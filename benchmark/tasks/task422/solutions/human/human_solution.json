[
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\n\nusing namespace std;\n\nset<int> base;\n\nstruct UnionFind {\n  vector<int> data;\n  UnionFind(int n):data(n, -1){}\n  int find(int x) {\n    return data[x] < 0 ? x : data[x] = find(data[x]);\n  }\n  bool same(int x, int y) {\n    return find(x) == find(y);\n  }\n  void unite(int x, int y) {\n    x = find(x), y = find(y);\n    if(x == y) return;\n    //if(data[x] < data[y]) swap(x, y);\n    if(!base.count(x)) swap(x, y);\n    data[x] += data[y];\n    data[y] = x;\n  }\n};\n\nstruct edge {\n  int from, to, cost;\n  edge(){}\n  edge(int from, int to, int cost):from(from), to(to), cost(cost){}\n  bool operator < (const edge& e) const {\n    return cost > e.cost;\n  }\n};\n\nusing Pi = pair<int, int>;\nusing Tapris = tuple<int, int, int>;\n\nvector<edge> es;\n\nint main() {\n  int n, t, k;\n  int T = 0;\n  while(cin >> n >> t >> k, n || t || k) {\n    base.clear();\n    es.clear();\n    for(int i = 0; i < n-1; i++) {\n      int a, b, c;\n      cin >> a >> b >> c;\n      --a, --b;\n      es.emplace_back(a, b, c);\n    }\n    UnionFind uf(n);\n    for(int i = 0; i < t; i++) {\n      int d; cin >> d; --d;\n      base.insert(d);\n    }\n    vector<int> ans;\n    sort(es.begin(), es.end());\n    for(int i = 0; i < n-1; i++) {\n      for(edge& e : es) {\n\tif(!uf.same(e.from, e.to)) {\n\t  int x = uf.find(e.from), y = uf.find(e.to);\n\t  if(base.count(x) && base.count(y)) {\n\t    ans.push_back(e.cost);\n\t  }\n\t  uf.unite(x, y);\n\t}\n      }\n    }\n    sort(ans.begin(), ans.end());\n    int total = 0;\n    for(int i = 0; i < k; i++) total += ans[i];\n    cout << \"Case \" << ++T << \": \" << total << endl;\n  }\n  return 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include <iostream>\n#include <vector>\n#include <map>\n#include <algorithm>\nusing namespace std;\n\nconst int MAX_V = 100000;\ntypedef pair<int,int> P;\nstruct edge{ int to,cost; };\n\n// グラフ (隣接リスト)\nvector<edge> G[MAX_V];\n// e = (u,v) , is_cost[e] := コスト\nmap<P,int> is_cost;\n// base[u] == true のとき ノード u は ベース\nbool base[MAX_V];\n// (cost,(u,v))の組\nvector< pair<int ,P> > a;\n// used[u] == true のとき ノード u は探索済み\nbool used[MAX_V];\n\nint n, t, k;\n\n\n// 初期化\nvoid init(){\n\ta.clear();\n\tis_cost.clear();\n\tfor(int i=0 ; i < MAX_V ; i++ ){\n\t\tbase[i] = false;\n\t\tG[i].clear();\n\t}\n}\n\n// グラフに重みcostのエッジ(u,v)を追加\nvoid add_edge(int u, int v, int cost){\n\tedge e;\n\te.to = v;\n\te.cost = cost;\n\tG[u].push_back( e );\n\te.to = u;\n\tG[v].push_back( e );\n}\n\n// グラフのエッジ(u,v)を切断\nvoid cut_edge(int u, int v){\n\tfor(vector<edge>::iterator it = G[u].begin() ; it != G[u].end() ; ++it ){\n\t\tif( (*it).to == v ){\n\t\t\tG[u].erase( it );\n\t\t\treturn ;\n\t\t}\n\t}\n}\n\n\n// ノード u の木にベースがあるかどうか\nvoid is_base(int u, bool& flag){\n\t\n\t// ノード u がベースのとき\n\tif( base[u] || flag ){\n\t\tflag = true;\n\t\treturn;\n\t}\n\t// ノード u が探索済みのとき\n\tif( used[u] ) return;\n\tused[u] = true;\n\t\n\tfor(int i=0 ; i < G[u].size() ; i++ ){\n\t\tedge e = G[u][i];\n\t\tis_base( e.to , flag );\n\t}\n}\n\nint solve(){\n\t\n\t// 連結成分の数\n\tint p=1;\n\t// コストの総和\n\tint sum = 0;\n\t\n\tsort( a.begin() , a.end() );\n\tfor(int i=0 ; i < a.size() ; i++ ){\n\t\tint cost = a[i].first;\n\t\tint u = a[i].second.first;\n\t\tint v = a[i].second.second;\n\t\tif( u > v ) swap(u,v);\n\t\t\n\t\tcut_edge( u , v );\n\t\t\n\t\tbool flag1 = false, flag2 = false;\n\t\tfor(int j=0 ; j < MAX_V ; j++ ) used[j] = false;\n\t\tis_base( u , flag1 );\n\t\tfor(int j=0 ; j < MAX_V ; j++ ) used[j] = false;\n\t\tis_base( v , flag2 );\n\t\t//flag1 = flag2 = true;\n\t\t\n\t\t// u,vの木の両方にベースを含むとき切断する\n\t\tif( flag1 && flag2 ){\n\t\t\t//sum += is_cost[P(u,v)];\n\t\t\tp++;\n\t\t}else{\n\t\t\t//add_edge( u , v , is_cost[P(u,v)] );\n\t\t}\n\t\t\n\t\t// 連結成分が K+1 個になったらループを抜ける\n\t\tif( p == k+1 ) break;\n\t}\n\treturn sum;\n}\n\nint main(){\n\tfor(int t_ = 1 ; cin >> n >> t >> k , (n || t || k) ; t_++ ){\n\t\t// 初期化\n\t\tinit();\n\t\t\n\t\tfor(int i = 0 ; i < n-1 ; i++ ){\n\t\t\tint u, v, cost;\n\t\t\tcin >> u >> v >> cost;\n\t\t\tu--; v--;\n\t\t\tif( u > v ) swap(u,v);\n\t\t\t\n\t\t\tis_cost[P(u,v)] = cost;\n\t\t\tadd_edge( u , v , cost );\n\t\t\tpair<int,P> p( cost , P(u,v) );\n\t\t\ta.push_back( p );\n\t\t}\n\t\tfor(int i = 0 ; i < t ; i++ ){\n\t\t\tint b;\n\t\t\tcin >> b;\n\t\t\tb--;\n\t\t\tbase[b] = true;\n\t\t}\n\t\t\n\t\tint ans = solve();\n\t\tcout << \"Case \" << t_ << \": \" << ans << endl;\n\t}\n}"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\n#define int long long\n#define N 100010\nusing namespace std;\nconst int INF = 1LL<<55;\nconst int mod = (1e9)+7;\nconst double EPS = 1e-8;\nconst double PI = 6.0 * asin(0.5);\ntemplate<class T> T Max(T &a,T b){return a=max(a,b);}\ntemplate<class T> T Min(T &a,T b){return a=min(a,b);}\n\n#define rank Asdfiasofsad\nclass UF{\npublic:\n  int V;\n  vector<int> par,rank,base;\n  UF(){}\n  UF(int V):V(V),par(V),rank(V,0),base(V,0){for(int i=0;i<V;i++)par[i]=i;}\n  \n  int find(int x){\n    assert(x < V);\n    if(par[x]==x)return x;\n    return par[x]=find(par[x]);\n  }\n  \n  void unite(int x,int y){\n    x=find(x), y=find(y);\n    if(x==y)return;\n    if(rank[x]<rank[y])par[x]=y, base[y] |= base[x];\n    else{\n      par[y]=x;\n      base[x] |= base[y];\n      if(rank[x]==rank[y])rank[x]++;\n    }\n  }\n\n  bool same(int x,int y){return find(x)==find(y);}\n};\n\nint n,k,t;\ntypedef pair<int,int> P;\ntypedef pair<int,P> PP;\nvector<int>  T;\nvector<PP> edge;\n\nint solve(){\n  sort(edge.begin(),edge.end());\n  int sum = 0;\n  for(int i=0;i<n-1;i++) sum += -edge[i].first;\n  UF uf(n);\n  for(int i=0;i<t;i++) uf.base[T[i]] = 1;\n  \n  int numBase = t,numNode = n;\n  for(int i=0;i<n-1;i++){\n    int a = edge[i].second.first;\n    int b = edge[i].second.second;\n    int c = -edge[i].first;\n    a = uf.find(a);\n    b = uf.find(b);\n    if(uf.same(a,b)) continue;\n    if(numBase == k+1 && uf.base[a] && uf.base[b]) continue;\n    if(numNode == k+1) continue;\n    if(uf.base[a] && uf.base[b]) numBase--;\n    numNode--;\n    sum -= c;\n    uf.unite(a,b);\n  }\n  return sum;\n}\n\nsigned main(){\n  int numCase = 0;\n  while(1){\n    cin>>n>>t>>k;\n    if(n == 0 && k == 0 && t == 0) break;\n    cout<<\"Case \"<<++numCase<<\": \";\n    \n    edge.resize(n-1);\n    for(int i=0;i<n-1;i++){\n      int a,b,c;\n      cin>>a>>b>>c; a--,b--;\n      edge[i] = PP(-c,P(a,b));\n    }\n    \n    T.resize(t);\n    for(int i=0;i<t;i++) cin>>T[i];\n   \n    cout<<solve()<<endl; \n  }\n\n\n\n  return 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include<cstdio>\n#include<algorithm>\n\n#define REP(i,s,n) for(int i=s;i<n;i++)\n#define rep(i,n) REP(i,0,n)\n\nusing namespace std;\n\nstruct Edge {\n  int src,dst,weight; \n  bool operator < ( const Edge &e ) const { return weight < e.weight; }\n};\n\nconst int MAX = 10010;\nint par[MAX];\n//vector<Edge> edges;\nEdge edges[MAX];\n\nvoid init(int _size=MAX) { rep(i,_size) par[i] = i; } \n\nint find(int x) {\n  if( par[x] == x ) return x;\n  return par[x] = find(par[x]);\n}\n\nvoid unit(int x,int y){\n  x = find(x), y = find(y);\n  if( x != y ) par[x] = y;\n}\n\nbool buffer[MAX];\nbool choose[MAX];\nint counter[MAX];\n//vector<int> bases;\nint bases[MAX];\nint V,t,k;\n\nbool isValid(int index){\n  choose[index] = false;\n  //map<int,int> mp;\n  rep(i,V) counter[i] = 0, par[i] = i;\n\n  rep(i,V-1) if( choose[i] ) unit(edges[i].src,edges[i].dst);\n  rep(i,t) ++counter[find(bases[i])];\n  rep(i,V) if( counter[find(i)] == 0 ) return false;\n  return true;\n}\n\nvoid compute(){\n  sort(edges,edges+V-1);\n  rep(i,V) buffer[i] = true;\n  int answer = 0;\n  int remain = k;\n  int cur = 0;\n  while( cur < V-1 && remain ){\n    rep(i,V) choose[i] = buffer[i];\n    if( isValid(cur) ) {\n      --remain;\n      answer += edges[cur].weight;\n      buffer[cur] = false;\n    }\n    ++cur;\n  }\n  printf(\"%d\\n\",answer);\n}\n\nint main(){\n  int CNT = 1;  \n  while( scanf(\" %d %d %d\",&V,&t,&k) , V|t|k ){\n    rep(i,V-1) {\n      int s,t,c;\n      scanf(\" %d %d %d\",&s,&t,&c);\n      --s, --t;\n      //edges.push_back((Edge){s,t,c});\n      edges[i] = (Edge){s,t,c};\n    }\n    rep(i,t){\n      int base;\n      scanf(\" %d\",&base);\n      --base;\n      //bases.push_back(base);\n      bases[i] = base;\n    }\n    printf(\"Case %d: \",CNT++);\n    compute();\n  }\n  return 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include<bits/stdc++.h>\n#define N 10005\n#define rank raljfds\nusing namespace std;\ntypedef pair<int,int> P;\ntypedef pair<int,P> P2;\n \nclass UF{\npublic:\n  int V;\n  vector<int> par, rank, mil;\n  UF(){}\n  UF(int V):V(V),par(V),rank(V,0),mil(V,-1){for(int i=0;i<V;i++) par[i]=i;}\n \n  int find(int x){\n    assert(x<V);\n    if(par[x]==x) return x;\n    return par[x]=find(par[x]);\n  }\n   \n  void unite(int x,int y){\n    x=find(x), y=find(y);\n    if(x==y)return;\n    \n    if(mil[x]!=-1) mil[y]=mil[x];\n    if(mil[y]!=-1) mil[x]=mil[y];\n    \n    if(rank[x]<rank[y]){\n      par[x]=y;\n    }\n    else{\n      par[y]=x;\n      if(rank[x]<rank[y]) rank[x]++;\n    }\n  }\n   \n  bool same(int x,int y){return find(x)==find(y);}\n   \n  void add_mil(int num){\n    mil[num]=num;\n  }\n   \n  int get_mil(int x){\n    return mil[find(x)];\n  }\n};\n \nint n,t,k;\nvector<P2> G;\nUF uf;\n \nint solve(){\n   \n  uf=UF(n);\n   \n  int milnum;\n   \n  for(int i=0;i<t;i++){\n \n    cin>>milnum;\n     \n    uf.add_mil(milnum-1);\n  }\n   \n  vector<int> ans;\n   \n  for(int idx=0;idx<G.size();idx++){\n     \n    int cost=G[idx].first;\n    int A=G[idx].second.first;\n    int B=G[idx].second.second;\n    \n    if(!(uf.get_mil(A)!=-1&&uf.get_mil(B)!=-1)) uf.unite(A,B);\n    else ans.push_back(cost);\n    \n  }\n \n  sort(ans.begin(),ans.end());\n \n  int res=0;\n  //  if(ans.size()<k) while(1);\n  for(int i=0;i<k;i++) res+=ans[i];\n   \n  return res;\n}\n \nint main(){\n \n  int T=1;\n   \n  while(1){\n \n    cin>>n>>t>>k;\n    if(!n&&!t&&!k) break;\n \n    int a,b,cost;\n     \n    for(int i=0;i<n-1;i++){\n       \n      cin>>a>>b>>cost;\n       \n      a--, b--;\n \n      G.push_back(P2(cost,P(a,b)));\n    }\n     \n    sort(G.begin(),G.end(),greater<P2>());\n     \n    cout<<\"Case \"<<T<<\": \";\n     \n    cout<<solve()<<endl;\n \n    G.clear();\n     \n    T++;\n  }\n   \n  return 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\nusing namespace std;\ntypedef long long ll;\ntypedef pair<int,int> Pii;\ntypedef pair<ll,ll> Pll;\n#define rep(i,n) for (ll i=0;i<n;++i)\n#define rep2(i,a,b) for (ll i=a;i<b;++i)\nconst ll MOD=1000000007;\nstruct edge{int cost, p1, p2;};\n\ntemplate<class T> inline bool chmin(T &a,T b){\n    if (a>b){\n        a=b;\n        return true;\n    }\n    return false;\n}\ntemplate<class T> inline bool chmax(T &a,T b){\n    if (a<b){\n        a=b;\n        return true;\n    }\n    return false;\n}\n\nstruct UnionFind {\n  vector<int> par,rank;\n\n  UnionFind (int N) : par(N),rank(N){\n    for (int i=0;i<N;i++){\n      par[i]=i;\n      rank[i]=0;\n    }\n  }\n\n  int root(int x){\n    if (par[x]==x){\n      return x;\n    }\n    return par[x]=root(par[x]);\n  }\n\n  void unite(int x, int y){\n    int rx = root(x);\n    int ry = root(y);\n    if (rx == ry){\n      return;\n    }\n    if (rank[rx]<rank[ry]){\n      par[rx]=ry;\n    }\n    else {\n      par[ry] = rx;\n      if (rank[rx]==rank[ry]){\n        rank[rx]++;\n      }\n    }\n  }\n\n  bool same(int x, int y){\n    int rx = root(x);\n    int ry = root(y);\n    return rx == ry;\n  }\n};\nint main(){\n    int Case=0;\n    int n,t,k,c=0;\n    while(cin >> n >> t >> k,n>0){\n        c++;\n        vector<vector<int>> es(n-1,vector<int>(3));\n        vector<vector<int>> G(n);\n        rep(i,n-1){\n            cin >> es[i][1] >> es[i][2] >> es[i][0];\n            es[i][1]--,es[i][2]--;\n            int a=es[i][1],b=es[i][2];\n            G[a].push_back(b);\n            G[b].push_back(a);\n        }\n        sort(es.begin(),es.end());\n        reverse(es.begin(),es.end());\n        set<int> s;\n        vector<ll> count(n,0);\n        rep(i,t){\n            int a;\n            cin >> a;\n            a--;\n            s.insert(a);\n            count[a]++;\n        }\n        ll ans=0;\n        UnionFind tree(n);\n        priority_queue<ll,vector<ll>,greater<ll>> pq;\n        rep(i,n-1){\n            int p=es[i][1],q=es[i][2];\n            if (count[tree.root(p)]>0&&count[tree.root(q)]>0){\n                pq.push(es[i][0]);\n                continue;\n            }\n            ll x=count[tree.root(p)]+count[tree.root(q)];\n            count[tree.root(p)]=count[tree.root(q)]=x;\n            tree.unite(p,q);\n        }\n        rep(i,k){\n            ll x=pq.top();\n            pq.pop();\n            ans+=x;\n        }\n        cout << \"Case \" << c << \": \" << ans << endl;\n    }\n}\n"
  },
  {
    "language": "C++",
    "code": "#include <iostream>\n#include <vector>\n#include <map>\n#include <algorithm>\nusing namespace std;\n\nconst int MAX_V = 100000;\ntypedef pair<int,int> P;\nstruct edge{ int to,cost; };\n\n// グラフ (隣接リスト)\nvector<edge> G[MAX_V];\n// e = (u,v) , is_cost[e] := コスト\nmap<P,int> is_cost;\n// base[u] == true のとき ノード u は ベース\nbool base[MAX_V];\n// (cost,(u,v))の組\nvector< pair<int ,P> > a;\n// used[u] == true のとき ノード u は探索済み\nbool used[MAX_V];\n\nint n, t, k;\n\n\n// 初期化\nvoid init(){\n\ta.clear();\n\tis_cost.clear();\n\tfor(int i=0 ; i < MAX_V ; i++ ){\n\t\tbase[i] = false;\n\t\tG[i].clear();\n\t}\n}\n\n// グラフに重みcostのエッジ(u,v)を追加\nvoid add_edge(int u, int v, int cost){\n\tedge e;\n\te.to = v;\n\te.cost = cost;\n\tG[u].push_back( e );\n\te.to = u;\n\tG[v].push_back( e );\n}\n\n// グラフのエッジ(u,v)を切断\nvoid cut_edge(int u, int v){\n\tfor(vector<edge>::iterator it = G[u].begin() ; it != G[u].end() ; ++it ){\n\t\tif( (*it).to == v ){\n\t\t\tG[u].erase( it );\n\t\t\treturn ;\n\t\t}\n\t}\n}\n\n\n// ノード u の木にベースがあるかどうか\nvoid is_base(int u, bool& flag){\n\t\n\t// ノード u がベースのとき\n\tif( base[u] || flag ){\n\t\tflag = true;\n\t\treturn;\n\t}\n\t// ノード u が探索済みのとき\n\tif( used[u] ) return;\n\tused[u] = true;\n\t\n\tfor(int i=0 ; i < G[u].size() ; i++ ){\n\t\tedge e = G[u][i];\n\t\tis_base( e.to , flag );\n\t}\n}\n\nint solve(){\n\t\n\t// 連結成分の数\n\tint p=1;\n\t// コストの総和\n\tint sum = 0;\n\t\n\tsort( a.begin() , a.end() );\n\tfor(int i=0 ; i < a.size() ; i++ ){\n\t\tint cost = a[i].first;\n\t\tint u = a[i].second.first;\n\t\tint v = a[i].second.second;\n\t\tif( u > v ) swap(u,v);\n\t\t\n\t\tcut_edge( u , v );\n\t\t\n\t\t/*bool flag1 = false, flag2 = false;\n\t\tfor(int j=0 ; j < MAX_V ; j++ ) used[j] = false;\n\t\t//is_base( u , flag1 );\n\t\tfor(int j=0 ; j < MAX_V ; j++ ) used[j] = false;\n\t\t//is_base( v , flag2 );\n\t\t//flag1 = flag2 = true;\n\t\t\n\t\t// u,vの木の両方にベースを含むとき切断する\n\t\tif( flag1 && flag2 ){\n\t\t\t//sum += is_cost[P(u,v)];\n\t\t\tp++;\n\t\t}else{\n\t\t\t//add_edge( u , v , is_cost[P(u,v)] );\n\t\t}\n\t\t\n\t\t// 連結成分が K+1 個になったらループを抜ける\n\t\tif( p == k+1 ) break;*/\n\t}\n\treturn sum;\n}\n\nint main(){\n\tfor(int t_ = 1 ; cin >> n >> t >> k , (n || t || k) ; t_++ ){\n\t\t// 初期化\n\t\tinit();\n\t\t\n\t\tfor(int i = 0 ; i < n-1 ; i++ ){\n\t\t\tint u, v, cost;\n\t\t\tcin >> u >> v >> cost;\n\t\t\tu--; v--;\n\t\t\tif( u > v ) swap(u,v);\n\t\t\t\n\t\t\tis_cost[P(u,v)] = cost;\n\t\t\tadd_edge( u , v , cost );\n\t\t\tpair<int,P> p( cost , P(u,v) );\n\t\t\ta.push_back( p );\n\t\t}\n\t\tfor(int i = 0 ; i < t ; i++ ){\n\t\t\tint b;\n\t\t\tcin >> b;\n\t\t\tb--;\n\t\t\tbase[b] = true;\n\t\t}\n\t\t\n\t\tint ans = solve();\n\t\tcout << \"Case \" << t_ << \": \" << ans << endl;\n\t}\n}"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\n#define int long long\n#define N 100010\nusing namespace std;\nconst int INF = 1LL<<55;\nconst int mod = (1e9)+7;\nconst double EPS = 1e-8;\nconst double PI = 6.0 * asin(0.5);\ntemplate<class T> T Max(T &a,T b){return a=max(a,b);}\ntemplate<class T> T Min(T &a,T b){return a=min(a,b);}\n\n#define rank Asdfiasofsad\nclass UF{\npublic:\n  int V;\n  vector<int> par,rank,base;\n  UF(){}\n  UF(int V):V(V),par(V),rank(V,0),base(V,0){for(int i=0;i<V;i++)par[i]=i;}\n  \n  int find(int x){\n    assert(x < V);\n    if(par[x]==x)return x;\n    return par[x]=find(par[x]);\n  }\n  \n  void unite(int x,int y){\n    x=find(x), y=find(y);\n    if(x==y)return;\n    if(rank[x]<rank[y])par[x]=y, base[y] |= base[x];\n    else{\n      par[y]=x;\n      base[x] |= base[y];\n      if(rank[x]==rank[y])rank[x]++;\n    }\n  }\n\n  bool same(int x,int y){return find(x)==find(y);}\n};\n\nint n,k,t;\ntypedef pair<int,int> P;\ntypedef pair<int,P> PP;\nvector<int>  T;\nvector<PP> edge;\n\nint solve(){\n  sort(edge.begin(),edge.end());\n  int sum = 0;\n  for(int i=0;i<n-1;i++) sum += -edge[i].first;\n  UF uf(n);\n  for(int i=0;i<t;i++) uf.base[T[i]] = 1;\n  \n  int numBase = t,numNode = n;\n  for(int i=0;i<n-1;i++){\n    int a = edge[i].second.first;\n    int b = edge[i].second.second;\n    int c = -edge[i].first;\n    a = uf.find(a);\n    b = uf.find(b);\n    if(uf.same(a,b)) continue;\n    if(numBase == k+1 && uf.base[a] && uf.base[b]) continue;\n    if(numNode == k+1) continue;\n    if(uf.base[a] && uf.base[b]) numBase--;\n    numNode--;\n    sum -= c;\n    uf.unite(a,b);\n  }\n  return sum;\n}\n\nsigned main(){\n  int numCase = 0;\n  while(1){\n    cin>>n>>t>>k;\n    if(n == 0 && k == 0 && t == 0) break;\n    cout<<\"Case \"<<++numCase<<\": \";\n    \n    edge.resize(n-1);\n    for(int i=0;i<n-1;i++){\n      int a,b,c;\n      cin>>a>>b>>c; a--,b--;\n      edge[i] = PP(-c,P(a,b));\n    }\n    \n    T.resize(t);\n    for(int i=0;i<t;i++) cin>>T[i],T[i]--;\n   \n    cout<<solve()<<endl; \n  }\n\n\n\n  return 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include <cstdio>\n#include <iostream>\n#include <vector>\n#include <algorithm>\n#include <tuple>\n#include <utility>\nusing namespace std;\n\n// Union-Find 木 (Verified: AtCoder Typical Contest 001 B)\nstruct UnionFind {\nprivate:\n    const int n;\n    int __size, base_size;\n    vector<int> uf, has_base;\npublic:\n    // 初期化 UnionFind uni(n) のように宣言すれば良い\n    UnionFind(int _n, vector<int> has_base_) : n(_n), __size(_n), uf(_n, -1), has_base(has_base_) {\n        base_size = 0;\n        for(auto e : has_base_) base_size += (e > 0);\n    }\n    // find (木の根を求める)\n    int find(int x) {return (uf[x] < 0) ? x : uf[x] = find(uf[x]);}\n    // x と y が同じ集合に属するかどうか\n    bool same(int x, int y) {return find(x) == find(y);}\n    // x が属する集合の要素数\n    int size(int x) {return -uf[find(x)];}\n    int base(int x) {return has_base[find(x)];}\n    // 集合はいくつあるか\n    int size()      {return __size;}\n    int size_base() {return base_size;}\n    // x と y の属する集合を併合\n    void unite(int x, int y) {\n        x = find(x); y = find(y);\n        if(x == y) return;\n        __size--;\n        if(uf[y] < uf[x]) swap(x, y);\n        if(has_base[x] and has_base[y]) base_size--;\n        has_base[x] += has_base[y];\n        uf[x] += uf[y]; uf[y] = x;\n    }\n};\n\nint solve_testcase(int case_num) {\n    int N, T, K; cin >> N >> T >> K;\n    if(N == 0 and T == 0 and K == 0) return 1;\n\n    vector<int> is_base(N);\n    vector< tuple<int, int, int> > edges;\n\n    int sum = 0;\n    for(int i=0; i<N-1; i++) {\n        int u, v, w; cin >> u >> v >> w;\n        u--; v--; sum += w;\n        edges.emplace_back(w, u, v);\n    }\n    sort(edges.rbegin(), edges.rend());\n\n    for(int i=0; i<T; i++) {\n        int v; cin >> v; v--;\n        is_base[v] = true;\n    }\n\n    int ans = sum, rem = N - 1 - K;\n    UnionFind uf(N, is_base);\n    for(auto e : edges) {\n        if(rem == 0) break;\n        int w, u, v; tie(w, u, v) = e;\n        // fprintf(stderr, \"edge (%d, %d), cost = %d, base = (%d, %d), size_base = %d\\n\", u, v, w, uf.base(u), uf.base(v), uf.size_base());\n        if(uf.same(u, v)) ans -= w, rem--;\n        else if(uf.base(u) and uf.base(v) and uf.size_base() == K+1) continue;\n        else {\n            uf.unite(u, v);\n            ans -= w, rem--;\n        }\n    }\n\n    printf(\"Case %d: %d\\n\", case_num, ans);\n    return 0;\n}\n\nint main() {\n    int t = 0;\n    while(!solve_testcase(++t));\n    return 0;\n}\n\n"
  },
  {
    "language": "C++",
    "code": "#ifdef stderr_path\n#define LOCAL\n#endif\n#ifdef LOCAL\n#define _GLIBCXX_DEBUG\n#else\n#pragma GCC optimize(\"Ofast\")\n#endif\n#include <algorithm>\n#include <bitset>\n#include <cassert>\n#include <chrono>\n#include <complex>\n#include <cstring>\n#include <deque>\n#include <functional>\n#include <iomanip>\n#include <iostream>\n#include <map>\n#include <queue>\n#include <random>\n#include <set>\n#include <stack>\n#include <unordered_map>\n#include <unordered_set>\n\n// #define NDEBUG\n#define debug_stream std::cerr\n#define iostream_untie true\n#define __precision__ 10\n\n#define all(v) std::begin(v), std::end(v)\n#define rall(v) std::rbegin(v), std::rend(v)\n#define __odd(n) ((n)&1)\n#define __even(n) (not __odd(n))\n#define __popcount(n) __builtin_popcountll(n)\n#define __clz32(n) __builtin_clz(n)\n#define __clz64(n) __builtin_clzll(n)\n#define __ctz32(n) __builtin_ctz(n)\n#define __ctz64(n) __builtin_ctzll(n)\n\nusing i64 = int_fast64_t;\nusing pii = std::pair<int, int>;\nusing pll = std::pair<int_fast64_t, int_fast64_t>;\ntemplate <class T>\nusing heap = std::priority_queue<T>;\ntemplate <class T>\nusing minheap = std::priority_queue<T, std::vector<T>, std::greater<T>>;\ntemplate <class T>\nconstexpr T inf = std::numeric_limits<T>::max() / T(2) - T(1123456);\n\nnamespace execution\n{\n    std::chrono::system_clock::time_point start_time, end_time;\n    void print_elapsed_time()\n    {\n        end_time = std::chrono::system_clock::now();\n        std::cerr << \"\\n----- Exec time : \";\n        std::cerr << std::chrono::duration_cast<std::chrono::milliseconds>(\n                         end_time - start_time)\n                         .count();\n        std::cerr << \" ms -----\\n\\n\";\n    }\n    struct setupper\n    {\n        setupper()\n        {\n            if(iostream_untie)\n            {\n                std::ios::sync_with_stdio(false);\n                std::cin.tie(nullptr);\n            }\n            std::cout << std::fixed << std::setprecision(__precision__);\n#ifdef stderr_path\n            if(freopen(stderr_path, \"a\", stderr))\n            {\n                std::cerr << std::fixed << std::setprecision(__precision__);\n            }\n#endif\n#ifdef stdout_path\n            if(not freopen(stdout_path, \"w\", stdout))\n            {\n                freopen(\"CON\", \"w\", stdout);\n                std::cerr << \"Failed to open the stdout file\\n\\n\";\n            }\n            std::cout << \"\";\n#endif\n#ifdef stdin_path\n            if(not freopen(stdin_path, \"r\", stdin))\n            {\n                freopen(\"CON\", \"r\", stdin);\n                std::cerr << \"Failed to open the stdin file\\n\\n\";\n            }\n#endif\n#ifdef LOCAL\n            std::cerr << \"----- stderr at LOCAL -----\\n\\n\";\n            atexit(print_elapsed_time);\n            start_time = std::chrono::system_clock::now();\n#else\n            fclose(stderr);\n#endif\n        }\n    } __setupper;\n} // namespace execution\n\nclass myclock_t\n{\n    std::chrono::system_clock::time_point built_pt, last_pt;\n    int built_ln, last_ln;\n    std::string built_func, last_func;\n    bool is_built;\n\n  public:\n    explicit myclock_t() : is_built(false)\n    {\n    }\n    void build(int crt_ln, const std::string &crt_func)\n    {\n        is_built = true;\n        last_pt = built_pt = std::chrono::system_clock::now();\n        last_ln = built_ln = crt_ln, last_func = built_func = crt_func;\n    }\n    void set(int crt_ln, const std::string &crt_func)\n    {\n        if(is_built)\n        {\n            last_pt = std::chrono::system_clock::now();\n            last_ln = crt_ln, last_func = crt_func;\n        }\n        else\n        {\n            debug_stream << \"[ \" << crt_ln << \" : \" << crt_func << \" ] \"\n                         << \"myclock_t::set failed (yet to be built!)\\n\";\n        }\n    }\n    void get(int crt_ln, const std::string &crt_func)\n    {\n        if(is_built)\n        {\n            std::chrono::system_clock::time_point crt_pt(\n                std::chrono::system_clock::now());\n            int64_t diff =\n                std::chrono::duration_cast<std::chrono::milliseconds>(crt_pt -\n                                                                      last_pt)\n                    .count();\n            debug_stream << diff << \" ms elapsed from\"\n                         << \" [ \" << last_ln << \" : \" << last_func << \" ]\";\n            if(last_ln == built_ln) debug_stream << \" (when built)\";\n            debug_stream << \" to\"\n                         << \" [ \" << crt_ln << \" : \" << crt_func << \" ]\"\n                         << \"\\n\";\n            last_pt = built_pt, last_ln = built_ln, last_func = built_func;\n        }\n        else\n        {\n            debug_stream << \"[ \" << crt_ln << \" : \" << crt_func << \" ] \"\n                         << \"myclock_t::get failed (yet to be built!)\\n\";\n        }\n    }\n};\n#ifdef LOCAL\nmyclock_t __myclock;\n#define build_clock() __myclock.build(__LINE__, __func__)\n#define set_clock() __myclock.set(__LINE__, __func__)\n#define get_clock() __myclock.get(__LINE__, __func__)\n#else\n#define build_clock() ((void)0)\n#define set_clock() ((void)0)\n#define get_clock() ((void)0)\n#endif\n\nnamespace std\n{\n    template <class RAitr>\n    void rsort(RAitr __first, RAitr __last)\n    {\n        sort(__first, __last, greater<>());\n    }\n    template <class T>\n    size_t hash_combine(size_t seed, T const &key)\n    {\n        return seed ^ (hash<T>()(key) + 0x9e3779b9 + (seed << 6) + (seed >> 2));\n    }\n    template <class T, class U>\n    struct hash<pair<T, U>>\n    {\n        size_t operator()(pair<T, U> const &pr) const\n        {\n            return hash_combine(hash_combine(0, pr.first), pr.second);\n        }\n    };\n    template <class tuple_t, size_t index = tuple_size<tuple_t>::value - 1>\n    struct tuple_hash_calc\n    {\n        static size_t apply(size_t seed, tuple_t const &t)\n        {\n            return hash_combine(\n                tuple_hash_calc<tuple_t, index - 1>::apply(seed, t),\n                get<index>(t));\n        }\n    };\n    template <class tuple_t>\n    struct tuple_hash_calc<tuple_t, 0>\n    {\n        static size_t apply(size_t seed, tuple_t const &t)\n        {\n            return hash_combine(seed, get<0>(t));\n        }\n    };\n    template <class... T>\n    struct hash<tuple<T...>>\n    {\n        size_t operator()(tuple<T...> const &t) const\n        {\n            return tuple_hash_calc<tuple<T...>>::apply(0, t);\n        }\n    };\n    template <class T, class U>\n    istream &operator>>(std::istream &s, pair<T, U> &p)\n    {\n        return s >> p.first >> p.second;\n    }\n    template <class T, class U>\n    ostream &operator<<(std::ostream &s, const pair<T, U> p)\n    {\n        return s << p.first << \" \" << p.second;\n    }\n    template <class T>\n    istream &operator>>(istream &s, vector<T> &v)\n    {\n        for(T &e : v)\n        {\n            s >> e;\n        }\n        return s;\n    }\n    template <class T>\n    ostream &operator<<(ostream &s, const vector<T> &v)\n    {\n        bool is_front = true;\n        for(const T &e : v)\n        {\n            if(not is_front)\n            {\n                s << ' ';\n            }\n            else\n            {\n                is_front = false;\n            }\n            s << e;\n        }\n        return s;\n    }\n    template <class tuple_t, size_t index>\n    struct tupleos\n    {\n        static ostream &apply(ostream &s, const tuple_t &t)\n        {\n            tupleos<tuple_t, index - 1>::apply(s, t);\n            return s << \" \" << get<index>(t);\n        }\n    };\n    template <class tuple_t>\n    struct tupleos<tuple_t, 0>\n    {\n        static ostream &apply(ostream &s, const tuple_t &t)\n        {\n            return s << get<0>(t);\n        }\n    };\n    template <class... T>\n    ostream &operator<<(ostream &s, const tuple<T...> &t)\n    {\n        return tupleos<tuple<T...>, tuple_size<tuple<T...>>::value - 1>::apply(\n            s, t);\n    }\n    template <>\n    ostream &operator<<(ostream &s, const tuple<> &t)\n    {\n        return s;\n    }\n    string revstr(string str)\n    {\n        reverse(str.begin(), str.end());\n        return str;\n    }\n} // namespace std\n\n#ifdef LOCAL\n#define dump(...)                                                              \\\n    debug_stream << \"[ \" << __LINE__ << \" : \" << __FUNCTION__ << \" ]\\n\",       \\\n        dump_func(#__VA_ARGS__, __VA_ARGS__)\ntemplate <class T>\nvoid dump_func(const char *ptr, const T &x)\n{\n    debug_stream << '\\t';\n    for(char c = *ptr; c != '\\0'; c = *++ptr)\n    {\n        if(c != ' ') debug_stream << c;\n    }\n    debug_stream << \" : \" << x << '\\n';\n}\ntemplate <class T, class... rest_t>\nvoid dump_func(const char *ptr, const T &x, rest_t... rest)\n{\n    debug_stream << '\\t';\n    for(char c = *ptr; c != ','; c = *++ptr)\n    {\n        if(c != ' ') debug_stream << c;\n    }\n    debug_stream << \" : \" << x << \",\\n\";\n    dump_func(++ptr, rest...);\n}\n#else\n#define dump(...) ((void)0)\n#endif\ntemplate <class P>\nvoid read_range(P __first, P __second)\n{\n    for(P i = __first; i != __second; ++i)\n        std::cin >> *i;\n}\ntemplate <class P>\nvoid write_range(P __first, P __second)\n{\n    for(P i = __first; i != __second;\n        std::cout << (++i == __second ? '\\n' : ' '))\n    {\n        std::cout << *i;\n    }\n}\n\n// substitue y for x iff x > y.\ntemplate <class T>\nbool chmin(T &x, const T &y)\n{\n    return x > y ? x = y, true : false;\n}\n// substitue y for x iff x < y.\ntemplate <class T>\nbool chmax(T &x, const T &y)\n{\n    return x < y ? x = y, true : false;\n}\n// binary search.\nint_fast64_t bin(int_fast64_t ok, int_fast64_t ng,\n                 const std::function<bool(int_fast64_t)> &f)\n{\n    while(std::abs(ok - ng) > 1)\n    {\n        int_fast64_t mid = (ok + ng) / 2;\n        (f(mid) ? ok : ng) = mid;\n    }\n    return ok;\n}\n// be careful that val is type-sensitive.\ntemplate <class T, class A, size_t N>\nvoid init(A (&array)[N], const T &val)\n{\n    std::fill((T *)array, (T *)(array + N), val);\n}\ntemplate <class A>\nvoid reset(A &array)\n{\n    memset(array, 0, sizeof(array));\n}\n\n/* The main code follows. */\n\nusing namespace std;\n\nsigned main()\n{\n    void __solve(int);\n\n    unsigned int t = 1;\n\n#ifdef LOCAL\n    t = 1;\n#endif\n\n    // cin >> t;\n    t = inf<int>;\n    int cas = 0;\n\n    while(t--)\n    {\n        cas++;\n        __solve(cas);\n    }\n}\n\nconst int winf = 1e5;\nvector<pii> g[10101];\nvector<int> eg;\nbool pt[10101];\nbool bas[10101];\n\nint dfs(int v, int p)\n{\n    int cnt = 0;\n    vector<int> tmp;\n    for(pii e : g[v])\n    {\n        int u, w;\n        tie(u, w) = e;\n        if(u != p)\n        {\n            int ww = dfs(u, v);\n            if(pt[u])\n            {\n                cnt++;\n                tmp.emplace_back(min(w, ww));\n            }\n        }\n    }\n    sort(all(tmp));\n    dump(tmp);\n    if(cnt)\n    {\n        if(bas[v])\n        {\n            for(int w : tmp)\n            {\n                eg.emplace_back(w);\n            }\n            pt[v] = 1;\n            return winf;\n        }\n        else\n        {\n            for(int w : tmp)\n            {\n                eg.emplace_back(w);\n            }\n            int ret = eg.back();\n            eg.pop_back();\n            pt[v] = 1;\n            return ret;\n        }\n    }\n    else\n    {\n        if(bas[v])\n        {\n            dump(v);\n            pt[v] = 1;\n        }\n        return winf;\n    }\n    return winf;\n}\n\nvoid __solve(int cas)\n{\n    reset(g);\n    reset(pt);\n    reset(bas);\n    eg.clear();\n\n    int n, t;\n    int k;\n    cin >> n >> t >> k;\n    if(not n and not t and not k)\n    {\n        exit(0);\n    }\n    for(int i = 0; i < n - 1; ++i)\n    {\n        int a, b, w;\n        cin >> a >> b >> w;\n        a--, b--;\n        g[a].emplace_back(b, w);\n        g[b].emplace_back(a, w);\n    }\n    for(int i = 0; i < t; ++i)\n    {\n        int v;\n        cin >> v;\n        v--;\n        bas[v] = 1;\n    }\n    const int root = 0;\n    dfs(root, -1);\n    sort(all(eg));\n    cout << \"Case \" << cas << \": \";\n    cout << accumulate(eg.begin(), eg.begin() + k, 0LL) << \"\\n\";\n}\n\n"
  },
  {
    "language": "C++",
    "code": "#include<bits/stdc++.h>\nusing namespace std;\n\nstruct unionfind{\n  int parent[200000];\n  int size[200000];\n  \n  void init(int n){\n    for(int i=0;i<n;i++){\n      parent[i]=i;\n      size[i]=1;\n    }\n  }\n  int find(int x){\n    if(parent[x]==x)return x;\n    else parent[x]=find(parent[x]);\n  }\n  bool same(int x,int y){\n    return (find(x)==find(y));\n  }\n  int getSize(int x){\n    return size[ find(x) ];\n  }\n  void unite(int x,int y){\n    x=find(x);\n    y=find(y);\n    if(x==y)return;\n    if(size[x]>size[y])swap(x,y);\n    parent[x]=y;\n    size[y]+=size[x];\n  }\n};\n  \nstruct edge{\n  int from,to,cost;\n  bool operator < (const edge &e) const {\n    return cost < e.cost;\n  }\n};\n\nint n,t,k;\nunionfind uf;\n\nint main(){\n\n  \n  for(int tc=1;;tc++){\n    cin>>n>>t>>k;\n    if(n==0&&t==0&&k==0)break;\n    vector<edge> E;\n\n    uf.init(n);\n    \n    for(int i=0;i<n-1;i++){\n      int a,b,c;\n      cin>>a>>b>>c;\n      a--,b--;\n      E.push_back( (edge){a,b,-c} );\n      uf.unite(a,b);\n    }\n    assert( uf.getSize(0) == n );\n    \n    for(int i=0;i<t;i++){\n      int a;\n      cin>>a;\n      a--;\n      E.push_back( (edge){a,n,-20000} );\n    }\n    sort(E.begin(),E.end());\n    \n    uf.init(n+1);\n\n    vector<edge> tmp;\n    \n    for(int i=0;i<(int)E.size();i++){\n      edge e=E[i];\n      if( uf.same(e.from,e.to) ){\n        tmp.push_back(e);\n      }else{\n        uf.unite(e.from,e.to);\n      }\n    }\n\n    int ans=0;\n    //    assert( (int)tmp.size() == t-1 );\n    \n    \n    for(int i=t-1-k;i<(int)tmp.size();i++){\n      ans-=tmp[i].cost;\n    }\n    cout<<\"Case \"<<tc<<\": \"<<ans<<endl;\n    \n  }\n  return 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include <iostream>\n#include <vector>\n#include <map>\n#include <algorithm>\nusing namespace std;\n\nconst int MAX_V = 100000;\ntypedef pair<int,int> P;\nstruct edge{ int to,cost; };\n\n// グラフ (隣接リスト)\nvector<edge> G[MAX_V];\n// e = (u,v) , is_cost[e] := コスト\nmap<P,int> is_cost;\n// base[u] == true のとき ノード u は ベース\nbool base[MAX_V];\n// (cost,(u,v))の組\nvector< pair<int ,P> > a;\n// used[u] == true のとき ノード u は探索済み\nbool used[MAX_V];\n\nint n, t, k;\n\n\n// 初期化\nvoid init(){\n\ta.clear();\n\tis_cost.clear();\n\tfor(int i=0 ; i < MAX_V ; i++ ){\n\t\tbase[i] = false;\n\t\tG[i].clear();\n\t}\n}\n\n// グラフに重みcostのエッジ(u,v)を追加\nvoid add_edge(int u, int v, int cost){\n\tedge e;\n\te.to = v;\n\te.cost = cost;\n\tG[u].push_back( e );\n\te.to = u;\n\tG[v].push_back( e );\n}\n\n// グラフのエッジ(u,v)を切断\nvoid cut_edge(int u, int v){\n\tfor(vector<edge>::iterator it = G[u].begin() ; it != G[u].end() ; ++it ){\n\t\tif( (*it).to == v ){\n\t\t\tG[u].erase( it );\n\t\t\treturn ;\n\t\t}\n\t}\n}\n\n\n// ノード u の木にベースがあるかどうか\nvoid is_base(int u, bool& flag){\n\t\n\t// ノード u がベースのとき\n\tif( base[u] || flag ){\n\t\tflag = true;\n\t\treturn;\n\t}\n\t// ノード u が探索済みのとき\n\tif( used[u] ) return;\n\tused[u] = true;\n\t\n\tfor(int i=0 ; i < G[u].size() ; i++ ){\n\t\tedge e = G[u][i];\n\t\tis_base( e.to , flag );\n\t}\n}\n\nint solve(){\n\t\n\t// 連結成分の数\n\tint p=1;\n\t// コストの総和\n\tint sum = 0;\n\t\n\tsort( a.begin() , a.end() );\n\tfor(int i=0 ; i < a.size() ; i++ ){\n\t\tint cost = a[i].first;\n\t\tint u = a[i].second.first;\n\t\tint v = a[i].second.second;\n\t\tif( u > v ) swap(u,v);\n\t\t\n\t\tcut_edge( u , v );\n\t\t\n\t\tbool flag1 = false, flag2 = false;\n\t\tfor(int j=0 ; j < MAX_V ; j++ ) used[j] = false;\n\t\t//is_base( u , flag1 );\n\t\tfor(int j=0 ; j < MAX_V ; j++ ) used[j] = false;\n\t\t//is_base( v , flag2 );\n\t\t//flag1 = flag2 = true;\n\t\t\n\t\t// u,vの木の両方にベースを含むとき切断する\n\t\tif( flag1 && flag2 ){\n\t\t\t//sum += is_cost[P(u,v)];\n\t\t\tp++;\n\t\t}else{\n\t\t\t//add_edge( u , v , is_cost[P(u,v)] );\n\t\t}\n\t\t\n\t\t// 連結成分が K+1 個になったらループを抜ける\n\t\tif( p == k+1 ) break;\n\t}\n\treturn sum;\n}\n\nint main(){\n\tfor(int t_ = 1 ; cin >> n >> t >> k , (n || t || k) ; t_++ ){\n\t\t// 初期化\n\t\tinit();\n\t\t\n\t\tfor(int i = 0 ; i < n-1 ; i++ ){\n\t\t\tint u, v, cost;\n\t\t\tcin >> u >> v >> cost;\n\t\t\tu--; v--;\n\t\t\tif( u > v ) swap(u,v);\n\t\t\t\n\t\t\tis_cost[P(u,v)] = cost;\n\t\t\tadd_edge( u , v , cost );\n\t\t\tpair<int,P> p( cost , P(u,v) );\n\t\t\ta.push_back( p );\n\t\t}\n\t\tfor(int i = 0 ; i < t ; i++ ){\n\t\t\tint b;\n\t\t\tcin >> b;\n\t\t\tb--;\n\t\t\tbase[b] = true;\n\t\t}\n\t\t\n\t\tint ans = solve();\n\t\tcout << \"Case \" << t_ << \": \" << ans << endl;\n\t}\n}"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\n//!===========================================================!//\n//!  dP     dP                          dP                    !//\n//!  88     88                          88                    !//\n//!  88aaaaa88a .d8888b. .d8888b. .d888b88 .d8888b. 88d888b.  !//\n//!  88     88  88ooood8 88'  `88 88'  `88 88ooood8 88'  `88  !//\n//!  88     88  88.  ... 88.  .88 88.  .88 88.  ... 88        !//\n//!  dP     dP  `88888P' `88888P8 `88888P8 `88888P' dP        !//\n//!===========================================================!//\nusing ld = long double;\nusing ll = long long;\nstd::mt19937 mt{std::random_device{}()};\ntemplate <typename F>\nconstexpr F PI() { return 3.1415926535897932385; }\ntemplate <typename T, std::size_t N>\nstd::ostream& operator<<(std::ostream& os, const std::array<T, N>& v)\n{\n    os << \"[\";\n    for (const auto& e : v) { os << e << \",\"; }\n    return (os << \"]\" << std::endl);\n}\ntemplate <typename T, typename A>\nstd::ostream& operator<<(std::ostream& os, const std::deque<T, A>& v)\n{\n    os << \"[\";\n    for (const auto& e : v) { os << e << \",\"; }\n    return (os << \"]\" << std::endl);\n}\ntemplate <typename K, typename T, typename C, typename A>\nstd::ostream& operator<<(std::ostream& os, const std::multimap<K, T, C, A>& v)\n{\n    os << \"[\";\n    for (const auto& e : v) { os << \"<\" << e.first << \": \" << e.second << \">,\"; }\n    return (os << \"]\" << std::endl);\n}\ntemplate <typename T, typename C, typename A>\nstd::ostream& operator<<(std::ostream& os, const std::multiset<T, C, A>& v)\n{\n    os << \"[\";\n    for (const auto& e : v) { os << e << \",\"; }\n    return (os << \"]\" << std::endl);\n}\ntemplate <typename K, typename T, typename C, typename A>\nstd::ostream& operator<<(std::ostream& os, const std::map<K, T, C, A>& v)\n{\n    os << \"[\";\n    for (const auto& e : v) { os << \"<\" << e.first << \": \" << e.second << \">,\"; }\n    return (os << \"]\" << std::endl);\n}\ntemplate <typename T1, typename T2>\nstd::ostream& operator<<(std::ostream& os, const std::pair<T1, T2>& v) { return (os << \"<\" << v.first << \",\" << v.second << \">\"); }\ntemplate <typename T1, typename T2, typename T3>\nstd::ostream& operator<<(std::ostream& os, const std::priority_queue<T1, T2, T3>& v)\n{\n    auto q = v;\n    os << \"[\";\n    while (not q.empty()) { os << q.top() << \",\", q.pop(); }\n    return os << \"]\\n\";\n}\ntemplate <typename T1, typename T2>\nstd::ostream& operator<<(std::ostream& os, const std::queue<T1>& v)\n{\n    auto q = v;\n    os << \"[\";\n    while (not q.empty()) { os << q.front() << \",\", q.pop(); }\n    return os << \"]\\n\";\n}\ntemplate <typename T, typename C, typename A>\nstd::ostream& operator<<(std::ostream& os, const std::set<T, C, A>& v)\n{\n    os << \"[\";\n    for (const auto& e : v) { os << e << \",\"; }\n    return (os << \"]\" << std::endl);\n}\ntemplate <typename T1, typename T2>\nstd::ostream& operator<<(std::ostream& os, const std::stack<T1>& v)\n{\n    auto q = v;\n    os << \"[\";\n    while (not q.empty()) { os << q.top() << \",\", q.pop(); }\n    return os << \"]\\n\";\n}\ntemplate <typename K, typename T, typename H, typename P, typename A>\nstd::ostream& operator<<(std::ostream& os, const std::unordered_multimap<K, T, H, P, A>& v)\n{\n    os << \"[\";\n    for (const auto& e : v) { os << \"<\" << e.first << \": \" << e.second << \">,\"; }\n    return (os << \"]\" << std::endl);\n}\ntemplate <typename T, typename H, typename P, typename A>\nstd::ostream& operator<<(std::ostream& os, const std::unordered_multiset<T, H, P, A>& v)\n{\n    os << \"[\";\n    for (const auto& e : v) { os << e << \",\"; }\n    return (os << \"]\" << std::endl);\n}\ntemplate <typename K, typename T, typename H, typename P, typename A>\nstd::ostream& operator<<(std::ostream& os, const std::unordered_map<K, T, H, P, A>& v)\n{\n    os << \"[\";\n    for (const auto& e : v) { os << \"<\" << e.first << \": \" << e.second << \">,\"; }\n    return (os << \"]\" << std::endl);\n}\ntemplate <typename T, typename H, typename P, typename A>\nstd::ostream& operator<<(std::ostream& os, const std::unordered_set<T, H, P, A>& v)\n{\n    os << \"[\";\n    for (const auto& e : v) { os << e << \",\"; }\n    return (os << \"]\" << std::endl);\n}\ntemplate <typename T, typename A>\nstd::ostream& operator<<(std::ostream& os, const std::vector<T, A>& v)\n{\n    os << \"[\";\n    for (const auto& e : v) { os << e << \",\"; }\n    return (os << \"]\" << std::endl);\n}\n#define show(x) std::cerr << #x << \" = \" << (x) << std::endl\n//!============================================!//\n//!    8888ba.88ba             oo              !//\n//!    88  `8b  `8b                            !//\n//!    88   88   88  .d8888b.  dP  88d888b.    !//\n//!    88   88   88  88'  `88  88  88'  `88    !//\n//!    88   88   88  88.  .88  88  88    88    !//\n//!    dP   dP   dP  `88888P8  dP  dP    dP    !//\n//!============================================!//\nint main()\n{\n    std::cin.tie(nullptr);\n    std::ios::sync_with_stdio(false);\n    for (int N, T, K, cnt = 1;; cnt++) {\n        std::cin >> N >> T >> K;\n        if (N == 0 and T == 0 and K == 0) { break; }\n        using P = std::pair<int, int>;\n        using PP = std::pair<int, P>;\n        std::vector<std::vector<PP>> g(N);\n        for (int i = 0, u, v, c; i < N - 1; i++) { std::cin >> u >> v >> c, u--, v--, g[u].push_back({c, {u, v}}), g[v].push_back({c, {v, u}}); }\n        std::vector<int> ruined(N, -1);\n        std::priority_queue<PP> Q;\n        for (int i = 0, p; i < T; i++) {\n            std::cin >> p, p--, ruined[p] = p;\n            for (const auto& pp : g[p]) { Q.push(pp); }\n        }\n        std::vector<PP> Q2;\n        while (not Q.empty()) {\n            const auto pp = Q.top();\n            Q.pop();\n            const int c = pp.first, u = pp.second.first, v = pp.second.second;\n            if (ruined[u] == ruined[v]) { continue; }\n            if (ruined[v] != -1) {\n                Q2.push_back({c, std::minmax(u, v)});\n            } else {\n                ruined[v] = ruined[u];\n                for (const auto& pp : g[v]) {\n                    if (ruined[v] == ruined[pp.second.second]) { continue; }\n                    Q.push(pp);\n                }\n            }\n        }\n        std::sort(Q2.begin(), Q2.end());\n        Q2.erase(std::unique(Q2.begin(), Q2.end()), Q2.end());\n        int ans = 0;\n        for (int i = 0; i < K; i++) { ans += Q2[i].first; }\n        std::cout << \"Case \" << cnt << \": \" << ans << \"\\n\";\n    }\n\n    return 0;\n}\n\n"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\n\nusing namespace std;\n\nconst int NMAX = 10010;\n\nint N, T, K;\nbool base[NMAX], locked[NMAX];\n\nstruct Edge {\n\tint id, x, y, cost;\n\tbool operator<(const Edge &rhs) const {\n\t\treturn cost < rhs.cost;\n\t}\n} E[NMAX];\nlist<pair<int, int>> Tree[NMAX];\n\nbool visited[NMAX];\nint nodes[NMAX];\nbool baseBfs(int node) {\n\tif (base[node])\n\t\treturn 1;\n\tfor (int i = 1; i <= nodes[0]; ++i)\n\t\tvisited[nodes[i]] = 0;\n\tnodes[0] = 0;\n\tqueue<int> Q;\n\tQ.push(node);\n\tvisited[node] = 1;\n\tnodes[++nodes[0]] = node;\n\twhile (!Q.empty()) {\n\t\tint now = Q.front();\n\t\tQ.pop();\n\t\tfor (auto it: Tree[now]) {\n\t\t\tif (visited[it.first] || locked[it.second])\n\t\t\t\tcontinue;\n\t\t\tif (base[it.first])\n\t\t\t\treturn 1;\n\t\t\tQ.push(it.first);\n\t\t\tvisited[it.first] = 1;\n\t\t\tnodes[++nodes[0]] = it.first;\n\t\t}\n\t}\n\treturn 0;\n}\n\nint main() {\n//\tassert(freopen(\"debug.in\", \"r\", stdin));\n//\tassert(freopen(\"debug.out\", \"w\", stdout));\n\n\tint i;\n\n\tint caseNumber = 1;\n\tcin >> N >> T >> K;\n\twhile (N != 0 || T != 0 || K != 0) {\n\t\tmemset(base, 0, sizeof base);\n\t\tmemset(locked, 0, sizeof locked);\n\n\t\tfor (i = 0; i < N - 1; ++i) {\n\t\t\tcin >> E[i].x >> E[i].y >> E[i].cost;\n\t\t\tE[i].id = i;\n\t\t\tTree[E[i].x].push_back({E[i].y, i});\n\t\t\tTree[E[i].y].push_back({E[i].x, i});\n\t\t}\n\t\tfor (i = 1; i <= N; ++i) {\n\t\t\tint value;\n\t\t\tcin >> value;\n\t\t\tbase[value] = 1;\n\t\t}\n\n\t\tsort(E, E + N - 1);\n\n\t\tint answer = 0;\n\t\tfor (i = 0; i < N - 1 && K; ++i) {\n\t\t\tlocked[i] = 1;\n\t\t\tbool currBfs = baseBfs(E[i].x);\n\t\t\tif (!currBfs) {\n\t\t\t\tlocked[i] = 0;\n\t\t\t\tcontinue;\n\t\t\t}\n\t\t\tcurrBfs = baseBfs(E[i].y);\n\t\t\tif (!currBfs) {\n\t\t\t\tlocked[i] = 0;\n\t\t\t\tcontinue;\n\t\t\t}\n\t\t\tanswer += E[i].cost;\n\t\t\t--K;\n\t\t}\n\n\t\tcout << \"Case \" << caseNumber++ << \": \" << answer << '\\n';\n\n\t\tfor (i = 1; i <= N; ++i)\n\t\t\tTree[i].clear();\n\n\t\tcin >> N >> T >> K;\n\t}\n\n\treturn 0;\n}\n\n"
  },
  {
    "language": "C++",
    "code": "#include<bits/stdc++.h>\n#define N 10005\n#define rank raljfds\nusing namespace std;\ntypedef pair<int,int> P;\ntypedef pair<int,P> P2;\n\nclass UF{\npublic:\n  int V;\n  vector<int> par, rank, mil;\n  UF(){}\n  UF(int V):V(V),par(V),rank(V,0),mil(V,-1){for(int i=0;i<V;i++) par[i]=i;}\n\n  int find(int x){\n    assert(x<V);\n    if(par[x]==x) return x;\n    return par[x]=find(par[x]);\n  }\n  \n  void unite(int x,int y){\n    x=find(x), y=find(y);\n    if(x==y)return;\n    if(rank[x]<rank[y]){\n      par[x]=y;\n      if(mil[x]!=-1) mil[y]=mil[x];\n      if(mil[y]!=-1) mil[x]=mil[y];\n    }\n    else{\n      par[y]=x;\n      if(rank[x]<rank[y]) rank[x]++;\n      if(mil[x]!=-1) mil[y]=mil[x];\n      if(mil[y]!=-1) mil[x]=mil[y];\n    }\n  }\n  \n  bool same(int x,int y){return find(x)==find(y);}\n  \n  void add_mil(int num){\n    mil[num]=num;\n  }\n  \n  int get_mil(int x){\n    return mil[par[x]];\n  }\n};\n\nint n,t,k;\nvector<P2> G;\n\nint solve(){\n  \n  UF uf(n);\n\n  int milnum;\n  \n  for(int i=0;i<t;i++){\n\n    cin>>milnum;\n    \n    uf.add_mil(milnum-1);\n  }\n  \n  int res=0, cnt=0, idx=0;\n\n  while(cnt!=t-1){\n    \n    P2 tmp=G[idx];\n    \n    int cost=G[idx].first;\n    int A=G[idx].second.first;\n    int B=G[idx].second.second;\n\n    if(!(uf.get_mil(A)!=-1&&uf.get_mil(B)!=-1)) uf.unite(A,B);\n    else res+=cost, cnt++;\n    \n    idx++;\n  }\n  \n  return res;\n}\n\nint main(){\n\n  int T=1;\n  \n  while(1){\n\n    cin>>n>>t>>k;\n    if(!n&&!t&&!k) break;\n\n    int a,b,cost;\n    \n    for(int i=0;i<n-1;i++){\n      \n      cin>>a>>b>>cost;\n      \n      a--, b--;\n\n      G.push_back(P2(cost,P(a,b)));\n    }\n    \n    sort(G.begin(),G.end(),greater<P2>());\n    \n    cout<<\"Case \"<<T<<\": \";\n    \n    cout<<solve()<<endl;\n\n    G.clear();\n    \n    T++;\n  }\n  \n  return 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include<bits/stdc++.h>\ntypedef long long int ll;\ntypedef unsigned long long int ull;\n#define BIG_NUM 2000000000\n#define MOD 1000000007\n#define EPS 0.000000001\nusing namespace std;\n\n\n#define NUM 10005\n\nstruct Edge{\n\tEdge(int arg_from,int arg_to,int arg_cost){\n\t\tfrom = arg_from;\n\t\tto = arg_to;\n\t\tcost = arg_cost;\n\t}\n\tbool operator<(const struct Edge &arg) const{\n\t\treturn cost > arg.cost;\n\t}\n\tint from,to,cost;\n};\n\nstruct Data{\n\tData(int arg_cost){\n\t\tcost = arg_cost;\n\t}\n\tbool operator<(const struct Data &arg) const{\n\t\treturn cost > arg.cost;\n\t}\n\tint cost;\n};\n\nint V,E;\nint num_base,num_destroy;\nint height[NUM],boss[NUM],base_count[NUM];\nint case_num;\nvector<Edge> G;\npriority_queue<Data> Q;\n\nint get_boss(int id){\n\tif(id == boss[id])return id;\n\telse{\n\t\treturn boss[id] = get_boss(boss[id]);\n\t}\n}\n\nbool is_same_group(int x,int y){\n\treturn get_boss(x) == get_boss(y);\n}\n\nvoid unite(int x,int y){\n\n\tint x_boss_id = get_boss(x);\n\tint y_boss_id = get_boss(y);\n\n\tif(x_boss_id == y_boss_id)return;\n\n\tif(height[x_boss_id] < height[y_boss_id]){\n\n\t\tbase_count[y_boss_id] += base_count[x_boss_id];\n\t\tboss[x_boss_id] = y_boss_id;\n\n\t}else{\n\n\t\tbase_count[x_boss_id] += base_count[y_boss_id];\n\t\tboss[y_boss_id] = x_boss_id;\n\t\tif(height[x_boss_id] == y_boss_id)height[x_boss_id]++;\n\t}\n}\n\nvoid init(){\n\n\tfor(int i = 0; i < V; i++){\n\t\tboss[i] = i;\n\t\theight[i] = 0;\n\t\tbase_count[i] = 0;\n\t}\n}\n\nvoid func(){\n\n\tG.clear();\n\twhile(!Q.empty())Q.pop();\n\tinit();\n\n\tint from,to,cost;\n\n\tfor(int loop = 0; loop < E; loop++){\n\n\t\tscanf(\"%d %d %d\",&from,&to,&cost);\n\t\tfrom--;\n\t\tto--;\n\t\tG.push_back(Edge(from,to,cost));\n\t}\n\n\tint tmp;\n\n\tfor(int loop = 0; loop < num_base; loop++){\n\n\t\tscanf(\"%d\",&tmp);\n\t\ttmp--;\n\t\tbase_count[tmp] = 1;\n\t}\n\n\tsort(G.begin(),G.end());\n\n\tint num_A,num_B;\n\n\tfor(int i = 0; i < E; i++){\n\n\t\tif(is_same_group(G[i].from,G[i].to))continue;\n\n\t\tnum_A = base_count[get_boss(G[i].from)];\n\t\tnum_B = base_count[get_boss(G[i].to)];\n\n\t\tif(num_A >= 1 && num_B >= 1){\n\t\t\tQ.push(G[i].cost);\n\t\t\tcontinue;\n\t\t}\n\n\t\tunite(G[i].from,G[i].to);\n\t}\n\n\tint count = 0,ans = 0;\n\n\twhile(count < num_destroy){\n\n\t\tans += Q.top().cost;\n\t\tQ.pop();\n\t\tcount++;\n\t}\n\n\tprintf(\"Case %d: %d\\n\",case_num,ans);\n\n\tcase_num++;\n}\n\nint main(){\n\n\tcase_num = 1;\n\n\twhile(true){\n\t\tscanf(\"%d %d %d\",&V,&num_base,&num_destroy);\n\t\tif(V == 0 && num_base == 0 && num_destroy == 0)break;\n\t\tE = V-1;\n\n\t\tfunc();\n\t}\n\n\treturn 0;\n}\n\n"
  },
  {
    "language": "C++",
    "code": "#include<bits/stdc++.h>\nusing namespace std;\n\nstruct unionfind{\n  int parent[200000];\n  int size[200000];\n  \n  void init(int n){\n    for(int i=0;i<n;i++){\n      parent[i]=i;\n      size[i]=1;\n    }\n  }\n  int find(int x){\n    if(parent[x]==x)return x;\n    else parent[x]=find(parent[x]);\n  }\n  bool same(int x,int y){\n    return (find(x)==find(y));\n  }\n  int getSize(int x){\n    return size[ find(x) ];\n  }\n  void unite(int x,int y){\n    x=find(x);\n    y=find(y);\n    if(x==y)return;\n    if(size[x]>size[y])swap(x,y);\n    parent[x]=y;\n    size[y]+=size[x];\n  }\n};\n  \nstruct edge{\n  int from,to,cost;\n  bool operator < (const edge &e) const {\n    return cost < e.cost;\n  }\n};\n\nint n,t,k;\nunionfind uf;\n\nint main(){\n\n  \n  for(int tc=1;;tc++){\n    cin>>n>>t>>k;\n    if(n==0&&t==0&&k==0)break;\n    vector<edge> E;\n\n    uf.init(n);\n    \n    for(int i=0;i<n-1;i++){\n      int a,b,c;\n      cin>>a>>b>>c;\n      a--,b--;\n      E.push_back( (edge){a,b,-c} );\n      uf.unite(a,b);\n    }\n    assert( uf.getSize(0) == n );\n    \n    for(int i=0;i<t;i++){\n      int a;\n      cin>>a;\n      a--;\n      E.push_back( (edge){a,n,-20000} );\n    }\n    sort(E.begin(),E.end());\n    \n    uf.init(n+1);\n\n    vector<edge> tmp;\n    \n    for(int i=0;i<(int)E.size();i++){\n      edge e=E[i];\n      if( uf.same(e.from,e.to) ){\n        tmp.push_back(e);\n      }else{\n        uf.unite(e.from,e.to);\n      }\n    }\n\n    reverse(tmp.begin(),tmp.end());\n    \n    int ans=0;\n    //    assert( (int)tmp.size() == t-1 );\n    for(int i=0;i< min(k,(int)tmp.size());i++){\n      ans-=tmp[i].cost;\n    }\n    cout<<\"Case \"<<tc<<\": \"<<ans<<endl;\n    \n  }\n  return 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include <iostream>\n#include <cstdio>\n#include <vector>\n#include <set>\n#include <map>\n#include <queue>\n#include <deque>\n#include <stack>\n#include <algorithm>\n#include <cstring>\n#include <functional>\n#include <cmath>\nusing namespace std;\n#define rep(i,n) for(int i=0;i<(n);++i)\n#define rep1(i,n) for(int i=1;i<=(n);++i)\n#define all(c) (c).begin(),(c).end()\n#define fs first\n#define sc second\n#define pb push_back\n#define show(x) cout << #x << \" \" << x << endl\nstruct edge{int from,to,cost;};\nbool operator<(const edge& x,const edge& y){\n\treturn x.cost>y.cost;\n}\nint par[10000],id[10000];\nvoid init(int n){\n\trep(i,n) par[i]=i;\n\trep(i,n) id[i]=-1;\n}\nint find(int x){\n\tif(x==par[x]) return x;\n\telse par[x]=find(par[x]);\n}\nvoid unite(int x,int y){\n\tx=find(x),y=find(y);\n\tif(id[x]>=0) par[y]=x;\n\telse par[x]=y;\n}\nvector<edge> es;\nint main(){\n\tint tt=0;\n\twhile(true){\n\t\ttt++;\n\t\tint n,t,k;\n\t\tcin>>n>>t>>k;\n\t\tif(n==0) break;\n\t\tes.clear();\n\t\tinit(n);\n\t\trep(i,n-1){\n\t\t\tint a,b,c;\n\t\t\tcin>>a>>b>>c;\n\t\t\tes.pb(edge{a-1,b-1,c});\n\t\t}\n\t\trep(i,t){\n\t\t\tint x;\n\t\t\tcin>>x;\n\t\t\tid[x-1]=x-1;\n\t\t}\n\t\tsort(all(es));\n\t\tvector<int> costs;\n\t\trep(i,n-1){\n\t\t\tint a=es[i].from,b=es[i].to,c=es[i].cost;\n\t\t\ta=find(a),b=find(b);\n\t\t\tif(id[a]>=0&&id[b]>=0) costs.pb(c);\n\t\t\telse unite(a,b);\n\t\t}\n\t\tsort(all(costs));\n//\t\tshow(costs.size());\n\t\tint sum=0;\n\t\trep(i,k) sum+=costs[i];\n\t\tprintf(\"Case %d: %d\\n\",tt,sum);\n\t}\n}"
  },
  {
    "language": "C++",
    "code": "#include<bits/stdc++.h>\nusing namespace std;\ntypedef pair<int,int> pii;\n\nint main(){\n  cin.tie(0); ios::sync_with_stdio(0);\n\n  int n,t,k,case_num = 0;\n  while(cin >> n >> t >> k, n){\n    case_num++;\n\n    set<int> costs;\n    vector< vector<pii> > tree(n);\n\n    for(int i=0;i<n-1;i++){\n      int a,b,c;\n      cin >> a >> b >> c;\n      a--; b--;\n      tree[a].push_back(pii(c,b));\n      tree[b].push_back(pii(c,a));\n      costs.insert(c);\n    }\n\n    vector<int> base(t), use(n,0);\n    for(int i=0;i<t;i++){\n      cin >> base[i];\n      base[i]--;\n      use[base[i]] = 1;\n    }\n\n    priority_queue<pii> q;\n    for(int v : base){\n      for(pii u : tree[v]){\n\tif(!use[u.second])q.push(u);\n      }\n    }\n\n    int cnt = 0;\n    while(q.size()){\n      assert(cnt<n);\n      cnt++;\n      pii p = q.top(); q.pop();\n      if(use[p.second])continue;\n      use[p.second] = 1;\n      costs.erase(p.first);\n\n      for(pii u : tree[p.second]){\n\tif(use[u.second])continue;\n\tq.push(u);\n      }\n    }\n\n    long long res = 0;\n    auto it = costs.begin();\n    for(int i=0;i<k;i++){\n      res += *it; it++;\n    }\n    cout << \"Case \" << case_num << \": \" << res << endl;\n  }\n}"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\n#define int long long\n#define N 100010\nusing namespace std;\nconst int INF = 1LL<<55;\nconst int mod = (1e9)+7;\nconst double EPS = 1e-8;\nconst double PI = 6.0 * asin(0.5);\ntemplate<class T> T Max(T &a,T b){return a=max(a,b);}\ntemplate<class T> T Min(T &a,T b){return a=min(a,b);}\n\n#define rank Asdfiasofsad\nclass UF{\npublic:\n  int V;\n  vector<int> par,rank,base;\n  UF(){}\n  UF(int V):V(V),par(V),rank(V,0),base(V,0){for(int i=0;i<V;i++)par[i]=i;}\n  \n  int find(int x){\n    assert(x < V);\n    if(par[x]==x)return x;\n    return par[x]=find(par[x]);\n  }\n  \n  void unite(int x,int y){\n    x=find(x), y=find(y);\n    if(x==y)return;\n    if(rank[x]<rank[y])par[x]=y, base[y] |= base[x];\n    else{\n      par[y]=x;\n      base[x] |= base[y];\n      if(rank[x]==rank[y])rank[x]++;\n    }\n  }\n\n  bool same(int x,int y){return find(x)==find(y);}\n};\n\nint n,k,t;\ntypedef pair<int,int> P;\ntypedef pair<int,P> PP;\nvector<int>  T;\nvector<PP> edge;\n\nint solve(){\n  sort(edge.begin(),edge.end());\n  int sum = 0;\n  for(int i=0;i<n-1;i++) sum += -edge[i].first;\n  UF uf(n);\n  for(int i=0;i<t;i++) uf.base[T[i]] = 1;\n  \n  int numBase = t,numNode = n;\n  for(int i=0;i<n-1;i++){\n    int a = edge[i].second.first;\n    int b = edge[i].second.second;\n    int c = -edge[i].first;\n    a = uf.find(a);\n    b = uf.find(b);\n    if(uf.same(a,b)) continue;\n    if(numBase == k+1 && uf.base[a] && uf.base[b]) continue;\n    if(numNode == k+1) continue;\n    if(uf.base[a] && uf.base[b]) numBase--;\n    numNode--;\n    sum -= c;\n    uf.unite(a,b);\n  }\n  return sum;\n}\n\nsigned main(){\n  int numCase = 0;\n  while(1){\n    cin>>n>>t>>k;\n    if(n == 0 && k == 0 && t == 0) break;\n    cout<<\"Case \"<<++numCase<<\": \";\n    \n    edge.resize(n-1);\n    for(int i=0;i<n-1;i++){\n      int a,b,c;\n      cin>>a>>b>>c; a--,b--;\n      edge[i] = PP(-c,P(a,b));\n    }\n    \n    T.resize(t);\n    for(int i=0;i<t;i++) cin>>T[i],T[i]--;\n   \n    cout<<solve()<<endl; \n  }\n\n\n\n  return 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include<bits/stdc++.h>\nusing namespace std;\n\nstruct unionfind{\n  \n  vector<int> parent;\n  vector<int> size;\n  \n  void init(int n){\n    size.clear();\n    parent.clear();\n    size.resize(n);\n    parent.resize(n);\n    \n    for(int i=0;i<n;i++){\n      parent[i]=i;\n      size[i]=1;\n    }\n  }\n  int find(int x){\n    if(parent[x]==x)return x;\n    else parent[x]=find(parent[x]);\n  }\n  bool same(int x,int y){\n    return (find(x)==find(y));\n  }\n  int getSize(int x){\n    return size[ find(x) ];\n  }\n  void unite(int x,int y){\n    x=find(x);\n    y=find(y);\n    if(x==y)return;\n    parent[x]=y;\n    size[y]+=size[x];\n  }\n};\n  \nstruct edge{\n  int from,to,cost;\n  bool operator < (const edge &e) const {\n    return cost < e.cost;\n  }\n};\n\nint n,t,k;\nunionfind uf;\n\nint main(){\n\n  \n  for(int tc=1;;tc++){\n    cin>>n>>t>>k;\n    if(n==0&&t==0&&k==0)break;\n    vector<edge> E;\n\n    uf.init(n);\n    \n    for(int i=0;i<n-1;i++){\n      int a,b,c;\n      cin>>a>>b>>c;\n      a--,b--;\n      E.push_back( (edge){a,b,-c} );\n      uf.unite(a,b);\n    }\n    assert( uf.getSize(0) == n );\n    \n    for(int i=0;i<t;i++){\n      int a;\n      cin>>a;\n      a--;\n      E.push_back( (edge){a,n,-20000} );\n    }\n    sort(E.begin(),E.end());\n    \n    uf.init(n+1);\n\n    vector<edge> tmp;\n    \n    for(int i=0;i<(int)E.size();i++){\n      edge e=E[i];\n      if( uf.same(e.from,e.to) ){\n        tmp.push_back(e);\n      }else{\n        uf.unite(e.from,e.to);\n      }\n    }\n\n    reverse(tmp.begin(),tmp.end());\n    \n    int ans=0;\n    for(int i=0;i< min(k,(int)tmp.size());i++){\n      ans-=tmp[i].cost;\n    }\n    cout<<\"Case \"<<tc<<\": \"<<ans<<endl;\n    \n  }\n  return 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include<bits/stdc++.h>\n#define N 10005\n#define rank raljfds\nusing namespace std;\ntypedef pair<int,int> P;\ntypedef pair<int,P> P2;\n \nclass UF{\npublic:\n  int V;\n  vector<int> par, rank, mil;\n  UF(){}\n  UF(int V):V(V),par(V),rank(V,0),mil(V,-1){for(int i=0;i<V;i++) par[i]=i;}\n \n  int find(int x){\n    assert(x<V);\n    if(par[x]==x) return x;\n    return par[x]=find(par[x]);\n  }\n   \n  void unite(int x,int y){\n    x=find(x), y=find(y);\n    if(x==y)return;\n    \n    if(mil[x]!=-1) mil[y]=mil[x];\n    if(mil[y]!=-1) mil[x]=mil[y];\n    \n    if(rank[x]<rank[y]) par[x]=y;\n    else{\n      par[y]=x;\n      if(rank[x]<rank[y]) rank[x]++;\n    }\n  }\n   \n  bool same(int x,int y){return find(x)==find(y);}\n   \n  void add_mil(int num){\n    mil[num]=num;\n  }\n   \n  int get_mil(int x){\n    return mil[find(x)];\n  }\n  \n};\n \nint n,t,k;\nvector<P2> G;\nUF uf;\n \nint solve(){\n   \n  uf=UF(n);\n   \n  int milnum;\n   \n  for(int i=0;i<t;i++){\n \n    cin>>milnum;\n     \n    uf.add_mil(milnum-1);\n  }\n   \n  vector<int> ans;\n   \n  for(int idx=0;idx<G.size();idx++){\n     \n    int cost=G[idx].first;\n    int A=G[idx].second.first;\n    int B=G[idx].second.second;\n    \n    if(!(uf.get_mil(A)!=-1&&uf.get_mil(B)!=-1)) uf.unite(A,B);\n    else ans.push_back(cost);\n    \n  }\n \n  sort(ans.begin(),ans.end());\n \n  int res=0;\n  \n  for(int i=0;i<k;i++) res+=ans[i];\n   \n  return res;\n}\n \nint main(){\n \n  int T=1;\n   \n  while(1){\n \n    cin>>n>>t>>k;\n    if(!n&&!t&&!k) break;\n \n    int a,b,cost;\n     \n    for(int i=0;i<n-1;i++){\n       \n      scanf(\"%d %d %d\",&a,&b,&cost);\n       \n      a--, b--;\n \n      G.push_back(P2(cost,P(a,b)));\n    }\n     \n    sort(G.begin(),G.end(),greater<P2>());\n     \n    cout<<\"Case \"<<T<<\": \";\n     \n    cout<<solve()<<endl;\n \n    G.clear();\n     \n    T++;\n  }\n   \n  return 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\n#define ll long long\n#define INF 1000000005\n#define MOD 1000000007\n#define EPS 1e-10\n#define rep(i,n) for(int i=0;i<(int)(n);++i)\n#define rrep(i,n) for(int i=(int)(n)-1;i>=0;--i)\n#define srep(i,s,t) for(int i=(int)(s);i<(int)(t);++i)\n#define each(a,b) for(auto& (a): (b))\n#define all(v) (v).begin(),(v).end()\n#define len(v) (int)(v).size()\n#define zip(v) sort(all(v)),v.erase(unique(all(v)),v.end())\n#define cmx(x,y) x=max(x,y)\n#define cmn(x,y) x=min(x,y)\n#define fi first\n#define se second\n#define pb push_back\n#define show(x) cout<<#x<<\" = \"<<(x)<<endl\n#define spair(p) cout<<#p<<\": \"<<p.fi<<\" \"<<p.se<<endl\n#define sar(a,n) cout<<#a<<\":\";rep(kbrni,n)cout<<\" \"<<a[kbrni];cout<<endl\n#define svec(v) cout<<#v<<\":\";rep(kbrni,v.size())cout<<\" \"<<v[kbrni];cout<<endl\n#define svecp(v) cout<<#v<<\":\";each(kbrni,v)cout<<\" {\"<<kbrni.first<<\":\"<<kbrni.second<<\"}\";cout<<endl\n#define sset(s) cout<<#s<<\":\";each(kbrni,s)cout<<\" \"<<kbrni;cout<<endl\n#define smap(m) cout<<#m<<\":\";each(kbrni,m)cout<<\" {\"<<kbrni.first<<\":\"<<kbrni.second<<\"}\";cout<<endl\n\nusing namespace std;\n\ntypedef pair<int,int> P;\ntypedef pair<ll,ll> pll;\ntypedef vector<int> vi;\ntypedef vector<vi> vvi;\ntypedef vector<ll> vl;\ntypedef vector<vl> vvl;\ntypedef vector<double> vd;\ntypedef vector<P> vp;\ntypedef vector<string> vs;\n\nconst int MAX_N = 10005;\n\nstruct edge\n{\n    int to,cost;\n};\n\nvector<edge> G[MAX_N];\nbool ok[MAX_N];\nint sub[MAX_N];\nint n,t,k;\n\nvoid dfs(int u,int p)\n{\n    sub[u] = 1;\n    each(e,G[u]){\n        int v = e.to;\n        if(p != v){\n            dfs(v,u);\n            sub[u] += sub[v];\n        }\n    }\n}\n\nvvi redfs(int u,int p)\n{\n    vvi dp(2,vi(sub[u]+1,INF));\n    int mx = 1;\n    if(ok[u]){\n        dp[1][1] = 0;\n    }else{\n        dp[0][1] = 0;\n    }\n    each(e,G[u]){\n        cmn(mx,k+1);\n        int v = e.to, c = e.cost;\n        if(p != v){\n            vvi res = redfs(v,u);\n            // rep(i,2){\n            //     rep(j,len(res[i])){\n            //         cout << v << \" \" << i << \" \" << j << \" \" << res[i][j] << \"\\n\";\n            //     }\n            // }\n            vvi dp2(2,vi(mx+len(res[0]),INF));\n            srep(i,1,mx+1){\n                srep(j,1,len(res[0])){\n                    if(ok[u]){\n                        cmn(dp2[1][i+j-1],dp[1][i]+res[0][j]);\n                        cmn(dp2[1][i+j-1],dp[1][i]+res[1][j]);\n                        cmn(dp2[1][i+j],dp[1][i]+res[1][j]+c);\n                    }else{\n                        cmn(dp2[0][i+j-1],dp[0][i]+res[0][j]);\n                        cmn(dp2[0][i+j],dp[0][i]+res[1][j]+c);\n                        cmn(dp2[1][i+j-1],dp[0][i]+res[1][j]);\n                        cmn(dp2[1][i+j-1],dp[1][i]+res[0][j]);\n                        cmn(dp2[1][i+j-1],dp[1][i]+res[1][j]);\n                        cmn(dp2[1][i+j],dp[1][i]+res[1][j]+c);\n                    }\n                }\n            }\n            mx += len(res[0]) - 1;\n            rep(i,2){\n                rep(j,mx+1){\n                    dp[i][j] = dp2[i][j];\n                }\n            }\n            // rep(i,2){\n            //     rep(j,mx+1){\n            //         cout << i << \" \" << j << \" \" << dp[i][j] << \"\\n\";\n            //     }\n            // }\n        }\n    }\n    return dp;\n}\n\nint main()\n{\n    cin.tie(0);\n    ios::sync_with_stdio(false);\n    int id = 0;\n    while(1){\n        cin >> n >> t >> k;\n        if(n == 0){\n            break;\n        }\n        rep(i,n){\n            G[i].clear(),ok[i] = false;\n        }\n        rep(i,n-1){\n            int a,b,c;\n            cin >> a >> b >> c;\n            G[a-1].pb((edge){b-1,c}),G[b-1].pb((edge){a-1,c});\n        }\n        rep(i,t){\n            int a;\n            cin >> a;\n            --a;\n            ok[a] = true;\n        }\n        dfs(0,-1);\n        vvi ans = redfs(0,-1);\n        cout << \"Case \" << ++id << \": \" << ans[1][k+1] << \"\\n\";\n    }\n    return 0;\n}\n\n"
  },
  {
    "language": "C++",
    "code": "#include<iostream>\n#include<cstdlib>\n#include<cstring>\n#include<cstdio>\n#include<cmath>\n#include<ctime>\n#include<algorithm>\n#include<list>\n#include<queue>\n#include<stack>\n#include<vector>\n#include<set>\n#include<map>\n#include<bitset>\n#include<string>\n#define sgn(v) (abs((v))<eps?0:((v)<0?-1:1))\n#define sqr(v) ((v)*(v))\n#define mb make_pair\n#define debug 0\nusing namespace std;\ntypedef long long LL;\ntypedef unsigned long long ULL;\ntypedef pair<int,int> PII;\ntypedef pair<int,LL> PIL;\ntypedef pair<LL,int> PLI;\ntypedef pair<LL,LL> PLL;\nconst double eps=1e-9;\nconst double pi=acos(-1);\nconst int maxn=1e4+10;\nstruct Edge\n{\n\tint v,next,w;\n}edge[maxn*2];\nint ne,head[maxn];\nbool hv[maxn];\nvoid add(int u,int v,int w)\n{\n\tedge[ne].v=v;\n\tedge[ne].next=head[u];\n\tedge[ne].w=w;\n\thead[u]=ne++;\n}\nvector<int> ve,vt;\nint dfs(int u,int pre)\n{\n\tint i,v,pv;\n\tif(hv[u])\n\t{\n\t\tfor(i=head[u];i!=-1;i=edge[i].next)\n\t\t{\n\t\t\tv=edge[i].v;\n\t\t\tif((i^pre)==1)continue;\n\t\t\tpv=dfs(v,i);\n\t\t\tif(pv!=-1)ve.push_back(pv);\n\t\t}\n\t\tif(pre!=-1)return edge[pre].w;\n\t\telse return -1;\n\t}\n\telse\n\t{\n\t\tvt.clear();\n\t\tfor(i=head[u];i!=-1;i=edge[i].next)\n\t\t{\n\t\t\tv=edge[i].v;\n\t\t\tif((i^pre)==1)continue;\n\t\t\tpv=dfs(v,i);\n\t\t\tif(pv!=-1)vt.push_back(pv);\n\t\t}\n\t\tsort(vt.begin(),vt.end());\t\n\t\tfor(i=0;i<vt.size()-1;++i)\n\t\t\tve.push_back(vt[i]);\n\t\tif(pre!=-1&&vt.size()>0)return min(edge[pre].w,vt[i]);\n\t\telse if(pre==-1&&vt.size()>0)return vt[i];\n\t\telse if(pre!=-1&&vt.size()==0)return edge[pre].w;\n\t\telse return -1;\n\t}\n}\nint main()\n{\n\tint n,t,k,cas=0;\n\tint i,u,v,w,sum;\n\twhile(scanf(\"%d%d%d\",&n,&t,&k)!=0)\n\t{\n\t\tif(n==0&&t==0&&k==0)break;\n\t\tne=0;\n\t\tmemset(head,-1,sizeof(head));\n\t\tmemset(hv,0,sizeof(hv));\n\t\tfor(i=1;i<n;++i)\n\t\t{\n\t\t\tscanf(\"%d%d%d\",&u,&v,&w);\n\t\t\tadd(u,v,w),add(v,u,w);\n\t\t}\n\t\tfor(i=0;i<t;++i)\n\t\t{\n\t\t\tscanf(\"%d\",&u);\n\t\t\thv[u]=true;\n\t\t}\n\t\tve.clear();\n\t\tsum=0;\n\t\tu=dfs(n/2+1,-1);\n\t\tif(u!=-1)ve.push_back(u);\n\t\tsort(ve.begin(),ve.end());\n\t\tfor(i=0;i<ve.size()&&i<k;++i)sum+=ve[i];\n\t\tprintf(\"Case %d: %d\\n\",++cas,sum);\n\t}\n\treturn 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include<bits/stdc++.h>\n\nusing namespace std;\n\nstruct edge\n{\n  int to, cost;\n};\n\ntypedef pair< int, int > Pi;\n\nint main()\n{\n  int N, T, K;\n  int A[10000], B[10000], C[10000];\n  int testcase = 1;\n\n  while(scanf(\"%d %d %d\", &N, &T, &K), N) {\n\n    vector< edge > g[10000];\n    int deg[10000] = {};\n    bool M[10000] = {};\n    priority_queue< Pi, vector< Pi >, greater<> > que;\n\n    for(int i = 1; i < N; i++) {\n      scanf(\"%d %d %d\", &A[i], &B[i], &C[i]);\n      --A[i], --B[i];\n      g[A[i]].emplace_back((edge) {B[i], C[i]});\n      g[B[i]].emplace_back((edge) {A[i], C[i]});\n      ++deg[A[i]];\n      ++deg[B[i]];\n      que.emplace(C[i], i);\n    }\n\n    for(int i = 0; i < T; i++) {\n      int x;\n      scanf(\"%d\", &x);\n      --x;\n      M[x] = true;\n    }\n\n    queue< int > beet;\n    bool live[10000];\n    for(int i = 0; i < N; i++) {\n      if(deg[i] == 1) {\n        deg[i]--;\n        beet.emplace(i);\n      }\n      live[i] = true;\n    }\n\n    auto update = [&]()\n    {\n      while(!beet.empty()) {\n        int p = beet.front();\n        beet.pop();\n        if(M[p]) continue;\n        live[p] = false;\n        for(auto &e : g[p]) {\n          if(live[e.to]) {\n            deg[e.to]--;\n            if(deg[e.to] <= 1) beet.emplace(e.to);\n          }\n        }\n      }\n    };\n\n    int ret = 0;\n    for(int i = 0; i < K; i++) {\n      update();\n      while(!que.empty()) {\n        int cost, idx;\n        tie(cost, idx) = que.top();\n        que.pop();\n        if(!live[A[idx]] || !live[B[idx]]) continue;\n        ret += cost;\n        --deg[A[idx]];\n        --deg[B[idx]];\n        if(deg[A[idx]] <= 1) beet.emplace(A[idx]);\n        if(deg[B[idx]] <= 1) beet.emplace(B[idx]);\n        break;\n      }\n    }\n\n    printf(\"Case %d: %d\\n\", testcase++, ret);\n  }\n}"
  },
  {
    "language": "C++",
    "code": "#include<cstdio>\n#include<vector>\n#include<utility>\n#include<algorithm>\n\nusing namespace std;\n\ntypedef pair<int,int> P;\n\nvector<P> G[10100];\nbool isBase[10100];\nint baseNum[10100];\n\nint par[10100];\n\nvector<P> es;\nint N;\n\nvoid init(){\n\tfor(int i=0;i<N;i++){\n\t\tG[i].clear();\n\t\tisBase[i]=false;\n\t\tbaseNum[i]=0;\n\t}\n\tes.clear();\n}\n\nvoid dfs(int v,int p){\n\tbaseNum[v]=isBase[v]?1:0;\n\tpar[v]=p;\n\tfor(int i=0;i<G[v].size();i++){\n\t\tint u=G[v][i].first;\n\t\tif(u==p){\n\t\t\tes.push_back(P(G[v][i].second,v));\n\t\t}else{\n\t\t\tdfs(u,v);\n\t\t\tbaseNum[v]+=baseNum[u];\n\t\t}\n\t}\n}\n\nint main(){\n\tint datano=0;\n\twhile(true){\n\t\tdatano++;\n\t\tinit();\n\t\tint T,K;\n\t\tscanf(\"%d%d%d\",&N,&T,&K);\n\t\tif(N==0) break;\n\t\tfor(int i=0;i<N-1;i++){\n\t\t\tint u,v,c;\n\t\t\tscanf(\"%d%d%d\",&u,&v,&c);\n\t\t\tu--;v--;\n\t\t\tG[u].push_back(P(v,c));\n\t\t\tG[v].push_back(P(u,c));\n\t\t}\n\t\tfor(int i=0;i<T;i++){\n\t\t\tint in;\n\t\t\tscanf(\"%d\",&in);\n\t\t\tin--;\n\t\t\tisBase[in]=true;\n\t\t}\n\t\tdfs(0,-1);\n\t\tsort(es.begin(),es.end());\n\t\tint ans=0;\n\t\tint cnt=0;\n\t\tfor(int i=0;i<N-1;i++){\n\t\t\tint v=es[i].second;\n\t\t\tint p=par[v];\n\t\t\tint c=es[i].first;\n\t\t\tint x=baseNum[v];\n\t\t\tint y=0;\n\t\t\tint tmp=p;\n\t\t\twhile(p!=-1){\n\t\t\t\ty=max(y,baseNum[p]);\n\t\t\t\tp=par[p];\n\t\t\t}\n\t\t\tif(x>0&&y>x){\n\t\t\t\tp=tmp;\n\t\t\t\twhile(p!=-1){\n\t\t\t\t\tbaseNum[p]-=x;\n\t\t\t\t\tp=par[p];\n\t\t\t\t}\n\t\t\t\tpar[tmp]=-1;\n\t\t\t\tans+=c;\n\t\t\t}\n\t\t}\n\t\tprintf(\"Case %d: %d\\n\",datano,ans);\n\t}\n\treturn 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include<bits/stdc++.h>\n\nusing namespace std;\n\nstruct edge\n{\n  int to, cost;\n};\n\ntypedef pair< int, int > Pi;\n\nint main()\n{\n  int N, T, K;\n  int A[10000], B[10000], C[10000];\n  int testcase = 1;\n\n  while(scanf(\"%d %d %d\", &N, &T, &K), N) {\n\n    vector< edge > g[10000];\n    int deg[10000] = {};\n    bool M[10000] = {};\n    priority_queue< Pi, vector< Pi >, greater<> > que;\n\n    for(int i = 1; i < N; i++) {\n      scanf(\"%d %d %d\", &A[i], &B[i], &C[i]);\n      --A[i], --B[i];\n      g[A[i]].emplace_back((edge) {B[i], C[i]});\n      g[B[i]].emplace_back((edge) {A[i], C[i]});\n      ++deg[A[i]];\n      ++deg[B[i]];\n      que.emplace(C[i], i);\n    }\n\n    for(int i = 0; i < T; i++) {\n      int x;\n      scanf(\"%d\", &x);\n      --x;\n      M[x] = true;\n    }\n\n    queue< int > beet;\n    bool live[10000];\n    for(int i = 0; i < N; i++) {\n      if(deg[i] == 1) {\n        deg[i]--;\n        beet.emplace(i);\n      }\n      live[i] = true;\n    }\n\n    auto update = [&]()\n    {\n      while(!beet.empty()) {\n        int p = beet.front();\n        beet.pop();\n        if(M[p]) continue;\n        live[p] = false;\n        for(auto &e : g[p]) {\n          if(live[e.to]) {\n            deg[e.to]--;\n            if(deg[e.to] == 0) beet.emplace(e.to);\n          }\n        }\n      }\n    };\n\n    int ret = 0;\n    for(int i = 0; i < K; i++) {\n      update();\n      while(!que.empty()) {\n        int cost, idx;\n        tie(cost, idx) = que.top();\n        que.pop();\n        if(!live[A[idx]] || !live[B[idx]]) continue;\n        ret += cost;\n        --deg[A[idx]];\n        --deg[B[idx]];\n        if(deg[A[idx]] <= 1) beet.emplace(A[idx]);\n        if(deg[B[idx]] <= 1) beet.emplace(B[idx]);\n        break;\n      }\n    }\n\n    printf(\"Case %d: %d\\n\", testcase++, ret);\n  }\n}"
  },
  {
    "language": "C++",
    "code": "// Template {{{\n#include <bits/stdc++.h>\n#define REP(i,n) for(int i=0; i<(int)(n); ++i)\nusing namespace std;\ntypedef long long LL;\n\n#ifdef LOCAL\n#include \"contest.h\"\n#else\n#define dump(x) \n#endif\n\nclass range {\n    struct Iterator {\n        int val, inc;\n        int operator*() {return val;}\n        bool operator!=(Iterator& rhs) {return val < rhs.val;}\n        void operator++() {val += inc;}\n    };\n    Iterator i, n;\n    public:\n    range(int e) : i({0, 1}), n({e, 1}) {}\n    range(int b, int e) : i({b, 1}), n({e, 1}) {}\n    range(int b, int e, int inc) : i({b, inc}), n({e, inc}) {}\n    Iterator& begin() {return i;}\n    Iterator& end() {return n;}\n};\n\nconst int dx[4] = {1, 0, -1, 0};\nconst int dy[4] = {0, 1, 0, -1};\ninline bool valid(int x, int w) { return 0 <= x && x < w; }\n\nvoid iostream_init() {\n    ios::sync_with_stdio(false);\n    cin.tie(0);\n    cout.setf(ios::fixed);\n    cout.precision(12);\n}\n//}}}\n\nnamespace {\n    struct Edge{\n        int dst, cost;\n    };\n    typedef vector<Edge> Node;\n    typedef vector<Node> Graph;\n    Graph G;\n    typedef tuple<int, int, int> TP;\n    vector<TP> es;\n    vector<bool> is_base;\n    int N, T, K;\n\n    set<int> used[10000];\n\n    bool find(int u, int p) {\n        if(is_base[u]) return true;\n        for(Edge e : G[u]) {\n            if(e.dst == p) continue;\n            if(used[u].count(e.dst)) continue;\n            if(find(e.dst, u)) return true;\n        }\n        return false;\n    }\n\n    int solve() {\n        REP(i, N) used[i].clear();\n        int ans = 0;\n        for(auto tp : es) {\n            if(K == 0) break;\n            int w, a, b;\n            tie(w, a, b) = tp;\n            if(find(a, b) && find(b, a)) {\n                K--;\n                ans += w;\n                used[a].insert(b);\n                used[b].insert(a);\n            }\n        }\n        return ans;\n    }\n}\n\n\nint main(){\n    iostream_init();\n    int Case = 0;\n    while(cin >> N >> T >> K && N > 0) {\n        cout << \"Case \" << ++Case << \": \";\n        G.assign(N, Node());\n        es.clear();\n        is_base.assign(N, false);\n\n        REP(i, N-1) {\n            int a, b, w;\n            cin >> a >> b >> w;\n            a--; b--;\n            G[a].push_back({b, w});\n            G[b].push_back({a, w});\n            es.push_back(TP(w, a, b));\n        }\n        sort(es.begin(), es.end());\n\n        REP(i, T){\n            int base;\n            cin >> base;\n            base--;\n            is_base[base] = true;\n        }\n\n        cout << solve() << endl;\n    }\n    return 0;\n}\n\n/* vim:set foldmethod=marker: */"
  },
  {
    "language": "C++",
    "code": "#include <iostream>\n#include <utility>\n#include <tuple>\n#include <vector>\n#include <string>\n#include <map>\n#include <unordered_map>\n#include <set>\n#include <unordered_set>\n#include <algorithm>\n#include <functional>\n#include <climits>\n#include <numeric>\n#include <queue>\n#include <cmath>\n#include <iomanip>\n#include <array>\n#include <string>\n#include <stack>\n#include <cassert>\n#include <memory>\n#include <random>\n#include <fstream>\n#include <cfloat>\n#include <complex>\nusing namespace std;\nstruct Edge {\n\tint from, to, cost;\n};\nclass UnionFindTree {\n\tvector<int> vec;\npublic:\n\tUnionFindTree(int size) : vec(size, -1) {};\n\tint find(int a) {\n\t\treturn vec[a] < 0 ? a : vec[a] = find(vec[a]);\n\t}\n\tbool same(int a, int b) {\n\t\treturn find(a) == find(b);\n\t}\n\tbool unite(int a, int b) {\n\t\ta = find(a);\n\t\tb = find(b);\n\t\tif (a == b) return false;\n\t\tif (vec[a] > vec[b]) swap(a, b);\n\t\tvec[a] += vec[b];\n\t\tvec[b] = a;\n\t\treturn true;\n\t}\n};\nint main() {\n\tint test_case{ 0 };\n\twhile (true) {\n\t\tint n, t, k; cin >> n >> t >> k;\n\t\tif (n == 0 && t == 0 && k == 0) break;\n\t\tvector<Edge> edges(n - 1);\n\t\tfor (auto& e : edges)\n\t\t\tcin >> e.from >> e.to >> e.cost;\n\t\tUnionFindTree uft(n + 1);\n\t\tfor (auto i = 0; i < t; ++i) {\n\t\t\tint base; cin >> base;\n\t\t\tuft.unite(base, 0);\n\t\t}\n\t\tsort(edges.rbegin(), edges.rend(), [](const Edge& a, const Edge& b) {return a.cost < b.cost; });\n\t\tint sum_cost{ 0 };\n\t\tfor (const auto e : edges) {\n\t\t\tif (!uft.unite(e.from, e.to) && ++k >= t) {\n\t\t\t\tsum_cost += e.cost;\n\t\t\t}\n\t\t}\n\t\tcout << \"Case \" << ++test_case << \": \" << sum_cost << '\\n';\n\t}\n}\n"
  },
  {
    "language": "C++",
    "code": "#include<bits/stdc++.h>\nusing namespace std;\n\nstruct unionfind{\n  \n  vector<int> parent;\n  vector<int> size;\n  \n  void init(int n){\n    size.clear();\n    parent.clear();\n    size.resize(n);\n    parent.resize(n);\n    \n    for(int i=0;i<n;i++){\n      parent[i]=i;\n      size[i]=1;\n    }\n  }\n  int find(int x){\n    if(parent[x]==x)return x;\n    else return parent[x]=find(parent[x]);\n  }\n  bool same(int x,int y){\n    return (find(x)==find(y));\n  }\n  int getSize(int x){\n    return size[ find(x) ];\n  }\n  void unite(int x,int y){\n    x=find(x);\n    y=find(y);\n    if(x==y)return;\n    parent[x]=y;\n    size[y]+=size[x];\n  }\n};\n  \nstruct edge{\n  int from,to,cost;\n  bool operator < (const edge &e) const {\n    return cost < e.cost;\n  }\n};\n\nint n,t,k;\nunionfind uf;\n\nint main(){\n\n  \n  for(int tc=1;;tc++){\n    cin>>n>>t>>k;\n    if(n==0&&t==0&&k==0)break;\n    vector<edge> E;\n\n    uf.init(n);\n    \n    for(int i=0;i<n-1;i++){\n      int a,b,c;\n      cin>>a>>b>>c;\n      a--,b--;\n      E.push_back( (edge){a,b,-c} );\n      uf.unite(a,b);\n    }\n    assert( uf.getSize(0) == n );\n    \n    for(int i=0;i<t;i++){\n      int a;\n      cin>>a;\n      a--;\n      E.push_back( (edge){a,n,-20000} );\n    }\n    sort(E.begin(),E.end());\n    \n    uf.init(n+1);\n\n    vector<edge> tmp;\n    \n    for(int i=0;i<(int)E.size();i++){\n      edge e=E[i];\n      if( uf.same(e.from,e.to) ){\n        tmp.push_back(e);\n      }else{\n        uf.unite(e.from,e.to);\n      }\n    }\n\n    reverse(tmp.begin(),tmp.end());\n    \n    int ans=0;\n    for(int i=0;i< min(k,(int)tmp.size());i++){\n      ans-=tmp[i].cost;\n    }\n    cout<<\"Case \"<<tc<<\": \"<<ans<<endl;\n    \n  }\n  return 0;\n}"
  },
  {
    "language": "C++",
    "code": "// Template {{{\n#include <bits/stdc++.h>\n#define REP(i,n) for(int i=0; i<(int)(n); ++i)\nusing namespace std;\ntypedef long long LL;\n\n#ifdef LOCAL\n#include \"contest.h\"\n#else\n#define dump(x) \n#endif\n\nclass range {\n    struct Iterator {\n        int val, inc;\n        int operator*() {return val;}\n        bool operator!=(Iterator& rhs) {return val < rhs.val;}\n        void operator++() {val += inc;}\n    };\n    Iterator i, n;\n    public:\n    range(int e) : i({0, 1}), n({e, 1}) {}\n    range(int b, int e) : i({b, 1}), n({e, 1}) {}\n    range(int b, int e, int inc) : i({b, inc}), n({e, inc}) {}\n    Iterator& begin() {return i;}\n    Iterator& end() {return n;}\n};\n\nconst int dx[4] = {1, 0, -1, 0};\nconst int dy[4] = {0, 1, 0, -1};\ninline bool valid(int x, int w) { return 0 <= x && x < w; }\n\nvoid iostream_init() {\n    ios::sync_with_stdio(false);\n    cin.tie(0);\n    cout.setf(ios::fixed);\n    cout.precision(12);\n}\n//}}}\n\nnamespace {\n    struct Edge{\n        int dst, cost;\n    };\n    typedef vector<Edge> Node;\n    typedef vector<Node> Graph;\n    Graph G;\n    typedef tuple<int, int, int> TP;\n    vector<TP> es;\n    vector<bool> is_base;\n    int N, T, K;\n\n    int uf[10000];\n    int have[10000];\n    \n    int root(int x) {\n        if(uf[x] == x) return x;\n        return uf[x] = root(uf[x]);\n    }\n\n    bool unite(int x, int y) {\n        x = root(x);\n        y = root(y);\n        assert(x != y);\n        bool res = have[x] && have[y];\n\n        have[x] = have[x] || have[y];\n        uf[y] = x;\n\n        return res;\n    }\n\n    int solve() {\n        REP(i, N) uf[i] = i;\n        REP(i, N) have[i] = is_base[i];\n\n        int ans = 0;\n        reverse(es.begin(), es.end());\n        int rest = (T-1) - K;\n        for(auto tp : es) {\n            int w, a, b;\n            tie(w, a, b) = tp;\n            if(unite(a, b)) {\n                if(--rest < 0) {\n                    ans += w;\n                }\n            }\n        }\n        return ans;\n    }\n}\n\n\nint main(){\n    iostream_init();\n    int Case = 0;\n    while(cin >> N >> T >> K && N > 0) {\n        cout << \"Case \" << ++Case << \": \";\n        G.assign(N, Node());\n        es.clear();\n        is_base.assign(N, false);\n\n        REP(i, N-1) {\n            int a, b, w;\n            cin >> a >> b >> w;\n            a--; b--;\n            G[a].push_back({b, w});\n            G[b].push_back({a, w});\n            es.push_back(TP(w, a, b));\n        }\n        sort(es.begin(), es.end());\n\n        REP(i, T){\n            int base;\n            cin >> base;\n            base--;\n            is_base[base] = true;\n        }\n\n        cout << solve() << endl;\n    }\n    return 0;\n}\n\n/* vim:set foldmethod=marker: */"
  },
  {
    "language": "C++",
    "code": "#include<cstdio>\n#include<cstring>\n#include<vector>\n#include<queue>\n#include<algorithm>\n#include<cmath>\n#include<climits>\n#include<string>\nusing namespace std;\n#define rep(i,n) for(int i=0;i<(n);i++)\n#define reg(i,a,b) for(int i=(a);i<=(b);i++)\n#define irep(i,n) for(int i=((int)(n))-1;i>=0;i--)\n#define ireg(i,a,b) for(int i=(b);i>=(a);i--)\ntypedef long long int lli;\ntypedef pair<int,int> mp;\n#define fir first\n#define sec second\n#define IINF INT_MAX\n#define LINF LLONG_MAX\ntypedef pair<int,mp> mmp;\n\nint n,m,k;\n\nint uni[10005];\nint isb[10005];\nmmp vs[10005];\n\nint find(int p){\n\tif(uni[p] == p)return p;\n\treturn (uni[p] = find(uni[p]));\n}\n\n\nbool mer(int to,int p){\n\tuni[find(p)] = find(uni[to]);\n}\n\n\nint main(void){\n\tint casen = 0;\n\twhile(1){\n\t\tcasen++;\n\t\tscanf(\"%d%d%d\",&n,&m,&k);\n\t\tif(n==0)break;\n\t\trep(i,n-1){\n\t\t\tint a,b,c;\n\t\t\tscanf(\"%d%d%d\",&a,&b,&c);\n\t\t\tvs[i] = mmp(c,mp(a,b));\n\t\t}\n\t\t\n\t\treg(i,1,n)uni[i] = i;\n\t\tmemset(isb,0,sizeof(isb));\n\t\t\n\t\trep(i,m){\n\t\t\tint a;\n\t\t\tscanf(\"%d\",&a);\n\t\t\tisb[a] = 1;\n\t\t}\n\t\t\n\t\tsort(vs,vs+n-1,greater<mmp>());\n\t\n\t\tint canmn = m - k - 1;\n\t\t\n\t\tint ans = 0;\n\t\t\n\t\trep(i,n-1){\n\t\t\tmmp pa = vs[i];\n\t\t\tint a = pa.sec.fir,\n\t\t\t\tb = pa.sec.sec,\n\t\t\t\tc = pa.fir;\n\t\t\ta = find(a); b = find(b);\n\t\t\tif(isb[a] == 1 && isb[b] == 1){\n\t\t\t\tif(canmn>0)canmn--;\n\t\t\t\telse ans+=c;\n\t\t\t}\n\t\t\tif(isb[a]==1)mer(a,b);\n\t\t\telse mer(b,a);\n\t\t}\n\t\t\n\t\tprintf(\"Case %d: %d\\n\",casen,ans);\n\t}\n\t\t\n\t\n\treturn 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\nusing namespace std;;\n#include <set>\n#include <math.h>\n#include <random>\n#include <iostream>\n#include <cstdlib>\n#include <stdio.h>\n#include <vector>\n#define PI 3.14159265359\n#define ll long long\n#define rep(i, n) for(int i = 0; i < (int)n; i++)\n#define Rep(i, k, n) for(int i = k; i < (int)n; i++)\n#define mp make_pair\n#define pb push_back\ntypedef pair<ll, ll> P;\n\nstruct UnionFind {\n  vector<int> data;\n  UnionFind(int size) : data(size, -1) { }\n  bool unionSet(int x, int y) {\n    x = root(x); y = root(y);\n    if (x != y) {\n      if (data[y] < data[x]) swap(x, y);\n      data[x] += data[y]; data[y] = x;\n    }\n    return x != y;\n  }\n  bool findSet(int x, int y) {\n    return root(x) == root(y);\n  }\n  int root(int x) {\n    return data[x] < 0 ? x : data[x] = root(data[x]);\n  }\n  int size(int x) {\n    return -data[root(x)];\n  }\n};\n\nint main() {\n  int Case = 0;\n  while (true) {\n    Case++;\n    int n, t, k; cin >> n >> t >> k;\n    if (n==0&&t==0&&k==0) break;\n    vector<vector<int>> edge(n-1, vector<int>(3,0));\n    rep(i, n-1){\n      cin >> edge[i][1] >> edge[i][2] >> edge[i][0];\n    }\n    sort(edge.begin(), edge.end(), [](vector<int> x, vector<int> y) { return x[0] > y[0]; });\n\n    int base[t];\n    rep(i, t) {\n      cin >> base[i];\n    }\n    bool iedge[n] = {false};\n    bool mnode[n+1] = {false};\n    rep(i, t){\n      mnode[base[i]] = true;\n    } \n\n    UnionFind uf(n+1);\n    int num = 0;\n    int cnt = 0;\n    rep(i, n) {\n      if (num == n-t) break;\n      int a = edge[i][1];\n      int b = edge[i][2];\n      int c = edge[i][0];\n      if (!mnode[uf.root(a)] && !mnode[uf.root(b)]) {\n        uf.unionSet(a, b);\n        cnt += c;\n        iedge[i] = true;\n        num++;\n      }\n      else if (!mnode[uf.root(a)] || !mnode[uf.root(b)]) {\n        uf.unionSet(a, b);\n        mnode[uf.root(a)] = true;\n        cnt += c;\n        iedge[i] = true;\n        num++;\n      }\n    }\n    rep(i, n) {\n      if (num == n-k-1) break;\n      int c = edge[i][0];\n      if (!iedge[i]) {\n        cnt += c;\n        num++;\n      }\n    }\n    int ans = 0;\n    rep(i, n-1) {\n      ans += edge[i][0];\n    }\n    printf(\"Case %d: %d\\n\", Case, ans-cnt);\n  }\n  return 0;\n}\n"
  },
  {
    "language": "C++",
    "code": "#include<bits/stdc++.h>\n\nusing namespace std;\n\nstruct edge\n{\n  int to, cost;\n};\n\ntypedef pair< int, int > Pi;\n\nint main()\n{\n  int N, T, K;\n  int A[10000], B[10000], C[10000];\n  int testcase = 1;\n\n  while(scanf(\"%d %d %d\", &N, &T, &K), N) {\n\n    vector< edge > g[10000];\n    int deg[10000] = {};\n    bool M[10000] = {};\n    priority_queue< Pi, vector< Pi >, greater<> > que;\n\n    for(int i = 1; i < N; i++) {\n      scanf(\"%d %d %d\", &A[i], &B[i], &C[i]);\n      --A[i], --B[i];\n      g[A[i]].emplace_back((edge) {B[i], C[i]});\n      g[B[i]].emplace_back((edge) {A[i], C[i]});\n      ++deg[A[i]];\n      ++deg[B[i]];\n      que.emplace(C[i], i);\n    }\n\n    for(int i = 0; i < T; i++) {\n      int x;\n      scanf(\"%d\", &x);\n      --x;\n      M[x] = true;\n    }\n\n    queue< int > beet;\n    bool live[10000];\n    for(int i = 0; i < N; i++) {\n      if(deg[i] == 1) {\n        deg[i]--;\n        beet.emplace(i);\n      }\n      live[i] = true;\n    }\n\n    auto update = [&]()\n    {\n      while(!beet.empty()) {\n        int p = beet.front();\n        beet.pop();\n        if(M[p]) continue;\n        live[p] = false;\n        for(auto &e : g[p]) {\n          if(live[e.to]) {\n            deg[e.to]--;\n            if(deg[e.to] == 0) beet.emplace(e.to);\n          }\n        }\n      }\n    };\n\n    int ret = 0;\n    for(int i = 0; i < K; i++) {\n      update();\n      while(!que.empty()) {\n        int cost, idx;\n        tie(cost, idx) = que.top();\n        que.pop();\n        if(!live[A[idx]] || !live[B[idx]]) continue;\n        ret += cost;\n        --deg[A[idx]];\n        --deg[B[idx]];\n        if(deg[A[idx]] == 1) {\n          beet.emplace(A[idx]);\n          deg[A[idx]]--;\n        }\n        if(deg[B[idx]] == 1) {\n          beet.emplace(B[idx]);\n          deg[B[idx]]--;\n        }\n        break;\n      }\n    }\n\n    printf(\"Case %d: %d\\n\", testcase++, ret);\n  }\n}"
  },
  {
    "language": "C++",
    "code": "#include<bits/stdc++.h>\n#define N 10005\n#define rank raljfds\nusing namespace std;\ntypedef pair<int,int> P;\ntypedef pair<int,P> P2;\n\nclass UF{\npublic:\n  int V;\n  vector<int> par, rank, mil;\n  UF(){}\n  UF(int V):V(V),par(V),rank(V,0),mil(V,-1){for(int i=0;i<V;i++) par[i]=i;}\n\n  int find(int x){\n    assert(x<V);\n    if(par[x]==x) return x;\n    return par[x]=find(par[x]);\n  }\n  \n  void unite(int x,int y){\n    x=find(x), y=find(y);\n    if(x==y)return;\n    if(rank[x]<rank[y]){\n      par[x]=y;\n      if(mil[x]!=-1) mil[y]=mil[x];\n      if(mil[y]!=-1) mil[x]=mil[y];\n    }\n    else{\n      par[y]=x;\n      if(rank[x]<rank[y]) rank[x]++;\n      if(mil[x]!=-1) mil[y]=mil[x];\n      if(mil[y]!=-1) mil[x]=mil[y];\n    }\n  }\n  \n  bool same(int x,int y){return find(x)==find(y);}\n  \n  void add_mil(int num){\n    mil[num]=num;\n  }\n  \n  int get_mil(int x){\n    return mil[par[x]];\n  }\n};\n\nint n,t,k;\nvector<P2> G;\n\nint solve(){\n  \n  UF uf(n);\n\n  int milnum;\n  \n  for(int i=0;i<t;i++){\n\n    cin>>milnum;\n    \n    uf.add_mil(milnum-1);\n  }\n  \n  vector<int> ans;\n  \n  for(int idx=0;idx<G.size();idx++){\n    \n    P2 tmp=G[idx];\n    \n    int cost=G[idx].first;\n    int A=G[idx].second.first;\n    int B=G[idx].second.second;\n\n    if(!(uf.get_mil(A)!=-1&&uf.get_mil(B)!=-1)) uf.unite(A,B);\n    else ans.push_back(cost);\n    \n  }\n\n  sort(ans.begin(),ans.end());\n\n  int res=0;\n  \n  for(int i=0;i<k;i++) res+=ans[i];\n  \n  return res;\n}\n\nint main(){\n\n  int T=1;\n  \n  while(1){\n\n    cin>>n>>t>>k;\n    if(!n&&!t&&!k) break;\n\n    int a,b,cost;\n    \n    for(int i=0;i<n-1;i++){\n      \n      cin>>a>>b>>cost;\n      \n      a--, b--;\n\n      G.push_back(P2(cost,P(a,b)));\n    }\n    \n    sort(G.begin(),G.end(),greater<P2>());\n    \n    cout<<\"Case \"<<T<<\": \";\n    \n    cout<<solve()<<endl;\n\n    G.clear();\n    \n    T++;\n  }\n  \n  return 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include<bits/stdc++.h>\nusing namespace std;\n\nstruct unionfind{\n  int parent[20000];\n  int size[20000];\n  \n  void init(int n){\n    for(int i=0;i<n;i++){\n      parent[i]=i;\n      size[i]=1;\n    }\n  }\n  int find(int x){\n    if(parent[x]==x)return x;\n    else parent[x]=find(parent[x]);\n  }\n  bool same(int x,int y){\n    return (find(x)==find(y));\n  }\n  bool getSize(int x){\n    return size[ find(x) ];\n  }\n  void unite(int x,int y){\n    x=find(x);\n    y=find(y);\n    if(x==y)return;\n    if(size[x]>size[y])swap(x,y);\n    parent[x]=y;\n    size[y]+=size[x];\n  }\n};\n  \nstruct edge{\n  int from,to,cost;\n  bool operator < (const edge &e) const {\n    return cost < e.cost;\n  }\n};\n\nint n,t,k;\n\nint main(){\n  unionfind uf;\n  \n  for(int tc=1;;tc++){\n    cin>>n>>t>>k;\n    if(n==0&&t==0&&k==0)break;\n    vector<edge> E;\n    for(int i=0;i<n-1;i++){\n      int a,b,c;\n      cin>>a>>b>>c;\n      a--,b--;\n      E.push_back( (edge){a,b,-c} );\n    }\n    for(int i=0;i<t;i++){\n      int a;\n      cin>>a;\n      a--;\n      E.push_back( (edge){a,n,-20000} );\n    }\n    sort(E.begin(),E.end());\n    uf.init(n+1);\n\n    vector<edge> tmp;\n    \n    for(int i=0;i<(int)E.size();i++){\n      edge e=E[i];\n      if( uf.same(e.from,e.to) ){\n        tmp.push_back(e);\n      }else{\n        uf.unite(e.from,e.to);\n      }\n    }\n\n    int ans=0;\n    for(int i=t-1-k;i<(int)tmp.size();i++){\n      ans-=tmp[i].cost;\n    }\n    cout<<\"Case \"<<tc<<\": \"<<ans<<endl;\n    \n  }\n  return 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include <iostream>\n#include <vector>\n#include <map>\n#include <algorithm>\nusing namespace std;\n\nconst int MAX_V = 100000;\ntypedef pair<int,int> P;\nstruct edge{ int to,cost; };\n\n// グラフ (隣接リスト)\nvector<edge> G[MAX_V];\n// e = (u,v) , is_cost[e] := コスト\nmap<P,int> is_cost;\n// base[u] == true のとき ノード u は ベース\nbool base[MAX_V];\n// (cost,(u,v))の組\nvector< pair<int ,P> > a;\n// used[u] == true のとき ノード u は探索済み\nbool used[MAX_V];\n\nint n, t, k;\n\n\n// 初期化\nvoid init(){\n\ta.clear();\n\tis_cost.clear();\n\tfor(int i=0 ; i < MAX_V ; i++ ){\n\t\tbase[i] = false;\n\t\tG[i].clear();\n\t}\n}\n\n// グラフに重みcostのエッジ(u,v)を追加\nvoid add_edge(int u, int v, int cost){\n\tedge e;\n\te.to = v;\n\te.cost = cost;\n\tG[u].push_back( e );\n\te.to = u;\n\tG[v].push_back( e );\n}\n\n// グラフのエッジ(u,v)を切断\nvoid cut_edge(int u, int v){\n\tfor(vector<edge>::iterator it = G[u].begin() ; it != G[u].end() ; ++it ){\n\t\tif( (*it).to == v ){\n\t\t\tG[u].erase( it );\n\t\t\treturn ;\n\t\t}\n\t}\n}\n\n\n// ノード u の木にベースがあるかどうか\nvoid is_base(int u, bool& flag){\n\t\n\t// ノード u がベースのとき\n\tif( base[u] || flag ){\n\t\tflag = true;\n\t\treturn;\n\t}\n\t// ノード u が探索済みのとき\n\tif( used[u] ) return;\n\tused[u] = true;\n\t\n\tfor(int i=0 ; i < G[u].size() ; i++ ){\n\t\tedge e = G[u][i];\n\t\tis_base( e.to , flag );\n\t}\n}\n\nint solve(){\n\t\n\t// 連結成分の数\n\tint p=1;\n\t// コストの総和\n\tint sum = 0;\n\t\n\tsort( a.begin() , a.end() );\n\tfor(int i=0 ; i < a.size() ; i++ ){\n\t\tint cost = a[i].first;\n\t\tint u = a[i].second.first;\n\t\tint v = a[i].second.second;\n\t\tif( u > v ) swap(u,v);\n\t\t\n\t\t//cut_edge( u , v );\n\t\t\n\t\tbool flag1 = false, flag2 = false;\n\t\tfor(int j=0 ; j < MAX_V ; j++ ) used[j] = false;\n\t\t//is_base( u , flag1 );\n\t\tfor(int j=0 ; j < MAX_V ; j++ ) used[j] = false;\n\t\t//is_base( v , flag2 );\n\t\t//flag1 = flag2 = true;\n\t\t\n\t\t// u,vの木の両方にベースを含むとき切断する\n\t\tif( flag1 && flag2 ){\n\t\t\t//sum += is_cost[P(u,v)];\n\t\t\tp++;\n\t\t}else{\n\t\t\t//add_edge( u , v , is_cost[P(u,v)] );\n\t\t}\n\t\t\n\t\t// 連結成分が K+1 個になったらループを抜ける\n\t\tif( p == k+1 ) break;\n\t}\n\treturn sum;\n}\n\nint main(){\n\tfor(int t_ = 1 ; cin >> n >> t >> k , (n || t || k) ; t_++ ){\n\t\t// 初期化\n\t\tinit();\n\t\t\n\t\tfor(int i = 0 ; i < n-1 ; i++ ){\n\t\t\tint u, v, cost;\n\t\t\tcin >> u >> v >> cost;\n\t\t\tu--; v--;\n\t\t\tif( u > v ) swap(u,v);\n\t\t\t\n\t\t\tis_cost[P(u,v)] = cost;\n\t\t\tadd_edge( u , v , cost );\n\t\t\tpair<int,P> p( cost , P(u,v) );\n\t\t\ta.push_back( p );\n\t\t}\n\t\tfor(int i = 0 ; i < t ; i++ ){\n\t\t\tint b;\n\t\t\tcin >> b;\n\t\t\tb--;\n\t\t\tbase[b] = true;\n\t\t}\n\t\t\n\t\tint ans = solve();\n\t\tcout << \"Case \" << t_ << \": \" << ans << endl;\n\t}\n}"
  },
  {
    "language": "C++",
    "code": "#include<bits/stdc++.h>\n\n#define REP(i,s,n) for(int i=s;i<n;i++)\n#define rep(i,n) REP(i,0,n)\n\nusing namespace std;\n\nstruct Edge {\n  int src,dst,weight; \n  bool operator < ( const Edge &e ) const { return weight < e.weight; }\n};\n\nconst int MAX = 10010;\nint par[MAX];\nvector<Edge> edges;\n\nvoid init(int _size=MAX) { rep(i,_size) par[i] = i; } \n\nint find(int x) {\n  if( par[x] == x ) return x;\n  return par[x] = find(par[x]);\n}\n\nvoid unit(int x,int y){\n  x = find(x), y = find(y);\n  if( x != y ) par[x] = y;\n}\n\nbool buffer[MAX];\nbool choose[MAX];\nint counter[MAX];\nvector<int> bases;\nint V,t,k;\n\nbool isValid(int index){\n  choose[index] = false;\n  //map<int,int> mp;\n  rep(i,V) counter[i] = 0;\n  init(V);\n  rep(i,V-1) if( choose[i] ) unit(edges[i].src,edges[i].dst);\n  rep(i,t) ++counter[find(bases[i])];\n  rep(i,V) if( counter[find(i)] == 0 ) return false;\n  return true;\n}\n\nvoid compute(){\n  sort(edges.begin(),edges.end());\n  rep(i,V) buffer[i] = true;\n  int answer = 0;\n  int remain = k;\n  int cur = 0;\n  while( cur < V-1 && remain ){\n    rep(i,V) choose[i] = buffer[i];\n    if( isValid(cur) ) {\n      --remain;\n      answer += edges[cur].weight;\n      buffer[cur] = false;\n    }\n    ++cur;\n  }\n  printf(\"%d\\n\",answer);\n}\n\nint main(){\n  int CNT = 1;  \n  while( scanf(\" %d %d %d\",&V,&t,&k) , V|t|k ){\n    edges.clear(), bases.clear();\n    rep(i,V-1) {\n      int s,t,c;\n      scanf(\" %d %d %d\",&s,&t,&c);\n      --s, --t;\n      edges.push_back((Edge){s,t,c});\n    }\n    rep(i,t){\n      int base;\n      scanf(\" %d\",&base);\n      --base;\n      bases.push_back(base);\n    }\n    printf(\"Case %d: \",CNT++);\n    compute();\n  }\n  return 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include<bits/stdc++.h>\nusing namespace std;\ntypedef pair<int,int> pii;\n\nint main(){\n  cin.tie(0); ios::sync_with_stdio(0);\n\n  int n,t,k,case_num = 0;\n  while(cin >> n >> t >> k, n){\n    case_num++;\n    assert(case_num<=60);\n\n    set<int> costs;\n    vector< vector<pii> > tree(n);\n\n    for(int i=0;i<n-1;i++){\n      int a,b,c;\n      cin >> a >> b >> c;\n      a--; b--;\n      tree[a].push_back(pii(c,b));\n      tree[b].push_back(pii(c,a));\n      costs.insert(c);\n    }\n\n    vector<int> base(t), use(n,0);\n    for(int i=0;i<t;i++){\n      cin >> base[i];\n      base[i]--;\n      use[base[i]] = 1;\n    }\n\n    priority_queue<pii> q;\n    for(int v : base){\n      for(pii u : tree[v]){\n\tif(!use[u.second])q.push(u);\n      }\n    }\n\n    while(q.size()){\n      pii p = q.top(); q.pop();\n      if(use[p.second])continue;\n      use[p.second] = 1;\n      costs.erase(p.first);\n\n      for(pii u : tree[p.second]){\n\tif(use[u.second])continue;\n\tq.push(u);\n      }\n    }\n\n    long long res = 0;\n    auto it = costs.begin();\n    for(int i=0;i<k;i++){\n      res += *it; it++;\n    }\n    cout << \"Case \" << case_num << \": \" << res << endl;\n  }\n}"
  },
  {
    "language": "C++",
    "code": "#include <iostream>\n#include <vector>\n#include <map>\n#include <algorithm>\nusing namespace std;\n\nconst int MAX_V = 100000;\ntypedef pair<int,int> P;\nstruct edge{ int to,cost; };\n\n// グラフ (隣接リスト)\nvector<edge> G[MAX_V];\n// e = (u,v) , is_cost[e] := コスト\nmap<P,int> is_cost;\n// base[u] == true のとき ノード u は ベース\nbool base[MAX_V];\n// (cost,(u,v))の組\nvector< pair<int ,P> > a;\n// used[u] == true のとき ノード u は探索済み\nbool used[MAX_V];\n\nint n, t, k;\n\n\n// 初期化\nvoid init(){\n\ta.clear();\n\tis_cost.clear();\n\tfor(int i=0 ; i < MAX_V ; i++ ){\n\t\tbase[i] = false;\n\t\tG[i].clear();\n\t}\n}\n\n// グラフに重みcostのエッジ(u,v)を追加\nvoid add_edge(int u, int v, int cost){\n\tedge e;\n\te.to = v;\n\te.cost = cost;\n\tG[u].push_back( e );\n\te.to = u;\n\tG[v].push_back( e );\n}\n\n// グラフのエッジ(u,v)を切断\nvoid cut_edge(int u, int v){\n\tfor(vector<edge>::iterator it = G[u].begin() ; it != G[u].end() ; ++it ){\n\t\tif( (*it).to == v ){\n\t\t\tG[u].erase( it );\n\t\t\treturn ;\n\t\t}\n\t}\n}\n\n\n// ノード u の木にベースがあるかどうか\nvoid is_base(int u, bool& flag){\n\t\n\t// ノード u がベースのとき\n\tif( base[u] || flag ){\n\t\tflag = true;\n\t\treturn;\n\t}\n\t// ノード u が探索済みのとき\n\tif( used[u] ) return;\n\tused[u] = true;\n\t\n\tfor(int i=0 ; i < G[u].size() ; i++ ){\n\t\tedge e = G[u][i];\n\t\tis_base( e.to , flag );\n\t}\n}\n\nint solve(){\n\t\n\t// 連結成分の数\n\tint p=1;\n\t// コストの総和\n\tint sum = 0;\n\t\n\tsort( a.begin() , a.end() );\n\tfor(int i=0 ; i < a.size() ; i++ ){\n\t\tint cost = a[i].first;\n\t\tint u = a[i].second.first;\n\t\tint v = a[i].second.second;\n\t\tif( u > v ) swap(u,v);\n\t\t\n\t\tcut_edge( u , v );\n\t\t\n\t\t/*bool flag1 = false, flag2 = false;\n\t\tfor(int j=0 ; j < MAX_V ; j++ ) used[j] = false;\n\t\t//is_base( u , flag1 );\n\t\tfor(int j=0 ; j < MAX_V ; j++ ) used[j] = false;\n\t\t//is_base( v , flag2 );\n\t\t//flag1 = flag2 = true;\n\t\t\n\t\t// u,vの木の両方にベースを含むとき切断する\n\t\tif( flag1 && flag2 ){\n\t\t\t//sum += is_cost[P(u,v)];\n\t\t\tp++;\n\t\t}else{\n\t\t\t//add_edge( u , v , is_cost[P(u,v)] );\n\t\t}*/\n\t\t\n\t\t// 連結成分が K+1 個になったらループを抜ける\n\t\tif( p == k+1 ) break;\n\t}\n\treturn sum;\n}\n\nint main(){\n\tfor(int t_ = 1 ; cin >> n >> t >> k , (n || t || k) ; t_++ ){\n\t\t// 初期化\n\t\tinit();\n\t\t\n\t\tfor(int i = 0 ; i < n-1 ; i++ ){\n\t\t\tint u, v, cost;\n\t\t\tcin >> u >> v >> cost;\n\t\t\tu--; v--;\n\t\t\tif( u > v ) swap(u,v);\n\t\t\t\n\t\t\tis_cost[P(u,v)] = cost;\n\t\t\tadd_edge( u , v , cost );\n\t\t\tpair<int,P> p( cost , P(u,v) );\n\t\t\ta.push_back( p );\n\t\t}\n\t\tfor(int i = 0 ; i < t ; i++ ){\n\t\t\tint b;\n\t\t\tcin >> b;\n\t\t\tb--;\n\t\t\tbase[b] = true;\n\t\t}\n\t\t\n\t\tint ans = solve();\n\t\tcout << \"Case \" << t_ << \": \" << ans << endl;\n\t}\n}"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\n#define Nmax 10002\nusing namespace std;\n\nint n,t,k,B[Nmax],fst;\nstruct muchie{\n    int x,y,c;\n};\nvector<muchie> L;\nvector<muchie> :: iterator T;\nvector<int > v[Nmax];\nbool uz[Nmax];\nint gr[Nmax];\n\nint dfs(int nod,int ant)\n{\n    int ok = 0;\n    for (auto it : v[nod])\n    {\n        if (it==ant) continue;\n        if (dfs(it,nod))\n            ok = 1;\n        else\n            gr[nod]--;\n    }\n    if (B[nod])\n        ok = 1;\n    if (!ok)\n        uz[nod] = 1;\n    return ok;\n}\n\nint dfs2(int nod,int ant)\n{\n\n    if (B[nod]==1 || gr[nod]>2)\n    {\n        gr[nod]--;\n        return 1;\n    }\n    if (!fst)\n    {\n        gr[nod]--;\n    }\n    fst = 0;\n    for (auto it : v[nod])\n    {\n        if (it==ant) continue;\n        uz[nod] = 1;\n        if (dfs2(it,nod))\n            return 1;\n        else\n            gr[nod]--;\n    }\n    return 0;\n}\n\n\nint main()\n{\n    int nrT = 0;\n    while (cin>>n>>t>>k){\n        nrT++;\n        if (n==0 && k==0 && t==0)\n            return 0;\n        memset(B,0,sizeof(B));\n        memset(gr,0,sizeof(gr));\n        L.clear();\n        for (int i=1;i<=n;i++)\n            v[i].clear();\n        int x,y,c;\n        for (int i=1;i<n;i++){\n            cin>>x>>y>>c;\n            gr[x]++;\n            gr[y]++;\n            v[x].push_back(y);\n            v[y].push_back(x);\n            L.push_back({x,y,c});\n        }\n        int sav;\n        for (int i=1;i<=t;i++){\n            cin>>x;\n            B[x] = 1;\n            sav = x;\n        }\n\n        dfs(sav,-1);\n        int res = 0,mn;\n        for (int i=1;i<=k;i++)\n        {\n            mn = 1e9;\n            int S;\n            for (int j=0;j<L.size();j++){\n                auto it = L[j];\n                if (!uz[it.x] && !uz[it.y]){\n                    if (mn>it.c)\n                    {\n                        mn =it.c;\n                        S = j;\n                    }\n                }\n            }\n            res += mn;\n            fst = 1;\n            dfs2(L[S].x,L[S].y);\n            fst = 1;\n            dfs2(L[S].y,L[S].x);\n            L[S].c = 1e9;\n        }\n        cout<<\"Case \"<<nrT<<\": \"<<res<<'\\n';\n    }\n    return 0;\n}\n/*\n10 5 3\n1 2 2\n2 3 4\n2 6 3\n6 7 1\n6 8 2\n1 4 5\n4 10 5\n4 9 5\n4 5 5\n1 3 5 7 10\n*/\n\n"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\n\nusing namespace std;\n\nset<int> base;\n\nstruct UnionFind {\n  vector<int> data;\n  UnionFind(int n):data(n, -1){}\n  int find(int x) {\n    return data[x] < 0 ? x : data[x] = find(data[x]);\n  }\n  bool same(int x, int y) {\n    return find(x) == find(y);\n  }\n  void unite(int x, int y) {\n    x = find(x), y = find(y);\n    if(x == y) return;\n    //if(data[x] < data[y]) swap(x, y);\n    if(!base.count(x)) swap(x, y);\n    data[x] += data[y];\n    data[y] = x;\n  }\n};\n\nstruct edge {\n  int from, to, cost;\n  edge(){}\n  edge(int from, int to, int cost):from(from), to(to), cost(cost){}\n  bool operator < (const edge& e) const {\n    return cost > e.cost;\n  }\n};\n\nusing Pi = pair<int, int>;\nusing Tapris = tuple<int, int, int>;\n\nvector<edge> es;\n\nint main() {\n  int n, t, k;\n  int T = 0;\n  while(cin >> n >> t >> k, n || t || k) {\n    base.clear();\n    es.clear();\n    for(int i = 0; i < n-1; i++) {\n      int a, b, c;\n      cin >> a >> b >> c;\n      --a, --b;\n      es.emplace_back(a, b, c);\n    }\n    UnionFind uf(n);\n    for(int i = 0; i < t; i++) {\n      int d; cin >> d; --d;\n      base.insert(d);\n    }\n    vector<int> ans;\n    sort(es.begin(), es.end());\n    for(int i = 0; i < n-1; i++) {\n      for(edge& e : es) {\n\tif(!uf.same(e.from, e.to)) {\n\t  int x = uf.find(e.from), y = uf.find(e.to);\n\t  if(base.count(x) && base.count(y)) {\n\t    ans.push_back(e.cost);\n\t  }\n\t  uf.unite(x, y);\n\t}\n      }\n    }\n    sort(ans.begin(), ans.end());\n    int total = 0;\n    cout << ans.size() << \" \" << k << endl;\n    for(int i = 0; i < k; i++) total += ans[i];\n    cout << \"Case \" << ++T << \": \" << total << endl;\n  }\n  return 0;\n}"
  },
  {
    "language": "C++",
    "code": "//15:53-17:33\n#include <bits/stdc++.h>\nusing namespace std;\ntypedef long long ll;\ntypedef pair<int,int> P;\ntypedef pair<int,P> P1;\ntypedef pair<P,P> P2;\n#define pu push\n#define pb push_back\n#define mp make_pair\n#define eps 1e-7\n#define INF 1000000000\n#define fi first\n#define sc second\n#define rep(i,x) for(int i=0;i<x;i++)\n#define SORT(x) sort(x.begin(),x.end())\n#define ERASE(x) x.erase(unique(x.begin(),x.end()),x.end())\n#define POSL(x,v) (lower_bound(x.begin(),x.end(),v)-x.begin())\n#define POSU(x,v) (upper_bound(x.begin(),x.end(),v)-x.begin())\nint n,m,k;\nvector<P1>vec;\nvector<P>edge[10005];\nbool good[10005];\nbool used[10005],ok;\nP forbid;\nvoid dfs(int v){\n\tif(used[v]) return;\n\tif(good[v]) ok = 1; used[v] = 1;\n\tfor(int i=0;i<edge[v].size();i++){\n\t\tif(mp( min(v,edge[v][i].fi), max(v,edge[v][i].fi) ) == forbid){\n\t\t\tcontinue;\n\t\t}\n\t\tif(used[edge[v][i].fi]) dfs(edge[v][i].fi);\n\t}\n}\nint main(){\n\tfor(int q=1;;q++){\n\t\tscanf(\"%d%d%d\",&n,&m,&k);\n\t\tif(n==0) return 0;\n\t\tvec.clear(); rep(i,10005) edge[i].clear();\n\t\tfor(int i=1;i<n;i++){\n\t\t\tint a,b,c; scanf(\"%d%d%d\",&a,&b,&c);\n\t\t\tvec.pb(mp(c,mp(a,b)));\n\t\t\tedge[a].pb(mp(b,c));\n\t\t\tedge[b].pb(mp(a,c));\n\t\t}\n\t\tfor(int i=0;i<m;i++){\n\t\t\tint x; cin >> x; good[x] = 1;\n\t\t}\n\t\trep(i,1005) SORT(edge[i]);\n\t\tsort(vec.begin(),vec.end());\n\t\tll ret = 0;int c = 0;\n\t\tfor(int i=0;i<vec.size()&&c<k;i++){\n\t\t\tmemset(used,0,sizeof(used));\n\t\t\tint cs = vec[i].fi;\n\t\t\tint L = vec[i].sc.fi,R = vec[i].sc.sc;\n\t\t\tforbid = mp(min(L,R),max(L,R));\n\t\t\tok = 0;\n\t\t\tdfs(L);\n\t\t\tif(!ok) continue;\n\t\t\tok = 0;\n\t\t\tdfs(R);\n\t\t\tif(!ok) continue;\n\t\t\tedge[L].erase(lower_bound(edge[L].begin(),edge[L].end(),mp(R,cs)));\n\t\t\tedge[R].erase(lower_bound(edge[R].begin(),edge[R].end(),mp(L,cs)));\n\t\t\tc++; ret += cs;\n\t\t}\n\t\tcout << \"Case \" << q << \": \" << ret << endl;\n\t}\n}"
  },
  {
    "language": "C++",
    "code": "#include <iostream>\n#include <vector>\n#include <map>\n#include <algorithm>\nusing namespace std;\n\nconst int MAX_V = 100000;\ntypedef pair<int,int> P;\nstruct edge{ int to,cost; };\n\n// グラフ (隣接リスト)\nvector<edge> G[MAX_V];\n// e = (u,v) , is_cost[e] := コスト\nmap<P,int> is_cost;\n// base[u] == true のとき ノード u は ベース\nbool base[MAX_V];\n// (cost,(u,v))の組\nvector< pair<int ,P> > a;\n// used[u] == true のとき ノード u は探索済み\nbool used[MAX_V];\n\nint n, t, k;\n\n\n// 初期化\nvoid init(){\n\ta.clear();\n\tis_cost.clear();\n\tfor(int i=0 ; i < MAX_V ; i++ ){\n\t\tbase[i] = false;\n\t\tG[i].clear();\n\t}\n}\n\n// グラフに重みcostのエッジ(u,v)を追加\nvoid add_edge(int u, int v, int cost){\n\tedge e;\n\te.to = v;\n\te.cost = cost;\n\tG[u].push_back( e );\n\te.to = u;\n\tG[v].push_back( e );\n}\n\n// グラフのエッジ(u,v)を切断\nvoid cut_edge(int u, int v){\n\tfor(vector<edge>::iterator it = G[u].begin() ; it != G[u].end() ; ++ it ){\n\t\tif( (*it).to == v ){\n\t\t\tG[u].erase( it );\n\t\t\treturn ;\n\t\t}\n\t}\n}\n\n\n// ノード u の木にベースがあるかどうか\nvoid is_base(int u, bool& flag){\n\t// ノード u がベースのとき\n\tif( base[u] ){\n\t\tflag = true;\n\t\treturn;\n\t}\n\t// ノード u が探索済みのとき\n\tif( used[u] ) return;\n\tused[u] = true;\n\t\n\tfor(int i=0 ; i < G[u].size() ; i++ ){\n\t\tedge e = G[u][i];\n\t\tis_base( e.to , flag );\n\t}\n}\n\nint solve(){\n\t\n\t// 連結成分の数\n\tint p=1;\n\t// コストの総和\n\tint sum = 0;\n\t\n\tsort( a.begin() , a.end() );\n\tfor(int i=0 ; i < a.size() ; i++ ){\n\t\tint cost = a[i].first;\n\t\tint u = a[i].second.first;\n\t\tint v = a[i].second.second;\n\t\tif( u > v ) swap(u,v);\n\t\t\n\t\tcut_edge( u , v );\n\t\t\n\t\tbool flag1 = false, flag2 = false;\n\t\tfor(int i=0 ; i < n ; i++ ) used[i] = false;\n\t\tis_base( u , flag1 );\n\t\tfor(int i=0 ; i < n ; i++ ) used[i] = false;\n\t\tis_base( v , flag2 );\n\t\t\n\t\t// u,vの木の両方にベースを含むとき切断する\n\t\tif( flag1 && flag2 ){\n\t\t\tsum += is_cost[P(u,v)];\n\t\t\tp++;\n\t\t}else{\n\t\t\tadd_edge( u , v , is_cost[P(u,v)] );\n\t\t}\n\t\t\n\t\t// 連結成分が K+1 個になったらループを抜ける\n\t\tif( p == k+1 ) break;\n\t}\n\treturn sum;\n}\n\nint main(){\n\tfor(int t_ = 1 ; cin >> n >> t >> k , (n || t || k) ; t_++ ){\n\t\t// 初期化\n\t\tinit();\n\t\t\n\t\tfor(int i = 0 ; i < n-1 ; i++ ){\n\t\t\tint u, v, cost;\n\t\t\tcin >> u >> v >> cost;\n\t\t\tu--; v--;\n\t\t\tif( u > v ) swap(u,v);\n\t\t\t\n\t\t\tis_cost[P(u,v)] = cost;\n\t\t\tadd_edge( u , v , cost );\n\t\t\tpair<int,P> p( cost , P(u,v) );\n\t\t\ta.push_back( p );\n\t\t}\n\t\tfor(int i = 0 ; i < t ; i++ ){\n\t\t\tint b;\n\t\t\tcin >> b;\n\t\t\tb--;\n\t\t\tbase[b] = true;\n\t\t}\n\t\t\n\t\tint ans = solve();\n\t\tcout << \"Case \" << t_ << \": \" << ans << endl;\n\t}\n}"
  },
  {
    "language": "C++",
    "code": "#include <iostream>\n#include <cstdio>\n#include <vector>\n#include <set>\n#include <map>\n#include <queue>\n#include <deque>\n#include <stack>\n#include <algorithm>\n#include <cstring>\n#include <functional>\n#include <cmath>\nusing namespace std;\n#define rep(i,n) for(int i=0;i<(n);++i)\n#define rep1(i,n) for(int i=1;i<=(n);++i)\n#define all(c) (c).begin(),(c).end()\n#define fs first\n#define sc second\n#define pb push_back\n#define show(x) cout << #x << \" \" << x << endl\nstruct edge{int from,to,cost;};\nbool operator<(const edge& x,const edge& y){\n\tif(x.cost!=y.cost) x.cost>y.cost;\n\tif(x.from!=y.from) x.from<y.from;\n\treturn x.to<y.to;\n}\nint par[10000],id[10000];\nvoid init(int n){\n\trep(i,n) par[i]=i;\n\trep(i,n) id[i]=-1;\n}\nint find(int x){\n\tif(x==par[x]) return x;\n\telse par[x]=find(par[x]);\n}\nvoid unite(int x,int y){\n\tx=find(x),y=find(y);\n\tif(id[x]>=0) par[y]=x;\n\telse par[x]=y;\n}\nvector<edge> es;\nvector<int> costs;\nint main(){\n\tint tt=0;\n\twhile(true){\n\t\ttt++;\n\t\tint n,t,k;\n\t\tcin>>n>>t>>k;\n\t\tif(n==0) break;\n\t\tes.clear();\n\t\tinit(n);\n\t\trep(i,n-1){\n\t\t\tint a,b,c;\n\t\t\tcin>>a>>b>>c;\n\t\t\tes.pb(edge{a-1,b-1,c});\n\t\t}\n\t\trep(i,t){\n\t\t\tint x;\n\t\t\tcin>>x;\n\t\t\tid[x-1]=x-1;\n\t\t}\n\t\tsort(all(es));\n\t\tcosts.clear();\n\t\trep(i,n-1){\n\t\t\tint a=es[i].from,b=es[i].to,c=es[i].cost;\n\t\t\ta=find(a),b=find(b);\n\t\t\tif(id[a]>=0&&id[b]>=0) costs.pb(c);\n\t\t\telse unite(a,b);\n\t\t}\n\t\tsort(all(costs));\n//\t\tshow(costs.size());\n\t\tint sum=0;\n\t\trep(i,k) sum+=costs[i];\n\t\tprintf(\"Case %d: %d\\n\",tt,sum);\n\t}\n}"
  },
  {
    "language": "C++",
    "code": "#include <iostream>\n#include <vector>\n#include <map>\n#include <algorithm>\nusing namespace std;\n\nconst int MAX_V = 100000;\ntypedef pair<int,int> P;\nstruct edge{ int to,cost; };\n\n// グラフ (隣接リスト)\nvector<edge> G[MAX_V];\n// e = (u,v) , is_cost[e] := コスト\nmap<P,int> is_cost;\n// base[u] == true のとき ノード u は ベース\nbool base[MAX_V];\n// (cost,(u,v))の組\nvector< pair<int ,P> > a;\n// used[u] == true のとき ノード u は探索済み\nbool used[MAX_V];\n\nint n, t, k;\n\n\n// 初期化\nvoid init(){\n\ta.clear();\n\tis_cost.clear();\n\tfor(int i=0 ; i < MAX_V ; i++ ){\n\t\tbase[i] = false;\n\t\tG[i].clear();\n\t}\n}\n\n// グラフに重みcostのエッジ(u,v)を追加\nvoid add_edge(int u, int v, int cost){\n\tedge e;\n\te.to = v;\n\te.cost = cost;\n\tG[u].push_back( e );\n\te.to = u;\n\tG[v].push_back( e );\n}\n\n// グラフのエッジ(u,v)を切断\nvoid cut_edge(int u, int v){\n\tfor(vector<edge>::iterator it = G[u].begin() ; it != G[u].end() ; ++it ){\n\t\tif( (*it).to == v ){\n\t\t\tG[u].erase( it );\n\t\t\treturn ;\n\t\t}\n\t}\n}\n\n\n// ノード u の木にベースがあるかどうか\nvoid is_base(int u, bool& flag){\n\t\n\t// ノード u がベースのとき\n\t/*if( base[u] || flag ){\n\t\tflag = true;\n\t\treturn;\n\t}\n\t// ノード u が探索済みのとき\n\tif( used[u] ) return;\n\tused[u] = true;\n\t\n\tfor(int i=0 ; i < G[u].size() ; i++ ){\n\t\tedge e = G[u][i];\n\t\tis_base( e.to , flag );\n\t}*/\n}\n\nint solve(){\n\t\n\t// 連結成分の数\n\tint p=1;\n\t// コストの総和\n\tint sum = 0;\n\t\n\tsort( a.begin() , a.end() );\n\tfor(int i=0 ; i < a.size() ; i++ ){\n\t\tint cost = a[i].first;\n\t\tint u = a[i].second.first;\n\t\tint v = a[i].second.second;\n\t\tif( u > v ) swap(u,v);\n\t\t\n\t\tcut_edge( u , v );\n\t\t\n\t\tbool flag1 = false, flag2 = false;\n\t\tfor(int j=0 ; j < MAX_V ; j++ ) used[j] = false;\n\t\tis_base( u , flag1 );\n\t\tfor(int j=0 ; j < MAX_V ; j++ ) used[j] = false;\n\t\tis_base( v , flag2 );\n\t\t//flag1 = flag2 = true;\n\t\t\n\t\t// u,vの木の両方にベースを含むとき切断する\n\t\tif( flag1 && flag2 ){\n\t\t\tsum += is_cost[P(u,v)];\n\t\t\tp++;\n\t\t}else{\n\t\t\tadd_edge( u , v , is_cost[P(u,v)] );\n\t\t}\n\t\t\n\t\t// 連結成分が K+1 個になったらループを抜ける\n\t\tif( p == k+1 ) break;\n\t}\n\treturn sum;\n}\n\nint main(){\n\tfor(int t_ = 1 ; cin >> n >> t >> k , (n || t || k) ; t_++ ){\n\t\t// 初期化\n\t\tinit();\n\t\t\n\t\tfor(int i = 0 ; i < n-1 ; i++ ){\n\t\t\tint u, v, cost;\n\t\t\tcin >> u >> v >> cost;\n\t\t\tu--; v--;\n\t\t\tif( u > v ) swap(u,v);\n\t\t\t\n\t\t\tis_cost[P(u,v)] = cost;\n\t\t\tadd_edge( u , v , cost );\n\t\t\tpair<int,P> p( cost , P(u,v) );\n\t\t\ta.push_back( p );\n\t\t}\n\t\tfor(int i = 0 ; i < t ; i++ ){\n\t\t\tint b;\n\t\t\tcin >> b;\n\t\t\tb--;\n\t\t\tbase[b] = true;\n\t\t}\n\t\t\n\t\tint ans = solve();\n\t\tcout << \"Case \" << t_ << \": \" << ans << endl;\n\t}\n}"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\nusing namespace std;\n\n//https://github.com/hoget157/library/blob/master/DataStructure/UnionFind.cpp\nstruct UnionFind{\n\tvector<int> rnk,par;\n\n\tUnionFind(int sz) : rnk(sz,0),par(sz){\n\t\tfor(int i = 0;i < sz;i++) par[i] = i;\n\t}\n\n\tint find(int x){\n\t\tif(par[x] == x) return x;\n\t\treturn par[x] = find(par[x]);\n\t}\n\n\tvoid unite(int x,int y){\n\t\tx = find(x);\n\t\ty = find(y);\n\t\tif(x == y) return;\n\t\tif(rnk[x] < rnk[y]) swap(x,y);\n\t\tpar[y] = x;\n\t\tif(rnk[x] == rnk[y]) rnk[x]++;\n\t}\n\t\n\tbool same(int x,int y){\n\t\treturn (find(x) == find(y));\n\t}\n};\n\nstruct edge{ int from,to,cost; };\n\nsigned main(){\n\tint n,t,k;\n\tfor(int _t = 0;cin >> n >> t >> k,n;_t++){\n\t\tvector<edge> edges;\n\t\tUnionFind uf(n);\n\t\tint ans = 0;\n\t\tfor(int i = 0;i < n - 1;i++){\n\t\t\tint a,b,w;\n\t\t\tcin >> a >> b >> w; a--;b--;\n\t\t\tedges.push_back({a,b,w});\n\t\t\tans += w;\n\t\t}\n\t\tsort(edges.begin(),edges.end(),[](const edge &e1,const edge &e2){\n\t\t\treturn e1.cost > e2.cost;\n\t\t});\n\t\tint base[10010];\n\t\tfor(int i = 0;i < t;i++){\n\t\t\tcin >> base[i]; base[i]--;\n\t\t\tif(i) uf.unite(base[i],base[i - 1]);\n\t\t}\n\t\tint other = 0;\n\t\tfor(const auto &e : edges){\n\t\t\tif(!uf.same(e.from,e.to)){\n\t\t\t\tuf.unite(e.from,e.to);\n\t\t\t\tans -= e.cost;\n\t\t\t}else{\n\t\t\t\tif(other < t - k - 1) ans -= e.cost;\n\t\t\t\tother++;\n\t\t\t}\n\t\t}\n\t\tprintf(\"Case %d: %d\\n\",_t + 1,ans);\n\t}\n}\n"
  },
  {
    "language": "C++",
    "code": "#include<bits/stdc++.h>\n\n#define REP(i,s,n) for(int i=s;i<n;i++)\n#define rep(i,n) REP(i,0,n)\n\nusing namespace std;\n\nstruct Edge {\n  int src,dst,weight; \n  bool operator < ( const Edge &e ) const { return weight < e.weight; }\n};\n\nconst int MAX = 10010;\nint par[MAX];\nvector<Edge> edges;\n\nvoid init(int _size=MAX) { rep(i,_size) par[i] = i; } \n\nint find(int x) {\n  if( par[x] == x ) return x;\n  return par[x] = find(par[x]);\n}\n\nvoid unit(int x,int y){\n  x = find(x), y = find(y);\n  if( x != y ) par[x] = y;\n}\n\nbool buffer[MAX];\nbool choose[MAX];\nint counter[MAX];\nvector<int> bases;\nint V,t,k;\n\nbool isValid(int index){\n  choose[index] = false;\n  //map<int,int> mp;\n  rep(i,V) counter[i] = 0, par[i] = i;\n\n  rep(i,V-1) if( choose[i] ) unit(edges[i].src,edges[i].dst);\n  rep(i,t) ++counter[find(bases[i])];\n  rep(i,V) if( counter[find(i)] == 0 ) return false;\n  return true;\n}\n\nvoid compute(){\n  sort(edges.begin(),edges.end());\n  rep(i,V) buffer[i] = true;\n  int answer = 0;\n  int remain = k;\n  int cur = 0;\n  while( cur < V-1 && remain ){\n    rep(i,V) choose[i] = buffer[i];\n    if( isValid(cur) ) {\n      --remain;\n      answer += edges[cur].weight;\n      buffer[cur] = false;\n    }\n    ++cur;\n  }\n  printf(\"%d\\n\",answer);\n}\n\nint main(){\n  int CNT = 1;  \n  while( scanf(\" %d %d %d\",&V,&t,&k) , V|t|k ){\n    edges.clear(), bases.clear();\n    rep(i,V-1) {\n      int s,t,c;\n      scanf(\" %d %d %d\",&s,&t,&c);\n      --s, --t;\n      edges.push_back((Edge){s,t,c});\n    }\n    rep(i,t){\n      int base;\n      scanf(\" %d\",&base);\n      --base;\n      bases.push_back(base);\n    }\n    printf(\"Case %d: \",CNT++);\n    compute();\n  }\n  return 0;\n}"
  },
  {
    "language": "C++",
    "code": "// Template {{{\n#include <bits/stdc++.h>\n#define REP(i,n) for(int i=0; i<(int)(n); ++i)\nusing namespace std;\ntypedef long long LL;\n\n#ifdef LOCAL\n#include \"contest.h\"\n#else\n#define dump(x) \n#endif\n\nclass range {\n    struct Iterator {\n        int val, inc;\n        int operator*() {return val;}\n        bool operator!=(Iterator& rhs) {return val < rhs.val;}\n        void operator++() {val += inc;}\n    };\n    Iterator i, n;\n    public:\n    range(int e) : i({0, 1}), n({e, 1}) {}\n    range(int b, int e) : i({b, 1}), n({e, 1}) {}\n    range(int b, int e, int inc) : i({b, inc}), n({e, inc}) {}\n    Iterator& begin() {return i;}\n    Iterator& end() {return n;}\n};\n\nconst int dx[4] = {1, 0, -1, 0};\nconst int dy[4] = {0, 1, 0, -1};\ninline bool valid(int x, int w) { return 0 <= x && x < w; }\n\nvoid iostream_init() {\n    ios::sync_with_stdio(false);\n    cin.tie(0);\n    cout.setf(ios::fixed);\n    cout.precision(12);\n}\n//}}}\n\nnamespace {\n    struct Edge{\n        int dst, cost;\n    };\n    typedef vector<Edge> Node;\n    typedef vector<Node> Graph;\n    Graph G;\n    vector<bool> is_base;\n    int N, T, K;\n\n    int dp[10001][10001][2];\n    int next[10001][2];\n    int size[10001];\n    void calc(int u, int p) {\n        for(Edge e : G[u]){\n            if(e.dst != p) {\n                calc(e.dst, u);\n            }\n        }\n\n        size[u] = 1;\n        for(Edge e : G[u]) {\n            if(e.dst != p) {\n                size[u] += size[e.dst];\n            }\n        }\n\n        dp[u][0][is_base[u]] = 0;\n        for(Edge e : G[u]) {\n            int c = e.dst;\n            if(c == p) continue;\n\n            // memset(next, 0x3f, sizeof(next));\n            REP(i, K+1) REP(b, 2) next[i][b] = 1e9;\n\n            for(int i = 0; i <= K; i++) {\n                for(int j = 0; j < size[c] && i+j <= K; j++) {\n                    // connect\n                    {\n                        const int ni = i + j;\n                        next[ni][0] = min(next[ni][0], dp[u][i][0] + dp[c][j][0]);\n                        next[ni][1] = min(next[ni][1], dp[u][i][1] + dp[c][j][0]);\n                        next[ni][1] = min(next[ni][1], dp[u][i][0] + dp[c][j][1]);\n                        next[ni][1] = min(next[ni][1], dp[u][i][1] + dp[c][j][1]);\n                    }\n                    // cut\n                    {\n                        const int ni = i + j + 1;\n                        if(ni <= K) {\n                            next[ni][0] = min(next[ni][0], dp[u][i][0] + dp[c][j][1] + e.cost);\n                            next[ni][1] = min(next[ni][1], dp[u][i][1] + dp[c][j][1] + e.cost);\n                        }\n                    }\n                }\n            }\n\n            // memcpy(dp[u], next, sizeof(next));\n            REP(i, K+1) REP(b, 2) dp[u][i][b] = next[i][b];\n        }\n    }\n    void output(int u, int k, int b) {\n        printf(\"dp[%d][%d][%d] = %d\\n\", u, k, b, dp[u][k][b]);\n    }\n}\n\n\nint main(){\n    iostream_init();\n    int Case = 0;\n    while(cin >> N >> T >> K && N > 0) {\n        cout << \"Case \" << ++Case << \": \";\n        G.assign(N, Node());\n        is_base.assign(N, false);\n\n        memset(dp, 0x3f, sizeof(dp));\n\n        REP(i, N-1) {\n            int a, b, w;\n            cin >> a >> b >> w;\n            a--; b--;\n            G[a].push_back({b, w});\n            G[b].push_back({a, w});\n        }\n\n        REP(i, T){\n            int base;\n            cin >> base;\n            base--;\n            is_base[base] = true;\n        }\n\n        calc(0, -1);\n        cout << dp[0][K][1] << endl;\n    }\n    return 0;\n}\n\n/* vim:set foldmethod=marker: */"
  },
  {
    "language": "C++",
    "code": "#include <iostream>\n#include <cstdio>\n#include <cstring>\n#include <algorithm>\n#include <vector>\n#include <set>\n#include <queue>\nusing namespace std;\n#define maxn 10009\nstruct stu\n{\n    int to;\n    int w;\n} e[2*maxn];\nint first[maxn], next[2*maxn], vis[maxn], in[maxn], out[maxn];\nint old[maxn];\nvoid add(int x, int y, int z, int id)\n{\n    next[id] = first[x];\n    first[x] = id;\n    e[id].w = z;\n    e[id].to = y;\n}\nvector <int> b[maxn];\nint main()\n{\n   //freopen(\"in.txt\",\"r\",stdin);\n    int n, t, k;\n    while(scanf(\"%d%d%d\", &n, &t, &k) != EOF && n+t+k)\n    {\n        memset(old, 0, sizeof(old));\n        memset(vis, 0, sizeof(vis));\n        memset(first, -1, sizeof(first));\n        memset(in, 0, sizeof(in));\n        memset(out, 0, sizeof(out));\n        for(int i = 1; i <= n-1; i++)\n        {\n            int x, y, z;\n            scanf(\"%d%d%d\", &x, &y, &z);\n            in[x] ++;\n            in[y] ++;\n            out[x] ++;\n            out[y] ++;\n            add(x, y, z, i);\n            add(y, x, z, i+n-1);\n        }\n        for(int i = 1; i <= t; i++)\n        {\n            int x;\n            scanf(\"%d\",&x);\n            vis[x] = 1;\n        }\n        queue <int> q;\n        for(int i = 1; i <= n; i++) b[i].clear();\n\n        for(int i = 1; i <= n; i++)\n            if(in[i] == 1)\n            {\n                q.push(i);\n                old[i] = 1;\n                if(vis[i])\n                {\n                    for(int j = first[i]; j != -1; j = next[j])\n                    {\n                        int x = e[j].to;\n                        if(!old[x])\n                            b[x].push_back(e[j].w);\n                    }\n                }\n            }\n        int ans = 0;\n        while(!q.empty())\n        {\n            int u = q.front();\n            q.pop();\n            int maxx = 0;\n            for(int i = 0; i < b[u].size(); i++)\n            {\n                maxx = max(maxx, b[u][i]);\n                ans += b[u][i];\n            }\n            if(vis[u] == 0)\n            ans -= maxx;\n            for(int i = first[u]; i != -1; i = next[i])\n            {\n                int x = e[i].to;\n                if(in[x] >= 2)\n                {\n                    in[x] --;\n                    if(vis[x])\n                    {\n                        ans += maxx;\n                    }\n                    else\n                    {\n                        b[x].push_back(maxx);\n                    }\n                    if(in[x] == 1)\n                    {\n                        old[x] = 1;\n                        q.push(x);\n                    }\n                }\n            }\n        }\n        printf(\"%d\\n\", ans);\n    }\n    return 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include<bits/stdc++.h>\nusing namespace std;\nusing Int = long long;\nsigned main(){\n  int n,t,k;\n  int cnt=0;\n  while(cin>>n>>t>>k,n){\n    vector<vector<int> > G(n);\n    vector<map<int,int> > M(n);\n    for(int i=0;i<n-1;i++){\n      int a,b,c;\n      cin>>a>>b>>c;\n      a--;b--;\n      G[a].push_back(b);\n      G[b].push_back(a);\n      M[a][b]=M[b][a]=c;\n    }\n    vector<int> x(t);\n    for(int i=0;i<t;i++) cin>>x[i];\n    vector<int> y(n,0);\n    for(int i=0;i<t;i++) y[--x[i]]=1;\n    vector<vector<int> > dp(2,vector<int>(n,-1));\n    int INF=1<<28;\n    function<int(int,int,int)> dfs=[&](int v,int p,int f){\n      \n      //cout<<f<<\" \"<<v<<\" \"<<p<<\":\"<<dp[f][v]<<endl;\n      if(~dp[f][v]) return dp[f][v];\n      int &res=dp[f][v];\n      res=INF;\n      if(~p&&y[v]&&!f) return INF;\n      int tmp=0,xxx=0;\n      for(int u:G[v]){\n\tif(u==p) continue;\n\tint a=dfs(u,v,0),b=dfs(u,v,1);\n\ttmp+=min(a,b+M[v][u]);\n\txxx++;\n      }\n      //cout<<f<<\" \"<<v<<\" \"<<p<<\":\"<<res<<endl;\n      if(!f||y[v]) return res=tmp;\n      if(!xxx) return res;\n      for(int u:G[v]){\n\tif(u==p) continue;\n\tint a=dfs(u,v,0),b=dfs(u,v,1);\n\tint ushi=tmp;\n\tushi-=min(a,b+M[v][u]);\n\tushi+=b;\n\tres=min(res,ushi);\n      }\n      //cout<<f<<\" \"<<v<<\" \"<<p<<\":\"<<res<<endl;\n      return res;\n    };\n    cout<<\"Case \"<<++cnt<<\": \"<<dfs(x[0],-1,0)<<endl;\n  }\n  return 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include<bits/stdc++.h>\n\n#define REP(i,s,n) for(int i=s;i<n;i++)\n#define rep(i,n) REP(i,0,n)\n\nusing namespace std;\n\nstruct Edge {\n  int src,dst,weight;\n  bool operator < ( const Edge &e ) const { return weight > e.weight; }\n};\n\nconst int MAX = 10001;\nint V,t,k,par[MAX],base[MAX],CNT=1;\nEdge edge[MAX];\n\nint find(int x){\n  if( x == par[x] ) return x;\n  return par[x] = find(par[x]);\n}\n\nvoid unit(int x,int y){\n  x = find(x), y = find(y);\n  if( x != y ) par[x] = y;\n}\n\nint main(){\n  while( scanf(\" %d %d %d\",&V,&t,&k), V|t|k ){\n    rep(i,V) par[i] = i;\n    int sum = 0;\n    rep(i,V-1){\n      scanf(\" %d %d %d\",&edge[i].src,&edge[i].dst,&edge[i].weight);\n      --edge[i].src, --edge[i].dst;\n      sum += edge[i].weight;\n    }\n    rep(i,t) {\n      scanf(\" %d\",base+i);\n      if( i ) unit(base[0],base[i]);\n    }\n    sort(edge,edge+V-1);\n    int coef = 0, remain = t - 1 - k;\n    rep(i,V-1) {\n      int s = edge[i].src, t = edge[i].dst;\n      if( find(s) == find(t) && remain ) {\n\t--remain;\n\tcoef += edge[i].weight;\n      } else {\n\tunit(s,t);\n\tcoef += edge[i].weight;\n      }\n    }\n    printf(\"Case %d: %d\\n\",CNT++,sum-coef);\n  }\n  return 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include<bits/stdc++.h>\nusing namespace std;\n\nstruct unionfind{\n  int parent[200000];\n  int size[200000];\n  \n  void init(int n){\n    for(int i=0;i<n;i++){\n      parent[i]=i;\n      size[i]=1;\n    }\n  }\n  int find(int x){\n    if(parent[x]==x)return x;\n    else parent[x]=find(parent[x]);\n  }\n  bool same(int x,int y){\n    return (find(x)==find(y));\n  }\n  bool getSize(int x){\n    return size[ find(x) ];\n  }\n  void unite(int x,int y){\n    x=find(x);\n    y=find(y);\n    if(x==y)return;\n    if(size[x]>size[y])swap(x,y);\n    parent[x]=y;\n    size[y]+=size[x];\n  }\n};\n  \nstruct edge{\n  int from,to,cost;\n  bool operator < (const edge &e) const {\n    return cost < e.cost;\n  }\n};\n\nint n,t,k;\nunionfind uf;\n\nint main(){\n\n  \n  for(int tc=1;;tc++){\n    cin>>n>>t>>k;\n    if(n==0&&t==0&&k==0)break;\n    vector<edge> E;\n    for(int i=0;i<n-1;i++){\n      int a,b,c;\n      cin>>a>>b>>c;\n      a--,b--;\n      E.push_back( (edge){a,b,-c} );\n    }\n    for(int i=0;i<t;i++){\n      int a;\n      cin>>a;\n      a--;\n      E.push_back( (edge){a,n,-20000} );\n    }\n    sort(E.begin(),E.end());\n    uf.init(n+1);\n\n    vector<edge> tmp;\n    \n    for(int i=0;i<(int)E.size();i++){\n      edge e=E[i];\n      if( uf.same(e.from,e.to) ){\n        tmp.push_back(e);\n      }else{\n        uf.unite(e.from,e.to);\n      }\n    }\n\n    int ans=0;\n    assert( (int)tmp.size() == t-1 );\n    \n    for(int i=t-1-k;i<(int)tmp.size();i++){\n      ans-=tmp[i].cost;\n    }\n    cout<<\"Case \"<<tc<<\": \"<<ans<<endl;\n    \n  }\n  return 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include <set>\n#include <iostream>\n#include <cstdio>\n#include <algorithm>\n#include <queue>\n#define REP(i,n) for(int i=0; i<(int)(n); i++)\n\ninline int getInt(){ int s; scanf(\"%d\", &s); return s; }\n\nusing namespace std;\n\nclass UnionFind{\nprivate:\n  vector<int> id;\n\n  int getId(int i){\n    if(i == id[i]) return i;\n    return id[i] = getId(id[i]);\n  }\npublic:\n  UnionFind(int size = 0){ init(size); }\n  ~UnionFind(){}\n  void init(int size){\n    id = vector<int>(size);\n    for(int i = 0; i < size; i++)\n      id[i] = i;\n  }\n  void unite(int i, int j){\n    int next = min( getId(i), getId(j) );\n    id[getId(i)] = id[getId(j)] = next;\n  }\n  int operator [](int i){ return getId(i); }\n  int count(){\n    set<int> s;\n    for(int i = 0; i < (int)id.size(); i++)\n      s.insert(getId(i));\n    return s.size();\n  }\n};\n\nint main(){\n  for(int cc = 1; ; ++cc){\n    int n = getInt();\n    int t = getInt();\n    int k = getInt();\n\n    if(n + t + k == 0) break;\n\n    vector<vector<pair<int, int> > > g(n);\n    vector<int> base(n);\n    UnionFind uf(n);\n    vector<int> a(n - 1);\n    vector<int> b(n - 1);\n    vector<int> c(n - 1);\n\n    REP(i,n - 1){\n      a[i] = getInt() - 1;\n      b[i] = getInt() - 1;\n      c[i] = getInt();\n    }\n\n    vector<pair<int, int> > s(n);\n    REP(i,n) s[i] = make_pair(1, i);\n\n    REP(i,t) s[getInt() - 1].first = 0;\n    sort(s.begin(), s.end());\n    vector<int> m(n);\n    REP(i,n) m[s[i].second] = i;\n\n    priority_queue<pair<int, pair<int, int> > > pq;\n    REP(i,n - 1){\n      a[i] = m[a[i]];\n      b[i] = m[b[i]];\n\n      pq.push(make_pair(c[i], make_pair(a[i], b[i])));\n    }\n\n    vector<int> candidate;\n    while(pq.size()){\n      int cost = pq.top().first;\n      int aa   = pq.top().second.first;\n      int bb   = pq.top().second.second;\n      pq.pop();\n\n      if(uf[aa] < t && uf[bb] < t){\n\tcandidate.push_back(cost);\n      }\n\n      uf.unite(aa, bb);\n    }\n\n    sort(candidate.begin(), candidate.end());\n\n    int ans = 0;\n    REP(i,k) ans += candidate[i];\n\n    printf(\"Case %d: %d\\n\", cc, ans);\n  }\n  return 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include <iostream>\n#include <vector>\n#include <map>\n#include <algorithm>\nusing namespace std;\n\nconst int MAX_V = 100000;\ntypedef pair<int,int> P;\nstruct edge{ int to,cost; };\n\n// グラフ (隣接リスト)\nvector<edge> G[MAX_V];\n// e = (u,v) , is_cost[e] := コスト\nmap<P,int> is_cost;\n// base[u] == true のとき ノード u は ベース\nbool base[MAX_V];\n// (cost,(u,v))の組\nvector< pair<int ,P> > a;\n// used[u] == true のとき ノード u は探索済み\nbool used[MAX_V];\n\nint n, t, k;\n\n\n// 初期化\nvoid init(){\n\ta.clear();\n\tis_cost.clear();\n\tfor(int i=0 ; i < MAX_V ; i++ ){\n\t\tbase[i] = false;\n\t\tG[i].clear();\n\t}\n}\n\n// グラフに重みcostのエッジ(u,v)を追加\nvoid add_edge(int u, int v, int cost){\n\tedge e;\n\te.to = v;\n\te.cost = cost;\n\tG[u].push_back( e );\n\te.to = u;\n\tG[v].push_back( e );\n}\n\n// グラフのエッジ(u,v)を切断\nvoid cut_edge(int u, int v){\n\tfor(vector<edge>::iterator it = G[u].begin() ; it != G[u].end() ; ++it ){\n\t\tif( (*it).to == v ){\n\t\t\tG[u].erase( it );\n\t\t\treturn ;\n\t\t}\n\t}\n}\n\n\n// ノード u の木にベースがあるかどうか\nvoid is_base(int u, bool& flag){\n\tif( u < 0 || u >= n ) return;\n\t\n\t// ノード u がベースのとき\n\tif( base[u] ){\n\t\tflag = true;\n\t\treturn;\n\t}\n\t// ノード u が探索済みのとき\n\tif( used[u] ) return;\n\tused[u] = true;\n\t\n\tfor(int i=0 ; i < G[u].size() ; i++ ){\n\t\tedge e = G[u][i];\n\t\tis_base( e.to , flag );\n\t}\n}\n\nint solve(){\n\t\n\t// 連結成分の数\n\tint p=1;\n\t// コストの総和\n\tint sum = 0;\n\t\n\tsort( a.begin() , a.end() );\n\tfor(int i=0 ; i < a.size() ; i++ ){\n\t\tint cost = a[i].first;\n\t\tint u = a[i].second.first;\n\t\tint v = a[i].second.second;\n\t\tif( u > v ) swap(u,v);\n\t\t\n\t\tcut_edge( u , v );\n\t\t\n\t\tbool flag1 = false, flag2 = false;\n\t\tfor(int j=0 ; j < MAX_V ; j++ ) used[j] = false;\n\t\tis_base( u , flag1 );\n\t\tfor(int j=0 ; j < MAX_V ; j++ ) used[j] = false;\n\t\tis_base( v , flag2 );\n\t\t//flag1 = flag2 = true;\n\t\t\n\t\t// u,vの木の両方にベースを含むとき切断する\n\t\tif( flag1 && flag2 ){\n\t\t\tsum += is_cost[P(u,v)];\n\t\t\tp++;\n\t\t}else{\n\t\t\tadd_edge( u , v , is_cost[P(u,v)] );\n\t\t}\n\t\t\n\t\t// 連結成分が K+1 個になったらループを抜ける\n\t\tif( p == k+1 ) break;\n\t}\n\treturn sum;\n}\n\nint main(){\n\tfor(int t_ = 1 ; cin >> n >> t >> k , (n || t || k) ; t_++ ){\n\t\t// 初期化\n\t\tinit();\n\t\t\n\t\tfor(int i = 0 ; i < n-1 ; i++ ){\n\t\t\tint u, v, cost;\n\t\t\tcin >> u >> v >> cost;\n\t\t\tu--; v--;\n\t\t\tif( u > v ) swap(u,v);\n\t\t\t\n\t\t\tis_cost[P(u,v)] = cost;\n\t\t\tadd_edge( u , v , cost );\n\t\t\tpair<int,P> p( cost , P(u,v) );\n\t\t\ta.push_back( p );\n\t\t}\n\t\tfor(int i = 0 ; i < t ; i++ ){\n\t\t\tint b;\n\t\t\tcin >> b;\n\t\t\tb--;\n\t\t\tbase[b] = true;\n\t\t}\n\t\t\n\t\tint ans = solve();\n\t\tcout << \"Case \" << t_ << \": \" << ans << endl;\n\t}\n}"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\n\nusing namespace std;\n\nstruct UnionFind {\n  vector<int> data;\n  UnionFind(int n):data(n, -1){}\n  int find(int x) {\n    return data[x] < 0 ? x : data[x] = find(data[x]);\n  }\n  bool same(int x, int y) {\n    return find(x) == find(y);\n  }\n  void unite(int x, int y) {\n    x = find(x), y = find(y);\n    if(x == y) return;\n    if(data[x] < data[y]) swap(x, y);\n    data[x] += data[y];\n    data[y] = x;\n  }\n};\n\nstruct edge {\n  int to, cost;\n  edge(){}\n  edge(int to, int cost):to(to), cost(cost){}\n};\n\nusing Pi = pair<int, int>;\n\nvector<vector<edge>> graph;\n\nint main() {\n  int n, t, k;\n  int T = 0;\n  while(cin >> n >> t >> k, n || t || k) {\n    graph.clear();\n    graph.resize(n);\n    for(int i = 0; i < n-1; i++) {\n      int a, b, c;\n      cin >> a >> b >> c;\n      --a, --b;\n      graph[a].emplace_back(b, c);\n      graph[b].emplace_back(a, c);\n    }\n    priority_queue<pair<Pi, Pi>> que;\n    UnionFind uf(t);\n    vector<bool> used(n, false);\n    map<int, int> id;\n    for(int i = 0; i < t; i++) {\n      int b;\n      cin >> b;\n      --b;\n      id[b] = i;\n      que.emplace(Pi(0, b), Pi(id[b], id[b]));\n    }\n    vector<int> ans;\n    while(!que.empty()) {\n      auto p = que.top(); que.pop();\n      int now = p.first.second, x = p.second.first, y = p.second.second;\n      if(used[now]) continue;\n      used[now] = true;\n      if(x != y) {\n\tuf.unite(x, y);\n\tans.push_back(p.first.first);\n      }\n      for(edge& e : graph[now]) {\n\tint z = id.count(e.to) ? id[e.to] : x;\n\tque.emplace(Pi(e.cost, e.to), Pi(z, x));\n      }\n    }\n    sort(ans.begin(), ans.end());\n    int total = 0;\n    for(int i = 0; i < k; i++) total += ans[i];\n    cout << \"Case \" << ++T << \": \" << total << endl;\n  }\n  return 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include<cstdio>\n#include<algorithm>\n#include<vector>\n#include<map>\n\nusing namespace std;\n\n\nstruct E{\n    int node1,node2,wgt;\n    E(){\n        node1=-1;\n        node2=-1;\n        wgt=-1;\n    }\n    E(int a,int b,int c){\n        node1=a;\n        node2=b;\n        wgt=c;\n    }\n};\n\nbool cmp(E x, E y){\n    return x.wgt<y.wgt;\n}\n\nmap<int,map<int,int>> mp;\nvector<E> edge[20000];\nE edgelst[20000];\nbool ismil[20000];\nint n,k,t,par[20000],chl[20000];\n\nint dfs(int cur,int prev){\n    int tmp=0,next;\n    for(int i=0;i<edge[cur].size();i++){\n        next = edge[cur][i].node2;\n        if(next==prev)\n            continue;\n        par[next]=cur;\n        tmp+=dfs(next,cur);\n    }\n    chl[cur]=tmp;\n    if(ismil[cur])\n        return 1;\n    mp[cur][prev]=tmp>0;\n    mp[prev][cur]=tmp>0;\n    return tmp>0;\n}\n\nvoid reform(int cur,int parent,int Label){\n    if(Label<0){\n        ///down\n        if(!ismil[cur]){\n//        printf(\"(%d %d %d)\",cur,parent,Label);\n            if(chl[cur]==1){\n                int next;\n                for(int i=0;i<edge[cur].size();i++){\n                    next = edge[cur][i].node2;\n                    if(mp[cur][next]==0)\n                        continue;\n                    mp[cur][next]=0;\n                    mp[next][cur]=0;\n                    par[next]=0;\n                    reform(next,cur,-1);\n                    return ;\n                }\n            }\n        }\n    }\n    else{\n        ///up\n        if(ismil[parent]==1)\n            return;\n//        printf(\"(%d %d %d)\",cur,parent,Label);\n        if(par[parent]==0){\n            if(chl[parent]==1){\n                reform(parent,0,-1);\n            }\n        }\n        if(par[parent]!=0&&chl[parent]==0){\n            mp[parent][par[parent]]=0;\n            mp[par[parent]][parent]=0;\n            chl[par[parent]]--;\n            reform(parent,par[parent],1);\n            //parent = par[parent];\n        }\n    }\n}\n\nint main(){\n\n    int x,y,w,ans,cur=0,c=0,tmp,cnt=1,parent;\n\n    while(true){\n        scanf(\"%d%d%d\",&n,&t,&k);\n        if(n==0)\n            return 0;\n        /// RESET\n        ans=0;\n        cur=0;\n        for(int i=0;i<=n;i++){\n            par[i]=0;\n            chl[i]=0;\n            ismil[i]=false;\n            edge[i].clear();\n            mp.clear();\n        }\n        /// Begin\n        for(int i=0;i<n-1;i++){\n            scanf(\"%d%d%d\",&x,&y,&w);\n            edge[x].push_back(E(x,y,w));\n            edge[y].push_back(E(y,x,w));\n            edgelst[i]=E(x,y,w);\n            mp[x][y]=1;\n            mp[y][x]=1;\n        }\n        for(int i=0;i<t;i++){\n            scanf(\"%d\",&x);\n            ismil[x]=true;\n            tmp=x;\n        }\n        sort(edgelst,edgelst+n-1,cmp);\n        par[tmp]=0;\n        dfs(tmp,0);\n//        for(int i=0;i<n-1;i++){\n//            printf(\"%d %d %d\\n\",edgelst[i].node1,edgelst[i].node2,mp[edgelst[i].node1][edgelst[i].node2]);\n//        }\n        //printf(\"%d\",edge[0].front().wgt);\n        c=0;\n        while(k>0&&c<n){\n            x = edgelst[c].node1;\n            y = edgelst[c].node2;\n            w = edgelst[c].wgt;\n\n\n            if(mp[x][y]==1){\n                cur=y; parent=x;\n                if(par[x]==y){\n                    parent = y;\n                    cur=x;\n                }\n                ans+=w;\n                k--;\n                mp[cur][parent]=0;\n                mp[parent][cur]=0;\n                chl[parent]--;\n                par[cur]=0;\n\n                reform(cur,parent,-1);\n                reform(cur,parent,1);\n            }\n            c++;\n//            else{\n//                mp[x][y]=tmp1;\n//                mp[y][x]=tmp2;\n//            }\n        }\n        if(k>0)\n            ans=-1;\n        printf(\"Case %d: %d\\n\",cnt,ans);\n        cnt++;\n    }\n}\n\n"
  },
  {
    "language": "C++",
    "code": "#include<bits/stdc++.h>\n\nusing namespace std;\n\nstruct edge\n{\n  int to, cost;\n};\n\ntypedef pair< int, int > Pi;\n\nint main()\n{\n  int N, T, K;\n  int A[10000], B[10000], C[10000];\n  int testcase = 1;\n\n  while(scanf(\"%d %d %d\", &N, &T, &K), N) {\n\n    vector< edge > g[10000];\n    int deg[10000] = {};\n    bool M[10000] = {};\n    priority_queue< Pi, vector< Pi >, greater<> > que;\n\n    for(int i = 1; i < N; i++) {\n      scanf(\"%d %d %d\", &A[i], &B[i], &C[i]);\n      --A[i], --B[i];\n      g[A[i]].emplace_back((edge) {B[i], C[i]});\n      g[B[i]].emplace_back((edge) {A[i], C[i]});\n      ++deg[A[i]];\n      ++deg[B[i]];\n      que.emplace(C[i], i);\n    }\n\n    for(int i = 0; i < T; i++) {\n      int x;\n      scanf(\"%d\", &x);\n      --x;\n      M[x] = true;\n    }\n\n    queue< int > beet;\n    bool live[10000];\n    for(int i = 0; i < N; i++) {\n      if(deg[i] == 1) beet.emplace(i);\n      live[i] = true;\n    }\n\n    auto update = [&]()\n    {\n      while(!beet.empty()) {\n        int p = beet.front();\n        beet.pop();\n        if(M[p]) continue;\n        --deg[p];\n        if(deg[p] == 0) {\n          live[p] = false;\n          for(auto &e : g[p]) {\n            if(live[e.to]) beet.emplace(e.to);\n          }\n        }\n      }\n    };\n\n    int ret = 0;\n    for(int i = 0; i < K; i++) {\n      update();\n      while(!que.empty()) {\n        int cost, idx;\n        tie(cost, idx) = que.top();\n        que.pop();\n        if(!live[A[idx]] || !live[B[idx]]) continue;\n        ret += cost;\n        --deg[A[idx]];\n        --deg[B[idx]];\n        beet.emplace(A[idx]);\n        beet.emplace(B[idx]);\n        break;\n      }\n    }\n\n    printf(\"Case %d: %d\\n\", testcase++, ret);\n  }\n}"
  },
  {
    "language": "C++",
    "code": "#include <iostream>\n#include <vector>\n#include <algorithm>\n#include <cstdio>\n#include <utility>\n#include <tuple>\nusing namespace std;\nusing int64 = long long int;\nusing AnsType = vector< vector<int64> >;\nusing Graph = vector< vector< pair<int, int> > >;\nconst int64 INF = 1LL << 60;\n\nint N, T, K, is_base[10010];\nAnsType merge(int cost, AnsType& A, AnsType& B) {\n  int sz = min<int>(A.size() + B.size(), K + 1);\n  AnsType res(sz, vector<int64>(2, INF));\n  for(size_t i=0; i<A.size(); i++) {\n    for(size_t j=0; i+j<sz and j<B.size(); j++) {\n      {\n        res[i+j][0] = min(res[i+j][0], A[i][0] + B[j][0]);\n        res[i+j][1] = min(res[i+j][1], A[i][1] + B[j][0]);\n        res[i+j][1] = min(res[i+j][1], A[i][0] + B[j][1]);\n        res[i+j][1] = min(res[i+j][1], A[i][1] + B[j][1]);\n\n        if(i+j+1 < sz) {\n          res[i+j+1][0] = min(res[i+j+1][0], A[i][0] + B[j][1] + cost);\n          res[i+j+1][1] = min(res[i+j+1][1], A[i][1] + B[j][1] + cost);\n        }\n      }\n    }\n  }\n  return res;\n}\n\nAnsType solve_dp(Graph &G, int cur, int par=-1) {\n  // fprintf(stderr, \"cur = %d, par = %d\\n\", cur, par);\n  AnsType res(1, vector<int64>(2, INF));\n  res[0][is_base[cur]] = 0;\n  \n  for(auto e : G[cur]) {\n    int to, cost; tie(to, cost) = e;\n    if(to == par) continue;\n    auto tmp = solve_dp(G, to, cur);\n    res = merge(cost, res, tmp);\n  }\n\n  /*\n  for(size_t i=0; i<res.size(); i++) {\n    for(size_t j=0; j<res[i].size(); j++) {\n      fprintf(stderr, \"cur = %d, dp[%zu][%zu] = %lld\\n\", cur, i, j, res[i][j]);\n    }\n  }\n  */\n  return res;\n}\n\nint solve(int case_num) {\n  scanf(\"%d%d%d\", &N, &T, &K);\n  // cin >> N >> T >> K;\n  if(N == 0 and T == 0 and K == 0) return 1;\n  fill(is_base, is_base + N, false);\n\n  Graph G(N);\n  for(int i=0; i<N-1; i++) {\n    int u, v, w; // cin >> u >> v >> w;\n    scanf(\"%d%d%d\", &u, &v, &w);\n    u--; v--;\n    G[u].emplace_back(v, w);\n    G[v].emplace_back(u, w);\n  }\n\n  for(int i=0; i<T; i++) {\n    int v; scanf(\"%d\", &v);\n    is_base[v-1] = true;\n  }\n\n  auto ans = solve_dp(G, 0);\n  printf(\"Case %d: %lld\\n\", case_num, ans[K][1]);\n  // cout << \"Case \" << case_num << \": \";\n  // cout << ans[K][1] << endl;\n  return 0;\n}\n\nint main() {\n  int t = 0;\n  while(!solve(++t));\n  return 0;\n}\n\n"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\nusing namespace std;\nusing uint = unsigned int;\nusing ll = long long;\nusing pii = pair<int, int>;\n#define dbg(x) cerr<<#x\": \"<<(x)<<'\\n'\n#define dbg_v(x, n) {cerr<<#x\"[]: \";for(long long _=0;_<n;++_)cerr<<(x)[_]<<' ';cerr<<'\\n';}\n#define all(v) v.begin(), v.end()\n#define INF 1000000010\n#define MOD 1000000007\n#define ST_SIZE 1048600\n#define QMAX \n#define NMAX 110\n#define VMAX 110\n\nconst int N = 10005;\n\nstruct edge {\n\tint x, y, cost;\n};\n\nint test, rs, n, t, k, i, x, y, cost;\nbool boss[N];\nedge e[N];\nset<int> lda[N];\n\nvoid clearAll() {\n\tfor(int i = 1; i <= n; ++i) lda[i].clear();\n\tmemset(boss, 0, n + 2);\n\trs = 0;\n}\n\nbool dfs(int x, int tata = -1) {\n\tif(boss[x]) return 1;\n\tfor(auto to : lda[x])\n\t\tif(to != tata && dfs(to, x)) return 1;\n\treturn 0;\n}\n\nint main()\n{\n\tios_base::sync_with_stdio(false);\t\n\t\n\twhile(cin >> n >> t >> k) {\n\t\tif(n + t + k == 0) break;\n\n\t\tclearAll(); ++test;\n\t\tcout << \"Case \" << test << \": \";\n\t\t\n\t\tfor(i = 1; i < n; ++i) {\n\t\t\tcin >> e[i].x >> e[i].y >> e[i].cost;\n\t\t\tlda[e[i].x].insert(e[i].y);\n\t\t\tlda[e[i].y].insert(e[i].x);\n\t\t}\n\t\t\n\t\tfor(i = 1; i <= t; ++i) cin >> x, boss[x] = 1;\n\t\t\n\t\tsort(e + 1, e + n, [](edge a, edge b) { return a.cost < b.cost; });\n\t\t\n\t\tint cnt = 0;\n\t\tfor(i = 1; i < n; ++i) {\n\t\t\tlda[e[i].x].erase(e[i].y);\n\t\t\tlda[e[i].y].erase(e[i].x);\n\t\t\tif(dfs(e[i].x) && dfs(e[i].y)) {\n\t\t\t\trs += e[i].cost;\n\t\t\t\t++cnt;\n\t\t\t\tif(cnt == k) break;\n\t\t\t\tcontinue;\n\t\t\t}\n\t\t\tlda[e[i].x].insert(e[i].y);\n\t\t\tlda[e[i].y].insert(e[i].x);\n\t\t}\n\t\t\n\t\tcout << rs << '\\n';\n\t}\n\t\t\n\treturn 0;\n}\n\n"
  },
  {
    "language": "C++",
    "code": "#include <iostream>\n#include <cstdio>\n#include <vector>\n#include <set>\n#include <map>\n#include <queue>\n#include <deque>\n#include <stack>\n#include <algorithm>\n#include <cstring>\n#include <functional>\n#include <cmath>\nusing namespace std;\n#define rep(i,n) for(int i=0;i<(n);++i)\n#define rep1(i,n) for(int i=1;i<=(n);++i)\n#define all(c) (c).begin(),(c).end()\n#define fs first\n#define sc second\n#define pb push_back\n#define show(x) cout << #x << \" \" << x << endl\nstruct edge{int from,to,cost;};\nbool operator<(const edge& x,const edge& y){\n\treturn x.cost>y.cost;\n}\nint par[10000],id[10000];\nvoid init(int n){\n\trep(i,n) par[i]=i;\n\trep(i,n) id[i]=-1;\n}\nint find(int x){\n\tif(x==par[x]) return x;\n\telse par[x]=find(par[x]);\n}\nvoid unite(int x,int y){\n\tx=find(x),y=find(y);\n\tif(id[x]>=0) par[y]=x;\n\telse par[x]=y;\n}\nvector<edge> es;\nvector<int> costs;\nint main(){\n\tint tt=0;\n\twhile(true){\n\t\ttt++;\n\t\tint n,t,k;\n\t\tcin>>n>>t>>k;\n\t\tif(n==0) break;\n\t\tes.clear();\n\t\tinit(n);\n\t\trep(i,n-1){\n\t\t\tint a,b,c;\n\t\t\tcin>>a>>b>>c;\n\t\t\tes.pb(edge{a-1,b-1,c});\n\t\t}\n\t\trep(i,t){\n\t\t\tint x;\n\t\t\tcin>>x;\n\t\t\tid[x-1]=x-1;\n\t\t}\n\t\tsort(all(es));\n\t\tcosts.clear();\n\t\trep(i,n-1){\n\t\t\tint a=es[i].from,b=es[i].to,c=es[i].cost;\n\t\t\ta=find(a),b=find(b);\n\t\t\tif(id[a]>=0&&id[b]>=0) costs.pb(c);\n\t\t\telse unite(a,b);\n\t\t}\n\t\tsort(all(costs));\n//\t\tshow(costs.size());\n\t\tint sum=0;\n\t\trep(i,k) sum+=costs[i];\n\t\tprintf(\"Case %d: %d\\n\",tt,sum);\n\t}\n}"
  },
  {
    "language": "C++",
    "code": "#include<bits/stdc++.h>\nusing namespace std;\ntypedef pair<int,int> pii;\n\nint costs[10001];\n\nint main(){\n  int n,t,k,case_num = 0;\n  while(scanf(\"%d%d%d\",&n,&t,&k), n){\n    case_num++;\n\n    memset(costs,0,sizeof(costs));\n    vector< vector<pii> > tree(n);\n\n    for(int i=0;i<n-1;i++){\n      int a,b,c;\n      scanf(\"%d%d%d\",&a,&b,&c);\n      a--; b--;\n      tree[a].push_back(pii(c,b));\n      tree[b].push_back(pii(c,a));\n      costs[c]++;\n    }\n\n    vector<int> base(t), use(n,0);\n    for(int i=0;i<t;i++){\n      scanf(\"%d\",&base[i]);\n      base[i]--;\n      use[base[i]] = 1;\n    }\n\n    priority_queue<pii> q;\n    for(int v : base){\n      for(pii u : tree[v]){\n\tif(!use[u.second])q.push(u);\n      }\n    }\n\n    while(q.size()){\n      pii p = q.top(); q.pop();\n      if(use[p.second])continue;\n      use[p.second] = 1;\n      costs[p.first]--;\n\n      for(pii u : tree[p.second]){\n\tif(!use[u.second])q.push(u);\n      }\n    }\n\n    int p = 0;\n    int res = 0;\n    while(k){\n      int r = min(k,costs[p]);\n      res += p*r; k-=r; p++;\n    }\n    printf(\"Case %d: %d\\n\",case_num, res);\n  }\n}"
  },
  {
    "language": "C++",
    "code": "//15:53-17:33\n#include <bits/stdc++.h>\nusing namespace std;\ntypedef long long ll;\ntypedef pair<int,int> P;\ntypedef pair<int,P> P1;\ntypedef pair<P,P> P2;\n#define pu push\n#define pb push_back\n#define mp make_pair\n#define eps 1e-7\n#define INF 1000000000\n#define fi first\n#define sc second\n#define rep(i,x) for(int i=0;i<x;i++)\n#define SORT(x) sort(x.begin(),x.end())\n#define ERASE(x) x.erase(unique(x.begin(),x.end()),x.end())\n#define POSL(x,v) (lower_bound(x.begin(),x.end(),v)-x.begin())\n#define POSU(x,v) (upper_bound(x.begin(),x.end(),v)-x.begin())\nint n,m,k;\nvector<P1>vec;\nvector<P>edge[10005];\nbool good[10005];\nbool used[10005],ok;\nP forbid;\nvoid dfs(int v){\n\tif(used[v]) return;\n\tif(good[v]) ok = 1; used[v] = 1;\n\t//cout << v << endl;\n\tfor(int i=0;i<edge[v].size();i++){\n\t\tif(mp( min(v,edge[v][i].fi), max(v,edge[v][i].fi) ) == forbid){\n\t\t\tcontinue;\n\t\t}\n\t\tif(!used[edge[v][i].fi]) dfs(edge[v][i].fi);\n\t}\n}\nint main(){\n\tfor(int q=1;;q++){\n\t\tscanf(\"%d%d%d\",&n,&m,&k);\n\t\tif(n==0) return 0;\n\t\tvec.clear(); rep(i,10005) edge[i].clear();\n\t\tfor(int i=1;i<n;i++){\n\t\t\tint a,b,c; scanf(\"%d%d%d\",&a,&b,&c);\n\t\t\tvec.pb(mp(c,mp(a,b)));\n\t\t\tedge[a].pb(mp(b,c));\n\t\t\tedge[b].pb(mp(a,c));\n\t\t}\n\t\tfor(int i=0;i<m;i++){\n\t\t\tint x; cin >> x; good[x] = 1;\n\t\t}\n\t\trep(i,1005) SORT(edge[i]);\n\t\tsort(vec.begin(),vec.end());\n\t\tll ret = 0;int c = 0;\n\t\tfor(int i=0;i<vec.size()&&c<k;i++){\n\t\t\tmemset(used,0,sizeof(used));\n\t\t\tint cs = vec[i].fi;\n\t\t\tint L = vec[i].sc.fi,R = vec[i].sc.sc;\n\t\t\tforbid = mp(min(L,R),max(L,R));\n\t\t\tok = 0;\n\t\t\tdfs(L);\n\t\t\tif(!ok) continue;\n\t\t\tok = 0;\n\t\t\tdfs(R);\n\t\t\tif(!ok) continue;\n\t\t\tedge[L].erase(lower_bound(edge[L].begin(),edge[L].end(),mp(R,cs)));\n\t\t\tedge[R].erase(lower_bound(edge[R].begin(),edge[R].end(),mp(L,cs)));\n\t\t\tc++; ret += cs; //cout << ret << endl;\n\t\t}\n\t\tcout << \"Case \" << q << \": \" << ret << endl;\n\t}\n}"
  },
  {
    "language": "C++",
    "code": "#include<bits/stdc++.h>\nusing namespace std;\n\nstruct unionfind{\n  int parent[20000];\n  int size[20000];\n  \n  void init(int n){\n    parent.resize(n);\n    size.resize(n);\n    for(int i=0;i<n;i++){\n      parent[i]=i;\n      size[i]=1;\n    }\n  }\n  int find(int x){\n    if(parent[x]==x)return x;\n    else parent[x]=find(parent[x]);\n  }\n  bool same(int x,int y){\n    return (find(x)==find(y));\n  }\n  bool getSize(int x){\n    return size[ find(x) ];\n  }\n  void unite(int x,int y){\n    x=find(x);\n    y=find(y);\n    if(x==y)return;\n    if(size[x]>size[y])swap(x,y);\n    parent[x]=y;\n    size[y]+=size[x];\n  }\n};\n  \nstruct edge{\n  int from,to,cost;\n  bool operator < (const edge &e) const {\n    return cost < e.cost;\n  }\n};\n\nint n,t,k;\n\nint main(){\n  unionfind uf;\n  \n  for(int tc=1;;tc++){\n    cin>>n>>t>>k;\n    if(n==0&&t==0&&k==0)break;\n    vector<edge> E;\n    for(int i=0;i<n-1;i++){\n      int a,b,c;\n      cin>>a>>b>>c;\n      a--,b--;\n      E.push_back( (edge){a,b,-c} );\n    }\n    for(int i=0;i<t;i++){\n      int a;\n      cin>>a;\n      a--;\n      E.push_back( (edge){a,n,-20000} );\n    }\n    sort(E.begin(),E.end());\n    uf.init(n+1);\n\n    vector<edge> tmp;\n    \n    for(int i=0;i<(int)E.size();i++){\n      edge e=E[i];\n      if( uf.same(e.from,e.to) ){\n        tmp.push_back(e);\n      }else{\n        uf.unite(e.from,e.to);\n      }\n    }\n\n    int ans=0;\n    for(int i=t-1-k;i<(int)tmp.size();i++){\n      ans-=tmp[i].cost;\n    }\n    cout<<\"Case \"<<tc<<\": \"<<ans<<endl;\n    \n  }\n  return 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include<bits/stdc++.h>\nusing namespace std;\n\nconst int maxn = 1e4+4;\nint fro[maxn],to[maxn],cst[maxn];\nint vis[maxn];\nint bas[maxn];\nint clk;\n\nint has[maxn];\nint pa[maxn];\nint fdst(int x){ return x==pa[x]?x:pa[x]=fdst(pa[x]); }\n\nint edge[2][maxn];\n\nbool cmp(int a,int b) { return cst[a] > cst[b]; }\n\n//#define LOCAL\nint main()\n{\n#ifdef LOCAL\n    freopen(\"in.txt\",\"r\",stdin);\n#endif\n    int n,t,k,ks = 0;\n    while(scanf(\"%d%d%d\",&n,&t,&k),n){\n        for(int i = 1; i < n; i++){\n            scanf(\"%d%d%d\",fro+i,to+i,cst+i);\n        }\n        clk++;\n        for(int i = 0; i < t; i++){\n            int x; scanf(\"%d\",&x);\n            bas[x] = clk;\n        }\n        int swc = 0;\n        int c = 0;\n        for(int i = 1; i < n; i++){\n            edge[swc][c++] = i;\n        }\n        for(int i = 1; i <= n; i++){\n            has[i] = bas[i] == clk?1:0;\n            pa[i] = i;\n        }\n        int cnt = n-1-k;\n        #define E edge[swc]\n        sort(E,E+c,cmp);\n        while(cnt){\n            bool flg = true;\n            int tc = 0;\n            for(int i = 0; i < c; i++){\n                int x = E[i];\n                int a = fdst(fro[x]), b = fdst(to[x]);\n                if(has[a]^has[b]){\n                    flg = false;\n                    cnt--;\n                    vis[x] = clk;\n                    pa[a] = b;\n                    has[b] = true;\n                }else {\n                    edge[swc^1][tc++] = i;\n                }\n            }\n            swc ^= 1;\n            c = tc;\n            if(flg){\n                for(int i = 0; i < c&&cnt; i++){\n                    int x = E[i];\n                    cnt--;\n                }\n            }\n        }\n        int ans = 0;\n        for(int i = 1; i < n; i++){\n            if(vis[i] != clk) ans += cst[i];\n        }\n        printf(\"Case %d: %d\\n\",++ks,ans);\n    }\n    return 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include <iostream>\n#include <vector>\n#include <map>\n#include <algorithm>\nusing namespace std;\n\nconst int MAX_V = 100000;\ntypedef pair<int,int> P;\nstruct edge{ int to,cost; };\n\n// グラフ (隣接リスト)\nvector<edge> G[MAX_V];\n// e = (u,v) , is_cost[e] := コスト\nmap<P,int> is_cost;\n// base[u] == true のとき ノード u は ベース\nbool base[MAX_V];\n// (cost,(u,v))の組\nvector< pair<int ,P> > a;\n// used[u] == true のとき ノード u は探索済み\nbool used[MAX_V];\n\nint n, t, k;\n\n\n// 初期化\nvoid init(){\n\ta.clear();\n\tis_cost.clear();\n\tfor(int i=0 ; i < MAX_V ; i++ ){\n\t\tbase[i] = false;\n\t\tG[i].clear();\n\t}\n}\n\n// グラフに重みcostのエッジ(u,v)を追加\nvoid add_edge(int u, int v, int cost){\n\tedge e;\n\te.to = v;\n\te.cost = cost;\n\tG[u].push_back( e );\n\te.to = u;\n\tG[v].push_back( e );\n}\n\n// グラフのエッジ(u,v)を切断\nvoid cut_edge(int u, int v){\n\tfor(vector<edge>::iterator it = G[u].begin() ; it != G[u].end() ; ++it ){\n\t\tif( (*it).to == v ){\n\t\t\tG[u].erase( it );\n\t\t\treturn ;\n\t\t}\n\t}\n}\n\n\n// ノード u の木にベースがあるかどうか\nvoid is_base(int u, bool& flag){\n\t// ノード u がベースのとき\n\tif( base[u] ){\n\t\tflag = true;\n\t\treturn;\n\t}\n\t// ノード u が探索済みのとき\n\tif( used[u] ) return;\n\tused[u] = true;\n\t\n\tfor(int i=0 ; i < G[u].size() ; i++ ){\n\t\tedge e = G[u][i];\n\t\tis_base( e.to , flag );\n\t}\n}\n\nint solve(){\n\t\n\t// 連結成分の数\n\tint p=1;\n\t// コストの総和\n\tint sum = 0;\n\t\n\tsort( a.begin() , a.end() );\n\tfor(int i=0 ; i < a.size() ; i++ ){\n\t\tint cost = a[i].first;\n\t\tint u = a[i].second.first;\n\t\tint v = a[i].second.second;\n\t\tif( u > v ) swap(u,v);\n\t\t\n\t\tcut_edge( u , v );\n\t\t\n\t\tbool flag1 = false, flag2 = false;\n\t\tfor(int j=0 ; j < n ; j++ ) used[j] = false;\n\t\t//is_base( u , flag1 );\n\t\tfor(int j=0 ; j < n ; j++ ) used[j] = false;\n\t\t//is_base( v , flag2 );\n\t\tflag1 = flag2 = true;\n\t\t\n\t\t// u,vの木の両方にベースを含むとき切断する\n\t\tif( flag1 && flag2 ){\n\t\t\tsum += is_cost[P(u,v)];\n\t\t\tp++;\n\t\t}else{\n\t\t\tadd_edge( u , v , is_cost[P(u,v)] );\n\t\t}\n\t\t\n\t\t// 連結成分が K+1 個になったらループを抜ける\n\t\tif( p == k+1 ) break;\n\t}\n\treturn sum;\n}\n\nint main(){\n\tfor(int t_ = 1 ; cin >> n >> t >> k , (n || t || k) ; t_++ ){\n\t\t// 初期化\n\t\tinit();\n\t\t\n\t\tfor(int i = 0 ; i < n-1 ; i++ ){\n\t\t\tint u, v, cost;\n\t\t\tcin >> u >> v >> cost;\n\t\t\tu--; v--;\n\t\t\tif( u > v ) swap(u,v);\n\t\t\t\n\t\t\tis_cost[P(u,v)] = cost;\n\t\t\tadd_edge( u , v , cost );\n\t\t\tpair<int,P> p( cost , P(u,v) );\n\t\t\ta.push_back( p );\n\t\t}\n\t\tfor(int i = 0 ; i < t ; i++ ){\n\t\t\tint b;\n\t\t\tcin >> b;\n\t\t\tb--;\n\t\t\tbase[b] = true;\n\t\t}\n\t\t\n\t\tint ans = solve();\n\t\tcout << \"Case \" << t_ << \": \" << ans << endl;\n\t}\n}"
  },
  {
    "language": "C++",
    "code": "#include <algorithm>\n#include <cstdlib>\n#include <iostream>\n#include <vector>\nusing namespace std;\n\ntypedef pair<int, int> edge;\n#define to first\n#define cost second\n\nconstexpr int MAX_N = 10000;\nconstexpr long long INF = (1 << 30);\n\nvector<edge> G[MAX_N];\nbool need[MAX_N];\n\npair<long long, long long> dfs(int v, int parent = -1) {\n\tlong long connect_base = 0;\n\tlong long not_connect_base = 0;\n\n\tif(need[v]) {\n\t\tnot_connect_base = INF;\n\n\t\tfor(const auto &e : G[v]) {\n\t\t\tif(e.to == parent) continue;\n\n\t\t\tconst auto tmp = dfs(e.to, v);\n\t\t\tconnect_base += min(tmp.first + e.cost, tmp.second);\n\t\t}\n\t}\n\n\telse {\n\t\tlong long max_cost = 0;\n\n\t\tfor(const auto &e : G[v]) {\n\t\t\tif(e.to == parent) continue;\n\n\t\t\tconst auto tmp = dfs(e.to, v);\n\t\t\tif(tmp.first + e.cost < tmp.second) {\n\t\t\t\tnot_connect_base += tmp.first + e.cost;\n\t\t\t\tmax_cost = max<long long>(max_cost, e.cost);\n\t\t\t}\n\t\t\telse if(tmp.first < tmp.second) {\n\t\t\t\tmax_cost = max(max_cost, tmp.second - tmp.first);\n\t\t\t\tnot_connect_base += tmp.second;\n\t\t\t}\n\t\t\telse {\n\t\t\t\tnot_connect_base += tmp.second;\n\t\t\t}\n\t\t\tconnect_base = not_connect_base - max_cost;\n\t\t}\n\t}\n\n\n\treturn make_pair(connect_base, not_connect_base);\n}\n\nint main() {\n\tcin.tie(nullptr);\n\tios::sync_with_stdio(false);\n\n\tfor(int count = 1, n, t, k; cin >> n >> t >> k && n; ++count) {\n\t\tfor(int i = 0; i < n; ++i) {\n\t\t\tG[i].clear();\n\t\t\tneed[i] = false;\n\t\t}\n\n\t\tfor(int i = 0; i < n - 1; ++i) {\n\t\t\tint a, b, c;\n\t\t\tcin >> a >> b >> c;\n\t\t\t--a; --b;\n\t\t\tG[a].emplace_back(b, c);\n\t\t\tG[b].emplace_back(a, c);\n\t\t}\n\n\t\tfor(int i = 0; i < t; ++i) {\n\t\t\tint v;\n\t\t\tcin >> v;\n\t\t\tneed[v - 1] = true;\n\t\t}\n\n\t\tconst auto ans = dfs(0);\n\t\tcout << \"Case \" << count << \": \" << min(ans.first, ans.second) << endl;\n\t}\n\n\treturn EXIT_SUCCESS;\n}"
  },
  {
    "language": "C++",
    "code": "#include<bits/stdc++.h>\n\n#define REP(i,s,n) for(int i=s;i<n;i++)\n#define rep(i,n) REP(i,0,n)\n\nusing namespace std;\n\nstruct Edge {\n  int src,dst,weight; \n  bool operator < ( const Edge &e ) const { return weight < e.weight; }\n};\n\nconst int MAX = 10010;\nint par[MAX];\nvector<Edge> edges;\n\nvoid init(int _size=MAX) { rep(i,_size) par[i] = i; } \n\nint find(int x) {\n  if( par[x] == x ) return x;\n  return par[x] = find(par[x]);\n}\n\nvoid unit(int x,int y){\n  x = find(x), y = find(y);\n  if( x != y ) par[x] = y;\n}\n\nbool buffer[MAX];\nbool choose[MAX];\nvector<int> bases;\nint V,t,k;\n\nbool isValid(int index){\n  choose[index] = false;\n  map<int,int> mp;\n  init(V);\n  rep(i,V-1) if( choose[i] ) unit(edges[i].src,edges[i].dst);\n  rep(i,t) ++mp[find(bases[i])];\n  rep(i,V) if( mp[find(i)] == 0 ) return false;\n  return true;\n}\n\nvoid compute(){\n  sort(edges.begin(),edges.end());\n  rep(i,V) buffer[i] = true;\n  int answer = 0;\n  int remain = k;\n  int cur = 0;\n  while( cur < V-1 && remain ){\n    rep(i,V) choose[i] = buffer[i];\n    if( isValid(cur) ) {\n      --remain;\n      answer += edges[cur].weight;\n      buffer[cur] = false;\n    }\n    ++cur;\n  }\n  printf(\"%d\\n\",answer);\n}\n\nint main(){\n  int CNT = 1;  \n  while( scanf(\" %d %d %d\",&V,&t,&k) , V|t|k ){\n    edges.clear(), bases.clear();\n    rep(i,V-1) {\n      int s,t,c;\n      scanf(\" %d %d %d\",&s,&t,&c);\n      --s, --t;\n      edges.push_back((Edge){s,t,c});\n    }\n    rep(i,t){\n      int base;\n      scanf(\" %d\",&base);\n      --base;\n      bases.push_back(base);\n    }\n    printf(\"Case %d: \",CNT++);\n    compute();\n  }\n  return 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\n#define rep(i,n) for(int i = 0; i < n; i++)\n#define INF 100000000\n#define MOD 1000000007\n#define EPS 1e-10\n#define MAX_N 10000\nusing namespace std;\ntypedef long long ll;\ntypedef pair<int,bool> P;\ntypedef pair<P,P> PP;\n\nstruct UF{\n\tint par[MAX_N];\n\tint rank[MAX_N];\n    bool piv[MAX_N];\n\n\tvoid init(int n){\n\t\trep(i,n){\n\t\t\tpar[i] = i;\n\t\t\trank[i] = 0;\n            piv[i] = false;\n\t\t}\n\t}\n\n\tint find(int x){\n\t\tif(par[x] == x) return x;\n\t\telse return par[x] = find(par[x]);\n\t}\n    \n    bool canunite(int x, int y){\n        x = find(x);\n        y = find(y);\n        if(x == y) return true;\n        if(piv[x] & piv[y]) return false;\n        return true;\n    }\n\n\tvoid unite(int x, int y, int &z){\n\t\tx = find(x);\n\t\ty = find(y);\n\t\tif(x == y) return;\n        \n        if(piv[x] & piv[y]) z--;\n\t\t\n\t\tif(rank[x] < rank[y]){\n\t\t\tpar[x] = y;\n            piv[y] |= piv[x];\n\t\t} else{\n\t\t\tpar[y] = x;\n\t\t\tif(rank[x] == rank[y]) rank[x]++;\n            piv[x] |= piv[y];\n\t\t}\n\t}\n\n\tbool same(int x, int y){\n\t\treturn find(x) == find(y);\n\t}\n} uf;\n\nint n, t, k;\nint ans;\nstruct edge{\n    int w, a, b;\n    bool operator>( const edge& right) const {\n        return w > right.w;\n    }\n} e[10000];\n\nvoid solve(){\n    uf.init(n);\n    ans = 0;\n    rep(i,n-1){\n        int a, b, c;\n        cin >> a >> b >> c;\n        a--; b--;\n        e[i].w = c; e[i].a = a; e[i].b = b;\n    }\n    sort(e,e+n-1,greater<edge>());\n    rep(i,t){\n        int a; cin >> a;\n        a--;\n        uf.piv[a] = true;\n    }\n    rep(i,n-1){\n        if(t-1 == k){\n            if(!uf.canunite(e[i].a,e[i].b)){\n                ans += e[i].w;\n            } else{\n                uf.unite(e[i].a,e[i].b,t);\n            }\n            continue;\n        }\n        uf.unite(e[i].a,e[i].b,t);\n    }\n    cout << ans << endl;\n}\n\nint main(){\n    int i = 1;\n    while(cin >> n >> t >> k){\n        if(n == 0 && t == 0 && k == 0) break;\n        cout << \"Case \" << i << \": \";\n        solve();\n        i++;\n    }\n}"
  },
  {
    "language": "C++",
    "code": "#include<bits/stdc++.h>\n\n#define REP(i,s,n) for(int i=s;i<n;i++)\n#define rep(i,n) REP(i,0,n)\n\nusing namespace std;\n\nstruct Edge {\n  int src,dst,weight; \n  bool operator < ( const Edge &e ) const {\n    return weight < e.weight;\n  }\n};\n\n\n\nconst int MAX = 10010;\nint par[MAX];\nvector<Edge> G[MAX],edges;\n\nvoid init(int _size=MAX) { rep(i,_size) par[i] = i; } \n\nint find(int x) {\n  if( par[x] == x ) return x;\n  return par[x] = find(par[x]);\n}\n\nvoid unit(int x,int y){\n  x = find(x), y = find(y);\n  if( x != y ) par[x] = y;\n}\n\nbool buffer[MAX];\nbool choose[MAX];\nbool isBase[MAX];\nint V,t,k;\n\nbool isValid(int index){\n  choose[index] = false;\n  map<int,int> mp;\n  init(V);\n  rep(i,V-1) if( choose[i] ) unit(edges[i].src,edges[i].dst);\n  rep(i,V) if( isBase[i] ) ++mp[find(i)];\n  for(map<int,int>::iterator it = mp.begin();it != mp.end();it++){\n    if( it->second == 0 ) return false;\n  }\n  return true;\n}\n\nvoid compute(){\n  sort(edges.begin(),edges.end());\n\n  rep(i,V) buffer[i] = true;\n  int answer = 0;\n  int remain = k;\n  int cur = 0;\n  while( cur < V && remain ){\n    rep(i,V) choose[i] = buffer[i];\n    if( isValid(cur) ) {\n      --remain;\n      answer += edges[cur].weight;\n      buffer[cur] = false;\n    }\n    ++cur;\n  }\n  cout << answer << endl;\n}\n\nint main(){\n  int CNT = 1;  \n  while( cin >> V >> t >> k, V|t|k ){\n    edges.clear();\n    rep(i,V) G[i].clear(), isBase[i] = false;\n    rep(i,V-1) {\n      int s,t,c;\n      cin >> s >> t >> c;\n      --s, --t;\n      G[s].push_back((Edge){s,t,c});\n      G[t].push_back((Edge){t,s,c});\n      edges.push_back((Edge){s,t,c});\n    }\n    rep(i,t){\n      int base;\n      cin >> base;\n      --base;\n      isBase[base] = true;\n    }\n    printf(\"Case %d: \",CNT++);\n    compute();\n  }\n  return 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include<bits/stdc++.h>\nusing namespace std;\ntypedef pair<int,int> pii;\n\nint main(){\n  cin.tie(0); ios::sync_with_stdio(0);\n\n  int n,t,k,case_num = 0;\n  while(cin >> n >> t >> k, n){\n    case_num++;\n\n    set<int> costs;\n    vector< vector<pii> > tree(n);\n\n    for(int i=0;i<n-1;i++){\n      int a,b,c;\n      cin >> a >> b >> c;\n      a--; b--;\n      tree[a].push_back(pii(c,b));\n      tree[b].push_back(pii(c,a));\n      costs.insert(c);\n    }\n\n    vector<int> base(t), use(n,0);\n    for(int i=0;i<t;i++){\n      cin >> base[i];\n      base[i]--;\n      use[base[i]] = 1;\n    }\n\n    priority_queue<pii> q;\n    for(int v : base){\n      for(pii u : tree[v]){\n\tif(!use[u.second])q.push(u);\n      }\n    }\n\n    while(q.size()){\n      pii p = q.top(); q.pop();\n      if(use[p.second])continue;\n      use[p.second] = 1;\n      costs.erase(p.first);\n\n      for(pii u : tree[p.second]){\n\tif(use[u.second])continue;\n\tq.push(u);\n      }\n    }\n\n    long long res = 0;\n    auto it = costs.begin();\n    for(int i=0;i<k;i++){\n      res += *it; it++;\n    }\n    cout << \"Case \" << case_num << \": \" << res << endl;\n  }\n}"
  },
  {
    "language": "C++",
    "code": "#include<stdio.h>\n#include<algorithm>\n#include<vector>\n#include<queue>\nusing namespace std;\nvector<pair<int,int> > g[11000];\npair<int,pair<int,int> > edge[11000];\nint v[11000];\nint UF[11000];\nint FIND(int a){\n\tif(UF[a]<0)return a;\n\treturn UF[a]=FIND(UF[a]);\n}\nvoid UNION(int a,int b){\n\ta=FIND(a);b=FIND(b);if(a==b)return;UF[a]+=UF[b];UF[b]=a;\n}\nint main(){\n\tint T=0;\n\tint a,b,c;\n\twhile(scanf(\"%d%d%d\",&a,&b,&c),a){\n\t\tint ret=0;\n\t\tfor(int i=0;i<a-1;i++){\n\t\t\tint p,q,r;scanf(\"%d%d%d\",&p,&q,&r);\n\t\t\tp--;q--;\n\t\t\tg[p].push_back(make_pair(q,r));\n\t\t\tg[q].push_back(make_pair(p,r));\n\t\t\tedge[i]=make_pair(-r,make_pair(p,q));\n\t\t\tret+=r;\n\t\t}\n\t\tstd::sort(edge,edge+a-1);\n\t\tint rem=b-1-c;\n\t\tfor(int i=0;i<a;i++)UF[i]=-1;\n\t\tfor(int i=0;i<a;i++)v[i]=0;\n\t\tint fi=99999;\n\t\tfor(int i=0;i<b;i++){\n\t\t\tint p;scanf(\"%d\",&p);\n\t\t\tp--;v[p]=1;\n\t\t\tfi=min(fi,p);\n\t\t}\n\t\tfor(int i=0;i<a;i++){\n\t\t\tif(v[i])UNION(i,fi);\n\t\t}\n\t\tfor(int i=0;i<a-1;i++){\n\t\t\tif(FIND(edge[i].second.first)!=FIND(edge[i].second.second)){\n\t\t\t\tUNION(edge[i].second.first,edge[i].second.second);\n\t\t\t\tret+=edge[i].first;\n\t\t\t}else if(rem){\n\t\t\t\trem--;\n\t\t\t\tUNION(edge[i].second.first,edge[i].second.second);\n\t\t\t\tret+=edge[i].first;\n\t\t\t}\n\t\t}\n\t\tprintf(\"Case %d: %d\\n\",++T,ret);\n\t}\n}"
  },
  {
    "language": "C++",
    "code": "#include<bits/stdc++.h>\nusing namespace std;\n\nstruct unionfind{\n  int parent[200000];\n  int size[200000];\n  \n  void init(int n){\n    for(int i=0;i<n;i++){\n      parent[i]=i;\n      size[i]=1;\n    }\n  }\n  int find(int x){\n    if(parent[x]==x)return x;\n    else parent[x]=find(parent[x]);\n  }\n  bool same(int x,int y){\n    return (find(x)==find(y));\n  }\n  int getSize(int x){\n    return size[ find(x) ];\n  }\n  void unite(int x,int y){\n    x=find(x);\n    y=find(y);\n    if(x==y)return;\n    if(size[x]>size[y])swap(x,y);\n    parent[x]=y;\n    size[y]+=size[x];\n  }\n};\n  \nstruct edge{\n  int from,to,cost;\n  bool operator < (const edge &e) const {\n    return cost < e.cost;\n  }\n};\n\nint n,t,k;\nunionfind uf;\n\nint main(){\n\n  \n  for(int tc=1;;tc++){\n    cin>>n>>t>>k;\n    if(n==0&&t==0&&k==0)break;\n    vector<edge> E;\n\n    uf.init(n);\n    \n    for(int i=0;i<n-1;i++){\n      int a,b,c;\n      cin>>a>>b>>c;\n      a--,b--;\n      E.push_back( (edge){a,b,-c} );\n      uf.unite(a,b);\n    }\n    //    assert( uf.getSize(0) == n );\n    \n    for(int i=0;i<t;i++){\n      int a;\n      cin>>a;\n      a--;\n      E.push_back( (edge){a,n,-20000} );\n    }\n    sort(E.begin(),E.end());\n    \n    uf.init(n+1);\n\n    vector<edge> tmp;\n    \n    for(int i=0;i<(int)E.size();i++){\n      edge e=E[i];\n      if( uf.same(e.from,e.to) ){\n        tmp.push_back(e);\n      }else{\n        uf.unite(e.from,e.to);\n      }\n    }\n\n    int ans=0;\n    //    assert( (int)tmp.size() == t-1 );\n    \n    \n    for(int i= max(0, (int)tmp.size()-k) ;i<(int)tmp.size();i++){\n      ans-=tmp[i].cost;\n    }\n    cout<<\"Case \"<<tc<<\": \"<<ans<<endl;\n    \n  }\n  return 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include<cstdio>\n#include<vector>\n#include<algorithm>\n\nusing namespace std;\n\nstruct edge{\n\tint to,cost;\n\tedge(){}\n\tedge(int a,int b):to(a),cost(b){}\n};\n\nstruct edge2{\n\tint u,v,cost;\n\tedge2(){}\n\tedge2(int a,int b,int c):u(a),v(b),cost(c){}\n};\n\nbool operator<(const edge2 &e1,const edge2 &e2){\n\tif(e1.cost!=e2.cost) return e1.cost<e2.cost;\n\tif(e1.u!=e2.u) return e1.u<e2.u;\n\treturn e1.v<e2.v;\n}\n\nint K;\n\nvector<edge> G[10100];\nbool isBase[10100];\nbool hasBase[10100];\nint N;\nvector<int> bases;\n\nbool newNode[10100];\nvector<edge> nG[10100];\nint deg[10100];\nint V;\nvector<edge2> es;\n\nvoid init(){\n\tes.clear();\n\tbases.clear();\n\tfor(int i=0;i<N;i++){\n\t\tG[i].clear();\n\t\tisBase[i]=false;\n\t\thasBase[i]=false;\n\t\tnewNode[i]=false;\n\t}\n\tfor(int i=0;i<N;i++){\n\t\tnG[i].clear();\n\t\tdeg[i]=0;\n\t}\n\tN=0,V=0;\n}\n\nvoid dfs(int v,int p){\n\tbool flg=isBase[v];\n\tfor(int i=0;i<G[v].size();i++){\n\t\tint u=G[v][i].to;\n\t\tif(u==p) continue;\n\t\tdfs(u,v);\n\t\tflg|=hasBase[u];\n\t}\n\thasBase[v]=flg;\n\tif(isBase[v]) newNode[v]=true;\n\tint cnt=0;\n\tfor(int i=0;i<G[v].size();i++){\n\t\tint u=G[v][i].to;\n\t\tif(u==p) continue;\n\t\tif(hasBase[u]) cnt++;\n\t}\n\tif(cnt>=2){\n\t\tnewNode[v]=true;\n\t}\n}\n\nvoid getNewGraph(int r,int v,int p,int c){\n\tif(newNode[v]){\n\t\tnG[r].push_back(edge(v,c));\n\t\tif(r<v){\n\t\t\tes.push_back(edge2(r,v,c));\n\t//\t\tprintf(\"%d %d %d\\n\",r,v,c);\n\t\t}\n\t\treturn;\n\t}\n\tfor(int i=0;i<G[v].size();i++){\n\t\tint u=G[v][i].to;\n\t\tint cost=G[v][i].cost;\n\t\tif(u==p) continue;\n\t\tgetNewGraph(r,u,v,min(c,cost));\n\t}\n}\n\nint solve(){\n\tif(bases.size()==1||K==0){\n\t\treturn 0;\n\t}\n\tdfs(bases[0],-1);\n\tfor(int i=0;i<N;i++){\n\t\tif(newNode[i]){\n\t\t\tfor(int j=0;j<G[i].size();j++){\n\t\t\t\tgetNewGraph(i,G[i][j].to,i,G[i][j].cost);\n\t\t\t}\n\t\t}\n\t}\n\tfor(int i=0;i<N;i++){\n\t\tdeg[i]=nG[i].size();\n\t}\n\tsort(es.begin(),es.end());\n\tint cnt=0;\n\tint res=0;\n\tfor(int i=0;i<es.size();i++){\n\t\tint u=es[i].u,v=es[i].v;\n\t\tif(deg[u]<=1&&isBase[u]==false) continue;\n\t\tif(deg[v]<=1&&isBase[v]==false) continue;\n\t\tdeg[u]--;\n\t\tdeg[v]--;\n\t\tcnt++;\n\t\tres+=es[i].cost;\n\t\tif(cnt==K) break;\n\t}\n\treturn res;\n}\n\nbool input(){\n\tint T;\n\tscanf(\"%d%d%d\",&N,&T,&K);\n\tif(N==0) return false;\n\tfor(int i=0;i<N-1;i++){\n\t\tint u,v,c;\n\t\tscanf(\"%d%d%d\",&u,&v,&c);\n\t\tu--;v--;\n\t\tG[u].push_back(edge(v,c));\n\t\tG[v].push_back(edge(u,c));\n\t}\n\tfor(int i=0;i<T;i++){\n\t\tint v;\n\t\tscanf(\"%d\",&v);\n\t\tv--;\n\t\tisBase[v]=true;\n\t\tbases.push_back(v);\n\t}\n\treturn true;\n}\n\nint main(){\n\tint datano=0;\n\twhile(true){\n\t\tdatano++;\n\t\tinit();\n\t\tbool flg=input();\n\t\tif(flg==false) break;\n\t\tint ans=solve();\n\t\tprintf(\"Case %d: %d\\n\",datano,ans);\n\t}\n\treturn 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\n#define ll long long\n#define INF 1000000005\n#define MOD 1000000007\n#define EPS 1e-10\n#define rep(i,n) for(int i=0;i<(int)(n);++i)\n#define rrep(i,n) for(int i=(int)(n)-1;i>=0;--i)\n#define srep(i,s,t) for(int i=(int)(s);i<(int)(t);++i)\n#define each(a,b) for(auto& (a): (b))\n#define all(v) (v).begin(),(v).end()\n#define len(v) (int)(v).size()\n#define zip(v) sort(all(v)),v.erase(unique(all(v)),v.end())\n#define cmx(x,y) x=max(x,y)\n#define cmn(x,y) x=min(x,y)\n#define fi first\n#define se second\n#define pb push_back\n#define show(x) cout<<#x<<\" = \"<<(x)<<endl\n#define spair(p) cout<<#p<<\": \"<<p.fi<<\" \"<<p.se<<endl\n#define sar(a,n) cout<<#a<<\":\";rep(kbrni,n)cout<<\" \"<<a[kbrni];cout<<endl\n#define svec(v) cout<<#v<<\":\";rep(kbrni,v.size())cout<<\" \"<<v[kbrni];cout<<endl\n#define svecp(v) cout<<#v<<\":\";each(kbrni,v)cout<<\" {\"<<kbrni.first<<\":\"<<kbrni.second<<\"}\";cout<<endl\n#define sset(s) cout<<#s<<\":\";each(kbrni,s)cout<<\" \"<<kbrni;cout<<endl\n#define smap(m) cout<<#m<<\":\";each(kbrni,m)cout<<\" {\"<<kbrni.first<<\":\"<<kbrni.second<<\"}\";cout<<endl\n\nusing namespace std;\n\ntypedef pair<int,int> P;\ntypedef pair<ll,ll> pll;\ntypedef vector<int> vi;\ntypedef vector<vi> vvi;\ntypedef vector<ll> vl;\ntypedef vector<vl> vvl;\ntypedef vector<double> vd;\ntypedef vector<P> vp;\ntypedef vector<string> vs;\n\nconst int MAX_N = 10005;\n\nstruct edge\n{\n    int to,cost;\n};\n\nvector<edge> G[MAX_N];\nbool ok[MAX_N];\nint sub[MAX_N];\nint n,t,k;\n\nvoid dfs(int u,int p)\n{\n    sub[u] = 1;\n    each(e,G[u]){\n        int v = e.to;\n        if(p != v){\n            dfs(v,u);\n            sub[u] += sub[v];\n        }\n    }\n}\n\nvvi redfs(int u,int p)\n{\n    vvi dp(2,vi(sub[u]+1,INF));\n    int mx = 1;\n    if(ok[u]){\n        dp[1][1] = 0;\n    }else{\n        dp[0][1] = 0;\n    }\n    sort(all(G[u]),[&](edge& a,edge& b){\n        return (b.to==p)?true:sub[a.to]<sub[b.to];\n    });\n    each(e,G[u]){\n        cmn(mx,k+1);\n        int v = e.to, c = e.cost;\n        if(p != v){\n            vvi res = redfs(v,u);\n            vvi dp2(2,vi(mx+len(res[0]),INF));\n            srep(i,1,mx+1){\n                srep(j,1,len(res[0])){\n                    if(ok[u]){\n                        cmn(dp2[1][i+j-1],dp[1][i]+res[0][j]);\n                        cmn(dp2[1][i+j-1],dp[1][i]+res[1][j]);\n                        cmn(dp2[1][i+j],dp[1][i]+res[1][j]+c);\n                    }else{\n                        cmn(dp2[0][i+j-1],dp[0][i]+res[0][j]);\n                        cmn(dp2[0][i+j],dp[0][i]+res[1][j]+c);\n                        cmn(dp2[1][i+j-1],dp[0][i]+res[1][j]);\n                        cmn(dp2[1][i+j-1],dp[1][i]+res[0][j]);\n                        cmn(dp2[1][i+j-1],dp[1][i]+res[1][j]);\n                        cmn(dp2[1][i+j],dp[1][i]+res[1][j]+c);\n                    }\n                }\n            }\n            mx += len(res[0]) - 1;\n            rep(i,2){\n                rep(j,mx+1){\n                    dp[i][j] = dp2[i][j];\n                }\n            }\n        }\n    }\n    return dp;\n}\n\nint main()\n{\n    cin.tie(0);\n    ios::sync_with_stdio(false);\n    int id = 0;\n    while(1){\n        cin >> n >> t >> k;\n        if(n == 0){\n            break;\n        }\n        rep(i,n){\n            G[i].clear(),ok[i] = false;\n        }\n        rep(i,n-1){\n            int a,b,c;\n            cin >> a >> b >> c;\n            G[a-1].pb((edge){b-1,c}),G[b-1].pb((edge){a-1,c});\n        }\n        rep(i,t){\n            int a;\n            cin >> a;\n            --a;\n            ok[a] = true;\n        }\n        if(k == 0){\n            cout << \"Case \" << ++id << \": 0\" << endl;\n            continue;\n        }\n        dfs(0,-1);\n        vvi ans = redfs(0,-1);\n        cout << \"Case \" << ++id << \": \" << ans[1][k+1] << endl;\n    }\n    return 0;\n}\n\n"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\nusing namespace std;\n\ntypedef long long ll;\ntypedef unsigned long long ull;\ntypedef pair<ll, ll> P;\n\n#define fi first\n#define se second\n#define repl(i,a,b) for(ll i=(ll)(a);i<(ll)(b);i++)\n#define rep(i,n) repl(i,0,n)\n#define all(x) (x).begin(),(x).end()\n#define dbg(x) cout<<#x\"=\"<<x<<endl\n#define mmax(x,y) (x>y?x:y)\n#define mmin(x,y) (x<y?x:y)\n#define maxch(x,y) x=mmax(x,y)\n#define minch(x,y) x=mmin(x,y)\n#define uni(x) x.erase(unique(all(x)),x.end())\n#define exist(x,y) (find(all(x),y)!=x.end())\n#define bcnt __builtin_popcount\n\n#define INF 1e16\n#define mod 1000000007\n\nstruct UnionFind{\n  vector<int> v;\n  vector<bool> f; \n  UnionFind(int n) : v(n, -1),f(n,false) {}\n  void init(){ for(int i = 0;i < v.size();i++)v[i]=-1; }\n  int find(int x) { return v[x] < 0 ? x : find(v[x]); }\n  bool unite(int x, int y) {\n    x = find(x); y = find(y);\n    if (x == y) return false;\n    if (-v[x] < -v[y]) swap(x, y);\n    v[x] += v[y]; v[y] = x;\n    f[x]=(f[x]|f[y]);\n    return true;\n  }\n  bool root(int x) { return v[x] < 0; }\n  bool same(int x, int y) { return find(x) == find(y); }\n  int size(int x) { return -v[find(x)]; }\n  bool is_base(int x){ return f[find(x)]; }\n};\n\nstruct edge{\n  int u,v,cost;\n};\nbool operator<(const edge& a,const edge& b){\n  return a.cost > b.cost;\n}\n\nint main(){\n  int hoge=1;\n  while(1){\n    int n,t,k;\n    cin>>n>>t>>k;\n    if(n==0)break;\n    UnionFind uf(n);\n    vector<edge> es; \n    int res=0;\n    rep(i,n-1){\n      int a,b,c;\n      cin>>a>>b>>c;\n      a--;b--;\n      res+=c;\n      es.push_back((edge){a,b,c});\n    }\n    sort(all(es));\n    rep(i,t){\n      int a;\n      cin>>a;\n      a--;\n      uf.f[a]=true;\n    }\n    int lim=t-k-1;\n    for(int i=0,cnt=0;i<es.size()&&cnt<n-1-k;i++){\n      if(uf.is_base(es[i].u)&&uf.is_base(es[i].v)){\n        if(lim==0)continue;\n        lim--;\n      }\n      uf.unite(es[i].u,es[i].v);\n      res-=es[i].cost;\n      cnt++;\n    }\n    cout<<\"Case \"<<hoge<<\": \"<<res<<endl;\n    hoge++;\n  }\n  return 0;\n}\n\n"
  },
  {
    "language": "C++",
    "code": "#include<bits/stdc++.h>\nusing namespace std;\ntypedef pair<int,int> pii;\n\nint costs[10001];\n\nint main(){\n  cin.tie(0); ios::sync_with_stdio(0);\n\n  int n,t,k,case_num = 0;\n  while(cin >> n >> t >> k, n){\n    case_num++;\n\n    memset(costs,0,sizeof(costs));\n    vector< vector<pii> > tree(n);\n\n    for(int i=0;i<n-1;i++){\n      int a,b,c;\n      cin >> a >> b >> c;\n      a--; b--;\n      tree[a].push_back(pii(c,b));\n      tree[b].push_back(pii(c,a));\n      costs[c]++;\n    }\n\n    vector<int> base(t), use(n,0);\n    for(int i=0;i<t;i++){\n      cin >> base[i];\n      base[i]--;\n      use[base[i]] = 1;\n    }\n\n    priority_queue<pii> q;\n    for(int v : base){\n      for(pii u : tree[v]){\n\tif(!use[u.second])q.push(u);\n      }\n    }\n\n    while(q.size()){\n      pii p = q.top(); q.pop();\n      if(use[p.second])continue;\n      use[p.second] = 1;\n      costs[p.first]--;\n\n      for(pii u : tree[p.second]){\n\tif(!use[u.second])q.push(u);\n      }\n    }\n\n    int p = 0;\n    long long res = 0;\n    while(k){\n      while(k && costs[p]){\n\tcosts[p]--; k--;\n\tres += p;\n      }\n      p++;\n    }\n    cout << \"Case \" << case_num << \": \" << res << endl;\n  }\n}"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\n#define INF 1000000007\nusing namespace std;\ntypedef long long ll;\ntypedef pair<int,int> P;\n\nstruct diameter{\n\tstatic const int MAX=10000;\n\tvector<int> G[MAX];\n\tint n;\n\tint d[MAX];\n\tbool vis[MAX];\n\tint d2[2][MAX];\n\n\tvoid bfs(int s){\n\t\tfill(d,d+n,INF);\n\t\tqueue<int> que;\n\t\tque.push(s);\n\t\td[s]=0;\n\t\tint v;\n\t\twhile(que.size()){\n\t\t\tv=que.front();\n\t\t\tque.pop();\n\t\t\tfor(int i=0;i<G[v].size();i++){\n\t\t\t\tint e=G[v][i];\n\t\t\t\tif(d[e]==INF){\n\t\t\t\t\td[e]=d[v]+1;\n\t\t\t\t\tque.push(e);\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t}\n\tP diameter_points(int s=0){\n\t\tbfs(s);\n\t\tint maxv=0;\n\t\tint tgt=0;\n\t\tfor(int i=0;i<n;i++){\n\t\t\tif(d[i]==INF)continue;\n\t\t\tif(maxv<d[i]){\n\t\t\t\tmaxv=d[i];\n\t\t\t\ttgt=i;\n\t\t\t}\n\t\t}\n\t\tbfs(tgt);\n\t\tmaxv=0;\n\t\tint v=0;\n\t\tfor(int i=0;i<n;i++){\n\t\t\tif(d[i]==INF)continue;\n\t\t\tif(maxv<d[i]){\n\t\t\t\tmaxv=d[i];\n\t\t\t\tv=i;\n\t\t\t}\n\t\t}\n\t\treturn P(tgt,v);\n\t}\n\tvector<int> middle_points(){\n\t\tP p=diameter_points();\n\t\tbfs(p.first);\n\t\tfor(int i=0;i<n;i++){\n\t\t\td2[0][i]=d[i];\n\t\t}\n\t\tbfs(p.second);\n\t\tfor(int i=0;i<n;i++){\n\t\t\td2[1][i]=d[i];\n\t\t}\n\t\tvector<int> cid;\n\t\tif(d2[0][p.second]%2==0){\n\t\t\tfor(int i=0;i<n;i++){\n\t\t\t\tif(d2[0][p.second]==d2[0][i]*2 && d2[1][p.first]==d2[1][i]*2){\n\t\t\t\t\tcid.push_back(i);\n\t\t\t\t}\n\t\t\t}\n\t\t}else{\n\t\t\tfor(int i=0;i<n;i++){\n\t\t\t\tif(d2[0][p.second]==(d2[0][i]+d2[1][i]) && abs(d2[0][i]-d2[1][i])==1){\n\t\t\t\t\tcid.push_back(i);\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t\treturn cid;\n\t}\n};\n\nstruct edge{\n\tint t,c;\n\tedge(){}\n\tedge(int tt,int cc){\n\t\tt=tt;\n\t\tc=cc;\n\t}\n};\n\ndiameter di;\nvector<edge> G[10001];\nint n,t,k;\nbool flag[10001];\nint siz[10001];\nvector<int> dp[10001][2];\nint tmp[2][10001];\n\nint dfs(int v,int p){\n\tint ans=1;\n\tfor(int i=0;i<G[v].size();i++){\n\t\tint nv=G[v][i].t;\n\t\tif(nv!=p){\n\t\t\tans+=dfs(nv,v);\n\t\t}\n\t}\n\treturn (siz[v]=ans);\n}\n\nvoid func(int v,int p){\n\tdp[v][0].clear();\n\tdp[v][1].clear();\n\tdp[v][0].resize(siz[v]+1,INF);\n\tdp[v][1].resize(siz[v]+1,INF);\n\tif(flag[v])dp[v][1][1]=0;\n\telse dp[v][0][1]=0;\n\tint ns=1;\n\tfor(int i=0;i<G[v].size();i++){\n\t\tint nv=G[v][i].t;\n\t\tint nc=G[v][i].c;\n\t\tif(nv!=p){\n\t\t\tfunc(nv,v);\n\t\t\tfor(int j=0;j<=ns+siz[nv];j++){\n\t\t\t\ttmp[0][j]=INF;\n\t\t\t\ttmp[1][j]=INF;\n\t\t\t}\n\t\t\tfor(int i=0;i<=ns;i++){\n\t\t\t\tfor(int j=0;j<=siz[nv];j++){\n\t\t\t\t\ttmp[0][i+j]=min(tmp[0][i+j],dp[v][0][i]+dp[nv][1][j]+nc);\n\t\t\t\t\ttmp[1][i+j]=min(tmp[1][i+j],dp[v][1][i]+dp[nv][1][j]+nc);\n\t\t\t\t\ttmp[0][i+j-1]=min(tmp[0][i+j-1],dp[v][0][i]+dp[nv][0][j]);\n\t\t\t\t\ttmp[1][i+j-1]=min(tmp[1][i+j-1],dp[v][1][i]+dp[nv][0][j]);\n\t\t\t\t\ttmp[1][i+j-1]=min(tmp[1][i+j-1],dp[v][0][i]+dp[nv][1][j]);\n\t\t\t\t\ttmp[1][i+j-1]=min(tmp[1][i+j-1],dp[v][1][i]+dp[nv][1][j]);\n\t\t\t\t}\n\t\t\t}\n\t\t\tfor(int j=0;j<=ns+siz[nv];j++){\n\t\t\t\tdp[v][0][j]=tmp[0][j];\n\t\t\t\tdp[v][1][j]=tmp[1][j];\n\t\t\t}\n\t\t\tns+=siz[nv];\n\t\t\tdp[nv][0].clear();\n\t\t\tdp[nv][1].clear();\n\t\t}\n\t}\n}\n\nvoid solve(){\n\tint root=di.middle_points()[0];\n\tdfs(root,-1);\n\tfunc(root,-1);\n\tint ans=INF;\n\tfor(int i=k+1;i<=n;i++){\n\t\tans=min(ans,dp[root][1][i]);\n\t}\n\tprintf(\"%d\\n\",ans);\n}\n\nint main(void){\n\tint casenum=1;\n\twhile(1){\n\t\tscanf(\"%d%d%d\",&n,&t,&k);\n\t\tif(n==0)break;\n\t\tdi.n=n;\n\t\tmemset(flag,false,sizeof(flag));\n\t\tmemset(siz,false,sizeof(siz));\n\t\tfor(int i=0;i<n;i++){\n\t\t\tG[i].clear();\n\t\t\tdi.G[i].clear();\n\t\t}\n\t\tfor(int i=0;i<n-1;i++){\n\t\t\tint a,b,c;\n\t\t\tscanf(\"%d%d%d\",&a,&b,&c);\n\t\t\ta--;\n\t\t\tb--;\n\t\t\tG[a].push_back(edge(b,c));\n\t\t\tG[b].push_back(edge(a,c));\n\t\t\tdi.G[a].push_back(b);\n\t\t\tdi.G[b].push_back(a);\n\t\t}\n\t\tfor(int i=0;i<t;i++){\n\t\t\tint a;\n\t\t\tscanf(\"%d\",&a);\n\t\t\ta--;\n\t\t\tflag[a]=true;\n\t\t}\n\t\tprintf(\"Case %d: \",casenum++);\n\t\tsolve();\n\t}\n\treturn 0;\n}\n"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\n#define ll long long\n#define INF 1000000005\n#define MOD 1000000007\n#define EPS 1e-10\n#define rep(i,n) for(int i=0;i<(int)(n);++i)\n#define rrep(i,n) for(int i=(int)(n)-1;i>=0;--i)\n#define srep(i,s,t) for(int i=(int)(s);i<(int)(t);++i)\n#define each(a,b) for(auto& (a): (b))\n#define all(v) (v).begin(),(v).end()\n#define len(v) (int)(v).size()\n#define zip(v) sort(all(v)),v.erase(unique(all(v)),v.end())\n#define cmx(x,y) x=max(x,y)\n#define cmn(x,y) x=min(x,y)\n#define fi first\n#define se second\n#define pb push_back\n#define show(x) cout<<#x<<\" = \"<<(x)<<endl\n#define spair(p) cout<<#p<<\": \"<<p.fi<<\" \"<<p.se<<endl\n#define sar(a,n) cout<<#a<<\":\";rep(kbrni,n)cout<<\" \"<<a[kbrni];cout<<endl\n#define svec(v) cout<<#v<<\":\";rep(kbrni,v.size())cout<<\" \"<<v[kbrni];cout<<endl\n#define svecp(v) cout<<#v<<\":\";each(kbrni,v)cout<<\" {\"<<kbrni.first<<\":\"<<kbrni.second<<\"}\";cout<<endl\n#define sset(s) cout<<#s<<\":\";each(kbrni,s)cout<<\" \"<<kbrni;cout<<endl\n#define smap(m) cout<<#m<<\":\";each(kbrni,m)cout<<\" {\"<<kbrni.first<<\":\"<<kbrni.second<<\"}\";cout<<endl\n\nusing namespace std;\n\ntypedef pair<int,int> P;\ntypedef pair<ll,ll> pll;\ntypedef vector<int> vi;\ntypedef vector<vi> vvi;\ntypedef vector<ll> vl;\ntypedef vector<vl> vvl;\ntypedef vector<double> vd;\ntypedef vector<P> vp;\ntypedef vector<string> vs;\n\nconst int MAX_N = 10005;\n\nstruct edge\n{\n    int to,cost;\n};\n\nvector<edge> G[MAX_N];\nbool ok[MAX_N];\nint sub[MAX_N];\nint n,t,k;\n\nvoid dfs(int u,int p)\n{\n    sub[u] = 1;\n    each(e,G[u]){\n        int v = e.to;\n        if(p != v){\n            dfs(v,u);\n            sub[u] += sub[v];\n        }\n    }\n}\n\nvvi redfs(int u,int p)\n{\n    vvi dp(2,vi(sub[u]+1,INF));\n    int mx = 1;\n    if(ok[u]){\n        dp[1][1] = 0;\n    }else{\n        dp[0][1] = 0;\n    }\n    each(e,G[u]){\n        cmn(mx,k+1);\n        int v = e.to, c = e.cost;\n        if(p != v){\n            vvi res = redfs(v,u);\n            vvi dp2(2,vi(mx+len(res[0]),INF));\n            srep(i,1,mx+1){\n                srep(j,1,len(res[0])){\n                    if(ok[u]){\n                        cmn(dp2[1][i+j-1],dp[1][i]+res[0][j]);\n                        cmn(dp2[1][i+j-1],dp[1][i]+res[1][j]);\n                        cmn(dp2[1][i+j],dp[1][i]+res[1][j]+c);\n                    }else{\n                        cmn(dp2[0][i+j-1],dp[0][i]+res[0][j]);\n                        cmn(dp2[0][i+j],dp[0][i]+res[1][j]+c);\n                        cmn(dp2[1][i+j-1],dp[0][i]+res[1][j]);\n                        cmn(dp2[1][i+j-1],dp[1][i]+res[0][j]);\n                        cmn(dp2[1][i+j-1],dp[1][i]+res[1][j]);\n                        cmn(dp2[1][i+j],dp[1][i]+res[1][j]+c);\n                    }\n                }\n            }\n            mx += len(res[0]) - 1;\n            rep(i,2){\n                rep(j,mx+1){\n                    dp[i][j] = dp2[i][j];\n                }\n            }\n            rep(i,len(dp)){\n                dp2[i].clear();\n            }\n            rep(i,len(res)){\n                res[i].clear();\n            }\n        }\n    }\n    return dp;\n}\n\nint main()\n{\n    cin.tie(0);\n    ios::sync_with_stdio(false);\n    int id = 0;\n    while(1){\n        cin >> n >> t >> k;\n        if(n == 0){\n            break;\n        }\n        rep(i,n){\n            G[i].clear(),ok[i] = false;\n        }\n        rep(i,n-1){\n            int a,b,c;\n            cin >> a >> b >> c;\n            G[a-1].pb((edge){b-1,c}),G[b-1].pb((edge){a-1,c});\n        }\n        rep(i,t){\n            int a;\n            cin >> a;\n            --a;\n            ok[a] = true;\n        }\n        if(k == 0){\n            cout << \"Case \" << ++id << \": 0\" << endl;\n            continue;\n        }\n        dfs(0,-1);\n        vvi ans = redfs(0,-1);\n        cout << \"Case \" << ++id << \": \" << ans[1][k+1] << endl;\n    }\n    return 0;\n}\n\n"
  },
  {
    "language": "C++",
    "code": "#include<bits/stdc++.h>\n\nusing namespace std;\n\nstruct edge\n{\n  int to, cost;\n};\n\ntypedef pair< int, int > Pi;\n\nint main()\n{\n  int N, T, K;\n  int A[10000], B[10000], C[10000];\n  int testcase = 1;\n\n  while(scanf(\"%d %d %d\", &N, &T, &K), N) {\n\n    vector< edge > g[10000];\n    int deg[10000] = {};\n    bool M[10000] = {};\n    priority_queue< Pi, vector< Pi >, greater<> > que;\n\n    for(int i = 1; i < N; i++) {\n      scanf(\"%d %d %d\", &A[i], &B[i], &C[i]);\n      --A[i], --B[i];\n      g[A[i]].emplace_back((edge) {B[i], C[i]});\n      g[B[i]].emplace_back((edge) {A[i], C[i]});\n      ++deg[A[i]];\n      ++deg[B[i]];\n      que.emplace(C[i], i);\n    }\n\n    for(int i = 0; i < T; i++) {\n      int x;\n      scanf(\"%d\", &x);\n      --x;\n      M[x] = true;\n    }\n\n    queue< int > beet;\n    bool live[10000];\n    for(int i = 0; i < N; i++) {\n      if(deg[i] == 1) {\n        deg[i]--;\n        beet.emplace(i);\n      }\n      live[i] = true;\n    }\n\n    auto update = [&]()\n    {\n      while(!beet.empty()) {\n        int p = beet.front();\n        beet.pop();\n        if(M[p]) continue;\n        live[p] = false;\n        for(auto &e : g[p]) {\n          if(live[e.to]) {\n            deg[e.to]--;\n            if(deg[e.to] <= 1) beet.emplace(e.to);\n          }\n        }\n      }\n    };\n\n    int ret = 0;\n    for(int i = 0; i < K; i++) {\n      update();\n      while(!que.empty()) {\n        int cost, idx;\n        tie(cost, idx) = que.top();\n        que.pop();\n        if(!live[A[idx]] || !live[B[idx]]) continue;\n        ret += cost;\n        --deg[A[idx]];\n        --deg[B[idx]];\n        if(deg[A[idx]] <= 1) beet.emplace(A[idx]);\n        if(deg[B[idx]] <= 1) beet.emplace(B[idx]);\n        break;\n      }\n    }\n\n    printf(\"Case %d: %d\\n\", testcase++, ret);\n  }\n}"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\n\nusing namespace std;\n\nconst int NMAX = 10010;\n\nint N, T, K;\nbool base[NMAX], locked[NMAX];\n\nstruct Edge {\n\tint id, x, y, cost;\n\tbool operator<(const Edge &rhs) const {\n\t\treturn cost < rhs.cost;\n\t}\n} E[NMAX];\nvector<pair<int, int>> Tree[NMAX];\n\nbool visited[NMAX];\nint nodes[NMAX];\nbool baseBfs(int node) {\n\tif (base[node])\n\t\treturn 1;\n\tfor (int i = 1; i <= nodes[0]; ++i)\n\t\tvisited[nodes[i]] = 0;\n\tnodes[0] = 0;\n\tqueue<int> Q;\n\tQ.push(node);\n\tvisited[node] = 1;\n\tnodes[++nodes[0]] = node;\n\twhile (!Q.empty()) {\n\t\tint now = Q.front();\n\t\tQ.pop();\n\t\tfor (auto it: Tree[now]) {\n\t\t\tif (visited[it.first] || locked[it.second])\n\t\t\t\tcontinue;\n\t\t\tif (base[it.first])\n\t\t\t\treturn 1;\n\t\t\tQ.push(it.first);\n\t\t\tvisited[it.first] = 1;\n\t\t\tnodes[++nodes[0]] = it.first;\n\t\t}\n\t}\n\treturn 0;\n}\n\nint main() {\n//\tassert(freopen(\"debug.in\", \"r\", stdin));\n//\tassert(freopen(\"debug.out\", \"w\", stdout));\n\n\tint i;\n\n\tint caseNumber = 1;\n\tcin >> N >> T >> K;\n\twhile (N != 0 || T != 0 || K != 0) {\n\t\tmemset(base, 0, sizeof base);\n\t\tmemset(locked, 0, sizeof locked);\n\n\t\tfor (i = 0; i < N - 1; ++i) {\n\t\t\tassert(E[i].x >= 0 && E[i].x <= N && E[i].y >= 0 && E[i].y <= N);\n\t\t\tcin >> E[i].x >> E[i].y >> E[i].cost;\n\t\t\tE[i].id = i;\n\t\t\tTree[E[i].x].push_back({E[i].y, i});\n\t\t\tTree[E[i].y].push_back({E[i].x, i});\n\t\t}\n\t\tfor (i = 1; i <= N; ++i) {\n\t\t\tint value;\n\t\t\tcin >> value;\n\t\t\tbase[value] = 1;\n\t\t}\n\n\t\tsort(E, E + N - 1);\n\n\t\tint answer = 0;\n\t\tfor (i = 0; i < N - 1 && K; ++i) {\n\t\t\tlocked[i] = 1;\n\t\t\tbool currBfs = baseBfs(E[i].x);\n\t\t\tif (!currBfs) {\n\t\t\t\tlocked[i] = 0;\n\t\t\t\tcontinue;\n\t\t\t}\n\t\t\tcurrBfs = baseBfs(E[i].y);\n\t\t\tif (!currBfs) {\n\t\t\t\tlocked[i] = 0;\n\t\t\t\tcontinue;\n\t\t\t}\n\t\t\tanswer += E[i].cost;\n\t\t\t--K;\n\t\t}\n\n\t\tcout << \"Case \" << caseNumber << \": \" << answer << '\\n';\n\n\t\t++caseNumber;\n\t\tfor (i = 0; i <= N; ++i)\n\t\t\tTree[i].clear();\n\n\t\tcin >> N >> T >> K;\n\t}\n\n\treturn 0;\n}\n\n"
  },
  {
    "language": "C++",
    "code": "#include<bits/stdc++.h>\nusing namespace std;\n\nstruct unionfind{\n  vector<int> parent, size;\n  void init(int n){\n    parent.resize(n);\n    size.resize(n);\n    for(int i=0;i<n;i++){\n      parent[i]=i;\n      size[i]=1;\n    }\n  }\n  int find(int x){\n    if(parent[x]==x)return x;\n    else parent[x]=find(parent[x]);\n  }\n  bool same(int x,int y){\n    return (find(x)==find(y));\n  }\n  bool getSize(int x){\n    return size[ find(x) ];\n  }\n  void unite(int x,int y){\n    x=find(x);\n    y=find(y);\n    if(x==y)return;\n    if(size[x]>size[y])swap(x,y);\n    parent[x]=y;\n    size[y]+=size[x];\n  }\n};\n  \nstruct edge{\n  int from,to,cost;\n  bool operator < (const edge &e) const {\n    return cost < e.cost;\n  }\n};\n\nint n,t,k;\n\nint main(){\n  unionfind uf;\n  \n  for(int tc=1;;tc++){\n    cin>>n>>t>>k;\n    if(n==0&&t==0&&k==0)break;\n    vector<edge> E;\n    for(int i=0;i<n-1;i++){\n      int a,b,c;\n      cin>>a>>b>>c;\n      a--,b--;\n      E.push_back( (edge){a,b,-c} );\n    }\n    for(int i=0;i<t;i++){\n      int a;\n      cin>>a;\n      a--;\n      E.push_back( (edge){a,n,-20000} );\n    }\n    sort(E.begin(),E.end());\n    uf.init(n+1);\n\n    vector<edge> tmp;\n    for(int i=0;i<(int)E.size();i++){\n      edge e=E[i];\n      if( uf.same(e.from,e.to) ){\n        tmp.push_back(e);\n      }else{\n        uf.unite(e.from,e.to);\n      }\n    }\n    sort(tmp.begin(),tmp.end());\n    int ans=0;\n    for(int i=t-1-k;i<(int)tmp.size();i++){\n      ans-=tmp[i].cost;\n    }\n    cout<<\"Case \"<<tc<<\": \"<<ans<<endl;\n    \n  }\n  return 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include <iostream>\n#include <vector>\n#include <map>\n#include <algorithm>\nusing namespace std;\n\nconst int MAX_V = 100000;\ntypedef pair<int,int> P;\nstruct edge{ int to,cost; };\n\n// グラフ (隣接リスト)\nvector<edge> G[MAX_V];\n// e = (u,v) , is_cost[e] := コスト\nmap<P,int> is_cost;\n// base[u] == true のとき ノード u は ベース\nbool base[MAX_V];\n// (cost,(u,v))の組\nvector< pair<int ,P> > a;\n// used[u] == true のとき ノード u は探索済み\nbool used[MAX_V];\n\nint n, t, k;\n\n\n// 初期化\nvoid init(){\n\ta.clear();\n\tis_cost.clear();\n\tfor(int i=0 ; i < MAX_V ; i++ ){\n\t\tbase[i] = false;\n\t\tG[i].clear();\n\t}\n}\n\n// グラフに重みcostのエッジ(u,v)を追加\nvoid add_edge(int u, int v, int cost){\n\tedge e;\n\te.to = v;\n\te.cost = cost;\n\tG[u].push_back( e );\n\te.to = u;\n\tG[v].push_back( e );\n}\n\n// グラフのエッジ(u,v)を切断\nvoid cut_edge(int u, int v){\n\tfor(vector<edge>::iterator it = G[u].begin() ; it != G[u].end() ; ++it ){\n\t\tif( (*it).to == v ){\n\t\t\tG[u].erase( it );\n\t\t\treturn ;\n\t\t}\n\t}\n}\n\n\n// ノード u の木にベースがあるかどうか\nvoid is_base(int u, bool& flag){\n\t\n\t// ノード u がベースのとき\n\tif( base[u] || flag ){\n\t\tflag = true;\n\t\treturn;\n\t}\n\t// ノード u が探索済みのとき\n\tif( used[u] ) return;\n\tused[u] = true;\n\t\n\tfor(int i=0 ; i < G[u].size() ; i++ ){\n\t\tedge e = G[u][i];\n\t\tis_base( e.to , flag );\n\t}\n}\n\nint solve(){\n\t\n\t// 連結成分の数\n\tint p=1;\n\t// コストの総和\n\tint sum = 0;\n\t\n\tsort( a.begin() , a.end() );\n\tfor(int i=0 ; i < a.size() ; i++ ){\n\t\tint cost = a[i].first;\n\t\tint u = a[i].second.first;\n\t\tint v = a[i].second.second;\n\t\tif( u > v ) swap(u,v);\n\t\t\n\t\t//cut_edge( u , v );\n\t\t\n\t\tbool flag1 = false, flag2 = false;\n\t\tfor(int j=0 ; j < MAX_V ; j++ ) used[j] = false;\n\t\t//is_base( u , flag1 );\n\t\tfor(int j=0 ; j < MAX_V ; j++ ) used[j] = false;\n\t\t//is_base( v , flag2 );\n\t\t//flag1 = flag2 = true;\n\t\t\n\t\t// u,vの木の両方にベースを含むとき切断する\n\t\tif( flag1 && flag2 ){\n\t\t\t//sum += is_cost[P(u,v)];\n\t\t\tp++;\n\t\t}else{\n\t\t\t//add_edge( u , v , is_cost[P(u,v)] );\n\t\t}\n\t\t\n\t\t// 連結成分が K+1 個になったらループを抜ける\n\t\tif( p == k+1 ) break;\n\t}\n\treturn sum;\n}\n\nint main(){\n\tfor(int t_ = 1 ; cin >> n >> t >> k , (n || t || k) ; t_++ ){\n\t\t// 初期化\n\t\tinit();\n\t\t\n\t\tfor(int i = 0 ; i < n-1 ; i++ ){\n\t\t\tint u, v, cost;\n\t\t\tcin >> u >> v >> cost;\n\t\t\tu--; v--;\n\t\t\tif( u > v ) swap(u,v);\n\t\t\t\n\t\t\tis_cost[P(u,v)] = cost;\n\t\t\tadd_edge( u , v , cost );\n\t\t\tpair<int,P> p( cost , P(u,v) );\n\t\t\ta.push_back( p );\n\t\t}\n\t\tfor(int i = 0 ; i < t ; i++ ){\n\t\t\tint b;\n\t\t\tcin >> b;\n\t\t\tb--;\n\t\t\tbase[b] = true;\n\t\t}\n\t\t\n\t\tint ans = 0;//solve();\n\t\tcout << \"Case \" << t_ << \": \" << ans << endl;\n\t}\n}"
  },
  {
    "language": "C++",
    "code": "\n#include <iostream>\n#include <vector>\n#include <algorithm>\n#include <queue>\n#include <cstring>\n\nusing namespace std;\n\ntypedef pair<int,int> pii;\n\nconst int MAX_V=10001;\nconst int INF=1000000000;\n\n\nclass UnionFindTree{\npublic:\n  // indexの数の親ノード(ある集合の親を見つけたいときはここを直接参照せず、findを使う)\n  vector<int> par;\n  // indexを根とする木のランク\n  vector<int> rank;\n  // 木の最大値\n  int treeSize;\n  vector<bool> isBase;\n  UnionFindTree(int initTreeSize = 1000){\n    // 引数で与えられた値を最大格納数とするUnionFindTreeの作成\n    treeSize = initTreeSize;\n    init();\n  }\n  void init(){\n    for(int i = 0; i < treeSize; i++){\n      par.push_back(i);\n      rank.push_back(0);\n      isBase.push_back(false);\n    }\n  }\n  // 与えられた数が格納されている木のルートを探索\n  int find(int x){  \n    if(par[x]==x)return x;\n    else return par[x] = find(par[x]);\n  }\n  // 和集合をとる。ただしここでは各集合の親の付け替えは起こらない\n  void unite(int x,int y){\n    x = find(x);\n    y = find(y);\n    if(x == y)\n      return;\n    if(rank[x] < rank[y]){\n      par[x] = y;\n      if(isBase[find(x)]||isBase[find(y)])\n\tisBase[find(x)]=true;\n    }\n    else{\n      par[y] = x;\n      if(isBase[find(x)]||isBase[find(y)])\n\tisBase[find(x)]=true;\n      if(rank[y] == rank[x])rank[x]++;\n    }\n  }\n  bool same(int x,int y){\n    return find(x) == find(y);\n  }\n};\n\nstruct edge{\n  int to;\n  int cost;\n  int idx;\n};\n\nvector<edge> G[MAX_V];\nvector<int> bases;\nbool used[MAX_V];\nint n,t,k;\nvoid prim(int V){\n  priority_queue<int> cand;\n  UnionFindTree uft(V+1);\n  for(int i=0;i<MAX_V;i++)used[i]=false;\n  for(int i=0;i<bases.size();i++)uft.isBase[bases[i]]=true;\n  priority_queue<pair<pii,pii> > pq;\n  for(int i=0;i<bases.size();i++){\n    // 次の場所をコストとともに登録\n    for(int j=0;j<G[bases[i]].size();j++){\n      edge &e=G[bases[i]][j];\n      if(used[e.idx])continue;\n      used[e.idx]=true;\n      pq.push(make_pair(pii(e.cost,e.idx),pii(e.to,bases[i])));\n    }\n  }\n  while(pq.size()){\n    pair<pii,pii> p=pq.top();pq.pop();\n    int cost=p.first.first;\n    int idx=p.first.second;\n    int node=p.second.first;\n    int from=p.second.second;\n    // 今回のエッジを採用\n    if(uft.isBase[uft.find(from)]\n       &&uft.isBase[uft.find(node)])cand.push(-cost);\n    uft.unite(from,node);\n    // 今回登録したノードからいける場所を登録\n    for(int i=0;i<G[node].size();i++){\n      edge &e=G[node][i];\n      if(used[e.idx])continue;\n      used[e.idx]=true;\n      pq.push(make_pair(pii(e.cost,e.idx),pii(e.to,node)));\n    }\n  }\n  int res=0;\n  for(int i=0;i<k;i++){\n    res+=-cand.top();cand.pop();\n  }\n  cout<<res<<endl;\n  cout<<flush;\n}\n\nint main(){\n  int cnt=1;\n  while(cin>>n>>t>>k&&(n|t|k)){\n    for(int i=0;i<MAX_V;i++)G[i].clear();\n    for(int i=0;i<n-1;i++){\n      edge e;\n      int a,b,c;\n      cin>>a>>b>>c;\n      e.to=a;\n      e.cost=c;\n      e.idx=i;\n      G[b].push_back(e);\n      e.to=b;\n      G[a].push_back(e);\n    }\n    bases.clear();\n    for(int i=0;i<t;i++){\n      int a;\n      cin>>a;\n      bases.push_back(a);\n    }\n    cout<<\"Case \"<<cnt<<\": \";\n    prim(n);\n    cnt++;\n  }\n\n  return 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include <iostream>\n#include <vector>\n#include <map>\n#include <algorithm>\nusing namespace std;\n\nconst int MAX_V = 100000;\ntypedef pair<int,int> P;\nstruct edge{ int to,cost; };\n\n// グラフ (隣接リスト)\nvector<edge> G[MAX_V];\n// e = (u,v) , is_cost[e] := コスト\nmap<P,int> is_cost;\n// base[u] == true のとき ノード u は ベース\nbool base[MAX_V];\n// (cost,(u,v))の組\nvector< pair<int ,P> > a;\n// used[u] == true のとき ノード u は探索済み\nbool used[MAX_V];\n\nint n, t, k;\n\n\n// 初期化\nvoid init(){\n\ta.clear();\n\tis_cost.clear();\n\tfor(int i=0 ; i < MAX_V ; i++ ){\n\t\tbase[i] = false;\n\t\tG[i].clear();\n\t}\n}\n\n// グラフに重みcostのエッジ(u,v)を追加\nvoid add_edge(int u, int v, int cost){\n\tedge e;\n\te.to = v;\n\te.cost = cost;\n\tG[u].push_back( e );\n\te.to = u;\n\tG[v].push_back( e );\n}\n\n// グラフのエッジ(u,v)を切断\nvoid cut_edge(int u, int v){\n\tfor(vector<edge>::iterator it = G[u].begin() ; it != G[u].end() ; ++it ){\n\t\tif( (*it).to == v ){\n\t\t\tG[u].erase( it );\n\t\t\treturn ;\n\t\t}\n\t}\n}\n\n\n// ノード u の木にベースがあるかどうか\nvoid is_base(int u, bool& flag){\n\t\n\t// ノード u がベースのとき\n\tif( base[u] || flag ){\n\t\tflag = true;\n\t\treturn;\n\t}\n\t// ノード u が探索済みのとき\n\tif( used[u] ) return;\n\tused[u] = true;\n\t\n\tfor(int i=0 ; i < G[u].size() ; i++ ){\n\t\tedge e = G[u][i];\n\t\tis_base( e.to , flag );\n\t}\n}\n\nint solve(){\n\t\n\t// 連結成分の数\n\tint p=1;\n\t// コストの総和\n\tint sum = 0;\n\t\n\tsort( a.begin() , a.end() );\n\tfor(int i=0 ; i < a.size() ; i++ ){\n\t\tint cost = a[i].first;\n\t\tint u = a[i].second.first;\n\t\tint v = a[i].second.second;\n\t\tif( u > v ) swap(u,v);\n\t\t\n\t\t//cut_edge( u , v );\n\t\t\n\t\t/*bool flag1 = false, flag2 = false;\n\t\tfor(int j=0 ; j < MAX_V ; j++ ) used[j] = false;\n\t\t//is_base( u , flag1 );\n\t\tfor(int j=0 ; j < MAX_V ; j++ ) used[j] = false;\n\t\t//is_base( v , flag2 );\n\t\t//flag1 = flag2 = true;\n\t\t\n\t\t// u,vの木の両方にベースを含むとき切断する\n\t\tif( flag1 && flag2 ){\n\t\t\t//sum += is_cost[P(u,v)];\n\t\t\tp++;\n\t\t}else{\n\t\t\t//add_edge( u , v , is_cost[P(u,v)] );\n\t\t}\n\t\t\n\t\t// 連結成分が K+1 個になったらループを抜ける\n\t\tif( p == k+1 ) break;*/\n\t}\n\treturn sum;\n}\n\nint main(){\n\tfor(int t_ = 1 ; cin >> n >> t >> k , (n || t || k) ; t_++ ){\n\t\t// 初期化\n\t\tinit();\n\t\t\n\t\tfor(int i = 0 ; i < n-1 ; i++ ){\n\t\t\tint u, v, cost;\n\t\t\tcin >> u >> v >> cost;\n\t\t\tu--; v--;\n\t\t\tif( u > v ) swap(u,v);\n\t\t\t\n\t\t\tis_cost[P(u,v)] = cost;\n\t\t\tadd_edge( u , v , cost );\n\t\t\tpair<int,P> p( cost , P(u,v) );\n\t\t\ta.push_back( p );\n\t\t}\n\t\tfor(int i = 0 ; i < t ; i++ ){\n\t\t\tint b;\n\t\t\tcin >> b;\n\t\t\tb--;\n\t\t\tbase[b] = true;\n\t\t}\n\t\t\n\t\tint ans = solve();\n\t\tcout << \"Case \" << t_ << \": \" << ans << endl;\n\t}\n}"
  },
  {
    "language": "C++",
    "code": "#include <iostream>\n#include <cstdio>\n#include <vector>\n#include <set>\n#include <map>\n#include <queue>\n#include <deque>\n#include <stack>\n#include <algorithm>\n#include <cstring>\n#include <functional>\n#include <cmath>\nusing namespace std;\n#define rep(i,n) for(int i=0;i<(n);++i)\n#define rep1(i,n) for(int i=1;i<=(n);++i)\n#define all(c) (c).begin(),(c).end()\n#define fs first\n#define sc second\n#define pb push_back\n#define show(x) cout << #x << \" \" << x << endl\nstruct edge{int from,to,cost;};\nbool operator<(const edge& x,const edge& y){\n\treturn x.cost>y.cost;\n}\nint par[10000],id[10000];\nvoid init(int n){\n\trep(i,n) par[i]=i;\n\trep(i,n) id[i]=-1;\n}\nint find(int x){\n\tif(x==par[x]) return x;\n\telse par[x]=find(par[x]);\n}\nvoid unite(int x,int y){\n\tx=find(x),y=find(y);\n\tif(id[x]>=0) par[y]=x;\n\telse par[x]=y;\n}\nvector<edge> es;\nvector<int> costs;\nint main(){\n\tint tt=0;\n\twhile(true){\n\t\ttt++;\n\t\tint n,t,k;\n\t\tcin>>n>>t>>k;\n\t\tif(n==0) break;\n\t\tes.clear();\n\t\tinit(n);\n\t\trep(i,n-1){\n\t\t\tint a,b,c;\n\t\t\tcin>>a>>b>>c;\n\t\t\tes.pb(edge{a-1,b-1,c});\n\t\t}\n\t\trep(i,t){\n\t\t\tint x;\n\t\t\tcin>>x;\n\t\t\tid[x-1]=x-1;\n\t\t}\n\t\tsort(all(es));\n\t\tcosts.clear();\n\t\trep(i,n-1){\n\t\t\tint a=es[i].from,b=es[i].to,c=es[i].cost;\n\t\t\ta=find(a),b=find(b);\n\t\t\tif(id[a]>=0&&id[b]>=0) costs.pb(c);\n\t\t\telse unite(a,b);\n\t\t}\n\t\tsort(all(costs));\n//\t\tshow(costs.size());\n\t\tint sum=0;\n\t\trep(i,k) sum+=costs[i];\n\t\tprintf(\"Case %d: %d\\n\",tt,sum);\n\t}\n}"
  },
  {
    "language": "C++",
    "code": "#include<cstdio>\n#include<vector>\n#include<algorithm>\n\nusing namespace std;\n\nstruct edge{\n\tint to,cost;\n\tedge(){}\n\tedge(int a,int b):to(a),cost(b){}\n};\n\nstruct edge2{\n\tint u,v,cost;\n\tedge2(){}\n\tedge2(int a,int b,int c):u(a),v(b),cost(c){}\n};\n\nbool operator<(const edge2 &e1,const edge2 &e2){\n\tif(e1.cost!=e2.cost) return e1.cost<e2.cost;\n\tif(e1.u!=e2.u) return e1.u<e2.u;\n\treturn e1.v<e2.v;\n}\n\nint K;\n\nvector<edge> G[10100];\nbool isBase[10100];\nbool hasBase[10100];\nint N;\nvector<int> bases;\n\nbool newNode[10100];\nvector<edge> nG[10100];\nint deg[10100];\nint V;\nvector<edge2> es;\n\nvoid init(){\n\tes.clear();\n\tbases.clear();\n\tfor(int i=0;i<N;i++){\n\t\tG[i].clear();\n\t\tisBase[i]=false;\n\t\thasBase[i]=false;\n\t\tnewNode[i]=false;\n\t}\n\tfor(int i=0;i<N;i++){\n\t\tnG[i].clear();\n\t\tdeg[i]=0;\n\t}\n\tN=0,V=0;\n}\n\nvoid dfs(int v,int p){\n\tbool flg=isBase[v];\n\tfor(int i=0;i<G[v].size();i++){\n\t\tint u=G[v][i].to;\n\t\tif(u==p) continue;\n\t\tdfs(u,v);\n\t\tflg|=hasBase[u];\n\t}\n\thasBase[v]=flg;\n\tif(isBase[v]) newNode[v]=true;\n\tint cnt=0;\n\tfor(int i=0;i<G[v].size();i++){\n\t\tint u=G[v][i].to;\n\t\tif(u==p) continue;\n\t\tif(hasBase[u]) cnt++;\n\t}\n\tif(cnt>=2){\n\t\tnewNode[v]=true;\n\t}\n}\n\nvoid getNewGraph(int r,int v,int p,int c){\n\tif(newNode[v]){\n\t\tnG[r].push_back(edge(v,c));\n\t\tif(r<v){\n\t\t\tes.push_back(edge2(r,v,c));\n\t//\t\tprintf(\"%d %d %d\\n\",r,v,c);\n\t\t}\n\t\treturn;\n\t}\n\tfor(int i=0;i<G[v].size();i++){\n\t\tint u=G[v][i].to;\n\t\tint cost=G[v][i].cost;\n\t\tif(u==p) continue;\n\t\tgetNewGraph(r,u,v,min(c,cost));\n\t}\n}\n\nint solve(){\n\tif(bases.size()==1){\n\t\treturn 0;\n\t}\n\tdfs(bases[0],-1);\n\tfor(int i=0;i<N;i++){\n\t\tif(newNode[i]){\n\t\t\tfor(int j=0;j<G[i].size();j++){\n\t\t\t\tgetNewGraph(i,G[i][j].to,i,G[i][j].cost);\n\t\t\t}\n\t\t}\n\t}\n\tfor(int i=0;i<N;i++){\n\t\tdeg[i]=nG[i].size();\n\t}\n\tsort(es.begin(),es.end());\n\tint cnt=0;\n\tint res=0;\n\tfor(int i=0;i<es.size();i++){\n\t\tint u=es[i].u,v=es[i].v;\n\t\tif(deg[u]<=1&&isBase[u]==false) continue;\n\t\tif(deg[v]<=1&&isBase[v]==false) continue;\n\t\tdeg[u]--;\n\t\tdeg[v]--;\n\t\tcnt++;\n\t\tres+=es[i].cost;\n\t\tif(cnt==K) break;\n\t}\n\treturn res;\n}\n\nbool input(){\n\tint T;\n\tscanf(\"%d%d%d\",&N,&T,&K);\n\tif(N==0) return false;\n\tfor(int i=0;i<N-1;i++){\n\t\tint u,v,c;\n\t\tscanf(\"%d%d%d\",&u,&v,&c);\n\t\tu--;v--;\n\t\tG[u].push_back(edge(v,c));\n\t\tG[v].push_back(edge(u,c));\n\t}\n\tfor(int i=0;i<T;i++){\n\t\tint v;\n\t\tscanf(\"%d\",&v);\n\t\tv--;\n\t\tisBase[v]=true;\n\t\tbases.push_back(v);\n\t}\n\treturn true;\n}\n\nint main(){\n\tint datano=0;\n\twhile(true){\n\t\tdatano++;\n\t\tinit();\n\t\tbool flg=input();\n\t\tif(flg==false) break;\n\t\tint ans=solve();\n\t\tprintf(\"Case %d: %d\\n\",datano,ans);\n\t}\n\treturn 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include<bits/stdc++.h>\n\nusing namespace std;\n\nstruct edge\n{\n  int to, cost;\n};\n\ntypedef pair< int, int > Pi;\n\nint main()\n{\n  int N, T, K;\n  int A[10000], B[10000], C[10000];\n  int testcase = 1;\n\n  while(scanf(\"%d %d %d\", &N, &T, &K), N) {\n\n    vector< edge > g[10000];\n    int deg[10000] = {};\n    bool M[10000] = {};\n    priority_queue< Pi, vector< Pi >, greater<> > que;\n\n    for(int i = 1; i < N; i++) {\n      scanf(\"%d %d %d\", &A[i], &B[i], &C[i]);\n      --A[i], --B[i];\n      g[A[i]].emplace_back((edge) {B[i], C[i]});\n      g[B[i]].emplace_back((edge) {A[i], C[i]});\n      ++deg[A[i]];\n      ++deg[B[i]];\n      que.emplace(C[i], i);\n    }\n\n    for(int i = 0; i < T; i++) {\n      int x;\n      scanf(\"%d\", &x);\n      --x;\n      M[x] = true;\n    }\n\n    queue< int > beet;\n    bool live[10000];\n    for(int i = 0; i < N; i++) {\n      if(deg[i] == 1) {\n        deg[i]--;\n        beet.emplace(i);\n      }\n      live[i] = true;\n    }\n\n    auto update = [&]()\n    {\n      while(!beet.empty()) {\n        int p = beet.front();\n        beet.pop();\n        if(M[p]) continue;\n        live[p] = false;\n        for(auto &e : g[p]) {\n          if(live[e.to]) {\n            deg[e.to]--;\n            if(deg[e.to] == 0) beet.emplace(e.to);\n          }\n        }\n      }\n    };\n\n    int ret = 0;\n    for(int i = 0; i < K; i++) {\n      update();\n      while(!que.empty()) {\n        int cost, idx;\n        tie(cost, idx) = que.top();\n        que.pop();\n        if(!live[A[idx]] || !live[B[idx]]) continue;\n        ret += cost;\n        --deg[A[idx]];\n        --deg[B[idx]];\n        if(deg[A[idx]] == 1) {\n          beet.emplace(A[idx]);\n          deg[A[idx]]--;\n        }\n        if(deg[B[idx]] == 1) {\n          beet.emplace(B[idx]);\n          deg[B[idx]]--;\n        }\n        break;\n      }\n    }\n\n    printf(\"Case %d: %d\\n\", testcase++, ret);\n  }\n}"
  },
  {
    "language": "C++",
    "code": "#include<bits/stdc++.h>\n\nusing namespace std;\n\nstruct edge\n{\n  int to, cost;\n};\n\ntypedef pair< int, int > Pi;\n\nint main()\n{\n  int N, T, K;\n  int A[10000], B[10000], C[10000];\n  int testcase = 1;\n\n  while(scanf(\"%d %d %d\", &N, &T, &K), N) {\n\n    vector< edge > g[10000];\n    int deg[10000] = {};\n    bool M[10000] = {};\n    priority_queue< Pi, vector< Pi >, greater<> > que;\n\n    for(int i = 1; i < N; i++) {\n      scanf(\"%d %d %d\", &A[i], &B[i], &C[i]);\n      --A[i], --B[i];\n      g[A[i]].emplace_back((edge) {B[i], C[i]});\n      g[B[i]].emplace_back((edge) {A[i], C[i]});\n      ++deg[A[i]];\n      ++deg[B[i]];\n      que.emplace(C[i], i);\n    }\n\n    for(int i = 0; i < T; i++) {\n      int x;\n      scanf(\"%d\", &x);\n      --x;\n      M[x] = true;\n    }\n\n    queue< int > beet;\n    bool live[10000];\n    for(int i = 0; i < N; i++) {\n      if(deg[i] == 1) beet.emplace(i);\n      live[i] = true;\n    }\n\n    auto update = [&]()\n    {\n      while(!beet.empty()) {\n        int p = beet.front();\n        beet.pop();\n        if(M[p]) continue;\n        live[p] = false;\n        for(auto &e : g[p]) {\n          if(live[e.to]) {\n            deg[e.to]--;\n            if(deg[e.to] == 1) beet.emplace(e.to);\n          }\n        }\n      }\n    };\n\n    int ret = 0;\n    for(int i = 0; i < K; i++) {\n      update();\n      while(!que.empty()) {\n        int cost, idx;\n        tie(cost, idx) = que.top();\n        que.pop();\n        if(!live[A[idx]] || !live[B[idx]]) continue;\n        ret += cost;\n        --deg[A[idx]];\n        --deg[B[idx]];\n        if(deg[A[idx]] == 1) beet.emplace(A[idx]);\n        if(deg[B[idx]] == 1) beet.emplace(B[idx]);\n        break;\n      }\n    }\n\n    printf(\"Case %d: %d\\n\", testcase++, ret);\n  }\n}"
  },
  {
    "language": "C++",
    "code": "#include<cstdio>\n#include<vector>\n#include<algorithm>\n\nusing namespace std;\n\nstruct edge{\n\tint to,cost;\n\tedge(){}\n\tedge(int a,int b):to(a),cost(b){}\n};\n\nstruct edge2{\n\tint u,v,cost;\n\tedge2(){}\n\tedge2(int a,int b,int c):u(a),v(b),cost(c){}\n};\n\nbool operator<(const edge2 &e1,const edge2 &e2){\n\tif(e1.cost!=e2.cost) return e1.cost<e2.cost;\n\tif(e1.u!=e2.u) return e1.u<e2.u;\n\treturn e1.v<e2.v;\n}\n\nint K;\n\nvector<edge> G[10100];\nbool isBase[10100];\nbool hasBase[10100];\nint N;\nvector<int> bases;\n\nbool newNode[10100];\nvector<edge> nG[10100];\nint deg[10100];\nint V;\nvector<edge2> es;\n\nvoid init(){\n\tes.clear();\n\tbases.clear();\n\tfor(int i=0;i<N;i++){\n\t\tG[i].clear();\n\t\tisBase[i]=false;\n\t\thasBase[i]=false;\n\t\tnewNode[i]=false;\n\t}\n\tfor(int i=0;i<V;i++){\n\t\tnG[i].clear();\n\t\tdeg[i]=0;\n\t}\n\tN=0,V=0;\n}\n\nvoid dfs(int v,int p){\n\tbool flg=isBase[v];\n\tfor(int i=0;i<G[v].size();i++){\n\t\tint u=G[v][i].to;\n\t\tif(u==p) continue;\n\t\tdfs(u,v);\n\t\tflg|=hasBase[u];\n\t}\n\thasBase[v]=flg;\n\tif(isBase[v]) newNode[v]=true;\n\tint cnt=0;\n\tfor(int i=0;i<G[v].size();i++){\n\t\tint u=G[v][i].to;\n\t\tif(u==p) continue;\n\t\tif(hasBase[u]) cnt++;\n\t}\n\tif(cnt>=2){\n\t\tnewNode[v]=true;\n\t}\n}\n\nvoid getNewGraph(int r,int v,int p,int c){\n\tif(newNode[v]){\n\t\tnG[r].push_back(edge(v,c));\n\t\tif(r<v){\n\t\t\tes.push_back(edge2(r,v,c));\n\t//\t\tprintf(\"%d %d %d\\n\",r,v,c);\n\t\t}\n\t\treturn;\n\t}\n\tfor(int i=0;i<G[v].size();i++){\n\t\tint u=G[v][i].to;\n\t\tint cost=G[v][i].cost;\n\t\tif(u==p) continue;\n\t\tgetNewGraph(r,u,v,min(c,cost));\n\t}\n}\n\nint solve(){\n\tif(bases.size()==1){\n\t\treturn 0;\n\t}\n\tdfs(bases[0],-1);\n\tfor(int i=0;i<N;i++){\n\t\tif(newNode[i]){\n\t\t\tfor(int j=0;j<G[i].size();j++){\n\t\t\t\tgetNewGraph(i,G[i][j].to,i,G[i][j].cost);\n\t\t\t}\n\t\t}\n\t}\n\tfor(int i=0;i<N;i++){\n\t\tdeg[i]=nG[i].size();\n\t}\n\tsort(es.begin(),es.end());\n\tint cnt=0;\n\tint res=0;\n\tfor(int i=0;i<es.size();i++){\n\t\tint u=es[i].u,v=es[i].v;\n\t\tif(deg[u]<=1&&isBase[u]==false) continue;\n\t\tif(deg[v]<=1&&isBase[v]==false) continue;\n\t\tdeg[u]--;\n\t\tdeg[v]--;\n\t\tcnt++;\n\t\tres+=es[i].cost;\n\t\tif(cnt==K) break;\n\t}\n\treturn res;\n}\n\nbool input(){\n\tint T;\n\tscanf(\"%d%d%d\",&N,&T,&K);\n\tif(N==0) return false;\n\tfor(int i=0;i<N-1;i++){\n\t\tint u,v,c;\n\t\tscanf(\"%d%d%d\",&u,&v,&c);\n\t\tu--;v--;\n\t\tG[u].push_back(edge(v,c));\n\t\tG[v].push_back(edge(u,c));\n\t}\n\tfor(int i=0;i<T;i++){\n\t\tint v;\n\t\tscanf(\"%d\",&v);\n\t\tv--;\n\t\tisBase[v]=true;\n\t\tbases.push_back(v);\n\t}\n\treturn true;\n}\n\nint main(){\n\tint datano=0;\n\twhile(true){\n\t\tdatano++;\n\t\tinit();\n\t\tbool flg=input();\n\t\tif(flg==false) break;\n\t\tint ans=solve();\n\t\tprintf(\"Case %d: %d\\n\",datano,ans);\n\t}\n\treturn 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\n \nusing namespace std;\n \nset<int> base;\n \nstruct UnionFind {\n  vector<int> data;\n  UnionFind(int n):data(n, -1){}\n  int find(int x) {\n    return data[x] < 0 ? x : data[x] = find(data[x]);\n  }\n  bool same(int x, int y) {\n    return find(x) == find(y);\n  }\n  void unite(int x, int y) {\n    x = find(x), y = find(y);\n    if(x == y) return;\n    //if(data[x] < data[y]) swap(x, y);\n    if(!base.count(x)) swap(x, y);\n    data[x] += data[y];\n    data[y] = x;\n  }\n};\n \nstruct edge {\n  int from, to, cost;\n  edge(){}\n  edge(int from, int to, int cost):from(from), to(to), cost(cost){}\n  bool operator < (const edge& e) const {\n    return cost > e.cost;\n  }\n};\n \nusing Pi = pair<int, int>;\nusing Tapris = tuple<int, int, int>;\n \nvector<edge> es;\n \nint main() {\n  int n, t, k;\n  int T = 0;\n  while(cin >> n >> t >> k, n || t || k) {\n    base.clear();\n    es.clear();\n    for(int i = 0; i < n-1; i++) {\n      int a, b, c;\n      cin >> a >> b >> c;\n      --a, --b;\n      es.emplace_back(a, b, c);\n    }\n    UnionFind uf(n);\n    for(int i = 0; i < t; i++) {\n      int d; cin >> d; --d;\n      base.insert(d);\n    }\n    vector<int> ans;\n    sort(es.begin(), es.end());\n      for(edge& e : es) {\n    if(!uf.same(e.from, e.to)) {\n      int x = uf.find(e.from), y = uf.find(e.to);\n      if(base.count(x) && base.count(y)) {\n        ans.push_back(e.cost);\n      }\n      uf.unite(x, y);\n      }\n    }\n    sort(ans.begin(), ans.end());\n    int total = 0;\n    for(int i = 0; i < k; i++) total += ans[i];\n    cout << \"Case \" << ++T << \": \" << total << endl;\n  }\n  return 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include <iostream>\n#include <vector>\n#include <map>\n#include <algorithm>\nusing namespace std;\n\nconst int MAX_V = 100000;\ntypedef pair<int,int> P;\nstruct edge{ int to,cost; };\n\n// グラフ (隣接リスト)\nvector<edge> G[MAX_V];\n// e = (u,v) , is_cost[e] := コスト\nmap<P,int> is_cost;\n// base[u] == true のとき ノード u は ベース\nbool base[MAX_V];\n// (cost,(u,v))の組\nvector< pair<int ,P> > a;\n// used[u] == true のとき ノード u は探索済み\nbool used[MAX_V];\n\nint n, t, k;\n\n\n// 初期化\nvoid init(){\n\ta.clear();\n\tis_cost.clear();\n\tfor(int i=0 ; i < MAX_V ; i++ ){\n\t\tbase[i] = false;\n\t\tG[i].clear();\n\t}\n}\n\n// グラフに重みcostのエッジ(u,v)を追加\nvoid add_edge(int u, int v, int cost){\n\tedge e;\n\te.to = v;\n\te.cost = cost;\n\tG[u].push_back( e );\n\te.to = u;\n\tG[v].push_back( e );\n}\n\n// グラフのエッジ(u,v)を切断\nvoid cut_edge(int u, int v){\n\tfor(vector<edge>::iterator it = G[u].begin() ; it != G[u].end() ; ++it ){\n\t\tif( (*it).to == v ){\n\t\t\tG[u].erase( it );\n\t\t\treturn ;\n\t\t}\n\t}\n}\n\n\n// ノード u の木にベースがあるかどうか\nvoid is_base(int u, bool& flag){\n\tif( u < 0 || u >= n ) return;\n\t\n\t// ノード u がベースのとき\n\tif( base[u] || flag ){\n\t\tflag = true;\n\t\treturn;\n\t}\n\t// ノード u が探索済みのとき\n\tif( used[u] ) return;\n\tused[u] = true;\n\t\n\tfor(int i=0 ; i < G[u].size() ; i++ ){\n\t\tedge e = G[u][i];\n\t\tis_base( e.to , flag );\n\t}\n}\n\nint solve(){\n\t\n\t// 連結成分の数\n\tint p=1;\n\t// コストの総和\n\tint sum = 0;\n\t\n\tsort( a.begin() , a.end() );\n\tfor(int i=0 ; i < a.size() ; i++ ){\n\t\tint cost = a[i].first;\n\t\tint u = a[i].second.first;\n\t\tint v = a[i].second.second;\n\t\tif( u > v ) swap(u,v);\n\t\t\n\t\tcut_edge( u , v );\n\t\t\n\t\tbool flag1 = false, flag2 = false;\n\t\tfor(int j=0 ; j < MAX_V ; j++ ) used[j] = false;\n\t\tis_base( u , flag1 );\n\t\tfor(int j=0 ; j < MAX_V ; j++ ) used[j] = false;\n\t\tis_base( v , flag2 );\n\t\t//flag1 = flag2 = true;\n\t\t\n\t\t// u,vの木の両方にベースを含むとき切断する\n\t\tif( flag1 && flag2 ){\n\t\t\tsum += is_cost[P(u,v)];\n\t\t\tp++;\n\t\t}else{\n\t\t\tadd_edge( u , v , is_cost[P(u,v)] );\n\t\t}\n\t\t\n\t\t// 連結成分が K+1 個になったらループを抜ける\n\t\tif( p == k+1 ) break;\n\t}\n\treturn sum;\n}\n\nint main(){\n\tfor(int t_ = 1 ; cin >> n >> t >> k , (n || t || k) ; t_++ ){\n\t\t// 初期化\n\t\tinit();\n\t\t\n\t\tfor(int i = 0 ; i < n-1 ; i++ ){\n\t\t\tint u, v, cost;\n\t\t\tcin >> u >> v >> cost;\n\t\t\tu--; v--;\n\t\t\tif( u > v ) swap(u,v);\n\t\t\t\n\t\t\tis_cost[P(u,v)] = cost;\n\t\t\tadd_edge( u , v , cost );\n\t\t\tpair<int,P> p( cost , P(u,v) );\n\t\t\ta.push_back( p );\n\t\t}\n\t\tfor(int i = 0 ; i < t ; i++ ){\n\t\t\tint b;\n\t\t\tcin >> b;\n\t\t\tb--;\n\t\t\tbase[b] = true;\n\t\t}\n\t\t\n\t\tint ans = solve();\n\t\tcout << \"Case \" << t_ << \": \" << ans << endl;\n\t}\n}"
  },
  {
    "language": "C++",
    "code": "#include <iostream>\n#include <vector>\n#include <map>\n#include <algorithm>\nusing namespace std;\n\nconst int MAX_V = 100000;\ntypedef pair<int,int> P;\nstruct edge{ int to,cost; };\n\n// グラフ (隣接リスト)\nvector<edge> G[MAX_V];\n// e = (u,v) , is_cost[e] := コスト\nmap<P,int> is_cost;\n// base[u] == true のとき ノード u は ベース\nbool base[MAX_V];\n// (cost,(u,v))の組\nvector< pair<int ,P> > a;\n// used[u] == true のとき ノード u は探索済み\nbool used[MAX_V];\n\nint n, t, k;\n\n\n// 初期化\nvoid init(){\n\ta.clear();\n\tis_cost.clear();\n\tfor(int i=0 ; i < MAX_V ; i++ ){\n\t\tbase[i] = false;\n\t\tG[i].clear();\n\t}\n}\n\n// グラフに重みcostのエッジ(u,v)を追加\nvoid add_edge(int u, int v, int cost){\n\tedge e;\n\te.to = v;\n\te.cost = cost;\n\tG[u].push_back( e );\n\te.to = u;\n\tG[v].push_back( e );\n}\n\n// グラフのエッジ(u,v)を切断\nvoid cut_edge(int u, int v){\n\tfor(vector<edge>::iterator it = G[u].begin() ; it != G[u].end() ; ++it ){\n\t\tif( (*it).to == v ){\n\t\t\tG[u].erase( it );\n\t\t\treturn ;\n\t\t}\n\t}\n}\n\n\n// ノード u の木にベースがあるかどうか\nvoid is_base(int u, bool& flag){\n\tif( u < 0 || u >= n ) return;\n\t\n\t// ノード u がベースのとき\n\tif( base[u] || flag ){\n\t\tflag = true;\n\t\treturn;\n\t}\n\t// ノード u が探索済みのとき\n\tif( used[u] ) return;\n\tused[u] = true;\n\t\n\tfor(int i=0 ; i < G[u].size() ; i++ ){\n\t\tedge e = G[u][i];\n\t\t//is_base( e.to , flag );\n\t}\n}\n\nint solve(){\n\t\n\t// 連結成分の数\n\tint p=1;\n\t// コストの総和\n\tint sum = 0;\n\t\n\tsort( a.begin() , a.end() );\n\tfor(int i=0 ; i < a.size() ; i++ ){\n\t\tint cost = a[i].first;\n\t\tint u = a[i].second.first;\n\t\tint v = a[i].second.second;\n\t\tif( u > v ) swap(u,v);\n\t\t\n\t\tcut_edge( u , v );\n\t\t\n\t\tbool flag1 = false, flag2 = false;\n\t\tfor(int j=0 ; j < MAX_V ; j++ ) used[j] = false;\n\t\tis_base( u , flag1 );\n\t\tfor(int j=0 ; j < MAX_V ; j++ ) used[j] = false;\n\t\tis_base( v , flag2 );\n\t\t//flag1 = flag2 = true;\n\t\t\n\t\t// u,vの木の両方にベースを含むとき切断する\n\t\tif( flag1 && flag2 ){\n\t\t\tsum += is_cost[P(u,v)];\n\t\t\tp++;\n\t\t}else{\n\t\t\tadd_edge( u , v , is_cost[P(u,v)] );\n\t\t}\n\t\t\n\t\t// 連結成分が K+1 個になったらループを抜ける\n\t\tif( p == k+1 ) break;\n\t}\n\treturn sum;\n}\n\nint main(){\n\tfor(int t_ = 1 ; cin >> n >> t >> k , (n || t || k) ; t_++ ){\n\t\t// 初期化\n\t\tinit();\n\t\t\n\t\tfor(int i = 0 ; i < n-1 ; i++ ){\n\t\t\tint u, v, cost;\n\t\t\tcin >> u >> v >> cost;\n\t\t\tu--; v--;\n\t\t\tif( u > v ) swap(u,v);\n\t\t\t\n\t\t\tis_cost[P(u,v)] = cost;\n\t\t\tadd_edge( u , v , cost );\n\t\t\tpair<int,P> p( cost , P(u,v) );\n\t\t\ta.push_back( p );\n\t\t}\n\t\tfor(int i = 0 ; i < t ; i++ ){\n\t\t\tint b;\n\t\t\tcin >> b;\n\t\t\tb--;\n\t\t\tbase[b] = true;\n\t\t}\n\t\t\n\t\tint ans = solve();\n\t\tcout << \"Case \" << t_ << \": \" << ans << endl;\n\t}\n}"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\n \n#define _overload(_1,_2,_3,name,...) name\n#define _rep(i,n) _range(i,0,n)\n#define _range(i,a,b) for(int i=(int)(a);i<(int)(b);++i)\n#define rep(...) _overload(__VA_ARGS__,_range,_rep,)(__VA_ARGS__)\n \n#define _rrep(i,n) _rrange(i,n,0)\n#define _rrange(i,a,b) for(int i=(int)(a)-1;i>=(int)(b);--i)\n#define rrep(...) _overload(__VA_ARGS__,_rrange,_rrep,)(__VA_ARGS__)\n \n#define _all(arg) begin(arg),end(arg)\n#define uniq(arg) sort(_all(arg)),(arg).erase(unique(_all(arg)),end(arg))\n#define getidx(ary,key) lower_bound(_all(ary),key)-begin(ary)\n#define clr(a,b) memset((a),(b),sizeof(a))\n#define bit(n) (1LL<<(n))\n \n// #define DEBUG\n \n#ifdef DEBUG\n    #define dump(...) fprintf(stderr, __VA_ARGS__)\n#else\n    #define dump(...)\n#endif\n \ntemplate<class T>bool chmax(T &a, const T &b) { return (a<b)?(a=b,1):0;}\ntemplate<class T>bool chmin(T &a, const T &b) { return (b<a)?(a=b,1):0;}\n \nusing namespace std;\nusing ll=long long;\nusing vi=vector<int>;\nusing vll=vector<ll>;\n \nconst double EPS = 1e-10;\nconst double PI = acos(-1.0);\nconst ll inf =1LL << 62;\nconst ll mod=1000000007LL;\nconst int dx[4]={1,0,-1,0};\nconst int dy[4]={0,1,0,-1};\n \n \nll extgcd(ll a,ll b,ll& x,ll& y){x=1,y=0;ll g=a;if(b!=0) g=extgcd(b,a%b,y,x),y-=a/b*x;return g;}\nll ADD(const ll &a, const ll &b,const ll &mod) { return (a+b)%mod;}\nll SUB(const ll &a, const ll &b,const ll &mod) { return (a-b+mod)%mod;}\nll MUL(const ll &a, const ll &b,const ll &mod) { return (1LL*a*b)%mod;}\nll DIV(const ll &a, const ll &b,const ll &mod) {ll x,y; extgcd(b,mod,x,y);return MUL(a,(x+mod)%mod,mod);}\n \nrandom_device rd;\nmt19937 mt(rd());\nuniform_int_distribution<int> dice(1,6);\nuniform_real_distribution<double> score(0.0,10.0);\n\nstruct UnionFind {\n    vector<int> data;\n    UnionFind(int size) : data(size, -1) { }\n    bool unionSet(int x, int y) {\n        x = root(x); y = root(y);\n        if (x != y) {\n            if (data[y] < data[x]) swap(x, y);\n            data[x] += data[y]; data[y] = x;\n        }\n        return x != y;\n    }\n    bool findSet(int x, int y) {\n        return root(x) == root(y);\n    }\n    int root(int x) {\n        return data[x] < 0 ? x : data[x] = root(data[x]);\n    }\n    int size(int x) {\n        return -data[root(x)];\n    }\n};\n\n// (cost, a, b)\nusing Edge = tuple<int, int, int>;\n\nint main(void){\n    int T = 1;\n    for(int n, t, k; cin >> n >> t >> k, n;){\n        vector<Edge> edges(n - 1);\n        ll sum = 0;\n        rep(i, n - 1){\n            int a, b, cost; cin >> a >> b >> cost;\n            a--, b--;\n            edges[i] = Edge(cost, a, b);\n            sum += cost;\n        }\n        sort(_all(edges), greater<Edge>());\n\n        UnionFind uf(n);\n\n        vi has_b(n);\n        rep(i, t){\n            int v; cin >> v; v--;\n            has_b[v] = true;\n        }\n\n        int num_bb = t - 1 - k;\n        int cnt = 0;\n        ll res = sum;\n        rep(i, n - 1){\n            int a, b, cost; tie(cost, a, b) = edges[i];\n            int ra = uf.root(a), rb = uf.root(b);\n            if(ra == rb) continue;\n\n            if(has_b[ra] and has_b[rb]){\n                if(num_bb <= 0) continue;\n                num_bb--;\n            }\n            uf.unionSet(a, b);\n\n            if(has_b[ra] or has_b[rb]){\n                has_b[uf.root(a)] = true;\n            }\n            else {\n                has_b[uf.root(a)] = false;\n            }\n\n            res -= cost;\n\n            cnt++;\n            if(cnt == n - 1 - k) break;\n        }\n\n        cout << \"Case \" << T++ << \": \" << res << endl;\n    }\n\n    return 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include<bits/stdc++.h>\n\nusing namespace std;\n\nstruct edge\n{\n  int to, cost;\n};\n\ntypedef pair< int, int > Pi;\n\nint main()\n{\n  int N, T, K;\n  int A[10000], B[10000], C[10000];\n  int testcase = 1;\n\n  while(scanf(\"%d %d %d\", &N, &T, &K), N) {\n\n    vector< edge > g[10000];\n    int deg[10000] = {};\n    bool M[10000] = {};\n    priority_queue< Pi, vector< Pi >, greater<> > que;\n\n    for(int i = 1; i < N; i++) {\n      scanf(\"%d %d %d\", &A[i], &B[i], &C[i]);\n      --A[i], --B[i];\n      g[A[i]].emplace_back((edge) {B[i], C[i]});\n      g[B[i]].emplace_back((edge) {A[i], C[i]});\n      ++deg[A[i]];\n      ++deg[B[i]];\n      que.emplace(C[i], i);\n    }\n\n    for(int i = 0; i < T; i++) {\n      int x;\n      scanf(\"%d\", &x);\n      --x;\n      M[x] = true;\n    }\n\n    queue< int > beet;\n    bool live[10000];\n    for(int i = 0; i < N; i++) {\n      if(deg[i] == 1) {\n        deg[i]--;\n        beet.emplace(i);\n      }\n      live[i] = true;\n    }\n\n    auto update = [&]()\n    {\n      while(!beet.empty()) {\n        int p = beet.front();\n        beet.pop();\n        if(M[p]) continue;\n        live[p] = false;\n        for(auto &e : g[p]) {\n          if(live[e.to]) {\n            deg[e.to]--;\n            if(deg[e.to] <= 1) beet.emplace(e.to);\n          }\n        }\n      }\n    };\n\n    int ret = 0;\n    for(int i = 0; i < K; i++) {\n      update();\n      while(!que.empty()) {\n        int cost, idx;\n        tie(cost, idx) = que.top();\n        que.pop();\n        if(!live[A[idx]] || !live[B[idx]]) continue;\n        ret += cost;\n        --deg[A[idx]];\n        --deg[B[idx]];\n        if(deg[A[idx]] <= 1) beet.emplace(A[idx]);\n        if(deg[B[idx]] <= 1) beet.emplace(B[idx]);\n        break;\n      }\n    }\n\n    printf(\"Case %d: %d\\n\", testcase++, ret);\n  }\n}"
  },
  {
    "language": "C++",
    "code": "#include<bits/stdc++.h>\n\nusing namespace std;\n\nstruct edge\n{\n  int to, cost;\n};\n\ntypedef pair< int, int > Pi;\n\nint main()\n{\n  int N, T, K;\n  int A[10000], B[10000], C[10000];\n  int testcase = 1;\n\n  while(scanf(\"%d %d %d\", &N, &T, &K), N) {\n\n    vector< edge > g[10000];\n    int deg[10000] = {};\n    bool M[10000] = {};\n    priority_queue< Pi, vector< Pi >, greater<> > que;\n\n    for(int i = 1; i < N; i++) {\n      scanf(\"%d %d %d\", &A[i], &B[i], &C[i]);\n      --A[i], --B[i];\n      g[A[i]].emplace_back((edge) {B[i], C[i]});\n      g[B[i]].emplace_back((edge) {A[i], C[i]});\n      ++deg[A[i]];\n      ++deg[B[i]];\n      que.emplace(C[i], i);\n    }\n\n    for(int i = 0; i < T; i++) {\n      int x;\n      scanf(\"%d\", &x);\n      --x;\n      M[x] = true;\n    }\n\n    queue< int > beet;\n    bool live[10000];\n    for(int i = 0; i < N; i++) {\n      if(deg[i] == 1) {\n        deg[i]--;\n        beet.emplace(i);\n      }\n      live[i] = true;\n    }\n\n    auto update = [&]()\n    {\n      while(!beet.empty()) {\n        int p = beet.front();\n        beet.pop();\n        if(M[p]) continue;\n        live[p] = false;\n        for(auto &e : g[p]) {\n          if(live[e.to]) {\n            deg[e.to]--;\n            if(deg[e.to] == 0) beet.emplace(e.to);\n          }\n        }\n      }\n    };\n\n    int ret = 0;\n    for(int i = 0; i < K; i++) {\n      update();\n      while(!que.empty()) {\n        int cost, idx;\n        tie(cost, idx) = que.top();\n        que.pop();\n        if(!live[A[idx]] || !live[B[idx]]) continue;\n        ret += cost;\n        --deg[A[idx]];\n        --deg[B[idx]];\n        if(deg[A[idx]] <= 1) beet.emplace(A[idx]);\n        if(deg[B[idx]] <= 1) beet.emplace(B[idx]);\n        break;\n      }\n    }\n\n    printf(\"Case %d: %d\\n\", testcase++, ret);\n  }\n}"
  },
  {
    "language": "C++",
    "code": "#include<bits/stdc++.h>\n#define N 10005\n#define rank raljfds\nusing namespace std;\ntypedef pair<int,int> P;\ntypedef pair<int,P> P2;\n \nclass UF{\npublic:\n  int V;\n  vector<int> par, rank, mil;\n  UF(){}\n  UF(int V):V(V),par(V),rank(V,0),mil(V,-1){for(int i=0;i<V;i++) par[i]=i;}\n \n  int find(int x){\n    assert(x<V);\n    if(par[x]==x) return x;\n    return par[x]=find(par[x]);\n  }\n   \n  void unite(int x,int y){\n    x=find(x), y=find(y);\n    if(x==y)return;\n    \n    if(mil[x]!=-1) mil[y]=mil[x];\n    if(mil[y]!=-1) mil[x]=mil[y];\n    \n    if(rank[x]<rank[y]){\n      par[x]=y;\n    }\n    else{\n      par[y]=x;\n      if(rank[x]<rank[y]) rank[x]++;\n    }\n  }\n   \n  bool same(int x,int y){return find(x)==find(y);}\n   \n  void add_mil(int num){\n    mil[num]=num;\n  }\n   \n  int get_mil(int x){\n    return mil[find(x)];\n  }\n};\n \nint n,t,k;\nvector<P2> G;\nUF uf;\n \nint solve(){\n   \n  uf=UF(n);\n   \n  int milnum;\n   \n  for(int i=0;i<t;i++){\n \n    cin>>milnum;\n     \n    uf.add_mil(milnum-1);\n  }\n   \n  vector<int> ans;\n   \n  for(int idx=0;idx<G.size();idx++){\n     \n    int cost=G[idx].first;\n    int A=G[idx].second.first;\n    int B=G[idx].second.second;\n    \n    if(!(uf.get_mil(A)!=-1&&uf.get_mil(B)!=-1)) uf.unite(A,B);\n    else ans.push_back(cost);\n    \n  }\n \n  sort(ans.begin(),ans.end());\n \n  int res=0;\n\n  for(int i=0;i<k;i++) res+=ans[i];\n   \n  return res;\n}\n \nint main(){\n \n  int T=1;\n   \n  while(1){\n \n    cin>>n>>t>>k;\n    if(!n&&!t&&!k) break;\n \n    int a,b,cost;\n     \n    for(int i=0;i<n-1;i++){\n       \n      cin>>a>>b>>cost;\n       \n      a--, b--;\n \n      G.push_back(P2(cost,P(a,b)));\n    }\n     \n    sort(G.begin(),G.end(),greater<P2>());\n     \n    cout<<\"Case \"<<T<<\": \";\n     \n    cout<<solve()<<endl;\n \n    G.clear();\n     \n    T++;\n  }\n   \n  return 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include <stdio.h>\n#include <string.h>\n#include <algorithm>\n#include <iostream>\n#include <math.h>\n#include <assert.h>\n#include <vector>\n#include <queue>\n#include <string>\n#include <map>\n#include <set>\n\nusing namespace std;\ntypedef long long ll;\ntypedef unsigned int uint;\ntypedef unsigned long long ull;\nstatic const double EPS = 1e-9;\nstatic const double PI = acos(-1.0);\n\n#define REP(i, n) for (int i = 0; i < (int)(n); i++)\n#define FOR(i, s, n) for (int i = (s); i < (int)(n); i++)\n#define FOREQ(i, s, n) for (int i = (s); i <= (int)(n); i++)\n#define FORIT(it, c) for (__typeof((c).begin())it = (c).begin(); it != (c).end(); it++)\n#define MEMSET(v, h) memset((v), h, sizeof(v))\n\nint n, t, k;\nbool base[10010];\nvector<pair<int, int> > g[10010];\nvector<ll> cands;\n\nll calc(int from, int parent) {\n  vector<ll> nret;\n  FORIT(it, g[from]) {\n    if (it->first == parent) { continue; }\n    ll v = min((ll)it->second, calc(it->first, from));\n    nret.push_back(v);\n  }\n  sort(nret.begin(), nret.end());\n  ll ret = 0;\n  if (base[from]) {\n    ret = 1LL << 60;\n    REP(i, nret.size()) { cands.push_back(nret[i]); }\n  } else {\n    if (nret.size() == 0) {\n      ret = 0;\n      k++;\n    } else {\n      ret = nret.back();\n      REP(i, nret.size() - 1) { cands.push_back(nret[i]); }\n    }\n  }\n  return ret;\n}\n\nint main() {\n  int test_case = 0;\n  while (scanf(\"%d %d %d\", &n, &t, &k), n|t|k) {\n    test_case++;\n    MEMSET(base, false);\n    cands.clear();\n    REP(i, n) { g[i].clear(); }\n    REP(i, n - 1) {\n      int f, t, c;\n      scanf(\"%d %d %d\", &f, &t, &c);\n      f--; t--;\n      g[f].push_back(make_pair(t, c));\n      g[t].push_back(make_pair(f, c));\n    }\n    REP(i, t) {\n      int v;\n      scanf(\"%d\", &v);\n      base[v - 1] = true;\n    }\n    calc(0, 0);\n    sort(cands.begin(), cands.end());\n    ll ans = 0;\n    REP(i, k) { ans += cands[i]; }\n    printf(\"Case %d: %lld\\n\", test_case, ans);\n  }\n}"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\n#define ll long long\n#define INF 1000000005\n#define MOD 1000000007\n#define EPS 1e-10\n#define rep(i,n) for(int i=0;i<(int)(n);++i)\n#define rrep(i,n) for(int i=(int)(n)-1;i>=0;--i)\n#define srep(i,s,t) for(int i=(int)(s);i<(int)(t);++i)\n#define each(a,b) for(auto& (a): (b))\n#define all(v) (v).begin(),(v).end()\n#define len(v) (int)(v).size()\n#define zip(v) sort(all(v)),v.erase(unique(all(v)),v.end())\n#define cmx(x,y) x=max(x,y)\n#define cmn(x,y) x=min(x,y)\n#define fi first\n#define se second\n#define pb push_back\n#define show(x) cout<<#x<<\" = \"<<(x)<<endl\n#define spair(p) cout<<#p<<\": \"<<p.fi<<\" \"<<p.se<<endl\n#define sar(a,n) cout<<#a<<\":\";rep(kbrni,n)cout<<\" \"<<a[kbrni];cout<<endl\n#define svec(v) cout<<#v<<\":\";rep(kbrni,v.size())cout<<\" \"<<v[kbrni];cout<<endl\n#define svecp(v) cout<<#v<<\":\";each(kbrni,v)cout<<\" {\"<<kbrni.first<<\":\"<<kbrni.second<<\"}\";cout<<endl\n#define sset(s) cout<<#s<<\":\";each(kbrni,s)cout<<\" \"<<kbrni;cout<<endl\n#define smap(m) cout<<#m<<\":\";each(kbrni,m)cout<<\" {\"<<kbrni.first<<\":\"<<kbrni.second<<\"}\";cout<<endl\n\nusing namespace std;\n\ntypedef pair<int,int> P;\ntypedef pair<ll,ll> pll;\ntypedef vector<int> vi;\ntypedef vector<vi> vvi;\ntypedef vector<ll> vl;\ntypedef vector<vl> vvl;\ntypedef vector<double> vd;\ntypedef vector<P> vp;\ntypedef vector<string> vs;\n\nconst int MAX_N = 10005;\n\nstruct edge\n{\n    int to,cost;\n};\n\nvector<edge> G[MAX_N];\nbool ok[MAX_N];\nint sub[MAX_N];\nint n,t,k;\n\nvoid dfs(int u,int p)\n{\n    sub[u] = 1;\n    each(e,G[u]){\n        int v = e.to;\n        if(p != v){\n            dfs(v,u);\n            sub[u] += sub[v];\n        }\n    }\n}\n\nvvi redfs(int u,int p)\n{\n    vvi dp(2,vi(sub[u]+1,INF));\n    int mx = 1;\n    if(ok[u]){\n        dp[1][1] = 0;\n    }else{\n        dp[0][1] = 0;\n    }\n    each(e,G[u]){\n        cmn(mx,k+1);\n        int v = e.to, c = e.cost;\n        if(p != v){\n            vvi res = redfs(v,u);\n            // rep(i,2){\n            //     rep(j,len(res[i])){\n            //         cout << v << \" \" << i << \" \" << j << \" \" << res[i][j] << \"\\n\";\n            //     }\n            // }\n            vvi dp2(2,vi(mx+len(res[0]),INF));\n            srep(i,1,mx+1){\n                srep(j,1,len(res[0])){\n                    if(ok[u]){\n                        cmn(dp2[1][i+j-1],dp[1][i]+res[0][j]);\n                        cmn(dp2[1][i+j-1],dp[1][i]+res[1][j]);\n                        cmn(dp2[1][i+j],dp[1][i]+res[1][j]+c);\n                    }else{\n                        cmn(dp2[0][i+j-1],dp[0][i]+res[0][j]);\n                        cmn(dp2[0][i+j],dp[0][i]+res[1][j]+c);\n                        cmn(dp2[1][i+j-1],dp[0][i]+res[1][j]);\n                        cmn(dp2[1][i+j-1],dp[1][i]+res[0][j]);\n                        cmn(dp2[1][i+j-1],dp[1][i]+res[1][j]);\n                        cmn(dp2[1][i+j],dp[1][i]+res[1][j]+c);\n                    }\n                }\n            }\n            mx += len(res[0]) - 1;\n            rep(i,2){\n                rep(j,mx+1){\n                    dp[i][j] = dp2[i][j];\n                }\n            }\n            // rep(i,2){\n            //     rep(j,mx+1){\n            //         cout << i << \" \" << j << \" \" << dp[i][j] << \"\\n\";\n            //     }\n            // }\n        }\n    }\n    return dp;\n}\n\nint main()\n{\n    cin.tie(0);\n    ios::sync_with_stdio(false);\n    int id = 0;\n    while(1){\n        cin >> n >> t >> k;\n        if(n == 0){\n            break;\n        }\n        rep(i,n){\n            G[i].clear(),ok[i] = false;\n        }\n        rep(i,n-1){\n            int a,b,c;\n            cin >> a >> b >> c;\n            G[a-1].pb((edge){b-1,c}),G[b-1].pb((edge){a-1,c});\n        }\n        rep(i,t){\n            int a;\n            cin >> a;\n            --a;\n            ok[a] = true;\n        }\n        dfs(0,-1);\n        vvi ans = redfs(0,-1);\n        cout << \"Case \" << ++id << \": \" << ans[1][k+1] << \"\\n\";\n    }\n    return 0;\n}\n\n"
  },
  {
    "language": "C++",
    "code": "#include<bits/stdc++.h>\nusing namespace std;\n\nstruct unionfind{\n  int parent[500000];\n  int size[500000];\n  \n  void init(int n){\n    for(int i=0;i<n;i++){\n      parent[i]=i;\n      size[i]=1;\n    }\n  }\n  int find(int x){\n    if(parent[x]==x)return x;\n    else parent[x]=find(parent[x]);\n  }\n  bool same(int x,int y){\n    return (find(x)==find(y));\n  }\n  bool getSize(int x){\n    return size[ find(x) ];\n  }\n  void unite(int x,int y){\n    x=find(x);\n    y=find(y);\n    if(x==y)return;\n    if(size[x]>size[y])swap(x,y);\n    parent[x]=y;\n    size[y]+=size[x];\n  }\n};\n  \nstruct edge{\n  int from,to,cost;\n  bool operator < (const edge &e) const {\n    return cost < e.cost;\n  }\n};\n\nint n,t,k;\n\nint main(){\n  unionfind uf;\n  \n  for(int tc=1;;tc++){\n    cin>>n>>t>>k;\n    if(n==0&&t==0&&k==0)break;\n    vector<edge> E;\n    for(int i=0;i<n-1;i++){\n      int a,b,c;\n      cin>>a>>b>>c;\n      a--,b--;\n      E.push_back( (edge){a,b,-c} );\n    }\n    for(int i=0;i<t;i++){\n      int a;\n      cin>>a;\n      a--;\n      E.push_back( (edge){a,n,-20000} );\n    }\n    sort(E.begin(),E.end());\n    uf.init(n+1);\n\n    vector<edge> tmp;\n    \n    for(int i=0;i<(int)E.size();i++){\n      edge e=E[i];\n      if( uf.same(e.from,e.to) ){\n        tmp.push_back(e);\n      }else{\n        uf.unite(e.from,e.to);\n      }\n    }\n\n    int ans=0;\n    assert( (int)tmp.size() == t-1 );\n    \n    for(int i=t-1-k;i<(int)tmp.size();i++){\n      ans-=tmp[i].cost;\n    }\n    cout<<\"Case \"<<tc<<\": \"<<ans<<endl;\n    \n  }\n  return 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include<queue>\n#include<cstdio>\n#include<algorithm>\n\n#define rep(i,n) for(int i=0;i<(n);i++)\n\nusing namespace std;\n\nstruct edge{\n\tint u,v,cost;\n\tbool operator <(const edge &e)const{ return cost<e.cost; }\n\tbool operator==(const edge &e)const{ return u==e.u && v==e.v && cost==e.cost; }\n};\n\nint n,nt;\nbool term[10000];\nvector<edge> G[10000];\n\nbool bfs(int u0,int pre0){\n\tqueue< pair<int,int> > Q;\n\tQ.push(make_pair(u0,pre0));\n\twhile(!Q.empty()){\n\t\tint u=Q.front().first,pre=Q.front().second; Q.pop();\n\t\tif(term[u]) return true;\n\t\trep(i,G[u].size()){\n\t\t\tint v=G[u][i].v;\n\t\t\tif(v!=pre) Q.push(make_pair(v,u));\n\t\t}\n\t}\n\treturn false;\n}\n\nint main(){\n\tfor(int T=1,cut;scanf(\"%d%d%d\",&n,&nt,&cut),n;T++){\n\t\trep(u,n){\n\t\t\tG[u].clear();\n\t\t\tterm[u]=false;\n\t\t}\n\n\t\tedge E[9999];\n\t\trep(i,n-1){\n\t\t\tint u,v,cost; scanf(\"%d%d%d\",&u,&v,&cost); u--; v--;\n\t\t\tG[u].push_back((edge){u,v,cost});\n\t\t\tG[v].push_back((edge){v,u,cost});\n\t\t\tE[i]=(edge){u,v,cost};\n\t\t}\n\t\trep(i,nt){\n\t\t\tint u; scanf(\"%d\",&u); u--;\n\t\t\tterm[u]=true;\n\t\t}\n\n\t\tsort(E,E+n-1);\n\n\t\tint ans=0;\n\t\trep(i,n-1){\n\t\t\tif(cut==0) break;\n\t\t\tconst edge &e=E[i];\n\t\t\tif(bfs(e.u,e.v) && bfs(e.v,e.u)){\n\t\t\t\tG[e.u].erase(find(G[e.u].begin(),G[e.u].end(),(edge){e.u,e.v,e.cost}));\n\t\t\t\tG[e.v].erase(find(G[e.v].begin(),G[e.v].end(),(edge){e.v,e.u,e.cost}));\n\t\t\t\tans+=e.cost;\n\t\t\t\tcut--;\n\t\t\t}\n\t\t}\n\n\t\tprintf(\"Case %d: %d\\n\",T,ans);\n\t}\n\n\treturn 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include<bits/stdc++.h>\n#define N 10005\n#define rank raljfds\nusing namespace std;\ntypedef pair<int,int> P;\ntypedef pair<int,P> P2;\n \nclass UF{\npublic:\n  int V;\n  vector<int> par, rank, mil;\n  UF(){}\n  UF(int V):V(V),par(V),rank(V,0),mil(V,-1){for(int i=0;i<V;i++) par[i]=i;}\n \n  int find(int x){\n    assert(x<V);\n    if(par[x]==x) return x;\n    return par[x]=find(par[x]);\n  }\n   \n  void unite(int x,int y){\n    x=find(x), y=find(y);\n    if(x==y)return;\n    if(rank[x]<rank[y]){\n      par[x]=y;\n      if(mil[x]!=-1) mil[y]=mil[x];\n      if(mil[y]!=-1) mil[x]=mil[y];\n    }\n    else{\n      par[y]=x;\n      if(rank[x]<rank[y]) rank[x]++;\n      if(mil[x]!=-1) mil[y]=mil[x];\n      if(mil[y]!=-1) mil[x]=mil[y];\n    }\n  }\n   \n  bool same(int x,int y){return find(x)==find(y);}\n   \n  void add_mil(int num){\n    mil[num]=num;\n  }\n   \n  int get_mil(int x){\n    return mil[par[x]];\n  }\n};\n \nint n,t,k;\nvector<P2> G;\nUF uf;\n \nint solve(){\n   \n  uf=UF(n);\n   \n  int milnum;\n   \n  for(int i=0;i<t;i++){\n \n    cin>>milnum;\n     \n    uf.add_mil(milnum-1);\n  }\n   \n  vector<int> ans;\n   \n  for(int idx=0;idx<G.size();idx++){\n     \n    P2 tmp=G[idx];\n     \n    int cost=G[idx].first;\n    int A=G[idx].second.first;\n    int B=G[idx].second.second;\n \n    if(!(uf.get_mil(A)!=-1&&uf.get_mil(B)!=-1)) uf.unite(A,B);\n    else ans.push_back(cost);\n     \n  }\n \n  sort(ans.begin(),ans.end());\n \n  int res=0;\n  if(ans.size()<k) while(1);\n  for(int i=0;i<k;i++) res+=ans[i];\n   \n  return res;\n}\n \nint main(){\n \n  int T=1;\n   \n  while(1){\n \n    cin>>n>>t>>k;\n    if(!n&&!t&&!k) break;\n \n    int a,b,cost;\n     \n    for(int i=0;i<n-1;i++){\n       \n      cin>>a>>b>>cost;\n       \n      a--, b--;\n \n      G.push_back(P2(cost,P(a,b)));\n    }\n     \n    sort(G.begin(),G.end(),greater<P2>());\n     \n    cout<<\"Case \"<<T<<\": \";\n     \n    cout<<solve()<<endl;\n \n    G.clear();\n     \n    T++;\n  }\n   \n  return 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\nusing namespace std;\n\n#define rep(i, n) for(int i = 0; i < (n); i++)\n#define repp(i, l, r) for(int i = (l); i < (r); i++)\n#define per(i, n) for(int i = ((n)-1); i >= 0; i--)\n#define perr(i, l, r) for(int i = ((r)-1); i >= (l); i--)\n#define all(x) (x).begin(),(x).end()\n#define MOD 1000000007\n#define IINF 1000000000\n#define LINF 1000000000000000000\n#define SP <<\" \"<<\n#define CYES cout<<\"Yes\"<<endl;\n#define CNO cout<<\"No\"<<endl;\n\ntypedef long long LL;\ntypedef long double LD;\n\n\nclass Solver{\nprivate:\n  int n,t,k;\n  vector<vector<pair<int,int>>> e;\n  vector<bool> isb;\n\n  void dfs(int x, int p, vector<vector<int>> &v){\n    v={{{0,IINF}}};\n    vector<vector<int>> tmp;\n    for(auto ed:e[x]){\n      if(ed.first==p) continue;\n      dfs(ed.first,x,tmp);\n      tmp.push_back(vector<int>(2,IINF));\n      int vsz = v.size();\n      int tsz = tmp.size();\n      rep(i,tsz-1){\n        tmp[i+1][0]=min(tmp[i+1][0], tmp[i][1]+ed.second);\n      }\n      vector<vector<int>> nt(min(vsz+tsz-1,k+1),vector<int>(2,IINF));\n      rep(i,vsz){\n        rep(j,tsz){\n          if(i+j>k) break;\n          nt[i+j][0]=min(nt[i+j][0],v[i][0]+tmp[j][0]);\n          nt[i+j][1]=min(nt[i+j][1],v[i][1]+tmp[j][0]);\n          nt[i+j][1]=min(nt[i+j][1],v[i][0]+tmp[j][1]);\n          nt[i+j][1]=min(nt[i+j][1],v[i][1]+tmp[j][1]);\n        }\n      }\n\n      swap(v,nt);\n    }\n    int vsz=v.size();\n    if(isb[x]){\n      rep(i,vsz){\n        v[i][1]=min(v[i][0],v[i][1]);\n        v[i][0]=IINF;\n      }\n    }\n  }\n\npublic:\n  int solve(int nn,int tt,int kk,int cc){\n    n=nn,t=tt,k=kk;\n    e=vector<vector<pair<int,int>>>(n);\n    int u,v,c;\n    rep(i,n-1){\n      cin >> u >> v >> c;\n      u--,v--;\n      e[u].push_back({v,c});\n      e[v].push_back({u,c});\n    }\n    isb = vector<bool>(n);\n    rep(i,t){\n      cin >> u;\n      isb[u-1]=true;\n    }\n    vector<vector<int>> ans;\n    dfs(0,-1,ans);\n    cout << \"Case \" << cc+1 << \": \" << ans[k][1] << endl;\n  }\n};\n\n\n\nint main(){\n  Solver s;\n  for(int c=0;1;c++){\n    int n,t,k;\n    cin >> n >> t >> k;\n    if(n==0) return 0;\n    s.solve(n,t,k,c);\n  }\n  return 0;\n}\n\n"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\n \n#define _overload(_1,_2,_3,name,...) name\n#define _rep(i,n) _range(i,0,n)\n#define _range(i,a,b) for(int i=(int)(a);i<(int)(b);++i)\n#define rep(...) _overload(__VA_ARGS__,_range,_rep,)(__VA_ARGS__)\n \n#define _rrep(i,n) _rrange(i,n,0)\n#define _rrange(i,a,b) for(int i=(int)(a)-1;i>=(int)(b);--i)\n#define rrep(...) _overload(__VA_ARGS__,_rrange,_rrep,)(__VA_ARGS__)\n \n#define _all(arg) begin(arg),end(arg)\n#define uniq(arg) sort(_all(arg)),(arg).erase(unique(_all(arg)),end(arg))\n#define getidx(ary,key) lower_bound(_all(ary),key)-begin(ary)\n#define clr(a,b) memset((a),(b),sizeof(a))\n#define bit(n) (1LL<<(n))\n \n// #define DEBUG\n \n#ifdef DEBUG\n    #define dump(...) fprintf(stderr, __VA_ARGS__)\n#else\n    #define dump(...)\n#endif\n \ntemplate<class T>bool chmax(T &a, const T &b) { return (a<b)?(a=b,1):0;}\ntemplate<class T>bool chmin(T &a, const T &b) { return (b<a)?(a=b,1):0;}\n \nusing namespace std;\nusing ll=long long;\nusing vi=vector<int>;\nusing vll=vector<ll>;\n \nconst double EPS = 1e-10;\nconst double PI = acos(-1.0);\nconst ll inf =1LL << 62;\nconst ll mod=1000000007LL;\nconst int dx[4]={1,0,-1,0};\nconst int dy[4]={0,1,0,-1};\n \n \nll extgcd(ll a,ll b,ll& x,ll& y){x=1,y=0;ll g=a;if(b!=0) g=extgcd(b,a%b,y,x),y-=a/b*x;return g;}\nll ADD(const ll &a, const ll &b,const ll &mod) { return (a+b)%mod;}\nll SUB(const ll &a, const ll &b,const ll &mod) { return (a-b+mod)%mod;}\nll MUL(const ll &a, const ll &b,const ll &mod) { return (1LL*a*b)%mod;}\nll DIV(const ll &a, const ll &b,const ll &mod) {ll x,y; extgcd(b,mod,x,y);return MUL(a,(x+mod)%mod,mod);}\n \nrandom_device rd;\nmt19937 mt(rd());\nuniform_int_distribution<int> dice(1,6);\nuniform_real_distribution<double> score(0.0,10.0);\n\nstruct UnionFind {\n    vector<int> data;\n    UnionFind(int size) : data(size, -1) { }\n    bool unionSet(int x, int y) {\n        x = root(x); y = root(y);\n        if (x != y) {\n            if (data[y] < data[x]) swap(x, y);\n            data[x] += data[y]; data[y] = x;\n        }\n        return x != y;\n    }\n    bool findSet(int x, int y) {\n        return root(x) == root(y);\n    }\n    int root(int x) {\n        return data[x] < 0 ? x : data[x] = root(data[x]);\n    }\n    int size(int x) {\n        return -data[root(x)];\n    }\n};\n\n// (cost, a, b)\nusing Edge = tuple<int, int, int>;\n\nint main(void){\n    int T = 1;\n    for(int n, t, k; cin >> n >> t >> k, n;){\n        vector<Edge> edges(n - 1);\n        ll sum = 0;\n        rep(i, n - 1){\n            int a, b, cost; cin >> a >> b >> cost;\n            a--, b--;\n            edges[i] = Edge(cost, a, b);\n            sum += cost;\n        }\n        sort(_all(edges), greater<Edge>());\n\n        UnionFind uf(n);\n\n        vi has_b(n);\n        rep(i, t){\n            int v; cin >> v; v--;\n            has_b[v] = true;\n        }\n\n        int num_bb = t - 1 - k;\n        int cnt = 0;\n        ll res = sum;\n        rep(i, n - 1){\n            int a, b, cost; tie(cost, a, b) = edges[i];\n            int ra = uf.root(a), rb = uf.root(b);\n            if(ra == rb) continue;\n\n            if(has_b[ra] and has_b[rb]){\n                if(num_bb <= 0) continue;\n                num_bb--;\n            }\n            uf.unionSet(a, b);\n\n            if(has_b[ra] or has_b[rb]){\n                has_b[uf.root(a)] = true;\n            }\n            else {\n                has_b[uf.root(a)] = false;\n            }\n\n            res -= cost;\n\n            cnt++;\n            if(cnt == k) break;\n        }\n\n        cout << \"Case \" << T++ << \": \" << res << endl;\n    }\n\n    return 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\nusing namespace std;\n\nclass union_find {\npublic:\n    union_find(int n) : par(n, -1) {}\n\n    int root(int x) {\n        return par[x] < 0 ? x : par[x] = root(par[x]);\n    }\n\n    void unite(int x, int y) {\n        x = root(x), y = root(y);\n        if(x == y) return;\n        if(par[x] < par[y]) swap(x, y);\n        par[x] += par[y];\n        par[y] = x;\n    }\n\nprivate:\n    vector<int> par;\n};\n\nstruct edge {\n    int u, v, cost;\n    edge(int a, int b, int c) : u(a), v(b), cost(c) {}\n    bool operator<(edge const& e) const {\n        return cost < e.cost;\n    }\n};\n\nint main() {\n    int n, t, k;\n    int test = 1;\n    while(cin >> n >> t >> k, n) {\n        vector<edge> es;\n        for(int i = 0; i < n - 1; ++i) {\n            int a, b, c; cin >> a >> b >> c;\n            es.emplace_back(a - 1, b - 1, c);\n        }\n        sort(rbegin(es), rend(es));\n\n        vector<bool> base(n);\n        for(int i = 0; i < t; ++i) {\n            int x; cin >> x;\n            base[x - 1] = true;\n        }\n\n        union_find uf(n);\n        int region = t;\n        int ans = 0;\n        for(auto const& e : es) {\n            const int u = uf.root(e.u), v = uf.root(e.v);\n            if(base[u] && base[v] && region == k + 1) {\n                ans += e.cost;\n                continue;\n            }\n            uf.unite(u, v);\n            region -= (base[u] && base[v]);\n            base[u] = base[v] = (base[u] || base[v]);\n        }\n\n        cout << \"Case \" << (test++) << \": \" << ans << endl;\n    }\n}\n\n"
  },
  {
    "language": "C++",
    "code": "#include<bits/stdc++.h>\n#define N 10005\n#define rank raljfds\nusing namespace std;\ntypedef pair<int,int> P;\ntypedef pair<int,P> P2;\n\nclass UF{\npublic:\n  int V;\n  vector<int> par, rank, mil;\n  UF(){}\n  UF(int V):V(V),par(V),rank(V,0),mil(V,-1){for(int i=0;i<V;i++) par[i]=i;}\n\n  int find(int x){\n    assert(x<V);\n    if(par[x]==x) return x;\n    return par[x]=find(par[x]);\n  }\n  \n  void unite(int x,int y){\n    x=find(x), y=find(y);\n    if(x==y)return;\n    if(rank[x]<rank[y]){\n      par[x]=y;\n      if(mil[x]!=-1) mil[y]=mil[x];\n      if(mil[y]!=-1) mil[x]=mil[y];\n    }\n    else{\n      par[y]=x;\n      if(rank[x]<rank[y]) rank[x]++;\n      if(mil[x]!=-1) mil[y]=mil[x];\n      if(mil[y]!=-1) mil[x]=mil[y];\n    }\n  }\n  \n  bool same(int x,int y){return find(x)==find(y);}\n  \n  void add_mil(int num){\n    mil[num]=num;\n  }\n  \n  int get_mil(int x){\n    return mil[par[x]];\n  }\n};\n\nint n,t,k;\nvector<P2> G;\nUF uf;\n\nint solve(){\n  \n  uf=UF(n);\n  \n  int milnum;\n  \n  for(int i=0;i<t;i++){\n\n    cin>>milnum;\n    \n    uf.add_mil(milnum-1);\n  }\n  \n  vector<int> ans;\n  \n  for(int idx=0;idx<G.size();idx++){\n    \n    P2 tmp=G[idx];\n    \n    int cost=G[idx].first;\n    int A=G[idx].second.first;\n    int B=G[idx].second.second;\n\n    if(!(uf.get_mil(A)!=-1&&uf.get_mil(B)!=-1)) uf.unite(A,B);\n    else ans.push_back(cost);\n    \n  }\n\n  sort(ans.begin(),ans.end());\n\n  int res=0;\n  \n  for(int i=0;i<k;i++) res+=ans[i];\n  \n  return res;\n}\n\nint main(){\n\n  int T=1;\n  \n  while(1){\n\n    cin>>n>>t>>k;\n    if(!n&&!t&&!k) break;\n\n    int a,b,cost;\n    \n    for(int i=0;i<n-1;i++){\n      \n      cin>>a>>b>>cost;\n      \n      a--, b--;\n\n      G.push_back(P2(cost,P(a,b)));\n    }\n    \n    sort(G.begin(),G.end(),greater<P2>());\n    \n    cout<<\"Case \"<<T<<\": \";\n    \n    cout<<solve()<<endl;\n\n    G.clear();\n    \n    T++;\n  }\n  \n  return 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include<bits/stdc++.h>\n\n#define REP(i,s,n) for(int i=s;i<n;i++)\n#define rep(i,n) REP(i,0,n)\n\nusing namespace std;\n\nstruct Edge {\n  int src,dst,weight; \n  bool operator < ( const Edge &e ) const {\n    return weight < e.weight;\n  }\n};\n\n\n\nconst int MAX = 10010;\nint par[MAX];\nvector<Edge> edges;\n\nvoid init(int _size=MAX) { rep(i,_size) par[i] = i; } \n\nint find(int x) {\n  if( par[x] == x ) return x;\n  return par[x] = find(par[x]);\n}\n\nvoid unit(int x,int y){\n  x = find(x), y = find(y);\n  if( x != y ) par[x] = y;\n}\n\nbool buffer[MAX];\nbool choose[MAX];\n//bool isBase[MAX];\nvector<int> bases;\nint V,t,k;\n\nbool isValid(int index){\n  choose[index] = false;\n  map<int,int> mp;\n  init(V);\n  rep(i,V-1) if( choose[i] ) unit(edges[i].src,edges[i].dst);\n  rep(i,t) ++mp[find(bases[i])];\n  for(map<int,int>::iterator it = mp.begin();it != mp.end();it++){\n    if( it->second == 0 ) return false;\n  }\n  return true;\n}\n\nvoid compute(){\n  sort(edges.begin(),edges.end());\n  rep(i,V) buffer[i] = true;\n  int answer = 0;\n  int remain = k;\n  int cur = 0;\n  while( cur < V && remain ){\n    rep(i,V) choose[i] = buffer[i];\n    if( isValid(cur) ) {\n      --remain;\n      answer += edges[cur].weight;\n      buffer[cur] = false;\n    }\n    ++cur;\n  }\n  printf(\"%d\\n\",answer);\n}\n\nint main(){\n  int CNT = 1;  \n  while( scanf(\"%d %d %d\",&V,&t,&k) , V|t|k ){\n    edges.clear(), bases.clear();\n    rep(i,V-1) {\n      int s,t,c;\n      scanf(\"%d %d %d\",&s,&t,&c);\n      cin >> s >> t >> c;\n      --s, --t;\n      edges.push_back((Edge){s,t,c});\n    }\n    rep(i,t){\n      int base;\n      scanf(\"%d\",&base);\n      --base;\n      bases.push_back(base);\n    }\n    printf(\"Case %d: \",CNT++);\n    compute();\n  }\n  return 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\n#define Nmax 10002\nusing namespace std;\n\nint n,t,k,B[Nmax],fst;\nstruct muchie{\n    int x,y,c;\n};\nvector<muchie> L;\nvector<muchie> :: iterator T;\nvector<int > v[Nmax];\nbool uz[Nmax];\nint gr[Nmax];\n\nint dfs(int nod,int ant)\n{\n    int ok = 0;\n    for (auto it : v[nod])\n    {\n        if (it==ant) continue;\n        if (dfs(it,nod))\n            ok = 1;\n        else\n            gr[nod]--;\n    }\n    if (B[nod]) ok = 1;\n    if (!ok) uz[nod] = 1;\n    return ok;\n}\n\nint dfs2(int nod,int ant)\n{\n    if (B[nod]==1 || gr[nod]>2){\n        gr[nod]--;\n        return 1;\n    }\n    if (!fst) gr[nod]--;\n    fst = 0;\n    for (auto it : v[nod])\n    {\n        if (it==ant) continue;\n        uz[nod] = 1;\n        if (dfs2(it,nod))\n            return 1;\n        else\n            gr[nod]--;\n    }\n    return 0;\n}\n\n\nint main()\n{\n    int nrT = 0;\n    while (cin>>n>>t>>k){\n        nrT++;\n        if (n==0 && k==0 && t==0) return 0;\n        memset(B,0,sizeof(B));\n        memset(gr,0,sizeof(gr));\n        L.clear();\n        for (int i=1;i<=n;i++)\n            v[i].clear();\n        int x,y,c;\n        for (int i=1;i<n;i++){\n            cin>>x>>y>>c;\n            gr[x]++;\n            gr[y]++;\n            v[x].push_back(y);\n            v[y].push_back(x);\n            L.push_back({x,y,c});\n        }\n        int sav;\n        for (int i=1;i<=t;i++){\n            cin>>x;\n            B[x] = 1;\n            sav = x;\n        }\n\n        dfs(sav,-1);\n        int res = 0,mn;\n        for (int i=1;i<=k;i++)\n        {\n            mn = 1e9;\n            int S;\n            for (int j=0;j<L.size();j++){\n                auto it = L[j];\n                if (!uz[it.x] && !uz[it.y]){\n                    if (mn>it.c)\n                    {\n                        mn =it.c;\n                        S = j;\n                    }\n                }\n            }\n            res += mn;\n            fst = 1;\n            dfs2(L[S].x,L[S].y);\n            fst = 1;\n            dfs2(L[S].y,L[S].x);\n            gr[L[S].x]--;\n            gr[L[S].y]--;\n            L[S].c = 1e9;\n        }\n        cout<<\"Case \"<<nrT<<\": \"<<res<<'\\n';\n    }\n    return 0;\n}\n/*\n10 5 4\n1 2 2\n2 3 4\n2 6 3\n6 7 1\n6 8 2\n1 4 5\n4 10 5\n4 9 5\n4 5 5\n1 3 5 7 10\n*/\n\n"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\n#define ll long long\n#define INF 1000000005\n#define MOD 1000000007\n#define EPS 1e-10\n#define rep(i,n) for(int i=0;i<(int)(n);++i)\n#define rrep(i,n) for(int i=(int)(n)-1;i>=0;--i)\n#define srep(i,s,t) for(int i=(int)(s);i<(int)(t);++i)\n#define each(a,b) for(auto& (a): (b))\n#define all(v) (v).begin(),(v).end()\n#define len(v) (int)(v).size()\n#define zip(v) sort(all(v)),v.erase(unique(all(v)),v.end())\n#define cmx(x,y) x=max(x,y)\n#define cmn(x,y) x=min(x,y)\n#define fi first\n#define se second\n#define pb push_back\n#define show(x) cout<<#x<<\" = \"<<(x)<<endl\n#define spair(p) cout<<#p<<\": \"<<p.fi<<\" \"<<p.se<<endl\n#define sar(a,n) cout<<#a<<\":\";rep(kbrni,n)cout<<\" \"<<a[kbrni];cout<<endl\n#define svec(v) cout<<#v<<\":\";rep(kbrni,v.size())cout<<\" \"<<v[kbrni];cout<<endl\n#define svecp(v) cout<<#v<<\":\";each(kbrni,v)cout<<\" {\"<<kbrni.first<<\":\"<<kbrni.second<<\"}\";cout<<endl\n#define sset(s) cout<<#s<<\":\";each(kbrni,s)cout<<\" \"<<kbrni;cout<<endl\n#define smap(m) cout<<#m<<\":\";each(kbrni,m)cout<<\" {\"<<kbrni.first<<\":\"<<kbrni.second<<\"}\";cout<<endl\n\nusing namespace std;\n\ntypedef pair<int,int> P;\ntypedef pair<ll,ll> pll;\ntypedef vector<int> vi;\ntypedef vector<vi> vvi;\ntypedef vector<ll> vl;\ntypedef vector<vl> vvl;\ntypedef vector<double> vd;\ntypedef vector<P> vp;\ntypedef vector<string> vs;\n\nconst int MAX_N = 10005;\n\nstruct edge\n{\n    int to,cost;\n};\n\nvector<edge> G[MAX_N];\nbool ok[MAX_N];\nint sub[MAX_N];\nint n,t,k;\n\nvoid dfs(int u,int p)\n{\n    sub[u] = 1;\n    each(e,G[u]){\n        int v = e.to;\n        if(p != v){\n            dfs(v,u);\n            sub[u] += sub[v];\n        }\n    }\n}\n\nvoid redfs(int u,int p,int** dp)\n{\n    int mx = 1;\n    if(ok[u]){\n        dp[1][1] = 0;\n    }else{\n        dp[0][1] = 0;\n    }\n    each(e,G[u]){\n        cmn(mx,k+1);\n        int v = e.to, c = e.cost;\n        if(p != v){\n            int** res = new int*[2];\n            rep(i,2){\n                res[i] = new int[sub[v]+1];\n            }\n            rep(i,2){\n                rep(j,sub[v]+1){\n                    res[i][j] = INF;\n                }\n            }\n            redfs(v,u,res);\n            vvi dp2(2,vi(mx+sub[v]+1,INF));\n            srep(i,1,mx+1){\n                srep(j,1,sub[v]+1){\n                    if(ok[u]){\n                        cmn(dp2[1][i+j-1],dp[1][i]+res[0][j]);\n                        cmn(dp2[1][i+j-1],dp[1][i]+res[1][j]);\n                        cmn(dp2[1][i+j],dp[1][i]+res[1][j]+c);\n                    }else{\n                        cmn(dp2[0][i+j-1],dp[0][i]+res[0][j]);\n                        cmn(dp2[0][i+j],dp[0][i]+res[1][j]+c);\n                        cmn(dp2[1][i+j-1],dp[0][i]+res[1][j]);\n                        cmn(dp2[1][i+j-1],dp[1][i]+res[0][j]);\n                        cmn(dp2[1][i+j-1],dp[1][i]+res[1][j]);\n                        cmn(dp2[1][i+j],dp[1][i]+res[1][j]+c);\n                    }\n                }\n            }\n            mx += sub[v];\n            rep(i,2){\n                rep(j,mx+1){\n                    dp[i][j] = dp2[i][j];\n                }\n            }\n            rep(i,2){\n                delete res[i];\n            }\n            delete res;\n        }\n    }\n}\n\nint main()\n{\n    cin.tie(0);\n    ios::sync_with_stdio(false);\n    int id = 0;\n    while(1){\n        cin >> n >> t >> k;\n        if(n == 0){\n            break;\n        }\n        rep(i,n){\n            G[i].clear(),ok[i] = false;\n        }\n        rep(i,n-1){\n            int a,b,c;\n            cin >> a >> b >> c;\n            G[a-1].pb((edge){b-1,c}),G[b-1].pb((edge){a-1,c});\n        }\n        rep(i,t){\n            int a;\n            cin >> a;\n            --a;\n            ok[a] = true;\n        }\n        if(k == 0){\n            cout << \"Case \" << ++id << \": 0\" << endl;\n            continue;\n        }\n        dfs(0,-1);\n        int** ans = new int*[2];\n        rep(i,2){\n            ans[i] = new int[sub[0]+1];\n        }\n        rep(i,2){\n            rep(j,sub[0]+1){\n                ans[i][j] = INF;\n            }\n        }\n        redfs(0,-1,ans);\n        cout << \"Case \" << ++id << \": \" << ans[1][k+1] << endl;\n    }\n    return 0;\n}\n\n"
  },
  {
    "language": "C++",
    "code": "\n#include <iostream>\n#include <vector>\n#include <algorithm>\n#include <queue>\n#include <cstring>\n\nusing namespace std;\n\ntypedef pair<int,int> pii;\n\nconst int MAX_V=10001;\nconst int INF=1000000000;\n\n\nclass UnionFindTree{\npublic:\n  // indexの数の親ノード(ある集合の親を見つけたいときはここを直接参照せず、findを使う)\n  vector<int> par;\n  // indexを根とする木のランク\n  vector<int> rank;\n  // 木の最大値\n  int treeSize;\n  vector<bool> isBase;\n  UnionFindTree(int initTreeSize = 1000){\n    // 引数で与えられた値を最大格納数とするUnionFindTreeの作成\n    treeSize = initTreeSize;\n    init();\n  }\n  void init(){\n    for(int i = 0; i < treeSize; i++){\n      par.push_back(i);\n      rank.push_back(0);\n      isBase.push_back(false);\n    }\n  }\n  // 与えられた数が格納されている木のルートを探索\n  int find(int x){  \n    if(par[x]==x)return x;\n    else return par[x] = find(par[x]);\n  }\n  // 和集合をとる。ただしここでは各集合の親の付け替えは起こらない\n  void unite(int x,int y){\n    x = find(x);\n    y = find(y);\n    if(x == y)\n      return;\n    if(rank[x] < rank[y]){\n      par[x] = y;\n      if(isBase[find(x)]||isBase[find(y)])\n\tisBase[find(x)]=true;\n    }\n    else{\n      par[y] = x;\n      if(isBase[find(x)]||isBase[find(y)])\n\tisBase[find(x)]=true;\n      if(rank[y] == rank[x])rank[x]++;\n    }\n  }\n  bool same(int x,int y){\n    return find(x) == find(y);\n  }\n};\n\nstruct edge{\n  int to;\n  int cost;\n  int idx;\n};\n\nvector<edge> G[MAX_V];\nvector<int> bases;\nbool used[MAX_V];\nint n,t,k;\nvoid prim(int V){\n  priority_queue<int> cand;\n  UnionFindTree uft(V+1);\n  for(int i=0;i<MAX_V;i++)used[i]=false;\n  for(int i=0;i<bases.size();i++)uft.isBase[bases[i]]=true;\n  priority_queue<pair<pii,pii> > pq;\n  for(int i=0;i<bases.size();i++){\n    // 次の場所をコストとともに登録\n    for(int j=0;j<G[bases[i]].size();j++){\n      edge &e=G[bases[i]][j];\n      pq.push(make_pair(pii(e.cost,e.idx),pii(e.to,bases[i])));\n    }\n  }\n  while(pq.size()){\n    pair<pii,pii> p=pq.top();pq.pop();\n    int cost=p.first.first;\n    int idx=p.first.second;\n    int node=p.second.first;\n    int from=p.second.second;\n    if(used[idx])continue;\n    used[idx]=true;\n    // 今回のエッジを採用\n    if(uft.isBase[uft.find(from)]\n       &&uft.isBase[uft.find(node)])cand.push(-cost);\n    uft.unite(from,node);\n    // 今回登録したノードからいける場所を登録\n    for(int i=0;i<G[node].size();i++){\n      edge &e=G[node][i];\n      pq.push(make_pair(pii(e.cost,e.idx),pii(e.to,node)));\n    }\n  }\n  int res=0;\n  for(int i=0;i<k;i++){\n    res+=-cand.top();cand.pop();\n  }\n  cout<<res<<endl;\n  cout<<flush;\n}\n\nint main(){\n  int cnt=1;\n  while(cin>>n>>t>>k&&(n|t|k)){\n    for(int i=0;i<MAX_V;i++)G[i].clear();\n    for(int i=0;i<n-1;i++){\n      edge e;\n      int a,b,c;\n      cin>>a>>b>>c;\n      e.to=a;\n      e.cost=c;\n      e.idx=i;\n      G[b].push_back(e);\n      e.to=b;\n      G[a].push_back(e);\n    }\n    bases.clear();\n    for(int i=0;i<t;i++){\n      int a;\n      cin>>a;\n      bases.push_back(a);\n    }\n    cout<<\"Case \"<<cnt<<\": \";\n    prim(n);\n    cnt++;\n  }\n\n  return 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\n#define INF 1000000007\nusing namespace std;\ntypedef long long ll;\ntypedef pair<int,int> P;\n\nstruct diameter{\n\tstatic const int MAX=10000;\n\tvector<int> G[MAX];\n\tint n;\n\tint d[MAX];\n\tbool vis[MAX];\n\tint d2[2][MAX];\n\n\tvoid bfs(int s){\n\t\tfill(d,d+n,INF);\n\t\tqueue<int> que;\n\t\tque.push(s);\n\t\td[s]=0;\n\t\tint v;\n\t\twhile(que.size()){\n\t\t\tv=que.front();\n\t\t\tque.pop();\n\t\t\tfor(int i=0;i<G[v].size();i++){\n\t\t\t\tint e=G[v][i];\n\t\t\t\tif(d[e]==INF){\n\t\t\t\t\td[e]=d[v]+1;\n\t\t\t\t\tque.push(e);\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t}\n\tP diameter_points(int s=0){\n\t\tbfs(s);\n\t\tint maxv=0;\n\t\tint tgt=0;\n\t\tfor(int i=0;i<n;i++){\n\t\t\tif(d[i]==INF)continue;\n\t\t\tif(maxv<d[i]){\n\t\t\t\tmaxv=d[i];\n\t\t\t\ttgt=i;\n\t\t\t}\n\t\t}\n\t\tbfs(tgt);\n\t\tmaxv=0;\n\t\tint v=0;\n\t\tfor(int i=0;i<n;i++){\n\t\t\tif(d[i]==INF)continue;\n\t\t\tif(maxv<d[i]){\n\t\t\t\tmaxv=d[i];\n\t\t\t\tv=i;\n\t\t\t}\n\t\t}\n\t\treturn P(tgt,v);\n\t}\n\tvector<int> middle_points(){\n\t\tP p=diameter_points();\n\t\tbfs(p.first);\n\t\tfor(int i=0;i<n;i++){\n\t\t\td2[0][i]=d[i];\n\t\t}\n\t\tbfs(p.second);\n\t\tfor(int i=0;i<n;i++){\n\t\t\td2[1][i]=d[i];\n\t\t}\n\t\tvector<int> cid;\n\t\tif(d2[0][p.second]%2==0){\n\t\t\tfor(int i=0;i<n;i++){\n\t\t\t\tif(d2[0][p.second]==d2[0][i]*2 && d2[1][p.first]==d2[1][i]*2){\n\t\t\t\t\tcid.push_back(i);\n\t\t\t\t}\n\t\t\t}\n\t\t}else{\n\t\t\tfor(int i=0;i<n;i++){\n\t\t\t\tif(d2[0][p.second]==(d2[0][i]+d2[1][i]) && abs(d2[0][i]-d2[1][i])==1){\n\t\t\t\t\tcid.push_back(i);\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t\treturn cid;\n\t}\n};\n\nstruct edge{\n\tint t,c;\n\tedge(){}\n\tedge(int tt,int cc){\n\t\tt=tt;\n\t\tc=cc;\n\t}\n};\n\ndiameter di;\nvector<edge> G[10001];\nint n,t,k;\nbool flag[10001];\nint siz[10001];\nint* dp[10001][2];\nint tmp[2][10001];\n\nint dfs(int v,int p){\n\tint ans=1;\n\tfor(int i=0;i<G[v].size();i++){\n\t\tint nv=G[v][i].t;\n\t\tif(nv!=p){\n\t\t\tans+=dfs(nv,v);\n\t\t}\n\t}\n\treturn (siz[v]=ans);\n}\n\nvoid func(int v,int p){\n\tfree(dp[v][0]);\n\tfree(dp[v][1]);\n\tdp[v][0]=new int[siz[v]+1];\n\tdp[v][1]=new int[siz[v]+1];\n\tif(flag[v]){\n\t\tdp[v][0][1]=INF;\n\t\tdp[v][1][1]=0;\n\t}\n\telse{\n\t\tdp[v][1][1]=INF;\n\t\tdp[v][0][1]=0;\n\t}\n\tint ns=1;\n\tfor(int i=0;i<G[v].size();i++){\n\t\tint nv=G[v][i].t;\n\t\tint nc=G[v][i].c;\n\t\tif(nv!=p){\n\t\t\tfunc(nv,v);\n\t\t\tfor(int j=0;j<=ns+siz[nv];j++){\n\t\t\t\ttmp[0][j]=INF;\n\t\t\t\ttmp[1][j]=INF;\n\t\t\t}\n\t\t\tfor(int i=1;i<=ns;i++){\n\t\t\t\tfor(int j=1;j<=siz[nv];j++){\n\t\t\t\t\tint l=i+j;\n\t\t\t\t\ttmp[0][l]=min(tmp[0][i+j],dp[v][0][i]+dp[nv][1][j]+nc);\n\t\t\t\t\ttmp[1][l]=min(tmp[1][i+j],dp[v][1][i]+dp[nv][1][j]+nc);\n\t\t\t\t\ttmp[0][l-1]=min(tmp[0][i+j-1],dp[v][0][i]+dp[nv][0][j]);\n\t\t\t\t\ttmp[1][l-1]=min(tmp[1][i+j-1],dp[v][1][i]+dp[nv][0][j]);\n\t\t\t\t\ttmp[1][l-1]=min(tmp[1][i+j-1],dp[v][0][i]+dp[nv][1][j]);\n\t\t\t\t\ttmp[1][l-1]=min(tmp[1][i+j-1],dp[v][1][i]+dp[nv][1][j]);\n\t\t\t\t}\n\t\t\t}\n\t\t\tfor(int j=1;j<=ns+siz[nv];j++){\n\t\t\t\tdp[v][0][j]=tmp[0][j];\n\t\t\t\tdp[v][1][j]=tmp[1][j];\n\t\t\t}\n\t\t\tns+=siz[nv];\n\t\t}\n\t}\n}\n\nvoid solve(){\n\tint root=di.middle_points()[0];\n\tdfs(root,-1);\n\tfunc(root,-1);\n\tint ans=INF;\n\tfor(int i=k+1;i<=n;i++){\n\t\tans=min(ans,dp[root][1][i]);\n\t}\n\tprintf(\"%d\\n\",ans);\n}\n\nint main(void){\n\tint casenum=1;\n\twhile(1){\n\t\tscanf(\"%d%d%d\",&n,&t,&k);\n\t\tif(n==0)break;\n\t\tdi.n=n;\n\t\tmemset(flag,false,sizeof(flag));\n\t\tmemset(siz,false,sizeof(siz));\n\t\tfor(int i=0;i<n;i++){\n\t\t\tG[i].clear();\n\t\t\tdi.G[i].clear();\n\t\t}\n\t\tfor(int i=0;i<n-1;i++){\n\t\t\tint a,b,c;\n\t\t\tscanf(\"%d%d%d\",&a,&b,&c);\n\t\t\ta--;\n\t\t\tb--;\n\t\t\tG[a].push_back(edge(b,c));\n\t\t\tG[b].push_back(edge(a,c));\n\t\t\tdi.G[a].push_back(b);\n\t\t\tdi.G[b].push_back(a);\n\t\t}\n\t\tfor(int i=0;i<t;i++){\n\t\t\tint a;\n\t\t\tscanf(\"%d\",&a);\n\t\t\ta--;\n\t\t\tflag[a]=true;\n\t\t}\n\t\tprintf(\"Case %d: \",casenum++);\n\t\tsolve();\n\t}\n\treturn 0;\n}\n"
  },
  {
    "language": "C++",
    "code": "#include <cstdio>\n#include <cstdlib>\n#include <cmath>\n#include <cstring>\n\n#include <iostream>\n#include <complex>\n#include <string>\n#include <algorithm>\n#include <numeric>\n#include <vector>\n#include <queue>\n#include <stack>\n#include <map>\n#include <set>\n#include <unordered_map>\n#include <unordered_set>\n\n#include <functional>\n#include <cassert>\n\ntypedef long long ll;\nusing namespace std;\n\n#ifndef LOCAL\n#define debug(x) ;\n#else\n#define debug(x) cerr << __LINE__ << \" : \" << #x << \" = \" << (x) << endl;\n\ntemplate <typename T1, typename T2>\nostream &operator<<(ostream &out, const pair<T1, T2> &p) {\n  out << \"{\" << p.first << \", \" << p.second << \"}\";\n  return out;\n}\n\ntemplate <typename T>\nostream &operator<<(ostream &out, const vector<T> &v) {\n  out << '{';\n  for (const T &item : v) out << item << \", \";\n  out << \"\\b\\b}\";\n  return out;\n}\n#endif\n\n#define mod 1000000007 //1e9+7(prime number)\n#define INF 1000000000 //1e9\n#define LLINF 2000000000000000000LL //2e18\n#define SIZE 200010\n\nvector<pair<int,int>> G[SIZE];\nbool base[SIZE];\n\nusing DPVec = vector<vector<int>>;\n\nDPVec dfs(int now, int back = -1, int cost = INF) {\n  DPVec dpL;\n\n  for(auto p : G[now]) {\n    int to = p.first;\n    int dc = p.second;\n\n    if (to == back) continue;\n\n    DPVec dpR = dfs(to, now, dc);\n\n    if (dpL.size() == 0) {\n      swap(dpR, dpL);\n    } else {\n      int L = dpL.size();\n      int R = dpR.size();\n\n      for (int i=1; i<R; i++)\n        dpL.push_back(vector<int>(2, INF));\n\n      for (int i=L-1; i>=0; i--) {\n        for (int j=R-1; j>=0; j--) {\n          dpL[i+j][0] = min(dpL[i+j][0], dpL[i][0] + dpR[j][0]);\n          dpL[i+j][1] = min(dpL[i+j][1], dpL[i][1] + dpR[j][0]);\n          dpL[i+j][1] = min(dpL[i+j][1], dpL[i][0] + dpR[j][1]);\n          dpL[i+j][1] = min(dpL[i+j][1], dpL[i][1] + dpR[j][1]);\n        }\n      }\n    }\n  }\n\n  if (dpL.size() == 0) {\n    dpL.assign(1, vector<int>(2, INF));\n    dpL[0][0] = 0;\n  }\n\n  if (base[now]) {\n    int L = dpL.size();\n    for (int i=0; i<L; i++) {\n      dpL[i][1] = min(dpL[i][1], dpL[i][0]);\n      dpL[i][0] = INF;\n    }\n  }\n\n  int L = dpL.size();\n  dpL.push_back(vector<int>(2, INF));\n  for (int i=0; i<L; i++) {\n    dpL[i+1][0] = min(dpL[i+1][0], dpL[i][1] + cost);\n  }\n\n  return dpL;\n}\n\nint solve() {\n  int N, T, K;\n\n  scanf(\"%d%d%d\", &N, &T, &K);\n\n  if (N == 0) return -1;\n\n  for (int i=0; i<N; i++) {\n    G[i] = vector<pair<int,int>>();\n    base[i] = false;\n  }\n\n  for (int i=0; i<N-1; i++) {\n    int a, b, c;\n    scanf(\"%d%d%d\", &a, &b, &c);\n    a--; b--;\n    G[a].push_back({b, c});\n    G[b].push_back({a, c});\n  }\n\n  for (int i=0; i<T; i++) {\n    int a;\n    scanf(\"%d\", &a);\n    a--;\n    base[a] = true;\n  }\n\n  auto res = dfs(0);\n\n  return res[K][1];\n}\n\n\nint main(){\n  for(int i=1;; i++) {\n   int ans = solve();\n\n   if (ans == -1) break;\n\n   printf(\"Case %d: %d\\n\", i, ans);\n  }\n\n  return 0;\n}\n\n"
  },
  {
    "language": "C++",
    "code": "#include <iostream>\n#include <cstring>\n#include <cstdio>\n#include <algorithm>\n#include <vector>\n#include <cassert>\nusing namespace std;\nconst int Maxn = 10010;\nstruct Road\n{\n\tint x, y, v;\n\tbool operator < (const Road &e) const\n\t{\n\t\treturn v > e.v;\n\t}\n}road[Maxn];\nint n, m, k;\nint root[Maxn];\nint getRoot(int x)\n{\n\tint ret = x;\n\twhile (root[ret] != -1) ret = root[ret];\n\twhile (x != ret)\n\t{\n\t\tint tx = root[x];\n\t\troot[x] = ret;\n\t\tx = tx;\n\t}\n\treturn ret;\n}\nbool flag[Maxn];\nvector<int> vec;\nvoid kruskal()\n{\n\tmemset(root, -1, sizeof(root));\n\tvec.clear();\n\tfor (int i = 0; i < n - 1; ++i)\n\t{\n\t\tint x = getRoot(road[i].x), y = getRoot(road[i].y);\n\t\tassert(x != y);\n\t\t//cout << x <<\" \" << y << \" \" << road[i].v <<\" \" << flag[x] <<\" \" << flag[y]<<endl;\n\t\tif (flag[x] && flag[y]) vec.push_back(road[i].v), root[x] = y;\n\t\telse if(flag[x]) root[y] = x;\n\t\telse if(flag[y]) root[x] = y;\n\t\telse root[x] = y;\n\t}\n}\nint main()\n{\n\tint cas = 1;\n\twhile (scanf(\"%d%d%d\", &n, &m, &k) != EOF)\n\t{\n\t\tif (n == 0) break;\n\t\tprintf(\"Case %d: \", cas++);\n\t\tfor (int i = 0; i + 1 < n; ++i)\n\t\t\tscanf(\"%d%d%d\", &road[i].x, &road[i].y, &road[i].v);\n\t\tsort(road, road + n - 1);\n\t\tmemset(flag, 0, sizeof(flag));\n\t\tfor (int i = 0; i < m; ++i)\n\t\t{\n\t\t\tint x;\n\t\t\tscanf(\"%d\", &x);\n\t\t\tflag[x] = 1;\n\t\t}\n\t\tkruskal();\n\t\tint ans = 0;\n\t\tassert(vec.size() >= k); \n\t\tfor (int i = 1; i <= k; ++i)\n\t\t\tans += vec[vec.size() - i];\n\t\tprintf(\"%d\\n\", ans);\n\t}\n\treturn 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include<bits/stdc++.h>\nusing namespace std;\ntypedef pair<int,int> pii;\n\nint costs[10001];\n\nint main(){\n  int n,t,k,case_num = 0;\n  while(scanf(\"%d%d%d\",&n,&t,&k), n){\n    case_num++;\n\n    memset(costs,0,sizeof(costs));\n    vector< vector<pii> > tree(n);\n\n    for(int i=0;i<n-1;i++){\n      int a,b,c;\n      scanf(\"%d%d%d\",&a,&b,&c);\n      a--; b--;\n      tree[a].push_back(pii(c,b));\n      tree[b].push_back(pii(c,a));\n      costs[c]++;\n    }\n\n    vector<int> base(t), use(n,0);\n    for(int i=0;i<t;i++){\n      scanf(\"%d\",&base[i]);\n      base[i]--;\n      use[base[i]] = 1;\n    }\n\n    priority_queue<pii> q;\n    for(int v : base){\n      for(pii u : tree[v]){\n\tif(!use[u.second])q.push(u);\n      }\n    }\n\n    while(q.size()){\n      pii p = q.top(); q.pop();\n      if(use[p.second])continue;\n      use[p.second] = 1;\n      costs[p.first]--;\n\n      for(pii u : tree[p.second]){\n\tif(!use[u.second])q.push(u);\n      }\n    }\n\n    int p = 0;\n    int res = 0;\n    while(k){\n      int r = min(k,costs[p]);\n      res += p*r; k-=r; p++;\n    }\n    printf(\"Case %d: %d\\n\",case_num, res);\n  }\n}"
  },
  {
    "language": "C++",
    "code": "#include<bits/stdc++.h>\nusing namespace std;\n \nstruct edge{\n  int a,b,c;\n  bool operator<(const edge &e) const{\n    return c < e.c;\n  }\n};\ntypedef long long ll;\n \nstruct uni{\n  int d[100003];\n  int f[100003];\n  void init(){ memset(d,-1,sizeof(d)); memset(f,0,sizeof(f)); }\n  int find(int a){ return d[a]<0?a:(d[a]=find(d[a])); }\n  void marge(int a,int b){\n    a = find(a); b = find(b);\n    if( a == b ) return ;\n    if( d[a] > d[b] ) swap(a,b);\n    if( f[a] || f[b] ) f[a] = 1;\n    d[a]+=d[b]; d[b] = a;\n  }\n  bool same(int a,int b){\n    return find(a) == find(b);\n  }\n  int size(int a){\n    return -d[find(a)];\n  }\n  bool isbase(int a){ return f[find(a)]; }\n};\n \nint N,T,K;\nuni U;\n \nint main(){\n  int ttt =0;\n  while( cin >> N >> T >> K && (N||T||K) ){\n \n    U.init();\n    ll sum = 0;\n    vector<edge> E;\n    vector<edge> E2;\n    for(int i=0;i<N-1;i++){\n      int a,b,c;\n      cin >> a >> b >> c;\n      E.push_back( (edge){a,b,c} );\n      sum += c;\n    }\n    for(int i=0;i<T;i++){\n      int a; cin >> a;\n      U.f[a] = 1;\n    }\n    for(int i=0;i<N-1;i++){\n      if( !U.isbase(E[i].a) || !U.isbase(E[i].b) ) E2.push_back(E[i]);\n    }\n    ll res = 0;\n    sort(E2.rbegin(),E2.rend());\n    int ks = 0;\n    for(int i=0;i<(int)E2.size();i++){\n      int a = E2[i].a, b = E2[i].b, c = E2[i].c;\n      if( U.same(a,b) ) continue;\n      if( !U.isbase(a) || !U.isbase(b) ){\n    U.marge(a,b);\n    res += (ll)c;\n    ks++;\n      }\n    }\n    //  cout << ks << endl;\n    //cout << N-K-1 << endl;\n    assert(N-K-1>=ks);\n    sort(E.rbegin(),E.rend());\n    for(int i=0;N-K-1>ks;i++){\n      if( U.same(E[i].a,E[i].b) ) continue;\n      U.marge(E[i].a,E[i].b);\n      res += (ll)E[i].c;\n      ks++;\n    }\n    // cout << N - K - 1<< endl;\n    //cout << ks << endl;\n    cout << \"Case \" << ++ttt << \": \" << sum - res << endl;\n  }\n}"
  },
  {
    "language": "C++",
    "code": "#include <iostream>\n#include <cstdio>\n#include <vector>\n#include <set>\n#include <map>\n#include <queue>\n#include <deque>\n#include <stack>\n#include <algorithm>\n#include <cstring>\n#include <functional>\n#include <cmath>\nusing namespace std;\n#define rep(i,n) for(int i=0;i<(n);++i)\n#define rep1(i,n) for(int i=1;i<=(n);++i)\n#define all(c) (c).begin(),(c).end()\n#define fs first\n#define sc second\n#define pb push_back\n#define show(x) cout << #x << \" \" << x << endl\nstruct edge{int from,to,cost;};\nbool operator<(const edge& x,const edge& y){\n\treturn x.cost>y.cost;\n}\nint par[10000],id[10000];\nvoid init(int n){\n\trep(i,n) par[i]=i;\n\trep(i,n) id[i]=-1;\n}\nint find(int x){\n\tif(x==par[x]) return x;\n\telse par[x]=find(par[x]);\n}\nvoid unite(int x,int y){\n\tx=find(x),y=find(y);\n\tif(id[x]>=0) par[y]=x;\n\telse par[x]=y;\n}\nvector<edge> es;\nint main(){\n\tint tt=0;\n\twhile(true){\n\t\ttt++;\n\t\tint n,t,k;\n\t\tcin>>n>>t>>k;\n\t\tif(n==0) break;\n\t\tes.clear();\n\t\tinit(n);\n\t\trep(i,n-1){\n\t\t\tint a,b,c;\n\t\t\tcin>>a>>b>>c;\n\t\t\tes.pb(edge{a-1,b-1,c});\n\t\t}\n\t\trep(i,t){\n\t\t\tint x;\n\t\t\tcin>>x;\n\t\t\tid[x-1]=x-1;\n\t\t}\n\t\tsort(all(es));\n\t\tvector<int> costs;\n\t\trep(i,n-1){\n\t\t\tint a=es[i].from,b=es[i].to,c=es[i].cost;\n\t\t\ta=find(a),b=find(b);\n\t\t\tif(id[a]>=0&&id[b]>=0) costs.pb(c);\n\t\t\telse unite(a,b);\n\t\t}\n\t\tsort(all(costs));\n\t\tint sum=0;\n\t\trep(i,k) sum+=costs[i];\n\t\tprintf(\"Case %d: %d\\n\",tt,sum);\n\t}\n}"
  },
  {
    "language": "C++",
    "code": "#include<bits/stdc++.h>\n\nusing namespace std;\n\nstruct edge\n{\n  int to, cost;\n};\n\ntypedef pair< int, int > Pi;\n\nint main()\n{\n  int N, T, K;\n  int A[10000], B[10000], C[10000];\n  int testcase = 1;\n\n  while(scanf(\"%d %d %d\", &N, &T, &K), N) {\n\n    vector< edge > g[10000];\n    int deg[10000] = {};\n    bool M[10000] = {};\n    priority_queue< Pi, vector< Pi >, greater<> > que;\n\n    for(int i = 1; i < N; i++) {\n      scanf(\"%d %d %d\", &A[i], &B[i], &C[i]);\n      --A[i], --B[i];\n      g[A[i]].emplace_back((edge) {B[i], C[i]});\n      g[B[i]].emplace_back((edge) {A[i], C[i]});\n      ++deg[A[i]];\n      ++deg[B[i]];\n      que.emplace(C[i], i);\n    }\n\n    for(int i = 0; i < T; i++) {\n      int x;\n      scanf(\"%d\", &x);\n      --x;\n      M[x] = true;\n    }\n\n    queue< int > beet;\n    bool live[10000];\n    for(int i = 0; i < N; i++) {\n      if(deg[i] == 1) {\n        deg[i]--;\n        beet.emplace(i);\n      }\n      live[i] = true;\n    }\n\n    auto update = [&]()\n    {\n      while(!beet.empty()) {\n        int p = beet.front();\n        beet.pop();\n        if(M[p]) continue;\n        live[p] = false;\n        for(auto &e : g[p]) {\n          if(live[e.to]) {\n            deg[e.to]--;\n            if(deg[e.to] == 0) beet.emplace(e.to);\n          }\n        }\n      }\n    };\n\n    int ret = 0;\n    for(int i = 0; i < K; i++) {\n      update();\n      while(!que.empty()) {\n        int cost, idx;\n        tie(cost, idx) = que.top();\n        que.pop();\n        if(!live[A[idx]] || !live[B[idx]]) continue;\n        ret += cost;\n        --deg[A[idx]];\n        --deg[B[idx]];\n        if(deg[A[idx]] == 1) beet.emplace(A[idx]);\n        if(deg[B[idx]] == 1) beet.emplace(B[idx]);\n        break;\n      }\n    }\n\n    printf(\"Case %d: %d\\n\", testcase++, ret);\n  }\n}"
  },
  {
    "language": "C++",
    "code": "#include <iostream>\n#include <vector>\n#include <map>\n#include <algorithm>\nusing namespace std;\n\nconst int MAX_V = 100000;\ntypedef pair<int,int> P;\nstruct edge{ int to,cost; };\n\n// グラフ (隣接リスト)\nvector<edge> G[MAX_V];\n// e = (u,v) , is_cost[e] := コスト\nmap<P,int> is_cost;\n// base[u] == true のとき ノード u は ベース\nbool base[MAX_V];\n// (cost,(u,v))の組\nvector< pair<int ,P> > a;\n// used[u] == true のとき ノード u は探索済み\nbool used[MAX_V];\n\nint n, t, k;\n\n\n// 初期化\nvoid init(){\n\ta.clear();\n\tis_cost.clear();\n\tfor(int i=0 ; i < MAX_V ; i++ ){\n\t\tbase[i] = false;\n\t\tG[i].clear();\n\t}\n}\n\n// グラフに重みcostのエッジ(u,v)を追加\nvoid add_edge(int u, int v, int cost){\n\tedge e;\n\te.to = v;\n\te.cost = cost;\n\tG[u].push_back( e );\n\te.to = u;\n\tG[v].push_back( e );\n}\n\n// グラフのエッジ(u,v)を切断\nvoid cut_edge(int u, int v){\n\tfor(vector<edge>::iterator it = G[u].begin() ; it != G[u].end() ; ++it ){\n\t\tif( (*it).to == v ){\n\t\t\tG[u].erase( it );\n\t\t\treturn ;\n\t\t}\n\t}\n}\n\n\n// ノード u の木にベースがあるかどうか\nvoid is_base(int u, bool& flag){\n\t// ノード u がベースのとき\n\tif( base[u] ){\n\t\tflag = true;\n\t\treturn;\n\t}\n\t// ノード u が探索済みのとき\n\tif( used[u] ) return;\n\tused[u] = true;\n\t\n\tfor(int i=0 ; i < G[u].size() ; i++ ){\n\t\tedge e = G[u][i];\n\t\tis_base( e.to , flag );\n\t}\n}\n\nint solve(){\n\t\n\t// 連結成分の数\n\tint p=1;\n\t// コストの総和\n\tint sum = 0;\n\t\n\tsort( a.begin() , a.end() );\n\tfor(int i=0 ; i < a.size() ; i++ ){\n\t\tint cost = a[i].first;\n\t\tint u = a[i].second.first;\n\t\tint v = a[i].second.second;\n\t\tif( u > v ) swap(u,v);\n\t\t\n\t\tcut_edge( u , v );\n\t\t\n\t\tbool flag1 = false, flag2 = false;\n\t\tfor(int j=0 ; j < n ; j++ ) used[j] = false;\n\t\tis_base( u , flag1 );\n\t\tfor(int j=0 ; j < n ; j++ ) used[j] = false;\n\t\tis_base( v , flag2 );\n\t\t\n\t\t// u,vの木の両方にベースを含むとき切断する\n\t\tif( flag1 && flag2 ){\n\t\t\tsum += is_cost[P(u,v)];\n\t\t\tp++;\n\t\t}else{\n\t\t\tadd_edge( u , v , is_cost[P(u,v)] );\n\t\t}\n\t\t\n\t\t// 連結成分が K+1 個になったらループを抜ける\n\t\tif( p == k+1 ) break;\n\t}\n\treturn sum;\n}\n\nint main(){\n\tfor(int t_ = 1 ; cin >> n >> t >> k , (n || t || k) ; t_++ ){\n\t\t// 初期化\n\t\tinit();\n\t\t\n\t\tfor(int i = 0 ; i < n-1 ; i++ ){\n\t\t\tint u, v, cost;\n\t\t\tcin >> u >> v >> cost;\n\t\t\tu--; v--;\n\t\t\tif( u > v ) swap(u,v);\n\t\t\t\n\t\t\tis_cost[P(u,v)] = cost;\n\t\t\tadd_edge( u , v , cost );\n\t\t\tpair<int,P> p( cost , P(u,v) );\n\t\t\ta.push_back( p );\n\t\t}\n\t\tfor(int i = 0 ; i < t ; i++ ){\n\t\t\tint b;\n\t\t\tcin >> b;\n\t\t\tb--;\n\t\t\tbase[b] = true;\n\t\t}\n\t\t\n\t\tint ans = solve();\n\t\tcout << \"Case \" << t_ << \": \" << ans << endl;\n\t}\n}"
  },
  {
    "language": "C++",
    "code": "#include<bits/stdc++.h>\nusing namespace std;\n\nstruct edge{\n  int a,b,c;\n  bool operator<(const edge &e) const{\n    return c < e.c;\n  }\n};\ntypedef long long ll;\n\nstruct uni{\n  int d[100003];\n  void init(){ memset(d,-1,sizeof(d)); }\n  int find(int a){ return d[a]<0?a:(d[a]=find(d[a])); }\n  void marge(int a,int b){\n    a = find(a); b = find(b);\n    if( a == b ) return ;\n    if( d[a] > d[b] ) swap(a,b);\n    d[a]+=d[b]; d[b] = a; \n  }\n  bool same(int a,int b){\n    return find(a) == find(b);\n  }\n  int size(int a){\n    return -d[find(a)];\n  }\n};\n\nint N,T,K;\nint F[100003];\nuni U;\n\nint main(){\n  int ttt =0;\n  while( cin >> N >> T >> K && (N||T||K) ){\n    memset(F,0,sizeof(F));\n    U.init();\n    ll sum = 0;\n    vector<edge> E;\n    vector<edge> E2;\n    for(int i=0;i<N-1;i++){\n      int a,b,c;\n      cin >> a >> b >> c;\n      E.push_back( (edge){a,b,c} );\n      sum += c;\n    }\n    for(int i=0;i<T;i++){\n      int a; cin >> a;\n      F[a] = 1;\n    }\n    for(int i=0;i<N-1;i++){\n      if( F[E[i].a] == 0 || F[E[i].b] == 0 ) E2.push_back(E[i]);\n    }\n    ll res = 0;\n    sort(E2.rbegin(),E2.rend());\n    int ks = 0;\n    for(int i=0;i<(int)E2.size();i++){\n      int a = E2[i].a, b = E2[i].b, c = E2[i].c;\n      if( U.same(a,b) ) continue;\n      //   cout  << a << \" \"<< b << \" \" << F[a] << \" \"<< F[b] << endl;\n      if( (!F[a] && !F[U.find(a)]) || (!F[b] && !F[U.find(b)]) ){\n\tU.marge(a,b);\n\tif( F[U.find(a)] || F[a] == 1 || F[b] == 1){\n\t  F[a] = 1;\n\t  F[b] = 1;\n\t  F[U.find(a)] = 1;\n\t}\n\tres += (ll)c;\n\tks++;\n      }\n    }\n    // cout << ks << endl;\n    sort(E.rbegin(),E.rend());\n    for(int i=0;N-K-1>ks;i++){\n      if( U.same(E[i].a,E[i].b) ) continue;\n      U.marge(E[i].a,E[i].b);\n      res += (ll)E[i].c;\n      ks++;\n    }\n    // cout << N - K - 1<< endl;\n    //cout << ks << endl;\n    cout << \"Case \" << ++ttt << \": \" << sum - res << endl;\n  }\n}"
  },
  {
    "language": "C++",
    "code": "#include <iostream>\n#include <cstdio>\n#include <vector>\n#include <set>\n#include <map>\n#include <queue>\n#include <deque>\n#include <stack>\n#include <algorithm>\n#include <cstring>\n#include <functional>\n#include <cmath>\nusing namespace std;\n#define rep(i,n) for(int i=0;i<(n);++i)\n#define rep1(i,n) for(int i=1;i<=(n);++i)\n#define all(c) (c).begin(),(c).end()\n#define fs first\n#define sc second\n#define pb push_back\n#define show(x) cout << #x << \" \" << x << endl\nstruct edge{int from,to,cost;};\nbool operator<(const edge& x,const edge& y){\n\treturn x.cost>y.cost;\n}\nint par[20000],id[20000];\nvoid init(int n){\n\trep(i,n) par[i]=i;\n\trep(i,n) id[i]=-1;\n}\nint find(int x){\n\tif(x==par[x]) return x;\n\telse par[x]=find(par[x]);\n}\nvoid unite(int x,int y){\n\tx=find(x),y=find(y);\n\tif(id[x]>=0) par[y]=x;\n\telse par[x]=y;\n}\nvector<edge> es;\nvector<int> costs;\nint main(){\n\tint tt=0;\n\twhile(true){\n\t\ttt++;\n\t\tint n,t,k;\n\t\tcin>>n>>t>>k;\n\t\tif(n==0) break;\n\t\tes.clear();\n\t\tinit(n);\n\t\trep(i,n-1){\n\t\t\tint a,b,c;\n\t\t\tcin>>a>>b>>c;\n\t\t\tes.pb(edge{a-1,b-1,c});\n\t\t}\n\t\trep(i,t){\n\t\t\tint x;\n\t\t\tcin>>x;\n\t\t\tid[x-1]=x-1;\n\t\t}\n\t\tsort(all(es));\n\t\tcosts.clear();\n\t\trep(i,n-1){\n\t\t\tint a=es[i].from,b=es[i].to,c=es[i].cost;\n\t\t\ta=find(a),b=find(b);\n\t\t\tif(id[a]>=0&&id[b]>=0) costs.pb(c);\n\t\t\telse unite(a,b);\n\t\t}\n\t\tsort(all(costs));\n//\t\tshow(costs.size());\n\t\tint sum=0;\n\t\trep(i,k) sum+=costs[i];\n\t\tprintf(\"Case %d: %d\\n\",tt,sum);\n\t}\n}"
  },
  {
    "language": "C++",
    "code": "#include<bits/stdc++.h>\nusing namespace std;\n\nstruct edge{\n  int a,b,c;\n  bool operator<(const edge &e) const{\n    return c < e.c;\n  }\n};\ntypedef long long ll;\n\nstruct uni{\n  int d[100003];\n  void init(){ memset(d,-1,sizeof(d)); }\n  int find(int a){ return d[a]<0?a:(d[a]=find(d[a])); }\n  void marge(int a,int b){\n    a = find(a); b = find(b);\n    if( a == b ) return ;\n    if( d[a] > d[b] ) swap(a,b);\n    d[a]+=d[b]; d[b] = a; \n  }\n  bool same(int a,int b){\n    return find(a) == find(b);\n  }\n  int size(int a){\n    return -d[find(a)];\n  }\n};\n\nint N,T,K;\nint F[100003];\nuni U;\n\nint main(){\n  int ttt =0;\n  while( cin >> N >> T >> K && (N||T||K) ){\n    memset(F,0,sizeof(F));\n    U.init();\n    ll sum = 0;\n    vector<edge> E;\n    vector<edge> E2;\n    for(int i=0;i<N-1;i++){\n      int a,b,c;\n      cin >> a >> b >> c;\n      E.push_back( (edge){a,b,c} );\n      sum += c;\n    }\n    for(int i=0;i<T;i++){\n      int a; cin >> a;\n      F[a] = 1;\n    }\n    for(int i=0;i<N-1;i++){\n      if( F[E[i].a] == 0 || F[E[i].b] == 0 ) E2.push_back(E[i]);\n    }\n    ll res = 0;\n    sort(E2.rbegin(),E2.rend());\n    int ks = 0;\n    for(int i=0;i<(int)E2.size();i++){\n      int a = E2[i].a, b = E2[i].b, c = E2[i].c;\n      if( U.same(a,b) ) continue;\n      //   cout  << a << \" \"<< b << \" \" << F[a] << \" \"<< F[b] << endl;\n      if( F[a] == 0 || F[b] == 0 ){\n\tU.marge(a,b);\n\tif( F[U.find(a)] || F[a] == 1 || F[b] == 1){\n\t  F[a] = 1;\n\t  F[b] = 1;\n\t}\n\tres += (ll)c;\n\tks++;\n      }\n    }\n    // cout << ks << endl;\n    sort(E.rbegin(),E.rend());\n    for(int i=0;N-K-1>ks;i++){\n      if( U.same(E[i].a,E[i].b) ) continue;\n      U.marge(E[i].a,E[i].b);\n      res += (ll)E[i].c;\n      ks++;\n    }\n    // cout << N - K - 1<< endl;\n    //cout << ks << endl;\n    cout << \"Case \" << ++ttt << \": \" << sum - res << endl;\n  }\n}"
  },
  {
    "language": "C++",
    "code": "#include<bits/stdc++.h>\nusing namespace std;\ntypedef pair<int,int> pii;\n\nint main(){\n  cin.tie(0); ios::sync_with_stdio(0);\n\n  int n,t,k,case_num = 0;\n  while(cin >> n >> t >> k, n){\n    case_num++;\n\n    map<int,int> costs;\n    vector< vector<pii> > tree(n);\n\n    for(int i=0;i<n-1;i++){\n      int a,b,c;\n      cin >> a >> b >> c;\n      a--; b--;\n      tree[a].push_back(pii(c,b));\n      tree[b].push_back(pii(c,a));\n      costs[c]++;\n    }\n\n    vector<int> base(t), use(n,0);\n    for(int i=0;i<t;i++){\n      cin >> base[i];\n      base[i]--;\n      use[base[i]] = 1;\n    }\n\n    priority_queue<pii> q;\n    for(int v : base){\n      for(pii u : tree[v]){\n\tif(!use[u.second])q.push(u);\n      }\n    }\n\n    while(q.size()){\n      pii p = q.top(); q.pop();\n      if(use[p.second])continue;\n      use[p.second] = 1;\n      costs[p.first]--;\n\n      for(pii u : tree[p.second]){\n\tif(!use[u.second])q.push(u);\n      }\n    }\n\n    long long res = 0;\n    auto it = costs.begin();\n    while(k){\n      while(k && it->second){\n\tit->second--; k--;\n\tres += it->first;\n      }\n      it++;\n    }\n    cout << \"Case \" << case_num << \": \" << res << endl;\n  }\n}"
  },
  {
    "language": "C++",
    "code": "#include <iostream>\n#include <cstdio>\n#include <algorithm>\n#include <vector>\n#include <string>\n#include <set>\n#include <map>\n#include <queue>\n#include <cmath>\n \nusing namespace std;\n \n#define rep(i,n) for(int i = 0; i<n ; i++)\n#define FOR(i,a,n) for(int i=a; i<n; i++)\n \n#define RANGE(a,i,b) ((a)<=(i)&&(i)<=(b))\n \n#define pb push_back\n#define mp make_pair\n \n#define ALL(a) (a).begin(), (a).end()\n \n#define SET(a,c) memset(a,c,sizeof(a))\n#define CLR(a) memset(a,0,sizeof(a))\n \n#define INF 1001001001\n#define LLINF 1001001001001001001LL\n \ntypedef long long ll;\ntypedef pair<int,int> PII;\ntypedef vector<int> VI;\n \n#define PQ priority_queue\n \n#define FST first\n#define SEC second\n#define int long long\n \nint dx[4]={1,0,-1,0};\nint dy[4]={0,1,0,-1};\n \n//------------------HEAD---------------------\nstruct edge{\n    int u, v, cost;\n    bool operator < (const edge& e){\n        return cost > e.cost; // 逆順ソート\n    }\n};\n\n// 更地から構築していく。コスト高い辺から置いていく。\n// 最終的に基地がk+1箇所に分断されていればok\n\nint par[11234];\nint rank_[11234];\nint n,t,k;\nvoid init(){\n    rep(i,n){\n        par[i]=i;\n        rank_[i]=0;\n    }\n}\n\nint find(int x){\n    if(par[x]==x) return x;\n    else return par[x]=find(par[x]);\n}\n\nvoid unite(int x, int y){\n    x=find(x);\n    y=find(y);\n    if(x==y)return;\n    if(rank_[x]<rank_[y]){\n        par[x]=y;\n    }else{\n        par[y]=x;\n        if(rank_[x]==rank_[y])++rank_[x];\n    }\n}\n\nbool same(int x,int y){\n    return find(x)==find(y);\n}\n\n\nedge E[11234];\nbool isbase[11234];\n\nsigned main(void){\n    int i=0;\n    while(1){\n        i+=1;\n    cin>>n>>t>>k;init();\n    //cerr<<n<<t<<k<<endl;\n    if(!(n||t||k))break;\n    rep(i,n-1){\n        cin>>E[i].u>>E[i].v>>E[i].cost;\n        --E[i].u;--E[i].v;\n    }\n    sort(E,E+n-1);\n    rep(i,n)isbase[i]=false;\n    rep(i,t){\n        int tmp;cin>>tmp;\n        isbase[tmp-1]=true;\n    }\n    int ans=0;\n    rep(i, n-1){\n        edge e=E[i];\n        int u,v;\n        u=find(e.u);\n        v=find(e.v);\n        //cerr<<u<<isbase[u]<<v<<isbase[v]<<endl;\n        if(isbase[u]&&isbase[v]){\n            if(t>k+1){\n                unite(u,v);\n                --t;//cerr<<t<<endl;\n            }else{\n                ans+=e.cost;\n            }\n        }else{\n            unite(u,v);\n            isbase[u]=isbase[v]=isbase[u]||isbase[v];\n        }\n        \n    }\n    \n    printf(\"Case %lld: %lld\\n\", i, ans);\n    }\n    return 0;\n}\n"
  },
  {
    "language": "C++",
    "code": "#include<bits/stdc++.h>\n\nusing namespace std;\n\nstruct edge\n{\n  int to, cost;\n};\n\ntypedef pair< int, int > Pi;\n\nint main()\n{\n  int N, T, K;\n  int A[10000], B[10000], C[10000];\n  int testcase = 1;\n\n  while(scanf(\"%d %d %d\", &N, &T, &K), N) {\n\n    vector< edge > g[10000];\n    int deg[10000] = {};\n    bool M[10000] = {};\n    priority_queue< Pi, vector< Pi >, greater<> > que;\n\n    for(int i = 1; i < N; i++) {\n      scanf(\"%d %d %d\", &A[i], &B[i], &C[i]);\n      --A[i], --B[i];\n      g[A[i]].emplace_back((edge) {B[i], C[i]});\n      g[B[i]].emplace_back((edge) {A[i], C[i]});\n      ++deg[A[i]];\n      ++deg[B[i]];\n      que.emplace(C[i], i);\n    }\n\n    for(int i = 0; i < T; i++) {\n      int x;\n      scanf(\"%d\", &x);\n      --x;\n      M[x] = true;\n    }\n\n    queue< int > beet;\n    bool live[10000];\n    for(int i = 0; i < N; i++) {\n      if(deg[i] == 1) {\n        deg[i]--;\n        beet.emplace(i);\n      }\n      live[i] = true;\n    }\n\n    auto update = [&]()\n    {\n      while(!beet.empty()) {\n        int p = beet.front();\n        beet.pop();\n        if(M[p]) continue;\n        live[p] = false;\n        for(auto &e : g[p]) {\n          if(live[e.to]) {\n            deg[e.to]--;\n            if(deg[e.to] == 0) beet.emplace(e.to);\n          }\n        }\n      }\n    };\n\n    int ret = 0;\n    for(int i = 0; i < K; i++) {\n      update();\n      while(!que.empty()) {\n        int cost, idx;\n        tie(cost, idx) = que.top();\n        que.pop();\n        if(!live[A[idx]] || !live[B[idx]]) continue;\n        ret += cost;\n        --deg[A[idx]];\n        --deg[B[idx]];\n        if(deg[A[idx]] == 1) beet.emplace(A[idx]);\n        if(deg[B[idx]] == 1) beet.emplace(B[idx]);\n        break;\n      }\n    }\n\n    printf(\"Case %d: %d\\n\", testcase++, ret);\n  }\n}"
  },
  {
    "language": "C++",
    "code": "#include<bits/stdc++.h>\nusing namespace std;\n\nstruct unionfind{\n  int parent[200000];\n  int size[200000];\n  \n  void init(int n){\n    for(int i=0;i<n;i++){\n      parent[i]=i;\n      size[i]=1;\n    }\n  }\n  int find(int x){\n    if(parent[x]==x)return x;\n    else parent[x]=find(parent[x]);\n  }\n  bool same(int x,int y){\n    return (find(x)==find(y));\n  }\n  int getSize(int x){\n    return size[ find(x) ];\n  }\n  void unite(int x,int y){\n    x=find(x);\n    y=find(y);\n    if(x==y)return;\n    if(size[x]>size[y])swap(x,y);\n    parent[x]=y;\n    size[y]+=size[x];\n  }\n};\n  \nstruct edge{\n  int from,to,cost;\n  bool operator < (const edge &e) const {\n    return cost < e.cost;\n  }\n};\n\nint n,t,k;\nunionfind uf;\n\nint main(){\n\n  \n  for(int tc=1;;tc++){\n    cin>>n>>t>>k;\n    if(n==0&&t==0&&k==0)break;\n    vector<edge> E;\n\n    uf.init(n);\n    \n    for(int i=0;i<n-1;i++){\n      int a,b,c;\n      cin>>a>>b>>c;\n      a--,b--;\n      E.push_back( (edge){a,b,-c} );\n      uf.unite(a,b);\n    }\n    //    assert( uf.getSize(0) == n );\n    \n    for(int i=0;i<t;i++){\n      int a;\n      cin>>a;\n      a--;\n      E.push_back( (edge){a,n,-20000} );\n    }\n    sort(E.begin(),E.end());\n    \n    uf.init(n+1);\n\n    vector<edge> tmp;\n    \n    for(int i=0;i<(int)E.size();i++){\n      edge e=E[i];\n      if( uf.same(e.from,e.to) ){\n        tmp.push_back(e);\n      }else{\n        uf.unite(e.from,e.to);\n      }\n    }\n\n    int ans=0;\n    //    assert( (int)tmp.size() == t-1 );\n    \n    \n    for(int i=t-1-k;i<(int)tmp.size();i++){\n      ans-=tmp[i].cost;\n    }\n    cout<<\"Case \"<<tc<<\": \"<<ans<<endl;\n    \n  }\n  return 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\n#define ll long long\n#define INF 1000000005\n#define MOD 1000000007\n#define EPS 1e-10\n#define rep(i,n) for(int i=0;i<(int)(n);++i)\n#define rrep(i,n) for(int i=(int)(n)-1;i>=0;--i)\n#define srep(i,s,t) for(int i=(int)(s);i<(int)(t);++i)\n#define each(a,b) for(auto& (a): (b))\n#define all(v) (v).begin(),(v).end()\n#define len(v) (int)(v).size()\n#define zip(v) sort(all(v)),v.erase(unique(all(v)),v.end())\n#define cmx(x,y) x=max(x,y)\n#define cmn(x,y) x=min(x,y)\n#define fi first\n#define se second\n#define pb push_back\n#define show(x) cout<<#x<<\" = \"<<(x)<<endl\n#define spair(p) cout<<#p<<\": \"<<p.fi<<\" \"<<p.se<<endl\n#define sar(a,n) cout<<#a<<\":\";rep(kbrni,n)cout<<\" \"<<a[kbrni];cout<<endl\n#define svec(v) cout<<#v<<\":\";rep(kbrni,v.size())cout<<\" \"<<v[kbrni];cout<<endl\n#define svecp(v) cout<<#v<<\":\";each(kbrni,v)cout<<\" {\"<<kbrni.first<<\":\"<<kbrni.second<<\"}\";cout<<endl\n#define sset(s) cout<<#s<<\":\";each(kbrni,s)cout<<\" \"<<kbrni;cout<<endl\n#define smap(m) cout<<#m<<\":\";each(kbrni,m)cout<<\" {\"<<kbrni.first<<\":\"<<kbrni.second<<\"}\";cout<<endl\n\nusing namespace std;\n\ntypedef pair<int,int> P;\ntypedef pair<ll,ll> pll;\ntypedef vector<int> vi;\ntypedef vector<vi> vvi;\ntypedef vector<ll> vl;\ntypedef vector<vl> vvl;\ntypedef vector<double> vd;\ntypedef vector<P> vp;\ntypedef vector<string> vs;\n\nconst int MAX_N = 10005;\n\nstruct edge\n{\n    int to,cost;\n};\n\nvector<edge> G[MAX_N];\nbool ok[MAX_N];\nint sub[MAX_N];\nint n,t,k;\n\nvoid dfs(int u,int p)\n{\n    sub[u] = 1;\n    each(e,G[u]){\n        int v = e.to;\n        if(p != v){\n            dfs(v,u);\n            sub[u] += sub[v];\n        }\n    }\n}\n\nvvi redfs(int u,int p)\n{\n    vvi dp(2,vi(2,INF));\n    int mx = 1;\n    if(ok[u]){\n        dp[1][1] = 0;\n    }else{\n        dp[0][1] = 0;\n    }\n    each(e,G[u]){\n        cmn(mx,k+1);\n        int v = e.to, c = e.cost;\n        if(p != v){\n            vvi res = redfs(v,u);\n            vvi dp2(2,vi(mx+len(res[0]),INF));\n            srep(i,1,mx+1){\n                srep(j,1,len(res[0])){\n                    if(ok[u]){\n                        cmn(dp2[1][i+j-1],dp[1][i]+res[0][j]);\n                        cmn(dp2[1][i+j-1],dp[1][i]+res[1][j]);\n                        cmn(dp2[1][i+j],dp[1][i]+res[1][j]+c);\n                    }else{\n                        cmn(dp2[0][i+j-1],dp[0][i]+res[0][j]);\n                        cmn(dp2[0][i+j],dp[0][i]+res[1][j]+c);\n                        cmn(dp2[1][i+j-1],dp[0][i]+res[1][j]);\n                        cmn(dp2[1][i+j-1],dp[1][i]+res[0][j]);\n                        cmn(dp2[1][i+j-1],dp[1][i]+res[1][j]);\n                        cmn(dp2[1][i+j],dp[1][i]+res[1][j]+c);\n                    }\n                }\n            }\n            mx += len(res[0]) - 1;\n            dp[0].resize(mx+1),dp[1].resize(mx+1);\n            rep(i,2){\n                rep(j,mx+1){\n                    dp[i][j] = dp2[i][j];\n                }\n            }\n        }\n    }\n    return dp;\n}\n\nint main()\n{\n    cin.tie(0);\n    ios::sync_with_stdio(false);\n    int id = 0;\n    while(1){\n        cin >> n >> t >> k;\n        if(n == 0){\n            break;\n        }\n        rep(i,n){\n            G[i].clear(),ok[i] = false;\n        }\n        rep(i,n-1){\n            int a,b,c;\n            cin >> a >> b >> c;\n            G[a-1].pb((edge){b-1,c}),G[b-1].pb((edge){a-1,c});\n        }\n        rep(i,t){\n            int a;\n            cin >> a;\n            --a;\n            ok[a] = true;\n        }\n        if(k == 0){\n            cout << \"Case \" << ++id << \": 0\" << endl;\n            continue;\n        }\n        dfs(0,-1);\n        vvi ans = redfs(0,-1);\n        cout << \"Case \" << ++id << \": \" << ans[1][k+1] << endl;\n    }\n    return 0;\n}\n\n"
  },
  {
    "language": "C++",
    "code": "#include<bits/stdc++.h>\n\n#define REP(i,s,n) for(int i=s;i<n;i++)\n#define rep(i,n) REP(i,0,n)\n\nusing namespace std;\n\nstruct Edge {\n  int src,dst,weight;\n  bool operator < ( const Edge &e ) const { return weight > e.weight; }\n};\n\nconst int MAX = 10001;\nint V,t,k,par[MAX],base[MAX],CNT=1;\nEdge edge[MAX];\n\nint find(int x){\n  if( x == par[x] ) return x;\n  return par[x] = find(par[x]);\n}\n\nvoid unit(int x,int y){\n  x = find(x), y = find(y);\n  if( x != y ) par[x] = y;\n}\n\nint main(){\n  while( scanf(\" %d %d %d\",&V,&t,&k), V|t|k ){\n    rep(i,V) par[i] = i;\n    int sum = 0;\n    rep(i,V-1){\n      scanf(\" %d %d %d\",&edge[i].src,&edge[i].dst,&edge[i].weight);\n      --edge[i].src, --edge[i].dst;\n      sum += edge[i].weight;\n    }\n    rep(i,t) {\n      scanf(\" %d\",base+i);\n      if( i ) unit(base[0],base[i]);\n    }\n    sort(edge,edge+V-1);\n    int coef = 0, remain = t - 1 - k;\n    rep(i,V-1) {\n      int s = edge[i].src, t = edge[i].dst;\n      if( find(s) == find(t) && remain ) {\n\t--remain;\n\tcoef += edge[i].weight;\n      } else {\n\tunit(s,t);\n\tcoef += edge[i].weight;\n      }\n    }\n    printf(\"Case %d: %d\\n\",CNT++,sum-coef);\n  }\n  return 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include<bits/stdc++.h>\nusing namespace std;\n\nstruct edge{\n  int a,b,c;\n  bool operator<(const edge &e) const{\n    return c < e.c;\n  }\n};\ntypedef long long ll;\n\nstruct uni{\n  int d[100003];\n  int f[100003];\n  void init(){ memset(d,-1,sizeof(d)); memset(f,0,sizeof(f)); }\n  int find(int a){ return d[a]<0?a:(d[a]=find(d[a])); }\n  void marge(int a,int b){\n    a = find(a); b = find(b);\n    if( a == b ) return ;\n    if( d[a] > d[b] ) swap(a,b);\n    if( f[a] || f[b] ) f[a] = 1;\n    d[a]+=d[b]; d[b] = a; \n  }\n  bool same(int a,int b){\n    return find(a) == find(b);\n  }\n  int size(int a){\n    return -d[find(a)];\n  }\n  bool isbase(int a){ return f[find(a)]; }\n};\n\nint N,T,K;\nuni U;\n\nint main(){\n  int ttt =0;\n  while( cin >> N >> T >> K && (N||T||K) ){\n\n    U.init();\n    ll sum = 0;\n    vector<edge> E;\n    vector<edge> E2;\n    for(int i=0;i<N-1;i++){\n      int a,b,c;\n      cin >> a >> b >> c;\n      E.push_back( (edge){a,b,c} );\n      sum += c;\n    }\n    for(int i=0;i<T;i++){\n      int a; cin >> a;\n      U.f[a] = 1;\n    }\n    for(int i=0;i<N-1;i++){\n      if( !U.isbase(E[i].a) || !U.isbase(E[i].b) ) E2.push_back(E[i]);\n    }\n    ll res = 0;\n    sort(E2.rbegin(),E2.rend());\n    int ks = 0;\n    for(int i=0;i<(int)E2.size();i++){\n      int a = E2[i].a, b = E2[i].b, c = E2[i].c;\n      if( U.same(a,b) ) continue;\n      if( !U.isbase(a) || !U.isbase(b) ){\n\tU.marge(a,b);\n\tres += (ll)c;\n\tks++;\n      }\n    }\n    //  cout << ks << endl;\n    //cout << N-K-1 << endl;\n    assert(N-K-1>=ks);\n    sort(E.rbegin(),E.rend());\n    for(int i=0;N-K-1>ks;i++){\n      if( U.same(E[i].a,E[i].b) ) continue;\n      U.marge(E[i].a,E[i].b);\n      res += (ll)E[i].c;\n      ks++;\n    }\n    // cout << N - K - 1<< endl;\n    //cout << ks << endl;\n    cout << \"Case \" << ++ttt << \": \" << sum - res << endl;\n  }\n}"
  },
  {
    "language": "C++",
    "code": "//15:53-17:33\n#include <bits/stdc++.h>\nusing namespace std;\ntypedef long long ll;\ntypedef pair<int,int> P;\ntypedef pair<int,P> P1;\ntypedef pair<P,P> P2;\n#define pu push\n#define pb push_back\n#define mp make_pair\n#define eps 1e-7\n#define INF 1000000000\n#define fi first\n#define sc second\n#define rep(i,x) for(int i=0;i<x;i++)\n#define SORT(x) sort(x.begin(),x.end())\n#define ERASE(x) x.erase(unique(x.begin(),x.end()),x.end())\n#define POSL(x,v) (lower_bound(x.begin(),x.end(),v)-x.begin())\n#define POSU(x,v) (upper_bound(x.begin(),x.end(),v)-x.begin())\nint n,m,k;\nvector<P1>vec;\nvector<P>edge[10005];\nbool good[10005];\nbool used[10005],ok;\nP forbid;\nvoid dfs(int v){\n\tif(used[v]) return;\n\tif(good[v]) ok = 1; used[v] = 1;\n\t//cout << v << endl;\n\tfor(int i=0;i<edge[v].size();i++){\n\t\tif(mp( min(v,edge[v][i].fi), max(v,edge[v][i].fi) ) == forbid){\n\t\t\tcontinue;\n\t\t}\n\t\tif(!used[edge[v][i].fi]) dfs(edge[v][i].fi);\n\t}\n}\nint main(){\n\tfor(int q=1;;q++){\n\t\tscanf(\"%d%d%d\",&n,&m,&k);\n\t\tif(n==0) return 0; memset(good,0,sizeof(good));\n\t\tvec.clear(); rep(i,10005) edge[i].clear();\n\t\tfor(int i=1;i<n;i++){\n\t\t\tint a,b,c; scanf(\"%d%d%d\",&a,&b,&c);\n\t\t\tvec.pb(mp(c,mp(a,b)));\n\t\t\tedge[a].pb(mp(b,c));\n\t\t\tedge[b].pb(mp(a,c));\n\t\t}\n\t\tfor(int i=0;i<m;i++){\n\t\t\tint x; cin >> x; good[x] = 1;\n\t\t}\n\t\trep(i,1005) SORT(edge[i]);\n\t\tsort(vec.begin(),vec.end());\n\t\tll ret = 0;int c = 0;\n\t\tfor(int i=0;i<vec.size()&&c<k;i++){\n\t\t\tmemset(used,0,sizeof(used));\n\t\t\tint cs = vec[i].fi;\n\t\t\tint L = vec[i].sc.fi,R = vec[i].sc.sc;\n\t\t\tforbid = mp(min(L,R),max(L,R));\n\t\t\tok = 0;\n\t\t\tdfs(L);\n\t\t\tif(!ok) continue;\n\t\t\tok = 0;\n\t\t\tdfs(R);\n\t\t\tif(!ok) continue;\n\t\t\tedge[L].erase(lower_bound(edge[L].begin(),edge[L].end(),mp(R,cs)));\n\t\t\tedge[R].erase(lower_bound(edge[R].begin(),edge[R].end(),mp(L,cs)));\n\t\t\tc++; ret += cs; //cout << ret << endl;\n\t\t}\n\t\tcout << \"Case \" << q << \": \" << ret << endl;\n\t}\n}"
  },
  {
    "language": "C++",
    "code": "#include <iostream>\n#include <cstdio>\n#include <vector>\n#include <set>\n#include <map>\n#include <queue>\n#include <deque>\n#include <stack>\n#include <algorithm>\n#include <cstring>\n#include <functional>\n#include <cmath>\nusing namespace std;\n#define rep(i,n) for(int i=0;i<(n);++i)\n#define rep1(i,n) for(int i=1;i<=(n);++i)\n#define all(c) (c).begin(),(c).end()\n#define fs first\n#define sc second\n#define pb push_back\n#define show(x) cout << #x << \" \" << x << endl\nstruct edge{int from,to,cost;};\nbool operator<(const edge& x,const edge& y){\n\treturn x.cost>y.cost;\n}\nint par[10000],id[10000];\nvoid init(int n){\n\trep(i,n) par[i]=i;\n\trep(i,n) id[i]=-1;\n}\nint find(int x){\n\tif(x==par[x]) return x;\n\telse par[x]=find(par[x]);\n}\nvoid unite(int x,int y){\n\tx=find(x),y=find(y);\n\tif(id[x]>=0) par[y]=x;\n\telse par[x]=y;\n}\nvector<edge> es;\nint main(){\n\tint tt=0;\n\twhile(true){\n\t\ttt++;\n\t\tint n,t,k;\n\t\tcin>>n>>t>>k;\n\t\tif(n==0) break;\n\t\tes.clear();\n\t\tinit(n);\n\t\trep(i,n-1){\n\t\t\tint a,b,c;\n\t\t\tcin>>a>>b>>c;\n\t\t\tes.pb(edge{a-1,b-1,c});\n\t\t}\n\t\trep(i,t){\n\t\t\tint x;\n\t\t\tcin>>x;\n\t\t\tid[x-1]=x-1;\n\t\t}\n\t\tsort(all(es));\n\t\tvector<int> costs;\n\t\trep(i,n-1){\n\t\t\tint a=es[i].from,b=es[i].to,c=es[i].cost;\n\t\t\ta=find(a),b=find(b);\n\t\t\tif(id[a]>=0&&id[b]>=0) costs.pb(c);\n\t\t\telse unite(a,b);\n\t\t}\n\t\tsort(all(costs));\n//\t\tshow(costs.size());\n\t\tint sum=0;\n\t\trep(i,k) sum+=costs[i];\n\t\tprintf(\"Case %d: %d\\n\",tt,sum);\n\t}\n}"
  },
  {
    "language": "C++",
    "code": "#include<bits/stdc++.h>\n\n#define REP(i,s,n) for(int i=s;i<n;i++)\n#define rep(i,n) REP(i,0,n)\n\nusing namespace std;\n\nstruct Edge {\n  int src,dst,weight;\n  bool operator < ( const Edge &e ) const { return weight > e.weight; }\n};\n\nconst int MAX = 10001;\nint V,t,k,par[MAX],base[MAX],CNT=1;\nEdge edge[MAX];\n\nint find(int x){\n  if( x == par[x] ) return x;\n  return par[x] = find(par[x]);\n}\n\nvoid unit(int x,int y){\n  x = find(x), y = find(y);\n  if( x != y ) par[x] = y;\n}\n\nint main(){\n  while( scanf(\" %d %d %d\",&V,&t,&k), V|t|k ){\n    rep(i,V) par[i] = i;\n    int sum = 0;\n    rep(i,V-1){\n      scanf(\" %d %d %d\",&edge[i].src,&edge[i].dst,&edge[i].weight);\n      --edge[i].src, --edge[i].dst;\n      sum += edge[i].weight;\n    }\n    rep(i,t) {\n      scanf(\" %d\",base+i);\n      --base[i];\n      if( i ) unit(base[0],base[i]);\n    }\n    sort(edge,edge+V-1);\n    int coef = 0, remain = t - 1 - k;\n    rep(i,V-1) {\n      int s = edge[i].src, t = edge[i].dst;\n      if( find(s) == find(t) ) {\n\tif( remain ) {\n\t  --remain;\n\t  coef += edge[i].weight;\n\t}\n      } else {\n\tunit(s,t);\n\tcoef += edge[i].weight;\n      }\n    }\n    printf(\"Case %d: %d\\n\",CNT++,sum-coef);\n  }\n  return 0;\n}"
  },
  {
    "language": "C++",
    "code": "// #include <iostream>\n// #include <vector>\n// #include <algorithm>\n// #include <queue>\n// #include <cstring>\n\n\n\n\n// using namespace std;\n\n\n\n\n// typedef pair<int,int> pii;\n\n\n\n\n// const int MAX_V=10001;\n// const int INF=1000000000;\n\n\n\n\n// struct edge{\n// &#160; int to;\n// &#160; int cost;\n// };\n\n\n\n\n// vector<edge> G[MAX_V];\n// bool used[MAX_V];\n// int prim(int V){\n// &#160; memset(used,0,sizeof(used));\n// &#160; int res=0;\n// &#160; priority_queue<pii,vector<pii>,greater<pii> > pq;\n// &#160; // 次の場所をコストとともに登録\n// &#160; for(int i=0;i<G[0].size();i++)\n// &#160; &#160; pq.push(pii(G[0][i].cost,G[0][i].to));\n// &#160; used[0]=true;\n// &#160; while(pq.size()){\n// &#160; &#160; pii p=pq.top();pq.pop();\n// &#160; &#160; int cost=p.first;\n// &#160; &#160; int node=p.second;\n// &#160; &#160; // すでに登録済みノード\n// &#160; &#160; if(used[node])continue;\n// &#160; &#160; // 今回のエッジを採用\n// &#160; &#160; used[node]=true;\n// &#160; &#160; res+=cost;\n// &#160; &#160; // 今回登録したノードからいける場所を登録\n// &#160; &#160; for(int i=0;i<G[node].size();i++){\n// &#160; &#160; &#160; edge &e=G[node][i];\n// &#160; &#160; &#160; if(used[e.to])continue;\n// &#160; &#160; &#160; pq.push(pii(G[node][i].cost,G[node][i].to));\n// &#160; &#160; }\n// &#160; }\n// &#160; return res;\n// }\n\n\n\n\n#include <iostream>\n#include <vector>\n#include <algorithm>\n#include <queue>\n#include <cstring>\n\n\n\n\nusing namespace std;\n\n\n\n\ntypedef pair<int,int> pii;\n\n\n\n\nconst int MAX_V=10001;\nconst int INF=1000000000;\n\n\n\n\n\n\n\n\nclass UnionFindTree{\npublic:\n&#160; // indexの数の親ノード(ある集合の親を見つけたいときはここを直接参照せず、findを使う)\n&#160; vector<int> par;\n&#160; // indexを根とする木のランク\n&#160; vector<int> rank;\n&#160; // 木の最大値\n&#160; int treeSize;\n&#160; vector<bool> isBase;\n&#160; UnionFindTree(int initTreeSize = 1000){\n&#160; &#160; // 引数で与えられた値を最大格納数とするUnionFindTreeの作成\n&#160; &#160; treeSize = initTreeSize;\n&#160; &#160; init();\n&#160; }\n&#160; void init(){\n&#160; &#160; for(int i = 0; i < treeSize; i++){\n&#160; &#160; &#160; par.push_back(i);\n&#160; &#160; &#160; rank.push_back(0);\n&#160; &#160; &#160; isBase.push_back(false);\n&#160; &#160; }\n&#160; }\n&#160; // 与えられた数が格納されている木のルートを探索\n&#160; int find(int x){ &#160;\n&#160; &#160; if(par[x]==x)return x;\n&#160; &#160; else return par[x] = find(par[x]);\n&#160; }\n&#160; // 和集合をとる。ただしここでは各集合の親の付け替えは起こらない\n&#160; void unite(int x,int y){\n&#160; &#160; x = find(x);\n&#160; &#160; y = find(y);\n&#160; &#160; if(x == y)\n&#160; &#160; &#160; return;\n&#160; &#160; if(rank[x] < rank[y]){\n&#160; &#160; &#160; par[x] = y;\n&#160; &#160; &#160; if(isBase[find(x)]||isBase[find(y)])\n\tisBase[find(x)]=true;\n&#160; &#160; }\n&#160; &#160; else{\n&#160; &#160; &#160; par[y] = x;\n&#160; &#160; &#160; if(isBase[find(x)]||isBase[find(y)])\n\tisBase[find(x)]=true;\n&#160; &#160; &#160; if(rank[y] == rank[x])rank[x]++;\n&#160; &#160; }\n&#160; }\n&#160; bool same(int x,int y){\n&#160; &#160; return find(x) == find(y);\n&#160; }\n};\n\n\n\n\nstruct edge{\n&#160; int to;\n&#160; int cost;\n&#160; int idx;\n};\n\n\n\n\nvector<edge> G[MAX_V];\nvector<int> bases;\nbool used[MAX_V];\nint n,t,k;\nvoid prim(int V){\n&#160; priority_queue<int> cand;\n&#160; UnionFindTree uft(V+1);\n&#160; for(int i=0;i<MAX_V;i++)used[i]=false;\n&#160; for(int i=0;i<bases.size();i++)uft.isBase[bases[i]]=true;\n&#160; priority_queue<pair<pii,pii> > pq;\n&#160; for(int i=0;i<bases.size();i++){\n&#160; &#160; // 次の場所をコストとともに登録\n&#160; &#160; for(int j=0;j<G[bases[i]].size();j++){\n&#160; &#160; &#160; edge &e=G[bases[i]][j];\n&#160; &#160; &#160; if(used[e.idx])continue;\n&#160; &#160; &#160; used[e.idx]=true;\n&#160; &#160; &#160; pq.push(make_pair(pii(e.cost,e.idx),pii(e.to,bases[i])));\n&#160; &#160; }\n&#160; }\n&#160; while(pq.size()){\n&#160; &#160; pair<pii,pii> p=pq.top();pq.pop();\n&#160; &#160; int cost=p.first.first;\n&#160; &#160; int idx=p.first.second;\n&#160; &#160; int node=p.second.first;\n&#160; &#160; int from=p.second.second;\n&#160; &#160; // 今回のエッジを採用\n&#160; &#160; if(uft.isBase[uft.find(from)]\n&#160; &#160; &#160; &#160;&&uft.isBase[uft.find(node)])cand.push(-cost);\n&#160; &#160; uft.unite(from,node);\n&#160; &#160; // 今回登録したノードからいける場所を登録\n&#160; &#160; for(int i=0;i<G[node].size();i++){\n&#160; &#160; &#160; edge &e=G[node][i];\n&#160; &#160; &#160; if(used[e.idx])continue;\n&#160; &#160; &#160; used[e.idx]=true;\n&#160; &#160; &#160; pq.push(make_pair(pii(e.cost,e.idx),pii(e.to,node)));\n&#160; &#160; }\n&#160; }\n&#160; int res=0;\n&#160; for(int i=0;i<k;i++){\n&#160; &#160; res+=-cand.top();cand.pop();\n&#160; }\n&#160; cout<<res<<endl;\n&#160; cout<<flush;\n}\n\n\n\n\nint main(){\n&#160; int cnt=1;\n&#160; while(cin>>n>>t>>k&&(n|t|k)){\n&#160; &#160; for(int i=0;i<MAX_V;i++)G[i].clear();\n&#160; &#160; for(int i=0;i<n-1;i++){\n&#160; &#160; &#160; edge e;\n&#160; &#160; &#160; int a,b,c;\n&#160; &#160; &#160; cin>>a>>b>>c;\n&#160; &#160; &#160; e.to=a;\n&#160; &#160; &#160; e.cost=c;\n&#160; &#160; &#160; e.idx=i;\n&#160; &#160; &#160; G[b].push_back(e);\n&#160; &#160; &#160; e.to=b;\n&#160; &#160; &#160; G[a].push_back(e);\n&#160; &#160; }\n&#160; &#160; bases.clear();\n&#160; &#160; for(int i=0;i<t;i++){\n&#160; &#160; &#160; int a;\n&#160; &#160; &#160; cin>>a;\n&#160; &#160; &#160; bases.push_back(a);\n&#160; &#160; }\n&#160; &#160; cout<<\"Case \"<<cnt<<\": \";\n&#160; &#160; prim(n);\n&#160; &#160; cnt++;\n&#160; }\n\n\n\n\n&#160; return 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\nusing namespace std;\n#define int long long\n#define REP(i,n) for(int i = 0; i < (int)(n); ++i)\n#define DEBUG(x) cerr << #x << \" = \" << x << endl\nstruct UnionFind {\n  vector<int> data;\n  vector<int> sum;\n  UnionFind(int v) : data(v, -1), sum(v, 0) {}\n  int root(int x) {\n    return data[x] < 0 ? x : data[x] = root(data[x]);\n  }\n  bool same(int x, int y) {\n    return root(x) == root(y);\n  }\n  int size(int x) {\n    return -data[root(x)];\n  }\n  void merge(int x, int y) {\n    x = root(x), y = root(y);\n    if (x != y) {\n      if (size(y) > size(x))\n        swap(x, y);\n      data[x] += data[y];\n      data[y] = x;\n      sum[x] += sum[y];\n    }\n  }\n};\nstruct Edge {\n  int a, b, cost;\n  Edge(int a_, int b_, int cost_) : a(a_), b(b_), cost(cost_) {}\n  bool operator <(const Edge &other) const {\n    return this->cost < other.cost;\n  }\n};\nsigned main() {\n  ios::sync_with_stdio(false);\n  int caseNumber = 1;\n  while(true) {\n    int N, T, K; cin >> N >> T >> K;\n    if(N == 0 && T == 0 && K == 0) break;\n    vector<Edge> G;\n    REP(i, N - 1) {\n      int a, b, cost; cin >> a >> b >> cost;\n      --a, --b;\n      G.emplace_back(a, b, cost);\n    }\n    vector<int> B(T);\n    REP(i, T) {\n      cin >> B[i];\n      B[i]--;\n    }\n    sort(G.rbegin(), G.rend());\n    int totalCost = 0;\n    for(const auto &e : G) {\n      totalCost += e.cost;\n    }\n    UnionFind uf(N);\n    for(int b : B) {\n      uf.sum[b] = 1;\n    }\n    int mergeCount = 0;\n    int mergeCost = 0;\n    for(const auto &e : G) {\n      if (uf.sum[uf.root(e.a)] == 0 || uf.sum[uf.root(e.b)] == 0) {\n        mergeCost += e.cost;\n        uf.merge(e.a, e.b);\n      }\n      else if(mergeCount < T - 1 - K) {\n        mergeCount++;\n        mergeCost += e.cost;\n        uf.merge(e.a, e.b);\n      }\n    }\n    int ans = totalCost - mergeCost;\n    cout << \"Case \" << caseNumber << \": \" << ans << endl;\n    caseNumber++;\n  }\n}"
  },
  {
    "language": "C++",
    "code": "#include<bits/stdc++.h>\n\nusing namespace std;\n\nstruct edge\n{\n  int to, cost;\n};\n\ntypedef pair< int, int > Pi;\n\nint main()\n{\n  int N, T, K;\n  int A[10000], B[10000], C[10000];\n  int testcase = 1;\n\n  while(scanf(\"%d %d %d\", &N, &T, &K), N) {\n\n    vector< edge > g[10000];\n    int deg[10000] = {};\n    bool M[10000] = {};\n    priority_queue< Pi, vector< Pi >, greater<> > que;\n\n    for(int i = 1; i < N; i++) {\n      scanf(\"%d %d %d\", &A[i], &B[i], &C[i]);\n      --A[i], --B[i];\n      g[A[i]].emplace_back((edge) {B[i], C[i]});\n      g[B[i]].emplace_back((edge) {A[i], C[i]});\n      ++deg[A[i]];\n      ++deg[B[i]];\n      que.emplace(C[i], i);\n    }\n\n    for(int i = 0; i < T; i++) {\n      int x;\n      scanf(\"%d\", &x);\n      --x;\n      M[x] = true;\n    }\n\n    queue< int > beet;\n    bool live[10000];\n    for(int i = 0; i < N; i++) {\n      if(deg[i] == 1) beet.emplace(i);\n      live[i] = true;\n    }\n\n    auto update = [&]()\n    {\n      while(!beet.empty()) {\n        int p = beet.front();\n        beet.pop();\n        if(M[p]) continue;\n        --deg[p];\n        if(deg[p] == 0) {\n          live[p] = false;\n          for(auto &e : g[p]) {\n            if(live[e.to]) beet.emplace(e.to);\n          }\n        }\n      }\n    };\n\n    int ret = 0;\n    for(int i = 0; i < K; i++) {\n      update();\n      while(!que.empty()) {\n        int cost, idx;\n        tie(cost, idx) = que.top();\n        que.pop();\n        if(!live[A[idx]] || !live[B[idx]]) continue;\n        ret += cost;\n        --deg[A[idx]];\n        --deg[B[idx]];\n        beet.emplace(A[idx]);\n        beet.emplace(B[idx]);\n        break;\n      }\n    }\n\n    printf(\"Case %d: %d\\n\", testcase++, ret);\n  }\n}"
  },
  {
    "language": "C++",
    "code": "#include <iostream>\n#include <vector>\n#include <map>\n#include <algorithm>\nusing namespace std;\n\nconst int MAX_V = 10001;\ntypedef pair<int,int> P;\nstruct edge{ int to,cost; };\n\n// グラフ (隣接リスト)\nvector<edge> G[MAX_V];\n// e = (u,v) , is_cost[e] := コスト\nmap<P,int> is_cost;\n// base[u] == true のとき ノード u は ベース\nbool base[MAX_V];\n// (cost,(u,v))の組\nvector< pair<int ,P> > a;\n// used[u] == true のとき ノード u は探索済み\nbool used[MAX_V];\n\nint n, t, k;\n\n\n// 初期化\nvoid init(){\n\ta.clear();\n\tis_cost.clear();\n\tfor(int i=0 ; i < MAX_V ; i++ ){\n\t\tbase[i] = false;\n\t\tG[i].clear();\n\t}\n}\n\n// グラフに重みcostのエッジ(u,v)を追加\nvoid add_edge(int u, int v, int cost){\n\tedge e;\n\te.to = v;\n\te.cost = cost;\n\tG[u].push_back( e );\n\te.to = u;\n\tG[v].push_back( e );\n}\n\n// グラフのエッジ(u,v)を切断\nvoid cut_edge(int u, int v){\n\tfor(vector<edge>::iterator it = G[u].begin() ; it != G[u].end() ; ++ it ){\n\t\tif( (*it).to == v ){\n\t\t\tG[u].erase( it );\n\t\t\treturn ;\n\t\t}\n\t}\n}\n\n\n// ノード u の木にベースがあるかどうか\nvoid is_base(int u, bool& flag){\n\t// ノード u がベースのとき\n\tif( base[u] ){\n\t\tflag = true;\n\t\treturn;\n\t}\n\t// ノード u が探索済みのとき\n\tif( used[u] ) return;\n\tused[u] = true;\n\t\n\tfor(int i=0 ; i < G[u].size() ; i++ ){\n\t\tedge e = G[u][i];\n\t\tis_base( e.to , flag );\n\t}\n}\n\nint solve(){\n\t\n\t// 連結成分の数\n\tint p=1;\n\t// コストの総和\n\tint sum = 0;\n\t\n\tsort( a.begin() , a.end() );\n\tfor(int i=0 ; i < a.size() ; i++ ){\n\t\tint cost = a[i].first;\n\t\tint u = a[i].second.first;\n\t\tint v = a[i].second.second;\n\t\tif( u > v ) swap(u,v);\n\t\t\n\t\tcut_edge( u , v );\n\t\t\n\t\tbool flag1 = false, flag2 = false;\n\t\tfor(int i=0 ; i < n ; i++ ) used[i] = false;\n\t\tis_base( u , flag1 );\n\t\tfor(int i=0 ; i < n ; i++ ) used[i] = false;\n\t\tis_base( v , flag2 );\n\t\t\n\t\t// u,vの木の両方にベースを含むとき切断する\n\t\tif( flag1 && flag2 ){\n\t\t\tsum += is_cost[P(u,v)];\n\t\t\tp++;\n\t\t}else{\n\t\t\tadd_edge( u , v , is_cost[P(u,v)] );\n\t\t}\n\t\t\n\t\t// 連結成分が K+1 個になったらループを抜ける\n\t\tif( p == k+1 ) break;\n\t}\n\treturn sum;\n}\n\nint main(){\n\tfor(int t_ = 1 ; cin >> n >> t >> k , (n || t || k) ; t_++ ){\n\t\t// 初期化\n\t\tinit();\n\t\t\n\t\tfor(int i = 0 ; i < n-1 ; i++ ){\n\t\t\tint u, v, cost;\n\t\t\tcin >> u >> v >> cost;\n\t\t\tu--; v--;\n\t\t\tif( u > v ) swap(u,v);\n\t\t\t\n\t\t\tis_cost[P(u,v)] = cost;\n\t\t\tadd_edge( u , v , cost );\n\t\t\tpair<int,P> p( cost , P(u,v) );\n\t\t\ta.push_back( p );\n\t\t}\n\t\tfor(int i = 0 ; i < t ; i++ ){\n\t\t\tint b;\n\t\t\tcin >> b;\n\t\t\tb--;\n\t\t\tbase[b] = true;\n\t\t}\n\t\t\n\t\tint ans = solve();\n\t\tcout << \"Case \" << t_ << \": \" << ans << endl;\n\t}\n}"
  },
  {
    "language": "C++",
    "code": "#include<iostream>\n#include<iomanip>\n#include<cstdio>\n#include<string>\n#include<cstring>\n#include<climits>\n#include<algorithm>\n#include<vector>\n#include<cmath>\n#include<map>\n#include<set>\n#include<stack>\n#include<queue>\n#include<deque>\n#include<tuple>\n#include<list>\n#include<unordered_map>\n#define ll long long\n#define pii pair<int,int>\n#define pll pair<ll,ll>\n#define vii vector<int>\n#define vll vector<ll>\n#define lb lower_bound\n#define pb push_back\n#define mp make_pair\n#define fi first\n#define sc second\n#define rep(i,n) for(ll i=0;i<n;i++)\n#define rep2(i,a,b) for(ll i=a;i<b;i++)\n#define repr(i,n) for(ll i=n-1;i>=0;i--)\n#define all(x) x.begin(),x.end()\n#define LB(v,x) (lower_bound(v.begin(),v.end(),x)-v.begin())\n#define UB(v,x) (upper_bound(v.begin(),v.end(),x)-v.begin())\n#define ERASE(v) v.erase(unique(v.begin(),v.end()),v.end())\n// #define int ll\nusing namespace std;\nconst int INF (1 << 30);\nconst ll LLINF (1LL << 55LL);\nconst int MOD = 1000000007;\nconst int MAX = 510000;\nconst double pi = acos(-1);\nconst double eps = 1e-9;\n\nstruct UnionFind {\n    vector<ll> par;\n        \n    UnionFind(ll n) : par(n, -1) { }\n    void init(ll n) { par.assign(n, -1); }\n    \n    ll find(ll x) {\n        if (par[x] < 0) return x;\n        else return par[x] = find(par[x]);\n    }\n    \n    bool same(ll x, ll y) {\n        return find(x) == find(y);\n    }\n    \n    bool unite(ll x, ll y) {\n        x = find(x); y = find(y);\n        if (x == y) return false;\n        if (par[x] > par[y]) swap(x, y);\n        par[x] += par[y];\n        par[y] = x;\n        return true;\n    }\n    \n    ll size(ll x) {\n        return -par[find(x)];\n    }\n\n    void print(ll x){\n        rep(i,x){\n            cout<<par[i]<<endl;\n        }\n        return ;\n    }\n};\n\nint main(){\n    cin.tie(0);\n    ios::sync_with_stdio(false);\n    cout << fixed << setprecision(15);\n    rep(j,INF){\n        ll n,b,k,ans=0;\n        cin>>n>>b>>k;\n        if(n==0&&b==0&&k==0){\n            break;\n        }\n        bool t[100190]={};\n        pair<ll,pll> s[100010];\n        vll G;\n        UnionFind uf(n);\n        rep(i,n-1){\n            ll p,q,r;\n            cin>>p>>q>>r;\n            p--;q--;\n            s[i]=mp(r,pll(p,q));\n        }\n        sort(s,s+n-1);\n        reverse(s,s+n-1);\n        rep(i,b){\n            ll d;\n            cin>>d;\n            d--;\n            t[d]=true;\n        }\n        rep(i,n-1){\n            ll z1=uf.find(s[i].sc.sc);\n            ll z2=uf.find(s[i].sc.fi);\n            if(t[z1]==true&&t[z2]==true){\n                G.pb(s[i].fi);\n            }\n            else if(t[z1]==true||t[z2]==true){\n                uf.unite(z1,z2);\n                t[uf.find(z1)]=true;\n            }\n            else{\n                uf.unite(z1,z2);\n            }\n        }\n        sort(all(G));\n        rep(i,k){\n            ans+=G[i];\n        }\n        cout<<\"Case \"<<j+1<<\": \"<<ans<<endl;\n    }\n    return 0;\n}\n"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\n#define INF 1000000007\nusing namespace std;\ntypedef long long ll;\ntypedef pair<int,int> P;\n\nstruct diameter{\n\tstatic const int MAX=10000;\n\tvector<int> G[MAX];\n\tint n;\n\tint d[MAX];\n\tbool vis[MAX];\n\tint d2[2][MAX];\n\n\tvoid bfs(int s){\n\t\tfill(d,d+n,INF);\n\t\tqueue<int> que;\n\t\tque.push(s);\n\t\td[s]=0;\n\t\tint v;\n\t\twhile(que.size()){\n\t\t\tv=que.front();\n\t\t\tque.pop();\n\t\t\tfor(int i=0;i<G[v].size();i++){\n\t\t\t\tint e=G[v][i];\n\t\t\t\tif(d[e]==INF){\n\t\t\t\t\td[e]=d[v]+1;\n\t\t\t\t\tque.push(e);\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t}\n\tP diameter_points(int s=0){\n\t\tbfs(s);\n\t\tint maxv=0;\n\t\tint tgt=0;\n\t\tfor(int i=0;i<n;i++){\n\t\t\tif(d[i]==INF)continue;\n\t\t\tif(maxv<d[i]){\n\t\t\t\tmaxv=d[i];\n\t\t\t\ttgt=i;\n\t\t\t}\n\t\t}\n\t\tbfs(tgt);\n\t\tmaxv=0;\n\t\tint v=0;\n\t\tfor(int i=0;i<n;i++){\n\t\t\tif(d[i]==INF)continue;\n\t\t\tif(maxv<d[i]){\n\t\t\t\tmaxv=d[i];\n\t\t\t\tv=i;\n\t\t\t}\n\t\t}\n\t\treturn P(tgt,v);\n\t}\n\tvector<int> middle_points(){\n\t\tP p=diameter_points();\n\t\tbfs(p.first);\n\t\tfor(int i=0;i<n;i++){\n\t\t\td2[0][i]=d[i];\n\t\t}\n\t\tbfs(p.second);\n\t\tfor(int i=0;i<n;i++){\n\t\t\td2[1][i]=d[i];\n\t\t}\n\t\tvector<int> cid;\n\t\tif(d2[0][p.second]%2==0){\n\t\t\tfor(int i=0;i<n;i++){\n\t\t\t\tif(d2[0][p.second]==d2[0][i]*2 && d2[1][p.first]==d2[1][i]*2){\n\t\t\t\t\tcid.push_back(i);\n\t\t\t\t}\n\t\t\t}\n\t\t}else{\n\t\t\tfor(int i=0;i<n;i++){\n\t\t\t\tif(d2[0][p.second]==(d2[0][i]+d2[1][i]) && abs(d2[0][i]-d2[1][i])==1){\n\t\t\t\t\tcid.push_back(i);\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t\treturn cid;\n\t}\n};\n\nstruct edge{\n\tint t,c;\n\tedge(){}\n\tedge(int tt,int cc){\n\t\tt=tt;\n\t\tc=cc;\n\t}\n};\n\ndiameter di;\nvector<edge> G[10001];\nint n,t,k;\nbool flag[10001];\nint siz[10001];\nint* dp[10001][2];\nint tmp[2][10001];\n\nint dfs(int v,int p){\n\tint ans=1;\n\tfor(int i=0;i<G[v].size();i++){\n\t\tint nv=G[v][i].t;\n\t\tif(nv!=p){\n\t\t\tans+=dfs(nv,v);\n\t\t}\n\t}\n\treturn (siz[v]=ans);\n}\n\nvoid func(int v,int p){\n\tfree(dp[v][0]);\n\tfree(dp[v][1]);\n\tdp[v][0]=new int[siz[v]+1];\n\tdp[v][1]=new int[siz[v]+1];\n\tif(flag[v]){\n\t\tdp[v][0][1]=INF;\n\t\tdp[v][1][1]=0;\n\t}\n\telse{\n\t\tdp[v][1][1]=INF;\n\t\tdp[v][0][1]=0;\n\t}\n\tint ns=1;\n\tfor(int i=0;i<G[v].size();i++){\n\t\tint nv=G[v][i].t;\n\t\tint nc=G[v][i].c;\n\t\tif(nv!=p){\n\t\t\tfunc(nv,v);\n\t\t\tfor(int j=0;j<=ns+siz[nv];j++){\n\t\t\t\ttmp[0][j]=INF;\n\t\t\t\ttmp[1][j]=INF;\n\t\t\t}\n\t\t\tfor(int i=1;i<=ns;i++){\n\t\t\t\tfor(int j=0;j<=siz[nv];j++){\n\t\t\t\t\ttmp[0][i+j]=min(tmp[0][i+j],dp[v][0][i]+dp[nv][1][j]+nc);\n\t\t\t\t\ttmp[1][i+j]=min(tmp[1][i+j],dp[v][1][i]+dp[nv][1][j]+nc);\n\t\t\t\t\ttmp[0][i+j-1]=min(tmp[0][i+j-1],dp[v][0][i]+dp[nv][0][j]);\n\t\t\t\t\ttmp[1][i+j-1]=min(tmp[1][i+j-1],dp[v][1][i]+dp[nv][0][j]);\n\t\t\t\t\ttmp[1][i+j-1]=min(tmp[1][i+j-1],dp[v][0][i]+dp[nv][1][j]);\n\t\t\t\t\ttmp[1][i+j-1]=min(tmp[1][i+j-1],dp[v][1][i]+dp[nv][1][j]);\n\t\t\t\t}\n\t\t\t}\n\t\t\tfor(int j=0;j<=ns+siz[nv];j++){\n\t\t\t\tdp[v][0][j]=tmp[0][j];\n\t\t\t\tdp[v][1][j]=tmp[1][j];\n\t\t\t}\n\t\t\tns+=siz[nv];\n\t\t}\n\t}\n}\n\nvoid solve(){\n\tint root=di.middle_points()[0];\n\tdfs(root,-1);\n\tfunc(root,-1);\n\tint ans=INF;\n\tfor(int i=k+1;i<=n;i++){\n\t\tans=min(ans,dp[root][1][i]);\n\t}\n\tprintf(\"%d\\n\",ans);\n}\n\nint main(void){\n\tint casenum=1;\n\twhile(1){\n\t\tscanf(\"%d%d%d\",&n,&t,&k);\n\t\tif(n==0)break;\n\t\tdi.n=n;\n\t\tmemset(flag,false,sizeof(flag));\n\t\tmemset(siz,false,sizeof(siz));\n\t\tfor(int i=0;i<n;i++){\n\t\t\tG[i].clear();\n\t\t\tdi.G[i].clear();\n\t\t}\n\t\tfor(int i=0;i<n-1;i++){\n\t\t\tint a,b,c;\n\t\t\tscanf(\"%d%d%d\",&a,&b,&c);\n\t\t\ta--;\n\t\t\tb--;\n\t\t\tG[a].push_back(edge(b,c));\n\t\t\tG[b].push_back(edge(a,c));\n\t\t\tdi.G[a].push_back(b);\n\t\t\tdi.G[b].push_back(a);\n\t\t}\n\t\tfor(int i=0;i<t;i++){\n\t\t\tint a;\n\t\t\tscanf(\"%d\",&a);\n\t\t\ta--;\n\t\t\tflag[a]=true;\n\t\t}\n\t\tprintf(\"Case %d: \",casenum++);\n\t\tsolve();\n\t}\n\treturn 0;\n}\n"
  },
  {
    "language": "C++",
    "code": "#include<deque>\n#include<queue>\n#include<vector>\n#include<algorithm>\n#include<iostream>\n#include<set>\n#include<cmath>\n#include<tuple>\n#include<string>\n#include<chrono>\n#include<functional>\n#include<iterator>\n#include<random>\n#include<unordered_set>\n#include<array>\n#include<map>\n#include<iomanip>\n#include<assert.h>\n#include<list>\n#include<bitset>\n#include<stack>\n#include<memory>\n#include<numeric>\nusing namespace std;\nusing namespace std::chrono;\ntypedef long long int llint;\ntypedef long double lldo;\n#define mp make_pair\n#define mt make_tuple\n#define pub push_back\n#define puf push_front\n#define pob pop_back\n#define pof pop_front\n#define fir first\n#define sec second\n#define res resize\n#define ins insert\n#define era erase\n/*cout<<fixed<<setprecision(20);cin.tie(0);ios::sync_with_stdio(false);*/\nconst llint mod=1000000007 /5;\nconst llint big=2.19e15+1;\nconst long double pai=3.141592653589793238462643383279502884197;\nconst long double eps=1e-10;\nconst long double epsA=1e-4;\ntemplate <class T,class U>bool mineq(T& a,U b){if(a>b){a=b;return true;}return false;}\ntemplate <class T,class U>bool maxeq(T& a,U b){if(a<b){a=b;return true;}return false;}\nllint gcd(llint a,llint b){if(a%b==0){return b;}else return gcd(b,a%b);}\nllint lcm(llint a,llint b){if(a==0){return b;}return a/gcd(a,b)*b;}\ntemplate<class T> void SO(T& ve){sort(ve.begin(),ve.end());}\ntemplate<class T> void REV(T& ve){reverse(ve.begin(),ve.end());}\ntemplate<class T>llint LBI(const vector<T>&ar,T in){return lower_bound(ar.begin(),ar.end(),in)-ar.begin();}\ntemplate<class T>llint UBI(const vector<T>&ar,T in){return upper_bound(ar.begin(),ar.end(),in)-ar.begin();}\n\n\nbool solve(int ca){\n\tint n,t,k,i,j,ans=0;cin>>n>>t>>k;\n\tif(n==0){return false;}\n\tcout<<\"Case \"<<ca<<\": \";\n\tvector<vector<int>>go(n);\n\tvector<int>gowa(n);//行き先の残り和\n\tvector<int>zi(n);//残り次数\n\tvector<tuple<int,int,int>>edges(n-1);\n\tvector<tuple<int,int,int>>zyo(n-1);\n\tvector<bool>kie(n-1);\n\tfor(i=0;i<n-1;i++){\n\t\tint a,b,c;cin>>a>>b>>c;a--;b--;\n\t\tif(a>b){swap(a,b);}\n\t\tedges[i]=mt(c,a,b);\n\t\tzyo[i]=mt(a,b,c);\n\t\tgo[a].pub(b);gowa[a]+=b;zi[a]++;\n\t\tgo[b].pub(a);gowa[b]+=a;zi[b]++;\n\t}\n\tSO(edges);\n\tfor(i=0;i<n-1;i++){\n\t\tint a,b,c;tie(c,a,b)=edges[i];\n\t\tzyo[i]=mt(a,b,i);\n\t}\n\tSO(zyo);\n\tvector<bool>nobe(n,true);//baseの否定\n\tfor(i=0;i<t;i++){\n\t\tint a;cin>>a;a--;\n\t\tnobe[a]=false;\n\t}\n\tstack<int>eraque;\n\tfor(i=0;i<n;i++){\n\t\tif(nobe[i]&&zi[i]==1){eraque.push(i);}\n\t}\n\tint bas=0;\n\twhile(k--){\n\t\twhile(eraque.size()){\n\t\t\tint ter=eraque.top();\n\t\t\t\n\t\t\teraque.pop();\n\t\t\tif(zi[ter]!=1){continue;}\n\t\t\t\n\t\t\tint it=gowa[ter];\n\t\t\t//cerr<<\"eter=\"<<ter<<\"it=\"<<it<<endl;\n\t\t\tzi[ter]--;\n\t\t\tzi[it]--;\n\t\t\tgowa[it]-=ter;\n\t\t\tif(nobe[it]&&zi[it]==1){eraque.push(it);}\n\t\t\tif(ter>it){swap(ter,it);}\n\t\t\tint ban=get<2>(*lower_bound(zyo.begin(),zyo.end(),mt(ter,it,-1)));\n\t\t\t//cerr<<\"ban=\"<<ban<<endl;\n\t\t\tkie[ban]=1;//この辺は消えた!\n\t\t}\n\t\twhile(kie[bas]){bas++;}\n\t\tint c,a,b;tie(c,a,b)=edges[bas];\n\t\tans+=c;\n\t\tzi[a]--;gowa[a]-=b;\n\t\tif(nobe[a]&&zi[a]==1){eraque.push(a);}\n\t\tzi[b]--;gowa[b]-=a;\n\t\tif(nobe[b]&&zi[b]==1){eraque.push(b);}\n\t\t\n\t\tbas++;\n\t\t\n\t}\n\tcout<<ans<<endl;\n\treturn true;\n}\n/*\n4 3 2\n1 2 3\n2 3 4\n3 4 10\n1\n3\n4\n*/\nint main(void){\n\tcout<<fixed<<setprecision(20);cin.tie(0);ios::sync_with_stdio(false);\n\tint ca=1;\n\twhile(solve(ca)){ca++;}\n\treturn 0;\n}\n"
  },
  {
    "language": "C++",
    "code": "#include<cstdio>\n#include<vector>\n#include<utility>\n#include<algorithm>\n\nusing namespace std;\n\ntypedef pair<int,int> P;\n\nvector<P> G[10100];\nbool isBase[10100];\nint baseNum[10100];\n\nint par[10100];\n\nvector<P> es;\nint N;\n\nvoid init(){\n\tfor(int i=0;i<N;i++){\n\t\tG[i].clear();\n\t\tisBase[i]=false;\n\t\tbaseNum[i]=0;\n\t}\n\tes.clear();\n}\n\nvoid dfs(int v,int p){\n\tbaseNum[v]=isBase[v]?1:0;\n\tpar[v]=p;\n\tfor(int i=0;i<G[v].size();i++){\n\t\tint u=G[v][i].first;\n\t\tif(u==p){\n\t\t\tes.push_back(P(G[v][i].second,v));\n\t\t}else{\n\t\t\tdfs(u,v);\n\t\t\tbaseNum[v]+=baseNum[u];\n\t\t}\n\t}\n}\n\nint main(){\n\tint datano=0;\n\twhile(true){\n\t\tdatano++;\n\t\tinit();\n\t\tint T,K;\n\t\tscanf(\"%d%d%d\",&N,&T,&K);\n\t\tif(N==0) break;\n\t\tfor(int i=0;i<N-1;i++){\n\t\t\tint u,v,c;\n\t\t\tscanf(\"%d%d%d\",&u,&v,&c);\n\t\t\tu--;v--;\n\t\t\tG[u].push_back(P(v,c));\n\t\t\tG[v].push_back(P(u,c));\n\t\t}\n\t\tfor(int i=0;i<T;i++){\n\t\t\tint in;\n\t\t\tscanf(\"%d\",&in);\n\t\t\tin--;\n\t\t\tisBase[in]=true;\n\t\t}\n\t\tdfs(0,-1);\n\t\tsort(es.begin(),es.end());\n\t\tint ans=0;\n\t\tint cnt=0;\n\t\tif(K==0) goto output;\n\t\tfor(int i=0;i<N-1;i++){\n\t\t\tint v=es[i].second;\n\t\t\tint p=par[v];\n\t\t\tint c=es[i].first;\n\t\t\tint x=baseNum[v];\n\t\t\tint y=0;\n\t\t\tint tmp=p;\n\t\t\twhile(p!=-1){\n\t\t\t\ty=max(y,baseNum[p]);\n\t\t\t\tp=par[p];\n\t\t\t}\n\t\t\tif(x>0&&y>x){\n\t\t\t\tp=tmp;\n\t\t\t\twhile(p!=-1){\n\t\t\t\t\tbaseNum[p]-=x;\n\t\t\t\t\tp=par[p];\n\t\t\t\t}\n\t\t\t\tpar[v]=-1;\n\t\t\t\tans+=c;\n\t\t\t\tcnt++;\n\t\t\t}\n\t\t\tif(cnt==K) break;\n\t\t}\n\t\toutput:;\n\t\tprintf(\"Case %d: %d\\n\",datano,ans);\n\t}\n\treturn 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include<cstdio>\n#include<algorithm>\n\n#define REP(i,s,n) for(int i=s;i<n;i++)\n#define rep(i,n) REP(i,0,n)\n\nusing namespace std;\n\nstruct Edge {\n  int src,dst,weight; \n  bool operator < ( const Edge &e ) const { return weight < e.weight; }\n};\n\nconst int MAX = 10010;\nint par[MAX];\n//vector<Edge> edges;\nEdge edges[MAX];\n\nvoid init(int _size=MAX) { rep(i,_size) par[i] = i; } \n\nint find(int x) {\n  if( par[x] == x ) return x;\n  return par[x] = find(par[x]);\n}\n\nvoid unit(int x,int y){\n  x = find(x), y = find(y);\n  if( x != y ) par[x] = y;\n}\n\nbool buffer[MAX];\nbool choose[MAX];\nint counter[MAX];\n//vector<int> bases;\nint bases[MAX];\nint V,t,k;\n\nbool isValid(int index){\n  choose[index] = false;\n  //map<int,int> mp;\n  rep(i,V) counter[i] = 0, par[i] = i;\n\n  rep(i,V-1) if( choose[i] ) unit(edges[i].src,edges[i].dst);\n  rep(i,t) ++counter[find(bases[i])];\n  rep(i,V) if( counter[find(i)] == 0 ) return false;\n  return true;\n}\n\nvoid compute(){\n  sort(edges,edges+V-1);\n  if( V == t ) {\n    int sum = 0;\n    rep(i,k) sum += edges[i].weight;\n    printf(\"%d\\n\",sum);\n    return;\n  }\n  rep(i,V) buffer[i] = true;\n  int answer = 0;\n  int remain = k;\n  int cur = 0;\n  while( cur < V-1 && remain ){\n    rep(i,V) choose[i] = buffer[i];\n    if( isValid(cur) ) {\n      --remain;\n      answer += edges[cur].weight;\n      buffer[cur] = false;\n    }\n    ++cur;\n  }\n  printf(\"%d\\n\",answer);\n}\n\nint main(){\n  int CNT = 1;  \n  while( scanf(\" %d %d %d\",&V,&t,&k) , V|t|k ){\n    \n    rep(i,V-1) {\n      int s,t,c;\n      scanf(\" %d %d %d\",&s,&t,&c);\n      --s, --t;\n      //edges.push_back((Edge){s,t,c});\n      edges[i] = (Edge){s,t,c};\n    }\n    rep(i,t){\n      int base;\n      scanf(\" %d\",&base);\n      --base;\n      //bases.push_back(base);\n      bases[i] = base;\n    }\n    printf(\"Case %d: \",CNT++);\n    compute();\n  }\n  return 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\n#define ll long long\n#define INF 1000000005\n#define MOD 1000000007\n#define EPS 1e-10\n#define rep(i,n) for(int i=0;i<(int)(n);++i)\n#define rrep(i,n) for(int i=(int)(n)-1;i>=0;--i)\n#define srep(i,s,t) for(int i=(int)(s);i<(int)(t);++i)\n#define each(a,b) for(auto& (a): (b))\n#define all(v) (v).begin(),(v).end()\n#define len(v) (int)(v).size()\n#define zip(v) sort(all(v)),v.erase(unique(all(v)),v.end())\n#define cmx(x,y) x=max(x,y)\n#define cmn(x,y) x=min(x,y)\n#define fi first\n#define se second\n#define pb push_back\n#define show(x) cout<<#x<<\" = \"<<(x)<<endl\n#define spair(p) cout<<#p<<\": \"<<p.fi<<\" \"<<p.se<<endl\n#define sar(a,n) cout<<#a<<\":\";rep(kbrni,n)cout<<\" \"<<a[kbrni];cout<<endl\n#define svec(v) cout<<#v<<\":\";rep(kbrni,v.size())cout<<\" \"<<v[kbrni];cout<<endl\n#define svecp(v) cout<<#v<<\":\";each(kbrni,v)cout<<\" {\"<<kbrni.first<<\":\"<<kbrni.second<<\"}\";cout<<endl\n#define sset(s) cout<<#s<<\":\";each(kbrni,s)cout<<\" \"<<kbrni;cout<<endl\n#define smap(m) cout<<#m<<\":\";each(kbrni,m)cout<<\" {\"<<kbrni.first<<\":\"<<kbrni.second<<\"}\";cout<<endl\n\nusing namespace std;\n\ntypedef pair<int,int> P;\ntypedef pair<ll,ll> pll;\ntypedef vector<int> vi;\ntypedef vector<vi> vvi;\ntypedef vector<ll> vl;\ntypedef vector<vl> vvl;\ntypedef vector<double> vd;\ntypedef vector<P> vp;\ntypedef vector<string> vs;\n\nconst int MAX_N = 10005;\n\nstruct edge\n{\n    int to,cost;\n};\n\nvector<edge> G[MAX_N];\nbool ok[MAX_N];\nint sub[MAX_N];\nint n,t,k;\n\nvoid dfs(int u,int p)\n{\n    sub[u] = 1;\n    each(e,G[u]){\n        int v = e.to;\n        if(p != v){\n            dfs(v,u);\n            sub[u] += sub[v];\n        }\n    }\n}\n\nvoid redfs(int u,int p,int** dp)\n{\n    int mx = 1;\n    if(ok[u]){\n        dp[1][1] = 0;\n    }else{\n        dp[0][1] = 0;\n    }\n    each(e,G[u]){\n        cmn(mx,k+1);\n        int v = e.to, c = e.cost;\n        if(p != v){\n            int** res = new int*[2];\n            rep(i,2){\n                res[i] = new int[sub[v]+1];\n            }\n            rep(i,2){\n                rep(j,sub[v]+1){\n                    res[i][j] = INF;\n                }\n            }\n            redfs(v,u,res);\n            int** dp2 = new int*[2];\n            rep(i,2){\n                dp2[i] = new int[mx+sub[v]+1];\n            }\n            rep(i,2){\n                rep(j,mx+sub[v]+1){\n                    dp2[i][j] = INF;\n                }\n            }\n            srep(i,1,mx+1){\n                srep(j,1,sub[v]+1){\n                    if(ok[u]){\n                        cmn(dp2[1][i+j-1],dp[1][i]+res[0][j]);\n                        cmn(dp2[1][i+j-1],dp[1][i]+res[1][j]);\n                        cmn(dp2[1][i+j],dp[1][i]+res[1][j]+c);\n                    }else{\n                        cmn(dp2[0][i+j-1],dp[0][i]+res[0][j]);\n                        cmn(dp2[0][i+j],dp[0][i]+res[1][j]+c);\n                        cmn(dp2[1][i+j-1],dp[0][i]+res[1][j]);\n                        cmn(dp2[1][i+j-1],dp[1][i]+res[0][j]);\n                        cmn(dp2[1][i+j-1],dp[1][i]+res[1][j]);\n                        cmn(dp2[1][i+j],dp[1][i]+res[1][j]+c);\n                    }\n                }\n            }\n            mx += sub[v];\n            rep(i,2){\n                rep(j,mx+1){\n                    dp[i][j] = dp2[i][j];\n                }\n            }\n            rep(i,2){\n                delete res[i];\n                delete dp2[i];\n            }\n            delete res;\n            delete dp2;\n        }\n    }\n}\n\nint main()\n{\n    cin.tie(0);\n    ios::sync_with_stdio(false);\n    int id = 0;\n    while(1){\n        cin >> n >> t >> k;\n        if(n == 0){\n            break;\n        }\n        rep(i,n){\n            G[i].clear(),ok[i] = false;\n        }\n        rep(i,n-1){\n            int a,b,c;\n            cin >> a >> b >> c;\n            G[a-1].pb((edge){b-1,c}),G[b-1].pb((edge){a-1,c});\n        }\n        rep(i,t){\n            int a;\n            cin >> a;\n            --a;\n            ok[a] = true;\n        }\n        if(k == 0){\n            cout << \"Case \" << ++id << \": 0\" << endl;\n            continue;\n        }\n        dfs(0,-1);\n        int** ans = new int*[2];\n        rep(i,2){\n            ans[i] = new int[sub[0]+1];\n        }\n        rep(i,2){\n            rep(j,sub[0]+1){\n                ans[i][j] = INF;\n            }\n        }\n        redfs(0,-1,ans);\n        cout << \"Case \" << ++id << \": \" << ans[1][k+1] << endl;\n    }\n    return 0;\n}\n\n"
  },
  {
    "language": "C++",
    "code": "#include<bits/stdc++.h>\nusing namespace std;\n\nstruct unionfind{\n  int parent[200000];\n  int size[200000];\n  \n  void init(int n){\n    for(int i=0;i<n;i++){\n      parent[i]=i;\n      size[i]=1;\n    }\n  }\n  int find(int x){\n    if(parent[x]==x)return x;\n    else parent[x]=find(parent[x]);\n  }\n  bool same(int x,int y){\n    return (find(x)==find(y));\n  }\n  int getSize(int x){\n    return size[ find(x) ];\n  }\n  void unite(int x,int y){\n    x=find(x);\n    y=find(y);\n    if(x==y)return;\n    if(size[x]>size[y])swap(x,y);\n    parent[x]=y;\n    size[y]+=size[x];\n  }\n};\n  \nstruct edge{\n  int from,to,cost;\n  bool operator < (const edge &e) const {\n    return cost < e.cost;\n  }\n};\n\nint n,t,k;\nunionfind uf;\n\nint main(){\n\n  \n  for(int tc=1;;tc++){\n    cin>>n>>t>>k;\n    if(n==0&&t==0&&k==0)break;\n    vector<edge> E;\n\n    uf.init(n);\n    \n    for(int i=0;i<n-1;i++){\n      int a,b,c;\n      cin>>a>>b>>c;\n      a--,b--;\n      E.push_back( (edge){a,b,-c} );\n      uf.unite(a,b);\n    }\n    //    assert( uf.getSize(0) == n );\n    \n    for(int i=0;i<t;i++){\n      int a;\n      cin>>a;\n      a--;\n      E.push_back( (edge){a,n,-20000} );\n    }\n    sort(E.begin(),E.end());\n    \n    uf.init(n+1);\n\n    vector<edge> tmp;\n    \n    for(int i=0;i<(int)E.size();i++){\n      edge e=E[i];\n      if( uf.same(e.from,e.to) ){\n        tmp.push_back(e);\n      }else{\n        uf.unite(e.from,e.to);\n      }\n    }\n\n    int ans=0;\n    //    assert( (int)tmp.size() == t-1 );\n    \n    \n    for(int i=(int)tmp.size()-k;i<(int)tmp.size();i++){\n      ans-=tmp[i].cost;\n    }\n    cout<<\"Case \"<<tc<<\": \"<<ans<<endl;\n    \n  }\n  return 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include<bits/stdc++.h>\nusing namespace std;\nusing Int = long long;\n\nstruct UnionFind{\n  vector<int> r,p,yy;\n  int k;\n  UnionFind(){}\n  UnionFind(int size,vector<int> yy,int k):yy(yy),k(k){init(size);}\n  void init(int size){\n    r.resize(size,0);\n    p.resize(size,0);\n    for(int i=0;i<size;i++) r[i]=1,p[i]=i;\n  }\n  int find(int x){\n    return (x==p[x]?x:p[x]=find(p[x]));\n  }\n  bool same(int x,int y){\n    return find(x)==find(y);\n  }\n  bool unite(int x,int y){\n    x=find(x);y=find(y);\n    if(x==y) return 0;\n    if(yy[x]&&yy[y]){\n      if(!k) return 0;\n      //cout<<k<<endl;\n      k--;\n    }\n    if(r[x]<r[y]) swap(x,y);\n    if(!yy[x]&&yy[y]) swap(x,y);\n    //if(yy[x]||yy[y]) cout<<yy[x]<<\" \"<<yy[y]<<endl;\n    r[x]+=r[y];\n    p[y]=x;\n    return 1;\n  }\n};\nstruct edge{\n  int from,to,cost;\n  edge(){}\n  edge(int from,int to,Int cost):from(from),to(to),cost(cost){}\n  bool operator<(const edge& e) const{\n    return cost>e.cost;\n  }\n};\nInt kruskal(int N,vector<edge> edges,vector<int> y,int t,int k){\n  Int res=0;\n  sort(edges.begin(),edges.end());\n  UnionFind uf(N+1,y,t-(k+1));\n  int cnt=N-1-k;\n  //cout<<k<<\" \"<<cnt<<endl;\n  for(int i=0;cnt&&i<(int)edges.size();i++){\n    edge e=edges[i];\n    if(!uf.same(e.from,e.to)){\n      if(uf.unite(e.from,e.to)) res+=e.cost,cnt--;\n    }\n  }\n  return res;\n}\n\n\nsigned main(){\n  \n  Int n,t,k;\n  Int cnt=0;\n  while(cin>>n>>t>>k,n){\n    vector<edge> edges;\n    Int sum=0;\n    for(Int i=0;i<n-1;i++){\n      Int a,b,c;\n      cin>>a>>b>>c;\n      a--;b--;\n      edges.push_back(edge(a,b,c));\n      sum+=c;\n    }\n    \n    vector<int> x(t);\n    for(Int i=0;i<t;i++) cin>>x[i];\n    vector<int> y(n,0);\n    for(Int i=0;i<t;i++) y[--x[i]]=1;\n    \n    cout<<\"Case \"<<++cnt<<\": \"<<sum-kruskal(n,edges,y,t,k)<<endl;\n  }\n  return 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\nusing namespace std;\n\n#define rep(i, n) for (ll i = 0; i < (ll)(n); i++)\n#define rept(i,k,n) for(int i = (k); i < (int)(n); i++)\n#define Sort(v) sort(v.begin(),v.end())\n#define Reverse(v) reverse(v.begin(),v.end())\n#define X first\n#define Y second\n\ntypedef long long ll;\ntypedef pair<double,double> Pdd;\ntypedef pair<int,int> Pii;\n\nstruct UnionFind {\n    vector<int> par; // par[i]:iの親の番号\n    vector<int> siz; \n\n    UnionFind(int N) : par(N), siz(N,1) { //全てが根であるとして初期化\n        for(int i = 0; i < N; i++) par[i] = i;\n    }\n\n    int root(int x) { // データxが属する木の根を再帰で得る：root(x) = {xの木の根}\n        if (par[x] == x) return x;\n        return par[x] = root(par[x]); //根に行くまでに辿ったノードを根に直接付け替える\n    }\n\n    void unite(int x, int y) { // xとyの木を併合\n        int rx = root(x); //xの根をrx\n        int ry = root(y); //yの根をry\n        if (rx == ry) return; //xとyの根が同じ(=同じ木にある)時はそのまま\n        if (siz[rx] < siz[ry]) swap(rx, ry); //小を大にくっつける\n        siz[rx] += siz[ry];\n        par[ry] = rx;\n    }\n\n    bool same(int x, int y) { // 2つのデータx, yが属する木が同じならtrueを返す\n        int rx = root(x);\n        int ry = root(y);\n        return rx == ry;\n    }\n\n    int size(int x){ // 素集合のサイズ\n        return siz[root(x)];\n    }\n};\n\nint main(){\n    int cnt=0;\n    while(true){\n        int n,t,k;\n        cin>>n>>t>>k;\n        cnt++;\n        if(n+t+k==0) return 0;\n        vector<vector<int>> edge(n-1,vector<int>(3));\n        int cost=0;\n        rep(i,n-1){\n            cin>>edge[i][0]>>edge[i][1]>>edge[i][2];\n            edge[i][0]--; edge[i][1]--;\n            cost += edge[i][2];\n        }\n        vector<bool> bs(n,false);\n        rep(i,t){\n            int a;\n            cin>>a;\n            bs[a-1]=true;\n        }\n        sort(edge.begin(), edge.end(), [](vector<int> a, vector<int> b) { return a[2] > b[2]; });\n       // rep(i,n-1) cout<<edge[i][0]<<edge[i][1]<<edge[i][2]<<endl;\n       UnionFind uf(n);\n       int cut = t-1-k;\n       for(auto eg: edge){\n            int r1 = uf.root(eg[0]), r2 = uf.root(eg[1]);\n            if(bs[r1] && bs[r2] && cut==0) continue;\n            if(bs[r1] && bs[r2]) cut--;\n            uf.unite(r1,r2);\n            cost-=eg[2];\n            bool bs1=bs[r1], bs2=bs[r2];\n            bs[r1] = bs[r1] || bs2;\n            bs[r2] = bs[r2] || bs1;\n       }\n       cout << \"Case \" << cnt << \": \" << cost << endl;\n    }\n    return 0;\n}\n"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\n#define ll long long\n#define INF 1000000005\n#define MOD 1000000007\n#define EPS 1e-10\n#define rep(i,n) for(int i=0;i<(int)(n);++i)\n#define rrep(i,n) for(int i=(int)(n)-1;i>=0;--i)\n#define srep(i,s,t) for(int i=(int)(s);i<(int)(t);++i)\n#define each(a,b) for(auto& (a): (b))\n#define all(v) (v).begin(),(v).end()\n#define len(v) (int)(v).size()\n#define zip(v) sort(all(v)),v.erase(unique(all(v)),v.end())\n#define cmx(x,y) x=max(x,y)\n#define cmn(x,y) x=min(x,y)\n#define fi first\n#define se second\n#define pb push_back\n#define show(x) cout<<#x<<\" = \"<<(x)<<endl\n#define spair(p) cout<<#p<<\": \"<<p.fi<<\" \"<<p.se<<endl\n#define sar(a,n) cout<<#a<<\":\";rep(kbrni,n)cout<<\" \"<<a[kbrni];cout<<endl\n#define svec(v) cout<<#v<<\":\";rep(kbrni,v.size())cout<<\" \"<<v[kbrni];cout<<endl\n#define svecp(v) cout<<#v<<\":\";each(kbrni,v)cout<<\" {\"<<kbrni.first<<\":\"<<kbrni.second<<\"}\";cout<<endl\n#define sset(s) cout<<#s<<\":\";each(kbrni,s)cout<<\" \"<<kbrni;cout<<endl\n#define smap(m) cout<<#m<<\":\";each(kbrni,m)cout<<\" {\"<<kbrni.first<<\":\"<<kbrni.second<<\"}\";cout<<endl\n\nusing namespace std;\n\ntypedef pair<int,int> P;\ntypedef pair<ll,ll> pll;\ntypedef vector<int> vi;\ntypedef vector<vi> vvi;\ntypedef vector<ll> vl;\ntypedef vector<vl> vvl;\ntypedef vector<double> vd;\ntypedef vector<P> vp;\ntypedef vector<string> vs;\n\nconst int MAX_N = 10005;\n\nstruct edge\n{\n    int to,cost;\n};\n\nvector<edge> G[MAX_N];\nbool ok[MAX_N];\nint sub[MAX_N];\nint n,t,k;\n\nvoid dfs(int u,int p)\n{\n    sub[u] = 1;\n    each(e,G[u]){\n        int v = e.to;\n        if(p != v){\n            dfs(v,u);\n            sub[u] += sub[v];\n        }\n    }\n}\n\nvvi redfs(int u,int p)\n{\n    vvi dp(2,vi(sub[u]+1,INF));\n    int mx = 1;\n    if(ok[u]){\n        dp[1][1] = 0;\n    }else{\n        dp[0][1] = 0;\n    }\n    each(e,G[u]){\n        cmn(mx,k+1);\n        int v = e.to, c = e.cost;\n        if(p != v){\n            vvi res = redfs(v,u);\n            vvi dp2(2,vi(mx+len(res[0]),INF));\n            srep(i,1,mx+1){\n                srep(j,1,len(res[0])){\n                    if(ok[u]){\n                        cmn(dp2[1][i+j-1],dp[1][i]+res[0][j]);\n                        cmn(dp2[1][i+j-1],dp[1][i]+res[1][j]);\n                        cmn(dp2[1][i+j],dp[1][i]+res[1][j]+c);\n                    }else{\n                        cmn(dp2[0][i+j-1],dp[0][i]+res[0][j]);\n                        cmn(dp2[0][i+j],dp[0][i]+res[1][j]+c);\n                        cmn(dp2[1][i+j-1],dp[0][i]+res[1][j]);\n                        cmn(dp2[1][i+j-1],dp[1][i]+res[0][j]);\n                        cmn(dp2[1][i+j-1],dp[1][i]+res[1][j]);\n                        cmn(dp2[1][i+j],dp[1][i]+res[1][j]+c);\n                    }\n                }\n            }\n            mx += len(res[0]) - 1;\n            rep(i,2){\n                rep(j,mx+1){\n                    dp[i][j] = dp2[i][j];\n                }\n            }\n        }\n    }\n    return dp;\n}\n\nint main()\n{\n    cin.tie(0);\n    ios::sync_with_stdio(false);\n    int id = 0;\n    while(1){\n        cin >> n >> t >> k;\n        if(n == 0){\n            break;\n        }\n        rep(i,n){\n            G[i].clear(),ok[i] = false;\n        }\n        rep(i,n-1){\n            int a,b,c;\n            cin >> a >> b >> c;\n            G[a-1].pb((edge){b-1,c}),G[b-1].pb((edge){a-1,c});\n        }\n        rep(i,t){\n            int a;\n            cin >> a;\n            --a;\n            ok[a] = true;\n        }\n        if(k == 0){\n            cout << \"Case \" << ++id << \": 0\" << endl;\n            continue;\n        }\n        dfs(0,-1);\n        vvi ans = redfs(0,-1);\n        cout << \"Case \" << ++id << \": \" << ans[1][k+1] << endl;\n    }\n    return 0;\n}\n\n"
  },
  {
    "language": "C++",
    "code": "#include <iostream>\n#include <vector>\n#include <map>\n#include <algorithm>\nusing namespace std;\n\nconst int MAX_V = 100000;\ntypedef pair<int,int> P;\nstruct edge{ int to,cost; };\n\n// グラフ (隣接リスト)\nvector<edge> G[MAX_V];\n// e = (u,v) , is_cost[e] := コスト\nmap<P,int> is_cost;\n// base[u] == true のとき ノード u は ベース\nbool base[MAX_V];\n// (cost,(u,v))の組\nvector< pair<int ,P> > a;\n// used[u] == true のとき ノード u は探索済み\nbool used[MAX_V];\n\nint n, t, k;\n\n\n// 初期化\nvoid init(){\n\ta.clear();\n\tis_cost.clear();\n\tfor(int i=0 ; i < MAX_V ; i++ ){\n\t\tbase[i] = false;\n\t\tG[i].clear();\n\t}\n}\n\n// グラフに重みcostのエッジ(u,v)を追加\nvoid add_edge(int u, int v, int cost){\n\tedge e;\n\te.to = v;\n\te.cost = cost;\n\tG[u].push_back( e );\n\te.to = u;\n\tG[v].push_back( e );\n}\n\n// グラフのエッジ(u,v)を切断\nvoid cut_edge(int u, int v){\n\tfor(vector<edge>::iterator it = G[u].begin() ; it != G[u].end() ; ++it ){\n\t\tif( (*it).to == v ){\n\t\t\tG[u].erase( it );\n\t\t\treturn ;\n\t\t}\n\t}\n}\n\n\n// ノード u の木にベースがあるかどうか\nvoid is_base(int u, bool& flag){\n\t\n\t// ノード u がベースのとき\n\tif( base[u] || flag ){\n\t\tflag = true;\n\t\treturn;\n\t}\n\t// ノード u が探索済みのとき\n\tif( used[u] ) return;\n\tused[u] = true;\n\t\n\tfor(int i=0 ; i < G[u].size() ; i++ ){\n\t\tedge e = G[u][i];\n\t\tis_base( e.to , flag );\n\t}\n}\n\nint solve(){\n\t\n\t// 連結成分の数\n\tint p=1;\n\t// コストの総和\n\tint sum = 0;\n\t\n\tsort( a.begin() , a.end() );\n\t/*for(int i=0 ; i < a.size() ; i++ ){\n\t\tint cost = a[i].first;\n\t\tint u = a[i].second.first;\n\t\tint v = a[i].second.second;\n\t\tif( u > v ) swap(u,v);\n\t\t\n\t\t//cut_edge( u , v );\n\t\t\n\t\tbool flag1 = false, flag2 = false;\n\t\tfor(int j=0 ; j < MAX_V ; j++ ) used[j] = false;\n\t\t//is_base( u , flag1 );\n\t\tfor(int j=0 ; j < MAX_V ; j++ ) used[j] = false;\n\t\t//is_base( v , flag2 );\n\t\t//flag1 = flag2 = true;\n\t\t\n\t\t// u,vの木の両方にベースを含むとき切断する\n\t\tif( flag1 && flag2 ){\n\t\t\t//sum += is_cost[P(u,v)];\n\t\t\tp++;\n\t\t}else{\n\t\t\t//add_edge( u , v , is_cost[P(u,v)] );\n\t\t}\n\t\t\n\t\t// 連結成分が K+1 個になったらループを抜ける\n\t\tif( p == k+1 ) break;\n\t}*/\n\treturn sum;\n}\n\nint main(){\n\tfor(int t_ = 1 ; cin >> n >> t >> k , (n || t || k) ; t_++ ){\n\t\t// 初期化\n\t\tinit();\n\t\t\n\t\tfor(int i = 0 ; i < n-1 ; i++ ){\n\t\t\tint u, v, cost;\n\t\t\tcin >> u >> v >> cost;\n\t\t\tu--; v--;\n\t\t\tif( u > v ) swap(u,v);\n\t\t\t\n\t\t\tis_cost[P(u,v)] = cost;\n\t\t\tadd_edge( u , v , cost );\n\t\t\tpair<int,P> p( cost , P(u,v) );\n\t\t\ta.push_back( p );\n\t\t}\n\t\tfor(int i = 0 ; i < t ; i++ ){\n\t\t\tint b;\n\t\t\tcin >> b;\n\t\t\tb--;\n\t\t\tbase[b] = true;\n\t\t}\n\t\t\n\t\tint ans = solve();\n\t\tcout << \"Case \" << t_ << \": \" << ans << endl;\n\t}\n}"
  },
  {
    "language": "C++",
    "code": "#include<bits/stdc++.h>\n\nusing namespace std;\n\nstruct UnionFind\n{\n  vector< int > data;\n  vector< bool > flag;\n\n  UnionFind(int sz)\n  {\n    data.assign(sz, -1);\n    flag.assign(sz, false);\n  }\n\n  bool unite(int x, int y)\n  {\n    x = find(x), y = find(y);\n    if(x == y) return (false);\n    if(flag[y]) swap(x, y);\n    data[x] += data[y];\n    data[y] = x;\n    return (true);\n  }\n\n  int find(int k)\n  {\n    if(data[k] < 0) return (k);\n    return (data[k] = find(data[k]));\n  }\n\n  int size(int k)\n  {\n    return (-data[find(k)]);\n  }\n};\n\nint main()\n{\n  int N, T, K;\n  int A[10000], B[10000], C[10000];\n  int testcase = 1;\n\n  while(scanf(\"%d %d %d\", &N, &T, &K), N) {\n    vector< pair< int, int > > es;\n    for(int i = 1; i < N; i++) {\n      scanf(\"%d %d %d\", &A[i], &B[i], &C[i]);\n      --A[i], --B[i];\n      es.emplace_back(C[i], i);\n    }\n    UnionFind uf(N);\n    for(int i = 0; i < T; i++) {\n      int x;\n      scanf(\"%d\", &x);\n      uf.flag[--x] = true;\n    }\n    sort(es.rbegin(), es.rend());\n    int ret = 0;\n    vector< int > costs;\n    for(auto &e : es) {\n      int x = uf.find(A[e.second]);\n      int y = uf.find(B[e.second]);\n      if(x != y) {\n        if(uf.flag[x] && uf.flag[y]) costs.emplace_back(C[e.second]);\n        uf.unite(x, y);\n      }\n    }\n    reverse(begin(costs), end(costs));\n\n    printf(\"Case %d: %d\\n\", testcase++, accumulate(begin(costs), begin(costs) + K, 0));\n  }\n}"
  },
  {
    "language": "C++",
    "code": "#include <iostream>\n#include <cstdio>\n#include <vector>\n#include <algorithm>\nusing namespace std;\n#define rep(i,n) for(int i=0;i<(n);++i)\n#define rep1(i,n) for(int i=1;i<=(n);++i)\n#define all(c) (c).begin(),(c).end()\n#define pb push_back\n#define show(x) cout << #x << \" \" << x << endl\nstruct edge{int from,to,cost;};\nbool operator<(const edge& x,const edge& y){\n\treturn x.cost>y.cost;\n}\nint par[10000],id[10000];\nvoid init(int n){\n\trep(i,n) par[i]=i;\n\trep(i,n) id[i]=-1;\n}\nint find(int x){\n\tif(x==par[x]) return x;\n\telse return par[x]=find(par[x]);\n}\nvoid unite(int x,int y){\n\tx=find(x),y=find(y);\n\tif(id[x]>=0) par[y]=x;\n\telse par[x]=y;\n}\nvector<edge> es;\nvector<int> costs;\nint main(){\n\tint tt=0;\n\twhile(true){\n\t\ttt++;\n\t\tint n,t,k;\n\t\tcin>>n>>t>>k;\n\t\tif(n==0) break;\n\t\tes.clear();\n\t\tinit(n);\n\t\trep(i,n-1){\n\t\t\tint a,b,c;\n\t\t\tcin>>a>>b>>c;\n\t\t\tes.pb(edge{a-1,b-1,c});\n\t\t}\n\t\trep(i,t){\n\t\t\tint x;\n\t\t\tcin>>x;\n\t\t\tid[x-1]=x-1;\n\t\t}\n\t\tsort(all(es));\n\t\tcosts.clear();\n\t\trep(i,n-1){\n\t\t\tint a=es[i].from,b=es[i].to,c=es[i].cost;\n\t\t\ta=find(a),b=find(b);\n\t\t\tif(id[a]>=0&&id[b]>=0) costs.pb(c);\n\t\t\telse unite(a,b);\n\t\t}\n\t\tsort(all(costs));\n//\t\tshow(costs.size());\n\t\tint sum=0;\n\t\trep(i,k) sum+=costs[i];\n\t\tprintf(\"Case %d: %d\\n\",tt,sum);\n\t}\n}"
  },
  {
    "language": "C++",
    "code": "#include<bits/stdc++.h>\nusing namespace std;\n\nstruct unionfind{\n  int parent[200000];\n  int size[200000];\n  \n  void init(int n){\n    for(int i=0;i<n;i++){\n      parent[i]=i;\n      size[i]=1;\n    }\n  }\n  int find(int x){\n    if(parent[x]==x)return x;\n    else parent[x]=find(parent[x]);\n  }\n  bool same(int x,int y){\n    return (find(x)==find(y));\n  }\n  int getSize(int x){\n    return size[ find(x) ];\n  }\n  void unite(int x,int y){\n    x=find(x);\n    y=find(y);\n    if(x==y)return;\n    if(size[x]>size[y])swap(x,y);\n    parent[x]=y;\n    size[y]+=size[x];\n  }\n};\n  \nstruct edge{\n  int from,to,cost;\n  bool operator < (const edge &e) const {\n    return cost < e.cost;\n  }\n};\n\nint n,t,k;\nunionfind uf;\n\nint main(){\n\n  \n  for(int tc=1;;tc++){\n    cin>>n>>t>>k;\n    if(n==0&&t==0&&k==0)break;\n    vector<edge> E;\n\n    uf.init(n);\n    \n    for(int i=0;i<n-1;i++){\n      int a,b,c;\n      cin>>a>>b>>c;\n      a--,b--;\n      E.push_back( (edge){a,b,-c} );\n      uf.unite(a,b);\n    }\n    assert( uf.getSize(0) == n );\n    \n    for(int i=0;i<t;i++){\n      int a;\n      cin>>a;\n      a--;\n      E.push_back( (edge){a,n,-20000} );\n    }\n    sort(E.begin(),E.end());\n    \n    uf.init(n+1);\n\n    vector<edge> tmp;\n    \n    for(int i=0;i<(int)E.size();i++){\n      edge e=E[i];\n      if( uf.same(e.from,e.to) ){\n        tmp.push_back(e);\n      }else{\n        uf.unite(e.from,e.to);\n      }\n    }\n\n    int ans=0;\n    //    assert( (int)tmp.size() == t-1 );\n    \n    cout<<\"Case \"<<tc<<\": \"<<ans<<endl;\n    \n  }\n  return 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include <iostream>\n#include <fstream>\n#include <cassert>\n#include <typeinfo>\n#include <vector>\n#include <stack>\n#include <cmath>\n#include <set>\n#include <map>\n#include <string>\n#include <algorithm>\n#include <cstdio>\n#include <queue>\n#include <iomanip>\n#include <cctype>\n#include <random>\n#include <complex>\n#define syosu(x) fixed<<setprecision(x)\nusing namespace std;\ntypedef long long ll;\ntypedef unsigned long long ull;\ntypedef pair<int,int> P;\ntypedef pair<double,double> pdd;\ntypedef pair<ll,ll> pll;\ntypedef vector<int> vi;\ntypedef vector<vi> vvi;\ntypedef vector<double> vd;\ntypedef vector<vd> vvd;\ntypedef vector<ll> vl;\ntypedef vector<vl> vvl;\ntypedef vector<char> vc;\ntypedef vector<vc> vvc;\ntypedef vector<string> vs;\ntypedef vector<bool> vb;\ntypedef vector<vb> vvb;\ntypedef vector<P> vp;\ntypedef vector<vp> vvp;\ntypedef vector<pll> vpll;\ntypedef pair<int,P> pip;\ntypedef vector<pip> vip;\nconst int inf=1<<29;\nconst ll INF=1ll<<58;\nconst double pi=acos(-1);\nconst double eps=1e-7;\nconst ll mod=1e9+7;\nconst int dx[4]={0,1,0,-1},dy[4]={1,0,-1,0};\n\nclass Union_Find_Tree{\n\tpublic:\n\tvi Par,Rank;\n\tUnion_Find_Tree(int n){\n\t\tPar=Rank=vi(n);\n\t\tfor(int i=0;i<n;i++) Par[i]=i;\n\t}\n\tint Find_Par(int x){\n\t\tif(Par[x]==x) return x;\n\t\treturn Par[x]=Find_Par(Par[x]);\n\t}\n\tbool Unite(int x,int y){\n\t\tx=Find_Par(x);\n\t\ty=Find_Par(y);\n\t\tif(x==y) return 0;\n\t\tif(Rank[x]<Rank[y]) Par[x]=y;\n\t\telse{\n\t\t\tPar[y]=x;\n\t\t\tif(Rank[x]==Rank[y]) Rank[x]++;\n\t\t}\n\t\treturn 1;\n\t}\n\tbool Same(int x,int y){\n\t\treturn Find_Par(x)==Find_Par(y);\n\t}\n};\n\nint n,t,k;\nvip a;\n\nint main(){\n\tint cnt=1;\n\twhile(1){\n\t\tcin>>n>>t>>k;\n\t\tif(!n) break;\n\t\ta=vip(n-1);\n\t\tint res=0;\n\t\tfor(int i=0;i<n-1;i++){\n\t\t\tint u,v,c;\n\t\t\tcin>>u>>v>>c;\n\t\t\ta[i]={c,{u,v}};\n\t\t}\n\t\tsort(a.rbegin(),a.rend());\n\t\tUnion_Find_Tree uft(n+1);\n\t\tfor(int i=0;i<t;i++){\n\t\t\tint v;\n\t\t\tcin>>v;\n\t\t\tuft.Unite(0,v);\n\t\t}\n\t\tfor(int i=0;i<n-1;i++){\n\t\t\tP p=a[i].second;\n\t\t\tint c=a[i].first,u=p.first,v=p.second;\n\t\t\tif(uft.Same(u,v)){\n\t\t\t\tt--;\n\t\t\t\tif(t<=k) res+=c;\n\t\t\t}\n\t\t\telse uft.Unite(u,v);\n\t\t}\n\t\tcout<<\"Case \"<<cnt<<\": \"<<res<<endl;\n\t\tcnt++;\n\t}\n}"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\n#define ll long long\n#define INF 1000000005\n#define MOD 1000000007\n#define EPS 1e-10\n#define rep(i,n) for(int i=0;i<(int)(n);++i)\n#define rrep(i,n) for(int i=(int)(n)-1;i>=0;--i)\n#define srep(i,s,t) for(int i=(int)(s);i<(int)(t);++i)\n#define each(a,b) for(auto& (a): (b))\n#define all(v) (v).begin(),(v).end()\n#define len(v) (int)(v).size()\n#define zip(v) sort(all(v)),v.erase(unique(all(v)),v.end())\n#define cmx(x,y) x=max(x,y)\n#define cmn(x,y) x=min(x,y)\n#define fi first\n#define se second\n#define pb push_back\n#define show(x) cout<<#x<<\" = \"<<(x)<<endl\n#define spair(p) cout<<#p<<\": \"<<p.fi<<\" \"<<p.se<<endl\n#define sar(a,n) cout<<#a<<\":\";rep(kbrni,n)cout<<\" \"<<a[kbrni];cout<<endl\n#define svec(v) cout<<#v<<\":\";rep(kbrni,v.size())cout<<\" \"<<v[kbrni];cout<<endl\n#define svecp(v) cout<<#v<<\":\";each(kbrni,v)cout<<\" {\"<<kbrni.first<<\":\"<<kbrni.second<<\"}\";cout<<endl\n#define sset(s) cout<<#s<<\":\";each(kbrni,s)cout<<\" \"<<kbrni;cout<<endl\n#define smap(m) cout<<#m<<\":\";each(kbrni,m)cout<<\" {\"<<kbrni.first<<\":\"<<kbrni.second<<\"}\";cout<<endl\n\nusing namespace std;\n\ntypedef pair<int,int> P;\ntypedef pair<ll,ll> pll;\ntypedef vector<int> vi;\ntypedef vector<vi> vvi;\ntypedef vector<ll> vl;\ntypedef vector<vl> vvl;\ntypedef vector<double> vd;\ntypedef vector<P> vp;\ntypedef vector<string> vs;\n\nconst int MAX_N = 10005;\n\nstruct edge\n{\n    int to,cost;\n};\n\nvector<edge> G[MAX_N];\nbool ok[MAX_N];\nint sub[MAX_N];\nint n,t,k;\n\nvoid dfs(int u,int p)\n{\n    sub[u] = 1;\n    each(e,G[u]){\n        int v = e.to;\n        if(p != v){\n            dfs(v,u);\n            sub[u] += sub[v];\n        }\n    }\n}\n\nvvi redfs(int u,int p)\n{\n    vvi dp(2,vi(sub[u]+1,INF));\n    int mx = 1;\n    if(ok[u]){\n        dp[1][1] = 0;\n    }else{\n        dp[0][1] = 0;\n    }\n    each(e,G[u]){\n        cmn(mx,k+1);\n        int v = e.to, c = e.cost;\n        if(p != v){\n            vvi res = redfs(v,u);\n            vvi dp2(2,vi(mx+len(res[0]),INF));\n            srep(i,1,mx+1){\n                srep(j,1,len(res[0])){\n                    if(ok[u]){\n                        cmn(dp2[1][i+j-1],dp[1][i]+res[0][j]);\n                        cmn(dp2[1][i+j-1],dp[1][i]+res[1][j]);\n                        cmn(dp2[1][i+j],dp[1][i]+res[1][j]+c);\n                    }else{\n                        cmn(dp2[0][i+j-1],dp[0][i]+res[0][j]);\n                        cmn(dp2[0][i+j],dp[0][i]+res[1][j]+c);\n                        cmn(dp2[1][i+j-1],dp[0][i]+res[1][j]);\n                        cmn(dp2[1][i+j-1],dp[1][i]+res[0][j]);\n                        cmn(dp2[1][i+j-1],dp[1][i]+res[1][j]);\n                        cmn(dp2[1][i+j],dp[1][i]+res[1][j]+c);\n                    }\n                }\n            }\n            mx += len(res[0]) - 1;\n            rep(i,2){\n                rep(j,mx+1){\n                    dp[i][j] = dp2[i][j];\n                }\n            }\n            rep(i,len(res)){\n                res[i].clear();\n            }\n            rep(i,len(mx+len(res[0])){\n                dp2[i].clear();\n            }\n        }\n    }\n    return dp;\n}\n\nint main()\n{\n    cin.tie(0);\n    ios::sync_with_stdio(false);\n    int id = 0;\n    while(1){\n        cin >> n >> t >> k;\n        if(n == 0){\n            break;\n        }\n        rep(i,n){\n            G[i].clear(),ok[i] = false;\n        }\n        rep(i,n-1){\n            int a,b,c;\n            cin >> a >> b >> c;\n            G[a-1].pb((edge){b-1,c}),G[b-1].pb((edge){a-1,c});\n        }\n        rep(i,t){\n            int a;\n            cin >> a;\n            --a;\n            ok[a] = true;\n        }\n        if(k == 0){\n            cout << \"Case \" << ++id << \": 0\" << endl;\n            continue;\n        }\n        dfs(0,-1);\n        vvi ans = redfs(0,-1);\n        cout << \"Case \" << ++id << \": \" << ans[1][k+1] << endl;\n    }\n    return 0;\n}\n\n"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\n#define ll long long\n#define INF 1000000005\n#define MOD 1000000007\n#define EPS 1e-10\n#define rep(i,n) for(int i=0;i<(int)(n);++i)\n#define rrep(i,n) for(int i=(int)(n)-1;i>=0;--i)\n#define srep(i,s,t) for(int i=(int)(s);i<(int)(t);++i)\n#define each(a,b) for(auto& (a): (b))\n#define all(v) (v).begin(),(v).end()\n#define len(v) (int)(v).size()\n#define zip(v) sort(all(v)),v.erase(unique(all(v)),v.end())\n#define cmx(x,y) x=max(x,y)\n#define cmn(x,y) x=min(x,y)\n#define fi first\n#define se second\n#define pb push_back\n#define show(x) cout<<#x<<\" = \"<<(x)<<endl\n#define spair(p) cout<<#p<<\": \"<<p.fi<<\" \"<<p.se<<endl\n#define sar(a,n) cout<<#a<<\":\";rep(kbrni,n)cout<<\" \"<<a[kbrni];cout<<endl\n#define svec(v) cout<<#v<<\":\";rep(kbrni,v.size())cout<<\" \"<<v[kbrni];cout<<endl\n#define svecp(v) cout<<#v<<\":\";each(kbrni,v)cout<<\" {\"<<kbrni.first<<\":\"<<kbrni.second<<\"}\";cout<<endl\n#define sset(s) cout<<#s<<\":\";each(kbrni,s)cout<<\" \"<<kbrni;cout<<endl\n#define smap(m) cout<<#m<<\":\";each(kbrni,m)cout<<\" {\"<<kbrni.first<<\":\"<<kbrni.second<<\"}\";cout<<endl\n\nusing namespace std;\n\ntypedef pair<int,int> P;\ntypedef pair<ll,ll> pll;\ntypedef vector<int> vi;\ntypedef vector<vi> vvi;\ntypedef vector<ll> vl;\ntypedef vector<vl> vvl;\ntypedef vector<double> vd;\ntypedef vector<P> vp;\ntypedef vector<string> vs;\n\nconst int MAX_N = 10005;\n\nstruct edge\n{\n    int to,cost;\n};\n\nvector<edge> G[MAX_N];\nbool ok[MAX_N];\nint sub[MAX_N];\nint n,t,k;\n\nvoid dfs(int u,int p)\n{\n    sub[u] = 1;\n    each(e,G[u]){\n        int v = e.to;\n        if(p != v){\n            dfs(v,u);\n            sub[u] += sub[v];\n        }\n    }\n}\n\nvoid redfs(int u,int p,vvi& dp)\n{\n    int mx = 1;\n    if(ok[u]){\n        dp[1][1] = 0;\n    }else{\n        dp[0][1] = 0;\n    }\n    each(e,G[u]){\n        cmn(mx,k+1);\n        int v = e.to, c = e.cost;\n        if(p != v){\n            vvi res(2,vi(sub[v]+1,INF));\n            redfs(v,u,res);\n            vvi dp2(2,vi(mx+len(res[0]),INF));\n            srep(i,1,mx+1){\n                srep(j,1,len(res[0])){\n                    if(ok[u]){\n                        cmn(dp2[1][i+j-1],dp[1][i]+res[0][j]);\n                        cmn(dp2[1][i+j-1],dp[1][i]+res[1][j]);\n                        cmn(dp2[1][i+j],dp[1][i]+res[1][j]+c);\n                    }else{\n                        cmn(dp2[0][i+j-1],dp[0][i]+res[0][j]);\n                        cmn(dp2[0][i+j],dp[0][i]+res[1][j]+c);\n                        cmn(dp2[1][i+j-1],dp[0][i]+res[1][j]);\n                        cmn(dp2[1][i+j-1],dp[1][i]+res[0][j]);\n                        cmn(dp2[1][i+j-1],dp[1][i]+res[1][j]);\n                        cmn(dp2[1][i+j],dp[1][i]+res[1][j]+c);\n                    }\n                }\n            }\n            mx += len(res[0]) - 1;\n            rep(i,2){\n                rep(j,mx+1){\n                    dp[i][j] = dp2[i][j];\n                }\n            }\n        }\n    }\n}\n\nint main()\n{\n    cin.tie(0);\n    ios::sync_with_stdio(false);\n    int id = 0;\n    while(1){\n        cin >> n >> t >> k;\n        if(n == 0){\n            break;\n        }\n        rep(i,n){\n            G[i].clear(),ok[i] = false;\n        }\n        rep(i,n-1){\n            int a,b,c;\n            cin >> a >> b >> c;\n            G[a-1].pb((edge){b-1,c}),G[b-1].pb((edge){a-1,c});\n        }\n        rep(i,t){\n            int a;\n            cin >> a;\n            --a;\n            ok[a] = true;\n        }\n        if(k == 0){\n            cout << \"Case \" << ++id << \": 0\" << endl;\n            continue;\n        }\n        dfs(0,-1);\n        vvi ans(2,vi(sub[0]+1,INF));\n        redfs(0,-1,ans);\n        cout << \"Case \" << ++id << \": \" << ans[1][k+1] << endl;\n    }\n    return 0;\n}\n\n"
  },
  {
    "language": "C++",
    "code": "#include \"bits/stdc++.h\"\n#include<unordered_map>\n#include<unordered_set>\n#pragma warning(disable:4996)\nusing namespace std;\nusing ld = long double;\ntemplate<class T>\nusing Table = vector<vector<T>>;\nconst ld eps=1e-9;\n\n//// < \"D:\\D_Download\\Visual Studio 2015\\Projects\\programing_contest_c++\\Debug\\a.txt\" > \"D:\\D_Download\\Visual Studio 2015\\Projects\\programing_contest_c++\\Debug\\b.answer\"\nint get_c(const int now, const int from, vector<int>&childs,const vector<vector<pair<int,int>>>&es) {\n\tint num = 1;\n\tfor (auto e : es[now]) {\n\t\tif (e.first == from)continue;\n\t\telse {\n\t\t\tnum += get_c(e.first, now, childs, es);\n\t\t}\n\t}\n\treturn childs[now] = num;\n}\nvector<vector<int>>dfs(const vector<int>&bases,const int now, const int from,const vector<int>&childs, const vector<vector<pair<int,int>>>&edges) {\n\tvector<vector<int>>memo(2, vector<int>(childs[now],int(1e9)));\n\tif (bases[now]) {\n\t\tmemo[1][0] = 0;\n\t\tmemo[0][0] = 1e9;\n\t}\n\telse {\n\t\tmemo[0][0] = 0;\n\t\tmemo[1][0] = 1e9;\n\t}\n\tfor (auto e : edges[now]) {\n\t\tif (e.first == from)continue;\n\t\telse {\n\t\t\tvector<vector<int>>newmemo(memo);\n\t\t\tauto d(dfs(bases, e.first, now, childs, edges));\n\t\t\tfor (int i = 0; i < 2; ++i) {\n\t\t\t\tfor (int j = 0; j < 2; ++j) {\n\t\t\t\t\tfor (int k = 0; k < d[0].size(); ++k) {\n\t\t\t\t\t\tfor (int l = 0; l < memo[0].size(); ++l) {\n\t\t\t\t\t\t\tif (memo[j][l]<1e9) {\n\t\t\t\t\t\t\t\tif (!i&&!j) {\n\t\t\t\t\t\t\t\t\tnewmemo[0][k + l] = min(memo[0][k + l], memo[0][l] + d[0][k]);\n\t\t\t\t\t\t\t\t}\n\t\t\t\t\t\t\t\telse if (!i&&j) {\n\t\t\t\t\t\t\t\t\tnewmemo[1][k + l] = min(memo[1][k + l], memo[0][l] + d[0][k]);\n\t\t\t\t\t\t\t\t}\n\t\t\t\t\t\t\t\telse if (i&&!j) {\n\t\t\t\t\t\t\t\t\tnewmemo[1][k + l] = min(memo[1][k + l], memo[0][l] + d[1][k]);\n\t\t\t\t\t\t\t\t\tnewmemo[0][k + l + 1] = min(memo[0][k + l + 1], memo[0][l] + d[1][k] + e.second);\n\t\t\t\t\t\t\t\t}\n\t\t\t\t\t\t\t\telse {\n\t\t\t\t\t\t\t\t\tnewmemo[1][k + l] = min(memo[1][k + l], memo[1][l] + d[1][k]);\n\t\t\t\t\t\t\t\t\tnewmemo[1][k + l + 1] = min(memo[1][k + l + 1], memo[1][l] + d[1][k] + e.second);\n\n\t\t\t\t\t\t\t\t}\n\t\t\t\t\t\t\t}\n\t\t\t\t\t\t}\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t}\n\t\t\tmemo = newmemo;\n\t\t}\n\t}\n\treturn memo;\n}\n\nint main() {\n\tint num = 0;\n\twhile (1) {\n\t\tnum++;\n\t\tint N, T, K; cin >> N >> T >> K;\n\t\tif (!N)break;\n\t\tvector<vector<pair<int,int>>>edges(N);\n\t\tvector<int>childs(N);\n\t\tvector<int>bases(N);\n\t\tfor (int i = 0; i < N - 1; ++i) {\n\t\t\tint s, t, c; cin >> s >> t >> c; s--; t--;\n\t\t\tedges[s].push_back(make_pair(t, c));\n\t\t\tedges[t].push_back(make_pair(s, c));\n\t\t}\n\t\tfor (int i = 0; i < N; ++i) {\n\t\t\tsort(edges[i].begin(), edges[i].end(), [](const pair<int, int>&l, const pair<int, int>&r) {\n\t\t\t\treturn l.second > r.second;\n\t\t\t});\n\t\t}\n\t\tfor (int i = 0; i < T; ++i) {\n\t\t\tint a; cin >> a; a--;\n\t\t\tbases[a] = 1;\n\t\t}\n\t\tget_c(0, -1, childs, edges);\n\t\tauto v(dfs(bases, 0, -1, childs, edges));\n\t\tcout << \"Case \" << num << \": \" << v[1][K] << endl;\n\t}\n\treturn 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\n#define ll long long\n#define INF 1000000005\n#define MOD 1000000007\n#define EPS 1e-10\n#define rep(i,n) for(int i=0;i<(int)(n);++i)\n#define rrep(i,n) for(int i=(int)(n)-1;i>=0;--i)\n#define srep(i,s,t) for(int i=(int)(s);i<(int)(t);++i)\n#define each(a,b) for(auto& (a): (b))\n#define all(v) (v).begin(),(v).end()\n#define len(v) (int)(v).size()\n#define zip(v) sort(all(v)),v.erase(unique(all(v)),v.end())\n#define cmx(x,y) x=max(x,y)\n#define cmn(x,y) x=min(x,y)\n#define fi first\n#define se second\n#define pb push_back\n#define show(x) cout<<#x<<\" = \"<<(x)<<endl\n#define spair(p) cout<<#p<<\": \"<<p.fi<<\" \"<<p.se<<endl\n#define sar(a,n) cout<<#a<<\":\";rep(kbrni,n)cout<<\" \"<<a[kbrni];cout<<endl\n#define svec(v) cout<<#v<<\":\";rep(kbrni,v.size())cout<<\" \"<<v[kbrni];cout<<endl\n#define svecp(v) cout<<#v<<\":\";each(kbrni,v)cout<<\" {\"<<kbrni.first<<\":\"<<kbrni.second<<\"}\";cout<<endl\n#define sset(s) cout<<#s<<\":\";each(kbrni,s)cout<<\" \"<<kbrni;cout<<endl\n#define smap(m) cout<<#m<<\":\";each(kbrni,m)cout<<\" {\"<<kbrni.first<<\":\"<<kbrni.second<<\"}\";cout<<endl\n\nusing namespace std;\n\ntypedef pair<int,int> P;\ntypedef pair<ll,ll> pll;\ntypedef vector<int> vi;\ntypedef vector<vi> vvi;\ntypedef vector<ll> vl;\ntypedef vector<vl> vvl;\ntypedef vector<double> vd;\ntypedef vector<P> vp;\ntypedef vector<string> vs;\n\nconst int MAX_N = 10005;\n\nstruct edge\n{\n    int to,cost;\n};\n\nvector<edge> G[MAX_N];\nbool ok[MAX_N];\nint sub[MAX_N];\nint n,t,k;\n\nvoid dfs(int u,int p)\n{\n    sub[u] = 1;\n    each(e,G[u]){\n        int v = e.to;\n        if(p != v){\n            dfs(v,u);\n            sub[u] += sub[v];\n        }\n    }\n}\n\nvvi redfs(int u,int p)\n{\n    vvi dp(2,vi(2,INF));\n    int mx = 1;\n    if(ok[u]){\n        dp[1][1] = 0;\n    }else{\n        dp[0][1] = 0;\n    }\n    sort(all(G[u]),[&](edge& a,edge& b){\n        return (b.to==p)?true:sub[a.to]<sub[b.to];\n    });\n    each(e,G[u]){\n        cmn(mx,k+1);\n        int v = e.to, c = e.cost;\n        if(p != v){\n            vvi res = redfs(v,u);\n            vvi dp2(2,vi(mx+len(res[0]),INF));\n            srep(i,1,mx+1){\n                srep(j,1,len(res[0])){\n                    if(ok[u]){\n                        cmn(dp2[1][i+j-1],dp[1][i]+res[0][j]);\n                        cmn(dp2[1][i+j-1],dp[1][i]+res[1][j]);\n                        cmn(dp2[1][i+j],dp[1][i]+res[1][j]+c);\n                    }else{\n                        cmn(dp2[0][i+j-1],dp[0][i]+res[0][j]);\n                        cmn(dp2[0][i+j],dp[0][i]+res[1][j]+c);\n                        cmn(dp2[1][i+j-1],dp[0][i]+res[1][j]);\n                        cmn(dp2[1][i+j-1],dp[1][i]+res[0][j]);\n                        cmn(dp2[1][i+j-1],dp[1][i]+res[1][j]);\n                        cmn(dp2[1][i+j],dp[1][i]+res[1][j]+c);\n                    }\n                }\n            }\n            mx += len(res[0]) - 1;\n            dp[0].resize(mx+1),dp[1].resize(mx+1);\n            rep(i,2){\n                rep(j,mx+1){\n                    dp[i][j] = dp2[i][j];\n                }\n            }\n        }\n    }\n    return dp;\n}\n\nint main()\n{\n    cin.tie(0);\n    ios::sync_with_stdio(false);\n    int id = 0;\n    while(1){\n        cin >> n >> t >> k;\n        if(n == 0){\n            break;\n        }\n        rep(i,n){\n            G[i].clear(),ok[i] = false;\n        }\n        rep(i,n-1){\n            int a,b,c;\n            cin >> a >> b >> c;\n            G[a-1].pb((edge){b-1,c}),G[b-1].pb((edge){a-1,c});\n        }\n        rep(i,t){\n            int a;\n            cin >> a;\n            --a;\n            ok[a] = true;\n        }\n        if(k == 0){\n            cout << \"Case \" << ++id << \": 0\" << endl;\n            continue;\n        }\n        dfs(0,-1);\n        vvi ans = redfs(0,-1);\n        cout << \"Case \" << ++id << \": \" << ans[1][k+1] << endl;\n    }\n    return 0;\n}\n\n"
  },
  {
    "language": "Java",
    "code": "import java.util.*;\n\npublic class Main {\n\n\t@SuppressWarnings(\"unchecked\")\n\tpublic static void main(String[] args) {\n\t\tScanner sc = new Scanner(System.in);\n\t\tint num = 0;\n\t\twhile (true) {\n\t\t\t++num;\n\t\t\tint n = sc.nextInt();\n\t\t\tint t = sc.nextInt();\n\t\t\tint k = sc.nextInt();\n\t\t\tif (n == 0 && k == 0 && t == 0)\n\t\t\t\tbreak;\n\t\t\tArrayList<Edge>[] g = new ArrayList[n];\n\t\t\tfor (int i = 0; i < n; ++i)\n\t\t\t\tg[i] = new ArrayList<>();\n\t\t\tPriorityQueue<Edge> pq = new PriorityQueue<>();\n\t\t\tfor (int i = 0; i < n - 1; ++i) {\n\t\t\t\tint a = sc.nextInt() - 1;\n\t\t\t\tint b = sc.nextInt() - 1;\n\t\t\t\tint c = sc.nextInt();\n\t\t\t\tg[a].add(new Edge(a, b, c));\n\t\t\t\tg[b].add(new Edge(b, a, c));\n\t\t\t}\n\n\t\t\tboolean[] base = new boolean[n];\n\t\t\tfor (int i = 0; i < t; ++i) {\n\t\t\t\tint a = sc.nextInt() - 1;\n\t\t\t\tpq.addAll(g[a]);\n\t\t\t\tbase[a] = true;\n\t\t\t}\n\n\t\t\tDJSet ds = new DJSet(n);\n\n\t\t\tArrayList<Edge> pending = new ArrayList<>();\n\t\t\twhile (!pq.isEmpty()) {\n\t\t\t\tEdge e = pq.poll();\n\t\t\t\tif (ds.equiv(e.dst, e.src))\n\t\t\t\t\tcontinue;\n\t\t\t\tif (base[e.dst] || ds.size(e.dst) > 1)\n\t\t\t\t\tpending.add(e);\n\t\t\t\telse {\n\t\t\t\t\tif (ds.setUnion(e.src, e.dst)) {\n\t\t\t\t\t\tpq.addAll(g[e.dst]);\n\t\t\t\t\t}\n\n\t\t\t\t}\n\t\t\t}\n\n\t\t\tCollections.sort(pending);\n\n\t\t\tlong ans = 0;\n\t\t\tint len = pending.size();\n\t\t\tfor (int i = 0, j = 0; j < k; ++i) {\n\t\t\t\tEdge e = pending.get(len - 1 - i);\n\t\t\t\tif (ds.equiv(e.src, e.dst))\n\t\t\t\t\tcontinue;\n\t\t\t\tans += e.cost;\n\t\t\t\tds.setUnion(e.src, e.dst);\n\t\t\t\t++j;\n\t\t\t}\n\t\t\tSystem.out.println(\"Case \" + num + \": \" + ans);\n\t\t}\n\t}\n\n\tstatic class Edge implements Comparable<Edge> {\n\t\tint src;\n\t\tint dst;\n\t\tint cost;\n\n\t\tpublic Edge(int src, int dst, int cost) {\n\t\t\tthis.src = src;\n\t\t\tthis.dst = dst;\n\t\t\tthis.cost = cost;\n\t\t}\n\n\t\t@Override\n\t\tpublic int compareTo(Edge o) {\n\t\t\treturn -Integer.compare(this.cost, o.cost);\n\t\t}\n\n\t}\n\n\tstatic class DJSet {\n\t\tint n;\n\t\tint[] upper;\n\n\t\tpublic DJSet(int n) {\n\t\t\tthis.n = n;\n\t\t\tupper = new int[n];\n\t\t\tArrays.fill(upper, -1);\n\t\t}\n\n\t\tint root(int x) {\n\t\t\treturn upper[x] < 0 ? x : (upper[x] = root(upper[x]));\n\t\t}\n\n\t\tboolean setUnion(int x, int y) {\n\t\t\tx = root(x);\n\t\t\ty = root(y);\n\t\t\tif (x != y) {\n\t\t\t\tif (upper[x] < upper[y]) {\n\t\t\t\t\tint d = x;\n\t\t\t\t\tx = y;\n\t\t\t\t\ty = d;\n\t\t\t\t}\n\t\t\t\tupper[y] += upper[x];\n\t\t\t\tupper[x] = y;\n\t\t\t}\n\t\t\treturn x != y;\n\t\t}\n\n\t\tboolean equiv(int x, int y) {\n\t\t\treturn root(x) == root(y);\n\t\t}\n\n\t\tint size(int x) {\n\t\t\treturn -upper[root(x)];\n\t\t}\n\n\t}\n}"
  },
  {
    "language": "Java",
    "code": "import java.util.*;\n\npublic class Main {\n\n\t@SuppressWarnings(\"unchecked\")\n\tpublic static void main(String[] args) {\n\t\tScanner sc = new Scanner(System.in);\n\t\tint num = 0;\n\t\twhile (true) {\n\t\t\t++num;\n\t\t\tint n = sc.nextInt();\n\t\t\tint t = sc.nextInt();\n\t\t\tint k = sc.nextInt();\n\t\t\tif (n == 0 && k == 0 && t == 0)\n\t\t\t\tbreak;\n\t\t\tArrayList<Edge>[] g = new ArrayList[n];\n\t\t\tfor (int i = 0; i < n; ++i)\n\t\t\t\tg[i] = new ArrayList<>();\n\t\t\tPriorityQueue<Edge> pq = new PriorityQueue<>();\n\t\t\tfor (int i = 0; i < n - 1; ++i) {\n\t\t\t\tint a = sc.nextInt() - 1;\n\t\t\t\tint b = sc.nextInt() - 1;\n\t\t\t\tint c = sc.nextInt();\n\t\t\t\tg[a].add(new Edge(a, b, c));\n\t\t\t\tg[b].add(new Edge(b, a, c));\n\t\t\t}\n\n\t\t\tboolean[] base = new boolean[n];\n\t\t\tfor (int i = 0; i < t; ++i) {\n\t\t\t\tint a = sc.nextInt() - 1;\n\t\t\t\tpq.addAll(g[a]);\n\t\t\t\tbase[a] = true;\n\t\t\t}\n\n\t\t\tDJSet ds = new DJSet(n);\n\n\t\t\tArrayList<Edge> pending = new ArrayList<>();\n\t\t\twhile (!pq.isEmpty()) {\n\t\t\t\tEdge e = pq.poll();\n\t\t\t\tif (base[e.dst] || ds.size(e.dst) > 0)\n\t\t\t\t\tpending.add(e);\n\t\t\t\telse {\n\t\t\t\t\tds.setUnion(e.src, e.dst);\n\t\t\t\t}\n\t\t\t}\n\n\t\t\tCollections.sort(pending);\n\n\t\t\tlong ans = 0;\n\t\t\tint len = pending.size();\n\t\t\tfor (int i = 0; i < k; ++i) {\n\t\t\t\tans += pending.get(len - 1 - i).cost;\n\t\t\t}\n\t\t\tSystem.out.println(\"Case \"+num+\": \"+ans);\n\t\t}\n\t}\n\n\tstatic class Edge implements Comparable<Edge> {\n\t\tint src;\n\t\tint dst;\n\t\tint cost;\n\n\t\tpublic Edge(int src, int dst, int cost) {\n\t\t\tthis.src = src;\n\t\t\tthis.dst = dst;\n\t\t\tthis.cost = cost;\n\t\t}\n\n\t\t@Override\n\t\tpublic int compareTo(Edge o) {\n\t\t\treturn -Integer.compare(this.cost, o.cost);\n\t\t}\n\n\t}\n\n\tstatic class DJSet {\n\t\tint n;\n\t\tint[] upper;\n\n\t\tpublic DJSet(int n) {\n\t\t\tthis.n = n;\n\t\t\tupper = new int[n];\n\t\t\tArrays.fill(upper, -1);\n\t\t}\n\n\t\tint root(int x) {\n\t\t\treturn upper[x] < 0 ? x : (upper[x] = root(upper[x]));\n\t\t}\n\n\t\tboolean setUnion(int x, int y) {\n\t\t\tx = root(x);\n\t\t\ty = root(y);\n\t\t\tif (x != y) {\n\t\t\t\tif (upper[x] < upper[y]) {\n\t\t\t\t\tint d = x;\n\t\t\t\t\tx = y;\n\t\t\t\t\ty = d;\n\t\t\t\t}\n\t\t\t\tupper[y] += upper[x];\n\t\t\t\tupper[x] = y;\n\t\t\t}\n\t\t\treturn x != y;\n\t\t}\n\n\t\tboolean equiv(int x, int y) {\n\t\t\treturn root(x) == root(y);\n\t\t}\n\n\t\tint size(int x) {\n\t\t\treturn -upper[root(x)];\n\t\t}\n\n\t}\n}"
  },
  {
    "language": "C#",
    "code": "using System;\nusing System.Collections.Generic;\nusing System.Linq;\nusing System.IO;\nusing System.Text;\nusing static System.Math;\nusing static System.Array;\nusing static AtCoder.Tool;\nnamespace AtCoder\n{\n    class AC\n    {\n        const int MOD = 1000000007;\n        const int INF = int.MaxValue / 2;\n        const long SINF = long.MaxValue / 2;\n        const double EPS = 1e-8;\n        static readonly int[] dI = { 0, 1, 0, -1 };\n        static readonly int[] dJ = { 1, 0, -1, 0 };\n        //static List<List<int>> G = new List<List<int>>();\n        //static List<List<Edge>>G = new List<List<Edge>>();\n        //static List<Edge> E = new List<Edge>();\n        static void Main(string[] args)\n        {\n            //var sw = new StreamWriter(Console.OpenStandardOutput()) { AutoFlush = false };\n            //Console.SetOut(sw);\n            var cin = new Scanner();\n            int c = 0;\n            while (true)\n            {\n                c++;\n                var input = cin.ReadSplitInt();\n                if (input[0] == 0) { break; }\n                int n = input[0];\n                int t = input[1];\n                int k = input[2];\n                var E = new List<Edge>();\n                for (var i = 0; i < n - 1; i++)\n                {\n                    var p = cin.ReadSplitInt();\n                    p[0]--; p[1]--;\n                    E.Add(new Edge(p[0], p[1], p[2]));\n                }\n                E.Sort((x, y) =>\n                {\n                    var cmp = y.dist - x.dist;\n                    return cmp == 0 ? 0 : (cmp > 0 ? 1 : -1);\n                });\n                long ans = E.Sum(e => e.dist);\n                int cnt = 0;\n                var uf = new UnionFind(n);\n                var prev = -1;\n                for(var i = 0; i < t; i++)\n                {\n                    int bs = int.Parse(Console.ReadLine()) - 1;\n                    if (prev != -1) { uf.Unite(prev, bs); }\n                    prev = bs;\n                }\n                foreach(var e in E)\n                {\n                    if (!uf.SameRoot(e.from, e.to)) { uf.Unite(e.from, e.to);ans -= e.dist; }\n                    else if (cnt < t - (k + 1)) { ans -= e.dist;cnt++; }\n                }\n                Console.WriteLine($\"Case {c}: {ans}\");\n\n            }\n\n            //Console.Out.Flush();\n        }\n        struct Edge\n        {\n            public int from;\n\n            public int to;\n            public long dist;\n            public Edge(int t, long c)\n            {\n                from = -1;\n                to = t;\n                dist = c;\n            }\n            public Edge(int f, int t, long c)\n            {\n                from = f;\n                to = t;\n                dist = c;\n            }\n\n        }\n    }\n    public class UnionFind\n    {\n        public int[] parent;\n        public int[] rank;\n        public int[] size;\n        public UnionFind(int n)\n        {\n            parent = new int[n];\n            rank = new int[n];\n            size = new int[n];\n            for (var i = 0; i < n; i++)\n            {\n                parent[i] = i;\n                rank[i] = 0;\n                size[i] = 1;\n            }\n        }\n\n        private int Root(int x)\n        {\n            return parent[x] == x ? x : parent[x] = Root(parent[x]);\n        }\n\n        public bool SameRoot(int x, int y)\n        {\n            return Root(x) == Root(y);\n        }\n\n        public void Unite(int x, int y)\n        {\n            x = Root(x);\n            y = Root(y);\n            if (x == y) { return; }\n\n            if (rank[x] < rank[y])\n            {\n                parent[x] = y;\n                size[y] += size[x];\n                size[x] = 0;\n            }\n            else\n            {\n                parent[y] = x;\n                if (rank[x] == rank[y]) { rank[x]++; }\n                size[x] += size[y];\n                size[y] = 0;\n            }\n        }\n\n        public int SizeOf(int x)\n        {\n            return size[Root(x)];\n        }\n\n    }\n    public class Scanner\n    {\n        public int[] ReadSplitInt()\n        {\n            return ConvertAll(Console.ReadLine().Split(), int.Parse);\n        }\n        public long[] ReadSplitLong()\n        {\n            return ConvertAll(Console.ReadLine().Split(), long.Parse);\n        }\n        public double[] ReadSplit_Double()\n        {\n            return ConvertAll(Console.ReadLine().Split(), double.Parse);\n        }\n    }\n    public static class Tool\n    {\n        static public void Initialize<T>(ref T[] array, T initialvalue)\n        {\n            for (var i = 0; i < array.Length; i++)\n            {\n                array[i] = initialvalue;\n            }\n        }\n        static public void Swap<T>(ref T a, ref T b)\n        {\n            T keep = a;\n            a = b;\n            b = keep;\n        }\n\n        static public void Display<T>(T[,] array2d, int n, int m)\n        {\n            for (var i = 0; i < n; i++)\n            {\n                for (var j = 0; j < m; j++)\n                {\n                    Console.Write($\"{array2d[i, j]} \");\n                }\n                Console.WriteLine();\n            }\n        }\n\n        static public long LPow(int a, int b)\n        {\n            return (long)Pow(a, b);\n        }\n    }\n}\n\n"
  },
  {
    "language": "Python",
    "code": "from collections import defaultdict\nimport heapq\n\ncase = 1\nwhile True:\n    n, t, k = map(int, input().split())\n    if n == t == k == 0:\n        break\n\n    costs = [0] * 10001\n\n    # 全ての辺をまず壊して考える\n    E = defaultdict(list)\n    for i in range(n-1):\n        fr, to, c = map(int, input().split())\n        E[fr - 1].append((c, to - 1))\n        E[to - 1].append((c, fr - 1))\n        costs[c] += 1\n\n    bases = [None]*t\n    # isUnitedが負の点がなくなるようにしなければいけない\n    isUnited = [False] * n\n    for i in range(t):\n        b = int(input()) - 1\n        bases[i] = b\n        isUnited[b] = True\n\n    q = []\n    for b in bases:\n        for c, y in E[b]:\n            if not isUnited[y]:\n                # heapqで降順にするためにコストに負を掛ける\n                heapq.heappush(q, (-c, y))\n\n    while q:\n        c_minus, y = heapq.heappop(q)\n        if isUnited[y]:\n            continue\n        isUnited[y] = True\n        # -c_minus == c\n        # 壊してはいけない辺を復活させる\n        costs[-c_minus] -= 1\n\n        for nc, ny in E[y]:\n            if not isUnited[ny]:\n                heapq.heappush(q, (-nc, ny))\n\n    p = 0\n    ans = 0\n    # 壊せる辺の中でコストの低い順からk個だけとる\n    while k > 0:\n        while k > 0 and costs[p] > 0:\n            costs[p] -= 1\n            k -= 1\n            ans += p\n        p += 1\n\n    print(\"Case {}: {}\".format(case, ans))\n    case += 1\n\n\n"
  },
  {
    "language": "Python",
    "code": "import sys\nreadline = sys.stdin.readline\nwrite = sys.stdout.write\ndef solve(t):\n    N, T, K = map(int, readline().split())\n    if N == T == K == 0:\n        return False\n    G = [[] for i in range(N)]\n    E = []\n    res = 0\n    for i in range(N-1):\n        a, b, c = map(int, readline().split())\n        res += c\n        E.append((c, a-1, b-1))\n    E.sort(reverse=1)\n    sz = [0]*N\n    for i in range(T):\n        v = int(readline())-1\n        sz[v] = 1\n    *prt, = range(N)\n    def root(x):\n        if x == prt[x]:\n            return x\n        prt[x] = y = root(prt[x])\n        return y\n    def unite(x, y):\n        px = root(x); py = root(y)\n        if px < py:\n            prt[py] = px\n            sz[px] += sz[py]\n        else:\n            prt[px] = py\n            sz[py] += sz[px]\n    d = T - K - 1\n    for c, a, b in E:\n        pa = root(a); pb = root(b)\n        if sz[pa] == 0 or sz[pb] == 0:\n            unite(a, b)\n            res -= c\n            continue\n        if d > 0:\n            d -= 1\n            unite(a, b)\n            res -= c\n    write(\"Case %d: %d\\n\" % (t, res))\n    return True\ni = 1\nwhile solve(i):\n    i += 1\n"
  }
]