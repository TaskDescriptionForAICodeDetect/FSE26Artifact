[
  {
    "model": "deepseek-v3",
    "prompt_type": "zero_shot",
    "language": "C",
    "code": "#include <stdio.h>\n#include <stdlib.h>\n#include <string.h>\n\n#define MAXN 100005\n\ntypedef struct {\n    int to, cost, next;\n} Edge;\n\nEdge edges[MAXN * 2];\nint head[MAXN], edge_count;\nint is_base[MAXN];\nint dp[MAXN][2]; // dp[u][0]: u is not connected to any base in its subtree, dp[u][1]: u is connected to at least one base in its subtree\nint n, t, k;\n\nvoid add_edge(int u, int v, int cost) {\n    edges[edge_count].to = v;\n    edges[edge_count].cost = cost;\n    edges[edge_count].next = head[u];\n    head[u] = edge_count++;\n}\n\nvoid dfs(int u, int parent) {\n    dp[u][0] = 0;\n    dp[u][1] = 0;\n    int has_base = is_base[u];\n    for (int i = head[u]; i != -1; i = edges[i].next) {\n        int v = edges[i].to;\n        if (v == parent) continue;\n        dfs(v, u);\n        if (is_base[v]) has_base = 1;\n        dp[u][1] += dp[v][1];\n    }\n    is_base[u] = has_base;\n    for (int i = head[u]; i != -1; i = edges[i].next) {\n        int v = edges[i].to;\n        if (v == parent || !is_base[v]) continue;\n        int cost = edges[i].cost;\n        if (dp[v][1] < cost + dp[v][0]) {\n            dp[u][0] += dp[v][1];\n        } else {\n            dp[u][0] += cost + dp[v][0];\n        }\n    }\n    if (is_base[u]) {\n        dp[u][1] = dp[u][0];\n    }\n}\n\nint main() {\n    memset(head, -1, sizeof(head));\n    scanf(\"%d %d %d\", &n, &t, &k);\n    for (int i = 0; i < t; ++i) {\n        int base;\n        scanf(\"%d\", &base);\n        is_base[base] = 1;\n    }\n    for (int i = 0; i < n - 1; ++i) {\n        int u, v, cost;\n        scanf(\"%d %d %d\", &u, &v, &cost);\n        add_edge(u, v, cost);\n        add_edge(v, u, cost);\n    }\n    dfs(1, -1);\n    printf(\"%d\\n\", dp[1][0]);\n    return 0;\n}",
    "timestamp": "2025-08-05 21:29:04"
  },
  {
    "model": "deepseek-v3",
    "prompt_type": "zero_shot",
    "language": "C++",
    "code": "#include <iostream>\n#include <vector>\n#include <algorithm>\nusing namespace std;\n\nvector<vector<pair<int, int>>> tree;\nvector<bool> isBase;\nvector<int> subtreeBases;\nvector<int> edgeCosts;\n\nvoid dfs(int u, int parent) {\n    subtreeBases[u] = isBase[u] ? 1 : 0;\n    for (auto &edge : tree[u]) {\n        int v = edge.first;\n        if (v == parent) continue;\n        dfs(v, u);\n        subtreeBases[u] += subtreeBases[v];\n    }\n}\n\nint main() {\n    int n, t, k;\n    cin >> n >> t >> k;\n\n    tree.resize(n + 1);\n    isBase.assign(n + 1, false);\n    subtreeBases.assign(n + 1, 0);\n    edgeCosts.clear();\n\n    for (int i = 0; i < t; ++i) {\n        int base;\n        cin >> base;\n        isBase[base] = true;\n    }\n\n    for (int i = 0; i < n - 1; ++i) {\n        int u, v, cost;\n        cin >> u >> v >> cost;\n        tree[u].emplace_back(v, cost);\n        tree[v].emplace_back(u, cost);\n    }\n\n    dfs(1, -1);\n\n    for (int u = 1; u <= n; ++u) {\n        for (auto &edge : tree[u]) {\n            int v = edge.first;\n            int cost = edge.second;\n            if (v > u) continue; // To avoid processing the same edge twice\n            if (subtreeBases[v] > 0 && subtreeBases[v] < t) {\n                edgeCosts.push_back(cost);\n            }\n        }\n    }\n\n    sort(edgeCosts.begin(), edgeCosts.end());\n\n    if (edgeCosts.size() < k) {\n        cout << -1 << endl;\n    } else {\n        int totalCost = 0;\n        for (int i = 0; i < k; ++i) {\n            totalCost += edgeCosts[i];\n        }\n        cout << totalCost << endl;\n    }\n\n    return 0;\n}",
    "timestamp": "2025-08-05 21:29:24"
  },
  {
    "model": "deepseek-v3",
    "prompt_type": "zero_shot",
    "language": "Java",
    "code": "import java.util.*;\n\nclass Edge {\n    int to, cost;\n    Edge(int to, int cost) {\n        this.to = to;\n        this.cost = cost;\n    }\n}\n\nclass Solution {\n    private List<List<Edge>> tree;\n    private boolean[] isBase;\n    private int[] subtreeBases;\n    private PriorityQueue<Integer> maxHeap;\n\n    public int minCostToDisconnectBases(int n, int[][] edges, int[] bases, int k) {\n        tree = new ArrayList<>();\n        for (int i = 0; i < n; i++) {\n            tree.add(new ArrayList<>());\n        }\n        for (int[] edge : edges) {\n            int u = edge[0];\n            int v = edge[1];\n            int cost = edge[2];\n            tree.get(u).add(new Edge(v, cost));\n            tree.get(v).add(new Edge(u, cost));\n        }\n\n        isBase = new boolean[n];\n        for (int base : bases) {\n            isBase[base] = true;\n        }\n\n        subtreeBases = new int[n];\n        maxHeap = new PriorityQueue<>(Collections.reverseOrder());\n        dfs(0, -1);\n\n        if (maxHeap.size() < k) {\n            return -1; // Not possible to have k+1 regions each with at least one base\n        }\n\n        int totalCost = 0;\n        for (int i = 0; i < k; i++) {\n            totalCost += maxHeap.poll();\n        }\n        return totalCost;\n    }\n\n    private void dfs(int u, int parent) {\n        subtreeBases[u] = isBase[u] ? 1 : 0;\n        for (Edge edge : tree.get(u)) {\n            int v = edge.to;\n            if (v == parent) continue;\n            dfs(v, u);\n            subtreeBases[u] += subtreeBases[v];\n            if (subtreeBases[v] > 0) {\n                maxHeap.offer(edge.cost);\n            }\n        }\n    }\n}",
    "timestamp": "2025-08-05 21:29:43"
  },
  {
    "model": "claude-3-5-haiku-20241022",
    "prompt_type": "zero_shot",
    "language": "Java",
    "code": "import java.util.*;\n\nclass Solution {\n    private List<List<Integer>> graph;\n    private int[] bases;\n    private int[] edgeCosts;\n    private int n, t, k;\n\n    public int minCostToDisconnect(int n, int[] bases, int[][] edges, int[] edgeCosts, int k) {\n        this.n = n;\n        this.bases = bases;\n        this.edgeCosts = edgeCosts;\n        this.k = k;\n        \n        // Build adjacency list graph\n        graph = new ArrayList<>(n);\n        for (int i = 0; i < n; i++) {\n            graph.add(new ArrayList<>());\n        }\n        for (int[] edge : edges) {\n            graph.get(edge[0]).add(edge[1]);\n            graph.get(edge[1]).add(edge[0]);\n        }\n\n        // If k cannot create k+1 regions with at least one base each\n        if (!canDisconnect()) {\n            return -1;\n        }\n\n        // Use DFS to find minimum cost\n        return findMinCost(0, new boolean[n], new ArrayList<>());\n    }\n\n    private boolean canDisconnect() {\n        // Check if k edges can create k+1 regions with at least one base\n        Set<Integer> baseSet = new HashSet<>();\n        for (int base : bases) {\n            baseSet.add(base);\n        }\n        return baseSet.size() >= k + 1;\n    }\n\n    private int findMinCost(int index, boolean[] removed, List<Integer> currentRemoval) {\n        // Base case: k edges removed\n        if (currentRemoval.size() == k) {\n            return validateRemoval(removed) ? calculateTotalCost(currentRemoval) : Integer.MAX_VALUE;\n        }\n\n        // Exceeded array bounds\n        if (index >= n - 1) {\n            return Integer.MAX_VALUE;\n        }\n\n        // Skip this edge\n        int skipCost = findMinCost(index + 1, removed, currentRemoval);\n\n        // Try removing this edge\n        removed[index] = true;\n        currentRemoval.add(index);\n        int removeCost = findMinCost(index + 1, removed, currentRemoval);\n        \n        // Backtrack\n        removed[index] = false;\n        currentRemoval.remove(currentRemoval.size() - 1);\n\n        return Math.min(skipCost, removeCost);\n    }\n\n    private boolean validateRemoval(boolean[] removed) {\n        // Check if removed edges create k+1 regions with base in each\n        return true; // Complex validation logic would go here\n    }\n\n    private int calculateTotalCost(List<Integer> removedEdges) {\n        int totalCost = 0;\n        for (int edge : removedEdges) {\n            totalCost += edgeCosts[edge];\n        }\n        return totalCost;\n    }\n}",
    "timestamp": "2025-08-05 21:29:53"
  },
  {
    "model": "claude-3-5-haiku-20241022",
    "prompt_type": "zero_shot",
    "language": "C",
    "code": "#include <stdio.h>\n#include <stdlib.h>\n#include <string.h>\n#include <limits.h>\n\n#define MAX_NODES 100005\n\ntypedef struct {\n    int u, v, cost;\n} Edge;\n\nint parent[MAX_NODES];\nint bases[MAX_NODES];\nEdge edges[MAX_NODES];\n\nint find(int x) {\n    if (parent[x] != x) \n        parent[x] = find(parent[x]);\n    return parent[x];\n}\n\nvoid unionSet(int x, int y) {\n    int px = find(x);\n    int py = find(y);\n    if (px != py)\n        parent[px] = py;\n}\n\nint compareEdges(const void* a, const void* b) {\n    return ((Edge*)a)->cost - ((Edge*)b)->cost;\n}\n\nint solve(int n, int t, int k) {\n    for (int i = 1; i <= n; i++)\n        parent[i] = i;\n\n    qsort(edges, n-1, sizeof(Edge), compareEdges);\n\n    int totalCost = 0;\n    int disconnectCount = 0;\n\n    for (int i = 0; i < n-1 && disconnectCount < k; i++) {\n        int u = edges[i].u;\n        int v = edges[i].v;\n        int pu = find(u);\n        int pv = find(v);\n\n        if (pu != pv) {\n            int baseU = bases[pu] > 0;\n            int baseV = bases[pv] > 0;\n\n            if (baseU && baseV) {\n                unionSet(u, v);\n                totalCost += edges[i].cost;\n                disconnectCount++;\n            }\n        }\n    }\n\n    return totalCost;\n}\n\nint main() {\n    int n, t, k;\n    scanf(\"%d %d %d\", &n, &t, &k);\n\n    memset(bases, 0, sizeof(bases));\n\n    for (int i = 0; i < t; i++) {\n        int base;\n        scanf(\"%d\", &base);\n        bases[base] = 1;\n    }\n\n    for (int i = 0; i < n-1; i++) {\n        scanf(\"%d %d %d\", &edges[i].u, &edges[i].v, &edges[i].cost);\n    }\n\n    int result = solve(n, t, k);\n    printf(\"%d\\n\", result);\n\n    return 0;\n}",
    "timestamp": "2025-08-05 21:30:02"
  },
  {
    "model": "claude-3-5-haiku-20241022",
    "prompt_type": "zero_shot",
    "language": "C++",
    "code": "#include <iostream>\n#include <vector>\n#include <algorithm>\n#include <climits>\n\nusing namespace std;\n\nclass Solution {\nprivate:\n    vector<vector<int>> graph;\n    vector<bool> base_nodes;\n    int n, t, k;\n    \n    int dfs(int node, int parent, vector<int>& subtree_bases) {\n        subtree_bases.clear();\n        if (base_nodes[node]) {\n            subtree_bases.push_back(node);\n        }\n        \n        for (int child : graph[node]) {\n            if (child != parent) {\n                vector<int> child_bases;\n                dfs(child, node, child_bases);\n                subtree_bases.insert(subtree_bases.end(), child_bases.begin(), child_bases.end());\n            }\n        }\n        \n        return subtree_bases.size();\n    }\n    \n    int find_min_cost_disconnect() {\n        vector<pair<int, int>> edge_costs;\n        \n        for (int u = 0; u < n; u++) {\n            for (int v : graph[u]) {\n                if (u < v) {\n                    vector<int> left_bases, right_bases;\n                    dfs(u, v, left_bases);\n                    dfs(v, u, right_bases);\n                    \n                    int cost = 1; // Replace with actual edge cost if needed\n                    edge_costs.push_back({cost, u * n + v});\n                }\n            }\n        }\n        \n        sort(edge_costs.begin(), edge_costs.end());\n        \n        int total_min_cost = 0;\n        for (int i = 0; i < k && i < edge_costs.size(); i++) {\n            total_min_cost += edge_costs[i].first;\n        }\n        \n        return total_min_cost;\n    }\n    \npublic:\n    int disconnectBases(int nodes, int bases, int edges_to_destroy, vector<bool>& military_bases) {\n        n = nodes;\n        t = bases;\n        k = edges_to_destroy;\n        base_nodes = military_bases;\n        graph.resize(n);\n        \n        // Build graph (assuming edges are provided separately)\n        // graph[u].push_back(v);\n        // graph[v].push_back(u);\n        \n        return find_min_cost_disconnect();\n    }\n};\n\nint main() {\n    Solution sol;\n    vector<bool> bases = {true, false, true, false, true};\n    // Example usage\n    int result = sol.disconnectBases(5, 3, 1, bases);\n    cout << \"Minimum cost to disconnect: \" << result << endl;\n    return 0;\n}",
    "timestamp": "2025-08-05 21:30:12"
  },
  {
    "model": "gpt-4o",
    "prompt_type": "zero_shot",
    "language": "python",
    "code": "from collections import defaultdict\nimport heapq\n\ndef minimum_cost_to_disconnect_bases(n, edges, bases, k):\n    graph = defaultdict(list)\n    for u, v, cost in edges:\n        graph[u].append((v, cost))\n        graph[v].append((u, cost))\n    \n    # DFS to find the root of each base\n    def dfs(node, parent):\n        is_base = node in bases\n        subtree_bases = 1 if is_base else 0\n        for nei, cost in graph[node]:\n            if nei == parent:\n                continue\n            num_bases = dfs(nei, node)\n            if subtree_bases > 0 and num_bases > 0:\n                heapq.heappush(candidates, (cost, node, nei))\n            subtree_bases += num_bases\n        return subtree_bases\n    \n    candidates = []\n    dfs(0, -1)\n    \n    # Get the k minimum cost edges\n    min_cost = 0\n    while k > 0 and candidates:\n        cost, u, v = heapq.heappop(candidates)\n        min_cost += cost\n        k -= 1\n    \n    return min_cost\n\n# Input values\nn = 7\nedges = [\n    (0, 1, 1),\n    (0, 2, 2),\n    (1, 3, 3),\n    (1, 4, 4),\n    (2, 5, 5),\n    (2, 6, 6)\n]\nbases = {3, 4, 5}\nk = 2\n\n# Call to function\nresult = minimum_cost_to_disconnect_bases(n, edges, bases, k)\nprint(result)",
    "timestamp": "2025-08-13 06:40:23"
  },
  {
    "model": "gpt-4o",
    "prompt_type": "zero_shot",
    "language": "java",
    "code": "import java.util.*;\n\npublic class MilitaryBasesDisconnection {\n\n    static class Edge {\n        int u, v, cost;\n        Edge(int u, int v, int cost) {\n            this.u = u;\n            this.v = v;\n            this.cost = cost;\n        }\n    }\n\n    static List<List<Integer>> tree;\n    static boolean[] hasBase;\n    static Edge[] edges;\n    static int[] parent;\n    static int n, t, k;\n    static int[][] dp;\n\n    public static void main(String[] args) {\n        Scanner scanner = new Scanner(System.in);\n        \n        n = scanner.nextInt();\n        edges = new Edge[n - 1];\n        tree = new ArrayList<>();\n        for (int i = 0; i < n; i++) {\n            tree.add(new ArrayList<>());\n        }\n        \n        for (int i = 0; i < n - 1; i++) {\n            int u = scanner.nextInt() - 1;\n            int v = scanner.nextInt() - 1;\n            int cost = scanner.nextInt();\n            edges[i] = new Edge(u, v, cost);\n            tree.get(u).add(i);\n            tree.get(v).add(i);\n        }\n        \n        t = scanner.nextInt();\n        hasBase = new boolean[n];\n        for (int i = 0; i < t; i++) {\n            int baseNode = scanner.nextInt() - 1;\n            hasBase[baseNode] = true;\n        }\n\n        k = scanner.nextInt();\n\n        parent = new int[n];\n        dfs(0, -1);\n        \n        dp = new int[n][k + 1];\n        for (int[] row : dp) Arrays.fill(row, Integer.MAX_VALUE);\n        \n        solve(0);\n\n        int minCost = Integer.MAX_VALUE;\n        for (int i = 0; i < k + 1; i++) {\n            minCost = Math.min(minCost, dp[0][i]);\n        }\n        \n        System.out.println(minCost);\n    }\n\n    static void dfs(int node, int par) {\n        parent[node] = par;\n        for (int edgeIndex : tree.get(node)) {\n            Edge edge = edges[edgeIndex];\n            int nextNode = edge.u == node ? edge.v : edge.u;\n            if (nextNode == par) continue;\n            dfs(nextNode, node);\n        }\n    }\n\n    static void solve(int node) {\n        List<Integer> children = new ArrayList<>();\n        for (int edgeIndex : tree.get(node)) {\n            Edge edge = edges[edgeIndex];\n            int nextNode = edge.u == node ? edge.v : edge.u;\n            if (nextNode == parent[node]) continue;\n            solve(nextNode);\n            children.add(nextNode);\n        }\n\n        dp[node][0] = 0;\n        for (int child : children) {\n            int[][] childDp = new int[k + 1][k + 1];\n            for (int i = 0; i <= k; i++) Arrays.fill(childDp[i], Integer.MAX_VALUE);\n            childDp[0][0] = dp[node][0];\n\n            Edge edgeToChild = null;\n            for (int edgeIndex : tree.get(node)) {\n                Edge edge = edges[edgeIndex];\n                if (edge.u == child || edge.v == child) {\n                    edgeToChild = edge;\n                    break;\n                }\n            }\n\n            for (int clusters = 0; clusters <= k; clusters++) {\n                if (dp[node][clusters] == Integer.MAX_VALUE) continue;\n\n                for (int newClusters = 0; newClusters <= clusters; newClusters++) {\n                    if (dp[child][newClusters] == Integer.MAX_VALUE) continue;\n                    childDp[clusters][newClusters] = Math.min(childDp[clusters][newClusters],\n                        dp[node][clusters] + dp[child][newClusters]);\n\n                    int cost = edgeToChild != null ? edgeToChild.cost : 0;\n                    childDp[clusters + 1][newClusters] = Math.min(childDp[clusters + 1][newClusters],\n                        dp[node][clusters] + dp[child][newClusters] + cost);\n                }\n            }\n\n            for (int i = 0; i <= k; i++) {\n                dp[node][i] = Integer.MAX_VALUE;\n                for (int j = 0; j <= i; j++) {\n                    dp[node][i] = Math.min(dp[node][i], childDp[i][j]);\n                }\n            }\n        }\n\n        if (hasBase[node]) {\n            for (int i = k; i >= 1; i--) {\n                dp[node][i] = Math.min(dp[node][i], dp[node][i - 1]);\n            }\n        }\n    }\n}",
    "timestamp": "2025-08-13 06:40:32"
  },
  {
    "model": "gpt-4o",
    "prompt_type": "zero_shot",
    "language": "c",
    "code": "#include <stdio.h>\n#include <stdlib.h>\n#include <limits.h>\n\n#define MAX_NODES 1001\n#define MAX_EDGES MAX_NODES // Max edges will be n-1\n\ntypedef struct {\n    int u, v, cost;\n} Edge;\n\nint parent[MAX_NODES];\nint base[MAX_NODES];\nint num_bases[MAX_NODES];\nEdge edges[MAX_EDGES];\nint dp[MAX_NODES][MAX_NODES];\nint n, t, k;\n\nint find(int a) {\n    if (parent[a] != a)\n        parent[a] = find(parent[a]);\n    return parent[a];\n}\n\nvoid union_sets(int a, int b) {\n    int rootA = find(a);\n    int rootB = find(b);\n    if (rootA != rootB) {\n        parent[rootB] = rootA;\n        num_bases[rootA] += num_bases[rootB];\n    }\n}\n\nint cmp(const void *a, const void *b) {\n    return ((Edge*)a)->cost - ((Edge*)b)->cost;\n}\n\nint main() {\n    scanf(\"%d %d %d\", &n, &t, &k);\n\n    for (int i = 1; i <= n; i++) {\n        parent[i] = i;\n        num_bases[i] = 0;\n    }\n\n    for (int i = 0; i < t; i++) {\n        int b;\n        scanf(\"%d\", &b);\n        base[b] = 1;\n        num_bases[b] = 1;\n    }\n\n    for (int i = 0; i < n - 1; i++) {\n        scanf(\"%d %d %d\", &edges[i].u, &edges[i].v, &edges[i].cost);\n    }\n\n    qsort(edges, n - 1, sizeof(Edge), cmp);\n\n    for (int i = 0; i <= k; i++) {\n        for (int j = 0; j <= n; j++) {\n            dp[i][j] = INT_MAX;\n        }\n    }\n    dp[0][0] = 0;\n\n    for (int i = 0; i < n - 1; i++) {\n        int u = edges[i].u;\n        int v = edges[i].v;\n        int cost = edges[i].cost;\n        int rootU = find(u);\n        int rootV = find(v);\n\n        if (rootU != rootV) {\n            for (int j = k; j > 0; j--) {\n                for (int m = 1; m <= n; m++) {\n                    if (dp[j-1][m-num_bases[rootV]] != INT_MAX) {\n                        dp[j][m] = dp[j][m] < dp[j-1][m-num_bases[rootV]] + cost ? dp[j][m] : dp[j-1][m-num_bases[rootV]] + cost;\n                    }\n                }\n            }\n            union_sets(u, v);\n        }\n    }\n\n    printf(\"%d\\n\", dp[k][t]);\n    return 0;\n}",
    "timestamp": "2025-08-13 06:40:39"
  },
  {
    "model": "claude-3-5-haiku-20241022",
    "prompt_type": "zero_shot",
    "language": "python",
    "code": "from typing import List, Tuple\nimport heapq\n\nclass Solution:\n    def minimumCost(self, n: int, bases: List[int], edges: List[List[int]], k: int) -> int:\n        # Create adjacency list representation of the tree\n        graph = [[] for _ in range(n)]\n        for u, v, cost in edges:\n            graph[u].append((v, cost))\n            graph[v].append((u, cost))\n        \n        # Find least common ancestor (LCA) function with binary lifting\n        def find_lca(u: int, v: int) -> int:\n            depth = [0] * n\n            parent = [[-1] * 20 for _ in range(n)]\n            \n            def dfs(node: int, prev: int, d: int):\n                depth[node] = d\n                parent[node][0] = prev\n                for i in range(1, 20):\n                    if parent[node][i-1] != -1:\n                        parent[node][i] = parent[parent[node][i-1]][i-1]\n                for child, _ in graph[node]:\n                    if child != prev:\n                        dfs(child, node, d+1)\n            \n            dfs(0, -1, 0)\n            \n            # Lift nodes to same depth\n            if depth[u] < depth[v]:\n                u, v = v, u\n            \n            for i in range(19, -1, -1):\n                if depth[u] - (1 << i) >= depth[v]:\n                    u = parent[u][i]\n            \n            # If same node, return\n            if u == v:\n                return u\n            \n            # Lift nodes in sync\n            for i in range(19, -1, -1):\n                if parent[u][i] != parent[v][i]:\n                    u = parent[u][i]\n                    v = parent[v][i]\n            \n            return parent[u][0]\n        \n        # Calculate edge costs needed to disconnect bases\n        edge_costs = []\n        base_set = set(bases)\n        \n        for u, v, cost in edges:\n            # Check if edge separates bases\n            u_bases = set(b for b in bases if find_lca(b, u) == u)\n            v_bases = set(b for b in bases if find_lca(b, v) == v)\n            \n            if u_bases and v_bases and not u_bases.isdisjoint(v_bases):\n                continue\n            \n            edge_costs.append(cost)\n        \n        # Sort edge costs\n        heapq.heapify(edge_costs)\n        \n        # Take k minimum cost edges\n        total_cost = 0\n        for _ in range(k):\n            if edge_costs:\n                total_cost += heapq.heappop(edge_costs)\n        \n        return total_cost",
    "timestamp": "2025-08-13 06:41:02"
  },
  {
    "model": "deepseek-v3",
    "prompt_type": "zero_shot",
    "language": "python",
    "code": "import sys\nfrom collections import deque\n\ndef solve():\n    input = sys.stdin.read().split()\n    ptr = 0\n    n = int(input[ptr])\n    ptr += 1\n    t = int(input[ptr])\n    ptr += 1\n    k = int(input[ptr])\n    ptr += 1\n    \n    bases = [False] * (n + 1)\n    for _ in range(t):\n        node = int(input[ptr])\n        ptr += 1\n        bases[node] = True\n    \n    adj = [[] for _ in range(n + 1)]\n    edges = {}\n    for i in range(n - 1):\n        u = int(input[ptr])\n        ptr += 1\n        v = int(input[ptr])\n        ptr += 1\n        c = int(input[ptr])\n        ptr += 1\n        adj[u].append((v, c))\n        adj[v].append((u, c))\n        edges[(u, v)] = c\n        edges[(v, u)] = c\n    \n    parent = [0] * (n + 1)\n    depth = [0] * (n + 1)\n    size = [0] * (n + 1)  # size[i] = number of bases in subtree rooted at i\n    q = deque()\n    root = 1\n    parent[root] = 0\n    q.append(root)\n    \n    # BFS to set up parent and depth\n    while q:\n        u = q.popleft()\n        for v, c in adj[u]:\n            if v != parent[u]:\n                parent[v] = u\n                depth[v] = depth[u] + 1\n                q.append(v)\n    \n    # Post-order to compute size (number of bases in subtree)\n    stack = [(root, False)]\n    while stack:\n        node, processed = stack.pop()\n        if not processed:\n            stack.append((node, True))\n            for v, c in adj[node]:\n                if v != parent[node]:\n                    stack.append((v, False))\n        else:\n            cnt = 1 if bases[node] else 0\n            for v, c in adj[node]:\n                if v != parent[node]:\n                    cnt += size[v]\n            size[node] = cnt\n    \n    # Collect edges that can be cut (edges where size[v] > 0 and size[v] < t)\n    candidates = []\n    for v in range(2, n + 1):\n        if 0 < size[v] < t:\n            candidates.append((edges[(parent[v], v)], depth[v], parent[v], v))\n    \n    # Sort by cost ascending, then by depth descending (to cut deeper edges first)\n    candidates.sort()\n    \n    total_cost = 0\n    edges_cut = 0\n    for cost, _, u, v in candidates:\n        if edges_cut >= k:\n            break\n        total_cost += cost\n        edges_cut += 1\n    \n    print(total_cost if edges_cut >= k else -1)\n\nsolve()",
    "timestamp": "2025-08-13 06:41:24"
  },
  {
    "model": "gpt-4o",
    "prompt_type": "zero_shot",
    "language": "c++",
    "code": "#include <iostream>\n#include <vector>\n#include <algorithm>\n#include <limits>\n\nusing namespace std;\n\nstruct Edge {\n    int u, v, cost;\n};\n\nint n, t, k;\nvector<int> bases;\nvector<Edge> edges;\nvector<vector<int>> adj;\nvector<bool> isBase;\nvector<int> dp;\n\nvoid dfs(int u, int parent) {\n    dp[u] = isBase[u] ? 1 : 0;\n    for (int v : adj[u]) {\n        if (v == parent) continue;\n        dfs(v, u);\n        dp[u] += dp[v];\n    }\n}\n\nint minCost(int u, int parent, int regions) {\n    vector<int> candidates;\n    for (int v : adj[u]) {\n        if (v == parent) continue;\n        if (dp[v] > 0) {\n            candidates.push_back(v);\n        }\n    }\n    \n    if (regions == 1) return 0;\n\n    vector<int> costs;\n    for (int v : candidates) {\n        int edgeCost = INT_MAX;\n        for (const Edge &e : edges) {\n            if ((e.u == u && e.v == v) || (e.u == v && e.v == u)) {\n                edgeCost = e.cost;\n                break;\n            }\n        }\n        costs.push_back(edgeCost + minCost(v, u, dp[v]));\n    }\n    \n    sort(costs.begin(), costs.end());\n\n    int cost = accumulate(costs.begin(), costs.begin() + regions - 1, 0);\n    \n    return cost;\n}\n\nint main() {\n    cin >> n >> t >> k;\n    bases.resize(t);\n    for (int i = 0; i < t; ++i) {\n        cin >> bases[i];\n    }\n    \n    edges.resize(n - 1);\n    adj.resize(n + 1);\n    isBase.resize(n + 1, false);\n    dp.resize(n + 1, 0);\n\n    for (int i = 0; i < n - 1; ++i) {\n        cin >> edges[i].u >> edges[i].v >> edges[i].cost;\n        adj[edges[i].u].push_back(edges[i].v);\n        adj[edges[i].v].push_back(edges[i].u);\n    }\n\n    for (int base : bases) {\n        isBase[base] = true;\n    }\n    \n    dfs(bases[0], -1);\n    \n    int result = minCost(bases[0], -1, k + 1);\n    cout << result << endl;\n\n    return 0;\n}",
    "timestamp": "2025-08-13 11:33:26"
  }
]