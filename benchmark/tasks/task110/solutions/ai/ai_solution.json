[
  {
    "model": "deepseek-v3",
    "prompt_type": "zero_shot",
    "language": "C",
    "code": "#include <stdio.h>\n#include <stdlib.h>\n#include <math.h>\n\ntypedef struct {\n    int x, y;\n} Point;\n\ntypedef struct {\n    int dir, strength;\n} Wind;\n\ntypedef struct {\n    int id;\n    Point pos;\n} House;\n\nint is_between(double angle, double start, double end) {\n    if (start <= end) {\n        return angle >= start && angle <= end;\n    } else {\n        return angle >= start || angle <= end;\n    }\n}\n\nint main() {\n    int dataset_num = 0;\n    while (1) {\n        int N, M, L;\n        scanf(\"%d %d %d\", &N, &M, &L);\n        if (N == 0 && M == 0 && L == 0) break;\n\n        dataset_num++;\n        House *houses = malloc(N * sizeof(House));\n        Point *peach_trees = malloc(M * sizeof(Point));\n        Point *cherry_trees = malloc(L * sizeof(Point));\n\n        for (int i = 0; i < N; i++) {\n            scanf(\"%d %d %d\", &houses[i].id, &houses[i].pos.x, &houses[i].pos.y);\n        }\n\n        for (int i = 0; i < M; i++) {\n            scanf(\"%d %d\", &peach_trees[i].x, &peach_trees[i].y);\n        }\n\n        for (int i = 0; i < L; i++) {\n            scanf(\"%d %d\", &cherry_trees[i].x, &cherry_trees[i].y);\n        }\n\n        int W;\n        scanf(\"%d\", &W);\n        Wind *winds = malloc(W * sizeof(Wind));\n        for (int i = 0; i < W; i++) {\n            scanf(\"%d %d\", &winds[i].dir, &winds[i].strength);\n        }\n\n        int *scent_days = calloc(N, sizeof(int));\n\n        for (int w = 0; w < W; w++) {\n            int dir = winds[w].dir;\n            int strength = winds[w].strength;\n            double angle_center = (dir - 1) * 22.5;\n            double angle_start = angle_center - 11.25;\n            double angle_end = angle_center + 11.25;\n\n            for (int h = 0; h < N; h++) {\n                int x = houses[h].pos.x;\n                int y = houses[h].pos.y;\n                if (x == 0 && y == 0) continue;\n\n                double angle = atan2(y, x) * 180.0 / M_PI;\n                if (angle < 0) angle += 360.0;\n\n                if (is_between(angle, angle_start, angle_end)) {\n                    double dist = sqrt(x * x + y * y);\n                    if (dist <= strength) {\n                        int blocked = 0;\n\n                        for (int p = 0; p < M; p++) {\n                            int px = peach_trees[p].x;\n                            int py = peach_trees[p].y;\n                            if (px == 0 && py == 0) continue;\n\n                            double p_angle = atan2(py, px) * 180.0 / M_PI;\n                            if (p_angle < 0) p_angle += 360.0;\n\n                            if (is_between(p_angle, angle_start, angle_end)) {\n                                double p_dist = sqrt(px * px + py * py);\n                                if (p_dist < dist) {\n                                    blocked = 1;\n                                    break;\n                                }\n                            }\n                        }\n\n                        if (!blocked) {\n                            for (int c = 0; c < L; c++) {\n                                int cx = cherry_trees[c].x;\n                                int cy = cherry_trees[c].y;\n                                if (cx == 0 && cy == 0) continue;\n\n                                double c_angle = atan2(cy, cx) * 180.0 / M_PI;\n                                if (c_angle < 0) c_angle += 360.0;\n\n                                if (is_between(c_angle, angle_start, angle_end)) {\n                                    double c_dist = sqrt(cx * cx + cy * cy);\n                                    if (c_dist < dist) {\n                                        blocked = 1;\n                                        break;\n                                    }\n                                }\n                            }\n                        }\n\n                        if (!blocked) {\n                            scent_days[h]++;\n                        }\n                    }\n                }\n            }\n        }\n\n        int max_days = 0;\n        for (int h = 0; h < N; h++) {\n            if (scent_days[h] > max_days) {\n                max_days = scent_days[h];\n            }\n        }\n\n        if (max_days == 0) {\n            printf(\"Case %d: NA\\n\", dataset_num);\n        } else {\n            printf(\"Case %d:\", dataset_num);\n            for (int h = 0; h < N; h++) {\n                if (scent_days[h] == max_days) {\n                    printf(\" %d\", houses[h].id);\n                }\n            }\n            printf(\"\\n\");\n        }\n\n        free(houses);\n        free(peach_trees);\n        free(cherry_trees);\n        free(winds);\n        free(scent_days);\n    }\n    return 0;\n}",
    "timestamp": "2025-08-05 18:39:24"
  },
  {
    "model": "claude-3-5-haiku-20241022",
    "prompt_type": "zero_shot",
    "language": "Java",
    "code": "import java.util.*;\n\npublic class PlumTreeScent {\n    public static void main(String[] args) {\n        Scanner scanner = new Scanner(System.in);\n        \n        while (scanner.hasNextInt()) {\n            int M = scanner.nextInt(); // Number of houses\n            int N = scanner.nextInt(); // Number of trees other than plum\n            int K = scanner.nextInt(); // Number of wind records\n            \n            if (M == 0 && N == 0 && K == 0) break;\n            \n            // House coordinates\n            int[][] houses = new int[M][2];\n            for (int i = 0; i < M; i++) {\n                houses[i][0] = scanner.nextInt();\n                houses[i][1] = scanner.nextInt();\n            }\n            \n            // Other trees coordinates\n            int[][] otherTrees = new int[N][2];\n            for (int i = 0; i < N; i++) {\n                otherTrees[i][0] = scanner.nextInt();\n                otherTrees[i][1] = scanner.nextInt();\n            }\n            \n            // Wind records\n            int[] days = new int[K];\n            int[] directions = new int[K];\n            int[] strengths = new int[K];\n            for (int i = 0; i < K; i++) {\n                days[i] = scanner.nextInt();\n                directions[i] = scanner.nextInt();\n                strengths[i] = scanner.nextInt();\n            }\n            \n            // Process each house\n            int[] maxScent = new int[M];\n            \n            for (int day = 1; day <= K; day++) {\n                int dir = directions[day-1];\n                int str = strengths[day-1];\n                \n                for (int h = 0; h < M; h++) {\n                    boolean plumReaches = isReachable(0, 0, houses[h][0], houses[h][1], dir, str);\n                    boolean otherTreeReaches = false;\n                    \n                    for (int t = 0; t < N; t++) {\n                        if (isReachable(otherTrees[t][0], otherTrees[t][1], houses[h][0], houses[h][1], dir, str)) {\n                            otherTreeReaches = true;\n                            break;\n                        }\n                    }\n                    \n                    if (plumReaches && !otherTreeReaches) {\n                        maxScent[h]++;\n                    }\n                }\n            }\n            \n            // Find max days and print result\n            int maxDays = Arrays.stream(maxScent).max().getAsInt();\n            \n            if (maxDays == 0) {\n                System.out.println(\"NA\");\n            } else {\n                for (int h = 0; h < M; h++) {\n                    if (maxScent[h] == maxDays) {\n                        System.out.print((h+1) + \" \");\n                    }\n                }\n                System.out.println();\n            }\n        }\n        \n        scanner.close();\n    }\n    \n    static boolean isReachable(int treeX, int treeY, int houseX, int houseY, int dir, int str) {\n        int dx = houseX - treeX;\n        int dy = houseY - treeY;\n        \n        // Check within wind angle\n        double angle = Math.toDegrees(Math.atan2(dy, dx));\n        if (angle < 0) angle += 360;\n        \n        double angleError = 22.5;\n        if (Math.abs(angle - dir) > angleError && \n            Math.abs(angle - dir) < 360 - angleError) {\n            return false;\n        }\n        \n        // Check within wind strength\n        double distance = Math.sqrt(dx*dx + dy*dy);\n        return distance <= str;\n    }\n}",
    "timestamp": "2025-08-05 18:39:37"
  },
  {
    "model": "deepseek-v3",
    "prompt_type": "zero_shot",
    "language": "C++",
    "code": "#include <iostream>\n#include <vector>\n#include <cmath>\n#include <algorithm>\n#include <map>\n\nusing namespace std;\n\nstruct Point {\n    int x, y;\n    Point(int x = 0, int y = 0) : x(x), y(y) {}\n};\n\nstruct Wind {\n    int dir, strength;\n    Wind(int dir = 0, int strength = 0) : dir(dir), strength(strength) {}\n};\n\nbool isInFan(const Point& tree, const Wind& wind) {\n    double angle = atan2(tree.y, tree.x) * 180 / M_PI;\n    if (angle < 0) angle += 360;\n    int spread = 30;\n    double lower = wind.dir - spread;\n    double upper = wind.dir + spread;\n    if (lower < 0) lower += 360;\n    if (upper >= 360) upper -= 360;\n    \n    double dist = sqrt(tree.x * tree.x + tree.y * tree.y);\n    if (dist > wind.strength) return false;\n    \n    if (lower <= upper) {\n        return (angle >= lower && angle <= upper);\n    } else {\n        return (angle >= lower || angle <= upper);\n    }\n}\n\nint main() {\n    int N;\n    while (cin >> N && N != 0) {\n        vector<Point> houses(N);\n        for (int i = 0; i < N; ++i) {\n            cin >> houses[i].x >> houses[i].y;\n        }\n        \n        int M;\n        cin >> M;\n        vector<Point> trees(M);\n        vector<char> types(M);\n        for (int i = 0; i < M; ++i) {\n            cin >> types[i] >> trees[i].x >> trees[i].y;\n        }\n        \n        int K;\n        cin >> K;\n        vector<Wind> winds(K);\n        for (int i = 0; i < K; ++i) {\n            cin >> winds[i].dir >> winds[i].strength;\n        }\n        \n        map<int, int> houseCounts;\n        for (int day = 0; day < K; ++day) {\n            Wind wind = winds[day];\n            vector<bool> houseReached(N, false);\n            bool plumOnly = true;\n            \n            for (int i = 0; i < N; ++i) {\n                houseReached[i] = isInFan(houses[i], wind);\n            }\n            \n            for (int i = 0; i < M; ++i) {\n                if (types[i] == 'p') continue;\n                if (isInFan(trees[i], wind)) {\n                    for (int j = 0; j < N; ++j) {\n                        if (houseReached[j] && isInFan(Point(houses[j].x - trees[i].x, houses[j].y - trees[i].y), wind)) {\n                            plumOnly = false;\n                            break;\n                        }\n                    }\n                    if (!plumOnly) break;\n                }\n            }\n            \n            if (plumOnly) {\n                for (int i = 0; i < N; ++i) {\n                    if (houseReached[i]) {\n                        houseCounts[i]++;\n                    }\n                }\n            }\n        }\n        \n        if (houseCounts.empty()) {\n            cout << \"NA\" << endl;\n        } else {\n            int maxDays = 0;\n            for (auto& p : houseCounts) {\n                if (p.second > maxDays) {\n                    maxDays = p.second;\n                }\n            }\n            vector<int> bestHouses;\n            for (auto& p : houseCounts) {\n                if (p.second == maxDays) {\n                    bestHouses.push_back(p.first + 1);\n                }\n            }\n            sort(bestHouses.begin(), bestHouses.end());\n            for (size_t i = 0; i < bestHouses.size(); ++i) {\n                if (i != 0) cout << \" \";\n                cout << bestHouses[i];\n            }\n            cout << endl;\n        }\n    }\n    return 0;\n}",
    "timestamp": "2025-08-05 18:40:36"
  },
  {
    "model": "claude-3-5-haiku-20241022",
    "prompt_type": "zero_shot",
    "language": "C",
    "code": "#include <stdio.h>\n#include <stdlib.h>\n#include <string.h>\n#include <math.h>\n\n#define MAX_HOUSES 100\n#define MAX_DAYS 365\n#define MAX_TREES 10\n\ntypedef struct {\n    int x, y;\n} Point;\n\ntypedef struct {\n    int direction;\n    int strength;\n} WindData;\n\nint isInScent(Point house, Point tree, WindData wind) {\n    double dx = house.x - tree.x;\n    double dy = house.y - tree.y;\n    double distance = sqrt(dx*dx + dy*dy);\n    \n    double angle = atan2(dy, dx) * 180 / M_PI;\n    double windAngle = wind.direction;\n    \n    double halfSpread = 45.0;\n    double angleDiff = fabs(angle - windAngle);\n    \n    return (angleDiff <= halfSpread && distance <= wind.strength);\n}\n\nint main() {\n    int datasets;\n    scanf(\"%d\", &datasets);\n    \n    while (datasets--) {\n        int numHouses, numTrees, numDays;\n        Point houses[MAX_HOUSES], trees[MAX_TREES];\n        WindData winds[MAX_DAYS];\n        \n        scanf(\"%d %d %d\", &numHouses, &numTrees, &numDays);\n        \n        for (int i = 0; i < numHouses; i++)\n            scanf(\"%d %d\", &houses[i].x, &houses[i].y);\n        \n        for (int i = 0; i < numTrees; i++)\n            scanf(\"%d %d\", &trees[i].x, &trees[i].y);\n        \n        for (int i = 0; i < numDays; i++)\n            scanf(\"%d %d\", &winds[i].direction, &winds[i].strength);\n        \n        Point plumTree = {0, 0};\n        int maxDays[MAX_HOUSES] = {0};\n        \n        for (int day = 0; day < numDays; day++) {\n            int exclusiveDays[MAX_HOUSES] = {0};\n            \n            for (int h = 0; h < numHouses; h++) {\n                int plumScent = isInScent(houses[h], plumTree, winds[day]);\n                int otherScent = 0;\n                \n                for (int t = 0; t < numTrees; t++) {\n                    if (trees[t].x == 0 && trees[t].y == 0) continue;\n                    if (isInScent(houses[h], trees[t], winds[day])) {\n                        otherScent = 1;\n                        break;\n                    }\n                }\n                \n                if (plumScent && !otherScent)\n                    exclusiveDays[h]++;\n            }\n            \n            for (int h = 0; h < numHouses; h++)\n                maxDays[h] += exclusiveDays[h];\n        }\n        \n        int maxExclusiveDays = 0;\n        for (int h = 0; h < numHouses; h++)\n            maxExclusiveDays = fmax(maxExclusiveDays, maxDays[h]);\n        \n        if (maxExclusiveDays == 0) {\n            printf(\"NA\\n\");\n        } else {\n            for (int h = 0; h < numHouses; h++) {\n                if (maxDays[h] == maxExclusiveDays)\n                    printf(\"%d \", h + 1);\n            }\n            printf(\"\\n\");\n        }\n    }\n    \n    return 0;\n}",
    "timestamp": "2025-08-05 18:40:49"
  },
  {
    "model": "claude-3-5-haiku-20241022",
    "prompt_type": "zero_shot",
    "language": "C++",
    "code": "#include <iostream>\n#include <vector>\n#include <algorithm>\n#include <cmath>\n#include <limits>\n#include <iomanip>\n\nusing namespace std;\n\nconst double PI = acos(-1.0);\nconst double EPS = 1e-9;\n\nstruct Point {\n    double x, y;\n    Point(double x = 0, double y = 0) : x(x), y(y) {}\n};\n\nstruct Wind {\n    double direction, strength;\n};\n\nbool pointInSector(const Point& point, const Point& origin, double direction, double strength) {\n    double dx = point.x - origin.x;\n    double dy = point.y - origin.y;\n    \n    double distance = sqrt(dx * dx + dy * dy);\n    if (distance > strength) return false;\n    \n    double angle = atan2(dy, dx);\n    if (angle < 0) angle += 2 * PI;\n    \n    double windAngle = direction * PI / 180.0;\n    double halfSector = 45.0 * PI / 180.0;\n    \n    return abs(angle - windAngle) <= halfSector;\n}\n\nint main() {\n    int numDatasets;\n    cin >> numDatasets;\n    \n    for (int dataset = 1; dataset <= numDatasets; ++dataset) {\n        int numHouses, numTrees, numWindDays;\n        cin >> numHouses >> numTrees >> numWindDays;\n        \n        vector<Point> houses(numHouses);\n        for (int i = 0; i < numHouses; ++i) {\n            cin >> houses[i].x >> houses[i].y;\n        }\n        \n        vector<Point> trees(numTrees);\n        for (int i = 0; i < numTrees; ++i) {\n            cin >> trees[i].x >> trees[i].y;\n        }\n        \n        vector<Wind> winds(numWindDays);\n        for (int i = 0; i < numWindDays; ++i) {\n            cin >> winds[i].direction >> winds[i].strength;\n        }\n        \n        Point plumTree(0, 0);\n        vector<int> daysCounted(numHouses, 0);\n        \n        for (int day = 0; day < numWindDays; ++day) {\n            vector<bool> treeReaches(numTrees, false);\n            \n            for (int t = 0; t < numTrees; ++t) {\n                if (pointInSector(trees[t], plumTree, winds[day].direction, winds[day].strength)) {\n                    treeReaches[t] = true;\n                }\n            }\n            \n            for (int h = 0; h < numHouses; ++h) {\n                bool plumScent = pointInSector(houses[h], plumTree, winds[day].direction, winds[day].strength);\n                bool otherScent = false;\n                \n                for (int t = 0; t < numTrees; ++t) {\n                    if (treeReaches[t] && pointInSector(houses[h], trees[t], winds[day].direction, winds[day].strength)) {\n                        otherScent = true;\n                        break;\n                    }\n                }\n                \n                if (plumScent && !otherScent) {\n                    daysCounted[h]++;\n                }\n            }\n        }\n        \n        int maxDays = *max_element(daysCounted.begin(), daysCounted.end());\n        \n        cout << \"Dataset \" << dataset << \":\" << endl;\n        if (maxDays == 0) {\n            cout << \"NA\" << endl;\n        } else {\n            for (int h = 0; h < numHouses; ++h) {\n                if (daysCounted[h] == maxDays) {\n                    cout << \"House \" << h + 1 << endl;\n                }\n            }\n        }\n    }\n    \n    return 0;\n}",
    "timestamp": "2025-08-05 18:42:07"
  },
  {
    "model": "deepseek-v3",
    "prompt_type": "zero_shot",
    "language": "Java",
    "code": "import java.util.*;\n\npublic class PlumTreeScent {\n    static class Point {\n        int x, y;\n        Point(int x, int y) {\n            this.x = x;\n            this.y = y;\n        }\n    }\n\n    static class House {\n        int id, x, y;\n        House(int id, int x, int y) {\n            this.id = id;\n            this.x = x;\n            this.y = y;\n        }\n    }\n\n    static class Tree {\n        int x, y;\n        char type;\n        Tree(int x, int y, char type) {\n            this.x = x;\n            this.y = y;\n            this.type = type;\n        }\n    }\n\n    static class Wind {\n        int dir, strength;\n        Wind(int dir, int strength) {\n            this.dir = dir;\n            this.strength = strength;\n        }\n    }\n\n    public static void main(String[] args) {\n        Scanner scanner = new Scanner(System.in);\n        while (scanner.hasNext()) {\n            int N = scanner.nextInt();\n            if (N == 0) break;\n            List<House> houses = new ArrayList<>();\n            for (int i = 0; i < N; i++) {\n                int id = scanner.nextInt();\n                int x = scanner.nextInt();\n                int y = scanner.nextInt();\n                houses.add(new House(id, x, y));\n            }\n\n            int M = scanner.nextInt();\n            List<Tree> trees = new ArrayList<>();\n            for (int i = 0; i < M; i++) {\n                String type = scanner.next();\n                int x = scanner.nextInt();\n                int y = scanner.nextInt();\n                trees.add(new Tree(x, y, type.charAt(0)));\n            }\n\n            int K = scanner.nextInt();\n            List<Wind> winds = new ArrayList<>();\n            for (int i = 0; i < K; i++) {\n                int dir = scanner.nextInt();\n                int strength = scanner.nextInt();\n                winds.add(new Wind(dir, strength));\n            }\n\n            Map<Integer, Integer> houseScentDays = new HashMap<>();\n            for (House house : houses) {\n                houseScentDays.put(house.id, 0);\n            }\n\n            for (Wind wind : winds) {\n                double dirRad = Math.toRadians(wind.dir);\n                double cosDir = Math.cos(dirRad);\n                double sinDir = Math.sin(dirRad);\n\n                for (House house : houses) {\n                    boolean plumOnly = true;\n                    double hx = house.x;\n                    double hy = house.y;\n\n                    // Check if plum scent reaches the house\n                    boolean plumReaches = isInFan(hx, hy, 0, 0, cosDir, sinDir, wind.strength);\n                    if (!plumReaches) continue;\n\n                    // Check other trees\n                    for (Tree tree : trees) {\n                        if (tree.type == 'p') continue; // plum is origin\n                        double tx = tree.x;\n                        double ty = tree.y;\n                        if (isInFan(hx, hy, tx, ty, cosDir, sinDir, wind.strength)) {\n                            plumOnly = false;\n                            break;\n                        }\n                    }\n\n                    if (plumOnly) {\n                        houseScentDays.put(house.id, houseScentDays.get(house.id) + 1);\n                    }\n                }\n            }\n\n            int maxDays = -1;\n            List<Integer> bestHouses = new ArrayList<>();\n            for (House house : houses) {\n                int days = houseScentDays.get(house.id);\n                if (days > maxDays) {\n                    maxDays = days;\n                    bestHouses.clear();\n                    bestHouses.add(house.id);\n                } else if (days == maxDays) {\n                    bestHouses.add(house.id);\n                }\n            }\n\n            if (maxDays == 0) {\n                System.out.println(\"NA\");\n            } else {\n                Collections.sort(bestHouses);\n                for (int i = 0; i < bestHouses.size(); i++) {\n                    if (i > 0) System.out.print(\" \");\n                    System.out.print(bestHouses.get(i));\n                }\n                System.out.println();\n            }\n        }\n        scanner.close();\n    }\n\n    static boolean isInFan(double hx, double hy, double tx, double ty, double cosDir, double sinDir, int strength) {\n        double dx = hx - tx;\n        double dy = hy - ty;\n        double dist = Math.sqrt(dx * dx + dy * dy);\n        if (dist > strength) return false;\n\n        double angle = Math.atan2(dy, dx);\n        double fanAngle = Math.PI / 8.0; // 22.5 degrees in radians\n        double windAngle = Math.atan2(sinDir, cosDir);\n\n        double angleDiff = Math.abs(normalizeAngle(angle - windAngle));\n        return angleDiff <= fanAngle;\n    }\n\n    static double normalizeAngle(double angle) {\n        while (angle > Math.PI) angle -= 2 * Math.PI;\n        while (angle < -Math.PI) angle += 2 * Math.PI;\n        return angle;\n    }\n}",
    "timestamp": "2025-08-05 18:44:13"
  },
  {
    "model": "gpt-4o",
    "prompt_type": "zero_shot",
    "language": "python",
    "code": "def plum_tree_scent(houses, trees, wind_data):\n    def is_scent_reaching(house, wind_direction, strength, tree):\n        if tree == (0, 0):  # Ignore the plum tree itself\n            return False\n        dx = house[0] - tree[0]\n        dy = house[1] - tree[1]\n        if wind_direction == 'N':\n            if dy <= 0 and abs(dx) <= strength:\n                return True\n        elif wind_direction == 'S':\n            if dy >= 0 and abs(dx) <= strength:\n                return True\n        elif wind_direction == 'E':\n            if dx >= 0 and abs(dy) <= strength:\n                return True\n        elif wind_direction == 'W':\n            if dx <= 0 and abs(dy) <= strength:\n                return True\n        return False\n\n    def plum_scent_reaches(house, wind_direction, strength):\n        if wind_direction == 'N':\n            if house[1] <= 0 and abs(house[0]) <= strength:\n                return True\n        elif wind_direction == 'S':\n            if house[1] >= 0 and abs(house[0]) <= strength:\n                return True\n        elif wind_direction == 'E':\n            if house[0] >= 0 and abs(house[1]) <= strength:\n                return True\n        elif wind_direction == 'W':\n            if house[0] <= 0 and abs(house[1]) <= strength:\n                return True\n        return False\n\n    results = []\n    for dataset in range(len(wind_data)):\n        max_days = 0\n        best_houses = []\n        houses_positions = houses[dataset]\n        trees_positions = trees[dataset]\n        wind_days = wind_data[dataset]\n\n        for house in houses_positions:\n            unique_days = 0\n            for wind_direction, strength in wind_days:\n                if plum_scent_reaches(house, wind_direction, strength):\n                    if not any(is_scent_reaching(house, wind_direction, strength, tree) for tree in trees_positions):\n                        unique_days += 1\n\n            if unique_days > max_days:\n                max_days = unique_days\n                best_houses = [house]\n            elif unique_days == max_days and unique_days > 0:\n                best_houses.append(house)\n\n        results.append(best_houses if best_houses else 'NA')\n\n    return results\n\n\n# Example usage:\nhouses = [[(1, 2), (3, 4)], [(5, 6), (7, 8)]]\ntrees = [[(1, 0), (2, -1)], [(3, 3), (6, 5)]]\nwind_data = [\n    [('N', 3), ('S', 2), ('E', 1)],\n    [('W', 4), ('N', 2), ('E', 3)]\n]\n\nprint(plum_tree_scent(houses, trees, wind_data))",
    "timestamp": "2025-08-13 00:25:30"
  },
  {
    "model": "gpt-4o",
    "prompt_type": "zero_shot",
    "language": "java",
    "code": "import java.util.*;\nimport java.io.*;\n\npublic class PlumTreeScent {\n\n    static class House {\n        int x, y;\n        public House(int x, int y) {\n            this.x = x;\n            this.y = y;\n        }\n    }\n\n    static class Tree {\n        int x, y;\n        String type;\n        public Tree(int x, int y, String type) {\n            this.x = x;\n            this.y = y;\n            this.type = type;\n        }\n    }\n\n    static class Wind {\n        int direction; // 0 = North, 1 = East, 2 = South, 3 = West\n        int strength;\n        public Wind(int direction, int strength) {\n            this.direction = direction;\n            this.strength = strength;\n        }\n    }\n\n    public static void main(String[] args) throws IOException {\n        BufferedReader br = new BufferedReader(new InputStreamReader(System.in));\n        String line;\n        while ((line = br.readLine()) != null && !line.isEmpty()) {\n            StringTokenizer st = new StringTokenizer(line);\n            int nHouses = Integer.parseInt(st.nextToken());\n            int nTrees = Integer.parseInt(st.nextToken());\n            int nWindDays = Integer.parseInt(st.nextToken());\n\n            List<House> houses = new ArrayList<>();\n            for (int i = 0; i < nHouses; i++) {\n                st = new StringTokenizer(br.readLine());\n                int x = Integer.parseInt(st.nextToken());\n                int y = Integer.parseInt(st.nextToken());\n                houses.add(new House(x, y));\n            }\n\n            List<Tree> trees = new ArrayList<>();\n            for (int i = 0; i < nTrees; i++) {\n                st = new StringTokenizer(br.readLine());\n                int x = Integer.parseInt(st.nextToken());\n                int y = Integer.parseInt(st.nextToken());\n                String type = st.nextToken();\n                trees.add(new Tree(x, y, type));\n            }\n\n            List<Wind> winds = new ArrayList<>();\n            for (int i = 0; i < nWindDays; i++) {\n                st = new StringTokenizer(br.readLine());\n                int direction = Integer.parseInt(st.nextToken());\n                int strength = Integer.parseInt(st.nextToken());\n                winds.add(new Wind(direction, strength));\n            }\n\n            int[] aloneDays = new int[nHouses];\n            for (Wind wind : winds) {\n                for (int i = 0; i < nHouses; i++) {\n                    boolean plumReach = reaches(houses.get(i), new Tree(0, 0, \"Plum\"), wind);\n                    boolean otherReach = false;\n                    for (Tree tree : trees) {\n                        if (!tree.type.equals(\"Plum\") && reaches(houses.get(i), tree, wind)) {\n                            otherReach = true;\n                            break;\n                        }\n                    }\n                    if (plumReach && !otherReach) {\n                        aloneDays[i]++;\n                    }\n                }\n            }\n\n            int maxDays = Arrays.stream(aloneDays).max().orElse(0);\n            if (maxDays == 0) {\n                System.out.println(\"NA\");\n            } else {\n                for (int i = 0; i < nHouses; i++) {\n                    if (aloneDays[i] == maxDays) {\n                        System.out.println(i + 1);\n                    }\n                }\n            }\n        }\n    }\n\n    static boolean reaches(House house, Tree tree, Wind wind) {\n        int dx = house.x - tree.x;\n        int dy = house.y - tree.y;\n        switch (wind.direction) {\n            case 0: return dy >= 0 && Math.abs(dx) <= wind.strength; // North\n            case 1: return dx >= 0 && Math.abs(dy) <= wind.strength; // East\n            case 2: return dy <= 0 && Math.abs(dx) <= wind.strength; // South\n            case 3: return dx <= 0 && Math.abs(dy) <= wind.strength; // West\n        }\n        return false;\n    }\n}",
    "timestamp": "2025-08-13 00:26:16"
  },
  {
    "model": "gpt-4o",
    "prompt_type": "zero_shot",
    "language": "c",
    "code": "#include <stdio.h>\n#include <stdlib.h>\n#include <string.h>\n\n#define MAX_HOUSES 100\n#define MAX_TREES 100\n#define MAX_DAYS 365\n\ntypedef struct {\n    int x, y;\n} Position;\n\ntypedef struct {\n    char direction;\n    int strength;\n} Wind;\n\ntypedef struct {\n    Position plumTree;\n    Position houses[MAX_HOUSES];\n    int houseCount;\n    Position otherTrees[MAX_TREES];\n    int treeCount;\n    Wind windData[MAX_DAYS];\n    int dayCount;\n} Dataset;\n\nvoid readDatasets(Dataset datasets[], int *datasetCount) {\n    int n;\n    scanf(\"%d\", &n);\n    *datasetCount = n;\n    \n    for (int i = 0; i < n; i++) {\n        Dataset ds;\n        scanf(\"%d %d\", &ds.plumTree.x, &ds.plumTree.y);\n        \n        scanf(\"%d\", &ds.houseCount);\n        for (int j = 0; j < ds.houseCount; j++) {\n            scanf(\"%d %d\", &ds.houses[j].x, &ds.houses[j].y);\n        }\n        \n        scanf(\"%d\", &ds.treeCount);\n        for (int j = 0; j < ds.treeCount; j++) {\n            scanf(\"%d %d\", &ds.otherTrees[j].x, &ds.otherTrees[j].y);\n        }\n        \n        scanf(\"%d\", &ds.dayCount);\n        for (int j = 0; j < ds.dayCount; j++) {\n            scanf(\" %c %d\", &ds.windData[j].direction, &ds.windData[j].strength);\n        }\n        \n        datasets[i] = ds;\n    }\n}\n\nint isPlumOnlyReachable(Position house, Position plumTree, Position otherTrees[], int treeCount, Wind wind) {\n    // Simplified scent reachability calculation based on wind direction and strength\n    int plumReachX, plumReachY;\n    \n    switch (wind.direction) {\n        case 'N':\n            plumReachX = plumTree.x;\n            plumReachY = plumTree.y + wind.strength;\n            break;\n        case 'S':\n            plumReachX = plumTree.x;\n            plumReachY = plumTree.y - wind.strength;\n            break;\n        case 'E':\n            plumReachX = plumTree.x + wind.strength;\n            plumReachY = plumTree.y;\n            break;\n        case 'W':\n            plumReachX = plumTree.x - wind.strength;\n            plumReachY = plumTree.y;\n            break;\n        default:\n            return 0;\n    }\n    \n    if (plumReachX != house.x || plumReachY != house.y) {\n        return 0;\n    }\n    \n    for (int i = 0; i < treeCount; i++) {\n        Position tree = otherTrees[i];\n        int treeReachX, treeReachY;\n        \n        switch (wind.direction) {\n            case 'N':\n                treeReachX = tree.x;\n                treeReachY = tree.y + wind.strength;\n                break;\n            case 'S':\n                treeReachX = tree.x;\n                treeReachY = tree.y - wind.strength;\n                break;\n            case 'E':\n                treeReachX = tree.x + wind.strength;\n                treeReachY = tree.y;\n                break;\n            case 'W':\n                treeReachX = tree.x - wind.strength;\n                treeReachY = tree.y;\n                break;\n            default:\n                return 0;\n        }\n        \n        if (treeReachX == house.x && treeReachY == house.y) {\n            return 0;\n        }\n    }\n    \n    return 1;\n}\n\nvoid findBestHouse(Dataset ds) {\n    int maxDays = 0;\n    int bestHouseIdx = -1;\n    \n    for (int i = 0; i < ds.houseCount; i++) {\n        Position house = ds.houses[i];\n        int days = 0;\n        \n        for (int j = 0; j < ds.dayCount; j++) {\n            Wind wind = ds.windData[j];\n            if (isPlumOnlyReachable(house, ds.plumTree, ds.otherTrees, ds.treeCount, wind)) {\n                days++;\n            }\n        }\n        \n        if (days > maxDays) {\n            maxDays = days;\n            bestHouseIdx = i;\n        }\n    }\n    \n    if (bestHouseIdx == -1) {\n        printf(\"NA\\n\");\n    } else {\n        printf(\"%d %d\\n\", ds.houses[bestHouseIdx].x, ds.houses[bestHouseIdx].y);\n    }\n}\n\nint main() {\n    Dataset datasets[MAX_HOUSES];\n    int datasetCount;\n    \n    readDatasets(datasets, &datasetCount);\n    \n    for (int i = 0; i < datasetCount; i++) {\n        findBestHouse(datasets[i]);\n    }\n    \n    return 0;\n}",
    "timestamp": "2025-08-13 00:26:26"
  },
  {
    "model": "claude-3-5-haiku-20241022",
    "prompt_type": "zero_shot",
    "language": "python",
    "code": "def solve_scent_problem():\n    while True:\n        try:\n            N = int(input())\n            if N == 0:\n                break\n\n            # Store houses\n            houses = []\n            for _ in range(N):\n                x, y = map(int, input().split())\n                houses.append((x, y))\n\n            # Store tree positions\n            M = int(input())\n            trees = []\n            for _ in range(M):\n                x, y, type_tree = input().split()\n                trees.append((int(x), int(y), type_tree))\n\n            # Wind data\n            K = int(input())\n            wind_data = []\n            for _ in range(K):\n                day, direction, strength = input().split()\n                wind_data.append((int(day), direction, int(strength)))\n\n            # Check scent coverage\n            max_days = 0\n            valid_houses = []\n\n            for house_idx, (hx, hy) in enumerate(houses):\n                days_only_plum = 0\n                for day, direction, strength in wind_data:\n                    house_reached_only_plum = True\n\n                    # Check plum tree scent\n                    plum_covers = check_scent_coverage(0, 0, hx, hy, direction, strength)\n\n                    # Check other tree scents\n                    for tx, ty, tree_type in trees:\n                        if tree_type != 'plum' and check_scent_coverage(tx, ty, hx, hy, direction, strength):\n                            house_reached_only_plum = False\n                            break\n\n                    if plum_covers and house_reached_only_plum:\n                        days_only_plum += 1\n\n                if days_only_plum > max_days:\n                    max_days = days_only_plum\n                    valid_houses = [house_idx + 1]\n                elif days_only_plum == max_days and max_days > 0:\n                    valid_houses.append(house_idx + 1)\n\n            # Output results\n            if max_days == 0:\n                print('NA')\n            else:\n                print(' '.join(map(str, sorted(valid_houses))))\n\n        except EOFError:\n            break\n\ndef check_scent_coverage(tx, ty, hx, hy, direction, strength):\n    # Vector from tree to house\n    dx, dy = hx - tx, hy - ty\n\n    # Normalize directions\n    dirs = {\n        'N': (0, 1),\n        'S': (0, -1),\n        'E': (1, 0),\n        'W': (-1, 0),\n        'NE': (1, 1),\n        'NW': (-1, 1),\n        'SE': (1, -1),\n        'SW': (-1, -1)\n    }\n\n    wind_vec = dirs[direction]\n    \n    # Dot product to check angle\n    dot_product = dx * wind_vec[0] + dy * wind_vec[1]\n    \n    # Check angle within 45 degrees and distance within wind strength\n    distance = (dx**2 + dy**2)**0.5\n    angle_check = dot_product / (((dx**2 + dy**2)**0.5) * ((wind_vec[0]**2 + wind_vec[1]**2)**0.5))\n    \n    return (dot_product > 0 and \n            angle_check >= 0.707 and \n            distance <= strength)\n\nsolve_scent_problem()",
    "timestamp": "2025-08-13 00:26:52"
  },
  {
    "model": "deepseek-v3",
    "prompt_type": "zero_shot",
    "language": "python",
    "code": "import sys\nimport math\n\ndef readints():\n    return list(map(int, sys.stdin.readline().split()))\n\ndef solve():\n    while True:\n        line = sys.stdin.readline()\n        if not line:\n            break\n        N = int(line.strip())\n        if N == 0:\n            break\n        M = int(sys.stdin.readline().strip())\n        houses = []\n        for _ in range(M):\n            x, y = map(int, sys.stdin.readline().split())\n            houses.append((x, y))\n        K = int(sys.stdin.readline().strip())\n        trees = []\n        for _ in range(K):\n            x, y, t = map(int, sys.stdin.readline().split())\n            trees.append((x, y, t))\n        L = int(sys.stdin.readline().strip())\n        winds = []\n        for _ in range(L):\n            d, s = map(int, sys.stdin.readline().split())\n            winds.append((d, s))\n        \n        max_days = -1\n        best_houses = []\n        \n        for house in houses:\n            hx, hy = house\n            count = 0\n            for wind in winds:\n                d, s = wind\n                if s == 0:\n                    continue\n                theta = math.radians(d)\n                dx = math.cos(theta)\n                dy = math.sin(theta)\n                \n                # Check if plum (origin) reaches the house\n                # Vector from origin to house\n                ox, oy = hx, hy\n                # Cross product to check if in same direction\n                cross = ox * dy - oy * dx\n                if abs(cross) > 1e-9:\n                    continue  # Not in the same direction\n                dot = ox * dx + oy * dy\n                if dot <= 0:\n                    continue  # Opposite direction\n                # Check distance\n                dist_origin = math.hypot(ox, oy)\n                if dist_origin > s:\n                    continue\n                \n                # Now check other trees\n                blocked = False\n                for tree in trees:\n                    tx, ty, tt = tree\n                    # Vector from origin to tree\n                    otx, oty = tx, ty\n                    # Check if tree is in the same direction as wind\n                    cross_tree = otx * dy - oty * dx\n                    if abs(cross_tree) > 1e-9:\n                        continue  # Not in same direction\n                    dot_tree = otx * dx + oty * dy\n                    if dot_tree <= 0:\n                        continue  # Opposite direction\n                    dist_tree = math.hypot(otx, oty)\n                    if dist_tree > s:\n                        continue\n                    # Check if tree is closer than house\n                    if dot_tree < dot:\n                        blocked = True\n                        break\n                if not blocked:\n                    count += 1\n            if count > max_days:\n                max_days = count\n                best_houses = [house]\n            elif count == max_days:\n                best_houses.append(house)\n        \n        if max_days <= 0:\n            print(\"NA\")\n        else:\n            best_houses.sort()\n            for house in best_houses:\n                print(house[0], house[1])\n\nif __name__ == \"__main__\":\n    solve()",
    "timestamp": "2025-08-13 00:27:26"
  },
  {
    "model": "gpt-4o",
    "prompt_type": "zero_shot",
    "language": "c++",
    "code": "#include <iostream>\n#include <vector>\n#include <cmath>\n#include <map>\n#include <set>\nusing namespace std;\n\nstruct Tree {\n    int x, y;\n    char type;\n};\n\nstruct Wind {\n    double angle;\n    double strength;\n};\n\nstruct House {\n    int x, y;\n};\n\nbool isInFan(int hx, int hy, double angle, double strength) {\n    double houseAngle = atan2(hy, hx) * 180 / M_PI;\n    double houseDistance = sqrt(hx * hx + hy * hy);\n    return fabs(houseAngle - angle) <= 45 && houseDistance <= strength;\n}\n\nbool interferesWithOthers(int hx, int hy, const vector<Tree>& trees, double angle, double strength) {\n    for (const auto& tree : trees) {\n        double treeAngle = atan2(tree.y, tree.x) * 180 / M_PI;\n        double treeDistance = sqrt(tree.x * tree.x + tree.y * tree.y);\n        if (fabs(treeAngle - angle) <= 45 && treeDistance <= strength && tree.type != 'P') {\n            return true;\n        }\n    }\n    return false;\n}\n\nvector<House> findBestHouses(const vector<House>& houses, const vector<Tree>& trees, const vector<Wind>& winds) {\n    map<House, int> houseDays;\n    for (const auto& house : houses) {\n        houseDays[house] = 0;\n    }\n\n    for (const auto& wind : winds) {\n        for (const auto& house : houses) {\n            if (isInFan(house.x, house.y, wind.angle, wind.strength) &&\n                !interferesWithOthers(house.x, house.y, trees, wind.angle, wind.strength)) {\n                houseDays[house]++;\n            }\n        }\n    }\n\n    int maxDays = 0;\n    vector<House> bestHouses;\n    for (const auto& [house, days] : houseDays) {\n        if (days > maxDays) {\n            bestHouses.clear();\n            bestHouses.push_back(house);\n            maxDays = days;\n        } else if (days == maxDays && maxDays > 0) {\n            bestHouses.push_back(house);\n        }\n    }\n\n    return bestHouses;\n}\n\nint main() {\n    int datasets;\n    cin >> datasets;\n\n    while (datasets--) {\n        int numHouses, numTrees, numWinds;\n        cin >> numHouses >> numTrees >> numWinds;\n\n        vector<House> houses(numHouses);\n        for (int i = 0; i < numHouses; ++i) {\n            cin >> houses[i].x >> houses[i].y;\n        }\n\n        vector<Tree> trees(numTrees);\n        for (int i = 0; i < numTrees; ++i) {\n            cin >> trees[i].x >> trees[i].y >> trees[i].type;\n        }\n\n        vector<Wind> winds(numWinds);\n        for (int i = 0; i < numWinds; ++i) {\n            cin >> winds[i].angle >> winds[i].strength;\n        }\n\n        vector<House> bestHouses = findBestHouses(houses, trees, winds);\n\n        if (bestHouses.empty()) {\n            cout << \"NA\" << endl;\n        } else {\n            for (const auto& house : bestHouses) {\n                cout << house.x << \" \" << house.y << endl;\n            }\n        }\n    }\n\n    return 0;\n}",
    "timestamp": "2025-08-13 10:54:03"
  }
]