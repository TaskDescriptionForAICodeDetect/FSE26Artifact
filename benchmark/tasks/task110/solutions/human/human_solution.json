[
  {
    "language": "Scala",
    "code": "import scala.annotation.tailrec\nimport scala.collection.mutable\nimport scala.io.StdIn._\nobject Main extends App {\n  loop\n  @tailrec\n  def loop: Unit = {\n    val Array(h, r) = readLine.trim.split(' ').map(_.toInt)\n    if (h == 0) return\n    val suspects = Array.tabulate(h){_ ⇒\n      val Array(x, y) = readLine.trim.split(' ').map(_.toInt)\n      Point(x, y)\n    }\n    val Array(u, m, s, du, dm, ds) = readLine.trim.split(' ').map(_.toInt)\n    val ume = Array.tabulate(u){_ ⇒\n      val Array(x, y) = readLine.trim.split(' ').map(_.toInt)\n      Point(x, y)\n    }\n    val momo = Array.tabulate(m){_ ⇒\n      val Array(x, y) = readLine.trim.split(' ').map(_.toInt)\n      Point(x, y)\n    }\n    val sakura = Array.tabulate(s){_ ⇒\n      val Array(x, y) = readLine.trim.split(' ').map(_.toInt)\n      Point(x, y)\n    }\n    val umeAngle = Angle.byMeasure(du / 2.0)\n    val momoAngle = Angle.byMeasure(dm / 2.0)\n    val sakuraAngle = Angle.byMeasure(ds / 2.0)\n    val trees = Array(ume → umeAngle, momo → momoAngle, sakura → sakuraAngle)\n    val count = Array.tabulate(h){_ ⇒ 0}\n    for (_ ← 0 until r){\n      val Array(w, a) = readLine.trim.split(' ').map(_.toInt)\n      val wind = Angle.byMeasure(w)\n      var s = suspects.indices.filter(i ⇒ isReach(Point(0, 0), suspects(i), wind, umeAngle, a))\n      s = s.filterNot(i ⇒ trees.exists{case (tree, angle) ⇒ tree.exists(t ⇒ isReach(t, suspects(i), wind, angle, a))})\n      s.foreach(i ⇒ count(i) += 1)\n    }\n    println(\n      if (count.forall(_ == 0)) \"NA\" else count.max match {case c ⇒ count.indices.filter(i ⇒ count(i) == c).map(_ + 1).mkString(\" \")}\n    )\n    loop\n  }\n\n  def isReach(tree: Point, house: Point, wind: Angle, range: Angle, length: Int): Boolean = {\n    (tree.distance(house) <= length) && (wind + range - Angle(tree.vectorTo(house))).sin >= 0 && (wind - range - Angle(tree.vectorTo(house))).sin <= 0\n  }\n\n  case class Point(x: Int, y: Int) {\n    def distance(that: Point): Double = this - that match {case p ⇒ math.sqrt(p.x * p.x + p.y * p.y)}\n    def -(that: Point): Point = Point(x - that.x, y - that.y)\n    def vectorTo(that: Point): Vector = that - this match {case Point(dx, dy) ⇒ Vector(dx, dy)}\n  }\n\n  case class Vector(x: Int, y: Int) {\n    def dot(that: Vector): Int = x * that.x + y * that.y\n    def cross(that: Vector): Int = x * that.y - y * that.x\n  }\n  object Angle{\n    def byMeasure(measure: Double): Angle = {\n      val rad = measure / 180 * math.Pi\n      new Angle(math.sin(rad), math.cos(rad))\n    }\n    def apply(vector: Vector): Angle = math.sqrt(vector.x * vector.x + vector.y * vector.y) match {case n ⇒ new Angle(vector.y / n, vector.x / n)}\n  }\n  class Angle private (val sin: Double, val cos: Double) {\n    def +(that: Angle): Angle = new Angle(sin * that.cos + cos * that.sin, cos * that.cos - sin * that.sin)\n    def -(that: Angle): Angle = new Angle(sin * that.cos - cos * that.sin, cos * that.cos + sin * that.sin)\n  }\n}\n"
  },
  {
    "language": "C++",
    "code": "#include <iostream>\n#include <cstdlib>\n#include <cmath>\n#include <vector>\n#include <utility>\n#include <algorithm>\nusing namespace std;\n\n#define x first\n#define y second\ntypedef pair<double,double> pdd;\ntypedef pair<int,int> pii;\n\nconst double EPS = 1e-9;\n\nint H, R;\nvector<pdd> h, w;\nint U, M, S;\ndouble du, dm, ds;\nvector<pdd> u, m, s;\n\nbool in(pdd house, pdd tree, pdd wind, double d) {\n\tpdd v;\n\tdouble dist;\n\tv = make_pair(house.x - tree.x, house.y - tree.y);\n\tdist = sqrt(v.x*v.x + v.y*v.y);\n\tif(dist > wind.y)\n\t\treturn false;\n\n\tdouble theta;\n\ttheta = atan2(v.y, v.x);\n\tdouble tmp = theta - M_PI*wind.x/180.0 + 4*M_PI;\n\twhile(tmp - 2*M_PI >= -M_PI) tmp -= 2*M_PI;\n\t\n\tif(abs(tmp) > d*M_PI/180.0/2.0 + EPS)\n\t\treturn false;\n\n\treturn true;\n}\n\nvoid solve() {\n\tvector<pii> cnt;\n\tcnt.resize(H);\n\tfor(int i = 0; i < cnt.size(); i++)\n\t\tcnt[i] = make_pair(0,-(i+1));\n\n\tfor(int i = 0; i < h.size(); i++) {\n\t\tfor(int j = 0; j < w.size(); j++) {\n\t\t\tbool fu, fm, fs;\n\t\t\tfu = fm = fs = false;\n\t\t\tfor(int k = 0; k < u.size(); k++)\n\t\t\t\tfu |= in(h[i], u[k], w[j], du);\n\n\t\t\tfor(int k = 0; k < m.size(); k++)\n\t\t\t\tfm |= in(h[i], m[k], w[j], dm);\n\n\t\t\tfor(int k = 0; k < s.size(); k++)\n\t\t\t\tfs |= in(h[i], s[k], w[j], ds);\n\n\t\t\tif(!fu && !fm && !fs && in(h[i], make_pair(0.0, 0.0), w[j], du))\n\t\t\t\tcnt[i].x++;\n\t\t}\n\t}\n\tsort(cnt.rbegin(), cnt.rend());\n\n\tif(cnt[0].x == 0) {\n\t\tcout << \"NA\" << endl;\n\t\treturn;\n\t}\n\tcout << -cnt[0].y;\n\tfor(int i = 1; i < cnt.size() && cnt[i-1].x == cnt[i].x; i++)\n\t\tcout << \" \" << -cnt[i].y;\n\tcout << endl;\n}\n\nint main() {\n\twhile(cin >> H >> R, H || R) {\n\t\th.clear(); w.clear();\n\t\tu.clear(); m.clear(); s.clear();\n\n\t\th.resize(H);\n\t\tfor(int i = 0; i < H; i++)\n\t\t\tcin >> h[i].x >> h[i].y;\n\t\tcin >> U >> M >> S >> du >> dm >> ds;\n\t\tu.resize(U);\n\t\tfor(int i = 0; i < U; i++)\n\t\t\tcin >> u[i].x >> u[i].y;\n\n\t\tm.resize(M);\n\t\tfor(int i = 0; i < M; i++)\n\t\t\tcin >> m[i].x >> m[i].y;\n\t\ts.resize(S);\n\t\tfor(int i = 0; i < S; i++)\n\t\t\tcin >> s[i].x >> s[i].y;\n\t\tw.resize(R);\n\t\tfor(int i = 0; i < R; i++)\n\t\t\tcin >> w[i].x >> w[i].y;\n\n\t\tsolve();\n\t}\n}"
  },
  {
    "language": "C++",
    "code": "#include <iostream>\n#include <cstdio>\n#include <iomanip>\n#include <vector>\n#include <map>\n#include <set>\n#include <queue>\n#include <bitset>\n#include <stack>\n#include <utility>\n#include <numeric>\n#include <algorithm>\n#include <functional>\n#include <cctype>\n#include <complex>\n#include <string>\n#include <sstream>\n#include <fstream>\n#include <cassert>\nusing namespace std;\n\n//common\ntypedef long long i64,ll;\n\n#define BR \"\\n\"\n#define ALL(c) (c).begin(),(c).end()\n#define REP(i,n) for(int i=0;i<(int)(n);++i)\n#define FOR(i,l,r) for(int i=(l);i<(int)(r);++i)\n#define EACH(it,o) for(auto it = (o).begin(); it != (o).end(); ++it)\n#define IN(l,v,r) ((l)<=(v) && (v)<(r))\n\n//debug\n#ifdef NDEBUG\n#define DUMP(x)\n#define DUMPLN(x)\n#define DEBUG(x)\n#define DEBUGLN(x)\n#define LINE()\n#define LINELN()\n#define CHECK(exp,act)\n#define STOP(e)\n#else\n#define DUMP(x)  cerr << #x << \" = \" << (x)\n#define DUMPLN(x)  DUMP(x) <<endl\n#define DEBUG(x) DUMP(x) << LINE() << \" \" << __FILE__\n#define DEBUGLN(x) DEBUG(x)<<endl\n#define LINE()    cerr<< \" (L\" << __LINE__ << \")\"\n#define LINELN()    LINE()<<endl\n#define CHECK(exp,act)  if(exp!=act){DUMPLN(exp);DEBUGLN(act);}\n#define STOP(e)  CHECK(e,true);if(!(e)) exit(1);\n#endif\n\ntemplate<class T> inline string toString(const vector<T>& x) {\n\tstringstream ss;\n\tREP(i,x.size()){\n\t\tif(i!=0)ss<<\" \";\n\t\tss<< x[i];\n\t}\n\treturn ss.str();\n}\n\ntemplate<class T> inline string toString(const vector<vector<T> >& map) {\n\tstringstream ss;\n\tREP(i,map.size()){\n\t\tif(i!=0)ss<<BR;\n\t\tss<< toString(map[i]);\n\t}\n\treturn ss.str();\n}\ntemplate<class K,class V>  string toString(map<K,V>& x) {\n\tstring res;stringstream ss;\n\tfor(auto& p:x)ss<< p.first<<\":\" << p.second<<\" \";\n\treturn ss.str();\n}\n\nstring BITtoString(int bit){\n    stringstream ss;\n    while(bit!=0){ss<<(bit%2);bit/=2;}\n    string res=ss.str();reverse(ALL(res));\n    return res;\n}\n\ntemplate<typename T,typename V> inline T pmod(T v,V MOD){\n\treturn (v%MOD+MOD)%MOD;\n}\ndouble pfmod(double v,double MOD){\n\treturn fmod(fmod(v,MOD)+MOD,MOD);\n}\n\nclass Comp{\npublic:\n\tbool operator () (const pair<int,int>& l,const pair<int,int>& r){\n\t\tif(l.first!=r.first)return l.first>r.first;\n\t\treturn l.second<r.second;\n\t}\n};\n\nnamespace Ps{\n\tconst double EPS = 1e-8;\n\tconst double INF = 1e12;\n\n\ttypedef complex<double> P;\n\t#define X(a) (real(a))\n\t#define Y(a) (imag(a))\n\t\n\t// a×b\n\tdouble cross(const P& a,const P& b){\n\t\treturn imag(conj(a)*b);\n\t}\n\t// a・b\n\tdouble dot(const P&a,const P& b) {\n\t\treturn real(conj(a)*b);\n\t}\n\n\t int ccw(const P& a,P b,P c){\n\t\tb -= a; c -= a;\n\t\t  if (cross(b,c) > 0)   return +1;       // counter clockwise\n\t\t  if (cross(b,c) < 0)   return -1;       // clockwise\n\t\t  if (dot(b,c) < 0)     return +2;       // c--a--b on line\n\t\t  if (norm(b) < norm(c)) return -2;       // a--b--c on line\n\t\t  return 0;\n\t  }\n}\nusing namespace Ps;\n\ndouble Abs(double a){double ret=pfmod(max(a,-a),2*M_PI);return min(ret,2*M_PI-ret);}\n\nclass Main{\npublic:\n\tbool canReach(int x,int y,int w,int a,int d){\n\t\tif((ll)x*x+(ll)y*y<=(ll)a*a){\n\t\t\tif(Abs(w*M_PI/180-atan2(y,x))<=d*M_PI/180/2)return true;\n\t\t}\n\t\treturn false;\n\t}\n\n\tvoid run(){\n\n\t\twhile(true){\n\t\t\tint H,R;scanf(\"%d%d\",&H,&R);if(H==0)break;\n\n\t\t\tvector<int> xs(H),ys(H);\n\t\t\tREP(h,H)scanf(\"%d%d\",&xs[h],&ys[h]);\n\t\t\tint U,M,S,du,dm,ds;scanf(\"%d%d%d%d%d%d\",&U,&M,&S,&du,&dm,&ds);\n\n\t\t\tvector<int> uxs(U),uys(U);vector<int> mxs(M),mys(M);vector<int> sxs(S),sys(S);\n\t\t\tREP(i,U)scanf(\"%d%d\",&uxs[i],&uys[i]);\n\t\t\tREP(i,M)scanf(\"%d%d\",&mxs[i],&mys[i]);\n\t\t\tREP(i,S)scanf(\"%d%d\",&sxs[i],&sys[i]);\n\t\t\t\n\t\t\tvector<int> ws(R),as(R);\n\t\t\tREP(i,R)scanf(\"%d%d\",&ws[i],&as[i]);\n\n\n\t\t\tvector<pair<int,int>> res;\n\t\t\tREP(h,H){\n\t\t\t\tint x=xs[h],y=ys[h];\n\n\t\t\t\tint okc=0;\n\t\t\t\tREP(r,R){\n\t\t\t\t\tint w=ws[r],a=as[r];\n\t\t\t\t\tbool ok=false;\n\t\t\t\t\tif(canReach(x,y,w,a,du))ok=true;\n\t\t\t\t\tREP(i,U)if(canReach(x-uxs[i],y-uys[i],w,a,du))ok=false;\n\t\t\t\t\tREP(i,M)if(canReach(x-mxs[i],y-mys[i],w,a,dm))ok=false;\n\t\t\t\t\tREP(i,S)if(canReach(x-sxs[i],y-sys[i],w,a,ds))ok=false;\n\t\t\t\t\tif(ok)okc++;\n\t\t\t\t}\n\t\t\t\tres.push_back(make_pair(okc,h+1));\n\t\t\t}\n\t\t\tsort(ALL(res),Comp());\n\n\t\t\tint Mh=res[0].first;\n\t\t\t\n\t\t\tif(Mh==0){\n\t\t\t\tcout<<\"NA\"<<endl;continue;\n\t\t\t}\n\n\t\t\tfor(int i=0;i<H && Mh==res[i].first;i++){\n\t\t\t\tif(i!=0)cout <<\" \";\n\t\t\t\tcout << res[i].second; \n\t\t\t}\n\t\t\tcout <<endl;\n\t\t}\n\t}\n};\n\n int main(){\n\t//ios::sync_with_stdio(false);\n \tMain().run();\n \treturn 0;\n }"
  },
  {
    "language": "C++",
    "code": "#include<iostream>\n#include<vector>\n#include<math.h>\n#include<complex>\n\n#define EPS 1e-3\n\n#define PI 3.141592\n#define EQ(a,b) (abs((a)-(b))<EPS)\nusing namespace std;\n\ntypedef complex<double> P;\n\nvector<P> house;\nvector<P> ume,sak,mo;\n\ndouble cross(P v1,P v2){\n\treturn v1.real()*v2.imag()-v1.imag()*v2.real();\n}\n\nbool che(P h,P t,double d,double w,double a){\n\tP v=h-t;\n\tif(!(abs(v)<=a+EPS))return false;\n\t\n\tP v1=P(a*cos((w+d/2)/180*PI),a*sin((w+d/2)/180*PI));\n\tP v2=P(a*cos((w-d/2)/180*PI),a*sin((w-d/2)/180*PI));\n\t\n\tif(cross(v1,v)<=EPS && cross(v2,v)>=-EPS)return true;\n\telse return false;\n}\n\nint main(){\n\tint h,r;\n\t\n\twhile(cin>>h>>r && h&&r){\n\t\thouse.clear();\n\t\tume.push_back(P(0,0));\n\t\tfor(int i=0;i<h;i++){\n\t\t\tint x,y;\n\t\t\tcin>>x>>y;\n\t\t\thouse.push_back(P(x,y));\n\t\t}\n\t\t\n\t\tint U,M,S,du,dm,ds;\n\t\tcin>>U>>M>>S>>du>>dm>>ds;\n\t\tfor(int i=0;i<U;i++){\n\t\t\tint x,y;\n\t\t\tcin>>x>>y;\n\t\t\tume.push_back(P(x,y));\n\t\t}\n\t\tfor(int i=0;i<M;i++){\n\t\t\tint x,y;\n\t\t\tcin>>x>>y;\n\t\t\tmo.push_back(P(x,y));\n\t\t}\n\t\tfor(int i=0;i<S;i++){\n\t\t\tint x,y;\n\t\t\tcin>>x>>y;\n\t\t\tsak.push_back(P(x,y));\n\t\t}\n\t\t\n\t\t\n\t\tint data[120];\n\t\tfor(int i=0;i<120;i++)data[i]=0;\n\t\tfor(int z=0;z<r;z++){\n\t\t\tint w,a;\n\t\t\tcin>>w>>a;\n\t\t\t\n\t\t\tfor(int i=0;i<house.size();i++){\n\t\t\t\tbool ok=false;\n\t\t\t\tif(che(house[i],ume[0],du,w,a))ok=true;\n\t\t\t\telse continue;\n\t\t\t\tfor(int j=1;j<U;j++){\n\t\t\t\t\tif(che(house[i],ume[j],du,w,a))ok=false;\n\t\t\t\t}\n\t\t\t\tfor(int j=0;j<M;j++){\n\t\t\t\t\tif(che(house[i],mo[j],dm,w,a))ok=false;\n\t\t\t\t}\n\t\t\t\tfor(int j=0;j<S;j++){\n\t\t\t\t\tif(che(house[i],sak[j],ds,w,a))ok=false;\n\t\t\t\t}\n\t\t\t\t\n\t\t\t\tif(ok)data[i]++;\n\t\t\t}\n\t\t}\n\t\t\n\t\t\tint ans=0;\n\t\t\tint tmp=-1;\n\t\t\tfor(int i=0;i<h;i++){\n\t\t\t\tif(ans<=data[i]){\n\t\t\t\t\tans=data[i];\n\t\t\t\t\ttmp=i;\n\t\t\t\t}\n\t\t\t}\n\t\t\tif (ans==0)cout<<\"NA\"<<endl;\n\t\t\telse {\n\t\t\t\tfor(int i=0;i<h;i++){\n\t\t\t\t\tif(i==tmp)cout<<i+1;\n\t\t\t\t\telse if(data[i]==ans)cout<<i+1<<\" \";\n\t\t\t\t\t\n\t\t\t\t}\n\t\t\t\tcout<<endl;\n\t\t\t}\n\t\t\t\n\t\t\n\t}\n}"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\nusing namespace std;\n\n#define EPS (1e-8)\n#define equals(a, b) (fabs((a) - (b)) < EPS )\n#define dle(a, b) (equals(a, b) || a < b )\n#define LIM 0.001\n\nstatic const double PI = acos(-1);\n\nclass Point{\n    public:\n    double x, y;\n\n    Point ( double x = 0, double y = 0): x(x), y(y){}\n\n    Point operator + ( Point p ){ return Point(x + p.x, y + p.y); }\n    Point operator - ( Point p ){ return Point(x - p.x, y - p.y); }\n    Point operator * ( double a ){ return Point(x*a, y*a); }\n    Point operator / ( double a ){ return Point(x/a, y/a); }\n\n    double abs() { return sqrt(norm());}\n    double norm() { return x*x + y*y; }\n\n    bool operator < ( const Point &p ) const {\n    return x != p.x ? x < p.x : y < p.y;\n    }\n\n    bool operator == ( const Point &p ) const {\n    return fabs(x-p.x) < EPS && fabs(y-p.y) < EPS;\n    }\n};\n\ntypedef Point Vector;\n\nclass Segment{\n    public:\n    Point p1, p2;\n    Segment(Point s = Point(), Point t = Point()): p1(s), p2(t){}\n};\n\ntypedef Segment Line;\n\ndouble norm( Vector a ){ return a.x*a.x + a.y*a.y; }\ndouble abs( Vector a ){ return sqrt(norm(a)); }\nPoint polar( double a, double r ){ return Point(cos(r)*a, sin(r)*a);}\ndouble getDistance( Vector a, Vector b ){ return abs(a - b); }\ndouble dot( Vector a, Vector b ){ return a.x*b.x + a.y*b.y; }\ndouble cross( Vector a, Vector b ){ return a.x*b.y - a.y*b.x; }\n\nstatic const int COUNTER_CLOCKWISE = 1;\nstatic const int CLOCKWISE = -1;\nstatic const int ONLINE_BACK = 2;\nstatic const int ONLINE_FRONT = -2;\nstatic const int ON_SEGMENT = 0;\n\n// EPS can be 0\n// need to check for 920, 833, 866\nint ccw( Point p0, Point p1, Point p2 ){\n    Vector a = p1 - p0;\n    Vector b = p2 - p0;\n    if ( cross(a, b) > EPS ) return COUNTER_CLOCKWISE;\n    if ( cross(a, b) < -EPS ) return CLOCKWISE;\n    if ( dot(a, b) < -EPS ) return ONLINE_BACK;\n    if ( norm(a) < norm(b) ) return ONLINE_FRONT;\n    return ON_SEGMENT;\n}\n\ndouble getDistance(Segment s, Point p){\n    if ( dot(s.p2 - s.p1, p - s.p1) < 0.0 ) return abs(p - s.p1);\n    if ( dot(s.p1 - s.p2, p - s.p2) < 0.0 ) return abs(p - s.p2);\n    return abs(cross(s.p2 - s.p1, p - s.p1)/abs(s.p2 - s.p1));\n}\n\n\ndouble arg(Vector p){\n    return atan2(p.y, p.x);\n}\n\nbool isInSector(Point c, double a, double d, double r, Point p ){\n  double dist = abs(c - p);\n  if ( dist <= 0.001 ){\n    cout << p.x << \", \" << p.y << endl;\n  }\n\n  if ( dist > a ) return false;\n  Vector v1 = Vector(a*cos((r + d/2)*PI/180), a*sin((r + d/2)*PI/180));\n  Vector v2 = Vector(a*cos((r - d/2)*PI/180), a*sin((r - d/2)*PI/180));\n\n  double ldist1 = getDistance(Segment(c, c+v1), p);\n  double ldist2 = getDistance(Segment(c, c+v2), p);\n\n  if ( ccw(c, c+v1, p) == CLOCKWISE &&\n       ccw(c, c+v2, p) == COUNTER_CLOCKWISE ) return true;\n  return false;\n}\n\nint main(){\n  int h, r, C[3];\n  double D[3], x, y, w, a;\n  Point O[3][100];\n  Point H[100];\n  int P[100];\n\n  while(1){\n    cin >> h >> r;\n    if ( h == 0 && r == 0 ) break;\n\n    for ( int i = 0; i < h; i++ ) P[i] = 0;\n    for ( int i = 0; i < h; i++ ) cin >> H[i].x >> H[i].y;\n    cin >> C[0] >> C[1] >> C[2] >> D[0] >> D[1] >> D[2];\n\n    for ( int i = 0; i < 3; i++ ){\n      for ( int j = 0; j < C[i]; j++ ){\n    cin >> O[i][j].x >> O[i][j].y ;\n      }\n    }\n\n    for ( int i = 0; i < r; i++ ){\n      cin >> w >> a;\n      for ( int b = 0; b < h; b++ ){\n    Point target = H[b];\n    bool coveredByOther = false;\n    bool coveredByMe = isInSector(Point(0, 0), a, D[0], w, target);\n    for ( int k = 0; k < 3; k++ ){\n      for ( int l = 0; l < C[k]; l++ ){\n        if ( isInSector(O[k][l], a, D[k], w, target)) coveredByOther = true;\n      }\n    }\n    if (!coveredByOther && coveredByMe ) P[b]++;\n      }\n    }\n    int maxv = 0;\n    for ( int i = 0; i < h; i++ ) {\n      maxv = max(maxv, P[i]);\n    }\n    if ( maxv == 0 ) cout << \"NA\" << endl;\n    else {\n      bool f = true;\n      for ( int i = 0; i < h; i++ ){\n    if ( maxv == P[i] ) {\n      if ( !f) cout << \" \";\n      cout << i+1;\n      f = false;\n    }\n      }\n      cout << endl;\n    }\n\n\n  }\n}"
  },
  {
    "language": "C++",
    "code": "#include<iostream>\n#include<complex>\n#include<vector>\n#include<algorithm>\n#include<cmath>\n\n#define pb push_back\n#define sz size()\n#define rep(i,a) for(int i=0;i<(int)(a);i++)\n\nusing namespace std;\ntypedef long double D;\ntypedef complex<D> P;\nconst D EPS = 1e-10;\nconst D PI = acos(-1);\n\nD dot(P x,P y){return real(conj(x)*y);}\nD cross(P x,P y){return imag(conj(x)*y);}\nD arg(P a,P b,P c){\n  D res = acos(dot(b-a,c-a)/(abs(b-a)*abs(c-a))); \n  return (cross(b-a,c-a)<EPS)?2*PI-res:res;\n}\n\nint h,r,n[3];\nD d[3],tmp1,tmp2,seta;\nP hp[110],up[3][110];\nD w[110],a[110];\n\nint main(){\n  while(cin >> h >> r,h){\n    rep(i,h){\n      cin >> tmp1 >> tmp2;\n      hp[i] = P(tmp1,tmp2);\n    }\n\n    rep(i,3)cin >> n[i]; rep(i,3)cin >> d[i], d[i] *= PI/180/2;\n\n    rep(i,3)rep(j,n[i]){\n      cin >> tmp1 >> tmp2;\n      up[i][j] = P(tmp1,tmp2);\n    }\n\n    rep(i,r)cin >> w[i] >> a[i], w[i] *= PI/180;\n\n    int num[110] = {};\n    rep(x,r){\n      rep(id,h){\n\tint in = 0;\n\trep(i,3)rep(j,n[i]){\n\t  if(abs(hp[id]-up[i][j]) < a[x] +EPS){\n\t    P tmp = P(up[i][j].real() + 100, up[i][j].imag());\n\t    seta = arg(up[i][j],tmp,hp[id]);\n\t    if(w[x]-d[i] < seta+EPS && seta < w[x]+d[i]+EPS){\n\t      in++;\n\t    }\n\t  }\n\t}\n\tif(in)continue;\n\n        seta = arg(P(0,0),P(100,0),hp[id]);\n\tif(abs(hp[id]) < a[x] + EPS && w[x]-d[0] < seta+EPS && seta < w[x]+d[0]+EPS){\n\t  num[id]++;\n\t}\n      }\n    }\n\n    int maxv = *max_element(num,num+h);\n    vector<int> ans;\n    if(maxv==0)cout << \"NA\\n\";\n    else{\n      rep(i,h){\n\tif(num[i] == maxv)ans.pb(i+1);\n      }\n      rep(i,ans.sz)cout << ans[i] << (i+1==ans.size()?\"\\n\":\" \");\n    }\n  }\n}"
  },
  {
    "language": "C++",
    "code": "#include<iostream>\n#include<vector>\n#include<cmath>\n#include<algorithm>\n#include<numeric>\nusing namespace std;\n \nconst double PI = 3.14159265358979;\nconst double EPS = 1e-9;\n \nclass Point {\npublic:\n    double x, y;\n    Point(double x = 0.0, double y = 0.0) :x(x), y(y) {}\n};\n \nclass Wind {\npublic:\n    double w, a;\n};\n \nbool include(double angle, double low, double high) {\n    if(low < 0 + EPS) {\n        double l = low + 2.0 * PI;\n        if(l <= angle + EPS) return true;\n    }\n    if(high > 2.0 * PI + EPS) {\n        double h = high - 2.0 * PI;\n        if(angle <= h + EPS) return true;\n    }\n    return low <= angle + EPS && angle <= high + EPS;\n}\n \nbool savor(const Point &home, const Wind &wind, const vector<Point> &blossom, double d) {\n    d /= 2.0;\n    for(const auto &b: blossom) {\n        Point dif(home.x - b.x, home.y - b.y);\n        double angle = atan2(dif.y, dif.x);\n        double dist = hypot(dif.y, dif.x);\n        if(angle < 0) angle = angle + 2 * PI;\n        if(dist <= wind.a + EPS && include(angle, wind.w - d, wind.w + d)) return true;\n    }\n    return false;\n}\n \ndouble toRadian(double d) {\n    return d * PI / 180.0;\n}\n \nint main() {\n    int H, R;\n    while(cin >> H >> R, H | R) {\n        vector<Point> home(H);\n        for(auto &i: home) cin >> i.x >> i.y;\n \n        int U, M, S;\n        double du, dm, ds;\n        cin >> U >> M >> S >> du >> dm >> ds;\n \n        du = toRadian(du);\n        dm = toRadian(dm);\n        ds = toRadian(ds);\n \n        vector<Point> plum(U), peach(M), cherry(S);\n        for(auto &i: plum) cin >> i.x >> i.y;\n        for(auto &i: peach) cin >> i.x >> i.y;\n        for(auto &i: cherry) cin >> i.x >> i.y;\n \n        vector<Wind> wind(R);\n        for(auto &i: wind) cin >> i.w >> i.a;\n        for(auto &i: wind) i.w = toRadian(i.w);\n \n        // solve\n        vector<int> number(H, 0);\n        int maxNumber = 0;\n \n        for(int i = 0; i < H; ++i) {\n            for(int day = 0; day < R; ++day) {\n                bool ok = savor(home[i], wind[day], {Point(0.0, 0.0)}, du);\n                bool ng = false;\n                ng |= savor(home[i], wind[day], plum, du);\n                ng |= savor(home[i], wind[day], peach, dm);\n                ng |= savor(home[i], wind[day], cherry, ds);\n \n                if(!ok || ng) continue;\n \n                ++number[i];\n                maxNumber = max(maxNumber, number[i]);\n            }\n        }\n \n        if(maxNumber) {\n            bool first = true;\n            for(int i = 0; i < H; ++i) if(number[i] == maxNumber) {\n                if(!first) cout << \" \";\n                first = false;\n                cout << i + 1;\n            }\n            cout << endl;\n        } else {\n            cout << \"NA\" << endl;\n        }\n    }\n}"
  },
  {
    "language": "C++",
    "code": "#include<iostream>\n#include<vector>\n#include<math.h>\n#include<complex>\n\n#define EPS 1e-4\n\n#define PI 3.141592\n#define EQ(a,b) (abs((a)-(b))<EPS)\nusing namespace std;\n\ntypedef complex<double> P;\n\nvector<P> house;\nvector<P> ume,sak,mo;\n\ndouble cross(P v1,P v2){\n\treturn v1.real()*v2.imag()-v1.imag()*v2.real();\n}\n\nbool che(P h,P t,double d,double w,double a){\n\tP v=h-t;\n\tif(!(abs(v)<a))return false;\n\t\n\tP v1=P(a*cos((w+d/2)/180*PI),a*sin((w+d/2)/180*PI));\n\tP v2=P(a*cos((w-d/2)/180*PI),a*sin((w-d/2)/180*PI));\n\t\n\tif(cross(v1,v)<0 && cross(v2,v)>0)return true;\n\telse return false;\n}\n\nint main(){\n\tint h,r;\n\t\n\twhile(cin>>h>>r && h&&r){\n\t\thouse.clear();\n\t\tume.push_back(P(0,0));\n\t\tfor(int i=0;i<h;i++){\n\t\t\tint x,y;\n\t\t\tcin>>x>>y;\n\t\t\thouse.push_back(P(x,y));\n\t\t}\n\t\t\n\t\tint U,M,S,du,dm,ds;\n\t\tcin>>U>>M>>S>>du>>dm>>ds;\n\t\tfor(int i=0;i<U;i++){\n\t\t\tint x,y;\n\t\t\tcin>>x>>y;\n\t\t\tume.push_back(P(x,y));\n\t\t}\n\t\tfor(int i=0;i<M;i++){\n\t\t\tint x,y;\n\t\t\tcin>>x>>y;\n\t\t\tmo.push_back(P(x,y));\n\t\t}\n\t\tfor(int i=0;i<S;i++){\n\t\t\tint x,y;\n\t\t\tcin>>x>>y;\n\t\t\tsak.push_back(P(x,y));\n\t\t}\n\t\t\n\t\t\n\t\tint data[120];\n\t\tfor(int i=0;i<120;i++)data[i]=0;\n\t\tfor(int z=0;z<r;z++){\n\t\t\tint w,a;\n\t\t\tcin>>w>>a;\n\t\t\t\n\t\t\tfor(int i=0;i<house.size();i++){\n\t\t\t\tbool ok=false;\n\t\t\t\tif(che(house[i],ume[0],du,w,a))ok=true;\n\t\t\t\telse continue;\n\t\t\t\tfor(int j=1;j<U;j++){\n\t\t\t\t\tif(che(house[i],ume[j],du,w,a))ok=false;\n\t\t\t\t}\n\t\t\t\tfor(int j=0;j<M;j++){\n\t\t\t\t\tif(che(house[i],mo[j],dm,w,a))ok=false;\n\t\t\t\t}\n\t\t\t\tfor(int j=0;j<S;j++){\n\t\t\t\t\tif(che(house[i],sak[j],ds,w,a))ok=false;\n\t\t\t\t}\n\t\t\t\t\n\t\t\t\tif(ok)data[i]++;\n\t\t\t}\n\t\t}\n\t\t\n\t\t\tint ans=0;\n\t\t\tint tmp=-1;\n\t\t\tfor(int i=0;i<h;i++){\n\t\t\t\tif(ans<=data[i]){\n\t\t\t\t\tans=data[i];\n\t\t\t\t\ttmp=i;\n\t\t\t\t}\n\t\t\t}\n\t\t\tif (ans==0)cout<<\"NA\"<<endl;\n\t\t\telse {\n\t\t\t\tfor(int i=0;i<h;i++){\n\t\t\t\t\tif(i==tmp)cout<<i+1;\n\t\t\t\t\telse if(data[i]==ans)cout<<i+1<<\" \";\n\t\t\t\t\t\n\t\t\t\t}\n\t\t\t\tcout<<endl;\n\t\t\t}\n\t\t\t\n\t\t\n\t}\n}"
  },
  {
    "language": "C++",
    "code": "#include <iostream>\n#include <complex>\n#include <cmath>\n#include <vector>\n\nusing namespace std;\n\ntypedef complex<double> P;\n\nconst double EPS = 1e-4;\nconst double DBG = 1e-2;\n\nint h, r, u, m, s;\ndouble du, dm, ds;\nvector<P> ume, momo, sakura, ie;\nint cnt[100];\n\nvoid init(){\n  ume.clear();\n  momo.clear();\n  sakura.clear();\n  ie.clear();\n  fill(cnt, cnt+100, 0);\n}\n\nbool check2(P kaze, P e, P ki, double dir){\n  double dist = abs(e - ki);\n  if(dist > kaze.imag() + EPS) return false;\n  double tmp = arg(e - ki) * 180 / M_PI;\n  double a = kaze.real() + dir / 2.0;\n  double b = kaze.real() - dir / 2.0;\n  return !(tmp < b + EPS || a - EPS < tmp);\n}\n\nbool check(P kaze, P e){\n  if(!check2(kaze, e, P(0, 0), du)) return false;\n  for(int i=0;i<u;i++) if(check2(kaze, e, ume[i], du)) return false;\n  for(int i=0;i<m;i++) if(check2(kaze, e, momo[i], dm)) return false;\n  for(int i=0;i<s;i++) if(check2(kaze, e, sakura[i], ds)) return false;\n  return true;\n}\n\nmain(){\n  while(cin >> h >> r && (h|r)){\n    init();\n    P in;\n    for(int i=0;i<h;i++){\n      cin >> in.real() >> in.imag();\n      ie.push_back(in);\n    }\n    cin >> u >> m >> s >> du >> dm >> ds;\n    for(int i=0;i<u;i++){\n      cin >> in.real() >> in.imag();\n      ume.push_back(in);\n    }\n    for(int i=0;i<m;i++){\n      cin >> in.real() >> in.imag();\n      momo.push_back(in);\n    }\n    for(int i=0;i<s;i++){\n      cin >> in.real() >> in.imag();\n      sakura.push_back(in);\n    }\n    for(int i=0;i<r;i++){\n      cin >> in.real() >> in.imag();\n      for(int j=0;j<h;j++){\n        if(check(in, ie[j])) cnt[j]++;\n      }\n    }\n    int ans = 0;\n    for(int i=0;i<h;i++) ans = max(ans, cnt[i]);\n    if(!ans) cout << \"NA\" << endl;\n    else{\n      bool f = true;\n      for(int i=0;i<h;i++){\n        if(ans == cnt[i]){\n          if(f) f = false;\n          else cout << \" \";\n          cout << i+1;\n        }\n      }\n      cout << endl;\n    }\n  }\n}"
  },
  {
    "language": "C++",
    "code": "#include<iostream>\n#include<cfloat>\n#include<cassert>\n#include<cmath>\n#include<vector>\n\nusing namespace std;\n\n#define EPS (1e-8)\n#define equals(a, b) (fabs((a) - (b)) < EPS )\n#define dle(a, b) (equals(a, b) || a < b )\n#define LIM 0.001\n\nstatic const double PI = acos(-1);\n\nclass Point{\n    public:\n    double x, y;\n    \n    Point ( double x = 0, double y = 0): x(x), y(y){}\n    \n    Point operator + ( Point p ){ return Point(x + p.x, y + p.y); }\n    Point operator - ( Point p ){ return Point(x - p.x, y - p.y); }\n    Point operator * ( double a ){ return Point(x*a, y*a); }\n    Point operator / ( double a ){ return Point(x/a, y/a); }\n\n    double abs() { return sqrt(norm());}\n    double norm() { return x*x + y*y; }\n\n    bool operator < ( const Point &p ) const {\n\treturn x != p.x ? x < p.x : y < p.y;\n    }\n\n    bool operator == ( const Point &p ) const {\n\treturn fabs(x-p.x) < EPS && fabs(y-p.y) < EPS;\n    }\n};\n\ntypedef Point Vector;\n\nclass Segment{\n    public:\n    Point p1, p2;\n    Segment(Point s = Point(), Point t = Point()): p1(s), p2(t){}\n};\n\ntypedef Segment Line;\n\ndouble norm( Vector a ){ return a.x*a.x + a.y*a.y; }\ndouble abs( Vector a ){ return sqrt(norm(a)); }\nPoint polar( double a, double r ){ return Point(cos(r)*a, sin(r)*a);}\ndouble getDistance( Vector a, Vector b ){ return abs(a - b); }\ndouble dot( Vector a, Vector b ){ return a.x*b.x + a.y*b.y; }\ndouble cross( Vector a, Vector b ){ return a.x*b.y - a.y*b.x; }\n\nbool isOnSegment( Point a, Point b, Point c){\n    if ( a == c || b == c ) return true;\n    return (abs(a-c) + abs(c-b) < abs(a-b) + EPS );\n}\n\nbool isOrthogonal( Vector a, Vector b ){\n     return equals( dot(a, b), 0.0 );\n}\n\nbool isOrthogonal( Point a1, Point a2, Point b1, Point b2 ){\n    return isOrthogonal( a1 - a2, b1 - b2 );\n}\n\nbool isOrthogonal( Segment s1, Segment s2 ){\n    return equals( dot(s1.p2 - s1.p1, s2.p2 - s2.p1), 0.0 );\n}\n\nbool isParallel( Vector a, Vector b ){\n    return equals( cross(a, b), 0.0 );\n}\n\nbool isParallel( Point a1, Point a2, Point b1, Point b2){\n    return isParallel( a1 - a2, b1 - b2 );\n}\n\nbool isParallel( Segment s1, Segment s2 ){\n    return equals( cross(s1.p2 - s1.p1, s2.p2 - s2.p1), 0.0 );\n}\n\nstatic const int COUNTER_CLOCKWISE = 1;\nstatic const int CLOCKWISE = -1;\nstatic const int ONLINE_BACK = 2;\nstatic const int ONLINE_FRONT = -2;\nstatic const int ON_SEGMENT = 0;\n\n// EPS can be 0\n// need to check for 920, 833, 866\nint ccw( Point p0, Point p1, Point p2 ){\n    Vector a = p1 - p0;\n    Vector b = p2 - p0;\n    if ( cross(a, b) > EPS ) return COUNTER_CLOCKWISE;\n    if ( cross(a, b) < -EPS ) return CLOCKWISE;\n    if ( dot(a, b) < -EPS ) return ONLINE_BACK;\n    if ( norm(a) < norm(b) ) return ONLINE_FRONT;\n    return ON_SEGMENT;\n}\n\n// intersect Segment p1-p2 and Segment p3-p4 ?\nbool isIntersect(Point p1, Point p2, Point p3, Point p4){\n    return ( ccw(p1, p2, p3) * ccw(p1, p2, p4) <= 0 &&\n\t     ccw(p3, p4, p1) * ccw(p3, p4, p2) <= 0 );\n}\n\nbool isIntersect(Segment s1, Segment s2){\n    return isIntersect(s1.p1, s1.p2, s2.p1, s2.p2);\n}\n\ndouble getDistance(Segment s, Point p){\n    if ( dot(s.p2 - s.p1, p - s.p1) < 0.0 ) return abs(p - s.p1);\n    if ( dot(s.p1 - s.p2, p - s.p2) < 0.0 ) return abs(p - s.p2);\n    return abs(cross(s.p2 - s.p1, p - s.p1)/abs(s.p2 - s.p1));\n}\ndouble getDistance(Segment s1, Segment s2){\n    if ( isIntersect(s1, s2) ) return 0.0;\n    return min( min(getDistance(s1, s2.p1), getDistance(s1, s2.p2)),\n\t\tmin(getDistance(s2, s1.p1), getDistance(s2, s1.p2)));\n}\n\ndouble arg(Vector p){\n    return atan2(p.y, p.x);\n}\n\nbool isInSector(Point c, double a, double d, double r, Point p ){\n  double dist = abs(c - p);\n  if ( dist <= 0.001 ){\n    cout << p.x << \", \" << p.y << endl;\n    assert(false);\n  }\n\n  if ( dist > a ) return false;\n  Vector v1 = Vector(a*cos((r + d/2)*PI/180), a*sin((r + d/2)*PI/180));\n  Vector v2 = Vector(a*cos((r - d/2)*PI/180), a*sin((r - d/2)*PI/180));\n\n  double ldist1 = getDistance(Segment(c, c+v1), p);\n  double ldist2 = getDistance(Segment(c, c+v2), p);\n  assert( ldist1 > LIM );\n  assert( ldist2 > LIM );\n\n\n  if ( ccw(c, c+v1, p) == CLOCKWISE &&\n       ccw(c, c+v2, p) == COUNTER_CLOCKWISE ) return true;\n  return false;\n}\n\nint main(){\n  int h, r, C[3];\n  double D[3], x, y, w, a;\n  Point O[3][100];\n  Point H[100];\n  int P[100];\n  \n  while(1){\n    cin >> h >> r;\n    if ( h == 0 && r == 0 ) break;\n\n    for ( int i = 0; i < h; i++ ) P[i] = 0;\n    for ( int i = 0; i < h; i++ ) cin >> H[i].x >> H[i].y;\n    cin >> C[0] >> C[1] >> C[2] >> D[0] >> D[1] >> D[2];\n\n    for ( int i = 0; i < 3; i++ ){\n      for ( int j = 0; j < C[i]; j++ ){\n\tcin >> O[i][j].x >> O[i][j].y ;\n      }\n    }\n\n    for ( int i = 0; i < r; i++ ){\n      cin >> w >> a;\n      for ( int b = 0; b < h; b++ ){\n\tPoint target = H[b];\n\tbool coveredByOther = false;\n\tbool coveredByMe = isInSector(Point(0, 0), a, D[0], w, target);\n\tfor ( int k = 0; k < 3; k++ ){\n\t  for ( int l = 0; l < C[k]; l++ ){\n\t    if ( isInSector(O[k][l], a, D[k], w, target)) coveredByOther = true;\n\t  }\n\t}\n\tif (!coveredByOther && coveredByMe ) P[b]++;\n      }\n    }\n    int maxv = 0;\n    for ( int i = 0; i < h; i++ ) {\n      maxv = max(maxv, P[i]);\n    }\n    if ( maxv == 0 ) cout << \"NA\" << endl;\n    else {\n      bool f = true;\n      for ( int i = 0; i < h; i++ ){\n\tif ( maxv == P[i] ) {\n\t  if ( !f) cout << \" \";\n\t  cout << i+1;\n\t  f = false;\n\t}\n      }\n      cout << endl;\n    }\n\n\n  }\n}"
  },
  {
    "language": "C++",
    "code": "#include <cstdio>\n#include <cstdlib>\n#include <cmath>\n#include <cstring>\n\n#include <iostream>\n#include <string>\n#include <algorithm>\n#include <vector>\n#include <queue>\n#include <stack>\n#include <map>\n#include <set>\n\n#include <functional>\n#include <cassert>\n\ntypedef long long ll;\nusing namespace std;\n\n#define debug(x) cerr << #x << \" = \" << x << endl;\n\n\n#define mod 1000000007 //1e9+7(prime number)\n#define INF 1000000000 //1e9\n#define LLINF 2000000000000000000LL //2e18\n#define SIZE 10000\n\n#define eps 1e-8\n\nbool is_ok(int hx,int hy, int tx, int ty, int td,int a,int w){\n\n  int dx = hx - tx;\n  int dy = hy - ty;\n\n  if(a*a < dx*dx + dy*dy) return false;\n\n  double rad = atan((double)dy/dx);\n\n  if(rad < 0){\n    rad += M_PI;\n  }\n  \n  if(dy < 0){\n    rad += M_PI;\n  }\n\n  rad = rad/M_PI * 180;\n  \n  rad += 180 - w;\n  w = 180;\n\n  if(rad >= 360) rad -= 360;\n    \n  return w - td/2 < rad && rad < w + td/2;\n}\n\nbool calc(){\n  int h,r,t;\n  int hx[SIZE],hy[SIZE];\n  int u,m,s,du,dm,ds;\n  int tx[SIZE],ty[SIZE],td[SIZE];\n  int w[SIZE],a[SIZE];\n  \n  scanf(\"%d%d\",&h,&r);\n\n  if(h==0) return false;\n\n  for(int i=0;i<h;i++){\n    scanf(\"%d%d\",hx+i,hy+i);\n  }\n\n  scanf(\"%d%d%d%d%d%d\",&u,&m,&s,&du,&dm,&ds);\n\n  t = u+m+s;\n  \n  for(int i=0;i<u;i++){\n    scanf(\"%d%d\",tx+i,ty+i);\n    td[i] = du;\n  }\n\n  for(int i=u;i<u+m;i++){\n    scanf(\"%d%d\",tx+i,ty+i);\n    td[i] = dm;\n  }\n\n  for(int i=u+m;i<u+s+m;i++){\n    scanf(\"%d%d\",tx+i,ty+i);\n    td[i] = ds;\n  }\n\n  for(int i=0;i<r;i++){\n    scanf(\"%d%d\",w+i,a+i);\n  }\n\n  int max_d = 0;\n  int ans[SIZE] = {};\n\n  for(int i=0;i<h;i++){\n\n    for(int j=0;j<r;j++){\n      bool flag = true;\n\n      for(int k=0;k<t;k++){\n        if(is_ok(hx[i],hy[i],tx[k],ty[k],td[k],a[j],w[j])) flag = false;\n      }\n\n      if(flag && is_ok(hx[i],hy[i],0,0,du,a[j],w[j])) ans[i]++;\n    }\n  }\n  \n  for(int i=0;i<h;i++)\n    max_d = max(max_d,ans[i]);\n\n  if(max_d > 0){\n  \n    bool flag1 = false;\n    \n    for(int i=0;i<h;i++){\n      if(max_d == ans[i]){\n        if(flag1) printf(\" \");\n        flag1 = true;\n        printf(\"%d\",i+1);\n      }\n    }\n    \n    printf(\"\\n\");\n  }else{\n    puts(\"NA\");\n  }\n  \n  return true;\n}\n  \n\nint main(){\n\n  while(calc());\n  \n  return 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\n \nusing namespace std;\n \nstruct point {\n    double x, y;\n    int d;\n};\n \nbool check_dst(point home, point ums, double a) {\n \n    double x = home.x - ums.x;\n    double y = home.y - ums.y;\n \n    return x * x + y * y <= a * a;\n \n}\n \nbool check_deg(point home, point ums, double w) {\n \n    double x = home.x - ums.x;\n    double y = home.y - ums.y;\n    double home_deg;\n    double start_deg = w - ums.d / 2.0;\n    double end_deg = w + ums.d / 2.0;\n \n    home_deg = atan2(y, x) * 180 / M_PI;\n \n    if(home_deg < 0) {\n        home_deg += 360;\n    }\n \n    if(0 <= start_deg && end_deg <= 360) {\n        return start_deg <= home_deg && home_deg <= end_deg;\n    } else if(start_deg < 0) {\n        start_deg += 360;\n        return start_deg <= home_deg || home_deg <= end_deg;\n    } else { // end_deg > 360\n        end_deg -= 360;\n        return start_deg <= home_deg || home_deg <= end_deg;\n    }\n \n}\n \nint main() {\n \n    int h, r;\n \n    while(cin >> h >> r, h || r) {\n \n        int u, m, s;\n        double du, dm, ds;\n        vector<point> homes, ums;\n \n        for(int i = 0; i < h; ++i) {\n            int x, y;\n            cin >> x >> y;\n            homes.push_back((point){ x, y, 0 });\n        }\n \n        cin >> u >> m >> s;\n        cin >> du >> dm >> ds;\n \n        for(int i = 0; i < u + m + s; ++i) {\n            double x, y;\n            cin >> x >> y;\n            if(i < u) {\n                ums.push_back((point){ x, y, du });\n            } else if(u <= i && i < u + m) {\n                ums.push_back((point){ x, y, dm });\n            } else {\n                ums.push_back((point){ x, y, ds });\n            }\n        }\n \n        for(int i = 0; i < r; ++i) {\n            double w, a;\n            cin >> w >> a;\n            for(int j = 0; j < homes.size(); ++j) {\n                bool is_perfect = true;\n                for(int k = 0; k < ums.size(); ++k) {\n                    if(check_deg(homes[j], ums[k], w) && check_dst(homes[j], ums[k], a)) {\n                        is_perfect = false;\n                    }\n                }\n                homes[j].d += is_perfect;\n            }\n        }\n \n        int max_day = 0;\n        for(int i = 0; i < homes.size(); ++i) {\n            max_day = max(max_day, homes[i].d);\n        }\n \n        if(max_day) {\n            bool is_out = false;\n            for(int i = 0; i < homes.size(); ++i) {\n                if(homes[i].d == max_day) {\n                    if(is_out) cout << \" \" << i + 1;\n                    else cout << i + 1;\n                    is_out = true;\n                }\n            }\n            cout << endl;\n        } else {\n            cout << \"NA\" << endl;\n        }\n \n    }\n \n}"
  },
  {
    "language": "C++",
    "code": "#include <iostream>\n#include <vector> \n#include <cmath>\nusing namespace std;\n\n#define rep(i, n) for(int i = 0;i < n;i++)\n#define cin_pair(p) cin >> (p).first >> (p).second;\n\ntypedef pair<int, int> pos;\n\nbool isInSmell(int x, int y, int w, float d, int a, int cx, int cy) {\n    cx -= x; cy -= y;\n    x = y = 0;\n    int angle = atan2((double)cy, (double)cx) / M_PI * 180, lensq = cx * cx + cy * cy;\n    return (w - d / 2 <= angle && angle <= w + d / 2 && lensq <= a * a);\n}\n\nbool isInSmells(int w, float d, int a, vector<pos> &vec, int cx, int cy) {\n    //cout << vec.size();\n    rep(i, vec.size()) {\n        //cout << vec[i].first << ' ' << vec[i].second << endl;\n        if(isInSmell(vec[i].first, vec[i].second, w, d, a, cx, cy)) {\n            return true;\n        }\n    }\n}\n\nint main() {\n    int H, R;\n    int U, M, S, du, dm, ds;\n\n    while(true) {\n        cin >> H >> R;\n        if(!H && !R) break;\n\n        vector<pos> h(H);\n        rep(i, H) {\n            cin_pair(h[i]);\n        }\n        cin >> U >> M >> S >> du >> dm >> ds;\n        vector<pos> u(U), m(M), s(S), wa(R);\n        rep(i, U) {\n            cin_pair(u[i]);\n        }\n        rep(i, M) {\n            cin_pair(m[i]);\n        }\n        rep(i, S) {\n            cin_pair(s[i]);\n        }\n        rep(i, R) {\n            cin_pair(wa[i]);\n        }\n\n        vector<int> days(H, 0);\n        int maxa = -1;\n        rep(ri, R) {\n            rep(hi, H) {\n                int x = h[hi].first, y = h[hi].second;\n                int w = wa[ri].first, a = wa[ri].second;\n                if(\n                    !isInSmells(w, du, a, u, x, y) &&\n                    !isInSmells(w, dm, a, m, x, y) &&\n                    !isInSmells(w, ds, a, s, x, y) &&\n                    isInSmell(0, 0, w, du, a, x, y)\n                    ){\n                    days[hi]++;\n                    maxa = max(maxa, days[hi]);\n                }\n            }\n        }\n\n        //rep(i, days.size()) cout << days[i] << ' ';\n        //cout << endl;\n\n        int ansnum = 0;\n        rep(i, H) {\n            if(days[i] == maxa) ansnum++;\n        }\n        if(maxa == -1) {\n            cout << \"NA\" << endl;\n        }\n        else {\n            int j = 0;\n            rep(i, H) {\n                if(days[i] == maxa) {\n                    cout << i + 1;\n                    ansnum--;\n                    if(ansnum != 0) cout << ' ';\n                }\n            }\n            cout << endl;\n        }\n    }\n}"
  },
  {
    "language": "C++",
    "code": "#include<stdio.h>\n#include<algorithm>\n#include<math.h>\nusing namespace std;\ndouble x[200];\ndouble y[200];\ndouble ux[100];\ndouble uy[100];\ndouble mx[100];\ndouble my[100];\ndouble sx[100];\ndouble sy[100];\ndouble PI=acos(-1);\nint ans[200];\ndouble Abs(double a){double ret=max(a,-a);if(ret>PI)ret=2*PI-ret;return ret;}\ndouble dist(double x,double y){return sqrt(x*x+y*y);}\nint main(){\n\tint a,b;\n\twhile(scanf(\"%d%d\",&a,&b),a){\n\t\tfor(int i=0;i<a;i++)ans[i]=0;\n\t\tfor(int i=0;i<a;i++)scanf(\"%lf%lf\",x+i,y+i);\n\t\tint u,m,s;\n\t\tdouble du,dm,ds;\n\t\tscanf(\"%d%d%d%lf%lf%lf\",&u,&m,&s,&du,&dm,&ds);\n\n\t\tdu=PI*du/360;\n\t\tdm=PI*dm/360;\n\t\tds=PI*ds/360;\n\t\tfor(int i=0;i<u;i++){\n\t\t\tscanf(\"%lf%lf\",ux+i,uy+i);\n\t\t}\n\t\tfor(int i=0;i<m;i++){\n\t\t\tscanf(\"%lf%lf\",mx+i,my+i);\n\t\t}\n\t\tfor(int i=0;i<s;i++){\n\t\t\tscanf(\"%lf%lf\",sx+i,sy+i);\n\t\t}\n\t\tfor(int i=0;i<b;i++){\n\t\t\tdouble w,r;\n\t\t\tscanf(\"%lf%lf\",&w,&r);\n\t\t\tw=PI*w/180;\n\t\t\tif(w>PI)w-=2*PI;\n\t\t\tfor(int j=0;j<a;j++){\n\t\t\t\tbool ok=false;\n\t\t\t\tif(dist(x[j],y[j])<r&&Abs(atan2(y[j],x[j])-w)<du){\n\t\t\t\t\tok=true;\n\t\t\t\t}\n\t\t\t\tfor(int k=0;k<u;k++){\n\t\t\t\t\tif(dist(x[j]-ux[k],y[j]-uy[k])<r&&Abs(atan2(y[j]-uy[k],x[j]-ux[k])-w)<du)ok=false;\n\t\t\t\t}\n\t\t\t\tfor(int k=0;k<m;k++){\n\t\t\t\t\tif(dist(x[j]-mx[k],y[j]-my[k])<r&&Abs(atan2(y[j]-my[k],x[j]-mx[k])-w)<dm)ok=false;\n\t\t\t\t}\n\t\t\t\tfor(int k=0;k<s;k++){\n\t\t\t\t\tif(dist(x[j]-sx[k],y[j]-sy[k])<r&&Abs(atan2(y[j]-sy[k],x[j]-sx[k])-w)<ds)ok=false;\n\t\t\t\t}\n\t\t\t\tif(ok)ans[j]++;\n\t\t\t}\n\t\t}\n\t\tint val=0;\n\t\tfor(int i=0;i<a;i++){\n\t\t\tval=max(val,ans[i]);\n\t\t//\tprintf(\"%d\\n\",ans[i]);\n\t\t}\n\t\tif(val==0)printf(\"NA\\n\");\n\t\telse{\n\t\t\tbool f=true;\n\t\t\tfor(int i=0;i<a;i++){\n\t\t\t\tif(val==ans[i]){\n\t\t\t\t\tif(!f){printf(\" \");}\n\t\t\t\t\tf=false;\n\t\t\t\t\tprintf(\"%d\",i+1);\n\t\t\t\t}\n\t\t\t}\n\t\t\tprintf(\"\\n\");\n\t\t}\n\t}\n}"
  },
  {
    "language": "C++",
    "code": "\n//自分の梅は任意の地点でかおるとする。EPSはつけない。\n//扇形と家は接しないので、距離はsqrtで求めた。\n\n#include<iostream>\n#include<cmath>\n#include<vector>\n#define rep(i,n) for(i = 0;i < n;i++)\n#define PI 3.14159265358979\nusing namespace std;\n\ntypedef pair<double,double> P;\n\nint H,R;\t\t\t\t//家数,日数\nint hx[100],hy[100];\t//家の座標\nint U,M,S;\t\t\t\t//梅、桃、桜の数\nint du,dm,ds;\t\t\t//梅、桃、桜の扇形の中心角\nint ux[100],uy[100];\t//梅の座標\nint mx[100],my[100];\t//桃の座標\nint sx[100],sy[100];\t//桜の座標\nint w[100],a[100];\t\t//扇形の方向(角度),風の強さ\n\n//半径,角度の順で格納し、返す\n//rotateは角度補正( 補正 = rotate*360 )\nP POLAR( int treex,int treey,int housex,int housey,int rotate )\n{\n\tP ans;\n\tans.first = (housex-treex)*(housex-treex) + (housey-treey)*(housey-treey);\n\tans.first = sqrt( ans.first );\n\tif( housex == treex && housey > treey )\n\t\tans.second = 90;\n\telse if( housex == treex && housey < treey )\n\t\tans.second = -90;\n\telse\n\t\tans.second = atan2( (double)housey - treey, (double)housex - treex ) * 180 / PI;\n\tans.second += 360*rotate;\n\treturn ans;\n}\n\nint main()\n{\n\tint i,j,k,l;\n\twhile( cin >> H >> R )\n\t{\n\t\tint day[100] = {0};\t\t//i番目の家において、他の木の香りが届かなかった日数\n\n\t\tif( H == 0 && R == 0 )\n\t\t\tbreak;\n\t\trep(i,H)\n\t\t\tcin >> hx[i] >> hy[i];\n\t\tcin >> U >> M >> S >> du >> dm >> ds;\n\t\trep(i,U)\n\t\t\tcin >> ux[i] >> uy[i];\n\t\trep(i,M)\n\t\t\tcin >> mx[i] >> my[i];\n\t\trep(i,S)\n\t\t\tcin >> sx[i] >> sy[i];\n\t\trep(i,R)\n\t\t\tcin >> w[i] >> a[i];\n\t\t//ここから探索\n\t\trep(i,R){\n\t\t\trep(j,H){\n\t\t\t\trep(k,U){\n\t\t\t\t\trep(l,3){\n\t\t\t\t\t\tP t = POLAR( ux[k],uy[k],hx[j],hy[j],l-1 );\n\t\t\t\t\t\t//判定\n\t\t\t\t\t\tif( t.first <= a[i] && fabs( (double)w[i] - t.second ) <= du/2 )\n\t\t\t\t\t\t\tbreak;\n\t\t\t\t\t}\n\t\t\t\t\tif(l < 3)\n\t\t\t\t\t\tbreak;\n\t\t\t\t}\n\t\t\t\tif(k < U)\n\t\t\t\t\tcontinue;\n\t\t\t\trep(k,M){\n\t\t\t\t\trep(l,3){\n\t\t\t\t\t\tP t = POLAR( mx[k],my[k],hx[j],hy[j],l-1 );\n\t\t\t\t\t\t//判定\n\t\t\t\t\t\tif( t.first <= a[i] && fabs( (double)w[i] - t.second ) <= dm/2 )\n\t\t\t\t\t\t\tbreak;\n\t\t\t\t\t}\n\t\t\t\t\tif(l < 3)\n\t\t\t\t\t\tbreak;\n\t\t\t\t}\n\t\t\t\tif(k < M)\n\t\t\t\t\tcontinue;\n\t\t\t\trep(k,S){\n\t\t\t\t\trep(l,3){\n\t\t\t\t\t\tP t = POLAR( sx[k],sy[k],hx[j],hy[j],l-1 );\n\t\t\t\t\t\t//判定\n\t\t\t\t\t\tif( t.first <= a[i] && fabs( (double)w[i] - t.second ) <= ds/2 )\n\t\t\t\t\t\t\tbreak;\n\t\t\t\t\t}\n\t\t\t\t\tif(l < 3)\n\t\t\t\t\t\tbreak;\n\t\t\t\t}\n\t\t\t\tif(k < S)\n\t\t\t\t\tcontinue;\n\n\t\t\t\tday[j]++;\n\t\t\t}\n\t\t}\n\t\tint maxday = 0;\n\t\trep(i,H){\n\t\t\tmaxday = max( maxday,day[i] );\n\t\t}\n\t\tif( maxday == 0 ){\n\t\t\tcout << \"NA\" << endl;\n\t\t\tcontinue;\n\t\t}\n\t\trep(i,H){\n\t\t\tif( day[i] == maxday ){\n\t\t\t\tcout << i+1;\n\t\t\t\tif( i < H-1 )\n\t\t\t\t\tcout << ' ';\n\t\t\t\telse\n\t\t\t\t\tcout << endl;\n\t\t\t}\n\t\t}\n\t}\n\treturn 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include<iostream>\n#include<cstdio>\n#include<cstdlib>\n#include<complex>\n#include<vector>\n#include<algorithm>\n#include<cmath>\n\n#define EQ(a,b) (abs((a)-(b)) < EPS)\n#define fs first\n#define sc second\n#define pb push_back\n#define sz size()\n#define rep(i,a) for(int i=0;i<(int)(a);i++)\n\nusing namespace std;\ntypedef double D;\ntypedef complex<D> P;\nconst D EPS = 1e-8;\nconst D PI = acos(-1);\n\nD dot(P x,P y){return real(conj(x)*y);}\nD cross(P x,P y){return imag(conj(x)*y);}\nD arg(P a,P b,P c){\n  D res = acos(dot(b-a,c-a)/(abs(b-a)*abs(c-a))); \n  return (cross(b-a,c-a)<EPS)?2*PI-res:res;\n}\n\nint h,r,n[3];\nD d[3],tmp1,tmp2,seta;\nP hp[110],up[3][110];\nD w[110],a[110];\nconst P O = P(0,0), H = P(1,0);\n\nint main(){\n  int cnt = 0;\n  while(cin >> h >> r,h){\n    rep(i,h){\n      cin >> tmp1 >> tmp2;\n      hp[i] = P(tmp1,tmp2);\n    }\n\n    rep(i,3)cin >> n[i]; rep(i,3)cin >> d[i], d[i] *= PI/180/2;\n\n    rep(i,3)rep(j,n[i]){\n      cin >> tmp1 >> tmp2;\n      up[i][j] = P(tmp1,tmp2);\n    }\n\n    rep(i,r)cin >> w[i] >> a[i], w[i] *= PI/180;\n\n    int num[110] = {};\n    rep(x,r){\n      rep(id,h){\n\tint in = 0;\n\trep(i,3)rep(j,n[i]){\n\t  //if(id==4)cout << i << \" \" <<  abs(hp[id]-up[i][j]) << endl;\n\t  if(abs(hp[id]-up[i][j]) < a[x] +EPS){\n\t    P tmp = P(up[i][j].real() + 1, up[i][j].imag());\n\t    seta = arg(up[i][j],tmp,hp[id]);\n\t    if(id==4)cout << seta/PI * 180 << endl;\n\t    if(w[x]-d[i] < seta+EPS && seta < w[x]+d[i]+EPS){\n\t      in++;\n\t    }\n\t  }\n\t}\n\t//if(id==4)cout << in << endl;\n\tif(in)continue;\n\n        seta = arg(P(0,0),P(1,0),hp[id]);\n\t//if(id==4)cout << seta/PI * 180 << endl;\n\tif(abs(hp[id]) < a[x] + EPS && w[x]-d[0] < seta+EPS && seta < w[x]+d[0]+EPS){\n\t  num[id]++;\n\t}\n      }\n    }\n\n    int maxv = *max_element(num,num+h);\n    vector<int> ans;\n    if(maxv==0)cout << \"NA\\n\";\n    else{\n      rep(i,h){\n\tif(num[i] == maxv)ans.pb(i+1);\n      }\n      rep(i,ans.sz)cout << ans[i] << (i+1==ans.size()?\"\\n\":\" \");\n    }\n  }\n}"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\n\nusing namespace std;\n\nstruct point {\n    int x, y;\n    int d;\n};\n\nbool check_including(point home, point ums, int w, int a) {\n\n    double x = home.x - ums.x;\n    double y = home.y - ums.y;\n    double home_deg;\n    double start_deg = w - ums.d / 2;\n    double end_deg = w + ums.d / 2;\n\n    if(x == 0) {\n        if(y > 0) {\n            home_deg = 90;\n        } else {\n            home_deg = 270;\n        }\n    } else if(y == 0) {\n        if(x > 0) {\n            home_deg = 0;\n        } else {\n            home_deg = 180;\n        }\n    } else {\n        home_deg = atan(y / x) * 180 / M_PI;\n        if(x < 0 && y > 0) {\n            home_deg += 180;\n        } else if(x < 0 && y < 0) {\n            home_deg += 180;\n        } else if(x > 0 && y < 0) {\n            home_deg += 360;\n        }\n    }\n\n    if(start_deg <= home_deg && home_deg <= end_deg && x * x + y * y <= a * a) {\n        return true;\n    } else {\n        return false;\n    }\n\n}\n\nint main() {\n\n    int h, r;\n\n    while(cin >> h >> r, h || r) {\n\n        int u, m, s, du, dm, ds;\n        vector<point> homes, ums;\n\n        for(int i = 0; i < h; ++i) {\n            int x, y;\n            cin >> x >> y;\n            homes.push_back((point){ x, y, 0 });\n        }\n\n        cin >> u >> m >> s;\n        cin >> du >> dm >> ds;\n\n        for(int i = 0; i < u + m + s; ++i) {\n            int x, y;\n            cin >> x >> y;\n            if(i < u) {\n                ums.push_back((point){ x, y, du });\n            } else if(u <= i && i < u + m) {\n                ums.push_back((point){ x, y, dm });\n            } else {\n                ums.push_back((point){ x, y, ds });\n            }\n        }\n\n        for(int i = 0; i < r; ++i) {\n            int w, a;\n            cin >> w >> a;\n            for(int j = 0; j < homes.size(); ++j) {\n                bool is_perfect = true;\n                for(int k = 0; k < ums.size(); ++k) {\n                    if(check_including(homes[j], ums[k], w, a)) {\n                        is_perfect = false;\n                        break;\n                    }\n                }\n                homes[j].d += is_perfect;\n            }\n        }\n\n        int max_day = 0;\n        for(int i = 1; i < homes.size(); ++i) {\n            if(max_day < homes[i].d) {\n                max_day = homes[i].d;\n            }\n        }\n\n        if(max_day) {\n            bool is_out = false;\n            for(int i = 0; i < homes.size(); ++i) {\n                if(homes[i].d == max_day) {\n                    if(is_out) cout << \" \" << i + 1;\n                    else cout << i + 1;\n                    is_out = true;\n                }\n            }\n            cout << endl;\n        } else {\n            cout << \"NA\" << endl;\n        }\n\n    }\n\n}"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\n \nusing namespace std;\n \nstruct point {\n    double x, y;\n    int d;\n};\n \nbool check_dst(point home, point ums, double a) {\n \n    double x = home.x - ums.x;\n    double y = home.y - ums.y;\n \n    return x * x + y * y <= a * a;\n \n}\n \nbool check_deg(point home, point ums, double w) {\n \n    double x = home.x - ums.x;\n    double y = home.y - ums.y;\n    double home_deg;\n    double start_deg = w - ums.d / 2.0;\n    double end_deg = w + ums.d / 2.0;\n \n    home_deg = atan2(y, x) * 180 / M_PI;\n \n    if(home_deg < 0.0) {\n        home_deg += 360.0;\n    }\n \n    if(0.0 <= start_deg && end_deg <= 360.0) {\n        return start_deg <= home_deg && home_deg <= end_deg;\n    } else if(start_deg < 0.0) {\n        start_deg += 360.0;\n        return start_deg <= home_deg || home_deg <= end_deg;\n    } else { // end_deg > 360\n        end_deg -= 360.0;\n        return start_deg <= home_deg || home_deg <= end_deg;\n    }\n \n}\n\nbool check_reach(point home, point ums, double w, double a) {\n    return check_deg(home, ums, w) && check_dst(home, ums, a);\n}\n \nint main() {\n \n    int h, r;\n \n    while(cin >> h >> r, h || r) {\n \n        int u, m, s;\n        double du, dm, ds;\n        vector<point> homes, ums;\n \n        for(int i = 0; i < h; ++i) {\n            double x, y;\n            cin >> x >> y;\n            homes.push_back((point){ x, y, 0 });\n        }\n \n        cin >> u >> m >> s;\n        cin >> du >> dm >> ds;\n \n        for(int i = 0; i < u + m + s; ++i) {\n            double x, y;\n            cin >> x >> y;\n            if(i < u) {\n                ums.push_back((point){ x, y, du });\n            } else if(u <= i && i < u + m) {\n                ums.push_back((point){ x, y, dm });\n            } else {\n                ums.push_back((point){ x, y, ds });\n            }\n        }\n \n        for(int i = 0; i < r; ++i) {\n            double w, a;\n            cin >> w >> a;\n            for(int j = 0; j < homes.size(); ++j) {\n                bool is_perfect = check_reach(homes[j], (point){ 0, 0, du }, w, a);\n                for(int k = 0; k < ums.size(); ++k) {\n                    if(check_reach(homes[j], ums[k], w, a)) {\n                        is_perfect = false;\n                    }\n                }\n                homes[j].d += is_perfect;\n            }\n        }\n \n        int max_day = 0;\n        for(int i = 0; i < homes.size(); ++i) {\n            max_day = max(max_day, homes[i].d);\n        }\n \n        if(max_day) {\n            bool is_out = false;\n            for(int i = 0; i < homes.size(); ++i) {\n                if(homes[i].d == max_day) {\n                    if(is_out) cout << \" \" << i + 1;\n                    else cout << i + 1;\n                    is_out = true;\n                }\n            }\n            cout << endl;\n        } else {\n            cout << \"NA\" << endl;\n        }\n \n    }\n \n}"
  },
  {
    "language": "C++",
    "code": "#include<iostream>\n#include<vector>\n#include<cmath>\n#include<algorithm>\n#include<numeric>\nusing namespace std;\n\nconst double PI = 3.14159265358979;\nconst double EPS = 1e-5;\n\nclass Point {\npublic:\n    double x, y;\n    Point(double x = 0.0, double y = 0.0) :x(x), y(y) {}\n};\n\nclass Wind {\npublic:\n    double w, a;\n};\n\nbool savor(const Point &home, const Wind &wind, const vector<Point> &blossom, double d) {\n//     cout << \"home: \" << home.x << \", \" << home.y << endl;\n//     cout << \"blossom\" << endl; for(const auto &i: blossom) cout << \"  \" << i.x << \",\" << i.y; cout << endl;\n//     cout << \"d: \" << d << endl;\n//     cout << \"wind: \" << wind.w << \", \" << wind.a << endl;\n//     cout << endl;\n    d /= 2.0;\n    for(const auto &b: blossom) {\n        Point dif(home.x - b.x, home.y - b.y);\n        double angle = atan2(dif.y, dif.x);\n        double dist = hypot(dif.y, dif.x);\n        if(angle < 0) angle = 2 * PI - angle;\n//         cout<<\"angle: \"<<angle<<endl;\n//         cout<<\"wind.w +- d: \"<<wind.w - d<<\" - \"<<wind.w + d<<endl;\n//         cout<<\"dist: \"<<dist<<endl;\n        if(wind.w - d <= angle + EPS && angle <= wind.w + d + EPS && dist <= wind.a + EPS) return true;\n    }\n    return false;\n}\n\ndouble toRadian(double d) {\n    return d * PI / 180.0;\n}\n\nint main() {\n    int H, R;\n    while(cin >> H >> R, H | R) {\n        vector<Point> home(H);\n        for(auto &i: home) cin >> i.x >> i.y;\n\n        int U, M, S;\n        double du, dm, ds;\n        cin >> U >> M >> S >> du >> dm >> ds;\n\n        du = toRadian(du);\n        dm = toRadian(dm);\n        ds = toRadian(ds);\n\n        vector<Point> plum(U), peach(M), cherry(S);\n        for(auto &i: plum) cin >> i.x >> i.y;\n        for(auto &i: peach) cin >> i.x >> i.y;\n        for(auto &i: cherry) cin >> i.x >> i.y;\n\n        vector<Wind> wind(R);\n        for(auto &i: wind) cin >> i.w >> i.a;\n        for(auto &i: wind) i.w = toRadian(i.w);\n\n        // test\n//         cout << savor(home[5], wind[0], peach, dm) << endl;\n//         return 0;\n\n        // solve\n        vector<int> number(H, 0);\n        int maxNumber = 0;\n\n        for(int i = 0; i < H; ++i) {\n            for(int day = 0; day < R; ++day) {\n                bool ok = savor(home[i], wind[day], {Point(0.0, 0.0)}, du);\n                bool ng = false;\n                ng |= savor(home[i], wind[day], plum, du);\n                ng |= savor(home[i], wind[day], peach, dm);\n                ng |= savor(home[i], wind[day], cherry, ds);\n\n//                 cout<<\"day\"<<day<<endl;\n//                 cout<<savor(home[i], wind[day], plum, du)<<\" \"<<savor(home[i], wind[day], peach, du)<<\" \"<<savor(home[i], wind[day], cherry, du)<<endl;\n\n                if(!ok || ng) continue;\n\n                ++number[i];\n                maxNumber = max(maxNumber, number[i]);\n            }\n        }\n\n//         for(const auto &i: number) cout<<\" \"<<i;cout<<endl;\n\n        if(maxNumber) {\n            bool first = true;\n            for(int i = 0; i < H; ++i) if(number[i] == maxNumber) {\n                if(!first) cout << \" \";\n                first = false;\n                cout << i + 1;\n            }\n            cout << endl;\n        } else {\n            cout << \"NA\" << endl;\n        }\n\n//         return 0;\n    }\n}"
  },
  {
    "language": "C++",
    "code": "#include<bits/stdc++.h>\n#define x real() \n#define y imag() \nusing namespace std;\ntypedef complex<double> P;\n \nint ccw(P a,P b,P c){\n  b-=a;\n  c-=a;\n  if(imag(conj(b)*c)>0)return 1;\n  if(imag(conj(b)*c)<0)return -1;\n  return 0;\n}\n \nint main(){\n  int H,R;\n  while(cin>>H>>R,H){\n    P h[100];\n    for(int i=0;i<H;i++)\n      cin>>h[i].x>>h[i].y;\n    int m[3];\n    double d[3],w[100],a[100];\n    P p[3][10];\n    cin>>m[0]>>m[1]>>m[2]>>d[0]>>d[1]>>d[2];\n \n    for(int i=0;i<3;i++)\n      for(int j=0;j<m[i];j++)\n    cin>>p[i][j].x>>p[i][j].y;\n \n    for(int i=0;i<R;i++)cin>>w[i]>>a[i];\n \n    int c[100]={};\n \n    for(int i=0;i<R;i++){\n      bool f[100]={};\n      for(int j=0;j<H;j++){\n    P D=P(a[i]*cos((M_PI*(w[i]-d[0]/2)/180)),a[i]*sin((M_PI*(w[i]-d[0]/2)/180)));\n    P U=P(a[i]*cos((M_PI*(w[i]+d[0]/2)/180)),a[i]*sin((M_PI*(w[i]+d[0]/2)/180)));\n    if(abs(h[j])<=a[i]&&ccw(P(0,0),U,h[j])<=0&&ccw(P(0,0),D,h[j])>=0)f[j]=1;\n      }\n \n      for(int j=0;j<3;j++)\n    for(int k=0;k<m[j];k++)\n      for(int l=0;l<H;l++){\n        P D=P(a[i]*cos((M_PI*(w[i]-d[j]/2)/180)),a[i]*sin((M_PI*(w[i]-d[j]/2)/180)));\n        P U=P(a[i]*cos((M_PI*(w[i]+d[j]/2)/180)),a[i]*sin((M_PI*(w[i]+d[j]/2)/180)));\n        if(abs(p[j][k]-h[l])<=a[i]&&ccw(p[j][k],p[j][k]+U,h[l])<=0&&ccw(p[j][k],p[j][k]+D,h[l])>=0)\n          f[l]=0;\n      }\n      for(int j=0;j<H;j++)c[j]+=f[j];\n    }\n     \n    int mx=0;\n    vector<int> ans;\n    for(int i=0;i<H;i++)mx=max(mx,c[i]);\n    if(mx){\n      for(int i=0;i<H;i++)\n    if(mx==c[i])ans.push_back(i+1);\n      for(int i=0;i<ans.size();i++){\n    if(i)cout<<\" \";\n    cout<<ans[i];\n      }\n    }\n    else cout<<\"NA\";\n    cout<<endl;\n  }\n  return 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\n\nusing namespace std;\n\nstruct point {\n    int x, y;\n    int d;\n};\n\nbool check_including(point home, point ums, int w, int a) {\n\n    double x = home.x - ums.x;\n    double y = home.y - ums.y;\n    double home_deg;\n    double start_deg = w - ums.d / 2;\n    double end_deg = w + ums.d / 2;\n\n    /*\n    if(x == 0) {\n        if(y > 0) {\n            home_deg = 90;\n        } else {\n            home_deg = 270;\n        }\n    } else if(y == 0) {\n        if(x > 0) {\n            home_deg = 0;\n        } else {\n            home_deg = 180;\n        }\n    } else {\n        home_deg = atan(y / x) * 180 / M_PI;\n        if(x < 0 && y > 0) {\n            home_deg += 180;\n        } else if(x < 0 && y < 0) {\n            home_deg += 180;\n        } else if(x > 0 && y < 0) {\n            home_deg += 360;\n        }\n    }\n    */\n\n    home_deg = atan2(y, x) * 180 / M_PI;\n\n    if(home_deg < 0) {\n        home_deg += 360;\n    }\n\n    if(start_deg <= home_deg && home_deg <= end_deg && x * x + y * y <= a * a) {\n        return true;\n    } else {\n        return false;\n    }\n\n}\n\nint main() {\n\n    int h, r;\n\n    while(cin >> h >> r, h || r) {\n\n        int u, m, s, du, dm, ds;\n        vector<point> homes, ums;\n\n        for(int i = 0; i < h; ++i) {\n            int x, y;\n            cin >> x >> y;\n            homes.push_back((point){ x, y, 0 });\n        }\n\n        cin >> u >> m >> s;\n        cin >> du >> dm >> ds;\n\n        for(int i = 0; i < u + m + s; ++i) {\n            int x, y;\n            cin >> x >> y;\n            if(i < u) {\n                ums.push_back((point){ x, y, du });\n            } else if(u <= i && i < u + m) {\n                ums.push_back((point){ x, y, dm });\n            } else {\n                ums.push_back((point){ x, y, ds });\n            }\n        }\n\n        for(int i = 0; i < r; ++i) {\n            int w, a;\n            cin >> w >> a;\n            for(int j = 0; j < homes.size(); ++j) {\n                bool is_perfect = true;\n                for(int k = 0; k < ums.size(); ++k) {\n                    if(check_including(homes[j], ums[k], w, a)) {\n                        is_perfect = false;\n                        break;\n                    }\n                }\n                homes[j].d += is_perfect;\n            }\n        }\n\n        int max_day = 0;\n        for(int i = 1; i < homes.size(); ++i) {\n            if(max_day < homes[i].d) {\n                max_day = homes[i].d;\n            }\n        }\n\n        if(max_day) {\n            bool is_out = false;\n            for(int i = 0; i < homes.size(); ++i) {\n                if(homes[i].d == max_day) {\n                    if(is_out) cout << \" \" << i + 1;\n                    else cout << i + 1;\n                    is_out = true;\n                }\n            }\n            cout << endl;\n        } else {\n            cout << \"NA\" << endl;\n        }\n\n    }\n\n}"
  },
  {
    "language": "C++",
    "code": "#include <iostream>\n#include <algorithm>\n#include <vector>\n#include <complex>\n#include <cmath>\nusing namespace std;\n\ntypedef complex<double> P;\n\nconst double pi = acos(-1);\nconst double eps = 1e-5;\n\nbool equals(double a, double b) {\n  return abs(a-b) < eps;\n}\n\ndouble dot(P a, P b) {\n  return a.real()*b.real() + a.imag()*b.imag();\n}\n\ndouble cross(P a, P b) {\n  return a.real()*b.imag() - a.imag()*b.real();\n}\n\ninline double toRad(double d) {\n  return pi*d/180.0;\n}\n\nconst int WATASHIUME = 1<<0;\nconst int UME        = 1<<1;\nconst int MOMO       = 1<<2;\nconst int SAKURA     = 1<<3;\n\nstruct Tree {\n  P pos;\n  int type;\n  int d;\n};\n\nclass Field {\n  vector<Tree> trees;\npublic:\n  void add(const Tree &t) {\n    trees.push_back(t);\n  }\n\n  int reach(const int w, const int a, const P &p) {\n    int res = 0;\n    for(int i = 0; i < trees.size(); ++i) {\n      P m = p - trees[i].pos;\n      double dist = abs(m);\n      if(equals(dist, a) || dist < a) ; else continue;\n      P s = P( cos(toRad(w) - toRad(trees[i].d)/2.0),\n               sin(toRad(w) - toRad(trees[i].d)/2.0) );\n      P t = P( cos(toRad(w) + toRad(trees[i].d)/2.0),\n               sin(toRad(w) + toRad(trees[i].d)/2.0) );\n      double cs = cross(s, m);\n      double ct = cross(t, m);\n      if(  ( equals(cs, 0.0) || cs > 0.0 ) &&\n           ( equals(ct, 0.0) || ct < 0.0 )  ) {\n        res |= trees[i].type;\n      }\n    }\n    return res;\n  }\n};\n\nint main() {\n  int H, R;\n  int U, M, S, du, dm, ds;\n  while(cin >> H >> R && (H|R)) {\n    Field field;\n    vector<P> ps(H);\n    for(int i = 0; i < H; ++i) {\n      cin >> ps[i].real() >> ps[i].imag();\n    }\n    cin >> U >> M >> S >> du >> dm >> ds;\n    field.add((Tree){P(0,0), WATASHIUME, du});\n    for(int i = 0; i < U; ++i) {\n      P pos;\n      cin >> pos.real() >> pos.imag(); \n      field.add((Tree){pos, UME, du});\n    }\n    for(int i = 0; i < M; ++i) {\n      P pos;\n      cin >> pos.real() >> pos.imag(); \n      field.add((Tree){pos, MOMO, dm});\n    }\n    for(int i = 0; i < S; ++i) {\n      P pos;\n      cin >> pos.real() >> pos.imag(); \n      field.add((Tree){pos, SAKURA, ds});\n    }\n\n    int cnt[H], con[H];\n    fill(cnt, cnt+H, 0);\n    fill(con, con+H, 0);\n\n    while(R--) {\n      int w, a;\n      cin >> w >> a;\n      for(int i = 0; i < H; ++i) {\n        if(field.reach(w,a,ps[i]) == WATASHIUME) {\n          con[i] += 1;\n        } else {\n          con[i] = 0;\n        }\n        cnt[i] = max(cnt[i], con[i]);\n      }\n    }\n\n    vector<pair<int,int> > v;\n    for(int i = 0; i < H; ++i) {\n      if(cnt[i] != 0)\n        v.push_back(make_pair(-cnt[i], i+1));\n    }\n    if(v.size()) {\n      sort(v.begin(), v.end());\n      for(int i = 0; i < v.size(); ++i) {\n        if(i && v[i].first != v[i-1].first) break;\n        if(i) cout << \" \";\n        cout << v[i].second;\n      }\n      cout << endl;\n    } else {\n      cout << \"NA\" << endl;\n    }\n  }\n  return 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include <iostream>\n#include <algorithm>\n#include <complex>\n#include <vector>\n#include <cmath>\nusing namespace std;\ntypedef complex<double> P;\n\nconst double PI = acos(-1);\nconst double EPS = 1e-9;\nbool hit(P p,double a,double b,double r){\n\tif( abs(p) > r + EPS ) return false;\n\tdouble deg = atan2(p.imag(),p.real());\n\tif( a <= deg && deg <= b ) return true;\n\tif( a <= deg+2*PI && deg+2*PI <= b ) return true;\n\tif( a <= deg-2*PI && deg-2*PI <= b ) return true;\n\treturn false;\n}\nint main(){\n\tint H,R;\n\twhile(cin >> H >> R && H){\n\t\tP home[100];\n\t\tfor(int i = 0 ; i < H ; i++) cin >> home[i].real() >> home[i].imag();\n\t\tint U,M,S;\n\t\tdouble du,dm,ds;\n\t\tcin >> U >> M >> S >> du >> dm >> ds;\n\t\tdu = du / 180.*PI;\n\t\tdm = dm / 180.*PI;\n\t\tds = ds / 180.*PI;\n\t\tdu /= 2;\n\t\tdm /= 2;\n\t\tds /= 2;\n\t\tvector< pair<P,double> > flower;\n\t\tfor(int i = 0 ; i < U+M+S ; i++){\t\n\t\t\tP p; cin >> p.real() >> p.imag();\n\t\t\tflower.push_back(make_pair(p,(i<U?du:i<U+M?dm:ds)));\n\t\t}\n\t\tint answer[110] = {};\n\t\tfor(int i = 0 ; i < R ; i++){\n\t\t\tdouble w,r;\n\t\t\tcin >> w >> r;\n\t\t\tw = w / 180. * PI;\n\t\t\tfor(int j = 0 ; j < H ; j++){\n\t\t\t\tint ok = hit(home[j],w-du,w+du,r);\n\t\t\t\t//cout << w-du << \" \" << w+du << endl;\n\t\t\t\tfor(int k = 0 ; k < U+M+S ; k++){\n\t\t\t\t\tok &= !hit(home[j]-flower[k].first,w-flower[k].second,w+flower[k].second,r);\n\t\t\t\t}\n\t\t\t\tanswer[j] += ok;\n\t\t\t}\n\t\t}\n\t\tint maximum = *max_element(answer,answer+H);\n\t\tint fst = 1;\n\t\tif( maximum == 0 ){ cout << \"NA\" << endl; goto exit; }\n\n\t\tfor(int i = 0 ; i < H ; i++)\n\t\t\tif( maximum == answer[i] ){\n\t\t\t\tif( fst == 0 ) cout << \" \";\n\t\t\t\tcout << i+1;\n\t\t\t\tfst = 0;\n\t\t\t}\n\t\tcout << endl;\n\t\texit:;\n\t}\n\t\n\t\n\t\n\t\n}"
  },
  {
    "language": "C++",
    "code": "#include<iostream>\n#include<cstdio>\n#include<cstdlib>\n#include<cstring>\n#include<cmath>\n#include<vector>\n\n#define PI 3.141592653589793\n\nusing namespace std;\n\nint h,r;\nint hx[101],hy[101];\nint u,m,s,du,dm,ds;\nint ux[101],uy[101];\nint mx[101],my[101];\nint sx[101],sy[101];\nint w[101],a[101];\n\nvoid init(){\n\tmemset(hx,0,sizeof(hx));\n\tmemset(hy,0,sizeof(hy));\n\tmemset(ux,0,sizeof(ux));\n\tmemset(uy,0,sizeof(uy));\n\tmemset(mx,0,sizeof(mx));\n\tmemset(my,0,sizeof(my));\n\tmemset(sx,0,sizeof(sx));\n\tmemset(sy,0,sizeof(sy));\n\tmemset(w,0,sizeof(w));\n\tmemset(a,0,sizeof(a));\n}\n\nbool check(int p,int d){\n\tbool f=false;\n\tfor(int i=u;i<=u;i++){\n\t\tdouble x=hx[p]-ux[i];\n\t\tdouble y=hy[p]-uy[i];\n\t\tif(x*x+y*y>a[d]*a[d])continue;\n\t\tdouble c=(atan2(y,x))*180/PI;\n\t\tif(c<0)c=(double)360.0+c;\n\t\tif((double)w[d]-du/2<=c && c<=(double)w[d]+du/2)f=true;\n\t\tif(c<(double)w[d]+du/2-360)f=true;\n\t}\n\tif(!f)return false;\n\tfor(int i=0;i<u;i++){\n\t\tdouble x=hx[p]-ux[i];\n\t\tdouble y=hy[p]-uy[i];\n\t\tif(x*x+y*y>a[d]*a[d])continue;\n\t\tdouble c=(atan2(y,x))*180/PI;\n\t\tif(c<0)c=(double)360.0+c;\n\t\tif((double)w[d]-du/2<=c && c<=(double)w[d]+du/2)return false;\n\t\tif(c<(double)w[d]+du/2-360)return false;\n\t}\n\tfor(int i=0;i<m;i++){\n\t\tdouble x=hx[p]-mx[i];\n\t\tdouble y=hy[p]-my[i];\n\t\tif(x*x+y*y>a[d]*a[d])continue;\n\t\tdouble c=(atan2(y,x))*180/PI;\n\t\tif(c<0)c=(double)360.0+c;\n\t\tif((double)w[d]-dm/2<=c && c<=(double)w[d]+dm/2)return false;\n\t\tif(c<(double)w[d]+dm/2-360)return false;\n\t}\n\t\n\tfor(int i=0;i<s;i++){\n\t\tdouble x=hx[p]-sx[i];\n\t\tdouble y=hy[p]-sy[i];\n\t\tif(x*x+y*y>a[d]*a[d])continue;\n\t\tdouble c=(atan2(y,x))*180/PI;\n\t\tif(c<0)c=(double)360.0+c;\n\t\tif((double)w[d]-ds/2<=c && c<=(double)w[d]+ds/2)return false;\n\t\tif(c<(double)w[d]+ds/2-360)return false;\n\t}\n\treturn true;\n}\n\nint main(void){\n\twhile(1){\n\t\tscanf(\"%d%d\",&h,&r);\n\t\tif(h==0 && r==0)break;\n\t\tinit();\n\t\tfor(int i=0;i<h;i++)scanf(\"%d%d\",&hx[i],&hy[i]);\n\t\tscanf(\"%d%d%d%d%d%d\",&u,&m,&s,&du,&dm,&ds);\n\t\tfor(int i=0;i<u;i++)scanf(\"%d%d\",&ux[i],&uy[i]);\n\t\tfor(int i=0;i<m;i++)scanf(\"%d%d\",&mx[i],&my[i]);\n\t\tfor(int i=0;i<s;i++)scanf(\"%d%d\",&sx[i],&sy[i]);\n\t\tfor(int i=0;i<r;i++)scanf(\"%d%d\",&w[i],&a[i]);\n\t\tint res=0;\n\t\tvector<int> id;\n\t\tfor(int i=0;i<h;i++){\n\t\t\tint cnt=0;\n\t\t\tfor(int j=0;j<r;j++){\n\t\t\t\tif(check(i,j))cnt++;\n\t\t\t}\n\t\t\tif(cnt==res)id.push_back(i+1);\n\t\t\tif(cnt>res){\n\t\t\t\tres=cnt;\n\t\t\t\tid.clear();\n\t\t\t\tid.push_back(i+1);\n\t\t\t}\n\t\t}\n\t\tif(res==0)printf(\"NA\\n\");\n\t\telse for(int i=0;i<id.size();i++)printf(\"%d%c\",id[i],i==id.size()-1?'\\n':' ');\n\t}\n\treturn 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include<iostream>\n#include<cmath>\n#include<vector>\n#include<algorithm>\nusing namespace std;\nint H,R,U,M,S;\ndouble hx[100],hy[100],dU,dM,dS,ux[100],uy[100],mx[100],my[100],sx[100],sy[100],W[100],A[100];\nbool f(double x,double y,double tx,double ty,double w,double a,double d)\n{\n\tdouble theta=atan2(y-ty,x-tx);\n\tdouble A=abs(theta-w);\n\tA=min(A,2*M_PI-A);\n\treturn hypot(x-tx,y-ty)<a&&A<d;\n}\nmain()\n{\n\twhile(cin>>H>>R,H)\n\t{\n\t\tfor(int i=0;i<H;i++)cin>>hx[i]>>hy[i];\n\t\tcin>>U>>M>>S;\n\t\tcin>>dU>>dM>>dS;\n\t\tdU=dU/2/180*M_PI;\n\t\tdM=dM/2/180*M_PI;\n\t\tdS=dS/2/180*M_PI;\n\t\tfor(int i=0;i<U;i++)cin>>ux[i]>>uy[i];\n\t\tfor(int i=0;i<M;i++)cin>>mx[i]>>my[i];\n\t\tfor(int i=0;i<S;i++)cin>>sx[i]>>sy[i];\n\t\tfor(int i=0;i<R;i++)\n\t\t{\n\t\t\tcin>>W[i]>>A[i];\n\t\t\tW[i]=W[i]>180?(W[i]-360)/180*M_PI:W[i]/180*M_PI;\n\t\t}\n\t\tvector<pair<int,int> >ans;\n\t\tfor(int i=0;i<H;i++)\n\t\t{\n\t\t\tdouble x=hx[i],y=hy[i];\n\t\t\tint cnt=0;\n\t\t\tfor(int k=0;k<R;k++)\n\t\t\t{\n\t\t\t\tif(!f(x,y,0,0,W[k],A[k],dU))continue;\n\t\t\t\tbool flag=1;\n\t\t\t\tfor(int j=0;j<U;j++)flag&=!f(x,y,ux[j],uy[j],W[k],A[k],dU);\n\t\t\t\tfor(int j=0;j<M;j++)flag&=!f(x,y,mx[j],my[j],W[k],A[k],dM);\n\t\t\t\tfor(int j=0;j<S;j++)flag&=!f(x,y,sx[j],sy[j],W[k],A[k],dS);\n\t\t\t\tif(flag)cnt++;\n\t\t\t}\n\t\t\tans.push_back(make_pair(-cnt,i+1));\n\t\t}\n\t\tsort(ans.begin(),ans.end());\n\t\tif(ans[0].first==0)cout<<\"NA\"<<endl;\n\t\telse\n\t\t{\n\t\t\tcout<<ans[0].second;\n\t\t\tfor(int i=1;i<H;i++)\n\t\t\t{\n\t\t\t\tif(ans[i].first==ans[0].first)cout<<\" \"<<ans[i].second;\n\t\t\t}\n\t\t\tcout<<endl;\n\t\t}\n\t}\n}\n\n"
  },
  {
    "language": "C++",
    "code": "#include<iostream>\n#include<complex>\n#include<vector>\n#include<algorithm>\n#include<cmath>\n#include<cstring>\n\n#define pb push_back\n#define sz size()\n#define rep(i,a) for(int i=0;i<(int)(a);i++)\n\nusing namespace std;\ntypedef long double D;\ntypedef complex<D> P;\nconst D EPS = 1e-4;\nconst D PI = acos(-1);\n\ninline D dot(P x,P y){return real(conj(x)*y);}\ninline D cross(P x,P y){return imag(conj(x)*y);}\nP rotate(P v,double s){\n  return P(real(v)*cos(s) - imag(v)*sin(s), real(v)*sin(s) + imag(v)*cos(s) );\n}\ninline D arg(P a,P b,P c){\n  D res = acos(dot(b-a,c-a)/(abs(b-a)*abs(c-a))); \n  return (cross(b-a,c-a)<0.0)?2*PI-res:res;\n}\n\nint h,r,n[3];\nD d[3],tmp1,tmp2,seta;\nP hp[110],up[3][110];\nD w[110],a[110];\n\nint main(){\n  while(cin >> h >> r,h){\n    rep(i,h){\n      cin >> tmp1 >> tmp2;\n      hp[i] = P(tmp1,tmp2);\n    }\n\n    rep(i,3)cin >> n[i]; rep(i,3)cin >> d[i], d[i] *= PI/180/2;\n\n    rep(i,3)rep(j,n[i]){\n      cin >> tmp1 >> tmp2;\n      up[i][j] = P(tmp1,tmp2);\n    }\n\n    rep(i,r)cin >> w[i] >> a[i], w[i] *= PI/180;\n\n    int num[110];\n    memset(num,0,sizeof(num));\n\n    rep(x,r)rep(id,h){\n      if( !(abs(hp[id]) < a[x] + EPS) )continue;\n      seta = arg(P(0,0),P(100,0),hp[id]);\n      if( !(w[x]-d[0] < seta+EPS && seta < w[x]+d[0]+EPS)\n\t  && !(w[x]-d[0]+2*PI < seta+EPS && seta < w[x]+d[0]+2*PI+EPS) )continue;\n\n      bool in = 0;\n      rep(i,3){\n\trep(j,n[i]){\n\t  if(abs(hp[id]-up[i][j]) < a[x] +EPS){\n\t    P tmp = P(up[i][j].real() + 100.0, up[i][j].imag());\n\t    seta = arg(up[i][j],tmp,hp[id]);\n\t    if(w[x]-d[i] < seta+EPS && seta < w[x]+d[i]+EPS){\n\t      in = 1; break;\n\t    }\n\t    seta -= 2*PI;\n\t    if(w[x]-d[i] < seta+EPS && seta < w[x]+d[i]+EPS){\n\t      in = 1; break;\n\t    }\n\t  }\n\t}\n\tif(in)break;\n      }\n      if(!in)num[id]++;\n    }\n\n    int maxv = *max_element(num,num+h);\n    if(maxv==0)cout << \"NA\\n\";\n    else{\n      vector<int> ans;\n      rep(i,h){\n\tif(num[i] == maxv)ans.pb(i+1);\n      }\n      rep(i,ans.sz)cout << ans[i] << (i+1==ans.size()?\"\\n\":\" \");\n    }\n  }\n}"
  },
  {
    "language": "C++",
    "code": "#include<bits/stdc++.h>\ntypedef long long int ll;\ntypedef unsigned long long int ull;\n#define BIG_NUM 2000000000\n#define MOD 1000000007\n#define EPS 0.000000001\nusing namespace std;\n\nstruct Point{\n\tPoint(double arg_x,double arg_y){\n\t\tx = arg_x;\n\t\ty = arg_y;\n\t}\n\n\tPoint(){\n\t\tx = y = 0.0;\n\t}\n\n\tPoint operator + (Point p){ return Point(x+p.x,y+p.y); }\n\tPoint operator - (Point p){ return Point(x-p.x,y-p.y);}\n\tPoint operator * (double a){ return Point(a*x,a*y); }\n\tPoint operator / (double a){ return Point(x/a,y/a); }\n\n\tdouble abs(){ return sqrt(norm()); }\n\tdouble norm(){ return x*x + y*y; }\n\n\tbool operator<(const Point &p) const{\n\t\treturn x != p.x? x < p.x: y < p.y;\n\t}\n\n\tbool operator == (const Point &p) const{\n\t\treturn fabs(x-p.x) < EPS && fabs(y-p.y) < EPS;\n\t}\n\n\tdouble x,y;\n};\n\ntypedef Point Vector;\n\nint num_house,num_wind;\nint UME,MOMO,SAKURA;\nint ok_num[100];\ndouble deg_UME,deg_MOMO,deg_SAKURA;\ndouble dist_UME[100][11],dist_MOMO[100][10],dist_SAKURA[100][10];\nPoint info[100],info_UME[11],info_MOMO[10],info_SAKURA[10];\nvector<int> ANS;\n\ndouble norm(Vector a){\n\treturn a.x*a.x+a.y*a.y;\n}\n\ndouble abs(Vector a){\n\treturn sqrt(norm(a));\n}\n\ndouble cross(Vector a,Vector b){\n    return a.x*b.y-a.y*b.x;\n}\n\ndouble dot(Vector a,Vector b){\n    return a.x*b.x + a.y*b.y;\n}\n\nstatic const int COUNTER_CLOCKWISE = 1;\nstatic const int CLOCKWISE = -1;\nstatic const int ONLINE_BACK = 2;\nstatic const int ONLINE_FRONT = -1;\nstatic const int ON_SEGMENT = 0;\n\nint ccw(Point p0,Point p1,Point p2){\n\n\tVector a = p1 - p0;\n\tVector b = p2 - p0;\n\n\tif(cross(a,b) > EPS)return COUNTER_CLOCKWISE;\n\tif(cross(a,b) < -EPS)return CLOCKWISE;\n\tif(dot(a,b) < -EPS)return ONLINE_BACK;\n\tif(a.norm() < b.norm())return ONLINE_FRONT;\n\n\treturn ON_SEGMENT;\n}\n\ndouble calc_dist(Point a,Point b){\n\treturn sqrt((a.x-b.x)*(a.x-b.x)+(a.y-b.y)*(a.y-b.y));\n}\n\nbool is_OK(Point tree,Point house,double value,double wind_deg,double deg){\n\n\t Vector v1 = Vector(value*cos((wind_deg+deg/2)*M_PI/180),value*sin((wind_deg+deg/2)*M_PI/180));\n\t Vector v2 = Vector(value*cos((wind_deg-deg/2)*M_PI/180),value*sin((wind_deg-deg/2)*M_PI/180));\n\n\t if(ccw(tree,tree+v1,house) == CLOCKWISE && ccw(tree,tree+v2,house) == COUNTER_CLOCKWISE) {\n\t\t return true;\n\t }else{\n\t\t return false;\n\t }\n}\n\nvoid func(){\n\n\tfor(int i = 0; i < num_house; i++)ok_num[i] = 0;\n\n\tfor(int i = 0; i < num_house; i++){\n\t\tscanf(\"%lf %lf\",&info[i].x,&info[i].y);\n\t}\n\n\tscanf(\"%d %d %d %lf %lf %lf\",&UME,&MOMO,&SAKURA,&deg_UME,&deg_MOMO,&deg_SAKURA);\n\n\t//私の梅\n\tinfo_UME[0].x = 0;\n\tinfo_UME[0].y = 0;\n\n\tfor(int i = 1; i <= UME; i++){\n\t\tscanf(\"%lf %lf\",&info_UME[i].x,&info_UME[i].y);\n\t}\n\n\tfor(int i = 0; i < MOMO; i++){\n\t\tscanf(\"%lf %lf\",&info_MOMO[i].x,&info_MOMO[i].y);\n\t}\n\n\tfor(int i = 0; i < SAKURA; i++){\n\t\tscanf(\"%lf %lf\",&info_SAKURA[i].x,&info_SAKURA[i].y);\n\t}\n\n\t//あらかじめ、各木との距離を求めておく\n\tfor(int i = 0; i < num_house; i++){\n\n\t\tfor(int k = 0; k <= UME; k++){\n\t\t\tdist_UME[i][k] = calc_dist(info[i],info_UME[k]);\n\t\t}\n\t\tfor(int k = 0; k < MOMO; k++){\n\t\t\tdist_MOMO[i][k] = calc_dist(info[i],info_MOMO[k]);\n\t\t}\n\t\tfor(int k = 0; k < SAKURA; k++){\n\t\t\tdist_SAKURA[i][k] = calc_dist(info[i],info_SAKURA[k]);\n\t\t}\n\t}\n\n\tdouble degree,value;\n\tbool FLG;\n\n\tfor(int loop = 0; loop < num_wind; loop++){\n\t\tscanf(\"%lf %lf\",&degree,&value);\n\n\t\t//私の梅の香りだけが届く家を探す\n\t\tfor(int i = 0; i < num_house; i++){\n\t\t\tif(value < dist_UME[i][0])continue;//私の梅から距離が遠ければSKIP\n\n\t\t\tif(!is_OK(info_UME[0],info[i],value,degree,deg_UME))continue; //私の梅から香りが届かなければSKIP\n\n\t\t\tFLG = true;\n\n\t\t\t//他の香りが届かないか調べる\n\t\t\tfor(int k = 1; k <= UME; k++){\n\t\t\t\tif(value >= dist_UME[i][k] && is_OK(info_UME[k],info[i],value,degree,deg_UME) == true){\n\t\t\t\t\tFLG = false;\n\t\t\t\t\tbreak;\n\t\t\t\t}\n\t\t\t}\n\t\t\tif(!FLG)continue;\n\n\t\t\tfor(int k = 0; k < MOMO; k++){\n\t\t\t\tif(value >= dist_MOMO[i][k] && is_OK(info_MOMO[k],info[i],value,degree,deg_MOMO) == true){\n\t\t\t\t\tFLG = false;\n\t\t\t\t\tbreak;\n\t\t\t\t}\n\t\t\t}\n\t\t\tif(!FLG)continue;\n\n\t\t\tfor(int k = 0; k < SAKURA; k++){\n\t\t\t\tif(value >= dist_SAKURA[i][k] && is_OK(info_SAKURA[k],info[i],value,degree,deg_SAKURA) == true){\n\t\t\t\t\tFLG = false;\n\t\t\t\t\tbreak;\n\t\t\t\t}\n\t\t\t}\n\t\t\tif(!FLG)continue;\n\n\t\t\tok_num[i]++;\n\t\t}\n\t}\n\n\tint maximum = 0;\n\tANS.clear();\n\n\tfor(int i = 0; i < num_house; i++){\n\t\tif(ok_num[i] > maximum){\n\t\t\tmaximum = ok_num[i];\n\t\t\tANS.clear();\n\t\t\tANS.push_back(i+1);\n\t\t}else if(ok_num[i] > 0 && ok_num[i] == maximum){\n\t\t\tANS.push_back(i+1);\n\t\t}\n\t}\n\n\tif(ANS.size() == 0){\n\t\tprintf(\"NA\\n\");\n\t}else{\n\n\t\tprintf(\"%d\",ANS[0]);\n\t\tfor(int i = 1; i < ANS.size(); i++){\n\t\t\tprintf(\" %d\",ANS[i]);\n\t\t}\n\t\tprintf(\"\\n\");\n\t}\n}\n\nint main(){\n\n\twhile(true){\n\t\tscanf(\"%d %d\",&num_house,&num_wind);\n\t\tif(num_house == 0 && num_wind == 0)break;\n\n\t\tfunc();\n\t}\n\n\treturn 0;\n}\n\n"
  },
  {
    "language": "C++",
    "code": "#include <iostream>\n#include <cmath>\n#include <vector>\n#include <map>\n#include <algorithm>\nusing namespace std;\n\nconst double EPS = 0.001;\nconst double PI = acos(-1.0);\n\n// 2つのスカラーが等しいかどうか\nbool equal(double a, double b) {\n\treturn fabs(a - b) < EPS;\n}\n// 点クラス\nstruct P {\n\tdouble x, y;\n\tP(double x_, double y_) { x = x_; y = y_; }\n\tP(){}\n\t// 加算, 減算, スカラー倍\n\tP operator+(const P& a) const {\n\t\treturn P(x + a.x, y + a.y);\n\t}\n\tP operator-(const P& a) const {\n\t\treturn P(x - a.x, y - a.y);\n\t}\n\tP operator*(const P& a) const {\n\t\treturn P(x * a.x - y * a.y, x * a.y + y * a.y);\n\t}\n\tP operator*(double c) const {\n\t\treturn P(x * c, y * c);\n\t}\n\tP operator/(const P& a) const {\n\t\tdouble norm = a.x * a.x + a.y * a.y;\n\t\tdouble x_ = (x * a.x + y * a.y) / norm;\n\t\tdouble y_ = (y * a.x - x * a.y) / norm;\n\t\treturn P(x_, y_);\n\t}\n\tP operator/(double c) const {\n\t\treturn P(x / c, y / c);\n\t}\n\tP& operator+=(const P& a) {\n\t\tx += a.x; y += a.y;\n\t}\n\tP& operator-=(const P& a) {\n\t\tx -= a.x; y -= a.y;\n\t}\n\tP& operator*=(const P& a) {\n\t\t*this = P(x * a.x - y * a.y, x * a.y + y * a.y);\n\t}\n\tP& operator*=(double c) {\n\t\t*this = P(x * c, y * c);\n\t}\n\tP& operator/=(const P& a) {\n\t\tdouble norm = a.x * a.x + a.y * a.y;\n\t\tdouble x_ = (x * a.x + y * a.y) / norm;\n\t\tdouble y_ = (y * a.x - x * a.y) / norm;\n\t\t*this = P(x_, y_);\n\t}\n\tP& operator/=(double c) {\n\t\t*this = P(x / c, y / c);\n\t}\n};\nP operator*(double c, P a){\n\treturn P(a.x * c, a.y * c);\n}\n// 比較演算子\nbool operator==(const P& a, const P& b) {\n\treturn equal(a.x, b.x) && equal(a.y, b.y);\n}\nbool operator!=(const P& a, const P& b) {\n\treturn !(a == b);\n}\nbool operator<(const P& a, const P& b) {\n\treturn (a.x != b.x)? a.x < b.x : a.y < b.y;\n}\n\n// 原点からの距離(絶対値)\ndouble abs(P a) {\n\treturn sqrt(a.x * a.x + a.y * a.y);\n}\n// 2点間の距離\ndouble dist(P a, P b) {\n\treturn abs(a - b);\n}\n// 内積 (dot product) : a・b = |a||b|cosΘ\ndouble dot(P a, P b) {\n\treturn a.x * b.x + a.y * b.y;\n}\n// 外積 (cross product) : a×b = |a||b|sinΘ\ndouble cross(P a, P b) {\n\treturn a.x * b.y - a.y * b.x;\n}\n\n// CCW : 反時計回り (Counter Clock Wise)\n// CW : 時計回り (Clock Wise)\nenum {CCW=1, CW=-1, ON=0};\n// * 3点がどちら回りであるか返す, 3点が1直線に乗っているときは ON を返す\nint ccw(const P &a, P b, P c) {\n\tb -= a, c -= a;\n\tif( cross(b,c) >  EPS ) return CCW; // CCW : 反時計回り\n\tif( cross(b,c) < -EPS ) return CW;  // CW : 時計回り\n\tif( dot(b, c)  < -EPS ) return +2;  // c--a--b on line\n\tif( dot(b, b)  + EPS < dot(c, c) ) return -2; // a--b--c on line \n\treturn ON;\n}\n\n// 入力\nint H, R, U, M, S;\ndouble du, dm, ds;\nint hx[100], hy[100], ux[100], uy[100];\nint mx[100], my[100], sx[100], sy[100];\ndouble w[100], a[100];\n\n// smell[k] := 家 k に梅の香りのみが届く日数\nint smell[100];\n\n// ラジアンから度数へ変換して返す\ndouble to_deg(double rad) {\n\treturn rad * 180.0 / PI;\n}\n// 度数からラジアンに変換して返す\ndouble to_rad(double deg) {\n\treturn deg * PI / 180.0;\n}\n\n// 扇に含まれるかどうか\nbool isInSector(P c, double a, double d, double r, P p){\n\tdouble dist = abs(c - p);\n\tif( dist > a ) return false;\n\t\n\tP p1 = P(a * cos(r + d/2.0), a * sin(r + d/2.0) );\n\tP p2 = P(a * cos(r - d/2.0), a * sin(r - d/2.0) );\n\t\n\tif( ccw(c, c + p1, p) == CW && ccw(c, c + p2, p) == CCW ){\n\t\treturn true;\n\t}\n\treturn false;\n}\n\nvoid solve(){\n\tfor(int h=0 ; h < H ; h++ ){\n\t\t// 家 j の座標\n\t\tP p = P(hx[h], hy[h]);\n\t\t\n\t\tfor(int d=0 ; d < R ; d++ ){\n\t\t\tbool flag = false;\n\t\t\t// 桃の香りが家 j に届くかどうかチェック\n\t\t\tfor(int k=0 ; k < M ; k++ ){\n\t\t\t\tP c = P(mx[k], my[k]);\n\t\t\t\tif( isInSector(c, a[d], dm, w[d], p) ){\n\t\t\t\t\tflag = true;\n\t\t\t\t\tbreak;\n\t\t\t\t}\n\t\t\t}\n\t\t\tif( flag ) break;\n\t\t\t\n\t\t\t// 桜の香りが家 j に届くかどうかチェック\n\t\t\tfor(int k=0 ; k < S ; k++ ){\n\t\t\t\tP c = P(sx[k], sy[k]);\n\t\t\t\tif( isInSector(c, a[d], ds, w[d], p) ){\n\t\t\t\t\tflag = true;\n\t\t\t\t\tbreak;\n\t\t\t\t}\n\t\t\t}\n\t\t\tif( flag ) break;\n\t\t\t\n\t\t\t// 梅の香りが届くかどうか\n\t\t\tfor(int k=0 ; k < U ; k++ ){\n\t\t\t\tP c = P(ux[k], uy[k]);\n\t\t\t\tif( isInSector(c, a[d], du, w[d], p) ){\n\t\t\t\t\tflag = true;\n\t\t\t\t\tbreak;\n\t\t\t\t}\n\t\t\t}\n\t\t\tif( flag ) break;\n\t\t\t\n\t\t\t// 自分の家の梅の香りが届くかどうか\n\t\t\tif( isInSector(P(0, 0), a[d], du, w[d], p) ){\n\t\t\t\tsmell[h]++;\n\t\t\t}\n\t\t}\n\t}\n\t\n\t// ソート\n\tvector<pair<int, int> > v;\n\tfor(int i=0 ; i < H ; i++ ){\n\t\tif( smell[i] != 0 ) v.push_back(pair<int, int>(-smell[i], i+1));\n\t}\n\tsort(v.begin(), v.end());\n\t\n\t// 出力\n\tif( v.size() == 0 ){\n\t\tcout << \"NA\" << endl;\n\t}else{\n\t\tfor(int i=0 ; i < v.size() ; i++ ){\n\t\t\tif( i && v[i].first != v[i-1].first ) break;\n\t\t\tif( i ) cout << \" \";\n\t\t\tcout << v[i].second;\n\t\t}\n\t\tcout << endl;\n\t}\n}\n\nint main(){\n\twhile( cin >> H >> R , H || R ){\n\t\t// 初期化\n\t\tfill(smell, smell + H, 0);\n\t\t\n\t\t// 入力\n\t\tfor(int i=0 ; i < H ; i++ ) cin >> hx[i] >> hy[i];\n\t\tcin >> U >> M >> S >> du >> dm >> ds;\n\t\tdu = to_rad(du), dm = to_rad(dm), ds = to_rad(ds);\n\t\tfor(int i=0 ; i < U ; i++ ) cin >> ux[i] >> uy[i];\n\t\tfor(int i=0 ; i < M ; i++ ) cin >> mx[i] >> my[i];\n\t\tfor(int i=0 ; i < S ; i++ ) cin >> sx[i] >> sy[i];\n\t\tfor(int i=0 ; i < R ; i++ ){\n\t\t\tcin >> w[i] >> a[i];\n\t\t\tw[i] = to_rad(w[i]);\n\t\t}\n\t\t\n\t\tsolve();\n\t}\n}"
  },
  {
    "language": "C++",
    "code": "#include <iostream>\n#include <string>\n#include <vector>\n#include <algorithm>\n#include <cmath>\n\n#define REP(i,k,n) for(int i=k;i<n;i++)\n#define rep(i,n) for(int i=0;i<n;i++)\n#define EPS 1e-8\n#define equals(a,b) fabs((a) - (b)) < EPS\n#define PI acos(-1)\n\nusing namespace std;\n\nstruct Point\n{\n    double x, y;\n\n    Point(double x=0, double y=0) : x(x), y(y) {}\n\n    Point operator+(const Point &o) const { return Point(x+o.x, y+o.y); }\n\n    Point operator-(const Point &o) const { return Point(x-o.x, y-o.y); }\n\n    Point operator*(const double m) const { return Point(x*m, y*m); }\n\n    Point operator/(const double d) const { return Point(x/d, y/d); }\n\n    Point operator<(const Point &o) const { return x != o.x ? x < o.x : y < o.y; }\n\n\tbool operator==(const Point &o) const { return fabs(x-o.x) < EPS && fabs(y-o.y) < EPS; }\n\n\tdouble cross(const Point &o) const { return x * o.y - y * o.x; }\n\n    double dot(const Point &o) const { return x * o.x + y * o.y; }\n\n    double atan() const { return atan2(y, x); }\n\n\tdouble deg() const { return atan() * 180.0 / (acos(-1) * 4.0); }\n\n    double norm() const { return sqrt(dot(*this)); }\n\n    double distance(const Point &o) const { return (o - (*this)).norm(); }\n\n    double area(const Point &a,const Point &b)\n    {\n\t    Point p = a - (*this), p2 = b - (*this); \n\t    return p.cross(p2);\n    }\n\n    double area_abs(const Point &a,const Point &b) const\n    {\n\t    Point p = a - (*this), p2 = b - (*this);\n\t    return fabs(p.cross(p2)) / 2.0;\n    }\t\n\n    //線分abが自身に含まれているのかどうか判断する\n    int between(const Point &a,const Point &b)\n\t{\n\t\tif(area(a,b) != 0) return 0;\n\n    \tif(a.x != b.x)\n\t    {\n\t\t    return ((a.x <= x) && (x <= b.x) || (a.x >= x) && (x >= b.x));\n\t    }\n\t    else\n\t    {\n\t    \treturn ((a.y <= y) && (y <= b.y) || (a.y >= y) && (y >= b.y));\n\t    }\n    }      \n\n\tdouble distance_seg(const Point& a,const Point& b)\n\t{\n    \tif((b-a).dot(*this-a) < EPS)\n    \t{\n\t    \treturn (*this-a).norm();\n\t    }\n\t    if((a-b).dot(*this-b) < EPS)\n    \t{\n\t    \treturn (*this-b).norm();\n    \t}\n\t    return abs((b-a).cross(*this-a)) / (b-a).norm();\n    }\n\n    bool hitPolygon(const Point& a,const Point& b,const Point& c)\n\t{\n    \tdouble t = (b-a).cross(*this-b);\n    \tdouble t2 = (c-b).cross(*this-c);\n    \tdouble t3 = (a-c).cross(*this-a);\n    \tif((t > 0 && t2 > 0 && t3 > 0) || ( t < 0 && t2 < 0 && t3 < 0))\n    \t{\n    \t\treturn true;\n    \t}\n\n\t    return false;\n    }\n};\n\nint ccw(Point a,Point b,Point c)\n{\n    b = b-a;\n    c = c-a;\n\n    if(b.cross(c) > EPS) return +1;\t//conter clockwise\n    if(b.cross(c) < -EPS) return -1;\t//clockwise\n    if(b.dot(c) < -EPS) return +2;\t//a on Seg(b,c)\n    if(b.norm() < c.norm()) return -2;\t//b on Seg(a,c)\n    return 0;\t//c on Seg(a,b)\n}\n\nbool inPolygon(Point p,Point a,Point b,Point c)\n{\n\tif(ccw(a,b,p) == -1 && ccw(a,c,p) == +1) return true;\n\n\treturn false;\n}\n\ndouble to_rad(double deg)\n{\n\treturn deg*PI/180;\n}\n\nbool hit(Point s,Point v,double d,double w,double a)\n{\n\tdouble x = a*cos(to_rad(w + d/2));\n\tdouble y = a*sin(to_rad(w + d/2));\n\tPoint p(x,y);\n\n\tx = a*cos(to_rad(w - d/2));\n\ty = a*sin(to_rad(w - d/2));\n\tPoint p2(x,y);\n\n\tif(inPolygon(v,s,s+p,s+p2)) return true;\n\treturn false;\n}\n\nint main()\n{\n\tint h,r;\n\twhile(cin >> h >> r)\n\t{\n\t\tif(h == 0 && r == 0) break;\n\n\t\tvector<Point> v;\n\t\trep(i,h)\n\t\t{\n\t\t\tdouble x,y;\n\t\t\tcin >> x >> y;\n\t\t\tv.push_back(Point(x,y));\n\t\t}\n\n\t\tint u,m,s;\n\t\tdouble du,dm,ds;\n\t\tcin >> u >> m >> s >> du >> dm >> ds;\n\n\t\tvector<Point> ume;\n\t\trep(i,u)\n\t\t{\n\t\t\tdouble x,y;\n\t\t\tcin >> x >> y;\n\t\t\tume.push_back(Point(x,y));\n\t\t}\n\t\t\n\t\tvector<Point> momo;\n\t\trep(i,m)\n\t\t{\n\t\t\tdouble x,y;\n\t\t\tcin >> x >> y;\n\t\t\tmomo.push_back(Point(x,y));\n\t\t}\n\n\t\tvector<Point> sakura;\n\t\trep(i,s)\n\t\t{\n\t\t\tdouble x,y;\n\t\t\tcin >> x >> y;\n\t\t\tsakura.push_back(Point(x,y));\n\t\t}\n\n\t\tvector<pair<int,int> > wind;\n\t\trep(i,r)\n\t\t{\n\t\t\tint w,a;\n\t\t\tcin >> w >> a;\n\t\t\twind.push_back(make_pair(w,a));\n\t\t}\n\n\t\tvector<pair<int,int> > ret;\n\t\tPoint S(0,0);\n\t\trep(i,h)\n\t\t{\n\t\t\tint cnt = 0;\n\t\t\tdouble d = v[i].distance(S);\n\t\t\t\n\t\t\trep(j,r)\n\t\t\t{\n\t\t\t\tif(d > wind[j].second) continue;\n\t\t\t\n\t\t\t\tif(hit(S,v[i],du,wind[j].first,wind[j].second)) cnt++;\n\t\t\t}\n\n\t\t\trep(j,r)\n\t\t\t{\n\t\t\t\tbool only = true;\n\n\t\t\t\trep(k,u)\n\t\t\t\t{\n\t\t\t\t\tdouble d = v[i].distance(ume[k]);\n\n\t\t\t\t\tif(d > wind[j].second) continue;\n\t\t\t\t\tif(hit(ume[k],v[i],du,wind[j].first,wind[j].second))\n\t\t\t\t\t{\n\t\t\t\t\t\tonly = false;\n\t\t\t\t\t}\n\t\t\t\t}\n\n\t\t\t\trep(k,m)\n\t\t\t\t{\n\t\t\t\t\tdouble d = v[i].distance(momo[k]);\n\n\t\t\t\t\tif(d > wind[j].second) continue;\n\t\t\t\t\tif(hit(momo[k],v[i],dm,wind[j].first,wind[j].second))\n\t\t\t\t\t{\n\t\t\t\t\t\tonly = false;\n\t\t\t\t\t}\n\t\t\t\t}\n\n\t\t\t\trep(k,s)\n\t\t\t\t{\n\t\t\t\t\tdouble d = v[i].distance(sakura[k]);\n\n\t\t\t\t\tif(d > wind[j].second) continue;\n\t\t\t\t\tif(hit(sakura[k],v[i],ds,wind[j].first,wind[j].second))\n\t\t\t\t\t{\n\t\t\t\t\t\tonly = false;\n\t\t\t\t\t}\n\t\t\t\t}\n\n\t\t\t\tif(!only) cnt--;\n\t\t\t}\n\n\t\t\tif(cnt > 0)\n\t\t\t{\n\t\t\t\tret.push_back(make_pair(cnt,i));\n\t\t\t}\n\t\t}\n\n\t\tif(ret.size() == 0) cout << \"NA\" << endl;\n\t\telse\n\t\t{\n\t\t\tsort(ret.begin(),ret.end());\n\t\t\t\n\t\t\tvector<int> ans;\n\t\t\trep(i,ret.size())\n\t\t\t{\n\t\t\t\tif(ret[i].first == ret[ret.size()-1].first)\n\t\t\t\t{\n\t\t\t\t\tans.push_back(ret[i].second);\n\t\t\t\t}\n\t\t\t}\n\n\t\t\tsort(ans.begin(),ans.end());\n\n\t\t\trep(i,ans.size())\n\t\t\t{\n\t\t\t\tcout << ans[i] + 1;\n\n\t\t\t\tif(i == ans.size()-1) cout << endl;\n\t\t\t\telse cout << \" \";\n\t\t\t}\n\t\t}\n\t}\n\n\treturn 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include <iostream>\n#include <vector> \n#include <cmath>\nusing namespace std;\n\n#define rep(i, n) for(int i = 0;i < n;i++)\n#define cin_pair(p) cin >> (p).first >> (p).second;\n\ntypedef pair<int, int> pos;\n\nbool isInSmell(int x, int y, int w, float d, int a, int cx, int cy) {\n    cx -= x; cy -= y;\n    x = y = 0;\n    int angle = atan2((double)cy, (double)cx) / M_PI * 180, lensq = cx * cx + cy * cy;\n    if(angle <= 0) angle += 360;\n    return (w - d / 2 <= angle && angle <= w + d / 2 && lensq <= a * a);\n}\n\nbool isInSmells(int w, float d, int a, vector<pos> &vec, int cx, int cy) {\n    //cout << vec.size();\n    rep(i, vec.size()) {\n        //cout << vec[i].first << ' ' << vec[i].second << endl;\n        if(isInSmell(vec[i].first, vec[i].second, w, d, a, cx, cy)) {\n            return true;\n        }\n    }\n}\n\nint main() {\n    int H, R;\n    int U, M, S, du, dm, ds;\n\n    while(true) {\n        cin >> H >> R;\n        if(!H && !R) break;\n\n        vector<pos> h(H);\n        rep(i, H) {\n            cin_pair(h[i]);\n        }\n        cin >> U >> M >> S >> du >> dm >> ds;\n        vector<pos> u(U), m(M), s(S), wa(R);\n        rep(i, U) {\n            cin_pair(u[i]);\n        }\n        rep(i, M) {\n            cin_pair(m[i]);\n        }\n        rep(i, S) {\n            cin_pair(s[i]);\n        }\n        rep(i, R) {\n            cin_pair(wa[i]);\n        }\n\n        vector<int> days(H, 0);\n        int maxa = -1;\n        rep(ri, R) {\n            rep(hi, H) {\n                int x = h[hi].first, y = h[hi].second;\n                int w = wa[ri].first, a = wa[ri].second;\n                if(\n                    !isInSmells(w, du, a, u, x, y) &&\n                    !isInSmells(w, dm, a, m, x, y) &&\n                    !isInSmells(w, ds, a, s, x, y) &&\n                    isInSmell(0, 0, w, du, a, x, y)\n                    ){\n                    days[hi]++;\n                    maxa = max(maxa, days[hi]);\n                }\n            }\n        }\n\n        //rep(i, days.size()) cout << days[i] << ' ';\n        //cout << endl;\n\n        int ansnum = 0;\n        rep(i, H) {\n            if(days[i] == maxa) ansnum++;\n        }\n        if(maxa == -1) {\n            cout << \"NA\" << endl;\n        }\n        else {\n            int j = 0;\n            rep(i, H) {\n                if(days[i] == maxa) {\n                    cout << i + 1;\n                    ansnum--;\n                    if(ansnum != 0) cout << ' ';\n                }\n            }\n            cout << endl;\n        }\n    }\n}"
  },
  {
    "language": "C++",
    "code": "#include<iostream>\n#include<complex>\n#include<vector>\n#include<algorithm>\n#include<cmath>\n#include<cstring>\n\n#define pb push_back\n#define sz size()\n#define rep(i,a) for(int i=0;i<(int)(a);i++)\n\nusing namespace std;\ntypedef long double D;\ntypedef complex<D> P;\nconst D EPS = 1e-5;\nconst D PI = acos(-1);\n\nD dot(P x,P y){return real(conj(x)*y);}\nD cross(P x,P y){return imag(conj(x)*y);}\nD arg(P a,P b,P c){\n  D res = acos(dot(b-a,c-a)/(abs(b-a)*abs(c-a))); \n  return (cross(b-a,c-a)<EPS)?2*PI-res:res;\n}\n\nint h,r,n[3];\nD d[3],tmp1,tmp2,seta;\nP hp[110],up[3][110];\nD w[110],a[110];\n\nint main(){\n  while(cin >> h >> r,h){\n    rep(i,h){\n      cin >> tmp1 >> tmp2;\n      hp[i] = P(tmp1,tmp2);\n    }\n\n    rep(i,3)cin >> n[i]; rep(i,3)cin >> d[i], d[i] *= PI/180/2;\n\n    rep(i,3)rep(j,n[i]){\n      cin >> tmp1 >> tmp2;\n      up[i][j] = P(tmp1,tmp2);\n    }\n\n    rep(i,r)cin >> w[i] >> a[i], w[i] *= PI/180;\n\n    int num[110];\n    memset(num,0,sizeof(num));\n\n    rep(x,r)rep(id,h){\n      int in = 0;\n      rep(i,3)rep(j,n[i]){\n\tif(abs(hp[id]-up[i][j]) < a[x] +EPS){\n\t  P tmp = P(up[i][j].real() + 100.0, up[i][j].imag());\n\t  seta = arg(up[i][j],tmp,hp[id]);\n\t  if(w[x]-d[i] < seta+EPS && seta < w[x]+d[i]+EPS)in++;\n\t}\n      }\n      if(in)continue;\n      \n      seta = arg(P(0,0),P(100,0),hp[id]);\n      if(abs(hp[id]) < a[x] + EPS && w[x]-d[0] < seta+EPS && seta < w[x]+d[0]+EPS)num[id]++;\n    }\n\n    int maxv = *max_element(num,num+h);\n    vector<int> ans;\n    if(maxv==0)cout << \"NA\\n\";\n    else{\n      rep(i,h){\n\tif(num[i] == maxv)ans.pb(i+1);\n      }\n      rep(i,ans.sz)cout << ans[i] << (i+1==ans.size()?\"\\n\":\" \");\n    }\n  }\n}"
  },
  {
    "language": "C++",
    "code": "#include<iostream>\n#include<vector>\n#include<math.h>\n#include<complex>\n\n#define EPS 1e-4\n\n#define PI 3.141592\n#define EQ(a,b) (abs((a)-(b))<EPS)\nusing namespace std;\n\ntypedef complex<double> P;\n\nvector<P> house;\nvector<P> ume,sak,mo;\n\ndouble cross(P v1,P v2){\n\treturn v1.real()*v2.imag()-v1.imag()*v2.real();\n}\n\nbool che(P h,P t,double d,double w,double a){\n\tP v=h-t;\n\tif(!(abs(v)<a))return false;\n\t\n\tP v1=P(a*cos((w+d/2)/180*PI),a*sin((w+d/2)/180*PI));\n\tP v2=P(a*cos((w-d/2)/180*PI),a*sin((w-d/2)/180*PI));\n\t\n\tif(cross(v1,v)<0 && cross(v2,v)>0)return true;\n\telse return false;\n}\n\nint main(){\n\tint h,r;\n\t\n\twhile(cin>>h>>r && h&&r){\n\t\thouse.clear();\n\t\tume.push_back(P(0,0));\n\t\tfor(int i=0;i<h;i++){\n\t\t\tint x,y;\n\t\t\tcin>>x>>y;\n\t\t\thouse.push_back(P(x,y));\n\t\t}\n\t\t\n\t\tint U,M,S,du,dm,ds;\n\t\tcin>>U>>M>>S>>du>>dm>>ds;\n\t\tfor(int i=0;i<U;i++){\n\t\t\tint x,y;\n\t\t\tcin>>x>>y;\n\t\t\tume.push_back(P(x,y));\n\t\t}\n\t\tfor(int i=0;i<M;i++){\n\t\t\tint x,y;\n\t\t\tcin>>x>>y;\n\t\t\tmo.push_back(P(x,y));\n\t\t}\n\t\tfor(int i=0;i<S;i++){\n\t\t\tint x,y;\n\t\t\tcin>>x>>y;\n\t\t\tsak.push_back(P(x,y));\n\t\t}\n\t\t\n\t\t\n\t\tint data[120];\n\t\tfor(int i=0;i<120;i++)data[i]=0;\n\t\tfor(int z=0;z<r;z++){\n\t\t\tint w,a;\n\t\t\tcin>>w>>a;\n\t\t\t\n\t\t\tfor(int i=0;i<house.size();i++){\n\t\t\t\tbool ok=false;\n\t\t\t\tif(che(house[i],ume[0],du,w,a))ok=true;\n\t\t\t\telse continue;\n\t\t\t\tfor(int j=1;j<=U;j++){\n\t\t\t\t\tif(che(house[i],ume[j],du,w,a))ok=false;\n\t\t\t\t}\n\t\t\t\tfor(int j=0;j<M;j++){\n\t\t\t\t\tif(che(house[i],mo[j],dm,w,a))ok=false;\n\t\t\t\t}\n\t\t\t\tfor(int j=0;j<S;j++){\n\t\t\t\t\tif(che(house[i],sak[j],ds,w,a))ok=false;\n\t\t\t\t}\n\t\t\t\t\n\t\t\t\tif(ok)data[i]++;\n\t\t\t}\n\t\t}\n\t\t\n\t\t\tint ans=0;\n\t\t\tint tmp=-1;\n\t\t\tfor(int i=0;i<h;i++){\n\t\t\t\tif(ans<=data[i]){\n\t\t\t\t\tans=data[i];\n\t\t\t\t\ttmp=i;\n\t\t\t\t}\n\t\t\t}\n\t\t\tif (ans==0)cout<<\"NA\"<<endl;\n\t\t\telse {\n\t\t\t\tfor(int i=0;i<h;i++){\n\t\t\t\t\tif(i==tmp)cout<<i+1;\n\t\t\t\t\telse if(data[i]==ans)cout<<i+1<<\" \";\n\t\t\t\t\t\n\t\t\t\t}\n\t\t\t\tcout<<endl;\n\t\t\t}\n\t\t\t\n\t\t\n\t}\n}"
  },
  {
    "language": "C++",
    "code": "#include<bits/stdc++.h>\nusing namespace std;\n\nstruct Tree{\n\tdouble x, y, d;\n\t\n\tTree(int xx, int yy, int dd){\n\t\tx = xx;\n\t\ty = yy;\n\t\td = dd;\n\t}\n\n\tbool isOK(double hx, double hy, double w, double a){\n\t\tdouble l = w - d/2;\n\t\tdouble r = w + d/2;\n\t\tl += 360 * 4;\n\t\tr += 360 * 4;\n\t\t\n\t\tdouble kaku = atan2((hy-y),(hx-x)) * 180/M_PI;\n\t\t\n\t\twhile(l > kaku){\n\t\t\tkaku += 360;\n\t\t}\n\t\t\n\t\tif(r < kaku){\n\t\t\treturn false;\n\t\t}\n\n\t\tif(a*a >= (hy-y)*(hy-y) + (hx-x) * (hx-x)){\n\t\t\treturn true;\n\t\t}\n\t\treturn false;\n\n\t}\n};\n\n\t\n\n\nint main(){\n\n\tint h, r;\n\twhile(cin >> h >> r, h != 0){\n\t\tint x[110], y[110];\n\t\tfor(int i = 0;i < h;i++) cin >> x[i] >> y[i];\n\n\t\tint U, M, S, du, dm, ds;\n\t\tcin >> U >> M >> S >> du >> dm >> ds;\n\n\t\tTree myTree(0, 0, du);\n\t\t\n\t\tvector<Tree> tree;\n\t\tfor(int i = 0;i < U;i++){\n\t\t\tint x, y;\n\t\t\tcin >> x >> y;\n\t\t\ttree.push_back(Tree(x, y, du));\n\t\t}\n\t\t\n\t\tfor(int i = 0;i < M;i++){\n\t\t\tint x, y;\n\t\t\tcin >> x >> y;\n\t\t\ttree.push_back(Tree(x, y, dm));\n\t\t}\n\n\n\t\tfor(int i = 0;i < S;i++){\n\t\t\tint x, y;\n\t\t\tcin >> x >> y;\n\t\t\ttree.push_back(Tree(x, y, ds));\n\t\t}\n\t\t\n\t\tint n = U + M + S;\n\n\t\tint cnt[110] = {};\n\t\t\n\t\tfor(int i = 0;i < r;i++){\n\t\t\tint w, a;\n\t\t\tcin >> w >> a\n;\t\t\tbool flag;\n\t\t\tfor(int j = 0;j < h;j++){\n\t\t\t\tflag = false;\n\t\t\t\tfor(int k = 0;k < n;k++){\n\t\t\t\t\tflag = (flag || tree[k].isOK(x[j], y[j], w, a));\n\t\t\t\t}\n\t\t\t\tif(!flag && myTree.isOK(x[j], y[j], w, a)){\n\t\t\t\t\tcnt[j]++;\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\n\t\tvector<int> ans;\n\t\tint ans_num = 0;\n\t\tfor(int i = 0;i < h;i++){\n\t\t\tif(ans_num < cnt[i]){\n\t\t\t\tans.clear();\n\t\t\t\tans_num = cnt[i];\n\t\t\t\tans.push_back(i+1);\n\t\t\t}else if(ans_num == cnt[i]){\n\t\t\t\tans.push_back(i+1);\n\t\t\t}\n\t\t}\n\n\t\tif(ans_num == 0){\n\t\t\tcout << \"NA\" << endl;\n\t\t}else{\n\t\t\tfor(int i = 0;i < ans.size();i++){\n\t\t\t\tcout << ans[i];\n\t\t\t\tif(i < ans.size()-1){\n\t\t\t\t\tcout << \" \";\n\t\t\t\t}else{\n\t\t\t\t\tcout << endl;\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t}\n\n\treturn 0;\n\n}\n\n"
  },
  {
    "language": "C++",
    "code": "#include <iostream>\n#include <algorithm>\n#include <vector>\n#include <queue>\n#include <map>\n#include <set>\n#include <cstdio>\n#include <cmath>\n#include <cstring>\n#include <string>\n#include <ctime>\n \n#define FOR(i,a,b) for(int i=(a);i<(b);i++)\n#define FFOR(i,a,b) for(int i=(a);i<=(b);i++)\n#define REP(i,b) FOR(i,0,b)\n#define RREP(i,b) FFOR(i,1,b)\n#define PB push_back\n#define F first\n//#define S second\n#define BE(c) c.begin(),c.end()\nusing namespace std;\ntypedef long long LL;\ntypedef LL ut;\ntypedef long double ld;\ntypedef pair<ut,ut> pr;\ntypedef vector<pr> Vpr;\ntypedef vector<ut> VI;\ntypedef pair<ut,pr> ppr;\ntypedef priority_queue<pr,Vpr, greater<pr> > PQ;\nconst int SIZE=1e+5 + 1;\nconst ut INF=1<<29;\nconst ld eps=1e-6;\nconst LL mod=1e+6 + 3;\n\nclass Point {\npublic:\n\tdouble x, y;\n\t\n\tPoint(double x = 0, double y = 0) : x(x), y(y) {}\n\t\n\tPoint operator + (const Point p) {\n\t\treturn Point(x + p.x, y + p.y);\n\t}\n\tPoint operator - (const Point p) {\n\t\treturn Point(x - p.x, y - p.y);\n\t}\n\tPoint operator * (const double a) {\n\t\treturn Point(x * a, y * a);\n\t}\n\tPoint operator / (const double a) {\n\t\treturn Point(x / a, y / a);\n\t}\n\t\n\tbool operator < (const Point& p) const {\n\t\treturn x != p.x ? x < p.x : y < p.y;\n\t}\n\tbool operator == (const Point& p) const {\n\t\treturn fabs(x - p.x) < eps && fabs(y - p.y) < eps;\n\t}\n\t\n\tdouble abs() {\n\t\treturn sqrt(norm());\n\t}\n\tdouble norm() {\n\t\treturn x * x + y * y;\n\t}\n\t\n};\n\ntypedef Point Vector;\n\ndouble dot(const Vector& a, const Vector& b){\n\treturn a.x * b.x + a.y * b.y;\t\n}\n\ndouble cross(const Vector& a, const Vector& b){\n\treturn a.x * b.y - a.y * b.x;\n}\n\n// p0: ?????????\n// p1, p2: ??????p0p1???p0p2??¨?????????\n// ???????¨???????: 1\n// ????¨???????:  -1\nint ccw(Point p0, Point p1, Point p2){\n\tVector a = p1 - p0;\n\tVector b = p2 - p0;\n\tif(cross(a, b) > eps) return 1;\n\tif(cross(a, b) < -eps) return -1;\n\tif(dot(a, b) < -eps) return 2;\n\tif(a.norm() < b.norm()) return -2;\n\t\n\treturn 0;\n}\n\ndouble rad = M_PI/180;\n\nint H, R, U, M, S, du, dm, ds;\nPoint h[128], u[128], m[128], s[128];\nint ans[128];\n\nbool check(Point home, Point tar, double range, double w, double a){\n\tif(Point(tar.x - home.x, tar.y - home.y).norm() > a * a)\n\t\treturn false;\n\n\tVector d = Vector(a * cos((w - range / 2.0)*rad), a * sin((w - range / 2.0)*rad));\n\tVector t = Vector(a * cos((w + range / 2.0)*rad), a * sin((w + range / 2.0)*rad));\n\tif(ccw(tar, tar + d, home) == 1 && ccw(tar, tar + t, home) == -1)\n\t\treturn true;\n\treturn false;\n}\n\nvoid query(double w, double a){\n\tREP(i,H){\n\t\tif(!check(h[i], Point(0, 0), du, w, a))\n\t\t\tcontinue;\n\t\tbool ok = true;\n\t\tREP(j,U){\n\t\t\tif(check(h[i], u[j], du, w, a)){\n\t\t\t\tok = false;\n\t\t\t\tbreak;\n\t\t\t}\n\t\t}\n\t\tif(!ok)\n\t\t\tcontinue;\n\t\t\n\t\tREP(j,M){\n\t\t\tif(check(h[i], m[j], dm, w, a)){\n\t\t\t\tok = false;\n\t\t\t\tbreak;\n\t\t\t}\n\t\t}\n\t\tif(!ok)\n\t\t\tcontinue;\n\n\t\tREP(j,S){\n\t\t\tif(check(h[i], s[j], ds, w, a)){\n\t\t\t\tok = false;\n\t\t\t\tbreak;\n\t\t\t}\n\t\t}\n\t\tif(ok)\n\t\t\tans[i]++;\n\t}\n}\n\nint main() {\n\twhile(cin >> H >> R && (H || R)){\n\t\tmemset(ans, 0, sizeof(ans));\n\t\tint x, y;\n\t\tREP(i,H){\n\t\t\tcin >> x >> y;\n\t\t\th[i] = Point(x, y);\n\t\t}\n\t\tcin >> U >> M >> S >> du >> dm >> ds;\n\t\tREP(i,U){\n\t\t\tcin >> x >> y;\n\t\t\tu[i] = Point(x, y);\n\t\t}\n\t\tREP(i,M){\n\t\t\tcin >> x >> y;\n\t\t\tm[i] = Point(x, y);\n\t\t}\n\t\tREP(i,S){\n\t\t\tcin >> x >> y;\n\t\t\ts[i] = Point(x, y);\n\t\t}\n\t\n\t\tdouble w, a;\n\t\tREP(i,R){\n\t\t\tcin >> w >> a;\n\t\t\tquery(w, a);\n\t\t}\n\t\tint maxim = 0;\n\t\tREP(i,H){\n\t\t\tmaxim = max(maxim, ans[i]);\n\t\t}\n\t\tif(maxim == 0){\n\t\t\tcout << \"NA\" << endl;\n\t\t\tcontinue;\n\t\t}\n\t\tvector<int> res;\n\t\tREP(i,H){\n\t\t\tif(ans[i] == maxim)\n\t\t\t\tres.PB(i + 1);\n\t\t}\n\t\tREP(i,res.size()){\n\t\t\tif(i)\n\t\t\t\tcout << \" \";\n\t\t\tcout << res[i];\n\t\t}\n\t\tcout << endl;\n\t}\n \treturn 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include <iostream>\n#include <cassert>\n#include <vector>\n#include <set>\n#include <queue>\n#include <algorithm>\n#include <cstdio>\n#include <cstring>\n#include <complex>\n#include <cmath>\n\nusing namespace std;\ntypedef long long ll;\n\ntypedef long double R;\ntypedef complex<R> P;\n\nnamespace std {\n    bool operator < (P a, P b) {\n        return real(a) != real(b) ? real(a) < real(b) : imag(a) < imag(b);\n    }\n    bool operator > (P a, P b) {\n        return (b < a);\n    }\n}\n\nconst R EPS = 1e-10;\nconst R PI = acos((R)(-1));\n\n/*\n -1 -> neg\n  0 -> near 0\n  1 -> pos\n  */\nint sgn(R a) {\n    if (a < -EPS) return -1;\n    if (a > EPS) return 1;\n    return 0;\n}\n\nint sgn(R a, R b) {\n    return sgn(b-a);\n}\n\nbool near(P a, P b) {\n    return !sgn(abs(a-b));\n}\n\nR cross(P a, P b) { return imag(conj(a)*b); }\nR dot(P a, P b) { return real(conj(a)*b); }\n\n\nR ssqrt(R d) {\n    d = max<R>(0, d);\n    return sqrt(d);\n}\n\nR sacos(R d) {\n    d = max<R>(-1, d);\n    d = min<R>(1, d);\n    return acos(d);\n}\n\nR deg2rad(R x) {\n    return x/180*PI;\n}\n\n//?§???????[0, 2*PI)???\nR radNorP(R x) {\n    return fmod(fmod(x, 2*PI) + 2*PI, 2*PI);\n}\n\n/**\n * radian??§???x???[l, r]?????\\??£????????????????????\\??????\n * 0:OFF\n * 1:IN\n * 2:ON\n */\nbool inR(R l, R r, R x) {\n    l = radNorP(l);\n    r = radNorP(r);\n    x = radNorP(x);\n    if (!sgn(l, x) || !sgn(r, x)) return 2;\n    if (!sgn(l, r)) return 0;\n    if (sgn(l, r) == 1) {\n        if (sgn(l, x) == 1 && sgn(x, r) == 1) return 1;\n    } else {\n        if (sgn(x, r) == 1 || sgn(l, x) == 1) return 1;\n    }\n    return 0;\n}\nstruct C {\n    P p;\n    R r;\n    C () {}\n    C (P p, R r) : p(p), r(r) {}\n};\nstruct Sec {\n    C c;\n    R l, r;\n    Sec() {}\n    Sec(C c, R l, R r) : c(c), l(l), r(r) {}\n};\n\nbool crossSecP(const Sec &s, const P &p) {\n    P pp = p - s.c.p;\n    if (sgn(s.c.r, abs(pp)) == 1) return false;\n    return inR(s.l, s.r, arg(pp)) > 0;\n}\n\nconst int MN = 200;\nint h, r, u, m, s;\nR du, dm, ds;\nP hp[MN];\nP up[MN], mp[MN], sp[MN];\nint res[MN];\n\nvoid calc(R w, R a) {\n    for (int i = 0; i < h; i++) {\n        if (!crossSecP(Sec(C(P(0, 0), a), w-du, w+du), hp[i])) continue;\n        bool f = true;\n        for (int j = 0; j < u; j++) {\n            if (crossSecP(Sec(C(up[j], a), w-du, w+du), hp[i])) f = false;\n        }\n        for (int j = 0; j < m; j++) {\n            if (crossSecP(Sec(C(mp[j], a), w-dm, w+dm), hp[i])) f = false;\n        }\n        for (int j = 0; j < s; j++) {\n            if (crossSecP(Sec(C(sp[j], a), w-ds, w+ds), hp[i])) f = false;\n        }\n        if (!f) continue;\n        res[i]++;\n    }\n}\n\nint main() {\n    while (true) {\n        cin >> h >> r;\n        if (!h && !r) break;\n        for (int i = 0; i < h; i++) {\n            R x, y;\n            cin >> x >> y;\n            hp[i] = P(x, y);\n        }\n        cin >> u >> m >> s >> du >> dm >> ds;\n        du /= 2; dm /= 2; ds /= 2;\n        du = deg2rad(du);\n        dm = deg2rad(dm);\n        ds = deg2rad(ds);\n        for (int i = 0; i < u; i++) {\n            R x, y;\n            cin >> x >> y;\n            up[i] = P(x, y);\n        }\n        for (int i = 0; i < m; i++) {\n            R x, y;\n            cin >> x >> y;\n            mp[i] = P(x, y);\n        }\n        for (int i = 0; i < s; i++) {\n            R x, y;\n            cin >> x >> y;\n            sp[i] = P(x, y);\n        }\n        memset(res, 0, sizeof(res));\n        for (int i = 0; i < r; i++) {\n            R x, y;\n            cin >> x >> y;\n            calc(deg2rad(x), y);\n        }\n        int ma = 0;\n        for (int i = 0; i < h; i++) {\n            ma = max(ma, res[i]);\n        }\n        if (ma == 0) {\n            cout << \"NA\" << endl;\n            continue;\n        }\n        vector<int> buf;\n        for (int i = 0; i < h; i++) {\n            if (res[i] == ma) buf.push_back(i);\n        }\n        for (int i = 0; i < (int)buf.size()-1; i++) {\n            cout << buf[i] << \" \";\n        }\n        cout << buf[buf.size()-1] << endl;\n    }\n    return 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include <iostream>\n#include <algorithm>\n#include <complex>\n#include <vector>\n#include <cmath>\nusing namespace std;\ntypedef complex<double> P;\n\nconst double PI = acos(-1);\nconst double EPS = 1e-9;\nbool hit(P p,double a,double b,double r){\n\tif( abs(p) > r + EPS ) return false;\n\tdouble deg = atan2(p.imag(),p.real());\n\tif( a <= deg && deg <= b ) return true;\n\tif( a <= deg+2*PI && deg+2*PI <= b ) return true;\n\tif( a <= deg-2*PI && deg-2*PI <= b ) return true;\n\treturn false;\n}\nint main(){\n\tint H,R;\n\twhile(cin >> H >> R && H){\n\t\tP home[100];\n\t\tfor(int i = 0 ; i < H ; i++) cin >> home[i].real() >> home[i].imag();\n\t\tint U,M,S;\n\t\tdouble du,dm,ds;\n\t\tcin >> U >> M >> S >> du >> dm >> ds;\n\t\tdu = du / 180.*PI;\n\t\tdm = dm / 180.*PI;\n\t\tds = ds / 180.*PI;\n\t\tdu /= 2;\n\t\tdm /= 2;\n\t\tds /= 2;\n\t\tvector< pair<P,double> > flower;\n\t\tfor(int i = 0 ; i < U+M+S ; i++){\t\n\t\t\tP p; cin >> p.real() >> p.imag();\n\t\t\tflower.push_back(make_pair(p,(i<U?du:i<U+M?dm:ds)));\n\t\t}\n\t\tint answer[110] = {};\n\t\tfor(int i = 0 ; i < R ; i++){\n\t\t\tdouble w,r;\n\t\t\tcin >> w >> r;\n\t\t\tw = w / 180. * PI;\n\t\t\tfor(int j = 0 ; j < H ; j++){\n\t\t\t\tint ok = hit(home[j],w-du,w+du,r);\n\t\t\t\t//cout << w-du << \" \" << w+du << endl;\n\t\t\t\tfor(int k = 0 ; k < U+M+S ; k++){\n\t\t\t\t\tok &= !hit(home[j]-flower[k].first,w-flower[k].second,w+flower[k].second,r);\n\t\t\t\t}\n\t\t\t\tanswer[j] += ok;\n\t\t\t}\n\t\t}\n\t\tint maximum = *max_element(answer,answer+H);\n\t\tint fst = 1;\n\t\tif( maximum == 0 ){ cout << \"NA\" << endl; goto exit; }\n\n\t\tfor(int i = 0 ; i < H ; i++)\n\t\t\tif( maximum == answer[i] ){\n\t\t\t\tif( fst == 0 ) cout << \" \";\n\t\t\t\tcout << i+1;\n\t\t\t\tfst = 0;\n\t\t\t}\n\t\tcout << endl;\n\t\texit:;\n\t}\n\t\n\t\n\t\n\t\n}"
  },
  {
    "language": "C++",
    "code": "#include<iostream>\n#include<vector>\n#include<cmath>\n#include<algorithm>\n#include<numeric>\nusing namespace std;\n\nconst double PI = 3.14159265358979;\nconst double EPS = 1e-9;\n\nclass Point {\npublic:\n    double x, y;\n    Point(double x = 0.0, double y = 0.0) :x(x), y(y) {}\n};\n\nclass Wind {\npublic:\n    double w, a;\n};\n\nbool include(double angle, double low, double high) {\n    if(low < 0 + EPS) {\n        double l = low + 2.0 * PI;\n        if(l <= angle + EPS) return true;\n    }\n    if(high > 2.0 * PI + EPS) {\n        double h = high - 2.0 * PI;\n        if(angle <= h + EPS) return true;\n    }\n    return low <= angle + EPS && angle <= high + EPS;\n}\n\nbool savor(const Point &home, const Wind &wind, const vector<Point> &blossom, double d) {\n//     cout << \"home: \" << home.x << \", \" << home.y << endl;\n//     cout << \"blossom\" << endl; for(const auto &i: blossom) cout << \"  \" << i.x << \",\" << i.y; cout << endl;\n//     cout << \"d: \" << d << endl;\n//     cout << \"wind: \" << wind.w << \", \" << wind.a << endl;\n//     cout << endl;\n    d /= 2.0;\n    for(const auto &b: blossom) {\n        Point dif(home.x - b.x, home.y - b.y);\n        double angle = atan2(dif.y, dif.x);\n        double dist = hypot(dif.y, dif.x);\n        if(angle < 0) angle = 2 * PI + angle;\n//         cout<<\"angle: \"<<angle<<endl;\n//         cout<<\"wind.w +- d: \"<<wind.w - d<<\" - \"<<wind.w + d<<endl;\n//         cout<<\"dist: \"<<dist<<endl;\n        if(dist <= wind.a + EPS && include(angle, wind.w - d, wind.w + d)) return true;\n    }\n    return false;\n}\n\ndouble toRadian(double d) {\n    return d * PI / 180.0;\n}\n\nint main() {\n    int H, R;\n    while(cin >> H >> R, H | R) {\n        vector<Point> home(H);\n        for(auto &i: home) cin >> i.x >> i.y;\n\n        int U, M, S;\n        double du, dm, ds;\n        cin >> U >> M >> S >> du >> dm >> ds;\n\n        du = toRadian(du);\n        dm = toRadian(dm);\n        ds = toRadian(ds);\n\n        vector<Point> plum(U), peach(M), cherry(S);\n        for(auto &i: plum) cin >> i.x >> i.y;\n        for(auto &i: peach) cin >> i.x >> i.y;\n        for(auto &i: cherry) cin >> i.x >> i.y;\n\n        vector<Wind> wind(R);\n        for(auto &i: wind) cin >> i.w >> i.a;\n        for(auto &i: wind) i.w = toRadian(i.w);\n\n        // test\n//         cout << savor(home[5], wind[0], peach, dm) << endl;\n//         return 0;\n\n        // solve\n        vector<int> number(H, 0);\n        int maxNumber = 0;\n\n        for(int i = 0; i < H; ++i) {\n            for(int day = 0; day < R; ++day) {\n                bool ok = savor(home[i], wind[day], {Point(0.0, 0.0)}, du);\n                bool ng = false;\n                ng |= savor(home[i], wind[day], plum, du);\n                ng |= savor(home[i], wind[day], peach, dm);\n                ng |= savor(home[i], wind[day], cherry, ds);\n\n//                 cout<<\"day\"<<day<<endl;\n//                 cout<<savor(home[i], wind[day], plum, du)<<\" \"<<savor(home[i], wind[day], peach, du)<<\" \"<<savor(home[i], wind[day], cherry, du)<<endl;\n\n                if(!ok || ng) continue;\n\n                ++number[i];\n                maxNumber = max(maxNumber, number[i]);\n            }\n        }\n\n//         for(const auto &i: number) cout<<\" \"<<i;cout<<endl;\n\n        if(maxNumber) {\n            bool first = true;\n            for(int i = 0; i < H; ++i) if(number[i] == maxNumber) {\n                if(!first) cout << \" \";\n                first = false;\n                cout << i + 1;\n            }\n            cout << endl;\n        } else {\n            cout << \"NA\" << endl;\n        }\n\n//         return 0;\n    }\n}"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\nusing namespace std;\n\n#define EPS (1e-8)\n#define equals(a, b) (fabs((a) - (b)) < EPS )\n#define dle(a, b) (equals(a, b) || a < b )\n#define LIM 0.001\n\nstatic const double PI = acos(-1);\n\nclass Point{\n    public:\n    double x, y;\n\n    Point ( double x = 0, double y = 0): x(x), y(y){}\n\n    Point operator + ( Point p ){ return Point(x + p.x, y + p.y); }\n    Point operator - ( Point p ){ return Point(x - p.x, y - p.y); }\n    Point operator * ( double a ){ return Point(x*a, y*a); }\n    Point operator / ( double a ){ return Point(x/a, y/a); }\n\n    double abs() { return sqrt(norm());}\n    double norm() { return x*x + y*y; }\n\n    bool operator < ( const Point &p ) const {\n    return x != p.x ? x < p.x : y < p.y;\n    }\n\n    bool operator == ( const Point &p ) const {\n    return fabs(x-p.x) < EPS && fabs(y-p.y) < EPS;\n    }\n};\n\ntypedef Point Vector;\n\nclass Segment{\n    public:\n    Point p1, p2;\n    Segment(Point s = Point(), Point t = Point()): p1(s), p2(t){}\n};\n\ntypedef Segment Line;\n\ndouble norm( Vector a ){ return a.x*a.x + a.y*a.y; }\ndouble abs( Vector a ){ return sqrt(norm(a)); }\nPoint polar( double a, double r ){ return Point(cos(r)*a, sin(r)*a);}\ndouble getDistance( Vector a, Vector b ){ return abs(a - b); }\ndouble dot( Vector a, Vector b ){ return a.x*b.x + a.y*b.y; }\ndouble cross( Vector a, Vector b ){ return a.x*b.y - a.y*b.x; }\n\nstatic const int COUNTER_CLOCKWISE = 1;\nstatic const int CLOCKWISE = -1;\nstatic const int ONLINE_BACK = 2;\nstatic const int ONLINE_FRONT = -2;\nstatic const int ON_SEGMENT = 0;\n\n// EPS can be 0\n// need to check for 920, 833, 866\nint ccw( Point p0, Point p1, Point p2 ){\n    Vector a = p1 - p0;\n    Vector b = p2 - p0;\n    if ( cross(a, b) > EPS ) return COUNTER_CLOCKWISE;\n    if ( cross(a, b) < -EPS ) return CLOCKWISE;\n    if ( dot(a, b) < -EPS ) return ONLINE_BACK;\n    if ( norm(a) < norm(b) ) return ONLINE_FRONT;\n    return ON_SEGMENT;\n}\n\ndouble getDistance(Segment s, Point p){\n    if ( dot(s.p2 - s.p1, p - s.p1) < 0.0 ) return abs(p - s.p1);\n    if ( dot(s.p1 - s.p2, p - s.p2) < 0.0 ) return abs(p - s.p2);\n    return abs(cross(s.p2 - s.p1, p - s.p1)/abs(s.p2 - s.p1));\n}\ndouble getDistance(Segment s1, Segment s2){\n    if ( isIntersect(s1, s2) ) return 0.0;\n    return min( min(getDistance(s1, s2.p1), getDistance(s1, s2.p2)),\n        min(getDistance(s2, s1.p1), getDistance(s2, s1.p2)));\n}\n\ndouble arg(Vector p){\n    return atan2(p.y, p.x);\n}\n\nbool isInSector(Point c, double a, double d, double r, Point p ){\n  double dist = abs(c - p);\n  if ( dist <= 0.001 ){\n    cout << p.x << \", \" << p.y << endl;\n  }\n\n  if ( dist > a ) return false;\n  Vector v1 = Vector(a*cos((r + d/2)*PI/180), a*sin((r + d/2)*PI/180));\n  Vector v2 = Vector(a*cos((r - d/2)*PI/180), a*sin((r - d/2)*PI/180));\n\n  double ldist1 = getDistance(Segment(c, c+v1), p);\n  double ldist2 = getDistance(Segment(c, c+v2), p);\n\n  if ( ccw(c, c+v1, p) == CLOCKWISE &&\n       ccw(c, c+v2, p) == COUNTER_CLOCKWISE ) return true;\n  return false;\n}\n\nint main(){\n  int h, r, C[3];\n  double D[3], x, y, w, a;\n  Point O[3][100];\n  Point H[100];\n  int P[100];\n\n  while(1){\n    cin >> h >> r;\n    if ( h == 0 && r == 0 ) break;\n\n    for ( int i = 0; i < h; i++ ) P[i] = 0;\n    for ( int i = 0; i < h; i++ ) cin >> H[i].x >> H[i].y;\n    cin >> C[0] >> C[1] >> C[2] >> D[0] >> D[1] >> D[2];\n\n    for ( int i = 0; i < 3; i++ ){\n      for ( int j = 0; j < C[i]; j++ ){\n    cin >> O[i][j].x >> O[i][j].y ;\n      }\n    }\n\n    for ( int i = 0; i < r; i++ ){\n      cin >> w >> a;\n      for ( int b = 0; b < h; b++ ){\n    Point target = H[b];\n    bool coveredByOther = false;\n    bool coveredByMe = isInSector(Point(0, 0), a, D[0], w, target);\n    for ( int k = 0; k < 3; k++ ){\n      for ( int l = 0; l < C[k]; l++ ){\n        if ( isInSector(O[k][l], a, D[k], w, target)) coveredByOther = true;\n      }\n    }\n    if (!coveredByOther && coveredByMe ) P[b]++;\n      }\n    }\n    int maxv = 0;\n    for ( int i = 0; i < h; i++ ) {\n      maxv = max(maxv, P[i]);\n    }\n    if ( maxv == 0 ) cout << \"NA\" << endl;\n    else {\n      bool f = true;\n      for ( int i = 0; i < h; i++ ){\n    if ( maxv == P[i] ) {\n      if ( !f) cout << \" \";\n      cout << i+1;\n      f = false;\n    }\n      }\n      cout << endl;\n    }\n\n\n  }\n}"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\nusing namespace std;\n\ntypedef long long ll;\n#define rep(i,n) for(int (i)=0;(i)<(int)(n);++(i))\n#define each(itr,c) for(__typeof(c.begin()) itr=c.begin(); itr!=c.end(); ++itr)\n#define all(x) (x).begin(),(x).end()\n#define pb push_back\n#define fi first\n#define se second\n\ninline int dist2(int ax, int ay, int bx, int by)\n{\n    return (ax-bx)*(ax-bx)+(ay-by)*(ay-by);\n}\n\nbool reach(int hx, int hy, int tx, int ty, int d, int w, int a)\n{\n    // ?????¢?????§??????\n    if(dist2(hx,hy,tx,ty)>a*a) return false;\n\n    // ?§?????????§??????\n    const double PI=acos(-1);\n    double theta = atan2(hy-ty,hx-tx);\n    double rad_w=w*PI/180, rad_d=d*PI/180;\n    double l=rad_w-rad_d/2, r=rad_w+rad_d/2;\n\n    bool ret=false;\n    for(int i=-1; i<=1; ++i)\n    {\n        if(l<=theta+i*2*PI && theta+i*2*PI<=r) ret=true;\n    }\n    return ret;\n}\n\nint main()\n{\n    int H,R;\n    while(scanf(\" %d %d\", &H, &R),H)\n    {\n        // input\n        vector<int> hx(H),hy(H);\n        rep(i,H) scanf(\" %d %d\", &hx[i], &hy[i]);\n\n        int num[3],d[3];\n        rep(i,3) scanf(\" %d\", &num[i]);\n        rep(i,3) scanf(\" %d\", &d[i]);\n\n        vector<int> tx[3],ty[3];\n        rep(i,3)\n        {\n            tx[i] = vector<int>(num[i]);\n            ty[i] = vector<int>(num[i]);\n            rep(j,num[i]) scanf(\" %d %d\", &tx[i][j], &ty[i][j]);\n        }\n\n        vector<int> w(R), a(R);\n        rep(i,R) scanf(\" %d %d\", &w[i], &a[i]);\n\n        // solve\n        vector<int> ct(H,0);\n        rep(i,R)rep(j,H)\n        {\n            if(!reach(hx[j],hy[j],0,0,d[0],w[i],a[i])) continue;\n\n            bool other=false;\n            rep(k,3)rep(l,num[k]) if(reach(hx[j],hy[j],tx[k][l],ty[k][l],d[k],w[i],a[i])) other=true;\n\n            if(!other) ++ct[j];\n        }\n\n        // output\n        int max_ct=0;\n        rep(i,H) max_ct=max(max_ct,ct[i]);\n\n        if(max_ct==0) printf(\"NA\\n\");\n        else\n        {\n            vector<int> ans;\n            rep(i,H) if(max_ct == ct[i]) ans.pb(i);\n\n            rep(i,ans.size())\n            {\n                if(i) printf(\" \");\n                printf(\"%d\", ans[i]+1);\n            }\n            printf(\"\\n\");\n        }\n    }\n    return 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include <iostream>\n#include <cstdio>\n#include <iomanip>\n#include <vector>\n#include <map>\n#include <set>\n#include <queue>\n#include <bitset>\n#include <stack>\n#include <utility>\n#include <numeric>\n#include <algorithm>\n#include <functional>\n#include <cctype>\n#include <complex>\n#include <string>\n#include <sstream>\n#include <fstream>\n#include <cassert>\nusing namespace std;\n\n//common\ntypedef long long i64,ll;\n\n#define BR \"\\n\"\n#define ALL(c) (c).begin(),(c).end()\n#define REP(i,n) for(int i=0;i<(int)(n);++i)\n#define FOR(i,l,r) for(int i=(l);i<(int)(r);++i)\n#define EACH(it,o) for(auto it = (o).begin(); it != (o).end(); ++it)\n#define IN(l,v,r) ((l)<=(v) && (v)<(r))\n\n//debug\n#ifdef NDEBUG\n#define DUMP(x)\n#define DUMPLN(x)\n#define DEBUG(x)\n#define DEBUGLN(x)\n#define LINE()\n#define LINELN()\n#define CHECK(exp,act)\n#define STOP(e)\n#else\n#define DUMP(x)  cerr << #x << \" = \" << (x)\n#define DUMPLN(x)  DUMP(x) <<endl\n#define DEBUG(x) DUMP(x) << LINE() << \" \" << __FILE__\n#define DEBUGLN(x) DEBUG(x)<<endl\n#define LINE()    cerr<< \" (L\" << __LINE__ << \")\"\n#define LINELN()    LINE()<<endl\n#define CHECK(exp,act)  if(exp!=act){DUMPLN(exp);DEBUGLN(act);}\n#define STOP(e)  CHECK(e,true);if(!(e)) exit(1);\n#endif\n\ntemplate<class T> inline string toString(const vector<T>& x) {\n\tstringstream ss;\n\tREP(i,x.size()){\n\t\tif(i!=0)ss<<\" \";\n\t\tss<< x[i];\n\t}\n\treturn ss.str();\n}\n\ntemplate<class T> inline string toString(const vector<vector<T> >& map) {\n\tstringstream ss;\n\tREP(i,map.size()){\n\t\tif(i!=0)ss<<BR;\n\t\tss<< toString(map[i]);\n\t}\n\treturn ss.str();\n}\ntemplate<class K,class V>  string toString(map<K,V>& x) {\n\tstring res;stringstream ss;\n\tfor(auto& p:x)ss<< p.first<<\":\" << p.second<<\" \";\n\treturn ss.str();\n}\n\nstring BITtoString(int bit){\n    stringstream ss;\n    while(bit!=0){ss<<(bit%2);bit/=2;}\n    string res=ss.str();reverse(ALL(res));\n    return res;\n}\n\ntemplate<typename T,typename V> inline T pmod(T v,V MOD){\n\treturn (v%MOD+MOD)%MOD;\n}\ndouble pfmod(double v,double MOD){\n\treturn fmod(fmod(v,MOD)+MOD,MOD);\n}\n\nclass Comp{\npublic:\n\tbool operator () (const pair<int,int>& l,const pair<int,int>& r){\n\t\tif(l.first!=r.first)return l.first>r.first;\n\t\treturn l.second<r.second;\n\t}\n};\n\nnamespace Ps{\n\tconst double EPS = 1e-8;\n\tconst double INF = 1e12;\n\n\ttypedef complex<double> P;\n\t#define X(a) (real(a))\n\t#define Y(a) (imag(a))\n\t\n\t// a×b\n\tdouble cross(const P& a,const P& b){\n\t\treturn imag(conj(a)*b);\n\t}\n\t// a・b\n\tdouble dot(const P&a,const P& b) {\n\t\treturn real(conj(a)*b);\n\t}\n\n\t int ccw(const P& a,P b,P c){\n\t\tb -= a; c -= a;\n\t\t  if (cross(b,c) > 0)   return +1;       // counter clockwise\n\t\t  if (cross(b,c) < 0)   return -1;       // clockwise\n\t\t  if (dot(b,c) < 0)     return +2;       // c--a--b on line\n\t\t  if (norm(b) < norm(c)) return -2;       // a--b--c on line\n\t\t  return 0;\n\t  }\n}\nusing namespace Ps;\n\ndouble Abs(double a){double ret=pfmod(max(a,-a),2*M_PI);if(ret>M_PI)ret=2*M_PI-ret;return ret;}\n\nclass Main{\npublic:\n\tbool canReach(int x,int y,int w,int a,int d){\n\t\tif((ll)x*x+(ll)y*y<=(ll)a*a){\n\t\t\tif(Abs(w*M_PI/180-atan2(y,x))<=d*M_PI/180/2)return true;\n\t\t}\n\t\treturn false;\n\t}\n\n\tvoid run(){\n\n\t\twhile(true){\n\t\t\tint H,R;scanf(\"%d%d\",&H,&R);if(H==0)break;\n\n\t\t\tvector<int> xs(H),ys(H);\n\t\t\tREP(h,H)scanf(\"%d%d\",&xs[h],&ys[h]);\n\t\t\tint U,M,S,du,dm,ds;scanf(\"%d%d%d%d%d%d\",&U,&M,&S,&du,&dm,&ds);\n\n\t\t\tvector<int> uxs(U),uys(U);vector<int> mxs(M),mys(M);vector<int> sxs(S),sys(S);\n\t\t\tREP(i,U)scanf(\"%d%d\",&uxs[i],&uys[i]);\n\t\t\tREP(i,M)scanf(\"%d%d\",&mxs[i],&mys[i]);\n\t\t\tREP(i,S)scanf(\"%d%d\",&sxs[i],&sys[i]);\n\t\t\t\n\t\t\tvector<int> ws(R),as(R);\n\t\t\tREP(i,R)scanf(\"%d%d\",&ws[i],&as[i]);\n\n\n\t\t\tvector<pair<int,int>> res;\n\t\t\tREP(h,H){\n\t\t\t\tint x=xs[h],y=ys[h];\n\n\t\t\t\tint okc=0;\n\t\t\t\tREP(r,R){\n\t\t\t\t\tint w=ws[r],a=as[r];\n\t\t\t\t\tbool ok=false;\n\t\t\t\t\tif(canReach(x,y,w,a,du))ok=true;\n\t\t\t\t\tREP(i,U)if(canReach(x-uxs[i],y-uys[i],w,a,du))ok=false;\n\t\t\t\t\tREP(i,M)if(canReach(x-mxs[i],y-mys[i],w,a,dm))ok=false;\n\t\t\t\t\tREP(i,S)if(canReach(x-sxs[i],y-sys[i],w,a,ds))ok=false;\n\t\t\t\t\tif(ok)okc++;\n\t\t\t\t}\n\t\t\t\tres.push_back(make_pair(okc,h+1));\n\t\t\t}\n\t\t\tsort(ALL(res),Comp());\n\n\t\t\tint Mh=res[0].first;\n\t\t\t\n\t\t\tif(Mh==0){\n\t\t\t\tcout<<\"NA\"<<endl;continue;\n\t\t\t}\n\n\t\t\tfor(int i=0;i<H && Mh==res[i].first;i++){\n\t\t\t\tif(i!=0)cout <<\" \";\n\t\t\t\tcout << res[i].second; \n\t\t\t}\n\t\t\tcout <<endl;\n\t\t}\n\t}\n};\n\n int main(){\n\t//ios::sync_with_stdio(false);\n \tMain().run();\n \treturn 0;\n }"
  },
  {
    "language": "C++",
    "code": "#include \"bits/stdc++.h\"\n#include<unordered_map>\n#include<unordered_set>\n#pragma warning(disable:4996)\nusing namespace std;\nusing ld = long double;\ntemplate<class T>\nusing Table = vector<vector<T>>;\nconst ld eps=1e-9;\n\n/* ??????????????¬ */\n\n#include <complex>\n\ntypedef long double ld;\ntypedef complex<ld> Point;\n#define REP(i,n) for(int i=0;i<(int)(n);i++)\n#define ALL(x) (x).begin(),(x).end()\n\n\nconst ld pi = acos(-1.0);\nconst ld dtop = pi / 180.;\nconst ld ptod = 1. / dtop;\n\nnamespace std {\n\tbool operator<(const Point &lhs, const Point &rhs) {\n\t\tif (lhs.real() < rhs.real() - eps) return true;\n\t\tif (lhs.real() > rhs.real() + eps) return false;\n\t\treturn lhs.imag() < rhs.imag();\n\t}\n}\n\n// ????????\\???\nPoint input_point() {\n\tld x, y;\n\tcin >> x >> y;\n\treturn Point(x, y);\n}\n\n// ????????????????????????\nbool eq(const ld a, const ld b) {\n\treturn (abs(a - b) < eps);\n}\n\n// ??????\nld dot(const Point& a, const Point& b) {\n\treturn real(conj(a) * b);\n}\n\n// ??????\nld cross(const Point& a, const Point& b) {\n\treturn imag(conj(a) * b);\n}\n\n// ??´????????????\nclass Line {\npublic:\n\tPoint a, b;\n\tLine() : a(Point(0, 0)), b(Point(0, 0)) {}\n\tLine(Point a, Point b) : a(a), b(b) {}\n\tPoint operator[](const int _num)const {\n\t\tif (_num == 0)return a;\n\t\telse if (_num == 1)return b;\n\t\telse {\n\t\t\tassert(false);\n\t\t\treturn Point();\n\t\t}\n\t}\n};\n\n// ????????????\nclass Circle {\npublic:\n\tPoint p;\n\tld r;\n\tCircle() : p(Point(0, 0)), r(0) {}\n\tCircle(Point p, ld r) : p(p), r(r) {}\n};\n\n// CCW\nint ccw(const Point& a, const Point &b, const Point &c) {\n\tconst Point nb(b - a);\n\tconst Point nc(c - a);\n\tif (cross(nb, nc) > eps) return 1;   // a,b,c??????????¨???¨?????????????????¶\n\tif (cross(nb, nc) < -eps) return -1; // a,b,c???????¨???¨?????????????????¶\n\tif (dot(nb, nc) < 0) return 2;       // c,a,b???????????´???????????¶\n\tif (norm(nb) < norm(nc)) return -2;  // a,b,c???????????´???????????¶\n\treturn 0;                          // a,c,b???????????´???????????¶\n}\n\n\n/* ???????????? */\n\n// ??´?????¨??´??????????????????\nbool isis_ll(const Line& l, const Line& m) {\n\treturn !eq(cross(l.b - l.a, m.b - m.a), 0);\n}\n\n// ??´?????¨?????????????????????\nbool isis_ls(const Line& l, const Line& s) {\n\treturn isis_ll(l, s) &&\n\t\t(cross(l.b - l.a, s.a - l.a) * cross(l.b - l.a, s.b - l.a) < eps);\n}\n\n// ????????¨?????????????????????\nbool isis_ss(const Line& s, const Line& t) {\n\treturn ccw(s.a, s.b, t.a) * ccw(s.a, s.b, t.b) <= 0 &&\n\t\tccw(t.a, t.b, s.a) * ccw(t.a, t.b, s.b) <= 0;\n}\n\n// ????????´????????????\nbool isis_lp(const Line& l, const Point& p) {\n\treturn (abs(cross(l.b - p, l.a - p)) < eps);\n}\n\n// ?????????????????????\nbool isis_sp(const Line& s, const Point& p) {\n\treturn (abs(s.a - p) + abs(s.b - p) - abs(s.b - s.a) < eps);\n}\n\n// ??????????¶?\nPoint proj(const Line &l, const Point& p) {\n\tld t = dot(p - l.a, l.a - l.b) / norm(l.a - l.b);\n\treturn l.a + t * (l.a - l.b);\n}\n\n// ??´?????¨??´????????????\nPoint is_ll(const Line &s, const Line& t) {\n\tPoint sv = s.b - s.a, tv = t.b - t.a;\n\tassert(cross(sv, tv) != 0);\n\treturn s.a + sv * cross(tv, t.a - s.a) / cross(tv, sv);\n}\n// ??´?????¨??´????????????\nvector<Point> is_ll2(const Line &s, const Line& t) {\n\tPoint sv = s.b - s.a, tv = t.b - t.a;\n\tif (cross(sv, tv) != 0)return vector<Point>(1, is_ll(s, t));\n\telse {\n\t\tvector<Point>ans;\n\t\tfor (int k = 0; k < 2; ++k) {\n\t\t\tif (isis_sp(s, t[k]) && find(ans.begin(), ans.end(), t[k]) == ans.end())ans.push_back(t[k]);\n\t\t\tif (isis_sp(t, s[k]) && find(ans.begin(), ans.end(), s[k]) == ans.end())ans.push_back(s[k]);\n\t\t}\n\t\treturn ans;\n\t}\n}\n// ????????¨???????????????\n//???????????£????????¨???????????¨assert(false)\nPoint is_ss(const Line &s, const Line& t) {\n\tif (isis_ss(s, t)) {\n\t\tfor (int k = 0; k < 2; ++k) {\n\t\t\tfor (int l = 0; l < 2; ++l) {\n\t\t\t\tif (s[k] == t[l])return s[k];\n\t\t\t}\n\t\t}\n\t\treturn is_ll(s, t);\n\t}\n\telse {\n\t\t//??????isis_ss?????????\n\t\tassert(false);\n\t\treturn Point(0, 0);\n\t}\n}\n// ????????¨???????????????\nvector<Point> is_ss2(const Line &s, const Line& t) {\n\tvector<Point> kouho(is_ll2(s, t));\n\tvector<Point>ans;\n\tfor (auto p : kouho) {\n\t\tif (isis_sp(s, p) && isis_sp(t, p))ans.emplace_back(p);\n\t}\n\treturn ans;\n}\n// ??´?????¨???????????¢\nld dist_lp(const Line& l, const Point& p) {\n\treturn abs(p - proj(l, p));\n}\n\n// ??´?????¨??´???????????¢\nld dist_ll(const Line& l, const Line& m) {\n\treturn isis_ll(l, m) ? 0 : dist_lp(l, m.a);\n}\n\n// ??´?????¨??????????????¢\nld dist_ls(const Line& l, const Line& s) {\n\treturn isis_ls(l, s) ? 0 : min(dist_lp(l, s.a), dist_lp(l, s.b));\n}\n\n// ????????¨???????????¢\nld dist_sp(const Line& s, const Point& p) {\n\tPoint r = proj(s, p);\n\treturn isis_sp(s, r) ? abs(r - p) : min(abs(s.a - p), abs(s.b - p));\n}\n\n// ????????¨??????????????¢\nld dist_ss(const Line& s, const Line& t) {\n\tif (isis_ss(s, t)) return 0;\n\treturn min({ dist_sp(s, t.a), dist_sp(s, t.b), dist_sp(t, s.a), dist_sp(t, s.b) });\n}\n\n\n//??´?????¨??´?????????????????????????????????\nLine bisection(const Line &s, const Line &t) {\n\tconst Point laglanju(is_ll(s, t));\n\tconst Point avec = !(abs(laglanju - s[0])<eps) ? s[0] - laglanju : s[1] - laglanju;\n\tconst Point bvec = !(abs(laglanju - t[0])<eps) ? t[0] - laglanju : t[1] - laglanju;\n\n\treturn Line(laglanju, laglanju + (abs(bvec)*avec + abs(avec)*bvec) / (abs(avec) + abs(bvec)));\n}\n\n\n//???????????´?????????????????????\n//???????????´??????????????§???????????¨????¢?????????¨?????????\nPoint  inner_center(const vector<Line>&ls) {\n\tvector<Point>vertics;\n\tfor (int i = 0; i <static_cast<int>(ls.size()); ++i) {\n\t\tvertics.push_back(is_ll(ls[i], ls[(i + 1) % 3]));\n\t}\n\tif (vertics[0] == vertics[1] || vertics[1] == vertics[2] || vertics[2] == vertics[0])return vertics[0];\n\tLine bi1(bisection(Line(vertics[0], vertics[1]), Line(vertics[0], vertics[2])));\n\tLine bi2(bisection(Line(vertics[1], vertics[2]), Line(vertics[1], vertics[0])));\n\tif (bi1[0] == bi2[0])return bi1[0];\n\telse {\n\t\treturn is_ll(bi1, bi2);\n\t}\n}\n\n//???????????´?????????????????????\n//???????????´??????????????§???????????¨????¢?????????¨?????????\nvector<Point>  ex_center(const vector<Line>&ls) {\n\tvector<Point>vertics;\n\tfor (int i = 0; i < static_cast<int>(ls.size()); ++i) {\n\t\tvertics.push_back(is_ll(ls[i], ls[(i + 1) % 3]));\n\t}\n\tif (abs(vertics[0] - vertics[1])<eps || abs(vertics[1] - vertics[2])<eps || (abs(vertics[2] - vertics[0])<eps))return vector<Point>();\n\tvector<Point>ecs;\n\tfor (int i = 0; i < 3; ++i) {\n\t\tLine bi1(bisection(Line(vertics[i], vertics[i] * 2.0l - vertics[(i + 2) % 3]), Line(vertics[i], vertics[(i + 1) % 3])));\n\t\tLine bi2(bisection(Line(vertics[(i + 1) % 3], vertics[(i + 1) % 3] * 2.0l - vertics[(i + 2) % 3]), Line(vertics[(i + 1) % 3], vertics[i])));\n\t\tecs.push_back(is_ll(bi1, bi2));\n\t}\n\treturn ecs;\n}\n\n\n//a,b:??????\n//c:????????§??????\n//???????????´?????????????????¢?????????????±??????????\nvector<Point>  same_dis(const vector<Line>&ls) {\n\tvector<Point>vertics;\n\tvertics.push_back(is_ll(ls[0], ls[2]));\n\tvertics.push_back(is_ll(ls[1], ls[2]));\n\n\tif (abs(vertics[0] - vertics[1]) < eps)return vector<Point>{vertics[0]};\n\tLine bis(bisection(ls[0], ls[1]));\n\tvector<Point>ecs;\n\n\tLine abi(bisection(Line(vertics[0], vertics[1]), ls[0]));\n\tecs.push_back(is_ll(bis, abi));\n\n\n\tLine bbi(bisection(Line(vertics[0], 2.l*vertics[0] - vertics[1]), ls[0]));\n\tecs.push_back(is_ll(bis, bbi));\n\n\treturn ecs;\n}\n/* ??? */\n\n// ?????¨????????????\nvector<Point> is_cc(const Circle& c1, const Circle& c2) {\n\tvector<Point> res;\n\tld d = abs(c1.p - c2.p);\n\tld rc = (d * d + c1.r * c1.r - c2.r * c2.r) / (2 * d);\n\tld dfr = c1.r * c1.r - rc * rc;\n\tif (abs(dfr) < eps) dfr = 0.0;\n\telse if (dfr < 0.0) return res; // no intersection\n\tld rs = sqrt(dfr);\n\tPoint diff = (c2.p - c1.p) / d;\n\tres.push_back(c1.p + diff * Point(rc, rs));\n\tif (dfr != 0.0) res.push_back(c1.p + diff * Point(rc, -rs));\n\treturn res;\n}\n\n//???????????????????????????\n//  0 => out\n//  1 => on\n//  2 => in\nint is_in_circle(const Circle &cir, const  Point& p) {\n\tld dis = abs(cir.p - p);\n\tif (dis > cir.r + eps)return 0;\n\telse if (dis < cir.r - eps)return 2;\n\telse return 1;\n}\n//???lc??????rc??????????????????\n//  0 => out\n//  1 => on\n//  2 => in\nint circle_in_circle(const Circle &lc, const  Circle&rc) {\n\tld dis = abs(lc.p - rc.p);\n\tif (dis < rc.r - lc.r - eps)return 2;\n\telse if (dis>rc.r - lc.r + eps)return 0;\n\telse return 1;\n}\n\n// ?????¨??´????????????\nvector<Point> is_lc(const Circle& c, const Line& l) {\n\tvector<Point> res;\n\tld d = dist_lp(l, c.p);\n\tif (d < c.r + eps) {\n\t\tld len = (d > c.r) ? 0.0 : sqrt(c.r * c.r - d * d); //safety;\n\t\tPoint nor = (l.a - l.b) / abs(l.a - l.b);\n\t\tres.push_back(proj(l, c.p) + len * nor);\n\t\tres.push_back(proj(l, c.p) - len * nor);\n\t}\n\treturn res;\n}\n\n// ?????¨??????????????¢\nvector<Point> is_sc(const Circle& c, const Line& l) {\n\tvector<Point> v = is_lc(c, l), res;\n\tfor (Point p : v)\n\t\tif (isis_sp(l, p)) res.push_back(p);\n\treturn res;\n}\n\n// ?????¨????????\\???\nvector<Line> tangent_cp(const Circle& c, const Point& p) {\n\tvector<Line> ret;\n\tPoint v = c.p - p;\n\tld d = abs(v);\n\tld l = sqrt(norm(v) - c.r * c.r);\n\tif (isnan(l)) { return ret; }\n\tPoint v1 = v * Point(l / d, c.r / d);\n\tPoint v2 = v * Point(l / d, -c.r / d);\n\tret.push_back(Line(p, p + v1));\n\tif (l < eps) return ret;\n\tret.push_back(Line(p, p + v2));\n\treturn ret;\n}\n\n// ?????¨????????\\???\nvector<Line> tangent_cc(const Circle& c1, const Circle& c2) {\n\tvector<Line> ret;\n\tif (abs(c1.p - c2.p) - (c1.r + c2.r) > -eps) {\n\t\tPoint center = (c1.p * c2.r + c2.p * c1.r) / (c1.r + c2.r);\n\t\tret = tangent_cp(c1, center);\n\t}\n\tif (abs(c1.r - c2.r) > eps) {\n\t\tPoint out = (-c1.p * c2.r + c2.p * c1.r) / (c1.r - c2.r);\n\t\tvector<Line> nret = tangent_cp(c1, out);\n\t\tret.insert(ret.end(), ALL(nret));\n\t}\n\telse {\n\t\tPoint v = c2.p - c1.p;\n\t\tv /= abs(v);\n\t\tPoint q1 = c1.p + v * Point(0, 1) * c1.r;\n\t\tPoint q2 = c1.p + v * Point(0, -1) * c1.r;\n\t\tret.push_back(Line(q1, q1 + v));\n\t\tret.push_back(Line(q2, q2 + v));\n\t}\n\treturn ret;\n}\n//??????????????????????????¢???\nld two_circle_area(const Circle&l, const Circle&r) {\n\tld dis = abs(l.p - r.p);\n\tif (dis > l.r + r.r)return 0;\n\telse if (dis + r.r < l.r) {\n\t\treturn r.r*r.r*pi;\n\t}\n\telse if (dis + l.r < r.r) {\n\t\treturn l.r*l.r*pi;\n\t}\n\telse {\n\t\tld ans = (l.r)*(l.r)*acos((dis*dis + l.r*l.r - r.r*r.r) / (2 * dis*l.r)) +\n\t\t\t(r.r)*(r.r)*acos((dis*dis + r.r*r.r - l.r*l.r) / (2 * dis*r.r)) -\n\t\t\tsqrt(4 * dis*dis*l.r*l.r - (dis*dis + l.r*l.r - r.r*r.r)*(dis*dis + l.r*l.r - r.r*r.r)) / 2;\n\t\treturn ans;\n\t}\n\n}\n\n/* ????§???¢ */\n\ntypedef vector<Point> Polygon;\n\n// ??¢???\nld area(const Polygon &p) {\n\tld res = 0;\n\tint n = p.size();\n\tREP(j, n) res += cross(p[j], p[(j + 1) % n]);\n\treturn res / 2;\n}\n\n// ????§???¢????????¢??????\nbool is_counter_clockwise(const Polygon &poly) {\n\tld angle = 0;\n\tint n = poly.size();\n\tREP(i, n) {\n\t\tPoint a = poly[i], b = poly[(i + 1) % n], c = poly[(i + 2) % n];\n\t\tangle += arg((c - b) / (b - a));\n\t}\n\treturn angle > eps;\n}\n\n// ??????????????????\n//  0 => out\n//  1 => on\n//  2 => in\nint is_in_polygon(const Polygon &poly, const  Point& p) {\n\tld angle = 0;\n\tint n = poly.size();\n\tREP(i, n) {\n\t\tPoint a = poly[i], b = poly[(i + 1) % n];\n\t\tif (isis_sp(Line(a, b), p)) return 1;\n\t\tangle += arg((b - p) / (a - p));\n\t}\n\treturn eq(angle, 0) ? 0 : 2;\n}\n//??????????????????2?????????\nenum { OUT, ON, IN };\nint convex_contains(const Polygon &P, const Point &p) {\n\tconst int n = P.size();\n\tPoint g = (P[0] + P[n / 3] + P[2 * n / 3]) / 3.0l; // inner-point\n\tint a = 0, b = n;\n\twhile (a + 1 < b) { // invariant: c is in fan g-P[a]-P[b]\n\t\tint c = (a + b) / 2;\n\t\tif (cross(P[a] - g, P[c] - g) > 0) { // angle < 180 deg\n\t\t\tif (cross(P[a] - g, p - g) > 0 && cross(P[c] - g, p - g) < 0) b = c;\n\t\t\telse                                                  a = c;\n\t\t}\n\t\telse {\n\t\t\tif (cross(P[a] - g, p - g) < 0 && cross(P[c] - g, p - g) > 0) a = c;\n\t\t\telse                                                  b = c;\n\t\t}\n\t}\n\tb %= n;\n\tif (cross(P[a] - p, P[b] - p) < 0) return 0;\n\tif (cross(P[a] - p, P[b] - p) > 0) return 2;\n\treturn 1;\n}\n\n// ??????\n// ???????????????????????¨????????????????????§??¨???\nPolygon convex_hull(vector<Point> ps) {\n\tint n = ps.size();\n\tint k = 0;\n\tsort(ps.begin(), ps.end());\n\tPolygon ch(2 * n);\n\tfor (int i = 0; i < n; ch[k++] = ps[i++])\n\t\twhile (k >= 2 && ccw(ch[k - 2], ch[k - 1], ps[i]) <= 0) --k;\n\tfor (int i = n - 2, t = k + 1; i >= 0; ch[k++] = ps[i--])\n\t\twhile (k >= t && ccw(ch[k - 2], ch[k - 1], ps[i]) <= 0) --k;\n\tch.resize(k - 1);\n\treturn ch;\n}\n\n\n\n// ????????????\nvector<Polygon> convex_cut(const Polygon &ps, const Line& l) {\n\tint n = ps.size();\n\tPolygon Q;\n\tPolygon R;\n\tREP(i, n) {\n\t\tPoint A = ps[i], B = ps[(i + 1) % n];\n\t\tLine m = Line(A, B);\n\t\tif (ccw(l.a, l.b, A) != -1) Q.push_back(A);\n\t\tif (ccw(l.a, l.b, A) != 1) R.push_back(A);\n\t\tif (ccw(l.a, l.b, A) * ccw(l.a, l.b, B) < 0 && isis_ll(l, m)) {\n\t\t\tQ.push_back(is_ll(l, m));\n\t\t\tR.push_back(is_ll(l, m));\n\t\t}\n\t}\n\tconst vector<Polygon>polys{ Q,R };\n\treturn polys;\n}\n\n\n/* ??¢??¬??????????????? */\nvoid add_point(vector<Point> &ps, const Point p) {\n\tfor (Point q : ps) if (abs(q - p) < eps) return;\n\tps.push_back(p);\n}\n\ntypedef int Weight;\nstruct Edge {\n\tint src, dst;\n\tWeight weight;\n\tEdge(int src, int dst, Weight weight) :\n\t\tsrc(src), dst(dst), weight(weight) { }\n};\n\ntypedef vector<Edge> Edges;\ntypedef vector<Edges> Graph;\n\nvoid add_edge(Graph &g, const int from, const int to, const Weight weight) {\n\tg[from].push_back(Edge{ from, to, weight });\n}\n\nGraph segment_arrangement(const vector<Line> &s, const vector<Point> &p) {\n\tint n = p.size(), m = s.size();\n\tGraph g(n);\n\tREP(i, m) {\n\t\tvector<pair<ld, int>> vec;\n\t\tREP(j, n) if (isis_sp(s[i], p[j]))\n\t\t\tvec.emplace_back(abs(s[i].a - p[j]), j);\n\t\tsort(ALL(vec));\n\t\tREP(j, vec.size() - 1) {\n\t\t\tint from = vec[j].second, to = vec[j + 1].second;\n\t\t\tadd_edge(g, from, to, static_cast<Weight>(abs(p[from] - p[to])));\n\t\t}\n\t}\n\treturn g;\n}\nGraph sennbunn_arrangement(const vector<Line>&s) {\n\tvector<Point>crss;\n\tfor (int i = 0; i < static_cast<int>(s.size()); ++i) {\n\t\tfor (int j = i + 1; j < static_cast<int>(s.size()); ++j) {\n\t\t\tif (isis_ss(s[i], s[j])) {\n\t\t\t\tcrss.push_back(is_ll(s[i], s[j]));\n\t\t\t}\n\t\t}\n\t}\n\tfor (int i = 0; i <static_cast<int>(s.size()); ++i) {\n\t\tcrss.push_back(s[i][0]);\n\t\tcrss.push_back(s[i][1]);\n\t}\n\treturn segment_arrangement(s, crss);\n}\n\n//Graph circle_arrangement(const vector<Circle> &c, const vector<Point> &p) {\n//\tint n = p.size(), m = c.size();\n//\tGraph g(n);\n//\tREP(i, m) {\n//\t\tvector<pair<ld, int>> vec;\n//\t\tREP(j, n) if (abs(abs(c[i].p - p[j]) - c[i].r) < eps)\n//\t\t\tvec.emplace_back(arg(c[i].p - p[j]), j);\n//\t\tsort(ALL(vec));\n//\t\tREP(j, vec.size() - 1) {\n//\t\t\tint from = vec[j].second, to = vec[j + 1].second;\n//\t\t\tld angle = vec[j + 1].first - vec[j].first;\n//\t\t\tadd_edge(g, from, to, static_cast<Weight>(angle * c[i].r));\n//\t\t}\n//\t\tif (vec.size() >= 2) {\n//\t\t\tint from = vec.back().second, to = vec.front().first;\n//\t\t\tld angle = vec.front().first - vec.back().first;\n//\t\t\tadd_edge(g, from, to, static_cast<Weight>(angle * c[i].r));\n//\t\t}\n//\t}\n//\treturn g;\n//}\n\n\n/* ????????°?????? */\n\n// ?????????????????¢?????¢??¬??????????????????????????????????????°???????????????\n// ?????´?????????????¨?????????§????????´????????????????¨?????????§???????????????\n// ?????° polygon ??????vector<int> ??§??¨?????????????§???¢???????????§?????????\n// vector<int> ??§??¨????????? ????§???¢???i???????????????????????????????????????p????????????????????§?????????\nvector<vector<int>> polygon;\nvector<int> seg2p[1024][1024];\n\n//Graph dual_graph(const vector<Line> &s, const vector<Point> &p) {\n//\tint N = p.size();\n//\tpolygon.clear();\n//\tREP(i, 1024) REP(j, 1024) seg2p[i][j].clear();\n//\tvector<vector<tuple<ld, int, bool>>> tup(N);\n//\tREP(i, s.size()) {\n//\t\tint a = -1, b = -1;\n//\t\tREP(j, N) if (abs(s[i].a - p[j]) < eps) a = j;\n//\t\tREP(j, N) if (abs(s[i].b - p[j]) < eps) b = j;\n//\t\tassert(a >= 0 && b >= 0);\n//\t\ttup[a].emplace_back(arg(s[i].b - s[i].a), b, false);\n//\t\ttup[b].emplace_back(arg(s[i].a - s[i].b), a, false);\n//\t}\n//\tREP(i, N) sort(ALL(tup[i]));\n//\tREP(i, N) {\n//\t\tREP(j, tup[i].size()) {\n//\t\t\tld angle; int pos = j, from = i, to; bool flag;\n//\t\t\ttie(angle, to, flag) = tup[i][j];\n//\t\t\tif (flag) continue;\n//\t\t\tvector<int> ps;\n//\t\t\twhile (!flag) {\n//\t\t\t\tps.push_back(from);\n//\t\t\t\tget<2>(tup[from][pos]) = true;\n//\t\t\t\tseg2p[from][to].push_back(polygon.size());\n//\t\t\t\tseg2p[to][from].push_back(polygon.size());\n//\t\t\t\tangle += pi + eps;\n//\t\t\t\tif (angle > pi) angle -= 2 * pi;\n//\t\t\t\tauto it = lower_bound(ALL(tup[to]), make_tuple(angle, 0, false));\n//\t\t\t\tif (it == tup[to].end()) it = tup[to].begin();\n//\t\t\t\tfrom = to; tie(angle, to, flag) = *it;\n//\t\t\t\tpos = it - tup[from].begin();\n//\t\t\t}\n//\t\t\tpolygon.push_back(ps);\n//\t\t}\n//\t}\n//\tGraph g(polygon.size());\n//\tREP(i, N) REP(j, i) {\n//\t\tif (seg2p[i][j].size() == 2) {\n//\t\t\tint from = seg2p[i][j][0], to = seg2p[i][j][1];\n//\t\t\tg[from].push_back(Edge{ from, to });\n//\t\t\tg[to].push_back(Edge{ to, from });\n//\t\t}\n//\t}\n//\treturn g;\n//}\n\nstruct flo {\n\tPoint p;\n\tld the;\n};\nbool check(const flo&f, const Point p,const ld len,const ld theta) {\n\tconst ld dis = abs(f.p - p);\n\tif (dis-eps > len) {\n\t\treturn false;\n\t}\n\telse {\n\t\tld kaku = atan2(p.imag() - f.p.imag(), p.real() - f.p.real());\n\t\tif (p.real() > f.p.real()) {\n\n\t\t}\n\t\telse {\n\t\t\tkaku += pi;\n\t\t}\n\t\tld sa = abs(kaku - theta);\n\t\tsa = min(sa, 2 * pi - sa);\n\t\tif (sa < f.the / 2)return true;\n\t\telse return false;\n\t}\n}\nint main() {\n\twhile (1) {\n\t\tvector<Point>houses;\n\t\tint H, R; cin >> H >> R;\n\t\tif (!H)break;\n\t\tfor (int i = 0; i < H; ++i) {\n\t\t\tint x, y; cin >> x >> y;\n\t\t\thouses.emplace_back(x, y);\n\t\t}\n\t\tint U, M, S;ld du, dm, ds;  cin >> U >> M >> S >> du >> dm >> ds;\n\t\tdu *= dtop;\n\t\tdm *= dtop;\n\t\tds *= dtop;\n\t\tvector<flo>flowers;\n\t\tfor (int i = 0; i < U; ++i) {\n\t\t\tint x, y; cin >> x >> y;\n\t\t\tflowers.push_back(flo{ Point(x,y),du });\n\t\t}\n\t\tfor (int i = 0; i < M; ++i) {\n\t\t\tint x, y; cin >> x >> y;\n\t\t\tflowers.push_back(flo{ Point(x,y),dm });\n\t\t}\n\t\tfor (int i = 0; i < S; ++i) {\n\t\t\tint x, y; cin >> x >> y;\n\t\t\tflowers.push_back(flo{ Point(x,y),ds });\n\t\t}\n\t\tflo myflower{ Point(0,0),du };\n\t\tint ans = 0;\n\t\tvector<int>nums(H);\n\t\tfor (int i = 0; i < R; ++i) {\n\t\t\tld w, a; cin >> a >> w;\n\t\t\ta *= dtop;\n\t\t\tfor (int h = 0; h < H; ++h) {\n\t\t\t\tPoint p(houses[h]);\n\t\t\t\tif (check(myflower, p, w, a)) {\n\n\t\t\t\t\tbool aok = true;\n\t\t\t\t\tfor (auto f : flowers) {\n\t\t\t\t\t\tif (check(f, p, w, a)) {\n\t\t\t\t\t\t\taok = false;\n\t\t\t\t\t\t\tbreak;\n\t\t\t\t\t\t}\n\t\t\t\t\t}\n\t\t\t\t\tif (aok) {\n\t\t\t\t\t\tnums[h]++;\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t\tint amax = *max_element(nums.begin(), nums.end());\n\t\tif (amax) {\n\t\t\tvector<int>anss;\n\t\t\tfor (int i = 0; i < H; ++i) {\n\t\t\t\tif (amax == nums[i]) {\n\t\t\t\t\tanss.push_back(i+1);\n\t\t\t\t}\n\t\t\t}\n\t\t\tfor (int i = 0; i < anss.size(); ++i) {\n\t\t\t\tcout << anss[i];\n\t\t\t\tif (i != anss.size() - 1)cout << \" \";\n\t\t\t\telse cout << endl;\n\t\t\t}\n\t\t}\n\t\telse {\n\t\t\tcout << \"NA\" << endl;\n\t\t}\n\t}\n\treturn 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include<bits/stdc++.h>\nusing namespace std;\ntypedef complex<double> P;\nint H,R;\nint U[3];\ndouble D[3];\nconst double eps = 1e-8;\ndouble getRtoA( double r ){ return 180.0/M_PI*r; }\ndouble da[]={-360.0,0.0,360.0};\nbool check(P p, P f, double a, double w, double d ){\n  P v = p - f;\n  if( abs(v) > a + eps ) return false;\n  double an = getRtoA( arg(v) );\n  for(int i=0;i<3;i++){\n    if( w - d - eps < an + da[i] && an + da[i] < w + d + eps ) return true;\n  }\n  return false;\n}\n\nbool check( P p, vector<vector<P>> u, double a, double w){\n  for(int i=0;i<3;i++){\n    for(int j=0;j<U[i];j++){\n      if( check( p, u[i][j], a, w, D[i] ) ) return false;\n    }\n  }\n  return true;\n}\n\nint main(){\n  while( cin >> H >> R && (H|R) ){\n    vector<P> h;\n    vector<vector<P>> u;\n    vector<int> w,a;\n    u.resize(3);\n    for(int i=0;i<H;i++){\n      int x,y; cin >> x >> y; h.push_back( P( x, y ) );\n    }\n    cin >> U[0] >> U[1] >> U[2] >> D[0] >> D[1] >> D[2];\n    for(int i=0;i<3;i++){\n      D[i]/=2.0;\n      for(int j=0;j<U[i];j++){\n        int x,y; cin >> x >> y;\n        u[i].push_back( P(x,y) );\n      }\n    }\n\n    w.resize(R);a.resize(R);\n    for(int i=0;i<R;i++){\n      cin >> w[i] >> a[i];\n    }\n\n    \n    vector<int> res;\n    int maxs = 0;\n    for(int i=0;i<H;i++){\n      int cnt = 0;\n      for(int j=0;j<R;j++){\n        if( check( h[i], P(0,0), a[j], w[j], D[0] ) ) {\n          if( check( h[i], u, a[j], w[j] ) ) cnt++;\n        }\n      }\n      if( cnt == 0 ) continue;\n      if( maxs < cnt ){\n        res.clear();\n        res.push_back( i+1 );\n        maxs = cnt;\n      } else if( maxs == cnt )\n        res.push_back( i+1 );\n\n    }\n\n    if( res.empty() ) cout << \"NA\";\n    else {\n      for(int i=0;i<(int)res.size();i++){\n        if( i ) cout << \" \";\n        cout << res[i];\n      }\n    }\n    cout << endl;\n    \n  }\n}"
  },
  {
    "language": "C++",
    "code": "#include<bits/stdc++.h>\nusing namespace std;\n\ntypedef struct {\n  int x, y;\n  int cnt;\n} House;\n\ntypedef struct {\n  int x, y;\n  int c;\n} Flower;\n\ntypedef struct {\n  int w;\n  double a;\n} Wind;\n\ndouble d[3];\n\ndouble dist(int x1, int y1, int x2, int y2){\n  return fabs(sqrt(pow((double)(x1 - x2), 2.0) + pow((double)(y1 - y2), 2.0)));\n}\n\nbool clash(Wind w, House h, Flower f){\n  // 距離\n  if(dist(h.x, h.y, f.x, f.y) <= w.a){\n    double angle;\n    if(h.x == f.x && h.y > f.y){\n      angle = 90;\n    }else if(h.x == f.x && h.y < f.y){\n      angle = 270;\n    }else if(h.y == f.y && h.x > f.x){\n      angle = 0;\n    }else if(h.y == f.y && h.x < f.x){\n      angle = 180;\n    }else{\n      double x, y;\n      x = (double)(h.x - f.x);\n      y = (double)(h.y - f.y);\n\n      angle = atan(fabs(y) / fabs(x));\n      angle *= 180 / M_PI; // 度数法へ\n\n      if(x < 0 && y > 0){\n\tangle = 180 - angle;\n      }else if(x < 0 && y < 0){\n\tangle = 180 + angle;\n      }else if(x > 0 && y < 0){\n\tangle = 360 - angle;\n      }\n    }\n\n    double up = (double)w.w + d[f.c] / 2;\n    double low = (double)w.w - d[f.c] / 2;\n\n    if(up >= 360){\n      // 扇形を分割(x軸をまたぐ)\n      if(angle <= up - 360 || angle >= low){\n\treturn true;\n      }else{\n\treturn false;\n      }\n    }else if(low <= 0){\n      if(angle <= up || angle >= low + 360){\n\treturn true;\n      }else{\n\treturn false;\n      }\n    }else{\n      // 扇形を分割する必要がない\n      if(low <= angle && angle <= up){\n\treturn true;\n      }else{\n\treturn false;\n      }\n    }\n  }else{\n    return false;\n  }\n}\n\nint main(){\n  ios_base::sync_with_stdio(false);\n  cin.tie(NULL);\n\n  Flower temp;\n  temp.x = 0;\n  temp.y = 0;\n  temp.c = 0;\n\n  while(1){\n    int H, R;\n    cin >> H >> R;\n    if(H == 0 && R == 0) break;\n\n    House h[105];\n    for(int i = 0;i < H;++i){\n      cin >> h[i].x >> h[i].y;\n      h[i].cnt = 0;\n    }\n    \n    int U, M, S;\n    cin >> U >> M >> S >> d[0] >> d[1] >> d[2];\n    \n    Flower f[35];\n    int i, j;\n    for(i = 0;i < U;++i){\n      cin >> f[i].x >> f[i].y;\n      f[i].c = 0;\n    }\n    for(j = 0;j < M;++j){\n      cin >> f[i + j].x >> f[i + j].y;\n      f[i + j].c = 1;\n    }\n    for(int k = 0;k < S;++k){\n      cin >> f[i + j + k].x >> f[i + j + k].y;\n      f[i + j + k].c = 2;\n    }\n    \n    Wind w;\n    for(i = 0;i < R;++i){\n      cin >> w.w >> w.a;\n      for(int j = 0;j < H;++j){\n\tbool flag = true;\n\tfor(int k = 0;k < U + M + S && flag;++k){\n\t  if(/*あたり判定*/clash(w, h[j], f[k])){\n\t    flag = false;\n\t  }\n\t}\n\n\tif(flag && /*自分の梅とのあたり判定*/clash(w, h[j], temp)){\n\t  ++h[j].cnt;\n\t}\n      }\n    }\n\n    vector<int> vec;    \n    int maxim = 0;\n    for(i = 0;i < H;++i){\n      if(maxim == h[i].cnt){\n\tvec.push_back(i + 1);\n      }\n      else if(maxim < h[i].cnt){\n\tvec.clear();\n\tvec.push_back(i + 1);\n\tmaxim = h[i].cnt;\n      }\n    }\n    \n    if(maxim == 0){\n      cout << \"NA\" << endl;\n    }else{\n      for(int i = 0;i < vec.size();++i){\n\tcout << vec[i];\n\t\n\tif(i == vec.size() - 1){\n\t  cout << endl;\n\t}else{\n\t  cout << ' ';\n\t}\n      }\n    }\n\n    /*\n    cout << \"!\";\n    for(int i = 0;i < H;++i){\n      cout << h[i].cnt << ' ';\n    }\n    cout << endl;\n    */\n\n  }\n\n  return 0;\n}\n\n\n"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\nusing namespace std;\n#define F first\n#define S second\ntypedef pair<double,double> P;\ntypedef complex<double> PP;\ndouble toRad(double agl){return agl*M_PI/180.0;}\ndouble D(P a,P b) {return sqrt((a.F-b.F)*(a.F-b.F)+(a.S-b.S)*(a.S-b.S));}\nPP rotate(PP a, double r){return PP(a.real()*cos(r)-a.imag()*sin(r),a.real()*sin(r)+a.imag()*cos(r));}\n\nbool solve(P a,P c,P b,double d) {\n  double r=atan2(a.S-b.S,a.F-b.F);\n  PP a2=rotate(PP(c.S,0),toRad(c.F-d/2)),a3=rotate(PP(c.S,0),toRad(c.F+d/2));\n  double rl=atan2(a2.imag(),a2.real()),rr=atan2(a3.imag(),a3.real());\n  if(rr<rl) rr+=2*M_PI;\n  if(D(a,b)<=c.S&&(rl<=r&&r<=rr||rl<=r+M_PI*2&&r+M_PI*2<=rr)) return 1;\n  return 0;\n}\n\nint main() {\n  int n,n2;\n  while(cin >> n >> n2 && n) {\n    P a[n];\n    for(int i=0; i<n; i++) cin >> a[i].F >> a[i].S;\n    int U,M,S,du,dm,ds;\n    cin >> U >> M >> S >> du >> dm >> ds;\n    P u[U],m[M],s[S];\n    for(int i=0; i<U; i++) cin >> u[i].F >> u[i].S;\n    for(int i=0; i<M; i++) cin >> m[i].F >> m[i].S;\n    for(int i=0; i<S; i++) cin >> s[i].F >> s[i].S;\n    P b[n2];\n    for(int i=0; i<n2; i++) cin >> b[i].F >> b[i].S;\n    int z=1;\n    vector<int> ans;\n    for(int i=0; i<n; i++) {\n      int cnt=0;\n      for(int j=0; j<n2; j++) {\n        bool f=solve(a[i],b[j],P(0,0),du);\n        for(int k=0; k<U; k++) {\n          if(solve(a[i],b[j],u[k],du)) f=0;\n        }\n        for(int k=0; k<M; k++) {\n          if(solve(a[i],b[j],m[k],dm)) f=0;\n        }\n        for(int k=0; k<S; k++) {\n          if(solve(a[i],b[j],s[k],ds)) f=0;\n        }\n        cnt+=f;\n      }\n      if(cnt>z) {\n        z=cnt;\n        ans.clear();\n        ans.push_back(i+1);\n      } else if(cnt==z) ans.push_back(i+1);\n    }\n    if(!ans.size()) cout << \"NA\" << endl;\n    else {\n      for(int i=0; i<ans.size(); i++) {\n        if(i) cout << \" \";\n        cout << ans[i];\n      }\n      cout << endl;\n    }\n  }\n  return 0;\n}\n"
  },
  {
    "language": "C++",
    "code": "#include <cstdio>\n#include <cstdlib>\n#include <cmath>\n#include <cstring>\n\n#include <iostream>\n#include <string>\n#include <algorithm>\n#include <vector>\n#include <queue>\n#include <stack>\n#include <map>\n#include <set>\n\n#include <functional>\n#include <cassert>\n\ntypedef long long ll;\nusing namespace std;\n\n#define debug(x) cerr << #x << \" = \" << x << endl;\n\n\n#define mod 1000000007 //1e9+7(prime number)\n#define INF 1000000000 //1e9\n#define LLINF 2000000000000000000LL //2e18\n#define SIZE 10000\n\n#define eps 1e-8\n\nbool is_ok(int hx,int hy, int tx, int ty, int td,int a,int w){\n\n  int dx = hx - tx;\n  int dy = hy - ty;\n\n  if(a*a < dx*dx + dy*dy) return false;\n\n  double rad = atan((double)dy/dx);\n\n  if(rad < 0){\n    rad += M_PI;\n  }\n  \n  if(dy < 0){\n    rad += M_PI;\n  }\n\n  rad = rad/M_PI * 180;\n  \n  rad += 180 - w;\n  w = 180;\n\n  if(rad >= 360) rad -= 360;\n  if(rad < 0) rad += 360;\n    \n  return w - td/2.0 - eps < rad && rad < w + td/2.0 + eps;\n}\n\nbool calc(){\n  int h,r,t;\n  int hx[SIZE],hy[SIZE];\n  int u,m,s,du,dm,ds;\n  int tx[SIZE],ty[SIZE],td[SIZE];\n  int w[SIZE],a[SIZE];\n  \n  scanf(\"%d%d\",&h,&r);\n\n  if(h==0) return false;\n\n  for(int i=0;i<h;i++){\n    scanf(\"%d%d\",hx+i,hy+i);\n  }\n\n  scanf(\"%d%d%d%d%d%d\",&u,&m,&s,&du,&dm,&ds);\n\n  t = u+m+s;\n  \n  for(int i=0;i<u;i++){\n    scanf(\"%d%d\",tx+i,ty+i);\n    td[i] = du;\n  }\n\n  for(int i=u;i<u+m;i++){\n    scanf(\"%d%d\",tx+i,ty+i);\n    td[i] = dm;\n  }\n\n  for(int i=u+m;i<u+s+m;i++){\n    scanf(\"%d%d\",tx+i,ty+i);\n    td[i] = ds;\n  }\n\n  for(int i=0;i<r;i++){\n    scanf(\"%d%d\",w+i,a+i);\n  }\n\n  int max_d = 0;\n  int ans[SIZE] = {};\n\n  for(int i=0;i<h;i++){\n\n    for(int j=0;j<r;j++){\n      bool flag = true;\n\n      for(int k=0;k<t;k++){\n        if(is_ok(hx[i],hy[i],tx[k],ty[k],td[k],a[j],w[j])) flag = false;\n      }\n\n      if(flag && is_ok(hx[i],hy[i],0,0,du,a[j],w[j])) ans[i]++;\n    }\n  }\n  \n  for(int i=0;i<h;i++)\n    max_d = max(max_d,ans[i]);\n\n  if(max_d > 0){\n  \n    bool flag1 = false;\n    \n    for(int i=0;i<h;i++){\n      if(max_d == ans[i]){\n        if(flag1) printf(\" \");\n        flag1 = true;\n        printf(\"%d\",i+1);\n      }\n    }\n    \n    printf(\"\\n\");\n  }else{\n    puts(\"NA\");\n  }\n  \n  return true;\n}\n  \n\nint main(){\n\n  while(calc());\n  \n  return 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include <iostream>\n#include <complex>\n#include <cmath>\n#include <vector>\n\nusing namespace std;\n\ntypedef complex<double> P;\n\nconst double EPS = 1e-8;\n\nint h, r, u, m, s;\ndouble du, dm, ds;\nvector<P> ume, momo, sakura, ie;\nint cnt[100];\n\nvoid init(){\n  ume.clear();\n  momo.clear();\n  sakura.clear();\n  ie.clear();\n  fill(cnt, cnt+100, 0);\n}\n\nbool check2(P kaze, P e, P ki, double dir){\n  double dist = abs(e - ki);\n  if(dist > kaze.imag() + EPS) return false;\n  double tmp = arg(e - ki) * 180 / M_PI;\n  double a = kaze.real() + dir / 2.0;\n  double b = kaze.real() - dir / 2.0;\n  return !(tmp < b + EPS || a - EPS < tmp);\n}\n\nbool check(P kaze, P e){\n  if(!check2(kaze, e, P(0, 0), du)) return false;\n  for(int i=0;i<u;i++) if(check2(kaze, e, ume[i], du)) return false;\n  for(int i=0;i<m;i++) if(check2(kaze, e, momo[i], dm)) return false;\n  for(int i=0;i<s;i++) if(check2(kaze, e, sakura[i], ds)) return false;\n  return true;\n}\n\nmain(){\n  while(cin >> h >> r && (h|r)){\n    init();\n    P in;\n    for(int i=0;i<h;i++){\n      cin >> in.real() >> in.imag();\n      ie.push_back(in);\n    }\n    cin >> u >> m >> s >> du >> dm >> ds;\n    for(int i=0;i<u;i++){\n      cin >> in.real() >> in.imag();\n      ume.push_back(in);\n    }\n    for(int i=0;i<m;i++){\n      cin >> in.real() >> in.imag();\n      momo.push_back(in);\n    }\n    for(int i=0;i<s;i++){\n      cin >> in.real() >> in.imag();\n      sakura.push_back(in);\n    }\n    for(int i=0;i<r;i++){\n      cin >> in.real() >> in.imag();\n      for(int j=0;j<h;j++){\n        if(check(in, ie[j])) cnt[j]++;\n      }\n    }\n    int ans = 0;\n    for(int i=0;i<h;i++) ans = max(ans, cnt[i]);\n    if(!ans) cout << \"NA\" << endl;\n    else{\n      bool f = true;\n      for(int i=0;i<h;i++){\n        if(ans == cnt[i]){\n          if(f) f = false;\n          else cout << \" \";\n          cout << i+1;\n        }\n      }\n      cout << endl;\n    }\n  }\n}"
  },
  {
    "language": "C++",
    "code": "#include<iostream>\n#include<complex>\n#include<vector>\n#include<algorithm>\n\nusing namespace std;\n\ntypedef complex<double> P;\n\ndouble dot(P a,P b){\n  return (a*conj(b)).real();\n}\n\nint main(){\n  for(int H,R;cin>>H>>R,H;){\n    P h[100];\n    for(int i=0;i<H;i++){\n      int x,y;\n      cin>>x>>y;\n      h[i]=P(x,y);\n    }\n    int UMS[3],dums[3];\n    cin>>UMS[0]>>UMS[1]>>UMS[2]>>dums[0]>>dums[1]>>dums[2];\n    P ums[3][10];\n    for(int i=0;i<3;i++){\n      for(int j=0;j<UMS[i];j++){\n\tint x,y;\n\tcin>>x>>y;\n\tums[i][j]=P(x,y);\n      }\n    }\n    int nr[100]={};\n    for(int i=0;i<R;i++){\n      int w,a;\n      cin>>w>>a;\n      auto reach=[=](P s,P d,int ang){\n\tP v=d-s;\n\treturn abs(v)<a&&acos(dot(v,polar(1.,w*acos(0)/90))/abs(v))<ang*acos(0)/90/2;\n      };\n      for(int j=0;j<H;j++){\n\tif(reach(P(0,0),h[j],dums[0])){\n\t  bool f=false;\n\t  for(int k=0;k<3;k++){\n\t    for(int l=0;l<UMS[k];l++){\n\t      f|=reach(ums[k][l],h[j],dums[k]);\n\t    }\n\t  }\n\t  nr[j]+=!f;\n\t}\n      }\n    }\n    auto m=*max_element(nr,nr+H);\n    if(m==0){\n      cout<<\"NA\"<<endl;\n    }else{\n      vector<int> v;\n      for(int i=0;i<H;i++){\n\tif(m==nr[i]){\n\t  v.push_back(i+1);\n\t}\n      }\n      for(int i=0;i<v.size();i++){\n\tcout<<v[i]<<\" \\n\"[i==v.size()-1];\n      }\n    }\n  }\n}"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\nusing namespace std;\n\nusing ll=long long;\n#define int ll\n\n#define rng(i,a,b) for(int i=int(a);i<int(b);i++)\n#define rep(i,b) rng(i,0,b)\n#define gnr(i,a,b) for(int i=int(b)-1;i>=a;i--)\n#define per(i,b) gnr(i,0,b)\n#define pb push_back\n#define eb emplace_back\n#define a first\n#define b second\n#define bg begin()\n#define ed end()\n#define all(x) x.bg,x.ed\n#ifdef LOCAL\n#define dmp(x) cerr<<__LINE__<<\" \"<<#x<<\" \"<<x<<endl\n#else\n#define dmp(x) void(0)\n#endif\n\ntemplate<class t,class u> void chmax(t&a,u b){if(a<b)a=b;}\ntemplate<class t,class u> void chmin(t&a,u b){if(a>b)a=b;}\n\ntemplate<class t> using vc=vector<t>;\ntemplate<class t> using vvc=vc<vc<t>>;\n\nusing pi=pair<int,int>;\nusing vi=vc<int>;\n\ntemplate<class t,class u>\nostream& operator<<(ostream& os,const pair<t,u>& p){\n\treturn os<<\"{\"<<p.a<<\",\"<<p.b<<\"}\";\n}\n\ntemplate<class t> ostream& operator<<(ostream& os,const vc<t>& v){\n\tos<<\"{\";\n\tfor(auto e:v)os<<e<<\",\";\n\treturn os<<\"}\";\n}\n\nusing ld=long double;\nusing cm=complex<ld>;\n#define x real()\n#define y imag()\nconst ld eps=1e-8;\nconst ld PI=acos(ld(-1));\nint sgn(ld a){return a<-eps?-1:(a>eps?1:0);}\nauto cmcmp=[](const cm&a,const cm&b){\n\tif(sgn(a.x-b.x))return a.x<b.x;\n\telse return sgn(a.y-b.y)<0;\n};\nauto cmeq=[](const cm&a,const cm&b){\n\treturn sgn(a.x-b.x)==0&&sgn(a.y-b.y)==0;\n};\nld dot(cm a,cm b){return a.x*b.x+a.y*b.y;}\nld crs(cm a,cm b){return a.x*b.y-a.y*b.x;}\nld crs(cm a,cm b,cm c){return crs(b-a,c-a);}\nint ccw(cm a,cm b){return sgn(crs(a,b));}\nint ccw(cm a,cm b,cm c){return ccw(b-a,c-a);}\n//AOJ1183\nint qeq(ld a,ld b,ld c,ld&d,ld&e){\n\tld f=b*b-4*a*c;\n\tif(sgn(f)<0)return 0;\n\tld g=sqrt(max(f,ld(0)));\n\td=(-b+g)/(2*a);\n\te=(-b-g)/(2*a);\n\treturn sgn(f)+1;\n}\n//(-2)[a,-1](0)[b,1](2)\nint bet(cm a,cm b,cm c){\n\tcm d=b-a;\n\tld e=dot(d,c-a);\n\tif(sgn(e)<=0)return sgn(e)-1;\n\treturn sgn(e-norm(d))+1;\n}\n//AOJ0153\n//0-no,1-edge,2-in\nint cont(cm a,cm b,cm c,cm d){\n\tif(ccw(a,b,c)==-1)\n\t\tswap(b,c);\n\treturn min({ccw(a,b,d),ccw(b,c,d),ccw(c,a,d)})+1;\n}\n//AOJ1183\n//arg between ab\n//assume given lengths are valid\nld arg(ld a,ld b,ld c){\n\treturn acos(min(max((a*a+b*b-c*c)/(2*a*b),ld(-1)),ld(1)));\n}\n//AOJ2233\n//a->b->c と進むときに曲がる角度\n//a-b-cが一直線上にあれば0が帰る\nld turn(cm a,cm b,cm c){\n\treturn arg((c-b)/(b-a));\n}\n\nbool inc(ld a,ld b,ld c){\n\treturn sgn(a-b)<=0&&sgn(b-c)<=0;\n}\n\nsigned main(){\n\tcin.tie(nullptr);\n\tios::sync_with_stdio(false);\n\tcout<<fixed<<setprecision(20);\n\t\n\twhile(1){\n\t\tint h,r;cin>>h>>r;\n\t\tif(h==0)break;\n\t\tvc<cm> pos(h);\n\t\trep(i,h){\n\t\t\tld s,t;cin>>s>>t;\n\t\t\tpos[i]=cm(s,t);\n\t\t}\n\t\tint n[3];\n\t\tld d[3];\n\t\trep(i,3)cin>>n[i];\n\t\trep(i,3){cin>>d[i];d[i]*=PI/180/2;}\n\t\tvc<cm> z[3];\n\t\trep(i,3)rep(j,n[i]){\n\t\t\tld s,t;cin>>s>>t;\n\t\t\tz[i].eb(s,t);\n\t\t}\n\t\t\n\t\tvi cnt(h);\n\t\tconst auto sub=[&](int k,cm a,cm b,ld w,ld len){\n\t\t\tif(sgn(abs(a-b)-len)>0)return 0;\n\t\t\tld c=arg(b-a);\n\t\t\trng(i,-1,2)\n\t\t\t\tif(inc(w-d[k],c+2*PI*i,w+d[k]))\n\t\t\t\t\treturn 1;\n\t\t\treturn 0;\n\t\t};\n\t\trep(_,r){\n\t\t\tld w,a;cin>>w>>a;\n\t\t\tw*=PI/180;\n\t\t\trep(i,h)if(sub(0,cm(),pos[i],w,a)){\n\t\t\t\tbool ok=true;\n\t\t\t\trep(k,3)rep(j,n[k])\n\t\t\t\t\tif(sub(k,z[k][j],pos[i],w,a))\n\t\t\t\t\t\tok=false;\n\t\t\t\tcnt[i]+=ok;\n\t\t\t}\n\t\t}\n\t\t\n\t\tint mx=*max_element(all(cnt));\n\t\tif(mx){\n\t\t\tvi ans;\n\t\t\trep(i,h)if(cnt[i]==mx)\n\t\t\t\tans.pb(i+1);\n\t\t\trep(i,ans.size()){\n\t\t\t\tcout<<ans[i];\n\t\t\t\tif(i+1<int(ans.size()))cout<<\" \";\n\t\t\t\telse cout<<endl;\n\t\t\t}\n\t\t}else\n\t\t\tcout<<\"NA\"<<endl;\n\t}\n}\n\n"
  },
  {
    "language": "C++",
    "code": "#include<iostream>\n#include<complex>\n#include<vector>\n#include<algorithm>\n#include<cmath>\n#include<cstring>\n\n#define pb push_back\n#define sz size()\n#define rep(i,a) for(int i=0;i<(int)(a);i++)\n\nusing namespace std;\ntypedef long double D;\ntypedef complex<D> P;\nconst D EPS = 1e-10;\nconst D PI = acos(-1);\n\ninline D dot(P x,P y){return real(conj(x)*y);}\ninline D cross(P x,P y){return imag(conj(x)*y);}\nP rotate(P v,double s){\n  return P(real(v)*cos(s) - imag(v)*sin(s), real(v)*sin(s) + imag(v)*cos(s) );\n}\n/*\ninline D arg(P a,P b,P c){\n  D res = acos(dot(b-a,c-a)/(abs(b-a)*abs(c-a))); \n  return (cross(b-a,c-a)<0.0)?2*PI-res:res;\n}\n*/\ninline int ccw(P a,P b,P c){\n  b -= a;c -= a;\n  if (cross(b,c)>EPS) return 1;   //counter clockwise\n  if (cross(b,c)<-EPS) return -1; //clockwise\n  if (dot(b, c)<-EPS) return 2;   //c--a--b on line\n  if (abs(b)<abs(c)) return -2;   //a--b--c on line\n  return 0;                       //on segment\n}\n\nint h,r,n[3];\nD d[3],tmp1,tmp2,seta;\nP hp[110],up[3][110];\nD w[110],a[110];\n\nint main(){\n  while(cin >> h >> r,h){\n    rep(i,h){\n      cin >> tmp1 >> tmp2;\n      hp[i] = P(tmp1,tmp2);\n    }\n\n    rep(i,3)cin >> n[i]; rep(i,3)cin >> d[i], d[i] *= PI/180/2;\n\n    rep(i,3)rep(j,n[i]){\n      cin >> tmp1 >> tmp2;\n      up[i][j] = P(tmp1,tmp2);\n    }\n\n    rep(i,r)cin >> w[i] >> a[i], w[i] *= PI/180;\n\n    int num[110];\n    memset(num,0,sizeof(num));\n\n    rep(x,r)rep(id,h){\n      if( !(abs(hp[id]) < a[x] + EPS) )continue;\n      /*\n      seta = arg(P(0,0),P(100,0),hp[id]);\n      if( !(w[x]-d[0] < seta+EPS && seta < w[x]+d[0]+EPS)\n\t  && !(w[x]-d[0]+2*PI < seta+EPS && seta < w[x]+d[0]+2*PI+EPS) )continue;\n      */\n      P o = P(0,0), lp = rotate(P(1,0),w[x]+d[0]), rp = rotate(P(1,0),w[x]-d[0]);\n      if(ccw(o,lp,hp[id]) != -1 || ccw(o,rp,hp[id]) != 1)continue;\n\n      bool in = 0;\n      rep(i,3){\n\trep(j,n[i]){\n\t  if(abs(hp[id]-up[i][j]) < a[x] +EPS){\n\t    /*\n\t    P tmp = P(up[i][j].real() + 100.0, up[i][j].imag());\n\t    seta = arg(up[i][j],tmp,hp[id]);\n\t    if(w[x]-d[i] < seta+EPS && seta < w[x]+d[i]+EPS){\n\t      in = 1; break;\n\t    }\n\t    seta -= 2*PI;\n\t    if(w[x]-d[i] < seta+EPS && seta < w[x]+d[i]+EPS){\n\t      in = 1; break;\n\t    }\n\t    */\n\t    P o = up[i][j], lp = o + rotate(P(1,0),w[x]+d[i]), rp = o + rotate(P(1,0),w[x]-d[i]);\n\t    if(ccw(o,lp,hp[id]) == -1 && ccw(o,rp,hp[id]) == 1){\n\t      in = 1; break;\n\t    }\n\t  }\n\t}\n\tif(in)break;\n      }\n      if(!in)num[id]++;\n    }\n\n    int maxv = *max_element(num,num+h);\n    if(maxv==0)cout << \"NA\\n\";\n    else{\n      vector<int> ans;\n      rep(i,h){\n\tif(num[i] == maxv)ans.pb(i+1);\n      }\n      rep(i,ans.sz)cout << ans[i] << (i+1==ans.size()?\"\\n\":\" \");\n    }\n  }\n}"
  },
  {
    "language": "C++",
    "code": "#include <iostream>\n#include <cstdio>\n#include <iomanip>\n#include <vector>\n#include <map>\n#include <set>\n#include <queue>\n#include <bitset>\n#include <stack>\n#include <utility>\n#include <numeric>\n#include <algorithm>\n#include <functional>\n#include <cctype>\n#include <complex>\n#include <string>\n#include <sstream>\n#include <fstream>\n#include <cassert>\nusing namespace std;\n\n//common\ntypedef long long i64,ll;\n\n#define BR \"\\n\"\n#define ALL(c) (c).begin(),(c).end()\n#define REP(i,n) for(int i=0;i<(int)(n);++i)\n#define FOR(i,l,r) for(int i=(l);i<(int)(r);++i)\n#define EACH(it,o) for(auto it = (o).begin(); it != (o).end(); ++it)\n#define IN(l,v,r) ((l)<=(v) && (v)<(r))\n\n//debug\n#ifdef NDEBUG\n#define DUMP(x)\n#define DUMPLN(x)\n#define DEBUG(x)\n#define DEBUGLN(x)\n#define LINE()\n#define LINELN()\n#define CHECK(exp,act)\n#define STOP(e)\n#else\n#define DUMP(x)  cerr << #x << \" = \" << (x)\n#define DUMPLN(x)  DUMP(x) <<endl\n#define DEBUG(x) DUMP(x) << LINE() << \" \" << __FILE__\n#define DEBUGLN(x) DEBUG(x)<<endl\n#define LINE()    cerr<< \" (L\" << __LINE__ << \")\"\n#define LINELN()    LINE()<<endl\n#define CHECK(exp,act)  if(exp!=act){DUMPLN(exp);DEBUGLN(act);}\n#define STOP(e)  CHECK(e,true);if(!(e)) exit(1);\n#endif\n\ntemplate<class T> inline string toString(const vector<T>& x) {\n\tstringstream ss;\n\tREP(i,x.size()){\n\t\tif(i!=0)ss<<\" \";\n\t\tss<< x[i];\n\t}\n\treturn ss.str();\n}\n\ntemplate<class T> inline string toString(const vector<vector<T> >& map) {\n\tstringstream ss;\n\tREP(i,map.size()){\n\t\tif(i!=0)ss<<BR;\n\t\tss<< toString(map[i]);\n\t}\n\treturn ss.str();\n}\ntemplate<class K,class V>  string toString(map<K,V>& x) {\n\tstring res;stringstream ss;\n\tfor(auto& p:x)ss<< p.first<<\":\" << p.second<<\" \";\n\treturn ss.str();\n}\n\nstring BITtoString(int bit){\n    stringstream ss;\n    while(bit!=0){ss<<(bit%2);bit/=2;}\n    string res=ss.str();reverse(ALL(res));\n    return res;\n}\n\ntemplate<typename T,typename V> inline T pmod(T v,V MOD){\n\treturn (v%MOD+MOD)%MOD;\n}\ndouble pfmod(double v,double MOD){\n\treturn fmod(fmod(v,MOD)+MOD,MOD);\n}\n\nclass Comp{\npublic:\n\tbool operator () (const pair<int,int>& l,const pair<int,int>& r){\n\t\tif(l.first!=r.first)return l.first>r.first;\n\t\treturn l.second<r.second;\n\t}\n};\n\nnamespace Ps{\n\tconst double EPS = 1e-8;\n\tconst double INF = 1e12;\n\n\ttypedef complex<double> P;\n\t#define X(a) (real(a))\n\t#define Y(a) (imag(a))\n\t\n\t// a×b\n\tdouble cross(const P& a,const P& b){\n\t\treturn imag(conj(a)*b);\n\t}\n\t// a・b\n\tdouble dot(const P&a,const P& b) {\n\t\treturn real(conj(a)*b);\n\t}\n\n\t int ccw(const P& a,P b,P c){\n\t\tb -= a; c -= a;\n\t\t  if (cross(b,c) > 0)   return +1;       // counter clockwise\n\t\t  if (cross(b,c) < 0)   return -1;       // clockwise\n\t\t  if (dot(b,c) < 0)     return +2;       // c--a--b on line\n\t\t  if (norm(b) < norm(c)) return -2;       // a--b--c on line\n\t\t  return 0;\n\t  }\n}\nusing namespace Ps;\n\nclass Main{\npublic:\n\t\n\tbool canReach(int x,int y,int w,int a,int d){\n\t\tif((ll)x*x+(ll)y*y<=(ll)a*a)\n\t\tif(pfmod(abs(w*M_PI/180-atan2(y,x)),2*M_PI)<=d*M_PI/180/2)return true;\n\t\treturn false;\n\t}\n\n\tvoid run(){\n\n\t\twhile(true){\n\t\t\tint H,R;scanf(\"%d%d\",&H,&R);if(H==0)break;\n\n\t\t\tvector<int> xs(H),ys(H);\n\t\t\tREP(h,H)scanf(\"%d%d\",&xs[h],&ys[h]);\n\t\t\tint U,M,S,du,dm,ds;scanf(\"%d%d%d%d%d%d\",&U,&M,&S,&du,&dm,&ds);\n\n\t\t\tvector<int> uxs(U),uys(U);vector<int> mxs(M),mys(M);vector<int> sxs(S),sys(S);\n\t\t\tREP(i,U)scanf(\"%d%d\",&uxs[i],&uys[i]);\n\t\t\tREP(i,M)scanf(\"%d%d\",&mxs[i],&mys[i]);\n\t\t\tREP(i,S)scanf(\"%d%d\",&sxs[i],&sys[i]);\n\t\t\t\n\t\t\tvector<int> ws(R),as(R);\n\t\t\tREP(i,R)scanf(\"%d%d\",&ws[i],&as[i]);\n\n\n\t\t\tvector<pair<int,int>> res;\n\t\t\tREP(h,H){\n\t\t\t\tint x=xs[h],y=ys[h];\n\n\t\t\t\tint okc=0;\n\t\t\t\tREP(r,R){\n\t\t\t\t\tint w=ws[r],a=as[r];\n\t\t\t\t\tbool ok=false;\n\t\t\t\t\tif(canReach(x,y,w,a,du))ok=true;\n\t\t\t\t\t\n\t\t\t\t\tREP(i,U)if(canReach(x-uxs[i],y-uys[i],w,a,du))ok=false;\n\t\t\t\t\tREP(i,M)if(canReach(x-mxs[i],y-mys[i],w,a,dm))ok=false;\n\t\t\t\t\tREP(i,S)if(canReach(x-sxs[i],y-sys[i],w,a,ds))ok=false;\n\t\t\t\t\tif(ok)okc++;\n\t\t\t\t}\n\t\t\t\tres.push_back(make_pair(okc,h+1));\n\t\t\t}\n\t\t\tsort(ALL(res),Comp());\n\n\t\t\tint Mh=res[0].first;\n\t\t\t\n\t\t\tif(Mh==0){\n\t\t\t\tcout<<\"NA\"<<endl;continue;\n\t\t\t}\n\n\t\t\tfor(int i=0;i<H && Mh==res[i].first;i++){\n\t\t\t\tif(i!=0)cout <<\" \";\n\t\t\t\tcout << res[i].second; \n\t\t\t}\n\t\t\tcout <<endl;\n\t\t}\n\t}\n};\n\n int main(){\n\t//ios::sync_with_stdio(false);\n \tMain().run();\n \treturn 0;\n }"
  },
  {
    "language": "C++",
    "code": "#include<bits/stdc++.h>\n#define  Pi M_PI\nusing namespace std;\n#define int long long\ntypedef complex <double> P;\ndouble dot(P a,P b){return real(conj(a)*b);}\ndouble cross(P a,P b){return imag(conj(a)*b);}\nconst double EPS  = 1e-8;\n\nint ccw(P a,P b,P c){\n  b-= a;\n  c-=a;\n  if(cross(b,c) > EPS) return 1;\n  if(cross(b,c) < -EPS) return -1;\n  if(dot(b,c) < -EPS ) return 2;\n  if(norm(b) < norm(c)) return -2;\n  return 0;\n}\n\nbool check(P a,P t,double d,P h){\n  if(abs(t-h) > abs(a)) return 0;\n  h-=t;\n  d/=2;\n  d*= Pi/180;\n  P A = a * P(cos(d),sin(d));\n  P B = a * conj(P(cos(d),sin(d)));\n  return ccw(P(0,0),A,h)!=1&&ccw(P(0,0),B,h)!=-1;\n}\n\nsigned main(){\n  while(1){\n    int H,R;\n    cin>>H>>R;\n    if(!H&&!R)return 0;\n\n    P house[101];\n    for(int i=0;i<H;i++){\n      double x,y;\n      cin>>x>>y;\n      house[i] = P(x,y);\n    }\n\n    int U,M,S;\n    double du,dm,ds;\n    cin>>U>>M>>S>>du>>dm>>ds;\n\n    P UME[11],MO[11],SA[11];\n    for(int i=0;i<U;i++){\n      double x,y;\n      cin>>x>>y;\n      UME[i] = P(x,y);\n    }\n\n    for(int i=0;i<M;i++){\n      double x,y;\n      cin>>x>>y;\n      MO[i] = P(x,y);\n    }\n\n    for(int i=0;i<S;i++){\n      double x,y;\n      cin>>x>>y;\n      SA[i] = P(x,y);\n    }\n\n    int cnt[101]={};\n    for(int i=0;i<R;i++){\n      double w,d;\n      cin>>w>>d;\n      w*=Pi/180;\n      P a = P(cos(w),sin(w))*d;\n    \n      for(int j=0;j<H;j++){\n\tbool flg = check(a,P(0,0),du,house[j]);\n\tfor(int k=0;k<U;k++)flg &= !check(a,UME[k],du,house[j]);\n\tfor(int k=0;k<M;k++)flg &= !check(a,MO[k],dm,house[j]);\n\tfor(int k=0;k<S;k++)flg &= !check(a,SA[k],ds,house[j]);\n\tcnt[j] += flg;\n      }\n    }\n\n    int mx = 0;\n    for(int i=0;i<H;i++)mx = max(mx,cnt[i]);\n\n    if(mx==0) {cout<<\"NA\"<<endl;continue;}\n\n    int f=0;\n    for(int i=0;i<H;i++){\n      if(cnt[i] == mx) {\n\tif(f)cout<<\" \";\n\tf = 1;\n\tcout<<i+1;\n      }\n    }\n    cout<<endl;\n  }\n  \n    \n  return 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include<bits/stdc++.h>\nusing namespace std;\n\ntypedef pair<int,int>pint;\ntypedef vector<int>vint;\n#define pb push_back\n#define mp make_pair\n#define rep(i,n) for(int i=0;i<(n);i++)\ntemplate<class T,class U>void chmin(T &t,U f){if(t>f)t=f;}\ntemplate<class T,class U>void chmax(T &t,U f){if(t<f)t=f;}\n\ntypedef complex<double>P;\n\nconst double EPS=1e-9;\nconst double PI=acos(-1);\n\nconst int COUNTER_CLOCKWISE=1;\nconst int CLOCKWISE=-1;\nconst int ONLINE_BACK=2;\nconst int ONLINE_FRONT=-2;\nconst int ON_SEGMENT=0;\n\ninline double dot(const P &a, const P &b){return (conj(a) * b).real();}\ninline double cross(const P &a, const P &b){return (conj(a) * b).imag();}\n\ndouble toRad(double a){return a/180.0*PI;}\ndouble toDeg(double a){return a*180.0/PI;}\nP rotate(P p,double d){\n    return P(p.real()*cos(d)-p.imag()*sin(d),p.real()*sin(d)+p.imag()*cos(d));\n}\n\nP getP(){\n    double x,y;\n    scanf(\"%lf%lf\",&x,&y);\n    return P(x,y);\n}\n\nint ccw(P p0,P p1,P p2){\n    P a=p1-p0;\n    P b=p2-p0;\n    if(cross(a,b)>EPS)return COUNTER_CLOCKWISE;\n    if(cross(a,b)<-EPS)return CLOCKWISE;\n    if(dot(a,b)<-EPS)return ONLINE_BACK;\n    if(norm(a)<norm(b))return ONLINE_FRONT;\n    return ON_SEGMENT;\n}\n\nbool ok(P from,P to,double w,double a,double d){\n    if(abs(to-from)>a)return false;\n\n    w=toRad(w);\n    d=toRad(d);\n\n    P p0=from+P(cos(w),sin(w))*a;\n    P p1=rotate(p0,-d/2);\n    P p2=rotate(p0,d/2);\n\n    return (cross(p1-from,to-from)>EPS)&&(cross(p2-from,to-from)<EPS);\n}\n\nint H,R;\nvector<P>h;\n\nint U,M,S;\ndouble du,dm,ds;\nvector<P>u,m,s;\nvoid solve(){\n    h.resize(H);\n    rep(i,H)h[i]=getP();\n\n    scanf(\"%d%d%d\",&U,&M,&S);\n    scanf(\"%lf%lf%lf\",&du,&dm,&ds);\n\n    u.resize(U);\n    m.resize(M);\n    s.resize(S);\n    rep(i,U)u[i]=getP();\n    rep(i,M)m[i]=getP();\n    rep(i,S)s[i]=getP();\n\n    int cnt[100]={0};\n\n    while(R--){\n        double w,a;\n        scanf(\"%lf%lf\",&w,&a);\n        rep(i,H){\n            bool f=false;\n            if(ok(P(0,0),h[i],w,a,du))f=true;\n            rep(j,U)if(ok(u[j],h[i],w,a,du))f=false;\n            rep(j,M)if(ok(m[j],h[i],w,a,dm))f=false;\n            rep(j,S)if(ok(s[j],h[i],w,a,ds))f=false;\n            if(f)cnt[i]++;\n        }\n    }\n\n    int ma=*max_element(cnt,cnt+H);\n    if(ma==0){\n        puts(\"NA\");\n        return;\n    }\n\n    bool f=false;\n    rep(i,H){\n        if(cnt[i]!=ma)continue;\n        if(f)printf(\" \");\n        else f=true;\n        printf(\"%d\",i+1);\n    }\n    puts(\"\");\n}\n\nint main(){\n    while(scanf(\"%d%d\",&H,&R),H||R)solve();\n    return 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include <iostream>\n#include <cassert>\n#include <vector>\n#include <set>\n#include <queue>\n#include <algorithm>\n#include <cstdio>\n#include <cstring>\n#include <complex>\n#include <cmath>\n\nusing namespace std;\ntypedef long long ll;\n\ntypedef long double R;\ntypedef complex<R> P;\n\nnamespace std {\n    bool operator < (P a, P b) {\n        return real(a) != real(b) ? real(a) < real(b) : imag(a) < imag(b);\n    }\n    bool operator > (P a, P b) {\n        return (b < a);\n    }\n}\n\nconst R EPS = 1e-10;\nconst R PI = acos((R)(-1));\n\n/*\n -1 -> neg\n  0 -> near 0\n  1 -> pos\n  */\nint sgn(R a) {\n    if (a < -EPS) return -1;\n    if (a > EPS) return 1;\n    return 0;\n}\n\nint sgn(R a, R b) {\n    return sgn(b-a);\n}\n\nbool near(P a, P b) {\n    return !sgn(abs(a-b));\n}\n\nR cross(P a, P b) { return imag(conj(a)*b); }\nR dot(P a, P b) { return real(conj(a)*b); }\n\n\nR ssqrt(R d) {\n    d = max<R>(0, d);\n    return sqrt(d);\n}\n\nR sacos(R d) {\n    d = max<R>(-1, d);\n    d = min<R>(1, d);\n    return acos(d);\n}\n\nR deg2rad(R x) {\n    return x/180*PI;\n}\n\n//?§???????[0, 2*PI)???\nR radNorP(R x) {\n    return fmod(fmod(x, 2*PI) + 2*PI, 2*PI);\n}\n\n/**\n * radian??§???x???[l, r]?????\\??£????????????????????\\??????\n * 0:OFF\n * 1:IN\n * 2:ON\n */\nbool inR(R l, R r, R x) {\n    l = radNorP(l);\n    r = radNorP(r);\n    x = radNorP(x);\n    if (!sgn(l, x) || !sgn(r, x)) return 2;\n    if (!sgn(l, r)) return 0;\n    if (sgn(l, r) == 1) {\n        if (sgn(l, x) == 1 && sgn(x, r) == 1) return 1;\n    } else {\n        if (sgn(x, r) == 1 || sgn(l, x) == 1) return 1;\n    }\n    return 0;\n}\nstruct C {\n    P p;\n    R r;\n    C () {}\n    C (P p, R r) : p(p), r(r) {}\n};\nstruct Sec {\n    C c;\n    R l, r;\n    Sec() {}\n    Sec(C c, R l, R r) : c(c), l(l), r(r) {}\n};\n\nbool crossSecP(const Sec &s, const P &p) {\n    P pp = p - s.c.p;\n    if (sgn(s.c.r, abs(pp)) == 1) return false;\n    return inR(s.l, s.r, arg(pp)) > 0;\n}\n\nconst int MN = 200;\nint h, r, u, m, s;\nR du, dm, ds;\nP hp[MN];\nP up[MN], mp[MN], sp[MN];\nint res[MN];\n\nvoid calc(R w, R a) {\n    for (int i = 0; i < h; i++) {\n        if (!crossSecP(Sec(C(P(0, 0), a), w-du, w+du), hp[i])) continue;\n        bool f = true;\n        for (int j = 0; j < u; j++) {\n            if (crossSecP(Sec(C(up[j], a), w-du, w+du), hp[i])) f = false;\n        }\n        for (int j = 0; j < m; j++) {\n            if (crossSecP(Sec(C(mp[j], a), w-dm, w+dm), hp[i])) f = false;\n        }\n        for (int j = 0; j < s; j++) {\n            if (crossSecP(Sec(C(sp[j], a), w-ds, w+ds), hp[i])) f = false;\n        }\n        if (!f) continue;\n        res[i]++;\n    }\n}\n\nint main() {\n    while (true) {\n        cin >> h >> r;\n        if (!h && !r) break;\n        for (int i = 0; i < h; i++) {\n            R x, y;\n            cin >> x >> y;\n            hp[i] = P(x, y);\n        }\n        cin >> u >> m >> s >> du >> dm >> ds;\n        du /= 2; dm /= 2; ds /= 2;\n        du = deg2rad(du);\n        dm = deg2rad(dm);\n        ds = deg2rad(ds);\n        for (int i = 0; i < u; i++) {\n            R x, y;\n            cin >> x >> y;\n            up[i] = P(x, y);\n        }\n        for (int i = 0; i < m; i++) {\n            R x, y;\n            cin >> x >> y;\n            mp[i] = P(x, y);\n        }\n        for (int i = 0; i < s; i++) {\n            R x, y;\n            cin >> x >> y;\n            sp[i] = P(x, y);\n        }\n        memset(res, 0, sizeof(res));\n        for (int i = 0; i < r; i++) {\n            R x, y;\n            cin >> x >> y;\n            calc(deg2rad(x), y);\n        }\n        int ma = 0;\n        for (int i = 0; i < h; i++) {\n            ma = max(ma, res[i]);\n        }\n        if (ma == 0) {\n            cout << \"NA\" << endl;\n            continue;\n        }\n        vector<int> buf;\n        for (int i = 0; i < h; i++) {\n            if (res[i] == ma) buf.push_back(i);\n        }\n        for (int i = 0; i < (int)buf.size()-1; i++) {\n            cout << buf[i]+1 << \" \";\n        }\n        cout << buf[buf.size()-1]+1 << endl;\n    }\n    return 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include<bits/stdc++.h>\nusing namespace std;\n\nstruct Point {\n  double x;\n  double y;\n};\n\nint H, R;\nint U, M, S;\ndouble du, dm, ds;\nPoint h[101];\nPoint u[101], m[101], s[101];\ndouble w[101], a[101];\n\ndouble dist( Point a, Point b ) { //not sqrt\n  return ( pow((b.x - a.x), 2) + pow((b.y - a.y), 2) );\n}\n\nint main()\n{\n  cin >> H >> R;\n\n  for(int i=0; i<H; i++) {\n    Point p;\n    int x, y;\n    cin >> x >> y;\n    p.x = x; p.y = y;\n    h[i] = p;\n  }\n\n  cin >> U >> M >> S;\n  cin >> du >> dm >> ds;\n\n  for(int i=0; i<U; i++) {\n    Point p;\n    double x, y;\n    cin >> x >> y;\n    p.x = x; p.y = y;\n    u[i] = p;\n  }\n\n  for(int i=0; i<M; i++) {\n    Point p;\n    double x, y;\n    cin >> x >> y;\n    p.x = x; p.y = y;\n    m[i] = p;\n  }\n\n  for(int i=0; i<S; i++) {\n    Point p;\n    double x, y;\n    cin >> x >> y;\n    p.x = x; p.y = y;\n    s[i] = p;\n  }\n\n  for(int i=0; i<R; i++) cin >> w[i] >> a[i];\n  for(int i=0; i<R; i++) cout << w[i] << \" \" << a[i] << endl;\n\n  int cnt[101] = {0};\n  \n  for(int i=0; i<R; i++) {\n    \n    vector<int> tmp;\n    for(int j=0; j<H; j++) {\n      double myw, mya;\n      Point o; o.x = 0; o.y = 0;\n      \n      myw = atan( h[j].x / h[j].y ) * 180 / M_PI;\n      mya = dist( o, h[j] );\n      cout << w[i] << endl;\n      //printf(\"%lf %lf %lf %lf %lf\\n\", pow(a[i], 2), mya, w[i] - (du/2), w[i] + (du/2), myw);\n      if( pow(a[i], 2) < mya || w[i] - (du/2) > myw || myw > w[i] + (du/2) ) continue;\n      //cout << 'a' << endl;\n      bool flag = true;\n      for(int k=0; k<U; k++) {\n\tint tmpw = atan( (u[k].x - h[j].x) / (u[k].y - h[j].y) ) * 180 / M_PI;\n\tif( pow(a[i], 2) >= dist( u[k], h[j] ) || w[i] - (du/2) || tmpw || tmpw <= w[i] + (du/2) ) flag = false;\n      }\n\n      for(int k=0; k<M; k++) {\n\tint tmpw = atan( (m[k].x - h[j].x) / (m[k].y - h[j].y) ) * 180 / M_PI;\n\tif( pow(a[i], 2) >= dist( m[k], h[j] ) || w[i] - (dm/2) <= tmpw || tmpw <= w[i] + (dm/2) ) flag = false;\n      }\n\n      for(int k=0; k<S; k++) {\n\tint tmpw = atan( (s[k].x - h[j].x) / (s[k].y - h[j].y) ) * 180 / M_PI;\n\tif( pow(a[i], 2) >= dist( s[k], h[j] ) || w[i] - (ds/2) <= tmpw || tmpw <= w[i] + (ds/2) ) flag = false;\n      }\n\n      if( flag ) cnt[j]++;\n    }\n    \n  }\n\n  int ma = 0;\n  for(int i=0; i<H; i++) {\n    ma = max(ma, cnt[i]);\n  }\n\n  vector<int> ans;\n  for(int i=0; i<H; i++) {\n    if( cnt[i] == ma ) ans.push_back( i+1 ); \n  }\n\n  for(int i=0; i<ans.size()-1; i++) cout << ans[i] << \" \";\n  cout << ans[ans.size()-1] << endl;\n  \n}"
  },
  {
    "language": "C++",
    "code": "#include<bits/stdc++.h>\nusing namespace std;\n\ntypedef pair<int,int>pint;\ntypedef vector<int>vint;\n#define pb push_back\n#define mp make_pair\n#define rep(i,n) for(int i=0;i<(n);i++)\ntemplate<class T,class U>void chmin(T &t,U f){if(t>f)t=f;}\ntemplate<class T,class U>void chmax(T &t,U f){if(t<f)t=f;}\n\ntypedef complex<double>P;\n\nconst double EPS=1e-6;\nconst double PI=acos(-1);\n\nconst int COUNTER_CLOCKWISE=1;\nconst int CLOCKWISE=-1;\nconst int ONLINE_BACK=2;\nconst int ONLINE_FRONT=-2;\nconst int ON_SEGMENT=0;\n\ninline double dot(const P &a, const P &b){return (conj(a) * b).real();}\ninline double cross(const P &a, const P &b){return (conj(a) * b).imag();}\n\ndouble toRad(double a){return a/180.0*PI;}\ndouble toDeg(double a){return a*180.0/PI;}\nP rotate(P p,double d){\n    return P(p.real()*cos(d)-p.imag()*sin(d),p.real()*sin(d)+p.imag()*cos(d));\n}\n\nP getP(){\n    double x,y;\n    scanf(\"%lf%lf\",&x,&y);\n    return P(x,y);\n}\n\nint ccw(P p0,P p1,P p2){\n    P a=p1-p0;\n    P b=p2-p0;\n    if(cross(a,b)>EPS)return COUNTER_CLOCKWISE;\n    if(cross(a,b)<-EPS)return CLOCKWISE;\n    if(dot(a,b)<-EPS)return ONLINE_BACK;\n    if(norm(a)<norm(b))return ONLINE_FRONT;\n    return ON_SEGMENT;\n}\n\nbool ok(P from,P to,double w,double a,double d){\n    if(abs(to-from)>a)return false;\n\n    w=toRad(w);\n    d=toRad(d);\n\n    P p0=from+P(cos(w),sin(w))*a;\n    P p1=rotate(p0,-d/2);\n    P p2=rotate(p0,d/2);\n\n    return (cross(p1-from,to-from)>-EPS)&&(cross(p2-from,to-from)<EPS);\n\n\n\n\n    if(abs(to-from)>a)return false;\n\n    d=toRad(d);\n    w=toRad(w);\n\n    double left=w+d/2;\n    double right=w-d/2;\n    P vh=to-from;\n    P vl=a*P(cos(left),sin(left));\n    P vr=a*P(cos(right),sin(right));\n\n    return (cross(vr,vh)>-EPS)&&(cross(vh,vl)>-EPS);\n}\n\nint H,R;\nvector<P>h;\n\nint U,M,S;\ndouble du,dm,ds;\nvector<P>u,m,s;\nvoid solve(){\n    h.resize(H);\n    rep(i,H)h[i]=getP();\n\n    scanf(\"%d%d%d\",&U,&M,&S);\n    scanf(\"%lf%lf%lf\",&du,&dm,&ds);\n\n    u.resize(U);\n    m.resize(M);\n    s.resize(S);\n    rep(i,U)u[i]=getP();\n    rep(i,M)m[i]=getP();\n    rep(i,S)s[i]=getP();\n\n    int cnt[100]={0};\n\n    while(R--){\n        double w,a;\n        scanf(\"%lf%lf\",&w,&a);\n        rep(i,H){\n            bool f=false;\n            if(ok(P(0,0),h[i],w,a,du))f=true;\n            rep(j,U)if(ok(u[j],h[i],w,a,du))f=false;\n            rep(j,M)if(ok(m[j],h[i],w,a,dm))f=false;\n            rep(j,S)if(ok(s[j],h[i],w,a,ds))f=false;\n            if(f)cnt[i]++;\n        }\n    }\n\n    int ma=*max_element(cnt,cnt+H);\n    if(ma==0){\n        puts(\"NA\");\n        return;\n    }\n\n    bool f=false;\n    rep(i,H){\n        if(cnt[i]!=ma)continue;\n        if(f)printf(\" \");\n        else f=true;\n        printf(\"%d\",i+1);\n    }\n    puts(\"\");\n}\n\nint main(){\n    while(scanf(\"%d%d\",&H,&R),H||R)solve();\n    return 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include \"bits/stdc++.h\"\n#include<unordered_map>\n#include<unordered_set>\n#pragma warning(disable:4996)\nusing namespace std;\nusing ld = long double;\ntemplate<class T>\nusing Table = vector<vector<T>>;\nconst ld eps=1e-9;\n\n/* ??????????????¬ */\n\n#include <complex>\n\ntypedef long double ld;\ntypedef complex<ld> Point;\n#define REP(i,n) for(int i=0;i<(int)(n);i++)\n#define ALL(x) (x).begin(),(x).end()\n\n\nconst ld pi = acos(-1.0);\nconst ld dtop = pi / 180.;\nconst ld ptod = 1. / dtop;\n\nnamespace std {\n\tbool operator<(const Point &lhs, const Point &rhs) {\n\t\tif (lhs.real() < rhs.real() - eps) return true;\n\t\tif (lhs.real() > rhs.real() + eps) return false;\n\t\treturn lhs.imag() < rhs.imag();\n\t}\n}\n\n// ????????\\???\nPoint input_point() {\n\tld x, y;\n\tcin >> x >> y;\n\treturn Point(x, y);\n}\n\n// ????????????????????????\nbool eq(const ld a, const ld b) {\n\treturn (abs(a - b) < eps);\n}\n\n// ??????\nld dot(const Point& a, const Point& b) {\n\treturn real(conj(a) * b);\n}\n\n// ??????\nld cross(const Point& a, const Point& b) {\n\treturn imag(conj(a) * b);\n}\n\n// ??´????????????\nclass Line {\npublic:\n\tPoint a, b;\n\tLine() : a(Point(0, 0)), b(Point(0, 0)) {}\n\tLine(Point a, Point b) : a(a), b(b) {}\n\tPoint operator[](const int _num)const {\n\t\tif (_num == 0)return a;\n\t\telse if (_num == 1)return b;\n\t\telse {\n\t\t\tassert(false);\n\t\t\treturn Point();\n\t\t}\n\t}\n};\n\n// ????????????\nclass Circle {\npublic:\n\tPoint p;\n\tld r;\n\tCircle() : p(Point(0, 0)), r(0) {}\n\tCircle(Point p, ld r) : p(p), r(r) {}\n};\n\n// CCW\nint ccw(const Point& a, const Point &b, const Point &c) {\n\tconst Point nb(b - a);\n\tconst Point nc(c - a);\n\tif (cross(nb, nc) > eps) return 1;   // a,b,c??????????¨???¨?????????????????¶\n\tif (cross(nb, nc) < -eps) return -1; // a,b,c???????¨???¨?????????????????¶\n\tif (dot(nb, nc) < 0) return 2;       // c,a,b???????????´???????????¶\n\tif (norm(nb) < norm(nc)) return -2;  // a,b,c???????????´???????????¶\n\treturn 0;                          // a,c,b???????????´???????????¶\n}\n\n\n/* ???????????? */\n\n// ??´?????¨??´??????????????????\nbool isis_ll(const Line& l, const Line& m) {\n\treturn !eq(cross(l.b - l.a, m.b - m.a), 0);\n}\n\n// ??´?????¨?????????????????????\nbool isis_ls(const Line& l, const Line& s) {\n\treturn isis_ll(l, s) &&\n\t\t(cross(l.b - l.a, s.a - l.a) * cross(l.b - l.a, s.b - l.a) < eps);\n}\n\n// ????????¨?????????????????????\nbool isis_ss(const Line& s, const Line& t) {\n\treturn ccw(s.a, s.b, t.a) * ccw(s.a, s.b, t.b) <= 0 &&\n\t\tccw(t.a, t.b, s.a) * ccw(t.a, t.b, s.b) <= 0;\n}\n\n// ????????´????????????\nbool isis_lp(const Line& l, const Point& p) {\n\treturn (abs(cross(l.b - p, l.a - p)) < eps);\n}\n\n// ?????????????????????\nbool isis_sp(const Line& s, const Point& p) {\n\treturn (abs(s.a - p) + abs(s.b - p) - abs(s.b - s.a) < eps);\n}\n\n// ??????????¶?\nPoint proj(const Line &l, const Point& p) {\n\tld t = dot(p - l.a, l.a - l.b) / norm(l.a - l.b);\n\treturn l.a + t * (l.a - l.b);\n}\n\n// ??´?????¨??´????????????\nPoint is_ll(const Line &s, const Line& t) {\n\tPoint sv = s.b - s.a, tv = t.b - t.a;\n\tassert(cross(sv, tv) != 0);\n\treturn s.a + sv * cross(tv, t.a - s.a) / cross(tv, sv);\n}\n// ??´?????¨??´????????????\nvector<Point> is_ll2(const Line &s, const Line& t) {\n\tPoint sv = s.b - s.a, tv = t.b - t.a;\n\tif (cross(sv, tv) != 0)return vector<Point>(1, is_ll(s, t));\n\telse {\n\t\tvector<Point>ans;\n\t\tfor (int k = 0; k < 2; ++k) {\n\t\t\tif (isis_sp(s, t[k]) && find(ans.begin(), ans.end(), t[k]) == ans.end())ans.push_back(t[k]);\n\t\t\tif (isis_sp(t, s[k]) && find(ans.begin(), ans.end(), s[k]) == ans.end())ans.push_back(s[k]);\n\t\t}\n\t\treturn ans;\n\t}\n}\n// ????????¨???????????????\n//???????????£????????¨???????????¨assert(false)\nPoint is_ss(const Line &s, const Line& t) {\n\tif (isis_ss(s, t)) {\n\t\tfor (int k = 0; k < 2; ++k) {\n\t\t\tfor (int l = 0; l < 2; ++l) {\n\t\t\t\tif (s[k] == t[l])return s[k];\n\t\t\t}\n\t\t}\n\t\treturn is_ll(s, t);\n\t}\n\telse {\n\t\t//??????isis_ss?????????\n\t\tassert(false);\n\t\treturn Point(0, 0);\n\t}\n}\n// ????????¨???????????????\nvector<Point> is_ss2(const Line &s, const Line& t) {\n\tvector<Point> kouho(is_ll2(s, t));\n\tvector<Point>ans;\n\tfor (auto p : kouho) {\n\t\tif (isis_sp(s, p) && isis_sp(t, p))ans.emplace_back(p);\n\t}\n\treturn ans;\n}\n// ??´?????¨???????????¢\nld dist_lp(const Line& l, const Point& p) {\n\treturn abs(p - proj(l, p));\n}\n\n// ??´?????¨??´???????????¢\nld dist_ll(const Line& l, const Line& m) {\n\treturn isis_ll(l, m) ? 0 : dist_lp(l, m.a);\n}\n\n// ??´?????¨??????????????¢\nld dist_ls(const Line& l, const Line& s) {\n\treturn isis_ls(l, s) ? 0 : min(dist_lp(l, s.a), dist_lp(l, s.b));\n}\n\n// ????????¨???????????¢\nld dist_sp(const Line& s, const Point& p) {\n\tPoint r = proj(s, p);\n\treturn isis_sp(s, r) ? abs(r - p) : min(abs(s.a - p), abs(s.b - p));\n}\n\n// ????????¨??????????????¢\nld dist_ss(const Line& s, const Line& t) {\n\tif (isis_ss(s, t)) return 0;\n\treturn min({ dist_sp(s, t.a), dist_sp(s, t.b), dist_sp(t, s.a), dist_sp(t, s.b) });\n}\n\n\n//??´?????¨??´?????????????????????????????????\nLine bisection(const Line &s, const Line &t) {\n\tconst Point laglanju(is_ll(s, t));\n\tconst Point avec = !(abs(laglanju - s[0])<eps) ? s[0] - laglanju : s[1] - laglanju;\n\tconst Point bvec = !(abs(laglanju - t[0])<eps) ? t[0] - laglanju : t[1] - laglanju;\n\n\treturn Line(laglanju, laglanju + (abs(bvec)*avec + abs(avec)*bvec) / (abs(avec) + abs(bvec)));\n}\n\n\n//???????????´?????????????????????\n//???????????´??????????????§???????????¨????¢?????????¨?????????\nPoint  inner_center(const vector<Line>&ls) {\n\tvector<Point>vertics;\n\tfor (int i = 0; i <static_cast<int>(ls.size()); ++i) {\n\t\tvertics.push_back(is_ll(ls[i], ls[(i + 1) % 3]));\n\t}\n\tif (vertics[0] == vertics[1] || vertics[1] == vertics[2] || vertics[2] == vertics[0])return vertics[0];\n\tLine bi1(bisection(Line(vertics[0], vertics[1]), Line(vertics[0], vertics[2])));\n\tLine bi2(bisection(Line(vertics[1], vertics[2]), Line(vertics[1], vertics[0])));\n\tif (bi1[0] == bi2[0])return bi1[0];\n\telse {\n\t\treturn is_ll(bi1, bi2);\n\t}\n}\n\n//???????????´?????????????????????\n//???????????´??????????????§???????????¨????¢?????????¨?????????\nvector<Point>  ex_center(const vector<Line>&ls) {\n\tvector<Point>vertics;\n\tfor (int i = 0; i < static_cast<int>(ls.size()); ++i) {\n\t\tvertics.push_back(is_ll(ls[i], ls[(i + 1) % 3]));\n\t}\n\tif (abs(vertics[0] - vertics[1])<eps || abs(vertics[1] - vertics[2])<eps || (abs(vertics[2] - vertics[0])<eps))return vector<Point>();\n\tvector<Point>ecs;\n\tfor (int i = 0; i < 3; ++i) {\n\t\tLine bi1(bisection(Line(vertics[i], vertics[i] * 2.0l - vertics[(i + 2) % 3]), Line(vertics[i], vertics[(i + 1) % 3])));\n\t\tLine bi2(bisection(Line(vertics[(i + 1) % 3], vertics[(i + 1) % 3] * 2.0l - vertics[(i + 2) % 3]), Line(vertics[(i + 1) % 3], vertics[i])));\n\t\tecs.push_back(is_ll(bi1, bi2));\n\t}\n\treturn ecs;\n}\n\n\n//a,b:??????\n//c:????????§??????\n//???????????´?????????????????¢?????????????±??????????\nvector<Point>  same_dis(const vector<Line>&ls) {\n\tvector<Point>vertics;\n\tvertics.push_back(is_ll(ls[0], ls[2]));\n\tvertics.push_back(is_ll(ls[1], ls[2]));\n\n\tif (abs(vertics[0] - vertics[1]) < eps)return vector<Point>{vertics[0]};\n\tLine bis(bisection(ls[0], ls[1]));\n\tvector<Point>ecs;\n\n\tLine abi(bisection(Line(vertics[0], vertics[1]), ls[0]));\n\tecs.push_back(is_ll(bis, abi));\n\n\n\tLine bbi(bisection(Line(vertics[0], 2.l*vertics[0] - vertics[1]), ls[0]));\n\tecs.push_back(is_ll(bis, bbi));\n\n\treturn ecs;\n}\n/* ??? */\n\n// ?????¨????????????\nvector<Point> is_cc(const Circle& c1, const Circle& c2) {\n\tvector<Point> res;\n\tld d = abs(c1.p - c2.p);\n\tld rc = (d * d + c1.r * c1.r - c2.r * c2.r) / (2 * d);\n\tld dfr = c1.r * c1.r - rc * rc;\n\tif (abs(dfr) < eps) dfr = 0.0;\n\telse if (dfr < 0.0) return res; // no intersection\n\tld rs = sqrt(dfr);\n\tPoint diff = (c2.p - c1.p) / d;\n\tres.push_back(c1.p + diff * Point(rc, rs));\n\tif (dfr != 0.0) res.push_back(c1.p + diff * Point(rc, -rs));\n\treturn res;\n}\n\n//???????????????????????????\n//  0 => out\n//  1 => on\n//  2 => in\nint is_in_circle(const Circle &cir, const  Point& p) {\n\tld dis = abs(cir.p - p);\n\tif (dis > cir.r + eps)return 0;\n\telse if (dis < cir.r - eps)return 2;\n\telse return 1;\n}\n//???lc??????rc??????????????????\n//  0 => out\n//  1 => on\n//  2 => in\nint circle_in_circle(const Circle &lc, const  Circle&rc) {\n\tld dis = abs(lc.p - rc.p);\n\tif (dis < rc.r - lc.r - eps)return 2;\n\telse if (dis>rc.r - lc.r + eps)return 0;\n\telse return 1;\n}\n\n// ?????¨??´????????????\nvector<Point> is_lc(const Circle& c, const Line& l) {\n\tvector<Point> res;\n\tld d = dist_lp(l, c.p);\n\tif (d < c.r + eps) {\n\t\tld len = (d > c.r) ? 0.0 : sqrt(c.r * c.r - d * d); //safety;\n\t\tPoint nor = (l.a - l.b) / abs(l.a - l.b);\n\t\tres.push_back(proj(l, c.p) + len * nor);\n\t\tres.push_back(proj(l, c.p) - len * nor);\n\t}\n\treturn res;\n}\n\n// ?????¨??????????????¢\nvector<Point> is_sc(const Circle& c, const Line& l) {\n\tvector<Point> v = is_lc(c, l), res;\n\tfor (Point p : v)\n\t\tif (isis_sp(l, p)) res.push_back(p);\n\treturn res;\n}\n\n// ?????¨????????\\???\nvector<Line> tangent_cp(const Circle& c, const Point& p) {\n\tvector<Line> ret;\n\tPoint v = c.p - p;\n\tld d = abs(v);\n\tld l = sqrt(norm(v) - c.r * c.r);\n\tif (isnan(l)) { return ret; }\n\tPoint v1 = v * Point(l / d, c.r / d);\n\tPoint v2 = v * Point(l / d, -c.r / d);\n\tret.push_back(Line(p, p + v1));\n\tif (l < eps) return ret;\n\tret.push_back(Line(p, p + v2));\n\treturn ret;\n}\n\n// ?????¨????????\\???\nvector<Line> tangent_cc(const Circle& c1, const Circle& c2) {\n\tvector<Line> ret;\n\tif (abs(c1.p - c2.p) - (c1.r + c2.r) > -eps) {\n\t\tPoint center = (c1.p * c2.r + c2.p * c1.r) / (c1.r + c2.r);\n\t\tret = tangent_cp(c1, center);\n\t}\n\tif (abs(c1.r - c2.r) > eps) {\n\t\tPoint out = (-c1.p * c2.r + c2.p * c1.r) / (c1.r - c2.r);\n\t\tvector<Line> nret = tangent_cp(c1, out);\n\t\tret.insert(ret.end(), ALL(nret));\n\t}\n\telse {\n\t\tPoint v = c2.p - c1.p;\n\t\tv /= abs(v);\n\t\tPoint q1 = c1.p + v * Point(0, 1) * c1.r;\n\t\tPoint q2 = c1.p + v * Point(0, -1) * c1.r;\n\t\tret.push_back(Line(q1, q1 + v));\n\t\tret.push_back(Line(q2, q2 + v));\n\t}\n\treturn ret;\n}\n//??????????????????????????¢???\nld two_circle_area(const Circle&l, const Circle&r) {\n\tld dis = abs(l.p - r.p);\n\tif (dis > l.r + r.r)return 0;\n\telse if (dis + r.r < l.r) {\n\t\treturn r.r*r.r*pi;\n\t}\n\telse if (dis + l.r < r.r) {\n\t\treturn l.r*l.r*pi;\n\t}\n\telse {\n\t\tld ans = (l.r)*(l.r)*acos((dis*dis + l.r*l.r - r.r*r.r) / (2 * dis*l.r)) +\n\t\t\t(r.r)*(r.r)*acos((dis*dis + r.r*r.r - l.r*l.r) / (2 * dis*r.r)) -\n\t\t\tsqrt(4 * dis*dis*l.r*l.r - (dis*dis + l.r*l.r - r.r*r.r)*(dis*dis + l.r*l.r - r.r*r.r)) / 2;\n\t\treturn ans;\n\t}\n\n}\n\n/* ????§???¢ */\n\ntypedef vector<Point> Polygon;\n\n// ??¢???\nld area(const Polygon &p) {\n\tld res = 0;\n\tint n = p.size();\n\tREP(j, n) res += cross(p[j], p[(j + 1) % n]);\n\treturn res / 2;\n}\n\n// ????§???¢????????¢??????\nbool is_counter_clockwise(const Polygon &poly) {\n\tld angle = 0;\n\tint n = poly.size();\n\tREP(i, n) {\n\t\tPoint a = poly[i], b = poly[(i + 1) % n], c = poly[(i + 2) % n];\n\t\tangle += arg((c - b) / (b - a));\n\t}\n\treturn angle > eps;\n}\n\n// ??????????????????\n//  0 => out\n//  1 => on\n//  2 => in\nint is_in_polygon(const Polygon &poly, const  Point& p) {\n\tld angle = 0;\n\tint n = poly.size();\n\tREP(i, n) {\n\t\tPoint a = poly[i], b = poly[(i + 1) % n];\n\t\tif (isis_sp(Line(a, b), p)) return 1;\n\t\tangle += arg((b - p) / (a - p));\n\t}\n\treturn eq(angle, 0) ? 0 : 2;\n}\n//??????????????????2?????????\nenum { OUT, ON, IN };\nint convex_contains(const Polygon &P, const Point &p) {\n\tconst int n = P.size();\n\tPoint g = (P[0] + P[n / 3] + P[2 * n / 3]) / 3.0l; // inner-point\n\tint a = 0, b = n;\n\twhile (a + 1 < b) { // invariant: c is in fan g-P[a]-P[b]\n\t\tint c = (a + b) / 2;\n\t\tif (cross(P[a] - g, P[c] - g) > 0) { // angle < 180 deg\n\t\t\tif (cross(P[a] - g, p - g) > 0 && cross(P[c] - g, p - g) < 0) b = c;\n\t\t\telse                                                  a = c;\n\t\t}\n\t\telse {\n\t\t\tif (cross(P[a] - g, p - g) < 0 && cross(P[c] - g, p - g) > 0) a = c;\n\t\t\telse                                                  b = c;\n\t\t}\n\t}\n\tb %= n;\n\tif (cross(P[a] - p, P[b] - p) < 0) return 0;\n\tif (cross(P[a] - p, P[b] - p) > 0) return 2;\n\treturn 1;\n}\n\n// ??????\n// ???????????????????????¨????????????????????§??¨???\nPolygon convex_hull(vector<Point> ps) {\n\tint n = ps.size();\n\tint k = 0;\n\tsort(ps.begin(), ps.end());\n\tPolygon ch(2 * n);\n\tfor (int i = 0; i < n; ch[k++] = ps[i++])\n\t\twhile (k >= 2 && ccw(ch[k - 2], ch[k - 1], ps[i]) <= 0) --k;\n\tfor (int i = n - 2, t = k + 1; i >= 0; ch[k++] = ps[i--])\n\t\twhile (k >= t && ccw(ch[k - 2], ch[k - 1], ps[i]) <= 0) --k;\n\tch.resize(k - 1);\n\treturn ch;\n}\n\n\n\n// ????????????\nvector<Polygon> convex_cut(const Polygon &ps, const Line& l) {\n\tint n = ps.size();\n\tPolygon Q;\n\tPolygon R;\n\tREP(i, n) {\n\t\tPoint A = ps[i], B = ps[(i + 1) % n];\n\t\tLine m = Line(A, B);\n\t\tif (ccw(l.a, l.b, A) != -1) Q.push_back(A);\n\t\tif (ccw(l.a, l.b, A) != 1) R.push_back(A);\n\t\tif (ccw(l.a, l.b, A) * ccw(l.a, l.b, B) < 0 && isis_ll(l, m)) {\n\t\t\tQ.push_back(is_ll(l, m));\n\t\t\tR.push_back(is_ll(l, m));\n\t\t}\n\t}\n\tconst vector<Polygon>polys{ Q,R };\n\treturn polys;\n}\n\n\n/* ??¢??¬??????????????? */\nvoid add_point(vector<Point> &ps, const Point p) {\n\tfor (Point q : ps) if (abs(q - p) < eps) return;\n\tps.push_back(p);\n}\n\ntypedef int Weight;\nstruct Edge {\n\tint src, dst;\n\tWeight weight;\n\tEdge(int src, int dst, Weight weight) :\n\t\tsrc(src), dst(dst), weight(weight) { }\n};\n\ntypedef vector<Edge> Edges;\ntypedef vector<Edges> Graph;\n\nvoid add_edge(Graph &g, const int from, const int to, const Weight weight) {\n\tg[from].push_back(Edge{ from, to, weight });\n}\n\nGraph segment_arrangement(const vector<Line> &s, const vector<Point> &p) {\n\tint n = p.size(), m = s.size();\n\tGraph g(n);\n\tREP(i, m) {\n\t\tvector<pair<ld, int>> vec;\n\t\tREP(j, n) if (isis_sp(s[i], p[j]))\n\t\t\tvec.emplace_back(abs(s[i].a - p[j]), j);\n\t\tsort(ALL(vec));\n\t\tREP(j, vec.size() - 1) {\n\t\t\tint from = vec[j].second, to = vec[j + 1].second;\n\t\t\tadd_edge(g, from, to, static_cast<Weight>(abs(p[from] - p[to])));\n\t\t}\n\t}\n\treturn g;\n}\nGraph sennbunn_arrangement(const vector<Line>&s) {\n\tvector<Point>crss;\n\tfor (int i = 0; i < static_cast<int>(s.size()); ++i) {\n\t\tfor (int j = i + 1; j < static_cast<int>(s.size()); ++j) {\n\t\t\tif (isis_ss(s[i], s[j])) {\n\t\t\t\tcrss.push_back(is_ll(s[i], s[j]));\n\t\t\t}\n\t\t}\n\t}\n\tfor (int i = 0; i <static_cast<int>(s.size()); ++i) {\n\t\tcrss.push_back(s[i][0]);\n\t\tcrss.push_back(s[i][1]);\n\t}\n\treturn segment_arrangement(s, crss);\n}\n\n//Graph circle_arrangement(const vector<Circle> &c, const vector<Point> &p) {\n//\tint n = p.size(), m = c.size();\n//\tGraph g(n);\n//\tREP(i, m) {\n//\t\tvector<pair<ld, int>> vec;\n//\t\tREP(j, n) if (abs(abs(c[i].p - p[j]) - c[i].r) < eps)\n//\t\t\tvec.emplace_back(arg(c[i].p - p[j]), j);\n//\t\tsort(ALL(vec));\n//\t\tREP(j, vec.size() - 1) {\n//\t\t\tint from = vec[j].second, to = vec[j + 1].second;\n//\t\t\tld angle = vec[j + 1].first - vec[j].first;\n//\t\t\tadd_edge(g, from, to, static_cast<Weight>(angle * c[i].r));\n//\t\t}\n//\t\tif (vec.size() >= 2) {\n//\t\t\tint from = vec.back().second, to = vec.front().first;\n//\t\t\tld angle = vec.front().first - vec.back().first;\n//\t\t\tadd_edge(g, from, to, static_cast<Weight>(angle * c[i].r));\n//\t\t}\n//\t}\n//\treturn g;\n//}\n\n\n/* ????????°?????? */\n\n// ?????????????????¢?????¢??¬??????????????????????????????????????°???????????????\n// ?????´?????????????¨?????????§????????´????????????????¨?????????§???????????????\n// ?????° polygon ??????vector<int> ??§??¨?????????????§???¢???????????§?????????\n// vector<int> ??§??¨????????? ????§???¢???i???????????????????????????????????????p????????????????????§?????????\nvector<vector<int>> polygon;\nvector<int> seg2p[1024][1024];\n\n//Graph dual_graph(const vector<Line> &s, const vector<Point> &p) {\n//\tint N = p.size();\n//\tpolygon.clear();\n//\tREP(i, 1024) REP(j, 1024) seg2p[i][j].clear();\n//\tvector<vector<tuple<ld, int, bool>>> tup(N);\n//\tREP(i, s.size()) {\n//\t\tint a = -1, b = -1;\n//\t\tREP(j, N) if (abs(s[i].a - p[j]) < eps) a = j;\n//\t\tREP(j, N) if (abs(s[i].b - p[j]) < eps) b = j;\n//\t\tassert(a >= 0 && b >= 0);\n//\t\ttup[a].emplace_back(arg(s[i].b - s[i].a), b, false);\n//\t\ttup[b].emplace_back(arg(s[i].a - s[i].b), a, false);\n//\t}\n//\tREP(i, N) sort(ALL(tup[i]));\n//\tREP(i, N) {\n//\t\tREP(j, tup[i].size()) {\n//\t\t\tld angle; int pos = j, from = i, to; bool flag;\n//\t\t\ttie(angle, to, flag) = tup[i][j];\n//\t\t\tif (flag) continue;\n//\t\t\tvector<int> ps;\n//\t\t\twhile (!flag) {\n//\t\t\t\tps.push_back(from);\n//\t\t\t\tget<2>(tup[from][pos]) = true;\n//\t\t\t\tseg2p[from][to].push_back(polygon.size());\n//\t\t\t\tseg2p[to][from].push_back(polygon.size());\n//\t\t\t\tangle += pi + eps;\n//\t\t\t\tif (angle > pi) angle -= 2 * pi;\n//\t\t\t\tauto it = lower_bound(ALL(tup[to]), make_tuple(angle, 0, false));\n//\t\t\t\tif (it == tup[to].end()) it = tup[to].begin();\n//\t\t\t\tfrom = to; tie(angle, to, flag) = *it;\n//\t\t\t\tpos = it - tup[from].begin();\n//\t\t\t}\n//\t\t\tpolygon.push_back(ps);\n//\t\t}\n//\t}\n//\tGraph g(polygon.size());\n//\tREP(i, N) REP(j, i) {\n//\t\tif (seg2p[i][j].size() == 2) {\n//\t\t\tint from = seg2p[i][j][0], to = seg2p[i][j][1];\n//\t\t\tg[from].push_back(Edge{ from, to });\n//\t\t\tg[to].push_back(Edge{ to, from });\n//\t\t}\n//\t}\n//\treturn g;\n//}\n\nstruct flo {\n\tPoint p;\n\tld the;\n};\nbool check(const flo&f, const Point p,const ld len,const ld theta) {\n\tconst ld dis = abs(f.p - p);\n\tif (dis-eps > len) {\n\t\treturn false;\n\t}\n\telse {\n\t\tld kaku = atan2(p.imag() - f.p.imag(), p.real() - f.p.real());\n\t\tif (p.real() > f.p.real()) {\n\n\t\t}\n\t\telse {\n\t\t\tkaku += pi / 2.;\n\t\t}\n\t\tld sa = abs(kaku - theta);\n\t\tsa = min(sa, 2 * pi - sa);\n\t\tif (sa < f.the / 2)return true;\n\t\telse return false;\n\t}\n}\nint main() {\n\twhile (1) {\n\t\tvector<Point>houses;\n\t\tint H, R; cin >> H >> R;\n\t\tif (!H)break;\n\t\tfor (int i = 0; i < H; ++i) {\n\t\t\tint x, y; cin >> x >> y;\n\t\t\thouses.emplace_back(x, y);\n\t\t}\n\t\tint U, M, S;ld du, dm, ds;  cin >> U >> M >> S >> du >> dm >> ds;\n\t\tdu *= dtop;\n\t\tdm *= dtop;\n\t\tds *= dtop;\n\t\tvector<flo>flowers;\n\t\tfor (int i = 0; i < U; ++i) {\n\t\t\tint x, y; cin >> x >> y;\n\t\t\tflowers.push_back(flo{ Point(x,y),du });\n\t\t}\n\t\tfor (int i = 0; i < M; ++i) {\n\t\t\tint x, y; cin >> x >> y;\n\t\t\tflowers.push_back(flo{ Point(x,y),dm });\n\t\t}\n\t\tfor (int i = 0; i < S; ++i) {\n\t\t\tint x, y; cin >> x >> y;\n\t\t\tflowers.push_back(flo{ Point(x,y),ds });\n\t\t}\n\t\tflo myflower{ Point(0,0),du };\n\t\tint ans = 0;\n\t\tvector<int>nums(H);\n\t\tfor (int i = 0; i < R; ++i) {\n\t\t\tld w, a; cin >> a >> w;\n\t\t\ta *= dtop;\n\t\t\tfor (int h = 0; h < H; ++h) {\n\t\t\t\tPoint p(houses[h]);\n\t\t\t\tif (check(myflower, p, w, a)) {\n\n\t\t\t\t\tbool aok = true;\n\t\t\t\t\tfor (auto f : flowers) {\n\t\t\t\t\t\tif (check(f, p, w, a)) {\n\t\t\t\t\t\t\taok = false;\n\t\t\t\t\t\t\tbreak;\n\t\t\t\t\t\t}\n\t\t\t\t\t}\n\t\t\t\t\tif (aok) {\n\t\t\t\t\t\tnums[h]++;\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t\tint amax = *max_element(nums.begin(), nums.end());\n\t\tif (amax) {\n\t\t\tvector<int>anss;\n\t\t\tfor (int i = 0; i < H; ++i) {\n\t\t\t\tif (amax == nums[i]) {\n\t\t\t\t\tanss.push_back(i+1);\n\t\t\t\t}\n\t\t\t}\n\t\t\tfor (int i = 0; i < anss.size(); ++i) {\n\t\t\t\tcout << anss[i];\n\t\t\t\tif (i != anss.size() - 1)cout << \" \";\n\t\t\t\telse cout << endl;\n\t\t\t}\n\t\t}\n\t\telse {\n\t\t\tcout << \"NA\" << endl;\n\t\t}\n\t}\n\treturn 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include<bits/stdc++.h>\nusing namespace std;\n\ntypedef pair<int,int>pint;\ntypedef vector<int>vint;\n#define pb push_back\n#define mp make_pair\n#define rep(i,n) for(int i=0;i<(n);i++)\ntemplate<class T,class U>void chmin(T &t,U f){if(t>f)t=f;}\ntemplate<class T,class U>void chmax(T &t,U f){if(t<f)t=f;}\n\ntypedef complex<double>P;\n\nconst double EPS=1e-6;\nconst double PI=acos(-1);\n\nconst int COUNTER_CLOCKWISE=1;\nconst int CLOCKWISE=-1;\nconst int ONLINE_BACK=2;\nconst int ONLINE_FRONT=-2;\nconst int ON_SEGMENT=0;\n\ninline double dot(const P &a, const P &b){return (conj(a) * b).real();}\ninline double cross(const P &a, const P &b){return (conj(a) * b).imag();}\n\ndouble toRad(double a){return a/180.0*PI;}\ndouble toDeg(double a){return a*180.0/PI;}\nP rotate(P p,double d){\n    return P(p.real()*cos(d)-p.imag()*sin(d),p.real()*sin(d)+p.imag()*cos(d));\n}\n\nP getP(){\n    double x,y;\n    scanf(\"%lf%lf\",&x,&y);\n    return P(x,y);\n}\n\nint ccw(P p0,P p1,P p2){\n    P a=p1-p0;\n    P b=p2-p0;\n    if(cross(a,b)>EPS)return COUNTER_CLOCKWISE;\n    if(cross(a,b)<-EPS)return CLOCKWISE;\n    if(dot(a,b)<-EPS)return ONLINE_BACK;\n    if(norm(a)<norm(b))return ONLINE_FRONT;\n    return ON_SEGMENT;\n}\n\nbool ok(P from,P to,double w,double a,double d){\n    if(abs(to-from)>a)return false;\n\n    d=toRad(d);\n    w=toRad(w);\n\n    double left=w+d/2;\n    double right=w-d/2;\n    P vh=to-from;\n    P vl=a*P(cos(left),sin(left));\n    P vr=a*P(cos(right),sin(right));\n\n    return (cross(vr,vh)>-EPS)&&(cross(vh,vl)>-EPS);\n}\n\nint H,R;\nvector<P>h;\n\nint U,M,S;\ndouble du,dm,ds;\nvector<P>u,m,s;\nvoid solve(){\n    h.resize(H);\n    rep(i,H)h[i]=getP();\n\n    scanf(\"%d%d%d\",&U,&M,&S);\n    scanf(\"%lf%lf%lf\",&du,&dm,&ds);\n\n    u.resize(U);\n    m.resize(M);\n    s.resize(S);\n    rep(i,U)u[i]=getP();\n    rep(i,M)m[i]=getP();\n    rep(i,S)s[i]=getP();\n\n    int cnt[100]={0};\n\n    while(R--){\n        double w,a;\n        scanf(\"%lf%lf\",&w,&a);\n        rep(i,H){\n            bool f=false;\n            if(ok(P(0,0),h[i],w,a,du))f=true;\n            rep(j,U)if(ok(u[j],h[i],w,a,du))f=false;\n            rep(j,M)if(ok(m[j],h[i],w,a,dm))f=false;\n            rep(j,S)if(ok(s[j],h[i],w,a,ds))f=false;\n            if(f)cnt[i]++;\n        }\n    }\n\n    int ma=*max_element(cnt,cnt+H);\n    if(ma==0){\n        puts(\"NA\");\n        return;\n    }\n\n    bool f=false;\n    rep(i,H){\n        if(cnt[i]!=ma)continue;\n        if(f)printf(\" \");\n        else f=true;\n        printf(\"%d\",i+1);\n    }\n    puts(\"\");\n}\n\nint main(){\n    while(scanf(\"%d%d\",&H,&R),H||R)solve();\n    return 0;\n}"
  },
  {
    "language": "C++",
    "code": "\n//自分の梅は任意の地点でかおるとする。→間違い。\n//EPSはつけない。\n//扇形と家は接しないので、距離はsqrtで求めた。\n\n#include<iostream>\n#include<cmath>\n#include<vector>\n#define rep(i,n) for(i = 0;i < n;i++)\n#define PI 3.14159265358979\nusing namespace std;\n\ntypedef pair<double,double> P;\n\nint H,R;\t\t\t\t//家数,日数\nint hx[100],hy[100];\t//家の座標\nint U,M,S;\t\t\t\t//梅、桃、桜の数\nint du,dm,ds;\t\t\t//梅、桃、桜の扇形の中心角\nint ux[100],uy[100];\t//梅の座標\nint mx[100],my[100];\t//桃の座標\nint sx[100],sy[100];\t//桜の座標\nint w[100],a[100];\t\t//扇形の方向(角度),風の強さ\n\n//半径,角度の順で格納し、返す\n//rotateは角度補正( 補正 = rotate*360 )\nP POLAR( int treex,int treey,int housex,int housey,int rotate )\n{\n\tP ans;\n\tans.first = (housex-treex)*(housex-treex) + (housey-treey)*(housey-treey);\n\tans.first = sqrt( ans.first );\n\tans.second = atan2( (double)housey - treey, (double)housex - treex ) * 180 / PI;\n\tans.second += 360*rotate;\n\treturn ans;\n}\n\nint main()\n{\n\tint i,j,k,l;\n\twhile( cin >> H >> R )\n\t{\n\t\tint day[100] = {0};\t\t//i番目の家において、他の木の香りが届かなかった日数\n\n\t\tif( H == 0 && R == 0 )\n\t\t\tbreak;\n\t\trep(i,H)\n\t\t\tcin >> hx[i] >> hy[i];\n\t\tcin >> U >> M >> S >> du >> dm >> ds;\n\t\trep(i,U)\n\t\t\tcin >> ux[i] >> uy[i];\n\t\trep(i,M)\n\t\t\tcin >> mx[i] >> my[i];\n\t\trep(i,S)\n\t\t\tcin >> sx[i] >> sy[i];\n\t\trep(i,R)\n\t\t\tcin >> w[i] >> a[i];\n\t\t//ここから探索\n\t\trep(i,R){\n\t\t\trep(j,H){\n\t\t\t\trep(k,U){\n\t\t\t\t\trep(l,3){\n\t\t\t\t\t\tP t = POLAR( ux[k],uy[k],hx[j],hy[j],l-1 );\n\t\t\t\t\t\t//判定\n\t\t\t\t\t\tif( t.first <= a[i] && fabs( (double)w[i] - t.second ) <= (double)du/2.0 )\n\t\t\t\t\t\t\tbreak;\n\t\t\t\t\t}\n\t\t\t\t\tif(l < 3)\n\t\t\t\t\t\tbreak;\n\t\t\t\t}\n\t\t\t\tif(k < U)\n\t\t\t\t\tcontinue;\n\t\t\t\trep(k,M){\n\t\t\t\t\trep(l,3){\n\t\t\t\t\t\tP t = POLAR( mx[k],my[k],hx[j],hy[j],l-1 );\n\t\t\t\t\t\t//判定\n\t\t\t\t\t\tif( t.first <= a[i] && fabs( (double)w[i] - t.second ) <= (double)dm/2.0 )\n\t\t\t\t\t\t\tbreak;\n\t\t\t\t\t}\n\t\t\t\t\tif(l < 3)\n\t\t\t\t\t\tbreak;\n\t\t\t\t}\n\t\t\t\tif(k < M)\n\t\t\t\t\tcontinue;\n\t\t\t\trep(k,S){\n\t\t\t\t\trep(l,3){\n\t\t\t\t\t\tP t = POLAR( sx[k],sy[k],hx[j],hy[j],l-1 );\n\t\t\t\t\t\t//判定\n\t\t\t\t\t\tif( t.first <= a[i] && fabs( (double)w[i] - t.second ) <= (double)ds/2.0 )\n\t\t\t\t\t\t\tbreak;\n\t\t\t\t\t}\n\t\t\t\t\tif(l < 3)\n\t\t\t\t\t\tbreak;\n\t\t\t\t}\n\t\t\t\tif(k < S)\n\t\t\t\t\tcontinue;\n\n\t\t\t\t//私の梅の香りは届くのか！！\n\t\t\t\trep(l,3){\n\t\t\t\t\tP t = POLAR( 0,0,hx[j],hy[j],l-1 );\n\t\t\t\t\t//判定\n\t\t\t\t\tif( t.first <= a[i] && fabs( (double)w[i] - t.second ) <= du/2.0 )\n\t\t\t\t\t\tbreak;\n\t\t\t\t}\n\t\t\t\tif( l < 3 )\n\t\t\t\t\tday[j]++;\n\t\t\t}\n\t\t}\n\t\tint maxday = 0;\n\t\trep(i,H){\n\t\t\tmaxday = max( maxday,day[i] );\n\t\t}\n\t\tif( maxday == 0 ){\n\t\t\tcout << \"NA\" << endl;\n\t\t\tcontinue;\n\t\t}\n\t\trep(i,H){\n\t\t\tif( day[i] == maxday ){\n\t\t\t\tcout << i+1;\n\t\t\t\tif( i < H-1 )\n\t\t\t\t\tcout << ' ';\n\t\t\t\telse\n\t\t\t\t\tcout << endl;\n\t\t\t}\n\t\t}\n\t}\n\treturn 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include<iostream>\n#include<vector>\n#include<cmath>\n#include<algorithm>\nusing namespace std;\n\nconst double PI = 3.14159265358979;\n\nclass Point {\npublic:\n    double x, y;\n    Point(double x = 0.0, double y = 0.0) :x(x), y(y) {}\n};\n\nclass Wind {\npublic:\n    double w, a;\n};\n\nbool include(double angle, double low, double high) {\n    if(low < 0.0 && 2.0 * PI + low <= angle) return true;\n    if(high >= 2.0 * PI && angle <= high - 2.0 * PI) return true;\n    return low <= angle && angle <= high;\n}\n\nbool savor(const Point &home, const Wind &wind, const vector<Point> &blossom, double d) {\n    d /= 2.0;\n    for(const auto &b: blossom) {\n        Point dif(home.x - b.x, home.y - b.y);\n        double angle = atan2(dif.y, dif.x);\n        double dist = hypot(dif.y, dif.x);\n        if(angle < 0.0) angle = 2.0 * PI + angle;\n        if(dist <= wind.a && include(angle, wind.w - d, wind.w + d)) return true;\n    }\n    return false;\n}\n\ndouble toRadian(double d) {\n    return d * PI / 180.0;\n}\n\nint main() {\n    int H, R;\n    while(cin >> H >> R, H | R) {\n        vector<Point> home(H);\n        for(auto &i: home) cin >> i.x >> i.y;\n\n        int U, M, S;\n        double du, dm, ds;\n        cin >> U >> M >> S >> du >> dm >> ds;\n\n        du = toRadian(du);\n        dm = toRadian(dm);\n        ds = toRadian(ds);\n\n        vector<Point> plum(U), peach(M), cherry(S);\n        for(auto &i: plum) cin >> i.x >> i.y;\n        for(auto &i: peach) cin >> i.x >> i.y;\n        for(auto &i: cherry) cin >> i.x >> i.y;\n\n        vector<Wind> wind(R);\n        for(auto &i: wind) cin >> i.w >> i.a;\n        for(auto &i: wind) i.w = toRadian(i.w);\n\n        // solve\n        vector<int> number(H, 0);\n        int maxNumber = 0;\n\n        for(int i = 0; i < H; ++i) {\n            for(int day = 0; day < R; ++day) {\n                bool ok = savor(home[i], wind[day], {Point(0.0, 0.0)}, du);\n                bool ng = false;\n                ng |= savor(home[i], wind[day], plum, du);\n                ng |= savor(home[i], wind[day], peach, dm);\n                ng |= savor(home[i], wind[day], cherry, ds);\n\n                if(!ok || ng) continue;\n\n                ++number[i];\n                maxNumber = max(maxNumber, number[i]);\n            }\n        }\n\n        if(maxNumber) {\n            bool first = true;\n            for(int i = 0; i < H; ++i) if(number[i] == maxNumber) {\n                if(!first) cout << \" \";\n                first = false;\n                cout << i + 1;\n            }\n            cout << endl;\n        } else {\n            cout << \"NA\" << endl;\n        }\n    }\n}"
  },
  {
    "language": "C++",
    "code": "#include <cstdio>\n#include <iostream>\n#include <sstream>\n#include <fstream>\n#include <iomanip>\n#include <algorithm>\n#include <cmath>\n#include <string>\n#include <vector>\n#include <list>\n#include <queue>\n#include <stack>\n#include <set>\n#include <map>\n#include <bitset>\n#include <numeric>\n#include <climits>\n#include <cfloat>\nusing namespace std;\n\nconst double PI = acos(-1.0);\n\nclass Point\n{\npublic:\n    double y, x;\n    Point(){\n        y = x = 0.0;\n    }\n    Point(double y0, double x0){\n        y = y0;\n        x = x0;\n    }\n    Point operator+(const Point& p) const{\n        return Point(y + p.y, x + p.x);\n    }\n    Point operator-(const Point& p) const{\n        return Point(y - p.y, x - p.x);\n    }\n    Point operator*(double a) const{\n        return Point(y * a, x * a);\n    }\n    Point operator/(double a) const{\n        return Point(y / a, x / a);\n    }\n    double length() const{\n        return sqrt(y * y + x * x);\n    }\n    double dist(const Point& p) const{\n        return sqrt(pow(y - p.y, 2) + pow(x - p.x, 2));\n    }\n    double dot(const Point& p) const{\n        return y * p.y + x * p.x; // |a|*|b|*cos慮\n    }\n    double cross(const Point& p) const{\n        return x * p.y - y * p.x; // |a|*|b|*sin慮\n    }\n};\n\nbool check(Point& h, vector<Point>& t, double angle, double dir, double len)\n{\n    int m = t.size();\n\n    for(int i=0; i<m; ++i){\n        if(h.dist(t[i]) > len)\n            continue;\n\n        double theta = atan2(h.y - t[i].y, h.x - t[i].x);\n        for(int j=-1; j<=1; ++j){\n            if(dir - angle/2 + 2*PI*j < theta && theta < dir + angle/2 + 2*PI*j)\n                return true;\n        }\n    }\n\n    return false;\n}\n\nint main()\n{\n    for(;;){\n        int n, r;\n        cin >> n >> r;\n        if(n == 0)\n            return 0;\n\n        vector<Point> h(n);\n        for(int i=0; i<n; ++i)\n            cin >> h[i].x >> h[i].y;\n\n        vector<int> m(3);\n        vector<double> angle(3);\n        for(int i=0; i<3; ++i)\n            cin >> m[i];\n        for(int i=0; i<3; ++i){\n            cin >> angle[i];\n            angle[i] *= PI / 180;\n        }\n\n        vector<vector<Point> > t(3);\n        for(int i=0; i<3; ++i){\n            t[i].resize(m[i]);\n            for(int j=0; j<m[i]; ++j)\n                cin >> t[i][j].x >> t[i][j].y;\n        }\n\n        vector<double> dir(r), len(r);\n        for(int i=0; i<r; ++i){\n            cin >> dir[i] >> len[i];\n            dir[i] *= PI / 180;\n        }\n\n        vector<int> ret;\n        int maxDay = 1;\n        for(int i=0; i<n; ++i){\n            int day = 0;\n            for(int j=0; j<r; ++j){\n                bool ok = true;\n                for(int k=0; k<3; ++k){\n                    if(check(h[i], t[k], angle[k], dir[j], len[j]))\n                        ok = false;\n                }\n\n                if(ok && check(h[i], vector<Point>(1, Point(0, 0)), angle[0], dir[j], len[j]))\n                    ++ day;\n            }\n\n            if(day > maxDay){\n                ret.assign(1, i+1);\n                maxDay = day;\n            }else if(day == maxDay){\n                ret.push_back(i+1);\n            }\n        }\n\n        if(ret.empty()){\n            cout << \"NA\" << endl;\n        }else{\n            cout << ret[0];\n            for(unsigned i=1; i<ret.size(); ++i)\n                cout << ' ' << ret[i];\n            cout << endl;\n        }\n    }\n}"
  },
  {
    "language": "C++",
    "code": "#include<iostream>\n#include<vector>\n#include<cmath>\n#include<algorithm>\n#include<numeric>\nusing namespace std;\n \nconst double PI = 3.14159265358979;\n \nclass Point {\npublic:\n    double x, y;\n    Point(double x = 0.0, double y = 0.0) :x(x), y(y) {}\n};\n \nclass Wind {\npublic:\n    double w, a;\n};\n \nbool include(double angle, double low, double high) {\n    if(low < 0.0) {\n        double l = low + 2.0 * PI;\n        if(l <= angle) return true;\n    }\n    if(high > 2.0 * PI) {\n        double h = high - 2.0 * PI;\n        if(angle <= h) return true;\n    }\n    return low <= angle && angle <= high;\n}\n \nbool savor(const Point &home, const Wind &wind, const vector<Point> &blossom, double d) {\n    d /= 2.0;\n    for(const auto &b: blossom) {\n        Point dif(home.x - b.x, home.y - b.y);\n        double angle = atan2(dif.y, dif.x);\n        double dist = hypot(dif.y, dif.x);\n        if(angle < 0.0) angle = angle + 2.0 * PI;\n        if(dist <= wind.a && include(angle, wind.w - d, wind.w + d)) return true;\n    }\n    return false;\n}\n \ndouble toRadian(double d) {\n    return d * PI / 180.0;\n}\n \nint main() {\n    int H, R;\n    while(cin >> H >> R, H | R) {\n        vector<Point> home(H);\n        for(auto &i: home) cin >> i.x >> i.y;\n \n        int U, M, S;\n        double du, dm, ds;\n        cin >> U >> M >> S >> du >> dm >> ds;\n \n        du = toRadian(du);\n        dm = toRadian(dm);\n        ds = toRadian(ds);\n \n        vector<Point> plum(U), peach(M), cherry(S);\n        for(auto &i: plum) cin >> i.x >> i.y;\n        for(auto &i: peach) cin >> i.x >> i.y;\n        for(auto &i: cherry) cin >> i.x >> i.y;\n \n        vector<Wind> wind(R);\n        for(auto &i: wind) cin >> i.w >> i.a;\n        for(auto &i: wind) i.w = toRadian(i.w);\n \n        // solve\n        vector<int> number(H, 0);\n        int maxNumber = 0;\n \n        for(int i = 0; i < H; ++i) {\n            for(int day = 0; day < R; ++day) {\n                bool ok = savor(home[i], wind[day], {Point(0.0, 0.0)}, du);\n                bool ng = false;\n                ng |= savor(home[i], wind[day], plum, du);\n                ng |= savor(home[i], wind[day], peach, dm);\n                ng |= savor(home[i], wind[day], cherry, ds);\n \n                if(!ok || ng) continue;\n \n                ++number[i];\n                maxNumber = max(maxNumber, number[i]);\n            }\n        }\n \n        if(maxNumber) {\n            bool first = true;\n            for(int i = 0; i < H; ++i) if(number[i] == maxNumber) {\n                if(!first) cout << \" \";\n                first = false;\n                cout << i + 1;\n            }\n            cout << endl;\n        } else {\n            cout << \"NA\" << endl;\n        }\n    }\n}"
  },
  {
    "language": "C++",
    "code": "#include <stdio.h>\n#include <string.h>\n#include <math.h>\n#define PI 3.1415926535897932384626433832795028841971693993751058209749445923078164\n\nstruct point{\n\tint x,y;\n};\n\nstruct wind{\n\tint w,a;\n};\n\ndouble getlen(int x1,int y1,int x2,int y2){\n\treturn sqrt(pow((x1-x2)*1.0,2)+pow((y1-y2)*1.0,2));\n}\n\nint check(int N,point *tree,point house,wind wind,int dtree){\n\tint i;\n\tdouble rad,dig,up,down;\n\n\tfor(i = 0;i < N;i++){\n\t\tif(wind.a*1.0 < getlen(house.x,house.y,tree[i].x,tree[i].y)){\n\t\t\treturn 1;\n\t\t}\n\t\trad = atan2((house.y-tree[i].y)*1.0,(house.x-tree[i].x)*1.0);\n\t\tdig = fmod((rad * 180.0 / PI)+360.0,360.0);\n\t\tup = wind.w*1.0+dtree/2.0;\n\t\tdown = wind.w*1.0-dtree/2.0;\n\t\tif(up >= 360.0){\n\t\t\tif((0.0 <= dig && dig <= up-360.0) || (down <= dig && dig < 360.0)){\n\t\t\t\treturn 0;\n\t\t\t}\n\t\t}else if(down < 0.0){\n\t\t\tif((0.0 <= dig && dig <= up) || (down+360.0 <= dig && dig < 360.0)){\n\t\t\t\treturn 0;\n\t\t\t}\n\t\t}else{\n\t\t\tif(down <= dig && dig <= up){\n\t\t\t\treturn 0;\n\t\t\t}\n\t\t}\n    }\n\n\treturn 1;\n}\n\nint check2(point house,wind wind,int dtree){\n\tdouble rad,dig,up,down;\n\n\tif(wind.a*1.0 < getlen(house.x,house.y,0,0)){\n\t\treturn 0;\n\t}\n\n\trad = atan2(house.y*1.0,house.x*1.0);\n\tdig = fmod((rad * 180.0 / PI)+360.0,360.0);\n\tup = wind.w*1.0+dtree/2.0;\n\tdown = wind.w*1.0-dtree/2.0;\n\tif(up >= 360.0){\n\t\tif(!((0.0 <= dig && dig <= up-360.0) || (down <= dig && dig < 360.0))){\n\t\t\treturn 0;\n\t\t}\n\t}else if(down < 0.0){\n\t\tif(!((0.0 <= dig && dig <= up) || (down+360.0 <= dig && dig < 360.0))){\n\t\t\treturn 0;\n\t\t}\n\t}else{\n\t\tif(!(down <= dig && dig <= up)){\n\t\t\treturn 0;\n\t\t}\n\t}\n\treturn 1;\n}\n\nvoid max(int H,int *ok){\n\tint i,p,dmax;\n\tint tmp[100];\n\n\tp = 0;\n\tdmax = 0;\n\n\tfor(i = 0;i < H;i++){\n\t\tif(dmax < ok[i]){\n\t\t\tdmax = ok[i];\n\t\t\ttmp[0] = i+1;\n\t\t\tp = 1;\n\t\t}else if(dmax != 0 && dmax == ok[i]){\n\t\t\ttmp[p++] = i+1;\n\t\t}\n\t}\n\n\tif(dmax == 0){\n\t\tprintf(\"NA\\n\");\n\t}else{\n\t\tfor(i = 0;i < p;i++){\n\t\t\tprintf(\"%d%c\",tmp[i],(i == p-1) ? '\\n' : ' ');\n\t\t}\n\t}\n}\n\nint main(){\n\tint i,j,H,R,U,M,S,du,dm,ds;\n\tint ok[100];\n\tpoint h[100],u[10],m[10],s[10];\n\twind wind[100];\n\n\twhile(1){\n\t\tmemset(ok,0,sizeof(ok));\n\t\tscanf(\"%d %d\",&H,&R);\n\t\tif(H == 0 && R == 0){\n\t\t\tbreak;\n\t\t}\n\t\tfor(i = 0;i < H;i++){\n\t\t\tscanf(\"%d %d\",&h[i].x,&h[i].y);\n\t\t}\n\t\tscanf(\"%d %d %d %d %d %d\",&U,&M,&S,&du,&dm,&ds);\n\t\tfor(i = 0;i < U;i++){\n\t\t\tscanf(\"%d %d\",&u[i].x,&u[i].y);\n\t\t}\n\t\tfor(i = 0;i < M;i++){\n\t\t\tscanf(\"%d %d\",&m[i].x,&m[i].y);\n\t\t}\n\t\tfor(i = 0;i < S;i++){\n\t\t\tscanf(\"%d %d\",&s[i].x,&s[i].y);\n\t\t}\n\t\tfor(i = 0;i < R;i++){\n\t\t\tscanf(\"%d %d\",&wind[i].w,&wind[i].a);\n\t\t}\n\t\n\t\tfor(i = 0;i < R;i++){\n\t\t\tfor(j = 0;j < H;j++){\n\t\t\t\tif(!check2(h[j],wind[i],du)){\n\t\t\t\t\tcontinue;\n\t\t\t\t}\n\t\t\t\tif(!check(U,u,h[j],wind[i],du)){\n\t\t\t\t\tcontinue;\n\t\t\t\t}\n\t\t\t\tif(!check(M,m,h[j],wind[i],dm)){\n\t\t\t\t\tcontinue;\n\t\t\t\t}\n\t\t\t\tif(!check(S,s,h[j],wind[i],ds)){\n\t\t\t\t\tcontinue;\n\t\t\t\t}\n\t\t\t\tok[j]++;\n\t\t\t}\n\t\t}\n\t\n\t\tmax(H,ok);\n\t}\n\n\treturn 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include<iostream>\n#include<vector>\n#include<math.h>\n#include<complex>\n\n#define EPS 1e-4\n\n#define PI 3.141592\n#define EQ(a,b) (abs((a)-(b))<EPS)\nusing namespace std;\n\ntypedef complex<double> P;\n\nvector<P> house;\nvector<P> ume,sak,mo;\n\ndouble cross(P v1,P v2){\n\treturn v1.real()*v2.imag()-v1.imag()*v2.real();\n}\n\nbool che(P h,P t,double d,double w,double a){\n\tP v=h-t;\n\tif(!(abs(v)<=a+EPS))return false;\n\t\n\tP v1=P(a*cos((w+d/2)/180*PI),a*sin((w+d/2)/180*PI));\n\tP v2=P(a*cos((w-d/2)/180*PI),a*sin((w-d/2)/180*PI));\n\t\n\tif(cross(v1,v)<=EPS && cross(v2,v)>=-EPS)return true;\n\telse return false;\n}\n\nint main(){\n\tint h,r;\n\t\n\twhile(cin>>h>>r && h&&r){\n\t\thouse.clear();\n\t\tume.push_back(P(0,0));\n\t\tfor(int i=0;i<h;i++){\n\t\t\tint x,y;\n\t\t\tcin>>x>>y;\n\t\t\thouse.push_back(P(x,y));\n\t\t}\n\t\t\n\t\tint U,M,S,du,dm,ds;\n\t\tcin>>U>>M>>S>>du>>dm>>ds;\n\t\tfor(int i=0;i<U;i++){\n\t\t\tint x,y;\n\t\t\tcin>>x>>y;\n\t\t\tume.push_back(P(x,y));\n\t\t}\n\t\tfor(int i=0;i<M;i++){\n\t\t\tint x,y;\n\t\t\tcin>>x>>y;\n\t\t\tmo.push_back(P(x,y));\n\t\t}\n\t\tfor(int i=0;i<S;i++){\n\t\t\tint x,y;\n\t\t\tcin>>x>>y;\n\t\t\tsak.push_back(P(x,y));\n\t\t}\n\t\t\n\t\t\n\t\tint data[120];\n\t\tfor(int i=0;i<120;i++)data[i]=0;\n\t\tfor(int z=0;z<r;z++){\n\t\t\tint w,a;\n\t\t\tcin>>w>>a;\n\t\t\t\n\t\t\tfor(int i=0;i<house.size();i++){\n\t\t\t\tbool ok=false;\n\t\t\t\tif(che(house[i],ume[0],du,w,a))ok=true;\n\t\t\t\telse continue;\n\t\t\t\tfor(int j=1;j<U;j++){\n\t\t\t\t\tif(che(house[i],ume[j],du,w,a))ok=false;\n\t\t\t\t}\n\t\t\t\tfor(int j=0;j<M;j++){\n\t\t\t\t\tif(che(house[i],mo[j],dm,w,a))ok=false;\n\t\t\t\t}\n\t\t\t\tfor(int j=0;j<S;j++){\n\t\t\t\t\tif(che(house[i],sak[j],ds,w,a))ok=false;\n\t\t\t\t}\n\t\t\t\t\n\t\t\t\tif(ok)data[i]++;\n\t\t\t}\n\t\t}\n\t\t\n\t\t\tint ans=0;\n\t\t\tint tmp=-1;\n\t\t\tfor(int i=0;i<h;i++){\n\t\t\t\tif(ans<=data[i]){\n\t\t\t\t\tans=data[i];\n\t\t\t\t\ttmp=i;\n\t\t\t\t}\n\t\t\t}\n\t\t\tif (ans==0)cout<<\"NA\"<<endl;\n\t\t\telse {\n\t\t\t\tfor(int i=0;i<h;i++){\n\t\t\t\t\tif(i==tmp)cout<<i+1;\n\t\t\t\t\telse if(data[i]==ans)cout<<i+1<<\" \";\n\t\t\t\t\t\n\t\t\t\t}\n\t\t\t\tcout<<endl;\n\t\t\t}\n\t\t\t\n\t\t\n\t}\n}"
  },
  {
    "language": "C++",
    "code": "#include <iostream>\n#include <string>\n#include <vector>\n#include <algorithm>\n#include <cmath>\n\n#define REP(i,k,n) for(int i=k;i<n;i++)\n#define rep(i,n) for(int i=0;i<n;i++)\n#define EPS 1e-8\n#define equals(a,b) fabs((a) - (b)) < EPS\n#define PI acos(-1)\n\nusing namespace std;\n\nstruct Point\n{\n    double x, y;\n\n    Point(double x=0, double y=0) : x(x), y(y) {}\n\n    Point operator+(const Point &o) const { return Point(x+o.x, y+o.y); }\n\n    Point operator-(const Point &o) const { return Point(x-o.x, y-o.y); }\n\n    Point operator*(const double m) const { return Point(x*m, y*m); }\n\n    Point operator/(const double d) const { return Point(x/d, y/d); }\n\n    Point operator<(const Point &o) const { return x != o.x ? x < o.x : y < o.y; }\n\n\tbool operator==(const Point &o) const { return fabs(x-o.x) < EPS && fabs(y-o.y) < EPS; }\n\n\tdouble cross(const Point &o) const { return x * o.y - y * o.x; }\n\n    double dot(const Point &o) const { return x * o.x + y * o.y; }\n\n    double atan() const { return atan2(y, x); }\n\n\tdouble deg() const { return atan() * 180.0 / (acos(-1) * 4.0); }\n\n    double norm() const { return sqrt(dot(*this)); }\n\n    double distance(const Point &o) const { return (o - (*this)).norm(); }\n\n    double area(const Point &a,const Point &b)\n    {\n\t    Point p = a - (*this), p2 = b - (*this); \n\t    return p.cross(p2);\n    }\n\n    double area_abs(const Point &a,const Point &b) const\n    {\n\t    Point p = a - (*this), p2 = b - (*this);\n\t    return fabs(p.cross(p2)) / 2.0;\n    }\t\n\n    //線分abが自身に含まれているのかどうか判断する\n    int between(const Point &a,const Point &b)\n\t{\n\t\tif(area(a,b) != 0) return 0;\n\n    \tif(a.x != b.x)\n\t    {\n\t\t    return ((a.x <= x) && (x <= b.x) || (a.x >= x) && (x >= b.x));\n\t    }\n\t    else\n\t    {\n\t    \treturn ((a.y <= y) && (y <= b.y) || (a.y >= y) && (y >= b.y));\n\t    }\n    }      \n\n\tdouble distance_seg(const Point& a,const Point& b)\n\t{\n    \tif((b-a).dot(*this-a) < EPS)\n    \t{\n\t    \treturn (*this-a).norm();\n\t    }\n\t    if((a-b).dot(*this-b) < EPS)\n    \t{\n\t    \treturn (*this-b).norm();\n    \t}\n\t    return abs((b-a).cross(*this-a)) / (b-a).norm();\n    }\n\n    bool hitPolygon(const Point& a,const Point& b,const Point& c)\n\t{\n    \tdouble t = (b-a).cross(*this-b);\n    \tdouble t2 = (c-b).cross(*this-c);\n    \tdouble t3 = (a-c).cross(*this-a);\n    \tif((t > 0 && t2 > 0 && t3 > 0) || ( t < 0 && t2 < 0 && t3 < 0))\n    \t{\n    \t\treturn true;\n    \t}\n\n\t    return false;\n    }\n};\n\nint ccw(Point a,Point b,Point c)\n{\n    b = b-a;\n    c = c-a;\n\n    if(b.cross(c) > EPS) return +1;\t//conter clockwise\n    if(b.cross(c) < -EPS) return -1;\t//clockwise\n    if(b.dot(c) < -EPS) return +2;\t//a on Seg(b,c)\n    if(b.norm() < c.norm()) return -2;\t//b on Seg(a,c)\n    return 0;\t//c on Seg(a,b)\n}\n\nbool inPolygon(Point p,Point a,Point b,Point c)\n{\n\tif(ccw(a,b,p) == -1 && ccw(a,c,p) == +1) return true;\n\n\treturn false;\n}\n\ndouble to_rad(double deg)\n{\n\treturn deg*PI/180;\n}\n\nbool hit(Point s,Point v,double d,double w,double a)\n{\n\tif(s.distance(v) > a) return false;\n\n\tdouble x = a*cos(to_rad(w + d/2));\n\tdouble y = a*sin(to_rad(w + d/2));\n\tPoint p(x,y);\n\n\tx = a*cos(to_rad(w - d/2));\n\ty = a*sin(to_rad(w - d/2));\n\tPoint p2(x,y);\n\n\tif(inPolygon(v,s,s+p,s+p2)) return true;\n\treturn false;\n}\n\nint main()\n{\n\tint h,r;\n\twhile(cin >> h >> r)\n\t{\n\t\tif(h == 0 && r == 0) break;\n\n\t\tvector<Point> v;\n\t\trep(i,h)\n\t\t{\n\t\t\tdouble x,y;\n\t\t\tcin >> x >> y;\n\t\t\tv.push_back(Point(x,y));\n\t\t}\n\n\t\tint u,m,s;\n\t\tdouble du,dm,ds;\n\t\tcin >> u >> m >> s >> du >> dm >> ds;\n\n\t\tvector<Point> ume;\n\t\trep(i,u)\n\t\t{\n\t\t\tdouble x,y;\n\t\t\tcin >> x >> y;\n\t\t\tume.push_back(Point(x,y));\n\t\t}\n\t\t\n\t\tvector<Point> momo;\n\t\trep(i,m)\n\t\t{\n\t\t\tdouble x,y;\n\t\t\tcin >> x >> y;\n\t\t\tmomo.push_back(Point(x,y));\n\t\t}\n\n\t\tvector<Point> sakura;\n\t\trep(i,s)\n\t\t{\n\t\t\tdouble x,y;\n\t\t\tcin >> x >> y;\n\t\t\tsakura.push_back(Point(x,y));\n\t\t}\n\n\t\tvector<pair<int,int> > wind;\n\t\trep(i,r)\n\t\t{\n\t\t\tint w,a;\n\t\t\tcin >> w >> a;\n\t\t\twind.push_back(make_pair(w,a));\n\t\t}\n\n\t\tvector<pair<int,int> > ret;\n\t\tPoint S(0,0);\n\t\trep(i,h)\n\t\t{\n\t\t\tint cnt = 0;\n\t\t\t\n\t\t\trep(j,r)\n\t\t\t{\n\t\t\t\tif(hit(S,v[i],du,wind[j].first,wind[j].second)) cnt++;\n\t\t\t}\n\n\t\t\trep(j,r)\n\t\t\t{\n\t\t\t\tbool only = true;\n\n\t\t\t\trep(k,u)\n\t\t\t\t{\n\t\t\t\t\tif(hit(ume[k],v[i],du,wind[j].first,wind[j].second)) only = false;\n\t\t\t\t}\n\n\t\t\t\trep(k,m)\n\t\t\t\t{\n\t\t\t\t\tif(hit(momo[k],v[i],dm,wind[j].first,wind[j].second)) only = false;\n\t\t\t\t}\n\n\t\t\t\trep(k,s)\n\t\t\t\t{\n\t\t\t\t\tif(hit(sakura[k],v[i],ds,wind[j].first,wind[j].second)) only = false;\n\t\t\t\t}\n\n\t\t\t\tif(!only) cnt--;\n\t\t\t}\n\n\t\t\tif(cnt > 0)\n\t\t\t{\n\t\t\t\tret.push_back(make_pair(cnt,i));\n\t\t\t}\n\t\t}\n\n\t\tint cmax = 0;\n\n\t\trep(i,ret.size()) cmax = max(cmax,ret[i].first);\n\n\t\tif(cmax == 0) cout << \"NA\" << endl;\n\t\telse\n\t\t{\n\t\t\tvector<int> ans;\n\t\t\trep(i,ret.size())\n\t\t\t{\n\t\t\t\tif(ret[i].first == cmax) ans.push_back(ret[i].second);\n\t\t\t}\n\n\t\t\tsort(ans.begin(),ans.end());\n\n\t\t\trep(i,ans.size())\n\t\t\t{\n\t\t\t\tcout << ans[i] + 1;\n\t\t\t\tif(i == ans.size()-1) cout << endl;\n\t\t\t\telse cout << \" \";\n\t\t\t}\n\t\t}\n\t}\n\n\treturn 0;\n}"
  },
  {
    "language": "C++",
    "code": "\n//自分の梅は任意の地点でかおるとする。→間違い。\n//EPSはつけない。\n//扇形と家は接しないので、距離はsqrtで求めた。\n\n#include<iostream>\n#include<cmath>\n#include<vector>\n#define rep(i,n) for(i = 0;i < n;i++)\n#define PI 3.14159265358979\nusing namespace std;\n\ntypedef pair<double,double> P;\n\nint H,R;\t\t\t\t//家数,日数\nint hx[100],hy[100];\t//家の座標\nint U,M,S;\t\t\t\t//梅、桃、桜の数\nint du,dm,ds;\t\t\t//梅、桃、桜の扇形の中心角\nint ux[100],uy[100];\t//梅の座標\nint mx[100],my[100];\t//桃の座標\nint sx[100],sy[100];\t//桜の座標\nint w[100],a[100];\t\t//扇形の方向(角度),風の強さ\n\n//半径,角度の順で格納し、返す\n//rotateは角度補正( 補正 = rotate*360 )\nP POLAR( int treex,int treey,int housex,int housey,int rotate )\n{\n\tP ans;\n\tans.first = (housex-treex)*(housex-treex) + (housey-treey)*(housey-treey);\n\tans.first = sqrt( ans.first );\n\tans.second = atan2( (double)housey - treey, (double)housex - treex ) * 180 / PI;\n\tans.second += 360*rotate;\n\treturn ans;\n}\n\nint main()\n{\n\tint i,j,k,l;\n\twhile( cin >> H >> R )\n\t{\n\t\tint day[100] = {0};\t\t//i番目の家において、他の木の香りが届かなかった日数\n\n\t\tif( H == 0 && R == 0 )\n\t\t\tbreak;\n\t\trep(i,H)\n\t\t\tcin >> hx[i] >> hy[i];\n\t\tcin >> U >> M >> S >> du >> dm >> ds;\n\t\trep(i,U)\n\t\t\tcin >> ux[i] >> uy[i];\n\t\trep(i,M)\n\t\t\tcin >> mx[i] >> my[i];\n\t\trep(i,S)\n\t\t\tcin >> sx[i] >> sy[i];\n\t\trep(i,R)\n\t\t\tcin >> w[i] >> a[i];\n\t\t//ここから探索\n\t\trep(i,R){\n\t\t\trep(j,H){\n\t\t\t\trep(k,U){\n\t\t\t\t\trep(l,3){\n\t\t\t\t\t\tP t = POLAR( ux[k],uy[k],hx[j],hy[j],l-1 );\n\t\t\t\t\t\t//判定\n\t\t\t\t\t\tif( t.first <= a[i] && fabs( (double)w[i] - t.second ) <= (double)du/2.0 )\n\t\t\t\t\t\t\tbreak;\n\t\t\t\t\t}\n\t\t\t\t\tif(l < 3)\n\t\t\t\t\t\tbreak;\n\t\t\t\t}\n\t\t\t\tif(k < U)\n\t\t\t\t\tcontinue;\n\t\t\t\trep(k,M){\n\t\t\t\t\trep(l,3){\n\t\t\t\t\t\tP t = POLAR( mx[k],my[k],hx[j],hy[j],l-1 );\n\t\t\t\t\t\t//判定\n\t\t\t\t\t\tif( t.first <= a[i] && fabs( (double)w[i] - t.second ) <= (double)dm/2.0 )\n\t\t\t\t\t\t\tbreak;\n\t\t\t\t\t}\n\t\t\t\t\tif(l < 3)\n\t\t\t\t\t\tbreak;\n\t\t\t\t}\n\t\t\t\tif(k < M)\n\t\t\t\t\tcontinue;\n\t\t\t\trep(k,S){\n\t\t\t\t\trep(l,3){\n\t\t\t\t\t\tP t = POLAR( sx[k],sy[k],hx[j],hy[j],l-1 );\n\t\t\t\t\t\t//判定\n\t\t\t\t\t\tif( t.first <= a[i] && fabs( (double)w[i] - t.second ) <= (double)ds/2.0 )\n\t\t\t\t\t\t\tbreak;\n\t\t\t\t\t}\n\t\t\t\t\tif(l < 3)\n\t\t\t\t\t\tbreak;\n\t\t\t\t}\n\t\t\t\tif(k < S)\n\t\t\t\t\tcontinue;\n\n\t\t\t\t//私の梅の香りは届くのか！！\n\t\t\t\trep(l,3){\n\t\t\t\t\tP t = POLAR( 0,0,hx[j],hy[j],l-1 );\n\t\t\t\t\t//判定\n\t\t\t\t\tif( t.first <= a[i] && fabs( (double)w[i] - t.second ) <= du/2.0 )\n\t\t\t\t\t\tbreak;\n\t\t\t\t}\n\t\t\t\tif( l < 3 )\n\t\t\t\t\tday[j]++;\n\t\t\t}\n\t\t}\n\t\tint maxday = 0;\n\t\trep(i,H){\n\t\t\tmaxday = max( maxday,day[i] );\n\t\t}\n\t\tif( maxday == 0 ){\n\t\t\tcout << \"NA\" << endl;\n\t\t\tcontinue;\n\t\t}\n\n\t\tint lasthouse = 0; \n\t\trep(i,H){\n\t\t\tif( day[i] == maxday ){\n\t\t\t\tlasthouse = i;\n\t\t\t}\n\t\t}\n\t\trep(i,H){\n\t\t\tif( day[i] == maxday ){\n\t\t\t\tcout << i+1;\n\t\t\t\tif( i < lasthouse )\n\t\t\t\t\tcout << ' ';\n\t\t\t\telse\n\t\t\t\t\tcout << endl;\n\t\t\t}\n\t\t}\n\t}\n\treturn 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include<iostream>\n#include<vector>\n#include<cmath>\n#include<algorithm>\nusing namespace std;\n\nconst double PI = 3.14159265358979;\n\nclass Point {\npublic:\n    double x, y;\n    Point(double x = 0.0, double y = 0.0) :x(x), y(y) {}\n};\n\nclass Wind {\npublic:\n    double w, a;\n};\n\nbool include(double angle, double low, double high) {\n    if(low < 0.0) {\n        double l = low + 2.0 * PI;\n        if(l <= angle) return true;\n    }\n    if(high > 2.0 * PI) {\n        double h = high - 2.0 * PI;\n        if(angle <= h) return true;\n    }\n    return low <= angle && angle <= high;\n}\n\nbool savor(const Point &home, const Wind &wind, const vector<Point> &blossom, double d) {\n    d /= 2.0;\n    for(const auto &b: blossom) {\n        Point dif(home.x - b.x, home.y - b.y);\n        double angle = atan2(dif.y, dif.x);\n        double dist = hypot(dif.y, dif.x);\n        if(angle < 0.0) angle = angle + 2.0 * PI;\n        if(dist <= wind.a && include(angle, wind.w - d, wind.w + d)) return true;\n    }\n    return false;\n}\n\ndouble toRadian(double d) {\n    return d * PI / 180.0;\n}\n\nint main() {\n    int H, R;\n    while(cin >> H >> R, H | R) {\n        vector<Point> home(H);\n        for(auto &i: home) cin >> i.x >> i.y;\n\n        int U, M, S;\n        double du, dm, ds;\n        cin >> U >> M >> S >> du >> dm >> ds;\n\n        du = toRadian(du);\n        dm = toRadian(dm);\n        ds = toRadian(ds);\n\n        vector<Point> plum(U), peach(M), cherry(S);\n        for(auto &i: plum) cin >> i.x >> i.y;\n        for(auto &i: peach) cin >> i.x >> i.y;\n        for(auto &i: cherry) cin >> i.x >> i.y;\n\n        vector<Wind> wind(R);\n        for(auto &i: wind) cin >> i.w >> i.a;\n        for(auto &i: wind) i.w = toRadian(i.w);\n\n        // solve\n        vector<int> number(H, 0);\n        int maxNumber = 0;\n\n        for(int i = 0; i < H; ++i) {\n            for(int day = 0; day < R; ++day) {\n                bool ok = savor(home[i], wind[day], {Point(0.0, 0.0)}, du);\n                bool ng = false;\n                ng |= savor(home[i], wind[day], plum, du);\n                ng |= savor(home[i], wind[day], peach, dm);\n                ng |= savor(home[i], wind[day], cherry, ds);\n\n                if(!ok || ng) continue;\n\n                ++number[i];\n                maxNumber = max(maxNumber, number[i]);\n            }\n        }\n\n        if(maxNumber) {\n            bool first = true;\n            for(int i = 0; i < H; ++i) if(number[i] == maxNumber) {\n                if(!first) cout << \" \";\n                first = false;\n                cout << i + 1;\n            }\n            cout << endl;\n        } else {\n            cout << \"NA\" << endl;\n        }\n    }\n}"
  },
  {
    "language": "C++",
    "code": "#include<iostream>\n#include<complex>\n#include<vector>\n#include<algorithm>\n#include<cmath>\n#include<cstring>\n\n#define pb push_back\n#define sz size()\n#define rep(i,a) for(int i=0;i<(int)(a);i++)\n\nusing namespace std;\ntypedef long double D;\ntypedef complex<D> P;\nconst D EPS = 1e-10;\nconst D PI = acos(-1);\n\ninline D dot(P x,P y){return real(conj(x)*y);}\ninline D cross(P x,P y){return imag(conj(x)*y);}\ninline D arg(P a,P b,P c){\n  D res = acos(dot(b-a,c-a)/(abs(b-a)*abs(c-a))); \n  return (cross(b-a,c-a)<EPS)?2*PI-res:res;\n}\n\nint h,r,n[3];\nD d[3],tmp1,tmp2,seta;\nP hp[110],up[3][110];\nD w[110],a[110];\n\nint main(){\n  while(cin >> h >> r,h){\n    rep(i,h){\n      cin >> tmp1 >> tmp2;\n      hp[i] = P(tmp1,tmp2);\n    }\n\n    rep(i,3)cin >> n[i]; rep(i,3)cin >> d[i], d[i] *= PI/180/2;\n\n    rep(i,3)rep(j,n[i]){\n      cin >> tmp1 >> tmp2;\n      up[i][j] = P(tmp1,tmp2);\n    }\n\n    rep(i,r)cin >> w[i] >> a[i], w[i] *= PI/180;\n\n    int num[110];\n    memset(num,0,sizeof(num));\n\n    rep(x,r)rep(id,h){\n      if( !(abs(hp[id]) < a[x] + EPS) )continue;\n      seta = arg(P(0,0),P(100,0),hp[id]);\n      if( !(w[x]-d[0] < seta+EPS && seta < w[x]+d[0]+EPS)\n\t  && !(w[x]-d[0]+2*PI < seta+EPS && seta < w[x]+d[0]+2*PI+EPS) )continue;\n\n      bool in = 0;\n      rep(i,3){\n\trep(j,n[i]){\n\t  if(abs(hp[id]-up[i][j]) < a[x] +EPS){\n\t    P tmp = P(up[i][j].real() + 100.0, up[i][j].imag());\n\t    seta = arg(up[i][j],tmp,hp[id]);\n\t    if(w[x]-d[i] < seta+EPS && seta < w[x]+d[i]+EPS){\n\t      in = 1; break;\n\t    }\n\t    seta -= 2*PI;\n\t    if(w[x]-d[i] < seta+EPS && seta < w[x]+d[i]+EPS){\n\t      in = 1; break;\n\t    }\n\t  }\n\t}\n\tif(in)break;\n      }\n      if(!in)num[id]++;\n    }\n\n    int maxv = *max_element(num,num+h);\n    if(maxv==0)cout << \"NA\\n\";\n    else{\n      vector<int> ans;\n      rep(i,h){\n\tif(num[i] == maxv)ans.pb(i+1);\n      }\n      rep(i,ans.sz)cout << ans[i] << (i+1==ans.size()?\"\\n\":\" \");\n    }\n  }\n}"
  },
  {
    "language": "C++",
    "code": "#include<bits/stdc++.h>\nusing namespace std;\n\ntypedef pair<int,int>pint;\ntypedef vector<int>vint;\n#define pb push_back\n#define mp make_pair\n#define rep(i,n) for(int i=0;i<(n);i++)\ntemplate<class T,class U>void chmin(T &t,U f){if(t>f)t=f;}\ntemplate<class T,class U>void chmax(T &t,U f){if(t<f)t=f;}\n\ntypedef complex<double>P;\n\nconst double EPS=1e-9;\nconst double PI=acos(-1);\n\nconst int COUNTER_CLOCKWISE=1;\nconst int CLOCKWISE=-1;\nconst int ONLINE_BACK=2;\nconst int ONLINE_FRONT=-2;\nconst int ON_SEGMENT=0;\n\ninline double dot(const P &a, const P &b){return (conj(a) * b).real();}\ninline double cross(const P &a, const P &b){return (conj(a) * b).imag();}\n\ndouble toRad(double a){return a/180.0*PI;}\ndouble toDeg(double a){return a*180/PI;}\nP rotate(P p,double d){\n    return P(p.real()*cos(d)-p.imag()*sin(d),p.real()*sin(d)+p.imag()*cos(d));\n}\n\nP getP(){\n    double x,y;\n    scanf(\"%lf%lf\",&x,&y);\n    return P(x,y);\n}\n\nint ccw(P p0,P p1,P p2){\n    P a=p1-p0;\n    P b=p2-p0;\n    if(cross(a,b)>EPS)return COUNTER_CLOCKWISE;\n    if(cross(a,b)<-EPS)return CLOCKWISE;\n    if(dot(a,b)<-EPS)return ONLINE_BACK;\n    if(norm(a)<norm(b))return ONLINE_FRONT;\n    return ON_SEGMENT;\n}\n\nbool ok(P from,P to,double w,double a,double d){\n    if(abs(to-from)-EPS>a)return false;\n\n    w=toRad(w);\n    d=toRad(d);\n\n    P p0=from+P(cos(w),sin(w))*a;\n    P p1=rotate(p0,-d/2);\n    P p2=rotate(p0,d/2);\n\n    int c1=ccw(from,p1,to);\n    int c2=ccw(from,p2,to);\n\n    if(c1==CLOCKWISE||c1==ONLINE_BACK)return false;\n    if(c2==COUNTER_CLOCKWISE||c2==ONLINE_BACK)return false;\n    return true;\n}\n\nint H,R;\nvector<P>h;\n\nint U,M,S;\ndouble du,dm,ds;\nvector<P>u,m,s;\nvoid solve(){\n    h.resize(H);\n    rep(i,H)h[i]=getP();\n\n    scanf(\"%d%d%d\",&U,&M,&S);\n    scanf(\"%lf%lf%lf\",&du,&dm,&ds);\n\n    u.resize(U);\n    m.resize(M);\n    s.resize(S);\n    rep(i,U)u[i]=getP();\n    rep(i,M)m[i]=getP();\n    rep(i,S)s[i]=getP();\n\n    int cnt[100]={0};\n\n    while(R--){\n        double w,a;\n        scanf(\"%lf%lf\",&w,&a);\n        rep(i,H){\n            bool f=false;\n            if(ok(P(0,0),h[i],w,a,du))f=true;\n            rep(j,U)if(ok(u[j],h[i],w,a,du))f=false;\n            rep(j,M)if(ok(m[j],h[i],w,a,dm))f=false;\n            rep(j,S)if(ok(s[j],h[i],w,a,ds))f=false;\n            if(f)cnt[i]++;\n        }\n    }\n\n    int ma=*max_element(cnt,cnt+H);\n    if(ma==0){\n        puts(\"NA\");\n        return;\n    }\n\n    bool f=false;\n    rep(i,H){\n        if(cnt[i]!=ma)continue;\n        if(f)printf(\" \");\n        else f=true;\n        printf(\"%d\",i+1);\n    }\n    puts(\"\");\n}\n\nint main(){\n    while(scanf(\"%d%d\",&H,&R),H||R)solve();\n    return 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include<iostream>\n#include<vector>\n#include<math.h>\n#include<complex>\n\n#define EPS 1e-4\n\n#define PI 3.141592\n#define EQ(a,b) (abs((a)-(b))<EPS)\nusing namespace std;\n\ntypedef complex<double> P;\n\nvector<P> house;\nvector<P> ume,sak,mo;\n\ndouble cross(P v1,P v2){\n\treturn v1.real()*v2.imag()-v1.imag()*v2.real();\n}\n\nbool che(P h,P t,double d,double w,double a){\n\tP v=h-t;\n\tif(!(abs(v)<=a+EPS))return false;\n\t\n\tP v1=P(a*cos((w+d/2)/180*PI),a*sin((w+d/2)/180*PI));\n\tP v2=P(a*cos((w-d/2)/180*PI),a*sin((w-d/2)/180*PI));\n\t\n\tif(cross(v1,v)<=EPS && cross(v2,v)>=-EPS)return true;\n\telse return false;\n}\n\nint main(){\n\tint h,r;\n\t\n\twhile(cin>>h>>r && h&&r){\n\t\thouse.clear();\n\t\tume.push_back(P(0,0));\n\t\tfor(int i=0;i<h;i++){\n\t\t\tint x,y;\n\t\t\tcin>>x>>y;\n\t\t\thouse.push_back(P(x,y));\n\t\t}\n\t\t\n\t\tint U,M,S,du,dm,ds;\n\t\tcin>>U>>M>>S>>du>>dm>>ds;\n\t\tfor(int i=0;i<U;i++){\n\t\t\tint x,y;\n\t\t\tcin>>x>>y;\n\t\t\tume.push_back(P(x,y));\n\t\t}\n\t\tfor(int i=0;i<M;i++){\n\t\t\tint x,y;\n\t\t\tcin>>x>>y;\n\t\t\tmo.push_back(P(x,y));\n\t\t}\n\t\tfor(int i=0;i<S;i++){\n\t\t\tint x,y;\n\t\t\tcin>>x>>y;\n\t\t\tsak.push_back(P(x,y));\n\t\t}\n\t\t\n\t\t\n\t\tint data[120];\n\t\tfor(int i=0;i<120;i++)data[i]=0;\n\t\tfor(int z=0;z<r;z++){\n\t\t\tint w,a;\n\t\t\tcin>>w>>a;\n\t\t\t\n\t\t\tfor(int i=0;i<house.size();i++){\n\t\t\t\tbool ok=false;\n\t\t\t\tif(che(house[i],ume[0],du,w,a))ok=true;\n\t\t\t\telse continue;\n\t\t\t\tfor(int j=1;j<U;j++){\n\t\t\t\t\tif(che(house[i],ume[j],du,w,a))ok=false;\n\t\t\t\t}\n\t\t\t\tfor(int j=0;j<M;j++){\n\t\t\t\t\tif(che(house[i],mo[j],dm,w,a))ok=false;\n\t\t\t\t}\n\t\t\t\tfor(int j=0;j<S;j++){\n\t\t\t\t\tif(che(house[i],sak[j],ds,w,a))ok=false;\n\t\t\t\t}\n\t\t\t\t\n\t\t\t\tif(ok)data[i]++;\n\t\t\t}\n\t\t}\n\t\t\n\t\t\tint ans=0;\n\t\t\tfor(int i=0;i<h;i++){\n\t\t\t\tans=max(ans,data[i]);\n\t\t\t}\n\t\t\tif (ans==0)cout<<\"NA\";\n\t\t\telse {\n\t\t\t\tfor(int i=0;i<h;i++){\n\t\t\t\t\tif(data[i]==ans)cout<<i+1<<\" \";\n\t\t\t\t}\n\t\t\t}\n\t\t\tcout<<endl;\n\t\t\t\n\t\t\n\t}\n}"
  },
  {
    "language": "C++",
    "code": "#include<iostream>\n#include<cstdio>\n#include<cstdlib>\n#include<cstring>\n#include<cmath>\n#include<vector>\n\n#define PI 3.141592653589793\n\nusing namespace std;\n\nint h,r;\nint hx[101],hy[101];\nint u,m,s,du,dm,ds;\nint ux[101],uy[101];\nint mx[101],my[101];\nint sx[101],sy[101];\nint w[101],a[101];\n\nbool check(int p,int d){\n\tbool f=false;\n\tfor(int i=u;i<=u;i++){\n\t\tdouble x=hx[p]-ux[i];\n\t\tdouble y=hy[p]-uy[i];\n\t\tif(x*x+y*y>a[d]*a[d])continue;\n\t\tdouble c=(atan2(y,x))*180/PI;\n\t\tif(c<0)c=(double)360.0+c;\n\t\tif((double)w[d]-du/2<=c && c<=(double)w[d]+du/2)f=true;\n\t\tif(c<(double)w[d]+du/2-360)f=true;\n\t}\n\tif(!f)return false;\n\tfor(int i=0;i<u;i++){\n\t\tdouble x=hx[p]-ux[i];\n\t\tdouble y=hy[p]-uy[i];\n\t\tif(x*x+y*y>a[d]*a[d])continue;\n\t\tdouble c=(atan2(y,x))*180/PI;\n\t\tif(c<0)c=(double)360.0+c;\n\t\tif((double)w[d]-du/2<=c && c<=(double)w[d]+du/2)return false;\n\t\tif(c<(double)w[d]+du/2-360)return false;\n\t}\n\tfor(int i=0;i<m;i++){\n\t\tdouble x=hx[p]-mx[i];\n\t\tdouble y=hy[p]-my[i];\n\t\tif(x*x+y*y>a[d]*a[d])continue;\n\t\tdouble c=(atan2(y,x))*180/PI;\n\t\tif(c<0)c=(double)360.0+c;\n\t\tif((double)w[d]-dm/2<=c && c<=(double)w[d]+dm/2)return false;\n\t\tif(c<(double)w[d]+dm/2-360)return false;\n\t}\n\t\n\tfor(int i=0;i<s;i++){\n\t\tdouble x=hx[p]-sx[i];\n\t\tdouble y=hy[p]-sy[i];\n\t\tif(x*x+y*y>a[d]*a[d])continue;\n\t\tdouble c=(atan2(y,x))*180/PI;\n\t\tif(c<0)c=(double)360.0+c;\n\t\tif((double)w[d]-ds/2<=c && c<=(double)w[d]+ds/2)return false;\n\t\tif(c<(double)w[d]+ds/2-360)return false;\n\t}\n\treturn true;\n}\n\nint main(void){\n\twhile(1){\n\t\tscanf(\"%d%d\",&h,&r);\n\t\tif(h==0 && r==0)break;\n\t\tfor(int i=0;i<h;i++)scanf(\"%d%d\",&hx[i],&hy[i]);\n\t\tscanf(\"%d%d%d%d%d%d\",&u,&m,&s,&du,&dm,&ds);\n\t\tfor(int i=0;i<u;i++)scanf(\"%d%d\",&ux[i],&uy[i]);\n\t\tfor(int i=0;i<m;i++)scanf(\"%d%d\",&mx[i],&my[i]);\n\t\tfor(int i=0;i<s;i++)scanf(\"%d%d\",&sx[i],&sy[i]);\n\t\tfor(int i=0;i<r;i++)scanf(\"%d%d\",&w[i],&a[i]);\n\t\tint res=0;\n\t\tvector<int> id;\n\t\tfor(int i=0;i<h;i++){\n\t\t\tint cnt=0;\n\t\t\tfor(int j=0;j<r;j++){\n\t\t\t\tif(check(i,j))cnt++;\n\t\t\t}\n\t\t\tif(cnt==res)id.push_back(i+1);\n\t\t\tif(cnt>res){\n\t\t\t\tres=cnt;\n\t\t\t\tid.clear();\n\t\t\t\tid.push_back(i+1);\n\t\t\t}\n\t\t}\n\t\tif(res==0)printf(\"NA\\n\");\n\t\telse for(int i=0;i<id.size();i++)printf(\"%d%c\",id[i],i==id.size()-1?'\\n':' ');\n\t}\n\treturn 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include <cstdio>\n#include <vector>\n#include <complex>\n#include <cmath>\nusing namespace std;\n\n#define EPS 1e-7\n\ntypedef complex<double> P;\ntypedef const P &rP;\ntypedef const vector<P> &cvP;\n\ndouble pi;\n\nbool checkarg(double a, double b, double c){\n\tdouble pi2 = pi * 2.0;\n\twhile(b + EPS < a) b += pi2;\n\twhile(b > a + pi2 + EPS) b -= pi2;\n\twhile(c + EPS < b) c += pi2;\n\twhile(c > a + pi2 + EPS) c -= pi2;\n\n\treturn a < b + EPS && b < c + EPS;\n}\n\nvector<P> input(int n){\n\tint x, y;\n\tvector<P> v(n);\n\tfor(int i = 0; i < n; ++i){\n\t\tscanf(\"%d%d\", &x, &y);\n\t\tv[i] = P(x, y);\n\t}\n\treturn v;\n}\n\nbool reach(P house, double d, double a, double w){\n\tif(norm(house) > a * a + EPS) return false;\n\treturn checkarg(w - d * 0.5, arg(house), w + d * 0.5);\n}\n\nbool check(rP house, cvP us, double du, cvP ms, double dm, cvP ss, double ds, double a, double w){\n\tif(!reach(house, du, a, w)) return false;\n\tfor(int i = 0; i < us.size(); ++i){\n\t\tif(reach(house - us[i], du, a, w)) return false;\n\t}\n\tfor(int i = 0; i < ms.size(); ++i){\n\t\tif(reach(house - ms[i], dm, a, w)) return false;\n\t}\n\tfor(int i = 0; i < ss.size(); ++i){\n\t\tif(reach(house - ss[i], ds, a, w)) return false;\n\t}\n\treturn true;\n}\n\nint main(){\n\tpi = acos(-1.0);\n\n\tint h, r, u, m, s;\n\tdouble du, dm, ds;\n\twhile(scanf(\"%d%d\", &h, &r), h){\n\t\tvector<int> ans;\n\t\tint mincnt = 1;\n\t\t\n\t\tvector<P> hs = input(h);\n\n\t\tscanf(\"%d%d%d%lf%lf%lf\", &u, &m, &s, &du, &dm, &ds);\n\t\tdu *= pi / 180.0;\n\t\tdm *= pi / 180.0;\n\t\tds *= pi / 180.0;\n\n\t\tvector<P> us = input(u), ms = input(m), ss = input(s);\n\n\t\tvector<double> w(r), a(r);\n\t\tfor(int i = 0; i < r; ++i){\n\t\t\tscanf(\"%lf%lf\", &w[i], &a[i]);\n\t\t\tw[i] *= pi / 180.0;\n\t\t}\n\n\t\tfor(int i = 0; i < h; ++i){\n\t\t\tint cnt = 0;\n\t\t\tfor(int j = 0; j < r; ++j){\n\t\t\t\tif(check(hs[i], us, du, ms, dm, ss, ds, a[j], w[j])){\n\t\t\t\t\t++cnt;\n\t\t\t\t}\n\t\t\t}\n\n\t\t\tif(cnt > mincnt){\n\t\t\t\tmincnt = cnt;\n\t\t\t\tans.clear();\n\t\t\t}\n\t\t\tif(cnt == mincnt){\n\t\t\t\tans.push_back(i + 1);\n\t\t\t}\n\t\t}\n\t\t\n\t\tif(ans.empty()){\n\t\t\tputs(\"NA\");\n\t\t}\n\t\telse{\n\t\t\tprintf(\"%d\", ans[0]);\n\t\t\tfor(int i = 1; i < ans.size(); ++i){\n\t\t\t\tprintf(\" %d\", ans[i]);\n\t\t\t}\n\t\t\tputs(\"\");\n\t\t}\n\t}\n}"
  },
  {
    "language": "C++",
    "code": "#include<iostream>\n#include<complex>\n#include<vector>\n#include<algorithm>\n\nusing namespace std;\n\ntypedef complex<double> P;\n\ndouble dot(P a,P b){\n  return (a*conj(b)).real();\n}\n\nint main(){\n  for(int H,R;cin>>H>>R,H;){\n    P h[100];\n    for(int i=0;i<H;i++){\n      int x,y;\n      cin>>x>>y;\n      h[i]=P(x,y);\n    }\n    int UMS[3],dums[3];\n    cin>>UMS[0]>>UMS[1]>>UMS[2]>>dums[0]>>dums[1]>>dums[2];\n    P ums[3][10];\n    for(int i=0;i<3;i++){\n      for(int j=0;j<UMS[i];j++){\n\tint x,y;\n\tcin>>x>>y;\n\tums[i][j]=P(x,y);\n      }\n    }\n    int nr[100]={};\n    for(int i=0;i<R;i++){\n      int w,a;\n      cin>>w>>a;\n      auto reach=[=](P s,P d,int ang){\n\tP v=d-s;\n\treturn abs(v)<a&&acos(min(1.,max(-1.,dot(v,polar(1.,w*acos(0)/90))/abs(v))))<ang*acos(0)/90/2;\n      };\n      for(int j=0;j<H;j++){\n\tif(reach(P(0,0),h[j],dums[0])){\n\t  bool f=false;\n\t  for(int k=0;k<3;k++){\n\t    for(int l=0;l<UMS[k];l++){\n\t      f|=reach(ums[k][l],h[j],dums[k]);\n\t    }\n\t  }\n\t  nr[j]+=!f;\n\t}\n      }\n    }\n    auto m=*max_element(nr,nr+H);\n    if(m==0){\n      cout<<\"NA\"<<endl;\n    }else{\n      vector<int> v;\n      for(int i=0;i<H;i++){\n\tif(m==nr[i]){\n\t  v.push_back(i+1);\n\t}\n      }\n      for(int i=0;i<v.size();i++){\n\tcout<<v[i]<<\" \\n\"[i==v.size()-1];\n      }\n    }\n  }\n}"
  },
  {
    "language": "C++",
    "code": "#include<iostream>\n#include<cstdio>\n#include<cstdlib>\n#include<cstring>\n#include<cmath>\n#include<vector>\n\n#define PI 3.141592653589793\n\nusing namespace std;\n\nint h,r;\nint hx[101],hy[101];\nint u,m,s,du,dm,ds;\nint ux[12],uy[12];\nint mx[12],my[12];\nint sx[12],sy[12];\nint w[101],a[101];\n\nbool check(int p,int d){\n\tbool f=false;\n\tfor(int i=u;i<=u;i++){\n\t\tdouble x=hx[p]-ux[i];\n\t\tdouble y=hy[p]-uy[i];\n\t\tif(x*x+y*y>a[d]*a[d])continue;\n\t\tdouble c=(atan2(y,x))*180/PI;\n\t\tif(c<0)c=(double)360.0+c;\n\t\tif((double)w[d]-du/2<=c && c<=(double)w[d]+du/2)f=true;\n\t\tif(c<(double)w[d]+du/2-360)f=true;\n\t}\n\tif(!f)return false;\n\tfor(int i=0;i<u;i++){\n\t\tdouble x=hx[p]-ux[i];\n\t\tdouble y=hy[p]-uy[i];\n\t\tif(x*x+y*y>a[d]*a[d])continue;\n\t\tdouble c=(atan2(y,x))*180/PI;\n\t\tif(c<0)c=(double)360.0+c;\n\t\tif((double)w[d]-du/2<=c && c<=(double)w[d]+du/2)return false;\n\t\tif(c<(double)w[d]+du/2-360)return false;\n\t}\n\tfor(int i=0;i<m;i++){\n\t\tdouble x=hx[p]-mx[i];\n\t\tdouble y=hy[p]-my[i];\n\t\tif(x*x+y*y>a[d]*a[d])continue;\n\t\tdouble c=(atan2(y,x))*180/PI;\n\t\tif(c<0)c=(double)360.0+c;\n\t\tif((double)w[d]-dm/2<=c && c<=(double)w[d]+dm/2)return false;\n\t\tif(c<(double)w[d]+dm/2-360)return false;\n\t}\n\t\n\tfor(int i=0;i<s;i++){\n\t\tdouble x=hx[p]-sx[i];\n\t\tdouble y=hy[p]-sy[i];\n\t\tif(x*x+y*y>a[d]*a[d])continue;\n\t\tdouble c=(atan2(y,x))*180/PI;\n\t\tif(c<0)c=(double)360.0+c;\n\t\tif((double)w[d]-ds/2<=c && c<=(double)w[d]+ds/2)return false;\n\t\tif(c<(double)w[d]+ds/2-360)return false;\n\t}\n\treturn true;\n}\n\nint main(void){\n\twhile(1){\n\t\tscanf(\"%d%d\",&h,&r);\n\t\tif(h==0 && r==0)break;\n\t\tfor(int i=0;i<h;i++)scanf(\"%d%d\",&hx[i],&hy[i]);\n\t\tscanf(\"%d%d%d%d%d%d\",&u,&m,&s,&du,&dm,&ds);\n\t\tfor(int i=0;i<u;i++)scanf(\"%d%d\",&ux[i],&uy[i]);\n\t\tfor(int i=0;i<m;i++)scanf(\"%d%d\",&mx[i],&my[i]);\n\t\tfor(int i=0;i<s;i++)scanf(\"%d%d\",&sx[i],&sy[i]);\n\t\tfor(int i=0;i<r;i++)scanf(\"%d%d\",&w[i],&a[i]);\n\t\tint res=0;\n\t\tvector<int> id;\n\t\tfor(int i=0;i<h;i++){\n\t\t\tint cnt=0;\n\t\t\tfor(int j=0;j<r;j++){\n\t\t\t\tif(check(i,j))cnt++;\n\t\t\t}\n\t\t\tif(cnt==res)id.push_back(i+1);\n\t\t\tif(cnt>res){\n\t\t\t\tres=cnt;\n\t\t\t\tid.clear();\n\t\t\t\tid.push_back(i+1);\n\t\t\t}\n\t\t}\n\t\tif(res==0)printf(\"NA\\n\");\n\t\telse for(int i=0;i<id.size();i++)printf(\"%d%c\",id[i],i==id.size()-1?'\\n':' ');\n\t}\n\treturn 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include<cstdio>\n#include<cstring>\n#include<vector>\n#include<queue>\n#include<algorithm>\n#include<cmath>\n#include<cstring>\n#include<climits>\nusing namespace std;\n#define rep(i,n) for(int i=0;i<(n);i++)\n#define reg(i,a,b) for(int i=(a);i<=(b);i++)\n#define irep(i,n) for(int i=((int)(n))-1;i>=0;i--)\n#define ireg(i,a,b) for(int i=(b);i>=(a);i--)\ntypedef long long int lli;\ntypedef pair<int,int> mp;\n#define fir first\n#define sec second\n#define IINF INT_MAX\n#define LINF LLONG_MAX\n\n\nint ih,iwd;\nint hx[105];\nint hy[105];\n\ndouble det(double x,double y,double p,double q){\n\treturn x*q - p*y;\n}\n\nbool isin(int x,int y,int r,double k,double kai){\n\tif(r*r<x*x+y*y)return false;\n\tdouble r1 = (k+kai/2)/360.0*2*3.14159265358979;\n\tdouble r2 = (k-kai/2)/360.0*2*3.14159265358979;\n\t//printf(\"%lf %lf %lf %lf\\n\",r1,r2,det(x,y,cos(r1),sin(r1)), det(x,y,cos(r2),sin(r2)));\n\tif(det(x,y,cos(r1),sin(r1)) > 0 && det(x,y,cos(r2),sin(r2)) < 0)return true;\n\treturn false;\n}\n\nint main(void){\n\t//printf(\"%d %d %d\\n\",true,false,isin(1,3,6,45,30));\n\twhile(1){\n\t\tscanf(\"%d%d\",&ih,&iwd);\n\t\tif(ih==0)break;\n\t\trep(i,ih){\n\t\t\tscanf(\"%d%d\",&hx[i],&hy[i]);\n\t\t}\n\t\tint ans[105]={};\n\t\t\n\t\tint tn[3];\n\t\trep(i,3)scanf(\"%d\",&tn[i]);\n\t\tint tr[3];\n\t\trep(i,3)scanf(\"%d\",&tr[i]);\n\t\t\n\t\tint tx[3][20];\n\t\tint ty[3][20];\n\t\trep(i,3){\n\t\t\trep(j,tn[i]){\n\t\t\t\tscanf(\"%d%d\",&tx[i][j],&ty[i][j]);\n\t\t\t}\n\t\t}\n\t\t\n\t\trep(p,iwd){\n\t\t\tint nk,na;\n\t\t\tscanf(\"%d%d\",&nk,&na);\n\t\t\tint ok[105]={};\n\t\t\trep(i,ih){\n\t\t\t\tif(isin(hx[i],hy[i],na,nk,tr[0]))ok[i]=1;\n\t\t\t}\n\t\t\t/*\n\t\t\trep(i,ih){\n\t\t\t\tprintf(\"%d \",ok[i]);\n\t\t\t}\n\t\t\tprintf(\"\\n\");*/\n\t\t\trep(i,3){\n\t\t\t\trep(j,tn[i]){\n\t\t\t\t\trep(k,ih){\n\t\t\t\t\t\tint nx = hx[k]-tx[i][j];\n\t\t\t\t\t\tint ny = hy[k]-ty[i][j];\n\t\t\t\t\t\tif(isin(nx,ny,na,nk,tr[i])){\n\t\t\t\t\t\t\t//printf(\"%d %d %d %d %d\\n\",nx,ny,na,nk,tr[i]);\n\t\t\t\t\t\t\t//printf(\"out.....%d  %d %d\\n\",i,j,k);\n\t\t\t\t\t\t\tok[k]=0;\n\t\t\t\t\t\t}\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t}\n\n\t\t\trep(i,ih){\n\t\t\t\tif(ok[i]==1)ans[i]++;\n\t\t\t}\n\t\t\t\n\t\t\t/*\n\t\t\trep(i,ih){\n\t\t\t\tprintf(\"%d \",ans[i]);\n\t\t\t}\n\t\t\tprintf(\"\\n\");*/\n\t\t}\n\t\t\n\t\tint nmax = 0;\n\t\trep(i,ih){\n\t\t\t//printf(\"%d \",ans[i]);\n\t\t\tif(ans[i]>nmax)nmax = ans[i];\n\t\t}\n\t\t//printf(\"\\n\");\n\t\tif(nmax==0)printf(\"NA\\n\");\n\t\telse{\n\t\t\trep(i,ih){\n\t\t\t\tif(ans[i]==nmax)printf(\"%d \",i+1);\n\t\t\t}\n\t\t\tprintf(\"\\n\");\n\t\t}\n\t\t\n\t}\n\treturn 0;\n}"
  },
  {
    "language": "C++",
    "code": "\n//自分の梅は任意の地点でかおるとする。EPSはつけない。\n//扇形と家は接しないので、距離はsqrtで求めた。\n\n#include<iostream>\n#include<cmath>\n#include<vector>\n#define rep(i,n) for(i = 0;i < n;i++)\n#define PI 3.14159265358979\nusing namespace std;\n\ntypedef pair<double,double> P;\n\nint H,R;\t\t\t\t//家数,日数\nint hx[100],hy[100];\t//家の座標\nint U,M,S;\t\t\t\t//梅、桃、桜の数\nint du,dm,ds;\t\t\t//梅、桃、桜の扇形の中心角\nint ux[100],uy[100];\t//梅の座標\nint mx[100],my[100];\t//桃の座標\nint sx[100],sy[100];\t//桜の座標\nint w[100],a[100];\t\t//扇形の方向(角度),風の強さ\n\n//半径,角度の順で格納し、返す\n//rotateは角度補正( 補正 = rotate*360 )\nP 極座標( int treex,int treey,int housex,int housey,int rotate )\n{\n\tP ans;\n\tans.first = (housex-treex)*(housex-treex) + (housey-treey)*(housey-treey);\n\tans.first = sqrt( ans.first );\n\tif( housex == treex && housey > treey )\n\t\tans.second = 90;\n\telse if( housex == treex && housey < treey )\n\t\tans.second = -90;\n\telse\n\t\tans.second = atan2( (double)housey - treey, (double)housex - treex ) * 180 / PI;\n\tans.second += 360*rotate;\n\treturn ans;\n}\n\nint main()\n{\n\tint i,j,k,l;\n\twhile( cin >> H >> R )\n\t{\n\t\tint day[100] = {0};\t\t//i番目の家において、他の木の香りが届かなかった日数\n\n\t\tif( H == 0 && R == 0 )\n\t\t\tbreak;\n\t\trep(i,H)\n\t\t\tcin >> hx[i] >> hy[i];\n\t\tcin >> U >> M >> S >> du >> dm >> ds;\n\t\trep(i,U)\n\t\t\tcin >> ux[i] >> uy[i];\n\t\trep(i,M)\n\t\t\tcin >> mx[i] >> my[i];\n\t\trep(i,S)\n\t\t\tcin >> sx[i] >> sy[i];\n\t\trep(i,R)\n\t\t\tcin >> w[i] >> a[i];\n\t\t//ここから探索\n\t\trep(i,R){\n\t\t\trep(j,H){\n\t\t\t\trep(k,U){\n\t\t\t\t\trep(l,3){\n\t\t\t\t\t\tP t = 極座標( ux[k],uy[k],hx[j],hy[j],l-1 );\n\t\t\t\t\t\t//判定\n\t\t\t\t\t\tif( t.first <= a[i] && fabs( (double)w[i] - t.second ) <= du/2 )\n\t\t\t\t\t\t\tbreak;\n\t\t\t\t\t}\n\t\t\t\t\tif(l < 3)\n\t\t\t\t\t\tbreak;\n\t\t\t\t}\n\t\t\t\tif(k < U)\n\t\t\t\t\tcontinue;\n\t\t\t\trep(k,M){\n\t\t\t\t\trep(l,3){\n\t\t\t\t\t\tP t = 極座標( mx[k],my[k],hx[j],hy[j],l-1 );\n\t\t\t\t\t\t//判定\n\t\t\t\t\t\tif( t.first <= a[i] && fabs( (double)w[i] - t.second ) <= dm/2 )\n\t\t\t\t\t\t\tbreak;\n\t\t\t\t\t}\n\t\t\t\t\tif(l < 3)\n\t\t\t\t\t\tbreak;\n\t\t\t\t}\n\t\t\t\tif(k < M)\n\t\t\t\t\tcontinue;\n\t\t\t\trep(k,S){\n\t\t\t\t\trep(l,3){\n\t\t\t\t\t\tP t = 極座標( sx[k],sy[k],hx[j],hy[j],l-1 );\n\t\t\t\t\t\t//判定\n\t\t\t\t\t\tif( t.first <= a[i] && fabs( (double)w[i] - t.second ) <= ds/2 )\n\t\t\t\t\t\t\tbreak;\n\t\t\t\t\t}\n\t\t\t\t\tif(l < 3)\n\t\t\t\t\t\tbreak;\n\t\t\t\t}\n\t\t\t\tif(k < S)\n\t\t\t\t\tcontinue;\n\n\t\t\t\tday[j]++;\n\t\t\t}\n\t\t}\n\t\tint maxday = 0;\n\t\trep(i,H){\n\t\t\tmaxday = max( maxday,day[i] );\n\t\t}\n\t\tif( maxday == 0 ){\n\t\t\tcout << \"NA\" << endl;\n\t\t\tcontinue;\n\t\t}\n\t\trep(i,H){\n\t\t\tif( day[i] == maxday ){\n\t\t\t\tcout << i+1;\n\t\t\t\tif( i < H-1 )\n\t\t\t\t\tcout << ' ';\n\t\t\t\telse\n\t\t\t\t\tcout << endl;\n\t\t\t}\n\t\t}\n\t}\n\treturn 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include<iostream>\n#include<vector>\n#include<cmath>\n#include<algorithm>\n#include<numeric>\nusing namespace std;\n \nconst double PI = 3.14159265358979;\n \nclass Point {\npublic:\n    double x, y;\n    Point(double x = 0.0, double y = 0.0) :x(x), y(y) {}\n};\n \nclass Wind {\npublic:\n    double w, a;\n};\n \nbool include(double angle, double low, double high) {\n    if(low < 0.0) {\n        double l = low + 2.0 * PI;\n        if(l <= angle) return true;\n    }\n    if(high > 2.0 * PI) {\n        double h = high - 2.0 * PI;\n        if(angle <= h) return true;\n    }\n    return low <= angle && angle <= high;\n}\n \nbool savor(const Point &home, const Wind &wind, const vector<Point> &blossom, double d) {\n    d /= 2.0;\n    for(const auto &b: blossom) {\n        Point dif(home.x - b.x, home.y - b.y);\n        double angle = atan2(dif.y, dif.x);\n        double dist = hypot(dif.y, dif.x);\n        if(angle < 0.0) angle = angle + 2.0 * PI;\n        if(dist <= wind.a + EPS && include(angle, wind.w - d, wind.w + d)) return true;\n    }\n    return false;\n}\n \ndouble toRadian(double d) {\n    return d * PI / 180.0;\n}\n \nint main() {\n    int H, R;\n    while(cin >> H >> R, H | R) {\n        vector<Point> home(H);\n        for(auto &i: home) cin >> i.x >> i.y;\n \n        int U, M, S;\n        double du, dm, ds;\n        cin >> U >> M >> S >> du >> dm >> ds;\n \n        du = toRadian(du);\n        dm = toRadian(dm);\n        ds = toRadian(ds);\n \n        vector<Point> plum(U), peach(M), cherry(S);\n        for(auto &i: plum) cin >> i.x >> i.y;\n        for(auto &i: peach) cin >> i.x >> i.y;\n        for(auto &i: cherry) cin >> i.x >> i.y;\n \n        vector<Wind> wind(R);\n        for(auto &i: wind) cin >> i.w >> i.a;\n        for(auto &i: wind) i.w = toRadian(i.w);\n \n        // solve\n        vector<int> number(H, 0);\n        int maxNumber = 0;\n \n        for(int i = 0; i < H; ++i) {\n            for(int day = 0; day < R; ++day) {\n                bool ok = savor(home[i], wind[day], {Point(0.0, 0.0)}, du);\n                bool ng = false;\n                ng |= savor(home[i], wind[day], plum, du);\n                ng |= savor(home[i], wind[day], peach, dm);\n                ng |= savor(home[i], wind[day], cherry, ds);\n \n                if(!ok || ng) continue;\n \n                ++number[i];\n                maxNumber = max(maxNumber, number[i]);\n            }\n        }\n \n        if(maxNumber) {\n            bool first = true;\n            for(int i = 0; i < H; ++i) if(number[i] == maxNumber) {\n                if(!first) cout << \" \";\n                first = false;\n                cout << i + 1;\n            }\n            cout << endl;\n        } else {\n            cout << \"NA\" << endl;\n        }\n    }\n}"
  },
  {
    "language": "C++",
    "code": "// East Wind\n\n// wrong answer\n\n#include<iostream>\n#include<vector>\n#include<cmath>\n#include<algorithm>\n#include<numeric>\nusing namespace std;\n\nconst double PI = 3.14159265358979;\nconst double EPS = 1e-9;\n\nclass Point {\npublic:\n    double x, y;\n    Point(double x = 0.0, double y = 0.0) :x(x), y(y) {}\n};\n\nclass Wind {\npublic:\n    double w, a;\n};\n\nbool include(double angle, double low, double high) {\n\n    return low <= angle + EPS && angle <= high + EPS;\n}\n\nbool savor(const Point &home, const Wind &wind, const vector<Point> &blossom, double d) {\n//     cout << \"home: \" << home.x << \", \" << home.y << endl;\n//     cout << \"blossom\" << endl; for(const auto &i: blossom) cout << \"  \" << i.x << \",\" << i.y; cout << endl;\n//     cout << \"d: \" << d << endl;\n//     cout << \"wind: \" << wind.w << \", \" << wind.a << endl;\n//     cout << endl;\n    d /= 2.0;\n    for(const auto &b: blossom) {\n        Point dif(home.x - b.x, home.y - b.y);\n        double angle = atan2(dif.y, dif.x);\n        double dist = hypot(dif.y, dif.x);\n        if(angle < 0) angle = angle + 2 * PI;\n//         cout<<\"angle: \"<<angle<<endl;\n//         cout<<\"wind.w +- d: \"<<wind.w - d<<\" - \"<<wind.w + d<<endl;\n//         cout<<\"dist: \"<<dist<<endl;\n        if(dist <= wind.a + EPS && include(angle, wind.w - d, wind.w + d)) return true;\n    }\n    return false;\n}\n\ndouble toRadian(double d) {\n    return d * PI / 180.0;\n}\n\nint main() {\n    int H, R;\n    while(cin >> H >> R, H | R) {\n        vector<Point> home(H);\n        for(auto &i: home) cin >> i.x >> i.y;\n\n        int U, M, S;\n        double du, dm, ds;\n        cin >> U >> M >> S >> du >> dm >> ds;\n\n        du = toRadian(du);\n        dm = toRadian(dm);\n        ds = toRadian(ds);\n\n        vector<Point> plum(U), peach(M), cherry(S);\n        for(auto &i: plum) cin >> i.x >> i.y;\n        for(auto &i: peach) cin >> i.x >> i.y;\n        for(auto &i: cherry) cin >> i.x >> i.y;\n\n        vector<Wind> wind(R);\n        for(auto &i: wind) cin >> i.w >> i.a;\n        for(auto &i: wind) i.w = toRadian(i.w);\n\n        // test\n//         cout << savor(home[5], wind[0], peach, dm) << endl;\n//         return 0;\n\n        // solve\n        vector<int> number(H, 0);\n        int maxNumber = 0;\n\n        for(int i = 0; i < H; ++i) {\n            for(int day = 0; day < R; ++day) {\n                bool ok = savor(home[i], wind[day], {Point(0.0, 0.0)}, du);\n                bool ng = false;\n                ng |= savor(home[i], wind[day], plum, du);\n                ng |= savor(home[i], wind[day], peach, dm);\n                ng |= savor(home[i], wind[day], cherry, ds);\n\n//                 cout<<\"day\"<<day<<endl;\n//                 cout<<savor(home[i], wind[day], plum, du)<<\" \"<<savor(home[i], wind[day], peach, du)<<\" \"<<savor(home[i], wind[day], cherry, du)<<endl;\n\n                if(!ok || ng) continue;\n\n                ++number[i];\n                maxNumber = max(maxNumber, number[i]);\n            }\n        }\n\n//         for(const auto &i: number) cout<<\" \"<<i;cout<<endl;\n\n        if(maxNumber) {\n            bool first = true;\n            for(int i = 0; i < H; ++i) if(number[i] == maxNumber) {\n                if(!first) cout << \" \";\n                first = false;\n                cout << i + 1;\n            }\n            cout << endl;\n        } else {\n            cout << \"NA\" << endl;\n        }\n\n//         return 0;\n    }\n}"
  },
  {
    "language": "C++",
    "code": "#include <cstdio>\n#include <cstdlib>\n#include <cmath>\n#include <cstring>\n\n#include <iostream>\n#include <string>\n#include <algorithm>\n#include <vector>\n#include <queue>\n#include <stack>\n#include <map>\n#include <set>\n\n#include <functional>\n#include <cassert>\n\ntypedef long long ll;\nusing namespace std;\n\n#define debug(x) cerr << #x << \" = \" << x << endl;\n\n\n#define mod 1000000007 //1e9+7(prime number)\n#define INF 1000000000 //1e9\n#define LLINF 2000000000000000000LL //2e18\n#define SIZE 10000\n\n#define eps 1e-8\n\nbool is_ok(int hx,int hy, int tx, int ty, int td,int a,int w){\n\n  int dx = hx - tx;\n  int dy = hy - ty;\n\n  if(a*a < dx*dx + dy*dy) return false;\n\n  double rad;\n\n  if(dx == 0){\n    if(dy < 0) rad = 270;\n    else rad = 90;\n  }else if(dy == 0){\n    if(dx < 0) rad = 180;\n    else rad = 0;\n  }else{\n    rad = atan((double)dy/dx);\n\n    if(rad < 0){\n      rad += M_PI;\n    }\n  \n    if(dy < 0){\n      rad += M_PI;\n    }\n\n    rad = rad/M_PI * 180;\n  }\n  \n  rad += 180 - w;\n  w = 180;\n\n  if(rad >= 360) rad -= 360;\n  if(rad < 0) rad += 360;\n    \n  return w - td/2.0 - eps < rad && rad < w + td/2.0 + eps;\n}\n\nbool calc(){\n  int h,r,t;\n  int hx[SIZE],hy[SIZE];\n  int u,m,s,du,dm,ds;\n  int tx[SIZE],ty[SIZE],td[SIZE];\n  int w[SIZE],a[SIZE];\n  \n  scanf(\"%d%d\",&h,&r);\n\n  if(h==0) return false;\n\n  for(int i=0;i<h;i++){\n    scanf(\"%d%d\",hx+i,hy+i);\n  }\n\n  scanf(\"%d%d%d%d%d%d\",&u,&m,&s,&du,&dm,&ds);\n\n  t = u+m+s;\n  \n  for(int i=0;i<u;i++){\n    scanf(\"%d%d\",tx+i,ty+i);\n    td[i] = du;\n  }\n\n  for(int i=u;i<u+m;i++){\n    scanf(\"%d%d\",tx+i,ty+i);\n    td[i] = dm;\n  }\n\n  for(int i=u+m;i<u+s+m;i++){\n    scanf(\"%d%d\",tx+i,ty+i);\n    td[i] = ds;\n  }\n\n  for(int i=0;i<r;i++){\n    scanf(\"%d%d\",w+i,a+i);\n  }\n\n  int max_d = 0;\n  int ans[SIZE] = {};\n\n  for(int i=0;i<h;i++){\n\n    for(int j=0;j<r;j++){\n      bool flag = true;\n\n      for(int k=0;k<t;k++){\n        if(is_ok(hx[i],hy[i],tx[k],ty[k],td[k],a[j],w[j])) flag = false;\n      }\n\n      if(flag && is_ok(hx[i],hy[i],0,0,du,a[j],w[j])) ans[i]++;\n    }\n  }\n  \n  for(int i=0;i<h;i++)\n    max_d = max(max_d,ans[i]);\n\n  if(max_d > 0){\n  \n    bool flag1 = false;\n    \n    for(int i=0;i<h;i++){\n      if(max_d == ans[i]){\n        if(flag1) printf(\" \");\n        flag1 = true;\n        printf(\"%d\",i+1);\n      }\n    }\n    \n    printf(\"\\n\");\n  }else{\n    puts(\"NA\");\n  }\n  \n  return true;\n}\n  \n\nint main(){\n\n  while(calc());\n  \n  return 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include<iostream>\n#include<cstdio>\n#include<cstdlib>\n#include<cstring>\n#include<cmath>\n#include<vector>\n\n#define PI 3.141592653589793\n\nusing namespace std;\n\nint h,r;\nint hx[101],hy[101];\nint u,m,s,du,dm,ds;\nint ux[101],uy[101];\nint mx[101],my[101];\nint sx[101],sy[101];\nint w[101],a[101];\n\nvoid init(){\n\tmemset(hx,0,sizeof(hx));\n\tmemset(hy,0,sizeof(hy));\n\tmemset(ux,0,sizeof(ux));\n\tmemset(uy,0,sizeof(uy));\n\tmemset(mx,0,sizeof(mx));\n\tmemset(my,0,sizeof(my));\n\tmemset(sx,0,sizeof(sx));\n\tmemset(sy,0,sizeof(sy));\n\tmemset(w,0,sizeof(w));\n\tmemset(a,0,sizeof(a));\n}\n\nbool check(int p,int d){\n\tbool f=false;\n\tfor(int i=u;i<=u;i++){\n\t\tdouble x=hx[p]-ux[i];\n\t\tdouble y=hy[p]-uy[i];\n\t\tif((double)x*x+y*y>(double)a[d]*a[d])continue;\n\t\tdouble c=(atan2(y,x))*180/PI;\n\t\tif(c<0)c=(double)360.0+c;\n\t\tif((double)w[d]-du/2<=c && c<=(double)w[d]+du/2)f=true;\n\t\tif(c<(double)w[d]+du/2-360)f=true;\n\t}\n\tif(!f)return false;\n\tfor(int i=0;i<u;i++){\n\t\tdouble x=hx[p]-ux[i];\n\t\tdouble y=hy[p]-uy[i];\n\t\tif((double)x*x+y*y>(double)a[d]*a[d])continue;\n\t\tdouble c=(atan2(y,x))*180/PI;\n\t\tif(c<0)c=(double)360.0+c;\n\t\tif((double)w[d]-du/2<=c && c<=(double)w[d]+du/2)return false;\n\t\tif(c<(double)w[d]+du/2-360)return false;\n\t}\n\tfor(int i=0;i<m;i++){\n\t\tdouble x=hx[p]-mx[i];\n\t\tdouble y=hy[p]-my[i];\n\t\tif((double)x*x+y*y>(double)a[d]*a[d])continue;\n\t\tdouble c=(atan2(y,x))*180/PI;\n\t\tif(c<0)c=(double)360.0+c;\n\t\tif((double)w[d]-dm/2<=c && c<=(double)w[d]+dm/2)return false;\n\t\tif(c<(double)w[d]+dm/2-360)return false;\n\t}\n\t\n\tfor(int i=0;i<s;i++){\n\t\tdouble x=hx[p]-sx[i];\n\t\tdouble y=hy[p]-sy[i];\n\t\tif((double)x*x+y*y>(double)a[d]*a[d])continue;\n\t\tdouble c=(atan2(y,x))*180/PI;\n\t\tif(c<0)c=(double)360.0+c;\n\t\tif((double)w[d]-ds/2<=c && c<=(double)w[d]+ds/2)return false;\n\t\tif(c<(double)w[d]+ds/2-360)return false;\n\t}\n\treturn true;\n}\n\nint main(void){\n\twhile(1){\n\t\tscanf(\"%d%d\",&h,&r);\n\t\tif(h==0 && r==0)break;\n\t\tinit();\n\t\tfor(int i=0;i<h;i++)scanf(\"%d%d\",&hx[i],&hy[i]);\n\t\tscanf(\"%d%d%d%d%d%d\",&u,&m,&s,&du,&dm,&ds);\n\t\tfor(int i=0;i<u;i++)scanf(\"%d%d\",&ux[i],&uy[i]);\n\t\tfor(int i=0;i<m;i++)scanf(\"%d%d\",&mx[i],&my[i]);\n\t\tfor(int i=0;i<s;i++)scanf(\"%d%d\",&sx[i],&sy[i]);\n\t\tfor(int i=0;i<r;i++)scanf(\"%d%d\",&w[i],&a[i]);\n\t\tint res=0;\n\t\tvector<int> id;\n\t\tfor(int i=0;i<h;i++){\n\t\t\tint cnt=0;\n\t\t\tfor(int j=0;j<r;j++){\n\t\t\t\tif(check(i,j))cnt++;\n\t\t\t}\n\t\t\tif(cnt==res)id.push_back(i+1);\n\t\t\tif(cnt>res){\n\t\t\t\tres=cnt;\n\t\t\t\tid.clear();\n\t\t\t\tid.push_back(i+1);\n\t\t\t}\n\t\t}\n\t\tif(res==0)printf(\"NA\\n\");\n\t\telse for(int i=0;i<id.size();i++)printf(\"%d%c\",id[i],i==id.size()-1?'\\n':' ');\n\t}\n\treturn 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include <iostream>\n#include <cmath>\n#include <vector>\n#include <map>\n#include <algorithm>\nusing namespace std;\n\nconst double EPS = 0.0001;\nconst double PI = acos(-1.0);\n\n// 2つのスカラーが等しいかどうか\nbool equal(double a, double b) {\n\treturn fabs(a - b) < EPS;\n}\n// 点クラス\nstruct P {\n\tdouble x, y;\n\tP(double x_, double y_) { x = x_; y = y_; }\n\tP(){}\n\t// 加算, 減算, スカラー倍\n\tP operator+(const P& a) const {\n\t\treturn P(x + a.x, y + a.y);\n\t}\n\tP operator-(const P& a) const {\n\t\treturn P(x - a.x, y - a.y);\n\t}\n\tP operator*(const P& a) const {\n\t\treturn P(x * a.x - y * a.y, x * a.y + y * a.y);\n\t}\n\tP operator*(double c) const {\n\t\treturn P(x * c, y * c);\n\t}\n\tP operator/(const P& a) const {\n\t\tdouble norm = a.x * a.x + a.y * a.y;\n\t\tdouble x_ = (x * a.x + y * a.y) / norm;\n\t\tdouble y_ = (y * a.x - x * a.y) / norm;\n\t\treturn P(x_, y_);\n\t}\n\tP operator/(double c) const {\n\t\treturn P(x / c, y / c);\n\t}\n\tP& operator+=(const P& a) {\n\t\tx += a.x; y += a.y;\n\t}\n\tP& operator-=(const P& a) {\n\t\tx -= a.x; y -= a.y;\n\t}\n\tP& operator*=(const P& a) {\n\t\t*this = P(x * a.x - y * a.y, x * a.y + y * a.y);\n\t}\n\tP& operator*=(double c) {\n\t\t*this = P(x * c, y * c);\n\t}\n\tP& operator/=(const P& a) {\n\t\tdouble norm = a.x * a.x + a.y * a.y;\n\t\tdouble x_ = (x * a.x + y * a.y) / norm;\n\t\tdouble y_ = (y * a.x - x * a.y) / norm;\n\t\t*this = P(x_, y_);\n\t}\n\tP& operator/=(double c) {\n\t\t*this = P(x / c, y / c);\n\t}\n};\nP operator*(double c, P a){\n\treturn P(a.x * c, a.y * c);\n}\n// 比較演算子\nbool operator==(const P& a, const P& b) {\n\treturn equal(a.x, b.x) && equal(a.y, b.y);\n}\nbool operator!=(const P& a, const P& b) {\n\treturn !(a == b);\n}\nbool operator<(const P& a, const P& b) {\n\treturn (a.x != b.x)? a.x < b.x : a.y < b.y;\n}\n\n// 原点からの距離(絶対値)\ndouble abs(P a) {\n\treturn sqrt(a.x * a.x + a.y * a.y);\n}\n// 2点間の距離\ndouble dist(P a, P b) {\n\treturn abs(a - b);\n}\n// 内積 (dot product) : a・b = |a||b|cosΘ\ndouble dot(P a, P b) {\n\treturn a.x * b.x + a.y * b.y;\n}\n// 外積 (cross product) : a×b = |a||b|sinΘ\ndouble cross(P a, P b) {\n\treturn a.x * b.y - a.y * b.x;\n}\n\n// CCW : 反時計回り (Counter Clock Wise)\n// CW : 時計回り (Clock Wise)\nenum {CCW=1, CW=-1, ON=0};\n// * 3点がどちら回りであるか返す, 3点が1直線に乗っているときは ON を返す\nint ccw(const P &a, P b, P c) {\n\tb -= a, c -= a;\n\tif( cross(b,c) >  EPS ) return CCW; // CCW : 反時計回り\n\tif( cross(b,c) < -EPS ) return CW;  // CW : 時計回り\n\tif( dot(b, c)  < -EPS ) return +2;  // c--a--b on line\n\tif( dot(b, b)  + EPS < dot(c, c) ) return -2; // a--b--c on line \n\treturn ON;\n}\n\n// 入力\nint H, R, U, M, S;\ndouble du, dm, ds;\nint hx[100], hy[100], ux[100], uy[100];\nint mx[100], my[100], sx[100], sy[100];\ndouble w[100], a[100];\n\n// smell[k] := 家 k に梅の香りのみが届く日数\nint smell[100];\n\n// ラジアンから度数へ変換して返す\ndouble to_deg(double rad) {\n\treturn rad * 180.0 / PI;\n}\n// 度数からラジアンに変換して返す\ndouble to_rad(double deg) {\n\treturn deg * PI / 180.0;\n}\n\n// 扇に含まれるかどうか\nbool isInSector(P c, double a, double d, double r, P p){\n\tdouble dist = abs(c - p);\n\tif( dist > a ) return false;\n\t\n\tP p1 = P(a * cos(r + d/2.0), a * sin(r + d/2.0) );\n\tP p2 = P(a * cos(r - d/2.0), a * sin(r - d/2.0) );\n\t\n\tif( ccw(c, c + p1, p) == CW && ccw(c, c + p2, p) == CCW ){\n\t\treturn true;\n\t}\n\treturn false;\n}\n\nvoid solve(){\n\tfor(int h=0 ; h < H ; h++ ){\n\t\t// 家 j の座標\n\t\tP p = P(hx[h], hy[h]);\n\t\t\n\t\tfor(int d=0 ; d < R ; d++ ){\n\t\t\tbool flag = false;\n\t\t\t// 桃の香りが家 j に届くかどうかチェック\n\t\t\tfor(int k=0 ; k < M ; k++ ){\n\t\t\t\tP c = P(mx[k], my[k]);\n\t\t\t\tif( isInSector(c, a[d], dm, w[d], p) ){\n\t\t\t\t\tflag = true;\n\t\t\t\t\tbreak;\n\t\t\t\t}\n\t\t\t}\n\t\t\tif( flag ) break;\n\t\t\t\n\t\t\t// 桜の香りが家 j に届くかどうかチェック\n\t\t\tfor(int k=0 ; k < S ; k++ ){\n\t\t\t\tP c = P(sx[k], sy[k]);\n\t\t\t\tif( isInSector(c, a[d], ds, w[d], p) ){\n\t\t\t\t\tflag = true;\n\t\t\t\t\tbreak;\n\t\t\t\t}\n\t\t\t}\n\t\t\tif( flag ) break;\n\t\t\t\n\t\t\t// 梅の香りが届くかどうか\n\t\t\tfor(int k=0 ; k < U ; k++ ){\n\t\t\t\tP c = P(ux[k], uy[k]);\n\t\t\t\tif( isInSector(c, a[d], du, w[d], p) ){\n\t\t\t\t\tflag = true;\n\t\t\t\t\tbreak;\n\t\t\t\t}\n\t\t\t}\n\t\t\tif( flag ) break;\n\t\t\t\n\t\t\t// 自分の家の梅の香りが届くかどうか\n\t\t\tif( isInSector(P(0, 0), a[d], du, w[d], p) ){\n\t\t\t\tsmell[h]++;\n\t\t\t}\n\t\t}\n\t}\n\t\n\t// ソート\n\tvector<pair<int, int> > v;\n\tfor(int i=0 ; i < H ; i++ ){\n\t\tif( smell[i] != 0 ) v.push_back(pair<int, int>(-smell[i], i+1));\n\t}\n\tsort(v.begin(), v.end());\n\t\n\t// 出力\n\tif( v.size() == 0 ){\n\t\tcout << \"NA\" << endl;\n\t}else{\n\t\tfor(int i=0 ; i < v.size() ; i++ ){\n\t\t\tif( i && v[i].first != v[i-1].first ) break;\n\t\t\tif( i ) cout << \" \";\n\t\t\tcout << v[i].second;\n\t\t}\n\t\tcout << endl;\n\t}\n}\n\nint main(){\n\twhile( cin >> H >> R , H || R ){\n\t\t// 初期化\n\t\tfill(smell, smell + H, 0);\n\t\t\n\t\t// 入力\n\t\tfor(int i=0 ; i < H ; i++ ) cin >> hx[i] >> hy[i];\n\t\tcin >> U >> M >> S >> du >> dm >> ds;\n\t\tdu = to_rad(du), dm = to_rad(dm), ds = to_rad(ds);\n\t\tfor(int i=0 ; i < U ; i++ ) cin >> ux[i] >> uy[i];\n\t\tfor(int i=0 ; i < M ; i++ ) cin >> mx[i] >> my[i];\n\t\tfor(int i=0 ; i < S ; i++ ) cin >> sx[i] >> sy[i];\n\t\tfor(int i=0 ; i < R ; i++ ){\n\t\t\tcin >> w[i] >> a[i];\n\t\t\tw[i] = to_rad(w[i]);\n\t\t}\n\t\t\n\t\tsolve();\n\t}\n}"
  },
  {
    "language": "C++",
    "code": "#include<bits/stdc++.h>\n\n#define REP(i,s,n) for(int i=s;i<n;i++)\n#define rep(i,n) REP(i,0,n)\n#define EPS (1e-7)\n#define COUNTER_CLOCKWISE 1\n#define CLOCKWISE -1 \n#define ONLINE_BACK 2\n#define ONLINE_FRONT -2\n#define ON_SEGMENT 0\n#define equals(a,b) (fabs((a)-(b)) < EPS)\n\nusing namespace std;\n\nconst int IINF = INT_MAX;\n\n//\nclass Point{\npublic:\n  double x,y;\n\n  Point(double x = -IINF,double y = -IINF): x(x),y(y){}\n\n  Point operator + (Point p){return Point(x+p.x,y+p.y);}\n  Point operator - (Point p){return Point(x-p.x,y-p.y);}\n  Point operator * (double a){return Point(a*x,a*y);}\n  Point operator / (double a){return Point(x/a,y/a);}\n  Point operator * (Point a){ return Point(x * a.x - y * a.y, x * a.y + y * a.x); }\n\n  bool operator < (const Point& p) const{ return !equals(x,p.x)?x<p.x:y<p.y; }\n\n  bool operator == (const Point& p)const{ return fabs(x-p.x) < EPS && fabs(y-p.y) < EPS; }\n\n};\n\nstruct Segment{\n  Point p1,p2;\n  Segment(Point p1 = Point(),Point p2 = Point()):p1(p1),p2(p2){}\n  bool operator == (const Segment& p)const { return p.p1 == p1 && p.p2 == p2; }\n};\n\ntypedef Point Vector;\ntypedef Segment Line;\ntypedef vector<Point> Polygon;\n\nostream& operator << (ostream& os,const Point& a){ os << \"(\" << a.x << \",\" << a.y << \")\"; }\n\nostream& operator << (ostream& os,const Segment& a){ os << \"( \" << a.p1 << \" , \" << a.p2 << \" )\"; }\n\ndouble dot(Point a,Point b){ return a.x*b.x + a.y*b.y; }\n\ndouble cross(Point a,Point b){ return a.x*b.y - a.y*b.x; }\n\ndouble norm(Point a){ return a.x*a.x+a.y*a.y; }\n\ndouble abs(Point a){ return sqrt(norm(a)); }\n\n//rad は角度をラジアンで持たせること\nPoint rotate(Point a,double rad){ return Point(cos(rad)*a.x - sin(rad)*a.y,sin(rad)*a.x + cos(rad)*a.y); }\n\n// 度をラジアンに変換\ndouble toRad(double agl){ return agl*M_PI/180.0; }\n\n// a => prev, b => cur, c=> next\n// prev から cur へ行って next へ行く際の角度を求める\ndouble getArg(Point a,Point b,Point c){\n  double arg1 = atan2(b.y-a.y,b.x-a.x);\n  double arg2 = atan2(c.y-b.y,c.x-b.x);\n  double arg = fabs( arg1 - arg2 );\n  while( arg > M_PI ) arg -= 2.0 * M_PI;\n  return fabs(arg);\n}\n\nint ccw(Point p0,Point p1,Point p2){\n  Point a = p1-p0;\n  Point b = p2-p0;\n  if(cross(a,b) > EPS)return COUNTER_CLOCKWISE;\n  if(cross(a,b) < -EPS)return CLOCKWISE;\n  if(dot(a,b) < -EPS)return ONLINE_BACK;\n  if(norm(a) < norm(b))return ONLINE_FRONT;\n  return ON_SEGMENT;\n}\n\n//\n\nconst int MAX_N = 110;\nint N,M,Ume,Momo,SakuraHappyInnovation,counter[MAX_N],limit[3];\nPoint ps[MAX_N],p[3][20];\ndouble d[3],w[110],a[110];\n\nbool LT(double A,double B)  { return !equals(A,B) && A < B; }\nbool LTE(double A,double B) { return  equals(A,B) || A < B; }\n\nbool inside(Point h,Point t,double ta,double tw,double td){\n  double rad_w = toRad(tw), rad_d = toRad(td);\n  Point tmp = Point(ta*cos(rad_w),ta*sin(rad_w));\n  double rad_alpha = rad_w - toRad(td/2.0);\n  double rad_beta  = rad_w + toRad(td/2.0);\n  Point alpha = rotate(tmp,rad_alpha) + t;\n  Point beta  = rotate(tmp,rad_beta)  + t;\n  int res_ccw = ccw(t,alpha,h);\n  bool res1 = ( res_ccw == COUNTER_CLOCKWISE || res_ccw == ON_SEGMENT || res_ccw == ONLINE_BACK || res_ccw == ONLINE_FRONT ) ;\n  res_ccw = ccw(t,beta,h);\n  bool res2 = ( res_ccw == CLOCKWISE || res_ccw == ON_SEGMENT || res_ccw == ONLINE_BACK || res_ccw == ONLINE_FRONT ) ;\n  double dist = abs(h-t);\n  bool res3 = LTE(dist,ta);\n  return res1 && res2 && res3;\n}\n\ninline void compute(){\n  rep(i,N) counter[i] = 0;\n  rep(_,M){\n    rep(i,N){\n      bool failed = false;\n      if( inside(ps[i],Point(0,0),a[_],w[_],d[0]) ) {\n        rep(j,3) if( !failed ) rep(k,limit[j]) failed |= inside(ps[i],p[j][k],a[_],w[_],d[j]);\n      } else failed = true;\n      if( !failed ) ++counter[i];\n    }\n  }\n  int maxi = -1;\n  rep(i,N) if( counter[i] != 0 ) maxi = max(maxi,counter[i]);\n  if( maxi == -1 ) puts(\"NA\");\n  else {\n    bool first = true;\n    rep(i,N) if( counter[i] == maxi ){\n      if( !first ) printf(\" \"); first = false;\n      printf(\"%d\",i+1);\n    }\n    puts(\"\");\n  }\n}\n\nint main(){\n\n  while( scanf(\"%d %d\",&N,&M), N|M ){\n    rep(i,N) scanf(\"%lf %lf\",&ps[i].x,&ps[i].y);\n    scanf(\"%d %d %d %lf %lf %lf\",&Ume,&Momo,&SakuraHappyInnovation,d,d+1,d+2);\n    limit[0] = Ume, limit[1] = Momo, limit[2] = SakuraHappyInnovation;\n    rep(i,Ume) scanf(\"%lf %lf\",&p[0][i].x,&p[0][i].y);\n    rep(i,Momo) scanf(\"%lf %lf\",&p[1][i].x,&p[1][i].y);\n    rep(i,SakuraHappyInnovation) scanf(\"%lf %lf\",&p[2][i].x,&p[2][i].y);\n    rep(i,M) scanf(\"%lf %lf\",w+i,a+i);\n    compute();\n  }\n  return 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include <iostream>\n#include <cstdio>\n#include <iomanip>\n#include <vector>\n#include <map>\n#include <set>\n#include <queue>\n#include <bitset>\n#include <stack>\n#include <utility>\n#include <numeric>\n#include <algorithm>\n#include <functional>\n#include <cctype>\n#include <complex>\n#include <string>\n#include <sstream>\n#include <fstream>\n#include <cassert>\nusing namespace std;\n\n//common\ntypedef long long i64,ll;\n\n#define BR \"\\n\"\n#define ALL(c) (c).begin(),(c).end()\n#define REP(i,n) for(int i=0;i<(int)(n);++i)\n#define FOR(i,l,r) for(int i=(l);i<(int)(r);++i)\n#define EACH(it,o) for(auto it = (o).begin(); it != (o).end(); ++it)\n#define IN(l,v,r) ((l)<=(v) && (v)<(r))\n\n//debug\n#ifdef NDEBUG\n#define DUMP(x)\n#define DUMPLN(x)\n#define DEBUG(x)\n#define DEBUGLN(x)\n#define LINE()\n#define LINELN()\n#define CHECK(exp,act)\n#define STOP(e)\n#else\n#define DUMP(x)  cerr << #x << \" = \" << (x)\n#define DUMPLN(x)  DUMP(x) <<endl\n#define DEBUG(x) DUMP(x) << LINE() << \" \" << __FILE__\n#define DEBUGLN(x) DEBUG(x)<<endl\n#define LINE()    cerr<< \" (L\" << __LINE__ << \")\"\n#define LINELN()    LINE()<<endl\n#define CHECK(exp,act)  if(exp!=act){DUMPLN(exp);DEBUGLN(act);}\n#define STOP(e)  CHECK(e,true);if(!(e)) exit(1);\n#endif\n\ntemplate<class T> inline string toString(const vector<T>& x) {\n\tstringstream ss;\n\tREP(i,x.size()){\n\t\tif(i!=0)ss<<\" \";\n\t\tss<< x[i];\n\t}\n\treturn ss.str();\n}\n\ntemplate<class T> inline string toString(const vector<vector<T> >& map) {\n\tstringstream ss;\n\tREP(i,map.size()){\n\t\tif(i!=0)ss<<BR;\n\t\tss<< toString(map[i]);\n\t}\n\treturn ss.str();\n}\ntemplate<class K,class V>  string toString(map<K,V>& x) {\n\tstring res;stringstream ss;\n\tfor(auto& p:x)ss<< p.first<<\":\" << p.second<<\" \";\n\treturn ss.str();\n}\n\nstring BITtoString(int bit){\n    stringstream ss;\n    while(bit!=0){ss<<(bit%2);bit/=2;}\n    string res=ss.str();reverse(ALL(res));\n    return res;\n}\n\ntemplate<typename T,typename V> inline T pmod(T v,V MOD){\n\treturn (v%MOD+MOD)%MOD;\n}\ndouble pfmod(double v,double MOD){\n\treturn fmod(fmod(v,MOD)+MOD,MOD);\n}\n\nclass Comp{\npublic:\n\tbool operator () (const pair<int,int>& l,const pair<int,int>& r){\n\t\tif(l.first!=r.first)return l.first>r.first;\n\t\treturn l.second<r.second;\n\t}\n};\n\nnamespace Ps{\n\tconst double EPS = 1e-8;\n\tconst double INF = 1e12;\n\n\ttypedef complex<double> P;\n\t#define X(a) (real(a))\n\t#define Y(a) (imag(a))\n\t\n\t// a×b\n\tdouble cross(const P& a,const P& b){\n\t\treturn imag(conj(a)*b);\n\t}\n\t// a・b\n\tdouble dot(const P&a,const P& b) {\n\t\treturn real(conj(a)*b);\n\t}\n\n\t int ccw(const P& a,P b,P c){\n\t\tb -= a; c -= a;\n\t\t  if (cross(b,c) > 0)   return +1;       // counter clockwise\n\t\t  if (cross(b,c) < 0)   return -1;       // clockwise\n\t\t  if (dot(b,c) < 0)     return +2;       // c--a--b on line\n\t\t  if (norm(b) < norm(c)) return -2;       // a--b--c on line\n\t\t  return 0;\n\t  }\n}\nusing namespace Ps;\n\ndouble Abs(double a){double ret=max(a,-a);if(ret>M_PI)ret=2*M_PI-ret;return ret;}\nclass Main{\npublic:\n\tbool canReach(int x,int y,int w,int a,int d){\n\t\tif((ll)x*x+(ll)y*y<=(ll)a*a)\n\t\tif(Abs(w*M_PI/180-atan2(y,x))<=d*M_PI/180/2)return true;\n\t\t\n\t\treturn false;\n\t}\n\n\tvoid run(){\n\n\t\twhile(true){\n\t\t\tint H,R;scanf(\"%d%d\",&H,&R);if(H==0)break;\n\n\t\t\tvector<int> xs(H),ys(H);\n\t\t\tREP(h,H)scanf(\"%d%d\",&xs[h],&ys[h]);\n\t\t\tint U,M,S,du,dm,ds;scanf(\"%d%d%d%d%d%d\",&U,&M,&S,&du,&dm,&ds);\n\n\t\t\tvector<int> uxs(U),uys(U);vector<int> mxs(M),mys(M);vector<int> sxs(S),sys(S);\n\t\t\tREP(i,U)scanf(\"%d%d\",&uxs[i],&uys[i]);\n\t\t\tREP(i,M)scanf(\"%d%d\",&mxs[i],&mys[i]);\n\t\t\tREP(i,S)scanf(\"%d%d\",&sxs[i],&sys[i]);\n\t\t\t\n\t\t\tvector<int> ws(R),as(R);\n\t\t\tREP(i,R)scanf(\"%d%d\",&ws[i],&as[i]);\n\n\n\t\t\tvector<pair<int,int>> res;\n\t\t\tREP(h,H){\n\t\t\t\tint x=xs[h],y=ys[h];\n\n\t\t\t\tint okc=0;\n\t\t\t\tREP(r,R){\n\t\t\t\t\tint w=ws[r],a=as[r];\n\t\t\t\t\tbool ok=false;\n\t\t\t\t\tif(canReach(x,y,w,a,du))ok=true;\n\t\t\t\t\tREP(i,U)if(canReach(x-uxs[i],y-uys[i],w,a,du))ok=false;\n\t\t\t\t\tREP(i,M)if(canReach(x-mxs[i],y-mys[i],w,a,dm))ok=false;\n\t\t\t\t\tREP(i,S)if(canReach(x-sxs[i],y-sys[i],w,a,ds))ok=false;\n\t\t\t\t\tif(ok)okc++;\n\t\t\t\t}\n\t\t\t\tres.push_back(make_pair(okc,h+1));\n\t\t\t}\n\t\t\tsort(ALL(res),Comp());\n\n\t\t\tint Mh=res[0].first;\n\t\t\t\n\t\t\tif(Mh==0){\n\t\t\t\tcout<<\"NA\"<<endl;continue;\n\t\t\t}\n\n\t\t\tfor(int i=0;i<H && Mh==res[i].first;i++){\n\t\t\t\tif(i!=0)cout <<\" \";\n\t\t\t\tcout << res[i].second; \n\t\t\t}\n\t\t\tcout <<endl;\n\t\t}\n\t}\n};\n\n int main(){\n\t//ios::sync_with_stdio(false);\n \tMain().run();\n \treturn 0;\n }"
  },
  {
    "language": "C++",
    "code": "#include \"bits/stdc++.h\"\n#include<unordered_map>\n#include<unordered_set>\n#pragma warning(disable:4996)\nusing namespace std;\nusing ld = long double;\ntemplate<class T>\nusing Table = vector<vector<T>>;\nconst ld eps=1e-9;\n\n/* ??????????????¬ */\n\n#include <complex>\n\ntypedef long double ld;\ntypedef complex<ld> Point;\n#define REP(i,n) for(int i=0;i<(int)(n);i++)\n#define ALL(x) (x).begin(),(x).end()\n\n\nconst ld pi = acos(-1.0);\nconst ld dtop = pi / 180.;\nconst ld ptod = 1. / dtop;\n\nnamespace std {\n\tbool operator<(const Point &lhs, const Point &rhs) {\n\t\tif (lhs.real() < rhs.real() - eps) return true;\n\t\tif (lhs.real() > rhs.real() + eps) return false;\n\t\treturn lhs.imag() < rhs.imag();\n\t}\n}\n\n// ????????\\???\nPoint input_point() {\n\tld x, y;\n\tcin >> x >> y;\n\treturn Point(x, y);\n}\n\n// ????????????????????????\nbool eq(const ld a, const ld b) {\n\treturn (abs(a - b) < eps);\n}\n\n// ??????\nld dot(const Point& a, const Point& b) {\n\treturn real(conj(a) * b);\n}\n\n// ??????\nld cross(const Point& a, const Point& b) {\n\treturn imag(conj(a) * b);\n}\n\n// ??´????????????\nclass Line {\npublic:\n\tPoint a, b;\n\tLine() : a(Point(0, 0)), b(Point(0, 0)) {}\n\tLine(Point a, Point b) : a(a), b(b) {}\n\tPoint operator[](const int _num)const {\n\t\tif (_num == 0)return a;\n\t\telse if (_num == 1)return b;\n\t\telse {\n\t\t\tassert(false);\n\t\t\treturn Point();\n\t\t}\n\t}\n};\n\n// ????????????\nclass Circle {\npublic:\n\tPoint p;\n\tld r;\n\tCircle() : p(Point(0, 0)), r(0) {}\n\tCircle(Point p, ld r) : p(p), r(r) {}\n};\n\n// CCW\nint ccw(const Point& a, const Point &b, const Point &c) {\n\tconst Point nb(b - a);\n\tconst Point nc(c - a);\n\tif (cross(nb, nc) > eps) return 1;   // a,b,c??????????¨???¨?????????????????¶\n\tif (cross(nb, nc) < -eps) return -1; // a,b,c???????¨???¨?????????????????¶\n\tif (dot(nb, nc) < 0) return 2;       // c,a,b???????????´???????????¶\n\tif (norm(nb) < norm(nc)) return -2;  // a,b,c???????????´???????????¶\n\treturn 0;                          // a,c,b???????????´???????????¶\n}\n\n\n/* ???????????? */\n\n// ??´?????¨??´??????????????????\nbool isis_ll(const Line& l, const Line& m) {\n\treturn !eq(cross(l.b - l.a, m.b - m.a), 0);\n}\n\n// ??´?????¨?????????????????????\nbool isis_ls(const Line& l, const Line& s) {\n\treturn isis_ll(l, s) &&\n\t\t(cross(l.b - l.a, s.a - l.a) * cross(l.b - l.a, s.b - l.a) < eps);\n}\n\n// ????????¨?????????????????????\nbool isis_ss(const Line& s, const Line& t) {\n\treturn ccw(s.a, s.b, t.a) * ccw(s.a, s.b, t.b) <= 0 &&\n\t\tccw(t.a, t.b, s.a) * ccw(t.a, t.b, s.b) <= 0;\n}\n\n// ????????´????????????\nbool isis_lp(const Line& l, const Point& p) {\n\treturn (abs(cross(l.b - p, l.a - p)) < eps);\n}\n\n// ?????????????????????\nbool isis_sp(const Line& s, const Point& p) {\n\treturn (abs(s.a - p) + abs(s.b - p) - abs(s.b - s.a) < eps);\n}\n\n// ??????????¶?\nPoint proj(const Line &l, const Point& p) {\n\tld t = dot(p - l.a, l.a - l.b) / norm(l.a - l.b);\n\treturn l.a + t * (l.a - l.b);\n}\n\n// ??´?????¨??´????????????\nPoint is_ll(const Line &s, const Line& t) {\n\tPoint sv = s.b - s.a, tv = t.b - t.a;\n\tassert(cross(sv, tv) != 0);\n\treturn s.a + sv * cross(tv, t.a - s.a) / cross(tv, sv);\n}\n// ??´?????¨??´????????????\nvector<Point> is_ll2(const Line &s, const Line& t) {\n\tPoint sv = s.b - s.a, tv = t.b - t.a;\n\tif (cross(sv, tv) != 0)return vector<Point>(1, is_ll(s, t));\n\telse {\n\t\tvector<Point>ans;\n\t\tfor (int k = 0; k < 2; ++k) {\n\t\t\tif (isis_sp(s, t[k]) && find(ans.begin(), ans.end(), t[k]) == ans.end())ans.push_back(t[k]);\n\t\t\tif (isis_sp(t, s[k]) && find(ans.begin(), ans.end(), s[k]) == ans.end())ans.push_back(s[k]);\n\t\t}\n\t\treturn ans;\n\t}\n}\n// ????????¨???????????????\n//???????????£????????¨???????????¨assert(false)\nPoint is_ss(const Line &s, const Line& t) {\n\tif (isis_ss(s, t)) {\n\t\tfor (int k = 0; k < 2; ++k) {\n\t\t\tfor (int l = 0; l < 2; ++l) {\n\t\t\t\tif (s[k] == t[l])return s[k];\n\t\t\t}\n\t\t}\n\t\treturn is_ll(s, t);\n\t}\n\telse {\n\t\t//??????isis_ss?????????\n\t\tassert(false);\n\t\treturn Point(0, 0);\n\t}\n}\n// ????????¨???????????????\nvector<Point> is_ss2(const Line &s, const Line& t) {\n\tvector<Point> kouho(is_ll2(s, t));\n\tvector<Point>ans;\n\tfor (auto p : kouho) {\n\t\tif (isis_sp(s, p) && isis_sp(t, p))ans.emplace_back(p);\n\t}\n\treturn ans;\n}\n// ??´?????¨???????????¢\nld dist_lp(const Line& l, const Point& p) {\n\treturn abs(p - proj(l, p));\n}\n\n// ??´?????¨??´???????????¢\nld dist_ll(const Line& l, const Line& m) {\n\treturn isis_ll(l, m) ? 0 : dist_lp(l, m.a);\n}\n\n// ??´?????¨??????????????¢\nld dist_ls(const Line& l, const Line& s) {\n\treturn isis_ls(l, s) ? 0 : min(dist_lp(l, s.a), dist_lp(l, s.b));\n}\n\n// ????????¨???????????¢\nld dist_sp(const Line& s, const Point& p) {\n\tPoint r = proj(s, p);\n\treturn isis_sp(s, r) ? abs(r - p) : min(abs(s.a - p), abs(s.b - p));\n}\n\n// ????????¨??????????????¢\nld dist_ss(const Line& s, const Line& t) {\n\tif (isis_ss(s, t)) return 0;\n\treturn min({ dist_sp(s, t.a), dist_sp(s, t.b), dist_sp(t, s.a), dist_sp(t, s.b) });\n}\n\n\n//??´?????¨??´?????????????????????????????????\nLine bisection(const Line &s, const Line &t) {\n\tconst Point laglanju(is_ll(s, t));\n\tconst Point avec = !(abs(laglanju - s[0])<eps) ? s[0] - laglanju : s[1] - laglanju;\n\tconst Point bvec = !(abs(laglanju - t[0])<eps) ? t[0] - laglanju : t[1] - laglanju;\n\n\treturn Line(laglanju, laglanju + (abs(bvec)*avec + abs(avec)*bvec) / (abs(avec) + abs(bvec)));\n}\n\n\n//???????????´?????????????????????\n//???????????´??????????????§???????????¨????¢?????????¨?????????\nPoint  inner_center(const vector<Line>&ls) {\n\tvector<Point>vertics;\n\tfor (int i = 0; i <static_cast<int>(ls.size()); ++i) {\n\t\tvertics.push_back(is_ll(ls[i], ls[(i + 1) % 3]));\n\t}\n\tif (vertics[0] == vertics[1] || vertics[1] == vertics[2] || vertics[2] == vertics[0])return vertics[0];\n\tLine bi1(bisection(Line(vertics[0], vertics[1]), Line(vertics[0], vertics[2])));\n\tLine bi2(bisection(Line(vertics[1], vertics[2]), Line(vertics[1], vertics[0])));\n\tif (bi1[0] == bi2[0])return bi1[0];\n\telse {\n\t\treturn is_ll(bi1, bi2);\n\t}\n}\n\n//???????????´?????????????????????\n//???????????´??????????????§???????????¨????¢?????????¨?????????\nvector<Point>  ex_center(const vector<Line>&ls) {\n\tvector<Point>vertics;\n\tfor (int i = 0; i < static_cast<int>(ls.size()); ++i) {\n\t\tvertics.push_back(is_ll(ls[i], ls[(i + 1) % 3]));\n\t}\n\tif (abs(vertics[0] - vertics[1])<eps || abs(vertics[1] - vertics[2])<eps || (abs(vertics[2] - vertics[0])<eps))return vector<Point>();\n\tvector<Point>ecs;\n\tfor (int i = 0; i < 3; ++i) {\n\t\tLine bi1(bisection(Line(vertics[i], vertics[i] * 2.0l - vertics[(i + 2) % 3]), Line(vertics[i], vertics[(i + 1) % 3])));\n\t\tLine bi2(bisection(Line(vertics[(i + 1) % 3], vertics[(i + 1) % 3] * 2.0l - vertics[(i + 2) % 3]), Line(vertics[(i + 1) % 3], vertics[i])));\n\t\tecs.push_back(is_ll(bi1, bi2));\n\t}\n\treturn ecs;\n}\n\n\n//a,b:??????\n//c:????????§??????\n//???????????´?????????????????¢?????????????±??????????\nvector<Point>  same_dis(const vector<Line>&ls) {\n\tvector<Point>vertics;\n\tvertics.push_back(is_ll(ls[0], ls[2]));\n\tvertics.push_back(is_ll(ls[1], ls[2]));\n\n\tif (abs(vertics[0] - vertics[1]) < eps)return vector<Point>{vertics[0]};\n\tLine bis(bisection(ls[0], ls[1]));\n\tvector<Point>ecs;\n\n\tLine abi(bisection(Line(vertics[0], vertics[1]), ls[0]));\n\tecs.push_back(is_ll(bis, abi));\n\n\n\tLine bbi(bisection(Line(vertics[0], 2.l*vertics[0] - vertics[1]), ls[0]));\n\tecs.push_back(is_ll(bis, bbi));\n\n\treturn ecs;\n}\n/* ??? */\n\n// ?????¨????????????\nvector<Point> is_cc(const Circle& c1, const Circle& c2) {\n\tvector<Point> res;\n\tld d = abs(c1.p - c2.p);\n\tld rc = (d * d + c1.r * c1.r - c2.r * c2.r) / (2 * d);\n\tld dfr = c1.r * c1.r - rc * rc;\n\tif (abs(dfr) < eps) dfr = 0.0;\n\telse if (dfr < 0.0) return res; // no intersection\n\tld rs = sqrt(dfr);\n\tPoint diff = (c2.p - c1.p) / d;\n\tres.push_back(c1.p + diff * Point(rc, rs));\n\tif (dfr != 0.0) res.push_back(c1.p + diff * Point(rc, -rs));\n\treturn res;\n}\n\n//???????????????????????????\n//  0 => out\n//  1 => on\n//  2 => in\nint is_in_circle(const Circle &cir, const  Point& p) {\n\tld dis = abs(cir.p - p);\n\tif (dis > cir.r + eps)return 0;\n\telse if (dis < cir.r - eps)return 2;\n\telse return 1;\n}\n//???lc??????rc??????????????????\n//  0 => out\n//  1 => on\n//  2 => in\nint circle_in_circle(const Circle &lc, const  Circle&rc) {\n\tld dis = abs(lc.p - rc.p);\n\tif (dis < rc.r - lc.r - eps)return 2;\n\telse if (dis>rc.r - lc.r + eps)return 0;\n\telse return 1;\n}\n\n// ?????¨??´????????????\nvector<Point> is_lc(const Circle& c, const Line& l) {\n\tvector<Point> res;\n\tld d = dist_lp(l, c.p);\n\tif (d < c.r + eps) {\n\t\tld len = (d > c.r) ? 0.0 : sqrt(c.r * c.r - d * d); //safety;\n\t\tPoint nor = (l.a - l.b) / abs(l.a - l.b);\n\t\tres.push_back(proj(l, c.p) + len * nor);\n\t\tres.push_back(proj(l, c.p) - len * nor);\n\t}\n\treturn res;\n}\n\n// ?????¨??????????????¢\nvector<Point> is_sc(const Circle& c, const Line& l) {\n\tvector<Point> v = is_lc(c, l), res;\n\tfor (Point p : v)\n\t\tif (isis_sp(l, p)) res.push_back(p);\n\treturn res;\n}\n\n// ?????¨????????\\???\nvector<Line> tangent_cp(const Circle& c, const Point& p) {\n\tvector<Line> ret;\n\tPoint v = c.p - p;\n\tld d = abs(v);\n\tld l = sqrt(norm(v) - c.r * c.r);\n\tif (isnan(l)) { return ret; }\n\tPoint v1 = v * Point(l / d, c.r / d);\n\tPoint v2 = v * Point(l / d, -c.r / d);\n\tret.push_back(Line(p, p + v1));\n\tif (l < eps) return ret;\n\tret.push_back(Line(p, p + v2));\n\treturn ret;\n}\n\n// ?????¨????????\\???\nvector<Line> tangent_cc(const Circle& c1, const Circle& c2) {\n\tvector<Line> ret;\n\tif (abs(c1.p - c2.p) - (c1.r + c2.r) > -eps) {\n\t\tPoint center = (c1.p * c2.r + c2.p * c1.r) / (c1.r + c2.r);\n\t\tret = tangent_cp(c1, center);\n\t}\n\tif (abs(c1.r - c2.r) > eps) {\n\t\tPoint out = (-c1.p * c2.r + c2.p * c1.r) / (c1.r - c2.r);\n\t\tvector<Line> nret = tangent_cp(c1, out);\n\t\tret.insert(ret.end(), ALL(nret));\n\t}\n\telse {\n\t\tPoint v = c2.p - c1.p;\n\t\tv /= abs(v);\n\t\tPoint q1 = c1.p + v * Point(0, 1) * c1.r;\n\t\tPoint q2 = c1.p + v * Point(0, -1) * c1.r;\n\t\tret.push_back(Line(q1, q1 + v));\n\t\tret.push_back(Line(q2, q2 + v));\n\t}\n\treturn ret;\n}\n//??????????????????????????¢???\nld two_circle_area(const Circle&l, const Circle&r) {\n\tld dis = abs(l.p - r.p);\n\tif (dis > l.r + r.r)return 0;\n\telse if (dis + r.r < l.r) {\n\t\treturn r.r*r.r*pi;\n\t}\n\telse if (dis + l.r < r.r) {\n\t\treturn l.r*l.r*pi;\n\t}\n\telse {\n\t\tld ans = (l.r)*(l.r)*acos((dis*dis + l.r*l.r - r.r*r.r) / (2 * dis*l.r)) +\n\t\t\t(r.r)*(r.r)*acos((dis*dis + r.r*r.r - l.r*l.r) / (2 * dis*r.r)) -\n\t\t\tsqrt(4 * dis*dis*l.r*l.r - (dis*dis + l.r*l.r - r.r*r.r)*(dis*dis + l.r*l.r - r.r*r.r)) / 2;\n\t\treturn ans;\n\t}\n\n}\n\n/* ????§???¢ */\n\ntypedef vector<Point> Polygon;\n\n// ??¢???\nld area(const Polygon &p) {\n\tld res = 0;\n\tint n = p.size();\n\tREP(j, n) res += cross(p[j], p[(j + 1) % n]);\n\treturn res / 2;\n}\n\n// ????§???¢????????¢??????\nbool is_counter_clockwise(const Polygon &poly) {\n\tld angle = 0;\n\tint n = poly.size();\n\tREP(i, n) {\n\t\tPoint a = poly[i], b = poly[(i + 1) % n], c = poly[(i + 2) % n];\n\t\tangle += arg((c - b) / (b - a));\n\t}\n\treturn angle > eps;\n}\n\n// ??????????????????\n//  0 => out\n//  1 => on\n//  2 => in\nint is_in_polygon(const Polygon &poly, const  Point& p) {\n\tld angle = 0;\n\tint n = poly.size();\n\tREP(i, n) {\n\t\tPoint a = poly[i], b = poly[(i + 1) % n];\n\t\tif (isis_sp(Line(a, b), p)) return 1;\n\t\tangle += arg((b - p) / (a - p));\n\t}\n\treturn eq(angle, 0) ? 0 : 2;\n}\n//??????????????????2?????????\nenum { OUT, ON, IN };\nint convex_contains(const Polygon &P, const Point &p) {\n\tconst int n = P.size();\n\tPoint g = (P[0] + P[n / 3] + P[2 * n / 3]) / 3.0l; // inner-point\n\tint a = 0, b = n;\n\twhile (a + 1 < b) { // invariant: c is in fan g-P[a]-P[b]\n\t\tint c = (a + b) / 2;\n\t\tif (cross(P[a] - g, P[c] - g) > 0) { // angle < 180 deg\n\t\t\tif (cross(P[a] - g, p - g) > 0 && cross(P[c] - g, p - g) < 0) b = c;\n\t\t\telse                                                  a = c;\n\t\t}\n\t\telse {\n\t\t\tif (cross(P[a] - g, p - g) < 0 && cross(P[c] - g, p - g) > 0) a = c;\n\t\t\telse                                                  b = c;\n\t\t}\n\t}\n\tb %= n;\n\tif (cross(P[a] - p, P[b] - p) < 0) return 0;\n\tif (cross(P[a] - p, P[b] - p) > 0) return 2;\n\treturn 1;\n}\n\n// ??????\n// ???????????????????????¨????????????????????§??¨???\nPolygon convex_hull(vector<Point> ps) {\n\tint n = ps.size();\n\tint k = 0;\n\tsort(ps.begin(), ps.end());\n\tPolygon ch(2 * n);\n\tfor (int i = 0; i < n; ch[k++] = ps[i++])\n\t\twhile (k >= 2 && ccw(ch[k - 2], ch[k - 1], ps[i]) <= 0) --k;\n\tfor (int i = n - 2, t = k + 1; i >= 0; ch[k++] = ps[i--])\n\t\twhile (k >= t && ccw(ch[k - 2], ch[k - 1], ps[i]) <= 0) --k;\n\tch.resize(k - 1);\n\treturn ch;\n}\n\n\n\n// ????????????\nvector<Polygon> convex_cut(const Polygon &ps, const Line& l) {\n\tint n = ps.size();\n\tPolygon Q;\n\tPolygon R;\n\tREP(i, n) {\n\t\tPoint A = ps[i], B = ps[(i + 1) % n];\n\t\tLine m = Line(A, B);\n\t\tif (ccw(l.a, l.b, A) != -1) Q.push_back(A);\n\t\tif (ccw(l.a, l.b, A) != 1) R.push_back(A);\n\t\tif (ccw(l.a, l.b, A) * ccw(l.a, l.b, B) < 0 && isis_ll(l, m)) {\n\t\t\tQ.push_back(is_ll(l, m));\n\t\t\tR.push_back(is_ll(l, m));\n\t\t}\n\t}\n\tconst vector<Polygon>polys{ Q,R };\n\treturn polys;\n}\n\n\n/* ??¢??¬??????????????? */\nvoid add_point(vector<Point> &ps, const Point p) {\n\tfor (Point q : ps) if (abs(q - p) < eps) return;\n\tps.push_back(p);\n}\n\ntypedef int Weight;\nstruct Edge {\n\tint src, dst;\n\tWeight weight;\n\tEdge(int src, int dst, Weight weight) :\n\t\tsrc(src), dst(dst), weight(weight) { }\n};\n\ntypedef vector<Edge> Edges;\ntypedef vector<Edges> Graph;\n\nvoid add_edge(Graph &g, const int from, const int to, const Weight weight) {\n\tg[from].push_back(Edge{ from, to, weight });\n}\n\nGraph segment_arrangement(const vector<Line> &s, const vector<Point> &p) {\n\tint n = p.size(), m = s.size();\n\tGraph g(n);\n\tREP(i, m) {\n\t\tvector<pair<ld, int>> vec;\n\t\tREP(j, n) if (isis_sp(s[i], p[j]))\n\t\t\tvec.emplace_back(abs(s[i].a - p[j]), j);\n\t\tsort(ALL(vec));\n\t\tREP(j, vec.size() - 1) {\n\t\t\tint from = vec[j].second, to = vec[j + 1].second;\n\t\t\tadd_edge(g, from, to, static_cast<Weight>(abs(p[from] - p[to])));\n\t\t}\n\t}\n\treturn g;\n}\nGraph sennbunn_arrangement(const vector<Line>&s) {\n\tvector<Point>crss;\n\tfor (int i = 0; i < static_cast<int>(s.size()); ++i) {\n\t\tfor (int j = i + 1; j < static_cast<int>(s.size()); ++j) {\n\t\t\tif (isis_ss(s[i], s[j])) {\n\t\t\t\tcrss.push_back(is_ll(s[i], s[j]));\n\t\t\t}\n\t\t}\n\t}\n\tfor (int i = 0; i <static_cast<int>(s.size()); ++i) {\n\t\tcrss.push_back(s[i][0]);\n\t\tcrss.push_back(s[i][1]);\n\t}\n\treturn segment_arrangement(s, crss);\n}\n\n//Graph circle_arrangement(const vector<Circle> &c, const vector<Point> &p) {\n//\tint n = p.size(), m = c.size();\n//\tGraph g(n);\n//\tREP(i, m) {\n//\t\tvector<pair<ld, int>> vec;\n//\t\tREP(j, n) if (abs(abs(c[i].p - p[j]) - c[i].r) < eps)\n//\t\t\tvec.emplace_back(arg(c[i].p - p[j]), j);\n//\t\tsort(ALL(vec));\n//\t\tREP(j, vec.size() - 1) {\n//\t\t\tint from = vec[j].second, to = vec[j + 1].second;\n//\t\t\tld angle = vec[j + 1].first - vec[j].first;\n//\t\t\tadd_edge(g, from, to, static_cast<Weight>(angle * c[i].r));\n//\t\t}\n//\t\tif (vec.size() >= 2) {\n//\t\t\tint from = vec.back().second, to = vec.front().first;\n//\t\t\tld angle = vec.front().first - vec.back().first;\n//\t\t\tadd_edge(g, from, to, static_cast<Weight>(angle * c[i].r));\n//\t\t}\n//\t}\n//\treturn g;\n//}\n\n\n/* ????????°?????? */\n\n// ?????????????????¢?????¢??¬??????????????????????????????????????°???????????????\n// ?????´?????????????¨?????????§????????´????????????????¨?????????§???????????????\n// ?????° polygon ??????vector<int> ??§??¨?????????????§???¢???????????§?????????\n// vector<int> ??§??¨????????? ????§???¢???i???????????????????????????????????????p????????????????????§?????????\nvector<vector<int>> polygon;\nvector<int> seg2p[1024][1024];\n\n//Graph dual_graph(const vector<Line> &s, const vector<Point> &p) {\n//\tint N = p.size();\n//\tpolygon.clear();\n//\tREP(i, 1024) REP(j, 1024) seg2p[i][j].clear();\n//\tvector<vector<tuple<ld, int, bool>>> tup(N);\n//\tREP(i, s.size()) {\n//\t\tint a = -1, b = -1;\n//\t\tREP(j, N) if (abs(s[i].a - p[j]) < eps) a = j;\n//\t\tREP(j, N) if (abs(s[i].b - p[j]) < eps) b = j;\n//\t\tassert(a >= 0 && b >= 0);\n//\t\ttup[a].emplace_back(arg(s[i].b - s[i].a), b, false);\n//\t\ttup[b].emplace_back(arg(s[i].a - s[i].b), a, false);\n//\t}\n//\tREP(i, N) sort(ALL(tup[i]));\n//\tREP(i, N) {\n//\t\tREP(j, tup[i].size()) {\n//\t\t\tld angle; int pos = j, from = i, to; bool flag;\n//\t\t\ttie(angle, to, flag) = tup[i][j];\n//\t\t\tif (flag) continue;\n//\t\t\tvector<int> ps;\n//\t\t\twhile (!flag) {\n//\t\t\t\tps.push_back(from);\n//\t\t\t\tget<2>(tup[from][pos]) = true;\n//\t\t\t\tseg2p[from][to].push_back(polygon.size());\n//\t\t\t\tseg2p[to][from].push_back(polygon.size());\n//\t\t\t\tangle += pi + eps;\n//\t\t\t\tif (angle > pi) angle -= 2 * pi;\n//\t\t\t\tauto it = lower_bound(ALL(tup[to]), make_tuple(angle, 0, false));\n//\t\t\t\tif (it == tup[to].end()) it = tup[to].begin();\n//\t\t\t\tfrom = to; tie(angle, to, flag) = *it;\n//\t\t\t\tpos = it - tup[from].begin();\n//\t\t\t}\n//\t\t\tpolygon.push_back(ps);\n//\t\t}\n//\t}\n//\tGraph g(polygon.size());\n//\tREP(i, N) REP(j, i) {\n//\t\tif (seg2p[i][j].size() == 2) {\n//\t\t\tint from = seg2p[i][j][0], to = seg2p[i][j][1];\n//\t\t\tg[from].push_back(Edge{ from, to });\n//\t\t\tg[to].push_back(Edge{ to, from });\n//\t\t}\n//\t}\n//\treturn g;\n//}\n\nstruct flo {\n\tPoint p;\n\tld the;\n};\nbool check(const flo&f, const Point p,const ld len,const ld theta) {\n\tconst ld dis = abs(f.p - p);\n\tif (dis-eps > len) {\n\t\treturn false;\n\t}\n\telse {\n\t\tld kaku = atan2(p.imag() - f.p.imag(), p.real() - f.p.real());\n\t\tif (kaku < 0)kaku += pi;\n\t\tld sa = abs(kaku - theta);\n\t\tsa = min(sa, 2 * pi - sa);\n\t\tif (sa < f.the / 2)return true;\n\t\telse return false;\n\t}\n}\nint main() {\n\twhile (1) {\n\t\tvector<Point>houses;\n\t\tint H, R; cin >> H >> R;\n\t\tif (!H)break;\n\t\tfor (int i = 0; i < H; ++i) {\n\t\t\tint x, y; cin >> x >> y;\n\t\t\thouses.emplace_back(x, y);\n\t\t}\n\t\tint U, M, S;ld du, dm, ds;  cin >> U >> M >> S >> du >> dm >> ds;\n\t\tdu *= dtop;\n\t\tdm *= dtop;\n\t\tds *= dtop;\n\t\tvector<flo>flowers;\n\t\tfor (int i = 0; i < U; ++i) {\n\t\t\tint x, y; cin >> x >> y;\n\t\t\tflowers.push_back(flo{ Point(x,y),du });\n\t\t}\n\t\tfor (int i = 0; i < M; ++i) {\n\t\t\tint x, y; cin >> x >> y;\n\t\t\tflowers.push_back(flo{ Point(x,y),dm });\n\t\t}\n\t\tfor (int i = 0; i < S; ++i) {\n\t\t\tint x, y; cin >> x >> y;\n\t\t\tflowers.push_back(flo{ Point(x,y),ds });\n\t\t}\n\t\tflo myflower{ Point(0,0),du };\n\t\tint ans = 0;\n\t\tvector<int>nums(H);\n\t\tfor (int i = 0; i < R; ++i) {\n\t\t\tld w, a; cin >> a >> w;\n\t\t\ta *= dtop;\n\t\t\tfor (int h = 0; h < H; ++h) {\n\t\t\t\tPoint p(houses[h]);\n\t\t\t\tif (check(myflower, p, w, a)) {\n\n\t\t\t\t\tbool aok = true;\n\t\t\t\t\tfor (auto f : flowers) {\n\t\t\t\t\t\tif (check(f, p, w, a)) {\n\t\t\t\t\t\t\taok = false;\n\t\t\t\t\t\t\tbreak;\n\t\t\t\t\t\t}\n\t\t\t\t\t}\n\t\t\t\t\tif (aok) {\n\t\t\t\t\t\tnums[h]++;\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t\tint amax = *max_element(nums.begin(), nums.end());\n\t\tif (amax) {\n\t\t\tvector<int>anss;\n\t\t\tfor (int i = 0; i < H; ++i) {\n\t\t\t\tif (amax == nums[i]) {\n\t\t\t\t\tanss.push_back(i+1);\n\t\t\t\t}\n\t\t\t}\n\t\t\tfor (int i = 0; i < anss.size(); ++i) {\n\t\t\t\tcout << anss[i];\n\t\t\t\tif (i != anss.size() - 1)cout << \" \";\n\t\t\t\telse cout << endl;\n\t\t\t}\n\t\t}\n\t\telse {\n\t\t\tcout << \"NA\" << endl;\n\t\t}\n\t}\n\treturn 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include <iostream>\n#include <vector> \n#include <cmath>\nusing namespace std;\n\n#define rep(i, n) for(int i = 0;i < n;i++)\n#define cin_pair(p) cin >> (p).first >> (p).second;\n\ntypedef pair<int, int> pos;\n\nbool isInSmell(int x, int y, int w, float d, int a, int cx, int cy) {\n    cx -= x; cy -= y;\n    x = y = 0;\n    int angle = atan2((double)cy, (double)cx) / M_PI * 180, lensq = cx * cx + cy * cy;\n    return (w - d / 2 <= angle && angle <= w + d / 2 && lensq <= a * a);\n}\n\nbool isInSmells(int w, float d, int a, vector<pos> &vec, int cx, int cy) {\n    //cout << vec.size();\n    rep(i, vec.size()) {\n        //cout << vec[i].first << ' ' << vec[i].second << endl;\n        if(isInSmell(vec[i].first, vec[i].second, w, d, a, cx, cy)) {\n            return true;\n        }\n    }\n}\n\nint main() {\n    int H, R;\n    int U, M, S, du, dm, ds;\n\n    while(true) {\n        cin >> H >> R;\n        if(!H && !R) break;\n\n        vector<pos> h(H);\n        rep(i, H) {\n            cin_pair(h[i]);\n        }\n        cin >> U >> M >> S >> du >> dm >> ds;\n        vector<pos> u(U), m(M), s(S), wa(R);\n        rep(i, U) {\n            cin_pair(u[i]);\n        }\n        rep(i, M) {\n            cin_pair(m[i]);\n        }\n        rep(i, S) {\n            cin_pair(s[i]);\n        }\n        rep(i, R) {\n            cin_pair(wa[i]);\n        }\n\n        vector<int> days(H, 0);\n        int maxa = -1;\n        rep(ri, R) {\n            rep(hi, H) {\n                int x = h[hi].first, y = h[hi].second;\n                int w = wa[ri].first, a = wa[ri].second;\n                if(\n                    !isInSmells(w, du, a, u, x, y) &&\n                    !isInSmells(w, dm, a, m, x, y) &&\n                    !isInSmells(w, ds, a, s, x, y) &&\n                    isInSmell(0, 0, w, du, a, x, y)\n                    ){\n                    days[hi]++;\n                    maxa = max(maxa, days[hi]);\n                }\n            }\n        }\n\n        //rep(i, days.size()) cout << days[i] << ' ';\n        //cout << endl;\n\n        int ansnum = 0;\n        rep(i, H) {\n            if(days[i] == maxa) ansnum++;\n        }\n        if(maxa == -1) {\n            cout << \"NA\" << endl;\n        }\n        else {\n            int j = 0;\n            rep(i, H) {\n                if(days[i] == maxa) {\n                    cout << i + 1;\n                    ansnum--;\n                    if(ansnum != 0) cout << ' ';\n                }\n            }\n            cout << endl;\n        }\n    }\n}"
  },
  {
    "language": "C++",
    "code": "#include<iostream>\n#include<vector>\n#include<cmath>\n#include<algorithm>\nusing namespace std;\n\nconst double PI = 3.14159265358979;\n\nclass Point {\npublic:\n    double x, y;\n    Point(double x = 0.0, double y = 0.0) :x(x), y(y) {}\n};\n\nclass Wind {\npublic:\n    double w, a;\n};\n\nbool include(double angle, double low, double high) {\n    if(low < 0.0 && low + 2.0 * PI <= angle) return true;\n    if(high >= 2.0 * PI && angle <= high - 2.0 * PI) return true;\n    return low <= angle && angle <= high;\n}\n\nbool savor(const Point &home, const Wind &wind, const vector<Point> &blossom, double d) {\n    d /= 2.0;\n    for(const auto &b: blossom) {\n        Point dif(home.x - b.x, home.y - b.y);\n        double angle = atan2(dif.y, dif.x);\n        double dist = hypot(dif.y, dif.x);\n        if(angle < 0.0) angle = angle + 2.0 * PI;\n        if(dist <= wind.a && include(angle, wind.w - d, wind.w + d)) return true;\n    }\n    return false;\n}\n\ndouble toRadian(double d) {\n    return d * PI / 180.0;\n}\n\nint main() {\n    int H, R;\n    while(cin >> H >> R, H | R) {\n        vector<Point> home(H);\n        for(auto &i: home) cin >> i.x >> i.y;\n\n        int U, M, S;\n        double du, dm, ds;\n        cin >> U >> M >> S >> du >> dm >> ds;\n\n        du = toRadian(du);\n        dm = toRadian(dm);\n        ds = toRadian(ds);\n\n        vector<Point> plum(U), peach(M), cherry(S);\n        for(auto &i: plum) cin >> i.x >> i.y;\n        for(auto &i: peach) cin >> i.x >> i.y;\n        for(auto &i: cherry) cin >> i.x >> i.y;\n\n        vector<Wind> wind(R);\n        for(auto &i: wind) cin >> i.w >> i.a;\n        for(auto &i: wind) i.w = toRadian(i.w);\n\n        // solve\n        vector<int> number(H, 0);\n        int maxNumber = 0;\n\n        for(int i = 0; i < H; ++i) {\n            for(int day = 0; day < R; ++day) {\n                bool ok = savor(home[i], wind[day], {Point(0.0, 0.0)}, du);\n                bool ng = false;\n                ng |= savor(home[i], wind[day], plum, du);\n                ng |= savor(home[i], wind[day], peach, dm);\n                ng |= savor(home[i], wind[day], cherry, ds);\n\n                if(!ok || ng) continue;\n\n                ++number[i];\n                maxNumber = max(maxNumber, number[i]);\n            }\n        }\n\n        if(maxNumber) {\n            bool first = true;\n            for(int i = 0; i < H; ++i) if(number[i] == maxNumber) {\n                if(!first) cout << \" \";\n                first = false;\n                cout << i + 1;\n            }\n            cout << endl;\n        } else {\n            cout << \"NA\" << endl;\n        }\n    }\n}"
  },
  {
    "language": "C++",
    "code": "#include<bits/stdc++.h>\n#define x real() \n#define y imag() \nusing namespace std;\ntypedef complex<double> P;\n\nint ccw(P a,P b,P c){\n  b-=a;\n  c-=a;\n  if(imag(conj(b)*c)>0)return 1;\n  if(imag(conj(b)*c)<0)return -1;\n  return 0;\n}\n\nint main(){\n  int H,R;\n  while(cin>>H>>R,H){\n    P h[100];\n    for(int i=0;i<H;i++)\n      cin>>h[i].x>>h[i].y;\n    int m[3];\n    double d[3],w[100],a[100];\n    P p[3][10];\n    cin>>m[0]>>m[1]>>m[2]>>d[0]>>d[1]>>d[2];\n\n    for(int i=0;i<3;i++)\n      for(int j=0;j<m[i];j++)\n\tcin>>p[i][j].x>>p[i][j].y;\n\n    for(int i=0;i<R;i++)cin>>w[i]>>a[i];\n\n    int c[100]={};\n\n    for(int i=0;i<R;i++){\n      bool f[100]={};\n      for(int j=0;j<H;j++){\n\tP D=P(a[i]*cos((M_PI*(w[i]-d[0]/2)/180)),a[i]*sin((M_PI*(w[i]-d[0]/2)/180)));\n\tP U=P(a[i]*cos((M_PI*(w[i]+d[0]/2)/180)),a[i]*sin((M_PI*(w[i]+d[0]/2)/180)));\n\tif(abs(h[j])<=a[i]&&ccw(P(0,0),U,h[j])<=0&&ccw(P(0,0),D,h[j])>=0)f[j]=1;\n      }\n\n      for(int j=0;j<3;j++)\n\tfor(int k=0;k<m[j];k++)\n\t  for(int l=0;l<H;l++){\n\t    P D=P(a[i]*cos((M_PI*(w[i]-d[j]/2)/180)),a[i]*sin((M_PI*(w[i]-d[j]/2)/180)));\n\t    P U=P(a[i]*cos((M_PI*(w[i]+d[j]/2)/180)),a[i]*sin((M_PI*(w[i]+d[j]/2)/180)));\n\t    if(abs(p[j][k]-h[l])<=a[i]&&ccw(p[j][k],p[j][k]+U,h[l])<=0&&ccw(p[j][k],p[j][k]+D,h[l])>=0)\n\t      f[l]=0;\n\t  }\n      for(int j=0;j<H;j++)c[j]+=f[j];\n    }\n    \n    int mx=0;\n    vector<int> ans;\n    for(int i=0;i<H;i++)mx=max(mx,c[i]);\n    if(mx){\n      for(int i=0;i<H;i++)\n\tif(mx==c[i])ans.push_back(i+1);\n      for(int i=0;i<ans.size();i++){\n\tif(i)cout<<\" \";\n\tcout<<ans[i];\n      }\n    }\n    else cout<<\"NA\";\n    cout<<endl;\n  }\n  return 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include <iostream>\n#include <algorithm>\n#include <vector>\n#include <complex>\n#include <cmath>\nusing namespace std;\n\ntypedef complex<double> P;\n\nconst double pi = acos(-1);\nconst double eps = 1e-3;\n\nbool equals(double a, double b) {\n  return abs(a-b) < eps;\n}\n\ndouble dot(P a, P b) {\n  return a.real()*b.real() + a.imag()*b.imag();\n}\n\ndouble cross(P a, P b) {\n  return a.real()*b.imag() - a.imag()*b.real();\n}\n\ninline double toRad(double d) {\n  return pi*d/180.0;\n}\n\nconst int WATASHIUME = 1<<0;\nconst int UME        = 1<<1;\nconst int MOMO       = 1<<2;\nconst int SAKURA     = 1<<3;\n\nstruct Tree {\n  P pos;\n  int type;\n  int d;\n};\n\nclass Field {\n  vector<Tree> trees;\npublic:\n  void add(const Tree &t) {\n    trees.push_back(t);\n  }\n\n  int reach(const int w, const int a, const P &p) {\n    int res = 0;\n    for(int i = 0; i < trees.size(); ++i) {\n      P m = p - trees[i].pos;\n      double dist = abs(m);\n      if(equals(dist, a) || dist < a) ; else continue;\n      P s = P( cos(toRad(w) - toRad(trees[i].d)/2.0),\n               sin(toRad(w) - toRad(trees[i].d)/2.0) );\n      P t = P( cos(toRad(w) + toRad(trees[i].d)/2.0),\n               sin(toRad(w) + toRad(trees[i].d)/2.0) );\n      double cs = cross(s, m);\n      double ct = cross(t, m);\n      if(  ( equals(cs, 0.0) || cs > 0.0 ) &&\n           ( equals(ct, 0.0) || ct < 0.0 )  ) {\n        res |= trees[i].type;\n      }\n    }\n    return res;\n  }\n};\n\nint main() {\n  int H, R;\n  int U, M, S, du, dm, ds;\n  while(cin >> H >> R && (H|R)) {\n    Field field;\n    vector<P> ps(H);\n    for(int i = 0; i < H; ++i) {\n      cin >> ps[i].real() >> ps[i].imag();\n    }\n    cin >> U >> M >> S >> du >> dm >> ds;\n    field.add((Tree){P(0,0), WATASHIUME, du});\n    for(int i = 0; i < U; ++i) {\n      P pos;\n      cin >> pos.real() >> pos.imag(); \n      field.add((Tree){pos, UME, du});\n    }\n    for(int i = 0; i < M; ++i) {\n      P pos;\n      cin >> pos.real() >> pos.imag(); \n      field.add((Tree){pos, MOMO, dm});\n    }\n    for(int i = 0; i < S; ++i) {\n      P pos;\n      cin >> pos.real() >> pos.imag(); \n      field.add((Tree){pos, SAKURA, ds});\n    }\n\n    int cnt[H], con[H];\n    fill(cnt, cnt+H, 0);\n    fill(con, con+H, 0);\n\n    while(R--) {\n      int w, a;\n      cin >> w >> a;\n      for(int i = 0; i < H; ++i) {\n        if(field.reach(w,a,ps[i]) == WATASHIUME) {\n          con[i] += 1;\n        } else {\n          con[i] = 0;\n        }\n        cnt[i] = max(cnt[i], con[i]);\n      }\n    }\n\n    vector<pair<int,int> > v;\n    for(int i = 0; i < H; ++i) {\n      if(cnt[i] != 0)\n        v.push_back(make_pair(-cnt[i], i+1));\n    }\n    if(v.size()) {\n      sort(v.begin(), v.end());\n      for(int i = 0; i < v.size(); ++i) {\n        if(i && v[i].first != v[i-1].first) break;\n        if(i) cout << \" \";\n        cout << v[i].second;\n      }\n      cout << endl;\n    } else {\n      cout << \"NA\" << endl;\n    }\n  }\n  return 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include <algorithm>\n#include <bitset>\n#include <cassert>\n#include <cctype>\n#include <climits>\n#include <cmath>\n#include <complex>\n#include <cstdio>\n#include <cstdlib>\n#include <cstring>\n#include <ctime>\n#include <deque>\n#include <fstream>\n#include <iomanip>\n#include <iostream>\n#include <map>\n#include <numeric>\n#include <queue>\n#include <set>\n#include <sstream>\n#include <stack>\n#include <string>\n#include <valarray>\n#include <vector>\n\n#define EPS 1e-9\n#define INF 1070000000LL\n#define MOD 1000000007LL\n#define fir first\n#define foreach(it,X) for(__typeof((X).begin()) it=(X).begin();it!=(X).end();it++)\n#define ite iterator\n#define mp make_pair\n#define rep(i,n) rep2(i,0,n)\n#define rep2(i,m,n) for(int i=m;i<(n);i++)\n#define pb push_back\n#define sec second\n#define sz(x) ((int)x.size())\n\nusing namespace std;\n\nstruct timer{\n\ttime_t start;\n\ttimer(){start=clock();}\n\t~timer(){cerr<<1.*(clock()-start)/CLOCKS_PER_SEC<<\" secs\"<<endl;}\n};\n\ntypedef istringstream iss;\ntypedef long long ll;\ntypedef pair<int,int> pi;\ntypedef stringstream sst;\ntypedef vector<int> vi;\n\n#define PI 3.14159265358979323846\n\ntypedef complex<double> P;\n\nint H,R,U,M,S,T;\nP h[111];\ndouble du,dm,ds;\nP t[33];\ndouble d[33];\ndouble w[111],a[111];\nint day[111];\n\nbool reach(P house,P tree,double D,double dir,double dist){\n\tif(abs(house-tree) > dist)return false;\n\tdouble ang = arg(house-tree);\n\tdouble dif = abs(ang-dir);\n\tdif = min(dif, 2*PI - dif);\n\tif(dif > D/2)return false;\n\treturn true;\n}\n\nint main(){\n\tcin.tie(0);\n\tios_base::sync_with_stdio(0);\n\t\n\twhile(cin>>H>>R && H){\n\t\tfill(day,day+H,0);\n\t\trep(i,H)cin>>h[i].real()>>h[i].imag();\n\t\t\n\t\tcin>>U>>M>>S>>du>>dm>>ds;\n\t\tT=U+M+S;\n\t\trep(i,T){\n\t\t\tcin>>t[i].real()>>t[i].imag();\n\t\t\tif(i<U) d[i]=du;\n\t\t\telse if(i<U+M) d[i]=dm;\n\t\t\telse d[i]=ds;\n\t\t\td[i]*=PI/180;\n\t\t}\n\t\tt[T].real()=t[T].imag()=0;\n\t\td[T]=du*PI/180;\n\t\t\n\t\trep(i,R){\n\t\t\tcin>>w[i]>>a[i];\n\t\t\tw[i]*=PI/180;\n\t\t}\n\t\t\n\t\trep(i,H){\n\t\t\trep(j,R){\n\t\t\t\tif(!reach(h[i],t[T],d[T],w[j],a[j]))continue;\n\t\t\t\tint ok=1;\n\t\t\t\trep(k,T){\n\t\t\t\t\tif(reach(h[i],t[k],d[k],w[j],a[j])){\n\t\t\t\t\t\tok=0;break;\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t\tday[i]+=ok;\n\t\t\t}\n\t\t}\n\t\t\n\t\tint max=*max_element(day,day+H);\n\t\tif(max==0)cout<<\"NA\"<<endl;\n\t\telse{\n\t\t\tvi ans;\n\t\t\trep(i,H)if(day[i]==max)ans.pb(i+1);\n\t\t\trep(i,sz(ans))cout<<ans[i]<<(i==sz(ans)-1?\"\\n\":\" \");\n\t\t}\n\t}\n}"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\nusing namespace std;\n#define REP(i,n) for(int i=0;i<(int)(n);++i)\n#define REPR(i,n) for (int i=(int)(n)-1;i>=0;--i)\n#define FOR(i,c) for(__typeof((c).begin())i=(c).begin();i!=(c).end();++i)\n#define ALL(c) (c).begin(), (c).end()\n#define valid(y,x,h,w) (0<=y&&y<h&&0<=x&&x<w)\n#define tpl(...) make_tuple(__VA_ARGS__)\nconst int INF = 0x3f3f3f3f;\nconst double EPS = 1e-8;\nconst double PI = acos(-1);\nconst int dy[] = {-1,0,1,0};\nconst int dx[] = {0,1,0,-1};\ntypedef long long ll;\ntypedef pair<int,int> pii;\ntemplate<class T>bool chmax(T &a, const T &b) { if (a<b) { a=b; return 1; } return 0; }\ntemplate<class T>bool chmin(T &a, const T &b) { if (b<a) { a=b; return 1; } return 0; }\ntemplate<typename Ch,typename Tr,typename C,typename=decltype(begin(C()))>basic_ostream<Ch,Tr>& operator<<(basic_ostream<Ch,Tr>&os,\nconst C& c){os<<'[';for(auto i=begin(c);i!=end(c);++i)os<<(i==begin(c)?\"\":\" \")<<*i;return os<<']';}\ntemplate<class S,class T>ostream&operator<<(ostream &o,const pair<S,T>&t){return o<<'('<<t.first<<','<<t.second<<')';}\ntemplate<int N,class Tp>void output(ostream&,const Tp&){}\ntemplate<int N,class Tp,class,class ...Ts>void output(ostream &o,const Tp&t){if(N)o<<',';o<<get<N>(t);output<N+1,Tp,Ts...>(o,t);}\ntemplate<class ...Ts>ostream&operator<<(ostream&o,const tuple<Ts...>&t){o<<'(';output<0,tuple<Ts...>,Ts...>(o,t);return o<<')';}\ntemplate<class T>void output(T t,char z=10){if(t<0)t=-t,putchar(45);int c[20];\nint k=0;while(t)c[k++]=t%10,t/=10;for(k||(c[k++]=0);k;)putchar(c[--k]^48);putchar(z);}\ntemplate<class T>void outputs(T t){output(t);}\ntemplate<class S,class ...T>void outputs(S a,T...t){output(a,32);outputs(t...);}\ntemplate<class T>void output(T *a,int n){REP(i,n)cout<<a[i]<<(i!=n-1?',':'\\n');}\ntemplate<class T>void output(T *a,int n,int m){REP(i,n)output(a[i],m);}\ntemplate<class T>bool input(T &t){int n=1,c;for(t=0;!isdigit(c=getchar())&&~c&&c-45;);\nif(!~c)return 0;for(c-45&&(n=0,t=c^48);isdigit(c=getchar());)t=10*t+c-48;t=n?-t:t;return 1;}\ntemplate<class S,class ...T>bool input(S&a,T&...t){input(a);return input(t...);}\ntemplate<class T>bool inputs(T *a, int n) { REP(i,n) if(!input(a[i])) return 0; return 1;}\n\ntemplate<class T>\nstruct Pt {\n  T x,y;\n  Pt(T x=T(), T y=T()) :x(x),y(y) {}\n  void in() {ll _x, _y; input(_x,_y); x=_x; y=_y; }\n  bool operator<(const Pt &p) const { return x!=p.x?x<p.x:y<p.y; }\n  bool operator==(const Pt &p) const { return x==p.x&&y==p.y; }\n  Pt operator+=(const Pt &p) { x+=p.x, y+=p.y; return *this; }\n  Pt operator-=(const Pt &p) { x-=p.x, y-=p.y; return *this; }\n  Pt operator*=(const Pt &p) { T t=x;x=x*p.x-y*p.y,y=t*p.y+y*p.x; return *this;}\n  Pt operator*=(const T &v) { x*=v; y*=v; return *this;}\n  friend ostream& operator<<(ostream& os, const Pt &p) {return os<<'('<<p.x<<','<<p.y<<')';}\n  friend istream& operator>>(istream& is, Pt &p) {return is>>p.x>>p.y;}\n\n  Pt operator+(const Pt &p) const { return Pt(*this)+=p; }\n  Pt operator-(const Pt &p) const { return Pt(*this)-=p; }\n  Pt operator*(const Pt &p) const { return Pt(*this)*=p; }\n  Pt operator*(const T &v) const { return Pt(*this)*=v; }\n  friend Pt operator*(const T &v, const Pt &p) { return p*v; }\n  bool operator!=(const Pt &p) const { return !(*this == p); }\n\n  T abs() const { return hypot(x,y); }\n  T norm() const { return x*x+y*y; }\n  T arg() const { return atan2(y,x); }\n  T dot(const Pt &p) const { return x*p.x+y*p.y; }\n  T det(const Pt &p) const { return x*p.y-y*p.x; }\n  friend T abs(const Pt &p) { return p.abs(); }\n  friend T norm(const Pt &p) { return p.norm(); }\n  friend T arg(const Pt &p) { return p.arg(); }\n  friend T dot(const Pt &p, const Pt &q) { return p.dot(q); }\n  friend T det(const Pt &p, const Pt &q) { return p.det(q); }\n};\n\nint sig(double r) {return r<-EPS?-1:r>EPS?1:0;}\nint sig(ll r) {return r<0?-1:r>0?1:0;}\nbool eq(double a, double b) {return sig(a-b)==0;}\nbool eq(ll a, ll b) {return a==b;}\nPt<double> pol(double len, double ang) { return Pt<double>(cos(ang),sin(ang)) * len; }\n\ntypedef Pt<double> P;\n\ndouble angle(const P &a, const P &b) {\n  double ret = arg(b)-arg(a);\n  if (!sig(ret)||!sig(ret-2*PI)) return 0;\n  return ret>0 ? ret : ret + 2*PI;\n}\n\ntemplate<typename _T>\nstruct Ci {\n  typedef _T T;\n  Pt<T> p; T r;\n  Ci(const Pt<T> &p, T r) : p(p), r(r) { }\n};\ntypedef Ci<double> C;\n\n// 扇型\nstruct CS : C {\n  P p1, p2;\n  CS(const P &p, const P &p1, const P &p2):\n    C(p,abs(p1)),p1(p1),p2(p2) {}\n};\n\nbool intersectCSP(const CS &cs, const P &p) {\n  return angle(cs.p1, p-cs.p) < angle(cs.p1, cs.p2)+EPS &&\n    abs(cs.p-p) <= cs.r+EPS;\n}\n\nstruct Tree {\n  P p;\n  double d;\n  Tree(const P &p, double d) : p(p), d(d) {}\n  CS getCS(double w, double a) {\n    return CS(p, pol(a, w - d/2), pol(a, w + d/2));\n  }\n};\n\nint main() {\n  int H, R;\n  while(input(H,R), H || R) {\n    vector<P> home(H);\n    REP(i,H) cin >> home[i];\n    int U,M,S;\n    input(U,M,S);\n    double du,dm,ds;\n    cin>>du>>dm>>ds;\n    du = du / 180 * PI;\n    dm = dm / 180 * PI;\n    ds = ds / 180 * PI;\n    vector<Tree> tree;\n    REP(i,U) {\n      P p; cin >> p;\n      tree.push_back(Tree(p,du));\n    }\n    REP(i,M) {\n      P p; cin >> p;\n      tree.push_back(Tree(p,dm));\n    }\n    REP(i,S) {\n      P p; cin >> p;\n      tree.push_back(Tree(p,ds));\n    }\n    vector<int> numday(H);\n\n    Tree mine(P(), du);\n    REP(i,R) {\n      double w,a;\n      cin >> w >> a;\n      w = w / 180 * PI;\n      CS mycs = mine.getCS(w,a);\n      REP(i,home.size()) {\n        const P& h = home[i];\n        bool ok = intersectCSP(mycs, h);\n        if (!ok) continue;\n        for (auto &t : tree) {\n          CS cs = t.getCS(w,a);\n          ok &= !intersectCSP(cs, h);\n        }\n        if (ok)\n          numday[i]++;\n      }\n    }\n    int mx = *max_element(ALL(numday));\n    if (mx == 0) puts(\"NA\");\n    else {\n      bool f = 0;\n      REP(i,H) {\n        if (numday[i] == mx) {\n          if (f) printf(\" \");\n          printf(\"%d\", i+1);\n          f = 1;\n        }\n      }\n      cout << endl;\n    }\n  }\n}"
  },
  {
    "language": "C++",
    "code": "#include<bits/stdc++.h>\n#define N 105\n#define x real()\n#define y imag()\nusing namespace std;\ntypedef complex<double> point;\nint H,R,U,M,S,ans[N];\ndouble du,dm,ds,w,a;\npoint h[N],u[N],m[N],s[N];\n\nint ccw(point p0,point p1,point p2){\n  point temp;\n  p1-=p0;\n  p2-=p0;\n  temp=p1;\n  p1*=conj(temp);\n  p2*=conj(temp);\n  if(abs(temp)==0) return 0;\n  p1/=abs(temp);\n  if(p2.imag()>0) return 1;\n  if(p2.imag()<0) return -1;\n  p2/=abs(temp);\n  if(p2.real()<0) return -2;\n  if(p1.real()<p2.real()) return -2;\n  return 0;\n}\n\nbool check2(double d,point A,point B){\n  point p1=point(a,0),p2=point(a,0),pw=point(cos(w*M_PI/180),sin(w*M_PI/180));\n  point e1=point(cos(d*M_PI/360),sin(d*M_PI/360));\n  point e2=point(cos(d*M_PI/360),-sin(d*M_PI/360));\n  p1=B+p1*pw*e1;\n  p2=B+p2*pw*e2;\n  if(abs(A-B)>a)return true;\n  int r1=ccw(B,p1,A),r2=ccw(B,p2,A);\n  if((r1==0||r1==-1)&&(r2==0||r2==1))return false;\n  return true;\n}\n\nvoid check(){\n  for(int i=0;i<H;i++){\n    if(check2(du,h[i],point(0,0)))continue;\n    bool f=true;\n    for(int j=0;j<U;j++)f&=check2(du,h[i],u[j]);\n    for(int j=0;j<M;j++)f&=check2(dm,h[i],m[j]);\n    for(int j=0;j<S;j++)f&=check2(ds,h[i],s[j]);\n    if(f)ans[i]++;\n  }\n}\n\nint main(){\n  while(1){\n    cin>>H>>R;\n    if(!H&&!R)break;\n    memset(ans,0,sizeof(ans));\n    for(int i=0;i<H;i++)cin>>h[i].x>>h[i].y;\n    cin>>U>>M>>S>>du>>dm>>ds;\n    for(int i=0;i<U;i++)cin>>u[i].x>>u[i].y;\n    for(int i=0;i<M;i++)cin>>m[i].x>>m[i].y;\n    for(int i=0;i<S;i++)cin>>s[i].x>>s[i].y;\n    for(int i=0;i<R;i++)cin>>w>>a,check();\n    int maxans=0;\n    for(int i=0;i<H;i++)maxans=max(maxans,ans[i]);\n    if(!maxans)cout<<\"NA\"<<endl;\n    else{\n      int f=0;\n      for(int i=0;i<H;i++)\n\tif(maxans==ans[i]){\n\t  if(f)cout<<' ';\n\t  cout<<i+1;\n\t  f=1;\n\t}\n      cout<<endl;\n    }\n  }\n  return 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include<iostream>\n#include<complex>\n#include<vector>\n#include<algorithm>\n#include<cmath>\n#include<cstring>\n\n#define pb push_back\n#define sz size()\n#define rep(i,a) for(int i=0;i<(int)(a);i++)\n\nusing namespace std;\ntypedef long double D;\ntypedef complex<D> P;\nconst D EPS = 1e-8;\nconst D PI = acos(-1);\n\nD dot(P x,P y){return real(conj(x)*y);}\nD cross(P x,P y){return imag(conj(x)*y);}\nD arg(P a,P b,P c){\n  D res = acos(dot(b-a,c-a)/(abs(b-a)*abs(c-a))); \n  return (cross(b-a,c-a)<EPS)?2*PI-res:res;\n}\n\nint h,r,n[3];\nD d[3],tmp1,tmp2,seta;\nP hp[110],up[3][110];\nD w[110],a[110];\n\nint main(){\n  while(cin >> h >> r,h){\n    rep(i,h){\n      cin >> tmp1 >> tmp2;\n      hp[i] = P(tmp1,tmp2);\n    }\n\n    rep(i,3)cin >> n[i]; rep(i,3)cin >> d[i], d[i] *= PI/180/2;\n\n    rep(i,3)rep(j,n[i]){\n      cin >> tmp1 >> tmp2;\n      up[i][j] = P(tmp1,tmp2);\n    }\n\n    rep(i,r)cin >> w[i] >> a[i], w[i] *= PI/180;\n\n    int num[110];\n    memset(num,0,sizeof(num));\n\n    rep(x,r)rep(id,h){\n      seta = arg(P(0,0),P(100,0),hp[id]);\n      if( !(abs(hp[id]) < a[x] + EPS) )continue;\n      if( !(w[x]-d[0] < seta+EPS && seta < w[x]+d[0]+EPS)\n\t  && !(w[x]-d[0]+2*PI < seta+EPS && seta < w[x]+d[0]+2*PI+EPS) )continue;\n\n      bool in = 0;\n      rep(i,3){\n\trep(j,n[i]){\n\t  if(abs(hp[id]-up[i][j]) < a[x] +EPS){\n\t    P tmp = P(up[i][j].real() + 100.0, up[i][j].imag());\n\t    seta = arg(up[i][j],tmp,hp[id]);\n\t    if(w[x]-d[i] < seta+EPS && seta < w[x]+d[i]+EPS){\n\t      in = 1; break;\n\t    }else if(w[x]-d[i]+2*PI < seta+EPS && seta < w[x]+d[i]+2*PI+EPS){\n\t      in = 1; break;\n\t    }\n\t  }\n\t}\n\tif(in)break;\n      }\n      if(!in)num[id]++;\n    }\n\n    int maxv = *max_element(num,num+h);\n    vector<int> ans;\n    if(maxv==0)cout << \"NA\\n\";\n    else{\n      rep(i,h){\n\tif(num[i] == maxv)ans.pb(i+1);\n      }\n      rep(i,ans.sz)cout << ans[i] << (i+1==ans.size()?\"\\n\":\" \");\n    }\n  }\n}"
  },
  {
    "language": "C++",
    "code": "\n//自分の梅は任意の地点でかおるとする。→間違い。\n//EPSはつけない。\n//扇形と家は接しないので、距離はsqrtで求めた。\n\n#include<iostream>\n#include<cmath>\n#include<vector>\n#define rep(i,n) for(i = 0;i < n;i++)\n#define PI 3.14159265358979\nusing namespace std;\n\ntypedef pair<double,double> P;\n\nint H,R;\t\t\t\t//家数,日数\nint hx[100],hy[100];\t//家の座標\nint U,M,S;\t\t\t\t//梅、桃、桜の数\nint du,dm,ds;\t\t\t//梅、桃、桜の扇形の中心角\nint ux[100],uy[100];\t//梅の座標\nint mx[100],my[100];\t//桃の座標\nint sx[100],sy[100];\t//桜の座標\nint w[100],a[100];\t\t//扇形の方向(角度),風の強さ\n\n//半径,角度の順で格納し、返す\n//rotateは角度補正( 補正 = rotate*360 )\nP POLAR( int treex,int treey,int housex,int housey,int rotate )\n{\n\tP ans;\n\tans.first = (housex-treex)*(housex-treex) + (housey-treey)*(housey-treey);\n\tans.first = sqrt( ans.first );\n\tans.second = atan2( (double)housey - treey, (double)housex - treex ) * 180 / PI;\n\tans.second += 360*rotate;\n\treturn ans;\n}\n\nint main()\n{\n\tint i,j,k,l;\n\twhile( cin >> H >> R )\n\t{\n\t\tint day[100] = {0};\t\t//i番目の家において、他の木の香りが届かなかった日数\n\n\t\tif( H == 0 && R == 0 )\n\t\t\tbreak;\n\t\trep(i,H)\n\t\t\tcin >> hx[i] >> hy[i];\n\t\tcin >> U >> M >> S >> du >> dm >> ds;\n\t\trep(i,U)\n\t\t\tcin >> ux[i] >> uy[i];\n\t\trep(i,M)\n\t\t\tcin >> mx[i] >> my[i];\n\t\trep(i,S)\n\t\t\tcin >> sx[i] >> sy[i];\n\t\trep(i,R)\n\t\t\tcin >> w[i] >> a[i];\n\t\t//ここから探索\n\t\trep(i,R){\n\t\t\trep(j,H){\n\t\t\t\trep(k,U){\n\t\t\t\t\trep(l,3){\n\t\t\t\t\t\tP t = POLAR( ux[k],uy[k],hx[j],hy[j],l-1 );\n\t\t\t\t\t\t//判定\n\t\t\t\t\t\tif( t.first <= a[i] && fabs( (double)w[i] - t.second ) <= du/2.0 )\n\t\t\t\t\t\t\tbreak;\n\t\t\t\t\t}\n\t\t\t\t\tif(l < 3)\n\t\t\t\t\t\tbreak;\n\t\t\t\t}\n\t\t\t\tif(k < U)\n\t\t\t\t\tcontinue;\n\t\t\t\trep(k,M){\n\t\t\t\t\trep(l,3){\n\t\t\t\t\t\tP t = POLAR( mx[k],my[k],hx[j],hy[j],l-1 );\n\t\t\t\t\t\t//判定\n\t\t\t\t\t\tif( t.first <= a[i] && fabs( (double)w[i] - t.second ) <= dm/2.0 )\n\t\t\t\t\t\t\tbreak;\n\t\t\t\t\t}\n\t\t\t\t\tif(l < 3)\n\t\t\t\t\t\tbreak;\n\t\t\t\t}\n\t\t\t\tif(k < M)\n\t\t\t\t\tcontinue;\n\t\t\t\trep(k,S){\n\t\t\t\t\trep(l,3){\n\t\t\t\t\t\tP t = POLAR( sx[k],sy[k],hx[j],hy[j],l-1 );\n\t\t\t\t\t\t//判定\n\t\t\t\t\t\tif( t.first <= a[i] && fabs( (double)w[i] - t.second ) <= ds/2.0 )\n\t\t\t\t\t\t\tbreak;\n\t\t\t\t\t}\n\t\t\t\t\tif(l < 3)\n\t\t\t\t\t\tbreak;\n\t\t\t\t}\n\t\t\t\tif(k < S)\n\t\t\t\t\tcontinue;\n\n\t\t\t\t//私の梅の香りは届くのか！！\n\t\t\t\trep(l,3){\n\t\t\t\t\tP t = POLAR( 0,0,hx[j],hy[j],l-1 );\n\t\t\t\t\t//判定\n\t\t\t\t\tif( t.first <= a[i] && fabs( (double)w[i] - t.second ) <= du/2.0 )\n\t\t\t\t\t\tbreak;\n\t\t\t\t}\n\t\t\t\tif( l < 3 )\n\t\t\t\t\tday[j]++;\n\t\t\t}\n\t\t}\n\t\tint maxday = 0;\n\t\trep(i,H){\n\t\t\tmaxday = max( maxday,day[i] );\n\t\t}\n\t\tif( maxday == 0 ){\n\t\t\tcout << \"NA\" << endl;\n\t\t\tcontinue;\n\t\t}\n\t\trep(i,H){\n\t\t\tif( day[i] == maxday ){\n\t\t\t\tcout << i+1;\n\t\t\t\tif( i < H-1 )\n\t\t\t\t\tcout << ' ';\n\t\t\t\telse\n\t\t\t\t\tcout << endl;\n\t\t\t}\n\t\t}\n\t}\n\treturn 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include<iostream>\n#include<vector>\n#include<math.h>\n\n#define PI 3.141592\n\nusing namespace std;\n\n\n\nstruct tree{\n\ttree(){}\n\ttree(int a,int b,int c){\n\t\tx=a,y=b,sp=c;\n\t}\n\tint x;\n\tint y;\n\tint sp;\n};\nstruct pos{\n\tpos(){}\n\tpos(int a,int b){\n\t\tx=a,y=b;\n\t}\n\tint x;\n\tint y;\n};\n\nint D[3];\nvector<tree> tr;\npos ho[150];\nint data[150];\n\ndouble cro(pos p1,pos p2){\n\treturn p1.x*p2.y-p1.y*p2.x;\n}\nbool che(pos p,tree t,int w ,int a){\n\tint d=D[t.sp];\n\tpos p1=pos(p.x-t.x,p.y-t.y);\n\tpos v1=pos(a*cos((w+d/2.0)*PI/180.0),a*sin((w+d/2.0)*PI/180.0));\n\tpos v2=pos(a*cos((w-d/2.0)*PI/180.0),a*sin((w-d/2.0)*PI/180.0));\n\t\n\tif(pow(p1.x,2.0)+pow(p1.y,2.0)>pow(a,2.0))return false;\n\tif(cro(v1,p1)*cro(v2,p1)<=0)return true;\n\telse return false;\n}\n\nint main(){\n\tint h,r;\n\twhile(cin>>h>>r && h &&r){\n\t\tfor(int i=0;i<150;i++)data[i]=0;\n\t\ttr.clear();\n\t\ttr.push_back(tree(0,0,0));\n\t\t\n\t\tfor(int i=0;i<h;i++){\n\t\t\tpos tmp;\n\t\t\tcin>>tmp.x>>tmp.y;\n\t\t\tho[i]=tmp;\n\t\t}\n\t\tint U,M,S;\n\t\tcin>>U>>M>>S>>D[0]>>D[1]>>D[2];\n\t\t\n\t\tfor(int i=0;i<U;i++){\n\t\t\ttree tmp;\n\t\t\tcin>>tmp.x>>tmp.y;\n\t\t\ttmp.sp=0;\n\t\t\ttr.push_back(tmp);\n\t\t}\n\t\tfor(int i=0;i<M;i++){\n\t\t\ttree tmp;\n\t\t\tcin>>tmp.x>>tmp.y;\n\t\t\ttmp.sp=1;\n\t\t\ttr.push_back(tmp);\n\t\t}\n\t\tfor(int i=0;i<S;i++){\n\t\t\ttree tmp;\n\t\t\tcin>>tmp.x>>tmp.y;\n\t\t\ttmp.sp=2;\n\t\t\ttr.push_back(tmp);\n\t\t}\n\t\t\n\t\tfor(int i=0;i<r;i++){\n\t\t\tint w,a;\n\t\t\tcin>>w>>a;\n\t\t\t\n\t\t\tfor(int j=0;j<h;j++){\n\t\t\t\t\tif(!che(ho[j],tr[0],w,a))break;\n\t\t\t\tfor(int k=1;k<tr.size();k++){\n\t\t\t\t\tif(che(ho[j],tr[k],w,a))goto fail;\n\t\t\t\t}\n\t\t\t\tdata[j]++;\n\t\t\t\tfail:;\n\t\t\t}\n\t\t}\n\t\tint ma=0;\n\t\tfor(int i=0;i<h;i++){\n\t\t\tif(ma<data[i])ma=data[i];\n\t\t}\n\t\tif(ma==0){\n\t\t\tcout<<\"NA\"<<endl;\n\t\t\tcontinue;\n\t\t}\n\t\telse {\n\t\t\tfor(int i=0;i<h;i++){\n\t\t\t\tif(data[i]==ma)cout<<i+1<<\" \";\n\t\t\t}\n\t\t\tcout<<endl;\n\t\t}\n\t\t\n\t\tfor(int i=0;i<h;i++)cout<<data[i]<<\" \";\n\t\tcout<<endl;\n\t}\n}"
  },
  {
    "language": "C++",
    "code": "#include<iostream>\n#include<vector>\n#include<cmath>\n#include<algorithm>\n#include<numeric>\nusing namespace std;\n\nconst double PI = 3.14159265358979;\nconst double EPS = 0.0;\n\nclass Point {\npublic:\n    double x, y;\n    Point(double x = 0.0, double y = 0.0) :x(x), y(y) {}\n};\n\nclass Wind {\npublic:\n    double w, a;\n};\n\nbool savor(const Point &home, const Wind &wind, const vector<Point> &blossom, double d) {\n//     cout << \"home: \" << home.x << \", \" << home.y << endl;\n//     cout << \"blossom\" << endl; for(const auto &i: blossom) cout << \"  \" << i.x << \",\" << i.y; cout << endl;\n//     cout << \"d: \" << d << endl;\n//     cout << \"wind: \" << wind.w << \", \" << wind.a << endl;\n//     cout << endl;\n    d /= 2.0;\n    for(const auto &b: blossom) {\n        Point dif(home.x - b.x, home.y - b.y);\n        double angle = atan2(dif.y, dif.x);\n        double dist = hypot(dif.y, dif.x);\n        if(angle < 0) angle = 2 * PI - angle;\n//         cout<<\"angle: \"<<angle<<endl;\n//         cout<<\"wind.w +- d: \"<<wind.w - d<<\" - \"<<wind.w + d<<endl;\n//         cout<<\"dist: \"<<dist<<endl;\n        if(wind.w - d <= angle + EPS && angle <= wind.w + d + EPS && dist <= wind.a + EPS) return true;\n    }\n    return false;\n}\n\ndouble toRadian(double d) {\n    return d * PI / 180.0;\n}\n\nint main() {\n    int H, R;\n    while(cin >> H >> R, H | R) {\n        vector<Point> home(H);\n        for(auto &i: home) cin >> i.x >> i.y;\n\n        int U, M, S;\n        double du, dm, ds;\n        cin >> U >> M >> S >> du >> dm >> ds;\n\n        du = toRadian(du);\n        dm = toRadian(dm);\n        ds = toRadian(ds);\n\n        vector<Point> plum(U), peach(M), cherry(S);\n        for(auto &i: plum) cin >> i.x >> i.y;\n        for(auto &i: peach) cin >> i.x >> i.y;\n        for(auto &i: cherry) cin >> i.x >> i.y;\n\n        vector<Wind> wind(R);\n        for(auto &i: wind) cin >> i.w >> i.a;\n        for(auto &i: wind) i.w = toRadian(i.w);\n\n        // test\n//         cout << savor(home[5], wind[0], peach, dm) << endl;\n//         return 0;\n\n        // solve\n        vector<int> number(H, 0);\n        int maxNumber = 0;\n\n        for(int i = 0; i < H; ++i) {\n            for(int day = 0; day < R; ++day) {\n                bool ok = savor(home[i], wind[day], {Point(0.0, 0.0)}, du);\n                bool ng = false;\n                ng |= savor(home[i], wind[day], plum, du);\n                ng |= savor(home[i], wind[day], peach, dm);\n                ng |= savor(home[i], wind[day], cherry, ds);\n\n//                 cout<<\"day\"<<day<<endl;\n//                 cout<<savor(home[i], wind[day], plum, du)<<\" \"<<savor(home[i], wind[day], peach, du)<<\" \"<<savor(home[i], wind[day], cherry, du)<<endl;\n\n                if(!ok || ng) continue;\n\n                ++number[i];\n                maxNumber = max(maxNumber, number[i]);\n            }\n        }\n\n//         for(const auto &i: number) cout<<\" \"<<i;cout<<endl;\n\n        if(maxNumber) {\n            bool first = true;\n            for(int i = 0; i < H; ++i) if(number[i] == maxNumber) {\n                if(!first) cout << \" \";\n                first = false;\n                cout << i + 1;\n            }\n            cout << endl;\n        } else {\n            cout << \"NA\" << endl;\n        }\n\n//         return 0;\n    }\n}"
  },
  {
    "language": "C++",
    "code": "#include <iostream>\n#include <cstdio>\n#include <cmath>\n#include <vector>\n#include <map>\n#include <stack>\n#include <queue>\n#include <algorithm>\n#include <set>\n#include <cstring>\n\n#define FOR(i,a,b) for(int i=(a);i<(b);i++)\n#define REP(i,j) FOR(i,0,j)\n#define mp std::make_pair\n\ntypedef long long ll;\ntypedef unsigned long long ull;\n\nconst int INF = 1001001001;\nconst double EPS = 1e-8;\n\n// S N E W(南北東西)\nconst int dx[8] = {0, 0, 1, -1, 1, 1, -1, -1}, dy[8] = {1, -1, 0, 0, 1, -1, 1, -1};\n\nstruct P{\n    P(){}\n    P(double _r, double _i):r(_r), i(_i){}\n    void real(const double& v){r = v;}\n    void imag(const double& v){i = v;}\n    double r, i;\n};\n\ndouble real(const P& p){return p.r;}\ndouble imag(const P& p){return p.i;}\ndouble norm(const P& p){double r = real(p), i = imag(p); return r * r + i * i;}\ndouble dist(const P& p){return std::sqrt(norm(p));}\n\nP operator+(const P& lhs, const P& rhs){\n    return P(real(lhs)+real(rhs), imag(lhs)+imag(rhs));\n}\nP operator-(const P& lhs, const P& rhs){\n    return P(real(lhs)-real(rhs), imag(lhs)-imag(rhs));\n}\nP operator-(const P& p){\n    return P(-real(p), -imag(p));\n}\n\ndouble cross(const P& lhs, const P& rhs){\n    return real(lhs)*imag(rhs) - imag(lhs)*real(rhs);\n}\n\ndouble dot(const P& lhs, const P& rhs){\n    return real(lhs)*real(rhs) + imag(lhs)*imag(rhs);\n}\n\nint H, R, U, M, S;\ndouble du, dm, ds;\nP hs[100], us[10], ms[10], ss[10];\n\nbool can(P home, P flower, double d, P wind){\n    if(dist(home-flower) > imag(wind)){return false;}\n    P center;\n    center.real(imag(wind) * std::cos(M_PI / 180.0f * real(wind)));\n    center.imag(imag(wind) * std::sin(M_PI / 180.0f * real(wind)));\n    // {\n    //     P p = home-flower;\n    //     printf(\"%f, %f\\n\", real(center), imag(center));\n    // }\n    double s = cross(center, home-flower) / dist(center) / dist(home-flower),\n        c = dot(center, home-flower) / dist(center) / dist(home-flower);\n    // printf(\"%f, %f\\n\", c, s);\n    if((c < 0.0f && d > 90.0f || c > 0.0f) && std::abs(s) < std::sin(M_PI / 360.0f * d) + EPS){\n        return true;\n    }\n    return false;\n}\n\nint main(){\n    while(std::cin >> H >> R, H || R){\n        REP(i, H){\n            double x, y;\n            std::cin >> x >> y;\n\n            hs[i].real(x); hs[i].imag(y);\n        }\n\n        std::cin >> U >> M >> S >> du >> dm >> ds;\n        REP(i, U){\n            double x, y;\n            std::cin >> x >> y;\n\n            us[i].real(x); us[i].imag(y);\n        }\n        REP(i, M){\n            double x, y;\n            std::cin >> x >> y;\n\n            ms[i].real(x); ms[i].imag(y);\n        }\n        REP(i, S){\n            double x, y;\n            std::cin >> x >> y;\n\n            ss[i].real(x); ss[i].imag(y);\n        }\n\n        P origin(0.0f, 0.0f);\n        int counter[100];\n        memset(counter, 0, sizeof(counter));\n        REP(i, R){\n            double x, y;\n            std::cin >> x >> y;\n            P wind(x, y);\n\n            REP(k, H){\n                bool f = can(hs[k], origin, du, wind),\n                    g = true;\n\n                REP(j, U){\n                    g = g && !can(hs[k], us[j], du, wind);\n                }\n                REP(j, M){\n                    g = g && !can(hs[k], ms[j], dm, wind);\n                }\n                REP(j, S){\n                    g = g && !can(hs[k], ss[j], ds, wind);\n                }\n\n                if(f && g){counter[k] += 1;}\n            }\n        }\n\n        int maxDays = 0;\n        REP(i, H){\n            maxDays = std::max(maxDays, counter[i]);\n        }\n\n        if(maxDays == 0){\n            puts(\"NA\");\n        }else{\n            std::vector<int> indices;\n            REP(i, H){\n                if(counter[i] == maxDays){indices.push_back(i+1);}\n            }\n\n            REP(i, (int)indices.size()){\n                if(i == (int)indices.size() - 1){printf(\"%d\\n\", indices[i]);}\n                else{printf(\"%d \", indices[i]);}\n            }\n        }\n    }\n}"
  },
  {
    "language": "C++",
    "code": "#include <iostream>\n#include <sstream>\n#include <string>\n#include <algorithm>\n#include <vector>\n#include <stack>\n#include <queue>\n#include <set>\n#include <map>\n#include <cstdio>\n#include <cstdlib>\n#include <cstring>\n#include <cmath>\n#include <cassert>\n\nusing namespace std;\n\n#define FOR(i,k,n) for(int i=(k); i<(int)(n); ++i)\n#define REP(i,n) FOR(i,0,n)\n#define FORIT(i,c) for(__typeof((c).begin())i=(c).begin();i!=(c).end();++i)\n\ntemplate<class T> void debug(T begin, T end){ for(T i = begin; i != end; ++i) cerr<<*i<<\" \"; cerr<<endl; }\ninline bool valid(int x, int y, int W, int H){ return (x >= 0 && y >= 0 && x < W && y < H); }\n\ntypedef long long ll;\nconst int INF = 100000000;\nconst double EPS = 1e-8;\nconst int MOD = 1000000007;\nint dx[8] = {1, 0, -1, 0, 1, -1, -1, 1};\nint dy[8] = {0, 1, 0, -1, 1, 1, -1, -1};\nint sign(double r){ return (r < -EPS) ? -1 : (r > EPS) ? 1 : 0; }\nbool eq(double a, double b){ return abs(b - a) < EPS; }\n\nstruct Point{\n  double x, y;\n  Point() {}\n  Point(double x, double y) : x(x), y(y) {}\n  Point operator+(const Point& b) const { return Point(x + b.x, y + b.y); }\n  Point operator-(const Point& b) const { return Point(x - b.x, y - b.y); }\n  Point operator*(const double b) const { return Point(x * b, y * b); }\n  Point operator*(const Point& b) const { return Point(x * b.x - y * b.y, x * b.y + y * b.x); }\n  Point operator/(const double b) const { return Point(x / b, y / b); }\n  bool operator< (const Point& b) const { return x != b.x ? x < b.x : y < b.y; }\n  bool operator==(const Point& b) const { return eq(x, b.x) && eq(y, b.y); }\n  double norm(){ return x * x + y * y; }\n  double arg(){ return atan2(x, y); }\n  double abs(){ return sqrt(norm()); }\n  Point rotate(double theta){ return Point(cos(theta) * x - sin(theta) * y, sin(theta) * x + cos(theta) * y); }\n  Point rotate90(){ return Point(-y, x); }\n};\n\nostream& operator<<(ostream& os, Point& p){ return os<<\"(\"<<p.x<<\",\"<<p.y<<\")\"; }\nistream& operator>>(istream& is, Point& a){ return is>>a.x>>a.y; }\ndouble dot(const Point& a, const Point& b){ return a.x * b.x + a.y * b.y; }\ndouble cross(const Point& a, const Point& b){ return a.x * b.y - a.y * b.x; }\nPoint polor(double rho, double theta){ return Point(rho * cos(theta), rho * sin(theta)); }\n\nstruct Line : public vector<Point> {\n  Line(const Point& a, const Point& b) {\n    push_back(a); push_back(b);\n  }\n  Point vector() const {\n    return back() - front();\n  }\n};\nstruct Circle : Point {\n  double r;\n  Circle(Point p, double r) : Point(p), r(r) { }\n};\ntypedef vector<Point> Polygon;\nPoint curr(const Polygon& a, int x){ return a[x]; }\nPoint next(const Polygon& a, int x){ return a[(x + 1) % a.size()]; }\nPoint prev(const Polygon& a, int x){ return a[(x - 1 + a.size()) % a.size()]; }\n\n//a->b->c\nint ccw(Point a, Point b, Point c) {\n  b = b - a; c = c - a;\n  if (cross(b, c) > EPS)   return +1; // 反時計回り\n  if (cross(b, c) < -EPS)   return -1; // 時計回り\n  if (dot(b, c) < 0)     return +2; // c--a--b の順番で一直線上\n  if (b.norm() < c.norm()) return -2; // a--b--c の順番で一直線上\n  return 0;                         // a--c--b の順番で一直線上 (aがbまたはcと重なる場合を含む)\n}\n// 二直線の交差判定\nbool intersectLL(const Line& l, const Line& m) {\n  // 直線lと直線mが平行でない\n  return abs(cross(l.vector(), m.vector())) > EPS;\n}\n// 二直線の同一判定\nbool equalLL(const Line& l, const Line& m){\n  // 直線lとl[0]からm[0]への直線が並行\n  return abs(cross(l.vector(), m[0] - l[0])) < EPS;\n}\n// 直線と線分の交差判定(注意: 同一直線上にある場合も含む)\nbool intersectLS(const Line& l, const Line& s) {\n  // 直線lについて、線分sの端点が異なる側にある\n  return cross(l.vector(), s[0] - l[0]) * cross(l.vector(), s[1] - l[0]) < EPS; \n}\n// 直線と点の交差判定\nbool intersectLP(const Line& l, const Point& p) {\n  // 直線lとl[0]からpへの直線が平行\n  return abs(cross(l.vector(), p - l[0])) < EPS;\n}\n// 二つの線分の交差判定\nbool intersectSS(const Line& s, const Line& t) {\n  return ccw(s[0], s[1], t[0]) * ccw(s[0], s[1], t[1]) <= 0 &&\n         ccw(t[0], t[1], s[0]) * ccw(t[0], t[1], s[1]) <= 0;\n}\n// 線分と点の交差判定(端点を含む)\nbool intersectSP(const Line& s, const Point& p) {\n  return ccw(s[0], s[1], p) == 0;\n}\n// 円と点の交差判定(EPS注意)\nbool intersectCP(const Circle& c, const Point& p){\n  // 円の中心と点の距離が、円の半径以下である\n  return (c - p).abs() < c.r + EPS;\n}\n// 二つの円の交差判定(EPS注意)\nbool intersectCC(const Circle& c, const Circle& d){\n  // 円の中心同士の距離が、半径の和以下であり、半径の差以上である\n  return (c - d).abs() < c.r + d.r + EPS && (c - d).abs() > abs(c.r - d.r) - EPS;\n}\n// 射影\nPoint projection(const Line& l, const Point& p){\n  double t = dot(p - l[0], l.vector()) / l.vector().norm();\n  return l[0] + l.vector() * t;\n}\n// 反射\nPoint reflection(const Line& l, const Point& p){\n  return p + (projection(l, p) - p) * 2;\n}\n// 直線と点の距離\ndouble distanceLP(const Line& l, const Point& p){\n  // pからlに下ろした垂線の長さ\n  return (p - projection(l, p)).abs();\n}\n// 二直線の距離\ndouble distanceLL(const Line& l, const Line& m){\n  // 平行でないときは0, 平行のときは垂線の長さ\n  return intersectLL(l, m) ? 0 : distanceLP(l, m[0]);\n}\n// 直線と線分の距離\ndouble distanceLS(const Line& l, const Line& s){\n  if(intersectLS(l, s)) return 0;\n  return min(distanceLP(l, s[0]), distanceLP(l, s[1]));\n}\n// 線分と点の距離\ndouble distanceSP(const Line& s, const Point& p){\n  const Point r = projection(s, p);\n  if(intersectSP(s, r)) return (r - p).abs(); // 垂線が線分に交わるとき\n  return min((s[0] - p).abs(), (s[1] - p).abs());\n}\n// 二つの線分の距離\ndouble distanceSS(const Line& s, const Line& t){\n  if(intersectSS(s, t)) return 0;\n  return min(min(distanceSP(s, t[0]), distanceSP(s, t[1])),\n             min(distanceSP(t, s[0]), distanceSP(t, s[1])));\n}\n// 二直線の交点\nPoint crosspointLL(const Line& l, const Line& m){\n  double d = cross(m.vector(), l.vector());\n  if(abs(d) < EPS) assert(false); // 直線が交わらない\n  return l[0] + l.vector() * cross(m.vector(), m[1] - l[0]) * (1.0 / d);\n}\n\n// 点が多角形のどこにあるのか判定する\nenum { OUT, ON, IN };\nint contains(const Polygon& P, const Point& p){\n  // 点pから半直線をひき、辺と交差する回数を数える\n  bool in = false;\n  REP(i, P.size()){\n    Point a = curr(P, i) - p;\n    Point b = next(P, i) - p;\n    if(a.y > b.y) swap(a, b);\n    // aからbの直線がy=0と交わり、その交点は原点の右側である\n    if(a.y <= 0 && 0 < b.y && cross(a, b) < 0){ \n      in = !in;\n    }\n    if(cross(a, b) == 0 && dot(a, b) <= 0) return ON;\n  }\n  return in ? IN : OUT;\n}\n\n// 多角形の面積\ndouble area(const Polygon& P) {\n  double A = 0;\n  REP(i, P.size()){\n    A += cross(curr(P, i), next(P, i));\n  }\n  return A / 2.0;\n}\nbool arrive(double w, double a, double d, const Point& wp, const Point& hp){\n  if((hp - wp).abs() > a - EPS) return false;\n  Line l1(wp, wp + Point(a, 0).rotate(w - d/2));\n  Line l2(wp, wp + Point(a, 0).rotate(w + d/2));\n  if(ccw(l1[0], l1[1], hp) == 1 && ccw(l2[0], l2[1], hp) == -1) return true;\n  if(ccw(l1[0], l1[1], hp) * ccw(l2[0], l2[1], hp) == 0) return true;\n  return false;\n}\n\nint main(){\n  int H, R;\n  while(cin >> H >> R && H){\n    vector<Point> hp(H);\n    REP(i, H) cin >> hp[i];\n    int U, M, S;\n    double du, dm, ds;\n    cin >> U >> M >> S;\n    cin >> du >> dm >> ds;\n    du = du / 180.0 * M_PI;\n    dm = dm / 180.0 * M_PI;\n    ds = ds / 180.0 * M_PI;\n    vector<Point> up(U), mp(M), sp(S);\n    REP(i, U) cin >> up[i];\n    REP(i, M) cin >> mp[i];\n    REP(i, S) cin >> sp[i];\n    vector<double> w(R);\n    vector<double> a(R);\n    REP(i, R){\n      cin >> w[i] >> a[i];\n      w[i] = w[i] / 180.0 * M_PI;\n    }\n    map<int, vector<int> > ans;\n    REP(i, H){\n      int cnt = 0;\n      REP(j, R)if(arrive(w[j], a[j], du, Point(0, 0), hp[i])){\n        bool ok = true;\n        REP(k, U) if(arrive(w[j], a[j], du, up[k], hp[i])) ok = false;\n        REP(k, M) if(arrive(w[j], a[j], dm, mp[k], hp[i])) ok = false;\n        REP(k, S) if(arrive(w[j], a[j], ds, sp[k], hp[i])) ok = false;\n        if(ok) cnt++;\n      }\n      ans[cnt].push_back(i);\n    }\n    if(ans.rbegin()->first == 0){\n      cout << \"NA\" << endl;\n    }else{\n      vector<int> v = ans.rbegin()->second;\n      REP(i, v.size()){\n        cout << v[i] + 1;\n        if(i == v.size() - 1) cout << endl;\n        else cout << \" \";\n      }\n    }\n  }\n  return 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\nusing namespace std;\n#define REP(i,n) for(int i=0;i<(int)(n);++i)\n#define REPR(i,n) for (int i=(int)(n)-1;i>=0;--i)\n#define FOR(i,c) for(__typeof((c).begin())i=(c).begin();i!=(c).end();++i)\n#define ALL(c) (c).begin(), (c).end()\n#define valid(y,x,h,w) (0<=y&&y<h&&0<=x&&x<w)\n#define tpl(...) make_tuple(__VA_ARGS__)\nconst int INF = 0x3f3f3f3f;\nconst double EPS = 1e-8;\nconst double PI = acos(-1);\nconst int dy[] = {-1,0,1,0};\nconst int dx[] = {0,1,0,-1};\ntypedef long long ll;\ntypedef pair<int,int> pii;\ntemplate<class T>bool chmax(T &a, const T &b) { if (a<b) { a=b; return 1; } return 0; }\ntemplate<class T>bool chmin(T &a, const T &b) { if (b<a) { a=b; return 1; } return 0; }\ntemplate<typename Ch,typename Tr,typename C,typename=decltype(begin(C()))>basic_ostream<Ch,Tr>& operator<<(basic_ostream<Ch,Tr>&os,\nconst C& c){os<<'[';for(auto i=begin(c);i!=end(c);++i)os<<(i==begin(c)?\"\":\" \")<<*i;return os<<']';}\ntemplate<class S,class T>ostream&operator<<(ostream &o,const pair<S,T>&t){return o<<'('<<t.first<<','<<t.second<<')';}\ntemplate<int N,class Tp>void output(ostream&,const Tp&){}\ntemplate<int N,class Tp,class,class ...Ts>void output(ostream &o,const Tp&t){if(N)o<<',';o<<get<N>(t);output<N+1,Tp,Ts...>(o,t);}\ntemplate<class ...Ts>ostream&operator<<(ostream&o,const tuple<Ts...>&t){o<<'(';output<0,tuple<Ts...>,Ts...>(o,t);return o<<')';}\ntemplate<class T>void output(T t,char z=10){if(t<0)t=-t,putchar(45);int c[20];\nint k=0;while(t)c[k++]=t%10,t/=10;for(k||(c[k++]=0);k;)putchar(c[--k]^48);putchar(z);}\ntemplate<class T>void outputs(T t){output(t);}\ntemplate<class S,class ...T>void outputs(S a,T...t){output(a,32);outputs(t...);}\ntemplate<class T>void output(T *a,int n){REP(i,n)cout<<a[i]<<(i!=n-1?',':'\\n');}\ntemplate<class T>void output(T *a,int n,int m){REP(i,n)output(a[i],m);}\ntemplate<class T>bool input(T &t){int n=1,c;for(t=0;!isdigit(c=getchar())&&~c&&c-45;);\nif(!~c)return 0;for(c-45&&(n=0,t=c^48);isdigit(c=getchar());)t=10*t+c-48;t=n?-t:t;return 1;}\ntemplate<class S,class ...T>bool input(S&a,T&...t){input(a);return input(t...);}\ntemplate<class T>bool inputs(T *a, int n) { REP(i,n) if(!input(a[i])) return 0; return 1;}\n\ntemplate<class T>\nstruct Pt {\n  T x,y;\n  Pt(T x=T(), T y=T()) :x(x),y(y) {}\n  void in() {ll _x, _y; input(_x,_y); x=_x; y=_y; }\n  bool operator<(const Pt &p) const { return x!=p.x?x<p.x:y<p.y; }\n  bool operator==(const Pt &p) const { return x==p.x&&y==p.y; }\n  Pt operator+=(const Pt &p) { x+=p.x, y+=p.y; return *this; }\n  Pt operator-=(const Pt &p) { x-=p.x, y-=p.y; return *this; }\n  Pt operator*=(const Pt &p) { T t=x;x=x*p.x-y*p.y,y=t*p.y+y*p.x; return *this;}\n  Pt operator*=(const T &v) { x*=v; y*=v; return *this;}\n  friend ostream& operator<<(ostream& os, const Pt &p) {return os<<'('<<p.x<<','<<p.y<<')';}\n  friend istream& operator>>(istream& is, Pt &p) {return is>>p.x>>p.y;}\n\n  Pt operator+(const Pt &p) const { return Pt(*this)+=p; }\n  Pt operator-(const Pt &p) const { return Pt(*this)-=p; }\n  Pt operator*(const Pt &p) const { return Pt(*this)*=p; }\n  Pt operator*(const T &v) const { return Pt(*this)*=v; }\n  friend Pt operator*(const T &v, const Pt &p) { return p*v; }\n  bool operator!=(const Pt &p) const { return !(*this == p); }\n\n  T abs() const { return hypot(x,y); }\n  T norm() const { return x*x+y*y; }\n  T arg() const { return atan2(y,x); }\n  T dot(const Pt &p) const { return x*p.x+y*p.y; }\n  T det(const Pt &p) const { return x*p.y-y*p.x; }\n  friend T abs(const Pt &p) { return p.abs(); }\n  friend T norm(const Pt &p) { return p.norm(); }\n  friend T arg(const Pt &p) { return p.arg(); }\n  friend T dot(const Pt &p, const Pt &q) { return p.dot(q); }\n  friend T det(const Pt &p, const Pt &q) { return p.det(q); }\n};\n\nint sig(double r) {return r<-EPS?-1:r>EPS?1:0;}\nint sig(ll r) {return r<0?-1:r>0?1:0;}\nbool eq(double a, double b) {return sig(a-b)==0;}\nbool eq(ll a, ll b) {return a==b;}\nPt<double> pol(double len, double ang) { return Pt<double>(cos(ang),sin(ang)) * len; }\n\ntypedef Pt<double> P;\n\ndouble angle(const P &a, const P &b) {\n  double ret = arg(b)-arg(a);\n  if (!sig(ret)||!sig(ret-2*PI)) return 0;\n  return ret>0 ? ret : ret + 2*PI;\n}\n\ntemplate<typename _T>\nstruct Ci {\n  typedef _T T;\n  Pt<T> p; T r;\n  Ci(const Pt<T> &p, T r) : p(p), r(r) { }\n};\ntypedef Ci<double> C;\n\n// 扇型\nstruct CS : C {\n  P p1, p2;\n  CS(const P &p, const P &p1, const P &p2):\n    C(p,abs(p1)),p1(p1),p2(p2) {}\n};\n\nbool intersectCSP(const CS &cs, const P &p) {\n  return angle(cs.p1, p-cs.p) < angle(cs.p1, cs.p2)+EPS &&\n    abs(cs.p-p) <= cs.r+EPS;\n}\n\nstruct Tree {\n  P p;\n  double d;\n  Tree(const P &p, double d) : p(p), d(d) {}\n  CS getCS(double w, double a) {\n    return CS(p, pol(a, w - d/2), pol(a, w + d/2));\n  }\n};\n\nint main() {\n  int H, R;\n  while(input(H,R), H || R) {\n    vector<P> home(H);\n    REP(i,H) cin >> home[i];\n    int U,M,S;\n    input(U,M,S);\n    double du,dm,ds;\n    cin>>du>>dm>>ds;\n    du = du / 180 * PI;\n    dm = dm / 180 * PI;\n    ds = ds / 180 * PI;\n    vector<Tree> tree;\n    REP(i,U) {\n      P p; cin >> p;\n      tree.push_back(Tree(p,du));\n    }\n    REP(i,M) {\n      P p; cin >> p;\n      tree.push_back(Tree(p,dm));\n    }\n    REP(i,S) {\n      P p; cin >> p;\n      tree.push_back(Tree(p,ds));\n    }\n    vector<int> numday(H);\n\n    Tree mine(P(), du);\n    REP(i,R) {\n      double w,a;\n      cin >> w >> a;\n      w = w / 180 * PI;\n      CS mycs = mine.getCS(w,a);\n      REP(i,home.size()) {\n        const P& h = home[i];\n        bool ok = intersectCSP(mycs, h);\n        if (!ok) continue;\n        for (auto &t : tree) {\n          CS cs = t.getCS(w,a);\n          ok &= !intersectCSP(cs, h);\n        }\n        if (ok)\n          numday[i]++;\n      }\n    }\n    int mx = *max_element(ALL(numday));\n    if (mx == 0) puts(\"NA\");\n    else {\n      bool f = 0;\n      REP(i,H) {\n        if (numday[i] == mx) {\n          if (f) cout << \" \";\n          cout << i+1;\n          f = 1;\n        }\n      }\n      cout << endl;\n    }\n  }\n}"
  },
  {
    "language": "C++",
    "code": "#include<iostream>\n#include<complex>\n#include<vector>\n#include<algorithm>\n#include<cmath>\n#include<cstring>\n\n#define pb push_back\n#define sz size()\n#define rep(i,a) for(int i=0;i<(int)(a);i++)\n\nusing namespace std;\ntypedef long double D;\ntypedef complex<D> P;\nconst D EPS = 1e-8;\nconst D PI = acos(-1);\n\nD dot(P x,P y){return real(conj(x)*y);}\nD cross(P x,P y){return imag(conj(x)*y);}\nD arg(P a,P b,P c){\n  D res = acos(dot(b-a,c-a)/(abs(b-a)*abs(c-a))); \n  return (cross(b-a,c-a)<EPS)?2*PI-res:res;\n}\n\nint h,r,n[3];\nD d[3],tmp1,tmp2,seta;\nP hp[110],up[3][110];\nD w[110],a[110];\n\nint main(){\n  while(cin >> h >> r,h){\n    rep(i,h){\n      cin >> tmp1 >> tmp2;\n      hp[i] = P(tmp1,tmp2);\n    }\n\n    rep(i,3)cin >> n[i]; rep(i,3)cin >> d[i], d[i] *= PI/180/2;\n\n    rep(i,3)rep(j,n[i]){\n      cin >> tmp1 >> tmp2;\n      up[i][j] = P(tmp1,tmp2);\n    }\n\n    rep(i,r)cin >> w[i] >> a[i], w[i] *= PI/180;\n\n    int num[110];\n    memset(num,0,sizeof(num));\n\n    rep(x,r)rep(id,h){\n      int in = 0;\n      rep(i,3)rep(j,n[i]){\n\tif(abs(hp[id]-up[i][j]) < a[x] +EPS){\n\t  P tmp = P(up[i][j].real() + 100.0, up[i][j].imag());\n\t  seta = arg(up[i][j],tmp,hp[id]);\n\t  if(w[x]-d[i] < seta+EPS && seta < w[x]+d[i]+EPS)in++;\n\t  else if(w[x]-d[i]+2*PI < seta+EPS && seta < w[x]+d[i]+2*PI+EPS)in++;\n\t}\n      }\n      if(in)continue;\n      \n      seta = arg(P(0,0),P(100,0),hp[id]);\n      if(abs(hp[id]) < a[x] + EPS){\n\tif(w[x]-d[0] < seta+EPS && seta < w[x]+d[0]+EPS)num[id]++;\n\telse if(w[x]-d[0]+2*PI < seta+EPS && seta < w[x]+d[0]+2*PI+EPS)num[id]++;\n      }\n    }\n\n    int maxv = *max_element(num,num+h);\n    vector<int> ans;\n    if(maxv==0)cout << \"NA\\n\";\n    else{\n      rep(i,h){\n\tif(num[i] == maxv)ans.pb(i+1);\n      }\n      rep(i,ans.sz)cout << ans[i] << (i+1==ans.size()?\"\\n\":\" \");\n    }\n  }\n}"
  },
  {
    "language": "C++",
    "code": "#include <iostream>\n#include <string>\n#include <vector>\n#include <algorithm>\n#include <cmath>\n#include <map>\n\n#define REP(i,k,n) for(int i=k;i<n;i++)\n#define rep(i,n) for(int i=0;i<n;i++)\n#define EPS 1e-8\n#define equals(a,b) fabs((a) - (b)) < EPS\n#define PI acos(-1)\n\nusing namespace std;\n\nstruct Point\n{\n    double x, y;\n\n    Point(double x=0, double y=0) : x(x), y(y) {}\n\n    Point operator+(const Point &o) const { return Point(x+o.x, y+o.y); }\n\n    Point operator-(const Point &o) const { return Point(x-o.x, y-o.y); }\n\n    Point operator*(const double m) const { return Point(x*m, y*m); }\n\n    Point operator/(const double d) const { return Point(x/d, y/d); }\n\n    Point operator<(const Point &o) const { return x != o.x ? x < o.x : y < o.y; }\n\n\tbool operator==(const Point &o) const { return fabs(x-o.x) < EPS && fabs(y-o.y) < EPS; }\n\n\tdouble cross(const Point &o) const { return x * o.y - y * o.x; }\n\n    double dot(const Point &o) const { return x * o.x + y * o.y; }\n\n    double atan() const { return atan2(y, x); }\n\n\tdouble deg() const { return atan() * 180.0 / (acos(-1) * 4.0); }\n\n    double norm() const { return sqrt(dot(*this)); }\n\n    double distance(const Point &o) const { return (o - (*this)).norm(); }\n\n    double area(const Point &a,const Point &b)\n    {\n\t    Point p = a - (*this), p2 = b - (*this); \n\t    return p.cross(p2);\n    }\n\n    double area_abs(const Point &a,const Point &b) const\n    {\n\t    Point p = a - (*this), p2 = b - (*this);\n\t    return fabs(p.cross(p2)) / 2.0;\n    }\t\n\n    //線分abが自身に含まれているのかどうか判断する\n    int between(const Point &a,const Point &b)\n\t{\n\t\tif(area(a,b) != 0) return 0;\n\n    \tif(a.x != b.x)\n\t    {\n\t\t    return ((a.x <= x) && (x <= b.x) || (a.x >= x) && (x >= b.x));\n\t    }\n\t    else\n\t    {\n\t    \treturn ((a.y <= y) && (y <= b.y) || (a.y >= y) && (y >= b.y));\n\t    }\n    }      \n\n\tdouble distance_seg(const Point& a,const Point& b)\n\t{\n    \tif((b-a).dot(*this-a) < EPS)\n    \t{\n\t    \treturn (*this-a).norm();\n\t    }\n\t    if((a-b).dot(*this-b) < EPS)\n    \t{\n\t    \treturn (*this-b).norm();\n    \t}\n\t    return abs((b-a).cross(*this-a)) / (b-a).norm();\n    }\n\n    bool hitPolygon(const Point& a,const Point& b,const Point& c)\n\t{\n    \tdouble t = (b-a).cross(*this-b);\n    \tdouble t2 = (c-b).cross(*this-c);\n    \tdouble t3 = (a-c).cross(*this-a);\n    \tif((t > 0 && t2 > 0 && t3 > 0) || ( t < 0 && t2 < 0 && t3 < 0))\n    \t{\n    \t\treturn true;\n    \t}\n\n\t    return false;\n    }\n};\n\nint ccw(Point a,Point b,Point c)\n{\n    b = b-a;\n    c = c-a;\n\n    if(b.cross(c) > 0.0) return +1;\t//conter clockwise\n    if(b.cross(c) < 0.0) return -1;\t//clockwise\n    if(b.dot(c) < 0.0) return +2;\t//a on Seg(b,c)\n    if(b.norm() < c.norm()) return -2;\t//b on Seg(a,c)\n    return 0;\t//c on Seg(a,b)\n}\n\nbool inPolygon(Point p,Point a,Point b,Point c)\n{\n\tif(ccw(a,b,p) == -1 && ccw(a,c,p) == +1) return true;\n\n\treturn false;\n}\n\ndouble to_rad(double deg)\n{\n\treturn deg*PI/180;\n}\n\nbool hit(Point s,Point v,double d,double w,double a)\n{\n\tif(s.distance(v) > a) return false;\n\n\tdouble x = a*cos(to_rad(w + d/2));\n\tdouble y = a*sin(to_rad(w + d/2));\n\tPoint p(x,y);\n\n\tx = a*cos(to_rad(w - d/2));\n\ty = a*sin(to_rad(w - d/2));\n\tPoint p2(x,y);\n\n\tif(inPolygon(v,s,s+p,s+p2)) return true;\n\treturn false;\n}\n\nint main()\n{\n\tint h,r;\n\twhile(cin >> h >> r)\n\t{\n\t\tif(h == 0 && r == 0) break;\n\n\t\tvector<Point> v;\n\t\trep(i,h)\n\t\t{\n\t\t\tdouble x,y;\n\t\t\tcin >> x >> y;\n\t\t\tv.push_back(Point(x,y));\n\t\t}\n\n\t\tint u,m,s;\n\t\tdouble du,dm,ds;\n\t\tcin >> u >> m >> s >> du >> dm >> ds;\n\n\t\tvector<Point> ume;\n\t\trep(i,u)\n\t\t{\n\t\t\tdouble x,y;\n\t\t\tcin >> x >> y;\n\t\t\tume.push_back(Point(x,y));\n\t\t}\n\t\t\n\t\tvector<Point> momo;\n\t\trep(i,m)\n\t\t{\n\t\t\tdouble x,y;\n\t\t\tcin >> x >> y;\n\t\t\tmomo.push_back(Point(x,y));\n\t\t}\n\n\t\tvector<Point> sakura;\n\t\trep(i,s)\n\t\t{\n\t\t\tdouble x,y;\n\t\t\tcin >> x >> y;\n\t\t\tsakura.push_back(Point(x,y));\n\t\t}\n\n\t\tPoint S(0,0);\n\t\tmap<int,int> ma;\n\t\trep(i,r)\n\t\t{\n\t\t\tint w,a;\n\t\t\tcin >> w >> a;\n\n\t\t\trep(j,h)\n\t\t\t{\n\t\t\t\tint cnt = 0;\n\t\t\t\tif(hit(S,v[j],du,w,a)) cnt++;\n\n\t\t\t\tbool only = true;\n\n\t\t\t\trep(k,u) if(hit(ume[k],v[j],du,w,a)) only = false;\n\t\t\t\trep(k,m) if(hit(momo[k],v[j],dm,w,a)) only = false;\n\t\t\t\trep(k,s) if(hit(sakura[k],v[j],ds,w,a)) only = false;\n\n\t\t\t\tif(cnt > 0 && only) ma[j]++;\n\t\t\t}\n\t\t}\n\n\t\tint cmax = 0;\n\n\t\tmap<int,int>::iterator ite;\n\t\tfor(ite = ma.begin();ite != ma.end();ite++)\n\t\t{\n\t\t\tcmax = max(cmax,ite->second);\n\t\t}\n\n\t\tif(cmax == 0) cout << \"NA\" << endl;\n\t\telse\n\t\t{\n\t\t\tvector<int> ans;\n\t\t\tfor(ite = ma.begin();ite != ma.end();ite++)\n\t\t\t{\n\t\t\t\tif(ite->second == cmax) ans.push_back(ite->first);\n\t\t\t}\n\n\t\t\tsort(ans.begin(),ans.end());\n\n\t\t\trep(i,ans.size())\n\t\t\t{\n\t\t\t\tcout << ans[i] + 1;\n\t\t\t\tif(i == ans.size()-1) cout << endl;\n\t\t\t\telse cout << \" \";\n\t\t\t}\n\t\t}\n\t}\n\n\treturn 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include<iostream>\n#include<complex>\n#include<vector>\n#include<algorithm>\n#include<cmath>\n#include<cstring>\n\n#define pb push_back\n#define sz size()\n#define rep(i,a) for(int i=0;i<(int)(a);i++)\n\nusing namespace std;\ntypedef long double D;\ntypedef complex<D> P;\nconst D EPS = 1e-5;\nconst D PI = acos(-1);\n\nD dot(P x,P y){return real(conj(x)*y);}\nD cross(P x,P y){return imag(conj(x)*y);}\nD arg(P a,P b,P c){\n  D res = acos(dot(b-a,c-a)/(abs(b-a)*abs(c-a))); \n  return (cross(b-a,c-a)<EPS)?2*PI-res:res;\n}\n\nint h,r,n[3];\nD d[3],tmp1,tmp2,seta;\nP hp[110],up[3][110];\nD w[110],a[110];\n\nint main(){\n  while(cin >> h >> r,h){\n    rep(i,h){\n      cin >> tmp1 >> tmp2;\n      hp[i] = P(tmp1,tmp2);\n    }\n\n    rep(i,3)cin >> n[i]; rep(i,3)cin >> d[i], d[i] *= PI/180/2;\n\n    rep(i,3)rep(j,n[i]){\n      cin >> tmp1 >> tmp2;\n      up[i][j] = P(tmp1,tmp2);\n    }\n\n    rep(i,r)cin >> w[i] >> a[i], w[i] *= PI/180;\n\n    int num[110];\n    memset(num,0,sizeof(num));\n\n    rep(x,r)rep(id,h){\n      int in = 0;\n      rep(i,3)rep(j,n[i]){\n\tif(abs(hp[id]-up[i][j]) < a[x] +EPS){\n\t  P tmp = P(up[i][j].real() + 100.0, up[i][j].imag());\n\t  seta = arg(up[i][j],tmp,hp[id]);\n\t  if(w[x]-d[i] < seta+EPS && seta < w[x]+d[i]+EPS)in++;\n\t  else if(w[x]-d[i]+2*PI < seta+EPS && seta < w[x]+d[i]+2*PI+EPS)in++;\n\t}\n      }\n      if(in)continue;\n      \n      seta = arg(P(0,0),P(100,0),hp[id]);\n      if(abs(hp[id]) < a[x] + EPS){\n\tif(w[x]-d[0] < seta+EPS && seta < w[x]+d[0]+EPS)num[id]++;\n\telse if(w[x]-d[0]+2*PI < seta+EPS && seta < w[x]+d[0]+2*PI+EPS)num[id]++;\n      }\n    }\n\n    int maxv = *max_element(num,num+h);\n    vector<int> ans;\n    if(maxv==0)cout << \"NA\\n\";\n    else{\n      rep(i,h){\n\tif(num[i] == maxv)ans.pb(i+1);\n      }\n      rep(i,ans.sz)cout << ans[i] << (i+1==ans.size()?\"\\n\":\" \");\n    }\n  }\n}"
  },
  {
    "language": "C++",
    "code": "#include <cstdio>\n#include <cmath>\n#include <cfloat>\n#include <cstring>\n#include <cassert>\n#include <vector>\n#include <algorithm>\nusing namespace std;\n\n/* double extention Library. */\n\nconst double EPS = 1e-8;\n\nbool eq(double a, double b)\n{\n\treturn (fabs(a - b) <= EPS);\n}\n\nbool lt(double a, double b)\n{\n\treturn (a - b < EPS);\n}\n\nbool leq(double a, double b)\n{\n\treturn (lt(a, b) || eq(a, b));\n}\n\nbool gt(double a, double b)\n{\n\treturn (a - b > -EPS);\n}\n\nbool geq(double a, double b)\n{\n\treturn (gt(a, b) || eq(a, b));\n}\n\n/* 2-D Geometry Library. */\n\nclass Point{\npublic:\n\tdouble x, y;\n\tPoint (double x = 0, double y = 0): x(x), y(y){}\n\tPoint operator + (Point p){\n\t\treturn (Point(x + p.x, y + p.y));\n\t}\n\tPoint operator - (Point p){\n\t\treturn (Point(x - p.x, y - p.y));\n\t}\n\tPoint operator * (double a){\n\t\treturn (Point(x * a, y * a));\n\t}\n\tdouble abs(){\n\t\treturn (sqrt(norm()));\n\t}\n\tdouble norm(){\n\t\treturn (x * x + y * y);\n\t}\n\tbool operator < (const Point &p) const {\n\t\treturn (x != p.x ? x < p.x : y < p.y);\n\t}\n\tbool operator == (const Point &p) const {\n\t\treturn (fabs(x - p.x) < EPS && fabs(y - p.y) < EPS);\n\t}\n\tbool operator != (const Point &p) const {\n\t\treturn (!(*this == p));\n\t}\n};\n\ntypedef Point Vector;\ntypedef vector<Point> Polygon;\n\ndouble norm(Vector a)\n{\n\treturn (a.x * a.x + a.y * a.y);\n}\n\ndouble abs(Vector a)\n{\n\treturn (sqrt(norm(a)));\n}\n\ndouble dot(Vector a, Vector b)\n{\n\treturn (a.x * b.x + a.y * b.y);\n}\n\ndouble cross(Vector a, Vector b)\n{\n\treturn (a.x * b.y - a.y * b.x);\n}\n\nstatic const int COUNTER_CLOCKWISE = 1;\nstatic const int CLOCKWISE = -1;\nstatic const int ONLINE_BACK = 2;\nstatic const int ONLINE_FRONT = -2;\nstatic const int ON_SEGMENT = 0;\n\nint ccw(Point p0, Point p1, Point p2){\n\tVector a = p1 - p0;\n\tVector b = p2 - p0;\n\tif (cross(a, b) > EPS)  return (COUNTER_CLOCKWISE);\n\tif (cross(a, b) < -EPS) return (CLOCKWISE);\n\tif (dot(a, b) < -EPS)   return (ONLINE_BACK);\n\tif (norm(a) < norm(b))  return (ONLINE_FRONT);\n\treturn (ON_SEGMENT);\n}\n\nbool isIntersect(Point p1, Point p2, Point p3, Point p4){\n\treturn (ccw(p1, p2, p3) * ccw(p1, p2, p4) <= 0 &&\n\t\t\t ccw(p3, p4, p1) * ccw(p3, p4, p2) <= 0 );\n}\n\n\n\nbool isInside(Polygon gon, Point p)\n{\n\tfor (int i = 0; i < gon.size(); i++){\n\t\tif (ccw(gon[i], gon[(i + 1) % gon.size()], p) == CLOCKWISE) return (false);\n\t}\n\treturn (true);\n}\n\nPoint unitVector(Vector t)\n{\n\tdouble u = abs(t);\n\treturn (Point(t.x / u , t.y / u));\n}\n\ndouble getCos(Vector a, Vector b)\n{\n\treturn (dot(a, b) / (abs(a) * abs(b)));\n}\n\ndouble getSin(Point a , Point b)\n{\n\tdouble t = getCos(a, b);\n\treturn (sqrt(1.0 - t * t));\n}\n\ndouble getArg(Vector v)\n{\n\treturn (atan2(v.y, v.x));\n}\n\ndouble getDistPL(Point p, Point a, Point b)\n{\n\treturn (fabs(cross(b - a, p - a)) / abs(b - a));\n}\n\ndouble getDistPS(Point p, Point a, Point b)\n{\n\tif(dot(b - a, p - a) < EPS) return (abs(p - a));\n\tif(dot(a - b, p - b) < EPS) return (abs(p - b));\n\treturn (getDistPL(p, a, b));\n}\n\nPoint interPointS(Point a1 , Point a2 , Point b1 , Point b2)\n{\n\tPoint b = b2 - b1;\n\tdouble d1 = fabs(cross(b, a1 - b1));\n\tdouble d2 = fabs(cross(b, a2 - b1));\n\tdouble t = d1 / (d1 + d2);\n\tPoint a = a2 - a1;\n\tPoint v = a * t;\n\treturn (a1 + v);\n}\n\nPoint interPointL(Point a1 , Point a2 , Point b1 , Point b2)\n{\n\tPoint a = a2 - a1;\n\tPoint b = b2 - b1;\n\tdouble t = cross(b, b1 - a1) / cross(b, a);\n\tPoint v = a * t;\n\treturn (a1 + v);\n}\n\nvoid interPointLC(Point a, Point b, Point c, double r, Point ans[])\n{\n\tif (getDistPL(c, a, b) > r + EPS) return;\n\tPoint v = unitVector(b - a);\n\tdouble delta = dot(v, a - c) * dot(v, a - c) - abs(a - c) * abs(a - c) + r * r;\n\tdouble t = -dot(v, a - c);\n\tdouble s = sqrt(delta);\n\tans[0] = a + v * (t + s);\n\tans[1] = a + v * (t - s);\n}\n\nPoint xTranslate(Point t, double k)\n{\n\treturn (Point(t.x, 2 * k - t.y));\n}\n\nPoint yTranslate(Point t, double k)\n{\n\treturn (Point(2 * k - t.x, t.y));\n}\n\nPoint oTranslate(Point t, Point k)\n{\n\treturn (k + (k - t));\n}\n\nPoint rotate(Point t , Point p , double r)\n{\n\tdouble ta=cos(r)*(t.x-p.x)-sin(r)*(t.y-p.y)+p.x;\n\tdouble tb=sin(r)*(t.x-p.x)+cos(r)*(t.y-p.y)+p.y;\n\treturn Point(ta , tb);\n}\n\nvoid interPointCC(Point a , double ra , Point b , double rb , Point ans[])\n{\n\tdouble di=fabs(abs(a-b));\n\tif(di > ra+rb || di < fabs(ra-rb)) return;\n\tdouble t=(ra*ra-rb*rb+di*di)/(di+di);\n\tdouble rd=acos(t/ra);\n\n\tPoint dv=unitVector(b-a);\n\tPoint g1=rotate(dv , Point(0,0) , rd);\n\tPoint g2=rotate(dv , Point(0,0) , -rd);\n\tans[0]=a+g1*ra;\n\tans[1]=a+g2*ra;\n}\n\nPoint normalVector(Point p,Point a,Point b)\n{\n\tPoint v=unitVector(b-a);\n\tv = cross(v , p-a) > 0 ?  Point(v.y,(-1)*v.x) : Point((-1)*v.y , v.x);\n\treturn v*getDistPL(p,a,b);\n}\n\nPoint fTranslate(Point t , Point a , Point b)\n{\n\treturn t+normalVector(t,a,b)*2;\n}\n\ndouble area(Point a, Point b, Point c){\n\treturn fabs(cross(c-a , b-a)*0.5);\n}\n\ndouble polygonArea(Polygon t){\n\tdouble ans = 0.0;\n\tfor (unsigned int i = 0; i < t.size(); i++)\n\t\tans += cross(t[i] , t[(i + 1) % t.size()]);\n\treturn (ans / 2);\n}\n\nPolygon conhel(Polygon& ps)\n{\n    sort(ps.begin(), ps.end());\n    int k = 0, n = static_cast<int>(ps.size());\n    Polygon qs(n * 2);\n    \n    for (int i = 0; i < n; i++){\n      while (k > 1 && cross(qs[k - 1] - qs[k - 2], ps[i] - qs[k - 1]) < EPS) k--;\n      qs[k++] = ps[i];\n    }\n\n    for (int i = n - 2, t = k; i >= 0; i--){\n      while (k > t && cross(qs[k - 1] - qs[k - 2], ps[i] - qs[k - 1]) < EPS) k--;\n      qs[k++] = ps[i];\n    }\n\n    qs.resize(k - 1);\n    return (qs);\n}\n\nbool isIn(Point center, Point target, double arg, double arg2, double len)\n{\n\tif (gt(abs(target - center), len)) return (false);\n\t\n\tPoint p1 = Point(center.x + len * cos(arg - arg2 / 2), center.y + len * sin(arg - arg2 / 2)),\n\t\t  p2 = Point(center.x + len * cos(arg + arg2 / 2), center.y + len * sin(arg + arg2 / 2));\n\t\n\treturn (ccw(p1, center, target) == CLOCKWISE && ccw(p2, center, target) == COUNTER_CLOCKWISE);\n}\n\nint main()\n{\n\tint H, R;\n\tint U, M, S, du, dm, ds;\n\tint cnt[128];\n\tPoint house[128], up[16], mp[16], sp[16];\n\t\n\twhile (scanf(\"%d %d\", &H, &R) && H){\n\t\tfor (int i = 0; i < H; i++) scanf(\"%lf %lf\", &house[i].x, &house[i].y);\n\t\t\n\t\tscanf(\"%d %d %d %d %d %d\", &U, &M, &S, &du, &dm, &ds);\n\t\tfor (int i = 0; i < U; i++) scanf(\"%lf %lf\", &up[i].x, &up[i].y);\n\t\tfor (int i = 0; i < M; i++) scanf(\"%lf %lf\", &mp[i].x, &mp[i].y);\n\t\tfor (int i = 0; i < S; i++) scanf(\"%lf %lf\", &sp[i].x, &sp[i].y);\n\t\t\n\t\tmemset(cnt, 0 ,sizeof(cnt));\n\t\tint ma = 0;\n\t\tfor (int i = 0; i < R; i++){\n\t\t\tint rad, size;\n\t\t\tscanf(\"%d %d\", &rad, &size);\n\t\t\t\n\t\t\tfor (int j = 0; j < H; j++){\n\t\t\t\tbool ok = isIn(Point(0, 0), house[j], rad * M_PI / 180.0, du * M_PI / 180.0, size);\n\t\t\t\tfor (int k = 0; k < U; k++) ok &= !isIn(up[k], house[j], rad * M_PI / 180.0, du * M_PI / 180.0, size);\n\t\t\t\tfor (int k = 0; k < M; k++) ok &= !isIn(mp[k], house[j], rad * M_PI / 180.0, dm * M_PI / 180.0, size);\n\t\t\t\tfor (int k = 0; k < S; k++) ok &= !isIn(sp[k], house[j], rad * M_PI / 180.0, ds * M_PI / 180.0, size);\n\t\t\t\tcnt[j] += ok;\n\t\t\t\tif (cnt[j] > ma) ma = cnt[j];\n\t\t\t}\n\t\t}\n\t\t\n\t\tif (!ma) printf(\"NA\\n\");\n\t\telse {\n\t\t\tbool printed = false;\n\t\t\tfor (int i = 0; i < H; i++){\n\t\t\t\tif (cnt[i] == ma){\n\t\t\t\t\tif (printed) printf(\" \");\n\t\t\t\t\tprintf(\"%d\", i + 1);\n\t\t\t\t\tprinted = true;\n\t\t\t\t}\n\t\t\t}\n\t\t\tprintf(\"\\n\");\n\t\t}\n\t}\n\treturn (0);\n}"
  },
  {
    "language": "C++",
    "code": "#include<iostream>\n#include<complex>\n#include<vector>\n#include<algorithm>\n\nusing namespace std;\n\ntypedef complex<double> P;\n\ndouble dot(P a,P b){\n  return (a*conj(b)).real();\n}\n\nint main(){\n  for(int H,R;cin>>H>>R,H;){\n    P h[100];\n    for(int i=0;i<H;i++){\n      int x,y;\n      cin>>x>>y;\n      h[i]=P(x,y);\n    }\n    int UMS[3],dums[3];\n    cin>>UMS[0]>>UMS[1]>>UMS[2]>>dums[0]>>dums[1]>>dums[2];\n    P ums[3][10];\n    for(int i=0;i<3;i++){\n      for(int j=0;j<UMS[i];j++){\n\tint x,y;\n\tcin>>x>>y;\n\tums[i][j]=P(x,y);\n      }\n    }\n    int nr[100]={};\n    for(int i=0;i<R;i++){\n      int w,a;\n      cin>>w>>a;\n      auto reach=[=](P s,P d,int ang){\n\tP v=d-s;\n\treturn abs(v)-1e-5<a&&acos(dot(v,polar(1.,w*acos(0)/90))/abs(v))-1e-5<ang*acos(0)/90/2;\n      };\n      for(int j=0;j<H;j++){\n\tif(reach(P(0,0),h[j],dums[0])){\n\t  bool f=false;\n\t  for(int k=0;k<3;k++){\n\t    for(int l=0;l<UMS[k];l++){\n\t      f|=reach(ums[k][l],h[j],dums[k]);\n\t    }\n\t  }\n\t  nr[j]+=!f;\n\t}\n      }\n    }\n    auto m=*max_element(nr,nr+H);\n    if(m==0){\n      cout<<\"NA\"<<endl;\n    }else{\n      vector<int> v;\n      for(int i=0;i<H;i++){\n\tif(m==nr[i]){\n\t  v.push_back(i+1);\n\t}\n      }\n      for(int i=0;i<v.size();i++){\n\tcout<<v[i]<<\" \\n\"[i==v.size()-1];\n      }\n    }\n  }\n}"
  },
  {
    "language": "C++",
    "code": "#include <iostream>\n#include <cstdio>\n#include <cmath>\n#include <vector>\n#include <map>\n#include <stack>\n#include <queue>\n#include <algorithm>\n#include <set>\n#include <cstring>\n\n#define FOR(i,a,b) for(int i=(a);i<(b);i++)\n#define REP(i,j) FOR(i,0,j)\n#define mp std::make_pair\n\ntypedef long long ll;\ntypedef unsigned long long ull;\n\nconst int INF = 1001001001;\nconst double EPS = 1e-8;\n\n// S N E W(南北東西)\nconst int dx[8] = {0, 0, 1, -1, 1, 1, -1, -1}, dy[8] = {1, -1, 0, 0, 1, -1, 1, -1};\n\nstruct P{\n    P(){}\n    P(double _r, double _i):r(_r), i(_i){}\n    void real(const double& v){r = v;}\n    void imag(const double& v){i = v;}\n    double r, i;\n};\n\ndouble real(const P& p){return p.r;}\ndouble imag(const P& p){return p.i;}\ndouble norm(const P& p){double r = real(p), i = imag(p); return r * r + i * i;}\ndouble dist(const P& p){return std::sqrt(norm(p));}\n\nP operator+(const P& lhs, const P& rhs){\n    return P(real(lhs)+real(rhs), imag(lhs)+imag(rhs));\n}\nP operator-(const P& lhs, const P& rhs){\n    return P(real(lhs)-real(rhs), imag(lhs)-imag(rhs));\n}\nP operator-(const P& p){\n    return P(-real(p), -imag(p));\n}\n\ndouble cross(const P& lhs, const P& rhs){\n    return real(lhs)*imag(rhs) - imag(lhs)*real(rhs);\n}\n\ndouble dot(const P& lhs, const P& rhs){\n    return real(lhs)*real(rhs) + imag(lhs)*imag(rhs);\n}\n\nint H, R, U, M, S;\ndouble du, dm, ds;\nP hs[100], us[10], ms[10], ss[10];\n\nbool can(P home, P flower, double d, P wind){\n    if(dist(home-flower) > imag(wind)){return false;}\n    P center;\n    center.real(imag(wind) * std::cos(real(wind)));\n    center.imag(imag(wind) * std::sin(real(wind)));\n    double s = cross(center, home-flower) / dist(center) / dist(home-flower),\n        c = dot(center, home-flower) / dist(center) / dist(home-flower);\n    if((c < 0.0f && d > 90.0f || c > -EPS) && -std::sin(M_PI / 180.0f * d) - EPS < s && s < std::sin(M_PI / 180.0f * d) + EPS){\n        return true;\n    }\n    return false;\n}\n\nint main(){\n    while(std::cin >> H >> R, H || R){\n        REP(i, H){\n            double x, y;\n            std::cin >> x >> y;\n\n            hs[i].real(x); hs[i].imag(y);\n        }\n\n        std::cin >> U >> M >> S >> du >> dm >> ds;\n        REP(i, U){\n            double x, y;\n            std::cin >> x >> y;\n\n            us[i].real(x); us[i].imag(y);\n        }\n        REP(i, M){\n            double x, y;\n            std::cin >> x >> y;\n\n            ms[i].real(x); ms[i].imag(y);\n        }\n        REP(i, S){\n            double x, y;\n            std::cin >> x >> y;\n\n            ss[i].real(x); ss[i].imag(y);\n        }\n\n        P origin(0.0f, 0.0f);\n        int counter[100];\n        memset(counter, 0, sizeof(counter));\n        REP(i, R){\n            double x, y;\n            std::cin >> x >> y;\n            P wind(x, y);\n\n            REP(k, H){\n                bool f = can(hs[k], origin, du, wind),\n                    g = true;\n\n                REP(j, U){\n                    g = g && !can(hs[k], us[j], du, wind);\n                }\n                REP(j, M){\n                    g = g && !can(hs[k], ms[j], dm, wind);\n                }\n                REP(j, S){\n                    g = g && !can(hs[k], ss[j], ds, wind);\n                }\n\n                if(f && g){counter[k] += 1;}\n            }\n        }\n\n        int maxDays = 0;\n        REP(i, H){\n            maxDays = std::max(maxDays, counter[i]);\n        }\n\n        if(maxDays == 0){\n            puts(\"NA\");\n        }else{\n            std::vector<int> indices;\n            REP(i, H){\n                if(counter[i] == maxDays){indices.push_back(i+1);}\n            }\n\n            REP(i, (int)indices.size()){\n                if(i == (int)indices.size() - 1){printf(\"%d\\n\", indices[i]);}\n                else{printf(\"%d \", indices[i]);}\n            }\n        }\n    }\n}"
  },
  {
    "language": "C++",
    "code": "#include<iostream>\n#include<vector>\n#include<math.h>\n#include<complex>\n\n#define EPS 1e-4\n\n#define PI 3.141592\n#define EQ(a,b) (abs((a)-(b))<EPS)\nusing namespace std;\n\ntypedef complex<double> P;\n\nvector<P> house;\nvector<P> ume,sak,mo;\n\ndouble cross(P v1,P v2){\n\treturn v1.real()*v2.imag()-v1.imag()*v2.real();\n}\n\nbool che(P h,P t,double d,double w,double a){\n\tP v=h-t;\n\tif(!(abs(v)<a))return false;\n\t\n\tP v1=P(a*cos((w+d/2)/180*PI),a*sin((w+d/2)/180*PI));\n\tP v2=P(a*cos((w-d/2)/180*PI),a*sin((w-d/2)/180*PI));\n\t\n\tif(cross(v1,v)<=EPS && cross(v2,v)>=-EPS)return true;\n\telse return false;\n}\n\nint main(){\n\tint h,r;\n\t\n\twhile(cin>>h>>r && h&&r){\n\t\thouse.clear();\n\t\tume.push_back(P(0,0));\n\t\tfor(int i=0;i<h;i++){\n\t\t\tint x,y;\n\t\t\tcin>>x>>y;\n\t\t\thouse.push_back(P(x,y));\n\t\t}\n\t\t\n\t\tint U,M,S,du,dm,ds;\n\t\tcin>>U>>M>>S>>du>>dm>>ds;\n\t\tfor(int i=0;i<U;i++){\n\t\t\tint x,y;\n\t\t\tcin>>x>>y;\n\t\t\tume.push_back(P(x,y));\n\t\t}\n\t\tfor(int i=0;i<M;i++){\n\t\t\tint x,y;\n\t\t\tcin>>x>>y;\n\t\t\tmo.push_back(P(x,y));\n\t\t}\n\t\tfor(int i=0;i<S;i++){\n\t\t\tint x,y;\n\t\t\tcin>>x>>y;\n\t\t\tsak.push_back(P(x,y));\n\t\t}\n\t\t\n\t\t\n\t\tint data[120];\n\t\tfor(int i=0;i<120;i++)data[i]=0;\n\t\tfor(int z=0;z<r;z++){\n\t\t\tint w,a;\n\t\t\tcin>>w>>a;\n\t\t\t\n\t\t\tfor(int i=0;i<house.size();i++){\n\t\t\t\tbool ok=false;\n\t\t\t\tif(che(house[i],ume[0],du,w,a))ok=true;\n\t\t\t\telse continue;\n\t\t\t\tfor(int j=1;j<U;j++){\n\t\t\t\t\tif(che(house[i],ume[j],du,w,a))ok=false;\n\t\t\t\t}\n\t\t\t\tfor(int j=0;j<M;j++){\n\t\t\t\t\tif(che(house[i],mo[j],dm,w,a))ok=false;\n\t\t\t\t}\n\t\t\t\tfor(int j=0;j<S;j++){\n\t\t\t\t\tif(che(house[i],sak[j],ds,w,a))ok=false;\n\t\t\t\t}\n\t\t\t\t\n\t\t\t\tif(ok)data[i]++;\n\t\t\t}\n\t\t}\n\t\t\n\t\t\tint ans=0;\n\t\t\tint tmp=-1;\n\t\t\tfor(int i=0;i<h;i++){\n\t\t\t\tif(ans<=data[i]){\n\t\t\t\t\tans=data[i];\n\t\t\t\t\ttmp=i;\n\t\t\t\t}\n\t\t\t}\n\t\t\tif (ans==0)cout<<\"NA\"<<endl;\n\t\t\telse {\n\t\t\t\tfor(int i=0;i<h;i++){\n\t\t\t\t\tif(i==tmp)cout<<i+1;\n\t\t\t\t\telse if(data[i]==ans)cout<<i+1<<\" \";\n\t\t\t\t\t\n\t\t\t\t}\n\t\t\t\tcout<<endl;\n\t\t\t}\n\t\t\t\n\t\t\n\t}\n}"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\n\nusing namespace std;\n\nstruct point {\n    int x, y;\n    int d;\n};\n\nbool check_including(point home, point ums, int w, int a) {\n\n    double x = home.x - ums.x;\n    double y = home.y - ums.y;\n    double home_deg = atan(y / x) * 180 / M_PI;\n    double start_deg = w - ums.d / 2;\n    double end_deg = w + ums.d / 2;\n\n    if(x == 0) {\n        if(y > 0) {\n            home_deg = 90;\n        } else {\n            home_deg = 270;\n        }\n    } else if(y == 0) {\n        if(x > 0) {\n            home_deg = 0;\n        } else {\n            home_deg = 180;\n        }\n    } else if(x < 0 && y > 0) {\n        home_deg += 180;\n    } else if(x < 0 && y < 0) {\n        home_deg += 180;\n    } else if(x > 0 && y < 0) {\n        home_deg += 360;\n    }\n\n    if(start_deg <= home_deg && home_deg <= end_deg && x * x + y * y <= a * a) {\n        return true;\n    } else {\n        return false;\n    }\n\n}\n\nint main() {\n\n    int h, r;\n\n    while(cin >> h >> r, h || r) {\n\n        int u, m, s, du, dm, ds;\n        vector<point> homes, ums;\n\n        for(int i = 0; i < h; ++i) {\n            int x, y;\n            cin >> x >> y;\n            homes.push_back((point){ x, y, 0 });\n        }\n\n        cin >> u >> m >> s;\n        cin >> du >> dm >> ds;\n\n        for(int i = 0; i < u + m + s; ++i) {\n            int x, y;\n            cin >> x >> y;\n            if(i < u) {\n                ums.push_back((point){ x, y, du });\n            } else if(u <= i && i < u + m) {\n                ums.push_back((point){ x, y, dm });\n            } else {\n                ums.push_back((point){ x, y, ds });\n            }\n        }\n\n        for(int i = 0; i < r; ++i) {\n            int w, a;\n            cin >> w >> a;\n            for(int j = 0; j < homes.size(); ++j) {\n                bool is_perfect = true;\n                for(int k = 0; k < ums.size(); ++k) {\n                    if(check_including(homes[j], ums[k], w, a)) {\n                        is_perfect = false;\n                        break;\n                    }\n                }\n                homes[j].d += is_perfect;\n            }\n        }\n\n        int max_day = 0;\n        for(int i = 1; i < homes.size(); ++i) {\n            if(max_day < homes[i].d) {\n                max_day = homes[i].d;\n            }\n        }\n\n        if(max_day) {\n            bool is_out = false;\n            for(int i = 0; i < homes.size(); ++i) {\n                if(homes[i].d == max_day) {\n                    if(is_out) cout << \" \" << i + 1;\n                    else cout << i + 1;\n                    is_out = true;\n                }\n            }\n            cout << endl;\n        } else {\n            cout << \"NA\" << endl;\n        }\n\n    }\n\n}"
  },
  {
    "language": "C++",
    "code": "#include<bits/stdc++.h>\nusing namespace std;\n\ntypedef pair<int,int>pint;\ntypedef vector<int>vint;\n#define pb push_back\n#define mp make_pair\n#define rep(i,n) for(int i=0;i<(n);i++)\ntemplate<class T,class U>void chmin(T &t,U f){if(t>f)t=f;}\ntemplate<class T,class U>void chmax(T &t,U f){if(t<f)t=f;}\n\ntypedef complex<double>P;\n\nconst double EPS=1e-9;\nconst double PI=acos(-1);\n\nconst int COUNTER_CLOCKWISE=1;\nconst int CLOCKWISE=-1;\nconst int ONLINE_BACK=2;\nconst int ONLINE_FRONT=-2;\nconst int ON_SEGMENT=0;\n\ninline double dot(const P &a, const P &b){return (conj(a) * b).real();}\ninline double cross(const P &a, const P &b){return (conj(a) * b).imag();}\n\ndouble toRad(double a){return a/180.0*PI;}\ndouble toDeg(double a){return a*180.0/PI;}\nP rotate(P p,double d){\n    return P(p.real()*cos(d)-p.imag()*sin(d),p.real()*sin(d)+p.imag()*cos(d));\n}\n\nP getP(){\n    double x,y;\n    scanf(\"%lf%lf\",&x,&y);\n    return P(x,y);\n}\n\nint ccw(P p0,P p1,P p2){\n    P a=p1-p0;\n    P b=p2-p0;\n    if(cross(a,b)>EPS)return COUNTER_CLOCKWISE;\n    if(cross(a,b)<-EPS)return CLOCKWISE;\n    if(dot(a,b)<-EPS)return ONLINE_BACK;\n    if(norm(a)<norm(b))return ONLINE_FRONT;\n    return ON_SEGMENT;\n}\n\nbool ok(P from,P to,double w,double a,double d){\n    if(abs(to-from)>a)return false;\n\n    w=toRad(w);\n    d=toRad(d);\n\n    P p0=from+P(cos(w),sin(w))*a;\n    P p1=rotate(p0,-d/2);\n    P p2=rotate(p0,d/2);\n\n    int c1=ccw(from,p1,to);\n    int c2=ccw(from,p2,to);\n\n    if(c1==CLOCKWISE||c1==ONLINE_BACK)return false;\n    if(c2==COUNTER_CLOCKWISE||c2==ONLINE_BACK)return false;\n    return true;\n}\n\nint H,R;\nvector<P>h;\n\nint U,M,S;\ndouble du,dm,ds;\nvector<P>u,m,s;\nvoid solve(){\n    h.resize(H);\n    rep(i,H)h[i]=getP();\n\n    scanf(\"%d%d%d\",&U,&M,&S);\n    scanf(\"%lf%lf%lf\",&du,&dm,&ds);\n\n    u.resize(U);\n    m.resize(M);\n    s.resize(S);\n    rep(i,U)u[i]=getP();\n    rep(i,M)m[i]=getP();\n    rep(i,S)s[i]=getP();\n\n    int cnt[100]={0};\n\n    while(R--){\n        double w,a;\n        scanf(\"%lf%lf\",&w,&a);\n        rep(i,H){\n            bool f=false;\n            if(ok(P(0,0),h[i],w,a,du))f=true;\n            rep(j,U)if(ok(u[j],h[i],w,a,du))f=false;\n            rep(j,M)if(ok(m[j],h[i],w,a,dm))f=false;\n            rep(j,S)if(ok(s[j],h[i],w,a,ds))f=false;\n            if(f)cnt[i]++;\n        }\n    }\n\n    int ma=*max_element(cnt,cnt+H);\n    if(ma==0){\n        puts(\"NA\");\n        return;\n    }\n\n    bool f=false;\n    rep(i,H){\n        if(cnt[i]!=ma)continue;\n        if(f)printf(\" \");\n        else f=true;\n        printf(\"%d\",i+1);\n    }\n    puts(\"\");\n}\n\nint main(){\n    while(scanf(\"%d%d\",&H,&R),H||R)solve();\n    return 0;\n}"
  },
  {
    "language": "C++",
    "code": "\n//自分の梅は任意の地点でかおるとする。EPSはつけない。\n//扇形と家は接しないので、距離はsqrtで求めた。\n\n#include<iostream>\n#include<cmath>\n#include<vector>\n#define rep(i,n) for(i = 0;i < n;i++)\n#define PI 3.14159265358979\nusing namespace std;\n\ntypedef pair<double,double> P;\n\nint H,R;\t\t\t\t//家数,日数\nint hx[100],hy[100];\t//家の座標\nint U,M,S;\t\t\t\t//梅、桃、桜の数\nint du,dm,ds;\t\t\t//梅、桃、桜の扇形の中心角\nint ux[100],uy[100];\t//梅の座標\nint mx[100],my[100];\t//桃の座標\nint sx[100],sy[100];\t//桜の座標\nint w[100],a[100];\t\t//扇形の方向(角度),風の強さ\n\n//半径,角度の順で格納し、返す\n//rotateは角度補正( 補正 = rotate*360 )\nP POLAR( int treex,int treey,int housex,int housey,int rotate )\n{\n\tP ans;\n\tans.first = (housex-treex)*(housex-treex) + (housey-treey)*(housey-treey);\n\tans.first = sqrt( ans.first );\n\tif( housex == treex && housey > treey )\n\t\tans.second = 90;\n\telse if( housex == treex && housey < treey )\n\t\tans.second = -90;\n\telse\n\t\tans.second = atan2( (double)housey - treey, (double)housex - treex ) * 180 / PI;\n\tans.second += 360*rotate;\n\treturn ans;\n}\n\nint main()\n{\n\tint i,j,k,l;\n\twhile( cin >> H >> R )\n\t{\n\t\tint day[100] = {0};\t\t//i番目の家において、他の木の香りが届かなかった日数\n\n\t\tif( H == 0 && R == 0 )\n\t\t\tbreak;\n\t\trep(i,H)\n\t\t\tcin >> hx[i] >> hy[i];\n\t\tcin >> U >> M >> S >> du >> dm >> ds;\n\t\trep(i,U)\n\t\t\tcin >> ux[i] >> uy[i];\n\t\trep(i,M)\n\t\t\tcin >> mx[i] >> my[i];\n\t\trep(i,S)\n\t\t\tcin >> sx[i] >> sy[i];\n\t\trep(i,R)\n\t\t\tcin >> w[i] >> a[i];\n\t\t//ここから探索\n\t\trep(i,R){\n\t\t\trep(j,H){\n\t\t\t\trep(k,U){\n\t\t\t\t\trep(l,3){\n\t\t\t\t\t\tP t = POLAR( ux[k],uy[k],hx[j],hy[j],l-1 );\n\t\t\t\t\t\t//判定\n\t\t\t\t\t\tif( t.first <= a[i] && fabs( (double)w[i] - t.second ) <= du/2.0 )\n\t\t\t\t\t\t\tbreak;\n\t\t\t\t\t}\n\t\t\t\t\tif(l < 3)\n\t\t\t\t\t\tbreak;\n\t\t\t\t}\n\t\t\t\tif(k < U)\n\t\t\t\t\tcontinue;\n\t\t\t\trep(k,M){\n\t\t\t\t\trep(l,3){\n\t\t\t\t\t\tP t = POLAR( mx[k],my[k],hx[j],hy[j],l-1 );\n\t\t\t\t\t\t//判定\n\t\t\t\t\t\tif( t.first <= a[i] && fabs( (double)w[i] - t.second ) <= dm/2.0 )\n\t\t\t\t\t\t\tbreak;\n\t\t\t\t\t}\n\t\t\t\t\tif(l < 3)\n\t\t\t\t\t\tbreak;\n\t\t\t\t}\n\t\t\t\tif(k < M)\n\t\t\t\t\tcontinue;\n\t\t\t\trep(k,S){\n\t\t\t\t\trep(l,3){\n\t\t\t\t\t\tP t = POLAR( sx[k],sy[k],hx[j],hy[j],l-1 );\n\t\t\t\t\t\t//判定\n\t\t\t\t\t\tif( t.first <= a[i] && fabs( (double)w[i] - t.second ) <= ds/2.0 )\n\t\t\t\t\t\t\tbreak;\n\t\t\t\t\t}\n\t\t\t\t\tif(l < 3)\n\t\t\t\t\t\tbreak;\n\t\t\t\t}\n\t\t\t\tif(k < S)\n\t\t\t\t\tcontinue;\n\n\t\t\t\tday[j]++;\n\t\t\t}\n\t\t}\n\t\tint maxday = 0;\n\t\trep(i,H){\n\t\t\tmaxday = max( maxday,day[i] );\n\t\t}\n\t\tif( maxday == 0 ){\n\t\t\tcout << \"NA\" << endl;\n\t\t\tcontinue;\n\t\t}\n\t\trep(i,H){\n\t\t\tif( day[i] == maxday ){\n\t\t\t\tcout << i+1;\n\t\t\t\tif( i < H-1 )\n\t\t\t\t\tcout << ' ';\n\t\t\t\telse\n\t\t\t\t\tcout << endl;\n\t\t\t}\n\t\t}\n\t}\n\treturn 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include<iostream>\n#include<vector>\n#include<math.h>\n#include<complex>\n\n#define EPS 1e-4\n\n#define PI 3.141592\n#define EQ(a,b) (abs((a)-(b))<EPS)\nusing namespace std;\n\ntypedef complex<double> P;\n\nvector<P> house;\nvector<P> ume,sak,mo;\n\ndouble cross(P v1,P v2){\n\treturn v1.real()*v2.imag()-v1.imag()*v2.real();\n}\n\nbool che(P h,P t,double d,double w,double a){\n\tP v=h-t;\n\tif(!(abs(v)<=a+EPS))return false;\n\t\n\tP v1=P(a*cos((w+d/2)/180*PI),a*sin((w+d/2)/180*PI));\n\tP v2=P(a*cos((w-d/2)/180*PI),a*sin((w-d/2)/180*PI));\n\t\n\tif(cross(v1,v)<=EPS && cross(v2,v)>=-EPS)return true;\n\telse return false;\n}\n\nint main(){\n\tint h,r;\n\t\n\twhile(cin>>h>>r && h&&r){\n\t\thouse.clear();\n\t\tume.push_back(P(0,0));\n\t\tfor(int i=0;i<h;i++){\n\t\t\tint x,y;\n\t\t\tcin>>x>>y;\n\t\t\thouse.push_back(P(x,y));\n\t\t}\n\t\t\n\t\tint U,M,S,du,dm,ds;\n\t\tcin>>U>>M>>S>>du>>dm>>ds;\n\t\tfor(int i=0;i<U;i++){\n\t\t\tint x,y;\n\t\t\tcin>>x>>y;\n\t\t\tume.push_back(P(x,y));\n\t\t}\n\t\tfor(int i=0;i<M;i++){\n\t\t\tint x,y;\n\t\t\tcin>>x>>y;\n\t\t\tmo.push_back(P(x,y));\n\t\t}\n\t\tfor(int i=0;i<S;i++){\n\t\t\tint x,y;\n\t\t\tcin>>x>>y;\n\t\t\tsak.push_back(P(x,y));\n\t\t}\n\t\t\n\t\t\n\t\tint data[120];\n\t\tfor(int i=0;i<120;i++)data[i]=0;\n\t\tfor(int z=0;z<r;z++){\n\t\t\tint w,a;\n\t\t\tcin>>w>>a;\n\t\t\t\n\t\t\tfor(int i=0;i<house.size();i++){\n\t\t\t\tbool ok=false;\n\t\t\t\tif(che(house[i],ume[0],du,w,a))ok=true;\n\t\t\t\telse continue;\n\t\t\t\tfor(int j=1;j<U;j++){\n\t\t\t\t\tif(che(house[i],ume[j],du,w,a))ok=false;\n\t\t\t\t}\n\t\t\t\tfor(int j=0;j<M;j++){\n\t\t\t\t\tif(che(house[i],mo[j],dm,w,a))ok=false;\n\t\t\t\t}\n\t\t\t\tfor(int j=0;j<S;j++){\n\t\t\t\t\tif(che(house[i],sak[j],ds,w,a))ok=false;\n\t\t\t\t}\n\t\t\t\t\n\t\t\t\tif(ok)data[i]++;\n\t\t\t}\n\t\t}\n\t\t\n\t\t\tint ans=0;\n\t\t\tfor(int i=0;i<h;i++){\n\t\t\t\tans=max(ans,data[i]);\n\t\t\t}\n\t\t\tif (ans==0)cout<<\"NA\"<<endl;\n\t\t\telse {\n\t\t\t\tfor(int i=0;i<h;i++){\n\t\t\t\t\tif(data[i]==ans)cout<<i+1<<\" \";\n\t\t\t\t}\n\t\t\t\tcout<<endl;\n\t\t\t}\n\t\t\t\n\t\t\n\t}\n}"
  },
  {
    "language": "C++",
    "code": "#include <cmath>\n#include <cstdio>\n#include <algorithm>\n\n#define rep(i,n) for(int i=0;i<(n);i++)\n\nusing namespace std;\n\nconst double PI=acos(-1);\n\n// whether (hx, hy) is covered by the sector (tx,ty,w,a)\nbool check(int hx,int hy,int tx,int ty,double d,double w,int a){\n\tint x=hx-tx,y=hy-ty;\n\tif(sqrt(x*x+y*y)>a) return false;\n\n\tdouble phi=atan2(y,x);\n\tif(w>PI) w-=2*PI; // -PI < w <= PI\n\treturn min(min(abs(phi-w),abs(phi-w+2*PI)),abs(phi-w-2*PI))<d/2;\n}\n\nint main(){\n\tfor(int h,r;scanf(\"%d%d\",&h,&r),h;){\n\t\tint hx[100],hy[100];\n\t\trep(i,h) scanf(\"%d%d\",hx+i,hy+i);\n\n\t\tint nu,nm,ns;\n\t\tdouble du,dm,ds;\n\t\tscanf(\"%d%d%d\",&nu,&nm,&ns);\n\t\tscanf(\"%lf%lf%lf\",&du,&dm,&ds);\n\t\tdu*=PI/180;\n\t\tdm*=PI/180;\n\t\tds*=PI/180;\n\n\t\tint ux[10],uy[10],mx[10],my[10],sx[10],sy[10];\n\t\trep(i,nu) scanf(\"%d%d\",ux+i,uy+i);\n\t\trep(i,nm) scanf(\"%d%d\",mx+i,my+i);\n\t\trep(i,ns) scanf(\"%d%d\",sx+i,sy+i);\n\n\t\tdouble w[100];\n\t\tint a[100];\n\t\trep(i,r){\n\t\t\tscanf(\"%lf%d\",w+i,a+i);\n\t\t\tw[i]*=PI/180;\n\t\t}\n\n\t\tint cnt[100]={};\n\t\trep(i,h) rep(j,r) {\n\t\t\tbool ok=check(hx[i],hy[i],0,0,du,w[j],a[j]);\n\t\t\trep(k,nu) if(check(hx[i],hy[i],ux[k],uy[k],du,w[j],a[j])) ok=false;\n\t\t\trep(k,nm) if(check(hx[i],hy[i],mx[k],my[k],dm,w[j],a[j])) ok=false;\n\t\t\trep(k,ns) if(check(hx[i],hy[i],sx[k],sy[k],ds,w[j],a[j])) ok=false;\n\t\t\tif(ok) cnt[i]++;\n\t\t}\n\n\t\tint maxi=*max_element(cnt,cnt+h);\n\t\tif(maxi==0){ puts(\"NA\"); continue; }\n\n\t\tint num=0;\n\t\trep(i,h) if(cnt[i]==maxi) {\n\t\t\tprintf(\"%s%d\",num>0?\" \":\"\",i+1);\n\t\t\tnum++;\n\t\t}\n\t\tputs(\"\");\n\t}\n\n\treturn 0;\n}"
  },
  {
    "language": "C++",
    "code": "\n//自分の梅は任意の地点でかおるとする。→間違い。\n//EPSはつけない。\n//扇形と家は接しないので、距離はsqrtで求めた。\n\n#include<iostream>\n#include<cmath>\n#include<vector>\n#define rep(i,n) for(i = 0;i < n;i++)\n#define PI 3.14159265358979\nusing namespace std;\n\ntypedef pair<double,double> P;\n\nint H,R;\t\t\t\t//家数,日数\nint hx[100],hy[100];\t//家の座標\nint U,M,S;\t\t\t\t//梅、桃、桜の数\nint du,dm,ds;\t\t\t//梅、桃、桜の扇形の中心角\nint ux[100],uy[100];\t//梅の座標\nint mx[100],my[100];\t//桃の座標\nint sx[100],sy[100];\t//桜の座標\nint w[100],a[100];\t\t//扇形の方向(角度),風の強さ\n\n//半径,角度の順で格納し、返す\n//rotateは角度補正( 補正 = rotate*360 )\nP POLAR( int treex,int treey,int housex,int housey,int rotate )\n{\n\tP ans;\n\tans.first = (housex-treex)*(housex-treex) + (housey-treey)*(housey-treey);\n\tans.first = sqrt( ans.first );\n\tif( housex == treex && housey > treey )\n\t\tans.second = 90;\n\telse if( housex == treex && housey < treey )\n\t\tans.second = -90;\n\telse\n\t\tans.second = atan2( (double)housey - treey, (double)housex - treex ) * 180 / PI;\n\tans.second += 360*rotate;\n\treturn ans;\n}\n\nint main()\n{\n\tint i,j,k,l;\n\twhile( cin >> H >> R )\n\t{\n\t\tint day[100] = {0};\t\t//i番目の家において、他の木の香りが届かなかった日数\n\n\t\tif( H == 0 && R == 0 )\n\t\t\tbreak;\n\t\trep(i,H)\n\t\t\tcin >> hx[i] >> hy[i];\n\t\tcin >> U >> M >> S >> du >> dm >> ds;\n\t\trep(i,U)\n\t\t\tcin >> ux[i] >> uy[i];\n\t\trep(i,M)\n\t\t\tcin >> mx[i] >> my[i];\n\t\trep(i,S)\n\t\t\tcin >> sx[i] >> sy[i];\n\t\trep(i,R)\n\t\t\tcin >> w[i] >> a[i];\n\t\t//ここから探索\n\t\trep(i,R){\n\t\t\trep(j,H){\n\t\t\t\trep(k,U){\n\t\t\t\t\trep(l,3){\n\t\t\t\t\t\tP t = POLAR( ux[k],uy[k],hx[j],hy[j],l-1 );\n\t\t\t\t\t\t//判定\n\t\t\t\t\t\tif( t.first <= a[i] && fabs( (double)w[i] - t.second ) <= du/2.0 )\n\t\t\t\t\t\t\tbreak;\n\t\t\t\t\t}\n\t\t\t\t\tif(l < 3)\n\t\t\t\t\t\tbreak;\n\t\t\t\t}\n\t\t\t\tif(k < U)\n\t\t\t\t\tcontinue;\n\t\t\t\trep(k,M){\n\t\t\t\t\trep(l,3){\n\t\t\t\t\t\tP t = POLAR( mx[k],my[k],hx[j],hy[j],l-1 );\n\t\t\t\t\t\t//判定\n\t\t\t\t\t\tif( t.first <= a[i] && fabs( (double)w[i] - t.second ) <= dm/2.0 )\n\t\t\t\t\t\t\tbreak;\n\t\t\t\t\t}\n\t\t\t\t\tif(l < 3)\n\t\t\t\t\t\tbreak;\n\t\t\t\t}\n\t\t\t\tif(k < M)\n\t\t\t\t\tcontinue;\n\t\t\t\trep(k,S){\n\t\t\t\t\trep(l,3){\n\t\t\t\t\t\tP t = POLAR( sx[k],sy[k],hx[j],hy[j],l-1 );\n\t\t\t\t\t\t//判定\n\t\t\t\t\t\tif( t.first <= a[i] && fabs( (double)w[i] - t.second ) <= ds/2.0 )\n\t\t\t\t\t\t\tbreak;\n\t\t\t\t\t}\n\t\t\t\t\tif(l < 3)\n\t\t\t\t\t\tbreak;\n\t\t\t\t}\n\t\t\t\tif(k < S)\n\t\t\t\t\tcontinue;\n\n\t\t\t\t//私の梅の香りは届くのか！！\n\t\t\t\tP t = POLAR( 0,0,hx[j],hy[j],l-1 );\n\t\t\t\tif(  t.first <= a[i] && fabs( (double)w[i] - t.second ) <= du/2.0 )\n\t\t\t\t\tday[j]++;\n\t\t\t}\n\t\t}\n\t\tint maxday = 0;\n\t\trep(i,H){\n\t\t\tmaxday = max( maxday,day[i] );\n\t\t}\n\t\tif( maxday == 0 ){\n\t\t\tcout << \"NA\" << endl;\n\t\t\tcontinue;\n\t\t}\n\t\trep(i,H){\n\t\t\tif( day[i] == maxday ){\n\t\t\t\tcout << i+1;\n\t\t\t\tif( i < H-1 )\n\t\t\t\t\tcout << ' ';\n\t\t\t\telse\n\t\t\t\t\tcout << endl;\n\t\t\t}\n\t\t}\n\t}\n\treturn 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include<cstdio>\n#include<cstring>\n#include<vector>\n#include<queue>\n#include<algorithm>\n#include<cmath>\n#include<cstring>\n#include<climits>\nusing namespace std;\n#define rep(i,n) for(int i=0;i<(n);i++)\n#define reg(i,a,b) for(int i=(a);i<=(b);i++)\n#define irep(i,n) for(int i=((int)(n))-1;i>=0;i--)\n#define ireg(i,a,b) for(int i=(b);i>=(a);i--)\ntypedef long long int lli;\ntypedef pair<int,int> mp;\n#define fir first\n#define sec second\n#define IINF INT_MAX\n#define LINF LLONG_MAX\n\n\nint ih,iwd;\nint hx[105];\nint hy[105];\n\ndouble det(double x,double y,double p,double q){\n\treturn x*q - p*y;\n}\n\nbool isin(int x,int y,int r,double k,double kai){\n\tif(r*r<x*x+y*y)return false;\n\tdouble r1 = (k+kai/2)/360.0*2*3.14159265358979;\n\tdouble r2 = (k-kai/2)/360.0*2*3.14159265358979;\n\t//printf(\"%lf %lf %lf %lf\\n\",r1,r2,det(x,y,cos(r1),sin(r1)), det(x,y,cos(r2),sin(r2)));\n\tif(det(x,y,cos(r1),sin(r1)) > 0 && det(x,y,cos(r2),sin(r2)) < 0)return true;\n\treturn false;\n}\n\nint main(void){\n\t//printf(\"%d %d %d\\n\",true,false,isin(1,3,6,45,30));\n\twhile(1){\n\t\tscanf(\"%d%d\",&ih,&iwd);\n\t\tif(ih==0)break;\n\t\trep(i,ih){\n\t\t\tscanf(\"%d%d\",&hx[i],&hy[i]);\n\t\t}\n\t\tint ans[105]={};\n\t\t\n\t\tint tn[3];\n\t\trep(i,3)scanf(\"%d\",&tn[i]);\n\t\tint tr[3];\n\t\trep(i,3)scanf(\"%d\",&tr[i]);\n\t\t\n\t\tint tx[3][20];\n\t\tint ty[3][20];\n\t\trep(i,3){\n\t\t\trep(j,tn[i]){\n\t\t\t\tscanf(\"%d%d\",&tx[i][j],&ty[i][j]);\n\t\t\t}\n\t\t}\n\t\t\n\t\trep(p,iwd){\n\t\t\tint nk,na;\n\t\t\tscanf(\"%d%d\",&nk,&na);\n\t\t\tint ok[105]={};\n\t\t\trep(i,ih){\n\t\t\t\tif(isin(hx[i],hy[i],na,nk,tr[0]))ok[i]=1;\n\t\t\t}\n\t\t\t/*\n\t\t\trep(i,ih){\n\t\t\t\tprintf(\"%d \",ok[i]);\n\t\t\t}\n\t\t\tprintf(\"\\n\");*/\n\t\t\trep(i,3){\n\t\t\t\trep(j,tn[i]){\n\t\t\t\t\trep(k,ih){\n\t\t\t\t\t\tint nx = hx[k]-tx[i][j];\n\t\t\t\t\t\tint ny = hy[k]-ty[i][j];\n\t\t\t\t\t\tif(isin(nx,ny,na,nk,tr[i])){\n\t\t\t\t\t\t\t//printf(\"%d %d %d %d %d\\n\",nx,ny,na,nk,tr[i]);\n\t\t\t\t\t\t\t//printf(\"out.....%d  %d %d\\n\",i,j,k);\n\t\t\t\t\t\t\tok[k]=0;\n\t\t\t\t\t\t}\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t}\n\n\t\t\trep(i,ih){\n\t\t\t\tif(ok[i]==1)ans[i]++;\n\t\t\t}\n\t\t\t\n\t\t\t/*\n\t\t\trep(i,ih){\n\t\t\t\tprintf(\"%d \",ans[i]);\n\t\t\t}\n\t\t\tprintf(\"\\n\");*/\n\t\t}\n\t\t\n\t\tint nmax = 0;\n\t\trep(i,ih){\n\t\t\t//printf(\"%d \",ans[i]);\n\t\t\tif(ans[i]>nmax)nmax = ans[i];\n\t\t}\n\t\t//printf(\"\\n\");\n\t\tvector<int> anss;\n\t\tif(nmax==0)printf(\"NA\\n\");\n\t\telse{\n\t\t\trep(i,ih){\n\t\t\t\tif(ans[i]==nmax)anss.push_back(i+1);\n\t\t\t}\n\t\t\trep(i,anss.size()){\n\t\t\t\tprintf(\"%d%c\",anss[i],i+1==anss.size()?'\\n':' ');\n\t\t\t}\n\t\t}\n\t\t\n\t}\n\treturn 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include<iostream>\n#include<cstdio>\n#include<cstdlib>\n#include<complex>\n#include<vector>\n#include<algorithm>\n#include<cmath>\n\n#define EQ(a,b) (abs((a)-(b)) < EPS)\n#define fs first\n#define sc second\n#define pb push_back\n#define sz size()\n#define rep(i,a) for(int i=0;i<(int)(a);i++)\n\nusing namespace std;\ntypedef long double D;\ntypedef complex<D> P;\nconst D EPS = 1e-10;\nconst D PI = acos(-1);\n\nD dot(P x,P y){return real(conj(x)*y);}\nD cross(P x,P y){return imag(conj(x)*y);}\nD arg(P a,P b,P c){\n  D res = acos(dot(b-a,c-a)/(abs(b-a)*abs(c-a))); \n  return (cross(b-a,c-a)<EPS)?2*PI-res:res;\n}\n\nint h,r,n[3];\nD d[3],tmp1,tmp2,seta;\nP hp[110],up[3][110];\nD w[110],a[110];\nconst P O = P(0,0), H = P(1,0);\n\nint main(){\n  int cnt = 0;\n  while(cin >> h >> r,h){\n    rep(i,h){\n      cin >> tmp1 >> tmp2;\n      hp[i] = P(tmp1,tmp2);\n    }\n\n    rep(i,3)cin >> n[i]; rep(i,3)cin >> d[i], d[i] *= PI/180/2;\n\n    rep(i,3)rep(j,n[i]){\n      cin >> tmp1 >> tmp2;\n      up[i][j] = P(tmp1,tmp2);\n    }\n\n    rep(i,r)cin >> w[i] >> a[i], w[i] *= PI/180;\n\n    int num[110] = {};\n    rep(x,r){\n      rep(id,h){\n\tint in = 0;\n\trep(i,3)rep(j,n[i]){\n\t  //if(id==4)cout << i << \" \" <<  abs(hp[id]-up[i][j]) << endl;\n\t  if(abs(hp[id]-up[i][j]) < a[x] +EPS){\n\t    P tmp = P(up[i][j].real() + 1, up[i][j].imag());\n\t    seta = arg(up[i][j],tmp,hp[id]);\n\t    if(id==4)cout << seta/PI * 180 << endl;\n\t    if(w[x]-d[i] < seta+EPS && seta < w[x]+d[i]+EPS){\n\t      in++;\n\t    }\n\t  }\n\t}\n\t//if(id==4)cout << in << endl;\n\tif(in)continue;\n\n        seta = arg(P(0,0),P(1,0),hp[id]);\n\t//if(id==4)cout << seta/PI * 180 << endl;\n\tif(abs(hp[id]) < a[x] + EPS && w[x]-d[0] < seta+EPS && seta < w[x]+d[0]+EPS){\n\t  num[id]++;\n\t}\n      }\n    }\n\n    int maxv = *max_element(num,num+h);\n    vector<int> ans;\n    if(maxv==0)cout << \"NA\\n\";\n    else{\n      rep(i,h){\n\tif(num[i] == maxv)ans.pb(i+1);\n      }\n      rep(i,ans.sz)cout << ans[i] << (i+1==ans.size()?\"\\n\":\" \");\n    }\n  }\n}"
  },
  {
    "language": "C++",
    "code": "#include <iostream>\n#include <vector> \n#include <cmath>\nusing namespace std;\n\n#define rep(i, n) for(int i = 0;i < n;i++)\n#define cin_pair(p) cin >> (p).first >> (p).second;\n\ntypedef pair<int, int> pos;\n\nbool isInSmell(int x, int y, int w, float d, int a, int cx, int cy) {\n    cx -= x; cy -= y;\n    x = y = 0;\n    int angle = atan2((double)cy, (double)cx) / M_PI * 180, lensq = cx * cx + cy * cy;\n    if(angle < 0) angle += 360;\n    return (w - d / 2 <= angle && angle <= w + d / 2 && lensq <= a * a);\n}\n\nbool isInSmells(int w, float d, int a, vector<pos> &vec, int cx, int cy) {\n    //cout << vec.size();\n    rep(i, vec.size()) {\n        //cout << vec[i].first << ' ' << vec[i].second << endl;\n        if(isInSmell(vec[i].first, vec[i].second, w, d, a, cx, cy)) {\n            return true;\n        }\n    }\n}\n\nint main() {\n    int H, R;\n    int U, M, S, du, dm, ds;\n\n    while(true) {\n        cin >> H >> R;\n        if(!H && !R) break;\n\n        vector<pos> h(H);\n        rep(i, H) {\n            cin_pair(h[i]);\n        }\n        cin >> U >> M >> S >> du >> dm >> ds;\n        vector<pos> u(U), m(M), s(S), wa(R);\n        rep(i, U) {\n            cin_pair(u[i]);\n        }\n        rep(i, M) {\n            cin_pair(m[i]);\n        }\n        rep(i, S) {\n            cin_pair(s[i]);\n        }\n        rep(i, R) {\n            cin_pair(wa[i]);\n        }\n\n        vector<int> days(H, 0);\n        int maxa = -1;\n        rep(ri, R) {\n            rep(hi, H) {\n                int x = h[hi].first, y = h[hi].second;\n                int w = wa[ri].first, a = wa[ri].second;\n                if(\n                    !isInSmells(w, du, a, u, x, y) &&\n                    !isInSmells(w, dm, a, m, x, y) &&\n                    !isInSmells(w, ds, a, s, x, y) &&\n                    isInSmell(0, 0, w, du, a, x, y)\n                    ){\n                    days[hi]++;\n                    maxa = max(maxa, days[hi]);\n                }\n            }\n        }\n\n        //rep(i, days.size()) cout << days[i] << ' ';\n        //cout << endl;\n\n        int ansnum = 0;\n        rep(i, H) {\n            if(days[i] == maxa) ansnum++;\n        }\n        if(maxa == -1) {\n            cout << \"NA\" << endl;\n        }\n        else {\n            int j = 0;\n            rep(i, H) {\n                if(days[i] == maxa) {\n                    cout << i + 1;\n                    ansnum--;\n                    if(ansnum != 0) cout << ' ';\n                }\n            }\n            cout << endl;\n        }\n    }\n}"
  },
  {
    "language": "C++",
    "code": "#include<iostream>\n#include<vector>\n#include<cmath>\n#include<algorithm>\n#include<numeric>\nusing namespace std;\n\nconst double PI = 3.14159265358979;\nconst double EPS = 1e-9;\n\nclass Point {\npublic:\n    double x, y;\n    Point(double x = 0.0, double y = 0.0) :x(x), y(y) {}\n};\n\nclass Wind {\npublic:\n    double w, a;\n};\n\nbool savor(const Point &home, const Wind &wind, const vector<Point> &blossom, double d) {\n//     cout << \"home: \" << home.x << \", \" << home.y << endl;\n//     cout << \"blossom\" << endl; for(const auto &i: blossom) cout << \"  \" << i.x << \",\" << i.y; cout << endl;\n//     cout << \"d: \" << d << endl;\n//     cout << \"wind: \" << wind.w << \", \" << wind.a << endl;\n//     cout << endl;\n    d /= 2.0;\n    for(const auto &b: blossom) {\n        Point dif(home.x - b.x, home.y - b.y);\n        double angle = atan2(dif.y, dif.x);\n        double dist = hypot(dif.y, dif.x);\n        if(angle < 0) angle = 2 * PI - angle;\n//         cout<<\"angle: \"<<angle<<endl;\n//         cout<<\"wind.w +- d: \"<<wind.w - d<<\" - \"<<wind.w + d<<endl;\n//         cout<<\"dist: \"<<dist<<endl;\n        if(wind.w - d <= angle + EPS && angle <= wind.w + d + EPS && dist <= wind.a + EPS) return true;\n    }\n    return false;\n}\n\ndouble toRadian(double d) {\n    return d * PI / 180.0;\n    double result = d * PI / 180.0;\n    return result > PI ? result - 2.0 * PI : result;\n}\n\nint main() {\n    int H, R;\n    while(cin >> H >> R, H | R) {\n        vector<Point> home(H);\n        for(auto &i: home) cin >> i.x >> i.y;\n\n        int U, M, S;\n        double du, dm, ds;\n        cin >> U >> M >> S >> du >> dm >> ds;\n\n        du = toRadian(du);\n        dm = toRadian(dm);\n        ds = toRadian(ds);\n\n        vector<Point> plum(U), peach(M), cherry(S);\n        for(auto &i: plum) cin >> i.x >> i.y;\n        for(auto &i: peach) cin >> i.x >> i.y;\n        for(auto &i: cherry) cin >> i.x >> i.y;\n\n        vector<Wind> wind(R);\n        for(auto &i: wind) cin >> i.w >> i.a;\n        for(auto &i: wind) i.w = toRadian(i.w);\n\n        // test\n//         cout << savor(home[5], wind[0], peach, dm) << endl;\n//         return 0;\n\n        // solve\n        vector<int> number(H, 0);\n        int maxNumber = 0;\n\n        for(int i = 0; i < H; ++i) {\n            for(int day = 0; day < R; ++day) {\n                bool ok = savor(home[i], wind[day], {Point(0.0, 0.0)}, du);\n                bool ng = false;\n                ng |= savor(home[i], wind[day], plum, du);\n                ng |= savor(home[i], wind[day], peach, dm);\n                ng |= savor(home[i], wind[day], cherry, ds);\n\n//                 cout<<\"day\"<<day<<endl;\n//                 cout<<savor(home[i], wind[day], plum, du)<<\" \"<<savor(home[i], wind[day], peach, du)<<\" \"<<savor(home[i], wind[day], cherry, du)<<endl;\n\n                if(!ok || ng) continue;\n\n                ++number[i];\n                maxNumber = max(maxNumber, number[i]);\n            }\n        }\n\n//         for(const auto &i: number) cout<<\" \"<<i;cout<<endl;\n\n        if(maxNumber) {\n            bool first = true;\n            for(int i = 0; i < H; ++i) if(number[i] == maxNumber) {\n                if(!first) cout << \" \";\n                first = false;\n                cout << i + 1;\n            }\n            cout << endl;\n        } else {\n            cout << \"NA\" << endl;\n        }\n\n//         return 0;\n    }\n}"
  },
  {
    "language": "C++",
    "code": "#include<iostream>\n#include<complex>\n#include<vector>\n#include<algorithm>\n#include<cmath>\n#include<cstring>\n\n#define pb push_back\n#define sz size()\n#define rep(i,a) for(int i=0;i<(int)(a);i++)\n\nusing namespace std;\ntypedef long double D;\ntypedef complex<D> P;\nconst D EPS = 1e-10;\nconst D PI = acos(-1);\n\ninline D dot(P x,P y){return real(conj(x)*y);}\ninline D cross(P x,P y){return imag(conj(x)*y);}\ninline D arg(P a,P b,P c){\n  D res = acos(dot(b-a,c-a)/(abs(b-a)*abs(c-a))); \n  return (cross(b-a,c-a)<0.0)?2*PI-res:res;\n}\n\nint h,r,n[3];\nD d[3],tmp1,tmp2,seta;\nP hp[110],up[3][110];\nD w[110],a[110];\n\nint main(){\n  while(cin >> h >> r,h){\n    rep(i,h){\n      cin >> tmp1 >> tmp2;\n      hp[i] = P(tmp1,tmp2);\n    }\n\n    rep(i,3)cin >> n[i]; rep(i,3)cin >> d[i], d[i] *= PI/180/2;\n\n    rep(i,3)rep(j,n[i]){\n      cin >> tmp1 >> tmp2;\n      up[i][j] = P(tmp1,tmp2);\n    }\n\n    rep(i,r)cin >> w[i] >> a[i], w[i] *= PI/180;\n\n    int num[110];\n    memset(num,0,sizeof(num));\n\n    rep(x,r)rep(id,h){\n      if( !(abs(hp[id]) < a[x] + EPS) )continue;\n      seta = arg(P(0,0),P(100,0),hp[id]);\n      if( !(w[x]-d[0] < seta+EPS && seta < w[x]+d[0]+EPS)\n\t  && !(w[x]-d[0]+2*PI < seta+EPS && seta < w[x]+d[0]+2*PI+EPS) )continue;\n\n      bool in = 0;\n      rep(i,3){\n\trep(j,n[i]){\n\t  if(abs(hp[id]-up[i][j]) < a[x] +EPS){\n\t    P tmp = P(up[i][j].real() + 100.0, up[i][j].imag());\n\t    seta = arg(up[i][j],tmp,hp[id]);\n\t    if(w[x]-d[i] < seta+EPS && seta < w[x]+d[i]+EPS){\n\t      in = 1; break;\n\t    }\n\t    seta -= 2*PI;\n\t    if(w[x]-d[i] < seta+EPS && seta < w[x]+d[i]+EPS){\n\t      in = 1; break;\n\t    }\n\t  }\n\t}\n\tif(in)break;\n      }\n      if(!in)num[id]++;\n    }\n\n    int maxv = *max_element(num,num+h);\n    if(maxv==0)cout << \"NA\\n\";\n    else{\n      vector<int> ans;\n      rep(i,h){\n\tif(num[i] == maxv)ans.pb(i+1);\n      }\n      rep(i,ans.sz)cout << ans[i] << (i+1==ans.size()?\"\\n\":\" \");\n    }\n  }\n}"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\nusing namespace std;\ntypedef complex<double> Point;\ntypedef pair<Point, double> Tree;\n\nint H;\nPoint home[100];\n\nint U, M, S, du, dm, ds;\nTree tree[31];\n\nint R;\nint w[100], a[100];\n\ndouble toRad(double theta)\n{\n\treturn theta / 180 * acos(-1);\n}\n\ndouble cross(Point a, Point b)\n{\n\treturn a.real() * b.imag() - a.imag() * b.real();\n}\n\nbool contains(Tree tree, Point home, double dir, double len)\n{\n\tif (abs(home - tree.first) > len) return false;\n\tdouble left = dir + tree.second / 2;\n\tdouble right = dir - tree.second / 2;\n\tPoint vh = home - tree.first;\n\tPoint vl = polar(len, left);\n\tPoint vr = polar(len, right);\n\treturn (cross(vr, vh) > -1e-6) && (cross(vh, vl) > -1e-6);\n}\n\nvoid solve()\n{\n\t// day, home\n\tstatic int reach[100][100];\n\tfill_n(*reach, 100 * 100, 0);\n\t\n\tfor (int i = 0; i < R; i++){\n\t\tfor (int j = 0; j < H; j++){\n\t\t\tfor (int k = 0; k <= U + M + S; k++){\n\t\t\t\tif (contains(tree[k], home[j], toRad(w[i]), a[i])){\n\t\t\t\t\treach[i][j] |= 1 << k;\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t}\n\t\n\tstatic int cnt[100];\n\tfill_n(cnt, 100, 0);\n\t\n\tint maxi = 0;\n\tfor (int i = 0; i < H; i++){\n\t\tfor (int j = 0; j < R; j++){\n\t\t\tcnt[i] += (reach[j][i] == 1);\n\t\t\tmaxi = max(maxi, cnt[i]);\n\t\t}\n\t}\n\t\n\tif (maxi == 0) puts(\"NA\");\n\telse {\n\t\tbool f = false;\n\t\tfor (int i = 0; i < H; i++){\n\t\t\tif (cnt[i] == maxi){\n\t\t\t\tif (f) printf(\" \");\n\t\t\t\tf = true;\n\t\t\t\tprintf(\"%d\", i + 1);\n\t\t\t}\n\t\t}\n\t\tputs(\"\");\n\t}\n}\n\nint main()\n{\n\twhile (scanf(\"%d %d\", &H, &R), H){\n\t\tfor (int i = 0; i < H; i++){\n\t\t\tint x, y;\n\t\t\tscanf(\"%d %d\", &x, &y);\n\t\t\thome[i] = Point(x, y);\n\t\t}\n\t\t\n\t\tscanf(\"%d %d %d\", &U, &M, &S);\n\t\tscanf(\"%d %d %d\", &du, &dm, &ds);\n\t\ttree[0] = Tree(Point(0, 0), toRad(du));\n\t\tfor (int i = 0; i < U + M + S; i++){\n\t\t\tint x, y, d;\n\t\t\tscanf(\"%d %d\", &x, &y);\n\t\t\tif (i < U) d = du;\n\t\t\telse if (i < U + M) d = dm;\n\t\t\telse d = ds;\n\t\t\ttree[i + 1] = Tree(Point(x, y), toRad(d));\n\t\t}\n\t\t\n\t\tfor (int i = 0; i < R; i++){\n\t\t\tscanf(\"%d %d\", &w[i], &a[i]);\n\t\t}\n\t\t\n\t\tsolve();\n\t}\n\t\n\treturn 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\n\nusing namespace std;\n\nstruct point {\n    int x, y;\n    int d;\n};\n\nbool check_including(point home, point ums, int w, int a) {\n\n    double x = home.x - ums.x;\n    double y = home.y - ums.y;\n    double home_deg;\n    double start_deg = w - ums.d / 2.0;\n    double end_deg = w + ums.d / 2.0;\n\n    home_deg = atan2(y, x) * 180 / M_PI;\n\n    if(home_deg < 0) {\n        home_deg += 360;\n    }\n\n    if(start_deg < 0) {\n        start_deg += 360;\n        end_deg += 360;\n    }\n\n    if(end_deg > 360.0) {\n        home_deg += 360;\n    }\n\n\n    if(start_deg <= home_deg && home_deg <= end_deg && x * x + y * y <= a * a) {\n        return true;\n    } else {\n        return false;\n    }\n\n}\n\nint main() {\n\n    int h, r;\n\n    while(cin >> h >> r, h || r) {\n\n        int u, m, s, du, dm, ds;\n        vector<point> homes, ums;\n\n        for(int i = 0; i < h; ++i) {\n            int x, y;\n            cin >> x >> y;\n            homes.push_back((point){ x, y, 0 });\n        }\n\n        cin >> u >> m >> s;\n        cin >> du >> dm >> ds;\n\n        for(int i = 0; i < u + m + s; ++i) {\n            int x, y;\n            cin >> x >> y;\n            if(i < u) {\n                ums.push_back((point){ x, y, du });\n            } else if(u <= i && i < u + m) {\n                ums.push_back((point){ x, y, dm });\n            } else {\n                ums.push_back((point){ x, y, ds });\n            }\n        }\n\n        for(int i = 0; i < r; ++i) {\n            int w, a;\n            cin >> w >> a;\n            for(int j = 0; j < homes.size(); ++j) {\n                bool is_perfect = true;\n                for(int k = 0; k < ums.size(); ++k) {\n                    if(check_including(homes[j], ums[k], w, a)) {\n                        is_perfect = false;\n                        break;\n                    }\n                }\n                homes[j].d += is_perfect;\n            }\n        }\n\n        int max_day = 0;\n        for(int i = 1; i < homes.size(); ++i) {\n            if(max_day < homes[i].d) {\n                max_day = homes[i].d;\n            }\n        }\n\n        if(max_day) {\n            bool is_out = false;\n            for(int i = 0; i < homes.size(); ++i) {\n                if(homes[i].d == max_day) {\n                    if(is_out) cout << \" \" << i + 1;\n                    else cout << i + 1;\n                    is_out = true;\n                }\n            }\n            cout << endl;\n        } else {\n            cout << \"NA\" << endl;\n        }\n\n    }\n\n}"
  },
  {
    "language": "C++",
    "code": "#include<bits/stdc++.h>\nusing namespace std;\n\ntypedef pair<int,int> P;\n\n/* 平面幾何の基本要素 */\n \n#define EPS (1e-10)\n#define equals(a,b) (fabs((a) - (b)) < EPS )\n#define PI 3.141692653589793\n \nclass Point { // 点を表すクラス\n  public:\n  double x,y;\n   \n  Point(double x=0,double y=0): x(x),y(y) {}\n   \n  Point operator + (Point p) { return Point(x + p.x, y + p.y); }\n  Point operator - (Point p) { return Point(x - p.x, y - p.y); }\n  Point operator * (double a) { return Point(a * x, a * y); }\n  Point operator / (double a) { return Point(x / a, y / a); }\n \n  double abs() { return sqrt(norm()); }\n  double norm() { return x * x + y * y; }\n   \n  bool operator < (const Point &p) const {\n    return x != p.x ? x < p.x : y < p.y;\n  }\n \n  bool operator == (const Point &p) const {\n    return fabs(x - p.x) < EPS && fabs(y - p.y) < EPS;\n  }\n};\n \ntypedef Point Vector; // ベクトルを表す構造体\n \nstruct Segment { // 線分を表す構造体\n  Point p1,p2;\n};\n \ntypedef Segment Line; // 直線を表す構造体\n \nclass Circle { // 円を表すクラス\npublic:\n  Point c;\n  double r;\n  Circle(Point c = Point(), double r = 0.0): c(c),r(r) {}\n};\ntypedef vector < Point > Polygon; // 多角形\n\ndouble dot(Vector a, Vector b) {\n  return a.x * b.x + a.y * b.y;\n}\n \ndouble cross(Vector a, Vector b) {\n  return a.x * b.y - a.y * b.x;\n}\n\nint H,R;\nPoint h[111];\nint U,M,S;\ndouble du,dm,ds;\nPoint u[11],m[11],s[11];\ndouble w[111],a[111];\n\nstatic const int COUNTER_CLOCKWISE = 1;\nstatic const int CLOCKWISE = -1;\nstatic const int ONLINE_BACK = 2;\nstatic const int ONLINE_FRONT = -2;\nstatic const int ON_SEGMENT = 0;\n \nint ccw(Point p0, Point p1, Point p2) {\n  Vector a = p1 - p0;\n  Vector b = p2 - p0;\n \n  if( cross(a,b) > EPS ) return COUNTER_CLOCKWISE;\n  if( cross(a,b) < -EPS ) return CLOCKWISE;\n  if( dot(a,b) < -EPS ) return ONLINE_BACK;\n  if( a.norm() < b.norm() ) return ONLINE_FRONT;\n                         \n  return ON_SEGMENT;\n}\n\nbool judge(Point p,int hn,int wn,double rad){\n  double length = sqrt((p.x-h[hn].x)*(p.x-h[hn].x)+(p.y-h[hn].y)*(p.y-h[hn].y));\n  if(length > a[wn]) return false;\n  Point p1,p2;\n  p1.x = a[wn]*cos((w[wn]-rad/2)*PI/180.0)+p.x;\n  p1.y = a[wn]*sin((w[wn]-rad/2)*PI/180.0)+p.y;\n  p2.x = a[wn]*cos((w[wn]+rad/2)*PI/180.0)+p.x;\n  p2.y = a[wn]*sin((w[wn]+rad/2)*PI/180.0)+p.y;\n  //cout<<p.x<<\" \"<<p.y<<\" \"<<p1.x<<\" \"<<p1.y<<\" \"<<p2.x<<\" \"<<p2.y<<endl;\n  //cout << ccw(p,p1,h[hn]) << \" \" << ccw(p,p2,h[hn]) << endl;\n  if(ccw(p,p1,h[hn]) == 1 && ccw(p,p2,h[hn]) == -1) return true;\n  return false;\n}\n\nint main(){\n  while(cin >> H >> R , H){\n    for(int i=0;i<H;i++) cin >> h[i].x >> h[i].y;\n    cin >> U >> M >> S >> du >> dm >> ds;\n    for(int i=0;i<U;i++) cin >> u[i].x >> u[i].y;\n    for(int i=0;i<M;i++) cin >> m[i].x >> m[i].y;\n    for(int i=0;i<S;i++) cin >> s[i].x >> s[i].y;\n    for(int i=0;i<R;i++) cin >> w[i] >> a[i];\n    Point T; T.x = 0; T.y = 0;\n    P cnt[111];\n    for(int i=0;i<111;i++){\n      cnt[i].first = 0;\n      cnt[i].second = -(i+1);\n    }\n    for(int i=0;i<H;i++){\n      for(int j=0;j<R;j++){\n\tif(judge(T,i,j,du)){\n\t  bool flg = true;\n\t  for(int k=0;k<U;k++){\n\t    if(judge(u[k],i,j,du)) {\n\t      flg = false;\n\t      break;\n\t    }\n\t  }\n\t  if(flg){\n\t    for(int k=0;k<M;k++){\n\t      if(judge(m[k],i,j,dm)) {\n\t\tflg = false;\n\t\tbreak;\n\t      }\n\t    }\n\t  }\n\t  if(flg){\n\t    for(int k=0;k<S;k++){\n\t      if(judge(s[k],i,j,ds)) {\n\t\tflg = false;\n\t\tbreak;\n\t      }\n\t    }\n\t  }\n\t  if(flg) {\n\t    cnt[i].first++;\n\t  }\n\t}\n      }\n    }\n    sort(cnt,cnt+H,greater<P>() );\n    int maxx = cnt[0].first;\n    int idx = 0;\n    if(cnt[0].first == 0) cout << \"NA\" << endl;\n    else {\n      while(maxx == cnt[idx].first){\n\tcout << -cnt[idx].second;\n\tif(cnt[idx+1].first == maxx) cout << \" \";\n\telse cout << endl;\n\tidx++;\n      }\n    }\n  }\n}"
  },
  {
    "language": "C++",
    "code": "#include <iostream>\n#include <algorithm>\n#include <vector>\n#include <complex>\n#include <cmath>\nusing namespace std;\n\ntypedef complex<double> P;\n\nconst double pi = acos(-1);\nconst double eps = 1e-4;\n\nbool equals(double a, double b) {\n  return abs(a-b) < eps;\n}\n\ndouble dot(P a, P b) {\n  return a.real()*b.real() + a.imag()*b.imag();\n}\n\ndouble cross(P a, P b) {\n  return a.real()*b.imag() - a.imag()*b.real();\n}\n\ninline double toRad(double d) {\n  return pi*d/180.0;\n}\n\nconst int WATASHIUME = 1<<0;\nconst int UME        = 1<<1;\nconst int MOMO       = 1<<2;\nconst int SAKURA     = 1<<3;\n\nstruct Tree {\n  P pos;\n  int type;\n  int d;\n};\n\nclass Field {\n  vector<Tree> trees;\npublic:\n  void add(const Tree &t) {\n    trees.push_back(t);\n  }\n\n  int reach(const int w, const int a, const P &p) {\n    int res = 0;\n    for(int i = 0; i < trees.size(); ++i) {\n      P m = p - trees[i].pos;\n      double dist = abs(m);\n      if(equals(dist, a) || dist < a) ; else continue;\n      P s = P( cos(toRad(w) - toRad(trees[i].d)/2.0),\n               sin(toRad(w) - toRad(trees[i].d)/2.0) );\n      P t = P( cos(toRad(w) + toRad(trees[i].d)/2.0),\n               sin(toRad(w) + toRad(trees[i].d)/2.0) );\n      double cs = cross(s, m);\n      double ct = cross(t, m);\n      if(  ( equals(cs, 0.0) || cs > 0.0 ) &&\n           ( equals(ct, 0.0) || ct < 0.0 )  ) {\n        res |= trees[i].type;\n      }\n    }\n    return res;\n  }\n};\n\nint main() {\n  int H, R;\n  int U, M, S, du, dm, ds;\n  while(cin >> H >> R && (H|R)) {\n    Field field;\n    vector<P> ps(H);\n    for(int i = 0; i < H; ++i) {\n      cin >> ps[i].real() >> ps[i].imag();\n    }\n    cin >> U >> M >> S >> du >> dm >> ds;\n    field.add((Tree){P(0,0), WATASHIUME, du});\n    for(int i = 0; i < U; ++i) {\n      P pos;\n      cin >> pos.real() >> pos.imag(); \n      field.add((Tree){pos, UME, du});\n    }\n    for(int i = 0; i < M; ++i) {\n      P pos;\n      cin >> pos.real() >> pos.imag(); \n      field.add((Tree){pos, MOMO, dm});\n    }\n    for(int i = 0; i < S; ++i) {\n      P pos;\n      cin >> pos.real() >> pos.imag(); \n      field.add((Tree){pos, SAKURA, ds});\n    }\n\n    int cnt[H];\n    fill(cnt, cnt+H, 0);\n\n    while(R--) {\n      int w, a;\n      cin >> w >> a;\n      for(int i = 0; i < H; ++i) {\n        if(field.reach(w,a,ps[i]) == WATASHIUME) {\n          cnt[i] += 1;\n        }\n      }\n    }\n\n    vector<pair<int,int> > v;\n    for(int i = 0; i < H; ++i) {\n      if(cnt[i] != 0)\n        v.push_back(make_pair(-cnt[i], i+1));\n    }\n    if(v.size()) {\n      sort(v.begin(), v.end());\n      for(int i = 0; i < v.size(); ++i) {\n        if(i && v[i].first != v[i-1].first) break;\n        if(i) cout << \" \";\n        cout << v[i].second;\n      }\n      cout << endl;\n    } else {\n      cout << \"NA\" << endl;\n    }\n  }\n  return 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include \"bits/stdc++.h\"\n#include<unordered_map>\n#include<unordered_set>\n#pragma warning(disable:4996)\nusing namespace std;\nusing ld = long double;\ntemplate<class T>\nusing Table = vector<vector<T>>;\nconst ld eps=1e-9;\n\n/* ??????????????¬ */\n\n#include <complex>\n\ntypedef long double ld;\ntypedef complex<ld> Point;\n#define REP(i,n) for(int i=0;i<(int)(n);i++)\n#define ALL(x) (x).begin(),(x).end()\n\n\nconst ld pi = acos(-1.0);\nconst ld dtop = pi / 180.;\nconst ld ptod = 1. / dtop;\n\nnamespace std {\n\tbool operator<(const Point &lhs, const Point &rhs) {\n\t\tif (lhs.real() < rhs.real() - eps) return true;\n\t\tif (lhs.real() > rhs.real() + eps) return false;\n\t\treturn lhs.imag() < rhs.imag();\n\t}\n}\n\n// ????????\\???\nPoint input_point() {\n\tld x, y;\n\tcin >> x >> y;\n\treturn Point(x, y);\n}\n\n// ????????????????????????\nbool eq(const ld a, const ld b) {\n\treturn (abs(a - b) < eps);\n}\n\n// ??????\nld dot(const Point& a, const Point& b) {\n\treturn real(conj(a) * b);\n}\n\n// ??????\nld cross(const Point& a, const Point& b) {\n\treturn imag(conj(a) * b);\n}\n\n// ??´????????????\nclass Line {\npublic:\n\tPoint a, b;\n\tLine() : a(Point(0, 0)), b(Point(0, 0)) {}\n\tLine(Point a, Point b) : a(a), b(b) {}\n\tPoint operator[](const int _num)const {\n\t\tif (_num == 0)return a;\n\t\telse if (_num == 1)return b;\n\t\telse {\n\t\t\tassert(false);\n\t\t\treturn Point();\n\t\t}\n\t}\n};\n\n// ????????????\nclass Circle {\npublic:\n\tPoint p;\n\tld r;\n\tCircle() : p(Point(0, 0)), r(0) {}\n\tCircle(Point p, ld r) : p(p), r(r) {}\n};\n\n// CCW\nint ccw(const Point& a, const Point &b, const Point &c) {\n\tconst Point nb(b - a);\n\tconst Point nc(c - a);\n\tif (cross(nb, nc) > eps) return 1;   // a,b,c??????????¨???¨?????????????????¶\n\tif (cross(nb, nc) < -eps) return -1; // a,b,c???????¨???¨?????????????????¶\n\tif (dot(nb, nc) < 0) return 2;       // c,a,b???????????´???????????¶\n\tif (norm(nb) < norm(nc)) return -2;  // a,b,c???????????´???????????¶\n\treturn 0;                          // a,c,b???????????´???????????¶\n}\n\n\n/* ???????????? */\n\n// ??´?????¨??´??????????????????\nbool isis_ll(const Line& l, const Line& m) {\n\treturn !eq(cross(l.b - l.a, m.b - m.a), 0);\n}\n\n// ??´?????¨?????????????????????\nbool isis_ls(const Line& l, const Line& s) {\n\treturn isis_ll(l, s) &&\n\t\t(cross(l.b - l.a, s.a - l.a) * cross(l.b - l.a, s.b - l.a) < eps);\n}\n\n// ????????¨?????????????????????\nbool isis_ss(const Line& s, const Line& t) {\n\treturn ccw(s.a, s.b, t.a) * ccw(s.a, s.b, t.b) <= 0 &&\n\t\tccw(t.a, t.b, s.a) * ccw(t.a, t.b, s.b) <= 0;\n}\n\n// ????????´????????????\nbool isis_lp(const Line& l, const Point& p) {\n\treturn (abs(cross(l.b - p, l.a - p)) < eps);\n}\n\n// ?????????????????????\nbool isis_sp(const Line& s, const Point& p) {\n\treturn (abs(s.a - p) + abs(s.b - p) - abs(s.b - s.a) < eps);\n}\n\n// ??????????¶?\nPoint proj(const Line &l, const Point& p) {\n\tld t = dot(p - l.a, l.a - l.b) / norm(l.a - l.b);\n\treturn l.a + t * (l.a - l.b);\n}\n\n// ??´?????¨??´????????????\nPoint is_ll(const Line &s, const Line& t) {\n\tPoint sv = s.b - s.a, tv = t.b - t.a;\n\tassert(cross(sv, tv) != 0);\n\treturn s.a + sv * cross(tv, t.a - s.a) / cross(tv, sv);\n}\n// ??´?????¨??´????????????\nvector<Point> is_ll2(const Line &s, const Line& t) {\n\tPoint sv = s.b - s.a, tv = t.b - t.a;\n\tif (cross(sv, tv) != 0)return vector<Point>(1, is_ll(s, t));\n\telse {\n\t\tvector<Point>ans;\n\t\tfor (int k = 0; k < 2; ++k) {\n\t\t\tif (isis_sp(s, t[k]) && find(ans.begin(), ans.end(), t[k]) == ans.end())ans.push_back(t[k]);\n\t\t\tif (isis_sp(t, s[k]) && find(ans.begin(), ans.end(), s[k]) == ans.end())ans.push_back(s[k]);\n\t\t}\n\t\treturn ans;\n\t}\n}\n// ????????¨???????????????\n//???????????£????????¨???????????¨assert(false)\nPoint is_ss(const Line &s, const Line& t) {\n\tif (isis_ss(s, t)) {\n\t\tfor (int k = 0; k < 2; ++k) {\n\t\t\tfor (int l = 0; l < 2; ++l) {\n\t\t\t\tif (s[k] == t[l])return s[k];\n\t\t\t}\n\t\t}\n\t\treturn is_ll(s, t);\n\t}\n\telse {\n\t\t//??????isis_ss?????????\n\t\tassert(false);\n\t\treturn Point(0, 0);\n\t}\n}\n// ????????¨???????????????\nvector<Point> is_ss2(const Line &s, const Line& t) {\n\tvector<Point> kouho(is_ll2(s, t));\n\tvector<Point>ans;\n\tfor (auto p : kouho) {\n\t\tif (isis_sp(s, p) && isis_sp(t, p))ans.emplace_back(p);\n\t}\n\treturn ans;\n}\n// ??´?????¨???????????¢\nld dist_lp(const Line& l, const Point& p) {\n\treturn abs(p - proj(l, p));\n}\n\n// ??´?????¨??´???????????¢\nld dist_ll(const Line& l, const Line& m) {\n\treturn isis_ll(l, m) ? 0 : dist_lp(l, m.a);\n}\n\n// ??´?????¨??????????????¢\nld dist_ls(const Line& l, const Line& s) {\n\treturn isis_ls(l, s) ? 0 : min(dist_lp(l, s.a), dist_lp(l, s.b));\n}\n\n// ????????¨???????????¢\nld dist_sp(const Line& s, const Point& p) {\n\tPoint r = proj(s, p);\n\treturn isis_sp(s, r) ? abs(r - p) : min(abs(s.a - p), abs(s.b - p));\n}\n\n// ????????¨??????????????¢\nld dist_ss(const Line& s, const Line& t) {\n\tif (isis_ss(s, t)) return 0;\n\treturn min({ dist_sp(s, t.a), dist_sp(s, t.b), dist_sp(t, s.a), dist_sp(t, s.b) });\n}\n\n\n//??´?????¨??´?????????????????????????????????\nLine bisection(const Line &s, const Line &t) {\n\tconst Point laglanju(is_ll(s, t));\n\tconst Point avec = !(abs(laglanju - s[0])<eps) ? s[0] - laglanju : s[1] - laglanju;\n\tconst Point bvec = !(abs(laglanju - t[0])<eps) ? t[0] - laglanju : t[1] - laglanju;\n\n\treturn Line(laglanju, laglanju + (abs(bvec)*avec + abs(avec)*bvec) / (abs(avec) + abs(bvec)));\n}\n\n\n//???????????´?????????????????????\n//???????????´??????????????§???????????¨????¢?????????¨?????????\nPoint  inner_center(const vector<Line>&ls) {\n\tvector<Point>vertics;\n\tfor (int i = 0; i <static_cast<int>(ls.size()); ++i) {\n\t\tvertics.push_back(is_ll(ls[i], ls[(i + 1) % 3]));\n\t}\n\tif (vertics[0] == vertics[1] || vertics[1] == vertics[2] || vertics[2] == vertics[0])return vertics[0];\n\tLine bi1(bisection(Line(vertics[0], vertics[1]), Line(vertics[0], vertics[2])));\n\tLine bi2(bisection(Line(vertics[1], vertics[2]), Line(vertics[1], vertics[0])));\n\tif (bi1[0] == bi2[0])return bi1[0];\n\telse {\n\t\treturn is_ll(bi1, bi2);\n\t}\n}\n\n//???????????´?????????????????????\n//???????????´??????????????§???????????¨????¢?????????¨?????????\nvector<Point>  ex_center(const vector<Line>&ls) {\n\tvector<Point>vertics;\n\tfor (int i = 0; i < static_cast<int>(ls.size()); ++i) {\n\t\tvertics.push_back(is_ll(ls[i], ls[(i + 1) % 3]));\n\t}\n\tif (abs(vertics[0] - vertics[1])<eps || abs(vertics[1] - vertics[2])<eps || (abs(vertics[2] - vertics[0])<eps))return vector<Point>();\n\tvector<Point>ecs;\n\tfor (int i = 0; i < 3; ++i) {\n\t\tLine bi1(bisection(Line(vertics[i], vertics[i] * 2.0l - vertics[(i + 2) % 3]), Line(vertics[i], vertics[(i + 1) % 3])));\n\t\tLine bi2(bisection(Line(vertics[(i + 1) % 3], vertics[(i + 1) % 3] * 2.0l - vertics[(i + 2) % 3]), Line(vertics[(i + 1) % 3], vertics[i])));\n\t\tecs.push_back(is_ll(bi1, bi2));\n\t}\n\treturn ecs;\n}\n\n\n//a,b:??????\n//c:????????§??????\n//???????????´?????????????????¢?????????????±??????????\nvector<Point>  same_dis(const vector<Line>&ls) {\n\tvector<Point>vertics;\n\tvertics.push_back(is_ll(ls[0], ls[2]));\n\tvertics.push_back(is_ll(ls[1], ls[2]));\n\n\tif (abs(vertics[0] - vertics[1]) < eps)return vector<Point>{vertics[0]};\n\tLine bis(bisection(ls[0], ls[1]));\n\tvector<Point>ecs;\n\n\tLine abi(bisection(Line(vertics[0], vertics[1]), ls[0]));\n\tecs.push_back(is_ll(bis, abi));\n\n\n\tLine bbi(bisection(Line(vertics[0], 2.l*vertics[0] - vertics[1]), ls[0]));\n\tecs.push_back(is_ll(bis, bbi));\n\n\treturn ecs;\n}\n/* ??? */\n\n// ?????¨????????????\nvector<Point> is_cc(const Circle& c1, const Circle& c2) {\n\tvector<Point> res;\n\tld d = abs(c1.p - c2.p);\n\tld rc = (d * d + c1.r * c1.r - c2.r * c2.r) / (2 * d);\n\tld dfr = c1.r * c1.r - rc * rc;\n\tif (abs(dfr) < eps) dfr = 0.0;\n\telse if (dfr < 0.0) return res; // no intersection\n\tld rs = sqrt(dfr);\n\tPoint diff = (c2.p - c1.p) / d;\n\tres.push_back(c1.p + diff * Point(rc, rs));\n\tif (dfr != 0.0) res.push_back(c1.p + diff * Point(rc, -rs));\n\treturn res;\n}\n\n//???????????????????????????\n//  0 => out\n//  1 => on\n//  2 => in\nint is_in_circle(const Circle &cir, const  Point& p) {\n\tld dis = abs(cir.p - p);\n\tif (dis > cir.r + eps)return 0;\n\telse if (dis < cir.r - eps)return 2;\n\telse return 1;\n}\n//???lc??????rc??????????????????\n//  0 => out\n//  1 => on\n//  2 => in\nint circle_in_circle(const Circle &lc, const  Circle&rc) {\n\tld dis = abs(lc.p - rc.p);\n\tif (dis < rc.r - lc.r - eps)return 2;\n\telse if (dis>rc.r - lc.r + eps)return 0;\n\telse return 1;\n}\n\n// ?????¨??´????????????\nvector<Point> is_lc(const Circle& c, const Line& l) {\n\tvector<Point> res;\n\tld d = dist_lp(l, c.p);\n\tif (d < c.r + eps) {\n\t\tld len = (d > c.r) ? 0.0 : sqrt(c.r * c.r - d * d); //safety;\n\t\tPoint nor = (l.a - l.b) / abs(l.a - l.b);\n\t\tres.push_back(proj(l, c.p) + len * nor);\n\t\tres.push_back(proj(l, c.p) - len * nor);\n\t}\n\treturn res;\n}\n\n// ?????¨??????????????¢\nvector<Point> is_sc(const Circle& c, const Line& l) {\n\tvector<Point> v = is_lc(c, l), res;\n\tfor (Point p : v)\n\t\tif (isis_sp(l, p)) res.push_back(p);\n\treturn res;\n}\n\n// ?????¨????????\\???\nvector<Line> tangent_cp(const Circle& c, const Point& p) {\n\tvector<Line> ret;\n\tPoint v = c.p - p;\n\tld d = abs(v);\n\tld l = sqrt(norm(v) - c.r * c.r);\n\tif (isnan(l)) { return ret; }\n\tPoint v1 = v * Point(l / d, c.r / d);\n\tPoint v2 = v * Point(l / d, -c.r / d);\n\tret.push_back(Line(p, p + v1));\n\tif (l < eps) return ret;\n\tret.push_back(Line(p, p + v2));\n\treturn ret;\n}\n\n// ?????¨????????\\???\nvector<Line> tangent_cc(const Circle& c1, const Circle& c2) {\n\tvector<Line> ret;\n\tif (abs(c1.p - c2.p) - (c1.r + c2.r) > -eps) {\n\t\tPoint center = (c1.p * c2.r + c2.p * c1.r) / (c1.r + c2.r);\n\t\tret = tangent_cp(c1, center);\n\t}\n\tif (abs(c1.r - c2.r) > eps) {\n\t\tPoint out = (-c1.p * c2.r + c2.p * c1.r) / (c1.r - c2.r);\n\t\tvector<Line> nret = tangent_cp(c1, out);\n\t\tret.insert(ret.end(), ALL(nret));\n\t}\n\telse {\n\t\tPoint v = c2.p - c1.p;\n\t\tv /= abs(v);\n\t\tPoint q1 = c1.p + v * Point(0, 1) * c1.r;\n\t\tPoint q2 = c1.p + v * Point(0, -1) * c1.r;\n\t\tret.push_back(Line(q1, q1 + v));\n\t\tret.push_back(Line(q2, q2 + v));\n\t}\n\treturn ret;\n}\n//??????????????????????????¢???\nld two_circle_area(const Circle&l, const Circle&r) {\n\tld dis = abs(l.p - r.p);\n\tif (dis > l.r + r.r)return 0;\n\telse if (dis + r.r < l.r) {\n\t\treturn r.r*r.r*pi;\n\t}\n\telse if (dis + l.r < r.r) {\n\t\treturn l.r*l.r*pi;\n\t}\n\telse {\n\t\tld ans = (l.r)*(l.r)*acos((dis*dis + l.r*l.r - r.r*r.r) / (2 * dis*l.r)) +\n\t\t\t(r.r)*(r.r)*acos((dis*dis + r.r*r.r - l.r*l.r) / (2 * dis*r.r)) -\n\t\t\tsqrt(4 * dis*dis*l.r*l.r - (dis*dis + l.r*l.r - r.r*r.r)*(dis*dis + l.r*l.r - r.r*r.r)) / 2;\n\t\treturn ans;\n\t}\n\n}\n\n/* ????§???¢ */\n\ntypedef vector<Point> Polygon;\n\n// ??¢???\nld area(const Polygon &p) {\n\tld res = 0;\n\tint n = p.size();\n\tREP(j, n) res += cross(p[j], p[(j + 1) % n]);\n\treturn res / 2;\n}\n\n// ????§???¢????????¢??????\nbool is_counter_clockwise(const Polygon &poly) {\n\tld angle = 0;\n\tint n = poly.size();\n\tREP(i, n) {\n\t\tPoint a = poly[i], b = poly[(i + 1) % n], c = poly[(i + 2) % n];\n\t\tangle += arg((c - b) / (b - a));\n\t}\n\treturn angle > eps;\n}\n\n// ??????????????????\n//  0 => out\n//  1 => on\n//  2 => in\nint is_in_polygon(const Polygon &poly, const  Point& p) {\n\tld angle = 0;\n\tint n = poly.size();\n\tREP(i, n) {\n\t\tPoint a = poly[i], b = poly[(i + 1) % n];\n\t\tif (isis_sp(Line(a, b), p)) return 1;\n\t\tangle += arg((b - p) / (a - p));\n\t}\n\treturn eq(angle, 0) ? 0 : 2;\n}\n//??????????????????2?????????\nenum { OUT, ON, IN };\nint convex_contains(const Polygon &P, const Point &p) {\n\tconst int n = P.size();\n\tPoint g = (P[0] + P[n / 3] + P[2 * n / 3]) / 3.0l; // inner-point\n\tint a = 0, b = n;\n\twhile (a + 1 < b) { // invariant: c is in fan g-P[a]-P[b]\n\t\tint c = (a + b) / 2;\n\t\tif (cross(P[a] - g, P[c] - g) > 0) { // angle < 180 deg\n\t\t\tif (cross(P[a] - g, p - g) > 0 && cross(P[c] - g, p - g) < 0) b = c;\n\t\t\telse                                                  a = c;\n\t\t}\n\t\telse {\n\t\t\tif (cross(P[a] - g, p - g) < 0 && cross(P[c] - g, p - g) > 0) a = c;\n\t\t\telse                                                  b = c;\n\t\t}\n\t}\n\tb %= n;\n\tif (cross(P[a] - p, P[b] - p) < 0) return 0;\n\tif (cross(P[a] - p, P[b] - p) > 0) return 2;\n\treturn 1;\n}\n\n// ??????\n// ???????????????????????¨????????????????????§??¨???\nPolygon convex_hull(vector<Point> ps) {\n\tint n = ps.size();\n\tint k = 0;\n\tsort(ps.begin(), ps.end());\n\tPolygon ch(2 * n);\n\tfor (int i = 0; i < n; ch[k++] = ps[i++])\n\t\twhile (k >= 2 && ccw(ch[k - 2], ch[k - 1], ps[i]) <= 0) --k;\n\tfor (int i = n - 2, t = k + 1; i >= 0; ch[k++] = ps[i--])\n\t\twhile (k >= t && ccw(ch[k - 2], ch[k - 1], ps[i]) <= 0) --k;\n\tch.resize(k - 1);\n\treturn ch;\n}\n\n\n\n// ????????????\nvector<Polygon> convex_cut(const Polygon &ps, const Line& l) {\n\tint n = ps.size();\n\tPolygon Q;\n\tPolygon R;\n\tREP(i, n) {\n\t\tPoint A = ps[i], B = ps[(i + 1) % n];\n\t\tLine m = Line(A, B);\n\t\tif (ccw(l.a, l.b, A) != -1) Q.push_back(A);\n\t\tif (ccw(l.a, l.b, A) != 1) R.push_back(A);\n\t\tif (ccw(l.a, l.b, A) * ccw(l.a, l.b, B) < 0 && isis_ll(l, m)) {\n\t\t\tQ.push_back(is_ll(l, m));\n\t\t\tR.push_back(is_ll(l, m));\n\t\t}\n\t}\n\tconst vector<Polygon>polys{ Q,R };\n\treturn polys;\n}\n\n\n/* ??¢??¬??????????????? */\nvoid add_point(vector<Point> &ps, const Point p) {\n\tfor (Point q : ps) if (abs(q - p) < eps) return;\n\tps.push_back(p);\n}\n\ntypedef int Weight;\nstruct Edge {\n\tint src, dst;\n\tWeight weight;\n\tEdge(int src, int dst, Weight weight) :\n\t\tsrc(src), dst(dst), weight(weight) { }\n};\n\ntypedef vector<Edge> Edges;\ntypedef vector<Edges> Graph;\n\nvoid add_edge(Graph &g, const int from, const int to, const Weight weight) {\n\tg[from].push_back(Edge{ from, to, weight });\n}\n\nGraph segment_arrangement(const vector<Line> &s, const vector<Point> &p) {\n\tint n = p.size(), m = s.size();\n\tGraph g(n);\n\tREP(i, m) {\n\t\tvector<pair<ld, int>> vec;\n\t\tREP(j, n) if (isis_sp(s[i], p[j]))\n\t\t\tvec.emplace_back(abs(s[i].a - p[j]), j);\n\t\tsort(ALL(vec));\n\t\tREP(j, vec.size() - 1) {\n\t\t\tint from = vec[j].second, to = vec[j + 1].second;\n\t\t\tadd_edge(g, from, to, static_cast<Weight>(abs(p[from] - p[to])));\n\t\t}\n\t}\n\treturn g;\n}\nGraph sennbunn_arrangement(const vector<Line>&s) {\n\tvector<Point>crss;\n\tfor (int i = 0; i < static_cast<int>(s.size()); ++i) {\n\t\tfor (int j = i + 1; j < static_cast<int>(s.size()); ++j) {\n\t\t\tif (isis_ss(s[i], s[j])) {\n\t\t\t\tcrss.push_back(is_ll(s[i], s[j]));\n\t\t\t}\n\t\t}\n\t}\n\tfor (int i = 0; i <static_cast<int>(s.size()); ++i) {\n\t\tcrss.push_back(s[i][0]);\n\t\tcrss.push_back(s[i][1]);\n\t}\n\treturn segment_arrangement(s, crss);\n}\n\n//Graph circle_arrangement(const vector<Circle> &c, const vector<Point> &p) {\n//\tint n = p.size(), m = c.size();\n//\tGraph g(n);\n//\tREP(i, m) {\n//\t\tvector<pair<ld, int>> vec;\n//\t\tREP(j, n) if (abs(abs(c[i].p - p[j]) - c[i].r) < eps)\n//\t\t\tvec.emplace_back(arg(c[i].p - p[j]), j);\n//\t\tsort(ALL(vec));\n//\t\tREP(j, vec.size() - 1) {\n//\t\t\tint from = vec[j].second, to = vec[j + 1].second;\n//\t\t\tld angle = vec[j + 1].first - vec[j].first;\n//\t\t\tadd_edge(g, from, to, static_cast<Weight>(angle * c[i].r));\n//\t\t}\n//\t\tif (vec.size() >= 2) {\n//\t\t\tint from = vec.back().second, to = vec.front().first;\n//\t\t\tld angle = vec.front().first - vec.back().first;\n//\t\t\tadd_edge(g, from, to, static_cast<Weight>(angle * c[i].r));\n//\t\t}\n//\t}\n//\treturn g;\n//}\n\n\n/* ????????°?????? */\n\n// ?????????????????¢?????¢??¬??????????????????????????????????????°???????????????\n// ?????´?????????????¨?????????§????????´????????????????¨?????????§???????????????\n// ?????° polygon ??????vector<int> ??§??¨?????????????§???¢???????????§?????????\n// vector<int> ??§??¨????????? ????§???¢???i???????????????????????????????????????p????????????????????§?????????\nvector<vector<int>> polygon;\nvector<int> seg2p[1024][1024];\n\n//Graph dual_graph(const vector<Line> &s, const vector<Point> &p) {\n//\tint N = p.size();\n//\tpolygon.clear();\n//\tREP(i, 1024) REP(j, 1024) seg2p[i][j].clear();\n//\tvector<vector<tuple<ld, int, bool>>> tup(N);\n//\tREP(i, s.size()) {\n//\t\tint a = -1, b = -1;\n//\t\tREP(j, N) if (abs(s[i].a - p[j]) < eps) a = j;\n//\t\tREP(j, N) if (abs(s[i].b - p[j]) < eps) b = j;\n//\t\tassert(a >= 0 && b >= 0);\n//\t\ttup[a].emplace_back(arg(s[i].b - s[i].a), b, false);\n//\t\ttup[b].emplace_back(arg(s[i].a - s[i].b), a, false);\n//\t}\n//\tREP(i, N) sort(ALL(tup[i]));\n//\tREP(i, N) {\n//\t\tREP(j, tup[i].size()) {\n//\t\t\tld angle; int pos = j, from = i, to; bool flag;\n//\t\t\ttie(angle, to, flag) = tup[i][j];\n//\t\t\tif (flag) continue;\n//\t\t\tvector<int> ps;\n//\t\t\twhile (!flag) {\n//\t\t\t\tps.push_back(from);\n//\t\t\t\tget<2>(tup[from][pos]) = true;\n//\t\t\t\tseg2p[from][to].push_back(polygon.size());\n//\t\t\t\tseg2p[to][from].push_back(polygon.size());\n//\t\t\t\tangle += pi + eps;\n//\t\t\t\tif (angle > pi) angle -= 2 * pi;\n//\t\t\t\tauto it = lower_bound(ALL(tup[to]), make_tuple(angle, 0, false));\n//\t\t\t\tif (it == tup[to].end()) it = tup[to].begin();\n//\t\t\t\tfrom = to; tie(angle, to, flag) = *it;\n//\t\t\t\tpos = it - tup[from].begin();\n//\t\t\t}\n//\t\t\tpolygon.push_back(ps);\n//\t\t}\n//\t}\n//\tGraph g(polygon.size());\n//\tREP(i, N) REP(j, i) {\n//\t\tif (seg2p[i][j].size() == 2) {\n//\t\t\tint from = seg2p[i][j][0], to = seg2p[i][j][1];\n//\t\t\tg[from].push_back(Edge{ from, to });\n//\t\t\tg[to].push_back(Edge{ to, from });\n//\t\t}\n//\t}\n//\treturn g;\n//}\n\nstruct flo {\n\tPoint p;\n\tld the;\n};\nbool check(const flo&f, const Point p,const ld len,const ld theta) {\n\tconst ld dis = abs(f.p - p);\n\tif (dis-eps > len) {\n\t\treturn false;\n\t}\n\telse {\n\t\tconst ld kaku = atan2(p.imag() - f.p.imag(), p.real() - f.p.real());\n\t\tld sa = abs(kaku - theta);\n\t\tsa = min(sa, 2 * pi - sa);\n\t\tif (sa < f.the / 2)return true;\n\t\telse return false;\n\t}\n}\nint main() {\n\twhile (1) {\n\t\tvector<Point>houses;\n\t\tint H, R; cin >> H >> R;\n\t\tif (!H)break;\n\t\tfor (int i = 0; i < H; ++i) {\n\t\t\tint x, y; cin >> x >> y;\n\t\t\thouses.emplace_back(x, y);\n\t\t}\n\t\tint U, M, S;ld du, dm, ds;  cin >> U >> M >> S >> du >> dm >> ds;\n\t\tdu *= dtop;\n\t\tdm *= dtop;\n\t\tds *= dtop;\n\t\tvector<flo>flowers;\n\t\tfor (int i = 0; i < U; ++i) {\n\t\t\tint x, y; cin >> x >> y;\n\t\t\tflowers.push_back(flo{ Point(x,y),du });\n\t\t}\n\t\tfor (int i = 0; i < M; ++i) {\n\t\t\tint x, y; cin >> x >> y;\n\t\t\tflowers.push_back(flo{ Point(x,y),dm });\n\t\t}\n\t\tfor (int i = 0; i < S; ++i) {\n\t\t\tint x, y; cin >> x >> y;\n\t\t\tflowers.push_back(flo{ Point(x,y),ds });\n\t\t}\n\t\tflo myflower{ Point(0,0),du };\n\t\tint ans = 0;\n\t\tvector<int>nums(H);\n\t\tfor (int i = 0; i < R; ++i) {\n\t\t\tld w, a; cin >> a >> w;\n\t\t\ta *= dtop;\n\t\t\tfor (int h = 0; h < H; ++h) {\n\t\t\t\tPoint p(houses[h]);\n\t\t\t\tif (check(myflower, p, w, a)) {\n\n\t\t\t\t\tbool aok = true;\n\t\t\t\t\tfor (auto f : flowers) {\n\t\t\t\t\t\tif (check(f, p, w, a)) {\n\t\t\t\t\t\t\taok = false;\n\t\t\t\t\t\t\tbreak;\n\t\t\t\t\t\t}\n\t\t\t\t\t}\n\t\t\t\t\tif (aok) {\n\t\t\t\t\t\tnums[h]++;\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t\tint amax = *max_element(nums.begin(), nums.end());\n\t\tif (amax) {\n\t\t\tvector<int>anss;\n\t\t\tfor (int i = 0; i < H; ++i) {\n\t\t\t\tif (amax == nums[i]) {\n\t\t\t\t\tanss.push_back(i+1);\n\t\t\t\t}\n\t\t\t}\n\t\t\tfor (int i = 0; i < anss.size(); ++i) {\n\t\t\t\tcout << anss[i];\n\t\t\t\tif (i != anss.size() - 1)cout << \" \";\n\t\t\t\telse cout << endl;\n\t\t\t}\n\t\t}\n\t\telse {\n\t\t\tcout << \"NA\" << endl;\n\t\t}\n\t}\n\treturn 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include <iostream>\n#include <cstdio>\n#include <cmath>\n#include <vector>\n#include <map>\n#include <stack>\n#include <queue>\n#include <algorithm>\n#include <set>\n#include <cstring>\n\n#define FOR(i,a,b) for(int i=(a);i<(b);i++)\n#define REP(i,j) FOR(i,0,j)\n#define mp std::make_pair\n\ntypedef long long ll;\ntypedef unsigned long long ull;\n\nconst int INF = 1001001001;\n\n// S N E W(南北東西)\nconst int dx[8] = {0, 0, 1, -1, 1, 1, -1, -1}, dy[8] = {1, -1, 0, 0, 1, -1, 1, -1};\n\nstruct P{\n    P(){}\n    P(double _r, double _i):r(_r), i(_i){}\n    void real(const double& v){r = v;}\n    void imag(const double& v){i = v;}\n    double r, i;\n};\n\ndouble real(const P& p){return p.r;}\ndouble imag(const P& p){return p.i;}\ndouble norm(const P& p){double r = real(p), i = imag(p); return r * r + i * i;}\ndouble dist(const P& p){return std::sqrt(norm(p));}\n\nP operator+(const P& lhs, const P& rhs){\n    return P(real(lhs)+real(rhs), imag(lhs)+imag(rhs));\n}\nP operator-(const P& lhs, const P& rhs){\n    return P(real(lhs)-real(rhs), imag(lhs)-imag(rhs));\n}\nP operator-(const P& p){\n    return P(-real(p), -imag(p));\n}\n\ndouble cross(const P& lhs, const P& rhs){\n    return real(lhs)*imag(rhs) - imag(lhs)*real(rhs);\n}\n\ndouble dot(const P& lhs, const P& rhs){\n    return real(lhs)*real(rhs) + imag(lhs)*imag(rhs);\n}\n\nint H, R, U, M, S;\ndouble du, dm, ds;\nP hs[100], us[10], ms[10], ss[10];\n\nbool can(P home, P flower, double d, P wind){\n    if(dist(home-flower) > imag(wind)){return false;}\n    P center;\n    center.real(imag(wind) * std::cos(real(wind)));\n    center.imag(imag(wind) * std::sin(real(wind)));\n    double s = cross(center, home-flower) / dist(center) / dist(home-flower),\n        c = dot(center, home-flower) / dist(center) / dist(home-flower);\n    if((c < 0.0f && d > 90.0f || c > 0.0f) && std::abs(s) < std::sin(M_PI / 180.0f * d)){\n        return true;\n    }\n    return false;\n}\n\nint main(){\n    while(std::cin >> H >> R, H || R){\n        REP(i, H){\n            double x, y;\n            std::cin >> x >> y;\n\n            hs[i].real(x); hs[i].imag(y);\n        }\n\n        std::cin >> U >> M >> S >> du >> dm >> ds;\n        REP(i, U){\n            double x, y;\n            std::cin >> x >> y;\n\n            us[i].real(x); us[i].imag(y);\n        }\n        REP(i, M){\n            double x, y;\n            std::cin >> x >> y;\n\n            ms[i].real(x); ms[i].imag(y);\n        }\n        REP(i, S){\n            double x, y;\n            std::cin >> x >> y;\n\n            ss[i].real(x); ss[i].imag(y);\n        }\n\n        P origin(0.0f, 0.0f);\n        int counter[100];\n        memset(counter, 0, sizeof(counter));\n        REP(i, R){\n            double x, y;\n            std::cin >> x >> y;\n            P wind(x, y);\n\n            REP(k, H){\n                bool f = can(hs[k], origin, du, wind),\n                    g = true;\n\n                REP(j, U){\n                    g = g && !can(hs[k], us[j], du, wind);\n                }\n                REP(j, M){\n                    g = g && !can(hs[k], ms[j], dm, wind);\n                }\n                REP(j, S){\n                    g = g && !can(hs[k], ss[j], ds, wind);\n                }\n\n                if(f && g){counter[k] += 1;}\n            }\n        }\n\n        int maxDays = 0;\n        REP(i, H){\n            maxDays = std::max(maxDays, counter[i]);\n        }\n\n        if(maxDays == 0){\n            puts(\"NA\");\n        }else{\n            std::vector<int> indices;\n            REP(i, H){\n                if(counter[i] == maxDays){indices.push_back(i+1);}\n            }\n\n            REP(i, (int)indices.size()){\n                if(i == (int)indices.size() - 1){printf(\"%d\\n\", indices[i]);}\n                else{printf(\"%d \", indices[i]);}\n            }\n        }\n    }\n}"
  },
  {
    "language": "C++",
    "code": "#include <iostream>\n#include <algorithm>\n#include <vector>\n#include <complex>\n#include <cmath>\nusing namespace std;\n\ntypedef complex<double> P;\n\nconst double pi = acos(-1);\nconst double eps = 1e-8;\n\nbool equals(double a, double b) {\n  return abs(a-b) < eps;\n}\n\ndouble dot(P a, P b) {\n  return a.real()*b.real() + a.imag()*b.imag();\n}\n\ndouble cross(P a, P b) {\n  return a.real()*b.imag() - a.imag()*b.real();\n}\n\ninline double toRad(double d) {\n  return pi*d/180.0;\n}\n\nconst int WATASHIUME = 1<<0;\nconst int UME        = 1<<1;\nconst int MOMO       = 1<<2;\nconst int SAKURA     = 1<<3;\n\nstruct Tree {\n  P pos;\n  int type;\n  int d;\n};\n\nclass Field {\n  vector<Tree> trees;\npublic:\n  void add(const Tree &t) {\n    trees.push_back(t);\n  }\n\n  int reach(const int w, const int a, const P &p) {\n    int res = 0;\n    for(int i = 0; i < trees.size(); ++i) {\n      P m = p - trees[i].pos;\n      double dist = abs(m);\n      if(equals(dist, a) || dist < a) ; else continue;\n      P s = P( cos(toRad(w) - toRad(trees[i].d)/2.0),\n               sin(toRad(w) - toRad(trees[i].d)/2.0) );\n      P t = P( cos(toRad(w) + toRad(trees[i].d)/2.0),\n               sin(toRad(w) + toRad(trees[i].d)/2.0) );\n      if(cross(s, m) > eps && cross(t, m) < -eps) {\n        res |= trees[i].type;\n      }\n    }\n    return res;\n  }\n};\n\nint main() {\n  int H, R;\n  int U, M, S, du, dm, ds;\n  while(cin >> H >> R && (H|R)) {\n    Field field;\n    vector<P> ps(H);\n    for(int i = 0; i < H; ++i) {\n      cin >> ps[i].real() >> ps[i].imag();\n    }\n    cin >> U >> M >> S >> du >> dm >> ds;\n    field.add((Tree){P(0,0), WATASHIUME, du});\n    for(int i = 0; i < U; ++i) {\n      P pos;\n      cin >> pos.real() >> pos.imag(); \n      field.add((Tree){pos, UME, du});\n    }\n    for(int i = 0; i < M; ++i) {\n      P pos;\n      cin >> pos.real() >> pos.imag(); \n      field.add((Tree){pos, MOMO, dm});\n    }\n    for(int i = 0; i < S; ++i) {\n      P pos;\n      cin >> pos.real() >> pos.imag(); \n      field.add((Tree){pos, SAKURA, ds});\n    }\n\n    int cnt[H], con[H];\n    fill(cnt, cnt+H, 0);\n    fill(con, con+H, 0);\n\n    while(R--) {\n      int w, a;\n      cin >> w >> a;\n      for(int i = 0; i < H; ++i) {\n        if(field.reach(w,a,ps[i]) == WATASHIUME) {\n          con[i] += 1;\n        } else {\n          con[i] = 0;\n        }\n        cnt[i] = max(cnt[i], con[i]);\n      }\n    }\n\n    vector<pair<int,int> > v;\n    for(int i = 0; i < H; ++i) {\n      if(cnt[i] != 0)\n        v.push_back(make_pair(-cnt[i], i+1));\n    }\n    if(v.size()) {\n      sort(v.begin(), v.end());\n      for(int i = 0; i < v.size(); ++i) {\n        if(i && v[i].first != v[i-1].first) break;\n        if(i) cout << \" \";\n        cout << v[i].second;\n      }\n      cout << endl;\n    } else {\n      cout << \"NA\" << endl;\n    }\n  }\n  return 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include <cstdio>\n#include <cstdlib>\n#include <cmath>\n#include <cstring>\n\n#include <iostream>\n#include <string>\n#include <algorithm>\n#include <vector>\n#include <queue>\n#include <stack>\n#include <map>\n#include <set>\n\n#include <functional>\n#include <cassert>\n\ntypedef long long ll;\nusing namespace std;\n\n#define debug(x) cerr << #x << \" = \" << x << endl;\n\n\n#define mod 1000000007 //1e9+7(prime number)\n#define INF 1000000000 //1e9\n#define LLINF 2000000000000000000LL //2e18\n#define SIZE 10000\n\n#define eps 1e-8\n\nbool is_ok(int hx,int hy, int tx, int ty, int td,int a,int w){\n\n  int dx = hx - tx;\n  int dy = hy - ty;\n\n  if(a*a < dx*dx + dy*dy) return false;\n\n  double rad = atan((double)dy/dx);\n\n  if(rad < 0){\n    rad += M_PI;\n  }\n  \n  if(dy < 0){\n    rad += M_PI;\n  }\n\n  rad = rad/M_PI * 180;\n  \n  rad += 180 - w;\n  w = 180;\n\n  if(rad >= 360) rad -= 360;\n    \n  return w - td/2.0 - eps < rad && rad < w + td/2.0 + eps;\n}\n\nbool calc(){\n  int h,r,t;\n  int hx[SIZE],hy[SIZE];\n  int u,m,s,du,dm,ds;\n  int tx[SIZE],ty[SIZE],td[SIZE];\n  int w[SIZE],a[SIZE];\n  \n  scanf(\"%d%d\",&h,&r);\n\n  if(h==0) return false;\n\n  for(int i=0;i<h;i++){\n    scanf(\"%d%d\",hx+i,hy+i);\n  }\n\n  scanf(\"%d%d%d%d%d%d\",&u,&m,&s,&du,&dm,&ds);\n\n  t = u+m+s;\n  \n  for(int i=0;i<u;i++){\n    scanf(\"%d%d\",tx+i,ty+i);\n    td[i] = du;\n  }\n\n  for(int i=u;i<u+m;i++){\n    scanf(\"%d%d\",tx+i,ty+i);\n    td[i] = dm;\n  }\n\n  for(int i=u+m;i<u+s+m;i++){\n    scanf(\"%d%d\",tx+i,ty+i);\n    td[i] = ds;\n  }\n\n  for(int i=0;i<r;i++){\n    scanf(\"%d%d\",w+i,a+i);\n  }\n\n  int max_d = 0;\n  int ans[SIZE] = {};\n\n  for(int i=0;i<h;i++){\n\n    for(int j=0;j<r;j++){\n      bool flag = true;\n\n      for(int k=0;k<t;k++){\n        if(is_ok(hx[i],hy[i],tx[k],ty[k],td[k],a[j],w[j])) flag = false;\n      }\n\n      if(flag && is_ok(hx[i],hy[i],0,0,du,a[j],w[j])) ans[i]++;\n    }\n  }\n  \n  for(int i=0;i<h;i++)\n    max_d = max(max_d,ans[i]);\n\n  if(max_d > 0){\n  \n    bool flag1 = false;\n    \n    for(int i=0;i<h;i++){\n      if(max_d == ans[i]){\n        if(flag1) printf(\" \");\n        flag1 = true;\n        printf(\"%d\",i+1);\n      }\n    }\n    \n    printf(\"\\n\");\n  }else{\n    puts(\"NA\");\n  }\n  \n  return true;\n}\n  \n\nint main(){\n\n  while(calc());\n  \n  return 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include <cstdio>\n#include <iostream>\n#include <sstream>\n#include <fstream>\n#include <iomanip>\n#include <algorithm>\n#include <cmath>\n#include <string>\n#include <vector>\n#include <list>\n#include <queue>\n#include <stack>\n#include <set>\n#include <map>\n#include <bitset>\n#include <numeric>\n#include <climits>\n#include <cfloat>\nusing namespace std;\n\nconst double PI = acos(-1.0);\n\nclass Point\n{\npublic:\n    double y, x;\n    Point(){\n        y = x = 0.0;\n    }\n    Point(double y0, double x0){\n        y = y0;\n        x = x0;\n    }\n    Point operator+(const Point& p) const{\n        return Point(y + p.y, x + p.x);\n    }\n    Point operator-(const Point& p) const{\n        return Point(y - p.y, x - p.x);\n    }\n    Point operator*(double a) const{\n        return Point(y * a, x * a);\n    }\n    Point operator/(double a) const{\n        return Point(y / a, x / a);\n    }\n    double length() const{\n        return sqrt(y * y + x * x);\n    }\n    double dist(const Point& p) const{\n        return sqrt(pow(y - p.y, 2) + pow(x - p.x, 2));\n    }\n    double dot(const Point& p) const{\n        return y * p.y + x * p.x; // |a|*|b|*cos慮\n    }\n    double cross(const Point& p) const{\n        return x * p.y - y * p.x; // |a|*|b|*sin慮\n    }\n};\n\nbool check(Point& h, vector<Point>& t, double angle, double dir, double len)\n{\n    int m = t.size();\n\n    for(int i=0; i<m; ++i){\n        if(h.dist(t[i]) > len)\n            continue;\n\n        double theta = atan2(h.y - t[i].y, h.x - t[i].x);\n        for(int j=-1; j<=1; ++j){\n            if(dir - angle/2 + 2*PI*j < theta && theta < dir + angle/2 + 2*PI*j)\n                return true;\n        }\n    }\n\n    return false;\n}\n\nint main()\n{\n    for(;;){\n        int n, r;\n        cin >> n >> r;\n        if(n == 0)\n            return 0;\n\n        vector<Point> h(n);\n        for(int i=0; i<n; ++i)\n            cin >> h[i].x >> h[i].y;\n\n        vector<int> m(3);\n        vector<double> angle(3);\n        for(int i=0; i<3; ++i)\n            cin >> m[i];\n        for(int i=0; i<3; ++i){\n            cin >> angle[i];\n            angle[i] *= PI / 180;\n        }\n\n        vector<vector<Point> > t(3);\n        for(int i=0; i<3; ++i){\n            t[i].resize(m[i]);\n            for(int j=0; j<m[i]; ++j)\n                cin >> t[i][j].x >> t[i][j].y;\n        }\n\n        vector<double> dir(r), len(r);\n        for(int i=0; i<r; ++i){\n            cin >> dir[i] >> len[i];\n            dir[i] *= PI / 180;\n        }\n\n        vector<int> ret;\n        int maxDay = 1;\n        for(int i=0; i<n; ++i){\n            int day = 0;\n            for(int j=0; j<r; ++j){\n                bool ok = true;\n                for(int k=0; k<3; ++k){\n                    if(check(h[i], t[k], angle[k], dir[j], len[j]))\n                        ok = false;\n                }\n\n                vector<Point> my(1, Point(0, 0));\n                if(ok && check(h[i], my, angle[0], dir[j], len[j]))\n                    ++ day;\n            }\n\n            if(day > maxDay){\n                ret.assign(1, i+1);\n                maxDay = day;\n            }else if(day == maxDay){\n                ret.push_back(i+1);\n            }\n        }\n\n        if(ret.empty()){\n            cout << \"NA\" << endl;\n        }else{\n            cout << ret[0];\n            for(unsigned i=1; i<ret.size(); ++i)\n                cout << ' ' << ret[i];\n            cout << endl;\n        }\n    }\n}"
  },
  {
    "language": "C++",
    "code": "#include<bits/stdc++.h>\n\n#define REP(i,s,n) for(int i=s;i<n;i++)\n#define rep(i,n) REP(i,0,n)\n#define EPS (1e-7)\n#define COUNTER_CLOCKWISE 1\n#define CLOCKWISE -1 \n#define ONLINE_BACK 2\n#define ONLINE_FRONT -2\n#define ON_SEGMENT 0\n#define equals(a,b) (fabs((a)-(b)) < EPS)\n\nusing namespace std;\n\nconst int IINF = INT_MAX;\n\n//\nclass Point{\npublic:\n  double x,y;\n\n  Point(double x = -IINF,double y = -IINF): x(x),y(y){}\n\n  Point operator + (Point p){return Point(x+p.x,y+p.y);}\n  Point operator - (Point p){return Point(x-p.x,y-p.y);}\n  Point operator * (double a){return Point(a*x,a*y);}\n  Point operator / (double a){return Point(x/a,y/a);}\n  Point operator * (Point a){ return Point(x * a.x - y * a.y, x * a.y + y * a.x); }\n\n  bool operator < (const Point& p) const{ return !equals(x,p.x)?x<p.x:y<p.y; }\n\n  bool operator == (const Point& p)const{ return fabs(x-p.x) < EPS && fabs(y-p.y) < EPS; }\n\n};\n\nstruct Segment{\n  Point p1,p2;\n  Segment(Point p1 = Point(),Point p2 = Point()):p1(p1),p2(p2){}\n  bool operator == (const Segment& p)const { return p.p1 == p1 && p.p2 == p2; }\n};\n\ntypedef Point Vector;\ntypedef Segment Line;\ntypedef vector<Point> Polygon;\n\nostream& operator << (ostream& os,const Point& a){ os << \"(\" << a.x << \",\" << a.y << \")\"; }\n\nostream& operator << (ostream& os,const Segment& a){ os << \"( \" << a.p1 << \" , \" << a.p2 << \" )\"; }\n\ndouble dot(Point a,Point b){ return a.x*b.x + a.y*b.y; }\n\ndouble cross(Point a,Point b){ return a.x*b.y - a.y*b.x; }\n\ndouble norm(Point a){ return a.x*a.x+a.y*a.y; }\n\ndouble abs(Point a){ return sqrt(norm(a)); }\n\n//rad は角度をラジアンで持たせること\nPoint rotate(Point a,double rad){ return Point(cos(rad)*a.x - sin(rad)*a.y,sin(rad)*a.x + cos(rad)*a.y); }\n\n// 度をラジアンに変換\ndouble toRad(double agl){ return agl*M_PI/180.0; }\n\n// a => prev, b => cur, c=> next\n// prev から cur へ行って next へ行く際の角度を求める\ndouble getArg(Point a,Point b,Point c){\n  double arg1 = atan2(b.y-a.y,b.x-a.x);\n  double arg2 = atan2(c.y-b.y,c.x-b.x);\n  double arg = fabs( arg1 - arg2 );\n  while( arg > M_PI ) arg -= 2.0 * M_PI;\n  return fabs(arg);\n}\n\nint ccw(Point p0,Point p1,Point p2){\n  Point a = p1-p0;\n  Point b = p2-p0;\n  if(cross(a,b) > EPS)return COUNTER_CLOCKWISE;\n  if(cross(a,b) < -EPS)return CLOCKWISE;\n  if(dot(a,b) < -EPS)return ONLINE_BACK;\n  if(norm(a) < norm(b))return ONLINE_FRONT;\n  return ON_SEGMENT;\n}\n\n//\n\nconst int MAX_N = 110;\nint N,M,Ume,Momo,SakuraHappyInnovation,counter[MAX_N],limit[3];\nPoint ps[MAX_N],p[3][20];\ndouble d[3],w[110],a[110];\n\nbool LT(double A,double B)  { return !equals(A,B) && A < B; }\nbool LTE(double A,double B) { return  equals(A,B) || A < B; }\n\nbool inside(Point h,Point t,double ta,double tw,double td){\n  double rad_w = toRad(tw), rad_d = toRad(td/2.0);\n  Point tmp = Point(ta*cos(rad_w),ta*sin(rad_w));\n  Point alpha = rotate(tmp,-rad_d) + t;\n  Point beta  = rotate(tmp,rad_d)  + t;\n  int res_ccw = ccw(t,alpha,h);\n  bool res1 = ( res_ccw == COUNTER_CLOCKWISE || res_ccw == ON_SEGMENT || res_ccw == ONLINE_BACK || res_ccw == ONLINE_FRONT ) ;\n  res_ccw = ccw(t,beta,h);\n  bool res2 = ( res_ccw == CLOCKWISE || res_ccw == ON_SEGMENT || res_ccw == ONLINE_BACK || res_ccw == ONLINE_FRONT ) ;\n  double dist = abs(h-t);\n  bool res3 = LTE(dist,ta);\n  return res1 && res2 && res3;\n}\n\ninline void compute(){\n  rep(i,N) counter[i] = 0;\n  rep(_,M){\n    rep(i,N){\n      bool failed = false;\n      if( inside(ps[i],Point(0,0),a[_],w[_],d[0]) ) {\n        rep(j,3) if( !failed ) rep(k,limit[j]) failed |= inside(ps[i],p[j][k],a[_],w[_],d[j]);\n      } else failed = true;\n      if( !failed ) ++counter[i];\n    }\n  }\n  int maxi = -1;\n  rep(i,N) if( counter[i] != 0 ) maxi = max(maxi,counter[i]);\n  if( maxi == -1 ) puts(\"NA\");\n  else {\n    bool first = true;\n    rep(i,N) if( counter[i] == maxi ){\n      if( !first ) printf(\" \"); first = false;\n      printf(\"%d\",i+1);\n    }\n    puts(\"\");\n  }\n}\n\nint main(){\n\n  while( scanf(\"%d %d\",&N,&M), N|M ){\n    rep(i,N) scanf(\"%lf %lf\",&ps[i].x,&ps[i].y);\n    scanf(\"%d %d %d %lf %lf %lf\",&Ume,&Momo,&SakuraHappyInnovation,d,d+1,d+2);\n    limit[0] = Ume, limit[1] = Momo, limit[2] = SakuraHappyInnovation;\n    rep(i,Ume) scanf(\"%lf %lf\",&p[0][i].x,&p[0][i].y);\n    rep(i,Momo) scanf(\"%lf %lf\",&p[1][i].x,&p[1][i].y);\n    rep(i,SakuraHappyInnovation) scanf(\"%lf %lf\",&p[2][i].x,&p[2][i].y);\n    rep(i,M) scanf(\"%lf %lf\",w+i,a+i);\n    compute();\n  }\n  return 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include <algorithm>\n#include <cmath>\n#include <iostream>\n#include <vector>\n\nusing namespace std;\n\ntypedef long long ll;\ntypedef vector<int> vi;\ntypedef vector<vi> vvi;\ntypedef pair<int, int> pii;\n\n#define reps(i,f,n) for(int i=f; i<int(n); ++i)\n#define rep(i,n) reps(i,0,n)\n\nconst double PI = acos(-1);\n\nbool reach(int x, int y, int w, int a, int d)\n{\n    if(x*x + y*y > a*a) return false;\n    double arg = atan2(y, x)*180/PI - w;\n    if(arg < -180) arg += 360;\n    return abs(arg)*2 < d;\n}\n\nvoid func(int H, int R)\n{\n    vector<pii> house(H);\n    rep(i, H){\n        cin >> house[i].first >> house[i].second;\n    }\n    \n    int N[3], d[3];\n    rep(i, 3) cin >> N[i];\n    rep(i, 3) cin >> d[i];\n    \n    vector<pii> tree[3];\n    \n    rep(i, 3){\n        tree[i].resize(N[i]);\n        rep(j, N[i]){\n            cin >> tree[i][j].first >> tree[i][j].second;\n        }\n    }\n    \n    vi cnt(H);\n    \n    rep(i, R){\n        int w, a;\n        cin >> w >> a;\n        \n        rep(j, H){\n            bool ok = reach(house[j].first, house[j].second, w, a, d[0]);\n            \n            rep(k, 3) rep(l, N[k]){\n                ok &= !reach(house[j].first - tree[k][l].first, house[j].second - tree[k][l].second, w, a, d[k]);\n            }\n            \n            if(ok) cnt[j]++;\n        }\n    }\n    \n    int maxi = *max_element(cnt.begin(), cnt.end());\n    if(maxi == 0){\n        cout << \"NA\" << endl;\n        return;\n    }\n    \n    bool first = true;\n    rep(i, H){\n        if(cnt[i] == maxi){\n            cout << (first ? \"\" : \" \") << i;\n            first = false;\n        }\n    }\n    \n    cout << endl;\n}\n\nint main()\n{\n    int H, R;\n    while(cin >> H >> R, H){\n        func(H, R);\n    }\n}"
  },
  {
    "language": "C++",
    "code": "#include<bits/stdc++.h>\nusing namespace std;\n\ntypedef pair<int,int>pint;\ntypedef vector<int>vint;\n#define pb push_back\n#define mp make_pair\n#define rep(i,n) for(int i=0;i<(n);i++)\ntemplate<class T,class U>void chmin(T &t,U f){if(t>f)t=f;}\ntemplate<class T,class U>void chmax(T &t,U f){if(t<f)t=f;}\n\ntypedef complex<double>P;\n\nconst double EPS=1e-9;\nconst double PI=acos(-1);\n\nconst int COUNTER_CLOCKWISE=1;\nconst int CLOCKWISE=-1;\nconst int ONLINE_BACK=2;\nconst int ONLINE_FRONT=-2;\nconst int ON_SEGMENT=0;\n\ninline double dot(const P &a, const P &b){return (conj(a) * b).real();}\ninline double cross(const P &a, const P &b){return (conj(a) * b).imag();}\n\ndouble toRad(double a){return a/180.0*PI;}\ndouble toDeg(double a){return a*180/PI;}\nP rotate(P p,double d){\n    return P(p.real()*cos(d)-p.imag()*sin(d),p.real()*sin(d)+p.imag()*cos(d));\n}\n\nP getP(){\n    double x,y;\n    scanf(\"%lf%lf\",&x,&y);\n    return P(x,y);\n}\n\nint ccw(P p0,P p1,P p2){\n    P a=p1-p0;\n    P b=p2-p0;\n    if(cross(a,b)>EPS)return COUNTER_CLOCKWISE;\n    if(cross(a,b)<-EPS)return CLOCKWISE;\n    if(dot(a,b)<-EPS)return ONLINE_BACK;\n    if(norm(a)<norm(b))return ONLINE_FRONT;\n    return ON_SEGMENT;\n}\n\nbool ok(P from,P to,double w,double a,double d){\n    if(abs(to-from)>a+EPS)return false;\n\n    w=toRad(w);\n    d=toRad(d);\n\n    P p0=from+P(cos(w),sin(w))*a;\n    P p1=rotate(p0,-d/2);\n    P p2=rotate(p0,d/2);\n\n    int c1=ccw(from,p1,to);\n    int c2=ccw(from,p2,to);\n\n    if(c1==CLOCKWISE||c1==ONLINE_BACK)return false;\n    if(c2==COUNTER_CLOCKWISE||c2==ONLINE_BACK)return false;\n    return true;\n}\n\nint H,R;\nvector<P>h;\n\nint U,M,S;\ndouble du,dm,ds;\nvector<P>u,m,s;\nvoid solve(){\n    h.resize(H);\n    rep(i,H)h[i]=getP();\n\n    scanf(\"%d%d%d\",&U,&M,&S);\n    scanf(\"%lf%lf%lf\",&du,&dm,&ds);\n\n    u.resize(U);\n    m.resize(M);\n    s.resize(S);\n    rep(i,U)u[i]=getP();\n    rep(i,M)m[i]=getP();\n    rep(i,S)s[i]=getP();\n\n    int cnt[100]={0};\n\n    while(R--){\n        double w,a;\n        scanf(\"%lf%lf\",&w,&a);\n        rep(i,H){\n            bool f=false;\n            if(ok(P(0,0),h[i],w,a,du))f=true;\n            rep(j,U)if(ok(u[j],h[i],w,a,du))f=false;\n            rep(j,M)if(ok(m[j],h[i],w,a,dm))f=false;\n            rep(j,S)if(ok(s[j],h[i],w,a,ds))f=false;\n            if(f)cnt[i]++;\n        }\n    }\n\n    int ma=*max_element(cnt,cnt+H);\n    if(ma==0){\n        puts(\"NA\");\n        return;\n    }\n\n    bool f=false;\n    rep(i,H){\n        if(cnt[i]!=ma)continue;\n        if(f)printf(\" \");\n        else f=true;\n        printf(\"%d\",i+1);\n    }\n    puts(\"\");\n}\n\nint main(){\n    while(scanf(\"%d%d\",&H,&R),H||R)solve();\n    return 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include <iostream>\n#include <cstdio>\n#include <iomanip>\n#include <vector>\n#include <map>\n#include <set>\n#include <queue>\n#include <bitset>\n#include <stack>\n#include <utility>\n#include <numeric>\n#include <algorithm>\n#include <functional>\n#include <cctype>\n#include <complex>\n#include <string>\n#include <sstream>\n#include <fstream>\n#include <cassert>\nusing namespace std;\n\n//common\ntypedef long long i64,ll;\n\n#define BR \"\\n\"\n#define ALL(c) (c).begin(),(c).end()\n#define REP(i,n) for(int i=0;i<(int)(n);++i)\n#define FOR(i,l,r) for(int i=(l);i<(int)(r);++i)\n#define EACH(it,o) for(auto it = (o).begin(); it != (o).end(); ++it)\n#define IN(l,v,r) ((l)<=(v) && (v)<(r))\n\n//debug\n#ifdef NDEBUG\n#define DUMP(x)\n#define DUMPLN(x)\n#define DEBUG(x)\n#define DEBUGLN(x)\n#define LINE()\n#define LINELN()\n#define CHECK(exp,act)\n#define STOP(e)\n#else\n#define DUMP(x)  cerr << #x << \" = \" << (x)\n#define DUMPLN(x)  DUMP(x) <<endl\n#define DEBUG(x) DUMP(x) << LINE() << \" \" << __FILE__\n#define DEBUGLN(x) DEBUG(x)<<endl\n#define LINE()    cerr<< \" (L\" << __LINE__ << \")\"\n#define LINELN()    LINE()<<endl\n#define CHECK(exp,act)  if(exp!=act){DUMPLN(exp);DEBUGLN(act);}\n#define STOP(e)  CHECK(e,true);if(!(e)) exit(1);\n#endif\n\ntemplate<class T> inline string toString(const vector<T>& x) {\n\tstringstream ss;\n\tREP(i,x.size()){\n\t\tif(i!=0)ss<<\" \";\n\t\tss<< x[i];\n\t}\n\treturn ss.str();\n}\n\ntemplate<class T> inline string toString(const vector<vector<T> >& map) {\n\tstringstream ss;\n\tREP(i,map.size()){\n\t\tif(i!=0)ss<<BR;\n\t\tss<< toString(map[i]);\n\t}\n\treturn ss.str();\n}\ntemplate<class K,class V>  string toString(map<K,V>& x) {\n\tstring res;stringstream ss;\n\tfor(auto& p:x)ss<< p.first<<\":\" << p.second<<\" \";\n\treturn ss.str();\n}\n\nstring BITtoString(int bit){\n    stringstream ss;\n    while(bit!=0){ss<<(bit%2);bit/=2;}\n    string res=ss.str();reverse(ALL(res));\n    return res;\n}\n\ntemplate<typename T,typename V> inline T pmod(T v,V MOD){\n\treturn (v%MOD+MOD)%MOD;\n}\ndouble pfmod(double v,double MOD){\n\treturn fmod(fmod(v,MOD)+MOD,MOD);\n}\n\nclass Comp{\npublic:\n\tbool operator () (const pair<int,int>& l,const pair<int,int>& r){\n\t\tif(l.first!=r.first)return l.first>r.first;\n\t\treturn l.second<r.second;\n\t}\n};\n\nnamespace Ps{\n\tconst double EPS = 1e-8;\n\tconst double INF = 1e12;\n\n\ttypedef complex<double> P;\n\t#define X(a) (real(a))\n\t#define Y(a) (imag(a))\n\t\n\t// a×b\n\tdouble cross(const P& a,const P& b){\n\t\treturn imag(conj(a)*b);\n\t}\n\t// a・b\n\tdouble dot(const P&a,const P& b) {\n\t\treturn real(conj(a)*b);\n\t}\n\n\t int ccw(const P& a,P b,P c){\n\t\tb -= a; c -= a;\n\t\t  if (cross(b,c) > 0)   return +1;       // counter clockwise\n\t\t  if (cross(b,c) < 0)   return -1;       // clockwise\n\t\t  if (dot(b,c) < 0)     return +2;       // c--a--b on line\n\t\t  if (norm(b) < norm(c)) return -2;       // a--b--c on line\n\t\t  return 0;\n\t  }\n}\nusing namespace Ps;\n\ndouble Abs(double a){double ret=max(a,-a);if(ret>M_PI)ret=2*M_PI-ret;return ret;}\nclass Main{\npublic:\n\tbool canReach(int x,int y,int w,int a,int d){\n\t\tif((ll)x*x+(ll)y*y<=(ll)a*a)\n\t\tw*=M_PI/180;if(w>M_PI)w-=2*M_PI;\n\t\tif(Abs(w*M_PI/180-atan2(y,x))<=d*M_PI/180/2)return true;\n\t\t\n\t\treturn false;\n\t}\n\n\tvoid run(){\n\n\t\twhile(true){\n\t\t\tint H,R;scanf(\"%d%d\",&H,&R);if(H==0)break;\n\n\t\t\tvector<int> xs(H),ys(H);\n\t\t\tREP(h,H)scanf(\"%d%d\",&xs[h],&ys[h]);\n\t\t\tint U,M,S,du,dm,ds;scanf(\"%d%d%d%d%d%d\",&U,&M,&S,&du,&dm,&ds);\n\n\t\t\tvector<int> uxs(U),uys(U);vector<int> mxs(M),mys(M);vector<int> sxs(S),sys(S);\n\t\t\tREP(i,U)scanf(\"%d%d\",&uxs[i],&uys[i]);\n\t\t\tREP(i,M)scanf(\"%d%d\",&mxs[i],&mys[i]);\n\t\t\tREP(i,S)scanf(\"%d%d\",&sxs[i],&sys[i]);\n\t\t\t\n\t\t\tvector<int> ws(R),as(R);\n\t\t\tREP(i,R)scanf(\"%d%d\",&ws[i],&as[i]);\n\n\n\t\t\tvector<pair<int,int>> res;\n\t\t\tREP(h,H){\n\t\t\t\tint x=xs[h],y=ys[h];\n\n\t\t\t\tint okc=0;\n\t\t\t\tREP(r,R){\n\t\t\t\t\tint w=ws[r],a=as[r];\n\t\t\t\t\tbool ok=false;\n\t\t\t\t\tif(canReach(x,y,w,a,du))ok=true;\n\t\t\t\t\tREP(i,U)if(canReach(x-uxs[i],y-uys[i],w,a,du))ok=false;\n\t\t\t\t\tREP(i,M)if(canReach(x-mxs[i],y-mys[i],w,a,dm))ok=false;\n\t\t\t\t\tREP(i,S)if(canReach(x-sxs[i],y-sys[i],w,a,ds))ok=false;\n\t\t\t\t\tif(ok)okc++;\n\t\t\t\t}\n\t\t\t\tres.push_back(make_pair(okc,h+1));\n\t\t\t}\n\t\t\tsort(ALL(res),Comp());\n\n\t\t\tint Mh=res[0].first;\n\t\t\t\n\t\t\tif(Mh==0){\n\t\t\t\tcout<<\"NA\"<<endl;continue;\n\t\t\t}\n\n\t\t\tfor(int i=0;i<H && Mh==res[i].first;i++){\n\t\t\t\tif(i!=0)cout <<\" \";\n\t\t\t\tcout << res[i].second; \n\t\t\t}\n\t\t\tcout <<endl;\n\t\t}\n\t}\n};\n\n int main(){\n\t//ios::sync_with_stdio(false);\n \tMain().run();\n \treturn 0;\n }"
  },
  {
    "language": "C++",
    "code": "#include <iostream>\n#include <string>\n#include <vector>\n#include <algorithm>\n#include <cmath>\n#include <map>\n\n#define REP(i,k,n) for(int i=k;i<n;i++)\n#define rep(i,n) for(int i=0;i<n;i++)\n#define EPS 1e-8\n#define equals(a,b) fabs((a) - (b)) < EPS\n#define PI acos(-1)\n\nusing namespace std;\n\nstruct Point\n{\n    double x, y;\n\n    Point(double x=0, double y=0) : x(x), y(y) {}\n\n    Point operator+(const Point &o) const { return Point(x+o.x, y+o.y); }\n\n    Point operator-(const Point &o) const { return Point(x-o.x, y-o.y); }\n\n    Point operator*(const double m) const { return Point(x*m, y*m); }\n\n    Point operator/(const double d) const { return Point(x/d, y/d); }\n\n    Point operator<(const Point &o) const { return x != o.x ? x < o.x : y < o.y; }\n\n\tbool operator==(const Point &o) const { return fabs(x-o.x) < EPS && fabs(y-o.y) < EPS; }\n\n\tdouble cross(const Point &o) const { return x * o.y - y * o.x; }\n\n    double dot(const Point &o) const { return x * o.x + y * o.y; }\n\n    double atan() const { return atan2(y, x); }\n\n\tdouble deg() const { return atan() * 180.0 / (acos(-1) * 4.0); }\n\n    double norm() const { return sqrt(dot(*this)); }\n\n    double distance(const Point &o) const { return (o - (*this)).norm(); }\n\n    double area(const Point &a,const Point &b)\n    {\n\t    Point p = a - (*this), p2 = b - (*this); \n\t    return p.cross(p2);\n    }\n\n    double area_abs(const Point &a,const Point &b) const\n    {\n\t    Point p = a - (*this), p2 = b - (*this);\n\t    return fabs(p.cross(p2)) / 2.0;\n    }\t\n\n    //線分abが自身に含まれているのかどうか判断する\n    int between(const Point &a,const Point &b)\n\t{\n\t\tif(area(a,b) != 0) return 0;\n\n    \tif(a.x != b.x)\n\t    {\n\t\t    return ((a.x <= x) && (x <= b.x) || (a.x >= x) && (x >= b.x));\n\t    }\n\t    else\n\t    {\n\t    \treturn ((a.y <= y) && (y <= b.y) || (a.y >= y) && (y >= b.y));\n\t    }\n    }      \n\n\tdouble distance_seg(const Point& a,const Point& b)\n\t{\n    \tif((b-a).dot(*this-a) < EPS)\n    \t{\n\t    \treturn (*this-a).norm();\n\t    }\n\t    if((a-b).dot(*this-b) < EPS)\n    \t{\n\t    \treturn (*this-b).norm();\n    \t}\n\t    return abs((b-a).cross(*this-a)) / (b-a).norm();\n    }\n\n    bool hitPolygon(const Point& a,const Point& b,const Point& c)\n\t{\n    \tdouble t = (b-a).cross(*this-b);\n    \tdouble t2 = (c-b).cross(*this-c);\n    \tdouble t3 = (a-c).cross(*this-a);\n    \tif((t > 0 && t2 > 0 && t3 > 0) || ( t < 0 && t2 < 0 && t3 < 0))\n    \t{\n    \t\treturn true;\n    \t}\n\n\t    return false;\n    }\n};\n\nint ccw(Point a,Point b,Point c)\n{\n    b = b-a;\n    c = c-a;\n\n    if(b.cross(c) > EPS) return +1;\t//conter clockwise\n    if(b.cross(c) < -EPS) return -1;\t//clockwise\n    if(b.dot(c) < -EPS) return +2;\t//a on Seg(b,c)\n    if(b.norm() < c.norm()) return -2;\t//b on Seg(a,c)\n    return 0;\t//c on Seg(a,b)\n}\n\nbool inPolygon(Point p,Point a,Point b,Point c)\n{\n\tif(ccw(a,b,p) == -1 && ccw(a,c,p) == +1) return true;\n\n\treturn false;\n}\n\ndouble to_rad(double deg)\n{\n\treturn deg*PI/180;\n}\n\nbool hit(Point s,Point v,double d,double w,double a)\n{\n\tif(s.distance(v) > a) return false;\n\n\tdouble x = a*cos(to_rad(w + d/2));\n\tdouble y = a*sin(to_rad(w + d/2));\n\tPoint p(x,y);\n\n\tx = a*cos(to_rad(w - d/2));\n\ty = a*sin(to_rad(w - d/2));\n\tPoint p2(x,y);\n\n\tif(inPolygon(v,s,s+p,s+p2)) return true;\n\treturn false;\n}\n\nint main()\n{\n\tint h,r;\n\twhile(cin >> h >> r)\n\t{\n\t\tif(h == 0 && r == 0) break;\n\n\t\tvector<Point> v;\n\t\trep(i,h)\n\t\t{\n\t\t\tdouble x,y;\n\t\t\tcin >> x >> y;\n\t\t\tv.push_back(Point(x,y));\n\t\t}\n\n\t\tint u,m,s;\n\t\tdouble du,dm,ds;\n\t\tcin >> u >> m >> s >> du >> dm >> ds;\n\n\t\tvector<Point> ume;\n\t\trep(i,u)\n\t\t{\n\t\t\tdouble x,y;\n\t\t\tcin >> x >> y;\n\t\t\tume.push_back(Point(x,y));\n\t\t}\n\t\t\n\t\tvector<Point> momo;\n\t\trep(i,m)\n\t\t{\n\t\t\tdouble x,y;\n\t\t\tcin >> x >> y;\n\t\t\tmomo.push_back(Point(x,y));\n\t\t}\n\n\t\tvector<Point> sakura;\n\t\trep(i,s)\n\t\t{\n\t\t\tdouble x,y;\n\t\t\tcin >> x >> y;\n\t\t\tsakura.push_back(Point(x,y));\n\t\t}\n\n\t\tPoint S(0,0);\n\t\tmap<int,int> ma;\n\t\trep(i,r)\n\t\t{\n\t\t\tint w,a;\n\t\t\tcin >> w >> a;\n\n\t\t\trep(j,h)\n\t\t\t{\n\t\t\t\tint cnt = 0;\n\t\t\t\tif(hit(S,v[j],du,w,a)) cnt++;\n\n\t\t\t\tbool only = true;\n\n\t\t\t\trep(k,u) if(hit(ume[k],v[j],du,w,a)) only = false;\n\t\t\t\trep(k,m) if(hit(momo[k],v[j],dm,w,a)) only = false;\n\t\t\t\trep(k,s) if(hit(sakura[k],v[j],ds,w,a)) only = false;\n\n\t\t\t\tif(cnt > 0 && only) ma[j]++;\n\t\t\t}\n\t\t}\n\n\t\tint cmax = 0;\n\n\t\tmap<int,int>::iterator ite;\n\t\tfor(ite = ma.begin();ite != ma.end();ite++)\n\t\t{\n\t\t\tcmax = max(cmax,ite->second);\n\t\t}\n\n\t\tif(cmax == 0) cout << \"NA\" << endl;\n\t\telse\n\t\t{\n\t\t\tvector<int> ans;\n\t\t\tfor(ite = ma.begin();ite != ma.end();ite++)\n\t\t\t{\n\t\t\t\tif(ite->second == cmax) ans.push_back(ite->first);\n\t\t\t}\n\n\t\t\tsort(ans.begin(),ans.end());\n\n\t\t\trep(i,ans.size())\n\t\t\t{\n\t\t\t\tcout << ans[i] + 1;\n\t\t\t\tif(i == ans.size()-1) cout << endl;\n\t\t\t\telse cout << \" \";\n\t\t\t}\n\t\t}\n\t}\n\n\treturn 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include<bits/stdc++.h>\nusing namespace std;\ntypedef pair< int , int > Pi;\n\n/*                         */\n/*                         */\n/* @@ Geometory Library @@ */\n/*               by ei1333 */\n/*                         */\nconst double EPS = 1e-8, PI = acos(-1);\n \ninline bool eq(double a,double b){ return abs(b - a) < EPS; }\n#define curr(P,i) P[i]\n#define next(P,i) P[(i+1)%P.size()]\n#define prev(P,i) P[(i+P.size()-1) % P.size()]\nenum { OUT, ON, IN };\nnamespace Geometory { // Geometory Library\n  struct Point {\n    double x, y;\n    Point(){};\n    Point(double x,double y):x(x),y(y){};\n    Point operator+(const Point& b) const { return Point(x + b.x,y + b.y); }\n    Point operator-(const Point& b) const { return Point(x - b.x,y - b.y); }\n    Point operator*(const double b) const { return Point(x * b,y * b); }\n    Point operator*(const Point& b) const { return Point(x * b.x - y * b.y,x * b.y + y * b.x); }\n    Point operator/(const double b) const { return Point(x / b,y / b); }\n    bool operator< (const Point& b) const { return x != b.x ? x < b.x : y < b.y;}\n    bool operator==(const Point& b) const { return eq(x,b.x) && eq(y,b.y); }\n    double norm(){ return x * x + y * y; }\n    double arg(){ return atan2(x,y); }\n    double abs(){ return sqrt(norm()); }\n    Point rotate(double theta){ return Point(cos(theta) * x - sin(theta) * y,sin(theta) * x + cos(theta) * y); }\n    Point rotate90(){ return Point(-y,x); }\n    friend ostream& operator<<(ostream& os, Point& p){ return os<<\"(\"<<p.x<<\",\"<<p.y<<\")\"; }\n    friend istream& operator>>(istream& is, Point& a){ return is>>a.x>>a.y; }\n  };\n    \n  struct Line {\n    Point a, b;\n    Line(){};\n    Line(Point a,Point b):a(a),b(b){};\n    friend ostream& operator<<(ostream& os, Line& p){ return os<<\"(\"<<p.a.x<<\",\"<<p.a.y<<\") to (\"<<p.b.x<<\",\"<<p.b.y<<\")\"; }\n    friend istream& operator>>(istream& is, Line& a){ return is>>a.a.x>>a.a.y>>a.b.x>>a.b.y; }\n  };\n  struct Segment {\n    Point a, b;\n    Segment(){};\n    Segment(Point a,Point b):a(a),b(b){};\n    friend ostream& operator<<(ostream& os, Segment& p){ return os<<\"(\"<<p.a.x<<\",\"<<p.a.y<<\") to (\"<<p.b.x<<\",\"<<p.b.y<<\")\"; }\n    friend istream& operator>>(istream& is, Segment& a){ return is>>a.a.x>>a.a.y>>a.b.x>>a.b.y; }\n  };\n  struct Circle {\n    Point p; double r;\n    Circle(){};\n    Circle(Point p, double r) : p(p),r(r){};\n  };\n  typedef vector< Point > Polygon;\n  typedef vector< Segment > Segments;\n  typedef vector< Line > Lines;\n  typedef vector< Circle > Circles;\n  typedef pair< Point, Point > PointPoint;\n    \n  double cross(const Point& a,const Point& b){\n    return a.x * b.y - a.y * b.x;\n  }\n  double dot(const Point& a,const Point& b){\n    return a.x * b.x + a.y * b.y;\n  }\n    \n  int ccw(const Point& a,Point b,Point c){\n    b = b - a, c = c - a;\n    if(cross(b,c) > EPS)    return +1;  // a → b で 反時計方向におれて c\n    if(cross(b,c) < -EPS)    return -1; // a → b で 時計方向におれて c\n    if(dot(b,c) < 0)      return +2;  // c -- a -- bで一直線上\n    if(b.norm() < c.norm()) return -2; // a -- b -- cで一直線上\n    return 0;  // a -- c -- bで一直線上\n  }\n  Point Projection(const Line& l, const Point& p){\n    double t = dot( p - l.a, l.a - l.b) / (l.a - l.b).norm();\n    return l.a + (l.a - l.b) * t;\n  }\n  Point Projection(const Segment& l, const Point& p){\n    double t = dot( p - l.a, l.a - l.b) / (l.a - l.b).norm();\n    return l.a + (l.a - l.b) * t;\n  }\n  Point Reflection(const Line& l, const Point& p){\n    return p + (Projection( l, p) - p) * 2.0;\n  }\n    \n  double Distance( const Line& l,const Point& p) { //OK\n    return (p - Projection( l, p)).abs();\n  }\n    \n  bool Intersect(const Line& l, const Line& m){\n    return abs(cross(l.b - l.a, m.b - m.a)) > EPS || abs(cross(l.b-l.a, m.b-l.a)) < EPS;\n  }\n  bool Intersect(const Line& l, const Segment& s){\n    return cross( l.b - l.a, s.a - l.a) * cross( l.b - l.a, s.b - l.a) < EPS;\n  }\n  bool Intersect(const Line& l, const Point& p){\n    return abs(ccw(l.a, l.b, p)) != -1;\n  }\n  bool Intersect(const Segment& s, const Segment& t){\n    return ccw(s.a, s.b, t.a) * ccw(s.a, s.b, t.b) <= 0 && ccw(t.a, t.b, s.a) * ccw(t.a, t.b, s.b) <= 0;\n  }\n  bool Intersect(const Segment& s, const Point& p){\n    return ccw(s.a, s.b, p) == 0;\n  }\n  bool Intersect(const Circle& c,const Line& l){\n    return Distance( l, c.p) <= c.r + EPS;\n  }\n  bool Intersect(const Circle& c,const Point& p){\n    return abs( ( p - c.p).abs() - c.r ) < EPS;\n  }\n  int Intersect(const Circle& c, const Segment& l){\n    if( (Projection( l, c.p) - c.p).norm() - c.r * c.r > EPS) return 0;\n    const double d1 = ( c.p - l.a).abs(), d2 = ( c.p - l.b).abs();\n    if( d1 < c.r + EPS && d2 < c.r + EPS) return 0;\n    if( d1 < c.r - EPS && d2 > c.r + EPS || d1 > c.r + EPS && d2 < c.r - EPS ) return 1;\n    const Point h = Projection( l, c.p);\n    if( dot( l.a - h, l.b - h) < 0) return 2;\n    return 0;\n  }\n  bool Intersect(const Circle& a,const Circle& b){\n    return ( ( a.p - b.p).norm() - ( a.r + b.r) * ( a.r + b.r) < EPS) &&\n      ( ( a.p - b.p).norm() - ( a.r - b.r) * ( a.r - b.r) > -EPS);\n  }\n  double Distance(const Segment& s,const Point& p){\n    Point r = Projection(s, p);\n    if ( Intersect( s, r)) return ( r - p).abs();\n    return min( ( s.a - p).abs(), ( s.b - p).abs());\n  }\n  double Distance(const Segment& a,const Segment& b){\n    if(Intersect( a, b)) return 0;\n    return min( min( Distance( a, b.a), Distance( a, b.b)), min( Distance( b, a.a), Distance( b, a.b)));\n  }\n  double Distance(const Line& l,const Line& m) {\n    return Intersect( l, m) ? 0 : Distance( l, m.a);\n  }\n  double Distance(const Line& l,const Segment& s) { //OK\n    if (Intersect(l, s)) return 0;\n    return min(Distance(l, s.a), Distance(l, s.b));\n  }\n  double Distance(const Point& a,const Point& b){ //OK\n    return ( a - b).abs();\n  }\n  Point Crosspoint(const Segment& l,const Segment& m) { //OK\n    double A = cross(l.b - l.a, m.b - m.a);\n    double B = cross(l.b - l.a, l.b - m.a);\n    if (abs(A) < EPS && abs(B) < EPS) return m.a; // same line\n    return m.a + (m.b - m.a) * B / A;\n  }\n  PointPoint Crosspoint(const Circle& c,const Line l){\n    Point hp = Projection( l, c.p), h =  hp - c.p;\n    const double d2 = h.norm();\n    Point v = ( l.b - l.a) * sqrt( c.r * c.r - d2) / ( l.b - l.a).abs();\n    return PointPoint(hp - v, hp + v);\n  }\n  PointPoint Crosspoint(const Circle& c,const Segment& l) {\n    Line aa = Line( l.a, l.b);\n    if(Intersect(c, l) == 2) return Crosspoint(c, aa);\n    PointPoint ret = Crosspoint(c, aa);\n    if(dot(l.a - ret.first, l.b - ret.first) < 0) ret.second = ret.first;\n    else ret.first = ret.second;\n    return ret;\n  }\n  PointPoint Crosspoint(const Circle& c1,const Circle& c2){ //OK\n    double d = (c1.p - c2.p).abs();\n    double s = (c1.r + c2.r + d) / 2;\n    double S = sqrt( s * ( s - c1.r) * ( s - c2.r) * ( s - d));\n    double h = 2 * S / d;\n    Point v = ( c2.p - c1.p) / ( c2.p - c1.p).abs();\n    double m = sqrt( c1.r * c1.r - h * h);\n    return PointPoint( c1.p + v * m + Point(0,1) * h * v, c1.p + v * m - Point(0,1) * h * v);\n  }\n  bool parallel(const Line& a,const Line& b){\n    return abs(cross( a.b - a.a, b.b - b.a)) < EPS;\n  }\n  bool orthogonal(const Line& a,const Line& b){\n    return abs(dot( a.a - a.b, b.a - b.b)) < EPS;\n  }\n  int Contains(const Polygon& Q,const Point& p){\n    bool in = false;\n    for(int i = 0 ; i < Q.size() ; i++ ){\n      Point a = curr(Q,i) - p, b = next(Q,i) - p;\n      if(a.y > b.y) swap(a,b);\n      if(a.y <= 0 && 0 < b.y && cross(a,b) < 0) in = !in;\n      if(cross(a,b) == 0 && dot(a,b) <= 0) return ON;\n    }\n    return in ? IN : OUT;\n  }\n  bool Contains(const Circle& c,const Point& p){\n    return ( c.p - p).abs() < c.r + EPS;\n  }\n  double Area2(const Polygon& p){ //OK\n    double A = 0;\n    for (int i = 0; i < p.size(); ++i){\n      A += cross(curr(p, i), next(p, i));\n    }\n    return A;\n  }\n  bool IsConvex(const Polygon& p){\n    for(int i = 0; i < p.size(); i++){\n      if(ccw(prev(p,i),curr(p,i),next(p,i)) == -1) return false;\n    }\n    return true;\n  }\n  Polygon Convex_Hull(Polygon& p){\n    int n = p.size(), k = 0;\n    if(n >= 3){\n      sort( p.begin(), p.end());\n      vector< Point > ch(2 * n);\n      for(int i = 0; i < n; ch[k++] = p[i++]){\n        while(k >= 2 && cross( ch[k - 1] - ch[k - 2], p[i] - ch[k - 1]) < 0) --k;\n      }\n      for(int i = n - 2, t = k + 1; i >= 0; ch[k++] = p[i--]){\n        while(k >= t && cross( ch[k - 1] - ch[k - 2], p[i] - ch[k - 1]) < 0) --k;\n      }\n      ch.resize( k - 1);\n      return ch;\n    } else {\n      return p;\n    }\n  }\n  double Convex_Diameter(Polygon& p){\n    int n = p.size();\n    int is = 0, js = 0;\n    for(int i = 1; i < n; i++){\n      if(p[i].y > p[is].y) is = i;\n      if(p[i].y < p[js].y) js = i;\n    }\n    double maxdis = ( p[is] - p[js]).norm();\n  \n    int maxi, maxj, i, j;\n    i = maxi = is;\n    j = maxj = js;\n    do {\n      if(cross( next( p, i) - curr( p, i), next( p, j) - curr( p, j)) >= 0){\n        j = (j + 1) % n;\n      } else {\n        i = (i + 1) % n;\n      }\n      if(( p[i] - p[j]).norm() > maxdis){\n        maxdis = ( p[i] - p[j]).norm();\n        maxi = i; maxj = j;\n      }\n    }  while (i != is || j != js);\n    return maxdis;\n  }\n};\n  \ntypedef Geometory::Point Point;\ntypedef Geometory::Line Line;\ntypedef Geometory::Segment Segment;\ntypedef Geometory::Circle Circle;\n\nbool Contain(const double& d, const double& a, double w, const Point& base, Point that){\n\n  if(Geometory::Contains( Circle( base, a), that) == 0){ //円の外\n    return false;\n  } else {\n    double pos = atan2( (that - base).y, (that - base).x); \n    if(w > PI) w -= 2 * PI;\n    return min( min( abs(pos - w), abs(pos - w + 2 * PI)), abs(pos - w - 2 * PI)) * 2 < d;\n  }\n}\n\nint main(){\n  int H, R, U, M, S;\n  double du, dm, ds;\n  while(cin >> H >> R, H){\n    vector< Point > h(H);\n    for(int i = 0; i < H; i++){\n      cin >> h[i];\n    }\n    cin >> U >> M >> S >> du >> dm >> ds;\n    du *= PI / 180.0;\n    dm *= PI / 180.0;\n    ds *= PI / 180.0;\n\n    vector< Point > umx[3]; //umx[0]のみが届く日数が最大の家\n\n    umx[0].resize(U);\n    for(int i = 0; i < U; i++){\n      cin >> umx[0][i];\n    }\n    umx[1].resize(M);\n    for(int i = 0; i < M; i++){\n      cin >> umx[1][i];\n    }\n    umx[2].resize(S);\n    for(int i = 0; i < S; i++){\n      cin >> umx[2][i];\n    }\n    vector< int > home( H, 0);\n    for(int i = 0; i < R; i++){\n      double w, a; // w: 風の向かう方向θ a: 強さ = 半径\n      cin >> w >> a;\n      w *= PI / 180.0;\n      for(int j = 0; j < H; j++){\n\n        bool flag = Contain( du, a, w, Point( 0, 0), h[j]);\n        for(int k = 0; k < U && flag; k++){ // h[j]がこの扇形に入ってたらうれしみ\n          flag &= !Contain( du, a, w, umx[0][k], h[j]);\n        }\n        for(int k = 0; k < M && flag; k++){ // h[j]がこの扇形に入ってたらかなしみ\n          flag &= !Contain( dm, a, w, umx[1][k], h[j]);\n        }\n        for(int k = 0; k < S && flag; k++){ // 同上\n          flag &= !Contain( ds, a, w, umx[2][k], h[j]);\n        }\n        home[j] += flag; // うれしみの日数をインクリメント\n      }\n    }\n\n    int ret = *max_element( home.begin(), home.end());\n    if(ret == 0) cout << \"NA\" << endl;\n    else {\n      bool first = false;\n      for(int i = 0; i < H; i++){\n        if(ret == home[i]) cout << (first++ ? \" \" : \"\") << i + 1;\n      }\n      cout << endl;\n    }\n  }\n}"
  },
  {
    "language": "C++",
    "code": "#include<bits/stdc++.h>\nusing namespace std;\ntypedef complex<double> P;\nint H,R;\nint U[3];\ndouble D[3];\nconst double eps = 1e-8;\ndouble getRtoA( double r ){ return 180.0/M_PI*r; }\ndouble da[]={-360.0,0.0,360.0};\nbool check(P p, P f, double a, double w, double d ){\n  P v = p - f;\n  if( abs(v) > a + eps ) return false;\n  double an = getRtoA( arg(v) );\n  for(int i=0;i<3;i++){\n    if( w - d - eps < an + da[i] && an + da[i] < w + d + eps ) return true;\n  }\n  return false;\n}\n\nbool check( P p, vector<vector<P>> u, double a, double w){\n  for(int i=0;i<3;i++){\n    for(int j=0;j<U[i];j++){\n      if( check( p, u[i][j], a, w, D[i] ) ) return false;\n    }\n  }\n  return true;\n}\n\nint main(){\n  while( cin >> H >> R && (H|R) ){\n    vector<P> h;\n    vector<vector<P>> u;\n    vector<int> w,a;\n    u.resize(3);\n    for(int i=0;i<H;i++){\n      int x,y; cin >> x >> y; h.push_back( P( x, y ) );\n    }\n    cin >> U[0] >> U[1] >> U[2] >> D[0] >> D[1] >> D[2];\n    for(int i=0;i<3;i++){\n      D[i]/=2.0;\n      for(int j=0;j<U[i];j++){\n        int x,y; cin >> x >> y;\n        u[i].push_back( P(x,y) );\n      }\n    }\n\n    w.resize(R);a.resize(R);\n    for(int i=0;i<R;i++){\n      cin >> w[i] >> a[i];\n    }\n\n    \n    vector<int> res;\n    int maxs = 0;\n    for(int i=0;i<H;i++){\n      int cnt = 0;\n      for(int j=0;j<R;j++){\n        if( check( h[i], P(0,0), a[j], w[j], D[0] ) ) {\n          if( check( h[i], u, a[j], w[j] ) ) cnt++;\n        }\n      }\n      if( cnt == 0 ) continue;\n      if( maxs < cnt ){\n        res.clear();\n        res.push_back( i+1 );\n        maxs = cnt;\n      } else if( maxs == cnt )\n        res.push_back( i+1 );\n\n    }\n\n    if( res.empty() ) cout << \"NA\";\n    else {\n      for(int i=0;i<(int)res.size();i++){\n        if( i ) cout << \" \";\n        cout << res[i];\n      }\n    }\n    cout << endl;\n    \n  }\n}"
  },
  {
    "language": "C++",
    "code": "#include<bits/stdc++.h>\nusing namespace std;\ntypedef pair< int , int > Pi;\n\n/*                         */\n/*                         */\n/* @@ Geometory Library @@ */\n/*               by ei1333 */\n/*                         */\nconst double EPS = 1e-8, PI = acos(-1);\n \ninline bool eq(double a,double b){ return abs(b - a) < EPS; }\n#define curr(P,i) P[i]\n#define next(P,i) P[(i+1)%P.size()]\n#define prev(P,i) P[(i+P.size()-1) % P.size()]\nenum { OUT, ON, IN };\nnamespace Geometory { // Geometory Library\n  struct Point {\n    double x, y;\n    Point(){};\n    Point(double x,double y):x(x),y(y){};\n    Point operator+(const Point& b) const { return Point(x + b.x,y + b.y); }\n    Point operator-(const Point& b) const { return Point(x - b.x,y - b.y); }\n    Point operator*(const double b) const { return Point(x * b,y * b); }\n    Point operator*(const Point& b) const { return Point(x * b.x - y * b.y,x * b.y + y * b.x); }\n    Point operator/(const double b) const { return Point(x / b,y / b); }\n    bool operator< (const Point& b) const { return x != b.x ? x < b.x : y < b.y;}\n    bool operator==(const Point& b) const { return eq(x,b.x) && eq(y,b.y); }\n    double norm(){ return x * x + y * y; }\n    double arg(){ return atan2(x,y); }\n    double abs(){ return sqrt(norm()); }\n    Point rotate(double theta){ return Point(cos(theta) * x - sin(theta) * y,sin(theta) * x + cos(theta) * y); }\n    Point rotate90(){ return Point(-y,x); }\n    friend ostream& operator<<(ostream& os, Point& p){ return os<<\"(\"<<p.x<<\",\"<<p.y<<\")\"; }\n    friend istream& operator>>(istream& is, Point& a){ return is>>a.x>>a.y; }\n  };\n    \n  struct Line {\n    Point a, b;\n    Line(){};\n    Line(Point a,Point b):a(a),b(b){};\n    friend ostream& operator<<(ostream& os, Line& p){ return os<<\"(\"<<p.a.x<<\",\"<<p.a.y<<\") to (\"<<p.b.x<<\",\"<<p.b.y<<\")\"; }\n    friend istream& operator>>(istream& is, Line& a){ return is>>a.a.x>>a.a.y>>a.b.x>>a.b.y; }\n  };\n  struct Segment {\n    Point a, b;\n    Segment(){};\n    Segment(Point a,Point b):a(a),b(b){};\n    friend ostream& operator<<(ostream& os, Segment& p){ return os<<\"(\"<<p.a.x<<\",\"<<p.a.y<<\") to (\"<<p.b.x<<\",\"<<p.b.y<<\")\"; }\n    friend istream& operator>>(istream& is, Segment& a){ return is>>a.a.x>>a.a.y>>a.b.x>>a.b.y; }\n  };\n  struct Circle {\n    Point p; double r;\n    Circle(){};\n    Circle(Point p, double r) : p(p),r(r){};\n  };\n  typedef vector< Point > Polygon;\n  typedef vector< Segment > Segments;\n  typedef vector< Line > Lines;\n  typedef vector< Circle > Circles;\n  typedef pair< Point, Point > PointPoint;\n    \n  double cross(const Point& a,const Point& b){\n    return a.x * b.y - a.y * b.x;\n  }\n  double dot(const Point& a,const Point& b){\n    return a.x * b.x + a.y * b.y;\n  }\n    \n  int ccw(const Point& a,Point b,Point c){\n    b = b - a, c = c - a;\n    if(cross(b,c) > EPS)    return +1;  // a → b で 反時計方向におれて c\n    if(cross(b,c) < -EPS)    return -1; // a → b で 時計方向におれて c\n    if(dot(b,c) < 0)      return +2;  // c -- a -- bで一直線上\n    if(b.norm() < c.norm()) return -2; // a -- b -- cで一直線上\n    return 0;  // a -- c -- bで一直線上\n  }\n  Point Projection(const Line& l, const Point& p){\n    double t = dot( p - l.a, l.a - l.b) / (l.a - l.b).norm();\n    return l.a + (l.a - l.b) * t;\n  }\n  Point Projection(const Segment& l, const Point& p){\n    double t = dot( p - l.a, l.a - l.b) / (l.a - l.b).norm();\n    return l.a + (l.a - l.b) * t;\n  }\n  Point Reflection(const Line& l, const Point& p){\n    return p + (Projection( l, p) - p) * 2.0;\n  }\n    \n  double Distance( const Line& l,const Point& p) { //OK\n    return (p - Projection( l, p)).abs();\n  }\n    \n  bool Intersect(const Line& l, const Line& m){\n    return abs(cross(l.b - l.a, m.b - m.a)) > EPS || abs(cross(l.b-l.a, m.b-l.a)) < EPS;\n  }\n  bool Intersect(const Line& l, const Segment& s){\n    return cross( l.b - l.a, s.a - l.a) * cross( l.b - l.a, s.b - l.a) < EPS;\n  }\n  bool Intersect(const Line& l, const Point& p){\n    return abs(ccw(l.a, l.b, p)) != -1;\n  }\n  bool Intersect(const Segment& s, const Segment& t){\n    return ccw(s.a, s.b, t.a) * ccw(s.a, s.b, t.b) <= 0 && ccw(t.a, t.b, s.a) * ccw(t.a, t.b, s.b) <= 0;\n  }\n  bool Intersect(const Segment& s, const Point& p){\n    return ccw(s.a, s.b, p) == 0;\n  }\n  bool Intersect(const Circle& c,const Line& l){\n    return Distance( l, c.p) <= c.r + EPS;\n  }\n  bool Intersect(const Circle& c,const Point& p){\n    return abs( ( p - c.p).abs() - c.r ) < EPS;\n  }\n  int Intersect(const Circle& c, const Segment& l){\n    if( (Projection( l, c.p) - c.p).norm() - c.r * c.r > EPS) return 0;\n    const double d1 = ( c.p - l.a).abs(), d2 = ( c.p - l.b).abs();\n    if( d1 < c.r + EPS && d2 < c.r + EPS) return 0;\n    if( d1 < c.r - EPS && d2 > c.r + EPS || d1 > c.r + EPS && d2 < c.r - EPS ) return 1;\n    const Point h = Projection( l, c.p);\n    if( dot( l.a - h, l.b - h) < 0) return 2;\n    return 0;\n  }\n  bool Intersect(const Circle& a,const Circle& b){\n    return ( ( a.p - b.p).norm() - ( a.r + b.r) * ( a.r + b.r) < EPS) &&\n      ( ( a.p - b.p).norm() - ( a.r - b.r) * ( a.r - b.r) > -EPS);\n  }\n  double Distance(const Segment& s,const Point& p){\n    Point r = Projection(s, p);\n    if ( Intersect( s, r)) return ( r - p).abs();\n    return min( ( s.a - p).abs(), ( s.b - p).abs());\n  }\n  double Distance(const Segment& a,const Segment& b){\n    if(Intersect( a, b)) return 0;\n    return min( min( Distance( a, b.a), Distance( a, b.b)), min( Distance( b, a.a), Distance( b, a.b)));\n  }\n  double Distance(const Line& l,const Line& m) {\n    return Intersect( l, m) ? 0 : Distance( l, m.a);\n  }\n  double Distance(const Line& l,const Segment& s) { //OK\n    if (Intersect(l, s)) return 0;\n    return min(Distance(l, s.a), Distance(l, s.b));\n  }\n  double Distance(const Point& a,const Point& b){ //OK\n    return ( a - b).abs();\n  }\n  Point Crosspoint(const Segment& l,const Segment& m) { //OK\n    double A = cross(l.b - l.a, m.b - m.a);\n    double B = cross(l.b - l.a, l.b - m.a);\n    if (abs(A) < EPS && abs(B) < EPS) return m.a; // same line\n    return m.a + (m.b - m.a) * B / A;\n  }\n  PointPoint Crosspoint(const Circle& c,const Line l){\n    Point hp = Projection( l, c.p), h =  hp - c.p;\n    const double d2 = h.norm();\n    Point v = ( l.b - l.a) * sqrt( c.r * c.r - d2) / ( l.b - l.a).abs();\n    return PointPoint(hp - v, hp + v);\n  }\n  PointPoint Crosspoint(const Circle& c,const Segment& l) {\n    Line aa = Line( l.a, l.b);\n    if(Intersect(c, l) == 2) return Crosspoint(c, aa);\n    PointPoint ret = Crosspoint(c, aa);\n    if(dot(l.a - ret.first, l.b - ret.first) < 0) ret.second = ret.first;\n    else ret.first = ret.second;\n    return ret;\n  }\n  PointPoint Crosspoint(const Circle& c1,const Circle& c2){ //OK\n    double d = (c1.p - c2.p).abs();\n    double s = (c1.r + c2.r + d) / 2;\n    double S = sqrt( s * ( s - c1.r) * ( s - c2.r) * ( s - d));\n    double h = 2 * S / d;\n    Point v = ( c2.p - c1.p) / ( c2.p - c1.p).abs();\n    double m = sqrt( c1.r * c1.r - h * h);\n    return PointPoint( c1.p + v * m + Point(0,1) * h * v, c1.p + v * m - Point(0,1) * h * v);\n  }\n  bool parallel(const Line& a,const Line& b){\n    return abs(cross( a.b - a.a, b.b - b.a)) < EPS;\n  }\n  bool orthogonal(const Line& a,const Line& b){\n    return abs(dot( a.a - a.b, b.a - b.b)) < EPS;\n  }\n  int Contains(const Polygon& Q,const Point& p){\n    bool in = false;\n    for(int i = 0 ; i < Q.size() ; i++ ){\n      Point a = curr(Q,i) - p, b = next(Q,i) - p;\n      if(a.y > b.y) swap(a,b);\n      if(a.y <= 0 && 0 < b.y && cross(a,b) < 0) in = !in;\n      if(cross(a,b) == 0 && dot(a,b) <= 0) return ON;\n    }\n    return in ? IN : OUT;\n  }\n  bool Contains(const Circle& c,const Point& p){\n    return ( c.p - p).abs() < c.r + EPS;\n  }\n  double Area2(const Polygon& p){ //OK\n    double A = 0;\n    for (int i = 0; i < p.size(); ++i){\n      A += cross(curr(p, i), next(p, i));\n    }\n    return A;\n  }\n  bool IsConvex(const Polygon& p){\n    for(int i = 0; i < p.size(); i++){\n      if(ccw(prev(p,i),curr(p,i),next(p,i)) == -1) return false;\n    }\n    return true;\n  }\n  Polygon Convex_Hull(Polygon& p){\n    int n = p.size(), k = 0;\n    if(n >= 3){\n      sort( p.begin(), p.end());\n      vector< Point > ch(2 * n);\n      for(int i = 0; i < n; ch[k++] = p[i++]){\n        while(k >= 2 && cross( ch[k - 1] - ch[k - 2], p[i] - ch[k - 1]) < 0) --k;\n      }\n      for(int i = n - 2, t = k + 1; i >= 0; ch[k++] = p[i--]){\n        while(k >= t && cross( ch[k - 1] - ch[k - 2], p[i] - ch[k - 1]) < 0) --k;\n      }\n      ch.resize( k - 1);\n      return ch;\n    } else {\n      return p;\n    }\n  }\n  double Convex_Diameter(Polygon& p){\n    int n = p.size();\n    int is = 0, js = 0;\n    for(int i = 1; i < n; i++){\n      if(p[i].y > p[is].y) is = i;\n      if(p[i].y < p[js].y) js = i;\n    }\n    double maxdis = ( p[is] - p[js]).norm();\n  \n    int maxi, maxj, i, j;\n    i = maxi = is;\n    j = maxj = js;\n    do {\n      if(cross( next( p, i) - curr( p, i), next( p, j) - curr( p, j)) >= 0){\n        j = (j + 1) % n;\n      } else {\n        i = (i + 1) % n;\n      }\n      if(( p[i] - p[j]).norm() > maxdis){\n        maxdis = ( p[i] - p[j]).norm();\n        maxi = i; maxj = j;\n      }\n    }  while (i != is || j != js);\n    return maxdis;\n  }\n};\n  \ntypedef Geometory::Point Point;\ntypedef Geometory::Line Line;\ntypedef Geometory::Segment Segment;\ntypedef Geometory::Circle Circle;\n\nbool Contain(const double& d, const double& a, double w, const Point& base, Point that){\n\n  if(Geometory::Contains( Circle( base, a), that) == 0){ //円の外\n    return false;\n  } else {\n    double pos = atan2( (that - base).y, (that - base).x); \n    if(w > PI) w -= 2 * PI;\n    return min( min( abs(pos - w), abs(pos - w + 2 * PI)), abs(pos - w - 2 * PI)) * 2 < d;\n  }\n}\n\nint main(){\n  int H, R, U, M, S;\n  double du, dm, ds;\n  while(cin >> H >> R, H){\n    vector< Point > h(H);\n    for(int i = 0; i < H; i++){\n      cin >> h[i];\n    }\n    cin >> U >> M >> S >> du >> dm >> ds;\n    du *= PI / 180.0;\n    dm *= PI / 180.0;\n    ds *= PI / 180.0;\n\n    vector< Point > umx[3]; //umx[0]のみが届く日数が最大の家\n\n    umx[0].resize(U);\n    for(int i = 0; i < U; i++){\n      cin >> umx[0][i];\n    }\n    umx[1].resize(M);\n    for(int i = 0; i < M; i++){\n      cin >> umx[1][i];\n    }\n    umx[2].resize(M);\n    for(int i = 0; i < S; i++){\n      cin >> umx[2][i];\n    }\n    vector< int > home( H, 0);\n    for(int i = 0; i < R; i++){\n      double w, a; // w: 風の向かう方向θ a: 強さ = 半径\n      cin >> w >> a;\n      w *= PI / 180.0;\n      for(int j = 0; j < H; j++){\n\n        bool flag = Contain( du, a, w, Point( 0, 0), h[j]);\n        for(int k = 0; k < U && flag; k++){ // h[j]がこの扇形に入ってたらうれしみ\n          flag &= !Contain( du, a, w, umx[0][k], h[j]);\n        }\n        for(int k = 0; k < M && flag; k++){ // h[j]がこの扇形に入ってたらかなしみ\n          flag &= !Contain( dm, a, w, umx[1][k], h[j]);\n        }\n        for(int k = 0; k < S && flag; k++){ // 同上\n          flag &= !Contain( ds, a, w, umx[2][k], h[j]);\n        }\n        home[j] += flag; // うれしみの日数をインクリメント\n      }\n    }\n\n    int ret = *max_element( home.begin(), home.end());\n    if(ret == 0) cout << \"NA\" << endl;\n    else {\n      bool first = false;\n      for(int i = 0; i < H; i++){\n        if(ret == home[i]) cout << (first++ ? \" \" : \"\") << i + 1;\n      }\n      cout << endl;\n    }\n  }\n}"
  },
  {
    "language": "C++",
    "code": "#include <stdio.h>\n#include <math.h>\n#include <algorithm>\n#include <vector>\n#include <iostream>\nusing namespace std;\n#define PI 3.14159265\n#define pb push_back\nint main()\n{\n\twhile(1)\n\t{\n\t\tint h,r;\n\t\tdouble x[105];\n\t\tdouble y[105];\n\t\tcin >> h >> r;\n\t\tif(h == 0 && r == 0) return 0;\n\t\tfor(int i=0;i<h;i++)\n\t\t{\n\t\t\tscanf(\"%lf %lf\",&x[i],&y[i]);\n\t\t}\n\t\tint u,m,s;\n\t\tdouble du,dm,ds;\n\t\tscanf(\"%d%d%d%lf%lf%lf\",&u,&m,&s,&du,&dm,&ds);\n\t\tdouble ux[15],uy[15];\n\t\tdouble mx[15],my[15];\n\t\tdouble sx[15],sy[15];\n\t\tfor(int i=0;i<u;i++) scanf(\"%lf %lf\",&ux[i],&uy[i]);\n\t\tfor(int i=0;i<m;i++) scanf(\"%lf %lf\",&mx[i],&my[i]);\n\t\tfor(int i=0;i<s;i++) scanf(\"%lf %lf\",&sx[i],&sy[i]);\n\t\tdouble w[105],a[105];\n\t\tfor(int i=0;i<r;i++)\n\t\t{\n\t\t\tscanf(\"%lf %lf\",&w[i],&a[i]);\n\t\t}\n\t\tvector<int>ans;\n\t\tint res = 1;\n\t\tfor(int i=0;i<h;i++)\n\t\t{\n\t\t\tbool ok[105]={};\n\t\t\t{\n\t\t\t\tdouble ang = atan2(y[i],x[i])*180.0/PI;\n\t\t\t\tif(ang < 0.0) ang += 360.0;\n\t\t\t\tfor(int k=0;k<r;k++)\n\t\t\t\t{\n\t\t\t\t\tdouble beg = w[k]-du/2.0;\n\t\t\t\t\tdouble en = w[k]+du/2.0;\n\t\t\t\t\tif(beg < 0.0) {beg += 360.0; en += 360.0;}\n\t\t\t\t\tif( (beg <= ang && ang <= en) || (beg <= ang+360.0 && ang+360.0 <= en) )\n\t\t\t\t\t{\n\t\t\t\t\t\tif((x[i])*(x[i])+(y[i])*(y[i]) <= a[k]*a[k])\n\t\t\t\t\t\t{\n\t\t\t\t\t\t\tok[k] = true;\n\t\t\t\t\t\t}\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t}\n\t\t\tfor(int j=0;j<u;j++)\n\t\t\t{\n\t\t\t\tdouble ang = atan2(y[i]-uy[j],x[i]-ux[j])*180.0/PI;\n\t\t\t\tif(ang < 0.0) ang += 360.0;\n\t\t\t\tfor(int k=0;k<r;k++)\n\t\t\t\t{\n\t\t\t\t\tdouble beg = w[k]-du/2.0;\n\t\t\t\t\tdouble en = w[k]+du/2.0;\n\t\t\t\t\tif(beg < 0.0) {beg += 360.0; en += 360.0;}\n\t\t\t\t\tif( (beg <= ang && ang <= en) || (beg <= ang+360.0 && ang+360.0 <= en) )\n\t\t\t\t\t{\n\t\t\t\t\t\tif((x[i]-ux[j])*(x[i]-ux[j])+(y[i]-uy[j])*(y[i]-uy[j]) <= a[k]*a[k])\n\t\t\t\t\t\t{\n\t\t\t\t\t\t\tok[k] = false;\n\t\t\t\t\t\t}\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t}\n\t\t\tfor(int j=0;j<m;j++)\n\t\t\t{\n\t\t\t\tdouble ang = atan2(y[i]-my[j],x[i]-mx[j])*180.0/PI;\n\t\t\t\tif(ang < 0.0) ang += 360.0;\n\t\t\t\tfor(int k=0;k<r;k++)\n\t\t\t\t{\n\t\t\t\t\tdouble beg = w[k]-dm/2.0;\n\t\t\t\t\tdouble en = w[k]+dm/2.0;\n\t\t\t\t\tif(beg < 0.0) {beg += 360.0; en += 360.0;}\n\t\t\t\t\tif( (beg <= ang && ang <= en) || (beg <= ang+360.0 && ang+360.0 <= en) )\n\t\t\t\t\t{\n\t\t\t\t\t\tif((x[i]-mx[j])*(x[i]-mx[j])+(y[i]-my[j])*(y[i]-my[j]) <= a[k]*a[k])\n\t\t\t\t\t\t{\n\t\t\t\t\t\t\tok[k] = false;\n\t\t\t\t\t\t}\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t}\n\t\t\tfor(int j=0;j<s;j++)\n\t\t\t{\n\t\t\t\tdouble ang = atan2(y[i]-sy[j],x[i]-sx[j])*180.0/PI;\n\t\t\t\tif(ang < 0.0) ang += 360.0;\n\t\t\t\tfor(int k=0;k<r;k++)\n\t\t\t\t{\n\t\t\t\t\tdouble beg = w[k]-ds/2.0;\n\t\t\t\t\tdouble en = w[k]+ds/2.0;\n\t\t\t\t\tif(beg < 0.0) {beg += 360.0; en += 360.0;}\n\t\t\t\t\tif( (beg <= ang && ang <= en) || (beg <= ang+360.0 && ang+360.0 <= en) )\n\t\t\t\t\t{\n\t\t\t\t\t\tif((x[i]-sx[j])*(x[i]-sx[j])+(y[i]-sy[j])*(y[i]-sy[j]) <= a[k]*a[k])\n\t\t\t\t\t\t{\n\t\t\t\t\t\t\tok[k] = false;\n\t\t\t\t\t\t}\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t}\n\t\t\tint c = count(ok,ok+r,true);\n\t\t\tif(res == c) ans.pb(i+1);\n\t\t\telse if(res < c)\n\t\t\t{\n\t\t\t\tans.clear(); res = c; ans.pb(i+1);\n\t\t\t}\n\t\t}\n\t\tif(ans.empty()) puts(\"NA\");\n\t\telse for(int i=0;i<ans.size();i++) printf(\"%d%c\",ans[i],(i==ans.size()-1)?'\\n':' ');\n\t}\n}"
  },
  {
    "language": "C++",
    "code": "#include<bits/stdc++.h>\n\n#define REP(i,s,n) for(int i=s;i<n;i++)\n#define rep(i,n) REP(i,0,n)\n#define EPS (1e-7)\n#define COUNTER_CLOCKWISE 1\n#define CLOCKWISE -1 \n#define ONLINE_BACK 2\n#define ONLINE_FRONT -2\n#define ON_SEGMENT 0\n#define equals(a,b) (fabs((a)-(b)) < EPS)\n\nusing namespace std;\n\nconst int IINF = INT_MAX;\n\nclass Point{\npublic:\n  double x,y;\n\n  Point(double x = -IINF,double y = -IINF): x(x),y(y){}\n\n  Point operator + (Point p){return Point(x+p.x,y+p.y);}\n  Point operator - (Point p){return Point(x-p.x,y-p.y);}\n\n};\n\ndouble dot(Point a,Point b){ return a.x*b.x + a.y*b.y; }\n\ndouble cross(Point a,Point b){ return a.x*b.y - a.y*b.x; }\n\ndouble norm(Point a){ return a.x*a.x+a.y*a.y; }\n\ndouble abs(Point a){ return sqrt(norm(a)); }\n\nPoint rotate(Point a,double rad){ return Point(cos(rad)*a.x - sin(rad)*a.y,sin(rad)*a.x + cos(rad)*a.y); }\n\ndouble toRad(double agl){ return agl*M_PI/180.0; }\n\nint ccw(Point p0,Point p1,Point p2){\n  Point a = p1-p0;\n  Point b = p2-p0;\n  if(cross(a,b) > EPS)return COUNTER_CLOCKWISE;\n  if(cross(a,b) < -EPS)return CLOCKWISE;\n  if(dot(a,b) < -EPS)return ONLINE_BACK;\n  if(norm(a) < norm(b))return ONLINE_FRONT;\n  return ON_SEGMENT;\n}\n\nconst int MAX_N = 110;\nint N,M,Ume,Momo,SakuraHappyInnovation,counter[MAX_N],limit[3];\nPoint ps[MAX_N],p[3][20];\ndouble d[3],w[110],a[110];\n\nbool LT(double A,double B)  { return !equals(A,B) && A < B; }\nbool LTE(double A,double B) { return  equals(A,B) || A < B; }\n\nbool inside(Point h,Point t,double ta,double tw,double td){\n  double rad_w = toRad(tw), rad_d = toRad(td/2.0);\n  Point tmp = Point(ta*cos(rad_w),ta*sin(rad_w));\n  Point alpha = rotate(tmp,-rad_d) + t;\n  Point beta  = rotate(tmp,rad_d)  + t;\n  int res_ccw = ccw(t,alpha,h);\n  bool res1 = ( res_ccw != CLOCKWISE );\n  res_ccw = ccw(t,beta,h);\n  bool res2 = ( res_ccw != COUNTER_CLOCKWISE );\n  double dist = abs(h-t);\n  bool res3 = LTE(dist,ta);\n  return res1 && res2 && res3;\n}\n\ninline void compute(){\n  rep(i,N) counter[i] = 0;\n  rep(_,M){\n    rep(i,N){\n      bool failed = false;\n      if( inside(ps[i],Point(0,0),a[_],w[_],d[0]) ) {\n        rep(j,3) if( !failed ) rep(k,limit[j]) failed |= inside(ps[i],p[j][k],a[_],w[_],d[j]);\n      } else failed = true;\n      if( !failed ) ++counter[i];\n    }\n  }\n  int maxi = -1;\n  rep(i,N) if( counter[i] != 0 ) maxi = max(maxi,counter[i]);\n  if( maxi == -1 ) puts(\"NA\");\n  else {\n    bool first = true;\n    rep(i,N) if( counter[i] == maxi ){\n      if( !first ) printf(\" \"); first = false;\n      printf(\"%d\",i+1);\n    }\n    puts(\"\");\n  }\n}\n\nint main(){\n  while( scanf(\"%d %d\",&N,&M), N|M ){\n    rep(i,N) scanf(\"%lf %lf\",&ps[i].x,&ps[i].y);\n    scanf(\"%d %d %d %lf %lf %lf\",&Ume,&Momo,&SakuraHappyInnovation,d,d+1,d+2);\n    limit[0] = Ume, limit[1] = Momo, limit[2] = SakuraHappyInnovation;\n    rep(i,Ume) scanf(\"%lf %lf\",&p[0][i].x,&p[0][i].y);\n    rep(i,Momo) scanf(\"%lf %lf\",&p[1][i].x,&p[1][i].y);\n    rep(i,SakuraHappyInnovation) scanf(\"%lf %lf\",&p[2][i].x,&p[2][i].y);\n    rep(i,M) scanf(\"%lf %lf\",w+i,a+i);\n    compute();\n  }\n  return 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include <iostream>\n#include <cstdio>\n#include <vector>\n#include <list>\n#include <cmath>\n#include <fstream>\n#include <algorithm>\n#include <string>\n#include <queue>\n#include <set>\n#include <map>\n#include <complex>\n#include <iterator>\n#include <cstdlib>\n#include <cstring>\n#include <sstream>\n#include <stack>\n#include <climits>\n#include <deque>\n#include <bitset>\n#include <cassert>\n#include <ctime>\nusing namespace std;\n\ntypedef long long ll;\ntypedef pair<int,int> pii;\nconst int dy[]={-1,0,1,0},dx[]={0,1,0,-1};\n// adjust problem by problem\nconst double EPS=1e-8;\nconst double PI=acos(-1.0);\n#ifdef __GNUC__\nint popcount(int n){return __builtin_popcount(n);}\nint popcount(ll n){return __builtin_popcountll(n);}\n#endif\n#ifndef __GNUC__\ntemplate<class T> int popcount(T n){int cnt=0;while(n){if(n%2)cnt++;n/=2;}return cnt;}\n#endif\ntemplate<class T>int SIZE(T a){return a.size();}\ntemplate<class T>string IntToString(T num){string res;stringstream ss;ss<<num;return ss.str();}\ntemplate<class T>T StringToInt(string str){T res=0;for(int i=0;i<SIZE(str);i++)res=(res*10+str[i]-'0');return res;}\ntemplate<class T>T gcd(T a,T b){if(b==0)return a;return gcd(b,a%b);}\ntemplate<class T>T lcm(T a,T b){return a/gcd(a,b)*b;}\ntemplate<class T> void PrintSeq(T &a,int sz){for(int i=0;i<sz;i++){cout<<a[i];if(sz==i+1)cout<<endl;else cout<<' ';}}\nbool EQ(double a,double b){return abs(a-b)<EPS;}\nvoid fastStream(){cin.tie(0);std::ios_base::sync_with_stdio(0);}\nvector<string> split(string str,char del){\n  vector<string> res;\n  for(int i=0,s=0;i<SIZE(str);i++){\n    if(str[i]==del){if(i-s!=0)res.push_back(str.substr(s,i-s));s=i+1;}\n    else if(i==SIZE(str)-1){res.push_back(str.substr(s));}\n  }\n  return res;\n}\n\n\nint H,R;\ndouble hx[101],hy[101];\nint U,M,S;\ndouble du,dm,ds;\ndouble ux[101],uy[101];\ndouble mx[101],my[101];\ndouble sx[101],sy[101];\ndouble w[101],a[101];\n\ntypedef complex<double> P;\n// テ・ツ??ァツゥツ?\ndouble dot(const P &a, const P &b) {\n  return (a.real() * b.real() + a.imag() * b.imag());\n}\n// テ・ツ、ツ姪ァツゥツ?\ndouble cross(const P &a, const P &b) {\n  return (a.real() * b.imag() - a.imag() * b.real());\n}\n// 2テ」ツδ凖」ツつッテ」ツδ暗」ツδォテゥツ鳴禿」ツ?ョティツァツ津・ツコツヲ\n// aテ」ツ?凝」ツつ叡テ」ツ?クテ・ツキツヲテ・ツ堕ィテ」ツつ甘」ツ?ァテ、ツスツ陛・ツコツヲテ」ツ??0->2*PI)\ndouble diffAngle(const P &a,const P &b){\n  double angle=atan2(cross(a,b),dot(a,b));\n  if(angle<0)return 2*PI+angle;\n  return angle;\n}\n    \n// テ・ツコツァテヲツィツ凖」ツ?ョテ・ツ崢榲ィツサツ「(テ・ツコツァテヲツィツ冪テ」ツ?ォテ」ツ?づ」ツつ凝ァツつケテ」ツつ?テ・ツ債甘ヲツ卍づィツィツ暗・ツ崢榲」ツつ甘」ツ?ォa(テ」ツδゥテ」ツつクテ」ツつ「テ」ツδウ)テ・ツ崢榲ィツサツ「)\nP roundPoint(const P &p,double a){\n  return P(cos(a)*p.real()-sin(a)*p.imag(),sin(a)*p.real()+cos(a)*p.imag());\n}\n// テ」ツ?づ」ツつ凝・ツ?エテヲツ可?」ツ?凝」ツつ嘉・ツシツ陛ィツカツ甘」ツ?療・ツ?暗」ツ?クテ・ツ個づ」ツ??」ツ?古・ツアツ甘」ツ?湘」ツ?凝」ツ?ゥテ」ツ??」ツ??\nbool check(double x,double y,double wv,double dv,double av,int cx,int cy){\n  cx-=x,cy-=y;\n  x=y=0;\n  double dist=sqrt(pow(x-cx,2)+pow(y-cy,2));\n  if(!(EQ(dist,av)||dist<av))return false;\n  P rv=roundPoint(P(1,0),wv/180.0*PI);\n  double diff=diffAngle(rv,P(cx,cy))/PI*180;\n  if(diff>=180)diff=360-diff;\n  return (EQ(diff,dv/2)||diff<dv/2);\n}\n\nint main(){\n  //ifstream cin(\"in.txt\");\n  while(cin>>H>>R&&(H|R)){\n    for(int i=0;i<H;i++)cin>>hx[i]>>hy[i];\n    cin>>U>>M>>S>>du>>dm>>ds;\n    for(int i=0;i<U;i++)cin>>ux[i]>>uy[i];\n    for(int i=0;i<M;i++)cin>>mx[i]>>my[i];\n    for(int i=0;i<S;i++)cin>>sx[i]>>sy[i];\n    for(int i=0;i<R;i++)cin>>w[i]>>a[i];\n    int maxVal=0;\n    vector<int> cand;\n    // テ・ツョツカテ」ツ?氾」ツ?ィテ」ツ?ォティツィツ暗ァツョツ?\n    for(int h=0;h<H;h++){\n      int cnt=0;\n      for(int d=0;d<R;d++){\n        // テ・ツ篠淌ァツつケテ」ツ?凝」ツつ嘉」ツ?ォテ」ツ?甘」ツ??」ツ?古・ツアツ甘」ツ??\n        if(check(0,0,w[d],du,a[d],hx[h],hy[h])){\n          //cout<<h<<\" \"<<d<<endl;\n          // if(h==1){\n          //   cout<<\"a\"<<endl;\n          // }\n          // テ、ツサツ姪」ツ?ョテ・ツ?エテヲツ可?」ツ?凝」ツつ嘉」ツ?ォテ」ツ?甘」ツ??」ツ?古・ツアツ甘」ツ??」ツ?ヲテ」ツ?ッテ」ツ??」ツ?妥」ツ?ェテ」ツ??\n          bool no=false;\n          for(int i=0;i<U;i++)no|=check(ux[i],uy[i],w[d],du,a[d],hx[h],hy[h]);\n          for(int i=0;i<M;i++)no|=check(mx[i],my[i],w[d],dm,a[d],hx[h],hy[h]);\n          for(int i=0;i<S;i++)no|=check(sx[i],sy[i],w[d],ds,a[d],hx[h],hy[h]);\n          if(!no){\n            //cout<<h<<\" \"<<d<<endl;\n            cnt++;\n          }\n        }\n      }\n      //cout<<h<<\" \"<<cnt<<endl;\n      if(maxVal<cnt){\n        maxVal=cnt;\n        cand.clear();\n        cand.push_back(h+1);\n      }\n      else if(maxVal!=0&&maxVal==cnt)cand.push_back(h+1);\n    }\n    if(cand.size()==0)cout<<\"NA\"<<endl;\n    else{\n      for(int i=0;i<(int)cand.size();i++){\n        cout<<cand[i];\n        if(i==(int)cand.size()-1)cout<<endl;\n        else cout<<\" \";\n      }\n    }\n  }\n  \n  return 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include<bits/stdc++.h>\n\nusing namespace std;\n\nint H, R, U, M, S, DU, DM, DS;\nint HouseX[100], HouseY[100];\nint UmeX[100], UmeY[100];\nint MomoX[100], MomoY[100];\nint SakuraX[100], SakuraY[100];\nint WindD[100], WindR[100];\nint Days[100];\n\nconst double PI = 3.1415926;\n\n\nbool isReachHouse(int x0, int y0, int x1, int y1, int d, int w, int a) {\n\tdouble len, degree;\n\n\tlen = sqrt(pow((x1 - x0), 2) + pow((y1 - y0), 2));\n\tif (len > a) {\n\t\treturn false;\n\t}\n\tdegree = atan2((y1 - y0), (x1 - x0)) * 180 / PI;\n\t//cout << \"degree=\" << degree << endl;\n\tif (w - d / 2 <= degree && degree <= w + d / 2) {\n\t\treturn true;\n\t}\n\n\tdegree += 360;\n\tif (w - d / 2 <= degree && degree <= w + d / 2) {\n\t\treturn true;\n\t}\n\treturn false;\n}\n\nvoid solve() {\n\tint max;\n\tbool flag;\n\n\tfor (int i = 0; i < R; ++i) {\n\t\tfor (int j = 0; j < H; ++j) {\n\t\t\tif (!isReachHouse(0, 0, HouseX[j], HouseY[j], DU, WindD[i], WindR[i])) {\n\t\t\t\tcontinue;\n\t\t\t}\n\n\t\t\tflag = false;\n\t\t\tfor (int k = 0; k < U; ++k) {\n\t\t\t\tif (isReachHouse(UmeX[k], UmeY[k], HouseX[j], HouseY[j], DU, WindD[i], WindR[i])) {\n\t\t\t\t\tflag = true;\n\t\t\t\t\tbreak;\n\t\t\t\t}\n\t\t\t}\n\t\t\tif (flag) {\n\t\t\t\tcontinue;\n\t\t\t}\n\n\t\t\tfor (int k = 0; k < M; ++k) {\n\t\t\t\tif (isReachHouse(MomoX[k], MomoY[k], HouseX[j], HouseY[j], DM, WindD[i], WindR[i])) {\n\t\t\t\t\tflag = true;\n\t\t\t\t\tbreak;\n\t\t\t\t}\n\t\t\t}\n\t\t\tif (flag) {\n\t\t\t\tcontinue;\n\t\t\t}\n\n\t\t\tfor (int k = 0; k < S; ++k) {\n\t\t\t\tif (isReachHouse(SakuraX[k], SakuraY[k], HouseX[j], HouseY[j], DS, WindD[i], WindR[i])) {\n\t\t\t\t\tflag = true;\n\t\t\t\t\tbreak;\n\t\t\t\t}\n\t\t\t}\n\t\t\tif (flag) {\n\t\t\t\tcontinue;\n\t\t\t}\n\t\t\t++Days[j];\n\t\t}\n\t}\n\n\tmax = Days[0];\n\tfor (int i = 1; i < H; ++i) {\n\t\tif (Days[i] > max) {\n\t\t\tmax = Days[i];\n\t\t}\n\t}\n\n\tif (max == 0) {\n\t\tcout << \"NA\" << endl;\n\t\treturn;\n\t}\n\n\tflag = false;\n\tfor (int i = 0; i < H; ++i) {\n\t\tif (Days[i] == max) {\n\t\t\tif (flag) {\n\t\t\t\tcout << \" \";\n\t\t\t}\n\t\t\tcout << i+1;\n\t\t\tflag = true;\n\t\t}\n\t}\n\tcout << endl;\n}\n\nvoid InputData() {\n\tfor (int i = 0; i < H; ++i) {\n\t\tcin >> HouseX[i] >> HouseY[i];\n\t}\n\t\n\tcin >> U >> M >> S >> DU >> DM >> DS;\n\t\n\tfor (int i = 0; i < U; ++i) {\n\t\tcin >> UmeX[i] >> UmeY[i];\n\t}\n\n\tfor (int i = 0; i < M; ++i) {\n\t\tcin >> MomoX[i] >> MomoY[i];\n\t}\n\n\tfor (int i = 0; i < S; ++i) {\n\t\tcin >> SakuraX[i] >> SakuraY[i];\n\t}\n\n\tfor (int i = 0; i < R; ++i) {\n\t\tcin >> WindD[i] >> WindR[i];\n\t}\n\n\t//show\n#if 0\n\tfor (int i = 0; i < H; ++i) {\n\t\tcout << HouseX[i] << \" \" << HouseY[i] << endl;\n\t}\n\tcout << U << \" \" << M << \" \" << S << \" \" << DU << \" \" << DM << \" \" << DS << endl;\n\tfor (int i = 0; i < U; ++i) {\n\t\tcout << UmeX[i] << \" \" << UmeY[i] << endl;\n\t}\n\tfor (int i = 0; i < M; ++i) {\n\t\tcout << MomoX[i] << \" \" << MomoY[i] << endl;\n\t}\n\tfor (int i = 0; i < S; ++i) {\n\t\tcout << SakuraX[i] << \" \" << SakuraY[i] << endl;\n\t}\n\tfor (int i = 0; i < R; ++i) {\n\t\tcout << WindD[i] << \" \" << WindR[i] << endl;\n\t}\n#endif\n}\n\nint main() {\n\t\n\twhile (cin >> H >> R, H) {\n\t\tmemset(Days, 0, sizeof(Days));\n\t\tInputData();\n\t\tsolve();\n\t}\n\t\n\treturn 0;\n}\n\n"
  },
  {
    "language": "C++",
    "code": "#include <iostream>\n#include <iomanip>\n#include <complex>\n#include <vector>\n#include <algorithm>\n#include <cmath>\nusing namespace std;\nconst double EPS = 1e-10;\nconst double INF = 1e12;\nconst double PI = acos(-1);\n#define EQ(n,m) (abs((n)-(m)) < EPS)\n#define X real()\n#define Y imag()\ntypedef complex<double> P;\ntypedef vector<P> VP;\ndouble dot(P a, P b){\n    return (conj(a)*b).X;\n}\ndouble cross(P a, P b){\n    return (conj(a)*b).Y;\n}\nP rotate(const P &p, double rad){\n    return p *P(cos(rad), sin(rad));\n}\ndouble getangle(P a, P b){\n    return abs(arg(a/b));\n}\n\nvoid inputXY(P &p){\n    double x,y;\n    cin >> x >> y;\n    p = P(x,y);\n}\n\nbool in_sector(P s, P g, double w, double d, double a){\n    g -= s;\n    double wrad = w/180 *PI;\n    P dir = rotate(P(1, 0), wrad);\n    double drad = (d/2)/180 *PI;\n    double angle = getangle(g, dir);\n    return abs(g) < a +EPS && -drad < angle +EPS && angle < drad +EPS;\n}\n\nint main(){\n    while(1){\n        int h,r;\n        cin >> h >> r;\n        if(h==0 && r==0) break;\n\n        VP house(h);\n        for(int i=0; i<h; i++) inputXY(house[i]);\n\n        int u,m,s, du,dm,ds;\n        cin >> u >> m >> s >> du >> dm >> ds;\n        VP pu(u), pm(m), ps(s);\n        for(int i=0; i<u; i++) inputXY(pu[i]);\n        for(int i=0; i<m; i++) inputXY(pm[i]);\n        for(int i=0; i<s; i++) inputXY(ps[i]);\n        vector<int> w(r), a(r);\n        for(int i=0; i<r; i++) cin >> w[i] >> a[i];\n        \n        vector<int> reach(h, 0);\n        for(int i=0; i<h; i++){\n            for(int j=0; j<r; j++){\n                if(!in_sector(P(0,0), house[i], w[j], du, a[j])){\n                    continue;\n                }\n                bool only = true;\n                for(int k=0; k<u && only; k++){\n                    if(in_sector(pu[k], house[i], w[j], du, a[j])){\n                        only = false;\n                    }\n                }\n                for(int k=0; k<m && only; k++){\n                    if(in_sector(pm[k], house[i], w[j], dm, a[j])){\n                        only = false;\n                    }\n                }\n                for(int k=0; k<s && only; k++){\n                    if(in_sector(ps[k], house[i], w[j], ds, a[j])){\n                        only = false;\n                    }\n                }\n                if(only){\n                    reach[i]++;\n                }\n            }\n        }\n\n        int max = *max_element(reach.begin(), reach.end());\n        if(max == 0){\n            cout << \"NA\" << endl;\n        }else{\n            vector<int> ans;\n            for(int i=0; i<h; i++){\n                if(reach[i] == max){\n                    ans.push_back(i+1);\n                }\n            }\n            for(int i=0; i<(int)ans.size()-1; i++){\n                cout << ans[i] << \" \";\n            }\n            cout << ans.back() << endl;\n        }\n    }\n    return 0;\n}\n"
  },
  {
    "language": "C++",
    "code": "#include <stdio.h>\n#include <string.h>\n#include <math.h>\n#define PI 3.1415926535897932384626433832795028841971693993751058209749445923078164\n\nstruct point{\n\tint x,y;\n};\n\nstruct wind{\n\tint w,a;\n};\n\ndouble getlen(int x1,int y1,int x2,int y2){\n\treturn sqrt(pow((x1-x2)*1.0,2)+pow((y1-y2)*1.0,2));\n}\n\nint check(int N,point *tree,point house,wind wind,int dtree){\n\tint i;\n\tdouble rad,dig;\n\n\tfor(i = 0;i < N;i++){\n\t\tif(wind.a*1.0 < getlen(house.x,house.y,tree[i].x,tree[i].y)){\n\t\t\treturn 1;\n\t\t}\n\t\trad = atan2((house.y-tree[i].y)*1.0,(house.x-tree[i].x)*1.0);\n\t\tdig = fmod((rad * 180.0 / PI)+360.0,360.0);\n\n\t\tif(wind.w*1.0-dtree/2.0+90.0 <= dig+90.0 && wind.w*1.0+dtree/2.0+90.0 >= dig+90.0){\n\t\t\treturn 0;\n\t\t}\n    }\n\n\treturn 1;\n}\n\nint check2(point house,wind wind,int dtree){\n\tdouble rad,dig;\n\n\tif(wind.a*1.0 < getlen(house.x,house.y,0,0)){\n\t\treturn 0;\n\t}\n\n\trad = atan2(house.y*1.0,house.x*1.0);\n\tdig = fmod((rad * 180.0 / PI)+360.0,360.0);\n\n\tif(!(wind.w*1.0-dtree/2.0+90.0 <= dig+90.0 && wind.w*1.0+dtree/2.0+90.0 >= dig+90.0)){\n\t\treturn 0;\n\t}\n\n\treturn 1;\n}\n\nvoid max(int H,int *ok){\n\tint i,p,dmax;\n\tint tmp[100];\n\n\tp = 0;\n\tdmax = 0;\n\n\tfor(i = 0;i < H;i++){\n\t\tif(dmax < ok[i]){\n\t\t\tdmax = ok[i];\n\t\t\ttmp[0] = i+1;\n\t\t\tp = 1;\n\t\t}else if(dmax != 0 && dmax == ok[i]){\n\t\t\ttmp[p++] = i+1;\n\t\t}\n\t}\n\n\tif(dmax == 0){\n\t\tprintf(\"NA\\n\");\n\t}else{\n\t\tfor(i = 0;i < p;i++){\n\t\t\tprintf(\"%d%c\",tmp[i],(i == p-1) ? '\\n' : ' ');\n\t\t}\n\t}\n}\n\nint main(){\n\tint i,j,H,R,U,M,S,du,dm,ds;\n\tint ok[100];\n\tpoint h[100],u[10],m[10],s[10];\n\twind wind[100];\n\n\twhile(1){\n\t\tmemset(ok,0,sizeof(ok));\n\t\tscanf(\"%d %d\",&H,&R);\n\t\tif(H == 0 && R == 0){\n\t\t\tbreak;\n\t\t}\n\t\tfor(i = 0;i < H;i++){\n\t\t\tscanf(\"%d %d\",&h[i].x,&h[i].y);\n\t\t}\n\t\tscanf(\"%d %d %d %d %d %d\",&U,&M,&S,&du,&dm,&ds);\n\t\tfor(i = 0;i < U;i++){\n\t\t\tscanf(\"%d %d\",&u[i].x,&u[i].y);\n\t\t}\n\t\tfor(i = 0;i < M;i++){\n\t\t\tscanf(\"%d %d\",&m[i].x,&m[i].y);\n\t\t}\n\t\tfor(i = 0;i < S;i++){\n\t\t\tscanf(\"%d %d\",&s[i].x,&s[i].y);\n\t\t}\n\t\tfor(i = 0;i < R;i++){\n\t\t\tscanf(\"%d %d\",&wind[i].w,&wind[i].a);\n\t\t}\n\t\n\t\tfor(i = 0;i < R;i++){\n\t\t\tfor(j = 0;j < H;j++){\n\t\t\t\tif(!check2(h[j],wind[i],du)){\n\t\t\t\t\tcontinue;\n\t\t\t\t}\n\t\t\t\tif(!check(U,u,h[j],wind[i],du)){\n\t\t\t\t\tcontinue;\n\t\t\t\t}\n\t\t\t\tif(!check(M,m,h[j],wind[i],dm)){\n\t\t\t\t\tcontinue;\n\t\t\t\t}\n\t\t\t\tif(!check(S,s,h[j],wind[i],ds)){\n\t\t\t\t\tcontinue;\n\t\t\t\t}\n\t\t\t\tok[j]++;\n\t\t\t}\n\t\t}\n\t\n\t\tmax(H,ok);\n\t}\n\n\treturn 0;\n}"
  },
  {
    "language": "C++",
    "code": "\n//自分の梅は任意の地点でかおるとする。→間違い。\n//EPSはつけない。\n//扇形と家は接しないので、距離はsqrtで求めた。\n\n#include<iostream>\n#include<cmath>\n#include<vector>\n#define rep(i,n) for(i = 0;i < n;i++)\n#define PI 3.14159265358979\nusing namespace std;\n\ntypedef pair<double,double> P;\n\nint H,R;\t\t\t\t//家数,日数\nint hx[100],hy[100];\t//家の座標\nint U,M,S;\t\t\t\t//梅、桃、桜の数\nint du,dm,ds;\t\t\t//梅、桃、桜の扇形の中心角\nint ux[100],uy[100];\t//梅の座標\nint mx[100],my[100];\t//桃の座標\nint sx[100],sy[100];\t//桜の座標\nint w[100],a[100];\t\t//扇形の方向(角度),風の強さ\n\n//半径,角度の順で格納し、返す\n//rotateは角度補正( 補正 = rotate*360 )\nP POLAR( int treex,int treey,int housex,int housey,int rotate )\n{\n\tP ans;\n\tans.first = (housex-treex)*(housex-treex) + (housey-treey)*(housey-treey);\n\tans.first = sqrt( ans.first );\n\tif( housex == treex && housey > treey )\n\t\tans.second = 90;\n\telse if( housex == treex && housey < treey )\n\t\tans.second = -90;\n\telse\n\t\tans.second = atan2( (double)housey - treey, (double)housex - treex ) * 180 / PI;\n\tans.second += 360*rotate;\n\treturn ans;\n}\n\nint main()\n{\n\tint i,j,k,l;\n\twhile( cin >> H >> R )\n\t{\n\t\tint day[100] = {0};\t\t//i番目の家において、他の木の香りが届かなかった日数\n\n\t\tif( H == 0 && R == 0 )\n\t\t\tbreak;\n\t\trep(i,H)\n\t\t\tcin >> hx[i] >> hy[i];\n\t\tcin >> U >> M >> S >> du >> dm >> ds;\n\t\trep(i,U)\n\t\t\tcin >> ux[i] >> uy[i];\n\t\trep(i,M)\n\t\t\tcin >> mx[i] >> my[i];\n\t\trep(i,S)\n\t\t\tcin >> sx[i] >> sy[i];\n\t\trep(i,R)\n\t\t\tcin >> w[i] >> a[i];\n\t\t//ここから探索\n\t\trep(i,R){\n\t\t\trep(j,H){\n\t\t\t\trep(k,U){\n\t\t\t\t\trep(l,3){\n\t\t\t\t\t\tP t = POLAR( ux[k],uy[k],hx[j],hy[j],l-1 );\n\t\t\t\t\t\t//判定\n\t\t\t\t\t\tif( t.first <= a[i] && fabs( (double)w[i] - t.second ) <= du/2.0 )\n\t\t\t\t\t\t\tbreak;\n\t\t\t\t\t}\n\t\t\t\t\tif(l < 3)\n\t\t\t\t\t\tbreak;\n\t\t\t\t}\n\t\t\t\tif(k < U)\n\t\t\t\t\tcontinue;\n\t\t\t\trep(k,M){\n\t\t\t\t\trep(l,3){\n\t\t\t\t\t\tP t = POLAR( mx[k],my[k],hx[j],hy[j],l-1 );\n\t\t\t\t\t\t//判定\n\t\t\t\t\t\tif( t.first <= a[i] && fabs( (double)w[i] - t.second ) <= dm/2.0 )\n\t\t\t\t\t\t\tbreak;\n\t\t\t\t\t}\n\t\t\t\t\tif(l < 3)\n\t\t\t\t\t\tbreak;\n\t\t\t\t}\n\t\t\t\tif(k < M)\n\t\t\t\t\tcontinue;\n\t\t\t\trep(k,S){\n\t\t\t\t\trep(l,3){\n\t\t\t\t\t\tP t = POLAR( sx[k],sy[k],hx[j],hy[j],l-1 );\n\t\t\t\t\t\t//判定\n\t\t\t\t\t\tif( t.first <= a[i] && fabs( (double)w[i] - t.second ) <= ds/2.0 )\n\t\t\t\t\t\t\tbreak;\n\t\t\t\t\t}\n\t\t\t\t\tif(l < 3)\n\t\t\t\t\t\tbreak;\n\t\t\t\t}\n\t\t\t\tif(k < S)\n\t\t\t\t\tcontinue;\n\n\t\t\t\tif( hx[j]*hx[j] + hy[j]*hy[j] <= a[i]*a[i] )\n\t\t\t\t\tday[j]++;\n\t\t\t}\n\t\t}\n\t\tint maxday = 0;\n\t\trep(i,H){\n\t\t\tmaxday = max( maxday,day[i] );\n\t\t}\n\t\tif( maxday == 0 ){\n\t\t\tcout << \"NA\" << endl;\n\t\t\tcontinue;\n\t\t}\n\t\trep(i,H){\n\t\t\tif( day[i] == maxday ){\n\t\t\t\tcout << i+1;\n\t\t\t\tif( i < H-1 )\n\t\t\t\t\tcout << ' ';\n\t\t\t\telse\n\t\t\t\t\tcout << endl;\n\t\t\t}\n\t\t}\n\t}\n\treturn 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include <stdio.h>\n#include <math.h>\n#include <algorithm>\n#include <vector>\n#include <iostream>\nusing namespace std;\n#define PI 3.14159265\n#define pb push_back\nint main()\n{\n\twhile(1)\n\t{\n\t\tint h,r;\n\t\tdouble x[105];\n\t\tdouble y[105];\n\t\tcin >> h >> r;\n\t\tif(h == 0 && r == 0) return 0;\n\t\tfor(int i=0;i<h;i++)\n\t\t{\n\t\t\tscanf(\"%lf %lf\",&x[i],&y[i]);\n\t\t}\n\t\tint u,m,s;\n\t\tdouble du,dm,ds;\n\t\tscanf(\"%d%d%d%lf%lf%lf\",&u,&m,&s,&du,&dm,&ds);\n\t\tdouble ux[15],uy[15];\n\t\tdouble mx[15],my[15];\n\t\tdouble sx[15],sy[15];\n\t\tfor(int i=0;i<u;i++) scanf(\"%lf %lf\",&ux[i],&uy[i]);\n\t\tfor(int i=0;i<m;i++) scanf(\"%lf %lf\",&mx[i],&my[i]);\n\t\tfor(int i=0;i<s;i++) scanf(\"%lf %lf\",&sx[i],&sy[i]);\n\t\tdouble w[105],a[105];\n\t\tfor(int i=0;i<r;i++)\n\t\t{\n\t\t\tscanf(\"%lf %lf\",&w[i],&a[i]);\n\t\t}\n\t\tvector<int>ans;\n\t\tint res = 1;\n\t\tfor(int i=0;i<h;i++)\n\t\t{\n\t\t\tbool ok[105]={};\n\t\t\t{\n\t\t\t\tdouble ang = atan2(y[i],x[i])*180.0/PI;\n\t\t\t\tif(ang < 0.0) ang += 360.0;\n\t\t\t\tfor(int k=0;k<r;k++)\n\t\t\t\t{\n\t\t\t\t\tdouble beg = w[k]-du/2.0;\n\t\t\t\t\tdouble en = w[k]+du/2.0;\n\t\t\t\t\tif( (beg <= ang && ang <= en) || (beg <= ang+360.0 && ang+360.0 <= en) )\n\t\t\t\t\t{\n\t\t\t\t\t\tif((x[i])*(x[i])+(y[i])*(y[i]) <= a[k]*a[k])\n\t\t\t\t\t\t{\n\t\t\t\t\t\t\tok[k] = true;\n\t\t\t\t\t\t}\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t}\n\t\t\tfor(int j=0;j<u;j++)\n\t\t\t{\n\t\t\t\tdouble ang = atan2(y[i]-uy[j],x[i]-ux[j])*180.0/PI;\n\t\t\t\tif(ang < 0.0) ang += 360.0;\n\t\t\t\tfor(int k=0;k<r;k++)\n\t\t\t\t{\n\t\t\t\t\tdouble beg = w[k]-du/2.0;\n\t\t\t\t\tdouble en = w[k]+du/2.0;\n\t\t\t\t\tif( (beg <= ang && ang <= en) || (beg <= ang+360.0 && ang+360.0 <= en) )\n\t\t\t\t\t{\n\t\t\t\t\t\tif((x[i]-ux[j])*(x[i]-ux[j])+(y[i]-uy[j])*(y[i]-uy[j]) <= a[k]*a[k])\n\t\t\t\t\t\t{\n\t\t\t\t\t\t\tok[k] = false;\n\t\t\t\t\t\t}\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t}\n\t\t\tfor(int j=0;j<m;j++)\n\t\t\t{\n\t\t\t\tdouble ang = atan2(y[i]-my[j],x[i]-mx[j])*180.0/PI;\n\t\t\t\tif(ang < 0.0) ang += 360.0;\n\t\t\t\tfor(int k=0;k<r;k++)\n\t\t\t\t{\n\t\t\t\t\tdouble beg = w[k]-dm/2.0;\n\t\t\t\t\tdouble en = w[k]+dm/2.0;\n\t\t\t\t\tif( (beg <= ang && ang <= en) || (beg <= ang+360.0 && ang+360.0 <= en) )\n\t\t\t\t\t{\n\t\t\t\t\t\tif((x[i]-mx[j])*(x[i]-mx[j])+(y[i]-my[j])*(y[i]-my[j]) <= a[k]*a[k])\n\t\t\t\t\t\t{\n\t\t\t\t\t\t\tok[k] = false;\n\t\t\t\t\t\t}\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t}\n\t\t\tfor(int j=0;j<s;j++)\n\t\t\t{\n\t\t\t\tdouble ang = atan2(y[i]-sy[j],x[i]-sx[j])*180.0/PI;\n\t\t\t\tif(ang < 0.0) ang += 360.0;\n\t\t\t\tfor(int k=0;k<r;k++)\n\t\t\t\t{\n\t\t\t\t\tdouble beg = w[k]-ds/2.0;\n\t\t\t\t\tdouble en = w[k]+ds/2.0;\n\t\t\t\t\tif( (beg <= ang && ang <= en) || (beg <= ang+360.0 && ang+360.0 <= en) )\n\t\t\t\t\t{\n\t\t\t\t\t\tif((x[i]-sx[j])*(x[i]-sx[j])+(y[i]-sy[j])*(y[i]-sy[j]) <= a[k]*a[k])\n\t\t\t\t\t\t{\n\t\t\t\t\t\t\tok[k] = false;\n\t\t\t\t\t\t}\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t}\n\t\t\tint c = count(ok,ok+r,true);\n\t\t\tif(res == c) ans.pb(i+1);\n\t\t\telse if(res < c)\n\t\t\t{\n\t\t\t\tans.clear(); res = c; ans.pb(i+1);\n\t\t\t}\n\t\t}\n\t\tif(ans.empty()) puts(\"NA\");\n\t\telse for(int i=0;i<ans.size();i++) printf(\"%d%c\",ans[i],(i==ans.size()-1)?'\\n':' ');\n\t}\n}"
  },
  {
    "language": "C++",
    "code": "#include<stdio.h>\n#include<algorithm>\n#include<math.h>\nusing namespace std;\ndouble x[200];\ndouble y[200];\ndouble ux[100];\ndouble uy[100];\ndouble mx[100];\ndouble my[100];\ndouble sx[100];\ndouble sy[100];\ndouble PI=acos(-1);\nint ans[200];\ndouble Abs(double a){return max(a,-a);}\ndouble dist(double x,double y){return sqrt(x*x+y*y);}\nint main(){\n\tint a,b;\n\twhile(scanf(\"%d%d\",&a,&b),a){\n\t\tfor(int i=0;i<a;i++)ans[i]=0;\n\t\tfor(int i=0;i<a;i++)scanf(\"%lf%lf\",x+i,y+i);\n\t\tint u,m,s;\n\t\tdouble du,dm,ds;\n\t\tscanf(\"%d%d%d%lf%lf%lf\",&u,&m,&s,&du,&dm,&ds);\n\n\t\tdu=PI*du/360;\n\t\tdm=PI*dm/360;\n\t\tds=PI*ds/360;\n\t\tfor(int i=0;i<u;i++){\n\t\t\tscanf(\"%lf%lf\",ux+i,uy+i);\n\t\t}\n\t\tfor(int i=0;i<m;i++){\n\t\t\tscanf(\"%lf%lf\",mx+i,my+i);\n\t\t}\n\t\tfor(int i=0;i<s;i++){\n\t\t\tscanf(\"%lf%lf\",sx+i,sy+i);\n\t\t}\n\t\tfor(int i=0;i<b;i++){\n\t\t\tdouble w,r;\n\t\t\tscanf(\"%lf%lf\",&w,&r);\n\t\t\tw=PI*w/180;\n\t\t\tif(w>PI)w-=2*PI;\n\t\t\tfor(int j=0;j<a;j++){\n\t\t\t\tbool ok=false;\n\t\t\t\tif(dist(x[j],y[j])<r&&Abs(atan2(y[j],x[j])-w)<du){\n\t\t\t\t\tok=true;\n\t\t\t\t}\n\t\t\t\tfor(int k=0;k<u;k++){\n\t\t\t\t\tif(dist(x[j]-ux[k],y[j]-uy[k])<r&&Abs(atan2(y[j]-uy[k],x[j]-ux[k])-w)<du)ok=false;\n\t\t\t\t}\n\t\t\t\tfor(int k=0;k<m;k++){\n\t\t\t\t\tif(dist(x[j]-mx[k],y[j]-my[k])<r&&Abs(atan2(y[j]-my[k],x[j]-mx[k])-w)<dm)ok=false;\n\t\t\t\t}\n\t\t\t\tfor(int k=0;k<s;k++){\n\t\t\t\t\tif(dist(x[j]-sx[k],y[j]-sy[k])<r&&Abs(atan2(y[j]-sy[k],x[j]-sx[k])-w)<ds)ok=false;\n\t\t\t\t}\n\t\t\t\tif(ok)ans[j]++;\n\t\t\t}\n\t\t}\n\t\tint val=0;\n\t\tfor(int i=0;i<a;i++){\n\t\t\tval=max(val,ans[i]);\n\t\t//\tprintf(\"%d\\n\",ans[i]);\n\t\t}\n\t\tif(val==0)printf(\"NA\\n\");\n\t\telse{\n\t\t\tbool f=true;\n\t\t\tfor(int i=0;i<a;i++){\n\t\t\t\tif(val==ans[i]){\n\t\t\t\t\tif(!f){printf(\" \");}\n\t\t\t\t\tf=false;\n\t\t\t\t\tprintf(\"%d\",i+1);\n\t\t\t\t}\n\t\t\t}\n\t\t\tprintf(\"\\n\");\n\t\t}\n\t}\n}"
  },
  {
    "language": "C++",
    "code": "#include<iostream>\n#include<complex>\n#include<vector>\n#include<algorithm>\n#include<cmath>\n#include<cstring>\n\n#define pb push_back\n#define sz size()\n#define rep(i,a) for(int i=0;i<(int)(a);i++)\n\nusing namespace std;\ntypedef long double D;\ntypedef complex<D> P;\nconst D EPS = 1e-5;\nconst D PI = acos(-1);\n\nD dot(P x,P y){return real(conj(x)*y);}\nD cross(P x,P y){return imag(conj(x)*y);}\nD arg(P a,P b,P c){\n  D res = acos(dot(b-a,c-a)/(abs(b-a)*abs(c-a))); \n  return (cross(b-a,c-a)<EPS)?2*PI-res:res;\n}\n\nint h,r,n[3];\nD d[3],tmp1,tmp2,seta;\nP hp[110],up[3][110];\nD w[110],a[110];\n\nint main(){\n  while(cin >> h >> r,h){\n    rep(i,h){\n      cin >> tmp1 >> tmp2;\n      hp[i] = P(tmp1,tmp2);\n    }\n\n    rep(i,3)cin >> n[i]; rep(i,3)cin >> d[i], d[i] *= PI/180/2;\n\n    rep(i,3)rep(j,n[i]){\n      cin >> tmp1 >> tmp2;\n      up[i][j] = P(tmp1,tmp2);\n    }\n\n    rep(i,r)cin >> w[i] >> a[i], w[i] *= PI/180;\n\n    int num[110];\n    memset(num,0,sizeof(num));\n\n    rep(x,r)rep(id,h){\n      int in = 0;\n      rep(i,3)rep(j,n[i]){\n\tif(abs(hp[id]-up[i][j]) < a[x] +EPS){\n\t  P tmp = P(up[i][j].real() + 100.0, up[i][j].imag());\n\t  seta = arg(up[i][j],tmp,hp[id]);\n\t  if(w[x]-d[i] < seta+EPS && seta < w[x]+d[i]+EPS)in++;\n\t  if(w[x]-d[i]+2*PI < seta+EPS && seta < w[x]+d[i]+2*PI+EPS)in++;\n\t}\n      }\n      if(in)continue;\n      \n      seta = arg(P(0,0),P(100,0),hp[id]);\n      if(abs(hp[id]) < a[x] + EPS){\n\tif(w[x]-d[0] < seta+EPS && seta < w[x]+d[0]+EPS)num[id]++;\n\tif(w[x]-d[0]+2*PI < seta+EPS && seta < w[x]+d[0]+2*PI+EPS)num[id]++;\n      }\n    }\n\n    int maxv = *max_element(num,num+h);\n    vector<int> ans;\n    if(maxv==0)cout << \"NA\\n\";\n    else{\n      rep(i,h){\n\tif(num[i] == maxv)ans.pb(i+1);\n      }\n      rep(i,ans.sz)cout << ans[i] << (i+1==ans.size()?\"\\n\":\" \");\n    }\n  }\n}"
  },
  {
    "language": "C++",
    "code": "#include<iostream>\n#include<complex>\n#include<vector>\n#include<algorithm>\n#include<cmath>\n#include<cstring>\n\n#define pb push_back\n#define sz size()\n#define rep(i,a) for(int i=0;i<(int)(a);i++)\n\nusing namespace std;\ntypedef long double D;\ntypedef complex<D> P;\nconst D EPS = 1e-8;\nconst D PI = acos(-1);\n\nD dot(P x,P y){return real(conj(x)*y);}\nD cross(P x,P y){return imag(conj(x)*y);}\nD arg(P a,P b,P c){\n  D res = acos(dot(b-a,c-a)/(abs(b-a)*abs(c-a))); \n  return (cross(b-a,c-a)<EPS)?2*PI-res:res;\n}\n\nint h,r,n[3];\nD d[3],tmp1,tmp2,seta;\nP hp[110],up[3][110];\nD w[110],a[110];\n\nint main(){\n  while(cin >> h >> r,h){\n    rep(i,h){\n      cin >> tmp1 >> tmp2;\n      hp[i] = P(tmp1,tmp2);\n    }\n\n    rep(i,3)cin >> n[i]; rep(i,3)cin >> d[i], d[i] *= PI/180/2;\n\n    rep(i,3)rep(j,n[i]){\n      cin >> tmp1 >> tmp2;\n      up[i][j] = P(tmp1,tmp2);\n    }\n\n    rep(i,r)cin >> w[i] >> a[i], w[i] *= PI/180;\n\n    int num[110];\n    memset(num,0,sizeof(num));\n\n    rep(x,r)rep(id,h){\n      if( !(abs(hp[id]) < a[x] + EPS) )continue;\n      seta = arg(P(0,0),P(100,0),hp[id]);\n      if( !(w[x]-d[0] < seta+EPS && seta < w[x]+d[0]+EPS)\n\t  && !(w[x]-d[0]+2*PI < seta+EPS && seta < w[x]+d[0]+2*PI+EPS) )continue;\n\n      bool in = 0;\n      rep(i,3){\n\trep(j,n[i]){\n\t  if(abs(hp[id]-up[i][j]) < a[x] +EPS){\n\t    P tmp = P(up[i][j].real() + 100.0, up[i][j].imag());\n\t    seta = arg(up[i][j],tmp,hp[id]);\n\t    if(w[x]-d[i] < seta+EPS && seta < w[x]+d[i]+EPS){\n\t      in = 1; break;\n\t    }\n\t    seta -= 2*PI;\n\t    if(w[x]-d[i] < seta+EPS && seta < w[x]+d[i]+EPS){\n\t      in = 1; break;\n\t    }\n\t  }\n\t}\n\tif(in)break;\n      }\n      if(!in)num[id]++;\n    }\n\n    int maxv = *max_element(num,num+h);\n    if(maxv==0)cout << \"NA\\n\";\n    else{\n      vector<int> ans;\n      rep(i,h){\n\tif(num[i] == maxv)ans.pb(i+1);\n      }\n      rep(i,ans.sz)cout << ans[i] << (i+1==ans.size()?\"\\n\":\" \");\n    }\n  }\n}"
  },
  {
    "language": "C++",
    "code": "#include<iostream>\n#include<complex>\n#include<vector>\n#include<algorithm>\n\nusing namespace std;\n\ntypedef complex<double> P;\n\ndouble dot(P a,P b){\n  return (a*conj(b)).real();\n}\n\nint main(){\n  for(int H,R;cin>>H>>R,H;){\n    P h[100];\n    for(int i=0;i<H;i++){\n      int x,y;\n      cin>>x>>y;\n      h[i]=P(x,y);\n    }\n    int UMS[3],dums[3];\n    cin>>UMS[0]>>UMS[1]>>UMS[2]>>dums[0]>>dums[1]>>dums[2];\n    P ums[3][10];\n    for(int i=0;i<3;i++){\n      for(int j=0;j<UMS[i];j++){\n\tint x,y;\n\tcin>>x>>y;\n\tums[i][j]=P(x,y);\n      }\n    }\n    int nr[100]={};\n    for(int i=0;i<R;i++){\n      int w,a;\n      cin>>w>>a;\n      auto reach=[=](P s,P d,int ang){\n\tP v=d-s;\n\treturn abs(v)<=a&&acos(dot(v,polar(1.,w*acos(0)/90))/abs(v))<=ang*acos(0)/90/2;\n      };\n      for(int j=0;j<H;j++){\n\tif(reach(P(0,0),h[j],dums[0])){\n\t  bool f=false;\n\t  for(int k=0;k<3;k++){\n\t    for(int l=0;l<UMS[k];l++){\n\t      f|=reach(ums[k][l],h[j],dums[k]);\n\t    }\n\t  }\n\t  nr[j]+=!f;\n\t}\n      }\n    }\n    auto m=*max_element(nr,nr+H);\n    if(m==0){\n      cout<<\"NA\"<<endl;\n    }else{\n      vector<int> v;\n      for(int i=0;i<H;i++){\n\tif(m==nr[i]){\n\t  v.push_back(i+1);\n\t}\n      }\n      for(int i=0;i<v.size();i++){\n\tcout<<v[i]<<\" \\n\"[i==v.size()-1];\n      }\n    }\n  }\n}"
  },
  {
    "language": "C++",
    "code": "#include <iostream>\n#include <complex>\n#include <cmath>\n#include <vector>\n\nusing namespace std;\n\ntypedef complex<double> P;\n\nconst double DBG = 1e-8;\n\nint h, r, u, m, s;\ndouble du, dm, ds;\nvector<P> ume, momo, sakura, ie;\nint cnt[100];\n\nvoid print(){\n  cout << \"du = \" << du << \" dm = \" << dm << \" ds = \" << ds << endl;\n  const int SIZE = 15;\n  char table[SIZE*2][SIZE*2];\n  fill(table[0], table[SIZE*2], '.');\n  table[SIZE][SIZE] = 'w';\n  for(int i=0;i<ie.size();i++) table[(int)ie[i].imag()+SIZE][(int)ie[i].real()+SIZE] = (i+1<10 ? i+1+'0' : i+1-10+'A');\n  for(int i=0;i<ume.size();i++) table[(int)ume[i].imag()+SIZE][(int)ume[i].real()+SIZE] = 'u';\n  for(int i=0;i<momo.size();i++) table[(int)momo[i].imag()+SIZE][(int)momo[i].real()+SIZE] = 'm';\n  for(int i=0;i<sakura.size();i++) table[(int)sakura[i].imag()+SIZE][(int)sakura[i].real()+SIZE] = 's';\n  for(int i=SIZE*2-1;i>=0;i--){\n    for(int j=0;j<SIZE*2;j++){\n      cout << table[i][j];\n    }\n    cout << \" \" << i - SIZE << endl;\n  }\n  cout << endl; \n}\n\nvoid init(){\n  ume.clear();\n  momo.clear();\n  sakura.clear();\n  ie.clear();\n  fill(cnt, cnt+100, 0);\n}\n\nbool check2(P kaze, P e, P ki, double dir){\n  double dist = abs(e - ki);\n  if(dist > kaze.imag()) return false;\n  double tmp = arg(e - ki) * 180 / M_PI;\n  if(tmp < 0.0) tmp += 360;\n  double a = kaze.real() + dir / 2.0;\n  while(a > 360.0) a -= 360.0;\n  while(a < 0.0) a += 360.0;\n  double b = kaze.real() - dir / 2.0;\n  while(b > 360.0) b -= 360.0;\n  while(b < 0.0) b += 360.0;\n  if(b > a) return b <= tmp && tmp <= 360 || 0 <= tmp && tmp <= a;\n  else return b <= tmp && tmp <= a;\n}\n\nbool check(P kaze, P e){\n  if(!check2(kaze, e, P(0, 0), du)) return false;\n  //cout << \"watashi \" << kaze << \" \" << e << endl;\n  for(int i=0;i<u;i++) if(check2(kaze, e, ume[i], du)) return false;\n  //cout << \"ume \" << kaze << \" \" << e << \" \" << du << endl;\n  for(int i=0;i<m;i++) if(check2(kaze, e, momo[i], dm)) return false;\n  //cout << \"momo \" << kaze << \" \" << e << \" \" << dm << endl;\n  for(int i=0;i<s;i++) if(check2(kaze, e, sakura[i], ds)) return false;\n  //cout << \"sakura \" << kaze << \" \" << e << \" \" << ds << endl;\n  return true;\n}\n\nmain(){\n  //check2(P(0, 12), P(4, 3), P(-5, 9), 90);\n  //return 0;\n\n  while(cin >> h >> r && (h|r)){\n    //cout << h << ' ' << r << endl;\n    init();\n    P in;\n    for(int i=0;i<h;i++){\n      cin >> in.real() >> in.imag();\n      ie.push_back(in);\n    }\n    cin >> u >> m >> s >> du >> dm >> ds;\n    for(int i=0;i<u;i++){\n      cin >> in.real() >> in.imag();\n      ume.push_back(in);\n    }\n    for(int i=0;i<m;i++){\n      cin >> in.real() >> in.imag();\n      momo.push_back(in);\n    }\n    for(int i=0;i<s;i++){\n      cin >> in.real() >> in.imag();\n      sakura.push_back(in);\n    }\n    for(int i=0;i<r;i++){\n      cin >> in.real() >> in.imag();\n      for(int j=0;j<h;j++){\n        if(check(in, ie[j])) cnt[j]++;\n      }\n    }\n    int ans = 0;\n    for(int i=0;i<h;i++) ans = max(ans, cnt[i]);\n    if(!ans) cout << \"NA\" << endl;\n    else{\n      //cout << ans << endl;\n      bool f = true;\n      for(int i=0;i<h;i++){\n        if(ans == cnt[i]){\n          if(!f) cout << \" \";\n          f = false;\n          cout << i+1;\n        }\n      }\n      cout << endl;\n    }\n  }\n  //print();\n}"
  },
  {
    "language": "C++",
    "code": "#include<bits/stdc++.h>\n\n#define REP(i,s,n) for(int i=s;i<n;i++)\n#define rep(i,n) REP(i,0,n)\n#define EPS (1e-7)\n#define COUNTER_CLOCKWISE 1\n#define CLOCKWISE -1 \n#define ONLINE_BACK 2\n#define ONLINE_FRONT -2\n#define ON_SEGMENT 0\n#define equals(a,b) (fabs((a)-(b)) < EPS)\n\nusing namespace std;\n\nconst int IINF = INT_MAX;\n\n//\nclass Point{\npublic:\n  double x,y;\n\n  Point(double x = -IINF,double y = -IINF): x(x),y(y){}\n\n  Point operator + (Point p){return Point(x+p.x,y+p.y);}\n  Point operator - (Point p){return Point(x-p.x,y-p.y);}\n  Point operator * (double a){return Point(a*x,a*y);}\n  Point operator / (double a){return Point(x/a,y/a);}\n  Point operator * (Point a){ return Point(x * a.x - y * a.y, x * a.y + y * a.x); }\n\n  bool operator < (const Point& p) const{ return !equals(x,p.x)?x<p.x:y<p.y; }\n\n  bool operator == (const Point& p)const{ return fabs(x-p.x) < EPS && fabs(y-p.y) < EPS; }\n\n};\n\nstruct Segment{\n  Point p1,p2;\n  Segment(Point p1 = Point(),Point p2 = Point()):p1(p1),p2(p2){}\n  bool operator == (const Segment& p)const { return p.p1 == p1 && p.p2 == p2; }\n};\n\ntypedef Point Vector;\ntypedef Segment Line;\ntypedef vector<Point> Polygon;\n\nostream& operator << (ostream& os,const Point& a){ os << \"(\" << a.x << \",\" << a.y << \")\"; }\n\nostream& operator << (ostream& os,const Segment& a){ os << \"( \" << a.p1 << \" , \" << a.p2 << \" )\"; }\n\ndouble dot(Point a,Point b){ return a.x*b.x + a.y*b.y; }\n\ndouble cross(Point a,Point b){ return a.x*b.y - a.y*b.x; }\n\ndouble norm(Point a){ return a.x*a.x+a.y*a.y; }\n\ndouble abs(Point a){ return sqrt(norm(a)); }\n\n//rad は角度をラジアンで持たせること\nPoint rotate(Point a,double rad){ return Point(cos(rad)*a.x - sin(rad)*a.y,sin(rad)*a.x + cos(rad)*a.y); }\n\n// 度をラジアンに変換\ndouble toRad(double agl){ return agl*M_PI/180.0; }\n\n// a => prev, b => cur, c=> next\n// prev から cur へ行って next へ行く際の角度を求める\ndouble getArg(Point a,Point b,Point c){\n  double arg1 = atan2(b.y-a.y,b.x-a.x);\n  double arg2 = atan2(c.y-b.y,c.x-b.x);\n  double arg = fabs( arg1 - arg2 );\n  while( arg > M_PI ) arg -= 2.0 * M_PI;\n  return fabs(arg);\n}\n\nint ccw(Point p0,Point p1,Point p2){\n  Point a = p1-p0;\n  Point b = p2-p0;\n  if(cross(a,b) > EPS)return COUNTER_CLOCKWISE;\n  if(cross(a,b) < -EPS)return CLOCKWISE;\n  if(dot(a,b) < -EPS)return ONLINE_BACK;\n  if(norm(a) < norm(b))return ONLINE_FRONT;\n  return ON_SEGMENT;\n}\n\n//\n\nconst int MAX_N = 110;\nint N,M,Ume,Momo,SakuraHappyInnovation,counter[MAX_N],limit[3];\nPoint ps[MAX_N],p[3][20];\ndouble d[3],w[110],a[110];\n\nbool LT(double A,double B)  { return !equals(A,B) && A < B; }\nbool LTE(double A,double B) { return  equals(A,B) || A < B; }\n\nbool inside(Point h,Point t,double ta,double tw,double td){\n  double rad_w = toRad(tw), rad_d = toRad(td);\n  Point tmp = Point(ta*cos(rad_w),ta*sin(rad_w));\n  double rad_alpha = rad_w - toRad(td/2.0);\n  double rad_beta  = rad_w + toRad(td/2.0);\n  Point alpha = rotate(tmp,rad_alpha) + t;\n  Point beta  = rotate(tmp,rad_beta)  + t;\n  bool res1 = ( ccw(t,alpha,h) == COUNTER_CLOCKWISE ) ;\n  bool res2 = ( ccw(t,beta,h) == CLOCKWISE );\n  double dist = abs(h-t);\n  bool res3 = LTE(dist,ta);\n  return res1 && res2 && res3;\n}\n\ninline void compute(){\n  rep(i,N) counter[i] = 0;\n  rep(_,M){\n    rep(i,N){\n      bool failed = false;\n      if( inside(ps[i],Point(0,0),a[_],w[_],d[0]) ) {\n        rep(j,3) if( !failed ) rep(k,limit[j]) failed |= inside(ps[i],p[j][k],a[_],w[_],d[j]);\n      } else failed = true;\n      if( !failed ) ++counter[i];\n    }\n  }\n  int maxi = -1;\n  rep(i,N) if( counter[i] != 0 ) maxi = max(maxi,counter[i]);\n  if( maxi == -1 ) puts(\"NA\");\n  else {\n    bool first = true;\n    rep(i,N) if( counter[i] == maxi ){\n      if( !first ) printf(\" \"); first = false;\n      printf(\"%d\",i+1);\n    }\n    puts(\"\");\n  }\n}\n\nint main(){\n\n  while( scanf(\"%d %d\",&N,&M), N|M ){\n    rep(i,N) scanf(\"%lf %lf\",&ps[i].x,&ps[i].y);\n    scanf(\"%d %d %d %lf %lf %lf\",&Ume,&Momo,&SakuraHappyInnovation,d,d+1,d+2);\n    limit[0] = Ume, limit[1] = Momo, limit[2] = SakuraHappyInnovation;\n    rep(i,Ume) scanf(\"%lf %lf\",&p[0][i].x,&p[0][i].y);\n    rep(i,Momo) scanf(\"%lf %lf\",&p[1][i].x,&p[1][i].y);\n    rep(i,SakuraHappyInnovation) scanf(\"%lf %lf\",&p[2][i].x,&p[2][i].y);\n    rep(i,M) scanf(\"%lf %lf\",w+i,a+i);\n    compute();\n  }\n  return 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include <cstdio>\n#include <cmath>\n#include <cstring>\n#include <cstdlib>\n#include <climits>\n#include <ctime>\n#include <queue>\n#include <stack>\n#include <algorithm>\n#include <list>\n#include <vector>\n#include <set>\n#include <map>\n#include <iostream>\n#include <deque>\n#include <complex>\n#include <string>\n#include <iomanip>\n#include <sstream>\n#include <bitset>\n#include <valarray>\n#include <iterator>\n#include <assert.h>\nusing namespace std;\ntypedef long long int ll;\ntypedef unsigned int uint;\ntypedef unsigned char uchar;\ntypedef unsigned long long ull;\ntypedef pair<int, int> pii;\ntypedef pair<ll, ll> pll;\ntypedef vector<int> vi;\n\n#define REP(i,x) for(int i=0;i<(int)(x);i++)\n#define REPS(i,x) for(int i=1;i<=(int)(x);i++)\n#define RREP(i,x) for(int i=((int)(x)-1);i>=0;i--)\n#define RREPS(i,x) for(int i=((int)(x));i>0;i--)\n#define FOR(i,c) for(__typeof((c).begin())i=(c).begin();i!=(c).end();i++)\n#define RFOR(i,c) for(__typeof((c).rbegin())i=(c).rbegin();i!=(c).rend();i++)\n#define ALL(container) (container).begin(), (container).end()\n#define RALL(container) (container).rbegin(), (container).rend()\n#define SZ(container) ((int)container.size())\n#define mp(a,b) make_pair(a, b)\n#define UNIQUE(v) v.erase( unique(v.begin(), v.end()), v.end() );\n\ntemplate<class T> bool chmax(T &a, const T &b) { if (a<b) { a=b; return 1; } return 0; }\ntemplate<class T> bool chmin(T &a, const T &b) { if (a>b) { a=b; return 1; } return 0; }\ntemplate<class T> ostream& operator<<(ostream &os, const vector<T> &t) {\nFOR(it,t) os << *it << endl; return os;\n}\ntemplate<class T> ostream& operator<<(ostream &os, const set<T> &t) {\nos<<\"{\"; FOR(it,t) {if(it!=t.begin()) os<<\",\"; os<<*it;} os<<\"}\"; return os;\n}\ntemplate<class S, class T> ostream& operator<<(ostream &os, const pair<S,T> &t) { return os<<\"(\"<<t.first<<\",\"<<t.second<<\")\";}\ntemplate<class S, class T> pair<S,T> operator+(const pair<S,T> &s, const pair<S,T> &t){ return pair<S,T>(s.first+t.first, s.second+t.second);}\ntemplate<class S, class T> pair<S,T> operator-(const pair<S,T> &s, const pair<S,T> &t){ return pair<S,T>(s.first-t.first, s.second-t.second);}\n\nnamespace geom{\n\t#define X real()\n\t#define Y imag()\n\ttypedef double R;\n\tconst R INF = 1e8;\n\tconst R EPS = 1e-8;\n\tconst R PI = 3.1415926535897932384626;\n\tinline int sig(const R &x) { return (abs(x) < EPS ? 0 : x > 0 ? 1 : -1); }\n\ttypedef complex<R> P;\n\tstruct L : public vector<P>{\t// line\n\t\tL(const P &p1, const P &p2){this->push_back(p1);this->push_back(p2);}\n\t\tL(){}\n\t\tP dir()const {return at(1) - at(0);}\n\t};\n\tstruct Se : public L{\t// segment\n\t\tSe(const P &p1, const P &p2):L(p1, p2){}\n\t\tSe(){}\n\t};\n};\nusing namespace geom;\n\nnamespace std{\n\tbool operator<(const P &a, const P &b){return sig(a.X-b.X) ? a.X < b.X : a.Y < b.Y;}\n\tistream& operator>>(istream &is, P &p){R x,y;is>>x>>y;p=P(x, y);return is;}\n//\tostream& operator<<(ostream &os, const P &p){return os << \"circle(\"<<100+10*p.X<<\", \"<<100-10*p.Y<<\", 2)\";}\n//\tostream& operator<<(ostream &os, const Se &s){return os << \"line(\"<<100+10*s[0].X<<\", \"<<100-10*s[0].Y<<\", \"<<100+10*s[1].X<<\", \"<<100-10*s[1].Y<<\")\";}\n}\n\nint H, W, U, M, S;\nR du, dm, ds;\nmain(){\n\twhile(cin >> H >> W, H){\n\t\tvector<P> h(H);\n\t\tREP(i, H) cin >> h[i];\n\t\tcin >> U >> M >> S >> du >> dm >> ds;\n\t\tdu *= PI / 360;\n\t\tdm *= PI / 360;\n\t\tds *= PI / 360;\n\t\tvector<P> ums(U+M+S);\n\t\tREP(i, U+M+S) cin >> ums[i];\n\t\tvector<P> w(W);\n\t\tREP(i, W){\n\t\t\tR a, r;\n\t\t\tcin >> a >> r;\n\t\t\tw[i] = polar(r, a*PI/180);\n\t\t}\n\t\tint ma = 1;\n\t\tvector<int> ans;\n\t\tREP(i, H){\n\t\t\tconst P p = h[i];\n\t\t\tint c = 0;\n\t\t\tREP(j, W){\n\t\t\t\tconst P d = w[j];\n\t\t\t\tif(abs(d) < abs(p) || du < abs(arg(p/d))) continue;\n\t\t\t\tif([&](){\n\t\t\t\t\tREP(k, ums.size()){\n\t\t\t\t\t\tconst P q = p - ums[k];\n\t\t\t\t\t\tconst R dd = k<U ? du : k<U+M ? dm : ds;\n\t\t\t\t\t\tif(abs(q) < abs(d) && abs(arg(q/d)) < dd) return 0;\n\t\t\t\t\t}\n\t\t\t\t\treturn 1;\n\t\t\t\t}()) c ++;\n\t\t\t}\n\t\t\tif(c > ma){\n\t\t\t\tans.clear();\n\t\t\t\tma = c;\n\t\t\t}\n\t\t\tif(c == ma) ans.push_back(i+1);\n\t\t}\n\t\tif(ans.empty()) cout << \"NA\" << endl;\n\t\telse REP(i, ans.size()) cout << ans[i] << (i+1 == ans.size() ? \"\\n\" : \" \");\n\t}\n\treturn 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include <iostream>\n#include <algorithm>\n#include <map>\n#include <set>\n#include <queue>\n#include <stack>\n#include <numeric>\n#include <bitset>\n#include <cmath>\n\nstatic const int MOD = 1000000007;\nusing ll = long long;\nusing u32 = unsigned;\nusing u64 = unsigned long long;\nusing namespace std;\n\ntemplate<class T> constexpr T INF = ::numeric_limits<T>::max()/32*15+208;\n\nusing real = double;\nstatic constexpr real EPS = 1e-10;\nconst real pi = acos(-1);\nstruct Point {\n    real x, y;\n    Point& operator+=(const Point a) { x += a.x; y += a.y;  return *this; }\n    Point& operator-=(const Point a) { x -= a.x; y -= a.y;  return *this; }\n    Point& operator*=(const real k) { x *= k; y *= k;  return *this; }\n    Point& operator/=(const real k) { x /= k; y /= k;  return *this; }\n    Point operator+(const Point a) const {return Point(*this) += a; }\n    Point operator-(const Point a) const {return Point(*this) -= a; }\n    Point operator*(const real k) const {return Point(*this) *= k; }\n    Point operator/(const real k) const {return Point(*this) /= k; }\n    bool operator<(const Point &a) const { return (x != a.x ? x < a.x : y < a.y); }\n    explicit Point(real a = 0, real b = 0) : x(a), y(b) {};\n};\n\nbool sorty(Point a, Point b){\n    return (a.y != b.y ? a.y < b.y : a.x < b.x);\n}\n\nistream& operator>> (istream& s, Point& P){\n    s >> P.x >> P.y;\n    return s;\n}\n\ninline real dot(Point a, Point b){ return a.x*b.x + a.y*b.y; }\ninline real cross(Point a, Point b){ return a.x*b.y - a.y*b.x; }\ninline real abs(Point a){ return sqrt(dot(a, a)); }\n\n\nreal angle(Point A, Point B){\n    return acos(dot(A, B)/abs(A)/abs(B));\n}\n\n\n\nstatic constexpr int COUNTER_CLOCKWISE = 1;\nstatic constexpr int CLOCKWISE = -1;\nstatic constexpr int ONLINE_BACK = 2;\nstatic constexpr int ONLINE_FRONT = -2;\nstatic constexpr int ON_SEGMENT = 0;\n\nint ccw(Point a, Point b, Point c){\n    b -= a; c -= a;\n    if(cross(b, c) > EPS) return COUNTER_CLOCKWISE;\n    if(cross(b, c) < -EPS) return CLOCKWISE;\n    if(dot(b, c) < 0) return ONLINE_BACK;\n    if(abs(b) < abs(c)) return ONLINE_FRONT;\n    return ON_SEGMENT;\n}\nstruct Segment {\n    Point a, b;\n    Segment(Point x, Point y) : a(x), b(y) {};\n};\n\nstruct Line {\n    Point a, b;\n    Line(Point x, Point y) : a(x), b(y) {};\n};\n\nstruct Circle{\n    Point c; real r;\n    Circle(Point c, real r): c(c), r(r) {};\n};\n\nusing Polygon = vector<Point>;\n\nbool intersect(Segment s, Segment t){\n    return (ccw(s.a, s.b, t.a)*ccw(s.a, s.b, t.b) <= 0 &&\n            ccw(t.a, t.b, s.a)*ccw(t.a, t.b, s.b) <= 0);\n}\n\nbool intersect(Segment s, Line t){\n    int a = ccw(t.a, t.b, s.a), b = ccw(t.a, t.b, s.b);\n    return (!(a&1) || !(b&1) || a != b);\n}\n\nPoint polar(double r, double t){\n    return Point(r*cos(t), r*sin(t));\n}\n\ndouble arg(Point p){\n    return atan2(p.y, p.x);\n}\n\nstatic constexpr int CONTAIN = 0;\nstatic constexpr int INSCRIBE = 1;\nstatic constexpr int INTERSECT = 2;\nstatic constexpr int CIRCUMSCRIBED = 3;\nstatic constexpr int SEPARATE = 4;\n\nint intersect(Circle c1, Circle c2){\n    if(c1.r < c2.r) swap(c1, c2);\n    real d = abs(c1.c-c2.c);\n    real r = c1.r + c2.r;\n    if(fabs(d-r) < EPS) return CIRCUMSCRIBED;\n    if(d > r) return SEPARATE;\n    if(fabs(d+c2.r-c1.r) < EPS) return INSCRIBE;\n    if(d+c2.r < c1.r) return CONTAIN;\n    return INTERSECT;\n}\n\nreal distance(Line l, Point c){\n    return abs(cross(l.b-l.a, c-l.a)/abs(l.b-l.a));\n}\n\n\nreal distance(Segment s, Point c){\n    if(dot(s.b-s.a, c-s.a) < EPS) return abs(c-s.a);\n    if(dot(s.a-s.b, c-s.b) < EPS) return abs(c-s.b);\n    return abs(cross(s.b-s.a, c-s.a)) / abs(s.a-s.b);\n}\n\nreal distance(Segment s, Segment t){\n    if(intersect(s, t)) return 0.0;\n    return min({distance(s, t.a), distance(s, t.b),\n                distance(t, s.a), distance(t, s.b)});\n}\n\n\nPoint project(Line l, Point p){\n    Point Q = l.b-l.a;\n    return l.a + Q*(dot(p-l.a, Q) / dot(Q, Q));\n}\n\n\nPoint project(Segment s, Point p){\n    Point Q = s.b-s.a;\n    return s.a + Q*(dot(p-s.a, Q) / dot(Q, Q));\n}\n\nPoint refrect(Segment s, Point p){\n    Point Q = project(s, p);\n    return Q*2-p;\n}\n\nbool isOrthogonal(Segment s, Segment t){\n    return fabs(dot(s.b-s.a, t.b-t.a)) < EPS;\n}\n\nbool isparallel(Segment s, Segment t){\n    return fabs(cross(s.b-s.a, t.b-t.a)) < EPS;\n}\n\n\nPoint crossPoint(Segment s, Segment t){\n    real d1 = cross(s.b-s.a, t.b-t.a);\n    real d2 = cross(s.b-s.a, s.b-t.a);\n    if(fabs(d1) < EPS && fabs(d2) < EPS) return t.a;\n    return t.a+(t.b-t.a)*d2/d1;\n}\n\nPoint crossPoint(Line s, Line t){\n    real d1 = cross(s.b-s.a, t.b-t.a);\n    real d2 = cross(s.b-s.a, s.b-t.a);\n    if(fabs(d1) < EPS && fabs(d2) < EPS) return t.a;\n    return t.a+(t.b-t.a)*d2/d1;\n}\n\nPolygon crossPoint(Circle c, Line l){\n    Point p = project(l, c.c), q = (l.b-l.a)/abs(l.b-l.a);\n    if(abs(distance(l, c.c)-c.r) < EPS){\n        return {p};\n    }\n    double k = sqrt(c.r*c.r-dot(p-c.c, p-c.c));\n    return {p-q*k, p+q*k};\n}\n\nPolygon crossPoint(Circle c, Segment s){\n    auto tmp = crossPoint(c, Line(s.a, s.b));\n    Polygon ret;\n    for (auto &&i : tmp) {\n        if(distance(s, i) < EPS) ret.emplace_back(i);\n    }\n    return ret;\n}\n\n\nPolygon crossPoint(Circle c1, Circle c2){\n    double d = abs(c1.c-c2.c);\n    double a = acos((c1.r*c1.r+d*d-c2.r*c2.r)/(2*c1.r*d));\n    double t = arg(c2.c-c1.c);\n    return {c1.c+polar(c1.r, t+a), c1.c+polar(c1.r, t-a)};\n}\n\nPolygon tangent(Circle c1, Point p){\n    Circle c2 = Circle(p, sqrt(dot(c1.c-p, c1.c-p)-c1.r*c1.r));\n    return crossPoint(c1, c2);\n}\nvector<Line> tangent(Circle c1, Circle c2){\n    vector<Line> ret;\n    if(c1.r < c2.r) swap(c1, c2);\n    double k = dot(c1.c-c2.c, c1.c-c2.c);\n    if(abs(k) < EPS) return {};\n    Point u = (c2.c-c1.c)/sqrt(k);\n    Point v(-u.y, u.x);\n    for (auto &&i : {-1, 1}) {\n        double h = (c1.r+i*c2.r)/sqrt(k);\n        if(abs(h*h-1) < EPS){\n            ret.emplace_back(c1.c+u*c1.r, c1.c+(u+v)*c1.r);\n        }else if(h*h < 1){\n            Point u2 = u*h, v2 = v*sqrt(1-h*h);\n            ret.emplace_back(c1.c+(u2+v2)*c1.r, c2.c-(u2+v2)*c2.r*i);\n            ret.emplace_back(c1.c+(u2-v2)*c1.r, c2.c-(u2-v2)*c2.r*i);\n        }\n    }\n    return ret;\n}\n\nreal area(Polygon v){\n    if(v.size() < 3) return 0.0;\n    real ans = 0.0;\n    for (int i = 0; i < v.size(); ++i) {\n        ans += cross(v[i], v[(i+1)%v.size()]);\n    }\n    return ans/2;\n}\n\nreal area(Circle c, Polygon &v){\n    int n = v.size();\n    real ans = 0.0;\n    Polygon u;\n    for (int i = 0; i < n; ++i) {\n        u.emplace_back(v[i]);\n        auto q = crossPoint(c, Segment(v[i], v[(i+1)%n]));\n        for (auto &&j : q) {\n            u.emplace_back(j);\n        }\n    }\n    for (int i = 0; i < u.size(); ++i) {\n        Point A = u[i]-c.c, B = u[(i+1)%u.size()]-c.c;\n        if(abs(A) >= c.r+EPS || abs(B) >= c.r+EPS){\n            Point C = polar(1, arg(B)-arg(A));\n            ans += c.r*c.r*arg(C)/2;\n        }else {\n            ans += cross(A, B)/2;\n        }\n    }\n    return ans;\n}\n\nPolygon convex_hull(Polygon v){\n    int n = v.size();\n    sort(v.begin(),v.end(), sorty);\n    int k = 0;\n    Polygon ret(n*2);\n    for (int i = 0; i < n; ++i) {\n        while(k > 1 && cross(ret[k-1]-ret[k-2], v[i]-ret[k-1]) < 0) k--;\n        ret[k++] = v[i];\n    }\n    for(int i = n-2, t=k; i >= 0; i--){\n        while(k > t && cross(ret[k-1]-ret[k-2], v[i]-ret[k-1]) < 0) k--;\n        ret[k++] = v[i];\n    }\n    ret.resize(k-1);\n    return ret;\n}\n\nbool isconvex(Polygon v){\n    int n = v.size();\n    for (int i = 0; i < n; ++i) {\n        if(ccw(v[(i+n-1)%n], v[i], v[(i+1)%n]) == CLOCKWISE) return false;\n    }\n    return true;\n}\n\nint contains(Polygon v, Point p){\n    int n = v.size();\n    bool x = false;\n    static constexpr int IN = 2;\n    static constexpr int ON = 1;\n    static constexpr int OUT = 0;\n    for (int i = 0; i < n; ++i) {\n        Point a = v[i]-p, b = v[(i+1)%n]-p;\n        if(fabs(cross(a, b)) < EPS && dot(a, b) < EPS) return ON;\n        if(a.y > b.y) swap(a, b);\n        if(a.y < EPS && EPS < b.y && cross(a, b) > EPS) x = !x;\n    }\n    return (x?IN:OUT);\n}\n\nreal diameter(Polygon v){\n    int n = v.size();\n    if(n == 2) return abs(v[0]-v[1]);\n    int i = 0, j = 0;\n    for (int k = 0; k < n; ++k) {\n        if(v[i] < v[k]) i = k;\n        if(!(v[j] < v[k])) j = k;\n    }\n    real ret = 0;\n    int si = i, sj = j;\n    while(i != sj || j != si){\n        ret = max(ret, abs(v[i]-v[j]));\n        if(cross(v[(i+1)%n]-v[i], v[(j+1)%n]-v[j]) < 0.0) i = (i+1)%n;\n        else j = (j+1)%n;\n    }\n    return ret;\n}\n\nPolygon convexCut(Polygon v, Line l){\n    Polygon q;\n    int n = v.size();\n    for (int i = 0; i < n; ++i) {\n        Point a = v[i], b = v[(i+1)%n];\n        if(ccw(l.a, l.b, a) != -1) q.push_back(a);\n        if(ccw(l.a, l.b, a)*ccw(l.a, l.b, b) < 0){\n            q.push_back(crossPoint(Line(a, b), l));\n        }\n    }\n    return q;\n}\n\nreal closest_pair(Polygon &v, int l = 0, int r = -1){\n    if(!(~r)){\n        r = v.size();\n        sort(v.begin(),v.end());\n    }\n    if(r - l < 2) {\n        return abs(v.front()-v.back());\n    }\n    int mid = (l+r)/2;\n    real p = v[mid].x;\n    real d = min(closest_pair(v, l, mid), closest_pair(v, mid, r));\n    inplace_merge(v.begin()+l, v.begin()+mid, v.begin()+r, sorty);\n    Polygon u;\n    for (int i = l; i < r; ++i) {\n        if(fabs(v[i].x-p) >= d) continue;\n        for (int j = 0; j < u.size(); ++j) {\n            real dy = v[i].y-next(u.rbegin(), j)->y;\n            if(dy >= d) break;\n            d = min(d, abs(v[i]-*next(u.rbegin(), j)));\n        }\n        u.emplace_back(v[i]);\n    }\n    return d;\n}\n\nvoid solve(int n, int m){\n    Polygon v(n);\n    for (auto &&i : v) cin >> i;\n    int a, b, c, daa, dbb, dcc;\n    cin >> a >> b >> c >> daa >> dbb >> dcc;\n    double da = daa*pi/180, db = dbb*pi/180, dc = dcc*pi/180;\n    Polygon A(a), B(b), C(c);\n    for (auto &&i : A) cin >> i;\n    for (auto &&i : B) cin >> i;\n    for (auto &&i : C) cin >> i;\n    vector<int> cnt(n);\n    for (int i = 0; i < m; ++i) {\n        int ww, r;\n        cin >> ww >> r;\n        double w = ww*pi/180;\n        for (int j = 0; j < n; ++j){\n            cnt[j] += [&](){\n                if(abs(v[j]) > r || ccw(polar(0, 0), polar(r, w-da/2.0), v[j]) != COUNTER_CLOCKWISE\n                   || ccw(polar(0, 0), polar(r, w+da/2.0), v[j]) != CLOCKWISE) return false;\n                for (auto &&k : A) {\n                    if(abs(v[j]-k) <= r && ccw(k, k+polar(r, w-da/2.0), v[j]) == COUNTER_CLOCKWISE\n                    && ccw(k, k+polar(r, w+da/2.0), v[j]) == CLOCKWISE) return false;\n                }\n                for (auto &&k : B) {\n                    if(abs(v[j]-k) <= r && ccw(k, k+polar(r, w-db/2.0), v[j]) == COUNTER_CLOCKWISE\n                       && ccw(k, k+polar(r, w+db/2.0), v[j]) == CLOCKWISE) return false;\n                }\n                for (auto &&k : C) {\n                    if(abs(v[j]-k) <= r && ccw(k, k+polar(r, w-dc/2.0), v[j]) == COUNTER_CLOCKWISE\n                       && ccw(k, k+polar(r, w+dc/2.0), v[j]) == CLOCKWISE) return false;\n                }\n                return true;\n            }();\n        }\n    }\n    if(*max_element(cnt.begin(),cnt.end()) == 0) puts(\"NA\");\n    else {\n        vector<int> ans; auto x = *max_element(cnt.begin(),cnt.end());\n        for (int i = 0; i < n; ++i) {\n            if(cnt[i] == x) ans.emplace_back(i+1);\n        }\n        for (int i = 0; i < ans.size(); ++i) {\n            if(i) printf(\" \");\n            printf(\"%d\", ans[i]);\n        }\n        puts(\"\");\n    }\n}\n\nint main() {\n    int n, m;\n    while(cin >> n >> m, n){\n        solve(n, m);\n    }\n    return 0;\n}\n"
  },
  {
    "language": "C++",
    "code": "#include<bits/stdc++.h>\nusing namespace std;\n\ntypedef pair<int,int>pint;\ntypedef vector<int>vint;\n#define pb push_back\n#define mp make_pair\n#define rep(i,n) for(int i=0;i<(n);i++)\ntemplate<class T,class U>void chmin(T &t,U f){if(t>f)t=f;}\ntemplate<class T,class U>void chmax(T &t,U f){if(t<f)t=f;}\n\ntypedef complex<double>P;\n\nconst double EPS=1e-9;\nconst double PI=acos(-1);\n\nconst int COUNTER_CLOCKWISE=1;\nconst int CLOCKWISE=-1;\nconst int ONLINE_BACK=2;\nconst int ONLINE_FRONT=-2;\nconst int ON_SEGMENT=0;\n\ninline double dot(const P &a, const P &b){return (conj(a) * b).real();}\ninline double cross(const P &a, const P &b){return (conj(a) * b).imag();}\n\ndouble toRad(double a){return a/180.0*PI;}\ndouble toDeg(double a){return a*180.0/PI;}\nP rotate(P p,double d){\n    return P(p.real()*cos(d)-p.imag()*sin(d),p.real()*sin(d)+p.imag()*cos(d));\n}\n\nP getP(){\n    double x,y;\n    scanf(\"%lf%lf\",&x,&y);\n    return P(x,y);\n}\n\nint ccw(P p0,P p1,P p2){\n    P a=p1-p0;\n    P b=p2-p0;\n    if(cross(a,b)>EPS)return COUNTER_CLOCKWISE;\n    if(cross(a,b)<-EPS)return CLOCKWISE;\n    if(dot(a,b)<-EPS)return ONLINE_BACK;\n    if(norm(a)<norm(b))return ONLINE_FRONT;\n    return ON_SEGMENT;\n}\n\nbool ok(P from,P to,double w,double a,double d){\n    if(abs(to-from)>a)return false;\n\n    w=toRad(w);\n    d=toRad(d);\n\n    P p0=from+P(cos(w),sin(w))*a;\n    P p1=rotate(p0,-d/2);\n    P p2=rotate(p0,d/2);\n    \n    return (cross(from,p1,to)>EPS)&&(cross(from,p2,to)<EPS);\n}\n\nint H,R;\nvector<P>h;\n\nint U,M,S;\ndouble du,dm,ds;\nvector<P>u,m,s;\nvoid solve(){\n    h.resize(H);\n    rep(i,H)h[i]=getP();\n\n    scanf(\"%d%d%d\",&U,&M,&S);\n    scanf(\"%lf%lf%lf\",&du,&dm,&ds);\n\n    u.resize(U);\n    m.resize(M);\n    s.resize(S);\n    rep(i,U)u[i]=getP();\n    rep(i,M)m[i]=getP();\n    rep(i,S)s[i]=getP();\n\n    int cnt[100]={0};\n\n    while(R--){\n        double w,a;\n        scanf(\"%lf%lf\",&w,&a);\n        rep(i,H){\n            bool f=false;\n            if(ok(P(0,0),h[i],w,a,du))f=true;\n            rep(j,U)if(ok(u[j],h[i],w,a,du))f=false;\n            rep(j,M)if(ok(m[j],h[i],w,a,dm))f=false;\n            rep(j,S)if(ok(s[j],h[i],w,a,ds))f=false;\n            if(f)cnt[i]++;\n        }\n    }\n\n    int ma=*max_element(cnt,cnt+H);\n    if(ma==0){\n        puts(\"NA\");\n        return;\n    }\n\n    bool f=false;\n    rep(i,H){\n        if(cnt[i]!=ma)continue;\n        if(f)printf(\" \");\n        else f=true;\n        printf(\"%d\",i+1);\n    }\n    puts(\"\");\n}\n\nint main(){\n    while(scanf(\"%d%d\",&H,&R),H||R)solve();\n    return 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include<bits/stdc++.h>\nusing namespace std;\n\ntypedef pair<int,int> P;\n\n/* 平面幾何の基本要素 */\n \n#define EPS (1e-10)\n#define equals(a,b) (fabs((a) - (b)) < EPS )\n#define PI 3.141692653589793\n \nclass Point { // 点を表すクラス\n  public:\n  double x,y;\n   \n  Point(double x=0,double y=0): x(x),y(y) {}\n   \n  Point operator + (Point p) { return Point(x + p.x, y + p.y); }\n  Point operator - (Point p) { return Point(x - p.x, y - p.y); }\n  Point operator * (double a) { return Point(a * x, a * y); }\n  Point operator / (double a) { return Point(x / a, y / a); }\n \n  double abs() { return sqrt(norm()); }\n  double norm() { return x * x + y * y; }\n   \n  bool operator < (const Point &p) const {\n    return x != p.x ? x < p.x : y < p.y;\n  }\n \n  bool operator == (const Point &p) const {\n    return fabs(x - p.x) < EPS && fabs(y - p.y) < EPS;\n  }\n};\n \ntypedef Point Vector; // ベクトルを表す構造体\n \nstruct Segment { // 線分を表す構造体\n  Point p1,p2;\n};\n \ntypedef Segment Line; // 直線を表す構造体\n \nclass Circle { // 円を表すクラス\npublic:\n  Point c;\n  double r;\n  Circle(Point c = Point(), double r = 0.0): c(c),r(r) {}\n};\ntypedef vector < Point > Polygon; // 多角形\n\ndouble dot(Vector a, Vector b) {\n  return a.x * b.x + a.y * b.y;\n}\n \ndouble cross(Vector a, Vector b) {\n  return a.x * b.y - a.y * b.x;\n}\n\nint H,R;\nPoint h[111];\nint U,M,S;\ndouble du,dm,ds;\nPoint u[11],m[11],s[11];\ndouble w[111],a[111];\n\nstatic const int COUNTER_CLOCKWISE = 1;\nstatic const int CLOCKWISE = -1;\nstatic const int ONLINE_BACK = 2;\nstatic const int ONLINE_FRONT = -2;\nstatic const int ON_SEGMENT = 0;\n \nint ccw(Point p0, Point p1, Point p2) {\n  Vector a = p1 - p0;\n  Vector b = p2 - p0;\n \n  if( cross(a,b) > EPS ) return COUNTER_CLOCKWISE;\n  if( cross(a,b) < -EPS ) return CLOCKWISE;\n  if( dot(a,b) < -EPS ) return ONLINE_BACK;\n  if( a.norm() < b.norm() ) return ONLINE_FRONT;\n                         \n  return ON_SEGMENT;\n}\n\nbool judge(Point p,int hn,int wn,double rad){\n  double length = sqrt((p.x-h[hn].x)*(p.x-h[hn].x)+(p.y-h[hn].y)*(p.y-h[hn].y));\n  if(length > a[wn]) return false;\n  Point p1,p2;\n  p1.x = a[wn]*cos((w[wn]-rad/2)*PI/180.0)+p.x;\n  p1.y = a[wn]*sin((w[wn]-rad/2)*PI/180.0)+p.y;\n  p2.x = a[wn]*cos((w[wn]+rad/2)*PI/180.0)+p.x;\n  p2.y = a[wn]*sin((w[wn]+rad/2)*PI/180.0)+p.y;\n  //cout<<p.x<<\" \"<<p.y<<\" \"<<p1.x<<\" \"<<p1.y<<\" \"<<p2.x<<\" \"<<p2.y<<endl;\n  //cout << ccw(p,p1,h[hn]) << \" \" << ccw(p,p2,h[hn]) << endl;\n  if(ccw(p,p1,h[hn]) == 1 && ccw(p,p2,h[hn]) == -1) return true;\n  return false;\n}\n\nint main(){\n  while(cin >> H >> R , H){\n    for(int i=0;i<H;i++) cin >> h[i].x >> h[i].y;\n    cin >> U >> M >> S >> du >> dm >> ds;\n    for(int i=0;i<U;i++) cin >> u[i].x >> u[i].y;\n    for(int i=0;i<M;i++) cin >> m[i].x >> m[i].y;\n    for(int i=0;i<S;i++) cin >> s[i].x >> s[i].y;\n    for(int i=0;i<R;i++) cin >> w[i] >> a[i];\n    Point T; T.x = 0; T.y = 0;\n    P cnt[111];\n    for(int i=0;i<111;i++){\n      cnt[i].first = 0;\n      cnt[i].second = -(i+1);\n    }\n    for(int i=0;i<H;i++){\n      for(int j=0;j<R;j++){\n\tif(judge(T,i,j,du)){\n\t  bool flg = true;\n\t  for(int k=0;k<U;k++){\n\t    if(judge(u[k],i,j,du)) {\n\t      flg = false;\n\t      break;\n\t    }\n\t  }\n\t  if(flg){\n\t    for(int k=0;k<M;k++){\n\t      if(judge(m[k],i,j,dm)) {\n\t\tflg = false;\n\t\tbreak;\n\t      }\n\t    }\n\t  }\n\t  if(flg){\n\t    for(int k=0;k<S;k++){\n\t      if(judge(s[k],i,j,ds)) {\n\t\tflg = false;\n\t\tbreak;\n\t      }\n\t    }\n\t  }\n\t  if(flg) {\n\t    cnt[i].first++;\n\t  }\n\t}\n      }\n    }\n    sort(cnt,cnt+H,greater<P>() );\n    int maxx = cnt[0].first;\n    int idx = 0;\n    if(cnt[0].first == 0) cout << \"NA\" << endl;\n    else {\n      while(maxx == cnt[idx].first){\n\tcout << -cnt[idx].second;\n\tif(cnt[idx+1].first == maxx) cout << \" \";\n\telse cout << endl;\n\tidx++;\n      }\n    }\n  }\n}"
  },
  {
    "language": "C++",
    "code": "#include<iostream>\n#include<complex>\n#include<vector>\n#include<algorithm>\n#include<cmath>\n#include<cstring>\n\n#define pb push_back\n#define sz size()\n#define rep(i,a) for(int i=0;i<(int)(a);i++)\n\nusing namespace std;\ntypedef long double D;\ntypedef complex<D> P;\nconst D EPS = 1e-10;\nconst D PI = acos(-1);\n\ninline D dot(P x,P y){return real(conj(x)*y);}\ninline D cross(P x,P y){return imag(conj(x)*y);}\nP rotate(P v,double s){\n  return P(real(v)*cos(s) - imag(v)*sin(s), real(v)*sin(s) + imag(v)*cos(s) );\n}\ninline int ccw(P a,P b,P c){\n  b -= a;c -= a;\n  if (cross(b,c)>EPS) return 1;   //counter clockwise\n  if (cross(b,c)<-EPS) return -1; //clockwise\n  if (dot(b, c)<-EPS) return 2;   //c--a--b on line\n  if (abs(b)<abs(c)) return -2;   //a--b--c on line\n  return 0;                       //on segment\n}\n\nint h,r,n[3];\nD d[3],tmp1,tmp2,seta;\nP hp[110],up[3][110];\nD w[110],a[110];\n\nint main(){\n  while(cin >> h >> r,h){\n    rep(i,h){\n      cin >> tmp1 >> tmp2;\n      hp[i] = P(tmp1,tmp2);\n    }\n\n    rep(i,3)cin >> n[i]; rep(i,3)cin >> d[i], d[i] *= PI/180/2;\n\n    rep(i,3)rep(j,n[i]){\n      cin >> tmp1 >> tmp2;\n      up[i][j] = P(tmp1,tmp2);\n    }\n\n    rep(i,r)cin >> w[i] >> a[i], w[i] *= PI/180;\n\n    int num[110];\n    memset(num,0,sizeof(num));\n\n    rep(x,r)rep(id,h){\n      if( !(abs(hp[id]) < a[x] + EPS) )continue;\n      P o = P(0,0), lp = rotate(P(1,0),w[x]+d[0]), rp = rotate(P(1,0),w[x]-d[0]);\n      if(ccw(o,lp,hp[id]) != -1 || ccw(o,rp,hp[id]) != 1)continue;\n\n      bool in = 0;\n      rep(i,3){\n\trep(j,n[i]){\n\t  if(abs(hp[id]-up[i][j]) < a[x] +EPS){\n\t    P o = up[i][j], lp = o + rotate(P(1,0),w[x]+d[i]), rp = o + rotate(P(1,0),w[x]-d[i]);\n\t    if(ccw(o,lp,hp[id]) == -1 && ccw(o,rp,hp[id]) == 1){\n\t      in = 1; break;\n\t    }\n\t  }\n\t}\n\tif(in)break;\n      }\n      if(!in)num[id]++;\n    }\n\n    int maxv = *max_element(num,num+h);\n    if(maxv==0)cout << \"NA\\n\";\n    else{\n      vector<int> ans;\n      rep(i,h){\n\tif(num[i] == maxv)ans.pb(i+1);\n      }\n      rep(i,ans.sz)cout << ans[i] << (i+1==ans.size()?\"\\n\":\" \");\n    }\n  }\n}"
  },
  {
    "language": "C++",
    "code": "#include<iostream>\n#include<vector>\n#include<cmath>\n#include<algorithm>\n#include<numeric>\nusing namespace std;\n\nconst double PI = 3.14159265358979;\nconst double EPS = 1e-9;\n\nclass Point {\npublic:\n    double x, y;\n    Point(double x = 0.0, double y = 0.0) :x(x), y(y) {}\n};\n\nclass Wind {\npublic:\n    double w, a;\n};\n\nbool include(double angle, double low, double high) {\n    if(low < 0) {\n        double l = low + 2.0 * PI;\n        if(l <= angle + EPS) return true;\n    }\n    if(high > 2.0 * PI) {\n        double h = high - 2.0 * PI;\n        if(angle <= h + EPS) return true;\n    }\n    return low <= angle + EPS && angle <= high + EPS;\n}\n\nbool savor(const Point &home, const Wind &wind, const vector<Point> &blossom, double d) {\n    d /= 2.0;\n    for(const auto &b: blossom) {\n        Point dif(home.x - b.x, home.y - b.y);\n        double angle = atan2(dif.y, dif.x);\n        double dist = hypot(dif.y, dif.x);\n        if(angle < 0) angle = 2 * PI - angle;\n        if(dist <= wind.a + EPS && include(angle, wind.w - d, wind.w + d)) return true;\n    }\n    return false;\n}\n\ndouble toRadian(double d) {\n    return d * PI / 180.0;\n}\n\nint main() {\n    int H, R;\n    while(cin >> H >> R, H | R) {\n        vector<Point> home(H);\n        for(auto &i: home) cin >> i.x >> i.y;\n\n        int U, M, S;\n        double du, dm, ds;\n        cin >> U >> M >> S >> du >> dm >> ds;\n\n        du = toRadian(du);\n        dm = toRadian(dm);\n        ds = toRadian(ds);\n\n        vector<Point> plum(U), peach(M), cherry(S);\n        for(auto &i: plum) cin >> i.x >> i.y;\n        for(auto &i: peach) cin >> i.x >> i.y;\n        for(auto &i: cherry) cin >> i.x >> i.y;\n\n        vector<Wind> wind(R);\n        for(auto &i: wind) cin >> i.w >> i.a;\n        for(auto &i: wind) i.w = toRadian(i.w);\n\n        // solve\n        vector<int> number(H, 0);\n        int maxNumber = 0;\n\n        for(int i = 0; i < H; ++i) {\n            for(int day = 0; day < R; ++day) {\n                bool ok = savor(home[i], wind[day], {Point(0.0, 0.0)}, du);\n                bool ng = false;\n                ng |= savor(home[i], wind[day], plum, du);\n                ng |= savor(home[i], wind[day], peach, dm);\n                ng |= savor(home[i], wind[day], cherry, ds);\n\n                if(!ok || ng) continue;\n\n                ++number[i];\n                maxNumber = max(maxNumber, number[i]);\n            }\n        }\n\n        if(maxNumber) {\n            bool first = true;\n            for(int i = 0; i < H; ++i) if(number[i] == maxNumber) {\n                if(!first) cout << \" \";\n                first = false;\n                cout << i + 1;\n            }\n            cout << endl;\n        } else {\n            cout << \"NA\" << endl;\n        }\n    }\n}"
  },
  {
    "language": "C++",
    "code": "#include<iostream>\n#include<cstdio>\n#include<cstdlib>\n#include<complex>\n#include<vector>\n#include<algorithm>\n#include<cmath>\n\n#define EQ(a,b) (abs((a)-(b)) < EPS)\n#define fs first\n#define sc second\n#define pb push_back\n#define sz size()\n#define rep(i,a) for(int i=0;i<(int)(a);i++)\n\nusing namespace std;\ntypedef long double D;\ntypedef complex<D> P;\nconst D EPS = 1e-10;\nconst D PI = acos(-1);\n\nD dot(P x,P y){return real(conj(x)*y);}\nD cross(P x,P y){return imag(conj(x)*y);}\nD arg(P a,P b,P c){\n  D res = acos(dot(b-a,c-a)/(abs(b-a)*abs(c-a))); \n  return (cross(b-a,c-a)<EPS)?2*PI-res:res;\n}\n\nint h,r,n[3];\nD d[3],tmp1,tmp2,seta;\nP hp[110],up[3][110];\nD w[110],a[110];\nconst P O = P(0,0), H = P(1,0);\n\nint main(){\n  int cnt = 0;\n  while(cin >> h >> r,h){\n    rep(i,h){\n      cin >> tmp1 >> tmp2;\n      hp[i] = P(tmp1,tmp2);\n    }\n\n    rep(i,3)cin >> n[i]; rep(i,3)cin >> d[i], d[i] *= PI/180/2;\n\n    rep(i,3)rep(j,n[i]){\n      cin >> tmp1 >> tmp2;\n      up[i][j] = P(tmp1,tmp2);\n    }\n\n    rep(i,r)cin >> w[i] >> a[i], w[i] *= PI/180;\n\n    int num[110] = {};\n    rep(x,r){\n      rep(id,h){\n\tint in = 0;\n\trep(i,3)rep(j,n[i]){\n\t  if(abs(hp[id]-up[i][j]) < a[x] +EPS){\n\t    P tmp = P(up[i][j].real() + 100, up[i][j].imag());\n\t    seta = arg(up[i][j],tmp,hp[id]);\n\t    if(id==4)cout << seta/PI * 180 << endl;\n\t    if(w[x]-d[i] < seta+EPS && seta < w[x]+d[i]+EPS){\n\t      in++;\n\t    }\n\t  }\n\t}\n\tif(in)continue;\n\n        seta = arg(P(0,0),P(100,0),hp[id]);\n\tif(abs(hp[id]) < a[x] + EPS && w[x]-d[0] < seta+EPS && seta < w[x]+d[0]+EPS){\n\t  num[id]++;\n\t}\n      }\n    }\n\n    int maxv = *max_element(num,num+h);\n    vector<int> ans;\n    if(maxv==0)cout << \"NA\\n\";\n    else{\n      rep(i,h){\n\tif(num[i] == maxv)ans.pb(i+1);\n      }\n      rep(i,ans.sz)cout << ans[i] << (i+1==ans.size()?\"\\n\":\" \");\n    }\n  }\n}"
  },
  {
    "language": "C++",
    "code": "#include <iostream>\n#include <cstdio>\n#include <iomanip>\n#include <vector>\n#include <map>\n#include <set>\n#include <queue>\n#include <bitset>\n#include <stack>\n#include <utility>\n#include <numeric>\n#include <algorithm>\n#include <functional>\n#include <cctype>\n#include <complex>\n#include <string>\n#include <sstream>\n#include <fstream>\n#include <cassert>\nusing namespace std;\n\n//common\ntypedef long long i64,ll;\n\n#define BR \"\\n\"\n#define ALL(c) (c).begin(),(c).end()\n#define REP(i,n) for(int i=0;i<(int)(n);++i)\n#define FOR(i,l,r) for(int i=(l);i<(int)(r);++i)\n#define EACH(it,o) for(auto it = (o).begin(); it != (o).end(); ++it)\n#define IN(l,v,r) ((l)<=(v) && (v)<(r))\n\n//debug\n#ifdef NDEBUG\n#define DUMP(x)\n#define DUMPLN(x)\n#define DEBUG(x)\n#define DEBUGLN(x)\n#define LINE()\n#define LINELN()\n#define CHECK(exp,act)\n#define STOP(e)\n#else\n#define DUMP(x)  cerr << #x << \" = \" << (x)\n#define DUMPLN(x)  DUMP(x) <<endl\n#define DEBUG(x) DUMP(x) << LINE() << \" \" << __FILE__\n#define DEBUGLN(x) DEBUG(x)<<endl\n#define LINE()    cerr<< \" (L\" << __LINE__ << \")\"\n#define LINELN()    LINE()<<endl\n#define CHECK(exp,act)  if(exp!=act){DUMPLN(exp);DEBUGLN(act);}\n#define STOP(e)  CHECK(e,true);if(!(e)) exit(1);\n#endif\n\ntemplate<class T> inline string toString(const vector<T>& x) {\n\tstringstream ss;\n\tREP(i,x.size()){\n\t\tif(i!=0)ss<<\" \";\n\t\tss<< x[i];\n\t}\n\treturn ss.str();\n}\n\ntemplate<class T> inline string toString(const vector<vector<T> >& map) {\n\tstringstream ss;\n\tREP(i,map.size()){\n\t\tif(i!=0)ss<<BR;\n\t\tss<< toString(map[i]);\n\t}\n\treturn ss.str();\n}\ntemplate<class K,class V>  string toString(map<K,V>& x) {\n\tstring res;stringstream ss;\n\tfor(auto& p:x)ss<< p.first<<\":\" << p.second<<\" \";\n\treturn ss.str();\n}\n\nstring BITtoString(int bit){\n    stringstream ss;\n    while(bit!=0){ss<<(bit%2);bit/=2;}\n    string res=ss.str();reverse(ALL(res));\n    return res;\n}\n\ntemplate<typename T,typename V> inline T pmod(T v,V MOD){\n\treturn (v%MOD+MOD)%MOD;\n}\ndouble pfmod(double v,double MOD){\n\treturn fmod(fmod(v,MOD)+MOD,MOD);\n}\n\nclass Comp{\npublic:\n\tbool operator () (const pair<int,int>& l,const pair<int,int>& r){\n\t\tif(l.first!=r.first)return l.first>r.first;\n\t\treturn l.second<r.second;\n\t}\n};\n\nnamespace Ps{\n\tconst double EPS = 1e-8;\n\tconst double INF = 1e12;\n\n\ttypedef complex<double> P;\n\t#define X(a) (real(a))\n\t#define Y(a) (imag(a))\n\t\n\t// a×b\n\tdouble cross(const P& a,const P& b){\n\t\treturn imag(conj(a)*b);\n\t}\n\t// a・b\n\tdouble dot(const P&a,const P& b) {\n\t\treturn real(conj(a)*b);\n\t}\n\n\t int ccw(const P& a,P b,P c){\n\t\tb -= a; c -= a;\n\t\t  if (cross(b,c) > 0)   return +1;       // counter clockwise\n\t\t  if (cross(b,c) < 0)   return -1;       // clockwise\n\t\t  if (dot(b,c) < 0)     return +2;       // c--a--b on line\n\t\t  if (norm(b) < norm(c)) return -2;       // a--b--c on line\n\t\t  return 0;\n\t  }\n}\nusing namespace Ps;\n\nclass Main{\npublic:\n\t\n\tbool canReach(int x,int y,int w,int a,int d){\n\t\tif((ll)x*x+(ll)y*y<=(ll)a*a)\n\t\tif(pfmod(fabs(w*M_PI/180-atan2(y,x)),M_PI)<=d*M_PI/180/2)return true;\n\t\t\n\t\treturn false;\n\t}\n\n\tvoid run(){\n\n\t\twhile(true){\n\t\t\tint H,R;scanf(\"%d%d\",&H,&R);if(H==0)break;\n\n\t\t\tvector<int> xs(H),ys(H);\n\t\t\tREP(h,H)scanf(\"%d%d\",&xs[h],&ys[h]);\n\t\t\tint U,M,S,du,dm,ds;scanf(\"%d%d%d%d%d%d\",&U,&M,&S,&du,&dm,&ds);\n\n\t\t\tvector<int> uxs(U),uys(U);vector<int> mxs(M),mys(M);vector<int> sxs(S),sys(S);\n\t\t\tREP(i,U)scanf(\"%d%d\",&uxs[i],&uys[i]);\n\t\t\tREP(i,M)scanf(\"%d%d\",&mxs[i],&mys[i]);\n\t\t\tREP(i,S)scanf(\"%d%d\",&sxs[i],&sys[i]);\n\t\t\t\n\t\t\tvector<int> ws(R),as(R);\n\t\t\tREP(i,R)scanf(\"%d%d\",&ws[i],&as[i]);\n\n\n\t\t\tvector<pair<int,int>> res;\n\t\t\tREP(h,H){\n\t\t\t\tint x=xs[h],y=ys[h];\n\n\t\t\t\tint okc=0;\n\t\t\t\tREP(r,R){\n\t\t\t\t\tint w=ws[r],a=as[r];\n\t\t\t\t\tbool ok=false;\n\t\t\t\t\tif(canReach(x,y,w,a,du))ok=true;\n\t\t\t\t\tREP(i,U)if(canReach(x-uxs[i],y-uys[i],w,a,du))ok=false;\n\t\t\t\t\tREP(i,M)if(canReach(x-mxs[i],y-mys[i],w,a,dm))ok=false;\n\t\t\t\t\tREP(i,S)if(canReach(x-sxs[i],y-sys[i],w,a,ds))ok=false;\n\t\t\t\t\tif(ok)okc++;\n\t\t\t\t}\n\t\t\t\tres.push_back(make_pair(okc,h+1));\n\t\t\t}\n\t\t\tsort(ALL(res),Comp());\n\n\t\t\tint Mh=res[0].first;\n\t\t\t\n\t\t\tif(Mh==0){\n\t\t\t\tcout<<\"NA\"<<endl;continue;\n\t\t\t}\n\n\t\t\tfor(int i=0;i<H && Mh==res[i].first;i++){\n\t\t\t\tif(i!=0)cout <<\" \";\n\t\t\t\tcout << res[i].second; \n\t\t\t}\n\t\t\tcout <<endl;\n\t\t}\n\t}\n};\n\n int main(){\n\t//ios::sync_with_stdio(false);\n \tMain().run();\n \treturn 0;\n }"
  },
  {
    "language": "C++",
    "code": "\n//自分の梅は任意の地点でかおるとする。→間違い。\n//EPSはつけない。\n//扇形と家は接しないので、距離はsqrtで求めた。\n\n#include<iostream>\n#include<cmath>\n#include<vector>\n#define rep(i,n) for(i = 0;i < n;i++)\n#define PI 3.14159265358979\nusing namespace std;\n\ntypedef pair<double,double> P;\n\nint H,R;\t\t\t\t//家数,日数\nint hx[100],hy[100];\t//家の座標\nint U,M,S;\t\t\t\t//梅、桃、桜の数\nint du,dm,ds;\t\t\t//梅、桃、桜の扇形の中心角\nint ux[100],uy[100];\t//梅の座標\nint mx[100],my[100];\t//桃の座標\nint sx[100],sy[100];\t//桜の座標\nint w[100],a[100];\t\t//扇形の方向(角度),風の強さ\n\n//半径,角度の順で格納し、返す\n//rotateは角度補正( 補正 = rotate*360 )\nP POLAR( int treex,int treey,int housex,int housey,int rotate )\n{\n\tP ans;\n\tans.first = (housex-treex)*(housex-treex) + (housey-treey)*(housey-treey);\n\tans.first = sqrt( ans.first );\n\tif( housex == treex && housey > treey )\n\t\tans.second = 90;\n\telse if( housex == treex && housey < treey )\n\t\tans.second = -90;\n\telse\n\t\tans.second = atan2( (double)housey - treey, (double)housex - treex ) * 180 / PI;\n\tans.second += 360*rotate;\n\treturn ans;\n}\n\nint main()\n{\n\tint i,j,k,l;\n\twhile( cin >> H >> R )\n\t{\n\t\tint day[100] = {0};\t\t//i番目の家において、他の木の香りが届かなかった日数\n\n\t\tif( H == 0 && R == 0 )\n\t\t\tbreak;\n\t\trep(i,H)\n\t\t\tcin >> hx[i] >> hy[i];\n\t\tcin >> U >> M >> S >> du >> dm >> ds;\n\t\trep(i,U)\n\t\t\tcin >> ux[i] >> uy[i];\n\t\trep(i,M)\n\t\t\tcin >> mx[i] >> my[i];\n\t\trep(i,S)\n\t\t\tcin >> sx[i] >> sy[i];\n\t\trep(i,R)\n\t\t\tcin >> w[i] >> a[i];\n\t\t//ここから探索\n\t\trep(i,R){\n\t\t\trep(j,H){\n\t\t\t\trep(k,U){\n\t\t\t\t\trep(l,3){\n\t\t\t\t\t\tP t = POLAR( ux[k],uy[k],hx[j],hy[j],l-1 );\n\t\t\t\t\t\t//判定\n\t\t\t\t\t\tif( t.first <= a[i] && fabs( (double)w[i] - t.second ) <= du/2.0 )\n\t\t\t\t\t\t\tbreak;\n\t\t\t\t\t}\n\t\t\t\t\tif(l < 3)\n\t\t\t\t\t\tbreak;\n\t\t\t\t}\n\t\t\t\tif(k < U)\n\t\t\t\t\tcontinue;\n\t\t\t\trep(k,M){\n\t\t\t\t\trep(l,3){\n\t\t\t\t\t\tP t = POLAR( mx[k],my[k],hx[j],hy[j],l-1 );\n\t\t\t\t\t\t//判定\n\t\t\t\t\t\tif( t.first <= a[i] && fabs( (double)w[i] - t.second ) <= dm/2.0 )\n\t\t\t\t\t\t\tbreak;\n\t\t\t\t\t}\n\t\t\t\t\tif(l < 3)\n\t\t\t\t\t\tbreak;\n\t\t\t\t}\n\t\t\t\tif(k < M)\n\t\t\t\t\tcontinue;\n\t\t\t\trep(k,S){\n\t\t\t\t\trep(l,3){\n\t\t\t\t\t\tP t = POLAR( sx[k],sy[k],hx[j],hy[j],l-1 );\n\t\t\t\t\t\t//判定\n\t\t\t\t\t\tif( t.first <= a[i] && fabs( (double)w[i] - t.second ) <= ds/2.0 )\n\t\t\t\t\t\t\tbreak;\n\t\t\t\t\t}\n\t\t\t\t\tif(l < 3)\n\t\t\t\t\t\tbreak;\n\t\t\t\t}\n\t\t\t\tif(k < S)\n\t\t\t\t\tcontinue;\n\n\t\t\t\t//私の梅の香りは届くのか！！\n\t\t\t\trep(l,3){\n\t\t\t\t\tP t = POLAR( 0,0,hx[j],hy[j],l-1 );\n\t\t\t\t\t//判定\n\t\t\t\t\tif( t.first <= a[i] && fabs( (double)w[i] - t.second ) <= du/2.0 )\n\t\t\t\t\t\tbreak;\n\t\t\t\t}\n\t\t\t\tif( l < 3 )\n\t\t\t\t\tday[j]++;\n\t\t\t}\n\t\t}\n\t\tint maxday = 0;\n\t\trep(i,H){\n\t\t\tmaxday = max( maxday,day[i] );\n\t\t}\n\t\tif( maxday == 0 ){\n\t\t\tcout << \"NA\" << endl;\n\t\t\tcontinue;\n\t\t}\n\t\trep(i,H){\n\t\t\tif( day[i] == maxday ){\n\t\t\t\tcout << i+1;\n\t\t\t\tif( i < H-1 )\n\t\t\t\t\tcout << ' ';\n\t\t\t\telse\n\t\t\t\t\tcout << endl;\n\t\t\t}\n\t\t}\n\t}\n\treturn 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\n\nusing namespace std;\n\nstruct point {\n    int x, y;\n    int d;\n};\n\nbool check_including(point home, point ums, int w, int a) {\n\n    double x = home.x - ums.x;\n    double y = home.y - ums.y;\n    double home_deg;\n    double start_deg = w - ums.d / 2.0;\n    double end_deg = w + ums.d / 2.0;\n\n    home_deg = atan2(y, x) * 180 / M_PI;\n\n    if(home_deg < 0) {\n        home_deg += 360;\n    }\n\n    if(start_deg < 0) {\n        start_deg += 360;\n        end_deg += 360;\n    }\n\n    if(end_deg > 360.0) {\n        home_deg += 360;\n    }\n\n\n    if(start_deg <= home_deg && home_deg <= end_deg && x * x + y * y <= a * a) {\n        return true;\n    } else {\n        return false;\n    }\n\n}\n\nint main() {\n\n    int h, r;\n\n    while(cin >> h >> r, h || r) {\n\n        int u, m, s, du, dm, ds;\n        vector<point> homes, ums;\n\n        for(int i = 0; i < h; ++i) {\n            int x, y;\n            cin >> x >> y;\n            homes.push_back((point){ x, y, 0 });\n        }\n\n        cin >> u >> m >> s;\n        cin >> du >> dm >> ds;\n\n        for(int i = 0; i < u + m + s; ++i) {\n            int x, y;\n            cin >> x >> y;\n            if(i < u) {\n                ums.push_back((point){ x, y, du });\n            } else if(u <= i && i < u + m) {\n                ums.push_back((point){ x, y, dm });\n            } else {\n                ums.push_back((point){ x, y, ds });\n            }\n        }\n\n        for(int i = 0; i < r; ++i) {\n            int w, a;\n            cin >> w >> a;\n            for(int j = 0; j < homes.size(); ++j) {\n                bool is_perfect = true;\n                for(int k = 0; k < ums.size(); ++k) {\n                    if(check_including(homes[j], ums[k], w, a)) {\n                        is_perfect = false;\n                    }\n                }\n                homes[j].d += is_perfect;\n            }\n        }\n\n        int max_day = 0;\n        for(int i = 0; i < homes.size(); ++i) {\n            if(max_day < homes[i].d) {\n                max_day = homes[i].d;\n            }\n        }\n\n        if(max_day) {\n            bool is_out = false;\n            for(int i = 0; i < homes.size(); ++i) {\n                if(homes[i].d == max_day) {\n                    if(is_out) cout << \" \" << i + 1;\n                    else cout << i + 1;\n                    is_out = true;\n                }\n            }\n            cout << endl;\n        } else {\n            cout << \"NA\" << endl;\n        }\n\n    }\n\n}"
  },
  {
    "language": "C++",
    "code": "#include<iostream>\n#include<vector>\n#include<cmath>\n#include<algorithm>\n#include<numeric>\nusing namespace std;\n\nconst double PI = 3.14159265358979;\nconst double EPS = 1e-9;\n\nclass Point {\npublic:\n    double x, y;\n    Point(double x = 0.0, double y = 0.0) :x(x), y(y) {}\n};\n\nclass Wind {\npublic:\n    double w, a;\n};\n\nbool include(double angle, double low, double high) {\n    if(low < 0 + EPS) {\n        double l = low + 2.0 * PI;\n        if(l <= angle + EPS) return true;\n    }\n    if(high > 2.0 * PI + EPS) {\n        double h = high - 2.0 * PI;\n        if(angle <= h + EPS) return true;\n    }\n    return low <= angle + EPS && angle <= high + EPS;\n}\n\nbool savor(const Point &home, const Wind &wind, const vector<Point> &blossom, double d) {\n    d /= 2.0;\n    for(const auto &b: blossom) {\n        Point dif(home.x - b.x, home.y - b.y);\n        double angle = atan2(dif.y, dif.x);\n        double dist = hypot(dif.y, dif.x);\n        if(angle < 0) angle = angle + 2 * PI;\n        if(dist <= wind.a + EPS && include(angle, wind.w - d, wind.w + d)) return true;\n    }\n    return false;\n}\n\ndouble toRadian(double d) {\n    return d * PI / 180.0;\n}\n\nint main() {\n    int H, R;\n    while(cin >> H >> R, H | R) {\n        vector<Point> home(H);\n        for(auto &i: home) cin >> i.x >> i.y;\n\n        int U, M, S;\n        double du, dm, ds;\n        cin >> U >> M >> S >> du >> dm >> ds;\n\n        du = toRadian(du);\n        dm = toRadian(dm);\n        ds = toRadian(ds);\n\n        vector<Point> plum(U), peach(M), cherry(S);\n        for(auto &i: plum) cin >> i.x >> i.y;\n        for(auto &i: peach) cin >> i.x >> i.y;\n        for(auto &i: cherry) cin >> i.x >> i.y;\n\n        vector<Wind> wind(R);\n        for(auto &i: wind) cin >> i.w >> i.a;\n        for(auto &i: wind) i.w = toRadian(i.w);\n\n        // solve\n        vector<int> number(H, 0);\n        int maxNumber = 0;\n\n        for(int i = 0; i < H; ++i) {\n            for(int day = 0; day < R; ++day) {\n                bool ok = savor(home[i], wind[day], {Point(0.0, 0.0)}, du);\n                bool ng = false;\n                ng |= savor(home[i], wind[day], plum, du);\n                ng |= savor(home[i], wind[day], peach, dm);\n                ng |= savor(home[i], wind[day], cherry, ds);\n\n                if(!ok || ng) continue;\n\n                ++number[i];\n                maxNumber = max(maxNumber, number[i]);\n            }\n        }\n\n        if(maxNumber) {\n            bool first = true;\n            for(int i = 0; i < H; ++i) if(number[i] == maxNumber) {\n                if(!first) cout << \" \";\n                first = false;\n                cout << i + 1;\n            }\n            cout << endl;\n        } else {\n            cout << \"NA\" << endl;\n        }\n    }\n}"
  },
  {
    "language": "C++",
    "code": "#include <iostream>\n#include <cstdio>\n#include <iomanip>\n#include <vector>\n#include <map>\n#include <set>\n#include <queue>\n#include <bitset>\n#include <stack>\n#include <utility>\n#include <numeric>\n#include <algorithm>\n#include <functional>\n#include <cctype>\n#include <complex>\n#include <string>\n#include <sstream>\n#include <fstream>\n#include <cassert>\nusing namespace std;\n\n//common\ntypedef long long i64,ll;\n\n#define BR \"\\n\"\n#define ALL(c) (c).begin(),(c).end()\n#define REP(i,n) for(int i=0;i<(int)(n);++i)\n#define FOR(i,l,r) for(int i=(l);i<(int)(r);++i)\n#define EACH(it,o) for(auto it = (o).begin(); it != (o).end(); ++it)\n#define IN(l,v,r) ((l)<=(v) && (v)<(r))\n\n//debug\n#ifdef NDEBUG\n#define DUMP(x)\n#define DUMPLN(x)\n#define DEBUG(x)\n#define DEBUGLN(x)\n#define LINE()\n#define LINELN()\n#define CHECK(exp,act)\n#define STOP(e)\n#else\n#define DUMP(x)  cerr << #x << \" = \" << (x)\n#define DUMPLN(x)  DUMP(x) <<endl\n#define DEBUG(x) DUMP(x) << LINE() << \" \" << __FILE__\n#define DEBUGLN(x) DEBUG(x)<<endl\n#define LINE()    cerr<< \" (L\" << __LINE__ << \")\"\n#define LINELN()    LINE()<<endl\n#define CHECK(exp,act)  if(exp!=act){DUMPLN(exp);DEBUGLN(act);}\n#define STOP(e)  CHECK(e,true);if(!(e)) exit(1);\n#endif\n\ntemplate<class T> inline string toString(const vector<T>& x) {\n\tstringstream ss;\n\tREP(i,x.size()){\n\t\tif(i!=0)ss<<\" \";\n\t\tss<< x[i];\n\t}\n\treturn ss.str();\n}\n\ntemplate<class T> inline string toString(const vector<vector<T> >& map) {\n\tstringstream ss;\n\tREP(i,map.size()){\n\t\tif(i!=0)ss<<BR;\n\t\tss<< toString(map[i]);\n\t}\n\treturn ss.str();\n}\ntemplate<class K,class V>  string toString(map<K,V>& x) {\n\tstring res;stringstream ss;\n\tfor(auto& p:x)ss<< p.first<<\":\" << p.second<<\" \";\n\treturn ss.str();\n}\n\nstring BITtoString(int bit){\n    stringstream ss;\n    while(bit!=0){ss<<(bit%2);bit/=2;}\n    string res=ss.str();reverse(ALL(res));\n    return res;\n}\n\ntemplate<typename T,typename V> inline T pmod(T v,V MOD){\n\treturn (v%MOD+MOD)%MOD;\n}\ndouble pfmod(double v,double MOD){\n\treturn fmod(fmod(v,MOD)+MOD,MOD);\n}\n\nclass Comp{\npublic:\n\tbool operator () (const pair<int,int>& l,const pair<int,int>& r){\n\t\tif(l.first!=r.first)return l.first>r.first;\n\t\treturn l.second<r.second;\n\t}\n};\n\nnamespace Ps{\n\tconst double EPS = 1e-8;\n\tconst double INF = 1e12;\n\n\ttypedef complex<double> P;\n\t#define X(a) (real(a))\n\t#define Y(a) (imag(a))\n\t\n\t// a×b\n\tdouble cross(const P& a,const P& b){\n\t\treturn imag(conj(a)*b);\n\t}\n\t// a・b\n\tdouble dot(const P&a,const P& b) {\n\t\treturn real(conj(a)*b);\n\t}\n\n\t int ccw(const P& a,P b,P c){\n\t\tb -= a; c -= a;\n\t\t  if (cross(b,c) > 0)   return +1;       // counter clockwise\n\t\t  if (cross(b,c) < 0)   return -1;       // clockwise\n\t\t  if (dot(b,c) < 0)     return +2;       // c--a--b on line\n\t\t  if (norm(b) < norm(c)) return -2;       // a--b--c on line\n\t\t  return 0;\n\t  }\n}\nusing namespace Ps;\n\ndouble Abs(double a){double ret=max(a,-a);if(ret>M_PI)ret=2*M_PI-ret;return ret;}\nclass Main{\npublic:\n\tbool canReach(int x,int y,int w,int a,int d){\n\t\tif((ll)x*x+(ll)y*y<=(ll)a*a){\n\t\t\tdouble wr=w*M_PI/180;\n\t\t\tif(wr>M_PI)wr-=2*M_PI;\n\t\t\tif(Abs(wr-atan2(y,x))<=d*M_PI/180/2)return true;\n\t\t}\n\t\treturn false;\n\t}\n\n\tvoid run(){\n\n\t\twhile(true){\n\t\t\tint H,R;scanf(\"%d%d\",&H,&R);if(H==0)break;\n\n\t\t\tvector<int> xs(H),ys(H);\n\t\t\tREP(h,H)scanf(\"%d%d\",&xs[h],&ys[h]);\n\t\t\tint U,M,S,du,dm,ds;scanf(\"%d%d%d%d%d%d\",&U,&M,&S,&du,&dm,&ds);\n\n\t\t\tvector<int> uxs(U),uys(U);vector<int> mxs(M),mys(M);vector<int> sxs(S),sys(S);\n\t\t\tREP(i,U)scanf(\"%d%d\",&uxs[i],&uys[i]);\n\t\t\tREP(i,M)scanf(\"%d%d\",&mxs[i],&mys[i]);\n\t\t\tREP(i,S)scanf(\"%d%d\",&sxs[i],&sys[i]);\n\t\t\t\n\t\t\tvector<int> ws(R),as(R);\n\t\t\tREP(i,R)scanf(\"%d%d\",&ws[i],&as[i]);\n\n\n\t\t\tvector<pair<int,int>> res;\n\t\t\tREP(h,H){\n\t\t\t\tint x=xs[h],y=ys[h];\n\n\t\t\t\tint okc=0;\n\t\t\t\tREP(r,R){\n\t\t\t\t\tint w=ws[r],a=as[r];\n\t\t\t\t\tbool ok=false;\n\t\t\t\t\tif(canReach(x,y,w,a,du))ok=true;\n\t\t\t\t\tREP(i,U)if(canReach(x-uxs[i],y-uys[i],w,a,du))ok=false;\n\t\t\t\t\tREP(i,M)if(canReach(x-mxs[i],y-mys[i],w,a,dm))ok=false;\n\t\t\t\t\tREP(i,S)if(canReach(x-sxs[i],y-sys[i],w,a,ds))ok=false;\n\t\t\t\t\tif(ok)okc++;\n\t\t\t\t}\n\t\t\t\tres.push_back(make_pair(okc,h+1));\n\t\t\t}\n\t\t\tsort(ALL(res),Comp());\n\n\t\t\tint Mh=res[0].first;\n\t\t\t\n\t\t\tif(Mh==0){\n\t\t\t\tcout<<\"NA\"<<endl;continue;\n\t\t\t}\n\n\t\t\tfor(int i=0;i<H && Mh==res[i].first;i++){\n\t\t\t\tif(i!=0)cout <<\" \";\n\t\t\t\tcout << res[i].second; \n\t\t\t}\n\t\t\tcout <<endl;\n\t\t}\n\t}\n};\n\n int main(){\n\t//ios::sync_with_stdio(false);\n \tMain().run();\n \treturn 0;\n }"
  },
  {
    "language": "C++",
    "code": "#include <iostream>\n#include <string>\n#include <vector>\n#include <algorithm>\n#include <cmath>\n\n#define REP(i,k,n) for(int i=k;i<n;i++)\n#define rep(i,n) for(int i=0;i<n;i++)\n#define EPS 1e-8\n#define equals(a,b) fabs((a) - (b)) < EPS\n#define PI acos(-1)\n\nusing namespace std;\n\nstruct Point\n{\n    double x, y;\n\n    Point(double x=0, double y=0) : x(x), y(y) {}\n\n    Point operator+(const Point &o) const { return Point(x+o.x, y+o.y); }\n\n    Point operator-(const Point &o) const { return Point(x-o.x, y-o.y); }\n\n    Point operator*(const double m) const { return Point(x*m, y*m); }\n\n    Point operator/(const double d) const { return Point(x/d, y/d); }\n\n    Point operator<(const Point &o) const { return x != o.x ? x < o.x : y < o.y; }\n\n\tbool operator==(const Point &o) const { return fabs(x-o.x) < EPS && fabs(y-o.y) < EPS; }\n\n\tdouble cross(const Point &o) const { return x * o.y - y * o.x; }\n\n    double dot(const Point &o) const { return x * o.x + y * o.y; }\n\n    double atan() const { return atan2(y, x); }\n\n\tdouble deg() const { return atan() * 180.0 / (acos(-1) * 4.0); }\n\n    double norm() const { return sqrt(dot(*this)); }\n\n    double distance(const Point &o) const { return (o - (*this)).norm(); }\n\n    double area(const Point &a,const Point &b)\n    {\n\t    Point p = a - (*this), p2 = b - (*this); \n\t    return p.cross(p2);\n    }\n\n    double area_abs(const Point &a,const Point &b) const\n    {\n\t    Point p = a - (*this), p2 = b - (*this);\n\t    return fabs(p.cross(p2)) / 2.0;\n    }\t\n\n    //線分abが自身に含まれているのかどうか判断する\n    int between(const Point &a,const Point &b)\n\t{\n\t\tif(area(a,b) != 0) return 0;\n\n    \tif(a.x != b.x)\n\t    {\n\t\t    return ((a.x <= x) && (x <= b.x) || (a.x >= x) && (x >= b.x));\n\t    }\n\t    else\n\t    {\n\t    \treturn ((a.y <= y) && (y <= b.y) || (a.y >= y) && (y >= b.y));\n\t    }\n    }      \n\n\tdouble distance_seg(const Point& a,const Point& b)\n\t{\n    \tif((b-a).dot(*this-a) < EPS)\n    \t{\n\t    \treturn (*this-a).norm();\n\t    }\n\t    if((a-b).dot(*this-b) < EPS)\n    \t{\n\t    \treturn (*this-b).norm();\n    \t}\n\t    return abs((b-a).cross(*this-a)) / (b-a).norm();\n    }\n\n    bool hitPolygon(const Point& a,const Point& b,const Point& c)\n\t{\n    \tdouble t = (b-a).cross(*this-b);\n    \tdouble t2 = (c-b).cross(*this-c);\n    \tdouble t3 = (a-c).cross(*this-a);\n    \tif((t > 0 && t2 > 0 && t3 > 0) || ( t < 0 && t2 < 0 && t3 < 0))\n    \t{\n    \t\treturn true;\n    \t}\n\n\t    return false;\n    }\n};\n\nint ccw(Point a,Point b,Point c)\n{\n    b = b-a;\n    c = c-a;\n\n    if(b.cross(c) > 0.0) return +1;\t//conter clockwise\n    if(b.cross(c) < 0.0) return -1;\t//clockwise\n    if(b.dot(c) < 0.0) return +2;\t//a on Seg(b,c)\n    if(b.norm() < c.norm()) return -2;\t//b on Seg(a,c)\n    return 0;\t//c on Seg(a,b)\n}\n\nbool inPolygon(Point p,Point a,Point b,Point c)\n{\n\tif(ccw(a,b,p) == -1 && ccw(a,c,p) == +1) return true;\n\n\treturn false;\n}\n\ndouble to_rad(double r)\n{\n\treturn r*PI/180;\n}\n\nbool hit(Point s,Point v,double d,double w,double a)\n{\n\tdouble x = a*cos(to_rad(w + d/2));\n\tdouble y = a*sin(to_rad(w + d/2));\n\tPoint p(x,y);\n\n\tx = a*cos(to_rad(w - d/2));\n\ty = a*sin(to_rad(w - d/2));\n\tPoint p2(x,y);\n\n\tif(inPolygon(v,s,s+p,s+p2)) return true;\n\treturn false;\n}\n\nint main()\n{\n\tint h,r;\n\twhile(cin >> h >> r)\n\t{\n\t\tif(h == 0 && r == 0) break;\n\n\t\tvector<Point> v;\n\t\trep(i,h)\n\t\t{\n\t\t\tdouble x,y;\n\t\t\tcin >> x >> y;\n\t\t\tv.push_back(Point(x,y));\n\t\t}\n\n\t\tint u,m,s;\n\t\tdouble du,dm,ds;\n\t\tcin >> u >> m >> s >> du >> dm >> ds;\n\n\t\tvector<Point> ume;\n\t\trep(i,u)\n\t\t{\n\t\t\tdouble x,y;\n\t\t\tcin >> x >> y;\n\t\t\tume.push_back(Point(x,y));\n\t\t}\n\t\t\n\t\tvector<Point> momo;\n\t\trep(i,m)\n\t\t{\n\t\t\tdouble x,y;\n\t\t\tcin >> x >> y;\n\t\t\tmomo.push_back(Point(x,y));\n\t\t}\n\n\t\tvector<Point> sakura;\n\t\trep(i,s)\n\t\t{\n\t\t\tdouble x,y;\n\t\t\tcin >> x >> y;\n\t\t\tsakura.push_back(Point(x,y));\n\t\t}\n\n\t\tvector<pair<int,int> > wind;\n\t\trep(i,r)\n\t\t{\n\t\t\tint w,a;\n\t\t\tcin >> w >> a;\n\t\t\twind.push_back(make_pair(w,a));\n\t\t}\n\n\t\tvector<pair<int,int> > ret;\n\t\tPoint S(0,0);\n\t\trep(i,h)\n\t\t{\n\t\t\tint cnt = 0;\n\t\t\tdouble d = v[i].distance(S);\n\t\t\t\n\t\t\trep(j,r)\n\t\t\t{\n\t\t\t\tif(d > wind[j].second) continue;\n\t\t\t\n\t\t\t\tif(hit(S,v[i],du,wind[j].first,wind[j].second)) cnt++;\n\t\t\t}\n\n\t\t\trep(j,r)\n\t\t\t{\n\t\t\t\tbool only = true;\n\n\t\t\t\trep(k,u)\n\t\t\t\t{\n\t\t\t\t\tdouble d = v[i].distance(ume[k]);\n\n\t\t\t\t\tif(d > wind[j].second) continue;\n\t\t\t\t\tif(hit(ume[k],v[i],du,wind[j].first,wind[j].second))\n\t\t\t\t\t{\n\t\t\t\t\t\tonly = false;\n\t\t\t\t\t}\n\t\t\t\t}\n\n\t\t\t\trep(k,m)\n\t\t\t\t{\n\t\t\t\t\tdouble d = v[i].distance(momo[k]);\n\n\t\t\t\t\tif(d > wind[j].second) continue;\n\t\t\t\t\tif(hit(momo[k],v[i],dm,wind[j].first,wind[j].second))\n\t\t\t\t\t{\n\t\t\t\t\t\tonly = false;\n\t\t\t\t\t}\n\t\t\t\t}\n\n\t\t\t\trep(k,s)\n\t\t\t\t{\n\t\t\t\t\tdouble d = v[i].distance(sakura[k]);\n\n\t\t\t\t\tif(d > wind[j].second) continue;\n\t\t\t\t\tif(hit(sakura[k],v[i],ds,wind[j].first,wind[j].second))\n\t\t\t\t\t{\n\t\t\t\t\t\tonly = false;\n\t\t\t\t\t}\n\t\t\t\t}\n\n\t\t\t\tif(!only) cnt--;\n\t\t\t}\n\n\t\t\tif(cnt > 0)\n\t\t\t{\n\t\t\t\tret.push_back(make_pair(cnt,i));\n\t\t\t}\n\t\t}\n\n\t\tif(ret.size() == 0) cout << \"NA\" << endl;\n\t\telse\n\t\t{\n\t\t\tsort(ret.begin(),ret.end());\n\t\t\t\n\t\t\tvector<int> ans;\n\t\t\trep(i,ret.size())\n\t\t\t{\n\t\t\t\tif(ret[i].first == ret[ret.size()-1].first)\n\t\t\t\t{\n\t\t\t\t\tans.push_back(ret[i].second);\n\t\t\t\t}\n\t\t\t}\n\n\t\t\tsort(ans.begin(),ans.end());\n\n\t\t\trep(i,ans.size())\n\t\t\t{\n\t\t\t\tcout << ans[i] + 1;\n\n\t\t\t\tif(i == ans.size()-1) cout << endl;\n\t\t\t\telse cout << \" \";\n\t\t\t}\n\t\t}\n\t}\n\n\treturn 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include \"bits/stdc++.h\"\n#include<unordered_map>\n#include<unordered_set>\n#pragma warning(disable:4996)\nusing namespace std;\nusing ld = long double;\ntemplate<class T>\nusing Table = vector<vector<T>>;\nconst ld eps=1e-9;\n\n/* ??????????????¬ */\n\n#include <complex>\n\ntypedef long double ld;\ntypedef complex<ld> Point;\n#define REP(i,n) for(int i=0;i<(int)(n);i++)\n#define ALL(x) (x).begin(),(x).end()\n\n\nconst ld pi = acos(-1.0);\nconst ld dtop = pi / 180.;\nconst ld ptod = 1. / dtop;\n\nnamespace std {\n\tbool operator<(const Point &lhs, const Point &rhs) {\n\t\tif (lhs.real() < rhs.real() - eps) return true;\n\t\tif (lhs.real() > rhs.real() + eps) return false;\n\t\treturn lhs.imag() < rhs.imag();\n\t}\n}\n\n// ????????\\???\nPoint input_point() {\n\tld x, y;\n\tcin >> x >> y;\n\treturn Point(x, y);\n}\n\n// ????????????????????????\nbool eq(const ld a, const ld b) {\n\treturn (abs(a - b) < eps);\n}\n\n// ??????\nld dot(const Point& a, const Point& b) {\n\treturn real(conj(a) * b);\n}\n\n// ??????\nld cross(const Point& a, const Point& b) {\n\treturn imag(conj(a) * b);\n}\n\n// ??´????????????\nclass Line {\npublic:\n\tPoint a, b;\n\tLine() : a(Point(0, 0)), b(Point(0, 0)) {}\n\tLine(Point a, Point b) : a(a), b(b) {}\n\tPoint operator[](const int _num)const {\n\t\tif (_num == 0)return a;\n\t\telse if (_num == 1)return b;\n\t\telse {\n\t\t\tassert(false);\n\t\t\treturn Point();\n\t\t}\n\t}\n};\n\n// ????????????\nclass Circle {\npublic:\n\tPoint p;\n\tld r;\n\tCircle() : p(Point(0, 0)), r(0) {}\n\tCircle(Point p, ld r) : p(p), r(r) {}\n};\n\n// CCW\nint ccw(const Point& a, const Point &b, const Point &c) {\n\tconst Point nb(b - a);\n\tconst Point nc(c - a);\n\tif (cross(nb, nc) > eps) return 1;   // a,b,c??????????¨???¨?????????????????¶\n\tif (cross(nb, nc) < -eps) return -1; // a,b,c???????¨???¨?????????????????¶\n\tif (dot(nb, nc) < 0) return 2;       // c,a,b???????????´???????????¶\n\tif (norm(nb) < norm(nc)) return -2;  // a,b,c???????????´???????????¶\n\treturn 0;                          // a,c,b???????????´???????????¶\n}\n\n\n/* ???????????? */\n\n// ??´?????¨??´??????????????????\nbool isis_ll(const Line& l, const Line& m) {\n\treturn !eq(cross(l.b - l.a, m.b - m.a), 0);\n}\n\n// ??´?????¨?????????????????????\nbool isis_ls(const Line& l, const Line& s) {\n\treturn isis_ll(l, s) &&\n\t\t(cross(l.b - l.a, s.a - l.a) * cross(l.b - l.a, s.b - l.a) < eps);\n}\n\n// ????????¨?????????????????????\nbool isis_ss(const Line& s, const Line& t) {\n\treturn ccw(s.a, s.b, t.a) * ccw(s.a, s.b, t.b) <= 0 &&\n\t\tccw(t.a, t.b, s.a) * ccw(t.a, t.b, s.b) <= 0;\n}\n\n// ????????´????????????\nbool isis_lp(const Line& l, const Point& p) {\n\treturn (abs(cross(l.b - p, l.a - p)) < eps);\n}\n\n// ?????????????????????\nbool isis_sp(const Line& s, const Point& p) {\n\treturn (abs(s.a - p) + abs(s.b - p) - abs(s.b - s.a) < eps);\n}\n\n// ??????????¶?\nPoint proj(const Line &l, const Point& p) {\n\tld t = dot(p - l.a, l.a - l.b) / norm(l.a - l.b);\n\treturn l.a + t * (l.a - l.b);\n}\n\n// ??´?????¨??´????????????\nPoint is_ll(const Line &s, const Line& t) {\n\tPoint sv = s.b - s.a, tv = t.b - t.a;\n\tassert(cross(sv, tv) != 0);\n\treturn s.a + sv * cross(tv, t.a - s.a) / cross(tv, sv);\n}\n// ??´?????¨??´????????????\nvector<Point> is_ll2(const Line &s, const Line& t) {\n\tPoint sv = s.b - s.a, tv = t.b - t.a;\n\tif (cross(sv, tv) != 0)return vector<Point>(1, is_ll(s, t));\n\telse {\n\t\tvector<Point>ans;\n\t\tfor (int k = 0; k < 2; ++k) {\n\t\t\tif (isis_sp(s, t[k]) && find(ans.begin(), ans.end(), t[k]) == ans.end())ans.push_back(t[k]);\n\t\t\tif (isis_sp(t, s[k]) && find(ans.begin(), ans.end(), s[k]) == ans.end())ans.push_back(s[k]);\n\t\t}\n\t\treturn ans;\n\t}\n}\n// ????????¨???????????????\n//???????????£????????¨???????????¨assert(false)\nPoint is_ss(const Line &s, const Line& t) {\n\tif (isis_ss(s, t)) {\n\t\tfor (int k = 0; k < 2; ++k) {\n\t\t\tfor (int l = 0; l < 2; ++l) {\n\t\t\t\tif (s[k] == t[l])return s[k];\n\t\t\t}\n\t\t}\n\t\treturn is_ll(s, t);\n\t}\n\telse {\n\t\t//??????isis_ss?????????\n\t\tassert(false);\n\t\treturn Point(0, 0);\n\t}\n}\n// ????????¨???????????????\nvector<Point> is_ss2(const Line &s, const Line& t) {\n\tvector<Point> kouho(is_ll2(s, t));\n\tvector<Point>ans;\n\tfor (auto p : kouho) {\n\t\tif (isis_sp(s, p) && isis_sp(t, p))ans.emplace_back(p);\n\t}\n\treturn ans;\n}\n// ??´?????¨???????????¢\nld dist_lp(const Line& l, const Point& p) {\n\treturn abs(p - proj(l, p));\n}\n\n// ??´?????¨??´???????????¢\nld dist_ll(const Line& l, const Line& m) {\n\treturn isis_ll(l, m) ? 0 : dist_lp(l, m.a);\n}\n\n// ??´?????¨??????????????¢\nld dist_ls(const Line& l, const Line& s) {\n\treturn isis_ls(l, s) ? 0 : min(dist_lp(l, s.a), dist_lp(l, s.b));\n}\n\n// ????????¨???????????¢\nld dist_sp(const Line& s, const Point& p) {\n\tPoint r = proj(s, p);\n\treturn isis_sp(s, r) ? abs(r - p) : min(abs(s.a - p), abs(s.b - p));\n}\n\n// ????????¨??????????????¢\nld dist_ss(const Line& s, const Line& t) {\n\tif (isis_ss(s, t)) return 0;\n\treturn min({ dist_sp(s, t.a), dist_sp(s, t.b), dist_sp(t, s.a), dist_sp(t, s.b) });\n}\n\n\n//??´?????¨??´?????????????????????????????????\nLine bisection(const Line &s, const Line &t) {\n\tconst Point laglanju(is_ll(s, t));\n\tconst Point avec = !(abs(laglanju - s[0])<eps) ? s[0] - laglanju : s[1] - laglanju;\n\tconst Point bvec = !(abs(laglanju - t[0])<eps) ? t[0] - laglanju : t[1] - laglanju;\n\n\treturn Line(laglanju, laglanju + (abs(bvec)*avec + abs(avec)*bvec) / (abs(avec) + abs(bvec)));\n}\n\n\n//???????????´?????????????????????\n//???????????´??????????????§???????????¨????¢?????????¨?????????\nPoint  inner_center(const vector<Line>&ls) {\n\tvector<Point>vertics;\n\tfor (int i = 0; i <static_cast<int>(ls.size()); ++i) {\n\t\tvertics.push_back(is_ll(ls[i], ls[(i + 1) % 3]));\n\t}\n\tif (vertics[0] == vertics[1] || vertics[1] == vertics[2] || vertics[2] == vertics[0])return vertics[0];\n\tLine bi1(bisection(Line(vertics[0], vertics[1]), Line(vertics[0], vertics[2])));\n\tLine bi2(bisection(Line(vertics[1], vertics[2]), Line(vertics[1], vertics[0])));\n\tif (bi1[0] == bi2[0])return bi1[0];\n\telse {\n\t\treturn is_ll(bi1, bi2);\n\t}\n}\n\n//???????????´?????????????????????\n//???????????´??????????????§???????????¨????¢?????????¨?????????\nvector<Point>  ex_center(const vector<Line>&ls) {\n\tvector<Point>vertics;\n\tfor (int i = 0; i < static_cast<int>(ls.size()); ++i) {\n\t\tvertics.push_back(is_ll(ls[i], ls[(i + 1) % 3]));\n\t}\n\tif (abs(vertics[0] - vertics[1])<eps || abs(vertics[1] - vertics[2])<eps || (abs(vertics[2] - vertics[0])<eps))return vector<Point>();\n\tvector<Point>ecs;\n\tfor (int i = 0; i < 3; ++i) {\n\t\tLine bi1(bisection(Line(vertics[i], vertics[i] * 2.0l - vertics[(i + 2) % 3]), Line(vertics[i], vertics[(i + 1) % 3])));\n\t\tLine bi2(bisection(Line(vertics[(i + 1) % 3], vertics[(i + 1) % 3] * 2.0l - vertics[(i + 2) % 3]), Line(vertics[(i + 1) % 3], vertics[i])));\n\t\tecs.push_back(is_ll(bi1, bi2));\n\t}\n\treturn ecs;\n}\n\n\n//a,b:??????\n//c:????????§??????\n//???????????´?????????????????¢?????????????±??????????\nvector<Point>  same_dis(const vector<Line>&ls) {\n\tvector<Point>vertics;\n\tvertics.push_back(is_ll(ls[0], ls[2]));\n\tvertics.push_back(is_ll(ls[1], ls[2]));\n\n\tif (abs(vertics[0] - vertics[1]) < eps)return vector<Point>{vertics[0]};\n\tLine bis(bisection(ls[0], ls[1]));\n\tvector<Point>ecs;\n\n\tLine abi(bisection(Line(vertics[0], vertics[1]), ls[0]));\n\tecs.push_back(is_ll(bis, abi));\n\n\n\tLine bbi(bisection(Line(vertics[0], 2.l*vertics[0] - vertics[1]), ls[0]));\n\tecs.push_back(is_ll(bis, bbi));\n\n\treturn ecs;\n}\n/* ??? */\n\n// ?????¨????????????\nvector<Point> is_cc(const Circle& c1, const Circle& c2) {\n\tvector<Point> res;\n\tld d = abs(c1.p - c2.p);\n\tld rc = (d * d + c1.r * c1.r - c2.r * c2.r) / (2 * d);\n\tld dfr = c1.r * c1.r - rc * rc;\n\tif (abs(dfr) < eps) dfr = 0.0;\n\telse if (dfr < 0.0) return res; // no intersection\n\tld rs = sqrt(dfr);\n\tPoint diff = (c2.p - c1.p) / d;\n\tres.push_back(c1.p + diff * Point(rc, rs));\n\tif (dfr != 0.0) res.push_back(c1.p + diff * Point(rc, -rs));\n\treturn res;\n}\n\n//???????????????????????????\n//  0 => out\n//  1 => on\n//  2 => in\nint is_in_circle(const Circle &cir, const  Point& p) {\n\tld dis = abs(cir.p - p);\n\tif (dis > cir.r + eps)return 0;\n\telse if (dis < cir.r - eps)return 2;\n\telse return 1;\n}\n//???lc??????rc??????????????????\n//  0 => out\n//  1 => on\n//  2 => in\nint circle_in_circle(const Circle &lc, const  Circle&rc) {\n\tld dis = abs(lc.p - rc.p);\n\tif (dis < rc.r - lc.r - eps)return 2;\n\telse if (dis>rc.r - lc.r + eps)return 0;\n\telse return 1;\n}\n\n// ?????¨??´????????????\nvector<Point> is_lc(const Circle& c, const Line& l) {\n\tvector<Point> res;\n\tld d = dist_lp(l, c.p);\n\tif (d < c.r + eps) {\n\t\tld len = (d > c.r) ? 0.0 : sqrt(c.r * c.r - d * d); //safety;\n\t\tPoint nor = (l.a - l.b) / abs(l.a - l.b);\n\t\tres.push_back(proj(l, c.p) + len * nor);\n\t\tres.push_back(proj(l, c.p) - len * nor);\n\t}\n\treturn res;\n}\n\n// ?????¨??????????????¢\nvector<Point> is_sc(const Circle& c, const Line& l) {\n\tvector<Point> v = is_lc(c, l), res;\n\tfor (Point p : v)\n\t\tif (isis_sp(l, p)) res.push_back(p);\n\treturn res;\n}\n\n// ?????¨????????\\???\nvector<Line> tangent_cp(const Circle& c, const Point& p) {\n\tvector<Line> ret;\n\tPoint v = c.p - p;\n\tld d = abs(v);\n\tld l = sqrt(norm(v) - c.r * c.r);\n\tif (isnan(l)) { return ret; }\n\tPoint v1 = v * Point(l / d, c.r / d);\n\tPoint v2 = v * Point(l / d, -c.r / d);\n\tret.push_back(Line(p, p + v1));\n\tif (l < eps) return ret;\n\tret.push_back(Line(p, p + v2));\n\treturn ret;\n}\n\n// ?????¨????????\\???\nvector<Line> tangent_cc(const Circle& c1, const Circle& c2) {\n\tvector<Line> ret;\n\tif (abs(c1.p - c2.p) - (c1.r + c2.r) > -eps) {\n\t\tPoint center = (c1.p * c2.r + c2.p * c1.r) / (c1.r + c2.r);\n\t\tret = tangent_cp(c1, center);\n\t}\n\tif (abs(c1.r - c2.r) > eps) {\n\t\tPoint out = (-c1.p * c2.r + c2.p * c1.r) / (c1.r - c2.r);\n\t\tvector<Line> nret = tangent_cp(c1, out);\n\t\tret.insert(ret.end(), ALL(nret));\n\t}\n\telse {\n\t\tPoint v = c2.p - c1.p;\n\t\tv /= abs(v);\n\t\tPoint q1 = c1.p + v * Point(0, 1) * c1.r;\n\t\tPoint q2 = c1.p + v * Point(0, -1) * c1.r;\n\t\tret.push_back(Line(q1, q1 + v));\n\t\tret.push_back(Line(q2, q2 + v));\n\t}\n\treturn ret;\n}\n//??????????????????????????¢???\nld two_circle_area(const Circle&l, const Circle&r) {\n\tld dis = abs(l.p - r.p);\n\tif (dis > l.r + r.r)return 0;\n\telse if (dis + r.r < l.r) {\n\t\treturn r.r*r.r*pi;\n\t}\n\telse if (dis + l.r < r.r) {\n\t\treturn l.r*l.r*pi;\n\t}\n\telse {\n\t\tld ans = (l.r)*(l.r)*acos((dis*dis + l.r*l.r - r.r*r.r) / (2 * dis*l.r)) +\n\t\t\t(r.r)*(r.r)*acos((dis*dis + r.r*r.r - l.r*l.r) / (2 * dis*r.r)) -\n\t\t\tsqrt(4 * dis*dis*l.r*l.r - (dis*dis + l.r*l.r - r.r*r.r)*(dis*dis + l.r*l.r - r.r*r.r)) / 2;\n\t\treturn ans;\n\t}\n\n}\n\n/* ????§???¢ */\n\ntypedef vector<Point> Polygon;\n\n// ??¢???\nld area(const Polygon &p) {\n\tld res = 0;\n\tint n = p.size();\n\tREP(j, n) res += cross(p[j], p[(j + 1) % n]);\n\treturn res / 2;\n}\n\n// ????§???¢????????¢??????\nbool is_counter_clockwise(const Polygon &poly) {\n\tld angle = 0;\n\tint n = poly.size();\n\tREP(i, n) {\n\t\tPoint a = poly[i], b = poly[(i + 1) % n], c = poly[(i + 2) % n];\n\t\tangle += arg((c - b) / (b - a));\n\t}\n\treturn angle > eps;\n}\n\n// ??????????????????\n//  0 => out\n//  1 => on\n//  2 => in\nint is_in_polygon(const Polygon &poly, const  Point& p) {\n\tld angle = 0;\n\tint n = poly.size();\n\tREP(i, n) {\n\t\tPoint a = poly[i], b = poly[(i + 1) % n];\n\t\tif (isis_sp(Line(a, b), p)) return 1;\n\t\tangle += arg((b - p) / (a - p));\n\t}\n\treturn eq(angle, 0) ? 0 : 2;\n}\n//??????????????????2?????????\nenum { OUT, ON, IN };\nint convex_contains(const Polygon &P, const Point &p) {\n\tconst int n = P.size();\n\tPoint g = (P[0] + P[n / 3] + P[2 * n / 3]) / 3.0l; // inner-point\n\tint a = 0, b = n;\n\twhile (a + 1 < b) { // invariant: c is in fan g-P[a]-P[b]\n\t\tint c = (a + b) / 2;\n\t\tif (cross(P[a] - g, P[c] - g) > 0) { // angle < 180 deg\n\t\t\tif (cross(P[a] - g, p - g) > 0 && cross(P[c] - g, p - g) < 0) b = c;\n\t\t\telse                                                  a = c;\n\t\t}\n\t\telse {\n\t\t\tif (cross(P[a] - g, p - g) < 0 && cross(P[c] - g, p - g) > 0) a = c;\n\t\t\telse                                                  b = c;\n\t\t}\n\t}\n\tb %= n;\n\tif (cross(P[a] - p, P[b] - p) < 0) return 0;\n\tif (cross(P[a] - p, P[b] - p) > 0) return 2;\n\treturn 1;\n}\n\n// ??????\n// ???????????????????????¨????????????????????§??¨???\nPolygon convex_hull(vector<Point> ps) {\n\tint n = ps.size();\n\tint k = 0;\n\tsort(ps.begin(), ps.end());\n\tPolygon ch(2 * n);\n\tfor (int i = 0; i < n; ch[k++] = ps[i++])\n\t\twhile (k >= 2 && ccw(ch[k - 2], ch[k - 1], ps[i]) <= 0) --k;\n\tfor (int i = n - 2, t = k + 1; i >= 0; ch[k++] = ps[i--])\n\t\twhile (k >= t && ccw(ch[k - 2], ch[k - 1], ps[i]) <= 0) --k;\n\tch.resize(k - 1);\n\treturn ch;\n}\n\n\n\n// ????????????\nvector<Polygon> convex_cut(const Polygon &ps, const Line& l) {\n\tint n = ps.size();\n\tPolygon Q;\n\tPolygon R;\n\tREP(i, n) {\n\t\tPoint A = ps[i], B = ps[(i + 1) % n];\n\t\tLine m = Line(A, B);\n\t\tif (ccw(l.a, l.b, A) != -1) Q.push_back(A);\n\t\tif (ccw(l.a, l.b, A) != 1) R.push_back(A);\n\t\tif (ccw(l.a, l.b, A) * ccw(l.a, l.b, B) < 0 && isis_ll(l, m)) {\n\t\t\tQ.push_back(is_ll(l, m));\n\t\t\tR.push_back(is_ll(l, m));\n\t\t}\n\t}\n\tconst vector<Polygon>polys{ Q,R };\n\treturn polys;\n}\n\n\n/* ??¢??¬??????????????? */\nvoid add_point(vector<Point> &ps, const Point p) {\n\tfor (Point q : ps) if (abs(q - p) < eps) return;\n\tps.push_back(p);\n}\n\ntypedef int Weight;\nstruct Edge {\n\tint src, dst;\n\tWeight weight;\n\tEdge(int src, int dst, Weight weight) :\n\t\tsrc(src), dst(dst), weight(weight) { }\n};\n\ntypedef vector<Edge> Edges;\ntypedef vector<Edges> Graph;\n\nvoid add_edge(Graph &g, const int from, const int to, const Weight weight) {\n\tg[from].push_back(Edge{ from, to, weight });\n}\n\nGraph segment_arrangement(const vector<Line> &s, const vector<Point> &p) {\n\tint n = p.size(), m = s.size();\n\tGraph g(n);\n\tREP(i, m) {\n\t\tvector<pair<ld, int>> vec;\n\t\tREP(j, n) if (isis_sp(s[i], p[j]))\n\t\t\tvec.emplace_back(abs(s[i].a - p[j]), j);\n\t\tsort(ALL(vec));\n\t\tREP(j, vec.size() - 1) {\n\t\t\tint from = vec[j].second, to = vec[j + 1].second;\n\t\t\tadd_edge(g, from, to, static_cast<Weight>(abs(p[from] - p[to])));\n\t\t}\n\t}\n\treturn g;\n}\nGraph sennbunn_arrangement(const vector<Line>&s) {\n\tvector<Point>crss;\n\tfor (int i = 0; i < static_cast<int>(s.size()); ++i) {\n\t\tfor (int j = i + 1; j < static_cast<int>(s.size()); ++j) {\n\t\t\tif (isis_ss(s[i], s[j])) {\n\t\t\t\tcrss.push_back(is_ll(s[i], s[j]));\n\t\t\t}\n\t\t}\n\t}\n\tfor (int i = 0; i <static_cast<int>(s.size()); ++i) {\n\t\tcrss.push_back(s[i][0]);\n\t\tcrss.push_back(s[i][1]);\n\t}\n\treturn segment_arrangement(s, crss);\n}\n\n//Graph circle_arrangement(const vector<Circle> &c, const vector<Point> &p) {\n//\tint n = p.size(), m = c.size();\n//\tGraph g(n);\n//\tREP(i, m) {\n//\t\tvector<pair<ld, int>> vec;\n//\t\tREP(j, n) if (abs(abs(c[i].p - p[j]) - c[i].r) < eps)\n//\t\t\tvec.emplace_back(arg(c[i].p - p[j]), j);\n//\t\tsort(ALL(vec));\n//\t\tREP(j, vec.size() - 1) {\n//\t\t\tint from = vec[j].second, to = vec[j + 1].second;\n//\t\t\tld angle = vec[j + 1].first - vec[j].first;\n//\t\t\tadd_edge(g, from, to, static_cast<Weight>(angle * c[i].r));\n//\t\t}\n//\t\tif (vec.size() >= 2) {\n//\t\t\tint from = vec.back().second, to = vec.front().first;\n//\t\t\tld angle = vec.front().first - vec.back().first;\n//\t\t\tadd_edge(g, from, to, static_cast<Weight>(angle * c[i].r));\n//\t\t}\n//\t}\n//\treturn g;\n//}\n\n\n/* ????????°?????? */\n\n// ?????????????????¢?????¢??¬??????????????????????????????????????°???????????????\n// ?????´?????????????¨?????????§????????´????????????????¨?????????§???????????????\n// ?????° polygon ??????vector<int> ??§??¨?????????????§???¢???????????§?????????\n// vector<int> ??§??¨????????? ????§???¢???i???????????????????????????????????????p????????????????????§?????????\nvector<vector<int>> polygon;\nvector<int> seg2p[1024][1024];\n\n//Graph dual_graph(const vector<Line> &s, const vector<Point> &p) {\n//\tint N = p.size();\n//\tpolygon.clear();\n//\tREP(i, 1024) REP(j, 1024) seg2p[i][j].clear();\n//\tvector<vector<tuple<ld, int, bool>>> tup(N);\n//\tREP(i, s.size()) {\n//\t\tint a = -1, b = -1;\n//\t\tREP(j, N) if (abs(s[i].a - p[j]) < eps) a = j;\n//\t\tREP(j, N) if (abs(s[i].b - p[j]) < eps) b = j;\n//\t\tassert(a >= 0 && b >= 0);\n//\t\ttup[a].emplace_back(arg(s[i].b - s[i].a), b, false);\n//\t\ttup[b].emplace_back(arg(s[i].a - s[i].b), a, false);\n//\t}\n//\tREP(i, N) sort(ALL(tup[i]));\n//\tREP(i, N) {\n//\t\tREP(j, tup[i].size()) {\n//\t\t\tld angle; int pos = j, from = i, to; bool flag;\n//\t\t\ttie(angle, to, flag) = tup[i][j];\n//\t\t\tif (flag) continue;\n//\t\t\tvector<int> ps;\n//\t\t\twhile (!flag) {\n//\t\t\t\tps.push_back(from);\n//\t\t\t\tget<2>(tup[from][pos]) = true;\n//\t\t\t\tseg2p[from][to].push_back(polygon.size());\n//\t\t\t\tseg2p[to][from].push_back(polygon.size());\n//\t\t\t\tangle += pi + eps;\n//\t\t\t\tif (angle > pi) angle -= 2 * pi;\n//\t\t\t\tauto it = lower_bound(ALL(tup[to]), make_tuple(angle, 0, false));\n//\t\t\t\tif (it == tup[to].end()) it = tup[to].begin();\n//\t\t\t\tfrom = to; tie(angle, to, flag) = *it;\n//\t\t\t\tpos = it - tup[from].begin();\n//\t\t\t}\n//\t\t\tpolygon.push_back(ps);\n//\t\t}\n//\t}\n//\tGraph g(polygon.size());\n//\tREP(i, N) REP(j, i) {\n//\t\tif (seg2p[i][j].size() == 2) {\n//\t\t\tint from = seg2p[i][j][0], to = seg2p[i][j][1];\n//\t\t\tg[from].push_back(Edge{ from, to });\n//\t\t\tg[to].push_back(Edge{ to, from });\n//\t\t}\n//\t}\n//\treturn g;\n//}\n\nstruct flo {\n\tPoint p;\n\tld the;\n};\nbool check(const flo&f, const Point p,const ld len,const ld theta) {\n\tconst ld dis = abs(f.p - p);\n\tif (dis-eps > len) {\n\t\treturn false;\n\t}\n\telse {\n\t\tld kaku = atan2(p.imag() - f.p.imag(), p.real() - f.p.real());\n\t\tif (kaku < 0)kaku += 2*pi;\n\t\tld sa = abs(kaku - theta);\n\t\tsa = min(sa, 2 * pi - sa);\n\t\tif (sa < f.the / 2)return true;\n\t\telse return false;\n\t}\n}\nint main() {\n\twhile (1) {\n\t\tvector<Point>houses;\n\t\tint H, R; cin >> H >> R;\n\t\tif (!H)break;\n\t\tfor (int i = 0; i < H; ++i) {\n\t\t\tint x, y; cin >> x >> y;\n\t\t\thouses.emplace_back(x, y);\n\t\t}\n\t\tint U, M, S;ld du, dm, ds;  cin >> U >> M >> S >> du >> dm >> ds;\n\t\tdu *= dtop;\n\t\tdm *= dtop;\n\t\tds *= dtop;\n\t\tvector<flo>flowers;\n\t\tfor (int i = 0; i < U; ++i) {\n\t\t\tint x, y; cin >> x >> y;\n\t\t\tflowers.push_back(flo{ Point(x,y),du });\n\t\t}\n\t\tfor (int i = 0; i < M; ++i) {\n\t\t\tint x, y; cin >> x >> y;\n\t\t\tflowers.push_back(flo{ Point(x,y),dm });\n\t\t}\n\t\tfor (int i = 0; i < S; ++i) {\n\t\t\tint x, y; cin >> x >> y;\n\t\t\tflowers.push_back(flo{ Point(x,y),ds });\n\t\t}\n\t\tflo myflower{ Point(0,0),du };\n\t\tint ans = 0;\n\t\tvector<int>nums(H);\n\t\tfor (int i = 0; i < R; ++i) {\n\t\t\tld w, a; cin >> a >> w;\n\t\t\ta *= dtop;\n\t\t\tfor (int h = 0; h < H; ++h) {\n\t\t\t\tPoint p(houses[h]);\n\t\t\t\tif (check(myflower, p, w, a)) {\n\n\t\t\t\t\tbool aok = true;\n\t\t\t\t\tfor (auto f : flowers) {\n\t\t\t\t\t\tif (check(f, p, w, a)) {\n\t\t\t\t\t\t\taok = false;\n\t\t\t\t\t\t\tbreak;\n\t\t\t\t\t\t}\n\t\t\t\t\t}\n\t\t\t\t\tif (aok) {\n\t\t\t\t\t\tnums[h]++;\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t\tint amax = *max_element(nums.begin(), nums.end());\n\t\tif (amax) {\n\t\t\tvector<int>anss;\n\t\t\tfor (int i = 0; i < H; ++i) {\n\t\t\t\tif (amax == nums[i]) {\n\t\t\t\t\tanss.push_back(i+1);\n\t\t\t\t}\n\t\t\t}\n\t\t\tfor (int i = 0; i < anss.size(); ++i) {\n\t\t\t\tcout << anss[i];\n\t\t\t\tif (i != anss.size() - 1)cout << \" \";\n\t\t\t\telse cout << endl;\n\t\t\t}\n\t\t}\n\t\telse {\n\t\t\tcout << \"NA\" << endl;\n\t\t}\n\t}\n\treturn 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include <iostream>\n#include <cstdio>\n#include <iomanip>\n#include <vector>\n#include <map>\n#include <set>\n#include <queue>\n#include <bitset>\n#include <stack>\n#include <utility>\n#include <numeric>\n#include <algorithm>\n#include <functional>\n#include <cctype>\n#include <complex>\n#include <string>\n#include <sstream>\n#include <fstream>\n#include <cassert>\nusing namespace std;\n\n//common\ntypedef long long i64,ll;\n\n#define BR \"\\n\"\n#define ALL(c) (c).begin(),(c).end()\n#define REP(i,n) for(int i=0;i<(int)(n);++i)\n#define FOR(i,l,r) for(int i=(l);i<(int)(r);++i)\n#define EACH(it,o) for(auto it = (o).begin(); it != (o).end(); ++it)\n#define IN(l,v,r) ((l)<=(v) && (v)<(r))\n\n//debug\n#ifdef NDEBUG\n#define DUMP(x)\n#define DUMPLN(x)\n#define DEBUG(x)\n#define DEBUGLN(x)\n#define LINE()\n#define LINELN()\n#define CHECK(exp,act)\n#define STOP(e)\n#else\n#define DUMP(x)  cerr << #x << \" = \" << (x)\n#define DUMPLN(x)  DUMP(x) <<endl\n#define DEBUG(x) DUMP(x) << LINE() << \" \" << __FILE__\n#define DEBUGLN(x) DEBUG(x)<<endl\n#define LINE()    cerr<< \" (L\" << __LINE__ << \")\"\n#define LINELN()    LINE()<<endl\n#define CHECK(exp,act)  if(exp!=act){DUMPLN(exp);DEBUGLN(act);}\n#define STOP(e)  CHECK(e,true);if(!(e)) exit(1);\n#endif\n\ntemplate<class T> inline string toString(const vector<T>& x) {\n\tstringstream ss;\n\tREP(i,x.size()){\n\t\tif(i!=0)ss<<\" \";\n\t\tss<< x[i];\n\t}\n\treturn ss.str();\n}\n\ntemplate<class T> inline string toString(const vector<vector<T> >& map) {\n\tstringstream ss;\n\tREP(i,map.size()){\n\t\tif(i!=0)ss<<BR;\n\t\tss<< toString(map[i]);\n\t}\n\treturn ss.str();\n}\ntemplate<class K,class V>  string toString(map<K,V>& x) {\n\tstring res;stringstream ss;\n\tfor(auto& p:x)ss<< p.first<<\":\" << p.second<<\" \";\n\treturn ss.str();\n}\n\nstring BITtoString(int bit){\n    stringstream ss;\n    while(bit!=0){ss<<(bit%2);bit/=2;}\n    string res=ss.str();reverse(ALL(res));\n    return res;\n}\n\ntemplate<typename T,typename V> inline T pmod(T v,V MOD){\n\treturn (v%MOD+MOD)%MOD;\n}\ndouble pfmod(double v,double MOD){\n\treturn fmod(fmod(v,MOD)+MOD,MOD);\n}\n\nclass Comp{\npublic:\n\tbool operator () (const pair<int,int>& l,const pair<int,int>& r){\n\t\tif(l.first!=r.first)return l.first>r.first;\n\t\treturn l.second<r.second;\n\t}\n};\n\nnamespace Ps{\n\tconst double EPS = 1e-8;\n\tconst double INF = 1e12;\n\n\ttypedef complex<double> P;\n\t#define X(a) (real(a))\n\t#define Y(a) (imag(a))\n\t\n\t// a×b\n\tdouble cross(const P& a,const P& b){\n\t\treturn imag(conj(a)*b);\n\t}\n\t// a・b\n\tdouble dot(const P&a,const P& b) {\n\t\treturn real(conj(a)*b);\n\t}\n\n\t int ccw(const P& a,P b,P c){\n\t\tb -= a; c -= a;\n\t\t  if (cross(b,c) > 0)   return +1;       // counter clockwise\n\t\t  if (cross(b,c) < 0)   return -1;       // clockwise\n\t\t  if (dot(b,c) < 0)     return +2;       // c--a--b on line\n\t\t  if (norm(b) < norm(c)) return -2;       // a--b--c on line\n\t\t  return 0;\n\t  }\n}\nusing namespace Ps;\n\nclass Main{\npublic:\n\t\n\tbool canReach(int x,int y,int w,int a,int d){\n\t\tif((ll)x*x+(ll)y*y<=(ll)a*a)\n\t\tif(pfmod(fabs(w*M_PI/180-atan2(y,x)),2*M_PI)<=d*M_PI/180/2)return true;\n\t\treturn false;\n\t}\n\n\tvoid run(){\n\n\t\twhile(true){\n\t\t\tint H,R;scanf(\"%d%d\",&H,&R);if(H==0)break;\n\n\t\t\tvector<int> xs(H),ys(H);\n\t\t\tREP(h,H)scanf(\"%d%d\",&xs[h],&ys[h]);\n\t\t\tint U,M,S,du,dm,ds;scanf(\"%d%d%d%d%d%d\",&U,&M,&S,&du,&dm,&ds);\n\n\t\t\tvector<int> uxs(U),uys(U);vector<int> mxs(M),mys(M);vector<int> sxs(S),sys(S);\n\t\t\tREP(i,U)scanf(\"%d%d\",&uxs[i],&uys[i]);\n\t\t\tREP(i,M)scanf(\"%d%d\",&mxs[i],&mys[i]);\n\t\t\tREP(i,S)scanf(\"%d%d\",&sxs[i],&sys[i]);\n\t\t\t\n\t\t\tvector<int> ws(R),as(R);\n\t\t\tREP(i,R)scanf(\"%d%d\",&ws[i],&as[i]);\n\n\n\t\t\tvector<pair<int,int>> res;\n\t\t\tREP(h,H){\n\t\t\t\tint x=xs[h],y=ys[h];\n\n\t\t\t\tint okc=0;\n\t\t\t\tREP(r,R){\n\t\t\t\t\tint w=ws[r],a=as[r];\n\t\t\t\t\tbool ok=false;\n\t\t\t\t\tif(canReach(x,y,w,a,du))ok=true;\n\t\t\t\t\tREP(i,U)if(canReach(x-uxs[i],y-uys[i],w,a,du))ok=false;\n\t\t\t\t\tREP(i,M)if(canReach(x-mxs[i],y-mys[i],w,a,dm))ok=false;\n\t\t\t\t\tREP(i,S)if(canReach(x-sxs[i],y-sys[i],w,a,ds))ok=false;\n\t\t\t\t\tif(ok)okc++;\n\t\t\t\t}\n\t\t\t\tres.push_back(make_pair(okc,h+1));\n\t\t\t}\n\t\t\tsort(ALL(res),Comp());\n\n\t\t\tint Mh=res[0].first;\n\t\t\t\n\t\t\tif(Mh==0){\n\t\t\t\tcout<<\"NA\"<<endl;continue;\n\t\t\t}\n\n\t\t\tfor(int i=0;i<H && Mh==res[i].first;i++){\n\t\t\t\tif(i!=0)cout <<\" \";\n\t\t\t\tcout << res[i].second; \n\t\t\t}\n\t\t\tcout <<endl;\n\t\t}\n\t}\n};\n\n int main(){\n\t//ios::sync_with_stdio(false);\n \tMain().run();\n \treturn 0;\n }"
  },
  {
    "language": "C++",
    "code": "#include <algorithm>\n#include <bitset>\n#include <cassert>\n#include <cctype>\n#include <climits>\n#include <cmath>\n#include <complex>\n#include <cstdio>\n#include <cstdlib>\n#include <cstring>\n#include <ctime>\n#include <deque>\n#include <fstream>\n#include <iomanip>\n#include <iostream>\n#include <map>\n#include <numeric>\n#include <queue>\n#include <set>\n#include <sstream>\n#include <stack>\n#include <string>\n#include <valarray>\n#include <vector>\n\n#define EPS 1e-9\n#define INF 1070000000LL\n#define MOD 1000000007LL\n#define fir first\n#define foreach(it,X) for(__typeof((X).begin()) it=(X).begin();it!=(X).end();it++)\n#define ite iterator\n#define mp make_pair\n#define rep(i,n) rep2(i,0,n)\n#define rep2(i,m,n) for(int i=m;i<(n);i++)\n#define pb push_back\n#define sec second\n#define sz(x) ((int)x.size())\n\nusing namespace std;\n\nstruct timer{\n\ttime_t start;\n\ttimer(){start=clock();}\n\t~timer(){cerr<<1.*(clock()-start)/CLOCKS_PER_SEC<<\" secs\"<<endl;}\n};\n\ntypedef istringstream iss;\ntypedef long long ll;\ntypedef pair<int,int> pi;\ntypedef stringstream sst;\ntypedef vector<int> vi;\n\n#define PI 3.14159265358979323846\n\ntypedef complex<double> P;\n\nint H,R,U,M,S,T;\nP h[111];\ndouble du,dm,ds;\nP t[33];\ndouble d[33];\ndouble w[111],a[111];\nint day[111];\n\nbool reach(P house,P tree,double D,double dir,double dist){\n\tif(abs(house-tree) > dist)return false;\n\tdouble ang = arg(house-tree);\n\tif(ang<0)ang+=2*PI;\n\tdouble dif = abs(ang-dir);\n\tdif = min(dif, 2*PI - dif);\n\tif(dif > D/2)return false;\n\treturn true;\n}\n\nint main(){\n\tcin.tie(0);\n\tios_base::sync_with_stdio(0);\n\t\n\twhile(cin>>H>>R && H){\n\t\tfill(day,day+H,0);\n\t\trep(i,H)cin>>h[i].real()>>h[i].imag();\n\t\t\n\t\tcin>>U>>M>>S>>du>>dm>>ds;\n\t\tT=U+M+S;\n\t\trep(i,T){\n\t\t\tcin>>t[i].real()>>t[i].imag();\n\t\t\tif(i<U) d[i]=du;\n\t\t\telse if(i<U+M) d[i]=dm;\n\t\t\telse d[i]=ds;\n\t\t\td[i]*=PI/180;\n\t\t}\n\t\tt[T].real()=t[T].imag()=0;\n\t\td[T]=du*PI/180;\n\t\t\n\t\trep(i,R){\n\t\t\tcin>>w[i]>>a[i];\n\t\t\tw[i]*=PI/180;\n\t\t}\n\t\t\n\t\trep(i,H){\n\t\t\trep(j,R){\n\t\t\t\tif(!reach(h[i],t[T],d[T],w[j],a[j]))continue;\n\t\t\t\tint ok=1;\n\t\t\t\trep(k,T){\n\t\t\t\t\tif(reach(h[i],t[k],d[k],w[j],a[j])){\n\t\t\t\t\t\tok=0;break;\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t\tday[i]+=ok;\n\t\t\t}\n\t\t}\n\t\t\n\t\tint max=*max_element(day,day+H);\n\t\tif(max==0)cout<<\"NA\"<<endl;\n\t\telse{\n\t\t\tvi ans;\n\t\t\trep(i,H)if(day[i]==max)ans.pb(i+1);\n\t\t\trep(i,sz(ans))cout<<ans[i]<<(i==sz(ans)-1?\"\\n\":\" \");\n\t\t}\n\t}\n}"
  },
  {
    "language": "C++",
    "code": "#include <cstdio>\n#include <cstdlib>\n#include <cmath>\n#include <cstring>\n\n#include <iostream>\n#include <string>\n#include <algorithm>\n#include <vector>\n#include <queue>\n#include <stack>\n#include <map>\n#include <set>\n\n#include <functional>\n#include <cassert>\n\ntypedef long long ll;\nusing namespace std;\n\n#define debug(x) cerr << #x << \" = \" << x << endl;\n\n\n#define mod 1000000007 //1e9+7(prime number)\n#define INF 1000000000 //1e9\n#define LLINF 2000000000000000000LL //2e18\n#define SIZE 10000\n\n#define eps 1e-8\n\nbool is_ok(int hx,int hy, int tx, int ty, int td,int a,int w){\n\n  int dx = hx - tx;\n  int dy = hy - ty;\n\n  if(a*a < dx*dx + dy*dy) return false;\n\n  double rad = atan((double)dy/dx);\n\n  if(rad < 0){\n    rad += M_PI;\n  }\n  \n  if(dy < 0){\n    rad += M_PI;\n  }\n\n  rad = rad/M_PI * 180;\n  \n  rad += 180 - w;\n  w = 180;\n\n  if(rad >= 360) rad -= 360;\n    \n  return w - td/2 - eps < rad && rad < w + td/2 + eps;\n}\n\nbool calc(){\n  int h,r,t;\n  int hx[SIZE],hy[SIZE];\n  int u,m,s,du,dm,ds;\n  int tx[SIZE],ty[SIZE],td[SIZE];\n  int w[SIZE],a[SIZE];\n  \n  scanf(\"%d%d\",&h,&r);\n\n  if(h==0) return false;\n\n  for(int i=0;i<h;i++){\n    scanf(\"%d%d\",hx+i,hy+i);\n  }\n\n  scanf(\"%d%d%d%d%d%d\",&u,&m,&s,&du,&dm,&ds);\n\n  t = u+m+s;\n  \n  for(int i=0;i<u;i++){\n    scanf(\"%d%d\",tx+i,ty+i);\n    td[i] = du;\n  }\n\n  for(int i=u;i<u+m;i++){\n    scanf(\"%d%d\",tx+i,ty+i);\n    td[i] = dm;\n  }\n\n  for(int i=u+m;i<u+s+m;i++){\n    scanf(\"%d%d\",tx+i,ty+i);\n    td[i] = ds;\n  }\n\n  for(int i=0;i<r;i++){\n    scanf(\"%d%d\",w+i,a+i);\n  }\n\n  int max_d = 0;\n  int ans[SIZE] = {};\n\n  for(int i=0;i<h;i++){\n\n    for(int j=0;j<r;j++){\n      bool flag = true;\n\n      for(int k=0;k<t;k++){\n        if(is_ok(hx[i],hy[i],tx[k],ty[k],td[k],a[j],w[j])) flag = false;\n      }\n\n      if(flag && is_ok(hx[i],hy[i],0,0,du,a[j],w[j])) ans[i]++;\n    }\n  }\n  \n  for(int i=0;i<h;i++)\n    max_d = max(max_d,ans[i]);\n\n  if(max_d > 0){\n  \n    bool flag1 = false;\n    \n    for(int i=0;i<h;i++){\n      if(max_d == ans[i]){\n        if(flag1) printf(\" \");\n        flag1 = true;\n        printf(\"%d\",i+1);\n      }\n    }\n    \n    printf(\"\\n\");\n  }else{\n    puts(\"NA\");\n  }\n  \n  return true;\n}\n  \n\nint main(){\n\n  while(calc());\n  \n  return 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include<iostream>\n#include<complex>\n#include<vector>\n#include<algorithm>\n#include<cmath>\n#include<cstring>\n\n#define pb push_back\n#define sz size()\n#define rep(i,a) for(int i=0;i<(int)(a);i++)\n\nusing namespace std;\ntypedef long double D;\ntypedef complex<D> P;\nconst D EPS = 1e-4;\nconst D PI = acos(-1);\n\ninline D dot(P x,P y){return real(conj(x)*y);}\ninline D cross(P x,P y){return imag(conj(x)*y);}\nP rotate(P v,double s){\n  return P(real(v)*cos(s) - imag(v)*sin(s), real(v)*sin(s) + imag(v)*cos(s) );\n}\ninline D arg(P a,P b,P c){\n  D res = acos(dot(b-a,c-a)/(abs(b-a)*abs(c-a))); \n  return (cross(b-a,c-a)<0.0)?2*PI-res:res;\n}\n\nint h,r,n[3];\nD d[3],tmp1,tmp2,seta;\nP hp[110],up[3][110];\nD w[110],a[110];\n\nint main(){\n  while(cin >> h >> r,h){\n    rep(i,h){\n      cin >> tmp1 >> tmp2;\n      hp[i] = P(tmp1,tmp2);\n    }\n\n    rep(i,3)cin >> n[i]; rep(i,3)cin >> d[i], d[i] *= PI/180/2;\n\n    rep(i,3)rep(j,n[i]){\n      cin >> tmp1 >> tmp2;\n      up[i][j] = P(tmp1,tmp2);\n    }\n\n    rep(i,r)cin >> w[i] >> a[i], w[i] *= PI/180;\n\n    int num[110];\n    memset(num,0,sizeof(num));\n\n    rep(x,r)rep(id,h){\n      if( !(abs(hp[id]) < a[x] + EPS) )continue;\n      seta = arg(P(0,0),P(100,0),hp[id]);\n      if( !(w[x]-d[0] < seta+EPS && seta < w[x]+d[0]+EPS)\n\t  && !(w[x]-d[0]+2*PI < seta+EPS && seta < w[x]+d[0]+2*PI+EPS) )continue;\n\n      bool in = 0;\n      rep(i,3){\n\trep(j,n[i]){\n\t  if(abs(hp[id]-up[i][j]) < a[x] +EPS){\n\t    P tmp = P(up[i][j].real() + 100.0, up[i][j].imag());\n\t    seta = arg(up[i][j],tmp,hp[id]);\n\t    if( (w[x]-d[i] < seta+EPS && seta < w[x]+d[i]+EPS) ||\n\t\t(w[x]-d[i]+2*PI < seta+EPS && seta < w[x]+d[i]+2*PI+EPS) ){\n\t      in = 1; break;\n\t    }\n\t    /*\n\t    seta -= 2*PI;\n\t    else if(w[x]-d[i] < seta+EPS && seta < w[x]+d[i]+EPS){\n\t      in = 1; break;\n\t    }\n\t    */\n\t  }\n\t}\n\tif(in)break;\n      }\n      if(!in)num[id]++;\n    }\n\n    int maxv = *max_element(num,num+h);\n    if(maxv==0)cout << \"NA\\n\";\n    else{\n      vector<int> ans;\n      rep(i,h){\n\tif(num[i] == maxv)ans.pb(i+1);\n      }\n      rep(i,ans.sz)cout << ans[i] << (i+1==ans.size()?\"\\n\":\" \");\n    }\n  }\n}"
  },
  {
    "language": "C++",
    "code": "#include <stdio.h>\n#include <string.h>\n#include <math.h>\n#define PI 3.1415926535897932384626433832795028841971693993751058209749445923078164\n\nstruct point{\n\tint x,y;\n};\n\nstruct wind{\n\tint w,a;\n};\n\ndouble getlen(int x1,int y1,int x2,int y2){\n\treturn sqrt(pow((x1-x2)*1.0,2)+pow((y1-y2)*1.0,2));\n}\n\nint check(int N,point *tree,point house,wind wind,int dtree){\n\tint i;\n\tdouble rad,dig,up,down;\n\n\tfor(i = 0;i < N;i++){\n\t\tif(wind.a*1.0 < getlen(house.x,house.y,tree[i].x,tree[i].y)){\n\t\t\treturn 1;\n\t\t}\n\t\trad = atan2((house.y-tree[i].y)*1.0,(house.x-tree[i].x)*1.0);\n\t\tdig = fmod((rad * 180.0 / PI)+360.0,360.0);\n\t\tup = wind.w*1.0+dtree/2.0;\n\t\tdown = wind.w*1.0-dtree/2.0;\n\t\tif(up >= 360.0){\n\t\t\tif((0.0 <= dig && dig <= up-360.0) || (down <= dig && dig < 360.0)){\n\t\t\t\treturn 0;\n\t\t\t}\n\t\t}else if(down < 0.0){\n\t\t\tif((0.0 <= dig && dig <= up) || (down <= dig+360.0 && dig < 360.0)){\n\t\t\t\treturn 0;\n\t\t\t}\n\t\t}else{\n\t\t\tif(down <= dig && dig <= up){\n\t\t\t\treturn 0;\n\t\t\t}\n\t\t}\n    }\n\n\treturn 1;\n}\n\nint check2(point house,wind wind,int dtree){\n\tdouble rad,dig,up,down;\n\n\tif(wind.a*1.0 < getlen(house.x,house.y,0,0)){\n\t\treturn 0;\n\t}\n\n\trad = atan2(house.y*1.0,house.x*1.0);\n\tdig = fmod((rad * 180.0 / PI)+360.0,360.0);\n\tup = wind.w*1.0+dtree/2.0;\n\tdown = wind.w*1.0-dtree/2.0;\n\tif(up >= 360.0){\n\t\tif(!((0.0 <= dig && dig <= up-360.0) || (down <= dig && dig < 360.0))){\n\t\t\treturn 0;\n\t\t}\n\t}else if(down < 0.0){\n\t\tif(!((0.0 <= dig && dig <= up) || (down <= dig+360.0 && dig < 360.0))){\n\t\t\treturn 0;\n\t\t}\n\t}else{\n\t\tif(!(down <= dig && dig <= up)){\n\t\t\treturn 0;\n\t\t}\n\t}\n\treturn 1;\n}\n\nvoid max(int H,int *ok){\n\tint i,p,dmax;\n\tint tmp[100];\n\n\tp = 0;\n\tdmax = 0;\n\n\tfor(i = 0;i < H;i++){\n\t\tif(dmax < ok[i]){\n\t\t\tdmax = ok[i];\n\t\t\ttmp[0] = i+1;\n\t\t\tp = 1;\n\t\t}else if(dmax != 0 && dmax == ok[i]){\n\t\t\ttmp[p++] = i+1;\n\t\t}\n\t}\n\n\tif(dmax == 0){\n\t\tprintf(\"NA\\n\");\n\t}else{\n\t\tfor(i = 0;i < p;i++){\n\t\t\tprintf(\"%d%c\",tmp[i],(i == p-1) ? '\\n' : ' ');\n\t\t}\n\t}\n}\n\nint main(){\n\tint i,j,H,R,U,M,S,du,dm,ds;\n\tint ok[100];\n\tpoint h[100],u[10],m[10],s[10];\n\twind wind[100];\n\n\twhile(1){\n\t\tmemset(ok,0,sizeof(ok));\n\t\tscanf(\"%d %d\",&H,&R);\n\t\tif(H == 0 && R == 0){\n\t\t\tbreak;\n\t\t}\n\t\tfor(i = 0;i < H;i++){\n\t\t\tscanf(\"%d %d\",&h[i].x,&h[i].y);\n\t\t}\n\t\tscanf(\"%d %d %d %d %d %d\",&U,&M,&S,&du,&dm,&ds);\n\t\tfor(i = 0;i < U;i++){\n\t\t\tscanf(\"%d %d\",&u[i].x,&u[i].y);\n\t\t}\n\t\tfor(i = 0;i < M;i++){\n\t\t\tscanf(\"%d %d\",&m[i].x,&m[i].y);\n\t\t}\n\t\tfor(i = 0;i < S;i++){\n\t\t\tscanf(\"%d %d\",&s[i].x,&s[i].y);\n\t\t}\n\t\tfor(i = 0;i < R;i++){\n\t\t\tscanf(\"%d %d\",&wind[i].w,&wind[i].a);\n\t\t}\n\t\n\t\tfor(i = 0;i < R;i++){\n\t\t\tfor(j = 0;j < H;j++){\n\t\t\t\tif(!check2(h[j],wind[i],du)){\n\t\t\t\t\tcontinue;\n\t\t\t\t}\n\t\t\t\tif(!check(U,u,h[j],wind[i],du)){\n\t\t\t\t\tcontinue;\n\t\t\t\t}\n\t\t\t\tif(!check(M,m,h[j],wind[i],dm)){\n\t\t\t\t\tcontinue;\n\t\t\t\t}\n\t\t\t\tif(!check(S,s,h[j],wind[i],ds)){\n\t\t\t\t\tcontinue;\n\t\t\t\t}\n\t\t\t\tok[j]++;\n\t\t\t}\n\t\t}\n\t\n\t\tmax(H,ok);\n\t}\n\n\treturn 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include<bits/stdc++.h>\nusing namespace std;\n\ntypedef pair<int,int>pint;\ntypedef vector<int>vint;\n#define pb push_back\n#define mp make_pair\n#define rep(i,n) for(int i=0;i<(n);i++)\ntemplate<class T,class U>void chmin(T &t,U f){if(t>f)t=f;}\ntemplate<class T,class U>void chmax(T &t,U f){if(t<f)t=f;}\n\ntypedef complex<double>P;\n\nconst double EPS=1e-6;\nconst double PI=acos(-1);\n\nconst int COUNTER_CLOCKWISE=1;\nconst int CLOCKWISE=-1;\nconst int ONLINE_BACK=2;\nconst int ONLINE_FRONT=-2;\nconst int ON_SEGMENT=0;\n\ninline double dot(const P &a, const P &b){return (conj(a) * b).real();}\ninline double cross(const P &a, const P &b){return (conj(a) * b).imag();}\n\ndouble toRad(double a){return a/180.0*PI;}\ndouble toDeg(double a){return a*180.0/PI;}\nP rotate(P p,double d){\n    return P(p.real()*cos(d)-p.imag()*sin(d),p.real()*sin(d)+p.imag()*cos(d));\n}\n\nP getP(){\n    double x,y;\n    scanf(\"%lf%lf\",&x,&y);\n    return P(x,y);\n}\n\nint ccw(P p0,P p1,P p2){\n    P a=p1-p0;\n    P b=p2-p0;\n    if(cross(a,b)>EPS)return COUNTER_CLOCKWISE;\n    if(cross(a,b)<-EPS)return CLOCKWISE;\n    if(dot(a,b)<-EPS)return ONLINE_BACK;\n    if(norm(a)<norm(b))return ONLINE_FRONT;\n    return ON_SEGMENT;\n}\n\nbool ok(P from,P to,double w,double a,double d){\n    if(abs(to-from)>a)return false;\n\n    w=toRad(w);\n    d=toRad(d);\n\n    P p0=from+P(cos(w),sin(w))*a;\n    P p1=rotate(p0,-d/2);\n    P p2=rotate(p0,d/2);\n\n    return (cross(p1-from,to-from)>EPS)&&(cross(p2-from,to-from)<EPS);\n}\n\nint H,R;\nvector<P>h;\n\nint U,M,S;\ndouble du,dm,ds;\nvector<P>u,m,s;\nvoid solve(){\n    h.resize(H);\n    rep(i,H)h[i]=getP();\n\n    scanf(\"%d%d%d\",&U,&M,&S);\n    scanf(\"%lf%lf%lf\",&du,&dm,&ds);\n\n    u.resize(U);\n    m.resize(M);\n    s.resize(S);\n    rep(i,U)u[i]=getP();\n    rep(i,M)m[i]=getP();\n    rep(i,S)s[i]=getP();\n\n    int cnt[100]={0};\n\n    while(R--){\n        double w,a;\n        scanf(\"%lf%lf\",&w,&a);\n        rep(i,H){\n            bool f=false;\n            if(ok(P(0,0),h[i],w,a,du))f=true;\n            rep(j,U)if(ok(u[j],h[i],w,a,du))f=false;\n            rep(j,M)if(ok(m[j],h[i],w,a,dm))f=false;\n            rep(j,S)if(ok(s[j],h[i],w,a,ds))f=false;\n            if(f)cnt[i]++;\n        }\n    }\n\n    int ma=*max_element(cnt,cnt+H);\n    if(ma==0){\n        puts(\"NA\");\n        return;\n    }\n\n    bool f=false;\n    rep(i,H){\n        if(cnt[i]!=ma)continue;\n        if(f)printf(\" \");\n        else f=true;\n        printf(\"%d\",i+1);\n    }\n    puts(\"\");\n}\n\nint main(){\n    while(scanf(\"%d%d\",&H,&R),H||R)solve();\n    return 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\nusing namespace std;\n\n// *geometry library\n\ntypedef double Real;\nconstexpr Real EPS = 1e-10;\nconst Real PI = acos((Real)-1);\ninline int sign(Real d) { return d > EPS ? 1 : d < -EPS ? -1 : 0; }\n\nstruct Point {\n\tReal x, y;\n\tconstexpr explicit Point(Real x_ = 0, Real y_ = 0):x(x_), y(y_) {}\n\tPoint operator+(const Point &p) const { return Point(x + p.x, y + p.y); }\n\tPoint operator-(const Point &p) const { return Point(x - p.x, y - p.y); }\n\tPoint operator*(const Point &p) const { return Point(x * p.x - y * p.y, x * p.y + y * p.x); }\n\tPoint operator*(Real s) const { return Point(x * s, y * s); }\n\tPoint operator/(Real s) const { return Point(x / s, y / s); }\n\tbool operator<(const Point &p) const { return sign(x - p.x) == -1 || (sign(x - p.x) == 0 && sign(y - p.y) == -1); }\n\tbool operator==(const Point &p) const { return sign(x - p.x) == 0 && sign(y - p.y) == 0; }\n};\n\ninline istream &operator>>(istream &is, Point &p) {\n\treturn is >> p.x >> p.y;\n}\n\ninline ostream &operator<<(ostream &os, const Point &p) {\n\treturn os << '(' << p.x << \", \" << p.y << ')';\n}\n\ninline Point rotate(const Point &p, Real theta) {\n\tconst Real s = sin(theta), c = cos(theta);\n\treturn Point(c * p.x - s * p.y, s * p.x + c * p.y);\n}\n\ninline Real norm(const Point &p) {\n\treturn p.x * p.x + p.y * p.y;\n}\n\ninline Real cross(const Point &a, const Point &b) {\n\treturn a.x * b.y - a.y * b.x;\n}\n\n// ??????????§??????¨??????????????????a, b, c???????????????\n// c??????a??????b??????????¨?????????§???????§????????????¨?????????????????¨?????????????????????\n// + : ?????¨\n// 0 : ?????? or A = B\n// - : ?????¨\ninline int judge(const Point &a, const Point &b, const Point &c) {\n\treturn sign(cross(a, c)) - sign(cross(b, c)) - sign(cross(a, b));\n}\n\n// *solve\n\ninline bool check(const Point &house, const Point &flower, Real d, Real w, Real a) {\n\tconst auto vec = house - flower;\n\tif(sign(norm(vec) - a * a) == 1) return false;\n\treturn judge(rotate(Point(1, 0), w - d * 0.5), rotate(Point(1, 0), w + d * 0.5), vec) >= 0;\n}\n\nint main() {\n\tcin.tie(nullptr);\n\tios::sync_with_stdio(false);\n\tcout.setf(ios::fixed);\n\tcout.precision(10);\n\n\tconstexpr Point mine(0, 0);\n\tfor(int h, r; cin >> h >> r && h;) {\n\t\tvector<Point> houses(h);\n\t\tfor(auto &p : houses) cin >> p;\n\n\t\tint u, m, s;\n\t\tReal du, dm, ds;\n\t\tcin >> u >> m >> s >> du >> dm >> ds;\n\t\tdu = du / 180 * PI;\n\t\tdm = dm / 180 * PI;\n\t\tds = ds / 180 * PI;\n\n\t\tvector<Point> ume(u), matsu(m), sakura(s);\n\t\tfor(auto &p : ume) cin >> p;\n\t\tfor(auto &p : matsu) cin >> p;\n\t\tfor(auto &p : sakura) cin >> p;\n\n\t\tvector<int> cnt(h, 0);\n\t\tfor(int _ = 0; _ < r; ++_) {\n\t\t\tReal w, a;\n\t\t\tcin >> w >> a;\n\t\t\tw = w / 180 * PI;\n\t\t\tfor(int i = 0; i < h; ++i) {\n\t\t\t\tconst auto &p = houses[i];\n\t\t\t\tbool ok = check(p, mine, du, w, a);\n\t\t\t\tfor(const auto &e : ume) if(ok) ok = !check(p, e, du, w, a);\n\t\t\t\tfor(const auto &e : matsu) if(ok) ok = !check(p, e, dm, w, a);\n\t\t\t\tfor(const auto &e : sakura) if(ok) ok = !check(p, e, ds, w, a);\n\t\t\t\tif(ok) ++cnt[i];\n\t\t\t}\n\t\t}\n\n\t\tconst int mx = *max_element(begin(cnt), end(cnt));\n\t\tif(mx == 0) {\n\t\t\tcout << \"NA\\n\";\n\t\t\tcontinue;\n\t\t}\n\n\t\tbool first = true;\n\t\tfor(int i = 0; i < h; ++i) {\n\t\t\tif(cnt[i] == mx) {\n\t\t\t\tif(first) {\n\t\t\t\t\tfirst = !first;\n\t\t\t\t}\n\t\t\t\telse {\n\t\t\t\t\tcout << ' ';\n\t\t\t\t}\n\t\t\t\tcout << i + 1;\n\t\t\t}\n\t\t}\n\t\tcout << '\\n';\n\t}\n\n\treturn EXIT_SUCCESS;\n}"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\nusing namespace std;\n//define\n#define int long long\n#define UNIQUE(v) v.erase(unique(all(v)), v.end());\n#define ZIP(v) sort(all(v)),UNIQUE(v)\n#define ADD(a, b) a = (a + b) % mod\n#define SUB(a, b) a = (a+mod-b)%mod\n#define MUL(a, b) a = (a * b) % mod\n#define repi(i,m,n) for(int i = m;i < n;i++)\n#define drep(i,n,m) for(int i = n;i >= m;i--)\n#define rep(i,n) repi(i,0,n)\n#define rrep(i,n) repi(i,1,n+1)\n#define chmin(x,y) x = min(x,y)\n#define chmax(x,y) x = max(x,y)\n#define all(v) v.begin(),v.end()\n#define rall(v) v.rbegin(), v.rend()\n#define dmp(x,y) make_pair(x,y)\n#define pb(x) push_back(x)\n#define pf(x) push_front(x)\n#define fi first\n#define se second\n// 許容する誤差ε\n#define EPS (1e-10)\n// 2つのスカラーが等しいかどうか\n#define EQ(a,b) (abs((a)-(b)) < EPS)\n// 2つのベクトルが等しいかどうか\n#define EQV(a,b) ( EQ((a).real(), (b).real()) && EQ((a).imag(), (b).imag()) )\n//template\ntemplate <typename T, typename U>\nostream &operator<<(ostream &os, const pair<T, U> &p){\n  os << \"(\" << p.first << \",\" << p.second << \")\";return os;\n}\ntemplate <typename T>\nostream &operator<<(ostream &os, const vector<T> &v){\n  for (auto it = v.begin();it != v.end();++it){\n    if(it != v.begin())os << \" \";os << *it;\n      }return os;\n}\ntemplate <typename T, typename U>\nostream &operator<<(ostream &os, const map<T, U> &mp){\n  for(auto x: mp)os << \"(\" << x.first << \",\" << x.second << \")\" << endl;\n  return os;\n}\ntemplate<typename T, int SIZE>\nint array_length(const T (&)[SIZE]){return SIZE;}\ntemplate<typename T, int N>\nvoid PRINTF(const T (&a)[N], int s = N, int t = -1, bool f = true){\n\tif(t == -1){rep(i,s){if(i)cout << \" \";cout << a[i];}}\n\telse repi(i,s,t){if(i!=s)cout << \" \";cout << a[i];}\n\tif(f)cout << \"\\n\";\n}\ntemplate<typename T, int N1, int N2>\nvoid PRINTF(const T (&a)[N1][N2], int h = N1, int w = N2){\n\trep(i,h){rep(j,w){cout << a[i][j] << \" \\n\"[j==w-1];}}\n}\n//typedef\ntypedef complex<double> Point;\ntypedef pair<int,int> P;\ntypedef pair<int, P> PP;\ntypedef pair<P, int> Pi;\ntypedef vector<int> vi;\ntypedef deque<int> dq;\nconst int inf = 1e9+7;\nconst int INF = 1e18+7;\n\n\ndouble cross(Point a, Point b) {\n  return (a.real() * b.imag() - a.imag() * b.real());\n}\ndouble to_rad(double deg){return (deg/180*M_PI);}\ndouble to_deg(double rad){return (rad/M_PI*180);}\n\nP a[100];\nbool Hit(P h, P b, int R, int r, int d){\n  Point H(h.fi, h.se);\n  Point B(b.fi, b.se);\n  if(abs(H-B)-d > -EPS)return false;\n  Point l1(cos(to_rad(R+r/2.0)), sin(to_rad(R+r/2.0)));\n  Point l2(cos(to_rad(R-r/2.0)), sin(to_rad(R-r/2.0)));\n  if(cross(H-B, l1) > -EPS and cross(l2, H-B) > -EPS)return true;\n  // if(h == P(5, 2) and b == P(2, -2)){\n  //   cout << \"+ \" << R << \" \" << r << \" \" << cos(R+r/2.0) << \" \" << l2 << endl;\n  //   cout << arg(l1)/M_PI*180 << endl;\n  // }\n  return false;\n}\n\nsigned main(){\n  while(1){\n    int N, M;\n    scanf(\"%lld%lld\", &N, &M);\n    if(N == 0 and M == 0)break;\n    rep(i,N){\n      int x, y;\n      scanf(\"%lld%lld\", &x, &y);\n      a[i] = P(x, y);\n    }\n    P b[3][10], R[100];\n    int U[3], r[3];\n    rep(i,3)scanf(\"%lld\", &U[i]);\n    rep(i,3)scanf(\"%lld\", &r[i]);\n    rep(i,3){\n      rep(j,U[i]){\n        int x, y;\n        scanf(\"%lld%lld\", &x, &y);\n        b[i][j] = P(x, y);\n      }\n    }\n    rep(i,M){\n      int x, y;\n      scanf(\"%lld%lld\", &x, &y);\n      R[i] = P(x, y);\n    }\n    \n    vector<int> vec;\n    int mx = 0;\n    rep(i,N){\n      int cnt = 0;\n      rep(day,M){\n        bool hit = false;\n        rep(j,3)rep(k,U[j]){\n          chmax(hit, Hit(a[i], b[j][k], R[day].fi, r[j], R[day].se));\n        }\n        if(!hit and Hit(a[i], P(0, 0), R[day].fi, r[0], R[day].se))cnt++;\n      }\n      chmax(mx, cnt);\n      vec.pb(cnt);\n    }\n    // printf(\"*%lld* \", mx);\n    if(mx == 0){printf(\"NA\\n\");continue;}\n    bool f = false;\n    rep(i,N){\n      if(vec[i] != mx)continue;\n      if(f)printf(\" \");\n      printf(\"%lld\", i+1);\n      f = true;\n    }\n    printf(\"\\n\");\n  }\n\treturn 0;\n}\n\n\n\n\n\n\n\n\n\n"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\n\nusing namespace std;\n\nstruct point {\n    int x, y;\n    int d;\n};\n\nbool check_dst(point home, point ums, int a) {\n\n    double x = home.x - ums.x;\n    double y = home.y - ums.y;\n\n    return x * x + y * y <= a * a;\n\n}\n\nbool check_deg(point home, point ums, int w) {\n\n    double x = home.x - ums.x;\n    double y = home.y - ums.y;\n    double home_deg;\n    double start_deg = w - ums.d / 2.0;\n    double end_deg = w + ums.d / 2.0;\n\n    home_deg = atan2(y, x) * 180 / M_PI;\n\n    if(home_deg < 0) {\n        home_deg += 360;\n    }\n\n    if(0 <= start_deg && end_deg <= 360) {\n        return start_deg <= home_deg && home_deg <= end_deg;\n    } else if(start_deg < 0) {\n        start_deg += 360;\n        return start_deg <= home_deg || home_deg <= end_deg;\n    } else { // end_deg > 360\n        end_deg -= 360;\n        return start_deg <= home_deg || home_deg <= end_deg;\n    }\n\n}\n\nint main() {\n\n    int h, r;\n\n    while(cin >> h >> r, h || r) {\n\n        int u, m, s, du, dm, ds;\n        vector<point> homes, ums;\n\n        for(int i = 0; i < h; ++i) {\n            int x, y;\n            cin >> x >> y;\n            homes.push_back((point){ x, y, 0 });\n        }\n\n        cin >> u >> m >> s;\n        cin >> du >> dm >> ds;\n\n        for(int i = 0; i < u + m + s; ++i) {\n            int x, y;\n            cin >> x >> y;\n            if(i < u) {\n                ums.push_back((point){ x, y, du });\n            } else if(u <= i && i < u + m) {\n                ums.push_back((point){ x, y, dm });\n            } else {\n                ums.push_back((point){ x, y, ds });\n            }\n        }\n\n        for(int i = 0; i < r; ++i) {\n            int w, a;\n            cin >> w >> a;\n            for(int j = 0; j < homes.size(); ++j) {\n                bool is_perfect = true;\n                for(int k = 0; k < ums.size(); ++k) {\n                    if(check_deg(homes[j], ums[k], w) && check_dst(homes[j], ums[k], a)) {\n                        is_perfect = false;\n                    }\n                }\n                homes[j].d += is_perfect;\n            }\n        }\n\n        int max_day = 0;\n        for(int i = 0; i < homes.size(); ++i) {\n            max_day = max(max_day, homes[i].d);\n        }\n\n        if(max_day) {\n            bool is_out = false;\n            for(int i = 0; i < homes.size(); ++i) {\n                if(homes[i].d == max_day) {\n                    if(is_out) cout << \" \" << i + 1;\n                    else cout << i + 1;\n                    is_out = true;\n                }\n            }\n            cout << endl;\n        } else {\n            cout << \"NA\" << endl;\n        }\n\n    }\n\n}"
  },
  {
    "language": "C++",
    "code": "#include<bits/stdc++.h>\n#define rep(i,n) for(int i=0;i<(int)n;i++)\n#define all(c) (c).begin(),(c).end()\n#define pb push_back\n#define dbg(...) do{cerr<<__LINE__<<\": \";dbgprint(#__VA_ARGS__, __VA_ARGS__);}while(0);\n\nusing namespace std;\n\nnamespace std{template<class S,class T>struct hash<pair<S,T>>{size_t operator()(const pair<S,T>&p)const{return ((size_t)1e9+7)*hash<S>()(p.first)+hash<T>()(p.second);}};template<class T>struct hash<vector<T>>{size_t operator()(const vector<T> &v)const{size_t h=0;for(auto i : v)h=h*((size_t)1e9+7)+hash<T>()(i)+1;return h;}};}\ntemplate<class T>ostream& operator<<(ostream &os, const vector<T> &v){os<<\"[ \";rep(i,v.size())os<<v[i]<<(i==v.size()-1?\" ]\":\", \");return os;}template<class T>ostream& operator<<(ostream &os,const set<T> &v){os<<\"{ \"; for(const auto &i:v)os<<i<<\", \";return os<<\"}\";}\ntemplate<class T,class U>ostream& operator<<(ostream &os,const map<T,U> &v){os<<\"{\";for(const auto &i:v)os<<\" \"<<i.first<<\": \"<<i.second<<\",\";return os<<\"}\";}template<class T,class U>ostream& operator<<(ostream &os,const pair<T,U> &p){return os<<\"(\"<<p.first<<\", \"<<p.second<<\")\";}\nvoid dbgprint(const string &fmt){cerr<<endl;}template<class H,class... T>void dbgprint(const string &fmt,const H &h,const T&... r){cerr<<fmt.substr(0,fmt.find(\",\"))<<\"= \"<<h<<\" \";dbgprint(fmt.substr(fmt.find(\",\")+1),r...);}\ntypedef long long ll;typedef vector<int> vi;typedef pair<int,int> pi;const double EPS = 1e-8, INF = 1e12, PI = acos(-1.0);\ntypedef complex<double> P;\nnamespace std{\n\tbool operator<(const P& a, const P& b){\n\t\treturn real(a) != real(b) ? real(a) < real(b) : imag(a) < imag(b);\n\t}\n}\ninline double cross(const P& a, const P& b){ return imag(conj(a)*b); }\ninline double dot(const P& a, const P& b){ return real(conj(a)*b); }\nstruct L : public vector<P>{\n\tL(const P &a, const P &b) {\n\t\tpush_back(a); push_back(b);\n\t}\n};\ntypedef vector<P> G;\n\nint main(){\n\tcin.tie(0); cin.sync_with_stdio(0);\n\tint h, r;\n\twhile(cin >> h >> r, h){\n\t\tauto in = [](G &g, int n){\n\t\t\trep(i, n){ int x, y; cin >> x >> y; g.emplace_back(x, y); }\n\t\t};\n\t\t\n\t\tG hs; in(hs, h);\n\t\tint U, M, S, du, dm, ds; cin >> U >> M >> S >> du >> dm >> ds;\n\t\tG us, ms, ss;\n\t\tin(us, U); in(ms, M); in(ss, S);\n\t\tG myu = {P(0, 0)};\n\t\t\n\t\tvi cnt(h);\n\t\trep(it, r){\n\t\t\tint w, a; cin >> w >> a;\n\t\t\trep(i, h){\n\t\t\t\tbool my = 0, other = 0;\n\t\t\t\tauto check = [&](G &ps, int width, P &p){\n\t\t\t\t\tfor(P o : ps){\n\t\t\t\t\t\tif(abs(p - o) > a) continue;\n\t\t\t\t\t\tdouble t = arg(p - o) - w * PI / 180;\n\t\t\t\t\t\tif(t > PI) t -= 2 * PI;\n\t\t\t\t\t\tif(t < -PI)t += 2 * PI;\n\t\t\t\t\t\tif(abs(t) < width * PI / 180 / 2) return 1;\n\t\t\t\t\t}\n\t\t\t\t\treturn 0;\n\t\t\t\t};\n\t\t\t\tmy    |= check(myu, du, hs[i]);\n\t\t\t\tother |= check(us, du, hs[i]);\n\t\t\t\tother |= check(ms, dm, hs[i]);\n\t\t\t\tother |= check(ss, ds, hs[i]);\n\t\t\t\tif(my && !other) cnt[i]++;\n\t\t\t}\n\t\t}\n\t\tint best = *max_element(all(cnt));\n\t\tvi bests;\n\t\trep(i, h) if(best == cnt[i]) bests.pb(i + 1);\n\t\tif(best == 0) cout << \"NA\" << endl;\n\t\telse rep(i, bests.size()) cout << bests[i] << (i==bests.size()-1?\"\\n\":\" \");\n\t}\n\treturn 0;\n}\n"
  },
  {
    "language": "C++",
    "code": "#include <algorithm>\n#include <cmath>\n#include <iostream>\n#include <vector>\n\nusing namespace std;\n\ntypedef long long ll;\ntypedef vector<int> vi;\ntypedef vector<vi> vvi;\ntypedef pair<int, int> pii;\n\n#define reps(i,f,n) for(int i=f; i<int(n); ++i)\n#define rep(i,n) reps(i,0,n)\n\nconst double PI = acos(-1);\n\nbool reach(int x, int y, int w, int a, int d)\n{\n    if(x*x + y*y > a*a) return false;\n    double arg = atan2(y, x)*180/PI - w;\n    if(arg < -180) arg += 360;\n    return abs(arg)*2 < d;\n}\n\nvoid func(int H, int R)\n{\n    vector<pii> house(H);\n    rep(i, H){\n        cin >> house[i].first >> house[i].second;\n    }\n    \n    int N[3], d[3];\n    rep(i, 3) cin >> N[i];\n    rep(i, 3) cin >> d[i];\n    \n    vector<pii> tree[3];\n    \n    rep(i, 3){\n        tree[i].resize(N[i]);\n        rep(j, N[i]){\n            cin >> tree[i][j].first >> tree[i][j].second;\n        }\n    }\n    \n    vi cnt(H);\n    \n    rep(i, R){\n        int w, a;\n        cin >> w >> a;\n        \n        rep(j, H){\n            bool ok = reach(house[j].first, house[j].second, w, a, d[0]);\n            \n            rep(k, 3) rep(l, N[k]){\n                ok &= !reach(house[j].first - tree[k][l].first, house[j].second - tree[k][l].second, w, a, d[k]);\n            }\n            \n            if(ok) cnt[j]++;\n        }\n    }\n    \n    int maxi = *max_element(cnt.begin(), cnt.end());\n    if(maxi == 0){\n        cout << \"NA\" << endl;\n        return;\n    }\n    \n    bool first = true;\n    rep(i, H){\n        if(cnt[i] == maxi){\n            cout << (first ? \"\" : \" \") << i+1;\n            first = false;\n        }\n    }\n    \n    cout << endl;\n}\n\nint main()\n{\n    int H, R;\n    while(cin >> H >> R, H){\n        func(H, R);\n    }\n}"
  },
  {
    "language": "C++",
    "code": "#include <cstdio>\n#include <cstring>\n#include <cmath>\n\nint h,r,s[3];\ndouble hx[101],hy[101];\ndouble d[3];\ndouble x[3][101],y[3][101];\ndouble w[101],a[101];\nint cnt[101];\n\nbool check(int v,int day){\n\tdouble di=atan2(hy[v],hx[v])/M_PI*180.0;\n\tif(hx[v]*hx[v]+hy[v]*hy[v]>a[day]*a[day])return false;\n\tif(!((w[day]-d[0]/2.0<di && di<w[day]+d[0]/2.0) || (w[day]-d[0]/2.0<di+360.0 && di+360.0<w[day]+d[0]/2.0)))return false;\n\tfor(int k=0;k<=2;k++){\n\t\tfor(int i=0;i<s[k];i++){\n\t\t\tdouble nx=hx[v]-x[k][i],ny=hy[v]-y[k][i];\n\t\t\tif(sqrt(nx*nx+ny*ny)<a[day]){\n\t\t\t\tdouble dir=atan2(ny,nx)/M_PI*180.0;\n\t\t\t\t//printf(\"%d %d %d %f %f %f %f %f\\n\",v,k,i,nx,ny,dir,w[day]-d[k]/2.0,w[day]+d[k]/2.0);\n\t\t\t\tif(w[day]-d[k]/2.0<dir && dir<w[day]+d[k]/2.0)return false;\n\t\t\t\tif(w[day]-d[k]/2.0<dir+360.0 && dir+360.0<w[day]+d[k]/2.0)return false;\n\t\t\t}\n\t\t}\n\t}\n\treturn true;\n}\n\nint main(void){\n\twhile(1){\n\t\tscanf(\"%d %d\",&h,&r);\n\t\tif(h+r==0)break;\n\t\tmemset(cnt,0,sizeof(cnt));\n\t\tfor(int i=0;i<h;i++){\n\t\t\tscanf(\"%lf %lf\",&hx[i],&hy[i]);\n\t\t}\n\t\tscanf(\"%d %d %d %lf %lf %lf\",&s[0],&s[1],&s[2],&d[0],&d[1],&d[2]);\n\t\tfor(int i=0;i<3;i++){\n\t\t\tfor(int j=0;j<s[i];j++){\n\t\t\t\tscanf(\"%lf %lf\",&x[i][j],&y[i][j]);\n\t\t\t}\n\t\t}\n\t\tfor(int i=0;i<r;i++){\n\t\t\tscanf(\"%lf %lf\",&w[i],&a[i]);\n\t\t\tfor(int j=0;j<h;j++){\n\t\t\t\tif(check(j,i))cnt[j]++;\n\t\t\t}\n\t\t}\n\t\tint res=0,rcnt=0;\n\t\tfor(int i=0;i<h;i++){\n\t\t\tif(res==cnt[i])rcnt++;\n\t\t\tif(res<cnt[i]){\n\t\t\t\tres=cnt[i];\n\t\t\t\trcnt=1;\n\t\t\t}\n\t\t}\n\t\tif(res==0)printf(\"NA\\n\");\n\t\telse{\n\t\t\tint cn=0;\n\t\t\tfor(int i=0;i<h;i++){\n\t\t\t\tif(res==cnt[i]){\n\t\t\t\t\tprintf(\"%d%c\",i+1,cn+1==rcnt?'\\n':' ');\n\t\t\t\t\tcn++;\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t}\n\treturn 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\n\nusing namespace std;\n\nstruct point {\n    int x, y;\n    int d;\n};\n\nbool check_including(point home, point ums, int w, int a) {\n\n    double x = home.x - ums.x;\n    double y = home.y - ums.y;\n    double home_deg;\n    double start_deg = w - ums.d / 2;\n    double end_deg = w + ums.d / 2;\n\n    home_deg = atan2(y, x) * 180 / M_PI;\n\n    if(home_deg < 0) {\n        home_deg += 360;\n    }\n\n    if(end_deg > 360.0) {\n        home_deg += 360;\n    }\n\n    if(start_deg <= home_deg && home_deg <= end_deg && x * x + y * y <= a * a) {\n        return true;\n    } else {\n        return false;\n    }\n\n}\n\nint main() {\n\n    int h, r;\n\n    while(cin >> h >> r, h || r) {\n\n        int u, m, s, du, dm, ds;\n        vector<point> homes, ums;\n\n        for(int i = 0; i < h; ++i) {\n            int x, y;\n            cin >> x >> y;\n            homes.push_back((point){ x, y, 0 });\n        }\n\n        cin >> u >> m >> s;\n        cin >> du >> dm >> ds;\n\n        for(int i = 0; i < u + m + s; ++i) {\n            int x, y;\n            cin >> x >> y;\n            if(i < u) {\n                ums.push_back((point){ x, y, du });\n            } else if(u <= i && i < u + m) {\n                ums.push_back((point){ x, y, dm });\n            } else {\n                ums.push_back((point){ x, y, ds });\n            }\n        }\n\n        for(int i = 0; i < r; ++i) {\n            int w, a;\n            cin >> w >> a;\n            for(int j = 0; j < homes.size(); ++j) {\n                bool is_perfect = true;\n                for(int k = 0; k < ums.size(); ++k) {\n                    if(check_including(homes[j], ums[k], w, a)) {\n                        is_perfect = false;\n                        break;\n                    }\n                }\n                homes[j].d += is_perfect;\n            }\n        }\n\n        int max_day = 0;\n        for(int i = 1; i < homes.size(); ++i) {\n            if(max_day < homes[i].d) {\n                max_day = homes[i].d;\n            }\n        }\n\n        if(max_day) {\n            bool is_out = false;\n            for(int i = 0; i < homes.size(); ++i) {\n                if(homes[i].d == max_day) {\n                    if(is_out) cout << \" \" << i + 1;\n                    else cout << i + 1;\n                    is_out = true;\n                }\n            }\n            cout << endl;\n        } else {\n            cout << \"NA\" << endl;\n        }\n\n    }\n\n}"
  },
  {
    "language": "C",
    "code": "// Aizu 0269: East Wind\n// 2017.9.12 bal4u@uu\n\n#include <stdio.h>\n#include <string.h>\n#include <math.h>\n\n#define EPS 0.00001\n#define PI 3.1415926535897932384626433832795\n\ntypedef struct { int x, y; } POS;\nPOS tree[3][13]; int u[3], du[3];\n\ntypedef struct { int x, y, c, f; } HOME;\nHOME home[103]; int h;\n\ntypedef struct { int w, a; } WIND;\nWIND wind[102]; int r;\n\nint reach(int x, int y, int x0, int y0, int w, int a, int d)\n{\n\tdouble xx, yy, r, angle, ww1, ww2;\n\tif (x == x0 && y == y0) return 1; \n\txx = x - x0, yy = y - y0, angle = atan2(yy, xx), r = sqrt(xx*xx + yy*yy);\n\tif (r-a > EPS && r > a) return 0;\n\tww1 = PI*(w - 0.5*d)/180.0, ww2 = PI*(w + 0.5*d)/180.0;\n\tif (fabs(angle-ww1) <= EPS || fabs(ww2-angle) <= EPS || (ww1 <= angle && angle <= ww2)) return 1; \n\treturn 0;\n}\n\nint main()\n{\n\tint i, j, k, m, max;\n\n\twhile (scanf(\"%d%d\", &h, &r) && h) {\n\t\tfor (i = 0; i < h; i++) scanf(\"%d%d\", &home[i].x, &home[i].y), home[i].f = 1, home[i].c = 0;\n\t\tfor (i = 0; i < 3; i++) scanf(\"%d\", u+i);\n\t\tfor (i = 0; i < 3; i++) scanf(\"%d\", du+i);\n\t\tfor (j = 0; j < 3; j++) for (i = 0; i < u[j]; i++)\n\t\t\tscanf(\"%d%d\", &tree[j][i].x, &tree[j][i].y);\n\t\tfor (i = 0; i < r; i++) scanf(\"%d%d\", &wind[i].w, &wind[i].a);\n\n\t\tfor (k = 0; k < r; k++) for (j = 0; j < 3; j++) for (m = 0; m < u[j]; m++) for (i = 0; i < h; i++) if (home[i].f) {\n\t\t\tif (reach(home[i].x, home[i].y, tree[j][m].x, tree[j][m].y, wind[k].w, wind[k].a, du[j])) home[i].f = 0;\n\t\t}\n\n\t\tfor (k = 0; k < r; k++) for (i = 0; i < h; i++) if (home[i].f) {\n\t\t\tif (reach(home[i].x, home[i].y, 0, 0, wind[k].w, wind[k].a, du[0])) home[i].c++;\n\t\t}\n\t\tfor (max = 0, i = 0; i < h; i++) if (home[i].f) {\n\t\t\tif (home[i].c > max) max = home[i].c; \n\t\t}\n\t\tif (max == 0) puts(\"NA\");\n\t\telse {\n\t\t\tfor (k = 1, i = 0; i < h; i++) if (home[i].f) {\n\t\t\t\tif (home[i].c < max) continue;\n\t\t\t\tif (k) k = 0; else putchar(' ');\n\t\t\t\tprintf(\"%d\", i+1);\n\t\t\t}\n\t\t\tputchar('\\n');\n\t\t}\n\t}\n\treturn 0;\n}"
  },
  {
    "language": "C",
    "code": "#include <stdio.h>\n#include <string.h>\n#include <math.h>\n#define PI 3.1415926535897932384626433832795028841971693993751058209749445923078164\n\nstruct point{\n\tint x,y;\n};\n\nstruct wind{\n\tint w,a;\n};\n\ndouble getlen(int x1,int y1,int x2,int y2){\n\treturn sqrt(pow((x1-x2)*1.0,2)+pow((y1-y2)*1.0,2));\n}\n\nint check(int N,point *tree,point house,wind wind,int dtree){\n\tint i;\n\tdouble rad,dig;\n\n\tfor(i = 0;i < N;i++){\n\t\tif(wind.a*1.0 < getlen(house.x,house.y,tree[i].x,tree[i].y)){\n\t\t\treturn 1;\n\t\t}\n\t\trad = atan2((house.y-tree[i].y)*1.0,(house.x-tree[i].x)*1.0);\n\t\tdig = fmod((rad * 180.0 / PI)+360.0,360.0);\n\n\t\tif(wind.w*1.0-dtree/2.0+90.0 <= dig+90.0 && wind.w*1.0+dtree/2.0+90.0 >= dig+90.0){\n\t\t\treturn 0;\n\t\t}\n    }\n\n\treturn 1;\n}\n\nint check2(point house,wind wind,int dtree){\n\tdouble rad,dig;\n\n\tif(wind.a*1.0 < getlen(house.x,house.y,0,0)){\n\t\treturn 0;\n\t}\n\n\trad = atan2(house.y*1.0,house.x*1.0);\n\tdig = fmod((rad * 180.0 / PI)+360.0,360.0);\n\n\tif(!(wind.w*1.0-dtree/2.0+90.0 <= dig+90.0 && wind.w*1.0+dtree/2.0+90.0 >= dig+90.0)){\n\t\treturn 0;\n\t}\n\n\treturn 1;\n}\n\nvoid max(int H,int *ok){\n\tint i,p,dmax;\n\tint tmp[100];\n\n\tp = 0;\n\tdmax = 0;\n\n\tfor(i = 0;i < H;i++){\n\t\tif(dmax < ok[i]){\n\t\t\tdmax = ok[i];\n\t\t\ttmp[0] = i+1;\n\t\t\tp = 1;\n\t\t}else if(dmax != 0 && dmax == ok[i]){\n\t\t\ttmp[p++] = i+1;\n\t\t}\n\t}\n\n\tif(dmax == 0){\n\t\tprintf(\"NA\\n\");\n\t}else{\n\t\tfor(i = 0;i < p;i++){\n\t\t\tprintf(\"%d%c\",tmp[i],(i == p-1) ? '\\n' : ' ');\n\t\t}\n\t}\n}\n\nint main(){\n\tint i,j,H,R,U,M,S,du,dm,ds;\n\tint ok[100];\n\tpoint h[100],u[10],m[10],s[10];\n\twind wind[100];\n\n\twhile(1){\n\t\tmemset(ok,0,sizeof(ok));\n\t\tscanf(\"%d %d\",&H,&R);\n\t\tif(H == 0 && R == 0){\n\t\t\tbreak;\n\t\t}\n\t\tfor(i = 0;i < H;i++){\n\t\t\tscanf(\"%d %d\",&h[i].x,&h[i].y);\n\t\t}\n\t\tscanf(\"%d %d %d %d %d %d\",&U,&M,&S,&du,&dm,&ds);\n\t\tfor(i = 0;i < U;i++){\n\t\t\tscanf(\"%d %d\",&u[i].x,&u[i].y);\n\t\t}\n\t\tfor(i = 0;i < M;i++){\n\t\t\tscanf(\"%d %d\",&m[i].x,&m[i].y);\n\t\t}\n\t\tfor(i = 0;i < S;i++){\n\t\t\tscanf(\"%d %d\",&s[i].x,&s[i].y);\n\t\t}\n\t\tfor(i = 0;i < R;i++){\n\t\t\tscanf(\"%d %d\",&wind[i].w,&wind[i].a);\n\t\t}\n\t\n\t\tfor(i = 0;i < R;i++){\n\t\t\tfor(j = 0;j < H;j++){\n\t\t\t\tif(!check2(h[j],wind[i],du)){\n\t\t\t\t\tcontinue;\n\t\t\t\t}\n\t\t\t\tif(!check(U,u,h[j],wind[i],du)){\n\t\t\t\t\tcontinue;\n\t\t\t\t}\n\t\t\t\tif(!check(M,m,h[j],wind[i],dm)){\n\t\t\t\t\tcontinue;\n\t\t\t\t}\n\t\t\t\tif(!check(S,s,h[j],wind[i],ds)){\n\t\t\t\t\tcontinue;\n\t\t\t\t}\n\t\t\t\tok[j]++;\n\t\t\t}\n\t\t}\n\t\n\t\tmax(H,ok);\n\t}\n\n\treturn 0;\n}"
  },
  {
    "language": "C",
    "code": "// Aizu 0269: East Wind\n// 2017.9.12 bal4u@uu\n\n#include <stdio.h>\n#include <string.h>\n#include <math.h>\n\n#define EPS 0.00001\n#define PI 3.1415926535897932384626433832795\n\ntypedef struct { int x, y; } POS;\nPOS tree[3][13]; int u[3], du[3];\n\ntypedef struct { int x, y, c, f; } HOME;\nHOME home[103]; int h;\n\ntypedef struct { int w, a; } WIND;\nWIND wind[102]; int r;\n\nint reach(int x, int y, int x0, int y0, int w, int a, int d)\n{\n\tdouble xx, yy, r, angle, ww1, ww2;\n\tif (x == x0 && y == y0) return 1; \n\txx = x - x0, yy = y - y0, r = sqrt(xx*xx + yy*yy);\n\tangle = atan2(yy, xx); if (fabs(angle) > EPS && angle <= 0.0) angle += PI*2;\n\tif (r-a > EPS && r > a) return 0;\n\tww1 = PI*(w - 0.5*d)/180.0, ww2 = PI*(w + 0.5*d)/180.0;\n\tif (fabs(angle-ww1) <= EPS || fabs(ww2-angle) <= EPS || (ww1 <= angle && angle <= ww2)) return 1; \n\tangle += PI*2;\n\tif (fabs(angle-ww1) <= EPS || fabs(ww2-angle) <= EPS || (ww1 <= angle && angle <= ww2)) return 1; \n\treturn 0;\n}\n\nint main()\n{\n\tint i, j, k, m, max;\n\n\twhile (scanf(\"%d%d\", &h, &r) && h) {\n\t\tfor (i = 0; i < h; i++) scanf(\"%d%d\", &home[i].x, &home[i].y), home[i].f = 1, home[i].c = 0;\n\t\tfor (i = 0; i < 3; i++) scanf(\"%d\", u+i);\n\t\tfor (i = 0; i < 3; i++) scanf(\"%d\", du+i);\n\t\tfor (j = 0; j < 3; j++) for (i = 0; i < u[j]; i++)\n\t\t\tscanf(\"%d%d\", &tree[j][i].x, &tree[j][i].y);\n\t\tfor (i = 0; i < r; i++) scanf(\"%d%d\", &wind[i].w, &wind[i].a);\n\n\t\tfor (k = 0; k < r; k++) for (j = 0; j < 3; j++) for (m = 0; m < u[j]; m++) for (i = 0; i < h; i++) if (home[i].f) {\n\t\t\tif (reach(home[i].x, home[i].y, tree[j][m].x, tree[j][m].y, wind[k].w, wind[k].a, du[j])) home[i].f = 0;\n\t\t}\n\n\t\tfor (k = 0; k < r; k++) for (i = 0; i < h; i++) if (home[i].f) {\n\t\t\tif (reach(home[i].x, home[i].y, 0, 0, wind[k].w, wind[k].a, du[0])) home[i].c++;\n\t\t}\n\t\tfor (max = 0, i = 0; i < h; i++) if (home[i].f) {\n\t\t\tif (home[i].c > max) max = home[i].c; \n\t\t}\n\t\tif (max == 0) puts(\"NA\");\n\t\telse {\n\t\t\tfor (k = 1, i = 0; i < h; i++) if (home[i].f) {\n\t\t\t\tif (home[i].c < max) continue;\n\t\t\t\tif (k) k = 0; else putchar(' ');\n\t\t\t\tprintf(\"%d\", i+1);\n\t\t\t}\n\t\t\tputchar('\\n');\n\t\t}\n\t}\n\treturn 0;\n}"
  },
  {
    "language": "C",
    "code": "// Aizu 0269: East Wind\n// 2017.9.12 bal4u@uu\n\n#include <stdio.h>\n#include <string.h>\n#include <math.h>\n\n#define EPS 0.00001\n#define PI  3.1415926535897932384626433832795\n\ntypedef struct { int x, y; } POS;\nPOS tree[3][13]; int u[3], du[3];\n\ntypedef struct { int x, y, c, f; } HOME;\nHOME home[103]; int h;\n\ntypedef struct { int w, a; } WIND;\nWIND wind[102]; int r;\n\nint reach(int x, int y, int x0, int y0, int w, int a, int d)\n{\n\tdouble xx, yy, r, angle, ww1, ww2;\n\tif (x == x0 && y == y0) return 1; \n\txx = x - x0, yy = y - y0, r = sqrt(xx*xx + yy*yy), angle = atan2(yy, xx);\n\tif (fabs(r-a) > EPS && r > a) return 0;\n\tww1 = PI*(w - 0.5*d)/180.0, ww2 = PI*(w + 0.5*d)/180.0;\n\tif (fabs(angle-ww1) <= EPS || fabs(ww2-angle) <= EPS || (ww1 <= angle && angle <= ww2)) return 1; \n\tangle += 2*PI;\n\tif (fabs(angle-ww1) <= EPS || fabs(ww2-angle) <= EPS || (ww1 <= angle && angle <= ww2)) return 1; \n\treturn 0;\n}\n\nint main()\n{\n\tint i, j, k, m, max;\n\n\twhile (scanf(\"%d%d\", &h, &r) && h) {\n\t\tfor (i = 0; i < h; i++) scanf(\"%d%d\", &home[i].x, &home[i].y), home[i].f = 1, home[i].c = 0;\n\t\tfor (i = 0; i < 3; i++) scanf(\"%d\", u+i);\n\t\tfor (i = 0; i < 3; i++) scanf(\"%d\", du+i);\n\t\tfor (j = 0; j < 3; j++) for (i = 0; i < u[j]; i++)\n\t\t\tscanf(\"%d%d\", &tree[j][i].x, &tree[j][i].y);\n\t\tfor (i = 0; i < r; i++) scanf(\"%d%d\", &wind[i].w, &wind[i].a);\n\n\t\tfor (k = 0; k < r; k++) for (j = 0; j < 3; j++) for (m = 0; m < u[j]; m++) for (i = 0; i < h; i++) if (home[i].f) {\n\t\t\tif (reach(home[i].x, home[i].y, tree[j][m].x, tree[j][m].y, wind[k].w, wind[k].a, du[j])) home[i].f = 0;\n\t\t}\n\n\t\tfor (k = 0; k < r; k++) for (i = 0; i < h; i++) if (home[i].f) {\n\t\t\tif (reach(home[i].x, home[i].y, 0, 0, wind[k].w, wind[k].a, du[0])) home[i].c++;\n\t\t}\n\t\tfor (max = 0, i = 0; i < h; i++) if (home[i].f) {\n\t\t\tif (home[i].c > max) max = home[i].c; \n\t\t}\n\t\tif (max == 0) puts(\"NA\");\n\t\telse {\n\t\t\tfor (k = 1, i = 0; i < h; i++) if (home[i].f) {\n\t\t\t\tif (home[i].c < max) continue;\n\t\t\t\tif (k) k = 0; else putchar(' ');\n\t\t\t\tprintf(\"%d\", i+1);\n\t\t\t}\n\t\t\tputchar('\\n');\n\t\t}\n\t}\n\treturn 0;\n}"
  },
  {
    "language": "C",
    "code": "// Aizu 0269: East Wind\n// 2017.9.12 bal4u@uu\n\n#include <stdio.h>\n#include <string.h>\n#include <math.h>\n\n#define EPS 0.00001\n#define PI 3.1415926535897932384626433832795\n\ntypedef struct { int x, y; } POS;\nPOS tree[3][13]; int u[3], du[3];\n\ntypedef struct { int x, y, c, f; } HOME;\nHOME home[103]; int h;\n\ntypedef struct { int w, a; } WIND;\nWIND wind[102]; int r;\n\nint reach(int x, int y, int x0, int y0, int w, int a, int d)\n{\n\tdouble xx, yy, r, angle, ww1, ww2;\n\tif (x == x0 && y == y0) return 1; \n\txx = x - x0, yy = y - y0, r = sqrt(xx*xx + yy*yy);\n\tangle = atan2(yy, xx); if (fabs(angle) > EPS && angle <= 0.0) angle += PI*2;\n\tif (r-a > EPS && r > a) return 0;\n\tww1 = PI*(w - 0.5*d)/180.0, ww2 = PI*(w + 0.5*d)/180.0;\n\tif (fabs(angle-ww1) <= EPS || fabs(ww2-angle) <= EPS || (ww1 <= angle && angle <= ww2)) return 1; \n\tangle += PI*2;\n\tif (fabs(angle-ww1) <= EPS || fabs(ww2-angle) <= EPS || (ww1 <= angle && angle <= ww2)) return 1; \n\tangle -= PI*2;\n\tif (fabs(angle-ww1) <= EPS || fabs(ww2-angle) <= EPS || (ww1 <= angle && angle <= ww2)) return 1; \n\treturn 0;\n}\n\nint main()\n{\n\tint i, j, k, m, max;\n\n\twhile (scanf(\"%d%d\", &h, &r) && h) {\n\t\tfor (i = 0; i < h; i++) scanf(\"%d%d\", &home[i].x, &home[i].y), home[i].f = 1, home[i].c = 0;\n\t\tfor (i = 0; i < 3; i++) scanf(\"%d\", u+i);\n\t\tfor (i = 0; i < 3; i++) scanf(\"%d\", du+i);\n\t\tfor (j = 0; j < 3; j++) for (i = 0; i < u[j]; i++)\n\t\t\tscanf(\"%d%d\", &tree[j][i].x, &tree[j][i].y);\n\t\tfor (i = 0; i < r; i++) scanf(\"%d%d\", &wind[i].w, &wind[i].a);\n\n\t\tfor (k = 0; k < r; k++) for (j = 0; j < 3; j++) for (m = 0; m < u[j]; m++) for (i = 0; i < h; i++) if (home[i].f) {\n\t\t\tif (reach(home[i].x, home[i].y, tree[j][m].x, tree[j][m].y, wind[k].w, wind[k].a, du[j])) home[i].f = 0;\n\t\t}\n\n\t\tfor (k = 0; k < r; k++) for (i = 0; i < h; i++) if (home[i].f) {\n\t\t\tif (reach(home[i].x, home[i].y, 0, 0, wind[k].w, wind[k].a, du[0])) home[i].c++;\n\t\t}\n\t\tfor (max = 0, i = 0; i < h; i++) if (home[i].f) {\n\t\t\tif (home[i].c > max) max = home[i].c; \n\t\t}\n\t\tif (max == 0) puts(\"NA\");\n\t\telse {\n\t\t\tfor (k = 1, i = 0; i < h; i++) if (home[i].f) {\n\t\t\t\tif (home[i].c < max) continue;\n\t\t\t\tif (k) k = 0; else putchar(' ');\n\t\t\t\tprintf(\"%d\", i+1);\n\t\t\t}\n\t\t\tputchar('\\n');\n\t\t}\n\t}\n\treturn 0;\n}"
  },
  {
    "language": "C",
    "code": "#include <stdio.h>\n#include <math.h>\n\n#define PI 3.1415926535897932384626433832795028841\n\nint isreach(int x,int y,int wangle,int wpower,int fangle) {\n\tdouble angle1,angle2,angle3,angle4;\n\tif(x*x+y*y>wpower*wpower)return 0;\n\tangle1=atan2(y,x);\n\tangle2=wangle*PI/180.0;\n\tangle3=fangle*PI/180.0;\n\tangle4=fabs(angle1-angle2);\n\twhile(angle4>=PI*2)angle4-=PI*2;\n\tif(angle4>PI)angle4=PI*2-angle4;\n\treturn angle4<=angle3/2;\n}\n\nint main(void) {\n\tint H,R;\n\tint housex[100],housey[100],houseok[100];\n\tint U,M,S,du,dm,ds;\n\tint ux[10],uy[10],mx[10],my[10],sx[10],sy[10];\n\tint w,a;\n\tint i,j,k;\n\tint ok,max;\n\twhile(scanf(\"%d%d\",&H,&R)==2 && (H|R)!=0) {\n\t\tfor(i=0;i<H;i++) {\n\t\t\tscanf(\"%d%d\",&housex[i],&housey[i]);\n\t\t\thouseok[i]=0;\n\t\t}\n\t\tscanf(\"%d%d%d%d%d%d\",&U,&M,&S,&du,&dm,&ds);\n\t\tfor(i=0;i<U;i++)scanf(\"%d%d\",&ux[i],&uy[i]);\n\t\tfor(i=0;i<M;i++)scanf(\"%d%d\",&mx[i],&my[i]);\n\t\tfor(i=0;i<S;i++)scanf(\"%d%d\",&sx[i],&sy[i]);\n\t\tfor(i=0;i<R;i++) {\n\t\t\tscanf(\"%d%d\",&w,&a);\n\t\t\tfor(j=0;j<H;j++) {\n\t\t\t\tif(isreach(housex[j],housey[j],w,a,du)) {\n\t\t\t\t\tok=1;\n\t\t\t\t\tfor(k=0;k<U;k++) {\n\t\t\t\t\t\tif(isreach(housex[j]-ux[k],housey[j]-uy[k],w,a,du)) {\n\t\t\t\t\t\t\tok=0;\n\t\t\t\t\t\t\tbreak;\n\t\t\t\t\t\t}\n\t\t\t\t\t}\n\t\t\t\t\tif(ok) {\n\t\t\t\t\t\tfor(k=0;k<M;k++) {\n\t\t\t\t\t\t\tif(isreach(housex[j]-mx[k],housey[j]-my[k],w,a,dm)) {\n\t\t\t\t\t\t\t\tok=0;\n\t\t\t\t\t\t\t\tbreak;\n\t\t\t\t\t\t\t}\n\t\t\t\t\t\t}\n\t\t\t\t\t}\n\t\t\t\t\tif(ok) {\n\t\t\t\t\t\tfor(k=0;k<S;k++) {\n\t\t\t\t\t\t\tif(isreach(housex[j]-sx[k],housey[j]-sy[k],w,a,ds)) {\n\t\t\t\t\t\t\t\tok=0;\n\t\t\t\t\t\t\t\tbreak;\n\t\t\t\t\t\t\t}\n\t\t\t\t\t\t}\n\t\t\t\t\t}\n\t\t\t\t\tif(ok)houseok[j]++;\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t\tmax=0;\n\t\tfor(i=0;i<H;i++) {\n\t\t\tif(houseok[i]>max)max=houseok[i];\n\t\t}\n\t\tif(max==0)puts(\"NA\");\n\t\telse {\n\t\t\tok=0;\n\t\t\tfor(i=0;i<H;i++) {\n\t\t\t\tif(houseok[i]==max) {\n\t\t\t\t\tif(ok)putchar(' ');\n\t\t\t\t\tprintf(\"%d\",i+1);\n\t\t\t\t\tok=1;\n\t\t\t\t}\n\t\t\t}\n\t\t\tputchar('\\n');\n\t\t}\n\t}\n\treturn 0;\n}"
  },
  {
    "language": "C",
    "code": "#include <stdio.h>\n#include <math.h>\n\ntypedef struct {\n    int x;\n    int y;\n} point_t;\n\ntypedef struct {\n    int deg;\n    int a;\n} wind_t;\n\nvoid scan_coordinate(point_t p[], int count) {\n    int i;\n    for (i = 0; i < count; i++) {\n        scanf(\"%d%d\", &(p[i].x), &(p[i].y));\n    }\n}\n\nint atan2_deg(double y, double x) {\n    int deg = atan2(y, x) * 180.0 / M_PI;\n    return (deg + 360) % 360;\n}\n\nint main(void) {\n    int H, R, U, M, S, du, dm, ds;\n    point_t house[100], ume[10], momo[10], sakura[10];\n    point_t *hus, *um, *mm, *skr;\n    wind_t wind[100], *wnd;\n    int nice_house[100], nice_max, nice;\n    int i, h, w, d, deg, pfirst;\n\n    while (scanf(\"%d%d\\n\", &H, &R) == 2 && H && R) {\n        scan_coordinate(house, H);\n        scanf(\"%d%d%d%d%d%d\\n\", &U, &M, &S, &du, &dm, &ds);\n        scan_coordinate(ume, U);\n        scan_coordinate(momo, M);\n        scan_coordinate(sakura, S);\n        for (i = 0; i < R; i++) {\n            scanf(\"%d%d\", &(wind[i].deg), &(wind[i].a));\n        }\n\n        \n        for (h = 0, nice_max = 0; h < H; h++) {\n            hus = &house[h];\n            nice_house[h] = 0;\n            for (w = 0; w < R; w++) {\n                wnd = &wind[w];\n                nice = 0;\n                if (hypot(hus->x, hus->y) < wnd->a) {\n                    deg = atan2_deg(hus->y, hus->x);\n                    if ((wnd->deg - du / 2) < deg && deg < (wnd->deg + du/2)) {\n                        nice = 1;\n                    }\n                }\n                if (!nice) continue;\n\n                for (i = 0; i < 3; i++) {\n                    int t, T;\n                    point_t *tp, *tree;\n                    switch (i) {\n                    case 0:\n                        tree = ume; T = U; d = du; break;\n                    case 1:\n                        tree = momo; T = M; d = dm; break;\n                    case 2:\n                        tree = sakura; T = S; d = ds; break;\n                    }\n                    for (t = 0; t < T; t++) {\n                        tp = &tree[t];\n                        if (hypot(tp->x - hus->x, tp->y - hus->y) < wnd->a) {\n                            deg = atan2_deg(hus->y - tp->y, hus->x - tp->x);\n                            // printf(\"%d: %d -- %d - %d\\n\", h+1, deg, wnd->deg - d/2, wnd->deg + d/2);\n                            if (deg > (wnd->deg - d/2) && (wnd->deg + d/2) > deg) {\n                                nice = 0;\n                                break;\n                            }\n                        }\n                    }\n                    if (!nice) break;\n                }\n                nice_house[h] += nice;\n            }\n            if (nice_max < nice_house[h]) {\n                nice_max = nice_house[h];\n            }\n        }\n        if (nice_max > 0) {\n            for (h = 0, pfirst = 1; h < H; h++) {\n                if (nice_house[h] == nice_max) {\n                    printf(\"%s%d\", pfirst ? \"\": \" \", h+1);\n                    if (pfirst) pfirst = 0;\n                }\n            }\n            printf(\"\\n\");\n        }\n        else printf(\"NA\\n\");\n    }\n    return 0;\n}"
  },
  {
    "language": "C",
    "code": "#include <stdio.h>\n#include <stdlib.h>\n#include <sys/types.h>\n#include <math.h>\n\n/* constant */\n\n#define MAX_N   (100)\n#define MAX_T   (10)\n\n#define EPS     ((double)1.0e-4)\n\n/* typedef */\n\ntypedef struct _pt_t {\n  double x, y;\n} pt_t;\n\ntypedef struct _wind_t {\n  int w, a;\n} wind_t;\n\n/* global variables */\n\nstatic pt_t houses[MAX_N];\nstatic wind_t winds[MAX_N];\n\nstatic pt_t ume[MAX_T], momo[MAX_T], sakura[MAX_T];\nstatic pt_t origin = {0, 0};\n\nstatic int max_houses[MAX_N];\n\n/* subroutines */\n\ndouble dist2(pt_t *p0, pt_t *p1) {\n  double dx = p1->x - p0->x;\n  double dy = p1->y - p0->y;\n  return (dx * dx + dy * dy);\n}\n\ndouble o_prod(pt_t *v0, pt_t *v1) {\n  return (v0->x * v1->y - v0->y * v1->x);\n}\n\nint deg_inside(pt_t *p0, pt_t *p1, double d0, double d1) {\n  double rad0, rad1;\n  pt_t dv0, dv1, pv;\n\n  rad0 = d0 * M_PI / 180;\n  rad1 = d1 * M_PI / 180;\n\n  dv0.x = cos(rad0);\n  dv0.y = sin(rad0);\n  dv1.x = cos(rad1);\n  dv1.y = sin(rad1);\n\n  pv.x = p1->x - p0->x;\n  pv.y = p1->y - p0->y;\n\n  return (o_prod(&dv0, &pv) >= -EPS && o_prod(&dv1, &pv) <= EPS);\n}\n\nint reach(pt_t *src, pt_t *h, wind_t *w, int d) {\n  return\n    (dist2(src, h) <= (EPS + w->a) * (EPS + w->a) &&\n     deg_inside(src, h, w->w - 0.5 * d, w->w + 0.5 * d));\n}\n\n\n/* main */\n\nint main(int argc, char **argv) {\n  int i, j, k, hn, rn, un, mn, sn, du, dm, ds;\n  int days, max_days, max_hn;\n  pt_t *hpt, *upt, *mpt, *spt;\n  wind_t *wpt;\n\n  for(;;) {\n    scanf(\"%d%d\", &hn, &rn);\n    if (hn == 0 && rn == 0) break;\n\n    for (i = 0; i < hn; i++)\n      scanf(\"%lf%lf\", &(houses[i].x), &(houses[i].y));\n\n    scanf(\"%d%d%d%d%d%d\", &un, &mn, &sn, &du, &dm, &ds);\n\n    for (i = 0; i < un; i++)\n      scanf(\"%lf%lf\", &(ume[i].x), &(ume[i].y));\n    for (i = 0; i < mn; i++)\n      scanf(\"%lf%lf\", &(momo[i].x), &(momo[i].y));\n    for (i = 0; i < sn; i++)\n      scanf(\"%lf%lf\", &(sakura[i].x), &(sakura[i].y));\n\n    for (i = 0; i < rn; i++)\n      scanf(\"%d%d\", &(winds[i].w), &(winds[i].a));\n\n    max_days = 0;\n    max_hn = 0;\n\n    for (i = 0; i < hn; i++) {\n      hpt = &(houses[i]);\n      days = 0;\n\n      for (j = 0; j < rn; j++) {\n        wpt = &(winds[j]);\n\n        if (reach(&origin, hpt, wpt, du)) {\n          int ok = 1;\n\n          for (k = 0; k < un; k++)\n            if (reach(&(ume[k]), hpt, wpt, du)) {\n              ok = 0;\n              break;\n            }\n          if (! ok) break;\n\n          for (k = 0; k < mn; k++)\n            if (reach(&(momo[k]), hpt, wpt, dm)) {\n              ok = 0;\n              break;\n            }\n          if (! ok) break;\n\n          for (k = 0; k < sn; k++)\n            if (reach(&(sakura[k]), hpt, wpt, ds)) {\n              ok = 0;\n              break;\n            }\n          if (! ok) break;\n\n          days++;\n        }\n      }\n\n      /*printf(\"i=%d, days=%d\\n\", i, days);*/\n\n      if (max_days < days) {\n        max_days = days;\n        max_hn = 1;\n        max_houses[0] = i + 1;\n      }\n      else if (max_days == days) {\n        max_houses[max_hn++] = i + 1;\n      }\n    }\n\n    if (max_days == 0)\n      puts(\"NA\");\n    else {\n      for (i = 0; i < max_hn; i++) {\n        if (i > 0) putchar(' ');\n        printf(\"%d\", max_houses[i]);\n      }\n      putchar('\\n');\n    }\n  }\n\n  return 0;\n}"
  },
  {
    "language": "C",
    "code": "#include <stdio.h>\n#include <math.h>\n\n#define PI 3.1415926535897932384626433832795028841\n\nint isreach(int x,int y,int wangle,int wpower,int fangle) {\n\tdouble angle1,angle2,angle3,angle4;\n\tif(x*x+y*y>wpower*wpower)return 0;\n\tangle1=atan2(y,x);\n\tangle2=wangle*PI/180.0;\n\tangle3=fangle*PI/180.0;\n\tangle4=fabs(angle1-angle2);\n\twhile(angle4>=PI*2)angle4-=PI*2;\n\tif(angle4>PI)angle4=PI-angle4;\n\treturn angle4<=angle3/2;\n}\n\nint main(void) {\n\tint H,R;\n\tint housex[100],housey[100],houseok[100];\n\tint U,M,S,du,dm,ds;\n\tint ux[10],uy[10],mx[10],my[10],sx[10],sy[10];\n\tint w,a;\n\tint i,j,k;\n\tint ok,max;\n\twhile(scanf(\"%d%d\",&H,&R)==2 && (H|R)!=0) {\n\t\tfor(i=0;i<H;i++) {\n\t\t\tscanf(\"%d%d\",&housex[i],&housey[i]);\n\t\t\thouseok[i]=0;\n\t\t}\n\t\tscanf(\"%d%d%d%d%d%d\",&U,&M,&S,&du,&dm,&ds);\n\t\tfor(i=0;i<U;i++)scanf(\"%d%d\",&ux[i],&uy[i]);\n\t\tfor(i=0;i<M;i++)scanf(\"%d%d\",&mx[i],&my[i]);\n\t\tfor(i=0;i<S;i++)scanf(\"%d%d\",&sx[i],&sy[i]);\n\t\tfor(i=0;i<R;i++) {\n\t\t\tscanf(\"%d%d\",&w,&a);\n\t\t\tfor(j=0;j<H;j++) {\n\t\t\t\tif(isreach(housex[j],housey[j],w,a,du)) {\n\t\t\t\t\tok=1;\n\t\t\t\t\tfor(k=0;k<U;k++) {\n\t\t\t\t\t\tif(isreach(housex[j]-ux[k],housey[j]-uy[k],w,a,du)) {\n\t\t\t\t\t\t\tok=0;\n\t\t\t\t\t\t\tbreak;\n\t\t\t\t\t\t}\n\t\t\t\t\t}\n\t\t\t\t\tif(ok) {\n\t\t\t\t\t\tfor(k=0;k<M;k++) {\n\t\t\t\t\t\t\tif(isreach(housex[j]-mx[k],housey[j]-my[k],w,a,dm)) {\n\t\t\t\t\t\t\t\tok=0;\n\t\t\t\t\t\t\t\tbreak;\n\t\t\t\t\t\t\t}\n\t\t\t\t\t\t}\n\t\t\t\t\t}\n\t\t\t\t\tif(ok) {\n\t\t\t\t\t\tfor(k=0;k<S;k++) {\n\t\t\t\t\t\t\tif(isreach(housex[j]-sx[k],housey[j]-sy[k],w,a,ds)) {\n\t\t\t\t\t\t\t\tok=0;\n\t\t\t\t\t\t\t\tbreak;\n\t\t\t\t\t\t\t}\n\t\t\t\t\t\t}\n\t\t\t\t\t}\n\t\t\t\t\tif(ok)houseok[j]++;\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t\tmax=0;\n\t\tfor(i=0;i<H;i++) {\n\t\t\tif(houseok[i]>max)max=houseok[i];\n\t\t}\n\t\tif(max==0)puts(\"NA\");\n\t\telse {\n\t\t\tok=0;\n\t\t\tfor(i=0;i<H;i++) {\n\t\t\t\tif(houseok[i]==max) {\n\t\t\t\t\tif(ok)putchar(' ');\n\t\t\t\t\tprintf(\"%d\",i+1);\n\t\t\t\t\tok=1;\n\t\t\t\t}\n\t\t\t}\n\t\t\tputchar('\\n');\n\t\t}\n\t}\n\treturn 0;\n}"
  },
  {
    "language": "C",
    "code": "#include <stdio.h>\n#include <stdlib.h>\n#include <sys/types.h>\n#include <math.h>\n\n/* constant */\n\n#define MAX_N   (100)\n#define MAX_T   (10)\n\n#define EPS     ((double)1.0e-9)\n\n/* typedef */\n\ntypedef struct _pt_t {\n  double x, y;\n} pt_t;\n\ntypedef struct _wind_t {\n  int w, a;\n} wind_t;\n\n/* global variables */\n\nstatic pt_t houses[MAX_N];\nstatic wind_t winds[MAX_N];\n\nstatic pt_t ume[MAX_T], momo[MAX_T], sakura[MAX_T];\nstatic pt_t origin = {0, 0};\n\nstatic int max_houses[MAX_N];\n\n/* subroutines */\n\ndouble dist2(pt_t *p0, pt_t *p1) {\n  double dx = p1->x - p0->x;\n  double dy = p1->y - p0->y;\n  return (dx * dx + dy * dy);\n}\n\ndouble o_prod(pt_t *v0, pt_t *v1) {\n  return (v0->x * v1->y - v0->y * v1->x);\n}\n\nint deg_inside(pt_t *p0, pt_t *p1, double d0, double d1) {\n  double rad0, rad1;\n  pt_t dv0, dv1, pv;\n\n  rad0 = d0 * M_PI / 180;\n  rad1 = d1 * M_PI / 180;\n\n  dv0.x = cos(rad0);\n  dv0.y = sin(rad0);\n  dv1.x = cos(rad1);\n  dv1.y = sin(rad1);\n\n  pv.x = p1->x - p0->x;\n  pv.y = p1->y - p0->y;\n\n  return (o_prod(&dv0, &pv) > 0.0 && o_prod(&dv1, &pv) < 0.0);\n}\n\nint reach(pt_t *src, pt_t *h, wind_t *w, int d) {\n  return\n    (dist2(src, h) <= (w->a * w->a + EPS) &&\n     deg_inside(src, h, w->w - 0.5 * d, w->w + 0.5 * d));\n}\n\n\n/* main */\n\nint main(int argc, char **argv) {\n  int i, j, k, hn, rn, un, mn, sn, du, dm, ds;\n  int days, max_days, max_hn;\n  pt_t *hpt, *upt, *mpt, *spt;\n  wind_t *wpt;\n\n  for(;;) {\n    scanf(\"%d%d\", &hn, &rn);\n    if (hn == 0 && rn == 0) break;\n\n    for (i = 0; i < hn; i++)\n      scanf(\"%lf%lf\", &(houses[i].x), &(houses[i].y));\n\n    scanf(\"%d%d%d%d%d%d\", &un, &mn, &sn, &du, &dm, &ds);\n\n    for (i = 0; i < un; i++)\n      scanf(\"%lf%lf\", &(ume[i].x), &(ume[i].y));\n    for (i = 0; i < mn; i++)\n      scanf(\"%lf%lf\", &(momo[i].x), &(momo[i].y));\n    for (i = 0; i < sn; i++)\n      scanf(\"%lf%lf\", &(sakura[i].x), &(sakura[i].y));\n\n    for (i = 0; i < rn; i++)\n      scanf(\"%d%d\", &(winds[i].w), &(winds[i].a));\n\n    max_days = 0;\n    max_hn = 0;\n\n    for (i = 0; i < hn; i++) {\n      hpt = &(houses[i]);\n      days = 0;\n\n      for (j = 0; j < rn; j++) {\n        wpt = &(winds[j]);\n\n        if (reach(&origin, hpt, wpt, du)) {\n          int ok = 1;\n\n          for (k = 0; k < un; k++)\n            if (reach(&(ume[k]), hpt, wpt, du)) {\n              ok = 0;\n              break;\n            }\n          if (! ok) break;\n\n          for (k = 0; k < mn; k++)\n            if (reach(&(momo[k]), hpt, wpt, dm)) {\n              ok = 0;\n              break;\n            }\n          if (! ok) break;\n\n          for (k = 0; k < sn; k++)\n            if (reach(&(sakura[k]), hpt, wpt, ds)) {\n              ok = 0;\n              break;\n            }\n          if (! ok) break;\n\n          days++;\n        }\n      }\n\n      /*printf(\"i=%d, days=%d\\n\", i, days);*/\n\n      if (max_days < days) {\n        max_days = days;\n        max_hn = 1;\n        max_houses[0] = i + 1;\n      }\n      else if (max_days == days) {\n        max_houses[max_hn++] = i + 1;\n      }\n    }\n\n    if (max_days == 0)\n      puts(\"NA\");\n    else {\n      for (i = 0; i < max_hn; i++) {\n        if (i > 0) putchar(' ');\n        printf(\"%d\", max_houses[i]);\n      }\n      putchar('\\n');\n    }\n  }\n\n  return 0;\n}"
  },
  {
    "language": "C",
    "code": "// Aizu 0269: East Wind\n// 2017.9.12 bal4u@uu\n\n#include <stdio.h>\n#include <string.h>\n#include <math.h>\n\n#define PI  3.1415926535897932384626433832795\n\ntypedef struct { int x, y; } POS;\nPOS tree[3][13]; int u[3], du[3];\n\ntypedef struct { int x, y, c, f; } HOME;\nHOME home[103]; int h;\n\ntypedef struct { int w, a; } WIND;\nWIND wind[102]; int r;\n\nint reach(int x, int y, int x0, int y0, int w, int a, int d)\n{\n\tdouble xx, yy, r, angle, ww1, ww2;\n\tif (x == x0 && y == y0) return 1; \n\txx = x - x0, yy = y - y0, r = sqrt(xx*xx + yy*yy), angle = atan2(yy, xx);\n\tww1 = PI*(w - 0.5*d)/180.0, ww2 = PI*(w + 0.5*d)/180.0;\n\tif (r <= a) {\n\t\tif (ww1 <= angle && angle <= ww2) return 1; \n\t\tangle += 2*PI;\n\t\tif (ww1 <= angle && angle <= ww2) return 1; \n\t}\n\treturn 0;\n}\n\nint main()\n{\n\tint i, j, k, m, max;\n\n\twhile (scanf(\"%d%d\", &h, &r) && h) {\n\t\tfor (i = 0; i < h; i++) scanf(\"%d%d\", &home[i].x, &home[i].y), home[i].f = 1, home[i].c = 0;\n\t\tfor (i = 0; i < 3; i++) scanf(\"%d\", u+i);\n\t\tfor (i = 0; i < 3; i++) scanf(\"%d\", du+i);\n\t\tfor (j = 0; j < 3; j++) for (i = 0; i < u[j]; i++)\n\t\t\tscanf(\"%d%d\", &tree[j][i].x, &tree[j][i].y);\n\t\tfor (i = 0; i < r; i++) scanf(\"%d%d\", &wind[i].w, &wind[i].a);\n\n\t\tfor (k = 0; k < r; k++) for (j = 0; j < 3; j++) for (m = 0; m < u[j]; m++) for (i = 0; i < h; i++) if (home[i].f) {\n\t\t\tif (reach(home[i].x, home[i].y, tree[j][m].x, tree[j][m].y, wind[k].w, wind[k].a, du[j])) home[i].f = 0;\n\t\t}\n\n\t\tfor (k = 0; k < r; k++) for (i = 0; i < h; i++) if (home[i].f) {\n\t\t\tif (reach(home[i].x, home[i].y, 0, 0, wind[k].w, wind[k].a, du[0])) home[i].c++;\n\t\t}\n\t\tfor (max = 0, i = 0; i < h; i++) if (home[i].f) {\n\t\t\tif (home[i].c > max) max = home[i].c; \n\t\t}\n\t\tif (max == 0) puts(\"NA\");\n\t\telse {\n\t\t\tfor (k = 1, i = 0; i < h; i++) if (home[i].f) {\n\t\t\t\tif (home[i].c < max) continue;\n\t\t\t\tif (k) k = 0; else putchar(' ');\n\t\t\t\tprintf(\"%d\", i+1);\n\t\t\t}\n\t\t\tputchar('\\n');\n\t\t}\n\t}\n\treturn 0;\n}"
  },
  {
    "language": "C",
    "code": "#include <stdio.h>\n#include <stdlib.h>\n#include <sys/types.h>\n#include <math.h>\n\n/* constant */\n\n#define MAX_N   (100)\n#define MAX_T   (10)\n\n#define EPS     ((double)1.0e-3)\n\n/* typedef */\n\ntypedef struct _pt_t {\n  double x, y;\n} pt_t;\n\ntypedef struct _wind_t {\n  int w, a;\n} wind_t;\n\n/* global variables */\n\nstatic pt_t houses[MAX_N];\nstatic wind_t winds[MAX_N];\n\nstatic pt_t ume[MAX_T], momo[MAX_T], sakura[MAX_T];\nstatic pt_t origin = {0, 0};\n\nstatic int max_houses[MAX_N];\n\n/* subroutines */\n\ndouble dist2(pt_t *p0, pt_t *p1) {\n  double dx = p1->x - p0->x;\n  double dy = p1->y - p0->y;\n  return (dx * dx + dy * dy);\n}\n\ndouble o_prod(pt_t *v0, pt_t *v1) {\n  return (v0->x * v1->y - v0->y * v1->x);\n}\n\nint deg_inside(pt_t *p0, pt_t *p1, double d0, double d1) {\n  double rad0, rad1;\n  pt_t dv0, dv1, pv;\n\n  rad0 = d0 * M_PI / 180;\n  rad1 = d1 * M_PI / 180;\n\n  dv0.x = cos(rad0);\n  dv0.y = sin(rad0);\n  dv1.x = cos(rad1);\n  dv1.y = sin(rad1);\n\n  pv.x = p1->x - p0->x;\n  pv.y = p1->y - p0->y;\n\n  return (o_prod(&dv0, &pv) >= -EPS && o_prod(&dv1, &pv) <= EPS);\n}\n\nint reach(pt_t *src, pt_t *h, wind_t *w, int d) {\n  return\n    (dist2(src, h) <= (EPS + w->a) * (EPS + w->a) &&\n     deg_inside(src, h, w->w - 0.5 * d, w->w + 0.5 * d));\n}\n\n\n/* main */\n\nint main(int argc, char **argv) {\n  int i, j, k, hn, rn, un, mn, sn, du, dm, ds;\n  int days, max_days, max_hn;\n  pt_t *hpt, *upt, *mpt, *spt;\n  wind_t *wpt;\n\n  for(;;) {\n    scanf(\"%d%d\", &hn, &rn);\n    if (hn == 0 && rn == 0) break;\n\n    for (i = 0; i < hn; i++)\n      scanf(\"%lf%lf\", &(houses[i].x), &(houses[i].y));\n\n    scanf(\"%d%d%d%d%d%d\", &un, &mn, &sn, &du, &dm, &ds);\n\n    for (i = 0; i < un; i++)\n      scanf(\"%lf%lf\", &(ume[i].x), &(ume[i].y));\n    for (i = 0; i < mn; i++)\n      scanf(\"%lf%lf\", &(momo[i].x), &(momo[i].y));\n    for (i = 0; i < sn; i++)\n      scanf(\"%lf%lf\", &(sakura[i].x), &(sakura[i].y));\n\n    for (i = 0; i < rn; i++)\n      scanf(\"%d%d\", &(winds[i].w), &(winds[i].a));\n\n    max_days = 0;\n    max_hn = 0;\n\n    for (i = 0; i < hn; i++) {\n      hpt = &(houses[i]);\n      days = 0;\n\n      for (j = 0; j < rn; j++) {\n        wpt = &(winds[j]);\n\n        if (reach(&origin, hpt, wpt, du)) {\n          int ok = 1;\n\n          for (k = 0; k < un; k++)\n            if (reach(&(ume[k]), hpt, wpt, du)) {\n              ok = 0;\n              break;\n            }\n          if (! ok) break;\n\n          for (k = 0; k < mn; k++)\n            if (reach(&(momo[k]), hpt, wpt, dm)) {\n              ok = 0;\n              break;\n            }\n          if (! ok) break;\n\n          for (k = 0; k < sn; k++)\n            if (reach(&(sakura[k]), hpt, wpt, ds)) {\n              ok = 0;\n              break;\n            }\n          if (! ok) break;\n\n          days++;\n        }\n      }\n\n      /*printf(\"i=%d, days=%d\\n\", i, days);*/\n\n      if (max_days < days) {\n        max_days = days;\n        max_hn = 1;\n        max_houses[0] = i + 1;\n      }\n      else if (max_days == days) {\n        max_houses[max_hn++] = i + 1;\n      }\n    }\n\n    if (max_days == 0)\n      puts(\"NA\");\n    else {\n      for (i = 0; i < max_hn; i++) {\n        if (i > 0) putchar(' ');\n        printf(\"%d\", max_houses[i]);\n      }\n      putchar('\\n');\n    }\n  }\n\n  return 0;\n}"
  },
  {
    "language": "C",
    "code": "#include <stdio.h>\n#include <stdlib.h>\n#include <sys/types.h>\n#include <math.h>\n\n/* constant */\n\n#define MAX_N   (100)\n#define MAX_T   (10)\n\n/* typedef */\n\ntypedef struct _pt_t {\n  double x, y;\n} pt_t;\n\ntypedef struct _wind_t {\n  int w, a;\n} wind_t;\n\n/* global variables */\n\nstatic pt_t houses[MAX_N];\nstatic wind_t winds[MAX_N];\n\nstatic pt_t ume[MAX_T], momo[MAX_T], sakura[MAX_T];\nstatic pt_t origin = {0, 0};\n\nstatic int max_houses[MAX_N];\n\n/* subroutines */\n\ndouble dist2(pt_t *p0, pt_t *p1) {\n  double dx = p1->x - p0->x;\n  double dy = p1->y - p0->y;\n  return (dx * dx + dy * dy);\n}\n\ndouble o_prod(pt_t *v0, pt_t *v1) {\n  return (v0->x * v1->y - v0->y * v1->x);\n}\n\nint deg_inside(pt_t *p0, pt_t *p1, double d0, double d1) {\n  double rad0, rad1;\n  pt_t dv0, dv1, pv;\n\n  rad0 = d0 * M_PI / 180;\n  rad1 = d1 * M_PI / 180;\n\n  dv0.x = cos(rad0);\n  dv0.y = sin(rad0);\n  dv1.x = cos(rad1);\n  dv1.y = sin(rad1);\n\n  pv.x = p1->x - p0->x;\n  pv.y = p1->y - p0->y;\n\n  return (o_prod(&dv0, &pv) >= 0.0 && o_prod(&dv1, &pv) <= 0.0);\n}\n\nint reach(pt_t *src, pt_t *h, wind_t *w, int d) {\n  return\n    (dist2(src, h) <= (w->a * w->a) &&\n     deg_inside(src, h, w->w - 0.5 * d, w->w + 0.5 * d));\n}\n\n\n/* main */\n\nint main(int argc, char **argv) {\n  int i, j, k, hn, rn, un, mn, sn, du, dm, ds;\n  int days, max_days, max_hn;\n  pt_t *hpt, *upt, *mpt, *spt;\n  wind_t *wpt;\n\n  for(;;) {\n    scanf(\"%d%d\", &hn, &rn);\n    if (hn == 0 && rn == 0) break;\n\n    for (i = 0; i < hn; i++)\n      scanf(\"%lf%lf\", &(houses[i].x), &(houses[i].y));\n\n    scanf(\"%d%d%d%d%d%d\", &un, &mn, &sn, &du, &dm, &ds);\n\n    for (i = 0; i < un; i++)\n      scanf(\"%lf%lf\", &(ume[i].x), &(ume[i].y));\n    for (i = 0; i < mn; i++)\n      scanf(\"%lf%lf\", &(momo[i].x), &(momo[i].y));\n    for (i = 0; i < sn; i++)\n      scanf(\"%lf%lf\", &(sakura[i].x), &(sakura[i].y));\n\n    for (i = 0; i < rn; i++)\n      scanf(\"%d%d\", &(winds[i].w), &(winds[i].a));\n\n    max_days = 0;\n    max_hn = 0;\n\n    for (i = 0; i < hn; i++) {\n      hpt = &(houses[i]);\n      days = 0;\n\n      for (j = 0; j < rn; j++) {\n        wpt = &(winds[j]);\n\n        if (reach(&origin, hpt, wpt, du)) {\n          int ok = 1;\n\n          for (k = 0; k < un; k++)\n            if (reach(&(ume[k]), hpt, wpt, du)) {\n              ok = 0;\n              break;\n            }\n          if (! ok) break;\n\n          for (k = 0; k < mn; k++)\n            if (reach(&(momo[k]), hpt, wpt, dm)) {\n              ok = 0;\n              break;\n            }\n          if (! ok) break;\n\n          for (k = 0; k < sn; k++)\n            if (reach(&(sakura[k]), hpt, wpt, ds)) {\n              ok = 0;\n              break;\n            }\n          if (! ok) break;\n\n          days++;\n        }\n      }\n\n      /*printf(\"i=%d, days=%d\\n\", i, days);*/\n\n      if (max_days < days) {\n        max_days = days;\n        max_hn = 1;\n        max_houses[0] = i + 1;\n      }\n      else if (max_days == days) {\n        max_houses[max_hn++] = i + 1;\n      }\n    }\n\n    if (max_days == 0)\n      puts(\"NA\");\n    else {\n      for (i = 0; i < max_hn; i++) {\n        if (i > 0) putchar(' ');\n        printf(\"%d\", max_houses[i]);\n      }\n      putchar('\\n');\n    }\n  }\n\n  return 0;\n}"
  },
  {
    "language": "C",
    "code": "// Aizu 0269: East Wind\n// 2017.9.12 bal4u@uu\n\n#include <stdio.h>\n#include <string.h>\n#include <math.h>\n\n#define EPS 0.00001\n#define PI 3.1415926535897932384626433832795\n\ntypedef struct { int x, y; } POS;\nPOS tree[3][13]; int u[3], du[3];\n\ntypedef struct { int x, y, c, f; } HOME;\nHOME home[103]; int h;\n\ntypedef struct { int w, a; } WIND;\nWIND wind[102]; int r;\n\nint reach(int x, int y, int x0, int y0, int w, int a, int d)\n{\n\tdouble xx, yy, r, angle, ww1, ww2;\n\tif (x == x0 && y == y0) return 1; \n\txx = x - x0, yy = y - y0, r = sqrt(xx*xx + yy*yy);\n\tangle = atan2(yy, xx); if (fabs(angle) > EPS && angle <= 0.0) angle += PI*2;\n\tif (r-a > EPS && r > a) return 0;\n\tww1 = PI*(w - 0.5*d)/180.0, ww2 = PI*(w + 0.5*d)/180.0;\n\tif (fabs(angle-ww1) <= EPS || fabs(ww2-angle) <= EPS || (ww1 <= angle && angle <= ww2)) return 1; \n\tangle += PI*2;\n\tif (fabs(angle-ww1) <= EPS || fabs(ww2-angle) <= EPS || (ww1 <= angle && angle <= ww2)) return 1; \n\tangle -= PI*4;\n\tif (fabs(angle-ww1) <= EPS || fabs(ww2-angle) <= EPS || (ww1 <= angle && angle <= ww2)) return 1; \n\treturn 0;\n}\n\nint main()\n{\n\tint i, j, k, m, max;\n\n\twhile (scanf(\"%d%d\", &h, &r) && h) {\n\t\tfor (i = 0; i < h; i++) scanf(\"%d%d\", &home[i].x, &home[i].y), home[i].f = 1, home[i].c = 0;\n\t\tfor (i = 0; i < 3; i++) scanf(\"%d\", u+i);\n\t\tfor (i = 0; i < 3; i++) scanf(\"%d\", du+i);\n\t\tfor (j = 0; j < 3; j++) for (i = 0; i < u[j]; i++)\n\t\t\tscanf(\"%d%d\", &tree[j][i].x, &tree[j][i].y);\n\t\tfor (i = 0; i < r; i++) scanf(\"%d%d\", &wind[i].w, &wind[i].a);\n\n\t\tfor (k = 0; k < r; k++) for (j = 0; j < 3; j++) for (m = 0; m < u[j]; m++) for (i = 0; i < h; i++) if (home[i].f) {\n\t\t\tif (reach(home[i].x, home[i].y, tree[j][m].x, tree[j][m].y, wind[k].w, wind[k].a, du[j])) home[i].f = 0;\n\t\t}\n\n\t\tfor (k = 0; k < r; k++) for (i = 0; i < h; i++) if (home[i].f) {\n\t\t\tif (reach(home[i].x, home[i].y, 0, 0, wind[k].w, wind[k].a, du[0])) home[i].c++;\n\t\t}\n\t\tfor (max = 0, i = 0; i < h; i++) if (home[i].f) {\n\t\t\tif (home[i].c > max) max = home[i].c; \n\t\t}\n\t\tif (max == 0) puts(\"NA\");\n\t\telse {\n\t\t\tfor (k = 1, i = 0; i < h; i++) if (home[i].f) {\n\t\t\t\tif (home[i].c < max) continue;\n\t\t\t\tif (k) k = 0; else putchar(' ');\n\t\t\t\tprintf(\"%d\", i+1);\n\t\t\t}\n\t\t\tputchar('\\n');\n\t\t}\n\t}\n\treturn 0;\n}"
  },
  {
    "language": "C",
    "code": "#include <stdio.h>\n#include <stdlib.h>\n#include <sys/types.h>\n#include <math.h>\n\n/* constant */\n\n#define MAX_N   (100)\n#define MAX_T   (10)\n\n#define EPS     ((double)1.0e-9)\n\n/* typedef */\n\ntypedef struct _pt_t {\n  double x, y;\n} pt_t;\n\ntypedef struct _wind_t {\n  int w, a;\n} wind_t;\n\n/* global variables */\n\nstatic pt_t houses[MAX_N];\nstatic wind_t winds[MAX_N];\n\nstatic pt_t ume[MAX_T], momo[MAX_T], sakura[MAX_T];\nstatic pt_t origin = {0, 0};\n\nstatic int max_houses[MAX_N];\n\n/* subroutines */\n\ndouble dist2(pt_t *p0, pt_t *p1) {\n  double dx = p1->x - p0->x;\n  double dy = p1->y - p0->y;\n  return (dx * dx + dy * dy);\n}\n\ndouble o_prod(pt_t *v0, pt_t *v1) {\n  return (v0->x * v1->y - v0->y * v1->x);\n}\n\nint deg_inside(pt_t *p0, pt_t *p1, double d0, double d1) {\n  double rad0, rad1;\n  pt_t dv0, dv1, pv;\n\n  rad0 = d0 * M_PI / 180;\n  rad1 = d1 * M_PI / 180;\n\n  dv0.x = cos(rad0);\n  dv0.y = sin(rad0);\n  dv1.x = cos(rad1);\n  dv1.y = sin(rad1);\n\n  pv.x = p1->x - p0->x;\n  pv.y = p1->y - p0->y;\n\n  return (o_prod(&dv0, &pv) >= -EPS && o_prod(&dv1, &pv) <= EPS);\n}\n\nint reach(pt_t *src, pt_t *h, wind_t *w, int d) {\n  return\n    (dist2(src, h) <= (EPS + w->a * w->a) &&\n     deg_inside(src, h, w->w - 0.5 * d, w->w + 0.5 * d));\n}\n\n\n/* main */\n\nint main(int argc, char **argv) {\n  int i, j, k, hn, rn, un, mn, sn, du, dm, ds;\n  int days, max_days, max_hn;\n  pt_t *hpt, *upt, *mpt, *spt;\n  wind_t *wpt;\n\n  for(;;) {\n    scanf(\"%d%d\", &hn, &rn);\n    if (hn == 0 && rn == 0) break;\n\n    for (i = 0; i < hn; i++)\n      scanf(\"%lf%lf\", &(houses[i].x), &(houses[i].y));\n\n    scanf(\"%d%d%d%d%d%d\", &un, &mn, &sn, &du, &dm, &ds);\n\n    for (i = 0; i < un; i++)\n      scanf(\"%lf%lf\", &(ume[i].x), &(ume[i].y));\n    for (i = 0; i < mn; i++)\n      scanf(\"%lf%lf\", &(momo[i].x), &(momo[i].y));\n    for (i = 0; i < sn; i++)\n      scanf(\"%lf%lf\", &(sakura[i].x), &(sakura[i].y));\n\n    for (i = 0; i < rn; i++)\n      scanf(\"%d%d\", &(winds[i].w), &(winds[i].a));\n\n    max_days = 0;\n    max_hn = 0;\n\n    for (i = 0; i < hn; i++) {\n      hpt = &(houses[i]);\n      days = 0;\n\n      for (j = 0; j < rn; j++) {\n        wpt = &(winds[j]);\n\n        if (reach(&origin, hpt, wpt, du)) {\n          int ok = 1;\n\n          for (k = 0; k < un; k++)\n            if (reach(&(ume[k]), hpt, wpt, du)) {\n              ok = 0;\n              break;\n            }\n          if (! ok) break;\n\n          for (k = 0; k < mn; k++)\n            if (reach(&(momo[k]), hpt, wpt, dm)) {\n              ok = 0;\n              break;\n            }\n          if (! ok) break;\n\n          for (k = 0; k < sn; k++)\n            if (reach(&(sakura[k]), hpt, wpt, ds)) {\n              ok = 0;\n              break;\n            }\n          if (! ok) break;\n\n          days++;\n        }\n      }\n\n      /*printf(\"i=%d, days=%d\\n\", i, days);*/\n\n      if (max_days < days) {\n        max_days = days;\n        max_hn = 1;\n        max_houses[0] = i + 1;\n      }\n      else if (max_days == days) {\n        max_houses[max_hn++] = i + 1;\n      }\n    }\n\n    if (max_days == 0)\n      puts(\"NA\");\n    else {\n      for (i = 0; i < max_hn; i++) {\n        if (i > 0) putchar(' ');\n        printf(\"%d\", max_houses[i]);\n      }\n      putchar('\\n');\n    }\n  }\n\n  return 0;\n}"
  },
  {
    "language": "C",
    "code": "// Aizu 0269: East Wind\n// 2017.9.12 bal4u@uu\n\n#include <stdio.h>\n#include <string.h>\n#include <math.h>\n\n#define EPS 0.00001\n#define PI 3.1415926535897932384626433832795\n\ntypedef struct { int x, y; } POS;\nPOS tree[3][13]; int u[3], du[3];\n\ntypedef struct { int x, y, c, f; } HOME;\nHOME home[103]; int h;\n\ntypedef struct { int w, a; } WIND;\nWIND wind[102]; int r;\n\nint reach(int x, int y, int x0, int y0, int w, int a, int d)\n{\n\tdouble xx, yy, r, angle, ww1, ww2;\n\tif (x == x0 && y == y0) return 1; \n\txx = x - x0, yy = y - y0, angle = atan2(yy, xx), r = sqrt(xx*xx + yy*yy);\n\tif (fabs(r-a) >= EPS && r >= a) return 0;\n\tww1 = PI*(w - 0.5*d)/180.0, ww2 = PI*(w + 0.5*d)/180.0;\n\tif (fabs(angle-ww1) <= EPS || fabs(ww2-angle) <= EPS || (ww1 <= angle && angle <= ww2)) return 1; \n\treturn 0;\n}\n\nint main()\n{\n\tint i, j, k, m, max;\n\n\twhile (scanf(\"%d%d\", &h, &r) && h) {\n\t\tfor (i = 0; i < h; i++) scanf(\"%d%d\", &home[i].x, &home[i].y), home[i].f = 1, home[i].c = 0;\n\t\tfor (i = 0; i < 3; i++) scanf(\"%d\", u+i);\n\t\tfor (i = 0; i < 3; i++) scanf(\"%d\", du+i);\n\t\tfor (j = 0; j < 3; j++) for (i = 0; i < u[j]; i++)\n\t\t\tscanf(\"%d%d\", &tree[j][i].x, &tree[j][i].y);\n\t\tfor (i = 0; i < r; i++) scanf(\"%d%d\", &wind[i].w, &wind[i].a);\n\n\t\tfor (k = 0; k < r; k++) for (j = 0; j < 3; j++) for (m = 0; m < u[j]; m++) for (i = 0; i < h; i++) if (home[i].f) {\n\t\t\tif (reach(home[i].x, home[i].y, tree[j][m].x, tree[j][m].y, wind[k].w, wind[k].a, du[j])) home[i].f = 0;\n\t\t}\n\n\t\tfor (k = 0; k < r; k++) for (i = 0; i < h; i++) if (home[i].f) {\n\t\t\tif (reach(home[i].x, home[i].y, 0, 0, wind[k].w, wind[k].a, du[0])) home[i].c++;\n\t\t}\n\t\tfor (max = 0, i = 0; i < h; i++) if (home[i].f) {\n\t\t\tif (home[i].c > max) max = home[i].c; \n\t\t}\n\t\tif (max == 0) puts(\"NA\");\n\t\telse {\n\t\t\tfor (k = 1, i = 0; i < h; i++) if (home[i].f) {\n\t\t\t\tif (home[i].c < max) continue;\n\t\t\t\tif (k) k = 0; else putchar(' ');\n\t\t\t\tprintf(\"%d\", i+1);\n\t\t\t}\n\t\t\tputchar('\\n');\n\t\t}\n\t}\n\treturn 0;\n}"
  },
  {
    "language": "C",
    "code": "// Aizu 0269: East Wind\n// 2017.9.12 bal4u@uu\n\n#include <stdio.h>\n#include <string.h>\n#include <math.h>\n\n#define PI  3.1415926535897932384626433832795\n\ntypedef struct { int x, y; } POS;\nPOS tree[3][13]; int u[3], d[3];\n\ntypedef struct { int x, y, c; } HOME;\nHOME home[103]; int h;\n\ntypedef struct { int w, a; } WIND;\nWIND wind[102]; int r;\n\nint reach(int x, int y, int x0, int y0, int w, int a, int d)\n{\n\tdouble xx, yy, r, angle, ww1, ww2;\n\tif (x == x0 && y == y0) return 1; \n\txx = x - x0, yy = y - y0, r = sqrt(xx*xx + yy*yy), angle = atan2(yy, xx);\n\tww1 = PI*(w - 0.5*d)/180.0, ww2 = PI*(w + 0.5*d)/180.0;\n\tif (r <= a) {\n\t\tif (ww1 <= angle && angle <= ww2) return 1; \n\t\tangle += 2*PI;\n\t\tif (ww1 <= angle && angle <= ww2) return 1; \n\t}\n\treturn 0;\n}\n\nint main()\n{\n\tint i, j, k, m, max;\n\n\twhile (scanf(\"%d%d\", &h, &r) && h) {\n\t\tfor (i = 0; i < h; i++) scanf(\"%d%d\", &home[i].x, &home[i].y), home[i].c = 0;\n\t\tfor (i = 0; i < 3; i++) scanf(\"%d\", u+i);\n\t\tfor (i = 0; i < 3; i++) scanf(\"%d\", d+i);\n\t\tfor (j = 0; j < 3; j++) for (i = 0; i < u[j]; i++)\n\t\t\tscanf(\"%d%d\", &tree[j][i].x, &tree[j][i].y);\n\t\tfor (i = 0; i < r; i++) scanf(\"%d%d\", &wind[i].w, &wind[i].a);\n\n\t\tfor (k = 0; k < r; k++) for (i = 0; i < h; i++) {\n\t\t\tfor (j = 0; j < 3; j++) for (m = 0; m < u[j]; m++) {\n\t\t\t\tif (reach(home[i].x, home[i].y, tree[j][m].x, tree[j][m].y, wind[k].w, wind[k].a, d[j])) goto Next;\n\t\t\t}\n\t\t\tif (reach(home[i].x, home[i].y, 0, 0, wind[k].w, wind[k].a, d[0])) home[i].c++;\n\t\t\tNext:;\n\t\t}\n\t\tfor (max = 0, i = 0; i < h; i++) if (home[i].c > max) max = home[i].c; \n\t\tif (max == 0) puts(\"NA\");\n\t\telse {\n\t\t\tfor (k = 1, i = 0; i < h; i++) {\n\t\t\t\tif (home[i].c != max) continue;\n\t\t\t\tif (k) k = 0; else putchar(' ');\n\t\t\t\tprintf(\"%d\", i+1);\n\t\t\t}\n\t\t\tputchar('\\n');\n\t\t}\n\t}\n\treturn 0;\n}"
  },
  {
    "language": "Java",
    "code": "import java.util.*;\npublic class Main {\n\t\n\tpublic static void main(String[] args) {\n\t\tScanner stdIn = new Scanner(System.in);\n\t\twhile(true) {\n\t\t\tint H = stdIn.nextInt();\n\t\t\tint R = stdIn.nextInt();\n\t\t\t\n\t\t\tif(H == 0 && R == 0) {\n\t\t\t\tbreak;\n\t\t\t}\n\t\t\t\n\t\t\tint[] hx = new int[H];\n\t\t\tint[] hy = new int[H];\n\t\t\tfor(int i = 0; i < H; i++) {\n\t\t\t\thx[i] = stdIn.nextInt();\n\t\t\t\thy[i] = stdIn.nextInt();\n\t\t\t}\n\t\t\t\n\t\t\tint U = stdIn.nextInt();\n\t\t\tint M = stdIn.nextInt();\n\t\t\tint S = stdIn.nextInt();\n\t\t\tint du = stdIn.nextInt();\n\t\t\tint dm = stdIn.nextInt();\n\t\t\tint ds = stdIn.nextInt();\n\t\t\t\n\t\t\tint[] ux = new int[U];\n\t\t\tint[] uy = new int[U];\n\t\t\tfor(int i = 0; i < U; i++) {\n\t\t\t\tux[i] = stdIn.nextInt();\n\t\t\t\tuy[i] = stdIn.nextInt();\n\t\t\t}\n\t\t\t\n\t\t\tint[] mx = new int[M];\n\t\t\tint[] my = new int[M];\n\t\t\tfor(int i = 0; i < M; i++) {\n\t\t\t\tmx[i] = stdIn.nextInt();\n\t\t\t\tmy[i] = stdIn.nextInt();\n\t\t\t}\n\t\t\t\n\t\t\tint[] sx = new int[S];\n\t\t\tint[] sy = new int[S];\n\t\t\t\n\t\t\tfor(int i = 0; i < S; i++) {\n\t\t\t\tsx[i] = stdIn.nextInt();\n\t\t\t\tsy[i] = stdIn.nextInt();\n\t\t\t}\n\t\t\t\n\t\t\tint[] w = new int[R];\n\t\t\tint[] a = new int[R];\n\t\t\tfor(int i = 0; i < R; i++) {\n\t\t\t\tw[i] = stdIn.nextInt();\n\t\t\t\ta[i] = stdIn.nextInt();\n\t\t\t}\n\t\t\t\n\t\t\t//---処理ここから---//\n\t\t\tint[] day = new int[H];\n\t\t\tfor(int i = 0; i < R; i++) { //風\n\t\t\t\tIN:for(int j = 0; j < H; j++) { //家\n\t\t\t\t\t//---私の桜が届くか---//\n\t\t\t\t\tif(!ReachWind(0,0,hx[j],hy[j],w[i],du,a[i])) {\n\t\t\t\t\t\tcontinue;\n\t\t\t\t\t}\n\t\t\t\t\t//---梅---//\n\t\t\t\t\tfor(int k = 0; k < U; k++) {\n\t\t\t\t\t\tif(ReachWind(ux[k],uy[k],hx[j],hy[j],w[i],du,a[i])) {\n\t\t\t\t\t\t\tcontinue IN;\n\t\t\t\t\t\t}\n\t\t\t\t\t}\n\t\t\t\t\t//---桃---//\n\t\t\t\t\tfor(int k = 0; k < M; k++) {\n\t\t\t\t\t\tif(ReachWind(mx[k],my[k],hx[j],hy[j],w[i],dm,a[i])) {\n\t\t\t\t\t\t\tcontinue IN;\n\t\t\t\t\t\t}\n\t\t\t\t\t}\n\t\t\t\t\t//---桜---//\n\t\t\t\t\tfor(int k = 0; k < S; k++) {\n\t\t\t\t\t\tif(ReachWind(sx[k],sy[k],hx[j],hy[j],w[i],ds,a[i])) {\n\t\t\t\t\t\t\tcontinue IN;\n\t\t\t\t\t\t}\n\t\t\t\t\t}\n\t\t\t\t\tday[j]++;\n\t\t\t\t\t\n\t\t\t\t\t\n\t\t\t\t\t\n\t\t\t\t\t\n\t\t\t\t}\n\t\t\t}\n\t\t\tint max = 0;\n\t\t\tfor(int i = 0; i < H; i++) {\n\t\t\t\tif(max < day[i]) {\n\t\t\t\t\tmax = day[i];\n\t\t\t\t}\n\t\t\t}\n\t\t\tif(max != 0) {\n\t\t\t\tboolean tmp = false;\n\t\t\t\tfor(int i = 0; i < H; i++) {\n\t\t\t\t\tif(!tmp && max == day[i]) {\n\t\t\t\t\t\tSystem.out.print((i + 1));\n\t\t\t\t\t\ttmp = true;\n\t\t\t\t\t}\n\t\t\t\t\telse if(max == day[i]) {\n\t\t\t\t\t\tSystem.out.print(\" \" + (i+1));\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t\tSystem.out.println();\n\t\t\t}\n\t\t\telse {\n\t\t\t\tSystem.out.println(\"NA\");\n\t\t\t}\n\t\t}\n\t}\n\t\n\tpublic static boolean ReachWind(int x0, int y0, int x1, int y1, int w, int d, int a) {\n\t\t//---長さ---//\n\t\tif(Math.sqrt((x0 - x1) * (x0 - x1) + (y0 - y1)*(y0 - y1)) > a) {\n\t\t\treturn false;\n\t\t}\n\t\t\n\t\t//---角度(x軸から何度か)---//\n\t\tint xlen = x1 - x0;\n\t\tint ylen = y1 - y0;\n\t\tdouble angle = Math.atan2(ylen, xlen);\n\t\tdouble ue = w + d/2.0;\n\t\tif(ue >= 360) {\n\t\t\tue -= 360;\n\t\t}\n\t\tif(ue > 180) {\n\t\t\tue = ue - 180;\n\t\t\tue *= -1;\n\t\t}\n\t\tif(ue <= -360) {\n\t\t\tue += 360;\n\t\t}\n\t\tif(ue < -180) {\n\t\t\tue = ue + 180;\n\t\t\tue *= -1;\n\t\t}\n\t\tue = Math.toRadians(ue);\n\t\tdouble shita = w - d/2.0;\n\t\tif(shita>= 360) {\n\t\t\tshita -= 360;\n\t\t}\n\t\tif(shita > 180) {\n\t\t\tshita = shita - 180;\n\t\t\tshita *= -1;\n\t\t}\n\t\tif(shita <= -360) {\n\t\t\tshita += 360;\n\t\t}\n\t\tif(shita < -180) {\n\t\t\tshita = shita + 180;\n\t\t\tshita *= -1;\n\t\t}\n\t\tshita = Math.toRadians(shita);\n\t\t\n\t\tif(angle >= shita && angle <= ue) {\n\t\t\treturn true;\n\t\t}\n\t\treturn false;\n\t\t\n\t}\n}"
  },
  {
    "language": "Java",
    "code": "\nimport java.util.*;\nimport java.io.*;\nimport java.math.BigDecimal;\nimport java.awt.geom.*;\nimport static java.util.Arrays.*;\n\nclass Main{\n\tpublic static void main(String[] args){\n\t\tScanner stdIn = new Scanner(System.in);\n\t\tPrintWriter out = new PrintWriter(System.out);\n\t\twhile(true){\n\t\t\tint H = Integer.parseInt(stdIn.next());\n\t\t\tint R = Integer.parseInt(stdIn.next());\n\t\t\tif(H==0 && R==0){\n\t\t\t\tbreak;\n\t\t\t}\n\t\t\tint[] hx = new int[H];\n\t\t\tint[] hy = new int[H];\n\t\t\tfor(int i=0;i<H;i++){\n\t\t\t\thx[i] = Integer.parseInt(stdIn.next());\n\t\t\t\thy[i] = Integer.parseInt(stdIn.next());\n\t\t\t}\n\t\t\tint U = Integer.parseInt(stdIn.next());\n\t\t\tint M = Integer.parseInt(stdIn.next());\n\t\t\tint S = Integer.parseInt(stdIn.next());\n\t\t\tint du = Integer.parseInt(stdIn.next());\n\t\t\tint dm = Integer.parseInt(stdIn.next());\n\t\t\tint ds = Integer.parseInt(stdIn.next());\n\t\t\tint[] ux = new int[U];\n\t\t\tint[] uy = new int[U];\n\t\t\tint[] mx = new int[M];\n\t\t\tint[] my = new int[M];\n\t\t\tint[] sx = new int[S];\n\t\t\tint[] sy = new int[S];\n\t\t\tfor(int i=0;i<U;i++){\n\t\t\t\tux[i] = Integer.parseInt(stdIn.next());\n\t\t\t\tuy[i] = Integer.parseInt(stdIn.next());\n\t\t\t}\n\t\t\tfor(int i=0;i<M;i++){\n\t\t\t\tmx[i] = Integer.parseInt(stdIn.next());\n\t\t\t\tmy[i] = Integer.parseInt(stdIn.next());\n\t\t\t}\n\t\t\tfor(int i=0;i<S;i++){\n\t\t\t\tsx[i] = Integer.parseInt(stdIn.next());\n\t\t\t\tsy[i] = Integer.parseInt(stdIn.next());\n\t\t\t}\n\t\t\tint[] w = new int[R];\n\t\t\tint[] a = new int[R];\n\t\t\tfor(int i=0;i<R;i++){\n\t\t\t\tw[i] = Integer.parseInt(stdIn.next());\n\t\t\t\ta[i] = Integer.parseInt(stdIn.next());\n\t\t\t}\n\n\t\t\tint[] Hcount = new int[H];\n\t\t\tint count_max = 0;\n\n\t\t\tfor(int i=0;i<H;i++){\n\t\t\t\tIN:for(int j=0;j<R;j++){\n\t\t\t\t\t\tif(!func(0,0,hx[i],hy[i],a[j],w[j],du)){\n\t\t\t\t\t\t\tcontinue;\n\t\t\t\t\t\t}\n\t\t\t\t\tfor(int k=0;k<U;k++){\n\t\t\t\t\t\tif(func(ux[k],uy[k],hx[i],hy[i],a[j],w[j],du)){\n\t\t\t\t\t\t\tcontinue IN;\n\t\t\t\t\t\t}\n\t\t\t\t\t}\n\t\t\t\t\tfor(int l=0;l<M;l++){\n\t\t\t\t\t\tif(func(mx[l],my[l],hx[i],hy[i],a[j],w[j],dm)){\n\t\t\t\t\t\t\tcontinue IN;\n\t\t\t\t\t\t}\n\t\t\t\t\t}\n\t\t\t\t\tfor(int m=0;m<S;m++){\n\t\t\t\t\t\tif(func(sx[m],sy[m],hx[i],hy[i],a[j],w[j],ds)){\n\t\t\t\t\t\t\tcontinue IN;\n\t\t\t\t\t\t}\n\t\t\t\t\t}\n\t\t\t\t\tHcount[i]++;\n\t\t\t\t\tout.println(j);\n\t\t\t\t\tout.flush();\n\t\t\t\t}\n\t\t\t\tif(count_max<Hcount[i]){\n\t\t\t\t\tcount_max = Hcount[i];\n\t\t\t\t}\n\t\t\t}\n\n\t\t\tif(count_max>0){\n\t\t\t\tfor(int i=0;i<H;i++){\n\t\t\t\t\t//out.print(Hcount[i]+\" \");\n\t\t\t\t\t//out.flush();\n\t\t\t\t\tif(Hcount[i] == count_max){\n\t\t\t\t\t\tout.print(i+1);\n\t\t\t\t\t\tif(i!=H-1){\n\t\t\t\t\t\t\tout.print(\" \");\n\t\t\t\t\t\t}\n\t\t\t\t\t\tout.flush();\n\t\t\t\t\t}\n\t\t\t\t\tif(i==H-1){\n\t\t\t\t\t\tout.println();\n\t\t\t\t\t\tout.flush();\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t}\n\t\t\telse{\n\t\t\t\tout.println(\"NA\");\n\t\t\t\tout.flush();\n\t\t\t}\n\t\t}\n\t}\n\n\tstatic boolean func(int nx,int ny,int hx,int hy,int a,int w,int du){\n\t\tLine2D.Double v1 = new Line2D.Double(nx,ny,nx+(double)a*Math.cos(Math.PI*((double)w-(double)du/2.0)/180.0)\n\t\t\t,ny+(double)a*Math.sin(Math.PI*((double)w-(double)du/2.0)/180.0));\n\t\tLine2D.Double v2 = new Line2D.Double(nx,ny,nx+(double)a*Math.cos(Math.PI*((double)w+(double)du/2.0)/180.0)\n\t\t\t,ny+(double)a*Math.sin(Math.PI*((double)w+(double)du/2.0)/180.0));\n\t\tif(v1.relativeCCW(hx,hy)==0 || v2.relativeCCW(hx,hy)==0 \n\t\t\t\t|| (Math.sqrt(hx*hx+hy*hy)<=(double)a && v1.relativeCCW(hx,hy)==-1 && v2.relativeCCW(hx,hy)==1 )){\n\t\t\treturn true;\t\t\t\t\t\t\n\t\t}\n\t\treturn false;\n\t}\n}"
  },
  {
    "language": "Java",
    "code": "import java.util.*;\npublic class Main {\n\t\n\tpublic static void main(String[] args) {\n\t\tScanner stdIn = new Scanner(System.in);\n\t\twhile(true) {\n\t\t\tint H = stdIn.nextInt();\n\t\t\tint R = stdIn.nextInt();\n\t\t\t\n\t\t\tif(H == 0 && R == 0) {\n\t\t\t\tbreak;\n\t\t\t}\n\t\t\t\n\t\t\tint[] hx = new int[H];\n\t\t\tint[] hy = new int[H];\n\t\t\tfor(int i = 0; i < H; i++) {\n\t\t\t\thx[i] = stdIn.nextInt();\n\t\t\t\thy[i] = stdIn.nextInt();\n\t\t\t}\n\t\t\t\n\t\t\tint U = stdIn.nextInt();\n\t\t\tint M = stdIn.nextInt();\n\t\t\tint S = stdIn.nextInt();\n\t\t\tint du = stdIn.nextInt();\n\t\t\tint dm = stdIn.nextInt();\n\t\t\tint ds = stdIn.nextInt();\n\t\t\t\n\t\t\tint[] ux = new int[U];\n\t\t\tint[] uy = new int[U];\n\t\t\tfor(int i = 0; i < U; i++) {\n\t\t\t\tux[i] = stdIn.nextInt();\n\t\t\t\tuy[i] = stdIn.nextInt();\n\t\t\t}\n\t\t\t\n\t\t\tint[] mx = new int[M];\n\t\t\tint[] my = new int[M];\n\t\t\tfor(int i = 0; i < M; i++) {\n\t\t\t\tmx[i] = stdIn.nextInt();\n\t\t\t\tmy[i] = stdIn.nextInt();\n\t\t\t}\n\t\t\t\n\t\t\tint[] sx = new int[S];\n\t\t\tint[] sy = new int[S];\n\t\t\t\n\t\t\tfor(int i = 0; i < S; i++) {\n\t\t\t\tsx[i] = stdIn.nextInt();\n\t\t\t\tsy[i] = stdIn.nextInt();\n\t\t\t}\n\t\t\t\n\t\t\tint[] w = new int[R];\n\t\t\tint[] a = new int[R];\n\t\t\tfor(int i = 0; i < R; i++) {\n\t\t\t\tw[i] = stdIn.nextInt();\n\t\t\t\ta[i] = stdIn.nextInt();\n\t\t\t}\n\t\t\t\n\t\t\t//---処理ここから---//\n\t\t\tint[] day = new int[H];\n\t\t\tfor(int i = 0; i < R; i++) { //風\n\t\t\t\tIN:for(int j = 0; j < H; j++) { //家\n\t\t\t\t\t//---私の桜が届くか---//\n\t\t\t\t\tif(!ReachWind(0,0,hx[j],hy[j],w[i],du,a[i])) {\n\t\t\t\t\t\tcontinue;\n\t\t\t\t\t}\n\t\t\t\t\t//---梅---//\n\t\t\t\t\tfor(int k = 0; k < U; k++) {\n\t\t\t\t\t\tif(ReachWind(ux[k],uy[k],hx[j],hy[j],w[i],du,a[i])) {\n\t\t\t\t\t\t\tcontinue IN;\n\t\t\t\t\t\t}\n\t\t\t\t\t}\n\t\t\t\t\t//---桃---//\n\t\t\t\t\tfor(int k = 0; k < M; k++) {\n\t\t\t\t\t\tif(ReachWind(mx[k],my[k],hx[j],hy[j],w[i],dm,a[i])) {\n\t\t\t\t\t\t\tcontinue IN;\n\t\t\t\t\t\t}\n\t\t\t\t\t}\n\t\t\t\t\t//---桜---//\n\t\t\t\t\tfor(int k = 0; k < S; k++) {\n\t\t\t\t\t\tif(ReachWind(sx[k],sy[k],hx[j],hy[j],w[i],ds,a[i])) {\n\t\t\t\t\t\t\tcontinue IN;\n\t\t\t\t\t\t}\n\t\t\t\t\t}\n\t\t\t\t\tday[j]++;\n\t\t\t\t\t\n\t\t\t\t\t\n\t\t\t\t\t\n\t\t\t\t\t\n\t\t\t\t}\n\t\t\t}\n\t\t\tint max = 0;\n\t\t\tfor(int i = 0; i < H; i++) {\n\t\t\t\tif(max < day[i]) {\n\t\t\t\t\tmax = day[i];\n\t\t\t\t}\n\t\t\t}\n\t\t\tif(max != 0) {\n\t\t\t\tboolean tmp = false;\n\t\t\t\tfor(int i = 0; i < H; i++) {\n\t\t\t\t\tif(!tmp && max == day[i]) {\n\t\t\t\t\t\tSystem.out.print((i + 1));\n\t\t\t\t\t\ttmp = true;\n\t\t\t\t\t}\n\t\t\t\t\telse if(max == day[i]) {\n\t\t\t\t\t\tSystem.out.print(\" \" + (i+1));\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t\tSystem.out.println();\n\t\t\t}\n\t\t\telse {\n\t\t\t\tSystem.out.println(\"NA\");\n\t\t\t}\n\t\t}\n\t}\n\t\n\tpublic static boolean ReachWind(int x0, int y0, int x1, int y1, int w, int d, int a) {\n\t\t//---長さ---//\n\t\tif(Math.sqrt((x0 - x1) * (x0 - x1) + (y0 - y1)*(y0 - y1)) > a) {\n\t\t\treturn false;\n\t\t}\n\t\t\n\t\t//---角度(x軸から何度か)---//\n\t\tint xlen = x1 - x0;\n\t\tint ylen = y1 - y0;\n\t\tdouble angle = Math.atan2(ylen, xlen);\n\t\t\n\t\tangle = Math.toDegrees(angle);\n\t\t\n\t\tif(angle >= w-d/2.0 && angle <= w+d/2.0) {\n\t\t\treturn true;\n\t\t}\n\t\treturn false;\n\t\t\n\t}\n}"
  },
  {
    "language": "Java",
    "code": "import java.util.*;\nimport java.awt.geom.*;\n\npublic class Main {\n\t\n\tprivate void doit(){\n\t\tScanner sc = new Scanner(System.in);\n\t\twhile(true){\n\t\t\tint h = sc.nextInt();\n\t\t\tint r = sc.nextInt();\n\t\t\tif((h|r) == 0) break;\n\t\t\tPoint2D [] house = new Point2D[h];\n\t\t\tfor(int i = 0; i < h; i++){\n\t\t\t\tint x = sc.nextInt();\n\t\t\t\tint y = sc.nextInt();\n\t\t\t\thouse[i] = new Point2D.Double(x, y);\n\t\t\t}\n\t\t\tint [] size = new int[3];\n\t\t\tint [] deg = new int[3];\n\t\t\tfor(int i = 0; i < 3; i++){\n\t\t\t\tsize[i] = sc.nextInt();\n\t\t\t}\n\t\t\tfor(int i = 0; i < 3; i++){\n\t\t\t\tdeg[i] = sc.nextInt();\n\t\t\t}\n\t\t\tArrayList<ArrayList<Point2D>> ps = new ArrayList<ArrayList<Point2D>>();\n\t\t\tfor(int i =0; i < 3; i++){\n\t\t\t\tps.add(new ArrayList<Point2D>());\n\t\t\t\tfor(int j = 0; j < size[i]; j++){\n\t\t\t\t\tps.get(i).add(new Point2D.Double(sc.nextInt(), sc.nextInt()));\n\t\t\t\t}\n\t\t\t}\n\t\t\tint [][] wind = new int[r][2];\n\t\t\tfor(int i = 0; i < r; i++){\n\t\t\t\twind[i][0] = sc.nextInt();\n\t\t\t\twind[i][1] = sc.nextInt();\n\t\t\t}\n\t\t\t\n\t\t\tint [] count = new int[h];\n\t\t\tPoint2D myhome = new Point2D.Double(0,0);\n\t\t\t//日付ごと\n\t\t\tfor(int i = 0; i < r; i++){\n\t\t\t\t//ある家ごとにみる\n\t\t\t\t//自分以外の香りが届いているか？\n\t\t\t\t//すべて届いていないならば、自分の香りが届いているか？trueならばcount++;\n\t\t\t\t\n\t\t\t\tfor(int j = 0; j < h; j++){\n\t\t\t\t\tboolean res = isBadFlourReach(wind[i],deg,ps, house[j]);\n\t\t\t\t\tif(! res){\n\t\t\t\t\t\tres = isFlourReach(wind[i],deg[0],myhome, house[j]);\n\t\t\t\t\t\tif(res){\n\t\t\t\t\t\t\tcount[j]++;\n\t\t\t\t\t\t}\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t}\n\t\t\tint max = 1;\n\t\t\tfor(int i = 0; i < count.length; i++){\n\t\t\t\tmax = Math.max(max, count[i]);\n\t\t\t}\n\t\t\tStringBuilder anshouse = new StringBuilder();\n\t\t\tfor(int i = 0; i < count.length; i++){\n\t\t\t\tif(max == count[i]){\n\t\t\t\t\tanshouse.append(\" \" + (i + 1));\n\t\t\t\t}\n\t\t\t}\n\t\t\tif(anshouse.length() == 0){\n\t\t\t\tSystem.out.println(\"NA\");\n\t\t\t}\n\t\t\telse{\n\t\t\t\tSystem.out.println(anshouse.substring(1));\n\t\t\t}\n\t\t}\n\t}\n\t\n\n\tprivate boolean isFlourReach(int[] wind, int deg, Point2D myhome, Point2D target) {\n\t\tdouble dis = myhome.distance(target);\n\t\tif(myhome.distance(target) > wind[1]){\n\t\t\treturn false;\n\t\t}\n\t\tdouble x = (target.getX() - myhome.getX()) / dis;\n\t\tdouble y = (target.getY() - myhome.getY()) / dis;\n\t\tdouble res = Math.atan2(y, x);\n\t\tdouble resdeg = Math.toDegrees(res);\n\t\tdouble windmax = wind[0] + (double)deg / 2;\n\t\tdouble windmin = wind[0] - (double)deg / 2;\n\t\tif(windmin <= resdeg && resdeg <= windmax){\n\t\t\treturn true;\n\t\t}\n\t\tresdeg += 360;\n\t\tif(windmin <= resdeg && resdeg <= windmax){\n\t\t\treturn true;\n\t\t}\n\t\treturn false;\n\t}\n\n\n\tprivate boolean isBadFlourReach(int[] wind, int[] deg, ArrayList<ArrayList<Point2D>> ps, Point2D target) {\n\t\tfor(int i = 0; i < 3; i++){\n\t\t\tfor(int j = 0; j < ps.get(i).size(); j++){\n\t\t\t\tif(isFlourReach(wind, deg[i], ps.get(i).get(j), target)){\n\t\t\t\t\treturn true;\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t\treturn false;\n\t}\n\n\n\tprivate void debug(Object... o) {\n\t\tSystem.out.println(\"debug = \" + Arrays.deepToString(o));\n\t}\n\n\tpublic static void main(String[] args) {\n\t\tnew Main().doit();\n\t}\n}"
  },
  {
    "language": "Java",
    "code": "import java.util.*;\npublic class Main {\n\t\n\tpublic static void main(String[] args) {\n\t\tScanner stdIn = new Scanner(System.in);\n\t\twhile(true) {\n\t\t\tint H = stdIn.nextInt();\n\t\t\tint R = stdIn.nextInt();\n\t\t\t\n\t\t\tif(H == 0 && R == 0) {\n\t\t\t\tbreak;\n\t\t\t}\n\t\t\t\n\t\t\tint[] hx = new int[H];\n\t\t\tint[] hy = new int[H];\n\t\t\tfor(int i = 0; i < H; i++) {\n\t\t\t\thx[i] = stdIn.nextInt();\n\t\t\t\thy[i] = stdIn.nextInt();\n\t\t\t}\n\t\t\t\n\t\t\tint U = stdIn.nextInt();\n\t\t\tint M = stdIn.nextInt();\n\t\t\tint S = stdIn.nextInt();\n\t\t\tint du = stdIn.nextInt();\n\t\t\tint dm = stdIn.nextInt();\n\t\t\tint ds = stdIn.nextInt();\n\t\t\t\n\t\t\tint[] ux = new int[U];\n\t\t\tint[] uy = new int[U];\n\t\t\tfor(int i = 0; i < U; i++) {\n\t\t\t\tux[i] = stdIn.nextInt();\n\t\t\t\tuy[i] = stdIn.nextInt();\n\t\t\t}\n\t\t\t\n\t\t\tint[] mx = new int[M];\n\t\t\tint[] my = new int[M];\n\t\t\tfor(int i = 0; i < M; i++) {\n\t\t\t\tmx[i] = stdIn.nextInt();\n\t\t\t\tmy[i] = stdIn.nextInt();\n\t\t\t}\n\t\t\t\n\t\t\tint[] sx = new int[S];\n\t\t\tint[] sy = new int[S];\n\t\t\t\n\t\t\tfor(int i = 0; i < S; i++) {\n\t\t\t\tsx[i] = stdIn.nextInt();\n\t\t\t\tsy[i] = stdIn.nextInt();\n\t\t\t}\n\t\t\t\n\t\t\tint[] w = new int[R];\n\t\t\tint[] a = new int[R];\n\t\t\tfor(int i = 0; i < R; i++) {\n\t\t\t\tw[i] = stdIn.nextInt();\n\t\t\t\ta[i] = stdIn.nextInt();\n\t\t\t}\n\t\t\t\n\t\t\t//---処理ここから---//\n\t\t\tint[] day = new int[H];\n\t\t\tfor(int i = 0; i < R; i++) { //風\n\t\t\t\tIN:for(int j = 0; j < H; j++) { //家\n\t\t\t\t\t//---私の桜が届くか---//\n\t\t\t\t\tif(!ReachWind(0,0,hx[j],hy[j],w[i],du,a[i])) {\n\t\t\t\t\t\tcontinue;\n\t\t\t\t\t}\n\t\t\t\t\t//---梅---//\n\t\t\t\t\tfor(int k = 0; k < U; k++) {\n\t\t\t\t\t\tif(ReachWind(ux[k],uy[k],hx[j],hy[j],w[i],du,a[i])) {\n\t\t\t\t\t\t\tcontinue IN;\n\t\t\t\t\t\t}\n\t\t\t\t\t}\n\t\t\t\t\t//---桃---//\n\t\t\t\t\tfor(int k = 0; k < M; k++) {\n\t\t\t\t\t\tif(ReachWind(mx[k],my[k],hx[j],hy[j],w[i],dm,a[i])) {\n\t\t\t\t\t\t\tcontinue IN;\n\t\t\t\t\t\t}\n\t\t\t\t\t}\n\t\t\t\t\t//---桜---//\n\t\t\t\t\tfor(int k = 0; k < S; k++) {\n\t\t\t\t\t\tif(ReachWind(sx[k],sy[k],hx[j],hy[j],w[i],ds,a[i])) {\n\t\t\t\t\t\t\tcontinue IN;\n\t\t\t\t\t\t}\n\t\t\t\t\t}\n\t\t\t\t\tday[j]++;\n\t\t\t\t\t\n\t\t\t\t\t\n\t\t\t\t\t\n\t\t\t\t\t\n\t\t\t\t}\n\t\t\t}\n\t\t\tint max = 0;\n\t\t\tfor(int i = 0; i < H; i++) {\n\t\t\t\tif(max < day[i]) {\n\t\t\t\t\tmax = day[i];\n\t\t\t\t}\n\t\t\t}\n\t\t\tif(max != 0) {\n\t\t\t\tboolean tmp = false;\n\t\t\t\tfor(int i = 0; i < H; i++) {\n\t\t\t\t\tif(!tmp && max == day[i]) {\n\t\t\t\t\t\tSystem.out.print((i + 1));\n\t\t\t\t\t\ttmp = true;\n\t\t\t\t\t}\n\t\t\t\t\telse if(max == day[i]) {\n\t\t\t\t\t\tSystem.out.print(\" \" + (i+1));\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t\tSystem.out.println();\n\t\t\t}\n\t\t\telse {\n\t\t\t\tSystem.out.println(\"NA\");\n\t\t\t}\n\t\t}\n\t}\n\t\n\tpublic static boolean ReachWind(int x0, int y0, int x1, int y1, int w, int d, int a) {\n\t\t//---長さ---//\n\t\tif(Math.sqrt((x0 - x1) * (x0 - x1) + (y0 - y1)*(y0 - y1)) > a) {\n\t\t\treturn false;\n\t\t}\n\t\t\n\t\t//---角度(x軸から何度か)---//\n\t\tint xlen = x1 - x0;\n\t\tint ylen = y1 - y0;\n\t\tdouble angle = Math.atan2(ylen, xlen);\n\t\t\n\t\tangle = Math.toDegrees(angle);\n\t\t\n\t\tif(angle >= w-d/2 && angle <= w+d/2) {\n\t\t\treturn true;\n\t\t}\n\t\treturn false;\n\t\t\n\t}\n}"
  },
  {
    "language": "Java",
    "code": "import java.util.*;\npublic class Main {\n\t\n\tpublic static void main(String[] args) {\n\t\tScanner stdIn = new Scanner(System.in);\n\t\twhile(true) {\n\t\t\tint H = stdIn.nextInt();\n\t\t\tint R = stdIn.nextInt();\n\t\t\t\n\t\t\tif(H == 0 && R == 0) {\n\t\t\t\tbreak;\n\t\t\t}\n\t\t\t\n\t\t\tint[] hx = new int[H];\n\t\t\tint[] hy = new int[H];\n\t\t\tfor(int i = 0; i < H; i++) {\n\t\t\t\thx[i] = stdIn.nextInt();\n\t\t\t\thy[i] = stdIn.nextInt();\n\t\t\t}\n\t\t\t\n\t\t\tint U = stdIn.nextInt();\n\t\t\tint M = stdIn.nextInt();\n\t\t\tint S = stdIn.nextInt();\n\t\t\tint du = stdIn.nextInt();\n\t\t\tint dm = stdIn.nextInt();\n\t\t\tint ds = stdIn.nextInt();\n\t\t\t\n\t\t\tint[] ux = new int[U];\n\t\t\tint[] uy = new int[U];\n\t\t\tfor(int i = 0; i < U; i++) {\n\t\t\t\tux[i] = stdIn.nextInt();\n\t\t\t\tuy[i] = stdIn.nextInt();\n\t\t\t}\n\t\t\t\n\t\t\tint[] mx = new int[M];\n\t\t\tint[] my = new int[M];\n\t\t\tfor(int i = 0; i < M; i++) {\n\t\t\t\tmx[i] = stdIn.nextInt();\n\t\t\t\tmy[i] = stdIn.nextInt();\n\t\t\t}\n\t\t\t\n\t\t\tint[] sx = new int[S];\n\t\t\tint[] sy = new int[S];\n\t\t\t\n\t\t\tfor(int i = 0; i < S; i++) {\n\t\t\t\tsx[i] = stdIn.nextInt();\n\t\t\t\tsy[i] = stdIn.nextInt();\n\t\t\t}\n\t\t\t\n\t\t\tint[] w = new int[R];\n\t\t\tint[] a = new int[R];\n\t\t\tfor(int i = 0; i < R; i++) {\n\t\t\t\tw[i] = stdIn.nextInt();\n\t\t\t\ta[i] = stdIn.nextInt();\n\t\t\t}\n\t\t\t\n\t\t\t//---処理ここから---//\n\t\t\tint[] day = new int[H];\n\t\t\tfor(int i = 0; i < R; i++) { //風\n\t\t\t\tIN:for(int j = 0; j < H; j++) { //家\n\t\t\t\t\t//---私の桜が届くか---//\n\t\t\t\t\tif(!ReachWind(0,0,hx[j],hy[j],w[i],du,a[i])) {\n\t\t\t\t\t\tcontinue;\n\t\t\t\t\t}\n\t\t\t\t\t//---梅---//\n\t\t\t\t\tfor(int k = 0; k < U; k++) {\n\t\t\t\t\t\tif(ReachWind(ux[k],uy[k],hx[j],hy[j],w[i],du,a[i])) {\n\t\t\t\t\t\t\tcontinue IN;\n\t\t\t\t\t\t}\n\t\t\t\t\t}\n\t\t\t\t\t//---桃---//\n\t\t\t\t\tfor(int k = 0; k < M; k++) {\n\t\t\t\t\t\tif(ReachWind(mx[k],my[k],hx[j],hy[j],w[i],dm,a[i])) {\n\t\t\t\t\t\t\tcontinue IN;\n\t\t\t\t\t\t}\n\t\t\t\t\t}\n\t\t\t\t\t//---桜---//\n\t\t\t\t\tfor(int k = 0; k < S; k++) {\n\t\t\t\t\t\tif(ReachWind(sx[k],sy[k],hx[j],hy[j],w[i],ds,a[i])) {\n\t\t\t\t\t\t\tcontinue IN;\n\t\t\t\t\t\t}\n\t\t\t\t\t}\n\t\t\t\t\tday[j]++;\n\t\t\t\t\t\n\t\t\t\t\t\n\t\t\t\t\t\n\t\t\t\t\t\n\t\t\t\t}\n\t\t\t}\n\t\t\tint max = 0;\n\t\t\tfor(int i = 0; i < H; i++) {\n\t\t\t\tif(max < day[i]) {\n\t\t\t\t\tmax = day[i];\n\t\t\t\t}\n\t\t\t}\n\t\t\tif(max != 0) {\n\t\t\t\tboolean tmp = false;\n\t\t\t\tfor(int i = 0; i < H; i++) {\n\t\t\t\t\tif(!tmp && max == day[i]) {\n\t\t\t\t\t\tSystem.out.print((i + 1));\n\t\t\t\t\t\ttmp = true;\n\t\t\t\t\t}\n\t\t\t\t\telse if(max == day[i]) {\n\t\t\t\t\t\tSystem.out.print(\" \" + (i+1));\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t\tSystem.out.println();\n\t\t\t}\n\t\t\telse {\n\t\t\t\tSystem.out.println(\"NA\");\n\t\t\t}\n\t\t}\n\t}\n\t\n\tpublic static boolean ReachWind(int x0, int y0, int x1, int y1, int w, int d, int a) {\n\t\t//---長さ---//\n\t\tif(Math.sqrt((x0 - x1) * (x0 - x1) + (y0 - y1)*(y0 - y1)) > a) {\n\t\t\treturn false;\n\t\t}\n\t\t\n\t\t//---角度(x軸から何度か)---//\n\t\tint xlen = x1 - x0;\n\t\tint ylen = y1 - y0;\n\t\tdouble angle = Math.atan2(ylen, xlen);\n\t\t\n\t\tangle = Math.toDegrees(angle);\n\t\t\n\t\tif(angle < 0) {\n\t\t\tangle = (360.0 + angle);\n\t\t}\n\t\t\n\t\tif(angle >= (w-d/2.0)%360 && angle <= (w+d/2.0)%360) {\n\t\t\treturn true;\n\t\t}\n\t\treturn false;\n\t\t\n\t}\n}"
  },
  {
    "language": "Java",
    "code": "import java.util.ArrayList;\nimport java.util.Arrays;\nimport java.util.Comparator;\nimport java.util.Scanner;\n\npublic class Main {\n\tpublic static Vector2 ZERO = new Vector2(0,0);\n\tpublic static void main(String[] args) {\n\t\tScanner sc = new Scanner(System.in);\n\t\twhile(true) {\n\t\t\tint h = sc.nextInt();\n\t\t\tint r = sc.nextInt();\n\t\t\tif (h+r == 0) {\n\t\t\t\tbreak;\n\t\t\t}\n\t\t\tVector2[] home = new Vector2[h];\n\t\t\tPair[] count = new Pair[h];\n\t\t\tfor(int i=0;i<h;i++) {\n\t\t\t\tint x = sc.nextInt();\n\t\t\t\tint y = sc.nextInt();\n\t\t\t\thome[i] = new Vector2(x,y);\n\t\t\t\tcount[i] = new Pair(i,0);\n\t\t\t}\n\t\t\tint u = sc.nextInt();\n\t\t\tint m = sc.nextInt();\n\t\t\tint s = sc.nextInt();\n\t\t\tdouble du = Math.toRadians(sc.nextInt())/2;\n\t\t\tdouble dm = Math.toRadians(sc.nextInt())/2;\n\t\t\tdouble ds = Math.toRadians(sc.nextInt())/2;\n\t\t\tVector2[] posU = new Vector2[u];\n\t\t\tVector2[] posM = new Vector2[m];\n\t\t\tVector2[] posS = new Vector2[s];\n\t\t\tfor(int i=0;i<u;i++) {\n\t\t\t\tint x = sc.nextInt();\n\t\t\t\tint y = sc.nextInt();\n\t\t\t\tposU[i] = new Vector2(x,y);\n\t\t\t}\n\t\t\tfor(int i=0;i<m;i++) {\n\t\t\t\tint x = sc.nextInt();\n\t\t\t\tint y = sc.nextInt();\n\t\t\t\tposM[i] = new Vector2(x,y);\n\t\t\t}\n\t\t\tfor(int i=0;i<s;i++) {\n\t\t\t\tint x = sc.nextInt();\n\t\t\t\tint y = sc.nextInt();\n\t\t\t\tposS[i] = new Vector2(x,y);\n\t\t\t}\n\t\t\tfor(int i=0;i<r;i++) {\n\t\t\t\tint w = sc.nextInt();\n\t\t\t\tint a = sc.nextInt();\n\t\t\t\tVector2 wind = new Vector2(Math.cos(Math.toRadians(w)),Math.sin(Math.toRadians(w)));\n\t\t\t\tfor(int j=0;j<h;j++) {\n\t\t\t\t\tif (intersect(posU, wind, a, du, home[j])) {\n\t\t\t\t\t\tcontinue;\n\t\t\t\t\t}\n\t\t\t\t\tif (intersect(posM, wind, a, dm, home[j])) {\n\t\t\t\t\t\tcontinue;\n\t\t\t\t\t}\n\t\t\t\t\tif (intersect(posS, wind, a, ds, home[j])) {\n\t\t\t\t\t\tcontinue;\n\t\t\t\t\t}\n\t\t\t\t\tif (!intersect(ZERO,wind,a,du,home[j])) {\n\t\t\t\t\t\tcontinue;\n\t\t\t\t\t}\n\t\t\t\t\tcount[j].b++;\n\t\t\t\t}\n\t\t\t}\n\t\t\tArrays.sort(count,new Comparator<Pair>() {\n\t\t\t\tpublic int compare(Pair o1, Pair o2) {\n\t\t\t\t\treturn Integer.compare(o1.b, o2.b);\n\t\t\t\t}\n\t\t\t});\n\t\t\tint max = count[h-1].b;\n\t\t\tif (max == 0) {\n\t\t\t\tSystem.out.println(\"NA\");\n\t\t\t}else{\n\t\t\t\tArrayList<Integer> ans = new ArrayList<Integer>();\n\t\t\t\tfor(int i=0;i<h;i++) {\n\t\t\t\t\tif (count[i].b == max) {\n\t\t\t\t\t\tans.add(count[i].a);\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t\tStringBuilder sb = new StringBuilder();\n\t\t\t\tfor(int i=0;i<ans.size();i++) {\n\t\t\t\t\tsb.append(ans.get(i)+1);\n\t\t\t\t\tif (i!=ans.size()-1) {\n\t\t\t\t\t\tsb.append(\" \");\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t\tSystem.out.println(sb);\n\t\t\t}\n\t\t}\n\t}\n\tpublic static boolean intersect(Vector2[] pos,Vector2 dir,double length,double ang,Vector2 r) {\n\t\tfor(Vector2 r0:pos) {\n\t\t\tif (intersect(r0, dir, length, ang, r)) {\n\t\t\t\treturn true;\n\t\t\t}\n\t\t}\n\t\treturn false;\n\t}\n\tpublic static boolean intersect(Vector2 r0,Vector2 dir,double length,double ang,Vector2 r) {\n\t\tVector2 r1 = r.subtract(r0);\n\t\treturn r1.norm() < length && dir.dot(r1.normalize()) > Math.cos(ang);\n\t}\n}\nclass Pair {\n\tint a,b;\n\tpublic Pair(int a,int b) {\n\t\tthis.a = a;\n\t\tthis.b = b;\n\t}\n\tpublic String toString() {\n\t\treturn \"(\" + a + \",\" + b + \")\";\n\t}\n}\nclass Vector2 {\n\tdouble x = 0;\n\tdouble y = 0;\n\tpublic Vector2(double x,double y) {\n\t\tthis.x = x;\n\t\tthis.y = y;\n\t}\n\tpublic double dot(Vector2 v) {\n\t\treturn this.x*v.x+this.y*v.y;\n\t}\n\tpublic double cross(Vector2 v) {\n\t\treturn this.x*v.y-this.y*v.x;\n\t}\n\tpublic Vector2 add(Vector2 v) {\n\t\treturn new Vector2(this.x+v.x,this.y+v.y);\n\t}\n\tpublic Vector2 subtract(Vector2 v) {\n\t\treturn new Vector2(this.x-v.x,this.y-v.y);\n\t}\n\tpublic Vector2 multiply(double k) {\n\t\treturn new Vector2(k*this.x,k*this.y);\n\t}\n\tpublic Vector2 divide(double k) {\n\t\treturn new Vector2(x/k,y/k);\n\t}\n\tpublic double norm() {\n\t\treturn Math.sqrt(x*x+y*y);\n\t}\n\tpublic Vector2 normalize() {\n\t\treturn this.divide(norm());\n\t}\n\tpublic String toString() {\n\t\treturn this.x + \" \" + this.y;\n\t}\n}"
  },
  {
    "language": "Java",
    "code": "import java.util.*;\npublic class Main {\n\t\n\tpublic static void main(String[] args) {\n\t\tScanner stdIn = new Scanner(System.in);\n\t\twhile(true) {\n\t\t\tint H = stdIn.nextInt();\n\t\t\tint R = stdIn.nextInt();\n\t\t\t\n\t\t\tif(H == 0 && R == 0) {\n\t\t\t\tbreak;\n\t\t\t}\n\t\t\t\n\t\t\tint[] hx = new int[H];\n\t\t\tint[] hy = new int[H];\n\t\t\tfor(int i = 0; i < H; i++) {\n\t\t\t\thx[i] = stdIn.nextInt();\n\t\t\t\thy[i] = stdIn.nextInt();\n\t\t\t}\n\t\t\t\n\t\t\tint U = stdIn.nextInt();\n\t\t\tint M = stdIn.nextInt();\n\t\t\tint S = stdIn.nextInt();\n\t\t\tint du = stdIn.nextInt();\n\t\t\tint dm = stdIn.nextInt();\n\t\t\tint ds = stdIn.nextInt();\n\t\t\t\n\t\t\tint[] ux = new int[U];\n\t\t\tint[] uy = new int[U];\n\t\t\tfor(int i = 0; i < U; i++) {\n\t\t\t\tux[i] = stdIn.nextInt();\n\t\t\t\tuy[i] = stdIn.nextInt();\n\t\t\t}\n\t\t\t\n\t\t\tint[] mx = new int[M];\n\t\t\tint[] my = new int[M];\n\t\t\tfor(int i = 0; i < M; i++) {\n\t\t\t\tmx[i] = stdIn.nextInt();\n\t\t\t\tmy[i] = stdIn.nextInt();\n\t\t\t}\n\t\t\t\n\t\t\tint[] sx = new int[S];\n\t\t\tint[] sy = new int[S];\n\t\t\t\n\t\t\tfor(int i = 0; i < S; i++) {\n\t\t\t\tsx[i] = stdIn.nextInt();\n\t\t\t\tsy[i] = stdIn.nextInt();\n\t\t\t}\n\t\t\t\n\t\t\tint[] w = new int[R];\n\t\t\tint[] a = new int[R];\n\t\t\tfor(int i = 0; i < R; i++) {\n\t\t\t\tw[i] = stdIn.nextInt();\n\t\t\t\ta[i] = stdIn.nextInt();\n\t\t\t}\n\t\t\t\n\t\t\t//---処理ここから---//\n\t\t\tint[] day = new int[H];\n\t\t\tfor(int i = 0; i < R; i++) { //風\n\t\t\t\tIN:for(int j = 0; j < H; j++) { //家\n\t\t\t\t\t//---私の桜が届くか---//\n\t\t\t\t\tif(!ReachWind(0,0,hx[j],hy[j],w[i],du,a[i])) {\n\t\t\t\t\t\tcontinue;\n\t\t\t\t\t}\n\t\t\t\t\t//---梅---//\n\t\t\t\t\tfor(int k = 0; k < U; k++) {\n\t\t\t\t\t\tif(ReachWind(ux[k],uy[k],hx[j],hy[j],w[i],du,a[i])) {\n\t\t\t\t\t\t\tcontinue IN;\n\t\t\t\t\t\t}\n\t\t\t\t\t}\n\t\t\t\t\t//---桃---//\n\t\t\t\t\tfor(int k = 0; k < M; k++) {\n\t\t\t\t\t\tif(ReachWind(mx[k],my[k],hx[j],hy[j],w[i],dm,a[i])) {\n\t\t\t\t\t\t\tcontinue IN;\n\t\t\t\t\t\t}\n\t\t\t\t\t}\n\t\t\t\t\t//---桜---//\n\t\t\t\t\tfor(int k = 0; k < S; k++) {\n\t\t\t\t\t\tif(ReachWind(sx[k],sy[k],hx[j],hy[j],w[i],ds,a[i])) {\n\t\t\t\t\t\t\tcontinue IN;\n\t\t\t\t\t\t}\n\t\t\t\t\t}\n\t\t\t\t\tday[j]++;\n\t\t\t\t\t\n\t\t\t\t\t\n\t\t\t\t\t\n\t\t\t\t\t\n\t\t\t\t}\n\t\t\t}\n\t\t\tint max = 0;\n\t\t\tfor(int i = 0; i < H; i++) {\n\t\t\t\tif(max < day[i]) {\n\t\t\t\t\tmax = day[i];\n\t\t\t\t}\n\t\t\t}\n\t\t\tif(max != 0) {\n\t\t\t\tboolean tmp = false;\n\t\t\t\tfor(int i = 0; i < H; i++) {\n\t\t\t\t\tif(!tmp && max == day[i]) {\n\t\t\t\t\t\tSystem.out.print((i + 1));\n\t\t\t\t\t\ttmp = true;\n\t\t\t\t\t}\n\t\t\t\t\telse if(max == day[i]) {\n\t\t\t\t\t\tSystem.out.print(\" \" + (i+1));\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t\tSystem.out.println();\n\t\t\t}\n\t\t\telse {\n\t\t\t\tSystem.out.println(\"NA\");\n\t\t\t}\n\t\t}\n\t}\n\t\n\tpublic static boolean ReachWind(int x0, int y0, int x1, int y1, int w, int d, int a) {\n\t\t//---長さ---//\n\t\tif(Math.sqrt((x0 - x1) * (x0 - x1) + (y0 - y1)*(y0 - y1)) > a) {\n\t\t\treturn false;\n\t\t}\n\t\t\n\t\t//---角度(x軸から何度か)---//\n\t\tint xlen = x1 - x0;\n\t\tint ylen = y1 - y0;\n\t\tdouble angle = Math.atan2(ylen, xlen);\n\t\t\n\t\tangle = Math.toDegrees(angle);\n\t\t\n\t\tif(angle < 0) {\n\t\t\tangle = (360.0 + angle);\n\t\t}\n\t\t\n\t\tif(angle >= w-d/2.0 && angle <= w+d/2.0) {\n\t\t\treturn true;\n\t\t}\n\t\treturn false;\n\t\t\n\t}\n}"
  },
  {
    "language": "Java",
    "code": "import java.util.ArrayList;\nimport java.util.Arrays;\nimport java.util.Comparator;\nimport java.util.Scanner;\n\npublic class Main {\n\tpublic static Vector2 ZERO = new Vector2(0,0);\n\tpublic static void main(String[] args) {\n\t\tScanner sc = new Scanner(System.in);\n\t\twhile(true) {\n\t\t\tint h = sc.nextInt();\n\t\t\tint r = sc.nextInt();\n\t\t\tif (h+r == 0) {\n\t\t\t\tbreak;\n\t\t\t}\n\t\t\tVector2[] home = new Vector2[h];\n\t\t\tPair[] count = new Pair[h];\n\t\t\tfor(int i=0;i<h;i++) {\n\t\t\t\tint x = sc.nextInt();\n\t\t\t\tint y = sc.nextInt();\n\t\t\t\thome[i] = new Vector2(x,y);\n\t\t\t\tcount[i] = new Pair(i,0);\n\t\t\t}\n\t\t\tint u = sc.nextInt();\n\t\t\tint m = sc.nextInt();\n\t\t\tint s = sc.nextInt();\n\t\t\tdouble du = Math.toRadians(sc.nextInt())/2;\n\t\t\tdouble dm = Math.toRadians(sc.nextInt())/2;\n\t\t\tdouble ds = Math.toRadians(sc.nextInt())/2;\n\t\t\tVector2[] posU = new Vector2[u];\n\t\t\tVector2[] posM = new Vector2[m];\n\t\t\tVector2[] posS = new Vector2[s];\n\t\t\tfor(int i=0;i<u;i++) {\n\t\t\t\tint x = sc.nextInt();\n\t\t\t\tint y = sc.nextInt();\n\t\t\t\tposU[i] = new Vector2(x,y);\n\t\t\t}\n\t\t\tfor(int i=0;i<m;i++) {\n\t\t\t\tint x = sc.nextInt();\n\t\t\t\tint y = sc.nextInt();\n\t\t\t\tposM[i] = new Vector2(x,y);\n\t\t\t}\n\t\t\tfor(int i=0;i<s;i++) {\n\t\t\t\tint x = sc.nextInt();\n\t\t\t\tint y = sc.nextInt();\n\t\t\t\tposS[i] = new Vector2(x,y);\n\t\t\t}\n\t\t\tfor(int i=0;i<r;i++) {\n\t\t\t\tint w = sc.nextInt();\n\t\t\t\tint a = sc.nextInt();\n\t\t\t\tVector2 wind = new Vector2(Math.cos(Math.toRadians(w)),Math.sin(Math.toRadians(w)));\n\t\t\t\tfor(int j=0;j<h;j++) {\n\t\t\t\t\tif (intersect(posU, wind, a, du, home[j])) {\n\t\t\t\t\t\tcontinue;\n\t\t\t\t\t}\n\t\t\t\t\tif (intersect(posM, wind, a, dm, home[j])) {\n\t\t\t\t\t\tcontinue;\n\t\t\t\t\t}\n\t\t\t\t\tif (intersect(posS, wind, a, ds, home[j])) {\n\t\t\t\t\t\tcontinue;\n\t\t\t\t\t}\n\t\t\t\t\tif (!intersect(ZERO,wind,a,du,home[j])) {\n\t\t\t\t\t\tcontinue;\n\t\t\t\t\t}\n\t\t\t\t\tcount[j].b++;\n\t\t\t\t}\n\t\t\t}\n\t\t\tArrays.sort(count,new Comparator<Pair>() {\n\t\t\t\tpublic int compare(Pair o1, Pair o2) {\n\t\t\t\t\treturn o1.b- o2.b;\n\t\t\t\t}\n\t\t\t});\n\t\t\tint max = count[h-1].b;\n\t\t\tif (max == 0) {\n\t\t\t\tSystem.out.println(\"NA\");\n\t\t\t}else{\n\t\t\t\tArrayList<Integer> ans = new ArrayList<Integer>();\n\t\t\t\tfor(int i=0;i<h;i++) {\n\t\t\t\t\tif (count[i].b == max) {\n\t\t\t\t\t\tans.add(count[i].a);\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t\tStringBuilder sb = new StringBuilder();\n\t\t\t\tfor(int i=0;i<ans.size();i++) {\n\t\t\t\t\tsb.append(ans.get(i)+1);\n\t\t\t\t\tif (i!=ans.size()-1) {\n\t\t\t\t\t\tsb.append(\" \");\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t\tSystem.out.println(sb);\n\t\t\t}\n\t\t}\n\t}\n\tpublic static boolean intersect(Vector2[] pos,Vector2 dir,double length,double ang,Vector2 r) {\n\t\tfor(Vector2 r0:pos) {\n\t\t\tif (intersect(r0, dir, length, ang, r)) {\n\t\t\t\treturn true;\n\t\t\t}\n\t\t}\n\t\treturn false;\n\t}\n\tpublic static boolean intersect(Vector2 r0,Vector2 dir,double length,double ang,Vector2 r) {\n\t\tVector2 r1 = r.subtract(r0);\n\t\treturn r1.norm() < length && dir.dot(r1.normalize()) > Math.cos(ang);\n\t}\n}\nclass Pair {\n\tint a,b;\n\tpublic Pair(int a,int b) {\n\t\tthis.a = a;\n\t\tthis.b = b;\n\t}\n\tpublic String toString() {\n\t\treturn \"(\" + a + \",\" + b + \")\";\n\t}\n}\nclass Vector2 {\n\tdouble x = 0;\n\tdouble y = 0;\n\tpublic Vector2(double x,double y) {\n\t\tthis.x = x;\n\t\tthis.y = y;\n\t}\n\tpublic double dot(Vector2 v) {\n\t\treturn this.x*v.x+this.y*v.y;\n\t}\n\tpublic double cross(Vector2 v) {\n\t\treturn this.x*v.y-this.y*v.x;\n\t}\n\tpublic Vector2 add(Vector2 v) {\n\t\treturn new Vector2(this.x+v.x,this.y+v.y);\n\t}\n\tpublic Vector2 subtract(Vector2 v) {\n\t\treturn new Vector2(this.x-v.x,this.y-v.y);\n\t}\n\tpublic Vector2 multiply(double k) {\n\t\treturn new Vector2(k*this.x,k*this.y);\n\t}\n\tpublic Vector2 divide(double k) {\n\t\treturn new Vector2(x/k,y/k);\n\t}\n\tpublic double norm() {\n\t\treturn Math.sqrt(x*x+y*y);\n\t}\n\tpublic Vector2 normalize() {\n\t\treturn this.divide(norm());\n\t}\n\tpublic String toString() {\n\t\treturn this.x + \" \" + this.y;\n\t}\n}"
  },
  {
    "language": "Java",
    "code": "import java.util.*;\npublic class Main {\n\t\n\tpublic static void main(String[] args) {\n\t\tScanner stdIn = new Scanner(System.in);\n\t\twhile(true) {\n\t\t\tint H = stdIn.nextInt();\n\t\t\tint R = stdIn.nextInt();\n\t\t\t\n\t\t\tif(H == 0 && R == 0) {\n\t\t\t\tbreak;\n\t\t\t}\n\t\t\t\n\t\t\tint[] hx = new int[H];\n\t\t\tint[] hy = new int[H];\n\t\t\tfor(int i = 0; i < H; i++) {\n\t\t\t\thx[i] = stdIn.nextInt();\n\t\t\t\thy[i] = stdIn.nextInt();\n\t\t\t}\n\t\t\t\n\t\t\tint U = stdIn.nextInt();\n\t\t\tint M = stdIn.nextInt();\n\t\t\tint S = stdIn.nextInt();\n\t\t\tint du = stdIn.nextInt();\n\t\t\tint dm = stdIn.nextInt();\n\t\t\tint ds = stdIn.nextInt();\n\t\t\t\n\t\t\tint[] ux = new int[U];\n\t\t\tint[] uy = new int[U];\n\t\t\tfor(int i = 0; i < U; i++) {\n\t\t\t\tux[i] = stdIn.nextInt();\n\t\t\t\tuy[i] = stdIn.nextInt();\n\t\t\t}\n\t\t\t\n\t\t\tint[] mx = new int[M];\n\t\t\tint[] my = new int[M];\n\t\t\tfor(int i = 0; i < M; i++) {\n\t\t\t\tmx[i] = stdIn.nextInt();\n\t\t\t\tmy[i] = stdIn.nextInt();\n\t\t\t}\n\t\t\t\n\t\t\tint[] sx = new int[S];\n\t\t\tint[] sy = new int[S];\n\t\t\t\n\t\t\tfor(int i = 0; i < S; i++) {\n\t\t\t\tsx[i] = stdIn.nextInt();\n\t\t\t\tsy[i] = stdIn.nextInt();\n\t\t\t}\n\t\t\t\n\t\t\tint[] w = new int[R];\n\t\t\tint[] a = new int[R];\n\t\t\tfor(int i = 0; i < R; i++) {\n\t\t\t\tw[i] = stdIn.nextInt();\n\t\t\t\ta[i] = stdIn.nextInt();\n\t\t\t}\n\t\t\t\n\t\t\t//---処理ここから---//\n\t\t\tint[] day = new int[H];\n\t\t\tfor(int i = 0; i < R; i++) { //風\n\t\t\t\tIN:for(int j = 0; j < H; j++) { //家\n\t\t\t\t\t//---私の桜が届くか---//\n\t\t\t\t\tif(!ReachWind(0,0,hx[j],hy[j],w[i],du,a[i])) {\n\t\t\t\t\t\tcontinue;\n\t\t\t\t\t}\n\t\t\t\t\t//---梅---//\n\t\t\t\t\tfor(int k = 0; k < U; k++) {\n\t\t\t\t\t\tif(ReachWind(ux[k],uy[k],hx[j],hy[j],w[i],du,a[i])) {\n\t\t\t\t\t\t\tcontinue IN;\n\t\t\t\t\t\t}\n\t\t\t\t\t}\n\t\t\t\t\t//---桃---//\n\t\t\t\t\tfor(int k = 0; k < M; k++) {\n\t\t\t\t\t\tif(ReachWind(mx[k],my[k],hx[j],hy[j],w[i],dm,a[i])) {\n\t\t\t\t\t\t\tcontinue IN;\n\t\t\t\t\t\t}\n\t\t\t\t\t}\n\t\t\t\t\t//---桜---//\n\t\t\t\t\tfor(int k = 0; k < S; k++) {\n\t\t\t\t\t\tif(ReachWind(sx[k],sy[k],hx[j],hy[j],w[i],ds,a[i])) {\n\t\t\t\t\t\t\tcontinue IN;\n\t\t\t\t\t\t}\n\t\t\t\t\t}\n\t\t\t\t\tday[j]++;\n\t\t\t\t\t\n\t\t\t\t\t\n\t\t\t\t\t\n\t\t\t\t\t\n\t\t\t\t}\n\t\t\t}\n\t\t\tint max = 0;\n\t\t\tfor(int i = 0; i < H; i++) {\n\t\t\t\tif(max < day[i]) {\n\t\t\t\t\tmax = day[i];\n\t\t\t\t}\n\t\t\t}\n\t\t\tif(max != 0) {\n\t\t\t\tboolean tmp = false;\n\t\t\t\tfor(int i = 0; i < H; i++) {\n\t\t\t\t\tif(!tmp && max == day[i]) {\n\t\t\t\t\t\tSystem.out.print((i + 1));\n\t\t\t\t\t\ttmp = true;\n\t\t\t\t\t}\n\t\t\t\t\telse if(max == day[i]) {\n\t\t\t\t\t\tSystem.out.print(\" \" + (i+1));\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t\tSystem.out.println();\n\t\t\t}\n\t\t\telse {\n\t\t\t\tSystem.out.println(\"NA\");\n\t\t\t}\n\t\t}\n\t}\n\t\n\tpublic static boolean ReachWind(int x0, int y0, int x1, int y1, int w, int d, int a) {\n\t\t//---長さ---//\n\t\tif(Math.sqrt((x0 - x1) * (x0 - x1) + (y0 - y1)*(y0 - y1)) > a) {\n\t\t\treturn false;\n\t\t}\n\t\t\n\t\t//---角度(x軸から何度か)---//\n\t\tint xlen = x1 - x0;\n\t\tint ylen = y1 - y0;\n\t\tdouble angle = Math.atan2(ylen, xlen);\n\t\tangle = Math.toDegrees(angle);\n\t\tdouble ue = w + d/2.0;\n\t\tdouble shita = w - d/2.0;\n\t\tif(angle >= shita && angle <= ue) {\n\t\t\treturn true;\n\t\t}\n\t\tangle += 360;\n\t\tif(angle >= shita && angle <= ue) {\n\t\t\treturn true;\n\t\t}\n\t\tangle -= 1080;\n\t\tif(angle >= shita && angle <= ue) {\n\t\t\treturn true;\n\t\t}\n\t\treturn false;\n\t\t\n\t}\n}"
  },
  {
    "language": "Java",
    "code": "import java.util.ArrayList;\nimport java.util.Arrays;\nimport java.util.Comparator;\nimport java.util.Scanner;\n\npublic class Main {\n\tpublic static Vector2 ZERO = new Vector2(0,0);\n\tpublic static void main(String[] args) {\n\t\tScanner sc = new Scanner(System.in);\n\t\twhile(true) {\n\t\t\tint h = sc.nextInt();\n\t\t\tint r = sc.nextInt();\n\t\t\tif (h+r == 0) {\n\t\t\t\tbreak;\n\t\t\t}\n\t\t\tVector2[] home = new Vector2[h];\n\t\t\tPair[] count = new Pair[h];\n\t\t\tfor(int i=0;i<h;i++) {\n\t\t\t\tint x = sc.nextInt();\n\t\t\t\tint y = sc.nextInt();\n\t\t\t\thome[i] = new Vector2(x,y);\n\t\t\t\tcount[i] = new Pair(i,0);\n\t\t\t}\n\t\t\tint u = sc.nextInt();\n\t\t\tint m = sc.nextInt();\n\t\t\tint s = sc.nextInt();\n\t\t\tdouble du = Math.toRadians(sc.nextInt())/2;\n\t\t\tdouble dm = Math.toRadians(sc.nextInt())/2;\n\t\t\tdouble ds = Math.toRadians(sc.nextInt())/2;\n\t\t\tVector2[] posU = new Vector2[u];\n\t\t\tVector2[] posM = new Vector2[m];\n\t\t\tVector2[] posS = new Vector2[s];\n\t\t\tfor(int i=0;i<u;i++) {\n\t\t\t\tint x = sc.nextInt();\n\t\t\t\tint y = sc.nextInt();\n\t\t\t\tposU[i] = new Vector2(x,y);\n\t\t\t}\n\t\t\tfor(int i=0;i<m;i++) {\n\t\t\t\tint x = sc.nextInt();\n\t\t\t\tint y = sc.nextInt();\n\t\t\t\tposM[i] = new Vector2(x,y);\n\t\t\t}\n\t\t\tfor(int i=0;i<s;i++) {\n\t\t\t\tint x = sc.nextInt();\n\t\t\t\tint y = sc.nextInt();\n\t\t\t\tposS[i] = new Vector2(x,y);\n\t\t\t}\n\t\t\tfor(int i=0;i<r;i++) {\n\t\t\t\tint w = sc.nextInt();\n\t\t\t\tint a = sc.nextInt();\n\t\t\t\tVector2 wind = new Vector2(Math.cos(Math.toRadians(w)),Math.sin(Math.toRadians(w)));\n\t\t\t\tfor(int j=0;j<h;j++) {\n\t\t\t\t\tif (intersect(posU, wind, a, du, home[j])) {\n\t\t\t\t\t\tcontinue;\n\t\t\t\t\t}\n\t\t\t\t\tif (intersect(posM, wind, a, dm, home[j])) {\n\t\t\t\t\t\tcontinue;\n\t\t\t\t\t}\n\t\t\t\t\tif (intersect(posS, wind, a, ds, home[j])) {\n\t\t\t\t\t\tcontinue;\n\t\t\t\t\t}\n\t\t\t\t\tif (!intersect(ZERO,wind,a,du,home[j])) {\n\t\t\t\t\t\tcontinue;\n\t\t\t\t\t}\n\t\t\t\t\tcount[j].b++;\n\t\t\t\t}\n\t\t\t}\n\t\t\tArrays.sort(count,new Comparator<Pair>() {\n\t\t\t\tpublic int compare(Pair o1, Pair o2) {\n\t\t\t\t\treturn Integer.compare(o1.b, o2.b);\n\t\t\t\t}\n\t\t\t});\n\t\t\tint max = count[h-1].b;\n\t\t\tif (max == 0) {\n\t\t\t\tSystem.out.println(\"NA\");\n\t\t\t}else{\n\t\t\t\tArrayList<Integer> ans = new ArrayList<>();\n\t\t\t\tfor(int i=0;i<h;i++) {\n\t\t\t\t\tif (count[i].b == max) {\n\t\t\t\t\t\tans.add(count[i].a);\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t\tStringBuilder sb = new StringBuilder();\n\t\t\t\tfor(int i=0;i<ans.size();i++) {\n\t\t\t\t\tsb.append(ans.get(i)+1);\n\t\t\t\t\tif (i!=ans.size()-1) {\n\t\t\t\t\t\tsb.append(\" \");\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t\tSystem.out.println(sb);\n\t\t\t}\n\t\t}\n\t}\n\tpublic static boolean intersect(Vector2[] pos,Vector2 dir,double length,double ang,Vector2 r) {\n\t\tfor(Vector2 r0:pos) {\n\t\t\tif (intersect(r0, dir, length, ang, r)) {\n\t\t\t\treturn true;\n\t\t\t}\n\t\t}\n\t\treturn false;\n\t}\n\tpublic static boolean intersect(Vector2 r0,Vector2 dir,double length,double ang,Vector2 r) {\n\t\tVector2 r1 = r.subtract(r0);\n\t\treturn r1.norm() < length && dir.dot(r1.normalize()) > Math.cos(ang);\n\t}\n}\nclass Pair {\n\tint a,b;\n\tpublic Pair(int a,int b) {\n\t\tthis.a = a;\n\t\tthis.b = b;\n\t}\n\tpublic String toString() {\n\t\treturn \"(\" + a + \",\" + b + \")\";\n\t}\n}\nclass Vector2 {\n\tdouble x = 0;\n\tdouble y = 0;\n\tpublic Vector2(double x,double y) {\n\t\tthis.x = x;\n\t\tthis.y = y;\n\t}\n\tpublic double dot(Vector2 v) {\n\t\treturn this.x*v.x+this.y*v.y;\n\t}\n\tpublic double cross(Vector2 v) {\n\t\treturn this.x*v.y-this.y*v.x;\n\t}\n\tpublic Vector2 add(Vector2 v) {\n\t\treturn new Vector2(this.x+v.x,this.y+v.y);\n\t}\n\tpublic Vector2 subtract(Vector2 v) {\n\t\treturn new Vector2(this.x-v.x,this.y-v.y);\n\t}\n\tpublic Vector2 multiply(double k) {\n\t\treturn new Vector2(k*this.x,k*this.y);\n\t}\n\tpublic Vector2 divide(double k) {\n\t\treturn new Vector2(x/k,y/k);\n\t}\n\tpublic double norm() {\n\t\treturn Math.sqrt(x*x+y*y);\n\t}\n\tpublic Vector2 normalize() {\n\t\treturn this.divide(norm());\n\t}\n\tpublic String toString() {\n\t\treturn this.x + \" \" + this.y;\n\t}\n}"
  },
  {
    "language": "C#",
    "code": "using System;\nusing System.Collections.Generic;\nusing System.Linq;\nusing System.Text;\n\nnamespace _0269\n{\n    class Program\n    {\n        enum TreeType { Plam, Peach, Cherry }\n\n        class House\n        {\n            public int ID { get; set; }\n            public int X { get; set; }\n            public int Y { get; set; }\n            public int Days { get; set; }\n            public House(int id, int[] vs) { ID = id; X = vs[0]; Y = vs[1]; }\n        }\n\n        class Tree\n        {\n            public TreeType Type { get; set; }\n            public int X { get; set; }\n            public int Y { get; set; }\n            public Tree(TreeType type, int[] vs) { Type = type; X = vs[0]; Y = vs[1]; }\n        }\n\n        class Wind\n        {\n            public int Direction { get; set; }\n            public int Length { get; set; }\n            public Wind(int[] vs) { Direction = vs[0]; Length = vs[1]; }\n        }\n\n        static House[] houses;\n        static Tree myPlam;\n        static Tree[] trees;\n        static Dictionary<TreeType, int> angles;\n        static Wind[] winds;\n\n        static void Main(string[] args)\n        {\n            myPlam = new Tree(TreeType.Plam, new int[] { 0, 0 });\n            while (true)\n            {\n                int[] hr = RArInt();\n                if (hr.Sum() == 0) break;\n                Init(hr);\n                CalcReachDays();\n                int maxDay = houses.Max(x => x.Days);\n                Console.WriteLine(maxDay == 0 ? \"NA\" : WAr(houses.Where(x => x.Days == maxDay).Select(x => x.ID).OrderBy(x => x)));\n            }\n        }\n\n        private static void Init(int[] hr)\n        {\n            int h = hr[0], r = hr[1];\n\n            houses = new House[h];\n            for (int i = 0; i < h; i++) houses[i] = new House(i + 1, RArInt());\n\n            int[] ums = RArInt();\n            int TreeTypeCnt = Enum.GetNames(typeof(TreeType)).Length;\n\n            trees = new Tree[ums.Take(TreeTypeCnt).Sum()];\n            angles = new Dictionary<TreeType, int>();\n\n            int idx = 0;\n            for (int i = 0; i < TreeTypeCnt; i++)\n            {\n                for (int j = 0; j < ums[i]; j++)\n                {\n                    trees[idx] = new Tree((TreeType)i, RArInt());\n                    idx++;\n                }\n                angles.Add((TreeType)i, ums[TreeTypeCnt + i]);\n            }\n\n            winds = new Wind[r];\n            for (int i = 0; i < r; i++) winds[i] = new Wind(RArInt());\n        }\n\n        private static void CalcReachDays()\n        {\n            foreach (var wind in winds)\n            {\n                foreach (var house in houses)\n                {\n                    if (CanReachOnlyMyPlam(wind, house)) house.Days++;\n                }\n            }\n        }\n\n        private static bool CanReachOnlyMyPlam(Wind wind, House house)\n        {\n            if (!CanReachflavor(wind, house, myPlam)) return false;\n            foreach (var tree in trees)\n            {\n                if (CanReachflavor(wind, house, tree)) return false;\n            }\n            return true;\n        }\n\n        private static bool CanReachflavor(Wind wind, House house, Tree tree)\n        {\n            Vector vt = new Vector(tree.X, tree.Y);\n            Vector vh = new Vector(house.X, house.Y) - vt;\n            if (vh.LengthSquared > Math.Pow(wind.Length, 2)) return false;\n\n            Vector v1 = Vector.Rotation(new Vector(wind.Length, 0), wind.Direction - angles[tree.Type] / 2);\n            Vector v2 = Vector.Rotation(new Vector(wind.Length, 0), wind.Direction + angles[tree.Type] / 2);\n            return Vector.CrossProduct(v1, vh) >= 0 && Vector.CrossProduct(vh, v2) >= 0;\n        }\n\n        static string RSt() { return Console.ReadLine(); }\n        static int RInt() { return int.Parse(Console.ReadLine().Trim()); }\n        static long RLong() { return long.Parse(Console.ReadLine().Trim()); }\n        static double RDouble() { return double.Parse(Console.ReadLine()); }\n        static string[] RArSt(char sep = ' ') { return Console.ReadLine().Trim().Split(sep); }\n        static int[] RArInt(char sep = ' ') { return Array.ConvertAll(Console.ReadLine().Trim().Split(sep), e => int.Parse(e)); }\n        static long[] RArLong(char sep = ' ') { return Array.ConvertAll(Console.ReadLine().Trim().Split(sep), e => long.Parse(e)); }\n        static double[] RArDouble(char sep = ' ') { return Array.ConvertAll(Console.ReadLine().Trim().Split(sep), e => double.Parse(e)); }\n        static string WAr<T>(IEnumerable<T> array, string sep = \" \") { return string.Join(sep, array.Select(x => x.ToString()).ToArray()); }\n    }\n\n    public partial struct Vector : IFormattable\n    {\n\n        #region Internal Fields\t\n        internal double _x;\n        internal double _y;\n        #endregion Internal Fields\t\n\n        #region Public Properties\t\n        public double X { get { return _x; } set { _x = value; } }\n        public double Y { get { return _y; } set { _y = value; } }\n        #endregion Public Properties\n\n        #region Constructors\n        public Vector(double x, double y) { _x = x; _y = y; }\n        public Vector(double[] line) { _x = line[0]; _y = line[1]; }\n        #endregion Constructors\n\n        #region Public Methods\t\n        public static bool operator ==(Vector vector1, Vector vector2) { return vector1.X == vector2.X && vector1.Y == vector2.Y; }\n        public static bool operator !=(Vector vector1, Vector vector2) { return !(vector1 == vector2); }\n        public static bool Equals(Vector vector1, Vector vector2) { return vector1.X.Equals(vector2.X) && vector1.Y.Equals(vector2.Y); }\n        public override bool Equals(object o)\n        {\n            if ((null == o) || !(o is Vector)) return false;\n            Vector value = (Vector)o;\n            return Vector.Equals(this, value);\n        }\n        public bool Equals(Vector value) { return Vector.Equals(this, value); }\n        public override int GetHashCode() { return X.GetHashCode() ^ Y.GetHashCode(); }\n        #endregion Public Methods\t\n\n        #region Internal Properties\t\n        public override string ToString() { return ConvertToString(null /* format string */, null /* format provider */); }\n        public string ToString(IFormatProvider provider) { return ConvertToString(null /* format string */, provider); }\n        string IFormattable.ToString(string format, IFormatProvider provider) { return ConvertToString(format, provider); }\n        internal string ConvertToString(string format, IFormatProvider provider)\n        {\n            char separator = ' ';\n            return String.Format(provider, \"{1:\" + format + \"}{0}{2:\" + format + \"}\", separator, _x, _y);\n        }\n        #endregion Internal Properties\t\n\n        #region Public Methods\n\n        public double Length { get { return Math.Sqrt(_x * _x + _y * _y); } }\n        public double LengthSquared { get { return _x * _x + _y * _y; } }\n        public void Normalize()\n        {\n            this /= Math.Max(Math.Abs(_x), Math.Abs(_y));\n            this /= Length;\n        }\n\n        public static double CrossProduct(Vector vector1, Vector vector2) { return vector1._x * vector2._y - vector1._y * vector2._x; }\n        public static double AngleBetween(Vector vector1, Vector vector2)\n        {\n            double sin = vector1._x * vector2._y - vector2._x * vector1._y;\n            double cos = vector1._x * vector2._x + vector1._y * vector2._y;\n            return Math.Atan2(sin, cos) * (180 / Math.PI);\n        }\n\n        public static Vector Rotation(Vector v, double angle) { return Rotation(v, angle, new Vector(0, 0)); }\n        public static Vector Rotation(Vector v, double angle, Vector basePoint)\n        {\n            double rad = angle * Math.PI / 180;\n            Vector res = new Vector();\n            res.X = (v.X - basePoint.X) * Math.Cos(rad) - (v.Y - basePoint.Y) * Math.Sin(rad) + basePoint.X;\n            res.Y = (v.X - basePoint.X) * Math.Sin(rad) + (v.Y - basePoint.Y) * Math.Cos(rad) + basePoint.Y;\n            return res;\n        }\n\n        /// <summary>\n        /// 線分ABと点Pの距離を求める\n        /// </summary>\n        /// <param name=\"sx\">線分ABの始点x座標</param>\n        /// <param name=\"sy\">線分ABの始点y座標</param>\n        /// <param name=\"ex\">線分ABの終点x座標</param>\n        /// <param name=\"ey\">線分ABの終点y座標</param>\n        /// <param name=\"px\">地点Pのx座標</param>\n        /// <param name=\"py\">地点Pのy座標</param>\n        /// <returns></returns>\n        public static double RangeOfPointAndLineSegment(double sx, double sy, double ex, double ey, double px, double py)\n        {\n            Vector A = new Vector(sx, sy);\n            Vector B = new Vector(ex, ey);\n            Vector P = new Vector(px, py);\n            return (P - CalcClosestPointOnLineSegment(A, B, P)).Length;\n        }\n\n        private static Vector CalcClosestPointOnLineSegment(Vector A, Vector B, Vector P)\n        {\n\n            Vector a = B - A;\n            Vector b = P - A;\n            double r = (a * b) / (a * a);\n\n            if (r <= 0) return A;\n            else if (r >= 1) return B;\n            else return A + r * a;\n        }\n\n        /// <summary>\n        /// 線分ABと線分CDの交差判定\n        /// </summary>\n        /// <param name=\"ax\">線分ABの始点x座標</param>\n        /// <param name=\"ay\">線分ABの始点y座標</param>\n        /// <param name=\"bx\">線分ABの終点x座標</param>\n        /// <param name=\"by\">線分ABの終点y座標</param>\n        /// <param name=\"cx\">線分CDの始点x座標</param>\n        /// <param name=\"cy\">線分CDの始点y座標</param>\n        /// <param name=\"dx\">線分CDの終点x座標</param>\n        /// <param name=\"dy\">線分CDの終点y座標</param>\n        /// <param name=\"px\">交点Pのx座標</param>\n        /// <param name=\"py\">交点Pのy座標</param>\n        /// <returns></returns>\n        public static bool IsLineSegmentCrossed(double ax, double ay, double bx, double by, double cx, double cy, double dx, double dy, out double px, out double py)\n        {\n            Vector a = new Vector(ax, ay);\n            Vector b = new Vector(bx, by);\n            Vector c = new Vector(cx, cy);\n            Vector d = new Vector(dx, dy);\n\n            px = 0;\n            py = 0;\n\n            if ((CrossProduct(b - a, c - a) * CrossProduct(b - a, d - a) < 1e-10) &&\n                (CrossProduct(d - c, a - c) * CrossProduct(d - c, b - c) < 1e-10))\n            {\n\n                Vector cd = d - c;\n                double d1 = Math.Abs(CrossProduct(cd, a - c));\n                double d2 = Math.Abs(CrossProduct(cd, b - c));\n                double t = d1 / (d1 + d2);\n\n                px = (a + (b - a) * t).X;\n                py = (a + (b - a) * t).Y;\n\n                return true;\n            }\n            else\n            {\n                return false;\n            }\n\n        }\n\n        /// <summary>\n        /// 四角形ABCDと点Pの内包判定\n        /// ※四角形ABCDは凸であることが前提\n        /// </summary>\n        /// <param name=\"ax\">点Aのx座標</param>\n        /// <param name=\"ay\">点Aのy座標</param>\n        /// <param name=\"bx\">点Bのx座標/param>\n        /// <param name=\"by\">点Bのy座標</param>\n        /// <param name=\"cx\">点Cのx座標</param>\n        /// <param name=\"cy\">点Cのy座標</param>\n        /// <param name=\"dx\">点Dのx座標</param>\n        /// <param name=\"dy\">点Dのy座標</param>\n        /// <param name=\"px\">点Pのx座標</param>\n        /// <param name=\"py\">点Pのy座標</param>\n        /// <returns></returns>\n        public static bool IsQuadrangleIntersected(double ax, double ay, double bx, double by, double cx, double cy, double dx, double dy, double px, double py)\n        {\n            Vector a = new Vector(ax, ay);\n            Vector b = new Vector(bx, by);\n            Vector c = new Vector(cx, cy);\n            Vector d = new Vector(dx, dy);\n            Vector p = new Vector(px, py);\n\n            double c1 = Vector.CrossProduct(b - a, p - b);\n            double c2 = Vector.CrossProduct(c - b, p - c);\n            double c3 = Vector.CrossProduct(d - c, p - d);\n            double c4 = Vector.CrossProduct(a - d, p - a);\n\n            return (c1 > 0 && c2 > 0 && c3 > 0 && c4 > 0) || (c1 < 0 && c2 < 0 && c3 < 0 && c4 < 0);\n\n        }\n\n\n        #endregion Public Methods\n\n        #region Public Operators\n\n        public static Vector operator -(Vector vector) { return new Vector(-vector._x, -vector._y); }\n        public void Negate() { _x = -_x; _y = -_y; }\n        public static Vector operator +(Vector vector1, Vector vector2) { return new Vector(vector1._x + vector2._x, vector1._y + vector2._y); }\n        public static Vector Add(Vector vector1, Vector vector2) { return new Vector(vector1._x + vector2._x, vector1._y + vector2._y); }\n        public static Vector operator -(Vector vector1, Vector vector2) { return new Vector(vector1._x - vector2._x, vector1._y - vector2._y); }\n        public static Vector Subtract(Vector vector1, Vector vector2) { return new Vector(vector1._x - vector2._x, vector1._y - vector2._y); }\n        public static Vector operator *(Vector vector, double scalar) { return new Vector(vector._x * scalar, vector._y * scalar); }\n        public static Vector Multiply(Vector vector, double scalar) { return new Vector(vector._x * scalar, vector._y * scalar); }\n        public static Vector operator *(double scalar, Vector vector) { return new Vector(vector._x * scalar, vector._y * scalar); }\n        public static Vector Multiply(double scalar, Vector vector) { return new Vector(vector._x * scalar, vector._y * scalar); }\n        public static Vector operator /(Vector vector, double scalar) { return vector * (1.0 / scalar); }\n        public static Vector Divide(Vector vector, double scalar) { return vector * (1.0 / scalar); }\n        public static double operator *(Vector vector1, Vector vector2) { return vector1._x * vector2._x + vector1._y * vector2._y; }\n        public static double Multiply(Vector vector1, Vector vector2) { return vector1._x * vector2._x + vector1._y * vector2._y; }\n        public static double Determinant(Vector vector1, Vector vector2) { return vector1._x * vector2._y - vector1._y * vector2._x; }\n\n        #endregion Public Operators\n    }\n}\n\n"
  },
  {
    "language": "Ruby",
    "code": "def func tx, ty, tk, wd, wl, hx, hy\n    result = false\n    w0 = Math.atan2(hy - ty, hx - tx)\n    wrad = wd / 180 * Math::PI\n    diff = [(w0 - wrad).abs, 2 * Math::PI - (w0 - wrad).abs].min\n    drad = tk / 360 * Math::PI\n    result = true if (tx - hx) ** 2 + (ty - hy) ** 2 <= wl ** 2 && diff <= drad\n    result\nend\n\nwhile true\n    h, r = gets.chomp.split.map(&:to_i)\n    break if [h, r] == [0, 0]\n    houses = []\n    h.times{houses << gets.chomp.split.map(&:to_f)}\n    arr = gets.chomp.split.map(&:to_i)\n    3.upto(5){|i| arr[i] = arr[i].to_f}\n    trees = []\n    (arr[0]+arr[1]+ arr[2]).times{|i|\n        line = gets.chomp.split.map(&:to_f)\n        kind = arr[5]\n        if i < arr[0].to_i\n            kind = arr[3]\n        elsif i < arr[0] + arr[1]\n            kind = arr[4]\n        end\n        line << kind\n        trees << line\n    }\n\n    arr2 = Array.new(h, 0)\n    winds = []\n    r.times{winds << gets.chomp.split.map(&:to_f)}\n    winds.each{|d, l|\n        houses.each_with_index{|item, hi|\n            if func(0.0, 0.0, arr[3], d, l, item[0], item[1])\n                kaori = true\n                trees.each{|tx, ty, tk|\n                    if func(tx, ty, tk, d, l, item[0], item[1])\n                        kaori = false\n                        #break\n                    end\n                }\n                arr2[hi] += 1 if kaori\n            end\n        }\n    }\n    if arr2.max == 0\n        puts \"NA\"\n    else\n        arr3 = []\n        arr2.each_with_index{|x, i| arr3 << i + 1 if x == arr2.max}\n        puts arr3.sort.join(\" \")\n    end\nend\n"
  },
  {
    "language": "Ruby",
    "code": "### constants\n\nEPS = 1.0e-9\n\n### subroutines\n\ndef dist2(p0, p1)\n  (p1[0] - p0[0]) ** 2 + (p1[1] - p0[1]) ** 2\nend\n\ndef o_prod(v0, v1)\n  v0[0] * v1[1] - v0[1] * v1[0]\nend\n\ndef deg_inside?(p0, p1, d0, d1)\n  rad0 = d0 * Math::PI / 180\n  rad1 = d1 * Math::PI / 180\n\n  dv0 = [Math.cos(rad0), Math.sin(rad0)]\n  dv1 = [Math.cos(rad1), Math.sin(rad1)]\n\n  pv = [p1[0] - p0[0], p1[1] - p0[1]]\n\n  o_prod(dv0, pv) >= -EPS && o_prod(dv1, pv) <= EPS\nend\n\ndef reach?(src, h, w, d)\n  dist2(src, h) <= (w[1] ** 2 + EPS) &&\n    deg_inside?(src, h, w[0] - 0.5 * d, w[0] + 0.5 * d)\nend\n\n### main\n\nwhile true\n  hn, rn = gets.strip.split(' ').map{|s| s.to_i}\n  break if hn == 0 && rn == 0\n\n  houses = hn.times.map{gets.strip.split(' ').map{|s| s.to_f}}\n  #p houses\n\n  un, mn, sn, du, dm, ds = gets.strip.split(' ').map{|s| s.to_i}\n  #p [u, m, s, du, dm, ds]\n\n  ume = un.times.map{gets.strip.split(' ').map{|s| s.to_f}}\n  momo = mn.times.map{gets.strip.split(' ').map{|s| s.to_f}}\n  sakura = sn.times.map{gets.strip.split(' ').map{|s| s.to_f}}\n  #p ['u', ume]\n  #p ['m', momo]\n  #p ['s', sakura]\n\n  winds = rn.times.map{gets.strip.split(' ').map{|s| s.to_f}}\n  #p winds\n\n  max_days = 0\n  max_houses = []\n\n  for hi in (0...hn)\n    h = houses[hi]\n    days = 0\n\n    for w in winds\n      if reach?([0, 0], h, w, du)\n        ok = true\n\n        for u in ume\n          if reach?(u, h, w, du)\n            ok = false\n            break\n          end\n        end\n        break if ! ok\n\n        for m in momo\n          if reach?(m, h, w, dm)\n            ok = false\n            break\n          end\n        end\n        break if ! ok\n\n        for s in sakura\n          if reach?(s, h, w, ds)\n            ok = false\n            break\n          end\n        end\n        break if ! ok\n\n        days += 1\n      end\n    end\n\n    if max_days < days\n      max_days = days\n      max_houses = [(hi + 1)]\n    elsif max_days == days\n      max_houses << (hi + 1)\n    end\n  end\n\n  if max_days == 0\n    puts 'NA'\n  else\n    puts max_houses.join(' ')\n  end\nend"
  },
  {
    "language": "Ruby",
    "code": "### subroutines\n\ndef pts2deg(p0, p1)\n  deg = 180 * Math.atan2(p1[1] - p0[1], p1[0] - p0[0]) / Math::PI\n  deg += 360 if deg < 0\n  deg\nend\n\ndef dist2(p0, p1)\n  (p1[0] - p0[0]) ** 2 + (p1[1] - p0[1]) ** 2\nend\n\ndef reach?(src, h, w, d)\n  return false if dist2(src, h) > ((w[1] + 0.01) ** 2)\n\n  deg = pts2deg(src, h)\n  deg0 = w[0] - d / 2\n  deg1 = w[0] + d / 2\n\n  (deg0 <= deg && deg <= deg1) ||\n    (deg0 <= (deg - 360) && (deg - 360) <= deg1) ||\n    (deg0 <= (deg + 360) && (deg + 360) <= deg1)\nend\n\n### main\n\nwhile true\n  hn, rn = gets.strip.split(' ').map{|s| s.to_i}\n  break if hn == 0 && rn == 0\n\n  houses = hn.times.map{gets.strip.split(' ').map{|s| s.to_i}}\n  #p houses\n\n  un, mn, sn, du, dm, ds = gets.strip.split(' ').map{|s| s.to_i}\n  #p [u, m, s, du, dm, ds]\n\n  ume = un.times.map{gets.strip.split(' ').map{|s| s.to_i}}\n  momo = mn.times.map{gets.strip.split(' ').map{|s| s.to_i}}\n  sakura = sn.times.map{gets.strip.split(' ').map{|s| s.to_i}}\n  #p ['u', ume]\n  #p ['m', momo]\n  #p ['s', sakura]\n\n  winds = rn.times.map{gets.strip.split(' ').map{|s| s.to_i}}\n  #p winds\n\n  max_days = 0\n  max_houses = []\n\n  for hi in (0...hn)\n    h = houses[hi]\n    days = 0\n\n    for w in winds\n      if reach?([0, 0], h, w, du)\n        ok = true\n\n        for u in ume\n          if reach?(u, h, w, du)\n            ok = false\n            break\n          end\n        end\n        break if ! ok\n\n        for m in momo\n          if reach?(m, h, w, dm)\n            ok = false\n            break\n          end\n        end\n        break if ! ok\n\n        for s in sakura\n          if reach?(s, h, w, ds)\n            ok = false\n            break\n          end\n        end\n        break if ! ok\n\n        days += 1\n      end\n    end\n\n    if max_days < days\n      max_days = days\n      max_houses = [(hi + 1)]\n    elsif max_days == days\n      max_houses << (hi + 1)\n    end\n  end\n\n  if max_days == 0\n    puts 'NA'\n  else\n    puts max_houses.join(' ')\n  end\nend"
  },
  {
    "language": "Ruby",
    "code": "### subroutines\n\ndef pts2deg(p0, p1)\n  deg = 180 * Math.atan2(p1[1] - p0[1], p1[0] - p0[0]) / Math::PI\n  deg += 360 if deg < 0\n  deg\nend\n\ndef dist2(p0, p1)\n  (p1[0] - p0[0]) ** 2 + (p1[1] - p0[1]) ** 2\nend\n\ndef reach?(src, h, w, d)\n  return false if dist2(src, h) > (w[1] ** 2)\n\n  deg = pts2deg(src, h)\n  deg0 = w[0] - d / 2\n  deg1 = w[0] + d / 2\n\n  (deg0 <= deg && deg <= deg1) ||\n    (deg0 <= (deg - 360) && (deg - 360) <= deg1) ||\n    (deg0 <= (deg + 360) && (deg + 360) <= deg1)\nend\n\n### main\n\nwhile true\n  hn, rn = gets.strip.split(' ').map{|s| s.to_i}\n  break if hn == 0 && rn == 0\n\n  houses = hn.times.map{gets.strip.split(' ').map{|s| s.to_i}}\n  #p houses\n\n  un, mn, sn, du, dm, ds = gets.strip.split(' ').map{|s| s.to_i}\n  #p [u, m, s, du, dm, ds]\n\n  ume = un.times.map{gets.strip.split(' ').map{|s| s.to_i}}\n  momo = mn.times.map{gets.strip.split(' ').map{|s| s.to_i}}\n  sakura = sn.times.map{gets.strip.split(' ').map{|s| s.to_i}}\n  #p ['u', ume]\n  #p ['m', momo]\n  #p ['s', sakura]\n\n  winds = rn.times.map{gets.strip.split(' ').map{|s| s.to_i}}\n  #p winds\n\n  max_days = 0\n  max_houses = []\n\n  for hi in (0...hn)\n    h = houses[hi]\n    days = 0\n\n    for w in winds\n      if reach?([0, 0], h, w, du)\n        ok = true\n\n        for u in ume\n          if reach?(u, h, w, du)\n            ok = false\n            break\n          end\n        end\n        break if ! ok\n\n        for m in momo\n          if reach?(m, h, w, dm)\n            ok = false\n            break\n          end\n        end\n        break if ! ok\n\n        for s in sakura\n          if reach?(s, h, w, ds)\n            ok = false\n            break\n          end\n        end\n        break if ! ok\n\n        days += 1\n      end\n    end\n\n    if max_days < days\n      max_days = days\n      max_houses = [(hi + 1)]\n    elsif max_days == days\n      max_houses << (hi + 1)\n    end\n  end\n\n  if max_days == 0\n    puts 'NA'\n  else\n    puts max_houses.join(' ')\n  end\nend"
  },
  {
    "language": "Ruby",
    "code": "### constants\n\nEPS = 1.0e-8\n\n### subroutines\n\ndef dist2(p0, p1)\n  (p1[0] - p0[0]) ** 2 + (p1[1] - p0[1]) ** 2\nend\n\ndef o_prod(v0, v1)\n  v0[0] * v1[1] - v0[1] * v1[0]\nend\n\ndef deg_inside?(p0, p1, d0, d1)\n  rad0 = d0 * Math::PI / 180\n  rad1 = d1 * Math::PI / 180\n\n  dv0 = [Math.cos(rad0), Math.sin(rad0)]\n  dv1 = [Math.cos(rad1), Math.sin(rad1)]\n\n  pv = [p1[0] - p0[0], p1[1] - p0[1]]\n\n  o_prod(dv0, pv) >= -EPS && o_prod(dv1, pv) <= EPS\nend\n\ndef reach?(src, h, w, d)\n  dist2(src, h) <= (w[1] ** 2 + EPS) &&\n    deg_inside?(src, h, w[0] - 0.5 * d, w[0] + 0.5 * d)\nend\n\n### main\n\nwhile true\n  hn, rn = gets.strip.split(' ').map{|s| s.to_i}\n  break if hn == 0 && rn == 0\n\n  houses = hn.times.map{gets.strip.split(' ').map{|s| s.to_f}}\n  #p houses\n\n  un, mn, sn, du, dm, ds = gets.strip.split(' ').map{|s| s.to_i}\n  #p [u, m, s, du, dm, ds]\n\n  ume = un.times.map{gets.strip.split(' ').map{|s| s.to_f}}\n  momo = mn.times.map{gets.strip.split(' ').map{|s| s.to_f}}\n  sakura = sn.times.map{gets.strip.split(' ').map{|s| s.to_f}}\n  #p ['u', ume]\n  #p ['m', momo]\n  #p ['s', sakura]\n\n  winds = rn.times.map{gets.strip.split(' ').map{|s| s.to_f}}\n  #p winds\n\n  max_days = 0\n  max_houses = []\n\n  for hi in (0...hn)\n    h = houses[hi]\n    days = 0\n\n    for w in winds\n      if reach?([0, 0], h, w, du)\n        ok = true\n\n        for u in ume\n          if reach?(u, h, w, du)\n            ok = false\n            break\n          end\n        end\n        break if ! ok\n\n        for m in momo\n          if reach?(m, h, w, dm)\n            ok = false\n            break\n          end\n        end\n        break if ! ok\n\n        for s in sakura\n          if reach?(s, h, w, ds)\n            ok = false\n            break\n          end\n        end\n        break if ! ok\n\n        days += 1\n      end\n    end\n\n    if max_days < days\n      max_days = days\n      max_houses = [(hi + 1)]\n    elsif max_days == days\n      max_houses << (hi + 1)\n    end\n  end\n\n  if max_days == 0\n    puts 'NA'\n  else\n    puts max_houses.join(' ')\n  end\nend"
  },
  {
    "language": "Ruby",
    "code": "def func tx, ty, tk, wd, wl, hx, hy\n    result = false\n    w0 = Math.atan2(hy - ty, hx - tx)\n    w0 += 2 * Math::PI if w0 < 0\n    wrad = wd / 180 * Math::PI\n    diff = [(w0 - wrad).abs, 2 * Math::PI - (w0 - wrad).abs].min\n    drad = tk / 360 * Math::PI\n    result = true if (tx - hx) ** 2 + (ty - hy) ** 2 <= wl ** 2 && diff <= drad\n    result\nend\n\nwhile true\n    h, r = gets.chomp.split.map(&:to_i)\n    break if [h, r] == [0, 0]\n    houses = []\n    h.times{houses << gets.chomp.split.map(&:to_f)}\n    arr = gets.chomp.split.map(&:to_i)\n    3.upto(5){|i| arr[i] = arr[i].to_f}\n    trees = []\n    (arr[0]+arr[1]+ arr[2]).times{|i|\n        line = gets.chomp.split.map(&:to_f)\n        kind = arr[5]\n        if i < arr[0].to_i\n            kind = arr[3]\n        elsif i < arr[0] + arr[1]\n            kind = arr[4]\n        end\n        line << kind\n        trees << line\n    }\n\n    arr2 = Array.new(h, 0)\n    winds = []\n    r.times{winds << gets.chomp.split.map(&:to_f)}\n    winds.each{|d, l|\n        houses.each_with_index{|item, hi|\n            if func(0.0, 0.0, arr[3], d, l, item[0], item[1])\n                kaori = true\n                trees.each{|tx, ty, tk|\n                    if func(tx, ty, tk, d, l, item[0], item[1])\n                        kaori = false\n                        break\n                    end\n                }\n                arr2[hi] += 1 if kaori\n            end\n        }\n    }\n    if arr2.max == 0\n        puts \"NA\"\n    else\n        arr3 = []\n        arr2.each_with_index{|x, i| arr3 << i + 1 if x == arr2.max}\n        puts arr3.sort.join(\" \")\n    end\nend\n\n"
  },
  {
    "language": "Ruby",
    "code": "### subroutines\n\ndef dist2(p0, p1)\n  (p1[0] - p0[0]) ** 2 + (p1[1] - p0[1]) ** 2\nend\n\ndef o_prod(v0, v1)\n  v0[0] * v1[1] - v0[1] * v1[0]\nend\n\ndef deg_inside?(p0, p1, d0, d1)\n  rad0 = d0 * Math::PI / 180\n  rad1 = d1 * Math::PI / 180\n\n  dv0 = [Math.cos(rad0), Math.sin(rad0)]\n  dv1 = [Math.cos(rad1), Math.sin(rad1)]\n\n  pv = [p1[0] - p0[0], p1[1] - p0[1]]\n\n  o_prod(dv0, pv) >= 0 && o_prod(pv, dv1) >= 0\nend\n\ndef reach?(src, h, w, d)\n  dist2(src, h) <= ((w[1] + 0.01) ** 2) &&\n    deg_inside?(src, h, w[0] - 0.5 * d, w[0] + 0.5 * d)\nend\n\n### main\n\nwhile true\n  hn, rn = gets.strip.split(' ').map{|s| s.to_i}\n  break if hn == 0 && rn == 0\n\n  houses = hn.times.map{gets.strip.split(' ').map{|s| s.to_f}}\n  #p houses\n\n  un, mn, sn, du, dm, ds = gets.strip.split(' ').map{|s| s.to_i}\n  #p [u, m, s, du, dm, ds]\n\n  ume = un.times.map{gets.strip.split(' ').map{|s| s.to_f}}\n  momo = mn.times.map{gets.strip.split(' ').map{|s| s.to_f}}\n  sakura = sn.times.map{gets.strip.split(' ').map{|s| s.to_f}}\n  #p ['u', ume]\n  #p ['m', momo]\n  #p ['s', sakura]\n\n  winds = rn.times.map{gets.strip.split(' ').map{|s| s.to_f}}\n  #p winds\n\n  max_days = 0\n  max_houses = []\n\n  for hi in (0...hn)\n    h = houses[hi]\n    days = 0\n\n    for w in winds\n      if reach?([0, 0], h, w, du)\n        ok = true\n\n        for u in ume\n          if reach?(u, h, w, du)\n            ok = false\n            break\n          end\n        end\n        break if ! ok\n\n        for m in momo\n          if reach?(m, h, w, dm)\n            ok = false\n            break\n          end\n        end\n        break if ! ok\n\n        for s in sakura\n          if reach?(s, h, w, ds)\n            ok = false\n            break\n          end\n        end\n        break if ! ok\n\n        days += 1\n      end\n    end\n\n    if max_days < days\n      max_days = days\n      max_houses = [(hi + 1)]\n    elsif max_days == days\n      max_houses << (hi + 1)\n    end\n  end\n\n  if max_days == 0\n    puts 'NA'\n  else\n    puts max_houses.join(' ')\n  end\nend"
  },
  {
    "language": "Python",
    "code": "from math import *\ndef check(hx,hy,fx,fy,df,w,a):\n\td = ((hx-fx)**2 + (hy-fy)**2)**0.5\n\tif d > a: return False\n\ttheta = acos((hx-fx)/d) + (0 if hy-fy > 0 else pi)\n\tr,l = (w-df/2.0)*pi/180,(w+df/2.0)*pi/180\n\treturn True if r <= theta <= l or r-2*pi <= theta <= l-2*pi else False\n\nwhile 1:\n\tH,R = map(int,raw_input().split())\n\tif H == 0: break\n\thxy = [map(int,raw_input().split()) for i in range(H)]\n\tU,M,S,du,dm,ds = map(int,raw_input().split())\n\tdxy = [map(int,raw_input().split())+[du] for i in range(U)]\n\tmxy = [map(int,raw_input().split())+[dm] for i in range(M)]\n\tsxy = [map(int,raw_input().split())+[ds] for i in range(S)]\n\tfxy = dxy+mxy+sxy\n\tcount = [0]*H\n\tfor i in range(R):\n\t\tw,a = map(int,raw_input().split())\n\t\tfor j in range(H):\n\t\t\thx,hy = hxy[j]\n\t\t\tif not check(hx,hy,0,0,du,w,a):\n\t\t\t\tcontinue\n\t\t\tfor fx,fy,df in fxy:\n\t\t\t\tif check(hx,hy,fx,fy,df,w,a):\n\t\t\t\t\tbreak\n\t\t\telse:\n\t\t\t\tcount[j] += 1\n\tmx = max(count)\n\tif mx > 0:\n\t\tprint \" \".join(map(str,[i+1 for i in range(H) if count[i] == mx]))\n\telse:\n\t\tprint \"NA\""
  },
  {
    "language": "Python",
    "code": "from math import *\neps = 1e-7\ndef check(hx,hy,fx,fy,df,w,a):\n\td = ((hx-fx)**2 + (hy-fy)**2)**0.5\n\tif d-a > -0.001: return False\n\ttheta = (acos((hx-fx)/d) if hy-fy >= 0 else 2*pi-acos((hx-fx)/d))\n\tr,l = (w-df/2.0)*pi/180,(w+df/2.0)*pi/180\n\treturn True if r+eps < theta < l-eps or r-2*pi+eps < theta < l-2*pi-eps else False\n\nwhile 1:\n\tH,R = map(int,raw_input().split())\n\tif H == 0: break\n\thxy = [map(int,raw_input().split()) for i in range(H)]\n\tU,M,S,du,dm,ds = map(int,raw_input().split())\n\tdxy = [map(int,raw_input().split())+[du] for i in range(U)]\n\tmxy = [map(int,raw_input().split())+[dm] for i in range(M)]\n\tsxy = [map(int,raw_input().split())+[ds] for i in range(S)]\n\tfxy = dxy+mxy+sxy\n\tcount = [0]*H\n\tfor i in range(R):\n\t\tw,a = map(int,raw_input().split())\n\t\tfor j in range(H):\n\t\t\thx,hy = hxy[j]\n\t\t\tif not check(hx,hy,0,0,du,w,a):\n\t\t\t\tcontinue\n\t\t\tfor fx,fy,df in fxy:\n\t\t\t\tif check(hx,hy,fx,fy,df,w,a):\n\t\t\t\t\tbreak\n\t\t\telse:\n\t\t\t\tcount[j] += 1\n\tmx = max(count)\n\tif mx > 0:\n\t\tprint \" \".join(map(str,[i+1 for i in range(H) if count[i] == mx]))\n\telse:\n\t\tprint \"NA\""
  },
  {
    "language": "Python",
    "code": "from math import *\ndef check(hx,hy,fx,fy,df,w,a):\n\tif ((hx-fx)**2 + (hy-fy)**2)**0.5 < a and Abs(atan2(hy-fy,hx-fx)-w) < df:\n\t\treturn True\n\telse:\n\t\treturn False\n\ndef Abs(e):\n\te = abs(e)\n\tif e > pi: e = 2*pi - e\n\treturn e\n\nwhile 1:\n\tH,R = map(int,raw_input().split())\n\tif H == 0: break\n\thxy = [map(int,raw_input().split()) for i in range(H)]\n\tU,M,S,du,dm,ds = map(int,raw_input().split())\n\tdu,dm,ds = du*pi/360,dm*pi/360,ds*pi/360\n\tdxy = [map(int,raw_input().split())+[du] for i in range(U)]\n\tmxy = [map(int,raw_input().split())+[dm] for i in range(M)]\n\tsxy = [map(int,raw_input().split())+[ds] for i in range(S)]\n\tfxy = dxy+mxy+sxy\n\tcount = [0]*H\n\tfor i in range(R):\n\t\tw,a = map(int,raw_input().split())\n\t\tw = w*pi/180\n\t\tif w > pi: w -= 2*pi\n\t\tfor j in range(H):\n\t\t\thx,hy = hxy[j]\n\t\t\tif not check(hx,hy,0,0,du,w,a):\n\t\t\t\tcontinue\n\t\t\tfor fx,fy,df in fxy:\n\t\t\t\tif check(hx,hy,fx,fy,df,w,a):\n\t\t\t\t\tbreak\n\t\t\telse:\n\t\t\t\tcount[j] += 1\n\tmx = max(count)\n\tif mx > 0:\n\t\tprint \" \".join(map(str,[i+1 for i in range(H) if count[i] == mx]))\n\telse:\n\t\tprint \"NA\""
  },
  {
    "language": "Python",
    "code": "from math import *\ndef check(hx,hy,fx,fy,df,w,a):\n\td = ((hx-fx)**2 + (hy-fy)**2)**0.5\n\tif d-a > 0.001: return False\n\ttheta = (acos((hx-fx)/d) if hy-fy >= 0 else 2*pi-acos((hx-fx)/d))\n\tr,l = (w-df/2.0)*pi/180,(w+df/2.0)*pi/180\n\treturn True if r <= theta <= l or r-2*pi <= theta <= l-2*pi else False\n\nwhile 1:\n\tH,R = map(int,raw_input().split())\n\tif H == 0: break\n\thxy = [map(int,raw_input().split()) for i in range(H)]\n\tU,M,S,du,dm,ds = map(int,raw_input().split())\n\tdxy = [map(int,raw_input().split())+[du] for i in range(U)]\n\tmxy = [map(int,raw_input().split())+[dm] for i in range(M)]\n\tsxy = [map(int,raw_input().split())+[ds] for i in range(S)]\n\tfxy = dxy+mxy+sxy\n\tcount = [0]*H\n\tfor i in range(R):\n\t\tw,a = map(int,raw_input().split())\n\t\tfor j in range(H):\n\t\t\thx,hy = hxy[j]\n\t\t\tif not check(hx,hy,0,0,du,w,a):\n\t\t\t\tcontinue\n\t\t\tfor fx,fy,df in fxy:\n\t\t\t\tif check(hx,hy,fx,fy,df,w,a):\n\t\t\t\t\tbreak\n\t\t\telse:\n\t\t\t\tcount[j] += 1\n\tmx = max(count)\n\tif mx > 0:\n\t\tprint \" \".join(map(str,[i+1 for i in range(H) if count[i] == mx]))\n\telse:\n\t\tprint \"NA\""
  },
  {
    "language": "Python",
    "code": "from math import *\ndef check(hx,hy,fx,fy,df,w,a):\n\tif ((hx-fx)**2 + (hy-fy)**2)**0.5 < a and abs(atan2(hy-fy,hx-fx)-w) < df:\n\t\treturn True\n\telse:\n\t\treturn False\n\nwhile 1:\n\tH,R = map(int,raw_input().split())\n\tif H == 0: break\n\thxy = [map(int,raw_input().split()) for i in range(H)]\n\tU,M,S,du,dm,ds = map(int,raw_input().split())\n\tdu,dm,ds = du*pi/360,dm*pi/360,ds*pi/360\n\tdxy = [map(int,raw_input().split())+[du] for i in range(U)]\n\tmxy = [map(int,raw_input().split())+[dm] for i in range(M)]\n\tsxy = [map(int,raw_input().split())+[ds] for i in range(S)]\n\tfxy = dxy+mxy+sxy\n\tcount = [0]*H\n\tfor i in range(R):\n\t\tw,a = map(int,raw_input().split())\n\t\tw = w*pi/180\n\t\tif w > pi: w -= 2*pi\n\t\tfor j in range(H):\n\t\t\thx,hy = hxy[j]\n\t\t\tif not check(hx,hy,0,0,du,w,a):\n\t\t\t\tcontinue\n\t\t\tfor fx,fy,df in fxy:\n\t\t\t\tif check(hx,hy,fx,fy,df,w,a):\n\t\t\t\t\tbreak\n\t\t\telse:\n\t\t\t\tcount[j] += 1\n\tmx = max(count)\n\tif mx > 0:\n\t\tprint \" \".join(map(str,[i+1 for i in range(H) if count[i] == mx]))\n\telse:\n\t\tprint \"NA\""
  },
  {
    "language": "Python",
    "code": "from math import *\ndef check(hx,hy,fx,fy,df,w,a):\n\td = ((hx-fx)**2 + (hy-fy)**2)**0.5\n\tif d > a: return False\n\ttheta = (acos((hx-fx)/d) if hy-fy >= 0 else 2*pi-acos((hx-fx)/d))\n\tr,l = (w-df/2.0)*pi/180,(w+df/2.0)*pi/180\n\treturn True if r <= theta <= l or r-2*pi <= theta <= l-2*pi else False\n\nwhile 1:\n\tH,R = map(int,raw_input().split())\n\tif H == 0: break\n\thxy = [map(int,raw_input().split()) for i in range(H)]\n\tU,M,S,du,dm,ds = map(int,raw_input().split())\n\tdxy = [map(int,raw_input().split())+[du] for i in range(U)]\n\tmxy = [map(int,raw_input().split())+[dm] for i in range(M)]\n\tsxy = [map(int,raw_input().split())+[ds] for i in range(S)]\n\tfxy = dxy+mxy+sxy\n\tcount = [0]*H\n\tfor i in range(R):\n\t\tw,a = map(int,raw_input().split())\n\t\tfor j in range(H):\n\t\t\thx,hy = hxy[j]\n\t\t\tif not check(hx,hy,0,0,du,w,a):\n\t\t\t\tcontinue\n\t\t\tfor fx,fy,df in fxy:\n\t\t\t\tif check(hx,hy,fx,fy,df,w,a):\n\t\t\t\t\tbreak\n\t\t\telse:\n\t\t\t\tcount[j] += 1\n\tmx = max(count)\n\tif mx > 0:\n\t\tprint \" \".join(map(str,[i+1 for i in range(H) if count[i] == mx]))\n\telse:\n\t\tprint \"NA\""
  },
  {
    "language": "Python",
    "code": "from math import atan2, degrees\n\ndef calc(dx, dy, d, w, a):\n    if dx**2 + dy**2 > a**2:\n        return 0\n    t = degrees(atan2(dy, dx))\n    for i in range(2):\n        if w - d/2 <= t + 360*i <= w + d/2:\n            return 1\n    return 0\n\nwhile 1:\n    H, R = map(int, input().split())\n    if H == R == 0:\n        break\n    HS = [list(map(int, input().split())) for i in range(H)]\n    U, M, S, du, dm, ds = map(int, input().split())\n    US = [list(map(int, input().split())) for i in range(U)]\n    MS = [list(map(int, input().split())) for i in range(M)]\n    SS = [list(map(int, input().split())) for i in range(S)]\n    ans = [0]*H\n    for k in range(R):\n        w, a = map(int, input().split())\n        for i, (x, y) in enumerate(HS):\n            if not calc(x, y, du, w, a):\n                continue\n            if (\n                    any(calc(x - x0, y - y0, du, w, a) for x0, y0 in US) or\n                    any(calc(x - x0, y - y0, dm, w, a) for x0, y0 in MS) or\n                    any(calc(x - x0, y - y0, ds, w, a) for x0, y0 in SS)\n                ):\n                continue\n            ans[i] += 1\n    m = max(ans)\n    if m:\n        res = [i+1 for i in range(H) if m == ans[i]]\n        print(*res)\n    else:\n        print(\"NA\")\n\n"
  },
  {
    "language": "Python",
    "code": "from math import *\neps = 1e-7\ndef check(hx,hy,fx,fy,df,w,a):\n\td = ((hx-fx)**2 + (hy-fy)**2)**0.5\n\tif d-a > -0.001: return False\n\ttheta = (acos((hx-fx)/d) if hy-fy >= 0 else 2*pi-acos((hx-fx)/d))\n\tr,l = (w-df/2.0)*pi/180,(w+df/2.0)*pi/180\n\treturn True if r+eps < theta < l-eps or r-2*pi+eps < theta < l-2*pi-eps else False\n\nwhile 1:\n\tH,R = map(int,raw_input().split())\n\tif H == 0: break\n\thxy = [map(int,raw_input().split()) for i in range(H)]\n\tU,M,S,du,dm,ds = map(int,raw_input().split())\n\tdxy = [map(int,raw_input().split())+[du] for i in range(U)]\n\tmxy = [map(int,raw_input().split())+[dm] for i in range(M)]\n\tsxy = [map(int,raw_input().split())+[ds] for i in range(S)]\n\tfxy = dxy+mxy+sxy\n\tcount = [0]*H\n\tfor i in range(R):\n\t\tw,a = map(int,raw_input().split())\n\t\tfor j in range(H):\n\t\t\tflag = 0\n\t\t\thx,hy = hxy[j]\n\t\t\tif not check(hx,hy,0,0,du,w,a):\n\t\t\t\tcontinue\n\t\t\tfor fx,fy,df in fxy:\n\t\t\t\tif check(hx,hy,fx,fy,df,w,a):\n\t\t\t\t\tflag = 1\n\t\t\t\t\tbreak\n\t\t\tcount[j] += 1- flag\n\tmx = max(count)\n\tif mx > 0:\n\t\tprint \" \".join(map(str,[i+1 for i in range(H) if count[i] == mx]))\n\telse:\n\t\tprint \"NA\""
  },
  {
    "language": "Python",
    "code": "from math import *\ndef check(hx,hy,fx,fy,df,w,a):\n\td = ((hx-fx)**2 + (hy-fy)**2)**0.5\n\tif d-a > -0.001: return False\n\ttheta = (acos((hx-fx)/d) if hy-fy >= 0 else 2*pi-acos((hx-fx)/d))\n\tr,l = (w-df/2.0)*pi/180,(w+df/2.0)*pi/180\n\treturn True if r < theta < l or r-2*pi < theta < l-2*pi else False\n\nwhile 1:\n\tH,R = map(int,raw_input().split())\n\tif H == 0: break\n\thxy = [map(int,raw_input().split()) for i in range(H)]\n\tU,M,S,du,dm,ds = map(int,raw_input().split())\n\tdxy = [map(int,raw_input().split())+[du] for i in range(U)]\n\tmxy = [map(int,raw_input().split())+[dm] for i in range(M)]\n\tsxy = [map(int,raw_input().split())+[ds] for i in range(S)]\n\tfxy = dxy+mxy+sxy\n\tcount = [0]*H\n\tfor i in range(R):\n\t\tw,a = map(int,raw_input().split())\n\t\tfor j in range(H):\n\t\t\thx,hy = hxy[j]\n\t\t\tif not check(hx,hy,0,0,du,w,a):\n\t\t\t\tcontinue\n\t\t\tfor fx,fy,df in fxy:\n\t\t\t\tif check(hx,hy,fx,fy,df,w,a):\n\t\t\t\t\tbreak\n\t\t\telse:\n\t\t\t\tcount[j] += 1\n\tmx = max(count)\n\tif mx > 0:\n\t\tprint \" \".join(map(str,[i+1 for i in range(H) if count[i] == mx]))\n\telse:\n\t\tprint \"NA\""
  },
  {
    "language": "Python",
    "code": "from math import *\ndef check(hx,hy,fx,fy,df,w,a):\n\td = ((hx-fx)**2 + (hy-fy)**2)**0.5\n\tif d-a > -0.001: return False\n\ttheta = (acos((hx-fx)/d) if hy-fy >= 0 else 2*pi-acos((hx-fx)/d))\n\tr,l = (w-df/2.0)*pi/180,(w+df/2.0)*pi/180\n\treturn True if r <= theta <= l or r-2*pi <= theta <= l-2*pi else False\n\nwhile 1:\n\tH,R = map(int,raw_input().split())\n\tif H == 0: break\n\thxy = [map(int,raw_input().split()) for i in range(H)]\n\tU,M,S,du,dm,ds = map(int,raw_input().split())\n\tdxy = [map(int,raw_input().split())+[du] for i in range(U)]\n\tmxy = [map(int,raw_input().split())+[dm] for i in range(M)]\n\tsxy = [map(int,raw_input().split())+[ds] for i in range(S)]\n\tfxy = dxy+mxy+sxy\n\tcount = [0]*H\n\tfor i in range(R):\n\t\tw,a = map(int,raw_input().split())\n\t\tfor j in range(H):\n\t\t\thx,hy = hxy[j]\n\t\t\tif not check(hx,hy,0,0,du,w,a):\n\t\t\t\tcontinue\n\t\t\tfor fx,fy,df in fxy:\n\t\t\t\tif check(hx,hy,fx,fy,df,w,a):\n\t\t\t\t\tbreak\n\t\t\telse:\n\t\t\t\tcount[j] += 1\n\tmx = max(count)\n\tif mx > 0:\n\t\tprint \" \".join(map(str,[i+1 for i in range(H) if count[i] == mx]))\n\telse:\n\t\tprint \"NA\""
  },
  {
    "language": "Python",
    "code": "from math import *\ndef check(hx,hy,fx,fy,df,w,a):\n\td = ((hx-fx)**2 + (hy-fy)**2)**0.5\n\tif d-a > -0.001: return False\n\ttheta = (acos((hx-fx)/d) if hy-fy >= 0 else 2*pi-acos((hx-fx)/d))\n\tr,l = (w-df/2.0)*pi/180,(w+df/2.0)*pi/180\n\treturn True if r <= theta <= l else False\n\nwhile 1:\n\tH,R = map(int,raw_input().split())\n\tif H == 0: break\n\thxy = [map(int,raw_input().split()) for i in range(H)]\n\tU,M,S,du,dm,ds = map(int,raw_input().split())\n\tdxy = [map(int,raw_input().split())+[du] for i in range(U)]\n\tmxy = [map(int,raw_input().split())+[dm] for i in range(M)]\n\tsxy = [map(int,raw_input().split())+[ds] for i in range(S)]\n\tfxy = dxy+mxy+sxy\n\tcount = [0]*H\n\tfor i in range(R):\n\t\tw,a = map(int,raw_input().split())\n\t\tfor j in range(H):\n\t\t\thx,hy = hxy[j]\n\t\t\tif not check(hx,hy,0,0,du,w,a):\n\t\t\t\tcontinue\n\t\t\tfor fx,fy,df in fxy:\n\t\t\t\tif check(hx,hy,fx,fy,df,w,a):\n\t\t\t\t\tbreak\n\t\t\telse:\n\t\t\t\tcount[j] += 1\n\tmx = max(count)\n\tif mx > 0:\n\t\tprint \" \".join(map(str,[i+1 for i in range(H) if count[i] == mx]))\n\telse:\n\t\tprint \"NA\""
  },
  {
    "language": "Python",
    "code": "from math import *\neps = 1e-7\ndef check(hx,hy,fx,fy,df,w,a):\n\td = ((hx-fx)**2 + (hy-fy)**2)**0.5\n\tif d-a > -0.001: return False\n\ttheta = (acos((hx-fx)/d) if hy-fy >= 0 else 2*pi-acos((hx-fx)/d))\n\tr,l = w-df,w+df\n\treturn True if r+eps < theta < l-eps else False\n\nwhile 1:\n\tH,R = map(int,raw_input().split())\n\tif H == 0: break\n\thxy = [map(int,raw_input().split()) for i in range(H)]\n\tU,M,S,du,dm,ds = map(int,raw_input().split())\n\tdu,dm,ds = du*pi/360,dm*pi/360,ds*pi/360\n\tdxy = [map(int,raw_input().split())+[du] for i in range(U)]\n\tmxy = [map(int,raw_input().split())+[dm] for i in range(M)]\n\tsxy = [map(int,raw_input().split())+[ds] for i in range(S)]\n\tfxy = dxy+mxy+sxy\n\tcount = [0]*H\n\tfor i in range(R):\n\t\tw,a = map(int,raw_input().split())\n\t\tw = w*pi/180\n\t\tif w > pi: w -= 2*pi\n\t\tfor j in range(H):\n\t\t\thx,hy = hxy[j]\n\t\t\tif not check(hx,hy,0,0,du,w,a):\n\t\t\t\tcontinue\n\t\t\tfor fx,fy,df in fxy:\n\t\t\t\tif check(hx,hy,fx,fy,df,w,a):\n\t\t\t\t\tbreak\n\t\t\telse:\n\t\t\t\tcount[j] += 1\n\tmx = max(count)\n\tif mx > 0:\n\t\tprint \" \".join(map(str,[i+1 for i in range(H) if count[i] == mx]))\n\telse:\n\t\tprint \"NA\""
  }
]