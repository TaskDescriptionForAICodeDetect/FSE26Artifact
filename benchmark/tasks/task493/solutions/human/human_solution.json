[
  {
    "language": "C++",
    "code": "#include <iostream>\n#include <string>\n#include <vector>\n#include <algorithm>\n#include <cmath>\n#include <cstdio>\n#include <functional>\n#include <numeric>\n#include <stack>\n#include <queue>\n#include <map>\n#include <set>\n#include <utility>\n#include <sstream>\n#include <complex>\n#include <fstream>\n#include <bitset>\n#include <time.h>\n\nusing namespace std;\n\ntypedef long long ll;\ntypedef pair<ll, ll> P;\ntypedef vector<ll> V;\ntypedef complex<double> Point;\n\n#define PI acos(-1.0)\n#define EPS 1e-10\nconst ll INF = (1LL << 31) - 1;\nconst ll MOD = 1e9 + 7;\n\n#define FOR(i,a,b) for(int i=(a);i<(b);i++)\n#define rep(i,N) for(int i=0;i<(N);i++)\n#define ALL(s) (s).begin(),(s).end()\n#define EQ(a,b) (abs((a)-(b))<EPS)\n#define EQV(a,b) ( EQ((a).real(), (b).real()) && EQ((a).imag(), (b).imag()) )\n#define fi first\n#define se second\n#define N_SIZE (1LL << 20)\n#define NIL -1\n#define MAX_N 100100 * 3\n\nstring s;\nvector<int> pos;\n\nll digit(char c);\nll term(string &s, int& pos);\nll expr(string &s, int& pos);\n\nbool is_digit(char c) {\n\treturn c >= '0'&&c <= '9';\n}\n\nll digit(char c) {\n\treturn c - '0';\n}\n\nll term(string &s, int& pos) {\n\t//cout << s[pos] << \" \" << pos << endl;\n\tif (is_digit(s[pos]))return digit(s[pos]);\n\treturn expr(s, pos);\n}\n\nll expr(string &s, int& pos) {\n\t//cout << s[pos] << \" \" << pos << endl;\n\tll res = 0;\n\tif (s[pos] == '(') {\n\t\tpos++;\n\t\tres = expr(s, pos);\n\t\t//pos++;\n\t\t//cout << \"!\" << s[pos] << \" \" << pos << endl;\n\t}\n\telse {\n\t\tres = term(s, pos);\n\t\tpos++;\n\t\twhile (s[pos] == '+' || s[pos] == '-') {\n\t\t\tif (s[pos] == '+') {\n\t\t\t\t//cout << pos << \" \" << \"+\" << endl;\n\t\t\t\tpos++;\n\t\t\t\tres += term(s, pos);\n\t\t\t}\n\t\t\telse if (s[pos] == '-') {\n\t\t\t\t//cout << pos << \" \" << \"-\" << endl;\n\t\t\t\tpos++;\n\t\t\t\tres -= term(s, pos);\n\t\t\t}\n\t\t\tpos++;\n\t\t\t//cout << \"!\" << s[pos] << \" \" << pos << endl;\n\t\t}\n\t}\n\t//cout << res << endl;\n\treturn res;\n}\n\nint main() {\n\tcin >> s;\n\trep(i, s.size()) {\n\t\tif (is_digit(s[i]))pos.push_back(i);\n\t}\n\tint p = 0;\n\tll ans = expr(s, p);\n\trep(i, pos.size()) {\n\t\tFOR(j, i, pos.size()) {\n\t\t\tp = 0;\n\t\t\tint n[2] = { pos[i],pos[j] };\n\t\t\tstring t = s.substr(0, n[0]) + \"(\" + s.substr(n[0], n[1] - n[0] + 1) + \")\" + s.substr(n[1] + 1);\n\t\t\tbool f = 0;\n\t\t\trep(k, t.size() - 2) {\n\t\t\t\tif (t[k] == '('&&t[k + 2] == ')')f = 1;\n\t\t\t}\n\t\t\tif (f)continue;\n\t\t\t//cout << t << endl;\n\t\t\tans = max(ans, expr(t, p));\n\t\t\t//cout << ans << endl;\n\t\t}\n\t}\n\tcout << ans << endl;\n}"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\n                                #include<iostream>\n                                #include<cstdio>\n                                #include<vector>\n                                #include<queue>\n                                #include<map>\n                                #include<cstring>\n                                #include<string>\n                                #include <math.h>\n                                #include<algorithm>\n                            //    #include <boost/multiprecision/cpp_int.hpp>\n                                #include<functional>\n                       #define int long long\n                                #define inf  10000000000007\n                                #define pa pair<int,int>\n                                #define ll long long\n                                #define pal pair<double,pa>\n                                #define ppa pair<pa,int>\n                                #define ppap pair<int,pa>\n                                #define ssa pair<string,int>\n                                #define  mp make_pair\n                                #define  pb push_back\n                                #define EPS (1e-10)\n                                #define equals(a,b) (fabs((a)-(b))<EPS)\n                          \n                                using namespace std;\n                       \n                                class Point{\n                                    public:\n                                    double x,y;\n                                    Point(double x=0,double y=0):x(x),y(y) {}\n                                    Point operator + (Point p) {return Point(x+p.x,y+p.y);}\n                                    Point operator - (Point p) {return Point(x-p.x,y-p.y);}\n                                    Point operator * (double a) {return Point(x*a,y*a);}\n                                    Point operator / (double a) {return Point(x/a,y/a);}\n                                    double absv() {return sqrt(norm());}\n                                    double norm() {return x*x+y*y;}\n                                    bool operator < (const Point &p) const{\n                                        return x != p.x ? x<p.x: y<p.y;\n                                    }\n                                    bool operator == (const Point &p) const{\n                                        return fabs(x-p.x)<EPS && fabs(y-p.y)<EPS;\n                                    }\n                                };\n                                typedef Point Vector;\n                          \n                                struct Segment{\n                                Point p1,p2;\n                                };\n                                 double dot(Vector a,Vector b){\n                                    return a.x*b.x+a.y*b.y;\n                                }\n                                double cross(Vector a,Vector b){\n                                    return a.x*b.y-a.y*b.x;\n                                }\n                             \n    bool parareru(Point a,Point b,Point c,Point d){\n    //  if(abs(cross(a-b,d-c))<EPS)cout<<\"dd \"<<cross(a-b,d-c)<<endl;\n        return abs(cross(a-b,d-c))<EPS;\n    }\n    double distance_ls_p(Point a, Point b, Point c) {\n      if ( dot(b-a, c-a) < EPS ) return (c-a).absv();\n      if ( dot(a-b, c-b) < EPS ) return (c-b).absv();\n      return abs(cross(b-a, c-a)) / (b-a).absv();\n    }\n    bool is_intersected_ls(Segment a,Segment b) {\n        if(a.p1==b.p1||a.p2==b.p1||a.p1==b.p2||a.p2==b.p2) return false;\n        if(parareru((a.p2),(a.p1),(a.p1),(b.p2))&&parareru((a.p2),(a.p1),(a.p1),(b.p1))){\n    //      cout<<\"sss\"<<endl;\n            if(dot(a.p1-b.p1,a.p1-b.p2)<EPS) return true;\n            if(dot(a.p2-b.p1,a.p2-b.p2)<EPS) return true;\n            if(dot(a.p1-b.p1,a.p2-b.p1)<EPS) return true;\n            if(dot(a.p1-b.p2,a.p2-b.p2)<EPS) return true;\n            return false;\n        }\n      else return ( cross(a.p2-a.p1, b.p1-a.p1) * cross(a.p2-a.p1, b.p2-a.p1) < EPS ) && ( cross(b.p2-b.p1, a.p1-b.p1) * cross(b.p2-b.p1, a.p2-b.p1) < EPS );\n    }\n      \n    double segment_dis(Segment a,Segment b){\n        if(is_intersected_ls(a,b))return 0;\n        double r=distance_ls_p(a.p1, a.p2, b.p1);\n        r=min(r,distance_ls_p(a.p1, a.p2, b.p2));\n        r=min(r,distance_ls_p(b.p1, b.p2, a.p2));\n        r=min(r,distance_ls_p(b.p1, b.p2, a.p1));\n        return r;\n    }\n    Point intersection_ls(Segment a, Segment b) {\n      Point ba = b.p2-b.p1;\n      double d1 = abs(cross(ba, a.p1-b.p1));\n      double d2 = abs(cross(ba, a.p2-b.p1));\n      double t = d1 / (d1 + d2);\n      \n      return a.p1 + (a.p2-a.p1) * t;\n    }\n      \n                    string itos( int i ) {\n                    ostringstream s ;\n                    s << i ;\n                    return s.str() ;\n                    }\n                      \n                    int gcd(int v,int b){\n                        if(v>b) return gcd(b,v);\n                        if(v==b) return b;\n                        if(b%v==0) return v;\n                        return gcd(v,b%v);\n                    }\n      \n                    double distans(double x1,double y1,double x2,double y2){\n                        double rr=(x1-x2)*(x1-x2)+(y1-y2)*(y1-y2);\n                        return sqrt(rr);\n                         \n                    }\n                    /*\n    int pr[100010];\n    //int inv[100010];\n    */\n    int beki(int wa,int rr,int warukazu){\n        if(rr==0) return 1ll;\n        if(rr==1) return wa%warukazu;\n        if(rr%2==1) return (beki(wa,rr-1,warukazu)*wa)%warukazu;\n        int zx=beki(wa,rr/2,warukazu);\n        return (zx*zx)%warukazu;\n    }\n      /*\n    void gya(){\n        pr[0]=1;\n        for(int i=1;i<100010;i++){\n            pr[i]=(pr[i-1]*i)%inf;\n        }\n        for(int i=0;i<100010;i++) inv[i]=beki(pr[i],inf-2);\n         \n    }\n      \n    */\n     //sort(ve.begin(),ve.end(),greater<int>());\n                             //----------------kokomade tenpure------------\n    //vector<double> ans(100000000),ans2(100000000);\n    /*\n    int par[200100],ranks[200100],kosuu[200100];     \n      \n    void shoki(int n){\n        for(int i=0;i<n;i++){\n            par[i]=i;\n            ranks[i]=0;\n            kosuu[i]=1;\n        }\n    }\n      \n    int root(int x){\n        return par[x]==x ? x : par[x]=root(par[x]);\n    }\n      \n    bool same(int x,int y){\n    return root(x)==root(y);\n    }\n      \n    void unite(int x,int y){\n     x=root(x);\n     y=root(y);\n        int xx=kosuu[x],yy=kosuu[y];\n     if(x==y) return;\n        if(ranks[x]<ranks[y]){\n            par[x]=y;\n            kosuu[y]=yy+xx;\n        }\n     else {\n        par[y]=x;\n        if(ranks[x]==ranks[y]) ranks[x]=ranks[x]+1;\n        kosuu[x]=yy+xx;\n     }\n        return;\n    }\n    */\nint dp[300][300][2];\n\nint muri[300][300]={0};\nstring s;\n\n\nint saiki(int l,int r,int ma){\n\t\n//\tcout<<l<<\" \"<<r<<\" \"<<ma<<endl;\n\tif(r<l) return -inf;\n\tif(dp[l][r][ma]!=-inf) return dp[l][r][ma];\n\tint ka=0;\n\tfor(int i=l;i<=r;i++) if(s[i]>='0' && s[i]<='9')ka++;\n\t\n\tif(s[l]>='0' && s[l]<='9' && s[l+1]==')'){\n\t\tif(ka>1)muri[l][r]=1;\n\t}\n\tif(s[r]>='0' && s[r]<='9' && s[r-1]=='('){\n\t\tif(ka>1)muri[l][r]=1;\n\t}\n\t\n\tif(muri[l][r]==1) return (ma==1? -inf:inf);\n\tint l2=l,r2=r;\n\twhile(s[l2]=='(') l2++;\n\twhile(s[r2]==')') r2--;\n\tbool b=false;\n\tfor(int i=l2;i<=r2;i++)if(s[i]=='('||s[i]==')') b=true;\n\tint la=-inf,mi=inf;\n\tif(!b){\n\t\tint su=0;\n\t\tint op=1;\n\t\tfor(int i=l2;i<=r2;i+=2){\n\t\t\tif(i>l2) op= (s[i-1]=='+'? 1:-1);\n\t\t\tsu += op*(s[i]-'0');\n\t\t}\n\t\tla=su,mi=su;\n\t}\n\t\n\t\n\tfor(int i=l;i<=r;i++){\n\t\tint q1,q2;\n\t\tif(s[i]=='+'){\n\t\t\t q1=saiki(l,i-1,1)+saiki(i+1,r,1);\n\t\t\t q2=saiki(l,i-1,0)+saiki(i+1,r,0);\n\t\t}\n\t\telse if(s[i]=='-'){\n\t\t\t q1=saiki(l,i-1,1)-saiki(i+1,r,0);\n\t\t\t q2=saiki(l,i-1,0)-saiki(i+1,r,1);\n\t\t}\n\t\telse continue;\n\t\t\n\t\tif(muri[l][i-1]+muri[i+1][r]==2) continue;\n\t\t\n\t\tla=max(la,q1);\n\t\tmi=min(mi,q2);\n\t}\n\tdp[l][r][1]=la;\n\tdp[l][r][0]=mi;\n\t\n//\tcout<<l<<\" \"<<r<<\" \"<<1<<\" \"<<dp[l][r][1]<<endl;\n//\tcout<<l<<\" \"<<r<<\" \"<<0<<\" \"<<dp[l][r][0]<<endl;\n\treturn dp[l][r][ma];\n}\n\nsigned main(){\n\n\tfor(int i=0;i<300;i++)for(int j=0;j<300;j++)for(int k=0;k<2;k++) dp[i][j][k]=-inf;\n//\tstring s;\n\tcin>>s;\n\t\n\t\n\tint l=s.length();\n\t\n\tfor(int i=0;i<l;i++) if(s[i]>='0'&&s[i]<='9'){\n\t\tdp[i][i][0]=s[i]-'0';\n\t\tdp[i][i][1]=s[i]-'0';\n\t}\n\t\n\tint it;\n\tint mae=1;\n\tdp[0][0][0]=1;\n\t\n\tcout<<saiki(0,l-1,1)<<endl;\n    return 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include <iostream>\n#include <cstdio>\n#include <string>\n#include <algorithm>\n#include <utility>\nusing namespace std;\ntypedef pair<int, int> pii;\nvoid chmax(int &a, int b) {a = max(a, b);}\nvoid chmin(int &a, int b) {a = min(a, b);}\nconst int INF = 1 << 28;\nstring s;\nint N, dp_max[210][210], dp_min[210][210];\n\nvoid solve(int l, int r) {\n    if(dp_max[l][r] != -INF) return;\n    // 数字\n    if(r - l == 1 && isdigit(s[l])) {\n        dp_max[l][r] = dp_min[l][r] = s[l] - '0';\n    }\n    // 括弧をとっぱらって再帰的に\n    // このとき、括弧含め幅が 3 以下 (つまり実質 2 以下) だと\n    // 数式になりえないので飛ばす\n    if(s[l] == '(' && r-l > 3) {\n        solve(l+1, r);\n        chmax(dp_max[l][r], dp_max[l+1][r]);\n        chmin(dp_min[l][r], dp_min[l+1][r]);\n    }\n    else if(s[r-1] == ')' && r-l > 3) {\n        solve(l, r-1);\n        chmax(dp_max[l][r], dp_max[l][r-1]);\n        chmin(dp_min[l][r], dp_min[l][r-1]);\n    }\n    else {\n        for(int k=l; k<r; k++) {\n            if(s[k] != '+' && s[k] != '-') continue;\n            solve(l, k);\n            solve(k+1, r);\n            if(dp_max[l][k] == -INF || dp_max[k+1][r] == -INF) continue;\n            if(s[k] == '+') {\n                chmax(dp_max[l][r], dp_max[l][k] + dp_max[k+1][r]);\n                chmin(dp_min[l][r], dp_min[l][k] + dp_min[k+1][r]);\n            }\n            else {\n                chmax(dp_max[l][r], dp_max[l][k] - dp_min[k+1][r]);\n                chmin(dp_min[l][r], dp_min[l][k] - dp_max[k+1][r]);\n            }\n        }\n    }\n}\n\nint main() {\n    cin >> s;\n    N = s.length();\n    for(int i=0; i<N; i++) {\n        fill(dp_max[i], dp_max[i] + N + 1, -INF);\n        fill(dp_min[i], dp_min[i] + N + 1, INF);\n    }\n\n    solve(0, N);\n    /*\n    for(int i=0; i<N; i++) {\n        for(int j=i+1; j<=N; j++) {\n            if(dp_max[i][j] == -INF) continue;\n            printf(\"%s\\n\", s.c_str());\n            for(int k=0; k<N; k++) {\n                if(i <= k && k < j) printf(\"=\");\n                else printf(\" \");\n            }\n            printf(\" -> %d\\n\", dp_max[i][j]);\n        }\n    }\n    */\n    printf(\"%d\\n\", dp_max[0][N]);\n    return 0;\n}\n"
  },
  {
    "language": "C++",
    "code": "#include<iostream>\n#include<algorithm>\nusing namespace std;\nstring s,t;\nbool NOL[222],NOR[222];\nint D[222][222],P[222][222];\nbool ok[222][222];\nmain()\n{\n\tcin>>s;\n\tfor(int i=0;i<s.size();i++)\n\t{\n\t\tif(s[i]>='0'&&s[i]<='9')\n\t\t{\n\t\t\tt+=s[i];\n\t\t\tif(i>0&&s[i-1]=='(')NOR[t.size()-1]=true;\n\t\t\tif(i+1<s.size()&&s[i+1]==')')NOL[t.size()-1]=true;\n\t\t}\n\t\telse if(s[i]=='+'||s[i]=='-')t+=s[i];\n\t}\n\ts=t;\n\tfor(int i=0;i<s.size();i++)\n\t{\n\t\tif(s[i]>='0'&&s[i]<='9')\n\t\t{\n\t\t\tok[i][i+1]=true;\n\t\t\tD[i][i+1]=P[i][i+1]=s[i]-'0';\n\t\t}\n\t}\n\tfor(int k=2;k<=s.size();k++)for(int i=0;i+k<=s.size();i++)\n\t{\n\t\tif(NOL[i]||NOR[i+k-1])continue;\n\t\tint d=-2e9,p=2e9;\n\t\tfor(int j=i+1;j<i+k;j++)\n\t\t{\n\t\t\tif(!ok[i][j]||!ok[j+1][i+k])continue;\n\t\t\tif(s[j]=='+')\n\t\t\t{\n\t\t\t\tok[i][i+k]=true;\n\t\t\t\td=max(d,D[i][j]+D[j+1][i+k]);\n\t\t\t\tp=min(p,P[i][j]+P[j+1][i+k]);\n\t\t\t}\n\t\t\telse if(s[j]=='-')\n\t\t\t{\n\t\t\t\tok[i][i+k]=true;\n\t\t\t\td=max(d,D[i][j]-P[j+1][i+k]);\n\t\t\t\tp=min(p,P[i][j]-D[j+1][i+k]);\n\t\t\t}\n\t\t}\n\t\tif(ok[i][i+k])D[i][i+k]=d,P[i][i+k]=p;\n\t}\n\tcout<<D[0][s.size()]<<endl;\n}\n\n"
  },
  {
    "language": "C++",
    "code": "#include <iostream>\n#include <cmath>\n#define REP(i, a, n) for(int i = ((int) a); i < ((int) n); i++)\n#define INF 100000000\nusing namespace std;\ntypedef long long ll;\n\nstring S;\nll dp[300][300][2];\n\nll number(int l, int r) {\n  ll ret = 0;\n  REP(i, l, r) {\n    if('0' <= S[i] && S[i] <= '9') ret = ret * 10 + (S[i] - '0');\n    else return -1;\n  }\n  return ret;\n}\n\nll dfs(int l, int r, int mode, int depth) {\n  ll ret;\n\n  if(dp[l][r][mode] != -INF) ret = dp[l][r][mode];\n  else {\n    ll n = number(l, r);\n    if(n >= 0) ret = n;\n    else {\n      ret = mode == 0 ? -INF : INF;\n      REP(i, l, r) {\n        if(S[i] != '+' && S[i] != '-') continue;\n\n        int nl = l, nr = r;\n        while(1) {\n          ll n1 = dfs(nl, i, mode, depth + 1);\n          ll n2 = dfs(i + 1, nr, S[i] == '-' ? 1 - mode : mode, depth + 1);\n          if(abs(n1) != INF && abs(n2) != INF) {\n            if(mode == 0) {\n              if(S[i] == '+') ret = max(ret, n1 + n2);\n              if(S[i] == '-') ret = max(ret, n1 - n2);\n            } else {\n              if(S[i] == '+') ret = min(ret, n1 + n2);\n              if(S[i] == '-') ret = min(ret, n1 - n2);\n            }\n          }\n          if(S[nl] != '(' && S[nr - 1] != ')') break;\n          if(S[nl] == '(') nl++;\n          if(S[nr - 1] == ')') nr--;\n        }\n      }\n    }\n  }\n\n  return dp[l][r][mode] = ret;\n}\n\nint main(void) {\n  cin >> S;\n\n  REP(i, 0, 201) REP(j, 0, 201) REP(k, 0, 2) dp[i][j][k] = -INF;\n  cout << dfs(0, S.size(), 0, 0) << endl;\n\n  return 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\nusing namespace std;\n\nusing P = pair<int, int>;\n\nconstexpr int INF = 1e9;\n\nP memo[201][201];\n\nP rec(int l, int r, string const& s) {\n    P& res = memo[l][r];\n    if(res != P{-INF, INF}) {\n        return res;\n    }\n    if(l == r) {\n        int v = s[l] - '0';\n        return res = make_pair(v, v);\n    }\n    if(s[l] == '(' && r-l >= 3) {\n        P p = rec(l+1, r, s);\n        res.first = max(res.first, p.first);\n        res.second = min(res.second, p.second);\n    }\n    if(s[r] == ')' && r-l >= 3) {\n        P p = rec(l, r-1, s);\n        res.first = max(res.first, p.first);\n        res.second = min(res.second, p.second);\n    }\n    for(int i=l+1; i<r; ++i) {\n        char op = s[i];\n        if(op == '+' || op == '-') {\n            P rl = rec(l, i-1, s);\n            P rr = rec(i+1, r, s);\n            if(op == '+') {\n                res.first = max(res.first, rl.first + rr.first);\n                res.second = min(res.second, rl.second + rr.second);\n            } else {\n                res.first = max(res.first, rl.first - rr.second);\n                res.second = min(res.second, rl.second - rr.first);\n            }\n        }\n    }\n    return res;\n}\n\nint main() {\n    string s;\n    cin >> s;\n    for(int i=0; i<s.size(); ++i) {\n        for(int j=0; j<s.size(); ++j) {\n            memo[i][j] = make_pair(-INF, INF);\n        }\n    }\n    cout << rec(0, s.size()-1, s).first << endl;\n}\n"
  },
  {
    "language": "C++",
    "code": "#include<bits/stdc++.h>\nusing namespace std;\n#define INF (1e8)\n#define MAX 205\nint n;\nchar s[MAX];\n\nint dpA[MAX][MAX];\nint dpB[MAX][MAX];\nbool flgA[MAX][MAX];\nbool flgB[MAX][MAX];\n\nint solveA(int,int);\nint solveB(int,int);\n\nint main(){\n  scanf(\"%s\",s);\n  n=strlen(s);\n  printf(\"%d\\n\",solveA(0,n));\n  return 0;\n}\n\nint solveA(int l,int r){\n  if(flgA[l][r])return dpA[l][r];\n  flgA[l][r]=true;\n  int res=-INF,cnt=0,num=0;\n  for(int i=l;i<r;i++){\n    if(s[i]=='+'){\n      if(l<=i-3&&'0'<=s[i-1]&&s[i-1]<='9'&&s[i-2]=='(')continue;\n      if(i+3<r&&'0'<=s[i+1]&&s[i+1]<='9'&&s[i+2]==')')continue;\n\n      res=max(res, solveA(l,i)+solveA(i+1,r));\n    }else if(s[i]=='-'){\n      if(l<=i-3&&'0'<=s[i-1]&&s[i-1]<='9'&&s[i-2]=='(')continue;\n      if(i+3<r&&'0'<=s[i+1]&&s[i+1]<='9'&&s[i+2]==')')continue;\n      res=max(res, solveA(l,i)-solveB(i+1,r));\n    }else if('0'<=s[i]&&s[i]<='9'){\n      cnt++;\n      num=s[i]-'0';\n    }\n  }\n  if(cnt==1)res=num;\n  return dpA[l][r]=res;\n}\n\nint solveB(int l,int r){\n  if(flgB[l][r])return dpB[l][r];\n  flgB[l][r]=true;\n  int res=INF,cnt=0,num=0;\n  for(int i=l;i<r;i++){\n    if(s[i]=='+'){\n      if(l<=i-3&&'0'<=s[i-1]&&s[i-1]<='9'&&s[i-2]=='(')continue;\n      if(i+3<r&&'0'<=s[i+1]&&s[i+1]<='9'&&s[i+2]==')')continue;\n      res=min(res, solveB(l,i)+solveB(i+1,r));\n    }else if(s[i]=='-'){\n      if(l<=i-3&&'0'<=s[i-1]&&s[i-1]<='9'&&s[i-2]=='(')continue;\n      if(i+3<r&&'0'<=s[i+1]&&s[i+1]<='9'&&s[i+2]==')')continue;\n      res=min(res, solveB(l,i)-solveA(i+1,r));\n    }else if('0'<=s[i]&&s[i]<='9'){\n      cnt++;\n      num=s[i]-'0';\n    }\n  }\n  if(cnt==1)res=num;\n  return dpB[l][r]=res;\n}"
  },
  {
    "language": "C++",
    "code": "#include \"bits/stdc++.h\"\n#include<unordered_map>\n#include<unordered_set>\n#pragma warning(disable:4996)\nusing namespace std;\nusing ld = long double;\nconst ld eps = 1e-9;\n\nstruct Edge {\n\tint src;\n\tint dst;\n\tlong long int cost;\n};\nusing Graph=vector<vector<Edge>>;\n\nclass Centroid {\npublic:\n\tint dfs(const Graph&g, const int now, const int from, vector<int>&ch_nums, const vector<int>&oks) {\n\t\tint sum = 1;\n\t\tfor (auto &&e : g[now]) {\n\t\t\tif (e.dst == from || oks[e.dst]!=-1)continue;\n\t\t\telse {\n\t\t\t\tsum += dfs(g, e.dst, e.src, ch_nums,oks);\n\t\t\t}\n\t\t}\n\t\treturn ch_nums[now] = sum;\n\t};\n\n\n\tint find_centroid(const int asize, const vector<vector<Edge>>&graph, const int pre_root, const int pre_from, const vector<int>&ch_nums, const vector<int>&oks) {\n\t\tfor (auto&& e : graph[pre_root]) {\n\t\t\tif (e.dst == pre_from)continue;\n\t\t\tif (oks[e.dst]!=-1)continue;\n\t\t\tif (ch_nums[e.dst]>asize / 2)return find_centroid(asize, graph, e.dst, e.src, ch_nums, oks);\n\t\t}\n\t\treturn pre_root;\n\t}\n\n\t//void dfs2(const Graph&g, const int now, const int from,vector<long long int>&lens,const int root_id, long long int nlen) {\n\t//\tlens.push_back(nlen);\n\t//\tmp[make_pair(root_id,now)]=nlen;\n\t//\tfor (auto &&e : g[now]) {\n\t//\t\tif (e.dst == from || oks[e.dst] != -1)continue;\n\t//\t\telse {\n\t//\t\t\tdfs2(g,e.dst,e.src,lens,root_id,nlen+e.cost);\n\t//\t\t}\n\t//\t}\n\t//}\n\n\tvoid cent(const vector<vector<Edge>>&graph, vector<int>&oks, const int root, const int from, vector<vector<int>>&centroid_edges, int& fst_centroid,int depth,vector<int>&ch_nums) {\ndfs(graph, root, from, ch_nums, oks);\n\n\t\tint cent_id = find_centroid(ch_nums[root], graph, root, from, ch_nums, oks);\n\n\t\t\n\t\t//dfs2(graph,cent_id,from,lens[cent_id],0);\n\t\tsort(lens[cent_id].begin(),lens[cent_id].end());\n\n\t\toks[cent_id] = depth;\n\t\tif (from != -1) {\n\t\t\tcentroid_edges[from].push_back(cent_id);\n\t\t}\n\t\telse {\n\t\t\tfst_centroid = cent_id;\n\t\t}\n\t\tfor (auto e : graph[cent_id]) {\n\t\t\tif (e.dst == from)continue;\n\t\t\tif (oks[e.dst]!=-1)continue;\n\t\t\tcent(graph, oks, e.dst, e.src, centroid_edges, fst_centroid,depth+1,ch_nums);\n\t\t}\n\t}\n\npublic:\n\n\n\tvector<vector<long long int>>lens;\n\tvector<vector<int>> centroid_graph;\n\tvector<int>parents;\n\tvector<int>oks;\n\tmap<pair<int,int>,long long int>mp;\n\n\t//fst:root  snd:centroid_graph\n\tvector<vector<int>> get_cent_parent(const Graph&g) {\n\t\tlens.resize(g.size());\n\t\toks=vector<int>(g.size(),-1);\n\t\tint root = -1;\n\t\tcentroid_graph.resize(g.size());\n\t\tparents=vector<int>(g.size(),-1);\n\t\tvector<int>ch_nums(g.size());\n\t\tcent(g, oks, 0, -1, centroid_graph, root,0,ch_nums);\n\n\t\tfor (int i = 0; i < centroid_graph.size(); ++i) {\n\t\t\tfor (auto&& e : centroid_graph[i]) {\n\t\t\t\tparents[e] = i;\n\t\t\t}\n\t\t}\n\t\treturn centroid_graph;\n\t}\n}centroid;\n\n\nvoid addEdge(Graph& g ,int a, int b,long long int c) {\n\tg[a - 1].push_back(Edge{ a - 1,b - 1,c });\n\tg[b - 1].push_back(Edge{ b - 1,a - 1,c });\n}\n\nvector<int>nums;\nvector<int>ls;\nvector<int>rs;\nvector<int>pluss;\nvector<vector<pair<int,int>>>memo;\n\nstring st;\nvoid term(int&a,int&k) {\n\tnums.push_back(0);\n\tls.push_back(0);\n\trs.push_back(0);\n\twhile (a != st.size() && st[a] == '(') {\n\t\tls[k]=true;\n\t\ta++;\n\t}\n\tnums[k]=st[a]-'0';\n\ta++;\n\twhile (a != st.size() && st[a] == ')') {\n\t\trs[k]=true;\n\t\ta++;\n\t}\n\tk++;\n\treturn ;\n}\nvoid expr(int &a) {\n\tint k=0;\n\tterm(a,k);\n\n\twhile (a != st.size()) {\n\t\tpluss.push_back(st[a]=='+');\n\t\ta++;\n\t\tterm(a,k);\n\t}\n}\nvoid init() {\n\tint a=0;\n\texpr(a);\n\tmemo=vector<vector<pair<int,int>>>(nums.size()+1,vector<pair<int,int>>(nums.size()+1,make_pair(1e9,-1e9)));\n}\n\npair<int,int> solve(int l, int r) {\n\tif(memo[l][r].first!=1e9)return memo[l][r];\n\t if(l+1==r)return memo[l][r]=make_pair(nums[l],nums[l]);\n\t if (l + 2 == r) {\n\t\t if(rs[l]||ls[l+1])return memo[l][r]=make_pair(1e8,-1e8);\n\t\t else {\n\t\t\t if (pluss[l]) {\n\t\t\t\t return memo[l][r]=make_pair(nums[l]+nums[l+1],nums[l]+nums[l+1]);\n\t\t\t }\n\t\t\t else {\n\t\t\t\t return memo[l][r]=make_pair(nums[l]-nums[l+1],nums[l]-nums[l+1]);\n\t\t\t }\n\t\t }\n\t }\n\t else {\n\t\t pair<int,int>ans=make_pair(1e8,-1e8);\n\t\t for (int k = l + 1; k < r; ++k) {\n\t\t\t bool ok=true;\n\t\t\t//if(ls[k-1])ok=false;\n\t\t\t if(!ok)continue;\n\t\t\t else {\n\t\t\t\t auto lp=solve(l,k),rp=solve(k,r);\n\n\t\t\t\t if (pluss[k - 1]) {\n\t\t\t\t\t auto p=make_pair(lp.first+rp.first,lp.second+rp.second);\n\t\t\t\t\t ans=make_pair(min(ans.first,p.first),max(ans.second,p.second));\n\t\t\t\t }\n\t\t\t\t else {\n\t\t\t\t\t auto p=make_pair(lp.first-rp.second,lp.second-rp.first);\n\t\t\t\t\t ans=make_pair(min(ans.first,p.first),max(ans.second,p.second));\n\t\t\t\t }\n\t\t\t }\n\t\t }\n\t\t return memo[l][r]=ans;\n\t }\n}\n\nint main()\n{\n\tcin>>st;\n\tinit();\n\tauto p=solve(0,nums.size());\n\tcout<<p.second<<endl;\n\treturn 0;\n}\n"
  },
  {
    "language": "C++",
    "code": "#include \"bits/stdc++.h\"\nusing namespace std;\n// http://judge.u-aizu.ac.jp/onlinejudge/description.jsp?id=2710&lang=jp\n// reference : http://suikaba.hatenablog.com/entry/2017/05/24/231631\ntypedef pair<int, int> pii;\n#define INF 1<<20\n\npii rec(int l, int r, const string& S,vector<vector<pii>>& dp) {\n\tpii& ret = dp[l][r];\n\t/* Updated */\n\tif (ret != pii(-INF, INF)) return ret; \n\n\tif (l == r) return ret = { S[l] - '0',S[l] - '0' };\n\n\tif (S[l] == '(' && r - l >= 3) {\n\t\tpii x = rec(l + 1, r, S, dp);\n\t\tret.first = max(ret.first, x.first);\n\t\tret.second = min(ret.second, x.second);\n\t}\n\tif (S[r] == ')' && r - l >= 3) {\n\t\tpii x = rec(l, r - 1, S, dp);\n\t\tret.first = max(ret.first, x.first);\n\t\tret.second = min(ret.second, x.second);\n\t}\n\tfor (int m = l + 1; m < r; m++) {\n\t\tif (S[m] == '+' || S[m] == '-') {\n\t\t\tpii x1 = rec(l, m - 1, S, dp);\n\t\t\tpii x2 = rec(m + 1, r, S, dp);\n\t\t\tif (S[m] == '+') {\n\t\t\t\tret.first = max(ret.first, x1.first + x2.first);\n\t\t\t\tret.second = min(ret.second, x1.second + x2.second);\n\t\t\t}\n\t\t\telse {\n\t\t\t\tret.first = max(ret.first, x1.first - x2.second);\n\t\t\t\tret.second = max(ret.second, x1.second - x2.first);\n\t\t\t}\n\t\t}\n\t}\n\treturn ret;\n}\n\nint main(void) {\n\tcin.tie(0); ios::sync_with_stdio(false);\n\tstring S; cin >> S;\n\t/*  dp[l][r] := { maximum value of the interval(l-r) , minimum value of ~ }*/\n\tvector<vector<pii>> dp(S.length() + 1, vector<pii>(S.length() + 1, { -INF,INF }));\n\tcout << rec(0, S.length() - 1, S, dp).first << endl;\n}"
  },
  {
    "language": "C++",
    "code": "#include<bits/stdc++.h>\nusing namespace std;\n#define INF (1e8)\n#define MAX 205\nint n;\nchar s[MAX];\n\nint dpA[MAX][MAX];\nint dpB[MAX][MAX];\nbool flgA[MAX][MAX];\nbool flgB[MAX][MAX];\n\nint solveA(int,int);\nint solveB(int,int);\n\nint main(){\n  scanf(\"%s\",s);\n  n=strlen(s);\n  printf(\"%d\\n\",solveA(0,n));\n  return 0;\n}\n\nint solveA(int l,int r){\n  if(flgA[l][r])return dpA[l][r];\n  flgA[l][r]=true;\n  \n  if(r-l==1){\n    return dpA[l][r]=s[l]-'0';\n  }else if(s[l]=='('){\n    return dpA[l][r]=solveA(l+1,r);\n  }else if(s[r-1]==')'){\n    return dpA[l][r]=solveA(l,r-1);\n  }\n  \n  int res=-INF,cnt=0,last=-INF;\n  for(int i=l;i<r;i++){\n    if(s[i]=='('){\n      last=i;\n      cnt++;\n      continue;\n    }\n    if(s[i]==')'){\n      cnt--;\n      continue;\n    }\n    if(cnt==0){\n      if(s[i]=='+'){\n        res=max(res, solveA(l,i) + solveA(i+1,r) );\n      }\n      if(s[i]=='-'){\n        res=max(res, solveA(l,i) - solveB(i+1,r) );\n      }\n    }\n    if(cnt==1&&last+2<i){\n      if(s[i]=='+'){\n        if(s[last-1]=='+'){\n          res=max(res, solveA(l,last-1)+solveA(last+1,i)+solveA(i+1,r));\n        }\n        if(s[last-1]=='-'){\n          res=max(res, solveA(l,last-1)-solveB(last+1,i)+solveA(i+1,r));\n        }\n      }\n      if(s[i]=='-'){\n        if(s[last-1]=='+'){\n          res=max(res, solveA(l,last-1)+solveA(last+1,i)-solveB(i+1,r));\n        }\n        if(s[last-1]=='-'){\n          res=max(res, solveA(l,last-1)-solveB(last+1,i)-solveB(i+1,r));\n        }\n      }\n    }\n  }\n  return dpA[l][r]=res;\n}\n\nint solveB(int l,int r){\n  if(flgB[l][r])return dpB[l][r];\n  flgB[l][r]=true;\n  \n  if(r-l==1){\n    return dpB[l][r]=s[l]-'0';\n  }else if(s[l]=='('){\n    return dpB[l][r]=solveB(l+1,r);\n  }else if(s[r-1]==')'){\n    return dpB[l][r]=solveB(l,r-1);\n  }\n\n  int res=INF,cnt=0,last=-INF;\n  for(int i=l;i<r;i++){\n    if(s[i]=='('){\n      last=i;\n      cnt++;\n      continue;\n    }\n    if(s[i]==')'){\n      cnt--;\n      continue;\n    }\n    if(cnt==0){\n      if(s[i]=='+'){\n        res=min(res, solveB(l,i) + solveB(i+1,r) );\n      }\n      if(s[i]=='-'){\n        res=min(res, solveB(l,i) - solveA(i+1,r) );\n      }      \n    }\n    if(cnt==1&&last+2){\n      if(s[i]=='+'){\n        if(s[last-1]=='+'){\n          res=min(res, solveB(l,last-1)+solveB(last+1,i)+solveB(i+1,r));\n        }\n        if(s[last-1]=='-'){\n          res=min(res, solveB(l,last-1)-solveA(last+1,i)+solveB(i+1,r));\n        }\n      }\n      if(s[i]=='-'){\n        if(s[last-1]=='+'){\n          res=min(res, solveB(l,last-1)+solveB(last+1,i)-solveA(i+1,r));\n        }\n        if(s[last-1]=='-'){\n          res=min(res, solveB(l,last-1)-solveA(last+1,i)-solveA(i+1,r));\n        }\n      }\n    }\n  }\n  return dpB[l][r]=res;\n}"
  },
  {
    "language": "C++",
    "code": "#include<bits/stdc++.h>\n#define range(i,a,b) for(int i = (a); i < (b); i++)\n#define rep(i,b) for(int i = 0; i < (b); i++)\n#define all(a) (a).begin(), (a).end()\n#define show(x)  cerr << #x << \" = \" << (x) << endl;\nconst int INF = 1e8;\nusing namespace std;\n\nint main(){\n\tstring s;\n\twhile(cin >> s){\n\t\tint mini[205][205];\n\t\tint maxi[205][205];\n\t\trep(i,205) rep(j,205){\n\t\t\tmini[i][j] = INF;\n\t\t\tmaxi[i][j] = -INF;\n\t\t}\n\n\t\trep(i,s.size()){\n\t\t\tif(isdigit(s[i])){\n\t\t\t\tmini[i][i + 1] = maxi[i][i + 1] = s[i] - '0';\n\t\t\t}\n\t\t}\n\n\t\trange(w,3,s.size() + 1){\n\t\t\trep(i,s.size() + 1 - w){\n\t\t\t\tint j = i + w;\n\n\t\t\t\tif(w > 3){\n\t\t\t\t\tif(s[i] == '('){\n\t\t\t\t\t\tmaxi[i][j] = max(maxi[i][j], maxi[i + 1][j]);\n\t\t\t\t\t\tmini[i][j] = min(mini[i][j], mini[i + 1][j]);\n\t\t\t\t\t\tcontinue;\n\t\t\t\t\t}else if(s[j - 1] == ')'){\n\t\t\t\t\t\tmaxi[i][j] = max(maxi[i][j], maxi[i][j - 1]);\n\t\t\t\t\t\tmini[i][j] = min(mini[i][j], mini[i][j - 1]);\n\t\t\t\t\t\tcontinue;\n\t\t\t\t\t}\n\t\t\t\t}\n\n\t\t\t\trange(k,i + 1,j - 1){\n\t\t\t\t\tif(s[k] == '-'){\n\t\t\t\t\t\tmaxi[i][j] = max(maxi[i][j], maxi[i][k] - mini[k + 1][j]);\n\t\t\t\t\t\tmini[i][j] = min(mini[i][j], mini[i][k] - maxi[k + 1][j]);\n\t\t\t\t\t}else if(s[k] == '+'){\n\t\t\t\t\t\t//cout << i << ' ' << k << endl;\n\t\t\t\t\t\t//cout << maxi[i][k] << ' ' << maxi[i][k + 1] << endl;\n\t\t\t\t\t\tmaxi[i][j] = max(maxi[i][j], maxi[i][k] + maxi[k + 1][j]);\n\t\t\t\t\t\tmini[i][j] = min(mini[i][j], mini[i][k] + mini[k + 1][j]);\n\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t\t//rep(i,s.size() + 1){ rep(j,s.size() + 1){ cout << maxi[i][j] <<  ' '; } cout << endl; }\n\t\tcout << maxi[0][s.size()] << endl;\n\t}\n}"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\n#define INF (1e9)\nusing namespace std;\n\n\nint calc(string s){\n  vector<int> v;\n  for(int i=0;i<s.size();i++){\n    int n = (int)v.size()-1;\n    if(s[i]=='+')v.push_back(0);\n    if(s[i]=='-')v.push_back(1);\n    if(s[i]=='(')v.push_back(0),v.push_back(0);\n    if(s[i]==')'){\n      if(v.size()<3)continue;\n      v[n-2]+=v[n-1]? -v[n]:v[n];\n      v.pop_back(),v.pop_back();\n    }\n\n    if(isdigit(s[i])){\n      int num=s[i]-'0';\n      if(v.size()>=2){\n\tv[n-1]+=v[n]? -num:num;\n\tv.pop_back();\n      }\n      else v.push_back(num);\n    }\n  }\n  return v[0];\n}\n\n\nbool check(string s){\n  if(s[0]!='(')return 0;\n  int i=1,c=1;\n  while(c)c+=(s[i]=='(')-(s[i++]==')');\n  return i==(int)s.size();\n}\n\n\nmap<string,int> mem[2];\nint dfs(string s,int f){\n  while(check(s))s=s.substr(1,s.size()-2);\n  if(s.size()==1) return s[0]-'0';\n  if(mem[f].count(s))return mem[f][s];\n  \n  int n=s.size(),res=calc(s),d=0;\n  for(int i=0;i<n;i++) if(s[i]=='+'||s[i]=='-')d++;\n  for(int i=0,c=0,cnt=0;i<n;i++,cnt++,d--){\n    while(i<n){\n      while(s[i]=='('||s[i]==')')c+=(s[i]=='(')-(s[i]==')'),i++;\n      if(s[i]=='+'||s[i]=='-') break;\n      i++;\n    }\n    if(i>=n)break;\n    if(cnt&&s[i-2]=='(')continue;\n    if(d!=1&&s[i+2]==')')continue;\n    string a=s.substr(0,i),b=s.substr(i+1,n-i-1);\n    int t=c,ch=s[i];\n    while(t--)a+=')',b='('+b;\n    int mxa=dfs(a,0),mna=dfs(a,1);\n    int mxb=dfs(b,0),mnb=dfs(b,1);\n    if(f==0&&ch=='+') res=max(res, mxa+mxb);\n    if(f==0&&ch=='-') res=max(res, mxa-mnb);\n    if(f==1&&ch=='+') res=min(res, mna+mnb);\n    if(f==1&&ch=='-') res=min(res, mna-mxb);\n  }\n  return mem[f][s]=res;\n}\n\n\n\n\nint main(){\n  string S;\n  cin>>S;\n\n  cout <<dfs(S,0)<<endl;\n  return 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include <iostream>\n#define REP(i, a, n) for(int i = ((int) a); i < ((int) n); i++)\n#define INF 100000000\nusing namespace std;\ntypedef long long ll;\n\nstring S;\nll dp[300][300];\n\nll number(int l, int r) {\n  ll ret = 0;\n  REP(i, l, r) {\n    if('0' <= S[i] && S[i] <= '9') ret = ret * 10 + (S[i] - '0');\n    else return -1;\n  }\n  return ret;\n}\n\nll dfs(int l, int r) {\n  ll ret;\n\n  if(dp[l][r] >= 0) ret = dp[l][r];\n  else {\n    ll n = number(l, r);\n    if(n >= 0) ret = n;\n    else {\n      ret = -INF;\n      REP(i, l, r) {\n        if(S[i] != '+' && S[i] != '-') continue;\n        int nl = l, nr = r;\n        while(1) {\n          ll n1 = dfs(nl, i);\n          ll n2 = dfs(i + 1, nr);\n          if(n1 != -INF && n2 != -INF) {\n            if(S[i] == '+') ret = max(ret, n1 + n2);\n            if(S[i] == '-') ret = max(ret, n1 - n2);\n          }\n          if(S[nl] != '(' && S[nr - 1] != ')') break;\n          if(S[nl] == '(') nl++;\n          if(S[nr - 1] == ')') nr--;\n        }\n      }\n    }\n  }\n\n  return dp[l][r] = ret;\n}\n\nint main(void) {\n  cin >> S;\n\n  REP(i, 0, 201) REP(j, 0, 201) dp[i][j] = -INF;\n  cout << dfs(0, S.size());\n\n  return 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\nusing namespace std;\n#define INF 1000000\ntypedef string::const_iterator State;\nint expression(State &begin);\n\nint data[201];\nint kakko[201];\nint size;\n\nint number(State &begin){\n\tint ret=0;\n\twhile(isdigit(*begin)){\n\t\tret*=10;\n\t\tret+=*begin-'0';\n\t\tbegin++;\n\t}\n\tdata[size++]=ret;\n\treturn ret;\n}\n\nint factor(State &begin){\n\tif(*begin=='('){\n\t\tbegin++;\n\t\tkakko[size]++;\n\t\tint ret=expression(begin);\n\t\tkakko[size]--;\n\t\tbegin++;\n\t}else{\n\t\treturn number(begin);\n\t}\n}\n\nint expression(State &begin){\n\tint ret=factor(begin);\n\twhile(1){\n\t\tif(*begin=='+'){\n\t\t\tbegin++;\n\t\t\tdata[size++]=-1;\n\t\t\tret+=expression(begin);\n\t\t}else if(*begin=='-'){\n\t\t\tbegin++;\n\t\t\tdata[size++]=-2;\n\t\t\tret-=expression(begin);\n\t\t}else{\n\t\t\tbreak;\n\t\t}\n\t}\n\treturn ret;\n}\n\nint dp[201][201][2];\n\nint solve(int f,int t,int type){\n\tif(type==0 && dp[f][t][type]!=-INF)return dp[f][t][type];\n\tif(type==1 && dp[f][t][type]!=INF)return dp[f][t][type];\n\tif(t-f==1){\n\t\treturn data[f];\n\t}\n\tif(t-f==3){\n\t\tif(data[f+1]==-1){\n\t\t\treturn data[f]+data[f+2];\n\t\t}\n\t\tif(data[f+1]==-2){\n\t\t\treturn data[f]-data[f+2];\n\t\t}\n\t}\n\tint res=-INF;\n\tif(type==1)res=INF;\n\tfor(int i=f+1;i<t;i+=2){\n\t\tif(data[i]==-2 && kakko[i-1]<=0 && kakko[i+1]>=0){\n\t\t\tif(type==0)res=max(solve(f,i,0)-solve(i+1,t,1),res);\n\t\t\tif(type==1)res=min(solve(f,i,1)-solve(i+1,t,0),res);\n\t\t}\n\t\tif(data[i]==-1 && kakko[i-1]<=0 && kakko[i+1]>=0){\n\t\t\tif(type==0)res=max(solve(f,i,0)+solve(i+1,t,0),res);\n\t\t\tif(type==1)res=min(solve(f,i,1)+solve(i+1,t,1),res);\n\t\t}\n\t}\n\treturn res;\n}\n\nint main(void){\n\tstring str;\n\tcin >> str;\n\tState begin=str.begin();\n\texpression(begin);\n\tfor(int i=0;i<=200;i++){\n\t\tfor(int j=0;j<=200;j++){\n\t\t\tdp[i][j][0]=-INF;\n\t\t\tdp[i][j][1]=INF;\n\t\t}\n\t}\n\tprintf(\"%d\\n\",solve(0,size,0));\n\treturn 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include <iostream>\n#include <string>\n#include <vector>\n#include <algorithm>\n#include <cmath>\n#include <cstdio>\n#include <functional>\n#include <numeric>\n#include <stack>\n#include <queue>\n#include <map>\n#include <set>\n#include <utility>\n#include <sstream>\n#include <complex>\n#include <fstream>\n#include <bitset>\n#include <time.h>\n\nusing namespace std;\n\ntypedef long long ll;\ntypedef pair<ll, ll> P;\ntypedef vector<ll> V;\ntypedef complex<double> Point;\n\n#define PI acos(-1.0)\n#define EPS 1e-10\nconst ll INF = (1LL << 31) - 1;\nconst ll MOD = 1e9 + 7;\n\n#define FOR(i,a,b) for(int i=(a);i<(b);i++)\n#define rep(i,N) for(int i=0;i<(N);i++)\n#define ALL(s) (s).begin(),(s).end()\n#define EQ(a,b) (abs((a)-(b))<EPS)\n#define EQV(a,b) ( EQ((a).real(), (b).real()) && EQ((a).imag(), (b).imag()) )\n#define fi first\n#define se second\n#define N_SIZE (1LL << 20)\n#define NIL -1\n#define MAX_N 100100 * 3\n\nstring s;\nvector<int> pos;\n\nll digit(string& s, int& pos);\n//ll term(& s, int& pos);\nll expr(string& s, int& pos);\nll factor(string& s, int& pos);\n\nbool is_digit(char c) {\n\treturn c >= '0'&&c <= '9';\n}\n\nll digit(string& s, int& pos) {\n\treturn s[pos++] - '0';\n}\n\nll factor(string& s, int& pos) {\n\tif (isdigit(s[pos]))return digit(s, pos);\n\n\tpos++; \n\tll ret = expr(s, pos);\n\tpos++; \n\treturn ret;\n}\n\nll expr(string& s, int& pos) {\n\tll res = factor(s, pos);\n\twhile (s[pos] == '+' || s[pos] == '-') {\n\t\tif (s[pos] == '+') {\n\t\t\tpos++;\n\t\t\tres += factor(s, pos);\n\t\t}\n\t\telse if (s[pos] == '-') {\n\t\t\tpos++;\n\t\t\tres -= factor(s, pos);\n\t\t}\n\t}\n\treturn res;\n}\n\nint main() {\n\tcin >> s;\n\trep(i, s.size()) {\n\t\tif (is_digit(s[i]))pos.push_back(i);\n\t}\n\tint p = 0;\n\tll ans = expr(s, p);\n\t//cout << ans << endl;\n\trep(i, s.size()) {\n\t\tFOR(j, i + 1, s.size()) {\n\t\t\tif (is_digit(s[i]) && is_digit(s[j])) {\n\t\t\t\tp = 0;\n\t\t\t\tstring t = s.substr(0, i) + \"(\" + s.substr(i, j - i + 1) + \")\" + s.substr(j + 1);\n\t\t\t\tbool f = 0;\n\t\t\t\trep(k, t.size() - 2) {\n\t\t\t\t\tif (t[k] == '('&&t[k + 2] == ')')f = 1;\n\t\t\t\t}\n\t\t\t\tif (f)continue;\n\t\t\t\t//cout << t << endl;\n\t\t\t\tll num = expr(t, p);\n\t\t\t\t//cout << num << endl;\n\t\t\t\tif (ans < num) {\n\t\t\t\t\tans = num;\n\t\t\t\t\ts = t;\n\t\t\t\t}\n\t\t\t}\n\t\t\t//cout << \"!!\" << ans << endl;\n\t\t}\n\t}\n\tcout << ans << endl;\n}"
  },
  {
    "language": "C++",
    "code": "#include <iostream>\n#define REP(i, a, n) for(int i = ((int) a); i < ((int) n); i++)\n#define INF 100000000\nusing namespace std;\ntypedef long long ll;\n\nstring S;\nll dp[300][300][2];\n\nll number(int l, int r) {\n  ll ret = 0;\n  REP(i, l, r) {\n    if('0' <= S[i] && S[i] <= '9') ret = ret * 10 + (S[i] - '0');\n    else return -1;\n  }\n  return ret;\n}\n\nll dfs(int l, int r, int sign, int depth) {\n  ll ret;\n\n  if(dp[l][r][(sign + 1) / 2] >= 0) ret = dp[l][r][(sign + 1) / 2];\n  else {\n    ll n = number(l, r);\n    if(n >= 0) ret = sign * n;\n    else {\n      ret = -INF;\n      REP(i, l, r) {\n        int next = S[i] == '+' ? sign : -sign;\n        if(S[i] != '+' && S[i] != '-') continue;\n        ll m1 = dfs(l, i, sign, depth + 1);\n        ll m2 = dfs(i + 1, r, next, depth + 1);\n        ret = max(ret, m1 + m2);\n        ll n1 = dfs(l + (S[l] == '('), i, sign, depth + 1);\n        ll n2 = dfs(i + 1, r - (S[r - 1] == ')'), next, depth + 1);\n        ret = max(ret, n1 + n2);\n      }\n    }\n  }\n\n  return dp[l][r][(sign + 1) / 2] = ret;\n}\n\nint main(void) {\n  cin >> S;\n\n  REP(i, 0, 201) REP(j, 0, 201) REP(k, 0, 2) dp[i][j][k] = -INF;\n  cout << dfs(0, S.size(), 1, 0);\n\n  return 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include<iostream>\n#include<string>\n#include<cstdio>\n#include<vector>\n#include<cmath>\n#include<algorithm>\n#include<functional>\n#include<iomanip>\n#include<queue>\n#include<ciso646>\n#include<random>\n#include<map>\n#include<set>\n#include<complex>\n#include<bitset>\n#include<stack>\n#include<unordered_map>\nusing namespace std;\ntypedef long long ll;\ntypedef unsigned int ui;\nconst ll mod = 1000000007;\nconst ll INF = (ll)1000000007 * 1000000007;\ntypedef pair<int, int> P;\n#define stop char nyaa;cin>>nyaa;\n#define rep(i,n) for(int i=0;i<n;i++)\n#define per(i,n) for(int i=n-1;i>=0;i--)\n#define Rep(i,sta,n) for(int i=sta;i<n;i++)\n#define rep1(i,n) for(int i=1;i<=n;i++)\n#define per1(i,n) for(int i=n;i>=1;i--)\n#define Rep1(i,sta,n) for(int i=sta;i<=n;i++)\ntypedef long double ld;\ntypedef complex<ld> Point;\nconst ld eps = 1e-4;\nconst ld pi = acos(-1.0);\ntypedef pair<ll, ll> LP;\ntypedef pair<ld, ld> LDP;\nstring s; int n;\nint m;\nint num[200];bool ord[200][2];\nchar oper[200];\nbool valid;\nint calc(int le, int ri) {\n\tvalid = true; int res = num[le];\n\tRep1(i, le+1, ri) {\n\t\tif (oper[i - 1] == '+') {\n\t\t\tres += num[i];\n\t\t}\n\t\telse {\n\t\t\tres -= num[i];\n\t\t}\n\t}\n\tRep1(i, le + 1, ri - 1) {\n\t\tif (ord[i][0] || ord[i][1])valid = false;\n\t}\n\tif (ri-le>0&&(ord[le][1] || ord[ri][0]))valid = false;\n\treturn res;\n}\nbool chk[200][200];\nP ans[200][200];\nP dfs(int le, int ri) {\n\tif (chk[le][ri])return ans[le][ri];\n\tchk[le][ri] = true;\n\tif (le > ri)return ans[le][ri] = { 0,0 };\n\tP res = { mod,-mod };\n\tint t = calc(le, ri);\n\tif (valid)res = { t,t };\n\tif (ri - le > 0 && (ord[le][1] || ord[ri][0]))return ans[le][ri]=res;\n\tRep1(i, le+1,ri) {\n\t\tif (ord[i][1])continue;\n\t\tRep1(j, i + 1, ri-1) {\n\t\t\tif (ord[j][0])continue;\n\t\t\t//if (i == le && j == ri)continue;\n\t\t\tP s1 = dfs(le, i - 1),s2=dfs(i,j),s3=dfs(j+1,ri);\n\t\t\tif (s1.first == mod || s2.first == mod || s3.first == mod)continue;\n\t\t\tint mi = s1.first, ma = s1.second;\n\t\t\tif (oper[i - 1] == '+') {\n\t\t\t\tmi += s2.first; ma += s2.second;\n\t\t\t}\n\t\t\telse {\n\t\t\t\tmi -= s2.second; ma -= s2.first;\n\t\t\t}\n\t\t\tif (oper[j] == '+') {\n\t\t\t\tmi += s3.first; ma += s3.second;\n\t\t\t}\n\t\t\telse {\n\t\t\t\tmi -= s3.second; ma -= s3.first;\n\t\t\t}\n\t\t\tres.first = min(res.first, mi);\n\t\t\tres.second = max(res.second, ma);\n\t\t}\n\t}\n\tRep1(i, le + 1, ri - 1) {\n\t\tif (ord[i][0])continue;\n\t\tP s1 = dfs(le, i), s2 = dfs(i + 1, ri);\n\t\tif (s1.first == mod || s2.first == mod)continue;\n\t\tint mi = s1.first, ma = s1.second;\n\t\tif (oper[i] == '+') {\n\t\t\tmi += s2.first; ma += s2.second;\n\t\t}\n\t\telse {\n\t\t\tmi -= s2.second; ma -= s2.first;\n\t\t}\n\t\tres.first = min(res.first, mi);\n\t\tres.second = max(res.second, ma);\n\t}\n\tRep1(i, le + 1, ri - 1) {\n\t\tif (ord[i][1])continue;\n\t\tP s1 = dfs(le, i - 1), s2 = dfs(i, ri);\n\t\tif (s1.first == mod || s2.first == mod)continue;\n\t\tint mi = s1.first, ma = s1.second;\n\t\tif (oper[i - 1] == '+') {\n\t\t\tmi += s2.first; ma += s2.second;\n\t\t}\n\t\telse {\n\t\t\tmi -= s2.second; ma -= s2.first;\n\t\t}\n\t\tres.first = min(res.first, mi);\n\t\tres.second = max(res.second, ma);\n\t}\n\treturn ans[le][ri]=res;\n}\nint main() {\n\tcin.tie(0);\n\tios::sync_with_stdio(false);\n\tcin >> s; n = s.length();\n\tfor (int i = 0; i < n; i += 2) {\n\t\twhile (s[i] == '(') {\n\t\t\tord[m][0] = true; i++;\n\t\t}\n\t\tnum[m] = s[i] - '0';\n\t\twhile (i + 1 < n&&s[i + 1] == ')') {\n\t\t\tord[m][1] = true; i++;\n\t\t}\n\t\tif (i + 1 < n) {\n\t\t\toper[m] = s[i + 1];\n\t\t}\n\t\tm++;\n\t}\n\tcout << dfs(0, m - 1).second << endl;\n\t/*rep(i,m) {\n\t\tRep(j, i, m) {\n\t\t\tcout << i << \" \" << j << endl;\n\t\t\tcout << ans[i][j].first << \" \" << ans[i][j].second << endl;\n\n\t\t}\n\t}\n\trep(i, m) {\n\t\tcout << num[i] << endl;\n\t}*/\n\treturn 0;\n}\n"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\nusing namespace std;\nint dp[201][201][2];\nint main() {\n  string s;\n  cin >> s;\n  int n=s.size();\n  for(int i=0;i<n;i++){\n    for(int j=0;j<n;j++)dp[i][j][0]=1<<29,dp[i][j][1]=-(1<<29);\n    if(isdigit(s[i]))dp[i][i][0]=dp[i][i][1]=s[i]-'0';\n  }\n  for(int i=0; i<n; i++){\n    for(int j=0;j<n-i;j++){\n      if(s[j]=='(')dp[j][j+i][0]=min(dp[j][j+i][0],dp[j+1][j+i][0]),dp[j][j+i][1]=max(dp[j][j+i][1],dp[j+1][j+i][1]);\n      if(s[j+i]==')')dp[j][j+i][0]=min(dp[j][j+i][0],dp[j][j+i-1][0]),dp[j][j+i][1]=max(dp[j][j+i][1],dp[j][j+i-1][1]);\n    }\n    for(int j=0;j<n-i;j++){\n      if(s[j]=='+'||s[j]=='-'||s[j+i]=='+'||s[j+i]=='-')continue;\n      for(int k=j+1;k<=j+i-1;k++){\n        if((j+2<=k&&s[k-2]=='(')||(k<=j+i-2&&s[k+2]==')'))continue;\n        if(s[k]=='+'||s[k]=='-'){\n          for(int x=0;x<2;x++)for(int y=0;y<2;y++){\n              if(abs(dp[j][k-1][x])>=(1<<29)||abs(dp[k+1][j+i][y])>=(1<<29))continue;\n              dp[j][j+i][0]=min(dp[j][j+i][0],dp[j][k-1][x]+dp[k+1][j+i][y]*(s[k]=='+'?1:-1));\n              dp[j][j+i][1]=max(dp[j][j+i][1],dp[j][k-1][x]+dp[k+1][j+i][y]*(s[k]=='+'?1:-1));\n            }\n        }\n      }\n    }\n  }\n  cout<<dp[0][n-1][1]<<endl;\n  return 0;\n}\n"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\nusing namespace std;\ntypedef pair<int,int>P;\n#define F first\n#define S second\nint INF=1e9;\nstring s;\nP init=P(INF,-INF);\nvector<vector<P> >dp(200,vector<P>(200,init));\n\nP dfs(int l,int r){\n\tif(l==r)return P(s[l]-'0',s[l]-'0');\n\tif(dp[l][r]!=init)return dp[l][r];\n\tP res=init;\n\tif(s[l]=='('&&r-l>2) res=dfs(l+1,r);\n\tif(s[r]==')'&&r-l>2) res=dfs(l,r-1);\n\tfor(int i=l+1;i<r;i++){\n\t\tif(!(s[i]=='-'||s[i]=='+'))continue;\n\t\tP a=dfs(l,i-1);\n\t\tP b=dfs(i+1,r);\n\t\tif(s[i]=='-'){\n\t\t\tres.F=min(res.F,a.F-b.S);\n\t\t\tres.S=max(res.S,a.S-b.F);\n\t\t}\n\t\tif(s[i]=='+'){\n\t\t\tres.F=min(res.F,a.F+b.F);\n\t\t\tres.S=max(res.S,a.S+b.S);\n\t\t}\n\t}\n\treturn dp[l][r]=res;\n}\n\nmain(){\n\tcin>>s;\n\tcout<<dfs(0,s.size()-1).S<<endl;\n}\n"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\nusing namespace std;\ntypedef pair<int,int>P;\n#define F first\n#define S second\nint INF=1e9;\nstring s;\nP dp[222][222],init=P(INF,-INF);\n\nP dfs(int l,int r){\n\tif(l==r)return P(s[l]-'0',s[l]-'0');\n\tif(dp[l][r]!=init)return dp[l][r];\n\tP res=init;\n\tif(s[l]=='('&&r-l>2) res=dfs(l+1,r);\n\tif(s[r]==')'&&r-l>2) res=dfs(l,r-1);\n\tfor(int i=l+1;i<r;i++){\n\t\tif(!(s[i]=='-'||s[i]=='+'))continue;\n\t\tP a=dfs(l,i-1);\n\t\tP b=dfs(i+1,r);\n\t\tif(s[i]=='-'){\n\t\t\tres.F=min(res.F,a.F-b.F);\n\t\t\tres.S=max(res.S,a.S-b.F);\n\t\t}\n\t\tif(s[i]=='+'){\n\t\t\tres.F=min(res.F,a.F+b.F);\n\t\t\tres.S=max(res.S,a.S+b.F);\n\t\t}\n\t}\n\treturn dp[l][r]=res;\n}\n\nint main(){\n\tcin>>s;\n\tfor(int i=0;i<222;i++)\n\t\tfor(int j=0;j<222;j++)dp[i][j]=init;\n\tcout<<dfs(0,s.size()-1).S<<endl;\n}\n"
  },
  {
    "language": "C++",
    "code": "#include <iostream>\n#include <cctype>\n#include <vector>\nusing namespace std;\n\nint main(){\n    string S;\n    cin>>S;\n    vector<pair<int,int>> D;\n    vector<char> OP;\n    for(int i=0;i<S.size();i++){\n        if(isdigit(S[i])) D.emplace_back(i,S[i]-'0');\n        if(S[i]=='+'||S[i]=='-') OP.push_back(S[i]);\n\n    }\n    int N = D.size();\n    bool R[N],L[N];\n    fill(R,R+N,true);\n    fill(L,L+N,true);\n    R[0]=L[N-1]=false;\n    for(int i=0;i<N;i++){\n        if(D[i].first>0&&S[D[i].first-1]=='(') R[i]=false;\n        if(D[i].first+1<S.size()&&S[D[i].first+1]==')') L[i]=false;\n    }\n    int DP_MIN[N][N+1],DP_MAX[N][N+1];//[l,r)\n    fill(DP_MIN[0],DP_MIN[N],1000000);\n    fill(DP_MAX[0],DP_MAX[N],-1000000);\n    for(int i=0;i<N;i++){\n        DP_MAX[i][i+1]=DP_MIN[i][i+1]=D[i].second;\n    }\n    for(int len=2;len<=N;len++){\n        for(int l=0;l+len<=N;l++){\n            if(L[l]&&R[l+len-1]){\n                for(int r=l+1;r<l+len;r++){\n                    if(DP_MAX[l][r]!=-1000000&&DP_MAX[r][l+len]!=-1000000){\n                        DP_MAX[l][l+len]=max(DP_MAX[l][l+len],DP_MAX[l][r]+(OP[r-1]=='+'?DP_MAX[r][l+len]:-DP_MIN[r][l+len]));\n                        DP_MIN[l][l+len]=min(DP_MIN[l][l+len],DP_MIN[l][r]+(OP[r-1]=='+'?DP_MIN[r][l+len]:-DP_MAX[r][l+len]));\n                    }\n                }\n            }\n            // cout<<\"l: \"<<l<<\" r: \"<<l+len<<' '<<DP_MIN[l][l+len]<<' '<<DP_MAX[l][l+len]<<endl;\n        }\n    }\n    cout<<DP_MAX[0][N]<<endl;\n    return 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\n#define INF (1e9)\nusing namespace std;\n\n\nint calc(string s){\n  vector<int> v;\n  for(int i=0;i<s.size();i++){\n    int n = (int)v.size()-1;\n    if(s[i]=='+')v.push_back(0);\n    if(s[i]=='-')v.push_back(1);\n    if(s[i]=='(')v.push_back(0),v.push_back(0);\n    if(s[i]==')'){\n      if(v.size()<3)continue;\n      v[n-2]+=v[n-1]? -v[n]:v[n];\n      v.pop_back(),v.pop_back();\n    }\n\n    if(isdigit(s[i])){\n      int num=s[i]-'0';\n      if(v.size()>=2){\n\tv[n-1]+=v[n]? -num:num;\n\tv.pop_back();\n      }\n      else v.push_back(num);\n    }\n  }\n  return v[0];\n}\n\nmap<string,int> mem[2];\nint dfs(string s,int f){\n  if(s.size()==1) return s[0]-'0';\n  //  if(mem[f].count(s))return mem[f][s];\n  \n  int n=s.size(),res=calc(s),d=-1;\n  for(int i=0;i<n;i++) if(s[i]=='+'||s[i]=='-')d++;\n  for(int i=0,c=0,cnt=0;i<n;i++,cnt++,d--){\n    while(i<n){\n      while(s[i]=='('||s[i]==')')c+=(s[i]=='(')-(s[i]==')'),i++;\n      if(s[i]=='+'||s[i]=='-') break;\n      i++;\n    }\n    if(i>=n||(cnt&&s[i-2]=='(')||(d&&s[i+2]==')'))continue;\n    string a=s.substr(0,i),b=s.substr(i+1,n-i-1);\n    int t=c,ch=s[i];\n    while(t--)a+=')',b='('+b;\n    int mxa=dfs(a,0),mna=dfs(a,1);\n    int mxb=dfs(b,0),mnb=dfs(b,1);\n    if(f==0&&ch=='+') res=max(res, mxa+mxb);\n    if(f==0&&ch=='-') res=max(res, mxa-mnb);\n    if(f==1&&ch=='+') res=min(res, mna+mnb);\n    if(f==1&&ch=='-') res=min(res, mna-mxb);\n  }\n  return mem[f][s]=res;\n}\n\n\n\n\nint main(){\n  string S;\n  cin>>S;\n\n  cout <<dfs(S,0)<<endl;\n  return 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include<bits/stdc++.h>\nusing namespace std;\n#define INF (1e8)\n#define MAX 205\nint n;\nchar s[MAX];\n\nint dpA[MAX][MAX];\nint dpB[MAX][MAX];\nbool flgA[MAX][MAX];\nbool flgB[MAX][MAX];\n\nint solveA(int,int);\nint solveB(int,int);\n\nint main(){\n  scanf(\"%s\",s);\n  n=strlen(s);\n  int ans=solveA(0,n);\n  assert( abs(ans) < 1e6 );\n  printf(\"%d\\n\",ans);\n  return 0;\n}\n\nint solveA(int l,int r){\n  if(flgA[l][r])return dpA[l][r];\n  flgA[l][r]=true;\n  int res=-INF,cnt=0,num=0;\n  int L=INF,R=-INF;\n  for(int i=l;i<r;i++){\n    if(s[i]<'0'||'9'<s[i])continue;\n    L=min(L,i);\n    R=max(R,i);\n  }\n  for(int i=l;i<r;i++){\n    if(s[i]=='+'){\n      if(L<=i-3&&'0'<=s[i-1]&&s[i-1]<='9'&&s[i-2]=='(')continue;\n      if(i+3< R&&'0'<=s[i+1]&&s[i+1]<='9'&&s[i+2]==')')continue;\n      res=max(res, solveA(l,i)+solveA(i+1,r));\n    }else if(s[i]=='-'){\n      if(L<=i-3&&'0'<=s[i-1]&&s[i-1]<='9'&&s[i-2]=='(')continue;\n      if(i+3< R&&'0'<=s[i+1]&&s[i+1]<='9'&&s[i+2]==')')continue;\n      res=max(res, solveA(l,i)-solveB(i+1,r));\n    }else if('0'<=s[i]&&s[i]<='9'){\n      cnt++;\n      num=s[i]-'0';\n    }\n  }\n  if(cnt==1)res=num;\n\n    \n  return dpA[l][r]=res;\n}\n\nint solveB(int l,int r){\n  if(flgB[l][r])return dpB[l][r];\n  flgB[l][r]=true;\n  int res=INF,cnt=0,num=0;\n  int L=INF,R=-INF;\n  for(int i=l;i<r;i++){\n    if(s[i]<'0'||'9'<s[i])continue;\n    L=min(L,i);\n    R=max(R,i);\n  }\n  \n  for(int i=l;i<r;i++){\n    if(s[i]=='+'){\n      if(L<=i-3&&'0'<=s[i-1]&&s[i-1]<='9'&&s[i-2]=='(')continue;\n      if(i+3<R &&'0'<=s[i+1]&&s[i+1]<='9'&&s[i+2]==')')continue;\n      res=min(res, solveB(l,i)+solveB(i+1,r));\n    }else if(s[i]=='-'){\n      if(L<=i-3&&'0'<=s[i-1]&&s[i-1]<='9'&&s[i-2]=='(')continue;\n      if(i+3< R&&'0'<=s[i+1]&&s[i+1]<='9'&&s[i+2]==')')continue;\n      res=min(res, solveB(l,i)-solveA(i+1,r));\n    }else if('0'<=s[i]&&s[i]<='9'){\n      cnt++;\n      num=s[i]-'0';\n    }\n  }\n  if(cnt==1)res=num;\n  return dpB[l][r]=res;\n}"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\n#define N 201\nusing namespace std;\n\n/*\nint p;\nint bnf(){\n  int res=0;\n  while(p<S.size()){\n    if(S[p]=='(')p++,res=bnf();\n    else if(isdigit(S[p]))res=S[p++]-'0';\n    else if(S[p]=='+')p++,res+=bnf();\n    else if(S[p]=='-')p++,res-=bnf();\n    else break;\n    }\n  p++;\n  return res;\n  }\n*/\n\n\nint skip(string &str,int i){\n  if(str[i]!='(')return i;\n  string res;\n  int cnt=1;i++;\n  while(1) {\n    if(str[i]=='(')cnt++;\n    if(str[i]==')')cnt--;\n    if(!cnt)break;\n    res+=str[i++];\n  }\n  return i;\n}\n \n\nmap<string,int>mem[2];\nint dfs(string str,int flg){\n  if(str.size()==1) return str[0]-'0';\n  if(mem[flg].count(str)) return mem[flg][str];\n  if(skip(str,0)==(int)str.size()-1)return dfs(str.substr(1,str.size()-2),flg);\n\n  int res=flg? 1e9:-1e9;\n  for(int i=0;(i=skip(str,i))<str.size()-1;i+=2){\n    string L=str.substr(0,i+1),R=str.substr(i+2,str.size()-i-2);\n    int Lmx=dfs(L,0),Lmn=dfs(L,1);\n    int Rmx=dfs(R,0),Rmn=dfs(R,1);\n    if(str[i+1]=='-') res=flg? min(res,Lmn-Rmx):max(res,Lmx-Rmn);\n    if(str[i+1]=='+') res=flg? min(res,Lmn+Rmn):max(res,Lmx+Rmx);\n  }\n  return mem[flg][str]=res;\n}\n\n\nint main(){\n  string S,tmp;\n  cin>>S;\n  int cnt=0;\n  if(skip(S,0)==S.size()-1)S=S.substr(1,S.size()-2);\n  for(int i=0;i<S.size();i++) {\n    if(S[i]!=')')tmp+=S[i];\n    if(i&&(S[i-1]=='+'||S[i-1]=='-')&&cnt)tmp+=')',cnt--;\n    if(S[i]=='(')cnt++;\n  }\n  \n  cout<<dfs(tmp,0)<<endl;  \n  return 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\nusing namespace std;\n\ntypedef long long ll;\ntypedef unsigned long long ull;\ntypedef pair<ll, ll> P;\n\n#define fi first\n#define se second\n#define repl(i,a,b) for(ll i=(ll)(a);i<(ll)(b);i++)\n#define rep(i,n) repl(i,0,n)\n#define each(itr,v) for(auto itr:v)\n#define pb push_back\n#define all(x) (x).begin(),(x).end()\n#define dbg(x) cout<<#x\"=\"<<x<<endl\n#define mmax(x,y) (x>y?x:y)\n#define mmin(x,y) (x<y?x:y)\n#define maxch(x,y) x=mmax(x,y)\n#define minch(x,y) x=mmin(x,y)\n#define uni(x) x.erase(unique(all(x)),x.end())\n#define exist(x,y) (find(all(x),y)!=x.end())\n#define bcnt __builtin_popcount\n\n#define INF INT_MAX/3\n\nchar s[222];\nint n;\nbool lc[222],rc[222];\nint dp[222][222][2];\n\nint f(int l,int r,int flag){\n  if(l+1==r)return s[l]-'0'; // num\n  if(dp[l][r][flag]!=-INF-1)return dp[l][r][flag];\n\n  int res=flag?INF:-INF;\n  repl(i,l,r){\n    if(s[i]!='+'&&s[i]!='-')continue;\n    if((lc[i]&&i-2>=l)||(rc[i]&&i+2<r))continue;\n    int op=s[i]=='+'?+1:-1;\n    int lnum=f(l,i,flag),rnum=f(i+1,r,op==+1?flag:1-flag);\n    if(!flag)maxch(res,lnum+op*rnum);\n    else minch(res,lnum+op*rnum);\n  }\n  return dp[l][r][flag]=res;\n}\n\nint main(){\n\tcin.sync_with_stdio(false);\n  cin>>s;\n  n=strlen(s);\n  rep(i,222)rep(j,222)rep(k,2)dp[i][j][k]=-INF-1;\n  rep(i,n){\n    if(i-2>=0&&(s[i]=='+'||s[i]=='*')&&s[i-2]=='(')lc[i]=true;\n    if(i+2<n&&(s[i]=='+'||s[i]=='*')&&s[i+2]==')')rc[i]=true;\n  }\n  rep(i,n){\n    if(s[i]=='('||s[i]==')')s[i]=0;\n  }\n  rep(i,n){\n    if(s[i]!=0)continue;\n    repl(j,i,n){\n      s[j]=s[j+1];\n      lc[j]=lc[j+1];\n      rc[j]=rc[j+1];\n    }\n  }\n  n=strlen(s);\n  cout<<f(0,n,0)<<endl;\n\treturn 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\n\nusing namespace std;\n\n#define int long long\n#define all(v) begin(v), end(v)\n#define rep(i, n) for(int i = 0; i < (int)(n); i++)\n#define reps(i, s, n) for(int i = (int)(s); i < (int)(n); i++)\n\ntemplate<class T1, class T2> void chmin(T1 &a, T2 b){if(a>b)a=b;}\ntemplate<class T1, class T2> void chmax(T1 &a, T2 b){if(a<b)a=b;}\n\nusing pint = pair<int, int>;\nusing tint = tuple<int, int, int>;\nusing vint = vector<int>;\n\nconst int inf = 1LL << 55;\nconst int mod = 1e9 + 7;\n\nsigned main()\n{\n  cin.tie(0);\n  ios_base::sync_with_stdio(0);\n  cout << fixed << setprecision(12);\n\n  string s;\n  cin >> s;\n  int dp[2][202][202];\n  rep(i, 202) rep(j, 202) {\n    dp[0][i][j] = -inf;\n    dp[1][i][j] = inf;\n  }\n  reps(len, 1, s.size()+1) {\n    rep(i, s.size()+1-len) {\n      int j = i + len;\n      if(len == 1 && isdigit(s[i])) {\n\tdp[0][i][j] = dp[1][i][j] = s[i]-'0';\n      }\n\n      if(len < 3) continue;\n\n      if(len > 3) { // a+<(b>?????????????????????a+<(b+c>???ok / ()???????????????????????????4??\\???\n\tif(s[i] == '(') {\n\t  chmax(dp[0][i][j], dp[0][i+1][j]);\n\t  chmin(dp[1][i][j], dp[1][i+1][j]);\n\t} else if(s[j-1] == ')') { // <a)>+b <z+a)>+b\n\t  chmax(dp[0][i][j], dp[0][i][j-1]);\n\t  chmin(dp[1][i][j], dp[1][i][j-1]);\n\t}\n      }\n\n\n      reps(k, i+1, j-1) {\n\tif(s[k] == '+') {\n\t  chmax(dp[0][i][j], dp[0][i][k]+dp[0][k+1][j]);\n\t  chmin(dp[1][i][j], dp[1][i][k]+dp[1][k+1][j]);\n\t} else if(s[k] == '-') {\n\t  chmax(dp[0][i][j], dp[0][i][k]-dp[1][k+1][j]);\n\t  chmin(dp[1][i][j], dp[1][i][k]-dp[0][k+1][j]);\n\t}\n      }\n    }\n  }\n  //rep(i, s.size()) reps(j, i+1, s.size()+1) cout << dp[0][i][j]<<endl;\n  cout << dp[0][0][s.size()] << endl;\n\n  return 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\n\n#define _overload(_1,_2,_3,name,...) name\n#define _rep(i,n) _range(i,0,n)\n#define _range(i,a,b) for(int i=int(a);i<int(b);++i)\n#define rep(...) _overload(__VA_ARGS__,_range,_rep,)(__VA_ARGS__)\n\n#define _rrep(i,n) _rrange(i,n,0)\n#define _rrange(i,a,b) for(int i=int(a)-1;i>=int(b);--i)\n#define rrep(...) _overload(__VA_ARGS__,_rrange,_rrep,)(__VA_ARGS__)\n\n#define _all(arg) begin(arg),end(arg)\n#define uniq(arg) sort(_all(arg)),(arg).erase(unique(_all(arg)),end(arg))\n#define getidx(ary,key) lower_bound(_all(ary),key)-begin(ary)\n#define clr(a,b) memset((a),(b),sizeof(a))\n#define bit(n) (1LL<<(n))\n#define popcount(n) (__builtin_popcountll(n))\n\ntemplate<class T>bool chmax(T &a, const T &b) { return (a<b)?(a=b,1):0;}\ntemplate<class T>bool chmin(T &a, const T &b) { return (b<a)?(a=b,1):0;}\n\nusing namespace std;\nconst int inf=1<<20;\n\nint num[210];\nchar op[210];\nbool lb[210],rb[210];\n\nint memo[210][210];\n\nint rec(int l,int r){\n\tif(r-l==1) return num[l];\n\n\tif(lb[r-1]) return -inf;\n\tif(rb[l]) return -inf;\n\t\n\tint &ret=memo[l][r];\n\tif(ret!=-inf) return ret;\n\n\trep(m,l+1,r){\n\t\tint a=rec(l,m),b=rec(m,r);\n\t\tif(a==-inf||b==-inf) continue;\n\t\tif(op[m]=='+')\n\t\t\tchmax(ret,a+b);\n\t\telse\n\t\t\tchmax(ret,a-b);\n\t}\n\n\treturn ret;\n}\n\n\nint main(void){\n\tstring s;\n\tcin >> s;\n\n\tint tidx=0,oidx=1;\n\tfor(auto &c:s){\n\t\tif(c=='(') lb[tidx]=true;\n\t\tif(c==')') rb[tidx-1]=true;\n\t\tif(isdigit(c)) num[tidx++]=c-'0';\n\t\tif(c=='+'||c=='-') op[oidx++]=c;\n\t}\n\n\t// rep(i,5) cout << num[i] << \" \" << lb[i] << \" \" << rb[i] << endl;\n\t// rep(i,1,5) cout << op[i] << endl;\n\n\trep(i,210)rep(j,210) memo[i][j]=-inf;\n\tcout << rec(0,tidx) << endl;\n\n\treturn 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\nusing namespace std;\n#define int long long\n#define REP(i, n) for (int i = 0; i < (n); i++)\n#define fi first\n#define se second\nusing ii = pair<int, int>;\n\nconstexpr int HOGE = 1e17 + 100;\nint exp1(const string& s, int& i, int r);\nint exp2(const string& s, int& i, int r);\nint exp1(const string& s, int& i, int r) {\n    int acc = exp2(s, i, r);\n    while (i < r) {\n        if (s[i] == '+') {\n            acc += exp2(s, ++i, r);\n        } else if (s[i] == '-') {\n            acc -= exp2(s, ++i, r);\n        } else\n            return acc;\n        // assert(0);\n    }\n    return acc;\n}\nint exp2(const string& s, int& i, int r) {\n    if (s[i] == '(') {\n        int ret = exp1(s, ++i, r);\n        assert(s[i++] == ')');\n        return ret;\n    }\n    if (isdigit(s[i])) return s[i++] - '0';\n    // assert(0);\n    return exp1(s, i, r);\n}\nbool is_valid(const string& s, int i, int r) {\n    int acc = 0;\n    for (int j = i; j < r; j++) {\n        if (s[j] == '(') acc++;\n        if (s[j] == ')') acc--;\n        if (acc < 0) return false;\n    }\n    return acc == 0;\n}\nsigned main() {\n    ios::sync_with_stdio(false);\n    cin.tie(0);\n\n    string s;\n    cin >> s;\n    vector<int> num, idx, op_idx;\n    op_idx.push_back(-1);\n    vector<char> ops;\n    REP(i, s.size()) {\n        if (isdigit(s[i])) {\n            num.push_back(s[i] - '0');\n            idx.push_back(i);\n        }\n        if (s[i] == '+' || s[i] == '-') {\n            ops.push_back(s[i]);\n            op_idx.push_back(i);\n        }\n    }\n    op_idx.push_back(s.size());\n\n    auto valid = [&](int i) { return 0 <= i && i < s.size(); };\n\n    constexpr ii DMY = {1e17, 1e17};\n    int m = num.size();\n    vector<vector<ii>> dp(m, vector<ii>(m, DMY));\n    function<ii(int, int)> dfs = [&](int i, int j) {\n        if (dp[i][j] != DMY) return dp[i][j];\n        if (i == j) return dp[i][j] = {num[i], num[i]};\n        int mi = 1e18, ma = -1e18;\n        int l_idx = idx[i];\n        int r_idx = idx[j];\n        if (is_valid(s, l_idx, r_idx + 1)) {\n            mi = ma = exp1(s, l_idx, r_idx + 1);\n        }\n        for (int k = i; k < j; k++) {\n            if (k != i && valid(idx[k] - 1) && s[idx[k] - 1] == '(') continue;\n            if (k != j - 1 && valid(idx[k + 1] + 1) && s[idx[k + 1] + 1] == ')') continue;\n            ii l = dfs(i, k);\n            ii r = dfs(k + 1, j);\n            if (ops[k] == '+') {\n                mi = min(mi, l.fi + r.fi);\n                ma = max(ma, l.se + r.se);\n            } else {\n                // assert(ops[k] == '-');\n                mi = min(mi, l.fi - r.se);\n                ma = max(ma, l.se - r.fi);\n            }\n        }\n        return dp[i][j] = {mi, ma};\n    };\n    dfs(0, m - 1);\n    cout << dp[0][m - 1].se << endl;\n}\n\n"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\n#define N 201\nusing namespace std;\n\n/*\nint p;\nint bnf(){\n  int res=0;\n  while(p<S.size()){\n    if(S[p]=='(')p++,res=bnf();\n    else if(isdigit(S[p]))res=S[p++]-'0';\n    else if(S[p]=='+')p++,res+=bnf();\n    else if(S[p]=='-')p++,res-=bnf();\n    else break;\n    }\n  p++;\n  return res;\n  }\n*/\n\n\nint skip(string &str,int i){\n  if(str[i]!='(')return i;\n  string res;\n  int cnt=1;i++;\n  while(1) {\n    if(str[i]=='(')cnt++;\n    if(str[i]==')')cnt--;\n    if(!cnt)break;\n    res+=str[i++];\n  }\n  return i;\n}\n\n\nbool check(char ch){return ch=='+'||ch=='-';}\nbool check(string str){\n  for(int i=1;i<(int)str.size()-1;i++)\n    if(str[i-1]=='('&&isdigit(str[i])&&str[i+1]==')')return 0;\n  return 1;\n}\n\nmap<string,int>mem[2];\nint dfs(string str,int flg){\n  \n  if(str.size()==1) return str[0]-'0';\n  if(mem[flg].count(str)) return mem[flg][str];\n  if(skip(str,0)==(int)str.size()-1)return dfs(str.substr(1,str.size()-2),flg);\n  \n  int res=flg? 1e9:-1e9,cnt=0;\n  for(int i=0;i<str.size()-1;i++){\n    if(str[i]=='(')cnt++;\n    if(str[i]==')')cnt--;\n    if(!check(str[i+1]))continue;\n    string L=str.substr(0,i+1),R=str.substr(i+2,str.size()-i-2);\n    int t=cnt;\n    if(cnt&&check(str[i+1]))while(cnt)cnt--,L+=')',R='('+R;\n    if(cnt)continue;\n    cnt=t;\n    \n    if(!check(L)||!check(R))continue;\n    //  cout <<\"cnt=\"<<cnt<<\"|\"<< L<<\"| |\"<<R<<\"|\"<<endl;    \n    int Lmx=dfs(L,0),Lmn=dfs(L,1);\n    int Rmx=dfs(R,0),Rmn=dfs(R,1);\n    if(str[i+1]=='-') res=flg? min(res,Lmn-Rmx):max(res,Lmx-Rmn);\n    if(str[i+1]=='+') res=flg? min(res,Lmn+Rmn):max(res,Lmx+Rmx);\n  }\n  return mem[flg][str]=res;\n}\n\nint main(){\n  string S;\n  cin>>S;\n  cout<<dfs(S,0)<<endl;  \n  return 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\nusing namespace std;\n\nint calc(string &s,int &i){\n  int res=0;\n  while(1){\n    if(isdigit(s[i]))res=s[i++]-'0';\n    else if(s[i]=='('){res=calc(s,++i),i++;}\n    else if(s[i]=='+')res+=calc(s,++i);\n    else if(s[i]=='-')res-=calc(s,++i);\n    else break;\n  }\n  return res;\n}\n\nmap<string,int> mem[2];\nint dfs(string &s,int f){\n  if(mem[f].count(s))return mem[f][s];\n\n  int j=0,res=calc(s,j),n=s.size(),d=-1;\n  for(int i=0;i<n;i++) d+=(s[i]=='+'||s[i]=='-');\n  \n  for(int i=0,c=0,cnt=0;i<n;i++,cnt++,d--){\n    while(1){\n      while(s[i]=='('||s[i]==')')c+=(s[i]=='(')-(s[i]==')'),i++;\n      if(i>=n||s[i]=='+'||s[i]=='-') break;\n      i++;\n    }\n    if(i>=n||(cnt&&s[i-2]=='(')||(d&&s[i+2]==')'))continue;\n    string a=s.substr(0,i),b=s.substr(i+1,n-i-1);\n    int t=c,ch=s[i];\n    while(t--)a+=')',b='('+b;\n    int mxa=dfs(a,0),mna=dfs(a,1);\n    int mxb=dfs(b,0),mnb=dfs(b,1);\n    if(f==0&&ch=='+') res=max(res, mxa+mxb);\n    if(f==0&&ch=='-') res=max(res, mxa-mnb);\n    if(f==1&&ch=='+') res=min(res, mna+mnb);\n    if(f==1&&ch=='-') res=min(res, mna-mxb);\n  }\n  return mem[f][s]=res;\n}\n\nint main(){\n  string S;\n  cin>>S;\n  cout <<dfs(S,0)<<endl;\n  return 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include <iostream>\n#include <string>\n#include <algorithm>\n#include <utility>\nusing namespace std;\ntypedef pair<int, int> pii;\nvoid chmax(int &a, int b) {a = max(a, b);}\nvoid chmin(int &a, int b) {a = min(a, b);}\nconst int INF = 1 << 28;\nstring s;\nint N, dp_max[210][210], dp_min[210][210];\n\nvoid solve(int l, int r) {\n    if(dp_max[l][r] != -INF) return;\n    // 数字\n    if(r - l == 1 && isdigit(s[l])) {\n        dp_max[l][r] = dp_min[l][r] = s[l] - '0';\n    }\n    // 括弧をとっぱらって再帰的に\n    // このとき、括弧含め幅が 3 以下 (つまり実質 2 以下) だと\n    // 数式になりえないので飛ばす\n    if(s[l] == '(' && r-l > 3) {\n        solve(l+1, r);\n        chmax(dp_max[l][r], dp_max[l+1][r]);\n        chmin(dp_min[l][r], dp_min[l+1][r]);\n    }\n    if(s[r-1] == ')' && r-l > 3) {\n        solve(l, r-1);\n        chmax(dp_max[l][r], dp_max[l][r-1]);\n        chmin(dp_min[l][r], dp_min[l][r-1]);\n    }\n    for(int k=l; k<r; k++) {\n        if(s[k] != '+' && s[k] != '-') continue;\n        solve(l, k);\n        solve(k+1, r);\n        if(dp_max[l][k] == -INF || dp_max[k+1][r] == -INF) continue;\n        if(s[k] == '+') {\n            chmax(dp_max[l][r], dp_max[l][k] + dp_max[k+1][r]);\n            chmin(dp_min[l][r], dp_min[l][k] + dp_min[k+1][r]);\n        }\n        else {\n            chmax(dp_max[l][r], dp_max[l][k] - dp_min[k+1][r]);\n            chmin(dp_min[l][r], dp_min[l][k] - dp_max[k+1][r]);\n        }\n    }\n}\n\nint main() {\n    cin >> s;\n    N = s.length();\n    for(int i=0; i<N; i++) {\n        fill(dp_max[i], dp_max[i] + N + 1, -INF);\n        fill(dp_min[i], dp_min[i] + N + 1, INF);\n    }\n\n    solve(0, N);\n    /*\n    for(int i=0; i<N; i++) {\n        for(int j=i+1; j<=N; j++) {\n            if(dp_max[i][j] == -INF) continue;\n            printf(\"%s\\n\", s.c_str());\n            for(int k=0; k<N; k++) {\n                if(i <= k && k < j) printf(\"=\");\n                else printf(\" \");\n            }\n            printf(\" -> %d\\n\", dp_max[i][j]);\n        }\n    }\n    */\n    printf(\"%d\\n\", dp_max[0][N]);\n    return 0;\n}\n"
  },
  {
    "language": "C++",
    "code": "#include<bits/stdc++.h>\nusing namespace std;\n\n#define REP(i,n) for(int i=0;i<(int)(n);i++)\n#define ALL(a) (a).begin(),(a).end()\n\nconstexpr int INF = 1000000000;\n\nenum CYK_TABLE {\n  DIGIT,\n  LPAR,\n  RPAR,\n  PLUS,\n  MINUS,\n  TERM,\n  RPEXPR,\n  RMEXPR,\n  LEXPR,\n  EXPR\n};\n\nint main(){\n  int N = 10;\n  string s;\n  cin>>s;\n  int n = s.size();\n  vector<vector<vector<bool>>> cyk(n, vector<vector<bool>>(n+1, vector<bool>(N, false)));\n  vector<vector<vector<int>>> mn(n, vector<vector<int>>(n+1, vector<int>(N, INF)));\n  vector<vector<vector<int>>> mx(n, vector<vector<int>>(n+1, vector<int>(N, -INF)));\n  REP(i,n) {\n    if (isdigit(s[i])) {\n      cyk[i][1][DIGIT] = true;\n      mn[i][1][DIGIT] = s[i] - '0';\n      mx[i][1][DIGIT] = s[i] - '0';\n    } else {\n      switch (s[i]) {\n        case '(':\n        cyk[i][1][LPAR] = true;\n        break;\n        case ')':\n        cyk[i][1][RPAR] = true;\n        break;\n        case '+':\n        cyk[i][1][PLUS] = true;\n        break;\n        case '-':\n        cyk[i][1][MINUS] = true;\n        break;\n      }\n    }\n  }\n  vector<pair<int, int>> m = {\n    {DIGIT, TERM},\n    {EXPR, TERM},\n    {EXPR, LEXPR},\n    {LEXPR, EXPR}\n  };\n  map<pair<int,int>, int> m2 = {\n    {{PLUS, TERM}, RPEXPR},\n    {{TERM, RPEXPR}, EXPR},\n    {{MINUS, TERM}, RMEXPR},\n    {{TERM, RMEXPR}, EXPR},\n    {{LPAR, EXPR}, LEXPR},\n    {{LEXPR, RPAR}, EXPR}\n  };\n  for (int l = 1; l <= n; ++l) {\n    REP(i,n) {\n      if (i+l > n) continue;\n      REP(k,l) {\n        if (k == 0) continue;\n        for (auto p : m2) {\n          int left, right, res;\n          pair<int,int> tmp;\n          tie(tmp, res) = p;\n          tie(left, right) = tmp;\n          if (cyk[i][k][left] && cyk[i+k][l-k][right]) {\n            cyk[i][l][res] = true;\n            if (right == RPEXPR) {\n              mn[i][l][res] = min(mn[i][l][res],\n                  mn[i][k][left] + mn[i+k][l-k][right]);\n              mx[i][l][res] = max(mx[i][l][res],\n                  mx[i][k][left] + mx[i+k][l-k][right]);\n            } else if (right == RMEXPR) {\n              mn[i][l][res] = min(mn[i][l][res],\n                  mn[i][k][left] - mx[i+k][l-k][right]);\n              mx[i][l][res] = max(mx[i][l][res],\n                  mx[i][k][left] - mn[i+k][l-k][right]);\n            } else if (right == EXPR || right == TERM) {\n              mn[i][l][res] = min(mn[i][l][res], mn[i+k][l-k][right]);\n              mx[i][l][res] = max(mx[i][l][res], mx[i+k][l-k][right]);\n            } else if (left == LEXPR) {\n              mn[i][l][res] = min(mn[i][l][res], mn[i][k][left]);\n              mx[i][l][res] = max(mx[i][l][res], mx[i][k][left]);\n            }\n          }\n        }\n      }\n      while (true) {\n      bool update = false;\n        for (auto p : m) {\n          int src, res;\n          tie(src, res) = p;\n          if (cyk[i][l][src]) {\n            if (!cyk[i][l][res]) update = true;\n            cyk[i][l][res] = true;\n            mn[i][l][res] = min(mn[i][l][res], mn[i][l][src]);\n            mx[i][l][res] = max(mx[i][l][res], mx[i][l][src]);\n          }\n        }\n        if (!update) break;\n      }\n    }\n  }\n  cout << mx[0][n][EXPR] << endl;\n  return 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include <string>\n#include <iostream>\n#include <algorithm>\nusing namespace std;\nconst int inf = 1012345678;\nconst pair<int, int> arienai = make_pair(inf, -inf);\nbool vis[209][209]; pair<int, int> dp[209][209];\npair<int, int> solve(int l, int r, string& s) {\n\tif (r - l == 0) return arienai;\n\tif (r - l == 1) return('0' <= s[l] && s[l] <= '9' ? make_pair(int(s[l] - '0'), int(s[l] - '0')) : arienai);\n\tif (vis[l][r]) return dp[l][r];\n\tpair<int, int> ans = arienai;\n\tfor (int i = l + 1; i < r - 1; ++i) {\n\t\tif (s[i] == '+') {\n\t\t\tpair<int, int> lc = solve(l, i, s);\n\t\t\tpair<int, int> rc = solve(i + 1, r, s);\n\t\t\tif (lc != arienai && rc != arienai) {\n\t\t\t\tans.first = min(ans.first, lc.first + rc.first);\n\t\t\t\tans.second = max(ans.second, lc.second + rc.second);\n\t\t\t}\n\t\t}\n\t\tif (s[i] == '-') {\n\t\t\tpair<int, int> lc = solve(l, i, s);\n\t\t\tpair<int, int> rc = solve(i + 1, r, s);\n\t\t\tif (lc != arienai && rc != arienai) {\n\t\t\t\tans.first = min(ans.first, lc.first - rc.second);\n\t\t\t\tans.second = max(ans.second, lc.second - rc.first);\n\t\t\t}\n\t\t}\n\t}\n\tfor (int i = 1; i < 4; ++i) {\n\t\tif ((i & 1) && s[l] != '(') continue;\n\t\tif ((i & 2) && s[r - 1] != ')') continue;\n\t\tpair<int, int> res = solve(l + (i & 1 ? 1 : 0), r - (i & 2 ? 1 : 0), s);\n\t\tif (res != arienai && (r - (i & 2 ? 1 : 0)) - (l + (i & 1 ? 1 : 0)) >= 2) {\n\t\t\tans.first = min(ans.first, res.first);\n\t\t\tans.second = max(ans.second, res.second);\n\t\t}\n\t}\n\tvis[l][r] = true;\n\tdp[l][r] = ans;\n\treturn ans;\n}\nint main() {\n\tstring s;\n\tcin >> s;\n\tpair<int, int> ans = solve(0, s.size(), s);\n\tcout << ans.second << endl;\n\treturn 0;\n}\n"
  },
  {
    "language": "C++",
    "code": "#include <iostream>\n#include <cmath>\n#define REP(i, a, n) for(int i = ((int) a); i < ((int) n); i++)\n#define INF 100000000\nusing namespace std;\ntypedef long long ll;\n\nstring S;\nll dp[300][300][2];\n\nll number(int l, int r) {\n  ll ret = 0;\n  REP(i, l, r) {\n    if('0' <= S[i] && S[i] <= '9') ret = ret * 10 + (S[i] - '0');\n    else return -1;\n  }\n  return ret;\n}\n\nll dfs(int l, int r, int mode, int depth) {\n\n  if(dp[l][r][mode] > -INF * 2) return dp[l][r][mode];\n\n  ll n = number(l, r);\n  if(n >= 0) return n;\n\n  ll ret = mode == 0 ? -INF : INF;\n  REP(i, l, r) if(S[i] == '+' || S[i] == '-') {\n    int nl = l, nr = r;\n    while(1) {\n      ll n1 = dfs(nl, i, mode, depth + 1);\n      ll n2 = dfs(i + 1, nr, S[i] == '-' ? 1 - mode : mode, depth + 1);\n      if(abs(n1) != INF && abs(n2) != INF) {\n        if(mode == 0) {\n          if(S[i] == '+') ret = max(ret, n1 + n2);\n          if(S[i] == '-') ret = max(ret, n1 - n2);\n        } else {\n          if(S[i] == '+') ret = min(ret, n1 + n2);\n          if(S[i] == '-') ret = min(ret, n1 - n2);\n        }\n      }\n      if(S[nl] != '(' && S[nr - 1] != ')') break;\n      if(S[nl] == '(') nl++;\n      if(S[nr - 1] == ')') nr--;\n    }\n  }\n  return dp[l][r][mode] = ret;\n}\n\nint main(void) {\n  cin >> S;\n\n  REP(i, 0, 201) REP(j, 0, 201) REP(k, 0, 2) dp[i][j][k] = -INF * 2;\n  cout << dfs(0, S.size(), 0, 0) << endl;\n\n  return 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\n#define N 201\nusing namespace std;\n\n/*\nint p;\nint bnf(){\n  int res=0;\n  while(p<S.size()){\n    if(S[p]=='(')p++,res=bnf();\n    else if(isdigit(S[p]))res=S[p++]-'0';\n    else if(S[p]=='+')p++,res+=bnf();\n    else if(S[p]=='-')p++,res-=bnf();\n    else break;\n    }\n  p++;\n  return res;\n  }\n*/\n\n\nint skip(string &str,int i){\n  if(str[i]!='(')return i;\n  string res;\n  int cnt=1;i++;\n  while(1) {\n    if(str[i]=='(')cnt++;\n    if(str[i]==')')cnt--;\n    if(!cnt)break;\n    res+=str[i++];\n  }\n  return i;\n}\n \n\nmap<string,int>mem[2];\nint dfs(string str,int flg){\n  if(str.size()==1) return str[0]-'0';\n  if(mem[flg].count(str)) return mem[flg][str];\n  if(skip(str,0)==(int)str.size()-1)return dfs(str.substr(1,str.size()-2),flg);\n\n  int res=flg? 1e9:-1e9;\n  for(int i=0;(i=skip(str,i))<str.size()-1;i+=2){\n    string L=str.substr(0,i+1),R=str.substr(i+2,str.size()-i-2);\n    int Lmx=dfs(L,0),Lmn=dfs(L,1);\n    int Rmx=dfs(R,0),Rmn=dfs(R,1);\n    if(str[i+1]=='-') res=flg? min(res,Lmn-Rmx):max(res,Lmx-Rmn);\n    if(str[i+1]=='+') res=flg? min(res,Lmn+Rmn):max(res,Lmx+Rmx);\n  }\n  return mem[flg][str]=res;\n}\n\n\nint main(){\n  string S,tmp;\n  cin>>S;\n  int cnt=0;\n  for(int i=0;i<S.size();i++) {\n    if(S[i]!=')')tmp+=S[i];\n    if(i&&(S[i-1]=='+'||S[i-1]=='-')&&cnt)tmp+=')',cnt--;\n    if(S[i]=='(')cnt++;\n  }\n  cout<<dfs(tmp,0)<<endl;  \n  return 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include <stdio.h>\n#include <cmath>\n#include <algorithm>\n#include <cfloat>\n#include <stack>\n#include <queue>\n#include <vector>\n#include <string>\n#include <iostream>\n#include <set>\n#include <map>\n#include <time.h>\ntypedef long long int ll;\ntypedef unsigned long long int ull;\n#define BIG_NUM 2000000000\n#define MOD 1000000007\n#define EPS 0.000000001\nusing namespace std;\n\n#define NUM 200\n\nenum Type{\n\tMAX,\n\tMIN,\n};\n\nchar buf[NUM+5];\nint dp[NUM][NUM][2];\nint num_count,op_count;\nint num_loc[NUM],op_loc[NUM];\n\nbool is_digit(char ch){\n\treturn ch >= '0' && ch <= '9';\n}\n\nbool is_op(char ch){\n\treturn ch == '+' || ch == '-';\n}\n\n\nint main(){\n\n\tscanf(\"%s\",buf);\n\n\tnum_count = 0,op_count = 0;\n\tfor(int i = 0; buf[i] != '\\0'; i++){\n\t\tif(is_digit(buf[i])){\n\t\t\tnum_loc[num_count++] = i;\n\t\t}else if(is_op(buf[i])){\n\t\t\top_loc[op_count++] = i;\n\t\t}\n\t}\n\n\tfor(int left = 0; left < num_count; left++){\n\t\tdp[left][left][MAX] = buf[num_loc[left]]-'0';\n\t\tdp[left][left][MIN] = buf[num_loc[left]]-'0';\n\t\tfor(int right = left+1; right < num_count; right++){\n\t\t\tdp[left][right][MAX] = -BIG_NUM;\n\t\t\tdp[left][right][MIN] = BIG_NUM;\n\t\t}\n\t}\n\n\tint right,left_left,left_right,right_left,right_right;\n\n\tfor(int length = 2; length <= num_count; length++){\n\t\tfor(int left = 0; left+length-1 < num_count; left++){\n\t\t\tright = left+length-1;\n\n\t\t\tfor(int op = left; op < right; op++){\n\t\t\t\tleft_left = left;\n\t\t\t\tleft_right = op;\n\n\t\t\t\tright_left = op+1;\n\t\t\t\tright_right = right;\n\n\t\t\t\tif(left_left != left_right && (buf[num_loc[left_left]+1] == ')' || buf[num_loc[left_right]-1] == '('))continue;\n\t\t\t\tif(right_left != right_right && (buf[num_loc[right_left]+1] == ')' || buf[num_loc[right_right]-1] == '('))continue;\n\n\t\t\t\tif(buf[op_loc[op]] == '+'){\n\t\t\t\t\tdp[left][right][MAX] = max(dp[left][right][MAX],dp[left_left][left_right][MAX]+dp[right_left][right_right][MAX]);\n\t\t\t\t\tdp[left][right][MIN] = min(dp[left][right][MIN],dp[left_left][left_right][MIN]+dp[right_left][right_right][MIN]);\n\t\t\t\t}else{\n\t\t\t\t\tdp[left][right][MAX] = max(dp[left][right][MAX],dp[left_left][left_right][MAX]-dp[right_left][right_right][MIN]);\n\t\t\t\t\tdp[left][right][MIN] = min(dp[left][right][MIN],dp[left_left][left_right][MIN]-dp[right_left][right_right][MAX]);\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t}\n\n\tprintf(\"%d\\n\",dp[0][num_count-1][MAX]);\n\n\treturn 0;\n}\n\n"
  },
  {
    "language": "C++",
    "code": "#include<bits/stdc++.h>\nusing namespace std;\n#define INF (1e8)\n#define MAX 205\nint n;\nchar s[MAX];\n \nint dpA[MAX][MAX];\nint dpB[MAX][MAX];\nbool flgA[MAX][MAX];\nbool flgB[MAX][MAX];\n \nint solveA(int,int);\nint solveB(int,int);\n \nint main(){\n  scanf(\"%s\",s);\n  n=strlen(s);\n  int ans=solveA(0,n);\n  assert( abs(ans) < 1e6 );\n  printf(\"%d\\n\",ans);\n  return 0;\n}\n \nint solveA(int l,int r){\n  if(flgA[l][r])return dpA[l][r];\n  flgA[l][r]=true;\n  int res=-INF,cnt=0,num=0;\n  int L=INF,R=-INF;\n  for(int i=l;i<r;i++){\n    if(s[i]<'0'||'9'<s[i])continue;\n    L=min(L,i);\n    R=max(R,i);\n  }\n  for(int i=l;i<r;i++){\n    if(s[i]=='+'){\n      if(L<=i-3&&'0'<=s[i-1]&&s[i-1]<='9'&&s[i-2]=='(')continue;\n      if(i+3< R&&'0'<=s[i+1]&&s[i+1]<='9'&&s[i+2]==')')continue;\n      res=max(res, solveA(l,i)+solveA(i+1,r));\n    }else if(s[i]=='-'){\n      if(L<=i-3&&'0'<=s[i-1]&&s[i-1]<='9'&&s[i-2]=='(')continue;\n      if(i+3< R&&'0'<=s[i+1]&&s[i+1]<='9'&&s[i+2]==')')continue;\n      res=max(res, solveA(l,i)-solveB(i+1,r));\n    }else if('0'<=s[i]&&s[i]<='9'){\n      cnt++;\n      num=s[i]-'0';\n    }\n  }\n  if(cnt==1)res=num;\n \n     \n  return dpA[l][r]=res;\n}\n \nint solveB(int l,int r){\n  if(flgB[l][r])return dpB[l][r];\n  flgB[l][r]=true;\n  int res=INF,cnt=0,num=0;\n  int L=INF,R=-INF;\n  for(int i=l;i<r;i++){\n    if(s[i]<'0'||'9'<s[i])continue;\n    L=min(L,i);\n    R=max(R,i);\n  }\n   \n  for(int i=l;i<r;i++){\n    if(s[i]=='+'){\n      if(L<=i-3&&'0'<=s[i-1]&&s[i-1]<='9'&&s[i-2]=='(')continue;\n      if(i+3<R &&'0'<=s[i+1]&&s[i+1]<='9'&&s[i+2]==')')continue;\n      res=min(res, solveB(l,i)+solveB(i+1,r));\n    }else if(s[i]=='-'){\n      if(L<=i-3&&'0'<=s[i-1]&&s[i-1]<='9'&&s[i-2]=='(')continue;\n      if(i+3< R&&'0'<=s[i+1]&&s[i+1]<='9'&&s[i+2]==')')continue;\n      res=min(res, solveB(l,i)-solveA(i+1,r));\n    }else if('0'<=s[i]&&s[i]<='9'){\n      cnt++;\n      num=s[i]-'0';\n    }\n  }\n  if(cnt==1)res=num;\n  return dpB[l][r]=res;\n}"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\n#define INF (1e9)\nusing namespace std;\n\n\nint calc(string s){\n  vector<int> v;\n  for(int i=0;i<s.size();i++){\n    int n = (int)v.size()-1;\n    if(s[i]=='+')v.push_back(0);\n    if(s[i]=='-')v.push_back(1);\n    if(s[i]=='(')v.push_back(0),v.push_back(0);\n    if(s[i]==')'){\n      if(v.size()<3)continue;\n      v[n-2]+=v[n-1]? -v[n]:v[n];\n      v.pop_back(),v.pop_back();\n    }\n\n    if(isdigit(s[i])){\n      int num=s[i]-'0';\n      if(v.size()>=2){\n\tv[n-1]+=v[n]? -num:num;\n\tv.pop_back();\n      }\n      else v.push_back(num);\n    }\n  }\n  return v[0];\n}\n\nmap<string,int> mem[2];\nint dfs(string s,int f){\n  if(s.size()==1) return s[0]-'0';\n  if(mem[f].count(s))return mem[f][s];\n  int n=s.size(),res=calc(s);\n  for(int i=0,c=0;i<n;i++){\n    while(i<n){\n      while(s[i]=='('||s[i]==')')c+=(s[i]=='(')-(s[i]==')'),i++;\n      if(s[i]=='+'||s[i]=='-') break;\n      i++;\n    }\n    if(i>=n)break;\n    if((i-2>=0&&s[i-2]=='(')&&s[i+2]!=')')continue;\n    string a=s.substr(0,i),b=s.substr(i+1,n-i-1);\n    int t=c,ch=s[i];\n    while(t--)a+=')',b='('+b;\n    int mxa=dfs(a,0),mna=dfs(a,1);\n    int mxb=dfs(b,0),mnb=dfs(b,1);\n    if(f==0&&ch=='+') res=max(res, mxa+mxb);\n    if(f==0&&ch=='-') res=max(res, mxa-mnb);\n    if(f==1&&ch=='+') res=min(res, mna+mnb);\n    if(f==1&&ch=='-') res=min(res, mna-mxb);\n  }\n  return mem[f][s]=res;\n}\n\n\n\nint main(){\n  string S;\n  cin>>S;\n  cout <<dfs(S,0)<<endl;\n  return 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include <iostream>\n#include <string>\n#include <vector>\n#include <algorithm>\n#include <cmath>\n#include <cstdio>\n#include <functional>\n#include <numeric>\n#include <stack>\n#include <queue>\n#include <map>\n#include <set>\n#include <utility>\n#include <sstream>\n#include <complex>\n#include <fstream>\n#include <bitset>\n#include <time.h>\n\nusing namespace std;\n\ntypedef long long ll;\ntypedef pair<ll, ll> P;\ntypedef vector<ll> V;\ntypedef complex<double> Point;\n\n#define PI acos(-1.0)\n#define EPS 1e-10\nconst ll INF = (1LL << 31) - 1;\nconst ll MOD = 1e9 + 7;\n\n#define FOR(i,a,b) for(int i=(a);i<(b);i++)\n#define rep(i,N) for(int i=0;i<(N);i++)\n#define ALL(s) (s).begin(),(s).end()\n#define EQ(a,b) (abs((a)-(b))<EPS)\n#define EQV(a,b) ( EQ((a).real(), (b).real()) && EQ((a).imag(), (b).imag()) )\n#define fi first\n#define se second\n#define N_SIZE (1LL << 20)\n#define NIL -1\n#define MAX_N 100100 * 3\n\nstring s;\nvector<int> pos;\n\nll digit(string& s, int& pos);\n//ll term(& s, int& pos);\nll expr(string& s, int& pos);\nll factor(string& s, int& pos);\n\nbool is_digit(char c) {\n\treturn c >= '0'&&c <= '9';\n}\n\nll digit(string& s, int& pos) {\n\treturn s[pos++] - '0';\n}\n\nll factor(string& s, int& pos) {\n\tif (isdigit(s[pos]))return digit(s, pos);\n\n\tpos++; \n\tll ret = expr(s, pos);\n\tpos++; \n\treturn ret;\n}\n\nll expr(string& s, int& pos) {\n\tll res = factor(s, pos);\n\twhile (s[pos] == '+' || s[pos] == '-') {\n\t\tif (s[pos] == '+') {\n\t\t\tpos++;\n\t\t\tres += factor(s, pos);\n\t\t}\n\t\telse if (s[pos] == '-') {\n\t\t\tpos++;\n\t\t\tres -= factor(s, pos);\n\t\t}\n\t}\n\treturn res;\n}\n\nint main() {\n\tcin >> s;\n\trep(i, s.size()) {\n\t\tif (is_digit(s[i]))pos.push_back(i);\n\t}\n\tint p = 0;\n\tll ans = expr(s, p);\n\tll pans = -INF;\n\t//cout << ans << endl;\n\twhile (1) {\n\t\tstring buf = \"\";\n\t\trep(i, s.size()) {\n\t\t\tFOR(j, i + 1, s.size()) {\n\t\t\t\tif (is_digit(s[i]) && is_digit(s[j])) {\n\t\t\t\t\tp = 0;\n\t\t\t\t\tstring t = s.substr(0, i) + \"(\" + s.substr(i, j - i + 1) + \")\" + s.substr(j + 1);\n\t\t\t\t\tbool f = 0;\n\t\t\t\t\trep(k, t.size() - 2) {\n\t\t\t\t\t\tif (t[k] == '('&&t[k + 2] == ')')f = 1;\n\t\t\t\t\t}\n\t\t\t\t\tif (f)continue;\n\t\t\t\t\t//cout << t << endl;\n\t\t\t\t\tll num = expr(t, p);\n\t\t\t\t\t//cout << num << endl;\n\t\t\t\t\tif (pans < num) {\n\t\t\t\t\t\tpans = num;\n\t\t\t\t\t\tbuf = t;\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t\t//cout << \"!!\" << ans << endl;\n\t\t\t}\n\t\t}\n\t\t//cout << pans << \" \" << ans << endl;\n\t\tif (pans == ans) {\n\t\t\tbreak;\n\t\t}\n\t\telse {\n\t\t\tans = max(ans, pans);\n\t\t\ts = buf;\n\t\t}\n\t}\n\tcout << ans << endl;\n}"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\nusing namespace std;\n#define INF 1000000\ntypedef string::const_iterator State;\nint expression(State &begin);\n\nint data[201];\nint kakko[201];\nint size;\n\nint number(State &begin){\n\tint ret=0;\n\twhile(isdigit(*begin)){\n\t\tret*=10;\n\t\tret+=*begin-'0';\n\t\tbegin++;\n\t}\n\tdata[size++]=ret;\n\treturn ret;\n}\n\nint factor(State &begin){\n\tif(*begin=='('){\n\t\tbegin++;\n\t\tkakko[size]++;\n\t\tint ret=expression(begin);\n\t\tkakko[size-1]--;\n\t\tbegin++;\n\t}else{\n\t\treturn number(begin);\n\t}\n}\n\nint expression(State &begin){\n\tint ret=factor(begin);\n\twhile(1){\n\t\tif(*begin=='+'){\n\t\t\tbegin++;\n\t\t\tdata[size++]=-1;\n\t\t\tret+=expression(begin);\n\t\t}else if(*begin=='-'){\n\t\t\tbegin++;\n\t\t\tdata[size++]=-2;\n\t\t\tret-=expression(begin);\n\t\t}else{\n\t\t\tbreak;\n\t\t}\n\t}\n\treturn ret;\n}\n\nint dp[201][201][2];\n\nint solve(int f,int t,int type){\n\tif(type==0 && dp[f][t][type]!=-INF)return dp[f][t][type];\n\tif(type==1 && dp[f][t][type]!=INF)return dp[f][t][type];\n\tif(t-f==1){\n\t\treturn data[f];\n\t}\n\tif(t-f==3){\n\t\tif(data[f+1]==-1){\n\t\t\treturn data[f]+data[f+2];\n\t\t}\n\t\tif(data[f+1]==-2){\n\t\t\treturn data[f]-data[f+2];\n\t\t}\n\t}\n\tint res=-INF;\n\tif(type==1)res=INF;\n\tfor(int i=f+1;i<t;i+=2){\n\t\tif(data[i]==-2 && (i-1==f || kakko[i-1]<=0) && kakko[f]>=0 && kakko[t-1]<=0 && (kakko[i+1]>=0 || i+1==t-1)){\n\t\t\tif(type==0)res=max(solve(f,i,0)-solve(i+1,t,1),res);\n\t\t\tif(type==1)res=min(solve(f,i,1)-solve(i+1,t,0),res);\n\t\t}\n\t\tif(data[i]==-1 && (i-1==f || kakko[i-1]<=0) && kakko[f]>=0 && kakko[t-1]<=0 && (kakko[i+1]>=0 || i+1==t-1)){\n\t\t\tif(type==0)res=max(solve(f,i,0)+solve(i+1,t,0),res);\n\t\t\tif(type==1)res=min(solve(f,i,1)+solve(i+1,t,1),res);\n\t\t}\n\t}\n\treturn dp[f][t][type]=res;\n}\n\nint main(void){\n\tstring str;\n\tcin >> str;\n\tState begin=str.begin();\n\texpression(begin);\n\tfor(int i=0;i<=200;i++){\n\t\tfor(int j=0;j<=200;j++){\n\t\t\tdp[i][j][0]=-INF;\n\t\t\tdp[i][j][1]=INF;\n\t\t}\n\t}\n\tprintf(\"%d\\n\",solve(0,size,0));\n\treturn 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\nusing namespace std;\n\nint calc(string &s,int &i){\n  int res=0;\n  while(1){\n    if(isdigit(s[i]))res=s[i++]-'0';\n    else if(s[i]=='('){res=calc(s,++i),i++;}\n    else if(s[i]=='+')res+=calc(s,++i);\n    else if(s[i]=='-')res-=calc(s,++i);\n    else break;\n  }\n  return res;\n}\n\nunordered_map<string,int> mem[2];\nint dfs(string s,int f){\n  if(mem[f].count(s))return mem[f][s];\n\n  int j=0,res=calc(s,j),n=s.size(),d=-1;\n  for(int i=0;i<n;i++) d+=(s[i]=='+'||s[i]=='-');\n  \n  for(int i=0,c=0,cnt=0;i<n;i++,cnt++,d--){\n    while(1){\n      while(s[i]=='('||s[i]==')')c+=(s[i]=='(')-(s[i]==')'),i++;\n      if(i>=n||s[i]=='+'||s[i]=='-') break;\n      i++;\n    }\n    if(i>=n||(cnt&&s[i-2]=='(')||(d&&s[i+2]==')'))continue;\n    string a=s.substr(0,i),b=s.substr(i+1,n-i-1);\n    int t=c,ch=s[i];\n    while(t--)a+=')',b='('+b;\n    int mxa=dfs(a,0),mna=dfs(a,1);\n    int mxb=dfs(b,0),mnb=dfs(b,1);\n    if(f==0&&ch=='+') res=max(res, mxa+mxb);\n    if(f==0&&ch=='-') res=max(res, mxa-mnb);\n    if(f==1&&ch=='+') res=min(res, mna+mnb);\n    if(f==1&&ch=='-') res=min(res, mna-mxb);\n  }\n  return mem[f][s]=res;\n}\n\nint main(){\n  string S;\n  cin>>S;\n  cout <<dfs(S,0)<<endl;\n  return 0;\n}"
  },
  {
    "language": "C++",
    "code": "//#define __USE_MINGW_ANSI_STDIO 0\n#include <bits/stdc++.h>\n\nusing namespace std;\ntypedef long long ll;\ntypedef vector<int> VI;\ntypedef vector<VI> VVI;\ntypedef vector<ll> VL;\ntypedef vector<VL> VVL;\ntypedef pair<int, int> PII;\n\n#define FOR(i, a, n) for (ll i = (ll)a; i < (ll)n; ++i)\n#define REP(i, n) FOR(i, 0, n)\n#define ALL(x) x.begin(), x.end()\n#define IN(a, b, x) (a<=x&&x<b)\n#define MP make_pair\n#define PB push_back\n#define MOD 1000000007\n#define INF (1LL<<30)\n#define LLINF (1LL<<60)\n#define PI 3.14159265359\n#define EPS 1e-12\n//#define int ll\n\nint dx[] = {0, 1, 0, -1}, dy[] = {1, 0, -1, 0};\n\nPII dp[210][210];\nstring s;\n\nPII dfs(int l, int r) {\n\t//cout << \"l:\" << l << \" r:\" << r << endl;\n\tif(dp[l][r] != PII{-INF, INF}) return dp[l][r];\n\tif(l == r) return dp[l][r] = MP(s[l]-'0', s[l]-'0');\n\tif(s[l] == '(' && r-l>=3) {\n\t\tPII p = dfs(l+1, r);\n\t\tdp[l][r].first = max(dp[l][r].first, p.first);\n\t\tdp[l][r].second = min(dp[l][r].second, p.second);\n\t\treturn dp[l][r];\n\t}\n\tif(s[r] == ')' && r-l>=3) {\n\t\tPII p = dfs(l, r-1);\n\t\tdp[l][r].first = max(dp[l][r].first, p.first);\n\t\tdp[l][r].second = min(dp[l][r].second, p.second);\n\t\treturn dp[l][r];\n\t}\n\tFOR(i, l+1, r) {\n\t\tif(s[i] == '+') {\n\t\t\tPII a = dfs(l, i-1);\n\t\t\tPII b = dfs(i+1, r);\n\t\t\tdp[l][r].first = max(dp[l][r].first, a.first + b.first);\n\t\t\tdp[l][r].second = min(dp[l][r].second, a.second + b.second);\n\t\t} else if(s[i] == '-') {\n\t\t\tPII a = dfs(l, i-1);\n\t\t\tPII b = dfs(i+1, r);\n\t\t\tdp[l][r].first = max(dp[l][r].first, a.first - b.second);\n\t\t\tdp[l][r].second = min(dp[l][r].second, a.second - b.first);\n\t\t}\n\t}\n\t//cout << l << \" \" << r << \" \" << dp[l][r].first << \" \" << dp[l][r].second << endl;\n\treturn dp[l][r];\n}\n\nsigned main(void)\n{\n\tcin >> s;\n\tREP(i, s.size()) REP(j, s.size()) dp[i][j] = MP(-INF, INF);\n\tcout << dfs(0, s.size()-1).first << endl;\n\t/*REP(i, s.size()) {\n\t\tREP(j, s.size()) {\n\t\t\tcout << \"(\" << max(0, dp[i][j].first) << \", \" << min(0, dp[i][j].second) << \" )\";\n\t\t}\n\t\tcout << endl;\n\t}*/\n\n\treturn 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\n#define INF (1e9)\nusing namespace std;\n\n\nint calc(string s){\n  vector<int> v;\n  for(int i=0;i<s.size();i++){\n    int n = (int)v.size()-1;\n    if(s[i]=='+')v.push_back(0);\n    if(s[i]=='-')v.push_back(1);\n    if(s[i]=='(')v.push_back(0),v.push_back(0);\n    if(s[i]==')'){\n      if(v.size()<3)continue;\n      v[n-2]+=v[n-1]? -v[n]:v[n];\n      v.pop_back(),v.pop_back();\n    }\n\n    if(isdigit(s[i])){\n      int num=s[i]-'0';\n      if(v.size()>=2){\n\tv[n-1]+=v[n]? -num:num;\n\tv.pop_back();\n      }\n      else v.push_back(num);\n    }\n  }\n  return v[0];\n}\n\nmap<string,int> mem[2];\nint dfs(string s,int f){\n  if(s.size()==1) return s[0]-'0';\n  if(mem[f].count(s))return mem[f][s];\n  int n=s.size(),res=calc(s);\n  for(int i=0,c=0;i<n;i++){\n    while(i<n){\n      while(s[i]=='('||s[i]==')')c+=(s[i]=='(')-(s[i]==')'),i++;\n      if(s[i]=='+'||s[i]=='-') break;\n      i++;\n    }\n    if(i>=n)break;\n    if((i-2>=0&&s[i-2]=='(')||(i+2<n-1&&s[i+2]==')'))continue;\n    string a=s.substr(0,i),b=s.substr(i+1,n-i-1);\n    int t=c,ch=s[i];\n    while(t--)a+=')',b='('+b;\n    int mxa=dfs(a,0),mna=dfs(a,1);\n    int mxb=dfs(b,0),mnb=dfs(b,1);\n    if(f==0&&ch=='+') res=max(res, mxa+mxb);\n    if(f==0&&ch=='-') res=max(res, mxa-mnb);\n    if(f==1&&ch=='+') res=min(res, mna+mnb);\n    if(f==1&&ch=='-') res=min(res, mna-mxb);\n  }\n  return mem[f][s]=res;\n}\n\n\n\nbool check(string s){\n  if(s[0]!='(')return 0;\n  int i=0;\n  while(s[i]!=')')i++;\n  return i==(int)s.size()-1;\n}\n\nint main(){\n  string S;\n  cin>>S;\n  while(check(S))S=S.substr(1,S.size()-2);\n  cout <<dfs(S,0)<<endl;\n  return 0;\n}"
  },
  {
    "language": "C++",
    "code": "//#define __USE_MINGW_ANSI_STDIO 0\n#include <bits/stdc++.h>\n\nusing namespace std;\ntypedef long long ll;\ntypedef vector<int> VI;\ntypedef vector<VI> VVI;\ntypedef vector<ll> VL;\ntypedef vector<VL> VVL;\ntypedef pair<int, int> PII;\n\n#define FOR(i, a, n) for (ll i = (ll)a; i < (ll)n; ++i)\n#define REP(i, n) FOR(i, 0, n)\n#define ALL(x) x.begin(), x.end()\n#define IN(a, b, x) (a<=x&&x<b)\n#define MP make_pair\n#define PB push_back\n#define MOD 1000000007\n#define INF (1LL<<30)\n#define LLINF (1LL<<60)\n#define PI 3.14159265359\n#define EPS 1e-12\n//#define int ll\n\nint dx[] = {0, 1, 0, -1}, dy[] = {1, 0, -1, 0};\n\nPII dp[210][210];\nstring s;\n\nPII dfs(int l, int r) {\n\tif(dp[l][r] != PII{-INF, INF}) return dp[l][r];\n\tif(l == r) return dp[l][r] = MP(s[l]-'0', s[l]-'0');\n\tif(s[l] == '(' && r-l>=3) {\n\t\tPII p = dfs(l+1, r);\n\t\tdp[l][r].first = max(dp[l][r].first, p.first);\n\t\tdp[l][r].second = min(dp[l][r].second, p.second);\n\t}\n\tif(s[r] == ')' && r-l>=3) {\n\t\tPII p = dfs(l, r-1);\n\t\tdp[l][r].first = max(dp[l][r].first, p.first);\n\t\tdp[l][r].second = min(dp[l][r].second, p.second);\n\t}\n\tFOR(i, l, r) {\n\t\tif(s[i] == '+') {\n\t\t\tPII a = dfs(l, i-1);\n\t\t\tPII b = dfs(i+1, r);\n\t\t\tdp[l][r].first = max(dp[l][r].first, a.first + b.first);\n\t\t\tdp[l][r].second = min(dp[l][r].second, a.second + b.second);\n\t\t} else if(s[i] == '-') {\n\t\t\tPII a = dfs(l, i-1);\n\t\t\tPII b = dfs(i+1, r);\n\t\t\tdp[l][r].first = max(dp[l][r].first, a.first - b.second);\n\t\t\tdp[l][r].second = min(dp[l][r].second, a.second - b.first);\n\t\t}\n\t}\n\n\treturn dp[l][r];\n}\n\nsigned main(void)\n{\n\tcin >> s;\n\tREP(i, s.size()) REP(j, s.size()) dp[i][j] = MP(-INF, INF);\n\tcout << dfs(0, s.size()-1).first << endl;\n\n\treturn 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include \"bits/stdc++.h\"\n#include<unordered_map>\n#include<unordered_set>\n#pragma warning(disable:4996)\nusing namespace std;\nusing ld = long double;\nconst ld eps = 1e-9;\n\nstruct Edge {\n\tint src;\n\tint dst;\n\tlong long int cost;\n};\nusing Graph=vector<vector<Edge>>;\n\nclass Centroid {\npublic:\n\tint dfs(const Graph&g, const int now, const int from, vector<int>&ch_nums, const vector<int>&oks) {\n\t\tint sum = 1;\n\t\tfor (auto &&e : g[now]) {\n\t\t\tif (e.dst == from || oks[e.dst]!=-1)continue;\n\t\t\telse {\n\t\t\t\tsum += dfs(g, e.dst, e.src, ch_nums,oks);\n\t\t\t}\n\t\t}\n\t\treturn ch_nums[now] = sum;\n\t};\n\n\n\tint find_centroid(const int asize, const vector<vector<Edge>>&graph, const int pre_root, const int pre_from, const vector<int>&ch_nums, const vector<int>&oks) {\n\t\tfor (auto&& e : graph[pre_root]) {\n\t\t\tif (e.dst == pre_from)continue;\n\t\t\tif (oks[e.dst]!=-1)continue;\n\t\t\tif (ch_nums[e.dst]>asize / 2)return find_centroid(asize, graph, e.dst, e.src, ch_nums, oks);\n\t\t}\n\t\treturn pre_root;\n\t}\n\n\t//void dfs2(const Graph&g, const int now, const int from,vector<long long int>&lens,const int root_id, long long int nlen) {\n\t//\tlens.push_back(nlen);\n\t//\tmp[make_pair(root_id,now)]=nlen;\n\t//\tfor (auto &&e : g[now]) {\n\t//\t\tif (e.dst == from || oks[e.dst] != -1)continue;\n\t//\t\telse {\n\t//\t\t\tdfs2(g,e.dst,e.src,lens,root_id,nlen+e.cost);\n\t//\t\t}\n\t//\t}\n\t//}\n\n\tvoid cent(const vector<vector<Edge>>&graph, vector<int>&oks, const int root, const int from, vector<vector<int>>&centroid_edges, int& fst_centroid,int depth,vector<int>&ch_nums) {\ndfs(graph, root, from, ch_nums, oks);\n\n\t\tint cent_id = find_centroid(ch_nums[root], graph, root, from, ch_nums, oks);\n\n\t\t\n\t\t//dfs2(graph,cent_id,from,lens[cent_id],0);\n\t\tsort(lens[cent_id].begin(),lens[cent_id].end());\n\n\t\toks[cent_id] = depth;\n\t\tif (from != -1) {\n\t\t\tcentroid_edges[from].push_back(cent_id);\n\t\t}\n\t\telse {\n\t\t\tfst_centroid = cent_id;\n\t\t}\n\t\tfor (auto e : graph[cent_id]) {\n\t\t\tif (e.dst == from)continue;\n\t\t\tif (oks[e.dst]!=-1)continue;\n\t\t\tcent(graph, oks, e.dst, e.src, centroid_edges, fst_centroid,depth+1,ch_nums);\n\t\t}\n\t}\n\npublic:\n\n\n\tvector<vector<long long int>>lens;\n\tvector<vector<int>> centroid_graph;\n\tvector<int>parents;\n\tvector<int>oks;\n\tmap<pair<int,int>,long long int>mp;\n\n\t//fst:root  snd:centroid_graph\n\tvector<vector<int>> get_cent_parent(const Graph&g) {\n\t\tlens.resize(g.size());\n\t\toks=vector<int>(g.size(),-1);\n\t\tint root = -1;\n\t\tcentroid_graph.resize(g.size());\n\t\tparents=vector<int>(g.size(),-1);\n\t\tvector<int>ch_nums(g.size());\n\t\tcent(g, oks, 0, -1, centroid_graph, root,0,ch_nums);\n\n\t\tfor (int i = 0; i < centroid_graph.size(); ++i) {\n\t\t\tfor (auto&& e : centroid_graph[i]) {\n\t\t\t\tparents[e] = i;\n\t\t\t}\n\t\t}\n\t\treturn centroid_graph;\n\t}\n}centroid;\n\n\nvoid addEdge(Graph& g ,int a, int b,long long int c) {\n\tg[a - 1].push_back(Edge{ a - 1,b - 1,c });\n\tg[b - 1].push_back(Edge{ b - 1,a - 1,c });\n}\n\nvector<int>nums;\nvector<int>ls;\nvector<int>rs;\nvector<int>pluss;\nvector<vector<pair<int,int>>>memo;\n\nstring st;\nvoid term(int&a,int&k) {\n\tnums.push_back(0);\n\tls.push_back(0);\n\trs.push_back(0);\n\twhile (a != st.size() && st[a] == '(') {\n\t\tls[k]=true;\n\t\ta++;\n\t}\n\tnums[k]=st[a]-'0';\n\ta++;\n\twhile (a != st.size() && st[a] == ')') {\n\t\trs[k]=true;\n\t\ta++;\n\t}\n\tk++;\n\treturn ;\n}\nvoid expr(int &a) {\n\tint k=0;\n\tterm(a,k);\n\n\twhile (a != st.size()) {\n\t\tpluss.push_back(st[a]=='+');\n\t\ta++;\n\t\tterm(a,k);\n\t}\n}\nvoid init() {\n\tint a=0;\n\texpr(a);\n\tmemo=vector<vector<pair<int,int>>>(nums.size()+1,vector<pair<int,int>>(nums.size()+1,make_pair(1e9,-1e9)));\n}\n\npair<int,int> solve(int l, int r) {\n\tif(memo[l][r].first!=1e9)return memo[l][r];\n\t if(l+1==r)return memo[l][r]=make_pair(nums[l],nums[l]);\n\t if (l + 2 == r) {\n\t\t if(rs[l]||ls[l+1])return memo[l][r]=make_pair(1e8,-1e8);\n\t\t else {\n\t\t\t if (pluss[l]) {\n\t\t\t\t return memo[l][r]=make_pair(nums[l]+nums[l+1],nums[l]+nums[l+1]);\n\t\t\t }\n\t\t\t else {\n\t\t\t\t return memo[l][r]=make_pair(nums[l]-nums[l+1],nums[l]-nums[l+1]);\n\t\t\t }\n\t\t }\n\t }\n\t else {\n\t\t pair<int,int>ans=make_pair(1e8,-1e8);\n\t\t for (int k = l + 1; k < r; ++k) {\n\t\t\t bool ok=true;\n\t\t\t//if(ls[k-1])ok=false;\n\t\t\t if(!ok)continue;\n\t\t\t else {\n\t\t\t\t auto lp=solve(l,k),rp=solve(k,r);\n\n\t\t\t\t if (pluss[k - 1]) {\n\t\t\t\t\t auto p=make_pair(lp.first+rp.first,lp.second+rp.second);\n\t\t\t\t\t ans=make_pair(min(ans.first,p.first),max(ans.second,p.second));\n\t\t\t\t }\n\t\t\t\t else {\n\t\t\t\t\t auto p=make_pair(lp.first-rp.second,lp.second-rp.first);\n\t\t\t\t\t ans=make_pair(min(ans.first,p.first),max(ans.second,p.second));\n\t\t\t\t }\n\t\t\t }\n\t\t }\n\t\t return memo[l][r]=ans;\n\t }\n}\n\nint main()\n{\n\tcin>>st;\n\tinit();\n\tauto p=solve(0,nums.size());\n\tcout<<p.second<<endl;\n\treturn 0;\n}\n"
  },
  {
    "language": "C++",
    "code": "#include \"bits/stdc++.h\"\n#include<unordered_map>\n#include<unordered_set>\n#pragma warning(disable:4996)\nusing namespace std;\nusing ld = long double;\nconst ld eps = 1e-9;\n\nstruct Edge {\n\tint src;\n\tint dst;\n\tlong long int cost;\n};\nusing Graph=vector<vector<Edge>>;\n\nclass Centroid {\npublic:\n\tint dfs(const Graph&g, const int now, const int from, vector<int>&ch_nums, const vector<int>&oks) {\n\t\tint sum = 1;\n\t\tfor (auto &&e : g[now]) {\n\t\t\tif (e.dst == from || oks[e.dst]!=-1)continue;\n\t\t\telse {\n\t\t\t\tsum += dfs(g, e.dst, e.src, ch_nums,oks);\n\t\t\t}\n\t\t}\n\t\treturn ch_nums[now] = sum;\n\t};\n\n\n\tint find_centroid(const int asize, const vector<vector<Edge>>&graph, const int pre_root, const int pre_from, const vector<int>&ch_nums, const vector<int>&oks) {\n\t\tfor (auto&& e : graph[pre_root]) {\n\t\t\tif (e.dst == pre_from)continue;\n\t\t\tif (oks[e.dst]!=-1)continue;\n\t\t\tif (ch_nums[e.dst]>asize / 2)return find_centroid(asize, graph, e.dst, e.src, ch_nums, oks);\n\t\t}\n\t\treturn pre_root;\n\t}\n\n\t//void dfs2(const Graph&g, const int now, const int from,vector<long long int>&lens,const int root_id, long long int nlen) {\n\t//\tlens.push_back(nlen);\n\t//\tmp[make_pair(root_id,now)]=nlen;\n\t//\tfor (auto &&e : g[now]) {\n\t//\t\tif (e.dst == from || oks[e.dst] != -1)continue;\n\t//\t\telse {\n\t//\t\t\tdfs2(g,e.dst,e.src,lens,root_id,nlen+e.cost);\n\t//\t\t}\n\t//\t}\n\t//}\n\n\tvoid cent(const vector<vector<Edge>>&graph, vector<int>&oks, const int root, const int from, vector<vector<int>>&centroid_edges, int& fst_centroid,int depth,vector<int>&ch_nums) {\ndfs(graph, root, from, ch_nums, oks);\n\n\t\tint cent_id = find_centroid(ch_nums[root], graph, root, from, ch_nums, oks);\n\n\t\t\n\t\t//dfs2(graph,cent_id,from,lens[cent_id],0);\n\t\tsort(lens[cent_id].begin(),lens[cent_id].end());\n\n\t\toks[cent_id] = depth;\n\t\tif (from != -1) {\n\t\t\tcentroid_edges[from].push_back(cent_id);\n\t\t}\n\t\telse {\n\t\t\tfst_centroid = cent_id;\n\t\t}\n\t\tfor (auto e : graph[cent_id]) {\n\t\t\tif (e.dst == from)continue;\n\t\t\tif (oks[e.dst]!=-1)continue;\n\t\t\tcent(graph, oks, e.dst, e.src, centroid_edges, fst_centroid,depth+1,ch_nums);\n\t\t}\n\t}\n\npublic:\n\n\n\tvector<vector<long long int>>lens;\n\tvector<vector<int>> centroid_graph;\n\tvector<int>parents;\n\tvector<int>oks;\n\tmap<pair<int,int>,long long int>mp;\n\n\t//fst:root  snd:centroid_graph\n\tvector<vector<int>> get_cent_parent(const Graph&g) {\n\t\tlens.resize(g.size());\n\t\toks=vector<int>(g.size(),-1);\n\t\tint root = -1;\n\t\tcentroid_graph.resize(g.size());\n\t\tparents=vector<int>(g.size(),-1);\n\t\tvector<int>ch_nums(g.size());\n\t\tcent(g, oks, 0, -1, centroid_graph, root,0,ch_nums);\n\n\t\tfor (int i = 0; i < centroid_graph.size(); ++i) {\n\t\t\tfor (auto&& e : centroid_graph[i]) {\n\t\t\t\tparents[e] = i;\n\t\t\t}\n\t\t}\n\t\treturn centroid_graph;\n\t}\n}centroid;\n\n\nvoid addEdge(Graph& g ,int a, int b,long long int c) {\n\tg[a - 1].push_back(Edge{ a - 1,b - 1,c });\n\tg[b - 1].push_back(Edge{ b - 1,a - 1,c });\n}\n\nvector<int>nums;\nvector<int>ls;\nvector<int>rs;\nvector<int>pluss;\nvector<vector<pair<int,int>>>memo;\n\nstring st;\nvoid term(int&a,int&k) {\n\tnums.push_back(0);\n\tls.push_back(0);\n\trs.push_back(0);\n\twhile (a != st.size() && st[a] == '(') {\n\t\tls[k]=true;\n\t\ta++;\n\t}\n\tnums[k]=st[a]-'0';\n\ta++;\n\twhile (a != st.size() && st[a] == ')') {\n\t\trs[k]=true;\n\t\ta++;\n\t}\n\tk++;\n\treturn ;\n}\nvoid expr(int &a) {\n\tint k=0;\n\tterm(a,k);\n\n\twhile (a != st.size()) {\n\t\tpluss.push_back(st[a]=='+');\n\t\ta++;\n\t\tterm(a,k);\n\t}\n}\nvoid init() {\n\tint a=0;\n\texpr(a);\n\tmemo=vector<vector<pair<int,int>>>(nums.size()+1,vector<pair<int,int>>(nums.size()+1,make_pair(1e9,-1e9)));\n}\n\npair<int,int> solve(int l, int r) {\n\tif(memo[l][r].first!=1e9)return memo[l][r];\n\t if(l+1==r)return memo[l][r]=make_pair(nums[l],nums[l]);\n\t if (l + 2 == r) {\n\t\t if(rs[l]||ls[l+1])return memo[l][r]=make_pair(1e8,-1e8);\n\t\t else {\n\t\t\t if (pluss[l]) {\n\t\t\t\t return memo[l][r]=make_pair(nums[l]+nums[l+1],nums[l]+nums[l+1]);\n\t\t\t }\n\t\t\t else {\n\t\t\t\t return memo[l][r]=make_pair(nums[l]-nums[l+1],nums[l]-nums[l+1]);\n\t\t\t }\n\t\t }\n\t }\n\t else {\n\t\t pair<int,int>ans=make_pair(1e8,-1e8);\n\t\t if(rs[l]||ls[r-1])return make_pair(1e8,-1e8);\n\t\t for (int k = l + 1; k < r; ++k) {\n\t\t\t bool ok=true;\n\t\t\t//if(ls[k-1])ok=false;\n\t\t\t if(!ok)continue;\n\t\t\t else {\n\t\t\t\t auto lp=solve(l,k),rp=solve(k,r);\n\n\t\t\t\t if (pluss[k - 1]) {\n\t\t\t\t\t auto p=make_pair(lp.first+rp.first,lp.second+rp.second);\n\t\t\t\t\t ans=make_pair(min(ans.first,p.first),max(ans.second,p.second));\n\t\t\t\t }\n\t\t\t\t else {\n\t\t\t\t\t auto p=make_pair(lp.first-rp.second,lp.second-rp.first);\n\t\t\t\t\t ans=make_pair(min(ans.first,p.first),max(ans.second,p.second));\n\t\t\t\t }\n\t\t\t }\n\t\t }\n\t\t return memo[l][r]=ans;\n\t }\n}\n\nint main()\n{\n\tcin>>st;\n\tinit();\n\tauto p=solve(0,nums.size());\n\tcout<<p.second<<endl;\n\treturn 0;\n}\n"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\n\nusing namespace std;\n\n#define rep(i,n) for(int i=0; i<n; i++)\n#define reep(i,a,b) for(int i=a; i<b; i++)\n#define INF 0x3f3f3f3f\n\nstring s;\nint mn[300][300];\nint mx[300][300];\n\nint MAX(int l, int r);\nint MIN(int l, int r);\n\n\nint MAX(int l, int r){\n\tif(mx[l][r]!=-INF) return mx[l][r];\n\tint &ret = mx[l][r];\n\twhile(s[l] == '('){\n\t\tl++;\n\t}\n\twhile(s[r] == ')'){\n\t\tr--;\n\t}\n\tif(l==r&&isdigit(s[l])){\n\t\treturn ret = s[l]-'0';\n\t}\n\tif(s[l+1]==')') return ret;\n\tif(s[r-1]=='(') return ret;\n\tint lim = l-1;\n\tint cnt = 0;\n\tfor(int i=r; i>=l; i--){\n\t\tcnt += isdigit(s[i]);\n\t\tif(cnt==2){\n\t\t\tlim = i;\n\t\t\tbreak;\n\t\t}\n\t}\n\tcnt = 0;\n\treep(i,l,r+1){\n\t\tcnt += isdigit(s[i]);\n\t\tif(s[i]=='+'){\n\t\t\t// if(s[i-1]==')'&&cnt<2) continue;\n\t\t\t// if(s[i+1]=='('&&lim<i) continue;\n\t\t\t// if(l==i-2&&s[i-1]==')'&&isdigit(s[i-2])) continue;\n\t\t\t// if(i+2==r&&s[i+1]=='('&&isdigit(s[i+2])) continue;\n\t\t\tret = max(ret, MAX(l,i-1)+MAX(i+1, r));\n\t\t\tif(l==3&&r==20){\n\t\t\t\t// cout<<ret<<\" \"<<MAX(l,i-1)<<\" + \"<<MIN(i+1, r)<<endl;\n\t\t\t}\n\t\t}\n\t\tif(s[i]=='-'){\n\t\t\t// if(s[i-1]==')'&&cnt<2) continue;\n\t\t\t// if(s[i+1]=='('&&lim<i) continue;\n\t\t\t// if(l==i-2&&s[i-1]==')'&&isdigit(s[i-2])) continue;\n\t\t\t// if(i+2==r&&s[i+1]=='('&&isdigit(s[i+2])) continue;\n\t\t\tret = max(ret, MAX(l,i-1)-MIN(i+1, r));\n\t\t\tif(l==3&&r==20){\n\t\t\t\t// cout<<ret<<\" \"<<MAX(l,i-1)<<\" - \"<<MIN(i+1, r)<<endl;\n\t\t\t}\n\t\t}\n\t}\n\t// cout<<\"MAX \"<<s.substr(l,r-l+1)<<\" \"<<ret<<endl;\n\treturn ret;\n}\n\nint MIN(int l, int r){\n\tif(mn[l][r]!=INF) return mn[l][r];\n\tint &ret = mn[l][r];\n\twhile(s[l] == '('){\n\t\tl++;\n\t}\n\twhile(s[r] == ')'){\n\t\tr--;\n\t}\n\tif(l==r&&isdigit(s[l])){\n\t\treturn ret = s[l]-'0';\n\t}\n\tif(s[l+1]==')') return ret;\n\tif(s[r-1]=='(') return ret;\n\tint lim = l-1;\n\tint cnt = 0;\n\tfor(int i=r; i>=l; i--){\n\t\tcnt += isdigit(s[i]);\n\t\tif(cnt==2){\n\t\t\tlim = i;\n\t\t\tbreak;\n\t\t}\n\t}\n\tcnt = 0;\n\treep(i,l,r+1){\n\t\tcnt += isdigit(s[i]);\n\t\tif(s[i]=='+'){\n\t\t\t// if(s[i-1]==')'&&cnt<2) continue;\n\t\t\t// if(s[i+1]=='('&&lim<i) continue;\n\t\t\t// if(l==i-2&&s[i-1]==')'&&isdigit(s[i-2])) continue;\n\t\t\t// if(i+2==r&&s[i+1]=='('&&isdigit(s[i+2])) continue;\n\t\t\tret = min(ret, MIN(l,i-1)+MIN(i+1, r));\n\t\t\tif(l==3&&r==18){\n\t\t\t\t// cout<<ret<<\" \"<<MIN(l,i-1)<<\" + \"<<MIN(i+1, r)<<endl;\n\t\t\t}\n\t\t}\n\t\tif(s[i]=='-'){\n\t\t\t// if(s[i-1]==')'&&cnt<2) continue;\n\t\t\t// if(s[i+1]=='('&&lim<i) continue;\n\t\t\t// if(l==i-2&&s[i-1]==')'&&isdigit(s[i-2])) continue;\n\t\t\t// if(i+2==r&&s[i+1]=='('&&isdigit(s[i+2])) continue;\n\t\t\tret = min(ret, MIN(l,i-1)-MAX(i+1, r));\n\t\t\tif(l==3&&r==18){\n\t\t\t\t// cout<<ret<<\" \"<<MIN(l,i-1)<<\" - \"<<MAX(i+1, r)<<endl;\n\t\t\t}\n\t\t}\n\t}\n\t// cout<<\"MIN \"<<s.substr(l,r-l+1)<<\" \"<<ret<<endl;\n\treturn ret;\n}\n\nint main(){\n\tcin>>s;\n\trep(i,300){\n\t\trep(j,300){\n\t\t\tmx[i][j] = -INF;\n\t\t\tmn[i][j] = INF;\n\t\t}\n\t}\n\tcout<<MAX(0,s.size()-1)<<endl;\n}"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\n\n#define _overload(_1,_2,_3,name,...) name\n#define _rep(i,n) _range(i,0,n)\n#define _range(i,a,b) for(int i=int(a);i<int(b);++i)\n#define rep(...) _overload(__VA_ARGS__,_range,_rep,)(__VA_ARGS__)\n\n#define _rrep(i,n) _rrange(i,n,0)\n#define _rrange(i,a,b) for(int i=int(a)-1;i>=int(b);--i)\n#define rrep(...) _overload(__VA_ARGS__,_rrange,_rrep,)(__VA_ARGS__)\n\n#define _all(arg) begin(arg),end(arg)\n#define uniq(arg) sort(_all(arg)),(arg).erase(unique(_all(arg)),end(arg))\n#define getidx(ary,key) lower_bound(_all(ary),key)-begin(ary)\n#define clr(a,b) memset((a),(b),sizeof(a))\n#define bit(n) (1LL<<(n))\n#define popcount(n) (__builtin_popcountll(n))\n\ntemplate<class T>bool chmax(T &a, const T &b) { return (a<b)?(a=b,1):0;}\ntemplate<class T>bool chmin(T &a, const T &b) { return (b<a)?(a=b,1):0;}\n\nusing namespace std;\nconst int inf=1<<20;\n\nint num[210];\nchar op[210];\nbool lb[210],rb[210];\n\nint memo[210][210][2];\n\nint rec(int l,int r){\n\tif(r-l==1) return memo[l][r][0]=memo[l][r][1]=num[l];\n\n\tif(lb[r-1]) return -inf;\n\tif(rb[l]) return -inf;\n\t\n\tint &cmin=memo[l][r][0];\n\tint &cmax=memo[l][r][1];\n\tif(cmax!=-inf) return cmax;\n\n\trep(m,l+1,r){\n\t\tint a=rec(l,m),b=rec(m,r);\n\t\tif(a==-inf||b==-inf) continue;\n\t\tif(op[m]=='+'){\n\t\t\tchmax(cmax,memo[l][m][1]+memo[m][r][1]);\n\t\t\tchmin(cmin,memo[l][m][0]+memo[m][r][0]);\n\t\t}else{\n\t\t\tchmax(cmax,memo[l][m][1]-memo[m][r][0]);\n\t\t\tchmin(cmin,memo[l][m][0]-memo[m][r][1]);\n\t\t}\n\t}\n\n\treturn cmax;\n}\n\n\nint main(void){\n\tstring s;\n\tcin >> s;\n\n\tint tidx=0,oidx=1;\n\tfor(auto &c:s){\n\t\tif(c=='(') lb[tidx]=true;\n\t\tif(c==')') rb[tidx-1]=true;\n\t\tif(isdigit(c)) num[tidx++]=c-'0';\n\t\tif(c=='+'||c=='-') op[oidx++]=c;\n\t}\n\n\t// rep(i,5) cout << num[i] << \" \" << lb[i] << \" \" << rb[i] << endl;\n\t// rep(i,1,5) cout << op[i] << endl;\n\n\trep(i,210)rep(j,210) memo[i][j][0]=inf,memo[i][j][1]=-inf;\n\tcout << rec(0,tidx) << endl;\n\n\treturn 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include <iostream>\n#include <cmath>\n#define REP(i, a, n) for(int i = ((int) a); i < ((int) n); i++)\n#define INF 100000000\nusing namespace std;\ntypedef long long ll;\n\nstring S;\nll dp[300][300][2];\n\nll number(int l, int r) {\n  ll ret = 0;\n  REP(i, l, r) {\n    if('0' <= S[i] && S[i] <= '9') ret = ret * 10 + (S[i] - '0');\n    else return -1;\n  }\n  return ret;\n}\n\nll dfs(int l, int r, int mode, int depth) {\n  ll ret;\n\n  if(dp[l][r][mode] >= 0) ret = dp[l][r][mode];\n  else {\n    ll n = number(l, r);\n    if(n >= 0) ret = n;\n    else {\n      ret = mode == 0 ? -INF : INF;\n      REP(i, l, r) {\n        if(S[i] != '+' && S[i] != '-') continue;\n\n        int nl = l, nr = r;\n        while(1) {\n          ll n1 = dfs(nl, i, 0, depth + 1);\n          ll n2 = dfs(i + 1, nr, S[i] == '-', depth + 1);\n          if(abs(n1) != INF && abs(n2) != INF) {\n            if(mode == 0) {\n              if(S[i] == '+') ret = max(ret, n1 + n2);\n              if(S[i] == '-') ret = max(ret, n1 - n2);\n            } else {\n              if(S[i] == '+') ret = min(ret, n1 + n2);\n              if(S[i] == '-') ret = min(ret, n1 - n2);\n            }\n          }\n          if(S[nl] != '(' && S[nr - 1] != ')') break;\n          if(S[nl] == '(') nl++;\n          if(S[nr - 1] == ')') nr--;\n        }\n      }\n    }\n  }\n\n  return dp[l][r][mode] = ret;\n}\n\nint main(void) {\n  cin >> S;\n\n  REP(i, 0, 201) REP(j, 0, 201) REP(k, 0, 2) dp[i][j][k] = -INF;\n  cout << dfs(0, S.size(), 0, 0) << endl;\n\n  return 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\nusing namespace std;\n\nusing ll = long long;\n\nusing P = pair<int, int>;\n\nconstexpr int INF = 1e9;\n\nP memo[201][201];\n\nP rec(int l, int r, string const& s) {\n    P& res = memo[l][r];\n    if(res != make_pair(-INF, INF)) {\n        return res;\n    }\n    if(l == r) {\n        int v = s[l] - '0';\n        return make_pair(v, v);\n    }\n    if(s[r] == ')' && r-l >= 3) {\n        P p = rec(l, r-1, s);\n        res.first = max(res.first, p.first);\n        res.second = min(res.second, p.second);\n    }\n    if(s[l] == '(' && r-l >= 3) {\n        P p = rec(l+1, r, s);\n        res.first = max(res.first, p.first);\n        res.second = min(res.second, p.second);\n    }\n    for(int i=l+1; i<r; ++i) {\n        char op = s[i];\n        if(op == '+' || op == '-') {\n            P rl = rec(l, i-1, s);\n            P rr = rec(i+1, r, s);\n            if(op == '+') {\n                res.first = max(res.first, rl.first + rr.first);\n                res.second = min(res.second, rl.second + rr.second);\n            } else {\n                res.first = max(res.first, rl.first - rr.second);\n                res.second = min(res.second, rl.second - rr.first);\n            }\n        }\n    }\n    return res;\n}\n\nint main() {\n    string s;\n    cin >> s;\n    for(int i=0; i<s.size(); ++i) {\n        for(int j=0; j<s.size(); ++j) {\n            memo[i][j] = make_pair(-INF, INF);\n        }\n    }\n    cout << rec(0, s.size()-1, s).first << endl;\n}"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\n#define INF (1e9)\nusing namespace std;\n\n\nint calc(string s){\n  vector<int> v;\n  for(int i=0;i<s.size();i++){\n    int n = (int)v.size()-1;\n    if(s[i]=='+')v.push_back(0);\n    if(s[i]=='-')v.push_back(1);\n    if(s[i]=='(')v.push_back(0),v.push_back(0);\n    if(s[i]==')'){\n      if(v.size()<3)continue;\n      v[n-2]+=v[n-1]? -v[n]:v[n];\n      v.pop_back(),v.pop_back();\n    }\n\n    if(isdigit(s[i])){\n      int num=s[i]-'0';\n      if(v.size()>=2){\n\tv[n-1]+=v[n]? -num:num;\n\tv.pop_back();\n      }\n      else v.push_back(num);\n    }\n  }\n  return v[0];\n}\n\nmap<string,int> mem[2];\nint dfs(string s,int f){\n  if(s.size()==1) return s[0]-'0';\n  if(mem[f].count(s))return mem[f][s];\n  int n=s.size(),res=calc(s);\n  for(int i=0,c=0;i<n;i++){\n    while(i<n){\n      while(s[i]=='('||s[i]==')')c+=(s[i]=='(')-(s[i]==')'),i++;\n      if(s[i]=='+'||s[i]=='-') break;\n      i++;\n    }\n    if(i>=n)break;\n    if((i-2>=0&&s[i-2]=='(')&&s[i+1]!='(')continue;\n    string a=s.substr(0,i),b=s.substr(i+1,n-i-1);\n    int t=c,ch=s[i];\n    while(t--)a+=')',b='('+b;\n    int mxa=dfs(a,0),mna=dfs(a,1);\n    int mxb=dfs(b,0),mnb=dfs(b,1);\n    if(f==0&&ch=='+') res=max(res, mxa+mxb);\n    if(f==0&&ch=='-') res=max(res, mxa-mnb);\n    if(f==1&&ch=='+') res=min(res, mna+mnb);\n    if(f==1&&ch=='-') res=min(res, mna-mxb);\n  }\n  return mem[f][s]=res;\n}\n\n\n\nint main(){\n  string S;\n  cin>>S;\n  cout <<dfs(S,0)<<endl;\n  return 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include <iostream>\n#include <vector>\n#include <algorithm>\nusing namespace std;\nconst int inf = 1e9;\n\nbool isvalid(int b, int e, vector<int> &num, string &str){\n    int numbr=0, numop=0;\n    for(int i=num[b]; i<=num[e]; i++){\n        if(str[i]=='+' || str[i]=='-') numop++;\n        if(str[i]==')'){\n            numbr++;\n            if(numbr > numop) return false;\n        }\n    }\n    numbr=0; numop=0;\n    for(int i=num[e]; i>=num[b]; i--){\n        if(str[i]=='+' || str[i]=='-') numop++;\n        if(str[i]=='('){\n            numbr++;\n            if(numbr > numop) return false;\n        }\n    }\n    return true;\n}\n\nint main(){\n    string str;\n    cin >> str;\n    vector<int> num, op;\n    for(int i=0; i<(int)str.length(); i++){\n        if('0'<=str[i] && str[i]<='9') num.push_back(i);\n        if(str[i]=='+' || str[i]=='-') op.push_back(i);\n    }\n    \n    int n = num.size();\n    vector<vector<int> > dpmin(n, vector<int>(n, inf)), dpmax(n, vector<int>(n, -inf));;\n    for(int i=0; i<n; i++) dpmin[i][i] = dpmax[i][i] = str[num[i]]-'0';\n    \n    for(int j=1; j<n; j++){\n        for(int i=0; i+j<n; i++){\n            for(int k=0; k<j; k++){\n                if(isvalid(i, i+k, num, str) && isvalid(i+k+1, i+j, num, str)){\n                    if(str[op[i+k]] == '+'){\n                        dpmax[i][i+j] = max(dpmax[i][i+j], dpmax[i][i+k]+dpmax[i+k+1][i+j]);\n                        dpmin[i][i+j] = min(dpmin[i][i+j], dpmin[i][i+k]+dpmin[i+k+1][i+j]);\n                    }else{\n                        dpmax[i][i+j] = max(dpmax[i][i+j], dpmax[i][i+k]-dpmin[i+k+1][i+j]);\n                        dpmin[i][i+j] = min(dpmin[i][i+j], dpmin[i][i+k]-dpmax[i+k+1][i+j]);\n                    }\n                }\n            }\n        }\n    }\n    cout << dpmax[0][n-1] << endl;\n    return 0;\n}\n\n"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\nusing namespace std;\n\nusing VI = vector<int>;\nusing VVI = vector<VI>;\nusing PII = pair<int, int>;\nusing LL = long long;\nusing VL = vector<LL>;\nusing VVL = vector<VL>;\nusing PLL = pair<LL, LL>;\nusing VS = vector<string>;\n\n#define ALL(a)  begin((a)),end((a))\n#define RALL(a) (a).rbegin(), (a).rend()\n#define PB push_back\n#define EB emplace_back\n#define MP make_pair\n#define SZ(a) int((a).size())\n#define SORT(c) sort(ALL((c)))\n#define RSORT(c) sort(RALL((c)))\n#define UNIQ(c) (c).erase(unique(ALL((c))), end((c)))\n\n#define FOR(i,a,b) for(int i=(a);i<(b);++i)\n#define REP(i,n)  FOR(i,0,n)\n\n#define FF first\n#define SS second\ntemplate<class S, class T>\nistream& operator>>(istream& is, pair<S,T>& p){\n  return is >> p.FF >> p.SS;\n}\ntemplate<class S, class T>\nostream& operator<<(ostream& os, const pair<S,T>& p){\n  return os << p.FF << \" \" << p.SS;\n}\ntemplate<class T>\nvoid maxi(T& x, T y){\n  if(x < y) x = y;\n}\ntemplate<class T>\nvoid mini(T& x, T y){\n  if(x > y) x = y;\n}\n\n\nconst double EPS = 1e-10;\nconst double PI  = acos(-1.0);\nconst LL MOD = 1e9+7;\nconst LL INF = 1e7;\n\nint dp[210][210][2];\nbool isl[210], isr[210];\nstring S;\nint N;\n\nint solve(int l, int r, int f){\n  if(dp[l][r][f] != MOD) return dp[l][r][f];\n\n  int& res = dp[l][r][f];\n  res = f? -INF: INF;\n  if(l+1 == r){\n\tif(!isl[l] && !isr[l])\n\t  res = S[l] - '0';\n\treturn res;\n  }\n\n  bool pl = isl[l];\n  bool pr = isr[r-1];\n  isl[l] = isr[r-1] = false;\n  for(int i=l+1;i<r-1;i+=2){\n\tif(isl[i-1] || isr[i+1]) continue;\n\tif(S[i] == '+'){\n\t  if(f)\n\t\tmaxi(res, solve(l,i,1) + solve(i+1,r,1));\n\t  else\n\t\tmini(res, solve(l,i,0) + solve(i+1,r,0));\n\t}\n\telse if(S[i] == '-'){\n\t  if(f)\n\t\tmaxi(res, solve(l,i,1) - solve(i+1,r,0));\n\t  else\n\t\tmini(res, solve(l,i,0) - solve(i+1,r,1));\n\t}\n  }\n  isl[l] = pl;\n  isr[r-1] = pr;\n  \n  return res;\n}\n\n\nint main(){\n  cin.tie(0);\n  ios_base::sync_with_stdio(false);\n\n  string tmp;\n  cin >> tmp;\n\n  int j = 0;\n  for(int i=0;i<SZ(tmp);++i){\n\tif(tmp[i] == '('){\n\t  isl[j] = true;\n\t}\n\telse if(tmp[i] == ')'){\n\t  isr[j-1] = true;\n\t}\n\telse{\n\t  S += string(1, tmp[i]);\n\t  ++j;\n\t}\n  }\n  N = SZ(S);\n\n  fill((int*)dp, (int*)dp+210*210*2, MOD);\n  cout << solve(0, N, 1) << endl;\n\n  return 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include <iostream>\n#include <string>\n#include <vector>\n#include <algorithm>\n#include <cmath>\n#include <cstdio>\n#include <functional>\n#include <numeric>\n#include <stack>\n#include <queue>\n#include <map>\n#include <set>\n#include <utility>\n#include <sstream>\n#include <complex>\n#include <fstream>\n#include <bitset>\n#include <time.h>\n\nusing namespace std;\n\ntypedef long long ll;\ntypedef pair<ll, ll> P;\ntypedef vector<ll> V;\ntypedef complex<double> Point;\n\n#define PI acos(-1.0)\n#define EPS 1e-10\nconst ll INF = (1LL << 31) - 1;\nconst ll MOD = 1e9 + 7;\n\n#define FOR(i,a,b) for(int i=(a);i<(b);i++)\n#define rep(i,N) for(int i=0;i<(N);i++)\n#define ALL(s) (s).begin(),(s).end()\n#define EQ(a,b) (abs((a)-(b))<EPS)\n#define EQV(a,b) ( EQ((a).real(), (b).real()) && EQ((a).imag(), (b).imag()) )\n#define fi first\n#define se second\n#define N_SIZE (1LL << 20)\n#define NIL -1\n#define MAX_N 100100 * 3\n\nstring s;\nvector<int> pos;\n\nll digit(string& s, int& pos);\n//ll term(& s, int& pos);\nll expr(string& s, int& pos);\nll factor(string& s, int& pos);\n\nbool is_digit(char c) {\n\treturn c >= '0'&&c <= '9';\n}\n\nll digit(string& s, int& pos) {\n\treturn s[pos++] - '0';\n}\n\nll factor(string& s, int& pos) {\n\tif (isdigit(s[pos]))return digit(s, pos);\n\n\tpos++; \n\tll ret = expr(s, pos);\n\tpos++; \n\treturn ret;\n}\n\nll expr(string& s, int& pos) {\n\tll res = factor(s, pos);\n\twhile (s[pos] == '+' || s[pos] == '-') {\n\t\tif (s[pos] == '+') {\n\t\t\tpos++;\n\t\t\tres += factor(s, pos);\n\t\t}\n\t\telse if (s[pos] == '-') {\n\t\t\tpos++;\n\t\t\tres -= factor(s, pos);\n\t\t}\n\t}\n\treturn res;\n}\n\nint main() {\n\tcin >> s;\n\trep(i, s.size()) {\n\t\tif (is_digit(s[i]))pos.push_back(i);\n\t}\n\tint p = 0;\n\tll ans = expr(s, p);\n\trep(i, pos.size()) {\n\t\tFOR(j, i, pos.size()) {\n\t\t\tp = 0;\n\t\t\tint n[2] = { pos[i],pos[j] };\n\t\t\tstring t = s.substr(0, n[0]) + \"(\" + s.substr(n[0], n[1] - n[0] + 1) + \")\" + s.substr(n[1] + 1);\n\t\t\tbool f = 0;\n\t\t\trep(k, t.size() - 2) {\n\t\t\t\tif (t[k] == '('&&t[k + 2] == ')')f = 1;\n\t\t\t}\n\t\t\tif (f)continue;\n\t\t\t//cout << t << endl;\n\t\t\tans = max(ans, expr(t, p));\n\t\t\t//cout << \"!!\" << ans << endl;\n\t\t}\n\t}\n\tcout << ans << endl;\n}"
  },
  {
    "language": "C++",
    "code": "#include<bits/stdc++.h>\nusing namespace std;\n\n#define int long long\ntypedef vector<int>vint;\ntypedef pair<int,int>pint;\ntypedef vector<pint>vpint;\n#define rep(i,n) for(int i=0;i<(n);i++)\n#define reps(i,f,n) for(int i=(f);i<(n);i++)\n#define all(v) (v).begin(),(v).end()\n#define each(it,v) for(__typeof((v).begin()) it=(v).begin();it!=(v).end();it++)\n#define pb push_back\n#define fi first\n#define se second\ntemplate<typename A,typename B>inline void chmin(A &a,B b){if(a>b)a=b;}\ntemplate<typename A,typename B>inline void chmax(A &a,B b){if(a<b)a=b;}\n\nint N;\nint A[222],ope[222],bef[222],aft[222];\n\n\nconst int INF=1001001001001001001ll;\nint mi[222][222];\nint ma[222][222];\n\nsigned main(){\n    string S;cin>>S;\n    rep(i,S.size()){\n        if(!isdigit(S[i]))continue;\n        A[N]=S[i]-'0';\n        if(i+1<S.size()&&S[i+1]==')')aft[N]=1;\n        ope[N]=1;\n        int t=i;\n        while(t&&S[t-1]=='(')t--,bef[N]=1;\n        if(t&&S[t-1]=='-')ope[N]=-1;\n        N++;\n    }\n\n    fill_n(*ma,222*222,-INF);\n    fill_n(*mi,222*222,INF);\n    rep(i,N){\n        if(!bef[i])mi[i][i+1]=ma[i][i+1]=A[i]*ope[i];\n    }\n\n\n    for(int len=2;len<=N;len++){\n        for(int i=0;i+len<=N;i++){\n            int j=i+len;\n            for(int k=i+1;k<j;k++){\n                chmax(ma[i][j],ma[i][k]+ma[k][j]);\n                chmin(mi[i][j],mi[i][k]+mi[k][j]);\n            }\n            if(!aft[i]&&ope[i]==-1){\n                chmax(ma[i][j],-(A[i]+mi[i+1][j]));\n                chmin(mi[i][j],-(A[i]+ma[i+1][j]));\n            }\n        }\n    }\n\n    cout<<ma[0][N]<<endl;\n    return 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include <iostream>\n#include <cstdio>\n#include <string>\n#include <algorithm>\n#include <utility>\nusing namespace std;\ntypedef pair<int, int> pii;\ninline void chmax(int &a, const int &b) {a = max(a, b);}\ninline void chmin(int &a, const int &b) {a = min(a, b);}\nconst int INF = 1 << 28;\nstring s;\nint N;\npii dp[210][210], INIT;\n\npii solve(int l, int r) {\n    pii &res = dp[l][r];\n    if(dp[l][r] != INIT) return res;\n    // 数字\n    if(r - l == 1) {\n        int val = s[l] - '0';\n        return res = make_pair(val, val);\n    }\n    // 括弧をとっぱらって再帰的に\n    // このとき、括弧含め幅が 3 以下 (つまり実質 2 以下) だと\n    // 数式になりえないので飛ばす\n    if(s[l] == '(' && r-l > 3) {\n        pii tmp = solve(l+1, r);\n        res.first = max(res.first, tmp.first);\n        res.second = min(res.second, tmp.second);\n    }\n    if(s[r-1] == ')' && r-l > 3) {\n        pii tmp = solve(l, r-1);\n        res.first = max(res.first, tmp.first);\n        res.second = min(res.second, tmp.second);\n    }\n    for(int k=l; k<r; k++) {\n        if(s[k] != '+' && s[k] != '-') continue;\n        pii v1 = solve(l, k), v2 = solve(k+1, r);\n        if(s[k] == '+') {\n            res.first = max(res.first, v1.first + v2.first);\n            res.second = min(res.second, v1.second + v2.second);\n        }\n        else {\n            res.first = max(res.first, v1.first - v2.second);\n            res.second = min(res.second, v1.second - v2.first);\n        }\n    }\n    return res;\n}\n\nint main() {\n    cin >> s;\n    N = s.length();\n    INIT = make_pair(-INF, INF);\n    for(int i=0; i<N; i++) {\n        fill(dp[i], dp[i] + N + 1, INIT);\n    }\n\n    cout << solve(0, N).first << endl;\n    /*\n    for(int i=0; i<N; i++) {\n        for(int j=i+1; j<=N; j++) {\n            if(dp_max[i][j] == -INF) continue;\n            printf(\"%s\\n\", s.c_str());\n            for(int k=0; k<N; k++) {\n                if(i <= k && k < j) printf(\"=\");\n                else printf(\" \");\n            }\n            printf(\" -> %d\\n\", dp_max[i][j]);\n        }\n    }\n    */\n    return 0;\n}\n"
  },
  {
    "language": "C++",
    "code": "#include \"bits/stdc++.h\"\n#include<unordered_map>\n#include<unordered_set>\n#pragma warning(disable:4996)\nusing namespace std;\nusing ld = long double;\nconst ld eps = 1e-9;\n\nstruct Edge {\n\tint src;\n\tint dst;\n\tlong long int cost;\n};\nusing Graph=vector<vector<Edge>>;\n\nclass Centroid {\npublic:\n\tint dfs(const Graph&g, const int now, const int from, vector<int>&ch_nums, const vector<int>&oks) {\n\t\tint sum = 1;\n\t\tfor (auto &&e : g[now]) {\n\t\t\tif (e.dst == from || oks[e.dst]!=-1)continue;\n\t\t\telse {\n\t\t\t\tsum += dfs(g, e.dst, e.src, ch_nums,oks);\n\t\t\t}\n\t\t}\n\t\treturn ch_nums[now] = sum;\n\t};\n\n\n\tint find_centroid(const int asize, const vector<vector<Edge>>&graph, const int pre_root, const int pre_from, const vector<int>&ch_nums, const vector<int>&oks) {\n\t\tfor (auto&& e : graph[pre_root]) {\n\t\t\tif (e.dst == pre_from)continue;\n\t\t\tif (oks[e.dst]!=-1)continue;\n\t\t\tif (ch_nums[e.dst]>asize / 2)return find_centroid(asize, graph, e.dst, e.src, ch_nums, oks);\n\t\t}\n\t\treturn pre_root;\n\t}\n\n\t//void dfs2(const Graph&g, const int now, const int from,vector<long long int>&lens,const int root_id, long long int nlen) {\n\t//\tlens.push_back(nlen);\n\t//\tmp[make_pair(root_id,now)]=nlen;\n\t//\tfor (auto &&e : g[now]) {\n\t//\t\tif (e.dst == from || oks[e.dst] != -1)continue;\n\t//\t\telse {\n\t//\t\t\tdfs2(g,e.dst,e.src,lens,root_id,nlen+e.cost);\n\t//\t\t}\n\t//\t}\n\t//}\n\n\tvoid cent(const vector<vector<Edge>>&graph, vector<int>&oks, const int root, const int from, vector<vector<int>>&centroid_edges, int& fst_centroid,int depth,vector<int>&ch_nums) {\ndfs(graph, root, from, ch_nums, oks);\n\n\t\tint cent_id = find_centroid(ch_nums[root], graph, root, from, ch_nums, oks);\n\n\t\t\n\t\t//dfs2(graph,cent_id,from,lens[cent_id],0);\n\t\tsort(lens[cent_id].begin(),lens[cent_id].end());\n\n\t\toks[cent_id] = depth;\n\t\tif (from != -1) {\n\t\t\tcentroid_edges[from].push_back(cent_id);\n\t\t}\n\t\telse {\n\t\t\tfst_centroid = cent_id;\n\t\t}\n\t\tfor (auto e : graph[cent_id]) {\n\t\t\tif (e.dst == from)continue;\n\t\t\tif (oks[e.dst]!=-1)continue;\n\t\t\tcent(graph, oks, e.dst, e.src, centroid_edges, fst_centroid,depth+1,ch_nums);\n\t\t}\n\t}\n\npublic:\n\n\n\tvector<vector<long long int>>lens;\n\tvector<vector<int>> centroid_graph;\n\tvector<int>parents;\n\tvector<int>oks;\n\tmap<pair<int,int>,long long int>mp;\n\n\t//fst:root  snd:centroid_graph\n\tvector<vector<int>> get_cent_parent(const Graph&g) {\n\t\tlens.resize(g.size());\n\t\toks=vector<int>(g.size(),-1);\n\t\tint root = -1;\n\t\tcentroid_graph.resize(g.size());\n\t\tparents=vector<int>(g.size(),-1);\n\t\tvector<int>ch_nums(g.size());\n\t\tcent(g, oks, 0, -1, centroid_graph, root,0,ch_nums);\n\n\t\tfor (int i = 0; i < centroid_graph.size(); ++i) {\n\t\t\tfor (auto&& e : centroid_graph[i]) {\n\t\t\t\tparents[e] = i;\n\t\t\t}\n\t\t}\n\t\treturn centroid_graph;\n\t}\n}centroid;\n\n\nvoid addEdge(Graph& g ,int a, int b,long long int c) {\n\tg[a - 1].push_back(Edge{ a - 1,b - 1,c });\n\tg[b - 1].push_back(Edge{ b - 1,a - 1,c });\n}\n\nvector<int>nums;\nvector<int>ls;\nvector<int>rs;\nvector<int>pluss;\nvector<vector<pair<int,int>>>memo;\n\nstring st;\nvoid term(int&a,int&k) {\n\tnums.push_back(0);\n\tls.push_back(0);\n\trs.push_back(0);\n\twhile (a != st.size() && st[a] == '(') {\n\t\tls[k]=true;\n\t\ta++;\n\t}\n\tnums[k]=st[a]-'0';\n\ta++;\n\twhile (a != st.size() && st[a] == ')') {\n\t\trs[k]=true;\n\t\ta++;\n\t}\n\tk++;\n\treturn ;\n}\nvoid expr(int &a) {\n\tint k=0;\n\tterm(a,k);\n\n\twhile (a != st.size()) {\n\t\tpluss.push_back(st[a]=='+');\n\t\ta++;\n\t\tterm(a,k);\n\t}\n}\nvoid init() {\n\tint a=0;\n\texpr(a);\n\tmemo=vector<vector<pair<int,int>>>(nums.size()+1,vector<pair<int,int>>(nums.size()+1,make_pair(1e9,-1e9)));\n}\n\npair<int,int> solve(int l, int r) {\n\tif(memo[l][r].first!=1e9)return memo[l][r];\n\t if(l+1==r)return memo[l][r]=make_pair(nums[l],nums[l]);\n\t if (l + 2 == r) {\n\t\t if(rs[l]||ls[l+1])return memo[l][r]=make_pair(1e8,-1e8);\n\t\t else {\n\t\t\t if (pluss[l]) {\n\t\t\t\t return memo[l][r]=make_pair(nums[l]+nums[l+1],nums[l]+nums[l+1]);\n\t\t\t }\n\t\t\t else {\n\t\t\t\t return memo[l][r]=make_pair(nums[l]-nums[l+1],nums[l]-nums[l+1]);\n\t\t\t }\n\t\t }\n\t }\n\t else {\n\t\t pair<int,int>ans=make_pair(1e8,-1e8);\n\t\t for (int k = l + 1; k < r; ++k) {\n\t\t\t bool ok=true;\n\t\t\tif(ls[k-1])ok=false;\n\t\t\t if(!ok)continue;\n\t\t\t else {\n\t\t\t\t auto lp=solve(l,k),rp=solve(k,r);\n\n\t\t\t\t if (pluss[k - 1]) {\n\t\t\t\t\t auto p=make_pair(lp.first+rp.first,lp.second+rp.second);\n\t\t\t\t\t ans=make_pair(min(ans.first,p.first),max(ans.second,p.second));\n\t\t\t\t }\n\t\t\t\t else {\n\t\t\t\t\t auto p=make_pair(lp.first-rp.second,lp.second-rp.first);\n\t\t\t\t\t ans=make_pair(min(ans.first,p.first),max(ans.second,p.second));\n\t\t\t\t }\n\t\t\t }\n\t\t }\n\t\t return memo[l][r]=ans;\n\t }\n}\n\nint main()\n{\n\tcin>>st;\n\tinit();\n\tauto p=solve(0,nums.size());\n\tcout<<p.second<<endl;\n\treturn 0;\n}\n"
  },
  {
    "language": "C++",
    "code": "#include<bits/stdc++.h>\n\nusing namespace std;\n\nconst int INF = 1 << 29;\nconst pair< int, int > wait = {INF, -INF};\n\nstring S;\npair< int, int > dp[200][200];\n\ninline void merge(pair< int, int > &s, pair< int, int > t)\n{\n  s.first = min(s.first, t.first);\n  s.second = max(s.second, t.second);\n}\n\n\npair< int, int > rec(int l, int r)\n{\n  if(dp[l][r] != wait) return (dp[l][r]);\n  if(l == r) return (dp[l][r] = make_pair(S[l] - '0', S[l] - '0'));\n  if(S[l] == '(' && r - l > 2) merge(dp[l][r], rec(l + 1, r));\n  if(S[r] == ')' && r - l > 2) merge(dp[l][r], rec(l, r - 1));\n  for(int i = l + 1; i < r; i++) {\n    if(S[i] != '+' && S[i] != '-') continue;\n    auto p = rec(l, i - 1), q = rec(i + 1, r);\n    if(S[i] == '+') merge(dp[l][r], {p.first + q.first, p.second + q.second});\n    else merge(dp[l][r], {p.first - q.second, p.second - q.first});\n  }\n  return (dp[l][r]);\n}\n\nint main()\n{\n  fill_n(*dp, 200 * 200, wait);\n  cin >> S;\n  cout << rec(0, S.size() - 1).second << endl;\n}"
  },
  {
    "language": "C++",
    "code": "#include <iostream>\n#include <cctype>\n#include <vector>\nusing namespace std;\n\nint main(){\n    string S;\n    cin>>S;\n    vector<pair<int,int>> D;\n    vector<char> OP;\n    for(int i=0;i<S.size();i++){\n        if(isdigit(S[i])) D.emplace_back(i,S[i]-'0');\n        if(S[i]=='+'||S[i]=='-') OP.push_back(S[i]);\n\n    }\n    int N = D.size();\n    bool R[N],L[N];\n    fill(R,R+N,true);\n    fill(L,L+N,true);\n    R[0]=L[N-1]=false;\n    for(int i=0;i<N;i++){\n        if(D[i].first>0&&S[D[i].first-1]=='(') R[i]=false;\n        if(D[i].first+1<N&&S[D[i].first+1]==')') L[i]=false;\n    }\n    int DP[N][N+1];//[l,r)\n    fill(DP[0],DP[N],-1000000);\n    for(int i=0;i<N;i++){\n        DP[i][i+1]=D[i].second;\n    }\n    for(int len=2;len<=N;len++){\n        for(int l=0;l+len<=N;l++){\n            if(L[l]&&R[l+len-1]){\n                for(int r=l+1;r<l+len;r++){\n                    if(DP[l][r]!=-1000000&&DP[r][l+len]!=-1000000){\n                        DP[l][l+len]=max(DP[l][l+len],DP[l][r]+(OP[r-1]=='+'?1:-1)*DP[r][l+len]);\n                    }\n                }\n            }\n        }\n    }\n    cout<<DP[0][N]<<endl;\n    return 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\nusing namespace std;\n\nint dp[201][201][2];\n\nint main() {\n  string s;\n  cin >> s;\n  for(int i=0; i<s.size(); i++) {\n    for(int j=0; j<s.size(); j++) {\n      dp[i][j][0]=1<<29;\n      dp[i][j][1]=-(1<<29);\n    }\n    if(isdigit(s[i])) dp[i][i][0]=dp[i][i][1]=s[i]-'0';\n  }\n  for(int i=1; i<s.size(); i++) {\n    for(int j=0; j<s.size()-i; j++) {\n      if(s[j]=='(') {\n        dp[j][j+i][0]=min(dp[j][j+i][0],dp[j+1][j+i][0]);\n        dp[j][j+i][1]=max(dp[j][j+i][1],dp[j+1][j+i][1]);\n      }\n      if(s[j+i]==')') {\n        dp[j][j+i][0]=min(dp[j][j+i][0],dp[j][j+i-1][0]);\n        dp[j][j+i][1]=max(dp[j][j+i][1],dp[j][j+i-1][1]);\n      }\n    }\n    for(int j=0; j<s.size()-i; j++) {\n      if(s[j]=='+'||s[j]=='-'||s[j+i]=='+'||s[j+i]=='-') continue;\n      for(int k=j+1; k<=j+i-1; k++) {\n        if((j+2<=k&&s[k-2]=='(')||(k<=j+i-2&&s[k+2]==')')) continue;\n        if(s[k]=='+') {\n          for(int x=0; x<2; x++) {\n            for(int y=0; y<2; y++) {\n              if(abs(dp[j][k-1][x])>=(1<<29)||abs(dp[k+1][j+i][y])>=(1<<29)) continue;\n              dp[j][j+i][0]=min(dp[j][j+i][0],dp[j][k-1][x]+dp[k+1][j+i][y]);\n            }\n          }\n          for(int x=0; x<2; x++) {\n            for(int y=0; y<2; y++) {\n              if(abs(dp[j][k-1][x])>=(1<<29)||abs(dp[k+1][j+i][y])>=(1<<29)) continue;\n              dp[j][j+i][1]=max(dp[j][j+i][1],dp[j][k-1][x]+dp[k+1][j+i][y]);\n            }\n          }\n        } else if(s[k]=='-') {\n          for(int x=0; x<2; x++) {\n            for(int y=0; y<2; y++) {\n              if(abs(dp[j][k-1][x])>=(1<<29)||abs(dp[k+1][j+i][y])>=(1<<29)) continue;\n              dp[j][j+i][0]=min(dp[j][j+i][0],dp[j][k-1][x]-dp[k+1][j+i][y]);\n            }\n          }\n          for(int x=0; x<2; x++) {\n            for(int y=0; y<2; y++) {\n              if(abs(dp[j][k-1][x])>=(1<<29)||abs(dp[k+1][j+i][y])>=(1<<29)) continue;\n              dp[j][j+i][1]=max(dp[j][j+i][1],dp[j][k-1][x]-dp[k+1][j+i][y]);\n            }\n          }\n        }\n      }\n    }\n  }\n  cout << dp[0][s.size()-1][1] << endl;\n  return 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\n#define ALL(v) std::begin(v), std::end(v)\n#define ALLR(v) std::rbegin(v), std::rend(v)\nusing ll = std::int64_t;\nusing ull = std::uint64_t;\nusing pll = std::pair<ll, ll>;\nusing tll = std::tuple<ll, ll, ll>;\ntemplate <typename T> using vec = std::vector<T>;\ntemplate <typename T> using vvec = vec<vec<T>>;\ntemplate <typename T> const T& var_min(const T &t) { return t; }\ntemplate <typename T> const T& var_max(const T &t) { return t; }\ntemplate <typename T, typename... Tail> const T& var_min(const T &t, const Tail&... tail) { return std::min(t, var_min(tail...)); }\ntemplate <typename T, typename... Tail> const T& var_max(const T &t, const Tail&... tail) { return std::max(t, var_max(tail...)); }\ntemplate <typename T, typename... Tail> void chmin(T &t, const Tail&... tail) { t = var_min(t, tail...); }\ntemplate <typename T, typename... Tail> void chmax(T &t, const Tail&... tail) { t = var_max(t, tail...); }\ntemplate <typename T> const T& clamp(const T &t, const T &low, const T &high) { return std::max(low, std::min(high, t)); }\ntemplate <typename T> void chclamp(T &t, const T &low, const T &high) { return t = clamp(t, low, high); }\ntemplate <typename T> T make_v(T init) { return init; }\ntemplate <typename T, typename... Tail> auto make_v(T init, std::size_t s, Tail... tail) { auto v = std::move(make_v(init, tail...)); return vec<decltype(v)>(s, v); }\ntemplate <typename T, std::size_t Head, std::size_t ...Tail> struct multi_dem_array { using type = std::array<typename multi_dem_array<T, Tail...>::type, Head>; };\ntemplate <typename T, std::size_t Head> struct multi_dem_array<T, Head> { using type = std::array<T, Head>; };\ntemplate <typename T, std::size_t ...Args> using mdarray = typename multi_dem_array<T, Args...>::type;\nnamespace init__ { struct InitIO { InitIO() { std::cin.tie(nullptr); std::ios_base::sync_with_stdio(false); std::cout << std::fixed << std::setprecision(30); } } init_io; }\n\nconst std::size_t SIZE = 210;\nstd::string expr;\nll dp[SIZE][SIZE][2];\nbool br[SIZE][2];\nbool calced[SIZE][SIZE][2];\nconst ll inf = 5e15;\n\nll calc(ll l, ll r, bool is_max) {\n    if (calced[l][r][is_max]) return dp[l][r][is_max];\n    calced[l][r][is_max] = true;\n    if (r - l == 1) return dp[l][r][is_max] = expr[l] - '0';\n    ll ret = (is_max ? -inf : inf);\n    for (ll i = l + 1; i < r; i += 2) {\n        if (br[i - 1][0] && 1 < (i - l)) continue;\n        if (br[i + 1][1] && 1 < (r - (i + 1))) continue;\n        bool add = (expr[i] == '+');\n        ll lv = calc(l, i, is_max);\n        ll rv = calc(i + 1, r, (is_max ? add : !add));\n        ll val = lv + (add ? rv : -rv);\n        if (is_max) chmax(ret, val);\n        else chmin(ret, val);\n    }\n    return dp[l][r][is_max] = ret;\n}\n\nint main() {\n    std::string s;\n    std::cin >> s;\n    for (ll i = 0; i < s.size(); i++) {\n        bool lb = false, rb = false;\n        for (; s[i] == '('; i++) lb = true;\n        expr += s[i++];\n        for (; s[i] == ')'; i++) rb = true;\n        br[expr.size() - 1][0] = lb;\n        br[expr.size() - 1][1] = rb;\n        if (i < s.size()) expr += s[i];\n    }\n\n    std::cout << calc(0, expr.size(), true) << std::endl;\n    return 0;\n}\n\n"
  },
  {
    "language": "C++",
    "code": "#include<bits/stdc++.h>\nusing namespace std;\n#define int long long\nstring s;\nint n;\nint used[300][300];\nint dp[300][300];\nint dfs(int p,int d){\n  if(used[p][d]) return dp[p][d];\n  used[p][d]=1;\n  int res=-(1LL<<55LL),op=0;\n  int j;\n  for(j=p-1;j>=0;j--) if(s[j]=='+'||s[j]=='-') break;\n  if(j>=0&&s[j]=='-') op=1;\n  int x=((d+op)%2?-(s[p]-'0'):(s[p]-'0'));\n  for(j=p+1;j<n;j++) if(isdigit(s[j])) break;\n  if(j==n){\n    //cout<<p<<\" \"<<d<<\":\"<<res<<\"/\"<<x<<endl;\n    return dp[p][d]=x;\n  }\n  if(p<1||s[p-1]!='(') res=max(res,dfs(j,d)+x);\n  if(p+1<n&&s[p+1]!=')') res=max(res,dfs(j,d+op)+x);\n  if(d>0&&p-1>=0&&s[p-1]!='(') res=max(res,dfs(j,d-1)+x);\n  //cout<<p<<\" \"<<d<<\":\"<<res<<\"/\"<<x<<endl;\n  return dp[p][d]=res;\n}\nsigned main(){\n  cin>>s;\n  n=s.length();\n  int j;\n  for(j=0;j<n;j++) if(isdigit(s[j])) break;\n  cout<<dfs(j,0)<<endl;\n  return 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include<iostream>\n#include<vector>\n#include<string>\n#include<algorithm>\nusing namespace std;\ntypedef long long ll;\n#define mod  1000000007\n#define inf  1000000007\n#define rep(i,n) for(int i=0;i<(int)(n);i++)\n    \n\nint mx[210][210];\nbool mxflag[210][210];\nint mi[210][210];\nbool miflag[210][210];\nint n;\nstring s;\n\nint mxdfs(int l,int r);\nint midfs(int l,int r);\n\nint mxdfs(int l,int r){\n    if(s[l]=='('||s[r]==')'){\n        int c = 0;\n        for(int i=l;i<=r;i++){\n            if(isdigit(s[i]))c++;\n        }\n        if(c==1){\n            return -inf;\n        }\n    }\n    if(s[l]=='(')return mxdfs(l+1,r); \n    if(s[r]==')')return mxdfs(l,r-1);\n    if(mxflag[l][r])return mx[l][r];\n    if(l==r){\n        return s[l]-'0';\n    }\n    if(s[r-1]=='(')return -inf;\n    int res = -inf;\n    for(int i=l;i<=r;i++){\n        if(s[i]=='-'){\n            res = max(mxdfs(l,i-1)-midfs(i+1,r),res);\n        }else if(s[i]=='+'){\n            res = max(mxdfs(l,i-1)+mxdfs(i+1,r),res);\n        \n        }\n    }\n    mxflag[l][r] = 1;\n    return mx[l][r] = res;\n}\nint midfs(int l,int r){\n    if(s[l]=='('||s[r]==')'){\n        int c = 0;\n        for(int i=l;i<=r;i++){\n            if(isdigit(s[i]))c++;\n        }\n        if(c==1){\n            return inf;\n        }\n    }\n    if(s[l]=='(')return midfs(l+1,r); \n    if(s[r]==')')return midfs(l,r-1);\n    if(miflag[l][r])return mi[l][r];\n    if(l==r){\n        return s[l]-'0';\n    }\n    if(s[l+1]==')')return inf;\n    int res = inf;\n    for(int i=l;i<=r;i++){\n        if(s[i]=='-'){\n            res = min(midfs(l,i-1)-mxdfs(i+1,r),res);\n        }else if(s[i]=='+'){\n            res = min(midfs(l,i-1)+midfs(i+1,r),res);\n        \n        }\n    }\n    miflag[l][r] = 1;\n    return mi[l][r] = res;\n}\n\n\nint main(){\n    cin >> s;\n    n = s.size();\n    cout << mxdfs(0,n-1) << endl;\n    \n    \n    return 0;\n}\n"
  },
  {
    "language": "C++",
    "code": "#include \"bits/stdc++.h\"\nusing namespace std;\n// http://judge.u-aizu.ac.jp/onlinejudge/description.jsp?id=2710&lang=jp\n// reference : http://suikaba.hatenablog.com/entry/2017/05/24/231631\ntypedef pair<int, int> pii;\n#define INF 1<<30\n\npii rec(int l, int r, const string& S,vector<vector<pii>>& dp) {\n\tpii& ret = dp[l][r];\n\t/* Updated */\n\tif (ret != pii(-INF, INF)) return ret; \n\n\tif (l == r) return ret = { S[l] - '0',S[l] - '0' };\n\n\tif (S[l] == '(' && r - l >= 3) {\n\t\tpii x = rec(l + 1, r, S, dp);\n\t\tret.first = max(ret.first, x.first);\n\t\tret.second = min(ret.second, x.second);\n\t}\n\tif (S[r] == ')' && r - l >= 3) {\n\t\tpii x = rec(l, r - 1, S, dp);\n\t\tret.first = max(ret.first, x.first);\n\t\tret.second = min(ret.second, x.second);\n\t}\n\tfor (int m = l + 1; m < r; m++) {\n\t\tif (S[m] == '+' || S[m] == '-') {\n\t\t\tpii x1 = rec(l, m - 1, S, dp);\n\t\t\tpii x2 = rec(m + 1, r, S, dp);\n\t\t\tif (S[m] == '+') {\n\t\t\t\tret.first = max(ret.first, x1.first + x2.first);\n\t\t\t\tret.second = min(ret.second, x1.second + x2.second);\n\t\t\t}\n\t\t\telse {\n\t\t\t\tret.first = max(ret.first, x1.first - x2.second);\n\t\t\t\tret.second = max(ret.second, x1.second - x2.first);\n\t\t\t}\n\t\t}\n\t}\n\treturn ret;\n}\n\nint main(void) {\n\tcin.tie(0); ios::sync_with_stdio(false);\n\tstring S; cin >> S;\n\t/*  dp[l][r] := { maximum value of the interval(l-r) , minimum value of ~ }*/\n\tvector<vector<pii>> dp(S.length() + 1, vector<pii>(S.length() + 1, { -INF,INF }));\n\tcout << rec(0, S.length() - 1, S, dp).first << endl;\n}"
  },
  {
    "language": "C++",
    "code": "#if __has_include(\"../library/Basic/Debug.hpp\")\n\n#include \"../library/Basic/Debug.hpp\"\n\n#else\n\n/* ----- Header Files ----- */\n// IO\n#include <cstdio>\n#include <iomanip>\n#include <ios>\n#include <iostream>\n\n// algorithm\n#include <algorithm>\n#include <cmath>\n#include <numeric>\n\n// container\n#include <vector>\n#include <string>\n#include <tuple>\n#include <complex>\n#include <set>\n#include <map>\n#include <stack>\n#include <queue>\n#include <deque>\n#include <bitset>\n\n// others\n#include <random>\n#include <limits>\n#include <functional>\n#include <ctime>\n#include <cassert>\n#include <cstdint>\n\n\n/* ----- Type Alias ----- */\nusing Bool = bool;\nusing Int = long long int;\nusing Real = long double;\nusing Char = char;\nusing String = std::string;\ntemplate <class T, class U>\nusing Pair = std::pair<T, U>;\ntemplate <class... Ts>\nusing Tuple = std::tuple<Ts...>;\n\ntemplate <class T>\nusing Vector = std::vector<T>;\ntemplate <size_t N>\nusing Bits = std::bitset<N>;\ntemplate <class T>\nusing Queue = std::queue<T>;\ntemplate <class T>\nusing Stack = std::stack<T>;\ntemplate <class T>\nusing Deque = std::deque<T>;\n\ntemplate <class T>\nusing MaxHeap = std::priority_queue<T>;\ntemplate <class T>\nusing MinHeap = std::priority_queue<T, std::vector<T>, std::greater<T>>;\ntemplate <class T>\nusing Set = std::set<T>;\ntemplate <class T, class U>\nusing Map = std::map<T, U>;\n\ntemplate <class T, class... Us>\nusing Func = std::function<T(Us...)>;\n\ntemplate <class T>\nT genv(T v) { return v; }\n\ntemplate <class T, class... Ts>\nauto genv(size_t l, Ts... ts) {\n    return Vector<decltype(genv<T>(ts...))>(l, genv<T>(ts...));\n}\n\ntemplate <class Cost = Int>\nstruct Edge {\n    Int src, dst;\n    Cost cost;\n    Edge(Int src = -1, Int dst = -1, Cost cost = 1)\n        : src(src), dst(dst), cost(cost){};\n\n    bool operator<(const Edge<Cost>& e) const { return this->cost < e.cost; }\n    bool operator>(const Edge<Cost>& e) const { return this->cost > e.cost; }\n};\n\ntemplate <class Cost = Int>\nusing Edges = Vector<Edge<Cost>>;\ntemplate <class Cost = Int>\nusing Graph = Vector<Vector<Edge<Cost>>>;\n\n#endif\n\n/* ----- Misc ----- */\nvoid fastio() {\n    std::ios::sync_with_stdio(false);\n    std::cin.tie(nullptr);\n}\n\nstruct Fout {\n    Int precision;\n    Fout(Int precision) : precision(precision) {}\n};\nstd::ostream& operator<<(std::ostream& os, const Fout& fio) {\n    os << std::fixed << std::setprecision(fio.precision);\n    return os;\n}\n\n\n/* ----- Constants ----- */\nconstexpr Int INF = std::numeric_limits<Int>::max() / 3;\n// constexpr Int MOD = 1000000007;\n// constexpr Real PI = acos(-1);\n// constexpr Real EPS = 1e-10;\n// std::mt19937 mt(int(std::time(nullptr)));\n\nint main() {\n    String s;\n    std::cin >> s;\n    Int n = s.length();\n\n    std::function<Int(Int, Int)> maxdfs;\n\n    std::function<Int(Int, Int)> mindfs = [&](Int l, Int r) {\n        static Vector<Vector<Bool>> visited(n, Vector<Bool>(n, false));\n        static Vector<Vector<Int>> dp(n, Vector<Int>(n));\n\n        Int& ret = dp[l][r];\n        if (visited[l][r]) return ret;\n\n        visited[l][r] = true;\n        ret = INF;\n\n        // 単項\n        if (l == r) {\n            assert(std::isdigit(s[l]));\n            ret = s[l] - '0';\n        }\n\n        // 複項\n        // 両端に適当に括弧をつける\n        while (s[l] == '(') ++l;\n        while (s[r] == ')') --r;\n        for (Int i = l; i <= r; ++i) {\n            if (s[i] == '+') {\n                Int a = mindfs(l, i - 1), b = mindfs(i + 1, r);\n                ret = std::min(ret, a + b);\n            } else if (s[i] == '-') {\n                Int a = mindfs(l, i - 1), b = maxdfs(i + 1, r);\n                ret = std::min(ret, a - b);\n            }\n        }\n        return ret;\n    };\n\n    maxdfs = [&](Int l, Int r) {\n        static Vector<Vector<Bool>> visited(n, Vector<Bool>(n, false));\n        static Vector<Vector<Int>> dp(n, Vector<Int>(n));\n\n        Int& ret = dp[l][r];\n        if (visited[l][r]) return ret;\n\n        visited[l][r] = true;\n        ret = -INF;\n\n        // 単項\n        if (l == r) {\n            assert(std::isdigit(s[l]));\n            ret = s[l] - '0';\n        }\n\n        // 複項\n        // 両端に適当に括弧をつける\n        while (s[l] == '(') ++l;\n        while (s[r] == ')') --r;\n        for (Int i = l; i <= r; ++i) {\n            if (s[i] == '+') {\n                Int a = maxdfs(l, i - 1), b = maxdfs(i + 1, r);\n                ret = std::max(ret, a + b);\n            } else if (s[i] == '-') {\n                Int a = maxdfs(l, i - 1), b = mindfs(i + 1, r);\n                ret = std::max(ret, a - b);\n            }\n        }\n        return ret;\n    };\n\n    std::cout << maxdfs(0, s.length() - 1) << std::endl;\n    return 0;\n}\n\n"
  },
  {
    "language": "C++",
    "code": "#include<bits/stdc++.h>\nusing namespace std;\n#define int long long\nstring s;\nint n;\nint used[300][300];\nint dp[300][300];\nint dfs(int p,int d){\n  if(used[p][d]) return dp[p][d];\n  used[p][d]=1;\n  int res=-(1LL<<55LL),op=0;\n  int j;\n  for(j=p-1;j>=0;j--) if(s[j]=='+'||s[j]=='-') break;\n  if(j>=0&&s[j]=='-') op=1;\n  int x=((d+op)%2?-(s[p]-'0'):(s[p]-'0'));\n  for(j=p+1;j<n;j++) if(isdigit(s[j])) break;\n  if(j==n){\n    //cout<<p<<\" \"<<d<<\":\"<<res<<\"/\"<<x<<endl;\n    return dp[p][d]=x;\n  }\n  if(p<1||s[p-1]!='(') res=max(res,dfs(j,d)+x);\n  if(op&&p+1<n&&s[p+1]!=')') res=max(res,dfs(j,d+1)+x);\n  if(d>0&&p-1>=0&&s[p-1]!='(') res=max(res,dfs(j,d-1)+x);\n  //cout<<p<<\" \"<<d<<\":\"<<res<<\"/\"<<x<<endl;\n  return dp[p][d]=res;\n}\nsigned main(){\n  cin>>s;\n  n=s.length();\n  int j;\n  for(j=0;j<n;j++) if(isdigit(s[j])) break;\n  cout<<dfs(j,0)<<endl;\n  return 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include <iostream>\n#include <cstring>\n#include <algorithm>\n#include <set>\n\nusing namespace std;\n\n#define MIN first\n#define MAX second\nconstexpr int MAX_S = 252;\nconstexpr int INF = (1 << 29);\n\nstring S;\npair<int, int> mem[MAX_S][MAX_S];\n\nvoid init(int N)\n{\n    for (int i = 0; i < N; i++) {\n        for (int j = 0; j < N; j++) {\n            mem[i][j] = {+INF, -INF};\n        }\n    }\n}\n\nvoid update_max(int& l, int r)\n{   \n    if (l < r) l = r;\n}\n\nvoid update_min(int& l, int r)\n{\n    if (l > r) l = r;\n}\n\n// テ・ツ個コテゥツ鳴禿」ツ?ョpair(MIN, MAX)\npair<int, int> rec(int L, int R)\n{\n    pair<int, int>& res = mem[L][R];\n    if (res != make_pair(+INF, -INF)) {\n        return res;\n    }\n    \n    if (R - L == 0) {\n        int v = S[L] - '0';\n        return (res = make_pair(v, v));\n    }\n\n    if (S[L] == '(' && R - L > 2) {\n        update_min(res.MIN, rec(L + 1, R).MIN);\n        update_max(res.MAX, rec(L + 1, R).MAX);\n        return res;\n    }\n\n    if (S[R] == ')' && R - L > 2) {\n        update_min(res.MIN, rec(L, R - 1).MIN);\n        update_max(res.MAX, rec(L, R - 1).MAX);\n        return res;\n    }\n    \n    for (int i = L + 1; i <= R - 1; i++) {\n        char c = S[i];   \n        if (c != '+' && c != '-') continue;                 \n        \n        auto res_l = rec(L, i - 1); // Left\n        auto res_r = rec(i + 1, R); // Right\n\n        if (c == '+') {            \n            update_min(res.MIN, res_l.MIN + res_r.MIN);\n            update_max(res.MAX, res_l.MAX + res_r.MAX);            \n        }\n        if (c == '-') {           \n            update_min(res.MIN, res_l.MIN - res_r.MAX);\n            update_max(res.MAX, res_l.MAX - res_r.MIN);\n        }\n    } \n    return res;\n}\n\nvoid solve()\n{\n    int N = S.size();\n    init(N);\n    cout << rec(0, N - 1).MAX << endl;    \n}\n\nint main()\n{\n    cin >> S;\n    solve();    \n    return 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\nusing namespace std;\n#define int long long\n#define REP(i, n) for (int i = 0; i < (n); i++)\n#define fi first\n#define se second\nusing ii = pair<int, int>;\n\nconstexpr int HOGE = 1e17 + 100;\nint exp1(const string& s, int& i, int r);\nint exp2(const string& s, int& i, int r);\nint exp1(const string& s, int& i, int r) {\n    int acc = exp2(s, i, r);\n    while (i < r) {\n        if (s[i] == '+') {\n            acc += exp2(s, ++i, r);\n        } else if (s[i] == '-') {\n            acc -= exp2(s, ++i, r);\n        } else\n            return acc;\n        // assert(0);\n    }\n    return acc;\n}\nint exp2(const string& s, int& i, int r) {\n    if (s[i] == '(') {\n        int ret = exp1(s, ++i, r);\n        assert(s[i++] == ')');\n        return ret;\n    }\n    if (isdigit(s[i])) return s[i++] - '0';\n    // assert(0);\n    return exp1(s, i, r);\n}\nbool is_valid(const string& s, int i, int r) {\n    int acc = 0;\n    for (int j = i; j < r; j++) {\n        if (s[j] == '(') acc++;\n        if (s[j] == ')') acc--;\n        if (acc < 0) return false;\n    }\n    return acc == 0;\n}\nsigned main() {\n    ios::sync_with_stdio(false);\n    cin.tie(0);\n\n    string s;\n    cin >> s;\n    vector<int> num, idx, op_idx;\n    op_idx.push_back(-1);\n    vector<char> ops;\n    REP(i, s.size()) {\n        if (isdigit(s[i])) {\n            num.push_back(s[i] - '0');\n            idx.push_back(i);\n        }\n        if (s[i] == '+' || s[i] == '-') {\n            ops.push_back(s[i]);\n            op_idx.push_back(i);\n        }\n    }\n    op_idx.push_back(s.size());\n\n    auto valid = [&](int i) { return 0 <= i && i < s.size(); };\n\n    constexpr ii DMY = {1e17, 1e17};\n    int m = num.size();\n    vector<vector<ii>> dp(m, vector<ii>(m, DMY));\n    function<ii(int, int)> dfs = [&](int i, int j) {\n        if (dp[i][j] != DMY) return dp[i][j];\n        if (i == j) return dp[i][j] = {num[i], num[i]};\n        int mi = 1e18, ma = -1e18;\n        int l_idx = idx[i];\n        int r_idx = idx[j];\n        if (is_valid(s, l_idx, r_idx + 1)) {\n            mi = ma = exp1(s, l_idx, r_idx + 1);\n        }\n        for (int k = i; k < j; k++) {\n            if (k != i && valid(idx[k] - 1) && s[idx[k] - 1] == '(') continue;\n            if (k != j - 1 && valid(idx[k + 1] + 1) && s[idx[k + 1] + 1] == ')') continue;\n            ii l = dfs(i, k);\n            ii r = dfs(k + 1, j);\n            if (ops[k] == '+') {\n                mi = min(mi, l.fi + r.fi);\n                ma = max(ma, l.se + r.se);\n            } else {\n                // assert(ops[k] == '-');\n                mi = min(mi, l.fi - r.se);\n                ma = max(ma, l.se - r.fi);\n            }\n        }\n        return dp[i][j] = {mi, ma};\n    };\n    dfs(0, m - 1);\n    cout << dp[0][m - 1].se << endl;\n}\n\n"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\nusing namespace std;\n\nint calc(string &s,int &i){\n  int res=0;\n  while(1){\n    if(isdigit(s[i]))res=s[i++]-'0';\n    else if(s[i]=='('){res=calc(s,++i),i++;}\n    else if(s[i]=='+')res+=calc(s,++i);\n    else if(s[i]=='-')res-=calc(s,++i);\n    else break;\n  }\n  return res;\n}\n\nunordered_map<string,int> mem[2];\nint dfs(string s,int f){\n  if(mem[f].count(s))return mem[f][s];\n\n  int j=0,res=calc(s,j),n=s.size(),d=-1;\n  for(int i=0;i<n;i++) d+=(s[i]=='+'||s[i]=='-');\n  \n  for(int i=0,c=0,cnt=0;i<n;i++,cnt++,d--){\n    while(1){\n      while(s[i]=='('||s[i]==')')c+=(s[i]=='(')-(s[i]==')'),i++;\n      if(i>=n||s[i]=='+'||s[i]=='-') break;\n      i++;\n    }\n    if(i>=n||(cnt&&s[i-2]=='(')||(d&&s[i+2]==')'))continue;\n    string a=s.substr(0,i),b=s.substr(i+1,n-i-1);\n    int t=c,ch=s[i];\n    while(t--)a+=')',b='('+b;\n    int mxa=dfs(a,0),mna=dfs(a,1);\n    int mxb=dfs(b,0),mnb=dfs(b,1);\n    if(f==0&&ch=='+') res=max(res, mxa+mxb);\n    if(f==0&&ch=='-') res=max(res, mxa-mnb);\n    if(f==1&&ch=='+') res=min(res, mna+mnb);\n    if(f==1&&ch=='-') res=min(res, mna-mxb);\n  }\n  return mem[f][s]=res;\n}\n\nint main(){\n  string S;\n  cin>>S;\n  cout <<dfs(S,0)<<endl;\n  return 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\nusing namespace std;\n\nint cal(string &s,int &i){\n  int res=0;\n  while(1){\n    if(isdigit(s[i]))res=s[i++]-'0';\n    else if(s[i]=='('){res=cal(s,++i);}\n    else if(s[i]=='+')res+=cal(s,++i);\n    else if(s[i]=='-')res-=cal(s,++i);\n    else break;\n  }\n  return res;\n}\n\nint calc(string s){\n  vector<int> v;\n  for(int i=0;i<s.size();i++){\n    int n = (int)v.size()-1;\n    if(s[i]=='+')v.push_back(0);\n    if(s[i]=='-')v.push_back(1);\n    if(s[i]=='(')v.push_back(0),v.push_back(0);\n    if(s[i]==')'){\n      if(v.size()<3)continue;\n      v[n-2]+=v[n-1]? -v[n]:v[n];\n      v.pop_back(),v.pop_back();\n    }\n\n    if(isdigit(s[i])){\n      int num=s[i]-'0';\n      if(v.size()>=2){\n\tv[n-1]+=v[n]? -num:num;\n\tv.pop_back();\n      }\n      else v.push_back(num);\n    }\n  }\n  return v[0];\n}\n\nmap<string,int> mem[2];\nint dfs(string s,int f){\n  if(s.size()==1) return s[0]-'0';\n  if(mem[f].count(s))return mem[f][s];\n\n  int j=0;  \n  int n=s.size(),res=cal(s,j),d=-1;\n  for(int i=0;i<n;i++) d+=(s[i]=='+'||s[i]=='-');\n  \n  for(int i=0,c=0,cnt=0;i<n;i++,cnt++,d--){\n    while(i<n){\n      while(s[i]=='('||s[i]==')')c+=(s[i]=='(')-(s[i]==')'),i++;\n      if(s[i]=='+'||s[i]=='-') break;\n      i++;\n    }\n    if(i>=n||(cnt&&s[i-2]=='(')||(d&&s[i+2]==')'))continue;\n    string a=s.substr(0,i),b=s.substr(i+1,n-i-1);\n    int t=c,ch=s[i];\n    while(t--)a+=')',b='('+b;\n    int mxa=dfs(a,0),mna=dfs(a,1);\n    int mxb=dfs(b,0),mnb=dfs(b,1);\n    if(f==0&&ch=='+') res=max(res, mxa+mxb);\n    if(f==0&&ch=='-') res=max(res, mxa-mnb);\n    if(f==1&&ch=='+') res=min(res, mna+mnb);\n    if(f==1&&ch=='-') res=min(res, mna-mxb);\n  }\n  return mem[f][s]=res;\n}\n\nint main(){\n  string S;\n  cin>>S;\n  cout <<dfs(S,0)<<endl;\n  return 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\n#define int long long\nusing namespace std;\n\nmap<string,int> memo;\n\nint dfs(string s, int flag){\n  \n  if( memo.count(s) ) return memo[s];\n  \n  int cnt = 0;\n  \n  for(int i=0;i<(int)s.size();i++){\n    if( '0' <= s[i] && s[i] <= '9' ) cnt++;\n  }\n  \n  if( cnt == 1 ){\n    if( (int)s.size() == 1 ) return memo[s] = s[0] - '0';\n    else return memo[s] = flag == 0 ? -1e9 : 1e9;\n  }\n  \n  while( s[0] == '(' ) s = s.substr( 1 );\n  \n  while( s[(int)s.size()-1] == ')' ) s = s.substr( 0, (int)s.size() - 1 );\n  \n  int res = flag == 0 ? -1e9 : 1e9;\n  \n  for(int i=0;i<(int)s.size();i++){\n    \n    if( s[i] == '+' ){\n      int A = dfs( s.substr( 0, i ), flag );\n      int B = dfs( s.substr( i + 1 ), flag );\n      if( flag == 0 ) res = max( res, A + B );\n      else res = min( res, A + B );\n    }\n    \n    if( s[i] == '-' ){\n      int A = dfs( s.substr( 0, i ), flag );\n      int B = dfs( s.substr( i + 1 ), !flag );\n      if( flag == 0 ) res = max( res, A - B );\n      else res = min( res, A - B );\n    }\n    \n  }\n  \n  return memo[s] = res;\n}\n\nsigned main(){\n  \n  string s;\n  cin>>s;\n  \n  cout<<dfs(s,0)<<endl;\n  \n  return 0;\n}\n\n"
  },
  {
    "language": "C++",
    "code": "#include \"bits/stdc++.h\"\nusing namespace std;\n// http://judge.u-aizu.ac.jp/onlinejudge/description.jsp?id=2710&lang=jp\n// reference : http://suikaba.hatenablog.com/entry/2017/05/24/231631\ntypedef pair<int, int> pii;\n#define INF 1<<25\n\npii rec(int l, int r, const string& S,vector<vector<pii>>& dp) {\n\tpii& ret = dp[l][r];\n\t/* Updated */\n\tif (ret != pii{ -INF, INF }) return ret;\n\n\tif (l == r) {\n\t\treturn ret = { S[l] - '0',S[l] - '0' };\n\t}\n\n\tif (S[l] == '(' && r - l >= 3) {\n\t\tpii x = rec(l + 1, r, S, dp);\n\t\tret.first = max(ret.first, x.first);\n\t\tret.second = min(ret.second, x.second);\n\t}\n\tif (S[r] == ')' && r - l >= 3) {\n\t\tpii x = rec(l, r - 1, S, dp);\n\t\tret.first = max(ret.first, x.first);\n\t\tret.second = min(ret.second, x.second);\n\t}\n\tfor (int m = l + 1; m < r; m++) {\n\t\tif (S[m] == '+' || S[m] == '-') {\n\t\t\tpii x1 = rec(l, m - 1, S, dp);\n\t\t\tpii x2 = rec(m + 1, r, S, dp);\n\t\t\tif (S[m] == '+') {\n\t\t\t\tret.first = max(ret.first, x1.first + x2.first);\n\t\t\t\tret.second = min(ret.second, x1.second + x2.second);\n\t\t\t}\n\t\t\telse {\n\t\t\t\tret.first = max(ret.first, x1.first - x2.second);\n\t\t\t\tret.second = min(ret.second, x1.second - x2.first);\n\t\t\t}\n\t\t}\n\t}\n\treturn ret;\n}\n\nint main(void) {\n\tcin.tie(0); ios::sync_with_stdio(false);\n\tstring S; cin >> S;\n\t/*  dp[l][r] := { maximum value of the interval(l-r) , minimum value of ~ }*/\n\tvector<vector<pii>> dp(S.length(), vector<pii>(S.length(), { -INF,INF }));\n\tcout << rec(0, S.length() - 1, S, dp).first << endl;\n}"
  },
  {
    "language": "C++",
    "code": "#include <iostream>\n#include <cstdio>\n#include <string>\n#include <algorithm>\n#include <utility>\nusing namespace std;\ntypedef pair<int, int> pii;\nvoid chmax(int &a, int b) {a = max(a, b);}\nvoid chmin(int &a, int b) {a = min(a, b);}\nconst int INF = 1 << 28;\nstring s;\nint N, dp_max[210][210], dp_min[210][210];\n\nvoid solve(int l, int r) {\n    if(dp_max[l][r] != -INF) return;\n    // 数字\n    if(r - l == 1 && isdigit(s[l])) {\n        dp_max[l][r] = dp_min[l][r] = s[l] - '0';\n    }\n    // 括弧をとっぱらって再帰的に\n    // このとき、括弧含め幅が 3 以下 (つまり実質 2 以下) だと\n    // 数式になりえないので飛ばす\n    if(s[l] == '(' && r-l > 3) {\n        solve(l+1, r);\n        chmax(dp_max[l][r], dp_max[l+1][r]);\n        chmin(dp_min[l][r], dp_min[l+1][r]);\n    }\n    if(s[r-1] == ')' && r-l > 3) {\n        solve(l, r-1);\n        chmax(dp_max[l][r], dp_max[l][r-1]);\n        chmin(dp_min[l][r], dp_min[l][r-1]);\n    }\n    for(int k=l; k<r; k++) {\n        if(s[k] != '+' && s[k] != '-') continue;\n        solve(l, k);\n        solve(k+1, r);\n        if(dp_max[l][k] == -INF || dp_max[k+1][r] == -INF) continue;\n        if(s[k] == '+') {\n            chmax(dp_max[l][r], dp_max[l][k] + dp_max[k+1][r]);\n            chmin(dp_min[l][r], dp_min[l][k] + dp_min[k+1][r]);\n        }\n        else {\n            chmax(dp_max[l][r], dp_max[l][k] - dp_min[k+1][r]);\n            chmin(dp_min[l][r], dp_min[l][k] - dp_max[k+1][r]);\n        }\n    }\n}\n\nint main() {\n    cin >> s;\n    N = s.length();\n    for(int i=0; i<N; i++) {\n        fill(dp_max[i], dp_max[i] + N + 1, -INF);\n        fill(dp_min[i], dp_min[i] + N + 1, INF);\n    }\n\n    solve(0, N);\n    /*\n    for(int i=0; i<N; i++) {\n        for(int j=i+1; j<=N; j++) {\n            if(dp_max[i][j] == -INF) continue;\n            printf(\"%s\\n\", s.c_str());\n            for(int k=0; k<N; k++) {\n                if(i <= k && k < j) printf(\"=\");\n                else printf(\" \");\n            }\n            printf(\" -> %d\\n\", dp_max[i][j]);\n        }\n    }\n    */\n    printf(\"%d\\n\", dp_max[0][N]);\n    return 0;\n}\n"
  },
  {
    "language": "C++",
    "code": "#include <iostream>\n#define REP(i, a, n) for(int i = ((int) a); i < ((int) n); i++)\n#define INF 100000000\nusing namespace std;\ntypedef long long ll;\n\nstring S;\nll dp[300][300];\n\nll number(int l, int r) {\n  ll ret = 0;\n  REP(i, l, r) {\n    if('0' <= S[i] && S[i] <= '9') ret = ret * 10 + (S[i] - '0');\n    else return -1;\n  }\n  return ret;\n}\n\nll dfs(int l, int r) {\n  ll ret;\n\n  if(dp[l][r] >= 0) ret = dp[l][r];\n  else {\n    ll n = number(l, r);\n    if(n >= 0) ret = n;\n    else {\n      ret = -INF;\n      REP(i, l, r) {\n        if(S[i] != '+' && S[i] != '-') continue;\n        int nl = l, nr = r;\n        while(1) {\n          ll n1 = dfs(nl, i);\n          ll n2 = dfs(i + 1, nr);\n          if(n1 != -INF && n2 != -INF) {\n            if(S[i] == '+') ret = max(ret, n1 + n2);\n            if(S[i] == '-') ret = max(ret, n1 - n2);\n          }\n          if(S[nl] != '(' && S[nr - 1] != ')') break;\n          if(S[nl] == '(') nl++;\n          if(S[nr - 1] == ')') nr--;\n        }\n      }\n    }\n  }\n\n  return dp[l][r] = ret;\n}\n\nint main(void) {\n  cin >> S;\n\n  REP(i, 0, 201) REP(j, 0, 201) dp[i][j] = -INF;\n  cout << dfs(0, S.size()) << endl;\n\n  return 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include <iostream>\n#include <string>\n#include <vector>\n#include <algorithm>\n#include <cmath>\n#include <cstdio>\n#include <functional>\n#include <numeric>\n#include <stack>\n#include <queue>\n#include <map>\n#include <set>\n#include <utility>\n#include <sstream>\n#include <complex>\n#include <fstream>\n#include <bitset>\n#include <time.h>\n\nusing namespace std;\n\ntypedef long long ll;\ntypedef pair<ll, ll> P;\ntypedef vector<ll> V;\ntypedef complex<double> Point;\n\n#define PI acos(-1.0)\n#define EPS 1e-10\nconst ll INF = (1LL << 31) - 1;\nconst ll MOD = 1e9 + 7;\n\n#define FOR(i,a,b) for(int i=(a);i<(b);i++)\n#define rep(i,N) for(int i=0;i<(N);i++)\n#define ALL(s) (s).begin(),(s).end()\n#define EQ(a,b) (abs((a)-(b))<EPS)\n#define EQV(a,b) ( EQ((a).real(), (b).real()) && EQ((a).imag(), (b).imag()) )\n#define fi first\n#define se second\n#define N_SIZE (1LL << 20)\n#define NIL -1\n#define MAX_N 100100 * 3\n\nstring s;\nvector<int> pos;\n\nll digit(string& s, int& pos);\n//ll term(& s, int& pos);\nll expr(string& s, int& pos);\nll factor(string& s, int& pos);\n\nbool is_digit(char c) {\n\treturn c >= '0'&&c <= '9';\n}\n\nll digit(string& s, int& pos) {\n\treturn s[pos++] - '0';\n}\n\nll factor(string& s, int& pos) {\n\tif (isdigit(s[pos]))return digit(s, pos);\n\n\tpos++; \n\tll ret = expr(s, pos);\n\tpos++; \n\treturn ret;\n}\n\nll expr(string& s, int& pos) {\n\tll res = factor(s, pos);\n\twhile (s[pos] == '+' || s[pos] == '-') {\n\t\tif (s[pos] == '+') {\n\t\t\tpos++;\n\t\t\tres += factor(s, pos);\n\t\t}\n\t\telse if (s[pos] == '-') {\n\t\t\tpos++;\n\t\t\tres -= factor(s, pos);\n\t\t}\n\t}\n\treturn res;\n}\n\nint main() {\n\tcin >> s;\n\trep(i, s.size()) {\n\t\tif (is_digit(s[i]))pos.push_back(i);\n\t}\n\tint p = 0;\n\tll ans = expr(s, p);\n\t//cout << ans << endl;\n\trep(i, s.size()) {\n\t\tFOR(j, i + 1, s.size()) {\n\t\t\tif (is_digit(s[i]) && is_digit(s[j])) {\n\t\t\t\tp = 0;\n\t\t\t\tstring t = s.substr(0, i) + \"(\" + s.substr(i, j - i + 1) + \")\" + s.substr(j + 1);\n\t\t\t\tbool f = 0;\n\t\t\t\trep(k, t.size() - 2) {\n\t\t\t\t\tif (t[k] == '('&&t[k + 2] == ')')f = 1;\n\t\t\t\t}\n\t\t\t\tif (f)continue;\n\t\t\t\t//cout << t << endl;\n\t\t\t\tll num = expr(t, p);\n\t\t\t\t//cout << num << endl;\n\t\t\t\tif (ans < num) {\n\t\t\t\t\tans = num;\n\t\t\t\t\ts = t;\n\t\t\t\t}\n\t\t\t}\n\t\t\t//cout << \"!!\" << ans << endl;\n\t\t}\n\t}\n\tcout << ans << endl;\n}"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\n#define int long long\nusing namespace std;\n\ntypedef pair<int,int> P;\ntypedef pair<P,int> P1;\n\nmap<P1,int> memo;\nstring s;\n\nint dfs(int l, int r, int flag){\n  \n  if( memo.count(P1(P(l,r),flag)) ) return memo[P1(P(l,r),flag)];\n  \n  int L = l, R = r;\n  \n  int cnt = 0;\n  \n  for(int i=L;i<=R;i++){\n    if( '0' <= s[i] && s[i] <= '9' ) cnt++;\n  }\n  \n  if( cnt == 1 ){\n    if( R - L + 1 == 1 ) return memo[P1(P(L,R),flag)] = s[L] - '0';\n    else return memo[P1(P(L,R),flag)] = flag == 0 ? -1e9 : 1e9;\n  }\n  \n  while( s[L] == '(' ) L++;\n  \n  while( s[R] == ')' ) R--;\n  \n  int res = flag == 0 ? -1e9 : 1e9;\n  \n  for(int i=L;i<=R;i++){\n    \n    if( s[i] == '+' ){\n      int A = dfs( L, i - 1, flag );\n      int B = dfs( i + 1, R, flag );\n      if( flag == 0 ) res = max( res, A + B );\n      else res = min( res, A + B );\n    }\n    \n    if( s[i] == '-' ){\n      int A = dfs( L, i - 1, flag );\n      int B = dfs( i + 1, R, !flag );\n      if( flag == 0 ) res = max( res, A - B );\n      else res = min( res, A - B );\n    }\n    \n  }\n  \n  return memo[P1(P(l,r),flag)] = res;\n}\n\nsigned main(){\n  \n  cin>>s;\n  \n  cout<<dfs(0,(int)s.size()-1,0)<<endl;\n  \n  return 0;\n}\n\n"
  },
  {
    "language": "C++",
    "code": "#include <iostream>\n#include <cstring>\n#include <algorithm>\n#include <cassert>\n\nusing namespace std;\n\n#define MIN first\n#define MAX second\nconstexpr int MAX_N = 252;\nconstexpr int INF = (1 << 29);\n\nstring S;\nint mem_min[MAX_N][MAX_N];\nint mem_max[MAX_N][MAX_N];    \n\nvoid init(int N)\n{\n    for (int i = 0; i < N; i++) {\n        for (int j = 0; j < N; j++) {\n            mem_min[i][j] = +INF;\n            mem_max[i][j] = -INF;\n        }\n    }\n}\n\nvoid update_max(int& l, int r)\n{   \n    if (l < r) l = r;\n}\n\nvoid update_min(int& l, int r)\n{\n    if (l > r) l = r;\n}\n\n// テ・ツ個コテゥツ鳴禿」ツ?ョpair(MIN, MAX)\npair<int, int> rec(int L, int R)\n{\n    pair<int, int> res = {mem_min[L][R], mem_max[L][R]};\n    if (res != make_pair(+INF, -INF)) {\n        return res;\n    }\n    \n    if (R - L == 0) {\n        assert(isdigit(S[L]));\n        int v = S[L] - '0';\n        return make_pair(v, v);\n    }\n       \n    if (S[L] == '(') {\n        update_min(res.MIN, rec(L + 1, R).MIN);\n        update_max(res.MAX, rec(L + 1, R).MAX);\n        return make_pair(mem_min[L][R], mem_max[L][R]) = res;\n    }\n\n    if (S[R] == ')') {\n        update_min(res.MIN, rec(L, R - 1).MIN);\n        update_max(res.MAX, rec(L, R - 1).MAX);\n        return make_pair(mem_min[L][R], mem_max[L][R]) = res;\n    }\n    \n    int lp = -1;\n    for (int i = L + 1; i <= R; i++) {\n        char c = S[i];\n        if (c == '(') lp = i;        \n        if (c != '+' && c != '-') continue;        \n        if (lp != -1 && (i - lp <= 2)) continue;\n        \n        auto res_l = rec(L, i - 1); // Left\n        auto res_r = rec(i + 1, R); // Right\n        \n        if (c == '+') {            \n            update_min(res.MIN, res_l.MIN + res_r.MIN);\n            update_max(res.MAX, res_l.MAX + res_r.MAX);            \n        }\n        if (c == '-') {           \n            update_min(res.MIN, res_l.MIN - res_r.MAX);\n            update_max(res.MAX, res_l.MAX - res_r.MIN);\n        }\n    }\n    return make_pair(mem_min[L][R], mem_max[L][R]) = res;\n}\n\nvoid solve()\n{\n    int N = S.size();\n    init(N);\n    cout << rec(0, N - 1).MAX << endl;    \n}\n\nint main()\n{\n    cin >> S;\n    solve();    \n    return 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\n#define int long long\nusing namespace std;\n\ntypedef pair<string,int> P;\n\nmap<P,int> memo;\n\nint dfs(string s, int flag){\n  \n  if( memo.count(P(s,flag)) ) return memo[P(s,flag)];\n\n  int cnt = 0;\n  \n  for(int i=0;i<(int)s.size();i++){\n    if( '0' <= s[i] && s[i] <= '9' ) cnt++;\n  }\n  \n  if( cnt == 1 ){\n    if( (int)s.size() == 1 ) return memo[P(s,flag)] = s[0] - '0';\n    else return memo[P(s,flag)] = flag == 0 ? -1e9 : 1e9;\n  }\n  \n  while( s[0] == '(' ) s = s.substr( 1 );\n  \n  while( s[(int)s.size()-1] == ')' ) s = s.substr( 0, (int)s.size() - 1 );\n  \n  int res = flag == 0 ? -1e9 : 1e9;\n  \n  for(int i=0;i<(int)s.size();i++){\n    \n    if( s[i] == '+' ){\n      int A = dfs( s.substr( 0, i ), flag );\n      int B = dfs( s.substr( i + 1 ), flag );\n      if( flag == 0 ) res = max( res, A + B );\n      else res = min( res, A + B );\n    }\n    \n    if( s[i] == '-' ){\n      int A = dfs( s.substr( 0, i ), flag );\n      int B = dfs( s.substr( i + 1 ), !flag );\n      if( flag == 0 ) res = max( res, A - B );\n      else res = min( res, A - B );\n    }\n    \n  }\n  \n  return memo[P(s,flag)] = res;\n}\n\nsigned main(){\n  \n  string s;\n  cin>>s;\n  \n  cout<<dfs(s,0)<<endl;\n  \n  return 0;\n}\n\n"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\nusing namespace std;\ntypedef pair<int,int>P;\n#define F first\n#define S second\nint INF=1e9;\nstring s;\nP dp[222][222],init=P(INF,-INF);\n\nP dfs(int l,int r){\n\tif(l==r)return P(s[l]-'0',s[l]-'0');\n\tif(dp[l][r]!=init)return dp[l][r];\n\tP res=init;\n\tfor(int i=l+1;i<r;i++){\n\t\tif(!(s[i]=='-'||s[i]=='+'))continue;\n\t\tP a=dfs(l,i-1);\n\t\tP b=dfs(i+1,r);\n\t\tif(s[i]=='-'){\n\t\t\tres.F=min(res.F,a.F-b.F);\n\t\t\tres.S=max(res.S,a.S-b.F);\n\t\t}\n\t\tif(s[i]=='+'){\n\t\t\tres.F=min(res.F,a.F+b.F);\n\t\t\tres.S=max(res.S,a.S+b.F);\n\t\t}\n\t}\n\tif(s[l]=='('&&r-l>2) res=dfs(l+1,r);\n\tif(s[r]==')'&&r-l>2) res=dfs(l,r-1);\n\treturn dp[l][r]=res;\n}\n\nint main(){\n\tcin>>s;\n\tfor(int i=0;i<222;i++)\n\t\tfor(int j=0;j<222;j++)dp[i][j]=init;\n\tcout<<dfs(0,s.size()-1).S<<endl;\n}\n"
  },
  {
    "language": "C++",
    "code": "#include<bits/stdc++.h>\nusing namespace std;\n#define INF (1e8)\n#define MAX 205\nint n;\nchar s[MAX];\n\nint dpA[MAX][MAX];\nint dpB[MAX][MAX];\nbool flgA[MAX][MAX];\nbool flgB[MAX][MAX];\n\nint solveA(int,int);\nint solveB(int,int);\n\nint main(){\n  scanf(\"%s\",s);\n  n=strlen(s);\n  int ans=solveA(0,n);\n  assert( abs(ans) < 1e6 );\n  printf(\"%d\\n\",ans);\n  return 0;\n}\n\nint solveA(int l,int r){\n  if(flgA[l][r])return dpA[l][r];\n  flgA[l][r]=true;\n  int res=-INF,cnt=0,num=0;\n  for(int i=l;i<r;i++){\n    if(s[i]=='+'){\n      if(l<=i-3&&'0'<=s[i-1]&&s[i-1]<='9'&&s[i-2]=='(')continue;\n      if(i+3<r&&'0'<=s[i+1]&&s[i+1]<='9'&&s[i+2]==')')continue;\n      res=max(res, solveA(l,i)+solveA(i+1,r));\n    }else if(s[i]=='-'){\n      if(l<=i-3&&'0'<=s[i-1]&&s[i-1]<='9'&&s[i-2]=='(')continue;\n      if(i+3<r&&'0'<=s[i+1]&&s[i+1]<='9'&&s[i+2]==')')continue;\n      res=max(res, solveA(l,i)-solveB(i+1,r));\n    }else if('0'<=s[i]&&s[i]<='9'){\n      cnt++;\n      num=s[i]-'0';\n    }\n  }\n  if(cnt==1)res=num;\n  return dpA[l][r]=res;\n}\n\nint solveB(int l,int r){\n  if(flgB[l][r])return dpB[l][r];\n  flgB[l][r]=true;\n  int res=INF,cnt=0,num=0;\n  for(int i=l;i<r;i++){\n    if(s[i]=='+'){\n      if(l<=i-3&&'0'<=s[i-1]&&s[i-1]<='9'&&s[i-2]=='(')continue;\n      if(i+3<r&&'0'<=s[i+1]&&s[i+1]<='9'&&s[i+2]==')')continue;\n      res=min(res, solveB(l,i)+solveB(i+1,r));\n    }else if(s[i]=='-'){\n      if(l<=i-3&&'0'<=s[i-1]&&s[i-1]<='9'&&s[i-2]=='(')continue;\n      if(i+3<r&&'0'<=s[i+1]&&s[i+1]<='9'&&s[i+2]==')')continue;\n      res=min(res, solveB(l,i)-solveA(i+1,r));\n    }else if('0'<=s[i]&&s[i]<='9'){\n      cnt++;\n      num=s[i]-'0';\n    }\n  }\n  if(cnt==1)res=num;\n  return dpB[l][r]=res;\n}"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\n#define INF (1e9)\nusing namespace std;\n\n\nint calc(string s){\n  vector<int> v;\n  for(int i=0;i<s.size();i++){\n    int n = (int)v.size()-1;\n    if(s[i]=='+')v.push_back(0);\n    if(s[i]=='-')v.push_back(1);\n    if(s[i]=='(')v.push_back(0),v.push_back(0);\n    if(s[i]==')'){\n      if(v.size()<3)continue;\n      v[n-2]+=v[n-1]? -v[n]:v[n];\n      v.pop_back(),v.pop_back();\n    }\n\n    if(isdigit(s[i])){\n      int num=s[i]-'0';\n      if(v.size()>=2){\n\tv[n-1]+=v[n]? -num:num;\n\tv.pop_back();\n      }\n      else v.push_back(num);\n    }\n  }\n  return v[0];\n}\nbool check(string s){\n  if(s[0]!='(')return 0;\n  int i=0;\n  while(s[i]!=')')i++;\n  return i==(int)s.size()-1;\n}\n\nmap<string,int> mem[2];\nint dfs(string s,int f){\n  if(s.size()==1) return s[0]-'0';\n  if(mem[f].count(s))return mem[f][s];\n  if(check(s)) return mem[f][s]=dfs(s.substr(1,s.size()-2),f);\n  int n=s.size(),res=calc(s);\n  for(int i=0,c=0;i<n;i++){\n    while(i<n){\n      while(s[i]=='('||s[i]==')')c+=(s[i]=='(')-(s[i]==')'),i++;\n      if(s[i]=='+'||s[i]=='-') break;\n      i++;\n    }\n    if(i>=n)break;\n    if((i-2>=0&&s[i-2]=='('))continue;\n    string a=s.substr(0,i),b=s.substr(i+1,n-i-1);\n    int t=c,ch=s[i];\n    while(t--)a+=')',b='('+b;\n    int mxa=dfs(a,0),mna=dfs(a,1);\n    int mxb=dfs(b,0),mnb=dfs(b,1);\n    if(f==0&&ch=='+') res=max(res, mxa+mxb);\n    if(f==0&&ch=='-') res=max(res, mxa-mnb);\n    if(f==1&&ch=='+') res=min(res, mna+mnb);\n    if(f==1&&ch=='-') res=min(res, mna-mxb);\n  }\n  return mem[f][s]=res;\n}\n\n\n\nint main(){\n  string S;\n  cin>>S;\n  cout <<dfs(S,0)<<endl;\n  return 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\nusing namespace std;\n#define int long long\n#define REP(i, n) for (int i = 0; i < (n); i++)\n#define fi first\n#define se second\nusing ii = pair<int, int>;\n\nint exp1(const string& s, int& i, int r);\nint exp2(const string& s, int& i, int r);\nint exp1(const string& s, int& i, int r) {\n    int acc = exp2(s, i, r);\n    while (i < r && s[i] != ')') {\n        if (s[i] == '+') {\n            acc += exp2(s, ++i, r);\n        } else if (s[i] == '-') {\n            acc -= exp2(s, ++i, r);\n        } else assert(0);\n    }\n    return acc;\n}\nint exp2(const string& s, int& i, int r) {\n    if (s[i] == '(') {\n        int ret = exp1(s, ++i, r);\n        assert(s[i++] == ')');\n        return ret;\n    }\n    if (isdigit(s[i])) return s[i++] - '0';\n    assert(0);\n}\nbool is_valid(const string& s, int i, int r) {\n    int acc = 0;\n    for (int j = i; j < r; j++) {\n        if (s[j] == '(') acc++;\n        if (s[j] == ')') acc--;\n        if (acc < 0) return false;\n    }\n    return acc == 0;\n}\nsigned main() {\n    ios::sync_with_stdio(false);\n    cin.tie(0);\n\n    string s;\n    cin >> s;\n    vector<int> num, idx, op_idx;\n    op_idx.push_back(-1);\n    vector<char> ops;\n    REP(i, s.size()) {\n        if (isdigit(s[i])) {\n            num.push_back(s[i] - '0');\n            idx.push_back(i);\n        }\n        if (s[i] == '+' || s[i] == '-') {\n            ops.push_back(s[i]);\n            op_idx.push_back(i);\n        }\n    }\n    op_idx.push_back(s.size());\n\n    auto valid = [&](int i) { return 0 <= i && i < s.size(); };\n\n    constexpr ii DMY = {1e17, 1e17};\n    int m = num.size();\n    vector<vector<ii>> dp(m, vector<ii>(m, DMY));\n    function<ii(int, int)> dfs = [&](int i, int j) {\n        if (dp[i][j] != DMY) return dp[i][j];\n        if (i == j) return dp[i][j] = {num[i], num[i]};\n        int mi = 1e18, ma = -1e18;\n        int l_idx = idx[i];\n        int r_idx = idx[j];\n        if (is_valid(s, l_idx, r_idx + 1)) {\n            mi = ma = exp1(s, l_idx, r_idx + 1);\n        }\n        for (int k = i; k < j; k++) {\n            if (k != i && valid(idx[k] - 1) && s[idx[k] - 1] == '(') continue;\n            if (k != j - 1 && valid(idx[k + 1] + 1) && s[idx[k + 1] + 1] == ')') continue;\n            ii l = dfs(i, k);\n            ii r = dfs(k + 1, j);\n            if (ops[k] == '+') {\n                mi = min(mi, l.fi + r.fi);\n                ma = max(ma, l.se + r.se);\n            } else {\n                assert(ops[k] == '-');\n                mi = min(mi, l.fi - r.se);\n                ma = max(ma, l.se - r.fi);\n            }\n        }\n        return dp[i][j] = {mi, ma};\n    };\n    dfs(0, m - 1);\n    cout << dp[0][m - 1].se << endl;\n}\n"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\nusing namespace std;\n\nint cal(string &s,int &i){\n  int res=0;\n  while(1){\n    if(isdigit(s[i]))res=s[i++]-'0';\n    else if(s[i]=='('){res=cal(s,++i),i++;}\n    else if(s[i]=='+')res+=cal(s,++i);\n    else if(s[i]=='-')res-=cal(s,++i);\n    else break;\n  }\n  return res;\n}\n\nint calc(string s){\n  vector<int> v;\n  for(int i=0;i<s.size();i++){\n    int n = (int)v.size()-1;\n    if(s[i]=='+')v.push_back(0);\n    if(s[i]=='-')v.push_back(1);\n    if(s[i]=='(')v.push_back(0),v.push_back(0);\n    if(s[i]==')'){\n      if(v.size()<3)continue;\n      v[n-2]+=v[n-1]? -v[n]:v[n];\n      v.pop_back(),v.pop_back();\n    }\n\n    if(isdigit(s[i])){\n      int num=s[i]-'0';\n      if(v.size()>=2){\n\tv[n-1]+=v[n]? -num:num;\n\tv.pop_back();\n      }\n      else v.push_back(num);\n    }\n  }\n  return v[0];\n}\n\nmap<string,int> mem[2];\nint dfs(string s,int f){\n  if(s.size()==1) return s[0]-'0';\n  if(mem[f].count(s))return mem[f][s];\n\n  int j=0;  \n  int n=s.size(),res=cal(s,j),d=-1;\n  for(int i=0;i<n;i++) d+=(s[i]=='+'||s[i]=='-');\n  \n  for(int i=0,c=0,cnt=0;i<n;i++,cnt++,d--){\n    while(i<n){\n      while(s[i]=='('||s[i]==')')c+=(s[i]=='(')-(s[i]==')'),i++;\n      if(s[i]=='+'||s[i]=='-') break;\n      i++;\n    }\n    if(i>=n||(cnt&&s[i-2]=='(')||(d&&s[i+2]==')'))continue;\n    string a=s.substr(0,i),b=s.substr(i+1,n-i-1);\n    int t=c,ch=s[i];\n    while(t--)a+=')',b='('+b;\n    int mxa=dfs(a,0),mna=dfs(a,1);\n    int mxb=dfs(b,0),mnb=dfs(b,1);\n    if(f==0&&ch=='+') res=max(res, mxa+mxb);\n    if(f==0&&ch=='-') res=max(res, mxa-mnb);\n    if(f==1&&ch=='+') res=min(res, mna+mnb);\n    if(f==1&&ch=='-') res=min(res, mna-mxb);\n  }\n  return mem[f][s]=res;\n}\n\nint main(){\n  string S;\n  cin>>S;\n  cout <<dfs(S,0)<<endl;\n  return 0;\n}"
  },
  {
    "language": "C++",
    "code": "#define  _CRT_SECURE_NO_WARNINGS\n#define _USE_MATH_DEFINES\n\n#pragma comment (linker, \"/STACK:526000000\")\n\n#include \"bits/stdc++.h\"\n\nusing namespace std;\ntypedef string::const_iterator State;\n#define eps 1e-11L\n#define MAX_MOD 1000000007LL\n#define GYAKU 500000004LL\n\n#define MOD 998244353LL\n#define seg_size 262144 * 4LL\n#define pb push_back\n#define mp make_pair\ntypedef long long ll;\n#define REP(a,b) for(long long (a) = 0;(a) < (b);++(a))\n#define ALL(x) (x).begin(),(x).end()\n\nvoid init() {\n    iostream::sync_with_stdio(false);\n    cout << fixed << setprecision(20);\n}\n\n\n#define int ll\n\nunsigned long xor128() {\n    static unsigned long x = 123456789, y = 362436069, z = 521288629, w = 88675123;\n    unsigned long t = (x ^ (x << 11));\n    x = y; y = z; z = w;\n    return (w = (w ^ (w >> 19)) ^ (t ^ (t >> 8)));\n}\n\nint dp_max[300][300];\nint dp_min[300][300];\nint val[300];\nint rest[300];\nvoid solve() {\n    string s;\n    cin >> s;\n    int now = 0;\n    REP(i, s.length()) {\n        if (s[i] == '(') {\n            rest[now] |= 1;\n        }\n        else if (s[i] == ')') {\n            rest[now - 1] |= 2;\n        }\n        else if (s[i] == '+') {\n            val[now] = -1;\n            now++;\n        }\n        else if (s[i] == '-') {\n            val[now] = -2;\n            now++;\n        }\n        else {\n            val[now] = s[i] - '0';\n            now++;\n        }\n    }\n    REP(i, now + 1) {\n        REP(q, now + 1) {\n            dp_min[i][q] = 1e18;\n            dp_max[i][q] = -1e18;\n        }\n    }\n    REP(i, now) {\n        if (val[i] >= 0) {\n            dp_max[i][i] = val[i];\n            dp_min[i][i] = val[i];\n        }\n    }\n    for (int len = 3; len <= now; len += 2) {\n        for (int q = 0; q < now - len + 1; ++q) {\n            if (rest[q] == 2) continue;\n            if (rest[q + len - 1] == 1) continue;\n            for (int j = 1; j < len - 1; ++j) {\n                if (val[q + j] == -1) {\n                    dp_max[q][q + len - 1] = max(dp_max[q][q + len - 1], dp_max[q][q + j - 1] + dp_max[q + j + 1][q + len - 1]);\n                    dp_min[q][q + len - 1] = min(dp_min[q][q + len - 1], dp_min[q][q + j - 1] + dp_min[q + j + 1][q + len - 1]);\n                }\n                if (val[q + j] == -2) {\n                    dp_max[q][q + len - 1] = max(dp_max[q][q + len - 1], dp_max[q][q + j - 1] - dp_min[q + j + 1][q + len - 1]);\n                    dp_min[q][q + len - 1] = min(dp_min[q][q + len - 1], dp_min[q][q + j - 1] - dp_max[q + j + 1][q + len - 1]);\n                }\n            }\n        }\n    }\n    cout << dp_max[0][now - 1] << endl;\n}\n\n#undef int\nint main() {\n    init();\n    solve();\n}\n"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\nusing namespace std;\n#define INF 1000000\ntypedef string::const_iterator State;\nint expression(State &begin);\n\nint data[201];\nint kakko[201];\nint size;\n\nint number(State &begin){\n\tint ret=0;\n\twhile(isdigit(*begin)){\n\t\tret*=10;\n\t\tret+=*begin-'0';\n\t\tbegin++;\n\t}\n\tdata[size++]=ret;\n\treturn ret;\n}\n\nint factor(State &begin){\n\tif(*begin=='('){\n\t\tbegin++;\n\t\tkakko[size]++;\n\t\tint ret=expression(begin);\n\t\tkakko[size]--;\n\t\tbegin++;\n\t}else{\n\t\treturn number(begin);\n\t}\n}\n\nint expression(State &begin){\n\tint ret=factor(begin);\n\twhile(1){\n\t\tif(*begin=='+'){\n\t\t\tbegin++;\n\t\t\tdata[size++]=-1;\n\t\t\tret+=expression(begin);\n\t\t}else if(*begin=='-'){\n\t\t\tbegin++;\n\t\t\tdata[size++]=-2;\n\t\t\tret-=expression(begin);\n\t\t}else{\n\t\t\tbreak;\n\t\t}\n\t}\n\treturn ret;\n}\n\nint dp[201][201][2];\n\nint solve(int f,int t,int type){\n\tif(type==0 && dp[f][t][type]!=-INF)return dp[f][t][type];\n\tif(type==1 && dp[f][t][type]!=INF)return dp[f][t][type];\n\tif(t-f==1){\n\t\treturn data[f];\n\t}\n\tif(t-f==3){\n\t\tif(data[f+1]==-1){\n\t\t\treturn data[f]+data[f+2];\n\t\t}\n\t\tif(data[f+1]==-2){\n\t\t\treturn data[f]-data[f+2];\n\t\t}\n\t}\n\tint res=-INF;\n\tif(type==1)res=INF;\n\tfor(int i=f+1;i<t;i+=2){\n\t\tif(data[i]==-2 && (i-1==f || kakko[i-1]<=0) && (kakko[i+1]>=0 || i+1==t-1)){\n\t\t\tif(type==0)res=max(solve(f,i,0)-solve(i+1,t,1),res);\n\t\t\tif(type==1)res=min(solve(f,i,1)-solve(i+1,t,0),res);\n\t\t}\n\t\tif(data[i]==-1 && (i-1==f || kakko[i-1]<=0) && (kakko[i+1]>=0 || i+1==t-1)){\n\t\t\tif(type==0)res=max(solve(f,i,0)+solve(i+1,t,0),res);\n\t\t\tif(type==1)res=min(solve(f,i,1)+solve(i+1,t,1),res);\n\t\t}\n\t}\n\treturn res;\n}\n\nint main(void){\n\tstring str;\n\tcin >> str;\n\tState begin=str.begin();\n\texpression(begin);\n\tfor(int i=0;i<=200;i++){\n\t\tfor(int j=0;j<=200;j++){\n\t\t\tdp[i][j][0]=-INF;\n\t\t\tdp[i][j][1]=INF;\n\t\t}\n\t}\n\tprintf(\"%d\\n\",solve(0,size,0));\n\treturn 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include <iostream>\n#include <cctype>\n#include <vector>\nusing namespace std;\n\nint main(){\n    string S;\n    cin>>S;\n    vector<pair<int,int>> D;\n    vector<char> OP;\n    for(int i=0;i<S.size();i++){\n        if(isdigit(S[i])) D.emplace_back(i,S[i]-'0');\n        if(S[i]=='+'||S[i]=='-') OP.push_back(S[i]);\n\n    }\n    int N = D.size();\n    bool R[N],L[N];\n    fill(R,R+N,true);\n    fill(L,L+N,true);\n    R[0]=L[N-1]=false;\n    for(int i=0;i<N;i++){\n        if(D[i].first>0&&S[D[i].first-1]=='(') R[i]=false;\n        if(D[i].first+1<N&&S[D[i].first+1]==')') L[i]=false;\n    }\n    int DP_MIN[N][N+1],DP_MAX[N][N+1];//[l,r)\n    fill(DP_MIN[0],DP_MIN[N],1000000);\n    fill(DP_MAX[0],DP_MAX[N],-1000000);\n    for(int i=0;i<N;i++){\n        DP_MAX[i][i+1]=DP_MIN[i][i+1]=D[i].second;\n    }\n    for(int len=2;len<=N;len++){\n        for(int l=0;l+len<=N;l++){\n            if(L[l]&&R[l+len-1]){\n                for(int r=l+1;r<l+len;r++){\n                    if(DP_MAX[l][r]!=-1000000&&DP_MAX[r][l+len]!=-1000000){\n                        DP_MAX[l][l+len]=max(DP_MAX[l][l+len],DP_MAX[l][r]+(OP[r-1]=='+'?DP_MAX[r][l+len]:-DP_MIN[r][l+len]));\n                        DP_MIN[l][l+len]=min(DP_MIN[l][l+len],DP_MIN[l][r]+(OP[r-1]=='+'?DP_MIN[r][l+len]:-DP_MAX[r][l+len]));\n                    }\n                }\n            }\n            // cout<<\"l: \"<<l<<\" r: \"<<l+len<<\" \"<<DP[l][l+len]<<endl;\n        }\n    }\n    cout<<DP_MAX[0][N]<<endl;\n    return 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\n\nusing namespace std;\n\n#define rep(i,n) for(int i=0; i<n; i++)\n#define reep(i,a,b) for(int i=a; i<b; i++)\n#define INF 0x3f3f3f3f\n\nstring s;\nint mn[300][300];\nint mx[300][300];\n\nint MAX(int l, int r);\nint MIN(int l, int r);\n\n\nint MAX(int l, int r){\n\tif(mx[l][r]!=-INF) return mx[l][r];\n\tint &ret = mx[l][r];\n\twhile(s[l] == '('){\n\t\tl++;\n\t}\n\twhile(s[r] == ')'){\n\t\tr--;\n\t}\n\tif(l==r&&isdigit(s[l])){\n\t\treturn ret = s[l]-'0';\n\t}\n\tint lim = l-1;\n\tint cnt = 0;\n\tfor(int i=r; i>=l; i--){\n\t\tcnt += isdigit(s[i]);\n\t\tif(cnt==2){\n\t\t\tlim = i;\n\t\t\tbreak;\n\t\t}\n\t}\n\tcnt = 0;\n\treep(i,l,r+1){\n\t\tcnt += isdigit(s[i]);\n\t\tif(s[i]=='+'){\n\t\t\t// if(s[i-1]==')'&&cnt<2) continue;\n\t\t\t// if(s[i+1]=='('&&lim<i) continue;\n\t\t\tif(l==i-2&&s[i-1]==')'&&isdigit(s[i-2])) continue;\n\t\t\tif(i+2==r&&s[i+1]=='('&&isdigit(s[i+2])) continue;\n\t\t\tret = max(ret, MAX(l,i-1)+MAX(i+1, r));\n\t\t}\n\t\tif(s[i]=='-'){\n\t\t\t// if(s[i-1]==')'&&cnt<2) continue;\n\t\t\t// if(s[i+1]=='('&&lim<i) continue;\n\t\t\tif(l==i-2&&s[i-1]==')'&&isdigit(s[i-2])) continue;\n\t\t\tif(i+2==r&&s[i+1]=='('&&isdigit(s[i+2])) continue;\n\t\t\tret = max(ret, MAX(l,i-1)-MIN(i+1, r));\n\t\t}\n\t}\n\t// cout<<\"MAX \"<<s.substr(l,r-l+1)<<\" \"<<ret<<endl;\n\treturn ret;\n}\n\nint MIN(int l, int r){\n\tif(mn[l][r]!=INF) return mn[l][r];\n\tint &ret = mn[l][r];\n\twhile(s[l] == '('){\n\t\tl++;\n\t}\n\twhile(s[r] == ')'){\n\t\tr--;\n\t}\n\tif(l==r&&isdigit(s[l])){\n\t\treturn ret = s[l]-'0';\n\t}\n\tint lim = l-1;\n\tint cnt = 0;\n\tfor(int i=r; i>=l; i--){\n\t\tcnt += isdigit(s[i]);\n\t\tif(cnt==2){\n\t\t\tlim = i;\n\t\t\tbreak;\n\t\t}\n\t}\n\tcnt = 0;\n\treep(i,l,r+1){\n\t\tcnt += isdigit(s[i]);\n\t\tif(s[i]=='+'){\n\t\t\t// if(s[i-1]==')'&&cnt<2) continue;\n\t\t\t// if(s[i+1]=='('&&lim<i) continue;\n\t\t\tif(l==i-2&&s[i-1]==')'&&isdigit(s[i-2])) continue;\n\t\t\tif(i+2==r&&s[i+1]=='('&&isdigit(s[i+2])) continue;\n\t\t\tret = min(ret, MIN(l,i-1)+MIN(i+1, r));\n\t\t}\n\t\tif(s[i]=='-'){\n\t\t\t// if(s[i-1]==')'&&cnt<2) continue;\n\t\t\t// if(s[i+1]=='('&&lim<i) continue;\n\t\t\tif(l==i-2&&s[i-1]==')'&&isdigit(s[i-2])) continue;\n\t\t\tif(i+2==r&&s[i+1]=='('&&isdigit(s[i+2])) continue;\n\t\t\tret = min(ret, MIN(l,i-1)-MAX(i+1, r));\n\t\t}\n\t}\n\t// cout<<\"MIN \"<<s.substr(l,r-l+1)<<\" \"<<ret<<endl;\n\treturn ret;\n}\n\nint main(){\n\tcin>>s;\n\trep(i,300){\n\t\trep(j,300){\n\t\t\tmx[i][j] = -INF;\n\t\t\tmn[i][j] = INF;\n\t\t}\n\t}\n\tcout<<MAX(0,s.size()-1)<<endl;\n}"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\n#define INF (1e9)\nusing namespace std;\n\n\nint calc(string s){\n  vector<int> v;\n  for(int i=0;i<s.size();i++){\n    int n = (int)v.size()-1;\n    if(s[i]=='+')v.push_back(0);\n    if(s[i]=='-')v.push_back(1);\n    if(s[i]=='(')v.push_back(0),v.push_back(0);\n    if(s[i]==')'){\n      if(v.size()<3)continue;\n      v[n-2]+=v[n-1]? -v[n]:v[n];\n      v.pop_back(),v.pop_back();\n    }\n\n    if(isdigit(s[i])){\n      int num=s[i]-'0';\n      if(v.size()>=2){\n\tv[n-1]+=v[n]? -num:num;\n\tv.pop_back();\n      }\n      else v.push_back(num);\n    }\n  }\n  return v[0];\n}\n\nmap<string,int> mem[2];\nint dfs(string s,int f){\n  if(s.size()==1) return s[0]-'0';\n  if(mem[f].count(s))return mem[f][s];\n  int n=s.size(),res=calc(s);\n  for(int i=0,c=0;i<n;i++){\n    while(i<n){\n      while(s[i]=='('||s[i]==')')c+=(s[i]=='(')-(s[i]==')'),i++;\n      if(s[i]=='+'||s[i]=='-') break;\n      i++;\n    }\n    if(i>=n)break;\n    if((i-2>=0&&s[i-2]=='('))continue;\n    string a=s.substr(0,i),b=s.substr(i+1,n-i-1);\n    int t=c,ch=s[i];\n    while(t--)a+=')',b='('+b;\n    int mxa=dfs(a,0),mna=dfs(a,1);\n    int mxb=dfs(b,0),mnb=dfs(b,1);\n    if(f==0&&ch=='+') res=max(res, mxa+mxb);\n    if(f==0&&ch=='-') res=max(res, mxa-mnb);\n    if(f==1&&ch=='+') res=min(res, mna+mnb);\n    if(f==1&&ch=='-') res=min(res, mna-mxb);\n  }\n  return mem[f][s]=res;\n}\n\n\n\nbool check(string s){\n  if(s[0]!='(')return 0;\n  int i=0;\n  while(s[i]!=')')i++;\n  return i==(int)s.size()-1;\n}\n\nint main(){\n  string S;\n  cin>>S;\n  while(check(S))S=S.substr(1,S.size()-2);\n  cout <<dfs(S,0)<<endl;\n  return 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\n#define INF (1e9)\nusing namespace std;\n\n\nint calc(string s){\n  vector<int> v;\n  for(int i=0;i<s.size();i++){\n    int n = (int)v.size()-1;\n    if(s[i]=='+')v.push_back(0);\n    if(s[i]=='-')v.push_back(1);\n    if(s[i]=='(')v.push_back(0),v.push_back(0);\n    if(s[i]==')'){\n      if(v.size()<3)continue;\n      v[n-2]+=v[n-1]? -v[n]:v[n];\n      v.pop_back(),v.pop_back();\n    }\n\n    if(isdigit(s[i])){\n      int num=s[i]-'0';\n      if(v.size()>=2){\n\tv[n-1]+=v[n]? -num:num;\n\tv.pop_back();\n      }\n      else v.push_back(num);\n    }\n  }\n  return v[0];\n}\n\nmap<string,int> mem[2];\nint dfs(string s,int f){\n  if(s.size()==1) return s[0]-'0';\n  if(mem[f].count(s))return mem[f][s];\n  int n=s.size(),res=calc(s);\n  for(int i=0,c=0;i<n;i++){\n    while(i<n){\n      while(s[i]=='('||s[i]==')')c+=(s[i]=='(')-(s[i]==')'),i++;\n      if(s[i]=='+'||s[i]=='-') break;\n      i++;\n    }\n    if(i>=n)break;\n    if((i-2>=0&&s[i-2]=='('))continue;\n    string a=s.substr(0,i),b=s.substr(i+1,n-i-1);\n    int t=c,ch=s[i];\n    while(t--)a+=')',b='('+b;\n    int mxa=dfs(a,0),mna=dfs(a,1);\n    int mxb=dfs(b,0),mnb=dfs(b,1);\n    if(f==0&&ch=='+') res=max(res, mxa+mxb);\n    if(f==0&&ch=='-') res=max(res, mxa-mnb);\n    if(f==1&&ch=='+') res=min(res, mna+mnb);\n    if(f==1&&ch=='-') res=min(res, mna-mxb);\n  }\n  return mem[f][s]=res;\n}\n\n\n\nint main(){\n  string S;\n  cin>>S;\n  cout <<dfs(S,0)<<endl;\n  return 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include<iostream>\n#include<vector>\n#include<string>\n#include<algorithm>\n#include<map>\n#include<set>\n#include<cstring>\n#include<queue>\n#include<stack>\n#include<cstdio>\n#include<iomanip>\n#define loop(i,a,b) for(int i=a;i<b;i++)\n#define rep(i,a) loop(i,0,a)\n#define pb push_back\n#define all(in) in.begin(),in.end()\n#define shosu(x) fixed<<setprecision(x)\n#define show1d(v) rep(i,v.size())cout<<\" \"<<v[i];cout<<endl;\n#define show2d(v) rep(i,v.size()){rep(j,v[i].size())cout<<\" \"<<v[i][j];cout<<endl;}cout<<endl;\nusing namespace std;\ntypedef long long ll;\ntypedef int Def;\ntypedef pair<Def,Def> pii;\ntypedef vector<Def> vi;\ntypedef vector<vi> vvi;\ntypedef vector<pii> vp;\ntypedef vector<string> vs;\nDef inf = sizeof(Def)==sizeof(ll)?2e18:1e9+10;\nint n,co;\nvvi w;\nstring s,t;\nint dp[110][110][2];//min max\nint dfs(int l,int r,int c){\n\tif(c&&dp[l][r][c]!=-inf)return dp[l][r][c];\n\tif(!c&&dp[l][r][c]!=inf)return dp[l][r][c];\n\t\n\tint out=inf;\n\tif(c)out=-inf;\n\tif(l==r)return t[l]-'0';\n\tif(w[l][1]||w[r][0])return inf;\n\tloop(i,l,r){\n\t\tint a,b;\n\t\tif(c){\n\t\t\ta=dfs(l,i,1);\n\t\t\tif(w[i+1][2]==0)b=dfs(i+1,r,1);\n\t\t\telse b=-dfs(i+1,r,0);\n\t\t}else{\n\t\t\ta=dfs(l,i,0);\n\t\t\tif(w[i+1][2]==0)b=dfs(i+1,r,0);\n\t\t\telse b=-dfs(i+1,r,1);\n\t\t}\n\t\tif(abs(a)==inf||abs(b)==inf)continue;\n\t\tif(c)out=max(out,a+b);\n\t\telse out=min(out,a+b);\n\t}\n//\tcout<<l<<\" \"<<r<<\" \"<<c<<\" \"<<out<<endl;\n\treturn dp[l][r][c]=out;\n}\nint main(){\n\tcin>>s;\n\tn=s.size();\n\tint co=0;\n\trep(i,n)if(isdigit(s[i]))co++;\n\tw=vvi(co,vi(3));\n\tt=\"\";\n\trep(i,s.size()){\n\t\tif(s[i]=='('){\n\t\t\tw[t.size()][0]=true;\n\t\t}else if(s[i]==')'){\n\t\t\tw[t.size()-1][1]=true;\n\t\t}else if(isdigit(s[i])){\n\t\t\tt+=s[i];\n\t\t}else if(s[i]=='-'){\n\t\t\tw[t.size()][2]=true;\n\t\t}\n\t}\n\trep(i,110)rep(j,110){\n\t\tdp[i][j][0]=inf;\n\t\tdp[i][j][1]=-inf;\n\t}\n//\tcout<<t<<endl;\n//\tshow2d(w);\n\tcout<<dfs(0,co-1,1)<<endl;\n}\n\n\n\n\n\n\n\n\n\n\n\n"
  },
  {
    "language": "C++",
    "code": "//#define __USE_MINGW_ANSI_STDIO 0\n#include <bits/stdc++.h>\n\nusing namespace std;\ntypedef long long ll;\ntypedef vector<int> VI;\ntypedef vector<VI> VVI;\ntypedef vector<ll> VL;\ntypedef vector<VL> VVL;\ntypedef pair<int, int> PII;\n\n#define FOR(i, a, n) for (ll i = (ll)a; i < (ll)n; ++i)\n#define REP(i, n) FOR(i, 0, n)\n#define ALL(x) x.begin(), x.end()\n#define IN(a, b, x) (a<=x&&x<b)\n#define MP make_pair\n#define PB push_back\n#define MOD 1000000007\n#define INF (1LL<<30)\n#define LLINF (1LL<<60)\n#define PI 3.14159265359\n#define EPS 1e-12\n//#define int ll\n\nint dx[] = {0, 1, 0, -1}, dy[] = {1, 0, -1, 0};\n\nPII dp[210][210];\nstring s;\n\nPII dfs(int l, int r) {\n\tif(dp[l][r] != PII{-INF, INF}) return dp[l][r];\n\tif(l == r) return dp[l][r] = MP(s[l]-'0', s[l]-'0');\n\tif(s[l] == '(' && r-l>=3) {\n\t\tPII p = dfs(l+1, r);\n\t\tdp[l][r].first = max(dp[l][r].first, p.first);\n\t\tdp[l][r].second = min(dp[l][r].second, p.second);\n\t}\n\tif(s[r] == ')' && r-l>=3) {\n\t\tPII p = dfs(l, r-1);\n\t\tdp[l][r].first = max(dp[l][r].first, p.first);\n\t\tdp[l][r].second = min(dp[l][r].second, p.second);\n\t}\n\tFOR(i, l+1, r) {\n\t\tif(s[i] == '+') {\n\t\t\tPII a = dfs(l, i-1);\n\t\t\tPII b = dfs(i+1, r);\n\t\t\tdp[l][r].first = max(dp[l][r].first, a.first + b.first);\n\t\t\tdp[l][r].second = min(dp[l][r].second, a.second + b.second);\n\t\t} else if(s[i] == '-') {\n\t\t\tPII a = dfs(l, i-1);\n\t\t\tPII b = dfs(i+1, r);\n\t\t\tdp[l][r].first = max(dp[l][r].first, a.first - b.second);\n\t\t\tdp[l][r].second = min(dp[l][r].second, a.second - b.first);\n\t\t}\n\t}\n\n\treturn dp[l][r];\n}\n\nsigned main(void)\n{\n\tcin >> s;\n\tREP(i, s.size()) REP(j, s.size()) dp[i][j] = MP(-INF, INF);\n\tcout << dfs(0, s.size()-1).first << endl;\n\n\treturn 0;\n}"
  },
  {
    "language": "C++",
    "code": "#define __USE_MINGW_ANSI_STDIO 0\n#include <bits/stdc++.h>\n\nusing namespace std;\nusing ll = long long;\n#define int ll\nusing VI = vector<int>;\nusing VVI = vector<VI>;\nusing PII = pair<int, int>;\n\n#define FOR(i, a, n) for (ll i = (ll)a; i < (ll)n; ++i)\n#define REP(i, n) FOR(i, 0, n)\n#define ALL(x) x.begin(), x.end()\n#define PB push_back\n\nconst ll LLINF = (1LL<<60);\nconst int INF = (1LL<<30);\nconst int MOD = 1000000007;\n\ntemplate <typename T> T &chmin(T &a, const T &b) { return a = min(a, b); }\ntemplate <typename T> T &chmax(T &a, const T &b) { return a = max(a, b); }\ntemplate <typename T> bool IN(T a, T b, T x) { return a<=x&&x<b; }\ntemplate<typename T> T ceil(T a, T b) { return a/b + !!(a%b); }\ntemplate<class S,class T>\nostream &operator <<(ostream& out,const pair<S,T>& a){\n  out<<'('<<a.first<<','<<a.second<<')';\n  return out;\n}\ntemplate<class T>\nostream &operator <<(ostream& out,const vector<T>& a){\n  out<<'[';\n  REP(i, a.size()) {out<<a[i];if(i!=a.size()-1)out<<',';}\n  out<<']';\n  return out;\n}\n\nint dx[] = {0, 1, 0, -1}, dy[] = {1, 0, -1, 0};\n\nPII dp[205][205];\nsigned main(void)\n{\n  cin.tie(0);\n  ios::sync_with_stdio(false);\n\n  string s;\n  cin >> s;\n\n  // [l,r]\n  function<PII(int,int)> dfs = [&](int l, int r) -> PII {\n    if(dp[l][r] != PII{-INF, INF}) return dp[l][r];\n    if(l==r) return dp[l][r] = {s[l]-'0', s[l]-'0'};\n    if(s[l]=='(' && r-l>=3) {\n      PII p = dfs(l+1, r);\n      chmax(dp[l][r].first, p.first);\n      chmin(dp[l][r].second, p.second);\n    }\n    if(s[r]==')' && r-l>=3) {\n      PII p = dfs(l, r-1);\n      chmax(dp[l][r].first, p.first);\n      chmin(dp[l][r].second, p.second);\n    }\n    FOR(i, l+1, r) {\n      if(s[i]=='+' || s[i]=='-') {\n        PII vl = dfs(l, i-1);\n        PII vr = dfs(i+1, r);\n        if(s[i]=='+') {\n          chmax(dp[l][r].first, vl.first+vr.first);\n          chmin(dp[l][r].second, vl.second+vr.second);\n        } else {\n          chmax(dp[l][r].first, vl.first-vr.second);\n          chmin(dp[l][r].second, vl.second-vr.first);\n        }\n      }\n    }\n    return dp[l][r];\n  };\n\n  REP(i, s.size()) REP(j, s.size()) dp[i][j] = PII{-INF, INF};\n  cout << dfs(0, s.size()-1).first << endl;\n\n  // REP(i, s.size()) {\n  //   FOR(j, i, s.size()) cout << dp[i][j] << \" \";\n  //   cout << endl;\n  // }\n\n  return 0;\n}\n\n"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\n#define inf (long long)1e17\nusing namespace std;\n\nlong long n;\nstring s;\nvector<vector<long long>> dpmax, dpmin;\n\nlong long solve(int l, int r);\n\nint main() {\n  cin >> s;\n  n = s.size();\n  dpmax.assign(n + 1, vector<long long>(n + 1, inf));\n  dpmin.assign(n + 1, vector<long long>(n + 1, inf));\n  cout << solve(0, n) << endl;\n  return 0;\n}\n\nlong long solve(int l, int r) {\n  if(dpmax[l][r] != inf) return dpmax[l][r];\n  bool ch = 1;\n  // x))))))\n  for(int i = l + 1; i < r; ++i)\n    if(s[i] != ')') ch = 0;\n  if(ch) return dpmax[l][r] = dpmin[l][r] = s[l] - '0';\n  ch = 1;\n  // ((((((x\n  for(int i = l; i < r - 1; ++i)\n    if(s[i] != '(') ch = 0;\n  if(ch) return dpmax[l][r] = dpmin[l][r] = s[r - 1] - '0';\n  // x)+y...\n  if(r - l > 2 && s[l + 1] == ')')\n    return dpmax[l][r] = -inf;\n  // ...+y(x\n  if(r - l > 2 && s[r - 2] == '(')\n    return dpmax[l][r] = -inf;\n  long long resmax = -inf, resmin = inf;\n  for(int i = l; i < r; ++i)\n    if(s[i] == '+') {\n      resmax = max(resmax, solve(l, i) + solve(i + 1, r));\n      resmin = min(resmin, dpmin[l][i] + dpmin[i + 1][r]);\n    }\n    else if(s[i] == '-') {\n      solve(i + 1, r);\n      resmax = max(resmax, solve(l, i) - dpmin[i + 1][r]);\n      resmin = min(resmin, dpmin[l][i] - dpmax[i + 1][r]);\n    }\n  dpmin[l][r] = resmin;\n  return dpmax[l][r] = resmax;\n}\n"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\nusing namespace std;\ntypedef pair<int,int>P;\n#define F first\n#define S second\nint INF=1e9;\nstring s;\nP dp[222][222],init=P(INF,-INF);\n\nP dfs(int l,int r){\n\tif(l==r)return P(s[l]-'0',s[l]-'0');\n\tif(dp[l][r]!=init)return dp[l][r];\n\tP res=init;\n\tif(s[l]=='('&&r-l>2) res=dfs(l+1,r);\n\tif(s[r]==')'&&r-l>2) res=dfs(l,r-1);\n\tfor(int i=l+1;i<r;i++){\n\t\tif(!(s[i]=='-'||s[i]=='+'))continue;\n\t\tP a=dfs(l,i-1);\n\t\tP b=dfs(i+1,r);\n\t\tif(s[i]=='-'){\n\t\t\tres.F=min(res.F,a.F-b.S);\n\t\t\tres.S=max(res.S,a.S-b.F);\n\t\t}\n\t\tif(s[i]=='+'){\n\t\t\tres.F=min(res.F,a.F+b.F);\n\t\t\tres.S=max(res.S,a.S+b.S);\n\t\t}\n\t}\n\treturn dp[l][r]=res;\n}\n\nint main(){\n\tcin>>s;\n\tfor(int i=0;i<222;i++)\n\t\tfor(int j=0;j<222;j++)dp[i][j]=init;\n\tcout<<dfs(0,s.size()-1).S<<endl;\n}\n"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\nusing namespace std;\n\nint cal(string &s,int &i){\n  int res=0;\n  while(1){\n    if(isdigit(s[i]))res=s[i++]-'0';\n    else if(s[i]=='('){res=cal(s,++i);}\n    else if(s[i]=='+')res+=cal(s,++i);\n    else if(s[i]=='-')res-=cal(s,++i);\n    else break;\n  }\n  return res;\n}\n\nint calc(string s){\n  vector<int> v;\n  for(int i=0;i<s.size();i++){\n    int n = (int)v.size()-1;\n    if(s[i]=='+')v.push_back(0);\n    if(s[i]=='-')v.push_back(1);\n    if(s[i]=='(')v.push_back(0),v.push_back(0);\n    if(s[i]==')'){\n      if(v.size()<3)continue;\n      v[n-2]+=v[n-1]? -v[n]:v[n];\n      v.pop_back(),v.pop_back();\n    }\n\n    if(isdigit(s[i])){\n      int num=s[i]-'0';\n      if(v.size()>=2){\n\tv[n-1]+=v[n]? -num:num;\n\tv.pop_back();\n      }\n      else v.push_back(num);\n    }\n  }\n  return v[0];\n}\n\nmap<string,int> mem[2];\nint dfs(string s,int f){\n  if(s.size()==1) return s[0]-'0';\n  if(mem[f].count(s))return mem[f][s];\n\n  int j=0;  \n  int n=s.size(),res=calc(s),d=-1;\n  for(int i=0;i<n;i++) d+=(s[i]=='+'||s[i]=='-');\n  \n  for(int i=0,c=0,cnt=0;i<n;i++,cnt++,d--){\n    while(i<n){\n      while(s[i]=='('||s[i]==')')c+=(s[i]=='(')-(s[i]==')'),i++;\n      if(s[i]=='+'||s[i]=='-') break;\n      i++;\n    }\n    if(i>=n||(cnt&&s[i-2]=='(')||(d&&s[i+2]==')'))continue;\n    string a=s.substr(0,i),b=s.substr(i+1,n-i-1);\n    int t=c,ch=s[i];\n    while(t--)a+=')',b='('+b;\n    int mxa=dfs(a,0),mna=dfs(a,1);\n    int mxb=dfs(b,0),mnb=dfs(b,1);\n    if(f==0&&ch=='+') res=max(res, mxa+mxb);\n    if(f==0&&ch=='-') res=max(res, mxa-mnb);\n    if(f==1&&ch=='+') res=min(res, mna+mnb);\n    if(f==1&&ch=='-') res=min(res, mna-mxb);\n  }\n  return mem[f][s]=res;\n}\n\nint main(){\n  string S;\n  cin>>S;\n  cout <<dfs(S,0)<<endl;\n  return 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\nusing namespace std;\ntypedef long long ll;\n#define all(x) (x).begin(),(x).end()\nconst int mod=1000000007,MAX=203,INF=1<<20;\n\npair<int,int> dp[MAX][MAX];\nint cnt[MAX][MAX];\nbool seen[MAX][MAX];\nstring S;\nint N;\n\npair<int,int> ch(pair<int,int> &a,pair<int,int> b){\n    a.first=max(a.first,b.first);\n    a.second=min(a.second,b.second);\n    return a;\n}\n\npair<int,int> solve(int l,int r){\n    if(seen[l][r]) return dp[l][r];\n    \n    seen[l][r]=1;\n    \n    if(l==r-1){\n        if('0'<=S[l]&&S[l]<='9'){\n            return dp[l][r]={S[l]-'0',S[l]-'0'};\n        }else{\n            return dp[l][r]={-INF,INF};\n        }\n    }\n    \n    pair<int,int> ret={-INF,INF};\n    \n    if(S[l]=='('){\n        ch(ret,solve(l+1,r));\n    }\n    \n    if(S[r-1]==')'){\n        ch(ret,solve(l,r-1));\n    }\n    \n    for(int i=l+1;i<r-1;i++){\n        if(S[i]=='+'){\n            bool ok=true;\n            if(S[i-1]==')'){\n                if(cnt[l][i]<=1) ok=false;\n            }\n            if(S[i+1]=='('){\n                if(cnt[i+1][r]<=1) ok=false;\n            }\n            pair<int,int> a=solve(l,i),b=solve(i+1,r);\n            if(a.first<a.second||b.first<b.second) ok=false;\n            \n            if(ok){\n                ch(ret,{a.first+b.first,a.second+b.second});\n            }\n        }\n        if(S[i]=='-'){\n            bool ok=true;\n            if(S[i-1]==')'){\n                if(cnt[l][i]<=1) ok=false;\n            }\n            if(S[i+1]=='('){\n                if(cnt[i+1][r]<=1) ok=false;\n            }\n            pair<int,int> a=solve(l,i),b=solve(i+1,r);\n            if(a.first<a.second||b.first<b.second) ok=false;\n            \n            if(ok){\n                ch(ret,{a.first-b.second,a.second-b.first});\n            }\n        }\n    }\n    \n    return dp[l][r]=ret;\n}\n\nint main(){\n    \n    std::ifstream in(\"text.txt\");\n    std::cin.rdbuf(in.rdbuf());\n    cin.tie(0);\n    ios::sync_with_stdio(false);\n    \n    cin>>S;\n    N=S.size();\n    \n    for(int i=0;i<N;i++){\n        for(int j=i+1;j<=N;j++){\n            int s=0;\n            for(int k=i;k<j;k++){\n                if('0'<=S[k]&&S[k]<='9') s++;\n            }\n            cnt[i][j]=s;\n        }\n    }\n    \n    cout<<solve(0,N).first<<endl;\n}\n\n\n"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\n#define INF (1e9)\nusing namespace std;\n\n\nint calc(string s){\n  vector<int> v;\n  for(int i=0;i<s.size();i++){\n    int n = (int)v.size()-1;\n    if(s[i]=='+')v.push_back(0);\n    if(s[i]=='-')v.push_back(1);\n    if(s[i]=='(')v.push_back(0),v.push_back(0);\n    if(s[i]==')'){\n      if(v.size()<3)continue;\n      v[n-2]+=v[n-1]? -v[n]:v[n];\n      v.pop_back(),v.pop_back();\n    }\n\n    if(isdigit(s[i])){\n      int num=s[i]-'0';\n      if(v.size()>=2){\n\tv[n-1]+=v[n]? -num:num;\n\tv.pop_back();\n      }\n      else v.push_back(num);\n    }\n  }\n  return v[0];\n}\n\nmap<string,int> mem[2];\nint dfs(string s,int f){\n  if(s.size()==1) return s[0]-'0';\n  if(mem[f].count(s))return mem[f][s];\n  int n=s.size(),res=calc(s);\n  for(int i=0,c=0;i<n;i++){\n    while(i<n){\n      while(s[i]=='('||s[i]==')')c+=(s[i]=='(')-(s[i]==')'),i++;\n      if(s[i]=='+'||s[i]=='-') break;\n      i++;\n    }\n    if(i>=n)break;\n    if((i-2>=0&&s[i-2]=='(')||(i+2<n&&s[i+2]==')'))continue;\n    string a=s.substr(0,i),b=s.substr(i+1,n-i-1);\n    int t=c,ch=s[i];\n    while(t--)a+=')',b='('+b;\n    int mxa=dfs(a,0),mna=dfs(a,1);\n    int mxb=dfs(b,0),mnb=dfs(b,1);\n    if(f==0&&ch=='+') res=max(res, mxa+mxb);\n    if(f==0&&ch=='-') res=max(res, mxa-mnb);\n    if(f==1&&ch=='+') res=min(res, mna+mnb);\n    if(f==1&&ch=='-') res=min(res, mna-mxb);\n  }\n  return mem[f][s]=res;\n}\n\n\n\nbool check(string s){\n  if(s[0]!='(')return 0;\n  int i=0;\n  while(s[i]!=')')i++;\n  return i==(int)s.size()-1;\n}\n\nint main(){\n  string S;\n  cin>>S;\n  while(check(S))S=S.substr(1,S.size()-2);\n  cout <<dfs(S,0)<<endl;\n  return 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\n#define INF (1e9)\nusing namespace std;\n\n\nint calc(string s){\n  vector<int> v;\n  for(int i=0;i<s.size();i++){\n    int n = (int)v.size()-1;\n    if(s[i]=='+')v.push_back(0);\n    if(s[i]=='-')v.push_back(1);\n    if(s[i]=='(')v.push_back(0),v.push_back(0);\n    if(s[i]==')'){\n      if(v.size()<3)continue;\n      v[n-2]+=v[n-1]? -v[n]:v[n];\n      v.pop_back(),v.pop_back();\n    }\n\n    if(isdigit(s[i])){\n      int num=s[i]-'0';\n      if(v.size()>=2){\n\tv[n-1]+=v[n]? -num:num;\n\tv.pop_back();\n      }\n      else v.push_back(num);\n    }\n  }\n  return v[0];\n}\n\n\nbool check(string s){\n  if(s[0]!='(')return 0;\n  int i=1,c=1;\n  while(c)c+=(s[i]=='(')-(s[i++]==')');\n  return i==(int)s.size();\n}\n\n\nmap<string,int> mem[2];\nint dfs(string s,int f){\n  while(check(s))s=s.substr(1,s.size()-2);\n  if(s.size()==1) return s[0]-'0';\n  if(mem[f].count(s))return mem[f][s];\n  \n  int n=s.size(),res=calc(s);\n  for(int i=0,c=0;i<n;i++){\n    while(i<n){\n      while(s[i]=='('||s[i]==')')c+=(s[i]=='(')-(s[i]==')'),i++;\n      if(s[i]=='+'||s[i]=='-') break;\n      i++;\n    }\n    if(i>=n)break;\n    if((i-2>=0&&s[i-2]=='('&&s[i+1]!='('))continue;\n    if(i+2<n-1&&s[i+2]==')')continue;\n    string a=s.substr(0,i),b=s.substr(i+1,n-i-1);\n    int t=c,ch=s[i];\n    while(t--)a+=')',b='('+b;\n    int mxa=dfs(a,0),mna=dfs(a,1);\n    int mxb=dfs(b,0),mnb=dfs(b,1);\n    if(f==0&&ch=='+') res=max(res, mxa+mxb);\n    if(f==0&&ch=='-') res=max(res, mxa-mnb);\n    if(f==1&&ch=='+') res=min(res, mna+mnb);\n    if(f==1&&ch=='-') res=min(res, mna-mxb);\n  }\n  return mem[f][s]=res;\n}\n\n\n\n\nint main(){\n  string S;\n  cin>>S;\n\n  cout <<dfs(S,0)<<endl;\n  return 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\nusing namespace std;\n\ntypedef long long ll;\ntypedef unsigned long long ull;\ntypedef pair<ll, ll> P;\n\n#define fi first\n#define se second\n#define repl(i,a,b) for(ll i=(ll)(a);i<(ll)(b);i++)\n#define rep(i,n) repl(i,0,n)\n#define each(itr,v) for(auto itr:v)\n#define pb push_back\n#define all(x) (x).begin(),(x).end()\n#define dbg(x) cout<<#x\"=\"<<x<<endl\n#define mmax(x,y) (x>y?x:y)\n#define mmin(x,y) (x<y?x:y)\n#define maxch(x,y) x=mmax(x,y)\n#define minch(x,y) x=mmin(x,y)\n#define uni(x) x.erase(unique(all(x)),x.end())\n#define exist(x,y) (find(all(x),y)!=x.end())\n#define bcnt __builtin_popcount\n\n#define INF INT_MAX/3\n\nchar s[222];\nint n;\nbool lc[222],rc[222];\nint dp[222][222][2];\n\nint f(int l,int r,int flag){\n  if(l+1==r)return s[l]-'0'; // num\n  if(dp[l][r][flag]!=-INF-1)return dp[l][r][flag];\n\n  int res=flag?INF:-INF;\n  repl(i,l,r){\n    if(s[i]!='+'&&s[i]!='-')continue;\n    if((lc[i]&&i-2>=l)||(rc[i]&&i+2<r))continue;\n    int op=s[i]=='+'?+1:-1;\n    int lnum=f(l,i,flag),rnum=f(i+1,r,op==+1?flag:1-flag);\n    if(!flag)maxch(res,lnum+op*rnum);\n    else minch(res,lnum+op*rnum);\n  }\n  return dp[l][r][flag]=res;\n}\n\nint main(){\n\tcin.sync_with_stdio(false);\n  cin>>s;\n  n=strlen(s);\n  rep(i,222)rep(j,222)rep(k,2)dp[i][j][k]=-INF-1;\n  rep(i,n){\n    if(i-2>=0&&(s[i]=='+'||s[i]=='-')&&s[i-2]=='(')lc[i]=true;\n    if(i+2<n&&(s[i]=='+'||s[i]=='-')&&s[i+2]==')')rc[i]=true;\n  }\n  rep(i,n){\n    if(s[i]=='('||s[i]==')')s[i]=0;\n  }\n  rep(i,n){\n    if(s[i]!=0)continue;\n    repl(j,i,n){\n      if(s[j]==0)continue;\n      s[i]=s[j];\n      lc[i]=lc[j];\n      rc[i]=rc[j];\n      s[j]=0;\n      break;\n    }\n  }\n  n=strlen(s);\n  cout<<f(0,n,0)<<endl;\n\treturn 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include<bits/stdc++.h>\nusing namespace std;\n\n#define int long long\ntypedef vector<int>vint;\ntypedef pair<int,int>pint;\ntypedef vector<pint>vpint;\n#define rep(i,n) for(int i=0;i<(n);i++)\n#define reps(i,f,n) for(int i=(f);i<(n);i++)\n#define all(v) (v).begin(),(v).end()\n#define each(it,v) for(__typeof((v).begin()) it=(v).begin();it!=(v).end();it++)\n#define pb push_back\n#define fi first\n#define se second\ntemplate<typename A,typename B>inline void chmin(A &a,B b){if(a>b)a=b;}\ntemplate<typename A,typename B>inline void chmax(A &a,B b){if(a<b)a=b;}\n\nint N;\nint A[222],ope[222],bef[222],aft[222];\n\n\nconst int INF=1001001001001001001ll;\nint mi[222][222];\nint ma[222][222];\n\nsigned main(){\n    string S;cin>>S;\n    rep(i,S.size()){\n        if(!isdigit(S[i]))continue;\n        A[N]=S[i]-'0';\n        if(i+1<S.size()&&S[i+1]==')')aft[N]=1;\n        ope[N]=1;\n        int t=i;\n        while(t&&S[t-1]=='(')t--,bef[N]=1;\n        if(t&&S[t-1]=='-')ope[N]=-1;\n        N++;\n    }\n\n    fill_n(*ma,222*222,-INF);\n    fill_n(*mi,222*222,INF);\n    rep(i,N){\n        if(!bef[i])mi[i][i+1]=ma[i][i+1]=A[i]*ope[i];\n    }\n\n\n    for(int len=2;len<=N;len++){\n        for(int i=0;i+len<=N;i++){\n            int j=i+len;\n            for(int k=i+1;k<j;k++){\n                chmax(ma[i][j],ma[i][k]+ma[k][j]);\n                chmin(mi[i][j],mi[i][k]+mi[k][j]);\n            }\n            if(!aft[i]){\n                if(ope[i]==1){\n                    chmax(ma[i][j],A[i]+ma[i+1][j]);\n                    chmin(mi[i][j],A[i]+mi[i+1][j]);\n                }\n                else{\n                    chmax(ma[i][j],-A[i]-mi[i+1][j]);\n                    chmin(mi[i][j],-A[i]-ma[i+1][j]);\n                }\n            }\n        }\n    }\n\n    cout<<ma[0][N]<<endl;\n    return 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include <iostream>\n#include <cstdio>\n#include <string>\n#include <algorithm>\n#include <utility>\nusing namespace std;\ntypedef pair<int, int> pii;\ninline void chmax(int &a, const int &b) {a = max(a, b);}\ninline void chmin(int &a, const int &b) {a = min(a, b);}\nconst int INF = 1 << 28;\nstring s;\nint N;\npii dp[210][210], INIT;\n\npii solve(int l, int r) {\n    pii &res = dp[l][r];\n    if(dp[l][r] != INIT) return res;\n    // 数字\n    if(r - l == 1) {\n        int val = s[l] - '0';\n        return res = make_pair(val, val);\n    }\n    // 括弧をとっぱらって再帰的に\n    // このとき、括弧含め幅が 3 以下 (つまり実質 2 以下) だと\n    // 数式になりえないので飛ばす\n    if(s[l] == '(' && r-l > 3) {\n        pii tmp = solve(l+1, r);\n        res.first = max(res.first, tmp.first);\n        res.second = min(res.second, tmp.second);\n    }\n    if(s[r-1] == ')' && r-l > 3) {\n        pii tmp = solve(l, r-1);\n        res.first = max(res.first, tmp.first);\n        res.second = min(res.second, tmp.second);\n    }\n    for(int k=l; k<r; k++) {\n        if(s[k] != '+' && s[k] != '-') continue;\n        pii v1 = solve(l, k), v2 = solve(k+1, r);\n        if(s[k] == '+') {\n            res.first = max(res.first, v1.first + v2.first);\n            res.second = min(res.second, v1.second + v2.second);\n        }\n        else {\n            res.first = max(res.first, v1.first - v2.second);\n            res.second = min(res.second, v1.second - v2.first);\n        }\n    }\n    return res;\n}\n\nint main() {\n    cin >> s;\n    N = s.length();\n    INIT = make_pair(-INF, INF);\n    for(int i=0; i<N; i++) {\n        fill(dp[i], dp[i] + N + 1, INIT);\n    }\n\n    cout << solve(0, N).first << endl;\n    /*\n    for(int i=0; i<N; i++) {\n        for(int j=i+1; j<=N; j++) {\n            if(dp_max[i][j] == -INF) continue;\n            printf(\"%s\\n\", s.c_str());\n            for(int k=0; k<N; k++) {\n                if(i <= k && k < j) printf(\"=\");\n                else printf(\" \");\n            }\n            printf(\" -> %d\\n\", dp_max[i][j]);\n        }\n    }\n    */\n    return 0;\n}\n"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\n\nusing namespace std;\n\n#define rep(i,n) for(int i=0; i<n; i++)\n#define reep(i,a,b) for(int i=a; i<b; i++)\n#define INF 0x3f3f3f3f\n\nstring s;\nint mn[300][300];\nint mx[300][300];\n\nint MAX(int l, int r);\nint MIN(int l, int r);\n\n\nint MAX(int l, int r){\n\tif(mx[l][r]!=-INF) return mx[l][r];\n\tint &ret = mx[l][r];\n\twhile(s[l] == '(') l++;\n\twhile(s[r] == ')') r--;\n\tif(l==r&&isdigit(s[l])) return ret = s[l]-'0';\n\tif(s[l+1]==')') return ret;\n\tif(s[r-1]=='(') return ret;\n\treep(i,l,r+1){\n\t\tif(s[i]=='+') ret = max(ret, MAX(l,i-1)+MAX(i+1, r));\n\t\tif(s[i]=='-') ret = max(ret, MAX(l,i-1)-MIN(i+1, r));\n\t}\n\treturn ret;\n}\n\nint MIN(int l, int r){\n\tif(mn[l][r]!=INF) return mn[l][r];\n\tint &ret = mn[l][r];\n\twhile(s[l] == '(') l++;\n\twhile(s[r] == ')') r--;\n\tif(l==r&&isdigit(s[l])) return ret = s[l]-'0';\n\tif(s[l+1]==')') return ret;\n\tif(s[r-1]=='(') return ret;\n\treep(i,l,r+1){\n\t\tif(s[i]=='+') ret = min(ret, MIN(l,i-1)+MIN(i+1, r));\n\t\tif(s[i]=='-') ret = min(ret, MIN(l,i-1)-MAX(i+1, r));\n\t}\n\treturn ret;\n}\n\nint main(){\n\tcin>>s;\n\trep(i,300){\n\t\trep(j,300){\n\t\t\tmx[i][j] = -INF;\n\t\t\tmn[i][j] = INF;\n\t\t}\n\t}\n\tcout<<MAX(0,s.size()-1)<<endl;\n}"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\nusing namespace std;\n\ntypedef long long ll;\ntypedef unsigned long long ull;\ntypedef pair<ll, ll> P;\n\n#define fi first\n#define se second\n#define repl(i,a,b) for(ll i=(ll)(a);i<(ll)(b);i++)\n#define rep(i,n) repl(i,0,n)\n#define each(itr,v) for(auto itr:v)\n#define pb push_back\n#define all(x) (x).begin(),(x).end()\n#define dbg(x) cout<<#x\"=\"<<x<<endl\n#define mmax(x,y) (x>y?x:y)\n#define mmin(x,y) (x<y?x:y)\n#define maxch(x,y) x=mmax(x,y)\n#define minch(x,y) x=mmin(x,y)\n#define uni(x) x.erase(unique(all(x)),x.end())\n#define exist(x,y) (find(all(x),y)!=x.end())\n#define bcnt __builtin_popcount\n\n#define INF INT_MAX/3\n\nchar s[222];\nint n;\nbool lc[222],rc[222];\nint dp[222][222][2];\n\nint f(int l,int r,int flag){\n  if(l+1==r)return s[l]-'0'; // num\n  if(dp[l][r][flag]!=-INF-1)return dp[l][r][flag];\n\n  int res=flag?INF:-INF;\n  repl(i,l,r){\n    if(s[i]!='+'&&s[i]!='-')continue;\n    if((lc[i]&&i-2>=l)||(rc[i]&&i+2<r))continue;\n    int op=s[i]=='+'?+1:-1;\n    int lnum=f(l,i,flag),rnum=f(i+1,r,op==+1?flag:1-flag);\n    if(!flag)maxch(res,lnum+op*rnum);\n    else minch(res,lnum+op*rnum);\n  }\n  return dp[l][r][flag]=res;\n}\n\nint main(){\n\tcin.sync_with_stdio(false);\n  cin>>s;\n  n=strlen(s);\n  rep(i,222)rep(j,222)rep(k,2)dp[i][j][k]=-INF-1;\n  rep(i,n){\n    if(i-2>=0&&(s[i]=='+'||s[i]=='-')&&s[i-2]=='(')lc[i]=true;\n    if(i+2<n&&(s[i]=='+'||s[i]=='-')&&s[i+2]==')')rc[i]=true;\n  }\n  rep(i,n){\n    if(s[i]=='('||s[i]==')')s[i]=0;\n  }\n  rep(i,n){\n    if(s[i]!=0)continue;\n    repl(j,i,n){\n      s[j]=s[j+1];\n      lc[j]=lc[j+1];\n      rc[j]=rc[j+1];\n    }\n  }\n  n=strlen(s);\n  cout<<f(0,n,0)<<endl;\n\treturn 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include <iostream>\n#include <cstdio>\n#include <string>\n#include <algorithm>\n#include <utility>\nusing namespace std;\ntypedef pair<int, int> pii;\nvoid chmax(int &a, const int &b) {a = max(a, b);}\nvoid chmin(int &a, const int &b) {a = min(a, b);}\nconst int INF = 1 << 28;\nstring s;\nint N;\npii dp[210][210], INIT;\n\npii solve(int l, int r) {\n    if(dp[l][r] != INIT) return dp[l][r];\n    // 数字\n    if(r - l == 1 && isdigit(s[l])) {\n        int val = s[l] - '0';\n        return dp[l][r] = make_pair(val, val);\n    }\n    // 括弧をとっぱらって再帰的に\n    // このとき、括弧含め幅が 3 以下 (つまり実質 2 以下) だと\n    // 数式になりえないので飛ばす\n    if(s[l] == '(' && r-l > 3) {\n        pii res = solve(l+1, r);\n        chmax(dp[l][r].first, res.first);\n        chmin(dp[l][r].second, res.second);\n    }\n    else if(s[r-1] == ')' && r-l > 3) {\n        pii res = solve(l, r-1);\n        chmax(dp[l][r].first, res.first);\n        chmin(dp[l][r].second, res.second);\n    }\n    else {\n        for(int k=l; k<r; k++) {\n            if(s[k] != '+' && s[k] != '-') continue;\n            pii v1 = solve(l, k), v2 = solve(k+1, r);\n            if(v1 == INIT || v2 == INIT) continue;\n            if(s[k] == '+') {\n                chmax(dp[l][r].first, v1.first + v2.first);\n                chmin(dp[l][r].second, v1.second + v2.second);\n            }\n            else {\n                chmax(dp[l][r].first, v1.first - v2.second);\n                chmin(dp[l][r].second, v1.second - v2.first);\n            }\n        }\n    }\n    return dp[l][r];\n}\n\nint main() {\n    cin >> s;\n    N = s.length();\n    INIT = make_pair(-INF, INF);\n    for(int i=0; i<N; i++) {\n        fill(dp[i], dp[i] + N + 1, INIT);\n    }\n\n    cout << solve(0, N).first << endl;\n    /*\n    for(int i=0; i<N; i++) {\n        for(int j=i+1; j<=N; j++) {\n            if(dp_max[i][j] == -INF) continue;\n            printf(\"%s\\n\", s.c_str());\n            for(int k=0; k<N; k++) {\n                if(i <= k && k < j) printf(\"=\");\n                else printf(\" \");\n            }\n            printf(\" -> %d\\n\", dp_max[i][j]);\n        }\n    }\n    */\n    return 0;\n}\n"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\n#define INF (1e9)\nusing namespace std;\n\n\nint calc(string s){\n  vector<int> v;\n  for(int i=0;i<s.size();i++){\n    int n = v.size()-1;\n    if(s[i]=='+')v.push_back(0);\n    if(s[i]=='-')v.push_back(1);\n    if(s[i]=='(')v.push_back(0),v.push_back(0);\n    if(s[i]==')'){\n      v[n-2]+=v[n-1]? -v[n]:v[n];\n      v.pop_back(),v.pop_back();\n    }\n\n    if(isdigit(s[i])){\n      int num=s[i]-'0';\n      if(v.size()>=2){\n\tv[n-1]+=v[n]? -num:num;\n\tv.pop_back();\n      }\n      else v.push_back(num);\n    }\n  }\n  return v[0];\n}\n\nmap<string,int> mem[2];\nint dfs(string s,int f){\n  if(s.size()==1) return s[0]-'0';\n  if(mem[f].count(s))return mem[f][s];\n  int n=s.size(),res=calc(s);\n  for(int i=0,c=0;i<n;i++){\n    while(i<n){\n      while(s[i]=='('||s[i]==')')c+=(s[i]=='(')-(s[i]==')'),i++;\n      if(s[i]=='+'||s[i]=='-') break;\n      i++;\n    }\n    if(i>=n)break;\n    if((i-2>=0&&s[i-2]=='('))continue;\n    string a=s.substr(0,i),b=s.substr(i+1,n-i-1);\n    int t=c,ch=s[i];\n    while(t--)a+=')',b='('+b;\n    int mxa=dfs(a,0),mna=dfs(a,1);\n    int mxb=dfs(b,0),mnb=dfs(b,1);\n    if(f==0&&ch=='+') res=max(res, mxa+mxb);\n    if(f==0&&ch=='-') res=max(res, mxa-mnb);\n    if(f==1&&ch=='+') res=min(res, mna+mnb);\n    if(f==1&&ch=='-') res=min(res, mna-mxb);\n  }\n  return mem[f][s]=res;\n}\n\n\n\nint main(){\n  string S;\n\n  cin>>S;\n  cout <<dfs(S,0)<<endl;\n  return 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include <iostream>\n#include <cmath>\n#define REP(i, a, n) for(int i = ((int) a); i < ((int) n); i++)\n#define INF 100000000\nusing namespace std;\ntypedef long long ll;\n\nstring S;\nll dp[300][300][2];\n\nll number(int l, int r) {\n  ll ret = 0;\n  REP(i, l, r) {\n    if('0' <= S[i] && S[i] <= '9') ret = ret * 10 + (S[i] - '0');\n    else return -1;\n  }\n  return ret;\n}\n\nll dfs(int l, int r, int mode, int depth) {\n  ll ret;\n\n  if(dp[l][r][mode] >= 0) ret = dp[l][r][mode];\n  else {\n    ll n = number(l, r);\n    if(n >= 0) ret = n;\n    else {\n      ret = mode == 0 ? -INF : INF;\n      REP(i, l, r) {\n        if(S[i] != '+' && S[i] != '-') continue;\n\n        int nl = l, nr = r;\n        while(1) {\n          ll n1 = dfs(nl, i, mode, depth + 1);\n          ll n2 = dfs(i + 1, nr, S[i] == '-' ? 1 - mode : mode, depth + 1);\n          if(abs(n1) != INF && abs(n2) != INF) {\n            if(mode == 0) {\n              if(S[i] == '+') ret = max(ret, n1 + n2);\n              if(S[i] == '-') ret = max(ret, n1 - n2);\n            } else {\n              if(S[i] == '+') ret = min(ret, n1 + n2);\n              if(S[i] == '-') ret = min(ret, n1 - n2);\n            }\n          }\n          if(S[nl] != '(' && S[nr - 1] != ')') break;\n          if(S[nl] == '(') nl++;\n          if(S[nr - 1] == ')') nr--;\n        }\n      }\n    }\n  }\n\n  return dp[l][r][mode] = ret;\n}\n\nint main(void) {\n  cin >> S;\n\n  REP(i, 0, 201) REP(j, 0, 201) REP(k, 0, 2) dp[i][j][k] = -INF;\n  cout << dfs(0, S.size(), 0, 0) << endl;\n\n  return 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\nusing namespace std;\n\nint calc(string &s,int &i){\n  int res=0;\n  while(1){\n    if(isdigit(s[i]))res=s[i++]-'0';\n    else if(s[i]=='('){res=calc(s,++i),i++;}\n    else if(s[i]=='+')res+=calc(s,++i);\n    else if(s[i]=='-')res-=calc(s,++i);\n    else break;\n  }\n  return res;\n}\n\nmap<string,int> mem[2];\nint dfs(string s,int f){\n  if(mem[f].count(s))return mem[f][s];\n\n  int j=0,res=calc(s,j),n=s.size(),d=-1;\n  for(int i=0;i<n;i++) d+=(s[i]=='+'||s[i]=='-');\n  \n  for(int i=0,c=0,cnt=0;i<n;i++,cnt++,d--){\n    while(1){\n      while(s[i]=='('||s[i]==')')c+=(s[i]=='(')-(s[i]==')'),i++;\n      if(i>=n||s[i]=='+'||s[i]=='-') break;\n      i++;\n    }\n    if(i>=n||(cnt&&s[i-2]=='(')||(d&&s[i+2]==')'))continue;\n    string a=s.substr(0,i),b=s.substr(i+1,n-i-1);\n    int t=c,ch=s[i];\n    while(t--)a+=')',b='('+b;\n    int mxa=dfs(a,0),mna=dfs(a,1);\n    int mxb=dfs(b,0),mnb=dfs(b,1);\n    if(f==0&&ch=='+') res=max(res, mxa+mxb);\n    if(f==0&&ch=='-') res=max(res, mxa-mnb);\n    if(f==1&&ch=='+') res=min(res, mna+mnb);\n    if(f==1&&ch=='-') res=min(res, mna-mxb);\n  }\n  return mem[f][s]=res;\n}\n\nint main(){\n  string S;\n  cin>>S;\n  cout <<dfs(S,0)<<endl;\n  return 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\nusing namespace std;\n\n#define int long long\nusing P = pair<int, int>;\nconst int INF = 1e9;\n\nstring s;\nvector<vector<P> > dp;\n\nP dfs(int l, int r) {\n  if ( dp[l][r] != P(-INF, INF) ) {\n    return dp[l][r];    \n  }\n  if ( l == r ) {\n    return P(s[l]-'0', s[l]-'0');    \n  }\n\n  P ret = {-INF, INF};\n  if ( s[l] == '(' && r-l >= 3 ) {\n    P res = dfs(l+1, r);\n    ret.first = max(ret.first, res.first);\n    ret.second = min(ret.second, res.second);    \n  }\n  \n  if ( s[r] == ')' && r-l >= 3 ) {\n    P res = dfs(l, r-1);\n    ret.first = max(ret.first, res.first);\n    ret.second = min(ret.second, res.second);    \n  }\n  \n  for ( int i = l+1; i < r; i++ ) {\n    if ( s[i] == '+' ) {\n      P res1 = dfs(l, i-1);\n      P res2 = dfs(i+1, r);      \n      ret.first = max(ret.first, res1.first+res2.first);\n      ret.second = min(ret.second, res1.second+res2.second);      \n    }\n    if ( s[i] == '-' ) {\n      P res1 = dfs(l, i-1);\n      P res2 = dfs(i+1, r);      \n      ret.first = max(ret.first, res1.first-res2.second);\n      ret.second = min(ret.second, res1.second-res2.first);      \n    }\n  }\n\n  return dp[l][r] = ret;  \n}\n\nsigned main() {\n  cin.tie(0);\n  ios_base::sync_with_stdio(0);\n  cout << fixed << setprecision(12);\n\n  cin >> s;\n\n  int n = s.size();\n  dp = vector<vector<P> >(n+1, vector<P>(n+1, P(-INF, INF)));\n\n  cout << dfs(0, n-1).first << endl;  \n  \n  return 0;\n}\n\n"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\nusing namespace std;\n\nint calc(string &s,int &i){\n  int res=0;\n  while(1){\n    if(isdigit(s[i]))res=s[i++]-'0';\n    else if(s[i]=='('){res=calc(s,++i),i++;}\n    else if(s[i]=='+')res+=calc(s,++i);\n    else if(s[i]=='-')res-=calc(s,++i);\n    else break;\n  }\n  return res;\n}\n\nmap<string,int> mem[2];\nint dfs(string s,int f){\n  if(mem[f].count(s))return mem[f][s];\n\n  int j=0,res=calc(s,j),n=s.size(),d=-1;\n  for(int i=0;i<n;i++) d+=(s[i]=='+'||s[i]=='-');\n  \n  for(int i=0,c=0,cnt=0;i<n;i++,cnt++,d--){\n    while(1){\n      while(s[i]=='('||s[i]==')')c+=(s[i]=='(')-(s[i]==')'),i++;\n      if(i>=n||s[i]=='+'||s[i]=='-') break;\n      i++;\n    }\n    if(i>=n||(cnt&&s[i-2]=='(')||(d&&s[i+2]==')'))continue;\n    string a=s.substr(0,i),b=s.substr(i+1,n-i-1);\n    int t=c,ch=s[i];\n    while(t--)a+=')',b='('+b;\n    int mxa=dfs(a,0),mna=dfs(a,1);\n    int mxb=dfs(b,0),mnb=dfs(b,1);\n    if(f==0&&ch=='+') res=max(res, mxa+mxb);\n    if(f==0&&ch=='-') res=max(res, mxa-mnb);\n    if(f==1&&ch=='+') res=min(res, mna+mnb);\n    if(f==1&&ch=='-') res=min(res, mna-mxb);\n  }\n  return mem[f][s]=res;\n}\n\nint main(){\n  string S;\n  cin>>S;\n  cout <<dfs(S,0)<<endl;\n  return 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\nusing namespace std;\nint INF = 10000000;\nint main(){\n  string S;\n  cin >> S;\n  int L = S.size();\n  vector<int> p;\n  vector<char> op;\n  for (int i = 0; i < L; i++){\n    if ('0' <= S[i] && S[i] <= '9'){\n      p.push_back(i);\n    }\n    if (S[i] == '+' || S[i] == '-'){\n      op.push_back(S[i]);\n    }\n  }\n  int N = p.size();\n  vector<vector<int>> dpmax(N + 1, vector<int>(N + 1, -INF));\n  vector<vector<int>> dpmin(N + 1, vector<int>(N + 1, INF));\n  for (int i = 0; i < N; i++){\n    dpmax[i][i + 1] = S[p[i]] - '0';\n    dpmin[i][i + 1] = S[p[i]] - '0';\n  }\n  for (int r = 2; r <= N; r++){\n    for (int i = 0; i <= N - r; i++){\n      int j = i + r;\n      for (int k = i + 1; k < j; k++){\n        bool ok = true;\n        if (k == i + 1){\n          if (S[p[i] + 1] == ')'){\n           ok = false;\n          }\n        }\n        if (k == j - 1){\n          if (S[p[k] - 1] == '('){\n            ok = false;\n          }\n        }\n        if (ok){\n          if (op[k - 1] == '+'){\n            dpmax[i][j] = max(dpmax[i][j], dpmax[i][k] + dpmax[k][j]);\n            dpmin[i][j] = min(dpmin[i][j], dpmin[i][k] + dpmin[k][j]);\n          }\n          if (op[k - 1] == '-'){\n            dpmax[i][j] = max(dpmax[i][j], dpmax[i][k] - dpmin[k][j]);\n            dpmin[i][j] = min(dpmin[i][j], dpmin[i][k] - dpmax[k][j]);\n          }\n        }\n      }\n    }\n  }\n  cout << dpmax[0][N] << endl;\n}\n"
  },
  {
    "language": "C++",
    "code": "#include <iostream>\n#include <cstring>\n#include <algorithm>\n#include <set>\n\nusing namespace std;\n\n#define MIN first\n#define MAX second\nconstexpr int MAX_S = 252;\nconstexpr int INF = (1 << 29);\n\nstring S;\npair<int, int> mem[MAX_S][MAX_S];\n\nvoid init(int N)\n{\n    for (int i = 0; i < N; i++) {\n        for (int j = 0; j < N; j++) {\n            mem[i][j] = {+INF, -INF};\n        }\n    }\n}\n\nvoid update_max(int& l, int r)\n{   \n    if (l < r) l = r;\n}\n\nvoid update_min(int& l, int r)\n{\n    if (l > r) l = r;\n}\n\n// テ・ツ個コテゥツ鳴禿」ツ?ョpair(MIN, MAX)\npair<int, int> rec(int L, int R)\n{\n    pair<int, int>& res = mem[L][R];\n    if (res != make_pair(+INF, -INF)) {\n        return res;\n    }\n\n    if (R - L == 0) {\n        int v = S[L] - '0';\n        return (res = make_pair(v, v));\n    }    \n\n    if (S[L] == '(' && R - L > 2) {\n        auto r = rec(L + 1, R);\n        update_min(res.MIN, r.MIN);\n        update_max(res.MAX, r.MAX);\n        return res;\n    }\n\n    if (S[R] == ')' && R - L > 2) {\n        auto r = rec(L, R - 1);\n        update_min(res.MIN, r.MIN);\n        update_max(res.MAX, r.MAX);\n        return res;\n    }\n    \n    for (int i = L + 1; i <= R - 1; i++) {\n        char c = S[i];   \n        if (c != '+' && c != '-') continue;                 \n        \n        auto res_l = rec(L, i - 1); // Left\n        auto res_r = rec(i + 1, R); // Right\n\n        if (c == '+') {            \n            update_min(res.MIN, res_l.MIN + res_r.MIN);\n            update_max(res.MAX, res_l.MAX + res_r.MAX);            \n        }\n        if (c == '-') {           \n            update_min(res.MIN, res_l.MIN - res_r.MAX);\n            update_max(res.MAX, res_l.MAX - res_r.MIN);\n        }\n    } \n    return res;\n}\n\nvoid solve()\n{\n    int N = S.size();\n    init(N);\n    cout << rec(0, N - 1).MAX << endl;    \n}\n\nint main()\n{\n    cin >> S;\n    solve();    \n    return 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include <iostream>\n#define REP(i, a, n) for(int i = ((int) a); i < ((int) n); i++)\n#define INF 100000000\nusing namespace std;\ntypedef long long ll;\n\nstring S;\nll dp[300][300][2];\n\nll number(int l, int r) {\n  ll ret = 0;\n  REP(i, l, r) {\n    if('0' <= S[i] && S[i] <= '9') ret = ret * 10 + (S[i] - '0');\n    else return -1;\n  }\n  return ret;\n}\n\nll dfs(int l, int r, int sign, int depth) {\n  ll ret;\n\n  if(dp[l][r][(sign + 1) / 2] >= 0) ret = dp[l][r][(sign + 1) / 2];\n  else {\n    ll n = number(l, r);\n    if(n >= 0) ret = sign * n;\n    else {\n      ret = -INF;\n      REP(i, l, r) {\n        int next = S[i] == '+' ? sign : -sign;\n        if(S[i] != '+' && S[i] != '-') continue;\n        ll m1 = dfs(l, i, sign, depth + 1);\n        ll m2 = dfs(i + 1, r, next, depth + 1);\n        ret = max(ret, m1 + m2);\n        ll n1 = dfs(l + (S[l] == '('), i, sign, depth + 1);\n        ll n2 = dfs(i + 1, r - (S[r - 1] == ')'), next, depth + 1);\n        ret = max(ret, n1 + n2);\n      }\n    }\n  }\n\n  return dp[l][r][(sign + 1) / 2] = ret;\n}\n\nint main(void) {\n  cin >> S;\n\n  REP(i, 0, 201) REP(j, 0, 201) REP(k, 0, 2) dp[i][j][k] = -INF;\n  cout << dfs(0, S.size(), 1, 0) << endl;\n\n  return 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\n#define N 201\nusing namespace std;\n\n/*\nint p;\nint bnf(){\n  int res=0;\n  while(p<S.size()){\n    if(S[p]=='(')p++,res=bnf();\n    else if(isdigit(S[p]))res=S[p++]-'0';\n    else if(S[p]=='+')p++,res+=bnf();\n    else if(S[p]=='-')p++,res-=bnf();\n    else break;\n    }\n  p++;\n  return res;\n  }\n*/\n\n\nint skip(string &str,int i){\n  if(str[i]!='(')return i;\n  string res;\n  int cnt=1;i++;\n  while(1) {\n    if(str[i]=='(')cnt++;\n    if(str[i]==')')cnt--;\n    if(!cnt)break;\n    res+=str[i++];\n  }\n  return i;\n}\n \n\nmap<string,int>mem[2];\nint dfs(string str,int flg){\n  if(str.size()==1) return str[0]-'0';\n  if(mem[flg].count(str)) return mem[flg][str];\n  if(skip(str,0)==(int)str.size()-1)return dfs(str.substr(1,str.size()-2),flg);\n\n  int res=flg? 1e9:-1e9;\n  for(int i=0;(i=skip(str,i))<str.size()-1;i+=2){\n    string L=str.substr(0,i+1),R=str.substr(i+2,str.size()-i-2);\n    int Lmx=dfs(L,0),Lmn=dfs(L,1);\n    int Rmx=dfs(R,0),Rmn=dfs(R,1);\n    if(str[i+1]=='-') res=flg? min(res,Lmn-Rmx):max(res,Lmx-Rmn);\n    if(str[i+1]=='+') res=flg? min(res,Lmn+Rmn):max(res,Lmx+Rmx);\n  }\n  return mem[flg][str]=res;\n}\n\n\nint main(){\n  string S,tmp;\n  cin>>S;\n  int cnt=0;\n  for(int i=0;i<S.size();i++) {\n    if(S[i]!=')')tmp+=S[i];\n    if(i&&(S[i-1]=='+'||S[i-1]=='-')&&cnt)tmp+=')',cnt--;\n    if(S[i]=='(')cnt++;\n  }\n  if(skip(S,0)==S.size()-1) tmp=S;\n  cout<<dfs(tmp,0)<<endl;  \n  return 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include<bits/stdc++.h>\nusing namespace std;\n\nusing ll=long long;\nconst ll INF=1e9;\nvoid cmax(ll &lhs,ll rhs){\n    lhs=max(lhs,rhs);\n}\nvoid cmin(ll &lhs,ll rhs){\n    lhs=min(lhs,rhs);\n}\nint main(){\n    string s;\n    cin>>s;\n    int n=s.size();\n    vector<vector<ll>> dpmax(n,vector<ll>(n+1,-INF));\n    vector<vector<ll>> dpmin(n,vector<ll>(n+1,INF));\n    for(int k=1;k<=n;k++){\n        for(int l=0;l+k<=n;l++){\n            int r=l+k;\n            if(k==1){\n                if(isdigit(s[l])){\n                    dpmax[l][r]=s[l]-'0';\n                    dpmin[l][r]=s[l]-'0';\n                }\n            }\n            else if(s[l]=='(' || s[r-1]==')'){\n                int cnt=0;\n                for(int i=l;i<r;i++){\n                    cnt+=(int)(isdigit(s[i]));\n                }\n                if(cnt>=2){\n                    if(s[l]=='('){\n                        dpmax[l][r]=dpmax[l+1][r];\n                        dpmin[l][r]=dpmin[l+1][r];\n                    }\n                    else{\n                        dpmax[l][r]=dpmax[l][r-1];\n                        dpmin[l][r]=dpmin[l][r-1];\n                    }\n                }\n            }\n            else{\n                for(int i=l;i<r;i++){\n                    if(s[i]=='+'){\n                        cmax(dpmax[l][r],dpmax[l][i]+dpmax[i+1][r]);\n                        cmin(dpmin[l][r],dpmin[l][i]+dpmin[i+1][r]);\n                    }\n                    if(s[i]=='-'){\n                        cmax(dpmax[l][r],dpmax[l][i]-dpmin[i+1][r]);\n                        cmin(dpmin[l][r],dpmin[l][i]-dpmax[i+1][r]);\n                    }\n                }\n\n            }\n        }\n    }\n    cout<<dpmax[0][n]<<endl;\n\n    return 0;\n}\n"
  },
  {
    "language": "C++",
    "code": "#include<iostream>\n#include<cstdio>\n#include<climits>\n#include<cassert>\n#include<cstring>\n#include<sstream>\n#include<bitset>\n#include<deque>\n#include<queue>\n#include<algorithm>\n#include<vector>\n#include<map>\n#include<set>\n\n#define REP(i,s,n) for(int i=s;i<n;++i)\n#define rep(i,n) REP(i,0,n)\n\nusing namespace std;\n\n#define MAX 210\n#define MINI 0\n#define MAXI 1\nlong long dp[MAX][MAX][2];\n\nint getPos(string &text,int p) {\n  int cnt = 0;\n  rep(i,(int)text.size()) {\n    if( isdigit(text[i]) ) {\n      if( cnt == p ) return i;\n      ++cnt;\n    }\n  }\n  assert(false);\n}\n\nvoid fix(string &text,string &L,string &R) {\n  string tmp = text;\n  rep(i,(int)text.size()) {\n    if( text[i] == '(' || text[i] == ')' ) {\n      text[i] = ' ';\n    }\n  }\n  {\n    stringstream ss;\n    ss << text;\n    string new_text = \"\";\n    while( ss >> text ) new_text += text;\n    text = new_text;\n  }\n  L = R = string((int)text.size(),'o');\n  for(int i=0;i<(int)text.size();i+=2) {\n    assert( isdigit(text[i]) );\n    int p = getPos(tmp,i/2);\n    if( p - 1 >= 0 && tmp[p-1] == '(' ) L[i] = 'x';\n    if( p + 1 < (int)tmp.size() && tmp[p+1] == ')' ) R[i] = 'x';\n  }\n}\n\nvoid compute(string text) {\n  string L,R;\n  fix(text,L,R);\n  /*\n  cout << \"new text = \" << text << endl;\n  cout << \"L        = \" << L << endl;\n  cout << \"R        = \" << R << endl;\n  */\n  rep(i,MAX) rep(j,MAX) dp[i][j][MINI] = INT_MAX;\n  rep(i,MAX) rep(j,MAX) dp[i][j][MAXI] = -INT_MAX;\n  rep(i,(int)text.size()) if( isdigit(text[i]) ) {\n    dp[i][i][MINI] = dp[i][i][MAXI] = text[i] - '0';\n  }\n  int n = ((int)text.size()+1) / 2;\n  REP(i,2,n+1) {\n    for(int j=0;j<(int)text.size();j+=2) {\n      int k = j + ( i -1 ) * 2;\n      if( k >= (int)text.size() ) break;\n      if( L[k] == 'x' || R[j] == 'x' ) continue;\n      for(int l=j+1;l<(int)k;l+=2) {\n\tif( text[l] == '+' ) {\n\t  if( dp[j][l-1][MINI] != INT_MAX && dp[l+1][k][MINI] != INT_MAX ) {\n\t    dp[j][k][MINI] = min(dp[j][k][MINI],\n\t\t\t\t dp[j][l-1][MINI]+dp[l+1][k][MINI]);\n\t  }\n\t  if( dp[j][l-1][MAXI] != -INT_MAX && dp[l+1][k][MAXI] != -INT_MAX ) {\n\t    dp[j][k][MAXI] = max(dp[j][k][MAXI],\n\t\t\t\t dp[j][l-1][MAXI]+dp[l+1][k][MAXI]);\n\t  }\n\t} else {\n\t  if( dp[j][l-1][MINI] != INT_MAX && dp[l+1][k][MAXI] != -INT_MAX ) {\n\t    dp[j][k][MINI] = min(dp[j][k][MINI],\n\t\t\t\t dp[j][l-1][MINI]-dp[l+1][k][MAXI]);\n\t  }\n\t  if( dp[j][l-1][MAXI] != -INT_MAX && dp[l+1][k][MINI] != INT_MAX ) {\n\t    dp[j][k][MAXI] = max(dp[j][k][MAXI],\n\t\t\t\t dp[j][l-1][MAXI]-dp[l+1][k][MINI]);\n\t  }\n\t}\n      }\n    }\n  }\n  cout << dp[0][(int)text.size()-1][MAXI] << endl;\n}\n\nint main() {\n  string text;\n  cin >> text;\n  compute(text);\n  return 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include <iostream>\n#include <cstring>\n#include <algorithm>\n#include <set>\n\nusing namespace std;\n\n#define MIN first\n#define MAX second\nconstexpr int MAX_S = 252;\nconstexpr int INF = (1 << 29);\n\nstring S;\npair<int, int> mem[MAX_S][MAX_S];\n\nvoid init(int N)\n{\n    for (int i = 0; i < N; i++) {\n        for (int j = 0; j < N; j++) {\n            mem[i][j] = {+INF, -INF};\n        }\n    }\n}\n\nvoid update_max(int& l, int r)\n{   \n    if (l < r) l = r;\n}\n\nvoid update_min(int& l, int r)\n{\n    if (l > r) l = r;\n}\n\n// テ・ツ個コテゥツ鳴禿」ツ?ョpair(MIN, MAX)\npair<int, int> rec(int L, int R)\n{\n    pair<int, int>& res = mem[L][R];\n    if (res != make_pair(+INF, -INF)) {\n        return res;\n    }\n    \n    if (R - L == 0) {\n        int v = S[L] - '0';\n        return (res = make_pair(v, v));\n    }\n\n    if (S[L] == '(' && R - L > 2) {\n        update_min(res.MIN, rec(L + 1, R).MIN);\n        update_max(res.MAX, rec(L + 1, R).MAX);\n    }\n\n    if (S[R] == ')' && R - L > 2) {\n        update_min(res.MIN, rec(L, R - 1).MIN);\n        update_max(res.MAX, rec(L, R - 1).MAX);\n    }\n    \n    for (int i = L + 1; i <= R - 1; i++) {\n        char c = S[i];   \n        if (c != '+' && c != '-') continue;                 \n        \n        auto res_l = rec(L, i - 1); // Left\n        auto res_r = rec(i + 1, R); // Right\n\n        if (c == '+') {            \n            update_min(res.MIN, res_l.MIN + res_r.MIN);\n            update_max(res.MAX, res_l.MAX + res_r.MAX);            \n        }\n        if (c == '-') {           \n            update_min(res.MIN, res_l.MIN - res_r.MAX);\n            update_max(res.MAX, res_l.MAX - res_r.MIN);\n        }\n    } \n    return res;\n}\n\nvoid solve()\n{\n    int N = S.size();\n    init(N);\n    cout << rec(0, N - 1).MAX << endl;    \n}\n\nint main()\n{\n    cin >> S;\n    solve();    \n    return 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\n#define N 201\nusing namespace std;\n\n/*\nint p;\nint bnf(){\n  int res=0;\n  while(p<S.size()){\n    if(S[p]=='(')p++,res=bnf();\n    else if(isdigit(S[p]))res=S[p++]-'0';\n    else if(S[p]=='+')p++,res+=bnf();\n    else if(S[p]=='-')p++,res-=bnf();\n    else break;\n    }\n  p++;\n  return res;\n  }\n*/\n\n\nint skip(string &str,int i){\n  if(str[i]!='(')return i;\n  string res;\n  int cnt=1;i++;\n  while(1) {\n    if(str[i]=='(')cnt++;\n    if(str[i]==')')cnt--;\n    if(!cnt)break;\n    res+=str[i++];\n  }\n  return i;\n}\n\n\nbool check(char ch){return ch=='+'||ch=='-';}\nbool check(string str){\n  for(int i=1;i<(int)str.size()-1;i++)\n    if(str[i-1]=='('&&isdigit(str[i])&&str[i+1]==')')return 0;\n  return 1;\n}\n\nmap<string,int>mem[2];\nint dfs(string str,int flg){\n  \n  if(str.size()==1) return str[0]-'0';\n  if(mem[flg].count(str)) return mem[flg][str];\n  if(skip(str,0)==(int)str.size()-1)return dfs(str.substr(1,str.size()-2),flg);\n  \n  int res=flg? 1e9:-1e9,cnt=0;\n  for(int i=0;i<str.size()-1;i++){\n    if(str[i]=='(')cnt++;\n    if(str[i]==')')cnt--;\n    if(!check(str[i+1]))continue;\n    string L=str.substr(0,i+1),R=str.substr(i+2,str.size()-i-2);\n    int t=cnt;\n    if(cnt&&check(str[i+1]))while(cnt)cnt--,L+=')',R='('+R;\n    if(cnt)continue;\n    cnt=t;\n    //    cout <<\"cnt=\"<<cnt<<\"|\"<< L<<\"|\"<<str[i+1]<< \"|\"<<R<<\"|\"<<endl;    \n    if(!check(L))continue;//||!check(R))continue;\n    \n    int Lmx=dfs(L,0),Lmn=dfs(L,1);\n    int Rmx=dfs(R,0),Rmn=dfs(R,1);\n    if(str[i+1]=='-') res=flg? min(res,Lmn-Rmx):max(res,Lmx-Rmn);\n    if(str[i+1]=='+') res=flg? min(res,Lmn+Rmn):max(res,Lmx+Rmx);\n  }\n  return mem[flg][str]=res;\n}\n\nint main(){\n  string S;\n  cin>>S;\n  cout<<dfs(S,0)<<endl;  \n  return 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include <cstdio>\n#include <cstdint>\n#include <cassert>\n#include <cctype>\n#include <string>\n#include <vector>\n#include <algorithm>\n\nusing MinMax = std::pair<int, int>;\n\nconstexpr int INF=1<<29;\nconstexpr MinMax INIT(INF, -INF);\n\nstd::vector<std::vector<MinMax>> memo;\n\nMinMax rec(const std::string& s, size_t left, size_t right) {\n  MinMax& res=memo[left][right];\n  if (res != INIT) return res;\n\n  if (right == left+1) {\n    int v=s[left]-'0';\n    return (res = {v, v});\n  }\n  if (s[left] == '(' && right-left > 3) {\n    MinMax p=rec(s, left+1, right);\n    res.first = std::min(res.first, p.first);\n    res.second = std::max(res.second, p.second);\n  }\n  if (s[right-1] == ')' && right-left > 3) {\n    MinMax p=rec(s, left, right-1);\n    res.first = std::min(res.first, p.first);\n    res.second = std::max(res.second, p.second);\n  }\n  for (size_t i=left+1; i+1<right; ++i) {\n    char op=s[i];\n    if (op == '+' || op == '-') {\n      MinMax pl=rec(s, left, i);\n      MinMax pr=rec(s, i+1, right);\n      if (op == '+') {\n        res.first = std::min(res.first, pl.first+pr.first);\n        res.second = std::max(res.second, pl.second+pr.second);\n      } else {\n        res.first = std::min(res.first, pl.first-pr.second);\n        res.second = std::max(res.second, pl.second-pr.first);\n      }\n    }\n  }\n  return res;\n}\n\nint main() {\n  char buf[256];\n  scanf(\"%s\", buf);\n  std::string S=buf;\n\n  size_t n=S.length();\n  memo.assign(n+1, std::vector<MinMax>(n+1, INIT));\n  \n  printf(\"%d\\n\", rec(S, 0, n).second);\n}\n\n"
  },
  {
    "language": "C++",
    "code": "#include<bits/stdc++.h>\nusing namespace std;\n#define INF (1e8)\n#define MAX 205\nint n;\nchar s[MAX];\n\nint dpA[MAX][MAX];\nint dpB[MAX][MAX];\nbool flgA[MAX][MAX];\nbool flgB[MAX][MAX];\n\nint solveA(int,int);\nint solveB(int,int);\n\nint main(){\n  scanf(\"%s\",s);\n  n=strlen(s);\n  printf(\"%d\\n\",solveA(0,n));\n  return 0;\n}\n\nint solveA(int l,int r){\n  if(flgA[l][r])return dpA[l][r];\n  flgA[l][r]=true;\n  int res=-INF,cnt=0,num=0;\n  for(int i=l;i<r;i++){\n    if(s[i]=='+'){\n      if(l<=i-3&&'0'<=s[i-1]&&s[i-1]<='9'&&s[i-2]=='(')continue;\n      res=max(res, solveA(l,i)+solveA(i+1,r));\n    }else if(s[i]=='-'){\n      if(l<=i-3&&'0'<=s[i-1]&&s[i-1]<='9'&&s[i-2]=='(')continue;\n      res=max(res, solveA(l,i)-solveB(i+1,r));\n    }else if('0'<=s[i]&&s[i]<='9'){\n      cnt++;\n      num=s[i]-'0';\n    }\n  }\n  if(cnt==1)res=num;\n  return dpA[l][r]=res;\n}\n\nint solveB(int l,int r){\n  if(flgB[l][r])return dpB[l][r];\n  flgB[l][r]=true;\n  int res=INF,cnt=0,num=0;\n  for(int i=l;i<r;i++){\n    if(s[i]=='+'){\n      if(l<=i-3&&'0'<=s[i-1]&&s[i-1]<='9'&&s[i-2]=='(')continue;\n      res=min(res, solveB(l,i)+solveB(i+1,r));\n    }else if(s[i]=='-'){\n      if(l<=i-3&&'0'<=s[i-1]&&s[i-1]<='9'&&s[i-2]=='(')continue;\n      res=min(res, solveB(l,i)-solveA(i+1,r));\n    }else if('0'<=s[i]&&s[i]<='9'){\n      cnt++;\n      num=s[i]-'0';\n    }\n  }\n  if(cnt==1)res=num;\n  return dpB[l][r]=res;\n}"
  },
  {
    "language": "C++",
    "code": "#include <iostream>\n#include <vector>\n#include <algorithm>\nusing namespace std;\nconst int inf = 1e9;\n\nbool isvalid(int b, int e, vector<int> &num, string &str){\n    if(b==e || (str[num[b]+1]!=')' && str[num[e]-1]!='(')){\n        return true;\n    }\n    return false;\n}\n\nint main(){\n    string str;\n    cin >> str;\n    vector<int> num, op;\n    for(int i=0; i<(int)str.length(); i++){\n        if('0'<=str[i] && str[i]<='9') num.push_back(i);\n        if(str[i]=='+' || str[i]=='-') op.push_back(i);\n    }\n    \n    int n = num.size();\n    vector<vector<int> > dpmin(n, vector<int>(n, inf)), dpmax(n, vector<int>(n, -inf));;\n    for(int i=0; i<n; i++) dpmin[i][i] = dpmax[i][i] = str[num[i]]-'0';\n    \n    for(int j=1; j<n; j++){\n        for(int i=0; i+j<n; i++){\n            for(int k=0; k<j; k++){\n                if(isvalid(i, i+k, num, str) && isvalid(i+k+1, i+j, num, str)){\n                    if(str[op[i+k]] == '+'){\n                        dpmax[i][i+j] = max(dpmax[i][i+j], dpmax[i][i+k]+dpmax[i+k+1][i+j]);\n                        dpmin[i][i+j] = min(dpmin[i][i+j], dpmin[i][i+k]+dpmin[i+k+1][i+j]);\n                    }else{\n                        dpmax[i][i+j] = max(dpmax[i][i+j], dpmax[i][i+k]-dpmin[i+k+1][i+j]);\n                        dpmin[i][i+j] = min(dpmin[i][i+j], dpmin[i][i+k]-dpmax[i+k+1][i+j]);\n                    }\n                }\n            }\n        }\n    }\n    cout << dpmax[0][n-1] << endl;\n    return 0;\n}\n\n"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\n\nusing i2 = std::array<int64_t, 2>;\n\nstd::string S;\n\ni2 calcFormula(int& s_i);\n\nint main()\n{\n\tstd::cin >> S;\n\tint s_i{};\n\tprintf(\"%lld\\n\", calcFormula(s_i)[1]);\n\n\treturn 0;\n}\n\ni2 calcFormula(int& s_i)\n{\n\tstd::vector<int> num;\n\tstd::vector<bool> isBegin(1), isEnd(1);\n\twhile (S[s_i] == '(')\n\t{\n\t\ts_i++;\n\t\tisBegin.back() = true;\n\t}\n\tnum.push_back(S[s_i] - '0');\n\ts_i++;\n\twhile (S[s_i] == ')')\n\t{\n\t\ts_i++;\n\t\tisEnd.back() = true;\n\t}\n\tstd::vector<char> operators;\n\twhile (s_i < (int)S.size())\n\t{\n\t\toperators.push_back(S[s_i]);\n\t\ts_i++;\n\t\tisBegin.push_back(false);\n\t\twhile (S[s_i] == '(')\n\t\t{\n\t\t\tisBegin.back() = true;\n\t\t\ts_i++;\n\t\t}\n\t\tnum.push_back(S[s_i] - '0');\n\t\ts_i++;\n\t\tisEnd.push_back(false);\n\t\twhile (s_i < (int)S.size() && S[s_i] == ')')\n\t\t{\n\t\t\tisEnd.back() = true;\n\t\t\ts_i++;\n\t\t}\n\t}\n\tusing vi = std::vector<int64_t>;\n\tusing vvi = std::vector<vi>;\n\tint size{(int)num.size()};\n\tvvi minTable(size + 1, vi(size + 1, 1ll << 60)), maxTable(size + 1, vi(size + 1, -(1ll << 60)));\n\tfor (int i{}; i < size; i++)\n\t\tminTable[i][i + 1] = maxTable[i][i + 1] = num[i];\n\tfor (int width{2}; width <= size; width++)\n\t\tfor (int left{}; left + width <= size; left++)\n\t\t{\n\t\t\tint right{left + width};\n\t\t\tif (isEnd[left] || isBegin[right - 1]) continue;\n\t\t\tfor (int mid{left + 1}; mid < right; mid++)\n\t\t\t{\n\t\t\t\tif (operators[mid - 1] == '+')\n\t\t\t\t{\n\t\t\t\t\tminTable[left][right] = std::min(minTable[left][right], minTable[left][mid] + minTable[mid][right]);\n\t\t\t\t\tmaxTable[left][right] = std::max(maxTable[left][right], maxTable[left][mid] + maxTable[mid][right]);\n\t\t\t\t}\n\t\t\t\telse\n\t\t\t\t{\n\t\t\t\t\tminTable[left][right] = std::min(minTable[left][right], minTable[left][mid] - maxTable[mid][right]);\n\t\t\t\t\tmaxTable[left][right] = std::max(maxTable[left][right], maxTable[left][mid] - minTable[mid][right]);\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\treturn {minTable[0][size], maxTable[0][size]};\n}\n"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\nusing namespace std;\ntypedef pair<int,int>P;\n#define F first\n#define S second\nint INF=1e9;\nstring s;\nP init=P(INF,-INF);\nvector<vector<P> >dp(200,vector<P>(200,init));\n\nP dfs(int l,int r){\n\tif(l==r)return P(s[l]-'0',s[l]-'0');\n\tif(dp[l][r]!=init)return dp[l][r];\n\tP res=init;\n\tif(s[l]=='('&&r-l>2) res=dfs(l+1,r);\n\tif(s[r]==')'&&r-l>2) res=dfs(l,r-1);\n\tfor(int i=l+1;i<r;i++){\n\t\tif(!(s[i]=='-'||s[i]=='+'))continue;\n\t\tP a=dfs(l,i-1);\n\t\tP b=dfs(i+1,r);\n\t\tif(s[i]=='-'){\n\t\t\tres.F=min(res.F,a.F-b.S);\n\t\t\tres.S=max(res.S,a.S-b.F);\n\t\t}\n\t\tif(s[i]=='+'){\n\t\t\tres.F=min(res.F,a.F+b.F);\n\t\t\tres.S=max(res.S,a.S+b.S);\n\t\t}\n\t}\n\treturn dp[l][r]=res;\n}\n\nmain(){\n\tcin>>s;\n\tcout<<dfs(0,s.size()-1).S<<endl;\n}\n"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\n#define range(i, a, n) for(int (i) = (a); (i) < (n); (i)++)\n#define rep(i, n) for(int (i) = 0; (i) < (n); (i)++)\nusing namespace std;\n\n#define pb push_back\ntypedef vector<int> vi;\ntypedef vector<vi> vvi;\ntypedef vector<string> vs;\n\nconst int inf = 1 << 24;\n\nint main(void){\n    string s; cin >> s;\n\n    vi num, br_l, br_r;\n    string op;\n    rep(i, (int)s.size()){\n        if(isdigit(s[i])){\n            num.pb(s[i] - '0');\n            if(0 <= i - 1 && s[i - 1] == '(')            br_l.pb(true);\n            else                                         br_l.pb(false);\n            if(i + 1 < (int)s.size() && s[i + 1] == ')') br_r.pb(true);\n            else                                         br_r.pb(false);\n        }\n        if(s[i] == '+' || s[i] == '-'){\n            op.pb(s[i]);\n        }\n    }\n\n    vvi dp_max(num.size(), vi(num.size(), -inf));\n    vvi dp_min(num.size(), vi(num.size(), inf));\n    rep(i, (int)num.size()){\n        dp_max[i][i] = dp_min[i][i] = num[i];\n    }\n\n    range(i, 2, (int)num.size() + 1){    // len \n        rep(j, (int)num.size() - i + 1){ // l such [l, l + len)\n            int l = j, r = j + i - 1;\n            if(br_r[l] || br_l[r]) continue;\n\n            range(k, l + 1, r + 1){\n                //if(br_l[k - 1] || br_r[k]) continue;\n                \n                if(op[k - 1] == '+'){\n                    if(dp_min[l][k - 1] != inf && dp_min[k][r] != inf)\n                        dp_min[l][r] = min(dp_min[l][r], dp_min[l][k - 1] + dp_min[k][r]);\n                    if(dp_max[l][k - 1] != -inf && dp_max[k][r] != -inf)\n                        dp_max[l][r] = max(dp_max[l][r], dp_max[l][k - 1] + dp_max[k][r]);\n                }\n                else {\n                    if(dp_min[l][k - 1] != inf && dp_max[k][r] != -inf)\n                        dp_min[l][r] = min(dp_min[l][r], dp_min[l][k - 1] - dp_max[k][r]);\n                    if(dp_max[l][k - 1] != -inf && dp_min[k][r] != inf)\n                        dp_max[l][r] = max(dp_max[l][r], dp_max[l][k - 1] - dp_min[k][r]);\n                }\n            }\n        }\n    }\n\n    cout << dp_max[0][(int)num.size() - 1] << endl;\n\n    return 0;\n}"
  },
  {
    "language": "C",
    "code": "// AOJ 2710 An Equation in a Mine\n// 2018.2.14 bal4u\n\n#include <stdio.h>\n#include <ctype.h>\n#include <string.h>\n\n#define INF 0x10101010\n\nunsigned char s[202], sgn[202], num[202];\nint min[202][202], max[202][202];\n\nint main()\n{\n\tint n, i, j, k, l, x;\n\tunsigned char *p, *qs, *qn;\n\n\tfgets(p=s, 202, stdin);\n\tqs = sgn, qn = num;\tfor (i = 0; *p >= ' '; i++) {\n\t\tif (isdigit(*p)) *qn++ = i;\n\t\telse if (*p == '+' || *p == '-') *qs++ = i;\n\t\tp++;\n\t}\n\tn = qn - num;\n\n\tmemset(min,  INF, sizeof(min));\n\tmemset(max, -INF, sizeof(max));\n    for (i = 0; i < n; i++) min[i][i] = max[i][i] = s[num[i]] & 0xf;\n\n\tfor(l = 1; l < n ; l++) for(i = 0; (j=i+l) < n; i++) {\n\t\tfor (k = i; k < j; k++) {\n\t\t\tif (  i != k && (s[num[  i]+1] == ')' || s[num[k]-1] == '(')) continue;\n\t\t\tif (k+1 != j && (s[num[k+1]+1] == ')' || s[num[j]-1] == '(')) continue;\n\n\t\t\tif (s[sgn[k]] == '+') {\n\t\t\t\tx = max[i][k] + max[k+1][j];\n\t\t\t\tif (max[i][j] < x) max[i][j] = x;\n\t\t\t\tx = min[i][k] + min[k+1][j];\n\t\t\t\tif (min[i][j] > x) min[i][j] = x;\n\t\t\t} else {\n\t\t\t\tx = max[i][k] - min[k+1][j];\n\t\t\t\tif (max[i][j] < x) max[i][j] = x;\n\t\t\t\tx = min[i][k] - max[k+1][j];\n\t\t\t\tif (min[i][j] > x) min[i][j] = x;\n            }\n        }\n    }\n    printf(\"%d\\n\", max[0][n-1]);\n    return 0;\n}\n"
  },
  {
    "language": "D",
    "code": "import std.algorithm;\nimport std.ascii;\nimport std.array;\nimport std.container;\nimport std.conv;\nimport std.numeric;\nimport std.stdio;\nimport std.string;\nimport std.typecons;\n\nvoid log(A...)(A arg) {\n    stderr.writeln(arg);\n}\nint size(T)(in T s) {\n    return cast(int)s.length;\n}\n\nconst int INF = 10000;\n\nint op(char c, int a, int b) {\n    if (c == '+') return a + b;\n    if (c == '-') return a - b;\n    assert(false);\n}\n\nint next_op_index(in string s, int i) {\n    for (int j = i; j < s.size; j++) {\n        if (s[j] == '+' || s[j] == '-') return j;\n    }\n    throw new Exception(\"\");\n}\nint prev_op_index(in string s, int i) {\n    for (int j = i; j >= 0; j--) {\n        if (s[j] == '+' || s[j] == '-') return j;\n    }\n    throw new Exception(\"\");\n}\n\nvoid main() {\n    string s = readln.chomp;\n\n    auto t_index = new int[s.size]; t_index[] = -1;\n    int cur = 0;\n    foreach (i, c; s) {\n        if (c == '(' || c == ')') continue;\n        t_index[i] = cur++;\n    }\n    auto buf = new char[cur];\n    foreach (i, c; s) {\n        if (c == '(' || c == ')') continue;\n        buf[t_index[i]] = c;\n    }\n    string t = buf.idup;\n\n    int N = t.size;\n    auto open_banned = new bool[N];\n    auto close_banned = new bool[N];\n    foreach (i, c; s) {\n        try {\n            if (c == '(')      close_banned[t_index[next_op_index(s, i)]] = true;\n            else if (c == ')') open_banned[t_index[prev_op_index(s, i)]] = true;\n        } catch (Exception e) {}\n    }\n\n    auto dp_min = new int[][](N + 1, N + 1);\n    auto dp_max = new int[][](N + 1, N + 1);\n    foreach (ref a; dp_max) a[] = -INF;\n    foreach (ref a; dp_min) a[] = INF;\n    foreach (i, c; t) {\n        if (c.isDigit) dp_max[i][i + 1] = dp_min[i][i + 1] = cast(int)(c - '0');\n    }\n\n    for (int k = 2; k <= N; k++) {\n        for (int i = 0; i + k <= N; i++) {\n            for (int j = i + 1; j < i + k; j++) {\n                if (! (t[j] == '+' || t[j] == '-')) continue;\n                int lcount = t[i .. j].count!isDigit;\n                int rcount = t[j .. i + k].count!isDigit;\n                if (lcount >= 2 && close_banned[j]) continue;\n                if (rcount >= 2 && open_banned[j]) continue;\n                switch (t[j]) {\n                    case '+':\n                        dp_max[i][i + k] = max(dp_max[i][i + k], dp_max[i][j] + dp_max[j + 1][i + k]);\n                        dp_min[i][i + k] = min(dp_min[i][i + k], dp_min[i][j] + dp_min[j+ 1][i + k]);\n                        break;\n                    case '-':\n                        dp_max[i][i + k] = max(dp_max[i][i + k], dp_max[i][j] - dp_min[j + 1][i + k]);\n                        dp_min[i][i + k] = min(dp_min[i][i + k], dp_min[i][j] - dp_max[j + 1][i + k]);\n                        break;\n                    case '(':\n\n                    default:\n                        break;\n                } \n            }\n        }\n    }\n    /*\n    foreach (L; dp_max) log(L);\n    log();\n    foreach (L; dp_min) log(L);\n    */\n    writeln(dp_max[0][t.size]);\n}"
  },
  {
    "language": "D",
    "code": "import std.algorithm;\nimport std.ascii;\nimport std.array;\nimport std.container;\nimport std.conv;\nimport std.numeric;\nimport std.stdio;\nimport std.string;\nimport std.typecons;\n\nvoid log(A...)(A arg) {\n    stderr.writeln(arg);\n}\nint size(T)(in T s) {\n    return cast(int)s.length;\n}\n\nconst int INF = 10000;\n\nint op(char c, int a, int b) {\n    if (c == '+') return a + b;\n    if (c == '-') return a - b;\n    assert(false);\n}\n\nint next_op_index(in string s, int i) {\n    for (int j = i; j < s.size; j++) {\n        if (s[j] == '+' || s[j] == '-') return j;\n    }\n    throw new Exception(\"\");\n}\nint prev_op_index(in string s, int i) {\n    for (int j = i; j >= 0; j--) {\n        if (s[j] == '+' || s[j] == '-') return j;\n    }\n    throw new Exception(\"\");\n}\n\nvoid main() {\n    string s = readln.chomp;\n\n    auto t_index = new int[s.size]; t_index[] = -1;\n    int cur = 0;\n    foreach (i, c; s) {\n        if (c == '(' || c == ')') continue;\n        t_index[i] = cur++;\n    }\n    auto buf = new char[cur];\n    foreach (i, c; s) {\n        if (c == '(' || c == ')') continue;\n        buf[t_index[i]] = c;\n    }\n    string t = buf.idup;\n\n    int N = t.size;\n    auto open_banned = new bool[N];\n    auto close_banned = new bool[N];\n    foreach (int i, c; s) {\n        try {\n            if (c == '(')      close_banned[t_index[next_op_index(s, i)]] = true;\n            else if (c == ')') open_banned[t_index[prev_op_index(s, i)]] = true;\n        } catch (Exception e) {}\n    }\n\n    auto dp_min = new int[][](N + 1, N + 1);\n    auto dp_max = new int[][](N + 1, N + 1);\n    foreach (ref a; dp_max) a[] = -INF;\n    foreach (ref a; dp_min) a[] = INF;\n    foreach (i, c; t) {\n        if (c.isDigit) dp_max[i][i + 1] = dp_min[i][i + 1] = cast(int)(c - '0');\n    }\n\n    for (int k = 2; k <= N; k++) {\n        for (int i = 0; i + k <= N; i++) {\n            for (int j = i + 1; j < i + k; j++) {\n                if (! (t[j] == '+' || t[j] == '-')) continue;\n                int lcount = cast(int)t[i .. j].count!isDigit;\n                int rcount = cast(int)t[j .. i + k].count!isDigit;\n                if (lcount >= 2 && close_banned[j]) continue;\n                if (rcount >= 2 && open_banned[j]) continue;\n                switch (t[j]) {\n                    case '+':\n                        dp_max[i][i + k] = max(dp_max[i][i + k], dp_max[i][j] + dp_max[j + 1][i + k]);\n                        dp_min[i][i + k] = min(dp_min[i][i + k], dp_min[i][j] + dp_min[j+ 1][i + k]);\n                        break;\n                    case '-':\n                        dp_max[i][i + k] = max(dp_max[i][i + k], dp_max[i][j] - dp_min[j + 1][i + k]);\n                        dp_min[i][i + k] = min(dp_min[i][i + k], dp_min[i][j] - dp_max[j + 1][i + k]);\n                        break;\n                    default:\n                        break;\n                } \n            }\n        }\n    }\n    /*\n    foreach (L; dp_max) log(L);\n    log();\n    foreach (L; dp_min) log(L);\n    */\n    writeln(dp_max[0][t.size]);\n}"
  },
  {
    "language": "D",
    "code": "import std.algorithm;\nimport std.ascii;\nimport std.array;\nimport std.container;\nimport std.conv;\nimport std.numeric;\nimport std.stdio;\nimport std.string;\nimport std.typecons;\n\nvoid log(A...)(A arg) {\n    stderr.writeln(arg);\n}\nint size(T)(in T s) {\n    return cast(int)s.length;\n}\n\nconst int INF = 10000;\n\nint op(char c, int a, int b) {\n    if (c == '+') return a + b;\n    if (c == '-') return a - b;\n    assert(false);\n}\n\nint next_op_index(in string s, int i) {\n    for (int j = i; j < s.size; j++) {\n        if (s[j] == '+' || s[j] == '-') return j;\n    }\n    throw new Exception(\"\");\n}\nint prev_op_index(in string s, int i) {\n    for (int j = i; j >= 0; j--) {\n        if (s[j] == '+' || s[j] == '-') return j;\n    }\n    throw new Exception(\"\");\n}\n\nvoid main() {\n    string s = readln.chomp;\n\n    auto t_index = new int[s.size]; t_index[] = -1;\n    int cur = 0;\n    foreach (i, c; s) {\n        if (c == '(' || c == ')') continue;\n        t_index[i] = cur++;\n    }\n    auto buf = new char[cur];\n    foreach (i, c; s) {\n        if (c == '(' || c == ')') continue;\n        buf[t_index[i]] = c;\n    }\n    string t = buf.idup;\n\n    int N = t.size;\n    auto open_banned = new bool[N];\n    auto close_banned = new bool[N];\n    foreach (int i, c; s) {\n        try {\n            if (c == '(')      close_banned[t_index[next_op_index(s, i)]] = true;\n            else if (c == ')') open_banned[t_index[prev_op_index(s, i)]] = true;\n        } catch (Exception e) {}\n    }\n\n    auto dp_min = new int[][](N + 1, N + 1);\n    auto dp_max = new int[][](N + 1, N + 1);\n    foreach (ref a; dp_max) a[] = -INF;\n    foreach (ref a; dp_min) a[] = INF;\n    foreach (i, c; t) {\n        if (c.isDigit) dp_max[i][i + 1] = dp_min[i][i + 1] = cast(int)(c - '0');\n    }\n\n    for (int k = 2; k <= N; k++) {\n        for (int i = 0; i + k <= N; i++) {\n            for (int j = i + 1; j < i + k; j++) {\n                if (! (t[j] == '+' || t[j] == '-')) continue;\n                int lcount = cast(int)t[i .. j].count!isDigit;\n                int rcount = cast(int)t[j .. i + k].count!isDigit;\n                if (lcount >= 2 && close_banned[j]) continue;\n                if (rcount >= 2 && open_banned[j]) continue;\n                switch (t[j]) {\n                    case '+':\n                        dp_max[i][i + k] = max(dp_max[i][i + k], dp_max[i][j] + dp_max[j + 1][i + k]);\n                        dp_min[i][i + k] = min(dp_min[i][i + k], dp_min[i][j] + dp_min[j+ 1][i + k]);\n                        break;\n                    case '-':\n                        dp_max[i][i + k] = max(dp_max[i][i + k], dp_max[i][j] - dp_min[j + 1][i + k]);\n                        dp_min[i][i + k] = min(dp_min[i][i + k], dp_min[i][j] - dp_max[j + 1][i + k]);\n                        break;\n                    case '(':\n\n                    default:\n                        break;\n                } \n            }\n        }\n    }\n    /*\n    foreach (L; dp_max) log(L);\n    log();\n    foreach (L; dp_min) log(L);\n    */\n    writeln(dp_max[0][t.size]);\n}"
  },
  {
    "language": "Python",
    "code": "import math,string,itertools,fractions,heapq,collections,re,array,bisect,sys,random,time,copy,functools\n\nsys.setrecursionlimit(10**7)\ninf = 10**20\neps = 1.0 / 10**13\nmod = 10**9+7\ndd = [(-1,0),(0,1),(1,0),(0,-1)]\nddn = [(-1,0),(-1,1),(0,1),(1,1),(1,0),(1,-1),(0,-1),(-1,-1)]\n\ndef LI(): return [int(x) for x in sys.stdin.readline().split()]\ndef LI_(): return [int(x)-1 for x in sys.stdin.readline().split()]\ndef LF(): return [float(x) for x in sys.stdin.readline().split()]\ndef LS(): return sys.stdin.readline().split()\ndef I(): return int(sys.stdin.readline())\ndef F(): return float(sys.stdin.readline())\ndef S(): return input()\ndef pf(s): return print(s, flush=True)\n\n\ndef main():\n    s = S()\n    fm = {}\n\n    def sa(s):\n        a = []\n        for c in s:\n            if '0' <= c <= '9':\n                ci = int(c)\n                if len(a) > 0 and isinstance(a[-1], int):\n                    a[-1] = a[-1] * 10 + ci\n                else:\n                    a.append(ci)\n            else:\n                a.append(c)\n        return a\n\n    def f(s, sf):\n        key = (s, sf)\n        if key in fm:\n            return fm[key]\n        # print(s,sf)\n        a = sa(s)\n        l = len(a)\n        r = None\n        for i in range(2,l-2):\n            if not isinstance(a[i], int):\n                continue\n            if a[i-1] == '(' or a[i+1] == ')':\n                continue\n            tl = f(''.join(map(str, a[:i+1])), sf)\n            if tl is None:\n                continue\n            if a[i+1] == '+':\n                tr = f(''.join(map(str, a[i+2:])), sf)\n                if not tr is None:\n                    tl += tr\n                else:\n                    tl = None\n            else:\n                tr = f(''.join(map(str, a[i+2:])), not sf)\n                if not tr is None:\n                    tl -= tr\n                else:\n                    tl = None\n            if tl is None:\n                continue\n            if sf:\n                if r is None or r < tl:\n                    r = tl\n            else:\n                if r is None or r > tl:\n                    r = tl\n\n        kc = 0\n        for c in a:\n            if c == '(':\n                kc += 1\n            elif c == ')':\n                kc -= 1\n                if kc < 0:\n                    kc = 0\n        if kc > 0:\n            a += [')'] * kc\n        kc = 0\n        for c in a[::-1]:\n            if c == '(':\n                kc -= 1\n                if kc < 0:\n                    kc = 0\n            elif c == ')':\n                kc += 1\n        if kc > 0:\n            a = ['('] * kc + a\n\n        while '(' in a:\n            # print('while (', a)\n            i = len(a) - 1\n            while '(' != a[i]:\n                i -= 1\n            j = a.index(')', i)\n            if j-i < 2:\n                break\n            tr = a[i+1]\n            for k in range(i+2,j,2):\n                if a[k] == '+':\n                    tr += a[k+1]\n                else:\n                    tr -= a[k+1]\n            a[i:j+1] = [tr]\n\n        if not '(' in a:\n            # print('not (', a)\n            tr = a[0]\n            for i in range(1,len(a),2):\n                if a[i] == '+':\n                    tr += a[i+1]\n                else:\n                    tr -= a[i+1]\n            if sf:\n                if r is None or r < tr:\n                    r = tr\n            else:\n                if r is None or r > tr:\n                    r = tr\n\n        fm[key] = r\n        return r\n\n\n    r = f(s, True)\n    return r\n\n\nprint(main())\n\n"
  },
  {
    "language": "Python",
    "code": "import math,string,itertools,fractions,heapq,collections,re,array,bisect,sys,random,time,copy,functools\n\nsys.setrecursionlimit(10**7)\ninf = 10**20\neps = 1.0 / 10**13\nmod = 10**9+7\ndd = [(-1,0),(0,1),(1,0),(0,-1)]\nddn = [(-1,0),(-1,1),(0,1),(1,1),(1,0),(1,-1),(0,-1),(-1,-1)]\n\ndef LI(): return [int(x) for x in sys.stdin.readline().split()]\ndef LI_(): return [int(x)-1 for x in sys.stdin.readline().split()]\ndef LF(): return [float(x) for x in sys.stdin.readline().split()]\ndef LS(): return sys.stdin.readline().split()\ndef I(): return int(sys.stdin.readline())\ndef F(): return float(sys.stdin.readline())\ndef S(): return input()\ndef pf(s): return print(s, flush=True)\n\n\ndef main():\n    s = S()\n    fm = {}\n\n    def sa(s):\n        a = []\n        for c in s:\n            if '0' <= c <= '9':\n                ci = int(c)\n                if len(a) > 0 and isinstance(a[-1], int):\n                    a[-1] = a[-1] * 10 + ci\n                else:\n                    a.append(ci)\n            else:\n                a.append(c)\n        return a\n\n    def f(s, sf):\n        key = (s, sf)\n        if key in fm:\n            return fm[key]\n        # print(s,sf)\n        a = sa(s)\n        l = len(a)\n        if l == 1:\n            if isinstance(a[0], int):\n                return a[0]\n            return None\n        r = None\n        for i in range(0,l-2):\n            if not isinstance(a[i], int):\n                continue\n            if a[i-1] == '(' or a[i+1] == ')':\n                continue\n            tl = f(''.join(map(str, a[:i+1])), sf)\n            if tl is None:\n                continue\n            if a[i+1] == '+':\n                tr = f(''.join(map(str, a[i+2:])), sf)\n                if not tr is None:\n                    tl += tr\n                else:\n                    tl = None\n            else:\n                tr = f(''.join(map(str, a[i+2:])), not sf)\n                if not tr is None:\n                    tl -= tr\n                else:\n                    tl = None\n            if tl is None:\n                continue\n            if sf:\n                if r is None or r < tl:\n                    r = tl\n            else:\n                if r is None or r > tl:\n                    r = tl\n\n        kc = 0\n        for c in a:\n            if c == '(':\n                kc += 1\n            elif c == ')':\n                kc -= 1\n                if kc < 0:\n                    kc = 0\n        if kc > 0:\n            a += [')'] * kc\n        kc = 0\n        for c in a[::-1]:\n            if c == '(':\n                kc -= 1\n                if kc < 0:\n                    kc = 0\n            elif c == ')':\n                kc += 1\n        if kc > 0:\n            a = ['('] * kc + a\n\n        while '(' in a:\n            # print('while (', a)\n            i = len(a) - 1\n            while '(' != a[i]:\n                i -= 1\n            j = a.index(')', i)\n            if j-i < 2:\n                break\n            tr = a[i+1]\n            for k in range(i+2,j,2):\n                if a[k] == '+':\n                    tr += a[k+1]\n                else:\n                    tr -= a[k+1]\n            a[i:j+1] = [tr]\n\n        if not '(' in a:\n            # print('not (', a)\n            tr = a[0]\n            for i in range(1,len(a),2):\n                if a[i] == '+':\n                    tr += a[i+1]\n                else:\n                    tr -= a[i+1]\n            if sf:\n                if r is None or r < tr:\n                    r = tr\n            else:\n                if r is None or r > tr:\n                    r = tr\n\n        fm[key] = r\n        return r\n\n\n    r = f(s, True)\n    return r\n\n\nprint(main())\n\n"
  },
  {
    "language": "Python",
    "code": "import math,string,itertools,fractions,heapq,collections,re,array,bisect,sys,random,time,copy,functools\n\nsys.setrecursionlimit(10**7)\ninf = 10**20\neps = 1.0 / 10**13\nmod = 10**9+7\ndd = [(-1,0),(0,1),(1,0),(0,-1)]\nddn = [(-1,0),(-1,1),(0,1),(1,1),(1,0),(1,-1),(0,-1),(-1,-1)]\n\ndef LI(): return [int(x) for x in sys.stdin.readline().split()]\ndef LI_(): return [int(x)-1 for x in sys.stdin.readline().split()]\ndef LF(): return [float(x) for x in sys.stdin.readline().split()]\ndef LS(): return sys.stdin.readline().split()\ndef I(): return int(sys.stdin.readline())\ndef F(): return float(sys.stdin.readline())\ndef S(): return input()\ndef pf(s): return print(s, flush=True)\n\n\ndef main():\n    s = S()\n    fm = {}\n\n    def sa(s):\n        a = []\n        for c in s:\n            if '0' <= c <= '9':\n                ci = int(c)\n                if len(a) > 0 and isinstance(a[-1], int):\n                    a[-1] = a[-1] * 10 + ci\n                else:\n                    a.append(ci)\n            else:\n                a.append(c)\n        return a\n\n    def f(s, sf):\n        key = (s, sf)\n        if key in fm:\n            return fm[key]\n        # print(s,sf)\n        if s[0] == '(' and s[-1] == ')':\n            s = s[1:-1]\n        a = sa(s)\n        l = len(a)\n        if l == 1:\n            if isinstance(a[0], int):\n                return a[0]\n            return None\n        r = None\n        for i in range(0,l-2):\n            if not isinstance(a[i], int):\n                continue\n            if a[i-1] == '(' or a[i+1] == ')':\n                continue\n            tl = f(''.join(map(str, a[:i+1])), sf)\n            if tl is None:\n                continue\n            if a[i+1] == '+':\n                tr = f(''.join(map(str, a[i+2:])), sf)\n                if not tr is None:\n                    tl += tr\n                else:\n                    tl = None\n            else:\n                tr = f(''.join(map(str, a[i+2:])), not sf)\n                if not tr is None:\n                    tl -= tr\n                else:\n                    tl = None\n            if tl is None:\n                continue\n            if sf:\n                if r is None or r < tl:\n                    r = tl\n            else:\n                if r is None or r > tl:\n                    r = tl\n\n        kc = 0\n        for c in a:\n            if c == '(':\n                kc += 1\n            elif c == ')':\n                kc -= 1\n                if kc < 0:\n                    kc = 0\n        if kc > 0:\n            a += [')'] * kc\n        kc = 0\n        for c in a[::-1]:\n            if c == '(':\n                kc -= 1\n                if kc < 0:\n                    kc = 0\n            elif c == ')':\n                kc += 1\n        if kc > 0:\n            a = ['('] * kc + a\n\n        while '(' in a:\n            # print('while (', a)\n            i = len(a) - 1\n            while '(' != a[i]:\n                i -= 1\n            j = a.index(')', i)\n            if j-i < 2:\n                break\n            tr = a[i+1]\n            for k in range(i+2,j,2):\n                if a[k] == '+':\n                    tr += a[k+1]\n                else:\n                    tr -= a[k+1]\n            a[i:j+1] = [tr]\n\n        if not '(' in a:\n            # print('not (', a)\n            tr = a[0]\n            for i in range(1,len(a),2):\n                if a[i] == '+':\n                    tr += a[i+1]\n                else:\n                    tr -= a[i+1]\n            if sf:\n                if r is None or r < tr:\n                    r = tr\n            else:\n                if r is None or r > tr:\n                    r = tr\n\n        fm[key] = r\n        return r\n\n\n    r = f(s, True)\n    return r\n\n\nprint(main())\n\n"
  },
  {
    "language": "Python",
    "code": "import math,string,itertools,fractions,heapq,collections,re,array,bisect,sys,random,time,copy,functools\n\nsys.setrecursionlimit(10**7)\ninf = 10**20\neps = 1.0 / 10**13\nmod = 10**9+7\ndd = [(-1,0),(0,1),(1,0),(0,-1)]\nddn = [(-1,0),(-1,1),(0,1),(1,1),(1,0),(1,-1),(0,-1),(-1,-1)]\n\ndef LI(): return [int(x) for x in sys.stdin.readline().split()]\ndef LI_(): return [int(x)-1 for x in sys.stdin.readline().split()]\ndef LF(): return [float(x) for x in sys.stdin.readline().split()]\ndef LS(): return sys.stdin.readline().split()\ndef I(): return int(sys.stdin.readline())\ndef F(): return float(sys.stdin.readline())\ndef S(): return input()\ndef pf(s): return print(s, flush=True)\n\n\ndef main():\n    s = S()\n    fm = {}\n\n    a = []\n    for c in s:\n        if '0' <= c <= '9':\n            ci = int(c)\n            if len(a) > 0 and isinstance(a[-1], int):\n                a[-1] = a[-1] * 10 + ci\n            else:\n                a.append(ci)\n        else:\n            a.append(c)\n\n    def f(a):\n        key = tuple(a)\n        if key in fm:\n            return fm[key]\n        if len(a) == 2:\n            fm[key] = [inf,-inf]\n            return [inf,-inf]\n        for i in range(len(a)):\n            if a[i] != '(':\n                if i > 0:\n                    a = a[i:]\n                break\n        for i in range(len(a)-1,-1,-1):\n            if a[i] != ')':\n                a = a[:i+1]\n                break\n        if len(a) == 1:\n            r = [a[0],a[0]]\n            fm[key] = r\n            return r\n\n        ri = [inf]\n        ra = [-inf]\n        for i in range(1,len(a)-1):\n            if not a[i] in ['+','-']:\n                continue\n            fl = f(a[:i])\n            fr = f(a[i+1:])\n            if a[i] == '+':\n                ri.append(fl[0]+fr[0])\n                ra.append(fl[1]+fr[1])\n            else:\n                ri.append(fl[0]-fr[1])\n                ra.append(fl[1]-fr[0])\n\n        r = [min(ri), max(ra)]\n        fm[key] = r\n        return r\n\n    r = f(a)\n    return r[1]\n\n\nprint(main())\n\n"
  },
  {
    "language": "Python",
    "code": "import math,string,itertools,fractions,heapq,collections,re,array,bisect,sys,random,time,copy,functools\n\nsys.setrecursionlimit(10**7)\ninf = 10**20\neps = 1.0 / 10**13\nmod = 10**9+7\ndd = [(-1,0),(0,1),(1,0),(0,-1)]\nddn = [(-1,0),(-1,1),(0,1),(1,1),(1,0),(1,-1),(0,-1),(-1,-1)]\n\ndef LI(): return [int(x) for x in sys.stdin.readline().split()]\ndef LI_(): return [int(x)-1 for x in sys.stdin.readline().split()]\ndef LF(): return [float(x) for x in sys.stdin.readline().split()]\ndef LS(): return sys.stdin.readline().split()\ndef I(): return int(sys.stdin.readline())\ndef F(): return float(sys.stdin.readline())\ndef S(): return input()\ndef pf(s): return print(s, flush=True)\n\n\ndef main():\n    s = S()\n    fm = {}\n\n    a = []\n    for c in s:\n        if '0' <= c <= '9':\n            ci = int(c)\n            if len(a) > 0 and isinstance(a[-1], int):\n                a[-1] = a[-1] * 10 + ci\n            else:\n                a.append(ci)\n        else:\n            a.append(c)\n\n    def f(a):\n        key = tuple(a)\n        if key in fm:\n            return fm[key]\n        if len(a) == 2:\n            fm[key] = [inf,-inf]\n            return [inf,-inf]\n        for i in range(len(a)):\n            if a[i] != '(':\n                if i > 0:\n                    a = a[i:]\n                break\n        for i in range(len(a)-1,-1,-1):\n            if a[i] != ')':\n                a = a[:i+1]\n                break\n        if len(a) == 1:\n            r = [a[0],a[0]]\n            fm[key] = r\n            return r\n\n        ri = [inf]\n        ra = [-inf]\n        l = len(a)\n        for i in range(1,len(a)-1):\n            if not a[i] in ['+','-'] or (i > 1 and a[i-2] == '(') or (i+2 < l and a[i+2] == ')'):\n                continue\n            fl = f(a[:i])\n            fr = f(a[i+1:])\n            if a[i] == '+':\n                ri.append(fl[0]+fr[0])\n                ra.append(fl[1]+fr[1])\n            else:\n                ri.append(fl[0]-fr[1])\n                ra.append(fl[1]-fr[0])\n\n        r = [min(ri), max(ra)]\n        fm[key] = r\n        return r\n\n    r = f(a)\n    # print(r)\n    # for k in sorted(fm.keys(), key=lambda x: [len(str(x)), str(x)]):\n    #     print('k,fm[k]', ''.join(map(str,k)),fm[k])\n    return r[1]\n\n\nprint(main())\n\n"
  }
]