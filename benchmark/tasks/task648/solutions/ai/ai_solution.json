[
  {
    "model": "claude-3-5-haiku-20241022",
    "prompt_type": "zero_shot",
    "language": "C",
    "code": "#include <stdio.h>\n#include <string.h>\n#include <limits.h>\n\n#define MAX_H 2000\n#define MAX_W 2000\n\nint blocked[MAX_H + 1][MAX_W + 1];\nint dp[MAX_H + 1][MAX_W + 1];\n\nint main() {\n    int H, W, K;\n    scanf(\"%d %d %d\", &H, &W, &K);\n\n    memset(blocked, 0, sizeof(blocked));\n    for (int i = 1; i <= H; i++) {\n        int a, b;\n        scanf(\"%d %d\", &a, &b);\n        for (int j = a; j <= b; j++) {\n            blocked[i][j] = 1;\n        }\n    }\n\n    for (int k = 1; k <= H; k++) {\n        int minMoves = INT_MAX;\n        for (int start = 1; start <= W; start++) {\n            memset(dp, 0x3f, sizeof(dp));\n            dp[1][start] = 0;\n\n            for (int i = 1; i <= H; i++) {\n                for (int j = 1; j <= W; j++) {\n                    if (dp[i][j] == 0x3f3f3f3f) continue;\n\n                    for (int nx = j - 1; nx <= j + 1; nx++) {\n                        if (nx < 1 || nx > W) continue;\n                        if (i + 1 <= H && blocked[i + 1][nx]) continue;\n\n                        if (i + 1 <= H) {\n                            dp[i + 1][nx] = (dp[i + 1][nx] < dp[i][j] + 1) ? \n                                             dp[i + 1][nx] : dp[i][j] + 1;\n                        }\n                    }\n                }\n            }\n\n            for (int j = 1; j <= W; j++) {\n                if (dp[k + 1][j] != 0x3f3f3f3f) {\n                    minMoves = (minMoves < dp[k + 1][j]) ? minMoves : dp[k + 1][j];\n                }\n            }\n        }\n\n        printf(\"%d\\n\", minMoves == INT_MAX ? -1 : minMoves);\n    }\n\n    return 0;\n}",
    "timestamp": "2025-08-05 22:25:20"
  },
  {
    "model": "deepseek-v3",
    "prompt_type": "zero_shot",
    "language": "C",
    "code": "#include <stdio.h>\n#include <limits.h>\n#include <stdbool.h>\n\n#define MAX_H 200000\n#define MAX_W 200000\n\nint H, W;\nint A[MAX_H + 1], B[MAX_H + 1];\nint seg[1 << 20]; // Segment tree for min query and point update\nint size;\n\nvoid init_seg(int n) {\n    size = 1;\n    while (size < n) size <<= 1;\n    for (int i = 0; i < 2 * size; ++i) seg[i] = INT_MAX;\n}\n\nvoid update(int pos, int val) {\n    pos += size;\n    seg[pos] = val;\n    while (pos > 1) {\n        pos >>= 1;\n        int new_val = (seg[2*pos] < seg[2*pos+1]) ? seg[2*pos] : seg[2*pos+1];\n        if (seg[pos] == new_val) break;\n        seg[pos] = new_val;\n    }\n}\n\nint query(int l, int r, int a, int b, int k) {\n    if (r <= a || b <= l) return INT_MAX;\n    if (l <= a && b <= r) return seg[k];\n    int m = (a + b) / 2;\n    int left = query(l, r, a, m, 2*k);\n    int right = query(l, r, m, b, 2*k+1);\n    return (left < right) ? left : right;\n}\n\nint main() {\n    scanf(\"%d %d\", &H, &W);\n    for (int i = 1; i <= H; ++i) {\n        scanf(\"%d %d\", &A[i], &B[i]);\n    }\n\n    init_seg(W + 2);\n    for (int j = 1; j <= W; ++j) {\n        update(j, 0);\n    }\n\n    for (int i = 1; i <= H; ++i) {\n        int l = A[i], r = B[i];\n        int min_val = INT_MAX;\n        if (l > 1) {\n            int q = query(1, l, 0, size, 1);\n            if (q < min_val) min_val = q;\n        }\n        if (r < W) {\n            int q = query(r + 1, W + 1, 0, size, 1);\n            if (q < min_val) min_val = q;\n        }\n        if (min_val != INT_MAX) {\n            min_val += 1;\n            if (l <= r) {\n                update(l, min_val);\n                if (r + 1 <= W) {\n                    update(r + 1, min_val + (r + 1 - l));\n                }\n            }\n        }\n\n        int res = query(1, W + 1, 0, size, 1);\n        printf(\"%d\\n\", res == INT_MAX ? -1 : res);\n    }\n\n    return 0;\n}",
    "timestamp": "2025-08-05 22:25:54"
  },
  {
    "model": "deepseek-v3",
    "prompt_type": "zero_shot",
    "language": "C++",
    "code": "#include <iostream>\n#include <vector>\n#include <deque>\n#include <algorithm>\nusing namespace std;\n\nint main() {\n    int H, W;\n    cin >> H >> W;\n    vector<int> A(H), B(H);\n    for (int i = 0; i < H; ++i) {\n        cin >> A[i] >> B[i];\n    }\n\n    vector<int> res(H + 1, -1);\n    deque<pair<int, int>> dq;\n    vector<int> seg(W + 2, 1e9);\n    for (int j = 1; j <= W; ++j) {\n        seg[j] = 0;\n        dq.emplace_back(j, 0);\n    }\n\n    for (int i = 1; i <= H; ++i) {\n        int a = A[i-1], b = B[i-1];\n        while (!dq.empty() && dq.front().first <= b) {\n            int pos = dq.front().first;\n            int val = dq.front().second;\n            if (pos >= a) {\n                seg[pos] = 1e9;\n            }\n            dq.pop_front();\n        }\n        if (b < W) {\n            if (!dq.empty()) {\n                int new_val = dq.front().second + (b + 1 - dq.front().first) + 1;\n                if (new_val < seg[b + 1]) {\n                    seg[b + 1] = new_val;\n                    while (!dq.empty() && dq.back().second >= new_val) {\n                        dq.pop_back();\n                    }\n                    dq.emplace_back(b + 1, new_val);\n                }\n            }\n        }\n        if (!dq.empty()) {\n            res[i] = dq.front().second;\n        }\n    }\n\n    for (int i = 1; i <= H; ++i) {\n        cout << res[i] << endl;\n    }\n    return 0;\n}",
    "timestamp": "2025-08-05 22:26:13"
  },
  {
    "model": "deepseek-v3",
    "prompt_type": "zero_shot",
    "language": "Java",
    "code": "import java.util.*;\n\npublic class Main {\n    public static void main(String[] args) {\n        Scanner sc = new Scanner(System.in);\n        int H = sc.nextInt();\n        int W = sc.nextInt();\n        int[] A = new int[H + 1];\n        int[] B = new int[H + 1];\n        for (int i = 1; i <= H; i++) {\n            A[i] = sc.nextInt();\n            B[i] = sc.nextInt();\n        }\n\n        TreeSet<Integer> set = new TreeSet<>();\n        for (int j = 1; j <= W; j++) {\n            set.add(j);\n        }\n\n        int[] ans = new int[H + 1];\n        Arrays.fill(ans, -1);\n\n        for (int i = 1; i <= H; i++) {\n            Integer left = set.ceiling(A[i]);\n            while (left != null && left <= B[i]) {\n                set.remove(left);\n                left = set.higher(left);\n            }\n            if (!set.isEmpty()) {\n                ans[i] = i + set.first() - 1;\n            }\n            System.out.println(ans[i]);\n        }\n    }\n}",
    "timestamp": "2025-08-05 22:26:25"
  },
  {
    "model": "claude-3-5-haiku-20241022",
    "prompt_type": "zero_shot",
    "language": "Java",
    "code": "import java.util.*;\n\npublic class Solution {\n    public static void solve(int H, int W, int[] A, int[] B) {\n        int[][] dp = new int[H + 1][W + 1];\n        for (int[] row : dp) {\n            Arrays.fill(row, Integer.MAX_VALUE);\n        }\n\n        // Initialize top row\n        for (int j = 1; j <= W; j++) {\n            dp[0][j] = 0;\n        }\n\n        // Dynamic programming\n        for (int i = 1; i <= H; i++) {\n            for (int j = 1; j <= W; j++) {\n                // Check if current square is blocked in this row\n                if (j >= A[i] && j <= B[i]) continue;\n\n                // Check move from left\n                if (j > 1 && dp[i][j-1] != Integer.MAX_VALUE) {\n                    dp[i][j] = Math.min(dp[i][j], dp[i][j-1] + 1);\n                }\n\n                // Check move from above\n                if (i > 1) {\n                    boolean blocked = false;\n                    for (int k = A[i-1]; k <= B[i-1]; k++) {\n                        if (k == j) {\n                            blocked = true;\n                            break;\n                        }\n                    }\n                    if (!blocked && dp[i-1][j] != Integer.MAX_VALUE) {\n                        dp[i][j] = Math.min(dp[i][j], dp[i-1][j] + 1);\n                    }\n                }\n            }\n        }\n\n        // Find minimum moves for each target row\n        for (int k = 1; k <= H; k++) {\n            int minMoves = Integer.MAX_VALUE;\n            for (int j = 1; j <= W; j++) {\n                minMoves = Math.min(minMoves, dp[k][j]);\n            }\n            System.out.println(minMoves == Integer.MAX_VALUE ? -1 : minMoves);\n        }\n    }\n\n    public static void main(String[] args) {\n        Scanner scanner = new Scanner(System.in);\n        int H = scanner.nextInt();\n        int W = scanner.nextInt();\n        int[] A = new int[H + 1];\n        int[] B = new int[H + 1];\n\n        for (int i = 1; i <= H; i++) {\n            A[i] = scanner.nextInt();\n            B[i] = scanner.nextInt();\n        }\n\n        solve(H, W, A, B);\n    }\n}",
    "timestamp": "2025-08-05 22:26:34"
  },
  {
    "model": "claude-3-5-haiku-20241022",
    "prompt_type": "zero_shot",
    "language": "C++",
    "code": "#include <iostream>\n#include <vector>\n#include <queue>\n#include <climits>\n\nusing namespace std;\n\nint main() {\n    int H, W;\n    cin >> H >> W;\n    \n    vector<vector<int>> blocked(H + 1, vector<int>(W + 1, 0));\n    \n    for (int i = 1; i <= H; i++) {\n        int A, B;\n        cin >> A >> B;\n        for (int j = A; j <= B; j++) {\n            blocked[i][j] = 1;\n        }\n    }\n    \n    vector<int> result(H + 1, -1);\n    \n    for (int start = 1; start <= W; start++) {\n        vector<vector<int>> dist(H + 1, vector<int>(W + 1, INT_MAX));\n        dist[1][start] = 0;\n        \n        queue<pair<int, int>> q;\n        q.push({1, start});\n        \n        while (!q.empty()) {\n            int r = q.front().first;\n            int c = q.front().second;\n            q.pop();\n            \n            if (r == H + 1) break;\n            \n            // Move right\n            if (c + 1 <= W && blocked[r][c + 1] == 0) {\n                if (dist[r][c] + 1 < dist[r][c + 1]) {\n                    dist[r][c + 1] = dist[r][c] + 1;\n                    q.push({r, c + 1});\n                }\n            }\n            \n            // Move down\n            if (r + 1 <= H + 1) {\n                bool can_move_down = true;\n                for (int j = 1; j <= W; j++) {\n                    if (blocked[r][j] == 1 && j == c) {\n                        can_move_down = false;\n                        break;\n                    }\n                }\n                \n                if (can_move_down) {\n                    if (dist[r][c] + 1 < dist[r + 1][c]) {\n                        dist[r + 1][c] = dist[r][c] + 1;\n                        q.push({r + 1, c});\n                    }\n                }\n            }\n        }\n        \n        for (int k = 2; k <= H + 1; k++) {\n            int min_moves = INT_MAX;\n            for (int j = 1; j <= W; j++) {\n                if (dist[k][j] != INT_MAX) {\n                    min_moves = min(min_moves, dist[k][j]);\n                }\n            }\n            \n            if (min_moves != INT_MAX) {\n                if (result[k - 1] == -1 || min_moves < result[k - 1]) {\n                    result[k - 1] = min_moves;\n                }\n            }\n        }\n    }\n    \n    for (int k = 1; k <= H; k++) {\n        cout << result[k] << endl;\n    }\n    \n    return 0;\n}",
    "timestamp": "2025-08-05 22:26:43"
  },
  {
    "model": "gpt-4o",
    "prompt_type": "zero_shot",
    "language": "python",
    "code": "def min_moves_to_reach(H, W, restrictions):\n    result = []\n\n    for k in range(1, H + 1):\n        min_moves = float('inf')\n        for start_col in range(W):\n            current_col = start_col\n            moves = 0\n\n            for i in range(k):\n                if restrictions[i][0] <= current_col <= restrictions[i][1]:\n                    moves += 1\n\n                if restrictions[i][0] <= current_col + 1 <= restrictions[i][1]:\n                    current_col += 1\n\n            if restrictions[k][0] <= current_col <= restrictions[k][1]:\n                current_col += 1\n                moves += 1\n\n            if current_col < W:\n                result.append(min(min_moves, moves))\n            else:\n                result.append(-1)\n\n    return result\n\n\n# Example usage:\nH = 3\nW = 5\nrestrictions = [(1, 3), (0, 2), (2, 4)] # Each tuple (A_i, B_i) for the i-th row\n\nprint(min_moves_to_reach(H, W, restrictions))",
    "timestamp": "2025-08-13 10:43:59"
  },
  {
    "model": "gpt-4o",
    "prompt_type": "zero_shot",
    "language": "java",
    "code": "import java.util.*;\n\npublic class GridPathFinder {\n    public static int[] minimumMoves(int H, int W, int[] A, int[] B) {\n        int[] results = new int[H];\n        for (int k = 0; k < H; k++) {\n            results[k] = findMinMovesToRow(k + 1, W, A, B);\n        }\n        return results;\n    }\n\n    private static int findMinMovesToRow(int targetRow, int W, int[] A, int[] B) {\n        int startRow = 0;\n        Set<Integer> targetMoveSet = createAvailableSet(targetRow, W, A, B);\n        \n        Queue<int[]> queue = new LinkedList<>();\n        for (int col = 0; col < W; col++) {\n            queue.offer(new int[] { 0, col, 0 });\n        }\n\n        while (!queue.isEmpty()) {\n            int[] current = queue.poll();\n            int row = current[0], col = current[1], moves = current[2];\n\n            if (row == targetRow && targetMoveSet.contains(col)) {\n                return moves;\n            }\n\n            // Move right\n            if (col + 1 < W) {\n                queue.offer(new int[] { row, col + 1, moves + 1 });\n            }\n\n            // Move down, check restrictions\n            if (row + 1 <= targetRow && !isRestricted(col, row + 1, A, B)) {\n                queue.offer(new int[] { row + 1, col, moves + 1 });\n            }\n        }\n        return -1;\n    }\n\n    private static Set<Integer> createAvailableSet(int targetRow, int W, int[] A, int[] B) {\n        Set<Integer> availableSet = new HashSet<>();\n        for (int col = 0; col < W; col++) {\n            if (!isRestricted(col, targetRow, A, B)) {\n                availableSet.add(col);\n            }\n        }\n        return availableSet;\n    }\n\n    private static boolean isRestricted(int col, int row, int[] A, int[] B) {\n        return row > 0 && col >= A[row - 1] && col <= B[row - 1];\n    }\n\n    public static void main(String[] args) {\n        int H = 2;\n        int W = 5;\n        int[] A = { 1, 3 };\n        int[] B = { 3, 4 };\n\n        int[] result = minimumMoves(H, W, A, B);\n        System.out.println(Arrays.toString(result));\n    }\n}",
    "timestamp": "2025-08-13 10:44:04"
  },
  {
    "model": "gpt-4o",
    "prompt_type": "zero_shot",
    "language": "c",
    "code": "#include <stdio.h>\n#include <stdlib.h>\n#include <limits.h>\n\n#define min(x, y) ((x) < (y) ? (x) : (y))\n\nint main() {\n    int H, W;\n    scanf(\"%d %d\", &H, &W);\n    int A[H + 1], B[H + 1];\n    \n    for (int i = 1; i <= H; i++) {\n        scanf(\"%d %d\", &A[i], &B[i]);\n    }\n\n    int dp[W];\n    for (int i = 0; i < W; i++) {\n        dp[i] = 0; // Initialize moves required from top row\n    }\n\n    for (int step = 0; step < H; step++) {\n        int next_dp[W];\n        for (int i = 0; i < W; i++) {\n            next_dp[i] = INT_MAX; // Initialize next row as unreachable\n        }\n\n        for (int i = 0; i < W; i++) {\n            if (dp[i] != INT_MAX) {\n                for (int j = i; j < W; j++) {\n                    next_dp[j] = min(next_dp[j], dp[i] + (j - i));\n                    if (j >= A[step + 1] - 1 && j <= B[step + 1] - 1) break;\n                }\n            }\n        }\n\n        for (int i = 0; i < W; i++) {\n            dp[i] = next_dp[i];\n        }\n\n        int min_moves = INT_MAX;\n        for (int i = 0; i < W; i++) {\n            min_moves = min(min_moves, dp[i]);\n        }\n\n        if (min_moves == INT_MAX) {\n            printf(\"-1\\n\");\n        } else {\n            printf(\"%d\\n\", min_moves);\n        }\n    }\n\n    return 0;\n}",
    "timestamp": "2025-08-13 10:44:09"
  },
  {
    "model": "claude-3-5-haiku-20241022",
    "prompt_type": "zero_shot",
    "language": "python",
    "code": "def solve(H, W, A):\n    # Initialize dp array with large value\n    dp = [[float('inf')] * W for _ in range(H + 1)]\n    \n    # Initialize top row\n    for j in range(W):\n        dp[0][j] = 0\n    \n    # Process each row\n    for i in range(H):\n        # Restrictions on current row\n        blocked = set(range(A[i][0] - 1, A[i][1]))\n        \n        # Go through each column\n        for j in range(W):\n            if dp[i][j] == float('inf'):\n                continue\n            \n            # Try moving right\n            for right in range(j + 1, W):\n                if right not in blocked:\n                    dp[i + 1][right] = min(dp[i + 1][right], dp[i][j] + 1)\n    \n    # Find minimum moves to reach next row\n    result = min(dp[H])\n    return result if result != float('inf') else -1\n\n# Read input\nH, W = map(int, input().split())\nA = []\nfor _ in range(H):\n    l, r = map(int, input().split())\n    A.append((l, r))\n\n# Solve and print result\nprint(solve(H, W, A))",
    "timestamp": "2025-08-13 10:44:20"
  },
  {
    "model": "deepseek-v3",
    "prompt_type": "zero_shot",
    "language": "python",
    "code": "import sys\nimport heapq\n\ndef solve():\n    H, W = map(int, sys.stdin.readline().split())\n    A = []\n    B = []\n    for _ in range(H):\n        a, b = map(int, sys.stdin.readline().split())\n        A.append(a)\n        B.append(b)\n    \n    # Initialize for each row\n    res = [-1] * H\n    # We'll use a segment tree or a priority queue to manage the reachable positions\n    # Here, we'll use a list of sets for each row, but it's not efficient for large W\n    # So, we need a smarter approach\n    \n    # We'll track for each row the reachable x positions and their minimal steps\n    # Using a priority queue for each row, sorted by steps, then x\n    \n    # Initialize for row 0 (top row)\n    # For row 0, all x in [1, W] are reachable with 0 steps if starting there\n    # But since we can choose any starting point, the minimal steps is 0 if k=0 (but k starts from 1)\n    # So for k=1 (row 1), we need to move down from row 0\n    \n    # We'll manage a priority queue where elements are (steps, x, row)\n    # And for each row, we'll keep track of the x's that can reach it\n    \n    # Initialize for row 0: all x in 1..W are reachable with 0 steps\n    # But since we can choose any starting point, the minimal steps to reach row 1 is 1 (move down)\n    # But only if there's at least one x in row 0 that can move down to row 1\n    \n    # So for each row k (0-based), we need to find if there's an x in row k that can move down\n    \n    # We'll use a list to keep track of the current x positions and their steps for each row\n    # But for large W, we need a more efficient way\n    \n    # Let's think differently: for each row i (0-based), the forbidden down moves are A_i <= x <= B_i\n    # So to move down from row i to i+1, x must be < A_i or > B_i\n    \n    # The minimal steps to reach row k+1 is k+1 (since you need to move down k times and right some times)\n    # But if in any row i < k, all x in row i are forbidden to move down, then it's impossible\n    \n    # So for each k, we need to check if there's a path from top to row k+1\n    \n    # Let's precompute for each row i, the allowed x's to move down: x < A_i or x > B_i\n    # Then, for each k, the answer is k+1 if there's a path, else -1\n    \n    # But we need to handle the right moves\n    \n    # Alternative approach: for each row k, the minimal steps is the minimal steps to reach any x in row k that can move down, plus 1\n    \n    # Initialize for row 0: all x are reachable with 0 steps\n    \n    # We'll use a segment tree to keep track of the minimal steps for x in each row\n    # But for simplicity, here's a priority queue approach\n    \n    INF = float('inf')\n    \n    # For each row, we'll have a priority queue of (steps, x)\n    # We'll process row by row\n    \n    # Initialize for row 0\n    # The minimal steps to reach any x in row 0 is 0 (since we can start there)\n    # Then, for each next row, we can move right or down\n    \n    # We'll have a global priority queue that holds (steps, x, row)\n    # And for each row, we'll process the minimal steps\n    \n    # Initialize for row 0\n    # We can start at any x in 1..W with steps 0\n    # But since we can choose any starting point, the minimal steps to reach row 1 is 1 (if there's a valid x to move down)\n    \n    # So for each row k (0-based), the answer for k+1 is k+1 if there's a path\n    \n    # Now, we need to check for each row k, if there's any x in row k that can move down\n    \n    # So for each row k from 0 to H-1, check if there's x < A[k] or x > B[k]\n    # If for any row i < k, all x in row i are forbidden to move down, then answer for k+1 is -1\n    \n    # So the answer for k is k if there's a path, else -1\n    \n    # But we also need to account for right moves\n    \n    # The problem is more complex than that\n    \n    # Let's think differently: the minimal steps to reach row k+1 is the minimal steps to reach any cell in row k that can move down, plus 1\n    \n    # So for each row i from 0 to k, we need to find if there's a path from top to row i, then move down to row i+1\n    \n    # So the answer for k is (k+1) if there's a path, else -1\n    \n    # Now, to find if there's a path to row k+1, we need to check that for all i <= k, there's at least one x in row i that can move down\n    \n    # So the answer for k is k+1 if for all i <= k, [1, W] is not entirely contained in [A_i, B_i], else -1\n    \n    # But this doesn't account for right moves\n    \n    # For example, even if row 0 has A_0=1, B_0=W (all forbidden), but if W > 1, you can move right to x=W+1 (but x is up to W)\n    # So if A_i=1 and B_i=W, then no down moves are possible from row i\n    \n    # So the answer for k is -1 if there exists i <= k such that A_i <= 1 and B_i >= W (i.e., all x in row i are forbidden to move down)\n    \n    # Otherwise, the answer is k+1\n    \n    # So the solution is:\n    # For each k in 1..H, the answer is k if for all i < k, [A_i, B_i] does not cover the entire row [1, W], else -1\n    \n    # So we can precompute for each row i whether the entire row is forbidden\n    blocked = [False] * H\n    for i in range(H):\n        if A[i] == 1 and B[i] == W:\n            blocked[i] = True\n    \n    # Now, for each k, the answer is k+1 if all rows i < k+1 are not entirely blocked\n    # But since k is from 1 to H, and rows are 0-based, we need to check rows 0..k-1\n    \n    # We'll compute a prefix 'and' of not blocked\n    prefix_ok = [True] * (H + 1)\n    for i in range(H):\n        prefix_ok[i+1] = prefix_ok[i] and (not blocked[i])\n    \n    for k in range(1, H+1):\n        if prefix_ok[k]:\n            res[k-1] = k\n        else:\n            res[k-1] = -1\n    \n    # But this doesn't account for right moves allowing to bypass some blocks\n    \n    # For example, if in row 0, A=2, B=2, then x=1 can move down, and x=3 can move down (if W >=3)\n    # So the entire row is not blocked\n    \n    # So the initial approach seems correct\n    \n    # Print the results\n    for ans in res:\n        print(ans)\n\nsolve()",
    "timestamp": "2025-08-13 10:45:09"
  },
  {
    "model": "gpt-4o",
    "prompt_type": "zero_shot",
    "language": "c++",
    "code": "#include <iostream>\n#include <vector>\n#include <algorithm>\n#include <limits>\n\nusing namespace std;\n\nint main() {\n    int H, W;\n    cin >> H >> W;\n    \n    vector<pair<int, int>> restrictions(H);\n    for (int i = 0; i < H; ++i) {\n        cin >> restrictions[i].first >> restrictions[i].second;\n    }\n    \n    for (int k = 1; k <= H; ++k) {\n        vector<int> dp(W, numeric_limits<int>::max());\n        dp[0] = 0;\n        \n        for (int i = 0; i < W; ++i) {\n            if (dp[i] == numeric_limits<int>::max()) continue;\n            \n            // Move right\n            if (i + 1 < W) {\n                dp[i + 1] = min(dp[i + 1], dp[i] + 1);\n            }\n            \n            // Check if moving down is allowed\n            if (i < restrictions[k - 1].first - 1 || i >= restrictions[k - 1].second) {\n                dp[i] = min(dp[i], dp[i] + 1);\n            }\n        }\n        \n        int min_moves = *min_element(dp.begin(), dp.end());\n        if (min_moves == numeric_limits<int>::max()) {\n            cout << -1 << endl;\n        } else {\n            cout << min_moves << endl;\n        }\n    }\n    \n    return 0;\n}",
    "timestamp": "2025-08-13 12:00:22"
  }
]