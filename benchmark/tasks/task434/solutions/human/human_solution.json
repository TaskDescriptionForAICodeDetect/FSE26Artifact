[
  {
    "language": "C++",
    "code": "#include <cassert>\n#include <cstdlib>\n#include <iostream>\n#include <vector>\nusing namespace std;\n\ntemplate<class T> inline void chmax(T& a, const T& b) { if(b > a) a = b; }\n\ntypedef long long value; // 格納するデータの型\nconst value INIT = 0ll; // 初期値．目的に応じて，適切な値に変更すること．\n\nclass segment_tree {\nprivate:\n\tint n;\n\tvector<value> dat;\n\n\tvalue func(value a, value b) const { // ノードの値を決める為の関数\n\t\treturn max(a, b);\n\t}\n\n\tvalue query(int a, int b, int k, int l, int r) const {\n\t\tif(r <= a || b <= l) // 求める区間が，ノードの区間と重なっていない．\n\t\t\treturn INIT;\n\n\t\tif(a <= l && r <= b) { // 求める区間が，ノードの区間を完全に含む．\n\t\t\treturn dat[k];\n\t\t}\n\t\telse {\n\t\t\tconst int mid = (l + r) / 2;\n\t\t\tconst value vl = query(a, b, k * 2 + 1, l, mid);\n\t\t\tconst value vr = query(a, b, k * 2 + 2, mid, r);\n\t\t\treturn func(vl, vr);\n\t\t}\n\t}\n\npublic:\n\tsegment_tree(int n_) {\n\t\tn = 1;\n\t\twhile(n < n_)\n\t\t\tn *= 2;\n\n\t\tdat.assign(4 * n - 1, INIT);\n\t}\n\n\tvoid update(int k, value a) { // k番目の要素をaに更新する．\n\t\tk += n - 1;\n\t\tdat[k] = a;\n\t\twhile(k > 0) {\n\t\t\tk = (k - 1) / 2;\n\t\t\tdat[k] = func(dat[k * 2 + 1], dat[k * 2 + 2]);\n\t\t}\n\t}\n\n\tvalue query(int a, int b) { // [a, b)に対するクエリ\n\t\treturn query(a, b, 0, 0, n);\n\t}\n};\n\nint main() {\n\tcin.tie(0);\n\tios::sync_with_stdio(false);\n\n\tint m;\n\tcin >> m;\n\n\tsegment_tree segt(m);\n\n\tlong long mx = 0;\n\tfor(int i = 0; i < m; ++i) {\n\t\tint w;\n\t\tcin >> w;\n\n\t\tlong long tmp = segt.query(1, w) + w;\n\t\tsegt.update(w, tmp);\n\t\tchmax(mx, tmp);\n\t}\n\n\tcout << ((m + 1ll) * m / 2ll - mx) << endl;\n\treturn EXIT_SUCCESS;\n}"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\nusing namespace std;\n#define FOR(i,k,n) for(int i = (k); i < (n); i++)\n#define REP(i,n) FOR(i,0,n)\n#define ALL(a) a.begin(), a.end()\n#define MS(m,v) memset(m,v,sizeof(m))\n#define D10 fixed<<setprecision(10)\ntypedef long long ll;\ntypedef long double ld;\ntypedef vector<int> vi;\ntypedef vector<string> vs;\ntypedef pair<int, int> pii;\nconst int MOD = 1000000007;\nconst int INF = MOD + 1;\nconst ld EPS = 1e-12;\ntemplate<class T> T &chmin(T &a, const T &b) { return a = min(a, b); }\ntemplate<class T> T &chmax(T &a, const T &b) { return a = max(a, b); }\n\n/*--------------------template--------------------*/\nstruct Data\n{\n\tll num;\n\tData() :num(INF) {};\n\tData(ll n) :num(n) {};\n};\n\nstruct SegmentTree\n{\n\tint n; vector<Data> data;\n\tSegmentTree(int N)\n\t{\n\t\tn = 1;\n\t\twhile (n < N) n *= 2;\n\t\tdata.resize(2 * n);\n\t}\nprivate:\n\tData sub(int left, int right, int node, int nleft, int nright)\n\t{\n\t\tif (nright <= left || right <= nleft) return Data();\n\t\tif (left <= nleft && nright <= right) return data[node];\n\t\tData vl = sub(left, right, node * 2 + 1, nleft, (nleft + nright) / 2);\n\t\tData vr = sub(left, right, node * 2 + 2, (nleft + nright) / 2, nright);\n\t\treturn min(vl.num, vr.num);\n\t}\n\npublic:\n\tvoid update(int pos, Data value)\n\t{\n\t\tpos += n - 1;\n\t\tdata[pos] = value;\n\t\twhile (pos > 0)\n\t\t{\n\t\t\tpos = (pos - 1) / 2;\n\t\t\tdata[pos] = min(data[pos * 2 + 1].num, data[pos * 2 + 2].num);\n\t\t}\n\t}\n\tData min_query(int left, int right)\n\t{\n\t\treturn sub(left, right, 0, 0, n);\n\t}\n};\n\n\n\nint main()\n{\n\tll n;\n\tcin >> n;\n\tSegmentTree seg(n);\n\tREP(i, n) seg.update(i, 0);\n\tREP(i, n)\n\t{\n\t\tint a;\n\t\tcin >> a;\n\t\tll val = seg.min_query(0, a).num - a;\n\t\tseg.update(a-1, val);\n\t}\n\tcout << n*(n + 1) / 2 + seg.min_query(0, n).num << endl;\n\treturn 0;\n}"
  },
  {
    "language": "C++",
    "code": "// AOJ 2431\n#include<cstdio>\n#include<algorithm>\n#define rep(i,a) for( int i = 0; i != (a); ++i )\n\ntypedef long long ll;\n\nint n;\nll bit[100000];\n\nvoid add( int k, ll x )\n{\n\tfor( int i = k; i < n; i |= i+1 )\n\t\tbit[i] = std::max( bit[i], x );\n\n\treturn;\n}\n\nll sum( int k )\n{\n\tll ret = 0;\n\n\tfor( int i = k-1; i >= 0; i = (i&(i+1))-1 )\n\t\tret = std::max( ret, bit[i] );\n\n\treturn ret;\n}\n\nint main()\n{\n\tscanf( \"%d\", &n );\n\trep( i, n )\n\t{\n\t\tint x;\n\t\tscanf( \"%d\", &x );\n\t\tadd( x-1, sum( x-1 )+x );\n\t}\n\n\tprintf( \"%lld\\n\", ll(n*(n+1)>>1)-sum(n-1) );\n\n\treturn 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include<bits/stdc++.h>\nusing namespace std;\nint n,m,s[15],d[100],dp[101][1<<15];\n\nvoid minimize(int &a,int b){\n  a=min(a,b);\n}\n\nint main(){\n\n\n  int n,m;\n  while(cin>>n>>m,n){\n    for(int i=0;i<n;i++)cin>>s[i];\n    for(int i=0;i<m;i++)cin>>d[i];\n    sort(d,d+m);\n\n    int sum[1<<15]={};\n    for(int i=0;i<(1<<n);i++)\n      for(int j=0;j<n;j++)\n\tif((1<<j)&i)sum[i]+=s[j];\n\n    for(int j=0;j<=m;j++)\n      for(int i=0;i<(1<<n);i++)dp[j][i]=1e9;\n    dp[0][0]=0;\n\n    for(int i=0;i<m;i++)\n      for(int j=0;j<(1<<n);j++){\n\n\tfor(int k=0;k<n;k++){\n\t  if(((1<<k)&j)!=0)continue;\n\t  \n\t  //\t  minimize( dp[i+1][j+(1<<k)] , dp[i][j]+abs(sum[j+(1<<k)]-d[i]));\n\t  minimize( dp[i][j+(1<<k)] , dp[i][j]);\n\t}\n\n\tminimize(dp[i+1][j],dp[i][j]+abs(sum[j]-d[i]));\n      }\n\n\n\n    int mn=1e9;\n    for(int i=0;i<(1<<n);i++)mn=min(mn,dp[m][i]);\n    cout<<mn<<endl;\n  }\n  return 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\nusing namespace std;\n#define FOR(i,k,n) for(int i = (k); i < (n); i++)\n#define REP(i,n) FOR(i,0,n)\n#define ALL(a) a.begin(), a.end()\n#define MS(m,v) memset(m,v,sizeof(m))\n#define D10 fixed<<setprecision(10)\ntypedef long long ll;\ntypedef long double ld;\ntypedef vector<int> vi;\ntypedef vector<string> vs;\ntypedef pair<int, int> pii;\nconst int MOD = 1000000007;\nconst int INF = MOD + 1;\nconst ld EPS = 1e-12;\ntemplate<class T> T &chmin(T &a, const T &b) { return a = min(a, b); }\ntemplate<class T> T &chmax(T &a, const T &b) { return a = max(a, b); }\n\n/*--------------------template--------------------*/\nstruct Data\n{\n\tint num;\n\tData() :num(INF) {};\n\tData(int n) :num(n) {};\n};\n\nstruct SegmentTree\n{\n\tint n; vector<Data> data;\n\tSegmentTree(int N)\n\t{\n\t\tn = 1;\n\t\twhile (n < N) n *= 2;\n\t\tdata.resize(2 * n);\n\t}\nprivate:\n\tData sub(int left, int right, int node, int nleft, int nright)\n\t{\n\t\tif (nright <= left || right <= nleft) return Data();\n\t\tif (left <= nleft && nright <= right) return data[node];\n\t\tData vl = sub(left, right, node * 2 + 1, nleft, (nleft + nright) / 2);\n\t\tData vr = sub(left, right, node * 2 + 2, (nleft + nright) / 2, nright);\n\t\treturn min(vl.num, vr.num);\n\t}\n\npublic:\n\tvoid update(int pos, Data value)\n\t{\n\t\tpos += n - 1;\n\t\tdata[pos] = value;\n\t\twhile (pos > 0)\n\t\t{\n\t\t\tpos = (pos - 1) / 2;\n\t\t\tdata[pos] = min(data[pos * 2 + 1].num, data[pos * 2 + 2].num);\n\t\t}\n\t}\n\tData min_query(int left, int right)\n\t{\n\t\treturn sub(left, right, 0, 0, n);\n\t}\n};\n\n\n\nint main()\n{\n\tint n;\n\tcin >> n;\n\tSegmentTree seg(n);\n\tREP(i, n) seg.update(i, 0);\n\tREP(i, n)\n\t{\n\t\tint a;\n\t\tcin >> a;\n\t\tint val = seg.min_query(0, a).num - a;\n\t\tseg.update(a-1, val);\n\t}\n\tcout << n*(n + 1) / 2 + seg.min_query(0, n).num << endl;\n\treturn 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include <iostream>\n#include <iomanip>\n#include <cstdio>\n#include <string>\n#include <cstring>\n#include <deque>\n#include <list>\n#include <queue>\n#include <stack>\n#include <vector>\n#include <utility>\n#include <algorithm>\n#include <map>\n#include <set>\n#include <complex>\n#include <cmath>\n#include <limits>\n#include <cfloat>\n#include <climits>\n#include <ctime>\n#include <cassert>\n#include <numeric>\n#include <functional>\nusing namespace std;\n\n#define rep(i,a,n) for(int (i)=(a); (i)<(n); (i)++)\n#define repq(i,a,n) for(int (i)=(a); (i)<=(n); (i)++)\n#define repr(i,a,n) for(int (i)=(a); (i)>=(n); (i)--)\n#define int long long int\n\ntemplate<typename T> void chmax(T &a, T b) {a = max(a, b);}\ntemplate<typename T> void chmin(T &a, T b) {a = min(a, b);}\ntemplate<typename T> void chadd(T &a, T b) {a = a + b;}\n\ntypedef pair<int, int> pii;\ntypedef long long ll;\n\nint dx[] = {0, 0, 1, -1};\nint dy[] = {1, -1, 0, 0};\nconstexpr ll INF = 1001001001001001LL;\nconstexpr ll MOD = 1000000007LL;\n\nll seg[1 << 18];\nconstexpr ll SIZE = 1 << 17;\n\nvoid update(int x, int val) {\n    int p = SIZE - 1 + x;\n    while(p >= 0) {\n        chmax(seg[p], val);\n        if(p == 0) break;\n        p = (p - 1) / 2;\n    }\n}\n\nint solve(int a, int b, int l=0, int r=SIZE, int k=0) {\n    if(r <= a || b <= l) return 0;\n    if(a <= l && r <= b) return seg[k];\n    int mid = (l+r) / 2;\n    int vl = solve(a, b, l, mid, 2*k+1);\n    int vr = solve(a, b, mid, r, 2*k+2);\n    return max(vl, vr);\n}\n\nint N, x;\n\nsigned main() {\n    cin >> N;\n    int sum = 0;\n    rep(i,0,N) {\n        cin >> x; sum += x;\n        int val = solve(0, x) + x;\n        update(x, val);\n    }\n    cout << sum - solve(0, N+1) << endl;\n    return 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include <cstdio>\n#include <algorithm>\nusing namespace std;\n\nstruct Fenwick {\n  int n;\n  long long *p;\n  Fenwick(int n) : n(n), p(new long long[n+1]) {\n    fill(p, p+n+1, 0);\n  }\n  ~Fenwick() { delete[] p; }\n  void add(int i, long long a) {\n    for(i++; i <= n; i += i&-i) p[i] = max(p[i], a);\n  }\n  long long sum(int i) {\n    long long s = 0;\n    for(; i > 0; i -= i&-i) s = max(s, p[i]);\n    return s;\n  }\n};\n\nint main() {\n  int n; scanf(\"%d\", &n);\n  // static int xs[100000];\n  // for(int i = 0; i < n; i++) scanf(\"%d\", xs+i);\n  Fenwick fwt(n+1);\n  for(int i = 0; i < n; i++) {\n    int x; scanf(\"%d\", &x);\n    int cost = fwt.sum(x-1)+x;\n    // printf(\"%d <- %d\\n\", x-1, cost);\n    fwt.add(x-1, cost);\n    // fwt.add(x, -cost);\n  }\n  printf(\"%lld\\n\", (long long)n*(n+1)/2-fwt.sum(n));\n  return 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include <vector>\n#include <iostream>\n#include <set>\n#include <cstdio>\n#include <queue>\n#include <cstdio>\n#include <cstdlib>\n#include <cassert>\n#include <ctime>\n#include <algorithm>\n#include <tuple>\n#include <algorithm>\n#include <limits>\n#include <map>\n\nusing namespace std;\n\ntypedef long long ll;\ntypedef pair<int, int> P;\ntypedef tuple<int, int, int> T;\n\n#include <algorithm>\n#include <limits>\n#include <cstring>\n#include <array>\n//size:2**N N=19:524288 N=17:131072 N=12:4096\ntemplate <class T, int N, int K>\nstruct RangeKthSmallest {\n    using PA = std::pair<T, int>;\n    using P = std::pair<std::array<PA, K>, T>;\n    static const int size = 1<<N;\n    P seg[size*2];\n    \n    void init(T x) {\n        int l = size-1, r = size*2-2;\n        for (int i = 0; i <= N; i++) {\n            for (int j = l; j <= r; j++) {\n                seg[j].first[0] = PA(x, 1<<i);\n                for (int i = 1; i < K; i++) {\n                    seg[j].first[i] = PA(0, -1);\n                }\n                if (i) {\n                    seg[j].second = 0;\n                } else {\n                    seg[j].second = x;\n                }\n            }\n            l = (l-1)/2; r = (r-1)/2;\n        }\n        for (int i = 0; i < K; i++) {\n            seg[size*2-1].first[i] = PA(0, -1);\n        }\n    }\n\n    //a=b+c\n    inline void merge(P *A, P &a1, P &a2) {\n        int c1 = 0, c2 = 0;\n        P &a = *A;\n        for (int c = 0; c < K; c++) {\n            PA &p1 = a1.first[c1], &p2 = a2.first[c2];\n            bool f1 = (c1 == K || p1.second == -1), f2 = (c2 == K || p2.second == -1);\n            if (f1 && f2) {\n                a.first[c] = PA(0, -1);\n                continue;\n            }\n            if (f1) {\n                a.first[c] = p2;\n                c2++;\n            } else if (f2) {\n                a.first[c] = p1;\n                c1++;\n            } else if (p1.first == p2.first) {\n                a.first[c] = PA(p1.first, p1.second + p2.second);\n                c1++; c2++;\n            } else if (p1.first < p2.first) {\n                a.first[c] = p1;\n                c1++;\n            } else {\n                a.first[c] = p2;\n                c2++;\n            }\n            a.first[c].first += a.second;\n        }\n    }\n\n    inline void merge2(P *a, P &a1) {\n        P a2;\n        memcpy(&a2, a, sizeof(a2));\n        merge(a, a1, a2);\n    }\n\n    inline void add(uint i, T x) {\n        if (i >= size) return;\n        i += size - 1;\n        seg[i].first[0].first += x;\n        seg[i].second += x;\n        while (i) {\n            i = (i - 1) / 2;\n            merge(&seg[i], seg[i*2+1], seg[i*2+2]);\n        }\n    }\n\n    inline void add(uint a, uint b, T x, uint k = 0, uint l = 0, uint r = size) {\n        if (a >= b || b > size) return;\n        if (r <= a || b <= l) return;\n        if (a <= l && r <= b) {\n            for (int i = 0; i < K && seg[k].first[i].second != -1; i++) {\n                seg[k].first[i].first += x;\n            }\n            seg[k].second += x;\n            return;\n        }\n        add(a, b, x, k*2+1, l, (l+r)/2);\n        add(a, b, x, k*2+2, (l+r)/2, r);\n        merge(&seg[k], seg[k*2+1], seg[k*2+2]);\n    }\n\n    inline PA get(uint k) {\n        return seg[0].first[k];\n    }\n    P buff_p;\n    int buff_a = size, buff_b = size;\n    inline PA get(uint a, uint b, uint k) {\n        if (a != buff_a || b != buff_b) {\n            buff_p = get2(a, b);\n            buff_a = a;\n            buff_b = b;\n        }\n        return buff_p.first[k];\n    }\n\nprivate:\n    inline P get2(uint a, uint b, uint k = 0, uint l = 0, uint r = size) {\n        if (a >= b || b > size || r <= a || b <= l) return seg[size*2-1];\n        if (a <= l && r <= b) {\n            return seg[k];\n        }\n        P p1 = get2(a, b, k*2+1, l, (l+r)/2);\n        P p2 = get2(a, b, k*2+2, (l+r)/2, r);\n        P p;\n        p.second = seg[k].second;\n        merge(&p, p1, p2);\n        return p;\n    }\n};\nRangeKthSmallest<ll, 17, 1> s;\nint main() {\n    int n;\n    cin >> n;\n    s.init(0);\n    ll r = 0;\n    for (int i = 0; i < n; i++) {\n        int d;\n        cin >> d;\n        s.add(d, s.get(0, d, 0).first-d);\n        r += d;\n    }\n    cout << r + s.get(0).first << endl;\n    return 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include<iostream>\n#include<vector>\n#include<algorithm>\nusing namespace std;\nclass union_find_tree {\nprivate:\n\tvector<int>par, rank_;\npublic:\n\tunion_find_tree(int n) :par(n), rank_(n) {\n\t\tfor (int i = 0; i < n; i++) {\n\t\t\tpar[i] = i;\n\t\t\trank_[i] = 0;\n\t\t}\n\t}\n\tint root(int x) {\n\t\tif (par[x] == x) {\n\t\t\treturn x;\n\t\t}\n\t\treturn par[x] = root(par[x]);\n\t}\n\tbool same(int x, int y) {\n\t\treturn root(x) == root(y);\n\t}\n\tvoid unite(int x, int y) {\n\t\tx = root(x);\n\t\ty = root(y);\n\t\tif (x == y) {\n\t\t\treturn;\n\t\t}\n\t\tif (rank_[x] < rank_[y]) {\n\t\t\tpar[x] = y;\n\t\t}\n\t\telse if (rank_[x] == rank_[y]) {\n\t\t\tpar[y] = x;\n\t\t\trank_[x]++;\n\t\t}\n\t\telse if (rank_[y] < rank_[x]) {\n\t\t\tpar[y] = x;\n\t\t}\n\t}\n};\n\nstruct edge {\n\tint from, to, cost;\n\tbool operator<(const edge& other)const {\n\t\treturn cost < other.cost;\n\t}\n};\n\nusing edges = vector<edge>;\n\nint kruskal(union_find_tree& uf, edges& es, int V) {\n\tsort(es.begin(), es.end());\n\tint E = es.size();\n\tint res = 0;\n\tfor (int i = 0; i < E; i++) {\n\t\tif (!uf.same(es[i].from, es[i].to)) {\n\t\t\tuf.unite(es[i].from, es[i].to);\n\t\t\tres += es[i].cost;\n\t\t}\n\t}\n\treturn res;\n}\n\nint main() {\n\tint V, E;\n\tcin >> V >> E;\n\tedges es(E);\n\tunion_find_tree uf(V);\n\tfor (int i = 0; i < E; i++) {\n\t\tcin >> es[i].from >> es[i].to >> es[i].cost;\n\t}\n\tcout << kruskal(uf, es, V) << endl;\n\treturn 0;\n\n}\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n"
  },
  {
    "language": "C++",
    "code": "#include<iostream>\n#include<iomanip>\n#include<algorithm>\n#include<bitset>\n#include<cctype>\n#include<cmath>\n#include<cstdio>\n#include<cstring>\n#include<deque>\n#include<functional>\n#include<limits>\n#include<list>\n#include<map>\n#include<set>\n#include<stack>\n#include<string>\n#include<sstream>\n#include<queue>\n#include<vector>\nusing namespace std;\n\n#define MOD 1000000007\n#define INF 0x3f3f3f3f\n#define INFL 0x3f3f3f3f3f3f3f3fLL\n\nint main() {\n\tint n; cin >> n;\n\tint S = 0;\n\tvector<int> x(n);\n\tfor (int i = 0; i < n; i++) {\n\t\tint X; scanf(\"%d\", &X);\n\t\tx[i] = X;\n\t\tS += X;\n\t}\n\n\tvector<int> dp(n, 0);\n\tdp[n - 1] = x[n - 1];\n\tfor (int i = n - 1; i >= 0; i--) {\n\t\tfor (int j = i + 1; j < n; j++) {\n\t\t\t//cerr << x[i] << \" \" << x[j] << endl;\n\t\t\tif (x[j] > x[i]) {\n\t\t\t\tdp[i] = max(dp[i], x[i] + dp[j]);\n\t\t\t\t//cerr << \" \" << M[i] << \" \" << x[i] + M[j] << endl;\n\t\t\t}\n\t\t}\n\t}\n\tcout << S - *max_element(dp.begin(), dp.end()) << endl;\n\treturn 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\nusing namespace std;\n\n// 0-indexed\ntemplate <class T>\nstruct SegmentTree {\n  // a,b,c: T, e:T(unit)\n  // abc = (ab)c = a(bc)\n  // ae = ea = a\n  typedef function<T(T, T)> F;\n  int n;\n  F f;\n  T unit;\n  vector<T> dat;\n  SegmentTree(){};\n  SegmentTree(int newn, F f, T t) : f(f), unit(t) {\n    init(newn);\n  }\n  void init(int newn) {\n    n = 1;\n    while(n < newn) n <<= 1;\n    dat.assign(n << 1, unit);\n  }\n\n  // \"go up\" process\n  void update(int k, T newdata) {\n    dat[k += n] = newdata;\n    while(k >>= 1) {\n      dat[k] = f(dat[(k << 1) | 0], dat[(k << 1) | 1]);\n    }\n  }\n  // [a,b)\n  T query(int a, int b) {\n    T vl = unit, vr = unit;\n    for(int l = a + n, r = b + n; l < r; l >>= 1, r >>= 1) {\n      if(l & 1) vl = f(vl, dat[l++]);\n      if(r & 1) vr = f(dat[--r], vr);\n    }\n    return f(vl, vr);\n  }\n};\n\nlong long n;\nvector<long long> x, id;\n\nlong long solve();\n\nint main() {\n  cin >> n;\n  x.resize(n);\n  for(int i = 0; i < n; ++i) cin >> x[i];\n  cout << solve() << endl;\n  return 0;\n}\n\nlong long solve() {\n  long long res = n * (n + 1) / 2;\n  auto f = [&](long long l, long long r) {\n    return max(l, r);\n  };\n  auto idf = [](long long l, long long r) {\n    return x[l] < x[r];\n  };\n  id.resize(n);\n  for(int i = 0; i < n; ++i) id[i] = i;\n  sort(id.begin(), id.end(), idf);\n  SegmentTree<long long> seg(n, f, 0);\n  for(int i = 0; i < n; ++i) {\n    seg.update(id[i], i + 1 + seg.query(0, id[i]));\n  }\n  return res - seg.query(0, n);\n}\n"
  },
  {
    "language": "C++",
    "code": "#include <iostream>\n#include <vector>\n#define ll long long \nusing namespace std;\nint INF = 1000000000;\nstruct SegmentTree{\nprivate:\n  int n;\n  vector<ll int> node;\npublic:\n  SegmentTree(vector<ll int> v){\n    int sz = v.size();\n    n = 1; while(n < sz) n *= 2;\n    node.resize(2*n-1,0);\n    for(int i = 0; i < sz; ++i) node[i+n-1] = v[i];\n    for(int i = n-2; i >= 0; --i) node[i] = max(node[2*i+1],node[2*i+2]);\n  }\n  void update(int x, ll int val){\n    x += (n-1);\n    node[x] = val;\n    while(x > 0){\n      x = (x-1)/2;\n      node[x] = max(node[2*x+1],node[2*x+2]);\n    }\n  }\n  ll int getmax(int a, int b, int k = 0, int l = 0, int r = -1){\n    if(r < 0) r = n;\n    if(r <= a || b <= l) return 0LL;\n    if(a <= l && r <= b) return node[k];\n    int vl = getmax(a,b,2*k+1,l,(l+r)/2);\n    int vr = getmax(a,b,2*k+2,(l+r)/2,r);\n    return max(vl,vr);\n  }\n};\nsigned main(){\n//int main(){\n  int n;\n  ll int s = 0;\n  cin >> n;\n  vector<ll int> x(n);\n  for(int i = 0; i < n; ++i){\n    cin >> x[i];\n    s += x[i];\n  }\n  SegmentTree st(vector<ll int>(n+1,0));\n  for(int i = 0; i < n; ++i){\n    ll int t = st.getmax(0,x[i]);\n    //cout << x[i] << \" \" << t << endl;\n    st.update(x[i],t+x[i]);\n  }\n\n  cout << s - st.getmax(0,n+1) << endl;\n  return 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include <iostream>\n#include <algorithm>\n\nusing namespace std;\n\n#define ll long long\n#define rep(a,b) for(int a = 0; a < b; a++)\n\nint n;\nll dp[1<<18]{};\nint arr[100000];\nint size = 1;\n\nvoid update(int index, ll num) {\n  index += size-1;\n  dp[index] = num;\n  //cout << \"  \" << index << \",\" << dp[index] << endl;\n  while(index>0) {\n    int new_index = (index-1)>>1;\n    dp[new_index] = max(dp[(new_index<<1)+1],dp[(new_index<<1)+2]);\n    //cout << \"  \" << new_index << \",\" << dp[new_index] << endl;\n    index = new_index;\n  }\n  //dp[index] = max(dp[index],dp[index^1]);\n}\n\nll get_max(int a, int b, int k, int left, int right) {\n  //cout << \"gmax \" << a << \",\" << b << \",\" << k << \",\" << left << \",\" << right << endl;\n  if(right<a||b<=left||right<=left) return 0;\n  if(a<=left&&right<=b) {\n    //cout << \"OK \" << dp[k] << endl;\n    return dp[k];\n  }\n  ll ret = 0;\n  ret = max(ret,get_max(a,b,(k<<1)+1,left,(left+right)>>1));\n  ret = max(ret,get_max(a,b,(k<<1)+2,(left+right+1)>>1,right));\n  return ret;\n}\n\nint main() {\n  cin >> n;\n  for(int i = 1; i < n; i<<=1) size<<=1;\n  rep(i,n) cin >> arr[i];\n  rep(i,n) {\n    int num = arr[i];\n    ll _max = get_max(1,num,0,0,size);\n    //cout << num << \",\" << _max << endl;\n    update(num,_max+num);\n  }\n  ll ans = (ll)n;\n  ans = n*(n+1)/2;\n  //for(int i = 0; i < size<<1; i++) cout << dp[i] << endl;\n  cout << ans-dp[0] << endl;\n}\n\n"
  },
  {
    "language": "C++",
    "code": "#include<iostream>\n#include<vector>\n#include<algorithm>\n#include<climits>\n\nconst int MAX_N=1000000;\n\ntypedef long long ll;\n\nusing namespace std;\n\nll n,dat[2*MAX_N-1];\n\nvoid init(int n_){\n\tn=1;\n\twhile(n<n_)n*=2;\n}\n\nvoid update(int k,ll a){\n\tk+=n-1;\n\tdat[k]=a;\n\t\n\twhile(k>0){\n\t\tk=(k-1)/2;\n\t\tdat[k]=max(dat[2*k+1],dat[2*k+2]);\n\t}\n}\n\nll query(int a,int b,int k,int l,int r){\n\tif(r<=a || b<=l)return 0;\n\tif(a<=l && r<=b)return dat[k];\n\telse {\n\t\tll vl=query(a,b,k*2+1,l,(l+r)/2);\n\t\tll vr=query(a,b,k*2+2,(l+r)/2,r);\n\t\treturn max(vl,vr);\n\t}\n}\n\nint main(void){\n\t\n\tll in,m,ans=0;\n\t\n\tcin >> m;\n\t\n\tinit(m);\n\t\n\tfor(int i=0;i<m;i++){\n\t\tcin >> in;\n\t\tupdate(in,in+query(1,in,0,0,n));\n\t}\n\tcout << m*(m+1)/2-query(1,m+1,0,0,n) << endl;\n\t\n\treturn 0;\n}"
  },
  {
    "language": "C++",
    "code": "// AOJ 2431\n#include<cstdio>\n#include<algorithm>\n#define rep(i,a) for( int i = 0; i != (a); ++i )\n\ntypedef long long ll;\n\nll n, dat[(1<<18)-1];\nint sz;\n\nvoid init()\n{\n\tsz = 1;\n\twhile( sz < n )\n\t\tsz <<= 1;\n\n\trep( i, (sz<<1)-1 )\n\t\tdat[i] = 0;\n\n\treturn;\n}\n\nvoid update( int k, ll x )\n{\n\tk += sz-1;\n\tdat[k] = x;\n\n\twhile( k )\n\t{\n\t\tk = (k-1)>>1;\n\t\tdat[k] = std::max( dat[(k<<1)+1], dat[(k<<1)+2] );\n\t}\n\n\treturn;\n}\n\nint query( int a, int b, int k, int l, int r )\n{\n\tif( r <= a || b <= l )\n\t\treturn 0;\n\telse if( a <= l && r <= b )\n\t\treturn dat[k];\n\telse\n\t\treturn std::max( query( a, b, (k<<1)+1, l, (l+r)>>1 ), query( a, b, (k<<1)+2, (l+r)>>1, r ) );\n}\n\nint main()\n{\n\tscanf( \"%lld\", &n );\n\tll ans = 0;\n\tinit();\n\trep( i, n )\n\t{\n\t\tint x;\n\t\tscanf( \"%d\", &x );\n\t\tupdate( x, query( 1, x+1, 0, 0, sz ) + x );\n\t\tans = std::max( ans, dat[x+sz-1] );\n\t}\n\n\tprintf( \"%lld\\n\", (n*(n+1)>>1)-ans );\n\n\treturn 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include <cstdlib>\n#include <iostream>\n#include <vector>\nusing namespace std;\n\ntemplate<class T> inline void chmax(T& a, const T& b) { if(b > a) a = b; }\n\ntypedef long long value; // 格納するデータの型\nconst value INIT = 0ll; // 初期値．目的に応じて，適切な値に変更すること．\n\nclass segment_tree {\nprivate:\n\tint n;\n\tvector<value> dat;\n\n\tvalue func(value a, value b) const { // ノードの値を決める為の関数関数\n\t\treturn max(a, b);\n\t}\n\n\tvalue query(int a, int b, int k, int l, int r) const {\n\t\tif(r <= a || b <= l) // 求める区間が，ノードの区間と重なっていない．\n\t\t\treturn 0;\n\n\t\tif(a <= l && r <= b) { // 求める区間が，ノードの区間を完全に含む．\n\t\t\treturn dat[k];\n\t\t}\n\t\telse {\n\t\t\tconst int mid = (l + r) / 2;\n\t\t\tconst value vl = query(a, b, k * 2 + 1, l, mid);\n\t\t\tconst value vr = query(a, b, k * 2 + 2, mid, r);\n\t\t\treturn func(vl, vr);\n\t\t}\n\t}\n\npublic:\n\tsegment_tree(int n_) {\n\t\tn = 1;\n\t\twhile(n < n_)\n\t\t\tn *= 2;\n\n\t\tdat.resize(2 * n - 1, INIT);\n\t}\n\n\tvoid update(int k, value a) { // k番目の要素をaに更新する．\n\t\tk += n - 1;\n\t\tdat[k] = a;\n\t\twhile(k > 0) {\n\t\t\tk = (k - 1) / 2;\n\t\t\tdat[k] = func(dat[k * 2 + 1], dat[k * 2 + 2]);\n\t\t}\n\t}\n\n\tvalue query(int a, int b) { // [a, b)に対するクエリ\n\t\treturn query(a, b, 0, 0, n);\n\t}\n};\n\nint main() {\n\tcin.tie(0);\n\tios::sync_with_stdio(false);\n\n\tint m;\n\tcin >> m;\n\n\tsegment_tree segt(m);\n\n\tlong long mx = 0;\n\tfor(int i = 0; i < m; ++i) {\n\t\tint w;\n\t\tcin >> w;\n\n\t\tlong long tmp = segt.query(1, w) + w;\n\t\tsegt.update(w, tmp);\n\t\tchmax(mx, tmp);\n\t}\n\n\tcout << ((m + 1ll) * m / 2ll - mx) << endl;\n\treturn EXIT_SUCCESS;\n}"
  },
  {
    "language": "C++",
    "code": "#include <iostream>\n#include <iomanip>\n#include <sstream>\n#include <cstdio>\n#include <cstdlib>\n#include <cstring>\n#include <cmath>\n#include <climits>\n#include <cfloat>\n#include <vector>\n#include <string>\n#include <stack>\n#include <queue>\n#include <set>\n#include <map>\n#include <algorithm>\n#include <functional>\n#include <utility>\n#include <numeric>\n#include <iterator>\n\nusing namespace std;\n\ntypedef long long LL;\ntypedef unsigned long long ULL;\ntypedef vector<int> VI;\ntypedef vector<VI> VVI;\ntypedef vector<string> VS;\ntypedef pair<int,int> PII;\ntypedef vector<PII> VPII;\ntypedef istringstream ISS;\ntypedef ostringstream OSS;\n\n#define REP( i, m, n ) for ( int i = (int)( m ); i < (int)( n ); ++i )\n#define FOR( v, c ) for ( auto &v : c )\n#define EACH( it, c ) for ( auto it = c.begin(); it != c.end(); ++it )\n#define ALL( c ) (c).begin(), (c).end()\n#define DRANGE( c, p ) (c).begin(), (c).begin() + p, (c).end()\n\n#define PB( n ) push_back( n )\n#define MP( a, b ) make_pair( ( a ), ( b ) )\n#define EXIST( c, e ) ( (c).find( e ) != (c).end() )\n\n#define fst first\n#define snd second\n\n#define DUMP( x ) cerr << #x << \" = \" << ( x ) << endl\n#define DEBUG( x ) cerr << __FILE__ << \":\" << __LINE__ << \": \" << #x << \" = \" << ( x ) << endl\n\nconst int INF = INT_MAX / 4;\n\n// セグメント木のユーティリティ\ninline const int chl( const int k )\n{\n\treturn k * 2 + 1;\n}\n\ninline const int chr( const int k )\n{\n\treturn k * 2 + 2;\n}\n\ninline const int mid( const int l, const int r )\n{\n\treturn ( l + r ) / 2;\n}\n\n// セグメント木による Range Maximum Query\nclass RangeMaximumQuery\n{\nprivate:\n\tconst int N;\n\tvector<int> data;\n\npublic:\n\tRangeMaximumQuery( const vector<int> &src ) : N( src.size() ), data( N * 4 )\n\t{\n\t\tREP( i, 0, N )\n\t\t{\n\t\t\tupdate( i, src[i] );\n\t\t}\n\n\t\treturn;\n\t}\n\n\tvoid update( const int p, const int x )\n\t{\n\t\treturn update( p, x, 0, 0, N );\n\t}\n\n\tint maximum( const int a, const int b ) const\n\t{\n\t\treturn maximum( a, b, 0, 0, N );\n\t}\nprivate:\n\tvoid update( const int p, const int x, const int k, const int l, const int r )\n\t{\n\t\tif ( p < l || r <= p )\n\t\t{\n\t\t\treturn;\n\t\t}\n\t\tif ( l + 1 == r && p == l )\n\t\t{\n\t\t\tdata[k] = x;\n\t\t\treturn;\n\t\t}\n\n\t\tupdate( p, x, chl( k ), l, mid( l, r ) );\n\t\tupdate( p, x, chr( k ), mid( l, r ), r );\n\t\tdata[k] = max( data[ chl( k ) ], data[ chr( k ) ] );\n\t\n\t\treturn;\n\t}\n\n\tint maximum( const int a, const int b, const int k, const int l, const int r ) const\n\t{\n\t\tif ( b <= l || r <= a )\n\t\t{\n\t\t\treturn INT_MIN;\n\t\t}\n\t\telse if ( a <= l && r <= b )\n\t\t{\n\t\t\treturn data[k];\n\t\t}\n\t\telse\n\t\t{\n\t\t\treturn max( maximum( a, b, chl( k ), l, mid( l, r ) ), maximum( a, b, chr( k ), mid( l, r ), r ) );\n\t\t}\n\t}\n};\n// RangeMaximumQuery( VI src )\n// update( pos, x )\n// maximum( [ a, b ) )\n\nint main()\n{\n\tcin.tie( 0 );\n\tios::sync_with_stdio( false );\n\n\tint n;\n\tcin >> n;\n\n\tVI xs( n );\n\tREP( i, 0, n )\n\t{\n\t\tcin >> xs[i];\n\t}\n\n\tRangeMaximumQuery rmq( VI( n + 1, -INF ) );\n\trmq.update( 0, 0 );\n\n\tREP( i, 0, n )\n\t{\n\t\trmq.update( xs[i], rmq.maximum( 0, xs[i] ) + xs[i] );\n\t}\n\n\tcout << accumulate( ALL( xs ), 0 ) - rmq.maximum( 0, n + 1 ) << endl;\n\n\treturn 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\nusing namespace std;\n\n#define for_(i,a,b) for(int i=(a);i<(b);++i)\n#define for_rev(i,a,b) for(int i=(a);i>=(b);--i)\n\ntemplate< typename T >\nusing Vec = vector< T >;\n\ntypedef long long lint;\n\ntemplate< typename DATA >\nclass SegmentTree {\nprivate:\n\tint size__;\n\tVec< DATA > data;\n\t\n\tinline int left_t(int k) {\n\t\treturn (k << 1) + 1;\n\t}\n\t\n\tinline int right_t(int k) {\n\t\treturn (k << 1) + 2;\n\t}\n\t\n\tinline int center(int l, int r) {\n\t\treturn (l + r) >> 1;\n\t}\n\t\npublic:\n\tSegmentTree(int n, DATA ini) {\n\t\tfor (size__ = 1; size__ < n; size__ <<= 1);\n\t\tdata.assign(2 * size__ - 1, ini);\n\t}\n\t\n\tDATA calc(DATA d1, DATA d2) {\n\t\treturn max(d1, d2);\n\t}\n\t\n\tvoid update(int k, DATA a) {\n\t\tk += size__ - 1;\n\t\tdata[k] = a;\n\t\t\n\t\twhile (k > 0) {\n\t\t\tk = (k - 1) >> 1;\n\t\t\tdata[k] = calc(data[left_t(k)], data[right_t(k)]);\n\t\t}\n\t}\n\t\n\tDATA query(int a, int b) {\n\t\treturn query(a, b, 0, 0, size__);\n\t}\n\t\n\tDATA query(int a, int b, int k, int l, int r) {\n\t\tif (r <= a || b <= l) return 0;\n\t\tif (a <= l && r <= b) return data[k];\n\t\treturn calc(query(a, b, left_t(k), l, center(l, r)),\n\t\t\t\t\tquery(a, b, right_t(k), center(l, r), r));\n\t}\n\t\n\tint size() {\n\t\treturn size__;\n\t}\n};\n\nint n, x[100010];\n\nsigned main() {\n\tcin >> n;\n\tfor_(i,0,n) cin >> x[i];\n\t\n\tSegmentTree< lint > st(n + 1, 0);\n\tfor_(i,0,n) st.update(x[i], x[i] + st.query(1, x[i]));\n\tcout << n * (n + 1) / 2 - st.query(1, n + 1) << endl;\n}"
  },
  {
    "language": "C++",
    "code": "#include <algorithm>\n#include <cstring>\n#include <deque>\n#include <functional>\n#include <iostream>\n#include <map>\n#include <numeric>\n#include <queue>\n#include <set>\n#include <vector>\nusing namespace std;\nusing ll = long long;\n\nstruct SegmentTree {\n  int n;\n  vector<ll> dat;\n  SegmentTree(int n_) {\n    n = 1;\n    while (n < n_) n *= 2;\n    dat.resize(2 * n - 1, 0ll);\n  }\n  void update(int k, ll a) {\n    k += n - 1;\n    dat[k] = a;\n    while (k > 0) {\n      k = (k - 1) / 2;\n      dat[k] = max(dat[k * 2 + 1], dat[k * 2 + 2]);\n    }\n  }\n  ll query(int a, int b, int k, int l, int r) {\n    if (r <= a || b <= l) return 0;\n    if (a <= l && r <= b) return dat[k];\n    ll vl = query(a, b, k * 2 + 1, l, (l + r) / 2);\n    ll vr = query(a, b, k * 2 + 2, (l + r) / 2, r);\n    return max(vl, vr);\n  }\n  ll query(int a, int b) { return query(a, b, 0, 0, n); }\n};\n\nint main() {\n  int N;\n  while (cin >> N) {\n    SegmentTree dp(N);\n    ll sum = 0;\n    for (int i = 0; i < N; i++) {\n      int x;\n      cin >> x;\n      --x;\n      ll mx = dp.query(0, x);\n      dp.update(x, mx + x + 1);\n      sum += x + 1;\n    }\n    ll mx = 0;\n    for (int i = 0; i < N; i++) {\n      mx = max(mx, dp.query(i, i + 1));\n    }\n    ll ans = sum - mx;\n    cout << ans << endl;\n  }\n}\n\n"
  },
  {
    "language": "C++",
    "code": "#include <algorithm>\n#include <bitset>\n#include <cassert>\n#include <cctype>\n#include <climits>\n#include <cmath>\n#include <complex>\n#include <cstdio>\n#include <cstdlib>\n#include <cstring>\n#include <ctime>\n#include <deque>\n#include <functional>\n#include <iostream>\n#include <iterator>\n#include <list>\n#include <map>\n#include <numeric>\n#include <queue>\n#include <set>\n#include <sstream>\n#include <stack>\n#include <string>\n#include <utility>\n#include <vector>\nusing namespace std;\n\n#define dump(a) (cerr << (#a) << \" = \" << (a) << endl)\n#define FOR(it,c) for(__typeof((c).begin())it=(c).begin(); it!=(c).end();++it)\n#define RFOR(it,c) for(__typeof((c).rbegin())it=(c).rbegin(); it!=(c).rend();++it)\n#define exist(c, v) (find((c).begin(), (c).end(), (v)) != (c).end())\n\ntemplate<class T> inline void chmax(T& a, const T& b) { if(b > a) a = b; }\ntemplate<class T> inline void chmin(T& a, const T& b) { if(b < a) a = b; }\n\ntemplate<typename T, typename U> ostream& operator<<(ostream& os, const pair<T, U>& p) {\n\tos << '(' << p.first << \", \" << p.second << ')';\n\treturn os;\n}\n\ntemplate<typename T> ostream& operator<<(ostream& os, const vector<T>& v) {\n\tcopy(v.begin(), v.end(), ostream_iterator<T>(os, \" \"));\n\treturn os;\n}\n\nconst int MAX_N = 1 << 17;\n\nint n;\nlong long dat[2 * MAX_N - 1];\n\nvoid init(int n_) {\n\tn = 1;\n\twhile(n < n_)\n\t\tn *= 2;\n\n\tfill(dat, dat + 2 * n - 1, 0);\n}\n\nvoid update(int k, long long a) {\n\tk += n - 1;\n\tdat[k] = a;\n\n\twhile(k > 0) {\n\t\tk = (k - 1) / 2;\n\t\tdat[k] = max(dat[k * 2 + 1], dat[k * 2 + 2]);\n\t}\n}\n\nlong long query(int a, int b, int k = 0, int l = 0, int r = n) {\n\tif(r <= a || b <= l)\n\t\treturn 0;\n\n\tif(a <= l && r <= b) {\n\t\treturn dat[k];\n\t}\n\telse {\n\t\tlong long vl = query(a, b, k * 2 + 1, l, (l + r) / 2);\n\t\tlong long vr = query(a, b, k * 2 + 2, (l + r) / 2, r);\n\t\treturn max(vl, vr);\n\t}\n}\n\n\nint main() {\n\tcin.tie(0);\n\tios::sync_with_stdio(false);\n\n\tint m;\n\tcin >> m;\n\n\tinit(m);\n\n\tlong long mx = 0;\n\tfor(int i = 0; i < m; ++i) {\n\t\tint w;\n\t\tcin >> w;\n\n\t\tlong long tmp = query(1, w) + w;\n\t\tupdate(w, tmp);\n\t\tchmax(mx, tmp);\n\t}\n\n\tcout << ((1ll + m) * m / 2ll - mx) << endl;\n\n\treturn EXIT_SUCCESS;\n}"
  },
  {
    "language": "C++",
    "code": "#include<iostream>\n#include<vector>\n#include<algorithm>\n#include<climits>\n\nconst int MAX_N=100000;\n\nusing namespace std;\n\nint n,dat[2*MAX_N-1];\n\nvoid init(int n_){\n\tn=1;\n\twhile(n<n_)n*=2;\n\tfor(int i=0;i<2*n-1;i++)dat[i]=0;\n}\n\nvoid update(int k,int a){\n\tk+=n-1;\n\tdat[k]=a;\n\t\n\twhile(k>0){\n\t\tk=(k-1)/2;\n\t\tdat[k]=max(dat[2*k+1],dat[2*k+2]);\n\t}\n}\n\nint query(int a,int b,int k,int l,int r){\n\tif(r<=a || b<=l)return 0;\n\tif(a<=l && r<=b)return dat[k];\n\telse {\n\t\tint vl=query(a,b,k*2+1,l,(l+r)/2);\n\t\tint vr=query(a,b,k*2+2,(l+r)/2,r);\n\t\treturn max(vl,vr);\n\t}\n}\n\nint main(void){\n\t\n\tlong long in,n_,ans=0;\n\tcin >> n_;\n\t\n\tinit(n_);\n\t\n\tfor(int i=0;i<n_;i++){\n\t\tcin >> in;\n\t\tupdate(in,in+query(1,in+1,0,0,n));\n\t\tans=max(ans,dat[in+n-1]);\n\t}\n\tcout << n_*(n_+1)/2-ans << endl;\n\t\n\treturn 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include <iostream>\n#include <vector>\n#include <algorithm>\nusing namespace std;\nconst int inf = 1e9;\n\n//range min\nstruct segmentTree{\n\tvector<int> node;\n\tint n;\n\t\n\tsegmentTree(vector<int> v){\n\t\tint s = v.size();\n\t\tn = 2;\n\t\twhile(n < s) n *= 2;\n\t\tnode = vector<int>(2*n -1, inf);\n\t\tfor(int i=0; i<s; i++){\n\t\t\tnode[i +n-1] = v[i];\n\t\t}\n\t\tfor(int i=n-2; i>=0; i--){\n\t\t\tnode[i] = min(node[2*i +1], node[2*i +2]);\n\t\t}\n\t}\n\t\n\tvoid Set(int val, int pos){\n\t\tint idx = n-1 + pos;\n\t\tnode[idx] = val;\n\t\tdo{\n\t\t\tidx = (idx -1)/2;\n\t\t\tnode[idx] = min(node[2*idx +1], node[2*idx +2]);\n\t\t}while(idx != 0);\n\t}\n\tint Get(int l, int r){\n\t\treturn _get(l, r, 0, 0, n);\n\t}\n\tint _get(int l, int r, int k, int cl, int cr){\n\t\tif(l <= cl && cr <= r){\n\t\t\treturn node[k];\n\t\t}\n\t\tif(r <= cl || cr <= l){\n\t\t\treturn inf;\n\t\t}\n\t\tint m = (cl +cr)/2;\n\t\treturn min(_get(l, r, 2*k+1, cl, m), _get(l, r, 2*k+2, m, cr));\n\t}\n};\n\nsigned main(){\n\tint n;\n\tcin >> n;\n\tvector<int> x(n);\n\tfor(int i=0; i<n; i++){\n\t\tcin >> x[i];\n\t}\n\tsegmentTree segtree(vector<int>(n+1, 0));\n\tfor(int i=0; i<n; i++){\n\t\tsegtree.Set(segtree.Get(0, x[i]) -x[i], x[i]);\n\t}\n\tcout << n*(n+1)/2 +segtree.Get(1, n+1) << endl;\n\treturn 0;\n}\n"
  },
  {
    "language": "C++",
    "code": "#include<bits/stdc++.h>\nusing namespace std;\n#define int long long\n#define pb push_back \n#define mp make_pair\n#define fr first\n#define sc second\n#define Rep(i,n) for(int i=0;i<(n);i++)\n#define All(v) v.begin(),v.end()\ntypedef pair<int, int> Pii; typedef pair<int, Pii> Pip;\nconst int INF = (1<<30);\n\nstruct SegT\n{\n  vector<int> tree;\n  int n;\n \n  SegT(int n_)\n  {\n    n = 1;\n    while( n < n_ ) n <<= 1;\n    tree = vector<int>(2 * n - 1, 0);\n  }\n  int rmq(int a, int b, int k, int l, int r)\n  {\n    if( a >= r || b <= l ) return 0;\n    if( a <= l && r <= b ) return tree[k];\n    return(max(rmq(a, b, 2 * k + 1, l, (l + r) >> 1),\n               rmq(a, b, 2 * k + 2, (l + r) >> 1, r)));\n  }\n  int rmq(int a, int b)\n  {\n    return (rmq(a, b, 0, 0, n));\n  }\n  int update(int k, int x)\n  {\n    k += n - 1;\n    tree[k] = x;\n    while( k > 0 ) {\n      k = (k - 1) >> 1;\n      tree[k] = max(tree[2 * k + 1], tree[2 * k + 2]);\n    }\n  }\n};\n\nmain() {\n  int n;\n  cin >> n;\n  SegT tree( n+1 );\n\n  Rep(i, n) {\n    int x;\n    cin >> x;\n    tree.update(x, tree.rmq(1, x) + x);\n  }\n\n  cout << n * (n+1) / 2 - tree.rmq(1, n) << endl;\n}"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\nusing namespace std;\n\n#define int long long\n#define for_(i,a,b) for(int i=(a);i<(b);++i)\n#define for_rev(i,a,b) for(int i=(a);i>=(b);--i)\n\nint n, x[100010];\nint dp[100010], sum[100010];\n\nsigned main() {\n\tcin >> n;\n\tfor_(i,0,n) cin >> x[i];\n\t\n\tmemset(dp, 0, sizeof(dp));\n\tmemset(sum, 0, sizeof(sum));\n\t\n\tdp[n] = 100010;\n\t\n\tfor_rev(i,n-1,0) {\n\t\tint ind = lower_bound(dp, dp + n + 1, x[i]) - dp - 1;\n\t\t\n\t\tif (sum[ind] <= sum[ind + 1] + x[i]) {\n\t\t\tdp[ind] = x[i];\n\t\t\tsum[ind] = sum[ind + 1] + x[i];\n\t\t}\n\t}\n\t\n\tcout << (n * (n + 1) / 2 - *max_element(sum, sum + n)) << endl;\n}"
  },
  {
    "language": "C++",
    "code": "#include <stdio.h>\n#include <cmath>\n#include <algorithm>\n#include <cfloat>\n#include <stack>\n#include <queue>\n#include <vector>\n#include <string>\n#include <iostream>\ntypedef long long int ll;\ntypedef unsigned long long int ull;\n#define BIG_NUM 2000000000\n#define MOD 1000000007\n#define EPS 0.000000001\nusing namespace std;\n\n#define NUM 0\n\nint N;\nll* table;\n\nvoid init(int first_N){\n\twhile(N < first_N)N *= 2;\n}\n\nvoid update(int loc,ll value){\n\tloc += N-1;\n\n\ttable[loc] = value;\n\n\tif(N == 1)return;\n\n\tint parent = (loc-1)/2;\n\n\twhile(true){\n\t\ttable[parent] = max(table[2*parent+1],table[2*parent+2]);\n\n\t\tif(parent == 0)break;\n\t\telse{\n\t\t\tparent = (parent-1)/2;\n\t\t}\n\t}\n}\n\n\nll query(int search_left,int search_right,int node_id,int node_left,int node_right){\n\n\tif(search_right < node_left || search_left > node_right)return NUM;\n\n\tif(search_left <= node_left && search_right >= node_right){\n\t\treturn table[node_id];\n\t}\n\n\tll left_max = query(search_left,search_right,2*node_id+1,node_left,(node_left+node_right)/2);\n\tll right_max = query(search_left,search_right,2*node_id+2,(node_left+node_right)/2+1,node_right);\n\n\treturn max(left_max,right_max);\n}\n\n\nint main(){\n\n\tint first_N;\n\ttable = new ll[263000];\n\tN = 1;\n\n\tscanf(\"%d\",&first_N);\n\n\tinit(100001);\n\n\tfor(int i = 0; i <= 2*N-2; i++)table[i] = NUM;\n\n\tll tmp,left_max,sum = 0;\n\n\tfor(int loop = 0; loop < first_N; loop++){\n\n\t\tscanf(\"%lld\",&tmp);\n\n\t\tleft_max = query(0,tmp-1,0,0,N-1);\n\n\t\tupdate(tmp,left_max+tmp);\n\n\t\tsum += tmp;\n\t}\n\n\tll ans = 0;\n\n\tfor(int i = 1; i <= 100000; i++){\n\t\tans = max(ans,table[N-1+i]);\n\t}\n\n\tprintf(\"%lld\\n\",sum - ans);\n\n\treturn 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include <vector>\n#include <list>\n#include <map>\n#include <set>\n#include <deque>\n#include <stack>\n#include <bitset>\n#include <algorithm>\n#include <functional>\n#include <numeric>\n#include <utility>\n#include <sstream>\n#include <queue>\n#include <iostream>\n#include <iomanip>\n#include <cstdio>\n#include <cmath>\n#include <cstdlib>\n#include <cctype>\n#include <string>\n#include <cstring>\n#include <ctime>\n#include <fstream>\n#include <stdio.h>\n#include <complex>\n\nusing namespace std;\n\n//conversion\n//------------------------------------------\ninline int toInt(string s) {int v; istringstream sin(s);sin>>v;return v;}\ntemplate<class T> inline string toString(T x) {ostringstream sout;sout<<x;return sout.str();}\n\n//typedef\n//------------------------------------------\ntypedef vector<int> VI;\ntypedef vector<VI> VVI;\ntypedef vector<string> VS;\ntypedef pair<int, int> PII;\ntypedef pair<int, PII> TIII;\ntypedef long long LL;\ntypedef vector<LL> VLL;\n\n//container util\n\n//------------------------------------------\n#define ALL(a)  (a).begin(),(a).end()\n#define RALL(a) (a).rbegin(), (a).rend()\n#define PB push_back\n#define MP make_pair\n#define SZ(a) int((a).size())\n#define EACH(i,c) for(typeof((c).begin()) i=(c).begin(); i!=(c).end(); ++i)\n#define EXIST(s,e) ((s).find(e)!=(s).end())\n#define SORT(c) sort((c).begin(),(c).end())\n#define MT(a,b,c) MP(a, MP(b, c))\n\n//repetition\n//------------------------------------------\n#define FOR(i,a,b) for(int i=(a);i<(b);++i)\n#define REP(i,n)  FOR(i,0,n)\n\nclass SegTree{\n\tpublic:\n\tVLL dat;\n\tint n;\n\tLL DEF;\n\tSegTree(int N){\n\t\tn = 1;\n\t\tDEF = 0;\n\t\twhile(n<N)n*=2;\n\t\tdat = VLL(2*n-1, DEF);\n\t}\n\tvoid update(int index, LL v){\n\t\tint k=index+n-1;\n\t\tdat[k]=v; \n\t\twhile(1){\n\t\t\tk=(k-1)/2;//上に登る\n\t\t\tdat[k] = value(k);\n\t\t\tif(k==0)break;\n\t\t}\n\t}\n\tinline LL value(int idx){//Update value with (2*idx+1, 2*idx+2) \n\t\treturn value(dat[2*idx+1], dat[2*idx+2]);\n\t}\n\tinline LL value(LL v1, LL v2){\n\t\treturn max(v1, v2);\n\t}\n\tLL query(int idx1, int idx2, int node=0, int range1=0, int range2=-10){\n\t\tif(range2 == -10 )range2 = n;\n\t\tif(range2 <= idx1 || idx2 <= range1)return DEF;//交差しない\n\t\tif(idx1 <= range1 && range2 <= idx2)return dat[node];\n\t\telse{\n\t\t\tLL vl = query(idx1, idx2, node*2+1, range1, (range1+range2)/2);\n\t\t\tLL vr = query(idx1, idx2, node*2+2, (range1+range2)/2, range2); \n\t\t\treturn value(vl, vr);\n\t\t}\n\t}\n};\n\nint main(){\n\tint n;\n\tcin >> n;\n\tSegTree seg(n);\n\tREP(i,n){\n\t\tint tmp;\n\t\tscanf(\"%d\", &tmp);\n\t\tLL v = seg.query(0, tmp-1);\n\t\tseg.update(tmp-1, v+tmp);\n\t}\n\tcout << ((LL)n)*(n+1)/2-seg.query(0, n)<< endl;\n\treturn 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\nusing namespace std;\nusing ll = long long;\n\nint n;\nll b[100001];\n\nll find(int s) {\n\tll res = 0;\n\tfor (int i = s; i > 0; i = i & (i - 1))\n\t\tres = max(res, b[i]);\n\treturn res;\n}\n\nvoid update(int s, ll val) {\n\tfor (int i = s; i <= n; i += (i & -i))\n\t\tb[i] = max(b[i], val);\n}\n\nint main()\n{\n\tcin.sync_with_stdio(false);\n\tcin >> n;\n\tll sum = 0;\n\tfor (int i = 0, x; i < n; i++) {\n\t\tcin >> x;\n\t\tsum += x;\n\t\tupdate(x, find(x - 1) + x);\n\t}\n\tprintf(\"%lld\\n\", sum - find(n));\n\treturn 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include<algorithm>\n#include<cassert>\n#include<cctype>\n#include<climits>\n#include<cmath>\n#include<cstdio>\n#include<cstdlib>\n#include<cstring>\n#include<iostream>\n#include<iomanip>\n#include<map>\n#include<numeric>\n#include<queue>\n#include<vector>\n#include<set>\n#include<string>\n#include<stack>\n#include<sstream>\n#include<complex>\n\n#define pb push_back\n#define clr clear()\n#define sz size()\n#define fs first\n#define sc second\n\n#define rep(i,a) for(int i=0;i<(int)(a);i++)\n#define rrep(i,a) for(int i=(int)(a)−1;i>=0;i−−)\n#define all(a) (a).begin(),(a).end()\n#define EQ(a,b) (abs((a)−(b)) < EPS)\n#define INIT(a) memset(a,0,sizeof(a))\n\nusing namespace std;\ntypedef double D;\ntypedef pair<int,int> P;\ntypedef long long ll;\ntypedef vector<int> vi;\ntypedef vector<string> vs;\n\nconst D EPS = 1e-7;\nconst D INF = 1e9;\nconst D PI = acos(-1);\nconst int N = 200100;\n\nll n,dat[2*N-1];\n\nvoid init(int n_){\n  n=1;\n  while(n<n_)n*=2;\n  rep(i,2*n-1)dat[i] = 0;\n}\n\nvoid update(ll k,ll a){\n  k += n-1;\n  dat[k] = a;\n  while(k>0){\n    k = (k-1)/2;\n    dat[k] = max(dat[k*2+1],dat[k*2+2]);\n  }\n}\n\n//return minimam value in [a,b). ( [l,r) is interval in which k is.)\nll query(int a,int b,int k,int l,int r){\n  if(r<=a || b<=l)return 0;\n  if(a<=l && r<=b)return dat[k];\n  ll vl = query(a,b,2*k+1,l,(l+r)/2);\n  ll vr = query(a,b,2*k+2,(l+r)/2,r);\n  return max(vl,vr);\n}\n\nint main(){\n  ll n_, x[N];\n\n  cin >> n_;\n  rep(i,n_)cin >> x[i];\n  init(n_);\n\n  ll ans = 0;\n  rep(i,n_){\n    ll val = query(0,x[i],0,0,n) + x[i];\n    ans = max(ans,val);\n    update(x[i]-1,val);\n  }\n\n  cout << n_*(n_+1)/2 - ans << endl;\n}"
  },
  {
    "language": "C++",
    "code": "#include<iostream>\n#include<cstring>\n\nusing namespace std;\n\ntypedef long long ll;\nconst int MAX = (1<<18);\n\nclass SegmentTree{\npublic:\n  int n;\n  ll dat[MAX];\n\n  void init(int num){\n    n = 1;\n    while(n < num) n*=2;\n    memset(dat,0,sizeof(dat));\n  }\n\n  void update(int k, ll a){\n    k += n-1;\n    dat[k] = a;\n\n    while(k > 0){\n      k = (k-1)/2;\n      dat[k] = max(dat[k*2+1],dat[k*2+2]);\n    }\n  }\n\n  ll query(int a, int b, int k, int l, int r){\n    if(r <= a || b <= l) return 0;\n    \n    if(a <= l && r <= b) return dat[k];\n\n    int vl = query(a,b,k*2+1,l,(l+r)/2);\n    int vr = query(a,b,k*2+2,(l+r)/2,r);\n    return max(vl,vr);\n  }\n};\n\nint main(){\n\n  ll n;\n  cin >> n;\n  SegmentTree st;\n  st.init(n);\n  \n  ll ans = 0;\n \n  for(int i = 0; i < n; i++){\n    ll x;\n    cin >> x;\n    ll nex = st.query(1,x+1,0,0,st.n)+x;\n    st.update(x,nex);\n    ans = max(ans,nex);\n  }\n  cout << (n*(n+1LL))/2LL - ans << endl;\n\n  return 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include<iostream>\n#include<vector>\n#include<algorithm>\nusing namespace std;\ntypedef long long ll;\n#define INF (1 << 30)\nstruct SegmentTree{\nprivate:\n  ll dat[1 << 18];\n  int n;\npublic:\n  SegmentTree(){}\n  SegmentTree(int size){\n    n = 1;\n    while(n < size) n *= 2;\n  }\n  int getSize(){\n    return n;\n  }\n  ll getSeg(int s){\n    return dat[s];\n  }\n  void update(int i,ll x){\n    i += n - 1;\n    dat[i] = x;\n    while(i > 0){\n      i = ( i - 1 ) / 2;\n      dat[i] = max( dat[i * 2 + 1] , dat[i * 2 + 2]);\n    }\n  }\n  ll query(int a,int b,int k,int l,int r){\n    if(r <= a || b <= l) return 0;\n    if(a <= l && r <= b) return dat[k];\n    ll vl = query(a,b,k*2+1,l,(l+r)/2);\n    ll vr = query(a,b,k*2+2,(l+r)/2,r);\n    return max(vl,vr);\n  }\n};\nint main(){\n  int n;\n  ll ans = 0;\n  cin >> n;\n  SegmentTree BIT(n);\n  for(int i = 0 , x ; i < n ; i++ ){\n    cin >> x;\n    BIT.update( x , BIT.query(1,x+1,0,0,BIT.getSize()) + x );\n    ans = max( ans , BIT.getSeg( x + BIT.getSize() - 1));\n  }\n  cout << (n * (n + 1) / 2 - ans) << endl;\n}"
  },
  {
    "language": "C++",
    "code": "#include<iostream>\n#include<vector>\n#include<algorithm>\nusing namespace std;\ntypedef long long ll;\n#define INF (1 << 30)\nstruct SegmentTree{\nprivate:\n  ll dat[1 << 18];\n  int n;\npublic:\n  SegmentTree(){}\n  SegmentTree(int size){\n    n = 1;\n    while(n < size) n *= 2;\n  }\n  ll getSize(){\n    return n;\n  }\n  ll getSeg(int s){\n    return dat[s];\n  }\n  void update(int i,ll x){\n    i += n - 1;\n    dat[i] = x;\n    while(i > 0){\n      i = ( i - 1 ) / 2;\n      dat[i] = max( dat[i * 2 + 1] , dat[i * 2 + 2]);\n    }\n  }\n  ll query(int a,int b,int k,int l,int r){\n    if(r <= a || b <= l) return 0;\n    if(a <= l && r <= b) return dat[k];\n    ll vl = query(a,b,k*2+1,l,(l+r)/2);\n    ll vr = query(a,b,k*2+2,(l+r)/2,r);\n    return max(vl,vr);\n  }\n};\nint main(){\n  int n;\n  ll ans = 0;\n  cin >> n;\n  SegmentTree BIT(n);\n  for(int i = 0 , x ; i < n ; i++ ){\n    cin >> x;\n    BIT.update( x , BIT.query(1,x+1,0,0,BIT.getSize()) + x );\n    ans = max( ans , BIT.getSeg( x + BIT.getSize() - 1));\n  }\n  cout << ((ll)n * (ll)(n + 1) / 2 - ans) << endl;\n}"
  },
  {
    "language": "C++",
    "code": "#include \"bits/stdc++.h\"\nusing namespace std;\ntypedef long long LL;\nLL bit[100001];\nint n;\nLL max_q(int i) {\n\tLL ret = 0;\n\twhile (i > 0) {\n\t\tret = max(ret, bit[i]);\n\t\ti -= i&-i;\n\t}\n\treturn ret;\n}\nvoid update(int i, LL x) {\n\tbit[i] = max(bit[i], x);\n\twhile (i <= n) {\n\t\tbit[i] = max(bit[i], x);\n\t\ti += i&-i;\n\t}\n}\nint main() {\n\tcin >> n;\n\tLL sum = 0;\n\tfor (int i = 0; i < n; i++) {\n\t\tint x;\n\t\tcin >> x;\n\t\tLL r = max_q(x - 1);\n\t\tupdate(x, r + x);\n\t\tsum += x;\n\t}\n\tcout << sum - max_q(n) << endl;\n}\n"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\nusing namespace std;\n\n#define for_(i,a,b) for(int i=(a);i<(b);++i)\n#define for_rev(i,a,b) for(int i=(a);i>=(b);--i)\n\nint n, x[100010];\nint dp[100010], sum[100010];\n\nint main() {\n\tcin >> n;\n\tfor_(i,0,n) cin >> x[i];\n\t\n\tmemset(dp, 0, sizeof(dp));\n\tmemset(sum, 0, sizeof(sum));\n\t\n\tdp[n] = 10001;\n\t\n\tfor_rev(i,n-1,0) {\n\t\tint ind = lower_bound(dp, dp + n + 1, x[i]) - dp - 1;\n\t\tdp[ind] = x[i];\n\t\tsum[ind] = sum[ind + 1] + x[i];\n\t}\n\t\n\tcout << (n * (n + 1) / 2 - *max_element(sum, sum + n)) << endl;\n}"
  },
  {
    "language": "C++",
    "code": "#include <stdio.h>\n#include <algorithm>\n#pragma warning(disable : 4996)\nusing namespace std;\nint n, a[100000], b[100000]; long long sum, ret, dp[100001], rmq[262144];\nint update(int i, int x) { i += 131072; rmq[i] = x; while (i > 1) i /= 2; rmq[i] = max(rmq[i * 2], rmq[i * 2 + 1]); }\nint query(int p, int q, int k, int l, int r) {\n\tif (r <= p || q <= l) return 0;\n\tif (p <= l && r <= q) return rmq[k];\n\tlong long vl = query(p, q, 2 * k, l, (l + r) / 2);\n\tlong long vr = query(p, q, 2 * k + 1, (l + r) / 2, r);\n\treturn max(vl, vr);\n}\nint main() {\n\tscanf(\"%d\", &n);\n\tfor (int i = 0; i < n; i++) scanf(\"%d\", &a[i]), sum += a[i], b[a[i] - 1] = i;\n\tfor (int i = 1; i <= n; i++) {\n\t\tdp[i] = query(0, a[i - 1], 0, 0, n) + a[i - 1];\n\t\tupdate(a[i - 1], dp[i]);\n\t}\n\tfor (int i = 1; i <= n; i++) ret = max(ret, dp[i]);\n\tprintf(\"%lld\\n\", sum - ret);\n\treturn 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include <iostream>\n#include <cmath>\n#include <algorithm>\n\nusing namespace std;\n\ntypedef long long int ll;\n\nconst int N = 1 << 17;\nll dat[N * 2 - 1] = { 0 }, n, m;\n\nvoid update(int i, ll val) {\n\ti += m - 1;\n\tdat[i] = val;\n\twhile(i > 0) {\n\t\ti = (i - 1) / 2;\n\t\tdat[i] = max(dat[i * 2 + 1], dat[i * 2 + 2]);\n\t}\n\treturn;\n}\n\nll getval(int a, int b, int k, int l, int r) {\n\tif (r <= a || b <= l) return 0;\n\tif (a <= l && r <= b) return dat[k];\n\telse{\n\t\tll vl = getval(a, b, k * 2 + 1, l, (l + r) / 2);\n\t\tll vr = getval(a, b, k * 2 + 2, (l + r / 2), r);\n\t\treturn max(vl, vr);\n\t}\n}\n\nint main(){\n\tint a, v;\n\tdouble p, ip = 0.0, fp;\n\tcin >> n;\n\tp = log2(n);\n\tfp = modf(p, &ip);\n\tif(fp == 0.0) {\n\t\tm = 1 << int(p);\n\t}\n\telse{\n\t\tm = 1 << (int(p) + 1);\n\t}\n\tfor(int i = 0;i < n;++i){\n\t\tcin >> a;\n\t\tv = getval(0, a, 0, 0, m);\n\t\tupdate(a - 1, a + v); // 0-indexedにしたいので\n\t}\n\tcout << n * (n + 1) / 2 - dat[0] << endl;\n\treturn 0;\n}\n\n"
  },
  {
    "language": "C++",
    "code": "#include <cstdio>\n#include <cstdlib>\n#include <cstring>\n#include <climits>\n#include <cmath>\n#include <cassert>\n#include <iostream>\n#include <sstream>\n#include <iomanip>\n#include <algorithm>\n#include <numeric>\n#include <complex>\n#include <list>\n#include <stack>\n#include <queue>\n#include <set>\n#include <map>\n#include <bitset>\n#include <utility>\n#include <functional>\n#include <iterator>\n\nusing namespace std;\n\n#define dump(n) cerr<<\"# \"<<#n<<\"=\"<<(n)<<endl\n#define repi(i,a,b) for(int i=int(a);i<int(b);i++)\n#define peri(i,a,b) for(int i=int(b);i-->int(a);)\n#define rep(i,n) repi(i,0,n)\n#define per(i,n) peri(i,0,n)\n#define iter(c) __typeof__((c).begin())\n#define foreach(i,c) for(iter(c) i=(c).begin();i!=(c).end();++i)\n#define all(c) (c).begin(),(c).end()\n#define mp make_pair\n\ntypedef unsigned int uint;\ntypedef long long ll;\ntypedef unsigned long long ull;\ntypedef vector<int> vi;\ntypedef vector<vi> vvi;\ntypedef vector<double> vd;\ntypedef vector<vd> vvd;\ntypedef vector<string> vs;\ntypedef pair<int,int> pii;\n\nstruct SegTree{\n\tvector<ll> data;\n\tint size;\n\tSegTree(int _size){\n\t\tfor(int i=1;;i<<=1)\n\t\t\tif(i>=_size){\n\t\t\t\tsize=i;\n\t\t\t\tbreak;\n\t\t\t}\n\t\tdata.assign(2*size,0);\n\t}\n\tvoid Update(int i,ll n){\n\t\tdata[size+i]=n;\n\t\tfor(int j=size+i;j;j>>=1)\n\t\t\tdata[j]=max(data[j],n);\n\t}\n\tll Query(int a,int b,int i,int l,int r){\n\t\tif(b<=l || r<=a) return 0;\n\t\tif(a<=l && r<=b) return data[i];\n\t\tll res=0;\n\t\tint m=(l+r)/2;\n\t\tif(a<m) res=max(res,Query(a,b,i*2+0,l,m));\n\t\tif(m<b) res=max(res,Query(a,b,i*2+1,m,r));\n\t\treturn res;\n\t}\n\tll Query(int a,int b){\n\t\treturn Query(a,b,1,0,size);\n\t}\n};\n\nint main()\n{\n\tfor(int n;cin>>n;){\n\t\tvi a(n);\n\t\trep(i,n) cin>>a[i];\n\t\t\n\t\tvi b(n);\n\t\trep(i,n) b[a[i]-1]=i;\n\t\t\n\t\tSegTree st(n);\n\t\tll mx=0;\n\t\trep(i,n){\n\t\t\tst.Update(b[i],st.Query(0,b[i])+i+1);\n\t\t\tmx=max<ll>(mx,st.Query(0,b[i]+1));\n\t\t}\n\t\tcout<<n*(n+1)/2-mx<<endl;\n\t}\n\t\n\treturn 0;\n}"
  },
  {
    "language": "C++",
    "code": "////////////////////////////////////////\n///  tu3 pro-con template            ///\n////////////////////////////////////////\n#include <cassert>\n#include <cstdio>\n#include <cstring>\n#include <cmath>\n#include <iostream>\n#include <sstream>\n#include <algorithm>\n#include <numeric>\n#include <functional>\n#include <vector>\n#include <queue>\n#include <string>\n#include <complex>\n#include <stack>\n#include <set>\n#include <map>\n#include <list>\n#include <unordered_map>\n#include <unordered_set>\n#include <bitset>\n#include <regex>\nusing namespace std;\n\n//// MACRO ////\n#define countof(a) (sizeof(a)/sizeof(a[0]))\n\n#define REP(i,n) for (int i = 0; i < (n); i++)\n#define RREP(i,n) for (int i = (n)-1; i >= 0; i--)\n#define FOR(i,s,n) for (int i = (s); i < (n); i++)\n#define RFOR(i,s,n) for (int i = (n)-1; i >= (s); i--)\n#define pos(c,i) c.being() + (i)\n#define allof(c) c.begin(), c.end()\n#define aallof(a) a, countof(a)\n#define partof(c,i,n) c.begin() + (i), c.begin() + (i) + (n)\n#define apartof(a,i,n) a + (i), a + (i) + (n)\n#define long long long\n\n#define EPS 1e-9\n#define INF (1L << 30)\n#define LINF (1LL << 60)\n\n#define PREDICATE(t,a) [&](const t & a) -> bool\n#define COMPARISON_T(t) bool(*)(const t &, const t &)\n#define COMPARISON(t,a,b) [&](const t & a, const t & b) -> bool\n#define CONVERTER(TSrc,t,TDest) [&](const TSrc &t)->TDest\n\n//// i/o helper ////\nstruct _Reader { template <class T> _Reader operator ,(T &rhs) { cin >> rhs; return *this; } };\nstruct _Writer { bool f; _Writer() : f(false) { } template <class T> _Writer operator ,(const T &rhs) { cout << (f ? \" \" : \"\") << rhs; f = true; return *this; } };\n#define READ(t,...) t __VA_ARGS__; _Reader(), __VA_ARGS__\n#define WRITE(...) _Writer(), __VA_ARGS__; cout << endl\n\ntemplate <class T> struct vevector : public vector<vector<T>> { vevector(int n = 0, int m = 0, const T &initial = T()) : vector<vector<T>>(n, vector<T>(m, initial)) { } };\ntemplate <class T> struct vevevector : public vector<vevector<T>> { vevevector(int n = 0, int m = 0, int l = 0, const T &initial = T()) : vector<vevector<T>>(n, vevector<T>(m, l, initial)) { } };\ntemplate <class T> struct vevevevector : public vector<vevevector<T>> { vevevevector(int n = 0, int m = 0, int l = 0, int k = 0, const T &initial = T()) : vector<vevevector<T>>(n, vevevector<T>(m, l, k, initial)) { } };\ntemplate <class T> T read() { T t; cin >> t; return t; }\ntemplate <class T> vector<T> read(int n) { vector<T> v; REP(i, n) { v.push_back(read<T>()); } return v; }\ntemplate <class T> vevector<T> read(int n, int m) { vevector<T> v; REP(i, n) v.push_back(read<T>(m)); return v; }\ntemplate <class T> vevector<T> readjag() { return read<T>(read<int>()); }\ntemplate <class T> vevector<T> readjag(int n) { vevector<T> v; REP(i, n) v.push_back(readjag<T>()); return v; }\n\ntemplate <class T1, class T2> inline istream & operator >> (istream & in, pair<T1, T2> &p) { in >> p.first >> p.second; return in; }\ntemplate <class T1, class T2> inline ostream & operator << (ostream &out, pair<T1, T2> &p) { out << p.first << p.second; return out; }\ntemplate <class T> inline ostream & operator << (ostream &out, vector<T> &v)\n{\n\tostringstream ss;\n\tfor (auto x : v) ss << x << ' ';\n\tauto s = ss.str();\n\tout << s.substr(0, s.length() - 1) << endl;\n\treturn out;\n}\n\n//// start up ////\nvoid solve();\nint main()\n{\n\tsolve();\n\treturn 0;\n}\n\n//// data structure ////\n\n/// 2分セグメント木。RMQとかが解ける。\ntemplate<class T = int, class TParentFunc = const T& (*)(const T&, const T&)>\nstruct SegTree\n{\n\tunsigned msb(unsigned v) { v |= v >> 1; v |= v >> 2; v |= v >> 4; v |= v >> 8; v |= v >> 16; return (v >> 1) + 1; }\n\n\tint size;\n\tvector<T> tree;\n\tTParentFunc parent;\n\n\tSegTree(int count, TParentFunc parentBuilder = std::min, T initialFill = INF)\n\t\t: size(msb(count - 1) << 1)\n\t\t, tree(size * 2)\n\t\t, parent(parentBuilder)\n\t{\n\t\tfill(partof(tree, size, size), initialFill);\n\t\trebuild();\n\t}\n\n\t// []を使うと更新されないのでrebuildすること。数が少なければupdateの方がよい。\n\tT& operator[](int i) { return tree[i + size]; }\n\tvoid rebuild() { RREP(i, size) { tree[i] = parent(tree[i * 2], tree[i * 2 + 1]); } }\n\n\tvoid update(int index, T value)\n\t{\n\t\ttree[index + size] = value;\n\t\tfor (int i = (index + size) / 2; i > 0; i /= 2)\n\t\t\ttree[i] = parent(tree[i * 2], tree[i * 2 + 1]);\n\t}\n\n\tT query(int s, int e, int i, int l, int r, T value)\n\t{\n\t\tif (r <= s || e <= l) return value;\n\t\tif (s <= l && r <= e) return parent(value, tree[i]);\n\t\tvalue = query(s, e, i * 2, l, (l + r) / 2, value);\n\t\tvalue = query(s, e, i * 2 + 1, (l + r) / 2, r, value);\n\t\treturn value;\n\t}\n\n\tT query(int start, int count, T initialValue)\n\t{\n\t\treturn query(start, start + count, 1, 0, size, initialValue);\n\t}\n};\n\n\n////////////////////\n/// template end ///\n////////////////////\n\nvoid solve()\n{\n\tint testcases = 1;\n\tREP(testcase, testcases)\n\t{\n\t\tREAD(int, N);\n\t\tauto x = read<int>(N);\n\t\tSegTree<long> st(N, max, 0);\n\t\tREP(i, N) st.update(x[i] - 1, st.query(0, x[i] - 1, 0) + x[i]);\n\t\tWRITE(accumulate(allof(x), 0) - st.query(0, N, 0));\n\t}\n}"
  },
  {
    "language": "C++",
    "code": "#include <iostream>\n#include <sstream>\n#include <string>\n#include <algorithm>\n#include <vector>\n#include <stack>\n#include <queue>\n#include <set>\n#include <map>\n#include <cstdio>\n#include <cstdlib>\n#include <cstring>\n#include <cmath>\n#include <cassert>\n\nusing namespace std;\n\n#define FOR(i,k,n) for(int i=(k); i<(int)n; ++i)\n#define REP(i,n) FOR(i,0,n)\n#define FORIT(i,c) for(__typeof((c).begin())i=(c).begin();i!=(c).end();++i)\n\ntemplate<class T> void debug(T begin, T end){ for(T i = begin; i != end; ++i) cout<<*i<<\" \"; cout<<endl; }\n\ntypedef long long ll;\nconst int INF = 100000000;\nconst double EPS = 1e-8;\nconst int MOD = 1000000007;\nvector<int> v;\ntypedef pair<int, int> P;\nmap<P, int> memo;\nint rec(int idx, int m){\n  P state(idx, m);\n  if(memo.count(state)) return memo[state];\n  if(idx == v.size()) return memo[state] = 0;\n  if(v[idx] < m) return memo[state] = rec(idx + 1, m) + v[idx];\n  if(v[idx] == m) return memo[state] = rec(idx + 1, m + 1);\n  // rest\n  int cnt = 0;\n  //for(int i = m; i < v[idx]; i++) cnt += i;\n  int res = cnt + rec(idx + 1, v[idx] + 1);\n  //move\n  if(res > rec(idx + 1, m) + v[idx]){\n    res = rec(idx + 1, m) + v[idx];\n  }\n  return memo[state] = res;\n}\n\nint main(){\n  int N;\n  while(cin>>N){\n    memo.clear();\n    v = vector<int>(N);\n    REP(i, N) cin>>v[i];\n    cout<<rec(0, 1)<<endl;\n  }\n  return 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\nusing namespace std;\nusing ll = long long;\nusing P = pair<int, int>;\nconst ll MOD = 1000000007;\n\n// 0-origin BIT\ntemplate <typename T>\nclass BIT{\npublic:\n    vector<T> data;\n    int n;\n    BIT(){}\n    BIT(int n_){\n        n = n_;\n        data.assign(n, T(0));\n    }\n    // v[a] += w\n    void add(int a, T w){\n        for (int x = a; x < n; x |= x + 1) data[x] += w;\n    }\n    // sum of v[i] for i in [0, a)\n    T sum(int a){\n        T ret = 0;\n        for (int x = a - 1; x >= 0; x = (x & (x + 1)) - 1) {\n            ret += data[x];\n        }\n        return ret;\n    }\n};\n\nint main(){\n    int n;\n    cin >> n;\n\n    vector<P> x(n);\n    for(int i=0;i<n;i++){\n        cin >> x[i].first;\n        x[i].second = i;\n    }\n    sort(x.begin(), x.end());\n\n    BIT<int> bit(n);\n    int ans = 0;\n    for(P& p : x){\n        int i = p.second, v = p.first;\n        int rev = n - 1 - i;\n        int c = min(v, bit.sum(rev));\n        ans += c;\n        bit.add(rev, v - c);\n    }\n    cout << ans << endl;\n\n    return 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include <cstdlib>\n#include <iostream>\n#include <vector>\nusing namespace std;\n\ntemplate<class T> inline void chmax(T& a, const T& b) { if(b > a) a = b; }\n\ntypedef long long value; // 格納するデータの型\nconst value INIT = 0ll; // 初期値．目的に応じて，適切な値に変更すること．\n\nclass segment_tree {\nprivate:\n\tint n;\n\tvector<value> dat;\n\n\tvalue func(value a, value b) const { // ノードの値を決める為の関数\n\t\treturn max(a, b);\n\t}\n\n\tvalue query(int a, int b, int k, int l, int r) const {\n\t\tif(r <= a || b <= l) // 求める区間が，ノードの区間と重なっていない．\n\t\t\treturn INIT;\n\n\t\tif(a <= l && r <= b) { // 求める区間が，ノードの区間を完全に含む．\n\t\t\treturn dat[k];\n\t\t}\n\t\telse {\n\t\t\tconst int mid = (l + r) / 2;\n\t\t\tconst value vl = query(a, b, k * 2 + 1, l, mid);\n\t\t\tconst value vr = query(a, b, k * 2 + 2, mid, r);\n\t\t\treturn func(vl, vr);\n\t\t}\n\t}\n\npublic:\n\tsegment_tree(int n_) {\n\t\tn = 1;\n\t\twhile(n < n_)\n\t\t\tn *= 2;\n\n\t\tdat.assign(2 * n - 1, INIT);\n\t}\n\n\tvoid update(int k, value a) { // k番目の要素をaに更新する．\n\t\tk += n - 1;\n\t\tdat[k] = a;\n\t\twhile(k > 0) {\n\t\t\tk = (k - 1) / 2;\n\t\t\tdat[k] = func(dat[k * 2 + 1], dat[k * 2 + 2]);\n\t\t}\n\t}\n\n\tvalue query(int a, int b) { // [a, b)に対するクエリ\n\t\treturn query(a, b, 0, 0, n);\n\t}\n};\n\nint main() {\n\tcin.tie(0);\n\tios::sync_with_stdio(false);\n\n\tint m;\n\tcin >> m;\n\n\tsegment_tree segt(m);\n\n\tlong long mx = 0;\n\tfor(int i = 0; i < m; ++i) {\n\t\tint w;\n\t\tcin >> w;\n\n\t\tlong long tmp = segt.query(1, w) + w;\n\t\tsegt.update(w, tmp);\n\t\tchmax(mx, tmp);\n\t}\n\n\tcout << ((m + 1ll) * m / 2ll - mx) << endl;\n\treturn EXIT_SUCCESS;\n}"
  },
  {
    "language": "C++",
    "code": "#include<cstdio>\n#include<iostream>\n#include<string>\n#include<vector>\n#include<algorithm>\n\nusing namespace std;\n\n#define reps(i,f,n) for(int i=f;i<int(n);i++)\n#define rep(i,n) reps(i,0,n)\n\nconst int N = 100;\n\nclass BIT{\n\tstatic const int N = 100010;\n\tpublic:\n\tint t[N];\n\tvoid init(){rep(i,N)t[i]=0;}\n\tint calc(int a,int b){return max(a,b);}\n\t\n\tvoid setval(int pos, int val){\n\t\tpos++;\n\t\tfor(int i=0;;i++){\n\t\t\tif(pos>=N)break;\n\t\t\tif(pos&(1<<i)){\n\t\t\t\tt[pos] = calc(t[pos],val);\n\t\t\t\tpos += (1<<i);\n\t\t\t}\n\t\t}\n\t}\n\t\n\tint getval(int pos){\n\t\tpos++;\n\t\tint ret = 0;\n\t\tfor(int i=0;;i++){\n\t\t\tif(pos==0)break;\n\t\t\tif(pos&(1<<i)){\n\t\t\t\tret = calc(ret, t[pos]);\n\t\t\t\tpos -= (1<<i);\n\t\t\t}\n\t\t}\n\t\treturn ret;\n\t}\n\t\n\tvoid print(){\n\t\tprintf(\"t : \");\n\t\trep(i,10)printf(\"%d \",t[i]);puts(\"\");\n\t}\n};\n\nint main(){\n\tint n;\n\tcin>>n;\n\t\n\tint p[N];\n\tint sum = 0;\n\trep(i,n){\n\t\tcin>>p[i];\n\t\tsum += p[i];\n\t}\n\t\n\tBIT bit;\n\tbit.init();\n\t\n\trep(i,n){\n\t\tbit.setval( p[i], bit.getval(p[i])+p[i] );\n\t\t//bit.print();\n\t}\n\t\n\tprintf(\"%d\\n\",sum - bit.getval(n-1));\n}\n\n/*\n5\n1 5 3 2 4\n\n*/"
  },
  {
    "language": "C++",
    "code": "#include<iostream>\n#include<cstdio>\n#include<bits/stdc++.h>\n#include<iomanip>\n#include<queue>\n#include<string>\n#include<vector>\n#include<utility>\n#include<set>\n#include<map>\n#include<algorithm>\n#include<functional>\t//for \"greater<type>\"\n#include<cmath>\nusing namespace std;\n#define pb push_back\n#define fi first\n#define sc second\n#define mp make_pair\n#define is insert\t//?????????\n\n#define BIT_MAX_N 100000 \n\nint n;\nlong long bit[BIT_MAX_N+1];\n\nvoid update(int k,long long a){\n\twhile(k<=n){\n\t\tbit[k]=max(a,bit[k]);\n\t\tk=(k|(k-1))+1;\n\t}\n}\n\nlong long s(int k){\n\tlong long z=0;\n\twhile(k>0){\n\t\tz=max(z,bit[k]);\n\t\tk=k&(k-1);\n\t}\n\treturn z;\n}\n\nint main(){\n\tcin>>n;\n\tfill(bit,bit+n+1,0);\n\tfor(int i=0;i<n;++i){\n\t\tint x;\n\t\tcin>>x;\n\t\tupdate(x,s(x-1)+x);\n\t}\n\tcout<<((long long)n*(n+1))/2-s(n)<<endl;;\n}"
  },
  {
    "language": "C++",
    "code": "#include<iostream>\n#include<string>\n#include<cstdio>\n#include<vector>\n#include<cmath>\n#include<algorithm>\n#include<functional>\n#include<iomanip>\n#include<queue>\n#include<ciso646>\n#include<random>\n#include<map>\n#include<set>\n#include<complex>\n#include<bitset>\n#include<stack>\n#include<unordered_map>\nusing namespace std;\ntypedef long long ll;\ntypedef unsigned int ui;\nconst ll mod = 152076289;\nconst ll INF = (ll)1000000007 * 1000000007;\ntypedef pair<int, int> P;\n#define stop char nyaa;cin>>nyaa;\n#define rep(i,n) for(int i=0;i<n;i++)\n#define per(i,n) for(int i=n-1;i>=0;i--)\n#define Rep(i,sta,n) for(int i=sta;i<n;i++)\n#define rep1(i,n) for(int i=1;i<=n;i++)\n#define per1(i,n) for(int i=n;i>=1;i--)\n#define Rep1(i,sta,n) for(int i=sta;i<=n;i++)\ntypedef long double ld;\ntypedef complex<ld> Point;\nconst ld eps = 1e-8;\nconst ld pi = acos(-1.0);\ntypedef pair<ll, ll> LP;\ntypedef pair<ld, ld> LDP;//100000\nconst int MAX_N = (1 << 17);\nint nn;ll dat[2 * MAX_N - 1];\nvoid init(int n_) {\n\tnn = 1;\n\twhile (nn < n_)nn *= 2;\n}\nvoid update(int k, ll a) {\n\tk += nn - 1;\n\tdat[k] = a;\n\twhile (k > 0) {\n\t\tk = (k - 1) / 2;\n\t\tdat[k] = max(dat[k * 2 + 1], dat[k * 2 + 2]);\n\t}\n}\nll query(int a, int b, int k, int l, int r) {\n\tif (r <= a || b <= l)return 0;\n\tif (a <= l && r <= b)return dat[k];\n\telse {\n\t\tll vl = query(a, b, k * 2 + 1, l, (l + r) / 2);\n\t\tll vr = query(a, b, k * 2 + 2, (l + r) / 2, r);\n\t\treturn max(vl, vr);\n\t}\n}\nint main(){\n\tint n; cin >> n; init(n + 1);\n\tll sum = (ll)n*(n + 1) / 2;\n\tll ma = 0;\n\trep(i, n) {\n\t\tll a; cin >> a;\n\t\tll csum = query(1, a, 0, 0, nn) + a;\n\t\tma = max(ma, csum);\n\t\tupdate(a, csum);\n\t}\n\tcout << sum - ma << endl;\n\treturn 0;\n}\n"
  },
  {
    "language": "C++",
    "code": "#include <cassert>\n#include <cstdlib>\n#include <iostream>\n#include <vector>\nusing namespace std;\n\ntemplate<class T> inline void chmax(T& a, const T& b) { if(b > a) a = b; }\n\ntypedef long long value; // 格納するデータの型\nconst value INIT = 0ll; // 初期値．目的に応じて，適切な値に変更すること．\n\nclass segment_tree {\nprivate:\n\tint n;\n\tvector<value> dat;\n\n\tvalue func(value a, value b) const { // ノードの値を決める為の関数\n\t\treturn max(a, b);\n\t}\n\n\tvalue query(int a, int b, int k, int l, int r) const {\n\t\tif(r <= a || b <= l) // 求める区間が，ノードの区間と重なっていない．\n\t\t\treturn INIT;\n\n\t\tif(a <= l && r <= b) { // 求める区間が，ノードの区間を完全に含む．\n\t\t\treturn dat[k];\n\t\t}\n\t\telse {\n\t\t\tconst int mid = (l + r) / 2;\n\t\t\tconst value vl = query(a, b, k * 2 + 1, l, mid);\n\t\t\tconst value vr = query(a, b, k * 2 + 2, mid, r);\n\t\t\treturn func(vl, vr);\n\t\t}\n\t}\n\npublic:\n\tsegment_tree(int n_) {\n\t\tn = 1;\n\t\twhile(n < n_)\n\t\t\tn *= 2;\n\n\t\tdat.resize(2 * n, INIT);\n\t}\n\n\tvoid update(int k, value a) { // k番目の要素をaに更新する．\n\t\tk += n - 1;\n\t\tdat[k] = a;\n\t\twhile(k > 0) {\n\t\t\tk = (k - 1) / 2;\n\t\t\tdat[k] = func(dat[k * 2 + 1], dat[k * 2 + 2]);\n\t\t}\n\t}\n\n\tvalue query(int a, int b) { // [a, b)に対するクエリ\n\t\treturn query(a, b, 0, 0, n);\n\t}\n};\n\nint main() {\n\tcin.tie(0);\n\tios::sync_with_stdio(false);\n\n\tint m;\n\tcin >> m;\n\n\tsegment_tree segt(m);\n\n\tlong long mx = 0;\n\tfor(int i = 0; i < m; ++i) {\n\t\tint w;\n\t\tcin >> w;\n\n\t\tlong long tmp = segt.query(1, w) + w;\n\t\tsegt.update(w, tmp);\n\t\tchmax(mx, tmp);\n\t}\n\n\tcout << ((m + 1ll) * m / 2ll - mx) << endl;\n\treturn EXIT_SUCCESS;\n}"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\nusing namespace std;\nusing ll = long long;\n\nint n;\nll b[100001];\n\nll find(int s) {\n\tll res = 0;\n\tfor (int i = s; i > 0; i = i & (i - 1))\n\t\tres = max(res, b[i]);\n\treturn res;\n}\n\nvoid update(int s, ll val) {\n\tfor (int i = s; i <= n; i += (i & -i))\n\t\tb[i] = max(b[i], val);\n}\n\nint main()\n{\n\tscanf(\"%d\", &n);\n\tll sum = 0;\n\tfor (int i = 0, x; i < n; i++) {\n\t\tscanf(\"%d\", &x);\n\t\tsum += x;\n\t\tupdate(x, find(x - 1) + x);\n\t}\n\tprintf(\"%lld\\n\", sum - find(n));\n\treturn 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include<bits/stdc++.h>\nusing namespace std;\ntypedef long long ll;\ntypedef pair<double,int> P;\ntypedef pair<P,ll> T;\ntypedef vector<int> vi;\ntypedef vector<ll> vll;\n#define pb push_back\n#define mp make_pair\n#define eps 1e-15\n#define INF 2000000000\n#define sz(x) ((int)(x).size())\n#define fi first\n#define sec second\n#define all(x) (x).begin(),(x).end()\n#define rep(i,n) for(int (i)=0;(i)<(int)(n);(i)++)\n#define repn(i,a,n) for(int (i)=(a);(i)<(int)(n);(i)++)\n#define EQ(a,b) (abs((a)-(b))<eps)\ntemplate<class T> void chmin(T& a,const T& b){if(a>b)a=b;}\ntemplate<class T> void chmax(T& a,const T& b){if(a<b)a=b;}\nconst int SIZE = 1<<18;\nstruct segtree{\n\tll seg[SIZE*2];\n\tvoid update(int k,ll x){\n\t\tk+=SIZE-1;\n\t\tseg[k]=x;\n\t\twhile(k){\n\t\t\tk = (k-1)/2;\n\t\t\tseg[k]=max(seg[k*2+1],seg[k*2+2]);\n\t\t}\n\t}\n\tll query(int a,int b,int k=0,int l=0,int r=SIZE){\n\t\tif(r<=a||b<=l)return 0;\n\t\telse if(a<=l&&r<=b)return seg[k];\n\t\telse{\n\t\t\tll lch = query(a,b,k*2+1,l,(l+r)/2);\n\t\t\tll rch = query(a,b,k*2+2,(l+r)/2,r);\n\t\t\treturn max(lch,rch);\n\t\t}\n\t}\n}seg;\nll n;\nvector<int> x;\nint main(){\n\tscanf(\"%lld\",&n);\n\tx.resize((int)n);\n\tfor(int i=0;i<n;i++)scanf(\"%d\",&x[i]);\n\tfor(int i=0;i<n;i++){\n\t\tseg.update(x[i],(ll)x[i]+seg.query(0,x[i]));\n\t}\n\tcout << n*(n+1)/2ll-seg.query(0,SIZE) << endl;\n\treturn 0;\n}"
  },
  {
    "language": "C++",
    "code": "// AOJ 2431\n#include<cstdio>\n#include<algorithm>\n#define rep(i,a) for( int i = 0; i != (a); ++i )\n\ntypedef long long ll;\n\nint n;\nll bit[100001];\n\nvoid add( int k, ll x )\n{\n\tfor( int i = k+1; i <= n; i += i&-i )\n\t\tbit[i] = std::max( bit[i], x );\n\n\treturn;\n}\n\nll sum( int k )\n{\n\tll ret = 0;\n\n\tfor( int i = k; i > 0; i -= i&-i )\n\t\tret = std::max( ret, bit[i] );\n\n\treturn ret;\n}\n\nint main()\n{\n\tscanf( \"%d\", &n );\n\trep( i, n )\n\t{\n\t\tint x;\n\t\tscanf( \"%d\", &x );\n\t\tadd( x-1, sum( x-1 )+x );\n\t}\n\n\tprintf( \"%lld\\n\", ll(n*(n+1)>>1)-sum(n) );\n\n\treturn 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include  <bits/stdc++.h>\n#define rep(i,n) for(int (i)=0;(i)<(n);(i)++)\nusing namespace std;\ntypedef long long int ll;\n\ntemplate <typename T> class SegmentTree{\n\tpublic :\n\t\tint n;\n\t\tSegmentTree(int size,T o): out_of_range(o){\n\t\t\tfor(n=1;n<size;n<<=1);\n\t\t\tdata=vector<T>(2*n,out_of_range);\n\t\t\tlazy=vector<bool>(2*n,false);\n\t\t}\n\n\t\tvoid update(int a,int b,T x,int k,int l,int r){\n\t\t\tif(r<=a||b<=l) return;\n\t\t\tif(a<=l&&r<=b){data[k]=x,lazy[k]=true;return;}\n\t\t\tif(lazy[k]) lazy_evaluate(k);\n\t\t\tupdate(a,b,x,k*2+1,l,(l+r)/2);\n\t\t\tupdate(a,b,x,k*2+2,(l+r)/2,r);\n\t\t\tdata[k]=max(data[k*2+1],data[k*2+2]);\n\t\t}\n\n\t\tT query(int a,int b,int k,int l,int r){\n\t\t\tif(r<=a||b<=l) return out_of_range;\n\t\t\tif(lazy[k]) return data[k];\n\t\t\tif(a<=l&&r<=b) return data[k];\n\t\t\tT vl = query(a,b,k*2+1,l,(l+r)/2);\n\t\t\tT vr = query(a,b,k*2+2,(l+r)/2,r);\n\t\t\treturn max(vl,vr);\n\t\t}\n\n\t\tvoid show(){\n\t\t\trep(i,n) cerr << \"i=\" << i << \"  data: \" << data[i] << \" lazy: \" << lazy[i] << endl;\n\t\t}\n\n\n\tprivate:\n\t\tvector<T> data;\n\t\tvector<bool> lazy;\n\t\tconst T out_of_range;\n\n\t\tinline void lazy_evaluate(int k){\n\t\t\tdata[k*2+1]=data[k];lazy[k*2+1]=true;\n\t\t\tdata[k*2+2]=data[k];lazy[k*2+2]=true;\n\t\t\tlazy[k]=false;\n\t\t}\n};\n\nconst int nmax=100010;\nll n;\nint a[nmax];\nint pos[nmax];\nSegmentTree<ll> dp(nmax,0LL);\n\n\nint main(void){\n\tcin >> n;\n\trep(i,n) cin >> a[i];\n\trep(i,n) pos[a[i]]=i;\n\n\tll all=n*(n+1)/2;\n\tfor(int i=n;i>=1;--i){\n\t\tll cur=dp.query(pos[i]+1,n,0,0,dp.n);\n\t\tcur+=i;\n\t\tdp.update(pos[i],pos[i]+1,cur,0,0,dp.n);\n\t\t//dp.show();\n\t}\n\tcout << all-dp.query(0,n,0,0,dp.n) << endl;\n\treturn 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include <iostream>\n#include <algorithm>\n#include <set>\nusing namespace std;\n\ntypedef long long ll;\ntypedef pair<ll,ll> P;\n\nconst ll MAX = 100000;\n\nint main(){\n   int n;\n   while(cin >> n){\n      ll a[MAX],ans=0;\n      set<P> s;\n      for(int i=0;i<n;i++) cin >> a[i];\n      for(int i=0;i<n;i++){\n\tll cnt = 0;\n\tif(!s.empty()){\n\t  set<P>::iterator it = s.end();\n\t  it--;\n\t  for(;;it--){\n\t    if(it->second < a[i]){\n\t      cnt = it->first;\n\t      break;\n\t    }\n\t    if(it == s.begin()) break;\n\t  }\n\t}\n\t ans = max(ans,cnt+a[i]);\n\t s.insert(P(cnt+a[i],a[i]));\n      }\n      cout << (ll)(n * (n+1) / 2) - ans << endl;\n   }\n}"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\nusing namespace std;\n\ntypedef long long ll;\n#define rep(i,n) for(int (i)=0;(i)<(int)(n);++(i))\n#define each(itr,c) for(__typeof(c.begin()) itr=c.begin(); itr!=c.end(); ++itr)\n#define all(x) (x).begin(),(x).end()\n#define pb push_back\n#define fi first\n#define se second\n\nstruct MaxSegTree{\n    long n; vector<ll> dat;\n    //?????????\n    MaxSegTree(long _n){\n        n=1;\n        while(n<_n) n*=2;\n        dat=vector<ll>(2*n-1,0);\n    }\n    //k??????(0-indexed)?????????a????????´\n    void update(long k, ll a){\n        k+=n-1;\n        dat[k]=a;\n        //??´??°\n        while(k>0){\n            k=(k-1)/2;\n            dat[k]=max(dat[2*k+1],dat[2*k+2]);\n        }\n    }\n    //?????¨??????????????????????????¨???\n    ll _query(long a, long b, long k, long l, long r){\n        if(r<=a || b<=l) return 0;\n\n        if(a<=l && r<=b) return dat[k];\n        else{\n            ll vl=_query(a,b,2*k+1,l,(l+r)/2);\n            ll vr=_query(a,b,2*k+2,(l+r)/2,r);\n            return max(vl,vr);\n        }\n    }\n    //[a,b)????????§???????±???????\n    ll query(long a, long b){\n        return _query(a,b,0,0,n);\n    }\n};\n\ntypedef pair<int,int> pi;\n\nint main()\n{\n    int n;\n    scanf(\" %d\", &n);\n\n    ll sum=0;\n    vector<pi> v(n);\n    rep(i,n)\n    {\n        int x;\n        scanf(\" %d\", &x);\n\n        v[i] = pi(x,i);\n        sum+=x;\n    }\n\n    sort(all(v));\n\n    MaxSegTree st(n);\n\n    rep(i,n)\n    {\n        int idx = v[i].se;\n        st.update(idx, st.query(0,idx)+v[i].fi);\n    }\n\n    printf(\"%lld\\n\", sum - st.query(0,n));\n    return 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include<bits/stdc++.h>\n#define MAX 100001\nusing namespace std;\nint n,p,A[MAX*2],N;\nvoid Segtree(int n_){\n  n=1;\n  while(n<n_)n*=2;\n}\nvoid update(int k,int x){\n  k+=n-1;\n  A[k]=x;\n  while(k>0){\n    k=(k-1)/2;\n    A[k]=max(A[k*2+1],A[k*2+2]);\n  }\n}\nint find(int a,int b,int k,int l,int r){\n  if(r<=a||b<=l)return 0;\n  if(a<=l&&r<=b)return A[k];\n  int v1=find(a,b,k*2+1,l,(l+r)/2);\n  int v2=find(a,b,k*2+2,(l+r)/2,r);\n  return max(v1,v2);\n}\nint main(){\n  cin>>n;\n  N=n;\n  Segtree(n+1);\n  for(int i=0;i<N;i++){\n    scanf(\"%d\",&p);\n    int v=find(0,p,0,0,n);\n    update(p,v+p);\n  }\n  cout<<N*(N+1)/2-find(0,N+1,0,0,n)<<endl;\n}"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\n\nusing namespace std;\n\ntypedef long long ll;\ntypedef unsigned long long ull;\ntypedef long double ld;\ntypedef pair<ll, ll> P;\n\n#define EACH(i,a) for (auto& i : a)\n#define FOR(i,a,b) for (ll i=(a);i<(b);i++)\n#define RFOR(i,a,b) for (ll i=(b)-1;i>=(a);i--)\n#define REP(i,n) for (ll i=0;i<(n);i++)\n#define RREP(i,n) for (ll i=(n)-1;i>=0;i--)\n#define debug(x) cout<<#x<<\": \"<<x<<endl\n#define pb push_back\n#define ALL(a) (a).begin(),(a).end()\n\nconst ll linf = 1e18;\nconst ll inf = 1e9;\nconst double eps = 1e-12;\nconst double pi = acos(-1);\n\ntemplate<typename T>\nistream& operator>>(istream& is, vector<T>& vec) {\n\tEACH(x,vec) is >> x;\n\treturn is;\n}\n/*\ntemplate<class... T>\nostream& operator<<(ostream& os, tuple<T...>& t) {\n\tfor (size_t i = 0; i < tuple_size< tuple<T...> >::value; ++i) {\n\t\tif (i) os << \" \";\n\t\tos << get<0>(t);\n\t}\n\treturn os;\n}\n*/\ntemplate<typename T>\nostream& operator<<(ostream& os, vector<T>& vec) {\n\tREP(i,vec.size()) {\n\t\tif (i) os << \" \";\n\t\tos << vec[i];\n\t}\n\treturn os;\n}\ntemplate<typename T>\nostream& operator<<(ostream& os, vector< vector<T> >& vec) {\n\tREP(i,vec.size()) {\n\t\tif (i) os << endl;\n\t\tos << vec[i];\n\t}\n\treturn os;\n}\n\nclass Seg {\nprivate:\n    ll size;\n    vector<ll> data;\npublic:\n    ll get(ll l, ll r, ll n, ll L, ll R) {\n        if (r <= L || R <= l) return 0;\n        if (L <= l && r <= R) return data[n];\n        ll m = (l + r) / 2;\n        return max(get(l, m, n*2+1, L, R), get(m, r, n*2+2, L, R));\n    }\n    ll get(ll l, ll r) {\n        return get(0, size, 0, l, r);\n    }\n    void update(ll pos, ll val) {\n        pos += size-1;\n        data[pos] = val;\n        while (1) {\n            if (pos == 0) break;\n            pos = (pos-1)/2;\n            data[pos] = max(data[pos*2+1], data[pos*2+2]);\n        }\n    }\n    Seg(ll n) {\n        for (size = 1; size < n; size <<= 1);\n        data = vector<ll>(size*2-1, 0);\n    }\n};\n\nint main() {\n    std::ios::sync_with_stdio(false);\n    std::cin.tie(0);\n    ll n; cin >> n;\n    vector<ll> v(n); cin >> v;\n    Seg seg(n);\n    vector<ll> rv(n);\n    REP(i, n) {\n        --v[i];\n        rv[v[i]] = i;\n    }\n    REP(i, n) {\n        ll val = seg.get(0, rv[i])+(i+1);\n        // cout << seg.get(0, rv[i]) << \" \" << val << endl;\n        seg.update(rv[i], val);\n    }\n    ll ans = (ll)n * (n+1) / 2;\n    ans -= seg.get(0, n);\n    cout << ans << endl;\n}"
  },
  {
    "language": "C++",
    "code": "// g++ -std=c++11 a.cpp\n#include<iostream>\n#include<vector>\n#include<string>\n#include<algorithm>\t\n#include<map>\n#include<set>\n#include<unordered_map>\n#include<utility>\n#include<cmath>\n#include<random>\n#include<cstring>\n#include<queue>\n#include<stack>\n#include<bitset>\n#include<cstdio>\n#include<sstream>\n#include<iomanip>\n#include<assert.h>\n#include<typeinfo>\n#define loop(i,a,b) for(int i=a;i<b;i++) \n#define rep(i,a) loop(i,0,a)\n#define FOR(i,a) for(auto i:a)\n#define pb push_back\n#define all(in) in.begin(),in.end()\n#define shosu(x) fixed<<setprecision(x)\n#define show1d(v) rep(i,v.size())cout<<\" \"<<v[i];cout<<endl;\n#define show2d(v) rep(i,v.size()){rep(j,v[i].size())cout<<\" \"<<v[i][j];cout<<endl;}cout<<endl;\nusing namespace std;\n//kaewasuretyuui\ntypedef long long ll;\n//#define int ll\ntypedef ll Def;\ntypedef pair<Def,Def> pii;\ntypedef vector<Def> vi;\ntypedef vector<vi> vvi;\ntypedef vector<pii> vp;\ntypedef vector<vp> vvp;\ntypedef vector<string> vs;\ntypedef vector<double> vd;\ntypedef vector<vd> vvd;\ntypedef pair<Def,pii> pip;\ntypedef vector<pip>vip;\n//#define mt make_tuple\n//typedef tuple<int,int,int> tp;\n//typedef vector<tp> vt;\ntemplate<typename A,typename B>bool cmin(A &a,const B &b){return a>b?(a=b,true):false;}\ntemplate<typename A,typename B>bool cmax(A &a,const B &b){return a<b?(a=b,true):false;}\n//template<class C>constexpr int size(const C &c){return (int)c.size();}\n//template<class T,size_t N> constexpr int size(const T (&xs)[N])noexcept{return (int)N;}\nconst double PI=acos(-1);\nconst double EPS=1e-9;\nDef inf = sizeof(Def) == sizeof(long long) ? 2e18 : 1e9+10;\nint dx[]={0,1,0,-1};\nint dy[]={1,0,-1,0};\nclass BIT{\n\tpublic:\n\t//[1,i]\n\tint n;\n\tvi bit;\n//\tint bit[MAZ_N+1];\n\tBIT(int size){\n\t\tn=size;\n\t\tbit=vi(n+1);\n\t}\n\tDef query(int i){//sum\n\t\tDef s=0;\n\t\twhile(i>0){\n\t\t\ts=max(s,bit[i]);\n\t\t\ti-=i&-i;\n\t\t}\n\t\treturn s;\n\t}\n\tvoid add(int i,Def x){\n\t\twhile(i<=n){\n\t\t\tbit[i]=max(bit[i],x);\n\t\t\ti+=i&-i;\n\t\t}\n\t}\n};\nint main(){\n\tll n;\n\tcin>>n;\n\tBIT bit(n);\n\trep(i,n){\n\t\tint a;cin>>a;\n\t\tbit.add(a,bit.query(a)+a);\n\t}\n\tcout<<n*(n+1)/2-bit.query(n)<<endl;\n}\n\n\n\n\n\n"
  },
  {
    "language": "C++",
    "code": "#include <iostream>\nusing namespace std;\n\nlong long BIT[100010], bit_size;\n\nvoid bit_init( int n ) {\n\n\tfill( BIT, BIT+n, 0);\n\tbit_size = n;\n\n}\n\nlong long bit_max( int n ) {\n\n\tlong long ans = 0;\n\t\n\twhile ( n > 0 ) {\n\t\n\t\tans = max( ans, BIT[n] );\n\t\tn &= n - 1;\n\t\t\n\t}\n\t\n\treturn ans;\n\t\n}\n\nvoid bit_setmax( int n, long long v ) {\n\n\twhile ( n < bit_size ) {\n\t\n\t\tBIT[n] = max( BIT[n], v );\n\t\tn += n & (-n);\n\t\t\n\t}\n\t\n}\n\nlong long N, x;\n\nint main() {\n\n\tcin >> N;\n\t\n\tbit_init( N+1 );\n\t\n\tfor ( int i = 0; i < N; ++i ) {\n\t\n\t\tcin >> x;\n\t\tlong long cost = bit_max( x );\n\t\tbit_setmax( x, cost + x );\n\t\t\n\t}\n\t\n\tcout << ( 1 + N ) * N / 2 - bit_max( N ) << endl;\n\n}"
  },
  {
    "language": "C++",
    "code": "#include<bits/stdc++.h>\nusing namespace std;\ntypedef long long ll;\n\nll d[(1<<18)];\nll n;\n\nvoid init(ll _n){\n  n = 1;\n  while( n < _n ) n*=2;\n  memset(d,0,sizeof(d));\n}\n\nll query(ll a,ll b,ll k,ll l,ll r){\n  if( r <= a || b <= l ) return 0;\n  else if( a <= l && r <= b ) return d[k];\n  return max( query( a, b, 2*k+1, l, (l+r)/2 ),  query( a, b, 2*k+2, (l+r)/2, r ) );\n}\n\nll query(ll a,ll b){\n  return query( a, b, 0, 0, n );\n}\n\nvoid sets(ll k,ll x) {\n  k += n-1;\n  d[k] = x;\n  while( k > 0 ){\n    k = (k-1)/2;\n    d[k] = max( d[2*k+1], d[2*k+2] );\n  }\n}\n\ntypedef pair<ll,ll> P;\n\nll N;\nvector<P> p;\nint main(){\n  cin >> N;\n  init( N );\n  for(ll i=0;i<N;i++){\n    ll x; cin >> x;\n    p.push_back( P(x,i) );\n  }\n\n  sort( p.begin(), p.end() );\n  \n  ll res = 0;\n  for(ll i=N-1;i>-1;i--){    \n    ll k = p[i].second;\n    ll num = query( k, N );\n    res = max( res, num + p[i].first );\n    sets( k, num+p[i].first );\n  }\n  cout << N*(N+1)/2 - res << endl;\n  \n}"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\nusing namespace std;\n\n#define for_(i,a,b) for(int i=(a);i<(b);++i)\n#define for_rev(i,a,b) for(int i=(a);i>=(b);--i)\n\nint n, x[100010];\nint dp[100010], sum[100010];\n\nint main() {\n\tcin >> n;\n\tfor_(i,0,n) cin >> x[i];\n\t\n\tmemset(dp, 0, sizeof(dp));\n\tmemset(sum, 0, sizeof(sum));\n\t\n\tdp[n] = 10001;\n\t\n\tfor_rev(i,n-1,0) {\n\t\tint ind = lower_bound(dp, dp + n + 1, x[i]) - dp - 1;\n\t\t\n\t\tif (sum[ind] <= sum[ind + 1] + x[i]) {\n\t\t\tdp[ind] = x[i];\n\t\t\tsum[ind] = sum[ind + 1] + x[i];\n\t\t}\n\t}\n\t\n\tcout << (n * (n + 1) / 2 - *max_element(sum, sum + n)) << endl;\n}"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\n\ntypedef long long ll;\n#define int ll\n\n#define range(i, a, n) for(int (i) = (a); (i) < (n); (i)++)\n#define rep(i, n) for(int (i) = 0; (i) < (n); (i)++)\nusing namespace std;\n\n// -----------------------\nnamespace SegmentTrees{\n    template<typename T>\n    class RMQ{\n    private:\n        int Pow2Fit(int _n){\n            int d = 1;\n            while((d << 1) <= _n) d <<= 1;\n            return d;\n        }\n\n    public:\n        vector<T> dat;\n        int n, size;\n\n        RMQ(int _n){\n            n = Pow2Fit(_n) << 1;\n            size = 2 * n - 1;\n            dat = vector<T>(size, 0);\n        }\n\n        // node v := a (0-indexed)\n        void set(int v, T a){\n\n            // leaf\n            v += n - 1;\n            dat[v]=a;\n\n            // update toward root\n            while(v > 0){\n                int parent = v = (v - 1) / 2;\n                int chl = parent * 2 + 1, chr = parent * 2 + 2;\n                dat[parent] = max(dat[chl], dat[chr]);\n            }\n        }\n\n        T get(int v){ // v (0-indexed)\n            return dat[v + n - 1];\n        }\n\n        T query(int a, int b){ // [a,b)\n            return query(0, a, b, 0, n);\n        }\n\n    private:\n        T query(int v, int a, int b, int l, int r){ // [a,b)\n            if(r <= a || b <= l) return 0; // out range\n            if(a <= l && r <= b) return dat[v]; // covered\n \n            T vl = query(v * 2 + 1, a, b, l, (l + r) / 2),\n              vr = query(v * 2 + 2, a, b, (l + r) / 2, r);\n\n            return max(vl, vr);\n        }\n    };\n}\n\nusing namespace SegmentTrees;\n// -----------------------\n\nsigned main(){\n    int n; cin >> n;\n    RMQ<int> rmq(n);\n\n    rep(i, n){\n        int x; cin >> x;\n        rmq.set(x - 1, rmq.query(0, x) + x);\n    }\n\n    cout << n * (n + 1) / 2 - rmq.query(0, n) << endl;\n}"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\n\n#define REP(i,n) for(int i=0;i<(int)(n);i++)\n\nusing namespace std;\n\nconst int64_t INF = INT64_C(1000000000000);\n\nstruct Data {\n  int64_t num;\n  Data() : num(-INF) {;}\n  Data(int64_t n) : num(n) {;}\n};\n\ninline Data Merge(Data left, Data right) {\n  return Data(left.num > right.num ? left.num : right.num);\n}\n\nstruct SegmentTree {\n  static const int STsize = 1 << 18;\n  Data data[STsize]; int n;\n  SegmentTree(void) : n(STsize / 2) {}\n  void update (int pos, Data value) {\n    if (data[pos].num >= value.num) return;\n    data[pos] = value;\n    while (pos < 2*n-1) {\n      int l = pos, r = pos^1;\n      pos = pos / 2 + n;\n      data[pos] = Merge(data[l], data[r]);\n    }\n  }\n  Data sub(int fr, int to, int node, int la, int ra) {\n    if (ra<=fr || to<=la) return Data();\n    if (fr<=la && ra<=to) return data[node];\n    Data vl = sub(fr, to, (node-n)*2+0, la, (la+ra)/2);\n    Data vr = sub(fr, to, (node-n)*2+1, (la+ra)/2, ra);\n    return Merge(vl, vr);\n  }\n  Data query(int fr, int to) { return sub(fr, to, 2*n-2, 0, n); }\n};\n\nint main() {\n  int n;\n  cin>>n;\n  SegmentTree st;\n  int64_t sum = 0;\n  st.update(0, 0);\n  REP(i,n){\n    int x;\n    cin>>x;\n    sum += x;\n    int64_t v = st.query(0, x).num;\n    st.update(x, v+x);\n  }\n  cout << (sum - st.query(0, n+1).num) << endl;\n  return 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include <iostream>\n#include <string>\n#include <vector>\n#include <algorithm>\n#include <queue>\n#include <set>\n#include <map>\n#include <cmath>\nusing namespace std;\ntypedef long long i64;\ntypedef long double ld;\ntypedef pair<i64,i64> P;\n#define rep(i,s,e) for(int i = (s);i <= (e);i++)\n\n/* include file*/\n#include <functional>\n#include <vector>\nusing namespace std;\n\ntemplate <class Monoid>\nstruct Segment\n{\n    using Func = function<Monoid(Monoid,Monoid )>;\n\n    vector<Monoid> node;\n    Monoid ide;\n    int n = 1;\n\n    Func bin_f;\n    Func update_f;\n\n    Segment(const vector<Monoid> &init, Monoid ide_, Func f_,Func u_f) : bin_f(f_),ide(ide_),update_f(u_f)\n    {\n        int sz = init.size();\n        while (n < sz)\n            n *= 2;\n        node.assign(n * 2 - 1, ide);\n        for (int i = 0; i < sz; i++)\n            node[i + n - 1] = init[i];\n        for (int i = n - 2; i >= 0; i--)\n            node[i] = bin_f(node[i * 2 + 1], node[i * 2 + 2]);\n    }\n\n    void update(int i, Monoid x)\n    {\n        i += n - 1;\n        node[i] = update_f(node[i],x);\n        while (i)\n        {\n            i = (i - 1) / 2;\n            node[i] = bin_f(node[i * 2 + 1], node[i * 2 + 2]);\n        }\n    }\n\n    Monoid get_inter(int a, int b, int k = 0, int l = 0, int r = -1)\n    {\n        if (r < 0)\n            r = n;\n        if (a <= l && r <= b)\n            return node[k];\n        if (r <= a || b <= l)\n            return ide;\n\n        Monoid lm = get_inter(a, b, k * 2 + 1, l, (l + r) / 2);\n        Monoid rm = get_inter(a, b, k * 2 + 2, (l + r) / 2, r);\n        return bin_f(lm, rm);\n    }\n};\n\n// http://judge.u-aizu.ac.jp/onlinejudge/review.jsp?rid=2730414#1\n// http://judge.u-aizu.ac.jp/onlinejudge/review.jsp?rid=2730425#1\n\nint n;\nvector<i64> x;\n\nint main(){\n    cin >> n;\n    x.assign(n + 1,0);\n    for(int i = 1;i <= n;i++) cin >> x[i];\n\n    Segment<i64> seg(vector<i64>(n + 1,0),0,[](i64 a , i64 b){\n        return max(a,b);\n    },[](i64 node,i64 a){\n        return a;\n    });\n\n    for(int i = 1;i <= n;i++){\n        seg.update(x[i],x[i] + seg.get_inter(1,x[i]));\n    }\n\n    cout << (n + 1) * n / 2 - seg.get_inter(0,n + 1) << endl;;\n\n}\n"
  },
  {
    "language": "C++",
    "code": "#include <iostream>\n#include <algorithm>\n#include <set>\nusing namespace std;\n\ntypedef long long ll;\ntypedef pair<ll,ll> P;\n\nconst ll MAX = 100000;\n\nint main(){\n   int n;\n   while(cin >> n){\n      ll a[MAX],ans=0;\n      set<P> s;\n      for(int i=0;i<n;i++) cin >> a[i];\n      for(int i=0;i<n;i++){\n\tll cnt = 0;\n\tif(i > 0){\n\t  set<P>::iterator it = s.end();\n\t  it--;\n\t  while(1){\n\t    it = s.lower_bound(P(it->first,0));\n\t    if(it->second < a[i]){\n\t      cnt = it->first;\n\t      break;\n\t    } else if(it == s.begin()) break;\n\t    else it--;\n\t  }\n\t}\n\tans = max(ans,cnt+a[i]);\n\ts.insert(P(cnt+a[i],a[i]));\n      }\n      cout << (ll)(n * (n+1) / 2) - ans << endl;\n   }\n}"
  },
  {
    "language": "C++",
    "code": "#include <iostream>\n#include <sstream>\n#include <string>\n#include <algorithm>\n#include <vector>\n#include <stack>\n#include <queue>\n#include <set>\n#include <map>\n#include <cstdio>\n#include <cstdlib>\n#include <cstring>\n#include <cmath>\n#include <cassert>\n\nusing namespace std;\n\n#define FOR(i,k,n) for(int i=(k); i<(int)(n); ++i)\n#define REP(i,n) FOR(i,0,n)\n#define FORIT(i,c) for(__typeof((c).begin())i=(c).begin();i!=(c).end();++i)\n\ntemplate<class T> void debug(T begin, T end){ for(T i = begin; i != end; ++i) cerr<<*i<<\" \"; cerr<<endl; }\ninline bool valid(int x, int y, int W, int H){ return (x >= 0 && y >= 0 && x < W && y < H); }\n\ntypedef long long ll;\nconst int INF = 100000000;\nconst double EPS = 1e-8;\nconst int MOD = 1000000007;\nint dx[8] = {1, 0, -1, 0, 1, -1, -1, 1};\nint dy[8] = {0, 1, 0, -1, 1, 1, -1, -1};\n\n// Range Minimum Query\n// class RMQは次の2つの処理をO(logn)で行う。\n// 1. s, tが与えられた時、a[s], a[s + 1], ..., a[t - 1]の最小値を求める\n// 2. i, xが与えられた時, a[i]の値をxに変更する。\n// usage:\n// int v = {5, 1, 3, 2, 6};\n// vector<int> vv(v, v + 5);\n// RMQ<int> rmq(vv);\n// rmq.query_value(0, 5); -> 1 (半開区間で指定することに注意)\n// rmq.update(1, 3); ({5, 1, 3, 2, 6} -> {5, 3, 3, 2, 6})\n// rmq.query_value(0, 5); -> 2\n// rmq.query_index(0, 5); -> 3 (a[3]が最小)\ntemplate <class T>\nclass RMQ{\n  int N;\n  vector<T> data;\n  vector<int> segtree;\n  bool compare(const T& a, const T& b){\n    return a > b;\n    // return a > b; // greater\n    // return a.second <= b.second; // pair\n    // return a.size() <= b.size() // string, array, ...\n    // return abs(a) <= abs(b) // complex\n  }\n  int build(int idx, int left, int right){\n    if(left + 1 == right){\n      segtree[idx] = left;\n    }else{\n      const int mid = (left + right) / 2;\n      int left_idx = build(idx * 2 + 1, left, mid);\n      int right_idx = build(idx * 2 + 2, mid, right);\n      if(compare(data[left_idx], data[right_idx])){\n        segtree[idx] = left_idx;\n      }else{\n        segtree[idx] = right_idx;\n      }\n    }\n    return segtree[idx];\n  }\n  int update_build(int k, int idx, int left, int right){\n    if(!(left <= k && k < right)){\n      //do nothing!\n    } else if(left + 1 == right){\n      segtree[idx] = left;\n    }else{\n      const int mid = (left + right) / 2;\n      int left_idx = update_build(k, idx * 2 + 1, left, mid);\n      int right_idx = update_build(k, idx * 2 + 2, mid, right);\n      if(compare(data[left_idx], data[right_idx])){\n        segtree[idx] = left_idx;\n      }else{\n        segtree[idx] = right_idx;\n      }\n    }\n    return segtree[idx];\n  }\npublic:\n  RMQ(int N){\n    data = vector<T>(N);\n    this->N = data.size();\n    segtree = vector<int>(4 * N, -1);\n    build(0, 0, N);\n  }\n  RMQ(const vector<T>& v){\n    data = vector<T>(v.begin(), v.end());\n    N = data.size();\n    segtree = vector<int>(4 * N, -1);\n    build(0, 0, N);\n  }\n\n  T operator[](const int idx) const {\n    return data[idx];\n  }\n\n  void update(int k, T a){\n    data[k] = a;\n    update_build(k, 0, 0, N);\n  }\n\n  inline int query_index(int left, int right) { return query_index(left, right, 0, 0, N); }\n  int query_index(int left, int right, int i, int a, int b) {\n    // [a, b) is the range of indexes[i]\n    if (b <= left || right <= a) {\n      // does not intersect\n      return -1;\n    } else if (left <= a && b <= right) {\n      // contains\n      return segtree[i];\n    } else {\n      const int m = (a+b)/2;\n      const int l = query_index(left, right, 2*i+1, a, m);\n      const int r = query_index(left, right, 2*i+2, m, b);\n      if (l == -1) {\n        return r;\n      } else if (r == -1) {\n        return l;\n      } else {\n        if(compare(data[l], data[r])){\n          return l;\n        } else {\n          return r;\n        }\n      }\n    }\n  }\n  inline T query_value(int left, int right) { return data[query_index(left, right)]; }\n\n};\nint main(){\n  int N;\n  cin>>N;\n  vector<int> x(N);\n  REP(i, N) cin >> x[i];\n  int cur = 1;\n  ll ans = (ll)N * (N + 1) / 2;\n  RMQ<ll> rmq(N + 1);\n  REP(i, N){\n    rmq.update(x[i], rmq.query_value(0, x[i]) + x[i]);\n  }\n  ans -= rmq.query_value(0, N + 1);\n  cout << ans << endl;\n  return 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include <iostream>\n#include <cmath>\n#include <algorithm>\n\nusing namespace std;\n\nconst int N = 1 << 17;\nint dat[N * 2 - 1] = { 0 }, n, m;\n\nvoid update(int i, int val) {\n\ti += m - 1;\n\tdat[i] = val;\n\twhile(i > 0) {\n\t\ti = (i - 1) / 2;\n\t\tdat[i] = max(dat[i * 2 + 1], dat[i * 2 + 2]);\n\t}\n\treturn;\n}\n\nint getval(int a, int b, int k, int l, int r) {\n\tif (r <= a || b <= l) return 0;\n\tif (a <= l && r <= b) return dat[k];\n\telse{\n\t\tint vl = getval(a, b, k * 2 + 1, l, (l + r) / 2);\n\t\tint vr = getval(a, b, k * 2 + 2, (l + r / 2), r);\n\t\treturn max(vl, vr);\n\t}\n}\n\nint main(){\n\tint a, v;\n\tdouble p, ip = 0.0, fp;\n\tcin >> n;\n\tp = log2(n);\n\tfp = modf(p, &ip);\n\tif(fp == 0.0) {\n\t\tm = 1 << int(p);\n\t}\n\telse{\n\t\tm = 1 << (int(p) + 1);\n\t}\n\tfor(int i = 0;i < n;++i){\n\t\tcin >> a;\n\t\tv = getval(0, a, 0, 0, m);\n\t\tupdate(a - 1, a + v); // 0-indexedにしたいので\n\t}\n\tcout << n * (n + 1) / 2 - dat[0] << endl;\n\treturn 0;\n}\n\n"
  },
  {
    "language": "C++",
    "code": "// AOJ 2431\n#include<cstdio>\n#include<algorithm>\n#define rep(i,a) for( int i = 0; i != (a); ++i )\n\ntypedef long long ll;\n\nll n, dat[(1<<18)-1];\nint sz;\n\nvoid init()\n{\n\tsz = 1;\n\twhile( sz < n )\n\t\tsz <<= 1;\n\n\trep( i, (sz<<1)-1 )\n\t\tdat[i] = 0;\n\n\treturn;\n}\n\nvoid update( int k, ll x )\n{\n\tk += sz-1;\n\tdat[k] = x;\n\n\twhile( k )\n\t{\n\t\tk = (k-1)>>1;\n\t\tdat[k] = std::max( dat[(k<<1)+1], dat[(k<<1)+2] );\n\t}\n\n\treturn;\n}\n\nll query( int a, int b, int k, int l, int r )\n{\n\tif( r <= a || b <= l )\n\t\treturn 0;\n\telse if( a <= l && r <= b )\n\t\treturn dat[k];\n\telse\n\t\treturn std::max( query( a, b, (k<<1)+1, l, (l+r)>>1 ), query( a, b, (k<<1)+2, (l+r)>>1, r ) );\n}\n\nint main()\n{\n\tscanf( \"%lld\", &n );\n\tll ans = 0;\n\tinit();\n\trep( i, n )\n\t{\n\t\tint x;\n\t\tscanf( \"%d\", &x );\n\t\tupdate( x, query( 1, x+1, 0, 0, sz ) + x );\n\t\tans = std::max( ans, dat[x+sz-1] );\n\t}\n\n\tprintf( \"%lld\\n\", (n*(n+1)>>1)-ans );\n\n\treturn 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include <iostream>\n//#include <cstdio>\n//#include <cmath>\n#include <vector>\n#include <algorithm>\n#include <string>\n#include <map>\n//#include <set>\n#include <queue>\n//#include <limits>\n#include <sstream>\n//#include <functional>\nusing namespace std;\n\n#define len(array)  (sizeof (array) / sizeof *(array))\n#define rep(i, s, e) for(int i = s;i < e;i++)\n#define rrep(i, e, s) for(int i = e;s <= i;i--)\n#define mfill(a, v) fill(a, a + len(a), v)\n#define mfill2(a, v, t) fill((t *)a, (t *)(a + len(a)), v)\n#define vsort(v) sort(v.begin(), v.end())\n#define rvsort(v, t) sort(v.begin(), v.end(), greater<t>())\n#define asort(a) sort(a, a + len(a))\n#define rasort(a, t) sort(a, a + len(a), greater<t>())\ntypedef unsigned int ui;\ntypedef long long ll;\ntypedef unsigned long long ull;\ntypedef pair<int, int> P;\nconst int INF = (int)1e9;\nconst int MOD = (int)1e9 + 7;\nconst double EPS = 1e-10;\nconst int dx[] = {1, -1, 0, 0, 1, -1, -1, 1};\nconst int dy[] = {0, 0, 1, -1, -1, -1, 1, 1};\nconst int weight[] = {0,1,10,100,1000,10000,100000,1000000,10000000};\n\n\nconst int MAX_N = 100000 + 2;\nll bit[MAX_N];\nint input[MAX_N], n;\n\n\nvoid add(int idx, ll val, ll* ary){\n  int p = idx;\n  while(p < MAX_N){\n\tary[p] = max(ary[p], val);\n\tp += p & -p;\n  }\n}\n\nll get(int idx, ll *ary){\n  ll res = 0;\n  int p = idx;\n  while(0 < p){\n\tres = max(res, ary[p]);\n\tp -= p & -p;\n  }\n  return res;\n}\n\nvoid doIt(){\n  cin >> n;\n  rep(i, 0, n) cin >> input[i];\n  mfill(bit, 0);\n  rep(i, 0, n){\n\tadd(input[i], get(input[i], bit) + input[i], bit);\n  }\n  cout << n*(n+1)/2 - get(n, bit) << endl;\n}\n\nint main() {\n  doIt();\n  return 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include <iostream>\n#include <vector>\n#include <map>\n#include <tuple>\nusing namespace std;\n\nconst int MAX_N = 1<<17;\n\nint n;\nint64_t dat[2*MAX_N-1];\n\nvoid init(int n_){\n    n = 1;\n    while(n<n_)n*=2;\n    for(int i=0;i<2*n-1;i++) dat[i]=1e12;\n}\n\n//0-indexed, k-th to a\nvoid update(int k, int64_t a){\n    k+=n-1;\n    dat[k]=a;\n    while(k>0){\n        k=(k-1)/2;\n        dat[k]=min(dat[k*2+1],dat[k*2+2]);\n    }\n}\n\n//[a,b)???????°????\nint64_t query(int a, int b, int k=0, int l=0, int r=n){\n    if(r<=a||b<=l) return INT_MAX;\n    if(a<=l&&r<=b) return dat[k];\n    else{\n        int64_t vl = query(a,b,k*2+1,l,(l+r)/2);\n        int64_t vr = query(a,b,k*2+2,(l+r)/2,r);\n        return min(vl,vr);\n    }\n}\n\nusing P = pair<int,int>;\n\nint main(){\n    int N;\n    cin>>N;\n    vector<P> V;\n    vector<int> X;\n    for(int i=0;i<N;i++){\n        int x;\n        cin>>x;\n        V.emplace_back(x,i);\n        X.push_back(x);\n    }\n    sort(V.begin(), V.end());\n    vector<int> nth(N);\n    for(int i=0;i<N;i++){\n        nth[V[i].second]=i;\n    }\n    init(N);\n    for(int i=0;i<N;i++){\n        update(i,0);\n    }\n    for(int i=0;i<N;i++){\n        int64_t sum = -X[i];\n        if(nth[i]){\n            sum+=query(0,nth[i]);\n        }\n        update(nth[i],sum);\n    }\n    int64_t ans = 0;\n    for(auto x:X) ans+=x;\n    ans+=query(0,N);\n    cout<<ans<<endl;\n\n    return 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include <sstream>\n#include <string>\n#include <vector>\n#include <map>\n#include <algorithm>\n#include <iostream>\n#include <utility>\n#include <set>\n#include <cctype>\n#include <queue>\n#include <stack>\n#include <cstdio>\n#include <cstdlib>\n#include <cmath>\n#include <climits>\nusing namespace std;\n#define INF 100000000\n\ntypedef long long ll;\nconst int dx[] = {1, 0, -1, 0};\nconst int dy[] = {0, 1, 0, -1};\n\nclass BIT {\npublic:\n    ll bit[1000010];\n    int bit_size;\n    BIT(int n) {\n        for (int i = 0; i < n+10; i++) bit[i] = 0;\n        bit_size = n;\n    }\n    void bit_add(int n, ll v) {\n        while (n <= bit_size) {\n            bit[n] = max(bit[n], v);\n            n += n & (-n);\n        }\n    }\n    ll bit_sum(int n) {\n        ll ans = 0;\n        while (n > 0) {\n            ans += bit[n];\n            n &= n-1;\n        }\n        return ans;\n    }\n    ll bit_max(int n) {\n        ll ans = 0;\n        while (n > 0) {\n            ans = max(ans, bit[n]);\n            n &= n-1;\n        }\n        return ans;\n    }\n};\n\nint main(void) {\n    int n;\n    cin >> n;\n    BIT bit(n+1);\n    ll ans = 0;\n    for (int i = 1; i <= n; i++) {\n        int x;\n        cin >> x;\n        ll cost = bit.bit_max(x-1);\n        ll tmp = cost + x;\n        ans = max(ans, tmp);\n        bit.bit_add(x, tmp);\n    }\n    ll sum = ((ll)n*(ll)(n+1)) / 2;\n    cout << sum - ans << endl;\n    return 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include<stdio.h>\n#include<algorithm>\nusing namespace std;\nint b[100000];\nint c[100000];\nlong long dp[100000];\nlong long segtree[262144];\nvoid set(int a,long long b){\n\ta+=131072;\n\twhile(a){\n\t\tsegtree[a]=max(segtree[a],b);\n\t\ta/=2;\n\t}\n}\nlong long query(int a,int b,int c,int d,int e){\n\tif(b<c||d<a)return 0;\n\tif(c<=a&&b<=d)return segtree[e];\n\treturn max(query(a,(a+b)/2,c,d,e*2),query((a+b)/2+1,b,c,d,e*2+1));\n}\npair<int,int> dat[100000];\nint m[100000];\nint main(){\n\tint a;\n\tscanf(\"%d\",&a);\n\tlong long sum=0;\n\tfor(int i=0;i<a;i++){\n\t\tscanf(\"%d\",c+i);\n\t\tb[i]=i+1;\n\t\tsum+=b[i];\n\t}\n\n\tfor(int i=0;i<a;i++)dat[i]=make_pair(c[i],i);\n\tstd::sort(dat,dat+a);\n\tfor(int i=0;i<a;i++){\n\t\tlong long val=query(0,131071,0,dat[i].second,1);\n\t\tdp[dat[i].second]=val+b[i];\n\t\tset(dat[i].second,dp[dat[i].second]);\n\t}\n\tprintf(\"%lld\\n\",(sum-query(0,131071,0,131071,1)));\n}"
  },
  {
    "language": "C++",
    "code": "#include <iostream>\n#include <iomanip>\n#include <cstdio>\n#include <string>\n#include <cstring>\n#include <deque>\n#include <list>\n#include <queue>\n#include <stack>\n#include <vector>\n#include <utility>\n#include <algorithm>\n#include <map>\n#include <set>\n#include <complex>\n#include <cmath>\n#include <limits>\n#include <cfloat>\n#include <climits>\n#include <ctime>\n#include <cassert>\n#include <numeric>\n#include <functional>\nusing namespace std;\n\n#define rep(i,a,n) for(int (i)=(a); (i)<(n); (i)++)\n#define repq(i,a,n) for(int (i)=(a); (i)<=(n); (i)++)\n#define repr(i,a,n) for(int (i)=(a); (i)>=(n); (i)--)\n#define int long long int\n\ntemplate<typename T> void chmax(T &a, T b) {a = max(a, b);}\ntemplate<typename T> void chmin(T &a, T b) {a = min(a, b);}\ntemplate<typename T> void chadd(T &a, T b) {a = a + b;}\n\ntypedef pair<int, int> pii;\ntypedef long long ll;\n\nint dx[] = {0, 0, 1, -1};\nint dy[] = {1, -1, 0, 0};\nconstexpr ll INF = 1001001001001001LL;\nconstexpr ll MOD = 1000000007LL;\n\nll seg[1 << 18];\nconstexpr ll SIZE = 1 << 17;\n\nvoid update(int x, int val) {\n    int p = SIZE - 1 + x;\n    chmax(seg[p], val);\n    while(p > 0) {\n        p = (p - 1) / 2;\n        chmax(seg[p], val);\n    }\n}\n\nint solve(int a, int b, int l=0, int r=SIZE, int k=0) {\n    if(r <= a || b <= l) return 0;\n    if(a <= l && r <= b) return seg[k];\n    int mid = (l+r) / 2;\n    int vl = solve(a, b, l, mid, 2*k+1);\n    int vr = solve(a, b, mid, r, 2*k+2);\n    return max(vl, vr);\n}\n\nint N, x;\n\nsigned main() {\n    cin >> N;\n    int sum = 0;\n    rep(i,0,N) {\n        cin >> x; sum += x;\n        int val = solve(0, x) + x;\n        update(x, val);\n    }\n    cout << sum - solve(0, N+1) << endl;\n    return 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include<cstdio>\n#include<iostream>\n#include<string>\n#include<vector>\n#include<algorithm>\n\nusing namespace std;\n\n#define reps(i,f,n) for(int i=f;i<int(n);i++)\n#define rep(i,n) reps(i,0,n)\n\ntypedef long long ll;\n\nconst int N = 100010;\n\nclass BIT{\n\tstatic const int N = 100010;\n\tpublic:\n\tll t[N];\n\tvoid init(){rep(i,N)t[i]=0;}\n\tll calc(ll a,ll b){return max(a,b);}\n\t\n\tvoid setval(int pos, ll val){\n\t\tpos++;\n\t\tfor(int i=0;;i++){\n\t\t\tif(pos>=N)break;\n\t\t\tif(pos&(1<<i)){\n\t\t\t\tt[pos] = calc(t[pos],val);\n\t\t\t\tpos += (1<<i);\n\t\t\t}\n\t\t}\n\t}\n\t\n\tll getval(int pos){\n\t\tpos++;\n\t\tll ret = 0;\n\t\tfor(int i=0;;i++){\n\t\t\tif(pos==0)break;\n\t\t\tif(pos&(1<<i)){\n\t\t\t\tret = calc(ret, t[pos]);\n\t\t\t\tpos -= (1<<i);\n\t\t\t}\n\t\t}\n\t\treturn ret;\n\t}\n\t\n\tvoid print(){\n\t\tprintf(\"t : \");\n\t\trep(i,10)printf(\"%d \",t[i]);puts(\"\");\n\t}\n};\n\nint main(){\n\tint n;\n\tcin>>n;\n\t\n\tint p[N];\n\tll sum = 0;\n\trep(i,n){\n\t\tcin>>p[i];\n\t\tsum += p[i];\n\t}\n\t\n\tBIT bit;\n\tbit.init();\n\t\n\trep(i,n){\n\t\tbit.setval( p[i], bit.getval(p[i])+p[i] );\n\t\t//bit.print();\n\t}\n\t\n\tcout<<sum - bit.getval(n)<<endl;\n}\n\n/*\n5\n1 5 3 2 4\n\n*/"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\nusing namespace std;\n\ntypedef long long ll;\ntypedef unsigned long long ull;\ntypedef pair<ll, ll> P;\n\n#define fi first\n#define se second\n#define repl(i,a,b) for(ll i=(ll)(a);i<(ll)(b);i++)\n#define rep(i,n) repl(i,0,n)\n#define each(itr,v) for(auto itr:v)\n#define pb push_back\n#define all(x) (x).begin(),(x).end()\n#define dbg(x) cout<<#x\"=\"<<x<<endl\n#define mmax(x,y) (x>y?x:y)\n#define mmin(x,y) (x<y?x:y)\n#define maxch(x,y) x=mmax(x,y)\n#define minch(x,y) x=mmin(x,y)\n#define uni(x) x.erase(unique(all(x)),x.end())\n#define exist(x,y) (find(all(x),y)!=x.end())\n#define bcnt __builtin_popcount\n\n#define INF 1e16\n\nstruct RangeMaxQuery{\n  ll dat[(1<<19)-1];\n  ll size;\n\n  void init(ll n_){\n    size=1;\n    while(size<n_) size*=2;\n    for(ll i=0;i<2*size-1;i++)dat[i]=-INF;\n  }\n\n  void update(ll k,ll a){\n    k+=size-1;\n    dat[k]=a;\n    while(k>0){\n      k=(k-1)/2;\n      dat[k]=max(dat[k*2+1],dat[k*2+2]);\n    }\n  }\n\n  ll subquery(int a,int b,int k,int l,int r){\n    if(r<=a||b<=l)return -INF;\n    if(a<=l&&r<=b)return dat[k];\n    else{\n      return max(subquery(a,b,k*2+1,l,(l+r)/2),subquery(a,b,k*2+2,(l+r)/2,r));\n    }\n  }\n  \n  ll query(int a,int b){\n    return subquery(a,b,0,0,size);\n  }\n};\n\n\nll n;\nll a[111111];\nRangeMaxQuery rmq;\n\nint main(){\n\tcin.sync_with_stdio(false);\n  cin>>n;\n  rep(i,n){\n    cin>>a[i];\n  }\n  rmq.init(n+1);\n  rmq.update(0,0);\n  rep(i,n){\n    ll sum=a[i]+rmq.query(0,a[i]);\n    rmq.update(a[i],sum);\n  }\n  cout<<n*(n+1)/2-rmq.query(0,n+1)<<endl;\n\treturn 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include <cstdio>\n#include <algorithm>\nusing namespace std;\n\n#define MAX_N 131072\ntypedef long long LL;\n\nLL dat[2 * MAX_N - 1];\nint n;\n\nvoid update(int k, LL a){\n\tk += n - 1;\n\tdat[k] = a;\n\t\n\twhile(k > 0){\n\t\tk = (k - 1) / 2;\n\t\tdat[k] = max(dat[k * 2 + 1], dat[k * 2 + 2]);\n\t}\n}\n\nLL maxvalue(int a, int b, int k, int left, int r){\n\tif( r <= a || b <= left ) return 0;\n\tif( a <= left && r <= b ) return dat[k];\n\telse{\n\t\tLL vl = maxvalue(a, b, k * 2 + 1, left, (left + r) / 2);\n\t\tLL vr = maxvalue(a, b, k * 2 + 2, (left + r) / 2, r);\n\t\treturn max(vl, vr);\n\t}\n}\n\nint main(){\n\tint x;\n\tint n0;\n\tscanf(\"%d\", &n0);\n\t\n\tn = n0 + 1;\n\twhile( n & (n - 1) ){\n\t\tn += n & -n;\n\t}\n\n\tfor(int i = 0; i < n0; ++i){\n\t\tscanf(\"%d\", &x);\n\n\t\tLL y = maxvalue(0, x, 0, 0, n);\n\t\tupdate(x, y + x);\n\t}\n\t\n\tLL m = maxvalue(0, n0 + 1, 0, 0, n);\n\tprintf(\"%lld\\n\", (LL)n0 * (n0 + 1) / 2 - m);\n}"
  },
  {
    "language": "C++",
    "code": "#include <limits>\n#include <vector>\n#include <iostream>\n#include <iterator>\n#include <algorithm>\n\nusing namespace std;\n\ntypedef long long ll;\n\nnamespace libcomp {\nnamespace structure {\n\ntemplate <typename T>\nstruct MaxSegmentTreeTraits {\n\ttypedef T value_type;\n\tT default_value() const { return numeric_limits<T>::min(); }\n\tT operator()(const T &a, const T &b) const { return max(a, b); }\n};\n\ntemplate <typename Traits>\nclass SegmentTree {\n\npublic:\n\ttypedef typename Traits::value_type value_type;\n\nprivate:\n\tTraits m_traits;\n\tvector<value_type> m_data;\n\tsize_t m_size;\n\n\tvoid initialize(){\n\t\tfor(int i = static_cast<int>(m_size) - 2; i >= 0; --i){\n\t\t\tm_data[i] = m_traits(m_data[i * 2 + 1], m_data[i * 2 + 2]);\n\t\t}\n\t}\n\n\tvalue_type query(int a, int b, int k, int l, int r) const {\n\t\tif(r <= a || b <= l){ return m_traits.default_value(); }\n\t\tif(a <= l && r <= b){ return m_data[k]; }\n\t\tconst value_type vl = query(a, b, k * 2 + 1, l, (l + r) / 2);\n\t\tconst value_type vr = query(a, b, k * 2 + 2, (l + r) / 2, r);\n\t\treturn m_traits(vl, vr);\n\t}\n\npublic:\n\texplicit SegmentTree(size_t size, const Traits &traits = Traits()) :\n\t\tm_size(1), m_traits(traits)\n\t{\n\t\twhile(m_size < size){ m_size *= 2; }\n\t\tm_data.resize(m_size * 2 - 1, m_traits.default_value());\n\t\tinitialize();\n\t}\n\n\ttemplate <typename Iterator>\n\tSegmentTree(\n\t\tIterator first, Iterator last, const Traits &traits = Traits()) :\n\t\tm_size(1), m_traits(traits)\n\t{\n\t\tconst size_t n = distance(first, last);\n\t\twhile(m_size < n){ m_size *= 2; }\n\t\tm_data.resize(m_size * 2 - 1, m_traits.default_value());\n\t\tcopy(first, last, m_data.begin() + m_size - 1);\n\t\tinitialize();\n\t}\n\n\tvoid update(size_t i, const value_type &val){\n\t\ti += m_size - 1;\n\t\tm_data[i] = val;\n\t\twhile(i > 0){\n\t\t\ti = (i - 1) / 2;\n\t\t\tm_data[i] = m_traits(m_data[i * 2 + 1], m_data[i * 2 + 2]);\n\t\t}\n\t}\n\n\tvalue_type query(size_t a, size_t b) const {\n\t\treturn query(a, b, 0, 0, m_size);\n\t}\n\n};\n\n}\n}\n\nint main(){\n\tusing libcomp::structure::MaxSegmentTreeTraits;\n\tusing libcomp::structure::SegmentTree;\n\tios_base::sync_with_stdio(false);\n\tint n;\n\tcin >> n;\n\tvector<int> x(n);\n\tfor(int i = 0; i < n; ++i){ cin >> x[i]; }\n\tSegmentTree< MaxSegmentTreeTraits<ll> > st(n + 1);\n\tll max_sum = 0;\n\tfor(int i = 0; i < n; ++i){\n\t\tconst ll y = max(0ll, st.query(0, x[i])) + x[i];\n\t\tmax_sum = max(max_sum, y);\n\t\tst.update(x[i], y);\n\t}\n\tcout << (static_cast<ll>(n) * (n + 1)) / 2 - max_sum << endl;\n\treturn 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include<bits/stdc++.h>\nusing namespace std;\n\ntypedef long long int ll;\ntypedef pair<int, int> pii;\ntypedef vector<int> vi;\ntypedef vector<pair<int, int> > vii;\n#define rrep(i, m, n) for(int (i)=(m); (i)<(n);  (i)++)\n#define erep(i, m, n) for(int (i)=(m); (i)<=(n); (i)++)\n#define  rep(i, n)    for(int (i)=0; (i)<(n);  (i)++)\n#define rrev(i, m, n) for(int (i)=(n)-1; (i)>=(m); (i)--)\n#define erev(i, m, n) for(int (i)=(n); (i)>=(m); (i)--)\n#define  rev(i, n)    for(int (i)=(n)-1; (i)>=0; (i)--)\n#define vrep(i, c)    for(__typeof((c).begin())i=(c).begin(); i!=(c).end(); i++)\n#define  ALL(v)       (v).begin(), (v).end()\n#define pb            push_back\n#define mp            make_pair\ntemplate<class T, class S> inline bool minup(T& m, const S x){ return m>(T)x ? (m=(T)x, true) : false; }\ntemplate<class T, class S> inline bool maxup(T& m, const S x){ return m<(T)x ? (m=(T)x, true) : false; }\n\nstatic const int    INF = 1000000000;\nstatic const ll     MOD = 1000000007LL;\nstatic const double EPS = 1E-10;\n\nconst int SZ = 1 << 19;\nint n, _n;\nint x[111111];\nll dp[4 * SZ + 1];\n\nvoid init(int n)\n{\n  _n = 1;\n  while(_n < n) _n *= 2;\n}\n\nvoid update(int k, int x)\n{\n  k += _n - 1;\n  dp[k] = x;\n  while(k > 0){\n    k = (k - 1) / 2;\n    dp[k] = max(dp[2 * k + 1], dp[2 * k + 2]);\n  }\n}\n\nll query(int a, int b, int k = 0, int l = 0, int r = _n)\n{\n  if(r <= a || b <= l) return 0;\n  if(a <= l && r <= b) return dp[k];\n  return max(query(a, b, 2 * k + 1, l, (l + r) / 2),\n             query(a, b, 2 * k + 2, (l + r) / 2, r));\n}\n\nint main(int argc, char *argv[])\n{\n  cin >> n;\n  rep(i, n) cin >> x[i];\n\n  int res = 0;\n  init(n);\n  rep(i, n){\n    update(x[i], query(1, x[i] + 1) + x[i]);\n    maxup(res, query(x[i], x[i] + 1));\n  }\n\n  cout << n * (n + 1LL) / 2LL - res << endl;\n    \n  return 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\nusing namespace std;\n\nusing VI = vector<int>;\nusing VVI = vector<VI>;\nusing PII = pair<int, int>;\nusing LL = long long;\nusing VL = vector<LL>;\nusing VVL = vector<VL>;\nusing PLL = pair<LL, LL>;\nusing VS = vector<string>;\n\n#define ALL(a)  begin((a)),end((a))\n#define RALL(a) (a).rbegin(), (a).rend()\n#define PB push_back\n#define EB emplace_back\n#define MP make_pair\n#define SZ(a) int((a).size())\n#define SORT(c) sort(ALL((c)))\n#define RSORT(c) sort(RALL((c)))\n#define UNIQ(c) (c).erase(unique(ALL((c))), end((c)))\n\n#define FOR(i,a,b) for(int i=(a);i<(b);++i)\n#define REP(i,n)  FOR(i,0,n)\n\n#define FF first\n#define SS second\ntemplate<class S, class T>\nistream& operator>>(istream& is, pair<S,T>& p){\n  return is >> p.FF >> p.SS;\n}\ntemplate<class S, class T>\nostream& operator<<(ostream& os, const pair<S,T>& p){\n  return os << p.FF << \" \" << p.SS;\n}\ntemplate<class T>\nvoid maxi(T& x, T y){\n  if(x < y) x = y;\n}\ntemplate<class T>\nvoid mini(T& x, T y){\n  if(x > y) x = y;\n}\n\n\nconst double EPS = 1e-10;\nconst double PI  = acos(-1.0);\nconst LL MOD = 1e9+7;\n\nclass BIT{\nprivate:\n  int n;\n  vector<LL> bit;\npublic:\n  BIT(int n_){\n\tn = n_;\n\tbit.assign(n+1, 0);\n  }\n\n  LL max(int i){\n\tLL s = 0;\n\twhile(i > 0){\n\t  maxi(s, bit[i]);\n\t  i -= i & -i;\n\t}\n\treturn s;\n  }\n\n  void add(int i, LL x){\n\twhile(i <= n){\n\t  maxi(bit[i], x);\n\t  i += i & -i;\n\t}\n  }\n};\n\nint main(){\n  cin.tie(0);\n  ios_base::sync_with_stdio(false);\n\n  LL N;\n  cin >> N;\n  VL xs(N);\n  REP(i,N) cin >> xs[i];\n\n  BIT bit(N+1);\n  LL ans = 0;\n  REP(i,N){\n\tLL t = xs[i] + bit.max(xs[i]);\n\tmaxi(ans, t);\n\tbit.add(xs[i], t);\n  }\n  cout << N * (N+1) / 2 - ans << endl;\n\n  return 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include \"bits/stdc++.h\"\n#include<unordered_map>\n#include<unordered_set>\n#pragma warning(disable:4996)\nusing namespace std;\nusing ld = long double;\ntemplate<class T>\nusing Table = vector<vector<T>>;\nld eps=1e-9;\n\n#define Seg_Max_N (1<<18) \nusing Value = long long int ;\nValue dat[2 * Seg_Max_N];\nstruct segtree {\n\tint N;\n\tconst Value ini = 0;\n\tsegtree() {}\n\tsegtree(int n) {\n\t\tN = 1;\n\t\twhile (N < n) N *= 2;\n\t\tfor (int i = 0; i < 2 * N - 1; i++) {\n\t\t\tdat[i] = ini;\n\t\t}\n\t}\n\t// update k th element\n\tvoid update(int k, Value a) {\n\t\tk += N - 1; // leaf\n\t\tdat[k] = a;\n\t\twhile (k > 0) {\n\t\t\tk = (k - 1) / 2;\n\t\t\tconst Value al(dat[k * 2 + 1]);\n\t\t\tconst Value ar(dat[k * 2 + 2]);\n\t\t\tdat[k] = max(al, ar);\n\t\t}\n\t}\n\t// min [a, b)\n\tValue  query(int a, int b) { return query(a, b, 0, 0, N); }\n\tValue  query(int a, int b, int k, int l, int r) {\n\t\tif (r <= a or b <= l) return ini;\n\t\tif (a <= l and r <= b) return dat[k];\n\t\tconst int m = (l + r) / 2;\n\t\tconst Value al(query(a, b, k * 2 + 1, l, m));\n\t\tconst Value ar(query(a, b, k * 2 + 2, m, r));\n\t\treturn max(al, ar);\n\t}\n};\nint main() {\n\tint N; cin >> N;\n\tvector<int>hs;\n\tvector<long long int>dps;\n\tsegtree seg(N);\n\tfor (size_t i = 0; i < N; i++)\n\t{\n\t\tint a; cin >> a; a--; hs.emplace_back(a);\n\t}\n\tfor (size_t i = 0; i < N; i++)\n\t{\n\t\tint next = seg.query(0, hs[i]);\n\t\tseg.update(hs[i], next + hs[i] + 1);\n\t}\n\tlong long int ans =N*(N+1)/2- seg.query(0, N);\n\tcout << ans << endl;\n\treturn 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include<bits/stdc++.h>\nusing namespace std;\n#define INF 2147483647\n#define MAX_N 100000\n#define MAX_Q 100000\n\n\nlong long n, q;\nlong long dat[MAX_N*4];\n\n//すべてのノードを0で初期化\nvoid init(){\n    for(int i = 0; i < 2*n - 1; i++) dat[i] = 0;\n}\n\n\n//a[i] を x に変更\nvoid update(int i, long long x){\n    i += n - 1;\n    dat[i] = x;\n\n    //登りながら探索\n    while(i > 0){\n        i = (i - 1) / 2;\n        dat[i] = max(dat[2*i + 1], dat[2*i + 2]);\n    }\n}\n\n\n//区間[a, b)の最大値を返す\nlong long find(int a, int b, int k, int l, int r){\n    if(r <= a || b <= l) return 0;\n    else if(a <= l && r <= b) return dat[k];\n    else{\n        int vl = find(a, b, k * 2 + 1, l, (l + r)/2);\n        int vr = find(a, b, k * 2 + 2, (l + r)/2, r);\n        return max(vl, vr);\n    }\n}\n\nint main(){\n\n    cin >> q;\n    n = q;\n    n++;\n    vector<long long> dp(q + 1, 0);\n    vector<int> POW(20);\n    POW[0] = 1;\n\n    for(int i = 1; i < 20; i++){\n        POW[i] = POW[i-1]*2;\n    }\n\n    //n以上n^2っぽいなにかと置換\n    n = *lower_bound(POW.begin(), POW.end(), n);\n    init();\n\n    for(int i = 0; i < q; i++){\n        long long x; cin >> x;\n\n        long long Max = find(0, x, 0, 0, n);\n        dp[x] = max(dp[x], Max + x);\n        update(x, dp[x]);\n        \n        //cout << x << \" \" << Max << \" \" << dp[x] << endl;\n    }\n\n    long long ans = 0;\n    for(int i = 1; i <= q; i++) ans = max(ans, dp[i]);\n    ans = -ans;\n    for(int i = 1; i <= q; i++) ans += (long long)i;\n    \n    cout << ans << endl;\n    \n    return 0;\n}\n"
  },
  {
    "language": "C++",
    "code": "#include <iostream>\n#include <algorithm>\n#define rep(a,b) for(int a = 0; a < b; a++)\n\nusing namespace std;\n\nlong int arr[100001];\nlong int dp[100001]{};\nlong int n;\n\nint main() {\n  cin >> n;\n  rep(i,n+1) cin >> arr[i];\n  rep(i,n) {\n    long int temp = 0;\n    rep(j,arr[i]) {\n      temp = max(temp,dp[arr[j]]);\n    }\n    dp[i+1] = temp + arr[i];\n  }\n  long int ans = 0;\n  rep(i,n+1) ans = max(ans,dp[i]);\n  //rep(i,n+1) cout << dp[i] << endl;\n  long int all = (1+n)*n/2;\n  cout << all-ans << endl;\n  return 0;\n}\n\n"
  },
  {
    "language": "C++",
    "code": "#include<iostream>\n#include<vector>\n#include<algorithm>\n#include<climits>\n\nconst int MAX_N=100000;\n\nusing namespace std;\n\nint n,dat[2*MAX_N-1];\n\nvoid init(int n_){\n\tn=1;\n\twhile(n<n_)n*=2;\n\tfor(int i=0;i<2*n-1;i++)dat[i]=0;\n}\n\nvoid update(int k,int a){\n\tk+=n-1;\n\tdat[k]=a;\n\t\n\twhile(k>0){\n\t\tk=(k-1)/2;\n\t\tdat[k]=max(dat[2*k+1],dat[2*k+2]);\n\t}\n}\n\nint query(int a,int b,int k,int l,int r){\n\tif(r<=a || b<=l)return 0;\n\tif(a<=l && r<=b)return dat[k];\n\telse {\n\t\tint vl=query(a,b,k*2+1,l,(l+r)/2);\n\t\tint vr=query(a,b,k*2+2,(l+r)/2,r);\n\t\treturn max(vl,vr);\n\t}\n}\n\nint main(void){\n\t\n\tint in,n_,ans=0;\n\tcin >> n_;\n\t\n\tinit(n_);\n\t\n\tfor(int i=0;i<n_;i++){\n\t\tcin >> in;\n\t\tupdate(in,in+query(1,in+1,0,0,n));\n\t\tans=max(ans,dat[in+n-1]);\n\t}\n\tcout << n_*(n_+1)/2-ans << endl;\n\t\n\treturn 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\nusing namespace std;\ntypedef long long ll;\ntypedef pair<ll, ll> l_l;\ntypedef pair<int, int> i_i;\n\n#define EPS (1e-7)\n#define INF (1e9)\n#define PI (acos(-1))\n//const ll mod = 1000000007;\nstruct SegmentTree {\nprivate:\n    int n;\n    vector<ll> node;\n \npublic:\n    SegmentTree() {\n        int sz = 100050;\n        n = 1; while(n < sz) n *= 2;\n        node.resize(2*n-1, 0);\n        for(int i=0; i<sz; i++) node[i+n-1] = 0;\n        for(int i=n-2; i>=0; i--) node[i] = max(node[2*i+1], node[2*i+2]);\n    }\n \n    void update(int x, ll val) {\n        x += (n - 1);\n        node[x] = val;\n        while(x > 0) {\n            x = (x - 1) / 2;\n            node[x] = max(node[2*x+1], node[2*x+2]);\n        }\n    }\n    // hannkaikukann \n    ll getmax(int a, int b, int k=0, int l=0, int r=-1) {\n        if(r < 0) r = n;\n        if(r <= a || b <= l) return 0;\n        if(a <= l && r <= b) return node[k];\n \n        ll vl = getmax(a, b, 2*k+1, l, (l+r)/2);\n        ll vr = getmax(a, b, 2*k+2, (l+r)/2, r);\n        return max(vl, vr);\n    }\n};\n\nll N;\nll x[105000];\nll xsum;\n\nint main() {\n    //cout.precision(10);\n    cin.tie(0);\n    ios::sync_with_stdio(false);\n    cin >> N;\n    SegmentTree seg;\n    for(int i = 0; i < N; i++) {\n        cin >> x[i];\n        xsum += x[i];\n        ll val = seg.getmax(0, x[i]);\n        seg.update(x[i], val + x[i]);\n    }\n    cout << xsum - seg.getmax(0, N + 1) << endl;\n    return 0;\n}\n"
  },
  {
    "language": "C++",
    "code": "#include<bits/stdc++.h>\n#define MAX (1<<17)\nusing namespace std;\n\ntypedef long long ll;\n\nint n;\nll st[MAX*2];\n\nvoid init(){\n  int tmp=1;\n  while(tmp<n)tmp*=2;\n  n=tmp;\n  for(int i=0;i<n*2-1;i++)st[i]=0;\n}\n\nvoid update(int k,ll x){\n  k+=n-1;\n  st[k]=x;\n  while(k>0){\n    k=(k-1)/2;\n    st[k]=max(st[k*2+1],st[k*2+2]);\n  }\n}\n\nll find(int a,int b,int k,int l,int r){\n\n  if(r<=a || b<=l)return 0;\n\n  if(a<=l && r<=b)return st[k];\n\n  ll v1=find(a,b,k*2+1,l,(l+r)/2);\n  ll v2=find(a,b,k*2+2,(l+r)/2,r);\n  return max(v1,v2);\n}\n\nint main()\n{\n  ll a,ans=0,m;\n\n  cin>>n;\n\n  m=n;\n  ans=n*(n+1)/2;\n  init();\n\n  for(int i=0;i<m;i++){\n    cin>>a;\n    ll res=find(1,a,0,0,n);\n    update(a,a+res);\n  }\n\n  ans-=find(1,m+1,0,0,n);\n\n  cout<<ans<<endl;\n\n  return 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include <iostream>\n#include <algorithm>\n\nusing namespace std;\n\n#define ll long long\n#define rep(a,b) for(int a = 0; a < b; a++)\n\nint n;\nll dp[100001*2];\nint arr[1<<18];\nint size = 1;\n\nvoid update(int index, ll num) {\n  index += size-1;\n  dp[index] = num;\n  //cout << \"  \" << index << \",\" << dp[index] << endl;\n  while(index>0) {\n    int new_index = (index-1)>>1;\n    dp[new_index] = max(dp[(new_index<<1)+1],dp[(new_index<<1)+2]);\n    //cout << \"  \" << new_index << \",\" << dp[new_index] << endl;\n    index = new_index;\n  }\n  //dp[index] = max(dp[index],dp[index^1]);\n}\n\nll get_max(int a, int b, int k, int left, int right) {\n  //cout << \"gmax \" << a << \",\" << b << \",\" << k << \",\" << left << \",\" << right << endl;\n  if(right<a||b<=left||right<=left) return 0;\n  if(a<=left&&right<=b) {\n    //cout << \"OK \" << dp[k] << endl;\n    return dp[k];\n  }\n  ll ret = 0;\n  ret = max(ret,get_max(a,b,(k<<1)+1,left,(left+right)>>1));\n  ret = max(ret,get_max(a,b,(k<<1)+2,(left+right+1)>>1,right));\n  return ret;\n}\n\nint main() {\n  cin >> n;\n  for(int i = 1; i < n; i<<=1) size<<=1;\n  rep(i,n) cin >> arr[i];\n  rep(i,n) {\n    int num = arr[i];\n    ll _max = get_max(1,num,0,0,size);\n    //cout << num << \",\" << _max << endl;\n    update(num,_max+num);\n  }\n  ll ans = (ll)n;\n  ans = n*(n+1)/2;\n  //for(int i = 0; i < size<<1; i++) cout << dp[i] << endl;\n  cout << ans-dp[0] << endl;\n}\n\n"
  },
  {
    "language": "C++",
    "code": "#include <cstdio>\n#include <iostream>\n#include <algorithm>\n#include <complex>\n#include <queue>\n#include <map>\nusing namespace std;\n\n#define FOR(i,a,b) for (int i=(a);i<(b);i++)\n#define FORR(i,a,b) for (int i=(b)-1;i>=(a);i--)\n#define REP(i,n) for (int i=0;i<(n);i++)\n#define RREP(i,n) for (int i=(n)-1;i>=0;i--)\n#define pb push_back\n#define ALL(a) (a).begin(),(a).end()\n\n#define EPS (1e-10)\n#define EQ(a,b) (abs((a)-(b)) < EPS)\n\ntypedef long long ll;\ntypedef pair<ll, int> P;\n//typedef complex<double> C;\n\nconst double pi = acos(-1);\n\nint N;\nint x[100010];\nint sum_x = 0;\n\nvoid input() {\n\tcin >> N;\n\tREP(i, N) {\n\t\tcin >> x[i];\n\t\tsum_x += x[i];\n\t}\n}\n\nconst int MAX_N = 1 << 17;\n\nint width;\nint dat[2 * MAX_N - 1];\n\nvoid init(int n_) {\n    // n: num of elements in the bottom row\n    // let n be the power of 2\n    width = 1;\n    while (width < n_) width *= 2;\n\n    // set all values by INF\n    REP(i, 2 * width - 1) dat[i] = 0;\n}\n\n// change the k-th(0-index) value to a\nvoid update(int k, int a) {\n    // set a in the leaf\n    k += width - 1;\n    dat[k] = a;\n\n    // update upward\n    while (k > 0) {\n        k = (k - 1) / 2;\n        dat[k] = max(dat[2 * k + 1], dat[2 * k + 2]);\n    }\n}\n\n// get the minimum value in [a, b)\n// k: num of the node corresponds to [l, r)\n// call like this: 'query(a, b, 0, 0, n)'\nint query(int a, int b, int k, int l, int r) {\n    // if [a, b) & [l, r) = 0, then return nonsense value\n    if (r <= a || b <= l) return 0;\n\n    // if [a, b) covers the whole [l, r),\n    // then return the value of this node\n    if (a <= l && r <= b) return dat[k];\n\n    // otherwise, return the min of two children\n    int vl = query(a, b, k * 2 + 1, l, (l + r) / 2);\n    int vr = query(a, b, k * 2 + 2, (l + r) / 2, r);\n\n    return max(vl, vr);\n}\n\n\nvoid solve() {\n\t// DP with segment tree\n\tinit(N);\n\tint ma = 0;\n\tREP(i, N) {\n\t\tint tmp = query(0, x[i], 0, 0, width) + x[i];\n\t\tma = max(ma, tmp);\n\t\tint maxi = max(query(x[i], x[i] + 1, 0, 0, width), tmp);\n\t\tupdate(x[i] - 1, maxi);\n\t}\n\n\tcout << sum_x - ma << endl;\n}\n\nint main() {\n\tinput();\n    solve();\n    return 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include<bits/stdc++.h>\nusing namespace std;\n#define int long long\n#define pb push_back \n#define mp make_pair\n#define fr first\n#define sc second\n#define Rep(i,n) for(int i=0;i<(n);i++)\n#define All(v) v.begin(),v.end()\ntypedef pair<int, int> Pii; typedef pair<int, Pii> Pip;\nconst int INF = (1<<30);\n\nstruct SegT\n{\n  vector<int> tree;\n  int n;\n \n  SegT(int n_)\n  {\n    n = 1;\n    while( n < n_ ) n <<= 1;\n    tree = vector<int>(2 * n - 1, 0);\n  }\n  int rmq(int a, int b, int k, int l, int r)\n  {\n    if( a >= r || b <= l ) return 0;\n    if( a <= l && r <= b ) return tree[k];\n    return(max(rmq(a, b, 2 * k + 1, l, (l + r) >> 1),\n               rmq(a, b, 2 * k + 2, (l + r) >> 1, r)));\n  }\n  int rmq(int a, int b)\n  {\n    return (rmq(a, b, 0, 0, n));\n  }\n  int update(int k, int x)\n  {\n    k += n - 1;\n    tree[k] = x;\n    while( k > 0 ) {\n      k = (k - 1) >> 1;\n      tree[k] = max(tree[2 * k + 1], tree[2 * k + 2]);\n    }\n  }\n};\n\nmain() {\n  int n;\n  cin >> n;\n  SegT tree( n );\n\n  Rep(i, n) {\n    int x;\n    cin >> x;\n    tree.update(x, tree.rmq(1, x) + x);\n  }\n\n  cout << n * (n+1) / 2 - tree.rmq(1, n+1) << endl;\n}"
  },
  {
    "language": "C++",
    "code": "// AOJ 2431\n#include<cstdio>\n#include<algorithm>\n#define rep(i,a) for( int i = 0; i != (a); ++i )\n\ntypedef long long ll;\n\nint n;\nll bit[100001];\n\nvoid add( int k, ll x )\n{\n\tfor( int i = k; i <= n; i += i&-i )\n\t\tbit[i] = std::max( bit[i], x );\n\n\treturn;\n}\n\nll sum( int k )\n{\n\tll ret = 0;\n\n\tfor( int i = k; i > 0; i -= i&-i )\n\t\tret = std::max( ret, bit[i] );\n\n\treturn ret;\n}\n\nint main()\n{\n\tscanf( \"%d\", &n );\n\trep( i, n )\n\t{\n\t\tint x;\n\t\tscanf( \"%d\", &x );\n\t\tadd( x, sum( x-1 )+x );\n\t}\n\n\tprintf( \"%lld\\n\", ll(n*(n+1)>>1)-sum(n) );\n\n\treturn 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include <iostream>\n#include <vector>\n#include <functional>\nusing namespace std;\n\ntemplate <class T, class Compare>\nstruct SegmentTree/*{{{*/\n{\n  vector<T>& mem;\n  vector<int> indexes;\n  Compare cmp;\n  SegmentTree(vector<T>& cs)\n    : mem(cs), indexes(4*cs.size(), -1)\n  {\n    build(0, 0, cs.size());\n  }\n\n  void build(int idx, int left, int right)\n  {\n    if (left+1 == right) {\n      indexes[idx] = left;\n    } else {\n      const int mid = (left + right)/2;\n      build(2*idx+1, left, mid);\n      build(2*idx+2, mid, right);\n      // minimum in [left, right)\n      if (cmp(mem[indexes[2*idx+1]], mem[indexes[2*idx+2]])) {\n        indexes[idx] = indexes[2*idx+1];\n      } else {\n        indexes[idx] = indexes[2*idx+2];\n      }\n    }\n  }\n\n  inline T query_value(int left, int right) const { return mem[query_index(left, right)]; }\n\n  inline int query_index(int left, int right) const { return query_index(left, right, 0, 0, mem.size()); }\n\n  int query_index(int left, int right, int i, int a, int b) const\n  {\n    // [a, b) is the range of indexes[i]\n    if (b <= left || right <= a) {\n      // does not intersect\n      return -1;\n    } else if (left <= a && b <= right) {\n      // contains\n      return indexes[i];\n    } else {\n      const int m = (a+b)/2;\n      const int l = query_index(left, right, 2*i+1, a, m);\n      const int r = query_index(left, right, 2*i+2, m, b);\n      if (l == -1) {\n        return r;\n      } else if (r == -1) {\n        return l;\n      } else {\n        if (cmp(mem[l], mem[r])) {\n          return l;\n        } else {\n          return r;\n        }\n      }\n    }\n  }\n\n  void update(int idx, const T& val)\n  {\n    mem[idx] = val;\n    update_index(0, mem.size(), 0, idx);\n  }\n\n  void update_index(int left, int right, int i, int idx)\n  {\n    if (left+1 == right) {\n      //indexes[i] = idx;\n    } else {\n      const int mid = (left+right)/2;\n      if (idx < mid) {\n        update_index(left, mid, 2*i+1, idx);\n      } else {\n        update_index(mid, right, 2*i+2, idx);\n      }\n      if (cmp(mem[indexes[2*i+1]], mem[indexes[2*i+2]])) {\n        indexes[i] = indexes[2*i+1];\n      } else {\n        indexes[i] = indexes[2*i+2];\n      }\n    }\n  }\n};/*}}}*/\n\nint main()\n{\n  int N;\n  cin >> N;\n  vector<long long> mem(N+1, 0);\n  SegmentTree<long long, greater<long long> > segtree(mem);\n  long long sum = 0, a = 0;\n  for (int i = 0; i < N; i++) {\n    int x;\n    cin >> x;\n    sum += x;\n    long long v = segtree.query_value(0, x);\n    a = max(a, v+x);\n    segtree.update(x, v+x);\n  }\n  cout << sum - a << endl;\n  return 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include <iostream>\n#include <vector>\n#include <algorithm>\nusing namespace std;\n\n#define rep(i, n) rep2(i, 0, n)\n#define rep2(i, m, n) for(int i = m; i < (int)(n); ++i)\n\ntypedef long long ll;\n\nint seg_n, n;\nvector<ll> seg;\n\nvoid init(int n) {\n    seg_n = 1;\n    while(seg_n < n) seg_n *= 2;\n    seg.resize(seg_n * 2 - 1);\n}\n\nvoid update(int k, ll a) {\n    k += seg_n - 1;\n    seg[k] = a;\n    while(k > 0) {\n        k = (k - 1) / 2;\n        seg[k] = max(seg[k*2+1], seg[k*2+2]);\n    }\n}\n\nll query(int a, int b, int k, int l, int r) {\n    if(r <= a || b <= l) return 0;\n    if(a <= l && r <= b) return seg[k];\n    ll vl = query(a, b, k * 2 + 1, l, (l + r) / 2);\n    ll vr = query(a, b, k * 2 + 2, (l + r) / 2, r);\n    return max(vl, vr);\n}\n\nll query(int x) { return query(0, x, 0, 0, seg_n); }\n\nint main() {\n    cin >> n;\n    vector<int> x(n);\n    rep(i, n) cin >> x[i];\n    init(n + 1);\n    rep(i, n) update(x[i], query(x[i]) + x[i]);\n    cout << (ll)n * (n + 1) / 2 - query(n + 1) << endl;\n}"
  },
  {
    "language": "C++",
    "code": "#include<iostream>\n#include<algorithm>\n\nusing namespace std;\ntypedef long long ll;\n\nstruct SegTree {\n\tint n = 1 << 18;\n\tll data[1 << 19];\n\t\n\tSegTree() {\n\t\tfor (int i = 0; i < (1 << 19); i++)data[i] = 0;\n\t}\n\n\tvoid set(int pos, ll value) {\n\t\tint a = pos + n - 1;\n\t\tdata[a] = value;\n\t\twhile (a > 0) {\n\t\t\ta = (a - 1) / 2;\n\t\t\tdata[a] = max(data[a * 2 + 1], data[a * 2 + 2]);\n\t\t}\n\t}\n\n\t//[l,r)\n\tll get(int l, int r, int k, int a, int b) {\n\t\tif (a >= r || b <= l)return 0;\n\t\tif (l <= a && b <= r)return data[k];\n\t\telse {\n\t\t\tll v1, v2;\n\t\t\tv1 = get(l, r, k * 2 + 1, a, (a + b) / 2);\n\t\t\tv2 = get(l, r, k * 2 + 2, (a + b) / 2, b);\n\t\t\treturn max(v1, v2);\n\t\t}\n\t}\n\n};\n\nSegTree st;\nll N;\n\nint main() {\n\tcin >> N;\n\tll ans = N * (N + 1) / 2;\n\n\tfor (int i = 0; i < N; i++) {\n\t\tll a;\n\t\tcin >> a;\n\t\tst.set(a, st.get(0, a, 0, 0, 1 << 18) + a);\n\t}\n\n\tans -= st.get(0, (1 << 18), 0, 0, 1 << 18);\n\n\tcout << ans << endl;\n\n\treturn 0;\n}\n"
  },
  {
    "language": "C++",
    "code": "#include<bits/stdc++.h>\nusing namespace std;\ntypedef long long ll;\ntypedef pair<double,int> P;\ntypedef pair<P,ll> T;\ntypedef vector<int> vi;\ntypedef vector<ll> vll;\n#define pb push_back\n#define mp make_pair\n#define eps 1e-15\n#define INF 2000000000\n#define sz(x) ((int)(x).size())\n#define fi first\n#define sec second\n#define all(x) (x).begin(),(x).end()\n#define rep(i,n) for(int (i)=0;(i)<(int)(n);(i)++)\n#define repn(i,a,n) for(int (i)=(a);(i)<(int)(n);(i)++)\n#define EQ(a,b) (abs((a)-(b))<eps)\ntemplate<class T> void chmin(T& a,const T& b){if(a>b)a=b;}\ntemplate<class T> void chmax(T& a,const T& b){if(a<b)a=b;}\nconst int SIZE = 1<<18;\nstruct segtree{\n\tll seg[SIZE*2];\n\tvoid update(int k,ll x){\n\t\tk+=SIZE-1;\n\t\tseg[k]=x;\n\t\twhile(k){\n\t\t\tk = (k-1)/2;\n\t\t\tseg[k]=max(seg[k*2+1],seg[k*2+2]);\n\t\t}\n\t}\n\tll query(int a,int b,int k=0,int l=0,int r=SIZE){\n\t\tif(r<=a||b<=l)return 0;\n\t\telse if(a<=l&&r<=b)return seg[k];\n\t\telse{\n\t\t\tint lch = query(a,b,k*2+1,l,(l+r)/2);\n\t\t\tint rch = query(a,b,k*2+2,(l+r)/2,r);\n\t\t\treturn max(lch,rch);\n\t\t}\n\t}\n}seg;\nint n;\nvector<int> x;\nll dp[100100];\nint main(){\n\tscanf(\"%d\",&n);\n\tx.resize(n);\n\tfor(int i=0;i<n;i++)scanf(\"%d\",&x[i]);\n\tfor(int i=0;i<n;i++){\n\t\tseg.update(x[i],x[i]+seg.query(0,x[i]));\n\t}\n\tcout << (ll)n*(ll)(n+1)/2ll-seg.query(0,SIZE) << endl;\n\treturn 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include<bits/stdc++.h>\n#define MAX (1<<17)\nusing namespace std;\n\ntypedef long long ll;\n\nint n;\nll st[MAX*2]={};\n\nvoid init(){\n  int tmp=1;\n  while(tmp<n)tmp*=2;\n  n=tmp;\n  //for(int i=0;i<n*2;i++)st[i]=0;\n}\n\nvoid update(int k,ll x){\n  k+=n-1;\n  st[k]=x;\n  while(k>0){\n    k=(k-1)/2;\n    st[k]=max(st[k*2+1],st[k*2+2]);\n  }\n}\n\nll find(int a,int b,int k,int l,int r){\n\n  if(r<=a || b<=l)return 0;\n\n  if(a<=l && r<=b)return st[k];\n\n  ll v1=find(a,b,k*2+1,l,(l+r)/2);\n  ll v2=find(a,b,k*2+2,(l+r)/2,r);\n  return max(v1,v2);\n}\n\nint main()\n{\n  ll a,ans=0,m;\n\n  cin>>n;\n\n  m=n;\n  ans=n*(n+1)/2;\n  init();\n\n  for(int i=0;i<m;i++){\n    cin>>a;\n    ll res=find(1,a,0,0,n);\n    update(a,a+res);\n  }\n\n  ans-=find(1,m+1,0,0,n);\n\n  cout<<ans<<endl;\n\n  return 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\n\nusing namespace std;\n\n#define MAX 100010\nconst int MAX_N = 1<<17;\ntypedef long long ll;\n\nclass RMQ{\npublic:\n  ll n,dat[2*MAX_N-1];\n  \n  void init(int n_){\n    n = 1;\n    while(n < n_){ n *= 2; }\n    for(int i = 0 ; i < 2*n-1 ; i++){\n      dat[i] = 0LL;\n    }\n  }\n\n  void update(ll k,ll a){\n    k += n - 1;\n    dat[k] = a;\n    while(k > 0){\n      k = (k - 1) / 2;\n      dat[k] = max(dat[k*2+1],dat[k*2+2]);\n    }\n  }\n\n  ll query(ll a,ll b,ll k,ll l,ll r){\n    if(r <= a || b <= l){ return 0LL; }\n    if(a <= l && r <= b){\n      return dat[k];\n    }else{\n      ll vl = query(a,b,k*2+1,l,(l+r)/2);\n      ll vr = query(a,b,k*2+2,(l+r)/2,r);\n      return max(vl,vr);\n    }\n  }\n};\n\nint main(){\n  ll N,x[MAX],sum = 0LL;\n  cin >> N;\n  for(int i = 0 ; i < N ; i++){\n    cin >> x[i];\n    sum += x[i];\n  }\n  RMQ rmq;\n  rmq.init(N);\n  for(int i = 0 ; i < N ; i++){\n    ll c = rmq.query(1,x[i]+1,0,0,rmq.n);\n    rmq.update(x[i],c+x[i]);\n  }\n  cout << sum-rmq.query(1,N+1,0,0,rmq.n) << endl;\n  return 0;\n}"
  },
  {
    "language": "C++",
    "code": "#ifndef LOCAL\n    #pragma GCC optimize(\"Ofast\")\n#endif\n#include <cassert>\n#include <iostream>\n#include <algorithm>\n#include <functional>\n#include <queue>\n#include <deque>\n#include <stack>\n#include <list>\n#include <set>\n#include <map>\n#include <unordered_set>\n#include <unordered_map>\n#include <complex>\n#include <iomanip>\n#include <bitset>\n#include <random>\n\nusing namespace std;\nusing i64 = int_fast64_t;\nusing db = double;\nusing ldb = long double;\nusing pii = pair<int, int>;\nusing pli = pair<int_fast64_t, int>;\nusing pll = pair<int_fast64_t, int_fast64_t>;\nusing pdi = pair<double, int>;\nusing pdd = pair<double, double>;\ntemplate <class T> using vct = vector<T>;\ntemplate <class T> using heap = priority_queue<T>;\ntemplate <class T> using minheap = priority_queue<T, vector<T>, greater<T>>;\ntemplate <class T> constexpr T inf = numeric_limits<T>::max() / (T)16;\nconstexpr int dx[9] = {1, 0, -1, 0, 1, -1, -1, 1, 0};\nconstexpr int dy[9] = {0, 1, 0, -1, 1, 1, -1, -1, 0};\nconstexpr long double Pi = 3.1415926535897932384626433832795028;\nconstexpr long double Golden = 1.61803398874989484820;\nconstexpr long double eps = 1e-15;\n\n#define iostream_untie true\n#define mod 1000000007LL\n#define stdout_precision 10\n#define stderr_precision 6\n#define itrep(i,v) for(auto i = begin(v); i != end(v); ++i)\n#define ritrep(i,v) for(auto i = rbegin(v); i != rend(v); ++i)\n#define rep(i,n) for(int i = 0; i < (n); ++i)\n#define rrep(i,n) for(int i = (n) - 1; i >= 0; --i)\n#define all(v) begin(v), end(v)\n#define rall(v) rbegin(v), rend(v)\n#define fir first\n#define sec second\n#define u_map unordered_map\n#define u_set unordered_set\n#define l_bnd lower_bound\n#define u_bnd upper_bound\n#define rsz resize\n#define ers erase\n#define emp emplace\n#define emf emplace_front\n#define emb emplace_back\n#define pof pop_front\n#define pob pop_back\n#define mkp make_pair\n#define mkt make_tuple\n#define popcnt __builtin_popcount\n\nnamespace setup {\n    struct setupper {\n        setupper() {\n            if(iostream_untie) {\n                ios::sync_with_stdio(false);\n                std::cin.tie(nullptr);\n                std::cout.tie(nullptr);\n                std::cerr.tie(nullptr);\n            }\n            std::cout << std::fixed << std::setprecision(stdout_precision);\n            std::cerr << std::fixed << std::setprecision(stderr_precision);\n    #ifdef LOCAL\n            if(!freopen(\"input.txt\",\"rt\",stdin)) {\n                std::cerr << \"Failed to open the input file.\\n\"; std::exit(EXIT_FAILURE);\n            }\n            // if(!freopen(\"output.txt\",\"wt\",stdout)) {\n            //     cerr << \"Failed to open the output file.\\n\"; exit(EXIT_FAILURE);\n            // }\n            // std::cerr << \"\\n---stderr---\\n\";\n            // auto print_atexit = []() {\n            //     std::cerr << \"Exec time : \" << clock() / (double)CLOCKS_PER_SEC * 1000.0 << \"ms\\n\";\n            //     std::cerr << \"------------\\n\";\n            // };\n            // atexit((void(*)())print_atexit);\n            // atexit((void(*)())fclose(stdin));\n    #endif\n        }\n    } __setupper;\n}\n\nnamespace std {\n    template <class RAitr> void rsort(RAitr __first, RAitr __last) {\n        sort(__first, __last, greater<>());\n    }\n    template <class T> void hash_combine(size_t &seed, T const &key) {\n        seed ^= hash<T>()(key) + 0x9e3779b9 + (seed << 6) + (seed >> 2);\n    }\n    template <class T, class U> struct hash<pair<T,U>> {\n        size_t operator()(pair<T,U> const &pr) const\n        {\n            size_t seed = 0;\n            hash_combine(seed,pr.first);\n            hash_combine(seed,pr.second);\n            return seed;\n        }\n    };\n    template <class Tup, size_t index = tuple_size<Tup>::value - 1> struct hashval_calc {\n        static void apply(size_t& seed, Tup const& tup) {\n            hashval_calc<Tup, index - 1>::apply(seed, tup);\n            hash_combine(seed,get<index>(tup));\n        }\n    };\n    template <class Tup> struct hashval_calc<Tup,0> {\n        static void apply(size_t& seed, Tup const& tup) {\n            hash_combine(seed,get<0>(tup));\n        }\n    };\n    template <class ...T> struct hash<tuple<T...>> {\n        size_t operator()(tuple<T...> const& tup) const\n        {\n            size_t seed = 0;\n            hashval_calc<tuple<T...>>::apply(seed,tup);\n            return seed;\n        }\n    };\n}\n\ntemplate <class T, class U> istream &operator>> (istream &s, pair<T,U> &p) { return s >> p.first >> p.second; }\ntemplate <class T, class U> ostream &operator<< (ostream &s, const pair<T,U> p) { return s << p.first << \" \" << p.second; }\ntemplate <class T> istream &operator>> (istream &s, vector<T> &v) { for(T &e : v) s >> e; return s; }\ntemplate <class T> ostream &operator<< (ostream &s, const vector<T> &v) {\n    for(size_t i = 0; i < v.size(); ++i) s << (i ? \" \" : \"\") << v[i]; return s;\n}\n#define dump(...) cerr << \" [ \" << __LINE__ << \" : \" << __FUNCTION__ << \" ] \" << #__VA_ARGS__ << \" : \";\\\ndump_func(__VA_ARGS__)\ntemplate <class T> void dump_func(T x) { cerr << x << '\\n'; }\ntemplate <class T,class ...Rest> void dump_func(T x, Rest ... rest) { cerr << x << \",\"; dump_func(rest...); }\ntemplate <class T = i64> T read() { T x; return cin >> x, x; }\ntemplate <class T> void write(T x) { cout << x << '\\n'; }\ntemplate <class T, class ...Rest> void write(T x, Rest ... rest) { cout << x << ' '; write(rest...); }\nvoid writeln() {}\ntemplate <class T, class ...Rest> void writeln(T x, Rest ... rest) { cout << x << '\\n'; writeln(rest...); }\n#define esc(...) writeln(__VA_ARGS__), exit(0)\n\nnamespace updater {\n    template <class T> static void add(T &x, const T &y) { x += y; }\n    template <class T> static void ext_add(T &x, const T &y, size_t w) { x += y * w; }\n    template <class T> static void mul(T &x, const T &y) { x *= y; }\n    template <class T> static void ext_mul(T &x, const T &y, size_t w) { x *= (T)pow(y,w); }\n    template <class T> static bool chmax(T &x, const T &y) { return x < y ? x = y,true : false; }\n    template <class T> static bool chmin(T &x, const T &y) { return x > y ? x = y,true : false; }\n};\nusing updater::add;\nusing updater::chmax;\nusing updater::chmin;\n\ntemplate <class T> constexpr T minf(const T &x, const T &y) { return min(x,y); }\ntemplate <class T> constexpr T maxf(const T &x, const T &y) { return max(x,y); }\nconstexpr bool bit(i64 n, int e) { return (n >> e) & 1; }\nconstexpr int_fast64_t mask(int_fast64_t n, int e) { return n & ((1 << e) - 1); }\nconstexpr int ilog(int_fast64_t x, int_fast64_t b = 2) { return x ? 1 + ilog(x / b, b) : -1; }\ntemplate <class F> int_fast64_t binry(int_fast64_t ok, int_fast64_t ng, const F &fn) {\n    while (abs(ok - ng) > 1) {\n        int_fast64_t mid = (ok + ng) / 2;\n        (fn(mid) ? ok : ng) = mid;\n    }\n    return ok;\n}\ntemplate <class A, size_t N, class T> void init(A (&array)[N], const T &val) { fill((T*)array,(T*)(array + N),val); }\ntemplate <class T> vector<int> cmprs(const vector<T> &v) {\n    vector<T> tmp = v; vector<int> ret;\n    sort(begin(tmp),end(tmp));\n    tmp.erase(unique(begin(tmp),end(tmp)), end(tmp));\n    for(T i : v) ret.emplace_back(lower_bound(begin(tmp),end(tmp),i) - begin(tmp));\n    return ret;\n}\ntemplate <class T> vector<int> cmprs(const T *__first, const T *__last) {\n    return cmprs(vector<T>(__first, __last));\n}\ntemplate <class F> void for_subset(uint_fast64_t s, const F &fn) {\n    uint_fast64_t tmp = s;\n    do { fn(tmp); } while((--tmp &= s) != s);\n}\n\n\n\n/* The main code follows. */\n\ntemplate <class Monoid, class act_t>\nstruct Segtree {\n    using opr_t = function<Monoid(const Monoid&, const Monoid&)>;\n    using update_opr_t = function<void(Monoid&, const act_t&)>;\n    const opr_t opr;\n    const update_opr_t update_opr;\n    const Monoid idel;\n    vector<Monoid> data;\n    const int n;\n    const size_t N;\n\n    constexpr size_t adjust_size(const int32_t n) {\n        for(int i = 29; i >= 0; --i) if(n >> i & 1) return 1 << (i + 1);\n        return 0;\n    }\n\n    Segtree(size_t n_, Monoid idel_, const opr_t &opr_, const update_opr_t &update_opr_)\n        : n(n_),N(adjust_size(n)),opr(opr_),update_opr(update_opr_),idel(idel_)\n    {\n        data.assign(N << 1,idel);\n    }\n\n    template <class P> void copy(P s, P t) {\n        for(size_t i = N; s != t; ++s, ++i) data[i] = *s;\n        for(size_t i = N - 1; i; --i) data[i] = opr(data[i * 2],data[i * 2 + 1]);\n    }\n\n    template <class A> void copy(const A &v) {\n        copy(begin(v),end(v));\n    }\n\n    void update(size_t idx, act_t val) {\n        update_opr(data[idx += N],val);\n        while(idx >>= 1) data[idx] = opr(data[idx * 2],data[idx * 2 + 1]);\n    }\n\n    Monoid query(size_t a, size_t b, bool is_first = true) {\n        if(a >= b) return idel;\n        if(is_first) a += N,b += N;\n        Monoid left = a & 1 ? data[a++] : idel;\n        Monoid right = b & 1 ? data[--b] : idel;\n        return opr(opr(left,query(a >> 1,b >> 1,false)),right);\n    }\n\n    int rightbound(size_t i, const function<bool(Monoid,size_t)> &judge) {\n        if(i >= n) return n; \n        int w = 1, rig = i, j = N << 1;\n        i += N;\n        while(i != j) {\n            if(i & 1) {\n                rig += w;\n                if(!judge(data[i],w)) break;\n                ++i;\n            }\n            i >>= 1, j >>= 1, w <<= 1;\n        }\n        if(i == j) return n;\n        while(w > 1) {\n            if(judge(data[i <<= 1], w >>= 1)) ++i;\n            else rig -= w;\n        }\n        return min(n,--rig);\n    }\n\n    int leftbound(size_t i, const function<bool(Monoid,size_t)> &judge) {\n        if(i < 0) return -1;\n        int w = 1, lef = i, j = N - 1;\n        i += N;\n        while(i != j) {\n            if(i & 1 ^ 1) {\n                lef -= w;\n                if(!judge(data[i],w)) break;\n                --i;\n            } \n            i >>= 1, j >>= 1, w <<= 1;\n        }\n        if(i == j) return -1;\n        while(w > 1) {\n            if(judge(data[++(i <<= 1)], w >>= 1)) --i;\n            else lef += w;\n        }\n        return ++lef;\n    }\n\n    struct sum_lower_bound_opr {\n        Monoid x;\n        sum_lower_bound_opr(Monoid _x) : x(_x) {}\n        bool operator()(Monoid v, size_t w) {\n            return v < x ? x -= v,true : false;\n        }\n    };\n\n    int sum_lower_leftbound(size_t i, Monoid v) {\n        return leftbound(i, sum_lower_bound_opr(v));\n    }\n\n    int sum_lower_rightbound(size_t i, Monoid v) {\n        return rightbound(i, sum_lower_bound_opr(v));\n    }\n\n    struct sum_upper_bound_opr {\n        Monoid x;\n        sum_upper_bound_opr(Monoid _x) : x(_x) {}\n        bool operator()(Monoid v, size_t w) {\n            return v <= x ? x -= v,true : false;\n        }\n    };\n\n    int sum_upper_leftbound(size_t i, Monoid v) {\n        return leftbound(i, sum_upper_bound_opr(v));\n    }\n\n    int sum_upper_rightbound(size_t i, Monoid v) {\n        return rightbound(i, sum_upper_bound_opr(v));\n    }\n};\n\ni64 n;\nint p[1<<17];\n\nsigned main() {\n    cin>>n;\n    Segtree<i64,i64> sg(n,0,maxf<i64>,chmax<i64>);\n    rep(i,n) cin>>p[i];\n    rep(i,n) {\n        sg.update(p[i]-1,p[i]+sg.query(0,p[i]-1));\n    }\n    esc(n*(n+1)/2-sg.query(0,n));\n}\n"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\nusing namespace std;\nusing ll = long long;\n\nconst function<ll(ll, ll)> maxQll = [](ll l, ll r) { return max(l, r); };\n\ntemplate <typename T>\nclass SegmentTree {\n\tusing func_t = function<T(T, T)>;\n\tconst int n;\n\tconst T id;\n\tfunc_t merge;\n\tvector<T> data;\n\tint size(int n) {\n\t\tint res;\n\t\tfor (res = 1; res < n; res <<= 1);\n\t\treturn res;\n\t}\npublic:\n\tSegmentTree(int n_, T id_, func_t merge_) :\n\t\tn(size(n_)), id(id_), merge(merge_), data(size(n_) * 2, id_) {}\n\tvoid Init(const vector<T>& data_) {\n\t\tfor (int i = 0; i < (int)data_.size(); i++)\n\t\t\tdata[i + n] = data_[i];\n\t\tfor (int i = n - 1; i >= 0; i--)\n\t\t\tdata[i] = merge(data[i * 2], data[i * 2 + 1]);\n\t}\n\tvoid Update(int p, T val) {\n\t\tp += n;\n\t\tdata[p] = val;\n\t\twhile (p >>= 1) data[p] = merge(data[p * 2], data[p * 2 + 1]);\n\t}\n\tvoid Add(int p, T val) {\n\t\tp += n;\n\t\tdata[p] += val;\n\t\twhile (p >>= 1) data[p] = merge(data[p * 2], data[p * 2 + 1]);\n\t}\n\tT Find(int i) {\n\t\treturn data[i + n];\n\t}\n\tT Find(int l, int r) {\n\t\tif (r < l) return id;\n\t\tl += n; r += n + 1;\n\t\tT res1 = id, res2 = id;\n\t\twhile (l != r) {\n\t\t\tif (l & 1) res1 = merge(res1, data[l++]);\n\t\t\tif (r & 1) res2 = merge(data[--r], res2);\n\t\t\tl >>= 1; r >>= 1;\n\t\t}\n\t\treturn merge(res1, res2);\n\t}\n};\n\nint main()\n{\n\tcin.sync_with_stdio(false);\n\tint n;\n\tcin >> n;\n\tSegmentTree<ll> st(n, 0, maxQll);\n\tfor (int i = 0, x; i < n; i++) {\n\t\tcin >> x; x--;\n\t\tst.Update(x, st.Find(0, x - 1) + x + 1);\n\t}\n\tcout << (ll)n * (n + 1) / 2 - st.Find(0, n - 1) << endl;\n\treturn 0;\n}"
  },
  {
    "language": "C++",
    "code": "#define  _CRT_SECURE_NO_WARNINGS\n#define _USE_MATH_DEFINES\n\n#pragma comment (linker, \"/STACK:526000000\")\n\n#include \"bits/stdc++.h\"\n\nusing namespace std;\ntypedef string::const_iterator State;\n#define eps 1e-11L\n#define MAX_MOD 1000000007LL\n#define GYAKU 500000004LL\n\n#define MOD 998244353LL\n#define seg_size 262144\n#define pb push_back\n#define mp make_pair\ntypedef long long ll;\n#define REP(a,b) for(long long (a) = 0;(a) < (b);++(a))\n#define ALL(x) (x).begin(),(x).end()\n\nvoid init() {\n    iostream::sync_with_stdio(false);\n    cout << fixed << setprecision(20);\n}\n\n\n#define int ll\n\nunsigned long xor128() {\n    static unsigned long x = 123456789, y = 362436069, z = 521288629, w = 88675123;\n    unsigned long t = (x ^ (x << 11));\n    x = y; y = z; z = w;\n    return (w = (w ^ (w >> 19)) ^ (t ^ (t >> 8)));\n}\n\nint seg_tree[seg_size * 2];\nint seg_find(int now, int n_l, int n_r, int w_l, int w_r) {\n    if (w_l <= n_l && n_r <= w_r) return seg_tree[now];\n    if (w_r <= n_l || n_r <= w_l) return 0;\n    return max(seg_find(now * 2, n_l, (n_l + n_r) / 2, w_l, w_r),\n        seg_find(now * 2 + 1, (n_l + n_r) / 2, n_r, w_l, w_r));\n}\n\nvoid seg_set(int now) {\n    seg_tree[now] = max(seg_tree[now * 2], seg_tree[now * 2 + 1]);\n    if (now > 1) seg_set(now / 2);\n    return;\n}\n\nvoid solve() {\n    int n;\n    cin >> n;\n    vector<int> inputs(n);\n    int ans = 0;\n    REP(i, n) {\n        cin >> inputs[i];\n        ans += inputs[i];\n    }\n    REP(i, n) {\n        seg_tree[(seg_size + inputs[i])] = seg_find(1, 0, seg_size, 0, inputs[i]) + inputs[i];\n        seg_set((seg_size + inputs[i]) / 2);\n    }\n    cout << ans - seg_tree[1] << endl;\n}\n\n#undef int\nint main() {\n    init();\n    solve();\n}\n"
  },
  {
    "language": "C++",
    "code": "#include<iostream>\n#include<cstdio>\n#include<cstdlib>\n#include<cmath>\n#include<algorithm>\n#include<cstring>\n#include<sstream>\n#include<vector>\n#include<queue>\n#include<stack>\n#include<string>\n#include<climits>\n#include<map>\n#include<set>\n#include<cassert>\n#include<deque>\n#define REP(i,s,n) for(int i=s;i<n;i++)\n#define rep(i,n) REP(i,0,n)\n#define INF 1<<27\n#define all(n) n.begin(),n.end()\n#define insert(a,b,c,d) PP(P(a,b),P(c,d))\n#define F first\n#define S second\n#define pb push_back\n#define MAX_N 100100\n#define foreach(i,c) for(iter(c) i=(c).begin();i!=(c).end();++i)\nusing namespace std;\ntypedef pair<int,int> P;\ntypedef pair<P,P> PP;\ntypedef long long ll;\n\n\n\n\n\ntemplate<class T>\nclass RMQ_segment{\nprivate:\n  int n;\n  T dat[2*MAX_N-1];\npublic:\n  void init(int n_){\n    n = 1;\n    while(n<n_)n*=2;\n    for(int i=0;i<2*n-1;i++)dat[i] = 0;\n  }\n\n  void update(int k,T a){\n    k += n-1;\n    dat[k] = a;\n    while(k > 0){\n      k = (k-1)/2;\n      dat[k] = max(dat[k*2+1],dat[k*2+2]);\n    }\n  }\n\n  T query(int a,int b,int k,int l,int r){\n    if(r<=a || b<=l)return 0;\n    else if(a<=l && r<=b)return dat[k];\n    \n      T vl = query(a,b,k*2+1,l,(l+r)/2);\n      T vr = query(a,b,k*2+2,(l+r)/2,r);\n      return max(vl,vr);\n    \n  }\n\n  T _query(int a,int b){//nの範囲でミスしないように極力こっちを利用\n    return query(a,b,0,0,n);\n  }\n\n};\n\n\n int x[1000010];\n RMQ_segment<ll> rmq;\nint main(){\n  int n;\n  cin >> n;\n \n  rmq.init(n+1);\n \n  rep(i,n)cin >> x[i];\n  ll mex=0;\n  ll sum=0;\n\n  for(int i=0;i<n;i++){\n    sum+=x[i];\n    ll premex = rmq._query(0,x[i])+x[i];\n    rmq.update(x[i],premex);\n    mex = max(mex,premex);\n   \n  }  \n  \n  cout << sum-mex << endl;\n\nreturn 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include<iostream>\n#include<algorithm>\n\nusing namespace std;\n\ntypedef long long Int;\n\nInt bit[105000];\n\nvoid setnum(int pos, Int val){\n\twhile(pos < 105000){\n\t\tbit[pos] = max(val, bit[pos]);\n\t\tpos += pos & -pos;\n\t}\n}\n\nInt maxnum(int pos){\n\tInt res = 0;\n\twhile(pos){\n\t\tres = max(res, bit[pos]);\n\t\tpos -= pos &-pos\n\t}\n\treturn res;\n}\n\nint main(){\n\tInt n, sum = 0, x;\n\tcin >> n;\t\n\tfor(int i = 0;i < n;i++){\n\t\tcin >> x;\n\t\tsum += x;\n\t\tInt p = p + maxnum(p);\n\t\tsetnum(x, p);\n\t}\n\tcout << sum - maxnum(10100) << endl;\n\treturn 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\nusing namespace std;\n#define FOR(i,k,n) for(int i = (k); i < (n); i++)\n#define REP(i,n) FOR(i,0,n)\n#define ALL(a) a.begin(), a.end()\n#define MS(m,v) memset(m,v,sizeof(m))\n#define D10 fixed<<setprecision(10)\ntypedef long long ll;\ntypedef long double ld;\ntypedef vector<ll> vi;\ntypedef vector<string> vs;\ntypedef pair<int, int> pii;\nconst int MOD = 1000000007;\nconst int INF = MOD + 1;\nconst ld EPS = 1e-12;\ntemplate<class T> T &chmin(T &a, const T &b) { return a = min(a, b); }\ntemplate<class T> T &chmax(T &a, const T &b) { return a = max(a, b); }\n\n/*--------------------template--------------------*/\nstruct Data\n{\n\tll num;\n\tData() :num(INF) {};\n\tData(ll n) :num(n) {};\n};\n\nstruct SegmentTree\n{\n\tll n; vector<Data> data;\n\tSegmentTree(ll N)\n\t{\n\t\tn = 1;\n\t\twhile (n < N) n *= 2;\n\t\tdata.resize(2 * n);\n\t}\nprivate:\n\tData sub(ll left, ll right, ll node, ll nleft, ll nright)\n\t{\n\t\tif (nright <= left || right <= nleft) return Data();\n\t\tif (left <= nleft && nright <= right) return data[node];\n\t\tData vl = sub(left, right, node * 2 + 1, nleft, (nleft + nright) / 2);\n\t\tData vr = sub(left, right, node * 2 + 2, (nleft + nright) / 2, nright);\n\t\treturn min(vl.num, vr.num);\n\t}\n\npublic:\n\tvoid update(ll pos, Data value)\n\t{\n\t\tpos += n - 1;\n\t\tdata[pos] = value;\n\t\twhile (pos > 0)\n\t\t{\n\t\t\tpos = (pos - 1) / 2;\n\t\t\tdata[pos] = min(data[pos * 2 + 1].num, data[pos * 2 + 2].num);\n\t\t}\n\t}\n\tData min_query(ll left, ll right)\n\t{\n\t\treturn sub(left, right, 0, 0, n);\n\t}\n};\n\n\n\nint main()\n{\n\tll n;\n\tcin >> n;\n\tSegmentTree seg(n);\n\tREP(i, n) seg.update(i, 0);\n\tREP(i, n)\n\t{\n\t\tll a;\n\t\tcin >> a;\n\t\tll val = seg.min_query(0, a).num - a;\n\t\tseg.update(a-1, val);\n\t}\n\tcout << n*(n + 1) / 2 + seg.min_query(0, n).num << endl;\n\treturn 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include <iostream>\n#include <iomanip>\n#include <string>\n#include <sstream>\n#include <algorithm>\n#include <vector>\n#include <utility>\n#include <stack>\n#include <queue>\n#include <map>\n#include <set>\n#include <functional>\n#include <cstdio>\n#include <cstdlib>\n#include <cstring>\n#include <cmath>\n#include <cassert>\n \nusing namespace std;\n \n#define REP(i,s,e) for(int i=(s); i<(int)(e); i++)\n#define rep(i,n) REP(i, 0, n)\n#define pb push_back\n#define mp make_pair\n#define all(r) (r).begin(),(r).end()\n#define rall(r) (r).rbegin(),(r).rend()\n#define fi first\n#define se second\n#define DBG(X) cout<<\" \"<<#X<<\" : \"<<X<<endl\n \ntypedef long long ll;\ntypedef vector<int> vi;\ntypedef vector<ll> vl;\ntypedef pair<int, int> pii;\n\nconst int INF = 1e9;\nconst double EPS = 1e-8;\nconst int mod = 1e9 + 7;\nconst ll LINF = 1e18;\n\nstruct Input\n{\n\tint n;char c;char str[1024];string s;ll l;\n\tint nextInt(){scanf(\"%d\", &n);return n;}\n\tll nextLong(){scanf(\"%lld\", &l);return l;}\n\tchar nextChar(){scanf(\"%c\", &c);return c;}\n\tstring next(){scanf(\"%s\", str);return string(str);}\n\tstring nextLine(){getline(cin, s);return s;}\n};\nInput in;\n\n\tconst int MX = 1<< 17;\n\tll dat[2 * MX - 1];\nstruct SegTree{\n\tint n;\n\tvoid init(int n_){\n\t\tn = 1;\n\t\twhile(n < n_) n *= 2;\n\n\t\trep(i, 2 * n -1) dat[i] = 0LL;\n\t}\n\tvoid update(int k, ll a){\n\t\tk += n-1;\n\t\tdat[k] = a;\n\t\twhile(k > 0){\n\t\t\tk = (k - 1) / 2;\n\t\t\tdat[k] = max(dat[k * 2 + 1], dat[k * 2 + 2]);\n\t\t}\n\t}\n\tll query(int a, int b, int k, int l, int r){\n\t\tif(r <= a || b <= l) return 0LL;\n\t\tif(a <= l && r <= b) return dat[k];\n\t\tll vl = query(a, b, k * 2 + 1, l, (l + r) / 2);\n\t\tll vr = query(a, b, k * 2 + 2, (l + r) / 2, r);\n\t\treturn max(vl, vr);\n\t}\n\tll query(int a, int b){\n\t\treturn query(a, b, 0, 0, n);\n\t}\n};\n\nint main(){\n\tint n = in.nextInt();\n\tSegTree st;\n\tst.init(n);\n\n\trep(i, n){\n\t\tint x = in.nextInt();\n\t\tll c = st.query(0, x);\n\t\tst.update(x-1, x + c);\n\t}\n\tcout<<(ll)n * (n + 1) / 2LL - st.query(0, n)<<endl;\n}"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\nusing namespace std;\n\n#define max(a,b) ((a)>(b)?(a):(b))\n#define min(a,b) ((a)<(b)?(a):(b))\n#define abs(a) max((a),-(a))\n#define rep(i,n) for(int i=0;i<(int)(n);i++)\n#define repe(i,n) rep(i,(n)+1)\n#define per(i,n) for(int i=(int)(n)-1;i>=0;i--)\n#define pere(i,n) rep(i,(n)+1)\n#define all(x) (x).begin(),(x).end()\n#define SP <<\" \"<<\n#define RET return 0\n#define MOD 1000000007\n#define INF 1000000000000000000\n\ntypedef long long LL;\ntypedef long double LD;\n\nstruct SegmentTree {\nprivate:\n  int n;\n  vector<LL> node;\n\npublic:\n  SegmentTree(int sz) {\n      n = 1; while(n < sz) n *= 2;\n      node.resize(2*n-1, 0);\n  }\n  LL getmax(int x) {\n    x += (n - 1);\n    LL ans=node[x];\n    while(x > 0) {\n        x = (x - 1) / 2;\n        ans=max(ans,node[x]);\n    }\n  }\n  void update(int a, int b, LL val, int k=0, int l=0, int r=-1) {\n    if(r < 0) r = n;\n    if(r <= a || b <= l) return;\n    if(a <= l && r <= b){\n      node[k]=max(node[k],val);\n    }else{\n      update(a, b, val, 2*k+1, l, (l+r)/2);\n      update(a, b, val, 2*k+2, (l+r)/2, r);\n    }\n  }\n};\n\nint main(){\n  int n;\n  cin >> n;\n  vector<LL> x(n),id(n);\n  vector<pair<int,int>> xs(n);\n  LL total=0;\n  for(int i=0;i<n;i++){\n    cin >> x[i];\n    xs[i]={x[i],i};\n    total+=x[i];\n  }\n  sort(all(xs));\n  for(int i=0;i<n;i++){\n    id[xs[i].second]=i;\n  }\n  SegmentTree seg(n);\n  LL now;\n  for(int i=0;i<n;i++){\n    now=seg.getmax(id[i]);\n    seg.update(id[i],n,now+x[i]);\n  }\n  cout << total-seg.getmax(n-1) << endl;\n  return 0;\n}\n\n"
  },
  {
    "language": "C++",
    "code": "#include<bits/stdc++.h>\n\nusing namespace std;\n#define INFS (1LL<<28)\n#define DEKAI 1000000007\n#define INF 1000000007\n//#define MOD 1000000007\n#define lp(i,n) for(int i=0;i<n;i++)\n#define lps(i,n) for(int i=1;i<=n;i++)\n#define all(c) begin(c), end(c)\n\n//#define int long long \n\nnamespace {\n\t#define __DECLARE__(C)    \\\n\t    template <typename T> \\\n\tstd::ostream &operator<<(std::ostream &, const C<T> &);\n\n\t#define __DECLAREM__(C)               \\\n\t    template <typename T, typename U> \\\n\tstd::ostream &operator<<(std::ostream &, const C<T, U> &);\n\n\t__DECLARE__(std::vector)\n\t__DECLARE__(std::deque)\n\t__DECLARE__(std::set)\n\t__DECLARE__(std::stack)\n\t__DECLARE__(std::queue)\n\t__DECLARE__(std::priority_queue)\n\t__DECLARE__(std::unordered_set)\n\t__DECLAREM__(std::map)\n\t__DECLAREM__(std::unordered_map)\n\n\ttemplate <typename T, typename U>\n\tstd::ostream &operator<<(std::ostream &, const std::pair<T, U> &);\n\ttemplate <typename... T>\n\tstd::ostream &operator<<(std::ostream &, const std::tuple<T...> &);\n\ttemplate <typename T, std::size_t N>\n\tstd::ostream &operator<<(std::ostream &, const std::array<T, N> &);\n\n\ttemplate <typename Tuple, std::size_t N>\n\tstruct __TuplePrinter__ {\n\t\tstatic void print(std::ostream &os, const Tuple &t) {\n\t\t\t__TuplePrinter__<Tuple, N - 1>::print(os, t);\n\t\t\tos << \", \" << std::get<N - 1>(t);\n\t\t}\n\t};\n\n\ttemplate <typename Tuple>\n\tstruct __TuplePrinter__<Tuple, 1> {\n\t\tstatic void print(std::ostream &os, const Tuple &t) { os << std::get<0>(t); }\n\t};\n\n\ttemplate <typename... T>\n\tstd::ostream &operator<<(std::ostream &os, const std::tuple<T...> &t) {\n\t\tos << '(';\n\t\t__TuplePrinter__<decltype(t), sizeof...(T)>::print(os, t);\n\t\tos << ')';\n\t\treturn os;\n\t}\n\n\ttemplate <typename T, typename U>\n\tstd::ostream &operator<<(std::ostream &os, const std::pair<T, U> &v) {\n\t\treturn os << '(' << v.first << \", \" << v.second << ')';\n\t}\n\n\t#define __INNER__                             \\\n\tos << '[';                                \\\n\tfor (auto it = begin(c); it != end(c);) { \\\n\t\tos << *it;                            \\\n\t\tos << (++it != end(c) ? \", \" : \"\");   \\\n\t}                                         \\\n\treturn os << ']';\n\n\ttemplate <typename T, std::size_t N>\n\tstd::ostream &operator<<(std::ostream &os, const std::array<T, N> &c) {\n\t\t__INNER__\n\t}\n\n\t#define __DEFINE__(C)                                           \\\n\t    template <typename T>                                       \\\n\tstd::ostream &operator<<(std::ostream &os, const C<T> &c) { \\\n\t\t__INNER__                                               \\\n\t}\n\n\t#define __DEFINEM__(C)                                             \\\n\t    template <typename T, typename U>                              \\\n\tstd::ostream &operator<<(std::ostream &os, const C<T, U> &c) { \\\n\t\t__INNER__                                                  \\\n\t}\n\n\t#define __DEFINEW__(C, M1, M2)                                  \\\n\t    template <typename T>                                       \\\n\tstd::ostream &operator<<(std::ostream &os, const C<T> &c) { \\\n\t\tstd::deque<T> v;                                        \\\n\t\tfor (auto d = c; !d.empty(); d.pop()) v.M1(d.M2());     \\\n\t\t\treturn os << v;                                         \\\n\t}\n\n\t__DEFINE__(std::vector)\n\t__DEFINE__(std::deque)\n\t__DEFINE__(std::set)\n\t__DEFINEW__(std::stack, push_front, top)\n\t__DEFINEW__(std::queue, push_back, front)\n\t__DEFINEW__(std::priority_queue, push_front, top)\n\t__DEFINE__(std::unordered_set)\n\t__DEFINEM__(std::map)\n\t__DEFINEM__(std::unordered_map)\n}\n\n#define pii pair<int,int>\n#define ll long long\ninline ll gcd(ll a, ll b) { return b ? gcd(b, a % b) : a; }\ninline ll lcm(ll a, ll b) { return a / gcd(a, b) * b; }\n\n// modint \ntemplate <signed M, unsigned T>\nstruct mod_int {\n\tconstexpr static signed MODULO = M;\n\tconstexpr static unsigned TABLE_SIZE = T;\n\n\tsigned x;\n\n\tmod_int() : x(0) {}\n\n\tmod_int(long long y) : x(static_cast<signed>(y >= 0 ? y % MODULO : MODULO - (-y) % MODULO)) {}\n\n\tmod_int(int y) : x(y >= 0 ? y % MODULO : MODULO - (-y) % MODULO) {}\n\n\tmod_int &operator+=(const mod_int &rhs) {\n\t\tif ((x += rhs.x) >= MODULO) x -= MODULO;\n\t\treturn *this;\n\t}\n\n\tmod_int &operator-=(const mod_int &rhs) {\n\t\tif ((x += MODULO - rhs.x) >= MODULO) x -= MODULO;\n\t\treturn *this;\n\t}\n\n\tmod_int &operator*=(const mod_int &rhs) {\n\t\tx = static_cast<signed>(1LL * x * rhs.x % MODULO);\n\t\treturn *this;\n\t}\n\n\tmod_int &operator/=(const mod_int &rhs) {\n\t\tx = static_cast<signed>((1LL * x * rhs.inv().x) % MODULO);\n\t\treturn *this;\n\t}\n\n\tmod_int operator-() const { return mod_int(-x); }\n\n\tmod_int operator+(const mod_int &rhs) const { return mod_int(*this) += rhs; }\n\n\tmod_int operator-(const mod_int &rhs) const { return mod_int(*this) -= rhs; }\n\n\tmod_int operator*(const mod_int &rhs) const { return mod_int(*this) *= rhs; }\n\n\tmod_int operator/(const mod_int &rhs) const { return mod_int(*this) /= rhs; }\n\n\tbool operator<(const mod_int &rhs) const { return x < rhs.x; }\n\n\tmod_int inv() const {\n\t\tassert(x != 0);\n\t\tif (x <= static_cast<signed>(TABLE_SIZE)) {\n\t\t\tif (_inv[1].x == 0) prepare();\n\t\t\treturn _inv[x];\n\t\t} else {\n\t\t\tsigned a = x, b = MODULO, u = 1, v = 0, t;\n\t\t\twhile (b) {\n\t\t\t\tt = a / b;\n\t\t\t\ta -= t * b;\n\t\t\t\tstd::swap(a, b);\n\t\t\t\tu -= t * v;\n\t\t\t\tstd::swap(u, v);\n\t\t\t}\n\t\t\treturn mod_int(u);\n\t\t}\n\t}\n\n\tmod_int pow(long long t) const {\n\t\tassert(!(x == 0 && t == 0));\n\t\tmod_int e = *this, res = mod_int(1);\n\t\tfor (; t; e *= e, t >>= 1)\n\t\t\tif (t & 1) res *= e;\n\t\treturn res;\n\t}\n\n\tmod_int fact() {\n\t\tif (_fact[0].x == 0) prepare();\n\t\treturn _fact[x];\n\t}\n\n\tmod_int inv_fact() {\n\t\tif (_fact[0].x == 0) prepare();\n\t\treturn _inv_fact[x];\n\t}\n\n\tmod_int choose(mod_int y) {\n\t\tassert(y.x <= x);\n\t\treturn this->fact() * y.inv_fact() * mod_int(x - y.x).inv_fact();\n\t}\n\n\tstatic mod_int _inv[TABLE_SIZE + 1];\n\n\tstatic mod_int _fact[TABLE_SIZE + 1];\n\n\tstatic mod_int _inv_fact[TABLE_SIZE + 1];\n\n\tstatic void prepare() {\n\t\t_inv[1] = 1;\n\t\tfor (int i = 2; i <= (int)TABLE_SIZE; ++i) {\n\t\t\t_inv[i] = 1LL * _inv[MODULO % i].x * (MODULO - MODULO / i) % MODULO;\n\t\t}\n\t\t_fact[0] = 1;\n\t\tfor (unsigned i = 1; i <= TABLE_SIZE; ++i) {\n\t\t\t_fact[i] = _fact[i - 1] * int(i);\n\t\t}\n\t\t_inv_fact[TABLE_SIZE] = _fact[TABLE_SIZE].inv();\n\t\tfor (int i = (int)TABLE_SIZE - 1; i >= 0; --i) {\n\t\t\t_inv_fact[i] = _inv_fact[i + 1] * (i + 1);\n\t\t}\n\t}\n};\n\ntemplate <int M, unsigned F>\nstd::ostream &operator<<(std::ostream &os, const mod_int<M, F> &rhs) {\n\treturn os << rhs.x;\n}\n\ntemplate <int M, unsigned F>\nstd::istream &operator>>(std::istream &is, mod_int<M, F> &rhs) {\n\tlong long s;\n\tis >> s;\n\trhs = mod_int<M, F>(s);\n\treturn is;\n}\n\ntemplate <int M, unsigned F>\nmod_int<M, F> mod_int<M, F>::_inv[TABLE_SIZE + 1];\n\ntemplate <int M, unsigned F>\nmod_int<M, F> mod_int<M, F>::_fact[TABLE_SIZE + 1];\n\ntemplate <int M, unsigned F>\nmod_int<M, F> mod_int<M, F>::_inv_fact[TABLE_SIZE + 1];\n\ntemplate <int M, unsigned F>\nbool operator==(const mod_int<M, F> &lhs, const mod_int<M, F> &rhs) {\n\treturn lhs.x == rhs.x;\n}\n\ntemplate <int M, unsigned F>\nbool operator!=(const mod_int<M, F> &lhs, const mod_int<M, F> &rhs) {\n\treturn !(lhs == rhs);\n}\n\nconst int MF = 1000010;\nconst int MOD = 1000000007;\n\nusing mint = mod_int<MOD, MF>;\n\nmint binom(int n, int r) { return (r < 0 || r > n || n < 0) ? 0 : mint(n).choose(r); }\n\nmint fact(int n) { return mint(n).fact(); }\n\nmint inv_fact(int n) { return mint(n).inv_fact(); }\nconst ll mod = 1000000007;\nconst int MAX_N = 10000;  // 400MB\n// const int MAX_N = 1024; // 4MB\n// nCr % mod\n\n#define int long long\n#define double long double \n\ninline ll gcds(ll a, ll b) { return b ? gcds(b, a % b) : a; }\n\n#define RK 200000000000\n#define LK 300000000000\n#define PL 400000000000\n#define MI 500000000000\n#define KA 600000000000\n\n\nstruct RMQ{\n  static const int MAX_N = 1 << 17;\n  int n,dat[2*MAX_N-1];\n  RMQ(){}\n  RMQ(int n_){init(n_);}\n  void init(int n_){\n    n=1;\n    while(n<n_) n*=2;\n    for(int i=0;i<2*n-1;i++) dat[i]=INT_MAX;\n  }\n  void update(int k,int a){\n    k+=n-1;\n    dat[k]=a;\n    while(k>0){\n      k=(k-1)/2;\n      dat[k]=min(dat[k*2+1],dat[k*2+2]);\n    }\n  }\n  int query(int a,int b,int k,int l,int r){\n    if(r<=a||b<=l) return INT_MAX;\n    if(a<=l&&r<=b) return dat[k];\n    else{\n      int vl=query(a,b,k*2+1,l,(l+r)/2);\n      int vr=query(a,b,k*2+2,(l+r)/2,r);\n      return min(vl,vr);\n    }\n  }\n  int query(int a,int b){\n    return query(a,b,0,0,n);\n  }\n};\n\n\tRMQ rmq(120000);\nsigned main(){\n\tint n;\n\tcin>>n;\n\tvector<int> v(n);\n\tint sum=0;\n\tlp(i,n){\n\t\tcin>>v[i];\n\t\tsum+=v[i];\n\t}\n\tint ans=-1;\n\tlp(i,120000){\n\t\trmq.update(i,0);\n\t}\n\tlp(i,n){\n\t\tint maxi=rmq.query(0,v[i]);\n\t\tmaxi*=-1;\n\t\t//cout<<maxi+v[i]<<endl;\n\t\tans=max(ans,maxi+v[i]);\n\t\trmq.update(v[i],(maxi+v[i])*-1);\n\t}\n\tcout<<sum-ans<<endl;\n\treturn 0;\n}\n"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\nusing namespace std;\n\n#define REP(i,n) for(int i=0;i<(int)n;++i)\n#define FOR(i,c) for(__typeof((c).begin())i=(c).begin();i!=(c).end();++i)\n#define ALL(c) (c).begin(), (c).end()\n\nclass RMQ{\nprivate:\n    static const int MAX_N = 1 << 17;\n    int n;\n    long long dat[2*MAX_N -1];\n    long long rec(int a,int b,int k,int l,int r){\n        if(b <= l || r <= a){\n            return 0;\n        }\n        \n        if(a<=l && r<=b){\n            return dat[k];\n        }else{\n            long long rl = rec(a,b,2*k+1,l,(l+r)/2);\n            long long rr = rec(a,b,2*k+2,(l+r)/2,r);\n            return max(rl,rr);\n        }\n    }\n    \npublic:\n    void init(int n_){\n        n=1;\n        while(n < n_) n <<= 1;\n        \n        for(int i=0;i<2*n-1;i++){\n            dat[i] = 0;\n        }\n    }\n    void update(int k, long long a){\n        int reaf = k+n-1;\n        dat[reaf]=a;\n        while(reaf>0){\n            reaf = (reaf-1)>>1;\n            dat[reaf]=max(dat[reaf*2+1],dat[2*reaf+2]);\n        }\n    }\n    long long query(int a,int b){\n        return rec(a,b+1,0,0,n);\n    }\n};\n\nint a[100010], ind[100010];\n\nint main(){\n    while (true) {\n        int n;\n        cin >> n;\n        if (!n) return 0;\n        \n        long long m = n * (long long)(n + 1) / 2;\n        for (int i = 0; i < n; ++i) {\n            cin >> a[i];\n            ind[a[i] - 1] = i;\n        }\n        RMQ r;\n        r.init(n);\n        for (int i = 0; i < n; ++i) {\n            r.update(ind[i], r.query(0, ind[i]) + i + 1);\n        }\n        cout << m - r.query(0, n) << \"\\n\";\n        \n        return 0;\n    }\n    return 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include <iostream>\n#include <algorithm>\n\nusing namespace std;\n\n#define ll long long\n#define rep(a,b) for(int a = 0; a < b; a++)\n\nint n;\nll dp[100001*2];\nint arr[100000];\nint size = 1;\n\nvoid update(int index, ll num) {\n  index += size-1;\n  dp[index] = num;\n  //cout << \"  \" << index << \",\" << dp[index] << endl;\n  while(index>0) {\n    int new_index = (index-1)>>1;\n    dp[new_index] = max(dp[(new_index<<1)+1],dp[(new_index<<1)+2]);\n    //cout << \"  \" << new_index << \",\" << dp[new_index] << endl;\n    index = new_index;\n  }\n  //dp[index] = max(dp[index],dp[index^1]);\n}\n\nll get_max(int a, int b, int k, int left, int right) {\n  //cout << \"gmax \" << a << \",\" << b << \",\" << k << \",\" << left << \",\" << right << endl;\n  if(right<a||b<=left||right<=left) return 0;\n  if(a<=left&&right<=b) {\n    //cout << \"OK \" << dp[k] << endl;\n    return dp[k];\n  }\n  ll ret = 0;\n  ret = max(ret,get_max(a,b,(k<<1)+1,left,(left+right)>>1));\n  ret = max(ret,get_max(a,b,(k<<1)+2,(left+right+1)>>1,right));\n  return ret;\n}\n\nint main() {\n  cin >> n;\n  for(int i = 1; i < n; i<<=1) size<<=1;\n  rep(i,n) cin >> arr[i];\n  rep(i,n) {\n    int num = arr[i];\n    ll _max = get_max(1,num,0,0,size);\n    //cout << num << \",\" << _max << endl;\n    update(num,_max+num);\n  }\n  ll ans = (ll)n;\n  ans = n*(n+1)/2;\n  //for(int i = 0; i < size<<1; i++) cout << dp[i] << endl;\n  cout << ans-dp[0] << endl;\n}\n\n"
  },
  {
    "language": "C++",
    "code": "#include<stdio.h>\n\nint main(void)\n{\n  \n  int number;\n  int array[10*10*10*10*10];\n  int i = 0;\n  int j;\n  int hp = 0;\n  int totalhp = 0;\n  int temp;\n\n  scanf(\"%d\",&number);\n\n  for(i=0;i<number;i++){\n    scanf(\"%d\",&array[i]);\n  }\n\n  i = 0;\n\n  while(i < number-1){\n    if(array[i] > array[i+1]){\n      for(j=i;j<number;j++){\n\tif(array[j+1]-array[j] == 1 || j == number-1){\n\t  if(hp > array[j])\n\t    totalhp += array[j];\n\t  else \n\t    totalhp += hp;\n\t  i = 0;\n\t  hp = 0;\n\t  break;\n\t}\n\telse{\n\t  hp += array[j+1];\n\t  temp = array[j];\n\t  array[j] = array[j+1];\n\t  array[j+1] = temp;\n\t}\n      }\t\n    }\n    else \n      i++;\n  }\n\n  printf(\"%d\\n\",totalhp);\n  \n  return 0; \n  \n}\n "
  },
  {
    "language": "C++",
    "code": "#include<bits/stdc++.h>\nusing namespace std;\n#define INF 2147483647\n#define MAX_N 100000\n#define MAX_Q 100000\n\n\nlong long n, q;\nlong long dat[MAX_N*4];\n\n//すべてのノードを0で初期化\nvoid init(){\n    for(int i = 0; i < 2*n - 1; i++) dat[i] = 0;\n}\n\n\n//a[i] を x に変更\nvoid update(int i, long long x){\n    i += n - 1;\n    dat[i] = x;\n\n    //登りながら探索\n    while(i > 0){\n        i = (i - 1) / 2;\n        dat[i] = max(dat[2*i + 1], dat[2*i + 2]);\n    }\n}\n\n\n//区間[a, b)の最大値を返す\nlong long find(int a, int b, int k, int l, int r){\n    if(r <= a || b <= l) return 0;\n    else if(a <= l && r <= b) return dat[k];\n    else{\n        long long vl = find(a, b, k * 2 + 1, l, (l + r)/2);\n        long long vr = find(a, b, k * 2 + 2, (l + r)/2, r);\n        return max(vl, vr);\n    }\n}\n\nint main(){\n\n    cin >> q;\n    n = q;\n    n++;\n    vector<long long> dp(q + 1, 0);\n    vector<int> POW(20);\n    POW[0] = 1;\n\n    for(int i = 1; i < 20; i++){\n        POW[i] = POW[i-1]*2;\n    }\n\n    //n以上n^2っぽいなにかと置換\n    n = *lower_bound(POW.begin(), POW.end(), n);\n    init();\n\n    for(int i = 0; i < q; i++){\n        long long x; cin >> x;\n\n        long long Max = find(0, x, 0, 0, n);\n        dp[x] = max(dp[x], Max + x);\n        update(x, dp[x]);\n        \n        //cout << x << \" \" << Max << \" \" << dp[x] << endl;\n    }\n\n    long long ans = 0;\n    for(int i = 1; i <= q; i++) ans = max(ans, dp[i]);\n    ans = -ans;\n    for(int i = 1; i <= q; i++) ans += (long long)i;\n    \n    cout << ans << endl;\n    \n    return 0;\n}\n"
  },
  {
    "language": "C++",
    "code": "#include <iostream>\n#include <algorithm>\n#include <vector>\n#include <cstdio>\n#include <climits>\nusing namespace std;\n\nlong long bit[100010] = {};\n\nvoid add(int x,long long v){\n\tfor(int i = x ; i < 100010 ; i += i & -i ){\n\t\tbit[i] = max(bit[i],v);\n\t}\n}\n\nlong long get(int x){\n\tlong long ans = 0;\n\tfor(int i = x ; i > 0 ; i -= i & -i ){\n\t\tans = max(bit[i],ans);\n\t}\n\treturn ans;\n}\n\nint main(){\n\tint n;\n\tcin >> n;\n\tlong long ans = 0;\n\tfor(int i = 0 ; i < n ; i++){\n\t\tint a;\n\t\tcin >> a;\n\t\tadd(a,get(a)+a);\n\t}\n\tcout << 1ll*n*(n+1) / 2 - get(100001) << endl;\n}"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\nusing namespace std;\n\ntypedef long long int ll;\n\nint main() {\n    int N;\n    cin >> N;\n\n    ll ans = 0LL;\n    vector<int> index(N+1);\n    for (int i = 1; i <= N; i++) {\n        int n; cin >> n; n;\n        index[n] = i;\n    }\n\n    vector<int> place(N + 1, 10000000);\n    vector<ll> total(N + 1);\n    place[0] = 0;\n    place[1] = index[1];\n    total[1] = 1LL;\n    for (int i = 2; i <= N; i++) total[i] = (ll)(i) + total[i-1];\n\n    for (int i = 2; i <= N; i++) {\n        int iter = lower_bound(place.begin(), place.end(), index[i]) - place.begin();\n        place[i] = max(index[i], place[i-1]);\n        if (iter < i)\n            ans += min(total[i-1] - total[iter-1], (ll)(i));\n    }\n\n    cout << ans << endl;\n\n    return 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\nusing namespace std;\n#define FOR(i,k,n) for(int i = (k); i < (n); i++)\n#define REP(i,n) FOR(i,0,n)\n#define ALL(a) a.begin(), a.end()\n#define MS(m,v) memset(m,v,sizeof(m))\n#define D10 fixed<<setprecision(10)\ntypedef long long ll;\ntypedef long double ld;\ntypedef vector<int> vi;\ntypedef vector<string> vs;\ntypedef pair<int, int> pii;\nconst int MOD = 1000000007;\nconst int INF = MOD + 1;\nconst ld EPS = 1e-12;\ntemplate<class T> T &chmin(T &a, const T &b) { return a = min(a, b); }\ntemplate<class T> T &chmax(T &a, const T &b) { return a = max(a, b); }\n\n/*--------------------template--------------------*/\nstruct Data\n{\n\tll num;\n\tData() :num(INF) {};\n\tData(int n) :num(n) {};\n};\n\nstruct SegmentTree\n{\n\tint n; vector<Data> data;\n\tSegmentTree(int N)\n\t{\n\t\tn = 1;\n\t\twhile (n < N) n *= 2;\n\t\tdata.resize(2 * n);\n\t}\nprivate:\n\tData sub(int left, int right, int node, int nleft, int nright)\n\t{\n\t\tif (nright <= left || right <= nleft) return Data();\n\t\tif (left <= nleft && nright <= right) return data[node];\n\t\tData vl = sub(left, right, node * 2 + 1, nleft, (nleft + nright) / 2);\n\t\tData vr = sub(left, right, node * 2 + 2, (nleft + nright) / 2, nright);\n\t\treturn min(vl.num, vr.num);\n\t}\n\npublic:\n\tvoid update(int pos, Data value)\n\t{\n\t\tpos += n - 1;\n\t\tdata[pos] = value;\n\t\twhile (pos > 0)\n\t\t{\n\t\t\tpos = (pos - 1) / 2;\n\t\t\tdata[pos] = min(data[pos * 2 + 1].num, data[pos * 2 + 2].num);\n\t\t}\n\t}\n\tData min_query(int left, int right)\n\t{\n\t\treturn sub(left, right, 0, 0, n);\n\t}\n};\n\n\n\nint main()\n{\n\tll n;\n\tcin >> n;\n\tSegmentTree seg(n);\n\tREP(i, n) seg.update(i, 0);\n\tREP(i, n)\n\t{\n\t\tll a;\n\t\tcin >> a;\n\t\tll val = seg.min_query(0, a).num - a;\n\t\tseg.update(a-1, val);\n\t}\n\tcout << n*(n + 1) / 2 + seg.min_query(0, n).num << endl;\n\treturn 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include<iostream>\n#include<cstdio>\n#include<cstdlib>\n#include<cmath>\n#include<algorithm>\n#include<cstring>\n#include<sstream>\n#include<vector>\n#include<queue>\n#include<stack>\n#include<string>\n#include<climits>\n#include<map>\n#include<set>\n#include<cassert>\n#include<deque>\n#define REP(i,s,n) for(int i=s;i<n;i++)\n#define rep(i,n) REP(i,0,n)\n#define INF 1<<27\n#define all(n) n.begin(),n.end()\n#define insert(a,b,c,d) PP(P(a,b),P(c,d))\n#define F first\n#define S second\n#define pb push_back\n#define MAX_N 100100\n#define foreach(i,c) for(iter(c) i=(c).begin();i!=(c).end();++i)\nusing namespace std;\ntypedef pair<int,int> P;\ntypedef pair<P,P> PP;\ntypedef long long ll;\n\n\n\n\n\ntemplate<class T>\nclass RMQ_segment{\nprivate:\n  int n;\n  T dat[2*MAX_N-1];\npublic:\n  void init(int n_){\n    n = 1;\n    while(n<n_)n*=2;\n    for(int i=0;i<2*n-1;i++)dat[i] = 0;\n  }\n\n  void update(int k,T a){\n    k += n-1;\n    dat[k] = a;\n    while(k > 0){\n      k = (k-1)/2;\n      dat[k] = max(dat[k*2+1],dat[k*2+2]);\n    }\n  }\n\n  T query(int a,int b,int k,int l,int r){\n    if(r<=a || b<=l)return 0;\n    else if(a<=l && r<=b)return dat[k];\n    \n      T vl = query(a,b,k*2+1,l,(l+r)/2);\n      T vr = query(a,b,k*2+2,(l+r)/2,r);\n      return max(vl,vr);\n    \n  }\n\n  T _query(int a,int b){//nの範囲でミスしないように極力こっちを利用\n    return query(a,b,0,0,n);\n  }\n\n};\n\n\n int x[1000010];\n RMQ_segment<ll> rmq;\nint main(){\n  int n;\n  cin >> n;\n \n  rmq.init(n+1);\n \n  rep(i,n)cin >> x[i];\n  ll mex=0;\n  ll sum=0;\n\n  for(int i=0;i<n;i++){\n    sum+=x[i];\n    ll premex = rmq._query(0,x[i])+x[i];\n    rmq.update(x[i],premex);\n    mex = max(mex,premex);\n   \n  }  \n  \n  cout << sum-mex << endl;\n\nreturn 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include<bits/stdc++.h>\n#define N (1<<17)\nusing namespace std;\ntypedef long long ll;\ntypedef pair<ll,ll> P;\nll n,x[N];\n\n\nclass RMQ{\npublic:\n  ll n,dat[2*N-1];\n  //?????????\n  RMQ(){};\n  RMQ(int n_){\n    //????´???°n???2???????????????\n    n=1;\n    while(n<n_)n*=2;\n    for(int i=0;i<2*n-1;i++)dat[i]=INT_MAX;\n  }\n  \n  //k???????????????a????????´\n  void update(int k,int a){\n    k+=n-1;\n    dat[k]=a;\n    while(k>0){\n      k=(k-1)/2;\n      dat[k]=min(dat[k*2+1],dat[k*2+2]);\n    }\n  }\n\n  //[a,b)???????°????????±???????\n  //query(a,b,0,0,n)\n  ll query(int a,int b,int k,int l,int r){\n    if(r<=a||b<=l)return INT_MAX;\n    if(a<=l&&r<=b)return dat[k];\n    else{\n      int v1=query(a,b,k*2+1,l,(l+r)/2);\n      int vr=query(a,b,k*2+2,(l+r)/2,r);\n      return min(v1,vr);\n    }\n  }\n};\n\nclass BIT{\npublic:\n  ll bit[N+1],n;\n  BIT(){};\n  BIT(int n){this->n=n,memset(bit,0,sizeof(bit));}\n  \n  ll sum(int i){\n    if(i<=0) return 0;\n    ll s=0;\n    while(i>0){\n      s+=bit[i];\n      i-=i&-i;\n    }\n    return s;\n  }\n\n  void add(int i,int x){\n    while(i<=n){\n      bit[i]+=x;\n      i+=i&-i;\n    }\n  }\n};\n\n\nRMQ rmq;\nint search(int x,int R){\n  int L=0,idx=R,M;\n  while(L<R){\n    M=(R+L)/2;\n    if(-rmq.query(M,idx+1,0,0,rmq.n)==x)R=M;\n    else L=M+1;\n  }\n\n  if(L==0||-rmq.dat[L+rmq.n-2]<x) return x;\n  return -rmq.dat[L+rmq.n-2];\n}\n\nint main(){  \n  cin>>n;\n  rmq=RMQ(n);\n  for(int i=0,a;i<n;i++){\n    cin>>a;\n    rmq.update(i,-a);\n    x[a]=i;\n  }\n  \n  BIT B(n);\n  ll ans=0;  \n  for(int i=1;i<=n;i++){\n    int mn=search(i,x[i]);\n    if(mn==i){\n      ll cost=B.sum(n)-B.sum(i-1);\n      ans+=(cost<=i)? B.sum(i)-B.sum(i-1):i;\n    }\t       \n    else {\n      ll cost=B.sum(i)-B.sum(i-1);\n      B.add(mn,i);\n      ans+=cost;\n      B.add(i,-cost);\n    }\n  }\n  cout <<ans<<endl;\n  return 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include<bits/stdc++.h>\nusing namespace std;\ntypedef long long ll;\n#define MAX 100005\n\n\nll bit[MAX];\n\nvoid numSet(int r,ll x){\n  r=MAX-r-1;\n  while(r){\n    bit[r]=max(bit[r],x);\n    r-=(r&-r);\n  }\n}\n\nll getMin(int i){\n  i=MAX-i-1;\n  ll res=0;\n  while(i<MAX){\n    res=max(res,bit[i]);\n    i+=(i&-i);\n  }\n  return res;\n}\n\n\nll n,k,sum,ans,num;\nint main(){\n  scanf(\"%lld\",&n);\n  while(n--){\n    scanf(\"%lld\",&num);\n    sum+=num;\n    k=getMin(num);\n    ans=max(ans,k+num);\n    numSet(num,k+num);\n  }\n  printf(\"%lld\\n\",sum-ans);\n  return 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\n\n#define ALL(a) (a).begin(), (a).end()\ntypedef long long ll;\n\nusing namespace std;\n\nint main(){\n\tint n; cin >> n;\n\n\tvector<ll> dp(n,0);\n\tvector<ll> sum(n,0);\n\tvector<ll> a(n);\n\tfor(int i = 0; i < n; i++)cin >> a[i];\n\tfor(vector<ll>::reverse_iterator itr = a.rbegin(); itr != a.rend(); ++itr){\n\t\tint idx = distance(dp.begin(),lower_bound(ALL(dp), *itr))-1;\n\t\tdp[idx] = *itr;\n\t\tsum[idx] = *itr;\n\t\tif(idx != n-1){\n\t\t\tsum[idx] += sum[idx+1];\n\t\t}\n\t}\n\tll ans = accumulate(ALL(a),0) - *max_element(ALL(sum));\n\tcout << ans << endl;\n\treturn 0;\n}\n\n"
  },
  {
    "language": "C++",
    "code": "#include <cstdio>\n#include <algorithm>\nusing namespace std;\n#define rep(i,n) for(int i=0;i<(n);i++)\ntypedef long long int lli;\n\nlli seg[400005]={};\nint N=1;\nvoid init(int p){\n\twhile(N<p)N*=2;\n}\n\nlli rec(int l,int r,int a,int b,int no){\n\tif(b<=l || r<=a)return 0;\n\tif(a<=l && r<=b)return seg[no];\n\treturn max( \n\t\trec(l,(l+r)/2,a,b,no*2),\n\t\trec((l+r)/2,r,a,b,no*2+1));\n}\n\t\t\nvoid upd(int p,lli to){\n\tp+=N;\n\twhile(p){\n\t\tseg[p]=max(seg[p],to);\n\t\tp/=2;\n\t}\n}\nint n;\nlli dat[100005];\nint main(void){\n\tscanf(\"%d\",&n);\n\trep(i,n)scanf(\"%lld\",&(dat[i]));\n\t\n\tinit(n+3);\n\trep(i,n){\n\t\tlli cam=rec(0,N,1,dat[i],1);\n\t\tupd(dat[i],cam+dat[i]);\n\t}\n\tprintf(\"%lld\\n\",n*(n+1)/2-rec(0,N,1,n+1,1));\n\treturn 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include <iostream>\n#include <iomanip>\n#include <sstream>\n#include <cstdio>\n#include <string>\n#include <vector>\n#include <algorithm>\n#include <complex>\n#include <cstring>\n#include <cstdlib>\n#include <cmath>\n#include <cassert>\n#include <climits>\n#include <queue>\n#include <set>\n#include <map>\n#include <valarray>\n#include <bitset>\n#include <stack>\nusing namespace std;\n\n#define REP(i,n) for(int i=0;i<(int)(n);++i)\n#define FOR(i,c) for(__typeof((c).begin())i=(c).begin();i!=(c).end();++i)\n#define ALL(c) (c).begin(), (c).end()\ntypedef long long ll;\ntypedef pair<int,int> pii;\nconst int INF = 1<<29;\nconst double PI = acos(-1);\nconst double EPS = 1e-8;\n\nconst int MAX_N = 100001;        // 131072\n\nstruct RMQ {\n  int n;\n  int dat[MAX_N * 2 - 1];\n  RMQ(int _n) {\n    for (n=1; n<_n; n*=2);\n    fill(dat, dat+2*n-1, 0);\n  }\n  RMQ(vector<int> v) {\n    for (n=1; n<v.size(); n*=2);\n    fill(dat, dat+2*n-1, 0);\n    copy(ALL(v),dat+n-1);\n    for (int i=n-2; i>=0; --i)\n      dat[i] = max(dat[i*2+1], dat[i*2+2]);\n  }\n  void update(int k, int a) {\n    k += n - 1;\n    dat[k] = a;\n    while(k>0) {\n      k = (k-1) / 2;\n      dat[k] = max(dat[k*2 + 1], dat[k*2 + 2]);\n    }\n  }\n  int query(int a, int b) { return q(a, b, 0, 0, n); }\n  int q(int a, int b, int k, int l, int r) {\n    if (r <= a || b <= l) return 0;\n    if (a <= l && r <= b) return dat[k];\n    return max(q(a, b, k*2+1, l, (l+r)/2),\n               q(a, b, k*2+2, (l+r)/2, r));\n  }\n};\n\nint main() {\n  int n;\n  cin >> n;\n  RMQ rmq(n+1);\n  int hoge = 0;\n  int ans = 0;\n  REP(i,n) {\n    int x;\n    cin >> x;\n    int a = rmq.query(0,x);\n    // cout << x << \" \" << a << endl;\n    rmq.update(x,a+x);\n    ans = max(ans, a+x);\n    hoge += x;\n  }\n  cout << hoge-ans << endl;\n}"
  },
  {
    "language": "C++",
    "code": "#include <vector>\n#include <list>\n#include <map>\n#include <set>\n#include <deque>\n#include <stack>\n#include <bitset>\n#include <algorithm>\n#include <functional>\n#include <numeric>\n#include <utility>\n#include <sstream>\n#include <queue>\n#include <iostream>\n#include <iomanip>\n#include <cstdio>\n#include <cmath>\n#include <cstdlib>\n#include <cctype>\n#include <string>\n#include <cstring>\n#include <ctime>\n#include <fstream>\n#include <stdio.h>\n#include <complex>\n\nusing namespace std;\n\n//conversion\n//------------------------------------------\ninline int toInt(string s) {int v; istringstream sin(s);sin>>v;return v;}\ntemplate<class T> inline string toString(T x) {ostringstream sout;sout<<x;return sout.str();}\n\n//typedef\n//------------------------------------------\ntypedef vector<int> VI;\ntypedef vector<VI> VVI;\ntypedef vector<string> VS;\ntypedef pair<int, int> PII;\ntypedef pair<int, PII> TIII;\ntypedef long long LL;\ntypedef vector<LL> VLL;\n\n//container util\n\n//------------------------------------------\n#define ALL(a)  (a).begin(),(a).end()\n#define RALL(a) (a).rbegin(), (a).rend()\n#define PB push_back\n#define MP make_pair\n#define SZ(a) int((a).size())\n#define EACH(i,c) for(typeof((c).begin()) i=(c).begin(); i!=(c).end(); ++i)\n#define EXIST(s,e) ((s).find(e)!=(s).end())\n#define SORT(c) sort((c).begin(),(c).end())\n#define MT(a,b,c) MP(a, MP(b, c))\n\n//repetition\n//------------------------------------------\n#define FOR(i,a,b) for(int i=(a);i<(b);++i)\n#define REP(i,n)  FOR(i,0,n)\n\nint main(){\n\tint n;\n\tcin >> n;\n\tVI a(n);\n\tVLL b(n, 0);\n\tREP(i,n)scanf(\"%d\", &a[i]);\n\tREP(i,n){\n\t\t//a[i]を使う場合\n\t\tint idx = a[i]-1;\n\t\tREP(j,a[i]){\n\t\t\tb[idx] = max(b[idx], (j==a[i]-1)?a[i]:(b[j]+a[i]));\n\t\t}\n\t}\n\tLL s=0;\n\tREP(i,n)s = max(s, b[i]);\n\tcout << n*(n+1)/2-s << endl;\n\treturn 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include<bits/stdc++.h>\n#define rep(i,n)for(int i=0;i<(n);i++)\nusing namespace std;\ntypedef long long ll;\n\nll dp[100001], bit[100001];\nint x[100000], n;\nvoid update(int k, ll x) {\n\twhile (k <= n) {\n\t\tbit[k] = max(bit[k], x);\n\t\tk += k&-k;\n\t}\n}\nll query(int k) {\n\tll ans = 0;\n\twhile (k) {\n\t\tans = max(ans, bit[k]);\n\t\tk -= k&-k;\n\t}\n\treturn ans;\n}\nint main() {\n\tscanf(\"%d\", &n);\n\tll sum = 0;\n\trep(i, n)scanf(\"%d\", &x[i]), sum += x[i];\n\trep(i, n){\n\t\tdp[i] = query(x[i]) + x[i];\n\t\tupdate(x[i], dp[i]);\n\t}\n\tprintf(\"%lld\\n\", sum - query(n));\n}"
  },
  {
    "language": "C++",
    "code": "#include<bits/stdc++.h>\n#define range(i,a,b) for(int i = (a); i < (b); i++)\n#define rep(i,b) for(int i = 0; i < (b); i++)\n#define all(a) (a).begin(), (a).end()\n#define show(x)  cerr << #x << \" = \" << (x) << endl;\n//const int INF = 1e8;\nusing namespace std;\n\n#define int long long\n\nconst int MAX_N = 100005;\n\n//[1, n]\nint bit[MAX_N + 1] = {0};\n\nint sum(int i){\n    int s = 0;\n    while(i > 0){\n        s = max(s,bit[i]);\n        i -= i & -i;\n    }\n    return s;\n}\n\nvoid add(int i, int x){\n    while(i <= MAX_N){\n        //bit[i] += x;\n        bit[i] = max(bit[i], x);\n        i += i & - i;\n    }\n}\n\nsigned main(){\n    int n;\n    cin >> n;\n\n    rep(i,n){\n        int a;\n        cin >> a;\n        add(a, sum(a) + a);\n    }\n    cout << ((n * n + n) / 2) - sum(MAX_N) << endl;\n}"
  },
  {
    "language": "C++",
    "code": "#include<iostream>\n#include<vector>\n#include<algorithm>\n#include<climits>\n\nconst int MAX_N=1000000;\n\ntypedef long long ll;\n\nusing namespace std;\n\nll n,dat[2*MAX_N-1];\n\nvoid init(int n_){\n\tn=1;\n\twhile(n<n_)n*=2;\n}\n\nvoid update(int k,ll a){\n\tk+=n-1;\n\tdat[k]=a;\n\t\n\twhile(k>0){\n\t\tk=(k-1)/2;\n\t\tdat[k]=max(dat[2*k+1],dat[2*k+2]);\n\t}\n}\n\nll query(int a,int b,int k,int l,int r){\n\tif(r<=a || b<=l)return 0;\n\tif(a<=l && r<=b)return dat[k];\n\telse {\n\t\tll vl=query(a,b,k*2+1,l,(l+r)/2);\n\t\tll vr=query(a,b,k*2+2,(l+r)/2,r);\n\t\treturn max(vl,vr);\n\t}\n}\n\nint main(void){\n\t\n\tll in,m,ans=0;\n\t\n\tcin >> m;\n\t\n\tinit(m);\n\t\n\tfor(int i=0;i<m;i++){\n\t\tcin >> in;\n\t\tupdate(in,in+query(1,in+1,0,0,n));\n\t\tans=max(ans,dat[in+n-1]);\n\t}\n\t//cout << m*(m+1)/2-query(1,m+1,0,0,n) << endl;\n\tcout << m*(m+1)/2-query(1,m+1,0,0,n) << endl;\n\t\n\treturn 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include<iostream>\n#include<cstdio>\n#include<cstdlib>\n#include<cmath>\n#include<algorithm>\n#include<cstring>\n#include<sstream>\n#include<vector>\n#include<queue>\n#include<stack>\n#include<string>\n#include<climits>\n#include<map>\n#include<set>\n#include<cassert>\n#include<deque>\n#define REP(i,s,n) for(int i=s;i<n;i++)\n#define rep(i,n) REP(i,0,n)\n#define INF 1<<27\n#define all(n) n.begin(),n.end()\n#define insert(a,b,c,d) PP(P(a,b),P(c,d))\n#define F first\n#define S second\n#define pb push_back\n#define MAX_N (int)1e5+10\n#define foreach(i,c) for(iter(c) i=(c).begin();i!=(c).end();++i)\nusing namespace std;\ntypedef pair<int,int> P;\ntypedef pair<P,P> PP;\ntypedef long long ll;\n\n\n\n\n\ntemplate<class T>\nclass RMQ_segment{\nprivate:\n  int n;\n  T dat[2*MAX_N-1];\npublic:\n  void init(int n_){\n    n = 1;\n    while(n<n_)n*=2;\n    for(int i=0;i<2*n-1;i++)dat[i] = 0;\n  }\n\n  void update(int k,T a){\n    k += n-1;\n    dat[k] = a;\n    while(k > 0){\n      k = (k-1)/2;\n      dat[k] = max(dat[k*2+1],dat[k*2+2]);\n    }\n  }\n\n  T query(int a,int b,int k,int l,int r){\n    if(r<=a || b<=l)return 0;\n    else if(a<=l && r<=b)return dat[k];\n    \n      T vl = query(a,b,k*2+1,l,(l+r)/2);\n      T vr = query(a,b,k*2+2,(l+r)/2,r);\n      return max(vl,vr);\n    \n  }\n\n  T _query(int a,int b){//nの範囲でミスしないように極力こっちを利用\n    return query(a,b,0,0,n);\n  }\n\n};\n\n\n\n\nint main(){\n  int n;\n  cin >> n;\n  RMQ_segment<ll> rmq;\n  rmq.init(n+1);\n  ll x[n];\n  rep(i,n)cin >> x[i];\n  ll mex=0;\n  ll sum=0;\n\n  for(int i=0;i<n;i++){\n    sum+=x[i];\n    ll premex = rmq._query(0,x[i])+x[i];\n    rmq.update(x[i],premex);\n    mex = max(mex,premex);\n   \n  }  \n  \n  cout << sum-mex << endl;\n\nreturn 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include <iostream>\n#include <vector>\n#include <algorithm>\nusing namespace std;\n\n#define rep(i, n) rep2(i, 0, n)\n#define rep2(i, m, n) for(int i = m; i < (int)(n); ++i)\n\ntypedef long long ll;\n\nint seg_n, n;\nvector<ll> seg;\n\nvoid init(int n) {\n    seg_n = 1;\n    while(seg_n < n) seg_n *= 2;\n    seg.resize(seg_n * 2 - 1);\n}\n\nvoid update(int k, ll a) {\n    k += seg_n - 1;\n    seg[k] = a;\n    while(k > 0) {\n        k = (k - 1) / 2;\n        seg[k] = max(seg[k*2+1], seg[k*2+2]);\n    }\n}\n\nll query(int a, int b, int k, int l, int r) {\n    if(r <= a || b <= l) return 0;\n    if(a <= l && r <= b) return seg[k];\n    int vl = query(a, b, k * 2 + 1, l, (l + r) / 2);\n    int vr = query(a, b, k * 2 + 2, (l + r) / 2, r);\n    return max(vl, vr);\n}\n\nll query(int x) { return query(0, x, 0, 0, seg_n); }\n\nint main() {\n    cin >> n;\n    vector<int> x(n);\n    rep(i, n) cin >> x[i];\n    init(n + 1);\n    rep(i, n) update(x[i], query(x[i]) + x[i]);\n    cout << (ll)n * (n + 1) / 2 - query(n + 1) << endl;\n}"
  },
  {
    "language": "C++",
    "code": "#include<iostream>\n#include<map>\n\nusing namespace std;\n\nint main(){\n  int n;\n  cin>>n;\n  long long s=0;\n  map<int,long long> m;\n  m[0]=0;\n  while(n--){\n    int x;\n    cin>>x;\n    s+=x;\n    auto c=(--m.lower_bound(x))->second+x;\n    for(auto it=m.upper_bound(x);it!=end(m)&&it->second<=c;it=m.erase(it));\n    m[x]=c;\n  }\n  cout<<s-m.rbegin()->second<<endl;\n}"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\nusing namespace std;\n\ntemplate<typename T>\nstruct SegmetTree\n{\n    int N;\n    vector<T> dat;\n\n    SegmetTree(int n) {\n        N = 1;\n        while (N < n) N *= 2;\n        dat.resize(N * 2 - 1, 0);\n    }\n\n    void update(int k, T a) {\n        k += N - 1;\n        dat[k] = a;\n        while (k > 0) {\n            k = (k - 1) / 2;\n            dat[k] = max(dat[k * 2 + 1], dat[k * 2 + 2]);\n        }\n    }\n\n    T Max(int limit, int k, int l, int r) {\n        if (limit <= l) return 0;\n        if (r <= limit) return dat[k];\n        T vl = Max(limit, k * 2 + 1, l, (r + l) / 2);\n        T vr = Max(limit, k * 2 + 2, (r + l) / 2, r);\n\n        return max(vl, vr);\n    }\n};\n\nint main() {\n    long long int N; cin >> N;\n    SegmetTree<long long int> st(N + 1);\n\n    for (int i = 0; i < N; i++) {\n        int now;\n        cin >> now;\n        st.update(now, now + st.Max(now, 0, 0, (st.dat.size() + 1) / 2));\n    }\n    cout << (((N + 1) * N) / 2) - st.dat[0] << endl;\n\n    return 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include <iostream>\n#include <fstream>\n#include <cassert>\n#include <typeinfo>\n#include <vector>\n#include <stack>\n#include <cmath>\n#include <set>\n#include <map>\n#include <string>\n#include <algorithm>\n#include <cstdio>\n#include <queue>\n#include <iomanip>\n#include <cctype>\n#include <random>\n#include <time.h>\n#define syosu(x) fixed<<setprecision(x)\nusing namespace std;\ntypedef long long ll;\ntypedef unsigned long long ull;\ntypedef pair<int,int> P;\ntypedef pair<double,double> pdd;\ntypedef pair<ll,ll> pll;\ntypedef vector<int> vi;\ntypedef vector<vi> vvi;\ntypedef vector<double> vd;\ntypedef vector<vd> vvd;\ntypedef vector<ll> vl;\ntypedef vector<vl> vvl;\ntypedef vector<char> vc;\ntypedef vector<vc> vvc;\ntypedef vector<string> vs;\ntypedef vector<bool> vb;\ntypedef vector<vb> vvb;\ntypedef vector<P> vp;\ntypedef vector<vp> vvp;\ntypedef vector<pll> vpll;\ntypedef pair<P,int> pip;\ntypedef vector<pip> vip;\nconst int inf=1<<28;\nconst ll INF=1ll<<60;\nconst double pi=acos(-1);\nconst double eps=1e-8;\nconst ll mod=1e9+7;\nconst int dx[4]={0,1,0,-1},dy[4]={1,0,-1,0};\n\nclass Segment_Tree{\n\tprivate:\n\tint n;\n\tvl date;\n\tll Query_func(int a,int b,int k,int l,int r){\n\t\tif(r<=a||b<=l) return -INF;\n\t\tif(a<=l&&r<=b) return date[k];\n\t\tint m=(l+r)/2;\n\t\treturn max(Query_func(a,b,k*2+1,l,m),Query_func(a,b,k*2+2,m,r));\n\t}\n\tpublic:\n\tSegment_Tree(int n_){\n\t\tn=1;\n\t\twhile(n<n_) n*=2;\n\t\tdate=vl(2*n-1,-INF);\n\t}\n\tvoid Update(int k,ll x){\n\t\tk+=n-1;\n\t\tdate[k]=x;\n\t\twhile(k>0){\n\t\t\tk=(k-1)/2;\n\t\t\tdate[k]=max(date[k*2+1],date[k*2+2]);\n\t\t}\n\t}\n\tll Query(int b){\n\t\treturn Query_func(0,b,0,0,n);\n\t}\n\tll Open(int k){\n\t\treturn date[n+k-1];\n\t}\n};\n\nll n;\n\nint main(){\n\tcin>>n;\n\tSegment_Tree st(n+1);\n\tst.Update(0,0);\n\tfor(int i=0;i<n;i++){\n\t\tint x;\n\t\tcin>>x;\n\t\tst.Update(x,st.Query(x)+x);\n\t}\n\tll res=0;\n\tfor(int i=1;i<=n;i++) res=max(res,st.Open(i));\n\tcout<<n*(n+1)/2-res<<endl;\n}"
  },
  {
    "language": "C++",
    "code": "#include<iostream>\n#include<cstring>\n\nusing namespace std;\n\ntypedef long long ll;\nconst int MAX = 200000;\n\nclass SegmentTree{\npublic:\n  int n;\n  ll dat[MAX];\n\n  void init(int num){\n    n = 1;\n    while(n < num) n*=2;\n    memset(dat,0,sizeof(dat));\n  }\n\n  void update(int k, ll a){\n    k += n-1;\n    dat[k] = a;\n\n    while(k > 0){\n      k = (k-1)/2;\n      dat[k] = max(dat[k*2+1],dat[k*2+2]);\n    }\n  }\n\n  ll query(int a, int b, int k, int l, int r){\n    if(r <= a || b <= l) return 0;\n    \n    if(a <= l && r <= b) return dat[k];\n\n    int vl = query(a,b,k*2+1,l,(l+r)/2);\n    int vr = query(a,b,k*2+2,(l+r)/2,r);\n    return max(vl,vr);\n  }\n};\n\nint main(){\n\n  ll n;\n  cin >> n;\n  SegmentTree st;\n  st.init(n);\n  \n  ll ans = 0;\n \n  for(int i = 0; i < n; i++){\n    ll x;\n    cin >> x;\n    ll nex = st.query(1,x+1,0,0,st.n)+x;\n    st.update(x,nex);\n    ans = max(ans,nex);\n  }\n  cout << (n*(n+1LL))/2LL - ans << endl;\n\n  return 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include<bits/stdc++.h>\n#define N 100005\nusing namespace std;\ntypedef long long ll;\nconst int MAX_N = 1<<17;\n\nll n,dat[2*MAX_N-1];\n\nvoid init(int n_){\n  n=1;\n  while(n<n_)n*=2;\n  for(int i=0;i<2*n-1;i++)dat[i]=0;\n}\n\nvoid update(int k,ll a){\n  k+=n-1;\n  dat[k]=a;\n  while(k>0){\n    k=(k-1)/2;\n    dat[k]=max(dat[k*2+1],dat[k*2+2]);\n  }\n}\n\nll query(int a,int b,int k,int l,int r){\n  if(r<=a||b<=l)return 0;\n  if(a<=l&&r<=b)return dat[k];\n  else{\n    ll vl=query(a,b,k*2+1,l,(l+r)/2);\n    ll vr=query(a,b,k*2+2,(l+r)/2,r);\n    return max(vl,vr);\n  }\n}\n\nint main(){\n  ll num,x;\n  cin>>n;\n  num=n;\n  init(n+1);\n  for(int i=0;i<num;i++){\n    cin>>x;\n    update(x,query(0,x,0,0,n)+x);\n  }\n  cout<<num*(num+1)/2-query(0,num+1,0,0,n)<<endl;\n  return 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\nusing namespace std;\n\ntemplate<typename T>\nstruct SegmetTree\n{\n    int N;\n    vector<T> dat;\n\n    SegmetTree(int n, T default_number) {\n        N = 1;\n        while (N < n) N *= 2;\n        dat.resize(N * 2, default_number);\n    }\n\n    void update(int k, T a) {\n        k += N - 1;\n        dat[k] = a;\n        while (k > 0) {\n            k = (k - 1) / 2;\n            dat[k] = max(dat[k * 2 + 1], dat[k * 2 + 2]);\n        }\n    }\n\n    T Max(int limit, int k, int l, int r) {\n        if (limit <= l) return 0;\n        if (r <= limit) return dat[k];\n        T vl = Max(limit, k * 2 + 1, l, (r + l) / 2);\n        T vr = Max(limit, k * 2 + 2, (r + l) / 2, r);\n\n        return max(vl, vr);\n    }\n};\n\nint main() {\n    int N; cin >> N;\n    SegmetTree<int> st(N, 0);\n\n    for (int i = 0; i < N; i++) {\n        int now;\n        cin >> now;\n        st.update(now, now + st.Max(now, 0, 0, N));\n    }\n    cout << (N + 1) * N / 2 - st.dat[0] << endl;\n\n    return 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include<iostream>\n#include<algorithm>\nusing namespace std;\ntypedef long long ll;\nll dp[110000], x[110000], n, s, rmq[280000], v, res = 1LL << 60;\nvoid update(ll i, ll x) {\n\ti += v; rmq[i] = x;\n\twhile (i > 1) {\n\t\ti /= 2, rmq[i] = max(rmq[i * 2], rmq[i * 2 + 1]);\n\t}\n}\nlong long query(ll p, ll q, ll k, ll l, ll r) {\n\tif (r <= p || q <= l) return 0;\n\tif (p <= l && r <= q) return rmq[k];\n\tlong long vl = query(p, q, 2 * k, l, (l + r) / 2);\n\tlong long vr = query(p, q, 2 * k + 1, (l + r) / 2, r);\n\treturn max(vl, vr);\n}\nint main() {\n\tcin >> n; for (int i = 0; i < 20; i++) { if ((1 << i) < n) { v = (1 << (i + 1)); } }\n\tfor (int i = 0; i < n; i++) { cin >> x[i]; dp[i] = x[i]; s += x[i]; }update(x[0], dp[0]);\n\tfor (int i = 1; i < n; i++) {\n\t\tdp[i] = query(1, x[i], 1, 0, v) + x[i];\n\t\tupdate(x[i], dp[i]);\n\t}\n\tfor (int i = 0; i < n; i++)res = min(res, s - dp[i]);\n\tcout << res << endl;\n\treturn 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include \"bits/stdc++.h\"\nusing namespace std;\ntypedef long long LL;\nLL bit[100001];\nint n;\nLL max_q(int i) {\n\tLL ret = 0;\n\twhile (i > 0) {\n\t\tret = max(ret, bit[i]);\n\t\ti -= i&-i;\n\t}\n\treturn ret;\n}\nvoid update(int i, LL x) {\n\tbit[i] = max(bit[i], x);\n\twhile (i <= n) {\n\t\tbit[i] = max(bit[i], x);\n\t\ti += i&-i;\n\t}\n}\nint main() {\n\tcin >> n;\n\tLL sum = 0;\n\tfor (int i = 0; i < n; i++) {\n\t\tint x;\n\t\tcin >> x;\n\t\tint r = max_q(x - 1);\n\t\tupdate(x, r + x);\n\t\tsum += x;\n\t}\n\tcout << sum - max_q(n) << endl;\n}\n"
  },
  {
    "language": "C++",
    "code": "#include<cstdio>\n#include<cstring>\n#include<vector>\n#include<queue>\n#include<algorithm>\n#include<cmath>\n#include<climits>\n#include<string>\n#include<set>\n#include<map>\n#include<iostream>\nusing namespace std;\n#define rep(i,n) for(int i=0;i<((int)(n));i++)\n#define reg(i,a,b) for(int i=((int)(a));i<=((int)(b));i++)\n#define irep(i,n) for(int i=((int)(n))-1;i>=0;i--)\n#define ireg(i,a,b) for(int i=((int)(b));i>=((int)(a));i--)\ntypedef long long int lli;\ntypedef pair<int,int> mp;\n#define fir first\n#define sec second\n#define IINF INT_MAX\n#define LINF LLONG_MAX\n#define eprintf(...) fprintf(stderr,__VA_ARGS__)\n#define pque(type) priority_queue<type,vector<type>,greater<type> >\n#define memst(a,b) memset(a,b,sizeof(a))\n#define iter(v,ite) for(auto ite=(v).begin();ite!=(v).end();ite++)\n#define mimunum(v,x) distance((v).begin(),lower_bound((v).begin(),(v).end(),x))\n\nint n;\nlli seg[400005]={};\nlli dat[100005];\nint N;\nvoid init(){\n\tN=1;\n\twhile(N<=n)N*=2;\n}\n\nlli get(int l,int r,int a,int b,int k){\n\tif(r<=a || b<=l)return 0;\n\tif(a<=l && r<=b)return seg[k];\n\treturn max(\n\t\tget(l,(l+r)/2,a,b,k*2),\n\t\tget((l+r)/2,r,a,b,k*2+1));\n}\n\nvoid upd(int p,lli t){\n\tp+=N;\n\twhile(p>0){\n\t\tseg[p]=max(seg[p],t); p/=2;\n\t}\n}\n\nint main(void){\n\tscanf(\"%d\",&n);\n\tinit();\n\tlli s=0;\n\trep(i,n){\n\t\tscanf(\"%lld\",&dat[i]);\n\t\ts+=dat[i];\n\t}\n\t\n\trep(i,n){\n\t\tlli g=get(0,N,0,dat[i],1);\n\t\tupd(dat[i],g+dat[i]);\n\t}\n\t\n\tlli ds=0;\n\treg(i,1,n)ds=max(ds,get(0,N,0,i,1));\n\t\n\tprintf(\"%lld\\n\",s-ds);\n\t\t\n\treturn 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include <iostream>\n#include <algorithm>\n#include <vector>\n#include <queue>\n#include <cstring>\n#include <string>\n#include <cstdlib>\n#include <cstdio>\nusing namespace std;\ntypedef long long int ll;\n\n// 配列を拡張してRMQに対応させる\nvoid rmq_ext(vector<ll>& v) {\n    int n = v.size();\n    v.resize(n*2);\n    for(int i = n; i < 2*n; i++)\n        v[i] = max(v[(i-n)*2+0], v[(i-n)*2+1]);\n}\n// 列の要素を書き換える\nvoid rmq_update(vector<ll>& rmq, int pos, const ll& value) {\n    int n = rmq.size() / 2;\n    rmq[pos] = value;\n    while(pos < 2*n-1) {\n        rmq[pos/2+n] = max(rmq[pos], rmq[pos^1]);\n        pos = pos/2+n;\n    }\n}\n// [from, to)の最小値を取り出す\nll rmq_query(const vector<ll>& rmq, int from, int to) {\n    int n = rmq.size() / 2;\n    int p = min((from == 0 ? 32 : __builtin_ctz(from)), 31-__builtin_clz(to-from));\n    ll x = rmq[(from>>p)|((n*2*((1<<p)-1))>>p)];\n    from += 1<<p;\n    if (from < to)\n        x = max(x, rmq_query(rmq, from, to));\n    return x;\n}\nint n;\nmain(){\n\tint i,j;\n\twhile(cin >> n){\n\t\tll x;\n\t\tvector<ll> dp(1<<17, 0);\n\t\trmq_ext(dp);\n\t\tfor(i=0;i<n;i++){\n\t\t\tcin >> x;\n\t\t\trmq_update(dp, x, rmq_query(dp, 0, x) + x);\n\t\t}\n\t\tcout << (ll)n*(n+1)/2 - rmq_query(dp, 0, n+1) << endl;\n\t}\n\treturn 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include<iostream>\n#include<sstream>\n#include<algorithm>\n#include<set>\n#include<map>\n#include<queue>\n#include<complex>\n#include<cstdio>\n#include<cstdlib>\n#include<cstring>\n#include<cassert>\n\n#define rep(i,n) for(int i=0;i<(int)n;i++)\n#define all(c) (c).begin(),(c).end()\n#define mp make_pair\n#define pb push_back\n#define each(i,c) for(__typeof((c).begin()) i=(c).begin();i!=(c).end();i++)\n#define dbg(x) cerr<<__LINE__<<\": \"<<#x<<\" = \"<<(x)<<endl\n\nusing namespace std;\n\ntypedef long long ll;\ntypedef vector<int> vi;\ntypedef pair<int,int> pi;\nconst int inf = (int)1e9;\nconst double INF = 1e12, EPS = 1e-9;\n\nconst int MX = 100010;\nll bit[MX];\nvoid add(int i, ll x){\n\tfor(; i < MX; i += i & -i) bit[i] = max(bit[i], x);\n}\nll sum(int i){\n\tll res = 0;\n\tfor(; i; i -= i & -i) res = max(res, bit[i]);\n\treturn res;\n}\n\nint main(){\n\tint n, a;\n\tcin >> n;\n\trep(i, n){\n\t\tcin >> a;\n\t\tadd(a, sum(a - 1) + a);\n\t}\n\tcout << n * (n + 1ll) / 2 - sum(n) << endl;\n\treturn 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\nusing namespace std;\n\ntypedef long long int LLI;\ntypedef pair<LLI, int> Pair;\n\nint n;\nint size;\nbool move[1145141];\nLLI BIT[1145141];\nLLI vs[1145141];\nLLI xs[1145141];\nset<LLI> remain;\nmap<int, LLI> rev;\npriority_queue<Pair, vector<Pair>, greater<Pair> > q;\n\nLLI add(int k, LLI x) {\n  k++;\n  while (k <= size) {\n    BIT[k] += x;\n    k += k&-k;\n  }\n}\n\nLLI getsum(int k) {\n  k++;\n  LLI ret = 0;\n  while (k) {\n    ret += BIT[k];\n    k -= k&-k;\n  }\n  return ret;\n}\n\nint main() {\n  scanf(\"%d\", &n);\n  size = 1;\n  while (size < n+10) size *= 2;\n\n  for (int i=0; i<n; i++) {\n    scanf(\"%lld\", &xs[i]);\n    q.push(Pair(xs[i], i));\n    remain.insert(xs[i]);\n  }\n\n  LLI ans = 0;\n  while (!q.empty()) {\n    Pair p = q.top(); q.pop();\n    LLI v = p.first;\n    int idx = p.second;\n    if (!remain.count(v)) continue;\n   \n    LLI cost = getsum(n)-getsum(idx);\n    if (cost > v) {\n      ans += v;\n      remain.erase(v);\n    } else {\n      auto itr = rev.lower_bound(idx);\n      while (itr != rev.end()) {\n        LLI g = getsum(itr->first)-getsum(itr->first-1);\n        add(itr->first, -g);\n        remain.erase(itr->second);\n        rev.erase(itr++);\n      }\n      ans += cost;\n      rev[idx] = v;\n      add(idx, v);\n    }\n  }\n\n  /*if (!remain.empty()) {\n    remain.erase(*remain.rbegin());\n    for (LLI t : remain) ans += t;\n  }*/\n\n  printf(\"%lld\\n\", ans);\n}"
  },
  {
    "language": "C++",
    "code": "#include <stdio.h>\n#include <iostream>\nusing namespace std;\n#define rep(i, n) for (int i = 0; i < (int)(n); i++)\n#define INF (1LL<<60)\ntypedef long long Int;\n\nstruct BIT {\n    static const int N = 200000;\n    Int x[N];\n    void init() {\n        rep (i, N) x[i] = -INF;\n    }\n    void add(int k, Int a) {\n        for(; k<N; k|=k+1) x[k] = max(x[k], a);\n    }\n    Int sum(int k) {\n        Int s = -INF;\n        for(; k>=0; k=(k&(k+1))-1) s = max(s, x[k]);\n        return s;\n    }\n} bit;\n\nint n, x[200000];\n\nint main() {\n    scanf(\"%d\", &n);\n    rep (i, n) scanf(\"%d\", x+i);\n    Int s = 0;\n    rep (i, n) s += x[i];\n    bit.init();\n    bit.add(0, 0);\n    Int ans = 0;\n    rep (i, n) {\n        const Int cur = bit.sum(x[i]) + x[i];\n        bit.add(x[i], cur);\n        ans = max(ans, cur);\n    }\n    cout << s-ans << endl;\n    return 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include <iostream>\n#include <algorithm>\n#include <utility>\n#include <vector>\n#include <list>\n#include <map>\n#include <set>\n#include <queue>\n#include <stack>\n#include <string>\n#include <sstream>\n#include <cstring>\n#include <cstdlib>\n\nusing namespace std;\n\n#define ALL(c) c.begin(),c.end()\n#define RALL(c) c.rbegin(),c.rend()\n#define SORT(x) sort((x).begin(),(x).end())\n#define REP(i,x,y) for(int i=(x);i<(y);++i)\n#define MP(a,b) make_pair((a),(b))\n#define F_ first\n#define S_ second\n#define debug(x) #x << \"=\" << (x)\n \n#ifdef DEBUG\n#define _GLIBCXX_DEBUG\n#define dump(x) std::cerr << debug(x) << \" (L:\" << __LINE__ << \")\" << std::endl\n#else\n#define dump(x)\n#endif\n\ntypedef long long int lli;\ntypedef pair<int,int> pii;\n\nconst int INF=1<<30;\nconst long long int INF_=1LL<<58;\nconst double EPS=1e-9;\nconst int dx[]={1,0,-1,0},dy[]={0,1,0,-1};\n\ntemplate <typename T> ostream &operator<<(ostream &os, const vector<T> &vector){\n\tos << \"[\";\n\tfor (const auto &v : vector) {\n\t\tos << v << \",\";\n\t}\n\tos << \"]\";\n\treturn os;\n}\n\nclass SegmentTree{\n\tprivate:\n\tpublic:\n\tint size;\n\tvector<int> data;\n\tvoid Init(int n){\n\t\tsize=1;\n\t\twhile(size<n) size*=2;\n\t\tdata=vector<int>(size*2-1,INF);\n\t}\n\tvoid Update(int k,int a){\n\t\tk+=size-1;\n\t\tdata[k]=a;\n\t\twhile(k>0){\n\t\t\tk=(k-1)/2;\n\t\t\tdata[k]=min(data[k*2+1],data[k*2+2]);\n\t\t}\n\t}\t\n\tint Query(int a,int b,int k,int l,int r){\n\t\tif(r<=a||b<=l) return INF;\n\t\tif(a<=l&&r<=b) return data[k];\n\t\telse {\n\t\t\tint vl=Query(a,b,k*2+1,l,(l+r)/2);\n\t\t\tint vr=Query(a,b,k*2+2,(l+r)/2,r);\n\t\t\treturn min(vl,vr);\n\t\t}\n\t}\n};\n\nint main(){\n\tstd::ios::sync_with_stdio(false);\n\tstd::cin.tie(0);\n\tint N;\n\tcin >> N;\n\tvector<int> x(N);\n\tREP(i,0,N) cin >> x[i];\n\tvector<int> s(N);\n\ts[0]=x[0];\n\tREP(i,1,N) s[i]+=s[i-1]+x[i];\n\tvector<vector<int>> dp(N,vector<int>(2));\n\tdp[0][0]=x[0];\n\tSegmentTree st;\n\tst.Init(N);\n\tst.Update(x[0]-1,-s[0]);\n\tREP(i,1,N){\n\t\tdp[i][0]=min(dp[i-1][0],dp[i-1][1])+x[i];\n\t\tdp[i][1]=min(s[i-1],st.Query(0,x[i],0,0,st.size)+s[i-1]);\n\t\tst.Update(x[i]-1,dp[i][1]-s[i]);\n\t}\n\tcout << min(dp[N-1][1],dp[N-1][0]) << endl;\n\treturn 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include<bits/stdc++.h>\n#define int long long\n#define MAX 100001\nusing namespace std;\nint n,p,A[MAX*2],N;\nvoid Segtree(int n_){\n  n=1;\n  while(n<n_)n*=2;\n}\nvoid update(int k,int x){\n  k+=n-1;\n  A[k]=x;\n  while(k>0){\n    k=(k-1)/2;\n    A[k]=max(A[k*2+1],A[k*2+2]);\n  }\n}\nint find(int a,int b,int k,int l,int r){\n  if(r<=a||b<=l)return 0;\n  if(a<=l&&r<=b)return A[k];\n  int v1=find(a,b,k*2+1,l,(l+r)/2);\n  int v2=find(a,b,k*2+2,(l+r)/2,r);\n  return max(v1,v2);\n}\nmain(){\n  cin>>n;\n  N=n;\n  Segtree(n+1);\n  for(int i=0;i<N;i++){\n    scanf(\"%lld\",&p);\n    int v=find(0,p,0,0,n);\n    update(p,v+p);\n  }\n  cout<<N*(N+1)/2-find(0,N+1,0,0,n)<<endl;\n}"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\nusing namespace std;\n\ntemplate <typename D, typename T = D>\nclass Tree\n{\npublic:\n\tTree( long long int size = 0, D InitialValueArg = D() ) {\n\t\tlong long int n = 1LL;\n\t\tCalcTree.emplace_back( vector<T>( n ) );\n\t\twhile( n <= size ) {\n\t\t\tn <<= 1LL;\n\t\t\taddOneLine( n );\n\t\t}\n\t\tInitialValue = InitialValueArg;\n\t\tData.resize( n, InitialValue );\n\t\tfor( size_t i = 0; i < Data.size(); i++ ) {\n\t\t\tupdate( i, Data[i] );\n\t\t}\n\t\tMaxSize = n;\n\t\tNowIndex = 0LL;\n\t}\n\n\tvirtual T preprocessing( D a ) {\n\t\treturn T( a );\n\t}\n\n\tvirtual T treeupdate( T a, T b ) {\n\t\treturn a;\n\t}\n\n\tvoid update( long long int idx, D data ) {\n\t\tData[idx] = data;\n\t\t(*(CalcTree.rbegin()))[idx] = preprocessing( data );\n\t\tfor( auto ite = CalcTree.rbegin(); ite + 1 < CalcTree.rend(); ) {\n\t\t\tidx >>= 1LL;\n\t\t\tT updatedata = treeupdate( (*ite)[idx * 2], (*ite)[idx * 2 + 1] );\n\t\t\tite++;\n\t\t\tif( (*ite)[idx] != updatedata ) {\n\t\t\t\t(*ite)[idx] = updatedata;\n\t\t\t} else {\n\t\t\t\tbreak;\n\t\t\t}\n\t\t}\n\t}\n\n\tvoid show() {\n\t\tfor( auto x : CalcTree ) {\n\t\t\tfor( auto y : x ) {\n\t\t\t\tcout << y << \" \";\n\t\t\t}\n\t\t\tcout << endl;\n\t\t}\n\t}\n\n\tvoid push( D data ) {\n\t\tif( NowIndex == MaxSize ) {\n\t\t\tMaxSize <<= 1LL;\n\t\t\taddOneLine( MaxSize );\n\t\t\tvector<D>Datamemo( MaxSize, InitialValue );\n\t\t\tcopy( Data.begin(), Data.end(), Datamemo.begin() );\n\t\t\tfor( long long int i = 0; i < Datamemo.size(); i++ ) {\n\t\t\t\tupdate( i, Datamemo[i] );\n\t\t\t}\n\t\t}\n\t\tData[NowIndex] = data;\n\t\tupdate( NowIndex, data );\n\t\tNowIndex++;\n\t}\n\n\tT range( long long int l, long long int r ) {\n\t\treturn rangeProcessing( 0, l, r, 0, 0, MaxSize );\n\t}\n\n\tlong long int t() {\n\t\treturn 10;\n\t}\n\nprivate:\n\tvector<vector<T>> CalcTree;\n\tvector<D> Data;\n\tlong long int MaxSize;\n\tlong long int NowIndex;\n\tD InitialValue;\n\n\tvoid addOneLine( long long int n ) {\n\t\tCalcTree.emplace_back( vector<T>( n ) );\n\t}\n\n\tT rangeProcessing( long long int d, long long int a, long long int b, long long int k, long long int l, long long int r ) {\n\t\tif( !(r <= a || b <= l) && d < CalcTree.size() ) {\n\t\t\tif( a <= l&&r <= b ) {\n\t\t\t\treturn CalcTree[d][k];\n\t\t\t} else {\n\t\t\t\treturn treeupdate( rangeProcessing( d + 1, a, b, k * 2, l, (l + r) / 2 ), rangeProcessing( d + 1, a, b, k * 2 + 1, (l + r) / 2, r ) );\n\t\t\t}\n\t\t}\n\t\treturn InitialValue;\n\t}\n};\n\nclass RMQ : public Tree<long long int>\n{\npublic:\n\tRMQ( long long int a, long long int b ) :Tree( a, b ) {\n\n\t}\n\tlong long int treeupdate( long long int a, long long int b ) {\n\t\treturn max( a, b );\n\t}\n};\n\nint main() {\n\tlong long int N;\n\tcin >> N;\n\tvector<long long int >data( N );\n\tRMQ rmq( N + 1, LLONG_MIN );\n\tlong long int sum = 0;\n\tfor( size_t i = 0; i < N; i++ ) {\n\t\tcin >> data[i];\n\t\tsum += data[i];\n\t}\n\tvector<long long int>dp( N + 1, LLONG_MIN );\n\tdp[0] = 0;\n\trmq.update( 0, 0 );\n\tlong long int maxnum = 0;\n\tfor( size_t i = 0; i < N; i++ ) {\n\t\tdp[data[i]] = rmq.range( 0, data[i] ) + data[i];\n\t\trmq.update( data[i], dp[data[i]] );\n\t}\n\tfor( size_t i = 0; i < N + 1; i++ ) {\n\t\tmaxnum = max( maxnum, dp[i] );\n\t}\n\tcout << sum - maxnum << endl;\n}"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\n#define REP(i, a, n) for (ll i ((ll) a); i < ((ll) n); i++)\nusing namespace std;\ntypedef long long ll;\n\ntemplate<typename T, typename E> class SegmentTree {\npublic:\n  typedef function<T (T, T)> Operator;\n  typedef function<T (T, E)> Apply;\n\n  vector<T> data;\n  ll n;\n  T e;\n  Operator op;\n  Apply apply;\n\n  SegmentTree(ll _n, T e, Operator op, Apply apply): e(e), op(op), apply(apply) {\n    for(n = 1; n < _n; n *= 2);\n    data.resize(n * 2 - 1, e);\n  }\n\n  T query(ll a, ll b) { return query(a, b, 0, 0, n); }\n  T query(ll a, ll b, ll k, ll l, ll r) {\n    if(r <= a || b <= l) return e;\n    if(a <= l && r <= b) return data[k];\n    T vl = query(a, b, k * 2 + 1, l, (l + r) / 2);\n    T vr = query(a, b, k * 2 + 2, (l + r) / 2, r);\n    return op(vl, vr);\n  }\n\n  void update(ll k, E x) {\n    k += n - 1;\n    data[k] = apply(data[k], x);\n    while(k > 0) {\n      k = (k - 1) / 2;\n      data[k] = op(data[k * 2 + 1], data[k * 2 + 2]);\n    }\n  }\n};\n\nconst ll INF = 1LL << 60;\n\nint main(void) {\n  ll N;\n  cin >> N;\n  vector<ll> A(N);\n  REP(i, 0, N) cin >> A[i];\n\n  SegmentTree<ll, ll>::Operator op = [](ll a, ll b) { return max(a, b); };\n  SegmentTree<ll, ll>::Apply apply = [](ll a, ll x) { return x; };\n  SegmentTree<ll, ll> segtree(N + 1, -INF, op, apply);\n  segtree.update(0, 0);\n\n  REP(i, 0, N) {\n    ll v = segtree.query(0, A[i]);\n    segtree.update(A[i], v + A[i]);\n  }\n  cout << N * (N + 1) / 2 - segtree.query(0, N + 1) << endl;\n}\n"
  },
  {
    "language": "C++",
    "code": "#include <iostream>\n#include <algorithm>\nusing namespace std;\n\ntypedef long long ll;\n\nconst ll MAX = 100000;\n\nint main(){\n   int n;\n   while(cin >> n){\n      ll a[MAX],sum[MAX],ans=0;\n      for(int i=0;i<n;i++) cin >> a[i];\n      for(int i=0;i<n;i++){\n\t sum[i] = a[i];\n\t ll aa = 0;\n\t for(int j=i-1;j>=0;j--){\n\t   if(a[i] > a[j] && aa < sum[j]){\n\t       aa = sum[j];\n\t    }\n\t }\n\t sum[i] += aa;\n\t ans = max(ans,sum[i]);\n      }\n      cout << (ll)(n * (n+1) / 2) - ans << endl;\n   }\n}"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\n\nusing namespace std;\n\n#define MAX 100010\nconst int MAX_N = 1<<17;\ntypedef long long ll;\n\nclass RMQ{\npublic:\n  ll n,dat[2*MAX_N-1];\n  \n  void init(int n_){\n    n = 1;\n    while(n < n_){ n *= 2; }\n    for(int i = 0 ; i < 2*n-1 ; i++){\n      dat[i] = 0LL;\n    }\n  }\n\n  void update(ll k,ll a){\n    k += n - 1;\n    dat[k] = a;\n    while(k > 0){\n      k = (k - 1) / 2;\n      dat[k] = max(dat[k*2+1],dat[k*2+2]);\n    }\n  }\n\n  ll query(ll a,ll b,ll k,ll l,ll r){\n    if(r <= a || b <= l){ return 0LL; }\n    if(a <= l && r <= b){\n      return dat[k];\n    }else{\n      ll vl = query(a,b,k*2+1,l,(l+r)/2);\n      ll vr = query(a,b,k*2+2,(l+r)/2,r);\n      return max(vl,vr);\n    }\n  }\n};\n\nint main(){\n  ll N,x[MAX],sum = 0LL;\n  cin >> N;\n  for(int i = 0 ; i < N ; i++){\n    cin >> x[i];\n    sum += x[i];\n  }\n  RMQ rmq;\n  rmq.init(N);\n  ll lis = 0LL;\n  for(int i = 0 ; i < N ; i++){\n    ll c = rmq.query(1,x[i]+1,0,0,rmq.n);\n    rmq.update(x[i],c+x[i]);\n    lis = max(lis,c);\n  }\n  cout << sum-rmq.query(1,N+1,0,0,rmq.n) << endl;\n  return 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include <iostream>\n#define int long long\nusing namespace std;\n\nint seg = 1,dat[300000];\n\nvoid add(int i,int x){\n\ti += seg - 1;\n\tdat[i] += x;\n\twhile(i){\n\t\ti = (i - 1) / 2;\n\t\tdat[i] = max(dat[i * 2 + 1],dat[i * 2 + 2]);\n\t}\n}\n\nint get(int a,int b,int k,int l,int r){\n\tif(b <= l || r <= a) return 0;\n\tif(a <= l && r <= b) return dat[k];\n\treturn max(get(a,b,k * 2 + 1,l,(l + r) / 2),get(a,b,k * 2 + 2,(l + r) / 2,r));\n}\n\nsigned main(){\n\tint n,a[100000];\n\tcin >> n;\n\twhile(seg < n) seg *= 2;\n\tfor(int i = 0;i < n;i++) {\n\t\tcin >> a[i];\n\t\tadd(a[i] - 1,get(0,a[i],0,0,seg) + a[i]);\n\t}\n\tcout << n * (n + 1) / 2 - dat[0] << endl;\n\treturn 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include <iostream>\n#include <algorithm>\n#include <cstdio>\nusing namespace std;\n\ntypedef long long ll;\n\nconst ll MAX = 100000;\n\nint main(){\n   int n;\n   while(scanf(\"%d\\n\",&n) != EOF){\n      ll a[MAX],sum[MAX],ans=0;\n      for(int i=0;i<n;i++) scanf(\"%d\",&a[i]);\n      for(int i=0;i<n;i++){\n\t sum[i] = a[i];\n\t ll aa = 0;\n\t for(int j=i-1;j>=0;j--){\n\t   if(a[i] > a[j] && aa < sum[j]){\n\t       aa = sum[j];\n\t    }\n\t }\n\t sum[i] += aa;\n\t ans = max(ans,sum[i]);\n      }\n      printf(\"%d\\n\",(ll)(n * (n+1) / 2) - ans);\n   }\n}"
  },
  {
    "language": "C++",
    "code": "#include <iostream>\n#include <algorithm>\n#include <map>\n#include <cstdio>\nusing namespace std;\n\ntypedef long long ll;\ntypedef pair<ll,ll> P;\n\nconst ll MAX = 100000;\n\nint main(){\n    int n;\n    while(cin >> n){\n        ll a[MAX],ans=0,v[MAX];\n        for(int i=0;i<n;i++) scanf(\"%lld\",&a[i]);\n        fill(v,v+n,0);\n        for(int i=0;i<n;i++){\n            ll in = v[a[i]-1] + a[i];\n            ans = max(ans,in);\n            int pos = lower_bound(v+a[i]-1,v+n,in) - v;\n            fill(v+a[i]-1,v+pos,in);\n        }\n        printf(\"%lld\\n\",(ll)n*(n+1)/2 - ans);\n    }\n}"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\nusing namespace std;\n\n#define FOR(i, a, b) for (int i = (a); i < int(b); ++i)\n#define REP(i, n) FOR(i, 0, n)\n\ntemplate <typename Int>\nstruct FenwickTree {\n  vector<Int> data;\n  explicit FenwickTree(int n): data(n, 0) {}\n  void add(int i, Int x) { for (; i < (int)data.size(); i |= i+1) data[i] = max(data[i], x); }\n  Int sum(int i) const { Int s = 0; for (; i >= 0; i = (i & (i+1)) - 1) s = max(s, data[i]); return s; }\n};\n\nlong long dp[100001];\n\nint main() {\n    cin.tie(0); ios_base::sync_with_stdio(false);\n\n    int n;\n    while (cin >> n) {\n        vector<int> weights(n);\n        REP(i, n) cin >> weights[i];\n\n        REP(w, n+1) dp[w] = 0;\n        dp[weights[0]] = weights[0];\n\n        FenwickTree<long long> ft(n+1);\n        ft.add(weights[0], weights[0]);\n\n        FOR(i, 1, n) {\n            int w = weights[i];\n            long long v = max(dp[w], ft.sum(w-1) + w);\n            dp[w] = v;\n            ft.add(w, v);\n        }\n\n        long long total_weight = 0;\n        REP(i, n) total_weight += weights[i];\n\n        cout << total_weight - ft.sum(n) << '\\n';\n    }\n}"
  },
  {
    "language": "C++",
    "code": "#include \"bits/stdc++.h\"\n#include<unordered_map>\n#include<unordered_set>\n#pragma warning(disable:4996)\nusing namespace std;\nusing ld = long double;\ntemplate<class T>\nusing Table = vector<vector<T>>;\n\n\n\nint main() {\n\tint N; cin >> N;\n\tvector<long long int>nums(N);\n\tfor (int i = 0; i < N; ++i) {\n\t\tcin >> nums[i];\n\t}\n\tmap<int, long long int>nmp;\n\tnmp[0] = 0;\n\tfor (int i = 0; i < N; ++i) {\n\t\tmap<int, long long int>newmp(nmp);\n\t\tfor (auto j : nmp) {\n\t\t\tif(nums[i]>j.first)\n\t\t\t\tnewmp[nums[i]] = max(newmp[nums[i]], j.second + nums[i]);\n\t\t\telse {\n\t\t\t\tbreak;\n\t\t\t}\n\t\t}\n\t\tnmp = newmp;\n\t\tmap<int, long long int>cleanmp;\n\t\tlong long int num = -1;\n\t\tfor (auto j : nmp) {\n\t\t\tif (j.second <= num) {\n\n\t\t\t}\n\t\t\telse {\n\t\t\t\tnum = max(num, j.second);\n\t\t\t\tcleanmp.emplace(j);\n\t\t\t}\n\t\t}\n\t\tnmp = cleanmp;\n\t}\n\tlong long int sum= N*(N + 1) / 2;\n\tlong long int ans = sum;\n\tfor (auto m : nmp) {\n\t\tans = min(ans, sum-m.second);\n\t}\n\tcout << ans << endl;\n\treturn 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include<bits/stdc++.h>\nusing namespace std;\ntypedef long long ll;\nconst ll MAX_N = 1<<17;\nll n,dat[2*MAX_N-1];\n\nvoid init(int n_){\n  n=1;\n  while(n<n_)n*=2;\n  for(int i=0;i<2*n-1;i++)dat[i]=0;\n}\n\nvoid update(ll k,ll a){\n  k+=n-1;\n  dat[k]=a;\n  while(k>0){\n    k=(k-1)/2;\n    dat[k]=max(dat[k*2+1],dat[k*2+2]);\n  }\n}\n\nll query(ll a,ll b,ll k,ll l,ll r){\n  if(r<=a||b<=l)return 0;\n  if(a<=l&&r<=b)return dat[k];\n  else{\n    ll v1=query(a,b,k*2+1,l,(l+r)/2);\n    ll vr=query(a,b,k*2+2,(l+r)/2,r);\n    return max(v1,vr);\n  }\n}\n\nint main(){\n  cin>>n;\n  ll nn=n;\n  ll ans=0;\n  init(n);\n  for(ll i=0,x;i<nn;i++){\n    cin>>x;\n    ll p=query(0,x,0,0,n);\n    update(x-1,p+x);\n    ans=max(ans,p+x);\n  }\n  cout<<nn*(nn+1)/2-ans<<endl;\n  return 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include<iostream>\n#include<cstring>\n\nusing namespace std;\n\ntypedef long long ll;\nconst int MAX = (1<<18);\n\nclass SegmentTree{\npublic:\n  int n;\n  ll dat[MAX];\n\n  void init(int num){\n    n = 1;\n    while(n < num) n*=2;\n    memset(dat,0,sizeof(dat));\n  }\n\n  void update(int k, ll a){\n    k += n-1;\n    dat[k] = a;\n\n    while(k > 0){\n      k = (k-1)/2;\n      dat[k] = max(dat[k*2+1],dat[k*2+2]);\n    }\n  }\n\n  ll query(int a, int b, int k, int l, int r){\n    if(r <= a || b <= l) return 0;\n    \n    if(a <= l && r <= b) return dat[k];\n\n    ll vl = query(a,b,k*2+1,l,(l+r)/2);\n    ll vr = query(a,b,k*2+2,(l+r)/2,r);\n    return max(vl,vr);\n  }\n};\n\nint main(){\n\n  ll n;\n  cin >> n;\n  SegmentTree st;\n  st.init(n);\n  \n  ll ans = 0;\n \n  for(int i = 0; i < n; i++){\n    ll x;\n    cin >> x;\n    ll nex = st.query(1,x+1,0,0,st.n)+x;\n    st.update(x,nex);\n    ans = max(ans,nex);\n  }\n  cout << (n*(n+1LL))/2LL - ans << endl;\n\n  return 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\n\n#define ALL(a) (a).begin(), (a).end()\ntypedef long long ll;\n\nusing namespace std;\n\nint main(){\n\tint n; cin >> n;\n\n\tvector<ll> dp(n,0);\n\tvector<ll> sum(n,0);\n\tvector<ll> a(n);\n\tfor(int i = 0; i < n; i++)cin >> a[i];\n\tfor(vector<ll>::reverse_iterator itr = a.rbegin(); itr != a.rend(); ++itr){\n\tint idx = distance(dp.begin(),lower_bound(ALL(dp), *itr))-1;\n\t\tdp[idx] = *itr;\n\t\tsum[idx] = *itr;\n\t\tif(idx != n-1){\n\t\t\tsum[idx] += sum[idx+1];\n\t\t}\n\t}\n\tll ans = 0;\n\tfor(auto e : a){ans += e;}\n\tans -= *max_element(ALL(sum));\n\tprintf(\"%lld\\n\", ans);\n\treturn 0;\n}\n\n"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\nusing namespace std;\nusing ll = long long;\nusing P = pair<ll, int>;\nconst ll MOD = 1000000007;\n\n// 0-origin BIT\ntemplate <typename T>\nclass BIT{\npublic:\n    vector<T> data;\n    int n;\n    BIT(){}\n    BIT(int n_){\n        n = n_;\n        data.assign(n, T(0));\n    }\n    // v[a] += w\n    void add(int a, T w){\n        for (int x = a; x < n; x |= x + 1) data[x] += w;\n    }\n    // sum of v[i] for i in [0, a)\n    T sum(int a){\n        T ret = 0;\n        for (int x = a - 1; x >= 0; x = (x & (x + 1)) - 1) {\n            ret += data[x];\n        }\n        return ret;\n    }\n};\n\nint main(){\n    int n;\n    cin >> n;\n\n    vector<ll> x(n);\n    vector<P> xi(n);\n    for(int i=0;i<n;i++){\n        cin >> x[i];\n        xi[i].first = x[i];\n        xi[i].second = i;\n    }\n    sort(xi.begin(), xi.end());\n\n    BIT<ll> bit(n);\n    set<int> exist;\n    ll ans = 0;\n    for(P& p : xi){\n        int i = p.second;\n        ll v = p.first;\n        int rev = n - 1 - i;\n        ll right = bit.sum(rev);\n        if(right <= v){\n            auto it = exist.upper_bound(i);\n            vector<int> to_remove;\n            while(it != exist.end()){\n                to_remove.push_back(*it);\n                it++;\n            }\n            for(int j : to_remove){\n                exist.erase(j);\n                bit.add(n - 1 - j, -x[j]);\n            }\n            exist.insert(i);\n            bit.add(rev, v);\n            ans += right;\n        }else{\n            ans += v;\n        }\n    }\n    cout << ans << endl;\n\n    return 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include <algorithm>\n#include <cctype>\n#include <cmath>\n#include <cstdio>\n#include <cstdlib>\n#include <cstring>\n#include <cassert>\n#include <functional>\n#include <iostream>\n#include <iomanip>\n#include <iterator>\n#include <map>\n#include <queue>\n#include <set>\n#include <sstream>\n#include <utility>\n#include <vector>\n\nusing namespace std;\n\ntypedef long long Long;\n#define whole(xs) xs.begin(), xs.end()\n\nLong INF = 1LL<<52;\n\nLong N;\nvector<int> xs;\n\nbool input() {\n    cin >> N;\n    xs.resize(N);\n    for (int i = 0; i < N; i++) cin >> xs[i];\n    return true;\n}\n\nLong C(map<int, Long>& L, Long x) {\n    map<int, Long>::iterator it = L.lower_bound(x);\n    if (it == L.begin()) return 0;\n    it--;\n    return it->second;\n}\n\nvoid D(map<int, Long>& L, Long x) {\n    map<int, Long>::iterator it1 = L.find(x);\n    assert(it1 != L.end());\n    map<int, Long>::iterator it = it1;\n    vector< int > del;\n    if (it != L.begin()) {\n        it1--;\n        if (it1->second >= it->second) {\n            del.push_back(it->first);\n        }\n    }\n    it1 = it;\n    it1++;\n    while (it1 != L.end() && it->second >= it1->second) {\n        del.push_back(it1->first);\n        it1++;\n    }\n    //cout << \"del: \" << del.size() << endl;\n    for (int i = 0; i < del.size(); i++) {\n        L.erase(del[i]);\n    }\n}\n\nvoid solve() {\n    map<int, Long> dp;\n    dp[0] = 0;\n    for (int i = 0; i < N; i++) {\n        map<int, Long>::iterator it = dp.lower_bound(xs[i]);\n        Long r = C(dp, xs[i]) + xs[i];\n        //cout << xs[i] << \": \" << r << endl;\n        dp[xs[i]] = r;\n        D(dp, xs[i]);\n    }\n    Long Ans = 0;\n\n    map<int, Long>::iterator it = dp.end();\n    it--;\n    Ans = max(Ans, it->second);\n\n    /*\n    for (map<int, Long>::iterator it = dp.begin(); it != dp.end(); it++) {\n        cout << \"(\" << it->first << \", \" << it->second << \")\";\n    }\n    cout << endl;\n    */\n\n    cout << N * (N + 1) / 2 - Ans << endl;\n}\n\nint main() {\n    input(); solve();\n    return 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include <algorithm>\n#include <cctype>\n#include <cmath>\n#include <cstdio>\n#include <cstdlib>\n#include <cstring>\n#include <cassert>\n#include <functional>\n#include <iostream>\n#include <iomanip>\n#include <iterator>\n#include <map>\n#include <queue>\n#include <set>\n#include <sstream>\n#include <utility>\n#include <vector>\n\nusing namespace std;\n\ntypedef long long Long;\n#define whole(xs) xs.begin(), xs.end()\n\nint INF = 1<<28;\n\nint N;\nvector<int> xs;\n\nbool input() {\n    cin >> N;\n    xs.resize(N);\n    for (int i = 0; i < N; i++) cin >> xs[i];\n    return true;\n}\n\nint C(map<int, int>& L, int x) {\n    map<int, int>::iterator it = L.lower_bound(x);\n    if (it == L.begin()) return -INF;\n    it--;\n    return it->second;\n}\n\nvoid D(map<int, int>& L, int x) {\n    map<int, int>::iterator it1 = L.find(x);\n    assert(it1 != L.end());\n    map<int, int>::iterator it = it1;\n    it1--;\n    vector< map<int, int>::iterator > del;\n    if (it1->second >= it->second) {\n        del.push_back(it);\n    }\n    it1 = it;\n    it1++;\n    while (it1 != L.end() && it->second >= it1->second) {\n        del.push_back(it1);\n        it++;\n    }\n    for (int i = 0; i < del.size(); i++) {\n        L.erase(del[i]);\n    }\n}\n\nvoid solve() {\n    map<int, int>* dp = new map<int, int>[N + 1];\n    dp[0][0] = 0;\n    for (int i = 0; i < N; i++) {\n        int lb = 0, ub = N + 1;\n        while (lb + 1 < ub) {\n            int mid = (lb + ub) / 2;\n            int r = C(dp[mid], xs[i]);\n            (r >= 0 ? lb : ub) = mid;\n        }\n        int r = C(dp[lb], xs[i]) + xs[i];\n        dp[lb + 1][xs[i]] = r;\n        //D(dp[lb + 1], xs[i]);\n    }\n    int Ans = 0;\n    for (int i = 0; i <= N; i++) {\n        if (!dp[i].empty()) {\n            map<int, int>::iterator it = dp[i].end();\n            it--;\n            Ans = max(Ans, it->second);\n        }\n    }\n    /*\n    for (int i = 0; i <= N; i++) {\n        for (map<int, int>::iterator it = dp[i].begin(); it != dp[i].end(); it++) {\n            cout << \"(\" << it->first << \", \" << it->second << \")\";\n        }\n        cout << endl;\n    }\n    */\n    cout << N * (N + 1) / 2 - Ans << endl;\n}\n\nint main() {\n    input(); solve();\n    return 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include <iostream>\n#include <vector>\n#include <algorithm>\n\nusing namespace std;\n\nint main(){\n    \n    long long n, x;\n    cin >> n;\n    vector<int> seg(n+1, 0);\n    \n    for(int i = 0; i < n; i++){\n        cin >> x;\n        long long sum = 0;\n        for(int j = x-1; j > 0; j = j & (j-1)){\n            if(seg[j] > sum)\n                sum = seg[j];\n        }\n        for(int j = x; j < n + 1; j += (j & -j)){\n            if(sum + x > seg[j]){\n                seg[j] = sum + x;\n                cout << j << \" \" << seg[j] << endl;\n            }\n        }\n    }\n    \n    long long ans = 0;\n    for(int j = n; j > 0; j = j & (j-1)){\n        if(seg[j] > ans)\n            ans = seg[j];\n    }\n    cout << (n*(n+1))/2 - ans <<endl;\n    \n}"
  },
  {
    "language": "C++",
    "code": "#include \"bits/stdc++.h\"\n#include<unordered_map>\n#include<unordered_set>\n#pragma warning(disable:4996)\nusing namespace std;\nusing ld = long double;\ntemplate<class T>\nusing Table = vector<vector<T>>;\nld eps=1e-9;\n\n#define Seg_Max_N (1<<18) \nusing Value = long long int ;\nValue dat[2 * Seg_Max_N];\nstruct segtree {\n\tint N;\n\tconst Value ini = 0;\n\tsegtree() {}\n\tsegtree(int n) {\n\t\tN = 1;\n\t\twhile (N < n) N *= 2;\n\t\tfor (int i = 0; i < 2 * N - 1; i++) {\n\t\t\tdat[i] = ini;\n\t\t}\n\t}\n\t// update k th element\n\tvoid update(int k, Value a) {\n\t\tk += N - 1; // leaf\n\t\tdat[k] = a;\n\t\twhile (k > 0) {\n\t\t\tk = (k - 1) / 2;\n\t\t\tconst Value al(dat[k * 2 + 1]);\n\t\t\tconst Value ar(dat[k * 2 + 2]);\n\t\t\tdat[k] = max(al, ar);\n\t\t}\n\t}\n\t// min [a, b)\n\tValue  query(int a, int b) { return query(a, b, 0, 0, N); }\n\tValue  query(int a, int b, int k, int l, int r) {\n\t\tif (r <= a or b <= l) return ini;\n\t\tif (a <= l and r <= b) return dat[k];\n\t\tconst int m = (l + r) / 2;\n\t\tconst Value al(query(a, b, k * 2 + 1, l, m));\n\t\tconst Value ar(query(a, b, k * 2 + 2, m, r));\n\t\treturn max(al, ar);\n\t}\n};\nint main() {\n\tint N; cin >> N;\n\tvector<long long int>hs;\n\tvector<long long int>dps;\n\tsegtree seg(N);\n\tfor (size_t i = 0; i < N; i++)\n\t{\n\t\tint a; cin >> a; a--; hs.emplace_back(a);\n\t}\n\tfor (size_t i = 0; i < N; i++)\n\t{\n\t\tlong long int next = seg.query(0, hs[i]);\n\t\tseg.update(hs[i], next + hs[i] + 1);\n\t}\n\tlong long int ans =N*(N+1)/2- seg.query(0, N);\n\tcout << ans << endl;\n\treturn 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include <iostream>\n#include <algorithm>\n#include <vector>\n#include <queue>\n#include <cstring>\n#include <string>\n#include <cstdlib>\n#include <cstdio>\nusing namespace std;\ntypedef long long int ll;\n\n// 配列を拡張してRMQに対応させる\nvoid rmq_ext(vector<ll>& v) {\n    int n = v.size();\n    v.resize(n*2);\n    for(int i = n; i < 2*n; i++)\n        v[i] = max(v[(i-n)*2+0], v[(i-n)*2+1]);\n}\n// 列の要素を書き換える\nvoid rmq_update(vector<ll>& rmq, int pos, const ll value) {\n    int n = rmq.size() / 2;\n    rmq[pos] = value;\n    while(pos < 2*n-1) {\n        rmq[pos/2+n] = max(rmq[pos], rmq[pos^1]);\n        pos = pos/2+n;\n    }\n}\n// [from, to)の最小値を取り出す\nll rmq_query(const vector<ll>& rmq, int from, int to) {\n    int n = rmq.size() / 2;\n    int p = min((from == 0 ? 32 : __builtin_ctz(from)), 31-__builtin_clz(to-from));\n    ll x = rmq[(from>>p)|((n*2*((1<<p)-1))>>p)];\n    from += 1<<p;\n    if (from < to)\n        x = max(x, rmq_query(rmq, from, to));\n    return x;\n}\nint n;\nmain(){\n\tint i,j;\n\twhile(cin >> n){\n\t\tll x;\n\t\tvector<ll> dp(1<<17, 0);\n\t\trmq_ext(dp);\n\t\tfor(i=0;i<n;i++){\n\t\t\tcin >> x;\n\t\t\trmq_update(dp, x, rmq_query(dp, 0, x) + x);\n\t\t}\n\t\tcout << (ll)n*(n+1)/2 - rmq_query(dp, 0, n+1) << endl;\n\t}\n\treturn 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include <iostream>\n#include <vector>\n#include <algorithm>\nusing namespace std;\n\nconst int MAX_N = 1 << 17;\ntypedef long long LL;\n\n// Segment Tree\n// (数列のサイズ N に対してSegment Treeの頂点は 2*N-1 となる)\nstruct Segment_tree{\n\tint n;\n\tvector<LL> dat;\n\t// コンストラクタで初期化\n\tSegment_tree(int n_){\n\t\t// 簡単のために要素数を2のべき乗にする \n\t\tn = 1;\n\t\twhile( n < n_ ) n *= 2;\n\t\t// すべての頂点の値を 0 にする\n\t\tfor(int i=0 ; i < 2*n-1 ; i++ ){\n\t\t\tdat.push_back( 0 );\n\t\t}\n\t}\n\t// k 番目の値 (0-indexed) を a に更新\n\tvoid update(int k, LL a){\n\t\tk += n-1;\n\t\tdat[k] = a;\n\t\t// 登りながら更新\n\t\twhile( k > 0 ){\n\t\t\tk = (k - 1) / 2;\n\t\t\tdat[k] = max( dat[k*2+1] , dat[k*2+2] );\n\t\t}\n\t}\n\t// [a,b)の最小値を求める\n\tint query(int a, int b, int k=0, int l=0, int r=0){\n\t\t// 初回呼び出し時\n\t\tif( k == 0 && l == 0 && r == 0 ) r = n;\n\t\t\n\t\t// [a,b) と [l,r) が交差しないとき\n\t\tif( r <= a || b <= l ) return 0;\n\t\t\n\t\t// [a,b) が [l,r) を完全に含んでいるとき\n\t\tif( a <= l && r <= b ){\n\t\t\treturn dat[k];\n\t\t}else{ // それ以外\n\t\t\tLL vl = query( a , b , k*2+1 , l , (l+r)/2 );\n\t\t\tLL vr = query( a , b , k*2+2 , (l+r)/2 , r );\n\t\t\treturn max( vl , vr );\n\t\t}\n\t}\n};\n\nint main(){\n\tint n;\n\tcin >> n;\n\tvector<int> x(n);\n\tSegment_tree t(n+1);\n\tfor(int i=0 ; i < n ; i++ ){\n\t\tcin >> x[i];\n\t}\n\t// segment tree について\n\t// t.query(0, b);\n\t// とすると (1..nの総和) - (荷物の重さ b 以下で整列させる最大のコスト)が返ってくる\n\tfor(int i=0 ; i < n ; i++ ){\n\t\t// [0,x[i]) の中で最小値が返ってくる.\n\t\tLL cost = t.query(0, x[i]);\n\t\t// 位置 x[i] を cost - x[i] に更新\n\t\tt.update(x[i], cost+x[i] );\n\t}\n\t// 解 (1..nの総和は n*(n+1)/2 で計算できる)\n\tLL ans = (LL) n * (n+1) / 2 - t.query(0, n+1);\n\tcout << ans << endl;\n}"
  },
  {
    "language": "C++",
    "code": "#include \"bits/stdc++.h\"\n#include<unordered_map>\n#include<unordered_set>\n#pragma warning(disable:4996)\nusing namespace std;\nusing ld = long double;\ntemplate<class T>\nusing Table = vector<vector<T>>;\nld eps=1e-9;\n\n#define Seg_Max_N (1<<18) \nusing Value = long long int ;\nValue dat[2 * Seg_Max_N];\nstruct segtree {\n\tint N;\n\tconst Value ini = 0;\n\tsegtree() {}\n\tsegtree(int n) {\n\t\tN = 1;\n\t\twhile (N < n) N *= 2;\n\t\tfor (int i = 0; i < 2 * N - 1; i++) {\n\t\t\tdat[i] = ini;\n\t\t}\n\t}\n\t// update k th element\n\tvoid update(int k, Value a) {\n\t\tk += N - 1; // leaf\n\t\tdat[k] = a;\n\t\twhile (k > 0) {\n\t\t\tk = (k - 1) / 2;\n\t\t\tconst Value al(dat[k * 2 + 1]);\n\t\t\tconst Value ar(dat[k * 2 + 2]);\n\t\t\tdat[k] = max(al, ar);\n\t\t}\n\t}\n\t// min [a, b)\n\tValue  query(int a, int b) { return query(a, b, 0, 0, N); }\n\tValue  query(int a, int b, int k, int l, int r) {\n\t\tif (r <= a or b <= l) return ini;\n\t\tif (a <= l and r <= b) return dat[k];\n\t\tconst int m = (l + r) / 2;\n\t\tconst Value al(query(a, b, k * 2 + 1, l, m));\n\t\tconst Value ar(query(a, b, k * 2 + 2, m, r));\n\t\treturn max(al, ar);\n\t}\n};\nint main() {\n\tlong long int N; cin >> N;\n\tvector<long long int>hs;\n\tvector<long long int>dps;\n\tsegtree seg(N);\n\tfor (size_t i = 0; i < N; i++)\n\t{\n\t\tint a; cin >> a; a--; hs.emplace_back(a);\n\t}\n\tfor (size_t i = 0; i < N; i++)\n\t{\n\t\tlong long int next = seg.query(0, hs[i]);\n\t\tseg.update(hs[i], next + hs[i] + 1);\n\t}\n\tlong long int ans =N*(N+1)/2- seg.query(0, N);\n\tcout << ans << endl;\n\treturn 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\nusing namespace std;\n\ntemplate<typename T>\nstruct SegmetTree\n{\n    int N;\n    vector<T> dat;\n\n    SegmetTree(int n) {\n        N = 1;\n        while (N < n) N *= 2;\n        dat.resize(N * 2 - 1, 0);\n    }\n\n    void update(int k, T a) {\n        k += N - 1;\n        dat[k] = a;\n        while (k > 0) {\n            k = (k - 1) / 2;\n            dat[k] = max(dat[k * 2 + 1], dat[k * 2 + 2]);\n        }\n    }\n\n    T Max(int limit, int k, int l, int r) {\n        if (limit <= l) return 0;\n        if (r <= limit) return dat[k];\n        T vl = Max(limit, k * 2 + 1, l, (r + l) / 2);\n        T vr = Max(limit, k * 2 + 2, (r + l) / 2, r);\n\n        return max(vl, vr);\n    }\n};\n\nint main() {\n    int N; cin >> N;\n    SegmetTree<int> st(N + 1);\n\n    for (int i = 0; i < N; i++) {\n        int now;\n        cin >> now;\n        st.update(now, now + st.Max(now, 0, 0, (st.dat.size() + 1) / 2));\n    }\n    cout << (((N + 1) * N) / 2) - st.dat[0] << endl;\n\n    return 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include <iostream>\n#include <algorithm>\n\nusing namespace std;\n\n#define ll long long\n#define rep(a,b) for(int a = 0; a < b; a++)\n\nint n;\nll dp[100001*2];\nint arr[1<<18+1];\nint size = 1;\n\nvoid update(int index, ll num) {\n  index += size-1;\n  dp[index] = num;\n  //cout << \"  \" << index << \",\" << dp[index] << endl;\n  while(index>0) {\n    int new_index = (index-1)>>1;\n    dp[new_index] = max(dp[(new_index<<1)+1],dp[(new_index<<1)+2]);\n    //cout << \"  \" << new_index << \",\" << dp[new_index] << endl;\n    index = new_index;\n  }\n  //dp[index] = max(dp[index],dp[index^1]);\n}\n\nll get_max(int a, int b, int k, int left, int right) {\n  //cout << \"gmax \" << a << \",\" << b << \",\" << k << \",\" << left << \",\" << right << endl;\n  if(right<a||b<=left||right<=left) return 0;\n  if(a<=left&&right<=b) {\n    //cout << \"OK \" << dp[k] << endl;\n    return dp[k];\n  }\n  ll ret = 0;\n  ret = max(ret,get_max(a,b,(k<<1)+1,left,(left+right)>>1));\n  ret = max(ret,get_max(a,b,(k<<1)+2,(left+right+1)>>1,right));\n  return ret;\n}\n\nint main() {\n  cin >> n;\n  for(int i = 1; i < n; i<<=1) size<<=1;\n  rep(i,n) cin >> arr[i];\n  rep(i,n) {\n    int num = arr[i];\n    ll _max = get_max(1,num,0,0,size);\n    //cout << num << \",\" << _max << endl;\n    update(num,_max+num);\n  }\n  ll ans = (ll)n;\n  ans = n*(n+1)/2;\n  //for(int i = 0; i < size<<1; i++) cout << dp[i] << endl;\n  cout << ans-dp[0] << endl;\n}\n\n"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\n\nusing namespace std;\n\ntypedef long long ll;\n\nstruct SegmentTree{\n  ll data[100010];\n  int sz;\n  void init(int n){\n    sz = 1;\n    while(sz < n) sz *= 2;\n    memset(data, 0LL, sizeof(data));\n  }\n  void update(int k, ll x){\n    k += sz - 1;\n    data[k] = x;\n    while(k > 0){\n      k = (k - 1) / 2;\n      data[k] = max(data[2*k+1], data[2*k+2]);\n    }\n  }\n  ll at(int k){\n    return data[k+sz-1];\n  }\n  ll query(int a, int b, int k, int l, int r){\n    if(r <= a || b <= l) return -1;\n    if(a <= l && r <= b) return data[k];\n    ll left = query(a, b, 2*k+1, l, (l+r)/2);\n    ll right = query(a, b, 2*k+2, (l+r)/2, r);\n    return max(left, right);\n  }\n  ll query(int a, int b){\n    return query(a, b, 0, 0, sz);\n  }\n  int size(){\n    return sz;\n  }\n};\n\nint main()\n{\n  SegmentTree tree;  \n  int n;\n  cin >> n;\n  tree.init(n);\n  ll maxcost = 0;\n  for(int i = 0; i < n; i++){\n    ll x;\n    cin >> x;\n    int cost = tree.query(1, x+1);\n    tree.update(x, cost + x);\n    maxcost = max(maxcost, tree.at(x));\n  }\n  cout << ((ll)n+1)*n/2 - maxcost << endl;\n  return 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include<iostream>\n#include<cstdio>\n#include<cstdlib>\n#include<cmath>\n#include<algorithm>\n#include<cstring>\n#include<sstream>\n#include<vector>\n#include<queue>\n#include<stack>\n#include<string>\n#include<climits>\n#include<map>\n#include<set>\n#include<cassert>\n#include<deque>\n#define REP(i,s,n) for(int i=s;i<n;i++)\n#define rep(i,n) REP(i,0,n)\n#define INF 1<<27\n#define all(n) n.begin(),n.end()\n#define insert(a,b,c,d) PP(P(a,b),P(c,d))\n#define F first\n#define S second\n#define pb push_back\n#define MAX_N 100100\n#define foreach(i,c) for(iter(c) i=(c).begin();i!=(c).end();++i)\nusing namespace std;\ntypedef pair<int,int> P;\ntypedef pair<P,P> PP;\ntypedef long long ll;\n\n\n\n\n\ntemplate<class T>\nclass RMQ_segment{\nprivate:\n  int n;\n  T dat[2*MAX_N-1];\npublic:\n  void init(int n_){\n    n = 1;\n    while(n<n_)n*=2;\n    for(int i=0;i<2*n-1;i++)dat[i] = 0;\n  }\n\n  void update(int k,T a){\n    k += n-1;\n    dat[k] = a;\n    while(k > 0){\n      k = (k-1)/2;\n      dat[k] = max(dat[k*2+1],dat[k*2+2]);\n    }\n  }\n\n  T query(int a,int b,int k,int l,int r){\n    if(r<=a || b<=l)return 0;\n    else if(a<=l && r<=b)return dat[k];\n    \n      T vl = query(a,b,k*2+1,l,(l+r)/2);\n      T vr = query(a,b,k*2+2,(l+r)/2,r);\n      return max(vl,vr);\n    \n  }\n\n  T _query(int a,int b){//nの範囲でミスしないように極力こっちを利用\n    return query(a,b,0,0,n);\n  }\n\n};\n\n\n\n\nint main(){\n  int n;\n  cin >> n;\n  RMQ_segment<ll> rmq;\n  rmq.init(n+1);\n  int x[n];\n  rep(i,n)cin >> x[i];\n  ll mex=0;\n  ll sum=0;\n\n  for(int i=0;i<n;i++){\n    sum+=x[i];\n    ll premex = rmq._query(0,x[i])+x[i];\n    rmq.update(x[i],premex);\n    mex = max(mex,premex);\n   \n  }  \n  \n  cout << sum-mex << endl;\n\nreturn 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\nusing namespace std;\nusing ll = long long;\n\nll find(const vector<ll>& b, int s) {\n\tll res = 0;\n\tfor (int i = s; i > 0; i = i & (i - 1))\n\t\tres = max(res, b[i]);\n\treturn res;\n}\n\nvoid add(vector<ll>& b, int s, ll val) {\n\tint n = b.size();\n\tfor (int i = s; i < n; i += (i & -i))\n\t\tb[i] = max(b[i], val);\n}\n\nint main()\n{\n\tcin.sync_with_stdio(false);\n\tint n;\n\tcin >> n;\n\tll sum = 0;\n\tvector<ll> bit(n + 1);\n\tfor (int i = 0, x; i < n; i++) {\n\t\tcin >> x; sum += x;\n\t\tadd(bit, x, find(bit, x - 1) + x);\n\t}\n\tprintf(\"%lld\\n\", sum - find(bit, n));\n\treturn 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include<iostream>\n#include<algorithm>\n\nusing namespace std;\ntypedef long long Int;\n\nInt bit[1080000];\n\nvoid setval(Int pos, Int val){\n\tpos++;\n\twhile(pos < 1080000){\n\t\tbit[pos] = max(bit[pos], val);\n\t\tpos += pos & -pos;\n\t}\n}\n\nInt getval(Int pos){\n\tpos++;\n\tInt res = 0;\n\twhile(pos){\n\t\tres = max(bit[pos], res);\n\t\tpos -= pos & -pos;\n\t}\n\treturn res;\n}\n\nint main(){\n\tInt n, x, res = 0;\n\tcin >> n;\n\tfor(Int i = 0;i < n;i++){\n\t\tcin >> x;\n\t\tsetval(x, x + getval(x));\n\t\tres = max(res, getval(x));\n\t}\n\tcout << n*(n+1)/2-res << endl;\n\treturn 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include <iostream>\n#include <iomanip>\n#include <sstream>\n#include <cstdio>\n#include <cstdlib>\n#include <cstring>\n#include <cmath>\n#include <climits>\n#include <cfloat>\n#include <vector>\n#include <string>\n#include <stack>\n#include <queue>\n#include <set>\n#include <map>\n#include <algorithm>\n#include <functional>\n#include <utility>\n#include <numeric>\n#include <iterator>\n\nusing namespace std;\n\ntypedef long long LL;\ntypedef unsigned long long ULL;\ntypedef vector<int> VI;\ntypedef vector<VI> VVI;\ntypedef vector<string> VS;\ntypedef pair<int,int> PII;\ntypedef vector<PII> VPII;\ntypedef istringstream ISS;\ntypedef ostringstream OSS;\n\n#define REP( i, m, n ) for ( int i = (int)( m ); i < (int)( n ); ++i )\n#define FOR( v, c ) for ( auto &v : c )\n#define EACH( it, c ) for ( auto it = c.begin(); it != c.end(); ++it )\n#define ALL( c ) (c).begin(), (c).end()\n#define DRANGE( c, p ) (c).begin(), (c).begin() + p, (c).end()\n\n#define PB( n ) push_back( n )\n#define MP( a, b ) make_pair( ( a ), ( b ) )\n#define EXIST( c, e ) ( (c).find( e ) != (c).end() )\n\n#define fst first\n#define snd second\n\n#define DUMP( x ) cerr << #x << \" = \" << ( x ) << endl\n#define DEBUG( x ) cerr << __FILE__ << \":\" << __LINE__ << \": \" << #x << \" = \" << ( x ) << endl\n\nconst int INF = INT_MAX / 4;\n\n// セグメント木のユーティリティ\ninline const int chl( const int k )\n{\n\treturn k * 2 + 1;\n}\n\ninline const int chr( const int k )\n{\n\treturn k * 2 + 2;\n}\n\ninline const int mid( const int l, const int r )\n{\n\treturn ( l + r ) / 2;\n}\n\n// セグメント木による Range Maximum Query\nclass RangeMaximumQuery\n{\nprivate:\n\tconst int N;\n\tvector<int> data;\n\npublic:\n\tRangeMaximumQuery( const vector<int> &src ) : N( src.size() ), data( N * 4 )\n\t{\n\t\tREP( i, 0, N )\n\t\t{\n\t\t\tupdate( i, src[i] );\n\t\t}\n\n\t\treturn;\n\t}\n\n\tvoid update( const int p, const int x )\n\t{\n\t\treturn update( p, x, 0, 0, N );\n\t}\n\n\tint maximum() const\n\t{\n\t\treturn maximum( 0, N, 0, 0, N );\n\t}\n\n\tint maximum( const int a, const int b ) const\n\t{\n\t\treturn maximum( a, b, 0, 0, N );\n\t}\nprivate:\n\tvoid update( const int p, const int x, const int k, const int l, const int r )\n\t{\n\t\tif ( p < l || r <= p )\n\t\t{\n\t\t\treturn;\n\t\t}\n\t\tif ( l + 1 == r && p == l )\n\t\t{\n\t\t\tdata[k] = x;\n\t\t\treturn;\n\t\t}\n\n\t\tupdate( p, x, chl( k ), l, mid( l, r ) );\n\t\tupdate( p, x, chr( k ), mid( l, r ), r );\n\t\tdata[k] = max( data[ chl( k ) ], data[ chr( k ) ] );\n\t\n\t\treturn;\n\t}\n\n\tint maximum( const int a, const int b, const int k, const int l, const int r ) const\n\t{\n\t\tif ( b <= l || r <= a )\n\t\t{\n\t\t\treturn INT_MIN;\n\t\t}\n\t\telse if ( a <= l && r <= b )\n\t\t{\n\t\t\treturn data[k];\n\t\t}\n\t\telse\n\t\t{\n\t\t\treturn max( maximum( a, b, chl( k ), l, mid( l, r ) ), maximum( a, b, chr( k ), mid( l, r ), r ) );\n\t\t}\n\t}\n};\n// RangeMaximumQuery( VI src )\n// update( pos, x )\n// maximum( [ a = 0, b = N ) )\n\nint main()\n{\n\tcin.tie( 0 );\n\tios::sync_with_stdio( false );\n\n\tint n;\n\tcin >> n;\n\n\tVI xs( n );\n\tREP( i, 0, n )\n\t{\n\t\tcin >> xs[i];\n\t}\n\n\tRangeMaximumQuery rmq( VI( n + 1, -INF ) );\n\trmq.update( 0, 0 );\n\n\tREP( i, 0, n )\n\t{\n\t\trmq.update( xs[i], rmq.maximum( 0, xs[i] ) + xs[i] );\n\t}\n\n\tcout << n * ( n + 1 ) / 2 - rmq.maximum() << endl;\n\n\treturn 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include<iostream>\n#include<vector>\n#include<algorithm>\nusing namespace std;\ntypedef long long ll;\n#define INF (1 << 30)\nstruct SegmentTree{\nprivate:\n  vector<ll> dat;\n  int n;\npublic:\n  SegmentTree(){}\n  SegmentTree(int size){\n    n = 1;\n    while(n < size) n *= 2;\n    dat = vector<ll>( 2 * n - 1 , 0 );\n  }\n  int getSize(){\n    return n;\n  }\n  ll getSeg(int s){\n    return dat[s];\n  }\n  void update(int i,ll x){\n    i += n - 1;\n    dat[i] = x;\n    while(i > 0){\n      i = ( i - 1 ) / 2;\n      dat[i] = max( dat[i * 2 + 1] , dat[i * 2 + 2]);\n    }\n  }\n  ll query(int a,int b,int k,int l,int r){\n    if(r <= a || b <= l) return 0;\n    if(a <= l && r <= b) return dat[k];\n    ll vl = query(a,b,k*2+1,l,(l+r)/2);\n    ll vr = query(a,b,k*2+2,(l+r)/2,r);\n    return max(vl,vr);\n  }\n};\nint main(){\n  int n;\n  ll ans = 0;\n  cin >> n;\n  SegmentTree BIT(n);\n  for(int i = 0 , x ; i < n ; i++ ){\n    cin >> x;\n    BIT.update( x , BIT.query(1,x+1,0,0,BIT.getSize()) + x );\n    ans = max( ans , BIT.getSeg( x + BIT.getSize() - 1));\n  }\n  cout << (n * (n + 1) / 2 - ans) << endl;\n}"
  },
  {
    "language": "C++",
    "code": "#include <iostream>\n#include <sstream>\n#include <string>\n#include <algorithm>\n#include <vector>\n#include <stack>\n#include <queue>\n#include <set>\n#include <map>\n#include <cstdio>\n#include <cstdlib>\n#include <cstring>\n#include <cmath>\n#include <cassert>\n\nusing namespace std;\n\n#define FOR(i,k,n) for(int i=(k); i<(int)n; ++i)\n#define REP(i,n) FOR(i,0,n)\n#define FORIT(i,c) for(__typeof((c).begin())i=(c).begin();i!=(c).end();++i)\n\ntemplate<class T> void debug(T begin, T end){ for(T i = begin; i != end; ++i) cout<<*i<<\" \"; cout<<endl; }\n\ntypedef long long ll;\nconst int INF = 100000000;\nconst double EPS = 1e-8;\nconst int MOD = 1000000007;\nvector<int> v;\ntypedef pair<int, int> P;\nmap<P, int> memo;\nint rec(int idx, int m){\n  P state(idx, m);\n  if(memo.count(state)) return memo[state];\n  if(idx == v.size()) return memo[state] = 0;\n  if(v[idx] < m) return memo[state] = rec(idx + 1, m) + v[idx];\n  if(v[idx] == m) return memo[state] = rec(idx + 1, m + 1);\n  // rest\n  int cnt = 0;\n  //for(int i = m; i < v[idx]; i++) cnt += i;\n  int res = cnt + rec(idx + 1, v[idx] + 1);\n  //move\n  if(res > rec(idx + 1, m) + v[idx]){\n    res = rec(idx + 1, m) + v[idx];\n  }\n  return memo[state] = res;\n}\n\nint main(){\n  int N;\n  while(cin>>N){\n    memo.clear();\n    v = vector<int>(N);\n    REP(i, N) cin>>v[i];\n    cout<<rec(0, 1)<<endl;\n  }\n  return 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include<bits/stdc++.h>\n#define MAX (1<<17)\nusing namespace std;\n\ntypedef long long ll;\n\nint n;\nll st[MAX*2]={};\n\nvoid init(){\n  int tmp=1;\n  while(tmp<n)tmp*=2;\n  n=tmp;\n  //for(int i=0;i<n*2;i++)st[i]=0;\n}\n\nvoid update(int k,ll x){\n  k+=n-1;\n  st[k]=x;\n  while(k>0){\n    k=(k-1)/2;\n    st[k]=max(st[k*2+1],st[k*2+2]);\n  }\n}\n\nll find(int a,int b,int k,int l,int r){\n\n  if(r<=a || b<=l)return 0;\n\n  if(a<=l && r<=b)return st[k];\n\n  ll v1=find(a,b,k*2+1,l,(l+r)/2);\n  ll v2=find(a,b,k*2+2,(l+r)/2,r);\n  return max(v1,v2);\n}\n\nint main()\n{\n  ll a,ans=0,m;\n\n  cin>>n;\n\n  m=n;\n  ans=n*(n+1)/2;\n  init();\n\n  for(int i=0;i<m;i++){\n    cin>>a;\n    ll res=find(1,a,0,0,n);\n    update(a,a+res);\n  }\n\n  ans-=find(1,m,0,0,n);\n\n  cout<<ans<<endl;\n\n  return 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include <iostream>\n#include <algorithm>\n#include <set>\n#include <cstdio>\nusing namespace std;\n\ntypedef long long ll;\ntypedef pair<ll,ll> P;\n\nconst ll MAX = 100000;\n\nint main(){\n   int n;\n   while(cin >> n){\n     ll a[MAX],ans=0,sum=0;\n      set<P> s;\n      for(int i=0;i<n;i++) scanf(\"%d\",&a[i]);\n      for(int i=0;i<n;i++){\n\tll cnt = a[i];\n\tsum += a[i];\n\tif(i > 0){\n\t  set<P>::iterator it = s.end();\n\t  it--;\n\t  while(1){\n\t    it = s.lower_bound(P(it->first,0));\n\t    if(it->second < a[i]){\n\t      cnt += it->first;\n\t      break;\n\t    } else if(it == s.begin()) break;\n\t    else it--;\n\t  }\n\t}\n\tans = max(ans,cnt);\n\ts.insert(P(cnt,a[i]));\n      }\n      printf(\"%d\\n\",sum - ans);\n   }\n}"
  },
  {
    "language": "C++",
    "code": "#include<bits/stdc++.h>\n#define MAX (1<<17)\nusing namespace std;\n\ntypedef long long ll;\n\nll n;\nll st[MAX*2]={};\n\nvoid init(){\n  int tmp=1;\n  while(tmp<n)tmp*=2;\n  n=tmp;\n  for(int i=0;i<n*2;i++)st[i]=0;\n}\n\nvoid update(int k,ll x){\n  k+=n-1;\n  st[k]=x;\n  while(k>0){\n    k=(k-1)/2;\n    st[k]=max(st[k*2+1],st[k*2+2]);\n  }\n}\n\nll find(int a,int b,int k,int l,int r){\n\n  if(r<=a || b<=l)return 0;\n\n  if(a<=l && r<=b)return st[k];\n\n  ll v1=find(a,b,k*2+1,l,(l+r)/2);\n  ll v2=find(a,b,k*2+2,(l+r)/2,r);\n  return max(v1,v2);\n}\n\nint main()\n{\n  ll a,ans=0,m;\n\n  cin>>n;\n\n  m=n;\n  ans=n*(n+1)/2;\n  init();\n\n  for(int i=0;i<m;i++){\n    cin>>a;\n    ll res=find(1,a,0,0,n);\n    update(a,a+res);\n  }\n\n  ans-=find(1,m+1,0,0,n);\n\n  cout<<ans<<endl;\n\n  return 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include <iostream>\n#define llint long long\n#define inf (llint)1e18\n\nusing namespace std;\n\nint n;\nint x[100005];\nllint dp[100005];\n\nllint bit[100005];\n\nvoid init()\n{\n\tfor(int i = 1; i <= n; i++){\n\t\tbit[i] = i;\n\t}\n}\n\nllint query(int i)\n{\n\tllint ret = -inf;\n\twhile(i > 0){\n\t\tret = max(ret, bit[i]);\n\t\ti -= i&(-i);\n\t}\n\treturn ret;\n}\n\nvoid add(int i, llint val)\n{\n\twhile(i <= n){\n\t\tbit[i] = max(bit[i], val);\n\t\ti += i&(-i);\n\t}\n}\n\nint main(void)\n{\n\tcin >> n;\n\tfor(int i = 1; i <= n; i++) cin >> x[i];\n\t\n\tfor(int i = 1; i <= n; i++){\n\t\tdp[x[i]] = query(x[i]) + x[i];\n\t\tadd(x[i], dp[x[i]]);\n\t}\n\t\n\tllint ans = 0;\n\tfor(int i = 1; i <= n; i++) ans += i;\n\t\n\tllint maxdp = -1;\n\tfor(int i = 1; i <= n; i++){\n\t\tmaxdp = max(maxdp, dp[i]);\n\t}\n\tans -= maxdp;\n\t\n\tcout << ans << endl; \n\treturn 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include <stdio.h>\n#include <algorithm>\nusing namespace std;\nint n, a[100000], c[100000]; pair<int, int> b[100000]; long long sum, ret, dp[100001];\nint main() {\n\tscanf(\"%d\", &n);\n\tfor (int i = 0; i < n; i++) scanf(\"%d\", &a[i]), sum += a[i], b[i] = make_pair(a[i], i);\n\tsort(b, b + n);\n\tfor (int i = 0; i < n; i++) c[i] = b[i].second;\n\tfor (int i = 1; i <= n; i++) {\n\t\tdp[i] = a[i - 1];\n\t\tfor (int j = 0; j < a[i - 1]; j++) {\n\t\t\tif (c[j] < i - 1) {\n\t\t\t\tdp[i] = max(dp[i], dp[c[j] + 1] + a[i - 1]);\n\t\t\t}\n\t\t}\n\t}\n\tfor (int i = 1; i <= n; i++) ret = max(ret, dp[i]);\n\tprintf(\"%lld\\n\", sum - ret);\n\treturn 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include <iostream>\n#include <algorithm>\n#include <map>\n#include <cstdio>\nusing namespace std;\n\ntypedef long long ll;\ntypedef pair<ll,ll> P;\n\nconst ll MAX = 100000;\n\nint main(){\n    int n;\n    while(cin >> n){\n        ll a[MAX],ans=0;\n        map<ll,ll> s;\n        for(int i=0;i<n;i++) scanf(\"%lld\",&a[i]);\n        for(int i=0;i<n;i++){\n            ll cnt = 0;\n            if(i > 0){\n                for(map<ll,ll>::iterator it = s.end();; it--){\n                    if(it == s.end()) it--;\n                    if(it->second < a[i]){\n                        cnt = it->first;\n                        break;\n                    }\n                    if(it == s.begin()) break;\n                }\n            }\n            ans = max(ans,cnt+a[i]);\n            if(s.find(cnt+a[i]) == s.end() || s[cnt+a[i]] > a[i]) s[cnt+a[i]] = a[i];\n        }\n        printf(\"%lld\\n\",(ll)n*(n+1)/2 - ans);\n    }\n}"
  },
  {
    "language": "C++",
    "code": "// template {{{\n\n#include <bits/stdc++.h>\nusing namespace std;\n\n#define loop(i, a, b) for (int i = (int)(a); i < (int)(b); i++)\n#define rep(i, n) loop(i, 0, n)\n#define rloop(i, a, b) for (int i = (int)(b) - 1; i >= (int)(a); i--)\n#define rrep(i, n) rloop(i, 0, n)\n#define eb emplace_back\n#define ef emplace_front\n#define pb pop_back\n#define pf pop_front\n#define all(c) std::begin(c), std::end(c)\n#define mp std::make_pair\n#define mt std::make_tuple\n#define fi first\n#define se second\n#define popcnt __builtin_popcountll\n\nusing uint = unsigned;\nusing ll = long long;\nusing ull = unsigned long long;\nusing ld = long double;\n\ntemplate<typename T>\nusing max_pq = priority_queue<T, vector<T>, less<T>>;\n\ntemplate<typename T>\nusing min_pq = priority_queue<T, vector<T>, greater<T>>;\n\nconst int MOD = 1e9 + 7;\nconst int INF = 1e9 + 10;\nconst ll LLINF = 1e18 + 10;\n\nconst int dx[] = {-1, 0, 1, 0};\nconst int dy[] = {0, -1, 0, 1};\nconst int dx8[] = {-1, -1, 0, 1, 1, 1, 0, -1};\nconst int dy8[] = {0, -1, -1, -1, 0, 1, 1, 1};\n\ntemplate<typename T>\ninline T sq(T x){ return x * x; }\n\ntemplate<typename T, typename U>\ninline bool chmax(T &x, U y){ if (x >= y) return false; x = y; return true; }\n\ntemplate<typename T, typename U>\ninline bool chmin(T &x, U y){ if (x <= y) return false; x = y; return true; }\n\ntemplate<typename T>\ninline void sort(T &c){ std::sort(std::begin(c), std::end(c)); }\n\ntemplate<typename T>\ninline void reverse(T &c){ std::reverse(std::begin(c), std::end(c)); }\n\ntemplate<typename T>\ninline void unique(T &c){ std::sort(std::begin(c), std::end(c)); c.erase(std::unique(all(c)), std::end(c)); }\n\n// }}}\n\nstruct FenwickTree {\n\tFenwickTree(size_t n): n(n), val(n + 1){}\n\t\n\tvoid chmax(int k, ll x){\n\t\tk++;\n\t\twhile (k <= n){\n\t\t\t::chmax(val[k], x);\n\t\t\tk += k & -k;\n\t\t}\n\t}\n\n\tll max(int k){\n\t\tll res = 0;\n\t\twhile (k > 0){\n\t\t\t::chmax(res, val[k]);\n\t\t\tk -= k & -k;\n\t\t}\n\t\treturn res;\n\t}\n\nprivate:\n\tint n;\n\tvector<ll> val;\n};\n\nint main()\n{\n\tint n;\n\tcin >> n;\n\n\tFenwickTree t(n + 1);\n\trep(i, n){\n\t\tint x;\n\t\tcin >> x;\n\t\tt.chmax(x, t.max(x) + x);\n\t}\n\n\tcout << (ll)n * (n + 1) / 2 - t.max(n + 1) << endl;\n}"
  },
  {
    "language": "C++",
    "code": "#include <queue>\n#include <cmath>\n#include <algorithm>\n#include <cstdio>\n#include <set>\n\n#define REP(i,n) for(int i=0; i<(int)(n); i++)\n\ntypedef long long ll;\n\ninline int getInt(){ int s; scanf(\"%d\", &s); return s; }\n\nusing namespace std;\n\nclass BIT{\n  vector<ll> bit;\npublic:\n  BIT(int n) : bit(n + 1) {}\n  void update(int idx, ll val){\n    idx++;\n    while(idx < (int)bit.size()){\n      bit[idx] = max(bit[idx], val);\n      idx += idx & -idx;\n    }\n  }\n\n  ll p(int i){\n    ll s = 0;\n    i++;\n    while(i > 0){\n      s = max(s, bit[i]);\n      i -= i & -i;\n    }\n    return s;\n  }\n};\n\nint main(){\n  const int n = getInt();\n  BIT bit(n + 1);\n\n  REP(i,n){\n    const int x = getInt();\n    bit.update(x, bit.p(x) + x);\n  }\n\n  printf(\"%lld\\n\", (ll)n * (ll)(n + 1) / 2 - bit.p(n));\n\n  return 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include <cstdio>\n#include <cstdlib>\n#include <cstring>\n#include <climits>\n#include <cassert>\n#include <iostream>\n#include <iomanip>\n#include <sstream>\n#include <algorithm>\n#include <numeric>\n#include <complex>\n#include <stack>\n#include <queue>\n#include <list>\n#include <set>\n#include <map>\n#include <bitset>\n#include <functional>\n#include <iterator>\n\nusing namespace std;\n\n#define dump(n) cout<<\"# \"<<#n<<\"=\"<<(n)<<endl\n#define repi(i,a,b) for(int i=int(a);i<int(b);i++)\n#define peri(i,a,b) for(int i=int(b);i-->int(a);)\n#define rep(i,n) repi(i,0,n)\n#define per(i,n) peri(i,0,n)\n#define iter(c) __typeof__((c).begin())\n#define foreach(i,c) for(iter(c) i=(c).begin();i!=(c).end();++i)\n#define all(c) (c).begin(),(c).end()\n#define mp make_pair\n\ntypedef unsigned int uint;\ntypedef long long ll;\ntypedef unsigned long long ull;\ntypedef vector<int> vi;\ntypedef vector<vi> vvi;\ntypedef vector<double> vd;\ntypedef vector<vd> vvd;\ntypedef vector<string> vs;\ntypedef pair<int,int> pii;\n\nconst int INFTY=1<<29;\nconst double EPS=1e-9;\n\ntemplate<typename T1,typename T2>\nostream& operator<<(ostream& os,const pair<T1,T2>& p){\n\treturn os<<'('<<p.first<<','<<p.second<<')';\n}\ntemplate<typename T>\nostream& operator<<(ostream& os,const vector<T>& a){\n\tos<<'[';\n\trep(i,a.size()) os<<(i?\" \":\"\")<<a[i];\n\treturn os<<']';\n}\n\nstruct SegTree{\n\tvector<ll> data;\n\tint size;\n\tSegTree(int _size){\n\t\tfor(int i=1;;i<<=1)\n\t\t\tif(i>=_size){\n\t\t\t\tsize=i;\n\t\t\t\tbreak;\n\t\t\t}\n\t\tdata.assign(2*size,0);\n\t}\n\tvoid Update(int i,ll n){\n\t\tfor(int j=size+i;j;j>>=1)\n\t\t\tdata[j]=max(data[j],n);\n\t}\n\tll Query(int a,int b,int i,int l,int r){\n\t\tif(b<=l || r<=a) return 0;\n\t\tif(a<=l && r<=b) return data[i];\n\t\tll res=0;\n\t\tint m=(l+r)/2;\n\t\tif(a<m) res=max(res,Query(a,b,i*2+0,l,m));\n\t\tif(m<b) res=max(res,Query(a,b,i*2+1,m,r));\n\t\treturn res;\n\t}\n\tll Query(int a,int b){\n\t\treturn Query(a,b,1,0,size);\n\t}\n};\n\nint main()\n{\n\tfor(int n;cin>>n;){\n\t\tvi a(n);\n\t\trep(i,n) cin>>a[i];\n\t\t\n\t\tvi b(n);\n\t\trep(i,n) b[a[i]-1]=i;\n\t\t\n\t\tSegTree st(n);\n\t\tll mx=0;\n\t\trep(i,n){\n\t\t\tst.Update(b[i],+st.Query(0,b[i])+i+1);\n\t\t\tmx=max<ll>(mx,st.Query(0,b[i]+1));\n\t\t}\n\t\tcout<<(ll)n*(n+1)/2-mx<<endl;\n\t}\n\t\n\treturn 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include <iostream>\n#include <algorithm>\n#include <utility>\n#include <vector>\n#include <list>\n#include <map>\n#include <set>\n#include <queue>\n#include <stack>\n#include <string>\n#include <sstream>\n#include <cstring>\n#include <cstdlib>\n\nusing namespace std;\n\n#define ALL(c) c.begin(),c.end()\n#define RALL(c) c.rbegin(),c.rend()\n#define SORT(x) sort((x).begin(),(x).end())\n#define REP(i,x,y) for(int i=(x);i<(y);++i)\n#define MP(a,b) make_pair((a),(b))\n#define F_ first\n#define S_ second\n#define debug(x) #x << \"=\" << (x)\n \n#ifdef DEBUG\n#define _GLIBCXX_DEBUG\n#define dump(x) std::cerr << debug(x) << \" (L:\" << __LINE__ << \")\" << std::endl\n#else\n#define dump(x)\n#endif\n\ntypedef long long int lli;\ntypedef pair<int,int> pii;\ntemplate<typename T> using vec=std::vector<T>;\n\nconst int INF=1<<30;\nconst long long int INF_=1LL<<58;\nconst double EPS=1e-9;\nconst int dx[]={1,0,-1,0},dy[]={0,1,0,-1};\n\ntemplate <typename T> ostream &operator<<(ostream &os, const vector<T> &vec){\n\tos << \"[\";\n\tfor (const auto &v : vec) {\n\t\tos << v << \",\";\n\t}\n\tos << \"]\";\n\treturn os;\n}\n\nint main(){\n\tstd::ios::sync_with_stdio(false);\n\tstd::cin.tie(0);\n\tint N;\n\tcin >> N;\n\tvec<int> x(N);\n\tREP(i,0,N) cin >> x[i];\n\tvec<int> s(N);\n\ts[0]=x[0];\n\tREP(i,1,N) s[i]+=s[i-1]+x[i];\n\tvec<vec<int>> dp(N,vec<int>(2));\n\tdp[0][0]=x[0];\n\tREP(i,1,N){\n\t\tdp[i][0]=min(dp[i-1][0],dp[i-1][1])+x[i];\n\t\tdp[i][1]=s[i-1];\n\t\tfor(int j=i-1; j>=0; --j) if(x[i]>x[j]){\n\t\t\tdp[i][1]=min(dp[i][1],dp[j][1]+s[i-1]-s[j]);\n\t\t}\n\t}\n\t//cout << dp << endl;\n\tcout << min(dp[N-1][1],dp[N-1][0]) << endl;\n\treturn 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include <cassert>\n#include <cstdlib>\n#include <iostream>\n#include <vector>\nusing namespace std;\n\ntemplate<class T> inline void chmax(T& a, const T& b) { if(b > a) a = b; }\n\ntypedef long long value; // 格納するデータの型\nconst value INIT = 0ll; // 初期値．目的に応じて，適切な値に変更すること．\n\nclass segment_tree {\nprivate:\n\tint n;\n\tvector<value> dat;\n\n\tvalue func(value a, value b) const { // ノードの値を決める為の関数\n\t\treturn max(a, b);\n\t}\n\n\tvalue query(int a, int b, int k, int l, int r) const {\n\t\tif(r <= a || b <= l) // 求める区間が，ノードの区間と重なっていない．\n\t\t\treturn INIT;\n\n\t\tif(a <= l && r <= b) { // 求める区間が，ノードの区間を完全に含む．\n\t\t\treturn dat[k];\n\t\t}\n\t\telse {\n\t\t\tconst int mid = (l + r) / 2;\n\t\t\tconst value vl = query(a, b, k * 2 + 1, l, mid);\n\t\t\tconst value vr = query(a, b, k * 2 + 2, mid, r);\n\t\t\treturn func(vl, vr);\n\t\t}\n\t}\n\npublic:\n\tsegment_tree(int n_) {\n\t\tn = 1;\n\t\twhile(n < n_)\n\t\t\tn *= 2;\n\n\t\tdat.assign(2 * n, INIT);\n\t}\n\n\tvoid update(int k, value a) { // k番目の要素をaに更新する．\n\t\tk += n - 1;\n\t\tdat[k] = a;\n\t\twhile(k > 0) {\n\t\t\tk = (k - 1) / 2;\n\t\t\tdat[k] = func(dat[k * 2 + 1], dat[k * 2 + 2]);\n\t\t}\n\t}\n\n\tvalue query(int a, int b) { // [a, b)に対するクエリ\n\t\treturn query(a, b, 0, 0, n);\n\t}\n};\n\nint main() {\n\tcin.tie(0);\n\tios::sync_with_stdio(false);\n\n\tint m;\n\tcin >> m;\n\n\tsegment_tree segt(m);\n\n\tlong long mx = 0;\n\tfor(int i = 0; i < m; ++i) {\n\t\tint w;\n\t\tcin >> w;\n\n\t\tlong long tmp = segt.query(1, w) + w;\n\t\tsegt.update(w, tmp);\n\t\tchmax(mx, tmp);\n\t}\n\n\tcout << ((m + 1ll) * m / 2ll - mx) << endl;\n\treturn EXIT_SUCCESS;\n}"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\ntemplate <typename T>\nclass SegmentTreeUpdMax {\n    int n;\n    const T inf_min = std::numeric_limits<T>::min();\n    std::vector<T> node;\npublic:\n    SegmentTreeUpdMax(std::vector<T> v) {\n        int sz = v.size();\n        n = 1; while(n < sz) n *= 2;\n        node.resize(2*n, inf_min);\n        for(int i=0;i<sz;++i) node[i+n-1] = v[i];\n        for(int i=n-2;i>=0;--i) node[i] = std::max(node[2*i+1], node[2*i+2]);\n    }\n    void update(int idx, T val) {\n        assert(0 <= idx && idx < n);\n        node[idx + n - 1] = val;\n        idx = idx + n - 1;\n        while(idx > 0) {\n            idx = (idx - 1) / 2;\n            node[idx] = std::max(node[2*idx + 1], node[2 * idx + 2]);\n        }\n    }\n    T query(int a, int b, int k, int l, int r) {\n        if(r <= a || b <= l) return inf_min;\n        if(a <= l && r <= b) return node[k];\n        T vl = query(a, b, k*2+1, l, ((l+r)/2));\n        T vr = query(a, b, k*2+2, (l+r)/2, r);\n        return std::max(vl, vr);\n    }\n    T query(int a, int b) {\n        return query(a, b, 0, 0, n);\n    }\n};\nusing namespace std;\nusing ll = long long;\nusing ld = long double;\nusing P = pair<int, int>;\nusing vi = vector<int>;\nusing vvi = vector<vector<int>>;\nusing vll = vector<ll>;\nusing vvll = vector<vector<ll>>;\nconst double eps = 1e-10;\nconst ll MOD = 1000000007;\nconst int INF = 1000000000;\nconst ll LINF = 1ll<<50;\ntemplate<typename T>\nvoid printv(const vector<T>& s) {\n  for(int i=0;i<(int)(s.size());++i) {\n    cout << s[i];\n    if(i == (int)(s.size())-1) cout << endl;\n    else cout << \" \";\n  }\n}\ntemplate<typename T1, typename T2>\nostream& operator<<(ostream &os, const pair<T1, T2> p) {\n  os << p.first << \":\" << p.second;\n  return os;\n}\nint main() {\n  cin.tie(0);\n  ios::sync_with_stdio(false);\n  cout << fixed << setprecision(10);\n  ll n; cin >> n;\n  vll x(n);\n  for(int i=0;i<n;++i) {\n    cin >> x[i];\n  }\n  vll node(n+1);\n  SegmentTreeUpdMax<ll> st(node);\n  for(int i=0;i<n;++i) {\n    ll tmp = x[i] + st.query(0, x[i]);\n    st.update(x[i], tmp);\n  }\n  ll mi = LINF;\n  for(int i=1;i<=n+1;++i) {\n    mi = min(mi, (ll)(n * (n + 1) / 2 - st.query(0, i)));\n  }\n  cout << mi << endl;\n}\n\n"
  },
  {
    "language": "C++",
    "code": "#include<iostream>\n#include<cstdio>\n#include<cstdlib>\n#include<cmath>\n#include<algorithm>\n#include<cstring>\n#include<sstream>\n#include<vector>\n#include<queue>\n#include<stack>\n#include<string>\n#include<climits>\n#include<map>\n#include<set>\n#include<cassert>\n#include<deque>\n#define REP(i,s,n) for(int i=s;i<n;i++)\n#define rep(i,n) REP(i,0,n)\n#define INF 1<<27\n#define all(n) n.begin(),n.end()\n#define insert(a,b,c,d) PP(P(a,b),P(c,d))\n#define F first\n#define S second\n#define pb push_back\n#define MAX_N (1<<18)\n#define foreach(i,c) for(iter(c) i=(c).begin();i!=(c).end();++i)\nusing namespace std;\ntypedef pair<int,int> P;\ntypedef pair<P,P> PP;\ntypedef long long ll;\n\n\n\n\n\ntemplate<class T>\nclass RMQ_segment{\nprivate:\n  int n;\n  T dat[2*MAX_N-1];\npublic:\n  void init(int n_){\n    n = 1;\n    while(n<n_)n*=2;\n    for(int i=0;i<2*n-1;i++)dat[i] = 0;\n  }\n\n  void update(int k,T a){\n    k += n-1;\n    dat[k] = a;\n    while(k > 0){\n      k = (k-1)/2;\n      dat[k] = max(dat[k*2+1],dat[k*2+2]);\n    }\n  }\n\n  T _query(int a,int b,int k,int l,int r){\n    if(r<=a || b<=l)return 0;\n    else if(a<=l && r<=b)return dat[k];\n    \n      T vl = _query(a,b,k*2+1,l,(l+r)/2);\n      T vr = _query(a,b,k*2+2,(l+r)/2,r);\n      return max(vl,vr);\n    \n  }\n\n  T query(int a,int b){//nの範囲でミスしないように極力こっちを利用\n    return _query(a,b,0,0,n);\n  }\n\n};\n\n\n int x[1000010];\n RMQ_segment<ll> rmq;\nint main(){\n  int n;\n  cin >> n;\n \n  rmq.init(n+1);\n \n  rep(i,n)cin >> x[i];\n  ll mex=0;\n  ll sum=0;\n\n  for(int i=0;i<n;i++){\n    sum+=x[i];\n    ll premex = rmq.query(0,x[i])+x[i];\n    rmq.update(x[i],premex);\n    mex = max(mex,premex);\n   \n  }  \n  \n  cout << sum-mex << endl;\n\nreturn 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\n\nusing namespace std;\n\ntypedef long long ll;\n\nstruct SegmentTree{\n  ll data[500010];\n  int sz;\n  void init(int n){\n    sz = 1;\n    while(sz < n) sz *= 2;\n    memset(data, 0LL, sizeof(data));\n  }\n  void update(int k, ll x){\n    k += sz - 1;\n    data[k] = x;\n    while(k > 0){\n      k = (k - 1) / 2;\n      data[k] = max(data[2*k+1], data[2*k+2]);\n    }\n  }\n  ll at(int k){\n    return data[k+sz-1];\n  }\n  ll query(int a, int b, int k, int l, int r){\n    if(r <= a || b <= l) return 0;\n    if(a <= l && r <= b) return data[k];\n    ll left = query(a, b, 2*k+1, l, (l+r)/2);\n    ll right = query(a, b, 2*k+2, (l+r)/2, r);\n    return max(left, right);\n  }\n  ll query(int a, int b){\n    return query(a, b, 0, 0, sz);\n  }\n  int size(){\n    return sz;\n  }\n};\n\nint main()\n{\n  SegmentTree tree;  \n  int n;\n  cin >> n;\n  tree.init(n);\n  ll maxcost = 0;\n  for(int i = 0; i < n; i++){\n    ll x; cin >> x;\n    ll cost = tree.query(1, x+1);\n    tree.update(x, cost + x);\n    maxcost = max(maxcost, tree.at(x));\n  }\n  cout << ((ll)n+1LL)*n/2LL - maxcost << endl;\n  return 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include <cstdio>\n#include <algorithm>\n\nusing namespace std;\ntypedef long long ll;\n\nll seg[1 << 18];\nint size;\n\nvoid init(int n)\n{\n\tsize = 1;\n\twhile (size < n) size *= 2;\n}\n\nvoid update(int k, ll x)\n{\n\tk += size - 1;\n\tseg[k] = x;\n\t\n\twhile (k){\n\t\tk = (k - 1) / 2;\n\t\tseg[k] = max(seg[k * 2 + 1], seg[k * 2 + 2]);\n\t}\n}\n\nll getMax(int a, int b, int k, int l, int r)\n{\n\tif (r <= a || b <= l){\n\t\treturn (0);\n\t}\n\t\n\tif (a <= l && r <= b){\n\t\treturn (seg[k]);\n\t}\n\tll lch = getMax(a, b, k * 2 + 1, l, (l + r) / 2);\n\tll rch = getMax(a, b, k * 2 + 2, (l + r) / 2, r);\n\t\n\treturn (max(lch, rch));\n}\n\nint main()\n{\n\tll n;\n\tll ans;\n\tint data;\n\t\n\tscanf(\"%lld\", &n);\n\t\n\tinit(n);\n\tans = 0;\n\t\n\tfor (int i = 0; i < n; i++){\n\t\tscanf(\"%d\", &data);\n\t\tupdate(data, getMax(1, data + 1, 0, 0, size) + data);\n\t\tans = max(ans, seg[data + size - 1]);\n\t}\n\t\n\tprintf(\"%lld\\n\", n * (n + 1) / 2 - ans);\n\t\n\treturn (0);\n}"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\nusing namespace std;\n\nint main() {\n\tlong long int N;\n\tcin >> N;\n\tvector<long long int >data( N );\n\tlong long int sum = 0;\n\tfor( size_t i = 0; i < N; i++ ) {\n\t\tcin >> data[i];\n\t\tsum += data[i];\n\t}\n\tvector<long long int>dp( N + 1, LLONG_MIN );\n\tdp[0] = 0;\n\tlong long int maxnum = 0;\n\tfor( size_t i = 0; i < N; i++ ) {\n\t\tfor( size_t j = 0; j < data[i]; j++ ) {\n\t\t\tdp[data[i]] = max( dp[data[i]], dp[j] + data[i] );\n\t\t\tmaxnum = max( dp[data[i]], maxnum );\n\t\t}\n\t}\n\tcout << sum - maxnum << endl;\n}"
  },
  {
    "language": "C++",
    "code": "#include <cstdio>\n#include <cstdlib>\n#include <cmath>\n#include <cstring>\n\n#include <iostream>\n#include <complex>\n#include <string>\n#include <algorithm>\n#include <numeric>\n#include <vector>\n#include <queue>\n#include <stack>\n#include <map>\n#include <set>\n#include <unordered_map>\n#include <unordered_set>\n\n#include <functional>\n#include <cassert>\n\ntypedef long long ll;\nusing namespace std;\n\n#ifndef LOCAL\n#define debug(x) ;\n#else\n#define debug(x) cerr << __LINE__ << \" : \" << #x << \" = \" << (x) << endl;\n\ntemplate <typename T1, typename T2>\nostream &operator<<(ostream &out, const pair<T1, T2> &p) {\n  out << \"{\" << p.first << \", \" << p.second << \"}\";\n  return out;\n}\n\ntemplate <typename T>\nostream &operator<<(ostream &out, const vector<T> &v) {\n  out << '{';\n  for (const T &item : v) out << item << \", \";\n  out << \"\\b\\b}\";\n  return out;\n}\n#endif\n\n#define mod 1000000007 //1e9+7(prime number)\n#define INF 1000000000 //1e9\n#define LLINF 2000000000000000000LL //2e18\n#define SIZE 200010\n\n/* SimpleSegTree(0-index) */\n\ntemplate <typename Type = int>\nstruct SimpleSegTree{\n  int segn2;\n  Type initVal;\n  vector<Type> data;\n  function<Type(Type, Type)> merge;\n\n  SimpleSegTree(int n, Type initVal, function<Type(Type, Type)> merge):\n    initVal(initVal), merge(merge)\n  {\n    for(segn2=1; segn2<n; segn2*=2);\n    data.assign(segn2*2, initVal);\n  }\n\n  SimpleSegTree(int n): //RangeMinimunQuery\n    SimpleSegTree(n, LLINF, [](Type a, Type b){ return min(a, b); }) {}\n\n  SimpleSegTree(int n, Type initVal): //RangeMinimunQuery\n    SimpleSegTree(n, initVal, [](Type a, Type b){ return min(a, b); }) {}\n\n  //get value [a,b)\n  Type query(int a, int b, int l = 0, int r = -1, int k = 0){\n    if(r == -1) r = segn2;\n    if(a <= l && r <= b) return data[k];\n    if(r <= a || b <= l) return initVal;\n    return merge(query(a,b,l,(l+r)/2,k*2+1),query(a,b,(l+r)/2,r,k*2+2));\n  }\n\n  //set kth number x\n  void set(int k, Type x){\n    k += segn2-1;\n    data[k] = x;\n    while(k > 0){\n      k = (k-1)/2;\n      data[k] = merge(data[k*2+1], data[k*2+2]);\n    }\n  }\n};\n\n\nint main(){\n  int N, x;\n  pair<int,int> p[SIZE];\n\n  scanf(\"%d\", &N);\n\n  SimpleSegTree<ll> seg(N+1);\n\n  seg.set(0, (ll)N * (N + 1) / 2);\n\n  for (int i=0; i<N; i++) {\n    scanf(\"%d\", &x);\n\n    ll v = seg.query(0, x);\n    seg.set(x, v-x);\n  }\n\n  cout << seg.query(0, N+1) << endl;\n\n  return 0;\n}\n\n"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\nusing namespace std;\n\n#define for_(i,a,b) for(int i=(a);i<(b);++i)\n#define for_rev(i,a,b) for(int i=(a);i>=(b);--i)\n\nint n, x[100010];\nint dp[100010], sum[100010];\n\nint main() {\n\tcin >> n;\n\tfor_(i,0,n) cin >> x[i];\n\t\n\tmemset(dp, 0, sizeof(dp));\n\tmemset(sum, 0, sizeof(sum));\n\t\n\tdp[n] = 100010;\n\t\n\tfor_rev(i,n-1,0) {\n\t\tint ind = lower_bound(dp, dp + n + 1, x[i]) - dp - 1;\n\t\t\t\t\n\t\tif (sum[ind] <= sum[ind + 1] + x[i]) {\n\t\t\tdp[ind] = x[i];\n\t\t\tsum[ind] = sum[ind + 1] + x[i];\n\t\t}\n\t}\n\t\n\tcout << (n * (n + 1) / 2 - *max_element(sum, sum + n)) << endl;\n}"
  },
  {
    "language": "C++",
    "code": "#include <iostream>\n#include <vector>\n#include <algorithm>\n\nusing namespace std;\n\nint main(){\n    \n    long long n, x;\n    cin >> n;\n    vector<int> seg(n+1, 0);\n    \n    for(int i = 0; i < n; i++){\n        cin >> x;\n        long long sum = 0;\n        for(int j = x-1; j > 0; j = j & (j-1)){\n            if(seg[j] > sum)\n                sum = seg[j];\n        }\n        for(int j = x; j < n + 1; j += (j & -j)){\n            if(sum + x > seg[j]){\n                seg[j] = sum + x;\n            }\n        }\n    }\n    \n    long long ans = 0;\n    for(int j = n; j > 0; j = j & (j-1)){\n        if(seg[j] > ans)\n            ans = seg[j];\n    }\n    cout << (n*(n+1))/2 - ans <<endl;\n    \n}"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\n\nusing namespace std;\n\ntypedef long long ll;\n\nstruct SegmentTree{\n  ll data[200010];\n  int sz;\n  void init(int n){\n    sz = 1;\n    while(sz < n) sz *= 2;\n    memset(data, 0LL, sizeof(data));\n  }\n  void update(int k, ll x){\n    k += sz - 1;\n    data[k] = x;\n    while(k > 0){\n      k = (k - 1) / 2;\n      data[k] = max(data[2*k+1], data[2*k+2]);\n    }\n  }\n  ll at(int k){\n    return data[k+sz-1];\n  }\n  ll query(int a, int b, int k, int l, int r){\n    if(r <= a || b <= l) return -1;\n    if(a <= l && r <= b) return data[k];\n    ll left = query(a, b, 2*k+1, l, (l+r)/2);\n    ll right = query(a, b, 2*k+2, (l+r)/2, r);\n    return max(left, right);\n  }\n  ll query(int a, int b){\n    return query(a, b, 0, 0, sz);\n  }\n  int size(){\n    return sz;\n  }\n};\n\nint main()\n{\n  SegmentTree tree;  \n  int n;\n  cin >> n;\n  tree.init(n);\n  ll maxcost = 0;\n  for(int i = 0; i < n; i++){\n    ll x;\n    cin >> x;\n    ll cost = tree.query(1, x+1);\n    tree.update(x, cost + x);\n    maxcost = max(maxcost, tree.at(x));\n  }\n  cout << ((ll)n+1LL)*n/2LL - maxcost << endl;\n  return 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\nusing namespace std;\nusing ll = long long;\n\ntemplate <typename T>\nclass SegmentTree {\n\tconst int n;\n\tconst T id;\n\tvector<T> data;\n\tint size(int n) {\n\t\tint res;\n\t\tfor (res = 1; res < n; res <<= 1);\n\t\treturn res;\n\t}\npublic:\n\tSegmentTree(int n_, T id_) :\n\t\tn(size(n_)), id(id_), data(size(n_) * 2, id_) {}\n\tvoid Update(int p, T val) {\n\t\tp += n;\n\t\tdata[p] = val;\n\t\twhile (p >>= 1) data[p] = max(data[p * 2], data[p * 2 + 1]);\n\t}\n\tT Find(int l, int r) {\n\t\tif (r < l) return id;\n\t\tl += n; r += n + 1;\n\t\tT res1 = id, res2 = id;\n\t\twhile (l != r) {\n\t\t\tif (l & 1) res1 = max(res1, data[l++]);\n\t\t\tif (r & 1) res2 = max(data[--r], res2);\n\t\t\tl >>= 1; r >>= 1;\n\t\t}\n\t\treturn max(res1, res2);\n\t}\n};\n\nint main()\n{\n\tcin.sync_with_stdio(false);\n\tint n, x;\n\tcin >> n;\n\tSegmentTree<ll> st(n, 0);\n\tfor (int i = 0; i < n; i++) {\n\t\tcin >> x; x--;\n\t\tst.Update(x, st.Find(0, x - 1) + x + 1);\n\t}\n\tprintf(\"%lld\\n\", (ll)n * (n + 1) / 2 - st.Find(0, n - 1));\n\treturn 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\n\nusing namespace std;\n\ntypedef long long ll;\n\nstruct SegmentTree{\n  ll data[100010];\n  int sz;\n  void init(int n){\n    sz = 1;\n    while(sz < n) sz *= 2;\n    memset(data, 0LL, sizeof(data));\n  }\n  void update(int k, ll x){\n    k += sz - 1;\n    data[k] = x;\n    while(k > 0){\n      k = (k - 1) / 2;\n      data[k] = max(data[2*k+1], data[2*k+2]);\n    }\n  }\n  ll at(int k){\n    return data[k+sz-1];\n  }\n  ll query(int a, int b, int k, int l, int r){\n    if(r <= a || b <= l) return -1;\n    if(a <= l && r <= b) return data[k];\n    ll left = query(a, b, 2*k+1, l, (l+r)/2);\n    ll right = query(a, b, 2*k+2, (l+r)/2, r);\n    return max(left, right);\n  }\n  ll query(int a, int b){\n    return query(a, b, 0, 0, sz);\n  }\n  int size(){\n    return sz;\n  }\n};\n\nint main()\n{\n  SegmentTree tree;  \n  int n;\n  cin >> n;\n  tree.init(n);\n  ll maxcost = 0;\n  for(int i = 0; i < n; i++){\n    ll x;\n    cin >> x;\n    ll cost = tree.query(1, x+1);\n    tree.update(x, cost + x);\n    maxcost = max(maxcost, tree.at(x));\n  }\n  cout << ((ll)n+1)*n/2 - maxcost << endl;\n  return 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include \"bits/stdc++.h\"\n\nusing namespace std;\n\ntypedef long long ll;\ntypedef pair<int,int> P;\nconst double EPS = 1e-12;\nconst int INF = numeric_limits<int>::max()/2;\nconst int MOD = 1e9+7;\n\nstruct RMQ {\n\tusing type = ll;\n\tstatic type id() { return 0; }\n\tstatic type op(const type& l, const type & r) { return max(l, r); }\n};\n\nstruct RSQ {\n\tusing type = int;\n\tstatic type id() { return 0; }\n\tstatic type op(const type& l, const type & r) { return l + r; }\n};\n\nstruct RMSQ {\n\tstruct type {\n\t\tll left, right, all, sum;\n\t\ttype() : left(-INF), right(-INF), all(-INF), sum(0) {}\n\t\ttype(ll val) : left(val), right(val), all(val), sum(val) {}\n\t\ttype(ll l, ll r, ll a, ll s) : left(l), right(r), all(a), sum(s) {}\n\t};\n\tstatic type id() { return type(); }\n\tstatic type op(const type& l, const type & r) {\n\t\treturn type(max(l.left, l.sum + r.left), max(r.right, r.sum + l.right), max({ l.all, r.all, l.right + r.left }), l.sum + r.sum);\n\t}\n};\n\n// segment tree\ntemplate <typename M>\nclass segment_tree {\n\tusing T = typename M::type;\n\tconst int n;\n\tvector<T> data;\n\tint size(int n) {\n\t\tint res;\n\t\tfor (res = 1; res < n; res <<= 1);\n\t\treturn res;\n\t}\npublic:\n\tsegment_tree(int n_) : n(size(n_)), data(n * 2, M::id()) {}\n\tsegment_tree(int n_, T val) : n(size(n_)), data(n * 2, val) {}\n\tvoid init(const vector<T>& data_) {\n\t\tfor (int i = 0; i < (int)data_.size(); i++)\n\t\t\tdata[i + n] = data_[i];\n\t\tfor (int i = n - 1; i >= 0; i--)\n\t\t\tdata[i] = M::op(data[i * 2], data[i * 2 + 1]);\n\t}\n\tvoid update(int p, T val) {\n\t\tp += n;\n\t\tdata[p] = val;\n\t\twhile (p >>= 1) data[p] = M::op(data[p * 2], data[p * 2 + 1]);\n\t}\n\tvoid add(int p, T val) {\n\t\tp += n;\n\t\tdata[p] += val;\n\t\twhile (p >>= 1) data[p] = M::op(data[p * 2], data[p * 2 + 1]);\n\t}\n\tT find(int l, int r) {\n\t\tl += n; r += n + 1;\n\t\tT res1 = M::id(), res2 = M::id();\n\t\twhile (l < r) {\n\t\t\tif (l & 1) res1 = M::op(res1, data[l++]);\n\t\t\tif (r & 1) res2 = M::op(data[--r], res2);\n\t\t\tl >>= 1; r >>= 1;\n\t\t}\n\t\treturn M::op(res1, res2);\n\t}\n};\n\nint main(){\n    cin.tie(0);\n    ios::sync_with_stdio(false);\n\n    int n;cin>>n;\n    vector<int> x(n);\n    for(int i=0;i<n;i++) cin>>x[i];\n    segment_tree<RMQ> st(111111);\n    vector<ll> dp(111111,0);\n    ll res=0,sum=0;\n    for(int i=0;i<n;i++){\n        dp[i] = st.find(0,x[i]-1) + x[i];\n        st.update(x[i],dp[i]);\n        res=max(res,dp[i]);\n        sum += x[i];\n    }\n    cout<<sum-res<<endl;\n\n}\n"
  },
  {
    "language": "C++",
    "code": "#include<iostream>\n#include<algorithm>\n\nusing namespace std;\n\ntypedef long long Int;\n\nInt bit[105000], num[105000], n;\n\nvoid setnum(int pos, Int val){\n\twhile(pos < 105000){\n\t\tbit[pos] = max(val, bit[pos]);\n\t\tpos += pos & -pos;\n\t}\n}\n\nInt maxnum(int pos){\n\tInt res = 0;\n\twhile(pos){\n\t\tres = max(res, bit[pos]);\n\t\tpos -= pos &-pos;\n\t}\n\treturn res;\n}\n\nInt solve(){\n\tfill(bit, bit + 105000, 0);\n\tInt n, sum = 0, x;\n\tfor(int i = 0;i < n;i++){\n\t\tx = num[i];\n\t\tsum += x;\n\t\tInt p = x + maxnum(x);\n\t\tsetnum(x, p);\n\t}\n\treturn sum - maxnum(10100);\n}\n\nint main(){\n\tcin >> n;\n\tfor(int i = 0;i < n;i++)cin >> num[i];\n\tInt res = solve();\n\tfor(int i = 0;i < n;i++){\n\t\tint p = n - i - 1;\n\t\tif(p <= i)break;\n\t\tswap(num[p], num[i]);\n\t}\n\tcout << min(res, solve()) << endl;\n\treturn 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include <iostream>\n#include <string>\n#include <vector>\n#include <algorithm>\n#include <queue>\n#include <set>\n#include <map>\n#include <cmath>\nusing namespace std;\ntypedef long long i64;\ntypedef long double ld;\ntypedef pair<i64,i64> P;\n#define rep(i,s,e) for(int i = (s);i <= (e);i++)\n\n/* include file*/\n#include <functional>\n#include <vector>\nusing namespace std;\n\ntemplate <class Monoid>\nstruct Segment\n{\n    using Func = function<Monoid(Monoid,Monoid )>;\n\n    vector<Monoid> node;\n    Monoid ide;\n    int n = 1;\n\n    Func bin_f;\n    Func update_f;\n\n    Segment(const vector<Monoid> &init, Monoid ide_, Func f_,Func u_f) : bin_f(f_),ide(ide_),update_f(u_f)\n    {\n        int sz = init.size();\n        while (n < sz)\n            n *= 2;\n        node.assign(n * 2 - 1, ide);\n        for (int i = 0; i < sz; i++)\n            node[i + n - 1] = init[i];\n        for (int i = n - 2; i >= 0; i--)\n            node[i] = bin_f(node[i * 2 + 1], node[i * 2 + 2]);\n    }\n\n    void update(int i, Monoid x)\n    {\n        i += n - 1;\n        node[i] = update_f(node[i],x);\n        while (i)\n        {\n            i = (i - 1) / 2;\n            node[i] = bin_f(node[i * 2 + 1], node[i * 2 + 2]);\n        }\n    }\n\n    Monoid get_inter(int a, int b, int k = 0, int l = 0, int r = -1)\n    {\n        if (r < 0)\n            r = n;\n        if (a <= l && r <= b)\n            return node[k];\n        if (r <= a || b <= l)\n            return ide;\n\n        Monoid lm = get_inter(a, b, k * 2 + 1, l, (l + r) / 2);\n        Monoid rm = get_inter(a, b, k * 2 + 2, (l + r) / 2, r);\n        return bin_f(lm, rm);\n    }\n};\n\n// http://judge.u-aizu.ac.jp/onlinejudge/review.jsp?rid=2730414#1\n// http://judge.u-aizu.ac.jp/onlinejudge/review.jsp?rid=2730425#1\n\ni64 n;\nvector<i64> x;\n\nint main(){\n    cin >> n;\n    x.assign(n + 1,0);\n    for(int i = 1;i <= n;i++) cin >> x[i];\n\n    Segment<i64> seg(vector<i64>(n + 1,0),0,[](i64 a , i64 b){\n        return max(a,b);\n    },[](i64 node,i64 a){\n        return a;\n    });\n\n    for(int i = 1;i <= n;i++){\n        seg.update(x[i],x[i] + seg.get_inter(1,x[i]));\n    }\n\n    cout << (n + 1) * n / 2 - seg.get_inter(0,n + 1) << endl;;\n\n}\n"
  },
  {
    "language": "C++",
    "code": "#include <iostream>\n#include <vector>\nusing namespace std;\nint INF = 1000000000;\nstruct SegmentTree{\nprivate:\n  int n;\n  vector<int> node;\npublic:\n  SegmentTree(vector<int> v){\n    int sz = v.size();\n    n = 1; while(n < sz) n *= 2;\n    node.resize(2*n-1,0);\n    for(int i = 0; i < sz; ++i) node[i+n-1] = v[i];\n    for(int i = n-2; i >= 0; --i) node[i] = max(node[2*i+1],node[2*i+2]);\n  }\n  void update(int x, int val){\n    x += (n-1);\n    node[x] = val;\n    while(x > 0){\n      x = (x-1)/2;\n      node[x] = max(node[2*x+1],node[2*x+2]);\n    }\n  }\n  int getmax(int a, int b, int k = 0, int l = 0, int r = -1){\n    if(r < 0) r = n;\n    if(r <= a || b <= l) return 0;\n    if(a <= l && r <= b) return node[k];\n    int vl = getmax(a,b,2*k+1,l,(l+r)/2);\n    int vr = getmax(a,b,2*k+2,(l+r)/2,r);\n    return max(vl,vr);\n  }\n};\n\nint main(){\n  int n, s = 0;\n  cin >> n;\n  vector<int> x(n);\n  for(int i = 0; i < n; ++i){\n    cin >> x[i];\n    s += x[i];\n  }\n  SegmentTree st(vector<int>(n+1,0));\n  for(int i = 0; i < n; ++i){\n    int t = st.getmax(0,x[i]);\n    //cout << x[i] << \" \" << t << endl;\n    st.update(x[i],t+x[i]);\n  }\n\n  cout << s - st.getmax(0,n+1) << endl;\n  return 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include<bits/stdc++.h>\n#define int long long\n#define PB push_back\n#define FI first\n#define SE second\nusing namespace std;\nstatic const int MAX_N = 1<<17;\nstatic const int inf = 1ll<<6;\ntypedef pair<int,int> PII;\n\nint N;\nvector<PII> V;\n\nclass Segment{\npublic:\n    int dp[MAX_N];\n    int n;\n\n    void init(int n_){\n        n=1;\n        while(n<n_)n*=2;\n        for(int i=0;i<2*n-1;++i)dp[i]=-inf;\n    }\n\n    void update(int k,int a){\n        k+=n-1;\n        dp[k]=a;\n        while(k>0){\n            k=(k-1)/2;\n            dp[k]=max(dp[2*k+1],dp[2*k+2]);\n        }\n    }\n\n    int query(int a,int b,int k,int l,int r){\n        if(r<=a||b<=l)return -inf;\n        if(a<=l&&r<=b)return dp[k];\n        else{\n            int vl=query(a,b,2*k+1,l,(l+r)/2);\n            int vr=query(a,b,2*k+2,(l+r)/2,r);\n            return max(vl,vr);\n        }\n    }\n};\n\nint res;\n\nsigned main(){\n    cin>>N;\n    Segment seg;\n    seg.init(N);\n    int MAX=N*(N+1)/2;\n    for(int i=0;i<N;++i){\n        int a;\n        cin>>a;\n        V.PB(PII(a,-i));\n    }\n    sort(V.begin(),V.end());\n    for(int i=0;i<N;++i){\n        int j=-V[i].SE;\n        seg.update(j,V[i].FI);\n        seg.update(j,max(seg.dp[j+seg.n-1],seg.query(0,j,0,0,seg.n)+V[i].FI));\n    }\n    cout<<MAX-seg.dp[0]<<endl;\n}"
  },
  {
    "language": "C++",
    "code": "#include <cstdio>\n#include <iostream>\n#include <algorithm>\n#include <complex>\n#include <queue>\n#include <map>\nusing namespace std;\n\n#define FOR(i,a,b) for (int i=(a);i<(b);i++)\n#define FORR(i,a,b) for (int i=(b)-1;i>=(a);i--)\n#define REP(i,n) for (int i=0;i<(n);i++)\n#define RREP(i,n) for (int i=(n)-1;i>=0;i--)\n#define pb push_back\n#define ALL(a) (a).begin(),(a).end()\n\n#define EPS (1e-10)\n#define EQ(a,b) (abs((a)-(b)) < EPS)\n\ntypedef long long ll;\ntypedef pair<ll, int> P;\n//typedef complex<double> C;\n\nconst double pi = acos(-1);\n\nint N;\nll x[100010];\nll sum_x = 0;\n\nvoid input() {\n\tcin >> N;\n\tREP(i, N) {\n\t\tcin >> x[i];\n\t\tsum_x += x[i];\n\t}\n}\n\nconst int MAX_N = 1 << 17;\n\nint width;\nll dat[2 * MAX_N - 1];\n\nvoid init(int n_) {\n    // let width be the power of 2\n    width = 1;\n    while (width < n_) width *= 2;\n\n    // set all values by INF(0)\n    REP(i, 2 * width - 1) dat[i] = 0;\n}\n\n// change the k-th(0-index) value to a\nvoid update(int k, ll a) {\n    // set a in the leaf\n    k += width - 1;\n    dat[k] = a;\n\n    // update upward\n    while (k > 0) {\n        k = (k - 1) / 2;\n        dat[k] = max(dat[2 * k + 1], dat[2 * k + 2]);\n    }\n}\n\n// get the minimum(maximum) value in [a, b)\n// k: num of the node corresponds to [l, r)\n// call like this: 'query(a, b, 0, 0, n)'\nll query(int a, int b, int k, int l, int r) {\n    // if [a, b) & [l, r) = 0, then return nonsense value\n    if (r <= a || b <= l) return 0;\n\n    // if [a, b) covers the whole [l, r),\n    // then return the value of this node\n    if (a <= l && r <= b) return dat[k];\n\n    // otherwise, return the min of two children\n    ll vl = query(a, b, k * 2 + 1, l, (l + r) / 2);\n    ll vr = query(a, b, k * 2 + 2, (l + r) / 2, r);\n\n    return max(vl, vr);\n}\n\n\nvoid solve() {\n\t// DP with segtree\n\tll ma = 0;\n\n\t// dp[i] = max(dp[j] s.t. j < i && x[j] < x[i]) + 1\n\tinit(N);\n\tREP(i, N) {\n\t\tll dpi = query(0, (int)x[i], 0, 0, width) + x[i];\n\t\tma = max(ma, dpi);\n\t\tupdate((int)x[i] - 1, dpi);\n\t}\n\n\tcout << sum_x - ma << endl;\n}\n\n\nint main() {\n\tinput();\n    solve();\n    return 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include<bits/stdc++.h>\n#define N (1<<17)\n#define INF 0\nusing namespace std;\ntypedef long long ll;\n\nclass RMQ{\npublic:\n  ll n,dat[2*N-1];\n\n  //?????????\n  RMQ(){\n    n=N;\n    for(int i=0;i<n;i++) dat[i]=INF;\n  }\n  \n  //k???????????????a????????´\n  void update(int k,ll a){\n    k+=n-1;\n    dat[k]=a;\n    while(k>0){\n      k=(k-1)/2;\n      dat[k]=min(dat[k*2+1],dat[k*2+2]);\n    }\n  }\n\n  //[a,b)???????°????????±??????? query(a,b,0,0,n)\n  ll query(int a,int b,int k=0,int l=0,int r=N){\n    if(r<=a||b<=l)return INF;\n    if(a<=l&&r<=b)return dat[k];\n    ll vl=query(a,b,k*2+1,l,(l+r)/2);\n    ll vr=query(a,b,k*2+2,(l+r)/2,r);\n    return min(vl,vr);\n  }\n};\n\n\nint main(){  \n  ll n,x[N];\n  cin>>n;\n  RMQ rmq;\n  for(int i=0;i<n;i++) cin>>x[i];\n\n  ll sum=n*(1+n)/2,ans=sum;\n  for(int i=0;i<n;i++){\n    ll mx=-rmq.query(1,x[i])+x[i];\n    ans=min(ans,sum-mx);\n    rmq.update(x[i],-mx);\n  }\n  cout <<ans<<endl;\n  return 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include<iostream>\n#include<cstdio>\n#include<cstdlib>\n#include<cmath>\n#include<algorithm>\n#include<cstring>\n#include<sstream>\n#include<vector>\n#include<queue>\n#include<stack>\n#include<string>\n#include<climits>\n#include<map>\n#include<set>\n#include<cassert>\n#include<deque>\n#define REP(i,s,n) for(int i=s;i<n;i++)\n#define rep(i,n) REP(i,0,n)\n#define INF 1<<27\n#define all(n) n.begin(),n.end()\n#define insert(a,b,c,d) PP(P(a,b),P(c,d))\n#define F first\n#define S second\n#define pb push_back\n#define MAX_N (1<<18)\n#define foreach(i,c) for(iter(c) i=(c).begin();i!=(c).end();++i)\nusing namespace std;\ntypedef pair<int,int> P;\ntypedef pair<P,P> PP;\ntypedef long long ll;\n\n\n\n\n\ntemplate<class T>\nclass RMQ_segment{\nprivate:\n  int n;\n  T dat[2*MAX_N-1];\npublic:\n  void init(int n_){\n    n = 1;\n    while(n<n_)n*=2;\n    for(int i=0;i<2*n-1;i++)dat[i] = 0;\n  }\n\n  void update(int k,T a){\n    k += n-1;\n    dat[k] = a;\n    while(k > 0){\n      k = (k-1)/2;\n      dat[k] = max(dat[k*2+1],dat[k*2+2]);\n    }\n  }\n\n  T query(int a,int b,int k,int l,int r){\n    if(r<=a || b<=l)return 0;\n    else if(a<=l && r<=b)return dat[k];\n    \n      T vl = query(a,b,k*2+1,l,(l+r)/2);\n      T vr = query(a,b,k*2+2,(l+r)/2,r);\n      return max(vl,vr);\n    \n  }\n\n  T _query(int a,int b){//nの範囲でミスしないように極力こっちを利用\n    return query(a,b,0,0,n);\n  }\n\n};\n\n\n int x[1000010];\n RMQ_segment<ll> rmq;\nint main(){\n  int n;\n  cin >> n;\n \n  rmq.init(n+1);\n \n  rep(i,n)cin >> x[i];\n  ll mex=0;\n  ll sum=0;\n\n  for(int i=0;i<n;i++){\n    sum+=x[i];\n    ll premex = rmq._query(0,x[i])+x[i];\n    rmq.update(x[i],premex);\n    mex = max(mex,premex);\n   \n  }  \n  \n  cout << sum-mex << endl;\n\nreturn 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include<cstdio>\n#include<iostream>\n#include<string>\n#include<vector>\n#include<algorithm>\n\nusing namespace std;\n\n#define reps(i,f,n) for(int i=f;i<int(n);i++)\n#define rep(i,n) reps(i,0,n)\n\nconst int N = 100;\nconst int INF = 1000000000;\nint n;\nint dp[2][N];\n\nvoid init(){\n\trep(i,2)rep(j,N)dp[i][j]=INF;\n}\n\nint solve(){\n\tinit();\n\t\n\tint p[N];\n\trep(i,n)cin>>p[i];\n\t\n\tint i2 = 0;\n\tint i1 = 1;\n\t\n\trep(i,n){\n\t\tdp[i1][i]=p[0];\n\t\tif(i>=p[0])dp[i1][i]=0;\n\t}\n\treps(i,1,n){\n\t\trep(j,N)dp[i2][j]=INF;\n\t\trep(j,n+1){\n\t\t\tdp[i2][j] = min(dp[i2][j],dp[i1][j] + p[i]);\n\t\t\tif(j-1>=0)dp[i2][j] = min(dp[i2][j],dp[i2][j-1]);\n\t\t\t\n\t\t\tif(p[i]==j){\n\t\t\t\trep(k,j){\n\t\t\t\t\tdp[i2][j] = min(dp[i2][j], dp[i1][k]);\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t\tswap(i2,i1);\n\t}\n\t\n\treturn dp[i1][n];\n}\n\nint main(){\n\twhile(1){\n\t\tcin>>n;\n\t\tif(n==0)break;\n\t\tprintf(\"%d\\n\",solve());\n\t\tbreak;\n\t}\n\t\n\t\n\t\n}"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\nusing namespace std;\n\n#define max(a,b) ((a)>(b)?(a):(b))\n#define min(a,b) ((a)<(b)?(a):(b))\n#define abs(a) max((a),-(a))\n#define rep(i,n) for(int i=0;i<(int)(n);i++)\n#define repe(i,n) rep(i,(n)+1)\n#define per(i,n) for(int i=(int)(n)-1;i>=0;i--)\n#define pere(i,n) rep(i,(n)+1)\n#define all(x) (x).begin(),(x).end()\n#define SP <<\" \"<<\n#define RET return 0\n#define MOD 1000000007\n#define INF 1000000000000000000\n\ntypedef long long LL;\ntypedef long double LD;\n\nstruct SegmentTree {\nprivate:\n  int n;\n  vector<LL> node;\n\npublic:\n  SegmentTree(int sz) {\n      n = 1; while(n < sz) n *= 2;\n      node.resize(2*n-1, 0);\n  }\n  LL getmax(int x) {\n    x += (n - 1);\n    LL ans=node[x];\n    while(x > 0) {\n        x = (x - 1) / 2;\n        ans=max(ans,node[x]);\n    }\n    return ans;\n  }\n  void update(int a, int b, LL val, int k=0, int l=0, int r=-1) {\n    if(r < 0) r = n;\n    if(r <= a || b <= l) return;\n    if(a <= l && r <= b){\n      node[k]=max(node[k],val);\n    }else{\n      update(a, b, val, 2*k+1, l, (l+r)/2);\n      update(a, b, val, 2*k+2, (l+r)/2, r);\n    }\n  }\n};\n\nint main(){\n  int n;\n  cin >> n;\n  vector<LL> x(n),id(n);\n  vector<pair<int,int>> xs(n);\n  LL total=0;\n  for(int i=0;i<n;i++){\n    cin >> x[i];\n    xs[i]={x[i],i};\n    total+=x[i];\n  }\n  sort(all(xs));\n  for(int i=0;i<n;i++){\n    id[xs[i].second]=i;\n  }\n  SegmentTree seg(n);\n  LL now;\n  for(int i=0;i<n;i++){\n    // for(int j=0;j<n;j++){\n    //   cout << seg.getmax(j) << \" \";\n    // }\n    // cout << endl;\n    now=seg.getmax(id[i]);\n    seg.update(id[i],n,now+x[i]);\n  }\n  // for(int j=0;j<n;j++){\n  //   cout << seg.getmax(j) << \" \";\n  // }\n  // cout << endl;\n  cout << total-seg.getmax(n-1) << endl;\n  return 0;\n}\n\n"
  },
  {
    "language": "C++",
    "code": "#include <vector>\n#include <iostream>\n#include <set>\n#include <cstdio>\n#include <queue>\n#include <cstdio>\n#include <cstdlib>\n#include <cassert>\n#include <ctime>\n#include <algorithm>\n#include <tuple>\n#include <algorithm>\n#include <limits>\n#include <map>\n\nusing namespace std;\n\ntypedef long long ll;\ntypedef pair<int, int> P;\ntypedef tuple<int, int, int> T;\n\n#include <algorithm>\n#include <limits>\n#include <cstring>\n#include <array>\n//size:2**N N=19:524288 N=17:131072 N=12:4096\ntemplate <class T, int N, int K>\nstruct RangeKthSmallest {\n    using PA = std::pair<T, int>;\n    using P = std::pair<std::array<PA, K>, T>;\n    using uint = unsigned int;\n    static const int size = 1<<N;\n    P seg[size*2];\n    \n    void init(T x) {\n        int l = size-1, r = size*2-2;\n        for (int i = 0; i <= N; i++) {\n            for (int j = l; j <= r; j++) {\n                seg[j].first[0] = PA(x, 1<<i);\n                for (int i = 1; i < K; i++) {\n                    seg[j].first[i] = PA(0, -1);\n                }\n                if (i) {\n                    seg[j].second = 0;\n                } else {\n                    seg[j].second = x;\n                }\n            }\n            l = (l-1)/2; r = (r-1)/2;\n        }\n        for (int i = 0; i < K; i++) {\n            seg[size*2-1].first[i] = PA(0, -1);\n        }\n    }\n\n    //a=b+c\n    inline void merge(P *A, P &a1, P &a2) {\n        int c1 = 0, c2 = 0;\n        P &a = *A;\n        for (int c = 0; c < K; c++) {\n            PA &p1 = a1.first[c1], &p2 = a2.first[c2];\n            bool f1 = (c1 == K || p1.second == -1), f2 = (c2 == K || p2.second == -1);\n            if (f1 && f2) {\n                a.first[c] = PA(0, -1);\n                continue;\n            }\n            if (f1) {\n                a.first[c] = p2;\n                c2++;\n            } else if (f2) {\n                a.first[c] = p1;\n                c1++;\n            } else if (p1.first == p2.first) {\n                a.first[c] = PA(p1.first, p1.second + p2.second);\n                c1++; c2++;\n            } else if (p1.first < p2.first) {\n                a.first[c] = p1;\n                c1++;\n            } else {\n                a.first[c] = p2;\n                c2++;\n            }\n            a.first[c].first += a.second;\n        }\n    }\n\n    inline void merge2(P *a, P &a1) {\n        P a2;\n        memcpy(&a2, a, sizeof(a2));\n        merge(a, a1, a2);\n    }\n\n    inline void add(uint i, T x) {\n        if (i >= size) return;\n        i += size - 1;\n        seg[i].first[0].first += x;\n        seg[i].second += x;\n        while (i) {\n            i = (i - 1) / 2;\n            merge(&seg[i], seg[i*2+1], seg[i*2+2]);\n        }\n    }\n\n    inline void add(uint a, uint b, T x, uint k = 0, uint l = 0, uint r = size) {\n        if (a >= b || b > size) return;\n        if (r <= a || b <= l) return;\n        if (a <= l && r <= b) {\n            for (int i = 0; i < K && seg[k].first[i].second != -1; i++) {\n                seg[k].first[i].first += x;\n            }\n            seg[k].second += x;\n            return;\n        }\n        add(a, b, x, k*2+1, l, (l+r)/2);\n        add(a, b, x, k*2+2, (l+r)/2, r);\n        merge(&seg[k], seg[k*2+1], seg[k*2+2]);\n    }\n\n    inline PA get(uint k) {\n        return seg[0].first[k];\n    }\n    P buff_p;\n    int buff_a = size, buff_b = size;\n    inline PA get(uint a, uint b, uint k) {\n        if (a != buff_a || b != buff_b) {\n            buff_p = get2(a, b);\n            buff_a = a;\n            buff_b = b;\n        }\n        return buff_p.first[k];\n    }\n\nprivate:\n    inline P get2(uint a, uint b, uint k = 0, uint l = 0, uint r = size) {\n        if (a >= b || b > size || r <= a || b <= l) return seg[size*2-1];\n        if (a <= l && r <= b) {\n            return seg[k];\n        }\n        P p1 = get2(a, b, k*2+1, l, (l+r)/2);\n        P p2 = get2(a, b, k*2+2, (l+r)/2, r);\n        P p;\n        p.second = seg[k].second;\n        merge(&p, p1, p2);\n        return p;\n    }\n};\nRangeKthSmallest<ll, 17, 1> s;\nint main() {\n    int n;\n    cin >> n;\n    s.init(0);\n    ll r = 0;\n    for (int i = 0; i < n; i++) {\n        int d;\n        cin >> d;\n        s.add(d, s.get(0, d, 0).first-d);\n        r += d;\n    }\n    cout << r + s.get(0).first << endl;\n    return 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include <stdio.h>\n#include <algorithm>\n#pragma warning(disable : 4996)\nusing namespace std;\nint n, a[100000]; long long sum, dp[100001];\nint main() {\n\tscanf(\"%d\", &n);\n\tfor (int i = 0; i < n; i++) scanf(\"%d\", &a[i]), sum += a[i];\n\tfor (int i = 1; i <= n; i++) {\n\t\tdp[i] = a[i - 1];\n\t\tfor (int j = 1; j < i; j++) {\n\t\t\tif (a[j - 1] < a[i - 1]) {\n\t\t\t\tdp[i] = max(dp[i], dp[j] + a[i - 1]);\n\t\t\t}\n\t\t}\n\t}\n\tprintf(\"%lld\\n\", sum - dp[n]);\n\treturn 0;\n}"
  },
  {
    "language": "C++",
    "code": "////////////////////////////////////////\n///  tu3 pro-con template            ///\n////////////////////////////////////////\n#include <cassert>\n#include <cstdio>\n#include <cstring>\n#include <cmath>\n#include <iostream>\n#include <sstream>\n#include <algorithm>\n#include <numeric>\n#include <functional>\n#include <vector>\n#include <queue>\n#include <string>\n#include <complex>\n#include <stack>\n#include <set>\n#include <map>\n#include <list>\n#include <unordered_map>\n#include <unordered_set>\n#include <bitset>\n#include <regex>\nusing namespace std;\n\n//// MACRO ////\n#define countof(a) (sizeof(a)/sizeof(a[0]))\n\n#define REP(i,n) for (int i = 0; i < (n); i++)\n#define RREP(i,n) for (int i = (n)-1; i >= 0; i--)\n#define FOR(i,s,n) for (int i = (s); i < (n); i++)\n#define RFOR(i,s,n) for (int i = (n)-1; i >= (s); i--)\n#define pos(c,i) c.being() + (i)\n#define allof(c) c.begin(), c.end()\n#define aallof(a) a, countof(a)\n#define partof(c,i,n) c.begin() + (i), c.begin() + (i) + (n)\n#define apartof(a,i,n) a + (i), a + (i) + (n)\n#define long long long\n\n#define EPS 1e-9\n#define INF (1L << 30)\n#define LINF (1LL << 60)\n\n#define PREDICATE(t,a) [&](const t & a) -> bool\n#define COMPARISON_T(t) bool(*)(const t &, const t &)\n#define COMPARISON(t,a,b) [&](const t & a, const t & b) -> bool\n#define CONVERTER(TSrc,t,TDest) [&](const TSrc &t)->TDest\n\n//// i/o helper ////\nstruct _Reader { template <class T> _Reader operator ,(T &rhs) { cin >> rhs; return *this; } };\nstruct _Writer { bool f; _Writer() : f(false) { } template <class T> _Writer operator ,(const T &rhs) { cout << (f ? \" \" : \"\") << rhs; f = true; return *this; } };\n#define READ(t,...) t __VA_ARGS__; _Reader(), __VA_ARGS__\n#define WRITE(...) _Writer(), __VA_ARGS__; cout << endl\n\ntemplate <class T> struct vevector : public vector<vector<T>> { vevector(int n = 0, int m = 0, const T &initial = T()) : vector<vector<T>>(n, vector<T>(m, initial)) { } };\ntemplate <class T> struct vevevector : public vector<vevector<T>> { vevevector(int n = 0, int m = 0, int l = 0, const T &initial = T()) : vector<vevector<T>>(n, vevector<T>(m, l, initial)) { } };\ntemplate <class T> struct vevevevector : public vector<vevevector<T>> { vevevevector(int n = 0, int m = 0, int l = 0, int k = 0, const T &initial = T()) : vector<vevevector<T>>(n, vevevector<T>(m, l, k, initial)) { } };\ntemplate <class T> T read() { T t; cin >> t; return t; }\ntemplate <class T> vector<T> read(int n) { vector<T> v; REP(i, n) { v.push_back(read<T>()); } return v; }\ntemplate <class T> vevector<T> read(int n, int m) { vevector<T> v; REP(i, n) v.push_back(read<T>(m)); return v; }\ntemplate <class T> vevector<T> readjag() { return read<T>(read<int>()); }\ntemplate <class T> vevector<T> readjag(int n) { vevector<T> v; REP(i, n) v.push_back(readjag<T>()); return v; }\n\ntemplate <class T1, class T2> inline istream & operator >> (istream & in, pair<T1, T2> &p) { in >> p.first >> p.second; return in; }\ntemplate <class T1, class T2> inline ostream & operator << (ostream &out, pair<T1, T2> &p) { out << p.first << p.second; return out; }\ntemplate <class T> inline ostream & operator << (ostream &out, vector<T> &v)\n{\n\tostringstream ss;\n\tfor (auto x : v) ss << x << ' ';\n\tauto s = ss.str();\n\tout << s.substr(0, s.length() - 1) << endl;\n\treturn out;\n}\n\n//// start up ////\nvoid solve();\nint main()\n{\n\tsolve();\n\treturn 0;\n}\n\n//// data structure ////\n\n/// 2分セグメント木。RMQとかが解ける。\ntemplate<class T = int, class TParentFunc = const T& (*)(const T&, const T&)>\nstruct SegTree\n{\n\tunsigned msb(unsigned v) { v |= v >> 1; v |= v >> 2; v |= v >> 4; v |= v >> 8; v |= v >> 16; return (v >> 1) + 1; }\n\n\tint size;\n\tvector<T> tree;\n\tTParentFunc parent;\n\n\tSegTree(int count, TParentFunc parentBuilder = std::min, T initialFill = INF)\n\t\t: size(msb(count - 1) << 1)\n\t\t, tree(size * 2)\n\t\t, parent(parentBuilder)\n\t{\n\t\tfill(partof(tree, size, size), initialFill);\n\t\trebuild();\n\t}\n\n\t// []を使うと更新されないのでrebuildすること。数が少なければupdateの方がよい。\n\tT& operator[](int i) { return tree[i + size]; }\n\tvoid rebuild() { RREP(i, size) { tree[i] = parent(tree[i * 2], tree[i * 2 + 1]); } }\n\n\tvoid update(int index, T value)\n\t{\n\t\ttree[index + size] = value;\n\t\tfor (int i = (index + size) / 2; i > 0; i /= 2)\n\t\t\ttree[i] = parent(tree[i * 2], tree[i * 2 + 1]);\n\t}\n\n\tT query(int s, int e, int i, int l, int r, T value)\n\t{\n\t\tif (r <= s || e <= l) return value;\n\t\tif (s <= l && r <= e) return parent(value, tree[i]);\n\t\tvalue = query(s, e, i * 2, l, (l + r) / 2, value);\n\t\tvalue = query(s, e, i * 2 + 1, (l + r) / 2, r, value);\n\t\treturn value;\n\t}\n\n\tT query(int start, int count, T initialValue)\n\t{\n\t\treturn query(start, start + count, 1, 0, size, initialValue);\n\t}\n};\n\n\n////////////////////\n/// template end ///\n////////////////////\n\nvoid solve()\n{\n\tint testcases = 1;\n\tREP(testcase, testcases)\n\t{\n\t\tREAD(int, N);\n\t\tauto x = read<int>(N);\n\t\tSegTree<long> st(N, max, 0);\n\t\tREP(i, N) st.update(x[i] - 1, st.query(0, x[i] - 1, 0) + x[i]);\n\t\tWRITE(accumulate(allof(x), 0LL) - st.query(0, N, 0));\n\t}\n}"
  },
  {
    "language": "C++",
    "code": "#include <iostream>\n#include <vector>\n#include <algorithm>\n#include <cassert>\n\n#define show(x) cerr << #x << \" = \" << x << endl\n\nusing namespace std;\nusing ll = long long;\n\ntemplate <typename T>\nostream& operator<<(ostream& os, const vector<T>& v)\n{\n    os << \"sz:\" << v.size() << \"\\n[\";\n    for (const auto& p : v) {\n        os << p << \",\";\n    }\n    os << \"]\\n\";\n    return os;\n}\n\nconstexpr int INF = 1 << 30;\n\nstruct Max {\n    using T = int;\n    T operator()(const T& a, const T& b) const\n    {\n        return max(a, b);\n    }\n    T inv(const T& a) const\n    {\n        return -a;  // dame\n    }\n    static constexpr T identity()\n    {\n        return -INF;\n    }\n};\ntemplate <typename Base>\nclass BinaryIndexedTree\n{\npublic:\n    using T = typename Base::T;\n    using AbelGroup = Base;\n\n    BinaryIndexedTree(const int n) : data_num(n), size(1 << (__lg(2 * data_num - 1))), value(size + 1, AbelGroup::identity()) { assert(n > 0); }\n    BinaryIndexedTree(const vector<T>& val) : data_num(val.size()), size(1 << (__lg(2 * data_num - 1))), value(size + 1, AbelGroup::identity())\n    {\n        for (int i = 1; i <= size; i++) {\n            value[i] = val[i - 1];\n        }\n        for (int x = 1; x < size; x++) {\n            value[x + (x & -x)] += value[x];\n        }\n    }\n\n    T accumulate(const int a) const\n    {\n        assert(0 <= a and a < data_num);\n        int ind = a + 1;\n        T sum = AbelGroup::identity();\n        while (ind > 0) {\n            sum = op(sum, value[ind]);\n            ind &= ind - 1;\n        }\n        return sum;\n    }\n\n    void add(const int a, const T& val)\n    {\n        assert(0 <= a and a < data_num);\n        int ind = a + 1;\n        while (ind <= size) {\n            value[ind] = op(value[ind], val);\n            ind += ind & (-ind);\n        }\n    }\n\n    void set(const int a, const T& val)\n    {\n        const int v = get(a);\n        add(a, op(val, op.inv(v)));\n    }\n\n    T get(const int a) const\n    {\n        assert(0 <= a and a < data_num);\n        if (a == 0) {\n            return accumulate(a);\n        } else {\n            return op(op.inv(accumulate(a - 1)), accumulate(a));\n        }\n    }\n\n    int lowerBound(T w) const\n    {\n        if (w <= AbelGroup::identity()) {\n            return 0;\n        }\n        int x = 0;\n        for (int k = ((size == data_num) ? size : size / 2); k > 0; k /= 2) {\n            if (x + k <= size and value[x + k] < w) {\n                w = op(w, op.inv(value[x + k]));\n                x += k;\n            }\n        }\n        return x;\n    }\n\nprivate:\n    const int data_num;\n    const int size;\n    const AbelGroup op{};\n    vector<T> value;\n};\n\n\nint main()\n{\n    int n;\n    cin >> n;\n    vector<int> a(n + 1, 0);\n    for (int i = 1; i <= n; i++) {\n        cin >> a[i];\n    }\n    vector<int> dp(n + 1, 0);\n    BinaryIndexedTree<Max> bit(n + 1);\n    for (int i = 0; i <= n; i++) {\n        if (i > 0) {\n            dp[i] = bit.accumulate(a[i]) + a[i];\n        }\n        bit.add(a[i], dp[i]);\n    }\n    const int maxi = *max_element(dp.begin(), dp.end());\n    cout << n * (n + 1) / 2 - maxi << endl;\n\n    return 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\nusing namespace std;\ntypedef long long ll;\n\nconst int MAX_N = 1 << 17;\nconst int def = 0;\nconst int INF = 1 << 25;\n\nstruct MaxSegTree {\n\tint n;\n\tll dat[2 * MAX_N - 1];\n\tvoid init(int n_) {\n\t\tn = 1;\n\t\twhile(n < n_) n *= 2;\n\t\tfor(int i = 0; i < 2 * n - 1; i++) dat[i] = def;\n\t}\n\n\tvoid update(int k, ll a) {\n\t\tk += n - 1;\n\t\tdat[k] = a;\n\t\twhile(k > 0) k = (k - 1) / 2, dat[k] = max(dat[k * 2 + 1], dat[k * 2 + 2]);\n\t}\n\n\tll query(int a, int b) { return query(a, b, 0, 0, n); }\n\n\tll query(int a, int b, int k, int l, int r) {\n\t\tif(r <= a || b <= l) return def;\n\t\tif(a <= l && r <= b) return dat[k];\n\t\tll vl = query(a, b, k * 2 + 1, l, (l + r) / 2);\n\t\tll vr = query(a, b, k * 2 + 2, (l + r) / 2, r);\n\t\treturn max(vl, vr);\n\t}\n\n\tvoid show() {\n\t\tfor(int i = 0; i < n; i++) cout << dat[i + n - 1] << \" \";\n\t\tcout << endl;\n\t}\n};\n\n\nMaxSegTree st;\n\ntypedef pair<int, int> P;\nll x[100000];\nll dp[100000];\n\nint main() {\n\tcin.tie(0);\n\tios::sync_with_stdio(false);\n\n\tint n;\n\tcin >> n;\n\tst.init(n);\n\tvector<P> v;\n\tfor(int i = 0; i < n; i++) {\n\t\tcin >> x[i];\n\t\tv.push_back({ x[i], i });\n\t}\n\tsort(v.begin(), v.end());\n\treverse(v.begin(), v.end());\n\n\tfor(auto t : v) {\n\t\tint i = t.second;\n\t\tdp[i] = x[i] + st.query(i + 1, n);\n\t\tst.update(i, dp[i]);\n\t}\n\n\tll ans = n * (n + 1) / 2 - st.query(0, n);\n\tcout << ans << endl;\n}"
  },
  {
    "language": "C++",
    "code": "#include<iostream>\n#include<algorithm>\n\nusing namespace std;\n\ntypedef long long Int;\n\nInt bit[105000], num[105000], n;\n\nvoid setnum(int pos, Int val){\n\twhile(pos < 105000){\n\t\tbit[pos] = max(val, bit[pos]);\n\t\tpos += pos & -pos;\n\t}\n}\n\nInt maxnum(int pos){\n\tInt res = 0;\n\twhile(pos){\n\t\tres = max(res, bit[pos]);\n\t\tpos -= pos &-pos;\n\t}\n\treturn res;\n}\n\nInt solve(){\n\tfill(bit, bit + 105000, 0);\n\tInt sum = 0, x;\n\tfor(int i = 0;i < n;i++){\n\t\tx = num[i];\n\t\tsum += x;\n\t\tInt p = x + maxnum(x-1);\n\t\tsetnum(x, p);\n\t}\n\treturn sum - maxnum(10100);\n}\n\nint main(){\n\tcin >> n;\n\tfor(int i = 0;i < n;i++)cin >> num[i];\n\tInt res = solve();\n\tfor(int i = 0;i < n;i++){\n\t\tint p = n - i - 1;\n\t\tif(p <= i)break;\n\t\tswap(num[p], num[i]);\n\t}\n\tcout << res << endl;\n\treturn 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\n#define ll long long\n#define INF 1000000005\n#define MOD 1000000007\n#define EPS 1e-10\n#define rep(i,n) for(int i=0;i<n;++i)\n\nusing namespace std;\n\ntypedef pair<int,int>P;\n\nconst int MAX_N = 100005;\n\nint a[MAX_N];\nint n;\n\nconst int N = 1 << 17;\n\nint n_;\nll dat[2*N-1];\n\nvoid init(int x)\n{\n\tn_=1;\n\twhile(n_<x){\n\t\tn_*=2;\n\t}\n\trep(i,2*n_-1){\n\t\tdat[i] = 0;\n\t}\n}\n\nvoid update(int k,ll a)\n{\n\t//????????????\n\tk += n_-1;\n\tdat[k] = a;\n\t//?????????????????´??°\n\twhile(k>0){\n\t\tk = (k-1)/2;\n\t\tdat[k] = max(dat[2*k+1],dat[2*k+2]);\n\t}\n}\n\n//[a,b)???????°????????±??????????\n//k??????????????????\n//????????????query(a,b,0,0,n_)??¨???????????¶???(n_??¨???????????¨?????¨???)\nll query(int a,int b,int k,int l,int r)\n{\n\tif(r <= a || b <= l){\n\t\treturn 0;\n\t}\n\tif(a <= l && r <= b){\n\t\treturn dat[k];\n\t}else{\n\t\tll vl = query(a,b,2*k+1,l,(l+r)/2);\n\t\tll vr = query(a,b,2*k+2,(l+r)/2,r);\n\t\treturn max(vl,vr);\n\t}\n}\n\n\nint main()\n{\n\tscanf(\"%d\",&n);\n\tinit(n+1);\n\trep(i,n){\n\t\tscanf(\"%d\",&a[i]);\n\t}\n\trep(i,n){\n\t\tupdate(a[i],a[i] + query(1,a[i]+1,0,0,n_));\n\t}\n\tcout << accumulate(a,a+n,0LL) - query(1,n+1,0,0,n_) << \"\\n\";\n\treturn 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include<iostream>\n#include<iomanip>\n#include<algorithm>\n#include<bitset>\n#include<cassert>\n#include<cctype>\n#include<cmath>\n#include<cstdio>\n#include<cstring>\n#include<functional>\n#include<limits>\n#include<list>\n#include<map>\n#include<numeric>\n#include<set>\n#include<stack>\n#include<string>\n#include<sstream>\n#include<queue>\n#include<vector>\nusing namespace std;\n\ntypedef long long ll;\ntypedef unsigned long long ull;\n\n#define MOD 1000000007\n#define INF 0x3f3f3f3f\n#define INFL 0x3f3f3f3f3f3f3f3fLL\n\n#define MAX 100001\n\n//Binary Indexed Tree (Fenwick Tree)\ntemplate<class T>\nclass BIT {\npublic:\n\tvector<T> v;\n\tBIT(int n) :v(n + 1, 0) {}\n\t//[1,i]??????\n\t//e.g. [i,j]?????? : sum(j)-sum(i-1)\n\tT sum(int i) {\n\t\tT sum = 0;\n\t\tfor (; i > 0; i -= i&-i)\n\t\t\tsum += v[i];\n\t\treturn sum;\n\t}\n\t//[1,i]????????§???\n\tT query(int i) {\n\t\tT M = 0;\n\t\tfor (; i > 0; i -= i&-i) {\n\t\t\tM = max(M, v[i]);\n\t\t\t//cout << \"query i:\" << i << \" M:\" << M << endl;\n\t\t}\n\t\treturn M;\n\t}\n\t//v[i]??¨????????????????´??????´??°\n\tvoid update(int i, T x) {\n\t\tfor (; i < v.size(); i += i&-i) {\n\t\t\t//cout << \"update i:\" << i << \" x:\" << x << \" v.size():\" << v.size() << endl;\n\t\t\tv[i] = max(v[i], x);\n\t\t}\n\t}\n};\n\nint main() {\n\tll n; cin >> n;\n\tBIT<ll> BIT(n);\n\tfor (int i = 1; i <= n; i++) {\n\t\tint x; cin >> x;\n\t\tBIT.update(x, BIT.query(x - 1) + x);\n\t\t//cout << endl;\n\t\t//for (int j = 1; j <= n; j++) {\n\t\t//\tcout << BIT.v[j] << \" \";\n\t\t//}\n\t\t//cout << endl;\n\t}\n\n\n\tcout << n*(n + 1) / 2 - BIT.query(n) << endl;\n\treturn 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include<bits/stdc++.h>\nusing namespace std;\ntypedef long long ll;\n#define MAX 100005\nstruct BIT{\n  void init(){  memset(bit,0,sizeof(bit));  }\n  ll bit[MAX];\n  void set(int r,ll x){\n    r=MAX-r-1;\n    while(r){\n      bit[r]=max(bit[r],x);\n      r-=(r&-r);\n    }\n  }\n  ll get(int i){\n    i=MAX-i-1;\n    ll res=0;\n    while(i<MAX){\n      res=max(res,bit[i]);\n      i+=(i&-i);\n    }\n    return res;\n  }\n};\n\nint n;\nll sum,ans,a[MAX];\nBIT A;\n\nint main(){\n  A.init();\n  cin>>n;\n  for(int i=1;i<=n;i++){\n    cin>>a[i];\n    sum+=a[i];\n    ll k=A.get(a[i]);\n    ans=max(ans,k+a[i]);\n    A.set(a[i],k+a[i]);\n  }\n  cout<<sum-ans<<endl;\n  return 0;\n}"
  },
  {
    "language": "C++",
    "code": "                                        #include <bits/stdc++.h>\n                                        #include<iostream>\n                                        #include<cstdio>\n                                        #include<vector>\n                                        #include<queue>\n                                        #include<map>\n                                        #include<cstring>\n                                        #include<string>\n                                        #include <math.h>\n                                        #include<algorithm>\n                                    //    #include <boost/multiprecision/cpp_int.hpp>\n                                        #include<functional>\n                                #define int long long\n                                        #define inf  1000000007\n                                        #define pa pair<int,int>\n                                        #define ll long long\n                                        #define pal pair<double,int>\n                                        #define ppa pair<int,int>\n                                        #define ppap pair<int,pa>\n                                        #define ssa pair<string,int>\n                                        #define  mp make_pair\n                                        #define  pb push_back\n                                        #define EPS (1e-12)\n                                        #define equals(a,b) (fabs((a)-(b))<EPS)\n                                  #define VI vector<int>\n                                        using namespace std;\n                                        \n                                  class pas{\n                                    \tpublic:\n                                    \tint x,y;\n                                    \tpas(int x=0,int y=0):x(x),y(y) {}\n                                    \tpas operator + (pas p) {return pas(x+p.x,y+p.y);}\n                                    \tpas operator - (pas p) {return pas(x-p.x,y-p.y);}\n                                    \tpas operator * (int a) {return pas(x*a,y*a);}\n                                    \tpas operator / (int a) {return pas(x/a,y/a);}\n                                    //\tdouble absv() {return sqrt(norm());}\n                                    \tint norm() {return x*x+y*y;}\n                                    \tbool operator < (const pas &p) const{\n                                   \t\treturn x != p.x ? x<p.x: y<p.y;\n                                   \t}\n                                  //\t\tbool operator < (const pas &p) const{\n                                    //\t\treturn y != p.y ? y<p.y: x<p.x;\n                                    //\t}\n                                    \tbool operator == (const pas &p) const{\n                                    \t\treturn x==p.x && y==p.y;\n                                    \t}\n                                    };\n\n                                        class Point{\n                                        \tpublic:\n                                        \tdouble x,y;\n                                        \tPoint(double x=0,double y=0):x(x),y(y) {}\n                                        \tPoint operator + (Point p) {return Point(x+p.x,y+p.y);}\n                                        \tPoint operator - (Point p) {return Point(x-p.x,y-p.y);}\n                                        \tPoint operator * (double a) {return Point(x*a,y*a);}\n                                        \tPoint operator / (double a) {return Point(x/a,y/a);}\n                                        \tdouble absv() {return sqrt(norm());}\n                                        \tdouble norm() {return x*x+y*y;}\n                                        \tbool operator < (const Point &p) const{\n                                        \t\treturn x != p.x ? x<p.x: y<p.y;\n                                        \t}\n                                        \tbool operator == (const Point &p) const{\n                                        \t\treturn fabs(x-p.x)<EPS && fabs(y-p.y)<EPS;\n                                        \t}\n                                        };\n                                        typedef Point Vector;\n                                 #define pl pair<int,pas>\n                                        struct Segment{\n                                        Point p1,p2;\n                                        };\n                                         double dot(Vector a,Vector b){\n                                        \treturn a.x*b.x+a.y*b.y;\n                                        }\n                                        double cross(Vector a,Vector b){\n                                        \treturn a.x*b.y-a.y*b.x;\n                                        }\n                                    \n            bool parareru(Point a,Point b,Point c,Point d){\n            //\tif(abs(cross(a-b,d-c))<EPS)cout<<\"dd \"<<cross(a-b,d-c)<<endl;\n            \treturn abs(cross(a-b,d-c))<EPS;\n            }\n            double distance_ls_p(Point a, Point b, Point c) {\n              if ( dot(b-a, c-a) < EPS ) return (c-a).absv();\n              if ( dot(a-b, c-b) < EPS ) return (c-b).absv();\n              return abs(cross(b-a, c-a)) / (b-a).absv();\n            }\n            bool is_intersected_ls(Segment a,Segment b) {\n            \tif(a.p1==b.p1||a.p2==b.p1||a.p1==b.p2||a.p2==b.p2) return false;\n            \tif(parareru((a.p2),(a.p1),(a.p1),(b.p2))&&parareru((a.p2),(a.p1),(a.p1),(b.p1))){\n            //\t\tcout<<\"sss\"<<endl;\n            \t\tif(dot(a.p1-b.p1,a.p1-b.p2)<EPS) return true;\n            \t\tif(dot(a.p2-b.p1,a.p2-b.p2)<EPS) return true;\n            \t\tif(dot(a.p1-b.p1,a.p2-b.p1)<EPS) return true;\n            \t\tif(dot(a.p1-b.p2,a.p2-b.p2)<EPS) return true;\n            \t\treturn false;\n            \t}\n              else return ( cross(a.p2-a.p1, b.p1-a.p1) * cross(a.p2-a.p1, b.p2-a.p1) < EPS ) && ( cross(b.p2-b.p1, a.p1-b.p1) * cross(b.p2-b.p1, a.p2-b.p1) < EPS );\n            }\n            double segment_len(Segment a){\n            \t\n            \treturn (a.p1-a.p2).absv();\n            }\n            double segment_dis(Segment a,Segment b){\n            \tif(is_intersected_ls(a,b))return 0;\n            \tdouble r=distance_ls_p(a.p1, a.p2, b.p1);\n            \tr=min(r,distance_ls_p(a.p1, a.p2, b.p2));\n            \tr=min(r,distance_ls_p(b.p1, b.p2, a.p2));\n            \tr=min(r,distance_ls_p(b.p1, b.p2, a.p1));\n            \treturn r;\n            }\n            Point intersection_ls(Segment a, Segment b) {\n              Point ba = b.p2-b.p1;\n              double d1 = abs(cross(ba, a.p1-b.p1));\n              double d2 = abs(cross(ba, a.p2-b.p1));\n              double t = d1 / (d1 + d2);\n             \n              return a.p1 + (a.p2-a.p1) * t;\n            }\n\t\t\tpair<Point,Point> circle_intersection(Point c1,double r1,Point c2,double r2){\n\t\t\t\tdouble d=(c1-c2).absv();\n\t\t\t\tdouble h=(r1*r1-r2*r2+d*d)/2.0/d;\n\t\t\t\tdouble l=sqrt(r1*r1-h*h);\n\t\t\t//\tcout<<d<<\" \"<<h<<\" \"<<l<<endl;\n\t\t\t\tPoint asi=c1+(c2-c1)*h/((c2-c1).absv());\n\t\t\t\tVector r1r2=(c2-c1)/((c2-c1).absv());\n\t\t\t\tVector sui={r1r2.y,-r1r2.x};\n\t\t\t//\tcout<<sui.x<<\" \"<<sui.y<<endl;\n\t\t\t\tpair<Point,Point> z=mp(asi+sui*l,asi-sui*l);\n\t\t\t\tif(z.first.x>z.second.x) swap(z.first,z.second);\n\t\t\t\treturn z;\n\t\t\t}\nint N=262144;\npa sgt[530000];\n\npa minis(int i,int j ){\nif(i==j) return sgt[i];\n\telse if(i%2==1){\n\t\tpa z=minis(i+1,j);\n\t\tif(sgt[i].first>z.first)return sgt[i] ;\n\t\telse return z;\n\t}\n\t\telse if(j%2==0) \t{\n\t\tpa z=minis(i,j-1);\n\t\tif(sgt[j].first>z.first)return sgt[j] ;\n\t\telse return z;\n\t}\nelse return minis(i/2,j/2);\n}\n\npa sgtmin(int i ,int j) {\n\treturn minis(i+N,j+N);\n}\n\nvoid upd(int x,int y){\n\tx+=N;\nsgt[x].first=y;\n\tsgt[x].second=x;\nx=x/2;\nwhile(x != 0){\n\tif(sgt[2*x+1].first>sgt[2*x].first){\n\t\tsgt[x]=sgt[2*x+1];\n\t}\n\telse sgt[x]=sgt[2*x];\n\nx=x/2;\n}\n}\n\n\n         signed main(){\nint n;\n     \n      for(int i=N;i<2*N;i++) sgt[i]=make_pair(0,i-N);\n         \tcin>>n;\n         \tfor(int i=N-1;i>0;i--){\n\t\tif(sgt[2*i].first<sgt[2*i+1].first) sgt[i]=sgt[2*i+1];\n\t\telse sgt[i]=sgt[2*i];\n\t}\n         \tfor(int i=1;i<=n;i++){\n         \t\tint t;\n         \t\tcin>>t;\n         \t\t\n         \t\tint e=sgtmin(0,t-1).first;\n         \t\tupd(t,e+t);\n         \t}\n         \tint ans=0;\n         \tfor(int i=1;i<=n;i++)ans=max(ans,sgt[N+i].first);\n         \tcout<<n*(n+1)/2-ans<<endl;\n           \treturn 0;\n           }\n"
  },
  {
    "language": "C++",
    "code": "#include<iostream>\n#include<cstdio>\n#include<cstdlib>\n#include<cmath>\n#include<algorithm>\n#include<cstring>\n#include<sstream>\n#include<vector>\n#include<queue>\n#include<stack>\n#include<string>\n#include<climits>\n#include<map>\n#include<set>\n#include<cassert>\n#include<deque>\n#define REP(i,s,n) for(int i=s;i<n;i++)\n#define rep(i,n) REP(i,0,n)\n#define INF 1<<27\n#define all(n) n.begin(),n.end()\n#define insert(a,b,c,d) PP(P(a,b),P(c,d))\n#define F first\n#define S second\n#define pb push_back\n#define MAX_N 100100\n#define foreach(i,c) for(iter(c) i=(c).begin();i!=(c).end();++i)\nusing namespace std;\ntypedef pair<int,int> P;\ntypedef pair<P,P> PP;\ntypedef long long ll;\n\n\n\n\n\ntemplate<class T>\nclass RMQ_segment{\nprivate:\n  int n;\n  T dat[2*MAX_N-1];\npublic:\n  void init(int n_){\n    n = 1;\n    while(n<n_)n*=2;\n    for(int i=0;i<2*n-1;i++)dat[i] = 0;\n  }\n\n  void update(int k,T a){\n    k += n-1;\n    dat[k] = a;\n    while(k > 0){\n      k = (k-1)/2;\n      dat[k] = max(dat[k*2+1],dat[k*2+2]);\n    }\n  }\n\n  T query(int a,int b,int k,int l,int r){\n    if(r<=a || b<=l)return 0;\n    else if(a<=l && r<=b)return dat[k];\n    \n      T vl = query(a,b,k*2+1,l,(l+r)/2);\n      T vr = query(a,b,k*2+2,(l+r)/2,r);\n      return max(vl,vr);\n    \n  }\n\n  T _query(int a,int b){//nの範囲でミスしないように極力こっちを利用\n    return query(a,b,0,0,n);\n  }\n\n};\n\n\n int x[100010];\n RMQ_segment<ll> rmq;\nint main(){\n  int n;\n  cin >> n;\n \n  rmq.init(n+1);\n \n  rep(i,n)cin >> x[i];\n  ll mex=0;\n  ll sum=0;\n\n  for(int i=0;i<n;i++){\n    sum+=x[i];\n    ll premex = rmq._query(0,x[i])+x[i];\n    rmq.update(x[i],premex);\n    mex = max(mex,premex);\n   \n  }  \n  \n  cout << sum-mex << endl;\n\nreturn 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include<bits/stdc++.h>\nusing namespace std;\ntypedef long long ll;\n\nstruct seg {\n  ll d[(1<18)];\n  int n;\n  void init(int _n){\n    n = 1;\n    while( n < _n ) n*=2;\n    memset(d,0,sizeof(d));\n  }\n  ll query(int a,int b,int k,int l,int r){\n    if( r <= a || b <= l ) return 0;\n    else if( a <= l && r <= b ) return d[k];\n    return max( query( a, b, 2*k+1, l, (l+r)/2 ), query( a, b, 2*k+2, (l+r)/2, r ) );\n  }\n  ll query(int a,int b){\n    return query( a, b, 0, 0, n );\n  }\n  void set(int k,ll x) {\n    k += n-1;\n    d[k] = x;\n    while( k > 0 ){\n      k = (k-1)/2;\n      d[k] = max( d[2*k+1], d[2*k+2] );\n    }\n  }\n};\ntypedef pair<ll,int> P;\n\nseg S;\nint N;\nll X[100005];\nP p[100005];\nint main(){\n  cin >> N;  S.init( N );\n  for(int i=0;i<N;i++){\n    cin >> X[i];\n    p[i] = P(X[i],i);\n  }\n  sort( p, p+N );\n  ll res = 0;\n  for(int i=N-1;i>-1;i--){\n    int k = p[i].second;\n    ll num = S.query( k, N );\n    res = max( res, num + p[i].first );\n    S.set( k, num+p[i].first );\n  }\n  cout << N*(N+1)/2 - res << endl;\n  \n}"
  },
  {
    "language": "C++",
    "code": "#include <iostream>\n#include <algorithm>\n#include <cstdio>\nusing namespace std;\n\ntypedef long long ll;\nconst ll MAX = 100000;\n\nint main(){\n    int n;\n    while(cin >> n){\n        ll a[MAX],ans=0,v[MAX];\n        for(int i=0;i<n;i++) scanf(\"%lld\",&a[i]);\n        fill(v,v+n,0);\n        for(int i=0;i<n;i++){\n            ll in = v[a[i]-1] + a[i];\n            ans = max(ans,in);\n            int pos = lower_bound(v+a[i]-1,v+n,in) - v;\n            fill(v+a[i]-1,v+pos,in);\n        }\n        printf(\"%lld\\n\",(ll)n*(n+1)/2 - ans);\n    }\n}"
  },
  {
    "language": "C++",
    "code": "#include <cstdio>\n#include <cstdlib>\n#include <cstring>\n#include <climits>\n#include <cmath>\n#include <cassert>\n#include <iostream>\n#include <sstream>\n#include <iomanip>\n#include <algorithm>\n#include <numeric>\n#include <complex>\n#include <list>\n#include <stack>\n#include <queue>\n#include <set>\n#include <map>\n#include <bitset>\n#include <utility>\n#include <functional>\n#include <iterator>\n\nusing namespace std;\n\n#define dump(n) cerr<<\"# \"<<#n<<\"=\"<<(n)<<endl\n#define repi(i,a,b) for(int i=int(a);i<int(b);i++)\n#define peri(i,a,b) for(int i=int(b);i-->int(a);)\n#define rep(i,n) repi(i,0,n)\n#define per(i,n) peri(i,0,n)\n#define iter(c) __typeof__((c).begin())\n#define foreach(i,c) for(iter(c) i=(c).begin();i!=(c).end();++i)\n#define all(c) (c).begin(),(c).end()\n#define mp make_pair\n\ntypedef unsigned int uint;\ntypedef long long ll;\ntypedef unsigned long long ull;\ntypedef vector<int> vi;\ntypedef vector<vi> vvi;\ntypedef vector<double> vd;\ntypedef vector<vd> vvd;\ntypedef vector<string> vs;\ntypedef pair<int,int> pii;\n\nstruct SegTree{\n\tvi data;\n\tint size;\n\tSegTree(int _size){\n\t\tfor(int i=1;;i<<=1)\n\t\t\tif(i>=_size){\n\t\t\t\tsize=i;\n\t\t\t\tbreak;\n\t\t\t}\n\t\tdata.assign(2*size,0);\n\t}\n\tvoid Update(int i,int n){\n\t\tdata[size+i]=n;\n\t\tfor(int j=size+i;j;j>>=1)\n\t\t\tdata[j]=max(data[j],n);\n\t}\n\tint Query(int a,int b,int i,int l,int r){\n\t\tif(b<=l || r<=a) return 0;\n\t\tif(a<=l && r<=b) return data[i];\n\t\tint res=0,m=(l+r)/2;\n\t\tif(a<m) res=max(res,Query(a,b,i*2+0,l,m));\n\t\tif(m<b) res=max(res,Query(a,b,i*2+1,m,r));\n\t\treturn res;\n\t}\n\tint Query(int a,int b){\n\t\treturn Query(a,b,1,0,size);\n\t}\n};\n\nint main()\n{\n\tfor(int n;cin>>n;){\n\t\tvi a(n);\n\t\trep(i,n) cin>>a[i];\n\t\t\n\t\tvi b(n);\n\t\trep(i,n) b[a[i]-1]=i;\n\t\t\n\t\tSegTree st(n);\n\t\tll mx=0;\n\t\trep(i,n){\n\t\t\tst.Update(b[i],st.Query(0,b[i])+i+1);\n\t\t\tmx=max<ll>(mx,st.Query(0,b[i]+1));\n\t\t}\n\t\tcout<<n*(n+1)/2-mx<<endl;\n\t}\n\t\n\treturn 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include <cstdio>\n#include <cstdlib>\n#include <cstring>\n#include <cmath>\n#include <climits>\n#include <cfloat>\n#include <ctime>\n#include <cassert>\n#include <map>\n#include <utility>\n#include <set>\n#include <iostream>\n#include <memory>\n#include <string>\n#include <vector>\n#include <algorithm>\n#include <functional>\n#include <sstream>\n#include <complex>\n#include <stack>\n#include <queue>\n#include <numeric>\n#include <list>\n#include <iomanip>\n   \nusing namespace std;\n   \n \n#ifdef __GNUC__\ntemplate <class T> int popcount(T n);\ntemplate <> int popcount(unsigned int n) { return __builtin_popcount(n); }\ntemplate <> int popcount(int n) { return __builtin_popcount(n); }\ntemplate <> int popcount(unsigned long long n) { return __builtin_popcountll(n); }\ntemplate <> int popcount(long long n) { return __builtin_popcountll(n); }\n#else\n#define __typeof__ decltype\ntemplate <class T> int popcount(T n) { return n ? 1 + popcount(n & (n - 1)) : 0; }\n#endif\n \n#define rep(i, n) for (int i = 0; i < (int)n; ++i)\n#define foreach(it, c) for (__typeof__((c).begin()) it=(c).begin(); it != (c).end(); ++it)\n#define rforeach(it, c) for (__typeof__((c).rbegin()) it=(c).rbegin(); it != (c).rend(); ++it)\n#define all(c) (c).begin(), (c).end()\n#define rall(c) (c).rbegin(), (c).rend()\n#define CL(arr, val) memset(arr, val, sizeof(arr))\n#define COPY(dest, src) memcpy(dest, src, sizeof(dest))\n   \ntemplate <class T> void max_swap(T& a, const T& b) { a = max(a, b); }\ntemplate <class T> void min_swap(T& a, const T& b) { a = min(a, b); }\n\ntemplate <class T> void sort(vector<T>& c) { sort(c.begin(), c.end()); }\ntemplate <class T> void unique(vector<T>& c) { sort(c.begin(), c.end()); c.erase(unique(c.begin(), c.end()), c.end()); }\n \ntypedef long long ll;\ntypedef pair<int, int> pint;\n   \ntemplate <class T, class U> ostream& operator<<(ostream& os, pair<T, U>& p) { os << \"( \" << p.first << \", \" << p.second << \" )\"; return os;  }\n  \ntemplate <class T> string to_s(const T& a) { ostringstream os; os << a; return os.str(); }\ntemplate <class T> T to_T(const string& s) { istringstream is(s); T res; is >> res; return res; }\n  \nbool valid(int x, int y, int w, int h) { return 0 <= x && x < w && 0 <= y && y < h; }\n   \ntemplate <class T> void print(T a, int n, const string& deli = \" \", int br = 1) { for (int i = 0; i < n; ++i) { cout << a[i]; if (i + 1 != n) cout << deli; } while (br--) cout << endl; }\ntemplate <class T> void print(const T& c, const string& deli = \" \", int br = 1) { foreach (it, c) { cout << *it; if (++it != c.end()) cout << deli;--it; } while (br--) cout << endl; }\ntemplate <class T> void print2d(T a, int w, int h, int width = -1, int br = 1) { for (int i = 0; i < h; ++i) { for (int j = 0; j < w; ++j) {    if (width != -1) cout.width(width); cout << a[i][j] << ' '; } cout << endl; } while (br--) cout << endl; }\n   \ntemplate <class T> void input(T& a, int n) { for (int i = 0; i < n; ++i) cin >> a[i]; }\ntemplate <class T, class U> void input(T& a, U& b, int n) { for (int i = 0; i < n; ++i) cin >> a[i] >> b[i]; }\n  \nconst int dx[] = { 0, 1, 0, -1 };\nconst int dy[] = { 1, 0, -1, 0 };\n  \nconst double PI = acos(-1.0);\nconst int mod = 1000000007;\n\n\n\n\nll node[2 * 114514];\nint size;\nvoid init(int n)\n{\n    size = 1;\n    while (size < n)\n        size *= 2;\n}\nvoid update(int k, ll a)\n{\n    k += size - 1;\n    node[k] = a;\n    while (k > 0)\n    {\n        k = (k - 1) / 2;\n        node[k] = max(node[2 * k + 1], node[2 * k + 2]);\n    }\n}\nll query(int a, int b, int k = 0, int l = 0, int r = ::size)\n{\n    if (r <= a || l >= b)\n        return 0;\n    else if (a <= l && r <= b)\n        return node[k];\n\n    ll left = query(a, b, 2 * k + 1, l, (l + r) / 2);\n    ll right = query(a, b, 2 * k + 2, (l + r) / 2, r);\n    return max(left, right);\n}\n\nint main()\n{\n    int n;\n    static int a[114514];\n    scanf(\"%d\", &n);\n    for (int i = 0; i < n; ++i)\n        scanf(\"%d\", a + i);\n\n    init(n + 1);\n    for (int i = 0; i < n; ++i)\n    {\n        ll max_seq = query(0, a[i]);\n        update(a[i], max_seq + a[i]);\n    }\n    ll max_seq = query(1, n + 1);\n    ll res = (ll)n * (n + 1) / 2 - max_seq;\n    printf(\"%lld\\n\", res);\n}"
  },
  {
    "language": "C++",
    "code": "#include <iostream>\n#include <algorithm>\n#include <vector>\n#include <cstdio>\nusing namespace std;\n\ntypedef long long ll;\ntypedef pair<ll,ll> P;\n\nconst ll MAX = 100000;\n\nint main(){\n    int n;\n    while(cin >> n){\n        ll a[MAX],ans=0;\n        vector<P> s;\n        for(int i=0;i<n;i++) scanf(\"%lld\",&a[i]);\n        for(int i=0;i<n;i++){\n            ll cnt = 0;\n            if(i > 0){\n                vector<P>::iterator it = s.end();\n                while(1){\n                    it = lower_bound(s.begin(),it,P((it-1)->first,0));\n                    if(it->second < a[i]){\n                        cnt = it->first;\n                        break;\n                    } else if(it == s.begin()) break;\n                }\n            }\n            P in = P(cnt+a[i], a[i]);\n            ans = max(ans,in.first);\n            s.insert(lower_bound(s.begin(),s.end(),in), in);\n        }\n        printf(\"%lld\\n\",(ll)n*(n+1)/2 - ans);\n    }\n}"
  },
  {
    "language": "C++",
    "code": "#include<iostream>\n#include<algorithm>\n\nusing namespace std;\n\ntypedef long long Int;\n\nInt bit[105000];\n\nvoid setnum(int pos, Int val){\n\twhile(pos < 105000){\n\t\tbit[pos] = max(val, bit[pos]);\n\t\tpos += pos & -pos;\n\t}\n}\n\nInt maxnum(int pos){\n\tInt res = 0;\n\twhile(pos){\n\t\tres = max(res, bit[pos]);\n\t\tpos -= pos &-pos;\n\t}\n\treturn res;\n}\n\nint main(){\n\tInt n, sum = 0, x;\n\tcin >> n;\t\n\tfor(int i = 0;i < n;i++){\n\t\tcin >> x;\n\t\tsum += x;\n\t\tInt p = x + maxnum(x);\n\t\tsetnum(x, p);\n\t}\n\tcout << sum - maxnum(10100) << endl;\n\treturn 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include<cstdio>\n#include<algorithm>\n\n#define rep(i,n) for(int i=0;i<(n);i++)\n\nusing namespace std;\n\ntypedef long long ll;\n\ntemplate<class T>\nclass segment_tree_RMQ{\n\tstatic const int N_MAX=1<<17;\n\tint n;\n\tT dat[2*N_MAX];\n\n\tT query(int l,int r,int a,int b,int u){\n\t\tif(l<=a && b<=r) return dat[u];\n\n\t\tT res=0;\n\t\tint c=(a+b+1)/2;\n\t\tif(l<c && a<r) res=max(res,query(l,r,a,c,2*u));\n\t\tif(l<b && c<r) res=max(res,query(l,r,c,b,2*u+1));\n\t\treturn res;\n\t}\n\npublic:\n\tvoid build(int N,T val){\n\t\tfor(n=1;n<N;n*=2);\n\t\trep(u,2*n) dat[u]=val;\n\t}\n\n\tvoid update(int u,T v){\n\t\tu+=n;\n\t\tdat[u]=v;\n\t\tfor(u/=2;u>1;u/=2) dat[u]=max(dat[2*u],dat[2*u+1]);\n\t}\n\n\tT query(int l,int r){ return query(l,r,0,n,1); }\n};\n\nint main(){\n\tint n; scanf(\"%d\",&n);\n\tint x[100000];\n\trep(i,n) scanf(\"%d\",x+i);\n\n\tstatic segment_tree_RMQ<ll> S;\n\tS.build(n+1,0);\n\trep(i,n){\n\t\tll cost=S.query(0,x[i]);\n\t\tS.update(x[i],cost+x[i]);\n\t}\n\n\tprintf(\"%lld\\n\",(ll)n*(n+1)/2-S.query(0,n+1));\n\n\treturn 0;\n}"
  },
  {
    "language": "C++",
    "code": "////////////////////////////////////////\n///  tu3 pro-con template            ///\n////////////////////////////////////////\n#include <cassert>\n#include <cstdio>\n#include <cstring>\n#include <cmath>\n#include <iostream>\n#include <sstream>\n#include <algorithm>\n#include <numeric>\n#include <functional>\n#include <vector>\n#include <queue>\n#include <string>\n#include <complex>\n#include <stack>\n#include <set>\n#include <map>\n#include <list>\n#include <unordered_map>\n#include <unordered_set>\n#include <bitset>\n#include <regex>\nusing namespace std;\n\n//// MACRO ////\n#define countof(a) (sizeof(a)/sizeof(a[0]))\n\n#define REP(i,n) for (int i = 0; i < (n); i++)\n#define RREP(i,n) for (int i = (n)-1; i >= 0; i--)\n#define FOR(i,s,n) for (int i = (s); i < (n); i++)\n#define RFOR(i,s,n) for (int i = (n)-1; i >= (s); i--)\n#define pos(c,i) c.being() + (i)\n#define allof(c) c.begin(), c.end()\n#define aallof(a) a, countof(a)\n#define partof(c,i,n) c.begin() + (i), c.begin() + (i) + (n)\n#define apartof(a,i,n) a + (i), a + (i) + (n)\n#define long long long\n\n#define EPS 1e-9\n#define INF (1L << 30)\n#define LINF (1LL << 60)\n\n#define PREDICATE(t,a) [&](const t & a) -> bool\n#define COMPARISON_T(t) bool(*)(const t &, const t &)\n#define COMPARISON(t,a,b) [&](const t & a, const t & b) -> bool\n#define CONVERTER(TSrc,t,TDest) [&](const TSrc &t)->TDest\n\n//// i/o helper ////\nstruct _Reader { template <class T> _Reader operator ,(T &rhs) { cin >> rhs; return *this; } };\nstruct _Writer { bool f; _Writer() : f(false) { } template <class T> _Writer operator ,(const T &rhs) { cout << (f ? \" \" : \"\") << rhs; f = true; return *this; } };\n#define READ(t,...) t __VA_ARGS__; _Reader(), __VA_ARGS__\n#define WRITE(...) _Writer(), __VA_ARGS__; cout << endl\n\ntemplate <class T> struct vevector : public vector<vector<T>> { vevector(int n = 0, int m = 0, const T &initial = T()) : vector<vector<T>>(n, vector<T>(m, initial)) { } };\ntemplate <class T> struct vevevector : public vector<vevector<T>> { vevevector(int n = 0, int m = 0, int l = 0, const T &initial = T()) : vector<vevector<T>>(n, vevector<T>(m, l, initial)) { } };\ntemplate <class T> struct vevevevector : public vector<vevevector<T>> { vevevevector(int n = 0, int m = 0, int l = 0, int k = 0, const T &initial = T()) : vector<vevevector<T>>(n, vevevector<T>(m, l, k, initial)) { } };\ntemplate <class T> T read() { T t; cin >> t; return t; }\ntemplate <class T> vector<T> read(int n) { vector<T> v; REP(i, n) { v.push_back(read<T>()); } return v; }\ntemplate <class T> vevector<T> read(int n, int m) { vevector<T> v; REP(i, n) v.push_back(read<T>(m)); return v; }\ntemplate <class T> vevector<T> readjag() { return read<T>(read<int>()); }\ntemplate <class T> vevector<T> readjag(int n) { vevector<T> v; REP(i, n) v.push_back(readjag<T>()); return v; }\n\ntemplate <class T1, class T2> inline istream & operator >> (istream & in, pair<T1, T2> &p) { in >> p.first >> p.second; return in; }\ntemplate <class T1, class T2> inline ostream & operator << (ostream &out, pair<T1, T2> &p) { out << p.first << p.second; return out; }\ntemplate <class T> inline ostream & operator << (ostream &out, vector<T> &v)\n{\n\tostringstream ss;\n\tfor (auto x : v) ss << x << ' ';\n\tauto s = ss.str();\n\tout << s.substr(0, s.length() - 1) << endl;\n\treturn out;\n}\n\n//// start up ////\nvoid solve();\nint main()\n{\n\tsolve();\n\treturn 0;\n}\n\n//// data structure ////\n\n/// 2分セグメント木。RMQとかが解ける。\ntemplate<class T = int, class TParentFunc = const T& (*)(const T&, const T&)>\nstruct SegTree\n{\n\tunsigned msb(unsigned v) { v |= v >> 1; v |= v >> 2; v |= v >> 4; v |= v >> 8; v |= v >> 16; return (v >> 1) + 1; }\n\n\tint size;\n\tvector<T> tree;\n\tTParentFunc parent;\n\n\tSegTree(int count, TParentFunc parentBuilder = std::min, T initialFill = INF)\n\t\t: size(msb(count - 1) << 1)\n\t\t, tree(size * 2)\n\t\t, parent(parentBuilder)\n\t{\n\t\tfill(partof(tree, size, size), initialFill);\n\t\trebuild();\n\t}\n\n\t// []を使うと更新されないのでrebuildすること。数が少なければupdateの方がよい。\n\tT& operator[](int i) { return tree[i + size]; }\n\tvoid rebuild() { RREP(i, size) { tree[i] = parent(tree[i * 2], tree[i * 2 + 1]); } }\n\n\tvoid update(int index, T value)\n\t{\n\t\ttree[index + size] = value;\n\t\tfor (int i = (index + size) / 2; i > 0; i /= 2)\n\t\t\ttree[i] = parent(tree[i * 2], tree[i * 2 + 1]);\n\t}\n\n\tT query(int s, int e, int i, int l, int r, T value)\n\t{\n\t\tif (r <= s || e <= l) return value;\n\t\tif (s <= l && r <= e) return parent(value, tree[i]);\n\t\tvalue = query(s, e, i * 2, l, (l + r) / 2, value);\n\t\tvalue = query(s, e, i * 2 + 1, (l + r) / 2, r, value);\n\t\treturn value;\n\t}\n\n\tT query(int start, int count, T initialValue)\n\t{\n\t\treturn query(start, start + count, 1, 0, size, initialValue);\n\t}\n};\n\n\n////////////////////\n/// template end ///\n////////////////////\n\nvoid solve()\n{\n\tint testcases = 1;\n\tREP(testcase, testcases)\n\t{\n\t\tREAD(int, N);\n\t\tauto x = read<int>(N);\n\t\tSegTree<int> st(N, max, 0);\n\t\tREP(i, N) st.update(x[i] - 1, st.query(0, x[i] - 1, 0) + x[i]);\n\t\tWRITE(accumulate(allof(x), 0) - st.query(0, N, 0));\n\t}\n}"
  },
  {
    "language": "C++",
    "code": "#include<bits/stdc++.h>\nusing namespace std;\n#define int long long\n#define pb push_back \n#define mp make_pair\n#define fr first\n#define sc second\n#define Rep(i,n) for(int i=0;i<(n);i++)\n#define All(v) v.begin(),v.end()\ntypedef pair<int, int> Pii; typedef pair<int, Pii> Pip;\nconst int INF = (1<<30);\n\nstruct SegT\n{\n  vector<int> tree;\n  int n;\n \n  SegT(int n_)\n  {\n    n = 1;\n    while( n < n_ ) n <<= 1;\n    tree = vector<int>(2 * n - 1, 0);\n  }\n  int rmq(int a, int b, int k, int l, int r)\n  {\n    if( a >= r || b <= l ) return 0;\n    if( a <= l && r <= b ) return tree[k];\n    return(max(rmq(a, b, 2 * k + 1, l, (l + r) >> 1),\n               rmq(a, b, 2 * k + 2, (l + r) >> 1, r)));\n  }\n  int rmq(int a, int b)\n  {\n    return (rmq(a, b, 0, 0, n));\n  }\n  int update(int k, int x)\n  {\n    k += n - 1;\n    tree[k] = x;\n    while( k > 0 ) {\n      k = (k - 1) >> 1;\n      tree[k] = max(tree[2 * k + 1], tree[2 * k + 2]);\n    }\n  }\n};\n\nmain() {\n  int n;\n  cin >> n;\n  SegT tree( n+1 );\n\n  Rep(i, n) {\n    int x;\n    cin >> x;\n    tree.update(x, tree.rmq(1, x) + x);\n  }\n\n  cout << n * (n+1) / 2 - tree.rmq(1, n+1) << endl;\n}"
  },
  {
    "language": "C++",
    "code": "#include <iostream>\n#include <algorithm>\n#include <utility>\n#include <vector>\n#include <list>\n#include <map>\n#include <set>\n#include <queue>\n#include <stack>\n#include <string>\n#include <sstream>\n#include <cstring>\n#include <cstdlib>\n\nusing namespace std;\n\n#define ALL(c) c.begin(),c.end()\n#define RALL(c) c.rbegin(),c.rend()\n#define SORT(x) sort((x).begin(),(x).end())\n#define REP(i,x,y) for(int i=(x);i<(y);++i)\n#define MP(a,b) make_pair((a),(b))\n#define F_ first\n#define S_ second\n#define debug(x) #x << \"=\" << (x)\n \n#ifdef DEBUG\n#define _GLIBCXX_DEBUG\n#define dump(x) std::cerr << debug(x) << \" (L:\" << __LINE__ << \")\" << std::endl\n#else\n#define dump(x)\n#endif\n\ntypedef long long int lli;\ntypedef pair<int,int> pii;\ntemplate<typename T> using vec=std::vector<T>;\n\nconst int INF=1<<30;\nconst long long int INF_=1LL<<58;\nconst double EPS=1e-9;\nconst int dx[]={1,0,-1,0},dy[]={0,1,0,-1};\n\ntemplate <typename T> ostream &operator<<(ostream &os, const vector<T> &vec){\n\tos << \"[\";\n\tfor (const auto &v : vec) {\n\t\tos << v << \",\";\n\t}\n\tos << \"]\";\n\treturn os;\n}\n\nint main(){\n\tstd::ios::sync_with_stdio(false);\n\tstd::cin.tie(0);\n\tint N;\n\tcin >> N;\n\tvec<int> x(N);\n\tREP(i,0,N) cin >> x[i];\n\tvec<int> s(N);\n\ts[0]=x[0];\n\tREP(i,1,N) s[i]+=s[i-1]+x[i];\n\tvec<vec<int>> dp(N,vec<int>(2));\n\tdp[0][0]=x[0];\n\tREP(i,1,N){\n\t\tdp[i][0]=min(dp[i-1][0],dp[i-1][1])+x[i];\n\t\tdp[i][1]=s[i-1];\n\t\tfor(int j=i-1; j>=0; --j) if(x[i]>x[j]){\n\t\t\tdp[i][1]=min(dp[i][1],dp[j][1]+s[i-1]-s[j]);\n\t\t}\n\t}\n\tcout << dp << endl;\n\tcout << min(dp[N-1][1],dp[N-1][0]) << endl;\n\treturn 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include<iostream>\n#include<vector>\n#include<algorithm>\n#include<climits>\n\nconst int MAX_N=100000;\n\ntypedef long long ll;\n\nusing namespace std;\n\nll n,dat[2*MAX_N-1];\n\nvoid init(int n_){\n\tn=1;\n\twhile(n<n_)n*=2;\n\tfor(int i=0;i<2*n-1;i++)dat[i]=0;\n}\n\nvoid update(int k,int a){\n\tk+=n-1;\n\tdat[k]=a;\n\t\n\twhile(k>0){\n\t\tk=(k-1)/2;\n\t\tdat[k]=max(dat[2*k+1],dat[2*k+2]);\n\t}\n}\n\nint query(int a,int b,int k,int l,int r){\n\tif(r<=a || b<=l)return 0;\n\tif(a<=l && r<=b)return dat[k];\n\telse {\n\t\tint vl=query(a,b,k*2+1,l,(l+r)/2);\n\t\tint vr=query(a,b,k*2+2,(l+r)/2,r);\n\t\treturn max(vl,vr);\n\t}\n}\n\nint main(void){\n\t\n\tll in,n_,ans=0;\n\tcin >> n_;\n\t\n\tinit(n_);\n\t\n\tfor(int i=0;i<n_;i++){\n\t\tcin >> in;\n\t\tupdate(in,in+query(1,in+1,0,0,n));\n\t\tans=max(ans,dat[in+n-1]);\n\t}\n\tcout << n_*(n_+1)/2-ans << endl;\n\t\n\treturn 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include <iostream>\n#include <vector>\n#include <utility>\n#include <algorithm>\nusing namespace std;\n\n#define INF 1e9\n\nclass SegmentTree{\npublic:\n  SegmentTree(int size)\n    : n(power2(size)),\n      node(vector<long long int>(2 * n - 1, NEUTRAL()))\n  {}\n  \n  SegmentTree(vector<long long int>& init){\n    n = power2(init.size());\n    node = vector<long long int>(2 * n - 1, NEUTRAL());\n    \n    // テ、ツクツ?ァツ閉ェテ、ツクツ凝」ツ?ョテヲツョツオテ」ツ?ォテ・ツ?・テ・ツ環崚」ツつ津・ツ渉療」ツ?妥・ツ渉姪」ツつ?\n    for(size_t i = 0; i < init.size(); i++){ node[n - 1 + i] = init[i]; }\n    // テ、ツクツ甘」ツ?ョテヲツョツオテ」ツつづゥツ?妥・ツシツオテ」ツ?」テ」ツ?ヲテ、ツスツ愿」ツつ?\n    for(int i = n - 2; i >= 0; i--){ node[i] = func(node[2 * i + 1], node[2 * i + 2]); }\n  }\n\n  // テ・ツ個コテゥツ鳴禿」ツつッテ」ツつィテ」ツδェ\n  int RangeQuery(int a, int b){ return _RQ(a, b, 0, 0, n); }\n\n  // テヲツ個?・ツョツ堙ァツョツ?ヲツ可?」ツ?ョテ・ツ?、テ」ツつ津・ツ、ツ嘉ヲツ崢エ\n  void change(int index, long long int value){\n    int k = n - 1 + index;\n    node[k] = value;\n    update((k - 1) / 2);\n  }\n\n  // テヲツ慊ィテ」ツ?ョテ・ツ?コテ・ツ環?(テ」ツδ?」ツδ静」ツδε」ツつーテァツ板ィ)\n  void print(){\n    int h = 1, cnt = 1;\n    for(size_t i = 0; i < node.size(); i++){\n      cout << \"[\" << node[i] << \"]\";\n      if(h <= cnt){\n        cout << endl;\n        h *= 2;\n        cnt = 0;\n      }\n      cnt++;\n    }\n  }\n\nprivate:\n  int n;\n  vector<long long int> node;\n\n  // テヲツッツ氾ィツシツεゥツ鳴「テヲツ閉ー\n  // テ・ツ個コテゥツ鳴禿ヲツ慊?・ツーツ湘」ツつッテ」ツつィテ」ツδェテ」ツ?ェテ」ツつ?min(x, y), テ・ツ個コテゥツ鳴禿・ツ陳古」ツ?ェテ」ツつ?x + y テ」ツ?ェテ」ツ?ゥ\n  int func(int x, int y){ return max(x, y); }\n  // テ・ツ債佚、ツスツ催・ツ??\n  // テ・ツ個コテゥツ鳴禿ヲツ慊?・ツーツ湘」ツつッテ」ツつィテ」ツδェテ」ツ?ェテ」ツつ?テ・ツキツィテ・ツ、ツァテ」ツ?ェテヲツ閉ー, テ・ツ個コテゥツ鳴禿・ツ陳古」ツ?ェテ」ツつ?0 テ」ツ?ェテ」ツ?ゥ\n  int NEUTRAL(){ return 0; }\n  \n  // sテ、ツサツ・テ、ツクツ甘」ツ?ァテ」ツ?づ」ツつ凝ヲツ慊?・ツーツ湘」ツ?ョ2^nテ」ツつ津ヲツアツづ」ツつ?」ツつ?\n  int power2(int s){\n    int logs = 32 - __builtin_clz(s);\n    return 1 << logs;\n    //int count, ans = 1;\n    //for(count = 0; s != 0; count++){ s /= 2; }\n    //for(int i = 0; i < count; i++){ ans *= 2; }\n    //return ans;\n  }\n\n  // [a, b)テ」ツ?ョテァツッツ?・ツ崢イテ」ツ?ァテ」ツ?ョテ・ツ個コテゥツ鳴禿・ツ?、テ」ツつ津ヲツアツづ」ツつ?」ツ?淌」ツ??\n  // テ」ツ?。テ」ツ?ェテ」ツ?ソテ」ツ?ォ[l, r)テ」ツ?ョテァツッツ?・ツ崢イテ」ツ?ァテ」ツ?ョテ・ツ個コテゥツ鳴禿・ツ?、テ」ツ?ッnode[k]テ」ツ?ァテ」ツ?づ」ツつ?\n  int _RQ(int a, int b, int k, int l, int r){\n    // [l, r)テ」ツ?古ヲツ?敕」ツ??」ツ?」テ」ツ?催」ツつ骸a, b)テ」ツ?ョテ・ツ、ツ姪」ツ??」ツ?」テ」ツ?淌・ツ?エテ・ツ青暗」ツ??・ツ債佚、ツスツ催・ツ?ε」ツつ津ィツソツ氾」ツ?療」ツ?ヲテ」ツ?甘」ツ??\n    if(r <= a || b <= l){ return NEUTRAL(); }\n    // [l, r)テ」ツ?古ヲツ?敕」ツ??」ツ?」テ」ツ?催」ツつ骸a, b)テ」ツ?ォテ・ツ??・ツ個?」ツ?陛」ツつ古」ツ?ヲテ」ツ??」ツ?淌・ツ?エテ・ツ青暗」ツ??」ツ?禿」ツ?ョテァツッツ?・ツ崢イテ」ツ?ョテァツオツ静ヲツ楪愿」ツつ津ィツソツ氾」ツ??\n    if(a <= l && r <= b){ return node[k]; }\n    \n    // 2テ」ツ?、テ」ツ?ョテ・ツュツ静」ツδ偲」ツδシテ」ツδ嘉」ツ?ァテ」ツ?ョテ・ツ個コテゥツ鳴禿・ツ?、テ」ツつ津・ツ?催・ツクツーテァツ堋?」ツ?ォテヲツアツづ」ツつ?」ツ??」ツ?敕」ツ?ョテ」ツ??」ツ?。テゥツ?ゥテ・ツ按?」ツ?ェテ」ツ?サテ」ツ??」ツつ津ィツソツ氾」ツ??\n    int vl = _RQ(a, b, 2 * k + 1, l, (l + r) / 2);\n    int vr = _RQ(a, b, 2 * k + 2, (l + r) / 2, r);\n    return func(vl, vr);\n  }\n\n  // node[k]テ」ツ?ョテヲツ崢エテヲツ鳴ー\n  void update(int k){\n    if(k < 0){ return; }\n    \n    int prior = node[k];\n    node[k] = func(node[2 * k + 1], node[2 * k + 2]);\n    // テヲツ崢エテヲツ鳴ーテ・ツ可催」ツ?ィテァツオツ静ヲツ楪愿」ツ?古・ツ、ツ嘉」ツつ湘」ツつ嘉」ツ?ェテ」ツ?凝」ツ?」テ」ツ?淌」ツつ?or テ、ツクツ?ァツ閉ェテ、ツクツ甘」ツ?セテ」ツ?ァテヲツ崢エテヲツ鳴ーテ」ツ?古ァツオツづ」ツつ湘」ツ?」テ」ツ?淌」ツつ嘉」ツ??\n    // テ」ツ?禿」ツつ古」ツつ暗」ツつ甘、ツクツ甘」ツつ津ヲツ崢エテヲツ鳴ーテ」ツ?凖」ツつ凝・ツソツ?ィツヲツ?」ツ?古」ツ?ェテ」ツ??」ツ?ョテ」ツ?ァreturn\n    if(node[k] == prior || k <= 0){ return; }\n\n    // テ」ツ?セテ」ツ??ヲツ崢エテヲツ鳴ーテ」ツ?凖」ツつ凝・ツソツ?ィツヲツ?」ツ?古」ツ?づ」ツつ古」ツ?ーテァツカツ堙」ツ?妥」ツつ?\n    update((k - 1) / 2);\n  }\n};\n\n\n\nint main(void){\n  int n;\n  cin >> n;\n  long long int sum = 0;\n  int max_input = 0;\n  vector<int> input(n); \n  for(int i = 0; i < n; i++){\n    cin >> input[i];\n    sum += input[i];\n    max_input = max(max_input, input[i]);\n  }\n\n  SegmentTree taro(max_input + 1);\n\n  for(int i = 0; i < n; i++){\n    taro.change(input[i], taro.RangeQuery(0, input[i]) + input[i]);\n  }\n\n  cout << sum - taro.RangeQuery(0, max_input + 1) << endl;\n  return 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include<algorithm>\n#include<cassert>\n#include<cctype>\n#include<climits>\n#include<cmath>\n#include<cstdio>\n#include<cstdlib>\n#include<cstring>\n#include<iostream>\n#include<iomanip>\n#include<map>\n#include<numeric>\n#include<queue>\n#include<vector>\n#include<set>\n#include<string>\n#include<stack>\n#include<sstream>\n#include<complex>\n\n#define pb push_back\n#define clr clear()\n#define sz size()\n#define fs first\n#define sc second\n\n#define rep(i,a) for(int i=0;i<(int)(a);i++)\n#define rrep(i,a) for(int i=(int)(a)−1;i>=0;i−−)\n#define all(a) (a).begin(),(a).end()\n#define EQ(a,b) (abs((a)−(b)) < EPS)\n#define INIT(a) memset(a,0,sizeof(a))\n\nusing namespace std;\ntypedef double D;\ntypedef pair<int,int> P;\ntypedef long long ll;\ntypedef vector<int> vi;\ntypedef vector<string> vs;\n\nconst D EPS = 1e-7;\nconst D INF = 1e9;\nconst D PI = acos(-1);\nconst int N = 100100;\n\nll n,dat[2*N-1];\n\nvoid init(int n_){\n  n=1;\n  while(n<n_)n*=2;\n  rep(i,2*n-1)dat[i] = 0;\n}\n\nvoid update(ll k,ll a){\n  k += n-1;\n  dat[k] = a;\n  while(k>0){\n    k = (k-1)/2;\n    dat[k] = max(dat[k*2+1],dat[k*2+2]);\n  }\n}\n\n//return minimam value in [a,b). ( [l,r) is interval in which k is.)\nll query(int a,int b,int k,int l,int r){\n  if(r<=a || b<=l)return 0;\n  if(a<=l && r<=b)return dat[k];\n  ll vl = query(a,b,2*k+1,l,(l+r)/2);\n  ll vr = query(a,b,2*k+2,(l+r)/2,r);\n  return max(vl,vr);\n}\n\nint main(){\n  ll n_, x[N];\n\n  cin >> n_;\n  rep(i,n_)cin >> x[i];\n  init(n_);\n\n  ll ans = 0;\n  rep(i,n_){\n    ll val = query(0,x[i],0,0,n) + x[i];\n    ans = max(ans,val);\n    update(x[i]-1,val);\n  }\n\n  cout << n_*(n_+1)/2 - ans << endl;\n}"
  },
  {
    "language": "C++",
    "code": "#include <cstdio>\n#include <algorithm>\nusing namespace std;\n\nstruct Fenwick {\n  int n;\n  long long *p;\n  Fenwick(int n) : n(n), p(new long long[n+1]) {\n    fill(p, p+n+1, 0);\n  }\n  ~Fenwick() { delete[] p; }\n  void add(int i, long long a) {\n    for(i++; i <= n; i += i&-i) p[i] = max(p[i], a);\n  }\n  long long sum(int i) {\n    long long s = 0;\n    for(; i > 0; i -= i&-i) s = max(s, p[i]);\n    return s;\n  }\n};\n\nint main() {\n  int n; scanf(\"%d\", &n);\n  // static int xs[100000];\n  // for(int i = 0; i < n; i++) scanf(\"%d\", xs+i);\n  Fenwick fwt(n+1);\n  for(int i = 0; i < n; i++) {\n    int x; scanf(\"%d\", &x);\n    long long cost = fwt.sum(x-1)+x;\n    // printf(\"%d <- %d\\n\", x-1, cost);\n    fwt.add(x-1, cost);\n    // fwt.add(x, -cost);\n  }\n  printf(\"%lld\\n\", (long long)n*(n+1)/2-fwt.sum(n));\n  return 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include<bits/stdc++.h>\nusing namespace std;\n\ntypedef long long int ll;\ntypedef pair<int, int> pii;\ntypedef vector<int> vi;\ntypedef vector<pair<int, int> > vii;\n#define rrep(i, m, n) for(int (i)=(m); (i)<(n);  (i)++)\n#define erep(i, m, n) for(int (i)=(m); (i)<=(n); (i)++)\n#define  rep(i, n)    for(int (i)=0; (i)<(n);  (i)++)\n#define rrev(i, m, n) for(int (i)=(n)-1; (i)>=(m); (i)--)\n#define erev(i, m, n) for(int (i)=(n); (i)>=(m); (i)--)\n#define  rev(i, n)    for(int (i)=(n)-1; (i)>=0; (i)--)\n#define vrep(i, c)    for(__typeof((c).begin())i=(c).begin(); i!=(c).end(); i++)\n#define  ALL(v)       (v).begin(), (v).end()\n#define pb            push_back\n#define mp            make_pair\ntemplate<class T, class S> inline bool minup(T& m, const S x){ return m>(T)x ? (m=(T)x, true) : false; }\ntemplate<class T, class S> inline bool maxup(T& m, const S x){ return m<(T)x ? (m=(T)x, true) : false; }\n\nstatic const int    INF = 1000000000;\nstatic const ll     MOD = 1000000007LL;\nstatic const double EPS = 1E-10;\n\nconst int SZ = 1 << 19;\nint n, _n;\nint x[111111];\nll dp[4 * SZ + 1];\n\nvoid init(int n)\n{\n  _n = 1;\n  while(_n < n) _n *= 2;\n}\n\nvoid update(int k, ll x)\n{\n  k += _n - 1;\n  dp[k] = x;\n  while(k > 0){\n    k = (k - 1) / 2;\n    dp[k] = max(dp[2 * k + 1], dp[2 * k + 2]);\n  }\n}\n\nll query(int a, int b, int k = 0, int l = 0, int r = _n)\n{\n  if(r <= a || b <= l) return 0;\n  if(a <= l && r <= b) return dp[k];\n  return max(query(a, b, 2 * k + 1, l, (l + r) / 2),\n             query(a, b, 2 * k + 2, (l + r) / 2, r));\n}\n\nint main(int argc, char *argv[])\n{\n  cin >> n;\n  rep(i, n) cin >> x[i];\n\n  ll res = 0;\n  init(n);\n  rep(i, n){\n    update(x[i], query(1, x[i] + 1) + x[i]);\n    maxup(res, query(x[i], x[i] + 1));\n  }\n\n  cout << (ll)n * (n + 1LL) / 2LL - res << endl;\n    \n  return 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include <iostream>\n#include <algorithm>\n#include <utility>\n#include <vectortor>\n#include <list>\n#include <map>\n#include <set>\n#include <queue>\n#include <stack>\n#include <string>\n#include <sstream>\n#include <cstring>\n#include <cstdlib>\n\nusing namespace std;\n\n#define ALL(c) c.begin(),c.end()\n#define RALL(c) c.rbegin(),c.rend()\n#define SORT(x) sort((x).begin(),(x).end())\n#define REP(i,x,y) for(int i=(x);i<(y);++i)\n#define MP(a,b) make_pair((a),(b))\n#define F_ first\n#define S_ second\n#define debug(x) #x << \"=\" << (x)\n \n#ifdef DEBUG\n#define _GLIBCXX_DEBUG\n#define dump(x) std::cerr << debug(x) << \" (L:\" << __LINE__ << \")\" << std::endl\n#else\n#define dump(x)\n#endif\n\ntypedef long long int lli;\ntypedef pair<int,int> pii;\ntemplate<typename T> using vector=std::vectortor<T>;\n\nconst int INF=1<<30;\nconst long long int INF_=1LL<<58;\nconst double EPS=1e-9;\nconst int dx[]={1,0,-1,0},dy[]={0,1,0,-1};\n\ntemplate <typename T> ostream &operator<<(ostream &os, const vectortor<T> &vector){\n\tos << \"[\";\n\tfor (const auto &v : vector) {\n\t\tos << v << \",\";\n\t}\n\tos << \"]\";\n\treturn os;\n}\n\nclass SegmentTree{\n\tprivate:\n\tpublic:\n\tint size;\n\tvector<int> data;\n\tvoid Init(int n){\n\t\tsize=1;\n\t\twhile(size<n) size*=2;\n\t\tdata=vector<int>(size*2-1,INF);\n\t}\n\tvoid Update(int k,int a){\n\t\tk+=size-1;\n\t\tdata[k]=a;\n\t\twhile(k>0){\n\t\t\tk=(k-1)/2;\n\t\t\tdata[k]=min(data[k*2+1],data[k*2+2]);\n\t\t}\n\t}\t\n\tint Query(int a,int b,int k,int l,int r){\n\t\tif(r<=a||b<=l) return INF;\n\t\tif(a<=l&&r<=b) return data[k];\n\t\telse {\n\t\t\tint vl=Query(a,b,k*2+1,l,(l+r)/2);\n\t\t\tint vr=Query(a,b,k*2+2,(l+r)/2,r);\n\t\t\treturn min(vl,vr);\n\t\t}\n\t}\n};\n\nint main(){\n\tstd::ios::sync_with_stdio(false);\n\tstd::cin.tie(0);\n\tint N;\n\tcin >> N;\n\tvector<int> x(N);\n\tREP(i,0,N) cin >> x[i];\n\tvector<int> s(N);\n\ts[0]=x[0];\n\tREP(i,1,N) s[i]+=s[i-1]+x[i];\n\tvector<vector<int>> dp(N,vector<int>(2));\n\tdp[0][0]=x[0];\n\tSegmentTree st;\n\tst.Init(N);\n\tst.Update(x[0]-1,-s[0]);\n\tREP(i,1,N){\n\t\tdp[i][0]=min(dp[i-1][0],dp[i-1][1])+x[i];\n\t\tdp[i][1]=min(s[i-1],st.Query(0,x[i],0,0,st.size)+s[i-1]);\n\t\tst.Update(x[i]-1,dp[i][1]-s[i]);\n\t}\n\tcout << min(dp[N-1][1],dp[N-1][0]) << endl;\n\treturn 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include<bits/stdc++.h>\n#define N (1<<17)\nusing namespace std;\ntypedef long long ll;\nll n,x[N];\n\nclass BIT{\npublic:\n  ll bit[N+1],n;\n  BIT(){memset(bit,0,sizeof(bit));}\n  BIT(int n){this->n=n,memset(bit,0,sizeof(bit));}\n  ll sum(int i){\n    ll s=0;\n    while(i>0){\n      s+=bit[i];\n      i-=i&-i;\n    }\n    return s;\n  }\n\n  void add(int i,int x){\n    while(i<=n){\n      bit[i]+=x;\n      i+=i&-i;\n\n    }\n  }\n\n};\n\nint main(){  \n  cin>>n;\n  BIT B(n);\n  set<ll> S;\n  for(int i=1;i<=n;i++)cin>>x[i],B.add(i,i),S.insert(i);\n  S.insert(n+1);\n  ll ans=0;\n\n  set<ll>::iterator it=S.begin();\n\n  for(int i=1;i<=n;i++){\n    if(!S.count(x[i]))continue;\n    ll cost1=B.sum(x[i])-x[i],cost2=x[i];\n    if(cost1>cost2)ans+=cost2,B.add(x[i],-x[i]),S.erase(x[i]);\n    else {\n      ans+=cost1;\n      set<ll>::iterator it=S.begin();\n      while(*it<=x[i])B.add(*it,-(*it)),S.erase(it++);\n    }\n    \n  }\n  cout <<ans<<endl;\n  \n  return 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include<cstdio>\n#include<cstring>\n#include<vector>\n#include<queue>\n#include<algorithm>\n#include<cmath>\n#include<climits>\n#include<string>\n#include<set>\n#include<map>\n#include<iostream>\nusing namespace std;\n#define rep(i,n) for(int i=0;i<((int)(n));i++)\n#define reg(i,a,b) for(int i=((int)(a));i<=((int)(b));i++)\n#define irep(i,n) for(int i=((int)(n))-1;i>=0;i--)\n#define ireg(i,a,b) for(int i=((int)(b));i>=((int)(a));i--)\ntypedef long long int lli;\ntypedef pair<int,int> mp;\n#define fir first\n#define sec second\n#define IINF INT_MAX\n#define LINF LLONG_MAX\n#define eprintf(...) fprintf(stderr,__VA_ARGS__)\n#define pque(type) priority_queue<type,vector<type>,greater<type> >\n#define memst(a,b) memset(a,b,sizeof(a))\n#define iter(v,ite) for(auto ite=(v).begin();ite!=(v).end();ite++)\n#define mimunum(v,x) distance((v).begin(),lower_bound((v).begin(),(v).end(),x))\n\nint n;\nlli seg[400005]={};\nlli dat[100005];\nint N;\nvoid init(){\n\tN=1;\n\twhile(N<=n)N*=2;\n}\n\nlli get(int l,int r,int a,int b,int k){\n\tif(r<=a || b<=l)return 0;\n\tif(a<=l && r<=b)return seg[k];\n\treturn max(\n\t\tget(l,(l+r)/2,a,b,k*2),\n\t\tget((l+r)/2,r,a,b,k*2+1));\n}\n\nvoid upd(int p,lli t){\n\tp+=N;\n\twhile(p>0){\n\t\tseg[p]=max(seg[p],t); p/=2;\n\t}\n}\n\nint main(void){\n\tscanf(\"%d\",&n);\n\tinit();\n\tlli s=0;\n\trep(i,n){\n\t\tscanf(\"%lld\",&dat[i]);\n\t\ts+=dat[i];\n\t}\n\t\n\trep(i,n){\n\t\tlli g=get(0,N,0,dat[i],1);\n\t\tupd(dat[i],g+dat[i]);\n\t\t//printf(\"%lld %lld %lld\\n\",g,dat[i],get(0,N,0,dat[i],1));\n\t}\n\t\n\tlli ds=0;\n\treg(i,1,n){\n\t\tlli p=get(0,N,0,dat[i]+1,1);\n\t\t//printf(\"%lld\\n\",p);\n\t\tds=max(ds,p);\n\t}\n\t\n\tprintf(\"%lld\\n\",s-ds);\n\t\t\n\treturn 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include <iostream>\n#include <vector>\n#include <algorithm>\nusing namespace std;\n\nconst int MAX_N = 1 << 17;\ntypedef long long LL;\n\n// Segment Tree\n// (数列のサイズ N に対してSegment Treeの頂点は 2*N-1 となる)\nstruct Segment_tree{\n\tint n;\n\tvector<LL> dat;\n\t// コンストラクタで初期化\n\tSegment_tree(int n_){\n\t\t// 簡単のために要素数を2のべき乗にする \n\t\tn = 1;\n\t\twhile( n < n_ ) n *= 2;\n\t\t// すべての頂点の値を 0 にする\n\t\tfor(int i=0 ; i < 2*n-1 ; i++ ){\n\t\t\tdat.push_back( 0 );\n\t\t}\n\t}\n\t// k 番目の値 (0-indexed) を a に更新\n\tvoid update(int k, LL a){\n\t\tk += n-1;\n\t\tdat[k] = a;\n\t\t// 登りながら更新\n\t\twhile( k > 0 ){\n\t\t\tk = (k - 1) / 2;\n\t\t\tdat[k] = max( dat[k*2+1] , dat[k*2+2] );\n\t\t}\n\t}\n\t// [a,b)の最小値を求める\n\tLL query(int a, int b, int k=0, int l=0, int r=0){\n\t\t// 初回呼び出し時\n\t\tif( k == 0 && l == 0 && r == 0 ) r = n;\n\t\t\n\t\t// [a,b) と [l,r) が交差しないとき\n\t\tif( r <= a || b <= l ) return 0;\n\t\t\n\t\t// [a,b) が [l,r) を完全に含んでいるとき\n\t\tif( a <= l && r <= b ){\n\t\t\treturn dat[k];\n\t\t}else{ // それ以外\n\t\t\tLL vl = query( a , b , k*2+1 , l , (l+r)/2 );\n\t\t\tLL vr = query( a , b , k*2+2 , (l+r)/2 , r );\n\t\t\treturn max( vl , vr );\n\t\t}\n\t}\n};\n\nint main(){\n\tLL n;\n\tcin >> n;\n\tvector<LL> x(n);\n\tSegment_tree t(n+1);\n\tfor(int i=0 ; i < n ; i++ ){\n\t\tcin >> x[i];\n\t}\n\t// segment tree について\n\t// t.query(0, b);\n\t// とすると (1..nの総和) - (荷物の重さ b 以下で整列させる最大のコスト)が返ってくる\n\tfor(int i=0 ; i < n ; i++ ){\n\t\t// [0,x[i]) の中で最小値が返ってくる.\n\t\tLL cost = t.query(0, x[i]);\n\t\t// 位置 x[i] を cost - x[i] に更新\n\t\tt.update(x[i], cost+x[i] );\n\t}\n\t// 解 (1..nの総和は n*(n+1)/2 で計算できる)\n\tLL ans = n * (n+1) / 2 - t.query(0, n+1);\n\tcout << ans << endl;\n}"
  },
  {
    "language": "C++",
    "code": "#include <iostream>\n#include <iomanip>\n#include <sstream>\n#include <cstdio>\n#include <cstdlib>\n#include <cstring>\n#include <cmath>\n#include <climits>\n#include <cfloat>\n#include <vector>\n#include <string>\n#include <stack>\n#include <queue>\n#include <set>\n#include <map>\n#include <algorithm>\n#include <functional>\n#include <utility>\n#include <numeric>\n#include <iterator>\n\nusing namespace std;\n\ntypedef long long LL;\ntypedef unsigned long long ULL;\ntypedef vector<int> VI;\ntypedef vector<VI> VVI;\ntypedef vector<string> VS;\ntypedef pair<int,int> PII;\ntypedef vector<PII> VPII;\ntypedef istringstream ISS;\ntypedef ostringstream OSS;\n\n#define REP( i, m, n ) for ( int i = (int)( m ); i < (int)( n ); ++i )\n#define FOR( v, c ) for ( auto &v : c )\n#define EACH( it, c ) for ( auto it = c.begin(); it != c.end(); ++it )\n#define ALL( c ) (c).begin(), (c).end()\n#define DRANGE( c, p ) (c).begin(), (c).begin() + p, (c).end()\n\n#define PB( n ) push_back( n )\n#define MP( a, b ) make_pair( ( a ), ( b ) )\n#define EXIST( c, e ) ( (c).find( e ) != (c).end() )\n\n#define fst first\n#define snd second\n\n#define DUMP( x ) cerr << #x << \" = \" << ( x ) << endl\n#define DEBUG( x ) cerr << __FILE__ << \":\" << __LINE__ << \": \" << #x << \" = \" << ( x ) << endl\n\nconst LL INF = LLONG_MAX / 4;\n\n// セグメント木のユーティリティ\ninline const int chl( const int k )\n{\n\treturn k * 2 + 1;\n}\n\ninline const int chr( const int k )\n{\n\treturn k * 2 + 2;\n}\n\ninline const int mid( const int l, const int r )\n{\n\treturn ( l + r ) / 2;\n}\n\n// セグメント木による Range Maximum Query\ntemplate < typename T >\nclass RangeMaximumQuery\n{\nprivate:\n\tconst int N;\n\tvector<T> data;\n\npublic:\n\tRangeMaximumQuery( const vector<T> &src ) : N( src.size() ), data( N * 4 )\n\t{\n\t\tREP( i, 0, N )\n\t\t{\n\t\t\tupdate( i, src[i] );\n\t\t}\n\n\t\treturn;\n\t}\n\n\tvoid update( const int p, const T x )\n\t{\n\t\treturn update( p, x, 0, 0, N );\n\t}\n\n\tT maximum() const\n\t{\n\t\treturn maximum( 0, N, 0, 0, N );\n\t}\n\n\tT maximum( const int a, const int b ) const\n\t{\n\t\treturn maximum( a, b, 0, 0, N );\n\t}\nprivate:\n\tvoid update( const int p, const int x, const int k, const int l, const int r )\n\t{\n\t\tif ( p < l || r <= p )\n\t\t{\n\t\t\treturn;\n\t\t}\n\t\tif ( l + 1 == r && p == l )\n\t\t{\n\t\t\tdata[k] = x;\n\t\t\treturn;\n\t\t}\n\n\t\tupdate( p, x, chl( k ), l, mid( l, r ) );\n\t\tupdate( p, x, chr( k ), mid( l, r ), r );\n\t\tdata[k] = max( data[ chl( k ) ], data[ chr( k ) ] );\n\t\n\t\treturn;\n\t}\n\n\tT maximum( const int a, const int b, const int k, const int l, const int r ) const\n\t{\n\t\tif ( b <= l || r <= a )\n\t\t{\n\t\t\treturn INT_MIN;\n\t\t}\n\t\telse if ( a <= l && r <= b )\n\t\t{\n\t\t\treturn data[k];\n\t\t}\n\t\telse\n\t\t{\n\t\t\treturn max( maximum( a, b, chl( k ), l, mid( l, r ) ), maximum( a, b, chr( k ), mid( l, r ), r ) );\n\t\t}\n\t}\n};\n// RangeMaximumQuery( VI src )\n// update( pos, x )\n// maximum( [ a = 0, b = N ) )\n\nint main()\n{\n\tcin.tie( 0 );\n\tios::sync_with_stdio( false );\n\n\tLL n;\n\tcin >> n;\n\n\tVI xs( n );\n\tREP( i, 0, n )\n\t{\n\t\tcin >> xs[i];\n\t}\n\n\tRangeMaximumQuery<LL> rmq( vector<LL>( n + 1, -INF ) );\n\trmq.update( 0, 0 );\n\n\tREP( i, 0, n )\n\t{\n\t\trmq.update( xs[i], rmq.maximum( 0, xs[i] ) + xs[i] );\n\t}\n\n\tcout << n * ( n + 1 ) / 2 - rmq.maximum() << endl;\n\n\treturn 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include <iostream>\n#include <cstdio>\n#include <vector>\n#include <queue>\n#include <cmath>\n#include <algorithm>\n#include <functional>\nusing namespace std;\n#define rep(i,n) for(int i=0;i<(n);++i)\n#define rep1(i,n) for(int i=1;i<=(n);++i)\n#define all(c) (c).begin(),(c).end()\n#define pb push_back\n#define fs first\n#define sc second\n#define show(x) cout << #x << \" = \" << x << endl\ntypedef long long ll;\nconst ll p2=1<<17;\nll a[100000],seg[p2*2-1];\nvoid update(int x){\n\twhile(true){\n\t\tx=(x-1)/2;\n\t\tseg[x]=max(seg[x*2+1],seg[x*2+2]);\n\t\tif(x==0) return;\n\t}\n}\nll segmax(int a,int b,int l,int r,int k){\n\tif(b<=l||r<=a) return 0;\n\tif(a<=l&&r<=b) return seg[k];\n\treturn max(segmax(a,b,l,(l+r)/2,k*2+1),segmax(a,b,(l+r)/2,r,k*2+2));\n}\nint main(){\n\tint N;\n\tcin>>N;\n\trep(i,N) cin>>a[i];\n\trep(i,N) a[i]--;\n\trep(i,N){\n\t\tseg[p2-1+a[i]]=segmax(0,a[i],0,p2,0)+a[i]+1;\n\t\tupdate(p2-1+a[i]);\n\t}\n\tll mx=0;\n\trep(i,N) mx=max(mx,seg[p2-1+i]);\n\tcout<<(ll)N*(N+1)/2-mx<<endl;\n}"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\nusing namespace std;\n#define F first\n#define S second\n#define pi M_PI\n#define R cin>>\n#define Z class\n#define ll long long\n#define ln cout<<'\\n'\n#define in(a) insert(a)\n#define pb(a) push_back(a)\n#define pd(a) printf(\"%.10f\\n\",a)\n#define mem(a) memset(a,0,sizeof(a))\n#define all(c) (c).begin(),(c).end()\n#define iter(c) __typeof((c).begin())\n#define rrep(i,n) for(int i=(int)(n)-1;i>=0;i--)\n#define REP(i,m,n) for(int i=(int)(m);i<(int)(n);i++)\n#define rep(i,n) REP(i,0,n)\n#define tr(it,c) for(iter(c) it=(c).begin();it!=(c).end();it++)\ntemplate<Z A>void pr(A a){cout<<a;ln;}\ntemplate<Z A,Z B>void pr(A a,B b){cout<<a<<' ';pr(b);}\ntemplate<Z A,Z B,Z C>void pr(A a,B b,C c){cout<<a<<' ';pr(b,c);}\ntemplate<Z A,Z B,Z C,Z D>void pr(A a,B b,C c,D d){cout<<a<<' ';pr(b,c,d);}\ntemplate<Z A>void PR(A a,ll n){rep(i,n){if(i)cout<<' ';cout<<a[i];}ln;}\nll check(ll n,ll m,ll x,ll y){return x>=0&&x<n&&y>=0&&y<m;}\nconst ll MAX=1000000007,MAXL=1LL<<61,dx[4]={-1,0,1,0},dy[4]={0,1,0,-1};\ntypedef pair<int,int> P;\nclass RMQ{\npublic:\n  ll n,dat[555555];\n  void init(int _n){\n    n=1;\n    while(n<_n)n*=2;\n    fill(dat,dat+2*n-1,-MAXL);\n  }\n  void update(ll k,ll a){\n    k+=n-1;dat[k]=a;\n    while(k>0){\n      k=(k-1)/2;\n      dat[k]=max(dat[k*2+1],dat[k*2+2]);\n    }\n  }\n  ll query(int a,int b){return query(a,b,0,0,n);}\n  ll query(int a,int b,int k,int l,int r){\n    if(r<=a||b<=l) return -MAXL;\n    if(a<=l&&r<=b) return dat[k];\n    ll vl=query(a,b,k*2+1,l,(l+r)/2);\n    ll vr=query(a,b,k*2+2,(l+r)/2,r);\n    return max(vl,vr);\n  }\n};\n\nvoid Main() {\n  ll n;\n  R n;\n  RMQ r;\n  r.init(n+1);\n  r.update(0,0);\n  rep(i,n) {\n    ll x;\n    R x;\n    r.update(x,r.query(0,x)+x);\n  }\n  pr(n*(n+1)/2-r.query(0,n+1));\n}\n\nint main(){ios::sync_with_stdio(0);cin.tie(0);Main();return 0;}\n"
  },
  {
    "language": "C++",
    "code": "#include<iostream>\n#include<algorithm>\n\nusing namespace std;\n\ntypedef long long Int;\n\nInt bit[105000];\n\nvoid setnum(int pos, Int val){\n\twhile(pos < 105000){\n\t\tbit[pos] = max(val, bit[pos]);\n\t\tpos += pos & -pos;\n\t}\n}\n\nInt maxnum(int pos){\n\tInt res = 0;\n\twhile(pos){\n\t\tres = max(res, bit[pos]);\n\t}\n\treturn res;\n}\n\nint main(){\n\tInt n, sum = 0, x;\n\tcin >> n;\t\n\tfor(int i = 0;i < n;i++){\n\t\tcin >> x;\n\t\tsum += x;\n\t\tInt p = p + maxnum(p);\n\t\tsetnum(x, p);\n\t}\n\tcout << sum - maxnum(10100) << endl;\n\treturn 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\nusing namespace std;\n\n#define for_(i,a,b) for(int i=(a);i<(b);++i)\n#define for_rev(i,a,b) for(int i=(a);i>=(b);--i)\n\ntypedef long long lint;\n\ntemplate< typename DATA >\nclass SegmentTree {\nprivate:\n\tint size__;\n\tvector< DATA > data;\n\t\n\tinline int left_t(int k) {\n\t\treturn (k << 1) + 1;\n\t}\n\t\n\tinline int right_t(int k) {\n\t\treturn (k << 1) + 2;\n\t}\n\t\n\tinline int center(int l, int r) {\n\t\treturn (l + r) >> 1;\n\t}\n\t\npublic:\n\tSegmentTree(int n, DATA ini) {\n\t\tfor (size__ = 1; size__ < n; size__ <<= 1);\n\t\tdata.assign(2 * size__ - 1, ini);\n\t}\n\t\n\tDATA calc(DATA d1, DATA d2) {\n\t\treturn max(d1, d2);\n\t}\n\t\n\tvoid update(int k, DATA a) {\n\t\tk += size__ - 1;\n\t\tdata[k] = a;\n\t\t\n\t\twhile (k > 0) {\n\t\t\tk = (k - 1) >> 1;\n\t\t\tdata[k] = calc(data[left_t(k)], data[right_t(k)]);\n\t\t}\n\t}\n\t\n\tDATA query(int a, int b) {\n\t\treturn query(a, b, 0, 0, size__);\n\t}\n\t\n\tDATA query(int a, int b, int k, int l, int r) {\n\t\tif (r <= a || b <= l) return 0;\n\t\tif (a <= l && r <= b) return data[k];\n\t\treturn calc(query(a, b, left_t(k), l, center(l, r)),\n\t\t\t\t\tquery(a, b, right_t(k), center(l, r), r));\n\t}\n\t\n\tint size() {\n\t\treturn size__;\n\t}\n};\n\nint n, x[100010];\n\nsigned main() {\n\tcin >> n;\n\tfor_(i,0,n) cin >> x[i];\n\t\n\tSegmentTree< lint > st(n + 1, 0);\n\tfor_(i,0,n) st.update(x[i], x[i] + st.query(1, x[i]));\n\tcout << n * (n + 1) / 2 - st.query(1, n + 1) << endl;\n}"
  },
  {
    "language": "C++",
    "code": "#include<bits/stdc++.h>\n#define N (1<<17)\nusing namespace std;\ntypedef long long ll;\nll n,x[N];\n\nclass BIT{\npublic:\n  ll bit[N+1],n;\n  BIT(){memset(bit,0,sizeof(bit));}\n  BIT(int n){this->n=n,memset(bit,0,sizeof(bit));}\n  int sum(int i){\n    int s=0;\n    while(i>0){\n      s+=bit[i];\n      i-=i&-i;\n    }\n    return s;\n  }\n\n  void add(int i,int x){\n    while(i<=n){\n      bit[i]+=x;\n      i+=i&-i;\n\n    }\n  }\n\n};\n\nint main(){  \n  cin>>n;\n  BIT B(n);\n  set<ll> S;\n  for(int i=1;i<=n;i++)cin>>x[i],B.add(i,i),S.insert(i);\n  S.insert(n+1);\n  ll ans=0;\n\n  set<ll>::iterator it=S.begin();\n\n  for(int i=1;i<=n;i++){\n    if(!S.count(x[i]))continue;\n    ll cost1=B.sum(x[i])-x[i],cost2=x[i];\n    if(cost1>cost2)ans+=cost2,B.add(x[i],-x[i]),S.erase(x[i]);\n    else {\n      ans+=cost1;\n      set<ll>::iterator it=S.begin();\n      while(*it<=x[i])B.add(*it,-(*it)),S.erase(it++);\n    }\n    \n  }\n  cout <<ans<<endl;\n  \n  return 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include <iostream>\n#include <cstdio>\n#include <cmath>\n#include <vector>\n#include <map>\n#include <stack>\n#include <queue>\n#include <algorithm>\n#include <set>\n\n#define FOR(i,a,b) for(int i=(a);i<(b);i++)\n#define REP(i,j) FOR(i,0,j)\n#define mp std::make_pair\n\nconst int INF = 1 << 24;\nconst int dx[8] = {0, 0, 1, -1, 1, 1, -1, -1}, dy[8] = {1, -1, 0, 0, 1, -1, 1, -1};\n\ntypedef unsigned long long ull;\ntypedef std::pair<int,int> P;\n\nconst int MAX_W = 100001;\nint N, X[100000];\n\nclass SegmentTree{\npublic:\n    SegmentTree(){}\n    SegmentTree(int n){init(n);}\n    void init(int n){\n        size = 1;\n        while(size < n){\n            size *= 2;\n        }\n        REP(i, size*2-1){\n            data[i] = 0;\n        }\n    }\n    void update(int index, int v){\n        index += size - 1;\n        data[index] = v;\n        while(index > 0){\n            index = (index-1) / 2;\n            data[index] = std::max(data[index*2+1], data[index*2+2]);\n        }\n    }\n    int query(int a, int b){\n        return _query(a, b, 0, 0, size);\n    }\nprivate:\n    int _query(int a, int b, int k, int l, int r){\n        if(b <= l || r <= a){return 0;}\n        if(a <= l && r <= b){return data[k];}\n        return std::max(_query(a, b, k*2+1, l, (l+r)/2), _query(a, b, k*2+2, (l+r)/2, r));\n    }\n    int data[MAX_W*4];\n    int size;\n};\n\nSegmentTree st;\n\nint main(){\n    std::cin >> N;\n    st.init(N+1);\n\n    int sum = 0;\n    REP(i, N){\n        std::cin >> X[i];\n        sum += X[i];\n    }\n\n    REP(i, N){\n        //std::cout << st.query(0, X[i]) + X[i] << std::endl;\n        st.update(X[i], st.query(0, X[i]) + X[i]);\n    }\n    \n    std::cout << sum-st.query(0, 100001) << std::endl;\n}"
  },
  {
    "language": "C++",
    "code": "#include<bits/stdc++.h>\n\nusing namespace std;\n\n#define rep(i,n) for(int i=0;i<(int)n;i++)\n#define INF 1000000000\n\nstruct SegmentTree {\nprivate:\n  int n;\n  vector<int> node;\npublic:\n  SegmentTree(vector<int> v){\n    int sz = v.size();\n    n = 1;\n    while(n<sz) n *= 2;\n    node.resize(2*n-1,INF);\n    for(int i=0; i<sz; i++) node[i+n-1] = v[i];\n    for(int i=n-2; i>=0; i--) node[i] = min(node[2*i+1], node[2*i+2]);\n  }\n\n  void update(int x, int val){\n    x += (n-1);\n    node[x] = val;\n    while(x>0){\n      x = (x-1)/2;\n      node[x] = min(node[2*x+1],node[2*x+2]);\n    }\n  }\n\n  int getmin(int a,int b,int k=0,int l=0,int r=-1){\n    if(r<0)r=n;\n    if(r<=a||b<=l) return INF;\n    if(a<=l&&r<=b) return node[k];\n    int vl = getmin(a,b,2*k+1,l,(l+r)/2);\n    int vr = getmin(a,b,2*k+2,(l+r)/2,r);\n    return min(vl,vr);\n  }\n};\n\n\nint main(){\n\n  int n;\n  cin >> n;\n  vector<int> s(n),ind(n);\n  rep(i,n)cin >> s[i];\n  rep(i,n)ind[s[i]-1]=i;\n  SegmentTree st(vector<int>(n,0));\n  rep(i,n){\n    int index = ind[i];\n    st.update(index,min(st.getmin(0,index)-i-1,-i-1));\n  }\n  cout << n*(n+1)/2+st.getmin(0,n) << endl;\n\n  return 0;\n}\n\n"
  },
  {
    "language": "C++",
    "code": "#include<iostream>\n#include<algorithm>\nusing namespace std;\ntypedef long long ll;\nll dp[110000], x[110000], n, s, rmq[280000], v;\nvoid update(int i, long long x) {\n\ti += v; rmq[i] = x;\n\twhile (i > 1) {\n\t\ti /= 2, rmq[i] = max(rmq[i * 2], rmq[i * 2 + 1]);\n\t}\n}\nlong long query(int p, int q, int k, int l, int r) {\n\tif (r <= p || q <= l) return 0;\n\tif (p <= l && r <= q) return rmq[k];\n\tlong long vl = query(p, q, 2 * k, l, (l + r) / 2);\n\tlong long vr = query(p, q, 2 * k + 1, (l + r) / 2, r);\n\treturn max(vl, vr);\n}\nint main() {\n\tcin >> n; for (int i = 0; i < 20; i++) { if ((1 << i) < n) { v = (1 << (i + 1)); } }\n\tfor (int i = 0; i < n; i++) { cin >> x[i]; dp[i] = x[i]; s += x[i]; }update(x[0], dp[0]);\n\tfor (int i = 1; i < n; i++) {\n\t\tdp[i] = query(1, x[i], 1, 0, v) + x[i];\n\t\tupdate(x[i], dp[i]);\n\t}\n\tcout << s - dp[n - 1] << endl;\n\treturn 0;\n}"
  },
  {
    "language": "C++",
    "code": "//動かさない要素の和を最大化する。動かさない要素は増加列。\n//dp([i])[cost] = minVal, a[0]～a[i-1]の中で残す要素の和をcost以上にするときの、最後の要素の最小値\n//を考えると単調性より更新箇所が1つとなり、1回の更新もO(logN)でできるが、costが大きいので配列では持てない。\n//そこで、(minVal, [start_pos, end_pos))をmapで持つ。(強実装…)\n#include <iostream>\n#include <vector>\n#include <algorithm>\n#include <map>\n#define int long long\nusing namespace std;\ntypedef pair<int, int> P;\n\nint n;\nint x[100000];\nmap<int, P> dp;\n\nsigned main() {\n\tint i, j;\n\t\n\tcin >> n;\n\tfor (i = 0; i < n; i++) cin >> x[i];\n\t\n\tdp[0] = P(0, 1);\n\tdp[n + 1] = P(1, 2);\n\tfor (i = 0; i < n; i++) {\n\t\tmap<int, P>::iterator it = dp.upper_bound(x[i]);\n\t\tint l = it->second.first;\n\t\tdp[x[i]] = P(l, l + x[i]);\n\t\t\n\t\tvector<map<int, P>::iterator> erase_its;\n\t\tfor (map<int, P>::iterator it2 = it; it2 != dp.end(); it2++) {\n\t\t\tif ((it2->second).second <= l + x[i]) {\n\t\t\t\terase_its.push_back(it2);\n\t\t\t}\n\t\t\telse if ((it2->second).first < l + x[i]) {\n\t\t\t\tit2->second = P(l + x[i], (it2->second).second);\n\t\t\t}\n\t\t\telse {\n\t\t\t\tbreak;\n\t\t\t}\n\t\t}\n\t\t\n\t\tfor (j = 0; j < erase_its.size(); j++) {\n\t\t\tdp.erase(erase_its[j]);\n\t\t}\n\t\tdp[n + 1].first = max(dp[n + 1].first, l + x[i]);\n\t\tdp[n + 1].second = dp[n + 1].first + 1;\n\t}\n\t\n\tint maxCost = 0;\n\tfor (map<int, P>::iterator it = dp.begin(); it != dp.end(); it++) {\n\t\tif (it->first == n + 1) {\n\t\t\tmaxCost = (it->second.first) - 1;\n\t\t\tbreak;\n\t\t}\n\t}\n\t\n\tint sumX = 0;\n\tfor (i = 0; i < n; i++) sumX += x[i];\n\tcout << sumX - maxCost << endl;\n\treturn 0;\n}\n"
  },
  {
    "language": "C++",
    "code": "/*\nSegment Tree\nセグ木\nセグメントツリー\n*/\n#include<bits/stdc++.h>\n\nusing namespace std;\n\n#define int long long\n#define rep(i,n) for(int i=0;i<(int)n;i++)\n#define INF 1000000000\n\nstruct SegmentTree {\nprivate:\n  int n;\n  vector<long> node;\npublic:\n  SegmentTree(vector<long long> v){\n    int sz = v.size();\n    n = 1;\n    while(n<sz) n *= 2;\n    node.resize(2*n-1,INF);\n    for(int i=0; i<sz; i++) node[i+n-1] = v[i];\n    for(int i=n-2; i>=0; i--) node[i] = min(node[2*i+1], node[2*i+2]);\n  }\n\n  void update(int x, long long val){\n    x += (n-1);\n    node[x] = val;\n    while(x>0){\n      x = (x-1)/2;\n      node[x] = min(node[2*x+1],node[2*x+2]);\n    }\n  }\n\n  long long getmin(int a,int b,int k=0,int l=0,int r=-1){\n    if(r<0)r=n;\n    if(r<=a||b<=l) return INF;\n    if(a<=l&&r<=b) return node[k];\n    long long vl = getmin(a,b,2*k+1,l,(l+r)/2);\n    long long vr = getmin(a,b,2*k+2,(l+r)/2,r);\n    return min(vl,vr);\n  }\n};\n\n\nsigned main(){\n\n  int n;\n  cin >> n;\n  vector<int> s(n),ind(n);\n  rep(i,n)cin >> s[i];\n  rep(i,n)ind[s[i]-1]=i;\n  SegmentTree st(vector<long long>(n,0));\n  rep(i,n){\n    int index = ind[i];\n    st.update(index,min(st.getmin(0,index)-i-1,(long long)(-i-1)));\n  }\n  cout << n*(n+1)/2+st.getmin(0,n) << endl;\n\n  return 0;\n}\n\n"
  },
  {
    "language": "C++",
    "code": "#include <stdio.h>\n#include <algorithm>\n#pragma warning(disable : 4996)\nusing namespace std;\nint n, a[100000]; long long sum, ret, dp[100001];\nint main() {\n\tscanf(\"%d\", &n);\n\tfor (int i = 0; i < n; i++) scanf(\"%d\", &a[i]), sum += a[i];\n\tfor (int i = 1; i <= n; i++) {\n\t\tdp[i] = a[i - 1];\n\t\tfor (int j = 1; j < i; j++) {\n\t\t\tif (a[j - 1] < a[i - 1]) {\n\t\t\t\tdp[i] = max(dp[i], dp[j] + a[i - 1]);\n\t\t\t}\n\t\t}\n\t}\n\tfor (int i = 1; i <= n; i++) ret = max(ret, dp[i]);\n\tprintf(\"%d\\n\", sum - ret);\n\treturn 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include<bits/stdc++.h>\nusing namespace std;\n#define INF 1<<20\ntypedef long long int lld;\ntypedef pair<int,int> P;\n\nstruct SegmentTree\n{\n  vector< lld > big;\n  lld sz;\n  SegmentTree(lld n)\n  {\n    sz = 1;\n    while(sz < n) sz <<= 1;\n    big.assign(2 * sz - 1, 0LL);\n  }\n  lld getSize(){\n    return sz;\n  }\n  lld getNum(lld s){\n    return big[s];\n  }\n  inline void Merge(lld k)\n  {\n    big[k] = max(big[2 * k + 1], big[2 * k + 2]);\n  }\n  inline lld RangeMaximumQuery(lld a, lld b, lld k, lld l, lld r)\n  {\n    if(a >= r || b <= l) return(-INF);\n    if(a <= l && r <= b) return(big[k]);\n    lld L = RangeMaximumQuery(a, b, 2 * k + 1, l, (l + r) >> 1);\n    lld R = RangeMaximumQuery(a, b, 2 * k + 2, (l + r) >> 1, r);\n    return(max(L, R));\n  }\n  void Update(lld k, lld x)\n  {\n    k += sz - 1;\n    big[k] = x;\n    while(k > 0) {\n      k = (k - 1) >> 1;\n      Merge(k);\n    }\n  }\n  lld RangeMaximumQuery(lld a, lld b)\n  {\n    return(RangeMaximumQuery(a, b, 0, 0, sz));\n  }\n};\n\nint main(){\n  lld n;\n  cin >> n;\n  lld ans = 0LL;\n  SegmentTree BIT(n);\n  for(int i=0;i<n;i++){\n    lld a;\n    cin >> a;\n    BIT.Update(a,BIT.RangeMaximumQuery(1,a+1)+a);\n    ans = max(ans,BIT.getNum(BIT.getSize()-1+a));\n  }\n  cout << ((n+1)*n/2)-ans << endl;\n}"
  },
  {
    "language": "C++",
    "code": "#include<bits/stdc++.h>\nusing namespace std;\nusing ll=long long;\n\nclass SegmentTree{\n    int N;\n    vector<ll> dat;\n    \n    ll query_impl(int a,int b,int k,int l,int r){\n        if(a<=l && r<=b) return dat[k];\n        if(r<=a || b<=l) return 0;\n        int mid=(l+r)/2;\n        ll c1v=query_impl(a,b,k*2+1,l,mid);\n        ll c2v=query_impl(a,b,k*2+2,mid,r);\n        return max(c1v,c2v);\n    }\n    public:\n    SegmentTree(int n){\n        N=1;\n        while(N<n) N*=2;\n        dat.assign(2*N-1,0);\n    }\n\n    void update(int pos,ll val){\n        pos+=N-1;\n        dat[pos]=val;\n        while(pos>0){\n            int par=(pos-1)/2;\n            int c1=par*2+1;\n            int c2=par*2+2;\n            dat[par]=max(dat[c1],dat[c2]);\n            pos=par;\n        }\n    }\n\n    ll query(int a,int b){\n        return query_impl(a,b,0,0,N);\n    }\n\n};\nint main(){\n    ll n;\n    cin>>n;\n    vector<int> revx(n);\n    for(int i=0;i<n;i++){\n        int x;\n        cin>>x;\n        revx[x-1]=i;\n    }\n    SegmentTree seg(n);\n    for(int i=0;i<n;i++){\n        ll sc=seg.query(0,revx[i])+i+1;\n        seg.update(revx[i],sc);\n    }\n    cout<<n*(n+1)/2-seg.query(0,n)<<endl;\n    return 0;\n}\n"
  },
  {
    "language": "C++",
    "code": "#include <cstdlib>\n#include <iostream>\n#include <vector>\nusing namespace std;\n\ntemplate<class T> inline void chmax(T& a, const T& b) { if(b > a) a = b; }\n\ntypedef long long value; // 格納するデータの型\nconst value INIT = 0ll; // 初期値．目的に応じて，適切な値に変更すること．\n\nclass segment_tree {\nprivate:\n\tint n;\n\tvector<value> dat;\n\n\tvalue func(value a, value b) const { // ノードの値を決める為の関数関数\n\t\treturn max(a, b); // RMQの場合．\n\t}\n\n\tvalue query(int a, int b, int k, int l, int r) const {\n\t\tif(r <= a || b <= l) // 求める区間が，ノードの区間と重なっていない．\n\t\t\treturn 0;\n\n\t\tif(a <= l && r <= b) { // 求める区間が，ノードの区間を完全に含む．\n\t\t\treturn dat[k];\n\t\t}\n\t\telse {\n\t\t\tconst value vl = query(a, b, k * 2 + 1, l, (l + r) / 2);\n\t\t\tconst value vr = query(a, b, k * 2 + 2, (l + r) / 2, r);\n\t\t\treturn func(vl, vr);\n\t\t}\n\t}\n\npublic:\n\tsegment_tree(int n_) {\n\t\tn = 1;\n\t\twhile(n < n_)\n\t\t\tn *= 2;\n\n\t\tdat.resize(2 * n - 1, INIT);\n\t}\n\n\tvoid update(int k, value a) { // k番目の要素をaに更新する．\n\t\tk += n - 1;\n\t\tdat[k] = a;\n\t\twhile(k > 0) {\n\t\t\tk = (k - 1) / 2;\n\t\t\tdat[k] = func(dat[k * 2 + 1], dat[k * 2 + 2]);\n\t\t}\n\t}\n\n\tvalue query(int a, int b) { // [a, b)に対するクエリ\n\t\treturn query(a, b, 0, 0, n);\n\t}\n};\n\nint main() {\n\tcin.tie(0);\n\tios::sync_with_stdio(false);\n\n\tint m;\n\tcin >> m;\n\n\tsegment_tree segt(m);\n\n\tlong long mx = 0;\n\tfor(int i = 0; i < m; ++i) {\n\t\tint w;\n\t\tcin >> w;\n\n\t\tlong long tmp = segt.query(1, w) + w;\n\t\tsegt.update(w, tmp);\n\t\tchmax(mx, tmp);\n\t}\n\n\tcout << ((m + 1ll) * m / 2ll - mx) << endl;\n\treturn EXIT_SUCCESS;\n}"
  },
  {
    "language": "C++",
    "code": "#include<iostream>\n#include<cstdio>\n#include<cstdlib>\n#include<cmath>\n#include<algorithm>\n#include<cstring>\n#include<sstream>\n#include<vector>\n#include<queue>\n#include<stack>\n#include<string>\n#include<climits>\n#include<map>\n#include<set>\n#include<cassert>\n#include<deque>\n#define REP(i,s,n) for(int i=s;i<n;i++)\n#define rep(i,n) REP(i,0,n)\n#define INF 1<<27\n#define all(n) n.begin(),n.end()\n#define insert(a,b,c,d) PP(P(a,b),P(c,d))\n#define F first\n#define S second\n#define pb push_back\n#define MAX_N 100100\n#define foreach(i,c) for(iter(c) i=(c).begin();i!=(c).end();++i)\nusing namespace std;\ntypedef pair<int,int> P;\ntypedef pair<P,P> PP;\ntypedef long long ll;\n\n\n\n\n\ntemplate<class T>\nclass RMQ_segment{\nprivate:\n  int n;\n  T dat[2*MAX_N-1];\npublic:\n  void init(int n_){\n    n = 1;\n    while(n<n_)n*=2;\n    for(int i=0;i<2*n-1;i++)dat[i] = 0;\n  }\n\n  void update(int k,T a){\n    k += n-1;\n    dat[k] = a;\n    while(k > 0){\n      k = (k-1)/2;\n      dat[k] = max(dat[k*2+1],dat[k*2+2]);\n    }\n  }\n\n  T query(int a,int b,int k,int l,int r){\n    if(r<=a || b<=l)return 0;\n    else if(a<=l && r<=b)return dat[k];\n    \n      T vl = query(a,b,k*2+1,l,(l+r)/2);\n      T vr = query(a,b,k*2+2,(l+r)/2,r);\n      return max(vl,vr);\n    \n  }\n\n  T _query(int a,int b){//nの範囲でミスしないように極力こっちを利用\n    return query(a,b,0,0,n);\n  }\n\n};\n\n\n int x[1000010];\n RMQ_segment<ll> rmq;\nint main(){\n  int n;\n  cin >> n;\n \n  rmq.init(n+1);\n \n  rep(i,n)cin >> x[i];\n  ll mex=0;\n  ll sum=0;\n\n  for(int i=0;i<n;i++){\n    sum+=x[i];\n    ll premex = rmq._query(0,x[i])+x[i];\n    rmq.update(x[i],premex);\n    mex = max(mex,premex);\n   \n  }  \n  \n  cout << sum-mex << endl;\n\nreturn 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include <algorithm>\n#include <cassert>\n#include <cctype>\n#include <cmath>\n#include <cstdio>\n#include <cstdlib>\n#include <ctime>\n#include <deque>\n#include <functional>\n#include <iomanip>\n#include <iostream>\n#include <list>\n#include <map>\n#include <queue>\n#include <random>\n#include <set>\n#include <sstream>\n#include <string>\n#include <utility>\n#include <vector>\n\n#define REP(i,s,n) for(int i=(int)(s);i<(int)(n);i++)\n#define DEBUGP(val) cerr << #val << \"=\" << val << \"\\n\"\n\nusing namespace std;\ntypedef long long int ll;\ntypedef vector<int> VI;\ntypedef vector<ll> VL;\ntypedef pair<int, int> PI;\n\n/**\n * I should implement static I op(I, I).\n */\ntemplate<class I>\nclass SegTree {\n  int n;\n  std::vector<I> dat;\n  I e;\npublic:\n  SegTree(int n_, I e) : e(e) {\n    n = 1;\n    while (n < n_) { n *= 2; } // n is a power of 2\n    dat.resize(2 * n);\n    for (int i = 0; i < 2 * n - 1; i++) {\n      dat[i] = e;\n    }\n  }\n  /* ary[k] <- v */\n  void update(int k, I v) {\n    k += n - 1;\n    dat[k] = v;\n    while (k > 0) {\n      k = (k - 1) / 2;\n      dat[k] = I::op(dat[2 * k + 1], dat[2 * k + 2]);\n    }\n  }\n  /* http://proc-cpuinfo.fixstars.com/2017/07/optimize-segment-tree/ */\n  I query(int a, int b) const {\n    I left = e;\n    I right = e;\n    a += n - 1;\n    b += n - 1;\n    while (a < b) {\n      if ((a & 1) == 0) {\n\tleft = I::op(left, dat[a]);\n      }\n      if ((b & 1) == 0) {\n\tright = I::op(dat[b - 1], right);\n      }\n      a = a / 2;\n      b = (b - 1) / 2;\n    }\n    return I::op(left, right);\n  }\n};\n\nstruct max_ll {\n  ll v;\n  max_ll(): v(0) {}\n  max_ll(ll v): v(v) {}\n  operator ll() const { return v; }\n  static max_ll op(max_ll x, max_ll y) {\n    return std::max(x, y);\n  }\n};\n\nint main(void) {\n  ios::sync_with_stdio(false);\n  cin.tie(0);\n  int n;\n  scanf(\"%d\", &n);\n  std::vector<int> x(n);\n  for (int i = 0; i < n; ++i)\n    scanf(\"%d\", &x[i]);\n  auto seg =\n    SegTree<max_ll>(n + 1, std::numeric_limits<ll>::min());\n  ll ma = 0;\n  for (int i = 0; i < n; ++i) {\n    ll res = std::max((ll)seg.query(1, x[i]), 0LL);\n    ll cur = res + x[i];\n    ma = std::max(ma, cur);\n    seg.update(x[i], cur);\n  }\n  ll whole = (ll)n * (ll)(n + 1) / 2;\n  printf(\"%lld\\n\", whole - ma);\n}\n\n"
  },
  {
    "language": "C++",
    "code": "#include<bits/stdc++.h>\n#define N (1<<17)\nusing namespace std;\ntypedef long long ll;\n\nclass RMQ{\npublic:\n  ll n,dat[2*N-1];\n\n  //?????????\n  RMQ(){n=N;memset(dat,0,sizeof(dat));}\n  \n  //k???????????????a????????´\n  void update(int k,ll a){\n    k+=n-1;\n    dat[k]=a;\n    while(k>0){\n      k=(k-1)/2;\n      dat[k]=min(dat[k*2+1],dat[k*2+2]);\n    }\n  }\n\n  //[a,b)???????°????????±???????\n  //query(a,b,0,0,n)\n  ll query(int a,int b,int k=0,int l=0,int r=N){\n    if(r==-1) r=n;\n    if(r<=a||b<=l)return 0;\n    if(a<=l&&r<=b)return dat[k];\n    else{\n      ll v1=query(a,b,k*2+1,l,(l+r)/2);\n      ll vr=query(a,b,k*2+2,(l+r)/2,r);\n      return min(v1,vr);\n    }\n  }\n};\n\n\nll x[N];\nint main(){  \n  ll n;\n  cin>>n;\n  RMQ rmq;\n  for(int i=1;i<=n;i++) cin>>x[i];\n\n  ll sum=n*(1+n)/2,cost=0;  \n  for(int i=1;i<=n;i++){\n    ll mx=-rmq.query(1,x[i])+x[i];\n    cost=max(cost,mx);\n    rmq.update(x[i],-mx);\n  }\n  cout << sum-cost<<endl;\n  return 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include<bits/stdc++.h>\nusing namespace std;\nusing ll=long long;\nusing ld=long double;\nusing P=pair<ll,ll>;\n#define MOD 1000000007ll\n#define INF 1000000000ll\n#define EPS 1e-7\n#define FOR(i,n,m) for(ll i=n;i<(ll)m;i++)\n#define REP(i,n) FOR(i,0,n)\n#define DUMP(a) REP(d,a.size()){cout<<a[d];if(d!=a.size()-1)cout<<\" \";else cout<<endl;}\n#define ALL(v) v.begin(),v.end()\n#define UNIQUE(v) sort(v.begin(),v.end());v.erase(unique(v.begin(),v.end()),v.end());\n#define pb push_back\n\nclass segtree {\n#define SEG_MAX ((1ll<<60)-1)\npublic:\n\tsegtree(int n) {\n\t\t_n=1;\n\t\twhile(_n<n) _n*=2;\n\t\t_dat.resize(2*_n-1);\n\t\tfor(int i=0;i<2*_n-1;++i) _dat[i]=-(SEG_MAX);\n\t}\n\tint size() {\n\t\treturn _n;\n\t}\n\tvoid update(int k,long long a) {\n\t\tk+=_n-1;\n\t\t_dat[k]=a;\n\t\twhile(k>0) {\n\t\t\tk=(k-1)/2;\n\t\t\t_dat[k]=max(_dat[k*2+1],_dat[k*2+2]);\n\t\t}\n\t}\n\t// return the minimum number in [a,b)\n\t// external call should be written like query(a,b,0,0,_n)\n\tll query(int a,int b,int k=0,int l=0,int r=-1) {\n\t\tif(r==-1) r=_n;\n\t\tif(r<=a||b<=l) return -(SEG_MAX);\n\t\tif(a<=l&&r<=b) return _dat[k];\n\t\telse {\n\t\t\tll vl=query(a,b,k*2+1,l,(l+r)/2);\n\t\t\tll vr=query(a,b,k*2+2,(l+r)/2,r);\n\t\t\treturn max(vl,vr);\n\t\t}\n\t}\nprivate:\n\tint _n;\n\tvector<ll> _dat;\n};\n\nint main(){\n\tcin.tie(0);\n\tios::sync_with_stdio(false);\n\tll n;\n\tcin>>n;\n\tll sum=n*(n+1)/2;\n\tvector<ll> x(n);\n\tsegtree seg(n);\n\tREP(i,n) {\n\t\tcin>>x[i];\n\t\tx[i]--;\n\t}\n\tREP(i,n) {\n\t\tif(seg.query(0,x[i])==-(SEG_MAX)) seg.update(x[i],x[i]+1);\n\t\telse seg.update(x[i],seg.query(0,x[i])+x[i]+1);\n\t}\n\tcout<<sum-seg.query(0,n)<<endl;\n}\n\n"
  },
  {
    "language": "C++",
    "code": "#include<iostream>\n#include<cstdio>\n#include<cstdlib>\n#include<cmath>\n#include<algorithm>\n#include<cstring>\n#include<sstream>\n#include<vector>\n#include<queue>\n#include<stack>\n#include<string>\n#include<climits>\n#include<map>\n#include<set>\n#include<cassert>\n#include<deque>\n#define REP(i,s,n) for(int i=s;i<n;i++)\n#define rep(i,n) REP(i,0,n)\n#define INF 1<<27\n#define all(n) n.begin(),n.end()\n#define insert(a,b,c,d) PP(P(a,b),P(c,d))\n#define F first\n#define S second\n#define pb push_back\n#define MAX_N (int)1e5+10\n#define foreach(i,c) for(iter(c) i=(c).begin();i!=(c).end();++i)\nusing namespace std;\ntypedef pair<int,int> P;\ntypedef pair<P,P> PP;\ntypedef long long ll;\n\n\n\n\n\ntemplate<class T>\nclass RMQ_segment{\nprivate:\n  int n;\n  T dat[2*MAX_N-1];\npublic:\n  void init(int n_){\n    n = 1;\n    while(n<n_)n*=2;\n    for(int i=0;i<2*n-1;i++)dat[i] = 0;\n  }\n\n  void update(int k,T a){\n    k += n-1;\n    dat[k] = a;\n    while(k > 0){\n      k = (k-1)/2;\n      dat[k] = max(dat[k*2+1],dat[k*2+2]);\n    }\n  }\n\n  T query(int a,int b,int k,int l,int r){\n    if(r<=a || b<=l)return 0;\n    else if(a<=l && r<=b)return dat[k];\n    \n      T vl = query(a,b,k*2+1,l,(l+r)/2);\n      T vr = query(a,b,k*2+2,(l+r)/2,r);\n      return max(vl,vr);\n    \n  }\n\n  T _query(int a,int b){//nの範囲でミスしないように極力こっちを利用\n    return query(a,b,0,0,n);\n  }\n\n};\n\n\n\n\nint main(){\n  int n;\n  cin >> n;\n  RMQ_segment<ll> rmq;\n  rmq.init(n+1);\n  ll x[n];\n  rep(i,n)cin >> x[i];\n  ll mex=0;\n  ll sum=0;\n\n  for(ll i=0;i<n;i++){\n    sum+=x[i];\n    ll premex = rmq._query(0,x[i])+x[i];\n    rmq.update(x[i],premex);\n    mex = max(mex,premex);\n   \n  }  \n  \n  cout << sum-mex << endl;\n\nreturn 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include <stdio.h>\n#include <algorithm>\n#pragma warning(disable : 4996)\nusing namespace std;\nint n, a[100000], b[100000]; long long sum, ret, dp[100001];\nint main() {\n\tscanf(\"%d\", &n);\n\tfor (int i = 0; i < n; i++) scanf(\"%d\", &a[i]), sum += a[i], b[a[i] - 1] = i;\n\tfor (int i = 1; i <= n; i++) {\n\t\tdp[i] = a[i - 1];\n\t\tfor (int j = 0; j < a[i - 1]; j++) {\n\t\t\tif (b[j] < i - 1) {\n\t\t\t\tdp[i] = max(dp[i], dp[b[j] + 1] + a[i - 1]);\n\t\t\t}\n\t\t}\n\t}\n\tfor (int i = 1; i <= n; i++) ret = max(ret, dp[i]);\n\tprintf(\"%lld\\n\", sum - ret);\n\treturn 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include<bits/stdc++.h>\nusing namespace std;\ntypedef long long int lli;\n\nclass RMQ{\n  lli n;\n  vector<lli>dat;\npublic:\n  RMQ(lli n_){\n    n = 1;\n    while(n < n_) n *= 2;\n    dat.resize(2*n - 1);\n    for(lli i = 0; i < 2*n - 1; i++) dat[i] = 0;\n  }\n  void update(lli k,lli a){\n    k += n - 1;\n    dat[k] = max(a, dat[k]);\n    while(k > 0){\n      k = (k - 1)/2;\n      dat[k] = max(dat[k*2 + 1], dat[k*2 + 2]);\n    }\n  }\n  void print(){\n    for (int i = n - 1; i < 2*n - 1; i++) {\n      std::cout << dat[i] << \" \";\n    }\n    std::cout << std::endl;\n  }\n  lli query(lli a,lli b,lli k = 0,lli l = 0,lli r = 0){\n    if(r <= l) r = n;\n    if(r <= a || b <= l) return 0;\n    if(a <= l && r <= b) return dat[k];\n    lli vl = query(a, b, k*2 + 1, l, (r + l)/2);\n    lli vr = query(a, b, k*2 + 2, (r + l)/2, r);\n    return max(vl, vr);\n  }\n};\n\n\nint main(int argc, char *argv[]){\n  lli n;\n  cin >> n;\n  vector<lli> x(n);\n  RMQ r(n);\n  for (lli i = 0; i < n; i++) {\n    cin >> x[i];\n  }\n  vector<lli> dp(n);\n  for (int i = 0; i < n; i++) {\n    r.update(x[i] - 1, x[i] + r.query(0, x[i] - 1));\n  }\n   std::cout << (n*(n + 1))/2 - r.query(0, n) << std::endl;\n  return 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include<cstdio>\n#include<algorithm>\n\n#define rep(i,n) for(int i=0;i<(n);i++)\n\nusing namespace std;\n\ntypedef long long ll;\n\ntemplate<class T>\nclass segment_tree_RMQ{\n\tstatic const int N_MAX=10001;\n\tint n;\n\tT dat[2*N_MAX];\n\n\tT query(int l,int r,int a,int b,int u){\n\t\tif(l<=a && b<=r) return dat[u];\n\n\t\tT res=0;\n\t\tint c=(a+b+1)/2;\n\t\tif(l<c && a<r) res=max(res,query(l,r,a,c,2*u));\n\t\tif(l<b && c<r) res=max(res,query(l,r,c,b,2*u+1));\n\t\treturn res;\n\t}\n\npublic:\n\tvoid build(int N,T val){\n\t\tfor(n=1;n<N;n*=2);\n\t\trep(u,2*n) dat[u]=val;\n\t}\n\n\tvoid update(int u,T v){\n\t\tu+=n;\n\t\tdat[u]=v;\n\t\tfor(u/=2;u>=1;u/=2) dat[u]=max(dat[2*u],dat[2*u+1]);\n\t}\n\n\tT query(int l,int r){ return query(l,r,0,n,1); }\n};\n\nint main(){\n\tint n; scanf(\"%d\",&n);\n\tint x[100000];\n\trep(i,n) scanf(\"%d\",x+i);\n\n\tstatic segment_tree_RMQ<ll> S;\n\tS.build(n+1,0);\n\trep(i,n){\n\t\tll cost=S.query(0,x[i]);\n\t\tS.update(x[i],cost+x[i]);\n\t}\n\n\tprintf(\"%lld\\n\",(ll)n*(n+1)/2-S.query(0,n+1));\n\n\treturn 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include<bits/stdc++.h>\nusing namespace std;\nusing ll=long long;\n\nclass SegmentTree{\n    int N;\n    vector<ll> dat;\n    \n    ll query_impl(int a,int b,int k,int l,int r){\n        if(a<=l && r<=b) return dat[k];\n        if(r<=a || b<=l) return 0;\n        int mid=(l+r)/2;\n        ll c1v=query_impl(a,b,k*2+1,l,mid);\n        ll c2v=query_impl(a,b,k*2+2,mid,r);\n        return max(c1v,c2v);\n    }\n    public:\n    SegmentTree(int n){\n        N=1;\n        while(N<n) N*=2;\n        dat.assign(2*N-1,0);\n    }\n\n    void update(int pos,ll val){\n        pos+=N-1;\n        dat[pos]=val;\n        while(pos>0){\n            int par=(pos-1)/2;\n            int c1=par*2+1;\n            int c2=par*2+2;\n            dat[par]=max(dat[c1],dat[c2]);\n            pos=par;\n        }\n    }\n\n    ll query(int a,int b){\n        return query_impl(a,b,0,0,N);\n    }\n\n};\nint main(){\n    ll n;\n    cin>>n;\n    vector<int> revx(n);\n    for(int i=0;i<n;i++){\n        int x;\n        cin>>x;\n        revx[x-1]=i;\n    }\n    SegmentTree seg(n);\n    for(int i=0;i<n;i++){\n        ll sc=seg.query(0,revx[i])+i+1;\n        seg.update(revx[i],sc);\n    }\n    cout<<n*(n+1)/2-seg.query(0,n);\n    return 0;\n}\n"
  },
  {
    "language": "C++",
    "code": "#include<bits/stdc++.h>\nusing namespace std;\n#define int long long\n#define pb push_back \n#define mp make_pair\n#define fr first\n#define sc second\n#define Rep(i,n) for(int i=0;i<(n);i++)\n#define All(v) v.begin(),v.end()\ntypedef pair<int, int> Pii; typedef pair<int, Pii> Pip;\nconst int INF = (1<<30);\n\nstruct SegT\n{\n  vector<int> tree;\n  int n;\n \n  SegT(int n_)\n  {\n    n = 1;\n    while( n < n_ ) n <<= 1;\n    tree = vector<int>(2 * n - 1, 0);\n  }\n  int rmq(int a, int b, int k, int l, int r)\n  {\n    if( a >= r || b <= l ) return 0;\n    if( a <= l && r <= b ) return tree[k];\n    return(max(rmq(a, b, 2 * k + 1, l, (l + r) >> 1),\n               rmq(a, b, 2 * k + 2, (l + r) >> 1, r)));\n  }\n  int rmq(int a, int b)\n  {\n    return (rmq(a, b+1, 0, 0, n));\n  }\n  int update(int k, int x)\n  {\n    k += n - 1;\n    tree[k] = x;\n    while( k > 0 ) {\n      k = (k - 1) >> 1;\n      tree[k] = max(tree[2 * k + 1], tree[2 * k + 2]);\n    }\n  }\n};\n\nmain() {\n  int n;\n  cin >> n;\n  SegT tree( n+1 );\n\n  Rep(i, n) {\n    int x;\n    cin >> x;\n    tree.update(x, tree.rmq(1, x-1) + x);\n  }\n\n  cout << n * (n+1) / 2 - tree.rmq(1, n) << endl;\n}"
  },
  {
    "language": "C++",
    "code": "#include <iostream>\n#include <algorithm>\n#include <vector>\n#include <cstdio>\n#include <climits>\nusing namespace std;\n\nlong long bit[100010] = {};\n\nvoid add(int x,int v){\n\tfor(int i = x ; i < 100010 ; i += i & -i ){\n\t\tbit[i] = max(bit[i],v);\n\t}\n}\n\nlong long get(int x){\n\tlong long ans = 0;\n\tfor(int i = x ; i > 0 ; i -= i & -i ){\n\t\tans = max(bit[i],ans);\n\t}\n\treturn ans;\n}\n\nint main(){\n\tint n;\n\tcin >> n;\n\tlong long ans = 0;\n\tfor(int i = 0 ; i < n ; i++){\n\t\tint a;\n\t\tcin >> a;\n\t\tadd(a,get(a)+a);\n\t}\n\tcout << 1ll*n*(n+1) / 2 - get(100001) << endl;\n}"
  },
  {
    "language": "C++",
    "code": "// AOJ 2431\n#include<cstdio>\n#include<algorithm>\n#define rep(i,a) for( int i = 0; i != (a); ++i )\n\ntypedef long long ll;\n\nint n;\nll bit[100001];\n\nvoid add( int k, ll x )\n{\n\tfor( int i = k+1; i <= n; i += i&-i )\n\t\tbit[i] = std::max( bit[i], x );\n\n\treturn;\n}\n\nll sum( int k )\n{\n\tll ret = 0;\n\n\tfor( int i = k; i > 0; i -= i&-i )\n\t\tret = std::max( ret, bit[i] );\n\n\treturn ret;\n}\n\nint main()\n{\n\tscanf( \"%d\", &n );\n\trep( i, n )\n\t{\n\t\tint x;\n\t\tscanf( \"%d\", &x );\n\t\tadd( x-1, sum( x-1 )+x );\n\t}\n\n\tprintf( \"%lld\\n\", (ll(n)*(n+1)>>1)-sum(n) );\n\n\treturn 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\nusing namespace std;\ntemplate<typename T1,typename T2> inline void chmin(T1 &a,T2 b){if(a>b) a=b;}\ntemplate<typename T1,typename T2> inline void chmax(T1 &a,T2 b){if(a<b) a=b;}\nusing ll = long long;\nconst char newl = '\\n';\n#define var auto\n\ntemplate <typename T>\nstruct SegmentTree {\n  using F = function<T(T, T)>;\n  int n;\n  F f;\n  T ti;\n\n  vector<T> dat;\n  SegmentTree() {}\n  SegmentTree(F f, T ti) : f(f), ti(ti) {}\n\n  void init(int n_) {\n    n = 1;\n    while (n < n_) n <<= 1;\n    dat.assign(n << 1, ti);\n  }\n\n  void build(const vector<T> &v) {\n    int n_ = v.size();\n    init(n_);\n    for (int i = 0; i < n_; i++) dat[n + i] = v[i];\n    for (int i = n - 1; i; i--)\n      dat[i] = f(dat[(i << 1) | 0], dat[(i << 1) | 1]);\n  }\n\n  void set_val(int k, T x) {\n    dat[k += n] = x;\n    while (k >>= 1)\n      dat[k] = f(dat[(k << 1) | 0], dat[(k << 1) | 1]);\n  }\n\n  T query(int a, int b) {\n    T vl = ti, vr = ti;\n    for (int l = a + n, r = b + n; l < r; l >>= 1, r >>= 1) {\n      if (l & 1) vl = f(vl, dat[l++]);\n      if (r & 1) vr = f(dat[--r], vr);\n    }\n\n    return f(vl, vr);\n  }\n\n  template<typename C>\n  int find(int st, C &check, T &acc, int k, int l, int r) {\n    if (l + 1 == r) {\n      acc = f(acc, dat[k]);\n      return check(acc) ? k - n : -1;\n    }\n\n    int m = (l + r) >> 1;\n    if (m <= st) return find(st, check, acc, (k << 1) | 1, m, r);\n    if (st <= l && !check(f(acc, dat[k]))) {\n      acc = f(acc, dat[k]);\n      return -1;\n    }\n    int vl = find(st, check, acc, (k << 1) | 0, l, m);\n    if (~vl) return vl;\n    return find(st, check, acc, (k << 1) | 1, m, r);\n  }\n\n  template<typename C>\n  int find(int st, C &check) {\n    T acc = ti;\n    return find(st, check, acc, 1, 0, n);\n  }\n};\n\nsigned main(){\n  int n;\n  cin >> n;\n\n  vector< int > xs(n);\n  for (auto &i: xs) cin >> i;\n\n  ll ans = accumulate(xs.begin(), xs.end(), 0ll);\n\n  SegmentTree< ll > seg([&](ll a, ll b) { return max(a, b); }, 0);\n  seg.init(n + 1);\n\n  for (int i = 0; i < n; ++i) {\n    int x = xs[i];\n    seg.set_val(x, seg.query(0, x) + x);\n  }\n\n  ans -= seg.query(0, n + 1);\n  cout << ans << endl;\n}\n\n"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\nusing namespace std;\n\n#define FOR(i, a, b) for (int i = (a); i < int(b); ++i)\n#define REP(i, n) FOR(i, 0, n)\n\ntemplate <typename Int>\nstruct FenwickTree {\n  vector<Int> data;\n  explicit FenwickTree(int n): data(n, 0) {}\n  void add(int i, Int x) { for (; i < (int)data.size(); i |= i+1) data[i] = max(data[i], x); }\n  Int sum(int i) const { Int s = 0; for (; i >= 0; i = (i & (i+1)) - 1) s = max(s, data[i]); return s; }\n};\n\nlong long dp[100001];\n\nint main() {\n    cin.tie(0); ios_base::sync_with_stdio(false);\n\n    int n;\n    while (cin >> n) {\n        vector<int> weights(n);\n        REP(i, n) cin >> weights[i];\n\n        REP(w, n+1) dp[w] = 0;\n        dp[weights[0]] = weights[0];\n\n        FenwickTree<long long> ft(n+1);\n        ft.add(weights[0], weights[0]);\n\n        FOR(i, 1, n) {\n            int w = weights[i];\n            long long v = max(dp[w], ft.sum(w-1) + w);\n            dp[w] = v;\n            ft.add(w, v);\n        }\n\n        long long total_weight = 0;\n        REP(i, n) total_weight += weights[i];\n\n        cout << total_weight - ft.sum(n) << '\\n';\n    }\n}"
  },
  {
    "language": "C++",
    "code": "#include<bits/stdc++.h>\nusing namespace std;\n#define int long long\nconst int MAX_N = 1 << 17;\nint bit[MAX_N+1],n;\nint sum(int i){\n  int s=0;\n  while(i>0){\n    s+=bit[i];\n    i-=i&-i;\n  }\n  return s<0?0:s;\n}\nvoid add(int i,int x){\n  while(i<=n){\n    bit[i]+=x;\n    i+=i&-i;\n  }\n}\nsigned main(){\n  memset(bit,0,sizeof(bit));\n  cin>>n;\n  int x[n],ans=0,p=-1;\n  for(int i=0;i<n;i++) cin>>x[i];\n  for(int i=n-1;i>=0;i--){\n    //cout<<x[i]<<\":\"<<sum(x[i])<<\"/\"<<ans<<endl;\n    if(x[i]<sum(x[i])){\n      ans+=x[i];\n    }else{\n      ans+=sum(x[i]);\n      add(1,-sum(x[i]));\n    }\n    add(x[i],x[i]);\n  }\n  cout<<ans<<endl;\n  return 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\nusing namespace std;\n\nusing VI = vector<int>;\nusing VVI = vector<VI>;\nusing PII = pair<int, int>;\nusing LL = long long;\nusing VL = vector<LL>;\nusing VVL = vector<VL>;\nusing PLL = pair<LL, LL>;\nusing VS = vector<string>;\n\n#define ALL(a)  begin((a)),end((a))\n#define RALL(a) (a).rbegin(), (a).rend()\n#define PB push_back\n#define EB emplace_back\n#define MP make_pair\n#define SZ(a) int((a).size())\n#define SORT(c) sort(ALL((c)))\n#define RSORT(c) sort(RALL((c)))\n#define UNIQ(c) (c).erase(unique(ALL((c))), end((c)))\n\n#define FOR(i,a,b) for(int i=(a);i<(b);++i)\n#define REP(i,n)  FOR(i,0,n)\n\n#define FF first\n#define SS second\ntemplate<class S, class T>\nistream& operator>>(istream& is, pair<S,T>& p){\n  return is >> p.FF >> p.SS;\n}\ntemplate<class S, class T>\nostream& operator<<(ostream& os, const pair<S,T>& p){\n  return os << p.FF << \" \" << p.SS;\n}\ntemplate<class T>\nvoid maxi(T& x, T y){\n  if(x < y) x = y;\n}\ntemplate<class T>\nvoid mini(T& x, T y){\n  if(x > y) x = y;\n}\n\n\nconst double EPS = 1e-10;\nconst double PI  = acos(-1.0);\nconst LL MOD = 1e9+7;\n\nclass BIT{\nprivate:\n  int n;\n  vector<LL> bit;\npublic:\n  BIT(int n_){\n\tn = n_;\n\tbit.assign(n+1, 0);\n  }\n\n  LL max(int i){\n\tLL s = 0;\n\twhile(i > 0){\n\t  maxi(s, bit[i]);\n\t  i -= i & -i;\n\t}\n\treturn s;\n  }\n\n  void add(int i, LL x){\n\twhile(i <= n){\n\t  maxi(bit[i], x);\n\t  i += i & -i;\n\t}\n  }\n};\n\nint main(){\n  cin.tie(0);\n  ios_base::sync_with_stdio(false);\n\n  LL N;\n  cin >> N;\n  VL xs(N);\n  REP(i,N) cin >> xs[i];\n\n  BIT bit(N+1);\n  LL ans = 0;\n  REP(i,N){\n\tLL t = xs[i] + bit.max(xs[i]);\n\tmaxi(ans, t);\n\tbit.add(xs[i], t);\n  }\n  cout << N * (N+1) / 2 - ans << endl;\n\n  return 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include <iostream>\n#include <vector>\n#define int long long\nusing namespace std;\nint INF = 1000000000;\nstruct SegmentTree{\nprivate:\n  int n;\n  vector<int> node;\npublic:\n  SegmentTree(vector<int> v){\n    int sz = v.size();\n    n = 1; while(n < sz) n *= 2;\n    node.resize(2*n-1,0);\n    for(int i = 0; i < sz; ++i) node[i+n-1] = v[i];\n    for(int i = n-2; i >= 0; --i) node[i] = max(node[2*i+1],node[2*i+2]);\n  }\n  void update(int x, int val){\n    x += (n-1);\n    node[x] = val;\n    while(x > 0){\n      x = (x-1)/2;\n      node[x] = max(node[2*x+1],node[2*x+2]);\n    }\n  }\n  int getmax(int a, int b, int k = 0, int l = 0, int r = -1){\n    if(r < 0) r = n;\n    if(r <= a || b <= l) return 0;\n    if(a <= l && r <= b) return node[k];\n    int vl = getmax(a,b,2*k+1,l,(l+r)/2);\n    int vr = getmax(a,b,2*k+2,(l+r)/2,r);\n    return max(vl,vr);\n  }\n};\nsigned main(){\n//int main(){\n  int n, s = 0;\n  cin >> n;\n  vector<int> x(n);\n  for(int i = 0; i < n; ++i){\n    cin >> x[i];\n    s += x[i];\n  }\n  SegmentTree st(vector<int>(n+1,0));\n  for(int i = 0; i < n; ++i){\n    int t = st.getmax(0,x[i]);\n    //cout << x[i] << \" \" << t << endl;\n    st.update(x[i],t+x[i]);\n  }\n\n  cout << s - st.getmax(0,n+1) << endl;\n  return 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include <vector>\n#include <list>\n#include <map>\n#include <set>\n#include <deque>\n#include <stack>\n#include <bitset>\n#include <algorithm>\n#include <functional>\n#include <numeric>\n#include <utility>\n#include <sstream>\n#include <queue>\n#include <iostream>\n#include <iomanip>\n#include <cstdio>\n#include <cmath>\n#include <cstdlib>\n#include <cctype>\n#include <string>\n#include <cstring>\n#include <ctime>\n#include <fstream>\n#include <stdio.h>\n#include <complex>\n\nusing namespace std;\n\n//conversion\n//------------------------------------------\ninline int toInt(string s) {int v; istringstream sin(s);sin>>v;return v;}\ntemplate<class T> inline string toString(T x) {ostringstream sout;sout<<x;return sout.str();}\n\n//typedef\n//------------------------------------------\ntypedef vector<int> VI;\ntypedef vector<VI> VVI;\ntypedef vector<string> VS;\ntypedef pair<int, int> PII;\ntypedef pair<int, PII> TIII;\ntypedef long long LL;\ntypedef vector<LL> VLL;\n\n//container util\n\n//------------------------------------------\n#define ALL(a)  (a).begin(),(a).end()\n#define RALL(a) (a).rbegin(), (a).rend()\n#define PB push_back\n#define MP make_pair\n#define SZ(a) int((a).size())\n#define EACH(i,c) for(typeof((c).begin()) i=(c).begin(); i!=(c).end(); ++i)\n#define EXIST(s,e) ((s).find(e)!=(s).end())\n#define SORT(c) sort((c).begin(),(c).end())\n#define MT(a,b,c) MP(a, MP(b, c))\n\n//repetition\n//------------------------------------------\n#define FOR(i,a,b) for(int i=(a);i<(b);++i)\n#define REP(i,n)  FOR(i,0,n)\n\nclass SegTree{\n\tpublic:\n\tVLL dat;\n\tint n, b;\n\tLL DEF;\n\tSegTree(int N){\n\t\tn = 1;\n\t\tDEF = 0;\n\t\twhile(n<N)n*=2;\n\t\tdat = VLL(2*n-1, DEF);\n\t}\n\tvoid update(int index, LL v){\n\t\tint k=index+n-1;\n\t\tdat[k]=v; \n\t\twhile(1){\n\t\t\tk=(k-1)/2;//上に登る\n\t\t\tdat[k] = value(k);\n\t\t\tif(k==0)break;\n\t\t}\n\t}\n\tinline LL value(int idx){//Update value with (2*idx+1, 2*idx+2) \n\t\treturn value(dat[2*idx+1], dat[2*idx+2]);\n\t}\n\tinline LL value(LL v1, LL v2){\n\t\treturn max(v1, v2);\n\t}\n\tLL query(int idx1, int idx2, int node=0, int range1=0, int range2=-1){\n\t\tif(range2 <0 )range2 = n;\n\t\tif(range2 <= idx1 || idx2 <= range1)return DEF;//交差しない\n\t\tif(idx1 <= range1 && range2 <= idx2)return dat[node];\n\t\telse{\n\t\t\tLL vl = query(idx1, idx2, node*2+1, range1, (range1+range2)/2);\n\t\t\tLL vr = query(idx1, idx2, node*2+2, (range1+range2)/2, range2); \n\t\t\treturn value(vl, vr);\n\t\t}\n\t}\n};\n\nint main(){\n\tint n;\n\tcin >> n;\n\tSegTree seg(n);\n\tREP(i,n){\n\t\tint tmp;\n\t\tscanf(\"%d\", &tmp);\n\t\tLL v = seg.query(0, tmp-1);\n\t\tseg.update(tmp-1, v+tmp);\n\t}\n\tcout << n*(n+1)/2-seg.query(0, n)<< endl;\n\treturn 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\n\nusing namespace std;\n\ntypedef long long ll;\ntypedef unsigned long long ull;\ntypedef long double ld;\ntypedef pair<ll, ll> P;\n\n#define EACH(i,a) for (auto& i : a)\n#define FOR(i,a,b) for (ll i=(a);i<(b);i++)\n#define RFOR(i,a,b) for (ll i=(b)-1;i>=(a);i--)\n#define REP(i,n) for (ll i=0;i<(n);i++)\n#define RREP(i,n) for (ll i=(n)-1;i>=0;i--)\n#define debug(x) cout<<#x<<\": \"<<x<<endl\n#define pb push_back\n#define ALL(a) (a).begin(),(a).end()\n\nconst ll linf = 1e18;\nconst int inf = 1e9;\nconst double eps = 1e-12;\nconst double pi = acos(-1);\n\ntemplate<typename T>\nistream& operator>>(istream& is, vector<T>& vec) {\n\tEACH(x,vec) is >> x;\n\treturn is;\n}\n/*\ntemplate<class... T>\nostream& operator<<(ostream& os, tuple<T...>& t) {\n\tfor (size_t i = 0; i < tuple_size< tuple<T...> >::value; ++i) {\n\t\tif (i) os << \" \";\n\t\tos << get<0>(t);\n\t}\n\treturn os;\n}\n*/\ntemplate<typename T>\nostream& operator<<(ostream& os, vector<T>& vec) {\n\tREP(i,vec.size()) {\n\t\tif (i) os << \" \";\n\t\tos << vec[i];\n\t}\n\treturn os;\n}\ntemplate<typename T>\nostream& operator<<(ostream& os, vector< vector<T> >& vec) {\n\tREP(i,vec.size()) {\n\t\tif (i) os << endl;\n\t\tos << vec[i];\n\t}\n\treturn os;\n}\n\nclass Seg {\nprivate:\n    ll size;\n    vector<ll> data;\npublic:\n    ll get(int l, int r, int n, int L, int R) {\n        if (r <= L || R <= l) return 0;\n        if (L <= l && r <= R) return data[n];\n        int m = (l + r) / 2;\n        return max(get(l, m, n*2+1, L, R), get(m, r, n*2+2, L, R));\n    }\n    ll get(int l, int r) {\n        return get(0, size, 0, l, r);\n    }\n    void update(int pos, ll val) {\n        pos += size-1;\n        data[pos] = val;\n        while (1) {\n            if (pos == 0) break;\n            pos = (pos-1)/2;\n            data[pos] = max(data[pos*2+1], data[pos*2+2]);\n        }\n    }\n    Seg(int n) {\n        for (size = 1; size < n; size <<= 1);\n        data = vector<ll>(size*2-1, 0);\n    }\n};\n\nint main() {\n    std::ios::sync_with_stdio(false);\n    std::cin.tie(0);\n    int n; cin >> n;\n    vector<int> v(n); cin >> v;\n    Seg seg(n);\n    vector<int> rv(n);\n    REP(i, n) {\n        --v[i];\n        rv[v[i]] = i;\n    }\n    REP(i, n) {\n        int val = seg.get(0, rv[i])+(i+1);\n        // cout << seg.get(0, rv[i]) << \" \" << val << endl;\n        seg.update(rv[i], val);\n    }\n    ll ans = (ll)n * (n+1) / 2;\n    ans -= seg.get(0, n);\n    cout << ans << endl;\n}"
  },
  {
    "language": "C++",
    "code": "#include <iostream>\n#include <vector>\n#include <utility>\n#include <algorithm>\nusing namespace std;\n\n#define INF 1e9\n\nclass SegmentTree{\npublic:\n  SegmentTree(int size)\n    : n(power2(size)),\n      node(vector<long long int>(2 * n - 1, NEUTRAL()))\n  {}\n  \n  SegmentTree(vector<long long int>& init){\n    n = power2(init.size());\n    node = vector<long long int>(2 * n - 1, NEUTRAL());\n    \n    // ????????????????????\\??????????????????\n    for(size_t i = 0; i < init.size(); i++){ node[n - 1 + i] = init[i]; }\n    // ????????????????????£?????????\n    for(int i = n - 2; i >= 0; i--){ node[i] = func(node[2 * i + 1], node[2 * i + 2]); }\n  }\n\n  // ???????????¨???\n  long long int RangeQuery(int a, int b){ return _RQ(a, b, 0, 0, n); }\n\n  // ??????????????????????????´\n  void change(int index, long long int value){\n    int k = n - 1 + index;\n    node[k] = value;\n    update((k - 1) / 2);\n  }\n\n  // ??¨????????? (???????????°??¨)\n  void print(){\n    int h = 1, cnt = 1;\n    for(size_t i = 0; i < node.size(); i++){\n      cout << \"[\" << node[i] << \"]\";\n      if(h <= cnt){\n        cout << endl;\n        h *= 2;\n        cnt = 0;\n      }\n      cnt++;\n    }\n  }\n\nprivate:\n  int n;\n  vector<long long int> node;\n\n  // ????????¢??°\n  // ??????????°??????¨????????? min(x, y), ??????????????? x + y ??????\n  long long int func(long long int x, long long int y){ return max(x, y); }\n  // ?????????\n  // ??????????°??????¨????????? ??¨??§?????°, ??????????????? 0 ??????\n  long long int NEUTRAL(){ return 0; }\n  \n  // s??\\?????§??????????°????2^n????±???????\n  long long int power2(int s){\n    int logs = 32 - __builtin_clz(s);\n    return 1 << logs;\n    //int count, ans = 1;\n    //for(count = 0; s != 0; count++){ s /= 2; }\n    //for(int i = 0; i < count; i++){ ans *= 2; }\n    //return ans;\n  }\n\n  // [a, b)???????????§????????????????±??????????\n  // ????????????[l, r)???????????§???????????????node[k]??§??????\n  long long int _RQ(int a, int b, int k, int l, int r){\n    // [l, r)???????????£??????[a, b)???????????£?????´?????????????????????????????????\n    if(r <= a || b <= l){ return NEUTRAL(); }\n    // [l, r)???????????£??????[a, b)??????????????????????????´????????????????????????????????????\n    if(a <= l && r <= b){ return node[k]; }\n    \n    // 2????????????????????§????????????????????°???????±???????????????????????????????????????????\n    long long int vl = _RQ(a, b, 2 * k + 1, l, (l + r) / 2);\n    long long int vr = _RQ(a, b, 2 * k + 2, (l + r) / 2, r);\n    return func(vl, vr);\n  }\n\n  // node[k]?????´??°\n  void update(long long int k){\n    if(k < 0){ return; }\n    \n    long long int prior = node[k];\n    node[k] = func(node[2 * k + 1], node[2 * k + 2]);\n    // ??´??°?????¨??????????????????????????£?????? or ??????????????§??´??°???????????£?????????\n    // ????????????????????´??°??????????????????????????§return\n    if(node[k] == prior || k <= 0){ return; }\n\n    // ????????´??°???????????????????????°?¶???????\n    update((k - 1) / 2);\n  }\n};\n\n\n\nint main(void){\n  int n;\n  cin >> n;\n  long long int sum = 0;\n  long long int max_input = 0;\n  vector<long long int> input(n); \n  for(int i = 0; i < n; i++){\n    cin >> input[i];\n    sum += input[i];\n    max_input = max(max_input, input[i]);\n  }\n\n  SegmentTree taro(max_input + 1);\n\n  for(int i = 0; i < n; i++){\n    taro.change(input[i], taro.RangeQuery(0, input[i]) + input[i]);\n  }\n\n  cout << sum - taro.RangeQuery(0, max_input + 1) << endl;\n  return 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include <iostream>\n#include <algorithm>\n\nusing namespace std;\n\ntypedef long long ll;\n#define rep(a,b) for(int a = 0; a < b; a++)\n\nint n;\nll dp[1<<18]{};\nint arr[100000];\nint size = 1;\n\nvoid update(int index, ll num) {\n  index += size-1;\n  dp[index] = num;\n  //cout << \"  \" << index << \",\" << dp[index] << endl;\n  while(index>0) {\n    int new_index = (index-1)>>1;\n    dp[new_index] = max(dp[(new_index<<1)+1],dp[(new_index<<1)+2]);\n    //cout << \"  \" << new_index << \",\" << dp[new_index] << endl;\n    index = new_index;\n  }\n  //dp[index] = max(dp[index],dp[index^1]);\n}\n\nll get_max(int a, int b, int k, int left, int right) {\n  //cout << \"gmax \" << a << \",\" << b << \",\" << k << \",\" << left << \",\" << right << endl;\n  if(right<a||b<=left||right<=left) return 0;\n  if(a<=left&&right<=b) {\n    //cout << \"OK \" << dp[k] << endl;\n    return dp[k];\n  }\n  ll ret = 0;\n  ret = max(ret,get_max(a,b,(k<<1)+1,left,(left+right)>>1));\n  ret = max(ret,get_max(a,b,(k<<1)+2,(left+right+1)>>1,right));\n  return ret;\n}\n\nint main() {\n  cin >> n;\n  for(int i = 1; i < n; i<<=1) size<<=1;\n  rep(i,n) cin >> arr[i];\n  rep(i,n) {\n    int num = arr[i];\n    ll _max = get_max(1,num,0,0,size);\n    //cout << num << \",\" << _max << endl;\n    update(num,_max+num);\n  }\n  ll ans = (ll)n;\n  ans = ans*(ans+1)/2;\n  //for(int i = 0; i < size<<1; i++) cout << dp[i] << endl;\n  cout << ans-dp[0] << endl;\n}\n\n"
  },
  {
    "language": "C++",
    "code": "#include<iostream>\n#include<vector>\n#include<algorithm>\n#include<climits>\n\nconst int MAX_N=1000000;\n\ntypedef long long ll;\n\nusing namespace std;\n\nll n,dat[2*MAX_N-1];\n\nvoid init(int n_){\n\tn=1;\n\twhile(n<n_)n*=2;\n\tfor(int i=0;i<2*n-1;i++)dat[i]=0;\n}\n\nvoid update(int k,ll a){\n\tk+=n-1;\n\tdat[k]=a;\n\t\n\twhile(k>0){\n\t\tk=(k-1)/2;\n\t\tdat[k]=max(dat[2*k+1],dat[2*k+2]);\n\t}\n}\n\nll query(int a,int b,int k,int l,int r){\n\tif(r<=a || b<=l)return 0;\n\tif(a<=l && r<=b)return dat[k];\n\telse {\n\t\tll vl=query(a,b,k*2+1,l,(l+r)/2);\n\t\tll vr=query(a,b,k*2+2,(l+r)/2,r);\n\t\treturn max(vl,vr);\n\t}\n}\n\nint main(void){\n\t\n\tll in,n_,ans=0;\n\tcin >> n_;\n\t\n\tinit(n_);\n\t\n\tfor(int i=0;i<n_;i++){\n\t\tcin >> in;\n\t\tupdate(in,in+query(1,in+1,0,0,n));\n\t\tans=max(ans,dat[in+n-1]);\n\t}\n\tcout << n_*(n_+1)/2-ans << endl;\n\t\n\treturn 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include <iostream>\n#include <algorithm>\n#include <utility>\n#include <vector>\n#include <list>\n#include <map>\n#include <set>\n#include <queue>\n#include <stack>\n#include <string>\n#include <sstream>\n#include <cstring>\n#include <cstdlib>\n\nusing namespace std;\n\n#define ALL(c) c.begin(),c.end()\n#define RALL(c) c.rbegin(),c.rend()\n#define SORT(x) sort((x).begin(),(x).end())\n#define REP(i,x,y) for(int i=(x);i<(y);++i)\n#define MP(a,b) make_pair((a),(b))\n#define F_ first\n#define S_ second\n#define debug(x) #x << \"=\" << (x)\n \n#ifdef DEBUG\n#define _GLIBCXX_DEBUG\n#define dump(x) std::cerr << debug(x) << \" (L:\" << __LINE__ << \")\" << std::endl\n#else\n#define dump(x)\n#endif\n\ntypedef long long int lli;\ntypedef pair<int,int> pii;\n\nconst int INF=1<<30;\nconst long long int INF_=1LL<<58;\nconst double EPS=1e-9;\nconst int dx[]={1,0,-1,0},dy[]={0,1,0,-1};\n\ntemplate <typename T> ostream &operator<<(ostream &os, const vector<T> &vector){\n\tos << \"[\";\n\tfor (const auto &v : vector) {\n\t\tos << v << \",\";\n\t}\n\tos << \"]\";\n\treturn os;\n}\n\nclass SegmentTree{\n\tprivate:\n\tpublic:\n\tint size;\n\tvector<int> data;\n\tvoid Init(int n){\n\t\tsize=1;\n\t\twhile(size<n) size*=2;\n\t\tdata=vector<int>(size*2-1,INF);\n\t}\n\tvoid Update(int k,int a){\n\t\tk+=size-1;\n\t\tdata[k]=a;\n\t\twhile(k>0){\n\t\t\tk=(k-1)/2;\n\t\t\tdata[k]=min(data[k*2+1],data[k*2+2]);\n\t\t}\n\t}\t\n\tint Query(int a,int b,int k,int l,int r){\n\t\tif(r<=a||b<=l) return INF;\n\t\tif(a<=l&&r<=b) return data[k];\n\t\telse {\n\t\t\tint vl=Query(a,b,k*2+1,l,(l+r)/2);\n\t\t\tint vr=Query(a,b,k*2+2,(l+r)/2,r);\n\t\t\treturn min(vl,vr);\n\t\t}\n\t}\n};\n\nint main(){\n\tstd::ios::sync_with_stdio(false);\n\tstd::cin.tie(0);\n\tint N;\n\tcin >> N;\n\tvector<int> x(N);\n\tREP(i,0,N) cin >> x[i];\n\tvector<int> s(N);\n\ts[0]=x[0];\n\tREP(i,1,N) s[i]+=s[i-1]+x[i];\n\tvector<vector<int>> dp(N,vector<int>(2));\n\tdp[0][0]=x[0];\n\tSegmentTree st;\n\tst.Init(N);\n\tst.Update(x[0]-1,-s[0]);\n\tREP(i,1,N){\n\t\tdp[i][0]=min(dp[i-1][0],dp[i-1][1])+x[i];\n\t\tdp[i][1]=min(s[i-1],st.Query(0,x[i],0,0,st.size)+s[i-1]);\n\t\tst.Update(x[i]-1,dp[i][1]-s[i]);\n\t}\n\tcout << min(dp[N-1][1],dp[N-1][0]) << endl;\n\treturn 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\nusing namespace std;\n\n#define for_(i,a,b) for(int i=(a);i<(b);++i)\n#define for_rev(i,a,b) for(int i=(a);i>=(b);--i)\n\ntemplate< typename T >\nusing Vec = vector< T >;\n\ntypedef long long lint;\n\ntemplate< typename DATA >\nclass SegmentTree {\nprivate:\n\tint size__;\n\tVec< DATA > data;\n\t\n\tinline int left_t(int k) {\n\t\treturn (k << 1) + 1;\n\t}\n\t\n\tinline int right_t(int k) {\n\t\treturn (k << 1) + 2;\n\t}\n\t\n\tinline int center(int l, int r) {\n\t\treturn (l + r) >> 1;\n\t}\n\t\npublic:\n\tSegmentTree(int n, DATA ini) {\n\t\tfor (size__ = 1; size__ < n; size__ <<= 1);\n\t\tdata.assign(2 * size__ - 1, ini);\n\t}\n\t\n\tDATA calc(DATA d1, DATA d2) {\n\t\treturn max(d1, d2);\n\t}\n\t\n\tvoid update(int k, DATA a) {\n\t\tk += size__ - 1;\n\t\tdata[k] = a;\n\t\t\n\t\twhile (k > 0) {\n\t\t\tk = (k - 1) >> 1;\n\t\t\tdata[k] = calc(data[left_t(k)], data[right_t(k)]);\n\t\t}\n\t}\n\t\n\tDATA query(int a, int b) {\n\t\treturn query(a, b, 0, 0, size__);\n\t}\n\t\n\tDATA query(int a, int b, int k, int l, int r) {\n\t\tif (r <= a || b <= l) return 0;\n\t\tif (a <= l && r <= b) return data[k];\n\t\treturn calc(query(a, b, left_t(k), l, center(l, r)),\n\t\t\t\t\tquery(a, b, right_t(k), center(l, r), r));\n\t}\n\t\n\tint size() {\n\t\treturn size__;\n\t}\n};\n\nint n, x[100010];\n\nsigned main() {\n\tcin >> n;\n\tfor_(i,0,n) cin >> x[i];\n\t\n\tSegmentTree< lint > st(n + 1, 0);\n\tfor_(i,0,n) st.update(x[i], x[i] + st.query(1, x[i]));\n\tcout << n * (n + 1) / 2 - st.query(1, n + 1) << endl;\n}"
  },
  {
    "language": "C++",
    "code": "#include <iostream>\n#include <algorithm>\n#include <numeric>\n#include <vector>\n#include <cassert>\n#include <string>\n#include <memory.h>\n#include <queue>\n#include <cstdio>\n#include <cstdlib>\n#include <set>\n#include <map>\n#include <cctype>\n#include <iomanip>\n#include <sstream>\n#include <cctype>\n#include <fstream>\n#include <cmath>\nusing namespace std;\n\n#define REP2(i, m, n) for(int i = (int)(m); i < (int)(n); i++)\n#define REP(i, n) REP2(i, 0, n)\n#define ALL(c) (c).begin(), (c).end()\n#define ITER(c) __typeof((c).begin())\n#define PB(e) push_back(e)\n#define FOREACH(i, c) for(ITER(c) i = (c).begin(); i != (c).end(); ++i)\n#define MP(a, b) make_pair(a, b)\n#define PARITY(n) ((n) & 1)\n\ntypedef long long ll;\ntypedef pair<ll, ll> P;\nconst int INF = 1000 * 1000 * 1000 + 7;\nconst double EPS = 1e-10;\n\n\nint N;\nvector<ll> dat;\n\nvoid init(int n){\n  N = 1;\n  while(N < n)  N *= 2;\n  dat.resize(2 * N, 0);\n}\n\nll query(int a, int b, int l, int r, int k){\n  if(r <= a || b <= l) return 0;\n  if(a <= l && r <= b) return dat[k];\n\n  int m = (l + r) / 2;\n  ll vl = query(a, b, l, m, k * 2 + 1);\n  ll vr = query(a, b, m, r, k * 2 + 2);\n  return max(vl, vr);\n}\n\nvoid update(int p, ll x, int l, int r, int k){\n  if(p < l || r <= p) return;\n  if(r - l == 1){\n    dat[k] = x;\n    return;\n  }\n  \n  int m = (l + r) / 2;\n  if(l <= p && p < m) update(p, x, l, m, k * 2 + 1);\n  if(m <= p && p < r) update(p, x, m, r, k * 2 + 2);\n  dat[k] = max(dat[k * 2 + 1], dat[k * 2 + 2]);\n}\n\n\nll calc(const vector<int> &x){\n  int n = x.size();  \n  vector<int> y = x;\n  vector<int> ind;\n  \n  sort(ALL(y));\n  REP(i, x.size()) ind.push_back(lower_bound(ALL(y), x[i]) - y.begin());\n  init(n);\n\n  \n  REP(i, n){\n    ll M = query(0, ind[i], 0, N, 0);\n    update(ind[i], M + x[i], 0, N, 0);\n  }\n\n  return query(0, N, 0, N, 0);\n}\n\n\nint main(){\n  \n  int n;\n  cin >> n;\n  \n  vector<int> x(n);\n  \n  ll S = 0;\n\n  REP(i, n){\n    cin >> x[i];\n    S += x[i];\n  }\n\n  cout << S - calc(x) << endl;\n  return 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include<bits/stdc++.h>\nusing namespace std;\ntypedef long long int ll;\n\nll d[(1<<18)];\nint n;\n\nvoid init(int _n){\n  n = 1;\n  while( n < _n ) n*=2;\n  memset(d,0,sizeof(d));\n}\n\nll query(int a,int b,int k,int l,int r){\n  if( r <= a || b <= l ) return 0;\n  else if( a <= l && r <= b ) return d[k];\n  return max( query( a, b, 2*k+1, l, (l+r)/2 ),  query( a, b, 2*k+2, (l+r)/2, r ) );\n}\n\nll query(int a,int b){\n  return query( a, b, 0, 0, n );\n}\n\nvoid sets(int k,ll x) {\n  k += n-1;\n  d[k] = x;\n  while( k > 0 ){\n    k = (k-1)/2;\n    d[k] = max( d[2*k+1], d[2*k+2] );\n  }\n}\n\ntypedef pair<ll,int> P;\n\nint N;\nvector<P> p;\nint main(){\n  cin >> N;\n  init( N );\n  for(int i=0;i<N;i++){\n    ll x; cin >> x;\n    p.push_back( P(x,i) );\n  }\n\n  sort( p.begin(), p.end() );\n  \n  ll res = 0;\n  for(int i=N-1;i>-1;i--){    \n    int k = p[i].second;\n    ll num = query( k, N );\n    res = max( res, num + p[i].first );\n    sets( k, num+p[i].first );\n  }\n  cout << N*(N+1)/2 - res << endl;\n  \n}"
  },
  {
    "language": "C++",
    "code": "#include <cstdio>\n#include <iostream>\n#include <sstream>\n#include <iomanip>\n#include <algorithm>\n#include <cmath>\n#include <string>\n#include <vector>\n#include <list>\n#include <queue>\n#include <stack>\n#include <set>\n#include <map>\n#include <bitset>\n#include <numeric>\n#include <climits>\n#include <cfloat>\nusing namespace std;\n\nclass Rmq\n{\n    int n;\n    vector<long long> data;\n    long long query(int a, int b, int k, int l, int r){\n        if(r < a || b < l)\n            return LLONG_MAX;\n        if(a <= l && r <= b)\n            return data[k];\n        long long x = query(a, b, k*2+1, l, (l+r)/2);\n        long long y = query(a, b, k*2+2, (l+r+1)/2, r);\n        return min(x, y);\n    }\npublic:\n    Rmq(int n0){ // コンストラクタ（要素数を指定）\n        n = 1;\n        while(n < n0)\n            n *= 2;\n        data.assign(2*n-1, LLONG_MAX);\n    }\n    void update(int k, long long x){ // k番目の要素をxに変更する\n        k += n - 1;\n        data[k] = x;\n        while(k > 0){\n            k = (k - 1) / 2;\n            data[k] = min(data[k*2+1], data[k*2+2]);\n        }\n    }\n    long long query(int a, int b){ // 区間[a,b]の最小値を返す\n        return query(a, b, 0, 0, n-1);\n    }\n};\n\nint main()\n{\n    int n;\n    cin >> n;\n    vector<int> x(n);\n    for(int i=0; i<n; ++i)\n        cin >> x[i];\n\n    Rmq rmq(n+1);\n    rmq.update(0, 0);\n    for(int i=0; i<n; ++i)\n        rmq.update(x[i], rmq.query(0, x[i]-1) - x[i]);\n\n    long long ret = (n * (n + 1LL)) / 2;\n    ret += rmq.query(0, n);\n    cout << ret << endl;\n\n    return 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include <iostream>\n#include <algorithm>\n#include <numeric>\n#include <vector>\n#include <cassert>\n#include <string>\n#include <memory.h>\n#include <queue>\n#include <cstdio>\n#include <cstdlib>\n#include <set>\n#include <map>\n#include <cctype>\n#include <iomanip>\n#include <sstream>\n#include <cctype>\n#include <fstream>\n#include <cmath>\nusing namespace std;\n\n#define REP2(i, m, n) for(int i = (int)(m); i < (int)(n); i++)\n#define REP(i, n) REP2(i, 0, n)\n#define ALL(c) (c).begin(), (c).end()\n#define ITER(c) __typeof((c).begin())\n#define PB(e) push_back(e)\n#define FOREACH(i, c) for(ITER(c) i = (c).begin(); i != (c).end(); ++i)\n#define MP(a, b) make_pair(a, b)\n#define PARITY(n) ((n) & 1)\n\ntypedef long long ll;\ntypedef pair<ll, ll> P;\nconst int INF = 1000 * 1000 * 1000 + 7;\nconst double EPS = 1e-10;\n\n\nint N;\nvector<int> dat;\n\nvoid init(int n){\n  N = 1;\n  while(N < n)  N *= 2;\n  dat.resize(2 * N, 0);\n}\n\nll query(int a, int b, int l, int r, int k){\n  if(r <= a || b <= l) return 0;\n  if(a <= l && r <= b) return dat[k];\n\n  int m = (l + r) / 2;\n  ll vl = query(a, b, l, m, k * 2 + 1);\n  ll vr = query(a, b, m, r, k * 2 + 2);\n  return max(vl, vr);\n}\n\nvoid update(int p, ll x, int l, int r, int k){\n  if(p < l || r <= p) return;\n  if(r - l == 1){\n    dat[k] = x;\n    return;\n  }\n  \n  int m = (l + r) / 2;\n  if(l <= p && p < m) update(p, x, l, m, k * 2 + 1);\n  if(m <= p && p < r) update(p, x, m, r, k * 2 + 2);\n  dat[k] = max(dat[k * 2 + 1], dat[k * 2 + 2]);\n}\n\n\nll calc(const vector<int> &x){\n  int n = x.size();  \n  vector<int> y = x;\n  vector<int> ind;\n  \n  sort(ALL(y));\n  REP(i, x.size()) ind.push_back(lower_bound(ALL(y), x[i]) - y.begin());\n  init(n);\n\n  \n  REP(i, n){\n    ll M = query(0, ind[i], 0, N, 0);\n    update(ind[i], M + x[i], 0, N, 0);\n  }\n\n  return query(0, N, 0, N, 0);\n}\n\n\nint main(){\n  \n  int n;\n  cin >> n;\n  \n  vector<int> x(n);\n  \n  ll S = 0;\n\n  REP(i, n){\n    cin >> x[i];\n    S += x[i];\n  }\n\n  cout << S - calc(x) << endl;\n  return 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\n\nusing namespace std;\n\n#define REP(i, n) for (int i=0; i<(n); ++i)\n#define RREP(i, n) for (int i=(int)(n)-1; i>=0; --i)\n#define FOR(i, a, n) for (int i=(a); i<(n); ++i)\n#define RFOR(i, a, n) for (int i=(int)(n)-1; i>=(a); --i)\n\n#define SZ(x) ((int)(x).size())\n#define all(x) begin(x),end(x)\n\n#define dump(x) cerr<<#x<<\" = \"<<(x)<<endl\n#define debug(x) cerr<<#x<<\" = \"<<(x)<<\" (L\"<<__LINE__<<\")\"<<endl;\n\ntemplate<class T>\nostream &operator<<(ostream &os, const vector <T> &v) {\n    os << \"[\";\n    REP(i, SZ(v)) {\n        if (i) os << \", \";\n        os << v[i];\n    }\n    return os << \"]\";\n}\n\ntemplate<class T, class U>\nostream &operator<<(ostream &os, const pair <T, U> &p) {\n    return os << \"(\" << p.first << \" \" << p.second << \")\";\n}\n\ntemplate<class T>\nbool chmax(T &a, const T &b) {\n    if (a < b) {\n        a = b;\n        return true;\n    }\n    return false;\n}\n\ntemplate<class T>\nbool chmin(T &a, const T &b) {\n    if (b < a) {\n        a = b;\n        return true;\n    }\n    return false;\n}\n\nusing ll = long long;\nusing ull = unsigned long long;\nusing ld = long double;\nusing P = pair<int, int>;\nusing vi = vector<int>;\nusing vll = vector<ll>;\nusing vvi = vector<vi>;\nusing vvll = vector<vll>;\n\nconst ll MOD = 1e9 + 7;\nconst int INF = INT_MAX / 2;\nconst ll LINF = LLONG_MAX / 2;\nconst ld EPS = 1e-9;\n\ntemplate<typename M>\nstruct SegmentTree {\n    int n, sz;\n    vector<M> data;\n    const function<M(M,M)> f;\n    const M e;\n\n    SegmentTree(\n            int n,\n            const function<M(M,M)>& f,\n            const M& e\n    ) : n(n), f(f), e(e) {\n        sz = 1;\n        while (sz < n) sz <<= 1;\n        data.assign(2*sz, e);\n    }\n\n    void build(const vector<M>& v) {\n        assert(v.size() <= n);\n        for (int i = 0; i < v.size(); ++i) {\n            data[i + sz] = v[i];\n        }\n        for (int i = sz-1; i > 0; --i) {\n            data[i] = f(data[2*i], data[2*i+1]);\n        }\n    }\n\n    template<typename UpdateQuery>\n    void update(int k, const UpdateQuery& q) {\n        k += sz;\n        data[k] = q(data[k]);\n        while (k >>= 1) {\n            data[k] = f(data[2*k], data[2*k+1]);\n        }\n    }\n\n    M _query(int a, int b, int k, int l, int r) const {\n        if (r <= a or b <= l) return e;\n        if (a <= l and r <= b) return data[k];\n        return f(_query(a,b,2*k,  l,(l+r)/2),\n                 _query(a,b,2*k+1,(l+r)/2,r));\n    }\n\n    M query(int a, int b) const {\n        // return f[a,b)\n        return _query(a, b, 1, 0, sz);\n    }\n\n    M operator[](int i) const {\n        return data.at(i + sz);\n    }\n\n    friend ostream& operator<<(ostream& os, const SegmentTree& s) {\n        os << \"[\";\n        for (int i = 0; i < s.n; ++i) {\n            if (i) os << \" \";\n            os << s[i];\n        }\n        return os << \"]\";\n    }\n};\n\nint main() {\n    cin.tie(0);\n    ios::sync_with_stdio(false);\n    cout << fixed << setprecision(10);\n\n    ll n; cin >> n;\n    vi x(n);\n    REP(i, n) {\n        cin >> x[i];\n        --x[i];\n    }\n\n    SegmentTree<ll> tree(n, [](ll a,ll b){ return max(a,b); }, 0);\n\n    REP(i, n) {\n        ll ma = tree.query(0, x[i]);\n        tree.update(x[i], [&](ll a){ return ma + x[i] + 1; });\n    }\n\n    ll ma = 0;\n    REP(i, n) chmax(ma, tree[i]);\n    ll ans = n * (n+1) / 2 - ma;\n\n    cout << ans << endl;\n\n    return 0;\n}\n\n"
  },
  {
    "language": "C++",
    "code": "#include<iostream>\n#include<cstdio>\n#include<cstdlib>\n#include<cmath>\n#include<algorithm>\n#include<cstring>\n#include<sstream>\n#include<vector>\n#include<queue>\n#include<stack>\n#include<string>\n#include<climits>\n#include<map>\n#include<set>\n#include<cassert>\n#include<deque>\n#define REP(i,s,n) for(int i=s;i<n;i++)\n#define rep(i,n) REP(i,0,n)\n#define INF 1<<27\n#define all(n) n.begin(),n.end()\n#define insert(a,b,c,d) PP(P(a,b),P(c,d))\n#define F first\n#define S second\n#define pb push_back\n#define MAX_N 100100\n#define foreach(i,c) for(iter(c) i=(c).begin();i!=(c).end();++i)\nusing namespace std;\ntypedef pair<int,int> P;\ntypedef pair<P,P> PP;\ntypedef long long ll;\n\n\n\n\n\ntemplate<class T>\nclass RMQ_segment{\nprivate:\n  int n;\n  T dat[2*MAX_N-1];\npublic:\n  void init(int n_){\n    n = 1;\n    while(n<n_)n*=2;\n    for(int i=0;i<2*n-1;i++)dat[i] = 0;\n  }\n\n  void update(int k,T a){\n    k += n-1;\n    dat[k] = a;\n    while(k > 0){\n      k = (k-1)/2;\n      dat[k] = max(dat[k*2+1],dat[k*2+2]);\n    }\n  }\n\n  T query(int a,int b,int k,int l,int r){\n    if(r<=a || b<=l)return 0;\n    else if(a<=l && r<=b)return dat[k];\n    \n      T vl = query(a,b,k*2+1,l,(l+r)/2);\n      T vr = query(a,b,k*2+2,(l+r)/2,r);\n      return max(vl,vr);\n    \n  }\n\n  T _query(int a,int b){//nの範囲でミスしないように極力こっちを利用\n    return query(a,b,0,0,n);\n  }\n\n};\n\n\n int x[1000010];\n RMQ_segment<ll> rmq;\nint main(){\n  int n;\n  cin >> n;\n \n  rmq.init(n+1);\n \n  rep(i,n)cin >> x[i];\n  ll mex=0;\n  ll sum=0;\n\n  for(int i=0;i<n;i++){\n    sum+=x[i];\n    ll premex = rmq._query(0,x[i])+x[i];\n    rmq.update(x[i],premex);\n    mex = max(mex,premex);\n   \n  }  \n  \n  cout << sum-mex << endl;\n\nreturn 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\n\nusing namespace std;\ntypedef long long int ll;\ntypedef pair<int, int> P;\ntypedef pair<ll, ll> Pll;\ntypedef vector<int> Vi;\ntypedef tuple<int, int, int> T;\n#define FOR(i,s,x) for(int i=s;i<(int)(x);i++)\n#define REP(i,x) FOR(i,0,x)\n#define ALL(c) c.begin(), c.end()\n#define DUMP( x ) cerr << #x << \" = \" << ( x ) << endl\n\n/*\nRange Sum Query by FenwickTree(Binary Indexed Tree)\n\ntotal number: n\nqueries:\n    1. update(i, val): add val to i-th value \n    2. query(n): sum(bit[0] + ... + bit[n-1])\ntime complexity: O(log n)\nspace complexity: O(N)\n\nSelf-balancing binary search tree or Segment Tree can do the same, it takes longer to program and complexity also increases.\n\nThanks: http://hos.ac/slides/20140319_bit.pdf\n    \nused in ARC031 C, indeednow finalB E, DSL2B(AOJ), ARC033 C, yukicoder No.59\n*/\n\nstruct RangeSumQuery {\n  int N;\n  vector<ll> dat;\n\n  RangeSumQuery(int N) : N(N) { dat.resize(N, 0); }\n\n  void update(int k, ll val) {\n    for (int x = k; x < N; x |= x + 1) {\n      dat[x] += val;\n    }\n  }\n\n  ll query(int k) {\n    ll ret = 0;\n    for (int x = k - 1; x >= 0; x = (x & (x + 1)) - 1) {\n      ret += dat[x];\n    }\n    return ret;\n  }\n};\n\nint main() {\n  // use scanf in CodeForces!\n  cin.tie(0);\n  ios_base::sync_with_stdio(false);\n\n  int N;\n  cin >> N;\n  RangeSumQuery bit(N);\n\n  vector<P> load;\n  REP(i, N) {\n    int x;\n    cin >> x;\n    load.push_back(P(-x, i));\n    bit.update(i, (ll)x);\n  }\n  sort(ALL(load));\n  ll ans = 0;\n  for (P p : load) {\n    int weight = -p.first, index = p.second;\n    ans += min((ll)weight, bit.query(N) - bit.query(index + 1));\n    bit.update(index, -(ll)weight);\n  }\n  cout << ans << endl;\n  return 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include<cstdio>\n#include<algorithm>\n\n#define rep(i,n) for(int i=0;i<(n);i++)\n\nusing namespace std;\n\ntypedef long long ll;\n\ntemplate<class T>\nclass segment_tree_RMQ{\n\tstatic const int N_MAX=1<<17;\n\tint n;\n\tT dat[2*N_MAX];\n\n\tT query(int l,int r,int a,int b,int u){\n\t\tif(l<=a && b<=r) return dat[u];\n\n\t\tT res=0;\n\t\tint c=(a+b+1)/2;\n\t\tif(l<c && a<r) res=max(res,query(l,r,a,c,2*u));\n\t\tif(l<b && c<r) res=max(res,query(l,r,c,b,2*u+1));\n\t\treturn res;\n\t}\n\npublic:\n\tvoid build(int N,T val){\n\t\tfor(n=1;n<N;n*=2);\n\t\trep(u,2*n) dat[u]=val;\n\t}\n\n\tvoid update(int u,T v){\n\t\tu+=n;\n\t\tdat[u]=v;\n\t\tfor(u/=2;u>=1;u/=2) dat[u]=max(dat[2*u],dat[2*u+1]);\n\t}\n\n\tT query(int l,int r){ return query(l,r,0,n,1); }\n};\n\nint main(){\n\tint n; scanf(\"%d\",&n);\n\tint x[100000];\n\trep(i,n) scanf(\"%d\",x+i);\n\n\tstatic segment_tree_RMQ<ll> S;\n\tS.build(n+1,0);\n\trep(i,n){\n\t\tll cost=S.query(0,x[i]);\n\t\tS.update(x[i],cost+x[i]);\n\t}\n\n\tprintf(\"%lld\\n\",(ll)n*(n+1)/2-S.query(0,n+1));\n\n\treturn 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include<iostream>\n#include<vector>\n#include<algorithm>\n#include<climits>\n\nconst int MAX_N=1000000;\n\ntypedef long long ll;\n\nusing namespace std;\n\nll n,dat[2*MAX_N-1];\n\nvoid init(int n_){\n\tn=1;\n\twhile(n<n_)n*=2;\n}\n\nvoid update(int k,ll a){\n\tk+=n-1;\n\tdat[k]=a;\n\t\n\twhile(k>0){\n\t\tk=(k-1)/2;\n\t\tdat[k]=max(dat[2*k+1],dat[2*k+2]);\n\t}\n}\n\nll query(int a,int b,int k,int l,int r){\n\tif(r<=a || b<=l)return 0;\n\tif(a<=l && r<=b)return dat[k];\n\telse {\n\t\tll vl=query(a,b,k*2+1,l,(l+r)/2);\n\t\tll vr=query(a,b,k*2+2,(l+r)/2,r);\n\t\treturn max(vl,vr);\n\t}\n}\n\nint main(void){\n\t\n\tll in,m,ans=0;\n\t\n\tcin >> m;\n\t\n\tinit(m);\n\t\n\tfor(int i=0;i<m;i++){\n\t\tcin >> in;\n\t\tupdate(in,in+query(1,in+1,0,0,n));\n\t\t//ans=max(ans,dat[in+n-1]);\n\t}\n\tcout << m*(m+1)/2-query(1,m+1,0,0,n) << endl;\n\t\n\treturn 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include<cstdio>\n#include<iostream>\n#include<string>\n#include<vector>\n#include<algorithm>\n\nusing namespace std;\n\n#define reps(i,f,n) for(int i=f;i<int(n);i++)\n#define rep(i,n) reps(i,0,n)\n\ntypedef long long ll;\n\nconst int N = 100010;\n\nclass BIT{\n\tstatic const int N = 100010;\n\tpublic:\n\tll t[N];\n\tvoid init(){rep(i,N)t[i]=0;}\n\tll calc(ll a,ll b){return max(a,b);}\n\t\n\tvoid setval(int pos, ll val){\n\t\tpos++;\n\t\tfor(int i=0;;i++){\n\t\t\tif(pos>=N)break;\n\t\t\tif(pos&(1<<i)){\n\t\t\t\tt[pos] = calc(t[pos],val);\n\t\t\t\tpos += (1<<i);\n\t\t\t}\n\t\t}\n\t}\n\t\n\tll getval(int pos){\n\t\tpos++;\n\t\tll ret = 0;\n\t\tfor(int i=0;;i++){\n\t\t\tif(pos==0)break;\n\t\t\tif(pos&(1<<i)){\n\t\t\t\tret = calc(ret, t[pos]);\n\t\t\t\tpos -= (1<<i);\n\t\t\t}\n\t\t}\n\t\treturn ret;\n\t}\n\t\n\tvoid print(){\n\t\tprintf(\"t : \");\n\t\trep(i,10)printf(\"%d \",t[i]);puts(\"\");\n\t}\n};\n\nint main(){\n\tint n;\n\tcin>>n;\n\t\n\tint p[N];\n\tll sum = 0;\n\trep(i,n){\n\t\tcin>>p[i];\n\t\tsum += p[i];\n\t}\n\t\n\tBIT bit;\n\tbit.init();\n\t\n\trep(i,n){\n\t\tbit.setval( p[i], bit.getval(p[i])+p[i] );\n\t\t//bit.print();\n\t}\n\t\n\tcout<<sum - bit.getval(n-1)<<endl;\n}\n\n/*\n5\n1 5 3 2 4\n\n*/"
  },
  {
    "language": "C++",
    "code": "#include <stdio.h>\ntypedef long long ll;\nll max(ll a,ll b){return a<b?b:a;}\nll w[100005],bit[(1<<17)+5];\nint a[100005],n;\nint f(int x){ return x&-x;}\nvoid update(int i,ll x){ for(int s=i;s<=(1<<17);s+=f(s)) bit[s]=max(bit[s],x);}\nll get(int i){ ll ret=0LL; for(int s=i;s>0;s-=f(s)) ret=max(ret,bit[s]); return ret;}\nint main()\n{\n  scanf(\"%d\",&n);\n  for(int i=1;i<=n;i++) w[i]=i;\n  for(int i=1;i<=n;i++) scanf(\"%d\",&a[i]);\n  ll sum=0;\n  for(int i=1;i<=n;i++)\n    {\n      ll got=get(a[i]-1);\n      update(a[i],got+w[a[i]]); sum+=w[i];\n    }\n  printf(\"%lld\\n\",(sum-get((1<<17))));\n}"
  },
  {
    "language": "C++",
    "code": "#include <iostream>\n#include<bits/stdc++.h>\nusing namespace std;\ntypedef long long ll;\nll n,m,a,tot,ans;\nvector<ll> v;\nvoid ini(void){\n    m=1;\n    while(m<n)m*=2;\n    v.resize(2*m-1,0);\n}\nvoid STadd(ll a,ll b){\n    a+=m-1;\n    v[a]=b;\n    while(a){\n        a=(a-1)/2;\n        v[a]=max(v[2*a+1],v[2*a+2]);\n    }\n    return ;\n}\nll STquery(ll a,ll b,ll k,ll l,ll r){\n    if(r<=a||l>=b)return 0;\n    if(a<=l&&r<=b)return v[k];\n    ll vr=STquery(a,b,2*k+1,l,(r+l)/2);\n    ll vl=STquery(a,b,2*k+2,(r+l)/2,r);\n    return max(vr,vl);\n}\nint main(void){\n    cin>>n;\n    ini();\n    for(int i=0;i<n;i++){\n        cin>>a;\n        tot+=a;\n        a--;\n        STadd(a,STquery(0,a+1,0,0,m)+a+1);\n        ans=max(ans,v[a+m-1]);\n    }\n    cout<<tot-ans<<endl;\n}\n"
  },
  {
    "language": "C++",
    "code": "#include<bits/stdc++.h>\n#define int long long\n#define MAX 100001\nusing namespace std;\nint n,p,A[MAX*2],N;\nvoid Segtree(int n_){\n  n=1;\n  while(n<n_)n*=2;\n}\nvoid update(int k,int x){\n  k+=n-1;\n  A[k]=x;\n  while(k>0){\n    k=(k-1)/2;\n    A[k]=max(A[k*2+1],A[k*2+2]);\n  }\n}\nint find(int a,int b,int k,int l,int r){\n  if(r<=a||b<=l)return 0;\n  if(a<=l&&r<=b)return A[k];\n  int v1=find(a,b,k*2+1,l,(l+r)/2);\n  int v2=find(a,b,k*2+2,(l+r)/2,r);\n  return max(v1,v2);\n}\nint main(){\n  cin>>n;\n  N=n;\n  Segtree(n+1);\n  for(int i=0;i<N;i++){\n    scanf(\"%lld\",&p);\n    int v=find(0,p,0,0,n);\n    update(p,v+p);\n  }\n  cout<<N*(N+1)/2-find(0,N+1,0,0,n)<<endl;\n}"
  },
  {
    "language": "C++",
    "code": "#include<bits/stdc++.h>\nusing namespace std;\n#define int long long\nconst int MAX_N = 1 << 17;\nint bit[MAX_N+1],n;\nint sum(int i){\n  int s=0;\n  while(i>0){\n    s+=bit[i];\n    i-=i&-i;\n  }\n  return s;\n}\nvoid add(int i,int x){\n  while(i<=n){\n    bit[i]+=x;\n    i+=i&-i;\n  }\n}\nsigned main(){\n  memset(bit,0,sizeof(bit));\n  cin>>n;\n  int x[n],ans=0;\n  for(int i=0;i<n;i++) cin>>x[i];\n  n++;\n  for(int i=n-2;i>=0;i--){\n    //cout<<x[i]<<\":\"<<sum(x[i])<<endl;\n    ans+=min(x[i],sum(x[i]));\n    add(x[i],x[i]);\n  }\n  cout<<ans<<endl;\n  return 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include<iostream>\n#include<vector>\n#include<algorithm>\n#include<climits>\n\nconst int MAX_N=1000000;\n\ntypedef long long ll;\n\nusing namespace std;\n\nll n,dat[2*MAX_N-1];\n\nvoid init(int n_){\n\tn=1;\n\twhile(n<n_)n*=2;\n\tfor(int i=0;i<2*n-1;i++)dat[i]=0;\n}\n\nvoid update(int k,ll a){\n\tk+=n-1;\n\tdat[k]=a;\n\t\n\twhile(k>0){\n\t\tk=(k-1)/2;\n\t\tdat[k]=max(dat[2*k+1],dat[2*k+2]);\n\t}\n}\n\nll query(int a,int b,int k,int l,int r){\n\tif(r<=a || b<=l)return 0;\n\tif(a<=l && r<=b)return dat[k];\n\telse {\n\t\tll vl=query(a,b,k*2+1,l,(l+r)/2);\n\t\tll vr=query(a,b,k*2+2,(l+r)/2,r);\n\t\treturn max(vl,vr);\n\t}\n}\n\nint main(void){\n\t\n\tll in,m,ans=0;\n\t\n\tcin >> m;\n\t\n\tinit(m);\n\t\n\tfor(int i=0;i<m;i++){\n\t\tcin >> in;\n\t\tupdate(in,in+query(1,in+1,0,0,n));\n\t\t//ans=max(ans,dat[in+n-1]);\n\t}\n\tcout << m*(m+1)/2-query(1,m+1,0,0,n) << endl;\n\t\n\treturn 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include <algorithm>\n#include <cctype>\n#include <cmath>\n#include <cstdio>\n#include <cstdlib>\n#include <cstring>\n#include <cassert>\n#include <functional>\n#include <iostream>\n#include <iomanip>\n#include <iterator>\n#include <map>\n#include <queue>\n#include <set>\n#include <sstream>\n#include <utility>\n#include <vector>\n\nusing namespace std;\n\ntypedef long long Long;\n#define whole(xs) xs.begin(), xs.end()\n\nLong INF = 1LL<<52;\n\nLong N;\nvector<int> xs;\n\nbool input() {\n    cin >> N;\n    xs.resize(N);\n    for (int i = 0; i < N; i++) cin >> xs[i];\n    return true;\n}\n\nLong C(map<int, Long>& L, Long x) {\n    map<int, Long>::iterator it = L.lower_bound(x);\n    if (it == L.begin()) return -INF;\n    it--;\n    return it->second;\n}\n\nvoid D(map<int, Long>& L, Long x) {\n    map<int, Long>::iterator it1 = L.find(x);\n    assert(it1 != L.end());\n    map<int, Long>::iterator it = it1;\n    vector< map<int, Long>::iterator > del;\n    if (it != L.begin()) {\n        it1--;\n        if (it1->second >= it->second) {\n            del.push_back(it);\n        }\n    }\n    it1 = it;\n    it1++;\n    while (it1 != L.end() && it->second >= it1->second) {\n        del.push_back(it1);\n        it++;\n    }\n    for (int i = 0; i < del.size(); i++) {\n        L.erase(del[i]);\n    }\n}\n\nvoid solve() {\n    map<int, Long>* dp = new map<int, Long>[N + 1];\n    dp[0][0] = 0;\n    for (int i = 0; i < N; i++) {\n        int lb = 0, ub = N + 1;\n        while (lb + 1 < ub) {\n            int mid = (lb + ub) / 2;\n            Long r = C(dp[mid], xs[i]);\n            (r >= 0 ? lb : ub) = mid;\n        }\n        Long r = C(dp[lb], xs[i]) + xs[i];\n        dp[lb + 1][xs[i]] = r;\n        D(dp[lb + 1], xs[i]);\n    }\n    Long Ans = 0;\n    for (int i = 0; i <= N; i++) {\n        if (!dp[i].empty()) {\n            map<int, Long>::iterator it = dp[i].end();\n            it--;\n            Ans = max(Ans, it->second);\n        }\n    }\n    /*\n    for (int i = 0; i <= N; i++) {\n        for (map<int, int>::iterator it = dp[i].begin(); it != dp[i].end(); it++) {\n            cout << \"(\" << it->first << \", \" << it->second << \")\";\n        }\n        cout << endl;\n    }\n    */\n    cout << N * (N + 1) / 2 - Ans << endl;\n}\n\nint main() {\n    input(); solve();\n    return 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include <iostream>\n#include <algorithm>\n#include <vector>\n#include <queue>\n#include <cstring>\n#include <string>\n#include <cstdlib>\n#include <cstdio>\nusing namespace std;\ntypedef long long int ll;\nclass RMQ{\n\tprivate:\n\t\tvector<ll> val;\n\t\tint n;\n\tpublic:\n\t\tRMQ(int size){\n\t\t\tn=1;\n\t\t\twhile(n<size)n<<=1;\n\t\t\tval=vector<ll>(2*n,0);\n\t\t}\n\t\t//x 番目の要素を a に更新する\n\t\tvoid update(int x,ll a){\n\t\t\tx+=n-1;\n\t\t\tval[x]=a;\n\t\t\twhile(x>0){\n\t\t\t\tx=(x-1)/2;\n\t\t\t\tval[x]=max(val[x*2+1],val[x*2+2]);\n\t\t\t}\n\t\t}\n\t\t//a<=x<b\n\t\tll maximum(int a,int b,int k=0,int l=0,int r=-1){\n\t\t\tif(r==-1)r=n;\n\t\t\tif(r<=a||b<=l)return 0;\n\t\t\tif(a<=l&&r<=b){\n\t\t\t\treturn val[k];\n\t\t\t}else{\n\t\t\t\treturn max(maximum(a,b,k*2+1,l,(l+r)/2),maximum(a,b,k*2+2,(l+r)/2,r));\n\t\t\t}\n\t\t}\n};\nll n;\nmain(){\n\tint i,j;\n\twhile(cin >> n){\n\t\tRMQ dp(100010);\n\t\tfor(i=0;i<n;i++){\n\t\t\tll x;\n\t\t\tcin >> x;\n\t\t\tll res = dp.maximum(0, x);\n\t\t\tdp.update(x, res + x);\n\t\t}\n\t\tcout << (ll)n*(n+1)/2 - dp.maximum(0, n+1) << endl;\n\t}\n\treturn 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include <cstdio>\n#include <cstdlib>\n#include <cstring>\n#include <cmath>\n#include <climits>\n#include <cfloat>\n#include <ctime>\n#include <cassert>\n#include <map>\n#include <utility>\n#include <set>\n#include <iostream>\n#include <memory>\n#include <string>\n#include <vector>\n#include <algorithm>\n#include <functional>\n#include <sstream>\n#include <complex>\n#include <stack>\n#include <queue>\n#include <numeric>\n#include <list>\n#include <iomanip>\n   \nusing namespace std;\n   \n \n#ifdef __GNUC__\ntemplate <class T> int popcount(T n);\ntemplate <> int popcount(unsigned int n) { return __builtin_popcount(n); }\ntemplate <> int popcount(int n) { return __builtin_popcount(n); }\ntemplate <> int popcount(unsigned long long n) { return __builtin_popcountll(n); }\ntemplate <> int popcount(long long n) { return __builtin_popcountll(n); }\n#else\n#define __typeof__ decltype\ntemplate <class T> int popcount(T n) { return n ? 1 + popcount(n & (n - 1)) : 0; }\n#endif\n \n#define rep(i, n) for (int i = 0; i < (int)n; ++i)\n#define foreach(it, c) for (__typeof__((c).begin()) it=(c).begin(); it != (c).end(); ++it)\n#define rforeach(it, c) for (__typeof__((c).rbegin()) it=(c).rbegin(); it != (c).rend(); ++it)\n#define all(c) (c).begin(), (c).end()\n#define rall(c) (c).rbegin(), (c).rend()\n#define CL(arr, val) memset(arr, val, sizeof(arr))\n#define COPY(dest, src) memcpy(dest, src, sizeof(dest))\n   \ntemplate <class T> void max_swap(T& a, const T& b) { a = max(a, b); }\ntemplate <class T> void min_swap(T& a, const T& b) { a = min(a, b); }\n\ntemplate <class T> void sort(vector<T>& c) { sort(c.begin(), c.end()); }\ntemplate <class T> void unique(vector<T>& c) { sort(c.begin(), c.end()); c.erase(unique(c.begin(), c.end()), c.end()); }\n \ntypedef long long ll;\ntypedef pair<int, int> pint;\n   \ntemplate <class T, class U> ostream& operator<<(ostream& os, pair<T, U>& p) { os << \"( \" << p.first << \", \" << p.second << \" )\"; return os;  }\n  \ntemplate <class T> string to_s(const T& a) { ostringstream os; os << a; return os.str(); }\ntemplate <class T> T to_T(const string& s) { istringstream is(s); T res; is >> res; return res; }\n  \nbool valid(int x, int y, int w, int h) { return 0 <= x && x < w && 0 <= y && y < h; }\n   \ntemplate <class T> void print(T a, int n, const string& deli = \" \", int br = 1) { for (int i = 0; i < n; ++i) { cout << a[i]; if (i + 1 != n) cout << deli; } while (br--) cout << endl; }\ntemplate <class T> void print(const T& c, const string& deli = \" \", int br = 1) { foreach (it, c) { cout << *it; if (++it != c.end()) cout << deli;--it; } while (br--) cout << endl; }\ntemplate <class T> void print2d(T a, int w, int h, int width = -1, int br = 1) { for (int i = 0; i < h; ++i) { for (int j = 0; j < w; ++j) {    if (width != -1) cout.width(width); cout << a[i][j] << ' '; } cout << endl; } while (br--) cout << endl; }\n   \ntemplate <class T> void input(T& a, int n) { for (int i = 0; i < n; ++i) cin >> a[i]; }\ntemplate <class T, class U> void input(T& a, U& b, int n) { for (int i = 0; i < n; ++i) cin >> a[i] >> b[i]; }\n  \nconst int dx[] = { 0, 1, 0, -1 };\nconst int dy[] = { 1, 0, -1, 0 };\n  \nconst double PI = acos(-1.0);\nconst int mod = 1000000007;\n\n\n\n\nll node[262144 + 100];\nint size;\nvoid init(int n)\n{\n    size = 1;\n    while (size < n)\n        size *= 2;\n}\nvoid update(int k, ll a)\n{\n    k += size - 1;\n    node[k] = a;\n    while (k > 0)\n    {\n        k = (k - 1) / 2;\n        node[k] = max(node[2 * k + 1], node[2 * k + 2]);\n    }\n}\nll query(int a, int b, int k = 0, int l = 0, int r = ::size)\n{\n    if (r <= a || l >= b)\n        return 0;\n    else if (a <= l && r <= b)\n        return node[k];\n\n    ll left = query(a, b, 2 * k + 1, l, (l + r) / 2);\n    ll right = query(a, b, 2 * k + 2, (l + r) / 2, r);\n    return max(left, right);\n}\n\nint main()\n{\n    int n;\n    static int a[114514];\n    scanf(\"%d\", &n);\n    for (int i = 0; i < n; ++i)\n        scanf(\"%d\", a + i);\n\n    init(n + 1);\n    for (int i = 0; i < n; ++i)\n    {\n        ll max_seq = query(0, a[i]);\n        update(a[i], max_seq + a[i]);\n    }\n    ll max_seq = query(1, n + 1);\n    ll res = (ll)n * (n + 1) / 2 - max_seq;\n    printf(\"%lld\\n\", res);\n}"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\n \nusing namespace std;\n \n#define MAX 100010\nconst int MAX_N = 1<<17;\ntypedef long long ll;\n \nclass RMQ{\npublic:\n    ll n,dat[2*MAX_N-1];\n   \n    void init(int n_){\n\tn = 1;\n\twhile(n < n_){ n *= 2; }\n\tfor(int i = 0 ; i < 2*n-1 ; i++){\n\t    dat[i] = 0LL;\n\t}\n    }\n \n    void update(ll k,ll a){\n\tk += n - 1;\n\tdat[k] = a;\n\twhile(k > 0){\n\t    k = (k - 1) / 2;\n\t    dat[k] = max(dat[k*2+1],dat[k*2+2]);\n\t}\n    }\n \n    ll query(ll a,ll b,ll k,ll l,ll r){\n\tif(r <= a || b <= l) return 0LL;\n\tif(a <= l && r <= b){\n\t    return dat[k];\n\t}else{\n\t    ll vl = query(a,b,k*2+1,l,(l+r)/2);\n\t    ll vr = query(a,b,k*2+2,(l+r)/2,r);\n\t    return max(vl,vr);\n\t}\n    }\n};\n \nint main(){\n    ll N,x[MAX],sum = 0LL;\n    cin >> N;\n    for(int i = 0 ; i < N ; i++){\n\tcin >> x[i];\n\tsum += x[i];\n    }\n    RMQ rmq;\n    rmq.init(N);\n    for(int i = 0 ; i < N ; i++){\n\tll c = rmq.query(1,x[i]+1,0,0,rmq.n);\n\trmq.update(x[i],c+x[i]);\n    }\n    cout << sum-rmq.query(1,N+1,0,0,rmq.n) << endl;\n    return 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include<bits/stdc++.h>\n#define int long long\n#define PB push_back\n#define FI first\n#define SE second\nusing namespace std;\nstatic const int MAX_N = 1<<17;\nstatic const int inf = 1ll<<6;\ntypedef pair<int,int> PII;\n\nint N;\nvector<PII> V;\n\nclass Segment{\npublic:\n    int dp[2*MAX_N];\n    int n;\n\n    void init(int n_){\n        n=1;\n        while(n<n_)n*=2;\n        for(int i=0;i<2*n-1;++i)dp[i]=-inf;\n    }\n\n    void update(int k,int a){\n        k+=n-1;\n        dp[k]=a;\n        while(k>0){\n            k=(k-1)/2;\n            dp[k]=max(dp[2*k+1],dp[2*k+2]);\n        }\n    }\n\n    int query(int a,int b,int k,int l,int r){\n        if(r<=a||b<=l)return -inf;\n        if(a<=l&&r<=b)return dp[k];\n        else{\n            int vl=query(a,b,2*k+1,l,(l+r)/2);\n            int vr=query(a,b,2*k+2,(l+r)/2,r);\n            return max(vl,vr);\n        }\n    }\n};\n\nint res;\n\nsigned main(){\n    cin>>N;\n    Segment seg;\n    seg.init(N);\n    int MAX=N*(N+1)/2;\n    for(int i=0;i<N;++i){\n        int a;\n        cin>>a;\n        V.PB(PII(a,-i));\n    }\n    sort(V.begin(),V.end());\n    for(int i=0;i<N;++i){\n        int j=-V[i].SE;\n        seg.update(j,V[i].FI);\n        seg.update(j,max(seg.dp[j+seg.n-1],seg.query(0,j,0,0,seg.n)+V[i].FI));\n    }\n    cout<<MAX-seg.dp[0]<<endl;\n}"
  },
  {
    "language": "C++",
    "code": "#include <iostream>\n#include <algorithm>\n\nusing namespace std;\n\n#define ll long long\n#define rep(a,b) for(int a = 0; a < b; a++)\n\nint n;\nll dp[100001*2];\nint arr[100000];\nint size = 1;\n\nvoid update(int index, ll num) {\n  index += size-1;\n  dp[index] = num;\n  //cout << \"  \" << index << \",\" << dp[index] << endl;\n  while(index>0) {\n    int new_index = (index-1)>>1;\n    dp[new_index] = max(dp[(new_index<<1)+1],dp[(new_index<<1)+2]);\n    //cout << \"  \" << new_index << \",\" << dp[new_index] << endl;\n    index = new_index;\n  }\n  //dp[index] = max(dp[index],dp[index^1]);\n}\n\nll get_max(int a, int b, int k, int left, int right) {\n  //cout << \"gmax \" << a << \",\" << b << \",\" << k << \",\" << left << \",\" << right << endl;\n  if(right<a||b<=left||right<=left) return 0;\n  if(a<=left&&right<=b) {\n    //cout << \"OK \" << dp[k] << endl;\n    return dp[k];\n  }\n  ll ret = 0;\n  ret = max(ret,get_max(a,b,(k<<1)+1,left,(left+right)>>1));\n  ret = max(ret,get_max(a,b,(k<<1)+2,(left+right+1)>>1,right));\n  return ret;\n}\n\nint main() {\n  cin >> n;\n  for(int i = 1; i < n; i<<=1) size<<=1;\n  rep(i,n) cin >> arr[i];\n  rep(i,n) {\n    int num = arr[i];\n    ll _max = get_max(0,num,0,0,size);\n    //cout << num << \",\" << _max << endl;\n    update(num,_max+num);\n  }\n  ll ans = (ll)n;\n  ans = n*(n+1)/2;\n  //for(int i = 0; i < size<<1; i++) cout << dp[i] << endl;\n  cout << ans-dp[0];\n}\n\n"
  },
  {
    "language": "C++",
    "code": "#include <iostream>\n#include <cmath>\n#include <algorithm>\n\nusing namespace std;\n\ntypedef long long int ll;\n\nconst int N = 1 << 17;\nll dat[N * 2 - 1] = { 0 }, n, m;\n\nvoid update(int i, ll val) {\n\ti += m - 1;\n\tdat[i] = val;\n\twhile(i > 0) {\n\t\ti = (i - 1) / 2;\n\t\tdat[i] = max(dat[i * 2 + 1], dat[i * 2 + 2]);\n\t}\n\treturn;\n}\n\nll getval(int a, int b, int k, int l, int r) {\n\tif (r <= a || b <= l) return 0;\n\tif (a <= l && r <= b) return dat[k];\n\telse{\n\t\tll vl = getval(a, b, k * 2 + 1, l, (l + r) / 2);\n\t\tll vr = getval(a, b, k * 2 + 2, (l + r) / 2, r);\n\t\treturn max(vl, vr);\n\t}\n}\n\nint main(){\n\tint a, v;\n\tdouble p, ip = 0.0, fp;\n\tcin >> n;\n\tp = log2(n);\n\tfp = modf(p, &ip);\n\tif(fp == 0.0) {\n\t\tm = 1 << int(p);\n\t}\n\telse{\n\t\tm = 1 << (int(p) + 1);\n\t}\n\tfor(int i = 0;i < n;++i){\n\t\tcin >> a;\n\t\tv = getval(0, a, 0, 0, m);\n\t\tupdate(a - 1, a + v); // 0-indexedにしたいので\n\t}\n\tcout << n * (n + 1) / 2 - dat[0] << endl;\n\treturn 0;\n}\n\n"
  },
  {
    "language": "C++",
    "code": "#include <iostream>\n#include <vector>\n#include <map>\n#include <tuple>\n#include <climits>\n#include <algorithm>\nusing namespace std;\n\nconst int MAX_N = 1<<17;\n\nint n;\nint64_t dat[2*MAX_N-1];\n\nvoid init(int n_){\n    n = 1;\n    while(n<n_)n*=2;\n    for(int i=0;i<2*n-1;i++) dat[i]=LLONG_MAX;\n}\n\n//0-indexed, k-th to a\nvoid update(int k, int64_t a){\n    k+=n-1;\n    dat[k]=a;\n    while(k>0){\n        k=(k-1)/2;\n        dat[k]=min(dat[k*2+1],dat[k*2+2]);\n    }\n}\n\n//[a,b)???????°????\nint64_t query(int a, int b, int k=0, int l=0, int r=n){\n    if(r<=a||b<=l) return LLONG_MAX;\n    if(a<=l&&r<=b) return dat[k];\n    else{\n        int64_t vl = query(a,b,k*2+1,l,(l+r)/2);\n        int64_t vr = query(a,b,k*2+2,(l+r)/2,r);\n        return min(vl,vr);\n    }\n}\n\nusing P = pair<int,int>;\n\nint main(){\n    int N;\n    cin>>N;\n    vector<P> V;\n    vector<int> X;\n    for(int i=0;i<N;i++){\n        int x;\n        cin>>x;\n        V.emplace_back(x,i);\n        X.push_back(x);\n    }\n    sort(V.begin(), V.end());\n    vector<int> nth(N);\n    for(int i=0;i<N;i++){\n        nth[V[i].second]=i;\n    }\n    init(N);\n    for(int i=0;i<N;i++){\n        update(i,0);\n    }\n    for(int i=0;i<N;i++){\n        int64_t sum = -X[i];\n        if(nth[i]){\n            sum+=query(0,nth[i]);\n        }\n        update(nth[i],sum);\n    }\n    int64_t ans = 0;\n    for(auto x:X) ans+=x;\n    ans+=query(0,N);\n    cout<<ans<<endl;\n\n    return 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include<cstdio>\n#include<algorithm>\n\n#define rep(i,n) for(int i=0;i<(n);i++)\n\nusing namespace std;\n\ntypedef long long ll;\n\ntemplate<class T>\nclass segment_tree_RMQ{\n\tstatic const int N_MAX=100001;\n\tint n;\n\tT dat[2*N_MAX];\n\n\tT query(int l,int r,int a,int b,int u){\n\t\tif(l<=a && b<=r) return dat[u];\n\n\t\tT res=0;\n\t\tint c=(a+b+1)/2;\n\t\tif(l<c && a<r) res=max(res,query(l,r,a,c,2*u));\n\t\tif(l<b && c<r) res=max(res,query(l,r,c,b,2*u+1));\n\t\treturn res;\n\t}\n\npublic:\n\tvoid build(int N,int val){\n\t\tfor(n=1;n<N;n*=2);\n\t\trep(i,2*n) dat[i]=val;\n\t}\n\n\tvoid update(int x,T v){\n\t\tx+=n;\n\t\tdat[x]=v;\n\t\tfor(x/=2;x>=1;x/=2) dat[x]=max(dat[2*x],dat[2*x+1]);\n\t}\n\n\tT query(int l,int r){ return query(l,r,0,n,1); }\n};\n\nint main(){\n\tint n; scanf(\"%d\",&n);\n\tint x[100000];\n\trep(i,n) scanf(\"%d\",x+i);\n\n\tsegment_tree_RMQ<int> S;\n\tS.build(n+1,0);\n\trep(i,n){\n\t\tint cost=S.query(0,x[i]);\n\t\tS.update(x[i],cost+x[i]);\n\t}\n\n\tprintf(\"%lld\\n\",(ll)n*(n+1)/2-S.query(1,n+1));\n\n\treturn 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include<iostream>\n#include<vector>\n#include<algorithm>\n#include<iomanip>\n#include<sstream>\n#include<map>\n#include<queue>\n#include<complex>\nusing namespace std;\nvector<int> dat;\nint sz;\nvoid init(int n) {\n\tsz = 1;\n\twhile (sz < n)sz *= 2;\n\tdat.clear();\n\tdat.resize(2 * sz, 0);\n}\nvoid update(int k, int a) {\n\tk += sz - 1;\n\tdat[k] = a;\n\twhile (k > 0) {\n\t\tk = (k - 1) / 2;\n\t\tdat[k] = max(dat[k * 2 + 1], dat[k * 2 + 2]);\n\t}\n}\nint query(int a, int b, int k, int l, int r) {\n\tif (r <= a || b <= l)return 0;\n\tif (a <= l && r <= b)return dat[k];\n\tint m = (l + r) / 2;\n\tint vl = query(a, b, 2 * k + 1, l, m);\n\tint vr = query(a, b, 2 * k + 2, m, r);\n\treturn max(vl, vr);\n}\nint query(int a, int b) {\n\treturn query(a, b, 0, 0, sz);\n}\nint N;\nsigned main() {\n\tcin >> N;\n\tvector<int> A(N);\n\tfor (int i = 0; i < N; i++) {\n\t\tint a;\n\t\tcin >> a;\n\t\ta--;\n\t\tA[a] = i;\n\t}\n\tinit(N);\n\tint res = 0;\n\tfor (int i = 0; i < N; i++) {\n\t\tint mx = query(0, A[i]);\n\t\t//cerr << i << \" \" << A[i] << \" \" << mx << endl;\n\t\tupdate(A[i], mx + i + 1);\n\t\tres = max(res, mx + i + 1);\n\t}\n\tcout << (((N + 1)*N) / 2) - res << endl;\n}\n"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\nusing namespace std;\n\n#define for_(i,a,b) for(int i=(a);i<(b);++i)\n#define for_rev(i,a,b) for(int i=(a);i>=(b);--i)\n\ntypedef long long lint;\n\ntemplate< typename DATA >\nclass SegmentTree {\nprivate:\n\tint size__;\n\tvector< DATA > data;\n\t\n\tinline int left_t(int k) {\n\t\treturn (k << 1) + 1;\n\t}\n\t\n\tinline int right_t(int k) {\n\t\treturn (k << 1) + 2;\n\t}\n\t\n\tinline int center(int l, int r) {\n\t\treturn (l + r) >> 1;\n\t}\n\t\npublic:\n\tSegmentTree(int n, DATA ini) {\n\t\tfor (size__ = 1; size__ < n; size__ <<= 1);\n\t\tdata.assign(2 * size__ - 1, ini);\n\t}\n\t\n\tDATA calc(DATA d1, DATA d2) {\n\t\treturn max(d1, d2);\n\t}\n\t\n\tvoid update(int k, DATA a) {\n\t\tk += size__ - 1;\n\t\tdata[k] = a;\n\t\t\n\t\twhile (k > 0) {\n\t\t\tk = (k - 1) >> 1;\n\t\t\tdata[k] = calc(data[left_t(k)], data[right_t(k)]);\n\t\t}\n\t}\n\t\n\tDATA query(int a, int b) {\n\t\treturn query(a, b, 0, 0, size__);\n\t}\n\t\n\tDATA query(int a, int b, int k, int l, int r) {\n\t\tif (r <= a || b <= l) return 0;\n\t\tif (a <= l && r <= b) return data[k];\n\t\treturn calc(query(a, b, left_t(k), l, center(l, r)),\n\t\t\t\t\tquery(a, b, right_t(k), center(l, r), r));\n\t}\n\t\n\tint size() {\n\t\treturn size__;\n\t}\n};\n\nint n, x[100010];\n\nsigned main() {\n\tcin >> n;\n\tfor_(i,0,n) cin >> x[i];\n\t\n\tSegmentTree< lint > st(n + 1, 0);\n\tfor_(i,0,n) st.update(x[i], x[i] + st.query(0, x[i]));\n\tcout << n * (n + 1) / 2 - st.query(0, n + 1) << endl;\n}"
  },
  {
    "language": "C++",
    "code": "#include<bits/stdc++.h>\n#define MAX 100001\nusing namespace std;\nint n,p,A[MAX*4],N;\nvoid Segtree(int n_){\n  n=1;\n  while(n<n_)n*=2;\n}\nvoid update(int k,int x){\n  k+=n-1;\n  A[k]=x;\n  while(k>0){\n    k=(k-1)/2;\n    A[k]=max(A[k*2+1],A[k*2+2]);\n  }\n}\nint find(int a,int b,int k,int l,int r){\n  if(r<=a||b<=l)return 0;\n  if(a<=l&&r<=b)return A[k];\n  int v1=find(a,b,k*2+1,l,(l+r)/2);\n  int v2=find(a,b,k*2+2,(l+r)/2,r);\n  return max(v1,v2);\n}\nint main(){\n  cin>>n;\n  N=n;\n  Segtree(n+1);\n  for(int i=0;i<N;i++){\n    scanf(\"%d\",&p);\n    int v=find(0,p,0,0,n);\n    update(p,v+p);\n  }\n  cout<<N*(N+1)/2-find(0,N+1,0,0,n)<<endl;\n}"
  },
  {
    "language": "C++",
    "code": "#include <iostream>\n#include <vector>\nusing namespace std;\n\ntypedef long long ll;\n\n// index : 1 - n\nstruct BIT {\n    typedef ll cont_type;\n    vector<cont_type> ary;\n    BIT(int n) { ary.assign(n, 0); }\n\n    void update(int idx,cont_type val) {\n        for(; idx < ary.size(); idx |= idx+1)\n            ary[idx] = max(ary[idx], val);\n    }\n\n    cont_type get(int x) const {\n        cont_type ret = 0;\n        for(; x >= 0; x = (x & (x+1)) -1)\n            ret = max(ary[x], ret);\n        return ret;\n    }\n};\n\nint main() {\n    int n;\n    cin>>n;\n    vector<int> x(n);\n    for(int i=0; i<n; ++i) cin>>x[i];\n\n    BIT bit(n);\n    ll ans = 0;\n    for(int i=0; i<n; ++i) {\n        ll p = bit.get(x[i]-1)+x[i];\n        ans = max(ans, p);\n        bit.update(x[i]-1, p);\n    }\n\n    ll ln = n;\n    cout<<(ln*(ln+1))/2-ans<<endl;\n}"
  },
  {
    "language": "C++",
    "code": "#include \"bits/stdc++.h\"\n#define int long long\n#define rep(i, n) for (int i = 0; i < (int)(n); i++)\n#define REP(i, a, b) for (int i = (int)(a); i < (int)(b); i++)\n#define FOR(i, a) for (auto &i: a)\n#define ALL(obj) begin(obj), end(obj)\n#define MAX(x) *max_element(ALL(x))\n#define MIN(x) *min_element(ALL(x))\n#define SUM(x) accumulate(ALL(x), 0LL)\n#define LOWER_BOUND(A, key) distance(A.begin(), lower_bound(ALL(A), key))\n#define UPPER_BOUND(A, key) distance(A.begin(), upper_bound(ALL(A), key))\n\nusing namespace std;\nconst int MOD    = (int)(1e9 + 7);\nconst int INF    = (int)(1e13 + 7);\nconst double EPS = 1e-14;\nconst double PI  = acos(-1);\n\nint CEIL(int a, int b) { return (a >= 0 ? (a + (b - 1)) / b : (a - (b - 1)) / b); } //ceil() for int\nint mod(int a, int b) { return a >= 0 ? a % b : a - (b * CEIL(a, b)); }             //always return positive num\nint bpm(int a, int b) {                                                             //return x^y in order(log(y))\n  int res = 1;\n  for (a %= MOD; b; a = a * a % MOD, b >>= 1)\n    if (b & 1) res = res * a % MOD;\n  return res;\n}\n\n// 最大値のquery\ntemplate<class T>\nstruct SegmentTree {\nprivate:\n  int n    = 1;\n  int init = -INF;\n  vector<T> data;\n\npublic:\n  SegmentTree(vector<T> &v) {\n    while (n < v.size()) n *= 2;\n    data.assign(2 * n - 1, init);\n    for (int i = 0; i < v.size(); i++) data[i + n - 1] = v[i];\n    for (int i = n - 2; i >= 0; i--) data[i] = max(data[2 * i + 1], data[2 * i + 2]);\n  }\n  void update(int ind, T val) {\n    ind += n - 1;\n    data[ind] = val;\n    while (ind > 0) {\n      ind       = (ind - 1) / 2;\n      data[ind] = max(data[2 * ind + 1], data[2 * ind + 2]);\n    }\n  }\n  T at(int ind) { return data[n - 1 + ind]; }\n  T operator[](int ind) { return data[n - 1 + ind]; }\n  T query(int L, int R, int k = 0, int l = 0, int r = -1) { // [L, R\n    if (r < 0) r = n;\n    if (r <= L || R <= l) return init;\n    if (L <= l and r <= R) return data[k];\n    return max(query(L, R, 2 * k + 1, l, (l + r) / 2), query(L, R, 2 * k + 2, (l + r) / 2, r));\n  }\n};\n\nsigned main() {\n  cin.tie(0);\n  ios::sync_with_stdio(false);\n  int n;\n  cin >> n;\n  vector<int> x(n);\n  rep(i, n) cin >> x[i];\n  vector<int> temp(n, 0);\n  SegmentTree<int> seg(temp);\n  rep(i, n) seg.update(x[i] - 1, seg.query(0, x[i]) + x[i]);\n  cout << SUM(x) - seg.query(0, n) << endl;\n}\n"
  },
  {
    "language": "C++",
    "code": "#include <stdio.h>\n#include <algorithm>\nusing namespace std;\nint n, a[100000], b[100000]; long long sum, ret, dp[100001], rmq[262144];\nvoid update(int i, long long x) { i += 131072; rmq[i] = x; while (i > 1) i /= 2, rmq[i] = max(rmq[i * 2], rmq[i * 2 + 1]); }\nlong long query(int p, int q, int k, int l, int r) {\n\tif (r <= p || q <= l) return 0;\n\tif (p <= l && r <= q) return rmq[k];\n\tlong long vl = query(p, q, 2 * k, l, (l + r) / 2);\n\tlong long vr = query(p, q, 2 * k + 1, (l + r) / 2, r);\n\treturn max(vl, vr);\n}\nint main() {\n\tscanf(\"%d\", &n);\n\tfor (int i = 0; i < n; i++) scanf(\"%d\", &a[i]), sum += a[i], b[a[i] - 1] = i;\n\tfor (int i = 1; i <= n; i++) {\n\t\tupdate(a[i - 1] - 1, dp[i] = query(0, a[i - 1], 1, 0, 131072) + a[i - 1]);\n\t\tret = max(ret, dp[i]);\n\t}\n\tprintf(\"%lld\\n\", sum - ret);\n\treturn 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include <iostream>\n#include <cmath>\n#include <algorithm>\n\nusing namespace std;\n\nconst int N = 1 << 17;\nint dat[N * 2 - 1] = { 0 }, n, m;\n\nvoid update(int i, int val) {\n\ti += m - 1;\n\tdat[i] = val;\n\twhile(i > 0) {\n\t\ti = (i - 1) / 2;\n\t\tdat[i] = max(dat[i * 2 + 1], dat[i * 2 + 2]);\n\t}\n\treturn;\n}\n\nint getval(int a, int b, int k, int l, int r) {\n\tif (r <= a || b <= l) return 0;\n\tif (a <= l && r <= b) return dat[k];\n\telse{\n\t\tint vl = getval(a, b, k * 2 + 1, l, (l + r) / 2);\n\t\tint vr = getval(a, b, k * 2 + 2, (l + r / 2), r);\n\t\treturn max(vl, vr);\n\t}\n}\n\nint main(){\n\tint a, v;\n\tdouble p, ip = 0.0, fp;\n\tcin >> n;\n\tp = log2(n);\n\tfp = modf(p, &ip);\n\tif(fp == 0.0) {\n\t\tm = 1 << int(p);\n\t}\n\telse{\n\t\tm = 1 << (int(p) + 1);\n\t}\n\tfor(int i = 0;i < n;++i){\n\t\tcin >> a;\n\t\tv = getval(0, a, 0, 0, m);\n\t\tupdate(a - 1, a + v); // 0-indexedにしたいので\n\t}\n\tcout << n * (n + 1) / 2 - dat[0] << endl;\n\treturn 0;\n}\n\n"
  },
  {
    "language": "C++",
    "code": "#include<iostream>\n#include<vector>\nusing namespace std;\n\nint main(){\n  long n,x,sum=0;\n  vector<long> v;\n  cin>>n;\n  for(long i=0;i<n;i++){\n    cin>>x;\n    v.push_back(x);\n    sum+=x;\n  }\n\n  long dp[v.size()]={},res=0;\n  for(long i=0;i<v.size();i++){\n    dp[i]=v[i];\n    for(long j=0;j<i;j++){\n      if(v[j]<v[i]){\n        dp[i]=max(dp[i],dp[j]+v[i]);\n      }\n    }\n    res=max(res,dp[i]);\n  }\n  cout<<sum-res<<endl;\n  return 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include <iostream>\n#include <iomanip>\n#include <sstream>\n#include <cstdio>\n#include <cstdlib>\n#include <cstring>\n#include <cmath>\n#include <climits>\n#include <cfloat>\n#include <vector>\n#include <string>\n#include <stack>\n#include <queue>\n#include <set>\n#include <map>\n#include <algorithm>\n#include <functional>\n#include <utility>\n#include <numeric>\n#include <iterator>\n\nusing namespace std;\n\ntypedef long long LL;\ntypedef unsigned long long ULL;\ntypedef vector<int> VI;\ntypedef vector<VI> VVI;\ntypedef vector<string> VS;\ntypedef pair<int,int> PII;\ntypedef vector<PII> VPII;\ntypedef istringstream ISS;\ntypedef ostringstream OSS;\n\n#define REP( i, m, n ) for ( int i = (int)( m ); i < (int)( n ); ++i )\n#define FOR( v, c ) for ( auto &v : c )\n#define EACH( it, c ) for ( auto it = c.begin(); it != c.end(); ++it )\n#define ALL( c ) (c).begin(), (c).end()\n#define DRANGE( c, p ) (c).begin(), (c).begin() + p, (c).end()\n\n#define PB( n ) push_back( n )\n#define MP( a, b ) make_pair( ( a ), ( b ) )\n#define EXIST( c, e ) ( (c).find( e ) != (c).end() )\n\n#define fst first\n#define snd second\n\n#define DUMP( x ) cerr << #x << \" = \" << ( x ) << endl\n#define DEBUG( x ) cerr << __FILE__ << \":\" << __LINE__ << \": \" << #x << \" = \" << ( x ) << endl\n\nconst LL INF = LLONG_MAX / 4;\n\n// セグメント木のユーティリティ\ninline const int chl( const int k )\n{\n\treturn k * 2 + 1;\n}\n\ninline const int chr( const int k )\n{\n\treturn k * 2 + 2;\n}\n\ninline const int mid( const int l, const int r )\n{\n\treturn ( l + r ) / 2;\n}\n\n// セグメント木による Range Maximum Query\ntemplate < typename T >\nclass RangeMaximumQuery\n{\nprivate:\n\tconst int N;\n\tvector<T> data;\n\npublic:\n\tRangeMaximumQuery( const vector<T> &src ) : N( src.size() ), data( N * 4 )\n\t{\n\t\tREP( i, 0, N )\n\t\t{\n\t\t\tupdate( i, src[i] );\n\t\t}\n\t\treturn;\n\t}\n\n\tvoid update( const int p, const T x )\n\t{\n\t\treturn update( p, x, 0, 0, N );\n\t}\n\n\tT maximum( const int a, const int b ) const\n\t{\n\t\treturn maximum( a, b, 0, 0, N );\n\t}\nprivate:\n\tvoid update( const int p, const T x, const int k, const int l, const int r )\n\t{\n\t\tif ( p < l || r <= p )\n\t\t{\n\t\t\treturn;\n\t\t}\n\t\tif ( l + 1 == r && p == l )\n\t\t{\n\t\t\tdata[k] = x;\n\t\t\treturn;\n\t\t}\n\n\t\tupdate( p, x, chl( k ), l, mid( l, r ) );\n\t\tupdate( p, x, chr( k ), mid( l, r ), r );\n\t\tdata[k] = max( data[ chl( k ) ], data[ chr( k ) ] );\n\t\n\t\treturn;\n\t}\n\n\tT maximum( const int a, const int b, const int k, const int l, const int r ) const\n\t{\n\t\tif ( b <= l || r <= a )\n\t\t{\n\t\t\treturn LLONG_MIN;\n\t\t}\n\t\telse if ( a <= l && r <= b )\n\t\t{\n\t\t\treturn data[k];\n\t\t}\n\t\telse\n\t\t{\n\t\t\treturn max( maximum( a, b, chl( k ), l, mid( l, r ) ), maximum( a, b, chr( k ), mid( l, r ), r ) );\n\t\t}\n\t}\n};\n// RangeMaximumQuery( VI src )\n// update( pos, x )\n// maximum( [ a, b ) )\n\nint main()\n{\n\tcin.tie( 0 );\n\tios::sync_with_stdio( false );\n\n\tLL n;\n\tcin >> n;\n\n\tVI xs( n );\n\tREP( i, 0, n )\n\t{\n\t\tcin >> xs[i];\n\t}\n\n\tRangeMaximumQuery<LL> rmq( vector<LL>( n + 1, -INF ) );\n\trmq.update( 0, 0 );\n\n\tREP( i, 0, n )\n\t{\n\t\trmq.update( xs[i], rmq.maximum( 0, xs[i] ) + xs[i] );\n\t}\n\n\tcout << n * ( n + 1 ) / 2 - rmq.maximum( 0, n + 1 ) << endl;\n\n\treturn 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include <iostream>\n#include <sstream>\n#include <string>\n#include <algorithm>\n#include <vector>\n#include <stack>\n#include <queue>\n#include <set>\n#include <map>\n#include <cstdio>\n#include <cstdlib>\n#include <cstring>\n#include <cmath>\n#include <cassert>\n\nusing namespace std;\n\n#define FOR(i,k,n) for(int i=(k); i<(int)(n); ++i)\n#define REP(i,n) FOR(i,0,n)\n#define FORIT(i,c) for(__typeof((c).begin())i=(c).begin();i!=(c).end();++i)\n\ntemplate<class T> void debug(T begin, T end){ for(T i = begin; i != end; ++i) cerr<<*i<<\" \"; cerr<<endl; }\ninline bool valid(int x, int y, int W, int H){ return (x >= 0 && y >= 0 && x < W && y < H); }\n\ntypedef long long ll;\nconst int INF = 100000000;\nconst double EPS = 1e-8;\nconst int MOD = 1000000007;\nint dx[8] = {1, 0, -1, 0, 1, -1, -1, 1};\nint dy[8] = {0, 1, 0, -1, 1, 1, -1, -1};\ntemplate <class T>\nclass BIT{\n  vector<T> data;\n  public:\n  BIT(int n) : data(n) { }\n  BIT(vector<T> x) : data(x.size()) {\n    for(int i = 0; i < x.size(); i++){\n      add(i, x[i]);\n    }\n  }\n  // v[left] + v[left + 1] + ... + v[right]\n  T sum(int left, int right) {\n    if (left == 0) {\n      T S = 0;\n      while(right >= 0){\n        S += data[right];\n        right = ((right & (right + 1)) - 1);\n      }\n      return S;\n    } else return sum(0, right) - sum(0, left - 1);\n  }\n  // v[k] += a;\n  void add(int k, T a) {\n    while(k < data.size()){\n      data[k] += a;\n      k |= k + 1;\n    }\n  }\n};\n\nint main(){\n  int N;\n  cin>>N;\n  vector<int> x(N);\n  REP(i, N) cin >> x[i];\n  int cur = 1;\n  ll ans = 0;\n  BIT<int> bit(N + 1);\n  REP(i, N) bit.add(i + 1, i + 1);\n  REP(i, N){\n    if(x[i] <= cur){\n      cur = max(cur, x[i] + 1);\n    }else{\n      int sum = bit.sum(cur, x[i] - 1); // [cur, x - 1]\n      if(sum <= x[i]){\n        ans += sum;\n        cur = x[i] + 1;\n      }else{\n        bit.add(x[i], -x[i]);\n        ans += x[i];\n      }\n    }\n  }\n  cout << ans << endl;\n  return 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\nusing namespace std;\n\n#define for_(i,a,b) for(int i=(a);i<(b);++i)\n#define for_rev(i,a,b) for(int i=(a);i>=(b);--i)\n\ntypedef long long lint;\n\ntemplate< typename DATA >\nclass SegmentTree {\nprivate:\n\tint size__;\n\tvector< DATA > data;\n\t\n\tinline int left_t(int k) {\n\t\treturn (k << 1) + 1;\n\t}\n\t\n\tinline int right_t(int k) {\n\t\treturn (k << 1) + 2;\n\t}\n\t\n\tinline int center(int l, int r) {\n\t\treturn (l + r) >> 1;\n\t}\n\t\npublic:\n\tSegmentTree(int n, DATA ini) {\n\t\tfor (size__ = 1; size__ < n; size__ <<= 1);\n\t\tdata.assign(2 * size__ - 1, ini);\n\t}\n\t\n\tDATA calc(DATA d1, DATA d2) {\n\t\treturn max(d1, d2);\n\t}\n\t\n\tvoid update(int k, DATA a) {\n\t\tk += size__ - 1;\n\t\tdata[k] = a;\n\t\t\n\t\twhile (k > 0) {\n\t\t\tk = (k - 1) >> 1;\n\t\t\tdata[k] = calc(data[left_t(k)], data[right_t(k)]);\n\t\t}\n\t}\n\t\n\tDATA query(int a, int b) {\n\t\treturn query(a, b, 0, 0, size__);\n\t}\n\t\n\tDATA query(int a, int b, int k, int l, int r) {\n\t\tif (r <= a || b <= l) return 0;\n\t\tif (a <= l && r <= b) return data[k];\n\t\treturn calc(query(a, b, left_t(k), l, center(l, r)),\n\t\t\t\t\tquery(a, b, right_t(k), center(l, r), r));\n\t}\n\t\n\tint size() {\n\t\treturn size__;\n\t}\n};\n\nint n, x[100010];\n\nsigned main() {\n\tcin >> n;\n\tfor_(i,0,n) cin >> x[i];\n\t\n\tSegmentTree< lint > st(n + 10, 0);\n\tfor_(i,0,n) st.update(x[i], x[i] + st.query(0, x[i] + 1));\n\tcout << n * (n + 1) / 2 - st.query(0, n + 1) << endl;\n}"
  },
  {
    "language": "C++",
    "code": "#include<iostream>\n#include<algorithm>\n#include<cstring>\nusing namespace std;\ntypedef long long ll;\n\nll seg[1<<20];\nint V;\n\nvoid init(int n){\n  V = 1;\n  while(n>V)V<<=1;\n  memset(seg,0,sizeof(seg));\n}\n\nll set(int p, ll v){\n  int cur = V-1 + p;\n  seg[cur] = v;\n  while(cur){\n    cur = (cur-1)/2;\n    if(seg[cur] >= v)break;\n    seg[cur] = v;\n  }\n  return v;\n}\n\nll get(int a, int b, int k, int l, int r){\n  if(r<=a || b<=l)return 0;\n  if(a<=l && r<=b)return seg[k];\n  ll vl = get(a,b,2*k+1,l,(l+r)/2);\n  ll vr = get(a,b,2*k+2,(l+r)/2,r);\n  return max(vl,vr);\n}\n\nll n,a[100100];\n\nint main(){\n  cin >> n;\n  for(int i=0;i<n;i++)cin >> a[i];\n\n  init(n);\n  ll res = 0;\n  for(int i=0;i<n;i++){\n    res = max(res,set(a[i]-1,get(0,a[i]-1,0,0,V) + a[i]));\n  }\n\n  cout << n*(n+1)/2 - res << endl;\n}"
  },
  {
    "language": "C++",
    "code": "#include<bits/stdc++.h>\nusing namespace std;\ntypedef long long ll;\n\nstruct seg {\n  ll d[(1<18)];\n  int n;\n  \n  void init(int _n){\n    n = 1;\n    while( n < _n ) n*=2;\n    memset(d,0,sizeof(d));\n  }\n  \n  ll query(int a,int b,int k,int l,int r){\n    if( r <= a || b <= l ) return 0;\n    else if( a <= l && r <= b ) return d[k];\n    ll vl = query( a, b, 2*k+1, l, (l+r)/2 );\n    ll vr = query( a, b, 2*k+2, (l+r)/2, r );\n    return max( vl, vr );\n  }\n\n  ll query(int a,int b){\n    return query( a, b, 0, 0, n );\n  }\n  \n  void set(int k,ll x) {\n    k += n-1;\n    d[k] = x;\n    while( k > 0 ){\n      k = (k-1)/2;\n      d[k] = max( d[2*k+1], d[2*k+2] );\n    }\n  }\n};\ntypedef pair<ll,int> P;\n\nseg S;\nint N;\nll X[100005];\nP p[100005];\nint main(){\n  cin >> N;  S.init( N );\n  for(int i=0;i<N;i++){\n    cin >> X[i];\n    p[i] = P(X[i],i);\n  }\n  sort( p, p+N );\n  ll res = 0;\n  for(int i=N-1;i>-1;i--){\n    int k = p[i].second;\n    ll num = S.query( k, N );\n    res = max( res, num + p[i].first );\n    S.set( k, num+p[i].first );\n  }\n  cout << N*(N+1)/2 - res << endl;\n  \n}"
  },
  {
    "language": "C++",
    "code": "#include <iostream>\n#include <vector>\n#define ll long long \nusing namespace std;\nll int INF = 100000000000;\nstruct SegmentTree{\nprivate:\n  int n;\n  vector<ll int> node;\npublic:\n  SegmentTree(vector<ll int> v){\n    int sz = v.size();\n    n = 1; while(n < sz) n *= 2;\n    node.resize(2*n-1,0);\n    for(int i = 0; i < sz; ++i) node[i+n-1] = v[i];\n    for(int i = n-2; i >= 0; --i) node[i] = max(node[2*i+1],node[2*i+2]);\n  }\n  void update(int x, ll int val){\n    x += (n-1);\n    node[x] = val;\n    while(x > 0){\n      x = (x-1)/2;\n      node[x] = max(node[2*x+1],node[2*x+2]);\n    }\n  }\n  ll int getmax(int a, int b, int k = 0, int l = 0, int r = -1){\n    if(r < 0) r = n;\n    if(r <= a || b <= l) return 0LL;\n    if(a <= l && r <= b) return node[k];\n    int vl = getmax(a,b,2*k+1,l,(l+r)/2);\n    int vr = getmax(a,b,2*k+2,(l+r)/2,r);\n    return max(vl,vr);\n  }\n};\nsigned main(){\n//int main(){\n  int n;\n  ll int s = 0LL;\n  cin >> n;\n  vector<ll int> x(n);\n  for(int i = 0; i < n; ++i){\n    cin >> x[i];\n    s += x[i];\n  }\n  SegmentTree st(vector<ll int>(n+1,0));\n  for(int i = 0; i < n; ++i){\n    ll int t = st.getmax(0,x[i]);\n    //cout << x[i] << \" \" << t << endl;\n    st.update(x[i],t+x[i]);\n  }\n\n  cout << s - st.getmax(0,n+1) << endl;\n  return 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include<iostream>\n#include<algorithm>\n#include<vector>\n#include<unordered_map>\nusing namespace std;\ntypedef long long ll;\ntypedef pair<ll,ll> P;\n#define N 100010\nclass Segtree{\n  public:\n  ll dat[2*N];\n  void init(){\n    for(int i=0;i<2*N;i++)dat[i]=0;\n  }\n  void upd(ll i,ll val){\n    i+=N; dat[i]=val;\n    for(;i;i>>=1)dat[i/2]=max(dat[i],dat[i^1]);\n  }\n  ll qry(ll l,ll r){\n    l+=N,r+=N;\n    ll res=0;\n    for(ll a=l,b=r;a<b;a>>=1,b>>=1){\n      if(a&1)res=max(res,dat[a++]);\n      if(b&1)res=max(res,dat[--b]);\n    }\n    return res;\n  }\n};Segtree seg;\nll n,a[N],b[N];\nvector<P> v;\nvoid zaats(){\n  for(int i=0;i<n;i++)v.push_back(make_pair(a[i],i));\n  sort(v.begin(),v.end());\n  for(int i=0;i<n;i++)b[v[i].second]=i;\n}\nint main(){\n  cin>>n;\n  for(int i=0;i<n;i++)cin>>a[i];\n  zaats();\n  seg.init();\n  for(int i=0;i<n;i++){\n    seg.upd(b[i],seg.qry(0,b[i])+a[i]);\n  }\n  ll sum=0;\n  for(int i=0;i<n;i++)sum+=a[i];\n  cout<<sum-seg.qry(0,n)<<endl;\n    return 0;\n}\n\n"
  },
  {
    "language": "C++",
    "code": "#include<cstdio>\n#include<algorithm>\n\n#define rep(i,n) for(int i=0;i<(n);i++)\n\nusing namespace std;\n\ntypedef long long ll;\n\ntemplate<class T>\nclass segment_tree_RMQ{\n\tstatic const int N_MAX=1<<17;\n\tint n;\n\tT dat[2*N_MAX];\n\n\tT query(int l,int r,int a,int b,int u){\n\t\tif(l<=a && b<=r) return dat[u];\n\n\t\tT res=0;\n\t\tint c=(a+b+1)/2;\n\t\tif(l<c && a<r) res=max(res,query(l,r,a,c,2*u));\n\t\tif(l<b && c<r) res=max(res,query(l,r,c,b,2*u+1));\n\t\treturn res;\n\t}\n\npublic:\n\tvoid build(int N,int val){\n\t\tfor(n=1;n<N;n*=2);\n\t\trep(u,2*n) dat[u]=val;\n\t}\n\n\tvoid update(int u,T v){\n\t\tu+=n;\n\t\tdat[u]=v;\n\t\tfor(u/=2;u>=1;u/=2) dat[u]=max(dat[2*u],dat[2*u+1]);\n\t}\n\n\tT query(int l,int r){ return query(l,r,0,n,1); }\n};\n\nint main(){\n\tint n; scanf(\"%d\",&n);\n\tint x[100000];\n\trep(i,n) scanf(\"%d\",x+i);\n\n\tsegment_tree_RMQ<int> S;\n\tS.build(n+1,0);\n\trep(i,n){\n\t\tint cost=S.query(0,x[i]);\n\t\tS.update(x[i],cost+x[i]);\n\t}\n\n\tprintf(\"%lld\\n\",(ll)n*(n+1)/2-S.query(1,n+1));\n\n\treturn 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\nusing namespace std;\n#define FOR(i,k,n) for(int i = (k); i < (n); i++)\n#define REP(i,n) FOR(i,0,n)\n#define ALL(a) a.begin(), a.end()\n#define MS(m,v) memset(m,v,sizeof(m))\n#define D10 fixed<<setprecision(10)\ntypedef long long ll;\ntypedef long double ld;\ntypedef vector<int> vi;\ntypedef vector<string> vs;\ntypedef pair<int, int> pii;\nconst int MOD = 1000000007;\nconst int INF = MOD + 1;\nconst ld EPS = 1e-12;\ntemplate<class T> T &chmin(T &a, const T &b) { return a = min(a, b); }\ntemplate<class T> T &chmax(T &a, const T &b) { return a = max(a, b); }\n\n/*--------------------template--------------------*/\nstruct Data\n{\n\tll num;\n\tData() :num(INF) {};\n\tData(int n) :num(n) {};\n};\n\nstruct SegmentTree\n{\n\tint n; vector<Data> data;\n\tSegmentTree(int N)\n\t{\n\t\tn = 1;\n\t\twhile (n < N) n *= 2;\n\t\tdata.resize(2 * n);\n\t}\nprivate:\n\tData sub(int left, int right, int node, int nleft, int nright)\n\t{\n\t\tif (nright <= left || right <= nleft) return Data();\n\t\tif (left <= nleft && nright <= right) return data[node];\n\t\tData vl = sub(left, right, node * 2 + 1, nleft, (nleft + nright) / 2);\n\t\tData vr = sub(left, right, node * 2 + 2, (nleft + nright) / 2, nright);\n\t\treturn min(vl.num, vr.num);\n\t}\n\npublic:\n\tvoid update(int pos, Data value)\n\t{\n\t\tpos += n - 1;\n\t\tdata[pos] = value;\n\t\twhile (pos > 0)\n\t\t{\n\t\t\tpos = (pos - 1) / 2;\n\t\t\tdata[pos] = min(data[pos * 2 + 1].num, data[pos * 2 + 2].num);\n\t\t}\n\t}\n\tData min_query(int left, int right)\n\t{\n\t\treturn sub(left, right, 0, 0, n);\n\t}\n};\n\n\n\nint main()\n{\n\tint n;\n\tcin >> n;\n\tSegmentTree seg(n);\n\tREP(i, n) seg.update(i, 0);\n\tREP(i, n)\n\t{\n\t\tint a;\n\t\tcin >> a;\n\t\tll val = seg.min_query(0, a).num - a;\n\t\tseg.update(a-1, val);\n\t}\n\tcout << n*(n + 1) / 2 + seg.min_query(0, n).num << endl;\n\treturn 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include <iostream>\n#include <vector>\n#include <map>\n#include <tuple>\nusing namespace std;\n\nconst int MAX_N = 1<<17;\n\nint n;\nint64_t dat[2*MAX_N-1];\n\nvoid init(int n_){\n    n = 1;\n    while(n<n_)n*=2;\n    for(int i=0;i<2*n-1;i++) dat[i]=INT_MAX;\n}\n\n//0-indexed, k-th to a\nvoid update(int k, int64_t a){\n    k+=n-1;\n    dat[k]=a;\n    while(k>0){\n        k=(k-1)/2;\n        dat[k]=min(dat[k*2+1],dat[k*2+2]);\n    }\n}\n\n//[a,b)???????°????\nint64_t query(int a, int b, int k=0, int l=0, int r=n){\n    if(r<=a||b<=l) return INT_MAX;\n    if(a<=l&&r<=b) return dat[k];\n    else{\n        int64_t vl = query(a,b,k*2+1,l,(l+r)/2);\n        int64_t vr = query(a,b,k*2+2,(l+r)/2,r);\n        return min(vl,vr);\n    }\n}\n\nusing P = pair<int,int>;\n\nint main(){\n    int N;\n    cin>>N;\n    vector<P> V;\n    vector<int> X;\n    for(int i=0;i<N;i++){\n        int x;\n        cin>>x;\n        V.emplace_back(x,i);\n        X.push_back(x);\n    }\n    sort(V.begin(), V.end());\n    vector<int> nth(N);\n    for(int i=0;i<N;i++){\n        nth[V[i].second]=i;\n    }\n    init(N);\n    for(int i=0;i<N;i++){\n        update(i,0);\n    }\n    for(int i=0;i<N;i++){\n        int64_t sum = -X[i];\n        if(nth[i]){\n            sum+=query(0,nth[i]);\n        }\n        update(nth[i],sum);\n    }\n    int64_t ans = 0;\n    for(auto x:X) ans+=x;\n    ans+=query(0,N);\n    cout<<ans<<endl;\n\n    return 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include<iostream>\n#include<vector>\n#include<algorithm>\n#include<climits>\n\nconst int MAX_N=1000000;\n\ntypedef long long ll;\n\nusing namespace std;\n\nll n,dat[2*MAX_N-1];\n\nvoid init(int n_){\n\tn=1;\n\twhile(n<n_)n*=2;\n\tfor(int i=0;i<2*n-1;i++)dat[i]=0;\n}\n\nvoid update(int k,ll a){\n\tk+=n-1;\n\tdat[k]=a;\n\t\n\twhile(k>0){\n\t\tk=(k-1)/2;\n\t\tdat[k]=max(dat[2*k+1],dat[2*k+2]);\n\t}\n}\n\nll query(int a,int b,int k,int l,int r){\n\tif(r<=a || b<=l)return 0;\n\tif(a<=l && r<=b)return dat[k];\n\telse {\n\t\tll vl=query(a,b,k*2+1,l,(l+r)/2);\n\t\tll vr=query(a,b,k*2+2,(l+r)/2,r);\n\t\treturn max(vl,vr);\n\t}\n}\n\nint main(void){\n\t\n\tll in,m,ans=0;\n\t\n\tcin >> m;\n\t\n\tinit(m);\n\t\n\tfor(int i=0;i<m;i++){\n\t\tcin >> in;\n\t\tupdate(in,in+query(1,in,0,0,n));\n\t\tans=max(ans,dat[in+n-1]);\n\t}\n\tcout << m*(m+1)/2-ans << endl;\n\t\n\treturn 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include <iostream>\n#include <vector>\n#include <functional>\n\nusing namespace std;\n\n// POJ 3264 Balanced Lineup\n// AOJ 2431 House Moving\ntemplate <class T, class Compare>\nstruct SegmentTree/*{{{*/\n{\n  vector<T>& mem;\n  vector<int> indexes;\n  Compare cmp;\n  SegmentTree(vector<T>& cs)\n    : mem(cs), indexes(4*cs.size(), -1)\n  {\n    build(0, 0, cs.size());\n  }\n\n  void build(int idx, int left, int right)\n  {\n    if (left+1 == right) {\n      indexes[idx] = left;\n    } else {\n      const int mid = (left + right)/2;\n      build(2*idx+1, left, mid);\n      build(2*idx+2, mid, right);\n      // minimum in [left, right)\n      if (cmp(mem[indexes[2*idx+1]], mem[indexes[2*idx+2]])) {\n        indexes[idx] = indexes[2*idx+1];\n      } else {\n        indexes[idx] = indexes[2*idx+2];\n      }\n    }\n  }\n\n  inline T query_value(int left, int right) const { return mem[query_index(left, right)]; }\n\n  inline int query_index(int left, int right) const { return query_index(left, right, 0, 0, mem.size()); }\n\n  int query_index(int left, int right, int i, int a, int b) const\n  {\n    // [a, b) is the range of indexes[i]\n    if (b <= left || right <= a) {\n      // does not intersect\n      return -1;\n    } else if (left <= a && b <= right) {\n      // contains\n      return indexes[i];\n    } else {\n      const int m = (a+b)/2;\n      const int l = query_index(left, right, 2*i+1, a, m);\n      const int r = query_index(left, right, 2*i+2, m, b);\n      if (l == -1) {\n        return r;\n      } else if (r == -1) {\n        return l;\n      } else {\n        if (cmp(mem[l], mem[r])) {\n          return l;\n        } else {\n          return r;\n        }\n      }\n    }\n  }\n\n  void update(int idx, T val)\n  {\n    mem[idx] = val;\n    update_index(0, mem.size(), 0, idx);\n  }\n\n  void update_index(int left, int right, int i, int idx)\n  {\n    if (left+1 == right) {\n      //indexes[i] = idx;\n    } else {\n      const int mid = (left+right)/2;\n      if (idx < mid) {\n        update_index(left, mid, 2*i+1, idx);\n      } else {\n        update_index(mid, right, 2*i+2, idx);\n      }\n      if (cmp(mem[indexes[2*i+1]], mem[indexes[2*i+2]])) {\n        indexes[i] = indexes[2*i+1];\n      } else {\n        indexes[i] = indexes[2*i+2];\n      }\n    }\n  }\n\n};/*}}}*/\n\nint main() {\n    cin.tie(0);\n    ios::sync_with_stdio(0);\n\n    int N;\n    cin >> N;\n    vector<long long> v(N+1, 0);\n    SegmentTree<long long, greater<long long> > segtree(v);\n    for(int i = 0; i < N; ++i) {\n        int X;\n        cin >> X;\n        long long best = segtree.query_value(0, X);\n        segtree.update(X, best + X);\n    }\n    long long sum = 0;\n    for(int i = 1; i <= N; ++i) {\n        sum += i;\n    }\n    cout << sum - segtree.query_value(1, N+1) << endl;\n    return 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include <iostream>\n#include <algorithm>\n#include <set>\n#include <cstdio>\nusing namespace std;\n\ntypedef long long ll;\ntypedef pair<ll,ll> P;\n\nconst ll MAX = 100000;\n\nint main(){\n  int n;\n  while(cin >> n){\n    ll a[MAX],ans=0,sum=0;\n    set<P> s;\n    for(int i=0;i<n;i++) scanf(\"%d\",&a[i]);\n    for(int i=0;i<n;i++){\n      ll cnt = 0;\n      sum += a[i];\n      if(i > 0){\n\tset<P>::iterator it = s.end();\n\tit--;\n\twhile(1){\n\t  it = s.lower_bound(P(it->first,0));\n\t  if(it->second < a[i]){\n\t    cnt = it->first;\n\t    break;\n\t  } else if(it == s.begin()) break;\n\t  else it--;\n\t}\n      }\n      ans = max(ans,cnt+a[i]);\n      s.insert(P(cnt+a[i],a[i]));\n    }\n    printf(\"%d\\n\",sum - ans);\n  }\n}"
  },
  {
    "language": "C++",
    "code": "#include <iostream>\n#include <algorithm>\n\nusing namespace std;\n\n#define ll long long\n#define rep(a,b) for(int a = 0; a < b; a++)\n\nint n;\nll dp[100001*2];\nint arr[100000];\nint size = 1;\n\nvoid update(int index, ll num) {\n  index += size-1;\n  dp[index] = num;\n  //cout << \"  \" << index << \",\" << dp[index] << endl;\n  while(index>0) {\n    int new_index = (index-1)>>1;\n    dp[new_index] = max(dp[(new_index<<1)+1],dp[(new_index<<1)+2]);\n    //cout << \"  \" << new_index << \",\" << dp[new_index] << endl;\n    index = new_index;\n  }\n  //dp[index] = max(dp[index],dp[index^1]);\n}\n\nll get_max(int a, int b, int k, int left, int right) {\n  //cout << \"gmax \" << a << \",\" << b << \",\" << k << \",\" << left << \",\" << right << endl;\n  if(right<a||b<=left||right<=left) return 0;\n  if(a<=left&&right<=b) {\n    //cout << \"OK \" << dp[k] << endl;\n    return dp[k];\n  }\n  ll ret = 0;\n  ret = max(ret,get_max(a,b,(k<<1)+1,left,(left+right)>>1));\n  ret = max(ret,get_max(a,b,(k<<1)+2,(left+right+1)>>1,right));\n  return ret;\n}\n\nint main() {\n  cin >> n;\n  for(int i = 1; i < n; i<<=1) size<<=1;\n  rep(i,n) cin >> arr[i];\n  rep(i,n) {\n    int num = arr[i];\n    ll _max = get_max(1,num,0,0,size);\n    //cout << num << \",\" << _max << endl;\n    update(num,_max+num);\n  }\n  ll ans = (ll)n;\n  ans = n*(n+1)/2;\n  //for(int i = 0; i < size<<1; i++) cout << dp[i] << endl;\n  cout << ans-dp[0];\n}\n\n"
  },
  {
    "language": "C++",
    "code": "#include<iostream>\n#include<algorithm>\n\nusing namespace std;\n\ntypedef long long Int;\n\nInt bit[105000];\n\nvoid setnum(int pos, int val){\n\twhile(pos < 105000){\n\t\tbit[pos] = max(val, bit[pos]);\n\t\tpos += pos & -pos;\n\t}\n}\n\nInt maxnum(int pos){\n\tInt res = 0;\n\twhile(pos){\n\t\tres = max(res, bit[pos]);\n\t}\n\treturn res;\n}\n\nint main(){\n\tInt n, sum = 0, x;\n\tcin >> n;\t\n\tfor(int i = 0;i < n;i++){\n\t\tcin >> x;\n\t\tsum += x;\n\t\tInt p = p + maxnum(p);\n\t\tsetnum(x, p);\n\t}\n\tcout << sum - maxnum(10100) << endl;\n\treturn 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include<iostream>\n#include<cstdio>\n#include<cmath>\n#include<algorithm>\n#include<string>\n#include<vector>\n#include<map>\n#include<stack>\n#include<queue>\n\nusing namespace std;\n\ntypedef long long ll;\n\nint n;\nll bit[100001];\n\nvoid add(int a, ll x){\n\tfor(int i=a+1;i<=n;i+=(i&-i)){\n\t\tbit[i]=max(bit[i],x);\n\t}\n\treturn;\n}\n\nll sum(int a){\n\tll ret=0;\n\tfor(int i=a;i>0;i-=(i&-i)){\n\t\tret=max(ret,bit[i]);\n\t}\n\treturn ret;\n}\n\nint main(){\n\tint x;\n\tscanf(\"%d\",&n);\n\tfor(int i=0;i<n;i++){\n\t\tscanf(\"%d\",&x);\n\t\tadd(x-1,sum(x-1)+x);\n\t}\n\tprintf(\"%lld\\n\",(ll(n)*(n+1))/2-sum(n));\n}\n"
  },
  {
    "language": "C++",
    "code": "#include <cstdio>\n#include <iostream>\n#include <algorithm>\n#include <complex>\n#include <queue>\n#include <map>\nusing namespace std;\n\n#define FOR(i,a,b) for (int i=(a);i<(b);i++)\n#define FORR(i,a,b) for (int i=(b)-1;i>=(a);i--)\n#define REP(i,n) for (int i=0;i<(n);i++)\n#define RREP(i,n) for (int i=(n)-1;i>=0;i--)\n#define pb push_back\n#define ALL(a) (a).begin(),(a).end()\n\n#define EPS (1e-10)\n#define EQ(a,b) (abs((a)-(b)) < EPS)\n\ntypedef long long ll;\ntypedef pair<ll, int> P;\n//typedef complex<double> C;\n\nconst double pi = acos(-1);\n\nint N;\nll x[100010];\nll sum_x = 0;\n\nvoid input() {\n\tcin >> N;\n\tREP(i, N) {\n\t\tcin >> x[i];\n\t\tsum_x += x[i];\n\t}\n}\n\nconst int MAX_N = 1 << 17;\n\nint width;\nll dat[2 * MAX_N - 1];\n\nvoid init(int n_) {\n    // let width be the power of 2\n    width = 1;\n    while (width < n_) width *= 2;\n\n    // set all values by INF(0)\n    REP(i, 2 * width - 1) dat[i] = 0;\n}\n\n// change the k-th(0-index) value to a\nvoid update(int k, int a) {\n    // set a in the leaf\n    k += width - 1;\n    dat[k] = a;\n\n    // update upward\n    while (k > 0) {\n        k = (k - 1) / 2;\n        dat[k] = max(dat[2 * k + 1], dat[2 * k + 2]);\n    }\n}\n\n// get the minimum(maximum) value in [a, b)\n// k: num of the node corresponds to [l, r)\n// call like this: 'query(a, b, 0, 0, n)'\nint query(int a, int b, int k, int l, int r) {\n    // if [a, b) & [l, r) = 0, then return nonsense value\n    if (r <= a || b <= l) return 0;\n\n    // if [a, b) covers the whole [l, r),\n    // then return the value of this node\n    if (a <= l && r <= b) return dat[k];\n\n    // otherwise, return the min of two children\n    int vl = query(a, b, k * 2 + 1, l, (l + r) / 2);\n    int vr = query(a, b, k * 2 + 2, (l + r) / 2, r);\n\n    return max(vl, vr);\n}\n\n\nvoid solve() {\n\t// DP with segtree\n\tint ma = 0;\n\n\t// dp[i] = max(dp[j] s.t. j < i && x[j] < x[i]) + 1\n\tinit(N);\n\tREP(i, N) {\n\t\tint dpi = query(0, x[i], 0, 0, width) + x[i];\n\t\tma = max(ma, dpi);\n\t\tupdate(x[i] - 1, dpi);\n\t}\n\n\tcout << sum_x - ma << endl;\n}\n\n\nint main() {\n\tinput();\n    solve();\n    return 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include<iostream>\n#include<cstdio>\n#include<iomanip>\n#include<queue>\n#include<string>\n#include<vector>\n#include<utility>\n#include<set>\n#include<map>\n#include<algorithm>\nusing namespace std;\n#define pb push_back\n#define fi first\n#define sc second\n#define mp make_pair\n#define is insert\nconst int inf=100001;\n\nstruct plli1{\n\tlong long fi;\n\tint sc;\n};\nstruct plli2{\n\tlong long fi;\n\tint sc;\n};\ntypedef set<plli1> slli1;\ntypedef set<plli2> slli2;\n\nbool operator<(plli1 p,plli1 q){\n\treturn p.fi<q.fi;\n}\n\nbool operator>(plli1 p,plli1 q){\n\treturn p.fi>q.fi;\n}\n\nbool operator<(plli2 p,plli2 q){\n\treturn p.sc<q.sc;\n}\n\nbool operator>(plli2 p,plli2 q){\n\treturn p.sc>q.sc;\n}\n\nint main(){\n\tint n;\n\tslli1 s;\n\tslli2 t;\n\ts.is((plli1){0,0});\n\ts.is((plli1){1,inf});\n\tt.is((plli2){0,0});\n\tt.is((plli2){1,inf});\n\tcin>>n;\n\tfor(int i=0;i<n;++i){\n\t\tint x;\n\t\tcin>>x;\n\t\tslli2::iterator b=upper_bound(t.begin(),t.end(),((plli2){0,x}));\n\t\tlong long y=((*b).fi);\n\t\tslli1::iterator e=lower_bound(s.begin(),s.end(),((plli1){y+x,0}));\n\t\tint z=(*(--e)).sc;\n\t\t++e;\n\t\tplli1 c1=((plli1){(*b).fi,(*b).sc});\n\t\tplli2 f1=((plli2){(*e).fi,(*e).sc});\n\t\tslli1::iterator b1=s.find(c1);\n\t\tslli2::iterator e1=t.find(f1);\n\t\ts.erase(b1,e);\n\t\tt.erase(b,e1);\n\t\ts.is((plli1){y,x});\n\t\ts.is((plli1){y+x,z});\n\t\tt.is((plli2){y,x});\n\t\tt.is((plli2){y+x,z});\n\t}\n\tslli1::iterator e=s.end();\n\t--e;\n\tcout<<((long long)n*(n+1)/2)-(*e).fi+1<<endl;\n}"
  },
  {
    "language": "C++",
    "code": "#include<cstdio>\n#include<iostream>\n#include<string>\n#include<vector>\n#include<algorithm>\n\nusing namespace std;\n\n#define reps(i,f,n) for(int i=f;i<int(n);i++)\n#define rep(i,n) reps(i,0,n)\n\nconst int N = 10010;\nconst int INF = 1000000000;\nint n;\nint dp[2][N];\n\nvoid init(){\n\trep(i,2)rep(j,N)dp[i][j]=INF;\n}\n\nint solve(){\n\tinit();\n\t\n\tint p[N];\n\trep(i,n)cin>>p[i];\n\t\n\tint i2 = 0;\n\tint i1 = 1;\n\t\n\trep(i,n){\n\t\tdp[i1][i]=p[0];\n\t\tif(i>=p[0])dp[i1][i]=0;\n\t}\n\treps(i,1,n){\n\t\trep(j,N)dp[i2][j]=INF;\n\t\trep(j,n+1){\n\t\t\tdp[i2][j] = min(dp[i2][j],dp[i1][j] + p[i]);\n\t\t\tif(j-1>=0)dp[i2][j] = min(dp[i2][j],dp[i2][j-1]);\n\t\t\t\n\t\t\tif(p[i]==j){\n\t\t\t\trep(k,j){\n\t\t\t\t\tdp[i2][j] = min(dp[i2][j], dp[i1][k]);\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t\tswap(i2,i1);\n\t}\n\t\n\treturn dp[i1][n];\n}\n\nint main(){\n\twhile(1){\n\t\tcin>>n;\n\t\tif(n==0)break;\n\t\tprintf(\"%d\\n\",solve());\n\t\tbreak;\n\t}\n\t\n\t\n\t\n}"
  },
  {
    "language": "C++",
    "code": "#include<iostream>\n#include<vector>\nusing namespace std;\ntypedef long long ll;\n\nconst int INF = 1<<30;\n\nstruct STmax{\nprivate:\n    int n;\n    vector<ll> dat;\npublic:\n    STmax(int siz){\n        n = 1;\n        while(n < siz)   n *= 2;\n        dat.resize(2*n-1, 0);\n    }\n\n    void update(int x, ll val){\n        x += (n-1);\n        dat[x] = val;\n        while(x > 0){\n            x = (x-1)/2;\n            dat[x] = max(dat[2*x+1], dat[2*x+2]);\n        }\n    }\n    \n    // focus on k-th node, who controls [l, r)\n    ll query(int a, int b, int k = 0, int l = 0, int r = -1){\n        if(r < 0)   r = n;\n        if(r <= a || b <= l)    return 0;\n        if(a <= l && r <= b)    return dat[k];\n\n        ll lx = query(a, b, 2*k+1, l, (l+r)/2);\n        ll rx = query(a, b, 2*k+2, (l+r)/2, r);\n        return max(lx, rx);\n    }\n};\n\nint main(){\n    int n;\n    cin >> n;\n    STmax seg(n+1);\n    for(int i = 0; i < n; i++){\n        int x;  cin >> x;\n        seg.update(x, seg.query(0, x)+x);\n    }\n    cout << (ll)n*(n+1)/2-seg.query(0, n+1) << endl;\n}\n"
  },
  {
    "language": "C++",
    "code": "#include <vector>\n#include <list>\n#include <map>\n#include <set>\n#include <deque>\n#include <stack>\n#include <bitset>\n#include <algorithm>\n#include <functional>\n#include <numeric>\n#include <utility>\n#include <sstream>\n#include <queue>\n#include <iostream>\n#include <iomanip>\n#include <cstdio>\n#include <cmath>\n#include <cstdlib>\n#include <cctype>\n#include <string>\n#include <cstring>\n#include <ctime>\n#include <fstream>\n#include <stdio.h>\n#include <complex>\n\nusing namespace std;\n\n//conversion\n//------------------------------------------\ninline int toInt(string s) {int v; istringstream sin(s);sin>>v;return v;}\ntemplate<class T> inline string toString(T x) {ostringstream sout;sout<<x;return sout.str();}\n\n//typedef\n//------------------------------------------\ntypedef vector<int> VI;\ntypedef vector<VI> VVI;\ntypedef vector<string> VS;\ntypedef pair<int, int> PII;\ntypedef pair<int, PII> TIII;\ntypedef long long LL;\ntypedef vector<LL> VLL;\n\n//container util\n\n//------------------------------------------\n#define ALL(a)  (a).begin(),(a).end()\n#define RALL(a) (a).rbegin(), (a).rend()\n#define PB push_back\n#define MP make_pair\n#define SZ(a) int((a).size())\n#define EACH(i,c) for(typeof((c).begin()) i=(c).begin(); i!=(c).end(); ++i)\n#define EXIST(s,e) ((s).find(e)!=(s).end())\n#define SORT(c) sort((c).begin(),(c).end())\n#define MT(a,b,c) MP(a, MP(b, c))\n\n//repetition\n//------------------------------------------\n#define FOR(i,a,b) for(int i=(a);i<(b);++i)\n#define REP(i,n)  FOR(i,0,n)\n\nclass SegTree{\n\tpublic:\n\tVLL dat;\n\tint n, b;\n\tint DEF;\n\tSegTree(int N){\n\t\tn = 1;\n\t\tDEF = 0;\n\t\twhile(n<N)n*=2;\n\t\tdat = VLL(2*n-1);\n\t\tREP(i, 2*n-1)dat[i] = DEF;\n\t}\n\tvoid update(int index, LL v){\n\t\tint k=index+n-1;\n\t\tdat[k]=v; \n\t\twhile(1){\n\t\t\tk=(k-1)/2;//上に登る\n\t\t\tdat[k] = value(k);\n\t\t\tif(k==0)break;\n\t\t}\n\t}\n\tinline LL value(int idx){//Update value with (2*idx+1, 2*idx+2) \n\t\treturn value(dat[2*idx+1], dat[2*idx+2]);\n\t}\n\tinline LL value(LL v1, LL v2){\n\t\treturn max(v1, v2);\n\t}\n\tLL query(int idx1, int idx2, int node=0, int range1=0, int range2=-1){\n\t\tif(range2 <0 )range2 = n;\n\t\tif(range2 <= idx1 || idx2 <= range1)return DEF;//交差しない\n\t\tif(idx1 <= range1 && range2 <= idx2)return dat[node];\n\t\telse{\n\t\t\tLL vl = query(idx1, idx2, node*2+1, range1, (range1+range2)/2);\n\t\t\tLL vr = query(idx1, idx2, node*2+2, (range1+range2)/2, range2); \n\t\t\treturn value(vl, vr);\n\t\t}\n\t}\n};\n\nint main(){\n\tint n;\n\tcin >> n;\n\tSegTree seg(n);\n\tREP(i,n){\n\t\tint tmp;\n\t\tscanf(\"%d\", &tmp);\n\t\tLL v = seg.query(0, tmp-1);\n\t\tseg.update(tmp-1, v+tmp);\n\t}\n\tcout << n*(n+1)/2-seg.query(0, n)<< endl;\n\treturn 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\nusing namespace std;\nusing ll = long long;\n\ntemplate <typename T>\nclass LazySegmentTree {\n\tconst int n;\n\tconst T flag;\n\tconst T id;\n\tvector<T> data, data2;\n\tint size(int n) {\n\t\tint res = 1;\n\t\twhile (res < n) res <<= 1;\n\t\treturn res;\n\t}\n\tT sub(int l, int r, int node, int lb, int ub) {\n\t\tif (ub <= l || r <= lb) return id;\n\t\tif (data[node] != flag) {\n\t\t\treturn data[node];\n\t\t}\n\t\tif (l <= lb && ub <= r) {\n\t\t\treturn data[node] == flag ? data2[node] : data[node];\n\t\t}\n\t\tint left = node * 2, right = node * 2 + 1;\n\t\tif (data[node] != flag) {\n\t\t\tdata[left] = data[node];\n\t\t\tdata[right] = data[node];\n\t\t}\n\t\treturn max(sub(l, r, node * 2, lb, (lb + ub) / 2), sub(l, r, node * 2 + 1, (lb + ub) / 2, ub));\n\t}\n\tvoid suc(int l, int r, int node, int lb, int ub, T val) {\n\t\tif (ub <= l || r <= lb) return;\n\t\tif (data[node] == val) return;\n\t\tif (l <= lb && ub <= r) {\n\t\t\tdata[node] = val;\n\t\t\treturn;\n\t\t}\n\t\tint left = node * 2, right = node * 2 + 1;\n\t\tif (data[node] != flag) {\n\t\t\tdata[left] = data[node];\n\t\t\tdata[right] = data[node];\n\t\t}\n\t\tdata[node] = flag;\n\t\tsuc(l, r, left, lb, (lb + ub) / 2, val);\n\t\tsuc(l, r, right, (lb + ub) / 2, ub, val);\n\t\tdata2[node] = max(data[left] == flag ? data2[left] : data[left], data[right] == flag ? data2[right] : data[right]);\n\t}\npublic:\n\tLazySegmentTree(int n_, T flag_, T id_) :\n\t\tn(size(n_)), flag(flag_), id(id_), data(n * 2, id), data2(n * 2) {}\n\tvoid update(int l, int r, T val) {\n\t\tsuc(l, r + 1, 1, 0, n, val);\n\t}\n\tT find(int l, int r) {\n\t\treturn sub(l, r + 1, 1, 0, n);\n\t}\n};\n\nint main()\n{\n\tll n;\n\tcin >> n;\n\tll res = n * (n + 1) / 2;\n\tLazySegmentTree<ll> lst(n + 1, -1, 0);\n\tfor (int i = 0, x; i < n; i++) {\n\t\tcin >> x;\n\t\tll val = x + lst.find(0, x);\n\t\tll l = x, r = n + 1;\n\t\twhile (l + 1 < r) {\n\t\t\tll c = (l + r) / 2;\n\t\t\tif (lst.find(x, c) == val) {\n\t\t\t\tl = c;\n\t\t\t}\n\t\t\telse {\n\t\t\t\tr = c;\n\t\t\t}\n\t\t}\n\t\tlst.update(x, l, val);\n\t}\n\tcout << res - lst.find(0, n) << endl;\n\treturn 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include<bits/stdc++.h>\nusing namespace std;\n#define int long long\nconst int MAX_N = 1 << 17;\nint bit[MAX_N+1],n;\nint sum(int i){\n  int s=0;\n  while(i>0){\n    s+=bit[i];\n    i-=i&-i;\n  }\n  return s;\n}\nvoid add(int i,int x){\n  while(i<=n){\n    bit[i]+=x;\n    i+=i&-i;\n  }\n}\nsigned main(){\n  memset(bit,0,sizeof(bit));\n  cin>>n;\n  int x[n],ans=0,p=-1;\n  for(int i=0;i<n;i++) cin>>x[i];\n  for(int i=n-1;i>=0;i--){\n    //cout<<x[i]<<\":\"<<sum(x[i])<<\"/\"<<ans<<endl;\n    if(x[i]<sum(x[i])){\n      ans+=x[i];\n    }else{\n      ans+=sum(x[i]);\n      add(x[i],-sum(x[i]));\n    }\n    add(x[i],x[i]);\n  }\n  cout<<ans<<endl;\n  return 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include<bits/stdc++.h>\n#define N (1<<17)\nusing namespace std;\ntypedef long long ll;\n\nclass RMQ{\npublic:\n  ll n,dat[2*N-1];\n  //?????????\n  RMQ(){};\n  RMQ(int n_){\n    //????´???°n???2???????????????\n    n=1;\n    while(n<n_)n*=2;\n    for(int i=0;i<2*n-1;i++)dat[i]=0;\n  }\n  \n  //k???????????????a????????´\n  void update(int k,int a){\n    k+=n-1;\n    dat[k]=a;\n    while(k>0){\n      k=(k-1)/2;\n      dat[k]=min(dat[k*2+1],dat[k*2+2]);\n    }\n  }\n\n  //[a,b)???????°????????±???????\n  //query(a,b,0,0,n)\n  ll query(int a,int b,int k=0,int l=0,int r=-1){\n    if(r==-1) r=n;\n    if(r<=a||b<=l)return 0;\n    if(a<=l&&r<=b)return dat[k];\n    else{\n      ll v1=query(a,b,k*2+1,l,(l+r)/2);\n      ll vr=query(a,b,k*2+2,(l+r)/2,r);\n      return min(v1,vr);\n    }\n  }\n};\n\n\nll x[N];\nint main(){  \n  ll n;\n  cin>>n;\n  RMQ rmq(n+1);\n  \n\n  for(int i=1;i<=n;i++) cin>>x[i];\n\n  ll sum=n*(1+n)/2,cost=0;  \n  for(int i=1;i<=n;i++){\n    ll mx=-rmq.query(1,x[i])+x[i];\n    cost=max(cost,mx);\n    rmq.update(x[i],-mx);\n  }\n  cout << sum-cost<<endl;\n  return 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include <iostream>\n#include <vector>\n#include <string>\n#include <cmath>\n#include <algorithm>\n#include <utility>\n#include <queue>\n#include <set>\n#include <map>\n\nusing namespace std;\ntypedef  long long ll;\ntypedef pair<int,int> PII;\ntypedef vector<int> VI;\ntypedef vector<VI> VVI;\n#define  MP make_pair\n#define  PB push_back\n#define inf  1000000007\n#define int long long\n#define rep(i,n) for(int i=0;i<(int)(n);++i)\n\nint bit[100010],n;\n\nint mx(int i){\n\tint s = 0;\n\twhile(i>0){\n\t\ts = max(s,bit[i]);\n\t\ti -= i& -i;\n\t}\n\treturn s;\n}\n\nvoid add(int i,int x){\n\twhile(i<=n){\n\t\tbit[i] = max(bit[i],x);\n\t\ti += i& -i;\n\t}\n}\n\n\n\nsigned main(){\n\tcin >> n;\n\tvector<int>v(n);\n\tint ans = 0;\n\trep(i,n){\n\t\tcin >> v[i];\n\t\tans += v[i];\n\t}\n\trep(i,n){\n\t\tint tmp = mx(v[i]);\n\t\tadd(v[i],tmp+v[i]);\n\t}\n\tint m=0;\n\trep(i,n){\n\t\tm = max(m,mx(i+1));\n\t}\n\tcout << ans - m << endl;\n\treturn 0;\n}\n"
  },
  {
    "language": "C++",
    "code": "#include<iostream>\n#include<vector>\n#include<algorithm>\n#include<climits>\n\nconst int MAX_N=1<<17;\n\ntypedef long long ll;\n\nusing namespace std;\n\n\nll n,dat[2*MAX_N-1];\n\nvoid init(int n_){\n\tn=1;\n\twhile(n<n_)n*=2;\n}\n\nvoid update(int k,ll a){\n\tk+=n-1;\n\tdat[k]=a;\n\t\n\twhile(k>0){\n\t\tk=(k-1)/2;\n\t\tdat[k]=max(dat[2*k+1],dat[2*k+2]);\n\t}\n}\n\nll query(int a,int b,int k,int l,int r){\n\tif(r<=a || b<=l)return 0;\n\tif(a<=l && r<=b)return dat[k];\n\telse {\n\t\tll vl=query(a,b,k*2+1,l,(l+r)/2);\n\t\tll vr=query(a,b,k*2+2,(l+r)/2,r);\n\t\treturn max(vl,vr);\n\t}\n}\n\nint main(void){\n\t\n\tll in,m,ans=0;\n\t\n\tcin >> m;\n\t\n\tinit(m);\n\t\n\tfor(int i=0;i<m;i++){\n\t\tcin >> in;\n\t\tupdate(in,in+query(1,in,0,0,n));\n\t}\n\tcout << m*(m+1)/2-query(1,m+1,0,0,n) << endl;\n\t\n\treturn 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include \"bits/stdc++.h\"\n#include<unordered_map>\n#include<unordered_set>\n#pragma warning(disable:4996)\nusing namespace std;\nusing ld = long double;\ntemplate<class T>\nusing Table = vector<vector<T>>;\n\n\n\nint main() {\n\tint N; cin >> N;\n\tvector<long long int>nums(N);\n\tfor (int i = 0; i < N; ++i) {\n\t\tcin >> nums[i];\n\t}\n\tunordered_map<int, long long int>nmp;\n\tnmp[0] = 0;\n\tfor (int i = 0; i < N; ++i) {\n\t\tunordered_map<int, long long int>newmp(nmp);\n\t\tfor (auto j : nmp) {\n\t\t\tif(nums[i]>j.first)\n\t\t\t\tnewmp[nums[i]] = max(newmp[nums[i]], j.second + nums[i]);\n\t\t}\n\t\tnmp = newmp;\n\t}\n\tlong long int sum= N*(N + 1) / 2;\n\tlong long int ans = sum;\n\tfor (auto m : nmp) {\n\t\tans = min(ans, sum-m.second);\n\t}\n\tcout << ans << endl;\n\treturn 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include <cstdio>\n#include <algorithm>\nusing namespace std;\n#define rep(i,n) for(int i=0;i<(n);i++)\ntypedef long long int lli;\n\nlli seg[400005]={};\nint N=1;\nvoid init(int p){\n\twhile(N<p)N*=2;\n}\n\nlli rec(int l,int r,int a,int b,int no){\n\tif(b<=l || r<=a)return 0;\n\tif(a<=l && r<=b)return seg[no];\n\treturn max( \n\t\trec(l,(l+r)/2,a,b,no*2),\n\t\trec((l+r)/2,r,a,b,no*2+1));\n}\n\t\t\nvoid upd(int p,lli to){\n\tp+=N;\n\twhile(p){\n\t\tseg[p]=max(seg[p],to);\n\t\tp/=2;\n\t}\n}\nlli n;\nlli dat[100005];\nint main(void){\n\tscanf(\"%lld\",&n);\n\trep(i,n)scanf(\"%lld\",&(dat[i]));\n\t\n\tinit(n+3);\n\trep(i,n){\n\t\tlli cam=rec(0,N,1,dat[i],1);\n\t\tupd(dat[i],cam+dat[i]);\n\t}\n\tprintf(\"%lld\\n\",n*(n+1)/2-rec(0,N,1,n+1,1));\n\treturn 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\n\nusing namespace std;\ntypedef long long int ll;\ntypedef pair<int, int> P;\ntypedef pair<ll, ll> Pll;\ntypedef vector<int> Vi;\ntypedef tuple<int, int, int> T;\n#define FOR(i,s,x) for(int i=s;i<(int)(x);i++)\n#define REP(i,x) FOR(i,0,x)\n#define ALL(c) c.begin(), c.end()\n#define DUMP( x ) cerr << #x << \" = \" << ( x ) << endl\n\n/*\nRange Sum Query by FenwickTree(Binary Indexed Tree)\n\ntotal number: n\nqueries:\n    1. update(i, val): add val to i-th value \n    2. query(n): sum(bit[0] + ... + bit[n-1])\ntime complexity: O(log n)\nspace complexity: O(N)\n\nSelf-balancing binary search tree or Segment Tree can do the same, it takes longer to program and complexity also increases.\n\nThanks: http://hos.ac/slides/20140319_bit.pdf\n    \nused in ARC031 C, indeednow finalB E, DSL2B(AOJ), ARC033 C, yukicoder No.59\n*/\n\nstruct RangeSumQuery {\n  int N;\n  vector<int> dat;\n\n  RangeSumQuery(int N) : N(N) { dat.resize(N, 0); }\n\n  void update(int k, int val) {\n    for (int x = k; x < N; x |= x + 1) {\n      dat[x] += val;\n    }\n  }\n\n  int query(int k) {\n    int ret = 0;\n    for (int x = k - 1; x >= 0; x = (x & (x + 1)) - 1) {\n      ret += dat[x];\n    }\n    return ret;\n  }\n};\n\nint main() {\n  // use scanf in CodeForces!\n  cin.tie(0);\n  ios_base::sync_with_stdio(false);\n\n  int N;\n  cin >> N;\n  RangeSumQuery bit(N);\n\n  vector<P> load;\n  REP(i, N) {\n    int x;\n    cin >> x;\n    load.push_back(P(-x, i));\n    bit.update(i, x);\n  }\n  sort(ALL(load));\n  int ans = 0;\n  for (P p : load) {\n    int weight = -p.first, index = p.second;\n    ans += min(weight, bit.query(N) - bit.query(index + 1));\n    bit.update(index, -weight);\n  }\n  cout << ans << endl;\n  return 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include<iostream>\n#include<algorithm>\nusing namespace std;\ntypedef long long ll;\nll dp[110000], x[110000], n, s, rmq[110000];\nvoid update(int i, long long x) { i += 131072; rmq[i] = x; while (i > 1) i /= 2, rmq[i] = max(rmq[i * 2], rmq[i * 2 + 1]); }\nlong long query(int p, int q, int k, int l, int r) {\n\tif (r <= p || q <= l) return 0;\n\tif (p <= l && r <= q) return rmq[k];\n\tlong long vl = query(p, q, 2 * k, l, (l + r) / 2);\n\tlong long vr = query(p, q, 2 * k + 1, (l + r) / 2, r);\n\treturn max(vl, vr);\n}\nint main() {\n\tcin >> n; for (int i = 0; i < n; i++) { cin >> x[i]; dp[i] = x[i]; s += x[i]; }\n\tfor (int i = 1; i < n; i++) {\n\t\tdp[i] = query(0, x[i], 1, 0, 131072) + x[i];\n\t\tupdate(i, dp[i]);\n\t}\n\tcout << s - dp[n - 1] << endl;\n\treturn 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include<iostream>\n#include<algorithm>\n\nusing namespace std;\n\ntypedef long long Int;\n\nInt bit[105000], num[105000], n;\n\nvoid setnum(int pos, Int val){\n\twhile(pos < 105000){\n\t\tbit[pos] = max(val, bit[pos]);\n\t\tpos += pos & -pos;\n\t}\n}\n\nInt maxnum(int pos){\n\tInt res = 0;\n\twhile(pos){\n\t\tres = max(res, bit[pos]);\n\t\tpos -= pos &-pos;\n\t}\n\treturn res;\n}\n\nInt solve(){\n\tfill(bit, bit + 105000, 0);\n\tInt sum = 0, x;\n\tfor(int i = 0;i < n;i++){\n\t\tx = num[i];\n\t\tsum += x;\n\t\tInt p = x + maxnum(x);\n\t\tsetnum(x, p);\n\t}\n\treturn sum - maxnum(10100);\n}\n\nint main(){\n\tcin >> n;\n\tfor(int i = 0;i < n;i++)cin >> num[i];\n\tInt res = solve();\n\tfor(int i = 0;i < n;i++){\n\t\tint p = n - i - 1;\n\t\tif(p <= i)break;\n\t\tswap(num[p], num[i]);\n\t}\n\tcout << res << endl;\n\treturn 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\n\n#define ALL(a) (a).begin(). (a).end()\ntypedef long long ll;\n\nusing namespace std;\n\nint main(){\n\tint n; cin >> n;\n\n\tvector<ll> dp(n,0);\n\tvector<ll> sum(n,0);\n\tvector<ll> a(n);\n\tfor(auto &e : a)cin >> e;\n\tfor(auto itr = a.rbegin(); itr != a.rend(); ++itr){\n\t\tint idx = distance(dp.begin(),lower_bound(ALL(dp), a))-1;\n\t\tdp[idx] = *itr;\n\t\tsum[idx] = *itr;\n\t\tif(idx != 0){\n\t\t\tsum[idx] += sum[idx-1];\n\t\t}\n\t}\n\tll ans = a.accumulate() - max_element(ALL(sum));\n\tcout << ans << endl;\n\treturn 0;\n}\n\n"
  },
  {
    "language": "C++",
    "code": "#include<bits/stdc++.h>\n#define N (1<<17)\nusing namespace std;\ntypedef long long ll;\ntypedef pair<ll,ll> P;\nll n,x[N];\n\n\nclass RMQ{\npublic:\n  ll n,dat[2*N-1];\n  //?????????\n  RMQ(){};\n  RMQ(int n_){\n    //????´???°n???2???????????????\n    n=1;\n    while(n<n_)n*=2;\n    for(int i=0;i<2*n-1;i++)dat[i]=INT_MAX;\n  }\n  \n  //k???????????????a????????´\n  void update(int k,int a){\n    k+=n-1;\n    dat[k]=a;\n    while(k>0){\n      k=(k-1)/2;\n      dat[k]=min(dat[k*2+1],dat[k*2+2]);\n    }\n  }\n\n  //[a,b)???????°????????±???????\n  //query(a,b,0,0,n)\n  ll query(int a,int b,int k,int l,int r){\n    if(r<=a||b<=l)return INT_MAX;\n    if(a<=l&&r<=b)return dat[k];\n    else{\n      int v1=query(a,b,k*2+1,l,(l+r)/2);\n      int vr=query(a,b,k*2+2,(l+r)/2,r);\n      return min(v1,vr);\n    }\n  }\n};\n\nclass BIT{\npublic:\n  ll bit[N+1],n;\n  BIT(){};\n  BIT(int n){this->n=n,memset(bit,0,sizeof(bit));}\n  \n  ll sum(int i){\n    if(i<=0) return 0;\n    ll s=0;\n    while(i>0){\n      s+=bit[i];\n      i-=i&-i;\n    }\n    return s;\n  }\n\n  void add(int i,int x){\n    while(i<=n){\n      bit[i]+=x;\n      i+=i&-i;\n    }\n  }\n};\n\n\nRMQ rmq;\nint search(int x,int R){\n  int L=0,idx=R,M;\n  while(L<R){\n    M=(R+L)/2;\n    if(-rmq.query(M,idx+1,0,0,rmq.n)==x)R=M;\n    else L=M+1;\n  }\n\n  if(L==0||-rmq.dat[L+rmq.n-2]<x) return x;\n  return -rmq.dat[L+rmq.n-2];\n}\n\nint main(){  \n  cin>>n;\n  rmq=RMQ(n);\n  for(int i=0,a;i<n;i++){\n    cin>>a;\n    rmq.update(i,-a);\n    x[a]=i;\n  }\n  \n  BIT B(n);\n  ll ans=0;  \n  for(int i=1;i<=n;i++){\n    int mn=search(i,x[i]);\n    if(mn==i)ans+=min((ll)i,B.sum(n)-B.sum(i-1));\n    else {\n      int cost=B.sum(i)-B.sum(i-1);\n      B.add(mn,i);\n      ans+=cost;\n      B.add(i,-cost);\n    }\n  }\n  cout <<ans<<endl;\n  return 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\nusing namespace std;\nusing ll = long long;\n\nint n, x;\nll b[100001];\n\nll find(int s) {\n\tll res = 0;\n\tfor (int i = s; i > 0; i = i & (i - 1))\n\t\tres = max(res, b[i]);\n\treturn res;\n}\n\nvoid update(int s, ll val) {\n\tfor (int i = s; i <= n; i += (i & -i))\n\t\tb[i] = max(b[i], val);\n}\n\nint main()\n{\n\tscanf(\"%d\", &n);\n\tfor (int i = 0; i < n; i++) {\n\t\tscanf(\"%d\", &x);\n\t\tupdate(x, find(x - 1) + x);\n\t}\n\tprintf(\"%lld\\n\", (ll)n * (n + 1) / 2 - find(n));\n\treturn 0;\n}"
  },
  {
    "language": "C++",
    "code": "// g++ -std=c++11 a.cpp\n#include<iostream>\n#include<vector>\n#include<string>\n#include<algorithm>\t\n#include<map>\n#include<set>\n#include<unordered_map>\n#include<utility>\n#include<cmath>\n#include<random>\n#include<cstring>\n#include<queue>\n#include<stack>\n#include<bitset>\n#include<cstdio>\n#include<sstream>\n#include<iomanip>\n#include<assert.h>\n#include<typeinfo>\n#define loop(i,a,b) for(int i=a;i<b;i++) \n#define rep(i,a) loop(i,0,a)\n#define FOR(i,a) for(auto i:a)\n#define pb push_back\n#define all(in) in.begin(),in.end()\n#define shosu(x) fixed<<setprecision(x)\n#define show1d(v) rep(i,v.size())cout<<\" \"<<v[i];cout<<endl;\n#define show2d(v) rep(i,v.size()){rep(j,v[i].size())cout<<\" \"<<v[i][j];cout<<endl;}cout<<endl;\nusing namespace std;\n//kaewasuretyuui\ntypedef long long ll;\n//#define int ll\ntypedef ll Def;\ntypedef pair<Def,Def> pii;\ntypedef vector<Def> vi;\ntypedef vector<vi> vvi;\ntypedef vector<pii> vp;\ntypedef vector<vp> vvp;\ntypedef vector<string> vs;\ntypedef vector<double> vd;\ntypedef vector<vd> vvd;\ntypedef pair<Def,pii> pip;\ntypedef vector<pip>vip;\n//#define mt make_tuple\n//typedef tuple<int,int,int> tp;\n//typedef vector<tp> vt;\ntemplate<typename A,typename B>bool cmin(A &a,const B &b){return a>b?(a=b,true):false;}\ntemplate<typename A,typename B>bool cmax(A &a,const B &b){return a<b?(a=b,true):false;}\n//template<class C>constexpr int size(const C &c){return (int)c.size();}\n//template<class T,size_t N> constexpr int size(const T (&xs)[N])noexcept{return (int)N;}\nconst double PI=acos(-1);\nconst double EPS=1e-9;\nDef inf = sizeof(Def) == sizeof(long long) ? 2e18 : 1e9+10;\nint dx[]={0,1,0,-1};\nint dy[]={1,0,-1,0};\nclass BIT{\n\tpublic:\n\t//[1,i]\n\tint n;\n\tvi bit;\n//\tint bit[MAZ_N+1];\n\tBIT(int size){\n\t\tn=size;\n\t\tbit=vi(n+1);\n\t}\n\tDef query(int i){//sum\n\t\tDef s=0;\n\t\twhile(i>0){\n\t\t\ts=max(s,bit[i]);\n\t\t\ti-=i&-i;\n\t\t}\n\t\treturn s;\n\t}\n\tvoid add(int i,Def x){\n\t\twhile(i<=n){\n\t\t\tbit[i]=max(bit[i],x);\n\t\t\ti+=i&-i;\n\t\t}\n\t}\n};\nint main(){\n\tint n;\n\tcin>>n;\n\tBIT bit(n);\n\trep(i,n){\n\t\tint a;cin>>a;\n\t\tbit.add(a,bit.query(a)+a);\n\t}\n\tcout<<n*(n+1)/2-bit.query(n)<<endl;\n}\n\n\n\n\n\n"
  },
  {
    "language": "C++",
    "code": "#include <iostream>\n#include <vector>\n#include <utility>\n#include <algorithm>\nusing namespace std;\n\n#define INF 1e9\n\nclass SegmentTree{\npublic:\n  SegmentTree(int size)\n    : n(power2(size)),\n      node(vector<long long int>(2 * n - 1, NEUTRAL()))\n  {}\n  \n  SegmentTree(vector<long long int>& init){\n    n = power2(init.size());\n    node = vector<long long int>(2 * n - 1, NEUTRAL());\n    \n    // ????????????????????\\??????????????????\n    for(size_t i = 0; i < init.size(); i++){ node[n - 1 + i] = init[i]; }\n    // ????????????????????£?????????\n    for(int i = n - 2; i >= 0; i--){ node[i] = func(node[2 * i + 1], node[2 * i + 2]); }\n  }\n\n  // ???????????¨???\n  long long int RangeQuery(int a, int b){ return _RQ(a, b, 0, 0, n); }\n\n  // ??????????????????????????´\n  void change(int index, long long int value){\n    int k = n - 1 + index;\n    node[k] = value;\n    update((k - 1) / 2);\n  }\n\n  // ??¨????????? (???????????°??¨)\n  void print(){\n    int h = 1, cnt = 1;\n    for(size_t i = 0; i < node.size(); i++){\n      cout << \"[\" << node[i] << \"]\";\n      if(h <= cnt){\n        cout << endl;\n        h *= 2;\n        cnt = 0;\n      }\n      cnt++;\n    }\n  }\n\nprivate:\n  int n;\n  vector<long long int> node;\n\n  // ????????¢??°\n  // ??????????°??????¨????????? min(x, y), ??????????????? x + y ??????\n  long long int func(long long int x, long long int y){ return max(x, y); }\n  // ?????????\n  // ??????????°??????¨????????? ??¨??§?????°, ??????????????? 0 ??????\n  long long int NEUTRAL(){ return 0; }\n  \n  // s??\\?????§??????????°????2^n????±???????\n  int power2(int s){\n    int logs = 32 - __builtin_clz(s);\n    return 1 << logs;\n    //int count, ans = 1;\n    //for(count = 0; s != 0; count++){ s /= 2; }\n    //for(int i = 0; i < count; i++){ ans *= 2; }\n    //return ans;\n  }\n\n  // [a, b)???????????§????????????????±??????????\n  // ????????????[l, r)???????????§???????????????node[k]??§??????\n  long long int _RQ(int a, int b, int k, int l, int r){\n    // [l, r)???????????£??????[a, b)???????????£?????´?????????????????????????????????\n    if(r <= a || b <= l){ return NEUTRAL(); }\n    // [l, r)???????????£??????[a, b)??????????????????????????´????????????????????????????????????\n    if(a <= l && r <= b){ return node[k]; }\n    \n    // 2????????????????????§????????????????????°???????±???????????????????????????????????????????\n    int vl = _RQ(a, b, 2 * k + 1, l, (l + r) / 2);\n    int vr = _RQ(a, b, 2 * k + 2, (l + r) / 2, r);\n    return func(vl, vr);\n  }\n\n  // node[k]?????´??°\n  void update(long long int k){\n    if(k < 0){ return; }\n    \n    int prior = node[k];\n    node[k] = func(node[2 * k + 1], node[2 * k + 2]);\n    // ??´??°?????¨??????????????????????????£?????? or ??????????????§??´??°???????????£?????????\n    // ????????????????????´??°??????????????????????????§return\n    if(node[k] == prior || k <= 0){ return; }\n\n    // ????????´??°???????????????????????°?¶???????\n    update((k - 1) / 2);\n  }\n};\n\n\n\nint main(void){\n  int n;\n  cin >> n;\n  long long int sum = 0;\n  int max_input = 0;\n  vector<int> input(n); \n  for(int i = 0; i < n; i++){\n    cin >> input[i];\n    sum += input[i];\n    max_input = max(max_input, input[i]);\n  }\n\n  SegmentTree taro(max_input + 1);\n\n  for(int i = 0; i < n; i++){\n    taro.change(input[i], taro.RangeQuery(0, input[i]) + input[i]);\n  }\n\n  cout << sum - taro.RangeQuery(0, max_input + 1) << endl;\n  return 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include<iostream>\n#include<algorithm>\nusing namespace std;\nlong long dp[110000], x[110000], n, s;\nint main() {\n\tcin >> n; for (int i = 0; i < n; i++) { cin >> x[i]; dp[i] = x[i]; s += x[i]; }\n\tfor (int i = 1; i < n; i++) {\n\t\tfor (int j = 0; j < i; j++) {\n\t\t\tif (x[j] < x[i])dp[i] = max(dp[i], dp[j] + x[i]);\n\t\t}\n\t}\n\tcout << s - dp[n - 1] << endl;\n\treturn 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include <cstdio>\n#include <iostream>\n#include <vector>\n#include <list>\n#include <cmath>\n#include <fstream>\n#include <algorithm>\n#include <string>\n#include <queue>\n#include <set>\n#include <map>\n#include <complex>\n#include <iterator>\n#include <cstdlib>\n#include <cstring>\n#include <sstream>\n#include <stack>\n#include <climits>\n#include <deque>\n\nusing namespace std;\n\ntypedef long long ll;\ntypedef pair<int,int> pii;\ndouble EPS=1e-10;\ndouble EQ(double a,double b){\n    return abs(a-b)<EPS;\n}\nvoid fast_stream(){\n  std::ios_base::sync_with_stdio(0);\n}\ntemplate<class T>\nstring IntToString(T num){\n  string res;stringstream ss;ss<<num;\n  return ss.str();\n}\nll StringToInt(string &str){\n  ll res=0;\n  for(int i=0;i<(int)str.size();i++)\n    res=(res*10+str[i]-'0');\n  return res;\n}\nconst int MAX_N=1<<20;\nconst ll INF=1LL<<50;\nclass RMQ{\npublic:\n  // セグメント木を持つグローバル配列\n  int n;\n  ll dat[2*MAX_N-1];\n  // 初期化\n  void init(int n_){\n    n=1;\n    while(n<n_)n*=2;\n    fill(dat,dat+2*n-1,0);\n  }\n  // k番目の値(0-indexed)をaに変更\n  void update(int k,ll a){\n    // 葉の節点\n    k+=n-1;\n    dat[k]=a;\n    // のぼりながら更新\n    while(k>0){\n      k=(k-1)/2;\n      dat[k]=max(dat[k*2+1],dat[k*2+2]);\n    }\n  }\n  // [a,b)の最大値を求める\n  // kは節点の番号、l,rはその節点が[l,r)に対応づいていることを表す\n  // したがって、外からはquery(a,b,0,0,n)として呼ぶ\n  ll _query(int a,int b,int k,int l,int r){\n    if(r<=a||b<=l)return 0;\n    else if(a<=l&&r<=b)return dat[k];\n    ll vl=_query(a,b,k*2+1,l,(l+r)/2);\n    ll vr=_query(a,b,k*2+2,(l+r)/2,r);\n    return max(vl,vr);\n  }\n  ll query(int a,int b){\n    return _query(a,b,0,0,n);\t\n  }\n};\nint as[1000001];\nll dp[100001];\nll sum;\nRMQ rmq;\nint main(){\n  int n;\n  cin>>n;\n  for(int i=0;i<n;i++){\n    cin>>as[i];\n    sum+=as[i];\n  }\n  rmq.init(n+1);\n  rmq.update(as[0],as[0]);\n  ll res=as[0];\n  for(int i=1;i<n;i++){\n    ll val=rmq.query(0,as[i]);\n    rmq.update(as[i],val+as[i]);\n    res=max(res,val+as[i]);\n  }\n  cout<<sum-res<<endl;\n  return 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\nusing namespace std;\n\n#define REP(i,n) for(int i=0;i<(int)n;++i)\n#define FOR(i,c) for(__typeof((c).begin())i=(c).begin();i!=(c).end();++i)\n#define ALL(c) (c).begin(), (c).end()\n\nclass RMQ{\nprivate:\n    static const int MAX_N = 1 << 17;\n    int n, dat[2*MAX_N -1];\n    int rec(int a,int b,int k,int l,int r){\n        if(b <= l || r <= a){\n            return 0;\n        }\n        \n        if(a<=l && r<=b){\n            return dat[k];\n        }else{\n            int rl = rec(a,b,2*k+1,l,(l+r)/2);\n            int rr = rec(a,b,2*k+2,(l+r)/2,r);\n            return max(rl,rr);\n        }\n    }\n    \npublic:\n    void init(int n_){\n        n=1;\n        while(n < n_) n <<= 1;\n        \n        for(int i=0;i<2*n-1;i++){\n            dat[i] = 0;\n        }\n    }\n    void update(int k, int a){\n        int reaf = k+n-1;\n        dat[reaf]=a;\n        while(reaf>0){\n            reaf = (reaf-1)>>1;\n            dat[reaf]=max(dat[reaf*2+1],dat[2*reaf+2]);\n        }\n    }\n    int query(int a,int b){\n        return rec(a,b+1,0,0,n);\n    }\n};\n\nint a[100010], ind[100010];\n\nint main(){\n    while (true) {\n        int n;\n        cin >> n;\n        if (!n) return 0;\n        \n        long long m = n * (long long)(n + 1) / 2;\n        for (int i = 0; i < n; ++i) {\n            cin >> a[i];\n            ind[a[i] - 1] = i;\n        }\n        RMQ r;\n        r.init(n);\n        for (int i = 0; i < n; ++i) {\n            r.update(ind[i], r.query(0, ind[i]) + i + 1);\n        }\n        cout << m - r.query(0, n) << \"\\n\";\n        \n        return 0;\n    }\n    return 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include <algorithm>\n#include <cctype>\n#include <cmath>\n#include <cstdio>\n#include <cstdlib>\n#include <cstring>\n#include <cassert>\n#include <functional>\n#include <iostream>\n#include <iomanip>\n#include <iterator>\n#include <map>\n#include <queue>\n#include <set>\n#include <sstream>\n#include <utility>\n#include <vector>\n\nusing namespace std;\n\ntypedef long long Long;\n#define whole(xs) xs.begin(), xs.end()\n\nint INF = 1<<28;\n\nint N;\nvector<int> xs;\n\nbool input() {\n    cin >> N;\n    xs.resize(N);\n    for (int i = 0; i < N; i++) cin >> xs[i];\n    return true;\n}\n\nint C(map<int, int>& L, int x) {\n    map<int, int>::iterator it = L.lower_bound(x);\n    if (it == L.begin()) return -INF;\n    it--;\n    return it->second;\n}\n\nvoid D(map<int, int>& L, int x) {\n    map<int, int>::iterator it1 = L.find(x);\n    assert(it1 != L.end());\n    map<int, int>::iterator it = it1;\n    vector< map<int, int>::iterator > del;\n    if (it != L.begin()) {\n        it1--;\n        if (it1->second >= it->second) {\n            del.push_back(it);\n        }\n    }\n    it1 = it;\n    it1++;\n    while (it1 != L.end() && it->second >= it1->second) {\n        del.push_back(it1);\n        it++;\n    }\n    for (int i = 0; i < del.size(); i++) {\n        L.erase(del[i]);\n    }\n}\n\nvoid solve() {\n    map<int, int>* dp = new map<int, int>[N + 1];\n    dp[0][0] = 0;\n    for (int i = 0; i < N; i++) {\n        int lb = 0, ub = N + 1;\n        while (lb + 1 < ub) {\n            int mid = (lb + ub) / 2;\n            int r = C(dp[mid], xs[i]);\n            (r >= 0 ? lb : ub) = mid;\n        }\n        int r = C(dp[lb], xs[i]) + xs[i];\n        dp[lb + 1][xs[i]] = r;\n        D(dp[lb + 1], xs[i]);\n    }\n    int Ans = 0;\n    for (int i = 0; i <= N; i++) {\n        if (!dp[i].empty()) {\n            map<int, int>::iterator it = dp[i].end();\n            it--;\n            Ans = max(Ans, it->second);\n        }\n    }\n    /*\n    for (int i = 0; i <= N; i++) {\n        for (map<int, int>::iterator it = dp[i].begin(); it != dp[i].end(); it++) {\n            cout << \"(\" << it->first << \", \" << it->second << \")\";\n        }\n        cout << endl;\n    }\n    */\n    cout << N * (N + 1) / 2 - Ans << endl;\n}\n\nint main() {\n    input(); solve();\n    return 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\nusing namespace std;\n\n#define for_(i,a,b) for(int i=(a);i<(b);++i)\n#define for_rev(i,a,b) for(int i=(a);i>=(b);--i)\ntypedef long long lint;\n\nclass FenwickTree {\nprivate:\n\tint n;\n\tvector< lint > data;\n\t\npublic:\n\tFenwickTree(int __n) : n(__n), data(__n+1, 0) {}\n\t\n\tlint sum(int i) {\n\t\tlint res = 0;\n\t\twhile (i) {\n\t\t\tres += data[i];\n\t\t\ti -= i & -i;\n\t\t}\n\t\treturn res;\n\t}\n\t\n\tvoid add(int i, lint x) {\n\t\twhile (i <= n) {\n\t\t\tdata[i] += x;\n\t\t\ti += i & -i;\n\t\t}\n\t}\n};\n\nint main() {\n\tint n;\n\tcin >> n;\n\t\n\tvector< lint > x(n);\n\tfor_(i,0,n) cin >> x[i];\n\t\n\tFenwickTree bit(n+1);\n\t\n\tlint ans = 0;\n\tfor_rev(i,n-1,0) {\n\t\tans += min(x[i], bit.sum(x[i]));\n\t\tbit.add(x[i], x[i]);\n\t}\n\tcout << ans << endl;\n}"
  },
  {
    "language": "C++",
    "code": "#include \"bits/stdc++.h\"\n\nusing namespace std;\n\nusing i64 = long long;\n\nconst i64 MOD = 1e9 + 7;\nconst i64 INF = 1e18 + 7;\n\ntemplate <typename T>\nbool chmin(T& x, T y){\n    if(x > y){\n        x = y;\n        return true;\n    }\n    return false;\n}\n\ntemplate <typename T>\nbool chmax(T& x, T y){\n    if(x < y){\n        x = y;\n        return true;\n    }\n    return false;\n}\n\n\ntemplate<typename T, typename U>\nstruct Segtree{\n    int n;\n    T op_t;\n    U op_u;\n    vector<T> elm;\n    vector<U> lazy;\n    vector<int> length;\n    function<T(T, T)> f;\n    function<T(T, U, int)> g;\n    function<U(U, U)> h;\n\n    Segtree(int n, T init, function<T(T, T)> f, function<T(T, U, int)> g, function<U(U, U)> h, T op_t = T(), U op_u = U()) :\n        n(n),\n        op_t(op_t),\n        op_u(op_u),\n        elm(2 * n, init),\n        lazy(2 * n, op_u),\n        length(2 * n, 0),\n        f(f),\n        g(g),\n        h(h)\n    {\n        for(int i = n - 1; i > 0; --i){\n            elm[i] = f(elm[2 * i], elm[2 * i + 1]);\n            length[i] = length[2 * i] + 1;\n        }\n    }\n\n    Segtree(int n, vector<T> init, function<T(T, T)> f, function<T(T, U, int)> g, function<U(U, U)> h, T op_t = T(), U op_u = U()) :\n        n(n),\n        op_t(op_t),\n        op_u(op_u),\n        elm(2 * n),\n        lazy(2 * n, op_u),\n        length(2 * n, 0),\n        f(f),\n        g(g),\n        h(h)\n    {\n        for(int i = 0; i < n; ++i)\n            elm[i + n] = init[i];\n\n        for(int i = n - 1; i > 0; --i){\n            elm[i] = f(elm[2 * i], elm[2 * i + 1]);\n            length[i] = length[2 * i] + 1;\n        }\n    }\n\n    vector<int> get_list(int x, int y){\n\n        vector<int> ret_list;\n        for(x += n, y += n - 1; x; x >>= 1, y >>= 1){\n            ret_list.emplace_back(x);\n            if(x != y)\n                ret_list.emplace_back(y);\n        }\n\n        return ret_list;\n    }\n\n    void eval(int x){\n\n        elm[x] = g(elm[x], lazy[x], 1 << length[x]);\n        if(x < n){\n            lazy[2 * x] = h(lazy[2 * x], lazy[x]);\n            lazy[2 * x + 1] = h(lazy[2 * x + 1], lazy[x]);\n        }\n        lazy[x] = op_u;\n    }\n\n    void update(int x, int y, U val){\n\n        vector<int> index_list = get_list(x, y);\n        for(int i = index_list.size() - 1; i >= 0; --i)\n            eval(index_list[i]);\n\n        for(x += n, y += n - 1; x <= y; x >>= 1, y >>= 1){\n            if(x & 1){\n                lazy[x] = h(lazy[x], val);\n                eval(x++);\n            }\n            if(!(y & 1)){\n                lazy[y] = h(lazy[y], val);\n                eval(y--);\n            }\n        }\n\n        for(auto index : index_list){\n            if(index < n){\n                eval(2 * index);\n                eval(2 * index + 1);\n                elm[index] = f(elm[2 * index], elm[2 * index + 1]);\n            }\n        }\n    }\n\n    T get(int x, int y){\n\n        vector<int> index_list = get_list(x, y);\n        for(int i = index_list.size() - 1; i >= 0; --i)\n            eval(index_list[i]);\n\n        T l = op_t, r = op_t;\n        for(x += n, y += n - 1; x <= y; x >>= 1, y >>= 1){\n            if(x & 1){\n                eval(x);\n                l = f(l, elm[x++]);\n            }\n            if(!(y & 1)){\n                eval(y);\n                r = f(elm[y--], r);\n            }\n        }\n        return f(l, r);\n    }\n};\n\n\nsigned main(){\n    int n;\n    cin >> n;\n    vector<int> a(n + 1, 0);\n    for(int i = 0; i < n; ++i)\n        cin >> a[i + 1];\n    ++n;\n\n    Segtree<i64,i64> seg(n, 0, [](auto x, auto y){return min(x, y);}, [](auto x, auto y, auto){return x + y;}, [](auto x, auto y){return x + y;}, 2 * INF, 0);\n\n    seg.update(1, n, INF);\n    for(int i = 1; i < n; ++i){\n\n        int v = a[i];\n        // get min\n        auto res = seg.get(0, v);\n\n        seg.update(v, v + 1, -1 * seg.get(v, v + 1));\n\n        seg.update(v, v + 1, res);\n\n        // range add\n        seg.update(0, v, v);\n        seg.update(v + 1, n, v);\n\n    }\n    cout << seg.get(0, n) << endl;\n}\n\n"
  },
  {
    "language": "C++",
    "code": "#include <iostream>\n//#include <cstdio>\n//#include <cmath>\n#include <vector>\n#include <algorithm>\n#include <string>\n#include <map>\n//#include <set>\n#include <queue>\n//#include <limits>\n#include <sstream>\n//#include <functional>\nusing namespace std;\n\n#define len(array)  (sizeof (array) / sizeof *(array))\n#define rep(i, s, e) for(int i = s;i < e;i++)\n#define rrep(i, e, s) for(int i = e;s <= i;i--)\n#define mfill(a, v) fill(a, a + len(a), v)\n#define mfill2(a, v, t) fill((t *)a, (t *)(a + len(a)), v)\n#define vsort(v) sort(v.begin(), v.end())\n#define rvsort(v, t) sort(v.begin(), v.end(), greater<t>())\n#define asort(a) sort(a, a + len(a))\n#define rasort(a, t) sort(a, a + len(a), greater<t>())\ntypedef unsigned int ui;\ntypedef long long ll;\ntypedef unsigned long long ull;\ntypedef pair<int, int> P;\nconst int INF = (int)1e9;\nconst int MOD = (int)1e9 + 7;\nconst double EPS = 1e-10;\nconst int dx[] = {1, -1, 0, 0, 1, -1, -1, 1};\nconst int dy[] = {0, 0, 1, -1, -1, -1, 1, 1};\nconst int weight[] = {0,1,10,100,1000,10000,100000,1000000,10000000};\n\n\nconst int MAX_N = 100000 + 2;\nll bit[MAX_N], input[MAX_N], n;\n\n\nvoid add(int idx, ll val, ll* ary){\n  int p = idx;\n  while(p < MAX_N){\n\tary[p] = max(ary[p], val);\n\tp += p & -p;\n  }\n}\n\nll get(int idx, ll *ary){\n  ll res = 0;\n  int p = idx;\n  while(0 < p){\n\tres = max(res, ary[p]);\n\tp -= p & -p;\n  }\n  return res;\n}\n\nvoid doIt(){\n  cin >> n;\n  rep(i, 0, n) cin >> input[i];\n  mfill(bit, 0);\n  rep(i, 0, n){\n\tadd(input[i], get(input[i], bit) + input[i], bit);\n  }\n  cout << n*(n+1)/2 - get(n, bit) << endl;\n}\n\nint main() {\n  doIt();\n  return 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include<cstdio>\n#include<algorithm>\nusing namespace std;\n\ntypedef long long ll;\n\nll n, x[100001];\nll N, dat[400001], dp[100001];\n\nvoid init() {\n  N = 1;\n  while (N < n + 1) N *= 2;\n  for (int i = 0; i < 2 * N - 1; i++) dat[i] = 0;\n}\n\nvoid update(ll k, ll a) {\n  k += N - 1;\n  dat[k] = a;\n  while (k > 0) {\n    k = (k - 1) / 2;\n    dat[k] = max(dat[k * 2 + 1], dat[k * 2 + 2]);\n  }\n}\n\nll query(ll a, ll b, ll k, ll l, ll r) {\n  if (r <= a || b <= l) return -1;\n  if (a <= l && r <= b) return dat[k];\n  else {\n    ll vl = query(a, b, k * 2 + 1, l, (l + r) / 2);\n    ll vr = query(a, b, k * 2 + 2, (l + r) / 2, r);\n    return max(vl, vr);\n  }\n}\n\nll seg(ll a) {\n  //printf(\"a: %lld \",a);\n  return query(0, a, 0, 0, N);\n}\n\n\nint main() {\n  scanf(\"%lld\", &n);\n  init();\n  for (int i = 1; i <= n; i++) scanf(\"%lld\", &x[i]);\n  for (int i = 1; i <= n; i++) {\n    dp[i] = seg(x[i]) + x[i];\n    update(x[i], dp[i]);\n  }\n  ll ans = 0;\n  for (int i = 1; i <= n; i++) ans = max(ans, dp[i]);\n  printf(\"%lld\\n\", n * (n + 1) / 2 - ans);\n}\n"
  },
  {
    "language": "C++",
    "code": "#include <iostream>\n#include <algorithm>\n#include <vector>\n#include <queue>\n#include <cstring>\n#include <string>\n#include <cstdlib>\n#include <cstdio>\nusing namespace std;\ntypedef long long int ll;\n\n// 配列を拡張してRMQに対応させる\nvoid rmq_ext(vector<int>& v) {\n    int n = v.size();\n    v.resize(n*2);\n    for(int i = n; i < 2*n; i++)\n        v[i] = max(v[(i-n)*2+0], v[(i-n)*2+1]);\n}\n// 列の要素を書き換える\nvoid rmq_update(vector<int>& rmq, int pos, const int& value) {\n    int n = rmq.size() / 2;\n    rmq[pos] = value;\n    while(pos < 2*n-1) {\n        rmq[pos/2+n] = max(rmq[pos], rmq[pos^1]);\n        pos = pos/2+n;\n    }\n}\n// [from, to)の最小値を取り出す\nint rmq_query(const vector<int>& rmq, int from, int to) {\n    int n = rmq.size() / 2;\n    int p = min((from == 0 ? 32 : __builtin_ctz(from)), 31-__builtin_clz(to-from));\n    int x = rmq[(from>>p)|((n*2*((1<<p)-1))>>p)];\n    from += 1<<p;\n    if (from < to)\n        x = max(x, rmq_query(rmq, from, to));\n    return x;\n}\n\nint n;\nmain(){\n\tint i,j;\n\twhile(cin >> n){\n\t\tint x;\n\t\tvector<int> dp(131072, 0);\n\t\trmq_ext(dp);\n\t\tfor(i=0;i<n;i++){\n\t\t\tcin >> x;\n\t\t\trmq_update(dp, x, rmq_query(dp, 0, x) + x);\n\t\t}\n\t\tcout << (ll)n*(n+1)/2 - rmq_query(dp, 0, n+1) << endl;\n\t}\n\treturn 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\n#define rep(i,n) for(int i = 0; i < n; i++)\nusing namespace std;\ntypedef long long ll;\ntypedef pair<ll,ll> P;\ntypedef pair<ll,P> PP;\nconst long long int MOD = 1000000007;\nconst int INF = 1000000000;\n\nstruct segtree{\n    ll n, dat[2*(1<<17)-1]; //(1<<17) = 130000\n\n    void init(ll n_){\n        n = 1;\n        while(n < n_) n *= 2;\n        for(ll i = 0; i < 2*n-1; i++) dat[i] = 0;\n    }\n\n    void update(ll k, ll a){\n        k += n-1;\n        dat[k] = a;\n        while(k > 0){\n            k = (k-1)/2;\n            dat[k] = max(dat[k*2+1], dat[k*2+2]);\n        }\n    }\n\n    ll query(ll a, ll b, ll k, ll l, ll r){\n        if(r <= a || b <= l) return 0;\n        if(a <= l && r <= b) return dat[k];\n        else{\n            ll vl = query(a,b,k*2+1,l,(l+r)/2);\n            ll vr = query(a,b,k*2+2,(l+r)/2,r);\n            return max(vl, vr);\n        }\n    }\n} seg;\n\nll n;\n\nint main(){\n    cin >> n;\n    seg.init(n);\n    ll ans = 0;\n    ll sum = 0;\n    rep(i,n){\n        ll x;\n        cin >> x;\n        sum += x;\n        x--;\n        ll v = seg.query(0,x,0,0,seg.n)+x+1;\n        ans = max(ans,v);\n        seg.update(x,v);\n    }\n    cout << sum-ans << endl;\n}"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\nusing namespace std;\nusing ll = long long;\nusing P = pair<ll, int>;\nconst ll MOD = 1000000007;\n\n// 0-origin BIT\ntemplate <typename T>\nclass BIT{\npublic:\n    vector<T> data;\n    int n;\n    BIT(){}\n    BIT(int n_){\n        n = n_;\n        data.assign(n, T(0));\n    }\n    // v[a] += w\n    void add(int a, T w){\n        for (int x = a; x < n; x |= x + 1) data[x] = max(data[x], w);\n    }\n    // sum of v[i] for i in [0, a)\n    T bmax(int a){\n        T ret = 0;\n        for (int x = a - 1; x >= 0; x = (x & (x + 1)) - 1) {\n            ret = max(ret, data[x]);\n        }\n        return ret;\n    }\n};\n\nint main(){\n    int n;\n    cin >> n;\n\n    vector<int> x(n);\n    ll total = 0;\n    for(int i=0;i<n;i++){\n        cin >> x[i];\n        total += x[i];\n    }\n\n    BIT<ll> bit(n+1);\n    for(int i=0;i<n;i++){\n        ll c = bit.bmax(x[i]) + x[i];\n        bit.add(x[i], c);\n    }\n    cout << total - bit.bmax(n+1) << endl;\n\n    return 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include <iostream>\n#include <algorithm>\n#include <set>\n#include <cstdio>\nusing namespace std;\n\ntypedef long long ll;\ntypedef pair<ll,ll> P;\n\nconst ll MAX = 100000;\n\nint main(){\n  int n;\n  while(cin >> n){\n    ll a[MAX],ans=0;\n    set<P> s;\n    for(int i=0;i<n;i++) scanf(\"%lld\",&a[i]);\n    for(int i=0;i<n;i++){\n      ll cnt = 0;\n      if(i > 0){\n\tset<P>::iterator it = s.end();\n\tit--;\n\twhile(1){\n\t  it = s.lower_bound(P(it->first,0));\n\t  if(it->second < a[i]){\n\t    cnt = it->first;\n\t    break;\n\t  } else if(it == s.begin()) break;\n\t  else it--;\n\t}\n      }\n      ans = max(ans,cnt+a[i]);\n      s.insert(P(cnt+a[i],a[i]));\n    }\n    printf(\"%lld\\n\",(ll)n*(n+1)/2 - ans);\n  }\n}"
  },
  {
    "language": "C++",
    "code": "#include<iostream>\n#include<algorithm>\nusing namespace std;\ntypedef long long ll;\nll dp[110000], x[110000], n, s, rmq[280000], v;\nvoid update(ll i, ll x) {\n\ti += v; rmq[i] = x;\n\twhile (i > 1) {\n\t\ti /= 2, rmq[i] = max(rmq[i * 2], rmq[i * 2 + 1]);\n\t}\n}\nlong long query(ll p, ll q, ll k, ll l, ll r) {\n\tif (r <= p || q <= l) return 0;\n\tif (p <= l && r <= q) return rmq[k];\n\tlong long vl = query(p, q, 2 * k, l, (l + r) / 2);\n\tlong long vr = query(p, q, 2 * k + 1, (l + r) / 2, r);\n\treturn max(vl, vr);\n}\nint main() {\n\tcin >> n; for (int i = 0; i < 20; i++) { if ((1 << i) < n) { v = (1 << (i + 1)); } }\n\tfor (int i = 0; i < n; i++) { cin >> x[i]; dp[i] = x[i]; s += x[i]; }update(x[0], dp[0]);\n\tfor (int i = 1; i < n; i++) {\n\t\tdp[i] = query(1, x[i], 1, 0, v) + x[i];\n\t\tupdate(x[i], dp[i]);\n\t}\n\tcout << s - dp[n - 1] << endl;\n\treturn 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include<cstdio>\n#include<cstring>\n#include<vector>\n#include<queue>\n#include<algorithm>\n#include<cmath>\n#include<climits>\n#include<string>\n#include<set>\n#include<map>\n#include<iostream>\nusing namespace std;\n#define rep(i,n) for(int i=0;i<((int)(n));i++)\n#define reg(i,a,b) for(int i=((int)(a));i<=((int)(b));i++)\n#define irep(i,n) for(int i=((int)(n))-1;i>=0;i--)\n#define ireg(i,a,b) for(int i=((int)(b));i>=((int)(a));i--)\ntypedef long long int lli;\ntypedef pair<int,int> mp;\n#define fir first\n#define sec second\n#define IINF INT_MAX\n#define LINF LLONG_MAX\n#define eprintf(...) fprintf(stderr,__VA_ARGS__)\n#define pque(type) priority_queue<type,vector<type>,greater<type> >\n#define memst(a,b) memset(a,b,sizeof(a))\n#define iter(v,ite) for(auto ite=(v).begin();ite!=(v).end();ite++)\n#define mimunum(v,x) distance((v).begin(),lower_bound((v).begin(),(v).end(),x))\n\nint n;\nlli seg[400005]={};\nlli dat[100005];\nint N;\nvoid init(){\n\tN=1;\n\twhile(N<=n+10)N*=2;\n}\n\nlli get(int l,int r,int a,int b,int k){\n\tif(r<=a || b<=l)return 0;\n\tif(a<=l && r<=b)return seg[k];\n\treturn max(\n\t\tget(l,(l+r)/2,a,b,k*2),\n\t\tget((l+r)/2,r,a,b,k*2+1));\n}\n\nvoid upd(int p,lli t){\n\tp+=N;\n\twhile(p>0){\n\t\tseg[p]=max(seg[p],t); p/=2;\n\t}\n}\n\nint main(void){\n\tscanf(\"%d\",&n);\n\tinit();\n\tlli s=0;\n\trep(i,n){\n\t\tscanf(\"%lld\",&dat[i]);\n\t\ts+=dat[i];\n\t}\n\t\n\trep(i,n){\n\t\tlli g=get(0,N,0,dat[i],1);\n\t\tupd(dat[i],g+dat[i]);\n\t\t//printf(\"%lld %lld %lld\\n\",g,dat[i],get(0,N,0,dat[i],1));\n\t}\n\n\tprintf(\"%lld\\n\",s-get(0,N,0,n+5,1));\n\t\t\n\treturn 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include <iostream>\n#include <iomanip>\n#include <sstream>\n#include <cstdio>\n#include <string>\n#include <vector>\n#include <algorithm>\n#include <complex>\n#include <cstring>\n#include <cstdlib>\n#include <cmath>\n#include <cassert>\n#include <climits>\n#include <queue>\n#include <set>\n#include <map>\n#include <valarray>\n#include <bitset>\n#include <stack>\nusing namespace std;\n\n#define REP(i,n) for(int i=0;i<(int)(n);++i)\n#define FOR(i,c) for(__typeof((c).begin())i=(c).begin();i!=(c).end();++i)\n#define ALL(c) (c).begin(), (c).end()\ntypedef long long ll;\ntypedef pair<int,int> pii;\nconst int INF = 1<<29;\nconst double PI = acos(-1);\nconst double EPS = 1e-8;\n\nconst int MAX_N = 200001;        // 131072\n\nstruct RMQ {\n  ll n;\n  ll dat[MAX_N * 2 - 1];\n  RMQ(ll _n) {\n    for (n=1; n<_n; n*=2);\n    fill(dat, dat+2*n-1, 0);\n  }\n  RMQ(vector<ll> v) {\n    for (n=1; n<v.size(); n*=2);\n    fill(dat, dat+2*n-1, 0);\n    copy(ALL(v),dat+n-1);\n    for (ll i=n-2; i>=0; --i)\n      dat[i] = max(dat[i*2+1], dat[i*2+2]);\n  }\n  void update(ll k, ll a) {\n    k += n - 1;\n    dat[k] = a;\n    while(k>0) {\n      k = (k-1) / 2;\n      dat[k] = max(dat[k*2 + 1], dat[k*2 + 2]);\n    }\n  }\n  ll query(ll a, ll b) { return q(a, b, 0, 0, n); }\n  ll q(ll a, ll b, ll k, ll l, ll r) {\n    if (r <= a || b <= l) return 0;\n    if (a <= l && r <= b) return dat[k];\n    return max(q(a, b, k*2+1, l, (l+r)/2),\n               q(a, b, k*2+2, (l+r)/2, r));\n  }\n};\n\nint main() {\n  int n;\n  cin >> n;\n  RMQ rmq(n+1);\n  ll hoge = 0;\n  ll ans = 0;\n  REP(i,n) {\n    ll x;\n    cin >> x;\n    ll a = rmq.query(0,x);\n    // cout << x << \" \" << a << endl;\n    rmq.update(x,a+x);\n    ans = max(ans, a+x);\n    hoge += x;\n  }\n  cout << hoge-ans << endl;\n}"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\nusing namespace std;\n \ntypedef long long int LLI;\ntypedef pair<LLI, int> Pair;\n \nint n;\nint size;\nLLI xs[1145141];\nLLI seg[1145141];\nmap<int, LLI> dp;\npriority_queue<Pair, vector<Pair>, greater<Pair> > q;\n \nvoid update(int k, LLI x) {\n  k += size-1;\n  seg[k] = x;\n  while (k > 0) {\n    k = (k-1)/2;\n    seg[k] = max(seg[k*2+1], seg[k*2+2]);\n  }\n}\n\nLLI getmax(int wishl, int wishr, int k, int watchl, int watchr) {\n  int mid;\n  LLI lval, rval;\n\n  if (wishr <= watchl || watchr <= wishl) return -1;\n  if (wishl <= watchl && watchr <= wishr) return seg[k];\n\n  mid = (watchl+watchr)/2;\n  lval = getmax(wishl, wishr, k*2+1, watchl, mid);\n  rval = getmax(wishl, wishr, k*2+2, mid, watchr);\n  return max(lval, rval);\n}\n\nint main() {\n  scanf(\"%d\", &n);\n  size = 1;\n  while (size < n) size *= 2;\n \n  LLI sum = 0;\n  for (int i=0; i<n; i++) {\n    scanf(\"%lld\", &xs[i]);\n    q.push(Pair(xs[i], i));\n    sum += xs[i];\n  }\n \n  while (!q.empty()) {\n    Pair p = q.top(); q.pop();\n    LLI v = p.first;\n    int idx = p.second;\n    LLI t = max(getmax(0, idx, 0, 0, size), 0LL) + v;\n    update(idx, t);\n  }\n \n  printf(\"%lld\\n\", sum - getmax(0, n, 0, 0, size));\n}"
  },
  {
    "language": "C++",
    "code": "#include <vector>\n#include <list>\n#include <map>\n#include <set>\n#include <deque>\n#include <stack>\n#include <bitset>\n#include <algorithm>\n#include <functional>\n#include <numeric>\n#include <utility>\n#include <sstream>\n#include <queue>\n#include <iostream>\n#include <iomanip>\n#include <cstdio>\n#include <cmath>\n#include <cstdlib>\n#include <cctype>\n#include <string>\n#include <cstring>\n#include <ctime>\n#include <fstream>\n#include <stdio.h>\n#include <complex>\n\nusing namespace std;\n\n//conversion\n//------------------------------------------\ninline int toInt(string s) {int v; istringstream sin(s);sin>>v;return v;}\ntemplate<class T> inline string toString(T x) {ostringstream sout;sout<<x;return sout.str();}\n\n//typedef\n//------------------------------------------\ntypedef vector<int> VI;\ntypedef vector<VI> VVI;\ntypedef vector<string> VS;\ntypedef pair<int, int> PII;\ntypedef pair<int, PII> TIII;\ntypedef long long LL;\ntypedef vector<LL> VLL;\n\n//container util\n\n//------------------------------------------\n#define ALL(a)  (a).begin(),(a).end()\n#define RALL(a) (a).rbegin(), (a).rend()\n#define PB push_back\n#define MP make_pair\n#define SZ(a) int((a).size())\n#define EACH(i,c) for(typeof((c).begin()) i=(c).begin(); i!=(c).end(); ++i)\n#define EXIST(s,e) ((s).find(e)!=(s).end())\n#define SORT(c) sort((c).begin(),(c).end())\n#define MT(a,b,c) MP(a, MP(b, c))\n\n//repetition\n//------------------------------------------\n#define FOR(i,a,b) for(int i=(a);i<(b);++i)\n#define REP(i,n)  FOR(i,0,n)\n\nclass SegTree{\n\tpublic:\n\tVLL dat;\n\tint n, b;\n\tint DEF;\n\tSegTree(int N){\n\t\tn = 1;\n\t\tDEF = 0;\n\t\twhile(n<N)n*=2;\n\t\tdat = VLL(2*n-1);\n\t\tREP(i, 2*n-1)dat[i] = DEF;\n\t}\n\tvoid update(int index, LL v){\n\t\tint k=index+n-1;\n\t\tdat[k]=v; \n\t\twhile(1){\n\t\t\tk=(k-1)/2;//上に登る\n\t\t\tdat[k] = value(k);\n\t\t\tif(k==0)break;\n\t\t}\n\t}\n\tinline int value(int idx){//Update value with (2*idx+1, 2*idx+2) \n\t\treturn value(dat[2*idx+1], dat[2*idx+2]);\n\t}\n\tinline LL value(int v1, int v2){\n\t\treturn max(v1, v2);\n\t}\n\tLL query(int idx1, int idx2, int node=0, int range1=0, int range2=-1){\n\t\tif(range2 <0 )range2 = n;\n\t\tif(range2 <= idx1 || idx2 <= range1)return DEF;//交差しない\n\t\tif(idx1 <= range1 && range2 <= idx2)return dat[node];\n\t\telse{\n\t\t\tint vl = query(idx1, idx2, node*2+1, range1, (range1+range2)/2);\n\t\t\tint vr = query(idx1, idx2, node*2+2, (range1+range2)/2, range2); \n\t\t\treturn value(vl, vr);\n\t\t}\n\t}\n};\n\nint main(){\n\tint n;\n\tcin >> n;\n\tSegTree seg(n);\n\tREP(i,n){\n\t\tint tmp;\n\t\tscanf(\"%d\", &tmp);\n\t\tLL v = seg.query(0, tmp-1);\n\t\tseg.update(tmp-1, v+tmp);\n\t}\n\tcout << n*(n+1)/2-seg.query(0, n)<< endl;\n\treturn 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include<iostream>\n#include<algorithm>\n\nusing namespace std;\n\ntypedef long long Int;\n\nInt bit[105000];\n\nvoid setnum(int pos, Int val){\n\twhile(pos < 105000){\n\t\tbit[pos] = max(val, bit[pos]);\n\t\tpos += pos & -pos;\n\t}\n}\n\nInt maxnum(int pos){\n\tInt res = 0;\n\twhile(pos){\n\t\tres = max(res, bit[pos]);\n\t\tpos -= pos &-pos;\n\t}\n\treturn res;\n}\n\nint main(){\n\tInt n, sum = 0, x;\n\tcin >> n;\t\n\tfor(int i = 0;i < n;i++){\n\t\tcin >> x;\n\t\tsum += x;\n\t\tInt p = p + maxnum(p);\n\t\tsetnum(x, p);\n\t}\n\tcout << sum - maxnum(10100) << endl;\n\treturn 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include<bits/stdc++.h>\nusing namespace std;\n#define int long long\nconst int MAX_N = 1 << 17;\nint bit[MAX_N+1],n;\nint sum(int i){\n  int s=0;\n  while(i>0){\n    s+=bit[i];\n    i-=i&-i;\n  }\n  return s;\n}\nvoid add(int i,int x){\n  while(i<=n){\n    bit[i]+=x;\n    i+=i&-i;\n  }\n}\nsigned main(){\n  memset(bit,0,sizeof(bit));\n  cin>>n;\n  int x[n],ans=0;\n  for(int i=0;i<n;i++) cin>>x[i];\n  n++;\n  for(int i=n-1;i>=0;i--){\n    //cout<<x[i]<<\":\"<<sum(x[i])<<endl;\n    ans+=min(x[i],sum(x[i]));\n    add(x[i],x[i]);\n  }\n  cout<<ans<<endl;\n  return 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include<iostream>\n#include<vector>\n#include<algorithm>\n#include<climits>\n\nconst int MAX_N=100000;\n\ntypedef long long ll;\n\nusing namespace std;\n\nll n,dat[2*MAX_N-1];\n\nvoid init(int n_){\n\tn=1;\n\twhile(n<n_)n*=2;\n}\n\nvoid update(int k,ll a){\n\tk+=n-1;\n\tdat[k]=a;\n\t\n\twhile(k>0){\n\t\tk=(k-1)/2;\n\t\tdat[k]=max(dat[2*k+1],dat[2*k+2]);\n\t}\n}\n\nll query(int a,int b,int k,int l,int r){\n\tif(r<=a || b<=l)return 0;\n\tif(a<=l && r<=b)return dat[k];\n\telse {\n\t\tll vl=query(a,b,k*2+1,l,(l+r)/2);\n\t\tll vr=query(a,b,k*2+2,(l+r)/2,r);\n\t\treturn max(vl,vr);\n\t}\n}\n\nint main(void){\n\t\n\tll in,m,ans=0;\n\t\n\tcin >> m;\n\t\n\tinit(m);\n\t\n\tfor(int i=0;i<m;i++){\n\t\tcin >> in;\n\t\tupdate(in,in+query(1,in+1,0,0,n));\n\t\t//ans=max(ans,dat[in+n-1]);\n\t}\n\tcout << m*(m+1)/2-query(1,m+1,0,0,n) << endl;\n\t\n\treturn 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include <iostream>\n#include <vector>\n#include <algorithm>\nusing namespace std;\nconst int inf = 1e9;\n\n//range min\nstruct segmentTree{\n\tvector<long long int> node;\n\tint n;\n\t\n\tsegmentTree(vector<long long int> v){\n\t\tint s = v.size();\n\t\tn = 2;\n\t\twhile(n < s) n *= 2;\n\t\tnode = vector<long long int>(2*n -1, inf);\n\t\tfor(int i=0; i<s; i++){\n\t\t\tnode[i +n-1] = v[i];\n\t\t}\n\t\tfor(int i=n-2; i>=0; i--){\n\t\t\tnode[i] = min(node[2*i +1], node[2*i +2]);\n\t\t}\n\t}\n\t\n\tvoid Set(long long int val, int pos){\n\t\tint idx = n-1 + pos;\n\t\tnode[idx] = val;\n\t\tdo{\n\t\t\tidx = (idx -1)/2;\n\t\t\tnode[idx] = min(node[2*idx +1], node[2*idx +2]);\n\t\t}while(idx != 0);\n\t}\n\tlong long int Get(int l, int r){\n\t\treturn _get(l, r, 0, 0, n);\n\t}\n\tlong long int _get(int l, int r, int k, int cl, int cr){\n\t\tif(l <= cl && cr <= r){\n\t\t\treturn node[k];\n\t\t}\n\t\tif(r <= cl || cr <= l){\n\t\t\treturn inf;\n\t\t}\n\t\tint m = (cl +cr)/2;\n\t\treturn min(_get(l, r, 2*k+1, cl, m), _get(l, r, 2*k+2, m, cr));\n\t}\n};\n\nsigned main(){\n\tlong long int n;\n\tcin >> n;\n\tvector<int> x(n);\n\tfor(int i=0; i<n; i++){\n\t\tcin >> x[i];\n\t}\n\tsegmentTree segtree(vector<long long int>(n+1, 0));\n\tfor(int i=0; i<n; i++){\n\t\tsegtree.Set(segtree.Get(0, x[i]) -x[i], x[i]);\n\t}\n\tcout << n*(n+1)/2 +segtree.Get(1, n+1) << endl;\n\treturn 0;\n}\n"
  },
  {
    "language": "C++",
    "code": "#include <iostream>\n#include <cmath>\n#include <algorithm>\n\nusing namespace std;\n\ntypedef long long int ll;\n\nconst int N = 1 << 17;\nll dat[N * 2 - 1] = { 0 }, n, m;\n\nvoid update(int i, int val) {\n\ti += m - 1;\n\tdat[i] = val;\n\twhile(i > 0) {\n\t\ti = (i - 1) / 2;\n\t\tdat[i] = max(dat[i * 2 + 1], dat[i * 2 + 2]);\n\t}\n\treturn;\n}\n\nll getval(int a, int b, int k, int l, int r) {\n\tif (r <= a || b <= l) return 0;\n\tif (a <= l && r <= b) return dat[k];\n\telse{\n\t\tint vl = getval(a, b, k * 2 + 1, l, (l + r) / 2);\n\t\tint vr = getval(a, b, k * 2 + 2, (l + r / 2), r);\n\t\treturn max(vl, vr);\n\t}\n}\n\nint main(){\n\tint a, v;\n\tdouble p, ip = 0.0, fp;\n\tcin >> n;\n\tp = log2(n);\n\tfp = modf(p, &ip);\n\tif(fp == 0.0) {\n\t\tm = 1 << int(p);\n\t}\n\telse{\n\t\tm = 1 << (int(p) + 1);\n\t}\n\tfor(int i = 0;i < n;++i){\n\t\tcin >> a;\n\t\tv = getval(0, a, 0, 0, m);\n\t\tupdate(a - 1, a + v); // 0-indexedにしたいので\n\t}\n\tcout << n * (n + 1) / 2 - dat[0] << endl;\n\treturn 0;\n}\n\n"
  },
  {
    "language": "C++",
    "code": "#include <iostream>\n#include <cmath>\n#include <algorithm>\n\nusing namespace std;\n\ntypedef long long int ll;\n\nconst int N = 1 << 17;\nll dat[N * 2 - 1] = { 0 }, n, m;\n\nvoid update(int i, ll val) {\n\ti += m - 1;\n\tdat[i] = val;\n\twhile(i > 0) {\n\t\ti = (i - 1) / 2;\n\t\tdat[i] = max(dat[i * 2 + 1], dat[i * 2 + 2]);\n\t}\n\treturn;\n}\n\nll getval(int a, int b, int k, int l, int r) {\n\tif (r <= a || b <= l) return 0;\n\tif (a <= l && r <= b) return dat[k];\n\telse{\n\t\tll vl = getval(a, b, k * 2 + 1, l, (l + r) / 2);\n\t\tll vr = getval(a, b, k * 2 + 2, (l + r) / 2, r);\n\t\treturn max(vl, vr);\n\t}\n}\n\nint main(){\n\tll a, v;\n\tdouble p, ip = 0.0, fp;\n\tcin >> n;\n\tp = log2(n);\n\tfp = modf(p, &ip);\n\tif(fp == 0.0) {\n\t\tm = 1 << int(p);\n\t}\n\telse{\n\t\tm = 1 << (int(p) + 1);\n\t}\n\tfor(int i = 0;i < n;++i){\n\t\tcin >> a;\n\t\tv = getval(0, a, 0, 0, m);\n\t\tupdate(a - 1, a + v); // 0-indexedにしたいので\n\t}\n\tcout << n * (n + 1) / 2 - dat[0] << endl;\n\treturn 0;\n}\n"
  },
  {
    "language": "C++",
    "code": "#include<iostream>\n#include<vector>\n#include<algorithm>\n#include<climits>\n\nconst int MAX_N=1000000;\n\ntypedef long long ll;\n\nusing namespace std;\n\nll n,dat[2*MAX_N-1];\n\nvoid init(int n_){\n\tn=1;\n\twhile(n<n_)n*=2;\n}\n\nvoid update(int k,ll a){\n\tk+=n-1;\n\tdat[k]=a;\n\t\n\twhile(k>0){\n\t\tk=(k-1)/2;\n\t\tdat[k]=max(dat[2*k+1],dat[2*k+2]);\n\t}\n}\n\nll query(int a,int b,int k,int l,int r){\n\tif(r<=a || b<=l)return 0;\n\tif(a<=l && r<=b)return dat[k];\n\telse {\n\t\tll vl=query(a,b,k*2+1,l,(l+r)/2);\n\t\tll vr=query(a,b,k*2+2,(l+r)/2,r);\n\t\treturn max(vl,vr);\n\t}\n}\n\nint main(void){\n\t\n\tll in,m,ans=0;\n\t\n\tcin >> m;\n\t\n\tinit(m);\n\t\n\tfor(int i=0;i<m;i++){\n\t\tcin >> in;\n\t\tupdate(in,in+query(1,in+1,0,0,n));\n\t\tans=max(ans,dat[in+n-1]);\n\t}\n\t//cout << m*(m+1)/2-query(1,m+1,0,0,n) << endl;\n\tcout << m*(m+1)/2-ans << endl;\n\t\n\treturn 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include<bits/stdc++.h>\nusing namespace std;\n#define INF 2147483647\n#define MAX_N 100000\n#define MAX_Q 100000\nusing namespace std;\n\nint n, q;\nint dat[MAX_N*4];\n\n//すべてのノードを0で初期化\nvoid init(){\n    for(int i = 0; i < 2*n - 1; i++) dat[i] = 0;\n}\n\n\n//a[i] を x に変更\nvoid update(int i, int x){\n    i += n - 1;\n    dat[i] = x;\n\n    //登りながら探索\n    while(i > 0){\n        i = (i - 1) / 2;\n        dat[i] = max(dat[2*i + 1], dat[2*i + 2]);\n    }\n}\n\n\n//区間[a, b)の最大値を返す\nint find(int a, int b, int k, int l, int r){\n    if(r <= a || b <= l) return 0;\n    else if(a <= l && r <= b) return dat[k];\n    else{\n        int vl = find(a, b, k * 2 + 1, l, (l + r)/2);\n        int vr = find(a, b, k * 2 + 2, (l + r)/2, r);\n        return max(vl, vr);\n    }\n}\n\nint main(){\n\n    cin >> q;\n    n = q;\n    n++;\n    vector<int> dp(q + 1, 0);\n    vector<int> POW(20);\n    POW[0] = 1;\n\n    for(int i = 1; i < 20; i++){\n        POW[i] = POW[i-1]*2;\n    }\n\n    //n以上n^2っぽいなにかと置換\n    n = *lower_bound(POW.begin(), POW.end(), n);\n    init();\n\n    for(int i = 0; i < q; i++){\n        int x; cin >> x;\n\n        int Max = find(0, x, 0, 0, n);\n        dp[x] = max(dp[x], Max + x);\n        update(x, dp[x]);\n        \n        //cout << x << \" \" << Max << \" \" << dp[x] << endl;\n    }\n\n    int ans = 0;\n    for(int i = 1; i <= q; i++) ans = max(ans, dp[i]);\n    ans = -ans;\n    for(int i = 1; i <= q; i++) ans += i;\n    \n    cout << ans << endl;\n    \n    return 0;\n}\n"
  },
  {
    "language": "C++",
    "code": "#include <sstream>\n#include <string>\n#include <vector>\n#include <map>\n#include <algorithm>\n#include <iostream>\n#include <utility>\n#include <set>\n#include <cctype>\n#include <queue>\n#include <stack>\n#include <cstdio>\n#include <cstdlib>\n#include <cmath>\n#include <climits>\nusing namespace std;\n#define INF 100000000\n\ntypedef long long ll;\nconst int dx[] = {1, 0, -1, 0};\nconst int dy[] = {0, 1, 0, -1};\n\nclass BIT {\npublic:\n    ll bit[1000010];\n    int bit_size;\n    BIT(int n) {\n        for (int i = 0; i < n+10; i++) bit[i] = 0;\n        bit_size = n;\n    }\n    void bit_add(int n, ll v) {\n        while (n <= bit_size) {\n            bit[n] = max(bit[n], v);\n            n += n & (-n);\n        }\n    }\n    ll bit_sum(int n) {\n        ll ans = 0;\n        while (n > 0) {\n            ans += bit[n];\n            n &= n-1;\n        }\n        return ans;\n    }\n    ll bit_max(int n) {\n        ll ans = 0;\n        while (n > 0) {\n            ans = max(ans, bit[n]);\n            n &= n-1;\n        }\n        return ans;\n    }\n};\n\nint main(void) {\n    int n;\n    cin >> n;\n    BIT bit(n+1);\n    ll ans = 0;\n    for (int i = 1; i <= n; i++) {\n        int x;\n        cin >> x;\n        ll cost = bit.bit_max(x-1);\n        ll tmp = cost + x;\n        ans = max(ans, tmp);\n        bit.bit_add(x, tmp);\n    }\n    ll sum = (n*(n+1)) / 2;\n    cout << sum - ans << endl;\n    return 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include<bits/stdc++.h>\nusing namespace std;\ntypedef long long ll;\nconst ll MAX_N = 1<<17;\nll n,dat[2*MAX_N-1];\n\nvoid init(int n_){\n  n=1;\n  while(n<n_)n*=2;\n  for(int i=0;i<2*n-1;i++)dat[i]=0;\n}\n\nvoid update(ll k,ll a){\n  k+=n-1;\n  dat[k]=a;\n  while(k>0){\n    k=(k-1)/2;\n    dat[k]=max(dat[k*2+1],dat[k*2+2]);\n  }\n}\n\nll query(ll a,ll b,ll k,ll l,ll r){\n  if(r<=a||b<=l)return 0;\n  if(a<=l&&r<=b)return dat[k];\n  else{\n    ll v1=query(a,b,k*2+1,l,(l+r)/2);\n    ll vr=query(a,b,k*2+2,(l+r)/2,r);\n    return max(v1,vr);\n  }\n}\n\nint main(){\n  cin>>n;\n  ll nn=n;\n  ll ans=0;\n  init(n);\n  for(ll i=0,x;i<nn;i++){\n    cin>>x;\n    ll p=query(0,x,0,0,n);\n    update(x-1,p+x);\n    ans=max(ans,p+x);\n  }\n  cout<<nn*(nn+1)/2-ans<<endl;\n  return 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include<cstdio>\n#include<algorithm>\n\n#define rep(i,n) for(int i=0;i<(n);i++)\n\nusing namespace std;\n\ntypedef long long ll;\n\ntemplate<class T>\nclass segment_tree_RMQ{\n\tstatic const int N_MAX=100001;\n\tint n;\n\tT dat[2*N_MAX];\n\n\tT query(int l,int r,int a,int b,int u){\n\t\tif(l<=a && b<=r) return dat[u];\n\n\t\tT res=0;\n\t\tint c=(a+b+1)/2;\n\t\tif(l<c && a<r) res=max(res,query(l,r,a,c,2*u));\n\t\tif(l<b && c<r) res=max(res,query(l,r,c,b,2*u+1));\n\t\treturn res;\n\t}\n\npublic:\n\tvoid build(int N,int val){\n\t\tfor(n=1;n<N;n*=2);\n\t\trep(i,2*n) dat[i]=val;\n\t}\n\n\tvoid update(int x,T v){\n\t\tx+=n;\n\t\tdat[x]=v;\n\t\tfor(x/=2;x>1;x/=2) dat[x]=max(dat[2*x],dat[2*x+1]);\n\t}\n\n\tT query(int l,int r){ return query(l,r,0,n,1); }\n};\n\nint main(){\n\tint n; scanf(\"%d\",&n);\n\tint x[100000];\n\trep(i,n) scanf(\"%d\",x+i);\n\n\tsegment_tree_RMQ<int> S;\n\tS.build(n+1,0);\n\trep(i,n){\n\t\tint cost=S.query(0,x[i]);\n\t\tS.update(x[i],cost+x[i]);\n\t}\n\n\tprintf(\"%lld\\n\",(ll)n*(n+1)/2-S.query(1,n+1));\n\n\treturn 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include <cstdio>\n#include <iostream>\n#include <sstream>\n#include <iomanip>\n#include <algorithm>\n#include <cmath>\n#include <string>\n#include <vector>\n#include <list>\n#include <queue>\n#include <stack>\n#include <set>\n#include <map>\n#include <bitset>\n#include <numeric>\n#include <climits>\n#include <cfloat>\nusing namespace std;\n\nclass Rmq\n{\n    int n;\n    vector<int> data;\n    int query(int a, int b, int k, int l, int r){\n        if(r < a || b < l)\n            return INT_MAX;\n        if(a <= l && r <= b)\n            return data[k];\n        int x = query(a, b, k*2+1, l, (l+r)/2);\n        int y = query(a, b, k*2+2, (l+r+1)/2, r);\n        return min(x, y);\n    }\npublic:\n    Rmq(int n0){ // コンストラクタ（要素数を指定）\n        n = 1;\n        while(n < n0)\n            n *= 2;\n        data.assign(2*n-1, INT_MAX);\n    }\n    Rmq(vector<int> vi){ // コンストラクタ（配列を指定）\n        int n0 = vi.size();\n        n = 1;\n        while(n < n0)\n            n *= 2;\n        data.assign(2*n-1, INT_MAX);\n        for(int i=0; i<n0; ++i)\n            data[i+n-1] = vi[i];\n        for(int i=n-2; i>=0; --i)\n            data[i] = min(data[i*2+1], data[i*2+2]);\n    }\n    void update(int k, int x){ // k番目の要素をxに変更する\n        k += n - 1;\n        data[k] = x;\n        while(k > 0){\n            k = (k - 1) / 2;\n            data[k] = min(data[k*2+1], data[k*2+2]);\n        }\n    }\n    int query(int a, int b){ // 区間[a,b]の最小値を返す\n        return query(a, b, 0, 0, n-1);\n    }\n};\n\nint main()\n{\n    int n;\n    cin >> n;\n    vector<int> x(n);\n    for(int i=0; i<n; ++i)\n        cin >> x[i];\n\n    Rmq rmq(n+1);\n    rmq.update(0, 0);\n    for(int i=0; i<n; ++i)\n        rmq.update(x[i], rmq.query(0, x[i]-1) - x[i]);\n\n    int ret = (n * (n + 1)) / 2;\n    ret += rmq.query(0, n);\n    cout << ret << endl;\n\n    return 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include<cstdio>\n#include<algorithm>\n#include<vector>\n#include<queue>\n#include<string>\n#include<iostream>\n#include<cmath>\n#include<map>\n#include<set>\n#include<climits>\nusing namespace std;\ntypedef vector<string>vs;\ntypedef vector<int>vi;\ntypedef vector<vi>vvi;\ntypedef vector<double>vd;\ntypedef pair<int,int>pii;\ntypedef long long ll;\ntypedef pair<ll,ll>pll;\ntypedef vector<ll>vl;\n#define rrep(i,x,n) for(int i=(x);i<(n);++i)\n#define rep(i,x) rrep(i,0,(x))\n#define fi first\n#define se second\n#define each(i,c) for(__typeof((c).begin()) i=(c).begin();i!=(c).end();++i)\n#define all(c) (c).begin(),(c).end()\n#define rall(c) (c).rbegin(),(c).rend()\n#define pb push_back\n#define maxs(a,b) (a)=max(a,b)\n#define mins(a,b) (a)=min(a,b)\n\nstruct SegTree{\n    ll N;\n    vl dat;\n    void init(int _N){\n        N=1;\n        while(N<_N)N*=2;\n        dat=vl(N*2-1,0);\n    }\n    void update(ll k,ll val){\n        k+=N-1;\n        dat[k]=val;\n        while(k){\n            k=(k-1)/2;\n            dat[k]=max(dat[k*2+1],dat[k*2+2]);\n        }\n    }\n    ll getMax(ll a,ll b,ll k=0,ll l=0,ll r=-1){\n        if(r==-1)r=N;\n        if(r<=a||b<=l)return 0;\n        if(a<=l&&b>=r)return dat[k];\n        ll v1=getMax(a,b,k*2+1,l,(l+r)/2);\n        ll v2=getMax(a,b,k*2+2,(l+r)/2,r);\n        return max(v1,v2);\n    }\n};\n\nint main(){\n    ll N;\n    scanf(\"%lld\",&N);\n\n    SegTree seg;\n    seg.init(N);\n    ll ans=0;\n\n    for(int i=0;i<N;i++){\n        ll weight;\n        scanf(\"%lld\",&weight);\n        seg.update(weight-1,seg.getMax(0,weight)+weight);\n        ans=max(ans,seg.getMax(weight-1,weight));\n    }\n    printf(\"%lld\\n\",N*(N+1)/2-ans);\n\n    return 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include <vector>\n#include <iostream>\n#include <set>\n#include <cstdio>\n#include <queue>\n#include <cstdio>\n#include <cstdlib>\n#include <cassert>\n#include <ctime>\n#include <algorithm>\n#include <tuple>\n#include <algorithm>\n#include <limits>\n#include <map>\n\nusing namespace std;\n\ntypedef long long ll;\ntypedef pair<int, int> P;\ntypedef tuple<int, int, int> T;\n\n#include <algorithm>\n#include <limits>\n#include <cstring>\n#include <array>\n//size:2**N N=19:524288 N=17:131072 N=12:4096\ntemplate <class T, int N, int K>\nstruct RangeKthSmallest {\n    using PA = std::pair<T, int>;\n    using P = std::pair<std::array<PA, K>, T>;\n    static const int size = 1<<N;\n    P seg[size*2];\n    \n    void init(T x) {\n        int l = size-1, r = size*2-2;\n        for (int i = 0; i <= N; i++) {\n            for (int j = l; j <= r; j++) {\n                seg[j].first[0] = PA(x, 1<<i);\n                for (int i = 1; i < K; i++) {\n                    seg[j].first[i] = PA(0, -1);\n                }\n                if (i) {\n                    seg[j].second = 0;\n                } else {\n                    seg[j].second = x;\n                }\n            }\n            l = (l-1)/2; r = (r-1)/2;\n        }\n        for (int i = 0; i < K; i++) {\n            seg[size*2-1].first[i] = PA(0, -1);\n        }\n    }\n\n    //a=b+c\n    inline void merge(P *A, P &a1, P &a2) {\n        int c1 = 0, c2 = 0;\n        P &a = *A;\n        for (int c = 0; c < K; c++) {\n            PA &p1 = a1.first[c1], &p2 = a2.first[c2];\n            bool f1 = (c1 == K || p1.second == -1), f2 = (c2 == K || p2.second == -1);\n            if (f1 && f2) {\n                a.first[c] = PA(0, -1);\n                continue;\n            }\n            if (f1) {\n                a.first[c] = p2;\n                c2++;\n            } else if (f2) {\n                a.first[c] = p1;\n                c1++;\n            } else if (p1.first == p2.first) {\n                a.first[c] = PA(p1.first, p1.second + p2.second);\n                c1++; c2++;\n            } else if (p1.first < p2.first) {\n                a.first[c] = p1;\n                c1++;\n            } else {\n                a.first[c] = p2;\n                c2++;\n            }\n            a.first[c].first += a.second;\n        }\n    }\n\n    inline void merge2(P *a, P &a1) {\n        P a2;\n        memcpy(&a2, a, sizeof(a2));\n        merge(a, a1, a2);\n    }\n\n    inline void add(uint i, T x) {\n        if (i >= size) return;\n        i += size - 1;\n        seg[i].first[0].first += x;\n        seg[i].second += x;\n        while (i) {\n            i = (i - 1) / 2;\n            merge(&seg[i], seg[i*2+1], seg[i*2+2]);\n        }\n    }\n\n    inline void add(uint a, uint b, T x, uint k = 0, uint l = 0, uint r = size) {\n        if (a >= b || b > size) return;\n        if (r <= a || b <= l) return;\n        if (a <= l && r <= b) {\n            for (int i = 0; i < K && seg[k].first[i].second != -1; i++) {\n                seg[k].first[i].first += x;\n            }\n            seg[k].second += x;\n            return;\n        }\n        add(a, b, x, k*2+1, l, (l+r)/2);\n        add(a, b, x, k*2+2, (l+r)/2, r);\n        merge(&seg[k], seg[k*2+1], seg[k*2+2]);\n    }\n\n    inline PA get(uint k) {\n        return seg[0].first[k];\n    }\n    P buff_p;\n    int buff_a = size, buff_b = size;\n    inline PA get(uint a, uint b, uint k) {\n        if (a != buff_a || b != buff_b) {\n            buff_p = get2(a, b);\n            buff_a = a;\n            buff_b = b;\n        }\n        return buff_p.first[k];\n    }\n\nprivate:\n    inline P get2(uint a, uint b, uint k = 0, uint l = 0, uint r = size) {\n        if (a >= b || b > size || r <= a || b <= l) return seg[size*2-1];\n        if (a <= l && r <= b) {\n            return seg[k];\n        }\n        P p1 = get2(a, b, k*2+1, l, (l+r)/2);\n        P p2 = get2(a, b, k*2+2, (l+r)/2, r);\n        P p;\n        p.second = seg[k].second;\n        merge(&p, p1, p2);\n        return p;\n    }\n};\nRangeKthSmallest<ll, 17, 1> s;\nint main() {\n    int n;\n    cin >> n;\n    s.init(0);\n    ll r = 0;\n    for (int i = 0; i < n; i++) {\n        int d;\n        cin >> d;\n        s.add(d, s.get(0, d, 0).first-d);\n        r += d;\n    }\n    cout << r + s.get(0).first << endl;\n    return 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\n\n#define FOR(i,a,b) for(int i= (a); i<((int)b); ++i)\n#define RFOR(i,a) for(int i=(a); i >= 0; --i)\n#define FOE(i,a) for(auto i : a)\n#define ALL(c) (c).begin(), (c).end()\n#define RALL(c) (c).rbegin(), (c).rend()\n#define DUMP(x)  cerr << #x << \" = \" << (x) << endl;\n#define SUM(x) std::accumulate(ALL(x), 0LL)\n#define MIN(v) *std::min_element(v.begin(), v.end())\n#define MAX(v) *std::max_element(v.begin(), v.end())\n#define EXIST(v,x) (std::find(v.begin(), v.end(), x) != v.end())\n#define BIT_ON(bit, i) (bit & (1LL << i))\n\ntypedef long long LL;\ntemplate<typename T> using V = std::vector<T>;\ntemplate<typename T> using VV = std::vector<std::vector<T>>;\ntemplate<typename T> using VVV = std::vector<std::vector<std::vector<T>>>;\ntemplate<typename T> using VVVV = std::vector<std::vector<std::vector<std::vector<T>>>>;\n\ntemplate<class T> inline T ceil(T a, T b) { return (a + b - 1) / b; }\ntemplate<class T> inline void print(T x) { std::cout << x << std::endl; }\ntemplate<class T> inline void print_vec(const std::vector<T> &v) { for (int i = 0; i < v.size(); ++i) {  if (i != 0) {std::cout << \" \";} std::cout << v[i];} std::cout << \"\\n\"; }\ntemplate<class T> inline bool inside(T y, T x, T H, T W) {return 0 <= y and y < H and 0 <= x and x < W; }\ntemplate<class T> inline double euclidean_distance(T y1, T x1, T y2, T x2) { return sqrt((x1 - x2) * (x1 - x2) + (y1 - y2) * (y1 - y2)); }\ntemplate<class T> inline double manhattan_distance(T y1, T x1, T y2, T x2) { return abs(x1 - x2) + abs(y1 - y2); }\ntemplate<class T> inline std::vector<T> unique(std::vector<T> v) {\n    sort(v.begin(), v.end());\n    v.erase(unique(v.begin(), v.end()), v.end());\n    return v;\n}\n\nconst int INF = 1 << 30;\nconst double EPS = 1e-9;\nconst std::string YES = \"YES\", Yes = \"Yes\", NO = \"NO\", No = \"No\";\nconst std::vector<int> dy4 = { 0, 1, 0, -1 }, dx4 = { 1, 0, -1, 0 };    // 4近傍（右, 下, 左, 上）\nconst std::vector<int> dy8 = { 0, -1, 0, 1, 1, -1, -1, 1 }, dx8 = { 1, 0, -1, 0, 1, 1, -1, -1 };\n\nusing namespace std;\n\ntemplate <typename T> class SegmentTree {\n    const int array_size;        // もとの配列のサイズ\n    int n;\n    std::vector<T> data;\n    std::function<T (T,T)> op;\n    T unit;\n\npublic:\n    enum Mode {\n        RangeMinimumQuery,\n        RangeMaximumQuery,\n        RangeSummationQuery,\n    };\n\n    SegmentTree(int array_size, Mode mode) : array_size(array_size) {\n        if (mode == RangeMinimumQuery) {\n            unit = numeric_limits<T>::max();\n            op = [](T a, T b) { return std::min(a, b); };\n        }\n        else if (mode == RangeMaximumQuery) {\n            unit = numeric_limits<T>::min();;\n            op = [](T a, T b) { return std::max(a, b); };\n        }\n        else if (mode == RangeSummationQuery) {\n            unit = 0;\n            op = [](T a, T b) { return a + b; };\n        }\n        else {\n            assert(false);\n        }\n\n        n = 1;\n        while (n < array_size) { n *= 2; }   // _n以上の最小の2冪\n        data.resize(2 * n - 1, unit);\n    }\n\n    template <typename F> SegmentTree(int array_size, T unit, F op) : array_size(array_size), unit(unit), op(op) {\n        while (n < array_size) { n *= 2; }   // _n以上の最小の2冪\n        data.resize(2 * n - 1, unit);\n    }\n\n    T access(int idx) {\n        return data[idx + n - 1];\n    }\n\n    // array[idx] = x\n    // O(log N)\n    void update(int idx, T x) {\n        assert(0 <= idx and idx < array_size);\n        idx += n - 1;   // 木での対象のインデックス\n        data[idx] = x;\n        while (idx > 0) {\n            idx = (idx - 1) / 2;                                    // 親のインデックス\n            data[idx] = op(data[idx * 2 + 1], data[idx * 2 + 2]);   // 左の子と右の子\n        }\n    }\n\n    // op(array[left, right))\n    // O(log N)\n    T query(int left, int right) {\n        assert(0 <= left and left < right and right <= array_size);\n        return query(left, right, 0, 0, n);\n    }\n\nprivate:\n    // [a, b)の目的値をノードk（区間[l, r]）から検索\n    T query(int a, int b, int k, int l, int r) {\n        assert(a < b && l < r);\n        // 範囲外\n        if (r <= a || b <= l) {\n            return unit;\n        }\n        // 完全に含む\n        if (a <= l && r <= b) {\n            return this->data[k];\n        }\n            // 一部含む\n        else {\n            T vl = query(a, b, k * 2 + 1, l, (l + r) / 2);    // 左の子\n            T vr = query(a, b, k * 2 + 2, (l + r) / 2, r);    // 右の子\n            return op(vl, vr);\n        }\n    }\n};\n\n\nint main() {\n    cin.tie(0);\n    ios::sync_with_stdio(false);\n    int N;\n    cin >> N;\n\n    SegmentTree<LL> st(N + 1, SegmentTree<LL>::RangeMaximumQuery);\n    LL total = 0;\n    FOR(i, 0, N) {\n        int x;\n        cin >> x;\n        total += x;\n        st.update(x, x + max(0LL, st.query(0, x + 1)));\n    }\n\n    print(total - st.query(0, N + 1));\n\n    return 0;\n}\n"
  },
  {
    "language": "C++",
    "code": "#include <iostream>\n#include <vector>\n#include <algorithm>\nusing namespace std;\n\n#define rep(i, n) rep2(i, 0, n)\n#define rep2(i, m, n) for(int i = m; i < (int)(n); ++i)\n\ntypedef long long ll;\n\nint seg_n, n;\nvector<ll> seg;\n\nvoid init(int n) {\n    seg_n = 1;\n    while(seg_n < n) seg_n *= 2;\n    seg.resize(seg_n * 2 - 1);\n}\n\nvoid update(int k, int a) {\n    k += seg_n - 1;\n    seg[k] = a;\n    while(k > 0) {\n        k = (k - 1) / 2;\n        seg[k] = max(seg[k*2+1], seg[k*2+2]);\n    }\n}\n\nll query(int a, int b, int k, int l, int r) {\n    if(r <= a || b <= l) return 0;\n    if(a <= l && r <= b) return seg[k];\n    int vl = query(a, b, k * 2 + 1, l, (l + r) / 2);\n    int vr = query(a, b, k * 2 + 2, (l + r) / 2, r);\n    return max(vl, vr);\n}\n\nll query(int x) { return query(0, x, 0, 0, seg_n); }\n\nint main() {\n    cin >> n;\n    vector<int> x(n);\n    rep(i, n) cin >> x[i];\n    init(n + 1);\n    rep(i, n) update(x[i], query(x[i]) + x[i]);\n    cout << (ll)n * (n + 1) / 2 - query(n + 1) << endl;\n}"
  },
  {
    "language": "C++",
    "code": "#include <iostream>\n#include <cmath>\nusing ll = long long;\nusing namespace std;\n\nconst int MAX_N = 1 << 17;\n\nint n;\nll dat[MAX_N*2 - 1];\n\nvoid init() {\n    int n_ = n;\n    n = 1;\n    while(n < n_) n *= 2;\n    for(int i=0; i<2*n - 1; ++i) {\n        dat[i] = 0;\n    }\n}\n\nvoid update(int i, ll x) {\n    i += n-1;\n    dat[i] = x;\n    while(i > 0) {\n        i = (i-1)/2;\n        dat[i] = max(dat[2*i+1], dat[2*i+2]);\n    }\n}\n\nll query(ll a, ll b, int k, int l, int r) {\n    if(r <= a || b <= l) {\n        return 0;\n    }\n    if(a <= l && r <= b) {\n        return dat[k];\n    } else {\n        ll vl = query(a, b, k*2 + 1, l, (r+l)/2);\n        ll vr = query(a, b, k*2 + 2, (r+l)/2, r);\n        return max(vl, vr);\n    }\n}\n\nint main() {\n    cin >> n;\n    ll sum = 0;\n    int n2 = n;\n    init();\n    for(int i=0; i<n2; ++i) {\n        ll x;\n        cin >> x;\n        sum += x;\n        update(x-1, x+query(0, x, 0, 0, n)); // x <= n\n    }\n    cout << sum - dat[0] << endl;\n}\n"
  },
  {
    "language": "C++",
    "code": "#include <iostream>\n#include <cstdio>\n#include <iomanip>\n#include <vector>\n#include <map>\n#include <set>\n#include <queue>\n#include <bitset>\n#include <stack>\n#include <utility>\n#include <numeric>\n#include <algorithm>\n#include <functional>\n#include <cctype>\n#include <complex>\n#include <string>\n#include <sstream>\n#include <fstream>\n#include <cassert>\nusing namespace std;\n\n//common\n\ntypedef int  i32;\ntypedef long long i64,ll;\ntypedef long double ld;\n\n#define BR \"\\n\"\n#define ALL(c) (c).begin(),(c).end()\n#define REP(i,n) for(int i=0;i<(int)(n);++i)\n#define FOR(i,l,r) for(int i=(int)l;i<(int)(r);++i)\n#define EACH(it,o) for(auto it = (o).begin(); it != (o).end(); ++it)\n#define IN(l,v,r) ((l)<=(v) && (v)<(r))\n\n//config\n//#define NDEBUG\n//#define INF 1<<30\n//#define EPS 1e-8\n//const ll MOD =100000007;\n\n//debug\n#ifdef NDEBUG\n#define DUMP(x)\n#define DUMPLN(x)\n#define DEBUG(x)\n#define DEBUGLN(x)\n#define LINE()\n#define LINELN()\n#define CHECK(exp,act)\n#define STOP(e)\n#else\n#define DUMP(x)  cerr << #x << \" = \" << (x)\n#define DUMPLN(x)  DUMP(x) <<endl\n#define DEBUG(x) DUMP(x) << LINE() << \" \" << __FILE__\n#define DEBUGLN(x) DEBUG(x)<<endl\n#define LINE()    cerr<< \" (L\" << __LINE__ << \")\"\n#define LINELN()    LINE()<<endl\n#define CHECK(exp,act)  if(exp!=act){DUMPLN(exp);DEBUGLN(act);}\n#define STOP(e)  CHECK(e,true);if(!(e)) exit(1);\n#endif\n\ntemplate<class T> inline string toString(const vector<T>& x) {\n\tstringstream ss;\n\tREP(i,x.size()){\n\t\tif(i!=0)ss<<\" \";\n\t\tss<< x[i];\n\t}\n\treturn ss.str();\n}\n\ntemplate<class T> inline string toString(const vector<vector<T> >& map) {\n\tstringstream ss;\n\tREP(i,map.size()){\n\t\tif(i!=0)ss<<BR;\n\t\tss<< toString(map[i]);\n\t}\n\treturn ss.str();\n}\ntemplate<class K,class V>  string toString(map<K,V>& x) {\n\tstring res;stringstream ss;\n\tfor(auto& p:x)ss<< p.first<<\":\" << p.second<<\" \";\n\treturn ss.str();\n}\n\nstring BITtoString(int bit){\n    stringstream ss;\n    while(bit!=0){ss<<(bit%2);bit/=2;}\n    string res=ss.str();reverse(ALL(res));\n    return res;\n}\n\ntemplate<typename T,typename V> inline T pmod(T v,V MOD){\n\treturn (v%MOD+MOD)%MOD;\n}\n#define nextInt(n) scanf(\"%d\",&n)\n#define defInt(n) int n;nextInt(n)\n#define nextLong(n) scanf(\"%lld\",&n)\n#define defLong(n) ll n;nextLong(n)\n#define nextDouble(n) scanf(\"%lf\",&n)\n\n\nnamespace SegmentTrees{\n\tll INF=1LL<<58;\n\n\ttemplate<typename T>\n\tclass RMQ{\n\tprivate:\n\t\tint Pow2Fit(int n){\n\t\t\tint d=1;while((d<<1)<=n)d<<=1;return d;\n\t\t}\n\tpublic:\n\t\tvector<T> dat;\n\t\tint n,size;\n\t\tRMQ(int _n){\n\t\t\tn=Pow2Fit(_n)<<1;\n\t\t\tsize=2*n-1;\n\t\t\tdat=vector<T>(size,0);\n\t\t}\n\t\tvoid set(int v,T a){\n\t\t\tv+=n-1;\n\t\t\tdat[v]=a;\n\t\t\twhile(v>0){\n\t\t\t\tint parent=v=(v-1)/2;\n\t\t\t\tint chl=parent*2+1,chr=parent*2+2;\n\t\t\t\tdat[parent]=max(dat[chl],dat[chr]);\n\t\t\t}\n\t\t}\n\t\tT get(int v){//v\n\t\t\treturn dat[v+n-1];\n\t\t}\n\t\tT query(int a,int b){//[a,b)\n\t\t\treturn query(0,a,b,0,n);\n\t\t}\n\tprivate:\n\t\tT query(int v,int a,int b,int l,int r){//[a,b)\n\t\t\tif(r<=a || b<=l)return 0;//out range\n\t\t\tif(a<=l && r<=b)return dat[v];\n\n\t\t\tT vl=query(v*2+1,a,b,l,(l+r)/2),vr=query(v*2+2,a,b,(l+r)/2,r);\n\t\t\treturn max(vl,vr);\n\t\t}\n\t};\n}\nusing namespace SegmentTrees;\n\nclass Main{\npublic:\n\tvoid run(){\n\t//\tifstream cin(\"in\");\n\t//\tofstream cout( \"out\" );\n\t\tint N;nextInt(N);\n\t\tRMQ<ll> rmq(N);\n\t\tvector<int> as(N);REP(i,N) nextInt(as[i]),as[i];\n\t\tREP(i,N){\n\t\t\trmq.set(as[i]-1,rmq.query(0,as[i])+as[i]);\n\t\t}\n\t\tll sum=0;REP(i,N) sum+=(i+1);\n\t\tcout << sum-rmq.query(0, N)<<endl;\n\t}\n};\nint main(){\n\tcout <<fixed<<setprecision(13);\t\n\tios::sync_with_stdio(false);\n\tMain().run();\n\treturn 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include<iostream>\n#include<vector>\n#include<algorithm>\nusing namespace std;\ntypedef long long ll;\n#define INF (1 << 30)\nstruct SegmentTree{\nprivate:\n  vector<ll> dat;\n  int n;\npublic:\n  SegmentTree(){}\n  SegmentTree(int size){\n    n = 1;\n    while(n < size) n *= 2;\n    dat = vector<ll>( 2 * n , 0 );\n  }\n  int getSize(){\n    return n;\n  }\n  ll getSeg(int s){\n    return dat[s];\n  }\n  void update(int i,ll x){\n    i += n - 1;\n    dat[i] = x;\n    while(i > 0){\n      i = ( i - 1 ) / 2;\n      dat[i] = max( dat[i * 2 + 1] , dat[i * 2 + 2]);\n    }\n  }\n  ll query(int a,int b,int k,int l,int r){\n    if(r <= a || b <= l) return 0;\n    if(a <= l && r <= b) return dat[k];\n    ll vl = query(a,b,k*2+1,l,(l+r)/2);\n    ll vr = query(a,b,k*2+2,(l+r)/2,r);\n    return max(vl,vr);\n  }\n};\nint main(){\n  int n;\n  ll ans = 0;\n  cin >> n;\n  SegmentTree BIT(n);\n  for(int i = 0 , x ; i < n ; i++ ){\n    cin >> x;\n    BIT.update( x , BIT.query(1,x+1,0,0,BIT.getSize()) + x );\n    ans = max( ans , BIT.getSeg( x + BIT.getSize() - 1));\n  }\n  cout << (n * (n + 1) / 2 - ans) << endl;\n}"
  },
  {
    "language": "C++",
    "code": "#include \"bits/stdc++.h\"\nusing namespace std;\ntypedef long long ll;\n#define int ll\ntypedef pair<int,int> pii;\n#define rep(i,n) for(ll i=0;i<(ll)(n);i++)\n#define all(a) (a).begin(),(a).end()\n#define pb emplace_back\n#define INF (1LL<<60)\n\n//0-index 抽象化半開区間遅延セグツリー\ntemplate<typename T, typename E>\nclass segment_tree{\n    typedef function<T(T,T)> F; //要素に適用する演算\n    typedef function<T(T,E)> G; //作用素の適用\n    typedef function<E(E,E)> H; //作用素の合成\n    typedef function<E(E,int)> P;\nprivate:\n    int num_of_elm_;\n    vector<T> dat_, lazy_;\n    F f_;\n    G g_;\n    H h_;\n    P p_;\n    T ident_;\n    E op_ident_;\npublic:\n    segment_tree(int n, F f, G g, H h, P p, T ident, E op_ident):f_(f), g_(g), h_(h), p_(p), ident_(ident), op_ident_(op_ident){\n        num_of_elm_ = 1;\n        while(num_of_elm_<n)num_of_elm_*=2;\n        dat_ .resize(2*num_of_elm_,ident);\n        lazy_.resize(2*num_of_elm_,op_ident);\n    }\n    \n    void build(vector<T> vec){\n        rep(i,vec.size()) dat_[num_of_elm_+i] = vec[i];\n        for(int i=num_of_elm_-1;i>=1;i--)dat_[i] = f_(dat_[i*2],dat_[i*2+1]);\n    }\n    \n    void eval(int k, int len){\n        if(lazy_[k] == op_ident_)return ;\n        \n        if(k<num_of_elm_){\n            lazy_[k*2]=h_(lazy_[k*2], lazy_[k]);\n            lazy_[k*2+1]=h_(lazy_[k*2+1], lazy_[k]);\n        }\n        dat_[k] = g_(dat_[k],p_(lazy_[k], len));\n        lazy_[k] = op_ident_;\n    }\n    \n    T update(int L, int R, int val, int l=0, int r=0, int k=1){\n        if(k==1)r = num_of_elm_;\n        \n        eval(k,r-l);\n        if(r<=L || R<=l)return dat_[k];\n        else if(L<=l && r<=R){\n            lazy_[k] = h_(lazy_[k], val);\n            return g_(dat_[k], p_(lazy_[k], r-l));\n        }\n        else{\n            return dat_[k] = f_(update(L,R,val,l,(l+r)/2,k*2), update(L,R,val,(l+r)/2,r,k*2+1));\n        }\n        \n    }\n    \n    T query(int L, int R,int l=0,int r=0, int k=1){\n        if(k==1)r = num_of_elm_;\n        \n        eval(k,r-l);\n        if(r<=L || R<=l)return ident_;\n        else if(L<=l && r<=R){\n            return dat_[k];\n        }\n        else{\n            return f_(query(L,R,l,(l+r)/2,k*2), query(L,R,(l+r)/2,r,k*2+1));\n        }\n    }\n};\n\nsigned main(){\n    int n;\n    cin>>n;\n    vector<int> v(n);\n    rep(i,n)cin>>v[i];\n    \n    auto f = [](int a, int b){ return max(a,b); };\n    auto g = f;\n    auto h = [](int a, int b){ return b; };\n    auto p = [](int a, int len){ return a; };\n\n    segment_tree<int,int> dp(n+1,f,g,h,p,0,0);\n    \n    for(int i=1;i<=n;i++){\n        dp.update(v[i-1], v[i-1]+1, dp.query( 0,v[i-1] )+v[i-1] );\n    }\n    cout<<n*(n+1)/2-dp.query(0,n+1)<<endl;\n}\n\n"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\nusing namespace std;\ntypedef long long ll;\n\nconst int MAX_N = 1 << 17;\nconst int def = 0;\nconst int INF = 1 << 25;\n\nstruct MaxSegTree {\n\tint n;\n\tll dat[2 * MAX_N - 1];\n\tvoid init(int n_) {\n\t\tn = 1;\n\t\twhile(n < n_) n *= 2;\n\t\tfor(int i = 0; i < 2 * n - 1; i++) dat[i] = def;\n\t}\n\n\tvoid update(int k, ll a) {\n\t\tk += n - 1;\n\t\tdat[k] = a;\n\t\twhile(k > 0) k = (k - 1) / 2, dat[k] = max(dat[k * 2 + 1], dat[k * 2 + 2]);\n\t}\n\n\tll query(int a, int b) { return query(a, b, 0, 0, n); }\n\n\tll query(int a, int b, int k, int l, int r) {\n\t\tif(r <= a || b <= l) return def;\n\t\tif(a <= l && r <= b) return dat[k];\n\t\tll vl = query(a, b, k * 2 + 1, l, (l + r) / 2);\n\t\tll vr = query(a, b, k * 2 + 2, (l + r) / 2, r);\n\t\treturn max(vl, vr);\n\t}\n\n\tvoid show() {\n\t\tfor(int i = 0; i < n; i++) cout << dat[i + n - 1] << \" \";\n\t\tcout << endl;\n\t}\n};\n\n\nMaxSegTree st;\n\ntypedef pair<ll, int> P;\nll x[100000];\nll dp[100000];\n\nint main() {\n\tcin.tie(0);\n\tios::sync_with_stdio(false);\n\n\tll n;\n\tcin >> n;\n\tst.init(n);\n\tvector<P> v;\n\tfor(int i = 0; i < n; i++) {\n\t\tcin >> x[i];\n\t\tv.push_back({ x[i], i });\n\t}\n\tsort(v.begin(), v.end());\n\treverse(v.begin(), v.end());\n\n\tfor(auto t : v) {\n\t\tint i = t.second;\n\t\tdp[i] = x[i] + st.query(i + 1, n);\n\t\tst.update(i, dp[i]);\n\t}\n\n\tll ans = n * (n + 1) / 2 - st.query(0, n);\n\tcout << ans << endl;\n}"
  },
  {
    "language": "C++",
    "code": "#include<bits/stdc++.h>\n#define int long long\n#define MAX 100001\nusing namespace std;\nint n,p,A[MAX*4],N;\nvoid Segtree(int n_){\n  n=1;\n  while(n<n_)n*=2;\n}\nvoid update(int k,int x){\n  k+=n-1;\n  A[k]=x;\n  while(k>0){\n    k=(k-1)/2;\n    A[k]=max(A[k*2+1],A[k*2+2]);\n  }\n}\nint find(int a,int b,int k,int l,int r){\n  if(r<=a||b<=l)return 0;\n  if(a<=l&&r<=b)return A[k];\n  int v1=find(a,b,k*2+1,l,(l+r)/2);\n  int v2=find(a,b,k*2+2,(l+r)/2,r);\n  return max(v1,v2);\n}\nmain(){\n  cin>>n;\n  N=n;\n  Segtree(n+1);\n  for(int i=0;i<N;i++){\n    scanf(\"%lld\",&p);\n    int v=find(0,p,0,0,n);\n    update(p,v+p);\n  }\n  cout<<N*(N+1)/2-find(0,N+1,0,0,n)<<endl;\n}"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\nusing namespace std;\n\n#define for_(i,a,b) for(int i=(a);i<(b);++i)\n#define for_rev(i,a,b) for(int i=(a);i>=(b);--i)\n\ntypedef long long lint;\n\ntemplate< typename DATA >\nclass SegmentTree {\nprivate:\n\tint size__;\n\tvector< DATA > data;\n\t\n\tinline int left_t(int k) {\n\t\treturn (k << 1) + 1;\n\t}\n\t\n\tinline int right_t(int k) {\n\t\treturn (k << 1) + 2;\n\t}\n\t\n\tinline int center(int l, int r) {\n\t\treturn (l + r) >> 1;\n\t}\n\t\npublic:\n\tSegmentTree(int n, DATA ini) {\n\t\tfor (size__ = 1; size__ < n; size__ <<= 1);\n\t\tdata.assign(2 * size__ - 1, ini);\n\t}\n\t\n\tDATA calc(DATA d1, DATA d2) {\n\t\treturn max(d1, d2);\n\t}\n\t\n\tvoid update(int k, DATA a) {\n\t\tk += size__ - 1;\n\t\tdata[k] = a;\n\t\t\n\t\twhile (k > 0) {\n\t\t\tk = (k - 1) >> 1;\n\t\t\tdata[k] = calc(data[left_t(k)], data[right_t(k)]);\n\t\t}\n\t}\n\t\n\tDATA query(int a, int b) {\n\t\treturn query(a, b, 0, 0, size__);\n\t}\n\t\n\tDATA query(int a, int b, int k, int l, int r) {\n\t\tif (r <= a || b <= l) return 0;\n\t\tif (a <= l && r <= b) return data[k];\n\t\treturn calc(query(a, b, left_t(k), l, center(l, r)),\n\t\t\t\t\tquery(a, b, right_t(k), center(l, r), r));\n\t}\n\t\n\tint size() {\n\t\treturn size__;\n\t}\n};\n\nlint n, x[100010];\n\nsigned main() {\n\tcin >> n;\n\tfor_(i,0,n) cin >> x[i];\n\t\n\tSegmentTree< lint > st(n + 10, 0);\n\tfor_(i,0,n) st.update(x[i], x[i] + st.query(0, x[i] + 1));\n\tcout << n * (n + 1) / 2 - st.query(0, n + 1) << endl;\n}"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\nusing namespace std;\n\n#define for_(i,a,b) for(int i=(a);i<(b);++i)\n#define for_rev(i,a,b) for(int i=(a);i>=(b);--i)\n\nint n, x[100010];\nint dp[100010], sum[100010];\n\nint main() {\n\tcin >> n;\n\tfor_(i,0,n) cin >> x[i];\n\t\n\tmemset(dp, 0, sizeof(dp));\n\tmemset(sum, 0, sizeof(sum));\n\t\n\tdp[n] = 10001;\n\t\n\tfor_rev(i,n-1,0) {\n\t\tint ind = lower_bound(dp, dp + n + 1, x[i]) - dp - 1;\n\t\t\n\t\tif (sum[ind] < sum[ind + 1] + x[i]) {\n\t\t\tdp[ind] = x[i];\n\t\t\tsum[ind] = sum[ind + 1] + x[i];\n\t\t}\n\t}\n\t\n\tcout << (n * (n + 1) / 2 - *max_element(sum, sum + n)) << endl;\n}"
  },
  {
    "language": "C++",
    "code": "#include <stdio.h>\n#include <cmath>\n#include <algorithm>\n#include <cfloat>\n#include <stack>\n#include <queue>\n#include <vector>\n#include <string>\n#include <iostream>\ntypedef long long int ll;\ntypedef unsigned long long int ull;\n#define BIG_NUM 2000000000\n#define MOD 1000000007\n#define EPS 0.000000001\nusing namespace std;\n\n\n#define NUM 0\n\nint N;\nll* table;\n\nvoid init(int first_N){\n\twhile(N < first_N)N *= 2;\n}\n\nvoid update(int loc,int value){\n\tloc += N-1;\n\n\ttable[loc] = value;\n\n\tif(N == 1)return;\n\n\tint parent = (loc-1)/2;\n\n\twhile(true){\n\t\ttable[parent] = max(table[2*parent+1],table[2*parent+2]);\n\n\t\tif(parent == 0)break;\n\t\telse{\n\t\t\tparent = (parent-1)/2;\n\t\t}\n\t}\n}\n\n\nint query(int search_left,int search_right,int node_id,int node_left,int node_right){\n\n\t//?????????????????????????´¢??????????????????????????????????????°??????????????¢?????????????????????\n\tif(search_right < node_left || search_left > node_right)return NUM;\n\n\tif(search_left <= node_left && search_right >= node_right){\n\t\treturn table[node_id];\n\t}\n\n\tint left_max = query(search_left,search_right,2*node_id+1,node_left,(node_left+node_right)/2);\n\tint right_max = query(search_left,search_right,2*node_id+2,(node_left+node_right)/2+1,node_right);\n\n\treturn max(left_max,right_max);\n}\n\n\nint main(){\n\n\tint first_N;\n\ttable = new ll[263000];\n\tN = 1;\n\n\tscanf(\"%d\",&first_N);\n\n\tinit(100000);\n\n\tfor(int i = 0; i <= 2*N-2; i++)table[i] = NUM;\n\n\tll tmp,left_max,sum = 0;\n\n\tfor(int loop = 0; loop < first_N; loop++){\n\n\t\tscanf(\"%lld\",&tmp);\n\n\t\tleft_max = query(0,tmp-1,0,0,N-1);\n\n\t\tupdate(tmp,left_max+tmp);\n\n\t\tsum += tmp;\n\t}\n\n\tll ans = 0;\n\n\tfor(int i = 1; i <= 100000; i++){\n\t\tans = max(ans,table[N-1+i]);\n\t}\n\n\tprintf(\"%lld\\n\",sum - ans);\n\n\treturn 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include<bits/stdc++.h>\nusing namespace std;\n#define INF 2147483647\n#define MAX_N 100000\n#define MAX_Q 100000\n\n\nint n, q;\nint dat[MAX_N*4];\n\n//すべてのノードを0で初期化\nvoid init(){\n    for(int i = 0; i < 2*n - 1; i++) dat[i] = 0;\n}\n\n\n//a[i] を x に変更\nvoid update(int i, long long x){\n    i += n - 1;\n    dat[i] = x;\n\n    //登りながら探索\n    while(i > 0){\n        i = (i - 1) / 2;\n        dat[i] = max(dat[2*i + 1], dat[2*i + 2]);\n    }\n}\n\n\n//区間[a, b)の最大値を返す\nlong long find(int a, int b, int k, int l, int r){\n    if(r <= a || b <= l) return 0;\n    else if(a <= l && r <= b) return dat[k];\n    else{\n        int vl = find(a, b, k * 2 + 1, l, (l + r)/2);\n        int vr = find(a, b, k * 2 + 2, (l + r)/2, r);\n        return max(vl, vr);\n    }\n}\n\nint main(){\n\n    cin >> q;\n    n = q;\n    n++;\n    vector<long long> dp(q + 1, 0);\n    vector<int> POW(20);\n    POW[0] = 1;\n\n    for(int i = 1; i < 20; i++){\n        POW[i] = POW[i-1]*2;\n    }\n\n    //n以上n^2っぽいなにかと置換\n    n = *lower_bound(POW.begin(), POW.end(), n);\n    init();\n\n    for(int i = 0; i < q; i++){\n        long long x; cin >> x;\n\n        long long Max = find(0, x, 0, 0, n);\n        dp[x] = max(dp[x], Max + x);\n        update(x, dp[x]);\n        \n        //cout << x << \" \" << Max << \" \" << dp[x] << endl;\n    }\n\n    long long ans = 0;\n    for(int i = 1; i <= q; i++) ans = max(ans, dp[i]);\n    ans = -ans;\n    for(int i = 1; i <= q; i++) ans += (long long)i;\n    \n    cout << ans << endl;\n    \n    return 0;\n}\n"
  },
  {
    "language": "C++",
    "code": "#include \"bits/stdc++.h\"\n#include<unordered_map>\n#include<unordered_set>\n#pragma warning(disable:4996)\nusing namespace std;\nusing ld = long double;\ntemplate<class T>\nusing Table = vector<vector<T>>;\n\n\n\nint main() {\n\tint N; cin >> N;\n\tvector<long long int>nums(N);\n\tfor (int i = 0; i < N; ++i) {\n\t\tcin >> nums[i];\n\t}\n\tmap<int, long long int>nmp;\n\tnmp[0] = 0;\n\tfor (int i = 0; i < N; ++i) {\n\t\tmap<int, long long int>newmp(nmp);\n\t\tfor (auto j : nmp) {\n\t\t\tif(nums[i]>j.first)\n\t\t\t\tnewmp[nums[i]] = max(newmp[nums[i]], j.second + nums[i]);\n\t\t\telse {\n\t\t\t\tbreak;\n\t\t\t}\n\t\t}\n\t\tnmp = newmp;\n\t}\n\tlong long int sum= N*(N + 1) / 2;\n\tlong long int ans = sum;\n\tfor (auto m : nmp) {\n\t\tans = min(ans, sum-m.second);\n\t}\n\tcout << ans << endl;\n\treturn 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include<bits/stdc++.h>\nusing namespace std;\ntypedef long long ll;\nconst ll MAX_N = 1<<17;\nll n,dat[2*MAX_N-1];\n\nvoid init(int n_){\n  n=1;\n  while(n<n_)n*=2;\n  for(int i=0;i<2*n-1;i++)dat[i]=0;\n}\n\nvoid update(ll k,ll a){\n  k+=n-1;\n  dat[k]=a;\n  while(k>0){\n    k=(k-1)/2;\n    dat[k]=max(dat[k*2+1],dat[k*2+2]);\n  }\n}\n\nll query(ll a,ll b,ll k,ll l,ll r){\n  if(r<=a||b<=l)return 0;\n  if(a<=l&&r<=b)return dat[k];\n  else{\n    ll v1=query(a,b,k*2+1,l,(l+r)/2);\n    ll vr=query(a,b,k*2+2,(l+r)/2,r);\n    return max(v1,vr);\n  }\n}\n\nint main(){\n  cin>>n;\n  ll nn=n;\n  ll ans=0;\n  init(n);\n  for(ll i=0,x;i<nn;i++){\n    cin>>x;\n    ll p=query(0,x,0,0,n);\n    update(x-1,p+x);\n    ans=max(ans,p+x);\n  }\n\n  cout<<nn*(nn+1)/2-ans<<endl;\n  \n  return 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include <iostream>\n#include <vector>\n#include <algorithm>\n\nusing namespace std;\ntypedef long long ll;\n\nconst ll MAX_N = (1 << 20);\nll dat[2 * MAX_N - 1] = { 0 };\n\nvoid update(ll k, ll a){\n\tk += MAX_N - 1;\n\tdat[k] = a;\n\twhile(k > 0){\n\t\tk = (k - 1) / 2;\n\t\tdat[k] = max(dat[k * 2 + 1], dat[k * 2 + 2]);\n\t}\n}\n\nll query(ll a, ll b, ll k, ll l, ll r){\n\tif(r <= a || b <= l){ return 0; }\n\tif(a <= l && r <= b){ return dat[k]; }\n\tll vl = query(a, b, k * 2 + 1, l, (l + r) / 2);\n\tll vr = query(a, b, k * 2 + 2, (l + r) / 2, r);\n\treturn max(vl, vr);\n}\n\nint main(){\n\tios_base::sync_with_stdio(false);\n\tll n;\n\tcin >> n;\n\tvector<ll> x(n);\n\tfor(ll i = 0; i < n; ++i){ cin >> x[i]; }\n\tll max_sum = 0;\n\tfor(ll i = 0; i < n; ++i){\n\t\tll y = query(0, x[i], 0, 0, MAX_N) + x[i];\n\t\tmax_sum = max(max_sum, y);\n\t\tupdate(x[i], y);\n\t}\n\tcout << (n * (n + 1) / 2) - max_sum << endl;\n\treturn 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\n\nusing namespace std;\n\n#define int long long\n// #define double long double\n#define FOR(i, a, b) for(ll i = (a); i < (b); ++i)\n#define FORR(i, a, b) for(ll i = (a); i > (b); --i)\n#define REP(i, n) for(ll i = 0; i < (n); ++i)\n#define REPR(i, n) for(ll i = n; i >= 0; i--)\n#define FOREACH(x, a) for(auto &(x) : (a))\n#define VECCIN(x)                                                              \\\n    for(auto &youso_ : (x)) cin >> youso_\n#define bitcnt(x) __builtin_popcount(x)\n#define lbit(x) __builtin_ffsll(x)\n#define rbit(x) __builtin_clzll(x)\n#define SZ(x) ((ll)(x).size())\n#define fi first\n#define se second\n#define All(a) (a).begin(), (a).end()\n#define rAll(a) (a).rbegin(), (a).rend()\n\ntemplate <typename T = long long> inline T IN() {\n    T x;\n    cin >> x;\n    return (x);\n}\ninline void CIN() {}\ntemplate <class Head, class... Tail>\ninline void CIN(Head &&head, Tail &&... tail) {\n    cin >> head;\n    CIN(move(tail)...);\n}\n#define CCIN(...)                                                              \\\n    char __VA_ARGS__;                                                          \\\n    CIN(__VA_ARGS__)\n#define DCIN(...)                                                              \\\n    double __VA_ARGS__;                                                        \\\n    CIN(__VA_ARGS__)\n#define LCIN(...)                                                              \\\n    ll __VA_ARGS__;                                                            \\\n    CIN(__VA_ARGS__)\n#define SCIN(...)                                                              \\\n    string __VA_ARGS__;                                                        \\\n    CIN(__VA_ARGS__)\n#define Yes(a) cout << (a ? \"Yes\" : \"No\") << \"\\n\"\n#define YES(a) cout << (a ? \"YES\" : \"NO\") << \"\\n\"\n#define Printv(v)                                                              \\\n    {                                                                          \\\n        FOREACH(x, v) { cout << x << \" \"; }                                    \\\n        cout << \"\\n\";                                                          \\\n    }\ntemplate <typename T = string> inline void eputs(T s) {\n    cout << s << \"\\n\";\n    exit(0);\n}\ntemplate <typename A, size_t N, typename T>\nvoid Fill(A (&array)[N], const T &val) {\n    std::fill((T *)array, (T *)(array + N), val);\n}\n\ntemplate <typename T> using PQG = priority_queue<T, vector<T>, greater<T>>;\ntemplate <typename T> using PQ = priority_queue<T>;\n\ntypedef long long ll;\ntypedef vector<ll> VL;\ntypedef vector<VL> VVL;\ntypedef pair<ll, ll> PL;\ntypedef vector<PL> VPL;\ntypedef vector<bool> VB;\ntypedef vector<double> VD;\ntypedef vector<string> VS;\n\nconst int INF = 1e9;\nconst int MOD = 1e9 + 7;\n// const int MOD = 998244353;\nconst ll LINF = 1e18;\n// const double PI = atan(1.0) * 4.0;\nconst ll dx[] = {1, 1, 0, -1, -1, -1, 0, 1};\nconst ll dy[] = {0, 1, 1, 1, 0, -1, -1, -1};\n#define PI 3.1415\n\ntemplate <typename T, typename E> struct SegmentTree {\n    using F = function<T(T, T)>;\n    using G = function<T(T, E)>;\n    using H = function<E(E, E)>;\n    using P = function<E(E, int)>;\n    int n;\n    // dat(蜃ｺ蜉�)縺ｮ繝槭�ｼ繧ｸ�ｼ域峩譁ｰ�ｼ�\n    F f;\n    // laz繧壇at縺ｫ蜿肴丐貍皮ｮ�\n    G g;\n    // laz(譖ｴ譁ｰ)縺ｮ繝代�ｼ繧ｸ�ｼ域峩譁ｰ�ｼ会ｼ井ｸ九↓莨晄眺�ｼ�\n    H h;\n    // laz繧壇at縺ｫ蜿肴丐貍皮ｮ�(縺ｾ縺ｨ繧�)\n    P p;\n    T e1;\n    E e2;\n    vector<T> dat;\n    vector<E> laz;\n    SegmentTree(int n_, F f, G g, H h, T e1, E e2, vector<T> v = vector<T>(),\n                P p = [](E a, int b) { return a; })\n        : f(f), g(g), h(h), e1(e1), e2(e2), p(p) {\n        init(n_);\n        if(n_ == (int)v.size()) build(n_, v);\n    }\n    void init(int n_) {\n        n = 1;\n        while(n < n_) n *= 2;\n        dat.clear();\n        dat.resize(2 * n - 1, e1);\n        laz.clear();\n        laz.resize(2 * n - 1, e2);\n    }\n    void build(int n_, vector<T> v) {\n        for(int i = 0; i < n_; i++) dat[i + n - 1] = v[i];\n        for(int i = n - 2; i >= 0; i--)\n            dat[i] = f(dat[i * 2 + 1], dat[i * 2 + 2]);\n    }\n    inline void eval(int len, int k) {\n        if(laz[k] == e2) return;\n        if(k * 2 + 1 < n * 2 - 1) {\n            laz[k * 2 + 1] = h(laz[k * 2 + 1], laz[k]);\n            laz[k * 2 + 2] = h(laz[k * 2 + 2], laz[k]);\n        }\n        dat[k] = g(dat[k], p(laz[k], len));\n        laz[k] = e2;\n    }\n    T update(int a, int b, E x, int k, int l, int r) {\n        eval(r - l, k);\n        if(r <= a || b <= l) return dat[k];\n        if(a <= l && r <= b) {\n            laz[k] = h(laz[k], x);\n            return g(dat[k], p(laz[k], r - l));\n        }\n        eval(r - l, k);\n        return dat[k] = f(update(a, b, x, k * 2 + 1, l, (l + r) / 2),\n                          update(a, b, x, k * 2 + 2, (l + r) / 2, r));\n    }\n    T update(int a, int b, E x) { return update(a, b, x, 0, 0, n); }\n    T query(int a, int b, int k, int l, int r) {\n        eval(r - l, k);\n        if(r <= a || b <= l) return e1;\n        if(a <= l && r <= b) return dat[k];\n        T vl = query(a, b, k * 2 + 1, l, (l + r) / 2);\n        T vr = query(a, b, k * 2 + 2, (l + r) / 2, r);\n        return f(vl, vr);\n    }\n    T query(int a, int b) { return query(a, b, 0, 0, n); }\n};\n\nsigned main() {\n    LCIN(N);\n    ll e1 = 0, e2 = 0;\n    auto f = [](ll a, ll b) { return max(a, b); };\n    auto g = [e2](ll a, ll b) { return b != e2 ? b : a; };\n    auto h = [e2](ll a, ll b) { return b != e2 ? b : a; };\n    SegmentTree<ll, ll> dp(N + 2, f, g, h, e1, e2, VL(N + 2));\n    ll sum = 0;\n    REP(i, N) {\n        LCIN(x);\n        sum += x;\n        ll val = dp.query(0, x);\n        dp.update(x, x + 1, val + x);\n    }\n    cout << sum - dp.query(0, N + 2) << \"\\n\";\n}\n\n"
  },
  {
    "language": "C++",
    "code": "#include<iostream>\n#include<vector>\n#include<algorithm>\n#include<iomanip>\n#include<sstream>\n#include<map>\n#include<queue>\n#include<complex>\nusing namespace std;\n#define int long long\nvector<int> dat;\nint sz;\nvoid init(int n) {\n\tsz = 1;\n\twhile (sz < n)sz *= 2;\n\tdat.clear();\n\tdat.resize(2 * sz, 0);\n}\nvoid update(int k, int a) {\n\tk += sz - 1;\n\tdat[k] = a;\n\twhile (k > 0) {\n\t\tk = (k - 1) / 2;\n\t\tdat[k] = max(dat[k * 2 + 1], dat[k * 2 + 2]);\n\t}\n}\nint query(int a, int b, int k, int l, int r) {\n\tif (r <= a || b <= l)return 0;\n\tif (a <= l && r <= b)return dat[k];\n\tint m = (l + r) / 2;\n\tint vl = query(a, b, 2 * k + 1, l, m);\n\tint vr = query(a, b, 2 * k + 2, m, r);\n\treturn max(vl, vr);\n}\nint query(int a, int b) {\n\treturn query(a, b, 0, 0, sz);\n}\nint N;\nsigned main() {\n\tcin >> N;\n\tvector<int> A(N);\n\tfor (int i = 0; i < N; i++) {\n\t\tint a;\n\t\tcin >> a;\n\t\ta--;\n\t\tA[a] = i;\n\t}\n\t\n\tinit(N);\n\tint res = 0;\n\tfor (int i = 0; i < N; i++) {\n\t\tint mx = query(0, A[i]);\n\t\t//cerr << i << \" \" << A[i] << \" \" << mx << endl;\n\t\tupdate(A[i], mx + i + 1);\n\t\tres = max(res, mx + i + 1);\n\t}\n\tcout << (((N + 1)*N) / 2) - res << endl;\n}\n"
  },
  {
    "language": "C++",
    "code": "#include<cstdio>\n#include<iostream>\n#include<string>\n#include<vector>\n#include<algorithm>\n\nusing namespace std;\n\n#define reps(i,f,n) for(int i=f;i<int(n);i++)\n#define rep(i,n) reps(i,0,n)\n\nconst int N = 100010;\n\nclass BIT{\n\tstatic const int N = 100010;\n\tpublic:\n\tint t[N];\n\tvoid init(){rep(i,N)t[i]=0;}\n\tint calc(int a,int b){return max(a,b);}\n\t\n\tvoid setval(int pos, int val){\n\t\tpos++;\n\t\tfor(int i=0;;i++){\n\t\t\tif(pos>=N)break;\n\t\t\tif(pos&(1<<i)){\n\t\t\t\tt[pos] = calc(t[pos],val);\n\t\t\t\tpos += (1<<i);\n\t\t\t}\n\t\t}\n\t}\n\t\n\tint getval(int pos){\n\t\tpos++;\n\t\tint ret = 0;\n\t\tfor(int i=0;;i++){\n\t\t\tif(pos==0)break;\n\t\t\tif(pos&(1<<i)){\n\t\t\t\tret = calc(ret, t[pos]);\n\t\t\t\tpos -= (1<<i);\n\t\t\t}\n\t\t}\n\t\treturn ret;\n\t}\n\t\n\tvoid print(){\n\t\tprintf(\"t : \");\n\t\trep(i,10)printf(\"%d \",t[i]);puts(\"\");\n\t}\n};\n\nint main(){\n\tint n;\n\tcin>>n;\n\t\n\tint p[N];\n\tint sum = 0;\n\trep(i,n){\n\t\tcin>>p[i];\n\t\tsum += p[i];\n\t}\n\t\n\tBIT bit;\n\tbit.init();\n\t\n\trep(i,n){\n\t\tbit.setval( p[i], bit.getval(p[i])+p[i] );\n\t\t//bit.print();\n\t}\n\t\n\tprintf(\"%d\\n\",sum - bit.getval(n-1));\n}\n\n/*\n5\n1 5 3 2 4\n\n*/"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\nusing namespace std;\ntypedef long long ll;\nconst int MAX_N = int(1e5 + 5);\n\nstruct SegmentTree {\n    int N;\n    vector<ll> node;\n\n    SegmentTree(){}\n    SegmentTree(int n_){\n        init(n_);\n    }\n    void init(int siz){\n        N = 1;\n        while (N < siz) N *= 2;\n        node.resize(2*N-1, 0);\n    }\n    void update(int k, ll a) {\n        k += N - 1;\n        node[k] = a;\n        while (k > 0) {\n            k = (k-1)/2;\n            node[k] = max(node[k*2+1], node[k*2+2]);\n        }\n    }\n    ll getMax(int a, int b) {return getMax(a, b, 0, 0, N);}\n    ll getMax(int a, int b, int k, int l, int r) {\n        if (r <= a || b <= l)\n            return 0;\n        if (a <= l && r <= b)\n            return node[k];\n        else {\n            ll vl = getMax(a, b, k*2+1, l, (l+r)/2);\n            ll vr = getMax(a, b, k*2+2, (l+r)/2, r);\n            return max(vl, vr);\n        }\n    }\n};\n\nint main() {\n    ll n, a[MAX_N];\n    cin >> n;\n    for(int i=0;i<n;i++){\n        cin >> a[i];\n    }\n    SegmentTree rmq(n+1);\n    for(int i=0;i<n;i++){\n        rmq.update(a[i], rmq.getMax(0,a[i])+a[i]);\n    }\n    cout << n*(n+1)/2 - rmq.getMax(0,n+1) << endl;\n    return 0;\n}\n"
  },
  {
    "language": "C++",
    "code": "#include<iostream>\n#include<vector>\n#include<algorithm>\n#include<climits>\n\nconst int MAX_N=1000000;\n\ntypedef long long ll;\n\nusing namespace std;\n\nll n,dat[2*MAX_N-1];\n\nvoid init(int n_){\n\tn=1;\n\twhile(n<n_)n*=2;\n\tfor(int i=0;i<2*n-1;i++)dat[i]=0;\n}\n\nvoid update(int k,ll a){\n\tk+=n-1;\n\tdat[k]=a;\n\t\n\twhile(k>0){\n\t\tk=(k-1)/2;\n\t\tdat[k]=max(dat[2*k+1],dat[2*k+2]);\n\t}\n}\n\nll query(int a,int b,int k,int l,int r){\n\tif(r<=a || b<=l)return 0;\n\tif(a<=l && r<=b)return dat[k];\n\telse {\n\t\tll vl=query(a,b,k*2+1,l,(l+r)/2);\n\t\tll vr=query(a,b,k*2+2,(l+r)/2,r);\n\t\treturn max(vl,vr);\n\t}\n}\n\nint main(void){\n\t\n\tll in,m,ans=0;\n\t\n\tcin >> m;\n\t\n\tinit(m);\n\t\n\tfor(int i=0;i<m;i++){\n\t\tcin >> in;\n\t\tupdate(in,in+query(1,in+1,0,0,n));\n\t\t//ans=max(ans,dat[in+n-1]);\n\t}\n\tcout << m*(m+1)/2-query(1,in+1,0,0,n) << endl;\n\t\n\treturn 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include <cstdio>\n#include <cstring>\n#include <algorithm>\nusing namespace std;\ntypedef long long ll;\nint n;\nint x[100001];\nll dp[1<<20];\nint n_;\nll query(int a,int b,int k=0,int l=0,int r=n_){\n\tif(a<=l && r<=b)return dp[k];\n\tif(r<=a || b<=l)return 0;\n\tll vl=query(a,b,k*2+1,l,(l+r)/2);\n\tll vr=query(a,b,k*2+2,(l+r)/2,r);\n\treturn max(vl,vr);\n}\n\nvoid update(int k,ll a){\n\tk+=n_-1;\n\tdp[k]=a;\n\twhile(k>0){\n\t\tk=(k-1)/2;\n\t\tdp[k]=max(dp[k*2+1],dp[k*2+2]);\n\t}\n}\n\nint main(void){\n\tscanf(\"%d\",&n);\n\tn_=1;\n\twhile(n_<n)n_*=2;\n\tll sum=0;\n\tfor(int i=0;i<n;i++){\n\t\tscanf(\"%d\",&x[i]);\n\t\tsum+=(ll)x[i];\n\t}\n\tfor(int i=0;i<n;i++){\n\t\tll val=query(0,x[i]-1);\n\t\tupdate(x[i]-1,(ll)x[i]+val);\n\t}\n\tprintf(\"%lld\\n\",sum-dp[0]);\n\treturn 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\nusing namespace std;\n\n#define FOR(i, a, b) for (int i = (a); i < int(b); ++i)\n#define REP(i, n) FOR(i, 0, n)\n\ntemplate <typename Int>\nstruct FenwickTree {\n  vector<Int> data;\n  explicit FenwickTree(int n): data(n, 0) {}\n  void add(int i, Int x) { for (; i < (int)data.size(); i |= i+1) data[i] = max(data[i], x); }\n  Int sum(int i) const { Int s = 0; for (; i >= 0; i = (i & (i+1)) - 1) s = max(s, data[i]); return s; }\n};\n\nlong long dp[100001];\n\nint main() {\n    cin.tie(0); ios_base::sync_with_stdio(false);\n\n    int n;\n    while (cin >> n) {\n        vector<int> weights(n);\n        REP(i, n) cin >> weights[i];\n\n        REP(w, n+1) dp[w] = 0;\n        dp[weights[0]] = weights[0];\n\n        FenwickTree<long long> ft(n+1);\n        ft.add(weights[0], weights[0]);\n\n        FOR(i, 1, n) {\n            int w = weights[i];\n            long long v = max(dp[w], ft.sum(w-1) + w);\n            dp[w] = v;\n            ft.add(w, v);\n        }\n\n        long long total_weight = accumulate(weights.begin(), weights.end(), 0);\n        long long subseq_weight = ft.sum(n);\n        cout << total_weight - subseq_weight << '\\n';\n    }\n}"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\n\nusing namespace std;\n\ntypedef long long ll;\n\nstruct SegmentTree{\n  ll data[500010];\n  int sz;\n  void init(int n){\n    sz = 1;\n    while(sz < n) sz *= 2;\n    memset(data, 0LL, sizeof(data));\n  }\n  void update(int k, ll x){\n    k += sz - 1;\n    data[k] = x;\n    while(k > 0){\n      k = (k - 1) / 2;\n      data[k] = max(data[2*k+1], data[2*k+2]);\n    }\n  }\n  ll at(int k){\n    return data[k+sz-1];\n  }\n  ll query(int a, int b, int k, int l, int r){\n    if(r <= a || b <= l) return -1;\n    if(a <= l && r <= b) return data[k];\n    ll left = query(a, b, 2*k+1, l, (l+r)/2);\n    ll right = query(a, b, 2*k+2, (l+r)/2, r);\n    return max(left, right);\n  }\n  ll query(int a, int b){\n    return query(a, b, 0, 0, sz);\n  }\n  int size(){\n    return sz;\n  }\n};\n\nint main()\n{\n  SegmentTree tree;  \n  int n;\n  cin >> n;\n  tree.init(n);\n  ll maxcost = 0;\n  for(int i = 0; i < n; i++){\n    ll x;\n    cin >> x;\n    ll cost = tree.query(1, x+1);\n    tree.update(x, cost + x);\n    maxcost = max(maxcost, tree.at(x));\n    cout << maxcost << endl;\n  }\n  cout << ((ll)n+1LL)*n/2LL - maxcost << endl;\n  return 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include <iostream>\n#include <vector>\n#include <algorithm>\n\nusing namespace std;\n\nint main(){\n    \n    long long n, x;\n    cin >> n;\n    vector<long long> seg(n+1, 0);\n    \n    for(int i = 0; i < n; i++){\n        cin >> x;\n        long long sum = 0;\n        for(int j = x-1; j > 0; j = j & (j-1)){\n            if(seg[j] > sum)\n                sum = seg[j];\n        }\n        for(int j = x; j < n + 1; j += (j & -j)){\n            if(sum + x > seg[j]){\n                seg[j] = sum + x;\n            }\n        }\n    }\n    \n    long long ans = 0;\n    for(int j = n; j > 0; j = j & (j-1)){\n        if(seg[j] > ans)\n            ans = seg[j];\n    }\n    cout << (n*(n+1))/2 - ans <<endl;\n    \n}"
  },
  {
    "language": "C++",
    "code": "#include<bits/stdc++.h>\n#define N (1<<17)\n#define INF 0\nusing namespace std;\ntypedef long long ll;\n \nclass RMQ{\npublic:\n  ll n,dat[2*N-1];\n \n  //?????????\n  RMQ(){\n    n=N;\n    for(int i=0;i<n;i++) dat[i]=INF;\n  }\n   \n  //k???????????????a?????????´\n  void update(int k,ll a){\n    k+=n-1;\n    dat[k]=a;\n    while(k>0){\n      k=(k-1)/2;\n      dat[k]=min(dat[k*2+1],dat[k*2+2]);\n    }\n  }\n \n  //[a,b)????????°?????????±??????? query(a,b,0,0,n)\n  ll query(int a,int b,int k=0,int l=0,int r=N){\n    if(r<=a||b<=l)return INF;\n    if(a<=l&&r<=b)return dat[k];\n    ll vl=query(a,b,k*2+1,l,(l+r)/2);\n    ll vr=query(a,b,k*2+2,(l+r)/2,r);\n    return min(vl,vr);\n  }\n};\n \n \nint main(){  \n  ll n,x[N];\n  cin>>n;\n  RMQ rmq;\n  for(int i=0;i<n;i++) cin>>x[i];\n \n  ll sum=n*(1+n)/2,ans=sum;\n  for(int i=0;i<n;i++){\n    ll mx=-rmq.query(1,x[i])+x[i];\n    ans=min(ans,sum-mx);\n    rmq.update(x[i],-mx);\n  }\n  cout <<ans<<endl;\n  return 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include<cstdio>\n#include<algorithm>\nusing namespace std;\n\ntypedef long long ll;\n\nconst ll INF = -1000000000000;\n\nll n, x[100001];\nll N, dat[400001], dp[100001];\n\nvoid init() {\n  N = 1;\n  while (N < n + 1) N *= 2;\n  for (int i = 0; i < 2 * N - 1; i++) dat[i] = INF;\n}\n\nvoid update(int k, int a) {\n  k += N - 1;\n  dat[k] = a;\n  while (k > 0) {\n    k = (k - 1) / 2;\n    dat[k] = max(dat[k * 2 + 1], dat[k * 2 + 2]);\n  }\n}\n\nll query(ll a, ll b, ll k, ll l, ll r) {\n  if (r <= a || b <= l) return INF;\n  if (a <= l && r <= b) return dat[k];\n  else {\n    ll vl = query(a, b, k * 2 + 1, l, (l + r) / 2);\n    ll vr = query(a, b, k * 2 + 2, (l + r) / 2, r);\n    return max(vl, vr);\n  }\n}\n\nll seg(ll a) {\n  return query(0, a, 0, 0, N);\n}\n\n\nint main() {\n  scanf(\"%lld\", &n);\n  init();\n  for (int i = 1; i <= n; i++) scanf(\"%lld\", &x[i]);\n  update(0, 0);\n  for (int i = 1; i <= n; i++) {\n    dp[i] = seg(x[i]) + x[i];\n    update(x[i], dp[i]);\n  }\n  ll ans = 0;\n  for (int i = 1; i <= n; i++) ans = max(ans, dp[i]);\n  printf(\"%lld\\n\", n * (n + 1) / 2 - ans);\n}\n"
  },
  {
    "language": "C++",
    "code": "#include <stdio.h>\n#include <algorithm>\nusing namespace std;\nint n, a[100000]; long long dp[100001];\nint main() {\n\tscanf(\"%d\", &n);\n\tfor (int i = 0; i < n; i++) scanf(\"%d\", &a[i]);\n\tfor (int i = 1; i <= n; i++) {\n\t\tdp[i] = a[i - 1];\n\t\tfor (int j = 0; j < i - 1; j++) {\n\t\t\tif (a[j] < a[i - 1]) {\n\t\t\t\tdp[i] = max(dp[i], dp[j] + a[i - 1]);\n\t\t\t}\n\t\t\telse {\n\t\t\t\tdp[i] = max(dp[i], dp[j]);\n\t\t\t}\n\t\t}\n\t}\n\tprintf(\"%d\\n\", dp[n]);\n\treturn 0;\n}"
  },
  {
    "language": "C++",
    "code": "//2431\n#include <bits/stdc++.h>\n\nusing namespace std;\n\nconst int MAX_N=1e5;\n\n#define FOR(i,a,b) for(int i=(a);i<(b);i++)\n#define REP(i,a) FOR(i,0,a)\n\ntypedef long long ll;\n\nconst ll INF=1e15;\n\nint n;\nint x[MAX_N];\n\nll seg[MAX_N*4];\nint s;\n\nvoid init(){\n\ts=1;\n\twhile (s<MAX_N){\n\t\ts<<=1;\n\t}\n}\n\nvoid update(int i,ll x){\n\ti+=s-1;\n\tdo{\n\t\tseg[i]=max(seg[i],x);\n\t\ti/=2;\n\t}while (i);\n}\n\nll query(int a,int b,int k=1,int l=1,int r=s){\n\tif (a<=l && r<=b){\n\t\treturn seg[k];\n\t}\n\tif (b<l || r<a){\n\t\treturn 0;\n\t}\n\tint mid=(l+r)/2;\n\treturn max(query(a,b,k*2,l,mid),query(a,b,k*2+1,mid+1,r));\n}\n\nint main(){\n\tscanf(\"%d\",&n);\n\tll sum=0;\n\tREP(i,n){\n\t\tscanf(\"%d\",&x[i]);\n\t\tsum+=x[i];\n\t}\n\tinit();\n\tREP(i,n){\n\t\tupdate(x[i],query(1,x[i])+x[i]);\n\t}\n\tprintf(\"%lld\\n\",sum-seg[1]);\n\treturn 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include<bits/stdc++.h>\nusing namespace std;\n#define int long long\nconst int MAX_N = 1 << 17;\nint bit[MAX_N+1],n;\nint sum(int i){\n  int s=0;\n  while(i>0){\n    s+=bit[i];\n    i-=i&-i;\n  }\n  return s;\n}\nvoid add(int i,int x){\n  while(i<=n){\n    bit[i]+=x;\n    i+=i&-i;\n  }\n}\nsigned main(){\n  memset(bit,0,sizeof(bit));\n  cin>>n;\n  int x[n],ans=0;\n  for(int i=0;i<n;i++) cin>>x[i];\n  for(int i=n-1;i>=0;i--){\n    //cout<<x[i]<<\":\"<<sum(x[i])<<endl;\n    ans+=min(x[i],sum(x[i]));\n    add(x[i],x[i]);\n  }\n  cout<<ans<<endl;\n  return 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include <cstdio>\n#include <cstdlib>\n#include <cstring>\n#include <climits>\n#include <cmath>\n#include <cassert>\n#include <iostream>\n#include <sstream>\n#include <iomanip>\n#include <algorithm>\n#include <numeric>\n#include <complex>\n#include <list>\n#include <stack>\n#include <queue>\n#include <set>\n#include <map>\n#include <bitset>\n#include <utility>\n#include <functional>\n#include <iterator>\n\nusing namespace std;\n\n#define dump(n) cerr<<\"# \"<<#n<<\"=\"<<(n)<<endl\n#define repi(i,a,b) for(int i=int(a);i<int(b);i++)\n#define peri(i,a,b) for(int i=int(b);i-->int(a);)\n#define rep(i,n) repi(i,0,n)\n#define per(i,n) peri(i,0,n)\n#define iter(c) __typeof__((c).begin())\n#define foreach(i,c) for(iter(c) i=(c).begin();i!=(c).end();++i)\n#define all(c) (c).begin(),(c).end()\n#define mp make_pair\n\ntypedef unsigned int uint;\ntypedef long long ll;\ntypedef unsigned long long ull;\ntypedef vector<int> vi;\ntypedef vector<vi> vvi;\ntypedef vector<double> vd;\ntypedef vector<vd> vvd;\ntypedef vector<string> vs;\ntypedef pair<int,int> pii;\n\nstruct SegTree{\n\tvector<ll> data;\n\tint size;\n\tSegTree(int _size){\n\t\tfor(int i=1;;i<<=1)\n\t\t\tif(i>=_size){\n\t\t\t\tsize=i;\n\t\t\t\tbreak;\n\t\t\t}\n\t\tdata.assign(2*size,0);\n\t}\n\tvoid Update(int i,ll n){\n\t\tdata[size+i]=n;\n\t\tfor(int j=size+i;j;j>>=1)\n\t\t\tdata[j]=max(data[j],n);\n\t}\n\tll Query(int a,int b,int i,int l,int r){\n\t\tif(b<=l || r<=a) return 0;\n\t\tif(a<=l && r<=b) return data[i];\n\t\tll res=0;\n\t\tint m=(l+r)/2;\n\t\tif(a<m) res=max(res,Query(a,b,i*2+0,l,m));\n\t\tif(m<b) res=max(res,Query(a,b,i*2+1,m,r));\n\t\treturn res;\n\t}\n\tll Query(int a,int b){\n\t\treturn Query(a,b,1,0,size);\n\t}\n};\n\nint main()\n{\n\tfor(int n;cin>>n;){\n\t\tvi a(n);\n\t\trep(i,n) cin>>a[i];\n\t\t\n\t\tvi b(n);\n\t\trep(i,n) b[a[i]-1]=i;\n\t\t\n\t\tSegTree st(n);\n\t\tll mx=0;\n\t\trep(i,n){\n\t\t\tst.Update(b[i],st.Query(0,b[i])+i+1);\n\t\t\tmx=max<ll>(mx,st.Query(0,b[i]+1));\n\t\t}\n\t\tcout<<(ll)n*(n+1)/2-mx<<endl;\n\t}\n\t\n\treturn 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include<algorithm>\n#include<cassert>\n#include<cctype>\n#include<climits>\n#include<cmath>\n#include<cstdio>\n#include<cstdlib>\n#include<cstring>\n#include<iostream>\n#include<iomanip>\n#include<map>\n#include<numeric>\n#include<queue>\n#include<vector>\n#include<set>\n#include<string>\n#include<stack>\n#include<sstream>\n#include<complex>\n\n#define pb push_back\n#define clr clear()\n#define sz size()\n#define fs first\n#define sc second\n\n#define rep(i,a) for(int i=0;i<(int)(a);i++)\n#define rrep(i,a) for(int i=(int)(a)−1;i>=0;i−−)\n#define all(a) (a).begin(),(a).end()\n#define EQ(a,b) (abs((a)−(b)) < EPS)\n#define INIT(a) memset(a,0,sizeof(a))\n\nusing namespace std;\ntypedef double D;\ntypedef pair<int,int> P;\ntypedef long long ll;\ntypedef vector<int> vi;\ntypedef vector<string> vs;\n\nconst D EPS = 1e-7;\nconst D INF = 1e9;\nconst D PI = acos(-1);\nconst int N = 100100;\n\nll n,dat[2*N-1];\n\nvoid init(int n_){\n  n=1;\n  while(n<n_)n*=2;\n  rep(i,2*n-1)dat[i] = 0;\n}\n\nvoid update(int k,int a){\n  k += n-1;\n  dat[k] = a;\n  while(k>0){\n    k = (k-1)/2;\n    dat[k] = max(dat[k*2+1],dat[k*2+2]);\n  }\n}\n\n//return minimam value in [a,b). ( [l,r) is interval in which k is.)\nll query(int a,int b,int k,int l,int r){\n  if(r<=a || b<=l)return 0;\n  if(a<=l && r<=b)return dat[k];\n  ll vl = query(a,b,2*k+1,l,(l+r)/2);\n  ll vr = query(a,b,2*k+2,(l+r)/2,r);\n  return max(vl,vr);\n}\n\nint main(){\n  ll n_, x[100100];\n\n  cin >> n_;\n  rep(i,n_)cin >> x[i];\n  init(n_);\n\n  ll ans = 0;\n  rep(i,n_){\n    ll val = query(0,x[i],0,0,n);\n    ans = max(ans,val+x[i]);\n    update(x[i]-1,val+x[i]);\n  }\n\n  cout << n_*(n_+1)/2 - ans << endl;\n}"
  },
  {
    "language": "C++",
    "code": "#include<bits/stdc++.h>\nusing namespace std;\n\nclass RMQ{\n  int n;\n  vector<int>dat;\npublic:\n  RMQ(int n_){\n    n = 1;\n    while(n < n_) n *= 2;\n    dat.resize(2*n - 1);\n    for(int i = 0; i < 2*n - 1; i++) dat[i] = 0;\n  }\n  void update(int k,int a){\n    k += n - 1;\n    dat[k] = max(a, dat[k]);\n    while(k > 0){\n      k = (k - 1)/2;\n      dat[k] = max(dat[k*2 + 1], dat[k*2 + 2]);\n    }\n  }\n  void print(){\n    for (int i = n - 1; i < 2*n - 1; i++) {\n      std::cout << dat[i] << \" \";\n    }\n    std::cout << std::endl;\n  }\n  int query(int a,int b,int k = 0,int l = 0,int r = 0){\n    if(r <= l) r = n;\n    if(r <= a || b <= l) return 0;\n    if(a <= l && r <= b) return dat[k];\n    int vl = query(a, b, k*2 + 1, l, (r + l)/2);\n    int vr = query(a, b, k*2 + 2, (r + l)/2, r);\n    return max(vl, vr);\n  }\n};\n\n\nint main(int argc, char *argv[]){\n  int n;\n  cin >> n;\n  vector<int> x(n);\n  RMQ r(n);\n  for (int i = 0; i < n; i++) {\n    cin >> x[i];\n  }\n  vector<int> dp(n);\n  for (int i = 0; i < n; i++) {\n    r.update(x[i] - 1, x[i] + r.query(0, x[i] - 1));\n  }\n   std::cout << (n*(n + 1))/2 - r.query(0, n) << std::endl;\n  return 0;\n}"
  },
  {
    "language": "C++",
    "code": "//2431\n#include <bits/stdc++.h>\n\nusing namespace std;\n\nconst int MAX_N=1e5;\n\n#define FOR(i,a,b) for(int i=(a);i<(b);i++)\n#define REP(i,a) FOR(i,0,a)\n\ntypedef long long ll;\n\nint n;\nint x[MAX_N];\n\nll dp[MAX_N];\n\nint main(){\n\tscanf(\"%d\",&n);\n\tll sum=0;\n\tREP(i,n){\n\t\tscanf(\"%d\",&x[i]);\n\t\tsum+=x[i];\n\t}\n\tdp[0]=x[0];\n\tll lis=dp[0];\n\tFOR(i,1,n){\n\t\tdp[i]=x[i];\n\t\tFOR(j,0,i){\n\t\t\tif (x[j]<x[i]){\n\t\t\t\tdp[i]=max(dp[i],dp[j]+x[i]);\n\t\t\t}\n\t\t}\n\t\tlis=max(lis,dp[i]);\n\t}\n\tprintf(\"%lld\\n\",sum-lis);\n\treturn 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include <iostream>\n#include <vector>\n#include <algorithm>\n#include <cassert>\n\n#define show(x) cerr << #x << \" = \" << x << endl\n\nusing namespace std;\nusing ll = long long;\n\ntemplate <typename T>\nostream& operator<<(ostream& os, const vector<T>& v)\n{\n    os << \"sz:\" << v.size() << \"\\n[\";\n    for (const auto& p : v) {\n        os << p << \",\";\n    }\n    os << \"]\\n\";\n    return os;\n}\n\nconstexpr ll INF = 1LL << 60;\n\nstruct Max {\n    using T = ll;\n    T operator()(const T& a, const T& b) const\n    {\n        return max(a, b);\n    }\n    T inv(const T& a) const\n    {\n        return -a;  // dame\n    }\n    static constexpr T identity()\n    {\n        return -INF;\n    }\n};\ntemplate <typename Base>\nclass BinaryIndexedTree\n{\npublic:\n    using T = typename Base::T;\n    using AbelGroup = Base;\n\n    BinaryIndexedTree(const int n) : data_num(n), size(1 << (__lg(2 * data_num - 1))), value(size + 1, AbelGroup::identity()) { assert(n > 0); }\n    BinaryIndexedTree(const vector<T>& val) : data_num(val.size()), size(1 << (__lg(2 * data_num - 1))), value(size + 1, AbelGroup::identity())\n    {\n        for (int i = 1; i <= size; i++) {\n            value[i] = val[i - 1];\n        }\n        for (int x = 1; x < size; x++) {\n            value[x + (x & -x)] += value[x];\n        }\n    }\n\n    T accumulate(const int a) const\n    {\n        assert(0 <= a and a < data_num);\n        int ind = a + 1;\n        T sum = AbelGroup::identity();\n        while (ind > 0) {\n            sum = op(sum, value[ind]);\n            ind &= ind - 1;\n        }\n        return sum;\n    }\n\n    void add(const int a, const T& val)\n    {\n        assert(0 <= a and a < data_num);\n        int ind = a + 1;\n        while (ind <= size) {\n            value[ind] = op(value[ind], val);\n            ind += ind & (-ind);\n        }\n    }\n\n    void set(const int a, const T& val)\n    {\n        const int v = get(a);\n        add(a, op(val, op.inv(v)));\n    }\n\n    T get(const int a) const\n    {\n        assert(0 <= a and a < data_num);\n        if (a == 0) {\n            return accumulate(a);\n        } else {\n            return op(op.inv(accumulate(a - 1)), accumulate(a));\n        }\n    }\n\n    int lowerBound(T w) const\n    {\n        if (w <= AbelGroup::identity()) {\n            return 0;\n        }\n        int x = 0;\n        for (int k = ((size == data_num) ? size : size / 2); k > 0; k /= 2) {\n            if (x + k <= size and value[x + k] < w) {\n                w = op(w, op.inv(value[x + k]));\n                x += k;\n            }\n        }\n        return x;\n    }\n\nprivate:\n    const int data_num;\n    const int size;\n    const AbelGroup op{};\n    vector<T> value;\n};\n\n\nint main()\n{\n    ll n;\n    cin >> n;\n    vector<ll> a(n + 1, 0);\n    for (int i = 1; i <= n; i++) {\n        cin >> a[i];\n    }\n    vector<ll> dp(n + 1, 0);\n    BinaryIndexedTree<Max> bit(n + 1);\n    for (int i = 0; i <= n; i++) {\n        if (i > 0) {\n            dp[i] = bit.accumulate(a[i]) + a[i];\n        }\n        bit.add(a[i], dp[i]);\n    }\n    const ll maxi = *max_element(dp.begin(), dp.end());\n    cout << n * (n + 1) / 2 - maxi << endl;\n\n    return 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include <cstdio>\n#include <iostream>\n#include <algorithm>\n#include <string>\n#include <cstring>\n#include <vector>\n#include <queue>\n#include <set>\n#include <map>\n#include <cmath>\n#include <iomanip>\nusing namespace std;\n\ntypedef pair<int, int> P;\n#define rep(i, n) for (int i=0; i<(n); i++)\n#define all(c) (c).begin(), (c).end()\n#define uniq(c) c.erase(unique(all(c)), (c).end())\n#define _1 first\n#define _2 second\n#define pb push_back\n#define INF 1145141919\n#define MOD 1000000007\n\n#define MAX_N (1<<17)\nstruct SegTree {\n  long long seg[MAX_N*2-1];\n\n  void update(int i, long long x) {\n    i += MAX_N-1;\n    if (seg[i] >= x) return;\n    seg[i] = x;\n    while (i > 0) {\n      i = (i-1) / 2;\n      seg[i] = max(seg[i*2+1], seg[i*2+2]);\n    }\n  }\n\n  long long query(int a, int b, int k=0, int l=0, int r=MAX_N) {\n    if (r <= a || b <= l) return 0;\n    if (a <= l && r <= b) return seg[k];\n    return max(\n      query(a, b, k*2+1, l, (l+r)/2),\n      query(a, b, k*2+2, (l+r)/2, r)\n    );\n  }\n};\n\nint N;\nint A[100000];\nSegTree seg;\n\nsigned main() {\n  ios::sync_with_stdio(false); cin.tie(0);\n  cin >> N;\n  rep(i, N) cin >> A[i];\n  rep(i, N) {\n    seg.update(A[i], seg.query(0, A[i]) + A[i]);\n  }\n  long long sum = 0;\n  rep(i, N) sum += A[i];\n  cout << sum - seg.query(0, N+1) << \"\\n\";\n  return 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\n\nusing namespace std;\n\ntypedef pair<int, int> P;\n\ntypedef long long ll;\n\n#define INF 1000000000000LL\n\nll max(ll a, ll b) { return a > b ? a : b; }\n\nstruct Bit {\n\tint bitSize;\n\tvector<ll> bit;\n\tvoid init(int n, ll v) {\n\t\tbitSize = n;\n\t\tbit = vector<ll>(n+1, 0);\n\t}\n\tvoid add(int n, ll v) {\n\t\t++n;\n\t\twhile (n <= bitSize) {\n\t\t\tbit[n] = max(bit[n], v);\n\t\t\tn += n & -n;\n\t\t}\n\t}\n\tll sum(int r) {\n\t\tll ret = 0;\n\n\t\twhile (r) {\n\t\t\tret = max(ret, bit[r]);\n\t\t\tr -= r & -r;\n\t\t}\n\n\t\treturn ret;\n\t}\n};\n\nBit bit;\n\nint main() {\n\tint N; cin >> N;\n\tvector<P> v;\n\tfor (int i = 0; i < N; ++i) {\n\t\tint x; cin >> x;\n\t\tv.push_back( P(x, i) );\n\t}\n\n\tsort( v.begin(), v.end() );\n\n\tll sum = (ll)N*(N+1)/2;\n\n\tbit.init(N, 0);\n\tll ans = 0;\n\tfor (int i = 0; i < N; ++i) {\n\t\tll val = bit.sum(v[i].second+1) + v[i].first;\n\t\tans = max(ans, val);\n\t\tbit.add(v[i].second, val);\n//\t\tcout << bit.sum(v[i].second+1) << endl;\n\t}\n\tans = sum-ans;\n\tcout << ans << endl;\n}"
  },
  {
    "language": "C++",
    "code": "// AOJ 2431\n#include<cstdio>\n#include<algorithm>\n#define rep(i,a) for( int i = 0; i != (a); ++i )\n\ntypedef long long ll;\n\nint n;\nll bit[100000];\n\nvoid add( int k, ll x )\n{\n\tfor( int i = k; i < n; i |= i+1 )\n\t\tbit[i] = std::max( bit[i], x );\n\n\treturn;\n}\n\nll sum( int k )\n{\n\tll ret = 0;\n\n\tfor( int i = k-1; i >= 0; i = (i&(i+1))-1 )\n\t\tret = std::max( ret, bit[i] );\n\n\treturn ret;\n}\n\nint main()\n{\n\tscanf( \"%d\", &n );\n\trep( i, n )\n\t{\n\t\tint x;\n\t\tscanf( \"%d\", &x );\n\t\tadd( x-1, sum( x-1 )+x );\n\t}\n\n\tprintf( \"%lld\\n\", ll(n*(n+1)>>1)-sum(n) );\n\n\treturn 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\nusing namespace std;\n#define FOR(i,k,n) for(int i = (k); i < (n); i++)\n#define REP(i,n) FOR(i,0,n)\n#define ALL(a) a.begin(), a.end()\n#define MS(m,v) memset(m,v,sizeof(m))\n#define D10 fixed<<setprecision(10)\ntypedef long long ll;\ntypedef long double ld;\ntypedef vector<int> vi;\ntypedef vector<string> vs;\ntypedef pair<int, int> pii;\nconst int MOD = 1000000007;\nconst int INF = MOD + 1;\nconst ld EPS = 1e-12;\ntemplate<class T> T &chmin(T &a, const T &b) { return a = min(a, b); }\ntemplate<class T> T &chmax(T &a, const T &b) { return a = max(a, b); }\n\n/*--------------------template--------------------*/\nstruct Data\n{\n\tll num;\n\tData() :num(INF) {};\n\tData(int n) :num(n) {};\n};\n\nstruct SegmentTree\n{\n\tint n; vector<Data> data;\n\tSegmentTree(int N)\n\t{\n\t\tn = 1;\n\t\twhile (n < N) n *= 2;\n\t\tdata.resize(2 * n);\n\t}\nprivate:\n\tData sub(int left, int right, int node, int nleft, int nright)\n\t{\n\t\tif (nright <= left || right <= nleft) return Data();\n\t\tif (left <= nleft && nright <= right) return data[node];\n\t\tData vl = sub(left, right, node * 2 + 1, nleft, (nleft + nright) / 2);\n\t\tData vr = sub(left, right, node * 2 + 2, (nleft + nright) / 2, nright);\n\t\treturn min(vl.num, vr.num);\n\t}\n\npublic:\n\tvoid update(int pos, Data value)\n\t{\n\t\tpos += n - 1;\n\t\tdata[pos] = value;\n\t\twhile (pos > 0)\n\t\t{\n\t\t\tpos = (pos - 1) / 2;\n\t\t\tdata[pos] = min(data[pos * 2 + 1].num, data[pos * 2 + 2].num);\n\t\t}\n\t}\n\tData min_query(int left, int right)\n\t{\n\t\treturn sub(left, right, 0, 0, n);\n\t}\n};\n\n\n\nint main()\n{\n\tll n;\n\tcin >> n;\n\tSegmentTree seg(n);\n\tREP(i, n) seg.update(i, 0);\n\tREP(i, n)\n\t{\n\t\tint a;\n\t\tcin >> a;\n\t\tll val = seg.min_query(0, a).num - a;\n\t\tseg.update(a-1, val);\n\t}\n\tcout << n*(n + 1) / 2 + seg.min_query(0, n).num << endl;\n\treturn 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include <iostream>\n#include <vector>\n#include <algorithm>\n#include <string>\n#include <sstream>\n#include <cstring>\n#include <cstdio>\n#include <cstdlib>\n#include <cmath>\n#include <queue>\n#include <stack>\n#include <map>\n#include <set>\n#include <numeric>\n#include <cctype>\n#include <tuple>\n#include <array>\n#include <climits>\n#include <bitset>\n#include <cassert>\n\n#ifdef _MSC_VER\n#include <agents.h>\n#endif\n\n#define FOR(i, a, b) for(int i = (a); i < (int)(b); ++i)\n#define rep(i, n) FOR(i, 0, n)\n#define ALL(v) v.begin(), v.end()\n#define REV(v) v.rbegin(), v.rend()\n#define MEMSET(v, s) memset(v, s, sizeof(v))\n#define UNIQUE(v) (v).erase(unique(ALL(v)), (v).end())\n#define MP make_pair\n#define MT make_tuple\n\nusing namespace std;\n\ntypedef long long ll;\ntypedef long double ld;\ntypedef pair<int, int> P;\n\nconst int N = 1 << 18;\n\nll dat[N];\nint n;\n\nvoid set_n(int nn){\n\tn = 1;\n\twhile (n < nn) n *= 2;\n}\n\nvoid update(int i, ll x){\n\ti += n - 1;\n\tdat[i] = x;\n\twhile (i > 0){\n\t\ti = (i - 1) / 2;\n\t\tdat[i] = max(dat[i * 2 + 1], dat[i * 2 + 2]);\n\t}\n}\n\nll query(int a, int b, int l, int r, int i){\n\tif (b <= l || r <= a) return 0;\n\tif (a <= l && r <= b) return dat[i];\n\n\treturn max(query(a, b, l, (l + r) / 2, i * 2 + 1),\n\t\tquery(a, b, (l + r) / 2, r, i * 2 + 2));\n}\nll query(int a, int b){ return query(a, b, 0, n, 0); }\n\n\nint main(){\n\tcin.tie(0);\n\tios::sync_with_stdio(false);\n\tcout.setf(ios::fixed);\n\tcout.precision(20);\n\n\tint n;\n\tcin >> n;\n\tvector<int> a(n);\n\trep(i, n) cin >> a[i];\n\n\tset_n(n);\n\trep(i, n){\n\t\tupdate(a[i] - 1, query(0, a[i]) + a[i]);\n\t}\n\n\tcout << accumulate(ALL(a), 0ll) - query(0, n + 1) << endl;\n\n}"
  },
  {
    "language": "C++",
    "code": "#include <iostream>\n#include <cstdio>\n#include <cmath>\n#include <vector>\n#include <map>\n#include <stack>\n#include <queue>\n#include <algorithm>\n#include <set>\n\n#define FOR(i,a,b) for(int i=(a);i<(b);i++)\n#define REP(i,j) FOR(i,0,j)\n#define mp std::make_pair\n\nconst int INF = 1 << 24;\nconst int dx[8] = {0, 0, 1, -1, 1, 1, -1, -1}, dy[8] = {1, -1, 0, 0, 1, -1, 1, -1};\n\ntypedef unsigned long long ull;\ntypedef std::pair<int,int> P;\n\nconst int MAX_W = 100001;\nint N, X[100000];\n\nclass SegmentTree{\npublic:\n    SegmentTree(){}\n    SegmentTree(int n){init(n);}\n    void init(int n){\n        size = 1;\n        while(size < n){\n            size *= 2;\n        }\n        REP(i, size*2-1){\n            data[i] = 0;\n        }\n    }\n    void update(int index, ull v){\n        index += size - 1;\n        data[index] = v;\n        while(index > 0){\n            index = (index-1) / 2;\n            data[index] = std::max(data[index*2+1], data[index*2+2]);\n        }\n    }\n    ull query(int a, int b){\n        return _query(a, b, 0, 0, size);\n    }\nprivate:\n    ull _query(int a, int b, int k, int l, int r){\n        if(b <= l || r <= a){return 0;}\n        if(a <= l && r <= b){return data[k];}\n        return std::max(_query(a, b, k*2+1, l, (l+r)/2), _query(a, b, k*2+2, (l+r)/2, r));\n    }\n    ull data[MAX_W*4];\n    int size;\n};\n\nSegmentTree st;\n\nint main(){\n    std::cin >> N;\n    st.init(N+1);\n\n    ull sum = 0;\n    REP(i, N){\n        std::cin >> X[i];\n        sum += X[i];\n    }\n\n    REP(i, N){\n        //std::cout << st.query(0, X[i]) + X[i] << std::endl;\n        st.update(X[i], st.query(0, X[i]) + X[i]);\n    }\n    \n    std::cout << sum-st.query(0, 100001) << std::endl;\n}"
  },
  {
    "language": "C++",
    "code": "#include \"bits/stdc++.h\"\nusing namespace std;\n// http://judge.u-aizu.ac.jp/onlinejudge/description.jsp?id=2431&lang=jp\ntypedef long long ll;\n#define INF 1<<30\n#define LINF 1LL<<60\n/*\n\t??§????????????????????????????????????????????????????????????????°??????????????????????????????????????????§???(?????????????¢??????¨?????????\n\n\t???????¢??????¨?????????????????????????????§???????????????\n\t?????????????????????????´?????????????????????\\?????????????????¨?????????????????¨?????§???????????§???????????¨??????????????????????????????\n\t ??????dp[k] = max(dp[1]~dp[k-1])+k\n\t    RMQ?????¨??????????????§??????????´¢??????????????´??°????????????\n\n\t?????????dp????????§?????¨??¨?????????(1/2*n(n+1))??¨??????\n*/\n\n/* ???????????????*/\nstruct SegTree {\n\tusing type = ll; \ttype INIT_VAL = 0;\n\ttype merge(type a, type b) { return max(a, b); } \n\ttype N; vector<type> dat;\n\tSegTree(type _N) { N = 1;\twhile (N < _N)N *= 2;dat = vector<type>(N * 2 - 1,INIT_VAL); }\n\tvoid update(int k, type val) { k += N - 1; dat[k] = val;\twhile (k) { k = (k - 1) / 2; dat[k] = merge(dat[k * 2 + 1], dat[k * 2 + 2]); } }\n\ttype query(int a, int b, int k, int l, int r) {\n\t\tif (r <= a || b <= l)return INIT_VAL; if (a <= l&&b >= r)return dat[k];\n\t\ttype v1 = query(a, b, k * 2 + 1, l, (l + r) / 2); type v2 = query(a, b, k * 2 + 2, (l + r) / 2, r);\treturn merge(v1, v2);\n\t}\n\tinline type query(int a, int b) { return query(a, b, 0, 0, N); }\n};\n\nint main() {\n\tcin.tie(0); ios::sync_with_stdio(false);\n\tll n; cin >> n;\n\tvector<ll> x(n);\n\tfor (int i = 0; i < n;i++)cin >> x[i];\n\tSegTree seg(n + 1);\n\tll ans = 0;\n\tfor (int i = 0;i < n;i++) {\n\t\tll max_v = seg.query(1, x[i]);\n\t\tans = max(ans, max_v + x[i]);\n\t\tseg.update(x[i], max_v + x[i]);\n\t}\n\t//cout << n*(n + 1) / 2 - ans << endl;\n\tcout << n*(n + 1) / 2 - seg.dat[0] << endl;\n\treturn 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\nusing namespace std;\nusing ll = long long;\nusing P = pair<ll, ll>;\nconst ll MOD = 1000000007;\n\n// 0-origin BIT\ntemplate <typename T>\nclass BIT{\npublic:\n    vector<T> data;\n    int n;\n    BIT(){}\n    BIT(int n_){\n        n = n_;\n        data.assign(n, T(0));\n    }\n    // v[a] += w\n    void add(int a, T w){\n        for (int x = a; x < n; x |= x + 1) data[x] += w;\n    }\n    // sum of v[i] for i in [0, a)\n    T sum(int a){\n        T ret = 0;\n        for (int x = a - 1; x >= 0; x = (x & (x + 1)) - 1) {\n            ret += data[x];\n        }\n        return ret;\n    }\n};\n\nint main(){\n    int n;\n    cin >> n;\n\n    vector<P> x(n);\n    for(int i=0;i<n;i++){\n        cin >> x[i].first;\n        x[i].second = i;\n    }\n    sort(x.begin(), x.end());\n\n    BIT<ll> bit(n);\n    ll ans = 0;\n    for(P& p : x){\n        ll i = p.second, v = p.first;\n        ll rev = n - 1 - i;\n        ll c = min(v, bit.sum(rev));\n        ans += c;\n        bit.add(rev, v - c);\n    }\n    cout << ans << endl;\n\n    return 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include<iostream>\n#include<vector>\n#include<algorithm>\n#include<climits>\n\nconst int MAX_N=1000000;\n\ntypedef long long ll;\n\nusing namespace std;\n\nll n,dat[2*MAX_N-1];\n\nvoid init(int n_){\n\tn=1;\n\twhile(n<n_)n*=2;\n\tfor(int i=0;i<2*n-1;i++)dat[i]=0;\n}\n\nvoid update(int k,int a){\n\tk+=n-1;\n\tdat[k]=a;\n\t\n\twhile(k>0){\n\t\tk=(k-1)/2;\n\t\tdat[k]=max(dat[2*k+1],dat[2*k+2]);\n\t}\n}\n\nint query(int a,int b,int k,int l,int r){\n\tif(r<=a || b<=l)return 0;\n\tif(a<=l && r<=b)return dat[k];\n\telse {\n\t\tint vl=query(a,b,k*2+1,l,(l+r)/2);\n\t\tint vr=query(a,b,k*2+2,(l+r)/2,r);\n\t\treturn max(vl,vr);\n\t}\n}\n\nint main(void){\n\t\n\tll in,n_,ans=0;\n\tcin >> n_;\n\t\n\tinit(n_);\n\t\n\tfor(int i=0;i<n_;i++){\n\t\tcin >> in;\n\t\tupdate(in,in+query(1,in+1,0,0,n));\n\t\tans=max(ans,dat[in+n-1]);\n\t}\n\tcout << n_*(n_+1)/2-ans << endl;\n\t\n\treturn 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include <iostream>\n#include <vector>\n#include <map>\n#include <tuple>\n#include <climits>\nusing namespace std;\n\nconst int MAX_N = 1<<17;\n\nint n;\nint64_t dat[2*MAX_N-1];\n\nvoid init(int n_){\n    n = 1;\n    while(n<n_)n*=2;\n    for(int i=0;i<2*n-1;i++) dat[i]=LLONG_MAX;\n}\n\n//0-indexed, k-th to a\nvoid update(int k, int64_t a){\n    k+=n-1;\n    dat[k]=a;\n    while(k>0){\n        k=(k-1)/2;\n        dat[k]=min(dat[k*2+1],dat[k*2+2]);\n    }\n}\n\n//[a,b)???????°????\nint64_t query(int a, int b, int k=0, int l=0, int r=n){\n    if(r<=a||b<=l) return LLONG_MAX;\n    if(a<=l&&r<=b) return dat[k];\n    else{\n        int64_t vl = query(a,b,k*2+1,l,(l+r)/2);\n        int64_t vr = query(a,b,k*2+2,(l+r)/2,r);\n        return min(vl,vr);\n    }\n}\n\nusing P = pair<int,int>;\n\nint main(){\n    int N;\n    cin>>N;\n    vector<P> V;\n    vector<int> X;\n    for(int i=0;i<N;i++){\n        int x;\n        cin>>x;\n        V.emplace_back(x,i);\n        X.push_back(x);\n    }\n    sort(V.begin(), V.end());\n    vector<int> nth(N);\n    for(int i=0;i<N;i++){\n        nth[V[i].second]=i;\n    }\n    init(N);\n    for(int i=0;i<N;i++){\n        update(i,0);\n    }\n    for(int i=0;i<N;i++){\n        int64_t sum = -X[i];\n        if(nth[i]){\n            sum+=query(0,nth[i]);\n        }\n        update(nth[i],sum);\n    }\n    int64_t ans = 0;\n    for(auto x:X) ans+=x;\n    ans+=query(0,N);\n    cout<<ans<<endl;\n\n    return 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include<iostream>\n#include<vector>\n#include<algorithm>\n#include<climits>\n\nconst int MAX_N=1000000;\n\ntypedef long long ll;\n\nusing namespace std;\n\nll n,dat[2*MAX_N-1];\n\nvoid init(int n_){\n\tn=1;\n\twhile(n<n_)n*=2;\n\tfor(int i=0;i<2*n-1;i++)dat[i]=0;\n}\n\nvoid update(int k,ll a){\n\tk+=n-1;\n\tdat[k]=a;\n\t\n\twhile(k>0){\n\t\tk=(k-1)/2;\n\t\tdat[k]=max(dat[2*k+1],dat[2*k+2]);\n\t}\n}\n\nll query(int a,int b,int k,int l,int r){\n\tif(r<=a || b<=l)return 0;\n\tif(a<=l && r<=b)return dat[k];\n\telse {\n\t\tll vl=query(a,b,k*2+1,l,(l+r)/2);\n\t\tll vr=query(a,b,k*2+2,(l+r)/2,r);\n\t\treturn max(vl,vr);\n\t}\n}\n\nint main(void){\n\t\n\tll in,m,ans=0;\n\t\n\tcin >> m;\n\t\n\tinit(m);\n\t\n\tfor(int i=0;i<m;i++){\n\t\tcin >> in;\n\t\tupdate(in,in+query(1,in,0,0,n));\n\t\t//ans=max(ans,dat[in+n-1]);\n\t}\n\tcout << m*(m+1)/2-query(1,in+1,0,0,n) << endl;\n\t\n\treturn 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include <iostream>\n#include <cstdio>\n#include <iomanip>\n#include <vector>\n#include <map>\n#include <set>\n#include <queue>\n#include <bitset>\n#include <stack>\n#include <utility>\n#include <numeric>\n#include <algorithm>\n#include <functional>\n#include <cctype>\n#include <complex>\n#include <string>\n#include <sstream>\n#include <fstream>\n#include <cassert>\nusing namespace std;\n\n//common\n\ntypedef int  i32;\ntypedef long long i64,ll;\ntypedef long double ld;\n\n#define BR \"\\n\"\n#define ALL(c) (c).begin(),(c).end()\n#define REP(i,n) for(int i=0;i<(int)(n);++i)\n#define FOR(i,l,r) for(int i=(int)l;i<(int)(r);++i)\n#define EACH(it,o) for(auto it = (o).begin(); it != (o).end(); ++it)\n#define IN(l,v,r) ((l)<=(v) && (v)<(r))\n\n//config\n//#define NDEBUG\n//#define INF 1<<30\n//#define EPS 1e-8\n//const ll MOD =100000007;\n\n//debug\n#ifdef NDEBUG\n#define DUMP(x)\n#define DUMPLN(x)\n#define DEBUG(x)\n#define DEBUGLN(x)\n#define LINE()\n#define LINELN()\n#define CHECK(exp,act)\n#define STOP(e)\n#else\n#define DUMP(x)  cerr << #x << \" = \" << (x)\n#define DUMPLN(x)  DUMP(x) <<endl\n#define DEBUG(x) DUMP(x) << LINE() << \" \" << __FILE__\n#define DEBUGLN(x) DEBUG(x)<<endl\n#define LINE()    cerr<< \" (L\" << __LINE__ << \")\"\n#define LINELN()    LINE()<<endl\n#define CHECK(exp,act)  if(exp!=act){DUMPLN(exp);DEBUGLN(act);}\n#define STOP(e)  CHECK(e,true);if(!(e)) exit(1);\n#endif\n\ntemplate<class T> inline string toString(const vector<T>& x) {\n\tstringstream ss;\n\tREP(i,x.size()){\n\t\tif(i!=0)ss<<\" \";\n\t\tss<< x[i];\n\t}\n\treturn ss.str();\n}\n\ntemplate<class T> inline string toString(const vector<vector<T> >& map) {\n\tstringstream ss;\n\tREP(i,map.size()){\n\t\tif(i!=0)ss<<BR;\n\t\tss<< toString(map[i]);\n\t}\n\treturn ss.str();\n}\ntemplate<class K,class V>  string toString(map<K,V>& x) {\n\tstring res;stringstream ss;\n\tfor(auto& p:x)ss<< p.first<<\":\" << p.second<<\" \";\n\treturn ss.str();\n}\n\nstring BITtoString(int bit){\n    stringstream ss;\n    while(bit!=0){ss<<(bit%2);bit/=2;}\n    string res=ss.str();reverse(ALL(res));\n    return res;\n}\n\ntemplate<typename T,typename V> inline T pmod(T v,V MOD){\n\treturn (v%MOD+MOD)%MOD;\n}\n#define nextInt(n) scanf(\"%d\",&n)\n#define defInt(n) int n;nextInt(n)\n#define nextLong(n) scanf(\"%lld\",&n)\n#define defLong(n) ll n;nextLong(n)\n#define nextDouble(n) scanf(\"%lf\",&n)\n\n\nnamespace SegmentTrees{\n\tll INF=1LL<<58;\n\n\ttemplate<typename T>\n\tclass RMQ{\n\tprivate:\n\t\tint Pow2Fit(int n){\n\t\t\tint d=1;while((d<<1)<=n)d<<=1;return d;\n\t\t}\n\tpublic:\n\t\tvector<T> dat;\n\t\tint n,size;\n\t\tRMQ(int _n){\n\t\t\tn=Pow2Fit(_n)<<1;\n\t\t\tsize=2*n-1;\n\t\t\tdat=vector<T>(size,0);\n\t\t}\n\t\tvoid set(int v,T a){\n\t\t\tv+=n-1;\n\t\t\tdat[v]=a;\n\t\t\twhile(v>0){\n\t\t\t\tint parent=v=(v-1)/2;\n\t\t\t\tint chl=parent*2+1,chr=parent*2+2;\n\t\t\t\tdat[parent]=max(dat[chl],dat[chr]);\n\t\t\t}\n\t\t}\n\t\tT get(int v){//v\n\t\t\treturn dat[v+n-1];\n\t\t}\n\t\tT query(int a,int b){//[a,b)\n\t\t\treturn query(0,a,b,0,n);\n\t\t}\n\tprivate:\n\t\tT query(int v,int a,int b,int l,int r){//[a,b)\n\t\t\tif(r<=a || b<=l)return 0;//out range\n\t\t\tif(a<=l && r<=b)return dat[v];\n\n\t\t\tT vl=query(v*2+1,a,b,l,(l+r)/2),vr=query(v*2+2,a,b,(l+r)/2,r);\n\t\t\treturn max(vl,vr);\n\t\t}\n\t};\n}\nusing namespace SegmentTrees;\n\nclass Main{\npublic:\n\tvoid run(){\n\t//\tifstream cin(\"in\");\n\t//\tofstream cout( \"out\" );\n\t\twhile(true){\n\t\t\tint N;nextInt(N);\n\t\t\tif(N==0)break;\n\t\t\tRMQ<ll> rmq(N);\n\t\t\tvector<int> as(N);REP(i,N) nextInt(as[i]),as[i];\n\t\t\tREP(i,N){\n\t\t\t\trmq.set(as[i]-1,rmq.query(0,as[i])+as[i]);\n\t\t\t}\n\t\t\tll sum=0;REP(i,N) sum+=(i+1);\n\t\t\tcout << sum-rmq.query(0, N)<<endl;\n\t\t}\n\t}\n};\nint main(){\n\tcout <<fixed<<setprecision(13);\t\n\tios::sync_with_stdio(false);\n\tMain().run();\n\treturn 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include <vector>\n#include <list>\n#include <map>\n#include <set>\n#include <deque>\n#include <stack>\n#include <bitset>\n#include <algorithm>\n#include <functional>\n#include <numeric>\n#include <utility>\n#include <sstream>\n#include <queue>\n#include <iostream>\n#include <iomanip>\n#include <cstdio>\n#include <cmath>\n#include <cstdlib>\n#include <cctype>\n#include <string>\n#include <cstring>\n#include <ctime>\n#include <fstream>\n#include <stdio.h>\n#include <complex>\n\nusing namespace std;\n\n//conversion\n//------------------------------------------\ninline int toInt(string s) {int v; istringstream sin(s);sin>>v;return v;}\ntemplate<class T> inline string toString(T x) {ostringstream sout;sout<<x;return sout.str();}\n\n//typedef\n//------------------------------------------\ntypedef vector<int> VI;\ntypedef vector<VI> VVI;\ntypedef vector<string> VS;\ntypedef pair<int, int> PII;\ntypedef pair<int, PII> TIII;\ntypedef long long LL;\ntypedef vector<LL> VLL;\n\n//container util\n\n//------------------------------------------\n#define ALL(a)  (a).begin(),(a).end()\n#define RALL(a) (a).rbegin(), (a).rend()\n#define PB push_back\n#define MP make_pair\n#define SZ(a) int((a).size())\n#define EACH(i,c) for(typeof((c).begin()) i=(c).begin(); i!=(c).end(); ++i)\n#define EXIST(s,e) ((s).find(e)!=(s).end())\n#define SORT(c) sort((c).begin(),(c).end())\n#define MT(a,b,c) MP(a, MP(b, c))\n\n//repetition\n//------------------------------------------\n#define FOR(i,a,b) for(int i=(a);i<(b);++i)\n#define REP(i,n)  FOR(i,0,n)\n\nint main(){\n\tint n;\n\tcin >> n;\n\tVI a(n);\n\tVLL b(n, 0);\n\tREP(i,n)cin>>a[i];\n\tREP(i,n){\n\t\t//a[i]を使う場合\n\t\tint idx = a[i]-1;\n\t\tREP(j,a[i]){\n\t\t\tb[idx] = max(b[idx], (j==a[i]-1)?a[i]:(b[j]+a[i]));\n\t\t}\n\t}\n\tLL s=0;\n\tREP(i,n)s = max(s, b[i]);\n\tcout << n*(n+1)/2-s << endl;\n\treturn 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include <vector>\n#include <cstdio>\nusing namespace std;\ntypedef long long ll;\n\ntemplate <typename T>\nstruct fenwick_tree {\n    vector<T> x;\n    fenwick_tree(int n) : x(n, 0) { }\n    T max(int j) {\n        T S = 0;\n        for (; j >= 0; j = (j & (j + 1)) - 1) S = std::max(x[j],S);\n        return S;\n    }\n    void chmax(int k, T a) {\n        for (; k < x.size(); k |= k+1) x[k] = std::max(x[k],a);\n    }\n};\n\nint main(){\n    ll n;scanf(\"%lld\",&n);\n    fenwick_tree<ll> dp(n+1);\n    for(int i=0;i<n;i++){\n        int x;scanf(\"%d\",&x);\n        dp.chmax(x,dp.max(x-1)+x);\n        // for(int i=1;i<=n;i++){\n        //     printf(\"%lld \",dp.max(i)-dp.max(i-1));\n        // }\n        // puts(\"\");\n    }\n    printf(\"%lld\\n\",(ll)n*(n+1)/2 - dp.max(n));\n}"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\n#define int long long\n#define endl '\\n'\n#define FOR(i, a, n) for (int i = (a); i < (n); ++i)\n#define REP(i, n) FOR(i, 0, n)\nusing namespace std;\n\ntemplate <class Abel> struct BIT1D_MaxChmax {\n    const Abel e;\n    size_t n;\n    vector<Abel> d;\n\n    BIT1D_MaxChmax(size_t n, Abel e = numeric_limits<Abel>::min()) : n(n), e(e), d(n + 1, e) {}\n\n    // max{d[1], ..., d[i]} (i : 1-indexed)\n    Abel max(size_t i) {\n        Abel res = e;\n        while (i > 0) {\n            res = std::max(res, d[i]);\n            i -= i & -i;\n        }\n        return res;\n    }\n\n    // d[i] = max(d[i], x) (i : 1-indexed)\n    void chmax(size_t i, Abel x) {\n        while (i <= n) {\n            d[i] = std::max(d[i], x);\n            i += i & -i;\n        }\n    }\n};\n\nint n;\nint x[100010];\nint dp[100010];\n\nsigned main() {\n    ios::sync_with_stdio(false);\n    cin.tie(nullptr);\n\n    cin >> n;\n    REP (i, n) cin >> x[i];\n    BIT1D_MaxChmax<int> bit(n, 0);\n    REP (i, n) {\n        dp[i] = bit.max(x[i] - 1) + x[i];\n        bit.chmax(x[i], dp[i]);\n    }\n    cout << n * (n + 1) / 2 - bit.max(n) << endl;\n}\n"
  },
  {
    "language": "C++",
    "code": "#include <iostream>\n#include <algorithm>\n\nusing namespace std;\n\n#define ll long long\n#define rep(a,b) for(int a = 0; a < b; a++)\n\nint n;\nll dp[1<<18];\nint arr[100000];\nint size = 1;\n\nvoid update(int index, ll num) {\n  index += size-1;\n  dp[index] = num;\n  //cout << \"  \" << index << \",\" << dp[index] << endl;\n  while(index>0) {\n    int new_index = (index-1)>>1;\n    dp[new_index] = max(dp[(new_index<<1)+1],dp[(new_index<<1)+2]);\n    //cout << \"  \" << new_index << \",\" << dp[new_index] << endl;\n    index = new_index;\n  }\n  //dp[index] = max(dp[index],dp[index^1]);\n}\n\nll get_max(int a, int b, int k, int left, int right) {\n  //cout << \"gmax \" << a << \",\" << b << \",\" << k << \",\" << left << \",\" << right << endl;\n  if(right<a||b<=left||right<=left) return 0;\n  if(a<=left&&right<=b) {\n    //cout << \"OK \" << dp[k] << endl;\n    return dp[k];\n  }\n  ll ret = 0;\n  ret = max(ret,get_max(a,b,(k<<1)+1,left,(left+right)>>1));\n  ret = max(ret,get_max(a,b,(k<<1)+2,(left+right+1)>>1,right));\n  return ret;\n}\n\nint main() {\n  cin >> n;\n  for(int i = 1; i < n; i<<=1) size<<=1;\n  rep(i,n) cin >> arr[i];\n  rep(i,n) {\n    int num = arr[i];\n    ll _max = get_max(1,num,0,0,size);\n    //cout << num << \",\" << _max << endl;\n    update(num,_max+num);\n  }\n  ll ans = (ll)n;\n  ans = n*(n+1)/2;\n  //for(int i = 0; i < size<<1; i++) cout << dp[i] << endl;\n  cout << ans-dp[0] << endl;\n}\n\n"
  },
  {
    "language": "C++",
    "code": "#include <stdio.h>\n#include <algorithm>\nusing namespace std;\nint n, a[100000], b[100000]; long long sum, ret, dp[100001], rmq[262144];\nvoid update(int i, int x) { i += 8; rmq[i] = x; while (i > 1) i /= 2, rmq[i] = max(rmq[i * 2], rmq[i * 2 + 1]); }\nint query(int p, int q, int k, int l, int r) {\n\tif (r <= p || q <= l) return 0;\n\tif (p <= l && r <= q) return rmq[k];\n\tlong long vl = query(p, q, 2 * k, l, (l + r) / 2);\n\tlong long vr = query(p, q, 2 * k + 1, (l + r) / 2, r);\n\treturn max(vl, vr);\n}\nint main() {\n\tscanf(\"%d\", &n);\n\tfor (int i = 0; i < n; i++) scanf(\"%d\", &a[i]), sum += a[i], b[a[i] - 1] = i;\n\tfor (int i = 1; i <= n; i++) {\n\t\tupdate(a[i - 1] - 1, dp[i] = query(0, a[i - 1], 1, 0, 8) + a[i - 1]);\n\t\tret = max(ret, dp[i]);\n\t}\n\tprintf(\"%lld\\n\", sum - ret);\n\treturn 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include<bits/stdc++.h>\n#define N 100005\nusing namespace std;\ntypedef long long ll;\nconst int MAX_N = 1<<17;\n\nll n,dat[2*MAX_N-1];\n\nvoid init(int n_){\n  n=1;\n  while(n<n_)n*=2;\n  for(int i=0;i<2*n-1;i++)dat[i]=0;\n}\n\nvoid update(int k,ll a){\n  k+=n-1;\n  dat[k]=a;\n  while(k>0){\n    k=(k-1)/2;\n    dat[k]=max(dat[k*2+1],dat[k*2+2]);\n  }\n}\n\nll query(int a,int b,int k,int l,int r){\n  if(r<=a||b<=l)return 0;\n  if(a<=l&&r<=b)return dat[k];\n  else{\n    ll vl=query(a,b,k*2+1,l,(l+r)/2);\n    ll vr=query(a,b,k*2+2,(l+r)/2,r);\n    return max(vl,vr);\n  }\n}\n\nint main(){\n  int num,x;\n  cin>>n;\n  num=n;\n  init(n+1);\n  for(int i=0;i<num;i++){\n    cin>>x;\n    update(x,query(0,x,0,0,n)+x);\n  }\n  cout<<num*(num+1)/2-query(0,num+1,0,0,n)<<endl;\n  return 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include<bits/stdc++.h>\nusing namespace std;\n#define int long long\nconst int MAX_N = 1 << 17;\nint n,dat[2*MAX_N-1];\nvoid init(int n_){\n  n=1;\n  while(n<n_) n*=2;\n  for(int i=0;i<2*n-1;i++) dat[i]=0;\n}\nvoid update(int k,int a){\n  k+=n-1;\n  dat[k]=a;\n  while(k>0){\n    k=(k-1)/2;\n    dat[k]=max(dat[k*2+1],dat[k*2+2]);\n  }\n}\n// find(a,b,0,0,n);\nint query(int a,int b,int k,int l,int r){\n  if(r<=a||b<=l) return 0;\n  if(a<=l&&r<=b) return dat[k];\n  else{\n    int vl=query(a,b,k*2+1,l,(l+r)/2);\n    int vr=query(a,b,k*2+2,(l+r)/2,r);\n    return max(vl,vr);\n  }\n}\nsigned main(){\n  int m;\n  cin>>m;\n  int dp[m+1];\n  memset(dp,0,sizeof(dp));\n  init(m+1);\n  int ans=0;\n  for(int i=0;i<m;i++){\n    int x;\n    cin>>x;\n    dp[x]=query(0,x,0,0,n)+x;\n    //cout<<x<<\":\"<<dp[x]<<endl;\n    ans=max(ans,dp[x]);\n    update(x,dp[x]);\n  }\n  cout<<m*(m+1)/2-ans<<endl;\n  return 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include <iostream>\n#include <algorithm>\n#define rep(a,b) for(int a = 0; a < b; a++)\n\nusing namespace std;\n\nlong int arr[100001];\nlong int dp[100001]{};\nlong int n;\n\nint main() {\n  cin >> n;\n  rep(i,n+1) cin >> arr[i];\n  rep(i,n) {\n    long int temp = 0;\n    rep(j,arr[i]) {\n      temp = max(temp,dp[j]);\n    }\n    dp[arr[i]] = temp + arr[i];\n  }\n  long int ans = 0;\n  rep(i,n+1) ans = max(ans,dp[i]);\n  //rep(i,n+1) cout << dp[i] << endl;\n  long int all = (1+n)*n/2;\n  cout << all-ans << endl;\n  return 0;\n}\n\n"
  },
  {
    "language": "C++",
    "code": "#include <iostream>\n#include <algorithm>\n#include <utility>\n#include <vector>\n#include <list>\n#include <map>\n#include <set>\n#include <queue>\n#include <stack>\n#include <string>\n#include <sstream>\n#include <cstring>\n#include <cstdlib>\n\nusing namespace std;\n\n#define ALL(c) c.begin(),c.end()\n#define RALL(c) c.rbegin(),c.rend()\n#define SORT(x) sort((x).begin(),(x).end())\n#define REP(i,x,y) for(int i=(x);i<(y);++i)\n#define MP(a,b) make_pair((a),(b))\n#define F_ first\n#define S_ second\n#define debug(x) #x << \"=\" << (x)\n \n#ifdef DEBUG\n#define _GLIBCXX_DEBUG\n#define dump(x) std::cerr << debug(x) << \" (L:\" << __LINE__ << \")\" << std::endl\n#else\n#define dump(x)\n#endif\n\ntypedef long long int lli;\ntypedef pair<int,int> pii;\n\nconst int INF=1<<30;\nconst long long int INF_=1LL<<58;\nconst double EPS=1e-9;\nconst int dx[]={1,0,-1,0},dy[]={0,1,0,-1};\n\ntemplate <typename T> ostream &operator<<(ostream &os, const vector<T> &vector){\n\tos << \"[\";\n\tfor (const auto &v : vector) {\n\t\tos << v << \",\";\n\t}\n\tos << \"]\";\n\treturn os;\n}\n\nclass SegmentTree{\n\tprivate:\n\tpublic:\n\tint size;\n\tvector<lli> data;\n\tvoid Init(int n){\n\t\tsize=1;\n\t\twhile(size<n) size*=2;\n\t\tdata=vector<lli>(size*2-1,INF_);\n\t}\n\tvoid Update(int k,lli a){\n\t\tk+=size-1;\n\t\tdata[k]=a;\n\t\twhile(k>0){\n\t\t\tk=(k-1)/2;\n\t\t\tdata[k]=min(data[k*2+1],data[k*2+2]);\n\t\t}\n\t}\t\n\tlli Query(int a,int b,int k,int l,int r){\n\t\tif(r<=a||b<=l) return INF_;\n\t\tif(a<=l&&r<=b) return data[k];\n\t\telse {\n\t\t\tlli vl=Query(a,b,k*2+1,l,(l+r)/2);\n\t\t\tlli vr=Query(a,b,k*2+2,(l+r)/2,r);\n\t\t\treturn min(vl,vr);\n\t\t}\n\t}\n};\n\nint main(){\n\tstd::ios::sync_with_stdio(false);\n\tstd::cin.tie(0);\n\tint N;\n\tcin >> N;\n\tvector<int> x(N);\n\tREP(i,0,N) cin >> x[i];\n\tvector<lli> s(N);\n\ts[0]=x[0];\n\tREP(i,1,N) s[i]+=s[i-1]+x[i];\n\tvector<vector<lli>> dp(N,vector<lli>(2));\n\tdp[0][0]=x[0];\n\tSegmentTree st;\n\tst.Init(N);\n\tst.Update(x[0]-1,-s[0]);\n\tREP(i,1,N){\n\t\tdp[i][0]=min(dp[i-1][0],dp[i-1][1])+x[i];\n\t\tdp[i][1]=min(s[i-1],st.Query(0,x[i],0,0,st.size)+s[i-1]);\n\t\tst.Update(x[i]-1,dp[i][1]-s[i]);\n\t}\n\tcout << min(dp[N-1][1],dp[N-1][0]) << endl;\n\treturn 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include<iostream>\n#include<algorithm>\n#include<cstring>\nusing namespace std;\ntypedef long long ll;\n\nll seg[1<<20] = {};\nint V;\n\nvoid init(int n){\n  V = 1; while(n>V)V<<=1;\n}\n\nll set(int p, ll v){\n  int cur = V-1 + p;\n  seg[cur] = v;\n  while(cur){\n    cur = (cur-1)/2;\n    if(seg[cur] >= v)break;\n    seg[cur] = v;\n  }\n  return v;\n}\n\nll get(int a, int b, int k, int l, int r){\n  if(r<=a || b<=l)return 0;\n  if(a<=l && r<=b)return seg[k];\n  ll vl = get(a,b,2*k+1,l,(l+r)/2);\n  ll vr = get(a,b,2*k+2,(l+r)/2,r);\n  return max(vl,vr);\n}\n\nint n, a[100100];\n\nint main(){\n  cin >> n;\n  for(int i=0;i<n;i++)cin >> a[i];\n\n  init(n);\n  ll res = 0;\n  for(int i=0;i<n;i++){\n    res = max(res,set(a[i]-1,get(0,a[i]-1,0,0,V) + a[i]));\n  }\n\n  cout << (ll)n*(n+1)/2 - res << endl;\n}"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\nusing namespace std;\n\nusing ll = long long;\nusing vint = vector<int>;\nusing vll = vector<ll>;\nconstexpr ll LLINF = 1ll << 60;\n\ntemplate<typename T>\nstruct SegmentTree {\n\tT id;\n\tfunction<T(T, T)> op;\n\tvector<T> dat;\n\tint size;\n\n\tSegmentTree(int n, T id, function<T(T, T)> op) : id(id), op(op) {\n\t\tsize = 1;\n\t\twhile (size < n) size <<= 1;\n\t\tdat.assign(size * 2 + 10, id);\n\t}\n\n\tvoid update(int k, T x) {\n\t\tk += size; dat[k] = x;\n\t\twhile (k > 1) k >>= 1, dat[k] = op(dat[k<<1], dat[(k<<1)|1]);\n\t}\n\n\tvoid merge(int k, T x) { update(k, op(x, dat[k+size])); }\n\n\tT query(int a, int b) {\n\t\tT tl = id, tr = id;\n\t\tfor (int l = a + size, r = b + size; l < r; l >>= 1, r >>= 1) {\n\t\t\tif (l & 1) tl = op(tl, dat[l++]);\n\t\t\tif (r & 1) tr = op(tr, dat[--r]);\n\t\t}\n\t\treturn (op(tl, tr));\n\t}\n};\n\nint main() {\n\tint N; cin >> N;\n\tSegmentTree<ll> seg(N, -LLINF, [](ll a, ll b) { return (max(a, b)); } );\n\n\tvll A(N);\n\tfor (auto &v : A) cin >> v;\n\n\tfor (int i = 0; i < N; i++) {\n\t\tseg.update(i, 0ll);\n\t}\n\n\tfor (int i = 0; i < N; i++) {\n\t\tll dat = seg.query(0, A[i]);\n\t\t//cout << dat << \" \";\n\t\tseg.update(A[i]-1, dat + A[i]);\n\t\t//cout << seg.query(A[i]-1, A[i]) << endl;\n\t}\n\n\tcout << (ll)N*(N+1)/2 - seg.query(0, N) << endl;\n}\n\n"
  },
  {
    "language": "C++",
    "code": "#include <iostream>\n#include <algorithm>\n#include <set>\n#include <cstdio>\nusing namespace std;\n\ntypedef long long ll;\ntypedef pair<ll,ll> P;\n\nconst ll MAX = 100000;\n\nint main(){\n  int n;\n  while(cin >> n){\n    ll a[MAX],ans=0;\n    set<P> s;\n    for(int i=0;i<n;i++) scanf(\"%d\",&a[i]);\n    for(int i=0;i<n;i++){\n      ll cnt = 0;\n      if(i > 0){\n\tset<P>::iterator it = s.end();\n\tit--;\n\twhile(1){\n\t  it = s.lower_bound(P(it->first,0));\n\t  if(it->second < a[i]){\n\t    cnt = it->first;\n\t    break;\n\t  } else if(it == s.begin()) break;\n\t  else it--;\n\t}\n      }\n      ans = max(ans,cnt+a[i]);\n      s.insert(P(cnt+a[i],a[i]));\n    }\n    printf(\"%d\\n\",(ll)n*(n+1)/2 - ans);\n  }\n}"
  },
  {
    "language": "C++",
    "code": "#include<iostream>\n#include<vector>\n#include<algorithm>\n#include<climits>\n\nconst int MAX_N=1<<17;\n\ntypedef long long ll;\n\nusing namespace std;\n\nll n,dat[2*MAX_N-1];\n\nvoid init(int n_){\n\tn=1;\n\twhile(n<n_)n*=2;\n}\n\nvoid update(int k,ll a){\n\tk+=n-1;\n\tdat[k]=a;\n\t\n\twhile(k>0){\n\t\tk=(k-1)/2;\n\t\tdat[k]=max(dat[2*k+1],dat[2*k+2]);\n\t}\n}\n\nll query(int a,int b,int k,int l,int r){\n\tif(r<=a || b<=l)return 0;\n\tif(a<=l && r<=b)return dat[k];\n\telse {\n\t\tll vl=query(a,b,k*2+1,l,(l+r)/2);\n\t\tll vr=query(a,b,k*2+2,(l+r)/2,r);\n\t\treturn max(vl,vr);\n\t}\n}\n\nint main(void){\n\t\n\tll in,m,ans=0;\n\t\n\tcin >> m;\n\t\n\tinit(m);\n\t\n\tfor(int i=0;i<m;i++){\n\t\tcin >> in;\n\t\tupdate(in,in+query(1,in,0,0,n));\n\t}\n\tcout << m*(m+1)/2-query(1,m+1,0,0,n) << endl;\n\t\n\treturn 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include \"bits/stdc++.h\"\nusing namespace std;\ntypedef long long ll;\ntypedef pair<int,int> pii;\n#define rep(i,n) for(ll i=0;i<(ll)(n);i++)\n#define all(a) (a).begin(),(a).end()\n#define pb emplace_back\n#define INF (1e9+1)\n\n//0-index 抽象化半開区間遅延セグツリー\ntemplate<typename T, typename E>\nclass segment_tree{\n    typedef function<T(T,T)> F; //要素に適用する演算\n    typedef function<T(T,E)> G; //作用素の適用\n    typedef function<E(E,E)> H; //作用素の合成\n    typedef function<E(E,int)> P;\nprivate:\n    int num_of_elm_;\n    vector<T> dat_, lazy_;\n    F f_;\n    G g_;\n    H h_;\n    P p_;\n    T ident_;\n    E op_ident_;\npublic:\n    segment_tree(int n, F f, G g, H h, P p, T ident, E op_ident):f_(f), g_(g), h_(h), p_(p), ident_(ident), op_ident_(op_ident){\n        num_of_elm_ = 1;\n        while(num_of_elm_<n)num_of_elm_*=2;\n        dat_ .resize(2*num_of_elm_,ident);\n        lazy_.resize(2*num_of_elm_,op_ident);\n    }\n    \n    void build(vector<T> vec){\n        rep(i,vec.size()) dat_[num_of_elm_+i] = vec[i];\n        for(int i=num_of_elm_-1;i>=1;i--)dat_[i] = f_(dat_[i*2],dat_[i*2+1]);\n    }\n    \n    void eval(int k, int len){\n        if(lazy_[k] == op_ident_)return ;\n        \n        if(k<num_of_elm_){\n            lazy_[k*2]=h_(lazy_[k*2], lazy_[k]);\n            lazy_[k*2+1]=h_(lazy_[k*2+1], lazy_[k]);\n        }\n        dat_[k] = g_(dat_[k],p_(lazy_[k], len));\n        lazy_[k] = op_ident_;\n    }\n    \n    T update(int L, int R, int val, int l=0, int r=0, int k=1){\n        if(k==1)r = num_of_elm_;\n        \n        eval(k,r-l);\n        if(r<=L || R<=l)return dat_[k];\n        else if(L<=l && r<=R){\n            lazy_[k] = h_(lazy_[k], val);\n            return g_(dat_[k], p_(lazy_[k], r-l));\n        }\n        else{\n            return dat_[k] = f_(update(L,R,val,l,(l+r)/2,k*2), update(L,R,val,(l+r)/2,r,k*2+1));\n        }\n        \n    }\n    \n    T query(int L, int R,int l=0,int r=0, int k=1){\n        if(k==1)r = num_of_elm_;\n        \n        eval(k,r-l);\n        if(r<=L || R<=l)return ident_;\n        else if(L<=l && r<=R){\n            return dat_[k];\n        }\n        else{\n            return f_(query(L,R,l,(l+r)/2,k*2), query(L,R,(l+r)/2,r,k*2+1));\n        }\n    }\n};\n\nint main(){\n    int n;\n    cin>>n;\n    vector<int> v(n);\n    rep(i,n)cin>>v[i];\n    \n    auto f = [](int a, int b){ return max(a,b); };\n    auto g = f;\n    auto h = [](int a, int b){ return b; };\n    auto p = [](int a, int len){ return a; };\n\n    segment_tree<int,int> dp(n+1,f,g,h,p,0,0);\n    \n    for(int i=1;i<=n;i++){\n        dp.update(v[i-1], v[i-1]+1, dp.query( 0,v[i-1] )+v[i-1] );\n    }\n    cout<<n*(n+1)/2-dp.query(0,n+1)<<endl;\n}\n\n"
  },
  {
    "language": "C++",
    "code": "#include<iostream>\n#include<vector>\n#include<algorithm>\n\nusing namespace std;\nusing T = long long;\n\n//RMQに答えるSegmentTree\n//必要に応じて書き換える．\nstruct SegmentTree {\nprivate:\n    int n;\n    vector<T> node;\npublic:\n    SegmentTree(vector<T> vect){\n        int sz = vect.size();\n        n = 1; for(;n<sz;) n*= 2;\n        node.resize(2*n-1,0);\n\n        for(int i=0; i<sz ; i++) node[i+n-1] = vect[i];\n        for(int i=n-2; i>=0 ; i--) node[i] = max(node[2*i+1], node[2*i+2]);//ここをうまく書き換える\n    }\n\n    void update(int x, T val){\n        x += (n-1);\n\n        node[x] = val;\n        while(x > 0){\n            x = (x-1) / 2;\n            node[x] = max(node[2*x+1], node[2*x+2]);\n        }\n    }\n    T getmax(int a, int b, int k=0, int l=0, int r= -1) {\n        if(r<0) r=n;\n        if(r <= a || b <= l) return 0;\n        if(a<=l && r<=b ) return node[k];\n\n        T vl = getmax(a, b, 2*k+1, l, (l+r)/2);\n        T vr = getmax(a, b, 2*k+2, (l+r)/2, r);\n        return max(vl,vr);\n    }\n};\n\n\nint main() {\n    int n;\n    long long sum = 0;\n    cin >> n;\n    vector<T> vect(n);\n    for(int i= 0; i< n; i++){\n        cin >> vect[i];\n        sum += vect[i];\n    }\n    SegmentTree dp((vector<T>(n)));\n    T now;\n    for(int i=0; i<n ;i++){\n        now = vect[i];\n        dp.update(now-1, dp.getmax(0,now)+now);\n    }\n    long long ans=dp.getmax(0,n);\n    cout << sum - ans << endl;\n    return 0;\n}\n\n"
  },
  {
    "language": "C++",
    "code": "#include <cstdio>\n#include <cstdlib>\n#include <cstring>\n#include <cmath>\n#include <climits>\n#include <cfloat>\n#include <ctime>\n#include <cassert>\n#include <map>\n#include <utility>\n#include <set>\n#include <iostream>\n#include <memory>\n#include <string>\n#include <vector>\n#include <algorithm>\n#include <functional>\n#include <sstream>\n#include <complex>\n#include <stack>\n#include <queue>\n#include <numeric>\n#include <list>\n#include <iomanip>\n   \nusing namespace std;\n   \n \n#ifdef __GNUC__\ntemplate <class T> int popcount(T n);\ntemplate <> int popcount(unsigned int n) { return __builtin_popcount(n); }\ntemplate <> int popcount(int n) { return __builtin_popcount(n); }\ntemplate <> int popcount(unsigned long long n) { return __builtin_popcountll(n); }\ntemplate <> int popcount(long long n) { return __builtin_popcountll(n); }\n#else\n#define __typeof__ decltype\ntemplate <class T> int popcount(T n) { return n ? 1 + popcount(n & (n - 1)) : 0; }\n#endif\n \n#define rep(i, n) for (int i = 0; i < (int)n; ++i)\n#define foreach(it, c) for (__typeof__((c).begin()) it=(c).begin(); it != (c).end(); ++it)\n#define rforeach(it, c) for (__typeof__((c).rbegin()) it=(c).rbegin(); it != (c).rend(); ++it)\n#define all(c) (c).begin(), (c).end()\n#define rall(c) (c).rbegin(), (c).rend()\n#define CL(arr, val) memset(arr, val, sizeof(arr))\n#define COPY(dest, src) memcpy(dest, src, sizeof(dest))\n   \ntemplate <class T> void max_swap(T& a, const T& b) { a = max(a, b); }\ntemplate <class T> void min_swap(T& a, const T& b) { a = min(a, b); }\n\ntemplate <class T> void sort(vector<T>& c) { sort(c.begin(), c.end()); }\ntemplate <class T> void unique(vector<T>& c) { sort(c.begin(), c.end()); c.erase(unique(c.begin(), c.end()), c.end()); }\n \ntypedef long long ll;\ntypedef pair<int, int> pint;\n   \ntemplate <class T, class U> ostream& operator<<(ostream& os, pair<T, U>& p) { os << \"( \" << p.first << \", \" << p.second << \" )\"; return os;  }\n  \ntemplate <class T> string to_s(const T& a) { ostringstream os; os << a; return os.str(); }\ntemplate <class T> T to_T(const string& s) { istringstream is(s); T res; is >> res; return res; }\n  \nbool valid(int x, int y, int w, int h) { return 0 <= x && x < w && 0 <= y && y < h; }\n   \ntemplate <class T> void print(T a, int n, const string& deli = \" \", int br = 1) { for (int i = 0; i < n; ++i) { cout << a[i]; if (i + 1 != n) cout << deli; } while (br--) cout << endl; }\ntemplate <class T> void print(const T& c, const string& deli = \" \", int br = 1) { foreach (it, c) { cout << *it; if (++it != c.end()) cout << deli;--it; } while (br--) cout << endl; }\ntemplate <class T> void print2d(T a, int w, int h, int width = -1, int br = 1) { for (int i = 0; i < h; ++i) { for (int j = 0; j < w; ++j) {    if (width != -1) cout.width(width); cout << a[i][j] << ' '; } cout << endl; } while (br--) cout << endl; }\n   \ntemplate <class T> void input(T& a, int n) { for (int i = 0; i < n; ++i) cin >> a[i]; }\ntemplate <class T, class U> void input(T& a, U& b, int n) { for (int i = 0; i < n; ++i) cin >> a[i] >> b[i]; }\n  \nconst int dx[] = { 0, 1, 0, -1 };\nconst int dy[] = { 1, 0, -1, 0 };\n  \nconst double PI = acos(-1.0);\nconst int mod = 1000000007;\n\n\n\n\nint node[2 * 114514];\nint size;\nvoid init(int n)\n{\n    size = 1;\n    while (size < n)\n        size *= 2;\n}\nvoid update(int k, int a)\n{\n    k += size - 1;\n    node[k] = a;\n    while (k > 0)\n    {\n        k = (k - 1) / 2;\n        node[k] = max(node[2 * k + 1], node[2 * k + 2]);\n    }\n}\nint query(int a, int b, int k = 0, int l = 0, int r = ::size)\n{\n    if (r <= a || l >= b)\n        return 0;\n    else if (a <= l && r <= b)\n        return node[k];\n\n    int left = query(a, b, 2 * k + 1, l, (l + r) / 2);\n    int right = query(a, b, 2 * k + 2, (l + r) / 2, r);\n    return max(left, right);\n}\n\nint main()\n{\n    int n;\n    static int a[114514];\n    scanf(\"%d\", &n);\n    for (int i = 0; i < n; ++i)\n        scanf(\"%d\", a + i);\n\n    init(n + 1);\n    for (int i = 0; i < n; ++i)\n    {\n        int max_seq = query(0, a[i]);\n        update(a[i], max_seq + a[i]);\n    }\n    int max_seq = query(1, n + 1);\n    int res = n * (n + 1) / 2 - max_seq;\n    printf(\"%d\\n\", res);\n}"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\n\nusing namespace std;\n\nusing ll = long long;\nusing vi = vector<int>;\nusing vll = vector<ll>;\nusing vvi = vector<vector<int>>;\nusing vvl = vector<vector<ll>>;\n\ntemplate<typename T>\nclass tRMQ {\n  vector<T> data;\n  T unit;\n\npublic:\n  static const long long INF = 100000000000;\n  int n;\n  function<T(const T &, const T &)> f;\n\n  tRMQ(int _, T u, function<T(T, T)> bi) {\n    unit = u;\n    f = bi;\n    n = 1;\n    while (n < _) {\n      n <<= 1;\n    }\n    data.resize(n * 4);\n    for (int i = 0; i < n * 4; i++)\n      data[i] = unit;\n  }\n\n  void update(int index, T val) {\n    int i = index + n - 1;\n    data[i] = val;\n    while (i > 0) {\n      i = (i - 1) / 2;\n      data[i] = f(data[i * 2 + 1], data[i * 2 + 2]);\n    }\n  }\n\n  // [a, b)\n  T query(int a, int b, int k, int l, int r) {\n    if (a < 0 || r <= a || b <= l)\n      return unit;\n    if (a <= l && r <= b)\n      return data[k];\n    else\n      return f(query(a, b, k * 2 + 1, l, (l + r) / 2),\n               query(a, b, k * 2 + 2, (r + l) / 2, r));\n  }\n\n  T query(int a, int b) { return query(a, b, 0, 0, n); }\n};\n\ntRMQ<ll> minrmq(int n) {\n  return tRMQ<ll>(n, 10000000000000000LL, [](ll r, ll l) { return min(l, r); });\n}\n\ntRMQ<ll> maxrmq(int n) {\n  return tRMQ<ll>(n, -10000000000000000LL,\n                  [](ll r, ll l) { return max(l, r); });\n}\n\ntRMQ<ll> sumrmq(int n) {\n  return tRMQ<ll>(n, 0, [](ll l, ll r) { return l + r; });\n}\n\nint main() {\n  cin.tie(nullptr);\n  ios::sync_with_stdio(false);\n  ll n;\n  cin >> n;\n  vector<ll> v(n);\n  ll sum = 0;\n  for (int i = 0; i < n; i++) {\n    cin >> v[i];\n    sum += v[i];\n  }\n  tRMQ<ll> r = maxrmq(n + 1);\n  r.update(0, 0);\n\n  for (int i = 0; i < n; i++) {\n    r.update(v[i], r.query(0, v[i]) + v[i]);\n  }\n  cout << sum - r.query(0, n + 1) << endl;\n  return 0;\n}\n\n"
  },
  {
    "language": "C",
    "code": "long long BIT[100010], bit_size; // long long は 64bit 整数．\nvoid bit_init(int n){\n\tmemset(BIT,0,n*(sizeof(long long)));\n\tbit_size = n;\n}\nlong long bit_max(int n){ // [1,n] の最大値\n\tlong long ans = 0;\n\twhile(n > 0){\n\t\tans = max(ans, BIT[n]);\n\t\tn &= n-1;\n\t}\n\treturn ans;\n}\nvoid bit_setmax(int n, long long v){ // # [1,n] の最大値を v に更新する\n\twhile (n < bit_size){\n\t\tBIT[n] = max(BIT[n], v);\n\t\tn += n & (-n);\n\t}\n}\nint main(){\n\tlong long N,x,i=0;\n\tscanf(\"%lld\",&N);\n\tbit_init(N+1);\n\tfor(; i<N; ++i){\n\t\tscanf(\"%lld\",&x);\n\t\tlong long cost = bit_max(x);\n\t\tbit_setmax(x,cost+x);\n\t}\n\tprintf(\"%lld\\n\",(1+N)*N/2 - bit_max(N));\n}"
  },
  {
    "language": "C",
    "code": "// AOJ 2431: House Moving\n// 2017.12.30 bal4u@uu\n\n#include <stdio.h>\n\nint seg[262145], sz;\t\t// 2^18 = 262144\nchar buf[600000], *p;\n\nint in()\n{\n\tint n = 0;\n\twhile (*p >= '0') n = 10*n + (*p++ & 0xf);\n\tp++;\n\treturn n;\n}\n\n// update kth value to v\nvoid update(int k, int v)\n{\n\tint t;\n\tk += sz-1;\n\tseg[k] = v;\n\twhile (k > 0) {\n\t\tif (!(k & 1)) k--;\n\t\tt = k, k >>= 1;\n\t\tv = seg[t++]; if (v < seg[t]) v = seg[t];\n\t\tseg[k] = v;\n\t}\n}\n\n// get max value in [a, b)\nint query(int a, int b, int k, int l, int r) \n{\n\tint m, lmax, rmax;\n\n\tif (r <= a || b <= l) return 0;\n    if (a <= l && r <= b) return seg[k];\n\tk <<= 1, m = (l + r) >> 1;\n    lmax = query(a, b, ++k, l, m);\n    rmax = query(a, b, ++k, m, r);\n    if (lmax < rmax) lmax = rmax; \n    return lmax;\n}\n\nint main()\n{\n\tint n, x, i;\n\tlong long ans;\n\n\tfgets(p=buf, 10, stdin), n = in();\n\n\tsz = 1; while (sz < n) sz <<= 1;\n\n\tfgets(p=buf, sizeof(buf), stdin);\n\tfor (i = 0; i < n; i++) {\n\t\tx = in();\n\t\tupdate(x, x + query(1, x, 0, 0, sz));\n\t}\n\n\tans = (((long long)n*(n+1)) >> 1) - query(1, n+1, 0, 0, sz);\n\tprintf(\"%lld\\n\", ans);\n\treturn 0;\n}"
  },
  {
    "language": "C",
    "code": "#include<stdio.h>\n\nint main(void)\n{\n  \n  int number;\n  int array[10*10*10*10*10];\n  int i = 0;\n  int j;\n  int hp = 0;\n  int totalhp = 0;\n  int temp;\n\n  scanf(\"%d\",&number);\n\n  for(i=0;i<number;i++){\n    scanf(\"%d\",&array[i]);\n  }\n\n  i = 0;\n\n  while(i < number-1){\n    if(array[i] > array[i+1]){\n      for(j=i;j<number;j++){\n\tif(array[j+1]-array[j] == 1 || j == number-1){\n\t  if(hp > array[j])\n\t    totalhp += array[j];\n\t  else \n\t    totalhp += hp;\n\t  i = 0;\n\t  hp = 0;\n\t  break;\n\t}\n\telse{\n\t  hp += array[j+1];\n\t  temp = array[j];\n\t  array[j] = array[j+1];\n\t  array[j+1] = temp;\n\t}\n      }\t\n    }\n    else \n      i++;\n  }\n\n  printf(\"%d\\n\",totalhp);\n  \n  return 0; \n  \n}\n    "
  },
  {
    "language": "C",
    "code": "#define max(a,b)((a)>(b)?(a):(b))\nlong long BIT[100010], bit_size; // long long は 64bit 整数．\nvoid bit_init(int n){\n\tmemset(BIT,0,n*(sizeof(long long)));\n\tbit_size = n;\n}\nlong long bit_max(int n){ // [1,n] の最大値\n\tlong long ans = 0;\n\twhile(n > 0){\n\t\tans = max(ans, BIT[n]);\n\t\tn &= n-1;\n\t}\n\treturn ans;\n}\nvoid bit_setmax(int n, long long v){ // # [1,n] の最大値を v に更新する\n\twhile (n < bit_size){\n\t\tBIT[n] = max(BIT[n], v);\n\t\tn += n & (-n);\n\t}\n}\nint main(){\n\tlong long N,x,i=0;\n\tscanf(\"%lld\",&N);\n\tbit_init(N+1);\n\tfor(; i<N; ++i){\n\t\tscanf(\"%lld\",&x);\n\t\tlong long cost = bit_max(x);\n\t\tbit_setmax(x,cost+x);\n\t}\n\tprintf(\"%lld\\n\",(1+N)*N/2 - bit_max(N));\nexit(0);}"
  },
  {
    "language": "C",
    "code": "// AOJ 2431: House Moving\n// 2017.11.16 bal4u@uu\n\n#include <stdio.h>\n#include <stdlib.h>\n\nchar buf[600000], *p;\nint getint()\n{\n\tint n = 0;\n\twhile (*p >= '0') n = (n<<3) + (n<<1) + (*p++ & 0xf);\n\treturn n;\n}\n\n#define SIZE 10005\nint N;\nint max;\nint num[SIZE+3];\nint LIS[SIZE+3];\nint tmp[SIZE+3];\n\nvoid calcLIS(void)\n{\n    int k;\n    int lo, hi, mid;\n\n    LIS[N-1] = 1;\n    tmp[0] = num[N-1];\n    max = 1;\n    for (k = N-2; k >= 0; k--) {\n        if (tmp[max-1] > num[k]) { tmp[max++] = num[k]; LIS[k] = max; continue; }\n        if (tmp[max-1] == num[k]) { LIS[k] = max; continue; }\n        lo = 0, hi = max;\n        while (lo < hi) {\n            mid = (lo + hi) >> 1;\n            if (tmp[mid] > num[k]) lo = mid+1;\n            else hi = mid;\n        }\n        tmp[lo] = num[k], LIS[k] = lo+1;\n    }\n}\n\nint main()\n{\n\tint i, j;\n\tlong long sum, a;\n\n\tfgets(p=buf, 10, stdin), N = getint();\n\tfgets(p=buf, sizeof(buf), stdin);\n\tfor (sum = 0, i = 0; i < N; i++) sum += (num[i] = getint()), p++;\n\tcalcLIS();\n\tfor (a = 0, j = max, i = 0; i < N; i++) if (LIS[i] == j) a += num[i], j--;\n\tprintf(\"%lld\\n\", sum - a);\n\treturn 0;\n}"
  },
  {
    "language": "C",
    "code": "// AOJ 2431: House Moving\n// 2017.12.30 bal4u@uu\n\n#include <stdio.h>\n\nlong long seg[262145]; int sz;\t\t// 2^18 = 262144\nchar buf[600000], *p;\n\nint in()\n{\n\tint n = 0;\n\twhile (*p >= '0') n = 10*n + (*p++ & 0xf);\n\tp++;\n\treturn n;\n}\n\n// update kth value to v\nvoid update(int k, long long v)\n{\n\tint t;\n\tk += sz-1;\n\tseg[k] = v;\n\twhile (k > 0) {\n\t\tif (!(k & 1)) k--;\n\t\tt = k, k >>= 1;\n\t\tv = seg[t++]; if (v < seg[t]) v = seg[t];\n\t\tseg[k] = v;\n\t}\n}\n\n// get max value in [a, b)\nlong long query(int a, int b, long long k, int l, int r) \n{\n\tint m;\n\tlong long lmax, rmax;\n\n\tif (r <= a || b <= l) return 0;\n    if (a <= l && r <= b) return seg[k];\n\tk <<= 1, m = (l + r) >> 1;\n    lmax = query(a, b, ++k, l, m);\n    rmax = query(a, b, ++k, m, r);\n    if (lmax < rmax) lmax = rmax; \n    return lmax;\n}\n\nint main()\n{\n\tint n, x, i;\n\tlong long ans;\n\n\tfgets(p=buf, 10, stdin), n = in();\n\n\tsz = 1; while (sz < n) sz <<= 1;\n\n\tfgets(p=buf, sizeof(buf), stdin);\n\tfor (i = 0; i < n; i++) {\n\t\tx = in();\n\t\tupdate(x, (long long)x + query(1, x, 0, 0, sz));\n\t}\n\n\tans = (((long long)n*(n+1)) >> 1) - query(1, n+1, 0, 0, sz);\n\tprintf(\"%lld\\n\", ans);\n\treturn 0;\n}"
  },
  {
    "language": "C",
    "code": "#include<stdio.h>\n\nint main(void)\n{\n  \n  int number;\n  int array[10*10*10*10*10];\n  int i = 0;\n  int j;\n  int hp = 0;\n  int totalhp = 0;\n  int temp;\n\n  scanf(\"%d\",&number);\n\n  for(i=0;i<number;i++){\n    scanf(\"%d\",&array[i]);\n  }\n\n  i = 0;\n\n  while(i < number-1){\n    if(array[i] > array[i+1]){\n      for(j=i;j<number;j++){\n\tif(array[j+1]-array[j] == 1 || j == number-1){\n\t  if(hp > array[j])\n\t    totalhp += array[j];\n\t  else \n\t    totalhp += hp;\n\t  i = 0;\n\t  hp = 0;\n\t  break;\n\t}\n\telse{\n\t  hp += array[j+1];\n\t  temp = array[j];\n\t  array[j] = array[j+1];\n\t  array[j+1] = temp;\n\t}\n      }\t\n    }\n    else \n      i++;\n  }\n\n  printf(\"%d\\n\",totalhp);\n  \n  return 0; \n  \n}\n    "
  },
  {
    "language": "C",
    "code": "#include<stdio.h>\n\nint main(void)\n{\n  \n  int number;\n  int array[10*10*10*10*10];\n  int i;\n  int j;\n  int hp = 0;\n  int totalhp = 0;\n  int temp;\n  int k = 0;\n\n  scanf(\"%d\",&number);\n\n  for(i=0;i<number;i++){\n    scanf(\"%d\",&array[i]);\n  }\n\n  i = 0;\n\n  while(i < number-1){\n    if(array[i] > array[i+1]){\n      for(j=i;j<number;j++){\n\tif(array[j+1]-array[j] == 1 || j == number-1){\n\t  if(hp > array[j])\n\t    totalhp += array[j];\n\t  else \n\t    totalhp += hp;\n\t  i = k;\n\t  hp = 0;\n\t  break;\n\t}\n\telse{\n\t  hp += array[j+1];\n\t  temp = array[j];\n\t  array[j] = array[j+1];\n\t  array[j+1] = temp;\n\t}\n      }\t\n    }\n\n    else if(array[i] == i+1){\n      k++;\n      i++;\n    }\n\n    else\n      i++;\n  }\n\n  printf(\"%d\\n\",totalhp);\n  \n  return 0; \n  \n}"
  },
  {
    "language": "C",
    "code": "#define max(a,b)((a)>(b)?(a):(b))\nlong long BIT[100010], bit_size; // long long は 64bit 整数．\nvoid bit_init(int n){\n\tmemset(BIT,0,n*(sizeof(long long)));\n\tbit_size = n;\n}\nlong long bit_max(int n){ // [1,n] の最大値\n\tlong long ans = 0;\n\twhile(n > 0){\n\t\tans = max(ans, BIT[n]);\n\t\tn &= n-1;\n\t}\n\treturn ans;\n}\nvoid bit_setmax(int n, long long v){ // # [1,n] の最大値を v に更新する\n\twhile (n < bit_size){\n\t\tBIT[n] = max(BIT[n], v);\n\t\tn += n & (-n);\n\t}\n}\nint main(){\n\tlong long N,x,i=0;\n\tscanf(\"%lld\",&N);\n\tbit_init(N+1);\n\tfor(; i<N; ++i){\n\t\tscanf(\"%lld\",&x);\n\t\tlong long cost = bit_max(x);\n\t\tbit_setmax(x,cost+x);\n\t}\n\tprintf(\"%lld\\n\",(1+N)*N/2 - bit_max(N));\n}"
  },
  {
    "language": "C",
    "code": "#include<stdio.h>\n\nint main(void)\n{\n  \n  int number;\n  int array[10*10*10*10*10];\n  int i;\n  int j;\n  int hp = 0;\n  int totalhp = 0;\n  int temp;\n  int k = 0;\n\n  scanf(\"%d\",&number);\n\n  for(i=0;i<number;i++){\n    scanf(\"%d\",&array[i]);\n  }\n\n  i = 0;\n\n  while(i < number-1){\n    if(array[i] > array[i+1]){\n      for(j=i;j<number;j++){\n\tif(array[j+1]-array[j] == 1 || j == number-1){\n\t  if(hp > array[j])\n\t    totalhp += array[j];\n\t  else \n\t    totalhp += hp;\n\n\t  if(j == number-1)\n\t    number-=2;\n\t  i = k;\n\t  hp = 0;\n\t  break;\n\t}\n\telse{\n\t  hp += array[j+1];\n\t  temp = array[j];\n\t  array[j] = array[j+1];\n\t  array[j+1] = temp;\n\t}\n      }\t\n    }\n\n    else if(array[i] == i+1){\n      k++;\n      i++;\n    }\n\n    else\n      i++;\n  }\n\n  printf(\"%d\\n\",totalhp);\n  \n  return 0; \n  \n}"
  },
  {
    "language": "C",
    "code": "// AOJ 2431: House Moving\n// 2017.12.30 bal4u@uu\n\n#include <stdio.h>\n\nint n;\nlong long bit[100002];\nchar buf[600000], *p;\n\nint in()\n{\n\tint n = 0;\n\twhile (*p >= '0') n = 10*n + (*p++ & 0xf);\n\tp++;\n\treturn n;\n}\n\nvoid add(int i, long long v)\n{\n\ti++;\n    while (i <= n) {\n\t\tif (v > bit[i]) bit[i] = v;\n\t\ti += i & -i;\n\t}\n}\n \nlong long sum(int i)\n{\n    long long s = 0;\n \n    while (i > 0) {\n\t\tif (bit[i] > s) s = bit[i];\n\t\ti -= i & -i;\n\t}\n    return s;\n}\n\nint main()\n{\n\tint x, i;\n\n\tfgets(p=buf, 10, stdin), n = in();\n\tfgets(p=buf, sizeof(buf), stdin);\n\ti = n; while (i--) {\n\t\tx = in();\n\t\tadd(x-1, sum(x-1)+x);\n\t}\n\n\tprintf(\"%lld\\n\", (((long long)n*(n+1)) >> 1) - sum(n));\n\treturn 0;\n}"
  },
  {
    "language": "C",
    "code": "// AOJ 2431: House Moving\n// 2017.11.16 bal4u@uu\n\n#include <stdio.h>\n#include <stdlib.h>\n\nchar buf[600000], *p;\nint getint()\n{\n\tint n = 0;\n\twhile (*p >= '0') n = (n<<3) + (n<<1) + (*p++ & 0xf);\n\treturn n;\n}\n\n#define SIZE 100005\nint N;\nint max;\nint num[SIZE+3];\nint LIS[SIZE+3];\nint tmp[SIZE+3];\n\nvoid calcLIS(void)\n{\n    int k;\n    int lo, hi, mid;\n\n    LIS[N-1] = 1;\n    tmp[0] = num[N-1];\n    max = 1;\n    for (k = N-2; k >= 0; k--) {\n        if (tmp[max-1] > num[k]) { tmp[max++] = num[k]; LIS[k] = max; continue; }\n        if (tmp[max-1] == num[k]) { LIS[k] = max; continue; }\n        lo = 0, hi = max;\n        while (lo < hi) {\n            mid = (lo + hi) >> 1;\n            if (tmp[mid] > num[k]) lo = mid+1;\n            else hi = mid;\n        }\n        tmp[lo] = num[k], LIS[k] = lo+1;\n    }\n}\n\nint main()\n{\n\tint i, j;\n\tlong long sum, a;\n\n\tfgets(p=buf, 10, stdin), N = getint();\n\tfgets(p=buf, sizeof(buf), stdin);\n\tfor (sum = 0, i = 0; i < N; i++) sum += (num[i] = getint()), p++;\n\tcalcLIS();\n\tfor (a = 0, j = max, i = 0; i < N; i++) if (LIS[i] == j) a += num[i], j--;\n\tprintf(\"%lld\\n\", sum - a);\n\treturn 0;\n}"
  },
  {
    "language": "C",
    "code": "#include<stdio.h>\n\nint main(void)\n{\n  \n  int number;\n  int array[10*10*10*10*10];\n  int i;\n  int j;\n  int hp = 0;\n  int totalhp = 0;\n  int temp;\n  int k = 0;\n\n  scanf(\"%d\",&number);\n\n  for(i=0;i<number;i++){\n    scanf(\"%d\",&array[i]);\n  }\n\n  i = 0;\n\n  while(i < number-1){\n    if(array[i] > array[i+1]){\n      for(j=i;j<number;j++){\n\tif(array[j+1]-array[j] == 1 || j == number-1){\n\t  if(hp > array[j])\n\t    totalhp += array[j];\n\t  else \n\t    totalhp += hp;\n\n\t  if(j == number-1)\n\t    number-=2;\n\t  i = k;\n\t  hp = 0;\n\t  break;\n\t}\n\telse{\n\t  hp += array[j+1];\n\t  temp = array[j];\n\t  array[j] = array[j+1];\n\t  array[j+1] = temp;\n\t}\n      }\t\n    }\n\n    else if(array[i] == i+1){\n      k++;\n      i++;\n    }\n\n    else\n      i++;\n  }\n\n  printf(\"%d\\n\",totalhp);\n  \n  return 0; \n  \n}"
  },
  {
    "language": "Java",
    "code": "import java.util.Arrays;\nimport java.util.Scanner;\n\npublic class Main {\n\tpublic static void main(String[] args) {\n\t\ttry {\n\t\t\t//solve(new Scanner(new File(\"src\\\\h\\\\10-maximum00.in\")));\n\t\t\tsolve(new Scanner(System.in));\n\t\t} catch (Exception e) {\n\t\t\te.printStackTrace();\n\t\t}\n\n\t}\n\tpublic static void solve(Scanner sc) {\n\t\tint n = sc.nextInt();\n\t\tint[] x = new int[n];\n\t\tfor(int i=0;i<n;i++) {\n\t\t\tx[i] = sc.nextInt();\n\t\t}\n\t\tRMQ dp = new RMQ(n+1);\n\t\tfor(int i=0;i<n;i++) {\n\t\t\tlong max = x[i];\n\t\t\tmax = Math.max(max,max+dp.query(0,x[i]));\n\t\t\tdp.update(x[i], max);\n\t\t\t//System.out.println(dp);\n\t\t}\n\t\tlong ans = n*(n+1L)/2;\n\t\tans-=dp.query(0, n+1);\n\t\tSystem.out.println(ans);\n\t\tsc.close();\n\t}\n}\nclass RMQ {\n\tprivate int size;\n\tprivate int size_ = 1;\n\tprivate long[] data;\n\tpublic RMQ(int size) {\n\t\tthis.size = size;\n\t\twhile(this.size_<this.size) {\n\t\t\tthis.size_*=2;\n\t\t}\n\t\tdata = new long[size_*2-1];\n\t\tthis.init();\n\t}\n\n\tprivate void init() {\n\t\tArrays.fill(data, -1);\n\t}\n\n\tpublic void update(int k,long a) {\n\t\tk+=size_-1;\n\t\tdata[k] = a;\n\t\twhile(k>0) {\n\t\t\tk=(k-1)/2;\n\t\t\tdata[k] = Math.max(data[k*2+1],data[k*2+2]);\n\t\t}\n\t}\n\n\tpublic long query(int a,int b) {\n\t\treturn query(a,b,0,0,size_);\n\t}\n\n\t//[a,b)の区間について処理\n\t//kは接点の番号,[l,r)がkに対応する節点\n\tpublic long query(int a,int b,int k,int l,int r) {\n\t\tif (r<=a || b<=l) {\n\t\t\treturn Integer.MIN_VALUE;\n\t\t}\n\t\tif (a<=l && r<=b) {\n\t\t\treturn data[k];\n\t\t}else{\n\t\t\treturn Math.max(query(a,b,k*2+1,l,(l+r)/2)\n\t\t\t\t\t,query(a,b,k*2+2,(l+r)/2,r));\n\t\t}\n\t}\n\n\tpublic String toString() {\n\t\tString s = \"\";\n\t\tfor(int i=0;i<size;i++) {\n\t\t\ts += query(i,i+1) + \",\";\n\t\t}\n\t\treturn s;\n\t}\n}"
  },
  {
    "language": "Java",
    "code": "import java.util.Scanner;\n\npublic class Main {\n\tpublic static void main(String[] args) {\n\t\tScanner sc = new Scanner(System.in);\n\t\tint n = sc.nextInt();\n\t\tint[] x = new int[n];\n\t\tfor(int i=0;i<n;i++) {\n\t\t\tx[i] = sc.nextInt();\n\t\t}\n\t\tint[] dp = new int[n];\n\t\tfor(int i=0;i<n;i++) {\n\t\t\tdp[i] = x[i];\n\t\t\tfor(int j=0;j<i;j++) {\n\t\t\t\tif (x[j] < x[i]) {\n\t\t\t\t\tdp[i] = Math.max(dp[i], dp[j]+x[i]);\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t\tlong ans = 0;\n\t\tfor(int i=0;i<n;i++) {\n\t\t\tans = Math.max(ans,dp[i]);\n\t\t}\n\t\tSystem.out.println(n*(n+1)/2-ans);\n\t}\n}"
  },
  {
    "language": "Java",
    "code": "import java.util.Arrays;\nimport java.util.Scanner;\n\npublic class Main {\n\tpublic static void main(String[] args) {\n\t\tScanner sc = new Scanner(System.in);\n\t\tint n = sc.nextInt();\n\t\tint[] x = new int[n];\n\t\tfor(int i=0;i<n;i++) {\n\t\t\tx[i] = sc.nextInt();\n\t\t}\n\t\tRMQ dp = new RMQ(n+1);\n\t\tfor(int i=0;i<n;i++) {\n\t\t\tint max = x[i];\n\t\t\tmax = Math.max(max,max+dp.query(0,x[i]));\n\t\t\tdp.update(x[i], max);\n\t\t\t//System.out.println(dp);\n\t\t}\n\t\tlong ans = n*(n+1)/2;\n\t\tans-=dp.query(0, n+1);\n\t\tSystem.out.println(ans);\n\t}\n}\nclass RMQ {\n\tprivate int size;\n\tprivate int size_ = 1;\n\tprivate int[] data;\n\tpublic RMQ(int size) {\n\t\tthis.size = size;\n\t\twhile(this.size_<this.size) {\n\t\t\tthis.size_*=2;\n\t\t}\n\t\tdata = new int[size_*2-1];\n\t\tthis.init();\n\t}\n\n\tprivate void init() {\n\t\tArrays.fill(data, Integer.MIN_VALUE);\n\t}\n\n\tpublic void update(int k,int a) {\n\t\tk+=size_-1;\n\t\tdata[k] = a;\n\t\twhile(k>0) {\n\t\t\tk=(k-1)/2;\n\t\t\tdata[k] = Math.max(data[k*2+1],data[k*2+2]);\n\t\t}\n\t}\n\n\tpublic int query(int a,int b) {\n\t\treturn query(a,b,0,0,size_);\n\t}\n\n\t//[a,b)の区間について処理\n\t//kは接点の番号,[l,r)がkに対応する節点\n\tpublic int query(int a,int b,int k,int l,int r) {\n\t\tif (r<=a || b<=l) {\n\t\t\treturn Integer.MIN_VALUE;\n\t\t}\n\t\tif (a<=l && r<=b) {\n\t\t\treturn data[k];\n\t\t}else{\n\t\t\treturn Math.max(query(a,b,k*2+1,l,(l+r)/2)\n\t\t\t\t\t,query(a,b,k*2+2,(l+r)/2,r));\n\t\t}\n\t}\n\n\tpublic String toString() {\n\t\tString s = \"\";\n\t\tfor(int i=0;i<size;i++) {\n\t\t\ts += query(i,i+1) + \",\";\n\t\t}\n\t\treturn s;\n\t}\n}"
  },
  {
    "language": "Java",
    "code": "import java.util.*;\n\npublic class Main {\n\tpublic static void main(String[] args) {\n\t\tScanner sc = new Scanner(System.in);\n\n\t\tint n = sc.nextInt();\n\t\tint[] x = new int[n];\n\t\tfor (int i = 0; i < n; ++i)\n\t\t\tx[i] = sc.nextInt();\n\n\t\tlong all = 0;\n\t\tfor (int i = 0; i < n; ++i)\n\t\t\tall += x[i];\n\t\tSegmentTree seg = new SegmentTree(n + 1);\n\t\tfor (int i = 0; i < n; ++i) {\n\t\t\tlong pre = seg.query(0, x[i]);\n\t\t\tseg.set(x[i], pre + x[i]);\n\t\t}\n\t\tlong fix = seg.query(0, n + 1);\n\t\tSystem.out.println(all - fix);\n\t}\n\n\tstatic class SegmentTree {\n\t\tint n = 1;\n\t\tlong[] val;\n\n\t\tpublic SegmentTree(int n) {\n\t\t\twhile (this.n < n)\n\t\t\t\tthis.n *= 2;\n\t\t\tval = new long[2 * this.n - 1];\n\t\t}\n\n\t\tvoid set(int k, long l) {\n\t\t\tk += n - 1;\n\t\t\tval[k] = l;\n\t\t\twhile (k > 0) {\n\t\t\t\tk = (k - 1) / 2;\n\t\t\t\tval[k] = Math.max(val[2 * k + 1], val[2 * k + 2]);\n\t\t\t}\n\t\t}\n\n\t\tlong query(int a, int b) {\n\t\t\treturn query(a, b, 0, n, 0);\n\t\t}\n\n\t\tlong query(int a, int b, int l, int r, int k) {\n\t\t\tif (r <= a || b <= l)\n\t\t\t\treturn 0;\n\t\t\telse if (a <= l && r <= b) {\n\t\t\t\treturn val[k];\n\t\t\t} else {\n\t\t\t\tlong vl = query(a, b, l, (l + r) / 2, 2 * k + 1);\n\t\t\t\tlong vr = query(a, b, (l + r) / 2, r, 2 * k + 2);\n\t\t\t\treturn Math.max(vl, vr);\n\t\t\t}\n\t\t}\n\t}\n}"
  },
  {
    "language": "Java",
    "code": "import java.io.File;\nimport java.util.Arrays;\nimport java.util.Scanner;\n\npublic class Main {\n\tpublic static void main(String[] args) {\n\t\ttry {\n\t\t\tsolve(new Scanner(new File(\"src\\\\h\\\\10-maximum00.in\")));\n\t\t} catch (Exception e) {\n\t\t\te.printStackTrace();\n\t\t}\n\n\t}\n\tpublic static void solve(Scanner sc) {\n\t\tint n = sc.nextInt();\n\t\tint[] x = new int[n];\n\t\tfor(int i=0;i<n;i++) {\n\t\t\tx[i] = sc.nextInt();\n\t\t}\n\t\tRMQ dp = new RMQ(n+1);\n\t\tfor(int i=0;i<n;i++) {\n\t\t\tlong max = x[i];\n\t\t\tmax = Math.max(max,max+dp.query(0,x[i]));\n\t\t\tdp.update(x[i], max);\n\t\t\t//System.out.println(dp);\n\t\t}\n\t\tlong ans = n*(n+1L)/2;\n\t\tans-=dp.query(0, n+1);\n\t\tSystem.out.println(ans);\n\t\tsc.close();\n\t}\n}\nclass RMQ {\n\tprivate int size;\n\tprivate int size_ = 1;\n\tprivate long[] data;\n\tpublic RMQ(int size) {\n\t\tthis.size = size;\n\t\twhile(this.size_<this.size) {\n\t\t\tthis.size_*=2;\n\t\t}\n\t\tdata = new long[size_*2-1];\n\t\tthis.init();\n\t}\n\n\tprivate void init() {\n\t\tArrays.fill(data, -1);\n\t}\n\n\tpublic void update(int k,long a) {\n\t\tk+=size_-1;\n\t\tdata[k] = a;\n\t\twhile(k>0) {\n\t\t\tk=(k-1)/2;\n\t\t\tdata[k] = Math.max(data[k*2+1],data[k*2+2]);\n\t\t}\n\t}\n\n\tpublic long query(int a,int b) {\n\t\treturn query(a,b,0,0,size_);\n\t}\n\n\t//[a,b)の区間について処理\n\t//kは接点の番号,[l,r)がkに対応する節点\n\tpublic long query(int a,int b,int k,int l,int r) {\n\t\tif (r<=a || b<=l) {\n\t\t\treturn Integer.MIN_VALUE;\n\t\t}\n\t\tif (a<=l && r<=b) {\n\t\t\treturn data[k];\n\t\t}else{\n\t\t\treturn Math.max(query(a,b,k*2+1,l,(l+r)/2)\n\t\t\t\t\t,query(a,b,k*2+2,(l+r)/2,r));\n\t\t}\n\t}\n\n\tpublic String toString() {\n\t\tString s = \"\";\n\t\tfor(int i=0;i<size;i++) {\n\t\t\ts += query(i,i+1) + \",\";\n\t\t}\n\t\treturn s;\n\t}\n}"
  },
  {
    "language": "Java",
    "code": "import java.util.Arrays;\nimport java.util.Scanner;\n\npublic class Main {\n\tpublic static void main(String[] args) {\n\t\tScanner sc = new Scanner(System.in);\n\t\tint n = sc.nextInt();\n\t\tint[] x = new int[n];\n\t\tfor(int i=0;i<n;i++) {\n\t\t\tx[i] = sc.nextInt();\n\t\t}\n\t\tRMQ dp = new RMQ(n+1);\n\t\tfor(int i=0;i<n;i++) {\n\t\t\tlong max = x[i];\n\t\t\tmax = Math.max(max,max+dp.query(0,x[i]));\n\t\t\tdp.update(x[i], max);\n\t\t\t//System.out.println(dp);\n\t\t}\n\t\tlong ans = n*(n+1)/2;\n\t\tans-=dp.query(0, n+1);\n\t\tSystem.out.println(ans);\n\t}\n}\nclass RMQ {\n\tprivate int size;\n\tprivate int size_ = 1;\n\tprivate long[] data;\n\tpublic RMQ(int size) {\n\t\tthis.size = size;\n\t\twhile(this.size_<this.size) {\n\t\t\tthis.size_*=2;\n\t\t}\n\t\tdata = new long[size_*2-1];\n\t\tthis.init();\n\t}\n\n\tprivate void init() {\n\t\tArrays.fill(data, Integer.MIN_VALUE);\n\t}\n\n\tpublic void update(int k,long a) {\n\t\tk+=size_-1;\n\t\tdata[k] = a;\n\t\twhile(k>0) {\n\t\t\tk=(k-1)/2;\n\t\t\tdata[k] = Math.max(data[k*2+1],data[k*2+2]);\n\t\t}\n\t}\n\n\tpublic long query(int a,int b) {\n\t\treturn query(a,b,0,0,size_);\n\t}\n\n\t//[a,b)の区間について処理\n\t//kは接点の番号,[l,r)がkに対応する節点\n\tpublic long query(int a,int b,int k,int l,int r) {\n\t\tif (r<=a || b<=l) {\n\t\t\treturn Integer.MIN_VALUE;\n\t\t}\n\t\tif (a<=l && r<=b) {\n\t\t\treturn data[k];\n\t\t}else{\n\t\t\treturn Math.max(query(a,b,k*2+1,l,(l+r)/2)\n\t\t\t\t\t,query(a,b,k*2+2,(l+r)/2,r));\n\t\t}\n\t}\n\n\tpublic String toString() {\n\t\tString s = \"\";\n\t\tfor(int i=0;i<size;i++) {\n\t\t\ts += query(i,i+1) + \",\";\n\t\t}\n\t\treturn s;\n\t}\n}"
  },
  {
    "language": "Java",
    "code": "import java.util.*;\nimport java.lang.*;\nimport java.math.*;\nimport java.io.*;\n\nimport static java.lang.Math.*;\nimport static java.util.Arrays.*;\nimport static java.util.Collections.*;\n\npublic class Main{\n\tScanner sc=new Scanner(System.in);\n\n\tlong INF=1L<<60;\n\tdouble EPS=1e-12;\n\n\tint n;\n\tint[] x;\n\n\tvoid run(){\n\t\tn=sc.nextInt();\n\t\tx=new int[n];\n\t\tfor(int i=0; i<n; i++){\n\t\t\tx[i]=sc.nextInt();\n\t\t}\n\t\tsolve();\n\t}\n\n\tvoid solve(){\n\t\tSegTree seg=new SegTree(n);\n\t\tfor(int i=0; i<n; i++){\n\t\t\tseg.update(x[i], seg.query(0, x[i]+1)+x[i]);\n\t\t}\n\t\tprintln((long)n*(n+1)/2-seg.query(0, n+1)+\"\");\n\t}\n\n\t// root = 1\n\t// par(k) = k/2\n\t// left(k) = 2*k\n\t// right(k) = 2*k+1\n\tclass SegTree{\n\t\tint n;\n\n\t\tlong[] a;\n\n\t\tSegTree(int n){\n\t\t\tthis.n=Integer.highestOneBit(n)<<1;\n\t\t\ta=new long[this.n*2];\n\t\t}\n\n\t\tvoid update(int k, long x){\n\t\t\ta[n+k]=x;\n\t\t\tfor(int i=(n+k)>>1; i>0; i>>=1){\n\t\t\t\ta[i]=max(a[2*i], a[2*i+1]);\n\t\t\t}\n\t\t}\n\n\t\t// [s, t)\n\t\tlong query(int s, int t){\n\t\t\treturn query(s, t, 1, 0, n);\n\t\t}\n\n\t\tlong query(int s, int t, int k, int l, int r){\n\t\t\t// debug(s,t,k,l,r);\n\t\t\tif(r<=s||l>=t){\n\t\t\t\t// 範囲外\n\t\t\t\treturn -1;\n\t\t\t}else if(s<=l&&r<=t){\n\t\t\t\t// a[k]\n\t\t\t\treturn a[k];\n\t\t\t}else{\n\t\t\t\treturn max(query(s, t, k*2, l, (l+r)/2),\n\t\t\t\t\t\tquery(s, t, k*2+1, (l+r)/2, r));\n\t\t\t}\n\t\t}\n\t}\n\n\tclass Scanner{\n\t\tBufferedReader br;\n\t\tStringTokenizer st;\n\n\t\tScanner(InputStream in){\n\t\t\tbr=new BufferedReader(new InputStreamReader(in));\n\t\t\teat(\"\");\n\t\t}\n\n\t\tvoid eat(String s){\n\t\t\tst=new StringTokenizer(s);\n\t\t}\n\n\t\tString nextLine(){\n\t\t\ttry{\n\t\t\t\treturn br.readLine();\n\t\t\t}catch(IOException e){\n\t\t\t\tthrow new IOError(e);\n\t\t\t}\n\t\t}\n\n\t\tboolean hasNext(){\n\t\t\twhile(!st.hasMoreTokens()){\n\t\t\t\tString s=nextLine();\n\t\t\t\tif(s==null)\n\t\t\t\t\treturn false;\n\t\t\t\teat(s);\n\t\t\t}\n\t\t\treturn true;\n\t\t}\n\n\t\tString next(){\n\t\t\thasNext();\n\t\t\treturn st.nextToken();\n\t\t}\n\n\t\tint nextInt(){\n\t\t\treturn Integer.parseInt(next());\n\t\t}\n\t}\n\n\tvoid debug(Object... os){\n\t\tSystem.err.println(Arrays.deepToString(os));\n\t}\n\n\tvoid print(String s){\n\t\tSystem.out.print(s);\n\t}\n\n\tvoid println(String s){\n\t\tSystem.out.println(s);\n\t}\n\n\tpublic static void main(String[] args){\n\t\tnew Main().run();\n\t}\n}"
  },
  {
    "language": "Java",
    "code": "import java.util.*;\n\npublic class Main {\n\tpublic static void main(String[] args) {\n\t\tScanner sc = new Scanner(System.in);\n\n\t\tint n = sc.nextInt();\n\t\tint[] x = new int[n];\n\t\tfor (int i = 0; i < n; ++i)\n\t\t\tx[i] = sc.nextInt();\n\n\t\tlong all = 0;\n\t\tfor (int i = 0; i < n; ++i)\n\t\t\tall += x[i];\n\t\tSegmentTree seg = new SegmentTree(n + 1);\n\t\tfor (int i = 0; i < n; ++i) {\n\t\t\tlong pre = seg.query(0, x[i]);\n\t\t\tseg.set(x[i], pre + x[i]);\n\t\t}\n\t\tlong fix = seg.query(0, n + 1);\n\t\tSystem.out.println(all - fix);\n\t}\n\n\tstatic class SegmentTree {\n\t\tint n = 1;\n\t\tlong[] val;\n\n\t\tpublic SegmentTree(int n) {\n\t\t\twhile (this.n < n)\n\t\t\t\tthis.n *= 2;\n\t\t\tval = new long[2 * this.n - 1];\n\t\t}\n\n\t\tvoid set(int k, long l) {\n\t\t\tk += n - 1;\n\t\t\tval[k] = l;\n\t\t\twhile (k > 0) {\n\t\t\t\tk = (k - 1) / 2;\n\t\t\t\tval[k] = Math.max(val[2 * k + 1], val[2 * k + 2]);\n\t\t\t}\n\t\t}\n\n\t\tlong query(int a, int b) {\n\t\t\treturn query(a, b, 0, n, 0);\n\t\t}\n\n\t\tlong query(int a, int b, int l, int r, int k) {\n\t\t\tif (r <= a || b <= l)\n\t\t\t\treturn 0;\n\t\t\telse if (a <= l && r <= b) {\n\t\t\t\treturn val[k];\n\t\t\t} else {\n\t\t\t\tlong vl = query(a, b, l, (l + r) / 2, 2 * k + 1);\n\t\t\t\tlong vr = query(a, b, (l + r) / 2, r, 2 * k + 2);\n\t\t\t\treturn Math.max(vl, vr);\n\t\t\t}\n\t\t}\n\t}\n}"
  },
  {
    "language": "Java",
    "code": "import java.util.Scanner;\n\npublic class Main {\n\n\tstatic Scanner sc = new Scanner(System.in);\n\tstatic long[] tree = new long[400000];\n\n\tstatic long max(int pos, int l, int r, int min, int max) {\n\t\tlong ret = 0;\n\t\tif (l == min && r == max) return tree[pos];\n\t\tint m = (l + r) / 2;\n\t\tif (min < m) {\n\t\t\tret = Math.max(ret, max(pos * 2 + 1, l, m, min, Math.min(m, max)));\n\t\t}\n\t\tif (m < max) {\n\t\t\tret = Math.max(ret, max(pos * 2 + 2, m, r, Math.max(m, min), max));\n\t\t}\n\t\treturn ret;\n\t}\n\n\tstatic void set(int pos, int l, int r, int index, long v) {\n\t\ttree[pos] = Math.max(tree[pos], v);\n\t\tif (l == r - 1) return;\n\t\tint m = (l + r) / 2;\n\t\tif (index < m) {\n\t\t\tset(pos * 2 + 1, l, m, index, v);\n\t\t} else {\n\t\t\tset(pos * 2 + 2, m, r, index, v);\n\t\t}\n\t}\n\n\tpublic static void main(String[] args) {\n\t\tint N = sc.nextInt();\n\t\tint size = 1;\n\t\twhile (size <= N) {\n\t\t\tsize *= 2;\n\t\t}\n\t\tfor (int i = 0; i < N; ++i) {\n\t\t\tint x = sc.nextInt();\n\t\t\tlong max = max(0, 0, size, 0, x);\n\t\t\tset(0, 0, size, x, max + x);\n\t\t}\n\t\tSystem.out.println((long) N * (N + 1) / 2 - tree[0]);\n\t}\n}"
  },
  {
    "language": "Java",
    "code": "import java.io.BufferedReader;\nimport java.io.IOException;\nimport java.io.InputStreamReader;\nimport java.util.Arrays;\nimport java.util.Scanner;\nimport java.util.TreeSet;\n \n \npublic class Main{\n     \n\tpublic static int sum(int[] bit, final int n, int i){\n\t\tint s = 0;\n\t\twhile(i > 0){\n\t\t\ts += bit[i];\n\t\t\ti -= i & -i;\n\t\t}\n\t\t\n\t\treturn s;\n\t}\n\t\n\tpublic static void add(int[] bit, final int n, int i, int x){\n\t\twhile(i <= n){\n\t\t\tbit[i] += x;\n\t\t\ti += i & -i;\n\t\t}\n\t}\n\t\n\tpublic static final int MAX = 10;\n\t\n    public static void main(String[] args) throws IOException {\n    \tScanner sc = new Scanner(System.in);\n         \n    \tfinal int n = sc.nextInt();\n    \t\n    \tint[] bit = new int[MAX];\n    \tint[] array = new int[MAX];\n    \t\n    \tfor(int i = 0; i < n; i++){\n    \t\tarray[i] = sc.nextInt();\n    \t\tadd(bit, n, array[i], array[i]);\n    \t\t//System.out.println(Arrays.toString(bit));\n    \t}\n    \t\n    \t\n    \t\n    \tint sum_cost = 0;\n    \tint prev = -1;\n    \tfor(int i = 0; i < n; i++){\n    \t\tfinal int move_cost = array[i];\n    \t\tfinal int other_cost = sum(bit, n, move_cost - 1);\n    \t\t\n    \t\t//System.out.println(i + \" \" + move_cost + \" \" + other_cost + \" ... (\" + prev + \" \" + sum_cost +  \")\");\n    \t\t\n    \t\tif(move_cost <= other_cost){\n    \t\t\tsum_cost += move_cost;\n    \t\t}else if(prev != -1 && move_cost < prev){\n    \t\t\tsum_cost += move_cost;\n    \t\t}else{\n    \t\t\tprev = move_cost;\n    \t\t}\n    \t\tadd(bit, n, move_cost, -move_cost);\n    \t\t//System.out.println(Arrays.toString(bit));\n    \t}\n    \t\n    \tSystem.out.println(sum_cost);\n         \n    }\n     \n}"
  },
  {
    "language": "Java",
    "code": "import java.io.BufferedReader;\nimport java.io.IOException;\nimport java.io.InputStreamReader;\nimport java.util.Arrays;\nimport java.util.Scanner;\nimport java.util.TreeSet;\n \n \npublic class Main{\n     \n\tpublic static int sum(int[] bit, final int n, int i){\n\t\tint s = 0;\n\t\twhile(i > 0){\n\t\t\ts += bit[i];\n\t\t\ti -= i & -i;\n\t\t}\n\t\t\n\t\treturn s;\n\t}\n\t\n\tpublic static void add(int[] bit, final int n, int i, int x){\n\t\twhile(i <= n){\n\t\t\tbit[i] += x;\n\t\t\ti += i & -i;\n\t\t}\n\t}\n\t\n\tpublic static final int MAX = 100000;\n\t\n    public static void main(String[] args) throws IOException {\n    \tScanner sc = new Scanner(System.in);\n         \n    \tfinal int n = sc.nextInt();\n    \t\n    \tint[] bit = new int[MAX];\n    \tint[] array = new int[MAX];\n    \t\n    \tfor(int i = 0; i < n; i++){\n    \t\tarray[i] = sc.nextInt();\n    \t\tadd(bit, n, array[i], array[i]);\n    \t\t//System.out.println(Arrays.toString(bit));\n    \t}\n    \t\n    \t\n    \t\n    \tint sum_cost = 0;\n    \tint prev = -1;\n    \tfor(int i = 0; i < n; i++){\n    \t\tfinal int move_cost = array[i];\n    \t\tfinal int other_cost = sum(bit, n, move_cost - 1);\n    \t\t\n    \t\t//System.out.println(i + \" \" + move_cost + \" \" + other_cost + \" ... (\" + prev + \" \" + sum_cost +  \")\");\n    \t\t\n    \t\tif(move_cost <= other_cost){\n    \t\t\tsum_cost += move_cost;\n    \t\t}else if(prev != -1 && move_cost < prev){\n    \t\t\tsum_cost += move_cost;\n    \t\t}else{\n    \t\t\tprev = move_cost;\n    \t\t}\n    \t\tadd(bit, n, move_cost, -move_cost);\n    \t\t//System.out.println(Arrays.toString(bit));\n    \t}\n    \t\n    \tSystem.out.println(sum_cost);\n         \n    }\n     \n}"
  },
  {
    "language": "Java",
    "code": "import java.io.BufferedReader;\nimport java.io.IOException;\nimport java.io.InputStreamReader;\nimport java.util.Arrays;\nimport java.util.Scanner;\nimport java.util.TreeSet;\n \n \npublic class Main{\n     \n\tpublic static int sum(int[] bit, final int n, int i){\n\t\tint s = 0;\n\t\twhile(i > 0){\n\t\t\ts += bit[i];\n\t\t\ti -= i & -i;\n\t\t}\n\t\t\n\t\treturn s;\n\t}\n\t\n\tpublic static void add(int[] bit, final int n, int i, int x){\n\t\twhile(i <= n){\n\t\t\tbit[i] += x;\n\t\t\ti += i & -i;\n\t\t}\n\t}\n\t\n\tpublic static final int MAX = 100001;\n\t\n    public static void main(String[] args) throws IOException {\n    \tScanner sc = new Scanner(System.in);\n         \n    \tfinal int n = sc.nextInt();\n    \t\n    \tint[] bit = new int[MAX];\n    \tint[] array = new int[MAX];\n    \t\n    \tfor(int i = 0; i < n; i++){\n    \t\tarray[i] = sc.nextInt();\n    \t\tadd(bit, n, array[i], array[i]);\n    \t\t//System.out.println(Arrays.toString(bit));\n    \t}\n    \t\n    \t\n    \t\n    \tint sum_cost = 0;\n    \tint prev = -1;\n    \tfor(int i = 0; i < n; i++){\n    \t\tfinal int move_cost = array[i];\n    \t\tfinal int other_cost = sum(bit, n, move_cost - 1);\n    \t\t\n    \t\t//System.out.println(i + \" \" + move_cost + \" \" + other_cost + \" ... (\" + prev + \" \" + sum_cost +  \")\");\n    \t\t\n    \t\tif(move_cost < other_cost){\n    \t\t\tsum_cost += move_cost;\n    \t\t}else if(prev != -1 && move_cost < prev){\n    \t\t\tsum_cost += move_cost;\n    \t\t}else{\n    \t\t\tprev = move_cost;\n    \t\t}\n    \t\tadd(bit, n, move_cost, -move_cost);\n    \t\t//System.out.println(Arrays.toString(bit));\n    \t}\n    \t\n    \tSystem.out.println(sum_cost);\n         \n    }\n     \n}"
  },
  {
    "language": "Java",
    "code": "import java.util.*;\nimport java.lang.*;\nimport java.math.*;\nimport java.io.*;\n\nimport static java.lang.Math.*;\nimport static java.util.Arrays.*;\nimport static java.util.Collections.*;\n\n// House Moving\n// 2012/09/20\npublic class Main{\n\tScanner sc=new Scanner(System.in);\n\n\tlong INF=1L<<60;\n\n\tint n;\n\tint[] x;\n\n\tvoid run(){\n\t\tn=sc.nextInt();\n\t\tx=new int[n];\n\t\tfor(int i=0; i<n; i++){\n\t\t\tx[i]=sc.nextInt();\n\t\t}\n\t\tsolve();\n\t}\n\n\tvoid solve(){\n\t\tSegTree seg=new SegTree(n);\n\t\tfor(int i=0; i<n; i++){\n\t\t\tseg.update(x[i], seg.query(0, x[i]+1)+x[i]);\n\t\t}\n\t\tprintln((long)n*(n+1)/2-seg.query(0, n+1)+\"\");\n\t}\n\n\tclass SegTree{\n\t\tint N;\n\t\tlong[] a;\n\n\t\tSegTree(int n){\n\t\t\tN=Integer.highestOneBit(n)<<1;\n\t\t\ta=new long[N<<1];\n\t\t}\n\n\t\tvoid update(int k, long x){\n\t\t\ta[N+k]=x;\n\t\t\tfor(int i=(N+k)>>1; i>0; i>>=1){\n\t\t\t\ta[i]=max(a[2*i], a[2*i+1]);\n\t\t\t}\n\t\t}\n\n\t\t// [s, t)\n\t\tlong query(int s, int t){\n\t\t\treturn query(s, t, 1, 0, N);\n\t\t}\n\n\t\tlong query(int s, int t, int k, int l, int r){\n\t\t\tif(r<=s||l>=t){\n\t\t\t\treturn 0;\n\t\t\t}else if(s<=l&&r<=t){\n\t\t\t\treturn a[k];\n\t\t\t}else{\n\t\t\t\treturn max(query(s, t, k*2, l, (l+r)>>1),\n\t\t\t\t\t\tquery(s, t, k*2+1, (l+r)>>1, r));\n\t\t\t}\n\t\t}\n\t}\n\n\tclass Scanner{\n\t\tBufferedReader br;\n\t\tStringTokenizer st;\n\n\t\tScanner(InputStream in){\n\t\t\tbr=new BufferedReader(new InputStreamReader(in));\n\t\t\teat(\"\");\n\t\t}\n\n\t\tvoid eat(String s){\n\t\t\tst=new StringTokenizer(s);\n\t\t}\n\n\t\tString nextLine(){\n\t\t\ttry{\n\t\t\t\treturn br.readLine();\n\t\t\t}catch(IOException e){\n\t\t\t\tthrow new IOError(e);\n\t\t\t}\n\t\t}\n\n\t\tboolean hasNext(){\n\t\t\twhile(!st.hasMoreTokens()){\n\t\t\t\tString s=nextLine();\n\t\t\t\tif(s==null)\n\t\t\t\t\treturn false;\n\t\t\t\teat(s);\n\t\t\t}\n\t\t\treturn true;\n\t\t}\n\n\t\tString next(){\n\t\t\thasNext();\n\t\t\treturn st.nextToken();\n\t\t}\n\n\t\tint nextInt(){\n\t\t\treturn Integer.parseInt(next());\n\t\t}\n\t}\n\n\tvoid println(String s){\n\t\tSystem.out.println(s);\n\t}\n\n\tpublic static void main(String[] args){\n\t\tnew Main().run();\n\t}\n}"
  },
  {
    "language": "Java",
    "code": "import java.io.BufferedReader;\nimport java.io.IOException;\nimport java.io.InputStreamReader;\nimport java.util.Arrays;\nimport java.util.Scanner;\nimport java.util.TreeSet;\n \n \npublic class Main{\n     \n\tpublic static int sum(int[] bit, final int n, int i){\n\t\tint s = 0;\n\t\twhile(i > 0){\n\t\t\ts += bit[i];\n\t\t\ti -= i & -i;\n\t\t}\n\t\t\n\t\treturn s;\n\t}\n\t\n\tpublic static void add(int[] bit, final int n, int i, int x){\n\t\twhile(i <= n){\n\t\t\tbit[i] += x;\n\t\t\ti += i & -i;\n\t\t}\n\t}\n\t\n\tpublic static final int MAX = 100001;\n\t\n    public static void main(String[] args) throws IOException {\n    \tScanner sc = new Scanner(System.in);\n         \n    \tfinal int n = sc.nextInt();\n    \t\n    \tint[] bit = new int[MAX];\n    \tint[] array = new int[MAX];\n    \t\n    \tfor(int i = 0; i < n; i++){\n    \t\tarray[i] = sc.nextInt();\n    \t\tadd(bit, n, array[i], array[i]);\n    \t\t//System.out.println(Arrays.toString(bit));\n    \t}\n    \t\n    \t\n    \t\n    \tint sum_cost = 0;\n    \tint prev = -1;\n    \tfor(int i = 0; i < n; i++){\n    \t\tfinal int move_cost = array[i];\n    \t\tfinal int other_cost = sum(bit, n, move_cost - 1);\n    \t\t\n    \t\t//System.out.println(i + \" \" + move_cost + \" \" + other_cost + \" ... (\" + prev + \" \" + sum_cost +  \")\");\n    \t\t\n    \t\tif(move_cost <= other_cost){\n    \t\t\tsum_cost += move_cost;\n    \t\t}else if(prev != -1 && move_cost < prev){\n    \t\t\tsum_cost += move_cost;\n    \t\t}else{\n    \t\t\tprev = move_cost;\n    \t\t}\n    \t\tadd(bit, n, move_cost, -move_cost);\n    \t\t//System.out.println(Arrays.toString(bit));\n    \t}\n    \t\n    \tSystem.out.println(sum_cost);\n         \n    }\n     \n}"
  },
  {
    "language": "C#",
    "code": "using System;\nusing System.Linq;\nusing System.Collections.Generic;\nusing Debug = System.Diagnostics.Debug;\nusing SB = System.Text.StringBuilder;\nusing System.Numerics;\nusing static System.Math;\nusing Point = System.Numerics.Complex;\nusing Number = System.Int64;\nnamespace Program {\n    public class Solver {\n        Random rnd = new Random(0);\n        public void Solve() {\n            var n = ri;\n            var a = Enumerate(n, x => ri);\n            var rmq = new RMQ(n + 50);\n            for (int i = 1; i <= n; i++)\n                rmq.Update(i, -INF);\n            rmq.Update(0, 0);\n            foreach (var x in a)\n            {\n                var ma = rmq.Query(0, x);\n                rmq.Update(x, ma + x);\n            }\n            var ans = Math.BigMul(n, n + 1) / 2;\n            ans -= rmq.Query(0, n + 1);\n            Console.WriteLine(ans);\n        }\n        const long INF = 1L << 60;\n        int ri { get { return sc.Integer(); } }\n        long rl { get { return sc.Long(); } }\n        double rd { get { return sc.Double(); } }\n        string rs { get { return sc.Scan(); } }\n        public IO.StreamScanner sc = new IO.StreamScanner(Console.OpenStandardInput());\n\n        static T[] Enumerate<T>(int n, Func<int, T> f) {\n            var a = new T[n];\n            for (int i = 0; i < n; ++i) a[i] = f(i);\n            return a;\n        }\n        static public void Swap<T>(ref T a, ref T b) { var tmp = a; a = b; b = tmp; }\n    }\n}\n\n#region main\nstatic class Ex {\n    static public string AsString(this IEnumerable<char> ie) { return new string(ie.ToArray()); }\n    static public string AsJoinedString<T>(this IEnumerable<T> ie, string st = \" \") {\n        return string.Join(st, ie);\n    }\n    static public void Main() {\n        Console.SetOut(new Program.IO.Printer(Console.OpenStandardOutput()) { AutoFlush = false });\n        var solver = new Program.Solver();\n        solver.Solve();\n        Console.Out.Flush();\n    }\n}\n#endregion\n#region Ex\nnamespace Program.IO {\n    using System.IO;\n    using System.Text;\n    using System.Globalization;\n\n    public class Printer: StreamWriter {\n        public override IFormatProvider FormatProvider { get { return CultureInfo.InvariantCulture; } }\n        public Printer(Stream stream) : base(stream, new UTF8Encoding(false, true)) { }\n    }\n\n    public class StreamScanner {\n        public StreamScanner(Stream stream) { str = stream; }\n\n        public readonly Stream str;\n        private readonly byte[] buf = new byte[1024];\n        private int len, ptr;\n        public bool isEof = false;\n        public bool IsEndOfStream { get { return isEof; } }\n\n        private byte read() {\n            if (isEof) return 0;\n            if (ptr >= len)\n            {\n                ptr = 0;\n                if ((len = str.Read(buf, 0, 1024)) <= 0)\n                {\n                    isEof = true;\n                    return 0;\n                }\n            }\n            return buf[ptr++];\n        }\n\n        public char Char() {\n            byte b = 0;\n            do b = read(); while ((b < 33 || 126 < b) && !isEof);\n            return (char)b;\n        }\n        public string Scan() {\n            var sb = new StringBuilder();\n            for (var b = Char(); b >= 33 && b <= 126; b = (char)read()) sb.Append(b);\n            return sb.ToString();\n        }\n        public string ScanLine() {\n            var sb = new StringBuilder();\n            for (var b = Char(); b != '\\n' && b != 0; b = (char)read()) if (b != '\\r') sb.Append(b);\n            return sb.ToString();\n        }\n        public long Long() { return isEof ? long.MinValue : long.Parse(Scan()); }\n        public int Integer() { return isEof ? int.MinValue : int.Parse(Scan()); }\n        public double Double() { return isEof ? double.NaN : double.Parse(Scan(), CultureInfo.InvariantCulture); }\n    }\n}\n\n#endregion\n\n#region SegTree Operator\npublic interface IData<T> {\n    T Merge(T l, T r);\n    T Identity { get; }\n    T InitValue { get; }\n}\n#endregion\n#region Segment Tree\n\npublic class SegmentTree<T, U>\n   where U : struct, IData<T> {\n    int sz;\n    int n;\n    T[] data;\n    U op;\n    public SegmentTree(int size) {\n        sz = size;\n        n = 1;\n        while (n < size) n *= 2;\n        data = new T[n * 2];\n        for (int i = 0; i < data.Length; i++)\n            data[i] = op.InitValue;\n    }\n    public SegmentTree(T[] a) {\n        sz = a.Length;\n        n = 1;\n        while (n < sz) n *= 2;\n        data = new T[n * 2];\n        for (int i = 0; i < n; i++)\n            data[i + n] = (i < a.Length) ? a[i] : op.InitValue;\n        for (int i = n - 1; i >= 0; i--)\n            data[i] = op.Merge(data[i * 2], data[i * 2 + 1]);\n    }\n    public void Update(int k, T v) {\n        k += n;\n        data[k] = v;\n        for (k = k / 2; k > 0; k /= 2)\n            data[k] = op.Merge(data[k * 2], data[k * 2 + 1]);\n\n    }\n    public T Query(int a, int b) { return query(a, b, 1, 0, n); }\n    private T query(int a, int b, int k, int l, int r) {\n        if (r <= a || b <= l)\n            return op.Identity;\n        if (a <= l && r <= b)\n            return data[k];\n        else\n        {\n            var vl = query(a, b, k * 2, l, (l + r) / 2);\n            var vr = query(a, b, k * 2 + 1, (l + r) / 2, r);\n            return op.Merge(vl, vr);\n        }\n    }\n    public T[] Items {\n        get {\n            var ret = new T[sz];\n            for (int i = 0; i < sz; i++)\n                ret[i] = data[i + n];\n            return ret;\n        }\n    }\n\n}\n#endregion\n#region RmQ\npublic class RmQ: SegmentTree<long, MinData> {\n    public RmQ(int size) : base(size) { }\n}\npublic struct MinData: IData<long> {\n    public long InitValue { get { return 0; } }\n    public long Identity { get { return long.MaxValue; } }\n    public long Merge(long l, long r) { return Math.Min(l, r); }\n\n\n}\n#endregion\n#region RMQ\npublic class RMQ: SegmentTree<long, MaxData> {\n    public RMQ(int size) : base(size) { }\n}\npublic struct MaxData: IData<long> {\n    public long Identity { get { return long.MinValue; } }\n\n    public long InitValue { get { return 0; } }\n\n    public long Merge(long l, long r) { return Math.Max(l, r); }\n}\n#endregion\n"
  },
  {
    "language": "Ruby",
    "code": "n = gets.to_i\na = gets.split.map(&:to_i)\n\nhash = {0 => 0}\n\na.each do |w| \n    new_hash = Hash.new(Float::INFINITY)\n    hash.each do |l, cost|\n        new_hash[l] = cost + w if cost + w < new_hash[l]\n        if l < w \n            new_hash[w] = cost if cost < new_hash[w]\n        end \n    end \n    hash = new_hash\nend\np hash.values.min"
  },
  {
    "language": "Ruby",
    "code": "class SegmentTree\n\tdef initialize(arr, l = 0, r = arr.size - 1)\n\t\t@l = l\n\t\t@r = r\n\t\tif l == r\n\t\t\t@max = arr[l]\n\t\telse\n\t\t\tc = (l + r) / 2\n\t\t\t@left_child = self.class.new(arr, l, c)\n\t\t\t@right_child = self.class.new(arr, c+1, r)\n\t\t\tlm = @left_child.max\n\t\t\trm = @right_child.max\n\t\t\t@max = (lm > rm ? lm : rm)\n\t\tend\n\tend\n\n\tdef query(r)\n\t\treturn @max if r == @r\n\t\tif r <= @left_child.r\n\t\t\treturn @left_child.query(r)\n\t\telse\n\t\t\tlm = @left_child.max\n\t\t\trm = @right_child.query(r)\n\t\t\treturn lm > rm ? lm : rm\n\t\tend\n\tend\n\n\tdef update(i, x)\n\t\tif @l == @r\n\t\t\t@max = x\t\n\t\telsif i <= @left_child.r \n\t\t\t@left_child.update(i, x)\n\t\t\t@max = @left_child.max if @left_child.max > @max\n\t\telse\n\t\t\t@right_child.update(i, x)\n\t\t\t@max = @right_child.max if @right_child.max > @max\n\t\tend\n\tend\n\n\tattr_reader :max, :l, :r\nend\n\nn = gets.to_i\nt = SegmentTree.new([0] * (n+1))\ngets.split.map(&:to_i).each do |x|\n\tt.update(x, t.query(x - 1) + x)\nend\np n * (n + 1) / 2 - t.max"
  },
  {
    "language": "Ruby",
    "code": "n = gets.to_i\na = gets.split.map(&:to_i)\n\nhash = {0 => 0}\n\na.each do |w|\n    new_hash = Hash.new(-Float::INFINITY)\n    hash.each do |l, cost|\n        new_hash[l] = cost if cost > new_hash[l]\n        if l < w\n            new_hash[w] = cost + w if cost + w > new_hash[w]\n        end\n    end\n    hash = new_hash\nend\np (1 + n) * n / 2 - hash.values.max"
  },
  {
    "language": "Ruby",
    "code": "gets\narray_x = gets.chomp.split\n\narray_x.map! do |x|\n  x.to_i\nend\n\ns = 0\n\nloop do\n  candi_i = 0\n  max_abs = 0\n  array_x.each_with_index do |x, i|\n    abs = (x - i - 1).abs\n    if max_abs < abs\n      max_abs = abs\n      candi_i = i\n    elsif max_abs == abs\n      if array_x[candi_i] > x\n        candi_i = i\n      end\n    end\n  end\n  \n  if max_abs == 0 then break end\n\n  x = array_x[candi_i].to_i\n  array_x.delete_at candi_i\n  array_x.insert x - 1, x\n  s += x\nend\n\nputs s"
  },
  {
    "language": "Ruby",
    "code": "gets\narray_x = gets.chomp.split\n\narray_x.map! do |x|\n  x.to_i\nend\n\ns = 0\n\nloop do\n  candi_i = 0\n  max_abs = 0\n  array_x.each_with_index do |x, i|\n    abs = (x - i - 1).abs\n    if max_abs < abs\n      max_abs = abs\n      candi_i = i\n    elsif max_abs == abs\n      if array_x[candi_i] > x\n        candi_i = i\n      end\n    end\n  end\n  \n  if max_abs == 0 then break end\n\n  x = array_x[candi_i].to_i\n  array_x.delete_at candi_i\n  array_x.insert x - 1, x\n  s += x\nend\n\nprint s"
  },
  {
    "language": "D",
    "code": "import std.stdio;\nimport std.string;\nimport std.conv;\nimport std.array;\nimport std.range;\nimport std.typecons;\nimport std.algorithm;\n\nstruct RMQSegmentTree(Type = int,string gstr = \"a>b\"){\n\tType[] data;\n\tsize_t height;\n\tType initvalue;\n\n\tbool greater(Type a,Type b){\n\t\tbool ret;\n\t\tmixin(\"ret = \"~gstr~\";\");\n\t\treturn ret;\n\t}\n\n\tType greatValue(Type a,Type b){\n\t\tif(greater(a,b))\n\t\t\treturn a;\n\t\treturn b;\n\t}\n\n\tvoid SetSize(size_t size){\n\t\tsize_t s = 1;\n\t\theight = 0;\n\t\twhile(s<size){\n\t\t\ts*=2;\n\t\t\t++height;\n\t\t}\n\t\tdata = new Type[s*2];\n\t\tinitvalue = Type.max - greatValue(Type.max,Type.min);\n\t\tdata[] = initvalue;\n\t}\n\n\tsize_t GetIdx(size_t idx,size_t depth){\n\t\tsize_t blocksize = 1<<depth;\n\t\treturn blocksize-1+(idx/blocksize)*blocksize*2;\n\t}\n\n\tvoid SetData(size_t idx,Type value,size_t depth = 0){\n\t\tif(depth > height)\n\t\t\treturn;\n\t\tsize_t gi = GetIdx(idx,depth);\n\t\tif(greater(value,data[gi])){\n\t\t\tdata[gi] = value;\n\t\t\tSetData(idx,value,depth+1);\n\t\t}\n\t}\n\n\tType GetRMQ(size_t begin,size_t end,size_t depth = -1){\n\t\tif(depth == -1)\n\t\t\tdepth = height;\n\t\tif(begin == end)\n\t\t\treturn initvalue;\n\t\tsize_t blocksize = 1<<depth;\n\t\tsize_t start = begin - begin%blocksize;\n\t\tif(start == begin && start + blocksize == end)\n\t\t\treturn data[GetIdx(begin,depth)];\n\t\tblocksize /= 2;\n\t\tType ret = initvalue;\n\t\tif(begin < start + blocksize)\n\t\t\tret = greatValue(ret, GetRMQ(begin,min(start + blocksize, end), depth-1));\n\t\tif(end > start + blocksize)\n\t\t\tret = greatValue(ret, GetRMQ(max(begin,start + blocksize), end, depth-1));\n\t\treturn ret;\n\t}\n}\n\nint[] rdi(){\n\treturn readln.split.map!(to!int).array;\n}\n\nvoid main(){\n\tint n= rdi[0];\n\tint[] w;\n\tw = rdi;\n\tRMQSegmentTree!long st;\n\tst.SetSize(n);\n\tlong[] dp = new long[n];\n\tdp[] = 0;\n\tforeach(i;0..n){\n\t\tdp[i] = st.GetRMQ(0,w[i]);\n\t\tdp[i] += w[i];\n\t\tst.SetData(w[i]-1,dp[i]);\n\t}\n\tlong res = 0;\n\tforeach(i;0..n){\n\t\tres += w[i];\n\t}\n\tlong md = 0;\n\tforeach(i;0..n){\n\t\tmd = max(md,dp[i]);\n\t}\n\t(res-md).writeln;\n}"
  },
  {
    "language": "D",
    "code": "import std.algorithm;\nimport std.array;\nimport std.conv;\nimport std.math;\nimport std.range;\nimport std.stdio;\nimport std.string;\nimport std.typecons;\n\nint readint() {\n    return readln.chomp.to!int;\n}\n\nint[] readints() {\n    return readln.split.map!(to!int).array;\n}\n\nvoid main() {\n    readln;\n    auto xs = readints();\n\n    int n = cast(int) xs.length;\n    auto segTree = new SegmentTree(n + 1);\n    foreach (x; xs) {\n        auto max = segTree.query(1, x);\n        segTree.update(x, x + max);\n    }\n\n    auto max = segTree.query(1, n + 1);\n    writeln(cast(long) n * (n + 1) / 2 - max);\n}\n\nclass SegmentTree {\n    private long[] _data;\n\n    this(int n) {\n        int len = 1;\n        while (len < n)\n            len *= 2;\n\n        _data = new long[len * 2];\n    }\n\n    /// k ?????????????´????(0-indexed)??? a ????????´\n    void update(int k, long a) {\n        // ????????\\???\n        k += (_data.length / 2) - 1;\n        _data[k] = a;\n        // ?????????????????´??°\n        while (k > 0) {\n            k = (k - 1) / 2;\n            _data[k] = max(_data[k * 2 + 1], _data[k * 2 + 2]);\n        }\n    }\n\n    /// [a, b) ???????°????????±???????\n    long query(int a, int b, int k, int l, int r) {\n        // [a, b) ??¨ [l, r) ??????????????????\n        if (r <= a || b <= l)\n            return 0;\n\n        // [a, b) ??? [l, r) ????????¨???????????§????????°???????????\\?????????\n        if (a <= l && r <= b) {\n            return _data[k];\n        }\n\n        // ????????§???????????°???2 ?????????????????§???\n        auto vl = query(a, b, k * 2 + 1, l, (l + r) / 2);\n        auto vr = query(a, b, k * 2 + 2, (l + r) / 2, r);\n        return max(vl, vr);\n    }\n\n    long query(int a, int b) {\n        return query(a, b, 0, 0, cast(int)(_data.length / 2));\n    }\n}"
  },
  {
    "language": "D",
    "code": "import std.algorithm;\nimport std.array;\nimport std.conv;\nimport std.math;\nimport std.range;\nimport std.stdio;\nimport std.string;\nimport std.typecons;\n\nint readint() {\n    return readln.chomp.to!int;\n}\n\nint[] readints() {\n    return readln.split.map!(to!int).array;\n}\n\nvoid main() {\n    readln;\n    auto xs = readints();\n\n    int n = cast(int) xs.length;\n    auto segTree = new SegmentTree(n + 1);\n    foreach (x; xs) {\n        auto max = segTree.query(1, x);\n        segTree.update(x, x + max);\n    }\n\n    auto max = segTree.query(1, n + 1);\n    writeln(cast(long) n * (n + 1) / 2 - max);\n}\n\nclass SegmentTree {\n    private long[] _data;\n\n    this(int n) {\n        int len = 1;\n        while (len < n)\n            len *= 2;\n\n        _data = new long[len * 2];\n    }\n\n    /// k ?????????????´????(0-indexed)??? a ????????´\n    void update(int k, long a) {\n        // ????????\\???\n        k += (_data.length / 2) - 1;\n        _data[k] = a;\n        // ?????????????????´??°\n        while (k > 0) {\n            k = (k - 1) / 2;\n            _data[k] = max(_data[k * 2 + 1], _data[k * 2 + 2]);\n        }\n    }\n\n    /// [a, b) ???????°????????±???????\n    long query(int a, int b, int k, int l, int r) {\n        // [a, b) ??¨ [l, r) ??????????????????\n        if (r <= a || b <= l)\n            return 0;\n\n        // [a, b) ??? [l, r) ????????¨???????????§????????°???????????\\?????????\n        if (a <= l && r <= b) {\n            return _data[k];\n        }\n\n        // ????????§???????????°???2 ?????????????????§???\n        auto vl = query(a, b, k * 2 + 1, l, (l + r) / 2);\n        auto vr = query(a, b, k * 2 + 2, (l + r) / 2, r);\n        return max(vl, vr);\n    }\n\n    long query(int a, int b) {\n        return query(a, b, 0, 0, cast(int)(_data.length / 2));\n    }\n}"
  },
  {
    "language": "D",
    "code": "import std.algorithm;\nimport std.array;\nimport std.conv;\nimport std.math;\nimport std.range;\nimport std.stdio;\nimport std.string;\nimport std.typecons;\n\nint readint() {\n    return readln.chomp.to!int;\n}\n\nint[] readints() {\n    return readln.split.map!(to!int).array;\n}\n\nvoid main() {\n    readln;\n    auto xs = readints();\n\n    int n = cast(int) xs.length;\n    auto segTree = new SegmentTree(n + 1);\n    foreach (x; xs) {\n        int max = segTree.query(1, x);\n        segTree.update(x, x + max);\n    }\n\n    auto max = segTree.query(1, n + 1);\n    writeln(n * (n + 1) / 2 - max);\n}\n\nclass SegmentTree {\n    private int[] _data;\n\n    this(int n) {\n        int len = 1;\n        while (len < n)\n            len *= 2;\n\n        _data = new int[len * 2];\n    }\n\n    /// k ?????????????´????(0-indexed)??? a ????????´\n    void update(int k, int a) {\n        // ????????\\???\n        k += (_data.length / 2) - 1;\n        _data[k] = a;\n        // ?????????????????´??°\n        while (k > 0) {\n            k = (k - 1) / 2;\n            _data[k] = max(_data[k * 2 + 1], _data[k * 2 + 2]);\n        }\n    }\n\n    /// [a, b) ???????°????????±???????\n    int query(int a, int b, int k, int l, int r) {\n        // [a, b) ??¨ [l, r) ??????????????????\n        if (r <= a || b <= l)\n            return 0;\n\n        // [a, b) ??? [l, r) ????????¨???????????§????????°???????????\\?????????\n        if (a <= l && r <= b) {\n            return _data[k];\n        }\n\n        // ????????§???????????°???2 ?????????????????§???\n        int vl = query(a, b, k * 2 + 1, l, (l + r) / 2);\n        int vr = query(a, b, k * 2 + 2, (l + r) / 2, r);\n        return max(vl, vr);\n    }\n\n    int query(int a, int b) {\n        return query(a, b, 0, 0, cast(int)(_data.length / 2));\n    }\n}"
  },
  {
    "language": "D",
    "code": "import std.algorithm;\nimport std.array;\nimport std.conv;\nimport std.math;\nimport std.range;\nimport std.stdio;\nimport std.string;\nimport std.typecons;\n\nint readint() {\n    return readln.chomp.to!int;\n}\n\nint[] readints() {\n    return readln.split.map!(to!int).array;\n}\n\nvoid main() {\n    readln;\n    auto xs = readints();\n\n    int n = cast(int) xs.length;\n    auto segTree = new SegmentTree(n + 1);\n    foreach (x; xs) {\n        auto max = segTree.query(1, x);\n        segTree.update(x, x + max);\n    }\n\n    auto max = segTree.query(1, n + 1);\n    writeln(n * (n + 1) / 2 - max);\n}\n\nclass SegmentTree {\n    private long[] _data;\n\n    this(int n) {\n        int len = 1;\n        while (len < n)\n            len *= 2;\n\n        _data = new long[len * 2];\n    }\n\n    /// k ?????????????´????(0-indexed)??? a ????????´\n    void update(int k, long a) {\n        // ????????\\???\n        k += (_data.length / 2) - 1;\n        _data[k] = a;\n        // ?????????????????´??°\n        while (k > 0) {\n            k = (k - 1) / 2;\n            _data[k] = max(_data[k * 2 + 1], _data[k * 2 + 2]);\n        }\n    }\n\n    /// [a, b) ???????°????????±???????\n    long query(int a, int b, int k, int l, int r) {\n        // [a, b) ??¨ [l, r) ??????????????????\n        if (r <= a || b <= l)\n            return 0;\n\n        // [a, b) ??? [l, r) ????????¨???????????§????????°???????????\\?????????\n        if (a <= l && r <= b) {\n            return _data[k];\n        }\n\n        // ????????§???????????°???2 ?????????????????§???\n        auto vl = query(a, b, k * 2 + 1, l, (l + r) / 2);\n        auto vr = query(a, b, k * 2 + 2, (l + r) / 2, r);\n        return max(vl, vr);\n    }\n\n    long query(int a, int b) {\n        return query(a, b, 0, 0, cast(int)(_data.length / 2));\n    }\n}"
  },
  {
    "language": "D",
    "code": "import std.algorithm;\nimport std.array;\nimport std.conv;\nimport std.math;\nimport std.range;\nimport std.stdio;\nimport std.string;\nimport std.typecons;\n\nint readint() {\n    return readln.chomp.to!int;\n}\n\nint[] readints() {\n    return readln.split.map!(to!int).array;\n}\n\nvoid main() {\n    readln;\n    auto xs = readints();\n\n    int n = cast(int) xs.length;\n    auto segTree = new SegmentTree(n + 1);\n    foreach (x; xs) {\n        auto max = segTree.query(1, x);\n        segTree.update(x, x + max);\n    }\n\n    auto max = segTree.query(1, n + 1);\n    writeln(cast(long) n * (n + 1) / 2 - max);\n}\n\nclass SegmentTree {\n    private int[] _data;\n\n    this(int n) {\n        int len = 1;\n        while (len < n)\n            len *= 2;\n\n        _data = new int[len * 2];\n    }\n\n    /// k ?????????????´????(0-indexed)??? a ????????´\n    void update(int k, int a) {\n        // ????????\\???\n        k += (_data.length / 2) - 1;\n        _data[k] = a;\n        // ?????????????????´??°\n        while (k > 0) {\n            k = (k - 1) / 2;\n            _data[k] = max(_data[k * 2 + 1], _data[k * 2 + 2]);\n        }\n    }\n\n    /// [a, b) ???????°????????±???????\n    int query(int a, int b, int k, int l, int r) {\n        // [a, b) ??¨ [l, r) ??????????????????\n        if (r <= a || b <= l)\n            return 0;\n\n        // [a, b) ??? [l, r) ????????¨???????????§????????°???????????\\?????????\n        if (a <= l && r <= b) {\n            return _data[k];\n        }\n\n        // ????????§???????????°???2 ?????????????????§???\n        auto vl = query(a, b, k * 2 + 1, l, (l + r) / 2);\n        auto vr = query(a, b, k * 2 + 2, (l + r) / 2, r);\n        return max(vl, vr);\n    }\n\n    int query(int a, int b) {\n        return query(a, b, 0, 0, cast(int)(_data.length / 2));\n    }\n}"
  },
  {
    "language": "D",
    "code": "import std.algorithm;\nimport std.array;\nimport std.conv;\nimport std.math;\nimport std.range;\nimport std.stdio;\nimport std.string;\nimport std.typecons;\n\nint readint() {\n    return readln.chomp.to!int;\n}\n\nint[] readints() {\n    return readln.split.map!(to!int).array;\n}\n\nvoid main() {\n    readln;\n    auto xs = readints();\n\n    int n = cast(int) xs.length;\n    auto segTree = new SegmentTree(n + 1);\n    foreach (x; xs) {\n        int max = segTree.query(1, x);\n        segTree.update(x, x + max);\n    }\n\n    auto max = segTree.query(1, n);\n    writeln(n * (n + 1) / 2 - max);\n}\n\nclass SegmentTree {\n    private int[] _data;\n\n    this(int n) {\n        int len = 1;\n        while (len < n)\n            len *= 2;\n\n        _data = new int[len * 2];\n    }\n\n    /// k ?????????????´????(0-indexed)??? a ????????´\n    void update(int k, int a) {\n        // ????????\\???\n        k += (_data.length / 2) - 1;\n        _data[k] = a;\n        // ?????????????????´??°\n        while (k > 0) {\n            k = (k - 1) / 2;\n            _data[k] = max(_data[k * 2 + 1], _data[k * 2 + 2]);\n        }\n    }\n\n    /// [a, b) ???????°????????±???????\n    int query(int a, int b, int k, int l, int r) {\n        // [a, b) ??¨ [l, r) ??????????????????\n        if (r <= a || b <= l)\n            return 0;\n\n        // [a, b) ??? [l, r) ????????¨???????????§????????°???????????\\?????????\n        if (a <= l && r <= b) {\n            return _data[k];\n        }\n\n        // ????????§???????????°???2 ?????????????????§???\n        int vl = query(a, b, k * 2 + 1, l, (l + r) / 2);\n        int vr = query(a, b, k * 2 + 2, (l + r) / 2, r);\n        return max(vl, vr);\n    }\n\n    int query(int a, int b) {\n        return query(a, b, 0, 0, cast(int)(_data.length / 2));\n    }\n}"
  },
  {
    "language": "D",
    "code": "import std.stdio;\nimport std.string;\nimport std.conv;\nimport std.array;\nimport std.range;\nimport std.typecons;\nimport std.algorithm;\n\nstruct RMQSegmentTree(string gstr){\n\tint[] data;\n\tint height;\n\tint initvalue;\n\n\tbool greater(int a,int b){\n\t\tbool ret;\n\t\tmixin(\"ret = \"~gstr~\";\");\n\t\treturn ret;\n\t}\n\n\tint greatValue(int a,int b){\n\t\tif(greater(a,b))\n\t\t\treturn a;\n\t\treturn b;\n\t}\n\n\tvoid SetSize(int size){\n\t\tint s = 1;\n\t\theight = 0;\n\t\twhile(s<size){\n\t\t\ts*=2;\n\t\t\t++height;\n\t\t}\n\t\tdata = new int[s*2];\n\t\tinitvalue = 1000000000 - greatValue(1000000000,0);\n\t\tdata[] = initvalue;\n\t}\n\n\tint GetIdx(int idx,int depth){\n\t\tint blocksize = 1<<depth;\n\t\treturn blocksize-1+(idx/blocksize)*blocksize*2;\n\t}\n\n\tvoid SetData(int idx,int value,int depth = 0){\n\t\tif(depth > height)\n\t\t\treturn;\n\t\tint gi = GetIdx(idx,depth);\n\t\tif(greater(value,data[gi])){\n\t\t\tdata[gi] = value;\n\t\t\tSetData(idx,value,depth+1);\n\t\t}\n\t}\n\n\tint GetRMQ(int begin,int end,int depth = -1){\n\t\tif(depth == -1)\n\t\t\tdepth = height;\n\t\tif(begin == end)\n\t\t\treturn initvalue;\n\t\tint blocksize = 1<<depth;\n\t\tint start = begin - begin%blocksize;\n\t\tif(start == begin && start + blocksize == end)\n\t\t\treturn data[GetIdx(begin,depth)];\n\t\tblocksize /= 2;\n\t\tint ret = initvalue;\n\t\tif(begin < start + blocksize)\n\t\t\tret = greatValue(ret, GetRMQ(begin,min(start + blocksize, end), depth-1));\n\t\tif(end > start + blocksize)\n\t\t\tret = greatValue(ret, GetRMQ(max(begin,start + blocksize), end, depth-1));\n\t\treturn ret;\n\t}\n}\n\nint[] rdi(){\n\treturn readln.split.map!(to!int).array;\n}\n\nvoid main(){\n\tint n= rdi[0];\n\tint[] w;\n\tw = rdi;\n\tRMQSegmentTree!\"a>b\" st;\n\tst.SetSize(n);\n\tint[] dp = new int[n];\n\tdp[] = 0;\n\tforeach(i;0..n){\n\t\tdp[i] = st.GetRMQ(0,w[i]);\n\t\tdp[i] += w[i];\n\t\tst.SetData(w[i]-1,dp[i]);\n\t}\n\tint res = 0;\n\tforeach(i;0..n){\n\t\tres += w[i];\n\t}\n\tint md = 0;\n\tforeach(i;0..n){\n\t\tmd = max(md,dp[i]);\n\t}\n\t(res-md).writeln;\n}"
  },
  {
    "language": "Python",
    "code": "#!/usr/bin/env python\n# -*- coding: utf-8 -*-\n\n# st = SegmentTree(n, lambda a,b: a if a > b else b)\nclass SegmentTree:\n    def __init__(self,n,f):\n        self.N = 1\n        self.f = f\n        while(self.N < n):\n            self.N *= 2\n        self.seg = [0] * (self.N * 2 -1)\n\n    def _update(self,k,a,f):\n        k += self.N - 1\n        self.seg[k] = a\n\n        while(0 < k):\n            k = (k-1)//2;\n            self.seg[k] = self.f(self.seg[2*k +1], self.seg[2*k + 2])\n\n    def _query(self,a, b, k, l, r,f):\n        if r <= a or b <= l:\n            return 0\n        if a <= l and r <= b:\n            return self.seg[k]\n        else:\n            vl = self._query(a, b, k * 2 + 1, l, (l + r)//2,f)\n            vr = self._query(a, b, k * 2 + 2, (l + r)//2, r,f)\n            return self.f(vl,vr)\n    \n    def query(self, a, b):\n        return self._query(a, b, 0, 0, self.N, self.f)\n    \n    def update(self, k ,a):\n        return self._update(k, a, self.f)\n\nn = int(input())\nX = list(map(int,input().split()))\nst = SegmentTree(n+1, lambda a,b: a if b < a else b)\n\nfor x in X:\n    st.update(x, st.query(0,x) + x)\nprint((n * (n + 1))//2 - st.query(0,n+1))"
  },
  {
    "language": "Python",
    "code": "import math\nimport sys\nif sys.version[0] == '2':\n    range, input = xrange, raw_input\n\n\nclass FenwickTree:\n    def __init__(self, a_list, f, default):\n        # 0-indexed\n        self.N = len(a_list)\n        self.bit = a_list[:]\n        self.f = f\n        self.default = default\n        for _ in range(self.N, 1 << int(math.ceil(math.log(self.N, 2)))):\n            self.bit.append(self.default)\n        for i in range(self.N - 1):\n            self.bit[i | (i + 1)] = self.f(self.bit[i | (i + 1)], self.bit[i])\n\n    def update(self, i, val):\n        while i < self.N:\n            self.bit[i] = self.f(self.bit[i], val)\n            i |= i + 1\n\n    def query(self, n):\n        # [0, n]\n        ret = 0\n        while n >= 0:\n            ret = self.f(ret, self.bit[n])\n            n = (n & (n + 1)) - 1\n        return ret\n\n\nN = int(input())\nX = [int(x) for x in input().split()]\ndp = FenwickTree([0] * N, lambda x, y: max(x, y), 0)\nfor x in X:\n    dp.update(x - 1, dp.query(x - 1) + x)\nprint(N * (N + 1) // 2 - dp.query(N - 1))"
  },
  {
    "language": "Python",
    "code": "class RMQ:\n    inf = 0\n    def __init__(self,n_):\n        self.n_ = n_\n        self.n = 1\n        while self.n < n_: self.n*=2\n        self.st = [self.inf]*(2*self.n-1)\n    \n    def update(self,k,x):\n        k+=(self.n-1)\n        self.st[k] = x\n        while k >0:\n            k = (k-1)//2\n            self.st[k] = max(self.st[2*k+1],self.st[2*k+2])\n\n    def search(self,a,b,k,l,r):\n        if r<=a or b<=l :return self.inf\n        if a<=l and r<=b:return self.st[k]\n        L = self.search(a,b,k*2+1,l,(l+r)//2)\n        R = self.search(a,b,k*2+2,(l+r)//2,r)\n        return max(L,R)\n\n    def query(self,a,b):\n        return self.search(a,b,0,0,self.n)\n\nn = int(input())\nx = list(map(int,input().split()))\nrmq = RMQ(n+1)\nfor i in x:\n    res = rmq.query(1,i)\n    rmq.update(i,i+res)\nprint (sum(x)-rmq.query(1,n+1))\n\n\n"
  },
  {
    "language": "Python",
    "code": "class RangeMaximumQuery:\n    def __init__(self, n):\n        self.size = n\n        self.dat = [0] * (2 * n - 1)\n    \n    def update(self, i, x):\n        i += self.size - 1\n        self.dat[i] = x\n        while i > 0:\n            i = (i - 1) // 2\n            d1 = self.dat[i * 2 + 1]\n            d2 = self.dat[i * 2 + 2]\n            if d1 > d2:\n                self.dat[i] = d1\n            else:\n                self.dat[i] = d2\n    \n    def getmax(self, a, b, k, l, r):\n        if r <= a or b <= l:\n            return 0\n        elif a <= l and r <= b:\n            return self.dat[k]\n        else:\n            vl = self.getmax(a, b, k * 2 + 1, l, (l + r) // 2)\n            vr = self.getmax(a, b, k * 2 + 2, (l + r) // 2, r)\n            if vl > vr:\n                return vl\n            else:\n                return vr\n\ndef solve():\n    from math import ceil, log\n    \n    n = int(input())\n    A = map(int, input().split())\n    s = 2 ** ceil(log(n, 2))\n    W = RangeMaximumQuery(s)\n    for a_i in A:\n        cost = W.getmax(0, a_i - 1, 0, 0, s) + a_i\n        W.update(a_i - 1, cost)\n    ans = n * (n + 1) // 2 - W.getmax(0, n, 0, 0, s)\n    print(ans)\n\nsolve()\n"
  },
  {
    "language": "Python",
    "code": "import math\nimport sys\nif sys.version[0] == '2':\n    range, input = xrange, raw_input\n\n\nclass FenwickTree:\n    def __init__(self, a_list, f, default):\n        # 0-indexed\n        self.N = len(a_list)\n        self.bit = a_list[:]\n        self.f = f\n        self.default = default\n        for _ in range(self.N, 1 << int(math.ceil(math.log(self.N, 2)))):\n            self.bit.append(self.default)\n        for i in range(self.N - 1):\n            self.bit[i | (i + 1)] = self.f(self.bit[i | (i + 1)], self.bit[i])\n\n    def update(self, i, val):\n        while i < self.N:\n            self.bit[i] = self.f(self.bit[i], val)\n            i |= i + 1\n\n    def query(self, n):\n        # [0, n]\n        ret = 0\n        while n >= 0:\n            ret = self.f(ret, self.bit[n])\n            n = (n & (n + 1)) - 1\n        return ret\n\n\nN = int(input())\nX = [int(x) for x in input().split()]\ndp = FenwickTree([0] * N, lambda x, y: max(x, y), 0)\nfor x, i in sorted((x, i) for i, x in enumerate(X)):\n    dp.update(i, dp.query(i) + x)\nprint(N * (N + 1) // 2 - dp.query(N - 1))"
  },
  {
    "language": "Python",
    "code": "import math\nimport sys\nif sys.version[0] == '2':\n    range, input = xrange, raw_input\n\n\nclass FenwickTree:\n    def __init__(self, a_list, f, default):\n        # 0-indexed\n        self.N = len(a_list)\n        self.bit = a_list[:]\n        self.f = f\n        self.default = default\n        for _ in range(self.N, 1 << (math.ceil(math.log(self.N, 2)))):\n            self.bit.append(self.default)\n        for i in range(self.N - 1):\n            self.bit[i | (i + 1)] = self.f(self.bit[i | (i + 1)], self.bit[i])\n\n    def update(self, i, val):\n        while i < self.N:\n            self.bit[i] = self.f(self.bit[i], val)\n            i |= i + 1\n\n    def query(self, n):\n        # [0, n]\n        ret = 0\n        while n >= 0:\n            ret = self.f(ret, self.bit[n])\n            n = (n & (n + 1)) - 1\n        return ret\n\n\nN = int(input())\nX = [int(x) for x in input().split()]\ndp = FenwickTree([0] * N, lambda x, y: max(x, y), 0)\nfor x, i in sorted((x, i) for i, x in enumerate(X)):\n    dp.update(i, dp.query(i) + x)\nprint(N * (N + 1) // 2 - dp.query(N - 1))"
  },
  {
    "language": "Python",
    "code": "def solve():\n    N = int(input())\n    *A, = map(int, input().split())\n\n    data = [0]*(N+1)\n    def update(k, x):\n        while k <= N:\n            data[k] = max(data[k], x)\n            k += k & -k\n    def get(k):\n        s = 0\n        while k:\n            s = max(s, data[k])\n            k -= k & -k\n        return s\n\n    B = [0]*N\n    for i in range(N):\n        B[A[i]-1] = i\n\n    ans = 0\n    for i in range(N):\n        j = B[i]\n        v = get(j+1)\n        update(j+1, v+i+1)\n    print(N*(N+1)//2 - get(N))\nsolve()\n"
  },
  {
    "language": "Python",
    "code": "def solve():\n    n = int(input())\n    dp = [0] * (n + 1)\n    \n    def update(i, x):\n        while i <= n:\n            if dp[i] < x:\n                dp[i] = x\n            i += i & -i\n    \n    def get_sum(i):\n        s = 0\n        while i > 0:\n            t = dp[i]\n            if s < t:\n                s = t\n            i -= i & -i\n        return s\n    \n    A = map(int, input().split())\n    \n    for a_i in A:\n        update(a_i, get_sum(a_i - 1) + a_i)\n    \n    ans = n * (n + 1) // 2 - get_sum(n)\n    print(ans)\n\nsolve()\n"
  },
  {
    "language": "Python",
    "code": "import math\n\n\nclass SegmentTree:\n    \"\"\"\n    Segment Tree\n    query:\n    1. update(i, val): update i-th value to val\n    2. query(low, high): find f(value) in [low, high)\n    time complexity: O(log n)\n    space complexity: O(2n)\n    \"\"\"\n    def __init__(self, N, f, default):\n        self.N = 1 << math.ceil(math.log(N, 2))\n        self.default = default\n        self.f = f\n        self.segtree = [self.default] * (self.N * 2 - 1)\n\n    def update(self, i, val):\n        i += self.N - 1\n        self.segtree[i] = val\n        while i > 0:\n            i = (i - 1) // 2\n            self.segtree[i] = self.f(self.segtree[2*i+1], self.segtree[2*i+2])\n\n    def query(self, low, high, k=0, left=0, right=-1):\n        if right == -1:\n            right = self.N\n        if right <= low or high <= left:\n            return self.default\n\n        if low <= left and right <= high:\n            return self.segtree[k]\n        else:\n            mid = (left + right) // 2\n            return self.f(self.query(low, high, 2*k+1, left, mid),\n                          self.query(low, high, 2*k+2, mid, right))\n\n\nN = int(input())\nX = [int(x) for x in input().split()]\ndp = SegmentTree(N, lambda x, y: max(x, y), 0)\nfor x, i in sorted((x, i) for i, x in enumerate(X)):\n    dp.update(i, dp.query(0, i) + x)\nprint(N * (N + 1) // 2 - dp.query(0, N))"
  },
  {
    "language": "Python",
    "code": "import math\nimport sys\nif sys.version[0] == '2':\n    range, input = xrange, raw_input\n\n\nclass FenwickTree:\n    def __init__(self, a_list, f, default):\n        # 0-indexed\n        self.N = len(a_list)\n        self.bit = a_list[:]\n        self.f = f\n        self.default = default\n        for _ in range(self.N, 1 << int(math.ceil(math.log(self.N, 2)))):\n            self.bit.append(self.default)\n        for i in range(self.N - 1):\n            self.bit[i | (i + 1)] = self.f(self.bit[i | (i + 1)], self.bit[i])\n\n    def update(self, i, val):\n        while i < self.N:\n            self.bit[i] = self.f(self.bit[i], val)\n            i |= i + 1\n\n    def query(self, n):\n        # [0, n]\n        ret = 0\n        while n >= 0:\n            ret = self.f(ret, self.bit[n])\n            n = (n & (n + 1)) - 1\n        return ret\n\n\nN = int(input())\nX = [int(x) for x in input().split()]\ndp = FenwickTree([0] * N, lambda x, y: max(x, y), 0)\nfor x in X:\n    dp.update(x - 1, dp.query(x - 1) + x)\nprint(N * (N + 1) // 2 - dp.query(N - 1))"
  },
  {
    "language": "Python",
    "code": "import math\n\n\nclass FenwickTree:\n    def __init__(self, a_list, f, default):\n        # 0-indexed\n        self.N = len(a_list)\n        self.bit = a_list[:]\n        self.f = f\n        self.default = default\n        for _ in range(self.N, 1 << (math.ceil(math.log(self.N, 2)))):\n            self.bit.append(self.default)\n        for i in range(self.N - 1):\n            self.bit[i | (i + 1)] = self.f(self.bit[i | (i + 1)], self.bit[i])\n\n    def update(self, i, val):\n        while i < self.N:\n            self.bit[i] = self.f(self.bit[i], val)\n            i |= i + 1\n\n    def query(self, n):\n        # [0, n]\n        ret = 0\n        while n >= 0:\n            ret = self.f(ret, self.bit[n])\n            n = (n & (n + 1)) - 1\n        return ret\n\n\nN = int(input())\nX = [int(x) for x in input().split()]\ndp = FenwickTree([0] * N, lambda x, y: max(x, y), 0)\nfor x, i in sorted((x, i) for i, x in enumerate(X)):\n    dp.update(i, dp.query(i) + x)\nprint(N * (N + 1) // 2 - dp.query(N - 1))"
  },
  {
    "language": "Python",
    "code": "#!/usr/bin/env python\n# -*- coding: utf-8 -*-\n\n# segment tree\nclass SegmentTree:\n    def _max(self,a,b):\n        if a < b:\n            return b\n        else:\n            return a\n\n    def __init__(self,n):\n        self.N = 1\n        while(self.N < n):\n            self.N *= 2\n        self.seg = [0] * (self.N * 2 -1)\n\n    def max_update(self,k,a):\n        k += self.N - 1\n        self.seg[k] = a\n\n        while(0 < k):\n            k = (k-1)//2;\n            self.seg[k] = self._max(self.seg[2*k +1], self.seg[2*k + 2])\n\n    def _max_query(self,a, b, k, l, r):\n        if r <= a or b <= l:\n            return 0\n        if a <= l and r <= b:\n            return self.seg[k]\n        else:\n            vl = self._max_query(a, b, k * 2 + 1, l, (l + r)//2)\n            vr = self._max_query(a, b, k * 2 + 2, (l + r)//2, r)\n            return self._max(vl,vr)\n\n    def max_query(self,a, b):\n        return self._max_query(a, b, 0, 0, self.N)\n\nn = int(input())\nX = list(map(int,input().split()))\nst = SegmentTree(n+1)\n\nfor x in X:\n    st.max_update(x, st.max_query(0,x) + x)\nprint((n * (n + 1))//2 - st.max_query(0,n+1))"
  },
  {
    "language": "Python",
    "code": "import math\n\n\nclass RangeMaximumQuery:\n    \"\"\"\n    RangeMaximumQuery by Segment Tree\n    query:\n    1. update(i, val): update i-th value to val\n    2. query(low, high): find maximun value in [low, high)\n    time complexity: O(log n)\n    space complexity: O(2n)\n    \"\"\"\n    def __init__(self, N, zero=0):\n        self.N = 1 << math.ceil(math.log(N, 2))\n        self.zero = zero\n        self.segtree = [self.zero] * (self.N * 2 - 1)\n\n    def update(self, i, val):\n        i += self.N - 1\n        self.segtree[i] = val\n        while i > 0:\n            i = (i - 1) // 2\n            self.segtree[i] = max(self.segtree[2*i+1], self.segtree[2*i+2])\n\n    def query(self, low, high, k=0, left=0, right=-1):\n        if right == -1:\n            right = self.N\n        if right <= low or high <= left:\n            return self.zero\n\n        if low <= left and right <= high:\n            return self.segtree[k]\n        else:\n            mid = (left + right) // 2\n            return max(self.query(low, high, 2*k+1, left, mid),\n                       self.query(low, high, 2*k+2, mid, right))\n\nN = int(input())\nX = [int(x) for x in input().split()]\ndp = RangeMaximumQuery(N)\nfor x, i in sorted((x, i) for i, x in enumerate(X)):\n    dp.update(i, dp.query(0, i) + x)\nprint(N * (N + 1) // 2 - dp.query(0, N))"
  },
  {
    "language": "Python",
    "code": "import math\nimport sys\nif sys.version[0] == '2':\n    range, input = xrange, raw_input\n\n\nclass FenwickTree:\n    def __init__(self, a_list, f, default):\n        # 0-indexed\n        self.N = len(a_list)\n        self.bit = a_list[:]\n        self.f = f\n        self.default = default\n        for _ in range(self.N, 1 << int(math.ceil(math.log(self.N, 2)))):\n            self.bit.append(self.default)\n        for i in range(self.N - 1):\n            self.bit[i | (i + 1)] = self.f(self.bit[i | (i + 1)], self.bit[i])\n\n    def update(self, i, val):\n        while i < self.N:\n            self.bit[i] = self.f(self.bit[i], val)\n            i |= i + 1\n\n    def query(self, n):\n        # [0, n]\n        ret = 0\n        while n >= 0:\n            ret = self.f(ret, self.bit[n])\n            n = (n & (n + 1)) - 1\n        return ret\n\n\nN = int(input())\nX = [int(x) for x in input().split()]\ndp = FenwickTree([0] * N, lambda x, y: max(x, y), 0)\nfor x, i in sorted((x, i) for i, x in enumerate(X)):\n    dp.update(i, dp.query(i) + x)\nprint(N * (N + 1) // 2 - dp.query(N - 1))"
  },
  {
    "language": "Python",
    "code": "import math,string,itertools,fractions,heapq,collections,re,array,bisect,sys,random,time,copy,functools\n\nsys.setrecursionlimit(10**7)\ninf = 10**20\neps = 1.0 / 10**13\nmod = 10**9+7\ndd = [(-1,0),(0,1),(1,0),(0,-1)]\nddn = [(-1,0),(-1,1),(0,1),(1,1),(1,0),(1,-1),(0,-1),(-1,-1)]\n\ndef LI(): return [int(x) for x in sys.stdin.readline().split()]\ndef LI_(): return [int(x)-1 for x in sys.stdin.readline().split()]\ndef LF(): return [float(x) for x in sys.stdin.readline().split()]\ndef LS(): return sys.stdin.readline().split()\ndef I(): return int(sys.stdin.readline())\ndef F(): return float(sys.stdin.readline())\ndef S(): return input()\ndef pf(s): return print(s, flush=True)\n\nclass Seg():\n    def __init__(self, na, default, func):\n        if isinstance(na, list):\n            n = len(na)\n        else:\n            n = na\n        i = 1\n        while 2**i <= n:\n            i += 1\n        self.D = default\n        self.H = i\n        self.N = 2**i\n        if isinstance(na, list):\n            self.A = [default] * (self.N) + na + [default] * (self.N-n)\n            for i in range(self.N-1,0,-1):\n                self.A[i] = func(self.A[i*2], self.A[i*2+1])\n        else:\n            self.A = [default] * (self.N*2)\n        self.F = func\n\n    def find(self, i):\n        return self.A[i + self.N]\n\n    def update(self, i, x):\n        i += self.N\n        self.A[i] = x\n        while i > 1:\n            i = i // 2\n            self.A[i] = self.merge(self.A[i*2], self.A[i*2+1])\n\n    def merge(self, a, b):\n        return self.F(a, b)\n\n    def total(self):\n        return self.A[1]\n\n    def query(self, a, b):\n        A = self.A\n        l = a + self.N\n        r = b + self.N\n        res = self.D\n        while l < r:\n            if l % 2 == 1:\n                res = self.merge(res, A[l])\n                l += 1\n            if r % 2 == 1:\n                r -= 1\n                res = self.merge(res, A[r])\n            l >>= 1\n            r >>= 1\n\n        return res\n\ndef main():\n    rr = []\n\n    def f(n):\n        a = LI()\n        seg = Seg(n, 0, max)\n        for c in a:\n            t = seg.query(0,c)\n            seg.update(c, t+c)\n        r = sum(a) - seg.total()\n        return r\n\n    while 1:\n        n = I()\n        if n == 0:\n            break\n        rr.append(f(n))\n        break\n\n    return '\\n'.join(map(str,rr))\n\n\nprint(main())\n\n"
  },
  {
    "language": "Python",
    "code": "def solve():\n    n = int(input())\n    A = map(int, input().split())\n    W = [0] * (n + 1)\n    for a_i in A:\n        W[a_i] = max(W[:a_i]) + a_i\n    ans = n * (n + 1) // 2 - max(W)\n    print(ans)\n\nsolve()\n"
  },
  {
    "language": "Rust",
    "code": "#[allow(unused_imports)]\nuse std::cmp::*;\n#[allow(unused_imports)]\nuse std::collections::*;\nuse std::io::Read;\n#[allow(dead_code)]\nfn getline() -> String {\n    let mut ret = String::new();\n    std::io::stdin().read_line(&mut ret).ok().unwrap();\n    ret\n}\nfn get_word() -> String {\n    let mut stdin = std::io::stdin();\n    let mut u8b: [u8; 1] = [0];\n    loop {\n        let mut buf: Vec<u8> = Vec::with_capacity(16);\n        loop {\n            let res = stdin.read(&mut u8b);\n            if res.unwrap_or(0) == 0 || u8b[0] <= b' ' {\n                break;\n            } else {\n                buf.push(u8b[0]);\n            }\n        }\n        if buf.len() >= 1 {\n            let ret = String::from_utf8(buf).unwrap();\n            return ret;\n        }\n    }\n}\n \n#[allow(dead_code)]\nfn get<T: std::str::FromStr>() -> T { get_word().parse().ok().unwrap() }\n/**\n * Segment Tree. This data structure is useful for fast folding on intervals of an array\n * whose elements are elements of monoid I. Note that constructing this tree requires the identity\n * element of I and the operation of I.\n * Verified by: yukicoder No. 259 (http://yukicoder.me/submissions/100581)\n *              AGC015-E (http://agc015.contest.atcoder.jp/submissions/1461001)\n */\nstruct SegTree<I, BiOp> {\n    n: usize,\n    dat: Vec<I>,\n    op: BiOp,\n    e: I,\n}\n \nimpl<I, BiOp> SegTree<I, BiOp>\n    where BiOp: Fn(I, I) -> I,\n          I: Copy {\n    pub fn new(n_: usize, op: BiOp, e: I) -> Self {\n        let mut n = 1;\n        while n < n_ { n *= 2; } // n is a power of 2\n        SegTree {n: n, dat: vec![e; 2 * n - 1], op: op, e: e}\n    }\n    /* ary[k] <- v */\n    pub fn update(&mut self, idx: usize, v: I) {\n        let mut k = idx + self.n - 1;\n        self.dat[k] = v;\n        while k > 0 {\n            k = (k - 1) / 2;\n            self.dat[k] = (self.op)(self.dat[2 * k + 1], self.dat[2 * k + 2]);\n        }\n    }\n    /* [a, b) (note: half-inclusive)\n     * http://proc-cpuinfo.fixstars.com/2017/07/optimize-segment-tree/ */\n    pub fn query(&self, mut a: usize, mut b: usize) -> I {\n        let mut left = self.e;\n        let mut right = self.e;\n        a += self.n - 1;\n        b += self.n - 1;\n        while a < b {\n            if (a & 1) == 0 {\n                left = (self.op)(left, self.dat[a]);\n            }\n            if (b & 1) == 0 {\n                right = (self.op)(self.dat[b - 1], right);\n            }\n            a = a / 2;\n            b = (b - 1) / 2;\n        }\n        (self.op)(left, right)\n    }\n}\n \nconst INF: i64 = 1 << 50;\n \nfn solve() {\n    let n = get();\n    let x: Vec<i64> = (0 .. n).map(|_| get()).collect();\n    let mut st = SegTree::new(n + 1, |x, y| max(x, y), -INF);\n    let mut ma = 0;\n    for &x in &x {\n        let res = max(st.query(1, x as usize), 0);\n        let cur = res + x;\n        ma = max(ma, cur);\n        st.update(x as usize, cur);\n    }\n    for i in 0 .. n {\n        ma -= 1 + i as i64;\n    }\n    println!(\"{}\", -ma);\n}\n \nfn main() {\n    // In order to avoid potential stack overflow, spawn a new thread.\n    let stack_size = 104_857_600; // 100 MB\n    let thd = std::thread::Builder::new().stack_size(stack_size);\n    thd.spawn(|| solve()).unwrap().join().unwrap();\n}\n\n"
  },
  {
    "language": "Rust",
    "code": "extern crate core;\n\nuse std::fmt;\nuse std::cmp::{Ordering, min, max};\nuse std::fmt::{Display, Error, Formatter};\nuse std::f32::MAX;\nuse std::ops::{Add, Sub, Mul, Div, Neg, Index, IndexMut};\nuse std::collections::BTreeMap;\n\nfn show<T: Display>(vec: &Vec<T>) {\n    if vec.is_empty() {\n        println!(\"[]\");\n    }else {\n        print!(\"[{}\", vec[0]);\n        for i in 1 .. vec.len() {\n            print!(\", {}\", vec[i]);\n        }\n        println!(\"]\");\n    }\n}\nfn show2<T: Display>(vec: &Vec<Vec<T>>) {\n    if vec.is_empty() {\n        println!(\"[]\");\n    }else {\n        for l in vec {\n            show(l);\n        }\n    }\n}\nmacro_rules! read_line{\n    () => {{\n        let mut line = String::new();\n        std::io::stdin().read_line(&mut line).ok();\n        line\n    }};\n    (delimiter: ' ') => {\n        read_line!().split_whitespace().map(|x|x.to_string()).collect::<Vec<_>>()\n    };\n    (delimiter: $p:expr) => {\n        read_line!().split($p).map(|x|x.to_string()).collect::<Vec<_>>()\n    };\n    (' ') => {\n        read_line!(delimiter: ' ')\n    };\n    ($delimiter:expr) => {\n        read_line!(delimiter: $delimiter)\n    };\n    (' '; $ty:ty) => {\n        read_line!().split_whitespace().map(|x|x.parse::<$ty>().ok().unwrap()).collect::<Vec<$ty>>()\n    };\n    ($delimiter:expr; $ty:ty) => {\n        read_line!($delimiter).into_iter().map(|x|x.parse::<$ty>().ok().unwrap()).collect::<Vec<$ty>>()\n    };\n}\nmacro_rules! read_value{\n    () => {\n        read_line!().trim().parse().ok().unwrap()\n    }\n}\nmacro_rules! let_all {\n    ($($n:ident:$t:ty),*) => {\n        let line = read_line!(delimiter: ' ');\n        let mut iter = line.iter();\n        $(let $n:$t = iter.next().unwrap().parse().ok().unwrap();)*\n    };\n}\nmacro_rules! let_mut_all {\n    ($($n:ident:$t:ty),*) => {\n        let line = read_line!(delimiter: ' ');\n        let mut iter = line.iter();\n        $(let mut $n:$t = iter.next().unwrap().parse().ok().unwrap();)*\n    };\n}\npub struct MaxFenwickTree {\n    vec: Vec<i64>\n}\nimpl MaxFenwickTree {\n    fn new(size: usize) -> MaxFenwickTree {\n        MaxFenwickTree{vec: vec![0; size]}\n    }\n    fn at(&self, mut index: usize) -> i64 {\n        let mut temp_max = self.vec[index];\n        while index >= !index & (index + 1) {\n            index -= !index & (index + 1);\n            temp_max = max(temp_max, self.vec[index]);\n        }\n        temp_max\n    }\n    fn update(&mut self, mut index: usize, value: i64) -> () {\n        while index < self.vec.len() {\n            self.vec[index] = max(self.vec[index], value);\n            index += !index & (index + 1);\n        }\n    }\n}\n\nfn main() {\n    let_all!(n: usize);\n    let values = read_line!(' '; usize);\n    let mut fenwick_tree = MaxFenwickTree::new(n + 1);\n    for &i in &values {\n        let current_max = fenwick_tree.at(i);\n        fenwick_tree.update(i, current_max + i as i64);\n    }\n    println!(\"{}\", (n as i64 * (n + 1) as i64 / 2) - fenwick_tree.at(n));\n}\n\n"
  }
]