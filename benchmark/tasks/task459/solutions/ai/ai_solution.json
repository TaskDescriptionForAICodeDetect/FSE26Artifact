[
  {
    "model": "claude-3-5-haiku-20241022",
    "prompt_type": "zero_shot",
    "language": "C",
    "code": "#include <stdio.h>\n#include <stdlib.h>\n#include <string.h>\n#include <stdbool.h>\n#include <limits.h>\n\n#define MAX_SAMPLES 1000\n\ntypedef struct {\n    int value;\n    bool is_broken;\n} Sample;\n\nbool can_recover_uniquely(Sample* samples, int n) {\n    for (int i = 0; i < n; i++) {\n        if (!samples[i].is_broken) continue;\n\n        if (i % 2 == 0) {\n            // Even-indexed sample must be greater than neighbors\n            int left_val = (i > 0 && !samples[i-1].is_broken) ? samples[i-1].value : INT_MIN;\n            int right_val = (i < n-1 && !samples[i+1].is_broken) ? samples[i+1].value : INT_MAX;\n\n            if (left_val != INT_MIN && right_val != INT_MAX) {\n                if (left_val >= right_val) return false;\n                samples[i].value = right_val - 1;\n            }\n        } else {\n            // Odd-indexed sample must be less than neighbors\n            int left_val = (i > 0 && !samples[i-1].is_broken) ? samples[i-1].value : INT_MAX;\n            int right_val = (i < n-1 && !samples[i+1].is_broken) ? samples[i+1].value : INT_MIN;\n\n            if (left_val != INT_MAX && right_val != INT_MIN) {\n                if (left_val <= right_val) return false;\n                samples[i].value = left_val - 1;\n            }\n        }\n    }\n\n    return true;\n}\n\nint main() {\n    int n;\n    Sample samples[MAX_SAMPLES];\n    char input[10];\n\n    scanf(\"%d\", &n);\n    for (int i = 0; i < n; i++) {\n        scanf(\"%s\", input);\n        if (input[0] == 'x') {\n            samples[i].is_broken = true;\n            samples[i].value = 0;\n        } else {\n            samples[i].is_broken = false;\n            samples[i].value = atoi(input);\n        }\n    }\n\n    if (can_recover_uniquely(samples, n)) {\n        printf(\"unique\\n\");\n        for (int i = 0; i < n; i++) {\n            printf(\"%d \", samples[i].value);\n        }\n        printf(\"\\n\");\n    } else {\n        printf(\"impossible\\n\");\n    }\n\n    return 0;\n}",
    "timestamp": "2025-08-05 21:45:30"
  },
  {
    "model": "deepseek-v3",
    "prompt_type": "zero_shot",
    "language": "C",
    "code": "#include <stdio.h>\n#include <stdlib.h>\n#include <string.h>\n#include <limits.h>\n\n#define MAX_LEN 1000\n\nint is_possible(char *signal, int *values, int n) {\n    for (int i = 0; i < n; i++) {\n        if (signal[i] == 'x') continue;\n        if (values[i] != signal[i] - '0') return 0;\n    }\n    for (int i = 1; i < n - 1; i++) {\n        if (i % 2 == 1) {\n            if (values[i] >= values[i-1] || values[i] >= values[i+1]) return 0;\n        } else {\n            if (values[i] <= values[i-1] || values[i] <= values[i+1]) return 0;\n        }\n    }\n    if (n > 1) {\n        if (1 % 2 == 1) {\n            if (values[0] >= values[1]) return 0;\n        } else {\n            if (values[0] <= values[1]) return 0;\n        }\n        if ((n-1) % 2 == 1) {\n            if (values[n-1] >= values[n-2]) return 0;\n        } else {\n            if (values[n-1] <= values[n-2]) return 0;\n        }\n    }\n    return 1;\n}\n\nvoid solve(char *signal) {\n    int n = strlen(signal);\n    int *values = (int *)malloc(n * sizeof(int));\n    int *possible = (int *)malloc(n * sizeof(int));\n    memset(possible, 0, n * sizeof(int));\n    int impossible = 0, multiple = 0;\n\n    for (int i = 0; i < n; i++) {\n        if (signal[i] != 'x') {\n            values[i] = signal[i] - '0';\n        } else {\n            int min_val = 0, max_val = 9;\n            if (i > 0 && signal[i-1] != 'x') {\n                if (i % 2 == 1) {\n                    max_val = values[i-1] - 1;\n                } else {\n                    min_val = values[i-1] + 1;\n                }\n            }\n            if (i < n - 1 && signal[i+1] != 'x') {\n                if (i % 2 == 1) {\n                    if (max_val > values[i+1] - 1) {\n                        max_val = values[i+1] - 1;\n                    }\n                } else {\n                    if (min_val < values[i+1] + 1) {\n                        min_val = values[i+1] + 1;\n                    }\n                }\n            }\n            if (min_val > max_val) {\n                impossible = 1;\n                break;\n            }\n            if (min_val == max_val) {\n                values[i] = min_val;\n            } else {\n                possible[i] = 1;\n                multiple = 1;\n            }\n        }\n    }\n\n    if (!impossible) {\n        for (int i = 0; i < n; i++) {\n            if (possible[i]) {\n                int min_val = 0, max_val = 9;\n                if (i > 0) {\n                    if (i % 2 == 1) {\n                        max_val = values[i-1] - 1;\n                    } else {\n                        min_val = values[i-1] + 1;\n                    }\n                }\n                if (i < n - 1) {\n                    if (i % 2 == 1) {\n                        if (max_val > values[i+1] - 1) {\n                            max_val = values[i+1] - 1;\n                        }\n                    } else {\n                        if (min_val < values[i+1] + 1) {\n                            min_val = values[i+1] + 1;\n                        }\n                    }\n                }\n                if (min_val > max_val) {\n                    impossible = 1;\n                    break;\n                }\n                if (min_val != max_val) {\n                    multiple = 1;\n                }\n            }\n        }\n    }\n\n    if (impossible || !is_possible(signal, values, n)) {\n        printf(\"impossible\\n\");\n    } else if (multiple) {\n        printf(\"ambiguous\\n\");\n    } else {\n        for (int i = 0; i < n; i++) {\n            printf(\"%d\", values[i]);\n        }\n        printf(\"\\n\");\n    }\n\n    free(values);\n    free(possible);\n}\n\nint main() {\n    char signal[MAX_LEN + 1];\n    scanf(\"%s\", signal);\n    solve(signal);\n    return 0;\n}",
    "timestamp": "2025-08-05 21:46:30"
  },
  {
    "model": "deepseek-v3",
    "prompt_type": "zero_shot",
    "language": "C++",
    "code": "#include <iostream>\n#include <vector>\n#include <string>\n#include <climits>\n\nusing namespace std;\n\nvoid solve() {\n    string s;\n    cin >> s;\n    int n = s.size();\n    vector<int> samples(n, -1);\n    vector<bool> fixed(n, false);\n\n    for (int i = 0; i < n; ++i) {\n        if (s[i] != 'x') {\n            samples[i] = s[i] - '0';\n            fixed[i] = true;\n        }\n    }\n\n    bool possible = true;\n    bool unique = true;\n\n    for (int i = 0; i < n; ++i) {\n        if (!fixed[i]) {\n            int left = (i > 0) ? samples[i-1] : INT_MIN;\n            int right = (i < n-1) ? samples[i+1] : INT_MIN;\n            int min_val = INT_MIN;\n            int max_val = INT_MAX;\n\n            if (i % 2 == 1) { // odd: must be less than neighbors\n                if (i > 0) {\n                    max_val = samples[i-1] - 1;\n                }\n                if (i < n-1 && fixed[i+1]) {\n                    max_val = min(max_val, samples[i+1] - 1);\n                }\n            } else { // even: must be greater than neighbors\n                if (i > 0) {\n                    min_val = samples[i-1] + 1;\n                }\n                if (i < n-1 && fixed[i+1]) {\n                    min_val = max(min_val, samples[i+1] + 1);\n                }\n            }\n\n            if (min_val > max_val) {\n                possible = false;\n                break;\n            }\n\n            if (min_val == max_val) {\n                samples[i] = min_val;\n                fixed[i] = true;\n            } else {\n                unique = false;\n                samples[i] = min_val; // assign a possible value, but not unique\n            }\n        } else {\n            if (i % 2 == 1) { // odd\n                if (i > 0 && fixed[i-1] && samples[i] >= samples[i-1]) {\n                    possible = false;\n                    break;\n                }\n                if (i < n-1 && fixed[i+1] && samples[i] >= samples[i+1]) {\n                    possible = false;\n                    break;\n                }\n            } else { // even\n                if (i > 0 && fixed[i-1] && samples[i] <= samples[i-1]) {\n                    possible = false;\n                    break;\n                }\n                if (i < n-1 && fixed[i+1] && samples[i] <= samples[i+1]) {\n                    possible = false;\n                    break;\n                }\n            }\n        }\n    }\n\n    if (!possible) {\n        cout << \"None\" << endl;\n    } else if (!unique) {\n        cout << \"Ambiguous\" << endl;\n    } else {\n        for (int num : samples) {\n            cout << num;\n        }\n        cout << endl;\n    }\n}\n\nint main() {\n    solve();\n    return 0;\n}",
    "timestamp": "2025-08-05 21:46:58"
  },
  {
    "model": "deepseek-v3",
    "prompt_type": "zero_shot",
    "language": "Java",
    "code": "import java.util.*;\n\npublic class AudioSignalRecovery {\n    public static void main(String[] args) {\n        Scanner scanner = new Scanner(System.in);\n        String input = scanner.nextLine();\n        String[] samples = input.split(\" \");\n        List<Integer> nums = new ArrayList<>();\n        List<Integer> brokenIndices = new ArrayList<>();\n\n        for (int i = 0; i < samples.length; i++) {\n            if (samples[i].equals(\"x\")) {\n                brokenIndices.add(i);\n            } else {\n                nums.add(Integer.parseInt(samples[i]));\n            }\n        }\n\n        boolean impossible = false;\n        boolean multiple = false;\n\n        for (int index : brokenIndices) {\n            int left = index - 1 >= 0 ? (samples[index - 1].equals(\"x\") ? Integer.MIN_VALUE : Integer.parseInt(samples[index - 1])) : Integer.MIN_VALUE;\n            int right = index + 1 < samples.length ? (samples[index + 1].equals(\"x\") ? Integer.MIN_VALUE : Integer.parseInt(samples[index + 1])) : Integer.MIN_VALUE;\n            boolean isEvenPos = (index + 1) % 2 == 0;\n\n            int min = Integer.MIN_VALUE;\n            int max = Integer.MAX_VALUE;\n\n            if (isEvenPos) {\n                if (left != Integer.MIN_VALUE) {\n                    min = left + 1;\n                }\n                if (right != Integer.MIN_VALUE) {\n                    if (min == Integer.MIN_VALUE) {\n                        min = right + 1;\n                    } else {\n                        min = Math.max(min, right + 1);\n                    }\n                }\n            } else {\n                if (left != Integer.MIN_VALUE) {\n                    max = left - 1;\n                }\n                if (right != Integer.MIN_VALUE) {\n                    if (max == Integer.MAX_VALUE) {\n                        max = right - 1;\n                    } else {\n                        max = Math.min(max, right - 1);\n                    }\n                }\n            }\n\n            if (min != Integer.MIN_VALUE && max != Integer.MAX_VALUE && min > max) {\n                impossible = true;\n                break;\n            }\n\n            if (min == Integer.MIN_VALUE && max == Integer.MAX_VALUE) {\n                multiple = true;\n            } else if (min != Integer.MIN_VALUE && max != Integer.MAX_VALUE && max - min + 1 > 1) {\n                multiple = true;\n            }\n        }\n\n        if (impossible) {\n            System.out.println(\"None\");\n        } else if (multiple) {\n            System.out.println(\"Multiple\");\n        } else {\n            System.out.println(\"Unique\");\n        }\n    }\n}",
    "timestamp": "2025-08-05 21:47:25"
  },
  {
    "model": "claude-3-5-haiku-20241022",
    "prompt_type": "zero_shot",
    "language": "Java",
    "code": "import java.util.*;\n\npublic class AudioSignalRecovery {\n    public static String processSignal(String[] signal) {\n        int n = signal.length;\n        \n        // Convert to array with Integer or null\n        Integer[] processedSignal = new Integer[n];\n        for (int i = 0; i < n; i++) {\n            if (!signal[i].equals(\"x\")) {\n                processedSignal[i] = Integer.parseInt(signal[i]);\n            }\n        }\n        \n        // First pass: check odd-numbered samples\n        for (int i = 1; i < n - 1; i += 2) {\n            if (processedSignal[i] == null) {\n                if (processedSignal[i-1] != null && processedSignal[i+1] != null) {\n                    if (processedSignal[i-1] >= processedSignal[i+1]) {\n                        return \"impossible\";\n                    }\n                    processedSignal[i] = (processedSignal[i-1] + processedSignal[i+1]) / 2;\n                }\n            } else {\n                if (processedSignal[i-1] != null && processedSignal[i+1] != null) {\n                    if (processedSignal[i] >= processedSignal[i-1] || processedSignal[i] >= processedSignal[i+1]) {\n                        return \"impossible\";\n                    }\n                }\n            }\n        }\n        \n        // Second pass: check even-numbered samples\n        for (int i = 2; i < n - 1; i += 2) {\n            if (processedSignal[i] == null) {\n                if (processedSignal[i-1] != null && processedSignal[i+1] != null) {\n                    if (processedSignal[i-1] <= processedSignal[i+1]) {\n                        return \"impossible\";\n                    }\n                    processedSignal[i] = (processedSignal[i-1] + processedSignal[i+1]) / 2;\n                }\n            } else {\n                if (processedSignal[i-1] != null && processedSignal[i+1] != null) {\n                    if (processedSignal[i] <= processedSignal[i-1] || processedSignal[i] <= processedSignal[i+1]) {\n                        return \"impossible\";\n                    }\n                }\n            }\n        }\n        \n        // Check if any samples are still missing\n        boolean allKnown = true;\n        for (Integer sample : processedSignal) {\n            if (sample == null) {\n                allKnown = false;\n                break;\n            }\n        }\n        \n        return allKnown ? \"unique\" : \"multiple\";\n    }\n    \n    public static void main(String[] args) {\n        // Example usage\n        String[] signal1 = {\"1\", \"x\", \"3\", \"x\", \"5\"};\n        String[] signal2 = {\"1\", \"x\", \"2\", \"x\", \"5\"};\n        \n        System.out.println(processSignal(signal1)); // Should print \"unique\"\n        System.out.println(processSignal(signal2)); // Should print \"multiple\"\n    }\n}",
    "timestamp": "2025-08-05 21:47:36"
  },
  {
    "model": "claude-3-5-haiku-20241022",
    "prompt_type": "zero_shot",
    "language": "C++",
    "code": "#include <iostream>\n#include <vector>\n#include <string>\n#include <limits>\n\nusing namespace std;\n\nbool canRecover(vector<string>& samples) {\n    int n = samples.size();\n    \n    // Check initial conditions and recover known constraints\n    for (int i = 0; i < n; i++) {\n        if (samples[i] != \"x\") continue;\n        \n        bool leftDefined = (i > 0 && samples[i-1] != \"x\");\n        bool rightDefined = (i < n-1 && samples[i+1] != \"x\");\n        \n        if (leftDefined && rightDefined) {\n            int left = stoi(samples[i-1]);\n            int right = stoi(samples[i+1]);\n            \n            if (i % 2 == 0) {\n                // Even-indexed samples must be greater than neighbors\n                if (left >= right) return false;\n            } else {\n                // Odd-indexed samples must be less than neighbors\n                if (left <= right) return false;\n            }\n        }\n    }\n    \n    // Attempt to recover values\n    bool changed;\n    do {\n        changed = false;\n        \n        for (int i = 0; i < n; i++) {\n            if (samples[i] != \"x\") continue;\n            \n            bool leftDefined = (i > 0 && samples[i-1] != \"x\");\n            bool rightDefined = (i < n-1 && samples[i+1] != \"x\");\n            \n            if (leftDefined && rightDefined) {\n                int left = stoi(samples[i-1]);\n                int right = stoi(samples[i+1]);\n                \n                if (i % 2 == 0) {\n                    // Even-indexed samples must be greater than neighbors\n                    if (left >= right) return false;\n                    samples[i] = to_string((left + right) / 2 + 1);\n                    changed = true;\n                } else {\n                    // Odd-indexed samples must be less than neighbors\n                    if (left <= right) return false;\n                    samples[i] = to_string((left + right) / 2);\n                    changed = true;\n                }\n            }\n        }\n    } while (changed);\n    \n    // Check if any samples remain unrecovered\n    for (const string& sample : samples) {\n        if (sample == \"x\") return false;\n    }\n    \n    return true;\n}\n\nint main() {\n    int n;\n    cin >> n;\n    \n    vector<string> samples(n);\n    for (int i = 0; i < n; i++) {\n        cin >> samples[i];\n    }\n    \n    if (canRecover(samples)) {\n        cout << \"Unique solution:\" << endl;\n        for (const string& sample : samples) {\n            cout << sample << \" \";\n        }\n        cout << endl;\n    } else {\n        cout << \"Cannot be uniquely recovered\" << endl;\n    }\n    \n    return 0;\n}",
    "timestamp": "2025-08-05 21:47:46"
  },
  {
    "model": "gpt-4o",
    "prompt_type": "zero_shot",
    "language": "python",
    "code": "def process_audio(samples):\n    n = len(samples)\n    if n <= 1:\n        return \"Recovery impossible\"\n\n    def check_valid(sample_list):\n        for i in range(n):\n            if sample_list[i] == 'x':\n                continue\n            if i > 0 and sample_list[i] <= sample_list[i-1] and i % 2 == 0:\n                return False\n            if i < n-1 and sample_list[i] <= sample_list[i+1] and i % 2 == 0:\n                return False\n            if i > 0 and sample_list[i] >= sample_list[i-1] and i % 2 == 1:\n                return False\n            if i < n-1 and sample_list[i] >= sample_list[i+1] and i % 2 == 1:\n                return False\n        return True\n\n    def recover(index):\n        if index == n:\n            return check_valid(samples)\n\n        if samples[index] == 'x':\n            possible_values = []\n            left = samples[index-1] if index > 0 else None\n            right = samples[index+1] if index < n-1 else None\n\n            # Determine valid range of values for current sample\n            if index % 2 == 0:\n                if left is not None:\n                    possible_values.extend(range(left+1, 101))\n                if right is not None:\n                    possible_values.extend(range(right+1, 101))\n            else:\n                if left is not None and left > 0:\n                    possible_values.extend(range(0, left))\n                if right is not None and right > 0:\n                    possible_values.extend(range(0, right))\n\n            # Remove duplicates and sort possible values\n            possible_values = sorted(set(possible_values))\n\n            unique_value = None\n            for value in possible_values:\n                samples[index] = value\n                if recover(index + 1):\n                    if unique_value is None:\n                        unique_value = value\n                    else:\n                        samples[index] = 'x'\n                        return \"Multiple values possible\"\n            samples[index] = 'x'\n            return unique_value is not None\n\n        return recover(index + 1)\n\n    if recover(0):\n        return \"Recovery possible\"\n    else:\n        return \"Recovery impossible\"\n\n# Example usage\nsamples = [\"1\", \"x\", \"3\", \"x\", \"5\"]\nresult = process_audio(samples)\nprint(result)",
    "timestamp": "2025-08-13 07:24:21"
  },
  {
    "model": "gpt-4o",
    "prompt_type": "zero_shot",
    "language": "java",
    "code": "import java.util.*;\nimport java.io.*;\n\npublic class AudioSignalProcessor {\n\n    enum Status {\n        UNIQUE,\n        MULTIPLE,\n        IMPOSSIBLE\n    }\n\n    public static void main(String[] args) {\n        Scanner scanner = new Scanner(System.in);\n        String[] input = scanner.nextLine().split(\" \");\n        int n = input.length;\n        Integer[] signal = new Integer[n];\n\n        for (int i = 0; i < n; i++) {\n            signal[i] = input[i].equals(\"x\") ? null : Integer.parseInt(input[i]);\n        }\n\n        Status result = recoverSignal(signal);\n        System.out.println(result);\n    }\n\n    private static Status recoverSignal(Integer[] signal) {\n        int n = signal.length;\n        List<Integer> unknownIndices = new ArrayList<>();\n        for (int i = 0; i < n; i++) {\n            if (signal[i] == null) {\n                unknownIndices.add(i);\n            }\n        }\n\n        if (unknownIndices.isEmpty()) {\n            return checkSignal(signal) ? Status.UNIQUE : Status.IMPOSSIBLE;\n        }\n\n        Status status = explore(signal, unknownIndices, 0);\n        return status;\n    }\n\n    private static boolean checkSignal(Integer[] signal) {\n        int n = signal.length;\n        for (int i = 0; i < n; i++) {\n            if (i > 0 && i < n - 1) {\n                if ((i % 2 != 0 && !(signal[i] < signal[i - 1] && signal[i] < signal[i + 1])) ||\n                    (i % 2 == 0 && !(signal[i] > signal[i - 1] && signal[i] > signal[i + 1]))) {\n                    return false;\n                }\n            }\n        }\n        return true;\n    }\n\n    private static Status explore(Integer[] signal, List<Integer> unknownIndices, int index) {\n        if (index == unknownIndices.size()) {\n            return checkSignal(signal) ? Status.UNIQUE : Status.IMPOSSIBLE;\n        }\n\n        int pos = unknownIndices.get(index);\n        Set<Integer> possibleValues = new HashSet<>();\n\n        for (int value = 1; value <= 100; value++) {\n            signal[pos] = value;\n            if (checkSignal(signal)) {\n                possibleValues.add(value);\n                if (possibleValues.size() > 1) {\n                    return Status.MULTIPLE;\n                }\n            }\n        }\n\n        if (possibleValues.size() == 0) {\n            return Status.IMPOSSIBLE;\n        }\n\n        signal[pos] = possibleValues.iterator().next();\n        Status nextStatus = explore(signal, unknownIndices, index + 1);\n        if (nextStatus == Status.MULTIPLE) {\n            return Status.MULTIPLE;\n        }\n\n        return Status.UNIQUE;\n    }\n}",
    "timestamp": "2025-08-13 07:24:27"
  },
  {
    "model": "gpt-4o",
    "prompt_type": "zero_shot",
    "language": "c",
    "code": "#include <stdio.h>\n#include <stdlib.h>\n#include <ctype.h>\n\n#define IMPOSSIBLE \"impossible\"\n#define MULTIPLE \"multiple\"\n#define UNIQUE \"unique\"\n\nint isDigitOrX(char c) {\n    return isdigit(c) || c == 'x';\n}\n\nvoid solveSignal(char *signal) {\n    int n = strlen(signal);\n    int values[n];\n\n    for (int i = 0; i < n; i++) {\n        if (isDigitOrX(signal[i]) && signal[i] != 'x') {\n            values[i] = signal[i] - '0';\n        } else {\n            values[i] = -1;  // mark 'x' with -1\n        }\n    }\n\n    int unique = 1;\n    for (int i = 0; i < n; i++) {\n        if (values[i] != -1) continue;\n\n        int lower_bound = 0, upper_bound = 9;\n\n        if (i > 0) {\n            if (i % 2 == 1) {\n                upper_bound = values[i - 1] - 1; \n            } else {\n                lower_bound = values[i - 1] + 1; \n            }\n        }\n        if (i < n - 1) {\n            if (i % 2 == 1) {\n                upper_bound = upper_bound < values[i + 1] - 1 ? upper_bound : values[i + 1] - 1;\n            } else {\n                lower_bound = lower_bound > values[i + 1] + 1 ? lower_bound : values[i + 1] + 1;\n            }\n        }\n\n        if (lower_bound > upper_bound) {\n            printf(IMPOSSIBLE);\n            return;\n        } else if (lower_bound == upper_bound) {\n            values[i] = lower_bound; \n        } else {\n            unique = 0;\n        }\n    }\n\n    printf(\"%s\", unique ? UNIQUE : MULTIPLE);\n}\n\nint main() {\n    char signal[] = \"5x3x\";\n    solveSignal(signal);\n    return 0;\n}",
    "timestamp": "2025-08-13 07:24:32"
  },
  {
    "model": "claude-3-5-haiku-20241022",
    "prompt_type": "zero_shot",
    "language": "python",
    "code": "def can_recover_audio_signal(samples):\n    n = len(samples)\n    \n    # Check if sample list is empty or has only one sample\n    if n <= 1:\n        return \"Unique\"\n    \n    # Replace 'x' placeholders with None for processing\n    samples = [int(x) if x != 'x' else None for x in samples]\n    \n    # Count unknown samples\n    unknown_count = samples.count(None)\n    \n    # Check initial constraints\n    for i in range(n):\n        if samples[i] is not None:\n            # Check odd-numbered samples\n            if i % 2 == 0:\n                if (i > 0 and samples[i-1] is not None and samples[i] >= samples[i-1]) or \\\n                   (i < n-1 and samples[i+1] is not None and samples[i] >= samples[i+1]):\n                    return \"Impossible\"\n            \n            # Check even-numbered samples\n            else:\n                if (i > 0 and samples[i-1] is not None and samples[i] <= samples[i-1]) or \\\n                   (i < n-1 and samples[i+1] is not None and samples[i] <= samples[i+1]):\n                    return \"Impossible\"\n    \n    # If no unique solution is guaranteed\n    if unknown_count > 0:\n        return \"Multiple\"\n    \n    return \"Unique\"",
    "timestamp": "2025-08-13 07:25:00"
  },
  {
    "model": "deepseek-v3",
    "prompt_type": "zero_shot",
    "language": "python",
    "code": "def solve_audio_signal(signal):\n    n = len(signal)\n    for i in range(n):\n        if signal[i] == 'x':\n            continue\n        signal[i] = int(signal[i])\n    \n    for i in range(n):\n        if signal[i] == 'x':\n            continue\n        \n        if i > 0 and signal[i-1] != 'x':\n            if (i % 2 == 1 and signal[i] >= signal[i-1]) or (i % 2 == 0 and signal[i] <= signal[i-1]):\n                return \"None\"\n        \n        if i < n - 1 and signal[i+1] != 'x':\n            if (i % 2 == 1 and signal[i] >= signal[i+1]) or (i % 2 == 0 and signal[i] <= signal[i+1]):\n                return \"None\"\n    \n    for i in range(n):\n        if signal[i] != 'x':\n            continue\n        \n        min_val = -float('inf')\n        max_val = float('inf')\n        \n        if i % 2 == 1:\n            if i > 0:\n                if signal[i-1] != 'x':\n                    max_val = min(max_val, signal[i-1] - 1)\n            if i < n - 1:\n                if signal[i+1] != 'x':\n                    max_val = min(max_val, signal[i+1] - 1)\n        else:\n            if i > 0:\n                if signal[i-1] != 'x':\n                    min_val = max(min_val, signal[i-1] + 1)\n            if i < n - 1:\n                if signal[i+1] != 'x':\n                    min_val = max(min_val, signal[i+1] + 1)\n        \n        if min_val > max_val:\n            return \"None\"\n        \n        if min_val == max_val:\n            signal[i] = min_val\n        else:\n            return \"Ambiguous\"\n    \n    for i in range(n):\n        if signal[i] == 'x':\n            return \"Ambiguous\"\n    \n    for i in range(n):\n        if i > 0:\n            if (i % 2 == 1 and signal[i] >= signal[i-1]) or (i % 2 == 0 and signal[i] <= signal[i-1]):\n                return \"None\"\n        if i < n - 1:\n            if (i % 2 == 1 and signal[i] >= signal[i+1]) or (i % 2 == 0 and signal[i] <= signal[i+1]):\n                return \"None\"\n    \n    return ' '.join(map(str, signal))",
    "timestamp": "2025-08-13 07:25:18"
  },
  {
    "model": "gpt-4o",
    "prompt_type": "zero_shot",
    "language": "c++",
    "code": "#include <iostream>\n#include <vector>\n#include <string>\n#include <limits>\n\nusing namespace std;\n\nbool isRecoverable(const vector<int>& samples, vector<int>& result) {\n    int n = samples.size();\n    \n    for (int i = 0; i < n; ++i) {\n        if (samples[i] != -1) {\n            if (i > 0 && ((i % 2 == 1 && samples[i] >= samples[i - 1]) || (i % 2 == 0 && samples[i] <= samples[i - 1]))) {\n                return false;\n            }\n            if (i < n - 1 && ((i % 2 == 1 && samples[i] >= samples[i + 1]) || (i % 2 == 0 && samples[i] <= samples[i + 1]))) {\n                return false;\n            }\n        }\n    }\n    \n    result = samples;\n    for (int i = 0; i < n; ++i) {\n        if (result[i] == -1) {\n            int left = (i > 0) ? result[i - 1] : numeric_limits<int>::min();\n            int right = (i < n - 1) ? result[i + 1] : numeric_limits<int>::max();\n            \n            if (i % 2 == 1) {\n                result[i] = min(left - 1, right - 1);\n            } else {\n                result[i] = max(left + 1, right + 1);\n            }\n            \n            if (result[i] <= left || result[i] >= right) {\n                return false;\n            }\n        }\n    }\n    \n    for (int i = 0; i < n; ++i) {\n        if (samples[i] == -1) {\n            int left = (i > 0) ? samples[i - 1] : numeric_limits<int>::min();\n            int right = (i < n - 1) ? samples[i + 1] : numeric_limits<int>::max();\n            int possible_value;\n            \n            if (i % 2 == 1) {\n                possible_value = min(left - 1, right - 1);\n            } else {\n                possible_value = max(left + 1, right + 1);\n            }\n\n            if (!(possible_value > left && possible_value < right)) {\n                return false;\n            }\n            \n            samples[i] = possible_value;\n        }\n    }\n\n    return samples == result;\n}\n\nint main() {\n    int n;\n    cin >> n;\n    \n    vector<int> samples(n);\n    \n    for (int i = 0; i < n; ++i) {\n        string temp;\n        cin >> temp;\n        samples[i] = (temp == \"x\") ? -1 : stoi(temp);\n    }\n\n    vector<int> recovery;\n    if (isRecoverable(samples, recovery)) {\n        for (int i = 0; i < n; ++i) {\n            cout << recovery[i] << \" \";\n        }\n        cout << endl;\n    } else {\n        cout << \"Impossible\" << endl;\n    }\n\n    return 0;\n}",
    "timestamp": "2025-08-13 11:38:26"
  }
]