[
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\nusing namespace std;\ntypedef pair < int , int > Pi;\nint main()\n{\n    int N, M;\n    int p, q, r;\n    int x, y;\n    int sizex, sizey;\n    while(cin >> N, N) {\n        vector < Pi > order;\n        cin >> M;\n        cin >> p >> q >> r;\n        order.push_back(Pi(1, N));\n        for(int i = 0; i <= M; i++) {\n            vector < Pi > tempa, tempb, tempc;\n            if(i < M) cin >> x >> y;\n            else x = p - 1, y = q;\n            sizex = x, sizey = y;\n            for(int j = 0; j < order.size(); j++) {\n                if(order[j].second > sizey) {\n                    if(sizex > 0) tempc.push_back(Pi(order[j].first, sizex));\n                    if(sizey > 0) tempb.push_back(Pi(order[j].first + sizex, sizey - sizex));\n                    tempa.push_back(Pi(order[j].first + sizey, order[j].second - sizey));\n                    sizey = sizex = 0;\n                } else if(order[j].second > sizex) {\n                    if(sizex > 0) tempc.push_back(Pi(order[j].first, sizex));\n                    tempb.push_back(Pi(order[j].first + sizex, order[j].second - sizex));\n                    sizey -= order[j].second;\n                    sizex = 0;\n                } else {\n                    tempc.push_back(Pi(order[j].first, order[j].second));\n                    sizey -= order[j].second;\n                    sizex -= order[j].second;\n                }\n            }\n            while(!order.empty()) order.pop_back();\n            for(int j = 0; j < tempa.size(); j++) order.push_back(tempa[j]);\n            for(int j = 0; j < tempb.size(); j++) order.push_back(tempb[j]);\n            for(int j = 0; j < tempc.size(); j++) order.push_back(tempc[j]);\n            if(i == M) {\n                int sum = 0;\n                for(int j = 0; j < tempb.size(); j++) {\n                    sum += max(0, min(r - tempb[j].first + 1, tempb[j].second));                }\n                cout << sum << endl;\n                break;\n            }\n        }\n    }\n    return (0);\n}\n"
  },
  {
    "language": "C++",
    "code": "#include <iostream>\n#include <vector>\n#include <utility>\n#include <algorithm>\n\nusing namespace std;\n\ntypedef pair<int, int> Range; // represents [first, second]\n\nint countOf(const Range &r) {\n    return r.second - r.first + 1;\n}\n\nint check(int R, const Range &r) {\n    if(R < r.first) return 0;\n    if(r.second <= R) return countOf(r);\n    return countOf(r)-countOf(Range(R+1, r.second));\n}\n\nint main() {\n    while(true) {\n        int N;\n        cin >> N;\n        if(!N) break;\n        int M, P, Q, R;\n        cin >> M >> P >> Q >> R;\n\n        vector<Range> cards;\n        cards.push_back(Range(1, N));\n        while(M--) {\n            int x, y;\n            cin >> x >> y;\n\n            vector<Range> next;\n            int cnts[] = {N-y, y-x, x};\n            int cntidx = 0;\n            int end = cards.size();\n            for(int i = cards.size()-1; i >= 0; --i) {\n                int cnt = countOf(cards[i]);\n                if(cnts[cntidx]-cnt <= 0) {\n                    int rem = cnts[cntidx];\n                    next.push_back(Range(cards[i].second-rem+1, cards[i].second));\n                    for(int j = i+1; j < end; ++j) {\n                        if(countOf(cards[j]) > 0) next.push_back(cards[j]);\n                    }\n                    cards[i].second -= rem;\n                    end = i+1;\n                    if(++cntidx == 4) {\n                        break;\n                    }\n                    else {\n                        ++i;\n                        continue;\n                    }\n                }\n                cnts[cntidx] -= cnt;\n            }\n            cards = next;\n        }\n        /*\n        for(int i = 0; i < cards.size(); ++i) {\n            cout << '(' << cards[i].first << \", \" << cards[i].second << ')' << endl;\n        }\n        */\n        int ans = 0;\n        int currCount = 0;\n        for(int i = 0; i < cards.size(); ++i) {\n            int cnt = countOf(cards[i]);\n            if(currCount < P && currCount+cnt >= P) {\n                ans += check(R, Range(max(cards[i].first, cards[i].second-P+1), cards[i].second));\n                //cout << i << ' ' << ans << endl;\n            }\n            else if(currCount < Q && currCount+cnt >= Q) {\n                ans += check(R, Range(cards[i].first, min(cards[i].second, cards[i].first+(Q-currCount-1))));\n                //cout << i << ' ' << ans << endl;\n            }\n            else if(P <= currCount+cnt && currCount+cnt <= Q) {\n                ans += check(R, cards[i]);\n                //cout << i << ' ' << ans << endl;\n            }\n            currCount += cnt;\n        }\n        cout << ans << endl;\n    }\n}"
  },
  {
    "language": "C++",
    "code": "#include<stdio.h>\n#include<string.h>\n#define Max(x,y) ((x>y)?x:y)\ntypedef struct card{\n\tint s,t,n;\n}card;\ncard x[10500],y[10500];\nint main(){\n\tint i,j,n,m,p,q,r,a,b,c,d;//(a,b)cut c,d:absolute point\n\tint xn,yn,e,f,g;//f:flag g:\n\twhile(1){\n\t\tscanf(\"%d\",&n);\n\t\tif(n==0)break;\n\t\tscanf(\"%d%d%d%d\",&m,&p,&q,&r);\n\t\txn=1;\n\t\tx[0]=(card){1,n+1,n};\n\t\twhile(m--){\n\t\t\tscanf(\"%d%d\",&a,&b);\n\t\t\td=n+1;c=d-x[xn-1].n;\n\t\t\tf=0;yn=0;\n\t\t\t//for(i=0;i<xn;i++)printf(\"(%d-%d)\",x[i].s,x[i].t);\n\t\t\t//printf(\"\\n\");\n\t\t\tfor(i=xn-1;i>=0;){\n\t\t\t\t//printf(\"c:%d  d:%d\\n\",c,d);\n\t\t\t\tif(f==0){\n\t\t\t\t\tif(c==b+1){\n\t\t\t\t\t\tfor(j=i;j<xn;j++)y[yn++]=x[j];\n\t\t\t\t\t\tf=1;g=i-1;i--;\n\t\t\t\t\t}else if(c<b+1 && b+1<d){\n\t\t\t\t\t\ty[yn++]=(card){x[i].s+b+1-c,x[i].t,x[i].t-x[i].s-b-1+c};\n\t\t\t\t\t\tfor(j=i+1;j<xn;j++)y[yn++]=x[j];\n\t\t\t\t\t\tx[i]=(card){x[i].s,x[i].s+b+1-c,b+1-c};\n\t\t\t\t\t\t//for(j=0;j<=i;j++)printf(\"(%d-%d)\",x[j].s,x[j].t);\n\t\t\t\t\t\t//printf(\"\\n\");\n\t\t\t\t\t\tf=1;g=i;d=c+x[i].n;\n\t\t\t\t\t\tcontinue;\n\t\t\t\t\t}else i--;\n\t\t\t\t}else{\n\t\t\t\t\tif(c==a+1){\n\t\t\t\t\t\tfor(j=i;j<=g;j++)y[yn++]=x[j];\n\t\t\t\t\t\tfor(j=0;j<i;j++)y[yn++]=x[j];\n\t\t\t\t\t\tbreak;\n\t\t\t\t\t}else if(c<a+1 && a+1<d){\n\t\t\t\t\t\ty[yn++]=(card){x[i].s+a+1-c,x[i].t,x[i].t-x[i].s-a-1+c};\n\t\t\t\t\t\tfor(j=i+1;j<=g;j++)y[yn++]=x[j];\n\t\t\t\t\t\tx[i]=(card){x[i].s,x[i].s+a+1-c,a+1-c};\n\t\t\t\t\t\tfor(j=0;j<=i;j++)y[yn++]=x[j];\n\t\t\t\t\t\tbreak;\n\t\t\t\t\t}else i--;\n\t\t\t\t}\n\t\t\t\td=c;\n\t\t\t\tc=d-x[i].n;\n\t\t\t}\n\t\t\t//for(i=0;i<yn;i++)printf(\"(%d-%d)\",y[i].s,y[i].t);\n\t\t\t//printf(\"\\n\");\n\t\t\tmemcpy(x,y,sizeof(card)*yn);\n\t\t\txn=yn;\n\t\t}\n\t\t//printf(\"\\n\");\n\t\t//for(i=0;i<xn;i++)printf(\"(%d - %d)\",x[i].s,x[i].t);\n\t\t//printf(\"\\n\\n\");\n\t\ta=0;b=1;\n\t\tfor(i=0;i<xn;i++){\n\t\t\t/*if(b<p){\n\t\t\t\tif(q>=b){\n\t\t\t\t\tif(q<b+x[i].n){\n\t\t\t\t\t\ta+=(x[i].s>r)?0:( (r<=x[i].s+q-b)?(r-x[i].s+1):(q-b+1) );\n\t\t\t\t\t\tbreak;\n\t\t\t\t\t}\n\t\t\t\t\telse\n\t\t\t\t\t\ta+=(x[i].s>r)?0:( (r<x[i].t)?(r-x[i].s+1):(x[i].n) );\n\t\t\t\t}\n\t\t\t}else if(b==p){\n\t\t\t\tif(q<b+x[i].n){\n\t\t\t\t\ta+=(x[i].s>r)?0:( (r<=x[i].s+q-p)?(r-x[i].s+1):(q-b+1) );\n\t\t\t\t\tbreak;\n\t\t\t\t}\n\t\t\t\telse\n\t\t\t\t\ta+=(x[i].s>r)?0:( (r<x[i].t)?(r-x[i].s+1):(x[i].n) );\n\t\t\t}else if(b<p && p<b+x[i].n){\n\t\t\t\tif(q<b+x[i].n){\n\t\t\t\t\ta+=(x[i].s+p-b>r)?0:( (r<=x[i].s+q-b)?(r-x[i].s-p+b+1):(q-p+1) );\n\t\t\t\t}\n\t\t\t\telse\n\t\t\t\t\ta+=(x[i].s+p-b>r)?0:( (r<x[i].t)?(r-x[i].s-p+b+1):(x[i].n-p+b) );\n\t\t\t}*/\n\t\t\t//printf(\"%d \",b);\n\t\t\tif(p<b+x[i].n && b<=q){\n\t\t\t\tc=x[i].s;\n\t\t\t\td=x[i].t;\n\t\t\t\tif(b<p)c+=p-b;\n\t\t\t\tif(b+x[i].n>q)d+=q-b-x[i].n+1;\n\t\t\t\tif(d>r)d=r+1;\n\t\t\t\tif(c>r)c=d+1;\n\t\t\t\t//printf(\"%d %d\",c,d);\n\t\t\t\t\n\t\t\t\ta+=Max(0,d-c);\n\t\t\t}\n\t\t\t//printf(\"\\n\");\n\t\t\tb+=x[i].n;\n\t\t}\n\t\tprintf(\"%d\\n\",a);\n\t}\n\treturn 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include <cstdlib>\n#include <iostream>\n#include <utility>\n#include <vector>\nusing namespace std;\n\nint main() {\n\tcin.tie(0);\n\tios::sync_with_stdio(false);\n\n\tfor(int n; cin >> n;) {\n\t\tint m;\n\t\tcin >> m;\n\n\t\tint p, q, r;\n\t\tcin >> p >> q >> r;\n\n\t\tvector<pair<int, bool> > cards;\n\t\tcards.push_back(make_pair(r, true));\n\t\tcards.push_back(make_pair(n - r, false));\n\n\t\tfor(int i = 0; i < m; ++i) {\n\t\t\tint x, y;\n\t\t\tcin >> x >> y;\n\n\t\t\tvector<pair<int, bool> > tmp;\n\t\t\tint j, sum = 0, idxA, idxB, sumA, sumB;\n\t\t\tfor(j = 0;; ++j) {\n\t\t\t\tsum += cards[j].first;\n\t\t\t\tif(sum >= x) {\n\t\t\t\t\tidxA = j;\n\t\t\t\t\tsumA = sum;\n\t\t\t\t\tsum -= cards[j].first;\n\t\t\t\t\tbreak;\n\t\t\t\t}\n\t\t\t}\n\n\t\t\tfor(;; ++j) {\n\t\t\t\tsum += cards[j].first;\n\t\t\t\tif(sum >= y) {\n\t\t\t\t\tidxB = j;\n\t\t\t\t\tsumB = sum;\n\t\t\t\t\tbreak;\n\t\t\t\t}\n\t\t\t}\n\n\t\t\tif(sumB != y) {\n\t\t\t\ttmp.push_back(make_pair(sumB - y, cards[idxB].second));\n\t\t\t\tcards[idxB].first -= sumB - y;\n\n\t\t\t\tif(idxA == idxB)\n\t\t\t\t\tsumA -= sumB - y;\n\t\t\t}\n\n\t\t\tfor(j = idxB + 1; j < cards.size(); ++j)\n\t\t\t\ttmp.push_back(cards[j]);\n\n\t\t\tif(sumA != x) {\n\t\t\t\ttmp.push_back(make_pair(sumA - x, cards[idxA].second));\n\t\t\t\tcards[idxA].first -= sumA - x;\n\t\t\t}\n\n\t\t\tfor(j = idxA + 1; j <= idxB; ++j)\n\t\t\t\ttmp.push_back(cards[j]);\n\n\t\t\tfor(j = 0; j <= idxA; ++j)\n\t\t\t\ttmp.push_back(cards[j]);\n\n\t\t\tcards.swap(tmp);\n\t\t}\n\n\t\tint ans = 0;\n\t\tint i = 0, sum = 0;\n\t\tfor(; i < cards.size(); ++i) {\n\t\t\tsum += cards[i].first;\n\t\t\tif(sum >= p) {\n\t\t\t\tif(cards[i].second)\n\t\t\t\t\tans += sum - p + 1;\n\n\t\t\t\tbreak;\n\t\t\t}\n\t\t}\n\n\t\tfor(++i; i < cards.size(); ++i) {\n\t\t\tsum += cards[i].first;\n\t\t\tif(sum > q) {\n\t\t\t\tif(cards[i].second)\n\t\t\t\t\tans += cards[i].first - (sum - q);\n\n\t\t\t\tbreak;\n\t\t\t}\n\t\t\telse {\n\t\t\t\tif(cards[i].second)\n\t\t\t\t\tans += cards[i].first;\n\t\t\t}\n\t\t}\n\n\t\tcout << ans << endl;\n\t}\n\n\treturn EXIT_SUCCESS;\n}"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\nusing namespace std;\n\nusing VI = vector<int>;\nusing VVI = vector<VI>;\nusing PII = pair<int, int>;\nusing LL = long long;\nusing VL = vector<LL>;\nusing VVL = vector<VL>;\nusing PLL = pair<LL, LL>;\nusing VS = vector<string>;\n\n#define ALL(a)  begin((a)),end((a))\n#define RALL(a) (a).rbegin(), (a).rend()\n#define PB push_back\n#define EB emplace_back\n#define MP make_pair\n#define SZ(a) int((a).size())\n#define SORT(c) sort(ALL((c)))\n#define RSORT(c) sort(RALL((c)))\n#define UNIQ(c) (c).erase(unique(ALL((c))), end((c)))\n\n#define FOR(i,a,b) for(int i=(a);i<(b);++i)\n#define REP(i,n)  FOR(i,0,n)\n\n#define FF first\n#define SS second\ntemplate<class S, class T>\nistream& operator>>(istream& is, pair<S,T>& p){\n  return is >> p.FF >> p.SS;\n}\ntemplate<class S, class T>\nostream& operator<<(ostream& os, const pair<S,T>& p){\n  return os << p.FF << \" \" << p.SS;\n}\ntemplate<class T>\nvoid maxi(T& x, T y){\n  if(x < y) x = y;\n}\ntemplate<class T>\nvoid mini(T& x, T y){\n  if(x > y) x = y;\n}\n\n\nconst double EPS = 1e-10;\nconst double PI  = acos(-1.0);\nconst LL MOD = 1e9+7;\n\nint main(){\n  cin.tie(0);\n  ios_base::sync_with_stdio(false);\n\n  int N;\n  while(cin>>N, N){\n\tint M;\n\tcin >> M;\n\tint P, Q, R;\n\tcin >> P >> Q >> R;\n\t--P;\n\t\n\tvector<pair<PII,int>> s[2];\n\tint crt = 0, nxt = 1;\n\ts[crt].PB(MP(MP(0,N),0));\n\tREP(i,M){\n\t  int a, b;\n\t  cin >> a >> b;\n\t  --a;\n\t  s[nxt].clear();\n\t  REP(i,SZ(s[crt])){\n\t\tif(R <= s[crt][i].SS){\n\t\t  s[crt].erase(begin(s[crt]) + i);\n\t\t  --i;\n\t\t}\n\t  }\n\t  \n\t  for(auto x: s[crt]){\n\t\tauto r = x.FF;\n\t\tint ix = x.SS;\n\t\tint l1 = N - b;\n\t\tint l2 = l1 + b - a;\n\t\t\n\t\tif(r.SS <= a){\n\t\t  s[nxt].PB(MP(MP(l2+r.FF, l2+r.SS), ix));\n\t\t}\n\t\telse if(r.FF < a){\n\t\t  if(r.SS <= b){\n\t\t\ts[nxt].PB(MP(MP(l2+r.FF, N), ix));\n\t\t\ts[nxt].PB(MP(MP(l1, l1+r.SS-a), ix+a-r.FF));\n\t\t  }\n\t\t  else{\n\t\t\ts[nxt].PB(MP(MP(l2+r.FF, l2+a), ix));\n\t\t\ts[nxt].PB(MP(MP(l1,l2), ix+a-r.FF));\n\t\t\ts[nxt].PB(MP(MP(0,r.SS-b), ix+b-r.FF));\n\t\t  }\n\t\t}\n\t\telse if(r.FF < b){\n\t\t  if(r.SS <= b){\n\t\t\ts[nxt].PB(MP(MP(l1+r.FF-a,l1+r.SS-a),ix));\n\t\t  }\n\t\t  else{\n\t\t\ts[nxt].PB(MP(MP(l1+r.FF-a,b), ix));\n\t\t\ts[nxt].PB(MP(MP(0,r.SS-b), ix+b-r.FF));\n\t\t  }\n\t\t}\n\t\telse{\n\t\t  s[nxt].PB(MP(MP(r.FF-b,r.SS-b), ix));\n\t\t}\n\t  }\n\t  swap(crt, nxt);\n\t}\n\t\n\tint ans = 0;\n\tfor(auto&& p: s[crt]){\n\t  auto ra = p.FF;\n\t  int ix = p.SS;\n\t  if(ra.SS <= P || Q <= ra.FF) continue;\n\t  int l = max(P, ra.FF);\n\t  int r = min(Q, ra.SS);\n\t  int bix = ix + l-ra.FF;\n\t  if(bix < R){\n\t\tans += min(r-l, R - bix);\n\t  }\n\t}\n\tcout << ans << endl;\n  }\n\n  return 0;\n}"
  },
  {
    "language": "C++",
    "code": "\n#if 1\n#include <fstream>\n#include <string>\n#include <sstream>\n#include <iostream>\n#include <locale>\n#include <codecvt>\n#include <memory>\n#include <iostream>\n#include <fstream>\n#include <string>\n#include <locale>\n#include <iomanip>\n#include <utility>\n#include <algorithm>\n\n\nint32_t N;\nint32_t p, q, r;\nint32_t M;\nint32_t X[5000];\nint32_t Y[5000];\n\nint32_t K[2][5000 * 3][2];//0: s 1: ?????°\nauto K_end = K[0];\ninline void insert(decltype(K_end) pos, int32_t ns, int32_t nn)\n{\n\tfor (auto iter = K_end; iter != pos; --iter) {\n\t\t(*iter)[0] = (*(iter - 1))[0];\n\t\t(*iter)[1] = (*(iter - 1))[1];\n\t}\n\t(*pos)[0] = ns;\n\t(*pos)[1] = nn;\n\t++K_end;\n}\nint main()\n{\n\tstd::cin >> N;\n\twhile (N != 0)\n\t{\n\t\tstd::cin >> M >> p >> q >> r;\n\t\tfor (int32_t i = 0; i < M; ++i) {\n\t\t\tstd::cin >> X[i] >> Y[i];\n\t\t}\n\t\tK_end = K[0];\n\t\t(*K_end)[0] = 1;\n\t\t(*K_end)[1] = N;\n\t\t++K_end;\n\n\t\tfor (int32_t i = 0; i < M; ++i)\n\t\t{\n\t\t\t//??????\n\t\t\tint num_buf = 0;\n\t\t\tdecltype(K_end) x_end_pos = nullptr;\n\t\t\tfor (auto iter = K[i & 1]; iter != K_end; ++iter) {\n\t\t\t\tnum_buf += (*iter)[1];\n\t\t\t\tif (X[i] <= num_buf) {\n\t\t\t\t\tauto nn = (num_buf - X[i]);\n\t\t\t\t\t(*iter)[1] -= nn;\n\t\t\t\t\tinsert(iter + 1, (*iter)[0] + (*iter)[1], nn);\n\t\t\t\t\tx_end_pos = iter + 1;\n\t\t\t\t\tbreak;\n\t\t\t\t}\n\t\t\t}\n\t\t\tnum_buf = X[i];\n\t\t\tdecltype(K_end) y_end_pos = nullptr;\n\t\t\tfor (auto iter = x_end_pos; iter != K_end; ++iter) {\n\t\t\t\tnum_buf += (*iter)[1];\n\t\t\t\tif (Y[i] <= num_buf) {\n\t\t\t\t\tauto nn = (num_buf - Y[i]);\n\t\t\t\t\t(*iter)[1] -= nn;\n\t\t\t\t\tinsert(iter + 1, (*iter)[0] + (*iter)[1], nn);\n\t\t\t\t\ty_end_pos = iter + 1;\n\t\t\t\t\tbreak;\n\t\t\t\t}\n\t\t\t}\n\t\t\t//????????????\n\t\t\tauto iter_out = K[(i + 1) & 1];\n\t\t\tfor (auto iter = y_end_pos; iter != K_end; ++iter) {\n\t\t\t\t(*iter_out)[0] = (*iter)[0];\n\t\t\t\t(*iter_out)[1] = (*iter)[1];\n\t\t\t\t++iter_out;\n\t\t\t}\n\t\t\tfor (auto iter = x_end_pos; iter != y_end_pos; ++iter) {\n\t\t\t\t(*iter_out)[0] = (*iter)[0];\n\t\t\t\t(*iter_out)[1] = (*iter)[1];\n\t\t\t\t++iter_out;\n\t\t\t}\n\t\t\tfor (auto iter = K[i & 1]; iter != x_end_pos; ++iter) {\n\t\t\t\t(*iter_out)[0] = (*iter)[0];\n\t\t\t\t(*iter_out)[1] = (*iter)[1];\n\t\t\t\t++iter_out;\n\t\t\t}\n\t\t\tK_end = iter_out;\n\t\t}\n\n\t\t//??????\n\t\tint32_t num_buf = 0;\n\t\tint32_t count = 0;\n\t\tfor (auto iter = K[M & 1]; iter != K_end; ++iter) {\n\t\t\tauto n_numbuf = num_buf + (*iter)[1];\n\t\t\tauto add = std::min(r - ((*iter)[0] - 1), (*iter)[1]);\n\t\t\tif (num_buf < p) {\n\t\t\t\tadd -= (p - 1 - num_buf);\n\t\t\t}\n\t\t\tif (q < n_numbuf) {\n\t\t\t\tadd = std::min(add, q - num_buf);\n\t\t\t}\n\t\t\tcount += std::max(0, add);\n\t\t\tnum_buf = n_numbuf;\n\t\t}\n\t\tstd::cout << count << '\\n';\n\n\t\tstd::cin >> N;\n\t}\n}"
  },
  {
    "language": "C++",
    "code": "#include<iostream>\n#include<cstdio>\n#include<vector>\n#include<queue>\n#include<algorithm>\n#include<functional>\n#include<cstring>\n#define MAX_N 100000\n#define F first\n#define S second \n#define MP make_pair\nusing namespace std;\ntypedef pair<int, int> P;\n\nconst int INF = 1e9;\n\nint main() {\n\tint n, m, pp, q, r;\n\n\twhile (cin >> n&&n){\t\n\t\tint save = -1, ans = 0;\n\t\tvector<int>vep, vep2, vep3;\n\t\tvep.push_back(1);\n\t\tvep.push_back(n);\n\t    vector<int> vec, vec2, vec3;\n\t\tvec.push_back(1);\n\t\tvec.push_back(n);\n\t\tcin >> m >> pp >> q >> r;\n\t\tfor (int i = 0; i < m; i++) {\n\t\t\tint x, y, p, p2;\n\t\t\tscanf(\"%d%d\", &x, &y);\n\t\t\tp = lower_bound(vec.begin(), vec.end(), x) - vec.begin();\n\t\t\tif (vec[p] != x) {\n\t\t\t\tvec.insert(vec.begin() + p, x);\n\t\t\t\tvep.insert(vep.begin() + p, vec[p] - vec[p - 1] + vep[p - 1]);\n\t\t\t}\n\t\t\tif (vec[p] + 1 != vec[p + 1]) {\n\t\t\t\tvec.insert(vec.begin() + p + 1, x + 1);\n\t\t\t\tvep.insert(vep.begin() + p + 1, vep[p] + 1);\n\t\t\t}\n\t\t\tp2 = lower_bound(vec.begin(), vec.end(), y) - vec.begin();\n\t\t\tif (vec[p2] != y) {\n\t\t\t\tvec.insert(vec.begin() + p2, y);\n\t\t\t\tvep.insert(vep.begin() + p2, vec[p2] - vec[p2 - 1] + vep[p2 - 1]);\n\t\t\t}\n\t\t\tif (vec[p2] + 1 != vec[p2 + 1]) {\n\t\t\t\tvec.insert(vec.begin() + p2 + 1, y + 1);\n\t\t\t\tvep.insert(vep.begin() + p2 + 1, vep[p2] + 1);\n\t\t\t}\n\t\t\tfor (int j = p2 + 1; j < vec.size(); j++) {\n\t\t\t\tvec2.push_back(vec[j] - vec[p2 + 1] + 1);\n\t\t\t\tvep2.push_back(vep[j]);\n\t\t\t}\n\t\t\tint size = vec2[vec2.size() - 1];\n\t\t\tfor (int j = p + 1; j < p2 + 1; j++) {\n\t\t\t\tvec2.push_back(vec[j] - vec[p + 1] + 1 + size);\n\t\t\t\tvep2.push_back(vep[j]);\n\t\t\t}\n\t\t\tsize = vec2[vec2.size() - 1];\n\t\t\tfor (int j = 0; j < p + 1; j++) {\n\t\t\t\tvec2.push_back(vec[j] - vec[0] + 1+size);\n\t\t\t\tvep2.push_back(vep[j]);\n\t\t\t}\n\t\t\tvec3 = vec;\n\t\t\tvep3 = vep;\n\t\t\tvec = vec2;\n\t\t\tvep = vep2;\n\t\t\tvec2 = vec3;\n\t\t\tvep2 = vep3;\n\t\t\tvec2.clear();\n\t\t\tvep2.clear();\n\t\t}\n\t\tint p, p2;\n\t\tp = lower_bound(vec.begin(), vec.end(), pp) - vec.begin();\n\t\t\n\t\tif (vec[p] != pp) {\n\t\t\tvec.insert(vec.begin() + p, pp);\n\t\t\tvep.insert(vep.begin() + p, vec[p] - vec[p - 1] + vep[p - 1]);\n\t\t}\n\t\tif (vec[p] + 1 != vec[p + 1]) {\n\t\t\tvec.insert(vec.begin() + p + 1, pp + 1);\n\t\t\tvep.insert(vep.begin() + p + 1, vep[p] + 1);\n\t\t}\n\t\tp2 = lower_bound(vec.begin(), vec.end(), q) - vec.begin();\n\t\tif (vec[p2] != q) {\n\t\t\tvec.insert(vec.begin() + p2, q);\n\t\t\tvep.insert(vep.begin() + p2, vec[p2] - vec[p2 - 1] + vep[p2 - 1]);\n\t\t}\n\t\tif (vec[p2] + 1 != vec[p2 + 1]) {\n\t\t\tvec.insert(vec.begin() + p2 + 1, q + 1);\n\t\t\tvep.insert(vep.begin() + p2 + 1, vep[p2] + 1);\n\t\t}\n\t\tfor (int i = p; i <= p2; i++) {\n\t\t\tif (i + 1<=p2 && vep[i + 1] - vep[i] == vec[i + 1] - vec[i]) {\n\t\t\t\tfor (int j = vep[i]; j <= vep[i + 1]; j++) {\n\t\t\t\t\tif (j <= r&&save!=j) {\n\t\t\t\t\t\tans++;\n\t\t\t\t\t\tsave = j;\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t}\n\t\t\telse{\n\t\t\t\tif (vep[i] <= r&&save != vep[i]) {\n\t\t\t\t\tans++;\n\t\t\t\t\tsave = vep[i];\n\t\t\t\t}\n\t\t\t}\n\t}\n\t\tcout << ans << endl;\n\t}\n}"
  },
  {
    "language": "C++",
    "code": "#include <iostream>\n#include <algorithm>\n#include <vector>\nusing namespace std;\nint main(){\n\tint n,m,p,q,r,x,y;\n\tvector<int>::iterator itx,ity,it;\n\tfor(;cin>>n>>m>>p>>q>>r;cout<<x<<endl){\n\t\tvector<int> v1(1),v2;\n\t\t\n\t\tfor(v1.push_back(r);m--;v2.clear()){\n\t\t\tcin>>x>>y;\n\t\t\titx=upper_bound(v1.begin(),v1.end(),x);\n\t\t\tity=upper_bound(v1.begin(),v1.end(),y);\n\t\t\t\n//\t\t\tif( ity-v1.begin()+1 & 1 )v2.push_back(0);\n//\t\t\tv2.push_back(0);\n\t\t\tv2.insert(v2.end(),ity-v1.begin()&1?1:2,0);\n\t\t\tfor(it=ity;it!=v1.end();++it)\n\t\t\t\tv2.push_back(*it - y);\n\t\t\t\n\t\t\tif(v1.end()-itx & 1)v2.push_back(n-y);\n\t\t\tfor(it=itx;it!=ity;++it)\n\t\t\t\tv2.push_back(*it-x+n-y);\n\t\t\t\n\t\t\tit = v1.begin();\n\t\t\tif(ity-v1.begin() & 1)++it;\n\t\t\tif(!it[1])it+=2;\n\t\t\tif(*it+n-x==v2.back())++it,v2.pop_back();\n\t\t\tfor(;it!=itx;++it)\n\t\t\t\tv2.push_back(*it+n-x);\n\t\t\t\n\t\t\tv1.swap(v2);\n\t\t}\n\t\tv1.insert( upper_bound(v1.begin(),v1.end(),p-1), 2, p-1);\n\t\tv1.insert( lower_bound(v1.begin(),v1.end(),q), q );\n\t\tv1.push_back(n);\n\t\tit = upper_bound(v1.begin(),v1.end(),p-1);\n\t\tif(it-v1.begin() & 1) --it;\n\t\tfor(x=0;*it<q;++it){\n\t\t\tm=*it,\n\t\t\tx+=*++it-m;\n\t\t}\n\t}\n}"
  },
  {
    "language": "C++",
    "code": "\n#include<iostream>\nusing namespace std;\nint cards,n,i,p,q,r,x[5000],y[5000],counter;\n  int numberStart[10001];\n  int numberFast[10001];\n  int numberEnd[10001];\n  int searchB[10001];\nint numberLong(int value){\n\treturn numberEnd[value]-numberStart[value]+1;\n}\n\n\nint searchD(int seed){\n\t\tint l=0;\n  for (int a=1;a<=counter+1;a++){\n\tif(seed>l+numberLong(searchB[a])){\n\tl+=numberLong(searchB[a]);\n\t}\n\telse{\n\t return numberFast[searchB[a]];\n\t}\n  }\n return -100;\n\t\n}\nint searchNumber(int value){\n\tint l=0;\n  for (int a=1;a<=counter+1;a++){\n\tif(value>l+numberLong(searchB[a])){\n\tl+=numberLong(searchB[a]);\n\t}\n\telse{\n\t return numberStart[searchB[a]]+value-l-1;\n\t}\n  }\n return -100;\n}\n\nvoid cut(int g){\n\tif(searchD(g)==searchD(g+1)){\n  //カットする場所が入ってる数列を求める\n\tint\tsearchNumberG=searchNumber(g);\n  int seachX=searchB[searchD(g)];\n  int seachXX=searchNumberG;\n//数列ができる範囲の後ろの番号FASTを変える\n     for(int j=1;j<=counter;j++){\n      if (numberFast[j]>=numberFast[seachX]+1){\n      numberFast[j]++;\n     }\n    }\n\n  //の数列の後ろに新しい数列を作る\n counter++;\n  numberFast[counter]=numberFast[seachX]+1;\n  numberStart[counter] =searchNumberG+1;\n  numberEnd[counter]=numberEnd[seachX];\n  //できた数列の前の数列の最後を調整する\n  numberEnd[seachX]=searchNumberG;\n \n\n  \n  for ( int a=1;a<=counter+1;a++){\n\t  searchB[numberFast[a]]=a;\n    }\n    }\n\n}\nvoid shuffle(int x,int y){\n\t\n\tint StartHead[10001];\n\tint  numberFastNew[10001];\n\t\n\tint longs=1;\n\tfor (int i=1;i<=counter;i++){\n\t\tStartHead[searchB[i]]=longs;\n\t\tlongs+=numberLong(searchB[i]);\n\t}\n\tint newCounter[3];\n\tfor(int i=0;i<3;i++){\n\t\tnewCounter[i]=0;\n\t}\n\tfor(int j=1;j<=counter;j++){\n\t\tif (StartHead[j]>y){\n\t\t\tnewCounter[0]++;\n\t\tnumberFastNew[j]=0;\n\t\t}\n\t\tif (StartHead[j]>x && StartHead[j]+numberLong(j)-1<=y){\n\t\t\tnewCounter[1]++;\n\t\tnumberFastNew[j]=1;\n\t\t}\n\t\tif (StartHead[j]+numberLong(j)-1<=x){\n\t\t\tnewCounter[2]++;\n\t\tnumberFastNew[j]=2;\n\t\t}\n\t}\n\t\n\tfor(int j=1;j<=counter;j++){\n\t\tswitch(numberFastNew[j]){\n\t\t\tcase 0:\n\t\t\t\tnumberFast[j]+=-newCounter[1]-newCounter[2];\n\t\t\t\tbreak;\n\t\t\tcase 1:\n\t\t\t\tnumberFast[j]+=newCounter[0]-newCounter[2];\n\t\t\t\tbreak;\n\t\t\tcase 2:\n\t\t\t\tnumberFast[j]+=newCounter[1]+newCounter[0];\n\t\t\t\tbreak;\n\t\t}\n\n\t}\n\t  for ( int a=1;a<=counter+1;a++){\n\t  searchB[numberFast[a]]=a;\n    }\n\n}\n\n\nint main(void)\n{\n\twhile(true){\n\tcards=0;\n\tn=0;\n\tcounter=0;\n\tfor (int i=0;i<10001;i++){\n   numberStart[i]=0;\n   numberFast[i]=0;\n   numberEnd[i]=0;\n   searchB[i]=0;\n\t}\n\tint points=0;\n  counter=1;\n  cin >> cards;\n  if (cards==0){\n\t  break;\n  }\n  numberStart[1]=1;\n  numberEnd[1]=cards;\n  numberFast[1]=1;\n  searchB[1]=1;\n  cin >> n;\n  cin >> p  >> q  >> r ;\n  for (i=1;i<=n;i++){\n    cin >> x[i] >> y[i];\n  }\n  for (i=1;i<=n;i++){\n     cut(x[i]);\n\t \n      cut(y[i]);\n\t  \n     shuffle(x[i],y[i]);\n  }\n  cut(p-1);\n  cut(q);\n /*\n  \n  for(int j=1;j<=counter;j++){\n\n    cout << numberStart[j] << \" \"  <<  numberEnd[j] << \" \" << numberFast[j] <<  endl;\n\n  }\n  cout << searchD(p) << searchD(q) <<endl;\n  */\n  for(int j=1;j<=counter;j++){\n  if( searchD(p)<= numberFast[j] && numberFast[j] <= searchD(q)){\n\t  if(numberEnd[j]<=r){\n\t  points+=numberLong(j);\n\t  }\n\t  else if(numberStart[j]<=r){\n\tpoints+=numberLong(j)-(numberEnd[j]-r);\n\t  }\n  }\n  }\n  cout << points << endl;\n\t}\n}"
  },
  {
    "language": "C++",
    "code": "#include<iostream>\n#include<list>\n\nusing namespace std;\n\nstruct block {\n  int start;\n  int end;\n  int len;\n};\n\nlist<block> blocks;\nlist<block> fronts;\nlist<block> middles;\n\n/*\nvoid view( block now ) {\n  cout << \"Start: \" << now.start << \"End: \" << now.end << endl;\n}\n*/\n\ninline void split ( int what, int x ) {\n  block now;\n  block front;\n  block back;  \n  //cout << \"Start split \" << x << endl;\n\n  now = blocks.front();\n\n  blocks.pop_front();\n  back.start = now.start + x;\n  back.end = now.end;\n  back.len = now.len - x;\n\n  blocks.push_front(back);\n\n  \n\n  front.start = now.start;\n  front.end = now.start + x -1;\n  front.len = x;\n  if ( what == 0 )\n    fronts.push_back(front);\n  else\n    middles.push_back(front);\n\n  //view(now);\n  //view(front);\n  //view(back);\n}\n  \nint main() {\n  int count = 0;\n\n\n  while ( true ) {\n    int n, m, p, q, r;\n\n    cin >> n;\n    if ( n == 0 )\n      break;\n\n    cin >> m;\n\n    cin >> p >> q >> r;\n\n    block data;\n    blocks.clear();\n    data.start = 1;\n    data.end = n;\n    data.len = n;\n    blocks.push_back(data);\n\n\n    block now;\n\n    for ( int i=0; i<m; i++ ) {\n      int x, y;\n      cin >> x >> y;\n      int temp = x;\n\n      fronts.clear();\n      middles.clear();\n\n      while ( x != 0 ) {\n\tif ( blocks.front().len > x ) {\n\t  split(0,x);\n\t  x = 0;\n\t  break;\n\t}\n\telse {\n\t  x -= blocks.front().len;\n\t  fronts.push_back(blocks.front());\n\t  blocks.pop_front();\n\t  /*\n\t  now = blocks.front();\n\t  blocks.pop_front();\n\t  x -= now.len;\n\t  fronts.push_back(now);\n\t  */\n\t}\n      }\n\n      y = y-temp;\n    \n      while ( y != 0 ) {\n\n\tif ( blocks.front().len > y ) {\n\t  split(1,y);\n\t  y = 0;\n\t  break;\n\t}\n\telse {\n\t  y -= blocks.front().len;\n\t  middles.push_back(blocks.front());\n\t  blocks.pop_front();\n\t  /*\n\t  now = blocks.front();\n\t  blocks.pop_front();\n\t  y -= now.len;\n\t  middles.push_back(now);\n\t  */\n\t}\n      }\n\n      blocks.splice(blocks.end(), middles);\n      blocks.splice(blocks.end(), fronts);\n\n    }\n    \n    int sum = 0;\n\n    \n\n    bool start, end;\n    start = true;\n    end = false;\n    //cout << \"Start Counting\" << endl;\n    while ( !blocks.empty() ) {\n      now = blocks.front();\n\n      blocks.pop_front();\n      if ( start && p > now.len ) {\n\t//view(now);\n\tp -= now.len;\n\tq -= now.len;\n      } else {\n\t//view(now);\n\tif ( start ) {\n\t  start = false;\n\t  now.start += p-1;\n\t}\n\n\n\n\tq -= now.len;\n\tif ( q <=0 )\n\t  end = true;\n\tif ( q < 0 )\n\t  now.end += q;\n\t//view(now);\t\n\n\tif ( now.start <= r ) {\n\t  if ( now.end >= r ) {\n\t    sum += r - now.start + 1;\n\t  }\n\t  else\n\t    sum += now.end - now.start + 1;\n\t}\n\n\tif ( end )\n\t  break;\n      }\n    }\n    cout << sum << endl;\n    //cout << \"ANswer: \" << sum << endl;\n    \n  }\n}"
  },
  {
    "language": "C++",
    "code": "//  Shuffle.cpp\n//  2013/01/02.\n\n#if 1\n\n#include <cstdio>\n#include <cstdlib>\n#include <cstring>\n#include <cmath>\n#include <ctime>\n#include <cassert>\n#include <iostream>\n#include <cctype>\n#include <sstream>\n#include <string>\n#include <list>\n#include <vector>\n#include <queue>\n#include <set>\n#include <stack>\n#include <map>\n#include <utility>\n#include <numeric>\n#include <algorithm>\n#include <iterator>\n#include <bitset>\n#include <complex>\n#include <fstream>\nusing namespace std;\ntypedef long long ll;\nconst double EPS = 1e-9;\ntypedef vector<int> vint;\ntypedef pair<int, int> pint;\n#define rep(i, n) REP(i, 0, n)\n#define ALL(v) v.begin(), v.end()\n#define MSG(a) cout << #a << \" \" << a << endl;\n#define REP(i, x, n) for(int i = x; i < n; i++)\ntemplate<class T> T RoundOff(T a){ return int(a+.5-(a<0)); }\ntemplate<class T, class C> void chmax(T& a, C b){ if(a < b) a = b; }\ntemplate<class T, class C> void chmin(T& a, C b){ if(b < a) a = b; }\ntemplate<class T, class C> pair<T, C> mp(T a, C b){ return make_pair(a, b); }\n\ntypedef vector<pint> VP;\n\npair<VP, VP> take(VP cards, int x)\n{\n\tVP head, tail;\n\n\tint num = 0;\n\t\n\trep(i, cards.size())\n\t{\n\t\tif(num + cards[i].second <= x) head.push_back(cards[i]);\n\t\telse if(x <= num) tail.push_back(cards[i]);\n\t\telse if(x < num + cards[i].second)\n\t\t{\n\t\t\thead.push_back(mp(cards[i].first, x - num));\n\t\t\ttail.push_back(mp(cards[i].first + x - num, cards[i].second - (x - num)));\n\t\t}\n\t\t\n\t\tnum += cards[i].second;\n\t}\n\t\n \treturn mp(head, tail);\n}\n\n\nint count(VP cards, int r)\n{\n\tint res = 0;\n\t\n\trep(i, cards.size()) if(cards[i].first <= r) res += min(r - cards[i].first + 1, cards[i].second);\n\t\n\treturn res;\n}\n\n\nint main()\n{\n\tfor(int n; cin >> n; )\n\t{\n\t\tif(n == 0) break;\n\t\t\n\t\tint m, p, q, r;\n\t\tcin >> m >> p >> q >> r;\n\t\t\n\t\tVP cards(1, mp(1, n));\n\t\t\n\t\t\n\t\trep(i, m)\n\t\t{\n\t\t\tint x, y;\n\t\t\tcin >> x >> y;\n\t\t\t\n\t\t\tVP a, b, c;\n\t\t\tpair<VP, VP> tmp;\n\t\t\t\n\t\t\ttmp = take(cards, x);\n\t\t\ta = tmp.first;\n\t\t\ttmp = take(tmp.second, y - x);\n\t\t\tb = tmp.first;\n\t\t\tc = tmp.second;\n\t\t\t\n\t\t\tcards.clear();\n\t\t\trep(i, c.size()) cards.push_back(c[i]);\n\t\t\trep(i, b.size()) cards.push_back(b[i]);\n\t\t\trep(i, a.size()) cards.push_back(a[i]);\n\t\t}\n\t\t\n\t\tcout << count(take(take(cards, p-1).second, q-p+1).first, r) << endl;\n\t}\n}\n\n/*\n while (n = gets.chomp.to_i) != 0\n m = gets.chomp.to_i\n p, q, r = gets.split.map(&:to_i)\n \n cards = [[1, n]]\n \n m.times do\n x, y = gets.split.map(&:to_i)\n \n a, cards = take(cards, x)\n b, c = take(cards, y - x)\n \n cards = c + b + a\n end\n \n \n puts count(take(take(cards, p-1)[1], q - p + 1)[0], r)\n end\n \n\n */\n\n\n#endif"
  },
  {
    "language": "C++",
    "code": "#include<bits/stdc++.h>\n#include<algorithm>\n#include<vector>\n#include<queue>\nusing namespace std;\ntypedef long long ll;\ntypedef pair<int,int> P;\n\nint n,m,p,q,r;\n\nint main(){\n\tscanf(\"%d%d\",&n,&m);\n\tscanf(\"%d%d%d\",&p,&q,&r);\n\tvector<P> *z=new vector<P>;\n\tz->push_back(P(1,n));\n\tfor(int i=0;i<m;i++){\n\t\tint x[3]={0,0,n};\n\t\tscanf(\"%d%d\",&x[0],&x[1]);\n\t\tvector<P> *b=new vector<P>;\n\t\tvector<P> c[3]; int count=0,cx=1;\n\t\tint j=0;\n\t\twhile(cx<=n)\n\t\t\tif(cx+(z->at(j).second)-(z->at(j).first)<=x[count]){ c[count].push_back(z->at(j)); cx+=(z->at(j).second)-(z->at(j).first)+1; j++;}\n\t\t\telse{ if(cx!=x[count]+1) c[count].push_back(P(z->at(j).first,z->at(j).first+x[count]-cx)); z->at(j).first+=x[count]-cx+1; cx=x[count]+1; count++;}\n\t\tfor(j=2;j>=0;j--)\n\t\t\tfor(int k=0;k<c[j].size();k++) b->push_back(c[j][k]);\n\t\tz=b;\n\t}\n\tint res=0,count=1;\n\tfor(int i=0;i<z->size();i++){\n\t\tP pp=z->at(i); int c1=count+pp.second-pp.first;\n\t\tif(count>=p&&q>=c1) ;\n\t\telse if(count<=p&&p<=c1) pp.first+=p-count;\n\t\telse if(count<=q&&q<=c1) pp.second-=c1-q;\n\t\telse { count=c1+1; continue;}\n\t\tcount=c1+1;\n\t\tif(r>=pp.second) res+=pp.second-pp.first+1;\n\t\telse if(r>=pp.first) res+=r-pp.first+1;\n\t}\n\tprintf(\"%d\\n\",res);\n}"
  },
  {
    "language": "C++",
    "code": "#include <cstdio>\n#include <iostream>\n#include <cmath>\n#include <cstring>\n#include <sstream>\n#include <algorithm>\n#include <cstdlib>\n#include <map>\n#include <queue>\n#include <utility>\n#include <vector>\n#include <set>\n#include <memory.h>\n#include <iomanip>\n#include <bitset>\n#include <list>\n#include <stack>\n#include <deque>\n\nusing namespace std;\n\n#define mod 1000000007\n\nint main()\n{\n\tint n, m, p, q, r;\n\tcin >> n >> m >> p >> q >> r;\n\tvector<pair<int, int> > v;\n\tv.push_back(make_pair(1, n));\n\tfor(int i = 0; i < m; i++){\n\t\tint x, y;\n\t\tcin >> x >> y;\n\t\ty -= x;\n\t\tvector<pair<int, int> > a, b, c;\n\t\tint cardnum = 0;\n\t\tint cnt = 0;\n\t\twhile(cnt < v.size() && cardnum + v[cnt].second < x){\n\t\t\ta.push_back(v[cnt]);\n\t\t\tcardnum += v[cnt].second;\n\t\t\tcnt++;\n\t\t}\n\t\tint tmp = x - cardnum;\n\t\ta.push_back(make_pair(v[cnt].first, tmp));\n\t\t// cout << a[0].first << \"  \" << a[0].second << endl;\n\t\tif(v[cnt].second - tmp >= y){\n\t\t\tb.push_back(make_pair(v[cnt].first + tmp, y));\n\t\t\tif(v[cnt].second - tmp > y) c.push_back(make_pair(v[cnt].first + tmp + y, v[cnt].second - tmp - y));\n\t\t\tcnt++;\n\t\t\twhile(cnt < v.size()){\n\t\t\t\tc.push_back(v[cnt]);\n\t\t\t\tcnt++;\n\t\t\t}\n\t\t\tv = c;\n\t\t\tcopy(b.begin(), b.end(), back_inserter(v));\n\t\t\tcopy(a.begin(), a.end(), back_inserter(v));\n\t\t\t// cout << endl;\n\t\t\t// for(int i = 0; i < v.size(); i++){\n\t\t\t// \tcout << v[i].first << \" \" << v[i].second << endl;\n\t\t\t// }\n\t\t\tcontinue;\n\t\t}\n\t\tif(v[cnt].second - tmp > 0) b.push_back(make_pair(v[cnt].first + tmp, v[cnt].second - tmp));\n\t\tcardnum = v[cnt].second - tmp;\n\t\tcnt++;\n\t\twhile(cnt < v.size() && cardnum + v[cnt].second < y){\n\t\t\tb.push_back(v[cnt]);\n\t\t\tcardnum += v[cnt].second;\n\t\t\tcnt++;\n\t\t}\n\t\ttmp = y - cardnum;\n\t\tb.push_back(make_pair(v[cnt].first, tmp));\n\t\tif(v[cnt].second - tmp > 0) c.push_back(make_pair(v[cnt].first + tmp, v[cnt].second - tmp));\n\t\tcnt++;\n\t\twhile(cnt < v.size()){\n\t\t\tc.push_back(v[cnt]);\n\t\t\tcnt++;\n\t\t}\n\t\tv = c;\n\t\tcopy(b.begin(), b.end(), back_inserter(v));\n\t\tcopy(a.begin(), a.end(), back_inserter(v));\n\t\t// cout << endl;\n\t\t// for(int i = 0; i < v.size(); i++){\n\t\t// \tcout << v[i].first << \" \" << v[i].second << endl;\n\t\t// }\n\t}\n\tint cardnum = 0;\n\tint ans = 0;\n\tfor(int i = 0; i < v.size(); i++){\n\t\tif(cardnum + v[i].second >= p){\n\t\t\tans += max(0, min(r + 1, (v[i].first + max(0, min(q - cardnum, v[i].second)))) - v[i].first);\n\t\t}\n\t\tcardnum += v[i].second;\n\t\t// cout << v[i].first << \" \" << v[i].second << \" \"  << ans << endl;\n\t}\n\tcout << ans << endl;\n\treturn 0;\n}\n"
  },
  {
    "language": "C++",
    "code": "#include<bits/stdc++.h>\n#include<algorithm>\n#include<vector>\n#include<queue>\nusing namespace std;\ntypedef long long ll;\ntypedef pair<int,int> P;\n\nint n,m,p,q,r;\n\nint main(){\n\twhile(scanf(\"%d\",&n),n){\n\t\tscanf(\"%d\",&m);\n\t\tscanf(\"%d%d%d\",&p,&q,&r);\n\t\tvector<P> *z=new vector<P>;\n\t\tz->push_back(P(1,n));\n\t\tfor(int i=0;i<m;i++){\n\t\t\tint x[3]={0,0,n};\n\t\t\tscanf(\"%d%d\",&x[0],&x[1]);\n\t\t\tvector<P> *b=new vector<P>;\n\t\t\tvector<P> c[3]; int count=0,cx=1;\n\t\t\tint j=0;\n\t\t\twhile(cx<=n)\n\t\t\t\tif(cx+(z->at(j).second)-(z->at(j).first)<=x[count]){ c[count].push_back(z->at(j)); cx+=(z->at(j).second)-(z->at(j).first)+1; j++;}\n\t\t\t\telse{ if(cx!=x[count]+1) c[count].push_back(P(z->at(j).first,z->at(j).first+x[count]-cx)); z->at(j).first+=x[count]-cx+1; cx=x[count]+1; count++;}\n\t\t\tfor(j=2;j>=0;j--)\n\t\t\t\tfor(int k=0;k<c[j].size();k++) b->push_back(c[j][k]);\n\t\t\tz=b;\n\t\t}\n\t\tint res=0,count=1;\n\t\tfor(int i=0;i<z->size();i++){\n\t\t\tP pp=z->at(i); int c1=count+pp.second-pp.first;\n\t\t\tif(count>=p&&q>=c1) ;\n\t\t\telse if(count<=p&&p<=c1) pp.first+=p-count;\n\t\t\telse if(count<=q&&q<=c1) pp.second-=c1-q;\n\t\t\telse { count=c1+1; continue;}\n\t\t\tcount=c1+1;\n\t\t\tif(r>=pp.second) res+=pp.second-pp.first+1;\n\t\t\telse if(r>=pp.first) res+=r-pp.first+1;\n\t\t}\n\t\tprintf(\"%d\\n\",res);\n\t}\n}"
  },
  {
    "language": "C++",
    "code": "#include <iostream>\n#include <vector>\n\nusing namespace std;\n\ntypedef struct\n{\n\tint begin;\n\tint end;\n} seq;\n\nvector<seq> cards,A,B,C;\nint N,M,P,Q,R;\nseq ts;\n\nseq* makeseq(int begin,int end)\n{\n\tts.begin = begin;\n\tts.end = end;\n\treturn &ts;\n}\n\nvoid shuffle(int x,int y)\n{\n\tA.clear();\n\tB.clear();\n\tC.clear();\n\tint sum = 0;\n\tfor(auto itr = cards.begin();itr < cards.end();itr++)\n\t{\n\t\tif(sum + (itr->end - itr->begin) < x)\n\t\t{\n\t\t\tA.push_back(*itr);\n\t\t\tsum += (itr->end - itr->begin) + 1;\n\t\t\tcards.erase(itr);\n\t\t\titr--;\n\t\t}\n\t\telse\n\t\t{\n\t\t\tif(sum != x)\n\t\t\t{\n\t\t\t\tA.push_back(*makeseq(itr->begin,itr->begin+((x-sum)-1)));\n\t\t\t\titr->begin = itr->begin+(x-sum);\n\t\t\t}\n\t\t\tbreak;\n\t\t}\n\t}\n\tsum = x;\n\tfor(auto itr = cards.begin();itr < cards.end();itr++)\n\t{\n\t\tif(sum + (itr->end - itr->begin) < y)\n\t\t{\n\t\t\tB.push_back(*itr);\n\t\t\tsum += (itr->end - itr->begin) + 1;\n\t\t\tcards.erase(itr);\n\t\t\titr--;\n\t\t}\n\t\telse\n\t\t{\n\t\t\tif(sum != y)\n\t\t\t{\n\t\t\t\tB.push_back(*makeseq(itr->begin,itr->begin+((y-sum)-1)));\n\t\t\t\titr->begin = itr->begin+(y-sum);\n\t\t\t}\n\t\t\tbreak;\n\t\t}\n\t}\n\tfor(auto itr = cards.begin();itr < cards.end();itr++)\n\t{\n\t\tC.push_back(*itr);\n\t\tcards.erase(itr);\n\t\titr--;\n\t}\n\tfor(auto itr = C.begin();itr < C.end();itr++)\n\t{\n\t\tcards.push_back(*itr);\n\t}\n\tfor(auto itr = B.begin();itr < B.end();itr++)\n\t{\n\t\tcards.push_back(*itr);\n\t}\n\tfor(auto itr = A.begin();itr < A.end();itr++)\n\t{\n\t\tcards.push_back(*itr);\n\t}\n}\n\nint main(void)\n{\n\twhile(true)\n\t{\n\t\tcin >> N;\n\t\tif(N == 0)\n\t\t\texit(0);\n\t\tcards.clear();\n\t\tA.clear();\n\t\tB.clear();\n\t\tC.clear();\n\t\tcin >> M >> P >> Q >> R;\n\t\tcards.push_back(*makeseq(1,N));\n\t\tint x,y;\n\t\tfor(int i = 0;i < M;i++)\n\t\t{\n\t\t\tcin >> x >> y;\n\t\t\tshuffle(x,y);\n\t\t}\n\t\tint result = 0;\n\t\tint sum = 0;\n\t\tfor(auto itr = cards.begin();itr < cards.end();itr++)\n\t\t{\n\t\t\tif(sum + (itr->end - itr->begin) < P-1)\n\t\t\t{\n\t\t\t\tsum += (itr->end - itr->begin)+1;\n\t\t\t\tcards.erase(itr);\n\t\t\t\titr--;\n\t\t\t}\n\t\t\telse\n\t\t\t{\n\t\t\t\tif(sum != P-1)\n\t\t\t\t{\n\t\t\t\t\titr->begin = itr->begin + ((P - sum) - 1);\n\t\t\t\t}\n\t\t\t\tbreak;\n\t\t\t}\n\t\t}\n\t\tsum = 0;\n\t\tint count = (Q - P) + 1;\n\t\tfor(auto itr = cards.begin();itr < cards.end();itr++)\n\t\t{\n\t\t\tif(sum + (itr->end - itr->begin) < count)\n\t\t\t{\n\t\t\t\tsum += (itr->end - itr->begin)+1;\n\t\t\t\tif(itr->begin <= R)\n\t\t\t\t{\n\t\t\t\t\tresult += (min(R,itr->end) - itr->begin)+1;\n\t\t\t\t}\n\t\t\t}\n\t\t\telse\n\t\t\t{\n\t\t\t\tif(sum != count)\n\t\t\t\t{\n\t\t\t\t\titr->end = itr->end - (((itr->end - itr->begin)+1)-(count-sum));\n\t\t\t\t\tresult += (min(R,itr->end) - itr->begin)+1;\n\t\t\t\t}\n\t\t\t\tbreak;\n\t\t\t}\n\t\t}\n\t\tcout << result << endl;\n\t}\n}"
  },
  {
    "language": "C++",
    "code": "#include <cstdio>\n#include <vector>\n#include <map>\nusing namespace std;\ntypedef pair<int, int> P;\ntypedef vector<P> vi;\n#define f first\n#define s second\n#define pb push_back\n#define sz(x) x.size()\nvi c;\nvoid shuffle(int x, int y) {\n    int cnt=0, i;\n    int sz=sz(c);\n    vi temp1, temp2, temp3;\n    for (i=0; i<sz; i++) {\n        int s=c[i].f, e=c[i].s;\n        if (cnt+e-s+1>=x) {\n            temp1.pb(P(s,s+x-cnt-1));\n            break;\n        }\n        temp1.pb(c[i]); \n        cnt+=e-s+1;\n    }\n    if (cnt+c[i].s-c[i].f+1>=y) {\n        temp2.pb(P(c[i].f+x-cnt,c[i].f+y-cnt-1));\n        temp3.pb(P(c[i].f+y-cnt,c[i].s));\n        for (i+=1;i<sz; i++) temp3.pb(c[i]);\n    } else {\n        temp2.pb(P(c[i].f+x-cnt,c[i].s));\n        cnt+=c[i].s-c[i].f+1;\n        int a=++i;\n        for (;i<sz; i++) {\n            int s=c[i].f, e=c[i].s;\n            if (cnt+e-s+1>=y) {\n                temp2.pb(P(s,s+y-cnt-1));\n                break;\n            }\n            temp2.pb(c[i]);\n            cnt+=e-s+1;\n        }\n        if (cnt+c[i].s-c[i].f+1!=y) temp3.pb(P(c[i].f+y-cnt,c[i].s));\n        for (i+=1; i<sz; i++) temp3.pb(c[i]);\n    }\n/*\n    for (i=0; i<sz(temp1); i++) printf(\"%d %d\\n\",temp1[i].f,temp1[i].s);\n    puts(\"\");\n    for (i=0; i<sz(temp2); i++) printf(\"%d %d\\n\",temp2[i].f,temp2[i].s);\n    puts(\"\");\n    for (i=0; i<sz(temp3); i++) printf(\"%d %d\\n\",temp3[i].f,temp3[i].s);\n    puts(\"\");\n*/\n    for (i=0; i<sz(temp3); i++) c.pb(temp3[i]);\n    for (i=0; i<sz(temp2); i++) c.pb(temp2[i]);\n    for (i=0; i<sz(temp1); i++) c.pb(temp1[i]);\n    temp1.clear(); temp2.clear(); temp3.clear();\n}\n\nint main() {\n    int n, m, p, q, r;\n    while (scanf(\"%d\",&n)) {\n        if (!n) break;\n        scanf(\"%d%d%d%d\",&m,&p,&q,&r);\n        c.pb(P(1,n));\n        for (int i=0; i<m; i++) {\n            int x, y; scanf(\"%d%d\",&x,&y);\n            shuffle(x,y);\n        }\n        int cnt=0, res=0;\n        for (int i=0; i<sz(c); i++) {\n            int s=c[i].f, e=c[i].s;\n//            printf(\"%d %d\\n\",s,e);\n            if (cnt+e-s+1>=p&&q>=cnt) {\n                int m=max(s+p-cnt-1,s), M=min(s+q-cnt-1,e);\n//                printf(\"%d %d\\n\",m,M);\n                if (r>=m&&r<=M) res+=r-m+1;\n                else if (r>=M) res+=M-m+1;\n            }\n            cnt+=e-s+1;\n        }\n        c.clear();\n        printf(\"%d\\n\",res);\n    }\n}"
  },
  {
    "language": "C++",
    "code": "#include <cstdio>\n#include <utility>\n#include <vector>\nusing namespace std;\ntypedef pair<int,int> P;\n#define min(a,b) ((a)<=(b)?(a):(b))\nvector<P> card;\nvector<P> solve(int x) {\n\tvector<P> A,B;\n\tint i,sum=0;\n\tfor(i=0;i<card.size() && sum<x;i++) {\n\t\tA.push_back(card[i]);\n\t\tsum+=(card[i].second-card[i].first+1);\n\t}\n\tA[A.size()-1].second-=(sum-x);\n\tif((sum-x)>0) {\n\t\tB.push_back(P(card[A.size()-1].second-(sum-x)+1,card[A.size()-1].second));\n\t}\n\tfor(i;i<card.size();i++) B.push_back(card[i]);\n\tcard=B;\n\treturn A;\n}\nint main() {\n\tint n,m,p,q,r;\n\twhile(scanf(\"%d\",&n),n) {\n\t\tscanf(\"%d\",&m);\n\t\tscanf(\"%d %d %d\",&p,&q,&r);\n\t\tcard.clear();\n\t\tcard.push_back(P(1,n));\n\t\tvector<P> A,B;\n\t\tfor(int i=0;i<m;i++) {\n\t\t\tint x,y;\n\t\t\tscanf(\"%d %d\",&x,&y);\n\t\t\tA=solve(x);\n\t\t\tB=solve(y-x);\n\t\t\tfor(int j=0;j<B.size();j++) card.push_back(B[j]);\n\t\t\tfor(int j=0;j<A.size();j++) card.push_back(A[j]);\n\t\t}\n\t\tA=solve(p-1);\n\t\tB=solve(q-p+1);\n\t\tint sum=0;\n\t\tfor(int i=0;i<B.size();i++) {\n\t\t\tif(B[i].first<=r) {\n\t\t\t\tsum+=(min(r,B[i].second)-B[i].first+1);\n\t\t\t}\n\t\t}\n\t\tprintf(\"%d\\n\",sum);\n\t}\n}"
  },
  {
    "language": "C++",
    "code": "#include <iostream>\n#include <vector>\n#include <utility>\n#include <algorithm>\n\nusing namespace std;\n\ntypedef pair<int, int> Range; // represents [first, second]\n\nint countOf(const Range &r) {\n    return r.second - r.first + 1;\n}\n\nint check(int R, const Range &r) {\n    if(R < r.first) return 0;\n    if(r.second <= R) return countOf(r);\n    return countOf(r)-countOf(Range(R+1, r.second));\n}\n\nint main() {\n    while(true) {\n        int N;\n        cin >> N;\n        if(!N) break;\n        int M, P, Q, R;\n        cin >> M >> P >> Q >> R;\n\n        vector<Range> cards;\n        cards.push_back(Range(1, N));\n        while(M--) {\n            int x, y;\n            cin >> x >> y;\n\n            vector<Range> next;\n            int cnts[] = {N-y, y-x, x};\n            int cntidx = 0;\n            int end = cards.size();\n            for(int i = cards.size()-1; i >= 0; --i) {\n                int cnt = countOf(cards[i]);\n                if(cnts[cntidx]-cnt <= 0) {\n                    int rem = cnts[cntidx];\n                    next.push_back(Range(cards[i].second-rem+1, cards[i].second));\n                    for(int j = i+1; j < end; ++j) {\n                        if(countOf(cards[j]) > 0) next.push_back(cards[j]);\n                    }\n                    cards[i].second -= rem;\n                    end = i+1;\n                    if(++cntidx == 4) {\n                        break;\n                    }\n                    else {\n                        ++i;\n                        continue;\n                    }\n                }\n                cnts[cntidx] -= cnt;\n            }\n            cards = next;\n        }\n        /*\n        for(int i = 0; i < cards.size(); ++i) {\n            cout << '(' << cards[i].first << \", \" << cards[i].second << ')' << endl;\n        }\n        */\n        int ans = 0;\n        int currCount = 0;\n        for(int i = 0; i < cards.size(); ++i) {\n            int cnt = countOf(cards[i]);\n            Range r = cards[i];\n\n            bool ok = false;\n            if(currCount < P && currCount+cnt >= P) {\n                r.first += P-currCount-1;\n                ok = true;\n                //cout << i << ' ' << ans << endl;\n            }\n            if(currCount < Q && currCount+cnt >= Q) {\n                r.second -= currCount+cnt-Q;\n                ok = true;\n                //cout << i << ' ' << ans << endl;\n            }\n            if(P <= currCount+cnt && currCount+cnt <= Q) ok = true;\n\n            if(ok) ans += check(R, r);\n            currCount += cnt;\n        }\n        cout << ans << endl;\n    }\n}"
  },
  {
    "language": "C++",
    "code": "#include<iostream>\n#include<cstring>\n#include<queue>\nusing namespace std;\n\nstruct tb{\n\tint f,t;\n\ttb(int f,int t): f(f),t(t) {}\n};\n\n\nint n,m,pr,q,r;\nint chx[5001][3];\n\nint main(void){\n\twhile(1){\n\t\tscanf(\"%d\",&n);\n\t\tif(n==0)break;\n\t\tqueue<tb> c;\n\t\tqueue<tb> d[4];\n\t\tc.push(tb(1,n));\n\t\tscanf(\"%d\",&m);\n\t\tscanf(\"%d%d%d\",&pr,&q,&r);\n\t\tfor(int i=0;i<m;i++){\n\t\t\tscanf(\"%d%d\",&chx[i][1],&chx[i][2]);\n\t\t}\n\t\tfor(int i=0;i<m;i++){\n\t\t\tint sh=1,size=0;\n\t\t\twhile(c.size()){\n\t\t\t\ttb p=c.front();c.pop();\n\t\t\t\tsize+=p.t-p.f+1;\n\t\t\t\tif(sh!=3){\n\t\t\t\t\tif(size<=chx[i][sh]){\n\t\t\t\t\t\td[sh].push(tb(p.f,p.t));\n\t\t\t\t\t\tif(size==chx[i][sh])sh++;\n\t\t\t\t\t}else if(sh==2){\n\t\t\t\t\t\tint x=size-p.t+p.f-1;\n\t\t\t\t\t\tint xx=chx[i][2]-x;\n\t\t\t\t\t\td[2].push(tb(p.f,p.f+xx-1));\n\t\t\t\t\t\td[3].push(tb(p.f+xx,p.t));\n\t\t\t\t\t\tsh++;\n\n\t\t\t\t\t}else if(sh==1 && size<=chx[i][2]){\n\t\t\t\t\t\tint x=size-p.t+p.f-1;\n\t\t\t\t\t\tint xx=chx[i][1]-x;\n\t\t\t\t\t\td[1].push(tb(p.f,p.f+xx-1));\n\t\t\t\t\t\td[2].push(tb(p.f+xx,p.t));\n\t\t\t\t\t\tif(size==chx[i][2])sh++;\n\t\t\t\t\t\tsh++;\n\t\t\t\t\t}else{\n\t\t\t\t\t\tint x=size-p.t+p.f-1;\n\t\t\t\t\t\tint xx=chx[i][1]-x;\n\t\t\t\t\t\tint x2=chx[i][2]-chx[i][1];\n\t\t\t\t\t\td[1].push(tb(p.f,p.f+xx-1));\n\t\t\t\t\t\td[2].push(tb(p.f+xx,p.f+xx+x2-1));\n\t\t\t\t\t\td[3].push(tb(p.f+xx+x2,p.t));\n\t\t\t\t\t\tsh=3;\n\t\t\t\t\t}\n\t\t\t\t}else d[sh].push(tb(p.f,p.t));\n\t\t\t}\n\t\t\tfor(int j=3;j>=1;j--){\n\t\t\t\twhile(d[j].size()){\n\t\t\t\t\ttb p=d[j].front();d[j].pop();\n\t\t\t\t\tint pf=p.f,pt=p.t;\n\t\t\t\t\tc.push(tb(pf,pt));\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t\tint size=1;\n\t\tint ans=0;\n\t\twhile(c.size()){\n\t\t\ttb p=c.front();c.pop();\n\t\t\tint x=p.f,y=p.t;\n\t\t\tint s=y-x+1;\n\t\t\tif(size<pr)x+=pr-size;\n\t\t\tif(size+s>q)y-=size+s-q-1;\n\t\t\tif(y>r)y=r;\n\t\t\tif(y>=x)ans+=y-x+1;\n\t\t\t//printf(\"%d %d %d %d\\n\",p.f,p.t,x,y);\n\t\t\tsize+=s;\n\t\t}\n\t\tprintf(\"%d\\n\",ans);\n\t}\n    return 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include <iostream>\n#include <vector>\nusing namespace std;\n\ntypedef pair<int,int> pint;\n\nint main(){\n    int n,m,p,q,r;\n    while(cin>>n,n){\n        cin>>m>>p>>q>>r;\n        vector<pint> cards;\n        cards.push_back(pint(1,n));\n        int x,y;        \n        while(m--){\n            cin>>x>>y;\n            vector<pint> a,b;\n            int count=0;\n            for(int i=0;i<cards.size();++i){\n                count += cards[i].second - cards[i].first +1;\n                if(count>=x){\n                    a.insert(a.begin(),cards.begin(),cards.begin()+i+1);\n                    a[i].second -= count - x;\n                    if(count>x){\n                        cards[i].first =a[i].second+1;--i;\n                    }\n                    cards.erase(cards.begin(),cards.begin()+i+1);\n                    break;\n                }\n            }\n            count=x;\n            for(int i=0;i<cards.size();++i){\n                count += cards[i].second - cards[i].first +1;\n                if(count>=y){\n                    b.insert(b.end(),cards.begin(),cards.begin()+i+1);\n                    b[i].second -= count - y;\n                    if(count>y){\n                        cards[i].first = b[i].second +1;\n                        --i;\n                    }\n                    cards.erase(cards.begin(),cards.begin()+i+1);\n                    break;\n                }\n            }\n            cards.insert(cards.end(),b.begin(),b.end());\n            cards.insert(cards.end(),a.begin(),a.end());\n        }\n        int count = 0,ans=0;\n        for(int i=0;i<cards.size();++i){\n            count += cards[i].second - cards[i].first +1;\n            if(count>=p){\n                cards[i].first = cards[i].second -count +p;\n                cards.erase(cards.begin(),cards.begin()+i);\n                break;\n            }\n        }\n        count=p-1;\n        for(int i=0;i<cards.size();++i){\n            count += cards[i].second - cards[i].first +1;\n            if(count>=q){\n                cards[i].second += -count+q;              \n                cards.erase(cards.begin()+i+1,cards.end());\n                break;\n            }\n        }\n        for(int i=0;i<cards.size();++i){\n            ans += max(0,min(r-cards[i].first+1,cards[i].second-cards[i].first+1));\n        }\n        cout<<ans<<endl;\n    }\n    return 0;\n}"
  },
  {
    "language": "C++",
    "code": "#define _USE_MATH_DEFINES\n#define INF 0x3f3f3f3f\n\n#include <iostream>\n#include <cstdio>\n#include <sstream>\n#include <cmath>\n#include <cstdlib>\n#include <algorithm>\n#include <queue>\n#include <stack>\n#include <limits>\n#include <map>\n#include <string>\n#include <cstring>\n#include <set>\n#include <deque>\n#include <bitset>\n#include <list>\n#include <cctype>\n#include <utility>\n  \nusing namespace std;\n  \ntypedef long long ll;\ntypedef pair <ll,ll> P;\n  \nstatic const double EPS = 1e-8;\n  \nstatic const int tx[] = {0,1,0,-1};\nstatic const int ty[] = {-1,0,1,0};\n\nint main(){\n  ll total_cards;\n  while(~scanf(\"%lld\",&total_cards)){\n    if(total_cards == 0) break;\n    ll total_shuffles;\n    ll first,last,upper;\n\n    scanf(\"%lld\",&total_shuffles);\n    scanf(\"%lld %lld %lld\",&first,&last,&upper);\n    \n    vector<P> cards;\n    cards.push_back(P(1,total_cards));\n\n    for(int shuffle_idx=0;shuffle_idx<total_shuffles;shuffle_idx++){\n      ll x,y;\n      scanf(\"%lld %lld\",&x,&y);\n      //x -> none\n      //y -> 1\n      //n -> x+1\n      //C -> B -> A\n      vector<P> A;\n      vector<P> B;\n      vector<P> C;\n      vector<P> next;\n\n      ll sum = 0;\n      ll prev_sum = 0;\n      for(int j=0;j<cards.size();j++){\n        prev_sum = sum;\n        sum += cards[j].second - cards[j].first + 1;\n        if(prev_sum < x){\n          if(sum <= x){\n            A.push_back(cards[j]);\n          }\n          else if(sum > x && sum <= y){\n            A.push_back(P(cards[j].first,cards[j].first + (x - prev_sum - 1)));\n            B.push_back(P(cards[j].first + (x - prev_sum),\n                          cards[j].second));\n          }\n          else if(sum > y){\n            A.push_back(P(cards[j].first,cards[j].first + (x - prev_sum - 1)));\n            B.push_back(P(cards[j].first + (x - prev_sum),\n                          cards[j].first + (x - prev_sum) + (y - x - 1)));\n            C.push_back(P(cards[j].first + (x - prev_sum) + (y - x),\n                          cards[j].second));\n          }\n        }\n        else if(prev_sum >= x){\n          if(prev_sum < y){\n            if(sum <= y){\n              B.push_back(P(cards[j].first,cards[j].second));\n            }\n            else if(sum > y){\n              B.push_back(P(cards[j].first,cards[j].first + (y - prev_sum - 1)));\n              C.push_back(P(cards[j].first + (y - prev_sum),cards[j].second));\n            }\n          }\n          else if(prev_sum >= y){\n            C.push_back(P(cards[j].first,cards[j].second));\n          }\n        }\n      }\n      for(int i=0;i<C.size();i++){\n        next.push_back(C[i]);\n        // cout << \"C<f,s>=\" << C[i].first << \",\" << C[i].second << endl;\n      }\n      for(int i=0;i<B.size();i++){\n        next.push_back(B[i]);\n        // cout << \"B<f,s>=\" << B[i].first << \",\" << B[i].second << endl;\n      }\n      for(int i=0;i<A.size();i++){\n        next.push_back(A[i]);\n        // cout << \"A<f,s>=\" << A[i].first << \",\" << A[i].second << endl;\n      }\n      // cout << endl;\n      cards = next;\n    }\n\n    ll offset = 0;\n    ll res = 0;\n    for(int i=0;i<cards.size();i++){\n      ll current = cards[i].second - cards[i].first + 1;\n      if(offset + current < first){\n        offset += current;\n        continue;\n      }\n      if(offset > last){\n        offset += current;\n        continue;\n      }\n\n      ll lhs = -1;\n      ll rhs = 1000000010;\n\n      for(int round = 0; round < 50; round++){\n        ll mid = (lhs + rhs) / 2;\n        if(cards[i].first + mid > upper){\n          rhs = mid;\n        }\n        if(cards[i].first + mid <= upper){\n          lhs = mid;\n        }\n      }\n\n      ll count = min(rhs,cards[i].second - cards[i].first + 1);\n\n      // cout << \"not considering last count: \" << count << endl;\n      \n      if(offset + count >= last){\n        count -= offset + count - last;\n      }\n\n      if(offset < first){\n        count -= first - offset - 1;\n      }\n\n      if(count > 0){\n        res += count;\n      }\n\n      // cout << \"offset \" << offset << endl;\n      // cout << \"<f,s>=\" << cards[i].first << \",\" << cards[i].second << endl;\n      // cout << \"count=\" << count << endl;\n\n      offset += current;\n    }\n    printf(\"%lld\\n\",res);\n\n  }\n}"
  },
  {
    "language": "C++",
    "code": "#include<bits/stdc++.h>\n#include<algorithm>\n#include<vector>\n#include<queue>\nusing namespace std;\ntypedef long long ll;\ntypedef pair<int,int> P;\n\nint n,m,p,q,r;\n\nint main(){\n\twhile(scanf(\"%d\",&n),n){\n\t\tscanf(\"%d\",&m);\n\t\tscanf(\"%d%d%d\",&p,&q,&r);\n\t\tvector<P> *z=new vector<P>;\n\t\tz->push_back(P(1,n));\n\t\tfor(int i=0;i<m;i++){\n\t\t\tint x[3]={0,0,n};\n\t\t\tscanf(\"%d%d\",&x[0],&x[1]);\n\t\t\tvector<P> *b=new vector<P>;\n\t\t\tvector<P> c[3]; int count=0,cx=1;\n\t\t\tint j=0;\n\t\t\twhile(cx<=n)\n\t\t\t\tif(cx+(z->at(j).second)-(z->at(j).first)<=x[count]){ c[count].push_back(z->at(j)); cx+=(z->at(j).second)-(z->at(j).first)+1; j++;}\n\t\t\t\telse{ if(cx!=x[count]+1) c[count].push_back(P(z->at(j).first,z->at(j).first+x[count]-cx)); z->at(j).first+=x[count]-cx+1; cx=x[count]+1; count++;}\n\t\t\tfor(j=2;j>=0;j--)\n\t\t\t\tfor(int k=0;k<c[j].size();k++) b->push_back(c[j][k]);\n\t\t\tdelete z;\n\t\t\tz=b;\n\t\t}\n\t\tint res=0,count=1;\n\t\tfor(int i=0;i<z->size();i++){\n\t\t\tP pp=z->at(i); int c1=count+pp.second-pp.first;\n\t\t\tif(count>=p&&q>=c1) ;\n\t\t\telse if(count<=p&&p<=c1) pp.first+=p-count;\n\t\t\telse if(count<=q&&q<=c1) pp.second-=c1-q;\n\t\t\telse { count=c1+1; continue;}\n\t\t\tcount=c1+1;\n\t\t\tif(r>=pp.second) res+=pp.second-pp.first+1;\n\t\t\telse if(r>=pp.first) res+=r-pp.first+1;\n\t\t}\n\t\tprintf(\"%d\\n\",res);\n\t}\n}"
  },
  {
    "language": "C++",
    "code": "#include \"bits/stdc++.h\"\n#include<unordered_map>\n#include<unordered_set>\n#pragma warning(disable:4996)\nusing namespace std;\nusing ld = long double;\nconst ld eps = 1e-9;\n\n//// < \"d:\\d_download\\visual studio 2015\\projects\\programing_contest_c++\\debug\\a.txt\" > \"d:\\d_download\\visual studio 2015\\projects\\programing_contest_c++\\debug\\b.txt\"\n\n\nint main() {\n\twhile (1) {\n\t\tint N, M; cin >> N;\n\t\tif (!N)break;\n\t\tcin >> M;\n\t\tint P, Q, R; cin >> P >> Q >> R;\n\t\tvector<pair<int, int>>cards(1, make_pair(1, N));\n\t\tfor (int i = 0; i < M; ++i) {\n\t\t\tint x, y; cin >> x >> y;\n\t\t\tvector<pair<int, int>>a, b, c;\n\t\t\tint h = 0;\n\t\t\tint n = 0;\n\t\t\tfor (; n < cards.size(); ++n) {\n\t\t\t\tauto acard(cards[n]);\n\t\t\t\tint nh = h + acard.second;\n\t\t\t\tif (nh > x) {\n\t\t\t\t\ta.push_back(make_pair(acard.first, x - h));\n\t\t\t\t\tif (nh > y) {\n\t\t\t\t\t\tb.push_back(make_pair(acard.first+(x-h), y-x));\n\t\t\t\t\t\tc.push_back(make_pair(acard.first +(y-h), nh - y));\n\t\t\t\t\t}\n\t\t\t\t\telse {\n\t\t\t\t\t\tb.push_back(make_pair(acard.first + (x - h), nh - x));\n\t\t\t\t\t}\n\t\t\t\t\th = nh;\n\t\t\t\t\tn++;\n\t\t\t\t\tbreak;\n\t\t\t\t}\n\t\t\t\telse if (nh == x) {\n\t\t\t\t\ta.push_back(make_pair(acard.first, x - h));\n\t\t\t\t\th = nh;\n\t\t\t\t\tn++;\n\t\t\t\t\tbreak;\n\t\t\t\t}\n\t\t\t\telse {\n\t\t\t\t\ta.push_back(acard);\n\t\t\t\t\th = nh;\n\t\t\t\t}\n\t\t\t}\n\t\t\tfor (; n < cards.size(); ++n) {\n\t\t\t\tauto acard(cards[n]);\n\t\t\t\tint nh = h + acard.second;\n\t\t\t\tif (nh > y) {\n\t\t\t\t\tb.push_back(make_pair(acard.first, y-h));\n\t\t\t\t\tc.push_back(make_pair(acard.first + y-h, nh - y));\n\t\t\t\t\th = nh;\n\t\t\t\t\tn++;\n\t\t\t\t\tbreak;\n\t\t\t\t}\n\t\t\t\telse if (nh == y) {\n\t\t\t\t\tb.push_back(make_pair(acard.first, y - h));\n\t\t\t\t\th = nh;\n\t\t\t\t\tn++;\n\t\t\t\t\tbreak;\n\t\t\t\t}\n\t\t\t\telse {\n\t\t\t\t\tb.push_back(acard);\n\t\t\t\t\th = nh;\n\t\t\t\t}\n\t\t\t}\n\t\t\tfor (; n < cards.size(); ++n) {\n\t\t\t\tauto acard(cards[n]);\t\t\n\t\t\t\tc.push_back(acard);\n\t\t\t}\n\t\t\tvector<pair<int, int>>nextcards(c);\n\t\t\tnextcards.insert(nextcards.end(), b.begin(), b.end());\n\t\t\tnextcards.insert(nextcards.end(), a.begin(), a.end());\n\n\t\t\tcards = nextcards;\n\t\t}\n\t\tint h = 0 ;\n\t\tint ans = 0;\n\t\tfor (int n = 0; n < cards.size(); ++n) {\n\t\t\tauto card(cards[n]);\n\t\t\tint nh = h + card.second;\n\t\t\tif (h < P&&nh > P) {\n\t\t\t\tint pnum = card.first + P - h-1;\n\t\t\t\tif (pnum > R)ans += 0;\n\t\t\t\telse {\n\t\t\t\t\tans += min(R - pnum+1, nh - P);\n\t\t\t\t}\n\n\t\t\t}\n\t\t\tif (h >= P) {\n\t\t\t\tint pnum = card.first;\n\t\t\t\tif (pnum > R)ans += 0;\n\t\t\t\telse {\n\t\t\t\t\tans += min(R - pnum+1, card.second);\n\t\t\t\t}\n\t\t\t}\n\t\t\th = nh;\n\t\t}\n\t\th = 0;\n\t\tfor (int n = 0; n < cards.size(); ++n) {\n\t\t\tauto card(cards[n]);\n\t\t\tint nh = h + card.second;\n\t\t\tif (h <Q&&nh>Q) {\n\t\t\t\tint pnum = card.first;\n\t\t\t\tif (pnum > R)ans += 0;\n\t\t\t\telse {\n\n\t\t\t\t\tans += min(Q - pnum + 1, Q - h);\n\t\t\t\t}\n\n\t\t\t}\n\t\t\tif (nh <= Q) {\n\t\t\t\tint pnum = card.first;\n\t\t\t\tif (pnum > R)ans += 0;\n\t\t\t\telse {\n\t\t\t\t\tans += min(R - pnum + 1, card.second);\n\t\t\t\t}\n\t\t\t}\n\t\t\th = nh;\n\t\t}\n\t\tans -= R;\n\t\tcout << ans << endl;\n\t}\n\treturn 0;\n}"
  },
  {
    "language": "C++",
    "code": "\n#include<iostream>\nusing namespace std;\nint cards,n,i,p,q,r,x[5000],y[5000],counter;\n  int numberStart[10001];\n  int numberFast[10001];\n  int numberEnd[10001];\nint numberLong(int value){\n\treturn numberEnd[value]-numberStart[value]+1;\n}\n\nint seach(int k ){\n  int l=0;\n\n  \n  for ( int a=1;a<=10000;a++){\n    if (numberStart[a]<=k && k<numberEnd[a]){\n      l=numberFast[a];\n      return l;\n    }\n    }\n\t\n  return -100;\n  }\nint seachB(int NumberFast){\n  int l=0;\n  for ( int a=1;a<=10000;a++){\n    if (NumberFast==numberFast[a]){\n      l=a;\n      return l;\n    }\n    }\n  return -100;\n  }\nint seachC(int seed){\n  //return seachB(seach(seed));\n\t\t\tint l=0;\n  for (int a=1;a<=10000;a++){\n\tif(seed>l+numberLong(seachB(a))){\n\tl+=numberLong(seachB(a));\n\t}\n\telse{\n\t return numberFast[seachB(a)];\n\t}\n  }\n return -100;\n\t\n}\nint searchD(int seed){\n\t\tint l=0;\n  for (int a=1;a<=10000;a++){\n\tif(seed>l+numberLong(seachB(a))){\n\tl+=numberLong(seachB(a));\n\t}\n\telse{\n\t return numberFast[seachB(a)];\n\t}\n  }\n return -100;\n\t\n}\nint searchNumber(int value){\n\tint l=0;\n  for (int a=1;a<=10000;a++){\n\tif(value>l+numberLong(seachB(a))){\n\tl+=numberLong(seachB(a));\n\t}\n\telse{\n\t return numberStart[seachB(a)]+value-l-1;\n\t}\n  }\n return -100;\n}\n\nint make(int sequence,int counter ){\n  counter++;\n // numberStart[counter]=j;\n // numberEnd[counter]=k;\n  return 0;\n}\nint StartHead(int value){\n\tint longs=1;\n\tfor (int i=1;i<=counter;i++){\n\t\n\t\tif (numberFast[i]<numberFast[value]){\n\t\t\tlongs+=numberLong(i);\n\t\t}\n\t}\n\treturn longs;\n\n\n}\nvoid cut(int g){\n\tif(searchD(g)==searchD(g+1)){\n  //カットする場所が入ってる数列を求める\n  int seachX=seachB(seachC(g));\n  int seachXX=searchNumber(g);\n//数列ができる範囲の後ろの番号FASTを変える\n     for(int j=1;j<=counter;j++){\n      if (numberFast[j]>=numberFast[seachX]+1){\n      numberFast[j]++;\n     }\n    }\n\n  //の数列の後ろに新しい数列を作る\n counter++;\n //for \n make(seachX,counter);\n  numberFast[counter]=numberFast[seachX]+1;\n  numberStart[counter] =searchNumber(g)+1;\n  numberEnd[counter]=numberEnd[seachX];\n  //できた数列の前の数列の最後を調整する\n  numberEnd[seachX]=searchNumber(g);\n \n\t}\n}\nvoid shuffle(int x,int y){\n\t\n\t\n\tint  numberFastNew[10001];\n\n\tint newCounter[3];\n\tfor(int i=0;i<3;i++){\n\t\tnewCounter[i]=0;\n\t}\n\tfor(int j=1;j<=counter;j++){\n\t\tif (StartHead(j)>y){\n\t\t\tnewCounter[0]++;\n\t\tnumberFastNew[j]=0;\n\t\t}\n\t}\n\t\n\tfor(int j=1;j<=counter;j++){\n\t\tif (StartHead(j)>x && StartHead(j)+numberLong(j)-1<=y){\n\t\t\tnewCounter[1]++;\n\t\tnumberFastNew[j]=1;\n\t\t}\n\t}\n\t\n\tfor(int j=1;j<=counter;j++){\n\t\t\tif (StartHead(j)+numberLong(j)-1<=x){\n\t\t\tnewCounter[2]++;\n\t\tnumberFastNew[j]=2;\n\t\t}\n\t}\n\t\n\tfor(int j=1;j<=counter;j++){\n\t\tswitch(numberFastNew[j]){\n\t\t\tcase 0:\n\t\t\t\tnumberFast[j]+=-newCounter[1]-newCounter[2];\n\t\t\t\tbreak;\n\t\t\tcase 1:\n\t\t\t\tnumberFast[j]+=newCounter[0]-newCounter[2];\n\t\t\t\tbreak;\n\t\t\tcase 2:\n\t\t\t\tnumberFast[j]+=newCounter[1]+newCounter[0];\n\t\t\t\tbreak;\n\t\t}\n\n\t}\n\n\t\n  /*  making[];\n  numbersb(counter);\n    getter(x+1);\n    numbersb(counter)=y-x;\n    getter(y+1);\n    numbersb(counter)=cards-y;\n  }\n  \n  for(int  j=1;j<=cards;j++){\n    if (p>=j && p<=j && numbers[j]<=r){\n      cout <<  numbers[j] << endl;\n    }\n  \n\n  for (int i=1;i<=2;i++){\n  cout << numberStart[i] << \" \" << numberEnd[i] << \" \" << numberFast[i] << \" \" << endl;\n  }\n  */\n}\n\n\nint main(void)\n{\n\twhile(true){\n\tcards=0;\n\tn=0;\n\tcounter=0;\n\tint points=0;\n  counter=1;\n  cin >> cards;\n  if (cards==0){\n\t  break;\n  }\n  numberStart[1]=1;\n  numberEnd[1]=cards;\n  numberFast[1]=1;\n  cin >> n;\n  cin >> p  >> q  >> r ;\n  for (i=1;i<=n;i++){\n    cin >> x[i] >> y[i];\n  }\n  for (i=1;i<=n;i++){\n     cut(x[i]);\n\t \n      cut(y[i]);\n\t  \n     shuffle(x[i],y[i]);\n  }\n\n  for(int j=p;j<=q;j++){\n\t  if(searchNumber(j)<=r){\n\t\t  points++;\n\t  }\n  }\n  cout << points << endl;\n\t}\n}"
  },
  {
    "language": "C++",
    "code": "#include <iostream>\n#include <iomanip>\n#include <string>\n#include <vector>\n#include <queue>\n#include <algorithm>\n#include <utility>\n#include <cmath>\n#include <map>\n#include <set>\n#include <stack>\n#include <cstdio>\n#include <cstdlib>\n#include <cstring>\n\n#define INF_LL 1e18\n#define INF 1e9\n\n#define REP(i, n) for(int i = 0;i < (n);i++)\n#define FOR(i, a, b) for(int i = (a);i < (b);i++)\n#define all(x) x.begin(),x.end()\n\n#define fst first\n#define snd second\n\nusing namespace std;\n\nusing ll = long long;\nusing PII = pair<int, int>;\nusing PLL = pair<ll, ll>;\n\nint main(void){\n\tvector<PLL> card;\n\tint N, M;\n\tint p, q, r;\n\tcin >> N >> M;\n\tcin >> p >> q >> r;\n\tcard.push_back({1, N+1});\n\tREP(i, M){\n\t\tint x, y;\n\t\tcin >> x >> y;\n\t\tint sum = 0;\n\t\tint c = 0;\n\t\tvector<PLL> tmp1, tmp2, tmp3;\n\t\twhile(sum < x){\n\t\t\tif(sum + card[c].second-card[c].first <= x){\n\t\t\t\tsum += card[c].second-card[c].first;\n\t\t\t\ttmp1.push_back(card[c]);\n\t\t\t}else{\n\t\t\t\ttmp1.push_back({card[c].first, card[c].first+x-sum});\n\t\t\t\tif(sum + card[c].second-card[c].first <= y){\n\t\t\t\t\ttmp2.push_back({card[c].first+x-sum, card[c].second});\n\t\t\t\t\tsum += card[c].second-card[c].first;\n\t\t\t\t}else{\n\t\t\t\t\ttmp2.push_back({card[c].first+x-sum, card[c].first+y-sum});\n\t\t\t\t\ttmp3.push_back({card[c].first+y-sum, card[c].second});\n\t\t\t\t\tsum += card[c].second-card[c].first;\n\t\t\t\t}\n\t\t\t}\n\t\t\tc++;\n\t\t}\n\t\twhile(sum < y){\n\t\t\tif(sum + card[c].second-card[c].first <= y){\n\t\t\t\tsum += card[c].second-card[c].first;\n\t\t\t\ttmp2.push_back(card[c]);\n\t\t\t}else{\n\t\t\t\ttmp2.push_back({card[c].first, card[c].first+y-sum});\n\t\t\t\ttmp3.push_back({card[c].first+y-sum, card[c].second});\n\t\t\t\tsum += card[c].second-card[c].first;\n\t\t\t}\n\t\t\tc++;\n\t\t}\n\t\twhile(c < card.size()){\n\t\t\ttmp3.push_back(card[c]);\n\t\t\tc++;\n\t\t}\n\t\tREP(j, tmp2.size()){\n\t\t\ttmp3.push_back(tmp2[j]);\n\t\t}\n\t\tREP(j, tmp1.size()){\n\t\t\ttmp3.push_back(tmp1[j]);\n\t\t}\n\t\tcard = tmp3;\n\t}\n\tll sum = 0;\n\tll res = 0;\n\tll c = 0;\n\twhile(sum + card[c].second - card[c].first < p){\n\t\tc++;\n\t\tsum += card[c].second-card[c].first;\n\t}\n\tcout << endl;\n\tif(p-sum+card[c].first <= r){\n\t\tif(card[c].second <= r){\n\t\t\tres += card[c].second-(p-sum+card[c].first)+1;\n\t\t}else{\n\t\t\tres += r-(p-sum+card[c].first)+1;\n\t\t}\n\t}\n\tsum += card[c].second-card[c].first;\n\tc++;\n\twhile(sum + card[c].second - card[c].first<= q){\n\t\tif(card[c].second <= r){\n\t\t\tres += card[c].second-card[c].first+1;\n\t\t}else if(card[c].first <= r){\n\t\t\tres += r-card[c].first+1;\n\t\t}\n\t\tsum += card[c].second-card[c].first;\n\t\tc++;\n\t}\n\n\tif(sum <= q){\n\t\tif(card[c].first+q-sum <= r){\n\t\t\tres += q-sum;\n\t\t}else if(card[c].first <= r){\n\t\t\tres += r-card[c].first+1;\n\t\t\tif(card[c].second <= r){\n\t\t\t\tres += card[c].second-r+1;\n\t\t\t}\n\t\t}\n\t}\n\tcout << res << endl;\n}"
  },
  {
    "language": "C++",
    "code": "#include <iostream>\n#include <vector>\n#include <utility>\n#include <algorithm>\n\nusing namespace std;\n\nint main()\n{\n    while (1)\n    {\n        int n, m, p, q, r, x, y, sum, cnt;\n        bool ok;\n        vector<pair<int, int>> vec, v1, v2, v3;\n        cin>>n;\n        if (!n) break;\n        cin>>m>>p>>q>>r;\n        vec.push_back({1,n});\n        for (int i=0; i<m; i++)\n        {\n            sum=0;\n            ok=true;\n            v1.clear();\n            v2.clear();\n            v3.clear();\n            cin>>x>>y;\n            auto u=vec.begin();\n            cnt=0;\n            while (ok)\n            {\n                u++;\n                if (cnt==0) { u--; cnt=1; }\n                sum+=u->second;\n                if (sum<=x) v1.push_back({u->first, u->second});\n                else\n                {\n                    sum-=u->second;\n                    if (x!=sum)\n                    {\n                        v1.push_back({u->first, (x-sum)});\n                        u->first+=(x-sum);\n                        u->second-=(x-sum);\n                        sum+=(x-sum);\n                    }\n                    ok=false;\n                }\n            }\n            ok=true;\n            cnt=0;\n            while (ok)\n            {\n                u++;\n                if (cnt==0) { u--; cnt=1; }\n                sum+=u->second;\n                if (sum<=y) v2.push_back({u->first, u->second});\n                else\n                {\n                    sum-=u->second;\n                    if (y!=sum)\n                    {\n                        v2.push_back({u->first, (y-sum)});\n                        u->first+=(y-sum);\n                        u->second-=(y-sum);\n                        sum+=(y-sum);\n                    }\n                    ok=false;\n                }\n            }\n            cnt=0;\n            while (u!=vec.end())\n            {\n                u++;\n                if (cnt==0) { u--; cnt=1; }\n                if (u!=vec.end())\n                {\n                    v3.push_back({u->first, u->second});\n                }\n            }\n            vec.swap(v3);\n            vec.insert(vec.end(), v2.begin(), v2.end());\n            vec.insert(vec.end(), v1.begin(), v1.end());\n        }\n        cnt=0;\n        sum=0;\n        ok=true;\n        auto u=vec.begin();\n        v1.clear();\n        while (ok)\n        {\n            u++;\n            if (cnt==0) { u--; cnt=1; }\n            sum+=u->second;\n            if (sum>=p)\n            {\n                sum-=u->second;\n                u->first+=(p-sum-1);\n                u->second-=(p-sum-1);\n                sum+=(p-sum-1);\n                ok=false;\n            }\n        }\n        cnt=0;\n        ok=true;\n        while (ok)\n        {\n            u++;\n            if (cnt==0) { u--; cnt=1; }\n            sum+=u->second;\n            if (sum<=q) v1.push_back({u->first, u->second});\n            else\n            {\n                sum-=u->second;\n                if (q!=sum) v1.push_back({u->first, (q-sum)});\n                ok=false;\n            }\n        }\n        cnt=0;\n        for (auto w : v1)\n        {\n            if (w.first<=r) cnt+=min(r-w.first+1, w.second);\n        }\n        cout<<cnt<<'\\n';\n    }\n    return 0;\n}\n\n"
  },
  {
    "language": "C++",
    "code": "#include<iostream>\n#include<cstdio>\n#include<vector>\n#include<queue>\n#include<algorithm>\n#include<functional>\n#include<cstring>\n#include<iterator>\nusing namespace std;\n\nconst int INF = 1e9;\n\nint main() {\n\tint n, m, pp, q, r;\n\n\twhile (cin >> n&&n){\t\n\t\tint save = -1, ans = 0;\n\t\tvector<int>vep, vep2, vep3;\n\t\tvep.push_back(1);\n\t\tvep.push_back(n);\n\t    vector<int> vec, vec2, vec3;\n\t\tvec.push_back(1);\n\t\tvec.push_back(n);\n\t\tcin >> m >> pp >> q >> r;\n\t\tfor (int i = 0; i < m; i++) {\n\t\t\tint x, y, p, p2;\n\t\t\tscanf(\"%d%d\", &x, &y);\n\t\t\tp = lower_bound(vec.begin(), vec.end(), x) - vec.begin();\n\t\t\tif (vec[p] != x) {\n\t\t\t\tvec.insert(vec.begin() + p, x);\n\t\t\t\tvep.insert(vep.begin() + p, vec[p] - vec[p - 1] + vep[p - 1]);\n\t\t\t}\n\t\t\tif (vec[p] + 1 != vec[p + 1]) {\n\t\t\t\tvec.insert(vec.begin() + p + 1, x + 1);\n\t\t\t\tvep.insert(vep.begin() + p + 1, vep[p] + 1);\n\t\t\t}\n\t\t\tp2 = lower_bound(vec.begin(), vec.end(), y) - vec.begin();\n\t\t\tif (vec[p2] != y) {\n\t\t\t\tvec.insert(vec.begin() + p2, y);\n\t\t\t\tvep.insert(vep.begin() + p2, vec[p2] - vec[p2 - 1] + vep[p2 - 1]);\n\t\t\t}\n\t\t\tif (vec[p2] + 1 != vec[p2 + 1]) {\n\t\t\t\tvec.insert(vec.begin() + p2 + 1, y + 1);\n\t\t\t\tvep.insert(vep.begin() + p2 + 1, vep[p2] + 1);\n\t\t\t}\n\t\t\tfor (int j = p2 + 1; j < vec.size(); j++) {\n\t\t\t\tvec2.push_back(vec[j] - vec[p2 + 1] + 1);\n\t\t\t\tvep2.push_back(vep[j]);\n\t\t\t}\n\t\t\tint size = vec2[vec2.size() - 1];\n\t\t\tfor (int j = p + 1; j < p2 + 1; j++) {\n\t\t\t\tvec2.push_back(vec[j] - vec[p + 1] + 1 + size);\n\t\t\t\tvep2.push_back(vep[j]);\n\t\t\t}\n\t\t\tsize = vec2[vec2.size() - 1];\n\t\t\tfor (int j = 0; j < p + 1; j++) {\n\t\t\t\tvec2.push_back(vec[j] - vec[0] + 1+size);\n\t\t\t\tvep2.push_back(vep[j]);\n\t\t\t}\n\t\t\tvec3 = vec;\n\t\t\tvep3 = vep;\n\t\t\tvec = vec2;\n\t\t\tvep = vep2;\n\t\t\tvec2 = vec3;\n\t\t\tvep2 = vep3;\n\t\t\tvec2.clear();\n\t\t\tvep2.clear();\n\t\t}\n\t\tint p, p2;\n\t\tp = lower_bound(vec.begin(), vec.end(), pp) - vec.begin();\n\t\t\n\t\tif (vec[p] != pp) {\n\t\t\tvec.insert(vec.begin() + p, pp);\n\t\t\tvep.insert(vep.begin() + p, vec[p] - vec[p - 1] + vep[p - 1]);\n\t\t}\n\t\tif (vec[p] + 1 != vec[p + 1]) {\n\t\t\tvec.insert(vec.begin() + p + 1, pp + 1);\n\t\t\tvep.insert(vep.begin() + p + 1, vep[p] + 1);\n\t\t}\n\t\tp2 = lower_bound(vec.begin(), vec.end(), q) - vec.begin();\n\t\tif (vec[p2] != q) {\n\t\t\tvec.insert(vec.begin() + p2, q);\n\t\t\tvep.insert(vep.begin() + p2, vec[p2] - vec[p2 - 1] + vep[p2 - 1]);\n\t\t}\n\t\tif (vec[p2] + 1 != vec[p2 + 1]) {\n\t\t\tvec.insert(vec.begin() + p2 + 1, q + 1);\n\t\t\tvep.insert(vep.begin() + p2 + 1, vep[p2] + 1);\n\t\t}\n\t\tfor (int i = p; i <= p2; i++) {\n\t\t\tif (i + 1<=p2 && vep[i + 1] - vep[i] == vec[i + 1] - vec[i]) {\n\t\t\t\tif (vep[i + 1] <= r) {\n\t\t\t\t\tans += vep[i + 1] - vep[i];\n\t\t\t\t\tif (save != vep[i])\n\t\t\t\t\t\tans++;\n\t\t\t\t\tsave = vep[i + 1];\n\t\t\t\t}\n\t\t\t\tif (vep[i] <= r&&vep[i + 1] > r) {\n\t\t\t\t\tans += r - vep[i];\n\t\t\t\t\tif (save != vep[i])\n\t\t\t\t\t\tans++;\n\t\t\t\t\tsave = q;\n\t\t\t\t}\n\t\t\t}\n\t\t\telse{\n\t\t\t\tif (vep[i] <= r&&save != vep[i]) {\n\t\t\t\t\tans++;\n\t\t\t\t\tsave = vep[i];\n\t\t\t\t}\n\t\t\t}\n\t}\n\t\tcout << ans << endl;\n\t}\n}"
  },
  {
    "language": "C++",
    "code": "\n#include<iostream>\nusing namespace std;\nint cards,n,i,p,q,r,x[5000],y[5000],counter;\n  int numberStart[10001];\n  int numberFast[10001];\n  int numberEnd[10001];\n  int searchB[10001];\nint numberLong(int value){\n\treturn numberEnd[value]-numberStart[value]+1;\n}\n\nint seach(int k ){\n  int l=0;\n\n  \n  for ( int a=1;a<=counter+1;a++){\n    if (numberStart[a]<=k && k<numberEnd[a]){\n      l=numberFast[a];\n      return l;\n    }\n    }\n\t\n  return -100;\n  }\nint seachC(int seed){\n  //return seachB(seach(seed));\n\t\t\tint l=0;\n  for (int a=1;a<=counter+1;a++){\n\tif(seed>l+numberLong(searchB[a])){\n\tl+=numberLong(searchB[a]);\n\t}\n\telse{\n\t return numberFast[searchB[a]];\n\t}\n  }\n return -100;\n\t\n}\nint searchD(int seed){\n\t\tint l=0;\n  for (int a=1;a<=counter+1;a++){\n\tif(seed>l+numberLong(searchB[a])){\n\tl+=numberLong(searchB[a]);\n\t}\n\telse{\n\t return numberFast[searchB[a]];\n\t}\n  }\n return -100;\n\t\n}\nint searchNumber(int value){\n\tint l=0;\n  for (int a=1;a<=counter+1;a++){\n\tif(value>l+numberLong(searchB[a])){\n\tl+=numberLong(searchB[a]);\n\t}\n\telse{\n\t return numberStart[searchB[a]]+value-l-1;\n\t}\n  }\n return -100;\n}\n\nint make(int sequence,int counter ){\n  counter++;\n // numberStart[counter]=j;\n // numberEnd[counter]=k;\n  return 0;\n}\nint StartHead(int value){\n\tint longs=1;\n\tfor (int i=1;i<=counter;i++){\n\t\n\t\tif (numberFast[i]<numberFast[value]){\n\t\t\tlongs+=numberLong(i);\n\t\t}\n\t}\n\treturn longs;\n\n\n}\nvoid cut(int g){\n\tif(searchD(g)==searchD(g+1)){\n  //カットする場所が入ってる数列を求める\n  int seachX=searchB[seachC(g)];\n  int seachXX=searchNumber(g);\n//数列ができる範囲の後ろの番号FASTを変える\n     for(int j=1;j<=counter;j++){\n      if (numberFast[j]>=numberFast[seachX]+1){\n      numberFast[j]++;\n     }\n    }\n\n  //の数列の後ろに新しい数列を作る\n counter++;\n //for \n make(seachX,counter);\n  numberFast[counter]=numberFast[seachX]+1;\n  numberStart[counter] =searchNumber(g)+1;\n  numberEnd[counter]=numberEnd[seachX];\n  //できた数列の前の数列の最後を調整する\n  numberEnd[seachX]=searchNumber(g);\n \n\n  \n  for ( int a=1;a<=counter+1;a++){\n\t  searchB[numberFast[a]]=a;\n    }\n    }\n\n}\nvoid shuffle(int x,int y){\n\t\n\t\n\tint  numberFastNew[10001];\n\n\tint newCounter[3];\n\tfor(int i=0;i<3;i++){\n\t\tnewCounter[i]=0;\n\t}\n\tfor(int j=1;j<=counter;j++){\n\t\tif (StartHead(j)>y){\n\t\t\tnewCounter[0]++;\n\t\tnumberFastNew[j]=0;\n\t\t}\n\t}\n\t\n\tfor(int j=1;j<=counter;j++){\n\t\tif (StartHead(j)>x && StartHead(j)+numberLong(j)-1<=y){\n\t\t\tnewCounter[1]++;\n\t\tnumberFastNew[j]=1;\n\t\t}\n\t}\n\t\n\tfor(int j=1;j<=counter;j++){\n\t\t\tif (StartHead(j)+numberLong(j)-1<=x){\n\t\t\tnewCounter[2]++;\n\t\tnumberFastNew[j]=2;\n\t\t}\n\t}\n\t\n\tfor(int j=1;j<=counter;j++){\n\t\tswitch(numberFastNew[j]){\n\t\t\tcase 0:\n\t\t\t\tnumberFast[j]+=-newCounter[1]-newCounter[2];\n\t\t\t\tbreak;\n\t\t\tcase 1:\n\t\t\t\tnumberFast[j]+=newCounter[0]-newCounter[2];\n\t\t\t\tbreak;\n\t\t\tcase 2:\n\t\t\t\tnumberFast[j]+=newCounter[1]+newCounter[0];\n\t\t\t\tbreak;\n\t\t}\n\n\t}\n\t  for ( int a=1;a<=counter+1;a++){\n\t  searchB[numberFast[a]]=a;\n    }\n\n}\n\n\nint main(void)\n{\n\twhile(true){\n\tcards=0;\n\tn=0;\n\tcounter=0;\n\tint points=0;\n  counter=1;\n  cin >> cards;\n  if (cards==0){\n\t  break;\n  }\n  numberStart[1]=1;\n  numberEnd[1]=cards;\n  numberFast[1]=1;\n  searchB[1]=1;\n  cin >> n;\n  cin >> p  >> q  >> r ;\n  for (i=1;i<=n;i++){\n    cin >> x[i] >> y[i];\n  }\n  for (i=1;i<=n;i++){\n     cut(x[i]);\n\t \n      cut(y[i]);\n\t  \n     shuffle(x[i],y[i]);\n  }\n\n  for(int j=p;j<=q;j++){\n\t  if(searchNumber(j)<=r){\n\t\t  points++;\n\t  }\n  }\n  cout << points << endl;\n\t}\n}"
  },
  {
    "language": "C++",
    "code": "#include<bits/stdc++.h>\nusing namespace std;\ntypedef pair<int,int> P;\n\nint n, m;\nvector<P> S,A,B,C;\n\nvoid shuffle(int x,int y){\n  \n  A.clear();\n  B.clear();\n  C.clear();\n\n  int idx=0;\n  \n  for(int i=0;i<S.size();i++){\n    \n    int d=S[i].second-S[i].first+1;\n    int f=0;\n    \n    if(d<=x){\n      if(d==x) f=1;\n      A.push_back(S[i]);\n      \n      x-=d;\n      \n    }\n    else{\n      \n      A.push_back(P(S[i].first,S[i].first+x-1));\n      \n      S[i]=P(S[i].first+x,S[i].second);\n      \n      x=0;\n           \n    }\n    \n    idx=i+f;\n    \n    if(!x) break;\n  }\n  \n  for(int i=idx;i<S.size();i++){\n  \n    int d=S[i].second-S[i].first+1;\n    int f=0;\n    if(d<=y){\n      if(d==y) f=1;\n      B.push_back(S[i]);\n      \n      y-=d;\n      \n    }\n    else{\n      \n      B.push_back(P(S[i].first,S[i].first+y-1));\n      \n      S[i]=P(S[i].first+y,S[i].second);\n      \n      y=0;\n            \n    }\n    \n    idx=i+f;\n    \n    if(!y) break;\n  }\n  \n  for(int i=idx;i<S.size();i++) C.push_back(S[i]);\n    \n  S.clear();\n\n  for(int i=0;i<C.size();i++) S.push_back(C[i]);\n  \n  for(int i=0;i<B.size();i++) S.push_back(B[i]);\n  \n  for(int i=0;i<A.size();i++) S.push_back(A[i]);\n  \n}\n\nint cal(int p,int q,int r){\n  \n  int res=0;\n\n  q=q-p+1;\n  p--;\n  for(int i=0;i<S.size();i++){\n  \n    int d=S[i].second-S[i].first+1;\n\t\n    if(d<=p){\n      \n      p-=d;\n      \n      S.erase(S.begin());\n      \n      i--;\n    }\n    else{\n      \n      S[i]=P(S[i].first+p,S[i].second);\n      \n      p=0;\n            \n    }\n    \n    if(!p) break;\n  }\n\n  for(int i=0;i<S.size();i++){\n\n    int d=S[i].second-S[i].first+1;\n\n    if(d<=q){\n      \n      if(S[i].first<=r) res+=min(r,S[i].second)-S[i].first+1;\n      \n      q-=d;\n    }else{\n      \n      S[i]=P(S[i].first,S[i].first+q-1);\n      \n      if(S[i].first<=r) res+=min(r,S[i].second)-S[i].first+1;\n    \n      q=0;\n    }\n    \n    if(!q) break;\n  }\n  \n  return res;\n}\n\nint main(){\n\n  while(1){\n    \n    cin>>n;\n    if(!n) break;\n    \n    cin>>m;\n    \n    int p, q, r;\n\n    cin>>p>>q>>r;\n        \n    S.clear();\n    \n    S.push_back(P(1,n));\n    \n    for(int i=0;i<m;i++){\n\n      int x, y;\n      cin>>x>>y;\n      \n      shuffle(x,y-x);\n    }\n    \n    cout<<cal(p,q,r)<<endl;\n    \n  }\n  \n  return 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\nusing namespace std;\n\ntypedef pair<int,int> P;\n\nint main(){\n\tint n,m,p,q,r;\n\twhile(cin >> n,n){\n\t\tvector<P> now;\n\t\tcin >> m >> p >> q >> r;\n\t\tnow.push_back(P(r,0));\n\t\tnow.push_back(P(n - r,1));\n\t\tfor(int i = 0;i < m;i++){\n\t\t\tint x,y,sum = 0,a = -1,b = -1;\n\t\t\tvector<P> nxt;\n\t\t\tcin >> x >> y;\n\t\t\tfor(int j = 0;j < now.size();j++){\n\t\t\t\tsum += now[j].first;\n\t\t\t\tif(sum > x && a == -1){\n\t\t\t\t\ta = j + 1;\n\t\t\t\t\tnow.insert(now.begin() + j + 1,P(sum - x,now[j].second));\n\t\t\t\t\tnow[j].first -= sum - x;\n\t\t\t\t\tsum = x;\n\t\t\t\t}else if(sum > y && b == -1){\n\t\t\t\t\tb = j + 1;\n\t\t\t\t\tnow.insert(now.begin() + j + 1,P(sum - y,now[j].second));\n\t\t\t\t\tnow[j].first -= sum - y;\n\t\t\t\t\tsum = y;\n\t\t\t\t}else if(sum == x) a = j + 1;\n\t\t\t\telse if(sum == y) b = j + 1;\n\t\t\t}\n\t\t\tfor(int j = b;j < now.size();j++) nxt.push_back(now[j]);\n\t\t\tfor(int j = a;j < b;j++) nxt.push_back(now[j]);\n\t\t\tfor(int j = 0;j < a;j++) nxt.push_back(now[j]);\n\t\t\tnow = nxt;\n\t\t}\n\t\tint sum = 0,ans = 0;\n\t\tfor(P pp : now){\n\t\t\tif(!pp.second) ans += max(0,min(sum + pp.first,q) - max(sum,p - 1));\n\t\t\tsum += pp.first;\n\t\t}\n\t\tcout << ans << endl;\n\t}\n\treturn 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include <iostream>\n#include <vector>\nusing namespace std;\n\nclass Cards\n{\n  public:\n    Cards(int n);\n\n  public:\n    void Shuffle(int x, int y);\n    int Ans(int p, int q, int r);\n\n  private:\n    int m_n;\n    vector<int> m_cards;\n};\n\nCards::Cards(int n) :\n  m_n(n), m_cards(n)\n{\n  for (int i = 0; i < n; ++i)\n  {\n    m_cards[i] = i + 1;\n  }\n}\n\nvoid Cards::Shuffle(int x, int y)\n{\n  vector<int> new_cards;\n  for (int i = y; i < m_n; ++i)\n  {\n    new_cards.push_back(m_cards[i]);\n  }\n\n  for (int i = x; i < y; ++i)\n  {\n    new_cards.push_back(m_cards[i]);\n  }\n\n  for (int i = 0; i < x; ++i)\n  {\n    new_cards.push_back(m_cards[i]);\n  }\n  m_cards.swap(new_cards);\n}\n\nint Cards::Ans(int p, int q, int r)\n{\n  int result;\n  for (int i = p - 1; i < q; ++i)\n  {\n    if (m_cards[i] <= r)\n    {\n      result++;\n    }\n  }\n  return result;\n}\n\nint main(void)\n{\n  while (true)\n  {\n    int n;\n    cin >> n;\n    if (n == 0) break;\n    Cards cards(n);\n\n    int m;\n    cin >> m;\n    int p, q, r;\n    cin >> p >> q >> r;\n\n    for (int i = 0; i < m; ++i)\n    {\n      int x, y;\n      cin >> x >> y;\n      cards.Shuffle(x, y);\n    }\n    cout << cards.Ans(p, q, r) << endl;\n  }\n  return 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include <iostream>\n#include <algorithm>\n#include <vector>\nusing namespace std;\nint main(){\n\tint n,m,p,q,r,x,y;\n\tvector<int>::iterator u,v,z;\n\tfor(;cin>>n>>m>>p>>q>>r;cout<<x<<endl){\n\t\tvector<int> s,t;\n\t\ts.push_back(0);\n\t\tfor(s.push_back(r);m--;t.clear()){\n\t\t\tcin>>x>>y;\n\t\t\tu=upper_bound(s.begin(),s.end(),x);\n\t\t\tv=upper_bound(s.begin(),s.end(),y);\n\t\t\t\n\t\t\tif( v-s.begin()+1 & 1 )t.push_back(0);\n\t\t\tt.push_back(0);\n\t\t\tfor(z=v;z!=s.end();++z)\n\t\t\t\tt.push_back(*z - y);\n\t\t\t\n\t\t\tif(s.end()-u & 1)t.push_back(n-y);\n\t\t\tfor(z=u;z!=v;++z)\n\t\t\t\tt.push_back(*z-x+n-y);\n\t\t\t\n\t\t\tz = s.begin();\n\t\t\tif(v-s.begin() & 1)++z;\n\t\t\tif(!z[1])z+=2;\n\t\t\tif(*z+n-x==t.back()){++z;t.pop_back();}\n\t\t\tfor(;z!=u;++z)\n\t\t\t\tt.push_back(*z+n-x);\n\t\t\t\n\t\t\ts.swap(t);\n\t\t}\n\t\ts.insert( upper_bound(s.begin(),s.end(),p-1), 2, p-1);\n\t\ts.insert( lower_bound(s.begin(),s.end(),q), q );\n\t\ts.push_back(n);\n\t\tz = upper_bound(s.begin(),s.end(),p-1);\n\t\tif(z-s.begin() & 1) --z;\n\t\tfor(x=0;*z<q;++z)\n\t\t\tm=*z++,x+=*z-m;\n\t}\n}"
  },
  {
    "language": "C++",
    "code": "#include <iostream>\n#include <algorithm>\n#include <vector>\nusing namespace std;\nint main(){\n\tint n,m,p,q,r,x,y;\n\tvector<int>::iterator itx,ity,it;\n\tfor(;cin>>n>>m>>p>>q>>r;cout<<x<<endl){\n\t\tvector<int> v1,v2;\n\t\tv1.push_back(0);\n\t\tfor(v1.push_back(r);m--;v2.clear()){\n\t\t\tcin>>x>>y;\n\t\t\titx=upper_bound(v1.begin(),v1.end(),x);\n\t\t\tity=upper_bound(v1.begin(),v1.end(),y);\n\t\t\t\n\t\t\tif( ity-v1.begin()+1 & 1 )v2.push_back(0);\n\t\t\tv2.push_back(0);\n//\t\t\tv2.insert(v2.end(),ity-v1.begin()&1?1:2,0);\n\t\t\tfor(it=ity;it!=v1.end();++it)\n\t\t\t\tv2.push_back(*it - y);\n\t\t\t\n\t\t\tif(v1.end()-itx & 1)v2.push_back(n-y);\n\t\t\tfor(it=itx;it!=ity;++it)\n\t\t\t\tv2.push_back(*it-x+n-y);\n\t\t\t\n\t\t\tit = v1.begin();\n\t\t\tif(ity-v1.begin() & 1)++it;\n\t\t\tif(!it[1])it+=2;\n\t\t\tif(*it+n-x==v2.back()){++it;v2.pop_back();}\n\t\t\tfor(;it!=itx;++it)\n\t\t\t\tv2.push_back(*it+n-x);\n\t\t\t\n\t\t\tv1.swap(v2);\n\t\t}\n\t\tv1.insert( upper_bound(v1.begin(),v1.end(),p-1), 2, p-1);\n\t\tv1.insert( lower_bound(v1.begin(),v1.end(),q), q );\n\t\tv1.push_back(n);\n\t\tit = upper_bound(v1.begin(),v1.end(),p-1);\n\t\tif(it-v1.begin() & 1) --it;\n\t\tfor(x=0;*it<q;++it)\n\t\t\tm=*it++,\n\t\t\tx+=*it-m;\n\t}\n}"
  },
  {
    "language": "C++",
    "code": "#include <set>\n#include <map>\n#include <list>\n#include <queue>\n#include <stack>\n#include <cmath>\n#include <ctime>\n#include <cstdio>\n#include <vector>\n#include <string>\n#include <bitset>\n#include <cctype>\n#include <cstdlib>\n#include <cstring>\n#include <utility>\n#include <numeric>\n#include <complex>\n#include <sstream>\n#include <fstream>\n#include <iomanip>\n#include <cassert>\n#include <iostream>\n#include <iterator>\n#include <algorithm>\n\nusing namespace std;\n\n//4方向ベクトル→↑←↓\nint dx[4] ={1,0,-1,0};\nint dy[4] ={0,-1,0,1};\n\nvector<int> Card;\nvector<int> Cardtemp;\nint n;//カードの枚数\nint m;//シャッフルの回数\nint x,y;//シャッフルする(x,y)\nint p,q,r;//p行q行以下に番号r以下のカードが何枚含まれているか\nint main()\n{\n  while(1){\n  scanf(\"%d\",&n);\n  if(n==0)\n    break;\n  scanf(\"%d\",&m);\n  scanf(\"%d %d %d\",&p,&q,&r);\n  Card.clear();\n  Cardtemp.clear();\n  for(int i = 1;i <=n;i++){\n    Card.push_back(i);\n  }\n  int ans = 0;\n  for(int i = 1;i <=m;i++){\n    Cardtemp = Card;\n    scanf(\"%d %d\",&x,&y);\n    for(int j = 0;j <=n-(y+1);j++){\n      Card[j] = Cardtemp[y+j];\n    }\n    for(int j = 0;j <=y-(x+1);j++){\n      Card[n-y+j] = Cardtemp[x+j];\n\t}\n    for(int j = 0;j <=x-1;j++){\n      Card[n-x+j] = Cardtemp[j];\n    }\n  }\n  for(int i = p-1;i < q;i++){\n    if(Card[i] <= r)\n      ans++;\n  }\n  cout <<ans<<endl;\n  }\n  return 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include<iostream>\n#include<list>\n\nusing namespace std;\n\nstruct block {\n  int start;\n  int end;\n  int len;\n};\n\nlist<block> blocks;\nlist<block> fronts;\nlist<block> middles;\nlist<block> backs;\n\n\nvoid view( block now ) {\n  cout << \"Start: \" << now.start << \"End: \" << now.end << endl;\n}\n\n\nvoid split ( int what, int x ) {\n  block now;\n  block front;\n  block middle;\n  block back;  \n  //cout << \"Start split \" << x << endl;\n\n  now = blocks.front();\n\n  blocks.pop_front();\n  back.start = now.start + x;\n  back.end = now.end;\n  back.len = now.len - x;\n\n  blocks.push_front(back);\n\n  \n\n  front.start = now.start;\n  front.end = now.start + x -1;\n  front.len = x;\n  if ( what == 0 )\n    fronts.push_back(front);\n  else\n    middles.push_back(front);\n\n  //view(now);\n  //view(front);\n  //view(back);\n}\n  \nint main() {\n  int count = 0;\n\n  /*\n  list<int> test0;\n  list<int> test1;\n  list<int> test2;\n  \n  test0.clear();\n  test1.clear();\n  test2.clear();\n  test0.push_back(1);\n  test0.push_back(2);\n  test1.push_back(3);\n  test1.push_back(4);\n  test2.push_back(5);\n  test2.push_back(6);\n\n  test0.splice(test0.end(), test1);\n  test0.splice(test0.end(), test2);\n\n  while( !test0.empty() ) {\n    cout << test0.front();\n    test0.pop_front();\n  }\n  */\n  while ( true ) {\n    int n, m, p, q, r;\n\n    cin >> n;\n    if ( n == 0 )\n      break;\n\n    cin >> m;\n\n    cin >> p >> q >> r;\n\n    block data;\n    blocks.clear();\n    data.start = 1;\n    data.end = n;\n    data.len = n;\n    blocks.push_back(data);\n\n\n    block now;\n\n    for ( int i=0; i<m; i++ ) {\n      int x, y;\n      cin >> x >> y;\n      int temp = x;\n\n      fronts.clear();\n      backs.clear();\n      middles.clear();\n\n      while ( x != 0 ) {\n\tif ( blocks.front().len > x ) {\n\t  split(0,x);\n\t  x = 0;\n\t  break;\n\t}\n\telse {\n\t  now = blocks.front();\n\t  blocks.pop_front();\n\t  x -= now.len;\n\t  fronts.push_back(now);\n\t}\n      }\n\n      y = y-temp;\n    \n      while ( y != 0 ) {\n\n\tif ( blocks.front().len > y ) {\n\t  split(1,y);\n\t  y = 0;\n\t  break;\n\t}\n\telse {\n\n\t  now = blocks.front();\n\t  blocks.pop_front();\n\t  y -= now.len;\n\t  middles.push_back(now);\n\t}\n      }\n\n      blocks.splice(blocks.end(), middles);\n      blocks.splice(blocks.end(), fronts);\n\n    }\n    \n    int sum = 0;\n\n    \n\n    bool start, end;\n    start = true;\n    end = false;\n    //cout << \"Start Counting\" << endl;\n    while ( !blocks.empty() ) {\n      now = blocks.front();\n\n      blocks.pop_front();\n      if ( start && p > now.len ) {\n\t//view(now);\n\tp -= now.len;\n\tq -= now.len;\n      } else {\n\t//view(now);\n\tif ( start ) {\n\t  start = false;\n\t  now.start += p-1;\n\t}\n\n\n\n\tq -= now.len;\n\tif ( q <=0 )\n\t  end = true;\n\tif ( q < 0 )\n\t  now.end += q;\n\t//view(now);\t\n\n\tif ( now.start <= r ) {\n\t  if ( now.end >= r ) {\n\t    sum += r - now.start + 1;\n\t  }\n\t  else\n\t    sum += now.end - now.start + 1;\n\t}\n\n\tif ( end )\n\t  break;\n      }\n    }\n    cout << sum << endl;\n    //cout << \"ANswer: \" << sum << endl;\n    \n  }\n}"
  },
  {
    "language": "C++",
    "code": "#define _USE_MATH_DEFINES\n#include <iostream>\n#include <memory>\n#include <memory.h>\n#include <fstream>\n#include <cmath>\n#include <math.h>\n#include <numeric>\n#include <vector>\n#include <stack>\n#include <string>\n#include <queue>\n#include <sstream>\n#include <cstdlib>\n#include <cassert>\n#include <cstdio>\n#include <map>\n#include <iomanip>\n#include <list>\n#include <cctype>\n#include <algorithm>\n#include <complex>\n\n#define rep(i, n) for(int i = 0; i < n; i++)\n#define rep2(i, m, n) for(int i = m; i < n; i++)\nusing namespace std;\n\ntypedef complex<double> xy_t;\ntypedef pair<xy_t, xy_t> line;\ntypedef long long ll;\ntypedef pair<int, int> P;\ntypedef pair<double, double> Pd;\ntypedef pair<int, P> PP;\ntypedef pair<int, PP> PPP;\nconst int INF = 1 << 29;\nconst double EPS = 1E-10;\n\n#define rep(i, n) for(int i = 0; i < n; i++)\n#define rep2(i, m, n) for(int i = m; i < n; i++)\n\nint sz[10000];\n\nvector<P> change(const vector<P> &nums, int x, int y){\n\tvector<P> res;\n\tint n = nums.size();\n\tint indx, indy;\n\tint ub = n + 1, lb = 0;\n\tsz[0] = 0;\n\trep(i, n){\n\t\tsz[i+1] = sz[i] + nums[i].second - nums[i].first + 1;\n\t}\n\n\twhile(ub - lb > 1){\n\t\tint mb = (ub + lb) / 2;\n\t\tif(sz[mb] < x) lb = mb;\n\t\telse ub = mb;\n\t}\n\tindx = lb;\n\tub = n + 1, lb = 0;\n\n\twhile(ub - lb > 1){\n\t\tint mb = (ub + lb ) / 2;\n\t\tif(sz[mb] <= y) lb = mb;\n\t\telse ub = mb;\n\t}\n\tindy = lb;\n\n\tint dy = indy == n ? 0 : y - sz[indy], dx = indx == n ? 0 : x - sz[indx];\n\n\tres.push_back(P(nums[indy].first + dy ,nums[indy].second));\n\trep2(i, indy + 1, n){\n\t\tres.push_back(nums[i]);\n\t}\n\tif(indx != indy) res.push_back(P(nums[indx].first + dx, nums[indx].second));\n\telse res.push_back(P(nums[indx].first + dx, nums[indx].first + dy-1));\n\trep2(i, indx + 1, indy){\n\t\tres.push_back(nums[i]);\n\t}\n\tif(indx != indy && dy != 0) res.push_back(P(nums[indy].first, nums[indy].first + dy - 1));\n\trep(i, indx ){\n\t\tres.push_back(nums[i]);\n\t}\n\tif(dx != 0)res.push_back(P(nums[indx].first, nums[indx].first + dx - 1));\n\treturn res;\n}\n\nint get_num(P p, int r){\n\t//cout << \"***\" << p.first << \" \" << p.second << endl;;\n\tif(p.second < p.first) return 0;\n\tif(r < p.first) return 0;\n\telse if(p.second <= r) return p.second - p.first + 1;\n\telse return r - p.first + 1;\n}\n\nint counter(const vector<P> &nums, int p, int q, int r){\n\tint cnt = 1;\n\tint res = 0;\n\tint n = nums.size();\n\trep(i, n){\n\t//\tcout << \"+ \" <<  nums[i].first << \" \" << nums[i].second << endl;\n\t\tint sz = nums[i].second - nums[i].first + 1;\n\t\tint pn = nums[i].first + p - cnt;\n\t\tint qn = nums[i].first + q - cnt;\n\t\t\n\t\tres += get_num(P(max(nums[i].first, pn), min(nums[i].second, qn)), r);\n\t\tcnt += sz;\n\t}\n\treturn res;\n}\n\nint main(){\n\tint n, m;\n\tint p, q, r;\n\tint x, y;\n\twhile(cin >> n && n){\n\t\tvector<P> nums;\n\t\tnums.push_back(P(1, n));\n\t\tcin >> m;\n\t\tcin >> p >> q >> r;\n\t\trep(i, m){\n\t\t\tcin >> x >> y;\n\t\t\tnums = change(nums, x, y);\n\t\t}\n\t\tcout << counter(nums, p, q, r) << endl;\n\t}\n\treturn 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include<iostream>\n#include<queue>\nusing namespace std;\nint main(){\n\tint n;\n\tdeque<int> a,c;\n\twhile(cin>>n,n){\n\t\tint m,p,q,r,x,y,ans=0;\n\t\n\tcin>>m;\n\tcin>>p>>q>>r;\n\tfor(int i=1;i<=n;i++)\n\t\ta.push_back(i);\n\tfor(int i=0;i<m;i++){\n\t\tcin>>x>>y;\n\t\tfor(int j=0;j<n-y;j++){\n\t\t\tc.push_back(a.back());\n\t\t\ta.pop_back();\n\t\t}\n\t\tfor(int j=0;j<y-x;j++){\n\t\t\ta.push_front(a.back());\n\t\t\ta.pop_back();\n\t\t}\n\t\tfor(int j=0;j<n-y;j++){\n\t\t\ta.push_front(c.front());\n\t\t\tc.pop_front();\n\t\t}\n\t}\n\t/*for(int i=0;i<n;i++){\n\t\tcout<<a.front()<<' ';\n\t\ta.pop_front();\n\t}cout<<endl;\n\t*/\n\tfor(int i=0;i<p-1;i++){\n\t\ta.pop_front();\n\t}\n\tfor(int j=0;j<q-p+1;j++){\n\t\tif(a.front()<=r)\n\t\tans++;\n\t\ta.pop_front();\n\t}\n\tcout<<ans<<endl;\n\t\twhile(!a.empty()){\n\t\t\ta.pop_front();\n\t\t}\n\t\twhile(!c.empty()){\n\t\t\tc.pop_front();\n\t\t}\n\t}\n\treturn 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include <iostream>\n#include<algorithm>\n#include<vector>\nusing namespace std;\nmain(){\n\tint n,m,p,q,r,x,y;\n\tvector<int>::iterator v,w,z;\n\tfor(;cin>>n>>m>>p>>q>>r;cout<<x<<endl){\n\t\tvector<int>t(1),u;\n\t\t\n\t\tfor(t.push_back(r);m--;u.clear()){\n\t\t\tcin>>x>>y;\n\t\t\tv=upper_bound(t.begin(),t.end(),x);\n\t\t\tw=upper_bound(t.begin(),t.end(),y);\n\t\t\t\n\t\t\tif(w-t.begin()+1&1)u.push_back(0);\n\t\t\tu.push_back(0);\n\t\t\tfor(z=w;z<t.end();++z)\n\t\t\t\tu.push_back(*z-y);\n\t\t\t\n\t\t\tif(t.end()-v&1)u.push_back(n-y);\n\t\t\tfor(z=v;z<w;++z)\n\t\t\t\tu.push_back(*z-x+n-y);\n\t\t\t\n\t\t\tz=t.begin();\n\t\t\tif(w-t.begin()&1)++z;\n\t\t\tif(!z[1])z+=2;\n\t\t\tif(*z+n-x==u.back())++z,u.pop_back();\n\t\t\tfor(;z<v;++z)\n\t\t\t\tu.push_back(*z+n-x);\n\t\t\t\n\t\t\tt.swap(u);\n\t\t}\n\t\tt.insert(upper_bound(t.begin(),t.end(),p-1),2,p-1);\n\t\tt.insert(lower_bound(t.begin(),t.end(),q),q);\n\t\tt.push_back(n);\n\t\tz=upper_bound(t.begin(),t.end(),p-1);\n\t\tif(z-t.begin()&1)--z;\n\t\tfor(x=0;*z<q;\n\t\t\tx+=*z++-m)\n\t\t\tm=*z++;\n\t}\n}"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\nusing namespace std;\n\nusing VI = vector<int>;\nusing VVI = vector<VI>;\nusing PII = pair<int, int>;\nusing LL = long long;\nusing VL = vector<LL>;\nusing VVL = vector<VL>;\nusing PLL = pair<LL, LL>;\nusing VS = vector<string>;\n\n#define ALL(a)  begin((a)),end((a))\n#define RALL(a) (a).rbegin(), (a).rend()\n#define PB push_back\n#define EB emplace_back\n#define MP make_pair\n#define SZ(a) int((a).size())\n#define SORT(c) sort(ALL((c)))\n#define RSORT(c) sort(RALL((c)))\n#define UNIQ(c) (c).erase(unique(ALL((c))), end((c)))\n\n#define FOR(i,a,b) for(int i=(a);i<(b);++i)\n#define REP(i,n)  FOR(i,0,n)\n\n#define FF first\n#define SS second\ntemplate<class S, class T>\nistream& operator>>(istream& is, pair<S,T>& p){\n  return is >> p.FF >> p.SS;\n}\ntemplate<class S, class T>\nostream& operator<<(ostream& os, const pair<S,T>& p){\n  return os << p.FF << \" \" << p.SS;\n}\ntemplate<class T>\nvoid maxi(T& x, T y){\n  if(x < y) x = y;\n}\ntemplate<class T>\nvoid mini(T& x, T y){\n  if(x > y) x = y;\n}\n\n\nconst double EPS = 1e-10;\nconst double PI  = acos(-1.0);\nconst LL MOD = 1e9+7;\n\nint main(){\n  cin.tie(0);\n  ios_base::sync_with_stdio(false);\n\n  int N;\n  while(cin>>N, N){\n\tint M;\n\tcin >> M;\n\tint P, Q, R;\n\tcin >> P >> Q >> R;\n\t--P;\n\t\n\tvector<pair<PII,int>> s[2];\n\tint crt = 0, nxt = 1;\n\ts[crt].PB(MP(MP(0,N),0));\n\tREP(i,M){\n\t  int a, b;\n\t  cin >> a >> b;\n\t  --a;\n\t  s[nxt].clear();\n\t  SORT(s[crt]);\n\t  \n\t  for(auto x: s[crt]){\n\t\tauto r = x.FF;\n\t\tint ix = x.SS;\n\t\tint l1 = N - b;\n\t\tint l2 = l1 + b - a;\n\t\t\n\t\tif(r.SS <= a){\n\t\t  s[nxt].PB(MP(MP(l2+r.FF, l2+r.SS), ix));\n\t\t}\n\t\telse if(r.FF < a){\n\t\t  if(r.SS <= b){\n\t\t\ts[nxt].PB(MP(MP(l2+r.FF, N), ix));\n\t\t\ts[nxt].PB(MP(MP(l1, l1+r.SS-a), ix+a-r.FF));\n\t\t  }\n\t\t  else{\n\t\t\ts[nxt].PB(MP(MP(l2+r.FF, l2+a), ix));\n\t\t\ts[nxt].PB(MP(MP(l1,l2), ix+a-r.FF));\n\t\t\ts[nxt].PB(MP(MP(0,r.SS-b), ix+b-r.FF));\n\t\t  }\n\t\t}\n\t\telse if(r.FF < b){\n\t\t  if(r.SS <= b){\n\t\t\ts[nxt].PB(MP(MP(l1+r.FF-a,l1+r.SS-a),ix));\n\t\t  }\n\t\t  else{\n\t\t\ts[nxt].PB(MP(MP(l1+r.FF-a,b), ix));\n\t\t\ts[nxt].PB(MP(MP(0,r.SS-b), ix+b-r.FF));\n\t\t  }\n\t\t}\n\t\telse{\n\t\t  s[nxt].PB(MP(MP(r.FF-b,r.SS-b), ix));\n\t\t}\n\t  }\n\t  swap(crt, nxt);\n\t}\n\t\n\tint ans = 0;\n\tfor(auto&& p: s[crt]){\n\t  auto ra = p.FF;\n\t  int ix = p.SS;\n\t  if(ra.SS <= P || Q <= ra.FF) continue;\n\t  int l = max(P, ra.FF);\n\t  int r = min(Q, ra.SS);\n\t  int bix = ix + l-ra.FF;\n\t  if(bix < R){\n\t\tans += min(r-l, R - bix);\n\t  }\n\t}\n\tcout << ans << endl;\n  }\n\n  return 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include<bits/stdc++.h>\nusing namespace std;\ntypedef pair<int,int> P;\n\nint n, m;\nvector<P> S,A,B,C;\n\nvoid shuffle(int x,int y){\n  \n  A.clear();\n  B.clear();\n  C.clear();\n\n  int idx=0;\n  \n  for(int i=0;i<S.size();i++){\n    \n    int d=S[i].second-S[i].first+1;\n    \n    if(d<=x){\n      \n      A.push_back(S[i]);\n      \n      x-=d;\n      \n    }\n    else{\n      \n      A.push_back(P(S[i].first,S[i].first+x-1));\n      \n      S[i]=P(S[i].first+x,S[i].second);\n      \n      x=0;\n           \n    }\n    idx=i;\n    if(!x) break;\n  }\n  \n  for(int i=idx;i<S.size();i++){\n  \n    int d=S[i].second-S[i].first+1;\n\t\n    if(d<=y){\n      \n      B.push_back(S[i]);\n      \n      y-=d;\n      \n    }\n    else{\n      \n      B.push_back(P(S[i].first,S[i].first+y-1));\n      \n      S[i]=P(S[i].first+y,S[i].second);\n      \n      y=0;\n            \n    }\n    idx=i;\n    if(!y) break;\n  }\n  \n  for(int i=idx;i<S.size();i++) C.push_back(S[i]);\n    \n  S.clear();\n\n  for(int i=0;i<C.size();i++) S.push_back(C[i]);\n  \n  for(int i=0;i<B.size();i++) S.push_back(B[i]);\n  \n  for(int i=0;i<A.size();i++) S.push_back(A[i]);\n  \n}\n\nint cal(int p,int q,int r){\n  \n  int res=0;\n\n  q=q-p+1;\n  p--;\n  for(int i=0;i<S.size();i++){\n  \n    int d=S[i].second-S[i].first+1;\n\t\n    if(d<=p){\n      \n      p-=d;\n      \n      S.erase(S.begin());\n      \n      i--;\n    }\n    else{\n      \n      S[i]=P(S[i].first+p,S[i].second);\n      \n      p=0;\n            \n    }\n    \n    if(!p) break;\n  }\n\n  for(int i=0;i<S.size();i++){\n\n    int d=S[i].second-S[i].first+1;\n\n    if(d<=q){\n      \n      if(S[i].first<=r) res+=min(r,S[i].second)-S[i].first+1;\n      \n      q-=d;\n    }else{\n      \n      S[i]=P(S[i].first,S[i].first+q-1);\n      \n      if(S[i].first<=r) res+=min(r,S[i].second)-S[i].first+1;\n    \n      q=0;\n    }\n    \n    if(!q) break;\n  }\n  \n  return res;\n}\n\nint main(){\n\n  while(1){\n    \n    cin>>n;\n    if(!n) break;\n    \n    cin>>m;\n    \n    int p, q, r;\n\n    cin>>p>>q>>r;\n        \n    S.clear();\n    \n    S.push_back(P(1,n));\n    \n    for(int i=0;i<m;i++){\n\n      int x, y;\n      cin>>x>>y;\n      \n      shuffle(x,y-x);\n    }\n    \n    cout<<cal(p,q,r)<<endl;\n    \n  }\n  \n  return 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include <set>\n#include <map>\n#include <list>\n#include <queue>\n#include <stack>\n#include <cmath>\n#include <ctime>\n#include <cstdio>\n#include <vector>\n#include <string>\n#include <bitset>\n#include <cctype>\n#include <cstdlib>\n#include <cstring>\n#include <utility>\n#include <numeric>\n#include <complex>\n#include <sstream>\n#include <fstream>\n#include <iomanip>\n#include <cassert>\n#include <iostream>\n#include <iterator>\n#include <algorithm>\n\nusing namespace std;\n\n//4方向ベクトル→↑←↓\nint dx[4] ={1,0,-1,0};\nint dy[4] ={0,-1,0,1};\n\nvector<int> Card;\nvector<int> Cardtemp;\nunsigned long n;//カードの枚数\nint m;//シャッフルの回数\nunsigned long x,y;//シャッフルする(x,y)\nunsigned long p,q,r;//p行q行以下に番号r以下のカードが何枚含まれているか\nint main()\n{\n  while(1){\n  scanf(\"%lu\",&n);\n  if(n==0)\n    break;\n  scanf(\"%d\",&m);\n  scanf(\"%lu %lu %lu\",&p,&q,&r);\n  for(int i = 1;i <=n;i++){\n    Card.push_back(i);\n  }\n  unsigned long ans = 0;\n  for(int i = 1;i <=m;i++){\n    Cardtemp = Card;\n    scanf(\"%lu %lu\",&x,&y);\n    for(int j = 0;j <=n-(y+1);j++){\n      Card[j] = Cardtemp[y+j];\n    }\n    for(int j = 0;j <=y-(x+1);j++){\n      Card[n-y+j] = Cardtemp[x+j];\n\t}\n    for(int j = 0;j <=x-1;j++){\n      Card[n-x+j] = Cardtemp[j];\n    }\n  }\n  for(int i = p-1;i < q;i++){\n    if(Card[i] <= r)\n      ans++;\n  }\n  printf(\"%lu\\n\",ans);\n  Card.clear();\n  Cardtemp.clear();\n  }\n  return 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include<stdio.h>\n#include<vector>\n#include<map>\n#include<algorithm>\nusing namespace std;\ntypedef pair<int,int> P;\nvector<P> v;\nint max(int a,int b){return a>b?a:b;}\nint min(int a,int b){return a<b?a:b;}\nint main(){\n\tint n,m;\n\tint a,b,r;\n\tint i,j,k;\n\twhile(1){\n\tscanf(\"%d\",&n);\n\tif(n==0)return 0;\n\tscanf(\"%d\",&m);\n\tscanf(\"%d %d %d\",&a,&b,&r);\n\ta--;\n\tv.clear();\n\tv.push_back(P(0,1));\n\tfor(i=0;i<m;i++){\n\t\tint p,q;\n\t\tscanf(\"%d %d\",&p,&q);\n\t\tP lp=P(-1,0),up=P(-1,0);\n\t\tfor(j=0;j<v.size();j++){\n\t\t\tif(v[j].first<=p&&v[j].first>lp.first){\n\t\t\t\tlp.first=v[j].first;\n\t\t\t\tlp.second=(p-v[j].first)+v[j].second;\n\t\t\t}\n\t\t\tif(v[j].first<=q&&v[j].first>up.first){\n\t\t\t\tup.first=v[j].first;\n\t\t\t\tup.second=(q-v[j].first)+v[j].second;\n\t\t\t}\n\t\t\tif(v[j].first<p)v[j].first+=n-p;\n\t\t\telse if(v[j].first<q)v[j].first=v[j].first-p+n-q;\n\t\t\telse v[j].first-=q;\n\t\t}\n\t\tv.push_back(P(n-q,lp.second));\n\t\tv.push_back(P(0,up.second));\n\t}\n\tv.push_back(P(n,0));\n\tsort(v.begin(),v.end());\n\tint ans=0;\n\tfor(i=0;i<v.size()-1;i++){\n\t\tif(v[i].first==v[i+1].first)continue;\n\t\tif(v[i].second<=r){\n\t\t\tint l=max(v[i].first,a)-v[i].first+v[i].second;\n\t\t\tint u=min(min(v[i+1].first,b)-v[i].first+v[i].second,r+1);\n\t\t\tans+=max(0,u-l);\n\t\t}\n\t}\n\tprintf(\"%d\\n\",ans);\n\t}\n}"
  },
  {
    "language": "C++",
    "code": "#include <iostream>\n#include <algorithm>\n#include <vector>\nusing namespace std;\nint main(){\n\tint n,m,p,q,r,x,y;\n\tvector<int>::iterator itx,ity,it;\n\tfor(;cin>>n>>m>>p>>q>>r;cout<<x<<endl){\n\t\tvector<int> v1,v2;\n\t\tv1.push_back(0);\n\t\tfor(v1.push_back(r);m--;v2.clear()){\n\t\t\tcin>>x>>y;\n\t\t\titx=upper_bound(v1.begin(),v1.end(),x);\n\t\t\tity=upper_bound(v1.begin(),v1.end(),y);\n\t\t\t\n//\t\t\tif( ity-v1.begin()+1 & 1 )v2.push_back(0);\n//\t\t\tv2.push_back(0);\n\t\t\tv2.insert(v2.end(),ity-v1.begin()&1?1:2,0);\n\t\t\tfor(it=ity;it!=v1.end();++it)\n\t\t\t\tv2.push_back(*it - y);\n\t\t\t\n\t\t\tif(v1.end()-itx & 1)v2.push_back(n-y);\n\t\t\tfor(it=itx;it!=ity;++it)\n\t\t\t\tv2.push_back(*it-x+n-y);\n\t\t\t\n\t\t\tit = v1.begin();\n\t\t\tif(ity-v1.begin() & 1)++it;\n\t\t\tif(!it[1])it+=2;\n\t\t\tif(*it+n-x==v2.back()){++it;v2.pop_back();}\n\t\t\tfor(;it!=itx;++it)\n\t\t\t\tv2.push_back(*it+n-x);\n\t\t\t\n\t\t\tv1.swap(v2);\n\t\t}\n\t\tv1.insert( upper_bound(v1.begin(),v1.end(),p-1), 2, p-1);\n\t\tv1.insert( lower_bound(v1.begin(),v1.end(),q), q );\n\t\tv1.push_back(n);\n\t\tit = upper_bound(v1.begin(),v1.end(),p-1);\n\t\tif(it-v1.begin() & 1) --it;\n\t\tfor(x=0;*it<q;\n\t\t\tx+=*it++-m)\n\t\t\tm=*it++\n\t}\n}"
  },
  {
    "language": "C++",
    "code": "#include <iostream>\n#include <algorithm>\n#include <vector>\n\nusing namespace std;\ntypedef pair<int,int> pii;\n\nint N;\nint M;\nint P,Q,R;\n\nvoid decidePlace(int &sumX,vector<pii>&deck,int &xPos,int x){\n    for(int j=0;j<deck.size();j++){\n        if(sumX+deck[j].second-deck[j].first+1>=x){\n            xPos=j;\n            break;\n        }\n        sumX+=deck[j].second-deck[j].first+1;\n    }\n}\nvoid divideBlock(vector<pii> &deck,int &xPos,int &sumX,int x,bool isX){\n    int minu=1;\n    if(isX)minu++;\n    pii p1=pii(deck[xPos].first,deck[xPos].first+(x-sumX-minu));\n    pii p2=pii(p1.second+1,deck[xPos].second);\n    deck.erase(deck.begin()+xPos);\n    if(p2.first<=p2.second)deck.insert(deck.begin()+xPos,p2);\n    if(p1.first<=p1.second)deck.insert(deck.begin()+xPos,p1);\n}\n\nint main(){\n    while(cin>>N&&N){\n        int res=0;\n        cin>>M>>P>>Q>>R;\n        vector<pii> deck;\n        deck.push_back(pii(1,N));\n        int x,y;\n        for(int i=0;i<M;i++){\n            cin>>x>>y;\n            x++;\n            int sumX=0;\n            int sumY=0;\n            int xPos,yPos;\n            decidePlace(sumX,deck,xPos,x);\n            decidePlace(sumY,deck,yPos,y);\n            if(xPos==yPos){\n                pii p1=pii(deck[xPos].first,deck[xPos].first+(x-sumX-2));\n                pii p2=pii(p1.second+1,deck[yPos].first+(y-sumY-1));\n                pii p3=pii(p2.second+1,deck[xPos].second);\n                deck.erase(deck.begin()+xPos);\n                if(p3.first<=p3.second)deck.insert(deck.begin()+xPos,p3);\n                if(p2.first<=p2.second)deck.insert(deck.begin()+xPos,p2);\n                if(p1.first<=p1.second)deck.insert(deck.begin()+xPos,p1);\n            }\n            else{\n                divideBlock(deck,yPos,sumY,y,false);\n                divideBlock(deck,xPos,sumX,x,true);\n            }\n            sumX=sumY=0;\n            decidePlace(sumX,deck,xPos,x);\n            decidePlace(sumY,deck,yPos,y);\n            vector<pii> cutPlace;\n            vector<pii> prv;\n            vector<pii> nxt;\n            for(int i=xPos;i<=yPos;i++)cutPlace.push_back(deck[i]);\n            for(int i=0;i<xPos;i++)prv.push_back(deck[i]);\n            for(int i=yPos+1;i<deck.size();i++)nxt.push_back(deck[i]);\n            deck.clear();\n            for(int i=0;i<nxt.size();i++)deck.push_back(nxt[i]);\n            for(int i=0;i<cutPlace.size();i++)deck.push_back(cutPlace[i]);\n            for(int i=0;i<prv.size();i++)deck.push_back(prv[i]);\n        }\n        int sum=0;\n        bool isApP=false;\n        for(int i=0;i<deck.size();i++){\n            int cnt=deck[i].second-deck[i].first+1;\n            sum+=cnt;\n            if(sum<P)continue;\n            if(sum-cnt<P&&sum-cnt<Q&&sum>=P&&sum>=Q){\n                int pPos=P-(sum-cnt)-1;\n                int pNum=pPos+deck[i].first;\n                int qPos=Q-(sum-cnt)-1;\n                int qNum=qPos+deck[i].first;\n                if(pNum<=R)res+=max(0,min(-qNum+R+1,qNum-pNum+1));\n                break;\n            }\n            else if(!isApP&&sum>=P){\n                isApP=true;\n                int pPos=P-(sum-cnt)-1;\n                int pNum=pPos+deck[i].first;\n                if(pNum<=R)res+=max(0,min(-deck[i].first+R+1,deck[i].second-pNum+1));\n            }\n            else if(isApP){\n                if(sum>=Q){\n                    int qPos=Q-(sum-cnt)-1;\n                    int qNum=qPos+deck[i].first;\n                    if(deck[i].first<=R)res+=min(qNum-deck[i].first+1,(R-deck[i].first+1));\n                    break;\n                }\n                else if(deck[i].first<=R)res+=max(0,min(-deck[i].first+R+1,deck[i].second-deck[i].first+1));\n            }\n        }\n        cout<<res<<endl;\n    }\n    return 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include <iostream>\n#include <vector>\n#include <deque>\n\nusing namespace std;\n\n#define fst first\n#define scd second\n#define PB push_back\n#define omajinai ios::sync_with_stdio(false);cin.tie(0)\n#define rep(i,x) for(int i=0;i<(int)(x);++i)\n\nusing pii = pair<int, int>;\nusing vpii = vector<pii>;\n\nint n, m, p, q, r;\n\nint calc(pii seg, int n)\n{\n\tint len = seg.scd - seg.fst + 1;\n\n\tif (n < p && p <= n + len - 1) {\n\t\tint a = (n + len - 1) - p;\n\n\t\treturn calc(pii(seg.scd - a, seg.scd), p);\n\t}\n\n\tif (p <= n && n + len - 1 <= q) {\n\t\treturn max(min(r - seg.fst + 1, len), 0);\n\t}\n\n\tif (n <= q && q < n + len - 1) {\n\t\tint a = q - n;\n\n\t\treturn calc(pii(seg.fst, seg.fst + a), n);\n\t}\n\n\treturn 0;\n}\n\nint main()\n{\n\tomajinai;\n\n\twhile (cin >> n >> m >> p >> q >> r, n) {\n\t\tdeque<pii> dat;\n\n\t\tdat.push_back(pii(1, n));\n\n\t\trep(_, m) {\n\t\t\tint x, y; cin >> x >> y;\n\n\t\t\tint sum = 0;\n\n\t\t\tvpii Top, Mid, Bottom;\n\n\t\t\t// Top?????????\n\t\t\twhile (true) {\n\t\t\t\tpii a = dat.front();\n\n\t\t\t\tint v = a.scd - a.fst + 1;\n\n\t\t\t\tif (sum + v >= x) {\n\t\t\t\t\tint dif = x - sum-1;\n\n\t\t\t\t\tsum += dif + 1;\n\n\t\t\t\t\tTop.push_back(pii(a.fst, a.fst + dif));\n\n\t\t\t\t\tdat.pop_front();\n\n\t\t\t\t\tif (a.fst + dif + 1 <= a.scd) dat.push_front(pii(a.fst + dif + 1, a.scd));\n\n\t\t\t\t\tbreak;\n\t\t\t\t} else {\n\t\t\t\t\tTop.PB(a);\n\t\t\t\t\tsum += v;\n\t\t\t\t}\n\n\t\t\t\tdat.pop_front();\n\t\t\t}\n\n\t\t\t// Mid?????????\n\t\t\twhile (true) {\n\t\t\t\tpii a = dat.front();\n\n\t\t\t\tint v = a.scd - a.fst + 1;\n\n\t\t\t\tif (sum + v >= y) {\n\t\t\t\t\tint dif = y - sum-1;\n\n\t\t\t\t\tsum += dif + 1;\n\n\t\t\t\t\tMid.push_back(pii(a.fst, a.fst + dif));\n\n\t\t\t\t\tdat.pop_front();\n\n\t\t\t\t\tif (a.fst + dif + 1 <= a.scd) dat.push_front(pii(a.fst + dif + 1, a.scd));\n\n\t\t\t\t\tbreak;\n\t\t\t\t} else {\n\t\t\t\t\tMid.PB(a);\n\t\t\t\t\tsum += v;\n\t\t\t\t}\n\t\t\t\tdat.pop_front();\n\t\t\t}\n\n\t\t\t// Bottom?????????\n\t\t\twhile (true) {\n\t\t\t\tpii a = dat.front();\n\n\t\t\t\tint v = a.scd - a.fst + 1;\n\n\t\t\t\tif (sum + v == n) {\n\t\t\t\t\tsum += v;\n\n\t\t\t\t\tBottom.push_back(pii(a.fst, a.scd));\n\n\t\t\t\t\tdat.pop_front();\n\n\t\t\t\t\tbreak;\n\t\t\t\t} else {\n\t\t\t\t\tBottom.PB(a);\n\t\t\t\t\tsum += v;\n\t\t\t\t}\n\n\t\t\t\tdat.pop_front();\n\t\t\t}\n\n\t\t\trep(i, Bottom.size()) dat.push_back(Bottom[i]);\n\t\t\trep(i, Mid.size()) dat.push_back(Mid[i]);\n\t\t\trep(i, Top.size()) dat.push_back(Top[i]);\n\t\t}\n\n\t\tint sum = 1;\n\t\tint ans = 0;\n\n\t\tfor (pii a : dat) {\n\t\t\tans += calc(a, sum);\n\t\t\tsum += a.scd - a.fst + 1;\n\t\t}\n\n\t\tcout << ans << endl;\n\t}\n}"
  },
  {
    "language": "C++",
    "code": "#include <iostream>\n#include <algorithm>\n#include <vector>\nusing namespace std;\nint main(){\n\tint n,m,p,q,r,x,y;\n\tvector<int>::iterator u,v,z;\n\tfor(;cin>>n>>m>>p>>q>>r;cout<<x<<endl){\n\t\tvector<int> s,t;\n\t\ts.push_back(0);\n\t\tfor(s.push_back(r);m--;t.clear()){\n\t\t\tcin>>x>>y;\n\t\t\tu=upper_bound(s.begin(),s.end(),x);\n\t\t\tv=upper_bound(s.begin(),s.end(),y);\n\t\t\t\n\t\t\tif( v-s.begin()+1 & 1 )t.push_back(0);\n\t\t\tt.push_back(0);\n\t\t\tfor(z=v;z!=s.end();++z)\n\t\t\t\tt.push_back(*z - y);\n\t\t\t\n\t\t\tif(s.end()-u & 1)t.push_back(n-y);\n\t\t\tfor(z=u;z!=v;++z)\n\t\t\t\tt.push_back(*z-x+n-y);\n\t\t\t\n\t\t\tz = s.begin();\n\t\t\tif(v-s.begin() & 1)++z;\n\t\t\tif(!z[1])z+=2;\n\t\t\tif(*z+n-x==t.back()){++z;t.pop_back();}\n\t\t\tfor(;z!=u;++z)\n\t\t\t\tt.push_back(*z+n-x);\n\t\t\t\n\t\t\ts.swap(t);\n\t\t}\n\t\ts.insert( upper_bound(s.begin(),s.end(),p-1), 2, p-1);\n\t\ts.insert( lower_bound(s.begin(),s.end(),q), q );\n\t\ts.push_back(n);\n\t\tz = upper_bound(s.begin(),s.end(),p-1);\n\t\tif(z-s.begin() & 1) --z;\n\t\tfor(x=0;*z<q;++z)\n\t\t\tm=*z++,x+=*z-m;\n\t}\n}"
  },
  {
    "language": "C++",
    "code": "#include <iostream>\n#include <algorithm>\n#include <string>\n#include <vector>\nusing namespace std;\n\nint N, M, P, Q, R;\n\nint sign(int x) {\n  if (x >= 0) return 1;\n  else        return -1;\n}\n\nvoid div(vector<int> &s, int x, int y, vector<int> &a, vector<int> &b, vector<int> &c) {\n  int i = 0, h = 0;\n  for (; i<s.size(); i++) {\n    h += abs(s[i]);\n    if (h >= x) {\n      int fa = x - (h-abs(s[i])),\n          fb = h - x;\n      if (fa > 0) a.push_back(sign(s[i]) * fa);\n      if (fb > 0) {\n        h -= fb;\n        s[i] = sign(s[i]) * fb;\n      }\n      else i++;\n      break;\n    }\n    a.push_back(s[i]);\n  }\n  for (; i<s.size(); i++) {\n    h += abs(s[i]);\n    if (h >= y) {\n      int fa = y - (h-abs(s[i])),\n          fb = h - y;\n      if (fa > 0) b.push_back(sign(s[i]) * fa);\n      if (fb > 0) {\n        h -= fb;\n        s[i] = sign(s[i]) * fb;\n      }\n      else i++;\n      break;\n    }\n    b.push_back(s[i]);\n  }\n  for (; i<s.size(); i++) {\n    c.push_back(s[i]);\n  }\n}\n\nint main() {\n  while (cin >> N) {\n    if (N == 0) break;\n    cin >> M >> P >> Q >> R;\n\n    vector<int> s;\n    s.push_back(R), s.push_back(R-N);\n\n    for (int k=0; k<M; k++) {\n      int x, y;\n      cin >> x >> y;\n      vector<int> a, b, c;\n      div(s, x, y, a, b, c);\n      s.clear();\n      s.insert(s.end(), c.begin(), c.end());\n      s.insert(s.end(), b.begin(), b.end());\n      s.insert(s.end(), a.begin(), a.end());\n    }\n\n    vector<int> a, b, c;\n    div(s, P-1, Q, a, b, c);\n    int ans = 0;\n    for (auto x : b) ans += max(x, 0);\n    cout << ans << \"\\n\";\n  }\n  return 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include <cstdio>\n#include <deque>\n#include <utility>\nusing namespace std;\ntypedef pair<int,int> P;\ndeque<P> que;\ndeque<P> removeCard(int x) {\n\tdeque<P> res;\n\twhile(1) {\n\t\tP p=que.front();que.pop_front();\n\t\tx-=(p.second-p.first+1);\n\t\tif(x<=0) {\n\t\t\tif(x!=0) {\n\t\t\t\tque.push_front(P(p.second+x+1,p.second));\n\t\t\t\tp.second+=x;\n\t\t\t}\n\t\t\tres.push_back(p);\n\t\t\tbreak;\n\t\t}\n\t\tres.push_back(p);\n\t}\n\treturn res;\n}\nvoid shuffle(int x,int y) {\n\tdeque<P> A=removeCard(x),B=removeCard(y-x);\n\tfor(int i=0;i<B.size();i++)que.push_back(B[i]);\n\tfor(int i=0;i<A.size();i++)que.push_back(A[i]);\n}\nint main() {\n\tint n,m,p,q,r,x,y;\n\twhile(scanf(\"%d\",&n),n) {\n\t\tque.clear();\n\t\tque.push_back(P(1,n));\n\t\tscanf(\"%d\",&m);\n\t\tscanf(\"%d %d %d\",&p,&q,&r);\n\t\tfor(int i=0;i<m;i++) {\n\t\t\tscanf(\"%d %d\",&x,&y);\n\t\t\tshuffle(x,y);\n\t\t}\n\t\tremoveCard(p-1);\n\t\tdeque<P> rem=removeCard(q-p+1);\n\t\tint ans=0;\n\t\tfor(int i=0;i<rem.size();i++) {\n\t\t\tif(rem[i].first<=r) {\n\t\t\t\tif(rem[i].second>=r) {\n\t\t\t\t\tans+=(r-rem[i].first+1);\n\t\t\t\t}else {\n\t\t\t\t\tans+=(rem[i].second-rem[i].first+1);\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t\tprintf(\"%d\\n\",ans);\n\t}\n}"
  },
  {
    "language": "C++",
    "code": "#include<iostream>\n#include<sstream>\n#include<cstdio>\n#include<cstdlib>\n#include<vector>\n#include<string>\n#include<stack>\n#include<queue>\n#include<deque>\n#include<set>\n#include<map>\n#include<algorithm>\n#include<functional>\n#include<utility>\n#include<cmath>\n#include<ctime>\n#include<complex>\n\nusing namespace std;\n\n#define REP(i,s,e) for(int i=int(s);i<=int(e);i++)\n#define rep(i,n) for(int i=0;i<int(n);i++)\n\nvector<int>u,v;\nint n;\nvoid f1(int x,int y){\n\trep(i,n-y) v[i]=u[y+i];\n\trep(i,y-x) v[i+n-y]=u[x+i];\n\trep(i,x) v[n-x+i]=u[i];\n}\n\nvoid f2(int x,int y){\n\trep(i,n-y) u[i]=v[y+i];\n\trep(i,y-x) u[i+n-y]=v[x+i];\n\trep(i,x) u[n-x+i]=v[i];\n}\n\nint main(){\n\n\tint m,p,q,r,x,y;\n\n\twhile(1){\n\n\t\tcin >> n;\n\t\tif(n==0) break;\n\t\tcin >> m >> p >> q >> r;\n\n\t\trep(i,n){\n\t\t\tu.push_back(i+1); v.push_back(0);\n\t\t}\n\n\t\tREP(i,1,m){\n\n\t\t\tcin >> x >> y;\n\n\t\t\tif(i%2==1) f1(x,y);\n\t\t\telse f2(x,y);\n\t\t}\n\n\t\tint c=0;\n\t\tif(m%2==1){\n\t\t\tREP(i,p-1,q-1)\n\t\t\tif(v[i]<=r) c++;\n\t\t}\n\t\telse{\n\t\t\tREP(i,p-1,q-1)\n\t\t\tif(u[i]<=r) c++;\n\t\t}\n\n\t\tcout << c << endl;\n\n\t\tu.clear(); v.clear();\n\n\t}\n\n\treturn 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include<stdio.h>\n#include<algorithm>\nusing namespace std;\npair<int,int> wolf[12000];\npair<int,int> top[12000];\npair<int,int> middle[12000];\npair<int,int> bottom[12000];\nint T,M,B;\nint size;\nint main(){\n\tint a;\n\twhile(scanf(\"%d\",&a),a){\n\t\tint b;\n\t\tscanf(\"%d\",&b);\n\t\tint p,q,r;\n\t\tscanf(\"%d%d%d\",&p,&q,&r);p--;\n\t\tsize=1;\n\t\twolf[0]=make_pair(0,a);\n\t\tfor(int i=0;i<b;i++){\n\t\t\tint s,t;\n\t\t\tscanf(\"%d%d\",&s,&t);\n\t\t\tint num=0;\n\t\t\tint phase=0;\n\t\t\tint P=0;\n\t\t\tfor(int j=0;j<size;j++){\n\t\t\t\tif(phase==0&&num+wolf[j].second-wolf[j].first>s){\n\t\t\t\t\tfor(int k=0;k<j;k++)bottom[k]=wolf[k];\n\t\t\t\t\tbottom[j]=make_pair(wolf[j].first,wolf[j].first+s-num);\n\t\t\t\t\twolf[j]=make_pair(wolf[j].first+s-num,wolf[j].second);\n\t\t\t\t\tnum=s;\n\t\t\t\t\tB=j+1;\n\t\t\t\t\tP=j;\n\t\t\t\t\tphase++;\n\t\t\t\t\tj--;\n\t\t\t\t\tcontinue;\n\t\t\t\t}\n\t\t\t\tif(phase==1&&num+wolf[j].second-wolf[j].first>t){\n\t\t\t\t\tfor(int k=P;k<j;k++)middle[k-P]=wolf[k];\n\t\t\t\t\tmiddle[j-P]=make_pair(wolf[j].first,wolf[j].first+t-num);\n\t\t\t\t\twolf[j]=make_pair(wolf[j].first+t-num,wolf[j].second);\n\t\t\t\t\tM=j-P+1;\n\t\t\t\t\tfor(int k=j;k<size;k++){\n\t\t\t\t\t\ttop[k-j]=wolf[k];\n\t\t\t\t\t}\n\t\t\t\t\tT=size-j;\n\t\t\t\t\tbreak;\n\t\t\t\t}\n\t\t\t\tnum+=wolf[j].second-wolf[j].first;\n\t\t\t}\n\t\t\tfor(int j=0;j<T;j++)wolf[j]=top[j];\n\t\t\tfor(int j=0;j<M;j++)wolf[j+T]=middle[j];\n\t\t\tfor(int j=0;j<B;j++)wolf[j+T+M]=bottom[j];\n\t\t\tsize=T+M+B;\n\t\t}\n\t\tint num=0;\n\t\tint ret=0;\n\t//\tfor(int i=0;i<size;i++)printf(\"%d %d\\n\",wolf[i].first,wolf[i].second);\n\t\tfor(int i=0;i<size;i++){\n\t\t\tif(num+wolf[i].second-wolf[i].first>p){\n\t\t\t\tint x=p-num;\n\t\t\t\tif(wolf[i].first+num-p<=r)ret-=num-p;\n\t\t\t\telse if(wolf[i].first<=r)ret-=r-wolf[i].first;\n\t\t\t\tbreak;\n\t\t\t}else{\n\t\t\t\tif(wolf[i].second<=r)ret-=wolf[i].second-wolf[i].first;\n\t\t\t\telse if(wolf[i].first<=r)ret-=r-wolf[i].first;\n\t\t\t}\n\t\t\tnum+=wolf[i].second-wolf[i].first;\n\t\t}\n\t\tnum=0;\n\t\tfor(int i=0;i<size;i++){\n\t\t\tif(num+wolf[i].second-wolf[i].first>q){\n\t\t\t\tint x=q-num;\n\t\t\t\tif(wolf[i].first+num-q<=r)ret+=num-q;\n\t\t\t\telse if(wolf[i].first<=r)ret+=r-wolf[i].first;\n\t\t\t\tbreak;\n\t\t\t}else{\n\t\t\t\tif(wolf[i].second<=r)ret+=wolf[i].second-wolf[i].first;\n\t\t\t\telse if(wolf[i].first<=r)ret+=r-wolf[i].first;\n\t\t\t}\n\t\t\tnum+=wolf[i].second-wolf[i].first;\n\t\t}\n\t\tprintf(\"%d\\n\",ret);\n\t}\n}"
  },
  {
    "language": "C++",
    "code": "#define _USE_MATH_DEFINES\n#define INF 0x3f3f3f3f\n\n#include <iostream>\n#include <cstdio>\n#include <sstream>\n#include <cmath>\n#include <cstdlib>\n#include <algorithm>\n#include <queue>\n#include <stack>\n#include <limits>\n#include <map>\n#include <string>\n#include <cstring>\n#include <set>\n#include <deque>\n#include <bitset>\n#include <list>\n#include <cctype>\n#include <utility>\n  \nusing namespace std;\n  \ntypedef long long ll;\ntypedef pair <int,int> P;\ntypedef pair <int,P> PP;\n  \nstatic const double EPS = 1e-8;\n  \nstatic const int tx[] = {0,1,0,-1};\nstatic const int ty[] = {-1,0,1,0};\n\nint main(){\n  int total_cards;\n  while(~scanf(\"%d\",&total_cards)){\n    if(total_cards == 0) break;\n    int total_shuffles;\n    int first,last,upper;\n\n    scanf(\"%d\",&total_shuffles);\n    scanf(\"%d %d %d\",&first,&last,&upper);\n    \n    vector<P> cards;\n    cards.push_back(P(1,total_cards));\n\n    for(int shuffle_idx=0;shuffle_idx<total_shuffles;shuffle_idx++){\n      int x,y;\n      scanf(\"%d %d\",&x,&y);\n      //x -> none\n      //y -> 1\n      //n -> x+1\n      //C -> B -> A\n      vector<P> A;\n      vector<P> B;\n      vector<P> C;\n      vector<P> next;\n\n      int sum = 0;\n      int prev_sum = 0;\n      for(int j=0;j<cards.size();j++){\n        prev_sum = sum;\n        sum += cards[j].second - cards[j].first + 1;\n        if(prev_sum < x){\n          if(sum <= x){\n            A.push_back(cards[j]);\n          }\n          else if(sum > x && sum <= y){\n            A.push_back(P(cards[j].first,cards[j].first + (x - prev_sum - 1)));\n            B.push_back(P(cards[j].first + (x - prev_sum),\n                          cards[j].second));\n          }\n          else if(sum > y){\n            A.push_back(P(cards[j].first,cards[j].first + (x - prev_sum - 1)));\n            B.push_back(P(cards[j].first + (x - prev_sum),\n                          cards[j].first + (x - prev_sum) + (y - x - 1)));\n            C.push_back(P(cards[j].first + (x - prev_sum) + (y - x),\n                          cards[j].second));\n          }\n        }\n        else if(prev_sum >= x){\n          if(prev_sum < y){\n            if(sum <= y){\n              B.push_back(P(cards[j].first,cards[j].second));\n            }\n            else if(sum > y){\n              B.push_back(P(cards[j].first,cards[j].first + (y - prev_sum - 1)));\n              C.push_back(P(cards[j].first + (y - prev_sum),cards[j].second));\n            }\n          }\n          else if(prev_sum >= y){\n            C.push_back(P(cards[j].first,cards[j].second));\n          }\n        }\n      }\n      for(int i=0;i<C.size();i++){\n        next.push_back(C[i]);\n        // cout << \"C<f,s>=\" << C[i].first << \",\" << C[i].second << endl;\n      }\n      for(int i=0;i<B.size();i++){\n        next.push_back(B[i]);\n        // cout << \"B<f,s>=\" << B[i].first << \",\" << B[i].second << endl;\n      }\n      for(int i=0;i<A.size();i++){\n        next.push_back(A[i]);\n        // cout << \"A<f,s>=\" << A[i].first << \",\" << A[i].second << endl;\n      }\n      // cout << endl;\n      cards = next;\n    }\n\n    int offset = 0;\n    int res = 0;\n    for(int i=0;i<cards.size();i++){\n      int current = cards[i].second - cards[i].first + 1;\n      if(offset + current < first){\n        offset += current;\n        continue;\n      }\n      if(offset >= last){\n        offset += current;\n        continue;\n      }\n\n      int lhs = -1;\n      int rhs = 1000000001;\n\n      for(int round = 0; round < 50; round++){\n        int mid = (lhs + rhs) / 2;\n        if(cards[i].first + mid > upper){\n          rhs = mid;\n        }\n        if(cards[i].first + mid <= upper){\n          lhs = mid;\n        }\n      }\n\n      lhs = min(lhs + 1,cards[i].second - cards[i].first + 1);\n      if(offset + lhs >= last){\n        lhs = offset + lhs - last;\n      }\n      res += lhs;\n\n      // cout << \"offset \" << offset << endl;\n      // cout << \"<f,s>=\" << cards[i].first << \",\" << cards[i].second << endl;\n      // cout << \"lhs=\" << lhs << endl;\n\n      offset += current;\n    }\n    printf(\"%d\\n\",res);\n\n  }\n}"
  },
  {
    "language": "C++",
    "code": "#include <cstdio>\n#include <cstdlib>\n#include <cstring>\n#include <cmath>\n#include <climits>\n#include <cfloat>\n#include <ctime>\n#include <map>\n#include <utility>\n#include <set>\n#include <iostream>\n#include <memory>\n#include <string>\n#include <vector>\n#include <algorithm>\n#include <functional>\n#include <sstream>\n#include <complex>\n#include <stack>\n#include <queue>\n#include <numeric>\n#include <list>\n\nusing namespace std;\n\n#ifdef _MSC_VER\n#define __typeof__ decltype\n\ntemplate <class T>\nint __builtin_popcount(T n) { return n ? 1 + __builtin_popcount(n & (n - 1)) : 0; }\n#endif\n\n#define foreach(it, c) for (__typeof__((c).begin()) it=(c).begin(); it != (c).end(); ++it)\n#define all(c) (c).begin(), (c).end()\n#define rall(c) (c).rbegin(), (c).rend()\n#define popcount __builtin_popcount\n\n#define rep(i, n) for (int i = 0; i < n; ++i)\n\ntemplate <class T> void max_swap(T& a, const T b) { a = max(a, b); }\ntemplate <class T> void min_swap(T& a, const T b) { a = min(a, b); }\n\nconst double EPS = 1e-10;\ntypedef long long ll;\ntypedef pair<int, int> pint;\n\n\nstruct Range\n{\n\tRange() {}\n\tRange(int top, int n) : top(top), n(n) {}\n\tpair<Range, Range> split(int num)\n\t{\n\t\treturn make_pair(Range(top, num), Range(top + num, n - num));\n\t}\n\tint top, n;\n};\nqueue<Range> pile;\nRange a[500000], b[500000], c[500000];\nint size;\nint next(int& sum, int until_sum, Range* a)\n{\n\tint j = 0;\n\tfor (; sum < until_sum; )\n\t{\n\t\tif (sum + pile.front().n <= until_sum)\n\t\t{\n\t\t\t//a.push_back(pile[i]);\n\t\t\ta[j++] = pile.front();\n\t\t\tsum += pile.front().n;\n\t\t\tpile.pop();\n\t\t}\n\t\telse\n\t\t{\n\t\t\tpair<Range, Range> t = pile.front().split(until_sum - sum);\n\t\t\t//a.push_back(t.first);\n\t\t\ta[j++] = t.first;\n\t\t\tsum = until_sum;\n\n\t\t\tpile.front() = t.second;\n\t\t\tbreak;\n\t\t}\n\t}\n\treturn j;\n}\nint main()\n{\n\tint n, m, p, q, r;\n\twhile (scanf(\"%d\", &n), n)\n\t{\n\t\tscanf(\"%d%d%d%d\", &m, &p, &q, &r);\n\n\t\t//pile.push_back(Range(1, n));\n\t\tpile = queue<Range>();\n\t\tpile.push(Range(1, n));\n\t\twhile (m--)\n\t\t{\n\t\t\tint x, y;\n\t\t\tscanf(\"%d%d\", &x, &y);\n\n\t\t\tint sum = 0;\n\t\t\t//next(pile, p, sum, x, a);\n\t\t\t//next(pile, p, sum, y, b);\n\t\t\t//for ( ; p < pile.size(); ++p)\n\t\t\t//\tc.push_back(pile[p]);\n\t\t\tint a_size = next(sum, x, a);\n\t\t\tint b_size = next(sum, y, b);\n\t\t\t\n\t\t\t//pile.insert(pile.end(), all(b));\n\t\t\t//pile.insert(pile.end(), all(a));\n\t\t\trep (i, b_size)\n\t\t\t\tpile.push(b[i]);\n\t\t\trep (i, a_size)\n\t\t\t\tpile.push(a[i]);\n\t\t}\n\n\n\t\tint i = 0, sum = 0;\n\t\t//next(pile, i, sum, p - 1, a);\n\t\t//next(pile, i, sum, q, b);\n\t\tint a_size = next(sum, p - 1, a);\n\t\tint b_size = next(sum, q, b);\n\n\t\tint res = 0;\n\t\trep (i, b_size)\n\t\t\tres += min(b[i].n, max(0, r - (b[i].top - 1)));\n\t\t\n\t\tprintf(\"%d\\n\", res);\n\t}\n}"
  },
  {
    "language": "C++",
    "code": "#include <iostream>\n#include <vector>\n\nusing namespace std;\n\ntypedef pair<int,int> P;\n\nvoid solve(int n) {\n    int m;\n    cin >> m;\n    int p,q,r;\n    cin >> p >> q >> r;\n\n    vector<P> card[2];\n    card[0].push_back(P(1,n));\n\n    vector<P> temp;\n    for(int i=0; i<m; ++i) {\n        int x,y;\n        cin >> x >> y;\n\n        card[(i+1)%2].clear();\n\n        int j=0;\n        int cnt=0;\n        int idx,idy;\n        while(j<(int)card[i%2].size()) {\n            if(cnt+card[i%2][j].second<=x) {\n                temp.push_back(card[i%2][j]);\n                cnt+=card[i%2][j].second;\n                if(cnt==x) idx=(int)temp.size();\n                ++j;\n            } else if(cnt<x) {\n                temp.push_back(P(card[i%2][j].first,x-cnt));\n                card[i%2][j].first+=x-cnt;\n                card[i%2][j].second-=x-cnt;\n                cnt=x;\n                idx=(int)temp.size();\n            } else if(cnt+card[i%2][j].second<=y) {\n                temp.push_back(card[i%2][j]);\n                cnt+=card[i%2][j].second;\n                if(cnt==y) idy=(int)temp.size();\n                ++j;\n            } else if(cnt<y) {\n                temp.push_back(P(card[i%2][j].first,y-cnt));\n                card[i%2][j].first+=y-cnt;\n                card[i%2][j].second-=y-cnt;\n                cnt=y;\n                idy=(int)temp.size();\n            } else {\n                temp.push_back(card[i%2][j]);\n                cnt+=card[i%2][j].second;\n                ++j;\n            }\n        }\n\n        for(int j=idy; j<(int)temp.size(); ++j) {\n            card[(i+1)%2].push_back(temp[j]);\n        }\n        for(int j=idx; j<idy; ++j) {\n            card[(i+1)%2].push_back(temp[j]);\n        }\n        for(int j=0; j<idx; ++j) {\n            card[(i+1)%2].push_back(temp[j]);\n        }\n\n        temp.clear();\n    }\n\n    int ans=0;\n    int c=0;\n\n    for(int i=0; i<(int)card[m%2].size(); ++i) {\n        int mx,mn;\n        if(c>q) break;\n        if(c+card[m%2][i].second<p) {\n            c+=card[m%2][i].second;\n            continue;\n        }\n        if(c<p) {\n            mn=card[m%2][i].first+p-c-1;\n        } else {\n            mn=card[m%2][i].first;\n        }\n        if(c+card[m%2][i].second>q) {\n            mx=card[m%2][i].first+q-c-1;\n        } else {\n            mx=card[m%2][i].first+card[m%2][i].second-1;\n        }\n        ans+=max(0,min(mx,r)-mn+1);\n        c+=card[m%2][i].second;\n    }\n\n    cout << ans << endl;\n\n    return;\n}\n\n\nint main() {\n    int n;\n    while(true) {\n        cin >> n;\n        if(n==0) break;\n        solve(n);\n    }\n    return 0;\n}\n"
  },
  {
    "language": "C++",
    "code": "#include <cstdio>\n#include <vector>\n#include <map>\n#include <algorithm>\n#define fi first\n#define sec second\nusing namespace std;\ntypedef pair<int,int> P;\n\nint n, m, p, q, r;\nint ans;\nvector<P> v;\nvector<P>::iterator it;\n\nvoid solve(){\n\tans = 0;\n\tv.clear();\n\tv.push_back(P(1,n));\n\tscanf(\"%d%d%d%d\", &m, &p, &q, &r);\n\tint pst;\n\tfor(int i = 0; i < m; i++){\n\t\tint x = 0, y = 0; scanf(\"%d%d\", &x, &y);\n\t\tpst = 0;\n\t\tint cnt = 0;\n\t\tfor(it = v.begin(); it != v.end(); it++){\n\t\t\tcnt++;\n\t\t\tpst += (*it).sec-(*it).fi+1;\n\t\t\tif(pst < x) continue;\n\t\t\tif(pst == x){\n\t\t\t\tx = cnt-1;\n\t\t\t\tbreak;\n\t\t\t}\n\t\t\tint in = (*it).sec;\n\t\t\t(*it).sec = (*it).sec-(pst-x);\n\t\t\tv.insert(it+1,P((*it).sec+1,in));\n\t\t\tx = cnt-1;\n\t\t\tbreak;\n\t\t}\n\t\tpst = 0;\n\t\tcnt = 0;\n\t\t/*\n\t\tfor(int j = 0; j < v.size(); j++){\n\t\t\tprintf(\" %d %d\\n\", v[j].fi, v[j].sec);\n\t\t}\n\t\t*/\n\t\tfor(it = v.begin(); it != v.end(); it++){\n\t\t\tcnt++;\n\t\t\tpst += (*it).sec-(*it).fi+1;\n\t\t\tif(pst < y) continue;\n\t\t\tif(pst == y){\n\t\t\t\ty = cnt-1;\n\t\t\t\tbreak;\n\t\t\t}\n\t\t\tint in = (*it).sec;\n\t\t\t(*it).sec = (*it).sec-(pst-y);\n\t\t\tv.insert(it+1,P((*it).sec+1,in));\n\t\t\ty = cnt-1;\n\t\t\tbreak;\n\t\t}\n\t\tvector<P> tmp;\n\t\tfor(int j = y+1; j < v.size(); j++) tmp.push_back(v[j]);\n\t\tfor(int j = x+1; j <= y; j++) tmp.push_back(v[j]);\n\t\tfor(int j = 0; j <= x; j++) tmp.push_back(v[j]);\n\t\tv = tmp;\n\t\t/*\n\t\tprintf(\"\\n\");\n\t\tfor(int j = 0; j < v.size(); j++){\n\t\t\tprintf(\"%d %d\\n\", v[j].fi, v[j].sec);\n\t\t}\n\t\t*/\n\t}\n\tpst = 0;\n\tfor(int i = 0; i < v.size(); i++){\n\t\tpst += v[i].sec-v[i].fi+1;\n\t\tif(v[i].fi > r) continue;\n\t\tif(pst < p) continue;\n\t\tif(pst-(v[i].sec-v[i].fi) > q) continue;\n\t\tif(pst <= q){\n\t\t\tif(r >= v[i].sec) ans += v[i].sec-v[i].fi+1;\n\t\t\telse ans += r-v[i].fi+1;\n\t\t} else{\n\t\t\tif(r >= v[i].fi+q-(pst-v[i].sec+v[i].fi)) ans += q-(pst-v[i].sec+v[i].fi)+1;\n\t\t\telse ans += r-v[i].fi+1;\n\t\t}\n\t\t//printf(\"%d\\n\", ans);\n\t}\n\tprintf(\"%d\\n\", ans);\n}\n\nint main(){\n\twhile(scanf(\"%d\", &n),n) solve();\n}"
  },
  {
    "language": "C++",
    "code": "#include <iostream>\n#include <sstream>\n#include <cstdio>\n#include <cstdlib>\n#include <cmath>\n#include <ctime>\n#include <cstring>\n#include <string>\n#include <vector>\n#include <stack>\n#include <queue>\n#include <deque>\n#include <map>\n#include <set>\n#include <bitset>\n#include <numeric>\n#include <utility>\n#include <iomanip>\n#include <algorithm>\n#include <functional>\nusing namespace std;\n\ntypedef long long ll;\ntypedef vector<int> vint;\ntypedef vector<long long> vll;\ntypedef pair<int,int> pint;\ntypedef pair<long long, long long> pll;\n\n#define MP make_pair\n#define PB push_back\n#define ALL(s) (s).begin(),(s).end()\n#define EACH(i, s) for (__typeof__((s).begin()) i = (s).begin(); i != (s).end(); ++i)\n#define COUT(x) cout << #x << \" = \" << (x) << \" (L\" << __LINE__ << \")\" << endl\n\ntemplate<class T> inline bool chmax(T& a, T b) { if (a < b) { a = b; return 1; } return 0; }\ntemplate<class T> inline bool chmin(T& a, T b) { if (a > b) { a = b; return 1; } return 0; }\ntemplate<class T1, class T2> ostream& operator << (ostream &s, pair<T1,T2> P) \n{ return s << '<' << P.first << \", \" << P.second << '>'; }\ntemplate<class T> ostream& operator << (ostream &s, vector<T> P) \n{ for (int i = 0; i < P.size(); ++i) { if (i > 0) { s << \" \"; } s << P[i]; } return s; }\ntemplate<class T1, class T2> ostream& operator << (ostream &s, map<T1,T2> P) \n{ EACH(it, P) { s << \"<\" << it->first << \"->\" << it->second << \"> \"; } return s; }\n\n\n\nint n, m, p, q, r, x, y;\n\nint num(vector<pint> now, int p) {\n    int res = 0, tot = 0;\n    int i;\n    for (i = 0; i < now.size(); ++i) {\n        if (tot <= p && p < tot + now[i].second - now[i].first) break;\n        tot += now[i].second - now[i].first;\n        \n        int tmp = min(r, now[i].second) - max(0, now[i].first);\n        if (tmp >= 0) res += tmp;\n        \n        //cout << i << \" : \" << tmp << endl;\n    }\n    int tmp = min(r, now[i].first + p - tot) - max(0, now[i].first);\n    if (tmp >= 0) res += tmp;\n    \n    //cout << tmp << endl;\n    \n    return res;\n}\n\nint main() {\n    //freopen( \"/Users/macuser/Dropbox/Contest/input.in\", \"r\", stdin );\n    while (cin >> n) {\n        if (n == 0) break;\n        cin >> m >> p >> q >> r;\n        vector<pint> now(1, pint(0, n));\n        \n        for (int id = 0; id < m; ++id) {\n            cin >> x >> y;\n            vector<pint> s1, s2, s3;\n            int tot = 0;\n            int i;\n            for (i = 0; i < now.size(); ++i) {\n                if (tot <= x && x < tot + now[i].second - now[i].first) break;\n                tot += now[i].second - now[i].first;\n                s1.PB(now[i]);\n            }\n            if (tot < x) s1.PB(pint(now[i].first, now[i].first + x - tot));\n            now[i].first = now[i].first + x - tot;\n            tot = x;\n            \n            int j;\n            for (j = i; j < now.size(); ++j) {\n                if (tot <= y && y < tot + now[j].second - now[j].first) break;\n                tot += now[j].second - now[j].first;\n                s2.PB(now[j]);\n            }\n            if (tot < y) s2.PB(pint(now[j].first, now[j].first + y - tot));\n            now[j].first = now[j].first + y - tot;\n            tot = y;\n            \n            for (int k = j; k < now.size(); ++k) {\n                tot += now[k].second - now[k].first;\n                s3.PB(now[k]);\n            }\n\n            now.clear();\n            for (int i = 0; i < s3.size(); ++i) now.PB(s3[i]);\n            for (int i = 0; i < s2.size(); ++i) now.PB(s2[i]);\n            for (int i = 0; i < s1.size(); ++i) now.PB(s1[i]);\n            \n            //cout << endl; COUT(s1); COUT(s2); COUT(s3); COUT(now);\n        }\n        \n        int res1 = num(now, q);\n        int res2 = num(now, p-1);\n        \n        //COUT(res1); COUT(res2);\n        \n        cout << res1 - res2 << endl;\n    }\n    return 0;\n}\n"
  },
  {
    "language": "C++",
    "code": "#include <iostream>\n#include <vector>\n#include <string>\n#include <stack>\n#include <queue>\n#include <deque>\n#include <set>\n#include <map>\n#include <algorithm>\t// require sort next_permutation count __gcd reverse etc.\n#include <cstdlib>\t// require abs exit\n#include <cstdio>\t// require scanf printf\n#include <functional>\n#include <numeric>\t// require accumulate\n#include <cmath>\n#include <climits>\n#include <limits>\n#include <cfloat>\n#include <iomanip>\t// require setw\n#include <sstream>\t// require stringstream \n#include <cstring>\t// require memset\n#include <cctype>\t// require tolower, toupper\n#include <fstream>\t// require freopen\n#include <ctime>\n#define rep(i,n) for(int i=0;i<(n);i++)\n#define ALL(A) A.begin(), A.end()\n\nusing namespace std;\n\ntypedef long long ll;\ntypedef pair<int, int> P;\n\nint main()\n{\n//\tcut here before submit \n//\tfreopen (\"testcase.shuffle\", \"r\", stdin );\n\n\tint n;\t// J[hÌ\n\twhile (cin >> n && n ){\n\t\tint m, p, q, r;\t// m: VbtÌñ \n\t\tcin >> m >> p >> q >> r;\t\n\t\tvector <vector <P> > before (m, vector <P> (3 ) );\n\t\tvector <vector <P> > after  (m, vector <P> (3 ) );\n\t\trep (i, m ){\n\t\t\tint x, y;\n\t\t\tcin >> x >> y;\n\t\t\tbefore[i][0] = P (1, x  );\n\t\t\tbefore[i][1] = P (x + 1, y );\n\t\t\tbefore[i][2] = P (y + 1, n );\n\t\t\tafter[i][0] = before[i][2];\n\t\t\tafter[i][1] = before[i][1];\n\t\t\tafter[i][2] = before[i][0];\n\t\t} // end rep\n\n\t\tint res = 0;\n\t\tfor (int w = p; w <= q; w++ ){\n\t\t\tint prev = 0;\n\t\t\tint curr = w;\n\t\t\trep (j, 3 ){\n\t\t\t\tint cn = after[m-1][j].second - after[m-1][j].first + 1;\n\t\t\t\tif (prev < curr && curr <= prev + cn ){\n\t\t\t\t\tcurr = after[m-1][j].first + curr - 1 - prev;\n\t\t\t\t\tbreak;\n\t\t\t\t} // end if\n\t\t\t\tprev += cn;\n\t\t\t} // end rep\n\t\t\tfor (int i = m - 2; i >= 0; i-- ){\n\t\t\t\t// ÇÌRÌ½ÔÚ©ðTõ\n\t\t\t\tint pre = 0;\n\t\t\t\trep (j, 3 ){\n\t\t\t\t\tint c = after[i][j].second - after[i][j].first + 1; // j ÌRÌJ[hÌ\t\t\t\n\t\t\t\t\tif (pre < curr && curr <= pre + c ){\t// ±ÌRÉJ[hª é\n\t\t\t\t\t\tcurr = after[i][j].first + curr - 1 - pre;\n\t\t\t\t\t\tbreak;\n\t\t\t\t\t} // end if\n\t\t\t\t\tpre += c;\n\t\t\t\t} // end rep\n\t\t\t} // end for\n\t\t\tif (curr <= r )\n\t\t\t\tres++;\n\t\t} // end for\n\t\tcout << res << endl;\n\t} // end while\n\t\t\n\treturn 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include<bits/stdc++.h>\nusing namespace std;\n#define h first\n#define w second\nvector<pair<bool,pair<int,int> > >v;\nint n,m,p,q,r,i;\nvoid Vp(bool a,int b,int c){v.push_back(make_pair(a,make_pair(b,c)));}\nint main(){\n\twhile(cin>>n&&n){\n\tcin>>m>>p>>q>>r;v.clear();\n\tVp(1,1,r);Vp(0,r+1,n);\n\twhile(m--){\n\t\tint x,y;scanf(\"%d%d\",&x,&y);\n\t\tfor(i=0;i<v.size();i++){\n\t\t\tint a=v[i].w.h,b=v[i].w.w;bool c=v[i].h;\n\t\t\tif(a<=x&&x<b){Vp(c,x+1,b);b=x;}\n\t\t\tif(a<=y&&y<b){Vp(c,y+1,b);b=y;}\n\t\t\tif(0<a&&b<=x)a+=n-x,b+=n-x;\n\t\t\telse if(x<a&&b<=y)a+=n-x-y,b+=n-x-y;\n\t\t\telse if(y<a&&b<=n)a-=y,b-=y;\n\t\t\tv[i].w.h=a,v[i].w.w=b;\n\t\t}\n\t}n=0;\n\tfor(i=0;i<v.size();i++)if(v[i].h)n+=max(0,1+min(v[i].w.w,q)-max(v[i].w.h,p));\n\tcout<<n<<endl;\n\t}\n\treturn 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include <cstdio>\n#include <cstdlib>\n#include <cstring>\n#include <cmath>\n#include <climits>\n#include <cfloat>\n#include <ctime>\n#include <map>\n#include <utility>\n#include <set>\n#include <iostream>\n#include <memory>\n#include <string>\n#include <vector>\n#include <algorithm>\n#include <functional>\n#include <sstream>\n#include <complex>\n#include <stack>\n#include <queue>\n#include <numeric>\n#include <list>\n\nusing namespace std;\n\n#ifdef _MSC_VER\n#define __typeof__ decltype\n\ntemplate <class T>\nint __builtin_popcount(T n) { return n ? 1 + __builtin_popcount(n & (n - 1)) : 0; }\n#endif\n\n#define foreach(it, c) for (__typeof__((c).begin()) it=(c).begin(); it != (c).end(); ++it)\n#define all(c) (c).begin(), (c).end()\n#define rall(c) (c).rbegin(), (c).rend()\n#define popcount __builtin_popcount\n\n#define rep(i, n) for (int i = 0; i < n; ++i)\n\ntemplate <class T> void max_swap(T& a, const T b) { a = max(a, b); }\ntemplate <class T> void min_swap(T& a, const T b) { a = min(a, b); }\n\nconst double EPS = 1e-10;\ntypedef long long ll;\ntypedef pair<int, int> pint;\n\n\nstruct Range\n{\n\tRange() {}\n\tRange(int top, int n) : top(top), n(n) {}\n\tpair<Range, Range> split(int num)\n\t{\n\t\treturn make_pair(Range(top, num), Range(top + num, n - num));\n\t}\n\tint top, n;\n};\nRange pile[500000], a[500000], b[500000], c[500000];\nint size;\nint next(int& i, int& sum, int until_sum, Range* a)\n{\n\tint j = 0;\n\tfor (i = 0; sum < until_sum; ++i)\n\t{\n\t\tif (sum + pile[i].n <= until_sum)\n\t\t{\n\t\t\t//a.push_back(pile[i]);\n\t\t\ta[j++] = pile[i];\n\t\t\tsum += pile[i].n;\n\t\t}\n\t\telse\n\t\t{\n\t\t\tpair<Range, Range> t = pile[i].split(until_sum - sum);\n\t\t\t//a.push_back(t.first);\n\t\t\ta[j++] = t.first;\n\t\t\tsum = until_sum;\n\n\t\t\tpile[i] = t.second;\n\t\t\tbreak;\n\t\t}\n\t}\n\treturn j;\n}\nint main()\n{\n\tint n, m, p, q, r;\n\twhile (scanf(\"%d\", &n), n)\n\t{\n\t\tscanf(\"%d%d%d%d\", &m, &p, &q, &r);\n\n\t\t//pile.push_back(Range(1, n));\n\t\tpile[0].top = 1, pile[0].n = n;\n\t\tsize = 1;\n\t\twhile (m--)\n\t\t{\n\t\t\tint x, y;\n\t\t\tscanf(\"%d%d\", &x, &y);\n\n\t\t\tint p = 0, sum = 0;\n\t\t\t//next(pile, p, sum, x, a);\n\t\t\t//next(pile, p, sum, y, b);\n\t\t\t//for ( ; p < pile.size(); ++p)\n\t\t\t//\tc.push_back(pile[p]);\n\t\t\tint a_size = next(p, sum, x, a);\n\t\t\tint b_size = next(p, sum, y, b);\n\t\t\tint c_size;\n\t\t\tfor (c_size = 0; p < size; ++p, ++c_size)\n\t\t\t\tc[c_size] = pile[p];\n\t\t\t\n\t\t\t//pile.insert(pile.end(), all(b));\n\t\t\t//pile.insert(pile.end(), all(a));\n\t\t\tsize = 0;\n\t\t\trep (i, c_size)\n\t\t\t\tpile[size++] = c[i];\n\t\t\trep (i, b_size)\n\t\t\t\tpile[size++] = b[i];\n\t\t\trep (i, a_size)\n\t\t\t\tpile[size++] = a[i];\n\t\t}\n\n\n\t\tint i = 0, sum = 0;\n\t\t//next(pile, i, sum, p - 1, a);\n\t\t//next(pile, i, sum, q, b);\n\t\tint a_size = next(p, sum, p - 1, a);\n\t\tint b_size = next(p, sum, q, b);\n\n\t\tint res = 0;\n\t\trep (i, b_size)\n\t\t\tres += min(b[i].n, max(0, r - (b[i].top - 1)));\n\t\t\n\t\tprintf(\"%d\\n\", res);\n\t}\n}"
  },
  {
    "language": "C++",
    "code": "#include<iostream>\n#include<cstdio>\n#include<vector>\n#include<queue>\n#include<algorithm>\n#include<functional>\n#include<cstring>\n#include<iterator>\n#define MAX_N 100000\n#define F first\n#define S second \n#define MP make_pair\nusing namespace std;\ntypedef pair<int, int> P;\n\nconst int INF = 1e9;\n\nint main() {\n\tint n, m, pp, q, r;\n\n\twhile (cin >> n&&n){\t\n\t\tint save = -1, ans = 0;\n\t\tvector<int>vep, vep2, vep3;\n\t\tvep.push_back(1);\n\t\tvep.push_back(n);\n\t    vector<int> vec, vec2, vec3;\n\t\tvec.push_back(1);\n\t\tvec.push_back(n);\n\t\tcin >> m >> pp >> q >> r;\n\t\tfor (int i = 0; i < m; i++) {\n\t\t\tint x, y, p, p2;\n\t\t\tscanf(\"%d%d\", &x, &y);\n\t\t\tp = lower_bound(vec.begin(), vec.end(), x) - vec.begin();\n\t\t\tif (vec[p] != x) {\n\t\t\t\tvec.insert(vec.begin() + p, x);\n\t\t\t\tvep.insert(vep.begin() + p, vec[p] - vec[p - 1] + vep[p - 1]);\n\t\t\t}\n\t\t\tif (vec[p] + 1 != vec[p + 1]) {\n\t\t\t\tvec.insert(vec.begin() + p + 1, x + 1);\n\t\t\t\tvep.insert(vep.begin() + p + 1, vep[p] + 1);\n\t\t\t}\n\t\t\tp2 = lower_bound(vec.begin(), vec.end(), y) - vec.begin();\n\t\t\tif (vec[p2] != y) {\n\t\t\t\tvec.insert(vec.begin() + p2, y);\n\t\t\t\tvep.insert(vep.begin() + p2, vec[p2] - vec[p2 - 1] + vep[p2 - 1]);\n\t\t\t}\n\t\t\tif (vec[p2] + 1 != vec[p2 + 1]) {\n\t\t\t\tvec.insert(vec.begin() + p2 + 1, y + 1);\n\t\t\t\tvep.insert(vep.begin() + p2 + 1, vep[p2] + 1);\n\t\t\t}\n\t\t\tfor (int j = p2 + 1; j < vec.size(); j++) {\n\t\t\t\tvec2.push_back(vec[j] - vec[p2 + 1] + 1);\n\t\t\t\tvep2.push_back(vep[j]);\n\t\t\t}\n\t\t\tint size = vec2[vec2.size() - 1];\n\t\t\tfor (int j = p + 1; j < p2 + 1; j++) {\n\t\t\t\tvec2.push_back(vec[j] - vec[p + 1] + 1 + size);\n\t\t\t\tvep2.push_back(vep[j]);\n\t\t\t}\n\t\t\tsize = vec2[vec2.size() - 1];\n\t\t\tfor (int j = 0; j < p + 1; j++) {\n\t\t\t\tvec2.push_back(vec[j] - vec[0] + 1+size);\n\t\t\t\tvep2.push_back(vep[j]);\n\t\t\t}\n\t\t\tvec3 = vec;\n\t\t\tvep3 = vep;\n\t\t\tvec = vec2;\n\t\t\tvep = vep2;\n\t\t\tvec2 = vec3;\n\t\t\tvep2 = vep3;\n\t\t\tvec2.clear();\n\t\t\tvep2.clear();\n\t\t}\n\t\tint p, p2;\n\t\tp = lower_bound(vec.begin(), vec.end(), pp) - vec.begin();\n\t\t\n\t\tif (vec[p] != pp) {\n\t\t\tvec.insert(vec.begin() + p, pp);\n\t\t\tvep.insert(vep.begin() + p, vec[p] - vec[p - 1] + vep[p - 1]);\n\t\t}\n\t\tif (vec[p] + 1 != vec[p + 1]) {\n\t\t\tvec.insert(vec.begin() + p + 1, pp + 1);\n\t\t\tvep.insert(vep.begin() + p + 1, vep[p] + 1);\n\t\t}\n\t\tp2 = lower_bound(vec.begin(), vec.end(), q) - vec.begin();\n\t\tif (vec[p2] != q) {\n\t\t\tvec.insert(vec.begin() + p2, q);\n\t\t\tvep.insert(vep.begin() + p2, vec[p2] - vec[p2 - 1] + vep[p2 - 1]);\n\t\t}\n\t\tif (vec[p2] + 1 != vec[p2 + 1]) {\n\t\t\tvec.insert(vec.begin() + p2 + 1, q + 1);\n\t\t\tvep.insert(vep.begin() + p2 + 1, vep[p2] + 1);\n\t\t}\n\t\tfor (int i = p; i <= p2; i++) {\n\t\t\tif (i + 1<=p2 && vep[i + 1] - vep[i] == vec[i + 1] - vec[i]) {\n\t\t\t\tif (vep[i + 1] <= r) {\n\t\t\t\t\tans += vep[i + 1] - vep[i];\n\t\t\t\t\tif (save != vep[i])\n\t\t\t\t\t\tans++;\n\t\t\t\t\tsave = vep[i + 1];\n\t\t\t\t}\n\t\t\t\tif (vep[i] <= r&&vep[i + 1] > r) {\n\t\t\t\t\tans += r - vep[i];\n\t\t\t\t\tif (save != vep[i])\n\t\t\t\t\t\tans++;\n\t\t\t\t\tsave = q;\n\t\t\t\t}\n\t\t\t}\n\t\t\telse{\n\t\t\t\tif (vep[i] <= r&&save != vep[i]) {\n\t\t\t\t\tans++;\n\t\t\t\t\tsave = vep[i];\n\t\t\t\t}\n\t\t\t}\n\t}\n\t\tcout << ans << endl;\n\t}\n}"
  },
  {
    "language": "C++",
    "code": "#include <iostream>\n#include <vector>\n#include <algorithm>\n#include <string>\n#include <sstream>\n#include <cstring>\n#include <cstdio>\n#include <cstdlib>\n#include <cmath>\n#include <queue>\n#include <stack>\n#include <map>\n#include <set>\n#include <numeric>\n#include <cctype>\n#include <tuple>\n#include <iterator>\n#include <bitset>\n#include <random>\n#include <assert.h>\n#include <unordered_map>\n#include <array>\n#include <ctime>\n\n#ifdef _MSC_VER\n#include <agents.h>\n#endif\n\n#define FOR(i, a, b) for(int i = (a); i < (int)(b); ++i)\n#define rep(i, n) FOR(i, 0, n)\n#define ALL(v) v.begin(), v.end()\n#define REV(v) v.rbegin(), v.rend()\n#define MEMSET(v, s) memset(v, s, sizeof(v))\n#define X first\n#define Y second\n#define MP make_pair\n#define umap unordered_map\n\nusing namespace std;\n\ntypedef long long ll;\ntypedef unsigned long long ull;\ntypedef long double ld;\ntypedef pair<int, int> P;\ntypedef unsigned int uint;\n\nstruct List{\n\tint val, cnt;\n\tList *next;\n};\n\nList lv[10010];\nint cur;\nList *head0, *tail2;\n\npair<List*, List*> split(List* li, int x){\n\t//if (li == nullptr) return nullptr;\n\tif (li->cnt <= x) return split(li->next, x - li->cnt);\n\tList *ret = &lv[cur++];\n\tret->val = li->val, ret->cnt = li->cnt - x, ret->next = li->next;\n\tli->cnt = x, li->next = ret;\n\tif (tail2 == li) tail2 = ret;\n\treturn MP(li, ret);\n}\n\nint count(List *li, int x){\n\tif (x <= 0) return 0;\n\tif (li->val == 0) return count(li->next, x - li->cnt);\n\tif (li->cnt < x) return li->cnt + count(li->next, x - li->cnt);\n\treturn x;\n}\n\nvoid shuffle(int x, int y){\n\tList *tail0, *head1;\n\ttie(tail0, head1) = split(head0, x);\n\tList *tail1, *head2;\n\ttie(tail1, head2) = split(head1, y - x);\n\n\t// h0->t0->h1->t1->h2->t2\n\t// h2->t2->h1->t1->h0->t0\n\ttail2->next = head1;\n\ttail1->next = head0;\n\ttail0->next = nullptr;\n\thead0 = head2, tail2 = tail0;\n}\n\nint main(){\n\tint n;\n\twhile (cin >> n, n){\n\t\tint m, p, q, r;\n\t\tcin >> m >> p >> q >> r;\n\n\t\tMEMSET(lv, 0);\n\t\tcur = 0;\n\t\thead0 = &lv[cur++];\n\t\thead0->cnt = r;\n\t\thead0->val = 1;\n\t\thead0->next = &lv[cur];\n\t\ttail2 = &lv[cur++];\n\t\ttail2->cnt = n - r;\n\t\ttail2->val = 0;\n\t\ttail2->next = nullptr;\n\n\t\twhile (m--){\n\t\t\tint x, y;\n\t\t\tcin >> x >> y;\n\t\t\tshuffle(x, y);\n\t\t}\n\t\tcout << count(head0, q) - count(head0, p-1) << endl;\n\t}\n\n\treturn 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\nusing namespace std;\n\nusing VI = vector<int>;\nusing VVI = vector<VI>;\nusing PII = pair<int, int>;\nusing LL = long long;\nusing VL = vector<LL>;\nusing VVL = vector<VL>;\nusing PLL = pair<LL, LL>;\nusing VS = vector<string>;\n\n#define ALL(a)  begin((a)),end((a))\n#define RALL(a) (a).rbegin(), (a).rend()\n#define PB push_back\n#define EB emplace_back\n#define MP make_pair\n#define SZ(a) int((a).size())\n#define SORT(c) sort(ALL((c)))\n#define RSORT(c) sort(RALL((c)))\n#define UNIQ(c) (c).erase(unique(ALL((c))), end((c)))\n\n#define FOR(i,a,b) for(int i=(a);i<(b);++i)\n#define REP(i,n)  FOR(i,0,n)\n\n#define FF first\n#define SS second\ntemplate<class S, class T>\nistream& operator>>(istream& is, pair<S,T>& p){\n  return is >> p.FF >> p.SS;\n}\ntemplate<class S, class T>\nostream& operator<<(ostream& os, const pair<S,T>& p){\n  return os << p.FF << \" \" << p.SS;\n}\ntemplate<class T>\nvoid maxi(T& x, T y){\n  if(x < y) x = y;\n}\ntemplate<class T>\nvoid mini(T& x, T y){\n  if(x > y) x = y;\n}\n\n\nconst double EPS = 1e-10;\nconst double PI  = acos(-1.0);\nconst LL MOD = 1e9+7;\n\nint main(){\n  cin.tie(0);\n  ios_base::sync_with_stdio(false);\n\n  int N;\n  while(cin>>N, N){\n\tint M;\n\tcin >> M;\n\tint P, Q, R;\n\tcin >> P >> Q >> R;\n\t--P;\n\n\tset<pair<PII,int>> s[2];\n\tint crt = 0, nxt = 1;\n\ts[crt].insert(MP(MP(0,N),0));\n\tREP(i,M){\n\t  int a, b;\n\t  cin >> a >> b;\n\t  --a;\n\t  s[nxt].clear();\n\t  for(auto x: s[crt]){\n\t\tauto r = x.FF;\n\t\tint ix = x.SS;\n\t\tint l1 = N - b;\n\t\tint l2 = l1 + b - a;\n\t\t\n\t\tif(r.SS <= a){\n\t\t  s[nxt].insert(MP(MP(l2+r.FF, l2+r.SS), ix));\n\t\t}\n\t\telse if(r.FF < a){\n\t\t  if(r.SS <= b){\n\t\t\ts[nxt].insert(MP(MP(l2+r.FF, N), ix));\n\t\t\ts[nxt].insert(MP(MP(l1, l1+r.SS-a), ix+a-r.FF));\n\t\t  }\n\t\t  else{\n\t\t\ts[nxt].insert(MP(MP(l2+r.FF, l2+a), ix));\n\t\t\ts[nxt].insert(MP(MP(l1,l2), ix+a-r.FF));\n\t\t\ts[nxt].insert(MP(MP(0,r.SS-b), ix+b-r.FF));\n\t\t  }\n\t\t}\n\t\telse if(r.FF < b){\n\t\t  if(r.SS <= b){\n\t\t\ts[nxt].insert(MP(MP(l1+r.FF-a,l1+r.SS-a),ix));\n\t\t  }\n\t\t  else{\n\t\t\ts[nxt].insert(MP(MP(l1+r.FF-a,b), ix));\n\t\t\ts[nxt].insert(MP(MP(0,r.SS-b), ix+b-r.FF));\n\t\t  }\n\t\t}\n\t\telse{\n\t\t  s[nxt].insert(MP(MP(r.FF-b,r.SS-b), ix));\n\t\t}\n\t  }\n\t  swap(crt, nxt);\n\t}\n\t\n\tint ans = 0;\n\tfor(auto&& p: s[crt]){\n\t  auto ra = p.FF;\n\t  int ix = p.SS;\n\t  if(ra.SS <= P || Q <= ra.FF) continue;\n\t  int l = max(P, ra.FF);\n\t  int r = min(Q, ra.SS);\n\t  int bix = ix + l-ra.FF;\n\t  if(bix < R){\n\t\tans += min(r-l, R - bix);\n\t  }\n\t}\n\tcout << ans << endl;\n  }\n\n  return 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include <tuple>\n#include <vector>\n#include <iostream>\n#include <algorithm>\n\n#pragma warning(disable : 4996)\n\nusing namespace std;\n\nint n, m, p, q, c, r1, r2;\n\nvector<tuple<int, int, int> > dat; // (l, r, lnum)\n\nvoid divide(int pos)\n{\n\tvector<tuple<int, int, int> > dat1;\n\n\tfor (int i = 0; i < dat.size(); i++)\n\t{\n\t\tint l = get<0>(dat[i]);\n\t\tint r = get<1>(dat[i]);\n\t\tint t = get<2>(dat[i]);\n\n\t\tif (l < pos && pos < r)\n\t\t{\n\t\t\tdat1.push_back(make_tuple(l, pos, t));\n\t\t\tdat1.push_back(make_tuple(pos, r, t + pos - l));\n\t\t}\n\t\telse\n\t\t{\n\t\t\tdat1.push_back(make_tuple(l, r, t));\n\t\t}\n\t}\n\n\tdat = dat1;\n}\n\nint position(int num)\n{\n\tfor (int i = 0; i < dat.size(); i++)\n\t{\n\t\tif (get<0>(dat[i]) <= num && num < get<1>(dat[i]))\n\t\t{\n\t\t\treturn i;\n\t\t}\n\t}\n\n\treturn -1;\n}\n\nvoid shuffle(int a, int b)\n{\n\tdivide(a);\n\tdivide(b);\n\n\tint l = position(a);\n\tint r = position(b);\n\n\tvector<tuple<int, int, int> > dat1;\n\n\tint pos = 0;\n\n\tfor (int i = r; i < dat.size(); i++)\n\t{\n\t\tdat1.push_back(make_tuple(pos, pos - get<0>(dat[i]) + get<1>(dat[i]), get<2>(dat[i]))); pos += get<1>(dat[i]) - get<0>(dat[i]);\n\t}\n\n\tfor (int i = l; i < r; i++)\n\t{\n\t\tdat1.push_back(make_tuple(pos, pos - get<0>(dat[i]) + get<1>(dat[i]), get<2>(dat[i]))); pos += get<1>(dat[i]) - get<0>(dat[i]);\n\t}\n\n\tfor (int i = 0; i < l; i++)\n\t{\n\t\tdat1.push_back(make_tuple(pos, pos - get<0>(dat[i]) + get<1>(dat[i]), get<2>(dat[i]))); pos += get<1>(dat[i]) - get<0>(dat[i]);\n\t}\n\n\tdat = dat1;\n}\n\nint main()\n{\n\tscanf(\"%d\", &n);\n\tscanf(\"%d\", &m);\n\tscanf(\"%d\", &p); p--;\n\tscanf(\"%d\", &q); q--;\n\tscanf(\"%d\", &c);\n\n\tdat.push_back(make_tuple(0, n, 1));\n\n\tfor (int i = 0; i < m; i++)\n\t{\n\t\tscanf(\"%d\", &r1);\n\t\tscanf(\"%d\", &r2);\n\n\t\tshuffle(r1, r2);\n\t}\n\n\tint ret = 0;\n\n\tfor (int i = 0; i < dat.size(); i++)\n\t{\n\t\tint l = get<0>(dat[i]);\n\t\tint r = get<1>(dat[i]);\n\t\tint t = get<2>(dat[i]);\n\n\t\tif (p <= l && r <= q + 1)\n\t\t{\n\t\t\tret += max(c - t + 1, 0);\n\t\t}\n\t\telse if (p <= l)\n\t\t{\n\t\t\tret += min(max(c - t + 1, 0), q - l + 1);\n\t\t}\n\t\telse if (q <= r)\n\t\t{\n\t\t\tret += max(c - (t + (p - l)) + 1, 0);\n\t\t}\n\t}\n\n\tprintf(\"%d\\n\", ret);\n\n\treturn 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include<iostream>\n#include<cstring>\n#include<queue>\nusing namespace std;\n\nstruct tb{\n\tint f,t;\n\ttb(int f,int t): f(f),t(t) {}\n};\n\n\nint n,m,pr,q,r;\nint chx[5001][3];\n\nint main(void){\n\twhile(1){\n\t\tscanf(\"%d\",&n);\n\t\tif(n==0)break;\n\t\tqueue<tb> c;\n\t\tqueue<tb> d[4];\n\t\tc.push(tb(1,n));\n\t\tscanf(\"%d\",&m);\n\t\tscanf(\"%d%d%d\",&pr,&q,&r);\n\t\tfor(int i=0;i<m;i++){\n\t\t\tscanf(\"%d%d\",&chx[i][1],&chx[i][2]);\n\t\t}\n\t\tfor(int i=0;i<m;i++){\n\t\t\tint sh=1,size=0;\n\t\t\twhile(c.size()){\n\t\t\t\ttb p=c.front();c.pop();\n\t\t\t\tsize+=p.t-p.f+1;\n\t\t\t\tif(sh!=3){\n\t\t\t\t\tif(size<=chx[i][sh]){\n\t\t\t\t\t\td[sh].push(tb(p.f,p.t));\n\t\t\t\t\t\tif(size==chx[i][sh])sh++;\n\t\t\t\t\t}else if(sh==2){\n\t\t\t\t\t\tint x=size-p.t+p.f-1;\n\t\t\t\t\t\tint xx=chx[i][2]-x;\n\t\t\t\t\t\td[2].push(tb(p.f,p.f+xx-1));\n\t\t\t\t\t\td[3].push(tb(p.f+xx,p.t));\n\t\t\t\t\t\tsh++;\n\n\t\t\t\t\t}else if(sh==1 && size<=chx[i][2]){\n\t\t\t\t\t\tint x=size-p.t+p.f-1;\n\t\t\t\t\t\tint xx=chx[i][1]-x;\n\t\t\t\t\t\td[1].push(tb(p.f,p.f+xx-1));\n\t\t\t\t\t\td[2].push(tb(p.f+xx,p.t));\n\t\t\t\t\t\tif(size==chx[i][2])sh++;\n\t\t\t\t\t\tsh++;\n\t\t\t\t\t}else{\n\t\t\t\t\t\tint x=size-p.t+p.f-1;\n\t\t\t\t\t\tint xx=chx[i][1]-x;\n\t\t\t\t\t\tint x2=chx[i][2]-chx[i][1];\n\t\t\t\t\t\td[1].push(tb(p.f,p.f+xx-1));\n\t\t\t\t\t\td[2].push(tb(p.f+xx,p.f+xx+x2-1));\n\t\t\t\t\t\td[3].push(tb(p.f+xx+x2,p.t));\n\t\t\t\t\t\tsh=3;\n\t\t\t\t\t}\n\t\t\t\t}else d[sh].push(tb(p.f,p.t));\n\t\t\t}\n\t\t\tfor(int j=3;j>=1;j--){\n\t\t\t\twhile(d[j].size()){\n\t\t\t\t\ttb p=d[j].front();d[j].pop();\n\t\t\t\t\tint pf=p.f,pt=p.t;\n\t\t\t\t\tc.push(tb(pf,pt));\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t\tint size=1;\n\t\tint ans=0;\n\t\twhile(c.size()){\n\t\t\ttb p=c.front();c.pop();\n\t\t\twhile(p.f!=p.t+1){\n\t\t\t\tif(size>=pr && size<=q && p.f<=r)ans++;\n\t\t\t\tp.f++;\n\t\t\t\tsize++;\n\t\t\t}\n\t\t}\n\t\tprintf(\"%d\\n\",ans);\n\t}\n    return 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include <iostream>\n#include <algorithm>\n#include <vector>\n\nusing namespace std;\ntypedef pair<int,int> pii;\n\nint N;\nint M;\nint P,Q,R;\n\nvoid decidePlace(int &sumX,vector<pii>&deck,int &xPos,int x){\n    for(int j=0;j<deck.size();j++){\n        if(sumX+deck[j].second-deck[j].first+1>=x){\n            xPos=j;\n            break;\n        }\n        sumX+=deck[j].second-deck[j].first+1;\n    }\n}\nvoid divideBlock(vector<pii> &deck,int &xPos,int &sumX,int x,bool isX){\n    int minu=1;\n    if(isX)minu++;\n    pii p1=pii(deck[xPos].first,deck[xPos].first+(x-sumX-minu));\n    pii p2=pii(p1.second+1,deck[xPos].second);\n    deck.erase(deck.begin()+xPos);\n    if(p2.first<=p2.second)deck.insert(deck.begin()+xPos,p2);\n    if(p1.first<=p1.second)deck.insert(deck.begin()+xPos,p1);\n}\n\nint main(){\n    while(cin>>N&&N){\n        int res=0;\n        cin>>M>>P>>Q>>R;\n        vector<pii> deck;\n        deck.push_back(pii(1,N));\n        int x,y;\n        for(int i=0;i<M;i++){\n            cin>>x>>y;\n            x++;\n            int sumX=0;\n            int sumY=0;\n            int xPos,yPos;\n            decidePlace(sumX,deck,xPos,x);\n            decidePlace(sumY,deck,yPos,y);\n            if(xPos==yPos){\n                pii p1=pii(deck[xPos].first,deck[xPos].first+(x-sumX-2));\n                pii p2=pii(p1.second+1,deck[yPos].first+(y-sumY-1));\n                pii p3=pii(p2.second+1,deck[xPos].second);\n                deck.erase(deck.begin()+xPos);\n                if(p3.first<=p3.second)deck.insert(deck.begin()+xPos,p3);\n                if(p2.first<=p2.second)deck.insert(deck.begin()+xPos,p2);\n                if(p1.first<=p1.second)deck.insert(deck.begin()+xPos,p1);\n            }\n            else{\n                divideBlock(deck,yPos,sumY,y,false);\n                divideBlock(deck,xPos,sumX,x,true);\n            }\n            sumX=sumY=0;\n            decidePlace(sumX,deck,xPos,x);\n            decidePlace(sumY,deck,yPos,y);\n            vector<pii> cutPlace;\n            vector<pii> prv;\n            vector<pii> nxt;\n            for(int i=xPos;i<=yPos;i++)cutPlace.push_back(deck[i]);\n            for(int i=0;i<xPos;i++)prv.push_back(deck[i]);\n            for(int i=yPos+1;i<deck.size();i++)nxt.push_back(deck[i]);\n            deck.clear();\n            for(int i=0;i<nxt.size();i++)deck.push_back(nxt[i]);\n            for(int i=0;i<cutPlace.size();i++)deck.push_back(cutPlace[i]);\n            for(int i=0;i<prv.size();i++)deck.push_back(prv[i]);\n        }\n        int sum=0;\n        bool isApP=false;\n        for(int i=0;i<deck.size();i++){\n            int cnt=deck[i].second-deck[i].first+1;\n            sum+=cnt;\n            int pPos=P-(sum-cnt)-1;\n            int pNum=pPos+deck[i].first;\n            int qPos=Q-(sum-cnt)-1;\n            int qNum=qPos+deck[i].first;\n            if(sum<P)continue;\n            if(sum-cnt<P&&sum-cnt<Q&&sum>=P&&sum>=Q){\n                if(pNum<=R)res+=max(0,min(-qNum+R+1,qNum-pNum+1));\n                break;\n            }\n            else if(!isApP&&sum>=P){\n                isApP=true;\n                if(pNum<=R)res+=max(0,min(-deck[i].first+R+1,deck[i].second-pNum+1));\n            }\n            else if(isApP){\n                if(sum>=Q){\n                    if(deck[i].first<=R)res+=min(qNum-deck[i].first+1,(R-deck[i].first+1));\n                    break;\n                }\n                else if(deck[i].first<=R)res+=max(0,min(-deck[i].first+R+1,deck[i].second-deck[i].first+1));\n            }\n        }\n        cout<<res<<endl;\n    }\n    return 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include<vector>\n#include<list>\n#include<algorithm>\n#include<iostream>\n#include<string>\n#include<cstdio>\n#include<cstdlib>\n#include<cstring>\n#include<cmath>\nusing namespace std;\nint main(){\n  int h,i,j;\n  int m,n,p,q,r,x,y;\n  int ct;\n  list<int> a,b,c,d;\n  list<int>::iterator it,jt,kt,lt;\n  while(cin>>n&&n){\n    cin>>m>>p>>q>>r;\n    a.clear();\n    a.push_back(1);\n    a.push_back(n);\n    for(h=0;h<m;h++){\n      cin>>x>>y;\n      it=jt=a.begin();\n      jt++;\n      for(i=0;i<x;){\n\tif(i+*jt-*it+1>x){\n\t  it=jt=kt=a.insert(a.insert(jt,*it+x-i),*it+x-i-1);\n\t  it++;\n\t  advance(jt,2);\n\t  kt++;\n\t  i=x;\n\t}else if(i+*jt-*it+1<x){\n\t  i+=*jt-*it+1;\n\t  advance(it,2);\n\t  advance(jt,2);\n\t}else if(i+*jt-*it+1==x){\n\t  advance(it,2);\n\t  advance(jt,2);\n\t  kt=it;\n\t  i=x;\n\t}\n      }\n      for(;i<y;){\n\tif(i+*jt-*it+1>y){\n\t  lt=a.insert(a.insert(jt,*it+y-i),*it+y-i-1);\n\t  lt++;\n\t  i=y;\n\t}else if(i+*jt-*it+1<y){\n\t  i+=*jt-*it+1;\n\t  advance(it,2);\n\t  advance(jt,2);\n\t}else if(i+*jt-*it+1==y){\n\t  lt=it;\n\t  advance(lt,2);\n\t  i=y;\n\t}\n      }\n      b.assign(a.begin(),kt);\n      c.assign(kt,lt);\n      d.assign(lt,a.end());\n      a.clear();\n      a.splice(a.end(),d);\n      a.splice(a.end(),c);\n      a.splice(a.end(),b);\n    }\n    j=a.front();\n    it=jt=a.begin();\n    jt++;\n    for(i=0;i<p-1;i++){\n      if(j==*jt){\n\tadvance(it,2);\n\tadvance(jt,2);\n\tj=*it-1;\n      }\n      j++;\n    }\n    ct=0;\n    for(i=0;i<q-p+1;i++){\n      if(j<=r)\n\tct++;\n      if(j==*jt){\n\tadvance(it,2);\n\tadvance(jt,2);\n\tj=*it-1;\n      }\n      j++;\n    }\n    cout<<ct<<endl;\n  }\n  return 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include<bits/stdc++.h>\nusing namespace std;\n#define h first\n#define w second\nvector<pair<bool,pair<int,int> > >v;\nint n,m,p,q,r,i;\nvoid Vp(bool a,int b,int c){v.push_back(make_pair(a,make_pair(b,c)));}\nint main(){\n\twhile(cin>>n&&n){\n\tcin>>m>>p>>q>>r;v.clear();\n\tVp(1,1,r);Vp(0,r+1,n);\n\twhile(m--){\n\t\tint x,y;scanf(\"%d%d\",&x,&y);\n\t\tfor(i=0;i<v.size();i++){\n\t\t\tint a=v[i].w.h,b=v[i].w.w;bool c=v[i].h;\n\t\t\tif(a<=x&&x<b){Vp(c,x+1,b);b=x;}\n\t\t\tif(a<=y&&y<b){Vp(c,y+1,b);b=y;}\n\t\t\tif(0<a&&b<=x)a+=n-x,b+=n-x;\n\t\t\telse if(x<a&&b<=y)a+=n-x-y,b+=n-x-y;\n\t\t\telse if(y<a&&b<=n)a-=y,b-=y;\n\t\t\tv[i].w.h=a,v[i].w.w=b;\n\t\t}\n\t}n=0;\n\tfor(i=0;i<v.size();i++)if(v[i].h)n+=max(0,1+min(v[i].w.w,q)-max(v[i].w.h,p));\n\tcout<<n<<endl;\n\t}\n\treturn 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include<iostream>\n#include<algorithm>\n#include<vector>\nusing namespace std;int main(){int n,m,p,q,r,x,y;vector<int>::iterator u,v,z;for(;cin>>n>>m>>p>>q>>r;cout<<x<<endl){vector<int>s,t;s.push_back(0);for(s.push_back(r);m--;t.clear()){cin>>x>>y;u=upper_bound(s.begin(),s.end(),x);v=upper_bound(s.begin(),s.end(),y);if(v-s.begin()+1&1)t.push_back(0);t.push_back(0);for(z=v;z!=s.end();++z)t.push_back(*z-y);if(s.end()-u&1)t.push_back(n-y);for(z=u;z!=v;++z)t.push_back(*z-x+n-y);z=s.begin();if(v-s.begin()&1)++z;if(!z[1])z+=2;if(*z+n-x==t.back()){++z;t.pop_back();}for(;z!=u;++z)t.push_back(*z+n-x);s.swap(t);}s.insert(upper_bound(s.begin(),s.end(),p-1),2,p-1);s.insert(lower_bound(s.begin(),s.end(),q),q);s.push_back(n);z=upper_bound(s.begin(),s.end(),p-1);if(z-s.begin()&1)--z;for(x=0;*z<q;++z)m=*z++,x+=*z-m;}}"
  },
  {
    "language": "C++",
    "code": "#include <iostream>\n#include <algorithm>\n#include <vector>\nusing namespace std;\nint main(){\n\tint n,m,p,q,r,x,y;\n\tvector<int>::iterator itx,ity,it;\n\tfor(;cin>>n>>m>>p>>q>>r;cout<<x<<endl){\n\t\tvector<int> v1(1),v2;\n\t\t\n\t\tfor(v1.push_back(r);m--;v2.clear()){\n\t\t\tcin>>x>>y;\n\t\t\titx=upper_bound(v1.begin(),v1.end(),x);\n\t\t\tity=upper_bound(v1.begin(),v1.end(),y);\n\t\t\t\n\t\t\tif( ity-v1.begin()+1 & 1 )v2.push_back(0);\n\t\t\tv2.push_back(0);\n//\t\t\tv2.insert(v2.end(),ity-v1.begin()&1?1:2,0);\n\t\t\tfor(it=ity;it!=v1.end();++it)\n\t\t\t\tv2.push_back(*it - y);\n\t\t\t\n\t\t\tif(v1.end()-itx & 1)v2.push_back(n-y);\n\t\t\tfor(it=itx;it!=ity;++it)\n\t\t\t\tv2.push_back(*it-x+n-y);\n\t\t\t\n\t\t\tit = v1.begin();\n\t\t\tif(ity-v1.begin() & 1)++it;\n\t\t\tif(!it[1])it+=2;\n\t\t\tif(*it+n-x==v2.back())++it,v2.pop_back();\n\t\t\tfor(;it!=itx;++it)\n\t\t\t\tv2.push_back(*it+n-x);\n\t\t\t\n\t\t\tv1.swap(v2);\n\t\t}\n\t\tv1.insert( upper_bound(v1.begin(),v1.end(),p-1), 2, p-1);\n\t\tv1.insert( lower_bound(v1.begin(),v1.end(),q), q );\n\t\tv1.push_back(n);\n\t\tit = upper_bound(v1.begin(),v1.end(),p-1);\n\t\tif(it-v1.begin() & 1) --it;\n\t\tfor(x=0;*it<q;++it){\n\t\t\tm=*it,++it\n\t\t\tx+=*it-m;\n\t\t}\n\t}\n}"
  },
  {
    "language": "C++",
    "code": "#include <iostream>\n#include <algorithm>\n#include <vector>\nusing namespace std;\nint main(){\n\tint n,m,p,q,r,x,y,t;\n\tvector<int>::iterator itx,ity,it;\n\tfor(;cin>>n>>m>>p>>q>>r;cout<<x<<endl){\n\t\tvector<int> v1,v2;\n\t\tv1.push_back(0);\n\t\tv1.push_back(r);\n\t\t\n\t\tfor(;m--;v2.clear()){\n\t\t\tcin>>x>>y;\n\t\t\titx=upper_bound(v1.begin(),v1.end(),x);\n\t\t\tity=upper_bound(v1.begin(),v1.end(),y);\n\t\t\t\n\t\t\tif( ity-v1.begin()+1 & 1 )v2.push_back(0);\n\t\t\tv2.push_back(0);\n\t\t\tfor(it=ity;it!=v1.end();++it)\n\t\t\t\tv2.push_back(*it - y);\n\t\t\t\n\t\t\tif(v1.end()-itx & 1)v2.push_back(n-y);\n\t\t\tfor(it=itx;it!=ity;++it)\n\t\t\t\tv2.push_back(*it-x+n-y);\n\t\t\t\n\t\t\tit = v1.begin();\n\t\t\tif(ity-v1.begin() & 1)++it;\n\t\t\tif(!it[1]){++it;++it;}\t//d¡r\n\t\t\tif(*it+n-x==v2.back()){++it;v2.pop_back();}\t//d¡r\n\t\t\tfor(;it!=itx;++it)\n\t\t\t\tv2.push_back(*it+n-x);\n\t\t\t\n\t\t\tv1.swap(v2);\n\t\t}\n\t\tv1.insert( upper_bound(v1.begin(),v1.end(),p-1), 2, p-1);\n\t\tv1.insert( lower_bound(v1.begin(),v1.end(),q), q );\n\t\tv1.push_back(n);\n\t\tit = upper_bound(v1.begin(),v1.end(),p-1);\n\t\tif(it-v1.begin() & 1) --it;\n\t\tfor(x=0;*it<q;++it){\n\t\t\tm=*it;\n\t\t\t++it;\n\t\t\tx+=*it-m;\n\t\t}\n\t}\n}"
  },
  {
    "language": "C++",
    "code": "#include <iostream>\n#include <vector>\n#include <algorithm>\nusing namespace std;\n\nconst int N = 1000000000;\nvector<bool> cards_a(N+1), cards_b(N+1);\n\nvoid copyCards(const vector<bool> &src, vector<bool> &dst, int src_i, int dst_i, int n) {\n    for (int i = 0; i < n; i++) {\n        dst[dst_i + i] = src[src_i + i];\n    }\n}\n\nint countTrue(const vector<bool> &v, int p, int q) {\n    int counter = 0;\n    for (int i = p; i <= q; i++) {\n        if (v[i]) {\n            counter++;\n        }\n    }\n    return counter;\n}\n\nint main () {\n    int n;\n    while (cin >> n, n) {\n        int m, p, q, r;\n        cin >> m >> p >> q >> r;\n        vector<int> xs(m), ys(m);\n        for (int i = 0; i < m; i++) {\n            cin >> xs[i] >> ys[i];\n        }\n\n        fill(cards_a.begin(), cards_a.begin() + r + 1, true);\n        fill(cards_a.begin() + r + 2, cards_a.end(), false);\n\n        for (int i = 0; i < m; i++) {\n            if (i % 2 == 0) {\n                copyCards(cards_a, cards_b, 1, n - xs[i] + 1, xs[i]);\n                copyCards(cards_a, cards_b, xs[i] + 1, n - ys[i] + 1, ys[i] - xs[i]);\n                copyCards(cards_a, cards_b, ys[i] + 1, 1, n - ys[i]);\n            } else {\n                copyCards(cards_b, cards_a, 1, n - xs[i] + 1, xs[i]);\n                copyCards(cards_b, cards_a, xs[i] + 1, n - ys[i] + 1, ys[i] - xs[i]);\n                copyCards(cards_b, cards_a, ys[i] + 1, 1, n - ys[i]);\n            }\n        }\n        if (m % 2 == 0) {\n            cout << countTrue(cards_a, p, q) << endl;\n        } else {\n            cout << countTrue(cards_b, p, q) << endl;\n        }\n    }\n}"
  },
  {
    "language": "C++",
    "code": "\n#include<iostream>\nusing namespace std;\nint cards,n,i,p,q,r,x[5000],y[5000],counter;\n  int numberStart[10001];\n  int numberFast[10001];\n  int numberEnd[10001];\n  int searchB[10001];\nint numberLong(int value){\n\treturn numberEnd[value]-numberStart[value]+1;\n}\n\nint seach(int k ){\n  int l=0;\n\n  \n  for ( int a=1;a<=counter+1;a++){\n    if (numberStart[a]<=k && k<numberEnd[a]){\n      l=numberFast[a];\n      return l;\n    }\n    }\n\t\n  return -100;\n  }\nint seachC(int seed){\n  //return seachB(seach(seed));\n\t\t\tint l=0;\n  for (int a=1;a<=counter+1;a++){\n\tif(seed>l+numberLong(searchB[a])){\n\tl+=numberLong(searchB[a]);\n\t}\n\telse{\n\t return numberFast[searchB[a]];\n\t}\n  }\n return -100;\n\t\n}\nint searchD(int seed){\n\t\tint l=0;\n  for (int a=1;a<=counter+1;a++){\n\tif(seed>l+numberLong(searchB[a])){\n\tl+=numberLong(searchB[a]);\n\t}\n\telse{\n\t return numberFast[searchB[a]];\n\t}\n  }\n return -100;\n\t\n}\nint searchNumber(int value){\n\tint l=0;\n  for (int a=1;a<=counter+1;a++){\n\tif(value>l+numberLong(searchB[a])){\n\tl+=numberLong(searchB[a]);\n\t}\n\telse{\n\t return numberStart[searchB[a]]+value-l-1;\n\t}\n  }\n return -100;\n}\n\nint make(int sequence,int counter ){\n  counter++;\n // numberStart[counter]=j;\n // numberEnd[counter]=k;\n  return 0;\n}\nint StartHead(int value){\n\tint longs=1;\n\tfor (int i=1;i<=counter;i++){\n\t\n\t\tif (numberFast[i]<numberFast[value]){\n\t\t\tlongs+=numberLong(i);\n\t\t}\n\t}\n\treturn longs;\n\n\n}\nvoid cut(int g){\n\tif(searchD(g)==searchD(g+1)){\n  //カットする場所が入ってる数列を求める\n  int seachX=searchB[seachC(g)];\n  int seachXX=searchNumber(g);\n//数列ができる範囲の後ろの番号FASTを変える\n     for(int j=1;j<=counter;j++){\n      if (numberFast[j]>=numberFast[seachX]+1){\n      numberFast[j]++;\n     }\n    }\n\n  //の数列の後ろに新しい数列を作る\n counter++;\n //for \n make(seachX,counter);\n  numberFast[counter]=numberFast[seachX]+1;\n  numberStart[counter] =searchNumber(g)+1;\n  numberEnd[counter]=numberEnd[seachX];\n  //できた数列の前の数列の最後を調整する\n  numberEnd[seachX]=searchNumber(g);\n \n\n  \n  for ( int a=1;a<=counter+1;a++){\n\t  searchB[numberFast[a]]=a;\n    }\n    }\n\n}\nvoid shuffle(int x,int y){\n\t\n\t\n\tint  numberFastNew[10001];\n\n\tint newCounter[3];\n\tfor(int i=0;i<3;i++){\n\t\tnewCounter[i]=0;\n\t}\n\tfor(int j=1;j<=counter;j++){\n\t\tif (StartHead(j)>y){\n\t\t\tnewCounter[0]++;\n\t\tnumberFastNew[j]=0;\n\t\t}\n\t}\n\t\n\tfor(int j=1;j<=counter;j++){\n\t\tif (StartHead(j)>x && StartHead(j)+numberLong(j)-1<=y){\n\t\t\tnewCounter[1]++;\n\t\tnumberFastNew[j]=1;\n\t\t}\n\t}\n\t\n\tfor(int j=1;j<=counter;j++){\n\t\t\tif (StartHead(j)+numberLong(j)-1<=x){\n\t\t\tnewCounter[2]++;\n\t\tnumberFastNew[j]=2;\n\t\t}\n\t}\n\t\n\tfor(int j=1;j<=counter;j++){\n\t\tswitch(numberFastNew[j]){\n\t\t\tcase 0:\n\t\t\t\tnumberFast[j]+=-newCounter[1]-newCounter[2];\n\t\t\t\tbreak;\n\t\t\tcase 1:\n\t\t\t\tnumberFast[j]+=newCounter[0]-newCounter[2];\n\t\t\t\tbreak;\n\t\t\tcase 2:\n\t\t\t\tnumberFast[j]+=newCounter[1]+newCounter[0];\n\t\t\t\tbreak;\n\t\t}\n\n\t}\n\t  for ( int a=1;a<=counter+1;a++){\n\t  searchB[numberFast[a]]=a;\n    }\n\n}\n\n\nint main(void)\n{\n\twhile(true){\n\tcards=0;\n\tn=0;\n\tcounter=0;\n\tfor (int i=0;i<10001;i++){\n   numberStart[i]=0;\n   numberFast[i]=0;\n   numberEnd[i]=0;\n   searchB[i]=0;\n\t}\n\tint points=0;\n  counter=1;\n  cin >> cards;\n  if (cards==0){\n\t  break;\n  }\n  numberStart[1]=1;\n  numberEnd[1]=cards;\n  numberFast[1]=1;\n  searchB[1]=1;\n  cin >> n;\n  cin >> p  >> q  >> r ;\n  for (i=1;i<=n;i++){\n    cin >> x[i] >> y[i];\n  }\n  for (i=1;i<=n;i++){\n     cut(x[i]);\n\t \n      cut(y[i]);\n\t  \n     shuffle(x[i],y[i]);\n  }\n\n  for(int j=p;j<=q;j++){\n\t  if(searchNumber(j)<=r){\n\t\t  points++;\n\t  }\n  }\n  cout << points << endl;\n\t}\n}"
  },
  {
    "language": "C++",
    "code": "#include <cstdio>\n#include <cstdlib>\n#include <cstring>\n#include <cmath>\n#include <climits>\n#include <cfloat>\n#include <ctime>\n#include <map>\n#include <utility>\n#include <set>\n#include <iostream>\n#include <memory>\n#include <string>\n#include <vector>\n#include <algorithm>\n#include <functional>\n#include <sstream>\n#include <complex>\n#include <stack>\n#include <queue>\n#include <numeric>\n#include <list>\n\nusing namespace std;\n\n#ifdef _MSC_VER\n#define __typeof__ decltype\n\ntemplate <class T>\nint __builtin_popcount(T n) { return n ? 1 + __builtin_popcount(n & (n - 1)) : 0; }\n#endif\n\n#define foreach(it, c) for (__typeof__((c).begin()) it=(c).begin(); it != (c).end(); ++it)\n#define all(c) (c).begin(), (c).end()\n#define rall(c) (c).rbegin(), (c).rend()\n#define popcount __builtin_popcount\n\n#define rep(i, n) for (int i = 0; i < n; ++i)\n\ntemplate <class T> void max_swap(T& a, const T b) { a = max(a, b); }\ntemplate <class T> void min_swap(T& a, const T b) { a = min(a, b); }\n\nconst double EPS = 1e-10;\ntypedef long long ll;\ntypedef pair<int, int> pint;\n\n\nstruct Range\n{\n\tRange(int top, int n) : top(top), n(n) {}\n\tpair<Range, Range> split(int num)\n\t{\n\t\treturn make_pair(Range(top, num), Range(top + num, n - num));\n\t}\n\tint top, n;\n};\nvoid next(vector<Range>& pile, int& i, int& sum, int until_sum, vector<Range>& a)\n{\n\tfor (i = 0; sum < until_sum; ++i)\n\t{\n\t\tif (sum + pile[i].n <= until_sum)\n\t\t{\n\t\t\ta.push_back(pile[i]);\n\t\t\tsum += pile[i].n;\n\t\t}\n\t\telse\n\t\t{\n\t\t\tpair<Range, Range> t = pile[i].split(until_sum - sum);\n\t\t\ta.push_back(t.first);\n\t\t\tsum = until_sum;\n\n\t\t\tpile[i] = t.second;\n\t\t\tbreak;\n\t\t}\n\t}\n}\nint main()\n{\n\tint n, m, p, q, r;\n\twhile (scanf(\"%d\", &n), n)\n\t{\n\t\tscanf(\"%d%d%d%d\", &m, &p, &q, &r);\n\n\t\tvector<Range> pile;\n\t\tpile.push_back(Range(1, n));\n\t\twhile (m--)\n\t\t{\n\t\t\tint x, y;\n\t\t\tscanf(\"%d%d\", &x, &y);\n\n\t\t\tvector<Range> a, b, c;\n\t\t\tint i = 0, sum = 0;\n\t\t\tnext(pile, i, sum, x, a);\n\t\t\tnext(pile, i, sum, y, b);\n\t\t\tfor ( ; i < pile.size(); ++i)\n\t\t\t\tc.push_back(pile[i]);\n\n\t\t\tpile = c;\n\t\t\tpile.insert(pile.end(), all(b));\n\t\t\tpile.insert(pile.end(), all(a));\n\t\t}\n\n\t\tvector<Range> a, b;\n\t\tint i = 0, sum = 0;\n\t\tnext(pile, i, sum, p - 1, a);\n\t\tnext(pile, i, sum, q, b);\n\n\t\tint res = 0;\n\t\tforeach (t, b)\n\t\t\tres += min(t->n, max(0, r - (t->top - 1)));\n\t\t\n\t\tprintf(\"%d\\n\", res);\n\t}\n}"
  },
  {
    "language": "C++",
    "code": "// Shuffle\n#include<iostream>\n// 平衡二分探索木\n// Treap\n\n#include<vector>\n#include<algorithm>\n#include<memory>\n#include<cstdlib>\n\nclass Treap {\npublic:\n    Treap(int r) :r_(r) {}\n\n    int size() const;\n    void insert(const int index, const int value);\n    void erase(const int index);\n    int find(const int index) const;\n    void shuffle(int x, int y);\n    int count(int p, int q) const;\n\nprivate:\n    struct Node;\n\n    int size(const std::unique_ptr<Node>& node) const;\n    int count(const std::unique_ptr<Node>& node) const;\n    int count(const std::unique_ptr<Node>& node, int p, int q) const;\n    int find(const std::unique_ptr<Node>& node, const int index) const;\n    std::unique_ptr<Node> update(std::unique_ptr<Node>& node);\n    std::unique_ptr<Node> merge(std::unique_ptr<Node>& left, std::unique_ptr<Node>& right);\n    std::vector<std::unique_ptr<Node>> split(std::unique_ptr<Node>& node, const int k);\n\n    std::unique_ptr<Node> root_;\n    int r_;\npublic:\n    void print();\nprivate:\n    void print(std::unique_ptr<Node>& node);\n};\n\n// struct\nstruct Treap::Node {\n    int value;\n    int size;\n    int count;\n    double priority;\n    std::unique_ptr<Node> left_child, right_child;\n    Node(int v, int c) :value(v), size(1), count(c), priority(std::rand()), left_child(nullptr), right_child(nullptr) {}\n};\n\n// DEBUG\nvoid Treap::print() {\n    print(root_);\n}\nvoid Treap::print(std::unique_ptr<Node>& node){\n    std::cout<<node->value<<\"    \"<<node->count<<std::endl;\n//     std::cout<<\"left\"<<std::endl;\n    if(node->left_child) print(node->left_child);\n//     std::cout<<\"right\"<<std::endl;\n    if(node->right_child) print(node->right_child);\n}\n// ADD\nvoid Treap::shuffle(int x, int y) {\n    auto v1 = split(root_, x);\n    auto v2 = split(v1.back(), y - x);\n    auto m = merge(v2.back(), v2.front());\n    root_ = merge(m, v1.front());\n}\nint Treap::count(int p, int q) const {\n    return count(root_, p, q);\n}\nint Treap::count(const std::unique_ptr<Node>& node, int p, int q) const {\n    if(!node) return 0;\n    if(q < p) return 0;\n// std::cout<<p<<\",\"<<q<<\"    \"<<(node->value)<<\"  \"<<size(node->left_child)<<std::endl;\n\n    if(p == size(node->left_child)) return (node->value <= r_ ? 1: 0) + count(node->right_child, 0, q - p - 1);\n    if(q <= size(node->left_child)) return count(node->left_child, p, q);\n\n    return count(node->left_child, p, q) + (node->value <= r_ ? 1: 0) + count(node->right_child, 0, q - size(node->left_child) - 1);\n}\n\n// public\nint Treap::size() const {return size(root_);}\nvoid Treap::insert(const int index, const int value) {\n    auto t = split(root_, index);\n    std::unique_ptr<Node> n(new Node(value, value <= r_ ? 1 : 0));\n    root_ = merge(t[0], n);\n    root_ = merge(root_, t[1]);\n}\nvoid Treap::erase(const int index) {\n    auto t1 = split(root_, index);\n    auto t2 = split(t1[1], 1);\n    root_ = merge(t1[0], t2[1]);\n}\nint Treap::find(const int index) const {return find(root_, index);}\n\n// private\nint Treap::size(const std::unique_ptr<Node>& node) const {return node ? node->size : 0;}\nint Treap::count(const std::unique_ptr<Node>& node) const {return node ? node->count : 0;}\nint Treap::find(const std::unique_ptr<Node>& node, const int index) const {\n    if(index < size(node->left_child))          return find(node->left_child, index);\n    else if(index == size(node->left_child))    return node->value;\n    else                                        return find(node->right_child, index - size(node->left_child) - 1);\n}\nstd::unique_ptr<Treap::Node> Treap::update(std::unique_ptr<Node>& node) {\n    node->size = size(node->left_child) + size(node->right_child) + 1;\n    node->count = count(node->left_child) + count(node->right_child) + (node->value <= r_ ? 1 : 0);\n    return std::move(node);\n}\nstd::unique_ptr<Treap::Node> Treap::merge(std::unique_ptr<Node>& left, std::unique_ptr<Node>& right) {\n    if(!left || !right) return std::move(left ? left : right);\n    if(left->priority > right->priority) {\n        left->right_child = merge(left->right_child, right);\n        return update(left);\n    } else {\n        right->left_child = merge(left, right->left_child);\n        return update(right);\n    }\n}\nstd::vector<std::unique_ptr<Treap::Node>> Treap::split(std::unique_ptr<Node>& node, const int k) {\n    std::vector<std::unique_ptr<Node>> result(2);\n    if(!node) return result;\n    if(k <= size(node->left_child)) {\n        result = split(node->left_child, k);\n        node->left_child = std::move(result[1]);\n        result[1] = update(node);\n    } else {\n        result = split(node->right_child, k - size(node->left_child) - 1);\n        node->right_child = std::move(result[0]);\n        result[0] = update(node);\n    }\n    return result;\n}\n\n\n#include<iostream>\nusing namespace std;\nint main() {\n    int n, m, p, q, r;\n    while(cin >> n >> m >> p >> q >> r, n) {\n        Treap t(r);\n        for(int i = 0; i < n; ++i) t.insert(i, i + 1);\n        for(int i = 0; i < m; ++i) {\n            int x, y;\n            cin >> x >> y;\n            t.shuffle(x, y);\n        }\n//         t.print();\n        cout << t.count(p - 1, q - 1) << endl;\n    }\n}"
  },
  {
    "language": "C++",
    "code": "#include <iostream>\n#include <algorithm>\n#include <vector>\n#include <queue>\n#include <map>\n#include <set>\n#include <cstdio>\n#include <cmath>\n#include <cstring>\n#include <string>\n#include <time.h>\n#include <cctype>\n#include <deque>\n \n#define FOR(i,a,b) for(int i=(a);i<(b);i++)\n#define FFOR(i,a,b) for(int i=(a);i<=(b);i++)\n#define REP(i,b) FOR(i,0,b)\n#define RREP(i,b) FFOR(i,1,b)\n#define PB push_back\n#define F first\n#define S second\n#define BE(c) c.begin(),c.end()\nusing namespace std;\ntypedef long long LL;\ntypedef LL ut;\ntypedef long double ld;\ntypedef pair<ut,ut> pr;\ntypedef vector<pr> Vpr;\ntypedef vector<ut> VI;\ntypedef pair<ut,pr> ppr;\ntypedef priority_queue<pr,Vpr, greater<pr> > PQ;\nconst int SIZE=1e+5+10;\nconst ut INF=1<<30;\nconst ld eps=1e-6;\nconst LL mod=1e+9 + 7;\n\nLL N, M, P, q, r;\ndeque<pr> cards;\n\ndeque<pr> pickCards(int k){\n\tdeque<pr> res;\n\twhile(!cards.empty()){\n\t\tpr p = cards.front(); cards.pop_front();\n\t\tif(p.S - p.F + 1 == k){\n\t\t\tres.PB(pr(p.F, p.S));\n\t\t\tbreak;\n\t\t}\n\t\telse if(p.S - p.F + 1 > k){\n\t\t\tres.PB(pr(p.F, p.F + k - 1));\n\t\t\tcards.push_front(pr(p.F + k, p.S));\n\t\t\tbreak;\n\t\t}\n\t\tk -= p.S - p.F + 1;\n\t\tres.PB(pr(p.F, p.S));\n\t}\n\treturn res;\n}\n\nint main() {\n\twhile(cin >> N && N){\n\t\tcin >> M;\n\t\tcin >> P >> q >> r;\n\t\tcards.clear();\n\t\tcards.PB(pr(1, N));\n\t\tREP(i,M){\n\t\t\tint x, y;\n\t\t\tscanf(\"%d%d\",&x, &y);\n\t\t\tdeque<pr> top = pickCards(x);\n\t\t\tdeque<pr> middle = pickCards(y - x);\n\t\t\twhile(!middle.empty()){\n\t\t\t\tcards.PB(middle.front());\n\t\t\t\tmiddle.pop_front();\n\t\t\t}\n\t\t\twhile(!top.empty()){\n\t\t\t\tcards.PB(top.front());\n\t\t\t\ttop.pop_front();\n\t\t\t}\n\t\t}\n\t\t\n\t\tLL now = 0, ans = 0;\n\t\tpickCards(P - 1);\n\t\tdeque<pr> res = pickCards(q - P + 1);\n\t\twhile(!res.empty()){\n\t\t\tpr c = res.front();\n\t\t\tres.pop_front();\n\t\t\tif(c.S <= r){\n\t\t\t\tans += c.S - c.F + 1;\n\t\t\t}\n\t\t\telse if(c.F <= r){\n\t\t\t\tans += r - c.F + 1;\n\t\t\t}\n\t\t}\n\t\tcout << ans << endl;\n\t}\n\treturn 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include <algorithm>\n#include <iostream>\n\nusing namespace std;\n\nconst int MAX_M = 5000;\n\nint ns[MAX_M*2+1];\nint bs[MAX_M*2+1];\nint es[MAX_M*2+1];\nint cs[MAX_M*2+1];\n\nint main() {\n  for (;;) {\n    int n;\n    cin >> n;\n    if (!n) return 0;\n    int m, p, q, r;\n    cin >> m >> p >> q >> r;\n    ns[0] = -1;\n    bs[0] = 0;\n    es[0] = n;\n    cs[0] = n;\n    int t = 0;\n    for (int i = 0, j = 1; i < m; i++) {\n      int x, y;\n      cin >> x >> y;\n      int s = 0, a = -1, b = -1, c = t;\n      for (;;) {\n        s += cs[c];\n        if (a < 0 && s >= x) {\n          a = j++;\n          ns[a] = ns[c];\n          es[a] = es[c];\n          cs[a] = s - x;\n          bs[a] = es[a] - cs[a];\n          cs[c] -= cs[a];\n          es[c] = bs[c] + cs[c];\n          ns[c] = -1;\n          c = a;\n        }\n        if (b < 0 && s >= y) {\n          b = j++;\n          ns[b] = ns[c];\n          es[b] = es[c];\n          cs[b] = s - y;\n          bs[b] = es[b] - cs[b];\n          cs[c] -= cs[b];\n          es[c] = bs[c] + cs[c];\n          ns[c] = t;\n          c = b;\n        }\n        if (ns[c] == -1)\n          break;\n        c = ns[c];\n      }\n      ns[c] = a;\n      t = b;\n    }\n    int z = 0;\n    for (int c = t, s = 0; c != -1; c = ns[c]) {\n      if (s >= q)\n        break;\n      s += cs[c];\n      if (s >= p)\n        z += max(0, min(r, min(bs[c]+q-(s-cs[c]), es[c]))-(bs[c]+max(p-1-(s-cs[c]), 0)));\n    }\n    cout << z << endl;\n  }\n}"
  },
  {
    "language": "C++",
    "code": "#include<stdio.h>\n#include<algorithm>\nusing namespace std;\npair<int,int> wolf[12000];\npair<int,int> top[12000];\npair<int,int> middle[12000];\npair<int,int> bottom[12000];\nint T,M,B;\nint size;\nint main(){\n\tint a;\n\twhile(scanf(\"%d\",&a),a){\n\t\tint b;\n\t\tscanf(\"%d\",&b);\n\t\tint p,q,r;\n\t\tscanf(\"%d%d%d\",&p,&q,&r);p--;\n\t\tsize=1;\n\t\twolf[0]=make_pair(0,a);\n\t\tfor(int i=0;i<b;i++){\n\t\t\tint s,t;\n\t\t\tscanf(\"%d%d\",&s,&t);\n\t\t\tint num=0;\n\t\t\tint phase=0;\n\t\t\tint P=0;\n\t\t\tfor(int j=0;j<size;j++){\n\t\t\t\tif(phase==0&&num+wolf[j].second-wolf[j].first>s){\n\t\t\t\t\tfor(int k=0;k<j;k++)bottom[k]=wolf[k];\n\t\t\t\t\tbottom[j]=make_pair(wolf[j].first,wolf[j].first+s-num);\n\t\t\t\t\twolf[j]=make_pair(wolf[j].first+s-num,wolf[j].second);\n\t\t\t\t\tnum=s;\n\t\t\t\t\tB=j+1;\n\t\t\t\t\tP=j;\n\t\t\t\t\tphase++;\n\t\t\t\t\tj--;\n\t\t\t\t\tcontinue;\n\t\t\t\t}\n\t\t\t\tif(phase==1&&num+wolf[j].second-wolf[j].first>t){\n\t\t\t\t\tfor(int k=P;k<j;k++)middle[k-P]=wolf[k];\n\t\t\t\t\tmiddle[j-P]=make_pair(wolf[j].first,wolf[j].first+t-num);\n\t\t\t\t\twolf[j]=make_pair(wolf[j].first+t-num,wolf[j].second);\n\t\t\t\t\tM=j-P+1;\n\t\t\t\t\tfor(int k=j;k<size;k++){\n\t\t\t\t\t\ttop[k-j]=wolf[k];\n\t\t\t\t\t}\n\t\t\t\t\tT=size-j;\n\t\t\t\t\tbreak;\n\t\t\t\t}\n\t\t\t\tnum+=wolf[j].second-wolf[j].first;\n\t\t\t}\n\t\t\tfor(int j=0;j<T;j++)wolf[j]=top[j];\n\t\t\tfor(int j=0;j<M;j++)wolf[j+T]=middle[j];\n\t\t\tfor(int j=0;j<B;j++)wolf[j+T+M]=bottom[j];\n\t\t\tsize=T+M+B;\n\t\t}\n\t\tint num=0;\n\t\tint ret=0;\n\t//\tfor(int i=0;i<size;i++)printf(\"%d %d\\n\",wolf[i].first,wolf[i].second);\n\t\tfor(int i=0;i<size;i++){\n\t\t\tif(num+wolf[i].second-wolf[i].first>p){\n\t\t\t\tint x=p-num;\n\t\t\t\tif(wolf[i].first+num-p<=r)ret-=num-p;\n\t\t\t\telse if(wolf[i].first<=r)ret-=r-wolf[i].first;\n\t\t\t\tbreak;\n\t\t\t}else{\n\t\t\t\tif(wolf[i].second<=r)ret-=wolf[i].second-wolf[i].first;\n\t\t\t\telse if(wolf[i].first<=r)ret-=r-wolf[i].first;\n\t\t\t}\n\t\t\tnum+=wolf[i].second-wolf[i].first;\n\t\t}\n\t\tnum=0;\n\t\tfor(int i=0;i<size;i++){\n\t\t\tif(num+wolf[i].second-wolf[i].first>q){\n\t\t\t\tint x=q-num;\n\t\t\t\tif(wolf[i].first+num-p<=r)ret+=num-q;\n\t\t\t\telse if(wolf[i].first<=r)ret+=r-wolf[i].first;\n\t\t\t\tbreak;\n\t\t\t}else{\n\t\t\t\tif(wolf[i].second<=r)ret+=wolf[i].second-wolf[i].first;\n\t\t\t\telse if(wolf[i].first<=r)ret+=r-wolf[i].first;\n\t\t\t}\n\t\t\tnum+=wolf[i].second-wolf[i].first;\n\t\t}\n\t\tprintf(\"%d\\n\",ret);\n\t}\n}"
  },
  {
    "language": "C++",
    "code": "#include<iostream>\n#include<string>\n#include<cmath>\n#include<queue>\n#include<map>\n#include<set>\n#include<list>\n#include<iomanip>\n#include<vector>\n#include<functional>\n#include<algorithm>\n#include<cstdio>\n#include<unordered_map>\nusing namespace std;\n//---------------------------------------------------\n//????????????????????????????????????\n#define int long long\n#define str string\n#define rep(i,j) for(int i=0;i<(int)(j);i++)\ntypedef long long ll;\ntypedef long double ld;\nconst ll inf = 4523372036854775807;\nconst int inf2 = 1145141919;\nconst ld pi = 3.14159265358979323846264338327950288419716939937510582097494459230781640628620899;\nstruct P {\n\tll pos, cost;\n};\nbool operator<(P a, P b) { return a.cost < b.cost; }\nbool operator>(P a, P b) { return a.cost > b.cost; }\nstruct B {//??£??\\???????????¨???\n\tll to, cost;\n};\nstruct S {//???????????±?????\\???????????°\n\tint from, to, cost;\n};\nbool operator<(S a, S b) { return a.cost < b.cost; }\nbool operator>(S a, S b) { return a.cost > b.cost; }\nstruct H {\n\tint x, y;\n};\nll gcm(ll i, ll j) {//?????§??¬?´???°\n\tif (i > j) swap(i, j);\n\tif (i == 0) return j;\n\treturn gcm(j%i, i);\n}\nld rad(ld a, ld b, ld c, ld d) {\n\treturn sqrt(pow(a - c, 2) + pow(b - d, 2));\n}//rad?????§?¨???????2??????????????¢\n //---------------------------------------------------\n //+++++++++++++++++++++++++++++++++++++++++++++++++++\nstruct A {\n\tint s, e, s2, size;\n\t//????????????????????????????????????????????????????????????????????????\n};\nint n, m, p, q, r;\nvector<A>a[2];\nvector<int>b[2];\nsigned main() {\n\twhile (cin >> n) {\n\t\tcin >> m >> p >> q >> r;\n\t\tint d = 0, e = 1, k, t, x, y;\n\t\ta[0].clear(); a[1].clear();\n\t\tb[0].clear(); b[1].clear();\n\t\ta[d].push_back(A{ 1,n,1,n });\n\t\tb[d].push_back(1);\n\t\tfor (int z = 0; z < m; z++) {\n\t\t\ta[e].clear(); b[e].clear();\n\t\t\tcin >> x >> y;\n\t\t\t//y+1??????????????????????????§????????????????????????????????????\n\t\t\tk = lower_bound(b[d].begin(), b[d].end(), y + 1) - b[d].begin();\n\t\t\tif (k == b[d].size() || a[d][k].s2 > y + 1)\n\t\t\t\tk--;\n\t\t\tb[e].push_back(1);\n\t\t\ta[e].push_back(A{ a[d][k].s + (y + 1 - a[d][k].s2),a[d][k].e,1,a[d][k].size - (y + 1 - a[d][k].s2) });\n\t\t\tint sum = a[d][k].size - (y + 1 - a[d][k].s2) + 1;\n\t\t\tk++;\n\t\t\tfor (; k < a[d].size(); k++) {\n\t\t\t\tb[e].push_back(sum);\n\t\t\t\ta[e].push_back(A{ a[d][k].s,a[d][k].e,sum,a[d][k].size });\n\t\t\t\tsum += a[d][k].size;\n\t\t\t}\n\t\t\t//x+1?????????y?????§???????????????????????????????????????\n\t\t\tk = lower_bound(b[d].begin(), b[d].end(), x + 1) - b[d].begin();\n\t\t\tt = lower_bound(b[d].begin(), b[d].end(), y) - b[d].begin();\n\t\t\tif (k == a[d].size() || a[d][k].s2 > x + 1)\n\t\t\t\tk--;\n\t\t\tif (t == a[d].size() || a[d][t].s2 > y)\n\t\t\t\tt--;\n\t\t\tif (k == t) {\n\t\t\t\tb[e].push_back(sum);\n\t\t\t\ta[e].push_back(A{ a[d][k].s + (x + 1 - a[d][k].s2),a[d][k].s + (y - a[d][k].s2),sum,y - x });\n\t\t\t\tsum += y - x;\n\t\t\t}\n\t\t\telse {\n\t\t\t\tb[e].push_back(sum);\n\t\t\t\ta[e].push_back(A{ a[d][k].s + (x + 1 - a[d][k].s2),a[d][k].e,sum,a[d][k].size - (x + 1 - a[d][k].s2) });\n\t\t\t\tsum += (a[d][k].size - (x + 1 - a[d][k].s2));\n\t\t\t\tk++;\n\t\t\t\tfor (; k < t; k++) {\n\t\t\t\t\tb[e].push_back(sum);\n\t\t\t\t\ta[e].push_back(A{ a[d][k].s,a[d][k].e,sum,a[d][k].size });\n\t\t\t\t\tsum += a[d][k].size;\n\t\t\t\t}\n\t\t\t\tb[e].push_back(sum);\n\t\t\t\ta[e].push_back(A{ a[d][k].s,a[d][k].s + (y - a[d][k].s2),sum,y - a[d][k].s2 + 1 });\n\t\t\t\tsum += y - a[d][k].s2 + 1;\n\t\t\t}\n\t\t\t//1??????x?????§????????????????????????????????§?????????\n\t\t\tk = lower_bound(b[d].begin(), b[d].end(), x) - b[d].begin();\n\t\t\tif (k == b[d].size() || a[d][k].s2 > x)\n\t\t\t\tk--;\n\t\t\tfor (int i = 0; i < k; i++) {\n\t\t\t\tb[e].push_back(sum);\n\t\t\t\ta[e].push_back(A{ a[d][i].s,a[d][i].e,sum,a[d][i].size });\n\t\t\t\tsum += a[d][i].size;\n\t\t\t}\n\t\t\tb[e].push_back(sum);\n\t\t\ta[e].push_back(A{ a[d][k].s,a[d][k].s + (x - a[d][k].s2),sum,x - a[d][k].s2 + 1 });\n\t\t\tswap(d, e);\n\t\t}\n\t\tk = lower_bound(b[d].begin(), b[d].end(), p) - b[d].begin();\n\t\tt = lower_bound(b[d].begin(), b[d].end(), q) - b[d].begin();\n\t\tif (k == b[d].size() || a[d][k].s2 > p) k--;\n\t\tif (t == b[d].size() || a[d][t].s2 > q) t--;\n\t\ta[d][k].size -= (p - a[d][k].s2);\n\t\ta[d][k].s = a[d][k].s + (p - a[d][k].s2);\n\t\ta[d][t].size = (q - a[d][t].s2 + 1);\n\t\ta[d][t].e = a[d][t].s + (q - a[d][t].s2);\n\t\tint sum = 0;\n\t\tif (k == t) {\n\t\t\tif (a[d][k].e <= r)\n\t\t\t\tsum = a[d][k].size;\n\t\t\telse if (a[d][k].s <= r)\n\t\t\t\tsum = r - a[d][k].s + 1;\n\t\t}\n\t\telse {\n\t\t\tfor (; k <= t; k++) {\n\t\t\t\tif (a[d][k].e <= r)\n\t\t\t\t\tsum += a[d][k].size;\n\t\t\t\telse if (a[d][k].s <= r)\n\t\t\t\t\tsum += r - a[d][k].s + 1;\n\t\t\t}\n\t\t}\n\t\tcout << sum << endl;\n\t}\n\tgetchar(); getchar();\n}"
  },
  {
    "language": "C++",
    "code": "#include<bits/stdc++.h>\nusing namespace std;\n#define h first\n#define w second\nvector<pair<bool,pair<int,int> > >v;\nint n,m,p,q,r,i;\nvoid Vp(bool a,int b,int c){v.push_back(make_pair(a,make_pair(b,c)));}\nint main(){\n\twhile(cin>>n&&n){\n\tcin>>m>>p>>q>>r;v.clear();\n\tVp(1,1,r);Vp(0,r+1,n);\n\twhile(m--){\n\t\tint x,y;cin>>x>>y;\n\t\tfor(i=0;i<v.size();i++){\n\t\t\tint a=v[i].w.h,b=v[i].w.w;bool c=v[i].h;\n\t\t\tif(a<=x&&x<b){\n\t\t\t\tVp(c,x+1,b);\n\t\t\t\tb=x;\n\t\t\t}\n\t\t\tif(a<=y&&y<b){\n\t\t\t\tVp(c,y+1,b);\n\t\t\t\tb=y;\n\t\t\t}\n\t\t\tif(0<a&&b<=x)a+=n-x,b+=n-x;\n\t\t\telse if(x<a&&b<=y)a+=n-x-y,b+=n-x-y;\n\t\t\telse if(y<a&&b<=n)a-=y,b-=y;\n\t\t\tv[i].w.h=a,v[i].w.w=b;\n\t\t}\n\t}\n\tint ans=0;\n\tfor(i=0;i<v.size();i++){\n\t\tif(v[i].h)ans+=max(0,1+min(v[i].w.w,q)-max(v[i].w.h,p));\n\t}\n\tcout<<ans<<endl;\n\t}\n\treturn 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include<deque>\n#include<list>\n#include<map>\n#include<queue>\n#include<set>\n#include<stack>\n#include<vector>\n#include<algorithm>\n#include<string>\n#include<iostream>\n#include<sstream>\n#include<cmath>\n#include<cstdio>\nusing namespace std;\npair<int,int> a[10001],b[10001];\nint sm,l;\nint fi(int i,int p){\n  for(;sm<p;++i)\n    sm+=a[i].second;\n  if(sm>p){\n    copy(a+i,a+l,b);\n    copy(b,b+l-i,a+i+1);\n    ++l;\n    a[i-1].second-=sm-p;\n    a[i]=make_pair(a[i-1].first+a[i-1].second,sm-p);\n    sm=p;\n  }\n  return i;\n}\nint main(){\n  int i,j,k;\n  int n;\n  while(cin>>n){\n    int m,p,q,r;\n    cin>>m>>p>>q>>r;\n    if(0){\n    }else if(r==n){\n      for(i=0;i<m;++i){\n\tint x,y;\n\tcin>>x>>y;\n      }\n      cout<<q-p+1<<endl;\n      continue;\n    }else if(r){\n      a[0]=make_pair(1,r);\n      a[1]=make_pair(r+1,n-r);\n      l=2;\n    }else{\n      for(i=0;i<m;++i){\n\tint x,y;\n\tcin>>x>>y;\n      }\n      cout<<0<<endl;\n      continue;\n    }\n    for(i=0;i<m;++i){\n      int x,y;\n      cin>>x>>y;\n      sm=0;\n      j=fi(0,x);\n      k=fi(j,y);\n      copy(a+k,a+l,b);\n      copy(a+j,a+k,b+l-k);\n      copy(a,a+k,b+l-j);\n      copy(b,b+l,a);\n    }\n    sm=0;\n    j=fi(0,p-1);\n    k=fi(j,q);\n    int ct=0;\n    for(i=j;i<k;++i){\n      if(a[i].first<=r)\n\tct+=a[i].second;\n    }\n    cout<<ct<<endl;\n  }\n  return 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include <iostream>\n#include <vector>\n\nusing namespace std;\n\nclass range {\nprivate:\n  struct Iterator {\n    int val;\n    int operator*() {return val;}\n    bool operator!=(Iterator &itr) {return val < itr.val;}\n    void operator++() {++val;}\n  };\n  Iterator i, n;\npublic:\n  range(int n) : i({0}), n({n}) {}\n  range(int i, int n) : i({i}), n({n}) {}\n  Iterator &begin() {return i;}\n  Iterator &end() {return n;}\n};\n\ntemplate<class T> T at(vector<T> v, int i) {return v[(i % (int)v.size() + v.size()) % v.size()];}\n\nint main() {\n  while (true) {\n    int n, m, p, q, r;\n    cin >> n;\n    if (n == 0) break; \n    cin >> m >> p >> q >> r;;\n    --p;\n    vector<pair<int, int>> dp[2];\n    dp[0].emplace_back(1, n);\n    for (int i : range(m)) {\n      int x, y, sum = 0;\n      cin >> x >> y;\n      --x;\n      for (const auto &i : dp[0]) {\n        int nsum = sum + i.second - i.first + 1;\n        int xx = max(sum, y);\n        int yy = min(nsum, n);\n        if (xx < yy) dp[1].emplace_back(i.first + max(0, y - sum), i.second - max(0, nsum - n));\n        sum = nsum;\n      }\n      sum = 0;\n      for (const auto &i : dp[0]) {\n        int nsum = sum + i.second - i.first + 1;\n        int xx = max(sum, x);\n        int yy = min(nsum, y);\n        if (xx < yy) dp[1].emplace_back(i.first + max(0, x - sum), i.second - max(0, nsum - y));\n        sum = nsum;\n      }\n      sum = 0;\n      for (const auto &i : dp[0]) {\n        int nsum = sum + i.second - i.first + 1;\n        int xx = max(sum, 0);\n        int yy = min(nsum, x);\n        if (xx < yy) dp[1].emplace_back(i.first + max(0, 0 - sum), i.second - max(0, nsum - x));\n        sum = nsum;\n      }\n      dp[0] = dp[1];\n      dp[1].clear();\n    }\n    int sum = 0;\n    int res = 0;\n    for (const auto &i : dp[0]) {\n      int nsum = sum + i.second - i.first + 1;\n      int xx = max(sum, p);\n      int yy = min(nsum, q);\n      if (xx < yy) {\n        int s = i.first + max(0, p - sum);\n        int t = min(i.second - max(0, nsum - q), r);\n        if (s <= r) res += t - s + 1;\n      }\n      sum = nsum;\n    }\n    cout << res << endl;\n  }\n}"
  },
  {
    "language": "C++",
    "code": "//  4???27??\\  ????????????0535 ; ?????£?????????\n// http://judge.u-aizu.ac.jp/onlinejudge/description.jsp?id=0536\n\n#include <iostream>\n#define NUM 100000\nusing namespace std;\n\nint main(){\n\n  register int n;//?????????????????°\n  register int m;//?????£??????????????°\n  register int p,q;//p ???????????? q ?????????????????????\n  register int r;// r??\\?????????????????????????????????\n  register int x[5000],y[5000];//????????????????????´???\n  register int card[NUM];\n  register int i;\n  register int A[NUM];\n  register int B[NUM];\n  register int C[NUM];\n\n  do{\n    register int j = 0;\n    register int count = 1;\n    register int step = 1;\n    register int red = 1;\n    register int blue = 1;\n    register int green = 0;\n\n    cin >> n;\n    cin >> m;\n    cin >> p >> q >> r;\n\n    if (!n){\n      break;\n    }\n\n    for (i=0; i < m; i++){\n      cin >> x[i] >> y[i];\n    }\n\n    while (j < m){\n\n      for (i=1; i <= n; i++ ){//??°?????£??\\\n        card[i] = i;\n      }\n\n      for (i=1 ; i <= x[j] ;i++ ){//????????????1~X???????????§\n        A[i] = card[i];\n      }\n\n      while (i <= y[j]){//????????????X+1~Y???????????§\n        B[count] = card[i];\n        i++;\n        count++;\n      }\n\n      while (i <= n){//????????????Y+1~n???????????§\n        C[step] = card[i];\n        i++;\n        step++;\n      }\n\n      for (i=1; i <= (n - y[j]); i++ ){//C?????°?????£??\\\n        card[i] = C[i];\n      }\n\n      while (red <= count){//B?????°?????£??\\\n        card[i] = B[red];\n        i++;\n        red++;\n      }\n\n      while (blue <= step){//A?????°?????£??\\\n        card[i] = A[blue];\n        i++;\n        blue++;\n      }\n      j++;\n    }\n\n    for (i=p; i <= q; i++){\n      if (card[i] <= r){\n        green++;\n      }\n    }\n\n    cout << green << endl;\n  } while (n);\n\n  return 0;\n\n}"
  },
  {
    "language": "C++",
    "code": "//  4???27??\\  ????????????0535 ; ?????£?????????\n// http://judge.u-aizu.ac.jp/onlinejudge/description.jsp?id=0536\n\n#include <iostream>\n#define NUM 100000\nusing namespace std;\n\nint main(){\n\n  int n;//?????????????????°\n  int m;//?????£??????????????°\n  int p,q;//p ???????????? q ?????????????????????\n  int r;// r??\\?????????????????????????????????\n  int x[5000],y[5000];//????????????????????´???\n  int card[NUM];\n  int i;\n  int A[NUM];\n  int B[NUM];\n  int C[NUM];\n\n  do{\n    int j = 0;\n    int count = 1;\n    int step = 1;\n    int red = 1;\n    int blue = 1;\n    int green = 0;\n\n    cin >> n;\n    cin >> m;\n    cin >> p >> q >> r;\n\n    if (!n){\n      break;\n    }\n\n    for (i=0; i < m; i++){\n      cin >> x[i] >> y[i];\n    }\n\n    while (j < m){\n\n      for (i=1; i <= n; i++ ){//??°?????£??\\\n        card[i] = i;\n      }\n\n      for (i=1 ; i <= x[j] ;i++ ){//????????????1~X???????????§\n        A[i] = card[i];\n      }\n\n      while (i <= y[j]){//????????????X+1~Y???????????§\n        B[count] = card[i];\n        i++;\n        count++;\n      }\n\n      while (i <= n){//????????????Y+1~n???????????§\n        C[step] = card[i];\n        i++;\n        step++;\n      }\n\n      for (i=1; i <= (n - y[j]); i++ ){//C?????°?????£??\\\n        card[i] = C[i];\n      }\n\n      while (red <= count){//B?????°?????£??\\\n        card[i] = B[red];\n        i++;\n        red++;\n      }\n\n      while (blue <= step){//A?????°?????£??\\\n        card[i] = A[blue];\n        i++;\n        blue++;\n      }\n      j++;\n    }\n\n    for (i=p; i <= q; i++){\n      if (card[i] <= r){\n        green++;\n      }\n    }\n\n    cout << green << endl;\n  } while (n);\n\n  return 0;\n\n}"
  },
  {
    "language": "C++",
    "code": "#include <iostream>\n#include <sstream>\n#include <iomanip>\n#include <algorithm>\n#include <cmath>\n#include <string>\n#include <vector>\n#include <list>\n#include <queue>\n#include <stack>\n#include <set>\n#include <map>\n#include <bitset>\n#include <numeric>\n#include <climits>\n#include <cfloat>\nusing namespace std;\n\nint main()\n{\n    for(;;){\n        int n;\n        cin >> n;\n        if(n == 0)\n            return 0;\n\n        int m, p, q, r;\n        cin >> m >> p >> q >> r;\n\n        vector<pair<int, int> > card;\n        card.push_back(make_pair(1, r));\n\n        while(--m >= 0){\n            int x, y;\n            cin >> x >> y;\n\n            vector<pair<int, int> > nextCard;\n            for(unsigned i=0; i<card.size(); ++i){\n                int a, b;\n                a = card[i].first;\n                b = min(card[i].second, x);\n                if(a <= b)\n                    nextCard.push_back(make_pair(n-x+a, n-x+b));\n\n                a = max(card[i].first, x+1);\n                b = min(card[i].second, y);\n                if(a <= b)\n                    nextCard.push_back(make_pair(n-x-y+a, n-x-y+b));\n\n                a = max(card[i].first, y+1);\n                b = card[i].second;\n                if(a <= b)\n                    nextCard.push_back(make_pair(-y+a, -y+b));\n            }\n\n            card.swap(nextCard);\n        }\n\n        int ret = 0;\n        for(unsigned i=0; i<card.size(); ++i){\n            int a = max(card[i].first, p);\n            int b = min(card[i].second, q);\n            ret += max(b - a + 1, 0);\n        }\n        cout << ret << endl;\n    }\n}"
  },
  {
    "language": "C++",
    "code": "#include <iostream>\n#include <vector>\nusing namespace std;\n\nint main () {\n    int n;\n    while (cin >> n, n) {\n        int m, p, q, r;\n        cin >> m >> p >> q >> r;\n        vector<int> xs(m), ys(m);\n        for (int i = 0; i < m; i++) {\n            cin >> xs[i] >> ys[i];\n        }\n\n        int result = 0;\n        for (int i = p; i <= q; i++) {\n            int cur = i;\n            for (int j = m - 1; j >= 0; j--) {\n                if (cur <= n - ys[j]) {\n                    cur += ys[j];\n                } else if (n - xs[j] < cur) {\n                    cur = cur + xs[j] - n;\n                } else {\n                    cur = cur + xs[j] + ys[j] - n;\n                }\n            }\n            if (cur <= r) {\n                result++;\n            }\n        }\n        cout << result << endl;\n    }\n}"
  },
  {
    "language": "C++",
    "code": "#include <iostream>\n#include <algorithm>\n#include <vector>\nusing namespace std;\nint main(){\n\tint n,m,p,q,r,x,y;\n\tvector<int>::iterator itx,ity,it;\n\tfor(;cin>>n>>m>>p>>q>>r;cout<<x<<endl){\n\t\tvector<int> v1,v2;\n\t\tv1.push_back(0);\n\t\tfor(v1.push_back(r);m--;v2.clear()){\n\t\t\tcin>>x>>y;\n\t\t\titx=upper_bound(v1.begin(),v1.end(),x);\n\t\t\tity=upper_bound(v1.begin(),v1.end(),y);\n\t\t\t\n//\t\t\tif( ity-v1.begin()+1 & 1 )v2.push_back(0);\n//\t\t\tv2.push_back(0);\n\t\t\tv2.insert(v2.end(),ity-v1.begin()&1?1:2,0);\n\t\t\tfor(it=ity;it!=v1.end();++it)\n\t\t\t\tv2.push_back(*it - y);\n\t\t\t\n\t\t\tif(v1.end()-itx & 1)v2.push_back(n-y);\n\t\t\tfor(it=itx;it!=ity;++it)\n\t\t\t\tv2.push_back(*it-x+n-y);\n\t\t\t\n\t\t\tit = v1.begin();\n\t\t\tif(ity-v1.begin() & 1)++it;\n\t\t\tif(!it[1])it+=2;\n\t\t\tif(*it+n-x==v2.back()){++it;v2.pop_back();}\n\t\t\tfor(;it!=itx;++it)\n\t\t\t\tv2.push_back(*it+n-x);\n\t\t\t\n\t\t\tv1.swap(v2);\n\t\t}\n\t\tv1.insert( upper_bound(v1.begin(),v1.end(),p-1), 2, p-1);\n\t\tv1.insert( lower_bound(v1.begin(),v1.end(),q), q );\n\t\tv1.push_back(n);\n\t\tit = upper_bound(v1.begin(),v1.end(),p-1);\n\t\tif(it-v1.begin() & 1) --it;\n\t\tfor(x=0;*it<q;it+=2)\n\t\t\tx+=it[1]-*it\n\t}\n}"
  },
  {
    "language": "C++",
    "code": "#include<deque>\n#include<list>\n#include<map>\n#include<queue>\n#include<set>\n#include<stack>\n#include<vector>\n#include<algorithm>\n#include<string>\n#include<iostream>\n#include<sstream>\n#include<cmath>\n#include<cstdio>\nusing namespace std;\npair<int,int> a[11000],b[11000];\nint sm,l;\nint fi(int i,int p){\n  for(;sm<p;++i)\n    sm+=a[i].second;\n  if(sm>p){\n    copy_backward(a+i,a+l,a+l+1);\n    ++l;\n    a[i-1].second-=sm-p;\n    a[i]=make_pair(a[i-1].first+a[i-1].second,sm-p);\n    sm=p;\n  }\n  return i;\n}\nint main(){\n  int i,j,k;\n  int n;\n  while(cin>>n,n){\n    int m,p,q,r;\n    cin>>m>>p>>q>>r;\n    if(r==n){\n      for(i=0;i<m;++i){\n\tint x,y;\n\tcin>>x>>y;\n      }\n      cout<<q-p+1<<endl;\n      continue;\n    }else{\n      a[0]=make_pair(1,r);\n      a[1]=make_pair(r+1,n-r);\n      l=2;\n    }\n    for(i=0;i<m;++i){\n      int x,y;\n      cin>>x>>y;\n      sm=0;\n      j=fi(0,x);\n      k=fi(j,y);\n      copy(a+k,a+l,b);\n      copy(a+j,a+k,b+l-k);\n      copy(a,a+j,b+l-j);\n      copy(b,b+l,a);\n    }\n    sm=0;\n    j=fi(0,p-1);\n    k=fi(j,q);\n    int ct=0;\n    for(i=j;i<k;++i){\n      if(a[i].first<=r)\n\tct+=a[i].second;\n    }\n    cout<<ct<<endl;\n  }\n  return 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include <algorithm>\n#include <climits>\n#include <iostream>\n#include <string>\n#include <vector>\n#include<queue>\n#include<queue>\n#define P pair<int,int>\nusing namespace std;\n\nqueue<P>operator +(queue<P>a, queue<P>b) {\n\twhile (b.size()) {\n\t\ta.push(b.front()); b.pop();\n\t}\n\treturn a;\n}\nqueue<P>L;\nint main() {\n\tint a;\n\twhile (cin >> a, a) {\n\t\tint b, c, d, e; scanf(\"%d%d%d%d\", &b, &c, &d, &e);\n\t\tqueue<P>tmp;\n\t\tswap(L, tmp);\n\t\tL.push(P(1, a));\n\t\tfor (int f = 0; f < b; f++) {\n\t\t\tint g, h; scanf(\"%d%d\", &g, &h);\n\t\t\tqueue<P>A, B, C;\n\t\t\tint sum = 0, j = 0;\n\t\t\twhile (L.size()) {\n\t\t\t\tP i = L.front(); L.pop();\n\t\t\t\tsum += i.second - i.first + 1;\n\t\t\t\tif (j < g&&sum > g) {\n\t\t\t\t\tif (j < h&&sum > h) {\n\t\t\t\t\t\tA.push(P(i.first, i.first + (g - j) - 1));\n\t\t\t\t\t\tB.push(P(i.first + (g - j), i.first + (h - j) - 1));\n\t\t\t\t\t\tC.push(P(i.first + (h - j), i.second));\n\t\t\t\t\t}\n\t\t\t\t\telse {\n\t\t\t\t\t\tA.push(P(i.first, i.first + (g - j) - 1));\n\t\t\t\t\t\tB.push(P(i.first + (g - j), i.second));\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t\telse {\n\t\t\t\t\tif (j < h&&sum > h) {\n\t\t\t\t\t\tB.push(P(i.first, i.first + (h - j) - 1));\n\t\t\t\t\t\tC.push(P(i.first + (h - j), i.second));\n\t\t\t\t\t}\n\t\t\t\t\telse {\n\t\t\t\t\t\tif (sum > h) {\n\t\t\t\t\t\t\tC.push(i);\n\t\t\t\t\t\t}\n\t\t\t\t\t\telse if (sum > g) {\n\t\t\t\t\t\t\tB.push(i);\n\t\t\t\t\t\t}\n\t\t\t\t\t\telse {\n\t\t\t\t\t\t\tA.push(i);\n\t\t\t\t\t\t}\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t\tj += i.second - i.first + 1;\n\t\t\t}\n\t\t\tL = C + B + A;\n\t\t}\n\t\tint x = 0, y = 0;\n\t\tvector<P>W;\n\t\twhile (L.size()) {\n\t\t\tP t = L.front(); L.pop();\n\t\t\tx += t.second - t.first + 1;\n\t\t\tif (x <= d&&x >= c) {\n\t\t\t\tif (y <= d&&y >= c) {\n\t\t\t\t\tW.push_back(P(t.first, t.second));\n\t\t\t\t}\n\t\t\t\telse {\n\t\t\t\t\tW.push_back(P(t.second - (x - c), t.second));\n\t\t\t\t}\n\t\t\t}\n\t\t\telse {\n\t\t\t\tif (y <= d&&y >= c) {\n\t\t\t\t\tW.push_back(P(t.first, t.first + d - y - 1));\n\t\t\t\t}\n\t\t\t}\n\t\t\ty += t.second - t.first + 1;\n\t\t}\n\t\tint ans = 0;\n\t\tfor (P i : W) {\n\t\t\tans += max(0, min(e, i.second) - i.first + 1);\n\t\t}\n\t\tcout << ans << endl;\n\t}\n}"
  },
  {
    "language": "C++",
    "code": "//Bokann ga bokka--nn!!\n//JOI 2008yo-5\n#include <cstdio>\n#include <cstring>\n#include <cstdlib>\n#include <cmath>\n#include <string>\n#include <algorithm>\n#include <vector>\n#include <queue>\n#include <stack>\n#include <functional>\n#include <iostream>\n#include <map>\n#include <set>\nusing namespace std;\ntypedef pair<int,int> P;\ntypedef pair<int,P> P1;\ntypedef pair<P,P> P2;\n#define pu push\n#define pb push_back\n#define mp make_pair\n#define eps 1e-7\n#define INF 2000000000\nqueue<P>que;\nint n;\nvoid shuffle(int x,int y)\n{\n\t//1~x x+1~y y+1~n\n\tint rep=que.size();\n\tfor(int i=0;i<rep;i++)\n\t{\n\t\tP p=que.front(); que.pop();\n\t\tint f=p.first,s=p.second;\n\t\tif(s<=x)\n\t\t{\n\t\t\tque.push(mp(n-x+f,n-x+s));\n\t\t}\n\t\telse if(f<=x && s<=y)\n\t\t{\n\t\t\tif(f==1 && s==y)\n\t\t\t{\n\t\t\t\tque.push(mp(n-y+1,n));\n\t\t\t}\n\t\t\telse\n\t\t\t{\n\t\t\t\tque.push(mp(n-x+f,n));\n\t\t\t\tque.push(mp(n-y+1,n-y+s-x));\n\t\t\t}\n\t\t}\n\t\telse if(f<=x)\n\t\t{\n\t\t\tif(f==1)\n\t\t\t{\n\t\t\t\tque.push(mp(n-y+1,n));\n\t\t\t\tque.push(mp(1,s-y));\n\t\t\t}\n\t\t\telse if(s==n)\n\t\t\t{\n\t\t\t\tque.push(mp(1,n-x));\n\t\t\t\tque.push(mp(n-x+f,n));\n\t\t\t}\n\t\t\telse\n\t\t\t{\n\t\t\t\tque.push(mp(1,s-y));\n\t\t\t\tque.push(mp(n-y+1,n-x));\n\t\t\t\tque.push(mp(n-x+f,n));\n\t\t\t}\n\t\t}\n\t\telse if(s<=y)\n\t\t{\n\t\t\tque.push(mp(n-y+f-x,n-y+s-x));\n\t\t}\n\t\telse if(f<=y)\n\t\t{\n\t\t\tif(f==x+1 && s==n)\n\t\t\t{\n\t\t\t\tque.push(mp(1,n-x));\n\t\t\t}\n\t\t\telse\n\t\t\t{\n\t\t\t\tque.push(mp(1,s-y));\n\t\t\t\tque.push(mp(n-y+f-x,n-x));\n\t\t\t}\n\t\t}\n\t\telse\n\t\t{\n\t\t\tque.push(mp(f-y,s-y));\n\t\t}\n\t}\n}\nint main(){\n\twhile(1)\n\t{\n\t\tcin >> n;\n\t\tif(!n) return 0;\n\t\tint m;\n\t\tcin >> m;\n\t\tint pp,q,r;\n\t\tcin >> pp >> q >> r;\n\t\tif(r==1) { cout << q-pp+1 << endl; continue;}\n\t\twhile(!que.empty()) que.pop();\n\t\tque.push(mp(1,r));\n\t\tfor(int i=0;i<m;i++)\n\t\t{\n\t\t\tint x,y;\n\t\t\tcin >> x >> y;\n\t\t\tshuffle(x,y);\n\t\t}\n\t\tint ret=0;\n\t\twhile(!que.empty())\n\t\t{\n\t\t\tP p=que.front(); que.pop();\n\t\t\tret+=max(0,min(q,p.second)-max(pp,p.first)+1);\n\t\t}\n\t\tcout << ret << endl;\n\t}\n}"
  },
  {
    "language": "C++",
    "code": "#include <iostream>\n#include <algorithm>\n#include <vector>\n\nusing namespace std;\ntypedef pair<int,int> pii;\n\nint N;\nint M;\nint P,Q,R;\n\nvoid decidePlace(int &sumX,vector<pii>&deck,int &xPos,int x){\n    for(int j=0;j<deck.size();j++){\n        if(sumX+deck[j].second-deck[j].first+1>=x){\n            xPos=j;\n            break;\n        }\n        sumX+=deck[j].second-deck[j].first+1;\n    }\n}\nvoid divideBlock(vector<pii> &deck,int &xPos,int &sumX,int x,bool isX){\n    int minu=1;\n    if(isX)minu++;\n    pii p1=pii(deck[xPos].first,deck[xPos].first+(x-sumX-minu));\n    pii p2=pii(p1.second+1,deck[xPos].second);\n    deck.erase(deck.begin()+xPos);\n    if(p2.first<=p2.second)deck.insert(deck.begin()+xPos,p2);\n    if(p1.first<=p1.second)deck.insert(deck.begin()+xPos,p1);\n}\n\nint main(){\n    while(cin>>N&&N){\n        int res=0;\n        cin>>M>>P>>Q>>R;\n        vector<pii> deck;\n        deck.push_back(pii(1,N));\n        int x,y;\n        for(int i=0;i<M;i++){\n            cin>>x>>y;\n            // xÌÓÆyÌÓðÁèµAVbt\n            int sumX=0;\n            int sumY=0;\n            int xPos,yPos;\n            // x+1ÚðÁè\n            x++;\n            decidePlace(sumX,deck,xPos,x);\n            //for(int j=0;j<deck.size();j++){\n            //    if(sumX+deck[j].second-deck[j].first+1>=x){\n            //        xPos=j;\n            //        break;\n            //    }\n            //    sumX+=deck[j].second-deck[j].first+1;\n            //}\n            // yÚðÁè\n            decidePlace(sumY,deck,yPos,y);\n            //for(int j=0;j<deck.size();j++){\n            //    if(sumY+deck[j].second-deck[j].first+1>=y){\n            //        yPos=j;\n            //        break;\n            //    }\n            //    sumY+=deck[j].second-deck[j].first+1;\n            //}\n            // x+1Ú©çy+1ÚÜÅÌÓðØèæèAVbt\n            // ¯¶æÔÉ¶Ý\n            if(xPos==yPos){\n                // »ÝÌæÔðRª\n                pii p1=pii(deck[xPos].first,deck[xPos].first+(x-sumX-2));\n                pii p2=pii(p1.second+1,deck[yPos].first+(y-sumY-1));\n                pii p3=pii(p2.second+1,deck[xPos].second);\n                deck.erase(deck.begin()+xPos);\n                if(p3.first<=p3.second)deck.insert(deck.begin()+xPos,p3);\n                if(p2.first<=p2.second)deck.insert(deck.begin()+xPos,p2);\n                if(p1.first<=p1.second)deck.insert(deck.begin()+xPos,p1);\n            }\n            // ÊÌæÔÉ¶Ý·éêÍA»ê¼êÌæÔ²ÆÉªðs¤\n            else{\n                // y\n                //{\n                //    pii p1=pii(deck[yPos].first,deck[yPos].first+(y-sumY-1));\n                //    pii p2=pii(p1.second+1,deck[yPos].second);\n                //    deck.erase(deck.begin()+yPos);\n                //    if(p2.first<=p2.second)deck.insert(deck.begin()+yPos,p2);\n                //    if(p1.first<=p1.second)deck.insert(deck.begin()+yPos,p1);\n                //}\n                divideBlock(deck,yPos,sumY,y,false);\n                divideBlock(deck,xPos,sumX,x,true);\n                // x\n                //{\n                //    pii p1=pii(deck[xPos].first,deck[xPos].first+(x-sumX-2));\n                //    pii p2=pii(p1.second+1,deck[xPos].second);\n                //    deck.erase(deck.begin()+xPos);\n                //    if(p2.first<=p2.second)deck.insert(deck.begin()+xPos,p2);\n                //    if(p1.first<=p1.second)deck.insert(deck.begin()+xPos,p1);\n                //}\n            }\n            // à¤êxxÆyÌêðTõµA©Â¯½çVbt\n            sumX=sumY=0;\n            decidePlace(sumX,deck,xPos,x);\n            decidePlace(sumY,deck,yPos,y);\n            //for(int j=0;j<deck.size();j++){\n            //    if(sumX+deck[j].second-deck[j].first+1>=x){\n            //        xPos=j;\n            //        break;\n            //    }\n            //    sumX+=deck[j].second-deck[j].first+1;\n            //}\n            //for(int j=0;j<deck.size();j++){\n            //    if(sumY+deck[j].second-deck[j].first+1>=y){\n            //        yPos=j;\n            //        break;\n            //    }\n            //    sumY+=deck[j].second-deck[j].first+1;\n            //}\n            // xpos©çyposÜÅÌÓð²«oµÄAVbt\n            vector<pii> cutPlace;\n            vector<pii> prv;\n            vector<pii> nxt;\n            for(int i=xPos;i<=yPos;i++)cutPlace.push_back(deck[i]);\n            for(int i=0;i<xPos;i++)prv.push_back(deck[i]);\n            for(int i=yPos+1;i<deck.size();i++)nxt.push_back(deck[i]);\n            deck.clear();\n            for(int i=0;i<nxt.size();i++)deck.push_back(nxt[i]);\n            for(int i=0;i<cutPlace.size();i++)deck.push_back(cutPlace[i]);\n            for(int i=0;i<prv.size();i++)deck.push_back(prv[i]);\n        }\n        // VbtI¹ãApÆqÌl©çAðð½·àÌðTõ\n        int sum=0;\n        bool isApP=false;\n        for(int i=0;i<deck.size();i++){\n            int cnt=deck[i].second-deck[i].first+1;\n            sum+=cnt;\n            if(sum<P)continue;\n            // ¡ñÌæÔÉñÂÆàÜÜêéê\n            if(sum-cnt<P&&sum-cnt<Q&&sum>=P&&sum>=Q){\n                int pPos=P-(sum-cnt)-1;\n                int pNum=pPos+deck[i].first;\n                int qPos=Q-(sum-cnt)-1;\n                int qNum=qPos+deck[i].first;\n                // pÌl©çrÈºÌàÌð¦ã°\n                if(pNum<=R)\n                    res+=max(0,min(-qNum+R+1,qNum-pNum+1));\n                break;\n            }\n            // ¡ñÌæÔÅßÄpª»ê½ê\n            else if(!isApP&&sum>=P){\n                isApP=true;\n                int pPos=P-(sum-cnt)-1;\n                int pNum=pPos+deck[i].first;\n                // pÌl©çrÈºÌàÌð¦ã°\n                if(pNum<=R)\n                    res+=max(0,min(-deck[i].first+R+1,deck[i].second-pNum+1));\n            }\n            // pªo»ÏÝÌê\n            else if(isApP){\n                // ¡ñQª»ê½çðµÄbreak\n                if(sum>=Q){\n                    int qPos=Q-(sum-cnt)-1;\n                    int qNum=qPos+deck[i].first;\n                    if(deck[i].first<=R)res+=min(qNum-deck[i].first+1,(R-deck[i].first+1));\n                    break;\n                }\n                // æÔÌl·×ÄÉÎµÄvZ\n                else{\n                    if(deck[i].first<=R){\n                        res+=max(0,min(-deck[i].first+R+1,deck[i].second-deck[i].first+1));\n                    }\n                }\n            }\n        }\n        cout<<res<<endl;\n    }\n    return 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include<iostream>\n#include<cstdio>\n#include<algorithm>\n#include<string>\n#include<vector>\n#include<queue>\n#include<set>\n#include<stack>\n#include<functional>\n#include<list>\n#define P pair<int,int>\nusing namespace std;\n\nlist<P>operator +(list<P>a, list<P>b) {\n\twhile (b.size()) {\n\t\ta.push_back(b.front()); b.pop_front();\n\t}\n\treturn a;\n}\nlist<P>L;\nint main() {\n\tint a;\n\twhile (cin >> a, a) {\n\t\tint b, c, d, e; scanf(\"%d%d%d%d\", &b, &c, &d, &e);\n\t\tL.clear();\n\t\tL.push_back(P(1, a));\n\t\tfor (int f = 0; f < b; f++) {\n\t\t\tint g, h; scanf(\"%d%d\", &g, &h);\n\t\t\tlist<P>A, B, C;\n\t\t\tint sum = 0,j=0;\n\t\t\twhile (L.size()) {\n\t\t\t\tP i = L.front(); L.pop_front();\n\t\t\t\tsum += i.second - i.first+1;\n\t\t\t\tif (j < g&&sum > g) {\n\t\t\t\t\tif (j < h&&sum > h) {\n\t\t\t\t\t\tA.push_back(P(i.first, i.first + (g - j) - 1));\n\t\t\t\t\t\tB.push_back(P(i.first + (g - j), i.first + (h - j)-1));\n\t\t\t\t\t\tC.push_back(P(i.first + (h - j), i.second));\n\t\t\t\t\t}\n\t\t\t\t\telse {\n\t\t\t\t\t\tA.push_back(P(i.first, i.first + (g - j) - 1));\n\t\t\t\t\t\tB.push_back(P(i.first + (g - j), i.second));\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t\telse {\n\t\t\t\t\tif (j < h&&sum > h) {\n\t\t\t\t\t\tB.push_back(P(i.first, i.first + (h - j) - 1));\n\t\t\t\t\t\tC.push_back(P(i.first + (h - j), i.second));\n\t\t\t\t\t}\n\t\t\t\t\telse {\n\t\t\t\t\t\tif (sum > h) {\n\t\t\t\t\t\t\tC.push_back(i);\n\t\t\t\t\t\t}\n\t\t\t\t\t\telse if (sum > g) {\n\t\t\t\t\t\t\tB.push_back(i);\n\t\t\t\t\t\t}\n\t\t\t\t\t\telse {\n\t\t\t\t\t\t\tA.push_back(i);\n\t\t\t\t\t\t}\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t\tj += i.second - i.first+1;\n\t\t\t}\n\t\t\tL = C + B + A;\n\t\t}\n\t\tint x = 0, y = 0;\n\t\tvector<P>W;\n\t\twhile (L.size()) {\n\t\t\tP t = L.front(); L.pop_front();\n\t\t\tx += t.second - t.first + 1;\n\t\t\tif (x <= d&&x>=c) {\n\t\t\t\tif (y <= d&&y >= c) {\n\t\t\t\t\tW.push_back(P(t.first,t.second));\n\t\t\t\t}\n\t\t\t\telse {\n\t\t\t\t\tW.push_back(P(t.second-(x-c),t.second));\n\t\t\t\t}\n\t\t\t}\n\t\t\telse {\n\t\t\t\tif (y<=d&&y>=c) {\n\t\t\t\t\tW.push_back(P(t.first,t.first+d-y-1));\n\t\t\t\t}\n\t\t\t}\n\t\t\ty += t.second - t.first + 1;\n\t\t}\n\t\tint ans = 0;\n\t\tfor (P i: W) {\n\t\t\tans += max(0, min(e, i.second) - i.first + 1);\n\t\t}\n\t\tcout<<ans<<endl;\n\t}\n}"
  },
  {
    "language": "C++",
    "code": "#include<bits/stdc++.h>\n#define rep(i,n)for(int i=0;i<n;i++)\nusing namespace std;\ntypedef pair<int, int>P;\ntypedef long long ll;\n\nint main() {\n\tint n, m, p, q, r;\n\twhile (scanf(\"%d\", &n), n) {\n\t\tscanf(\"%d%d%d%d\", &m, &p, &q, &r);\n\t\tqueue<P>que, que1, que2, que3;\n\t\tque.push(P(1, n));\n\t\trep(i, m) {\n\t\t\tint x, y; scanf(\"%d%d\", &x, &y);\n\t\t\tint cnt = 0;\n\t\t\twhile (!que.empty()) {\n\t\t\t\tP p = que.front(); que.pop();\n\t\t\t\tint f = p.first, s = p.second;\n\t\t\t\tif (cnt + s - f + 1 <= x) {\n\t\t\t\t\tque1.push(p);\n\t\t\t\t\tgoto g;\n\t\t\t\t}\n\t\t\t\tif (y <= cnt) {\n\t\t\t\t\tque3.push(p);\n\t\t\t\t\tgoto g;\n\t\t\t\t}\n\t\t\t\tif (cnt < x) {\n\t\t\t\t\tque1.push(P(f, f + x - cnt - 1));\n\t\t\t\t\tp.first = f + x - cnt;\n\t\t\t\t}\n\t\t\t\tif (y < cnt + s - f + 1) {\n\t\t\t\t\tque3.push(P(f + y - cnt, s));\n\t\t\t\t\tp.second = f + y - cnt - 1;\n\t\t\t\t}\n\t\t\t\tque2.push(P(p.first, p.second));\n\t\t\tg:\n\t\t\t\tcnt += s - f + 1;\n\t\t\t}\n\t\t\twhile (!que3.empty()) { que.push(que3.front()); que3.pop(); }\n\t\t\twhile (!que2.empty()) { que.push(que2.front()); que2.pop(); }\n\t\t\twhile (!que1.empty()) { que.push(que1.front()); que1.pop(); }\n\t\t}\n\t\tint cnt = 0, ans = 0;\n\t\twhile (!que.empty()) {\n\t\t\tP pa = que.front(); que.pop();\n\t\t\tint f = pa.first, s = pa.second;\n\t\t\tif (cnt + s - f + 1 < p)goto e;\n\t\t\tif (r < f)goto e;\n\t\t\tif (cnt <= p)\n\t\t\t\tpa.first = f + p - cnt - 1;\n\t\t\tif (q < cnt + s - f + 1)\n\t\t\t\tpa.second = f + q - cnt - 1;\n\t\t\tif (pa.second <= r) {\n\t\t\t\tans += pa.second - pa.first + 1;\n\t\t\t\tgoto e;\n\t\t\t}\n\t\t\tans += r - pa.first + 1;\n\t\te:\n\t\t\tcnt += s - f + 1;\n\t\t\tif (q <= cnt)break;\n\t\t}\n\t\tprintf(\"%d\\n\", ans);\n\t}\n\treturn 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include <iostream>\n#include <vector>\nusing namespace std;\ntypedef pair<int,int> Card;\ntypedef vector<Card> Cards;\n\npair<int,int> f(int x,Cards& c){\n\tint sum = 0;\n\tfor(int i = 0 ; i < c.size() ; i++){\n\t\tint num = c[i].second - c[i].first + 1;\n\t\tif(sum + num <= x){\n\t\t\tsum += num;\t\n\t\t}else{\n\t\t\tint a = x - sum;\n\t\t\treturn make_pair(i,a);\n\t\t}\n\t}\n}\nCards get(int x,int y,Cards& c){\n\tCards g;\n\tpair<int,int> s = f(x,c) , e = f(y,c);\n\tif(s.first != e.first){\n\t\tg.push_back(make_pair(c[s.first].first+s.second,c[s.first].second));\n\t\tfor(int i = s.first + 1 ; i <= e.first-1 ; i++){\n\t\t\tg.push_back(c[i]);\n\t\t}\n\t\tg.push_back(make_pair(c[e.first].first,c[e.first].first+e.second));\n\t\t\n\t}else{\n\t\tint S = s.second , E = e.second;\n\t\t//cout << S << \"-\" << E << endl;\n\t\tg.push_back(make_pair(c[s.first].first+S,c[s.first].first+E));\n\t}\n\treturn g;\n}\nint main(){\n\tint n;\n\twhile(cin >> n && n){\n\t\tCards c(1,make_pair(0,n-1));\n\t\tint m; cin >> m;\n\t\tint p,q,r;\n\t\tcin >> p >> q >> r;\n\t\tp--,q--;\n\t\tfor(int i = 0 ; i < m ; i++){\n\t\t\tint a,b;\n\t\t\tcin >> a >> b;\n\t\t\ta--,b--;\n\t\t\tCards A = get(0,a,c) , B = get(a+1,b,c) , C = get(b+1,n-1,c);\n\t\t\tC.insert(C.end(),B.begin(),B.end());\n\t\t\tC.insert(C.end(),A.begin(),A.end());\n\t\t\tc = C;\n\t\t}\n\t\tint ans = 0;\n\t\tc = get(p,q,c);\n\t\tfor(int i = 0 ; i < c.size() ; i++){\n\t\t\t//cout << c[i].first << \" \" << c[i].second << endl;\n\t\t\tif( c[i].first < r ){\n\t\t\t\tans += min(c[i].second,r-1) - c[i].first + 1;\n\t\t\t}\n\t\t}\n\t\tcout << ans << endl;\n\t}\n\t\n}"
  },
  {
    "language": "C++",
    "code": "#include<bits/stdc++.h>\nusing namespace std;\n\nint solve();\n\nint N,M,P,Q,R;\nint X[5010],Y[5010];\n\nint main()\n{\n    while(scanf(\"%d\",&N),N)\n    {\n        scanf(\"%d\",&M);\n        scanf(\"%d%d%d\",&P,&Q,&R);\n        for(int i = 0; i < M; i++)\n        {\n            scanf(\"%d%d\",&X[i],&Y[i]);\n        }\n        printf(\"%d\\n\",solve());\n    }\n}\n\nint solve()\n{\n    int ANS = 0;\n    vector<pair<int,int> > vec[5010];\n    vec[0].push_back(make_pair(1,R));\n    for(int i = 0; i < M; i++)\n    {\n        for(int j = 0; j < vec[i].size(); j++)\n        {\n            int l = vec[i][j].first,r = vec[i][j].second;\n            if(l <= X[i] && r <= X[i])\n            {\n                vec[i + 1].push_back(make_pair(l + N - X[i],r + N - X[i]));\n                continue;\n            }\n            if(l <= X[i] && X[i] < r && r <= Y[i])\n            {\n                vec[i + 1].push_back(make_pair(l + N - X[i],N));\n                vec[i + 1].push_back(make_pair(N - Y[i] + 1,r + N - X[i] - Y[i]));\n                continue;\n            }\n            if(X[i] < l && l <= Y[i] && X[i] < r && r <= Y[i])\n            {\n                vec[i + 1].push_back(make_pair(l + N - X[i] - Y[i],r + N - X[i] - Y[i]));\n                continue;\n            }\n            if(X[i] < l && l <= Y[i] && Y[i] < r)\n            {\n                vec[i + 1].push_back(make_pair(l + N - X[i] - Y[i],N - X[i]));\n                vec[i + 1].push_back(make_pair(1,r - Y[i]));\n                continue;\n            }\n            if(Y[i] < l && Y[i] < r)\n            {\n                vec[i + 1].push_back(make_pair(l - Y[i],r - Y[i]));\n                continue;\n            }\n            if(l <= X[i] && Y[i] < r)\n            {\n                vec[i + 1].push_back(make_pair(l + N - X[i],N));\n                vec[i + 1].push_back(make_pair(N - Y[i] + 1,N - X[i]));\n                vec[i + 1].push_back(make_pair(1,r - Y[i]));\n                continue;\n            }\n        }\n        vec[i].clear();\n    }\n    for(int i = 0;i < vec[M].size(); i++)\n    {\n        int l = vec[M][i].first,r = vec[M][i].second;\n        int a = max(l,P),b = min(r,Q) + 1;\n        ANS += max(0,b - a);\n    }\n    return ANS;\n}"
  },
  {
    "language": "C++",
    "code": "\n#include<iostream>\nusing namespace std;\nint cards,n,i,p,q,r,x[5000],y[5000],counter;\n  int numberStart[10001];\n  int numberFast[10001];\n  int numberEnd[10001];\n  int searchB[10001];\nint numberLong(int value){\n\treturn numberEnd[value]-numberStart[value]+1;\n}\n\n\nint searchD(int seed){\n\t\tint l=0;\n  for (int a=1;a<=counter+1;a++){\n\tif(seed>l+numberLong(searchB[a])){\n\tl+=numberLong(searchB[a]);\n\t}\n\telse{\n\t return numberFast[searchB[a]];\n\t}\n  }\n return -100;\n\t\n}\nint searchNumber(int value){\n\tint l=0;\n  for (int a=1;a<=counter+1;a++){\n\tif(value>l+numberLong(searchB[a])){\n\tl+=numberLong(searchB[a]);\n\t}\n\telse{\n\t return numberStart[searchB[a]]+value-l-1;\n\t}\n  }\n return -100;\n}\n\nvoid cut(int g){\n\tif(searchD(g)==searchD(g+1)){\n  //カットする場所が入ってる数列を求める\n\tint\tsearchNumberG=searchNumber(g);\n  int seachX=searchB[searchD(g)];\n  int seachXX=searchNumberG;\n//数列ができる範囲の後ろの番号FASTを変える\n     for(int j=1;j<=counter;j++){\n      if (numberFast[j]>=numberFast[seachX]+1){\n      numberFast[j]++;\n     }\n    }\n\n  //の数列の後ろに新しい数列を作る\n counter++;\n  numberFast[counter]=numberFast[seachX]+1;\n  numberStart[counter] =searchNumberG+1;\n  numberEnd[counter]=numberEnd[seachX];\n  //できた数列の前の数列の最後を調整する\n  numberEnd[seachX]=searchNumberG;\n \n\n  \n  for ( int a=1;a<=counter+1;a++){\n\t  searchB[numberFast[a]]=a;\n    }\n    }\n\n}\nvoid shuffle(int x,int y){\n\t\n\tint StartHead[10001];\n\tint  numberFastNew[10001];\n\t\n\tint longs=1;\n\tfor (int i=1;i<=counter;i++){\n\t\tStartHead[searchB[i]]=longs;\n\t\tlongs+=numberLong(searchB[i]);\n\t}\n\tint newCounter[3];\n\tfor(int i=0;i<3;i++){\n\t\tnewCounter[i]=0;\n\t}\n\tfor(int j=1;j<=counter;j++){\n\t\tif (StartHead[j]>y){\n\t\t\tnewCounter[0]++;\n\t\tnumberFastNew[j]=0;\n\t\t}\n\t\tif (StartHead[j]>x && StartHead[j]+numberLong(j)-1<=y){\n\t\t\tnewCounter[1]++;\n\t\tnumberFastNew[j]=1;\n\t\t}\n\t\tif (StartHead[j]+numberLong(j)-1<=x){\n\t\t\tnewCounter[2]++;\n\t\tnumberFastNew[j]=2;\n\t\t}\n\t}\n\t\n\tfor(int j=1;j<=counter;j++){\n\t\tswitch(numberFastNew[j]){\n\t\t\tcase 0:\n\t\t\t\tnumberFast[j]+=-newCounter[1]-newCounter[2];\n\t\t\t\tbreak;\n\t\t\tcase 1:\n\t\t\t\tnumberFast[j]+=newCounter[0]-newCounter[2];\n\t\t\t\tbreak;\n\t\t\tcase 2:\n\t\t\t\tnumberFast[j]+=newCounter[1]+newCounter[0];\n\t\t\t\tbreak;\n\t\t}\n\n\t}\n\t  for ( int a=1;a<=counter+1;a++){\n\t  searchB[numberFast[a]]=a;\n    }\n\n}\n\n\nint main(void)\n{\n\twhile(true){\n\tcards=0;\n\tn=0;\n\tcounter=0;\n\tfor (int i=0;i<10001;i++){\n   numberStart[i]=0;\n   numberFast[i]=0;\n   numberEnd[i]=0;\n   searchB[i]=0;\n\t}\n\tint points=0;\n  counter=1;\n  cin >> cards;\n  if (cards==0){\n\t  break;\n  }\n  numberStart[1]=1;\n  numberEnd[1]=cards;\n  numberFast[1]=1;\n  searchB[1]=1;\n  cin >> n;\n  cin >> p  >> q  >> r ;\n  for (i=1;i<=n;i++){\n    cin >> x[i] >> y[i];\n  }\n  for (i=1;i<=n;i++){\n     cut(x[i]);\n\t \n      cut(y[i]);\n\t  \n     shuffle(x[i],y[i]);\n  }\n  cut(p-1);\n  cut(q);\n \n  \n  for(int j=1;j<=counter;j++){\n\n    cout << numberStart[j] << \" \"  <<  numberEnd[j] << \" \" << numberFast[j] <<  endl;\n\n  }\n  cout << searchD(p) << searchD(q) <<endl;\n\n  for(int j=1;j<=counter;j++){\n  if( searchD(p)< numberFast[j] && numberFast[j] <= searchD(q)){\n\t  if(numberEnd[j]<=r){\n\t  points+=numberLong(j);\n\t  }\n\t  else if(numberStart[j]<=r){\n\tpoints+=numberLong(j)-(numberEnd[j]-r);\n\t  }\n  }\n  }\n  cout << points << endl;\n\t}\n}"
  },
  {
    "language": "C++",
    "code": "#include<iostream>\n#include<string>\n#include<cmath>\n#include<queue>\n#include<map>\n#include<set>\n#include<list>\n#include<iomanip>\n#include<vector>\n#include<functional>\n#include<algorithm>\n#include<cstdio>\n#include<unordered_map>\nusing namespace std;\n//---------------------------------------------------\n//????????????????????????????????????\n#define int long long\n#define str string\n#define rep(i,j) for(int i=0;i<(int)(j);i++)\ntypedef long long ll;\ntypedef long double ld;\nconst ll inf = 4523372036854775807;\nconst int inf2 = 1145141919;\nconst ld pi = 3.14159265358979323846264338327950288419716939937510582097494459230781640628620899;\nstruct P {\n\tll pos, cost;\n};\nbool operator<(P a, P b) { return a.cost < b.cost; }\nbool operator>(P a, P b) { return a.cost > b.cost; }\nstruct B {//??£??\\???????????¨???\n\tll to, cost;\n};\nstruct S {//???????????±?????\\???????????°\n\tint from, to, cost;\n};\nbool operator<(S a, S b) { return a.cost < b.cost; }\nbool operator>(S a, S b) { return a.cost > b.cost; }\nstruct H {\n\tint x, y;\n};\nll gcm(ll i, ll j) {//?????§??¬?´???°\n\tif (i > j) swap(i, j);\n\tif (i == 0) return j;\n\treturn gcm(j%i, i);\n}\nld rad(ld a, ld b, ld c, ld d) {\n\treturn sqrt(pow(a - c, 2) + pow(b - d, 2));\n}//rad?????§?¨???????2??????????????¢\n //---------------------------------------------------\n //+++++++++++++++++++++++++++++++++++++++++++++++++++\nstruct A {\n\tint s, e, s2, size;\n\t//????????????????????????????????????????????????????????????????????????\n};\nint n, m, p, q, r;\nvector<A>a[2];\nvector<int>b[2];\nsigned main() {\n\twhile (cin >> n) {\n\t\tcin >> m >> p >> q >> r;\n\t\tint d = 0, e = 1, k, t, x, y;\n\t\ta[0].clear(); a[1].clear();\n\t\tb[0].clear(); b[1].clear();\n\t\ta[d].push_back(A{ 1,n,1,n });\n\t\tb[d].push_back(1);\n\t\tfor (int z = 0; z < m; z++) {\n\t\t\ta[e].clear(); b[e].clear();\n\t\t\tcin >> x >> y;\n\t\t\t//y+1??????????????????????????§????????????????????????????????????\n\t\t\tk = lower_bound(b[d].begin(), b[d].end(), y + 1) - b[d].begin();\n\t\t\tif (k == b[d].size() || a[d][k].s2 > y + 1)\n\t\t\t\tk--;\n\t\t\tb[e].push_back(1);\n\t\t\ta[e].push_back(A{ a[d][k].s + (y + 1 - a[d][k].s2),a[d][k].e,1,a[d][k].size - (y + 1 - a[d][k].s2) });\n\t\t\tint sum = a[d][k].size - (y + 1 - a[d][k].s2) + 1;\n\t\t\tk++;\n\t\t\tfor (; k < a[d].size(); k++) {\n\t\t\t\tb[e].push_back(sum);\n\t\t\t\ta[e].push_back(A{ a[d][k].s,a[d][k].e,sum,a[d][k].size });\n\t\t\t\tsum += a[d][k].size;\n\t\t\t}\n\t\t\t//x+1?????????y?????§???????????????????????????????????????\n\t\t\tk = lower_bound(b[d].begin(), b[d].end(), x + 1) - b[d].begin();\n\t\t\tt = lower_bound(b[d].begin(), b[d].end(), y) - b[d].begin();\n\t\t\tif (k == a[d].size() || a[d][k].s2 > x + 1)\n\t\t\t\tk--;\n\t\t\tif (t == a[d].size() || a[d][t].s2 > y)\n\t\t\t\tt--;\n\t\t\tif (k == t) {\n\t\t\t\tb[e].push_back(sum);\n\t\t\t\ta[e].push_back(A{ a[d][k].s + (x + 1 - a[d][k].s2),a[d][k].s + (y - a[d][k].s2),sum,y - x });\n\t\t\t\tsum += y - x;\n\t\t\t}\n\t\t\telse {\n\t\t\t\tb[e].push_back(sum);\n\t\t\t\ta[e].push_back(A{ a[d][k].s + (x + 1 - a[d][k].s2),a[d][k].e,sum,a[d][k].size - (x + 1 - a[d][k].s2) });\n\t\t\t\tsum += (a[d][k].size - (x + 1 - a[d][k].s2));\n\t\t\t\tk++;\n\t\t\t\tfor (; k < t; k++) {\n\t\t\t\t\tb[e].push_back(sum);\n\t\t\t\t\ta[e].push_back(A{ a[d][k].s,a[d][k].e,sum,a[d][k].size });\n\t\t\t\t\tsum += a[d][k].size;\n\t\t\t\t}\n\t\t\t\tb[e].push_back(sum);\n\t\t\t\ta[e].push_back(A{ a[d][k].s,a[d][k].s + (y - a[d][k].s2),sum,y - a[d][k].s2 + 1 });\n\t\t\t\tsum += y - a[d][k].s2 + 1;\n\t\t\t}\n\t\t\t//1??????x?????§????????????????????????????????§?????????\n\t\t\tk = lower_bound(b[d].begin(), b[d].end(), x) - b[d].begin();\n\t\t\tif (k == b[d].size() || a[d][k].s2 > x)\n\t\t\t\tk--;\n\t\t\tfor (int i = 0; i < k; i++) {\n\t\t\t\tb[e].push_back(sum);\n\t\t\t\ta[e].push_back(A{ a[d][i].s,a[d][i].e,sum,a[d][i].size });\n\t\t\t\tsum += a[d][i].size;\n\t\t\t}\n\t\t\tb[e].push_back(sum);\n\t\t\ta[e].push_back(A{ a[d][k].s,a[d][k].s + (x - a[d][k].s2),sum,x - a[d][k].s2 + 1 });\n\t\t\tswap(d, e);\n\t\t}\n\t\tk = lower_bound(b[d].begin(), b[d].end(), p) - b[d].begin();\n\t\tt = lower_bound(b[d].begin(), b[d].end(), q) - b[d].begin();\n\t\tif (k == b[d].size() || a[d][k].s2 > p) k--;\n\t\tif (t == b[d].size() || a[d][t].s2 > q) t--;\n\t\ta[d][k].size -= (p - a[d][k].s2);\n\t\ta[d][k].s = a[d][k].s + (p - a[d][k].s2);\n\t\ta[d][t].size = (q - a[d][t].s2 + 1);\n\t\ta[d][t].e = a[d][t].s + (q - a[d][t].s2);\n\t\tint sum = 0;\n\t\tif (k == t) {\n\t\t\tif (a[d][k].e <= r)\n\t\t\t\tsum = a[d][k].size;\n\t\t\telse if (a[d][k].s <= r)\n\t\t\t\tsum = r - a[d][k].s + 1;\n\t\t}\n\t\telse {\n\t\t\tfor (; k <= t; k++) {\n\t\t\t\tif (a[d][k].e <= r)\n\t\t\t\t\tsum += a[d][k].size;\n\t\t\t\telse if (a[d][k].s <= r)\n\t\t\t\t\tsum += r - a[d][k].s + 1;\n\t\t\t}\n\t\t}\n\t\tcout << sum << endl;\n\t}\n\tgetchar(); getchar();\n}"
  },
  {
    "language": "C++",
    "code": "#include <vector>\n#include <algorithm>\n#include <set>\n#include <map>\n#include <queue>\n#include <stack>\n#include <iostream>\n#include <cstdio>\n#include <cmath>\n#include <cstring>\nusing namespace std;\ntypedef long long ll;\ntypedef pair<ll,ll> P;\ntypedef double db;\nstruct T{\n\tll st;\n\tll en;\n\tbool b;\n\tbool operator<(const T& another)const{\n\t\tif(st==another.st) return en<another.en;\n\t\treturn st<another.st;\n\t}\n};\nvector<T> cards[2];\nll n,m,p,q,r;\nll x,y;\n\nconst ll INF=0xffffffffff;\nll B=1;\nvoid printv(){\n\tfor(ll i=0;i<cards[!B].size();i++){\n\t\tcout<<\"cards[\"<<i<<\"]={\";\n\t\tprintf(\"%lld,%lld,\",cards[!B][i].st,cards[!B][i].en);\n\t\tcout<<cards[!B][i].b<<\"}\"<<endl;\n\t}\n\tcout<<endl;\n}\n\nint main()\n{\n\twhile(1){\n\tB=1;\n\tscanf(\"%lld\",&n);\n\tif(!n) return 0;\n\tscanf(\"%lld%lld%lld%lld\",&m,&p,&q,&r);\n\tp--;\n\tq--;\n\tcards[0].clear();\n\tcards[0].push_back((T){0,r-1,1});\n\tcards[0].push_back((T){r,n-1,0});\n\tfor(ll i=0;i<m;i++){\n\t\t//printv();\n\t\tcards[B].clear();\n\t\tscanf(\"%lld%lld\",&x,&y);\n\t\tx--;\n\t\ty--;\n\t\tll kosu=0;\n\t\tll px=upper_bound(cards[!B].begin(),cards[!B].end(),(T){x,INF,INF})-cards[!B].begin()-1;\n\t\tll py=upper_bound(cards[!B].begin(),cards[!B].end(),(T){y,INF,INF})-cards[!B].begin()-1;\n\t\tif(cards[!B][py].en>y){\n\t\t\tcards[B].push_back((T){0,cards[!B][py].en-y-1,cards[!B][py].b});\n\t\t\tkosu+=cards[!B][py].en-y;\n\t\t}\n\t\tfor(ll i=py+1;i<cards[!B].size();i++){\n\t\t\tcards[B].push_back((T){kosu,kosu+cards[!B][i].en-cards[!B][i].st,cards[!B][i].b});\n\t\t\tkosu+=cards[!B][i].en-cards[!B][i].st+1;\n\t\t}\n\t\tif(cards[!B][px].en>x){\n\t\t\tcards[B].push_back((T){kosu,kosu+cards[!B][px].en-x-1,cards[!B][px].b});\n\t\t\tkosu+=cards[!B][px].en-x;\n\t\t}\n\t\tfor(ll i=px+1;i<py;i++){\n\t\t\tcards[B].push_back((T){kosu,kosu+cards[!B][i].en-cards[!B][i].st,cards[!B][i].b});\n\t\t\tkosu+=cards[!B][i].en-cards[!B][i].st+1;\n\t\t}\n\t\tcards[B].push_back((T){kosu,kosu+y-cards[!B][py].st,cards[!B][py].b});\n\t\tkosu+=y-cards[!B][py].st+1;\n\t\tfor(ll i=0;i<px;i++){\n\t\t\tcards[B].push_back((T){kosu,kosu+cards[!B][i].en-cards[!B][i].st,cards[!B][i].b});\n\t\t\tkosu+=cards[!B][i].en-cards[!B][i].st+1;\n\t\t}\n\t\tcards[B].push_back((T){kosu,kosu+x-cards[!B][px].st,cards[!B][px].b});\n\t\tkosu+=x-cards[!B][px].st+1;\n\t\tB=!B;\n\t}\n\t//printv();\n\tll ans=0;\n\tfor(ll i=0;i<cards[!B].size();i++){\n\t\tif(!cards[!B][i].b) continue;\n\t\tif(q<cards[!B][i].st||cards[!B][i].en<p) continue;\n\t\tans+=max(p,cards[!B][i].st)-min(q,cards[!B][i].en)+1;\n\t}\n\tprintf(\"%lld\\n\",ans);\n}}"
  },
  {
    "language": "C++",
    "code": "#include<vector>\n#include<list>\n#include<algorithm>\n#include<iostream>\n#include<string>\n#include<cstdio>\n#include<cstdlib>\n#include<cstring>\n#include<cmath>\nusing namespace std;\nint main(){\n  int i,j;\n  int m,n,p,q,r,x,y;\n  int sm;\n  list<int> a,b,c,d;\n  list<int>::iterator it,jt,kt;\n  while(cin>>n&&n){\n    cin>>m>>p>>q>>r;\n    a.clear();\n    for(i=1;i<n+1;i++)\n      a.push_back(i);\n    for(i=0;i<m;i++){\n      cin>>x>>y;\n      it=a.begin();\n      for(j=0;j<x;j++)\n\tit++;\n      jt=it;\n      for(j=0;j<y-x;j++)\n\tit++;\n      kt=it;\n      b.clear();\n      b.assign(a.begin(),jt);\n      c.clear();\n      c.assign(jt,kt);\n      d.clear();\n      d.assign(kt,a.end());\n      a.clear();\n      a.splice(a.end(),d);\n      a.splice(a.end(),c);\n      a.splice(a.end(),b);\n    }\n    it=a.begin();\n    sm=0;\n    for(i=0;i<p-1;i++)\n      it++;\n    for(i=0;i<q-p+1;i++){\n      if(*it<=r)\n\tsm++;\n      it++;\n    }\n    cout<<sm<<endl;\n  }\n  return 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include <iostream>\n#include <iomanip>\n#include <string>\n#include <vector>\n#include <queue>\n#include <algorithm>\n#include <utility>\n#include <cmath>\n#include <map>\n#include <set>\n#include <stack>\n#include <cstdio>\n#include <cstdlib>\n#include <cstring>\n\n#define INF_LL 1e18\n#define INF 1e9\n\n#define REP(i, n) for(int i = 0;i < (n);i++)\n#define FOR(i, a, b) for(int i = (a);i < (b);i++)\n#define all(x) x.begin(),x.end()\n\n#define fst first\n#define snd second\n\nusing namespace std;\n\nusing ll = long long;\nusing PII = pair<int, int>;\nusing PLL = pair<ll, ll>;\n\nint main(void){\n\tint N, M;\n\twhile(cin >> N && N){\n\tvector<PLL> card;\n\tint p, q, r;\n\tcin >> M;\n\tcin >> p >> q >> r;\n\tcard.push_back({1, N+1});\n\tREP(i, M){\n\t\tint x, y;\n\t\tcin >> x >> y;\n\t\tint sum = 0;\n\t\tint c = 0;\n\t\tvector<PLL> tmp1, tmp2, tmp3;\n\t\twhile(sum < x){\n\t\t\tif(sum + card[c].second-card[c].first <= x){\n\t\t\t\tsum += card[c].second-card[c].first;\n\t\t\t\ttmp1.push_back(card[c]);\n\t\t\t}else{\n\t\t\t\ttmp1.push_back({card[c].first, card[c].first+x-sum});\n\t\t\t\tif(sum + card[c].second-card[c].first <= y){\n\t\t\t\t\ttmp2.push_back({card[c].first+x-sum, card[c].second});\n\t\t\t\t\tsum += card[c].second-card[c].first;\n\t\t\t\t}else{\n\t\t\t\t\ttmp2.push_back({card[c].first+x-sum, card[c].first+y-sum});\n\t\t\t\t\ttmp3.push_back({card[c].first+y-sum, card[c].second});\n\t\t\t\t\tsum += card[c].second-card[c].first;\n\t\t\t\t}\n\t\t\t}\n\t\t\tc++;\n\t\t}\n\t\twhile(sum < y){\n\t\t\tif(sum + card[c].second-card[c].first <= y){\n\t\t\t\tsum += card[c].second-card[c].first;\n\t\t\t\ttmp2.push_back(card[c]);\n\t\t\t}else{\n\t\t\t\ttmp2.push_back({card[c].first, card[c].first+y-sum});\n\t\t\t\ttmp3.push_back({card[c].first+y-sum, card[c].second});\n\t\t\t\tsum += card[c].second-card[c].first;\n\t\t\t}\n\t\t\tc++;\n\t\t}\n\t\twhile(c < card.size()){\n\t\t\ttmp3.push_back(card[c]);\n\t\t\tc++;\n\t\t}\n\t\tREP(j, tmp2.size()){\n\t\t\ttmp3.push_back(tmp2[j]);\n\t\t}\n\t\tREP(j, tmp1.size()){\n\t\t\ttmp3.push_back(tmp1[j]);\n\t\t}\n\t\tcard = tmp3;\n\t}\n\tll sum = 0;\n\tll res = 0;\n\tll c = 0;\n\twhile(sum + card[c].second - card[c].first < p){\n\t\tc++;\n\t\tsum += card[c].second-card[c].first;\n\t}\n\tif(p-sum+card[c].first <= r){\n\t\tif(card[c].second <= r){\n\t\t\tres += card[c].second-(p-sum+card[c].first)+1;\n\t\t}else{\n\t\t\tres += r-(p-sum+card[c].first)+1;\n\t\t}\n\t}\n\tsum += card[c].second-card[c].first;\n\tc++;\n\twhile(sum + card[c].second - card[c].first<= q){\n\t\tif(card[c].second <= r){\n\t\t\tres += card[c].second-card[c].first+1;\n\t\t}else if(card[c].first <= r){\n\t\t\tres += r-card[c].first+1;\n\t\t}\n\t\tsum += card[c].second-card[c].first;\n\t\tc++;\n\t}\n\n\tif(sum <= q){\n\t\tif(card[c].first+q-sum <= r){\n\t\t\tres += q-sum;\n\t\t}else if(card[c].first <= r){\n\t\t\tres += r-card[c].first+1;\n\t\t\tif(card[c].second <= r){\n\t\t\t\tres += card[c].second-r+1;\n\t\t\t}\n\t\t}\n\t}\n\tcout << res << endl;\n\t}\n}"
  },
  {
    "language": "C++",
    "code": "#include <cstdio>\n#include <cstring>\n#include <vector>\n#include <deque>\n#include <algorithm>\n\nusing namespace std;\n\ntypedef pair<int,int>P;\n\nint N;\ndeque<P>card;\n\nint main(){\n  while(scanf(\"%d\", &N) && N){\n    card.clear();\n    card.push_back(P(1,N));\n    int m,p,q,r;\n    scanf(\"%d%d%d%d\",&m,&p,&q,&r);\n    for(int i=0;i<m;i++){\n      int x,y; scanf(\"%d%d\",&x,&y);\n      deque<P>A,B,C;\n      int pos = 0;\n      while(pos <= x){\n\tif(pos + (card[0].second-card[0].first+1) > x){\n\t  A.push_back(P(card[0].first, card[0].first+x-pos-1));\n\t  card[0].first += x-pos;\n\t  pos = x+1;\n\t  break;\n\t}\n\tpos += card[0].second-card[0].first+1;\n\tA.push_back(card[0]);\n\tcard.pop_front();\n      }\n      while(pos <= y){\n\tif(pos + (card[0].second-card[0].first+1) > y){\n\t  B.push_back(P(card[0].first, card[0].first+y-pos));\n\t  card[0].first += y-pos+1;\n\t  pos = y+1;\n\t  break;\n\t}\n \tpos += card[0].second-card[0].first+1;\n\tB.push_back(card[0]);\n\tcard.pop_front();\n      }    \n      card.insert(card.end(), B.begin(), B.end());\n      card.insert(card.end(), A.begin(), A.end());\n    }\n    \n    //    for(int i=0;i<card.size();i++) printf(\"%d %d\\n\", card[i].first, card[i].second);\n    int pos = 1;\n    int res = 0;\n    for(int i=0;i<card.size();i++){\n      if(p <= pos && pos <= q){\n\t//\tprintf(\"%d 1\\n\", i);\n\tif(pos + card[i].second-card[i].first+1 < q){\n\t  if(card[i].first <= r && card[i].second <= r) res += card[i].second-card[i].first+1;\n\t  else if(card[i].first <= r) res += r-card[i].first+1;\n\t}else if(pos + card[i].second-card[i].first+1 >= q){\n\t  int vl = card[i].first, vr = card[i].first+q-pos;\n\t  //\t  printf(\"%d %d %d\\n\",pos, vl ,vr);\n\t  if(vl <= r && vr <= r) res += vr-vl+1;\n\t  else if(vl <= r) res += r-vl+1;\n\t}\n\t//\tprintf(\"%d\\n\", res);\n      }else if(pos + card[i].second-card[i].first+1 > p && pos <= q){\n\t//\tprintf(\"%d 2\\n\", i);\n\tint vl = card[i].first + p-pos;\n\t//\tprintf(\"vl %d\\n\", vl);\n\tif(pos + card[i].second-card[i].first+1 < q){\n\t  if(vl <= r && card[i].second <= r) res += card[i].second-vl+1;\n\t  else if(vl <= r) res += r - vl + 1;\n\t}else if(pos + card[i].second - card[i].first+ 1 >= q){\n\t  int vr = vl + q - pos;\n\t  if(vl <= r && vr <= r) res += vr-vl+1;\n\t  else if(vl <= r) res += r-vl+1;\n\t}\n\t//\tprintf(\"%d\\n\", res);\n      }\n      pos += card[i].second-card[i].first+1;\n    }\n    printf(\"%d\\n\", res);\n  }\n  return 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include<vector>\n#include<map>\n#include<set>\n#include<algorithm>\n#include<functional>\n#include<numeric>\n#include<utility>\n#include<sstream>\n#include<iostream>\n#include<iomanip>\n#include<cstdio>\n#include<cmath>\n#include<cstdlib>\n#include<cctype>\n#include<string>\n#include<cstring>\n#include<list>\nusing namespace std;\ntypedef vector<int>VI;\ntypedef vector<VI>VVI;\ntypedef vector<string>VS;\ntypedef pair<int,int>PII;\ntypedef long long LL;\n#define ALL(a) (a).begin(),(a).end()\n#define RALL(a) (a).rbegin(),(a).rend()\n#define PB push_back\n#define EACH(i,c) for(typeof((c).begin())i=(c).begin();i!=(c).end();i++)\n#define FOR(i,a,b) for(int i=(a);i<(b);++i)\n#define REP(i,n) FOR(i,0,n)\n\nstruct data{\n    int l,r;\n    data(int a,int b):l(a),r(b){}\n    data(){}\n};\n\nint N,M;\nint p,q,r;\nint x[5001],y[5001];\n\nint solve(){\n    list<data>L;\n    L.push_back(data(1,N));\n    x[M]=p-1,y[M]=q;\n    REP(i,M+1){\n        list<data>a,b,c;\n        int sum=0;\n        list<data>::iterator it=L.begin();\n        while(true){\n            data d=*it;\n            if(x[i]==0)break;\n            if(sum+(d.r-d.l+1)<=x[i]){\n                a.push_back(d);\n                L.pop_front();\n                it=L.begin();\n                sum+=(d.r-d.l+1);\n                if(sum==x[i])break;\n            }\n            else{\n                a.push_back(data(d.l,x[i]+d.l-1-sum));\n                //cout<<\"**** \"<<d.l<<\" \"<<x[i]+d.l-1-sum<<endl<<endl;\n                L.pop_front();\n                L.push_front(data(x[i]+d.l-sum,d.r));\n                it=L.begin();\n                break;\n            }\n        }\n        sum=x[i];\n        while(true){\n            data d=*it;\n            if(x[i]==y[i])break;\n            if(sum+(d.r-d.l+1)<=y[i]){\n                b.push_back(d);\n                L.pop_front();\n                it=L.begin();\n                sum+=(d.r-d.l+1);\n                if(sum==y[i])break;\n            }\n            else{\n                b.push_back(data(d.l,y[i]+d.l-1-sum));\n                L.pop_front();\n                L.push_front(data(y[i]-sum+d.l,d.r));\n                it=L.begin();\n                break;\n            }\n        }\n        if(i==M){\n            L=b;\n            break;\n        }\n        L.insert(L.end(),b.begin(),b.end());\n        L.insert(L.end(),a.begin(),a.end());\n        //cout<<endl;EACH(it,L)cout<<it->l<<\" \"<<it->r<<endl;\n    }\n    //cout<<endl;EACH(it,L)cout<<it->l<<\" \"<<it->r<<endl;\n    int cnt=0;\n    EACH(it,L){\n        int l=it->l,u=it->r;\n        if(l>r)continue;\n        if(u<=r)cnt+=u-l+1;\n        else{\n            cnt+=r-l+1;\n        }\n    }\n    return cnt;\n}\n\n\n\n\n\n\n\nint main(){\n    while(cin>>N,N){\n        cin>>M;\n        cin>>p>>q>>r;\n        REP(i,M)cin>>x[i]>>y[i];\n        cout<<solve()<<endl;\n    }\n    return 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include <cstdio>\n#include <vector>\n#include <map>\n#include <algorithm>\n#define fi first\n#define sec second\nusing namespace std;\ntypedef pair<int,int> P;\n\nint n, m, p, q, r;\nint ans;\nvector<P> v;\nvector<P>::iterator it;\n\nvoid solve(){\n\tans = 0;\n\tv.clear();\n\tv.push_back(P(1,n));\n\tscanf(\"%d%d%d%d\", &m, &p, &q, &r);\n\tint pst;\n\tfor(int i = 0; i < m; i++){\n\t\tint x, y; scanf(\"%d%d\", &x, &y);\n\t\tpst = 0;\n\t\tint cnt = 0;\n\t\tfor(it = v.begin(); it != v.end(); it++){\n\t\t\tcnt++;\n\t\t\tpst += (*it).sec-(*it).fi+1;\n\t\t\tif(pst < x) continue;\n\t\t\tif(pst == x){\n\t\t\t\tx = cnt-1;\n\t\t\t\tbreak;\n\t\t\t}\n\t\t\tint in = (*it).sec;\n\t\t\t(*it).sec = (*it).sec-(pst-x);\n\t\t\tv.insert(it+1,P((*it).sec+1,in));\n\t\t\tx = cnt-1;\n\t\t\tbreak;\n\t\t}\n\t\tpst = 0;\n\t\tcnt = 0;\n\t\t/*\n\t\tfor(int j = 0; j < v.size(); j++){\n\t\t\tprintf(\" %d %d\\n\", v[j].fi, v[j].sec);\n\t\t}\n\t\t*/\n\t\tfor(it = v.begin(); it != v.end(); it++){\n\t\t\tcnt++;\n\t\t\tpst += (*it).sec-(*it).fi+1;\n\t\t\tif(pst < y) continue;\n\t\t\tif(pst == y){\n\t\t\t\ty = cnt-1;\n\t\t\t\tbreak;\n\t\t\t}\n\t\t\tint in = (*it).sec;\n\t\t\t(*it).sec = (*it).sec-(pst-y);\n\t\t\tv.insert(it+1,P((*it).sec+1,in));\n\t\t\ty = cnt-1;\n\t\t\tbreak;\n\t\t}\n\t\tvector<P> tmp;\n\t\tfor(int j = y+1; j < v.size(); j++) tmp.push_back(v[j]);\n\t\tfor(int j = x+1; j <= y; j++) tmp.push_back(v[j]);\n\t\tfor(int j = 0; j <= x; j++) tmp.push_back(v[j]);\n\t\tv = tmp;\n\t\t/*\n\t\tprintf(\"\\n\");\n\t\tfor(int j = 0; j < v.size(); j++){\n\t\t\tprintf(\"%d %d\\n\", v[j].fi, v[j].sec);\n\t\t}\n\t\t*/\n\t}\n\t/*\n\tfor(int j = 0; j < v.size(); j++){\n\t\t\tprintf(\"%d %d\\n\", v[j].fi, v[j].sec);\n\t\t}*/\n\tpst = 0;\n\tfor(int i = 0; i < v.size(); i++){\n\t\tpst += v[i].sec-v[i].fi+1;\n\t\tint s = pst-(v[i].sec-v[i].fi), dif = 0;\n\t\tif(v[i].fi > r) continue;\n\t\tif(pst < p) continue;\n\t\tif(s > q) continue;\n\t\tif(s < p) dif = p-s;\n\t\tif(pst <= q){\n\t\t\tif(r >= v[i].sec) ans += v[i].sec-v[i].fi+1-dif;\n\t\t\telse ans += r-v[i].fi+1-dif;\n\t\t} else{\n\t\t\tif(r >= v[i].fi+q-s) ans += q-s+1-dif;\n\t\t\telse ans += r-v[i].fi+1-dif;\n\t\t}\n\t\t//printf(\"%d\\n\", ans);\n\t}\n\tprintf(\"%d\\n\", ans);\n}\n\nint main(){\n\twhile(scanf(\"%d\", &n),n) solve();\n}"
  },
  {
    "language": "C++",
    "code": "#include<iostream>\n#include<cstdio>\n#include<vector>\n#include<algorithm>\nusing namespace std;\ntypedef pair<int,int> P;\nint main()\n{\n\twhile(true){\n\t\tint N,M;\n\t\tint PP,QQ,RR;\n\t\tint X[5000];\n\t\tint Y[5000];\n\t\tvector<P>now;\n\t\tscanf(\"%d\",&N);\n\t\tnow.push_back(P(1,N));\n\t\tif(N==0)break;\n\t\tscanf(\"%d%d%d%d\",&M,&PP,&QQ,&RR);\n\t\tfor(int i=0;i<M;i++){\n\t\t\tscanf(\"%d%d\",&X[i],&Y[i]);\n\t\t}\n\t\tfor(int i=0;i<M;i++){\n\t\t\tint XX,YY;\n\t\t\tint cou=0;\n\t\t\tfor(int j=0;j<now.size();j++){\n\t\t\t\tint cou1=cou+now[j].second;\n\t\t\t\tif(cou<=X[i]&&cou1>X[i])XX=j;\n\t\t\t\tif(cou<=Y[i]&&cou1>Y[i])YY=j;\n\t\t\t\tcou=cou1;\n\t\t\t}\n\t\t\tvector<P>now11,now12,now13;\n\t\t\tint cou2=0;\n\t\t\tif(XX!=YY){\n\t\t\t\tfor(int j=0;j<XX;j++){\n\t\t\t\t\tnow11.push_back(now[j]);\n\t\t\t\t\tcou2+=now[j].second;\n\t\t\t\t}\n\t\t\t\tif(X[i]!=cou2)now11.push_back(P(now[XX].first,X[i]-cou2));\n\t\t\t\tif(X[i]!=cou2+now[XX].second)now12.push_back(P(now[XX].first+(X[i]-cou2),cou2+now[XX].second-X[i]));\n\t\t\t\tcou2+=now[XX].second;\n\t\t\t\tfor(int j=XX+1;j<YY;j++){\n\t\t\t\t\tnow12.push_back(now[j]);\n\t\t\t\t\tcou2+=now[j].second;\n\t\t\t\t}\n\t\t\t\tif(Y[i]!=cou2)now12.push_back(P(now[YY].first,Y[i]-cou2));\n\t\t\t\tif(Y[i]!=cou2+now[YY].second)now13.push_back(P(now[YY].first+(Y[i]-cou2),cou2+now[YY].second-Y[i]));\n\t\t\t\tcou2+=now[YY].second;\n\t\t\t\tfor(int j=YY+1;j<now.size();j++){\n\t\t\t\t\tnow13.push_back(now[j]);\n\t\t\t\t\tcou2+=now[j].second;\n\t\t\t\t}\n\t\t\t}\n\t\t\telse{\n\t\t\t\tfor(int j=0;j<XX;j++){\n\t\t\t\t\tnow11.push_back(now[j]);\n\t\t\t\t\tcou2+=now[j].second;\n\t\t\t\t}\n\t\t\t\tif(X[i]!=cou2)now11.push_back(P(now[XX].first,X[i]-cou2));\n\t\t\t\tnow12.push_back(P(now[XX].first+(X[i]-cou2),Y[i]-X[i]));\n\t\t\t\tif(Y[i]!=cou2+now[XX].second)now13.push_back(P(now[YY].first+(Y[i]-cou2),cou2+now[YY].second-Y[i]));\n\t\t\t\tcou2+=now[YY].second;\n\t\t\t\tfor(int j=YY+1;j<now.size();j++){\n\t\t\t\t\tnow13.push_back(now[j]);\n\t\t\t\t\tcou2+=now[j].second;\n\t\t\t\t}\n\t\t\t}\n\t\t\tnow.clear();\n\t\t\tfor(int i=0;i<now13.size();i++){\n\t\t\t\tnow.push_back(now13[i]);\n\t\t\t}\n\t\t\tfor(int i=0;i<now12.size();i++){\n\t\t\t\tnow.push_back(now12[i]);\n\t\t\t}\n\t\t\tfor(int i=0;i<now11.size();i++){\n\t\t\t\tnow.push_back(now11[i]);\n\t\t\t}\n\t\t}\n\t\t//printf(\"%d\\n\",now.size());\n\t\tint ans=0;\n\t\tint cou11=1;\n\t\tfor(int i=0;i<now.size();i++){\n\t\t\tif(PP<=cou11&&cou11+now[i].second<=QQ){\n\t\t\t\tans+=min(now[i].second,max(0,RR-now[i].first+1));\n\t\t\t}\n\t\t\telse if(cou11+now[i].second<=QQ&&cou11+now[i].second>=PP){\n\t\t\t\tans+=min(now[i].second-(PP-cou11),max(0,RR-now[i].first-(PP-cou11)+1));\n\t\t\t}\n\t\t\telse if(PP<=cou11&&QQ>=cou11){\n\t\t\t\tans+=min(QQ-cou11+1,max(0,RR-now[i].first+1));\n\t\t\t}\n\t\t\tcou11+=now[i].second;\n\t\t}\n\t\tprintf(\"%d\\n\",ans);\n\t}\n}"
  },
  {
    "language": "C++",
    "code": "#include<iostream>\n#include<algorithm>\n#include<vector>\nusing namespace std;\nvector<pair<bool,pair<int,int> > >v;\nint n,m,p,q,r;\n\nvoid Vp(bool a,int b,int c){v.push_back(make_pair(a,make_pair(b,c)));}\n\nint main(){\n\twhile(cin>>n&&n){\n\tcin>>m>>p>>q>>r;v.clear();\n\tVp(1,1,r);Vp(0,r+1,n);\n\twhile(m--){\n\t\tint x,y;cin>>x>>y;\n\t\tfor(int i=0;i<v.size();i++){\n\t\t\tint a=v[i].second.first,b=v[i].second.second;bool c=v[i].first;\n\t\t\tif(a<=x&&x<b){\n\t\t\t\tVp(c,x+1,b);\n\t\t\t\tb=x;\n\t\t\t}\n\t\t\tif(a<=y&&y<b){\n\t\t\t\tVp(c,y+1,b);\n\t\t\t\tb=y;\n\t\t\t}\n\t\t\tif(0<a&&b<=x)a+=n-x,b+=n-x;\n\t\t\telse if(x<a&&b<=y)a+=n-x-y,b+=n-x-y;\n\t\t\telse if(y<a&&b<=n)a-=y,b-=y;\n\t\t\tv[i].second.first=a,v[i].second.second=b;\n\t\t}\n\t}\n\tint ans=0;\n\tfor(int i=0;i<v.size();i++){\n\t\tif(v[i].first){\n\t\t\tans+=max(0,1+min(v[i].second.second,q)-max(v[i].second.first,p));\n\t\t}\n\t}\n\tcout<<ans<<endl;\n\t}\n\treturn 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include <iostream>\n#include<algorithm>\n#include<vector>\nusing namespace std;\nmain(){\n\tint n,m,p,q,r,x,y;\n\tvector<int>::iterator v,w,z;\n\tfor(;cin>>n>>m>>p>>q>>r;cout<<x<<endl){\n\tvector<int>t(1),u;\n\n\tfor(t.push_back(r);m--;u.clear()){\n\t\tcin>>x>>y;\n\t\tv=upper_bound(t.begin(),t.end(),x);\n\t\tw=upper_bound(t.begin(),t.end(),y);\n\n\t\tu.insert(u.end(),w-t.begin()&1?1:2,0);\n\t\tfor(z=w;z<t.end();++z)\n\t\t\tu.push_back(*z-y);\n\t\t\t\n\t\t\tif(t.end()-v&1)u.push_back(n-y);\n\t\t\tfor(z=v;z<w;++z)\n\t\t\t\tu.push_back(*z-x+n-y);\n\t\t\t\n\t\t\tz=t.begin();\n\t\t\tif(w-t.begin()&1)++z;\n\t\t\tif(!z[1])z+=2;\n\t\t\tif(*z+n-x==u.back())++z,u.pop_back();\n\t\t\tfor(;z<v;++z)\n\t\t\t\tu.push_back(*z+n-x);\n\t\t\t\n\t\t\tt.swap(u);\n\t\t}\n\t\tt.insert(upper_bound(t.begin(),t.end(),p-1),2,p-1);\n\t\tt.insert(lower_bound(t.begin(),t.end(),q),q);\n\t\tt.push_back(n);\n\t\tz=upper_bound(t.begin(),t.end(),p-1);\n\t\tif(z-t.begin()&1)--z;\n\t\tfor(x=0;*z<q;\n\t\t\tx+=*z-m,++z)\n\t\t\tm=*++z;\n\t}\n}"
  },
  {
    "language": "C++",
    "code": "#include<iostream>\n#include<algorithm>\n#include<vector>\nusing namespace std;\n\nstruct Group{  //aからbまでのトランプカード郡。最初のカードは上からc枚目\n\tint a;\n\tint b;\n\tint c;\n\tint d;\n};\n\nGroup make_G(int a,int b,int c,int d){\n\tGroup ret;\n\tret.a=a; ret.b=b; ret.c=c; ret.d=d;\n\treturn ret;\n}\n\nint main(){\nwhile(1){\n\tint n,m,x,y,p,q,r;\n\tvector<Group> CG;\n\tscanf(\"%d\",&n); if(n==0)break; scanf(\"%d\",&m);\n\tscanf(\"%d%d%d\",&p,&q,&r);\n\tCG.push_back(make_G(1,n,1,n));\n\tfor(int i=0;i<m;i++){\n\t\tscanf(\"%d%d\",&x,&y);\n\t\tint s=CG.size();\n\t\tfor(int j=0;j<s;j++){\n\t\t\tGroup g=CG[j];\n\t\t\tif(g.c<=x&&g.d>x){\n\t\t\t\tCG.push_back(make_G(g.a,g.a+x-g.c,n-x+g.c,n));\n\t\t\t\tg.a+=x-g.c+1;\n\t\t\t\tg.c+=x-g.c+1;\n\t\t\t}\n\t\t\tif(g.c<=y&&g.d>y){\n\t\t\t\tCG.push_back(make_G(y+1-g.d+g.b,g.b,1,g.d-y));\n\t\t\t\tg.b-=g.d-y;\n\t\t\t\tg.d-=g.d-y;\n\t\t\t}\n\t\t\tif(g.d<=x)g.c+=n-x;\n\t\t\telse if(g.d<=y)g.c+=n-y-x;\n\t\t\telse g.c-=y;\n\t\t\tCG[j].a=g.a; CG[j].b=g.b; CG[j].c=g.c; CG[j].d=CG[j].c-CG[j].a+CG[j].b;\n\t\t}\n\t\ts=CG.size();\n\t\tfor(int j=0;j<s;j++){\n\t\t\tGroup g=CG[j];\n\t\t\t//cout<<g.a<<\" \"<<g.b<<\" \"<<g.c<<\" \"<<g.d<<endl;\n\t\t}\n\t}\n\tint s=CG.size(),sum=0;\n\tfor(int i=0;i<s;i++){\n\t\tGroup g=CG[i];\n\t\t//cout<<g.a<<g.b<<g.c<<endl;\n\t\tint b=g.c,e=min(g.d,g.c+r-g.a);\n\t\tsum+=max(min(q,e)-max(p,b)+1,0);\n\t}\n\tprintf(\"%d\\n\",sum);\n}\n}"
  },
  {
    "language": "C++",
    "code": "#include <iostream>\n#include <algorithm>\n#include <vector>\nusing namespace std;\nint main(){\n\tint n,m,p,q,r,x,y;\n\tvector<int>::iterator itx,ity,it;\n\tfor(;cin>>n>>m>>p>>q>>r;cout<<x<<endl){\n\t\tvector<int> v1(1),v2;\n\t\t\n\t\tfor(v1.push_back(r);m--;v2.clear()){\n\t\t\tcin>>x>>y;\n\t\t\titx=upper_bound(v1.begin(),v1.end(),x);\n\t\t\tity=upper_bound(v1.begin(),v1.end(),y);\n\t\t\t\n\t\t\tif( ity-v1.begin()+1 & 1 )v2.push_back(0);\n\t\t\tv2.push_back(0);\n//\t\t\tv2.insert(v2.end(),ity-v1.begin()&1?1:2,0);\n\t\t\tfor(it=ity;it!=v1.end();++it)\n\t\t\t\tv2.push_back(*it - y);\n\t\t\t\n\t\t\tif(v1.end()-itx & 1)v2.push_back(n-y);\n\t\t\tfor(it=itx;it!=ity;++it)\n\t\t\t\tv2.push_back(*it-x+n-y);\n\t\t\t\n\t\t\tit = v1.begin();\n\t\t\tif(ity-v1.begin() & 1)++it;\n\t\t\tif(!it[1])it+=2;\n\t\t\tif(*it+n-x==v2.back())++it,v2.pop_back();\n\t\t\tfor(;it!=itx;++it)\n\t\t\t\tv2.push_back(*it+n-x);\n\t\t\t\n\t\t\tv1.swap(v2);\n\t\t}\n\t\tv1.insert( upper_bound(v1.begin(),v1.end(),p-1), 2, p-1);\n\t\tv1.insert( lower_bound(v1.begin(),v1.end(),q), q );\n\t\tv1.push_back(n);\n\t\tit = upper_bound(v1.begin(),v1.end(),p-1);\n\t\tif(it-v1.begin() & 1) --it;\n\t\tfor(x=0;*it<q;++it){\n\t\t\tm=*it,++it,\n\t\t\tx+=*it-m;\n\t\t}\n\t}\n}"
  },
  {
    "language": "C++",
    "code": "#include<bits/stdc++.h>\nusing namespace std;\n#define h first\n#define w second\nvector<pair<bool,pair<int,int> > >v;\nint n,m,p,q,r,i;\nvoid Vp(bool a,int b,int c){v.push_back(make_pair(a,make_pair(b,c)));}\nint main(){\n\twhile(cin>>n&&n){\n\tcin>>m>>p>>q>>r;v.clear();\n\tVp(1,1,r);Vp(0,r+1,n);\n\twhile(m--){\n\t\tint x,y;cin>>x>>y;\n\t\tfor(i=0;i<v.size();i++){\n\t\t\tint a=v[i].w.h,b=v[i].w.w;bool c=v[i].h;\n\t\t\tif(a<=x&&x<b){Vp(c,x+1,b);b=x;}\n\t\t\tif(a<=y&&y<b){Vp(c,y+1,b);b=y;}\n\t\t\tif(0<a&&b<=x)a+=n-x,b+=n-x;\n\t\t\telse if(x<a&&b<=y)a+=n-x-y,b+=n-x-y;\n\t\t\telse if(y<a&&b<=n)a-=y,b-=y;\n\t\t\tv[i].w.h=a,v[i].w.w=b;\n\t\t}\n\t}n=0;\n\tfor(i=0;i<v.size();i++)if(v[i].h)n+=max(0,1+min(v[i].w.w,q)-max(v[i].w.h,p));\n\tcout<<n<<endl;\n\t}\n\treturn 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include <iostream>\n#include<algorithm>\n#include<vector>\nusing namespace std;\nmain(){\n\tint n,m,p,q,r,x,y;\n\tvector<int>::iterator v,w,z;\n\tfor(;cin>>n>>m>>p>>q>>r;cout<<x<<endl){\n\tvector<int>t(1),u;\n\n\tfor(t.push_back(r);m--;u.clear()){\n\t\tcin>>x>>y;\n\t\tv=upper_bound(t.begin(),t.end(),x);\n\t\tw=upper_bound(t.begin(),t.end(),y);\n\n\t\tu.insert(u.end(),w-t.begin()&1?1:2,0);\n\t\tfor(z=w;z<t.end();++z)\n\t\t\tu.push_back(*z-y);\n\t\t\t\n\t\t\tif(t.end()-v&1)u.push_back(n-y);\n\t\t\tfor(z=v;z<w;++z)\n\t\t\t\tu.push_back(*z-x+n-y);\n\t\t\t\n\t\t\tz=t.begin();\n\t\t\tif(w-t.begin()&1)++z;\n\t\t\tif(!z[1])z+=2;\n\t\t\tif(*z+n-x==u.back())++z,u.pop_back();\n\t\t\tfor(;z<v;++z)\n\t\t\t\tu.push_back(*z+n-x);\n\t\t\t\n\t\t\tt.swap(u);\n\t\t}\n\t\tt.insert(upper_bound(t.begin(),t.end(),p-1),2,p-1);\n\t\tt.insert(lower_bound(t.begin(),t.end(),q),q);\n\t\tt.push_back(n);\n\t\tz=upper_bound(t.begin(),t.end(),p-1);\n\t\tif(z-t.begin()&1)--z;\n\t\tfor(x=0;*z<q;\n\t\t\tx+=*++z-m,++z)\n\t\t\tm=*z;\n\t}\n}"
  },
  {
    "language": "C++",
    "code": "#include<iostream>\n#include<map>\n#include<queue>\nusing namespace std;\ntypedef pair<int,int> P;\n#define fr first\n#define sc second\n#define rep(i,n) for(int i = 0 ; i < n ; ++i )\n\nint n,m,p,q,r;int a;\ndeque<P> card;\n\nint query(){\n  int sum = 0,ans = 0;\n  while(sum + card.front().sc - card.front().fr + 1 < p){\n    sum += card.front().sc - card.front().fr + 1;\n    card.pop_front();\n  }\n  if(sum + 1 != p) card.front().fr = card.front().fr + p - sum;\n  sum = p;\n  while(sum + card.front().sc - card.front().fr + 1 <= q){\n    if(card.front().sc <= r){ //完全に含む\n      ans += card.front().sc - card.front().fr + 1;\n    }else if(card.front().fr <= r){ //微妙に含む\n      ans += r - card.front().fr + 1;\n    }\n    sum += card.front().sc - card.front().fr + 1;\n    card.pop_front();\n  }\n  if(!card.empty() && sum != q){\n    card.push_front(P(card.front().fr,card.front().fr+q-sum-1));\n    if(card.front().sc <= r){ //完全に含む\n      ans += card.front().sc - card.front().fr + 1;\n    }else if(card.front().fr <= r){ //微妙に含む\n      ans += r - card.front().fr + 1;\n    }\n  }\n  return ans;\n}\n\nvoid deb(deque<P>& tmp){\n  cout << endl;\n  for(deque<P>::iterator it = tmp.begin();it!=tmp.end();it++){\n    cout << (*it).fr << \" \" << (*it).sc << endl;\n  }\n}\nvoid shuffle(int x,int y){\n  deque<P> A;\n  int sum = 0;\n  while(sum + card.front().sc - card.front().fr + 1 <= x){\n    A.push_back(card.front());\n    sum += card.front().sc - card.front().fr + 1;\n    card.pop_front();\n  }\n\n  if(sum != x){\n    A.push_back(P(card.front().fr,card.front().fr + x - sum - 1));\n    card.front().fr = card.front().fr + x - sum;\n    sum = x;\n  }\n  while(sum + card.front().sc - card.front().fr + 1 <= y){\n    card.push_back(card.front());\n    sum += card.front().sc - card.front().fr + 1;\n    card.pop_front();\n  }\n  if(sum != y){\n    card.push_back(P(card.front().fr,card.front().fr + y - sum - 1));\n    card.front().fr = card.front().fr + y - sum;\n    sum = y;\n  }\n  card.insert(card.end(),A.begin(),A.end());\n}\n\nint main(){\n  while(cin >> n , n){\n    cin >> m >> p >> q >> r;\n    p--;\n    card.push_back(P(1,n));\n    while(m--){\n      int x,y;\n      cin >> x >> y;\n      shuffle(x,y);\n    }\n    cout << query() << endl;\n    card.clear();\n  }\n}"
  },
  {
    "language": "C++",
    "code": "#include<bits/stdc++.h>\nusing namespace std;\n\nint solve();\n\nint N,M,P,Q,R;\nint X[5010],Y[5010];\n\nint main()\n{\n    while(scanf(\"%d\",&N),N)\n    {\n        scanf(\"%d\",&M);\n        scanf(\"%d%d%d\",&P,&Q,&R);\n        for(int i = 0; i < M; i++)\n        {\n            scanf(\"%d%d\",&X[i],&Y[i]);\n        }\n        printf(\"%d\\n\",solve());\n    }\n}\n\nint solve()\n{\n    int ANS = 0;\n    vector<pair<int,int> > vec[5010];\n    vec[0].push_back(make_pair(1,R));\n    for(int i = 0; i < M; i++)\n    {\n        for(int j = 0; j < vec[i].size(); j++)\n        {\n            int l = vec[i][j].first,r = vec[i][j].second;\n            if(l <= X[i] && r <= X[i])\n            {\n                vec[i + 1].push_back(make_pair(l + N - X[i],r + N - X[i]));\n                continue;\n            }\n            if(l <= X[i] && X[i] < r && r <= Y[i])\n            {\n                vec[i + 1].push_back(make_pair(l + N - X[i],N));\n                vec[i + 1].push_back(make_pair(N - Y[i] + 1,r + N - X[i] - Y[i]));\n                continue;\n            }\n            if(X[i] < l && l <= Y[i] && X[i] < r && r <= Y[i])\n            {\n                vec[i + 1].push_back(make_pair(l + N - X[i] - Y[i],r + N - X[i] - Y[i]));\n                continue;\n            }\n            if(X[i] < l && l <= Y[i] && Y[i] < r)\n            {\n                vec[i + 1].push_back(make_pair(l + N - X[i] - Y[i],N - X[i]));\n                vec[i + 1].push_back(make_pair(1,r - Y[i]));\n                continue;\n            }\n            if(Y[i] < l && Y[i] < r)\n            {\n                vec[i + 1].push_back(make_pair(l - Y[i],r - Y[i]));\n                continue;\n            }\n            if(l <= X[i] && Y[i] < r)\n            {\n                vec[i + 1].push_back(make_pair(l + N - X[i],N));\n                vec[i + 1].push_back(make_pair(N - Y[i] + 1,N - X[i]));\n                vec[i + 1].push_back(make_pair(1,r - Y[i]));\n                continue;\n            }\n        }\n        sort(vec[i + 1].begin(),vec[i + 1].end());\n    }\n    for(int i = 0;i < vec[M].size(); i++)\n    {\n        int l = vec[M][i].first,r = vec[M][i].second;\n        int a = max(l,P),b = min(r,Q) + 1;\n        ANS += max(0,b - a);\n    }\n    return ANS;\n}"
  },
  {
    "language": "C++",
    "code": "#include <iostream>\n#include <vector>\n#include <algorithm>\n\nusing namespace std;\ntypedef pair<int, int> p;\n\nstruct range {\n    int start;\n    int end;\n};\n\nint main() {\n    while (true) {\n        int card_count, shuffle_count, l, r, x;\n        cin >> card_count;\n        if (card_count == 0)break;\n        \n        cin >> shuffle_count >> l >> r >> x;\n        vector<range> shuffle(shuffle_count);\n        for (int i = 0; i < shuffle_count; i++) {\n            cin >> shuffle[i].start >> shuffle[i].end;\n        }\n        reverse(shuffle.begin(), shuffle.end());\n\n        vector<range> card_group{{l, r}};\n        for (int i = 0; i < shuffle_count; i++) {\n            range current_shuffle = shuffle[i];\n            int left_cut = card_count - shuffle[i].end;\n            int right_cut = card_count - shuffle[i].start;\n\n            vector<range> after;\n            for (auto group:card_group) {\n                if (group.start <= left_cut && left_cut < group.end) {\n                    after.push_back({group.start, left_cut});\n                    group.start = left_cut + 1;\n                }\n                if (group.start <= right_cut && right_cut < group.end) {\n                    after.push_back({group.start, right_cut});\n                    group.start = right_cut + 1;\n                }\n                after.push_back({group.start, group.end});\n            }\n\n            for (auto &group:after) {\n                if (group.end <= left_cut) {\n                    group.start += current_shuffle.end;\n                    group.end += current_shuffle.end;\n                } else if (group.end <= right_cut) {\n                    group.start += current_shuffle.start + current_shuffle.end - card_count;\n                    group.end += current_shuffle.start + current_shuffle.end - card_count;\n                } else {\n                    group.start += current_shuffle.start - card_count;\n                    group.end += current_shuffle.start - card_count;\n                }\n            }\n\n            card_group = after;\n        }\n\n        int ret = 0;\n        for (auto group:card_group) {\n            if (group.start <= x)\n                ret += min(x, group.end) - group.start + 1;\n        }\n\n        cout << ret << endl;\n    }\n    return 0;\n}\n"
  },
  {
    "language": "C++",
    "code": "#include <iostream>\n#include <algorithm>\n#include <vector>\n\nusing namespace std;\ntypedef pair<int,int> pii;\n\nint N;\nint M;\nint P,Q,R;\n\nint main(){\n    while(cin>>N&&N){\n        int res=0;\n        cin>>M>>P>>Q>>R;\n        vector<pii> deck;\n        deck.push_back(pii(1,N));\n        int x,y;\n        for(int i=0;i<M;i++){\n            cin>>x>>y;\n            // xÌÓÆyÌÓðÁèµAVbt\n            int sumX=0;\n            int xPos,yPos;\n            // x+1ÚðÁè\n            x++;\n            for(int j=0;j<deck.size();j++){\n                if(sumX+deck[j].second-deck[j].first+1>=x){\n                    xPos=j;\n                    break;\n                }\n                sumX+=deck[j].second-deck[j].first+1;\n            }\n            int sumY=0;\n            // yÚðÁè\n            for(int j=0;j<deck.size();j++){\n                if(sumY+deck[j].second-deck[j].first+1>=y){\n                    yPos=j;\n                    break;\n                }\n                sumY+=deck[j].second-deck[j].first+1;\n            }\n            // x+1Ú©çy+1ÚÜÅÌÓðØèæèAVbt\n            // ¯¶æÔÉ¶Ý\n            if(xPos==yPos){\n                // »ÝÌæÔðRª\n                pii p1=pii(deck[xPos].first,deck[xPos].first+(x-sumX-2));\n                pii p2=pii(p1.second+1,deck[yPos].first+(y-sumY-1));\n                pii p3=pii(p2.second+1,deck[xPos].second);\n                deck.erase(deck.begin()+xPos);\n                if(p3.first<=p3.second)deck.insert(deck.begin()+xPos,p3);\n                if(p2.first<=p2.second)deck.insert(deck.begin()+xPos,p2);\n                if(p1.first<=p1.second)deck.insert(deck.begin()+xPos,p1);\n            }\n            // ÊÌæÔÉ¶Ý·éêÍA»ê¼êÌæÔ²ÆÉªðs¤\n            else{\n                // x\n                {\n                    pii p1=pii(deck[xPos].first,deck[xPos].first+(x-sumX-2));\n                    pii p2=pii(p1.second+1,deck[xPos].second);\n                    deck.erase(deck.begin()+xPos);\n                    if(p2.first<=p2.second)deck.insert(deck.begin()+xPos,p2);\n                    if(p1.first<=p1.second)deck.insert(deck.begin()+xPos,p1);\n                }\n                // y\n                {\n                    pii p1=pii(deck[yPos].first,deck[yPos].first+(y-sumY-1));\n                    pii p2=pii(p1.second+1,deck[yPos].second);\n                    deck.erase(deck.begin()+yPos);\n                    if(p2.first<=p2.second)deck.insert(deck.begin()+yPos,p2);\n                    if(p1.first<=p1.second)deck.insert(deck.begin()+yPos,p1);\n                }\n            }\n            // à¤êxxÆyÌêðTõµA©Â¯½çVbt\n            sumX=sumY=0;\n            for(int j=0;j<deck.size();j++){\n                if(sumX+deck[j].second-deck[j].first+1>=x){\n                    xPos=j;\n                    break;\n                }\n                sumX+=deck[j].second-deck[j].first+1;\n            }\n            for(int j=0;j<deck.size();j++){\n                if(sumY+deck[j].second-deck[j].first+1>=y){\n                    yPos=j;\n                    break;\n                }\n                sumY+=deck[j].second-deck[j].first+1;\n            }\n            // xpos©çyposÜÅÌÓð²«oµÄAVbt\n            vector<pii> cutPlace;\n            vector<pii> prv;\n            vector<pii> nxt;\n            for(int i=xPos;i<=yPos;i++)cutPlace.push_back(deck[i]);\n            for(int i=0;i<xPos;i++)prv.push_back(deck[i]);\n            for(int i=yPos+1;i<deck.size();i++)nxt.push_back(deck[i]);\n            deck.clear();\n            for(int i=0;i<nxt.size();i++)deck.push_back(nxt[i]);\n            for(int i=0;i<cutPlace.size();i++)deck.push_back(cutPlace[i]);\n            for(int i=0;i<prv.size();i++)deck.push_back(prv[i]);\n        }\n        // VbtI¹ãApÆqÌl©çAðð½·àÌðTõ\n        int sum=0;\n        bool isApP=false;\n        for(int i=0;i<deck.size();i++){\n            int cnt=deck[i].second-deck[i].first+1;\n            sum+=cnt;\n            if(sum<P)continue;\n            // ¡ñÌæÔÉñÂÆàÜÜêéê\n            if(sum-cnt<=P&&sum-cnt<=Q&&sum>=P&&sum>=Q){\n                int pPos=P-(sum-cnt)-1;\n                int pNum=pPos+deck[i].first;\n                int qPos=Q-(sum-cnt)-1;\n                int qNum=qPos+deck[i].first;\n                // pÌl©çrÈºÌàÌð¦ã°\n                if(pNum<=R)\n                    res+=max(0,min(-qNum+R+1,qNum-pNum+1));\n                break;\n            }\n            // ¡ñÌæÔÅßÄpª»ê½ê\n            else if(!isApP&&sum>=P){\n                isApP=true;\n                int pPos=P-(sum-cnt)-1;\n                int pNum=pPos+deck[i].first;\n                // pÌl©çrÈºÌàÌð¦ã°\n                if(pNum<=R)\n                    res+=max(0,min(-deck[i].first+R+1,deck[i].second-pNum+1));\n            }\n            // pªo»ÏÝÌê\n            else if(isApP){\n                // ¡ñQª»ê½çðµÄbreak\n                if(sum>=Q){\n                    int qPos=Q-(sum-cnt)-1;\n                    int qNum=qPos+deck[i].first;\n                    if(deck[i].first<=R){\n                        if(qNum>=R)res+=R;\n                        else res+=(qNum-deck[i].first+1);\n                    }\n                    break;\n                }\n                // æÔÌl·×ÄÉÎµÄvZ\n                else{\n                    if(deck[i].first<=R)\n                        res+=max(0,min(-deck[i].first+R+1,deck[i].second-deck[i].first+1));\n                }\n            }\n        }\n        cout<<res<<endl;\n}\nreturn 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include<bits/stdc++.h>\nusing namespace std;\nvector<int>vec;\nint n,m,p,q,r,a[10000],b[10000],h[10000],a1[10000],a2[10000];\nint main(){\n\tcin>>n>>m;\n\tcin>>p>>q>>r;vec.push_back(r);\n\tfor(int i=0;i<m;i++){\n\t\tcin>>a1[i]>>a2[i];vec.push_back(a1[i]);vec.push_back(a2[i]);\n\t}\n\tsort(vec.begin(),vec.end());\n\tfor(int i=0;i<vec.size();i++){a[i]=vec[i];h[i]=i;}\n\tfor(int i=0;i<m;i++){\n\t\tint pos1=lower_bound(vec.begin(),vec.end(),a1[i])-vec.begin();\n\t\tint pos2=lower_bound(vec.begin(),vec.end(),a2[i])-vec.end();\n\t\tfor(int j=0;j<vec.size();j++)b[j]=0;int J=0;\n\t\tfor(int j=pos2+1;j<vec.size();j++){b[J]=h[j];J++;}\n\t\tfor(int j=pos1+1;j<=pos2;j++){b[J]=h[j];J++;}\n\t\tfor(int j=0;j<=pos1;j++){b[J]=h[j];J++;}\n\t\tfor(int j=0;j<vec.size();j++){h[j]=b[j];}\n\t}\n\tint sum=0,cnt=0;r=lower_bound(vec.begin(),vec.end(),r)-vec.begin();\n\tfor(int i=0;i<vec.size();i++){\n\t\tcnt+=vec[h[i]];if(h[i]>=1)cnt-=vec[h[i-1]];\n\t}\n}"
  },
  {
    "language": "C++",
    "code": "#include<cstdio>\n#include<cstdlib>\n#include<cstring>\n#include<cmath>\n#include<iostream>\n#include<sstream>\n#include<utility>\n#include<map>\n#include<vector>\n#include<queue>\n#include<algorithm>\n#include<set>\nusing namespace std;\ntypedef long long ll;\n//typedef pair<int,int>P;\n#define INF 1000000009\n\ntypedef struct D{int s,e;}D;//(s,e]\n\nint N,M,P,Q,R,x,y,res;\n\nvoid Qmov(queue<D> &s,queue<D> &d,int len)\n{\n\tfor(int c=0;c<len&&!s.empty();)\n\t{\n\t\tD now=s.front();s.pop();\n\t\tif(c+(now.e-now.s)>len)\n\t\t{\n\t\t\tD rev={now.s+(len-c),now.e};\n\t\t\tnow.e=now.s+(len-c);\n\t\t\tqueue<D>tmp;\n\t\t\ttmp.push(rev);\n\t\t\tQmov(s,tmp,INF);\n\t\t\tQmov(tmp,s,INF);\n\t\t}\n\t\tc+=(now.e-now.s);\n\t\td.push(now);\n\t}\n}\n\n\nint main()\n{\n\tfor(;scanf(\"%d\",&N),N;)\n\t{\n\t\tqueue<D>q,A,B,C;\n\t\tD tmp={1,N+1};\n\t\tq.push(tmp);\n\t\tscanf(\"%d%d%d%d\",&M,&P,&Q,&R);\n\t\tfor(int i=0;i<M;i++)\n\t\t{\n\t\t\tscanf(\"%d%d\",&x,&y);\n\t\t\tQmov(q,A,x);\n\t\t\tQmov(q,B,y-x);\n\t\t\tQmov(q,C,INF);\n\t\t\tQmov(C,q,INF);\n\t\t\tQmov(B,q,INF);\n\t\t\tQmov(A,q,INF);\n\t\t}\n\t\tP--;Q--;res=0;\n\t\tfor(int i=0;i<=Q;)\n\t\t{\n\t\t\tD tmp=q.front();q.pop();\n\t\t\tint len=tmp.e-tmp.s;\n\t\t\tif(i+len<P||i>Q)\n\t\t\t{\n\t\t\t}\n\t\t\telse\n\t\t\t{\n\t\t\t\tint s=i>P?tmp.s:tmp.s+(P-i);\n\t\t\t\tint e=i+len<Q?tmp.e-1:tmp.s+(Q-i);\n\t\t\t\tif(s<=R)\n\t\t\t\t\tres+=min(R,e)-s+1;\n\t\t\t}\n\t\t\ti+=len;\n\t\t\t\n\t\t}\n\t\tprintf(\"%d\\n\",res);\n\t}\n}"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\nusing namespace std;\n \nusing VI = vector<int>;\nusing VVI = vector<VI>;\nusing PII = pair<int, int>;\nusing LL = long long;\nusing VL = vector<LL>;\nusing VVL = vector<VL>;\nusing PLL = pair<LL, LL>;\nusing VS = vector<string>;\n \n#define ALL(a)  begin((a)),end((a))\n#define RALL(a) (a).rbegin(), (a).rend()\n#define PB push_back\n#define EB emplace_back\n#define MP make_pair\n#define SZ(a) int((a).size())\n#define SORT(c) sort(ALL((c)))\n#define RSORT(c) sort(RALL((c)))\n#define UNIQ(c) (c).erase(unique(ALL((c))), end((c)))\n \n#define FOR(i,a,b) for(int i=(a);i<(b);++i)\n#define REP(i,n)  FOR(i,0,n)\n \n#define FF first\n#define SS second\ntemplate<class S, class T>\nistream& operator>>(istream& is, pair<S,T>& p){\n  return is >> p.FF >> p.SS;\n}\ntemplate<class S, class T>\nostream& operator<<(ostream& os, const pair<S,T>& p){\n  return os << p.FF << \" \" << p.SS;\n}\ntemplate<class T>\nvoid maxi(T& x, T y){\n  if(x < y) x = y;\n}\ntemplate<class T>\nvoid mini(T& x, T y){\n  if(x > y) x = y;\n}\n \n \nconst double EPS = 1e-10;\nconst double PI  = acos(-1.0);\nconst LL MOD = 1e9+7;\n \nint main(){\n  cin.tie(0);\n  ios_base::sync_with_stdio(false);\n \n  int N;\n  while(cin>>N, N){\n    int M;\n    cin >> M;\n    int P, Q, R;\n    cin >> P >> Q >> R;\n    --P;\n     \n    vector<PII> s[2];\n    int crt = 0, nxt = 1;\n    s[crt].PB(MP(0,R));\n    REP(i,M){\n      int a, b;\n      cin >> a >> b;\n      s[nxt].clear();\n\n      for(auto r: s[crt]){\n        int l1 = N - b;\n        int l2 = N - a;\n\n\t\tif(r.FF < a){\n\t\t  s[nxt].EB(l2 + r.FF, min(N, l2 + r.SS));\n\t\t}\n\t\tif(b < r.SS){\n\t\t  s[nxt].EB(max(0, r.FF-b), r.SS - b);\n\t\t}\n\t\tint lft = max(a, r.FF);\n\t\tint rht = min(b, r.SS);\n\t\tif(rht - lft > 0 && a <= lft && rht <= b){\n\t\t  s[nxt].EB(l1 + lft - a, l1 + rht - a);\n\t\t}\n      }\n      swap(crt, nxt);\n    }\n     \n    int ans = 0;\n    for(auto&& ra: s[crt]){\n\t  if(ra.SS <= P || Q <= ra.FF) continue;\n      int l = max(P, ra.FF);\n      int r = min(Q, ra.SS);\n\n\t  ans += max(0, r-l);\n    }\n    cout << ans << endl;\n  }\n \n  return 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include<cstdio>\n#include<list>\n#include<algorithm>\nusing namespace std;\nstruct S{int a,b;S(int a,int b):a(a),b(b){}};\ntypedef list<S>L;\ntypedef L::iterator I;\nvoid F(L&l,L&s,int x)\n{\n\tfor(I i=l.begin();i!=l.end();++i)\n\t{\n\t\tint c=i->b-i->a;\n\t\tif(x<=c)\n\t\t{\n\t\t\ts.assign(l.begin(),i);\n\t\t\ts.push_back(S(i->a,i->a+x));\n\t\t\tl.erase(l.begin(),i);\n\t\t\tif(c==x)l.erase(i);\n\t\t\telse i->a+=x;\n\t\t\tbreak;\n\t\t}\n\t\tx-=c;\n\t}\n}\nint main()\n{\n\tint n,m,p,q,r,x,y,a,b,c;\n\tL l,s,t;\n\twhile(scanf(\"%d%d%d%d%d\",&n,&m,&p,&q,&r),n)\n\t{\n\t\t--p,--q;\n\t\tl.assign(1,S(1,n+1));\n\t\twhile(m--)\n\t\t{\n\t\t\tscanf(\"%d%d\",&x,&y);\n\t\t\tF(l,s,x);\n\t\t\tF(l,t,y-x);\n\t\t\tl.insert(l.end(),t.begin(),t.end());\n\t\t\tl.insert(l.end(),s.begin(),s.end());\n\t\t}\n\t\tm=x=0;\n\t\tfor(I i=l.begin();i!=l.end();++i)\n\t\t{\n\t\t\tc=i->b-i->a;\n\t\t\tif(x+c-1<p||q<x);\n\t\t\telse\n\t\t\t{\n\t\t\t\ta=max(x,p);\n\t\t\t\tb=min(x+c-1,q);\n\t\t\t\tm+=max(0,min(b-a+1,r-i->a+1));\n\t\t\t}\n\t\t\tx+=c;\n\t\t}\n\t\tprintf(\"%d\\n\",m);\n\t}\n\treturn 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include<iostream>\nusing namespace std;\nint main() {\n\tlong long int size;\n\tlong long int *card;\n\tlong long int *dommy;\n\tlong long int search[3];\n\tlong long int shuffle[2];\n\tlong long int time;\n\twhile (cin >> size&&size) {\n\t\tcard = new long long int[size];\n\t\tfor (long long int i = 0; i < size; ++i) {\n\t\t\tcard[i] = i + 1;\n\t\t}\n\t\tcin >> time;\n\t\tfor (long long int i = 0; i < 3; ++i) {\n\t\t\tcin >> search[i];\n\t\t}\n\t\tfor (long long int i = 0; i < time; ++i) {\n\t\t\tfor (long long int j = 0; j < 2; ++j) {\n\t\t\t\tcin>>shuffle[j];\n\t\t\t}\n\t\t\tdommy = new long long int[size];\n\t\t\tfor (long long int j = shuffle[1]; j < size; ++j) {\n\t\t\t\tdommy[j - shuffle[1]] = card[j];\n\t\t\t}\n\t\t\tfor (long long int j = shuffle[0]; j < shuffle[1]; ++j) {\n\t\t\t\tdommy[size - shuffle[1] + j - shuffle[0]] = card[j];\n\t\t\t}\n\t\t\tfor (long long int j = 0; j < shuffle[0]; ++j) {\n\t\t\t\tdommy[size - shuffle[0] + j] = card[j];\n\t\t\t}\n\t\t\tcard = dommy;\n\t\t}\n\t\tlong long int answer = 0;\n\t\tfor (long long int i = search[0] - 1; i < search[1]; ++i) {\n\t\t\tif (card[i] <= search[2]) {\n\t\t\t\t++answer;\n\t\t\t}\n\t\t}\n\t\tcout << answer << endl;\n\t}\n\treturn 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include<iostream>\n#include<vector>\n#include<algorithm>\nusing namespace std;\nvector<pair<int, int>>vec;\nint n, m, l, r, p;\nint main() {\n\tcin >> n >> m; cin >> l >> r >> p;\n\tvec.push_back(make_pair(1, n));\n\tfor (int i = 0; i < m; i++) {\n\t\tint r1, r2; cin >> r1 >> r2;\n\t\tvector<pair<int, int>>A, B, C; int sum1 = 0, c = 0;\n\t\tfor (int j = 0; j < vec.size(); j++) {\n\t\t\tsum1 += (vec[j].second - vec[j].first + 1);\n\t\t\tbool H = false;\n\t\t\tif (sum1 > r2 && c == 0) {\n\t\t\t\tint Border1 = vec[j].second - (sum1 - r1);\n\t\t\t\tint Border2 = vec[j].second - (sum1 - r2);\n\t\t\t\tA.push_back(make_pair(vec[j].first, Border1));\n\t\t\t\tB.push_back(make_pair(Border1+1, Border2));\n\t\t\t\tC.push_back(make_pair(Border2 + 1, vec[j].second));\n\t\t\t\tc = 2; H = true;\n\t\t\t}\n\t\t\tif (sum1 > r1 && c == 0) {\n\t\t\t\tint Border = vec[j].second - (sum1 - r1);\n\t\t\t\tA.push_back(make_pair(vec[j].first, Border));\n\t\t\t\tB.push_back(make_pair(Border + 1, vec[j].second));\n\t\t\t\tc = 1; H = true;\n\t\t\t}\n\t\t\tif (sum1 > r2 && c == 1 && H == false) {\n\t\t\t\tint Border = vec[j].second - (sum1 - r2);\n\t\t\t\tB.push_back(make_pair(vec[j].first, Border));\n\t\t\t\tC.push_back(make_pair(Border + 1, vec[j].second));\n\t\t\t\tc = 2; H = true;\n\t\t\t}\n\t\t\tif (H == false) {\n\t\t\t\tif (c == 0) { A.push_back(make_pair(vec[j].first, vec[j].second)); }\n\t\t\t\tif (c == 1) { B.push_back(make_pair(vec[j].first, vec[j].second)); }\n\t\t\t\tif (c == 2) { C.push_back(make_pair(vec[j].first, vec[j].second)); }\n\t\t\t}\n\t\t}\n\t\tvec.clear();\n\t\tfor (int i = 0; i < C.size(); i++)vec.push_back(C[i]);\n\t\tfor (int i = 0; i < B.size(); i++)vec.push_back(B[i]);\n\t\tfor (int i = 0; i < A.size(); i++)vec.push_back(A[i]);\n\t}\n\tint sum2 = 0, sum3 = 0;\n\tfor (int i = 0; i < vec.size(); i++) {\n\t\tif (vec[i].first > vec[i].second)continue;\n\t\tint HB = (vec[i].second - vec[i].first + 1); sum2 += HB;\n\t\tint L1 = vec[i].first, R1 = vec[i].second;\n\t\tint L2 = 1, R2 = p;\n\t\tif (sum2 > r && sum2 - HB <= r) { R1 = vec[i].first + (r - (sum2 - HB)) - 1; }\n\t\tif (sum2 - HB < l && sum2 >= l) { L1 = vec[i].first + (l - (sum2 - HB)) - 1; }\n\t\tif (sum2 - HB > r)continue;\n\t\tif (sum2 < l)continue;\n\n\t\tint L3 = max(L1, L2), R3 = min(R1, R2);\n\t\tsum3 += max(0, R3 - L3 + 1);\n\t}\n\tcout << sum3 << endl;\n\treturn 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include <tuple>\n#include <vector>\n#include <iostream>\n#include <algorithm>\n\nusing namespace std;\n\nint n, m, p, q, c, r1, r2;\n\nvector<tuple<int, int, int> > dat;\n\ninline void divide(int pos)\n{\n\tvector<tuple<int, int, int> > dat1;\n\n\tfor (int i = 0; i < dat.size(); i++)\n\t{\n\t\tint l = get<0>(dat[i]);\n\t\tint r = get<1>(dat[i]);\n\t\tint t = get<2>(dat[i]);\n\n\t\tif (l < pos && pos < r)\n\t\t{\n\t\t\tdat1.push_back(make_tuple(l, pos, t));\n\t\t\tdat1.push_back(make_tuple(pos, r, t + pos - l));\n\t\t}\n\t\telse\n\t\t{\n\t\t\tdat1.push_back(make_tuple(l, r, t));\n\t\t}\n\t}\n\n\tdat = dat1;\n}\n\ninline void shuffle(int a, int b)\n{\n\tdivide(a);\n\tdivide(b);\n\n\tint l = lower_bound(dat.begin(), dat.end(), make_tuple(a, 0, 0)) - dat.begin();\n\tint r = lower_bound(dat.begin(), dat.end(), make_tuple(b, 0, 0)) - dat.begin();\n\tint u = dat.size();\n\n\tvector<tuple<int, int, int> > dat1;\n\n\tint pos = 0;\n\n\tfor (int i = r; i < u; i++)\n\t{\n\t\tdat1.push_back(make_tuple(pos, pos - get<0>(dat[i]) + get<1>(dat[i]), get<2>(dat[i]))); pos += get<1>(dat[i]) - get<0>(dat[i]);\n\t}\n\n\tfor (int i = l; i < r; i++)\n\t{\n\t\tdat1.push_back(make_tuple(pos, pos - get<0>(dat[i]) + get<1>(dat[i]), get<2>(dat[i]))); pos += get<1>(dat[i]) - get<0>(dat[i]);\n\t}\n\n\tfor (int i = 0; i < l; i++)\n\t{\n\t\tdat1.push_back(make_tuple(pos, pos - get<0>(dat[i]) + get<1>(dat[i]), get<2>(dat[i]))); pos += get<1>(dat[i]) - get<0>(dat[i]);\n\t}\n\n\tdat = dat1;\n}\n\nint main()\n{\n\twhile(true)\n\t{\n\t\tscanf(\"%d\", &n); if (n == 0) { break; }\n\t\tscanf(\"%d\", &m);\n\t\tscanf(\"%d\", &p); p--;\n\t\tscanf(\"%d\", &q); q--;\n\t\tscanf(\"%d\", &c);\n\n\t\tdat = { make_tuple(0, n, 1) };\n\n\t\tfor (int i = 0; i < m; i++)\n\t\t{\n\t\t\tscanf(\"%d\", &r1);\n\t\t\tscanf(\"%d\", &r2);\n\n\t\t\tshuffle(r1, r2);\n\t\t}\n\n\t\tint ret = 0;\n\n\t\tfor (int i = 0; i < dat.size(); i++)\n\t\t{\n\t\t\tint l = get<0>(dat[i]);\n\t\t\tint r = get<1>(dat[i]);\n\t\t\tint t = get<2>(dat[i]);\n\n\t\t\tif (p <= l && r <= q + 1)\n\t\t\t{\n\t\t\t\tret += min(max(c - t + 1, 0), r - l);\n\t\t\t}\n\t\t\telse if (p <= l && l <= q)\n\t\t\t{\n\t\t\t\tret += min(max(c - t + 1, 0), q - l + 1);\n\t\t\t}\n\t\t\telse if (p <= r && r <= q)\n\t\t\t{\n\t\t\t\tret += max(c - (t + (p - l)) + 1, 0);\n\t\t\t}\n\t\t}\n\n\t\tprintf(\"%d\\n\", ret);\n\t}\n\n\treturn 0;\n}"
  },
  {
    "language": "C++",
    "code": "#define _USE_MATH_DEFINES\n#define INF 0x3f3f3f3f\n\n#include <iostream>\n#include <cstdio>\n#include <sstream>\n#include <cmath>\n#include <cstdlib>\n#include <algorithm>\n#include <queue>\n#include <stack>\n#include <limits>\n#include <map>\n#include <string>\n#include <cstring>\n#include <set>\n#include <deque>\n#include <bitset>\n#include <list>\n#include <cctype>\n#include <utility>\n  \nusing namespace std;\n  \ntypedef long long ll;\ntypedef pair <int,int> P;\ntypedef pair <int,P> PP;\n  \nstatic const double EPS = 1e-8;\n  \nstatic const int tx[] = {0,1,0,-1};\nstatic const int ty[] = {-1,0,1,0};\n\nint main(){\n  int total_cards;\n  while(~scanf(\"%d\",&total_cards)){\n    if(total_cards == 0) break;\n    int total_shuffles;\n    int first,last,upper;\n\n    scanf(\"%d\",&total_shuffles);\n    scanf(\"%d %d %d\",&first,&last,&upper);\n    \n    vector<P> cards;\n    cards.push_back(P(1,total_cards));\n\n    for(int shuffle_idx=0;shuffle_idx<total_shuffles;shuffle_idx++){\n      int x,y;\n      scanf(\"%d %d\",&x,&y);\n      //x -> none\n      //y -> 1\n      //n -> x+1\n      //C -> B -> A\n      vector<P> A;\n      vector<P> B;\n      vector<P> C;\n      vector<P> next;\n\n      int sum = 0;\n      int prev_sum = 0;\n      for(int j=0;j<cards.size();j++){\n        prev_sum = sum;\n        sum += cards[j].second - cards[j].first + 1;\n        if(prev_sum < x){\n          if(sum <= x){\n            A.push_back(cards[j]);\n          }\n          else if(sum > x && sum <= y){\n            A.push_back(P(cards[j].first,cards[j].first + (x - prev_sum - 1)));\n            B.push_back(P(cards[j].first + (x - prev_sum),\n                          cards[j].second));\n          }\n          else if(sum > y){\n            A.push_back(P(cards[j].first,cards[j].first + (x - prev_sum - 1)));\n            B.push_back(P(cards[j].first + (x - prev_sum),\n                          cards[j].first + (x - prev_sum) + (y - x - 1)));\n            C.push_back(P(cards[j].first + (x - prev_sum) + (y - x),\n                          cards[j].second));\n          }\n        }\n        else if(prev_sum >= x){\n          if(prev_sum < y){\n            if(sum <= y){\n              B.push_back(P(cards[j].first,cards[j].second));\n            }\n            else if(sum > y){\n              B.push_back(P(cards[j].first,cards[j].first + (y - prev_sum - 1)));\n              C.push_back(P(cards[j].first + (y - prev_sum),cards[j].second));\n            }\n          }\n          else if(prev_sum >= y){\n            C.push_back(P(cards[j].first,cards[j].second));\n          }\n        }\n      }\n      for(int i=0;i<C.size();i++){\n        next.push_back(C[i]);\n        // cout << \"C<f,s>=\" << C[i].first << \",\" << C[i].second << endl;\n      }\n      for(int i=0;i<B.size();i++){\n        next.push_back(B[i]);\n        // cout << \"B<f,s>=\" << B[i].first << \",\" << B[i].second << endl;\n      }\n      for(int i=0;i<A.size();i++){\n        next.push_back(A[i]);\n        // cout << \"A<f,s>=\" << A[i].first << \",\" << A[i].second << endl;\n      }\n      // cout << endl;\n      cards = next;\n    }\n\n    int offset = 0;\n    int res = 0;\n    for(int i=0;i<cards.size();i++){\n      int current = cards[i].second - cards[i].first + 1;\n      if(offset + current < first){\n        offset += current;\n        continue;\n      }\n      if(offset > last){\n        offset += current;\n        continue;\n      }\n\n      int lhs = -1;\n      int rhs = 1000000010;\n\n      for(int round = 0; round < 50; round++){\n        int mid = (lhs + rhs) / 2;\n        if(cards[i].first + mid > upper){\n          rhs = mid;\n        }\n        if(cards[i].first + mid <= upper){\n          lhs = mid;\n        }\n      }\n\n      int count = min(lhs + 1,cards[i].second - cards[i].first + 1);\n\n      // cout << \"not considering last count: \" << count << endl;\n      \n      if(offset + count >= last){\n        count -= offset + count - last;\n      }\n\n      if(count > 0){\n        res += count;\n      }\n\n      // cout << \"offset \" << offset << endl;\n      // cout << \"<f,s>=\" << cards[i].first << \",\" << cards[i].second << endl;\n      // cout << \"count=\" << count << endl;\n\n      offset += current;\n    }\n    printf(\"%d\\n\",res);\n\n  }\n}"
  },
  {
    "language": "C++",
    "code": "#include<iostream>\n#include<vector>\n\n#define AMNT 4096\n\nusing namespace std;\n\ntypedef pair<int,int> range;\ntypedef vector< range > deck;\n\ninline int quant(const range &r){\n  return r.second-r.first+1;\n}\n\nint shuffle(int x, int y, deck &D, bool count = false, int r = 0){\n  int i = 0;\n  deck d1,d2,d3;\n  int cts[D.size()];\n  \n  for(int i = 0; i < D.size(); ++i){\n    cts[i] = (i==0?0:cts[i-1]) + (D[i].second-D[i].first)+1;\n  }\n\n  d1.reserve(AMNT);\n  d2.reserve(AMNT);\n  d3.reserve(AMNT);\n\n  // part I\n  int precnt=0, cnt=0;\n  for(i; i < D.size(); ++i){\n    range R=D[i];\n    cnt += quant( R );\n    if( cnt >= x ){\n      d1.push_back( range( R.first, R.first + (x-precnt) - 1 ) );\n      break;\n    }else{\n      d1.push_back( R );\n    }\n    precnt = cnt;\n  }\n  i=max(i-1,0);\n  precnt=i<=1?0:cts[i-2];\n  cnt=i<=0?0:cts[i-1];\n  \n  // part II\n  bool first=true;\n  for(i; i < D.size(); ++i){\n    range R = D[i];\n    cnt += quant( R );\n    if( precnt <= x && precnt <= y && cnt > x && cnt > y ){\n      d2.push_back( range( R.first + (x-precnt), R.first + (y-precnt) - 1 )  );\n      break;\n    }else if( cnt >= x && first ){\n      d2.push_back( range( R.first + (x-precnt), R.second ) );\n      first = false;\n    }else if( cnt >= x && cnt < y  ){\n      d2.push_back( R );\n    }else if( cnt >= y ){\n      d2.push_back( range( R.first, R.first + (y-precnt) - 1 ) );\n      break;\n    }\n    precnt = cnt;\n  }\n  i=max(i-1,0);\n  precnt=i<=1?0:cts[i-2];\n  cnt=i<=0?0:cts[i-1];\n  \n  // part III\n  first=true;\n  for(i;i<D.size();++i){\n    range R = D[i];\n    cnt += quant( R );\n    if( cnt > y && first ){\n      d3.push_back( range( R.first + (y-precnt), R.second ) );\n      first=false;\n    }else if( !first ){\n      d3.push_back( R );\n    }\n    precnt = cnt;\n  }\n\n/*\n  cout << \"D1\" << endl;\n  for(deck::iterator itd=d1.begin();itd!=d1.end();++itd){\n    cout << '(' << itd->first << \" - \" << itd->second << ')' << endl;\n  }cout << \"D2\" << endl;\n  for(deck::iterator itd=d2.begin();itd!=d2.end();++itd){\n    cout << '(' << itd->first << \" - \" << itd->second << ')' << endl;\n  }cout << \"D3\" << endl;\n  for(deck::iterator itd=d3.begin();itd!=d3.end();++itd){\n    cout << '(' << itd->first << \" - \" << itd->second << ')' << endl;\n  }\n  cout << endl;\n*/\n\n  if( count ){\n    int ret = 0;\n    if( d1.back().second <= r ) ++ret;\n    for(i = 0; i < d2.size(); ++i){\n      range R = d2[i];\n      //cout << R.first << ' ' << R.second << endl;\n      if( R.first <= r ){\n\tret += ( min(R.second,r) - R.first + 1);\n      }\n    }\n    return ret;\n  }\n\n\n  int ni = 0;\n  //  D.clear();\n  D.resize( d1.size() + d2.size() + d3.size() );\n  for(i = 0; i < d3.size(); ++i){ D[i] = d3[i]; } ni = d3.size();\n  for(i = ni; i < ni+d2.size(); ++i){ D[i] = d2[i - ni]; } ni = d3.size() + d2.size();\n  for(i = ni; i < ni+d1.size(); ++i){ D[i] = d1[i - ni]; }\n\n  return 0;\n}\n\nint main()\n{\n  while(true){\n    int n,m,p,q,r;\n    deck D;\n    scanf(\"%d\",&n);\n    if( n == 0 ) break;\n    scanf(\"%d%d%d%d\", &m, &p, &q, &r);\n    D.push_back( range(1,n) );\n    for(int i = 0; i < m; ++i){\n      int x,y;\n      scanf(\"%d%d\", &x, &y);\n      shuffle( x, y, D );\n      // compress\n      //CompressDeck( D );\n      /*\n      for(deck::iterator itd=D.begin();itd!=D.end();++itd){\n\tcout << '(' << itd->first << \" - \" << itd->second << ')' << endl;\n      }\n      cout << endl;\n      */\n    }\n    printf(\"%d\\n\", shuffle( p, q, D, true, r ));\n  }\n  return 0;\n}"
  },
  {
    "language": "C++",
    "code": "\n#include<iostream>\nusing namespace std;\nint cards,n,i,p,q,r,x[5000],y[5000],counter;\n  int numberStart[10001];\n  int numberFast[10001];\n  int numberEnd[10001];\n  int searchB[10001];\nint numberLong(int value){\n\treturn numberEnd[value]-numberStart[value]+1;\n}\n\n\nint searchD(int seed){\n\t\tint l=0;\n  for (int a=1;a<=counter+1;a++){\n\tif(seed>l+numberLong(searchB[a])){\n\tl+=numberLong(searchB[a]);\n\t}\n\telse{\n\t return numberFast[searchB[a]];\n\t}\n  }\n return -100;\n\t\n}\nint searchNumber(int value){\n\tint l=0;\n  for (int a=1;a<=counter+1;a++){\n\tif(value>l+numberLong(searchB[a])){\n\tl+=numberLong(searchB[a]);\n\t}\n\telse{\n\t return numberStart[searchB[a]]+value-l-1;\n\t}\n  }\n return -100;\n}\n\nvoid cut(int g){\n\tif(searchD(g)==searchD(g+1)){\n  //カットする場所が入ってる数列を求める\n\tint\tsearchNumberG=searchNumber(g);\n  int seachX=searchB[searchD(g)];\n  int seachXX=searchNumberG;\n//数列ができる範囲の後ろの番号FASTを変える\n     for(int j=1;j<=counter;j++){\n      if (numberFast[j]>=numberFast[seachX]+1){\n      numberFast[j]++;\n     }\n    }\n\n  //の数列の後ろに新しい数列を作る\n counter++;\n  numberFast[counter]=numberFast[seachX]+1;\n  numberStart[counter] =searchNumberG+1;\n  numberEnd[counter]=numberEnd[seachX];\n  //できた数列の前の数列の最後を調整する\n  numberEnd[seachX]=searchNumberG;\n \n\n  \n  for ( int a=1;a<=counter+1;a++){\n\t  searchB[numberFast[a]]=a;\n    }\n    }\n\n}\nvoid shuffle(int x,int y){\n\t\n\tint StartHead[10001];\n\tint  numberFastNew[10001];\n\t\n\tint longs=1;\n\tfor (int i=1;i<=counter;i++){\n\t\tStartHead[searchB[i]]=longs;\n\t\tlongs+=numberLong(searchB[i]);\n\t}\n\tint newCounter[3];\n\tfor(int i=0;i<3;i++){\n\t\tnewCounter[i]=0;\n\t}\n\tfor(int j=1;j<=counter;j++){\n\t\tif (StartHead[j]>y){\n\t\t\tnewCounter[0]++;\n\t\tnumberFastNew[j]=0;\n\t\t}\n\t\tif (StartHead[j]>x && StartHead[j]+numberLong(j)-1<=y){\n\t\t\tnewCounter[1]++;\n\t\tnumberFastNew[j]=1;\n\t\t}\n\t\tif (StartHead[j]+numberLong(j)-1<=x){\n\t\t\tnewCounter[2]++;\n\t\tnumberFastNew[j]=2;\n\t\t}\n\t}\n\t\n\tfor(int j=1;j<=counter;j++){\n\t\tswitch(numberFastNew[j]){\n\t\t\tcase 0:\n\t\t\t\tnumberFast[j]+=-newCounter[1]-newCounter[2];\n\t\t\t\tbreak;\n\t\t\tcase 1:\n\t\t\t\tnumberFast[j]+=newCounter[0]-newCounter[2];\n\t\t\t\tbreak;\n\t\t\tcase 2:\n\t\t\t\tnumberFast[j]+=newCounter[1]+newCounter[0];\n\t\t\t\tbreak;\n\t\t}\n\n\t}\n\t  for ( int a=1;a<=counter+1;a++){\n\t  searchB[numberFast[a]]=a;\n    }\n\n}\n\n\nint main(void)\n{\n\twhile(true){\n\tcards=0;\n\tn=0;\n\tcounter=0;\n\tfor (int i=0;i<10001;i++){\n   numberStart[i]=0;\n   numberFast[i]=0;\n   numberEnd[i]=0;\n   searchB[i]=0;\n\t}\n\tint points=0;\n  counter=1;\n  cin >> cards;\n  if (cards==0){\n\t  break;\n  }\n  numberStart[1]=1;\n  numberEnd[1]=cards;\n  numberFast[1]=1;\n  searchB[1]=1;\n  cin >> n;\n  cin >> p  >> q  >> r ;\n  for (i=1;i<=n;i++){\n    cin >> x[i] >> y[i];\n  }\n  for (i=1;i<=n;i++){\n     cut(x[i]);\n\t \n      cut(y[i]);\n\t  \n     shuffle(x[i],y[i]);\n  }\n  cut(p);\n  cut(q);\n  /*\n  for(int j=p;j<=q;j++){\n\t  if(searchNumber(j)<=r){\n\t\t  points++;\n\t  }\n  }\n  */\n  \n \n  for(int j=1;j<=counter;j++){\n  if(numberEnd[j]<=r && searchD(p)<= numberFast[j] && numberFast[j] <= searchD(q)){\n\t  points+=numberLong(j);\n  }\n  else if(numberStart[j]<=r && searchD(p)<= numberFast[j] && numberFast[j] <= searchD(q))\n  {\n\t  points+=numberLong(j)-(numberEnd[j]-r);\n  }\n  }\n  cout << points << endl;\n\t}\n}"
  },
  {
    "language": "C++",
    "code": "#include <cstdio>\n#include <cstring>\n#include <cmath>\n#include <vector>\n#include <list>\n#include <string>\n#include <set>\n#include <map>\n#include <queue>\n#include <stack>\n#include <algorithm>\n#include <iostream>\n#include <sstream>\nusing namespace std;\n\ntypedef long long int64;\nconst int inf = (int)1e9;\n\npair<int, int> findpos(vector<pair<int, int> > &s, int x)\n{\n\tint total = 0;\n\t\n\tfor(int i = 0; i < s.size(); ++i) {\n\t\t\n\t\tif(x < total + s[i].first)\n\t\t\treturn make_pair(i, x - total);\n\t\t\n\t\ttotal += s[i].first;\n\t}\n\t\n\treturn make_pair(s.size(), 0);\n}\n\nvoid copy(vector<pair<int, int> > &s, vector<pair<int, int> > &t, int l, int r)\n{\n\tpair<int, int> lp, rp;\n\tlp = findpos(s, l);\t\n\trp = findpos(s, r);\n\t\n\tint lidx = lp.first, ridx = rp.first, lpos = lp.second, rpos = rp.second;\n\t\n\tif(lidx == ridx) {\n\t\tt.push_back(make_pair(rpos - lpos, s[lidx].second + lpos));\n\t\treturn;\n\t}\n\t\n\tt.push_back(make_pair(s[lidx].first - lpos, s[lidx].second + lpos));\n\tfor(int i = lidx + 1; i < ridx; ++i)\n\t\tt.push_back(s[i]);\n\tt.push_back(make_pair(rpos, s[ridx].second));\n\t\n\treturn;\n}\n\nvoid shuffle(vector<pair<int, int> > &s, vector<pair<int, int> > &t, int x, int y, int n)\n{\n\tt.clear();\n\t\n\tcopy(s, t, y, n);\n\tcopy(s, t, x, y);\n\tcopy(s, t, 0, x);\n\t\n\treturn;\n}\n\nint countnum(vector<pair<int, int> > &s, int l, int r, int x)\n{\n\tint total = 0;\n\tpair<int, int> lp, rp;\n\tlp = findpos(s, l);\t\n\trp = findpos(s, r);\n\t\n\tint lidx = lp.first, ridx = rp.first, lpos = lp.second, rpos = rp.second;\n\t\n\tif(lidx == ridx) {\n\t\ttotal += max(min(x, (s[ridx].second + rpos)) - (s[lidx].second + lpos), 0);\n\t\treturn total;\n\t}\n\t\n\ttotal += max(min(x, s[lidx].second + s[lidx].first) - (s[lidx].second + lpos), 0);\n\tfor(int i = lidx + 1; i < ridx; ++i)\n\t\ttotal += max(min(x, s[i].second + s[i].first) - s[i].second, 0);\n\ttotal += max(min(x, s[ridx].second + rpos) - s[ridx].second, 0);\n\t\n\treturn total;\n}\n\nint main()\n{\n\twhile(true) {\n\n\t\tint n, m, p, q, r;\n\t\tvector<pair<int, int> > c, d;\n\t\n\t\tscanf(\"%d\", &n);\n\t\tif(n == 0)\n\t\t\tbreak;\n\t\tscanf(\"%d%d%d%d\", &m, &p, &q, &r);\n\t\t\n\t\tc.push_back(make_pair(n, 1));\n\t\tc.reserve(3 * m);\n\t\td.reserve(3 * m);\n\t\t\n\t\tfor(int i = 0; i < m; ++i) {\n\t\t\t\n\t\t\tint x, y;\n\t\t\t\n\t\t\tscanf(\"%d%d\", &x, &y);\n\t\t\t\n\t\t\tshuffle(c, d, x, y, n);\n\t\t\tc = d;\n\t\t}\n\t\t\n\t\t//for(int i = 0; i < c.size(); ++i)\n\t\t//\tprintf(\"(%d, %d)\\n\", c[i].second, c[i].first);\n\t\tint ans = countnum(c, p - 1, q, r + 1);\n\t\t\n\t\tprintf(\"%d\\n\", ans);\n\t}\n\t\n\treturn 0;\n}\n\n/* ハラスメントに負けず */\n/* 0完太陽にも負けず */\n/* はやく人権を獲得したい */\n/* nullmineralが書きましたが */\n/* 責任はまったくとりません */"
  },
  {
    "language": "C++",
    "code": "#include <iostream>\n#include <cstdio>\n#include <cmath>\n#include <vector>\n#include <map>\n#include <stack>\n#include <queue>\n#include <algorithm>\n#include <set>\n\n#define FOR(i,a,b) for(int i=(a);i<(b);i++)\n#define REP(i,j) FOR(i,0,j)\n#define mp std::make_pair\n\ntypedef long long ll;\ntypedef unsigned long long ull;\ntypedef std::pair<int,int> P;\ntypedef std::pair<int,P> State;\n\nconst int INF = 1001001001;\n\n// S N E W(南北東西)\nconst int dx[8] = {0, 0, 1, -1, 1, 1, -1, -1}, dy[8] = {1, -1, 0, 0, 1, -1, 1, -1};\n\nstruct Node{\n    int first, last;\n    Node *prev, *next;\n};\n\nint N, M;\nint p, q, r;\n\nNode* get(Node* n, int index){\n    int size = n->last - n->first + 1;\n    if(index == 0){\n        return n;\n    }else if(0 < index && index < size){\n        Node* new_node = new Node{n->first + index, n->last, n, n->next};\n        n->last = n->first + index - 1;\n        n->next = new_node;\n        return new_node;\n    }\n    return get(n->next, index - size);\n}\n\nNode* end(Node* n){\n    if(n->next == nullptr){return n;}\n    return end(n->next);\n}\n\nvoid print(Node *n){\n    printf(\"[%d, %d]\\n\", n->first, n->last);\n    if(n->next == nullptr){puts(\"---------------------------\");return;}\n    print(n->next);\n}\n\nP intersect(const P lp, const P rp){\n    if(rp.first <= lp.first && lp.second <= rp.second){return lp;}\n    if(lp.first <= rp.first && rp.second <= lp.second){return rp;}\n    if(rp.first <= lp.first && lp.first < rp.second){return mp(lp.first, rp.second);}\n    if(lp.first <= rp.first && rp.first < lp.second){return mp(rp.first, lp.second);}\n    return mp(-1, -1);\n}\n\nint count(Node *n, int first){\n    if(n == nullptr){return 0;}\n    int size = n->last - n->first + 1, res = 0;\n    P is = intersect(mp(first, first+size), mp(p, q));\n    is.second = std::min(is.second, is.first + r - n->first + 1);\n    // printf(\"%d, %d, %d, %d\\n\", is.first, is.second, is.first-first, is.second-first);\n    if(is.first != -1 && n->first+is.first-first <= r){\n        //printf(\"wa-: %d, %d\\n\", n->first, n->last);\n        \n        res += is.second - is.first;\n    }\n    res += count(n->next, first+size);\n    return res;\n}\n\n// intersect(mp(0, 3), mp(1, 10)) -> (1, 3)\n// intersect(mp(0, 9), mp(1, 10)) -> (1, 9)\nint main(){\n    while(std::cin >> N >> M, N){\n        std::cin >> p >> q >> r;\n        --p;\n\n        Node *root = new Node{1, N, nullptr, nullptr};\n\n        REP(i, M){\n            int a, b;\n            std::cin >> a >> b;\n\n            Node *f1 = root, *s1 = get(root, a), *t1 = get(root, b),\n                *f2 = s1->prev, *s2 = t1->prev, *t2 = end(root);\n        \n            t2->next = s1;\n            s1->prev = t2;\n\n            s2->next = f1;\n            f1->prev = s2;\n\n            f2->next = nullptr;\n        \n            root = t1;\n            // print(root);\n        }\n\n        printf(\"%d\\n\", count(root, 0));\n    }\n}"
  },
  {
    "language": "C++",
    "code": "#define _CRT_SECURE_NO_WARNINGS\n#include \"bits/stdc++.h\"\nusing namespace std;\n\n#define int int64_t\n\n#define CHOOSE(a) CHOOSE2 a\n#define CHOOSE2(a0,a1,a2,a3,x,...) x\n#define REP1(i, s, cond, cal) for (signed i = signed(s); i cond; i cal)\n#define REP2(i, s, n) REP1(i, s, < signed(n), ++)\n#define REP3(i, n) REP2(i, 0, n)\n#define rep(...) CHOOSE((__VA_ARGS__,REP1,REP2,REP3))(__VA_ARGS__)\n#define rrep(i, s) rep(i, s, >= 0, --)\n\n#define all(c) begin(c), end(c)\n#define maxup(ans, x) (ans = (ans < x ? x : ans))\n#define minup(ans, x) (ans = (ans > x ? x : ans))\n\n#define breakif(cond) if(cond) break; else\n\nusing VV = vector<vector<int>>;\nusing V = vector<int>;\nusing P = pair<int, int>;\nusing IP = pair<int, P>;\n\ntemplate<typename T>\ninline void input(vector<T>& v) { for (auto& x : v) cin >> x; }\n\nsigned main() {\n\tint n, m, p, q, r;\n\tvector<vector<P>> v(5001, vector<P>(5000));\n\twhile (cin >> n && n) {\n\t\tcin >> m >> p >> q >> r;\n\t\tv[0].clear();\n\t\tv[0].push_back(P(1, n));\n\t\tvector<P> a(m), b(m), c(m);\n\t\trep(i, m) {\n\t\t\ta.clear(); b.clear(); c.clear();\n\t\t\tv[i + 1].clear();\n\t\t\tint x, y; cin >> x >> y;\n\t\t\tint sum = 0;\n\t\t\tfor (P p : v[i]) {\n\t\t\t\tint tmp = p.second - p.first + 1;\n\t\t\t\tif (sum + tmp <= x) {\n\t\t\t\t\ta.push_back(p);\n\t\t\t\t} else if (y <= sum) {\n\t\t\t\t\tc.push_back(p);\n\t\t\t\t} else if (x <= sum && sum + tmp <= y) {\n\t\t\t\t\tb.push_back(p);\n\t\t\t\t} else if (sum < x && y < sum + tmp) {\n\t\t\t\t\tP fst = P(p.first, p.first + (x - sum) - 1);\n\t\t\t\t\tP snd = P(fst.second + 1, fst.second + (y - x));\n\t\t\t\t\tP trd = P(snd.second + 1, p.second);\n\t\t\t\t\ta.push_back(fst);\n\t\t\t\t\tb.push_back(snd);\n\t\t\t\t\tc.push_back(trd);\n\t\t\t\t} else if (sum < x && x < sum + tmp) {\n\t\t\t\t\tP fst = P(p.first, p.first + (x - sum) - 1);\n\t\t\t\t\tP snd = P(fst.second + 1, p.second);\n\t\t\t\t\ta.push_back(fst);\n\t\t\t\t\tb.push_back(snd);\n\t\t\t\t} else if (sum < y && y < sum + tmp) {\n\t\t\t\t\tP fst = P(p.first, p.first + (y - sum) - 1);\n\t\t\t\t\tP snd = P(fst.second + 1, p.second);\n\t\t\t\t\tb.push_back(fst);\n\t\t\t\t\tc.push_back(snd);\n\t\t\t\t}\n\t\t\t\tsum += tmp;\n\t\t\t}\n\t\t\tv[i + 1].insert(v[i + 1].end(), all(c));\n\t\t\tv[i + 1].insert(v[i + 1].end(), all(b));\n\t\t\tv[i + 1].insert(v[i + 1].end(), all(a));\n\t\t}\n\n\t\tint sum = 0;\n\t\tint ans = 0;\n\t\tp--;\n\t\tfor (P item : v[m]) {\n\t\t\tint tmp = item.second - item.first + 1;\n\t\t\tP ra = P(1ll << 60, 1ll << 60);\n\t\t\tif (sum + tmp <= p) {\n\t\t\t\t//skip\n\t\t\t} else if (q <= sum) {\n\t\t\t\t//skip\n\t\t\t} else if (p <= sum && sum + tmp <= q) {\n\t\t\t\tra = item;\n\t\t\t} else if (sum < p && q < sum + tmp) {\n\t\t\t\tint l = item.first + (p - sum);\n\t\t\t\tint r = l + (q - p);\n\t\t\t\tra = P(l, r);\n\t\t\t} else if (sum < p && p < sum + tmp) {\n\t\t\t\tint l = item.first + (p - sum);\n\t\t\t\tint r = item.second;\n\t\t\t\tra = P(l, r);\n\t\t\t} else if (sum < q && q < sum + tmp) {\n\t\t\t\tra = P(item.first, item.first + (q - sum) - 1);\n\t\t\t}\n\n\t\t\tans += max(0ll, min(r, ra.second) - ra.first + 1);\n\t\t\tsum += tmp;\n\t\t}\n\t\tcout << ans << endl;\n\t}\n}"
  },
  {
    "language": "C++",
    "code": "#include <cstdio>\n#include <vector>\n#include <map>\nusing namespace std;\ntypedef pair<int, int> P;\ntypedef vector<P> vi;\n#define f first\n#define s second\n#define pb push_back\n#define sz(x) x.size()\nvoid shuffle(int x, int y, vi &c) {\n    int cnt=0, i;\n    int sz=sz(c);\n    vi temp1, temp2, temp3;\n    for (i=0; i<sz; i++) {\n        int s=c[i].f, e=c[i].s;\n        if (cnt+e-s+1>=x) {\n            temp1.pb(P(s,s+x-cnt-1));\n            break;\n        }\n        temp1.pb(c[i]); \n        cnt+=e-s+1;\n    }\n    if (cnt+c[i].s-c[i].f+1>=y) {\n        temp2.pb(P(c[i].f+x-cnt,c[i].f+y-cnt-1));\n        temp3.pb(P(c[i].f+y-cnt,c[i].s));\n        for (i+=1;i<sz; i++) temp3.pb(c[i]);\n    } else {\n        temp2.pb(P(c[i].f+x-cnt,c[i].s));\n        cnt+=c[i].s-c[i].f+1;\n        int a=++i;\n        for (;i<sz; i++) {\n            int s=c[i].f, e=c[i].s;\n            if (cnt+e-s+1>=y) {\n                temp2.pb(P(s,s+y-cnt-1));\n                break;\n            }\n            temp2.pb(c[i]);\n            cnt+=e-s+1;\n        }\n        if (cnt+c[i].s-c[i].f+1!=y) temp3.pb(P(c[i].f+y-cnt,c[i].s));\n        for (i+=1; i<sz; i++) temp3.pb(c[i]);\n    }\n/*\n    for (i=0; i<sz(temp1); i++) printf(\"%d %d\\n\",temp1[i].f,temp1[i].s);\n    puts(\"\");\n    for (i=0; i<sz(temp2); i++) printf(\"%d %d\\n\",temp2[i].f,temp2[i].s);\n    puts(\"\");\n    for (i=0; i<sz(temp3); i++) printf(\"%d %d\\n\",temp3[i].f,temp3[i].s);\n    puts(\"\");\n*/\n    for (i=0; i<sz(temp3); i++) c.pb(temp3[i]);\n    for (i=0; i<sz(temp2); i++) c.pb(temp2[i]);\n    for (i=0; i<sz(temp1); i++) c.pb(temp1[i]);\n    temp1.clear(); temp2.clear(); temp3.clear();\n}\n\nint main() {\n    int n, m, p, q, r;\n    while (scanf(\"%d\",&n)) {\n        if (!n) break;\n        scanf(\"%d%d%d%d\",&m,&p,&q,&r);\n        vi c(1,P(1,n));\n        for (int i=0; i<m; i++) {\n            int x, y; scanf(\"%d%d\",&x,&y);\n            shuffle(x,y,c);\n        }\n        int cnt=0, res=0;\n        for (int i=0; i<sz(c); i++) {\n            int s=c[i].f, e=c[i].s;\n//            printf(\"%d %d\\n\",s,e);\n            if (cnt+e-s+1>=p&&q>=cnt) {\n                int m=max(s+p-cnt-1,s), M=min(s+q-cnt-1,e);\n//                printf(\"%d %d\\n\",m,M);\n                if (r>=m&&r<=M) res+=r-m+1;\n                else if (r>=M) res+=M-m+1;\n            }\n            cnt+=e-s+1;\n        }\n        printf(\"%d\\n\",res);\n    }\n}"
  },
  {
    "language": "C++",
    "code": "#include <iostream>\n#include <vector>\nusing namespace std;\n\ntypedef pair<int,int> pint;\n\nint main(){\n    int n,m,p,q,r;\n    while(cin>>n,n){\n        cin>>m>>p>>q>>r;\n        vector<pint> cards;\n        cards.push_back(pint(1,n));\n        int x,y;        \n        while(m--){\n            cin>>x>>y;\n            vector<pint> a,b;\n            int count=0;\n            for(int i=0;i<cards.size();++i){\n                count += cards[i].second - cards[i].first +1;\n                if(count>=x){\n                    a.insert(a.begin(),cards.begin(),cards.begin()+i+1);\n                    a[i].second -= count - x;\n                    if(count>x){\n                        cards[i].first =a[i].second+1;--i;\n                    }\n                    cards.erase(cards.begin(),cards.begin()+i+1);\n                    break;\n                }\n            }\n            count=x;\n            for(int i=0;i<cards.size();++i){\n                count += cards[i].second - cards[i].first +1;\n                if(count>=y){\n                    b.insert(b.end(),cards.begin(),cards.begin()+i+1);\n                    b[i].second -= count - y;\n                    if(count>y){\n                        cards[i].first = b[i].second +1;\n                        --i;\n                    }\n                    cards.erase(cards.begin(),cards.begin()+i+1);\n                    break;\n                }\n            }\n            cards.insert(cards.end(),b.begin(),b.end());\n            cards.insert(cards.end(),a.begin(),a.end());\n        }\n        int count = 0,ans=0;\n        for(int i=0;i<cards.size();++i){\n            count += cards[i].second - cards[i].first +1;\n            if(count>=p){\n                cards[i].first = cards[i].second -count +p;\n                cards.erase(cards.begin(),cards.begin()+i);\n                break;\n            }\n        }\n        count=p-1;\n        for(int i=0;i<cards.size();++i){\n            count += cards[i].second - cards[i].first +1;\n            if(count>=q){\n                cards[i].second += -count+q;              \n                cards.erase(cards.begin()+i+1,cards.end());\n                break;\n            }\n        }\n        for(int i=0;i<cards.size();++i){\n            cout<<cards[i].first<<\" \"<<cards[i].second<<endl;\n            ans += max(0,min(r-cards[i].first+1,cards[i].second-cards[i].first+1));\n        }\n        cout<<ans<<endl;\n    }\n    return 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include <iostream>\n#include <algorithm>\n#include <vector>\n#include <map>\n\nusing namespace std;\n\ntypedef pair<int, int> P;\n\nint n, m, p, q, r;\nvector<P> data[2][3];\n\nvoid calc(int t, int a, int b){\n  int pos = 2, cnt = 0, nex = 1 - t, id = 0;\n  int c[2] = {a, b};\n  \n  for(int i=0;i<3;i++) data[nex][i].clear();\n  for(int i=0;i<3;i++){\n    for(int j=0;j<data[t][i].size();j++){\n      if(id == 2) data[nex][pos].push_back(data[t][i][j]);\n      else{\n        int val = cnt + data[t][i][j].second - data[t][i][j].first + 1;\n        if(id == 0 && c[0] < val && c[1] < val){\n          data[nex][pos].push_back(P(data[t][i][j].first, data[t][i][j].second - (val - c[id])));\n          pos--;\n          id++;\n          data[nex][pos].push_back(P(data[t][i][j].second - (val - c[id-1]) + 1, data[t][i][j].second - (val - c[id])));\n          pos--;\n          id++;\n          data[nex][pos].push_back(P(data[t][i][j].second - (val - c[id-1]) + 1, data[t][i][j].second));\n        }else if(val < c[id]){\n          data[nex][pos].push_back(data[t][i][j]);\n        }else if(val == c[id]){\n          data[nex][pos].push_back(data[t][i][j]);\n          pos--;\n          id++;\n        }else if(val > c[id]){\n          int tmp = val - c[id];\n          data[nex][pos].push_back(P(data[t][i][j].first, data[t][i][j].second - tmp));\n          pos--;\n          id++;\n          data[nex][pos].push_back(P(data[t][i][j].second - tmp + 1, data[t][i][j].second));\n        }\n      }\n      cnt += data[t][i][j].second - data[t][i][j].first + 1;\n    }\n  }\n}\n\nmain(){\n  while(cin >> n && n){\n    for(int i=0;i<2;i++) for(int j=0;j<3;j++) data[i][j].clear();\n    cin >> m >> p >> q >> r;\n    data[0][0].push_back(P(1, n));\n    for(int i=0;i<m;i++){\n      int a, b;\n      cin >> a >> b;\n      calc(i%2, a, b);\n    }\n    /*for(int i=0;i<3;i++){\n      for(int j=0;j<data[m%2][i].size();j++){\n      cout << \"(\" << data[m%2][i][j].first << \"-\" << data[m%2][i][j].second << \"), \";\n      }\n      cout << endl;\n      }*/\n    int ans = 0;\n    int cnt = 0;\n    for(int i=0;i<3;i++){\n      for(int j=0;j<data[m%2][i].size();j++){\n        P tmp = data[m%2][i][j];\n        int len = tmp.second - tmp.first + 1;\n        if(cnt <= p && q <= cnt + len){\n          int v1 = tmp.first + (p - cnt - 1);\n          int v2 = r - (v1 - 1);\n          ans += max(0, min(v2, q - p + 1));\n        }else if(p <= cnt && cnt + len <= q){\n          int v1 = tmp.first - 1;\n          int v2 = r - v1;\n          ans += max(0, min(v2, len));\n        }else if(cnt <= p && p <= cnt + len){\n          int v1 = tmp.first + (p - cnt - 1); \n          int v2 = r - (v1 - 1);\n          ans += max(0, min(v2, len - (p - cnt - 1)));\n        }else if(cnt <= q && q <= cnt + len){\n          int v1 = tmp.first - 1;\n          int v2 = r - v1;\n          ans += max(0, min(v2, q - cnt));\n        }\n        cnt += len;\n      }\n    }\n    cout << ans << endl;\n  }\n}"
  },
  {
    "language": "C++",
    "code": "#include <iostream>\n#include <sstream>\n#include <string>\n#include <algorithm>\n#include <vector>\n#include <list>\n#include <stack>\n#include <queue>\n#include <set>\n#include <map>\n#include <cstdio>\n#include <cstdlib>\n#include <cstring>\n#include <cmath>\n\nusing namespace std;\n\n#define FOR(i,k,n) for(int i=(k); i<(int)n; ++i)\n#define REP(i,n) FOR(i,0,n)\n#define FORIT(i,c) for(__typeof((c).begin())i=(c).begin();i!=(c).end();++i)\ntypedef pair<int,int> P;\nlist<P> card;\nint cnum(P p){\n  return p.second - p.first + 1;\n}\nvoid printcard(list<P> card){\n  for(list<P>::iterator it = card.begin(); it != card.end(); it++){\n    printf(\"%d-%d \",it->first,it->second);\n  }\n  putchar('\\n');\n}\n\nvoid shuffle(int x,int y){ //[y,n) [x,y) [0,x)\n  list<P> A,B,C;\n  int count = 0;\n  for(list<P>::iterator it = card.begin(); it != card.end(); it++ ){\n    P ncd = *it;\n    while(true){\n      if(count < x){\n        if(count + cnum(ncd) > x){\n          A.push_back(P(ncd.first, ncd.first + (x - count - 1)));\n          ncd = P(ncd.first+(x-count), ncd.second);\n          count += cnum(A.back());\n        }else{\n          A.push_back(ncd);\n          count += cnum(ncd);\n          break;\n        }\n      }else if(count < y){\n        if(count + cnum(ncd) > y){\n          B.push_back(P(ncd.first, ncd.first + (y - count - 1)));\n          ncd = P(ncd.first+(y-count), ncd.second);\n          count += cnum(B.back());\n        }else{\n          B.push_back(ncd);\n          count += cnum(ncd);\n          break;\n        }\n      }else{\n        C.push_back(ncd);\n        break;\n      }\n    }\n  }\n  /*j\n  printcard(card);\n  printcard(A);\n  printcard(B);\n  printcard(C);\n  */\n  C.insert(C.end(),B.begin(),B.end());\n  C.insert(C.end(),A.begin(),A.end());\n  card = C;\n}\nint calc(int p, int q, int r){\n  int ret = 0;\n  int count = 0;\n  for(list<P>::iterator it = card.begin(); it != card.end(); it++){\n    int lw = count + 1;\n    int up = count + cnum(*it);\n    if(lw >= p && lw < q){\n      if(up >= p && up < q){\n        ret += max(0,  it->second - max(r+1,it->first) + 1); \n      }else{\n        ret += max(0,  (it->first+(q-lw)) - max(r+1,it->first) + 1); \n      }\n    }else{\n      if(up >= p && up < q){\n        ret += max(0,  it->second - max(r+1,it->second-(up-p)) + 1); \n      }else{\n        //nothing\n      }\n    }\n    //printf(\"%d->%d:%d \",lw,up, ret);\n    count = up;\n  }\n  return (q-p+1)-ret;  \n}\n\nint main(){\n  int n,m,p,q,r;\n  while(cin>>n>>m>>p>>q>>r){\n    card.clear();\n    card.push_back(P(1,n));\n    REP(i,m){\n      int x,y;\n      cin>>x>>y;\n      shuffle(x,y);\n    }\n    int ans = calc(p,q,r);\n    cout<<ans<<endl;\n  }\n  return 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include<iostream>\n#include<vector>\n#include<map>\n#define pb push_back\nusing namespace std;\n\ntypedef pair<int,int> P;\n\nint main(){\n  int n,m,p,q,r;\n  int x[10000],y[10000];\n  vector<P> v,tmp;\n\n  while(cin >> n, n){\n    cin >> m >> p >> q >> r;\n    for(int i=0;i<m;i++)cin >> x[i] >> y[i];\n    \n    v.clear();\n    v.pb(P(p,q));\n    \n    for(int i=m-1;i>=0;i--){\n      tmp.clear();\n      for(int j=0;j<(int)v.size();j++){\n\tint b = v[j].first, e = v[j].second;\n\tif(e<=n-y[i])tmp.pb(P(b + y[i], e + y[i]));\n\telse if(b<=n-y[i]){\n\t  if(e<=n-x[i]){\n\t    tmp.pb(P(b + y[i],n));\n\t    tmp.pb(P(x[i]+1,x[i] + e - (n-y[i]) ));\n\t  }else{ \n\t    tmp.pb(P(b + y[i],n));\n\t    tmp.pb(P(x[i]+1,y[i]));\n\t    tmp.pb(P(1,e - (n-x[i])));\n\t  }\n\t}\n\telse if(e<=n-x[i])tmp.pb(P(b - (n-y[i]) + x[i],e - (n-y[i]) + x[i]) );\n\telse if(b<=n-x[i]){\n\t  tmp.pb(P(b - (n-y[i]) + x[i],y[i]));\n\t  tmp.pb(P(1,e - (n-x[i])));\n\t}\n\telse tmp.pb(P(b - (n-x[i]),e - (n-x[i])));\n      }\n \n      v = tmp;\n    }\n    \n    int ans = 0;\n    for(int i=0;i<(int)v.size();i++){\n      if(v[i].second<=r)ans += v[i].second - v[i].first + 1;\n      else if(v[i].first<=r)ans += r - v[i].first + 1;\n    }\n    cout << ans <<endl;\n  }\n}"
  },
  {
    "language": "C++",
    "code": "#include <cstdio>\n#include <cstdlib>\n#include <cstring>\n#include <cmath>\n#include <climits>\n#include <cfloat>\n#include <ctime>\n#include <map>\n#include <utility>\n#include <set>\n#include <iostream>\n#include <memory>\n#include <string>\n#include <vector>\n#include <algorithm>\n#include <functional>\n#include <sstream>\n#include <complex>\n#include <stack>\n#include <queue>\n#include <numeric>\n#include <list>\n\nusing namespace std;\n\n#ifdef _MSC_VER\n#define __typeof__ decltype\n\ntemplate <class T>\nint __builtin_popcount(T n) { return n ? 1 + __builtin_popcount(n & (n - 1)) : 0; }\n#endif\n\n#define foreach(it, c) for (__typeof__((c).begin()) it=(c).begin(); it != (c).end(); ++it)\n#define all(c) (c).begin(), (c).end()\n#define rall(c) (c).rbegin(), (c).rend()\n#define popcount __builtin_popcount\n\n#define rep(i, n) for (int i = 0; i < n; ++i)\n\ntemplate <class T> void max_swap(T& a, const T b) { a = max(a, b); }\ntemplate <class T> void min_swap(T& a, const T b) { a = min(a, b); }\n\nconst double EPS = 1e-10;\ntypedef long long ll;\ntypedef pair<int, int> pint;\n\n\nstruct Range\n{\n\tRange() {}\n\tRange(int top, int n) : top(top), n(n) {}\n\tpair<Range, Range> split(int num)\n\t{\n\t\treturn make_pair(Range(top, num), Range(top + num, n - num));\n\t}\n\tint top, n;\n};\n//int next(vector<Range>& pile, int& i, int& sum, int until_sum, vector<Range>& a)\n//{\n//\tint j = 0;\n//\tfor (i = 0; sum < until_sum; ++i)\n//\t{\n//\t\tif (sum + pile[i].n <= until_sum)\n//\t\t{\n//\t\t\t//a.push_back(pile[i]);\n//\t\t\ta[j++] = pile[i];\n//\t\t\tsum += pile[i].n;\n//\t\t}\n//\t\telse\n//\t\t{\n//\t\t\tpair<Range, Range> t = pile[i].split(until_sum - sum);\n//\t\t\t//a.push_back(t.first);\n//\t\t\ta[j++] = t.first;\n//\t\t\tsum = until_sum;\n//\n//\t\t\tpile[i] = t.second;\n//\t\t\tbreak;\n//\t\t}\n//\t}\n//\treturn j;\n//}\nRange pile[10100], a[10100], b[10100], c[10100];\nint size;\nint next(int& i, int& sum, int until_sum, Range* a)\n{\n\tint j = 0;\n\tfor (i = 0; sum < until_sum; ++i)\n\t{\n\t\tif (sum + pile[i].n <= until_sum)\n\t\t{\n\t\t\t//a.push_back(pile[i]);\n\t\t\ta[j++] = pile[i];\n\t\t\tsum += pile[i].n;\n\t\t}\n\t\telse\n\t\t{\n\t\t\tpair<Range, Range> t = pile[i].split(until_sum - sum);\n\t\t\t//a.push_back(t.first);\n\t\t\ta[j++] = t.first;\n\t\t\tsum = until_sum;\n\n\t\t\tpile[i] = t.second;\n\t\t\tbreak;\n\t\t}\n\t}\n\treturn j;\n}\nint main()\n{\n\tint n, m, p, q, r;\n\twhile (scanf(\"%d\", &n), n)\n\t{\n\t\tscanf(\"%d%d%d%d\", &m, &p, &q, &r);\n\n\t\t//pile.push_back(Range(1, n));\n\t\tpile[0].top = 1, pile[0].n = n;\n\t\tsize = 1;\n\t\twhile (m--)\n\t\t{\n\t\t\tint x, y;\n\t\t\tscanf(\"%d%d\", &x, &y);\n\n\t\t\tint p = 0, sum = 0;\n\t\t\t//next(pile, p, sum, x, a);\n\t\t\t//next(pile, p, sum, y, b);\n\t\t\t//for ( ; p < pile.size(); ++p)\n\t\t\t//\tc.push_back(pile[p]);\n\t\t\tint a_size = next(p, sum, x, a);\n\t\t\tint b_size = next(p, sum, y, b);\n\t\t\tint c_size;\n\t\t\tfor (c_size = 0; p < size; ++p, ++c_size)\n\t\t\t\tc[c_size] = pile[p];\n\t\t\t\n\t\t\t//pile.insert(pile.end(), all(b));\n\t\t\t//pile.insert(pile.end(), all(a));\n\t\t\tsize = 0;\n\t\t\trep (i, c_size)\n\t\t\t\tpile[size++] = c[i];\n\t\t\trep (i, b_size)\n\t\t\t\tpile[size++] = b[i];\n\t\t\trep (i, a_size)\n\t\t\t\tpile[size++] = a[i];\n\t\t}\n\n\n\t\tint i = 0, sum = 0;\n\t\t//next(pile, i, sum, p - 1, a);\n\t\t//next(pile, i, sum, q, b);\n\t\tint a_size = next(p, sum, p - 1, a);\n\t\tint b_size = next(p, sum, q, b);\n\n\t\tint res = 0;\n\t\trep (i, b_size)\n\t\t\tres += min(b[i].n, max(0, r - (b[i].top - 1)));\n\t\t\n\t\tprintf(\"%d\\n\", res);\n\t}\n}"
  },
  {
    "language": "C++",
    "code": "#include<iostream>\n#include<algorithm>\nusing namespace std;\nint bef[10000],aft[10000];\nint main(){\n\tint n,m,p,q,r,x,y;\n\twhile(true){\n\tcin>>n;\n\tif(n==0)break;\n\tcin>>m>>p>>q>>r;\n\tint top=1;\n\tbef[0]=0,aft[0]=r;\n\tfor(int u=0;u<m;u++){\n\t\tcin>>x>>y;\n\t\tfor(int i=0;i<top;i++){\n\t\t\tif(x>bef[i]&&x<aft[i])bef[top]=bef[i],aft[top]=x,bef[i]=x,top++;\n\t\t\tif(y>bef[i]&&y<aft[i])bef[top]=bef[i],aft[top]=y,bef[i]=y,top++;\n\t\t\tif(aft[i]<x){bef[i]+=n-x,aft[i]+=n-x;}\n\t\t\tif(bef[i]>=x&&aft[i]<y){bef[i]+=n-x-y,aft[i]+=n-x-y;}\n\t\t\tif(bef[i]>=y){bef[i]-=y,aft[i]-=y;}\n\t\t}\n\t}\n\tint ans=0;\n\tfor(int i=0;i<top;i++){ans+=max(0,min(q,aft[i]+1)-max(p+1,bef[i]));}\n\tcout<<ans<<endl;\n\t}\n\treturn 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include <iostream>\n#include <algorithm>\n#include <vector>\nusing namespace std;\nint main(){\n\tint n,m,p,q,r,x,y,t;\n\tvector<int>::iterator itx,ity,it;\n\tfor(;cin>>n>>m>>p>>q>>r;cout<<x<<endl){\n\t\tvector<int> v1,v2;\n\t\tv1.push_back(0);\n\t\tv1.push_back(r);\n\t\t\n\t\tfor(;m--;v2.clear()){\n\t\t\tcin>>x>>y;\n\t\t\titx=upper_bound(v1.begin(),v1.end(),x);\n\t\t\tity=upper_bound(v1.begin(),v1.end(),y);\n\t\t\t\n\t\t\tif( ity-v1.begin()+1 & 1 )v2.push_back(0);\n\t\t\tv2.push_back(0);\n\t\t\tfor(it=ity;it!=v1.end();++it)\n\t\t\t\tv2.push_back(*it - y);\n\t\t\t\n\t\t\tif(v1.end()-itx & 1)v2.push_back(n-y);\n\t\t\tfor(it=itx;it!=ity;++it)\n\t\t\t\tv2.push_back(*it-x+n-y);\n\t\t\t\n\t\t\tit = v1.begin();\n\t\t\tif(ity-v1.begin() & 1)++it;\n\t\t\tfor(;it!=itx;++it)\n\t\t\t\tv2.push_back(*it+n-x);\n\t\t\t\n\t\t\tv1.swap(v2);\n\t\t}\n\t\tv1.insert( upper_bound(v1.begin(),v1.end(),p-1), 2, p-1);\n\t\tv1.insert( lower_bound(v1.begin(),v1.end(),q), q );\n\t\tv1.push_back(n);\n\t\tit = upper_bound(v1.begin(),v1.end(),p-1);\n\t\tif(it-v1.begin() & 1) --it;\n\t\tfor(x=0;*it<q;++it){\n\t\t\tm=*it;\n\t\t\t++it;\n\t\t\tx+=*it-m;\n\t\t}\n\t}\n}"
  },
  {
    "language": "C++",
    "code": "//確か、r以下とそれ以外の境界部分のインデックスをうごうごやっていた……気がする。\n//書いた当時のことを覚えていないので、誰か解読してください。\n\n#include <iostream>\n#include <algorithm>\n#include <vector>\nusing namespace std;\n\nint main(){\n\tint n, m, p, q, r, x, y;\n\tvector<int>::iterator itx, ity, it;\n\n\twhile( cin >> n >> m >> p >> q >> r ){\n\t\tvector<int> v1, v2;\n\t\tv1.push_back(0);\n\t\tv1.push_back(r);\n\t\t\n\t\tfor(int i = 0; i < m; ++i){\n\t\t\tcin >> x >> y;\n\t\t\titx = upper_bound(v1.begin(), v1.end(), x);\n\t\t\tity = upper_bound(v1.begin(), v1.end(), y);\n\t\t\t\n\t\t\tif( (ity - v1.begin()) % 2 == 0 ) v2.push_back(0);\n\t\t\tv2.push_back(0);\n\n\t\t\tfor(it = ity; it != v1.end(); ++it)\n\t\t\t\tv2.push_back(*it - y);\n\n\t\t\tif( (v1.end() - itx) % 2 != 0 ) v2.push_back(n-y);\n\t\t\tfor(it = itx; it != ity; ++it)\n\t\t\t\tv2.push_back(*it - x + n - y);\n\t\t\t\n\t\t\tit = v1.begin();\n\t\t\tif( (ity - v1.begin()) % 2 != 0 ) ++it;\n\t\t\tif( !it[1] ) it+=2;\t//重複排除\n\t\t\tif( *it + n - x == v2.back() ){\t//重複排除\n\t\t\t\t++it;\n\t\t\t\tv2.pop_back();\n\t\t\t}\n\t\t\tfor( ; it != itx; ++it)\n\t\t\t\tv2.push_back(*it + n - x);\n\t\t\t\n\t\t\tv1.swap(v2);\n\t\t\tv2.clear();\n\t\t}\n\n\t\tv1.insert( upper_bound(v1.begin(), v1.end(), p - 1), 2, p - 1);\n\t\tv1.insert( lower_bound(v1.begin(), v1.end(), q), q);\n\t\tv1.push_back(n);\n\n\t\tit = upper_bound(v1.begin(), v1.end(), p - 1);\n\t\tif( (it - v1.begin()) % 2 != 0) --it;\n\n\t\tint ans = 0;\n\t\tfor( ; *it < q; ++it){\n\t\t\tint prev = *it;\n\t\t\t++it;\n\t\t\tans += *it - prev;\n\t\t}\n\t\t\n\t\tcout << ans << '\\n';\n\t}\n\t\n\treturn 0;\n}"
  },
  {
    "language": "C++",
    "code": "#define _USE_MATH_DEFINES\n#define INF 0x3f3f3f3f\n\n#include <iostream>\n#include <cstdio>\n#include <sstream>\n#include <cmath>\n#include <cstdlib>\n#include <algorithm>\n#include <queue>\n#include <stack>\n#include <limits>\n#include <map>\n#include <string>\n#include <cstring>\n#include <set>\n#include <deque>\n#include <bitset>\n#include <list>\n#include <cctype>\n#include <utility>\n  \nusing namespace std;\n  \ntypedef long long ll;\ntypedef pair <int,int> P;\ntypedef pair <int,P> PP;\n  \nstatic const double EPS = 1e-8;\n  \nstatic const int tx[] = {0,1,0,-1};\nstatic const int ty[] = {-1,0,1,0};\n\nint main(){\n  int total_cards;\n  while(~scanf(\"%d\",&total_cards)){\n    if(total_cards == 0) break;\n    int total_shuffles;\n    int first,last,upper;\n\n    scanf(\"%d\",&total_shuffles);\n    scanf(\"%d %d %d\",&first,&last,&upper);\n    \n    vector<P> cards;\n    cards.push_back(P(1,total_cards));\n\n    for(int shuffle_idx=0;shuffle_idx<total_shuffles;shuffle_idx++){\n      int x,y;\n      scanf(\"%d %d\",&x,&y);\n      //x -> none\n      //y -> 1\n      //n -> x+1\n      //C -> B -> A\n      vector<P> A;\n      vector<P> B;\n      vector<P> C;\n      vector<P> next;\n\n      int sum = 0;\n      int prev_sum = 0;\n      for(int j=0;j<cards.size();j++){\n        prev_sum = sum;\n        sum += cards[j].second - cards[j].first + 1;\n        if(prev_sum < x){\n          if(sum <= x){\n            A.push_back(cards[j]);\n          }\n          else if(sum > x && sum <= y){\n            A.push_back(P(cards[j].first,cards[j].first + (x - prev_sum - 1)));\n            B.push_back(P(cards[j].first + (x - prev_sum),\n                          cards[j].second));\n          }\n          else if(sum > y){\n            A.push_back(P(cards[j].first,cards[j].first + (x - prev_sum - 1)));\n            B.push_back(P(cards[j].first + (x - prev_sum),\n                          cards[j].first + (x - prev_sum) + (y - x - 1)));\n            C.push_back(P(cards[j].first + (x - prev_sum) + (y - x),\n                          cards[j].second));\n          }\n        }\n        else if(prev_sum >= x){\n          if(prev_sum < y){\n            if(sum <= y){\n              B.push_back(P(cards[j].first,cards[j].second));\n            }\n            else if(sum > y){\n              B.push_back(P(cards[j].first,cards[j].first + (y - prev_sum - 1)));\n              C.push_back(P(cards[j].first + (y - prev_sum),cards[j].second));\n            }\n          }\n          else if(prev_sum >= y){\n            C.push_back(P(cards[j].first,cards[j].second));\n          }\n        }\n      }\n      for(int i=0;i<C.size();i++){\n        next.push_back(C[i]);\n        // cout << \"C<f,s>=\" << C[i].first << \",\" << C[i].second << endl;\n      }\n      for(int i=0;i<B.size();i++){\n        next.push_back(B[i]);\n        // cout << \"B<f,s>=\" << B[i].first << \",\" << B[i].second << endl;\n      }\n      for(int i=0;i<A.size();i++){\n        next.push_back(A[i]);\n        // cout << \"A<f,s>=\" << A[i].first << \",\" << A[i].second << endl;\n      }\n      // cout << endl;\n      cards = next;\n    }\n\n    int offset = 0;\n    int res = 0;\n    for(int i=0;i<cards.size();i++){\n      int current = cards[i].second - cards[i].first + 1;\n      // cout << \"offset \" << offset << endl;\n      // cout << \"<f,s>=\" << cards[i].first << \",\" << cards[i].second << endl;\n\n      for(int j=0;j<=cards[i].second - cards[i].first;j++){\n        if(offset + j + 1 > last) break;\n        if(cards[i].first + j <= upper){\n          res++;\n        }\n      }\n      offset += current;\n    }\n    printf(\"%d\\n\",res);\n\n  }\n}"
  },
  {
    "language": "C++",
    "code": "#include <cstdio>\n#include <vector>\n#include <map>\n#include <algorithm>\n#define fi first\n#define sec second\nusing namespace std;\ntypedef pair<int,int> P;\n \nint n, m, p, q, r;\nint ans;\nvector<P> v;\nvector<P>::iterator it;\n \nvoid solve(){\n    ans = 0;\n    v.clear();\n    v.push_back(P(1,n));\n    scanf(\"%d%d%d%d\", &m, &p, &q, &r);\n    int pst;\n    for(int i = 0; i < m; i++){\n        int x, y; scanf(\"%d%d\", &x, &y);\n        pst = 0;\n        int cnt = 0;\n        for(it = v.begin(); it != v.end(); it++){\n            cnt++;\n            pst += (*it).sec-(*it).fi+1;\n            if(pst < x) continue;\n            if(pst == x){\n                x = cnt-1;\n                break;\n            }\n            int in = (*it).sec;\n            (*it).sec = (*it).sec-(pst-x);\n            v.insert(it+1,P((*it).sec+1,in));\n            x = cnt-1;\n            break;\n        }\n        pst = 0;\n        cnt = 0;\n        /*\n        for(int j = 0; j < v.size(); j++){\n            printf(\" %d %d\\n\", v[j].fi, v[j].sec);\n        }\n        */\n        for(it = v.begin(); it != v.end(); it++){\n            cnt++;\n            pst += (*it).sec-(*it).fi+1;\n            if(pst < y) continue;\n            if(pst == y){\n                y = cnt-1;\n                break;\n            }\n            int in = (*it).sec;\n            (*it).sec = (*it).sec-(pst-y);\n            v.insert(it+1,P((*it).sec+1,in));\n            y = cnt-1;\n            break;\n        }\n        vector<P> tmp;\n        for(int j = y+1; j < v.size(); j++) tmp.push_back(v[j]);\n        for(int j = x+1; j <= y; j++) tmp.push_back(v[j]);\n        for(int j = 0; j <= x; j++) tmp.push_back(v[j]);\n        v = tmp;\n        /*\n        printf(\"\\n\");\n        for(int j = 0; j < v.size(); j++){\n            printf(\"%d %d\\n\", v[j].fi, v[j].sec);\n        }\n        */\n    }\n    /*\n    for(int j = 0; j < v.size(); j++){\n            printf(\"%d %d\\n\", v[j].fi, v[j].sec);\n        }*/\n    pst = 0;\n    for(int i = 0; i < v.size(); i++){\n        pst += v[i].sec-v[i].fi+1;\n        int s = pst-(v[i].sec-v[i].fi), dif = 0;\n        if(v[i].fi > r) continue;\n        if(pst < p) continue;\n        if(s > q) continue;\n        if(s < p) dif = p-s;\n        if(pst <= q){\n            if(r >= v[i].sec) ans += v[i].sec-v[i].fi+1-dif;\n            else ans += r-v[i].fi+1-dif;\n        } else{\n            if(r >= v[i].fi+q-s) ans += q-s+1-dif;\n            else ans += r-v[i].fi+1-dif;\n        }\n        //printf(\"%d\\n\", ans);\n    }\n    printf(\"%d\\n\", ans);\n}\n \nint main(){\n    while(scanf(\"%d\", &n),n) solve();\n}"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\nusing namespace std;\n\nusing VI = vector<int>;\nusing VVI = vector<VI>;\nusing PII = pair<int, int>;\nusing LL = long long;\nusing VL = vector<LL>;\nusing VVL = vector<VL>;\nusing PLL = pair<LL, LL>;\nusing VS = vector<string>;\n\n#define ALL(a)  begin((a)),end((a))\n#define RALL(a) (a).rbegin(), (a).rend()\n#define PB push_back\n#define EB emplace_back\n#define MP make_pair\n#define SZ(a) int((a).size())\n#define SORT(c) sort(ALL((c)))\n#define RSORT(c) sort(RALL((c)))\n#define UNIQ(c) (c).erase(unique(ALL((c))), end((c)))\n\n#define FOR(i,a,b) for(int i=(a);i<(b);++i)\n#define REP(i,n)  FOR(i,0,n)\n\n#define FF first\n#define SS second\ntemplate<class S, class T>\nistream& operator>>(istream& is, pair<S,T>& p){\n  return is >> p.FF >> p.SS;\n}\ntemplate<class S, class T>\nostream& operator<<(ostream& os, const pair<S,T>& p){\n  return os << p.FF << \" \" << p.SS;\n}\ntemplate<class T>\nvoid maxi(T& x, T y){\n  if(x < y) x = y;\n}\ntemplate<class T>\nvoid mini(T& x, T y){\n  if(x > y) x = y;\n}\n\n\nconst double EPS = 1e-10;\nconst double PI  = acos(-1.0);\nconst LL MOD = 1e9+7;\n\nint main(){\n  cin.tie(0);\n  ios_base::sync_with_stdio(false);\n\n  int N;\n  while(cin>>N, N){\n\tint M;\n\tcin >> M;\n\tint P, Q, R;\n\tcin >> P >> Q >> R;\n\t--P;\n\t\n\tvector<pair<PII,int>> s[2];\n\tint crt = 0, nxt = 1;\n\ts[crt].PB(MP(MP(0,N),0));\n\tREP(i,M){\n\t  int a, b;\n\t  cin >> a >> b;\n\t  --a;\n\t  s[nxt].clear();\n\t  \n\t  for(auto x: s[crt]){\n\t\tauto r = x.FF;\n\t\tint ix = x.SS;\n\t\tint l1 = N - b;\n\t\tint l2 = l1 + b - a;\n\t\t\n\t\tif(r.SS <= a){\n\t\t  s[nxt].PB(MP(MP(l2+r.FF, l2+r.SS), ix));\n\t\t}\n\t\telse if(r.FF < a){\n\t\t  if(r.SS <= b){\n\t\t\ts[nxt].PB(MP(MP(l2+r.FF, N), ix));\n\t\t\tif(ix+a-r.FF < R)\n\t\t\t  s[nxt].PB(MP(MP(l1, l1+r.SS-a), ix+a-r.FF));\n\t\t  }\n\t\t  else{\n\t\t\ts[nxt].PB(MP(MP(l2+r.FF, l2+a), ix));\n\t\t\tif(ix+a-r.FF < R)\n\t\t\t  s[nxt].PB(MP(MP(l1,l2), ix+a-r.FF));\n\t\t\tif(ix+b-r.FF < R)\n\t\t\t  s[nxt].PB(MP(MP(0,r.SS-b), ix+b-r.FF));\n\t\t  }\n\t\t}\n\t\telse if(r.FF < b){\n\t\t  if(r.SS <= b){\n\t\t\ts[nxt].PB(MP(MP(l1+r.FF-a,l1+r.SS-a),ix));\n\t\t  }\n\t\t  else{\n\t\t\ts[nxt].PB(MP(MP(l1+r.FF-a,b), ix));\n\t\t\tif(ix+b-r.FF < R)\n\t\t\t  s[nxt].PB(MP(MP(0,r.SS-b), ix+b-r.FF));\n\t\t  }\n\t\t}\n\t\telse{\n\t\t  s[nxt].PB(MP(MP(r.FF-b,r.SS-b), ix));\n\t\t}\n\t  }\n\t  swap(crt, nxt);\n\t}\n\t\n\tint ans = 0;\n\tfor(auto&& p: s[crt]){\n\t  auto ra = p.FF;\n\t  int ix = p.SS;\n\t  if(ra.SS <= P || Q <= ra.FF) continue;\n\t  int l = max(P, ra.FF);\n\t  int r = min(Q, ra.SS);\n\t  int bix = ix + l-ra.FF;\n\t  if(bix < R){\n\t\tans += min(r-l, R - bix);\n\t  }\n\t}\n\tcout << ans << endl;\n  }\n\n  return 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include<iostream>\n#include<cstdio>\n#include<vector>\n#include<queue>\n#include<algorithm>\n#include<functional>\n#include<cstring>\n#include<iterator>\n#define MAX_N 100000\n#define F first\n#define S second \n#define MP make_pair\nusing namespace std;\ntypedef pair<int, int> P;\n\nconst int INF = 1e9;\n\nint main() {\n\tint n, m, pp, q, r;\n\n\twhile (cin >> n&&n){\t\n\t\tint save = -1, ans = 0;\n\t\tvector<int>vep, vep2, vep3;\n\t\tvep.push_back(1);\n\t\tvep.push_back(n);\n\t    vector<int> vec, vec2, vec3;\n\t\tvec.push_back(1);\n\t\tvec.push_back(n);\n\t\tcin >> m >> pp >> q >> r;\n\t\tfor (int i = 0; i < m; i++) {\n\t\t\tint x, y, p, p2;\n\t\t\tscanf(\"%d%d\", &x, &y);\n\t\t\tp = lower_bound(vec.begin(), vec.end(), x) - vec.begin();\n\t\t\tif (vec[p] != x) {\n\t\t\t\tvec.insert(vec.begin() + p, x);\n\t\t\t\tvep.insert(vep.begin() + p, vec[p] - vec[p - 1] + vep[p - 1]);\n\t\t\t}\n\t\t\tif (vec[p] + 1 != vec[p + 1]) {\n\t\t\t\tvec.insert(vec.begin() + p + 1, x + 1);\n\t\t\t\tvep.insert(vep.begin() + p + 1, vep[p] + 1);\n\t\t\t}\n\t\t\tp2 = lower_bound(vec.begin(), vec.end(), y) - vec.begin();\n\t\t\tif (vec[p2] != y) {\n\t\t\t\tvec.insert(vec.begin() + p2, y);\n\t\t\t\tvep.insert(vep.begin() + p2, vec[p2] - vec[p2 - 1] + vep[p2 - 1]);\n\t\t\t}\n\t\t\tif (vec[p2] + 1 != vec[p2 + 1]) {\n\t\t\t\tvec.insert(vec.begin() + p2 + 1, y + 1);\n\t\t\t\tvep.insert(vep.begin() + p2 + 1, vep[p2] + 1);\n\t\t\t}\n\t\t\tfor (int j = p2 + 1; j < vec.size(); j++) {\n\t\t\t\tvec2.push_back(vec[j] - vec[p2 + 1] + 1);\n\t\t\t\tvep2.push_back(vep[j]);\n\t\t\t}\n\t\t\tint size = vec2[vec2.size() - 1];\n\t\t\tfor (int j = p + 1; j < p2 + 1; j++) {\n\t\t\t\tvec2.push_back(vec[j] - vec[p + 1] + 1 + size);\n\t\t\t\tvep2.push_back(vep[j]);\n\t\t\t}\n\t\t\tsize = vec2[vec2.size() - 1];\n\t\t\tfor (int j = 0; j < p + 1; j++) {\n\t\t\t\tvec2.push_back(vec[j] - vec[0] + 1+size);\n\t\t\t\tvep2.push_back(vep[j]);\n\t\t\t}\n\t\t\tcopy(vec.begin(), vec.end(), back_inserter(vec2));\n\t\t\tcopy(vep.begin(), vep.end(), back_inserter(vep2));\n\t\t}\n\t\tint p, p2;\n\t\tp = lower_bound(vec.begin(), vec.end(), pp) - vec.begin();\n\t\t\n\t\tif (vec[p] != pp) {\n\t\t\tvec.insert(vec.begin() + p, pp);\n\t\t\tvep.insert(vep.begin() + p, vec[p] - vec[p - 1] + vep[p - 1]);\n\t\t}\n\t\tif (vec[p] + 1 != vec[p + 1]) {\n\t\t\tvec.insert(vec.begin() + p + 1, pp + 1);\n\t\t\tvep.insert(vep.begin() + p + 1, vep[p] + 1);\n\t\t}\n\t\tp2 = lower_bound(vec.begin(), vec.end(), q) - vec.begin();\n\t\tif (vec[p2] != q) {\n\t\t\tvec.insert(vec.begin() + p2, q);\n\t\t\tvep.insert(vep.begin() + p2, vec[p2] - vec[p2 - 1] + vep[p2 - 1]);\n\t\t}\n\t\tif (vec[p2] + 1 != vec[p2 + 1]) {\n\t\t\tvec.insert(vec.begin() + p2 + 1, q + 1);\n\t\t\tvep.insert(vep.begin() + p2 + 1, vep[p2] + 1);\n\t\t}\n\t\tfor (int i = p; i <= p2; i++) {\n\t\t\tif (i + 1<=p2 && vep[i + 1] - vep[i] == vec[i + 1] - vec[i]) {\n\t\t\t\tfor (int j = vep[i]; j <= vep[i + 1]; j++) {\n\t\t\t\t\tif (j <= r&&save!=j) {\n\t\t\t\t\t\tans++;\n\t\t\t\t\t\tsave = j;\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t}\n\t\t\telse{\n\t\t\t\tif (vep[i] <= r&&save != vep[i]) {\n\t\t\t\t\tans++;\n\t\t\t\t\tsave = vep[i];\n\t\t\t\t}\n\t\t\t}\n\t}\n\t\tcout << ans << endl;\n\t}\n}"
  },
  {
    "language": "C++",
    "code": "#include <iostream>\n#include <algorithm>\n#include <utility>\n#include <vector>\n#include <list>\n#include <map>\n#include <set>\n#include <queue>\n#include <stack>\n#include <string>\n#include <sstream>\n#include <cstring>\n#include <cstdlib>\n\nusing namespace std;\n\n#define ALL(c) c.begin(),c.end()\n#define RALL(c) c.rbegin(),c.rend()\n#define REP(i,x,y) for(int i=(x);i<(y);++i)\n#define MP(a,b) make_pair((a),(b))\n#define F_ first\n#define S_ second\n\ntypedef long long int lli;\ntypedef pair<int,int> Pi;\n\nconst int INF=100000000;\nconst long long int INF_=100000000000000000;\n\nstruct Segment{\n\tint s,e/*,size()*/;\n\tSegment(int a,int b):s(a),e(b){}\n\tint size(){\n\t\treturn e-s+1;\n\t}\n};\n\nvoid Split(vector<Segment> *state,int i,int x,int y){\n\tstate[i%2].clear();\n\tint idx=i%2,prev_idx=(i+1)%2;\n\t{\n\t\tint s=0;\n\t\tbool flag=true;\n\t\tREP(j,0,state[prev_idx].size()){\n\t\t\ts+=state[prev_idx][j].size();\n\t\t\tif(y<s){\n\t\t\t\tif(flag){\n\t\t\t\t\tstate[idx].push_back(Segment(state[prev_idx][j].s+state[prev_idx][j].size()-(s-y),state[prev_idx][j].e));\n\t\t\t\t\tflag=false;\n\t\t\t\t}else{\n\t\t\t\t\tstate[idx].push_back(state[prev_idx][j]);\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t}\n\t{\n\t\tint s=0;\n\t\tbool flag=true;\n\t\tREP(j,0,state[prev_idx].size()){\n\t\t\ts+=state[prev_idx][j].size();\n\t\t\tif(y<=s){\n\t\t\t\tif(flag){\n\t\t\t\t\tstate[idx].push_back(Segment(state[prev_idx][j].s+state[prev_idx][j].size()-(s-x),state[prev_idx][j].e-(s-y)));\n\t\t\t\t}else{\n\t\t\t\t\tstate[idx].push_back(Segment(state[prev_idx][j].s,state[prev_idx][j].e-(s-y)));\n\t\t\t\t}\n\t\t\t\tbreak;\n\t\t\t}else if(x<s){\n\t\t\t\tif(flag){\n\t\t\t\t\tstate[idx].push_back(Segment(state[prev_idx][j].s+state[prev_idx][j].size()-(s-x),state[prev_idx][j].e));\n\t\t\t\t\tflag=false;\n\t\t\t\t}else{\n\t\t\t\t\tstate[idx].push_back(state[prev_idx][j]);\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t}\n\t{\n\t\tint s=0;\n\t\tREP(j,0,state[prev_idx].size()){\n\t\t\ts+=state[prev_idx][j].size();\n\t\t\tif(x<=s){\n\t\t\t\tstate[idx].push_back(Segment(state[prev_idx][j].s,state[prev_idx][j].s+state[prev_idx][j].size()-(s-x)-1));\n\t\t\t\tbreak;\n\t\t\t}else {\n\t\t\t\tstate[idx].push_back(state[prev_idx][j]);\n\t\t\t}\n\t\t}\n\t}\n}\n\nint main(){\n\tstd::ios::sync_with_stdio(false);\n    std::cin.tie(0);\n\tint N;\n\twhile(cin>>N&&N){\n\t\tint M,P,Q,R;\n\t\tcin >> M >> P >> Q >> R;\n\t\tvector<int> X(M),Y(M);\n\t\tREP(i,0,M) cin >> X[i] >> Y[i];\n\t\tvector<Segment> state[2];\n\t\tstate[0].push_back(Segment(1,N));\n\t\t//cout << endl;\n\t\tREP(i,1,M+1){\n\t\t\tSplit(state,i,X[i-1],Y[i-1]);\n\t\t\t/*\n\t\t\tREP(j,0,state[i].size()){\n\t\t\t\tcout << state[i][j].s << ' ' << state[i][j].e << ' ' << state[i][j].size() << endl;\n\t\t\t}\n\t\t\tcout << endl;\n\t\t\t*/\n\t\t}\n\t\tint ans=0;\n\t\tint s=0;\n\t\tbool flag=true;\n\t\tint idx=M%2;\n\t\tREP(i,0,state[idx].size()){\n\t\t\ts+=state[idx][i].size();\n\t\t\tint tmp=0;\n\t\t\tif(Q<=s){\n\t\t\t\tif(R<state[idx][i].s) break;\n\t\t\t\tif(flag){\n\t\t\t\t\ttmp=min(R,state[idx][i].s+state[idx][i].size()-(s-Q)-1)-(state[idx][i].s+state[idx][i].size()-(s-P)-1)+1;\n\t\t\t\t}else{\n\t\t\t\t\ttmp=min(R,state[idx][i].s+state[idx][i].size()-(s-Q)-1)-state[idx][i].s+1;\n\t\t\t\t}\n\t\t\t\tans+=tmp;\n\t\t\t\tbreak;\n\t\t\t}else if(P<=s){\n\t\t\t\tif(flag){\n\t\t\t\t\tif(R>=state[idx][i].s) tmp=min(R,state[idx][i].e)-(state[idx][i].s+state[idx][i].size()-(s-P)-1)+1;\n\t\t\t\t\tflag=false;\n\t\t\t\t}else{\n\t\t\t\t\tif(R>=state[idx][i].s) tmp+=min(R,state[idx][i].e)-state[idx][i].s+1;\n\t\t\t\t}\n\t\t\t\tans+=tmp;\n\t\t\t}\n\t\t}\n\t\tcout << ans << endl;\n\t}\n\treturn 0;\n}"
  },
  {
    "language": "C++",
    "code": "\n#include<iostream>\nusing namespace std;\nint cards,n,i,p,q,r,x[5000],y[5000],counter;\n  int numberStart[10001];\n  int numberFast[10001];\n  int numberEnd[10001];\n  int searchB[10001];\nint numberLong(int value){\n\treturn numberEnd[value]-numberStart[value]+1;\n}\n\nint seach(int k ){\n  int l=0;\n\n  \n  for ( int a=1;a<=counter+1;a++){\n    if (numberStart[a]<=k && k<numberEnd[a]){\n      l=numberFast[a];\n      return l;\n    }\n    }\n\t\n  return -100;\n  }\nint seachC(int seed){\n  //return seachB(seach(seed));\n\t\t\tint l=0;\n  for (int a=1;a<=counter+1;a++){\n\tif(seed>l+numberLong(searchB[a])){\n\tl+=numberLong(searchB[a]);\n\t}\n\telse{\n\t return numberFast[searchB[a]];\n\t}\n  }\n return -100;\n\t\n}\nint searchD(int seed){\n\t\tint l=0;\n  for (int a=1;a<=counter+1;a++){\n\tif(seed>l+numberLong(searchB[a])){\n\tl+=numberLong(searchB[a]);\n\t}\n\telse{\n\t return numberFast[searchB[a]];\n\t}\n  }\n return -100;\n\t\n}\nint searchNumber(int value){\n\tint l=0;\n  for (int a=1;a<=counter+1;a++){\n\tif(value>l+numberLong(searchB[a])){\n\tl+=numberLong(searchB[a]);\n\t}\n\telse{\n\t return numberStart[searchB[a]]+value-l-1;\n\t}\n  }\n return -100;\n}\n\nint make(int sequence,int counter ){\n  counter++;\n // numberStart[counter]=j;\n // numberEnd[counter]=k;\n  return 0;\n}\n/*\nint StartHead(int value){\n\tint longs=1;\n\tfor (int i=1;i<=counter;i++){\n\t\n\t\tif (numberFast[i]<numberFast[value]){\n\t\t\tlongs+=numberLong(i);\n\t\t}\n\t}\n\treturn longs;\n\n\n}\n*/\nvoid cut(int g){\n\tif(searchD(g)==searchD(g+1)){\n  //カットする場所が入ってる数列を求める\n  int seachX=searchB[seachC(g)];\n  int seachXX=searchNumber(g);\n//数列ができる範囲の後ろの番号FASTを変える\n     for(int j=1;j<=counter;j++){\n      if (numberFast[j]>=numberFast[seachX]+1){\n      numberFast[j]++;\n     }\n    }\n\n  //の数列の後ろに新しい数列を作る\n counter++;\n //for \n make(seachX,counter);\n  numberFast[counter]=numberFast[seachX]+1;\n  numberStart[counter] =searchNumber(g)+1;\n  numberEnd[counter]=numberEnd[seachX];\n  //できた数列の前の数列の最後を調整する\n  numberEnd[seachX]=searchNumber(g);\n \n\n  \n  for ( int a=1;a<=counter+1;a++){\n\t  searchB[numberFast[a]]=a;\n    }\n    }\n\n}\nvoid shuffle(int x,int y){\n\t\n\tint StartHead[10001];\n\tint  numberFastNew[10001];\n\t\n\tint longs=1;\n\tfor (int i=1;i<=counter;i++){\n\t\tStartHead[searchB[i]]=longs;\n\t\tlongs+=numberLong(searchB[i]);\n\t}\n\tint newCounter[3];\n\tfor(int i=0;i<3;i++){\n\t\tnewCounter[i]=0;\n\t}\n\tfor(int j=1;j<=counter;j++){\n\t\tif (StartHead[j]>y){\n\t\t\tnewCounter[0]++;\n\t\tnumberFastNew[j]=0;\n\t\t}\n\t}\n\t\n\tfor(int j=1;j<=counter;j++){\n\t\tif (StartHead[j]>x && StartHead[j]+numberLong(j)-1<=y){\n\t\t\tnewCounter[1]++;\n\t\tnumberFastNew[j]=1;\n\t\t}\n\t}\n\t\n\tfor(int j=1;j<=counter;j++){\n\t\t\tif (StartHead[j]+numberLong(j)-1<=x){\n\t\t\tnewCounter[2]++;\n\t\tnumberFastNew[j]=2;\n\t\t}\n\t}\n\t\n\tfor(int j=1;j<=counter;j++){\n\t\tswitch(numberFastNew[j]){\n\t\t\tcase 0:\n\t\t\t\tnumberFast[j]+=-newCounter[1]-newCounter[2];\n\t\t\t\tbreak;\n\t\t\tcase 1:\n\t\t\t\tnumberFast[j]+=newCounter[0]-newCounter[2];\n\t\t\t\tbreak;\n\t\t\tcase 2:\n\t\t\t\tnumberFast[j]+=newCounter[1]+newCounter[0];\n\t\t\t\tbreak;\n\t\t}\n\n\t}\n\t  for ( int a=1;a<=counter+1;a++){\n\t  searchB[numberFast[a]]=a;\n    }\n\n}\n\n\nint main(void)\n{\n\twhile(true){\n\tcards=0;\n\tn=0;\n\tcounter=0;\n\tfor (int i=0;i<10001;i++){\n   numberStart[i]=0;\n   numberFast[i]=0;\n   numberEnd[i]=0;\n   searchB[i]=0;\n\t}\n\tint points=0;\n  counter=1;\n  cin >> cards;\n  if (cards==0){\n\t  break;\n  }\n  numberStart[1]=1;\n  numberEnd[1]=cards;\n  numberFast[1]=1;\n  searchB[1]=1;\n  cin >> n;\n  cin >> p  >> q  >> r ;\n  for (i=1;i<=n;i++){\n    cin >> x[i] >> y[i];\n  }\n  for (i=1;i<=n;i++){\n     cut(x[i]);\n\t \n      cut(y[i]);\n\t  \n     shuffle(x[i],y[i]);\n  }\n\n  for(int j=p;j<=q;j++){\n\t  if(searchNumber(j)<=r){\n\t\t  points++;\n\t  }\n  }\n  cout << points << endl;\n\t}\n}"
  },
  {
    "language": "C++",
    "code": "#include<iostream>\n#include<vector>\nusing namespace std;\nint main() {\n\tint n;\n\twhile (cin >> n&&n != 0) {\n\t\tvector<int> line;\n\t\tfor (int i = 1; i <= n; ++i) {\n\t\t\tline.push_back(i);\n\t\t}\n\t\tint time;\n\t\tcin >> time;\n\t\tint search[3];\n\t\tfor (int i = 0; i < 3; ++i) {\n\t\t\tcin >> search[i];\n\t\t}\n\t\tint act[2];\n\t\tfor (int j = 0; j < time; ++j) {\n\t\t\tvector<int> dommy;\n\t\t\tfor (int i = 0; i < 2; ++i) {\n\t\t\t\tcin >> act[i];\n\t\t\t}\n\t\t\tdommy.insert(dommy.end(), line.begin() + act[1], line.end());\n\t\t\tdommy.insert(dommy.end(), line.begin() + act[0], line.begin() + act[1]);\n\t\t\tdommy.insert(dommy.end(), line.begin(), line.begin() + act[0]);\n\t\t\tline = dommy;\n\t\t}\n\t\tint answer = 0;\n\t\tfor (int i = search[0] - 1; i < search[1]; ++i) {\n\t\t\tif (line[i] <= search[2]) {\n\t\t\t\t++answer;\n\t\t\t}\n\t\t}\n\t\tcout << answer << endl;\n\t}\n\treturn 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include<iostream>\nusing namespace std;\nint main() {\n\tint n;\n\twhile (cin >> n&&n != 0) {\n\t\tint *line;\n\t\tline = new int[n];\n\t\tfor (int i = 0; i < n; ++i) {\n\t\t\tline[i] = i + 1;\n\t\t}\n\t\tint search[3];\n\t\tint act[2];\n\t\tint time;\n\t\tcin >> time;\n\t\tfor (int i = 0; i < 3; ++i) {\n\t\t\tcin >> search[i];\n\t\t}\n\t\tint *dommy;\n\t\tfor (int i = 0; i < time; ++i) {\n\t\t\tint nsize = 0;\n\t\t\tdommy = new int[n];\n\t\t\tfor (int j = 0; j < 2; ++j) {\n\t\t\t\tcin >> act[j];\n\t\t\t}\n\t\t\tfor (int j = act[1]; j < n; ++j) {\n\t\t\t\tdommy[nsize] = line[j];\n\t\t\t\t++nsize;\n\t\t\t}\n\t\t\tfor (int j = act[0]; j < act[1]; ++j) {\n\t\t\t\tdommy[nsize] = line[j];\n\t\t\t\t++nsize;\n\t\t\t}\n\t\t\tfor (int j = 0; j < act[0]; ++j) {\n\t\t\t\tdommy[nsize] = line[j];\n\t\t\t\t++nsize;\n\t\t\t}\n\t\t\tdelete line;\n\t\t\tline = dommy;\n\t\t}\n\t\tint answer = 0;\n\t\tfor (int i = search[0] - 1; i < search[1]; ++i) {\n\t\t\tif (line[i] <= search[2]) {\n\t\t\t\t++answer;\n\t\t\t}\n\t\t}\n\t\tcout << answer << endl;\n\t\tdelete line;\n\t}\n\treturn 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include<iostream>\n#include<vector>\n#include<string>\n#include<algorithm>\t\n#include<map>\n#include<set>\n#include<utility>\n#include<cmath>\n#include<cstring>\n#include<queue>\n#include<cstdio>\n#include<sstream>\n#include<iomanip>\n#define loop(i,a,b) for(int i=a;i<b;i++) \n#define rep(i,a) loop(i,0,a)\n#define pb push_back\n#define mp make_pair\n#define all(in) in.begin(),in.end()\n#define shosu(x) fixed<<setprecision(x)\nusing namespace std;\n//kaewasuretyuui\ntypedef long long ll;\ntypedef pair<int,int> pii;\ntypedef vector<int> vi;\ntypedef vector<vi> vvi;\ntypedef vector<pii> vp;\ntypedef vector<vp> vvp;\ntypedef pair<int,pii> pip;\ntypedef vector<pip>vip;\nconst double PI=acos(-1);\nconst double EPS=1e-8;\nconst int inf=1<<30;\n//aoj 0536\nint main(){\n\tint n;\n\twhile(cin>>n,n){\n\t\tvp in(1);\n\t\tin[0]=pii(0,n);\n\t\tint m;\n\t\tcin>>m;\n\t\tint p,q,r;\n\t\tcin>>p>>q>>r;\n\t\twhile(m--){\n\t\t\tint a,b;\n\t\t\tcin>>a>>b;\n\t\t\tvp t1,t2,tmp;\n\t\t\tint c=0;\n\t\t\twhile(a){\n\t\t\t\tif(in[c].second<=a){\n\t\t\t\t\ta-=in[c].second;\n\t\t\t\t\tb-=in[c].second;\n\t\t\t\t\tt1.pb(in[c]);\n\t\t\t\t\tc++;\n\t\t\t\t}else{\n\t\t\t\t\tpii p(in[c].first,a);\n\t\t\t\t\tin[c].first+=a;\n\t\t\t\t\tin[c].second-=a;\n\t\t\t\t\tt1.pb(p);\n\t\t\t\t\tb-=a;\n\t\t\t\t\tbreak;\n\t\t\t\t}\n\t\t\t}\n//\t\t\trep(i,t1.size())cout<<t1[i].first<<\" \"<<t1[i].second<<endl;\n//\t\t\tcout<<endl;\n\t\t\twhile(b){\n\t\t\t\tif(in[c].second<=b){\n\t\t\t\t\tb-=in[c].second;\n\t\t\t\t\tt2.pb(in[c]);\n\t\t\t\t\tc++;\n\t\t\t\t}else{\n\t\t\t\t\tpii p(in[c].first,b);\n\t\t\t\t\tin[c].first+=b;\n\t\t\t\t\tin[c].second-=b;\n\t\t\t\t\tt2.pb(p);\n\t\t\t\t\tbreak;\n\t\t\t\t}\n\t\t\t}\n\t\t\twhile(c!=in.size())tmp.pb(in[c++]);\n\t\t\trep(i,t2.size())tmp.pb(t2[i]);\n\t\t\trep(i,t1.size())tmp.pb(t1[i]);\n\t\t\tin=tmp;\n\t\t}\n\t\tint co=0;\n\t\tm=0;\n\t\tp--;\n\t\trep(i,in.size()){\n\t\t\tif(m+in[i].second<p||q<m);\n\t\t\telse{\n\t\t\t\tint a=in[i].first+max(p,m)-m;\n\t\t\t\tint b=min(q,m+in[i].second)-max(p,m);\n\t\t\t\tco+=min(b,max(0,r-a));\n\t\t\t}\n\t\t\tm+=in[i].second;\n\t\t}\n\t\tcout<<co<<endl;\n\t}\n}\n//aoj 0534\n/*vp tmp;\nint r,l,co;\nvoid f(){\n\twhile(1){\n\t\tif(r<0||l>=tmp.size())return;\n\t\tint t=tmp[r].second+tmp[l].second;\n\t\tif(tmp[r].first==tmp[l].first&&t>=4){\n\t\t\tco+=t;\n\t\t\tr--;l++;\n\t\t}else break;\n\t}\n}\nint main(){\n\tint n;\n\tcin>>n;\n\tvi q(n);\n\tvp in;\n\trep(i,n)cin>>q[i];\n\tq.pb(0);\n\tloop(i,1,n+1){\n\t\tif(q[i]!=q[i-1]){\n\t\t\tin.pb(pii(q[i-1],co));\n\t\t\tco=1;\n\t\t}else co++;\n\t}\n\tint out=0;\n\trep(i,in.size())if(in[i].second==3){\n\t\tif(i){\n\t\t\ttmp=in;\n\t\t\ttmp[i-1].second--;\n\t\t\tr=i-1;l=i+1;\n\t\t\tco=4;\n\t\t\tif(tmp[i-1].second==0){\n\t\t\t\tr-=2;\n\t\t\t\tif(i>1)co+=tmp[i-2].second;\n\t\t\t}\n\t\t\tf();\n\t\t\tout=max(out,co);\n\t\t}\n\t\tif(i!=in.size()-1){\n\t\t\ttmp=in;\n\t\t\ttmp[i+1].second--;\n\t\t\tr=i-1;l=i+1;\n\t\t\tco=4;\n\t\t\tif(tmp[i+1].second==0){\n\t\t\t\tl+=2;\n\t\t\t\tif(i<in.size()-2)co+=tmp[i+2].second;\n\t\t\t}\n\t\t\tf();\n\t\t\tout=max(out,co);\n\t\t}\n\t}\n\tcout<<n-out<<endl;\n}\n*/"
  },
  {
    "language": "C++",
    "code": "#include<bits/stdc++.h>\nusing namespace std;\n#define h first\n#define w second\nvector<pair<bool,pair<int,int> > >v;\nint n,m,p,q,r,i;\nvoid Vp(bool a,int b,int c){v.push_back(make_pair(a,make_pair(b,c)));}\nint main(){\n\twhile(cin>>n&&n){\n\tcin>>m>>p>>q>>r;v.clear();\n\tVp(1,1,r);Vp(0,r+1,n);\n\twhile(m--){\n\t\tint x,y;scanf(\"%d%d\",&x,&y);\n\t\tfor(i=0;i<v.size();i++){\n\t\t\tint a=v[i].w.h,b=v[i].w.w;bool c=v[i].h;\n\t\t\tif(a<=x&&x<b){Vp(c,x+1,b);b=x;}\n\t\t\tif(a<=y&&y<b){Vp(c,y+1,b);b=y;}\n\t\t\tif(0<a&&b<=x)a+=n-x,b+=n-x;\n\t\t\telse if(x<a&&b<=y)a+=n-x-y,b+=n-x-y;\n\t\t\telse if(y<a&&b<=n)a-=y,b-=y;\n\t\t\tv[i].w.h=a,v[i].w.w=b;\n\t\t}\n\t}n=0;\n\tfor(i=0;i<v.size();i++)if(v[i].h)n+=max(0,1+min(v[i].w.w,q)-max(v[i].w.h,p));\n\tcout<<n<<endl;\n\t}\n\treturn 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include <iostream>\n#include <vector>\n#include <deque>\n\nusing namespace std;\n\n#define fst first\n#define scd second\n#define PB push_back\n#define omajinai ios::sync_with_stdio(false);cin.tie(0)\n#define rep(i,x) for(int i=0;i<(int)(x);++i)\n\nusing pii = pair<int, int>;\nusing vpii = vector<pii>;\n\nint n, m, p, q, r;\n\nint calc(pii seg, int n) // n=seg.fst????????????????????????\n{\n\tint len = seg.scd - seg.fst + 1; // seg?????????\n\n\tif (n < p && p <= n + len - 1) {\n\t\tint a = (n + len - 1) - p;\n\n\t\treturn calc(pii(seg.scd - a, seg.scd), p);\n\t}\n\n\tif (p <= n && n + len - 1 <= q) {\n\t\treturn max(min(r - seg.fst + 1, len), 0);\n\t}\n\n\tif (n <= q && q < n + len - 1) {\n\t\tint a = q - n;\n\n\t\treturn calc(pii(seg.fst, seg.fst + a), n);\n\t}\n\n\treturn 0;\n}\n\nint main()\n{\n\tomajinai;\n\n\twhile (cin >> n >> m >> p >> q >> r, n) {\n\t\tdeque<pii> dat;\n\n\t\tdat.push_back(pii(1, n));\n\n\t\trep(_, m) {\n\t\t\tint x, y; cin >> x >> y;\n\n\t\t\tint sum = 0;\n\n\t\t\tvpii Top, Mid, Bottom;\n\n\t\t\t// Top?????????\n\t\t\twhile (true) {\n\t\t\t\tpii a = dat.front();\n\n\t\t\t\tint v = a.scd - a.fst + 1;\n\n\t\t\t\tif (sum + v >= x) {\n\t\t\t\t\tint dif = x - sum-1;\n\n\t\t\t\t\tsum += dif + 1;\n\n\t\t\t\t\tTop.push_back(pii(a.fst, a.fst + dif));\n\n\t\t\t\t\tdat.pop_front();\n\n\t\t\t\t\tif (a.fst + dif + 1 <= a.scd) dat.push_front(pii(a.fst + dif + 1, a.scd));\n\n\t\t\t\t\tbreak;\n\t\t\t\t} else {\n\t\t\t\t\tTop.PB(a);\n\t\t\t\t\tsum += v;\n\t\t\t\t}\n\n\t\t\t\tdat.pop_front();\n\t\t\t}\n\n\t\t\t// Mid?????????\n\t\t\twhile (true) {\n\t\t\t\tpii a = dat.front();\n\n\t\t\t\tint v = a.scd - a.fst + 1;\n\n\t\t\t\tif (sum + v >= y) {\n\t\t\t\t\tint dif = y - sum-1;\n\n\t\t\t\t\tsum += dif + 1;\n\n\t\t\t\t\tMid.push_back(pii(a.fst, a.fst + dif));\n\n\t\t\t\t\tdat.pop_front();\n\n\t\t\t\t\tif (a.fst + dif + 1 <= a.scd) dat.push_front(pii(a.fst + dif + 1, a.scd));\n\n\t\t\t\t\tbreak;\n\t\t\t\t} else {\n\t\t\t\t\tMid.PB(a);\n\t\t\t\t\tsum += v;\n\t\t\t\t}\n\t\t\t\tdat.pop_front();\n\t\t\t}\n\n\t\t\t// Bottom?????????\n\t\t\twhile (true) {\n\t\t\t\tpii a = dat.front();\n\n\t\t\t\tint v = a.scd - a.fst + 1;\n\n\t\t\t\tif (sum + v == n) {\n\t\t\t\t\tsum += v;\n\n\t\t\t\t\tBottom.push_back(pii(a.fst, a.scd));\n\n\t\t\t\t\tdat.pop_front();\n\n\t\t\t\t\tbreak;\n\t\t\t\t} else {\n\t\t\t\t\tBottom.PB(a);\n\t\t\t\t\tsum += v;\n\t\t\t\t}\n\n\t\t\t\tdat.pop_front();\n\t\t\t}\n\n\t\t\trep(i, Bottom.size()) dat.push_back(Bottom[i]);\n\t\t\trep(i, Mid.size()) dat.push_back(Mid[i]);\n\t\t\trep(i, Top.size()) dat.push_back(Top[i]);\n\t\t}\n\n\t\tint sum = 1;\n\t\tint ans = 0;\n\n\t\tfor (pii a : dat) {\n\t\t\tans += calc(a, sum);\n\t\t\tsum += a.scd - a.fst + 1;\n\t\t}\n\n\t\tcout << ans << endl;\n\t}\n}"
  },
  {
    "language": "C++",
    "code": "#include <iostream>\n#include <algorithm>\n#include <vector>\nusing namespace std;\nint main(){\n\tint n,m,p,q,r,x,y;\n\tvector<int>::iterator itx,ity,it;\n\tfor(;cin>>n>>m>>p>>q>>r;cout<<x<<endl){\n\t\tvector<int> v1,v2;\n\t\tv1.push_back(0);\n\t\tfor(v1.push_back(r);m--;v2.clear()){\n\t\t\tcin>>x>>y;\n\t\t\titx=upper_bound(v1.begin(),v1.end(),x);\n\t\t\tity=upper_bound(v1.begin(),v1.end(),y);\n\t\t\t\n//\t\t\tif( ity-v1.begin()+1 & 1 )v2.push_back(0);\n//\t\t\tv2.push_back(0);\n\t\t\tv2.insert(v2.end(),ity-v1.begin()&1?1:2,0);\n\t\t\tfor(it=ity;it!=v1.end();++it)\n\t\t\t\tv2.push_back(*it - y);\n\t\t\t\n\t\t\tif(v1.end()-itx & 1)v2.push_back(n-y);\n\t\t\tfor(it=itx;it!=ity;++it)\n\t\t\t\tv2.push_back(*it-x+n-y);\n\t\t\t\n\t\t\tit = v1.begin();\n\t\t\tif(ity-v1.begin() & 1)++it;\n\t\t\tif(!it[1])it+=2;\n\t\t\tif(*it+n-x==v2.back()){++it;v2.pop_back();}\n\t\t\tfor(;it!=itx;++it)\n\t\t\t\tv2.push_back(*it+n-x);\n\t\t\t\n\t\t\tv1.swap(v2);\n\t\t}\n\t\tv1.insert( upper_bound(v1.begin(),v1.end(),p-1), 2, p-1);\n\t\tv1.insert( lower_bound(v1.begin(),v1.end(),q), q );\n\t\tv1.push_back(n);\n\t\tit = upper_bound(v1.begin(),v1.end(),p-1);\n\t\tif(it-v1.begin() & 1) --it;\n\t\tfor(x=0;*it<q;it+=2)\n\t\t\tx+=it[1]-*it;\n\t}\n}"
  },
  {
    "language": "C++",
    "code": "#include<iostream>\n#include<string>\n#include<cmath>\n#include<queue>\n#include<map>\n#include<set>\n#include<list>\n#include<iomanip>\n#include<vector>\n#include<functional>\n#include<algorithm>\n#include<cstdio>\n#include<unordered_map>\nusing namespace std;\n//---------------------------------------------------\n//????????????????????????????????????\n//#define int long long\n#define str string\n#define rep(i,j) for(int i=0;i<(int)(j);i++)\ntypedef long long ll;\ntypedef long double ld;\nconst ll inf = 4523372036854775807;\nconst int inf2 = 1145141919;\nconst ld pi = 3.14159265358979323846264338327950288419716939937510582097494459230781640628620899;\nstruct P {\n\tll pos, cost;\n};\nbool operator<(P a, P b) { return a.cost < b.cost; }\nbool operator>(P a, P b) { return a.cost > b.cost; }\nstruct B {//??£??\\???????????¨???\n\tll to, cost;\n};\nstruct S {//???????????±?????\\???????????°\n\tint from, to, cost;\n};\nbool operator<(S a, S b) { return a.cost < b.cost; }\nbool operator>(S a, S b) { return a.cost > b.cost; }\nstruct H {\n\tint x, y;\n};\nll gcm(ll i, ll j) {//?????§??¬?´???°\n\tif (i > j) swap(i, j);\n\tif (i == 0) return j;\n\treturn gcm(j%i, i);\n}\nld rad(ld a, ld b, ld c, ld d) {\n\treturn sqrt(pow(a - c, 2) + pow(b - d, 2));\n}//rad?????§?¨???????2??????????????¢\n //---------------------------------------------------\n //+++++++++++++++++++++++++++++++++++++++++++++++++++\nstruct A {\n\tint s, e, s2, size;\n\t//????????????????????????????????????????????????????????????????????????\n};\nint n, m, p, q, r;\nvector<A>a[2];\nvector<int>b[2];\nsigned main() {\n\twhile (cin >> n) {\n\t\tcin >> m >> p >> q >> r;\n\t\ta[0].clear(); a[1].clear();\n\t\tb[0].clear(); b[1].clear();\n\t\tint d = 0, e = 1, x, y;\n\t\ta[0].push_back(A{ 1,n,1,n });\n\t\tb[0].push_back(1);\n\t\tfor (int z = 0; z < m; z++) {\n\t\t\ta[e].clear(); b[e].clear();\n\t\t\tcin >> x >> y;\n\t\t\tint k = lower_bound(b[d].begin(), b[d].end(), y + 1) - b[d].begin(), t;\n\t\t\tif (k == a[d].size() || a[d][k].s2 > y + 1) k--;\n\t\t\ta[e].push_back(A{ (y + 1 - a[d][k].s2) + a[d][k].s,a[d][k].e,1,a[d][k].size - (y + 1 - a[d][k].s2) });\n\t\t\tb[e].push_back(1);\n\t\t\tint sum = a[d][k].size - (y + 1 - a[d][k].s2) + 1;\n\t\t\tk++;\n\t\t\tfor (; k < a[d].size(); k++) {\n\t\t\t\tb[e].push_back(sum);\n\t\t\t\ta[e].push_back(A{ a[d][k].s,a[d][k].e,sum,a[d][k].size });\n\t\t\t\tsum += (a[d][k].size);\n\t\t\t}\n\t\t\tk = lower_bound(b[d].begin(), b[d].end(), x + 1) - b[d].begin();\n\t\t\tt = lower_bound(b[d].begin(), b[d].end(), y) - b[d].begin();\n\t\t\tif (k == b[d].size() || a[d][k].s2 > x + 1)k--;\n\t\t\tif (t == b[d].size() || a[d][t].s2 > y)t--;\n\t\t\tif (k == t) {\n\t\t\t\tb[e].push_back(sum);\n\t\t\t\ta[e].push_back(A{ a[d][k].s + (x + 1 - a[d][k].s2),a[d][k].s + (y - a[d][k].s2),sum,(y - x) });\n\t\t\t\tsum += (y - x);\n\t\t\t}\n\t\t\telse {\n\t\t\t\tb[e].push_back(sum);\n\t\t\t\ta[e].push_back(A{ a[d][k].s + (x + 1 - a[d][k].s2),a[d][k].e,sum, a[d][k].e - (a[d][k].s + x - a[d][k].s2) });\n\t\t\t\tsum += (x - a[d][k].s2 + 1);\n\t\t\t\tk++;\n\t\t\t\tfor (; k < t; k++) {\n\t\t\t\t\tb[e].push_back(sum);\n\t\t\t\t\ta[e].push_back(A{ a[d][k].s,a[d][k].e,sum,a[d][k].size });\n\t\t\t\t\tsum += a[d][k].size;\n\t\t\t\t}\n\t\t\t\tb[e].push_back(sum);\n\t\t\t\ta[e].push_back(A{ a[d][t].s, a[d][t].s + (y - a[d][t].s2), sum, (y - a[d][t].s2 + 1) });\n\t\t\t\tsum += (y - a[d][t].s2 + 1);\n\t\t\t}\n\t\t\tk = lower_bound(b[d].begin(), b[d].end(), x) - b[d].begin();\n\t\t\tif (k == a[d].size() || a[d][k].s2 > x) k--;\n\t\t\tfor (int i = 0; i < k; i++) {\n\t\t\t\tb[e].push_back(sum);\n\t\t\t\ta[e].push_back(A{ a[d][i].s, a[d][i].e, sum, a[d][i].size });\n\t\t\t\tsum += a[d][i].size;\n\t\t\t}\n\t\t\tb[e].push_back(sum);\n\t\t\ta[e].push_back(A{ a[d][k].s,a[d][k].s + (x - a[d][k].s2),sum,x - a[d][k].s2 + 1 });\n\t\t\tswap(d, e);\n\t\t}\n\t\tint k = lower_bound(b[d].begin(), b[d].end(), p) - b[d].begin();\n\t\tint t = lower_bound(b[d].begin(), b[d].end(), q) - b[d].begin();\n\t\tif (k == a[d].size() || a[d][k].s2 > p) k--;\n\t\tif (t == a[d].size() || a[d][t].s2 > q) t--;\n\t\tint sum = 0;\n\t\tif (k == t) {\n\t\t\ta[d][k].size = q - p + 1;\n\t\t\ta[d][k].e = a[d][k].s + (q - a[d][k].s2);\n\t\t\ta[d][k].s = a[d][k].s + (p - a[d][k].s2);\n\t\t\tif (a[d][k].e <= r)\n\t\t\t\tsum = a[d][k].size;\n\t\t\telse if (a[d][k].e <= r)\n\t\t\t\tsum = r - a[d][k].s + 1;\n\t\t}\n\t\telse {\n\t\t\ta[d][k].size -= (p - a[d][k].s2);\n\t\t\ta[d][k].s = a[d][k].s + (p - a[d][k].s2);\n\t\t\ta[d][t].size = (q - a[d][t].s2 + 1);\n\t\t\ta[d][t].e = a[d][t].s + (q - a[d][t].s2);\n\t\t\tfor (; k <= t; k++) {\n\t\t\t\tif (a[d][k].e <= r)\n\t\t\t\t\tsum += a[d][k].size;\n\t\t\t\telse if (a[d][k].s <= r)\n\t\t\t\t\tsum += r - a[d][k].s + 1;\n\t\t\t}\n\t\t}\n\t\tcout << sum << endl;\n\t}\n\tgetchar(); getchar();\n}"
  },
  {
    "language": "C++",
    "code": "#include<cstdio>\n#include<vector>\n\n#define rep(i,n) for(int i=0;i<(n);i++)\n\nusing namespace std;\n\nstruct Interval{\n\tint a,b;\n\tInterval(){}\n\tInterval(int A,int B):a(A),b(B){}\n};\n\ninline int intersect(const Interval &I,const Interval &J){\n\treturn max(min(I.b,J.b)-max(I.a,J.a)+1,0);\n}\n\nint main(){\n\tfor(int n,m,q1,q2,q3;scanf(\"%d%d%d%d%d\",&n,&m,&q1,&q2,&q3),n;){\n\t\tvector<Interval> I;\n\t\tI.push_back(Interval(1,n));\n\t\twhile(m--){\n\t\t\t// A B C Éª\n\t\t\tint x,y; scanf(\"%d%d\",&x,&y);\n\n\t\t\t// ¶[ðTµÄª\n\t\t\tint pl;\n\t\t\tfor(int i=0,j=1;;i++){\n\t\t\t\tint w=I[i].b-I[i].a;\n\t\t\t\tif(x+1<=j+w){\n\t\t\t\t\tif(j<x+1){\n\t\t\t\t\t\tI.insert(I.begin()+i+1,Interval(I[i].a+(x+1)-j,I[i].b));\n\t\t\t\t\t\tI[i].b=I[i].a+x-j;\n\t\t\t\t\t\tpl=i+1;\n\t\t\t\t\t}\n\t\t\t\t\telse pl=i;\n\t\t\t\t\tbreak;\n\t\t\t\t}\n\t\t\t\tj+=w+1;\n\t\t\t}\n\n\t\t\t// E[ðTµÄª\n\t\t\tint pr;\n\t\t\tfor(int i=0,j=1;;i++){\n\t\t\t\tint w=I[i].b-I[i].a;\n\t\t\t\tif(y<=j+w){\n\t\t\t\t\tif(y<j+w){\n\t\t\t\t\t\tI.insert(I.begin()+i+1,Interval(I[i].a+(y+1)-j,I[i].b));\n\t\t\t\t\t\tI[i].b=I[i].a+y-j;\n\t\t\t\t\t}\n\t\t\t\t\tpr=i+1;\n\t\t\t\t\tbreak;\n\t\t\t\t}\n\t\t\t\tj+=w+1;\n\t\t\t}\n\n\t\t\tvector<Interval> next(I.size());\n\t\t\tint ii=0,nn=I.size();\n\t\t\tfor(int i=pr;i<nn;i++) next[ii++]=I[i];\n\t\t\tfor(int i=pl;i<pr;i++) next[ii++]=I[i];\n\t\t\tfor(int i= 0;i<pl;i++) next[ii++]=I[i];\n\t\t\trep(i,nn) I[i]=next[i];\n\t\t}\n\n\t\tint ans=0;\n\t\tfor(int i=0,j=1;i<I.size();i++){\n\t\t\tint w=I[i].b-I[i].a;\n\t\t\tans+=intersect(Interval(q1,q2),Interval(j,j+min(q3,I[i].b)-I[i].a));\n\t\t\tj+=w+1;\n\t\t}\n\t\tprintf(\"%d\\n\",ans);\n\t}\n\n\treturn 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include <iostream>\n#include <cstdio>\n#include <cstring>\n#include <cstdlib>\n#include <cmath>\n#include <vector>\n#include <string>\n#include <map>\n#include <set>\n#include <queue>\n#include <stack>\n#include <algorithm>\n#include <deque>\n \nusing namespace std;\n \n#define rep(i,j) REP((i), 0, (j))\n#define REP(i,j,k) for(int i=(j);(i)<(k);++i)\n#define BW(a,x,b) ((a)<=(x)&&(x)<=(b))\n#define ALL(v) (v).begin(), (v).end()\n#define LENGTHOF(x) (sizeof(x) / sizeof(*(x)))\n#define AFILL(a, b) fill((int*)a, (int*)(a + LENGTHOF(a)), b)\n#define SQ(x) ((x)*(x))\n#define Mod(x, mod) (((x)+(mod)%(mod))\n#define MP make_pair\n#define PB push_back\n#define F first\n#define S second\n#define INF 1 << 30\n#define EPS 1e-10\n#define MOD 1000000007\n \ntypedef pair<int, int> pi;\ntypedef pair<int, pi> pii;\ntypedef vector<int> vi;\ntypedef queue<int> qi;\ntypedef long long ll;\n \ndeque<pi>vec, a, b, c;\nint N, M, P, Q, R;\n \nint cnt(int p, int q, int r){\n  if(p > r) return 0;\n  if(r >= q) return q-p+1;\n  return r-p+1;\n}\n \nint countR(int p, int q, int r){\n  int n = 1, vp, res = 0;\n  for(vp=0;vp<vec.size();vp++){\n    int f = vec[vp].F, l = vec[vp].S;\n    int c = l-f+1;\n    if(n <= p){\n      if(n+c < p){\n      }\n      else if(n + c > q){\n    res += cnt(f+p-n, f+q-n, r);\n      }else{\n    res += cnt(f+p-n, l, r);\n      }\n      n += c;\n    }else if(n <= q){\n      if(n+c<=q){\n    res += cnt(f, l, r);\n      }else{\n    res += cnt(f, f+q-n, r);\n      }\n      n += c;\n    }\n  }\n  return res;\n}\n \n \nint main(){\n  while(1){\n    cin >> N;\n    if(!N) break;\n    cin >> M >> P >> Q >> R;\n    vec.clear();\n    vec.push_back(MP(1,N));\n    int x, y;\n    rep(i, M){\n      cin >> x >> y;\n      a.clear(); b.clear();\n      int p=1;\n      while(p<=x){\n    int f = vec[0].F, s = vec[0].S;\n    if(p+s-f<=x){\n      a.push_back(MP(f,s));\n      p += s-f+1;\n      vec.pop_front();\n    }else if(p+s-f>x){\n      a.push_back(MP(f, f+x-p));\n      vec[0].F = f+x-p+1;\n      p = x+1;\n    }\n      }\n      while(p<=y){\n    int f = vec[0].F, s = vec[0].S;\n    if(p+s-f<=y){\n      b.push_back(MP(f, s));\n      p += s-f+1;\n      vec.pop_front();\n    }else if(p+s-f>y){\n      b.push_back(MP(f, f+y-p));\n      vec[0].F = f+y-p+1;\n      p = y+1;\n    }\n      }\n \n      vec.insert(vec.end(), b.begin(), b.end());\n      vec.insert(vec.end(), a.begin(), a.end());\n \n    }\n \n \n    /*    rep(i, vec.size()){\n      for(int j=vec[i].F;j<=vec[i].S;j++) cout << j << endl;;\n      }*/\n    cout << countR(P, Q, R) << endl;\n  }\n}\n"
  },
  {
    "language": "C++",
    "code": "#include <cstdio>\n#include <algorithm>\n#include <queue>\nusing namespace std;\ntypedef pair<int,int> P;\n#define mp make_pair\n#define f first\n#define s second\nint main(){\nwhile(1){\nint n,m,p,q,r;\nqueue<P>que;\nscanf(\"%d\",&n);\nif(!n) break;\nscanf(\"%d\",&m);\nscanf(\"%d %d %d\",&p,&q,&r);\nque.push(mp(1,r));\nfor(int i=0;i<m;i++){\n\tint x,y;\n\tscanf(\"%d %d\",&x,&y);\n\tint e=que.size();\n\tfor(int j=0;j<e;j++){\n\t\tP pp=que.front(); que.pop();\n\t\tint a=pp.f,b=pp.s;\n\t\tif(b<=x){\n\t\t\tque.push(mp(n-x+a,n-x+b));\n\t\t}else if(b>x && b<=y){\n\t\t\tif(a<=x){\n\t\t\t\tque.push(mp(n-x+a,n));\n\t\t\t\tque.push(mp(n-y+1,n+b-x-y));\n\t\t\t}else{\n\t\t\t\tque.push(mp(n-y+a-x,n+b-x-y));\n\t\t\t}\n\t\t}else{\n\t\t\tif(a<=x){\n\t\t\t\tque.push(mp(1,b-y));\n\t\t\t\tque.push(mp(n-x+a,n));\n\t\t\t\tque.push(mp(n-y+1,n-x));\n\t\t\t}else if(a>x && a<=y){\n\t\t\t\tque.push(mp(1,b-y));\n\t\t\t\tque.push(mp(n-y-x+a,n-x));\n\t\t\t}else{\n\t\t\t\tque.push(mp(a-y,b-y));\n\t\t\t}\n\t\t}\n\t}\n}\nint ans=0;\nwhile(que.size()){\nP pp=que.front(); que.pop();\nif(pp.s<p || pp.f>q){\ncontinue;\n}else if(pp.f<q){\nans+=q-pp.f+1;\n}else{\nans+=pp.s-p+1;\n}\n}\nprintf(\"%d\\n\",ans);\nans=0;\n}\nreturn 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include <set>\n#include <map>\n#include <list>\n#include <queue>\n#include <stack>\n#include <cmath>\n#include <ctime>\n#include <cstdio>\n#include <vector>\n#include <string>\n#include <bitset>\n#include <cctype>\n#include <cstdlib>\n#include <cstring>\n#include <utility>\n#include <numeric>\n#include <complex>\n#include <sstream>\n#include <fstream>\n#include <iomanip>\n#include <cassert>\n#include <iostream>\n#include <iterator>\n#include <algorithm>\n\nusing namespace std;\n\n//4方向ベクトル→↑←↓\nint dx[4] ={1,0,-1,0};\nint dy[4] ={0,-1,0,1};\n\nvector<int> Card;\nvector<int> Cardtemp;\nunsigned long n;//カードの枚数\nint m;//シャッフルの回数\nint x,y;//シャッフルする(x,y)\nunsigned long p,q,r;//p行q行以下に番号r以下のカードが何枚含まれているか\nint main()\n{\n  while(1){\n  scanf(\"%lu\",&n);\n  if(n==0)\n    break;\n  scanf(\"%d\",&m);\n  scanf(\"%lu %lu %lu\",&p,&q,&r);\n  Card.clear();\n  Cardtemp.clear();\n  for(int i = 1;i <=n;i++){\n    Card.push_back(i);\n  }\n  unsigned long ans = 0;\n  for(int i = 1;i <=m;i++){\n    Cardtemp = Card;\n    scanf(\"%d %d\",&x,&y);\n    for(int j = 0;j <=n-(y+1);j++){\n      Card[j] = Cardtemp[y+j];\n    }\n    for(int j = 0;j <=y-(x+1);j++){\n      Card[n-y+j] = Cardtemp[x+j];\n\t}\n    for(int j = 0;j <=x-1;j++){\n      Card[n-x+j] = Cardtemp[j];\n    }\n  }\n  for(int i = p-1;i < q;i++){\n    if(Card[i] <= r)\n      ans++;\n  }\n  cout <<ans<<endl;\n  }\n  return 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include<cstdio>\n#include<cmath>\n#include<algorithm>\n#include<iostream>\n#include<vector>\n#include<stack>\n#include<queue>\n\n#define rep(i,n) for(int i = 0; i < n; i++)\n\nusing namespace std;\n\nint memo[50000][2];\nint cpy[50000][2];\nint cnt;\n\nvoid func(int x, int y){\n\t//3分割して、copyに入れなおす。\n\tint flg = 0;\n\tint total = 0;\n\tint cn = 0;\n\trep(i,cnt){\n\t\tint n = memo[i][1]-memo[i][0]+1;\n\t\tif(total + n > y && flg == 0){\n\t\t\tcpy[cn][0] = memo[i][0] + y - total;\n\t\t\tcpy[cn][1] = memo[i][1];\n\t\t\tmemo[i][1] = memo[i][0] + y - total - 1;\n\t\t\tcn++;\n\t\t\tflg = 1;\n\t\t}else if(flg && n >= 1){\n\t\t\tcpy[cn][0] = memo[i][0];\n\t\t\tcpy[cn][1] = memo[i][1];\n\t\t\tmemo[i][0] = 0;\n\t\t\tmemo[i][1] = -1;\n\t\t\tcn++;\n\t\t}else{\n\t\t\ttotal += n;\n\t\t}\n\t}\n\tflg = 0;\n\ttotal = 0;\n\trep(i,cnt){\n\t\tint n = memo[i][1]-memo[i][0]+1;\n\t\tif(total + n > x && flg == 0){\n\t\t\tcpy[cn][0] = memo[i][0] + x - total;\n\t\t\tcpy[cn][1] = memo[i][1];\n\t\t\tmemo[i][1] = memo[i][0] + x - total - 1;\n\t\t\tcn++;\n\t\t\tflg = 1;\n\t\t}else if(flg && n >= 1){\n\t\t\tcpy[cn][0] = memo[i][0];\n\t\t\tcpy[cn][1] = memo[i][1];\n\t\t\tmemo[i][0] = 0;\n\t\t\tmemo[i][1] = -1;\n\t\t\tcn++;\n\t\t}else{\n\t\t\ttotal += n;\n\t\t}\n\t}\n\trep(i,cnt){\n\t\tint n = memo[i][1]-memo[i][0]+1;\n\t\tif(n >= 1){\n\t\t\tcpy[cn][0] = memo[i][0];\n\t\t\tcpy[cn][1] = memo[i][1];\n\t\t\tmemo[i][0] = -1;\n\t\t\tmemo[i][1] = -1;\n\t\t\tcn++;\n\t\t}\n\t}\n\tcnt = cn;\n\trep(i,cnt){\n\t\tmemo[i][0] = cpy[i][0];\n\t\tmemo[i][1] = cpy[i][1];\n\t}\n}\n\nint solve(int p, int q, int r){\n\tint ans = 0;\n\tint total = 0;\n\tint flg = 0;\n\trep(i,cnt){\n\t\tint n = memo[i][1] - memo[i][0] + 1;\n\t\tif(total + n >= p && flg == 0){\n\t\t\tmemo[i][0] = memo[i][0] + p-total-1;\n\t\t\tflg = 1;\n\t\t}\n\t\tif(total + n > q && flg == 1){\n\t\t\tmemo[i][1] = memo[i][0] + q-total-1;\n\t\t\tflg = 2;\n\t\t}\n\t\tif(flg){\n\t\t\tif(memo[i][0] <= r){\n\t\t\t\tif(memo[i][1] <= r){\n\t\t\t\t\tans += memo[i][1]-memo[i][0]+1;\n\t\t\t\t}else{\n\t\t\t\t\tans += r-memo[i][0]+1;\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t\t//cout << \"ans:\" << ans << endl;\n\t\tif(flg==2)break;\n\t\ttotal += n;\n\t}\n\treturn ans;\n}\n\nint main(void){\n\tint n;\n\tint ans;\n\twhile(scanf(\"%d\", &n), n){\n\t\tint m;\n\t\tint p, q, r;\n\t\tint flg = 0;\n\t\tcnt = 0;\n\t\t\n\t\tscanf(\"%d\", &m);\n\t\tscanf(\"%d %d %d\", &p, &q, &r);\n\t\t\n\t\trep(i,50000)rep(j,2)memo[i][j] = 0;\n\t\t\n\t\tmemo[cnt][0] = 1;\n\t\tmemo[cnt][1] = n;\n\t\tcnt++;\n\t\trep(i,m){\n\t\t\tint x,y;\n\t\t\tscanf(\"%d %d\", &x, &y);\n\t\t\tint total = 0;\n\t\t\t\n\t\t\tfunc(x,y);\n\t\t\t/*\n\t\t\trep(j,cnt){\n\t\t\t\tcout << memo[j][0] << \",\" << memo[j][1] << endl;\n\t\t\t}\n\t\t\t*/\n\t\t}\n\t\t\n\t\tans  = solve(p,q,r);\n\t\tprintf(\"%d\\n\", ans);\n\t\t\n\t}\n\treturn 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include <cstdio>\n#include <cstdlib>\n#include <cstring>\n#include <cmath>\n#include <climits>\n#include <cfloat>\n#include <ctime>\n#include <map>\n#include <utility>\n#include <set>\n#include <iostream>\n#include <memory>\n#include <string>\n#include <vector>\n#include <algorithm>\n#include <functional>\n#include <sstream>\n#include <complex>\n#include <stack>\n#include <queue>\n#include <numeric>\n#include <list>\n\nusing namespace std;\n\n#ifdef _MSC_VER\n#define __typeof__ decltype\n\ntemplate <class T>\nint __builtin_popcount(T n) { return n ? 1 + __builtin_popcount(n & (n - 1)) : 0; }\n#endif\n\n#define foreach(it, c) for (__typeof__((c).begin()) it=(c).begin(); it != (c).end(); ++it)\n#define all(c) (c).begin(), (c).end()\n#define rall(c) (c).rbegin(), (c).rend()\n#define popcount __builtin_popcount\n\n#define rep(i, n) for (int i = 0; i < n; ++i)\n\ntemplate <class T> void max_swap(T& a, const T b) { a = max(a, b); }\ntemplate <class T> void min_swap(T& a, const T b) { a = min(a, b); }\n\nconst double EPS = 1e-10;\ntypedef long long ll;\ntypedef pair<int, int> pint;\n\n\nstruct Range\n{\n\tRange(int top, int n) : top(top), n(n) {}\n\tpair<Range, Range> split(int num)\n\t{\n\t\treturn make_pair(Range(top, num), Range(top + num, n - num));\n\t}\n\tint top, n;\n};\nvoid next(vector<Range>& pile, int& i, int& sum, int until_sum, vector<Range>& a)\n{\n\tfor (i = 0; sum < until_sum; ++i)\n\t{\n\t\tif (sum + pile[i].n <= until_sum)\n\t\t{\n\t\t\ta.push_back(pile[i]);\n\t\t\tsum += pile[i].n;\n\t\t}\n\t\telse\n\t\t{\n\t\t\tpair<Range, Range> t = pile[i].split(until_sum - sum);\n\t\t\ta.push_back(t.first);\n\t\t\tsum = until_sum;\n\n\t\t\tpile[i] = t.second;\n\t\t\tbreak;\n\t\t}\n\t}\n}\nint main()\n{\n\tint n, m, p, q, r;\n\twhile (scanf(\"%d\", &n), n)\n\t{\n\t\tscanf(\"%d%d%d%d\", &m, &p, &q, &r);\n\n\t\tvector<Range> pile;\n\t\tpile.push_back(Range(1, n));\n\t\twhile (m--)\n\t\t{\n\t\t\tint x, y;\n\t\t\tscanf(\"%d%d\", &x, &y);\n\n\t\t\tvector<Range> a, b, c;\n\t\t\tint i = 0, sum = 0;\n\t\t\tnext(pile, i, sum, x, a);\n\t\t\tnext(pile, i, sum, y, b);\n\t\t\tfor ( ; i < pile.size(); ++i)\n\t\t\t\tc.push_back(pile[i]);\n\n\t\t\tpile = c;\n\t\t\tforeach (it, b)\n\t\t\t\tpile.push_back(*it);\n\t\t\tforeach (it, a)\n\t\t\t\tpile.push_back(*it);\n\t\t\t//pile.insert(pile.end(), all(b));\n\t\t\t//pile.insert(pile.end(), all(a));\n\t\t}\n\n\t\tvector<Range> a, b;\n\t\tint i = 0, sum = 0;\n\t\tnext(pile, i, sum, p - 1, a);\n\t\tnext(pile, i, sum, q, b);\n\n\t\tint res = 0;\n\t\tforeach (t, b)\n\t\t\tres += min(t->n, max(0, r - (t->top - 1)));\n\t\t\n\t\tprintf(\"%d\\n\", res);\n\t}\n}"
  },
  {
    "language": "C++",
    "code": "#define _USE_MATH_DEFINES\n#include <iostream>\n#include <memory>\n#include <memory.h>\n#include <fstream>\n#include <cmath>\n#include <math.h>\n#include <numeric>\n#include <vector>\n#include <stack>\n#include <string>\n#include <queue>\n#include <sstream>\n#include <cstdlib>\n#include <cassert>\n#include <cstdio>\n#include <map>\n#include <iomanip>\n#include <list>\n#include <cctype>\n#include <algorithm>\n#include <complex>\n\n#define rep(i, n) for(int i = 0; i < n; i++)\n#define rep2(i, m, n) for(int i = m; i < n; i++)\nusing namespace std;\n\ntypedef complex<double> xy_t;\ntypedef pair<xy_t, xy_t> line;\ntypedef long long ll;\ntypedef pair<int, int> P;\ntypedef pair<double, double> Pd;\ntypedef pair<int, P> PP;\ntypedef pair<int, PP> PPP;\nconst int INF = 1 << 29;\nconst double EPS = 1E-10;\n\n#define rep(i, n) for(int i = 0; i < n; i++)\n#define rep2(i, m, n) for(int i = m; i < n; i++)\n\nvector<P> change(const vector<P> &nums, int x, int y){\n\tvector<P> n1;\n\tvector<P> n2;\n\tvector<P> n3;\n\tint n = nums.size();\n\tint cnt = 0;\n\tint ind = 0;\n\twhile(ind < n && cnt < x){\n\t\tint sz = nums[ind].second - nums[ind].first + 1;\n\t\tif(cnt + sz <= x){\n\t\t\tn1.push_back(nums[ind]);\n\t\t\tcnt += sz;\n\t\t}else{\n\t\t\tif(cnt + sz <= y){\n\t\t\t\tn1.push_back(P(nums[ind].first, nums[ind].first + x - cnt - 1));\n\t\t\t\tn2.push_back(P(nums[ind].first + x - cnt, nums[ind].second));\n\t\t\t\tcnt += sz;\n\t\t\t}else{\n\t\t\t\tn1.push_back(P(nums[ind].first, nums[ind].first + x - cnt - 1));\n\t\t\t\tn2.push_back(P(nums[ind].first + x - cnt, nums[ind].first + y - cnt - 1));\n\t\t\t\tn3.push_back(P(nums[ind].first + y - cnt, nums[ind].second));\n\t\t\t\tcnt += sz;\n\t\t\t}\n\t\t}\n\t\tind++;\n\t}\n\twhile(ind < n && cnt < y){\n\t\tint sz = nums[ind].second - nums[ind].first + 1;\n\t\tif(cnt + sz <= y){\n\t\t\tn1.push_back(nums[ind]);\n\t\t\tcnt += sz;\n\t\t}else{\n\t\t\tn2.push_back(P(nums[ind].first, nums[ind].first + y - cnt - 1));\n\t\t\tn3.push_back(P(nums[ind].first + y  - cnt, nums[ind].second));\n\t\t\tcnt += sz;\n\t\t}\n\t\tind++;\n\t}\n\twhile(ind < n){\n\t\tn3.push_back(nums[ind++]);\n\t}\n\tint sz1 = n1.size();\n\tint sz2 = n2.size();\n\trep(i, sz2) n3.push_back(n2[i]);\n\trep(i, sz1) n3.push_back(n1[i]);\n\treturn n3;\n}\n\nint get_num(P p, int r){\n\t//cout << \"***\" << p.first << \" \" << p.second << endl;;\n\tif(p.second < p.first) return 0;\n\tif(r < p.first) return 0;\n\telse if(p.second <= r) return p.second - p.first + 1;\n\telse return r - p.first + 1;\n}\n\nint counter(const vector<P> &nums, int p, int q, int r){\n\tint cnt = 1;\n\tint res = 0;\n\tint n = nums.size();\n\trep(i, n){\n\t\t//cout << \"+ \" <<  nums[i].first << \" \" << nums[i].second << endl;\n\t\tint sz = nums[i].second - nums[i].first + 1;\n\t\tint pn = nums[i].first + p - cnt;\n\t\tint qn = nums[i].first + q - cnt;\n\t\t\n\t\tres += get_num(P(max(nums[i].first, pn), min(nums[i].second, qn)), r);\n\t\tcnt += sz;\n\t}\n\treturn res;\n}\n\nint main(){\n\tint n, m;\n\tint p, q, r;\n\tint x, y;\n\twhile(cin >> n && n){\n\t\tvector<P> nums;\n\t\tnums.push_back(P(1, n));\n\t\tcin >> m;\n\t\tcin >> p >> q >> r;\n\t\trep(i, m){\n\t\t\tcin >> x >> y;\n\t\t\tnums = change(nums, x, y);\n\t\t}\n\t\tcout << counter(nums, p, q, r) << endl;\n\t}\n\treturn 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include <cstdio>\n#include <cstdlib>\n#include <cstring>\n#include <cmath>\n#include <climits>\n#include <cfloat>\n#include <ctime>\n#include <map>\n#include <utility>\n#include <set>\n#include <iostream>\n#include <memory>\n#include <string>\n#include <vector>\n#include <algorithm>\n#include <functional>\n#include <sstream>\n#include <complex>\n#include <stack>\n#include <queue>\n#include <numeric>\n#include <list>\n\nusing namespace std;\n\n#ifdef _MSC_VER\n#define __typeof__ decltype\n\ntemplate <class T>\nint __builtin_popcount(T n) { return n ? 1 + __builtin_popcount(n & (n - 1)) : 0; }\n#endif\n\n#define foreach(it, c) for (__typeof__((c).begin()) it=(c).begin(); it != (c).end(); ++it)\n#define all(c) (c).begin(), (c).end()\n#define rall(c) (c).rbegin(), (c).rend()\n#define popcount __builtin_popcount\n\n#define rep(i, n) for (int i = 0; i < n; ++i)\n\ntemplate <class T> void max_swap(T& a, const T b) { a = max(a, b); }\ntemplate <class T> void min_swap(T& a, const T b) { a = min(a, b); }\n\nconst double EPS = 1e-10;\ntypedef long long ll;\ntypedef pair<int, int> pint;\n\n\nstruct Range\n{\n\tRange() {}\n\tRange(int top, int n) : top(top), n(n) {}\n\tpair<Range, Range> split(int num)\n\t{\n\t\treturn make_pair(Range(top, num), Range(top + num, n - num));\n\t}\n\tint top, n;\n};\nqueue<Range> pile;\nRange a[100000], b[500000], c[500000];\nint size;\nint next(int& sum, int until_sum, Range* a)\n{\n\tint j = 0;\n\tfor (; sum < until_sum; )\n\t{\n\t\tif (sum + pile.front().n <= until_sum)\n\t\t{\n\t\t\ta[j++] = pile.front();\n\t\t\tsum += pile.front().n;\n\t\t\tpile.pop();\n\t\t}\n\t\telse\n\t\t{\n\t\t\tpair<Range, Range> t = pile.front().split(until_sum - sum);\n\t\t\ta[j++] = t.first;\n\t\t\tsum = until_sum;\n\n\t\t\tpile.front() = t.second;\n\t\t\tbreak;\n\t\t}\n\t}\n\treturn j;\n}\nint main()\n{\n\tint n, m, p, q, r;\n\twhile (scanf(\"%d\", &n), n)\n\t{\n\t\tscanf(\"%d%d%d%d\", &m, &p, &q, &r);\n\n\t\tpile = queue<Range>();\n\t\tpile.push(Range(1, n));\n\t\twhile (m--)\n\t\t{\n\t\t\tint x, y;\n\t\t\tscanf(\"%d%d\", &x, &y);\n\n\t\t\tint sum = 0;\n\t\t\tint a_size = next(sum, x, a);\n\t\t\tint b_size = next(sum, y, b);\n\t\t\t\n\t\t\trep (i, b_size)\n\t\t\t\tpile.push(b[i]);\n\t\t\trep (i, a_size)\n\t\t\t\tpile.push(a[i]);\n\t\t}\n\n\t\tint i = 0, sum = 0;\n\t\tint a_size = next(sum, p - 1, a);\n\t\tint b_size = next(sum, q, b);\n\n\t\tint res = 0;\n\t\trep (i, b_size)\n\t\t\tres += min(b[i].n, max(0, r - (b[i].top - 1)));\n\t\t\n\t\tprintf(\"%d\\n\", res);\n\t}\n}"
  },
  {
    "language": "C++",
    "code": "#include<cstdio>\n#include<vector>\n#include<algorithm>\nusing namespace std;\nint main(){\n    int n,m,p,q,r;\n    for(;;){\n        scanf(\"%d%d%d%d%d\",&n,&m,&p,&q,&r);\n        if(n==0) break;\n        pair<int,int> *cards=new pair<int,int>[1];\n        cards[0]=make_pair(1,n);\n        int csize=1;\n        for(int ix=0;ix<m;ix++){\n            int x,y;\n            scanf(\"%d%d\",&x,&y);\n            int *maif=new int[csize],*mais=new int[csize];\n            maif[0]=1;\n            mais[0]=cards[0].second-cards[0].first+1;\n            for(int i=1;i<csize;i++){\n                mais[i]=mais[i-1]+(cards[i].second-cards[i].first+1);\n                maif[i]=mais[i-1]+1;\n            }\n            vector<pair<int,int> > a,b,c;\n            for(int i=0;i<csize;i++){\n                if(mais[i]<=x) a.push_back(cards[i]);\n                else if(y<maif[i]) c.push_back(cards[i]);\n                else if(x<maif[i]&&mais[i]<=y) b.push_back(cards[i]);\n                else if(x<maif[i]&&y<mais[i]){\n                    b.push_back(make_pair(cards[i].first,y+(cards[i].first-maif[i])));\n                    c.push_back(make_pair(y+(cards[i].first-maif[i])+1,cards[i].second));\n                }\n                else if(maif[i]<=x&&mais[i]<=y){\n                    a.push_back(make_pair(cards[i].first,x+(cards[i].first-maif[i])));\n                    b.push_back(make_pair(x+(cards[i].first-maif[i])+1,cards[i].second));\n                }\n                else if(maif[i]<=x&&y<mais[i]){\n                    a.push_back(make_pair(cards[i].first,x+(cards[i].first-maif[i])));\n                    b.push_back(make_pair(x+(cards[i].first-maif[i])+1,y+(cards[i].first-maif[i])));\n                    c.push_back(make_pair(y+(cards[i].first-maif[i])+1,cards[i].second));\n                }\n            }\n            delete[] cards;\n            delete[] maif;\n            delete[] mais;\n            csize=c.size()+b.size()+a.size();\n            cards=new pair<int,int>[csize];\n            for(int ii=0;ii<c.size();ii++)cards[ii]=c[ii];\n            for(int ii=0;ii<b.size();ii++)cards[ii+c.size()]=b[ii];\n            for(int ii=0;ii<a.size();ii++)cards[ii+c.size()+b.size()]=a[ii];\n        }\n        int *maif=new int[csize],*mais=new int[csize];\n        maif[0]=1;\n        mais[0]=cards[0].second-cards[0].first+1;\n        for(int i=1;i<csize;i++){\n            mais[i]=mais[i-1]+(cards[i].second-cards[i].first+1);\n            maif[i]=mais[i-1]+1;\n        }\n        int ans=0;\n        for(int i=0;i<csize;i++){\n            if(p<=maif[i]&&mais[i]<=q) ans+=max(0,min(r,cards[i].second)-cards[i].first+1);\n            else if(maif[i]<p) ans+=max(0,min(r,cards[i].second)-(cards[i].first+(p-maif[i])+1));\n            else if(q<mais[i]) ans+=max(0,min(r,cards[i].second-(mais[i]-q))-cards[i].first+1);\n            else ans+=max(0,min(r,cards[i].second-(mais[i]-q))-(cards[i].first+(p-maif[i])+1));\n        }\n        printf(\"%d\\n\",ans);\n        delete[] cards;\n        delete[] maif;\n        delete[] mais;\n    }\n}"
  },
  {
    "language": "C++",
    "code": "#include <cstdlib>\n#include <iostream>\n#include <utility>\n#include <vector>\nusing namespace std;\n\nint main() {\n\tcin.tie(0);\n\tios::sync_with_stdio(false);\n\n\tfor(int n; cin >> n, n;) {\n\t\tint m;\n\t\tcin >> m;\n\n\t\tint p, q, r;\n\t\tcin >> p >> q >> r;\n\n\t\tvector<pair<int, bool> > cards;\n\t\tcards.push_back(make_pair(r, true));\n\t\tcards.push_back(make_pair(n - r, false));\n\n\t\tfor(int i = 0; i < m; ++i) {\n\t\t\tint x, y;\n\t\t\tcin >> x >> y;\n\n\t\t\tvector<pair<int, bool> > tmp;\n\t\t\tint j, sum = 0, idxA, idxB, sumA, sumB;\n\t\t\tfor(j = 0;; ++j) {\n\t\t\t\tsum += cards[j].first;\n\t\t\t\tif(sum >= x) {\n\t\t\t\t\tidxA = j;\n\t\t\t\t\tsumA = sum;\n\t\t\t\t\tbreak;\n\t\t\t\t}\n\t\t\t}\n\n\t\t\tfor(++j;; ++j) {\n\t\t\t\tsum += cards[j].first;\n\t\t\t\tif(sum >= y) {\n\t\t\t\t\tidxB = j;\n\t\t\t\t\tsumB = sum;\n\t\t\t\t\tbreak;\n\t\t\t\t}\n\t\t\t}\n\n\t\t\tif(sumB != y) {\n\t\t\t\ttmp.push_back(make_pair(sumB - y, cards[idxB].second));\n\t\t\t\tcards[idxB].first -= sumB - y;\n\n\t\t\t\tif(idxA == idxB)\n\t\t\t\t\tsumA -= sumB - y;\n\t\t\t}\n\n\t\t\tfor(j = idxB + 1; j < cards.size(); ++j)\n\t\t\t\ttmp.push_back(cards[j]);\n\n\t\t\tif(sumA != x) {\n\t\t\t\ttmp.push_back(make_pair(sumA - x, cards[idxA].second));\n\t\t\t\tcards[idxA].first -= sumA - x;\n\t\t\t}\n\n\t\t\tfor(j = idxA + 1; j <= idxB; ++j)\n\t\t\t\ttmp.push_back(cards[j]);\n\n\t\t\tfor(j = 0; j <= idxA; ++j)\n\t\t\t\ttmp.push_back(cards[j]);\n\n\t\t\tcards.swap(tmp);\n\t\t}\n\n\t\tint ans = 0;\n\t\tint i = 0, sum = 0;\n\t\tfor(; i < cards.size(); ++i) {\n\t\t\tsum += cards[i].first;\n\t\t\tif(sum >= p) {\n\t\t\t\tif(cards[i].second)\n\t\t\t\t\tans += sum - p + 1;\n\n\t\t\t\tbreak;\n\t\t\t}\n\t\t}\n\n\t\tfor(++i; i < cards.size(); ++i) {\n\t\t\tsum += cards[i].first;\n\t\t\tif(sum > q) {\n\t\t\t\tif(cards[i].second)\n\t\t\t\t\tans += cards[i].first - (sum - q);\n\n\t\t\t\tbreak;\n\t\t\t}\n\t\t\telse {\n\t\t\t\tif(cards[i].second)\n\t\t\t\t\tans += cards[i].first;\n\t\t\t}\n\t\t}\n\n\t\tcout << ans << endl;\n\t}\n\n\treturn EXIT_SUCCESS;\n}"
  },
  {
    "language": "C++",
    "code": "#include <iostream>\n#include <utility>\n#include <list>\n#include <algorithm>\n\nint main() {\n\tint n, m, p, q, r;\n\twhile (std::cin >> n, n != 0) {\n\t\tstd::list<std::pair<int, int>> cards;\n\t\tcards.push_back({ 1, n });\n\n\t\tstd::cin >> m >> p >> q >> r;\n\t\tfor (int i = 0; i < m; ++i) {\n\t\t\tint x, y;\n\t\t\tstd::cin >> x >> y;\n\n\t\t\tdecltype(cards)::iterator sec1 = cards.end(), sec2;\n\t\t\tint num = 0;\n\t\t\tfor (auto itr = cards.begin(); itr != cards.end(); ++itr) {\n\t\t\t\tnum += itr->second - itr->first + 1;\n\n\t\t\t\tif (num >= x && sec1 == cards.end()) {\n\t\t\t\t\tif (num == x) {\n\t\t\t\t\t\tsec1 = itr;\n\t\t\t\t\t\tsec2 = cards.end();\n\t\t\t\t\t\tcontinue;\n\t\t\t\t\t}\n\n\t\t\t\t\tcards.insert(\n\t\t\t\t\t\titr,\n\t\t\t\t\t\t{\n\t\t\t\t\t\t\t{itr->first, itr->second - (num - x)},\n\t\t\t\t\t\t\t{itr->second - (num - x) + 1, itr->second}\n\t\t\t\t\t\t}\n\t\t\t\t\t);\n\t\t\t\t\tsec1 = itr = cards.erase(itr);\n\t\t\t\t\t--itr, ----sec1;\n\t\t\t\t\tsec2 = cards.end();\n\n\t\t\t\t\tnum = x + sec1->second - sec1->first + 1;\n\t\t\t\t}\n\t\t\t\tif (num >= y && sec2 == cards.end()) {\n\t\t\t\t\tif (num == y) {\n\t\t\t\t\t\tsec2 = itr;\n\t\t\t\t\t\t++sec2, ++sec1;\n\t\t\t\t\t\tbreak;\n\t\t\t\t\t}\n\t\t\t\t\tcards.insert(\n\t\t\t\t\t\titr,\n\t\t\t\t\t\t{\n\t\t\t\t\t\t\t{ itr->first, itr->second - (num - y) },\n\t\t\t\t\t\t\t{ itr->second - (num - y) + 1, itr->second }\n\t\t\t\t\t\t}\n\t\t\t\t\t);\n\t\t\t\t\tsec2 = itr = cards.erase(itr);\n\t\t\t\t\t--itr, --sec2, ++sec1;\n\n\t\t\t\t\tbreak;\n\t\t\t\t}\n\t\t\t}\n\n\t\t\tcards.splice(cards.end(), cards, sec1, sec2);\n\t\t\tcards.splice(cards.end(), cards, cards.begin(), sec2);\n\t\t}\n\n\t\tint count = 0, ans = 0;\n\t\tfor (auto&& rng : cards) {\n\t\t\tint rngSize = rng.second - rng.first + 1;\n\n\t\t\tcount += rngSize;\n\n\t\t\tif (rng.first > r)\n\t\t\t\tcontinue;\n\t\t\telse if (rng.first <= r && r < rng.second)\n\t\t\t\trngSize -= rng.second - r;\n\n\t\t\tif (count > q) {\n\t\t\t\tans += std::max(0, rngSize - (count - q));\n\t\t\t\tbreak;\n\t\t\t}\n\t\t\tif (count >= p)\n\t\t\t\tans += std::min(rngSize, count - p);\n\t\t}\n\n\t\tstd::cout << ans << std::endl;\n\t}\n}"
  },
  {
    "language": "C++",
    "code": "#include<cstdio>\n#include<vector>\n#include<map>\n#include<algorithm>\nusing namespace std;\n\nint main(){\n  while(1){\n    int n, m, p, q, r;\n    scanf(\"%d\", &n);\n    if(n == 0)return 0;\n    scanf(\"%d%d%d%d\", &m, &p, &q, &r);\n    vector<pair<int, int> > mountain, mounta, mountb;\n    mountain.push_back(make_pair(1, n));\n    for(int i = 0;i < m;i++){\n      int x, y, j = 0;\n      scanf(\"%d%d\", &x, &y);\n      \n      while(j + mountain[0].second - mountain[0].first + 1 < x){\n\tj += mountain[0].second - mountain[0].first + 1;\n\tmounta.push_back(mountain[0]);\n\tmountain.erase(mountain.begin());\n      }\n      mounta.push_back(make_pair(mountain[0].first ,mountain[0].first + x - j - 1));\n      if(mountain[0].second == mountain[0].first + x - j - 1)mountain.erase(mountain.begin());\n      else mountain[0].first += x - j;\n      j = x;\n\n      while(j + mountain[0].second - mountain[0].first + 1 < y){\n\tj += mountain[0].second - mountain[0].first + 1;\n\tmountb.push_back(mountain[0]);\n\tmountain.erase(mountain.begin());\n      }\n      mountb.push_back(make_pair(mountain[0].first ,mountain[0].first + y - j - 1));\n      if(mountain[0].second == mountain[0].first + y - j - 1)mountain.erase(mountain.begin());\n      else mountain[0].first += y - j;\n      \n      while(!mountb.empty()){\n\tmountain.push_back(mountb[0]);\n\tmountb.erase(mountb.begin());\n      }\n      while(!mounta.empty()){\n\tmountain.push_back(mounta[0]);\n\tmounta.erase(mounta.begin());\n      }\n    }\n    int j = 0;\n    while(j + mountain[0].second - mountain[0].first + 1 < p - 1){\n      j += mountain[0].second - mountain[0].first + 1;\n      mountain.erase(mountain.begin());\n    }\n    if(mountain[0].second == mountain[0].first + p - j - 2)mountain.erase(mountain.begin());\n    else mountain[0].first += p - j - 1;\n    j = p - 1;\n    \n    int res = 0;\n    while(j + mountain[0].second - mountain[0].first + 1 < q){\n      res += max(0, min(r, mountain[0].second) - mountain[0].first + 1);\n      j += mountain[0].second - mountain[0].first + 1;\n      mountain.erase(mountain.begin());      \n    }\n    res += max(0, min(r, mountain[0].first + q - j - 1) - mountain[0].first + 1);\n    printf(\"%d\\n\", res);\n  }\n}"
  },
  {
    "language": "C++",
    "code": "#include<bits/stdc++.h>\nusing namespace std;\n\nint solve();\nvector<pair<int,int> > shuffle(vector<pair<int,int> > vec,int i);\n\nint N,M,P,Q,R;\nint X[5010],Y[5010];\n\nint main()\n{\n    while(scanf(\"%d\",&N),N)\n    {\n        scanf(\"%d\",&M);\n        scanf(\"%d%d%d\",&P,&Q,&R);\n        for(int i = 0; i < M; i++)\n        {\n            scanf(\"%d%d\",&X[i],&Y[i]);\n        }\n        printf(\"%d\\n\",solve());\n    }\n}\n\nvector<pair<int,int> > shuffle(vector<pair<int,int> > vec,int i)\n{\n    vector<pair<int,int> > new_vec;\n    for(int j = 0; j < vec.size(); j++)\n    {\n        int l = vec[j].first,r = vec[j].second;\n        if(l <= X[i] && r <= X[i])\n        {\n            new_vec.push_back(make_pair(l + N - X[i],r + N - X[i]));\n            continue;\n        }\n        if(l <= X[i] && X[i] < r && r <= Y[i])\n        {\n            new_vec.push_back(make_pair(l + N - X[i],N));\n            new_vec.push_back(make_pair(N - Y[i] + 1,r + N - X[i] - Y[i]));\n            continue;\n        }\n        if(X[i] < l && l <= Y[i] && X[i] < r && r <= Y[i])\n        {\n            new_vec.push_back(make_pair(l + N - X[i] - Y[i],r + N - X[i] - Y[i]));\n            continue;\n        }\n        if(X[i] < l && l <= Y[i] && Y[i] < r)\n        {\n            new_vec.push_back(make_pair(l + N - X[i] - Y[i],N - X[i]));\n            new_vec.push_back(make_pair(1,r - Y[i]));\n            continue;\n        }\n        if(Y[i] < l && Y[i] < r)\n        {\n            new_vec.push_back(make_pair(l - Y[i],r - Y[i]));\n            continue;\n        }\n        if(l <= X[i] && Y[i] < r)\n        {\n            new_vec.push_back(make_pair(l + N - X[i],N));\n            new_vec.push_back(make_pair(N - Y[i] + 1,N - X[i]));\n            new_vec.push_back(make_pair(1,r - Y[i]));\n            continue;\n        }\n    }\n    return new_vec;\n}\n\nint solve()\n{\n    int ANS = 0;\n    vector<pair<int,int> > vec;\n    vec.push_back(make_pair(1,R));\n    for(int i = 0; i < M; i++)\n    {\n        vec = shuffle(vec,i);\n    }\n    for(int i = 0;i < vec.size(); i++)\n    {\n        int l = vec[i].first,r = vec[i].second;\n        int a = max(l,P),b = min(r,Q) + 1;\n        ANS += max(0,b - a);\n    }\n    return ANS;\n}"
  },
  {
    "language": "C++",
    "code": "#include <tuple>\n#include <vector>\n#include <iostream>\n#include <algorithm>\n\n#pragma warning(disable : 4996)\n\nusing namespace std;\n\nint n, m, p, q, c, r1, r2;\n\nvector<tuple<int, int, int> > dat;\n\ninline void divide(int pos)\n{\n\tvector<tuple<int, int, int> > dat1;\n\n\tint u = dat.size();\n\n\tfor (int i = 0; i < u; i++)\n\t{\n\t\tint l = get<0>(dat[i]);\n\t\tint r = get<1>(dat[i]);\n\t\tint t = get<2>(dat[i]);\n\n\t\tif (l < pos && pos < r)\n\t\t{\n\t\t\tdat1.push_back(make_tuple(l, pos, t));\n\t\t\tdat1.push_back(make_tuple(pos, r, t + pos - l));\n\t\t}\n\t\telse if(pos <= l)\n\t\t{\n\t\t\tdat1.push_back(make_tuple(l, r, t));\n\t\t}\n\t\telse\n\t\t{\n\t\t\tbreak;\n\t\t}\n\t}\n\n\tdat = dat1;\n}\n\ninline void shuffle(int a, int b)\n{\n\tdivide(a);\n\tdivide(b);\n\n\tint l = lower_bound(dat.begin(), dat.end(), make_tuple(a, 0, 0)) - dat.begin();\n\tint r = lower_bound(dat.begin(), dat.end(), make_tuple(b, 0, 0)) - dat.begin();\n\tint u = dat.size();\n\n\tvector<tuple<int, int, int> > dat1;\n\n\tint pos = 0;\n\n\tfor (int i = r; i < u; i++)\n\t{\n\t\tdat1.push_back(make_tuple(pos, pos - get<0>(dat[i]) + get<1>(dat[i]), get<2>(dat[i]))); pos += get<1>(dat[i]) - get<0>(dat[i]);\n\t}\n\n\tfor (int i = l; i < r; i++)\n\t{\n\t\tdat1.push_back(make_tuple(pos, pos - get<0>(dat[i]) + get<1>(dat[i]), get<2>(dat[i]))); pos += get<1>(dat[i]) - get<0>(dat[i]);\n\t}\n\n\tfor (int i = 0; i < l; i++)\n\t{\n\t\tdat1.push_back(make_tuple(pos, pos - get<0>(dat[i]) + get<1>(dat[i]), get<2>(dat[i]))); pos += get<1>(dat[i]) - get<0>(dat[i]);\n\t}\n\n\tdat = dat1;\n}\n\nint main()\n{\n\twhile(true)\n\t{\n\t\tscanf(\"%d\", &n);\n\t\t\n\t\tif (n == 0) { break; }\n\n\t\tscanf(\"%d\", &m);\n\t\tscanf(\"%d\", &p); p--;\n\t\tscanf(\"%d\", &q); q--;\n\t\tscanf(\"%d\", &c);\n\n\t\tdat = { make_tuple(0, n, 1) };\n\n\t\tfor (int i = 0; i < m; i++)\n\t\t{\n\t\t\tscanf(\"%d\", &r1);\n\t\t\tscanf(\"%d\", &r2);\n\n\t\t\tshuffle(r1, r2);\n\t\t}\n\n\t\tint ret = 0;\n\n\t\tfor (int i = 0; i < dat.size(); i++)\n\t\t{\n\t\t\tint l = get<0>(dat[i]);\n\t\t\tint r = get<1>(dat[i]);\n\t\t\tint t = get<2>(dat[i]);\n\n\t\t\tif (p <= l && r <= q + 1)\n\t\t\t{\n\t\t\t\tret += min(max(c - t + 1, 0), r - l);\n\t\t\t}\n\t\t\telse if (p <= l && l <= q)\n\t\t\t{\n\t\t\t\tret += min(max(c - t + 1, 0), q - l + 1);\n\t\t\t}\n\t\t\telse if (p <= r && r <= q)\n\t\t\t{\n\t\t\t\tret += max(c - (t + (p - l)) + 1, 0);\n\t\t\t}\n\t\t}\n\n\t\tprintf(\"%d\\n\", ret);\n\t}\n\n\treturn 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include<iostream>\n#include<queue>\n#include<map>\n#include<algorithm>\nusing namespace std;\n#define fr first\n#define sc second\ntypedef pair< int , int > P;\nint n, m;\ndeque< P > d;\nint _sum(P p){\n  return p.sc - p.fr + 1;\n}\nint query(int& p,int& q,int& r){\n  int ret = 0, ans = 0;\n  while(ret + _sum(d.front()) < p){\n    ret += _sum(d.front());\n    d.pop_front();\n  }\n  if(ret != p - 1) d.front().fr += p - ret;\n  ret = p;\n  while(ret + _sum(d.front()) <= q){\n    if(d.front().sc <= r) ans += _sum(d.front());\n    else if(d.front().fr <= r) ans += _sum(P(d.front().fr,r));\n    ret += _sum(d.front());\n    d.pop_front();\n  }\n  if(!d.empty() && ret != q){\n    P p = P(d.front().fr,d.front().fr + q - ret - 1);\n    if(p.sc <= r) ans += _sum(P(p.fr,p.sc));\n    else if(p.fr <= r) ans += _sum(P(p.fr,r));\n  }\n  return ans;\n}\nvoid shuffle(int* xy){\n  deque< P > tmp[2];\n  int ret = 0;\n  for(int i = 0 ; i < 2 ; i++ ){\n    while( ret + _sum(d.front()) <= xy[i]){\n      tmp[i].push_back(d.front());\n      ret += _sum(d.front());\n      d.pop_front();\n    }\n    if(ret != xy[i]){\n      tmp[i].push_back(P(d.front().fr,d.front().fr + xy[i] - ret - 1));\n      d.front().fr = d.front().fr + xy[i] - ret;\n      ret = xy[i];\n    }\n  }\n  d.insert(d.end(),tmp[1].begin(),tmp[1].end());\n  d.insert(d.end(),tmp[0].begin(),tmp[0].end()); \n}\nint main(){\n  while(cin >> n , n){\n    cin >> m;\n    d.push_back( P( 1, n));\n    int p, q, r;\n    cin >> p >> q >> r;\n    while(m--){\n      int xy[2];\n      cin >> xy[0] >> xy[1];\n      shuffle(xy);\n    }\n    cout << query(--p, q, r) << endl;\n    d.clear();\n  }\n}"
  },
  {
    "language": "C++",
    "code": "#include<iostream>\n#include<queue>\nusing namespace std;\nint main(){\n\tint n;\n\twhile(cin>>n,n){\n\t\tint m,p,q,r,x,y,ans=0;\n\tdeque<int> a,c;\n\t\n\tcin>>m;\n\tcin>>p>>q>>r;\n\tfor(int i=1;i<=n;i++)\n\t\ta.push_back(i);\n\tfor(int i=0;i<m;i++){\n\t\tcin>>x>>y;\n\t\tfor(int j=0;j<n-y;j++){\n\t\t\tc.push_back(a.back());\n\t\t\ta.pop_back();\n\t\t}\n\t\tfor(int j=0;j<y-x;j++){\n\t\t\ta.push_front(a.back());\n\t\t\ta.pop_back();\n\t\t}\n\t\tfor(int j=0;j<n-y;j++){\n\t\t\ta.push_front(c.front());\n\t\t\tc.pop_front();\n\t\t}\n\t}\n\t/*for(int i=0;i<n;i++){\n\t\tcout<<a.front()<<' ';\n\t\ta.pop_front();\n\t}cout<<endl;\n\t*/\n\tfor(int i=0;i<p-1;i++){\n\t\ta.pop_front();\n\t}\n\tfor(int j=0;j<q-p+1;j++){\n\t\tif(a.front()<=r)\n\t\tans++;\n\t\ta.pop_front();\n\t}\n\tcout<<ans<<endl;\n\t}\n\treturn 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include<iostream>\n#include<sstream>\n#include<vector>\n#include<set>\n#include<map>\n#include<queue>\n#include<algorithm>\n#include<numeric>\n#include<cstdio>\n#include<cstdlib>\n#include<cstring>\n#include<cmath>\n#include<cassert>\n\n#define rep(i,n) for(int i=0;i<n;i++)\n#define all(c) (c).begin(),(c).end()\n#define mp make_pair\n#define pb push_back\n#define rp(i,c) rep(i,(c).size())\n#define fr(i,c) for(__typeof((c).begin()) i=(c).begin();i!=(c).end();i++)\n#define dbg(x) cerr<<#x<<\" = \"<<(x)<<endl\n\nusing namespace std;\ntypedef vector<pair<int,int> > vp;\n\nvoid split(vp &v,int x){\n\tint cnt=0,l,r;\n\tfr(i,v){\n\t\tl=i->first; r=i->second;\n\t\tif(x<=cnt+r-l+1){\n\t\t\tif(x==cnt+r-l+1)break;\n\t\t\ti=v.erase(i);\n\t\t\tv.insert(i,mp(l+x-cnt,r));\n\t\t\tv.insert(i,mp(l,l+x-cnt-1));\n\t\t\tbreak;\n\t\t}\n\t\tcnt+=r-l+1;\n\t}\n}\nvoid cut(vp &v,int x,int y){\n\tsplit(v,x); split(v,y);\n\tvp ret;\n\tint l,r,cnt=0;\n\trep(i,v.size()){\n\t\tcnt+=v[i].second-v[i].first+1;\n\t\tif(cnt==x)l=i;\n\t\tif(cnt==y)r=i;\n\t}\n\tfor(int i=r+1;i<v.size();i++)ret.pb(v[i]);\n\tfor(int i=l+1;i<=r;i++)ret.pb(v[i]);\n\tfor(int i=0;i<=l;i++)ret.pb(v[i]);\n\tv=ret;\n}\n\nint main()\n{\n\tint n,m,p,q,r;\n\twhile(scanf(\"%d\",&n),n){\n\t\tvp taba;\n\t\ttaba.pb(mp(1,n));\n\t\t\n\t\tscanf(\"%d\",&m);\n\t\tscanf(\"%d%d%d\",&p,&q,&r);\n\t\t\n\t\trep(i,m){\n\t\t\tint x,y; scanf(\"%d%d\",&x,&y);\n\t\t\tcut(taba,x,y);\n\t\t}\n\t\tif(p>1)split(taba,p-1); if(q<n)split(taba,q);\n\t\tint ans=0,cnt=0,a,b; bool plus=0;\n\t\tfr(i,taba){\n\t\t\ta=i->first; b=i->second;\n\t\t\tif(cnt+1==p)plus=1;\n\t\t\tif(plus){\n\t\t\t\tif(b<=r)ans+=b-a+1;\n\t\t\t\telse if(a<=r)ans+=r-a+1;\n\t\t\t}\n\t\t\tcnt+=b-a+1;\n\t\t\tif(cnt==q)break;\n\t\t}\n\t\tprintf(\"%d\\n\",ans);\n\t}\n\treturn 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include<iostream>\n#include<cstring>\n#include<queue>\n#include<algorithm>\nusing namespace std;\n\nint x[5001][3];\nint z[25000][2];\n\nqueue<int>Q1;\nqueue<int>R1;\nqueue<int>S1;\nqueue<int>Q2;\nqueue<int>R2;\nqueue<int>S2;\n\nint main(){\n\tint n,m,a,b,c,k,p,sum,sum2,sum3,t;\n\twhile(true){\n\t\tcin>>n>>m;\n\t\tcin>>a>>b>>c;\n\t\tz[0][0]=1;\n\t\tz[0][1]=n;\n\n\t\tk=1;\n\t\tfor(int i=1;i<=m;i++){\n\t\t\tcin>>x[i][1]>>x[i][2];\n\n\t\t\tfor(int j=0;j<k;j++){\n\t\t\t\tif(z[j][1]<=x[i][1]){\n\t\t\t\t\tQ1.push(z[j][0]);\n\t\t\t\t\tQ2.push(z[j][1]);\n\t\t\t\t}\n\t\t\t\telse if(z[j][0]>x[i][2]){\n\t\t\t\t\tS1.push(z[j][0]);\n\t\t\t\t\tS2.push(z[j][1]);\n\t\t\t\t}\n\t\t\t\telse if(z[j][1]<=x[i][2] && z[j][0]>x[i][1]){\n\t\t\t\t\tR1.push(z[j][0]);\n\t\t\t\t\tR2.push(z[j][1]);\n\t\t\t\t}\n\t\t\t\telse if(z[j][1]<=x[i][2] && z[j][0]<=x[i][1]){\n\t\t\t\t\tQ1.push(z[j][0]);\n\t\t\t\t\tQ2.push(x[i][1]);\n\t\t\t\t\tR1.push(x[i][1]+1);\n\t\t\t\t\tR2.push(z[j][1]);\n\t\t\t\t}\n\t\t\t\telse if(z[j][1]>x[i][2] && z[j][0]>x[i][1]){\n\t\t\t\t\tR1.push(z[j][0]);\n\t\t\t\t\tR2.push(x[i][2]);\n\t\t\t\t\tS1.push(x[i][2]+1);\n\t\t\t\t\tS2.push(z[j][1]);\n\t\t\t\t}\n\t\t\t\telse{\n\t\t\t\t\tQ1.push(z[j][0]);\n\t\t\t\t\tQ2.push(x[i][1]);\n\t\t\t\t\tR1.push(x[i][1]+1);\n\t\t\t\t\tR2.push(x[i][2]);\n\t\t\t\t\tS1.push(x[i][2]+1);\n\t\t\t\t\tS2.push(z[j][1]);\n\t\t\t\t}\n\t\t\t}\n\t\t\tk=0;\n\t\t\tk+=Q1.size();\n\t\t\tk+=R1.size();\n\t\t\tk+=S1.size();\n\t\t\tp=0;\n\t\t\t\n\t\t\twhile(!S1.empty()){\n\t\t\t\tz[p][0]=S1.front();\n\t\t\t\tz[p][1]=S2.front();\n\t\t\t\tS1.pop();\n\t\t\t\tS2.pop();\n\t\t\t\tp++;\n\t\t\t}\n\t\t\twhile(!R1.empty()){\n\t\t\t\tz[p][0]=R1.front();\n\t\t\t\tz[p][1]=R2.front();\n\t\t\t\tR1.pop();\n\t\t\t\tR2.pop();\n\t\t\t\tp++;\n\t\t\t}\n\t\t\twhile(!Q1.empty()){\n\t\t\t\tz[p][0]=Q1.front();\n\t\t\t\tz[p][1]=Q2.front();\n\t\t\t\tQ1.pop();\n\t\t\t\tQ2.pop();\n\t\t\t\tp++;\n\t\t\t}\n\t\t}\n\t\tsum=0;\n\t\tsum2=1;\n\t\tsum3=1;\n\t\tfor(int i=0;i<k;i++){\n\t\t\tsum2 += z[i][1]-z[i][0]+1;\n\t\t\tif(sum2-1>=a && sum3<=b){\n\t\t\t\tif(z[i][1]<=c){\n\t\t\t\t\tsum += min(b,sum2-1)-max(a,sum3)+1;\n\t\t\t\t}\n\t\t\t\telse if(z[i][0]<=c){\n\t\t\t\t\tt=min(b,sum2-1);\n\t\t\t\t\tt=min(t,sum3+c-z[i][0]);\n\t\t\t\t\tif(t-max(a,sum3)>=0){\n\t\t\t\t\t\tsum += t-max(a,sum3)+1;\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t}\n\t\t\tsum3=sum2;\n\t\t}\n\t\tcout<<sum<<endl;\n\t}\n}"
  },
  {
    "language": "C++",
    "code": "#include <iostream>\n#include <fstream>\n#include <stdio.h>\n#include <math.h>\n#include <time.h>\n#include <string>\n#include <tuple>\n#include <vector>\n#include <map>\n#include <list>\n#include <set>\n#include <stack>\n#include <queue>\n#include <cstdlib>\n#include <algorithm>\n#include <random>\n#include <cassert>\nusing namespace std;\n#define LL long long\n#define MP(a, b) make_pair(a, b)\n#define MMP(a, b, c) make_pair(make_pair(a, b), c)\n#define MAX 1000000000\n#undef INT_MIN\n#undef INT_MAX\n#define INT_MIN -2147483648\n#define INT_MAX 2147483647\n#define LL_MIN -9223372036854775808\n#define LL_MAX 9223372036854775807\n#define PI 3.14159265359\n\nint main(){\n    iostream::sync_with_stdio(false);\n\n    START:\n\n    int n;\n    cin >> n;\n    if(n == 0) return 0;\n    int m,p,q,r;\n    cin >> m >> p >> q >> r;\n    vector<pair<int, int> > updown; //1オリジン\n    updown.push_back(MP(1,r));\n    for(int i=0; i<m; i++){\n        int x,y;\n        cin >> x >> y;\n        //塊の切断処理\n        for(int j=0; j<updown.size(); j++){\n            int a = updown[j].first;\n            int b = updown[j].second;\n            if(a<=x && x<b){\n                updown[j].second = x;\n                updown.push_back(MP(x+1,b));\n                continue;\n            }\n            if(a<=y && y<b){\n                updown[j].second = y;\n                updown.push_back(MP(y+1,b));\n            }\n        }\n        //塊の移動処理\n        for(int j=0; j<updown.size(); j++){\n            int a = updown[j].first;\n            if(a <= x){\n                updown[j].first += n-x;\n                updown[j].second += n-x;\n            }\n            else if(a <= y){\n                updown[j].first += (n-y)-x;\n                updown[j].second += (n-y)-x;\n            }\n            else{\n                updown[j].first -= y;\n                updown[j].second -= y;\n            }\n        }\n    }\n    int ans = 0;\n    for(int i=0; i<updown.size(); i++){\n        int a = updown[i].first;\n        int b = updown[i].second;\n        //cout << a << \" \" << b << endl;\n        if(p <= a && b <= q) ans += b - a + 1;\n        else if(p <= b && b <= q) ans += b - p + 1;\n        else if(p <= a && a <= q) ans += q - a + 1;\n    }\n    cout << ans << endl;\n\n    goto START;\n    \n    return 0;\n}\n\n"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\n//#include <math.h>\nusing namespace std;\n\n#define INF 1.1e9\n#define LINF 1.1e18\n#define FOR(i,a,b) for (int i=(a);i<(b);++i)\n#define REP(i,n) FOR(i,0,n)\n#define ALL(v) (v).begin(),(v).end()\n#define pb push_back\n#define pf push_front\n#define fi first\n#define se second\n#define BIT(x,n) bitset<n>(x)\n#define PI 3.14159265358979323846\n\ntypedef long long ll;\ntypedef pair<int,int> P;\ntypedef pair<int,P> PP;\n\n//-----------------------------------------------------------------------------\n\nint n,m,p,q,r,sum;\n\nint main() {\n\tcin.tie(0);\n\tios::sync_with_stdio(false);\n\n    while(true) {\n\tcin>>n;\n\tif(n==0) break;\n\tcin>>m>>p>>q>>r;\n\tdeque<P> v;\n\tv.pb(P(1,n));\n\tREP(i,m) {\n\t\tint x,y;cin>>x>>y;\n\t\tdeque<P> a,b;\n\t\tsum=0;\n\t\twhile(sum+v.front().se<=x) {\n\t\t\tsum+=v.front().se;\n\t\t\ta.pb(v.front());\n\t\t\tv.pop_front();\n\t\t}\n\t\ta.pb(P(v.front().fi,x-sum));\n\t\tif(v.front().se>a.back().se) v.front()=P(v.front().fi+x-sum,v.front().se-a.back().se);\n\t\telse v.pop_front();\n\t\tsum+=a.back().se;\n\t\twhile(sum+v.front().se<=y) {\n\t\t\tsum+=v.front().se;\n\t\t\tb.pb(v.front());\n\t\t\tv.pop_front();\n\t\t}\n\t\tb.pb(P(v.front().fi,y-sum));\n\t\tif(v.front().se>b.back().se) v.front()=P(v.front().fi+y-sum,v.front().se-b.back().se);\n\t\telse v.pop_front();\n\t\twhile(!b.empty()) {\n\t\t\tif(b.front().se!=0) v.pb(b.front());\n\t\t\tb.pop_front();\n\t\t}\n\t\twhile(!a.empty()) {\n\t\t\tif(a.front().se!=0) v.pb(a.front());\n\t\t\ta.pop_front();\n\t\t}\n\t}\n\t//cout<<endl<<\"v\"<<endl;\n\t//for(auto i:v) cout<<i.fi<<' '<<i.se<<endl;\n\tsum=0;\n\tdeque<P> dq,ans;\n\tp--;\n\twhile(sum+v.front().se<=p) {\n\t\tsum+=v.front().se;\n\t\tdq.pb(v.front());\n\t\tv.pop_front();\n\t}\n\tdq.pb(P(v.front().fi,p-sum));\n\tif(v.front().se>dq.back().se) v.front()=P(v.front().fi+p-sum,v.front().se-dq.back().se);\n\telse v.pop_front();\n\tsum+=dq.back().se;\n\twhile(sum+v.front().se<=q) {\n\t\tsum+=v.front().se;\n\t\tans.pb(v.front());\n\t\tv.pop_front();\n\t}\n\tans.pb(P(v.front().fi,q-sum));\n\n\tint cnt=0;\n\tfor(auto s:ans) {\n\t\t//cout<<\"s \"<<s.fi<<' '<<s.se<<endl;\n\t\tif(s.fi>r) continue;\n\t\tif(s.se+s.fi<=r) cnt+=s.se;\n\t\telse cnt+=r-s.fi+1;\n\t}\n\tcout<<cnt<<endl;\n    }\n\n\treturn 0;\n}\n\n"
  },
  {
    "language": "C++",
    "code": "// Very fast O(N^1.5) solution\n\n#include <vector>\n#include <iostream>\n#include <algorithm>\nusing namespace std;\nint main() {\n\tcin.tie(0);\n\tios_base::sync_with_stdio(false);\n\tint N, M, P, Q, R;\n\twhile (cin >> N, N) {\n\t\tcin >> M >> P >> Q >> R;\n\t\tvector<int> X(M), Y(M);\n\t\tfor (int i = 0; i < M; ++i) {\n\t\t\tcin >> X[i] >> Y[i];\n\t\t}\n\t\tint B = 1;\n\t\twhile (B * B < 4 * M) ++B;\n\t\tvector<int> sep = { 0, R, N }, col = { 1, 0 };\n\t\tfor (int i = 0; i < B; ++i) {\n\t\t\tint L = i * M / B, R = (i + 1) * M / B;\n\t\t\tvector<pair<int, int> > ord = { make_pair(0, N) };\n\t\t\tfor (int j = L; j < R; ++j) {\n\t\t\t\tvector<pair<int, int> > ordx, ordy, ordz;\n\t\t\t\tint sum = 0;\n\t\t\t\tfor (int k = 0; k < ord.size(); ++k) {\n\t\t\t\t\tint seg = ord[k].second - ord[k].first, cur = ord[k].first;\n\t\t\t\t\tif (sum < X[j] && X[j] < sum + seg) {\n\t\t\t\t\t\tordx.push_back(make_pair(cur, cur + X[j] - sum));\n\t\t\t\t\t\tcur += X[j] - sum;\n\t\t\t\t\t\tseg -= X[j] - sum;\n\t\t\t\t\t\tsum = X[j];\n\t\t\t\t\t}\n\t\t\t\t\tif (sum < Y[j] && Y[j] < sum + seg) {\n\t\t\t\t\t\tordy.push_back(make_pair(cur, cur + Y[j] - sum));\n\t\t\t\t\t\tcur += Y[j] - sum;\n\t\t\t\t\t\tseg -= Y[j] - sum;\n\t\t\t\t\t\tsum = Y[j];\n\t\t\t\t\t}\n\t\t\t\t\tif (sum < X[j]) ordx.push_back(make_pair(cur, cur + seg));\n\t\t\t\t\telse if (sum < Y[j]) ordy.push_back(make_pair(cur, cur + seg));\n\t\t\t\t\telse ordz.push_back(make_pair(cur, cur + seg));\n\t\t\t\t\tsum += seg;\n\t\t\t\t}\n\t\t\t\tordz.insert(ordz.end(), ordy.begin(), ordy.end());\n\t\t\t\tordz.insert(ordz.end(), ordx.begin(), ordx.end());\n\t\t\t\tord = ordz;\n\t\t\t}\n\t\t\tvector<int> sepptr;\n\t\t\tfor (int j = 0; j < ord.size(); ++j) {\n\t\t\t\tsepptr.push_back(ord[j].first);\n\t\t\t}\n\t\t\tsepptr.push_back(N);\n\t\t\tsort(sepptr.begin(), sepptr.end());\n\t\t\tvector<int> newsep, newcol;\n\t\t\tint curptr = 0;\n\t\t\tfor (int j = 0; j < col.size(); ++j) {\n\t\t\t\tnewsep.push_back(sep[j]);\n\t\t\t\tnewcol.push_back(col[j]);\n\t\t\t\twhile (curptr < sepptr.size() && sepptr[curptr] < sep[j + 1]) {\n\t\t\t\t\tif (sepptr[curptr] != sep[j]) {\n\t\t\t\t\t\tnewsep.push_back(sepptr[curptr]);\n\t\t\t\t\t\tnewcol.push_back(col[j]);\n\t\t\t\t\t}\n\t\t\t\t\t++curptr;\n\t\t\t\t}\n\t\t\t}\n\t\t\tnewsep.push_back(N);\n\t\t\tvector<int> nxtsep, nxtcol;\n\t\t\tint sum = 0;\n\t\t\tfor (int j = 0; j < ord.size(); ++j) {\n\t\t\t\tint ptr = lower_bound(newsep.begin(), newsep.end(), ord[j].first) - newsep.begin();\n\t\t\t\twhile (newsep[ptr] < ord[j].second) {\n\t\t\t\t\tnxtsep.push_back(sum);\n\t\t\t\t\tnxtcol.push_back(newcol[ptr]);\n\t\t\t\t\tsum += newsep[ptr + 1] - newsep[ptr];\n\t\t\t\t\t++ptr;\n\t\t\t\t}\n\t\t\t}\n\t\t\tnxtsep.push_back(N);\n\t\t\tsep = nxtsep, col = nxtcol;\n\t\t}\n\t\tint ans = 0;\n\t\tfor (int i = 0; i < col.size(); ++i) {\n\t\t\tif (col[i] == 1) {\n\t\t\t\tint pl = max(P - 1, sep[i]), pr = min(Q, sep[i + 1]);\n\t\t\t\tif (pl < pr) ans += pr - pl;\n\t\t\t}\n\t\t}\n\t\tcout << ans << endl;\n\t}\n\treturn 0;\n}\n"
  },
  {
    "language": "C++",
    "code": "#include <iostream>\n#include <algorithm>\n#include <vector>\n\nusing namespace std;\ntypedef pair<int,int> pii;\n\nint N;\nint M;\nint P,Q,R;\n\nint main(){\n    while(cin>>N&&N){\n        int res=0;\n        cin>>M>>P>>Q>>R;\n        vector<pii> deck;\n        deck.push_back(pii(1,N));\n        int x,y;\n        for(int i=0;i<M;i++){\n            cin>>x>>y;\n            // xÌÓÆyÌÓðÁèµAVbt\n            int sumX=0;\n            int xPos,yPos;\n            // x+1ÚðÁè\n            x++;\n            for(int j=0;j<deck.size();j++){\n                if(sumX+deck[j].second-deck[j].first+1>=x){\n                    xPos=j;\n                    break;\n                }\n                sumX+=deck[j].second-deck[j].first+1;\n            }\n            int sumY=0;\n            // yÚðÁè\n            for(int j=0;j<deck.size();j++){\n                if(sumY+deck[j].second-deck[j].first+1>=y){\n                    yPos=j;\n                    break;\n                }\n                sumY+=deck[j].second-deck[j].first+1;\n            }\n            // x+1Ú©çy+1ÚÜÅÌÓðØèæèAVbt\n            // ¯¶æÔÉ¶Ý\n            if(xPos==yPos){\n                // »ÝÌæÔðRª\n                pii p1=pii(deck[xPos].first,deck[xPos].first+(x-sumX-2));\n                pii p2=pii(p1.second+1,deck[yPos].first+(y-sumY-1));\n                pii p3=pii(p2.second+1,deck[xPos].second);\n                deck.erase(deck.begin()+xPos);\n                if(p3.first<=p3.second)deck.insert(deck.begin()+xPos,p3);\n                if(p2.first<=p2.second)deck.insert(deck.begin()+xPos,p2);\n                if(p1.first<=p1.second)deck.insert(deck.begin()+xPos,p1);\n            }\n            // ÊÌæÔÉ¶Ý·éêÍA»ê¼êÌæÔ²ÆÉªðs¤\n            else{\n                // x\n                {\n                    pii p1=pii(deck[xPos].first,deck[xPos].first+(x-sumX-2));\n                    pii p2=pii(p1.second+1,deck[xPos].second);\n                    deck.erase(deck.begin()+xPos);\n                    if(p2.first<=p2.second)deck.insert(deck.begin()+xPos,p2);\n                    if(p1.first<=p1.second)deck.insert(deck.begin()+xPos,p1);\n                }\n                // y\n                {\n                    pii p1=pii(deck[yPos].first,deck[yPos].first+(y-sumY-1));\n                    pii p2=pii(p1.second+1,deck[yPos].second);\n                    deck.erase(deck.begin()+yPos);\n                    if(p2.first<=p2.second)deck.insert(deck.begin()+yPos,p2);\n                    if(p1.first<=p1.second)deck.insert(deck.begin()+yPos,p1);\n                }\n            }\n            // à¤êxxÆyÌêðTõµA©Â¯½çVbt\n            sumX=sumY=0;\n            for(int j=0;j<deck.size();j++){\n                if(sumX+deck[j].second-deck[j].first+1>=x){\n                    xPos=j;\n                    break;\n                }\n                sumX+=deck[j].second-deck[j].first+1;\n            }\n            for(int j=0;j<deck.size();j++){\n                if(sumY+deck[j].second-deck[j].first+1>=y){\n                    yPos=j;\n                    break;\n                }\n                sumY+=deck[j].second-deck[j].first+1;\n            }\n            // xpos©çyposÜÅÌÓð²«oµÄAVbt\n            vector<pii> cutPlace;\n            vector<pii> prv;\n            vector<pii> nxt;\n            for(int i=xPos;i<=yPos;i++)cutPlace.push_back(deck[i]);\n            for(int i=0;i<xPos;i++)prv.push_back(deck[i]);\n            for(int i=yPos+1;i<deck.size();i++)nxt.push_back(deck[i]);\n            deck.clear();\n            for(int i=0;i<nxt.size();i++)deck.push_back(nxt[i]);\n            for(int i=0;i<cutPlace.size();i++)deck.push_back(cutPlace[i]);\n            for(int i=0;i<prv.size();i++)deck.push_back(prv[i]);\n        }\n        // VbtI¹ãApÆqÌl©çAðð½·àÌðTõ\n        int sum=0;\n        bool isApP=false;\n        for(int i=0;i<deck.size();i++){\n            int cnt=deck[i].second-deck[i].first+1;\n            sum+=cnt;\n            if(sum<P)continue;\n            // ¡ñÌæÔÉñÂÆàÜÜêéê\n            if(sum-cnt<P&&sum-cnt<Q&&sum>=P&&sum>=Q){\n                int pPos=P-(sum-cnt)-1;\n                int pNum=pPos+deck[i].first;\n                int qPos=Q-(sum-cnt)-1;\n                int qNum=qPos+deck[i].first;\n                // pÌl©çrÈºÌàÌð¦ã°\n                if(pNum<=R)\n                    res+=max(0,min(-qNum+R+1,qNum-pNum+1));\n                break;\n            }\n            // ¡ñÌæÔÅßÄpª»ê½ê\n            else if(!isApP&&sum>=P){\n                isApP=true;\n                int pPos=P-(sum-cnt)-1;\n                int pNum=pPos+deck[i].first;\n                // pÌl©çrÈºÌàÌð¦ã°\n                if(pNum<=R)\n                    res+=max(0,min(-deck[i].first+R+1,deck[i].second-pNum+1));\n            }\n            // pªo»ÏÝÌê\n            else if(isApP){\n                // ¡ñQª»ê½çðµÄbreak\n                if(sum>=Q){\n                    int qPos=Q-(sum-cnt)-1;\n                    int qNum=qPos+deck[i].first;\n                    if(deck[i].first<=R){\n                        if(qNum>=R)res+=R;\n                        else res+=(qNum-deck[i].first+1);\n                    }\n                    break;\n                }\n                // æÔÌl·×ÄÉÎµÄvZ\n                else{\n                    if(deck[i].first<=R){\n                        res+=max(0,min(-deck[i].first+R+1,deck[i].second-deck[i].first+1));\n                    }\n                }\n            }\n        }\n        cout<<res<<endl;\n    }\n    return 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include<iostream>\n#include<cstring>\n#include<queue>\nusing namespace std;\n\nstruct tb{\n\tint f,t;\n\ttb(int f,int t): f(f),t(t) {}\n};\n\n\nint n,m,pr,q,r;\nint chx[5001][3];\n\nint main(void){\n\twhile(1){\n\t\tscanf(\"%d\",&n);\n\t\tif(n==0)break;\n\t\tqueue<tb> c;\n\t\tqueue<tb> d[4];\n\t\tc.push(tb(1,n));\n\t\tscanf(\"%d\",&m);\n\t\tscanf(\"%d%d%d\",&pr,&q,&r);\n\t\tfor(int i=0;i<m;i++){\n\t\t\tscanf(\"%d%d\",&chx[i][1],&chx[i][2]);\n\t\t}\n\t\tfor(int i=0;i<m;i++){\n\t\t\tint sh=1,size=0;\n\t\t\twhile(c.size()){\n\t\t\t\ttb p=c.front();c.pop();\n\t\t\t\tsize+=p.t-p.f+1;\n\t\t\t\tif(sh!=3){\n\t\t\t\t\tif(size<=chx[i][sh]){\n\t\t\t\t\t\td[sh].push(tb(p.f,p.t));\n\t\t\t\t\t\tif(size==chx[i][sh])sh++;\n\t\t\t\t\t}else if(sh==2){\n\t\t\t\t\t\tint x=size-p.t+p.f-1;\n\t\t\t\t\t\tint xx=chx[i][2]-x;\n\t\t\t\t\t\td[2].push(tb(p.f,p.f+xx-1));\n\t\t\t\t\t\td[3].push(tb(p.f+xx,p.t));\n\t\t\t\t\t\tsh++;\n\n\t\t\t\t\t}else if(sh==1 && size<=chx[i][2]){\n\t\t\t\t\t\tint x=size-p.t+p.f-1;\n\t\t\t\t\t\tint xx=chx[i][1]-x;\n\t\t\t\t\t\td[1].push(tb(p.f,p.f+xx-1));\n\t\t\t\t\t\td[2].push(tb(p.f+xx,p.t));\n\t\t\t\t\t\tif(size==chx[i][2])sh++;\n\t\t\t\t\t\tsh++;\n\t\t\t\t\t}else{\n\t\t\t\t\t\tint x=size-p.t+p.f-1;\n\t\t\t\t\t\tint xx=chx[i][1]-x;\n\t\t\t\t\t\tint x2=chx[i][2]-chx[i][1];\n\t\t\t\t\t\td[1].push(tb(p.f,p.f+xx-1));\n\t\t\t\t\t\td[2].push(tb(p.f+xx,p.f+xx+x2-1));\n\t\t\t\t\t\td[3].push(tb(p.f+xx+x2,p.t));\n\t\t\t\t\t\tsh=3;\n\t\t\t\t\t}\n\t\t\t\t}else d[sh].push(tb(p.f,p.t));\n\t\t\t}\n\t\t\tfor(int j=3;j>=1;j--){\n\t\t\t\twhile(d[j].size()){\n\t\t\t\t\ttb p=d[j].front();d[j].pop();\n\t\t\t\t\tint pf=p.f,pt=p.t;\n\t\t\t\t\tc.push(tb(pf,pt));\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t\tint size=0;\n\t\tint ans=0;\n\t\twhile(c.size()){\n\t\t\ttb p=c.front();c.pop();\n\t\t\tint res=0;\n\t\t\tint x=p.f,y=p.t,sy=0;\n\t\t\tif(x<pr)size+=pr-x,x=pr;\n\t\t\tif(y>q)sy=y-q,y=q;\n\t\t\tres=y-x;\n\t\t\tif(size>pr)res-=size-pr;\n\t\t\tif(size+y-x>q)res-=size+y-x-q;\n\t\t\tif(res>0)ans+=res;\n\t\t\tsize+=y-x;\n\t\t\tsize+=sy;\n\t\t}\n\t\tprintf(\"%d\\n\",ans);\n\t}\n    return 0;\n}"
  },
  {
    "language": "C++",
    "code": "//確か、r以下とそれ以外の境界部分のインデックスをうごうごやっていた……気がする。\n//書いた当時のことを覚えていないので、誰か解読してください。\n\n#include <iostream>\n#include <algorithm>\n#include <vector>\nusing namespace std;\n\nint main(){\n\tint n, m, p, q, r, x, y;\n\tvector<int>::iterator itx, ity, it;\n\n\twhile( cin >> n >> m >> p >> q >> r ){\n\t\tvector<int> v1, v2;\n\t\tv1.push_back(0);\n\t\tv1.push_back(r);\n\t\t\n\t\tfor(int i = 0; i < m; ++i){\n\t\t\tcin >> x >> y;\n\t\t\titx = upper_bound(v1.begin(), v1.end(), x);\n\t\t\tity = upper_bound(v1.begin(), v1.end(), y);\n\t\t\t\n\t\t\tif( (ity - v1.begin()) % 2 == 0 ){\tv2.push_back(0);\t}\n\t\t\tv2.push_back(0);\n\n\t\t\tfor(it = ity; it != v1.end(); ++it){\n\t\t\t\tv2.push_back(*it - y);\n\t\t\t}\n\n\t\t\tif( (v1.end() - itx) % 2 != 0 ){\tv2.push_back(n - y);\t}\n\t\t\tfor(it = itx; it != ity; ++it){\n\t\t\t\tv2.push_back(*it - x + n - y);\n\t\t\t}\n\t\t\t\n\t\t\tit = v1.begin();\n\t\t\tif( (ity - v1.begin()) % 2 != 0 ){\t++it;\t}\n\t\t\tif( v1.size() > 1 && !it[1] ){\n\t\t\t\t it += 2;\t//重複排除\n\t\t\t}\n\t\t\tif( *it + n - x == v2.back() ){\t//重複排除\n\t\t\t\t++it;\n\t\t\t\tv2.pop_back();\n\t\t\t}\n\t\t\tfor( ; it != itx; ++it){\n\t\t\t\tv2.push_back(*it + n - x);\n\t\t\t}\n\n\t\t\tv1.swap(v2);\n\t\t\tv2.clear();\n\t\t}\n\n\t\tv1.insert( upper_bound(v1.begin(), v1.end(), p - 1), 2, p - 1);\n\t\tv1.insert( lower_bound(v1.begin(), v1.end(), q), q);\n\t\tv1.push_back(n);\n\n\t\tit = upper_bound(v1.begin(), v1.end(), p - 1);\n\t\tif( (it - v1.begin()) % 2 != 0) --it;\n\n\t\tint ans = 0;\n\t\tfor( ; *it < q; ++it){\n\t\t\tint prev = *it;\n\t\t\t++it;\n\t\t\tans += *it - prev;\n\t\t}\n\t\t\n\t\tcout << ans << '\\n';\n\t}\n}"
  },
  {
    "language": "C++",
    "code": "#include <iostream>\n#include <sstream>\n#include <string>\n#include <algorithm>\n#include <vector>\n#include <stack>\n#include <queue>\n#include <set>\n#include <map>\n#include <cstdio>\n#include <cstdlib>\n#include <cstring>\n#include <cmath>\n#include <cassert>\n\nusing namespace std;\n\n#define FOR(i,k,n) for(int i=(k); i<(int)(n); ++i)\n#define REP(i,n) FOR(i,0,n)\n#define FORIT(i,c) for(__typeof((c).begin())i=(c).begin();i!=(c).end();++i)\n\ntemplate<class T> void debug(T begin, T end){ for(T i = begin; i != end; ++i) cerr<<*i<<\" \"; cerr<<endl; }\ninline bool valid(int x, int y, int W, int H){ return (x >= 0 && y >= 0 && x < W && y < H); }\n\ntypedef long long ll;\nconst int INF = 100000000;\nconst double EPS = 1e-8;\nconst int MOD = 1000000007;\nint dx[8] = {1, 0, -1, 0, 1, -1, -1, 1};\nint dy[8] = {0, 1, 0, -1, 1, 1, -1, -1};\ntypedef pair<int, int> P;\n\nvoid queue_to_vector(queue<P>& stk, vector<P>& v){\n  while(!stk.empty()){\n    v.push_back(stk.front());\n    stk.pop();\n  }\n}\n\nint main(){\n  int N, M, p, q, r;\n  while(cin >> N >> M >> p >> q >> r){\n    vector<P> card;\n    card.push_back(P(1, N));\n    while(M-- > 0){\n      int x, y;\n      cin >> x >> y;\n      int C = 0;\n      queue<P> bottom, mid, top;\n      for(int i = 0; i < card.size(); i++){\n        int num = card[i].second - card[i].first + 1;\n        if(C < x){\n          if(C + num <= x){\n            bottom.push(card[i]);\n            C += num;\n          }else{\n            bottom.push(P(card[i].first, card[i].second - (C + num - x)));\n            card.insert(card.begin() + i + 1, P(card[i].second - (C + num - x) + 1, card[i].second));\n            C = x;\n          }\n        }else if(C < y){\n          if(C + num <= y){\n            mid.push(card[i]);\n            C += num;\n          }else{\n            mid.push(P(card[i].first, card[i].second - (C + num - y)));\n            card.insert(card.begin() + i + 1, P(card[i].second - (C + num - y) + 1, card[i].second));\n            C = y;\n          }\n        }else{\n          top.push(card[i]);\n        }\n      }\n      card.clear();\n      queue_to_vector(top, card);\n      queue_to_vector(mid, card);\n      queue_to_vector(bottom, card);\n    }\n    int C = 0;\n    int ans = 0;\n    p--;\n    for(int i = 0; i < card.size(); i++){\n      int num = card[i].second - card[i].first + 1;\n      if(C < p){\n        if(C + num <= p){\n          C += num;\n        }else{\n          card.insert(card.begin() + i + 1, P(card[i].second - (C + num - p) + 1, card[i].second));\n          C = p;\n        }\n      }else if(C < q){\n        if(C + num <= q){\n          ans += max(0, min(card[i].second, r) - card[i].first + 1);\n          C += num;\n        }else{\n          int E = card[i].second - (C + num - q);\n          ans += max(0, min(E, r) - card[i].first + 1);\n          break;\n        }\n      }else{\n        break;\n      }\n    }\n    cout << ans << endl;\n  }\n  return 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include<cstdio>\n#include<list>\n#include<algorithm>\nusing namespace std;\nstruct S{int a,b;S(int a,int b):a(a),b(b){}};\ntypedef list<S>L;\ntypedef L::iterator I;\nvoid F(L&l,L&s,int x)\n{\n\tfor(I i=l.begin();i!=l.end();++i)\n\t{\n\t\tint c=i->b-i->a;\n\t\tif(x<=c)\n\t\t{\n\t\t\ts.assign(l.begin(),i);\n\t\t\ts.push_back(S(i->a,i->a+x));\n\t\t\tl.erase(l.begin(),i);\n\t\t\tif(c==x)l.erase(i);\n\t\t\telse i->a+=x;\n\t\t\tbreak;\n\t\t}\n\t\tx-=c;\n\t}\n}\nvoid G(L&l,L&s)\n{\n\tI i=s.begin();\n\tif(l.back().b==s.front().a)\n\t{\n\t\tl.back().b=s.front().b;\n\t\t++i;\n\t}\n\tl.insert(l.end(),i,s.end());\n}\nint main()\n{\n\tint n,m,p,q,r,x,y,a,b,c;\n\tL l,s,t;\n\twhile(scanf(\"%d%d%d%d%d\",&n,&m,&p,&q,&r),n)\n\t{\n\t\t--p,--q;\n\t\tl.assign(1,S(1,n+1));\n\t\twhile(m--)\n\t\t{\n\t\t\tscanf(\"%d%d\",&x,&y);\n\t\t\tF(l,s,x);\n\t\t\tF(l,t,y-x);\n\t\t\tG(l,t);\n\t\t\tG(l,s);\n\t\t}\n\t\tm=x=0;\n\t\tfor(I i=l.begin();i!=l.end();++i)\n\t\t{\n\t\t\tc=i->b-i->a;\n\t\t\tif(x<=q&&p<=x+c-1)\n\t\t\t{\n\t\t\t\ta=max(x,p);\n\t\t\t\tb=min(x+c-1,q);\n\t\t\t\tm+=max(0,min(b-a+1,r-i->a+1));\n\t\t\t}\n\t\t\tx+=c;\n\t\t}\n\t\tprintf(\"%d\\n\",m);\n\t}\n\treturn 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include<bits/stdc++.h>\nusing namespace std;\n#define h first\n#define w second\nvector<pair<bool,pair<int,int> > >v;\nint n,m,p,q,r,i;\nvoid Vp(bool a,int b,int c){v.push_back(make_pair(a,make_pair(b,c)));}\nint main(){\n\twhile(cin>>n&&n){\n\tcin>>m>>p>>q>>r;v.clear();\n\tVp(1,1,r);Vp(0,r+1,n);\n\twhile(m--){\n\t\tint x,y;scanf(\"%d%d\",&x,&y);\n\t\tfor(i=0;i<v.size();i++){\n\t\t\tint a=v[i].w.h,b=v[i].w.w;bool c=v[i].h;\n\t\t\tif(a<=x&&x<b){Vp(c,x+1,b);b=x;}\n\t\t\tif(a<=y&&y<b){Vp(c,y+1,b);b=y;}\n\t\t\tif(0<a&&b<=x)a+=n-x,b+=n-x;\n\t\t\telse if(x<a&&b<=y)a+=n-x-y,b+=n-x-y;\n\t\t\telse if(y<a&&b<=n)a-=y,b-=y;\n\t\t\tv[i].w.h=a,v[i].w.w=b;\n\t\t}\n\t}n=0;\n\tfor(i=0;i<v.size();i++)if(v[i].h)n+=max(0,1+min(v[i].w.w,q)-max(v[i].w.h,p));\n\tcout<<n<<endl;\n\t}\n\treturn 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include<deque>\n#include<list>\n#include<map>\n#include<queue>\n#include<set>\n#include<stack>\n#include<vector>\n#include<algorithm>\n#include<string>\n#include<iostream>\n#include<sstream>\n#include<cmath>\n#include<cstdio>\nusing namespace std;\npair<int,int> a[11000],b[11000];\nint sm,l;\nint fi(int i,int p){\n  for(;sm<p;++i)\n    sm+=a[i].second;\n  if(sm>p){\n    copy_backward(a+i,a+l,a+l+1);\n    ++l;\n    a[i-1].second-=sm-p;\n    a[i]=make_pair(a[i-1].first+a[i-1].second,sm-p);\n    sm=p;\n  }\n  return i;\n}\nint main(){\n  int i,j,k;\n  int n;\n  while(scanf(\"%d\",&n),n){\n    int m,p,q,r;\n    scanf(\"%d%d%d%d\",&m,&p,&q,&r);\n    if(r==n){\n      for(i=0;i<m;++i){\n\tint x,y;\n\tscanf(\"%d%d\",&x,&y);\n      }\n      printf(\"%d\\n\",q-p+1);\n      continue;\n    }else{\n      a[0]=make_pair(1,r);\n      a[1]=make_pair(r+1,n-r);\n      l=2;\n    }\n    for(i=0;i<m;++i){\n      int x,y;\n      scanf(\"%d%d\",&x,&y);\n      sm=0;\n      j=fi(0,x);\n      k=fi(j,y);\n      copy(a+k,a+l,b);\n      copy(a+j,a+k,b+l-k);\n      copy_backward(a,a+j,a+l);\n      copy(b,b+l-j,a);\n    }\n    sm=0;\n    j=fi(0,p-1);\n    k=fi(j,q);\n    int ct=0;\n    for(i=j;i<k;++i){\n      if(a[i].first<=r)\n\tct+=a[i].second;\n    }\n    printf(\"%d\\n\",ct);\n  }\n  return 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include <iostream>\n#include <list>\n\nusing namespace std;\n\ntypedef struct {\n\tint s;\n\tint n;\n\tint div_p;\n} DATA;\n\nint main(void)\n{\n\tlist<DATA> data;\n\tlist<DATA>::iterator it;\n\tint n, s_count;\n\tint q, p, r;\n\tDATA c;\n\tint ans;\n\t\n\tcin >> n >> s_count >> p >> q >> r;\n\t\n\tc.s = 1;\n\tc.n = n;\n\tdata.push_back(c);\n\t\n\tfor (int i = 0; i < s_count; i++){\n\t\tlist<DATA> t_data;\n\t\tint x, y;\n\t\t\n\t\tcin >> x >> y;\n\t\ty -= x;\n\t\t\n\t\tit = data.begin();\n\t\twhile (x > 0){\n\t\t\tc.s = it->s;\n\t\t\tif (it->n > x){\n\t\t\t\tit->s += x;\n\t\t\t\tit->n -= x;\n\t\t\t\tc.n = x;\n\t\t\t\tx = 0;\n\t\t\t}\n\t\t\telse {\n\t\t\t\tx -= it->n;\n\t\t\t\tc.n = it->n;\n\t\t\t\tit++;\n\t\t\t}\n\t\t\tc.div_p = 0;\n\t\t\tt_data.push_back(c);\n\t\t}\n\t\twhile (y > 0){\n\t\t\tc.s = it->s;\n\t\t\tif (it->n > y){\n\t\t\t\tit->s += y;\n\t\t\t\tit->n -= y;\n\t\t\t\tc.n = y;\n\t\t\t\ty = 0;\n\t\t\t}\n\t\t\telse {\n\t\t\t\ty -= it->n;\n\t\t\t\tc.n = it->n;\n\t\t\t\tit++;\n\t\t\t}\n\t\t\tc.div_p = 1;\n\t\t\tt_data.push_back(c);\n\t\t}\n\t\t\n\t\twhile (it != data.end()){\n\t\t\tc = *it;\n\t\t\tc.div_p = 2;\n\t\t\tt_data.push_back(c);\n\t\t\tit++;\n\t\t}\n\t\t\n\t\tdata.clear();\n\t\tit = t_data.begin();\n\t\twhile (it->div_p != 2){\n\t\t\tit++;\n\t\t}\n\t\twhile (it != t_data.end()){\n\t\t\tdata.push_back(*it);\n\t\t\tit++;\n\t\t}\n\t\tit = t_data.begin();\n\t\twhile (it->div_p != 1){\n\t\t\tit++;\n\t\t}\n\t\twhile (it->div_p == 1){\n\t\t\tdata.push_back(*it);\n\t\t\tit++;\n\t\t}\n\t\tit = t_data.begin();\n\t\twhile (it->div_p == 0){\n\t\t\tdata.push_back(*it);\n\t\t\tit++;\n\t\t}\n\t\t\n\t}\n\t\n\t\n\tint sum = 0;\n\tint count = 0;\n\tans = 0;\n\tit = data.begin();\n\twhile (sum < p){\n\t\tsum += it->n;\n\t\tit++;\n\t}\n\t\n\t\n\tint end;\n\tif (sum >= p){\n\t\tit--;\n\t\tend = it->s + it->n - 1;\n\t\tfor (int i = 0; i < sum - p + 1; i++){\n\t\t\tif (end - i <= r){\n\t\t\t\tans++;\n\t\t\t}\n\t\t\tcount++;\n\t\t}\n\t\tit++;\n\t}\n\twhile (p + count <= q){\n\t\tfor (int i = 0; i < it->n && p + count <= q; i++){\n\t\t\tif (it->s + i <= r){\n\t\t\t\tans++;\n\t\t\t}\n\t\t\tcount++;\n\t\t}\n\t\tit++;\n\t}\n\t\n\tcout << ans << endl;\n\t\n\treturn (0);\n}"
  },
  {
    "language": "C++",
    "code": "#include<bits/stdc++.h>\nusing namespace std;\n#define int long long\ntypedef pair<int,int> P;\nint n,m;\nvector<P>v;\n\nvector<P> getABC(int &idx,int x){\n  int start= idx;\n  int cnt = 0;\n  while(1){\n    int a = v[idx].first;\n    int b = v[idx].second;\n    cnt+=b-a+1;\n    if( cnt >= x )break;\n    idx++;\n  }\n  vector<P> res;\n  assert(cnt>=x);\n  if(cnt!=x){\n    P p = P(v[idx].second-(cnt-x)+1,v[idx].second);\n    v.insert(v.begin()+idx+1,p);\n    v[idx].second -= (cnt - x);\n  }\n  for(int i=start;i<=idx;i++) res.push_back(v[i]);\n  idx++;\n  //  idx+=cnt!=x;\n  //cout<<\"idx=\"<<idx<<endl;\n  return res;\n}\n\nint Score(int x,int y,int r){\n  int idx = 0;\n  vector<P> A = getABC(idx,x);\n  vector<P> B = getABC(idx,y-x+1);\n  vector<P> C;\n  //cout<<\"B=\";for(int i=0;i<B.size();i++)cout<<B[i].first<<\",\"<<B[i].second<<\" \";cout<<endl;\n  \n  int res = 0;\n  for(int i=0;i<(int)B.size();i++){\n    int a = B[i].first;\n    int b = B[i].second;\n    if(a > r) continue;\n    b = min(b,r);\n    res += b - a + 1;\n  }\n  return res;\n}\n\nsigned main(){\n  while( cin>>n,n){\n    \n    cin>>m;\n    v.clear();\n    v.resize(1,P(0,n-1));\n    int p,q,r;\n    cin>>p>>q>>r; p--,q--,r--;\n    \n    while(m--){\n      int x,y;\n      cin>>x>>y; x--,y--;\n      \n      int idx = 0;\n      vector<P> A = getABC(idx,x+1);\n      //cout<<\"v=\";for(int i=0;i<v.size();i++)cout<<v[i].first<<\",\"<<v[i].second<<\" \";cout<<endl;      \n      vector<P> B = getABC(idx,y-x);\n      vector<P> C;\n  \n      for(;idx<(int)v.size();idx++)C.push_back(v[idx]);\n\n      //cout<<\"A=\";for(int i=0;i<A.size();i++)cout<<A[i].first<<\",\"<<A[i].second<<\" \";cout<<endl;\n      //cout<<\"B=\";for(int i=0;i<B.size();i++)cout<<B[i].first<<\",\"<<B[i].second<<\" \";cout<<endl;\n      //cout<<\"C=\";for(int i=0;i<C.size();i++)cout<<C[i].first<<\",\"<<C[i].second<<\" \";cout<<endl;\n      //cout<<\"V=\";for(int i=0;i<v.size();i++)cout<<v[i].first<<\",\"<<v[i].second<<\" \";cout<<endl;      \n      v.clear();\n      for(int i=0;i<(int)C.size();i++) v.push_back(C[i]);\n      for(int i=0;i<(int)B.size();i++) v.push_back(B[i]);\n      for(int i=0;i<(int)A.size();i++) v.push_back(A[i]);\n      //cout<<\"v=\";for(int i=0;i<v.size();i++)cout<<v[i].first<<\",\"<<v[i].second<<\" \";cout<<endl;      \n    }\n    \n    //for(int i=0;i<v.size();i++)cout<<v[i].first<<\",\"<<v[i].second<<\" \";cout<<endl;\n    \n    cout<<Score(p,q,r)<<endl;\n  }  \n  return 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include <iostream>\n#include <cstdio>\n#include <cmath>\n#include <vector>\n#include <map>\n#include <stack>\n#include <queue>\n#include <algorithm>\n#include <set>\n\n#define FOR(i,a,b) for(int i=(a);i<(b);i++)\n#define REP(i,j) FOR(i,0,j)\n#define mp std::make_pair\n\ntypedef long long ll;\ntypedef unsigned long long ull;\ntypedef std::pair<int,int> P;\ntypedef std::pair<int,P> State;\n\nconst int INF = 1001001001;\n\n// S N E W(南北東西)\nconst int dx[8] = {0, 0, 1, -1, 1, 1, -1, -1}, dy[8] = {1, -1, 0, 0, 1, -1, 1, -1};\n\nstruct Node{\n    int first, last;\n    Node *prev, *next;\n};\n\nint N, M;\nint p, q, r;\n\nNode* get(Node* n, int index){\n    int size = n->last - n->first + 1;\n    if(index == 0){\n        return n;\n    }else if(0 < index && index < size){\n        Node* new_node = new Node{n->first + index, n->last, n, n->next};\n        n->last = n->first + index - 1;\n        n->next = new_node;\n        return new_node;\n    }\n    return get(n->next, index - size);\n}\n\nNode* end(Node* n){\n    if(n->next == nullptr){return n;}\n    return end(n->next);\n}\n\nvoid print(Node *n){\n    printf(\"[%d, %d]\\n\", n->first, n->last);\n    if(n->next == nullptr){puts(\"---------------------------\");return;}\n    print(n->next);\n}\n\nP intersect(const P lp, const P rp){\n    if(rp.first <= lp.first && lp.second <= rp.second){return lp;}\n    if(lp.first <= rp.first && rp.second <= lp.second){return rp;}\n    if(rp.first <= lp.first && lp.first < rp.second){return mp(lp.first, rp.second);}\n    if(lp.first <= rp.first && rp.first < lp.second){return mp(rp.first, lp.second);}\n    return mp(-1, -1);\n}\n\nint count(Node *n, int first){\n    if(n == nullptr){return 0;}\n    int size = n->last - n->first + 1, res = 0;\n    P is = intersect(mp(first, first+size), mp(p, q));\n    is.second = std::min(is.second, is.first + r - n->first + 1);\n    // printf(\"%d, %d, %d, %d\\n\", is.first, is.second, is.first-first, is.second-first);\n    if(is.first != -1 && n->first+is.first-first <= r){\n        //printf(\"wa-: %d, %d\\n\", n->first, n->last);\n        \n        res += is.second - is.first;\n    }\n    res += count(n->next, first+size);\n    return res;\n}\n\n// intersect(mp(0, 3), mp(1, 10)) -> (1, 3)\n// intersect(mp(0, 9), mp(1, 10)) -> (1, 9)\nint main(){\n    while(std::cin >> N >> M, N){\n        std::cin >> p >> q >> r;\n        --p;\n\n        Node *root = new Node{1, N, nullptr, nullptr};\n\n        REP(i, M){\n            int a, b;\n            std::cin >> a >> b;\n\n            Node *f1 = root, *s1 = get(root, a), *t1 = get(root, b),\n                *f2 = s1->prev, *s2 = t1->prev, *t2 = end(root);\n        \n            t2->next = s1;\n            s1->prev = t2;\n\n            s2->next = f1;\n            f1->prev = s2;\n\n            f2->next = nullptr;\n        \n            root = t1;\n            // print(root);\n        }\n\n        printf(\"%d\\n\", count(root, 0));\n    }\n}"
  },
  {
    "language": "C++",
    "code": "#include<cstdio>\n#include<deque>\n#include<map>\n#include<algorithm>\nusing namespace std;\n\nint main(){\n  while(1){\n    int n, m, p, q, r;\n    scanf(\"%d\", &n);\n    if(n == 0)return 0;\n    scanf(\"%d%d%d%d\", &m, &p, &q, &r);\n    deque<pair<int, int> > mountain, mounta, mountb;\n    mountain.push_back(make_pair(1, n));\n    for(int i = 0;i < m;i++){\n      int x, y, j = 0;\n      scanf(\"%d%d\", &x, &y);\n      \n      while(j + mountain[0].second - mountain[0].first + 1 < x){\n\tj += mountain[0].second - mountain[0].first + 1;\n\tmounta.push_back(mountain[0]);\n\tmountain.pop_front();\n      }\n      mounta.push_back(make_pair(mountain[0].first ,mountain[0].first + x - j - 1));\n      if(mountain[0].second == mountain[0].first + x - j - 1)mountain.pop_front();\n      else mountain[0].first += x - j;\n      j = x;\n\n      while(j + mountain[0].second - mountain[0].first + 1 < y){\n\tj += mountain[0].second - mountain[0].first + 1;\n\tmountb.push_back(mountain[0]);\n\tmountain.pop_front();\n      }\n      mountb.push_back(make_pair(mountain[0].first ,mountain[0].first + y - j - 1));\n      if(mountain[0].second == mountain[0].first + y - j - 1)mountain.pop_front();\n      else mountain[0].first += y - j;\n      \n      while(!mountb.empty()){\n\tmountain.push_back(mountb[0]);\n\tmountb.pop_front();\n      }\n      while(!mounta.empty()){\n\tmountain.push_back(mounta[0]);\n\tmounta.pop_front();\n      }\n    }\n    int j = 0;\n    while(j + mountain[0].second - mountain[0].first + 1 < p - 1){\n      j += mountain[0].second - mountain[0].first + 1;\n      mountain.pop_front();\n    }\n    if(mountain[0].second == mountain[0].first + p - j - 2)mountain.pop_front();\n    else mountain[0].first += p - j - 1;\n    j = p - 1;\n    \n    int res = 0;\n    while(j + mountain[0].second - mountain[0].first + 1 < q){\n      res += max(0, min(r, mountain[0].second) - mountain[0].first + 1);\n      j += mountain[0].second - mountain[0].first + 1;\n      mountain.pop_front();      \n    }\n    res += max(0, min(r, mountain[0].first + q - j - 1) - mountain[0].first + 1);\n    printf(\"%d\\n\", res);\n  }\n}"
  },
  {
    "language": "C++",
    "code": "#include <iostream>\n#include <cstdio>\n#include <cmath>\n#include <vector>\n#include <map>\n#include <stack>\n#include <queue>\n#include <algorithm>\n#include <set>\n\n#define FOR(i,a,b) for(int i=(a);i<(b);i++)\n#define REP(i,j) FOR(i,0,j)\n#define mp std::make_pair\n\ntypedef long long ll;\ntypedef unsigned long long ull;\ntypedef std::pair<int,int> P;\ntypedef std::pair<int,P> State;\n\nconst int INF = 1001001001;\n\n// S N E W(南北東西)\nconst int dx[8] = {0, 0, 1, -1, 1, 1, -1, -1}, dy[8] = {1, -1, 0, 0, 1, -1, 1, -1};\n\nint N, M;\n\nstruct Node{\n    int begin, end;\n    Node *prev, *next;\n};\n\n// 0, 1, 2, 3, 4, 5, 6, 7, 8\n// 1, 2, 3, 4, 5, 6, 7, 8, 9\n// [6, 7, 8, 9], [4, 5], [1, 2, 3]\nNode* update(Node* n, int index){\n    int size = n->end - n->begin;\n    if(index == 0){\n        return n;\n    }else if(0 < index && index < size){\n        Node* new_node = new Node{n->begin + index, n->end, n, n->next};\n        n->end = new_node->begin;\n        n->next = new_node;\n        if(new_node->next != nullptr){new_node->next->prev = new_node;}\n        return new_node;\n    }\n    return update(n->next, index-size);\n}\n\nNode* tail(Node* n){\n    if(n->next == nullptr){return n;}\n    return tail(n->next);\n}\n\nvoid test(Node* n){\n    while(n != nullptr){\n        printf(\"[%d, %d)\\n\", n->begin, n->end);\n        n = n->next;\n    }\n    puts(\"---------------------------\");\n}\n\nP intersect(int al, int ar, int bl, int br){\n    if(al <= bl && br <= ar){return mp(bl, br);}\n    if(bl <= al && ar <= br){return mp(al, ar);}\n    if(al <= bl && bl < ar){return mp(bl, ar);}\n    if(bl <= al && al < br){return mp(al, br);}\n    return mp(-1, -1);\n}\n\nint count(Node* root, int begin, int end, int v){\n    int pos = 0, res = 0;\n    while(root != nullptr){\n        int size = root->end - root->begin;\n        \n        if(v - root->begin >= 0){\n            P is = intersect(begin, end, pos, pos+std::min(v-root->begin+1, size));\n            if(is.first != -1){\n                res += is.second - is.first;\n            }\n        }\n\n        pos += size;\n        root = root->next;\n    }\n\n    return res;\n}\n\nint main(){\n    while(std::cin >> N >> M, N){\n        int p, q, r;\n        std::cin >> p >> q >> r;\n\n        Node *root = new Node{1, N+1, nullptr, nullptr};\n        REP(i, M){\n            int a, b;\n            std::cin >> a >> b;\n\n            // シャッフル前 [a1, ..., a2], [b1, ..., b2], [c1, ..., c2]\n            // シャッフル後 [c1, ..., c2], [b1, ..., b2], [a1, ..., a2] (a2後ろの接続を断つ)\n            Node *a1 = root, *b1 = update(root, a), *c1 = update(root, b),\n                *a2 = b1->prev, *b2 = c1->prev, *c2 = tail(root);\n\n            // printf(\"a1: [%d, %d), a2: [%d, %d)\\n\", a1->begin, a1->end, a2->begin, a2->end);        \n            // printf(\"b1: [%d, %d), b2: [%d, %d)\\n\", b1->begin, b1->end, b2->begin, b2->end);\n            // printf(\"c1: [%d, %d), c2: [%d, %d)\\n\", c1->begin, c1->end, c2->begin, c2->end);\n\n            c2->next = b1;\n            b1->prev = c2;\n            b2->next = a1;\n            a1->prev = b2;\n            a2->next = nullptr;\n\n            root = c1;\n        }\n        printf(\"%d\\n\", count(root, p-1, q, r));\n    }\n}"
  },
  {
    "language": "C++",
    "code": "#include<iostream>\n#include<algorithm>\n#include<vector>\nusing namespace std;main(){int n,m,p,q,r,x,y;vector<int>::iterator u,v,z;for(;cin>>n>>m>>p>>q>>r;cout<<x<<endl){vector<int>s,t;s.push_back(0);for(s.push_back(r);m--;t.clear()){cin>>x>>y;u=upper_bound(s.begin(),s.end(),x);v=upper_bound(s.begin(),s.end(),y);if(v-s.begin()+1&1)t.push_back(0);t.push_back(0);for(z=v;z!=s.end();++z)t.push_back(*z-y);if(s.end()-u&1)t.push_back(n-y);for(z=u;z!=v;++z)t.push_back(*z-x+n-y);z=s.begin();if(v-s.begin()&1)++z;if(!z[1])z+=2;if(*z+n-x==t.back()){++z;t.pop_back();}for(;z!=u;++z)t.push_back(*z+n-x);s.swap(t);}s.insert(upper_bound(s.begin(),s.end(),p-1),2,p-1);s.insert(lower_bound(s.begin(),s.end(),q),q);s.push_back(n);z=upper_bound(s.begin(),s.end(),p-1);if(z-s.begin()&1)--z;for(x=0;*z<q;++z)m=*z++,x+=*z-m;}}"
  },
  {
    "language": "C++",
    "code": "#include<iostream>\n#include<map>\n#include<queue>\nusing namespace std;\ntypedef pair<int,int> P;\n#define fr first\n#define sc second\n#define rep(i,n) for(int i = 0 ; i < n ; ++i )\n\nint n,m,p,q,r;int a;\ndeque<P> card;\n\nint query(){\n  int sum = 0,ans = 0;\n  while(sum + card.front().sc - card.front().fr + 1 < p){\n    sum += card.front().sc - card.front().fr + 1;\n    card.pop_front();\n  }\n  if(sum + 1 != p) card.front().fr = card.front().fr + p - sum;\n  sum = p;\n  while(sum + card.front().sc - card.front().fr + 1 <= q){\n    if(card.front().sc <= r){ //完全に含む\n      ans += card.front().sc - card.front().fr + 1;\n    }else if(card.front().fr <= r){ //微妙に含む\n      ans += r - card.front().fr + 1;\n    }\n    sum += card.front().sc - card.front().fr + 1;\n    card.pop_front();\n  }\n  if(!card.empty() && sum != q){\n    card.push_front(P(card.front().fr,card.front().fr+q-sum-1));\n    if(card.front().sc <= r){ //完全に含む\n      ans += card.front().sc - card.front().fr + 1;\n    }else if(card.front().fr <= r){ //微妙に含む\n      ans += r - card.front().fr + 1; \n    }\n  }\n  return ans;\n}\n\nvoid deb(deque<P>& tmp){\n  cout << endl;\n  for(deque<P>::iterator it = tmp.begin();it!=tmp.end();it++){\n    cout << (*it).fr << \" \" << (*it).sc << endl;\n  }\n}\ndeque<P> shuffle(int x,int y){\n  deque<P> A,B,C;\n  int sum = 0;\n  while(sum + card.front().sc - card.front().fr + 1 <= x){\n    A.push_back(card.front());\n    sum += card.front().sc - card.front().fr + 1;\n    card.pop_front();\n  }\n\n  if(sum != x){\n    A.push_back(P(card.front().fr,card.front().fr + x - sum - 1));\n    card.front().fr = card.front().fr + x - sum;\n    sum = x;\n  }\n  while(sum + card.front().sc - card.front().fr + 1 <= y){\n    B.push_back(card.front());\n    sum += card.front().sc - card.front().fr + 1;\n    card.pop_front();\n  }\n\n  if(sum != y){\n    B.push_back(P(card.front().fr,card.front().fr + y - sum - 1));\n    card.front().fr = card.front().fr + y - sum;\n    sum = y;\n  }\n  while(!card.empty()){\n    C.push_back(card.front());\n    card.pop_front();\n  }\n  C.insert(C.end(),B.begin(),B.end());\n  C.insert(C.end(),A.begin(),A.end());\n  return C;\n}\n\nint main(){\n  while(cin >> n , n){\n    cin >> m >> p >> q >> r;\n    p--;\n    card.push_back(P(1,n));\n    while(m--){\n      int x,y;\n      cin >> x >> y;\n      card = shuffle(x,y);\n    }\n    cout << query() << endl;\n    card.clear();\n  }\n}"
  },
  {
    "language": "C++",
    "code": "#include <cstdio>\n#include <algorthm>\n#include <queue>\nusing namespace std;\ntypedef pair<int,int> P;\n#define mp make_pair\n#define f first\n#define s second\nint main(){\nwhile(1){\nint n,m,p,q,r;\nqueue<P>que;\nscanf(\"%d\",&n);\nif(!n) break;\nscanf(\"%d\",&m);\nscanf(\"%d %d %d\",&p,&q,&r);\nque.push(mp(1,r));\nfor(int i=0;i<m;i++){\n\tint x,y;\n\tscanf(\"%d %d\",&x,&y);\n\tint e=que.size();\n\tfor(int j=0;j<e;j++){\n\t\tP pp=que.front(); que.pop();\n\t\tint a=pp.f,b=pp.s;\n\t\tif(b<=x){\n\t\t\tque.push(mp(n-x+a,n-x+b));\n\t\t}else if(b>x && b<=y){\n\t\t\tif(a<=x){\n\t\t\t\tque.push(mp(n-x+a,n));\n\t\t\t\tque.push(mp(n-y+1,n+b-x-y));\n\t\t\t}else{\n\t\t\t\tque.push(mp(n-y+a-x,n+b-x-y));\n\t\t\t}\n\t\t}else{\n\t\t\tif(a<=x){\n\t\t\t\tque.push(mp(1,b-y));\n\t\t\t\tque.push(mp(n-x+a,n));\n\t\t\t\tque.push(mp(n-y+1,n-x));\n\t\t\t}else if(a>x && a<=y){\n\t\t\t\tque.push(mp(1,b-y));\n\t\t\t\tque.push(mp(n-y-x+a,n-x));\n\t\t\t}else{\n\t\t\t\tque.push(mp(a-y,b-y));\n\t\t\t}\n\t\t}\n\t}\n}\nint ans=0;\nwhile(que.size()){\nP pp=que.front(); que.pop();\nif(pp.s<p || pp.f>q){\ncontinue;\n}else if(pp.f<q){\nans+=q-pp.f+1;\n}else{\nans+=pp.s-p+1;\n}\n}\nprintf(\"%d\\n\",ans);\n}\nreturn 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include <iostream>\n#include <vector>\n\n#define T_CT 1\n#define T_NC 2\n\nusing namespace std;\n\ntypedef struct\n{\n\tint count;\n\tint type;\n} bulk;\n\nint N,M,P,Q,R;\nvector<bulk> S;\nbulk tb;\n\nbulk* makebulk(int count,int type)\n{\n\ttb.count = count;\n\ttb.type = type;\n\treturn &tb;\n}\n\nvoid shuffle(int x,int y)\n{\n\tint sum = 0;\n\tauto itr = S.begin();\n\tint countv = 0;\n\twhile(true)\n\t{\n\t\titr = S.begin();\n\t\tif(sum + itr->count <= x)\n\t\t{\n\t\t\tS.push_back(*itr);\n\t\t\tsum += itr->count;\n\t\t\tS.erase(itr);\n\t\t\tcountv++;\n\t\t}\n\t\telse\n\t\t{\n\t\t\tif(sum != x)\n\t\t\t{\n\t\t\t\titr->count -= x - sum;\n\t\t\t\tS.push_back(*makebulk(x-sum,itr->type));\n\t\t\t\tcountv++;\n\t\t\t}\n\t\t\tbreak;\n\t\t}\n\t}\n\tauto endi = S.end()-countv;\n\titr = S.begin();\n\tsum = 0;\n\twhile(true)\n\t{\n\t\titr = S.begin();\n\t\tif(sum + itr->count <= y-x)\n\t\t{\n\t\t\tS.insert(endi,*itr);\n\t\t\tsum += itr->count;\n\t\t\tS.erase(itr);\n\t\t}\n\t\telse\n\t\t{\n\t\t\tif(sum != y-x)\n\t\t\t{\n\t\t\t\titr->count -= (y-x) - sum;\n\t\t\t\tS.insert(endi,*makebulk((y-x)-sum,itr->type));\n\t\t\t\tendi++;\n\t\t\t}\n\t\t\tbreak;\n\t\t}\n\t}\n\tfor(auto it = S.begin();it < S.end()-1;it++)\n\t{\n\t\tif(it->type == (it+1)->type)\n\t\t{\n\t\t\tit->count += (it+1)->count;\n\t\t\tS.erase(it+1);\n\t\t\tit--;\n\t\t}\n\t}\n\t\n}\n\nint main(void)\n{\n\twhile(true)\n\t{\n\t\tcin >> N;\n\t\tif(N == 0)\n\t\t\texit(0);\n\t\tcin >> M >> P >> Q >> R;\n\t\tS.clear();\n\t\tS.push_back(*makebulk(R,T_CT));\n\t\tS.push_back(*makebulk(N-R,T_NC));\n\t\tint a,b;\n\t\tfor(int i = 0;i < M;i++)\n\t\t{\n\t\t\tcin >> a >> b;\n\t\t\tshuffle(a,b);\n\t\t}\n\t\tint sum = 0;\n\t\tauto itr = S.begin();\n\t\twhile(true)\n\t\t{\n\t\t\titr = S.begin();\n\t\t\tif(sum + itr->count <= P-1)\n\t\t\t{\n\t\t\t\tsum += itr->count;\n\t\t\t\tS.erase(itr);\n\t\t\t}\n\t\t\telse\n\t\t\t{\n\t\t\t\tif(sum != P-1)\n\t\t\t\t{\n\t\t\t\t\titr->count -= (P-1)-sum;\n\t\t\t\t}\n\t\t\t\tbreak;\n\t\t\t}\n\t\t}\n\t\tsum = 0;\n\t\tint count = (Q - P) + 1;\n\t\tint result = 0;\n\t\twhile(true)\n\t\t{\n\t\t\titr = S.begin();\n\t\t\tif(sum + itr->count <= count)\n\t\t\t{\n\t\t\t\tif(itr->type == T_CT)\n\t\t\t\t{\n\t\t\t\t\tresult += itr->count;\n\t\t\t\t}\n\t\t\t\tsum += itr->count;\n\t\t\t\tS.erase(itr);\n\t\t\t}\n\t\t\telse\n\t\t\t{\n\t\t\t\tif(sum != count)\n\t\t\t\t{\n\t\t\t\t\tif(itr->type == T_CT)\n\t\t\t\t\t{\n\t\t\t\t\t\tresult += count - sum;\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t\tbreak;\n\t\t\t}\n\t\t}\n\t\tcout << result << endl;\n\t}\n}"
  },
  {
    "language": "C++",
    "code": "#include<iostream>\n#include<list>\n\nusing namespace std;\n\ntypedef pair<int,int> range;\ntypedef list< range > deck;\n\ninline int quant(const range &r){\n  return r.second-r.first+1;\n}\n\nint shuffle(int x, int y, deck &D, bool count = false, int r = 0){\n  deck d1,d2,d3;\n\n  // part I\n  int precnt = 0, cnt = 0;\n  for(deck::iterator itd = D.begin(); itd != D.end(); ++itd){\n    cnt += quant( *itd );\n    if( cnt >= x ){\n      d1.push_back( range( itd->first, itd->first + (x-precnt) - 1 ) );\n      break;\n    }else{\n      d1.push_back( *itd );\n    }\n    precnt = cnt;\n  }\n  \n  // part II\n  precnt = cnt = 0;\n  bool first=true;\n  for(deck::iterator itd = D.begin(); itd != D.end(); ++itd){\n    cnt += quant( *itd );\n    if( precnt <= x && precnt <= y && cnt > x && cnt > y ){\n      d2.push_back( range( itd->first + (x-precnt), itd->first + (y-precnt) - 1 )  );\n      // cout << \"A : \" << d2.back().first << ' ' << d2.back().second << endl;\n      break;\n    }else if( cnt >= x && first ){\n      d2.push_back( range( itd->first + (x-precnt), itd->second ) );\n      // cout << \"B : \" << d2.back().first << ' ' << d2.back().second << endl;\n      first = false;\n    }else if( cnt >= x && cnt < y  ){\n      d2.push_back( *itd );\n      // cout << \"C : \" << d2.back().first << ' ' << d2.back().second << endl;\n    }else if( cnt >= y ){\n      d2.push_back( range( itd->first, itd->first + (y-precnt) - 1 ) );\n      // cout << \"D : \" << d2.back().first << ' ' << d2.back().second << endl;\n      break;\n    }\n    precnt = cnt;\n  }\n  \n  // part III\n  precnt = cnt = 0;\n  first=true;\n  for(deck::iterator itd = D.begin(); itd != D.end(); ++itd){\n    cnt += quant( *itd );\n    if( cnt > y && first ){\n      d3.push_back( range( itd->first + (y-precnt), itd->second ) );\n      first=false;\n    }else if( !first ){\n      d3.push_back( *itd );\n    }\n    precnt = cnt;\n  }\n\n  D.clear();\n/*\n  cout << \"D1\" << endl;\n  for(deck::iterator itd=d1.begin();itd!=d1.end();++itd){\n    cout << '(' << itd->first << \" - \" << itd->second << ')' << endl;\n  }cout << \"D2\" << endl;\n  for(deck::iterator itd=d2.begin();itd!=d2.end();++itd){\n    cout << '(' << itd->first << \" - \" << itd->second << ')' << endl;\n  }cout << \"D3\" << endl;\n  for(deck::iterator itd=d3.begin();itd!=d3.end();++itd){\n    cout << '(' << itd->first << \" - \" << itd->second << ')' << endl;\n  }\n  cout << endl;\n*/\n\n  if( count ){\n    int ret = 0;\n    if(d1.back().second <= r ) ++ret;\n    for(deck::iterator itd=d2.begin(); itd!=d2.end(); ++itd){\n      //cout << itd->first << ' ' << itd->second << endl;\n      if( itd->first <= r ){\n\tret += ( min(itd->second,r) - itd->first + 1);\n      }\n    }\n    return ret;\n  }\n  \n  D.insert( D.begin(), d1.begin(), d1.end() );\n  D.insert( D.begin(), d2.begin(), d2.end() );\n  D.insert( D.begin(), d3.begin(), d3.end() );\n  \n  return 0;\n}\n\nvoid CompressDeck(deck &D){\n  deck::iterator itd = D.begin();\n  for(;itd!=D.end();++itd){\n    deck::iterator itnx = itd;\n    itnx++;\n    if( itnx == D.end() ) break;\n    if( itd->second + 1 == itnx->first ){\n      itd->second = itnx->second;\n      itd = D.erase( itnx );\n      --itd;--itd;\n    }\n  }\n}\n\nint main()\n{\n  while(true){\n    int n,m,p,q,r;\n    deck D;\n    scanf(\"%d\",&n);\n    if( n == 0 ) break;\n    scanf(\"%d%d%d%d\", &m, &p, &q, &r);\n    D.push_back( range(1,n) );\n    for(int i = 0; i < m; ++i){\n      int x,y;\n      scanf(\"%d%d\", &x, &y);\n      shuffle( x, y, D );\n      // compress\n      CompressDeck( D );\n      /*\n      for(deck::iterator itd=D.begin();itd!=D.end();++itd){\n\tcout << '(' << itd->first << \" - \" << itd->second << ')' << endl;\n      }\n      cout << endl;\n      */\n    }\n    printf(\"%d\\n\", shuffle( p, q, D, true, r ));\n  }\n  return 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include <iostream>\n#include <algorithm>\n#include <vector>\n#include <map>\n\nusing namespace std;\n\ntypedef pair<int, int> P;\n\nint n, m, p, q, r;\nvector<P> data[2][3];\n\nvoid calc(int t, int a, int b){\n  int pos = 2, cnt = 0, nex = 1 - t, id = 0;\n  int c[2] = {a, b};\n  \n  for(int i=0;i<3;i++) data[nex][i].clear();\n  for(int i=0;i<3;i++){\n    for(int j=0;j<data[t][i].size();j++){\n      if(id == 2) data[nex][pos].push_back(data[t][i][j]);\n      else{\n        int val = cnt + data[t][i][j].second - data[t][i][j].first + 1;\n        if(id == 0 && c[0] < val && c[1] < val){\n          data[nex][pos].push_back(P(data[t][i][j].first, data[t][i][j].second - (val - c[id])));\n          pos--;\n          id++;\n          data[nex][pos].push_back(P(data[t][i][j].second - (val - c[id-1]) + 1, data[t][i][j].second - (val - c[id])));\n          pos--;\n          id++;\n          data[nex][pos].push_back(P(data[t][i][j].second - (val - c[id-1]) + 1, data[t][i][j].second));\n        }else if(val < c[id]){\n          data[nex][pos].push_back(data[t][i][j]);\n        }else if(val == c[id]){\n          data[nex][pos].push_back(data[t][i][j]);\n          pos--;\n          id++;\n        }else if(val > c[id]){\n          int tmp = val - c[id];\n          data[nex][pos].push_back(P(data[t][i][j].first, data[t][i][j].second - tmp));\n          pos--;\n          id++;\n          data[nex][pos].push_back(P(data[t][i][j].second - tmp + 1, data[t][i][j].second));\n        }\n      }\n      cnt += data[t][i][j].second - data[t][i][j].first + 1;\n    }\n  }\n}\n\nmain(){\n  while(cin >> n && n){\n    for(int i=0;i<2;i++) for(int j=0;j<3;j++) data[i][j].clear();\n    cin >> m >> p >> q >> r;\n    data[0][0].push_back(P(1, n));\n    for(int i=0;i<m;i++){\n      int a, b;\n      cin >> a >> b;\n      calc(i%2, a, b);\n    }\n    int ans = 0;\n    int cnt = 0;\n    for(int i=0;i<3;i++){\n      for(int j=0;j<data[m%2][i].size();j++){\n        P tmp = data[m%2][i][j];\n        int len = tmp.second - tmp.first + 1;\n        if(cnt <= p && q <= cnt + len){\n          int v1 = tmp.first + (p - cnt - 1);\n          int v2 = r - (v1 - 1);\n          ans += max(0, min(v2, q - p + 1));\n        }else if(p <= cnt && cnt + len <= q){\n          int v1 = tmp.first - 1;\n          int v2 = r - v1;\n          ans += max(0, min(v2, len));\n        }else if(cnt <= p && p <= cnt + len){\n          int v1 = tmp.first + (p - cnt - 1); \n          int v2 = r - (v1 - 1);\n          ans += max(0, min(v2, len - (p - cnt - 1)));\n        }else if(cnt <= q && q <= cnt + len){\n          int v1 = tmp.first - 1;\n          int v2 = r - v1;\n          ans += max(0, min(v2, q - cnt));\n        }\n        cnt += len;\n      }\n    }\n    cout << ans << endl;\n  }\n}"
  },
  {
    "language": "C++",
    "code": "#include <set>\n#include <map>\n#include <list>\n#include <queue>\n#include <stack>\n#include <cmath>\n#include <ctime>\n#include <cstdio>\n#include <vector>\n#include <string>\n#include <bitset>\n#include <cctype>\n#include <cstdlib>\n#include <cstring>\n#include <utility>\n#include <numeric>\n#include <complex>\n#include <sstream>\n#include <fstream>\n#include <iomanip>\n#include <cassert>\n#include <iostream>\n#include <iterator>\n#include <algorithm>\n\nusing namespace std;\n\n//4方向ベクトル→↑←↓\nint dx[] ={1,0,-1,0};\nint dy[] ={0,-1,0,1};\n\nvector<int> Card;\nvector<int> Cardtemp;\nint n;//カードの枚数\nint m;//シャッフルの回数\nint x,y;//シャッフルする(x,y)\nint p,q,r;//p行q行以下に番号r以下のカードが何枚含まれているか\nint main()\n{\n  while(1){\n  scanf(\"%d\",&n);\n  if(n==0)\n    break;\n  scanf(\"%d\",&m);\n  scanf(\"%d %d %d\",&p,&q,&r);\n  Card.clear();\n  for(int i = 1;i <=n;i++){\n    Card.push_back(i);\n  }\n  int ans = 0;\n  for(int i = 1;i <=m;i++){\n    Cardtemp = Card;\n    scanf(\"%d %d\",&x,&y);\n    for(int j = 0;j <=n-(y+1);j++){\n      Card[j] = Cardtemp[y+j];\n    }\n    for(int j = 0;j <=y-(x+1);j++){\n      Card[n-y+j] = Cardtemp[x+j];\n\t}\n    for(int j = 0;j <=x-1;j++){\n      Card[n-x+j] = Cardtemp[j];\n    }\n  }\n  for(int i = p-1;i < q;i++){\n    if(Card[i] <= r)\n      ans++;\n  }\n  cout <<ans<<endl;\n  }\n  return 0;\n}"
  },
  {
    "language": "C++",
    "code": "#define _USE_MATH_DEFINES\n#define INF 0x3f3f3f3f\n\n#include <iostream>\n#include <cstdio>\n#include <sstream>\n#include <cmath>\n#include <cstdlib>\n#include <algorithm>\n#include <queue>\n#include <stack>\n#include <limits>\n#include <map>\n#include <string>\n#include <cstring>\n#include <set>\n#include <deque>\n#include <bitset>\n#include <list>\n#include <cctype>\n#include <utility>\n  \nusing namespace std;\n  \ntypedef long long ll;\ntypedef pair <int,int> P;\ntypedef pair <int,P> PP;\n  \nstatic const double EPS = 1e-8;\n  \nstatic const int tx[] = {0,1,0,-1};\nstatic const int ty[] = {-1,0,1,0};\n\nint main(){\n  int total_cards;\n  while(~scanf(\"%d\",&total_cards)){\n    if(total_cards == 0) break;\n    int total_shuffles;\n    int first,last,upper;\n\n    scanf(\"%d\",&total_shuffles);\n    scanf(\"%d %d %d\",&first,&last,&upper);\n    \n    vector<P> cards;\n    cards.push_back(P(1,total_cards));\n\n    for(int shuffle_idx=0;shuffle_idx<total_shuffles;shuffle_idx++){\n      int x,y;\n      scanf(\"%d %d\",&x,&y);\n      //x -> none\n      //y -> 1\n      //n -> x+1\n      //C -> B -> A\n      vector<P> A;\n      vector<P> B;\n      vector<P> C;\n      vector<P> next;\n\n      int sum = 0;\n      int prev_sum = 0;\n      for(int j=0;j<cards.size();j++){\n        prev_sum = sum;\n        sum += cards[j].second - cards[j].first + 1;\n        if(prev_sum < x){\n          if(sum <= x){\n            A.push_back(cards[j]);\n          }\n          else if(sum > x && sum <= y){\n            A.push_back(P(cards[j].first,cards[j].first + (x - prev_sum - 1)));\n            B.push_back(P(cards[j].first + (x - prev_sum),\n                          cards[j].second));\n          }\n          else if(sum > y){\n            A.push_back(P(cards[j].first,cards[j].first + (x - prev_sum - 1)));\n            B.push_back(P(cards[j].first + (x - prev_sum),\n                          cards[j].first + (x - prev_sum) + (y - x - 1)));\n            C.push_back(P(cards[j].first + (x - prev_sum) + (y - x),\n                          cards[j].second));\n          }\n        }\n        else if(prev_sum >= x){\n          if(prev_sum < y){\n            if(sum <= y){\n              B.push_back(P(cards[j].first,cards[j].second));\n            }\n            else if(sum > y){\n              B.push_back(P(cards[j].first,cards[j].first + (y - prev_sum - 1)));\n              C.push_back(P(cards[j].first + (y - prev_sum),cards[j].second));\n            }\n          }\n          else if(prev_sum >= y){\n            C.push_back(P(cards[j].first,cards[j].second));\n          }\n        }\n      }\n      for(int i=0;i<C.size();i++){\n        next.push_back(C[i]);\n        // cout << \"C<f,s>=\" << C[i].first << \",\" << C[i].second << endl;\n      }\n      for(int i=0;i<B.size();i++){\n        next.push_back(B[i]);\n        // cout << \"B<f,s>=\" << B[i].first << \",\" << B[i].second << endl;\n      }\n      for(int i=0;i<A.size();i++){\n        next.push_back(A[i]);\n        // cout << \"A<f,s>=\" << A[i].first << \",\" << A[i].second << endl;\n      }\n      // cout << endl;\n      cards = next;\n    }\n\n    int offset = 0;\n    int res = 0;\n    for(int i=0;i<cards.size();i++){\n      int current = cards[i].second - cards[i].first + 1;\n      if(offset + current < first) continue;\n      if(offset > last) continue;\n\n      int lhs = 0;\n      int rhs = 1000000000;\n\n      for(int round = 0; round < 50; round++){\n        int mid = (lhs + rhs) / 2;\n        if(cards[i].first + mid > upper){\n          rhs = mid;\n        }\n        if(cards[i].first + mid <= upper){\n          lhs = mid;\n        }\n      }\n\n      lhs = min(lhs + 1,cards[i].second - cards[i].first + 1);\n      if(offset + lhs > last){\n        lhs = last - offset - 1;\n      }\n      res += lhs;\n\n      // cout << \"offset \" << offset << endl;\n      // cout << \"<f,s>=\" << cards[i].first << \",\" << cards[i].second << endl;\n      // cout << \"lhs=\" << lhs << endl;\n\n      offset += current;\n    }\n    printf(\"%d\\n\",res);\n\n  }\n}"
  },
  {
    "language": "C++",
    "code": "#include <iostream>\n#include <cstdio>\n#include <cstring>\n#include <cstdlib>\n#include <cmath>\n#include <vector>\n#include <string>\n#include <map>\n#include <set>\n#include <queue>\n#include <stack>\n#include <algorithm>\n\nusing namespace std;\n\n#define rep(i,j) REP((i), 0, (j))\n#define REP(i,j,k) for(int i=(j);(i)<(k);++i)\n#define BW(a,x,b) ((a)<=(x)&&(x)<=(b))\n#define ALL(v) (v).begin(), (v).end()\n#define LENGTHOF(x) (sizeof(x) / sizeof(*(x)))\n#define AFILL(a, b) fill((int*)a, (int*)(a + LENGTHOF(a)), b)\n#define SQ(x) ((x)*(x))\n#define Mod(x, mod) (((x)+(mod)%(mod))\n#define MP make_pair\n#define PB push_back\n#define F first\n#define S second\n#define INF 1 << 30\n#define EPS 1e-10\n#define MOD 1000000007\n\ntypedef pair<int, int> pi;\ntypedef pair<int, pi> pii;\ntypedef vector<int> vi;\ntypedef queue<int> qi;\ntypedef long long ll;\n\nvector<pi>vec, a, b, c;\nint N, M, P, Q, R;\n\nint cnt(int p, int q, int r){\n  if(p > r) return 0;\n  if(r >= q) return q-p+1;\n  return r-p+1;\n}\n\nint countR(int p, int q, int r){\n  int n = 1, vp, res = 0;\n  for(vp=0;vp<vec.size();vp++){\n    if(n <= p){\n      if(n + vec[vp].S - vec[vp].F + 1 < p){\n\tn += vec[vp].S - vec[vp].F + 1;\n\tcontinue;\n      }\n      if(n + vec[vp].S - vec[vp].F + 1 > q){\n\tres += cnt(vec[vp].F+p-n, vec[vp].F+q-n, r);\n      }else{\n\tres += cnt(vec[vp].F+p-n, vec[vp].S, r);\n      }\n      n += vec[vp].S - vec[vp].F + 1;      \n    }else if(n <= q){\n      if(n+vec[vp].S-vec[vp].F+1<q){\n\tres += cnt(vec[vp].F, vec[vp].F, r);\n      }else{\n\tres += cnt(vec[vp].F, vec[vp].F+q-n, r);\n      }\n      n += vec[vp].S-vec[vp].F+1;\n    }\n  }\n  return res;\n}\n\nint main(){\n  while(1){\n    cin >> N;\n    if(!N) break;\n    cin >> M >> P >> Q >> R;\n    vec.clear();\n    vec.PB(MP(1,N));\n    int x, y;\n    rep(i, M){\n      cin >> x >> y;\n      a.clear(); b.clear();// c.clear();\n      int p=1;\n      while(p<=x){\n\tint f = vec[0].F, s = vec[0].S;\n\tif(p+s-f<=x){\n\t  a.PB(MP(f,s));\n\t  p += s-f+1;\n\t  vec.erase(vec.begin());\n\t}else if(p+s-f>x){\n\t  a.PB(MP(f, f+x-p));\n\t  vec[0].F = f+x-p+1;\n\t  p = x+1;\n\t}\n      }\n      while(p<=y){\n\tint f = vec[0].F, s = vec[0].S;\n\tif(p+s-f<=y){\n\t  b.PB(MP(f, s));\n\t  p += s-f+1;\n\t  vec.erase(vec.begin());\n\t}else if(p+s-f>y){\n\t  b.PB(MP(f, f+y-p));\n\t  vec[0].F = f+y-p+1;\n\t  p = y+1;\n\t}\n      }\n\n      vec.insert(vec.end(), b.begin(), b.end());\n      vec.insert(vec.end(), a.begin(), a.end());\n      //      rep(i, vec.size()) cout << vec[i].F << \" \" <<vec[i].S << endl;\n    }\n\n    cout << countR(P, Q, R) << endl;\n  }\n  return 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include <tuple>\n#include <vector>\n#include <iostream>\n#include <algorithm>\n\n#pragma warning(disable : 4996)\n\nusing namespace std;\n\nint n, m, p, q, c, r1, r2;\n\nvector<tuple<int, int, int> > dat;\n\ninline void divide(int pos)\n{\n\tvector<tuple<int, int, int> > dat1;\n\n\tint u = dat.size();\n\n\tfor (int i = 0; i < u; i++)\n\t{\n\t\tint l = get<0>(dat[i]);\n\t\tint r = get<1>(dat[i]);\n\t\tint t = get<2>(dat[i]);\n\n\t\tif (l < pos && pos < r)\n\t\t{\n\t\t\tdat[i] = make_tuple(l, pos, t);\n\n\t\t\tdat.insert(dat.begin() + i + 1, make_tuple(pos, r, t + pos - l));\n\t\t}\n\t}\n}\n\ninline void shuffle(int a, int b)\n{\n\tdivide(a);\n\tdivide(b);\n\n\tint l = lower_bound(dat.begin(), dat.end(), make_tuple(a, 0, 0)) - dat.begin();\n\tint r = lower_bound(dat.begin(), dat.end(), make_tuple(b, 0, 0)) - dat.begin();\n\tint u = dat.size();\n\n\tvector<tuple<int, int, int> > dat1;\n\n\tint pos = 0;\n\n\tfor (int i = r; i < u; i++)\n\t{\n\t\tdat1.push_back(make_tuple(pos, pos - get<0>(dat[i]) + get<1>(dat[i]), get<2>(dat[i]))); pos += get<1>(dat[i]) - get<0>(dat[i]);\n\t}\n\n\tfor (int i = l; i < r; i++)\n\t{\n\t\tdat1.push_back(make_tuple(pos, pos - get<0>(dat[i]) + get<1>(dat[i]), get<2>(dat[i]))); pos += get<1>(dat[i]) - get<0>(dat[i]);\n\t}\n\n\tfor (int i = 0; i < l; i++)\n\t{\n\t\tdat1.push_back(make_tuple(pos, pos - get<0>(dat[i]) + get<1>(dat[i]), get<2>(dat[i]))); pos += get<1>(dat[i]) - get<0>(dat[i]);\n\t}\n\n\tdat = dat1;\n}\n\nint main()\n{\n\twhile(true)\n\t{\n\t\tscanf(\"%d\", &n);\n\t\t\n\t\tif (n == 0) { break; }\n\n\t\tscanf(\"%d\", &m);\n\t\tscanf(\"%d\", &p); p--;\n\t\tscanf(\"%d\", &q); q--;\n\t\tscanf(\"%d\", &c);\n\n\t\tdat = { make_tuple(0, n, 1) };\n\n\t\tfor (int i = 0; i < m; i++)\n\t\t{\n\t\t\tscanf(\"%d\", &r1);\n\t\t\tscanf(\"%d\", &r2);\n\n\t\t\tshuffle(r1, r2);\n\t\t}\n\n\t\tint ret = 0;\n\n\t\tfor (int i = 0; i < dat.size(); i++)\n\t\t{\n\t\t\tint l = get<0>(dat[i]);\n\t\t\tint r = get<1>(dat[i]);\n\t\t\tint t = get<2>(dat[i]);\n\n\t\t\tif (p <= l && r <= q + 1)\n\t\t\t{\n\t\t\t\tret += min(max(c - t + 1, 0), r - l);\n\t\t\t}\n\t\t\telse if (p <= l && l <= q)\n\t\t\t{\n\t\t\t\tret += min(max(c - t + 1, 0), q - l + 1);\n\t\t\t}\n\t\t\telse if (p <= r && r <= q)\n\t\t\t{\n\t\t\t\tret += max(c - (t + (p - l)) + 1, 0);\n\t\t\t}\n\t\t}\n\n\t\tprintf(\"%d\\n\", ret);\n\t}\n\n\treturn 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include <iostream>\n#include <vector>\n#include <algorithm>\nusing namespace std;\n#define rep(i,n) for(int i=0;i<n;i++)\nvector< pair<int,int> > card;\n\nint n,m;\nint divide(int x,int y){\n\tvector< pair<int,int> > a,b,c;\n\tfor(int i=0;i<=x;i++) a.push_back(card[i]);\n\tfor(int i=x+1;i<=y;i++) b.push_back(card[i]);\n\tfor(int i=y+1;i<card.size();i++) c.push_back(card[i]);\n\tc.insert(c.end(),b.begin(),b.end());\n\tc.insert(c.end(),a.begin(),a.end());\n\tcard = c;\n}\nint suffle(int x,int y,int r){\n\tint t[3] = {x , y-x, n-y}; \n\tint W[3];\n\tint i = 0;\n\trep(s,3){\n\t\tint a = t[s];\n\t\twhile(1){\n\t\t\tint t = card[i].second - card[i].first+1;\n\t\t\ta -= t;\n\t\t\tW[s] = i;\n\t\t\tif(a == 0)break;\n\t\t\tif(a<0){\n\t\t\t\tpair<int,int> np1,np2;\n\t\t\t\tnp1 = make_pair(card[i].first,card[i].second+a);\n\t\t\t\tnp2 = make_pair(card[i].second+a+1,card[i].second);\n\t\t\t\tcard[i] = np1;\n\t\t\t\tcard.insert(card.begin() + i + 1 , np2);\n\t\t\t\tbreak;\n\t\t\t}\n\t\t\ti++;\n\t\t}\n\t\ti = i+1;\n\t}\n\tif(r)divide(W[0],W[1]);\n}\nint main(){\n\twhile(cin >> n >> m , n){\n\t\tcard.clear();\n\t\tcard.push_back(make_pair(1,n));\n\t\tint p,q,r;\n\t\tcin >> p >> q >> r;\n\t\trep(i,m){\n\t\t\tint x,y;\n\t\t\tcin >> x >> y;\n\t\t\tsuffle(x,y,1);\n\t\t}\n\t\tsuffle(p,q,0);\n\t\tint c = 1 , ans = 0;\n\t\t\n\t\trep(i,card.size()){\n\t\t\tif(c > q) break;\n\t\t\tif(c >= p){\n\t\t\t\tif( r >= card[i].second){\n\t\t\t\t\tans += card[i].second-card[i].first+1;\n\t\t\t\t}else if(r >= card[i].first){\n\t\t\t\t\tans += r-card[i].first+1;\n\t\t\t\t}\n\t\t\t}\n\t\t\tc += card[i].second - card[i].first + 1;\n\t\t}\n\t\tcout << ans << endl;\n\t}\n}"
  },
  {
    "language": "C++",
    "code": "#include<bits/stdc++.h>\nusing namespace std;\n#define h first\n#define w second\nvector<pair<bool,pair<int,int> > >v;\nint n,m,p,q,r,i;\nvoid Vp(bool a,int b,int c){v.push_back(make_pair(a,make_pair(b,c)));}\nint main(){\n\twhile(cin>>n&&n){\n\tcin>>m>>p>>q>>r;v.clear();\n\tVp(1,1,r);Vp(0,r+1,n);\n\twhile(m--){\n\t\tint x,y;cin>>x>>y;\n\t\tfor(i=0;i<v.size();i++){\n\t\t\tint a=v[i].w.h,b=v[i].w.w;bool c=v[i].h;\n\t\t\tif(a<=x&&x<b){\n\t\t\t\tVp(c,x+1,b);\n\t\t\t\tb=x;\n\t\t\t}\n\t\t\tif(a<=y&&y<b){\n\t\t\t\tVp(c,y+1,b);\n\t\t\t\tb=y;\n\t\t\t}\n\t\t\tif(0<a&&b<=x)a+=n-x,b+=n-x;\n\t\t\telse if(x<a&&b<=y)a+=n-x-y,b+=n-x-y;\n\t\t\telse if(y<a&&b<=n)a-=y,b-=y;\n\t\t\tv[i].w.h=a,v[i].w.w=b;\n\t\t}\n\t}\n\tint ans=0;\n\tfor(i=0;i<v.size();i++){\n\t\tif(v[i].h)ans+=max(0,1+min(v[i].w.w,q)-max(v[i].w.h,p));\n\t}\n\tcout<<ans<<endl;\n\t}\n\treturn 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include<iostream>\n#include<queue>\nusing namespace std;\nint main(){\n\tint m,n,p,q,r,x,y,ans=0;\n\tdeque<int> a,c;\n\tcin>>n;\n\tcin>>m;\n\tcin>>p>>q>>r;\n\tfor(int i=1;i<=n;i++)\n\t\ta.push_back(i);\n\tfor(int i=0;i<m;i++){\n\t\tcin>>x>>y;\n\t\tfor(int j=0;j<n-y;j++){\n\t\t\tc.push_back(a.back());\n\t\t\ta.pop_back();\n\t\t}\n\t\tfor(int j=0;j<y-x;j++){\n\t\t\ta.push_front(a.back());\n\t\t\ta.pop_back();\n\t\t}\n\t\tfor(int j=0;j<n-y;j++){\n\t\t\ta.push_front(c.front());\n\t\t\tc.pop_front();\n\t\t}\n\t}\n\t/*for(int i=0;i<n;i++){\n\t\tcout<<a.front()<<' ';\n\t\ta.pop_front();\n\t}cout<<endl;\n\t*/\n\tfor(int i=0;i<p-1;i++){\n\t\ta.pop_front();\n\t}\n\tfor(int j=0;j<q-p+1;j++){\n\t\tif(a.front()<=r)\n\t\tans++;\n\t\ta.pop_front();\n\t}\n\tcout<<ans<<endl;\n\treturn 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include <iostream>\n#include <algorithm>\n#include <string>\n#include <vector>\nusing namespace std;\n\nint N, M, P, Q, R;\n\nint sign(int x) {\n  if (x >= 0) return 1;\n  else        return -1;\n}\n\nvoid div(vector<int> &s, int x, int y, vector<int> &a, vector<int> &b, vector<int> &c) {\n  int i = 0, h = 0;\n  for (; i<s.size(); i++) {\n    h += abs(s[i]);\n    if (h >= x) {\n      int fa = x - (h-abs(s[i])),\n          fb = h - x;\n      if (fa > 0) a.push_back(sign(s[i]) * fa);\n      if (fb > 0) b.push_back(sign(s[i]) * fb);\n      break;\n    }\n    a.push_back(s[i]);\n  }\n  for (i++; i<s.size(); i++) {\n    h += abs(s[i]);\n    if (h >= y) {\n      int fa = y - (h-abs(s[i])),\n          fb = h - y;\n      if (fa > 0) b.push_back(sign(s[i]) * fa);\n      if (fb > 0) c.push_back(sign(s[i]) * fb);\n      break;\n    }\n    b.push_back(s[i]);\n  }\n  for (i++; i<s.size(); i++) {\n    c.push_back(s[i]);\n  }\n}\n\nint main() {\n  while (cin >> N) {\n    if (N == 0) break;\n    cin >> M >> P >> Q >> R;\n\n    vector<int> s;\n    s.push_back(R), s.push_back(R-N);\n\n    for (int k=0; k<M; k++) {\n      int x, y;\n      cin >> x >> y;\n      vector<int> a, b, c;\n      div(s, x, y, a, b, c);\n      s.clear();\n      s.insert(s.end(), c.begin(), c.end());\n      s.insert(s.end(), b.begin(), b.end());\n      s.insert(s.end(), a.begin(), a.end());\n    }\n\n    vector<int> a, b, c;\n    div(s, P-1, Q, a, b, c);\n    int ans = 0;\n    for (auto x : b) ans += max(x, 0);\n    cout << ans << \"\\n\";\n  }\n  return 0;\n}"
  },
  {
    "language": "C++",
    "code": "//#include <cstdio>\n//#include <vector>\n//#include <map>\n//using namespace std;\n//typedef pair<int, int> P;\n//typedef vector<P> vi;\n//#define f first\n//#define s second\n//#define pb push_back\n//#define sz(x) x.size()\n//void shuffle(int x, int y, vi &c) {\n//    int cnt=0, i;\n//    int sz=sz(c);\n//    vi temp1, temp2, temp3;\n//    for (i=0; i<sz; i++) {\n//        int s=c[i].f, e=c[i].s;\n//        if (cnt+e-s+1>=x) {\n//            temp1.pb(P(s,s+x-cnt-1));\n//            break;\n//        }\n//        temp1.pb(c[i]); \n//        cnt+=e-s+1;\n//    }\n//    if (cnt+c[i].s-c[i].f+1>=y) {\n//        temp2.pb(P(c[i].f+x-cnt,c[i].f+y-cnt-1));\n//        temp3.pb(P(c[i].f+y-cnt,c[i].s));\n//        for (i+=1;i<sz; i++) temp3.pb(c[i]);\n//    } else {\n//        temp2.pb(P(c[i].f+x-cnt,c[i].s));\n//        cnt+=c[i].s-c[i].f+1;\n//        int a=++i;\n//        for (;i<sz; i++) {\n//            int s=c[i].f, e=c[i].s;\n//            if (cnt+e-s+1>=y) {\n//                temp2.pb(P(s,s+y-cnt-1));\n//                break;\n//            }\n//            temp2.pb(c[i]);\n//            cnt+=e-s+1;\n//        }\n//        if (cnt+c[i].s-c[i].f+1!=y) temp3.pb(P(c[i].f+y-cnt,c[i].s));\n//        for (i+=1; i<sz; i++) temp3.pb(c[i]);\n//    }\n///*\n//    for (i=0; i<sz(temp1); i++) printf(\"%d %d\\n\",temp1[i].f,temp1[i].s);\n//    puts(\"\");\n//    for (i=0; i<sz(temp2); i++) printf(\"%d %d\\n\",temp2[i].f,temp2[i].s);\n//    puts(\"\");\n//    for (i=0; i<sz(temp3); i++) printf(\"%d %d\\n\",temp3[i].f,temp3[i].s);\n//    puts(\"\");\n//*/\n//    for (i=0; i<sz(temp3); i++) c.pb(temp3[i]);\n//    for (i=0; i<sz(temp2); i++) c.pb(temp2[i]);\n//    for (i=0; i<sz(temp1); i++) c.pb(temp1[i]);\n//    temp1.clear(); temp2.clear(); temp3.clear();\n//}\n\n//int main() {\n//    int n, m, p, q, r;\n//    while (scanf(\"%d\",&n)) {\n//        if (!n) break;\n//        scanf(\"%d%d%d%d\",&m,&p,&q,&r);\n//        vi c(1,P(1,n));\n//        for (int i=0; i<m; i++) {\n//            int x, y; scanf(\"%d%d\",&x,&y);\n//            shuffle(x,y,c);\n//        }\n//        int cnt=0, res=0;\n//        for (int i=0; i<sz(c); i++) {\n//            int s=c[i].f, e=c[i].s;\n////            printf(\"%d %d\\n\",s,e);\n//            if (cnt+e-s+1>=p&&q>=cnt) {\n//                int m=max(s+p-cnt-1,s), M=min(s+q-cnt-1,e);\n////                printf(\"%d %d\\n\",m,M);\n//                if (r>=m&&r<=M) res+=r-m+1;\n//                else if (r>=M) res+=M-m+1;\n//            }\n//            cnt+=e-s+1;\n//        }\n//        printf(\"%d\\n\",res);\n//    }\n//}\n#include <iostream>\n#include <deque>\nusing namespace std;\n\nclass Card{\npublic:\n  int f,t;\n\n  Card(int from,int to){\n    f = from;\n    t = to;\n  }\n};\n\nint n,m,p,q,r;\ndeque<Card> d; //J[hÌR\n\n//RÌ1Ú©çxÚÜÅðæèoµÄßèlÆµÄÔ·\ndeque<Card> removeCard(int x){\n  deque<Card> res;\n\n  while(1){\n    Card tmp = d.front(); d.pop_front();\n    x -= tmp.t - tmp.f + 1;\n\n    if(x <= 0){\n      if(x != 0){\n        d.push_front(Card(tmp.t + x + 1, tmp.t));\n        tmp.t += x;\n      }\n      res.push_back(tmp);\n      break;\n    }\n    res.push_back(tmp);\n  }\n  return res;\n}\n\n//VbtpÖ\nvoid shuffle(int x,int y){\n  deque<Card> A = removeCard(x);\n  deque<Card> B = removeCard(y-x);\n  for(int i=0;i<B.size();i++) d.push_back(B[i]);\n  for(int i=0;i<A.size();i++) d.push_back(A[i]);\n}\n\nint main(void){\n  while(cin>>n,n){\n    cin>>m>>p>>q>>r;\n    d.clear();\n    d.push_back(Card(1,n));\n\n    while(m--){\n      int x,y;\n      cin>>x>>y;\n      shuffle(x,y);\n    }\n\n    int ans = 0;\n    removeCard(p-1); //ãÌ(p-1)ðæèoµÄ¨­\n    deque<Card> rem = removeCard(q-p+1); //(p-q+1)æèo¹Î, pÚ©çqÚðæèoµ½±ÆÉÈé\n    for(int i=0;i<rem.size();i++){\n      if(rem[i].f <= r){\n        ans += r - rem[i].f - (rem[i].t < r ? r-rem[i].t : 0) + 1;\n      }\n    }\n    cout<<ans<<endl;\n  }\n\n  return 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include <cstdlib>\n#include <iostream>\n#include <vector>\nusing namespace std;\n\nint main() {\n\tcin.tie(0);\n\tios::sync_with_stdio(false);\n\n\tfor(int n; cin >> n, n;) {\n\t\tint m;\n\t\tcin >> m;\n\n\t\tint p, q, r;\n\t\tcin >> p >> q >> r;\n\n\t\tvector<int> cards;\n\t\tcards.reserve(n);\n\t\tfor(int i = 1; i <= n; ++i)\n\t\t\tcards.push_back(i);\n\n\t\tfor(int i = 0; i < m; ++i) {\n\t\t\tint x, y;\n\t\t\tcin >> x >> y;\n\n\t\t\tint idx = 0;\n\t\t\tvector<int> tmp(cards);\n\n\t\t\tfor(int j = y; j < n; ++j)\n\t\t\t\tcards[idx++] = tmp[j];\n\n\t\t\tfor(int j = x; j < y; ++j)\n\t\t\t\tcards[idx++] = tmp[j];\n\n\t\t\tfor(int j = 0; j < x; ++j)\n\t\t\t\tcards[idx++] = tmp[j];\n\t\t}\n\n\t\tint ans = 0;\n\t\tfor(int i = p - 1; i < q; ++i)\n\t\t\tif(cards[i] <= r)\n\t\t\t\t++ans;\n\n\t\tcout << ans << endl;\n\t}\n\n\treturn EXIT_SUCCESS;\n}"
  },
  {
    "language": "C++",
    "code": "#include <iostream>\n#include <algorithm>\n#include <vector>\nusing namespace std;\nint main(){\n\tint n,m,p,q,r,x,y,t;\n\tvector<int>::iterator itx,ity,it;\n\tfor(;cin>>n>>m>>p>>q>>r;cout<<x<<endl){\n\t\tvector<int> v1,v2;\n\t\tv1.push_back(0);\n\t\tv1.push_back(r);\n\t\t\n\t\tfor(;m--;v2.clear()){\n\t\t\tcin>>x>>y;\n\t\t\titx=upper_bound(v1.begin(),v1.end(),x);\n\t\t\tity=upper_bound(v1.begin(),v1.end(),y);\n\t\t\t\n\t\t\tif( ity-v1.begin() & 1 )v2.push_back(0);\n\t\t\tfor(it=ity;it!=v1.end();++it)\n\t\t\t\tv2.push_back(*it - y);\n\t\t\t\n\t\t\tif(v1.end()-itx & 1)v2.push_back(n-y);\n\t\t\tfor(it=itx;it!=ity;++it)\n\t\t\t\tv2.push_back(*it-x+n-y);\n\t\t\t\n\t\t\tit = v1.begin();\n\t\t\tif(ity-v1.begin() & 1)++it;\n\t\t\tfor(;it!=itx;++it)\n\t\t\t\tv2.push_back(*it+n-x);\n\t\t\t\n\t\t\tv1.swap(v2);\n\t\t}\n\t\tv1.insert( upper_bound(v1.begin(),v1.end(),p-1), 2, p-1);\n\t\tv1.insert( lower_bound(v1.begin(),v1.end(),q), q );\n\t\tv1.push_back(n);\n\t\tit = upper_bound(v1.begin(),v1.end(),p-1);\n\t\tif(it-v1.begin() & 1) --it;\n\t\tfor(x=0;*it<q;++it){\n\t\t\tm=*it;\n\t\t\t++it;\n\t\t\tx+=*it-m;\n\t\t}\n\t}\n}"
  },
  {
    "language": "C++",
    "code": "#include<bits/stdc++.h>\n\nusing namespace std;\n\nint N, M;\n\nvector<pair<int, int> > Divide(vector<pair<int, int> > all, pair<int, int> part)\n{\n    vector<pair<int, int> > div;\n    int l = 0, r = 0;\n    for (int i = 0; i < all.size(); i++)\n    {\n        l = r;\n        r += all[i].second - all[i].first;\n        if (part.second <= l || r <= part.first) continue;\n        int dl = all[i].first + max(l, part.first) - l;\n        int dr = all[i].first + min(r, part.second) - l;\n        div.push_back(make_pair(dl, dr));\n    }\n    return div;\n}\n\nint main()\n{\n    while (cin >> N, N)\n    {\n        int P, Q, R;\n        cin >> M >> P >> Q >> R;\n        P--;\n        Q--;\n        int x[5000], y[5000];\n        vector<pair<int, int> > latte;\n        latte.push_back(make_pair(0, N));\n        for (int i = 0; i < M; i++)\n        {\n            cin >> x[i] >> y[i];\n            x[i]--;\n            y[i]--;\n            vector<pair<int, int> > A = Divide(latte, make_pair(0, x[i] + 1));\n            vector<pair<int, int> > B = Divide(latte, make_pair(x[i] + 1, y[i] + 1));\n            vector<pair<int, int> > C = Divide(latte, make_pair(y[i] + 1, N));\n            latte = C;\n            latte.insert(latte.end(), B.begin(), B.end());\n            latte.insert(latte.end(), A.begin(), A.end());\n        }\n        vector<pair<int, int> > last = Divide(latte, make_pair(P, Q + 1));\n        int ans = 0;\n        for (int i = 0; i < last.size(); i++)\n        {\n            ans += max(0, min(R, last[i].second) - last[i].first);\n        }\n        printf(\"%d\\n\", ans);\n    }\n    return 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include<iostream>\n#include<list>\n\nusing namespace std;\n\ntypedef pair<int,int> range;\ntypedef list< range > deck;\n\ninline int quant(const range &r){\n  return r.second-r.first+1;\n}\n\nint shuffle(int x, int y, deck &D, bool count = false, int r = 0){\n  deck d1,d2,d3;\n\n  // part I\n  int precnt = 0, cnt = 0;\n  for(deck::iterator itd = D.begin(); itd != D.end(); ++itd){\n    cnt += quant( *itd );\n    if( cnt >= x ){\n      d1.push_back( range( itd->first, itd->first + (x-precnt) - 1 ) );\n      break;\n    }else{\n      d1.push_back( *itd );\n    }\n    precnt = cnt;\n  }\n  \n  // part II\n  precnt = cnt = 0;\n  bool first=true;\n  for(deck::iterator itd = D.begin(); itd != D.end(); ++itd){\n    cnt += quant( *itd );\n    if( precnt <= x && precnt <= y && cnt > x && cnt > y ){\n      d2.push_back( range( itd->first + (x-precnt), itd->first + (y-precnt) - 1 )  );\n      // cout << \"A : \" << d2.back().first << ' ' << d2.back().second << endl;\n      break;\n    }else if( cnt >= x && first ){\n      d2.push_back( range( itd->first + (x-precnt), itd->second ) );\n      // cout << \"B : \" << d2.back().first << ' ' << d2.back().second << endl;\n      first = false;\n    }else if( cnt >= x && cnt < y  ){\n      d2.push_back( *itd );\n      // cout << \"C : \" << d2.back().first << ' ' << d2.back().second << endl;\n    }else if( cnt >= y ){\n      d2.push_back( range( itd->first, itd->first + (y-precnt) - 1 ) );\n      // cout << \"D : \" << d2.back().first << ' ' << d2.back().second << endl;\n      break;\n    }\n    precnt = cnt;\n  }\n  \n  // part III\n  precnt = cnt = 0;\n  first=true;\n  for(deck::iterator itd = D.begin(); itd != D.end(); ++itd){\n    cnt += quant( *itd );\n    if( cnt > y && first ){\n      d3.push_back( range( itd->first + (y-precnt), itd->second ) );\n      first=false;\n    }else if( !first ){\n      d3.push_back( *itd );\n    }\n    precnt = cnt;\n  }\n\n  D.clear();\n/*\n  cout << \"D1\" << endl;\n  for(deck::iterator itd=d1.begin();itd!=d1.end();++itd){\n    cout << '(' << itd->first << \" - \" << itd->second << ')' << endl;\n  }cout << \"D2\" << endl;\n  for(deck::iterator itd=d2.begin();itd!=d2.end();++itd){\n    cout << '(' << itd->first << \" - \" << itd->second << ')' << endl;\n  }cout << \"D3\" << endl;\n  for(deck::iterator itd=d3.begin();itd!=d3.end();++itd){\n    cout << '(' << itd->first << \" - \" << itd->second << ')' << endl;\n  }\n  cout << endl;\n*/\n\n  if( count ){\n    int ret = 0;\n    if(d1.back().second <= r ) ++ret;\n    for(deck::iterator itd=d2.begin(); itd!=d2.end(); ++itd){\n      //cout << itd->first << ' ' << itd->second << endl;\n      if( itd->first <= r ){\n\tret += ( min(itd->second,r) - itd->first + 1);\n      }\n    }\n    return ret;\n  }\n  \n  D.insert( D.begin(), d1.begin(), d1.end() );\n  D.insert( D.begin(), d2.begin(), d2.end() );\n  D.insert( D.begin(), d3.begin(), d3.end() );\n  \n  return 0;\n}\n\nint main()\n{\n  while(true){\n    int n,m,p,q,r;\n    deck D;\n    cin >> n;\n    if( n == 0 ) break;\n    cin >> m >> p >> q >> r;\n    D.push_back( range(1,n) );\n    for(int i = 0; i < m; ++i){\n      int x,y;\n      cin >> x >> y;\n      shuffle( x, y, D );\n    }\n    cout << shuffle( p, q, D, true, r ) << endl;\n    \n  }\n  return 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include <cstdio>\n#include <cstdlib>\n#include <cstring>\n#include <cmath>\n#include <climits>\n#include <iostream>\n#include <vector>\n#include <string>\n#include <sstream>\n#include <algorithm>\n#include <utility>\n#include <set>\n#include <map>\n#include <stack>\n#include <queue>\n#include <deque>\n#include <functional>\n\nusing namespace std;\n\n#define fst first\n#define scd second\n#define PB push_back\n#define MP make_pair\n#define all(a) a.begin(),a.end()\n#define rall(a) a.rbegin(),a.rend()\n#define omajinai ios::sync_with_stdio(false);cin.tie(0)\n#define rep(i,x) for(int i=0;i<(int)(x);++i)\n#define rep1(i,x) for(int i=1;i<=(int)(x);++i)\n\nusing ll=long long;\nusing ld=long double;\nusing vi=vector<int>;\nusing vvi=vector<vi>;\nusing pii=pair<int, int>;\nusing vpii=vector<pii>;\n\ntemplate<class T,class U>ostream&operator<<(ostream&os,const pair<T,U>p){os<<\"(\"<<p.fst<<\", \"<<p.scd<<\")\";return os;}\ntemplate<class T>ostream&operator<<(ostream&os,const vector<T>v){rep(i,v.size()){if(i)os<<\", \";os<<v[i];}return os;}\ntemplate<typename T>T&max(T&a,T&b){if(a>=b)return a;return b;}\ntemplate<typename T>T&min(T&a,T&b){if(a < b)return a;return b;}\ntemplate<typename T>bool chmax(T&a,T b){if(a < b){a=b;return true;}return false;}\ntemplate<typename T>bool chmin(T&a,T b){if(a > b){a=b;return true;}return false;}\n\nconstexpr int inf = 1e9;\nconstexpr ll linf = 3e18;\nconstexpr double eps = 1e-9;\n\nint n, m, p, q, r;\n\nint calc(pii seg, int n) // n=seg.fst????????????????????????\n{\n    int len = seg.scd - seg.fst + 1; // seg?????????\n\n    if (n < p && p <= n + len - 1) {\n        int a = (n + len - 1) - p;\n\n        return calc(pii(seg.scd - a, seg.scd), p);\n    }\n\n    if (p <= n && n + len - 1 <= q) {\n        return max(min(r - seg.fst + 1, len), 0);\n    }\n\n    if (n <= q && q < n + len - 1) {\n        int a = q - n;\n\n        return calc(pii(seg.fst, seg.fst + a), n);\n    }\n\n    return 0;\n}\n\nint main()\n{\n    while (cin >> n >> m >> p >> q >> r, n) {\n        deque<pii> dat;\n\n        dat.push_back(pii(1, n));\n\n        rep(_, m) {\n            int x, y; cin >> x >> y;\n\n            int sum = 0;\n\n            vpii Top, Mid, Bottom;\n\n            // Top?????????\n            while (true) {\n                pii a = dat.front();\n\n                int v = a.scd - a.fst + 1;\n\n                if (sum + v >= x) {\n                    int dif = x - sum-1;\n\n                    sum += dif + 1;\n\n                    Top.push_back(pii(a.fst, a.fst + dif));\n\n                    dat.pop_front();\n\n                    if (a.fst + dif + 1 <= a.scd) dat.push_front(pii(a.fst + dif + 1, a.scd));\n\n                    break;\n                } else {\n                    Top.PB(a);\n                    sum += v;\n                }\n\n                dat.pop_front();\n            }\n\n            // Mid?????????\n            while (true) {\n                pii a = dat.front();\n\n                int v = a.scd - a.fst + 1;\n\n                if (sum + v >= y) {\n                    int dif = y - sum-1;\n\n                    sum += dif + 1;\n\n                    Mid.push_back(pii(a.fst, a.fst + dif));\n\n                    dat.pop_front();\n\n                    if (a.fst + dif + 1 <= a.scd) dat.push_front(pii(a.fst + dif + 1, a.scd));\n\n                    break;\n                } else {\n                    Mid.PB(a);\n                    sum += v;\n                }\n                dat.pop_front();\n            }\n\n            // Bottom?????????\n            while (true) {\n                pii a = dat.front();\n\n                int v = a.scd - a.fst + 1;\n\n                if (sum + v == n) {\n                    sum += v;\n\n                    Bottom.push_back(pii(a.fst, a.scd));\n\n                    dat.pop_front();\n\n                    break;\n                } else {\n                    Bottom.PB(a);\n                    sum += v;\n                }\n\n                dat.pop_front();\n            }\n\n            rep(i, Bottom.size()) dat.push_back(Bottom[i]);\n            rep(i, Mid.size()) dat.push_back(Mid[i]);\n            rep(i, Top.size()) dat.push_back(Top[i]);\n        }\n\n        int sum = 1;\n        int ans = 0;\n\n        for (pii a : dat) {\n            ans += calc(a, sum);\n            sum += a.scd - a.fst + 1;\n        }\n\n        cout << ans << endl;\n    }\n}"
  },
  {
    "language": "C++",
    "code": "#include <vector>\n#include <algorithm>\n#include <set>\n#include <map>\n#include <queue>\n#include <stack>\n#include <iostream>\n#include <cstdio>\n#include <cmath>\n#include <cstring>\nusing namespace std;\ntypedef long long ll;\ntypedef pair<ll,ll> P;\ntypedef double db;\nstruct T{\n\tll st;\n\tll en;\n\tbool b;\n\tbool operator<(const T& another)const{\n\t\tif(st==another.st) return en<another.en;\n\t\treturn st<another.st;\n\t}\n};\nvector<T> cards[2];\nll n,m,p,q,r;\nll x,y;\n\nconst ll INF=0xffffffffff;\nll B=1;\nvoid printv(){\n\tfor(ll i=0;i<cards[!B].size();i++){\n\t\tcout<<\"cards[\"<<i+1<<\"]={\";\n\t\tprintf(\"%lld,%lld,\",cards[!B][i].st+1,cards[!B][i].en+1);\n\t\tcout<<cards[!B][i].b<<\"}\"<<endl;\n\t}\n\tcout<<endl;\n}\nll ans;\nll kosu,px,py;\nint main()\n{\n\twhile(1){\n\tB=1;\n\tscanf(\"%lld\",&n);\n\tif(!n) return 0;\n\tscanf(\"%lld%lld%lld%lld\",&m,&p,&q,&r);\n\tp--;\n\tq--;\n\tcards[0].clear();\n\tcards[0].push_back((T){0,r-1,1});\n\tcards[0].push_back((T){r,n-1,0});\n\tfor(ll i=0;i<m;i++){\n\t\t//printv();\n\t\tcards[B].clear();\n\t\tscanf(\"%lld%lld\",&x,&y);\n\t\tx--;\n\t\ty--;\n\t\tkosu=0;\n\t\tpx=upper_bound(cards[!B].begin(),cards[!B].end(),(T){x,INF,INF})-cards[!B].begin()-1;\n\t\tpy=upper_bound(cards[!B].begin(),cards[!B].end(),(T){y,INF,INF})-cards[!B].begin()-1;\n\t\tif(cards[!B][py].en>y){\n\t\t\tcards[B].push_back((T){0,cards[!B][py].en-y-1,cards[!B][py].b});\n\t\t\tkosu+=cards[!B][py].en-y;\n\t\t}\n\t\tfor(ll i=py+1;i<cards[!B].size();i++){\n\t\t\tcards[B].push_back((T){kosu,kosu+cards[!B][i].en-cards[!B][i].st,cards[!B][i].b});\n\t\t\tkosu+=cards[!B][i].en-cards[!B][i].st+1;\n\t\t}\n\t\tif(px!=py){\n\t\t\tif(cards[!B][px].en>x){\n\t\t\t\tcards[B].push_back((T){kosu,kosu+cards[!B][px].en-x-1,cards[!B][px].b});\n\t\t\t\tkosu+=cards[!B][px].en-x;\n\t\t\t}\n\t\t\tfor(ll i=px+1;i<py;i++){\n\t\t\t\tcards[B].push_back((T){kosu,kosu+cards[!B][i].en-cards[!B][i].st,cards[!B][i].b});\n\t\t\t\tkosu+=cards[!B][i].en-cards[!B][i].st+1;\n\t\t\t}\n\t\t\tcards[B].push_back((T){kosu,kosu+y-cards[!B][py].st,cards[!B][py].b});\n\t\t\tkosu+=y-cards[!B][py].st+1;\n\t\t}\n\t\telse{\n\t\t\tcards[B].push_back((T){kosu,kosu+y-x-1,cards[!B][py].b});\n\t\t\tkosu+=y-x;\n\t\t}\n\t\tfor(ll i=0;i<px;i++){\n\t\t\tcards[B].push_back((T){kosu,kosu+cards[!B][i].en-cards[!B][i].st,cards[!B][i].b});\n\t\t\tkosu+=cards[!B][i].en-cards[!B][i].st+1;\n\t\t}\n\t\tcards[B].push_back((T){kosu,kosu+x-cards[!B][px].st,cards[!B][px].b});\n\t\tkosu+=x-cards[!B][px].st+1;\n\t\tB=!B;\n\t}\n\t//printv();\n\tans=0;\n\tfor(ll i=0;i<cards[!B].size();i++){\n\t\tif(!cards[!B][i].b) continue;\n\t\tif(q<cards[!B][i].st||cards[!B][i].en<p) continue;\n\t\tans+=min(q,cards[!B][i].en)-max(p,cards[!B][i].st)+1;\n\t}\n\tprintf(\"%lld\\n\",ans);\n}}"
  },
  {
    "language": "C++",
    "code": "#include <cstdio>\n#include <cstdlib>\n#include <iostream>\n#include <string>\n#include <cmath>\n#include <algorithm>\n#include <vector>\n#include <queue>\n#include <stack>\n#include <map>\n#include <set>\n\n\nusing namespace std;\ntypedef long long ll;\n\n#define INF 2000000000\n#define LLINF 4000000000000000000\n#define SIZE 100\n\n\nvoid calc(int n){\n    int m,x,y,p,q,r,vec_x=0,vec_x1=0,vec_y=0,vec_y1=0;\n    vector<pair<int,int> > cards;\n    \n    scanf(\"%d%d%d%d\",&m,&p,&q,&r);\n    \n    cards.push_back(make_pair(1,n));\n    \n    for(int i=0;i<m;i++){\n        vector<pair<int,int> > cards2;\n        vector<int> count;\n        \n        scanf(\"%d%d\",&x,&y);\n        \n        count.push_back(1);\n        \n        for(int j=0;j<cards.size();j++){\n            count.push_back(count[j] + cards[j].second-cards[j].first+1);\n            \n            if(count[j] <=  x  &&  x  < count[j+1]){\n                vec_x  = j;\n            }\n            if(count[j] <= x+1 && x+1 < count[j+1]){\n                vec_x1 = j;\n            }\n            if(count[j] <=  y  &&  y  < count[j+1]){\n                vec_y  = j;\n            }\n            if(count[j] <= y+1 && y+1 < count[j+1]){\n                vec_y1 = j;\n            }\n            \n        }\n        \n        /*y+1 - n*/\n        \n        cards2.push_back(make_pair(cards[vec_y1].first+(y+1-count[vec_y1]),\n                                   cards[vec_y1].second));\n        \n        for(int j=vec_y1+1;j<cards.size();j++){\n            cards2.push_back(cards[j]);\n        }\n        \n        /*x+1 - y*/\n        if(vec_x1 != vec_y){\n            cards2.push_back(make_pair(cards[vec_x1].first+(x+1-count[vec_x1]),cards[vec_x1].second));\n        \n            for(int j=vec_x1+1;j<vec_y;j++){\n                cards2.push_back(cards[j]);\n            }\n        \n            cards2.push_back(make_pair(cards[vec_y].first,cards[vec_y].first+(y-count[vec_y])));\n            \n        }else{\n            cards2.push_back(make_pair(cards[vec_x1].first+(x+1-count[vec_x1]),\n                                       cards[vec_y].first+(y-count[vec_y])));\n        }\n        \n        \n        /*1 - x*/\n        for(int j=0;j<vec_x;j++){\n            cards2.push_back(cards[j]);\n        }\n        cards2.push_back(make_pair(cards[vec_x].first,cards[vec_x].first+(x-count[vec_x])));\n        \n        cards = cards2;\n    }\n    \n    /*ans [count_a,count_b)*/\n    int count_a=1,count_b=1,ans=0;\n    for(int j=0;j<cards.size();j++){\n        count_a=count_b;\n        count_b+=cards[j].second-cards[j].first+1;\n        if(q < count_a  &&  count_b <= p) continue;\n\n        int a,b;\n        \n        //[a,b]\n        a = max(0,p-count_a);\n        b = min(count_b-count_a-1,q-count_a);\n        \n        if(b < a) continue;\n        \n        /* cards[j].first+a ~  cards[j].first+b */\n        \n        if(r < cards[j].first+a) continue;\n\n        ans += min(r-cards[j].first,b)-a+1;\n        \n    }\n    \n    printf(\"%d\\n\",ans);\n    \n    return;\n}\n\nint main(){\n    int n;\n    \n    while(1){\n        scanf(\"%d\",&n);\n        if(n==0) break;\n        calc(n);\n    }\n    \n    return 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include<iostream>\n#include<vector>\nusing namespace std;typedef pair<int,int>P;typedef vector<P>V;typedef V::iterator I;void D(V&v,int x,I&i){int c=0;for(i=v.begin();c<x;++i)c+=i->second-i->first;int&s=i[-1].second;i=v.insert(i,P(s-c+x,s));s-=c-x;}void S(V&v,int x,int y){I i,j;v.reserve(v.size()+2);D(v,x,i);D(v,y,j);V v1(j,v.end());v1.insert(v1.end(),i,j);v1.insert(v1.end(),v.begin(),i);v=v1;}int main(){int n,m,p,q,r,x,y,c;for(;cin>>n>>m>>p>>q>>r,n;){V v(1,P(0,n));for(;m--;){cin>>x>>y;S(v,x,y);}v.reserve(v.size()+2);I i,e;D(v,p-1,i);D(v,q,e);for(c=0;i!=e;++i)c+=i->second<=r?i->second-i->first:i->first<r?r-i->first:0;cout<<c<<endl;}}"
  },
  {
    "language": "C++",
    "code": "#include<bits/stdc++.h>\nusing namespace std;\nusing Int = long long;\n//INSERT ABOVE HERE\nsigned main(){\n  Int n,m,p,q,r;\n  while(cin>>n,n){\n    cin>>m>>p>>q>>r;\n    using P = pair<Int, Int>;\n    vector<P> cur;\n    cur.emplace_back(0,n);\n    for(Int i=0;i<m;i++){\n      Int x,y;\n      cin>>x>>y;\n      Int cnt=0;\n      vector<P> mid,nxt;\n      for(Int j=0;j<(Int)cur.size();j++){\n\tInt len=cur[j].second-cur[j].first;\n\tif(cnt+len<=x){\n\t  cnt+=len;\n\t  continue;\n\t}\n\tif(y<=cnt){\n\t  nxt.emplace_back(cur[j]);\n\t  cur[j]=P(-1,-1);\n\t  cnt+=len;\n\t  continue;\n\t} \n      \n\tif(cnt<=x&&y<=cnt+len){\n\t  P a(cur[j].first,cur[j].first+(x-cnt));\n\t  P b(cur[j].first+(x-cnt),cur[j].first+(y-cnt));\n\t  P c(cur[j].first+(y-cnt),cur[j].second);\n\t  mid.emplace_back(b);\n\t  nxt.emplace_back(c);\n\t  cur[j]=a;\n\t  cnt+=len;\n\t  continue;\n\t}\n\n\tif(x<=cnt&&cnt+len<=y){\n\t  mid.emplace_back(cur[j]);\n\t  cur[j]=P(-1,-1);\n\t  cnt+=len;\n\t  continue;\n\t}\n\n\tif(cnt<=x){\n\t  P a(cur[j].first,cur[j].first+(x-cnt));\n\t  P b(cur[j].first+(x-cnt),cur[j].second);\n\t  mid.emplace_back(b);\n\t  cur[j]=a;\n\t  cnt+=len;\n\t  continue;\n\t}\n\n\tif(y<=cnt+len){\n\t  P a(cur[j].first,cur[j].first+(y-cnt));\n\t  P c(cur[j].first+(y-cnt),cur[j].second);\n\t  mid.emplace_back(a);\n\t  nxt.emplace_back(c);\n\t  cur[j]=P(-1,-1);\n\t  cnt+=len;\n\t  continue;\n\t}\n\t\n      }\n\n      for(P x:mid) nxt.emplace_back(x);\n    \n      for(Int j=0;j<(Int)cur.size();j++)      \n        if(cur[j].second-cur[j].first)\n\t  nxt.emplace_back(cur[j]);\n    \n      swap(cur,nxt);\n\n      if(0){\n\tfor(auto x:mid) cout<<x.first<<\":\"<<x.second<<endl;\n\tfor(auto x:cur) cout<<x.first<<\" \"<<x.second<<endl;\n\tcout<<endl;\n      }\n    }\n    \n    Int x=p-1,y=q;\n    Int cnt=0;\n    vector<P> mid,nxt;\n    for(Int j=0;j<(Int)cur.size();j++){\n      Int len=cur[j].second-cur[j].first;\n      if(cnt+len<=x){\n\tcnt+=len;\n\tcontinue;\n      }\n      if(y<=cnt){\n\tnxt.emplace_back(cur[j]);\n\tcur[j]=P(-1,-1);\n\tcnt+=len;\n\tcontinue;\n      } \n      \n      if(cnt<=x&&y<=cnt+len){\n\tP a(cur[j].first,cur[j].first+(x-cnt));\n\tP b(cur[j].first+(x-cnt),cur[j].first+(y-cnt));\n\tP c(cur[j].first+(y-cnt),cur[j].second);\n\tmid.emplace_back(b);\n\tnxt.emplace_back(c);\n\tcur[j]=a;\n\tcnt+=len;\n\tcontinue;\n      }\n\n      if(x<=cnt&&cnt+len<=y){\n\tmid.emplace_back(cur[j]);\n\tcur[j]=P(-1,-1);\n\tcnt+=len;\n\tcontinue;\n      }\n\n      if(cnt<=x){\n\tP a(cur[j].first,cur[j].first+(x-cnt));\n\tP b(cur[j].first+(x-cnt),cur[j].second);\n\tmid.emplace_back(b);\n\tcur[j]=a;\n\tcnt+=len;\n\tcontinue;\n      }\n\n      if(y<=cnt+len){\n\tP a(cur[j].first,cur[j].first+(y-cnt));\n\tP c(cur[j].first+(y-cnt),cur[j].second);\n\tmid.emplace_back(a);\n\tnxt.emplace_back(c);\n\tcur[j]=P(-1,-1);\n\tcnt+=len;\n\tcontinue;\n      }\n\t\n    }\n\n    Int ans=0;\n    for(P x:mid){\n      if(x.second<=r) ans+=x.second-x.first;\n      else if(x.first<r) ans+=r-x.first;\n    }\n      \n    cout<<ans<<endl;\n  }\n  return 0;\n}\n\n"
  },
  {
    "language": "C++",
    "code": "#include<cstdio>\n#include<vector>\n#include<algorithm>\nusing namespace std;\nint main(){\n    int n,m,p,q,r;\n    for(;;){\n        scanf(\"%d%d%d%d%d\",&n,&m,&p,&q,&r);\n        if(n==0) break;\n        vector<pair<int,int> > cards;\n        cards.push_back(make_pair(1,n));\n        for(int ix=0;ix<m;ix++){\n            int x,y;\n            scanf(\"%d%d\",&x,&y);\n            vector<int> maif(cards.size()),mais(cards.size());\n            maif[0]=1;\n            mais[0]=cards[0].second-cards[0].first+1;\n            for(int i=1;i<mais.size();i++){\n                mais[i]=mais[i-1]+(cards[i].second-cards[i].first+1);\n                maif[i]=mais[i-1]+1;\n            }\n            vector<pair<int,int> > a,b,c;\n            for(int i=0;i<mais.size();i++){\n                if(mais[i]<=x) a.push_back(cards[i]);\n                else if(y<maif[i]) c.push_back(cards[i]);\n                else if(x<maif[i]&&mais[i]<=y) b.push_back(cards[i]);\n                else if(x<maif[i]&&y<mais[i]){\n                    b.push_back(make_pair(cards[i].first,y+(cards[i].first-maif[i])));\n                    c.push_back(make_pair(y+(cards[i].first-maif[i])+1,cards[i].second));\n                }\n                else if(maif[i]<=x&&mais[i]<=y){\n                    a.push_back(make_pair(cards[i].first,x+(cards[i].first-maif[i])));\n                    b.push_back(make_pair(x+(cards[i].first-maif[i])+1,cards[i].second));\n                }\n                else if(maif[i]<=x&&y<mais[i]){\n                    a.push_back(make_pair(cards[i].first,x+(cards[i].first-maif[i])));\n                    b.push_back(make_pair(x+(cards[i].first-maif[i])+1,y+(cards[i].first-maif[i])));\n                    c.push_back(make_pair(y+(cards[i].first-maif[i])+1,cards[i].second));\n                }\n            }\n            cards.clear();\n            cards.insert(cards.end(),c.begin(),c.end());\n            cards.insert(cards.end(),b.begin(),b.end());\n            cards.insert(cards.end(),a.begin(),a.end());\n        }\n        vector<int> maif(cards.size()),mais(cards.size());\n        maif[0]=1;\n        mais[0]=cards[0].second-cards[0].first+1;\n        for(int i=0;i<cards.size();i++){\n            for(int i=1;i<mais.size();i++){\n                mais[i]=mais[i-1]+(cards[i].second-cards[i].first+1);\n                maif[i]=mais[i-1]+1;\n            }\n        }\n        int ans=0;\n        for(int i=0;i<cards.size();i++){\n            if(p<=maif[i]&&mais[i]<=q) ans+=max(0,min(r,cards[i].second)-cards[i].first+1);\n            else if(maif[i]<p) ans+=max(0,min(r,cards[i].second)-(cards[i].first+(p-maif[i])+1));\n            else if(q<mais[i]) ans+=max(0,min(r,cards[i].second-(mais[i]-q))-cards[i].first+1);\n            else ans+=max(0,min(r,cards[i].second-(mais[i]-q))-(cards[i].first+(p-maif[i])+1));\n        }\n        printf(\"%d\\n\",ans);\n    }\n}"
  },
  {
    "language": "C++",
    "code": "#include <tuple>\n#include <vector>\n#include <iostream>\n#include <algorithm>\n\nusing namespace std;\n\nint n, m, p, q, c, r1, r2;\n\nvector<tuple<int, int, int> > dat;\n\ninline void divide(int pos)\n{\n\tvector<tuple<int, int, int> > dat1;\n\n\tfor (int i = 0; i < dat.size(); i++)\n\t{\n\t\tint l = get<0>(dat[i]);\n\t\tint r = get<1>(dat[i]);\n\t\tint t = get<2>(dat[i]);\n\n\t\tif (l < pos && pos < r)\n\t\t{\n\t\t\tdat1.push_back(make_tuple(l, pos, t));\n\t\t\tdat1.push_back(make_tuple(pos, r, t + pos - l));\n\t\t}\n\t\telse\n\t\t{\n\t\t\tdat1.push_back(make_tuple(l, r, t));\n\t\t}\n\t}\n\n\tdat = dat1;\n}\n\ninline void shuffle(int a, int b)\n{\n\tdivide(a);\n\tdivide(b);\n\n\tint l = lower_bound(dat.begin(), dat.end(), make_tuple(a, 0, 0)) - dat.begin();\n\tint r = lower_bound(dat.begin(), dat.end(), make_tuple(b, 0, 0)) - dat.begin();\n\tint u = dat.size();\n\n\tvector<tuple<int, int, int> > dat1;\n\n\tint pos = 0;\n\n\tfor (int i = r; i < u; i++)\n\t{\n\t\tdat1.push_back(make_tuple(pos, pos - get<0>(dat[i]) + get<1>(dat[i]), get<2>(dat[i]))); pos += get<1>(dat[i]) - get<0>(dat[i]);\n\t}\n\n\tfor (int i = l; i < r; i++)\n\t{\n\t\tdat1.push_back(make_tuple(pos, pos - get<0>(dat[i]) + get<1>(dat[i]), get<2>(dat[i]))); pos += get<1>(dat[i]) - get<0>(dat[i]);\n\t}\n\n\tfor (int i = 0; i < l; i++)\n\t{\n\t\tdat1.push_back(make_tuple(pos, pos - get<0>(dat[i]) + get<1>(dat[i]), get<2>(dat[i]))); pos += get<1>(dat[i]) - get<0>(dat[i]);\n\t}\n\n\tdat = dat1;\n}\n\nint main()\n{\n\twhile(true)\n\t{\n\t\tscanf(\"%d\", &n);\n\t\t\n\t\tif (n == 0) { break; }\n\n\t\tscanf(\"%d\", &m);\n\t\tscanf(\"%d\", &p); p--;\n\t\tscanf(\"%d\", &q); q--;\n\t\tscanf(\"%d\", &c);\n\n\t\tdat = { make_tuple(0, n, 1) };\n\n\t\tfor (int i = 0; i < m; i++)\n\t\t{\n\t\t\tscanf(\"%d\", &r1);\n\t\t\tscanf(\"%d\", &r2);\n\n\t\t\tshuffle(r1, r2);\n\t\t}\n\n\t\tint ret = 0;\n\n\t\tfor (int i = 0; i < dat.size(); i++)\n\t\t{\n\t\t\tint l = get<0>(dat[i]);\n\t\t\tint r = get<1>(dat[i]);\n\t\t\tint t = get<2>(dat[i]);\n\n\t\t\tif (p <= l && r <= q + 1)\n\t\t\t{\n\t\t\t\tret += min(max(c - t + 1, 0), r - l);\n\t\t\t}\n\t\t\telse if (p <= l && l <= q)\n\t\t\t{\n\t\t\t\tret += min(max(c - t + 1, 0), q - l + 1);\n\t\t\t}\n\t\t\telse if (p <= r && r <= q)\n\t\t\t{\n\t\t\t\tret += max(c - (t + (p - l)) + 1, 0);\n\t\t\t}\n\t\t}\n\n\t\tprintf(\"%d\\n\", ret);\n\t}\n\n\treturn 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include <set>\n#include <map>\n#include <list>\n#include <queue>\n#include <stack>\n#include <cmath>\n#include <ctime>\n#include <cstdio>\n#include <vector>\n#include <string>\n#include <bitset>\n#include <cctype>\n#include <cstdlib>\n#include <cstring>\n#include <utility>\n#include <numeric>\n#include <complex>\n#include <sstream>\n#include <fstream>\n#include <iomanip>\n#include <cassert>\n#include <iostream>\n#include <iterator>\n#include <algorithm>\n\nusing namespace std;\n\n//4方向ベクトル→↑←↓\nint dx[4] ={1,0,-1,0};\nint dy[4] ={0,-1,0,1};\n\nvector<int> Card;\nvector<int> Cardtemp;\nunsigned long n;//カードの枚数\nint m;//シャッフルの回数\nunsigned long x,y;//シャッフルする(x,y)\nunsigned long p,q,r;//p行q行以下に番号r以下のカードが何枚含まれているか\nint main()\n{\n  while(1){\n  scanf(\"%lu\",&n);\n  if(n==0)\n    break;\n  scanf(\"%d\",&m);\n  scanf(\"%lu %lu %lu\",&p,&q,&r);\n  Card.clear();\n  Cardtemp.clear();\n  for(int i = 1;i <=n;i++){\n    Card.push_back(i);\n  }\n  unsigned long ans = 0;\n  for(int i = 1;i <=m;i++){\n    Cardtemp = Card;\n    scanf(\"%lu %lu\",&x,&y);\n    for(int j = 0;j <=n-(y+1);j++){\n      Card[j] = Cardtemp[y+j];\n    }\n    for(int j = 0;j <=y-(x+1);j++){\n      Card[n-y+j] = Cardtemp[x+j];\n\t}\n    for(int j = 0;j <=x-1;j++){\n      Card[n-x+j] = Cardtemp[j];\n    }\n  }\n  for(int i = p-1;i < q;i++){\n    if(Card[i] <= r)\n      ans++;\n  }\n  cout <<ans<<endl;\n  }\n  return 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include<iostream>\n#include<map>\n#include<queue>\nusing namespace std;\ntypedef pair<int,int> P;\n#define fr first\n#define sc second\n#define rep(i,n) for(int i = 0 ; i < n ; ++i )\n\nint n,m,p,q,r;int a;\ndeque<P> card;\n\nint query(){\n  int sum = 0,ans = 0;\n  while(sum + card.front().sc - card.front().fr + 1 < p){\n    sum += card.front().sc - card.front().fr + 1;\n    card.pop_front();\n  }\n  if(sum + 1 != p) card.front().fr = card.front().fr + p - sum;\n  sum = p;\n  while(sum + card.front().sc - card.front().fr + 1 <= q){\n    if(card.front().sc <= r){ //完全に含む\n      ans += card.front().sc - card.front().fr + 1;\n    }else if(card.front().fr <= r){ //微妙に含む\n      ans += r - card.front().fr + 1;\n    }\n    sum += card.front().sc - card.front().fr + 1;\n    card.pop_front();\n  }\n  if(!card.empty() && sum != q){\n    card.push_front(P(card.front().fr,card.front().fr+q-sum-1));\n    if(card.front().sc <= r){ //完全に含む\n      ans += card.front().sc - card.front().fr + 1;\n    }else if(card.front().fr <= r){ //微妙に含む\n      ans += r - card.front().fr + 1; \n    }\n  }\n  return ans;\n}\n\nvoid deb(deque<P>& tmp){\n  cout << endl;\n  for(deque<P>::iterator it = tmp.begin();it!=tmp.end();it++){\n    cout << (*it).fr << \" \" << (*it).sc << endl;\n  }\n}\nvoid shuffle(int x,int y){\n  deque<P> A,B;\n  int sum = 0;\n  while(sum + card.front().sc - card.front().fr + 1 <= x){\n    A.push_back(card.front());\n    sum += card.front().sc - card.front().fr + 1;\n    card.pop_front();\n  }\n\n  if(sum != x){\n    A.push_back(P(card.front().fr,card.front().fr + x - sum - 1));\n    card.front().fr = card.front().fr + x - sum;\n    sum = x;\n  }\n  while(sum + card.front().sc - card.front().fr + 1 <= y){\n    B.push_back(card.front());\n    sum += card.front().sc - card.front().fr + 1;\n    card.pop_front();\n  }\n\n  if(sum != y){\n    B.push_back(P(card.front().fr,card.front().fr + y - sum - 1));\n    card.front().fr = card.front().fr + y - sum;\n    sum = y;\n  }\n  card.insert(card.end(),B.begin(),B.end());\n  card.insert(card.end(),A.begin(),A.end());\n}\n\nint main(){\n  while(cin >> n , n){\n    cin >> m >> p >> q >> r;\n    p--;\n    card.push_back(P(1,n));\n    while(m--){\n      int x,y;\n      cin >> x >> y;\n      shuffle(x,y);\n    }\n    cout << query() << endl;\n    card.clear();\n  }\n}"
  },
  {
    "language": "C++",
    "code": "#include <iostream>\n#include <cstdio>\n#include <algorithm>\n#include <map>\n#include <vector>\n\nusing namespace std;\n\n#define FOR(i,a,b) for(int i=(a);i<(b);i++)\n#define REP(i,n) FOR(i,0,n)\n\ntypedef pair<int, int> pii;\n\nstruct Data {\n\tint x, y, cnt;\n\tData() {}\n\tData(int x, int y, int cnt) : x(x), y(y), cnt(cnt) {}\n};\n\nint n, m, p, q, r;\n\nint main() {\n\twhile (cin >> n, n) {\n\t\tcin >> m >> p >> q >> r;\n\t\tp--; q--;\n\t\t\n\t\tvector<Data> data;\n\t\tdata.push_back(Data(0, n, r));\n\t\t\n\t\tREP(i, m) {\n\t\t\tint x, y;\n\t\t\tscanf(\"%d %d\", &x, &y);\n\t\t\t\n\t\t\tvector<pii> res[3]; // ???????????§??????, r??\\???????????°\n\t\t\t\n\t\t\tint c[3] = {x, y - x, n - y};\n\t\t\tpii pos = pii(0, 0); // i,j  data???i?????????j?????§??????\n\t\t\t\n\t\t\tREP(i, 3) {\n\t\t\t\tint cnt = c[i];\n\t\t\t\t\n\t\t\t\twhile (cnt > 0) {\n\t\t\t\t\tint len = data[pos.first].y - data[pos.first].x;\n\t\t\t\t\tint diff = min(cnt, len - pos.second);\n\t\t\t\t\t\n\t\t\t\t\tres[i].push_back(pii(diff, max(0, min(data[pos.first].cnt - pos.second, diff))));\n\t\t\t\t\t\n\t\t\t\t\tcnt -= diff;\n\t\t\t\t\tpos.second += diff;\n\t\t\t\t\t\n\t\t\t\t\tif (pos.second == len)\n\t\t\t\t\t\tpos = pii(pos.first + 1, 0);\n\t\t\t\t\t\n\t\t\t\t}\n\t\t\t}\n\t\t\t\n\t\t\tdata.clear();\n\t\t\tint cnt = 0;\n\t\t\tfor (int i = 2; i >= 0; i--) {\n\t\t\t\tREP(j, res[i].size()) {\n\t\t\t\t\tdata.push_back(Data(cnt, cnt + res[i][j].first, res[i][j].second));\n\t\t\t\t\tcnt += res[i][j].first;\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t\t\n\t\tint ans, pos = 0;\n\t\twhile (data[pos].y <= p) pos++;\n\t\t\n\t\tans = max(0, data[pos].cnt - (p - data[pos].x));\n\t\t\n\t\tif (data[pos].y > q) {\n\t\t\tans = min(ans, q - p + 1);\n\t\t}\n\t\telse {\n\t\t\tpos++;\n\t\t\twhile (data[pos].y <= q) ans += data[pos++].cnt;\n\t\t\tans += min(data[pos].cnt, q - data[pos].x + 1);\n\t\t}\n\t\t\n\t\tcout << ans << endl;\n\t}\n\treturn 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include <iostream>\n#include<algorithm>\n#include<vector>\nusing namespace std;\nmain(){\n\tint n,m,p,q,r,x,y;\n\tvector<int>::iterator v,w,z;\n\tfor(;cin>>n>>m>>p>>q>>r;cout<<x<<endl){\n\tvector<int>t(1),u;\n\n\tfor(t.push_back(r);m--;u.clear()){\n\t\tcin>>x>>y;\n\t\tv=upper_bound(t.begin(),t.end(),x);\n\t\tw=upper_bound(t.begin(),t.end(),y);\n\n//\t\tif(w-t.begin()+1&1)u.push_back(0);u.push_back(0);\n\t\tu.insert(u.end(),w-t.begin()&1?1:2,0);\n\t\tfor(z=w;z<t.end();++z)\n\t\t\tu.push_back(*z-y);\n\t\t\t\n\t\t\tif(t.end()-v&1)u.push_back(n-y);\n\t\t\tfor(z=v;z<w;++z)\n\t\t\t\tu.push_back(*z-x+n-y);\n\t\t\t\n\t\t\tz=t.begin();\n\t\t\tif(w-t.begin()&1)++z;\n\t\t\tif(!z[1])z+=2;\n\t\t\tif(*z+n-x==u.back())++z,u.pop_back();\n\t\t\tfor(;z<v;++z)\n\t\t\t\tu.push_back(*z+n-x);\n\t\t\t\n\t\t\tt.swap(u);\n\t\t}\n\t\tt.insert(upper_bound(t.begin(),t.end(),p-1),2,p-1);\n\t\tt.insert(lower_bound(t.begin(),t.end(),q),q);\n\t\tt.push_back(n);\n\t\tz=upper_bound(t.begin(),t.end(),p-1);\n\t\tif(z-t.begin()&1)--z;\n\t\tfor(x=0;*z<q;\n\t\t\tx+=*z++-m)\n\t\t\tm=*z++;\n\t}\n}"
  },
  {
    "language": "C++",
    "code": "#include <iostream>\n#include <algorithm>\n#include <utility>\n#include <vector>\n#include <list>\n#include <map>\n#include <set>\n#include <queue>\n#include <stack>\n#include <string>\n#include <sstream>\n#include <cstring>\n#include <cstdlib>\n\nusing namespace std;\n\n#define ALL(c) c.begin(),c.end()\n#define RALL(c) c.rbegin(),c.rend()\n#define REP(i,x,y) for(int i=(x);i<(y);++i)\n#define MP(a,b) make_pair((a),(b))\n#define F_ first\n#define S_ second\n\ntypedef long long int lli;\ntypedef pair<int,int> Pi;\n\nconst int INF=100000000;\nconst long long int INF_=100000000000000000;\n\nstruct Segment{\n\tint s,e/*,size()*/;\n\tSegment(int a,int b):s(a),e(b){}\n\tint size(){\n\t\treturn e-s+1;\n\t}\n};\n\nvoid Split(vector<Segment> *state,int i,int x,int y){\n\t{\n\t\tint s=0;\n\t\tbool flag=true;\n\t\tREP(j,0,state[i-1].size()){\n\t\t\ts+=state[i-1][j].size();\n\t\t\tif(y<s){\n\t\t\t\tif(flag){\n\t\t\t\t\tstate[i].push_back(Segment(state[i-1][j].s+state[i-1][j].size()-(s-y),state[i-1][j].e));\n\t\t\t\t\tflag=false;\n\t\t\t\t}else{\n\t\t\t\t\tstate[i].push_back(state[i-1][j]);\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t}\n\t{\n\t\tint s=0;\n\t\tbool flag=true;\n\t\tREP(j,0,state[i-1].size()){\n\t\t\ts+=state[i-1][j].size();\n\t\t\tif(y<=s){\n\t\t\t\tif(flag){\n\t\t\t\t\tstate[i].push_back(Segment(state[i-1][j].s+state[i-1][j].size()-(s-x),state[i-1][j].e-(s-y)));\n\t\t\t\t}else{\n\t\t\t\t\tstate[i].push_back(Segment(state[i-1][j].s,state[i-1][j].e-(s-y)));\n\t\t\t\t}\n\t\t\t\tbreak;\n\t\t\t}else if(x<s){\n\t\t\t\tif(flag){\n\t\t\t\t\tstate[i].push_back(Segment(state[i-1][j].s+state[i-1][j].size()-(s-x),state[i-1][j].e));\n\t\t\t\t\tflag=false;\n\t\t\t\t}else{\n\t\t\t\t\tstate[i].push_back(state[i-1][j]);\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t}\n\t{\n\t\tint s=0;\n\t\tREP(j,0,state[i-1].size()){\n\t\t\ts+=state[i-1][j].size();\n\t\t\tif(x<=s){\n\t\t\t\tstate[i].push_back(Segment(state[i-1][j].s,state[i-1][j].s+state[i-1][j].size()-(s-x)-1));\n\t\t\t\tbreak;\n\t\t\t}else {\n\t\t\t\tstate[i].push_back(state[i-1][j]);\n\t\t\t}\n\t\t}\n\t}\n}\n\nint main(){\n\tint N;\n\twhile(cin>>N&&N){\n\t\tint M,P,Q,R;\n\t\tcin >> M >> P >> Q >> R;\n\t\tvector<int> X(M),Y(M);\n\t\tREP(i,0,M) cin >> X[i] >> Y[i];\n\t\tvector<Segment> state[5001];\n\t\tstate[0].push_back(Segment(1,N));\n\t\t//cout << endl;\n\t\tREP(i,1,M+1){\n\t\t\tSplit(state,i,X[i-1],Y[i-1]);\n\t\t\t/*\n\t\t\tREP(j,0,state[i].size()){\n\t\t\t\tcout << state[i][j].s << ' ' << state[i][j].e << ' ' << state[i][j].size() << endl;\n\t\t\t}\n\t\t\tcout << endl;\n\t\t\t*/\n\t\t}\n\t\tint ans=0;\n\t\tint s=0;\n\t\tbool flag=true;\n\t\tREP(i,0,state[M].size()){\n\t\t\ts+=state[M][i].size();\n\t\t\tint tmp=0;\n\t\t\tif(Q<=s){\n\t\t\t\tif(R<state[M][i].s) break;\n\t\t\t\tif(flag){\n\t\t\t\t\ttmp=min(R,state[M][i].s+state[M][i].size()-(s-Q)-1)-(state[M][i].s+state[M][i].size()-(s-P)-1)+1;\n\t\t\t\t}else{\n\t\t\t\t\ttmp=min(R,state[M][i].s+state[M][i].size()-(s-Q)-1)-state[M][i].s+1;\n\t\t\t\t}\n\t\t\t\tans+=tmp;\n\t\t\t\tbreak;\n\t\t\t}else if(P<=s){\n\t\t\t\tif(flag){\n\t\t\t\t\tif(R>=state[M][i].s) tmp=min(R,state[M][i].e)-(state[M][i].s+state[M][i].size()-(s-P)-1)+1;\n\t\t\t\t\tflag=false;\n\t\t\t\t}else{\n\t\t\t\t\tif(R>=state[M][i].s) tmp+=min(R,state[M][i].e)-state[M][i].s+1;\n\t\t\t\t}\n\t\t\t\tans+=tmp;\n\t\t\t}\n\t\t}\n\t\tcout << ans << endl;\n\t}\n\treturn 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include <iostream>\n#include <algorithm>\n#include <string>\n#include <vector>\nusing namespace std;\n\nint N, M, P, Q, R;\n\nint sign(int x) {\n  if (x >= 0) return 1;\n  else        return -1;\n}\n\nvoid div(vector<int> &s, int x, int y, vector<int> &a, vector<int> &b, vector<int> &c) {\n  int i = 0, h = 0;\n  for (; i<s.size(); i++) {\n    h += abs(s[i]);\n    if (h >= x) {\n      int fa = x - (h-abs(s[i])),\n          fb = h - x;\n      if (fa > 0) a.push_back(sign(s[i]) * fa);\n      if (fb > 0) {\n        h -= fb;\n        s[i] = sign(s[i]) * fb;\n      }\n      else i++;\n      break;\n    }\n    a.push_back(s[i]);\n  }\n  for (; i<s.size(); i++) {\n    h += abs(s[i]);\n    if (h >= y) {\n      int fa = y - (h-abs(s[i])),\n          fb = h - y;\n      if (fa > 0) b.push_back(sign(s[i]) * fa);\n      if (fb > 0) {\n        h -= fb;\n        s[i] = sign(s[i]) * fb;\n      }\n      else i++;\n      break;\n    }\n    b.push_back(s[i]);\n  }\n  for (; i<s.size(); i++) {\n    c.push_back(s[i]);\n  }\n}\n\nint main() {\n  cin >> N >> M >> P >> Q >> R;\n\n  vector<int> s;\n  s.push_back(R), s.push_back(R-N);\n\n  for (int k=0; k<M; k++) {\n    int x, y;\n    cin >> x >> y;\n    vector<int> a, b, c;\n    div(s, x, y, a, b, c);\n    s.clear();\n    s.insert(s.end(), c.begin(), c.end());\n    s.insert(s.end(), b.begin(), b.end());\n    s.insert(s.end(), a.begin(), a.end());\n  }\n\n  vector<int> a, b, c;\n  div(s, P-1, Q, a, b, c);\n  int ans = 0;\n  for (auto x : b) ans += max(x, 0);\n  cout << ans << \"\\n\";\n  return 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include <iostream>\n#include <algorithm>\n#include <vector>\nusing namespace std;\nint main(){\n\tint n,m,p,q,r,x,y;\n\tvector<int>::iterator itx,ity,it;\n\tfor(;cin>>n>>m>>p>>q>>r;cout<<x<<endl){\n\t\tvector<int> v1(1),v2;\n\t\t\n\t\tfor(v1.push_back(r);m--;v2.clear()){\n\t\t\tcin>>x>>y;\n\t\t\titx=upper_bound(v1.begin(),v1.end(),x);\n\t\t\tity=upper_bound(v1.begin(),v1.end(),y);\n\t\t\t\n\t\t\tif( ity-v1.begin()+1 & 1 )v2.push_back(0);\n\t\t\tv2.push_back(0);\n//\t\t\tv2.insert(v2.end(),ity-v1.begin()&1?1:2,0);\n\t\t\tfor(it=ity;it!=v1.end();++it)\n\t\t\t\tv2.push_back(*it - y);\n\t\t\t\n\t\t\tif(v1.end()-itx & 1)v2.push_back(n-y);\n\t\t\tfor(it=itx;it!=ity;++it)\n\t\t\t\tv2.push_back(*it-x+n-y);\n\t\t\t\n\t\t\tit = v1.begin();\n\t\t\tif(ity-v1.begin() & 1)++it;\n\t\t\tif(!it[1])it+=2;\n\t\t\tif(*it+n-x==v2.back()){++it;v2.pop_back();}\n\t\t\tfor(;it!=itx;++it)\n\t\t\t\tv2.push_back(*it+n-x);\n\t\t\t\n\t\t\tv1.swap(v2);\n\t\t}\n\t\tv1.insert( upper_bound(v1.begin(),v1.end(),p-1), 2, p-1);\n\t\tv1.insert( lower_bound(v1.begin(),v1.end(),q), q );\n\t\tv1.push_back(n);\n\t\tit = upper_bound(v1.begin(),v1.end(),p-1);\n\t\tif(it-v1.begin() & 1) --it;\n\t\tfor(x=0;*it<q;++it){\n\t\t\tm=*it;++it;\n\t\t\tx+=*it-m;\n\t\t}\n\t}\n}"
  },
  {
    "language": "C++",
    "code": "#include<iostream>\n#include<cstring>\n#include<queue>\n#include<algorithm>\nusing namespace std;\n\nint x[5001][3];\nint z[25000][2];\n\nqueue<int>Q1;\nqueue<int>R1;\nqueue<int>S1;\nqueue<int>Q2;\nqueue<int>R2;\nqueue<int>S2;\n\nint main() {\n\tint n, m, a, b, c, k, p, sum, sum2, sum3, t;\n\twhile (true) {\n\t\tcin >> n;\n\t\tif (n == 0) {\n\t\t\tbreak;\n\t\t}\n\t\tcin >> m >> a >> b >> c;\n\t\tz[0][0] = 1;\n\t\tz[0][1] = n;\n\n\t\tk = 1;\n\t\tfor (int i = 1; i <= m; i++) {\n\t\t\tcin >> x[i][1] >> x[i][2];\n\t\t\tsum2 = 1;\n\t\t\tsum3 = 1;\n\t\t\tfor (int j = 0; j < k; j++) {\n\t\t\t\tsum2 += z[j][1] - z[j][0] + 1;\n\t\t\t\tsum2 -= 1;\n\t\t\t\tif (sum2 <= x[i][1]) {\n\t\t\t\t\tQ1.push(z[j][0]);\n\t\t\t\t\tQ2.push(z[j][1]);\n\t\t\t\t}\n\t\t\t\telse if (sum3 > x[i][2]) {\n\t\t\t\t\tS1.push(z[j][0]);\n\t\t\t\t\tS2.push(z[j][1]);\n\t\t\t\t}\n\t\t\t\telse if (sum2 <= x[i][2] && sum3 > x[i][1]) {\n\t\t\t\t\tR1.push(z[j][0]);\n\t\t\t\t\tR2.push(z[j][1]);\n\t\t\t\t}\n\t\t\t\telse if (sum2 <= x[i][2] && sum3 <= x[i][1]) {\n\t\t\t\t\tQ1.push(z[j][0]);\n\t\t\t\t\tQ2.push(z[j][0] + x[i][1] - sum3);\n\t\t\t\t\tR1.push(z[j][0] + x[i][1] - sum3 + 1);\n\t\t\t\t\tR2.push(z[j][1]);\n\t\t\t\t}\n\t\t\t\telse if (sum2 > x[i][2] && sum3 > x[i][1]) {\n\t\t\t\t\tR1.push(z[j][0]);\n\t\t\t\t\tR2.push(z[j][0] + x[i][2] - sum3);\n\t\t\t\t\tS1.push(z[j][0] + x[i][2] - sum3 + 1);\n\t\t\t\t\tS2.push(z[j][1]);\n\t\t\t\t}\n\t\t\t\telse {\n\t\t\t\t\tQ1.push(z[j][0]);\n\t\t\t\t\tQ2.push(z[j][0] + x[i][1] - sum3);\n\t\t\t\t\tR1.push(z[j][0] + x[i][1] - sum3 + 1);\n\t\t\t\t\tR2.push(z[j][0] + x[i][2] - sum3);\n\t\t\t\t\tS1.push(z[j][0] + x[i][2] - sum3 + 1);\n\t\t\t\t\tS2.push(z[j][1]);\n\t\t\t\t}\n\t\t\t\tsum2 += 1;\n\t\t\t\tsum3 = sum2;\n\t\t\t}\n\t\t\tk = 0;\n\t\t\tk += Q1.size();\n\t\t\tk += R1.size();\n\t\t\tk += S1.size();\n\t\t\tp = 0;\n\n\t\t\twhile (!S1.empty()) {\n\t\t\t\tz[p][0] = S1.front();\n\t\t\t\tz[p][1] = S2.front();\n\t\t\t\tS1.pop();\n\t\t\t\tS2.pop();\n\t\t\t\tp++;\n\t\t\t}\n\t\t\twhile (!R1.empty()) {\n\t\t\t\tz[p][0] = R1.front();\n\t\t\t\tz[p][1] = R2.front();\n\t\t\t\tR1.pop();\n\t\t\t\tR2.pop();\n\t\t\t\tp++;\n\t\t\t}\n\t\t\twhile (!Q1.empty()) {\n\t\t\t\tz[p][0] = Q1.front();\n\t\t\t\tz[p][1] = Q2.front();\n\t\t\t\tQ1.pop();\n\t\t\t\tQ2.pop();\n\t\t\t\tp++;\n\t\t\t}\n\t\t}\n\t\tsum = 0;\n\t\tsum2 = 1;\n\t\tsum3 = 1;\n\t\tfor (int i = 0; i < k; i++) {\n\t\t\tsum2 += z[i][1] - z[i][0] + 1;\n\t\t\tif (sum2 - 1 >= a && sum3 <= b) {\n\t\t\t\tif (z[i][1] <= c) {\n\t\t\t\t\tsum += min(b, sum2 - 1) - max(a, sum3) + 1;\n\t\t\t\t}\n\t\t\t\telse if (z[i][0] <= c) {\n\t\t\t\t\tt = min(b, sum2 - 1);\n\t\t\t\t\tt = min(t, sum3 + c - z[i][0]);\n\t\t\t\t\tif (t - max(a, sum3) >= 0) {\n\t\t\t\t\t\tsum += t - max(a, sum3) + 1;\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t}\n\t\t\tsum3 = sum2;\n\t\t}\n\t\tcout << sum << endl;\n\t}\n\treturn 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include <cstdio>\n#include <vector>\n#include <algorithm>\n\nusing namespace std;\n\ntypedef struct {\n    int begin;\n    int end;\n} Range;\n\ninline int length(Range r) {\n    return r.end - r.begin + 1;\n}\n\nvoid shuffle(vector<Range> &ranges, int x, int y) {\n    int count = 1;\n    int pos_x;\n    int pos_y;\n    vector<Range> tmp;\n    tmp.clear();\n\n    for (int i=0; i < ranges.size(); i++) {\n        int len = length(ranges[i]);\n            \n        if (count + len > x) {\n             Range new_range;\n             new_range.end = ranges[i].end;\n\n             ranges[i].end -= (count + len - 1 - x);\n             if (count + len - 1 != x) {\n                 new_range.begin = ranges[i].end + 1;\n                 ranges.insert(ranges.begin() + i+1, new_range);\n             }\n\n             pos_x = i+1;\n             break;\n        }\n\n        count += len;\n    }\n\n    count = 1;\n    for (int i=0; i < ranges.size(); i++) {\n        int len = length(ranges[i]);\n\n        if (count + len > y) {\n            Range new_range;\n            new_range.end = ranges[i].end;\n\n            ranges[i].end -= (count + len - 1 - y);\n            if (count + len - 1 != y) {\n                new_range.begin = ranges[i].end + 1;\n                ranges.insert(ranges.begin() + i+1, new_range);\n            }\n\n            pos_y = i+1;\n            break;\n        }\n\n         count += len;\n     }\n\n     for (int i=pos_y; i < ranges.size(); i++) {\n         tmp.push_back(ranges[i]);\n     }\n\n     for (int i=pos_x; i < pos_y; i++) {\n         tmp.push_back(ranges[i]);\n     }\n\n     for (int i=0; i < pos_x; i++) {\n         tmp.push_back(ranges[i]);\n     }\n\n     ranges.swap(tmp);\n}\n\nint main() {\n    while (1) {\n        int n;\n        int m;\n        int p, q, r;\n        int count;\n        int num;\n        Range first_range;\n        vector<Range> ranges(1);\n    \n        scanf(\"%d\", &n);\n        if (n == 0) return 0;\n\n        scanf(\"%d\", &m);\n        scanf(\"%d %d %d\", &p, &q, &r);\n    \n        first_range.begin = 1;\n        first_range.end = n;\n        ranges[0] = first_range;\n    \n        for (int i=0; i<m; i++) {\n            int x, y;\n    \n            scanf(\"%d %d\", &x, &y);\n            shuffle(ranges, x, y);\n        }\n\n        num = 0;\n        count = 1;\n        for (vector<Range>::iterator itr = ranges.begin(); itr != ranges.end(); itr++) {\n             int start;\n             int end;\n             int len = length(*itr);\n    \n             if (count > q) break;\n    \n             if (count + len > p) {\n                 end = itr->end;\n                 start = itr->begin;\n    \n                 if (count < p) {\n                     start += (p - count);\n                 } \n    \n                 if (count + len > q) {\n                     end -= (count + len - q - 1);\n                 }\n    \n                 if (start <= r) {\n                     if (end <= r) {\n                         num += end - start + 1;\n                     } else {\n                         num += r - start + 1;\n                     }\n                 }\n             }\n    \n             count += len;\n        }\n\n        printf(\"%d\\n\", num);   \n    }\n}"
  },
  {
    "language": "C++",
    "code": "#include<iostream>\n#include<stdio.h>\n#include<math.h>\n#include    <iomanip>\n#include    <map>\n#include    <set>\n#include    <vector>\nusing namespace std;\nvector<int> func(vector<int> &vec,int a,int b){\n    vector<int> v1,v2,v3;\n    int flag=1;\n    //1-a\n    for(auto it:vec){\n        if (flag<=a) {\n            v1.push_back(it);\n        }else if (flag<=b){\n            v2.push_back(it);\n        }else{\n            v3.push_back(it);\n        }\n        flag++;\n    }\n    \n    for(auto it:v2){\n        v3.push_back(it);\n    }\n    for(auto it:v1){\n        v3.push_back(it);\n    }\n    //a+1 - b\n    //b+1 - n1\n    return v3;\n}\nint a[1000][2];\nint main(){\n    int n1,n2,n3,n4;\n    while(cin>>n1&&n1!=0){\n        cin>>n2;\n        int p,q,r;\n        cin>>p>>q>>r;;\n        \n        for (int i=0; i<n2; i++) {\n            for (int j=0; j<2; j++) {\n                cin>>a[i][j];\n            }\n        }\n        \n        //1-n1\n        vector<int> vec;\n        for(int i=1;i<n1+1;i++){\n            vec.push_back(i);\n        }\n        \n        for (int i=0; i<n2; i++) {\n            vec=func(vec,a[i][0],a[i][1]);\n        }\n        int sum=0;\n        for(int i=p;i<=q;i++){\n            if(vec[i-1]<=r)sum++;\n        }\n        cout<<sum<<endl;\n    }\n    return 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include <cstdio>\n#include <vector>\n#include <algorithm>\n\nusing namespace std;\n\ntypedef struct {\n    int begin;\n    int end;\n} Range;\n\nRange empty_range = {0, 0};\n\ninline int length(Range r) {\n    return r.end - r.begin + 1;\n}\n\nvoid shuffle(vector<Range> &ranges, int x, int y) {\n    int count = 1;\n    int pos_x;\n    int pos_y;\n    vector<Range> tmp;\n    tmp.clear();\n\n    for (int i=0; i < ranges.size(); i++) {\n        int len = length(ranges[i]);\n\n        if (count + len > x) {\n             Range new_range;\n             new_range.end = ranges[i].end;\n\n             ranges[i].end = ranges[i].end - (count + len - x - 1);\n             if (count != x) {\n                 new_range.begin = ranges[i].end + 1;\n                 ranges.insert(ranges.begin() + i + 1, new_range);\n             }\n\n             pos_x = i+1;\n             break;\n        }\n\n        count += len;\n    }\n\n    count = 1;\n    for (int i=0; i < ranges.size(); i++) {\n        int len = length(ranges[i]);\n\n        if (count + len > y) {\n             Range new_range;\n             new_range.end = ranges[i].end;\n\n             ranges[i].end = ranges[i].end - (count + len - y - 1);\n             if (count != y) {\n                 new_range.begin = ranges[i].end + 1;\n                 ranges.insert(ranges.begin() + i + 1, new_range);\n             }\n\n             pos_y = i+1;\n             break;\n         }\n\n         count += len;\n     }\n\n     for (int i=pos_y; i < ranges.size(); i++) {\n         tmp.push_back(ranges[i]);\n     }\n\n     for (int i=pos_x; i < pos_y; i++) {\n         tmp.push_back(ranges[i]);\n     }\n\n     for (int i=0; i < pos_x; i++) {\n         tmp.push_back(ranges[i]);\n     }\n\n     ranges.swap(tmp);\n}\n\nint main() {\n    int n;\n    int m;\n    int p, q, r;\n    int count;\n    int num;\n    Range first_range;\n    vector<Range> ranges(1);\n\n    scanf(\"%d\", &n);\n    scanf(\"%d\", &m);\n    scanf(\"%d %d %d\", &p, &q, &r);\n\n    first_range.begin = 1;\n    first_range.end = n;\n    ranges[0] = first_range;\n\n    for (int i=0; i<m; i++) {\n        int x, y;\n\n        scanf(\"%d %d\", &x, &y);\n        shuffle(ranges, x, y);\n    }\n\n    num = 0;\n    count = 1;\n    for (vector<Range>::iterator itr = ranges.begin(); itr != ranges.end(); itr++) {\n         int start;\n         int end;\n         int len = length(*itr);\n\n         if (count > q) break;\n\n         if (count + len > p) {\n             end = itr->end;\n             start = itr->begin;\n\n             if (count < p) {\n                 start += (count + len - p);\n             } \n\n             if (count + len > q) {\n                 end -= (count + len - q - 1);\n             }\n\n             if (start <= r) {\n                 if (end <= r) {\n                     num += end - start + 1 ;\n                 } else {\n                     num += r - start + 1;\n                 }\n             }\n         }\n\n         count += len;\n    }\n \n    printf(\"%d\\n\", num);   \n}"
  },
  {
    "language": "C++",
    "code": "#include<cstdio>\n#include<vector>\n#include<map>\n#include<algorithm>\nusing namespace std;\n\nint main(){\n  while(1){\n    int n, m, p, q, r;\n    scanf(\"%d\", &n);\n    if(n == 0)return 0;\n    scanf(\"%d%d%d%d\", &m, &p, &q, &r);\n    vector<pair<int, int> > mountain, mounta, mountb;\n    mountain.push_back(make_pair(1, n));\n    for(int i = 0;i < m;i++){\n      int x, y, j = 0;\n      scanf(\"%d%d\", &x, &y);\n      \n      while(j + mountain[0].second - mountain[0].first + 1 < x){\n\tj += mountain[0].second - mountain[0].first + 1;\n\tmounta.push_back(mountain[0]);\n\tmountain.erase(mountain.begin());\n      }\n      mounta.push_back(make_pair(mountain[0].first ,mountain[0].first + x - j - 1));\n      if(mountain[0].second == mountain[0].first + x - j - 1)mountain.erase(mountain.begin());\n      else mountain[0].first += x - j;\n      j = x;\n\n      while(j + mountain[0].second - mountain[0].first + 1 < y){\n\tj += mountain[0].second - mountain[0].first + 1;\n\tmountb.push_back(mountain[0]);\n\tmountain.erase(mountain.begin());\n      }\n      mountb.push_back(make_pair(mountain[0].first ,mountain[0].first + y - j - 1));\n      if(mountain[0].second == mountain[0].first + y - j - 1)mountain.erase(mountain.begin());\n      else mountain[0].first += y - j;\n      \n      while(!mountb.empty()){\n\tmountain.push_back(mountb[0]);\n\tmountb.erase(mountb.begin());\n      }\n      while(!mounta.empty()){\n\tmountain.push_back(mounta[0]);\n\tmounta.erase(mounta.begin());\n      }\n    }\n    int j = 0;\n    while(j + mountain[0].second - mountain[0].first + 1 < p - 1){\n      j += mountain[0].second - mountain[0].first + 1;\n      mountain.erase(mountain.begin());\n    }\n    if(mountain[0].second == mountain[0].first + p - j - 2)mountain.erase(mountain.begin());\n    else mountain[0].first += p - j - 1;\n    j = p - 1;\n    \n    int res = 0;\n    while(j + mountain[0].second - mountain[0].first + 1 < q){\n      res += max(0, min(r, mountain[0].second) - mountain[0].first + 1);\n      j += mountain[0].second - mountain[0].first + 1;\n      mountain.erase(mountain.begin());      \n    }\n    res += max(0, min(r, mountain[0].first + q - j - 1) - mountain[0].first + 1);\n    printf(\"%d\\n\", res);\n  }\n}"
  },
  {
    "language": "C++",
    "code": "#include <iostream>\n#include <algorithm>\n#include <vector>\n#include<cstdio>\nusing namespace std;\nint main(){\n\tint n,m,p,q,r,x,y,t;\n\tvector<int>::iterator itx,ity,it;\n\tfor(;cin>>n>>m>>p>>q>>r;cout<<x<<endl){\n\t\tvector<int> v1,v2;\n\t\tv1.push_back(0);\n\t\tv1.push_back(r);\n\t\t\n\t\tfor(;m--;v2.clear()){\n\t\t\tcin>>x>>y;\n\t\t\titx=upper_bound(v1.begin(),v1.end(),x);\n\t\t\tity=upper_bound(v1.begin(),v1.end(),y);\n\t\t\t\n\t\t\tif( ity-v1.begin()+1 & 1 )v2.push_back(0);\n\t\t\tv2.push_back(0);\n\t\t\tfor(it=ity;it!=v1.end();++it)\n\t\t\t\tv2.push_back(*it - y);\n\t\t\t\n\t\t\tif(v1.end()-itx & 1)v2.push_back(n-y);\n\t\t\tfor(it=itx;it!=ity;++it)\n\t\t\t\tv2.push_back(*it-x+n-y);\n\t\t\t\n\t\t\tit = v1.begin();\n\t\t\tif(ity-v1.begin() & 1)++it;\n\t\t\tif(!it[1]){++it;++it;}\t//d¡r\n\t\t\tif(*it+n-x==v2.back()){++it;v2.pop_back();}\t//d¡r\n\t\t\tfor(;it!=itx;++it)\n\t\t\t\tv2.push_back(*it+n-x);\n\t\t\t\n\t\t\tv1.swap(v2);\n\t\t\t\n/*\t\t\tfor(it=v1.begin();it!=v1.end();++it)\n\t\t\t\tcout<<*it<<'\\t';\n\t\t\tcout<<'\\n';\n*/\t\t}\n\t\tv1.insert( upper_bound(v1.begin(),v1.end(),p-1), 2, p-1);\n\t\tv1.insert( lower_bound(v1.begin(),v1.end(),q), q );\n\t\tv1.push_back(n);\n\t\tit = upper_bound(v1.begin(),v1.end(),p-1);\n\t\tif(it-v1.begin() & 1) --it;\n/*\nfor(itx=v1.begin();itx!=v1.end();++itx)\n\tcout<<*itx<<'\\t';\ncout<<'\\n';\n\n\t\tprintf(\"%d\\t%d\\n\",it-v1.begin(),*it);\n*/\t\tfor(x=0;*it<q;++it){\n\t\t\tm=*it;\n\t\t\t++it;\n\t\t\tx+=*it-m;\n\t\t}\n\t}\n}"
  },
  {
    "language": "C++",
    "code": "#include <tuple>\n#include <vector>\n#include <iostream>\n#include <algorithm>\n\n#pragma warning(disable : 4996)\n\nusing namespace std;\n\nint n, m, p, q, c, r1, r2;\n\nvector<tuple<int, int, int> > dat;\n\ninline void divide(int pos)\n{\n\tvector<tuple<int, int, int> > dat1;\n\n\tint u = dat.size();\n\n\tfor (int i = 0; i < u; i++)\n\t{\n\t\tint l = get<0>(dat[i]);\n\t\tint r = get<1>(dat[i]);\n\t\tint t = get<2>(dat[i]);\n\n\t\tif (l < pos && pos < r)\n\t\t{\n\t\t\tdat1.push_back(make_tuple(l, pos, t));\n\t\t\tdat1.push_back(make_tuple(pos, r, t + pos - l));\n\t\t}\n\t\telse if(r <= pos)\n\t\t{\n\t\t\tdat1.push_back(make_tuple(l, r, t));\n\t\t}\n\t\telse\n\t\t{\n\t\t\tbreak;\n\t\t}\n\t}\n\n\tdat = dat1;\n}\n\ninline void shuffle(int a, int b)\n{\n\tdivide(a);\n\tdivide(b);\n\n\tint l = lower_bound(dat.begin(), dat.end(), make_tuple(a, 0, 0)) - dat.begin();\n\tint r = lower_bound(dat.begin(), dat.end(), make_tuple(b, 0, 0)) - dat.begin();\n\tint u = dat.size();\n\n\tvector<tuple<int, int, int> > dat1;\n\n\tint pos = 0;\n\n\tfor (int i = r; i < u; i++)\n\t{\n\t\tdat1.push_back(make_tuple(pos, pos - get<0>(dat[i]) + get<1>(dat[i]), get<2>(dat[i]))); pos += get<1>(dat[i]) - get<0>(dat[i]);\n\t}\n\n\tfor (int i = l; i < r; i++)\n\t{\n\t\tdat1.push_back(make_tuple(pos, pos - get<0>(dat[i]) + get<1>(dat[i]), get<2>(dat[i]))); pos += get<1>(dat[i]) - get<0>(dat[i]);\n\t}\n\n\tfor (int i = 0; i < l; i++)\n\t{\n\t\tdat1.push_back(make_tuple(pos, pos - get<0>(dat[i]) + get<1>(dat[i]), get<2>(dat[i]))); pos += get<1>(dat[i]) - get<0>(dat[i]);\n\t}\n\n\tdat = dat1;\n}\n\nint main()\n{\n\twhile(true)\n\t{\n\t\tscanf(\"%d\", &n);\n\t\t\n\t\tif (n == 0) { break; }\n\n\t\tscanf(\"%d\", &m);\n\t\tscanf(\"%d\", &p); p--;\n\t\tscanf(\"%d\", &q); q--;\n\t\tscanf(\"%d\", &c);\n\n\t\tdat = { make_tuple(0, n, 1) };\n\n\t\tfor (int i = 0; i < m; i++)\n\t\t{\n\t\t\tscanf(\"%d\", &r1);\n\t\t\tscanf(\"%d\", &r2);\n\n\t\t\tshuffle(r1, r2);\n\t\t}\n\n\t\tint ret = 0;\n\n\t\tfor (int i = 0; i < dat.size(); i++)\n\t\t{\n\t\t\tint l = get<0>(dat[i]);\n\t\t\tint r = get<1>(dat[i]);\n\t\t\tint t = get<2>(dat[i]);\n\n\t\t\tif (p <= l && r <= q + 1)\n\t\t\t{\n\t\t\t\tret += min(max(c - t + 1, 0), r - l);\n\t\t\t}\n\t\t\telse if (p <= l && l <= q)\n\t\t\t{\n\t\t\t\tret += min(max(c - t + 1, 0), q - l + 1);\n\t\t\t}\n\t\t\telse if (p <= r && r <= q)\n\t\t\t{\n\t\t\t\tret += max(c - (t + (p - l)) + 1, 0);\n\t\t\t}\n\t\t}\n\n\t\tprintf(\"%d\\n\", ret);\n\t}\n\n\treturn 0;\n}"
  },
  {
    "language": "C++",
    "code": "\n#include<iostream>\nusing namespace std;\nint cards,n,i,p,q,r,x[5000],y[5000],counter;\n  int numberStart[10001];\n  int numberFast[10001];\n  int numberEnd[10001];\n  int searchB[10001];\nint numberLong(int value){\n\treturn numberEnd[value]-numberStart[value]+1;\n}\n\n\nint searchD(int seed){\n\t\tint l=0;\n  for (int a=1;a<=counter+1;a++){\n\tif(seed>l+numberLong(searchB[a])){\n\tl+=numberLong(searchB[a]);\n\t}\n\telse{\n\t return numberFast[searchB[a]];\n\t}\n  }\n return -100;\n\t\n}\nint searchNumber(int value){\n\tint l=0;\n  for (int a=1;a<=counter+1;a++){\n\tif(value>l+numberLong(searchB[a])){\n\tl+=numberLong(searchB[a]);\n\t}\n\telse{\n\t return numberStart[searchB[a]]+value-l-1;\n\t}\n  }\n return -100;\n}\n\nvoid cut(int g){\n\tif(searchD(g)==searchD(g+1)){\n  //カットする場所が入ってる数列を求める\n\tint\tsearchNumberG=searchNumber(g);\n  int seachX=searchB[searchD(g)];\n  int seachXX=searchNumberG;\n//数列ができる範囲の後ろの番号FASTを変える\n     for(int j=1;j<=counter;j++){\n      if (numberFast[j]>=numberFast[seachX]+1){\n      numberFast[j]++;\n     }\n    }\n\n  //の数列の後ろに新しい数列を作る\n counter++;\n  numberFast[counter]=numberFast[seachX]+1;\n  numberStart[counter] =searchNumberG+1;\n  numberEnd[counter]=numberEnd[seachX];\n  //できた数列の前の数列の最後を調整する\n  numberEnd[seachX]=searchNumberG;\n \n\n  \n  for ( int a=1;a<=counter+1;a++){\n\t  searchB[numberFast[a]]=a;\n    }\n    }\n\n}\nvoid shuffle(int x,int y){\n\t\n\tint StartHead[10001];\n\tint  numberFastNew[10001];\n\t\n\tint longs=1;\n\tfor (int i=1;i<=counter;i++){\n\t\tStartHead[searchB[i]]=longs;\n\t\tlongs+=numberLong(searchB[i]);\n\t}\n\tint newCounter[3];\n\tfor(int i=0;i<3;i++){\n\t\tnewCounter[i]=0;\n\t}\n\tfor(int j=1;j<=counter;j++){\n\t\tif (StartHead[j]>y){\n\t\t\tnewCounter[0]++;\n\t\tnumberFastNew[j]=0;\n\t\t}\n\t\tif (StartHead[j]>x && StartHead[j]+numberLong(j)-1<=y){\n\t\t\tnewCounter[1]++;\n\t\tnumberFastNew[j]=1;\n\t\t}\n\t\tif (StartHead[j]+numberLong(j)-1<=x){\n\t\t\tnewCounter[2]++;\n\t\tnumberFastNew[j]=2;\n\t\t}\n\t}\n\t\n\tfor(int j=1;j<=counter;j++){\n\t\tswitch(numberFastNew[j]){\n\t\t\tcase 0:\n\t\t\t\tnumberFast[j]+=-newCounter[1]-newCounter[2];\n\t\t\t\tbreak;\n\t\t\tcase 1:\n\t\t\t\tnumberFast[j]+=newCounter[0]-newCounter[2];\n\t\t\t\tbreak;\n\t\t\tcase 2:\n\t\t\t\tnumberFast[j]+=newCounter[1]+newCounter[0];\n\t\t\t\tbreak;\n\t\t}\n\n\t}\n\t  for ( int a=1;a<=counter+1;a++){\n\t  searchB[numberFast[a]]=a;\n    }\n\n}\n\n\nint main(void)\n{\n\twhile(true){\n\tcards=0;\n\tn=0;\n\tcounter=0;\n\tfor (int i=0;i<10001;i++){\n   numberStart[i]=0;\n   numberFast[i]=0;\n   numberEnd[i]=0;\n   searchB[i]=0;\n\t}\n\tint points=0;\n  counter=1;\n  cin >> cards;\n  if (cards==0){\n\t  break;\n  }\n  numberStart[1]=1;\n  numberEnd[1]=cards;\n  numberFast[1]=1;\n  searchB[1]=1;\n  cin >> n;\n  cin >> p  >> q  >> r ;\n  for (i=1;i<=n;i++){\n    cin >> x[i] >> y[i];\n  }\n  for (i=1;i<=n;i++){\n     cut(x[i]);\n\t \n      cut(y[i]);\n\t  \n     shuffle(x[i],y[i]);\n  }\n  cut(p-1);\n  cut(q-1);\n \n\n\n  for(int j=1;j<=counter;j++){\n  if( searchD(p)<= numberFast[j] && numberFast[j] <= searchD(q)){\n\t  if(numberEnd[j]<=r){\n\t  points+=numberLong(j);\n\t  }\n\t  else if(numberStart[j]<=r){\n\tpoints+=numberLong(j)-(numberEnd[j]-r);\n\t  }\n  }\n  }\n  cout << points << endl;\n\t}\n}"
  },
  {
    "language": "C++",
    "code": "\n#include<iostream>\nusing namespace std;\nint cards,n,i,p,q,r,x[5000],y[5000],counter;\n  int numberStart[10001];\n  int numberFast[10001];\n  int numberEnd[10001];\n  int searchB[10001];\nint numberLong(int value){\n\treturn numberEnd[value]-numberStart[value]+1;\n}\n\n\nint searchD(int seed){\n\t\tint l=0;\n  for (int a=1;a<=counter+1;a++){\n\tif(seed>l+numberLong(searchB[a])){\n\tl+=numberLong(searchB[a]);\n\t}\n\telse{\n\t return numberFast[searchB[a]];\n\t}\n  }\n return -100;\n\t\n}\nint searchNumber(int value){\n\tint l=0;\n  for (int a=1;a<=counter+1;a++){\n\tif(value>l+numberLong(searchB[a])){\n\tl+=numberLong(searchB[a]);\n\t}\n\telse{\n\t return numberStart[searchB[a]]+value-l-1;\n\t}\n  }\n return -100;\n}\n\nvoid cut(int g){\n\tif(searchD(g)==searchD(g+1)){\n  //カットする場所が入ってる数列を求める\n\tint\tsearchNumberG=searchNumber(g);\n  int seachX=searchB[searchD(g)];\n  int seachXX=searchNumberG;\n//数列ができる範囲の後ろの番号FASTを変える\n     for(int j=1;j<=counter;j++){\n      if (numberFast[j]>=numberFast[seachX]+1){\n      numberFast[j]++;\n     }\n    }\n\n  //の数列の後ろに新しい数列を作る\n counter++;\n  numberFast[counter]=numberFast[seachX]+1;\n  numberStart[counter] =searchNumberG+1;\n  numberEnd[counter]=numberEnd[seachX];\n  //できた数列の前の数列の最後を調整する\n  numberEnd[seachX]=searchNumberG;\n \n\n  \n  for ( int a=1;a<=counter+1;a++){\n\t  searchB[numberFast[a]]=a;\n    }\n    }\n\n}\nvoid shuffle(int x,int y){\n\t\n\tint StartHead[10001];\n\tint  numberFastNew[10001];\n\t\n\tint longs=1;\n\tfor (int i=1;i<=counter;i++){\n\t\tStartHead[searchB[i]]=longs;\n\t\tlongs+=numberLong(searchB[i]);\n\t}\n\tint newCounter[3];\n\tfor(int i=0;i<3;i++){\n\t\tnewCounter[i]=0;\n\t}\n\tfor(int j=1;j<=counter;j++){\n\t\tif (StartHead[j]>y){\n\t\t\tnewCounter[0]++;\n\t\tnumberFastNew[j]=0;\n\t\t}\n\t\tif (StartHead[j]>x && StartHead[j]+numberLong(j)-1<=y){\n\t\t\tnewCounter[1]++;\n\t\tnumberFastNew[j]=1;\n\t\t}\n\t\tif (StartHead[j]+numberLong(j)-1<=x){\n\t\t\tnewCounter[2]++;\n\t\tnumberFastNew[j]=2;\n\t\t}\n\t}\n\t\n\tfor(int j=1;j<=counter;j++){\n\t\tswitch(numberFastNew[j]){\n\t\t\tcase 0:\n\t\t\t\tnumberFast[j]+=-newCounter[1]-newCounter[2];\n\t\t\t\tbreak;\n\t\t\tcase 1:\n\t\t\t\tnumberFast[j]+=newCounter[0]-newCounter[2];\n\t\t\t\tbreak;\n\t\t\tcase 2:\n\t\t\t\tnumberFast[j]+=newCounter[1]+newCounter[0];\n\t\t\t\tbreak;\n\t\t}\n\n\t}\n\t  for ( int a=1;a<=counter+1;a++){\n\t  searchB[numberFast[a]]=a;\n    }\n\n}\n\n\nint main(void)\n{\n\twhile(true){\n\tcards=0;\n\tn=0;\n\tcounter=0;\n\tfor (int i=0;i<10001;i++){\n   numberStart[i]=0;\n   numberFast[i]=0;\n   numberEnd[i]=0;\n   searchB[i]=0;\n\t}\n\tint points=0;\n  counter=1;\n  cin >> cards;\n  if (cards==0){\n\t  break;\n  }\n  numberStart[1]=1;\n  numberEnd[1]=cards;\n  numberFast[1]=1;\n  searchB[1]=1;\n  cin >> n;\n  cin >> p  >> q  >> r ;\n  for (i=1;i<=n;i++){\n    cin >> x[i] >> y[i];\n  }\n  for (i=1;i<=n;i++){\n     cut(x[i]);\n\t \n      cut(y[i]);\n\t  \n     shuffle(x[i],y[i]);\n  }\n\n  cout << points << endl;\n\t}\n}"
  },
  {
    "language": "C++",
    "code": "#define _USE_MATH_DEFINES\n#define INF 0x3f3f3f3f\n\n#include <iostream>\n#include <cstdio>\n#include <sstream>\n#include <cmath>\n#include <cstdlib>\n#include <algorithm>\n#include <queue>\n#include <stack>\n#include <limits>\n#include <map>\n#include <string>\n#include <cstring>\n#include <set>\n#include <deque>\n#include <bitset>\n#include <list>\n#include <cctype>\n#include <utility>\n  \nusing namespace std;\n  \ntypedef long long ll;\ntypedef pair <int,int> P;\ntypedef pair <int,P> PP;\n  \nstatic const double EPS = 1e-8;\n  \nstatic const int tx[] = {0,1,0,-1};\nstatic const int ty[] = {-1,0,1,0};\n\nint main(){\n  int total_cards;\n  while(~scanf(\"%d\",&total_cards)){\n    if(total_cards == 0) break;\n    int total_shuffles;\n    int first,last,upper;\n\n    scanf(\"%d\",&total_shuffles);\n    scanf(\"%d %d %d\",&first,&last,&upper);\n    \n    vector<P> cards;\n    cards.push_back(P(1,total_cards));\n\n    for(int shuffle_idx=0;shuffle_idx<total_shuffles;shuffle_idx++){\n      int x,y;\n      scanf(\"%d %d\",&x,&y);\n      //x -> none\n      //y -> 1\n      //n -> x+1\n      //C -> B -> A\n      vector<P> A;\n      vector<P> B;\n      vector<P> C;\n      vector<P> next;\n\n      int sum = 0;\n      int prev_sum = 0;\n      for(int j=0;j<cards.size();j++){\n        prev_sum = sum;\n        sum += cards[j].second - cards[j].first + 1;\n        if(prev_sum < x){\n          if(sum <= x){\n            A.push_back(cards[j]);\n          }\n          else if(sum > x && sum <= y){\n            A.push_back(P(cards[j].first,cards[j].first + (x - prev_sum - 1)));\n            B.push_back(P(cards[j].first + (x - prev_sum),\n                          cards[j].second));\n          }\n          else if(sum > y){\n            A.push_back(P(cards[j].first,cards[j].first + (x - prev_sum - 1)));\n            B.push_back(P(cards[j].first + (x - prev_sum),\n                          cards[j].first + (x - prev_sum) + (y - x - 1)));\n            C.push_back(P(cards[j].first + (x - prev_sum) + (y - x),\n                          cards[j].second));\n          }\n        }\n        else if(prev_sum >= x){\n          if(prev_sum < y){\n            if(sum <= y){\n              B.push_back(P(cards[j].first,cards[j].second));\n            }\n            else if(sum > y){\n              B.push_back(P(cards[j].first,cards[j].first + (y - prev_sum - 1)));\n              C.push_back(P(cards[j].first + (y - prev_sum),cards[j].second));\n            }\n          }\n          else if(prev_sum >= y){\n            C.push_back(P(cards[j].first,cards[j].second));\n          }\n        }\n      }\n      for(int i=0;i<C.size();i++){\n        next.push_back(C[i]);\n        // cout << \"C<f,s>=\" << C[i].first << \",\" << C[i].second << endl;\n      }\n      for(int i=0;i<B.size();i++){\n        next.push_back(B[i]);\n        // cout << \"B<f,s>=\" << B[i].first << \",\" << B[i].second << endl;\n      }\n      for(int i=0;i<A.size();i++){\n        next.push_back(A[i]);\n        // cout << \"A<f,s>=\" << A[i].first << \",\" << A[i].second << endl;\n      }\n      // cout << endl;\n      cards = next;\n    }\n\n    int offset = 0;\n    int res = 0;\n    for(int i=0;i<cards.size();i++){\n      int current = cards[i].second - cards[i].first + 1;\n      if(offset + current < first) continue;\n      if(offset >= last) continue;\n\n      int lhs = 0;\n      int rhs = 1000000000;\n\n      for(int round = 0; round < 50; round++){\n        int mid = (lhs + rhs) / 2;\n        if(cards[i].first + mid > upper){\n          rhs = mid;\n        }\n        if(cards[i].first + mid <= upper){\n          lhs = mid;\n        }\n      }\n\n      lhs = min(lhs + 1,cards[i].second - cards[i].first + 1);\n      if(offset + lhs > last){\n        lhs = last - offset - 1;\n      }\n      res += lhs;\n\n      // cout << \"offset \" << offset << endl;\n      // cout << \"<f,s>=\" << cards[i].first << \",\" << cards[i].second << endl;\n      // cout << \"lhs=\" << lhs << endl;\n\n      offset += current;\n    }\n    printf(\"%d\\n\",res);\n\n  }\n}"
  },
  {
    "language": "C++",
    "code": "#include<vector>\n#include<list>\n#include<algorithm>\n#include<iostream>\n#include<string>\n#include<cstdio>\n#include<cstdlib>\n#include<cstring>\n#include<cmath>\nusing namespace std;\nlist<int> a,b,c;\nint main(){\n  int h,i;\n  int m,n,p,q,r,x,y;\n  int ct;\n  list<int>::iterator it,jt,kt,lt;\n  while(cin>>n&&n){\n    cin>>m>>p>>q>>r;\n    a.clear();\n    a.push_back(1);\n    a.push_back(n);\n    for(h=0;h<m;h++){\n      cin>>x>>y;\n      it=jt=a.begin();\n      jt++;\n      for(i=0;i<x;){\n\tif(i+*jt-*it+1>x){\n\t  it=jt=kt=a.insert(a.insert(jt,*it+x-i),*it+x-i-1);\n\t  it++;\n\t  advance(jt,2);\n\t  kt++;\n\t  i=x;\n\t}else if(i+*jt-*it+1<x){\n\t  i+=*jt-*it+1;\n\t  advance(it,2);\n\t  advance(jt,2);\n\t}else if(i+*jt-*it+1==x){\n\t  advance(it,2);\n\t  advance(jt,2);\n\t  kt=it;\n\t  i=x;\n\t}\n      }\n      for(;i<y;){\n\tif(i+*jt-*it+1>y){\n\t  lt=a.insert(a.insert(jt,*it+y-i),*it+y-i-1);\n\t  lt++;\n\t  i=y;\n\t}else if(i+*jt-*it+1<y){\n\t  i+=*jt-*it+1;\n\t  advance(it,2);\n\t  advance(jt,2);\n\t}else if(i+*jt-*it+1==y){\n\t  lt=it;\n\t  advance(lt,2);\n\t  i=y;\n\t}\n      }\n      b.assign(a.begin(),kt);\n      c.assign(kt,lt);\n      a.erase(a.begin(),lt);\n      a.splice(a.end(),c);\n      a.splice(a.end(),b);\n    }\n    it=jt=a.begin();\n    jt++;\n    ct=0;\n    for(i=0;i<p;){\n      if(i+*jt-*it+1>=p){\n\tif(*it+p-i-1<=r&&r<=*jt)\n\t  ct+=r-*it-p+i+2;\n\telse if(*jt<r)\n\t  ct+=*jt-*it-p+i+2;\n\ti=p;\n\tadvance(it,2);\n\tadvance(jt,2);\n      }else{\n\ti+=*jt-*it+1;\n\tadvance(it,2);\n\tadvance(jt,2);\n      }\n    }\n    for(;i<q;){\n      if(i+*jt-*it+1>=q){\n\tif(*it<=r&&r<=*it+q-i-1)\n\t  ct+=r-*it+1;\n\telse if(*it+q-i-1<r)\n\t  ct+=q-i-1;\n\ti=q;\n      }else{\n\tif(*it<=r&&r<=*jt)\n\t  ct+=r-*it+1;\n\telse if(*jt<r)\n\t  ct+=*jt-*it+1;\n\ti+=*jt-*it+1;\n\tadvance(it,2);\n\tadvance(jt,2);\n      }\n    }\n    cout<<ct<<endl;\n  }\n  return 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include<iostream>\n#include<vector>\n#include<algorithm>\nusing namespace std;\nvector<pair<int, int>>vec;\nint n, m, l, r, p;\nint main() {\n\twhile (true) {\n\t\tcin >> n; if (n == 0)break;\n\t\tcin >> m >> l >> r >> p; vec.clear();\n\t\tvec.push_back(make_pair(1, n));\n\t\tfor (int i = 0; i < m; i++) {\n\t\t\tint r1, r2; cin >> r1 >> r2;\n\t\t\tvector<pair<int, int>>A, B, C; int sum1 = 0, c = 0;\n\t\t\tfor (int j = 0; j < vec.size(); j++) {\n\t\t\t\tsum1 += (vec[j].second - vec[j].first + 1);\n\t\t\t\tbool H = false;\n\t\t\t\tif (sum1 > r2 && c == 0) {\n\t\t\t\t\tint Border1 = vec[j].second - (sum1 - r1);\n\t\t\t\t\tint Border2 = vec[j].second - (sum1 - r2);\n\t\t\t\t\tA.push_back(make_pair(vec[j].first, Border1));\n\t\t\t\t\tB.push_back(make_pair(Border1 + 1, Border2));\n\t\t\t\t\tC.push_back(make_pair(Border2 + 1, vec[j].second));\n\t\t\t\t\tc = 2; H = true;\n\t\t\t\t}\n\t\t\t\tif (sum1 > r1 && c == 0) {\n\t\t\t\t\tint Border = vec[j].second - (sum1 - r1);\n\t\t\t\t\tA.push_back(make_pair(vec[j].first, Border));\n\t\t\t\t\tB.push_back(make_pair(Border + 1, vec[j].second));\n\t\t\t\t\tc = 1; H = true;\n\t\t\t\t}\n\t\t\t\tif (sum1 > r2 && c == 1 && H == false) {\n\t\t\t\t\tint Border = vec[j].second - (sum1 - r2);\n\t\t\t\t\tB.push_back(make_pair(vec[j].first, Border));\n\t\t\t\t\tC.push_back(make_pair(Border + 1, vec[j].second));\n\t\t\t\t\tc = 2; H = true;\n\t\t\t\t}\n\t\t\t\tif (H == false) {\n\t\t\t\t\tif (c == 0) { A.push_back(make_pair(vec[j].first, vec[j].second)); }\n\t\t\t\t\tif (c == 1) { B.push_back(make_pair(vec[j].first, vec[j].second)); }\n\t\t\t\t\tif (c == 2) { C.push_back(make_pair(vec[j].first, vec[j].second)); }\n\t\t\t\t}\n\t\t\t}\n\t\t\tvec.clear();\n\t\t\tfor (int i = 0; i < C.size(); i++) { if (C[i].first <= C[i].second) vec.push_back(C[i]); }\n\t\t\tfor (int i = 0; i < B.size(); i++) { if (B[i].first <= B[i].second)vec.push_back(B[i]); }\n\t\t\tfor (int i = 0; i < A.size(); i++) { if (A[i].first <= A[i].second)vec.push_back(A[i]); }\n\t\t}\n\t\tint sum2 = 0, sum3 = 0;\n\t\tfor (int i = 0; i < vec.size(); i++) {\n\t\t\tif (vec[i].first > vec[i].second)continue;\n\t\t\tint HB = (vec[i].second - vec[i].first + 1); sum2 += HB;\n\t\t\tint L1 = vec[i].first, R1 = vec[i].second;\n\t\t\tint L2 = 1, R2 = p;\n\t\t\tif (sum2 > r && sum2 - HB <= r) { R1 = vec[i].first + (r - (sum2 - HB)) - 1; }\n\t\t\tif (sum2 - HB < l && sum2 >= l) { L1 = vec[i].first + (l - (sum2 - HB)) - 1; }\n\t\t\tif (sum2 - HB > r)continue;\n\t\t\tif (sum2 < l)continue;\n\n\t\t\tint L3 = max(L1, L2), R3 = min(R1, R2);\n\t\t\tsum3 += max(0, R3 - L3 + 1);\n\t\t}\n\t\tcout << sum3 << endl;\n\t}\n\treturn 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include <iostream>\n#include <algorithm>\n#include <vector>\nusing namespace std;\nint main(){\n\tint n,m,p,q,r,x,y;\n\tvector<int>::iterator itx,ity,it;\n\tfor(;cin>>n>>m>>p>>q>>r;cout<<x<<endl){\n\t\tvector<int> v1,v2;\n\t\tv1.push_back(0);\n\t\tv1.push_back(r);\n\t\t\n\t\tfor(;m--;v2.clear()){\n\t\t\tcin>>x>>y;\n\t\t\titx=upper_bound(v1.begin(),v1.end(),x);\n\t\t\tity=upper_bound(v1.begin(),v1.end(),y);\n\t\t\t\n\t\t\tif( ity-v1.begin()+1 & 1 )v2.push_back(0);\n\t\t\tv2.push_back(0);\n\t\t\tfor(it=ity;it!=v1.end();++it)\n\t\t\t\tv2.push_back(*it - y);\n\t\t\t\n\t\t\tif(v1.end()-itx & 1)v2.push_back(n-y);\n\t\t\tfor(it=itx;it!=ity;++it)\n\t\t\t\tv2.push_back(*it-x+n-y);\n\t\t\t\n\t\t\tit = v1.begin();\n\t\t\tif(ity-v1.begin() & 1)++it;\n\t\t\tif(!it[1])it+=2;\t//d¡r\n\t\t\tif(*it+n-x==v2.back()){++it;v2.pop_back();}\t//d¡r\n\t\t\tfor(;it!=itx;++it)\n\t\t\t\tv2.push_back(*it+n-x);\n\t\t\t\n\t\t\tv1.swap(v2);\n\t\t}\n\t\tv1.insert( upper_bound(v1.begin(),v1.end(),p-1), 2, p-1);\n\t\tv1.insert( lower_bound(v1.begin(),v1.end(),q), q );\n\t\tv1.push_back(n);\n\t\tit = upper_bound(v1.begin(),v1.end(),p-1);\n\t\tif(it-v1.begin() & 1) --it;\n\t\tfor(x=0;*it<q;++it){\n\t\t\tm=*it;\n\t\t\t++it;\n\t\t\tx+=*it-m;\n\t\t}\n\t}\n}"
  },
  {
    "language": "C++",
    "code": "#include <stdio.h>\n#include <iostream>\n\nusing namespace std;\n\npair<int,int> d[11111];\nint k;\n\npair<int,int> a[11111];\nint ak;\npair<int,int> b[11111];\nint bk;\npair<int,int> c[11111];\nint ck;\n\nint main()\n{\n\twhile(1)\n\t{\n\t\tint n,m,p,q,r;\n\t\tscanf(\"%d\",&n);\n\t\tif(n == 0)\n\t\t{\n\t\t\tbreak;\n\t\t}\n\t\tscanf(\"%d%d%d%d\",&m,&p,&q,&r);\n\t\tk = 1;\n\t\td[0] = make_pair(1,n);\n\t\tfor(int j = 0; j < m; j++)\n\t\t{\n\t\t\tint x,y;\n\t\t\tscanf(\"%d%d\",&x,&y);\n\t\t\tint nk = 0;\n\t\t\tak = 0;\n\t\t\tint ne;\n\t\t\tfor(int i = 0; i < k; i++)\n\t\t\t{\n\t\t\t\tnk += d[i].second - d[i].first + 1;\n\t\t\t\ta[ak] = d[i];\n\t\t\t\tak++;\n\t\t\t\tif(nk >= x)\n\t\t\t\t{\n\t\t\t\t\tif(nk == x)\n\t\t\t\t\t{\n\t\t\t\t\t\tne = i + 1;\n\t\t\t\t\t}\n\t\t\t\t\telse\n\t\t\t\t\t{\n\t\t\t\t\t\ta[ak - 1].second -= nk - x;\n\t\t\t\t\t\td[i].first = a[ak - 1].second + 1;\n\t\t\t\t\t\tne = i;\n\t\t\t\t\t}\n\t\t\t\t\tnk = x;\n\t\t\t\t\tbreak;\n\t\t\t\t}\n\t\t\t}\n\t\t\tbk = 0;\n\t\t\tfor(int i = ne; i < k; i++)\n\t\t\t{\n\t\t\t\tnk += d[i].second - d[i].first + 1;\n\t\t\t\tb[bk] = d[i];\n\t\t\t\tbk++;\n\t\t\t\tif(nk >= y)\n\t\t\t\t{\n\t\t\t\t\tif(nk == y)\n\t\t\t\t\t{\n\t\t\t\t\t\tne = i + 1;\n\t\t\t\t\t}\n\t\t\t\t\telse\n\t\t\t\t\t{\n\t\t\t\t\t\tb[bk - 1].second -= nk - y;\n\t\t\t\t\t\td[i].first = b[bk - 1].second + 1;\n\t\t\t\t\t\tne = i;\n\t\t\t\t\t}\n\t\t\t\t\tnk = y;\n\t\t\t\t\tbreak;\n\t\t\t\t}\n\t\t\t}\n\t\t\tck = 0;\n\t\t\tfor(int i = ne; i < k; i++)\n\t\t\t{\n\t\t\t\tc[ck] = d[i];\n\t\t\t\tck++;\n\t\t\t}\n\t\t\tk = 0;\n\t\t\tfor(int i = 0; i < ck; i++)\n\t\t\t{\n\t\t\t\td[k] = c[i];\n\t\t\t\tk++;\n\t\t\t}\n\t\t\tfor(int i = 0; i < bk; i++)\n\t\t\t{\n\t\t\t\td[k] = b[i];\n\t\t\t\tk++;\n\t\t\t}\n\t\t\tfor(int i = 0; i < ak; i++)\n\t\t\t{\n\t\t\t\td[k] = a[i];\n\t\t\t\tk++;\n\t\t\t}\n\t\t}\n\t\tint now = 0;\n\t\tint all = 0;\n\t\tfor(int i = 0; i < k; i++)\n\t\t{\n\t\t\tnow++;\n\t\t\tint nex = now + d[i].second - d[i].first;\n\t\t\tif(now > q)\n\t\t\t{\n\t\t\t\tbreak;\n\t\t\t}\n\t\t\tif(p <= now && nex <= q)\n\t\t\t{\n\t\t\t\tif(d[i].second <= r)\n\t\t\t\t{\n\t\t\t\t\tall += d[i].second - d[i].first + 1;\n\t\t\t\t}\n\t\t\t\telse if(d[i].first <= r)\n\t\t\t\t{\n\t\t\t\t\tall += r - d[i].first + 1;\n\t\t\t\t}\n\t\t\t}\n\t\t\telse if(p <= now && now <= q)\n\t\t\t{\n\t\t\t\td[i].second -= nex - q;\n\t\t\t\tif(d[i].second <= r)\n\t\t\t\t{\n\t\t\t\t\tall += d[i].second - d[i].first + 1;\n\t\t\t\t}\n\t\t\t\telse if(d[i].first <= r)\n\t\t\t\t{\n\t\t\t\t\tall += r - d[i].first + 1;\n\t\t\t\t}\n\t\t\t}\n\t\t\telse if(p <= nex && nex <= q)\n\t\t\t{\n\t\t\t\td[i].first += p - now;\n\t\t\t\tif(d[i].second <= r)\n\t\t\t\t{\n\t\t\t\t\tall += d[i].second - d[i].first + 1;\n\t\t\t\t}\n\t\t\t\telse if(d[i].first <= r)\n\t\t\t\t{\n\t\t\t\t\tall += r - d[i].first + 1;\n\t\t\t\t}\n\t\t\t}\n\t\t\tnow = nex;\n\t\t}\n\t\tprintf(\"%d\\n\",all);\n\t}\n\treturn 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include <iostream>\n#include <set>\n#include <algorithm>\n#include <utility>\nusing namespace std;\ntypedef pair<int,int> P;\ntypedef set<P > Sep;\n\nint ary[2][5010];\nint main(){\n\tint N,M,PP,Q,R,in,ou,ln,rn,al;\n\tSep::iterator le,ri,ite,ite2;\n\tSep se[2];\n\twhile(true){\n\t\tcin>>N;\n\t\tif(N==0) break;\n\t\tcin>>M>>PP>>Q>>R;\n\t\tfor(int i=0;i<M;i++){\n\t\t\tcin>>ary[0][i]>>ary[1][i];\n\t\t\tary[0][i]++;\n\t\t\tary[1][i]++;\n\t\t}\n\n\t\tse[0].clear();\n\t\tse[0].insert(P(1,1));\n\t\tin=0;ou=1;\n\t\tfor(int i=0;i<M;i++){\n\t\t\tse[ou].clear();\n\t\t\tle=lower_bound(se[in].begin(),se[in].end(),P(ary[0][i],0));\n\t\t\tri=lower_bound(se[in].begin(),se[in].end(),P(ary[1][i],0));\n\t\t\tif(le==se[in].end()||le->first>ary[0][i]){\n\t\t\t\tle--;\n\t\t\t\tse[in].insert(P(ary[0][i],le->second+ary[0][i]-le->first));\n\t\t\t\tle++;\n\t\t\t}\n\t\t\tif(ri==se[in].end()||ri->first>ary[1][i]){\n\t\t\t\tri--;\n\t\t\t\tse[in].insert(P(ary[1][i],ri->second+ary[1][i]-ri->first));\n\t\t\t\tri++;\n\t\t\t}\n\t\t\tln=le->first-se[in].begin()->first;\n\t\t\trn=ri->first-se[in].begin()->first;\n\n\t\t\tfor(ite=se[in].begin();ite!=le;ite++){\n\t\t\t\tse[ou].insert(P(ite->first+(N-ln),ite->second));\n\t\t\t}\n\t\t\tfor(ite=le;ite!=ri;ite++){\n\t\t\t\tse[ou].insert(P(ite->first+(N-rn-ln),ite->second));\n\t\t\t}\n\t\t\tfor(ite=ri;ite!=se[in].end();ite++){\n\t\t\t\tse[ou].insert(P(ite->first-rn,ite->second));\n\t\t\t}\n\t\t\tswap(ou,in);\n\t\t}\n\n\t\tle=lower_bound(se[in].begin(),se[in].end(),P(PP,0));\n\t\tri=lower_bound(se[in].begin(),se[in].end(),P(Q,0));\n\t\tif(le->first>PP){\n\t\t\tle--;\n\t\t\tse[in].insert(P(PP,le->second+PP-le->first));\n\t\t\tle++;\n\t\t}\n\t\tif(ri->first>Q){\n\t\t\tri--;\n\t\t\tse[in].insert(P(Q,ri->second+Q-ri->first));\n\t\t\tri++;\n\t\t}\n\t\tint res=0,las=0,dis=0,lasn=1;\n\t\tse[in].insert(P(N+1,N+1));\n\t\tbool fla=false;\n\t\tite2=ri;\n\t\tite2++;\n\t\tfor(ite=le;ite!=ite2;ite++){\n\t\t\tif(fla){\n\t\t\t\tdis=ite->first-lasn;\n\t\t\t}\n\t\t\telse{\n\t\t\t\tfla=true;\n\t\t\t}\n\t\t\tif(las<=R){\n\t\t\t\tres+=min(dis,R-las+1);\n\t\t\t}\n\t\t\tlas=ite->second;\n\t\t\tlasn=ite->first;\n\t\t}\n\t\tif(ri->second<=R) res++;\n\t\tcout<<res<<endl;\n\t}\n\treturn 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\nusing namespace std;\n\nusing P = pair<int,int>;\n\nbool solve(){\n    int n, m, p, q, r;\n    cin >> n;\n    if(n==0) return false;\n    cin >> m >> p >> q >> r;\n    vector<P> v = {P(0,r)}, tmp;  // [a,b)\n    for(int i=0;i<m;i++){\n        int x, y;\n        cin >> x >> y;\n        tmp.clear();\n        for(auto &e : v){\n            int a = e.first, b = e.second;\n            if(b <= x){\n                int d = n-x;\n                tmp.emplace_back(P(a+d,b+d));\n            }else if(a >= y){\n                tmp.emplace_back(P(a-y,b-y));\n            }else{\n                if(a < x) tmp.emplace_back(P(a+n-x,n));\n                tmp.emplace_back(P(max(a,x)-x+n-y,min(b,y)-x+n-y));\n                if(b > y) tmp.emplace_back(P(0,b-y));\n            }\n        }\n        v = tmp;\n    }\n    int ans = 0;\n    p--;\n    for(auto &e : v){\n        int a = e.first, b = e.second;\n        ans += max(min(q,b)-max(p,a),0);\n    }\n    cout << ans << endl;\n    return true;\n}\n\nint main(){\n    while(solve());\n    return 0;\n}\n\n"
  },
  {
    "language": "C++",
    "code": "#include<iostream>\n#include<cstdio>\n#include<vector>\n#include<queue>\n#include<algorithm>\n#include<functional>\n#include<cstring>\n#define MAX_N 100000\n#define F first\n#define S second \n#define MP make_pair\nusing namespace std;\ntypedef pair<int, int> P;\n \nconst int INF = 1e9;\n \nint main() {\n    int n, m, pp, q, r;\n \n    while (cin >> n&&n){  \n        int save = -1, ans = 0;\n        vector<P>vep, vep2, vep3;\n        vep.push_back(MP(1, 1));\n        vep.push_back(MP(n, n));\n        vector<int> vec, vec2, vec3;\n        vec.push_back(1);\n        vec.push_back(n);\n        cin >> m >> pp >> q >> r;\n        for (int i = 0; i < m; i++) {\n            int x, y, p, p2;\n            scanf(\"%d%d\", &x, &y);\n            p = lower_bound(vec.begin(), vec.end(), x) - vec.begin();\n            if (vec[p] != x) {\n                vec.insert(vec.begin() + p, x);\n                P a = MP(vec[p] - vec[p - 1] + vep[p - 1].F, x);\n                vep.insert(vep.begin() + p, a);\n            }\n            if (vep[p].S + 1 != vep[p + 1].S) {\n                vec.insert(vec.begin() + p + 1, x + 1);\n                P a = MP(vep[p].F + 1, x + 1);\n                vep.insert(vep.begin() + p + 1, a);\n            }\n            p2 = lower_bound(vec.begin(), vec.end(), y) - vec.begin();\n            if (vec[p2] != y) {\n                vec.insert(vec.begin() + p2, y);\n                P a = MP(vec[p2] - vec[p2 - 1] + vep[p2 - 1].F, y);\n                vep.insert(vep.begin() + p2, a);\n            }\n            if (vep[p2].S + 1 != vep[p2 + 1].S) {\n                vec.insert(vec.begin() + p2 + 1, y + 1);\n                P a = MP(vep[p2].F + 1, y + 1);\n                vep.insert(vep.begin() + p2 + 1, a);\n            }\n            for (int j = p2 + 1; j < vec.size(); j++) {\n                vec2.push_back(vec[j] - vec[p2 + 1] + 1);\n                vep2.push_back(MP(vep[j].F, vec[j] - vec[p2 + 1] + 1));\n            }\n            int size = vec2[vec2.size() - 1];\n            for (int j = p + 1; j < p2 + 1; j++) {\n                vec2.push_back(vec[j] - vec[p + 1] + 1 + size);\n                vep2.push_back(MP(vep[j].F, vec[j] - vec[p + 1] + 1 + size));\n            }\n            size = vec2[vec2.size() - 1];\n            for (int j = 0; j < p + 1; j++) {\n                vec2.push_back(vec[j] - vec[0] + 1+size);\n                vep2.push_back(MP(vep[j].F, vec[j] - vec[0] + 1+size));\n            }\n            vec3 = vec;\n            vep3 = vep;\n            vec = vec2;\n            vep = vep2;\n            vec2 = vec3;\n            vep2 = vep3;\n            vec2.clear();\n            vep2.clear();\n        }\n        int p, p2;\n        p = lower_bound(vec.begin(), vec.end(), pp) - vec.begin();\n         \n        if (vec[p] != pp) {\n            vec.insert(vec.begin() + p, pp);\n            P a = MP(vec[p] - vec[p - 1] + vep[p-1].F, pp);\n            vep.insert(vep.begin() + p, a);\n        }\n        if (vep[p].S + 1 != vep[p + 1].S) {\n            vec.insert(vec.begin() + p + 1, pp + 1);\n            P a = MP(vep[p].F + 1, pp + 1);\n            vep.insert(vep.begin() + p + 1, a);\n        }\n        p2 = lower_bound(vec.begin(), vec.end(), q) - vec.begin();\n        if (vec[p2] != q) {\n            vec.insert(vec.begin() + p2, q);\n            P a = MP(vec[p2] - vec[p2 - 1] + vep[p2-1].F, q);\n            vep.insert(vep.begin() + p2, a);\n        }\n        if (vep[p2].S + 1 != vep[p2 + 1].S) {\n            vec.insert(vec.begin() + p2 + 1, q + 1);\n            P a = MP(vep[p2].F + 1, q + 1);\n            vep.insert(vep.begin() + p2 + 1, a);\n        }\n        for (int i = p; i <= p2; i++) {\n            if (i + 1<=p2 && vep[i + 1].F - vep[i].F == vep[i + 1].S - vep[i].S) {\n                for (int j = vep[i].F; j <= vep[i + 1].F; j++) {\n                    if (j <= r&&save!=j) {\n                        ans++;\n                        save = j;\n                    }\n                }\n            }\n            else{\n                if (vep[i].F <= r&&save != vep[i].F) {\n                    ans++;\n                    save = vep[i].F;\n                }\n            }\n    }\n        cout << ans << endl;\n    }\n}"
  },
  {
    "language": "C++",
    "code": "#include <iostream>\n#include <algorithm>\n#include <vector>\nusing namespace std;\n\nint c1[5010],c2[5010],vv[5010];\nint main(){\n\tint N,M,P,Q,R,ac1,ac2,cnt;\n\twhile(1){\n\t\tcin>>N;\n\t\tif(N==0) break;\n\t\tcin>>M>>P>>Q>>R;\n\t\tfor(int i=0;i<M;i++){\n\t\t\tcin>>ac1>>ac2;\n\t\t\tc1[i]=ac1;\n\t\t\tc2[i]=ac2;\n\t\t}\n\t\tfor(int i=1;i<=N;i++) vv[i]=i;\n\t\t\n\t\tfor(int i=0;i<M;i++){\n\t\t\treverse(vv+1,vv+c1[i]+1);\n\t\t\treverse(vv+c1[i]+1,vv+c2[i]+1);\n\t\t\treverse(vv+c2[i]+1,vv+N+1);\n\t\t\treverse(vv+1,vv+N+1);\n\t\t}\n\t\tcnt=0;\n\t\t//for(int i=1;i<=N;i++){//\n\t\t//\tcout<<vv[i]<<\" \";//\n\t\t//}//\n\t\t//cout<<endl;//\n\t\tfor(int i=P;i<=Q;i++){\n\t\t\tif(vv[i]<=R) cnt++;\n\t\t}\n\t\tcout<<cnt<<endl;\n\t}\n\treturn 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include<bits/stdc++.h>\nusing namespace std;\n\nclass Bundle {\npublic:\n  Bundle(int t, int b) : top_(t), bottom_(b) {}\n  int top() const {return top_;}\n  int bottom() const {return bottom_;}\n  int size() const {return bottom() - top() + 1;}\n  int count(int r) const {\n    if(r < top()) return 0;\n    if(bottom() <= r) return size();\n    return r - top() + 1;\n  }\n  Bundle split(int i) {\n    Bundle res(i, bottom());\n    bottom_ = i - 1;\n    return res;\n  }\nprivate:\n  int top_, bottom_;\n};\n\nint main() {\n  int n;\n  while(cin >> n, n) {\n    int m;\n    cin >> m;\n    int p, q, r;\n    cin >> p >> q >> r;\n\n    vector<Bundle> bundle;\n    bundle.emplace_back(1, n);\n\n    for(int k = 0; k < m; ++k) {\n      int x, y;\n      cin >> x >> y;\n      int cnt = 0;\n      for(int i = 0; i < bundle.size(); ++i) {\n        cnt += bundle[i].size();\n        if(cnt < x - 1) continue;\n        if(cnt != x - 1) bundle.insert(begin(bundle) + i + 1, bundle[i].split(bundle[i].top() + bundle[i].size() - (cnt - x + 1)));\n        cnt = x - 1;\n        ++i;\n        for(int j = i; j < bundle.size(); ++j) {\n          cnt += bundle[j].size();\n          if(cnt < y) continue;\n          if(cnt != y) bundle.insert(begin(bundle) + j + 1, bundle[j].split(bundle[j].top() + bundle[j].size() - (cnt - y)));\n          auto A = vector<Bundle>(begin(bundle), begin(bundle) + i);\n          auto B = vector<Bundle>(begin(bundle) + i, begin(bundle) + j + 1);\n          auto C = vector<Bundle>(begin(bundle) + j + 1, end(bundle));\n          bundle = A;\n          bundle.insert(begin(bundle), begin(B), end(B));\n          bundle.insert(begin(bundle), begin(C), end(C));\n          break;\n        }\n        break;\n      }\n    }\n\n    int answer = 0;\n    int cnt = 0;\n    for(int i = 0; i < bundle.size(); ++i) {\n      cnt += bundle[i].size();\n      if(cnt < p - 1) continue;\n      if(cnt != p - 1) bundle.insert(begin(bundle) + i + 1, bundle[i].split(bundle[i].top() + bundle[i].size() - (cnt - p + 1)));\n      cnt = p - 1;\n      ++i;\n      for(int j = i; j < bundle.size(); ++j) {\n        cnt += bundle[j].size();\n        if(cnt < q) continue;\n        if(cnt != q) bundle.insert(begin(bundle) + j + 1, bundle[j].split(bundle[j].top() + bundle[j].size() - (cnt - q)));\n        for(int k = i; k <= j; ++k) answer += bundle[k].count(r);\n        break;\n      }\n      break;\n    }\n    cout << answer << endl;\n  }\n}"
  },
  {
    "language": "C++",
    "code": "//こんな問題予選に出たら解きたくないわ〜\n\n\n\n\n\n#include <cstdio>\n#include <deque>\nusing namespace std;\n\nint main(){\n\nwhile(1){\n\tint n,m,p,q,r;\n\tdeque<pair<int,int> > d;\n\t\n\tscanf(\"%d\",&n);\n\t\n\tif(n == 0) break;\n\t\n\tscanf(\"%d%d%d%d\",&m,&p,&q,&r);\n\t\n\t\n\td.push_back(make_pair(1,n));\n\t\n\tfor(int i = 0;i < m;i++){\n\t\tint x,y,g = 0;\n\t\tscanf(\"%d%d\",&x,&y);\n\t\t\n\t\tdeque<pair<int,int> > a,b;\n\t\t\n\t\twhile(1){\n\t\t\tpair<int,int> nau = d.front(); d.pop_front();\n\t\t\tg += nau.second - nau.first + 1;\n\n\t\t\t\n\t\t\tif(g == x){\n\t\t\t\ta.push_back(nau);\n\t\t\t\tbreak;\n\t\t\t}else if(g < x){\n\t\t\t\ta.push_back(nau);\n\t\t\t}else{\n\t\t\t\ta.push_back(make_pair(nau.first,nau.second-(g-x)));\n\t\t\t\td.push_front(make_pair(nau.second-(g-x)+1,nau.second));\n\t\t\t\tbreak;\n\t\t\t}\n\t\t}\n\t\tg = x;\n\t\twhile(1){\n\t\t\tpair<int,int> nau = d.front(); d.pop_front();\n\t\t\t\n\t\t\tg += nau.second - nau.first + 1;\n\t\t\t\n\t\t\tif(g == y){\n\t\t\t\tb.push_back(nau);\n\t\t\t\tbreak;\n\t\t\t}else if(g < y){\n\t\t\t\tb.push_back(nau);\n\t\t\t}else{\n\t\t\t\tb.push_back(make_pair(nau.first,nau.second-(g-y)));\n\t\t\t\td.push_front(make_pair(nau.second-(g-y)+1,nau.second));\n\t\t\t\tbreak;\n\t\t\t}\n\t\t}\n\t\t\n\t\tfor(int i = 0;i < b.size();i++) d.push_back(b[i]);\n\t\tfor(int i = 0;i < a.size();i++) d.push_back(a[i]);\n\t\t\n\t}\n\t\n\tint g = 0,pre = 0;\n\tint ans = 0;\n\twhile(1){\n\t\tif(pre > q || d.empty()) break;\n\t\tpair<int,int> nau = d.front(); d.pop_front();\n\t\tg += nau.second - nau.first + 1;\n\t\t\n\t\tif(g < p){\n\t\t\tpre = g + 1;\n\t\t\tcontinue;\n\t\t}\n\t\tint st=nau.first,fi=nau.second;\t\n\t\t\n\t\tif(pre < p) st += p - pre;\n\t\t\n\t\tif(g > q) fi -= (g - q);\n\t\t\n\t\tpre = g + 1;\n\t\t\n\t\tif(st > r)continue;\n\t\t\n\t\tif(fi <= r){\n\t\t\tans += fi - st + 1;\n\t\t}else{\n\t\t\tans += r - st + 1;\n\t\t}\n\t}\n\t\n\tprintf(\"%d\\n\",ans);\n\t\n\t}\t\n\treturn 0;\n\t\n}\t\n"
  },
  {
    "language": "C++",
    "code": "#include<iostream>\nusing namespace std;\nlong long int main() {\n\tlong long int size;\n\tlong long int *card;\n\tlong long int *dommy;\n\tlong long int search[3];\n\tlong long int shuffle[2];\n\tlong long int time;\n\twhile (cin >> size&&size) {\n\t\tcard = new long long int[size];\n\t\tfor (long long int i = 0; i < size; ++i) {\n\t\t\tcard[i] = i + 1;\n\t\t}\n\t\tcin >> time;\n\t\tfor (long long int i = 0; i < 3; ++i) {\n\t\t\tcin >> search[i];\n\t\t}\n\t\tfor (long long int i = 0; i < time; ++i) {\n\t\t\tfor (long long int j = 0; j < 2; ++j) {\n\t\t\t\tcin>>shuffle[j];\n\t\t\t}\n\t\t\tdommy = new long long int[size];\n\t\t\tfor (long long int j = shuffle[1]; j < size; ++j) {\n\t\t\t\tdommy[j - shuffle[1]] = card[j];\n\t\t\t}\n\t\t\tfor (long long int j = shuffle[0]; j < shuffle[1]; ++j) {\n\t\t\t\tdommy[size - shuffle[1] + j - shuffle[0]] = card[j];\n\t\t\t}\n\t\t\tfor (long long int j = 0; j < shuffle[0]; ++j) {\n\t\t\t\tdommy[size - shuffle[0] + j] = card[j];\n\t\t\t}\n\t\t\tcard = dommy;\n\t\t}\n\t\tlong long int answer = 0;\n\t\tfor (long long int i = search[0] - 1; i < search[1]; ++i) {\n\t\t\tif (card[i] <= search[2]) {\n\t\t\t\t++answer;\n\t\t\t}\n\t\t}\n\t\tcout << answer << endl;\n\t}\n\treturn 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include <cstdio>\n#include <vector>\n#include <map>\n#include <algorithm>\n#define fi first\n#define sec second\nusing namespace std;\ntypedef pair<int,int> P;\n\nint n, m, p, q, r;\nint ans;\nvector<P> v;\nvector<P>::iterator it;\n\nvoid solve(){\n\tans = 0;\n\tv.clear();\n\tv.push_back(P(1,n));\n\tscanf(\"%d%d%d%d\", &m, &p, &q, &r);\n\tint pst;\n\tfor(int i = 0; i < m; i++){\n\t\tint x, y; scanf(\"%d%d\", &x, &y);\n\t\tpst = 0;\n\t\tint cnt = 0;\n\t\tfor(it = v.begin(); it != v.end(); it++){\n\t\t\tcnt++;\n\t\t\tpst += (*it).sec-(*it).fi+1;\n\t\t\tif(pst < x) continue;\n\t\t\tif(pst == x){\n\t\t\t\tx = cnt-1;\n\t\t\t\tbreak;\n\t\t\t}\n\t\t\tint in = (*it).sec;\n\t\t\t(*it).sec = (*it).sec-(pst-x);\n\t\t\tv.insert(it+1,P((*it).sec+1,in));\n\t\t\tx = cnt-1;\n\t\t\tbreak;\n\t\t}\n\t\tpst = 0;\n\t\tcnt = 0;\n\t\t/*\n\t\tfor(int j = 0; j < v.size(); j++){\n\t\t\tprintf(\" %d %d\\n\", v[j].fi, v[j].sec);\n\t\t}\n\t\t*/\n\t\tfor(it = v.begin(); it != v.end(); it++){\n\t\t\tcnt++;\n\t\t\tpst += (*it).sec-(*it).fi+1;\n\t\t\tif(pst < y) continue;\n\t\t\tif(pst == y){\n\t\t\t\ty = cnt-1;\n\t\t\t\tbreak;\n\t\t\t}\n\t\t\tint in = (*it).sec;\n\t\t\t(*it).sec = (*it).sec-(pst-y);\n\t\t\tv.insert(it+1,P((*it).sec+1,in));\n\t\t\ty = cnt-1;\n\t\t\tbreak;\n\t\t}\n\t\tvector<P> tmp;\n\t\tfor(int j = y+1; j < v.size(); j++) tmp.push_back(v[j]);\n\t\tfor(int j = x+1; j <= y; j++) tmp.push_back(v[j]);\n\t\tfor(int j = 0; j <= x; j++) tmp.push_back(v[j]);\n\t\tv = tmp;\n\t\t/*\n\t\tprintf(\"\\n\");\n\t\tfor(int j = 0; j < v.size(); j++){\n\t\t\tprintf(\"%d %d\\n\", v[j].fi, v[j].sec);\n\t\t}\n\t\t*/\n\t}\n\t/*\n\tfor(int j = 0; j < v.size(); j++){\n\t\t\tprintf(\"%d %d\\n\", v[j].fi, v[j].sec);\n\t\t}*/\n\tpst = 0;\n\tfor(int i = 0; i < v.size(); i++){\n\t\tpst += v[i].sec-v[i].fi+1;\n\t\tint s = pst-(v[i].sec-v[i].fi), st;\n\t\tif(v[i].fi > r) continue;\n\t\tif(pst < p) continue;\n\t\tif(s > q) continue;\n\t\tst = max(p,v[i].fi);\n\t\tif(pst <= q){\n\t\t\tif(r >= v[i].sec) ans += v[i].sec-v[i].fi+1;\n\t\t\telse ans += r-v[i].fi+1;\n\t\t} else{\n\t\t\tif(r >= v[i].fi+q-s) ans += q-s+1;\n\t\t\telse ans += r-v[i].fi+1;\n\t\t}\n\t\t//printf(\"%d\\n\", ans);\n\t}\n\tprintf(\"%d\\n\", ans);\n}\n\nint main(){\n\twhile(scanf(\"%d\", &n),n) solve();\n}"
  },
  {
    "language": "C++",
    "code": "#include<iostream>\n#include<cstdio>\n#include<vector>\n#include<queue>\n#include<algorithm>\n#include<functional>\n#include<cstring>\n#include<iterator>\n#define MAX_N 100000\n#define F first\n#define S second \n#define MP make_pair\nusing namespace std;\ntypedef pair<int, int> P;\n\nconst int INF = 1e9;\n\nint main() {\n\tint n, m, pp, q, r;\n\n\twhile (cin >> n&&n){\t\n\t\tint save = -1, ans = 0;\n\t\tvector<int>vep, vep2;\n\t\tvep.push_back(1);\n\t\tvep.push_back(n);\n\t    vector<int> vec, vec2;\n\t\tvec.push_back(1);\n\t\tvec.push_back(n);\n\t\tcin >> m >> pp >> q >> r;\n\t\tfor (int i = 0; i < m; i++) {\n\t\t\tint x, y, p, p2;\n\t\t\tscanf(\"%d%d\", &x, &y);\n\t\t\tp = lower_bound(vec.begin(), vec.end(), x) - vec.begin();\n\t\t\tif (vec[p] != x) {\n\t\t\t\tvec.insert(vec.begin() + p, x);\n\t\t\t\tvep.insert(vep.begin() + p, vec[p] - vec[p - 1] + vep[p - 1]);\n\t\t\t}\n\t\t\tif (vec[p] + 1 != vec[p + 1]) {\n\t\t\t\tvec.insert(vec.begin() + p + 1, x + 1);\n\t\t\t\tvep.insert(vep.begin() + p + 1, vep[p] + 1);\n\t\t\t}\n\t\t\tp2 = lower_bound(vec.begin(), vec.end(), y) - vec.begin();\n\t\t\tif (vec[p2] != y) {\n\t\t\t\tvec.insert(vec.begin() + p2, y);\n\t\t\t\tvep.insert(vep.begin() + p2, vec[p2] - vec[p2 - 1] + vep[p2 - 1]);\n\t\t\t}\n\t\t\tif (vec[p2] + 1 != vec[p2 + 1]) {\n\t\t\t\tvec.insert(vec.begin() + p2 + 1, y + 1);\n\t\t\t\tvep.insert(vep.begin() + p2 + 1, vep[p2] + 1);\n\t\t\t}\n\t\t\tfor (int j = p2 + 1; j < vec.size(); j++) {\n\t\t\t\tvec2.push_back(vec[j] - vec[p2 + 1] + 1);\n\t\t\t\tvep2.push_back(vep[j]);\n\t\t\t}\n\t\t\tint size = vec2[vec2.size() - 1];\n\t\t\tfor (int j = p + 1; j < p2 + 1; j++) {\n\t\t\t\tvec2.push_back(vec[j] - vec[p + 1] + 1 + size);\n\t\t\t\tvep2.push_back(vep[j]);\n\t\t\t}\n\t\t\tsize = vec2[vec2.size() - 1];\n\t\t\tfor (int j = 0; j < p + 1; j++) {\n\t\t\t\tvec2.push_back(vec[j] - vec[0] + 1+size);\n\t\t\t\tvep2.push_back(vep[j]);\n\t\t\t}\n\t\t\tcopy(vec.begin(), vec.end(), back_inserter(vec2));\n\t\t\tvec2.clear();\n\t\t\tcopy(vep.begin(), vep.end(), back_inserter(vep2));\n\t\t\tvep2.clear();\n\t\t}\n\t\tint p, p2;\n\t\tp = lower_bound(vec.begin(), vec.end(), pp) - vec.begin();\n\t\t\n\t\tif (vec[p] != pp) {\n\t\t\tvec.insert(vec.begin() + p, pp);\n\t\t\tvep.insert(vep.begin() + p, vec[p] - vec[p - 1] + vep[p - 1]);\n\t\t}\n\t\tif (vec[p] + 1 != vec[p + 1]) {\n\t\t\tvec.insert(vec.begin() + p + 1, pp + 1);\n\t\t\tvep.insert(vep.begin() + p + 1, vep[p] + 1);\n\t\t}\n\t\tp2 = lower_bound(vec.begin(), vec.end(), q) - vec.begin();\n\t\tif (vec[p2] != q) {\n\t\t\tvec.insert(vec.begin() + p2, q);\n\t\t\tvep.insert(vep.begin() + p2, vec[p2] - vec[p2 - 1] + vep[p2 - 1]);\n\t\t}\n\t\tif (vec[p2] + 1 != vec[p2 + 1]) {\n\t\t\tvec.insert(vec.begin() + p2 + 1, q + 1);\n\t\t\tvep.insert(vep.begin() + p2 + 1, vep[p2] + 1);\n\t\t}\n\t\tfor (int i = p; i <= p2; i++) {\n\t\t\tif (i + 1<=p2 && vep[i + 1] - vep[i] == vec[i + 1] - vec[i]) {\n\t\t\t\tfor (int j = vep[i]; j <= vep[i + 1]; j++) {\n\t\t\t\t\tif (j <= r&&save!=j) {\n\t\t\t\t\t\tans++;\n\t\t\t\t\t\tsave = j;\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t}\n\t\t\telse{\n\t\t\t\tif (vep[i] <= r&&save != vep[i]) {\n\t\t\t\t\tans++;\n\t\t\t\t\tsave = vep[i];\n\t\t\t\t}\n\t\t\t}\n\t}\n\t\tcout << ans << endl;\n\t}\n}"
  },
  {
    "language": "C++",
    "code": "#include<iostream>\n#include<cassert>\n#include<algorithm>\n#include<vector>\n#include<stack>\n#include<list>\nusing namespace std;\n#define REP(i,b,n) for(int i=b;i<n;i++)\n#define rep(i,n)   REP(i,0,n)\n\n\nvoid simulate(int n,vector<pair<int,int> > & in,const int lim,int l,int r){\n  vector<int> a(n);\n  rep(i,n)a[i] = i+1;\n  for(int i=in.size()-1;i>=0;i--){\n\n  }\n  rep(i,lim){\n\n  }\n}\n\n/*\n  l-rÌRÌª¾¯ðÛµÄAãë©çð¢Ä¢­B\n  Rªªô·é±Æª Á½ç»ê¼êÊÉª¯ÄâÁÄµÜÁÄ¢¢BiÍ¸j\n  [l,r]\n  inÍ[first,second]ðÅèµÄ¼ðXbv·é\n  1-origin\n */\nint ans = 0;\nvoid solve(const int n,vector<pair<int,int> > &in,int now,const int lim,int l,int r,const int p,const int q){\n  //cout << l <<\" \" << r << endl;\n  if (r < l)return;\n  if (now == in.size()){\n    if (q < l || r < p)return;\n    ans += min(r,q)-max(l,p)+1;\n    return;\n  }\n  int p1=in[now].first-1,p2=in[now].second-in[now].first+1,p3=n-p1-p2;//eRÌTCY\n  swap(p1,p3);\n\n  if (in[now].second < r){//[max(in[now].second+1,l)..r]ÜÅðãÉÁÄ¢­\n    int nextl=in[now].second < l?l-in[now].second:1;\n    int nextr=nextl + r-max(in[now].second+1,l);//\n    //cout <<l <<\" \" << r <<\" \" << in[now].first <<\" \" << in[now].second << \" type:1 \" << nextl <<\" \" << nextr << endl;\n    solve(n,in,now+1,lim,nextl,nextr,p,q);\n  }\n  \n  //»ÌÜÜ\n  if (!(r < in[now].first || in[now].second < l)){\n    int newl = max(in[now].first,l),newr=min(in[now].second,r);\n    int nextl = l < in[now].first ? 1+p1 : 1+p1 + l-in[now].first;\n    int nextr = nextl + newr-newl;\n    //cout <<l <<\" \" << r <<\" \" << in[now].first <<\" \"<< in[now].second <<\" type:2 \" << nextl <<\" \" << nextr << endl;\n    solve(n,in,now+1,lim,nextl,nextr,p,q);\n  }\n\n  if (l < in[now].first){//[l..min(in[now].first-1,r)] ðºÜÅÁÄ¢­B\n    int nextl=p1+p2+l;\n    int nextr=nextl+min(in[now].first-1,r)-l;\n    //cout <<l <<\" \" << r << \" \" << in[now].first <<\" \" << in[now].second << \" type:3 \" << nextl <<\" \"<< nextr << endl;\n    solve(n,in,now+1,lim,nextl,nextr,p,q);\n  }\n\n}\n\nmain(){\n  int n,m;\n  while(cin>>n && n){\n    ans = 0;\n    int m,l,r,lim;\n    cin>>m;\n    cin>>l>>r>>lim;\n    vector<pair<int,int> > in(m);\n    rep(i,m){\n      cin>>in[i].first>>in[i].second;\n      in[i].first++;\n    }\n    //reverse(in.begin(),in.end());\n    solve(n,in,0,lim,1,lim,l,r);\n    cout << ans << endl;\n  }\n}"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\n\nusing namespace std;\ntypedef long long ll;\ntypedef pair<int,int> P;\n\nint n,m,p,q,r;\n\nvector<P> a;\n\nvoid shuffle(int x, int y){\n\tvector<P> nex;\n\tvector<P> b[3];\n\tint in[] = {x,y,n};\n\tint cnt = 0;\n\tint c2 = 0;\n\tint c3 = 0;\n\tfor (int i = 0;i < a.size();i++){\n\t\t//cout << i << \"cnt\" << endl;\n\t\tif(cnt+a[i].second - a[i].first+1 < in[c2]){ b[c3].push_back(a[i]); cnt += a[i].second-a[i].first+1;}\n\t\telse{\n\t\t\tb[c3].push_back(P(a[i].first,a[i].first+(in[c2]-cnt-1)));\n\t\t\ta[i].first += in[c2] - cnt;\n\t\t\tcnt += in[c2] - cnt;\n\t\t\tc2++;\n\t\t\tc3++;\n\t\t\tif(a[i].first <= a[i].second) i--;\n\t\t\tif(c3 == 3) break;\n\t\t}\n\t}\n\tfor (int i = 2;i >= 0;i--){\n\t\tfor (int j = 0;j < b[i].size();j++){\n\t\t\tnex.push_back(b[i][j]);\n\t\t}\n\t}\n\ta = nex;\n\treturn ;\n}\n\nint count(int x,int y){\n\tint cnt = 0;\n\tint ret = 0;\n\tint in[] = {x-1,y};\n\tint c2 = 0;\n\tfor (int i = 0;i < a.size();i++){\n\t\t//cout << ret << \"ret\" << cnt << \" \" << a[i].first << \" \" << a[i].second <<endl;\n\t\tif(cnt+a[i].second - a[i].first+1 < in[c2]){\n\t\t\t   \tcnt += a[i].second-a[i].first+1;\n\t\t\t\tif(c2 == 1){\n\t\t\t\t\tret += max(0,min(a[i].second,r) - a[i].first+1);\n\t\t\t\t}\n\t\t}\n\t\telse{\n\t\t\tint tmp = a[i].first+(in[c2] - cnt - 1);\n\t\t\tif(c2 == 1) ret += max(0,min(tmp,r) - a[i].first+1);\n\t\t\ta[i].first += in[c2]-cnt;\n\t\t\tcnt += in[c2]-cnt;\n\t\t\ti--;\n\t\t\tc2++;\n\t\t}\n\t}\n\treturn ret;\n}\n\nint main() {\n\tcin.tie(0);\n\tios::sync_with_stdio(false);\n\n\twhile(true){\n\t\tcin >> n ;\n\t\tif(n == 0) break;\n\t\tcin >> m >> p >> q >> r;\n\t\ta = vector<P>(1);\n\t\ta[0] = P(1,n);\n\n\t\tfor (int i = 0;i < m;i++){\n\t\t\tint x,y; cin >> x >> y;\n\t\t\tshuffle(x,y);\n\t\t\t/*for (int j = 0;j < a.size();j++){\n\t\t\t\t\tcout << a[j].first << \" \" << a[j].second << endl;\n\t\t\t}*/\n\t\t}\n\t\tcout << count(p,q) << endl;\n\t}\n\n\n\n\treturn 0;\n\n}\n\n"
  },
  {
    "language": "C++",
    "code": "//  4???27??\\  ????????????0535 ; ?????£?????????\n// http://judge.u-aizu.ac.jp/onlinejudge/description.jsp?id=0536\n\n#include <iostream>\n#define NUM 100000\nusing namespace std;\n\nint main(){\n\n  int n;//?????????????????°\n  int m;//?????£??????????????°\n  int p,q;//p ???????????? q ?????????????????????\n  int r;// r??\\?????????????????????????????????\n  register int x[5000],y[5000];//????????????????????´???\n  register int card[NUM];\n  int i;\n  int A[NUM];\n  int B[NUM];\n  int C[NUM];\n\n  do{\n    int j = 0;\n    register int count = 1;\n    register int step = 1;\n    register int red = 1;\n    register int blue = 1;\n    register int green = 0;\n\n    cin >> n;\n    cin >> m;\n    cin >> p >> q >> r;\n\n    if (!n){\n      break;\n    }\n\n    for (i=0; i < m; i++){\n      cin >> x[i] >> y[i];\n    }\n\n    while (j < m){\n\n      for (i=1; i <= n; i++ ){//??°?????£??\\\n        card[i] = i;\n      }\n\n      for (i=1 ; i <= x[j] ;i++ ){//????????????1~X???????????§\n        A[i] = card[i];\n      }\n\n      while (i <= y[j]){//????????????X+1~Y???????????§\n        B[count] = card[i];\n        i++;\n        count++;\n      }\n\n      while (i <= n){//????????????Y+1~n???????????§\n        C[step] = card[i];\n        i++;\n        step++;\n      }\n\n      for (i=1; i <= (n - y[j]); i++ ){//C?????°?????£??\\\n        card[i] = C[i];\n      }\n\n      while (red <= count){//B?????°?????£??\\\n        card[i] = B[red];\n        i++;\n        red++;\n      }\n\n      while (blue <= step){//A?????°?????£??\\\n        card[i] = A[blue];\n        i++;\n        blue++;\n      }\n      j++;\n    }\n\n    for (i=p; i <= q; i++){\n      if (card[i] <= r){\n        green++;\n      }\n    }\n\n    cout << green << endl;\n  } while (n);\n\n  return 0;\n\n}"
  },
  {
    "language": "C++",
    "code": "#include \"bits/stdc++.h\"\nusing namespace std;\ntypedef long long LL;\ntypedef pair<int, int> P;\nconst LL MOD = 1000000007LL;\nstack<P> card;\nvector<P> cut(int x) {\n\tvector<P> ret;\n\tint sum = 0;\n\twhile (!card.empty() && sum + (card.top().second - card.top().first + 1) <= x) {\n\t\tsum += (card.top().second - card.top().first + 1);\n\t\tret.push_back(card.top());\n\t\tcard.pop();\n\t}\n\tif (sum < x) {\n\t\tret.emplace_back(card.top().first, card.top().first + x - sum - 1);\n\t\tcard.top().first += x - sum;\n\t}\n\treturn ret;\n}\nint main() {\n\tint n;\n\twhile (cin >> n, n) {\n\t\tint m;\n\t\tcin >> m;\n\t\tint p, q, r;\n\t\tcin >> p >> q >> r;\n\t\twhile (!card.empty()) card.pop();\n\t\tcard.push(P(1, n));\n\t\tfor (int i = 0; i < m; i++) {\n\t\t\tint x, y;\n\t\t\tcin >> x >> y;\n\t\t\tvector<P> A = cut(x);\n\t\t\tvector<P> B = cut(y - x);\n\t\t\tvector<P> C = cut(n - y);\n\t\t\tfor (int j = A.size() - 1; j >= 0; j--) card.push(A[j]);\n\t\t\tfor (int j = B.size() - 1; j >= 0; j--) card.push(B[j]);\n\t\t\tfor (int j = C.size() - 1; j >= 0; j--) card.push(C[j]);\n\t\t}\n\t\tcut(p - 1);\n\t\tvector<P> v = cut(q - p + 1);\n\t\tint ans = 0;\n\t\tfor (int i = 0; i < v.size(); i++) {\n\t\t\tif (v[i].first <= r) ans += min(v[i].second, r) - v[i].first + 1;\n\t\t}\n\t\tcout << ans << endl;\n\t}\n}\n"
  },
  {
    "language": "C++",
    "code": "//確か、r以下とそれ以外の境界部分のインデックスをうごうごやっていた……気がする。\n//書いた当時のことを覚えていないので、誰か解読してください。\n\n#include <iostream>\n#include <algorithm>\n#include <vector>\nusing namespace std;\n\nint main(){\n\tint n, m, p, q, r, x, y;\n\tvector<int>::iterator itx, ity, it;\n\n\twhile( cin >> n >> m >> p >> q >> r ){\n\t\tvector<int> v1, v2;\n\t\tv1.push_back(0);\n\t\tv1.push_back(r);\n\t\t\n\t\tfor(int i = 0; i < m; ++i){\n\t\t\tcin >> x >> y;\n\t\t\titx = upper_bound(v1.begin(), v1.end(), x);\n\t\t\tity = upper_bound(v1.begin(), v1.end(), y);\n\t\t\t\n\t\t\tif( (ity - v1.begin()) % 2 == 0 ){\tv2.push_back(0);\t}\n\t\t\tv2.push_back(0);\n\n\t\t\tfor(it = ity; it != v1.end(); ++it){\n\t\t\t\tv2.push_back(*it - y);\n\t\t\t}\n\n\t\t\tif( (v1.end() - itx) % 2 != 0 ){\tv2.push_back(n - y);\t}\n\t\t\tfor(it = itx; it != ity; ++it){\n\t\t\t\tv2.push_back(*it - x + n - y);\n\t\t\t}\n\t\t\t\n\t\t\tit = v1.begin();\n\t\t\tif( (ity - v1.begin()) % 2 != 0 ){\t++it;\t}\n\n\t\t\tif( v1.size() > 2 && !it[1] ){\n\t\t\t\t it += 2;\t//重複排除\n\t\t\t}\n\n\t\t\tif( *it + n - x == v2.back() ){\t//重複排除\n\t\t\t\t++it;\n\t\t\t\tv2.pop_back();\n\t\t\t}\n\t\t\tfor( ; it != itx; ++it){\n\t\t\t\tv2.push_back(*it + n - x);\n\t\t\t}\n\n\t\t\tv1.swap(v2);\n\t\t\tv2.clear();\n\t\t}\n\n\t\tv1.insert( upper_bound(v1.begin(), v1.end(), p - 1), 2, p - 1);\n\t\tv1.insert( lower_bound(v1.begin(), v1.end(), q), q);\n\t\tv1.push_back(n);\n\n\t\tit = upper_bound(v1.begin(), v1.end(), p - 1);\n\t\tif( (it - v1.begin()) % 2 != 0) --it;\n\n\t\tint ans = 0;\n\t\tfor( ; *it < q; ++it){\n\t\t\tint prev = *it;\n\t\t\t++it;\n\t\t\tans += *it - prev;\n\t\t}\n\t\t\n\t\tcout << ans << '\\n';\n\t}\n}"
  },
  {
    "language": "C++",
    "code": "// Last Change: 10/27/2019 14:53:59.\n#include <algorithm>\n#include <array>\n#include <bitset>\n#include <cmath>\n#include <complex>\n#include <cstdlib>\n#include <functional>\n#include <iomanip>\n#include <iostream>\n#include <list>\n#include <map>\n#include <memory>\n#include <numeric>\n#include <queue>\n#include <set>\n#include <stack>\n#include <string>\n#include <vector>\n\nusing namespace std;\nusing ll = long long;\n\nstruct Cards {\n  ll s, t;\n  Cards(ll a, ll b) : s(a), t(b) {\n  }\n  ll getSize() {\n    return t - s + 1;\n  }\n};\n\nll count(vector<Cards> &c, ll pos, ll val) {\n  ll res = 0;\n  ll total = 0;\n  size_t i = 0, cSize = c.size();\n  for (i = 0; i < cSize; ++i) {\n    if (total + c[i].getSize() > pos) {\n      break;\n    }\n    total += c[i].getSize();\n    res += max(0LL, val - c[i].s + 1) - max(0LL, val - c[i].t);\n  }\n  if (total != pos) {\n    ll diff = pos - total - 1;\n    res += max(0LL, val - c[i].s + 1) - max(0LL, val - (c[i].s + diff));\n  }\n  return res;\n}\n\nvoid shuffle(vector<Cards> &cards, ll x, ll y) {\n  // split\n  vector<Cards> a, b, c;\n  ll total = 0;\n  size_t i = 0, cardSize = cards.size();\n  for (i = 0; i < cardSize; ++i) {\n    if (total + cards[i].getSize() > x) {\n      break;\n    }\n    total += cards[i].getSize();\n    a.push_back(cards[i]);\n  }\n  if (total != x) {\n    a.push_back(Cards(cards[i].s, cards[i].s + x - total - 1));\n    cards[i] = Cards(cards[i].s + x - total, cards[i].t);\n    total = x;\n  }\n\n  for (; i < cardSize; ++i) {\n    if (total + cards[i].getSize() > y) {\n      break;\n    }\n    total += cards[i].getSize();\n    b.push_back(cards[i]);\n  }\n  if (total != y) {\n    b.push_back(Cards(cards[i].s, cards[i].s + y - total - 1));\n    cards[i] = Cards(cards[i].s + y - total, cards[i].t);\n    total = y;\n  }\n\n  for (; i < cardSize; ++i) {\n    c.push_back(cards[i]);\n  }\n\n  // shuffle\n  cards.clear();\n  for (auto &&e : c) {\n    cards.push_back(e);\n  }\n  for (auto &&e : b) {\n    cards.push_back(e);\n  }\n  for (auto &&e : a) {\n    cards.push_back(e);\n  }\n}\n\nvoid solve(ll n) {\n  ll m, p, q, r;\n  cin >> m >> p >> q >> r;\n  vector<Cards> cards(1, Cards(1, n));\n  {\n    // shuffle\n    ll x, y;\n    for (ll i = 0; i < m; ++i) {\n      cin >> x >> y;\n      shuffle(cards, x, y);\n    }\n  }\n  // count and output\n  ll res1 = count(cards, q, r);\n  ll res2 = count(cards, p - 1, r);\n  cout << res1 - res2 << endl;\n}\n\nint main() {\n  ll n;\n  while (cin >> n and n) {\n    solve(n);\n  }\n}\n"
  },
  {
    "language": "C++",
    "code": "#include <cstdio>\n#include <vector>\n#include <map>\nusing namespace std;\ntypedef pair<int, int> P;\ntypedef vector<P> vi;\n#define f first\n#define s second\n#define pb push_back\n#define sz(x) x.size()\nvi c;\nvoid shuffle(int x, int y) {\n    int cnt=0, i;\n    int sz=sz(c);\n    vi temp1, temp2, temp3;\n    for (i=0; i<sz; i++) {\n        int s=c[i].f, e=c[i].s;\n        if (cnt+e-s+1>=x) {\n            temp1.pb(P(s,s+x-cnt-1));\n            break;\n        }\n        temp1.pb(c[i]); \n        cnt+=e-s+1;\n    }\n    if (cnt+c[i].s-c[i].f+1>=y) {\n        temp2.pb(P(c[i].f+x-cnt,c[i].f+y-cnt-1));\n        temp3.pb(P(c[i].f+y-cnt,c[i].s));\n        for (i+=1;i<sz; i++) temp3.pb(c[i]);\n    } else {\n        temp2.pb(P(c[i].f+x-cnt,c[i].s));\n        cnt+=c[i].s-c[i].f+1;\n        int a=++i;\n        for (;i<sz; i++) {\n            int s=c[i].f, e=c[i].s;\n            if (cnt+e-s+1>=y) {\n                temp2.pb(P(s,s+y-cnt-1));\n                break;\n            }\n            temp2.pb(c[i]);\n            cnt+=e-s+1;\n        }\n        if (cnt+c[i].s-c[i].f+1!=y) temp3.pb(P(c[i].f+y-cnt,c[i].s));\n        for (i+=1; i<sz; i++) temp3.pb(c[i]);\n    }\n/*\n    for (i=0; i<sz(temp1); i++) printf(\"%d %d\\n\",temp1[i].f,temp1[i].s);\n    puts(\"\");\n    for (i=0; i<sz(temp2); i++) printf(\"%d %d\\n\",temp2[i].f,temp2[i].s);\n    puts(\"\");\n    for (i=0; i<sz(temp3); i++) printf(\"%d %d\\n\",temp3[i].f,temp3[i].s);\n    puts(\"\");\n*/\n    for (i=0; i<sz(temp3); i++) c.pb(temp3[i]);\n    for (i=0; i<sz(temp2); i++) c.pb(temp2[i]);\n    for (i=0; i<sz(temp1); i++) c.pb(temp1[i]);\n}\n\nint main() {\n    int n, m, p, q, r;\n    while (scanf(\"%d\",&n)) {\n        if (!n) break;\n        scanf(\"%d%d%d%d\",&m,&p,&q,&r);\n        c.pb(P(1,n));\n        for (int i=0; i<m; i++) {\n            int x, y; scanf(\"%d%d\",&x,&y);\n            shuffle(x,y);\n        }\n        int cnt=0, res=0;\n        for (int i=0; i<sz(c); i++) {\n            int s=c[i].f, e=c[i].s;\n//            printf(\"%d %d\\n\",s,e);\n            if (cnt+e-s+1>=p&&q>=cnt) {\n                int m=max(s+p-cnt-1,s), M=min(s+q-cnt-1,e);\n//                printf(\"%d %d\\n\",m,M);\n                if (r>=m&&r<=M) res+=r-m+1;\n                else if (r>=M) res+=M-m+1;\n            }\n            cnt+=e-s+1;\n        }\n        c.clear();\n        printf(\"%d\\n\",res);\n    }\n}"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\nusing namespace std;\ntypedef pair<int,int> P;\n\nint sizes(P a){\n\treturn a.second-a.first;\n}\n\nint main(){\n\twhile(true){\n\t\tint n;\tcin>>n;\n\t\tif(n==0)\treturn 0;\n\t\tint m;\tcin>>m;\n\t\tint p,q,r;\tcin>>p>>q>>r;\n\t\tvector<P> ls(1,make_pair(0,n));//(0,n]\n\t\tfor(int i=0;i<m;i++){\n\t\t\tint s,t;\tcin>>s>>t;\n\t\t\tvector<P> a;\n\t\t\tint cnt=0;\n\t\t\twhile(true){\n\t\t\t\tif(cnt+sizes(ls[0])>s){\n\t\t\t\t\tint tmp=s-cnt;\n\t\t\t\t\ta.push_back(make_pair(ls[0].first,ls[0].first+tmp));\n\t\t\t\t\tls[0].first=s;\n\t\t\t\t\tcnt=s;\n\t\t\t\t\tbreak;\n\t\t\t\t}\n\t\t\t\telse{\n\t\t\t\t\ta.push_back(ls[0]);\n\t\t\t\t\tcnt+=sizes(ls[0]);\n\t\t\t\t\tls.erase(ls.begin());\n\t\t\t\t}\n\t\t\t}\n\t\t\tif(ls[0].first==ls[0].second)\tls.erase(ls.begin());\n\t\t\twhile(true){\n\t\t\t\tif(cnt+sizes(ls[0])>t){\n\t\t\t\t\tint tmp=t-cnt;\n\t\t\t\t\tls.push_back(make_pair(ls[0].first,ls[0].first+tmp));\n\t\t\t\t\tls[0].first=t;\n\t\t\t\t\tcnt=t;\n\t\t\t\t\tbreak;\n\t\t\t\t}\n\t\t\t\telse{\n\t\t\t\t\tls.push_back(ls[0]);\n\t\t\t\t\tcnt+=sizes(ls[0]);\n\t\t\t\t\tls.erase(ls.begin());\n\t\t\t\t}\n\t\t\t}\n\t\t\tfor(int i=0;i<(int)a.size();i++)\tls.push_back(a[i]);\n\t\t\t//for(int i=0;i<(int)ls.size();i++)\tcout<<ls[i].first<<\" \"<<ls[i].second<<\"\\t\";\n\t\t\t//cout<<endl;\n\t\t}\n\t\tvector<P> range;\n\t\tint cnt=0;\n\t\twhile(cnt+sizes(ls[0])<p){\n\t\t\tcnt+=sizes(ls[0]);\tls.erase(ls.begin());\n\t\t}\n\t\tls[0].first+=p-cnt;\n\t\tcnt=p;\n\t\twhile(cnt+sizes(ls[0])<q){\n\t\t\tcnt+=sizes(ls[0]);\trange.push_back(ls[0]);\tls.erase(ls.begin());\n\t\t}\n\t\trange.push_back(make_pair(ls[0].first,ls[0].first+(q-cnt)));\n\t\trange[0].first--;\n\t\t/*for(int i=0;i<(int)range.size();i++){\n\t\t\tcout<<range[i].first<<\" \"<<range[i].second<<\"\\t\";\n\t\t}\n\t\tcout<<endl;*/\n\t\tint ans=0;\n\t\tfor(int i=0;i<(int)range.size();i++){\n\t\t\tans+=max(0,min(range[i].second,r)-range[i].first);\n\t\t}\n\t\tcout<<ans<<endl;\n\t}\n}\n\t\t"
  },
  {
    "language": "C++",
    "code": "#include <tuple>\n#include <vector>\n#include <iostream>\n#include <algorithm>\n\n#pragma warning(disable : 4996)\n\nusing namespace std;\n\nint n, m, p, q, c, r1, r2;\n\nvector<tuple<int, int, int> > dat; // (l, r, lnum)\n\ninline void divide(int pos)\n{\n\tvector<tuple<int, int, int> > dat1;\n\n\tfor (int i = 0; i < dat.size(); i++)\n\t{\n\t\tint l = get<0>(dat[i]);\n\t\tint r = get<1>(dat[i]);\n\t\tint t = get<2>(dat[i]);\n\n\t\tif (l < pos && pos < r)\n\t\t{\n\t\t\tdat1.push_back(make_tuple(l, pos, t));\n\t\t\tdat1.push_back(make_tuple(pos, r, t + pos - l));\n\t\t}\n\t\telse\n\t\t{\n\t\t\tdat1.push_back(make_tuple(l, r, t));\n\t\t}\n\t}\n\n\tdat = dat1;\n}\n\ninline int position(int num)\n{\n\tfor (int i = 0; i < dat.size(); i++)\n\t{\n\t\tif (get<0>(dat[i]) <= num && num < get<1>(dat[i]))\n\t\t{\n\t\t\treturn i;\n\t\t}\n\t}\n\n\treturn -1;\n}\n\ninline void shuffle(int a, int b)\n{\n\tdivide(a);\n\tdivide(b);\n\n\tint l = position(a);\n\tint r = position(b);\n\n\tvector<tuple<int, int, int> > dat1;\n\n\tint pos = 0;\n\n\tfor (int i = r; i < dat.size(); i++)\n\t{\n\t\tdat1.push_back(make_tuple(pos, pos - get<0>(dat[i]) + get<1>(dat[i]), get<2>(dat[i]))); pos += get<1>(dat[i]) - get<0>(dat[i]);\n\t}\n\n\tfor (int i = l; i < r; i++)\n\t{\n\t\tdat1.push_back(make_tuple(pos, pos - get<0>(dat[i]) + get<1>(dat[i]), get<2>(dat[i]))); pos += get<1>(dat[i]) - get<0>(dat[i]);\n\t}\n\n\tfor (int i = 0; i < l; i++)\n\t{\n\t\tdat1.push_back(make_tuple(pos, pos - get<0>(dat[i]) + get<1>(dat[i]), get<2>(dat[i]))); pos += get<1>(dat[i]) - get<0>(dat[i]);\n\t}\n\n\tdat = dat1;\n}\n\nint main()\n{\n\twhile(true)\n\t{\n\t\tscanf(\"%d\", &n); if (n == 0) { break; }\n\t\tscanf(\"%d\", &m);\n\t\tscanf(\"%d\", &p); p--;\n\t\tscanf(\"%d\", &q); q--;\n\t\tscanf(\"%d\", &c);\n\n\t\tdat.clear();\n\n\t\tdat.push_back(make_tuple(0, n, 1));\n\n\t\tfor (int i = 0; i < m; i++)\n\t\t{\n\t\t\tscanf(\"%d\", &r1);\n\t\t\tscanf(\"%d\", &r2);\n\n\t\t\tshuffle(r1, r2);\n\t\t}\n\n\t\tint ret = 0;\n\n\t\tfor (int i = 0; i < dat.size(); i++)\n\t\t{\n\t\t\tint l = get<0>(dat[i]);\n\t\t\tint r = get<1>(dat[i]);\n\t\t\tint t = get<2>(dat[i]);\n\n\t\t\tif (p <= l && r <= q + 1)\n\t\t\t{\n\t\t\t\tret += min(max(c - t + 1, 0), r - l);\n\t\t\t}\n\t\t\telse if (p <= l && l <= q)\n\t\t\t{\n\t\t\t\tret += min(max(c - t + 1, 0), q - l + 1);\n\t\t\t}\n\t\t\telse if (p <= r && r <= q)\n\t\t\t{\n\t\t\t\tret += max(c - (t + (p - l)) + 1, 0);\n\t\t\t}\n\t\t}\n\n\t\tprintf(\"%d\\n\", ret);\n\t}\n\n\treturn 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include <iostream>\n#include <algorithm>\n#include <string>\n#include <vector>\nusing namespace std;\n\nint N, M, P, Q, R;\n\nint sign(int x) {\n  if (x >= 0) return 1;\n  else        return -1;\n}\n\nvoid div(vector<int> &s, int x, int y, vector<int> &a, vector<int> &b, vector<int> &c) {\n  int i = 0, h = 0;\n  for (; i<s.size(); i++) {\n    h += abs(s[i]);\n    if (h >= x) {\n      int fa = x - (h-abs(s[i])),\n          fb = h - x;\n      if (fa > 0) a.push_back(sign(s[i]) * fa);\n      if (fb > 0) b.push_back(sign(s[i]) * fb);\n      break;\n    }\n    a.push_back(s[i]);\n  }\n  for (i++; i<s.size(); i++) {\n    h += abs(s[i]);\n    if (h >= y) {\n      int fa = y - (h-abs(s[i])),\n          fb = h - y;\n      if (fa > 0) b.push_back(sign(s[i]) * fa);\n      if (fb > 0) c.push_back(sign(s[i]) * fb);\n      break;\n    }\n    b.push_back(s[i]);\n  }\n  for (i++; i<s.size(); i++) {\n    c.push_back(s[i]);\n  }\n}\n\nint main() {\n  cin >> N >> M >> P >> Q >> R;\n\n  vector<int> s;\n  s.push_back(R), s.push_back(R-N);\n\n  for (int k=0; k<M; k++) {\n    int x, y;\n    cin >> x >> y;\n    vector<int> a, b, c;\n    div(s, x, y, a, b, c);\n    s.clear();\n    s.insert(s.end(), c.begin(), c.end());\n    s.insert(s.end(), b.begin(), b.end());\n    s.insert(s.end(), a.begin(), a.end());\n  }\n\n  vector<int> a, b, c;\n  div(s, P-1, Q, a, b, c);\n  int ans = 0;\n  for (auto x : b) ans += max(x, 0);\n  cout << ans << \"\\n\";\n  return 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include<iostream>\n#include<queue>\n#include<map>\n#include<algorithm>\nusing namespace std;\n#define fr first\n#define sc second\ntypedef pair< int , int > P;\nint n, m;\ndeque< P > d;\nint _sum(P p){\n  return p.sc - p.fr + 1;\n}\nint query(int& p,int& q,int& r){\n  int ret = 0, ans = 0;\n  while(_sum(d.front()) < p){\n    ret += _sum(d.front());\n    d.pop_front();\n  }\n  if(ret != p - 1) d.front().fr = d.front().fr + p - ret;\n  ret = p;\n  while(ret + _sum(d.front()) <= q){\n    if(d.front().sc <= r) ans += _sum(d.front());\n    else if(d.front().fr <= r) ans += _sum(P(d.front().fr,r));\n    ret += _sum(d.front());\n    d.pop_front();\n  }\n  if(ret != q){\n    P p = P(d.front().fr,d.front().fr + q - ret - 1);\n    if(p.sc <= r) ans += _sum(P(p.fr,p.sc));\n    else if(p.fr <= r) ans += _sum(P(p.fr,r));\n  }\n  return ans;\n}\nvoid shuffle(int* xy){\n  deque< P > tmp[2];\n  int ret = 0;\n  for(int i = 0 ; i < 2 ; i++ ){\n    while( ret + _sum(d.front()) <= xy[i]){\n      tmp[i].push_back(d.front());\n      ret += _sum(d.front());\n      d.pop_front();\n    }\n    if(ret != xy[i]){\n      tmp[i].push_back(P(d.front().fr,d.front().fr + xy[i] - ret - 1));\n      d.front().fr = d.front().fr + xy[i] - ret;\n      ret = xy[i];\n    }\n  }\n  d.insert(d.end(),tmp[1].begin(),tmp[1].end());\n  d.insert(d.end(),tmp[0].begin(),tmp[0].end()); \n}\nint main(){\n  while(cin >> n , n){\n    cin >> m;\n    d.push_back( P( 1, n));\n    int p, q, r;\n    cin >> p >> q >> r;\n    while(m--){\n      int xy[2];\n      cin >> xy[0] >> xy[1];\n      shuffle(xy);\n    }\n    cout << query(--p, q, r) << endl;\n    d.clear();\n  }\n}"
  },
  {
    "language": "C++",
    "code": "#include<cstdio>\n#include<vector>\n#include<algorithm>\nusing namespace std;\nint main(){\n    int n,m,p,q,r;\n    for(;;){\n        scanf(\"%d%d%d%d%d\",&n,&m,&p,&q,&r);\n        if(n==0) break;\n        pair<int,int> *cards=new pair<int,int>[1];\n        cards[0]=make_pair(1,n);\n        int csize=1;\n        for(int ix=0;ix<m;ix++){\n            int x,y;\n            scanf(\"%d%d\",&x,&y);\n            int *maif=new int[csize],*mais=new int[csize];\n            maif[0]=1;\n            mais[0]=cards[0].second-cards[0].first+1;\n            for(int i=1;i<csize;i++){\n                mais[i]=mais[i-1]+(cards[i].second-cards[i].first+1);\n                maif[i]=mais[i-1]+1;\n            }\n            vector<pair<int,int> > a,b,c;\n            for(int i=0;i<csize;i++){\n                if(mais[i]<=x) a.push_back(cards[i]);\n                else if(y<maif[i]) c.push_back(cards[i]);\n                else if(x<maif[i]&&mais[i]<=y) b.push_back(cards[i]);\n                else if(x<maif[i]&&y<mais[i]){\n                    b.push_back(make_pair(cards[i].first,y+(cards[i].first-maif[i])));\n                    c.push_back(make_pair(y+(cards[i].first-maif[i])+1,cards[i].second));\n                }\n                else if(maif[i]<=x&&mais[i]<=y){\n                    a.push_back(make_pair(cards[i].first,x+(cards[i].first-maif[i])));\n                    b.push_back(make_pair(x+(cards[i].first-maif[i])+1,cards[i].second));\n                }\n                else if(maif[i]<=x&&y<mais[i]){\n                    a.push_back(make_pair(cards[i].first,x+(cards[i].first-maif[i])));\n                    b.push_back(make_pair(x+(cards[i].first-maif[i])+1,y+(cards[i].first-maif[i])));\n                    c.push_back(make_pair(y+(cards[i].first-maif[i])+1,cards[i].second));\n                }\n            }\n            delete[] cards;\n            delete[] maif;\n            delete[] mais;\n            csize=c.size()+b.size()+a.size();\n            cards=new pair<int,int>[csize];\n            for(int ii=0;ii<c.size();ii++)cards[ii]=c[ii];\n            for(int ii=0;ii<b.size();ii++)cards[ii+c.size()]=b[ii];\n            for(int ii=0;ii<a.size();ii++)cards[ii+c.size()+b.size()]=a[ii];\n        }\n        int *maif=new int[csize],*mais=new int[csize];\n        maif[0]=1;\n        mais[0]=cards[0].second-cards[0].first+1;\n        for(int i=1;i<csize;i++){\n            mais[i]=mais[i-1]+(cards[i].second-cards[i].first+1);\n            maif[i]=mais[i-1]+1;\n        }\n        int ans=0;\n        for(int i=0;i<csize;i++){\n            if(p<=maif[i]&&mais[i]<=q) ans+=max(0,min(r,cards[i].second)-cards[i].first+1);\n            else if(maif[i]<p) ans+=max(0,min(r,cards[i].second)-(cards[i].first+(p-maif[i]))+1);\n            else if(q<mais[i]) ans+=max(0,min(r,cards[i].second-(mais[i]-q))-cards[i].first+1);\n            else ans+=max(0,min(r,cards[i].second-(mais[i]-q))-(cards[i].first+(p-maif[i]))+1);\n        }\n        printf(\"%d\\n\",ans);\n        delete[] cards;\n        delete[] maif;\n        delete[] mais;\n    }\n}"
  },
  {
    "language": "C++",
    "code": "#include<iostream>\n#include<algorithm>\n#include<vector>\n#include<queue>\n#include<map>\n#include<set>\n#include<string>\n#include<stack>\n#include<cstdio>\n#include<cmath>\nusing namespace std;\n\ntypedef long long ll;\ntypedef long double ld;\ntypedef pair<int,int> P;\ntypedef pair<int,P> P1;\n\n#define fr first\n#define sc second\n#define mp make_pair\n#define pb push_back\n#define rep(i,x) for(int i=0;i<x;i++)\n#define rep1(i,x) for(int i=1;i<=x;i++)\n#define rrep(i,x) for(int i=x-1;i>=0;i--)\n#define rrep1(i,x) for(int i=x;i>0;i--)\n#define sor(v) sort(v.begin(),v.end())\n#define rev(s) reverse(s.begin(),s.end())\n#define lb(vec,a) lower_bound(vec.begin(),vec.end(),a)\n#define ub(vec,a) upper_bound(vec.begin(),vec.end(),a)\n#define uniq(vec) vec.erase(unique(vec.begin(),vec.end()),vec.end())\n#define min_3(a,b,c) min(a,min(b,c))\n#define max_3(a,b,c) max(a,max(b,c))\n#define mp1(a,b,c) P1(a,P(b,c))\n#define pque(a) priority_queue<a>\n#define rpque(a) priority_queue<a,vector<a>,greater<a>>\n\nconst int INF=1000000000;\nconst int dir_4[4][2]={{1,0},{0,1},{-1,0},{0,-1}};\nconst int dir_8[8][2]={{1,0},{1,1},{0,1},{-1,1},{-1,0},{-1,-1},{0,-1},{1,-1}};\nconst int kaijou[10]={1,1,2,6,24,120,720,5040,40320,362880};\n\nint main(){\n\twhile(1){\n\t\tint n,m,p,q,r;\n\t\tscanf(\"%d\",&n); if(n == 0)break;\n\t\tscanf(\"%d%d%d%d\",&m,&p,&q,&r);\n\t\t\n\t\tvector<P> vec;\n\t\tvec.pb( P ( 1 , n+1 ) );\n\t\t\n\t\trep(i,m){\n\t\t\tint x,y;\n\t\t\tscanf(\"%d%d\",&x,&y);\n\t\t\t\n\t\t\tint a=-1,b,c=-1,d;\n\t\t\tint sum = 0;\n\t\t\trep(j,vec.size()){\n\t\t\t\tsum += vec[j].sc-vec[j].fr;\n\t\t\t\tif(sum > x && a == -1){\n\t\t\t\t\ta = j;\n\t\t\t\t\tb = vec[j].sc-vec[j].fr-sum+x;\n\t\t\t\t}\n\t\t\t\tif(sum > y && c == -1){\n\t\t\t\t\tc = j;\n\t\t\t\t\td = vec[j].sc-vec[j].fr-sum+y;\n\t\t\t\t}\n\t\t\t}\n\t\t\t\n\t\t\tvector<P> vec_;\n\t\t\tif(a != c){\n\t\t\t\tvec_.pb ( P ( vec[c].fr+d , vec[c].sc ) );\n\t\t\t\tfor(int j = c+1 ; j < vec.size() ; j ++){\n\t\t\t\t\tvec_.pb( vec[j] );\n\t\t\t\t}\n\t\t\t\tvec_.pb ( P ( vec[a].fr+b , vec[a].sc ) );\n\t\t\t\tfor(int j = a+1 ; j < c ; j ++ ){\n\t\t\t\t\tvec_.pb ( vec[j] );\n\t\t\t\t}\n\t\t\t\tvec_.pb ( P ( vec[c].fr , vec[c].fr+d ) );\n\t\t\t\tfor(int j = 0 ; j < a ; j ++){\n\t\t\t\t\tvec_.pb ( vec[j] );\n\t\t\t\t}\n\t\t\t\tvec_.pb ( P ( vec[a].fr , vec[a].fr+b ) );\n\t\t\t}\n\t\t\telse {\n\t\t\t\tvec_.pb ( P ( vec[c].fr+d , vec[c].sc ) );\n\t\t\t\tfor(int j = c+1 ; j < vec.size() ; j ++){\n\t\t\t\t\tvec_.pb( vec[j] );\n\t\t\t\t}\n\t\t\t\tvec_.pb ( P ( vec[a].fr+b , vec[a].fr+d ) );\n\t\t\t\tfor(int j = 0 ; j < a ; j ++){\n\t\t\t\t\tvec_.pb ( vec[j] );\n\t\t\t\t}\n\t\t\t\tvec_.pb ( P ( vec[a].fr , vec[a].fr+b ) );\n\t\t\t}\n\t\t\t\n\t\t\tvec = vec_;\n\t\t}\n\t\t\n\t\tint p_ = 0,q_ = 0;\n\t\tint sum = 0;\n\t\trep(i,vec.size()){\n\t\t\t//printf(\"%d %d\\n\",vec[i].fr,vec[i].sc);\n\t\t\tp_ += min ( max ( min ( r+1 , vec[i].sc ) - vec[i].fr , 0) , max ( p-1 - sum , 0 ) );\n\t\t\tq_ += min ( max ( min ( r+1 , vec[i].sc ) - vec[i].fr , 0) , max ( q - sum , 0 ) );\n\t\t\tsum += vec[i].sc-vec[i].fr;\n\t\t}\n\t\t\n\t\tprintf(\"%d\\n\",q_ - p_);\n\t}\n}"
  },
  {
    "language": "C++",
    "code": "#include<cstdio>\n#include<vector>\n#include<algorithm>\nusing namespace std;\ntypedef pair<int, int> P;\n\nint n;\nint m;\nint p, q, r;\n\nint main(){\n\tfor(;;){\n\t\tscanf(\"%d\", &n);\n\t\tif(n == 0) break;\n\t\tscanf(\"%d\", &m);\n\t\tscanf(\"%d %d %d\", &p, &q, &r);\n\t\tvector<P> va;\n\t\tvector<P> vb[3];\n\t\tva.push_back(P(1, n));\n\t\tfor(int i = 0; i < m; i++){\n\t\t\tint x, y;\n\t\t\tscanf(\"%d %d\", &x, &y);\n\t\t\tint cnt = 0;\n\t\t\tint layer = 0;\n\t\t\tfor(int j = 0; j < va.size(); j++){\n\t\t\t\tint cnt2 = cnt + va[j].second - va[j].first + 1;\n\t\t\t\tif(layer == 0){\n\t\t\t\t\tif(cnt2 > y){\n\t\t\t\t\t\tvb[layer].push_back(P(va[j].first, va[j].first + x - cnt - 1));\n\t\t\t\t\t\tlayer++;\n\t\t\t\t\t\tvb[layer].push_back(P(va[j].first + x - cnt, va[j].first + y - cnt - 1));\n\t\t\t\t\t\tlayer++;\n\t\t\t\t\t\tvb[layer].push_back(P(va[j].first + y - cnt, va[j].second));\n\t\t\t\t\t}else if(cnt2 == y){\n\t\t\t\t\t\tvb[layer].push_back(P(va[j].first, va[j].first + x - cnt - 1));\n\t\t\t\t\t\tlayer++;\n\t\t\t\t\t\tvb[layer].push_back(P(va[j].first + x - cnt, va[j].second));\n\t\t\t\t\t\tlayer++;\n\t\t\t\t\t}else if(cnt2 > x){\n\t\t\t\t\t\tvb[layer].push_back(P(va[j].first, va[j].first + x - cnt - 1));\n\t\t\t\t\t\tlayer++;\n\t\t\t\t\t\tvb[layer].push_back(P(va[j].first + x - cnt, va[j].second));\n\t\t\t\t\t}else if(cnt2 == x){\n\t\t\t\t\t\tvb[layer].push_back(P(va[j].first, va[j].second));\n\t\t\t\t\t\tlayer++;\n\t\t\t\t\t}else{\n\t\t\t\t\t\tvb[layer].push_back(P(va[j].first, va[j].second));\n\t\t\t\t\t}\n\t\t\t\t}else if(layer == 1){\n\t\t\t\t\tif(cnt2 > y){\n\t\t\t\t\t\tvb[layer].push_back(P(va[j].first, va[j].first + y - cnt - 1));\n\t\t\t\t\t\tlayer++;\n\t\t\t\t\t\tvb[layer].push_back(P(va[j].first + y - cnt, va[j].second));\n\t\t\t\t\t}else if(cnt2 == y){\n\t\t\t\t\t\tvb[layer].push_back(P(va[j].first, va[j].second));\n\t\t\t\t\t\tlayer++;\n\t\t\t\t\t}else{\n\t\t\t\t\t\tvb[layer].push_back(P(va[j].first, va[j].second));\n\t\t\t\t\t}\n\t\t\t\t}else{\n\t\t\t\t\tvb[layer].push_back(P(va[j].first, va[j].second));\n\t\t\t\t}\n\t\t\t\tcnt = cnt2;\n\t\t\t}\n\t\t\tva.clear();\n\t\t\tfor(int j = 2; j >= 0; j--){\n\t\t\t\tfor(int k = 0; k < vb[j].size(); k++){\n\t\t\t\t\tva.push_back(vb[j][k]);\n\t\t\t\t}\n\t\t\t\tvb[j].clear();\n\t\t\t}\n\t\t}\n\t\tint res = 0;\n\t\tint cnt = 1;\n\t\tfor(int i = 0; i < va.size(); i++){\n\t\t\tint cnt2 = cnt + va[i].second - va[i].first;\n\t\t\tint lb = max(va[i].first + p - cnt, va[i].first), rb = min(va[i].second + q - cnt2, va[i].second);\n\t\t\tres += max(0, min(rb, r) - lb + 1);\n\t\t\tcnt = cnt2 + 1;\n\t\t}\n\t\tprintf(\"%d\\n\", res);\n\t}\n\treturn 0;\n}\n"
  },
  {
    "language": "C++",
    "code": "#include <cstdlib>\n#include <iostream>\n#include <utility>\n#include <vector>\nusing namespace std;\n\nint main() {\n\tcin.tie(0);\n\tios::sync_with_stdio(false);\n\n\tfor(int n; cin >> n, n;) {\n\t\tint m;\n\t\tcin >> m;\n\n\t\tint p, q, r;\n\t\tcin >> p >> q >> r;\n\n\t\tvector<pair<int, bool> > cards;\n\t\tcards.push_back(make_pair(r, true));\n\t\tcards.push_back(make_pair(n - r, false));\n\n\t\tfor(int i = 0; i < m; ++i) {\n\t\t\tint x, y;\n\t\t\tcin >> x >> y;\n\n\t\t\tvector<pair<int, bool> > tmp;\n\t\t\tint j, sum = 0, idxA, idxB, sumA, sumB;\n\t\t\tfor(j = 0;; ++j) {\n\t\t\t\tsum += cards[j].first;\n\t\t\t\tif(sum >= x) {\n\t\t\t\t\tidxA = j;\n\t\t\t\t\tsumA = sum;\n\t\t\t\t\tbreak;\n\t\t\t\t}\n\t\t\t}\n\n\t\t\tfor(++j;; ++j) {\n\t\t\t\tsum += cards[j].first;\n\t\t\t\tif(sum >= y) {\n\t\t\t\t\tidxB = j;\n\t\t\t\t\tsumB = sum;\n\t\t\t\t\tbreak;\n\t\t\t\t}\n\t\t\t}\n\n\t\t\tif(sumB != y) {\n\t\t\t\ttmp.push_back(make_pair(sumB - y, cards[idxB].second));\n\t\t\t\tcards[idxB].first -= sumB - y;\n\t\t\t}\n\n\t\t\tfor(j = idxB + 1; j < cards.size(); ++j)\n\t\t\t\ttmp.push_back(cards[j]);\n\n\t\t\tif(sumA != x) {\n\t\t\t\ttmp.push_back(make_pair(sumA - x, cards[idxA].second));\n\t\t\t\tcards[idxA].first -= sumA - x;\n\t\t\t}\n\n\t\t\tfor(j = idxA + 1; j <= idxB; ++j)\n\t\t\t\ttmp.push_back(cards[j]);\n\n\t\t\tfor(j = 0; j <= idxA; ++j)\n\t\t\t\ttmp.push_back(cards[j]);\n\n\t\t\tcards.swap(tmp);\n\t\t}\n\n\t\tint ans = 0;\n\t\tint i = 0, sum = 0;\n\t\tfor(; i < cards.size(); ++i) {\n\t\t\tsum += cards[i].first;\n\t\t\tif(sum >= p) {\n\t\t\t\tif(cards[i].second)\n\t\t\t\t\tans += sum - p + 1;\n\n\t\t\t\tbreak;\n\t\t\t}\n\t\t}\n\n\t\tfor(++i; i < cards.size(); ++i) {\n\t\t\tsum += cards[i].first;\n\t\t\tif(sum > q) {\n\t\t\t\tif(cards[i].second)\n\t\t\t\t\tans += cards[i].first - (sum - q);\n\n\t\t\t\tbreak;\n\t\t\t}\n\t\t\telse {\n\t\t\t\tif(cards[i].second)\n\t\t\t\t\tans += cards[i].first;\n\t\t\t}\n\t\t}\n\n\t\tcout << ans << endl;\n\t}\n\n\treturn EXIT_SUCCESS;\n}"
  },
  {
    "language": "C++",
    "code": "#include <iostream>\n#include <list>\n\nusing namespace std;\n\ntypedef struct {\n\tint s;\n\tint n;\n\tint div_p;\n} DATA;\n\nint main(void)\n{\n\tlist<DATA> data;\n\tlist<DATA>::iterator it;\n\tint n, s_count;\n\tint q, p, r;\n\tDATA c;\n\tint ans;\n\t\n\twhile (1){\n\t\tdata.clear();\n\t\tcin >> n;\n\t\tif (n == 0){\n\t\t\tbreak;\n\t\t}\n\t\tcin >> s_count >> p >> q >> r;\n\t\tc.s = 1;\n\t\tc.n = n;\n\t\tdata.push_back(c);\n\t\t\n\t\tfor (int i = 0; i < s_count; i++){\n\t\t\tlist<DATA> t_data;\n\t\t\tint x, y;\n\t\t\t\n\t\t\tcin >> x >> y;\n\t\t\ty -= x;\n\t\t\t\n\t\t\tit = data.begin();\n\t\t\twhile (x > 0){\n\t\t\t\tc.s = it->s;\n\t\t\t\tif (it->n > x){\n\t\t\t\t\tit->s += x;\n\t\t\t\t\tit->n -= x;\n\t\t\t\t\tc.n = x;\n\t\t\t\t\tx = 0;\n\t\t\t\t}\n\t\t\t\telse {\n\t\t\t\t\tx -= it->n;\n\t\t\t\t\tc.n = it->n;\n\t\t\t\t\tit++;\n\t\t\t\t}\n\t\t\t\tc.div_p = 0;\n\t\t\t\tt_data.push_back(c);\n\t\t\t}\n\t\t\twhile (y > 0){\n\t\t\t\tc.s = it->s;\n\t\t\t\tif (it->n > y){\n\t\t\t\t\tit->s += y;\n\t\t\t\t\tit->n -= y;\n\t\t\t\t\tc.n = y;\n\t\t\t\t\ty = 0;\n\t\t\t\t}\n\t\t\t\telse {\n\t\t\t\t\ty -= it->n;\n\t\t\t\t\tc.n = it->n;\n\t\t\t\t\tit++;\n\t\t\t\t}\n\t\t\t\tc.div_p = 1;\n\t\t\t\tt_data.push_back(c);\n\t\t\t}\n\t\t\t\n\t\t\twhile (it != data.end()){\n\t\t\t\tc = *it;\n\t\t\t\tc.div_p = 2;\n\t\t\t\tt_data.push_back(c);\n\t\t\t\tit++;\n\t\t\t}\n\t\t\t\n\t\t\tdata.clear();\n\t\t\tit = t_data.begin();\n\t\t\twhile (it->div_p != 2){\n\t\t\t\tit++;\n\t\t\t}\n\t\t\twhile (it != t_data.end()){\n\t\t\t\tdata.push_back(*it);\n\t\t\t\tit++;\n\t\t\t}\n\t\t\tit = t_data.begin();\n\t\t\twhile (it->div_p != 1){\n\t\t\t\tit++;\n\t\t\t}\n\t\t\twhile (it->div_p == 1){\n\t\t\t\tdata.push_back(*it);\n\t\t\t\tit++;\n\t\t\t}\n\t\t\tit = t_data.begin();\n\t\t\twhile (it->div_p == 0){\n\t\t\t\tdata.push_back(*it);\n\t\t\t\tit++;\n\t\t\t}\n\t\t\t\n\t\t}\n\t\t\n\t\t\n\t\tint sum = 0;\n\t\tint count = 0;\n\t\tans = 0;\n\t\tit = data.begin();\n\t\twhile (sum < p){\n\t\t\tsum += it->n;\n\t\t\tit++;\n\t\t}\n\t\t\n\t\t\n\t\tint end;\n\t\tif (sum >= p){\n\t\t\tit--;\n\t\t\tend = it->s + it->n - 1;\n\t\t\tfor (int i = 0; i < sum - p + 1; i++){\n\t\t\t\tif (end - i <= r){\n\t\t\t\t\tans++;\n\t\t\t\t}\n\t\t\t\tcount++;\n\t\t\t}\n\t\t\tit++;\n\t\t}\n\t\twhile (p + count <= q){\n\t\t\tfor (int i = 0; i < it->n && p + count <= q; i++){\n\t\t\t\tif (it->s + i <= r){\n\t\t\t\t\tans++;\n\t\t\t\t}\n\t\t\t\tcount++;\n\t\t\t}\n\t\t\tit++;\n\t\t}\n\t\t\n\t\tcout << ans << endl;\n\t\t\n\t}\n\treturn (0);\n}"
  },
  {
    "language": "C++",
    "code": "#include <iostream>\n#include <algorithm>\n#include <utility>\n#include <vector>\n#include <list>\n#include <map>\n#include <set>\n#include <queue>\n#include <stack>\n#include <string>\n#include <sstream>\n#include <cstring>\n#include <cstdlib>\n\nusing namespace std;\n\n#define ALL(c) c.begin(),c.end()\n#define RALL(c) c.rbegin(),c.rend()\n#define REP(i,x,y) for(int i=(x);i<(y);++i)\n#define MP(a,b) make_pair((a),(b))\n#define F_ first\n#define S_ second\n\ntypedef long long int lli;\ntypedef pair<int,int> Pi;\n\nconst int INF=100000000;\nconst long long int INF_=100000000000000000;\n\nstruct Segment{\n\tint s,e,size;\n\tSegment(int a,int b,int c):s(a),e(b),size(c){}\n};\n\nvoid Split(vector<Segment> *state,int i,int x,int y){\n\t{\n\t\tint s=0;\n\t\tbool flag=true;\n\t\tREP(j,0,state[i-1].size()){\n\t\t\ts+=state[i-1][j].size;\n\t\t\tif(y<s){\n\t\t\t\tif(flag){\n\t\t\t\t\tstate[i].push_back(Segment(state[i-1][j].s+state[i-1][j].size-(s-y),state[i-1][j].e,state[i-1][j].e-(state[i-1][j].s+state[i-1][j].size-(s-y))+1));\n\t\t\t\t\tflag=false;\n\t\t\t\t}else{\n\t\t\t\t\tstate[i].push_back(state[i-1][j]);\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t}\n\t{\n\t\tint s=0;\n\t\tbool flag=true;\n\t\tREP(j,0,state[i-1].size()){\n\t\t\ts+=state[i-1][j].size;\n\t\t\tif(y<=s){\n\t\t\t\tif(flag){\n\t\t\t\t\tstate[i].push_back(Segment(state[i-1][j].s+state[i-1][j].size-(s-x),state[i-1][j].e-(s-y),state[i-1][j].e-(s-y)-(state[i-1][j].s+state[i-1][j].size-(s-x))+1));\n\t\t\t\t}else{\n\t\t\t\t\tstate[i].push_back(Segment(state[i-1][j].s,state[i-1][j].e-(s-y),state[i-1][j].s-(state[i-1][j].e-(s-y))+1));\n\t\t\t\t}\n\t\t\t\tbreak;\n\t\t\t}else if(x<s){\n\t\t\t\tif(flag){\n\t\t\t\t\tstate[i].push_back(Segment(state[i-1][j].s+state[i-1][j].size-(s-x),state[i-1][j].e,state[i-1][j].e-(state[i-1][j].s+state[i-1][j].size-(s-x))+1));\n\t\t\t\t\tflag=false;\n\t\t\t\t}else{\n\t\t\t\t\tstate[i].push_back(state[i-1][j]);\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t}\n\t{\n\t\tint s=0;\n\t\tREP(j,0,state[i-1].size()){\n\t\t\ts+=state[i-1][j].size;\n\t\t\tif(x<=s){\n\t\t\t\tstate[i].push_back(Segment(state[i-1][j].s,state[i-1][j].s+state[i-1][j].size-(s-x)-1,state[i-1][j].s+state[i-1][j].size-(s-x)-1-state[i-1][j].s+1));\n\t\t\t\tbreak;\n\t\t\t}else {\n\t\t\t\tstate[i].push_back(state[i-1][j]);\n\t\t\t}\n\t\t}\n\t}\n}\n\nint main(){\n\tint N;\n\twhile(cin>>N&&N){\n\t\tint M,P,Q,R;\n\t\tcin >> M >> P >> Q >> R;\n\t\tvector<int> X(M),Y(M);\n\t\tREP(i,0,M) cin >> X[i] >> Y[i];\n\t\tvector<Segment> state[5001];\n\t\tstate[0].push_back(Segment{1,N,N});\n\t\t//cout << endl;\n\t\tREP(i,1,M+1){\n\t\t\tSplit(state,i,X[i-1],Y[i-1]);\n\t\t\t/*\n\t\t\tREP(j,0,state[i].size()){\n\t\t\t\tcout << state[i][j].s << ' ' << state[i][j].e << ' ' << state[i][j].size << endl;\n\t\t\t}\n\t\t\tcout << endl;\n\t\t\t*/\n\t\t}\n\t\tint ans=0;\n\t\tint s=0;\n\t\tbool flag=true;\n\t\tREP(i,0,state[M].size()){\n\t\t\ts+=state[M][i].size;\n\t\t\tint tmp=0;\n\t\t\tif(Q<=s){\n\t\t\t\tif(R<state[M][i].s) break;\n\t\t\t\tif(flag){\n\t\t\t\t\ttmp=min(R,state[M][i].s+state[M][i].size-(s-Q)-1)-(state[M][i].s+state[M][i].size-(s-P)-1)+1;\n\t\t\t\t}else{\n\t\t\t\t\ttmp=min(R,state[M][i].s+state[M][i].size-(s-Q)-1)-state[M][i].s+1;\n\t\t\t\t}\n\t\t\t\tans+=tmp;\n\t\t\t\tbreak;\n\t\t\t}else if(P<=s){\n\t\t\t\tif(flag){\n\t\t\t\t\tif(R>=state[M][i].s) tmp=min(R,state[M][i].e)-(state[M][i].s+state[M][i].size-(s-P)-1)+1;\n\t\t\t\t\tflag=false;\n\t\t\t\t}else{\n\t\t\t\t\tif(R>=state[M][i].s) tmp+=min(R,state[M][i].e)-state[M][i].s+1;\n\t\t\t\t}\n\t\t\t\tans+=tmp;\n\t\t\t}\n\t\t}\n\t\tcout << ans << endl;\n\t}\n\treturn 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include<iostream>\n#include<vector>\nusing namespace std;\nint main() {\n\tint n;\n\twhile (cin >> n&&n != 0) {\n\t\tvector<int> line;\n\t\tfor (int i = 1; i <= n; ++i) {\n\t\t\tline.push_back(i);\n\t\t}\n\t\tint time;\n\t\tcin >> time;\n\t\tint search[3];\n\t\tfor (int i = 0; i < 3; ++i) {\n\t\t\tcin >> search[i];\n\t\t}\n\t\tint act[2];\n\t\tfor (int j = 0; j < time; ++j) {\n\t\t\tvector<int> dommy;\n\t\t\tfor (int i = 0; i < 2; ++i) {\n\t\t\t\tcin >> act[i];\n\t\t\t}\n\t\t\tdommy.insert(dommy.end(), line.begin() + act[1], line.end());\n\t\t\tdommy.insert(dommy.end(), line.begin() + act[0], line.begin() + act[1]);\n\t\t\tdommy.insert(dommy.end(), line.begin(), line.begin() + act[0]);\n\t\t\tline.clear();\n\t\t\tline = dommy;\n\t\t}\n\t\tint answer = 0;\n\t\tfor (int i = search[0] - 1; i < search[1]; ++i) {\n\t\t\tif (line[i] <= search[2]) {\n\t\t\t\t++answer;\n\t\t\t}\n\t\t}\n\t\tcout << answer << endl;\n\t}\n\treturn 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include <cstdio>\n#include <cstdlib>\n#include <cstring>\n#include <cmath>\n#include <climits>\n#include <iostream>\n#include <vector>\n#include <string>\n#include <sstream>\n#include <algorithm>\n#include <utility>\n#include <set>\n#include <map>\n#include <stack>\n#include <queue>\n#include <deque>\n#include <functional>\n\nusing namespace std;\n\n#define fst first\n#define scd second\n#define PB push_back\n#define MP make_pair\n#define all(a) a.begin(),a.end()\n#define rall(a) a.rbegin(),a.rend()\n#define omajinai ios::sync_with_stdio(false);cin.tie(0)\n#define rep(i,x) for(int i=0;i<(int)(x);++i)\n#define rep1(i,x) for(int i=1;i<=(int)(x);++i)\n\nusing ll=long long;\nusing ld=long double;\nusing vi=vector<int>;\nusing vvi=vector<vi>;\nusing pii=pair<int, int>;\nusing vpii=vector<pii>;\n\ntemplate<class T,class U>ostream&operator<<(ostream&os,const pair<T,U>p){os<<\"(\"<<p.fst<<\", \"<<p.scd<<\")\";return os;}\ntemplate<class T>ostream&operator<<(ostream&os,const vector<T>v){rep(i,v.size()){if(i)os<<\", \";os<<v[i];}return os;}\ntemplate<typename T>T&max(T&a,T&b){if(a>=b)return a;return b;}\ntemplate<typename T>T&min(T&a,T&b){if(a < b)return a;return b;}\ntemplate<typename T>bool chmax(T&a,T b){if(a < b){a=b;return true;}return false;}\ntemplate<typename T>bool chmin(T&a,T b){if(a > b){a=b;return true;}return false;}\n\nconstexpr int inf = 1e9;\nconstexpr ll linf = 3e18;\nconstexpr double eps = 1e-9;\n\nint n, m, p, q, r;\n\nint calc(pii seg, int n) // n=seg.fst????????????????????????\n{\n    int len = seg.scd - seg.fst + 1; // seg?????????\n\n    if (n < p && p <= n + len - 1) {\n        int a = (n + len - 1) - p;\n\n        return calc(pii(seg.scd - a, seg.scd), p);\n    }\n\n    if (p <= n && n + len - 1 <= q) {\n        return max(min(r - seg.fst + 1, len), 0);\n    }\n\n    if (n <= q && q < n + len - 1) {\n        int a = q - n;\n\n        return calc(pii(seg.fst, seg.fst + a), n);\n    }\n\n    return 0;\n}\n\nint main()\n{\n    omajinai;\n\n    while (cin >> n >> m >> p >> q >> r, n) {\n        deque<pii> dat;\n\n        dat.push_back(pii(1, n));\n\n        rep(_, m) {\n            int x, y; cin >> x >> y;\n\n            int sum = 0;\n\n            vpii Top, Mid, Bottom;\n\n            // Top?????????\n            while (true) {\n                pii a = dat.front();\n\n                int v = a.scd - a.fst + 1;\n\n                if (sum + v >= x) {\n                    int dif = x - sum-1;\n\n                    sum += dif + 1;\n\n                    Top.push_back(pii(a.fst, a.fst + dif));\n\n                    dat.pop_front();\n\n                    if (a.fst + dif + 1 <= a.scd) dat.push_front(pii(a.fst + dif + 1, a.scd));\n\n                    break;\n                } else {\n                    Top.PB(a);\n                    sum += v;\n                }\n\n                dat.pop_front();\n            }\n\n            // Mid?????????\n            while (true) {\n                pii a = dat.front();\n\n                int v = a.scd - a.fst + 1;\n\n                if (sum + v >= y) {\n                    int dif = y - sum-1;\n\n                    sum += dif + 1;\n\n                    Mid.push_back(pii(a.fst, a.fst + dif));\n\n                    dat.pop_front();\n\n                    if (a.fst + dif + 1 <= a.scd) dat.push_front(pii(a.fst + dif + 1, a.scd));\n\n                    break;\n                } else {\n                    Mid.PB(a);\n                    sum += v;\n                }\n                dat.pop_front();\n            }\n\n            // Bottom?????????\n            while (true) {\n                pii a = dat.front();\n\n                int v = a.scd - a.fst + 1;\n\n                if (sum + v == n) {\n                    sum += v;\n\n                    Bottom.push_back(pii(a.fst, a.scd));\n\n                    dat.pop_front();\n\n                    break;\n                } else {\n                    Bottom.PB(a);\n                    sum += v;\n                }\n\n                dat.pop_front();\n            }\n\n            rep(i, Bottom.size()) dat.push_back(Bottom[i]);\n            rep(i, Mid.size()) dat.push_back(Mid[i]);\n            rep(i, Top.size()) dat.push_back(Top[i]);\n        }\n\n        int sum = 1;\n        int ans = 0;\n\n        for (pii a : dat) {\n            ans += calc(a, sum);\n            sum += a.scd - a.fst + 1;\n        }\n\n        cout << ans << endl;\n    }\n}"
  },
  {
    "language": "C++",
    "code": "#include<iostream>\n#include<vector>\n#include<algorithm>\n#include<cassert>\n#include<cstdio>\nusing namespace std;\n\nstruct P\n{\n  int s,e;\n  P(int s,int e):s(s),e(e){}\n};\n\nvoid shuffle(vector<P>& vec,int x,int y,int n)\n{\n  vector<P> ins;\n  for(int i=0;i<vec.size();i++)\n    {\n      if(vec[i].e <= x)\n\t{\n\t  vec[i].s += (n-x),vec[i].e += (n-x);\n\t}\n      else if(vec[i].s <= x && vec[i].e <= y)\n\t{\n\t  ins.push_back(P(x+1,vec[i].e));\n\t  ins[ins.size()-1].s += (n-y)-x,ins[ins.size()-1].e += (n-y)-x;\n\t  vec[i].e = x;\n\t  vec[i].s += (n-x),vec[i].e += (n-x);\n\t}\n      else if(vec[i].s <= x && vec[i].e  > y)\n\t{\n\t  ins.push_back(P(vec[i].s,x));\n\t  ins[ins.size()-1].s += (n-x),ins[ins.size()-1].e += (n-x);\n\t  ins.push_back(P(x+1,y));\n\t  ins[ins.size()-1].s += (n-y)-x,ins[ins.size()-1].e += (n-y)-x;\n\t  vec[i].s = y+1;\n\t  vec[i].s -= y,vec[i].e -= y;\n\t}\n      else if(vec[i].s  > x && vec[i].e <= y)\n\t{\n\t  vec[i].s += (n-y)-x,vec[i].e += (n-y)-x;\n\t}\n      else if(vec[i].s  > x && vec[i].s <= y && vec[i].e  > y)\n\t{\n\t  ins.push_back(P(vec[i].s,y));\n\t  ins[ins.size()-1].s += (n-y)-x, ins[ins.size()-1].e += (n-y)-x;\n\t  vec[i].s = y+1;\n\t  vec[i].s -= y,vec[i].e -= y;\n\t}\n      else if(vec[i].s  > y)\n\t{\n\t  vec[i].s -= y,vec[i].e -= y;\n\t}\n      else \n\tassert(false);\n    }\nfor(int i=0;i<ins.size();i++)\n  vec.push_back(ins[i]);\n}\n\nint main()\n{\n  int n;\n  while(scanf(\"%d\",&n),n)\n    {\n      int m;\n      scanf(\"%d\",&m);\n      int p,q,r;\n      scanf(\"%d %d %d\",&p,&q,&r);\n      vector<P> vec;\n      vec.push_back(P(1,r));\n\n      for(int i=0;i<m;i++)\n\t{\n\t  int x,y;\n\t  scanf(\"%d %d\",&x,&y);\n\t  shuffle(vec,x,y,n);\n\t}\n   \n\n      int cnt = 0;\n      for(int i=0;i<vec.size();i++)\n\t{\n\t  //cout << \"!p: \" <<vec[i].s<<\"!q : \" <<vec[i].e << endl;\n\t  //cout << \"p : \" << p << \" q : \" << q << endl;\n\t  if(vec[i].s == vec[i].e && p <= vec[i].s && vec[i].e <= q)\n\t    {\n\t      //cout << \"P1\" << endl;\n\t      cnt += 1;\n\t    }\n\t  else if(vec[i].s <= p && q <= vec[i].e)\n\t    {\n\t      //cout << \"P2\" << endl;\n\t      cnt += q-p + (vec[i].s == p?1:0) + (vec[i].e == q?1:0);\n\t    }\n\t  else if(p <= vec[i].s && vec[i].e <= q)\n\t    {\n\t      //cout << \"P3\" << endl;\n\t      cnt += vec[i].e-vec[i].s+1;\n\t    }\n\t  else if(vec[i].s <= p && vec[i].e >= p)\n\t    {\n\t      //cout << \"P4\" << endl;\n\t      cnt += vec[i].e-p+ (vec[i].s == p?1:0) + (vec[i].e == p?1:0);\n\t    }\n\t  else if(vec[i].s <= q && vec[i].e >= q)\n\t    {\n\t      //cout << \"P5\" << endl;\n\t      cnt += q-vec[i].s+ (vec[i].s == q?1:0) + (vec[i].e == q?1:0);\n\t    }\n\t\n\t  //cout << \"cnt = \" << cnt << endl;\n\t}\n      cout << cnt << endl;\n    }\n  return 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include<iostream>\n#include<sstream>\n#include<cstdio>\n#include<cstdlib>\n#include<vector>\n#include<string>\n#include<stack>\n#include<queue>\n#include<deque>\n#include<set>\n#include<map>\n#include<algorithm>\n#include<functional>\n#include<utility>\n#include<cmath>\n#include<ctime>\n#include<complex>\n\nusing namespace std;\n\n#define REP(i,s,e) for(int i=int(s);i<=int(e);i++)\n#define rep(i,n) for(int i=0;i<int(n);i++)\n\nvector<int>u1,v1,u2,v2;\nvoid f(int x,int y,vector<int>& u1,vector<int>& v1,vector<int>& u2,vector<int>& v2){\n\tint c=0; int a,b,c1,c2;\n\trep(i,u1.size()){\n\t\tc+=v1[i]-u1[i]+1;\n\t\tif(c>=x){\n\t\t\ta=i; c1=c; break;\n\t\t}\n\t}\n\tc=0;\n\trep(i,u1.size()){\n\t\tc+=v1[i]-u1[i]+1;\n\t\tif(c>=y){\n\t\t\tb=i; c2=c; break;\n\t\t}\n\t}\n\n\n\tif(c2!=y){\n\t\tu2.push_back(v1[b]-(c2-y)+1);\n\t\tv2.push_back(v1[b]);\n\n\t\tREP(i,b+1,u1.size()-1){\n\t\t\tu2.push_back(u1[i]);\n\t\t\tv2.push_back(v1[i]);\n\t\t}\n\t}\n\telse{\n\t\tREP(i,b+1,u1.size()-1){\n\t\t\tu2.push_back(u1[i]);\n\t\t\tv2.push_back(v1[i]);\n\t\t}\n\t}\n\n\n    if(a!=b){\n\n\tif(c1!=x){\n\t\tu2.push_back(v1[a]-(c1-x)+1);\n\t\tv2.push_back(v1[a]);\n\n\t\tREP(i,a+1,b-1){\n\t\t\tu2.push_back(u1[i]);\n\t\t\tv2.push_back(v1[i]);\n\t\t}\n\t\tu2.push_back(u1[b]);\n\t\tv2.push_back(v1[b]-(c2-y));\n\t\t}\n\telse{\n\t\tREP(i,a+1,b-1){\n\t\t\tu2.push_back(u1[i]);\n\t\t\tv2.push_back(v1[i]);\n\t\t}\n\t\tu2.push_back(u1[b]);\n\t\tv2.push_back(v1[b]-(c2-y));\n\t}\n    }\n\n    else{\n\n    \tu2.push_back(v1[a]-(c1-x)+1);\n    \tv2.push_back(v1[b]-(c2-y));\n    }\n\n\n\t\tREP(i,0,a-1){\n\t\t\tu2.push_back(u1[i]);\n\t\t\tv2.push_back(v1[i]);\n\t\t}\n\t\tu2.push_back(u1[a]);\n\t\tv2.push_back(v1[a]-(c1-x));\n\n}\n\nint main(){\n\n\tint m,n,p,q,r,x,y;\n\n\twhile(1){\n\n\t\tcin >> n;\n\t\tif(n==0) break;\n\t\tcin >> m >> p >> q >> r;\n\n\n\t\tREP(i,1,m){\n\n\t\t\tcin >> x >> y;\n\n\t\t\tif(i==1){\n\t\t\t\tu1.push_back(y+1); v1.push_back(n);\n\t\t\t\tu1.push_back(x+1); v1.push_back(y);\n\t\t\t\tu1.push_back(1); v1.push_back(x);\n\t\t\t}\n\t\t\telse if(i%2==0){ u2.clear(); v2.clear(); f(x,y,u1,v1,u2,v2);}\n\t\t\telse if(i%2==1){ u1.clear(); v1.clear(); f(x,y,u2,v2,u1,v1);}\n\t\t}\n\n\n\t\tint s=0; int c=0; int a,b,c1,c2;\n\t\tif(m%2==0){\n\n\t\t\trep(i,u2.size()){\n\t\t\t\tc+=v2[i]-u2[i]+1;\n\t\t\t\tif(c>=p){\n\t\t\t\t\ta=i; c1=c; break;\n\t\t\t\t}\n\t\t\t}\n\t\t\tc=0;\n\t\t\trep(i,u2.size()){\n\t\t\t\tc+=v2[i]-u2[i]+1;\n\t\t\t\tif(c>=q){\n\t\t\t\t\tb=i; c2=c; break;\n\t\t\t\t}\n\t\t\t}\n\n\t\t\tif(a!=b){\n\n\t\t\tREP(i,v2[a]-(c1-p),v2[a])\n\t\t\tif(i<=r) s++;\n\t\t\tREP(i,a+1,b-1){\n\t\t\t\tREP(j,u2[i],v2[i]){\n\t\t\t\tif(j<=r) s++;\n\t\t\t\t}\n\t\t\t}\n\t\t\tREP(i,u2[b],v2[b]-(c2-q))\n\t\t\tif(i<=r) s++;\n\n\t\t\t}\n\n\t\t\telse{\n\n\t\t\tREP(i,v2[a]-(c1-p),v2[a]-(c2-q))\n\t\t\tif(i<=r) s++;\n\t\t\t}\n\n\t\t\tcout << s << endl;\n\n\t\t}\n\n\n\t\telse{\n\n\t\t\trep(i,u1.size()){\n\t\t\t\tc+=v1[i]-u1[i]+1;\n\t\t\t\tif(c>=p){\n\t\t\t\t\ta=i; c1=c; break;\n\t\t\t\t}\n\t\t\t}\n\t\t\tc=0;\n\t\t\trep(i,u1.size()){\n\t\t\t\tc+=v1[i]-u1[i]+1;\n\t\t\t\tif(c>=q){\n\t\t\t\t\tb=i; c2=c; break;\n\t\t\t\t}\n\t\t\t}\n\n\t\t\tif(a!=b){\n\n\t\t\tREP(i,v1[a]-(c1-p),v1[a])\n\t\t\tif(i<=r) s++;\n\t\t\tREP(i,a+1,b-1){\n\t\t\t\tREP(j,u1[i],v1[i]){\n\t\t\t\tif(j<=r) s++;\n\t\t\t\t}\n\t\t\t}\n\t\t\tREP(i,u1[b],v1[b]-(c2-q))\n\t\t\tif(i<=r) s++;\n\n\t\t\t}\n\n\t\t\telse{\n\n\t\t\tREP(i,v1[a]-(c1-p),v1[a]-(c2-q))\n\t\t\tif(i<=r) s++;\n\t\t\t}\n\n\t\t\tcout << s << endl;\n\n\t\t}\n\n\t\tu1.clear(); v1.clear(); u2.clear(); v2.clear();\n\n\t}\n\n\treturn 0;\n}"
  },
  {
    "language": "C++",
    "code": "//  4???27??\\  ????????????0535 ; ?????£?????????\n// http://judge.u-aizu.ac.jp/onlinejudge/description.jsp?id=0536\n\n#include <iostream>\n#define NUM 100000\nusing namespace std;\n\nint main(){\n\n  int n;//?????????????????°\n  int m;//?????£??????????????°\n  int p,q;//p ???????????? q ?????????????????????\n  int r;// r??\\?????????????????????????????????\n  register int x[5000],y[5000];//????????????????????´???\n  register int card[NUM];\n  int i;\n  int A[NUM];\n  int B[NUM];\n  int C[NUM];\n\n  do{\n    int j = 0;\n    register int count = 1;\n    register int step = 1;\n    register int red = 1;\n    register int blue = 1;\n    register int green = 0;\n\n    cin >> n;\n    cin >> m;\n    cin >> p >> q >> r;\n\n    if (!n){\n      break;\n    }\n\n    for (i=0; i < m; i++){\n      cin >> x[i] >> y[i];\n    }\n\n    while (j < m){\n\n      for (i=1; i <= n; i++ ){//??°?????£??\\\n        card[i] = i;\n      }\n\n      for (i=1 ; i <= x[j] ;i++ ){//????????????1~X???????????§\n        A[i] = card[i];\n      }\n\n      while (i <= y[j]){//????????????X+1~Y???????????§\n        B[count] = card[i];\n        i++;\n        count++;\n      }\n\n      while (i <= n){//????????????Y+1~n???????????§\n        C[step] = card[i];\n        i++;\n        step++;\n      }\n\n      for (i=1; i <= (n - y[j]); i++ ){//C?????°?????£??\\\n        card[i] = C[i];\n      }\n\n      while (red <= count){//B?????°?????£??\\\n        card[i] = B[red];\n        i++;\n        red++;\n      }\n\n      while (blue <= step){//A?????°?????£??\\\n        card[i] = A[blue];\n        i++;\n        blue++;\n      }\n      j++;\n    }\n\n    for (i=p; i <= q; i++){\n      if (card[i] <= r){\n        green++;\n      }\n    }\n\n    cout << green << endl;\n  } while (n);\n\n  return 0;\n\n}"
  },
  {
    "language": "C++",
    "code": "#include <iostream>\n#include <vector>\n#include <algorithm>\nusing namespace std;\n\nvoid copyCards(const vector<bool> &src, vector<bool> &dst, int src_i, int dst_i, int n) {\n    for (int i = 0; i < n; i++) {\n        dst[dst_i + i] = src[src_i + i];\n    }\n}\n\nint countTrue(const vector<bool> &v, int p, int q) {\n    int counter = 0;\n    for (int i = p; i <= q; i++) {\n        if (v[i]) {\n            counter++;\n        }\n    }\n    return counter;\n}\n\nint main () {\n    int n;\n    while (cin >> n, n) {\n        int m, p, q, r;\n        cin >> m >> p >> q >> r;\n        vector<int> xs(m), ys(m);\n        for (int i = 0; i < m; i++) {\n            cin >> xs[i] >> ys[i];\n        }\n\n        vector<bool> cards_a(n+1), cards_b(n+1);\n        fill(cards_a.begin(), cards_a.begin() + r + 1, true);\n        fill(cards_a.begin() + r + 2, cards_a.end(), false);\n\n        for (int i = 0; i < m; i++) {\n            if (i % 2 == 0) {\n                copyCards(cards_a, cards_b, 1, n - xs[i] + 1, xs[i]);\n                copyCards(cards_a, cards_b, xs[i] + 1, n - ys[i] + 1, ys[i] - xs[i]);\n                copyCards(cards_a, cards_b, ys[i] + 1, 1, n - ys[i]);\n            } else {\n                copyCards(cards_b, cards_a, 1, n - xs[i] + 1, xs[i]);\n                copyCards(cards_b, cards_a, xs[i] + 1, n - ys[i] + 1, ys[i] - xs[i]);\n                copyCards(cards_b, cards_a, ys[i] + 1, 1, n - ys[i]);\n            }\n        }\n        if (m % 2 == 0) {\n            cout << countTrue(cards_a, p, q) << endl;\n        } else {\n            cout << countTrue(cards_b, p, q) << endl;\n        }\n    }\n}"
  },
  {
    "language": "C++",
    "code": "#include <stdio.h>\n#include <cmath>\n#include <algorithm>\n#include <cfloat>\n#include <stack>\n#include <queue>\n#include <vector>\n#include <string>\n#include <iostream>\ntypedef long long int ll;\ntypedef unsigned long long int ull;\n#define BIG_NUM 2000000000\n#define MOD 1000000007\n#define EPS 0.000000001\nusing namespace std;\n\nstruct Data{\n\tData(int arg_left_index,int arg_right_index){\n\t\tleft_index = arg_left_index;\n\t\tright_index = arg_right_index;\n\t}\n\tint left_index,right_index;\n};\n\nstruct Info{\n\tint length;\n\tvector<Data> children;\n};\n\n\nint N,M,P,Q,R;\n\nvoid func(){\n\n\tscanf(\"%d\",&M);\n\n\tscanf(\"%d %d %d\",&P,&Q,&R);\n\n\tInfo info[3],work[3];\n\n\tint a,b;\n\n\tscanf(\"%d %d\",&a,&b);\n\n\tinfo[0].children.push_back(Data(b+1,N));\n\tinfo[1].children.push_back(Data(a+1,b));\n\tinfo[2].children.push_back(Data(1,a));\n\n\tfor(int i = 0; i < 3; i++){\n\t\tinfo[i].length = info[i].children[0].right_index-info[i].children[0].left_index+1;\n\t}\n\n\tint tmp,a_last_info,a_last_child;\n\n\tfor(int loop = 1; loop <= M; loop++){\n\t\tif(loop < M){\n\t\t\tscanf(\"%d %d\",&a,&b);\n\t\t}else{\n\t\t\ta = P-1;\n\t\t\tb = Q;\n\t\t}\n\n\t\tif(a <= info[0].length){\n\n\t\t\ttmp = 0;\n\t\t\tfor(int i = 0; i < info[0].children.size(); i++){\n\t\t\t\tif(tmp + info[0].children[i].right_index-info[0].children[i].left_index+1 < a){\n\t\t\t\t\ttmp += info[0].children[i].right_index-info[0].children[i].left_index+1;\n\t\t\t\t\twork[0].children.push_back(info[0].children[i]);\n\n\t\t\t\t}else{\n\t\t\t\t\ta_last_child = i;\n\t\t\t\t\tif(tmp + info[0].children[i].right_index-info[0].children[i].left_index+1 == a){\n\t\t\t\t\t\twork[0].children.push_back(info[0].children[i]);\n\t\t\t\t\t}else{\n\t\t\t\t\t\twork[0].children.push_back(Data(info[0].children[i].left_index,info[0].children[i].left_index+(a-tmp)-1));\n\t\t\t\t\t\twork[1].children.push_back(Data(info[0].children[i].left_index+(a-tmp),info[0].children[i].right_index));\n\t\t\t\t\t}\n\t\t\t\t\tbreak;\n\t\t\t\t}\n\t\t\t}\n\n\t\t\ta_last_info = 0;\n\n\t\t}else if(a <= info[0].length+info[1].length){\n\n\t\t\tfor(int i = 0; i < info[0].children.size(); i++){\n\t\t\t\twork[0].children.push_back(info[0].children[i]);\n\t\t\t}\n\t\t\ttmp = info[0].length;\n\n\t\t\tfor(int i = 0; i < info[1].children.size(); i++){\n\t\t\t\tif(tmp + info[1].children[i].right_index-info[1].children[i].left_index+1 < a){\n\t\t\t\t\ttmp += info[1].children[i].right_index-info[1].children[i].left_index+1;\n\t\t\t\t\twork[0].children.push_back(info[1].children[i]);\n\n\t\t\t\t}else{\n\t\t\t\t\ta_last_child = i;\n\t\t\t\t\tif(tmp + info[1].children[i].right_index-info[1].children[i].left_index+1 == a){\n\t\t\t\t\t\twork[0].children.push_back(info[1].children[i]);\n\t\t\t\t\t}else{\n\t\t\t\t\t\twork[0].children.push_back(Data(info[1].children[i].left_index,info[1].children[i].left_index+(a-tmp)-1));\n\t\t\t\t\t\twork[1].children.push_back(Data(info[1].children[i].left_index+(a-tmp),info[1].children[i].right_index));\n\t\t\t\t\t}\n\t\t\t\t\tbreak;\n\t\t\t\t}\n\t\t\t}\n\n\t\t\ta_last_info = 1;\n\n\t\t}else{\n\n\t\t\tfor(int i = 0; i < info[0].children.size(); i++){\n\t\t\t\twork[0].children.push_back(info[0].children[i]);\n\t\t\t}\n\n\t\t\tfor(int i = 0; i < info[1].children.size(); i++){\n\t\t\t\twork[0].children.push_back(info[1].children[i]);\n\t\t\t}\n\t\t\ttmp = info[0].length + info[1].length;\n\n\t\t\tfor(int i = 0; i < info[2].children.size(); i++){\n\t\t\t\tif(tmp + info[2].children[i].right_index-info[2].children[i].left_index+1 < a){\n\t\t\t\t\ttmp += info[2].children[i].right_index-info[2].children[i].left_index+1;\n\t\t\t\t\twork[0].children.push_back(info[2].children[i]);\n\n\t\t\t\t}else{\n\t\t\t\t\ta_last_child = i;\n\t\t\t\t\tif(tmp + info[2].children[i].right_index-info[2].children[i].left_index+1 == a){\n\t\t\t\t\t\twork[0].children.push_back(info[2].children[i]);\n\t\t\t\t\t}else{\n\t\t\t\t\t\twork[0].children.push_back(Data(info[2].children[i].left_index,info[2].children[i].left_index+(a-tmp)-1));\n\t\t\t\t\t\twork[1].children.push_back(Data(info[2].children[i].left_index+(a-tmp),info[2].children[i].right_index));\n\t\t\t\t\t}\n\t\t\t\t\tbreak;\n\t\t\t\t}\n\t\t\t}\n\t\t\ta_last_info = 2;\n\t\t}\n\n\n\t\tif(b <= info[0].length){\n\n\t\t\ttmp = 0;\n\t\t\tfor(int i = 0; i <= a_last_child; i++){\n\t\t\t\ttmp += info[0].children[i].right_index-info[0].children[i].left_index+1;\n\t\t\t}\n\n\t\t\tfor(int i = a_last_child+1; i < info[0].children.size(); i++){\n\t\t\t\tif(tmp + info[0].children[i].right_index-info[0].children[i].left_index+1 < b){\n\t\t\t\t\ttmp += info[0].children[i].right_index-info[0].children[i].left_index+1;\n\t\t\t\t}else{\n\n\t\t\t\t\tif(tmp + info[0].children[i].right_index-info[0].children[i].left_index+1 == b){\n\t\t\t\t\t\tfor(int k = a_last_child+1; k <= i; k++){\n\t\t\t\t\t\t\twork[1].children.push_back(info[0].children[k]);\n\t\t\t\t\t\t}\n\t\t\t\t\t\tfor(int k = i+1; k < info[0].children.size(); k++){\n\t\t\t\t\t\t\twork[2].children.push_back(info[0].children[k]);\n\t\t\t\t\t\t}\n\n\t\t\t\t\t}else{\n\t\t\t\t\t\tfor(int k = a_last_child+1; k <= i-1; k++){\n\t\t\t\t\t\t\twork[1].children.push_back(info[0].children[k]);\n\t\t\t\t\t\t}\n\t\t\t\t\t\twork[1].children.push_back(Data(info[0].children[i].left_index,info[0].children[i].left_index+(b-tmp)-1));\n\t\t\t\t\t\twork[2].children.push_back(Data(info[0].children[i].left_index+(b-tmp),info[0].children[i].right_index));\n\t\t\t\t\t\tfor(int k = i+1; k < info[0].children.size(); k++){\n\t\t\t\t\t\t\twork[2].children.push_back(info[0].children[k]);\n\t\t\t\t\t\t}\n\t\t\t\t\t}\n\n\t\t\t\t\tfor(int k = 0; k < info[1].children.size(); k++){\n\t\t\t\t\t\twork[2].children.push_back(info[1].children[k]);\n\t\t\t\t\t}\n\t\t\t\t\tfor(int k = 0; k < info[2].children.size(); k++){\n\t\t\t\t\t\twork[2].children.push_back(info[2].children[k]);\n\t\t\t\t\t}\n\t\t\t\t\tbreak;\n\t\t\t\t}\n\t\t\t}\n\n\n\t\t}else if(b <= info[0].length+info[1].length){\n\n\t\t\ttmp = info[0].length;\n\t\t\tif(a_last_info == 0){\n\n\t\t\t\tfor(int i = a_last_child+1;i < info[0].children.size(); i++){\n\t\t\t\t\twork[1].children.push_back(info[0].children[i]);\n\t\t\t\t}\n\t\t\t\ta_last_child = -1;\n\t\t\t}else{\n\t\t\t\tfor(int i = 0; i <= a_last_child; i++){\n\t\t\t\t\ttmp += info[1].children[i].right_index-info[1].children[i].left_index+1;\n\t\t\t\t}\n\t\t\t}\n\n\n\t\t\tfor(int i = a_last_child+1; i < info[1].children.size(); i++){\n\t\t\t\tif(tmp + info[1].children[i].right_index-info[1].children[i].left_index + 1 < b){\n\t\t\t\t\ttmp += info[1].children[i].right_index-info[1].children[i].left_index+1;\n\t\t\t\t}else{\n\n\t\t\t\t\tif(tmp + info[1].children[i].right_index-info[1].children[i].left_index + 1 == b){\n\t\t\t\t\t\tfor(int k = a_last_child+1; k <= i; k++){\n\t\t\t\t\t\t\twork[1].children.push_back(info[1].children[k]);\n\t\t\t\t\t\t}\n\t\t\t\t\t\tfor(int k = i+1; k < info[1].children.size(); k++){\n\t\t\t\t\t\t\twork[2].children.push_back(info[1].children[k]);\n\t\t\t\t\t\t}\n\n\t\t\t\t\t}else{\n\t\t\t\t\t\tfor(int k = a_last_child+1; k <= i-1; k++){\n\t\t\t\t\t\t\twork[1].children.push_back(info[1].children[k]);\n\t\t\t\t\t\t}\n\t\t\t\t\t\twork[1].children.push_back(Data(info[1].children[i].left_index,info[1].children[i].left_index+(b-tmp)-1));\n\t\t\t\t\t\twork[2].children.push_back(Data(info[1].children[i].left_index+(b-tmp),info[1].children[i].right_index));\n\t\t\t\t\t\tfor(int k = i+1; k < info[1].children.size(); k++){\n\t\t\t\t\t\t\twork[2].children.push_back(info[1].children[k]);\n\t\t\t\t\t\t}\n\t\t\t\t\t}\n\t\t\t\t\tfor(int k = 0; k < info[2].children.size(); k++){\n\t\t\t\t\t\twork[2].children.push_back(info[2].children[k]);\n\t\t\t\t\t}\n\t\t\t\t\tbreak;\n\t\t\t\t}\n\t\t\t}\n\n\t\t}else{\n\n\t\t\ttmp = info[0].length+info[1].length;\n\t\t\tif(a_last_info == 0){\n\n\t\t\t\tfor(int i = a_last_child+1; i < info[0].children.size(); i++){\n\t\t\t\t\twork[1].children.push_back(info[0].children[i]);\n\t\t\t\t}\n\t\t\t\tfor(int i = 0; i < info[1].children.size(); i++){\n\t\t\t\t\twork[1].children.push_back(info[1].children[i]);\n\t\t\t\t}\n\t\t\t\ta_last_child = -1;\n\t\t\t}else if(a_last_info == 1){\n\n\t\t\t\tfor(int i = a_last_child+1; i < info[1].children.size(); i++){\n\t\t\t\t\twork[1].children.push_back(info[1].children[i]);\n\t\t\t\t}\n\t\t\t\ta_last_child = -1;\n\t\t\t}else{\n\t\t\t\tfor(int i = 0; i <= a_last_child; i++){\n\t\t\t\t\ttmp += info[2].children[i].right_index-info[2].children[i].left_index+1;\n\t\t\t\t}\n\t\t\t}\n\n\t\t\tfor(int i = a_last_child+1; i < info[2].children.size(); i++){\n\t\t\t\tif(tmp + info[2].children[i].right_index-info[2].children[i].left_index + 1 < b){\n\t\t\t\t\ttmp += info[2].children[i].right_index-info[2].children[i].left_index+1;\n\t\t\t\t}else{\n\n\t\t\t\t\tif(tmp + info[2].children[i].right_index-info[2].children[i].left_index + 1 == b){\n\t\t\t\t\t\tfor(int k = a_last_child+1; k <= i; k++){\n\t\t\t\t\t\t\twork[1].children.push_back(info[2].children[k]);\n\t\t\t\t\t\t}\n\t\t\t\t\t\tfor(int k = i+1; k < info[2].children.size(); k++){\n\t\t\t\t\t\t\twork[2].children.push_back(info[2].children[k]);\n\t\t\t\t\t\t}\n\n\t\t\t\t\t}else{\n\t\t\t\t\t\tfor(int k = a_last_child+1; k <= i-1; k++){\n\t\t\t\t\t\t\twork[1].children.push_back(info[2].children[k]);\n\t\t\t\t\t\t}\n\t\t\t\t\t\twork[1].children.push_back(Data(info[2].children[i].left_index,info[2].children[i].left_index+(b-tmp)-1));\n\t\t\t\t\t\twork[2].children.push_back(Data(info[2].children[i].left_index+(b-tmp),info[2].children[i].right_index));\n\t\t\t\t\t\tfor(int k = i+1; k < info[2].children.size(); k++){\n\t\t\t\t\t\t\twork[2].children.push_back(info[2].children[k]);\n\t\t\t\t\t\t}\n\t\t\t\t\t}\n\t\t\t\t\tbreak;\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\n\t\tfor(int i = 0; i < 3; i++){\n\t\t\tinfo[i].children.clear();\n\t\t}\n\n\t\tfor(int i = 0; i < work[2].children.size(); i++){\n\t\t\tinfo[0].children.push_back(work[2].children[i]);\n\t\t}\n\n\t\tfor(int i = 0; i < work[1].children.size(); i++){\n\t\t\tinfo[1].children.push_back(work[1].children[i]);\n\t\t}\n\n\t\tfor(int i = 0; i < work[0].children.size(); i++){\n\t\t\tinfo[2].children.push_back(work[0].children[i]);\n\t\t}\n\n\t\tfor(int i = 0; i < 3; i++){\n\t\t\ttmp = 0;\n\t\t\tfor(int k = 0; k < info[i].children.size(); k++){\n\t\t\t\ttmp += info[i].children[k].right_index-info[i].children[k].left_index+1;\n\t\t\t}\n\t\t\tinfo[i].length = tmp;\n\t\t}\n\n\t\tfor(int i = 0; i < 3; i++){\n\t\t\twork[i].children.clear();\n\t\t}\n\n\t}\n\n\tint ans = 0;\n\n\tfor(int i = 0; i < info[1].children.size(); i++){\n\t\tif(info[1].children[i].left_index > R)continue;\n\n\t\tif(info[1].children[i].right_index <= R){\n\t\t\tans += info[1].children[i].right_index-info[1].children[i].left_index+1;\n\t\t}else{\n\t\t\tans += R-info[1].children[i].left_index+1;\n\t\t}\n\t}\n\n\tprintf(\"%d\\n\",ans);\n\n}\n\n\nint main(){\n\n\twhile(true){\n\t\tscanf(\"%d\",&N);\n\t\tif(N == 0)break;\n\n\t\tfunc();\n\n\t}\n\n\n\treturn 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include <algorithm>\n#include <climits>\n#include <iostream>\n#include <string>\n#include <vector>\n#include<queue>\n#include<queue>\n#define P pair<int,int>\nusing namespace std;\n\nqueue<P>operator +(queue<P>a, queue<P>b) {\n\twhile (b.size()) {\n\t\ta.push(b.front()); b.pop();\n\t}\n\treturn a;\n}\nqueue<P>L;\nint main() {\n\tint a;\n\twhile (cin >> a, a) {\n\t\tint b, c, d, e; scanf(\"%d%d%d%d\", &b, &c, &d, &e);\n\t\tqueue<P>tmp;\n\t\tswap(L, tmp);\n\t\tL.push(P(1, a));\n\t\tfor (int f = 0; f < b; f++) {\n\t\t\tint g, h; scanf(\"%d%d\", &g, &h);\n\t\t\tqueue<P>A, B, C;\n\t\t\tint sum = 0, j = 0;\n\t\t\twhile (L.size()) {\n\t\t\t\tP i = L.front(); L.pop();\n\t\t\t\tsum += i.second - i.first + 1;\n\t\t\t\tif (j < g&&sum > g) {\n\t\t\t\t\tif (j < h&&sum > h) {\n\t\t\t\t\t\tA.push(P(i.first, i.first + (g - j) - 1));\n\t\t\t\t\t\tB.push(P(i.first + (g - j), i.first + (h - j) - 1));\n\t\t\t\t\t\tC.push(P(i.first + (h - j), i.second));\n\t\t\t\t\t}\n\t\t\t\t\telse {\n\t\t\t\t\t\tA.push(P(i.first, i.first + (g - j) - 1));\n\t\t\t\t\t\tB.push(P(i.first + (g - j), i.second));\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t\telse {\n\t\t\t\t\tif (j < h&&sum > h) {\n\t\t\t\t\t\tB.push(P(i.first, i.first + (h - j) - 1));\n\t\t\t\t\t\tC.push(P(i.first + (h - j), i.second));\n\t\t\t\t\t}\n\t\t\t\t\telse {\n\t\t\t\t\t\tif (sum > h) {\n\t\t\t\t\t\t\tC.push(i);\n\t\t\t\t\t\t}\n\t\t\t\t\t\telse if (sum > g) {\n\t\t\t\t\t\t\tB.push(i);\n\t\t\t\t\t\t}\n\t\t\t\t\t\telse {\n\t\t\t\t\t\t\tA.push(i);\n\t\t\t\t\t\t}\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t\tj += i.second - i.first + 1;\n\t\t\t}\n\t\t\tL = C + B + A;\n\t\t}\n\t}\n}"
  },
  {
    "language": "C++",
    "code": "#include<iostream>\nusing namespace std;\n\ntypedef struct tagListNode{\n  struct tagListNode *next;\n  int data; //何個目までがr以下か\n  int num; //データ数\n} Talon;\n\n\nint main(){\n  int n, m, p, q, r;\n  int x, y;\n  int i;\n  Talon *firstnode, *lastnode, *thisnode, *newnode, *nextnode,*xnode, *ynode, *point,  *pnode, *qnode;\n  firstnode = lastnode = NULL;\n  while(1){\n    cin >> n;\n    if(n==0) break;\n    else{\n      cin  >> m >> p >> q >>r;\n      newnode = new Talon;\n      newnode->data = r;\n      newnode->num = n;\n      newnode->next = NULL;\n      firstnode = lastnode = newnode;\n      \n      for(i=0; i<m; i++){\n\tcin >> x >> y;\n\t//xによる分割\n\tint numcount= 0;\n\tthisnode = firstnode;\n\twhile(1){\n\t  if (numcount + thisnode->num >= x) break;\n\t  else {\n\t    numcount += thisnode->num;\n\t    thisnode = thisnode->next;\n\t  }\n\t}\n\t\n\tif(x-numcount == thisnode->num){\n\t  xnode = thisnode;\n\t}else if(x - numcount > thisnode->data){\n\t  newnode = new Talon;\n\t  newnode ->data = 0;\n\t  newnode ->num = thisnode->num - (x- numcount);\n\t  newnode ->next = thisnode ->next;\n\n\t  thisnode->num = x - numcount;\n\t  xnode = thisnode;\n\t  thisnode-> next = newnode;\n\t  if (thisnode == lastnode) lastnode = thisnode->next;\n\t}else{\n\t  newnode = new Talon;\n\t  newnode->data = thisnode->data-(x - numcount);\n\t  newnode->num = thisnode -> num - (x- numcount);\n\t  newnode->next = thisnode->next;\n\t  \n\t  thisnode->data = x - numcount;\n\t  thisnode->num = x - numcount;\n\t  xnode = thisnode;\n\t  thisnode->next = newnode;\n\t  if (thisnode == lastnode) lastnode = thisnode->next;\n\t}\n\t//yにおける分割\n\tnumcount= 0;\n\tthisnode = firstnode;\n\twhile(1){\n\t  if (numcount + thisnode->num >=y) break;\n\t  else {\n\t    numcount += thisnode->num;\n\t    thisnode = thisnode->next;\n\t  }\n\t}\n\tif(y - numcount == thisnode->num) {\n\t  ynode = thisnode;\n\t}else if(y - numcount > thisnode->data){\n\t  nextnode = thisnode->next;\n\t  thisnode->next = new Talon;\n\t  thisnode->next->data = 0;\n\t  thisnode->next->num = thisnode->num - (y- numcount);\n\t  thisnode->next->next = nextnode;\n\n\t  ynode = thisnode;\n\t  thisnode->num = y - numcount;\n\t  if (thisnode == lastnode) lastnode = thisnode->next;\n\t}\n\telse{\n\t  nextnode = thisnode->next;\n\t  thisnode->next = new Talon;\n\t  thisnode->next->data = thisnode->data - (y - numcount);\n\t  thisnode->next->num = thisnode->num - (y- numcount);\n\t  thisnode->next->next = nextnode;\n\t  \n\t  ynode = thisnode;\n\t  thisnode->data = y - numcount;\n\t  thisnode->num = y - numcount;\n\t  if (thisnode == lastnode) lastnode = thisnode->next;\n\t}\n      \n      //shuffleする\n\t\n\tpoint = ynode->next;\n\tlastnode->next = xnode->next;\n\tynode->next = firstnode;\n\txnode->next = NULL;\n\tfirstnode = point;\n\tlastnode = xnode;\n\t\n      }\n  \n      //m以下の数の数を数える\n      int numm = 0;\n      int numcountp = 0;\n      \n      thisnode = firstnode;\n      \n      while(1){\n\tif (numcountp + thisnode->num >= p) break;\n\telse {\n\t  numcountp += thisnode->num;\n\t  thisnode = thisnode->next;\n\t}\n      }\n      pnode = thisnode;\n\n      int numcountq = numcountp;\n      while(1){\n\tif (numcountq + thisnode->num >= q) break;\n\telse {\n\t  numcountq += thisnode->num;\n\t  thisnode = thisnode->next;\n\t}\n      }\n      qnode = thisnode;\n      \n      thisnode = pnode;\n      if (pnode != qnode){\n\tif (numcountp + thisnode->data >=p) {\n\t  numm += thisnode->data - (p - numcountp)+1;\n\t}\n\tnumcountp += thisnode -> num;\n\tthisnode = thisnode-> next;\n\twhile(1){\n\t  if( thisnode == qnode) break;\n\t  numm += thisnode->data;\n\t  numcountp += thisnode ->num;\n\t  thisnode = thisnode->next;\n\t}\n\t\n\tif ( q-numcountp > thisnode->data) numm += thisnode->data;\n\telse numm += q- numcountp;\n      } else {\n\tif(p <= numcountp +pnode->data){\n\t  if(q <= numcountp + pnode->data){\n\t    numm = q-p+1;\n\t  } else {\n\t    numm = thisnode->data -(p - numcountp);\n\t  }\n\t} \n      }\n      \n      cout << numm << endl;\n    }\n  }\n  return 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include <string>\n#include <vector>\n#include <sstream>\n#include <iostream>\n#include <algorithm>\n#include <map>\n#include <list>\n#include <set>\n#include <numeric>\n#include <queue>\n#include <stack>\n#include <cstdio>\n#include <cmath>\n#include <cstdlib>\n#include <cctype>\n#include <cstring>\n#include <climits>\n#include <cfloat>\n#include <ctime>\n#include <complex>\n#include <cassert>\n#include <iomanip>\nusing namespace std;\ntypedef long long LL;\ntypedef pair<int,int> P;\nint n;\nint p,q,r;\nint m;\nint x[5000];\nint y[5000];\nint num(int k, int a, int b)\n{\n\tif(k==m){\n\t\tint s=min(b-a, max(q-a,0));\n\t\tint t=min(b-a, max(p-1-a,0));\n\t\treturn s-t;\n\t}\n\tif(a<x[k]){\n\t\tif(b<=x[k]){\n\t\t\treturn num(k+1,a+n-x[k],b+n-x[k]);\n\t\t}\n\t\telse if(b<=y[k]){\n\t\t\treturn num(k+1,a+n-x[k],n)+num(k+1,n-y[k],n-y[k]+b-x[k]);\n\t\t}\n\t\telse\n\t\t{\n\t\t\treturn num(k+1,a+n-x[k],n)+num(k+1,n-y[k],n-x[k])+num(k+1,0,b-y[k]);\n\t\t}\n\t}\n\telse if(a<y[k])\n\t{\n\t\tif(b<=y[k]){\n\t\t\treturn num(k+1,n-y[k]-x[k]+a,n-y[k]-x[k]+b);\n\t\t}\n\t\telse\n\t\t{\n\t\t\treturn num(k+1,n-y[k]-x[k]+a,n-x[k])+num(k+1,0,b-y[k]);\n\t\t}\n\t}\n\telse\n\t{\n\t\treturn num(k+1,a-y[k],b-y[k]);\n\t}\n}\nint main() {\nwhile(1)\n{\n\tcin >> n >> m;\n\tif(n==0)return 0;\n\tcin >> p >> q >> r;\n\tfor(int i=0;i<m;i++){\n\t\tcin >> x[i] >> y[i];\n\t}\n\tcout << num(0,0,r) << endl;\n}\n}"
  },
  {
    "language": "C++",
    "code": "#include <iostream>\n#include <algorithm>\n#include <vector>\n\nusing namespace std;\ntypedef pair<int,int> pii;\n\nint N;\nint M;\nint P,Q,R;\n\nint main(){\n    while(cin>>N&&N){\n        int res=0;\n        cin>>M>>P>>Q>>R;\n        vector<pii> deck;\n        deck.push_back(pii(1,N));\n        int x,y;\n        for(int i=0;i<M;i++){\n            cin>>x>>y;\n            // xÌÓÆyÌÓðÁèµAVbt\n            int sumX=0;\n            int xPos,yPos;\n            // x+1ÚðÁè\n            x++;\n            for(int j=0;j<deck.size();j++){\n                if(sumX+deck[j].second-deck[j].first+1>=x){\n                    xPos=j;\n                    break;\n                }\n                sumX+=deck[j].second-deck[j].first+1;\n            }\n            int sumY=0;\n            // yÚðÁè\n            for(int j=0;j<deck.size();j++){\n                if(sumY+deck[j].second-deck[j].first+1>=y){\n                    yPos=j;\n                    break;\n                }\n                sumY+=deck[j].second-deck[j].first+1;\n            }\n            // x+1Ú©çy+1ÚÜÅÌÓðØèæèAVbt\n            // ¯¶æÔÉ¶Ý\n            int yDivNum=0;\n            if(xPos==yPos){\n                // »ÝÌæÔðRª\n                pii p1=pii(deck[xPos].first,deck[xPos].first+(x-sumX-2));\n                pii p2=pii(p1.second+1,deck[yPos].first+(y-sumY-1));\n                pii p3=pii(p2.second+1,deck[xPos].second);\n                deck.erase(deck.begin()+xPos);\n                if(p3.first<=p3.second)deck.insert(deck.begin()+xPos,p3);\n                if(p2.first<=p2.second)deck.insert(deck.begin()+xPos,p2);\n                if(p1.first<=p1.second)deck.insert(deck.begin()+xPos,p1);\n            }\n            // ÊÌæÔÉ¶Ý·éêÍA»ê¼êÌæÔ²ÆÉªðs¤\n            else{\n                // y\n                {\n                    pii p1=pii(deck[yPos].first,deck[yPos].first+(y-sumY-1));\n                    pii p2=pii(p1.second+1,deck[yPos].second);\n                    deck.erase(deck.begin()+yPos);\n                    if(p2.first<=p2.second)deck.insert(deck.begin()+yPos,p2);\n                    if(p1.first<=p1.second)deck.insert(deck.begin()+yPos,p1);\n                }\n                // x\n                {\n                    pii p1=pii(deck[xPos].first,deck[xPos].first+(x-sumX-2));\n                    pii p2=pii(p1.second+1,deck[xPos].second);\n                    deck.erase(deck.begin()+xPos);\n                    if(p2.first<=p2.second)deck.insert(deck.begin()+xPos,p2);\n                    if(p1.first<=p1.second)deck.insert(deck.begin()+xPos,p1);\n                }\n            }\n            // à¤êxxÆyÌêðTõµA©Â¯½çVbt\n            sumX=sumY=0;\n            for(int j=0;j<deck.size();j++){\n                if(sumX+deck[j].second-deck[j].first+1>=x){\n                    xPos=j;\n                    break;\n                }\n                sumX+=deck[j].second-deck[j].first+1;\n            }\n            for(int j=0;j<deck.size();j++){\n                if(sumY+deck[j].second-deck[j].first+1>=y){\n                    yPos=j;\n                    break;\n                }\n                sumY+=deck[j].second-deck[j].first+1;\n            }\n            // xpos©çyposÜÅÌÓð²«oµÄAVbt\n            vector<pii> cutPlace;\n            vector<pii> prv;\n            vector<pii> nxt;\n            for(int i=xPos;i<=yPos;i++)cutPlace.push_back(deck[i]);\n            for(int i=0;i<xPos;i++)prv.push_back(deck[i]);\n            for(int i=yPos+1;i<deck.size();i++)nxt.push_back(deck[i]);\n            deck.clear();\n            for(int i=0;i<nxt.size();i++)deck.push_back(nxt[i]);\n            for(int i=0;i<cutPlace.size();i++)deck.push_back(cutPlace[i]);\n            for(int i=0;i<prv.size();i++)deck.push_back(prv[i]);\n        }\n        // VbtI¹ãApÆqÌl©çAðð½·àÌðTõ\n        int sum=0;\n        bool isApP=false;\n        for(int i=0;i<deck.size();i++){\n            int cnt=deck[i].second-deck[i].first+1;\n            sum+=cnt;\n            if(sum<P)continue;\n            // ¡ñÌæÔÉñÂÆàÜÜêéê\n            if(sum-cnt<P&&sum-cnt<Q&&sum>=P&&sum>=Q){\n                int pPos=P-(sum-cnt)-1;\n                int pNum=pPos+deck[i].first;\n                int qPos=Q-(sum-cnt)-1;\n                int qNum=qPos+deck[i].first;\n                // pÌl©çrÈºÌàÌð¦ã°\n                if(pNum<=R)\n                    res+=max(0,min(-qNum+R+1,qNum-pNum+1));\n                break;\n            }\n            // ¡ñÌæÔÅßÄpª»ê½ê\n            else if(!isApP&&sum>=P){\n                isApP=true;\n                int pPos=P-(sum-cnt)-1;\n                int pNum=pPos+deck[i].first;\n                // pÌl©çrÈºÌàÌð¦ã°\n                if(pNum<=R)\n                    res+=max(0,min(-deck[i].first+R+1,deck[i].second-pNum+1));\n            }\n            // pªo»ÏÝÌê\n            else if(isApP){\n                // ¡ñQª»ê½çðµÄbreak\n                if(sum>=Q){\n                    int qPos=Q-(sum-cnt)-1;\n                    int qNum=qPos+deck[i].first;\n                    if(deck[i].first<=R){\n                        //deck[i].first-=R;\n                        res+=min(qNum-deck[i].first+1,(R-deck[i].first+1));\n                        //if(qNum>=R)res+=R;\n                    //else res+=(qNum-deck[i].first+1);\n                    }\n                    break;\n                }\n                // æÔÌl·×ÄÉÎµÄvZ\n                else{\n                    if(deck[i].first<=R){\n                        res+=max(0,min(-deck[i].first+R+1,deck[i].second-deck[i].first+1));\n                    }\n                }\n            }\n        }\n        cout<<res<<endl;\n    }\n    return 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include <iostream>\n#include <utility>\n#include <list>\n#include <algorithm>\n\nint main() {\n\tint n, m, p, q, r;\n\twhile (std::cin >> n, n != 0) {\n\t\tstd::list<std::pair<int, int>> cards;\n\t\tcards.push_back({ 1, n });\n\n\t\tstd::cin >> m >> p >> q >> r;\n\t\tfor (int i = 0; i < m; ++i) {\n\t\t\tint x, y;\n\t\t\tstd::cin >> x >> y;\n\n\t\t\tdecltype(cards)::iterator sec1 = cards.end(), sec2;\n\t\t\tint num = 0;\n\t\t\tfor (auto itr = cards.begin(); itr != cards.end(); ++itr) {\n\t\t\t\tnum += itr->second - itr->first + 1;\n\n\t\t\t\tif (num >= x && sec1 == cards.end()) {\n\t\t\t\t\tif (num == x) {\n\t\t\t\t\t\tsec1 = itr;\n\t\t\t\t\t\tsec2 = cards.end();\n\t\t\t\t\t\tcontinue;\n\t\t\t\t\t}\n\n\t\t\t\t\tcards.insert(\n\t\t\t\t\t\titr,\n\t\t\t\t\t\t{\n\t\t\t\t\t\t\t{itr->first, itr->second - (num - x)},\n\t\t\t\t\t\t\t{itr->second - (num - x) + 1, itr->second}\n\t\t\t\t\t\t}\n\t\t\t\t\t);\n\t\t\t\t\tsec1 = itr = cards.erase(itr);\n\t\t\t\t\t--itr, ----sec1;\n\t\t\t\t\tsec2 = cards.end();\n\n\t\t\t\t\tnum = x + itr->second - itr->first + 1;\n\t\t\t\t}\n\t\t\t\tif (num >= y && sec2 == cards.end()) {\n\t\t\t\t\tif (num == y) {\n\t\t\t\t\t\tsec2 = itr;\n\t\t\t\t\t\t++sec2, ++sec1;\n\t\t\t\t\t\tbreak;\n\t\t\t\t\t}\n\t\t\t\t\tcards.insert(\n\t\t\t\t\t\titr,\n\t\t\t\t\t\t{\n\t\t\t\t\t\t\t{ itr->first, itr->second - (num - y) },\n\t\t\t\t\t\t\t{ itr->second - (num - y) + 1, itr->second }\n\t\t\t\t\t\t}\n\t\t\t\t\t);\n\t\t\t\t\tsec2 = itr = cards.erase(itr);\n\t\t\t\t\t--itr, --sec2, ++sec1;\n\n\t\t\t\t\tbreak;\n\t\t\t\t}\n\t\t\t}\n\n\t\t\tcards.splice(cards.end(), cards, sec1, sec2);\n\t\t\tcards.splice(cards.end(), cards, cards.begin(), sec2);\n\t\t}\n\n\t\tint count = 0, ans = 0;\n\t\tfor (auto&& rng : cards) {\n\t\t\tconst int rngSize = rng.second - rng.first + 1;\n\t\t\tint prev = count;\n\t\t\tcount += rngSize;\n\n\t\t\tif (count < p)\n\t\t\t\tcontinue;\n\n\t\t\tif (prev < p && count >= p)\n\t\t\t\trng.first = rng.second - (count - p);\n\n\t\t\tif (count > q) {\n\t\t\t\tans += std::min(q - prev, std::max(r - rng.first + 1, 0));\n\t\t\t\tbreak;\n\t\t\t}\n\n\t\t\tans += std::min(rng.second - rng.first + 1, std::max(r - rng.first + 1, 0));\n\t\t}\n\n\t\tstd::cout << ans << std::endl;\n\t}\n}"
  },
  {
    "language": "C++",
    "code": "#include <iostream>\n#include <algorithm>\n#include <vector>\nusing namespace std;\nint main(){\n\tint n,m,p,q,r,x,y;\n\tvector<int>::iterator itx,ity,it;\n\tfor(;cin>>n>>m>>p>>q>>r;cout<<x<<endl){\n\t\tvector<int> v1,v2;\n\t\tv1.push_back(0);\n\t\tv1.push_back(r);\n\t\t\n\t\tfor(;m--;v2.clear()){\n\t\t\tcin>>x>>y;\n\t\t\titx=upper_bound(v1.begin(),v1.end(),x);\n\t\t\tity=upper_bound(v1.begin(),v1.end(),y);\n\t\t\t\n\t\t\tif( ity-v1.begin()+1 & 1 )v2.push_back(0);\n\t\t\tv2.push_back(0);\n\t\t\tfor(it=ity;it!=v1.end();++it)\n\t\t\t\tv2.push_back(*it - y);\n\t\t\t\n\t\t\tif(v1.end()-itx & 1)v2.push_back(n-y);\n\t\t\tfor(it=itx;it!=ity;++it)\n\t\t\t\tv2.push_back(*it-x+n-y);\n\t\t\t\n\t\t\tit = v1.begin();\n\t\t\tif(ity-v1.begin() & 1)++it;\n\t\t\tif(!it[1])it+=2;\t//重複排除\n\t\t\tif(*it+n-x==v2.back()){++it;v2.pop_back();}\t//重複排除\n\t\t\tfor(;it!=itx;++it)\n\t\t\t\tv2.push_back(*it+n-x);\n\t\t\t\n\t\t\tv1.swap(v2);\n\t\t}\n\t\tv1.insert( upper_bound(v1.begin(),v1.end(),p-1), 2, p-1);\n\t\tv1.insert( lower_bound(v1.begin(),v1.end(),q), q );\n\t\tv1.push_back(n);\n\t\tit = upper_bound(v1.begin(),v1.end(),p-1);\n\t\tif(it-v1.begin() & 1) --it;\n\t\tfor(x=0;*it<q;++it){\n\t\t\tm=*it;\n\t\t\t++it;\n\t\t\tx+=*it-m;\n\t\t}\n\t}\n}"
  },
  {
    "language": "C++",
    "code": "#include<vector>\n#include<map>\n#include<set>\n#include<algorithm>\n#include<functional>\n#include<numeric>\n#include<utility>\n#include<sstream>\n#include<iostream>\n#include<iomanip>\n#include<cstdio>\n#include<cmath>\n#include<cstdlib>\n#include<cctype>\n#include<string>\n#include<cstring>\n#include<list>\nusing namespace std;\ntypedef vector<int>VI;\ntypedef vector<VI>VVI;\ntypedef vector<string>VS;\ntypedef pair<int,int>PII;\ntypedef long long LL;\n#define ALL(a) (a).begin(),(a).end()\n#define RALL(a) (a).rbegin(),(a).rend()\n#define PB push_back\n#define EACH(i,c) for(typeof((c).begin())i=(c).begin();i!=(c).end();i++)\n#define FOR(i,a,b) for(int i=(a);i<(b);++i)\n#define REP(i,n) FOR(i,0,n)\n\nstruct data{\n    int l,r;\n    data(int a,int b):l(a),r(b){}\n    data(){}\n};\n\nint N,M;\nint p,q,r;\nint x[5001],y[5001];\n\nint solve(){\n    vector<data>L;\n    L.push_back(data(1,N));\n    x[M]=p-1,y[M]=q;\n    REP(i,M+1){\n        vector<data>a,b,c;\n        int sum=0;\n        int pos;\n        for(int j=0;j<L.size();j++){\n            data d=L[j];\n            if(x[i]==0)break;\n            if(sum+(d.r-d.l+1)<=x[i]){\n                a.push_back(d);\n                sum+=(d.r-d.l+1);\n                pos=j+1;\n                if(sum==x[i])break;\n            }\n            else{\n                a.push_back(data(d.l,x[i]+d.l-1-sum));\n                //cout<<\"**** \"<<d.l<<\" \"<<x[i]+d.l-1-sum<<endl<<endl;\n                L[j]=data(x[i]+d.l-sum,d.r);\n                pos=j;\n                break;\n            }\n        }\n        sum=x[i];\n        for(int j=pos;j<L.size();j++){\n            data d=L[j];\n            if(x[i]==y[i])break;\n            if(sum+(d.r-d.l+1)<=y[i]){\n                b.push_back(d);\n                sum+=(d.r-d.l+1);\n                pos=j+1;\n                if(sum==y[i])break;\n            }\n            else{\n                b.push_back(data(d.l,y[i]+d.l-1-sum));\n                L[j]=data(y[i]-sum+d.l,d.r);\n                pos=j;\n                break;\n            }\n        }\n        L.erase(L.begin(),L.begin()+pos);\n        if(i==M){\n            L=b;\n            break;\n        }\n        L.insert(L.end(),b.begin(),b.end());\n        L.insert(L.end(),a.begin(),a.end());\n        //cout<<endl;EACH(it,L)cout<<it->l<<\" \"<<it->r<<endl;\n    }\n    //cout<<endl;EACH(it,L)cout<<it->l<<\" \"<<it->r<<endl;\n    int cnt=0;\n    EACH(it,L){\n        int l=it->l,u=it->r;\n        if(l>r)continue;\n        if(u<=r)cnt+=u-l+1;\n        else{\n            cnt+=r-l+1;\n        }\n    }\n    return cnt;\n}\n\n\n\n\n\n\n\nint main(){\n    while(cin>>N,N){\n        cin>>M;\n        cin>>p>>q>>r;\n        REP(i,M)cin>>x[i]>>y[i];\n        cout<<solve()<<endl;\n    }\n    return 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include<iostream>\n#include<cstdio>\n#include<vector>\n#include<queue>\n#include<algorithm>\n#include<functional>\n#include<cstring>\n#define MAX_N 100000\n#define F first\n#define S second \n#define MP make_pair\nusing namespace std;\ntypedef pair<int, int> P;\n\nconst int INF = 1e9;\n\nint main() {\n\tint n, m, pp, q, r;\n\n\twhile (cin >> n&&n){\t\n\t\tint save = -1, ans = 0;\n\t\tvector<P>vep = { MP(1,1), MP(n, n) }, vep2, vep3;\n\tvector<int> vec = { 1, n }, vec2, vec3;\n\t\tcin >> m >> pp >> q >> r;\n\t\tfor (int i = 0; i < m; i++) {\n\t\t\tint x, y, p, p2;\n\t\t\tscanf(\"%d%d\", &x, &y);\n\t\t\tp = lower_bound(vec.begin(), vec.end(), x) - vec.begin();\n\t\t\tif (vec[p] != x) {\n\t\t\t\tvec.insert(vec.begin() + p, x);\n\t\t\t\tP a = MP(vec[p] - vec[p - 1] + vep[p - 1].F, x);\n\t\t\t\tvep.insert(vep.begin() + p, a);\n\t\t\t}\n\t\t\tif (vep[p].S + 1 != vep[p + 1].S) {\n\t\t\t\tvec.insert(vec.begin() + p + 1, x + 1);\n\t\t\t\tP a = MP(vep[p].F + 1, x + 1);\n\t\t\t\tvep.insert(vep.begin() + p + 1, a);\n\t\t\t}\n\t\t\tp2 = lower_bound(vec.begin(), vec.end(), y) - vec.begin();\n\t\t\tif (vec[p2] != y) {\n\t\t\t\tvec.insert(vec.begin() + p2, y);\n\t\t\t\tP a = MP(vec[p2] - vec[p2 - 1] + vep[p2 - 1].F, y);\n\t\t\t\tvep.insert(vep.begin() + p2, a);\n\t\t\t}\n\t\t\tif (vep[p2].S + 1 != vep[p2 + 1].S) {\n\t\t\t\tvec.insert(vec.begin() + p2 + 1, y + 1);\n\t\t\t\tP a = MP(vep[p2].F + 1, y + 1);\n\t\t\t\tvep.insert(vep.begin() + p2 + 1, a);\n\t\t\t}\n\t\t\tfor (int j = p2 + 1; j < vec.size(); j++) {\n\t\t\t\tvec2.push_back(vec[j] - vec[p2 + 1] + 1);\n\t\t\t\tvep2.push_back(MP(vep[j].F, vec[j] - vec[p2 + 1] + 1));\n\t\t\t}\n\t\t\tint size = vec2[vec2.size() - 1];\n\t\t\tfor (int j = p + 1; j < p2 + 1; j++) {\n\t\t\t\tvec2.push_back(vec[j] - vec[p + 1] + 1 + size);\n\t\t\t\tvep2.push_back(MP(vep[j].F, vec[j] - vec[p + 1] + 1 + size));\n\t\t\t}\n\t\t\tsize = vec2[vec2.size() - 1];\n\t\t\tfor (int j = 0; j < p + 1; j++) {\n\t\t\t\tvec2.push_back(vec[j] - vec[0] + 1+size);\n\t\t\t\tvep2.push_back(MP(vep[j].F, vec[j] - vec[0] + 1+size));\n\t\t\t}\n\t\t\tvec3 = vec;\n\t\t\tvep3 = vep;\n\t\t\tvec = vec2;\n\t\t\tvep = vep2;\n\t\t\tvec2 = vec3;\n\t\t\tvep2 = vep3;\n\t\t\tvec2.clear();\n\t\t\tvep2.clear();\n\t\t}\n\t\tint p, p2;\n\t\tp = lower_bound(vec.begin(), vec.end(), pp) - vec.begin();\n\t\t\n\t\tif (vec[p] != pp) {\n\t\t\tvec.insert(vec.begin() + p, pp);\n\t\t\tP a = MP(vec[p] - vec[p - 1] + vep[p-1].F, pp);\n\t\t\tvep.insert(vep.begin() + p, a);\n\t\t}\n\t\tif (vep[p].S + 1 != vep[p + 1].S) {\n\t\t\tvec.insert(vec.begin() + p + 1, pp + 1);\n\t\t\tP a = MP(vep[p].F + 1, pp + 1);\n\t\t\tvep.insert(vep.begin() + p + 1, a);\n\t\t}\n\t\tp2 = lower_bound(vec.begin(), vec.end(), q) - vec.begin();\n\t\tif (vec[p2] != q) {\n\t\t\tvec.insert(vec.begin() + p2, q);\n\t\t\tP a = MP(vec[p2] - vec[p2 - 1] + vep[p2-1].F, q);\n\t\t\tvep.insert(vep.begin() + p2, a);\n\t\t}\n\t\tif (vep[p2].S + 1 != vep[p2 + 1].S) {\n\t\t\tvec.insert(vec.begin() + p2 + 1, q + 1);\n\t\t\tP a = MP(vep[p2].F + 1, q + 1);\n\t\t\tvep.insert(vep.begin() + p2 + 1, a);\n\t\t}\n\t\tfor (int i = p; i <= p2; i++) {\n\t\t\tif (i + 1<=p2 && vep[i + 1].F - vep[i].F == vep[i + 1].S - vep[i].S) {\n\t\t\t\tfor (int j = vep[i].F; j <= vep[i + 1].F; j++) {\n\t\t\t\t\tif (j <= r&&save!=j) {\n\t\t\t\t\t\tans++;\n\t\t\t\t\t\tsave = j;\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t}\n\t\t\telse{\n\t\t\t\tif (vep[i].F <= r&&save != vep[i].F) {\n\t\t\t\t\tans++;\n\t\t\t\t\tsave = vep[i].F;\n\t\t\t\t}\n\t\t\t}\n\t}\n\t\tcout << ans << endl;\n\t}\n}"
  },
  {
    "language": "C++",
    "code": "#define _USE_MATH_DEFINES\n#define INF 0x3f3f3f3f\n\n#include <iostream>\n#include <cstdio>\n#include <sstream>\n#include <cmath>\n#include <cstdlib>\n#include <algorithm>\n#include <queue>\n#include <stack>\n#include <limits>\n#include <map>\n#include <string>\n#include <cstring>\n#include <set>\n#include <deque>\n#include <bitset>\n#include <list>\n#include <cctype>\n#include <utility>\n  \nusing namespace std;\n  \ntypedef long long ll;\ntypedef pair <int,int> P;\n  \nstatic const double EPS = 1e-8;\n  \nstatic const int tx[] = {0,1,0,-1};\nstatic const int ty[] = {-1,0,1,0};\n\nint main(){\n  int total_cards;\n  while(~scanf(\"%d\",&total_cards)){\n    if(total_cards == 0) break;\n    int total_shuffles;\n    int first,last,upper;\n\n    scanf(\"%d\",&total_shuffles);\n    scanf(\"%d %d %d\",&first,&last,&upper);\n    \n    vector<P> cards;\n    cards.push_back(P(1,total_cards));\n\n    for(int shuffle_idx=0;shuffle_idx<total_shuffles;shuffle_idx++){\n      int x,y;\n      scanf(\"%d %d\",&x,&y);\n      vector<P> A;\n      vector<P> B;\n      vector<P> C;\n      vector<P> next;\n\n      int sum = 0;\n      int prev_sum = 0;\n      for(int j=0;j<cards.size();j++){\n        prev_sum = sum;\n        sum += cards[j].second - cards[j].first + 1;\n        if(prev_sum < x){\n          if(sum <= x){\n            A.push_back(cards[j]);\n          }\n          else if(sum > x && sum <= y){\n            A.push_back(P(cards[j].first,cards[j].first + (x - prev_sum - 1)));\n            B.push_back(P(cards[j].first + (x - prev_sum),\n                          cards[j].second));\n          }\n          else if(sum > y){\n            A.push_back(P(cards[j].first,cards[j].first + (x - prev_sum - 1)));\n            B.push_back(P(cards[j].first + (x - prev_sum),\n                          cards[j].first + (x - prev_sum) + (y - x - 1)));\n            C.push_back(P(cards[j].first + (x - prev_sum) + (y - x),\n                          cards[j].second));\n          }\n        }\n        else if(prev_sum >= x){\n          if(prev_sum < y){\n            if(sum <= y){\n              B.push_back(P(cards[j].first,cards[j].second));\n            }\n            else if(sum > y){\n              B.push_back(P(cards[j].first,cards[j].first + (y - prev_sum - 1)));\n              C.push_back(P(cards[j].first + (y - prev_sum),cards[j].second));\n            }\n          }\n          else if(prev_sum >= y){\n            C.push_back(P(cards[j].first,cards[j].second));\n          }\n        }\n      }\n      for(int i=0;i<C.size();i++){\n        next.push_back(C[i]);\n      }\n      for(int i=0;i<B.size();i++){\n        next.push_back(B[i]);\n      }\n      for(int i=0;i<A.size();i++){\n        next.push_back(A[i]);\n      }\n      cards = next;\n    }\n\n    int offset = 0;\n    int res = 0;\n    for(int i=0;i<cards.size();i++){\n      int current = cards[i].second - cards[i].first + 1;\n      if(offset + current < first){\n        offset += current;\n        continue;\n      }\n      if(offset > last){\n        offset += current;\n        continue;\n      }\n\n      int lhs = -1;\n      int rhs = 1000000010;\n\n      for(int round = 0; round < 50; round++){\n        int mid = (lhs + rhs) / 2;\n        if(cards[i].first + mid > upper){\n          rhs = mid;\n        }\n        if(cards[i].first + mid <= upper){\n          lhs = mid;\n        }\n      }\n\n      int count = min(rhs,cards[i].second - cards[i].first + 1);\n\n      if(offset + count >= last){\n        count -= offset + count - last;\n      }\n\n      if(offset < first){\n        count -= first - offset - 1;\n      }\n\n      if(count > 0){\n        res += count;\n      }\n\n      offset += current;\n    }\n    printf(\"%d\\n\",res);\n\n  }\n}"
  },
  {
    "language": "C++",
    "code": "#include<stdio.h>\n#include<algorithm>\nusing namespace std;\npair<int,int> wolf[12000];\npair<int,int> top[12000];\npair<int,int> middle[12000];\npair<int,int> bottom[12000];\nint T,M,B;\nint size;\nint main(){\n\tint a;\n\twhile(scanf(\"%d\",&a),a){\n\t\tint b;\n\t\tscanf(\"%d\",&b);\n\t\tint p,q,r;\n\t\tscanf(\"%d%d%d\",&p,&q,&r);p--;\n\t\tsize=1;\n\t\twolf[0]=make_pair(0,a);\n\t\tfor(int i=0;i<b;i++){\n\t\t\tint s,t;\n\t\t\tscanf(\"%d%d\",&s,&t);\n\t\t\tint num=0;\n\t\t\tint phase=0;\n\t\t\tint P=0;\n\t\t\tfor(int j=0;j<size;j++){\n\t\t\t\tif(phase==0&&num+wolf[j].second-wolf[j].first>s){\n\t\t\t\t\tfor(int k=0;k<j;k++)bottom[k]=wolf[k];\n\t\t\t\t\tbottom[j]=make_pair(wolf[j].first,wolf[j].first+s-num);\n\t\t\t\t\twolf[j]=make_pair(wolf[j].first+s-num,wolf[j].second);\n\t\t\t\t\tnum=s;\n\t\t\t\t\tB=j+1;\n\t\t\t\t\tP=j;\n\t\t\t\t\tphase++;\n\t\t\t\t\tj--;\n\t\t\t\t\tcontinue;\n\t\t\t\t}\n\t\t\t\tif(phase==1&&num+wolf[j].second-wolf[j].first>t){\n\t\t\t\t\tfor(int k=P;k<j;k++)middle[k-P]=wolf[k];\n\t\t\t\t\tmiddle[j-P]=make_pair(wolf[j].first,wolf[j].first+t-num);\n\t\t\t\t\twolf[j]=make_pair(wolf[j].first+t-num,wolf[j].second);\n\t\t\t\t\tM=j-P+1;\n\t\t\t\t\tfor(int k=j;k<size;k++){\n\t\t\t\t\t\ttop[k-j]=wolf[k];\n\t\t\t\t\t}\n\t\t\t\t\tT=size-j;\n\t\t\t\t\tbreak;\n\t\t\t\t}\n\t\t\t\tnum+=wolf[j].second-wolf[j].first;\n\t\t\t}\n\t\t\tfor(int j=0;j<T;j++)wolf[j]=top[j];\n\t\t\tfor(int j=0;j<M;j++)wolf[j+T]=middle[j];\n\t\t\tfor(int j=0;j<B;j++)wolf[j+T+M]=bottom[j];\n\t\t\tsize=T+M+B;\n\t\t}\n\t\tint num=0;\n\t\tint ret=0;\n\t\t//for(int i=0;i<size;i++)printf(\"%d %d\\n\",wolf[i].first,wolf[i].second);\n\t\tfor(int i=0;i<size;i++){\n\t\t\tif(wolf[i].first==wolf[i].second)continue;\n\t\t\tif(num+wolf[i].second-wolf[i].first>=p){\n\t\t\t\tif(wolf[i].first+p-num<=r)ret-=p-num;\n\t\t\t\telse if(wolf[i].first<=r-1)ret-=r-wolf[i].first;\n\t\t\t\tbreak;\n\t\t\t}else{\n\t\t\t\tif(wolf[i].second<=r)ret-=wolf[i].second-wolf[i].first;\n\t\t\t\telse if(wolf[i].first<=r-1)ret-=r-wolf[i].first;\n\t\t\t}\n\t\t\tnum+=wolf[i].second-wolf[i].first;\n\t\t}\n\t\tnum=0;\n\t\tfor(int i=0;i<size;i++){\n\t\t\tif(wolf[i].first==wolf[i].second)continue;\n\t\t\tif(num+wolf[i].second-wolf[i].first>=q){\n\t\t\t\tint x=q-num;\n\t\t\t\tif(wolf[i].first+q-num<=r)ret+=q-num;\n\t\t\t\telse if(wolf[i].first<=r-1)ret+=r-wolf[i].first;\n\t\t\t\tbreak;\n\t\t\t}else{\n\t\t\t\tif(wolf[i].second<=r)ret+=wolf[i].second-wolf[i].first;\n\t\t\t\telse if(wolf[i].first<=r-1)ret+=r-wolf[i].first;\n\t\t\t}\n\t\t\tnum+=wolf[i].second-wolf[i].first;//printf(\"%d\\n\",ret);\n\t\t}\n\t\tprintf(\"%d\\n\",ret);\n\t}\n}"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\nusing namespace std;\n#define FI first\n#define SE second\n//#define DEBUG\n\nstruct NODE\n{\n\tint s, e;\n\tNODE* next;\n};\n\nNODE* shuffle(NODE* head, int x, int y, int n);\npair<NODE*, NODE*> S(NODE* now, int num);\nint query(int p, int q, int r);\n\nvoid printdeck(NODE* head);\n\nNODE* shuffle(NODE* head, int x, int y, int n)\n{\n\tpair<NODE*, NODE*> A, B, C;\n\t  printdeck(head);\n\tA = S(head, x);\n\t  printdeck(head);\n\tB = S(A.SE->next, y - x);\n\t  printdeck(head);\n\tC = S(B.SE->next, n - y);\n\t  printdeck(head);\n\t\n\tC.SE->next = B.FI;\n\tB.SE->next = A.FI;\n\tA.SE->next = NULL;\n\t\n\treturn C.FI;\n}\n\npair<NODE*, NODE*> S(NODE* now, int num)\n{\t\n\tint m = now->e - now->s + 1;\n\t\n\tif (num == m){\n\t\treturn {now, now};\n\t}\n\telse if (num < m){\n\t\tNODE* _node = new NODE;\n\t\t_node->s = now->s + num;\n\t\t_node->e = now->e;\n\t\t_node->next = now->next;\n\t\t\n\t\tnow->e = _node->s - 1;\n\t\tnow->next = _node;\n\t\t\n\t\treturn {now, now};\n\t}\n\telse if (num > m){\n\t\treturn {now, S(now->next, num - m).SE};\n\t}\n}\n\nint query(NODE* head, int p, int q, int r)\n{\n\tpair<NODE*, NODE*> s;\n\ts = S(S(head, p - 1).SE->next, q - p + 1);\n\t\n\tint res = 0;\n\tfor (NODE* _node = s.FI; /*_node != s.SE*/; _node = _node->next){\n\t\t//cout << \"_\" << _node->s << \" \" << _node->e << endl;\n\t\tif (r < _node->s) res += 0;\n\t\telse if (r >= _node->e) res += _node->e - _node->s + 1;\n\t\telse res += r - _node->s + 1;\n\t\t\n\t\tif (_node == s.SE) break;\n\t}\n\t\n\treturn res;\n}\n\nint main()\n{\n\tint n;\n\twhile (cin >> n, n){\n\t\tint m;\n\t\tcin >> m;\n\t\t\n\t\tint p, q, r;\n\t\tcin >> p >> q >> r;\n\t\t\n\t\tNODE* head = new NODE;\n\t\thead->s = 1;\n\t\thead->e = n;\n\t\thead->next = NULL;\n\t\t\n\t\tfor (int i = 0; i < m; i++){\n\t\t\tint x, y;\n\t\t\tcin >> x >> y;\n\t\t\thead = shuffle(head, x, y, n);\n\t\t\t  printdeck(head);\n\t\t}\n\t\t\n\t\tcout << query(head, p, q, r) << endl;\n\t}\n\t\n\treturn 0;\n}\n\nvoid printdeck(NODE* head)\n{\n\t#ifdef DEBUG\n\tcout << endl;\n\tfor (NODE* _node = head; _node != NULL; _node = _node->next){\n\t\tcout << _node->s << \" \" << _node->e << endl;\n\t}\n\tcout << endl;\n\t#endif\n}"
  },
  {
    "language": "C++",
    "code": "#include<bits/stdc++.h>\nusing namespace std;\n\nint solve();\n\nint N,M,P,Q,R;\nint X[5010],Y[5010];\n\nint main()\n{\n    while(scanf(\"%d\",&N),N)\n    {\n        scanf(\"%d\",&M);\n        scanf(\"%d%d%d\",&P,&Q,&R);\n        for(int i = 0; i < M; i++)\n        {\n            scanf(\"%d%d\",&X[i],&Y[i]);\n        }\n        printf(\"%d\\n\",solve());\n    }\n}\n\nint solve()\n{\n    int ANS = 0;\n    vector<pair<int,int> > vec[5010];\n    vec[0].push_back(make_pair(1,R));\n    for(int i = 0; i < M; i++)\n    {\n        for(int j = 0; j < vec[i].size(); j++)\n        {\n            int l = vec[i][j].first,r = vec[i][j].second;\n            if(l <= X[i] && r <= X[i])\n            {\n                vec[i + 1].push_back(make_pair(l + N - X[i],r + N - X[i]));\n                continue;\n            }\n            if(l <= X[i] && X[i] < r && r <= Y[i])\n            {\n                vec[i + 1].push_back(make_pair(l + N - X[i],N));\n                vec[i + 1].push_back(make_pair(N - Y[i] + 1,r + N - X[i] - Y[i]));\n                continue;\n            }\n            if(X[i] < l && l <= Y[i] && X[i] < r && r <= Y[i])\n            {\n                vec[i + 1].push_back(make_pair(l + N - X[i] - Y[i],r + N - X[i] - Y[i]));\n                continue;\n            }\n            if(X[i] < l && l <= Y[i] && Y[i] < r)\n            {\n                vec[i + 1].push_back(make_pair(l + N - X[i] - Y[i],N - X[i]));\n                vec[i + 1].push_back(make_pair(1,r - Y[i]));\n                continue;\n            }\n            if(Y[i] < l && Y[i] < r)\n            {\n                vec[i + 1].push_back(make_pair(l - Y[i],r - Y[i]));\n                continue;\n            }\n            if(l <= X[i] && Y[i] < r)\n            {\n                vec[i + 1].push_back(make_pair(l + N - X[i],N));\n                vec[i + 1].push_back(make_pair(N - Y[i] + 1,N - X[i]));\n                vec[i + 1].push_back(make_pair(1,r - Y[i]));\n                continue;\n            }\n        }\n    }\n    for(int i = 0;i < vec[M].size(); i++)\n    {\n        int l = vec[M][i].first,r = vec[M][i].second;\n        int a = max(l,P),b = min(r,Q) + 1;\n        ANS += max(0,b - a);\n    }\n    return ANS;\n}"
  },
  {
    "language": "C++",
    "code": "#include <cstdlib>\n#include <iostream>\n#include <utility>\n#include <vector>\nusing namespace std;\n\nint main() {\n\tcin.tie(0);\n\tios::sync_with_stdio(false);\n\n\tfor(int n; cin >> n, n;) {\n\t\tint m;\n\t\tcin >> m;\n\n\t\tint p, q, r;\n\t\tcin >> p >> q >> r;\n\n\t\tvector<pair<int, bool> > cards;\n\t\tcards.push_back(make_pair(r, true));\n\t\tcards.push_back(make_pair(n - r, false));\n\n\t\tfor(int i = 0; i < m; ++i) {\n\t\t\tint x, y;\n\t\t\tcin >> x >> y;\n\n\t\t\tvector<pair<int, bool> > tmp;\n\t\t\tint j, sum = 0, idxA, idxB, sumA, sumB;\n\t\t\tfor(j = 0;; ++j) {\n\t\t\t\tsum += cards[j].first;\n\t\t\t\tif(sum >= x) {\n\t\t\t\t\tidxA = j;\n\t\t\t\t\tsumA = sum;\n\t\t\t\t\tsum -= cards[j].first;\n\t\t\t\t\tbreak;\n\t\t\t\t}\n\t\t\t}\n\n\t\t\tfor(;; ++j) {\n\t\t\t\tsum += cards[j].first;\n\t\t\t\tif(sum >= y) {\n\t\t\t\t\tidxB = j;\n\t\t\t\t\tsumB = sum;\n\t\t\t\t\tbreak;\n\t\t\t\t}\n\t\t\t}\n\n\t\t\tif(sumB != y) {\n\t\t\t\ttmp.push_back(make_pair(sumB - y, cards[idxB].second));\n\t\t\t\tcards[idxB].first -= sumB - y;\n\n\t\t\t\tif(idxA == idxB)\n\t\t\t\t\tsumA -= sumB - y;\n\t\t\t}\n\n\t\t\tfor(j = idxB + 1; j < cards.size(); ++j)\n\t\t\t\ttmp.push_back(cards[j]);\n\n\t\t\tif(sumA != x) {\n\t\t\t\ttmp.push_back(make_pair(sumA - x, cards[idxA].second));\n\t\t\t\tcards[idxA].first -= sumA - x;\n\t\t\t}\n\n\t\t\tfor(j = idxA + 1; j <= idxB; ++j)\n\t\t\t\ttmp.push_back(cards[j]);\n\n\t\t\tfor(j = 0; j <= idxA; ++j)\n\t\t\t\ttmp.push_back(cards[j]);\n\n\t\t\tcards.swap(tmp);\n\t\t}\n\n\t\tint ans = 0;\n\t\tint i = 0, sum = 0;\n\t\tfor(; i < cards.size(); ++i) {\n\t\t\tsum += cards[i].first;\n\t\t\tif(sum >= p) {\n\t\t\t\tif(cards[i].second)\n\t\t\t\t\tans += sum - p + 1;\n\n\t\t\t\tbreak;\n\t\t\t}\n\t\t}\n\n\t\tfor(++i; i < cards.size(); ++i) {\n\t\t\tsum += cards[i].first;\n\t\t\tif(sum > q) {\n\t\t\t\tif(cards[i].second)\n\t\t\t\t\tans += cards[i].first - (sum - q);\n\n\t\t\t\tbreak;\n\t\t\t}\n\t\t\telse {\n\t\t\t\tif(cards[i].second)\n\t\t\t\t\tans += cards[i].first;\n\t\t\t}\n\t\t}\n\n\t\tcout << ans << endl;\n\t}\n\n\treturn EXIT_SUCCESS;\n}"
  },
  {
    "language": "C++",
    "code": "#include <fstream>\n#include <string>\n#include <sstream>\n#include <iostream>\n#include <locale>\n#include <codecvt>\n#include <memory>\n#include <iostream>\n#include <fstream>\n#include <string>\n#include <locale>\n#include <iomanip>\n#include <utility>\n#include <algorithm>\n \n \nint32_t N;\nint32_t p, q, r;\nint32_t M;\nint32_t X[5000];\nint32_t Y[5000];\n \nint32_t K[2][5000 * 3][2];//0: s 1: ??????°\nauto K_end = K[0];\ninline void insert(decltype(K_end) pos, int32_t ns, int32_t nn)\n{\n    for (auto iter = K_end; iter != pos; --iter) {\n        (*iter)[0] = (*(iter - 1))[0];\n        (*iter)[1] = (*(iter - 1))[1];\n    }\n    (*pos)[0] = ns;\n    (*pos)[1] = nn;\n    ++K_end;\n}\nint main()\n{\n    std::cin >> N;\n    while (N != 0)\n    {\n        std::cin >> M >> p >> q >> r;\n        for (int32_t i = 0; i < M; ++i) {\n            std::cin >> X[i] >> Y[i];\n        }\n        K_end = K[0];\n        (*K_end)[0] = 1;\n        (*K_end)[1] = N;\n        ++K_end;\n \n        for (int32_t i = 0; i < M; ++i)\n        {\n            //??????\n            int num_buf = 0;\n            decltype(K_end) x_end_pos = nullptr;\n            for (auto iter = K[i & 1]; iter != K_end; ++iter) {\n                num_buf += (*iter)[1];\n                if (X[i] <= num_buf) {\n                    auto nn = (num_buf - X[i]);\n                    (*iter)[1] -= nn;\n                    insert(iter + 1, (*iter)[0] + (*iter)[1], nn);\n                    x_end_pos = iter + 1;\n                    break;\n                }\n            }\n            num_buf = X[i];\n            decltype(K_end) y_end_pos = nullptr;\n            for (auto iter = x_end_pos; iter != K_end; ++iter) {\n                num_buf += (*iter)[1];\n                if (Y[i] <= num_buf) {\n                    auto nn = (num_buf - Y[i]);\n                    (*iter)[1] -= nn;\n                    insert(iter + 1, (*iter)[0] + (*iter)[1], nn);\n                    y_end_pos = iter + 1;\n                    break;\n                }\n            }\n            //????????????\n            auto iter_out = K[(i + 1) & 1];\n            for (auto iter = y_end_pos; iter != K_end; ++iter) {\n                (*iter_out)[0] = (*iter)[0];\n                (*iter_out)[1] = (*iter)[1];\n                ++iter_out;\n            }\n            for (auto iter = x_end_pos; iter != y_end_pos; ++iter) {\n                (*iter_out)[0] = (*iter)[0];\n                (*iter_out)[1] = (*iter)[1];\n                ++iter_out;\n            }\n            for (auto iter = K[i & 1]; iter != x_end_pos; ++iter) {\n                (*iter_out)[0] = (*iter)[0];\n                (*iter_out)[1] = (*iter)[1];\n                ++iter_out;\n            }\n            K_end = iter_out;\n        }\n \n        //??????\n        int32_t num_buf = 0;\n        int32_t count = 0;\n        for (auto iter = K[M & 1]; iter != K_end; ++iter) {\n            auto n_numbuf = num_buf + (*iter)[1];\n            auto add = std::min(r - ((*iter)[0] - 1), (*iter)[1]);\n            if (num_buf < p) {\n                add -= (p - 1 - num_buf);\n            }\n            if (q < n_numbuf) {\n                add = std::min(add, q - num_buf);\n            }\n            count += std::max(0, add);\n            num_buf = n_numbuf;\n        }\n        std::cout << count << '\\n';\n \n        std::cin >> N;\n    }\n}"
  },
  {
    "language": "C++",
    "code": "#include <tuple>\n#include <vector>\n#include <iostream>\n#include <algorithm>\n\n#pragma warning(disable : 4996)\n\nusing namespace std;\n\nint n, m, p, q, c, r1, r2;\n\nvector<tuple<int, int, int> > dat;\n\ninline void divide(int pos)\n{\n\tvector<tuple<int, int, int> > dat1;\n\n\tint u = dat.size();\n\n\tfor (int i = 0; i < u; i++)\n\t{\n\t\tint l = get<0>(dat[i]);\n\t\tint r = get<1>(dat[i]);\n\t\tint t = get<2>(dat[i]);\n\n\t\tif (l < pos && pos < r)\n\t\t{\n\t\t\tdat[i] = make_tuple(l, pos, t);\n\n\t\t\tdat.insert(dat.begin() + i + 1, make_tuple(pos, r, t + pos - l));\n\t\t}\n\t}\n}\n\ninline void shuffle(int a, int b)\n{\n\tdivide(a);\n\tdivide(b);\n\n\tint l = lower_bound(dat.begin(), dat.end(), make_tuple(a, 0, 0)) - dat.begin();\n\tint r = lower_bound(dat.begin(), dat.end(), make_tuple(b, 0, 0)) - dat.begin();\n\tint u = dat.size();\n\n\tvector<tuple<int, int, int> > dat1;\n\n\tint pos = 0;\n\n\tfor (int i = r; i < u; i++)\n\t{\n\t\tdat1.push_back(make_tuple(pos, pos - get<0>(dat[i]) + get<1>(dat[i]), get<2>(dat[i]))); pos += get<1>(dat[i]) - get<0>(dat[i]);\n\t}\n\n\tfor (int i = l; i < r; i++)\n\t{\n\t\tdat1.push_back(make_tuple(pos, pos - get<0>(dat[i]) + get<1>(dat[i]), get<2>(dat[i]))); pos += get<1>(dat[i]) - get<0>(dat[i]);\n\t}\n\n\tfor (int i = 0; i < l; i++)\n\t{\n\t\tdat1.push_back(make_tuple(pos, pos - get<0>(dat[i]) + get<1>(dat[i]), get<2>(dat[i]))); pos += get<1>(dat[i]) - get<0>(dat[i]);\n\t}\n\n\tdat = dat1;\n}\n\nint main()\n{\n\twhile(true)\n\t{\n\t\tscanf(\"%d\", &n);\n\t\t\n\t\tif (n == 0) { break; }\n\n\t\tscanf(\"%d\", &m);\n\t\tscanf(\"%d\", &p); p--;\n\t\tscanf(\"%d\", &q);\n\t\tscanf(\"%d\", &c);\n\n\t\tdat = { make_tuple(0, n, 1) };\n\n\t\tfor (int i = 0; i < m; i++)\n\t\t{\n\t\t\tscanf(\"%d\", &r1);\n\t\t\tscanf(\"%d\", &r2);\n\n\t\t\tshuffle(r1, r2);\n\t\t}\n\n\t\tint ret = 0;\n\n\t\tfor (int i = 0; i < dat.size(); i++)\n\t\t{\n\t\t\tint l = get<0>(dat[i]);\n\t\t\tint r = get<1>(dat[i]);\n\t\t\tint t = get<2>(dat[i]);\n\n\t\t\tif (p <= l && r <= q)\n\t\t\t{\n\t\t\t\tret += min(max(c - t + 1, 0), r - l);\n\t\t\t}\n\t\t\telse if (l <= p && q <= r)\n\t\t\t{\n\t\t\t\tret += min(max(c - (t + (p - l)), 0), q - p);\n\t\t\t}\n\t\t\telse if (p <= l && l < q)\n\t\t\t{\n\t\t\t\tret += min(max(c - t + 1, 0), q - l);\n\t\t\t}\n\t\t\telse if (p < r && r <= q)\n\t\t\t{\n\t\t\t\tret += min(max(c - (t + (p - l)) + 1, 0), r - p);\n\t\t\t}\n\t\t}\n\n\t\tprintf(\"%d\\n\", ret);\n\t}\n\n\treturn 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include <vector>\n#include <iostream>\n#include <algorithm>\nusing namespace std;\nstruct query {\n\tint p1, p2;\n\tquery() : p1(0), p2(0) {};\n};\nint N, M, x1, x2, x3; vector<query> v;\nint main() {\n\twhile (cin >> N, N) {\n\t\tcin >> M >> x1 >> x2 >> x3; x1--; v.resize(M);\n\t\tfor (int i = 0; i < M; i++) cin >> v[i].p1 >> v[i].p2;\n\t\tvector<int> compress;\n\t\tcompress.push_back(0);\n\t\tcompress.push_back(N);\n\t\tcompress.push_back(x1);\n\t\tcompress.push_back(x2);\n\t\tfor (int i = 0; i < M; i++) {\n\t\t\tcompress.push_back(v[i].p1);\n\t\t\tcompress.push_back(v[i].p2);\n\t\t}\n\t\tsort(compress.begin(), compress.end());\n\t\tcompress.erase(unique(compress.begin(), compress.end()), compress.end());\n\t\tfor (int i = 0; i < M; i++) {\n\t\t\tv[i].p1 = lower_bound(compress.begin(), compress.end(), v[i].p1) - compress.begin();\n\t\t\tv[i].p2 = lower_bound(compress.begin(), compress.end(), v[i].p2) - compress.begin();\n\t\t}\n\t\tint z = compress.size();\n\t\tvector<int> x(z - 1);\n\t\tfor (int i = 0; i < z - 1; i++) x[i] = i;\n\t\tfor (int i = 0; i < M; i++) {\n\t\t\tvector<int> w;\n\t\t\tfor (int j = v[i].p2; j < z - 1; j++) w.push_back(x[j]);\n\t\t\tfor (int j = v[i].p1; j < v[i].p2; j++) w.push_back(x[j]);\n\t\t\tfor (int j = 0; j < v[i].p1; j++) w.push_back(x[j]);\n\t\t\tx = w;\n\t\t}\n\t\tint ret = 0, sum = 0;\n\t\tfor (int i = 0; i < z - 1; i++) {\n\t\t\tint l = sum, r = sum + compress[x[i] + 1] - compress[x[i]]; sum = r;\n\t\t\tif (!(x1 <= l && r <= x2)) continue;\n\t\t\tint ptr = x3 - compress[x[i]] + l + 1;\n\t\t\tret += min(r, ptr) - min(l, ptr);\n\t\t}\n\t\tcout << ret << endl;\n\t}\n\treturn 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include <iostream>\n#include <list>\n#include <vector>\n#include <set>\nusing namespace std;\ntypedef pair<int,int> pa;\n\nint X[10010],Y[10010];\nint main(){\n\tint N,M,P,Q,R,cnt,in,ou,res,le,ri;\n\tbool xfl,yfl;\n\tlist<pa> li[2];\n\tlist<pa>::iterator tit;\n\twhile(true){\n\t\tcin>>N;\n\t\tif(N==0) break;\n\t\tcin>>M>>P>>Q>>R;\n\t\tfor(int i=1;i<=M;i++){\n\t\t\tcin>>X[i]>>Y[i];\n\t\t}\n\t\tin=0;ou=1;\n\t\tli[in].clear();\n\t\tli[in].push_back(pa(1,N));\n\t\tfor(int i=1;i<=M;i++){\n\t\t\tcnt=0;xfl=yfl=false;\n\t\t\tli[ou].clear();\n\t\t\ttit=li[ou].end();\n\t\t\tfor(auto it=li[in].begin();it!=li[in].end();it++){\n\t\t\t\tif((!xfl)&&cnt+((it->second)-(it->first)+1)>=X[i]){\n\t\t\t\t\tli[ou].insert(tit,pa(it->first,it->first+(X[i]-cnt)-1));\n\t\t\t\t\ttit=li[ou].begin();\n\t\t\t\t\tif(cnt+((it->second)-(it->first))+1>=Y[i]){\n\t\t\t\t\t\tli[ou].insert(tit,pa(it->first+(X[i]-cnt),it->first+(Y[i]-cnt)-1));\n\t\t\t\t\t\ttit=li[ou].begin();\n\t\t\t\t\t\tli[ou].insert(tit,pa(it->first+(Y[i]-cnt),it->second));\n\t\t\t\t\t\tyfl=true;\n\t\t\t\t\t}\n\t\t\t\t\telse if(cnt+((it->second)-(it->first))+1>X[i])li[ou].insert(tit,pa(it->first+(X[i]-cnt),it->second));\n\t\t\t\t\txfl=true;\n\t\t\t\t}\n\t\t\t\telse if((!yfl)&&cnt+((it->second)-(it->first))+1>=Y[i]){\n\t\t\t\t\tli[ou].insert(tit,pa(it->first,it->first+(Y[i]-cnt)-1));\n\t\t\t\t\ttit=li[ou].begin();\n\t\t\t\t\tif(cnt+((it->second)-(it->first))+1>Y[i]) li[ou].insert(tit,pa(it->first+(Y[i]-cnt),it->second));\n\t\t\t\t\tyfl=true;\n\t\t\t\t}\n\t\t\t\telse{\n\t\t\t\t\tli[ou].insert(tit,(*it));\n\t\t\t\t}\n\t\t\t\tcnt+=(it->second-it->first+1);\n\t\t\t}\n\t\t\tswap(in,ou);\n\t\t}\n\t\tres=0,cnt=0;\n\t\tfor(auto it=li[in].begin();it!=li[in].end();it++){\n\t\t\tif(R<it->first){\n\t\t\t\tcnt+=((it->second)-(it->first)+1);\n\t\t\t\tcontinue;\n\t\t\t}\n\t\t\tle=cnt+1;\n\t\t\tri=min(cnt+it->second-it->first+1,R-(it->first)+le);\n\t\t\tres+=max(0,min(ri,Q)-max(le,P)+1);\n\t\t\tcnt+=((it->second)-(it->first)+1);\n\t\t}\n\t\tcout<<res<<endl;\n\t}\n\treturn 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include <vector>\n#include <iostream>\n#include <algorithm>\nusing namespace std;\nstruct query {\n\tint p1, p2;\n\tquery() : p1(0), p2(0) {};\n};\nint N, M, x1, x2, x3; vector<query> v;\nint main() {\n\twhile (cin >> N, N) {\n\t\tcin >> M >> x1 >> x2 >> x3; x1--; v.resize(M);\n\t\tfor (int i = 0; i < M; i++) cin >> v[i].p1 >> v[i].p2;\n\t\tvector<int> compress;\n\t\tcompress.push_back(0);\n\t\tcompress.push_back(N);\n\t\tcompress.push_back(x1);\n\t\tcompress.push_back(x2);\n\t\tfor (int i = 0; i < M; i++) {\n\t\t\tcompress.push_back(v[i].p1);\n\t\t\tcompress.push_back(v[i].p2);\n\t\t}\n\t\tsort(compress.begin(), compress.end());\n\t\tcompress.erase(unique(compress.begin(), compress.end()), compress.end());\n\t\tfor (int i = 0; i < M; i++) {\n\t\t\tv[i].p1 = lower_bound(compress.begin(), compress.end(), v[i].p1) - compress.begin();\n\t\t\tv[i].p2 = lower_bound(compress.begin(), compress.end(), v[i].p2) - compress.begin();\n\t\t}\n\t\tint z = compress.size();\n\t\tvector<int> x(z - 1);\n\t\tfor (int i = 0; i < z - 1; i++) x[i] = i;\n\t\tfor (int i = 0; i < M; i++) {\n\t\t\tvector<int> w;\n\t\t\tfor (int j = v[i].p2; j < z - 1; j++) w.push_back(x[j]);\n\t\t\tfor (int j = v[i].p1; j < v[i].p2; j++) w.push_back(x[j]);\n\t\t\tfor (int j = 0; j < v[i].p1; j++) w.push_back(x[j]);\n\t\t\tx = w;\n\t\t}\n\t\tint ret = 0, sum = 0;\n\t\tfor (int i = 0; i < z - 1; i++) {\n\t\t\tint l = sum, r = sum + compress[x[i] + 1] - compress[x[i]]; sum = r;\n\t\t\tif (!(x1 <= l && r <= x2)) continue;\n\t\t\tint ptr = x3 - compress[x[i]] + l;\n\t\t\tret += min(r, ptr) - min(l, ptr);\n\t\t}\n\t\tcout << ret << endl;\n\t}\n\treturn 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include <iostream>\n#include <algorithm>\n#include <vector>\nusing namespace std;\nint main(){\n\tint n,m,p,q,r,x,y;\n\tvector<int>::iterator itx,ity,it;\n\tfor(;cin>>n>>m>>p>>q>>r;cout<<x<<endl){\n\t\tvector<int> v1,v2;\n\t\tv1.push_back(0);\n\t\tfor(v1.push_back(r);m--;v2.clear()){\n\t\t\tcin>>x>>y;\n\t\t\titx=upper_bound(v1.begin(),v1.end(),x);\n\t\t\tity=upper_bound(v1.begin(),v1.end(),y);\n\t\t\t\n\t\t\tif( ity-v1.begin()+1 & 1 )v2.push_back(0);\n\t\t\tv2.push_back(0);\n\t\t\tfor(it=ity;it!=v1.end();++it)\n\t\t\t\tv2.push_back(*it - y);\n\t\t\t\n\t\t\tif(v1.end()-itx & 1)v2.push_back(n-y);\n\t\t\tfor(it=itx;it!=ity;++it)\n\t\t\t\tv2.push_back(*it-x+n-y);\n\t\t\t\n\t\t\tit = v1.begin();\n\t\t\tif(ity-v1.begin() & 1)++it;\n\t\t\tif(!it[1])it+=2;\n\t\t\tif(*it+n-x==v2.back()){++it;v2.pop_back();}\n\t\t\tfor(;it!=itx;++it)\n\t\t\t\tv2.push_back(*it+n-x);\n\t\t\t\n\t\t\tv1.swap(v2);\n\t\t}\n\t\tv1.insert( upper_bound(v1.begin(),v1.end(),p-1), 2, p-1);\n\t\tv1.insert( lower_bound(v1.begin(),v1.end(),q), q );\n\t\tv1.push_back(n);\n\t\tit = upper_bound(v1.begin(),v1.end(),p-1);\n\t\tif(it-v1.begin() & 1) --it;\n\t\tfor(x=0;*it<q;++it)\n\t\t\tm=*it++,x+=*it-m;\n\t}\n}"
  },
  {
    "language": "C++",
    "code": "\n#include<iostream>\nusing namespace std;\nint cards,n,i,p,q,r,x[5000],y[5000],counter;\n  int numberStart[10001];\n  int numberFast[10001];\n  int numberEnd[10001];\nint numberLong(int value){\n\treturn numberEnd[value]-numberStart[value]+1;\n}\n\nint seach(int k ){\n  int l=0;\n\n  \n  for ( int a=1;a<=10000;a++){\n    if (numberStart[a]<=k && k<numberEnd[a]){\n      l=numberFast[a];\n      return l;\n    }\n    }\n\t\n  return -100;\n  }\nint seachB(int NumberFast){\n  int l=0;\n  for ( int a=1;a<=10000;a++){\n    if (NumberFast==numberFast[a]){\n      l=a;\n      return l;\n    }\n    }\n  return -100;\n  }\nint seachC(int seed){\n  //return seachB(seach(seed));\n\t\t\tint l=0;\n  for (int a=1;a<=10000;a++){\n\tif(seed>l+numberLong(seachB(a))){\n\tl+=numberLong(seachB(a));\n\t}\n\telse{\n\t return numberFast[seachB(a)];\n\t}\n  }\n return -100;\n\t\n}\nint searchD(int seed){\n\t\tint l=0;\n  for (int a=1;a<=10000;a++){\n\tif(seed>l+numberLong(seachB(a))){\n\tl+=numberLong(seachB(a));\n\t}\n\telse{\n\t return numberFast[seachB(a)];\n\t}\n  }\n return -100;\n\t\n}\nint searchNumber(int value){\n\tint l=0;\n  for (int a=1;a<=10000;a++){\n\tif(value>l+numberLong(seachB(a))){\n\tl+=numberLong(seachB(a));\n\t}\n\telse{\n\t return numberStart[seachB(a)]+value-l-1;\n\t}\n  }\n return -100;\n}\n\nint make(int sequence,int counter ){\n  counter++;\n // numberStart[counter]=j;\n // numberEnd[counter]=k;\n  return 0;\n}\nint StartHead(int value){\n\tint longs=1;\n\tfor (int i=1;i<=counter;i++){\n\t\n\t\tif (numberFast[i]<numberFast[value]){\n\t\t\tlongs+=numberLong(i);\n\t\t}\n\t}\n\treturn longs;\n\n\n}\nvoid cut(int g){\n\tif(searchD(g)==searchD(g+1)){\n  //カットする場所が入ってる数列を求める\n  int seachX=seachB(seachC(g));\n  int seachXX=searchNumber(g);\n//数列ができる範囲の後ろの番号FASTを変える\n     for(int j=1;j<=counter;j++){\n      if (numberFast[j]>=numberFast[seachX]+1){\n      numberFast[j]++;\n     }\n    }\n\n  //の数列の後ろに新しい数列を作る\n counter++;\n //for \n make(seachX,counter);\n  numberFast[counter]=numberFast[seachX]+1;\n  numberStart[counter] =searchNumber(g)+1;\n  numberEnd[counter]=numberEnd[seachX];\n  //できた数列の前の数列の最後を調整する\n  numberEnd[seachX]=searchNumber(g);\n \n\t}\n}\nvoid shuffle(int x,int y){\n\t\n\t\n\tint  numberFastNew[10001];\n\n\tint newCounter[3];\n\tfor(int i=0;i<3;i++){\n\t\tnewCounter[i]=0;\n\t}\n\tfor(int j=1;j<=counter;j++){\n\t\tif (StartHead(j)>y){\n\t\t\tnewCounter[0]++;\n\t\tnumberFastNew[j]=0;\n\t\t}\n\t}\n\t\n\tfor(int j=1;j<=counter;j++){\n\t\tif (StartHead(j)>x && StartHead(j)+numberLong(j)-1<=y){\n\t\t\tnewCounter[1]++;\n\t\tnumberFastNew[j]=1;\n\t\t}\n\t}\n\t\n\tfor(int j=1;j<=counter;j++){\n\t\t\tif (StartHead(j)+numberLong(j)-1<=x){\n\t\t\tnewCounter[2]++;\n\t\tnumberFastNew[j]=2;\n\t\t}\n\t}\n\t\n\tfor(int j=1;j<=counter;j++){\n\t\tswitch(numberFastNew[j]){\n\t\t\tcase 0:\n\t\t\t\tnumberFast[j]+=-newCounter[1]-newCounter[2];\n\t\t\t\tbreak;\n\t\t\tcase 1:\n\t\t\t\tnumberFast[j]+=newCounter[0]-newCounter[2];\n\t\t\t\tbreak;\n\t\t\tcase 2:\n\t\t\t\tnumberFast[j]+=newCounter[1]+newCounter[0];\n\t\t\t\tbreak;\n\t\t}\n\n\t}\n\n\t\n  /*  making[];\n  numbersb(counter);\n    getter(x+1);\n    numbersb(counter)=y-x;\n    getter(y+1);\n    numbersb(counter)=cards-y;\n  }\n  \n  for(int  j=1;j<=cards;j++){\n    if (p>=j && p<=j && numbers[j]<=r){\n      cout <<  numbers[j] << endl;\n    }\n  \n\n  for (int i=1;i<=2;i++){\n  cout << numberStart[i] << \" \" << numberEnd[i] << \" \" << numberFast[i] << \" \" << endl;\n  }\n  */\n}\n\n\nint main(void)\n{\n\twhile(true){\n\tcards=0;\n\tn=0;\n\tcounter=0;\n\tint points=0;\n  counter=1;\n  cin >> cards;\n  if (cards==0){\n\t  break;\n  }\n  numberStart[1]=1;\n  numberEnd[1]=cards;\n  numberFast[1]=1;\n  cin >> n;\n  cin >> p  >> q  >> r ;\n  for (i=1;i<=n;i++){\n    cin >> x[i] >> y[i];\n  }\n  for (i=1;i<=n;i++){\n     cut(x[i]);\n\t \n      cut(y[i]);\n\t  \n     shuffle(x[i],y[i]);\n  }\n\n  for(int j=p;j<=q;j++){\n\t  if(searchNumber(j)<=r){\n\t\t  points++;\n\t  }\n  }\n  cout << points << endl;\n\t}\n}"
  },
  {
    "language": "C++",
    "code": "//  4???27??\\  ????????????0535 ; ?????£?????????\n// http://judge.u-aizu.ac.jp/onlinejudge/description.jsp?id=0536\n\n#include <iostream>\n#define NUM 100000\nusing namespace std;\n\nint main(){\n\n  int n;//?????????????????°\n  int m;//?????£??????????????°\n  int p,q;//p ???????????? q ?????????????????????\n  int r;// r??\\?????????????????????????????????\n  register int x[5000],y[5000];//????????????????????´???\n  register int card[NUM];\n  int i;\n  int A[NUM];\n  int B[NUM];\n  int C[NUM];\n\n  do{\n    int j = 0;\n    int count = 1;\n    int step = 1;\n    int red = 1;\n    int blue = 1;\n    int green = 0;\n\n    cin >> n;\n    cin >> m;\n    cin >> p >> q >> r;\n\n    if (!n){\n      break;\n    }\n\n    for (i=0; i < m; i++){\n      cin >> x[i] >> y[i];\n    }\n\n    while (j < m){\n\n      for (i=1; i <= n; i++ ){//??°?????£??\\\n        card[i] = i;\n      }\n\n      for (i=1 ; i <= x[j] ;i++ ){//????????????1~X???????????§\n        A[i] = card[i];\n      }\n\n      while (i <= y[j]){//????????????X+1~Y???????????§\n        B[count] = card[i];\n        i++;\n        count++;\n      }\n\n      while (i <= n){//????????????Y+1~n???????????§\n        C[step] = card[i];\n        i++;\n        step++;\n      }\n\n      for (i=1; i <= (n - y[j]); i++ ){//C?????°?????£??\\\n        card[i] = C[i];\n      }\n\n      while (red <= count){//B?????°?????£??\\\n        card[i] = B[red];\n        i++;\n        red++;\n      }\n\n      while (blue <= step){//A?????°?????£??\\\n        card[i] = A[blue];\n        i++;\n        blue++;\n      }\n      j++;\n    }\n\n    for (i=p; i <= q; i++){\n      if (card[i] <= r){\n        green++;\n      }\n    }\n\n    cout << green << endl;\n  } while (n);\n\n  return 0;\n\n}"
  },
  {
    "language": "C++",
    "code": "#include <iostream>\n#include <utility>\n#include <list>\n#include <algorithm>\n\nint main() {\n\tint n, m, p, q, r;\n\twhile (std::cin >> n, n != 0) {\n\t\tstd::list<std::pair<int, int>> cards;\n\t\tcards.push_back({ 1, n });\n\n\t\tstd::cin >> m >> p >> q >> r;\n\t\tfor (int i = 0; i < m; ++i) {\n\t\t\tint x, y;\n\t\t\tstd::cin >> x >> y;\n\t\t\t\n\t\t\tbool flag = false, which;\n\t\t\tdecltype(cards)::iterator sec1, sec2;\n\t\t\tfor (auto itr = cards.begin(); itr != cards.end(); ++itr) {\n\t\t\t\tif (itr->first <= x && x <= itr->second) {\n\t\t\t\t\tcards.insert(itr, { {itr->first, x}, {x + 1, itr->second} });\n\t\t\t\t\tsec1 = itr = cards.erase(itr);\n\t\t\t\t\t--itr;\n\t\t\t\t\tif (!flag)\n\t\t\t\t\t\t----sec1, which = false, flag = true;\n\t\t\t\t\telse\n\t\t\t\t\t\t--sec1, ++sec2;\n\t\t\t\t}\n\t\t\t\tif (itr->first <= y && y <= itr->second) {\n\t\t\t\t\tcards.insert(itr, { { itr->first, y },{ y + 1, itr->second } });\n\t\t\t\t\tsec2 = itr = cards.erase(itr);\n\t\t\t\t\t--itr;\n\t\t\t\t\tif (!flag)\n\t\t\t\t\t\t----sec2, which = true, flag = true;\n\t\t\t\t\telse\n\t\t\t\t\t\t--sec2, ++sec1;\n\t\t\t\t}\n\t\t\t}\n\n\t\t\tif (which) {\n\t\t\t\tcards.splice(cards.end(), cards, sec2, sec1);\n\t\t\t\tcards.splice(cards.end(), cards, cards.begin(), sec1);\n\t\t\t}\n\t\t\telse {\n\t\t\t\tcards.splice(cards.end(), cards, sec1, sec2);\n\t\t\t\tcards.splice(cards.end(), cards, cards.begin(), sec2);\n\t\t\t}\n\t\t}\n\n\t\tint count = 0, ans = 0;\n\t\tfor (auto&& rng : cards) {\n\t\t\tint rngSize = rng.second - rng.first + 1;\n\n\t\t\tcount += rngSize;\n\n\t\t\tif (rng.first > r)\n\t\t\t\tcontinue;\n\t\t\telse if (rng.first <= r && r < rng.second)\n\t\t\t\trngSize -= rng.second - r;\n\n\t\t\tif (count > q) {\n\t\t\t\tans += std::max(0, rngSize - (count - q));\n\t\t\t\tbreak;\n\t\t\t}\n\t\t\tif (count >= p)\n\t\t\t\tans += std::min(rngSize, count - p);\n\t\t}\n\n\t\tstd::cout << ans << std::endl;\n\t}\n}"
  },
  {
    "language": "C++",
    "code": "\n#include<iostream>\nusing namespace std;\nint cards,n,i,p,q,r,x[5000],y[5000],counter;\n  int numberStart[10001];\n  int numberFast[10001];\n  int numberEnd[10001];\nint numberLong(int value){\n\treturn numberEnd[value]-numberStart[value]+1;\n}\n\nint seach(int k ){\n  int l=0;\n\n  \n  for ( int a=1;a<=counter+1;a++){\n    if (numberStart[a]<=k && k<numberEnd[a]){\n      l=numberFast[a];\n      return l;\n    }\n    }\n\t\n  return -100;\n  }\nint seachB(int NumberFast){\n  int l=0;\n  for ( int a=1;a<=counter+1;a++){\n    if (NumberFast==numberFast[a]){\n      l=a;\n      return l;\n    }\n    }\n  return -100;\n  }\nint seachC(int seed){\n  //return seachB(seach(seed));\n\t\t\tint l=0;\n  for (int a=1;a<=counter+1;a++){\n\tif(seed>l+numberLong(seachB(a))){\n\tl+=numberLong(seachB(a));\n\t}\n\telse{\n\t return numberFast[seachB(a)];\n\t}\n  }\n return -100;\n\t\n}\nint searchD(int seed){\n\t\tint l=0;\n  for (int a=1;a<=counter+1;a++){\n\tif(seed>l+numberLong(seachB(a))){\n\tl+=numberLong(seachB(a));\n\t}\n\telse{\n\t return numberFast[seachB(a)];\n\t}\n  }\n return -100;\n\t\n}\nint searchNumber(int value){\n\tint l=0;\n  for (int a=1;a<=counter+1;a++){\n\tif(value>l+numberLong(seachB(a))){\n\tl+=numberLong(seachB(a));\n\t}\n\telse{\n\t return numberStart[seachB(a)]+value-l-1;\n\t}\n  }\n return -100;\n}\n\nint make(int sequence,int counter ){\n  counter++;\n // numberStart[counter]=j;\n // numberEnd[counter]=k;\n  return 0;\n}\nint StartHead(int value){\n\tint longs=1;\n\tfor (int i=1;i<=counter;i++){\n\t\n\t\tif (numberFast[i]<numberFast[value]){\n\t\t\tlongs+=numberLong(i);\n\t\t}\n\t}\n\treturn longs;\n\n\n}\nvoid cut(int g){\n\tif(searchD(g)==searchD(g+1)){\n  //カットする場所が入ってる数列を求める\n  int seachX=seachB(seachC(g));\n  int seachXX=searchNumber(g);\n//数列ができる範囲の後ろの番号FASTを変える\n     for(int j=1;j<=counter;j++){\n      if (numberFast[j]>=numberFast[seachX]+1){\n      numberFast[j]++;\n     }\n    }\n\n  //の数列の後ろに新しい数列を作る\n counter++;\n //for \n make(seachX,counter);\n  numberFast[counter]=numberFast[seachX]+1;\n  numberStart[counter] =searchNumber(g)+1;\n  numberEnd[counter]=numberEnd[seachX];\n  //できた数列の前の数列の最後を調整する\n  numberEnd[seachX]=searchNumber(g);\n \n\t}\n}\nvoid shuffle(int x,int y){\n\t\n\t\n\tint  numberFastNew[10001];\n\n\tint newCounter[3];\n\tfor(int i=0;i<3;i++){\n\t\tnewCounter[i]=0;\n\t}\n\tfor(int j=1;j<=counter;j++){\n\t\tif (StartHead(j)>y){\n\t\t\tnewCounter[0]++;\n\t\tnumberFastNew[j]=0;\n\t\t}\n\t}\n\t\n\tfor(int j=1;j<=counter;j++){\n\t\tif (StartHead(j)>x && StartHead(j)+numberLong(j)-1<=y){\n\t\t\tnewCounter[1]++;\n\t\tnumberFastNew[j]=1;\n\t\t}\n\t}\n\t\n\tfor(int j=1;j<=counter;j++){\n\t\t\tif (StartHead(j)+numberLong(j)-1<=x){\n\t\t\tnewCounter[2]++;\n\t\tnumberFastNew[j]=2;\n\t\t}\n\t}\n\t\n\tfor(int j=1;j<=counter;j++){\n\t\tswitch(numberFastNew[j]){\n\t\t\tcase 0:\n\t\t\t\tnumberFast[j]+=-newCounter[1]-newCounter[2];\n\t\t\t\tbreak;\n\t\t\tcase 1:\n\t\t\t\tnumberFast[j]+=newCounter[0]-newCounter[2];\n\t\t\t\tbreak;\n\t\t\tcase 2:\n\t\t\t\tnumberFast[j]+=newCounter[1]+newCounter[0];\n\t\t\t\tbreak;\n\t\t}\n\n\t}\n\n\t\n  /*  making[];\n  numbersb(counter);\n    getter(x+1);\n    numbersb(counter)=y-x;\n    getter(y+1);\n    numbersb(counter)=cards-y;\n  }\n  \n  for(int  j=1;j<=cards;j++){\n    if (p>=j && p<=j && numbers[j]<=r){\n      cout <<  numbers[j] << endl;\n    }\n  \n\n  for (int i=1;i<=2;i++){\n  cout << numberStart[i] << \" \" << numberEnd[i] << \" \" << numberFast[i] << \" \" << endl;\n  }\n  */\n}\n\n\nint main(void)\n{\n\twhile(true){\n\tcards=0;\n\tn=0;\n\tcounter=0;\n\tint points=0;\n  counter=1;\n  cin >> cards;\n  if (cards==0){\n\t  break;\n  }\n  numberStart[1]=1;\n  numberEnd[1]=cards;\n  numberFast[1]=1;\n  cin >> n;\n  cin >> p  >> q  >> r ;\n  for (i=1;i<=n;i++){\n    cin >> x[i] >> y[i];\n  }\n  for (i=1;i<=n;i++){\n     cut(x[i]);\n\t \n      cut(y[i]);\n\t  \n     shuffle(x[i],y[i]);\n  }\n\n  for(int j=p;j<=q;j++){\n\t  if(searchNumber(j)<=r){\n\t\t  points++;\n\t  }\n  }\n  cout << points << endl;\n\t}\n}"
  },
  {
    "language": "C++",
    "code": "#include<iostream>\n#include<stdio.h>\n#include<math.h>\n#include    <iomanip>\n#include    <map>\n#include    <set>\n#include    <vector>\nusing namespace std;\nvector<int> func(vector<int> &vec,int a,int b){\n    vector<int> v1,v2,v3;\n    int flag=1;\n    //1-a\n    for(auto it:vec){\n        if (flag<=a) {\n            v1.push_back(it);\n        }else if (flag<=b){\n            v2.push_back(it);\n        }else{\n            v3.push_back(it);\n        }\n        flag++;\n    }\n    \n    for(auto it:v2){\n        v3.push_back(it);\n    }\n    for(auto it:v1){\n        v3.push_back(it);\n    }\n    //a+1 - b\n    //b+1 - n1\n    return v3;\n}\nint a[100000000][2];\nint main(){\n    int n1,n2,n3,n4;\n    while(cin>>n1&&n1!=0){\n        cin>>n2;\n        int p,q,r;\n        cin>>p>>q>>r;;\n        \n        for (int i=0; i<n2; i++) {\n            for (int j=0; j<2; j++) {\n                cin>>a[i][j];\n            }\n        }\n        \n        //1-n1\n        vector<int> vec;\n        for(int i=1;i<n1+1;i++){\n            vec.push_back(i);\n        }\n        \n        for (int i=0; i<n2; i++) {\n            vec=func(vec,a[i][0],a[i][1]);\n        }\n        int sum=0;\n        for(int i=p;i<=q;i++){\n            if(vec[i-1]<=r)sum++;\n        }\n        cout<<sum<<endl;\n    }\n    return 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include<iostream>\n#include<cstdio>\n#include<vector>\n#include<queue>\n#include<algorithm>\n#include<functional>\n#include<cstring>\n#define MAX_N 100000\n#define F first\n#define S second \n#define MP make_pair\nusing namespace std;\ntypedef pair<int, int> P;\n\nconst int INF = 1e9;\n\nint main() {\n\tint n, m, pp, q, r;\n\n\twhile (cin >> n&&n){\t\n\t\tint save = -1, ans = 0;\n\t\tvector<P>vep, vep2, vep3;\n\t\tvep.push_back(MP(1, 1));\n\t\tvep.push_back(MP(n, n));\n\t    vector<int> vec, vec2, vec3;\n\t\tvec.push_back(1);\n\t\tvec.push_back(n);\n\t\tcin >> m >> pp >> q >> r;\n\t\tfor (int i = 0; i < m; i++) {\n\t\t\tint x, y, p, p2;\n\t\t\tscanf(\"%d%d\", &x, &y);\n\t\t\tp = lower_bound(vec.begin(), vec.end(), x) - vec.begin();\n\t\t\tif (vec[p] != x) {\n\t\t\t\tvec.insert(vec.begin() + p, x);\n\t\t\t\tP a = MP(vec[p] - vec[p - 1] + vep[p - 1].F, x);\n\t\t\t\tvep.insert(vep.begin() + p, a);\n\t\t\t}\n\t\t\tif (vep[p].S + 1 != vep[p + 1].S) {\n\t\t\t\tvec.insert(vec.begin() + p + 1, x + 1);\n\t\t\t\tP a = MP(vep[p].F + 1, x + 1);\n\t\t\t\tvep.insert(vep.begin() + p + 1, a);\n\t\t\t}\n\t\t\tp2 = lower_bound(vec.begin(), vec.end(), y) - vec.begin();\n\t\t\tif (vec[p2] != y) {\n\t\t\t\tvec.insert(vec.begin() + p2, y);\n\t\t\t\tP a = MP(vec[p2] - vec[p2 - 1] + vep[p2 - 1].F, y);\n\t\t\t\tvep.insert(vep.begin() + p2, a);\n\t\t\t}\n\t\t\tif (vep[p2].S + 1 != vep[p2 + 1].S) {\n\t\t\t\tvec.insert(vec.begin() + p2 + 1, y + 1);\n\t\t\t\tP a = MP(vep[p2].F + 1, y + 1);\n\t\t\t\tvep.insert(vep.begin() + p2 + 1, a);\n\t\t\t}\n\t\t\tfor (int j = p2 + 1; j < vec.size(); j++) {\n\t\t\t\tvec2.push_back(vec[j] - vec[p2 + 1] + 1);\n\t\t\t\tvep2.push_back(MP(vep[j].F, vec[j] - vec[p2 + 1] + 1));\n\t\t\t}\n\t\t\tint size = vec2[vec2.size() - 1];\n\t\t\tfor (int j = p + 1; j < p2 + 1; j++) {\n\t\t\t\tvec2.push_back(vec[j] - vec[p + 1] + 1 + size);\n\t\t\t\tvep2.push_back(MP(vep[j].F, vec[j] - vec[p + 1] + 1 + size));\n\t\t\t}\n\t\t\tsize = vec2[vec2.size() - 1];\n\t\t\tfor (int j = 0; j < p + 1; j++) {\n\t\t\t\tvec2.push_back(vec[j] - vec[0] + 1+size);\n\t\t\t\tvep2.push_back(MP(vep[j].F, vec[j] - vec[0] + 1+size));\n\t\t\t}\n\t\t\tvec3 = vec;\n\t\t\tvep3 = vep;\n\t\t\tvec = vec2;\n\t\t\tvep = vep2;\n\t\t\tvec2 = vec3;\n\t\t\tvep2 = vep3;\n\t\t\tvec2.clear();\n\t\t\tvep2.clear();\n\t\t}\n\t\tint p, p2;\n\t\tp = lower_bound(vec.begin(), vec.end(), pp) - vec.begin();\n\t\t\n\t\tif (vec[p] != pp) {\n\t\t\tvec.insert(vec.begin() + p, pp);\n\t\t\tP a = MP(vec[p] - vec[p - 1] + vep[p-1].F, pp);\n\t\t\tvep.insert(vep.begin() + p, a);\n\t\t}\n\t\tif (vep[p].S + 1 != vep[p + 1].S) {\n\t\t\tvec.insert(vec.begin() + p + 1, pp + 1);\n\t\t\tP a = MP(vep[p].F + 1, pp + 1);\n\t\t\tvep.insert(vep.begin() + p + 1, a);\n\t\t}\n\t\tp2 = lower_bound(vec.begin(), vec.end(), q) - vec.begin();\n\t\tif (vec[p2] != q) {\n\t\t\tvec.insert(vec.begin() + p2, q);\n\t\t\tP a = MP(vec[p2] - vec[p2 - 1] + vep[p2-1].F, q);\n\t\t\tvep.insert(vep.begin() + p2, a);\n\t\t}\n\t\tif (vep[p2].S + 1 != vep[p2 + 1].S) {\n\t\t\tvec.insert(vec.begin() + p2 + 1, q + 1);\n\t\t\tP a = MP(vep[p2].F + 1, q + 1);\n\t\t\tvep.insert(vep.begin() + p2 + 1, a);\n\t\t}\n\t\tfor (int i = p; i <= p2; i++) {\n\t\t\tif (i + 1<=p2 && vep[i + 1].F - vep[i].F == vep[i + 1].S - vep[i].S) {\n\t\t\t\tfor (int j = vep[i].F; j <= vep[i + 1].F; j++) {\n\t\t\t\t\tif (j <= r&&save!=j) {\n\t\t\t\t\t\tans++;\n\t\t\t\t\t\tsave = j;\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t}\n\t\t\telse{\n\t\t\t\tif (vep[i].F <= r&&save != vep[i].F) {\n\t\t\t\t\tans++;\n\t\t\t\t\tsave = vep[i].F;\n\t\t\t\t}\n\t\t\t}\n\t}\n\t\tcout << ans << endl;\n\t}\n}"
  },
  {
    "language": "C++",
    "code": "#include <iostream>\n#include <cstdio>\n#include <cmath>\n#include <vector>\n#include <map>\n#include <stack>\n#include <queue>\n#include <algorithm>\n#include <set>\n\n#define FOR(i,a,b) for(int i=(a);i<(b);i++)\n#define REP(i,j) FOR(i,0,j)\n#define mp std::make_pair\n\ntypedef long long ll;\ntypedef unsigned long long ull;\ntypedef std::pair<int,int> P;\ntypedef std::pair<int,P> State;\n\nconst int INF = 1001001001;\n\n// S N E W(南北東西)\nconst int dx[8] = {0, 0, 1, -1, 1, 1, -1, -1}, dy[8] = {1, -1, 0, 0, 1, -1, 1, -1};\n\nint N, M;\n\nstruct Node{\n    int begin, end;\n    Node *prev, *next;\n};\n\n// 0, 1, 2, 3, 4, 5, 6, 7, 8\n// 1, 2, 3, 4, 5, 6, 7, 8, 9\n// [6, 7, 8, 9], [4, 5], [1, 2, 3]\nNode* update(Node* n, int index){\n    int size = n->end - n->begin;\n    if(index == 0){\n        return n;\n    }else if(0 < index && index < size){\n        Node* new_node = new Node{n->begin + index, n->end, n, n->next};\n        n->end = new_node->begin;\n        n->next = new_node;\n        return new_node;\n    }\n    return update(n->next, index-size);\n}\n\nNode* tail(Node* n){\n    if(n->next == nullptr){return n;}\n    return tail(n->next);\n}\n\nvoid test(Node* n){\n    while(n != nullptr){\n        printf(\"[%d, %d)\\n\", n->begin, n->end);\n        n = n->next;\n    }\n    puts(\"---------------------------\");\n}\n\nP intersect(int al, int ar, int bl, int br){\n    if(al <= bl && br <= ar){return mp(bl, br);}\n    if(bl <= al && ar <= br){return mp(al, ar);}\n    if(al <= bl && bl < ar){return mp(bl, ar);}\n    if(bl <= al && al < br){return mp(al, br);}\n    return mp(-1, -1);\n}\n\nint count(Node* root, int begin, int end, int v){\n    int pos = 0, res = 0;\n    while(root != nullptr){\n        int size = root->end - root->begin;\n        \n        if(v - root->begin >= 0){\n            P is = intersect(begin, end, pos, pos+std::min(v-root->begin+1, size));\n            if(is.first != -1){\n                res += is.second - is.first;\n            }\n        }\n\n        pos += size;\n        root = root->next;\n    }\n\n    return res;\n}\n\nint main(){\n    while(std::cin >> N >> M, N){\n        int p, q, r;\n        std::cin >> p >> q >> r;\n\n        Node *root = new Node{1, N+1, nullptr, nullptr};\n        REP(i, M){\n            int a, b;\n            std::cin >> a >> b;\n\n            // シャッフル前 [a1, ..., a2], [b1, ..., b2], [c1, ..., c2]\n            // シャッフル後 [c1, ..., c2], [b1, ..., b2], [a1, ..., a2] (a2後ろの接続を断つ)\n            Node *a1 = root, *b1 = update(root, a), *c1 = update(root, b),\n                *a2 = b1->prev, *b2 = c1->prev, *c2 = tail(root);\n        \n            c2->next = b1;\n            b1->prev = c2;\n            b2->next = a1;\n            a1->prev = b2;\n            a2->next = nullptr;\n\n            root = c1;\n        }\n    \n        printf(\"%d\\n\", count(root, p-1, q, r));\n    }\n}"
  },
  {
    "language": "C++",
    "code": "#include <iostream>\n#include <algorithm>\n#include <vector>\nusing namespace std;\nint main(){\n\tint n,m,p,q,r,x,y;\n\tvector<int>::iterator itx,ity,it;\n\tfor(;cin>>n>>m>>p>>q>>r;cout<<x<<endl){\n\t\tvector<int> v1,v2;\n\t\tv1.push_back(0);\n\t\tfor(v1.push_back(r);m--;v2.clear()){\n\t\t\tcin>>x>>y;\n\t\t\titx=upper_bound(v1.begin(),v1.end(),x);\n\t\t\tity=upper_bound(v1.begin(),v1.end(),y);\n\t\t\t\n\t\t\tif( ity-v1.begin()+1 & 1 )v2.push_back(0);\n\t\t\tv2.push_back(0);\n//\t\t\tv2.insert(v2.end(),ity-v1.begin()&1?1:2,0);\n\t\t\tfor(it=ity;it!=v1.end();++it)\n\t\t\t\tv2.push_back(*it - y);\n\t\t\t\n\t\t\tif(v1.end()-itx & 1)v2.push_back(n-y);\n\t\t\tfor(it=itx;it!=ity;++it)\n\t\t\t\tv2.push_back(*it-x+n-y);\n\t\t\t\n\t\t\tit = v1.begin();\n\t\t\tif(ity-v1.begin() & 1)++it;\n\t\t\tif(!it[1])it+=2;\n\t\t\tif(*it+n-x==v2.back()){++it;v2.pop_back();}\n\t\t\tfor(;it!=itx;++it)\n\t\t\t\tv2.push_back(*it+n-x);\n\t\t\t\n\t\t\tv1.swap(v2);\n\t\t}\n\t\tv1.insert( upper_bound(v1.begin(),v1.end(),p-1), 2, p-1);\n\t\tv1.insert( lower_bound(v1.begin(),v1.end(),q), q );\n\t\tv1.push_back(n);\n\t\tit = upper_bound(v1.begin(),v1.end(),p-1);\n\t\tif(it-v1.begin() & 1) --it;\n\t\tfor(x=0;*it<q;++it){\n\t\t\tm=*it;++it;\n\t\t\tx+=*it-m;\n\t\t}\n\t}\n}"
  },
  {
    "language": "C++",
    "code": "#include <iostream>\n#include <algorithm>\n#include <vector>\nusing namespace std;\nint main(){\n\tint n,m,p,q,r,x,y;\n\tvector<int>::iterator itx,ity,it;\n\tfor(;cin>>n>>m>>p>>q>>r;cout<<x<<endl){\n\t\tvector<int> v1(1),v2;\n\t\t\n\t\tfor(v1.push_back(r);m--;v2.clear()){\n\t\t\tcin>>x>>y;\n\t\t\titx=upper_bound(v1.begin(),v1.end(),x);\n\t\t\tity=upper_bound(v1.begin(),v1.end(),y);\n\t\t\t\n\t\t\tif( ity-v1.begin()+1 & 1 )v2.push_back(0);\n\t\t\tv2.push_back(0);\n//\t\t\tv2.insert(v2.end(),ity-v1.begin()&1?1:2,0);\n\t\t\tfor(it=ity;it!=v1.end();++it)\n\t\t\t\tv2.push_back(*it - y);\n\t\t\t\n\t\t\tif(v1.end()-itx & 1)v2.push_back(n-y);\n\t\t\tfor(it=itx;it!=ity;++it)\n\t\t\t\tv2.push_back(*it-x+n-y);\n\t\t\t\n\t\t\tit = v1.begin();\n\t\t\tif(ity-v1.begin() & 1)++it;\n\t\t\tif(!it[1])it+=2;\n\t\t\tif(*it+n-x==v2.back())++it,v2.pop_back();\n\t\t\tfor(;it!=itx;++it)\n\t\t\t\tv2.push_back(*it+n-x);\n\t\t\t\n\t\t\tv1.swap(v2);\n\t\t}\n\t\tv1.insert( upper_bound(v1.begin(),v1.end(),p-1), 2, p-1);\n\t\tv1.insert( lower_bound(v1.begin(),v1.end(),q), q );\n\t\tv1.push_back(n);\n\t\tit = upper_bound(v1.begin(),v1.end(),p-1);\n\t\tif(it-v1.begin() & 1) --it;\n\t\tfor(x=0;*it<q;++it){\n\t\t\tm=*it,\n\t\t\tx+=*++it-m;\n\t\t}\n\t}\n}"
  },
  {
    "language": "C++",
    "code": "#include \"bits/stdc++.h\"\n#include<unordered_map>\n#include<unordered_set>\n#pragma warning(disable:4996)\nusing namespace std;\nusing ld = long double;\nconst ld eps = 1e-9;\n\n//// < \"d:\\d_download\\visual studio 2015\\projects\\programing_contest_c++\\debug\\a.txt\" > \"d:\\d_download\\visual studio 2015\\projects\\programing_contest_c++\\debug\\b.txt\"\n\n\nint main() {\n\twhile (1) {\n\t\tint N, M; cin >> N;\n\t\tif (!N)break;\n\t\tcin >> M;\n\t\tint P, Q, R; cin >> P >> Q >> R;\n\t\tvector<pair<int, int>>cards(1, make_pair(1, N));\n\t\tfor (int i = 0; i < M; ++i) {\n\t\t\tint x, y; cin >> x >> y;\n\t\t\tvector<pair<int, int>>a, b, c;\n\t\t\tint h = 0;\n\t\t\tint n = 0;\n\t\t\tfor (; n < cards.size(); ++n) {\n\t\t\t\tauto acard(cards[n]);\n\t\t\t\tint nh = h + acard.second;\n\t\t\t\tif (nh > x) {\n\t\t\t\t\ta.push_back(make_pair(acard.first, x - h));\n\t\t\t\t\tif (nh > y) {\n\t\t\t\t\t\tb.push_back(make_pair(acard.first+(x-h), y-x));\n\t\t\t\t\t\tc.push_back(make_pair(acard.first +(y-h), nh - y));\n\t\t\t\t\t}\n\t\t\t\t\telse {\n\t\t\t\t\t\tb.push_back(make_pair(acard.first + (x - h), nh - x));\n\t\t\t\t\t}\n\t\t\t\t\th = nh;\n\t\t\t\t\tn++;\n\t\t\t\t\tbreak;\n\t\t\t\t}\n\t\t\t\telse if (nh == x) {\n\t\t\t\t\ta.push_back(make_pair(acard.first, x - h));\n\t\t\t\t\th = nh;\n\t\t\t\t\tn++;\n\t\t\t\t\tbreak;\n\t\t\t\t}\n\t\t\t\telse {\n\t\t\t\t\ta.push_back(acard);\n\t\t\t\t\th = nh;\n\t\t\t\t}\n\t\t\t}\n\t\t\tfor (; n < cards.size(); ++n) {\n\t\t\t\tif (h > y)break;\n\t\t\t\tauto acard(cards[n]);\n\t\t\t\tint nh = h + acard.second;\n\t\t\t\tif (nh > y) {\n\t\t\t\t\tb.push_back(make_pair(acard.first, y-h));\n\t\t\t\t\tc.push_back(make_pair(acard.first + y-h, nh - y));\n\t\t\t\t\th = nh;\n\t\t\t\t\tn++;\n\t\t\t\t\tbreak;\n\t\t\t\t}\n\t\t\t\telse if (nh == y) {\n\t\t\t\t\tb.push_back(make_pair(acard.first, y - h));\n\t\t\t\t\th = nh;\n\t\t\t\t\tn++;\n\t\t\t\t\tbreak;\n\t\t\t\t}\n\t\t\t\telse {\n\t\t\t\t\tb.push_back(acard);\n\t\t\t\t\th = nh;\n\t\t\t\t}\n\t\t\t}\n\t\t\tfor (; n < cards.size(); ++n) {\n\t\t\t\tauto acard(cards[n]);\t\t\n\t\t\t\tc.push_back(acard);\n\t\t\t}\n\t\t\tvector<pair<int, int>>nextcards(c);\n\t\t\tnextcards.insert(nextcards.end(), b.begin(), b.end());\n\t\t\tnextcards.insert(nextcards.end(), a.begin(), a.end());\n\t\t\tfor (int i = 0; i < nextcards.size(); ++i)assert(nextcards[i].first>0);\n\t\t\tcards = nextcards;\n\t\t}\n\t\tint h = 0 ;\n\t\tint ans = 0;\n\t\tfor (int n = 0; n < cards.size(); ++n) {\n\t\t\tauto card(cards[n]);\n\t\t\tint nh = h + card.second;\n\t\t\tif (h < P&&nh >= P) {\n\t\t\t\tint pnum = card.first + P - h-1;\n\t\t\t\tif (pnum > R)ans += 0;\n\t\t\t\telse {\n\t\t\t\t\tans += min(R - pnum+1, nh - P+1);\n\t\t\t\t}\n\n\t\t\t}\n\n\t\t\tif (h >= P) {\n\t\t\t\tint pnum = card.first;\n\t\t\t\tif (pnum > R)ans += 0;\n\t\t\t\telse {\n\t\t\t\t\tans += min(R - pnum+1, card.second);\n\t\t\t\t}\n\t\t\t}\n\t\t\th = nh;\n\t\t}\n\t\th = 0;\n\t\tfor (int n = 0; n < cards.size(); ++n) {\n\t\t\tauto card(cards[n]);\n\t\t\tint nh = h + card.second;\n\t\t\tif (h <Q&&nh>Q) {\n\t\t\t\tint pnum = card.first;\n\t\t\t\tif (pnum > R)ans += 0;\n\t\t\t\telse {\n\n\t\t\t\t\tans += min(Q - pnum + 1, Q - h);\n\t\t\t\t}\n\n\t\t\t}\n\t\t\tif (nh <= Q) {\n\t\t\t\tint pnum = card.first;\n\t\t\t\tif (pnum > R)ans += 0;\n\t\t\t\telse {\n\t\t\t\t\tans += min(R - pnum + 1, card.second);\n\t\t\t\t}\n\t\t\t}\n\t\t\th = nh;\n\t\t}\n\t\tans -= R;\n\t\tcout << ans << endl;\n\t}\n\treturn 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include <iostream>\n#include <list>\n#include <vector>\n#include <set>\nusing namespace std;\ntypedef pair<int,int> pa;\n\nint X[10010],Y[10010];\nint main(){\n\tint N,M,P,Q,R,cnt,in,ou,res,le,ri;\n\tbool xfl,yfl;\n\tlist<pa> li[10010];\n\tlist<pa>::iterator tit;\n\twhile(true){\n\t\tcin>>N;\n\t\tif(N==0) break;\n\t\tcin>>M>>P>>Q>>R;\n\t\tfor(int i=1;i<=M;i++){\n\t\t\tcin>>X[i]>>Y[i];\n\t\t}\n\t\tin=0;ou=1;\n\t\tfor(int i=0;i<=M;i++){\n\t\t\tli[i].clear();\n\t\t}\n\t\tli[in].push_back(pa(1,N));\n\t\tfor(int i=1;i<=M;i++){\n\t\t\tcnt=0;xfl=yfl=false;\n\t\t\t//li[ou].clear();\n\t\t\ttit=li[ou].end();\n\t\t\tfor(auto it=li[in].begin();it!=li[in].end();it++){\n\t\t\t\tif((!xfl)&&cnt+((it->second)-(it->first)+1)>=X[i]){\n\t\t\t\t\tli[ou].insert(tit,pa(it->first,it->first+(X[i]-cnt)-1));\n\t\t\t\t\ttit=li[ou].begin();\n\t\t\t\t\tif(cnt+((it->second)-(it->first))+1>=Y[i]){\n\t\t\t\t\t\tli[ou].insert(tit,pa(it->first+(X[i]-cnt),it->first+(Y[i]-cnt)-1));\n\t\t\t\t\t\ttit=li[ou].begin();\n\t\t\t\t\t\tli[ou].insert(tit,pa(it->first+(Y[i]-cnt),it->second));\n\t\t\t\t\t\tyfl=true;\n\t\t\t\t\t}\n\t\t\t\t\telse if(cnt+((it->second)-(it->first))+1>X[i])li[ou].insert(tit,pa(it->first+(X[i]-cnt),it->second));\n\t\t\t\t\txfl=true;\n\t\t\t\t}\n\t\t\t\telse if((!yfl)&&cnt+((it->second)-(it->first))+1>=Y[i]){\n\t\t\t\t\tli[ou].insert(tit,pa(it->first,it->first+(Y[i]-cnt)-1));\n\t\t\t\t\ttit=li[ou].begin();\n\t\t\t\t\tif(cnt+((it->second)-(it->first))+1>Y[i]) li[ou].insert(tit,pa(it->first+(Y[i]-cnt),it->second));\n\t\t\t\t\tyfl=true;\n\t\t\t\t}\n\t\t\t\telse{\n\t\t\t\t\tli[ou].insert(tit,(*it));\n\t\t\t\t}\n\t\t\t\tcnt+=(it->second-it->first+1);\n\t\t\t}\n\t\t\t//swap(in,ou);\n\t\t\tin++;ou++;\n\t\t}\n\t\tres=0,cnt=0;\n\t\tfor(auto it=li[in].begin();it!=li[in].end();it++){\n\t\t\tif(R<it->first){\n\t\t\t\tcnt+=((it->second)-(it->first)+1);\n\t\t\t\tcontinue;\n\t\t\t}\n\t\t\tle=cnt+1;\n\t\t\tri=min(cnt+it->second-it->first+1,R-(it->first)+le);\n\t\t\tres+=max(0,min(ri,Q)-max(le,P)+1);\n\t\t\tcnt+=((it->second)-(it->first)+1);\n\t\t}\n\t\tcout<<res<<endl;\n\t}\n\treturn 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include <cstdio>\n#include <cstdlib>\n#include <cstring>\n#include <cmath>\n#include <climits>\n#include <iostream>\n#include <vector>\n#include <string>\n#include <sstream>\n#include <algorithm>\n#include <utility>\n#include <set>\n#include <map>\n#include <stack>\n#include <queue>\n#include <deque>\n#include <functional>\n\nusing namespace std;\n\n#define fst first\n#define scd second\n#define PB push_back\n#define MP make_pair\n#define all(a) a.begin(),a.end()\n#define rall(a) a.rbegin(),a.rend()\n#define omajinai ios::sync_with_stdio(false);cin.tie(0)\n#define rep(i,x) for(int i=0;i<(int)(x);++i)\n#define rep1(i,x) for(int i=1;i<=(int)(x);++i)\n\nusing ll=long long;\nusing ld=long double;\nusing vi=vector<int>;\nusing vvi=vector<vi>;\nusing pii=pair<int, int>;\nusing vpii=vector<pii>;\n\ntemplate<class T,class U>ostream&operator<<(ostream&os,const pair<T,U>p){os<<\"(\"<<p.fst<<\", \"<<p.scd<<\")\";return os;}\ntemplate<class T>ostream&operator<<(ostream&os,const vector<T>v){rep(i,v.size()){if(i)os<<\", \";os<<v[i];}return os;}\ntemplate<typename T>T&max(T&a,T&b){if(a>=b)return a;return b;}\ntemplate<typename T>T&min(T&a,T&b){if(a < b)return a;return b;}\ntemplate<typename T>bool chmax(T&a,T b){if(a < b){a=b;return true;}return false;}\ntemplate<typename T>bool chmin(T&a,T b){if(a > b){a=b;return true;}return false;}\n\nconstexpr int inf = 1e9;\nconstexpr ll linf = 3e18;\nconstexpr double eps = 1e-9;\n\nint n, m, p, q, r;\n\nint calc(pii seg, int n) // n=seg.fst????????????????????????\n{\n    int len = seg.scd - seg.fst + 1; // seg?????????\n\n    if (n < p && p <= n + len - 1) {\n        int a = (n + len - 1) - p;\n\n        return calc(pii(seg.scd - a, seg.scd), p);\n    }\n\n    if (p <= n && n + len - 1 <= q) {\n        return max(min(r - seg.fst + 1, len), 0);\n    }\n\n    if (n <= q && q < n + len - 1) {\n        int a = q - n;\n\n        return calc(pii(seg.fst, seg.fst + a), n);\n    }\n\n    return 0;\n}\n\nint main()\n{\n    cin >> n >> m >> p >> q >> r;\n\n    deque<pii> dat;\n\n    dat.push_back(pii(1, n));\n\n    rep(_, m) {\n        int x, y; cin >> x >> y;\n\n        int sum = 0;\n\n        vpii Top, Mid, Bottom;\n\n        // Top?????????\n        while (true) {\n            pii a = dat.front();\n\n            int v = a.scd - a.fst + 1;\n\n            if (sum + v >= x) {\n                int dif = x - sum-1;\n\n                sum += dif + 1;\n\n                Top.push_back(pii(a.fst, a.fst + dif));\n\n                dat.pop_front();\n\n                if (a.fst + dif + 1 <= a.scd) dat.push_front(pii(a.fst + dif + 1, a.scd));\n\n                break;\n            } else {\n                Top.PB(a);\n                sum += v;\n            }\n\n            dat.pop_front();\n        }\n\n        // Mid?????????\n        while (true) {\n            pii a = dat.front();\n\n            int v = a.scd - a.fst + 1;\n\n            if (sum + v >= y) {\n                int dif = y - sum-1;\n\n                sum += dif + 1;\n\n                Mid.push_back(pii(a.fst, a.fst + dif));\n\n                dat.pop_front();\n\n                if (a.fst + dif + 1 <= a.scd) dat.push_front(pii(a.fst + dif + 1, a.scd));\n\n                break;\n            } else {\n                Mid.PB(a);\n                sum += v;\n            }\n            dat.pop_front();\n        }\n\n        // Bottom?????????\n        while (true) {\n            pii a = dat.front();\n\n            int v = a.scd - a.fst + 1;\n\n            if (sum + v == n) {\n                sum += v;\n\n                Bottom.push_back(pii(a.fst, a.scd));\n\n                dat.pop_front();\n\n                break;\n            } else {\n                Bottom.PB(a);\n                sum += v;\n            }\n\n            dat.pop_front();\n        }\n\n        rep(i, Bottom.size()) dat.push_back(Bottom[i]);\n        rep(i, Mid.size()) dat.push_back(Mid[i]);\n        rep(i, Top.size()) dat.push_back(Top[i]);\n    }\n\n    int sum = 1;\n    int ans = 0;\n\n    for (pii a : dat) {\n        ans += calc(a, sum);\n        sum += a.scd - a.fst + 1;\n    }\n\n    cout << ans << endl;\n}"
  },
  {
    "language": "C++",
    "code": "#include<iostream>\nusing namespace std;\nint cards,n,i,p,q,r,x[5000],y[5000],counter;\n  int numberStart[10001];\n  int numberFast[10001];\n  int numberEnd[10001];\n  int searchB[10001];\nint numberLong(int value){\n\treturn numberEnd[value]-numberStart[value]+1;\n}\n\n\nint searchD(int seed){\n\t\tint l=0;\n  for (int a=1;a<=counter+1;a++){\n\tif(seed>l+numberLong(searchB[a])){\n\tl+=numberLong(searchB[a]);\n\t}\n\telse{\n\t return numberFast[searchB[a]];\n\t}\n  }\n return -100;\n\t\n}\nint searchNumber(int value){\n\tint l=0;\n  for (int a=1;a<=counter+1;a++){\n\tif(value>l+numberLong(searchB[a])){\n\tl+=numberLong(searchB[a]);\n\t}\n\telse{\n\t return numberStart[searchB[a]]+value-l-1;\n\t}\n  }\n return -100;\n}\n\nvoid cut(int g){\n\tif(searchD(g)==searchD(g+1)){\n  //カットする場所が入ってる数列を求める\n  int seachX=searchB[searchD(g)];\n  int seachXX=searchNumber(g);\n//数列ができる範囲の後ろの番号FASTを変える\n     for(int j=1;j<=counter;j++){\n      if (numberFast[j]>=numberFast[seachX]+1){\n      numberFast[j]++;\n     }\n    }\n\n  //の数列の後ろに新しい数列を作る\n counter++;\n  numberFast[counter]=numberFast[seachX]+1;\n  numberStart[counter] =searchNumber(g)+1;\n  numberEnd[counter]=numberEnd[seachX];\n  //できた数列の前の数列の最後を調整する\n  numberEnd[seachX]=searchNumber(g);\n \n\n  \n  for ( int a=1;a<=counter+1;a++){\n\t  searchB[numberFast[a]]=a;\n    }\n    }\n\n}\nvoid shuffle(int x,int y){\n\t\n\tint StartHead[10001];\n\tint  numberFastNew[10001];\n\t\n\tint longs=1;\n\tfor (int i=1;i<=counter;i++){\n\t\tStartHead[searchB[i]]=longs;\n\t\tlongs+=numberLong(searchB[i]);\n\t}\n\tint newCounter[3];\n\tfor(int i=0;i<3;i++){\n\t\tnewCounter[i]=0;\n\t}\n\tfor(int j=1;j<=counter;j++){\n\t\tif (StartHead[j]>y){\n\t\t\tnewCounter[0]++;\n\t\tnumberFastNew[j]=0;\n\t\t}\n\t\tif (StartHead[j]>x && StartHead[j]+numberLong(j)-1<=y){\n\t\t\tnewCounter[1]++;\n\t\tnumberFastNew[j]=1;\n\t\t}\n\t\tif (StartHead[j]+numberLong(j)-1<=x){\n\t\t\tnewCounter[2]++;\n\t\tnumberFastNew[j]=2;\n\t\t}\n\t}\n\t\n\tfor(int j=1;j<=counter;j++){\n\t\tswitch(numberFastNew[j]){\n\t\t\tcase 0:\n\t\t\t\tnumberFast[j]+=-newCounter[1]-newCounter[2];\n\t\t\t\tbreak;\n\t\t\tcase 1:\n\t\t\t\tnumberFast[j]+=newCounter[0]-newCounter[2];\n\t\t\t\tbreak;\n\t\t\tcase 2:\n\t\t\t\tnumberFast[j]+=newCounter[1]+newCounter[0];\n\t\t\t\tbreak;\n\t\t}\n\n\t}\n\t  for ( int a=1;a<=counter+1;a++){\n\t  searchB[numberFast[a]]=a;\n    }\n\n}\n\n\nint main(void)\n{\n\twhile(true){\n\tcards=0;\n\tn=0;\n\tcounter=0;\n\tfor (int i=0;i<10001;i++){\n   numberStart[i]=0;\n   numberFast[i]=0;\n   numberEnd[i]=0;\n   searchB[i]=0;\n\t}\n\tint points=0;\n  counter=1;\n  cin >> cards;\n  if (cards==0){\n\t  break;\n  }\n  numberStart[1]=1;\n  numberEnd[1]=cards;\n  numberFast[1]=1;\n  searchB[1]=1;\n  cin >> n;\n  cin >> p  >> q  >> r ;\n  for (i=1;i<=n;i++){\n    cin >> x[i] >> y[i];\n  }\n  for (i=1;i<=n;i++){\n     cut(x[i]);\n\t \n      cut(y[i]);\n\t  \n     shuffle(x[i],y[i]);\n  }\n\n  for(int j=p;j<=q;j++){\n\t  if(searchNumber(j)<=r){\n\t\t  points++;\n\t  }\n  }\n  cout << points << endl;\n\t}\n}"
  },
  {
    "language": "C++",
    "code": "#include <stdio.h>\n#include <iostream>\n#include <algorithm>\n#include <vector>\n#include <queue>\n#include <list>\n#include <map>\n#include <string>\n#include <functional>\n#include <math.h>\n#include <utility>\n#define INF 100000000\nusing namespace std;\ntypedef pair<int,int> P;\nint n,m,p,q,r,ans;\nvector<P> sheaf;\nvoid Cut(int s,int l,int k){\n\tvector<P> sheaf2;\n\tint len;\n\tint divk=0;\n\tfor(len=0;len<k;){\n\t\tP tmp=sheaf[divk++];\n\t\tlen+=tmp.second-tmp.first+1;\n\t}\n\tdivk--;\n\tint nk=sheaf[divk].first+k-(len-(sheaf[divk].second-sheaf[divk].first+1))-1;\n\tsheaf2.push_back(make_pair(nk,sheaf[divk].second));\n\tif(sheaf.begin()+divk!=sheaf.end())sheaf2.insert(sheaf2.end(),sheaf.begin()+divk+1,sheaf.end());\n\tint divs=0;\n\tfor(len=0;len<s;){\n\t\tP tmp=sheaf[divs++];\n\t\tlen+=tmp.second-tmp.first+1;\n\t}\n\tdivs--;\n\tint ns=sheaf[divs].first+s-(len-(sheaf[divs].second-sheaf[divs].first+1))-1;\n\tif(divk-divs!=0)sheaf2.push_back(make_pair(ns,sheaf[divs].second));\n\telse sheaf2.push_back(make_pair(ns,nk-1));\n\tif(divk-divs>=2)sheaf2.insert(sheaf2.end(),sheaf.begin()+divs+1,sheaf.begin()+divk);\n\tif(sheaf[divk].first!=nk&&divk-divs!=0)sheaf2.push_back(make_pair(sheaf[divk].first,nk-1));\n\n\tif(sheaf[divs].first!=ns)sheaf2.insert(sheaf2.begin(),make_pair(sheaf[divs].first,ns-1));\n\tif(divs!=0)sheaf2.insert(sheaf2.begin(),sheaf.begin(),sheaf.begin()+divs);\n\tsheaf=sheaf2;\n\treturn;\n}\nint main()\n{\n\twhile(cin>>n&&n){\n\t\tcin>>m>>p>>q>>r;\n\t\tans=0;\n\t\tsheaf.clear();\n\t\tsheaf.push_back(make_pair(1,n));\n\t\twhile(m--){\n\t\t\tint x,y;cin>>x>>y;\n\t\t\tCut(1,n,y+1);\n\t\t\tCut(n-y+1,n,n+x-y+1);\n\t\t}\n\t\tCut(1,n,q+1);\n\t\tCut(1,n,n+p-q);\n\t\tint len=0;\n\t\tfor(int i=0;i<(int)sheaf.size()&&len!=q-p+1;i++){\n\t\t\tP tmp=sheaf[i];\n\t\t\tlen+=tmp.second-tmp.first+1;\n\t\t\tif(r<tmp.first)continue;\n\t\t\tans+=min(r,tmp.second)-tmp.first+1;\n\t\t}\n\t\tcout<<ans<<endl;\n\t}\n}"
  },
  {
    "language": "C++",
    "code": "#include<iostream>\n#include<queue>\n#include<map>\n#include<algorithm>\nusing namespace std;\n#define fr first\n#define sc second\ntypedef pair< int , int > P;\nint n, m;\ndeque< P > d;\nint _sum(P p){\n  return p.sc - p.fr + 1;\n}\nint query(int& p,int& q,int& r){\n  int ret = 0, ans = 0;\n  while(_sum(d.front()) < p){\n    ret += _sum(d.front());\n    d.pop_front();\n  }\n  if(ret != p - 1) d.front().fr = d.front().fr + p - ret;\n  ret = p;\n  while(ret + _sum(d.front()) <= q){\n    if(d.front().sc <= r) ans += _sum(d.front());\n    else if(d.front().fr <= r) ans += _sum(P(d.front().fr,r));\n    ret += _sum(d.front());\n    d.pop_front();\n  }\n  if(ret != q){\n    P p = P(d.front().fr,d.front().fr + q - ret - 1);\n    if(p.sc <= r) ans += _sum(P(p.fr,p.sc));\n    else if(p.fr <= r) ans += _sum(P(p.fr,r));\n  }\n  return ans;\n}\nvoid shuffle(int* xy){\n  deque< P > tmp[2];\n  int ret = 0;\n  for(int i = 0 ; i < 2 ; i++ ){\n    while( ret + _sum(d.front()) <= xy[i]){\n      tmp[i].push_back(d.front());\n      ret += _sum(d.front());\n      d.pop_front();\n    }\n    if(ret != xy[i]){\n      tmp[i].push_back(P(d.front().fr,d.front().fr + xy[i] - ret - 1));\n      d.front().fr = d.front().fr + xy[i] - ret;\n      ret = xy[i];\n    }\n  }\n  d.insert(d.end(),tmp[1].begin(),tmp[1].end());\n  d.insert(d.end(),tmp[0].begin(),tmp[0].end()); \n}\nint main(){\n  while(cin >> n >> m , n){\n    d.push_back( P( 1, n));\n    int p, q, r;\n    cin >> p >> q >> r;\n    while(m--){\n      int xy[2];\n      cin >> xy[0] >> xy[1];\n      shuffle(xy);\n    }\n    cout << query(--p, q, r) << endl;\n    d.clear();\n  }\n}"
  },
  {
    "language": "C++",
    "code": "#include<bits/stdc++.h>\nusing namespace std;\n#define h first\n#define w second\nvector<pair<bool,pair<int,int> > >v;\nint n,m,p,q,r,i;\nvoid Vp(bool a,int b,int c){v.push_back(make_pair(a,make_pair(b,c)));}\nint main(){\n\twhile(cin>>n&&n){\n\tcin>>m>>p>>q>>r;v.clear();\n\tVp(1,1,r);Vp(0,r+1,n);\n\twhile(m--){\n\t\tint x,y;scanf(\"%d%d\",&x,&y);\n\t\tfor(i=0;i<v.size();i++){\n\t\t\tint a=v[i].w.h,b=v[i].w.w;bool c=v[i].h;\n\t\t\tif(a<=x&&x<b){Vp(c,x+1,b);b=x;}\n\t\t\tif(a<=y&&y<b){Vp(c,y+1,b);b=y;}\n\t\t\tif(0<a&&b<=x)a+=n-x,b+=n-x;\n\t\t\telse if(x<a&&b<=y)a+=n-x-y,b+=n-x-y;\n\t\t\telse if(y<a&&b<=n)a-=y,b-=y;\n\t\t\tv[i].w.h=a,v[i].w.w=b;\n\t\t}\n\t}n=0;\n\tfor(i=0;i<v.size();i++)if(v[i].h)n+=max(0,1+min(v[i].w.w,q)-max(v[i].w.h,p));\n\tcout<<n<<endl;\n\t}\n\treturn 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include <iostream>\n#include <fstream>\n#include <sstream>\n#include <iomanip>\n#include <complex>\n#include <string>\n#include <vector>\n#include <list>\n#include <deque>\n#include <stack>\n#include <queue>\n#include <set>\n#include <map>\n#include <bitset>\n#include <functional>\n#include <utility>\n#include <algorithm>\n#include <numeric>\n#include <typeinfo>\n#include <cstdio>\n#include <cstdlib>\n#include <cstring>\n#include <cmath>\n#include <climits>\n#include <ctime>\n\nusing namespace std;\n\n#define dump(n) cout<<\"# \"<<#n<<\"=\"<<(n)<<endl\n#define debug(n) cout<<__FILE__<<\",\"<<__LINE__<<\": #\"<<#n<<\"=\"<<(n)<<endl\n#define repi(i,a,b) for(int i=int(a);i<int(b);i++)\n#define rep(i,n) repi(i,0,n)\n#define iter(c) __typeof((c).begin())\n#define foreach(i,c) for(iter(c) i=(c).begin();i!=(c).end();i++)\n#define allof(c) (c).begin(),(c).end()\n#define mp make_pair\n\ntypedef unsigned int uint;\ntypedef long long ll;\ntypedef unsigned long long ull;\ntypedef vector<int> vi;\ntypedef vector<vi> vvi;\ntypedef vector<string> vs;\ntypedef pair<int,int> pii;\n\ntypedef list<pii>::iterator lpiter;\n\npair<lpiter,lpiter> split(list<pii>& cards,int op1,int op2)\n{\n\titer(cards) i1=cards.begin();\n\titer(cards) i2=i1;\n\tint sum=0;\n\tfor(;;){\n\t\tint num=i2->second-i2->first+1;\n\t\tif(sum+num==op1){\n\t\t\ti2++;\n\t\t\tsum+=num;\n\t\t\tbreak;\n\t\t}\n\t\telse if(sum+num>op1){\n\t\t\tint over=sum+num-op1;\n\t\t\tpii temp(i2->second-over+1,i2->second);\n\t\t\ti2->second-=over;\n\t\t\ti2++;\n\t\t\ti2=cards.insert(i2,temp);\n\t\t\tsum=op1;\n\t\t\tbreak;\n\t\t}\n\t\telse{\n\t\t\tsum+=num;\n\t\t\ti2++;\n\t\t}\n\t}\n\titer(cards) i3=i2;\n\tfor(;;){\n\t\tint num=i3->second-i3->first+1;\n\t\tif(sum+num==op2){\n\t\t\ti3++;\n\t\t\tsum+=num;\n\t\t\tbreak;\n\t\t}\n\t\telse if(sum+num>op2){\n\t\t\tint over=sum+num-op2;\n\t\t\tpii temp(i3->second-over+1,i3->second);\n\t\t\ti3->second-=over;\n\t\t\ti3++;\n\t\t\ti3=cards.insert(i3,temp);\n\t\t\tsum=op2;\n\t\t\tbreak;\n\t\t}\n\t\telse{\n\t\t\tsum+=num;\n\t\t\ti3++;\n\t\t}\n\t}\n\treturn mp(i2,i3);\n}\n\nint main()\n{\n\tfor(int n,m,p,q,r;cin>>n>>m>>p>>q>>r,n;){\n\t\tvector<pii> op(m);\n\t\trep(i,m)\n\t\t\tcin>>op[i].first>>op[i].second;\n\t\t\n\t\tlist<pii> cards;\n\t\tcards.push_back(mp(1,n));\n\t\trep(i,m){\n\t\t\tpair<lpiter,lpiter> temp=split(cards,op[i].first,op[i].second);\n\t\t\tlpiter i2=temp.first,i3=temp.second;\n\t\t\t\n\t\t\tcards.splice(cards.begin(),cards,i2,i3);\n\t\t\tcards.splice(cards.begin(),cards,i3,cards.end());\n\t\t}\n\t\t\n\t\tpair<lpiter,lpiter> temp=split(cards,p-1,q);\n\t\tlpiter i2=temp.first,i3=temp.second;\n\t\tint res=0;\n\t\tfor(lpiter i=i2;i!=i3;i++){\n\t\t\tif(i->second<=r)\n\t\t\t\tres+=i->second-i->first+1;\n\t\t\telse if(i->first<=r)\n\t\t\t\tres+=r-i->first+1;\n\t\t}\n\t\tcout<<res<<endl;\n\t}\n\t\n\treturn 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include <iostream>\n#include <algorithm>\n#include <vector>\n\nusing namespace std;\ntypedef pair<int,int> pii;\n\nint N;\nint M;\nint P,Q,R;\n\nvoid decidePlace(int &sumX,vector<pii>&deck,int &xPos,int x){\n    for(int j=0;j<deck.size();j++){\n        if(sumX+deck[j].second-deck[j].first+1>=x){\n            xPos=j;\n            break;\n        }\n        sumX+=deck[j].second-deck[j].first+1;\n    }\n}\nvoid divideBlock(vector<pii> &deck,int &xPos,int &sumX,int x,bool isX){\n    int minu=1;\n    if(isX)minu++;\n    pii p1=pii(deck[xPos].first,deck[xPos].first+(x-sumX-minu));\n    pii p2=pii(p1.second+1,deck[xPos].second);\n    deck.erase(deck.begin()+xPos);\n    if(p2.first<=p2.second)deck.insert(deck.begin()+xPos,p2);\n    if(p1.first<=p1.second)deck.insert(deck.begin()+xPos,p1);\n}\n\nint main(){\n    while(cin>>N&&N){\n        int res=0;\n        cin>>M>>P>>Q>>R;\n        vector<pii> deck;\n        deck.push_back(pii(1,N));\n        int x,y;\n        for(int i=0;i<M;i++){\n            cin>>x>>y;\n            x++;\n            // xÌÓÆyÌÓðÁèµAVbt\n            int sumX=0;\n            int sumY=0;\n            int xPos,yPos;\n            // xÚðÁè\n            decidePlace(sumX,deck,xPos,x);\n            // yÚðÁè\n            decidePlace(sumY,deck,yPos,y);\n            // x+1Ú©çy+1ÚÜÅÌÓðØèæèAVbt\n            // ¯¶æÔÉ¶Ý\n            if(xPos==yPos){\n                // »ÝÌæÔðRª\n                pii p1=pii(deck[xPos].first,deck[xPos].first+(x-sumX-2));\n                pii p2=pii(p1.second+1,deck[yPos].first+(y-sumY-1));\n                pii p3=pii(p2.second+1,deck[xPos].second);\n                deck.erase(deck.begin()+xPos);\n                if(p3.first<=p3.second)deck.insert(deck.begin()+xPos,p3);\n                if(p2.first<=p2.second)deck.insert(deck.begin()+xPos,p2);\n                if(p1.first<=p1.second)deck.insert(deck.begin()+xPos,p1);\n            }\n            // ÊÌæÔÉ¶Ý·éêÍA»ê¼êÌæÔ²ÆÉªðs¤\n            else{\n                divideBlock(deck,yPos,sumY,y,false);\n                divideBlock(deck,xPos,sumX,x,true);\n            }\n            // à¤êxxÆyÌêðTõµA©Â¯½çVbt\n            sumX=sumY=0;\n            decidePlace(sumX,deck,xPos,x);\n            decidePlace(sumY,deck,yPos,y);\n            // xpos©çyposÜÅÌÓð²«oµÄAVbt\n            vector<pii> cutPlace;\n            vector<pii> prv;\n            vector<pii> nxt;\n            for(int i=xPos;i<=yPos;i++)cutPlace.push_back(deck[i]);\n            for(int i=0;i<xPos;i++)prv.push_back(deck[i]);\n            for(int i=yPos+1;i<deck.size();i++)nxt.push_back(deck[i]);\n            deck.clear();\n            for(int i=0;i<nxt.size();i++)deck.push_back(nxt[i]);\n            for(int i=0;i<cutPlace.size();i++)deck.push_back(cutPlace[i]);\n            for(int i=0;i<prv.size();i++)deck.push_back(prv[i]);\n        }\n        // VbtI¹ãApÆqÌl©çAðð½·àÌðTõ\n        int sum=0;\n        bool isApP=false;\n        for(int i=0;i<deck.size();i++){\n            int cnt=deck[i].second-deck[i].first+1;\n            sum+=cnt;\n            if(sum<P)continue;\n            // ¡ñÌæÔÉñÂÆàÜÜêéê\n            if(sum-cnt<P&&sum-cnt<Q&&sum>=P&&sum>=Q){\n                int pPos=P-(sum-cnt)-1;\n                int pNum=pPos+deck[i].first;\n                int qPos=Q-(sum-cnt)-1;\n                int qNum=qPos+deck[i].first;\n                // pÌl©çrÈºÌàÌð¦ã°\n                if(pNum<=R)res+=max(0,min(-qNum+R+1,qNum-pNum+1));\n                break;\n            }\n            // ¡ñÌæÔÅßÄpª»ê½ê\n            else if(!isApP&&sum>=P){\n                isApP=true;\n                int pPos=P-(sum-cnt)-1;\n                int pNum=pPos+deck[i].first;\n                // pÌl©çrÈºÌàÌð¦ã°\n                if(pNum<=R)res+=max(0,min(-deck[i].first+R+1,deck[i].second-pNum+1));\n            }\n            // pªo»ÏÝÌê\n            else if(isApP){\n                // ¡ñQª»ê½çðµÄbreak\n                if(sum>=Q){\n                    int qPos=Q-(sum-cnt)-1;\n                    int qNum=qPos+deck[i].first;\n                    if(deck[i].first<=R)res+=min(qNum-deck[i].first+1,(R-deck[i].first+1));\n                    break;\n                }\n                // æÔÌl·×ÄÉÎµÄvZ\n                else{\n                    if(deck[i].first<=R)res+=max(0,min(-deck[i].first+R+1,deck[i].second-deck[i].first+1));\n                }\n            }\n        }\n        cout<<res<<endl;\n    }\n    return 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include <iostream>\n#include <algorithm>\n#include <vector>\nusing namespace std;\nint main(){\n\tint n,m,p,q,r,x,y;\n\tvector<int>::iterator u,v,z;\n\tfor(;cin>>n>>m>>p>>q>>r;cout<<x<<endl){\n\t\tvector<int> s,t;\n\t\ts.push_back(0);\n\t\tfor(s.push_back(r);m--;t.clear()){\n\t\t\tcin>>x>>y;\n\t\t\tu=upper_bound(s.begin(),s.end(),x);\n\t\t\tv=upper_bound(s.begin(),s.end(),y);\n\t\t\t\n\t\t\tif( v-s.begin()+1 & 1 )t.push_back(0);\n\t\t\tt.push_back(0);\n\t\t\tfor(z=v;z<s.end();++z)\n\t\t\t\tt.push_back(*z - y);\n\t\t\t\n\t\t\tif(s.end()-u & 1)t.push_back(n-y);\n\t\t\tfor(z=u;z<v;++z)\n\t\t\t\tt.push_back(*z-x+n-y);\n\t\t\t\n\t\t\tz = s.begin();\n\t\t\tif(v-s.begin() & 1)++z;\n\t\t\tif(!z[1])z+=2;\n\t\t\tif(*z+n-x==t.back()){++z;t.pop_back();}\n\t\t\tfor(;z<u;++z)\n\t\t\t\tt.push_back(*z+n-x);\n\t\t\t\n\t\t\ts.swap(t);\n\t\t}\n\t\ts.insert( upper_bound(s.begin(),s.end(),p-1), 2, p-1);\n\t\ts.insert( lower_bound(s.begin(),s.end(),q), q );\n\t\ts.push_back(n);\n\t\tz = upper_bound(s.begin(),s.end(),p-1);\n\t\tif(z-s.begin() & 1) --z;\n\t\tfor(x=0;*z<q;++z)\n\t\t\tm=*z++,x+=*z-m;\n\t}\n}"
  },
  {
    "language": "C++",
    "code": "#include<iostream>\n#include<sstream>\n#include<cstdio>\n#include<cstdlib>\n#include<vector>\n#include<string>\n#include<stack>\n#include<queue>\n#include<deque>\n#include<set>\n#include<map>\n#include<algorithm>\n#include<functional>\n#include<utility>\n#include<cmath>\n#include<ctime>\n#include<complex>\n\nusing namespace std;\n\n#define REP(i,s,e) for(int i=int(s);i<=int(e);i++)\n#define rep(i,n) for(int i=0;i<int(n);i++)\n\nvector<int>u1,v1,u2,v2;\nvoid f(int x,int y,vector<int>& u1,vector<int>& v1,vector<int>& u2,vector<int>& v2){\n\tint c=0; int a,b,c1,c2;\n\trep(i,u1.size()){\n\t\tc+=v1[i]-u1[i]+1;\n\t\tif(c>=x){\n\t\t\ta=i; c1=c; break;\n\t\t}\n\t}\n\tc=0;\n\trep(i,u1.size()){\n\t\tc+=v1[i]-u1[i]+1;\n\t\tif(c>=y){\n\t\t\tb=i; c2=c; break;\n\t\t}\n\t}\n\n\n\tif(c2!=y){\n\t\tu2.push_back(v1[b]-(c2-y)+1);\n\t\tv2.push_back(v1[b]);\n\t\tREP(i,b+1,u1.size()-1){\n\t\t\tu2.push_back(u1[i]);\n\t\t\tv2.push_back(v1[i]);\n\t\t}\n\t}\n\telse{\n\t\tREP(i,b+1,u1.size()-1){\n\t\t\tu2.push_back(u1[i]);\n\t\t\tv2.push_back(v1[i]);\n\t\t}\n\t}\n\n\n\tif(c1!=x){\n\t\tu2.push_back(v1[a]-(c1-x)+1);\n\t\tv2.push_back(v1[a]);\n\t\tif(c2!=y){\n\t\tREP(i,a+1,b-1){\n\t\t\tu2.push_back(u1[i]);\n\t\t\tv2.push_back(v1[i]);\n\t\t}\n\t\tu2.push_back(u1[b]);\n\t\tv2.push_back(v1[b]-(c2-y));\n\t\t}\n\t\telse{\n\t\tREP(i,a+1,b){\n\t\t\tu2.push_back(u1[i]);\n\t\t\tv2.push_back(v1[i]);\n\t\t}\n\t\t}\n\t}\n\telse{\n\t\tif(c2!=y){\n\t\tREP(i,a+1,b-1){\n\t\t\tu2.push_back(u1[i]);\n\t\t\tv2.push_back(v1[i]);\n\t\t}\n\t\tu2.push_back(u1[b]);\n\t\tv2.push_back(v1[b]-(c2-y));\n\t\t}\n\t\telse{\n\t\tREP(i,a+1,b){\n\t\t\tu2.push_back(u1[i]);\n\t\t\tv2.push_back(v1[i]);\n\t\t}\n\t\t}\n\t}\n\n\n\tif(c1!=x){\n\t\tREP(i,0,a-1){\n\t\t\tu2.push_back(u1[i]);\n\t\t\tv2.push_back(v1[i]);\n\t\t}\n\t\tu2.push_back(u1[a]);\n\t\tv2.push_back(v1[a]-(c1-x));\n\t}\n\telse{\n\t\tREP(i,0,a){\n\t\t\tu2.push_back(u1[i]);\n\t\t\tv2.push_back(v1[i]);\n\t\t}\n\t}\n}\n\nint main(){\n\n\tint m,n,p,q,r,x,y;\n\n\twhile(1){\n\n\t\tcin >> n;\n\t\tif(n==0) break;\n\t\tcin >> m >> p >> q >> r;\n\n\n\t\tREP(i,1,m){\n\n\t\t\tcin >> x >> y;\n\n\t\t\tif(i==1){\n\t\t\t\tu1.push_back(y+1); v1.push_back(n);\n\t\t\t\tu1.push_back(x+1); v1.push_back(y);\n\t\t\t\tu1.push_back(1); v1.push_back(x);\n\t\t\t}\n\t\t\telse if(i%2==0){ u2.clear(); v2.clear(); f(x,y,u1,v1,u2,v2);}\n\t\t\telse if(i%2==1){ u1.clear(); v1.clear(); f(x,y,u2,v2,u1,v1);}\n\t\t}\n\n\n\t\tint s=0; int c=0; int a,b,c1,c2;\n\t\tif(m%2==0){\n\n\t\t\trep(i,u2.size()){\n\t\t\t\tc+=v2[i]-u2[i]+1;\n\t\t\t\tif(c>=p){\n\t\t\t\t\ta=i; c1=c; break;\n\t\t\t\t}\n\t\t\t}\n\t\t\tc=0;\n\t\t\trep(i,u2.size()){\n\t\t\t\tc+=v2[i]-u2[i]+1;\n\t\t\t\tif(c>=q){\n\t\t\t\t\tb=i; c2=c; break;\n\t\t\t\t}\n\t\t\t}\n\n\t\t\tREP(i,v2[a]-(c1-p),v2[a])\n\t\t\tif(i<=r) s++;\n\t\t\tREP(i,a+1,b-1){\n\t\t\t\tREP(j,u2[i],v2[i]){\n\t\t\t\tif(j<=r) s++;\n\t\t\t\t}\n\t\t\t}\n\t\t\tREP(i,u2[b],v2[b]-(c2-q))\n\t\t\tif(i<=r) s++;\n\n\t\t\tcout << s << endl;\n\n\n\t\t}\n\t\telse{\n\n\t\t\trep(i,u1.size()){\n\t\t\t\tc+=v1[i]-u1[i]+1;\n\t\t\t\tif(c>=p){\n\t\t\t\t\ta=i; c1=c; break;\n\t\t\t\t}\n\t\t\t}\n\t\t\tc=0;\n\t\t\trep(i,u1.size()){\n\t\t\t\tc+=v1[i]-u1[i]+1;\n\t\t\t\tif(c>=q){\n\t\t\t\t\tb=i; c2=c; break;\n\t\t\t\t}\n\t\t\t}\n\n\t\t\tREP(i,v1[a]-(c1-p),v1[a])\n\t\t\tif(i<=r) s++;\n\t\t\tREP(i,a+1,b-1){\n\t\t\t\tREP(j,u1[i],v1[i]){\n\t\t\t\tif(j<=r) s++;\n\t\t\t\t}\n\t\t\t}\n\t\t\tREP(i,u1[b],v1[b]-(c2-q))\n\t\t\tif(i<=r) s++;\n\n\t\t\tcout << s << endl;\n\n\n\t\t}\n\n\t\tu1.clear(); v1.clear(); u2.clear(); v2.clear();\n\n\t}\n\n\treturn 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include<cstdio>\n#include<cstdlib>\n#include<cstring>\n#include<cmath>\n#include<iostream>\n#include<sstream>\n#include<utility>\n#include<map>\n#include<vector>\n#include<queue>\n#include<algorithm>\n#include<set>\n#include<stack>\nusing namespace std;\ntypedef long long ll;\n//typedef pair<int,int>P;\n#define INF 1000000009\n\ntypedef struct D{int s,e;}D;//(s,e]\n\nint N,M,P,Q,R,x,y,res;\n\nvoid Smov(stack<D> &s,stack<D> &d,int len)\n{\n\tfor(int c=0;c<len&&!s.empty();)\n\t{\n\t\tD now=s.top();s.pop();\n\t\tif(c+(now.e-now.s)>len)\n\t\t{\n\t\t\tD rev={now.s+(len-c),now.e};\n\t\t\tnow.e=now.s+(len-c);\n\t\t\ts.push(rev);\n\t\t}\n\t\tc+=(now.e-now.s);\n\t\td.push(now);\n\t}\n}\n\n\nint main()\n{\n\tfor(;scanf(\"%d\",&N),N;)\n\t{\n\t\tstack<D>q,A,B,C;\n\t\tD tmp={1,N+1};\n\t\tq.push(tmp);\n\t\tscanf(\"%d%d%d%d\",&M,&P,&Q,&R);\n\t\tfor(int i=0;i<M;i++)\n\t\t{\n\t\t\tscanf(\"%d%d\",&x,&y);\n\t\t\tSmov(q,A,x);\n\t\t\tSmov(q,B,y-x);\n\t\t\tSmov(q,C,INF);\n\t\t\tSmov(A,q,INF);\n\t\t\tSmov(B,q,INF);\n\t\t\tSmov(C,q,INF);\n\t\t}\n\t\tP--;Q--;res=0;\n\t\tfor(int i=0;i<=Q;)\n\t\t{\n\t\t\tD tmp=q.top();q.pop();\n\t\t\tint len=tmp.e-tmp.s;\n\t\t\tif(i+len<P||i>Q)\n\t\t\t{\n\t\t\t}\n\t\t\telse\n\t\t\t{\n\t\t\t\tint s=i>P?tmp.s:tmp.s+(P-i);\n\t\t\t\tint e=i+len<Q?tmp.e-1:tmp.s+(Q-i);\n\t\t\t\tif(s<=R)\n\t\t\t\t\tres+=min(R,e)-s+1;\n\t\t\t}\n\t\t\ti+=len;\n\t\t\t\n\t\t}\n\t\tprintf(\"%d\\n\",res);\n\t}\n}"
  },
  {
    "language": "C++",
    "code": "#include <iostream>\n#include <algorithm>\n#include <vector>\nusing namespace std;\nint main(){\n\tint n,m,p,q,r,x,y,t;\n\tvector<int>::iterator itx,ity,it;\n\tfor(;cin>>n>>m>>p>>q>>r;cout<<x<<endl){\n\t\tvector<int> v1,v2;\n\t\tv1.push_back(0);\n\t\tv1.push_back(r);\n\t\t\n\t\tfor(;m--;v2.clear()){\n\t\t\tcin>>x>>y;\n\t\t\titx=upper_bound(v1.begin(),v1.end(),x);\n\t\t\tity=upper_bound(v1.begin(),v1.end(),y);\n\t\t\t\n\t\t\tif( ity-v1.begin()+1 & 1 )v2.push_back(0);\n\t\t\tv2.push_back(0);\n\t\t\tfor(it=ity;it!=v1.end();++it)\n\t\t\t\tv2.push_back(*it - y);\n\t\t\t\n\t\t\tif(v1.end()-itx & 1)v2.push_back(n-y);\n\t\t\tfor(it=itx;it!=ity;++it)\n\t\t\t\tv2.push_back(*it-x+n-y);\n\t\t\t\n\t\t\tit = v1.begin();\n\t\t\tif(ity-v1.begin() & 1)++it;\n\t\t\tif(!it[1])it+=2;\t//d¡r\n\t\t\tif(*it+n-x==v2.back()){++it;v2.pop_back();}\t//d¡r\n\t\t\tfor(;it!=itx;++it)\n\t\t\t\tv2.push_back(*it+n-x);\n\t\t\t\n\t\t\tv1.swap(v2);\n\t\t}\n\t\tv1.insert( upper_bound(v1.begin(),v1.end(),p-1), 2, p-1);\n\t\tv1.insert( lower_bound(v1.begin(),v1.end(),q), q );\n\t\tv1.push_back(n);\n\t\tit = upper_bound(v1.begin(),v1.end(),p-1);\n\t\tif(it-v1.begin() & 1) --it;\n\t\tfor(x=0;*it<q;++it){\n\t\t\tm=*it;\n\t\t\t++it;\n\t\t\tx+=*it-m;\n\t\t}\n\t}\n}"
  },
  {
    "language": "C++",
    "code": "#define _USE_MATH_DEFINES\n#include <iostream>\n#include <memory>\n#include <memory.h>\n#include <fstream>\n#include <cmath>\n#include <math.h>\n#include <numeric>\n#include <vector>\n#include <stack>\n#include <string>\n#include <queue>\n#include <sstream>\n#include <cstdlib>\n#include <cassert>\n#include <cstdio>\n#include <map>\n#include <iomanip>\n#include <list>\n#include <cctype>\n#include <algorithm>\n#include <complex>\n\n#define rep(i, n) for(int i = 0; i < n; i++)\n#define rep2(i, m, n) for(int i = m; i < n; i++)\nusing namespace std;\n\ntypedef complex<double> xy_t;\ntypedef pair<xy_t, xy_t> line;\ntypedef long long ll;\ntypedef pair<int, int> P;\ntypedef pair<double, double> Pd;\ntypedef pair<int, P> PP;\ntypedef pair<int, PP> PPP;\nconst int INF = 1 << 29;\nconst double EPS = 1E-10;\n\n#define rep(i, n) for(int i = 0; i < n; i++)\n#define rep2(i, m, n) for(int i = m; i < n; i++)\n\nint sz[10000];\n\nvoid change(vector<P> &nums, int x, int y){\n\tvector<P> res;\n\tint n = nums.size();\n\tint indx, indy;\n\tint ub = n + 1, lb = 0;\n\tsz[0] = 0;\n\trep(i, n){\n\t\tsz[i+1] = sz[i] + nums[i].second - nums[i].first + 1;\n\t}\n\n\twhile(ub - lb > 1){\n\t\tint mb = (ub + lb) / 2;\n\t\tif(sz[mb] < x) lb = mb;\n\t\telse ub = mb;\n\t}\n\tindx = lb;\n\tub = n + 1, lb = 0;\n\n\twhile(ub - lb > 1){\n\t\tint mb = (ub + lb ) / 2;\n\t\tif(sz[mb] <= y) lb = mb;\n\t\telse ub = mb;\n\t}\n\tindy = lb;\n\n\tint dy = indy == n ? 0 : y - sz[indy], dx = indx == n ? 0 : x - sz[indx];\n\n\tres.push_back(P(nums[indy].first + dy ,nums[indy].second));\n\trep2(i, indy + 1, n){\n\t\tres.push_back(nums[i]);\n\t}\n\tif(indx != indy) res.push_back(P(nums[indx].first + dx, nums[indx].second));\n\telse res.push_back(P(nums[indx].first + dx, nums[indx].first + dy-1));\n\trep2(i, indx + 1, indy){\n\t\tres.push_back(nums[i]);\n\t}\n\tif(indx != indy && dy != 0) res.push_back(P(nums[indy].first, nums[indy].first + dy - 1));\n\trep(i, indx ){\n\t\tres.push_back(nums[i]);\n\t}\n\tif(dx != 0)res.push_back(P(nums[indx].first, nums[indx].first + dx - 1));\n\tnums = res;\n}\n\nint get_num(P p, int r){\n\t//cout << \"***\" << p.first << \" \" << p.second << endl;;\n\tif(p.second < p.first) return 0;\n\tif(r < p.first) return 0;\n\telse if(p.second <= r) return p.second - p.first + 1;\n\telse return r - p.first + 1;\n}\n\nint counter(const vector<P> &nums, int p, int q, int r){\n\tint cnt = 1;\n\tint res = 0;\n\tint n = nums.size();\n\trep(i, n){\n\t//\tcout << \"+ \" <<  nums[i].first << \" \" << nums[i].second << endl;\n\t\tint sz = nums[i].second - nums[i].first + 1;\n\t\tint pn = nums[i].first + p - cnt;\n\t\tint qn = nums[i].first + q - cnt;\n\t\t\n\t\tres += get_num(P(max(nums[i].first, pn), min(nums[i].second, qn)), r);\n\t\tcnt += sz;\n\t}\n\treturn res;\n}\n\nint main(){\n\tint n, m;\n\tint p, q, r;\n\tint x, y;\n\twhile(cin >> n && n){\n\t\tvector<P> nums;\n\t\tnums.push_back(P(1, n));\n\t\tcin >> m;\n\t\tcin >> p >> q >> r;\n\t\trep(i, m){\n\t\t\tcin >> x >> y;\n\t\t    change(nums, x, y);\n\t\t}\n\t\tcout << counter(nums, p, q, r) << endl;\n\t}\n\treturn 0;\n}"
  },
  {
    "language": "C++",
    "code": "\n#include<iostream>\nusing namespace std;\nint cards,n,i,p,q,r,x[5002],y[5002],counter;\n  int numberStart[20001];\n  int numberFast[20001];\n  int numberEnd[20001];\n  int searchB[20001];\nint numberLong(int value){\n\treturn numberEnd[value]-numberStart[value]+1;\n}\n\n\nint searchD(int seed){\n\t\tint l=0;\n  for (int a=1;a<=counter+1;a++){\n\tif(seed>l+numberLong(searchB[a])){\n\tl+=numberLong(searchB[a]);\n\t}\n\telse{\n\t return numberFast[searchB[a]];\n\t}\n  }\n return -100;\n\t\n}\nint searchNumber(int value){\n\tint l=0;\n  for (int a=1;a<=counter+1;a++){\n\tif(value>l+numberLong(searchB[a])){\n\tl+=numberLong(searchB[a]);\n\t}\n\telse{\n\t return numberStart[searchB[a]]+value-l-1;\n\t}\n  }\n return -100;\n}\n\nvoid cut(int g){\n\tif(searchD(g)==searchD(g+1)){\n  //カットする場所が入ってる数列を求める\n\tint\tsearchNumberG=searchNumber(g);\n  int seachX=searchB[searchD(g)];\n  int seachXX=searchNumberG;\n//数列ができる範囲の後ろの番号FASTを変える\n     for(int j=1;j<=counter;j++){\n      if (numberFast[j]>=numberFast[seachX]+1){\n      numberFast[j]++;\n     }\n    }\n\n  //の数列の後ろに新しい数列を作る\n counter++;\n  numberFast[counter]=numberFast[seachX]+1;\n  numberStart[counter] =searchNumberG+1;\n  numberEnd[counter]=numberEnd[seachX];\n  //できた数列の前の数列の最後を調整する\n  numberEnd[seachX]=searchNumberG;\n \n\n  \n  for ( int a=1;a<=counter+1;a++){\n\t  searchB[numberFast[a]]=a;\n    }\n    }\n\n}\nvoid shuffle(int x,int y){\n\t\n\tint StartHead[10001];\n\tint  numberFastNew[10001];\n\t\n\tint longs=1;\n\tfor (int i=1;i<=counter;i++){\n\t\tStartHead[searchB[i]]=longs;\n\t\tlongs+=numberLong(searchB[i]);\n\t}\n\tint newCounter[3];\n\tfor(int i=0;i<3;i++){\n\t\tnewCounter[i]=0;\n\t}\n\tfor(int j=1;j<=counter;j++){\n\t\tif (StartHead[j]>y){\n\t\t\tnewCounter[0]++;\n\t\tnumberFastNew[j]=0;\n\t\t}\n\t\tif (StartHead[j]>x && StartHead[j]+numberLong(j)-1<=y){\n\t\t\tnewCounter[1]++;\n\t\tnumberFastNew[j]=1;\n\t\t}\n\t\tif (StartHead[j]+numberLong(j)-1<=x){\n\t\t\tnewCounter[2]++;\n\t\tnumberFastNew[j]=2;\n\t\t}\n\t}\n\t\n\tfor(int j=1;j<=counter;j++){\n\t\tswitch(numberFastNew[j]){\n\t\t\tcase 0:\n\t\t\t\tnumberFast[j]+=-newCounter[1]-newCounter[2];\n\t\t\t\tbreak;\n\t\t\tcase 1:\n\t\t\t\tnumberFast[j]+=newCounter[0]-newCounter[2];\n\t\t\t\tbreak;\n\t\t\tcase 2:\n\t\t\t\tnumberFast[j]+=newCounter[1]+newCounter[0];\n\t\t\t\tbreak;\n\t\t}\n\n\t}\n\t  for ( int a=1;a<=counter+1;a++){\n\t  searchB[numberFast[a]]=a;\n    }\n\n}\n\n\nint main(void)\n{\n\twhile(true){\n\tcards=0;\n\tn=0;\n\tcounter=0;\n\tfor (int i=0;i<20000;i++){\n   numberStart[i]=0;\n   numberFast[i]=0;\n   numberEnd[i]=0;\n   searchB[i]=0;\n\t}\n\tint points=0;\n  counter=1;\n  cin >> cards;\n  if (cards==0){\n\t  break;\n  }\n  numberStart[1]=1;\n  numberEnd[1]=cards;\n  numberFast[1]=1;\n  searchB[1]=1;\n  cin >> n;\n  cin >> p  >> q  >> r ;\n  for (i=1;i<=n;i++){\n    cin >> x[i] >> y[i];\n  }\n  for (i=1;i<=n;i++){\n     cut(x[i]);\n\t \n      cut(y[i]);\n\t  \n     shuffle(x[i],y[i]);\n  }\n  cut(p-1);\n  cut(q);\n /*\n  \n  for(int j=1;j<=counter;j++){\n\n    cout << numberStart[j] << \" \"  <<  numberEnd[j] << \" \" << numberFast[j] <<  endl;\n\n  }\n  cout << searchD(p) << searchD(q) <<endl;\n  */\n  for(int j=1;j<=counter;j++){\n  if( searchD(p)<= numberFast[j] && numberFast[j] <= searchD(q)){\n\t  if(numberEnd[j]<=r){\n\t  points+=numberLong(j);\n\t  }\n\t  else if(numberStart[j]<=r){\n\tpoints+=numberLong(j)-(numberEnd[j]-r);\n\t  }\n  }\n  }\n  cout << points << endl;\n\t}\n}"
  },
  {
    "language": "C++",
    "code": "#include \"bits/stdc++.h\"\n#include<unordered_map>\n#include<unordered_set>\n#pragma warning(disable:4996)\nusing namespace std;\nusing ld = long double;\nconst ld eps = 1e-9;\n\n//// < \"d:\\d_download\\visual studio 2015\\projects\\programing_contest_c++\\debug\\a.txt\" > \"d:\\d_download\\visual studio 2015\\projects\\programing_contest_c++\\debug\\b.txt\"\n\n\nint main() {\n\twhile (1) {\n\t\tint N, M; cin >> N;\n\t\tif (!N)break;\n\t\tcin >> M;\n\t\tint P, Q, R; cin >> P >> Q >> R;\n\t\tvector<pair<int, int>>cards(1, make_pair(1, N));\n\t\tfor (int i = 0; i < M; ++i) {\n\t\t\tint x, y; cin >> x >> y;\n\t\t\tvector<pair<int, int>>a, b, c;\n\t\t\tint h = 0;\n\t\t\tint n = 0;\n\t\t\tfor (; n < cards.size(); ++n) {\n\t\t\t\tauto acard(cards[n]);\n\t\t\t\tint nh = h + acard.second;\n\t\t\t\tif (nh > x) {\n\t\t\t\t\ta.push_back(make_pair(acard.first, x - h));\n\t\t\t\t\tif (nh > y) {\n\t\t\t\t\t\tb.push_back(make_pair(acard.first+(x-h), y-x));\n\t\t\t\t\t\tc.push_back(make_pair(acard.first +(y-h), nh - y));\n\t\t\t\t\t}\n\t\t\t\t\telse {\n\t\t\t\t\t\tb.push_back(make_pair(acard.first + (x - h), nh - x));\n\t\t\t\t\t}\n\t\t\t\t\th = nh;\n\t\t\t\t\tn++;\n\t\t\t\t\tbreak;\n\t\t\t\t}\n\t\t\t\telse if (nh == x) {\n\t\t\t\t\ta.push_back(make_pair(acard.first, x - h));\n\t\t\t\t\th = nh;\n\t\t\t\t\tn++;\n\t\t\t\t\tbreak;\n\t\t\t\t}\n\t\t\t\telse {\n\t\t\t\t\ta.push_back(acard);\n\t\t\t\t\th = nh;\n\t\t\t\t}\n\t\t\t}\n\t\t\tfor (; n < cards.size(); ++n) {\n\t\t\t\tauto acard(cards[n]);\n\t\t\t\tint nh = h + acard.second;\n\t\t\t\tif (nh > y) {\n\t\t\t\t\tb.push_back(make_pair(acard.first, y-h));\n\t\t\t\t\tc.push_back(make_pair(acard.first + y-h, nh - y));\n\t\t\t\t\th = nh;\n\t\t\t\t\tn++;\n\t\t\t\t\tbreak;\n\t\t\t\t}\n\t\t\t\telse if (nh == y) {\n\t\t\t\t\tb.push_back(make_pair(acard.first, y - h));\n\t\t\t\t\th = nh;\n\t\t\t\t\tn++;\n\t\t\t\t\tbreak;\n\t\t\t\t}\n\t\t\t\telse {\n\t\t\t\t\tb.push_back(acard);\n\t\t\t\t\th = nh;\n\t\t\t\t}\n\t\t\t}\n\t\t\tfor (; n < cards.size(); ++n) {\n\t\t\t\tauto acard(cards[n]);\t\t\n\t\t\t\tc.push_back(acard);\n\t\t\t}\n\t\t\tvector<pair<int, int>>nextcards(c);\n\t\t\tnextcards.insert(nextcards.end(), b.begin(), b.end());\n\t\t\tnextcards.insert(nextcards.end(), a.begin(), a.end());\n\n\t\t\tcards = nextcards;\n\t\t}\n\t\tint h = 0 ;\n\t\tint ans = 0;\n\t\tfor (int n = 0; n < cards.size(); ++n) {\n\t\t\tauto card(cards[n]);\n\t\t\tint nh = h + card.second;\n\t\t\tif (h < P&&nh >= P) {\n\t\t\t\tint pnum = card.first + P - h-1;\n\t\t\t\tif (pnum > R)ans += 0;\n\t\t\t\telse {\n\t\t\t\t\tans += min(R - pnum+1, nh - P+1);\n\t\t\t\t}\n\n\t\t\t}\n\n\t\t\tif (h >= P) {\n\t\t\t\tint pnum = card.first;\n\t\t\t\tif (pnum > R)ans += 0;\n\t\t\t\telse {\n\t\t\t\t\tans += min(R - pnum+1, card.second);\n\t\t\t\t}\n\t\t\t}\n\t\t\th = nh;\n\t\t}\n\t\th = 0;\n\t\tfor (int n = 0; n < cards.size(); ++n) {\n\t\t\tauto card(cards[n]);\n\t\t\tint nh = h + card.second;\n\t\t\tif (h <Q&&nh>Q) {\n\t\t\t\tint pnum = card.first;\n\t\t\t\tif (pnum > R)ans += 0;\n\t\t\t\telse {\n\n\t\t\t\t\tans += min(Q - pnum + 1, Q - h);\n\t\t\t\t}\n\n\t\t\t}\n\t\t\tif (nh <= Q) {\n\t\t\t\tint pnum = card.first;\n\t\t\t\tif (pnum > R)ans += 0;\n\t\t\t\telse {\n\t\t\t\t\tans += min(R - pnum + 1, card.second);\n\t\t\t\t}\n\t\t\t}\n\t\t\th = nh;\n\t\t}\n\t\tans -= R;\n\t\tcout << ans << endl;\n\t}\n\treturn 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include<deque>\n#include<list>\n#include<map>\n#include<queue>\n#include<set>\n#include<stack>\n#include<vector>\n#include<algorithm>\n#include<string>\n#include<sstream>\n#include<cmath>\n#include<cstdio>\nusing namespace std;\nint main(){\n  int i,j,k;\n  int n;\n  while(scanf(\"%d\",&n),n){\n    int m,p,q,r;\n    scanf(\"%d%d%d%d\",&m,&p,&q,&r);\n    pair<int,int> a[10001],b[10001];\n    a[0]=make_pair(1,n);\n    int l=1;\n    for(i=0;i<m;++i){\n      int x,y;\n      scanf(\"%d%d\",&x,&y);\n      int sm=0;\n      for(j=0;sm<x;++j)\n\tsm+=a[j].second;\n      if(sm>x){\n\tcopy(a+j,a+l,b);\n\tcopy(b,b+l-j,a+j+1);\n\t++l;\n\ta[j-1].second-=sm-x;\n\ta[j]=make_pair(a[j-1].first+a[j-1].second,sm-x);\n\tsm=x;\n      }\n      for(k=j;sm<y;++k)\n\tsm+=a[k].second;\n      if(sm>y){\n\tcopy(a+k,a+l,b);\n\tcopy(b,b+l-k,a+k+1);\n\t++l;\n\ta[k-1].second-=sm-y;\n\ta[k]=make_pair(a[k-1].first+a[k-1].second,sm-y);\n\tsm=y;\n      }\n      copy(a+k,a+l,b);\n      copy(a+j,a+k,b+l-k);\n      copy(a,a+k,b+l-j);\n      copy(b,b+l,a);\n    }\n    int ct=0,sm=0;\n    for(i=0;i<l;++i){\n      if(0){\n      }else if(sm+a[i].second<p){\n      }else if(sm+1>q){\n      }else if(sm+1<=p&&q<=sm+a[i].second){\n\tif(a[i].first+p-sm-1<=r)\n\t  ct+=min(r,a[i].first+a[i].second-1+q-sm-a[i].second)-a[i].first+p-sm-1+1;\n      }else if(p<=sm+1&&sm+a[i].second<=q){\n\tif(a[i].first<=r)\n\t  ct+=min(r,a[i].first+a[i].second-1)-a[i].first+1;\n      }else if(p<sm+1){\n\tif(a[i].first<=r)\n\t  ct+=min(r,a[i].first+a[i].second-1+q-sm-a[i].second)-a[i].first+1;\n      }else if(q>sm+1){\n\tif(a[i].first+p-sm-1<=r)\n\t  ct+=min(r,a[i].first+a[i].second-1)-a[i].first+p-sm-1+1;\n      }\n      sm+=a[i].second;\n    }\n    printf(\"%d\\n\",ct);\n  }\n  return 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include<iostream>\n#include<vector>\n#include<algorithm>\n#include<cassert>\n#include<cstdio>\nusing namespace std;\n\nstruct P\n{\n  int s,e;\n  P(int s,int e):s(s),e(e){}\n};\n\nvoid shuffle(vector<P>& vec,int x,int y,int n)\n{\n  vector<P> ins;\n  for(int i=0;i<vec.size();i++)\n    {\n      if(vec[i].e <= x)\n\t{\n\t  vec[i].s += (n-x),vec[i].e += (n-x);\n\t}\n      else if(vec[i].s <= x && vec[i].e <= y)\n\t{\n\t  ins.push_back(P(x+1,vec[i].e));\n\t  ins[ins.size()-1].s += (n-y)-x,ins[ins.size()-1].e += (n-y)-x;\n\t  vec[i].e = x;\n\t  vec[i].s += (n-x),vec[i].e += (n-x);\n\t}\n      else if(vec[i].s <= x && vec[i].e  > y)\n\t{\n\t  ins.push_back(P(vec[i].s,x));\n\t  ins[ins.size()-1].s += (n-x),ins[ins.size()-1].e += (n-x);\n\t  ins.push_back(P(x+1,y));\n\t  ins[ins.size()-1].s += (n-y)-x,ins[ins.size()-1].e += (n-y)-x;\n\t  vec[i].s = y+1;\n\t  vec[i].s -= y,vec[i].e -= y;\n\t}\n      else if(vec[i].s  > x && vec[i].e <= y)\n\t{\n\t  vec[i].s += (n-y)-x,vec[i].e += (n-y)-x;\n\t}\n      else if(vec[i].s  > x && vec[i].s <= y && vec[i].e  > y)\n\t{\n\t  ins.push_back(P(vec[i].s,y));\n\t  ins[ins.size()-1].s += (n-y)-x, ins[ins.size()-1].e += (n-y)-x;\n\t  vec[i].s = y+1;\n\t  vec[i].s -= y,vec[i].e -= y;\n\t}\n      else if(vec[i].s  > y)\n\t{\n\t  vec[i].s -= y,vec[i].e -= y;\n\t}\n      else \n\tassert(false);\n    }\nfor(int i=0;i<ins.size();i++)\n  vec.push_back(ins[i]);\n}\n\nint main()\n{\n  int n;\n  while(scanf(\"%d\",&n),n)\n    {\n      int m;\n      scanf(\"%d\",&m);\n      int p,q,r;\n      scanf(\"%d %d %d\",&p,&q,&r);\n      vector<P> vec;\n      vec.push_back(P(1,r));\n\n      for(int i=0;i<m;i++)\n\t{\n\t  int x,y;\n\t  scanf(\"%d %d\",&x,&y);\n\t  shuffle(vec,x,y,n);\n\t}\n   \n\n      int cnt = 0;\n      for(int i=0;i<vec.size();i++)\n\t{\n\t  if(vec[i].s > q || vec[i].e < p)\n\t    continue;\n\t  cnt += min(vec[i].e,q) - max(vec[i].s,p)+1;\n\t  /*\n\t  cout << \"!p: \" <<vec[i].s<<\"!q : \" <<vec[i].e << endl;\n\t  cout << \"p : \" << p << \" q : \" << q << endl;\n\t  if(vec[i].s == vec[i].e && p <= vec[i].s && vec[i].e <= q)\n\t    {\n\t      cout << \"P1\" << endl;\n\t      cnt += 1;\n\t    }\n\t  else if(vec[i].s <= p && q <= vec[i].e)\n\t    {\n\t      cout << \"P2\" << endl;\n\t      cnt += q-p + (vec[i].s == p?1:0) + (vec[i].e == q?1:0);\n\t    }\n\t  else if(p <= vec[i].s && vec[i].e <= q)\n\t    {\n\t      cout << \"P3\" << endl;\n\t      cnt += vec[i].e-vec[i].s+1;\n\t    }\n\t  else if(vec[i].s <= p && vec[i].e >= p)\n\t    {\n\t      cout << \"P4\" << endl;\n\t      cnt += vec[i].e-p+ (vec[i].s == p?1:0) + (vec[i].e == p?1:0);\n\t    }\n\t  else if(vec[i].s <= q && vec[i].e >= q)\n\t    {\n\t      cout << \"P5\" << endl;\n\t      cnt += q-vec[i].s+ (vec[i].s == q?1:0) + (vec[i].e == q?1:0);\n\t    }\n\t  */\n\t  // cout << \"cnt = \" << cnt << endl;\n\t}\n      cout << cnt << endl;\n    }\n  return 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include <iostream>\n#include <algorithm>\n#include <vector>\nusing namespace std;\n\nint c1[5010],c2[5010],vv[1000000000];\nint main(){\n\tint N,M,P,Q,R,ac1,ac2,cnt;\n\twhile(1){\n\t\tcin>>N;\n\t\tif(N==0) break;\n\t\tcin>>M>>P>>Q>>R;\n\t\tfor(int i=0;i<M;i++){\n\t\t\tcin>>ac1>>ac2;\n\t\t\tc1[i]=ac1;\n\t\t\tc2[i]=ac2;\n\t\t}\n\t\tfor(int i=1;i<=N;i++) vv[i]=i;\n\t\t\n\t\tfor(int i=0;i<M;i++){\n\t\t\treverse(vv+1,vv+c1[i]+1);\n\t\t\treverse(vv+c1[i]+1,vv+c2[i]+1);\n\t\t\treverse(vv+c2[i]+1,vv+N+1);\n\t\t\treverse(vv+1,vv+N+1);\n\t\t}\n\t\tcnt=0;\n\t\tfor(int i=P;i<=Q;i++){\n\t\t\tif(vv[i]<=R) cnt++;\n\t\t}\n\t\tcout<<cnt<<endl;\n\t}\n\treturn 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include<iostream>\nusing namespace std;\n\ntypedef struct tagListNode{\n  struct tagListNode *next;\n  int data;\n} Talon;\n\nint main(){\n  int n, m, p, q, r;\n  int x, y;\n  int i;\n  Talon *firstnode, *lastnode, *thisnode, *newnode, *xnode,*ynode, *point;\n  firstnode = lastnode = NULL;\n  while(1){\n    cin >> n;\n    if(n==0) break;\n    for(i=0; i<n;i++){\n      newnode = new Talon;\n      newnode->data = i+1;\n      newnode->next = NULL;\n      \n      if(firstnode != NULL){\n\tlastnode->next = newnode;\n\tlastnode = newnode;\n      } else {\n\tfirstnode = lastnode = newnode;\n      }\n    }\n    cin>>m>>p>>q>>r;\n    for(int j=0; j<m ;j++){\n      cin>> x >> y;\n      xnode = firstnode;\n      for(i=0;i<x-1;i++) xnode = xnode->next;\n\n      ynode = firstnode;\n      for(i=0; i<y-1;i++) ynode = ynode->next;\n      \n      point = ynode->next;\n      lastnode->next = xnode->next;\n      xnode->next =NULL;\n      ynode->next = firstnode;\n      firstnode = point;\n      lastnode = xnode;\n    }\n    \n    thisnode = firstnode;\n    for(i=0; i<p-1;i++){\n      thisnode = thisnode->next;\n    }\n    \n    int count= 0;\n    for(i=0; i<q-p+1; i++){\n      int value = thisnode->data;\n      if(value < r+1) count++;\n      thisnode = thisnode->next;\n    }\n    cout << count <<endl;\n  }\n  return 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include <cstdio>\nbool hi[1000000000];\nint main(){\nreturn 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include <iostream>\n#include <vector>\n\n#define bgi (S.begin())\n#define T_CT 1\n#define T_NC 2\n\nusing namespace std;\n\ntypedef struct\n{\n\tint count;\n\tint type;\n} bulk;\n\nint N,M,P,Q,R;\nvector<bulk> S;\nbulk tb;\n\nbulk* makebulk(int count,int type)\n{\n\ttb.count = count;\n\ttb.type = type;\n\treturn &tb;\n}\n\nvoid shuffle(int x,int y)\n{\n\tint sum = 0;\n\tint countv = 0;\n\twhile(true)\n\t{\n\t\tif(sum + bgi->count <= x)\n\t\t{\n\t\t\tS.push_back(S[0]);\n\t\t\tsum += S[0].count;\n\t\t\tS.erase(bgi);\n\t\t\tcountv++;\n\t\t}\n\t\telse\n\t\t{\n\t\t\tif(sum != x)\n\t\t\t{\n\t\t\t\tS[0].count -= x - sum;\n\t\t\t\tS.push_back(*makebulk(x-sum,S[0].type));\n\t\t\t\tcountv++;\n\t\t\t}\n\t\t\tbreak;\n\t\t}\n\t}\n\tauto endi = S.end()-countv;\n\tsum = 0;\n\twhile(true)\n\t{\n\t\tendi = S.end()-countv;\n\t\tif(sum + bgi->count <= y-x)\n\t\t{\n\t\t\tS.insert(endi,S[0]);\n\t\t\tsum += S[0].count;\n\t\t\tS.erase(bgi);\n\t\t}\n\t\telse\n\t\t{\n\t\t\tif(sum != y-x)\n\t\t\t{\n\t\t\t\tS[0].count -= (y-x) - sum;\n\t\t\t\tS.insert(endi,*makebulk((y-x)-sum,S[0].type));\n\t\t\t\tendi++;\n\t\t\t}\n\t\t\tbreak;\n\t\t}\n\t}\n\tfor(auto it = S.begin();it < S.end()-1;it++)\n\t{\n\t\tif(it->type == (it+1)->type)\n\t\t{\n\t\t\tit->count += (it+1)->count;\n\t\t\tS.erase(it+1);\n\t\t\tit--;\n\t\t}\n\t}\n\t\n}\n\nint main(void)\n{\n\twhile(true)\n\t{\n\t\tcin >> N;\n\t\tif(N == 0)\n\t\t\texit(0);\n\t\tcin >> M >> P >> Q >> R;\n\t\tS.clear();\n\t\tS.push_back(*makebulk(R,T_CT));\n\t\tS.push_back(*makebulk(N-R,T_NC));\n\t\tint a,b;\n\t\tfor(int i = 0;i < M;i++)\n\t\t{\n\t\t\tcin >> a >> b;\n\t\t\tshuffle(a,b);\n\t\t}\n\t\tint sum = 0;\n\t\twhile(true)\n\t\t{\n\t\t\tif(sum + S[0].count <= P-1)\n\t\t\t{\n\t\t\t\tsum += S[0].count;\n\t\t\t\tS.erase(bgi);\n\t\t\t}\n\t\t\telse\n\t\t\t{\n\t\t\t\tif(sum != P-1)\n\t\t\t\t{\n\t\t\t\t\tS[0].count -= (P-1)-sum;\n\t\t\t\t}\n\t\t\t\tbreak;\n\t\t\t}\n\t\t}\n\t\tsum = 0;\n\t\tint count = (Q - P) + 1;\n\t\tint result = 0;\n\t\twhile(true)\n\t\t{\n\t\t\tif(sum + S[0].count <= count)\n\t\t\t{\n\t\t\t\tif(S[0].type == T_CT)\n\t\t\t\t{\n\t\t\t\t\tresult += S[0].count;\n\t\t\t\t}\n\t\t\t\tsum += S[0].count;\n\t\t\t\tS.erase(bgi);\n\t\t\t}\n\t\t\telse\n\t\t\t{\n\t\t\t\tif(sum != count)\n\t\t\t\t{\n\t\t\t\t\tif(S[0].type == T_CT)\n\t\t\t\t\t{\n\t\t\t\t\t\tresult += count - sum;\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t\tbreak;\n\t\t\t}\n\t\t}\n\t\tcout << result << endl;\n\t}\n}"
  },
  {
    "language": "C++",
    "code": "#define _CRT_SECURE_NO_WARNINGS\n#include \"bits/stdc++.h\"\nusing namespace std;\n\n#define int int64_t\n\n#define CHOOSE(a) CHOOSE2 a\n#define CHOOSE2(a0,a1,a2,a3,x,...) x\n#define REP1(i, s, cond, cal) for (signed i = signed(s); i cond; i cal)\n#define REP2(i, s, n) REP1(i, s, < signed(n), ++)\n#define REP3(i, n) REP2(i, 0, n)\n#define rep(...) CHOOSE((__VA_ARGS__,REP1,REP2,REP3))(__VA_ARGS__)\n#define rrep(i, s) rep(i, s, >= 0, --)\n\n#define all(c) begin(c), end(c)\n#define maxup(ans, x) (ans = (ans < x ? x : ans))\n#define minup(ans, x) (ans = (ans > x ? x : ans))\n\n#define breakif(cond) if(cond) break; else\n\nusing VV = vector<vector<int>>;\nusing V = vector<int>;\nusing P = pair<int, int>;\nusing IP = pair<int, P>;\n\ntemplate<typename T>\ninline void input(vector<T>& v) { for (auto& x : v) cin >> x; }\n\nsigned main() {\n\tint n, m, p, q, r;\n\tvector<vector<P>> v(5001, vector<P>(5000));\n\twhile (cin >> n && n) {\n\t\tcin >> m >> p >> q >> r;\n\t\tv[0].clear();\n\t\tv[0].push_back(P(1, n));\n\t\tvector<P> a(m), b(m), c(m);\n\t\trep(i, m) {\n\t\t\ta.clear(); b.clear(); c.clear();\n\t\t\tv[i + 1].clear();\n\t\t\tint x, y; cin >> x >> y;\n\t\t\tint sum = 0;\n\t\t\tfor (P p : v[i]) {\n\t\t\t\tint tmp = p.second - p.first + 1;\n\t\t\t\tif (sum + tmp <= x) {\n\t\t\t\t\ta.push_back(p);\n\t\t\t\t} else if (y <= sum) {\n\t\t\t\t\tc.push_back(p);\n\t\t\t\t} else if (x <= sum && sum + tmp <= y) {\n\t\t\t\t\tb.push_back(p);\n\t\t\t\t} else if (sum < x && y < sum + tmp) {\n\t\t\t\t\tP fst = P(p.first, p.first + (x - sum) - 1);\n\t\t\t\t\tP snd = P(fst.second + 1, fst.second + (y - x));\n\t\t\t\t\tP trd = P(snd.second + 1, p.second);\n\t\t\t\t\ta.push_back(fst);\n\t\t\t\t\tb.push_back(snd);\n\t\t\t\t\tc.push_back(trd);\n\t\t\t\t} else if (sum < x && x < sum + tmp) {\n\t\t\t\t\tP fst = P(p.first, p.first + (x - sum) - 1);\n\t\t\t\t\tP snd = P(fst.second + 1, p.second);\n\t\t\t\t\ta.push_back(fst);\n\t\t\t\t\tb.push_back(snd);\n\t\t\t\t} else if (sum < y && y < sum + tmp) {\n\t\t\t\t\tP fst = P(p.first, p.first + (y - sum) - 1);\n\t\t\t\t\tP snd = P(fst.second + 1, p.second);\n\t\t\t\t\tb.push_back(fst);\n\t\t\t\t\tc.push_back(snd);\n\t\t\t\t}\n\t\t\t\tsum += tmp;\n\t\t\t}\n\t\t\tv[i + 1].insert(v[i + 1].end(), all(c));\n\t\t\tv[i + 1].insert(v[i + 1].end(), all(b));\n\t\t\tv[i + 1].insert(v[i + 1].end(), all(a));\n\t\t}\n\n\t\tint sum = 0;\n\t\tint ans = 0;\n\t\tp--;\n\t\tfor (P item : v[m]) {\n\t\t\tint tmp = item.second - item.first + 1;\n\t\t\tP ra = P(1ll << 60, 1ll << 60);\n\t\t\tif (sum + tmp <= p) {\n\t\t\t\t//skip\n\t\t\t} else if (q <= sum) {\n\t\t\t\t//skip\n\t\t\t} else if (p <= sum && sum + tmp <= q) {\n\t\t\t\tra = item;\n\t\t\t} else if (sum < p && q < sum + tmp) {\n\t\t\t\tint l = item.first + (p - sum);\n\t\t\t\tint r = l + (q - p);\n\t\t\t\tra = P(l, r);\n\t\t\t} else if (sum < p && p < sum + tmp) {\n\t\t\t\tint l = item.first + (p - sum);\n\t\t\t\tint r = item.second;\n\t\t\t\tra = P(l, r);\n\t\t\t} else if (sum < q && q < sum + tmp) {\n\t\t\t\tra = P(item.first, item.first + (q - sum) - 1);\n\t\t\t}\n\n\t\t\tans += max(0ll, min(r, ra.second) - ra.first + 1ll);\n\t\t\tsum += tmp;\n\t\t}\n\t\tcout << ans << endl;\n\t}\n}"
  },
  {
    "language": "C++",
    "code": "#include<iostream>\n\nint n;\n\nint ReShuffle(int x, int y, int m){\n\ty -= x;\n\tint z = n - (x + y);\n\n\tif (m <= z)return x + y + m;\n\telse if (m <= z + y)return x + (m - z);\n\telse return (m - y - z);\n}\n\nint main(){\n\n\twhile (std::cin >> n, n){\n\n\t\tint m, p, q, r, cnt = 0;\n\n\t\tstd::cin >> m >> p >> q >> r;\n\n\t\tstd::pair<int, int>Shuffle[5001];\n\n\t\tfor (int i = 0; i < m; i++)std::cin >> Shuffle[i].first >> Shuffle[i].second;\n\n\t\tfor (int i = p; i <= q; i++){\n\n\t\t\tint card = i;\n\t\t\tfor (int j = 0; j < m; j++){\n\t\t\t\tcard = ReShuffle(Shuffle[j].first, Shuffle[j].second, card);\n\t\t\t}\n\t\t\tif (card <= r)cnt++;\n\t\t}\n\n\t\tstd::cout << cnt << std::endl;\n\t}\n\n\treturn 0;\n}"
  },
  {
    "language": "C++",
    "code": "//28\n#include<iostream>\n#include<vector>\n\nusing namespace std;\n\nstruct S{\n  int s,l;\n};\n\nvoid cut(vector<S> &v,int x,vector<S> &r){\n  r.clear();\n  int n=0,p;\n  for(p=0;n+v[p].l<=x;n+=v[p].l,p++);\n  S ns={v[p].s+x-n,v[p].l-(x-n)};\n  r.push_back(ns);\n  r.insert(r.end(),v.begin()+p+1,v.end());\n  v.erase(v.begin()+p+1,v.end());\n  (*v.rbegin()).l=x-n;\n}\n\nint main(){\n  for(int n;cin>>n,n;){\n    int m,p,q,r;\n    cin>>m>>p>>q>>r;\n    vector<S> v;\n    S is={1,n};\n    v.push_back(is);\n    while(m--){\n      int x,y;\n      cin>>x>>y;\n      vector<S> a,b,c;\n      cut(v,y,c);\n      cut(v,x,b);\n      a=v;\n      v=c;\n      v.insert(v.end(),b.begin(),b.end());\n      v.insert(v.end(),a.begin(),a.end());\n    }\n    vector<S> rv;\n    cut(v,q,rv);\n    cut(v,p-1,rv);\n    int ans=0;\n    for(int i=0;i<rv.size();i++){\n      ans+=max(0,min(r-rv[i].s+1,rv[i].l));\n    }\n    cout<<ans<<endl;\n  }\n  return 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include<iostream>\n#include<cstdio>\n#include<algorithm>\n#include<string>\n#include<vector>\n#include<queue>\n#include<set>\n#include<stack>\n#include<functional>\n#include<list>\n#define P pair<int,int>\nusing namespace std;\n\nlist<P>operator +(list<P>a, list<P>b) {\n\twhile (b.size()) {\n\t\ta.push_back(b.front()); b.pop_front();\n\t}\n\treturn a;\n}\nlist<P>L;\nint main() {\n\tint a;\n\twhile (cin >> a, a) {\n\t\tint b, c, d, e; scanf(\"%d%d%d%d\", &b, &c, &d, &e);\n\t\tL.clear();\n\t\tL.push_back(P(1, a));\n\t\tfor (int f = 0; f < b; f++) {\n\t\t\tint g, h; scanf(\"%d%d\", &g, &h);\n\t\t\tlist<P>A, B, C;\n\t\t\tint sum = 0,j=0;\n\t\t\twhile (L.size()) {\n\t\t\t\tP i = L.front(); L.pop_front();\n\t\t\t\tsum += i.second - i.first+1;\n\t\t\t\tif (j < g&&sum > g) {\n\t\t\t\t\tif (j < h&&sum > h) {\n\t\t\t\t\t\tA.push_back(P(i.first, i.first + (g - j) - 1));\n\t\t\t\t\t\tB.push_back(P(i.first + (g - j), i.first + (h - j)-1));\n\t\t\t\t\t\tC.push_back(P(i.first + (h - j), i.second));\n\t\t\t\t\t}\n\t\t\t\t\telse {\n\t\t\t\t\t\tA.push_back(P(i.first, i.first + (g - j) - 1));\n\t\t\t\t\t\tB.push_back(P(i.first + (g - j), i.second));\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t\telse {\n\t\t\t\t\tif (j < h&&sum > h) {\n\t\t\t\t\t\tB.push_back(P(i.first, i.first + (h - j) - 1));\n\t\t\t\t\t\tC.push_back(P(i.first + (h - j), i.second));\n\t\t\t\t\t}\n\t\t\t\t\telse {\n\t\t\t\t\t\tif (sum > h) {\n\t\t\t\t\t\t\tC.push_back(i);\n\t\t\t\t\t\t}\n\t\t\t\t\t\telse if (sum > g) {\n\t\t\t\t\t\t\tB.push_back(i);\n\t\t\t\t\t\t}\n\t\t\t\t\t\telse {\n\t\t\t\t\t\t\tA.push_back(i);\n\t\t\t\t\t\t}\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t\tj += i.second - i.first+1;\n\t\t\t}\n\t\t\tL = C + B + A;\n\t\t}\n\t\tint x = 0, y = 0;\n\t\tvector<P>W;\n\t\twhile (L.size()) {\n\t\t\tP t = L.front(); L.pop_front();\n\t\t\tx += t.second - t.first + 1;\n\t\t\tif (x <= d&&x>=c) {\n\t\t\t\tif (y <= d&&x >= c) {\n\t\t\t\t\tW.push_back(P(t.first,t.second));\n\t\t\t\t}\n\t\t\t\telse {\n\t\t\t\t\tW.push_back(P(t.second-(x-c),t.second));\n\t\t\t\t}\n\t\t\t}\n\t\t\telse {\n\t\t\t\tif (y<=d&&x>=c) {\n\t\t\t\t\tW.push_back(P(t.first,t.first+d-y));\n\t\t\t\t}\n\t\t\t}\n\t\t\ty += t.second - t.first + 1;\n\t\t}\n\t\tint ans = 0;\n\t\tfor (P i: W) {\n\t\t\tans += max(0,min(i.second,e)-i.first+1);\n\t\t}\n\t\tcout << ans << endl;\n\t}\n}"
  },
  {
    "language": "C++",
    "code": "#include<vector>\n#include<list>\n#include<algorithm>\n#include<iostream>\n#include<string>\n#include<cstdio>\n#include<cstdlib>\n#include<cstring>\n#include<cmath>\nusing namespace std;\nint main(){\n  int i,j;\n  int m,n,p,q,r,x,y;\n  int sm;\n  list<int> a,b,c,d;\n  list<int>::iterator it,jt,kt;\n  while(cin>>n&&n){\n    cin>>m>>p>>q>>r;\n    a.clear();\n    for(i=1;i<n+1;i++)\n      a.push_back(i);\n    for(i=0;i<m;i++){\n      cin>>x>>y;\n      it=a.begin();\n      for(j=0;j<x;j++)\n\tit++;\n      jt=it;\n      for(j=0;j<y-x;j++)\n\tit++;\n      kt=it;\n      b.assign(a.begin(),jt);\n      c.assign(jt,kt);\n      d.assign(kt,a.end());\n      a.clear();\n      a.splice(a.end(),d);\n      a.splice(a.end(),c);\n      a.splice(a.end(),b);\n    }\n    it=a.begin();\n    sm=0;\n    for(i=0;i<p-1;i++)\n      it++;\n    for(i=0;i<q-p+1;i++){\n      if(*it<=r)\n\tsm++;\n      it++;\n    }\n    cout<<sm<<endl;\n  }\n  return 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include<bits/stdc++.h>\nusing namespace std;\ntypedef pair<int,int> P;\n\nint n, m;\nvector<P> S,A,B,C;\n\nvoid shuffle(int x,int y){\n  \n  A.clear();\n  B.clear();\n  C.clear();\n\n  for(int i=0;i<S.size();i++){\n    \n    int d=S[i].second-S[i].first+1;\n    \n    if(d<=x){\n      \n      A.push_back(S[i]);\n      \n      x-=d;\n      \n      S.erase(S.begin());\n      \n      i--;\n    }\n    else{\n      \n      A.push_back(P(S[i].first,S[i].first+x-1));\n      \n      S[i]=P(S[i].first+x,S[i].second);\n      \n      x=0;\n           \n    }\n    if(!x) break;\n  }\n  \n  for(int i=0;i<S.size();i++){\n  \n    int d=S[i].second-S[i].first+1;\n\t\n    if(d<=y){\n      \n      B.push_back(S[i]);\n      \n      y-=d;\n      \n      S.erase(S.begin());\n      \n      i--;\n    }\n    else{\n      \n      B.push_back(P(S[i].first,S[i].first+y-1));\n      \n      S[i]=P(S[i].first+y,S[i].second);\n      \n      y=0;\n            \n    }\n    \n    if(!y) break;\n  }\n  \n  for(int i=0;i<S.size();i++) C.push_back(S[i]);\n    \n  S.clear();\n\n  for(int i=0;i<C.size();i++) S.push_back(C[i]);\n  \n  for(int i=0;i<B.size();i++) S.push_back(B[i]);\n  \n  for(int i=0;i<A.size();i++) S.push_back(A[i]);\n  \n}\n\nint cal(int p,int q,int r){\n  \n  int res=0;\n\n  q=q-p+1;\n  p--;\n  for(int i=0;i<S.size();i++){\n  \n    int d=S[i].second-S[i].first+1;\n\t\n    if(d<=p){\n      \n      p-=d;\n      \n      S.erase(S.begin());\n      \n      i--;\n    }\n    else{\n      \n      S[i]=P(S[i].first+p,S[i].second);\n      \n      p=0;\n            \n    }\n    \n    if(!p) break;\n  }\n\n  for(int i=0;i<S.size();i++){\n\n    int d=S[i].second-S[i].first+1;\n\n    if(d<=q){\n      \n      if(S[i].first<=r) res+=min(r,S[i].second)-S[i].first+1;\n      \n      q-=d;\n    }else{\n      \n      S[i]=P(S[i].first,S[i].first+q-1);\n      \n      if(S[i].first<=r) res+=min(r,S[i].second)-S[i].first+1;\n    \n      q=0;\n    }\n    \n    if(!q) break;\n  }\n  \n  return res;\n}\n\nint main(){\n\n  while(1){\n    \n    cin>>n;\n    if(!n) break;\n    \n    cin>>m;\n    \n    int p, q, r;\n\n    cin>>p>>q>>r;\n        \n    S.clear();\n    \n    S.push_back(P(1,n));\n    \n    for(int i=0;i<m;i++){\n\n      int x, y;\n      cin>>x>>y;\n      \n      shuffle(x,y-x);\n    }\n    \n    cout<<cal(p,q,r)<<endl;\n    \n  }\n  \n  return 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include<bits/stdc++.h>\nusing namespace std;\n#define h first\n#define w second\nvector<pair<bool,pair<int,int> > >v;\nint n,m,p,q,r,i;\nvoid Vp(bool a,int b,int c){v.push_back(make_pair(a,make_pair(b,c)));}\nint main(){\n\twhile(cin>>n&&n){\n\tcin>>m>>p>>q>>r;v.clear();\n\tVp(1,1,r);Vp(0,r+1,n);\n\twhile(m--){\n\t\tint x,y;scanf(\"%d%d\",&x,&y);\n\t\tfor(i=0;i<v.size();i++){\n\t\t\tint a=v[i].w.h,b=v[i].w.w;bool c=v[i].h;\n\t\t\tif(a<=x&&x<b){Vp(c,x+1,b);b=x;}\n\t\t\tif(a<=y&&y<b){Vp(c,y+1,b);b=y;}\n\t\t\tif(0<a&&b<=x)a+=n-x,b+=n-x;\n\t\t\telse if(x<a&&b<=y)a+=n-x-y,b+=n-x-y;\n\t\t\telse if(y<a&&b<=n)a-=y,b-=y;\n\t\t\tv[i].w.h=a,v[i].w.w=b;\n\t\t}\n\t}n=0;\n\tfor(i=0;i<v.size();i++)if(v[i].h)n+=max(0,1+min(v[i].w.w,q)-max(v[i].w.h,p));\n\tcout<<n<<endl;\n\t}\n\treturn 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include <fstream>\n#include <string>\n#include <sstream>\n#include <iostream>\n#include <locale>\n#include <codecvt>\n#include <memory>\n#include <iostream>\n#include <fstream>\n#include <string>\n#include <locale>\n#include <iomanip>\n#include <utility>\n#include <algorithm>\n\n\nint32_t N;\nint32_t p,q,r;\nint32_t M;\nint32_t X[5000];\nint32_t Y[5000];\n\nint32_t K[2][5000 * 3][2];//0: s 1: ?????°\nauto K_end = K[0];\ninline void insert(decltype(K_end) pos, int32_t ns, int32_t nn)\n{\n\tfor (auto iter = K_end; iter != pos; --iter) {\n\t\t(*iter)[0] = (*(iter - 1))[0];\n\t\t(*iter)[1] = (*(iter - 1))[1];\n\t}\n\t(*pos)[0] = ns;\n\t(*pos)[1] = nn;\n\t++K_end;\n}\nint main()\n{\n\tstd::cin >> N;\n\twhile (N != 0)\n\t{\n\t\tstd::cin >> M >> p >> q >> r;\n\t\tfor (int32_t i = 0; i < M; ++i) {\n\t\t\tstd::cin >> X[i] >> Y[i];\n\t\t}\n\t\tK_end = K[0];\n\t\t(*K_end)[0] = 1;\n\t\t(*K_end)[1] = N;\n\t\t++K_end;\n\n\t\tfor (int32_t i = 0; i < M; ++i)\n\t\t{\n\t\t\t//??????\n\t\t\tint num_buf = 0;\n\t\t\tdecltype(K_end) x_end_pos = nullptr;\n\t\t\tfor (auto iter = K[i & 1]; iter != K_end; ++iter) {\n\t\t\t\tnum_buf += (*iter)[1];\n\t\t\t\tif (X[i] <= num_buf) {\n\t\t\t\t\tauto nn = (num_buf - X[i]);\n\t\t\t\t\t(*iter)[1] -= nn;\n\t\t\t\t\tinsert(iter + 1, (*iter)[0] + (*iter)[1], nn);\n\t\t\t\t\tx_end_pos = iter + 1;\n\t\t\t\t\tbreak;\n\t\t\t\t}\n\t\t\t}\n\t\t\tnum_buf = X[i];\n\t\t\tdecltype(K_end) y_end_pos = nullptr;\n\t\t\tfor (auto iter = x_end_pos; iter != K_end; ++iter) {\n\t\t\t\tnum_buf += (*iter)[1];\n\t\t\t\tif (Y[i] <= num_buf) {\n\t\t\t\t\tauto nn = (num_buf - Y[i]);\n\t\t\t\t\t(*iter)[1] -= nn;\n\t\t\t\t\tinsert(iter + 1, (*iter)[0] + (*iter)[1], nn);\n\t\t\t\t\ty_end_pos = iter + 1;\n\t\t\t\t\tbreak;\n\t\t\t\t}\n\t\t\t}\n\t\t\t//????????????\n\t\t\tauto iter_out = K[(i + 1) & 1];\n\t\t\tfor (auto iter = y_end_pos; iter != K_end; ++iter) {\n\t\t\t\t(*iter_out)[0] = (*iter)[0];\n\t\t\t\t(*iter_out)[1] = (*iter)[1];\n\t\t\t\t++iter_out;\n\t\t\t}\n\t\t\tfor (auto iter = x_end_pos; iter != y_end_pos; ++iter) {\n\t\t\t\t(*iter_out)[0] = (*iter)[0];\n\t\t\t\t(*iter_out)[1] = (*iter)[1];\n\t\t\t\t++iter_out;\n\t\t\t}\n\t\t\tfor (auto iter = K[i & 1]; iter != x_end_pos; ++iter) {\n\t\t\t\t(*iter_out)[0] = (*iter)[0];\n\t\t\t\t(*iter_out)[1] = (*iter)[1];\n\t\t\t\t++iter_out;\n\t\t\t}\n\t\t\tK_end = iter_out;\n\t\t}\n\n\t\t//??????\n\t\tint32_t num_buf = 0;\n\t\tint32_t count = 0;\n\t\tfor (auto iter = K[M & 1]; iter != K_end; ++iter) {\n\t\t\tauto n_numbuf = num_buf + (*iter)[1];\n\t\t\tauto add = std::min(r - ((*iter)[0] - 1), (*iter)[1]);\n\t\t\tif (num_buf < p) {\n\t\t\t\tadd -= (p - 1 - num_buf);\n\t\t\t}\n\t\t\tif (q < n_numbuf) {\n\t\t\t\tadd = std::min(add, q - num_buf);\n\t\t\t}\n\t\t\tcount += std::max(0, add);\n\t\t\tnum_buf = n_numbuf;\n\t\t}\n\t\tstd::cout << count << '\\n';\n\t}\n}\n\n#if 0\n#include <codecvt>\n// utility wrapper to adapt locale-bound facets for wstring/wbuffer convert\ntemplate<class Facet>\nstruct deletable_facet : Facet\n{\n\ttemplate<class ...Args>\n\tdeletable_facet(Args&& ...args) : Facet(std::forward<Args>(args)...) {}\n\t~deletable_facet() {}\n};\n\nint main()\n{\n\t// UTF-8 narrow multibyte encoding\n\tstd::string data = u8\"z\\u00df\\u6c34\\U0001f34c\";\n\t// or u8\"z???°´????\"\n\t// or \"\\x7a\\xc3\\x9f\\xe6\\xb0\\xb4\\xf0\\x9f\\x8d\\x8c\";\n\n\tstd::ofstream(\"text.txt\") << data;\n\n\t// using system-supplied locale's codecvt facet\n\tstd::wifstream fin(\"text.txt\");\n\t// reading from wifstream will use codecvt<wchar_t, char, mbstate_t>\n\t// this locale's codecvt converts UTF-8 to UCS4 (on systems such as Linux)\n\tfin.imbue(std::locale(\"en_US.UTF-8\"));\n\tstd::cout << \"The UTF-8 file contains the following UCS4 code points: \\n\";\n\tfor (wchar_t c; fin >> c; )\n\t\tstd::cout << \"U+\" << std::hex << std::setw(4) << std::setfill('0') << c << '\\n';\n\n\t// using standard (locale-independent) codecvt facet\n\tstd::wstring_convert<\n\t\tdeletable_facet<std::codecvt<char16_t, char, std::mbstate_t>>, char16_t> conv16;\n\tstd::u16string str16 = conv16.from_bytes(data);\n\n\tstd::cout << \"The UTF-8 file contains the following UTF-16 code points: \\n\";\n\tfor (char16_t c : str16)\n\t\tstd::cout << \"U+\" << std::hex << std::setw(4) << std::setfill('0') << c << '\\n';\n}\n#endif\n#if 0\nint main()\n{\n\tstd::locale jpn_loc_all(\"Japanese\");\n\tstd::locale jpn_loc(std::locale::classic(), \"Japanese\",\n\t\tstd::locale::ctype);// | std::locale::collate);\n\tstd::locale::global(jpn_loc);\n\tstd::wcout.imbue(jpn_loc);\n\tif(1){\n\t\tstd::wifstream wifs(L\"in.txt\");\n\n\t\tif (!wifs) {\n\t\t\tstd::wcout << L\"ifs.fail()\\n\";\n\t\t}\n\t\tstd::wstring buf;\n\t\tstd::getline(wifs, buf, L'@');\n\t\tif (buf.empty()) {\n\t\t\tstd::wcout << L\"wbuf.empty()\\n\";\n\t\t}\n\t\tstd::wcout << buf << std::endl;\n\t\tstd::wcout << L\"------------------\" << std::endl;\n\t}\n\t{\n\t\tstd::ifstream ifs(\"in.txt\");\n\t\tif (!ifs) {\n\t\t\tstd::cout << \"ifs.fail()\\n\";\n\t\t}\n\t\tstd::string buf;\n\t\tstd::getline(ifs, buf, '@');\n\t\tif (buf.empty()) {\n\t\t\tstd::cout << \"buf.empty()\\n\";\n\t\t}\n\t\tstd::cout << buf << std::endl;\n\t\tstd::wstring wstr;\n\t\t{\n\t\t\tsize_t     length = buf.size();\n\t\t\tauto  wc = std::make_unique< wchar_t[]>(length + 1);\n\t\t\tmbstowcs_s(&length, wc.get(), length + 1, buf.c_str(), length); // wc ??????????????????????????\\???\n\t\t\twstr = wc.get();\n\t\t}\n\t\tstd::wcout << L\"------------------\" << std::endl;\n\t\tif (wstr.empty()) {\n\t\t\tstd::wcout << L\"buf.empty()\\n\";\n\t\t}\n\t\tstd::wcout << wstr << std::endl;\n\t}\n}\n#endif"
  },
  {
    "language": "C++",
    "code": "#include <set>\n#include <map>\n#include <list>\n#include <queue>\n#include <stack>\n#include <cmath>\n#include <ctime>\n#include <cstdio>\n#include <vector>\n#include <string>\n#include <bitset>\n#include <cctype>\n#include <cstdlib>\n#include <cstring>\n#include <utility>\n#include <numeric>\n#include <complex>\n#include <sstream>\n#include <fstream>\n#include <iomanip>\n#include <cassert>\n#include <iostream>\n#include <iterator>\n#include <algorithm>\n\nusing namespace std;\n\n//4方向ベクトル→↑←↓\nint dx[4] ={1,0,-1,0};\nint dy[4] ={0,-1,0,1};\n\nvector<int> Card;\nvector<int> Cardtemp;\nunsigned long n;//カードの枚数\nint m;//シャッフルの回数\nint x,y;//シャッフルする(x,y)\nint p,q,r;//p行q行以下に番号r以下のカードが何枚含まれているか\nint main()\n{\n  while(1){\n  scanf(\"%lu\",&n);\n  if(n==0)\n    break;\n  scanf(\"%d\",&m);\n  scanf(\"%d %d %d\",&p,&q,&r);\n  Card.clear();\n  Cardtemp.clear();\n  for(int i = 1;i <=n;i++){\n    Card.push_back(i);\n  }\n  unsigned long ans = 0;\n  for(int i = 1;i <=m;i++){\n    Cardtemp = Card;\n    scanf(\"%d %d\",&x,&y);\n    for(int j = 0;j <=n-(y+1);j++){\n      Card[j] = Cardtemp[y+j];\n    }\n    for(int j = 0;j <=y-(x+1);j++){\n      Card[n-y+j] = Cardtemp[x+j];\n\t}\n    for(int j = 0;j <=x-1;j++){\n      Card[n-x+j] = Cardtemp[j];\n    }\n  }\n  for(int i = p-1;i < q;i++){\n    if(Card[i] <= r)\n      ans++;\n  }\n  cout <<ans<<endl;\n  }\n  return 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include <cstdio>\n#include <cstdlib>\n#include <cstring>\n#include <cmath>\n#include <climits>\n#include <cfloat>\n#include <ctime>\n#include <map>\n#include <utility>\n#include <set>\n#include <iostream>\n#include <memory>\n#include <string>\n#include <vector>\n#include <algorithm>\n#include <functional>\n#include <sstream>\n#include <complex>\n#include <stack>\n#include <queue>\n#include <numeric>\n#include <list>\n\nusing namespace std;\n\n#ifdef _MSC_VER\n#define __typeof__ decltype\n\ntemplate <class T>\nint __builtin_popcount(T n) { return n ? 1 + __builtin_popcount(n & (n - 1)) : 0; }\n#endif\n\n#define foreach(it, c) for (__typeof__((c).begin()) it=(c).begin(); it != (c).end(); ++it)\n#define all(c) (c).begin(), (c).end()\n#define rall(c) (c).rbegin(), (c).rend()\n#define popcount __builtin_popcount\n\n#define rep(i, n) for (int i = 0; i < n; ++i)\n\ntemplate <class T> void max_swap(T& a, const T b) { a = max(a, b); }\ntemplate <class T> void min_swap(T& a, const T b) { a = min(a, b); }\n\nconst double EPS = 1e-10;\ntypedef long long ll;\ntypedef pair<int, int> pint;\n\n\nstruct Range\n{\n\tRange() {}\n\tRange(int top, int n) : top(top), n(n) {}\n\tpair<Range, Range> split(int num)\n\t{\n\t\treturn make_pair(Range(top, num), Range(top + num, n - num));\n\t}\n\tint top, n;\n};\nRange pile[50000], a[50000], b[50000], c[50000];\nint size;\nint next(int& i, int& sum, int until_sum, Range* a)\n{\n\tint j = 0;\n\tfor (i = 0; sum < until_sum; ++i)\n\t{\n\t\tif (sum + pile[i].n <= until_sum)\n\t\t{\n\t\t\t//a.push_back(pile[i]);\n\t\t\ta[j++] = pile[i];\n\t\t\tsum += pile[i].n;\n\t\t}\n\t\telse\n\t\t{\n\t\t\tpair<Range, Range> t = pile[i].split(until_sum - sum);\n\t\t\t//a.push_back(t.first);\n\t\t\ta[j++] = t.first;\n\t\t\tsum = until_sum;\n\n\t\t\tpile[i] = t.second;\n\t\t\tbreak;\n\t\t}\n\t}\n\treturn j;\n}\nint main()\n{\n\tint n, m, p, q, r;\n\twhile (scanf(\"%d\", &n), n)\n\t{\n\t\tscanf(\"%d%d%d%d\", &m, &p, &q, &r);\n\n\t\t//pile.push_back(Range(1, n));\n\t\tpile[0].top = 1, pile[0].n = n;\n\t\tsize = 1;\n\t\twhile (m--)\n\t\t{\n\t\t\tint x, y;\n\t\t\tscanf(\"%d%d\", &x, &y);\n\n\t\t\tint p = 0, sum = 0;\n\t\t\t//next(pile, p, sum, x, a);\n\t\t\t//next(pile, p, sum, y, b);\n\t\t\t//for ( ; p < pile.size(); ++p)\n\t\t\t//\tc.push_back(pile[p]);\n\t\t\tint a_size = next(p, sum, x, a);\n\t\t\tint b_size = next(p, sum, y, b);\n\t\t\tint c_size;\n\t\t\tfor (c_size = 0; p < size; ++p, ++c_size)\n\t\t\t\tc[c_size] = pile[p];\n\t\t\t\n\t\t\t//pile.insert(pile.end(), all(b));\n\t\t\t//pile.insert(pile.end(), all(a));\n\t\t\tsize = 0;\n\t\t\trep (i, c_size)\n\t\t\t\tpile[size++] = c[i];\n\t\t\trep (i, b_size)\n\t\t\t\tpile[size++] = b[i];\n\t\t\trep (i, a_size)\n\t\t\t\tpile[size++] = a[i];\n\t\t}\n\n\n\t\tint i = 0, sum = 0;\n\t\t//next(pile, i, sum, p - 1, a);\n\t\t//next(pile, i, sum, q, b);\n\t\tint a_size = next(p, sum, p - 1, a);\n\t\tint b_size = next(p, sum, q, b);\n\n\t\tint res = 0;\n\t\trep (i, b_size)\n\t\t\tres += min(b[i].n, max(0, r - (b[i].top - 1)));\n\t\t\n\t\tprintf(\"%d\\n\", res);\n\t}\n}"
  },
  {
    "language": "C++",
    "code": "#include <cstdio>\n#include <vector>\n#include <map>\nusing namespace std;\ntypedef pair<int, int> P;\ntypedef vector<P> vi;\n#define f first\n#define s second\n#define pb push_back\n#define sz(x) x.size()\nvi c,temp1,temp2,temp3;\nvoid shuffle(int x, int y) {\n    int cnt=0, i;\n    int sz=sz(c);\n    for (i=0; i<sz; i++) {\n        int s=c[i].f, e=c[i].s;\n        if (cnt+e-s+1>=x) {\n            temp1.pb(P(s,s+x-cnt-1));\n            break;\n        }\n        temp1.pb(c[i]); \n        cnt+=e-s+1;\n    }\n    if (cnt+c[i].s-c[i].f+1>=y) {\n        temp2.pb(P(c[i].f+x-cnt,c[i].f+y-cnt-1));\n        temp3.pb(P(c[i].f+y-cnt,c[i].s));\n        for (i+=1;i<sz; i++) temp3.pb(c[i]);\n    } else {\n        temp2.pb(P(c[i].f+x-cnt,c[i].s));\n        cnt+=c[i].s-c[i].f+1;\n        int a=++i;\n        for (;i<sz; i++) {\n            int s=c[i].f, e=c[i].s;\n            if (cnt+e-s+1>=y) {\n                temp2.pb(P(s,s+y-cnt-1));\n                break;\n            }\n            temp2.pb(c[i]);\n            cnt+=e-s+1;\n        }\n        if (cnt+c[i].s-c[i].f+1!=y) temp3.pb(P(c[i].f+y-cnt,c[i].s));\n        for (i+=1; i<sz; i++) temp3.pb(c[i]);\n    }\n/*\n    for (i=0; i<sz(temp1); i++) printf(\"%d %d\\n\",temp1[i].f,temp1[i].s);\n    puts(\"\");\n    for (i=0; i<sz(temp2); i++) printf(\"%d %d\\n\",temp2[i].f,temp2[i].s);\n    puts(\"\");\n    for (i=0; i<sz(temp3); i++) printf(\"%d %d\\n\",temp3[i].f,temp3[i].s);\n    puts(\"\");\n*/\n    for (i=0; i<sz(temp3); i++) c.pb(temp3[i]);\n    for (i=0; i<sz(temp2); i++) c.pb(temp2[i]);\n    for (i=0; i<sz(temp1); i++) c.pb(temp1[i]);\n    temp1.clear(); temp2.clear(); temp3.clear();\n}\n\nint main() {\n    int n, m, p, q, r;\n    while (scanf(\"%d\",&n)) {\n        if (!n) break;\n        scanf(\"%d%d%d%d\",&m,&p,&q,&r);\n        c=vi(1,P(1,n));\n        for (int i=0; i<m; i++) {\n            int x, y; scanf(\"%d%d\",&x,&y);\n            shuffle(x,y);\n        }\n        int cnt=0, res=0;\n        for (int i=0; i<sz(c); i++) {\n            int s=c[i].f, e=c[i].s;\n//            printf(\"%d %d\\n\",s,e);\n            if (cnt+e-s+1>=p&&q>=cnt) {\n                int m=max(s+p-cnt-1,s), M=min(s+q-cnt-1,e);\n//                printf(\"%d %d\\n\",m,M);\n                if (r>=m&&r<=M) res+=r-m+1;\n                else if (r>=M) res+=M-m+1;\n            }\n            cnt+=e-s+1;\n        }\n        printf(\"%d\\n\",res);\n    }\n}"
  },
  {
    "language": "C++",
    "code": "#include <iostream>\n#include <cstdio>\n#include <algorithm>\n#include <map>\n#include <vector>\n\nusing namespace std;\n\n#define FOR(i,a,b) for(int i=(a);i<(b);i++)\n#define REP(i,n) FOR(i,0,n)\n\ntypedef pair<int, int> pii;\n\nstruct Data {\n\tint x, y, cnt;\n\tData() {}\n\tData(int x, int y, int cnt) : x(x), y(y), cnt(cnt) {}\n};\n\nint n, m, p, q, r;\n\nint main() {\n\tcin >> n >> m >> p >> q >> r;\n\tp--; q--;\n\t\n\tvector<Data> data;\n\tdata.push_back(Data(0, n, r));\n\t\n\tREP(i, m) {\n\t\tint x, y;\n\t\tscanf(\"%d %d\", &x, &y);\n\t\t\n\t\tvector<pii> res[3]; // ???????????§??????, r??\\???????????°\n\t\t\n\t\tint c[3] = {x, y - x, n - y};\n\t\tpii pos = pii(0, 0); // i,j  data???i?????????j?????§??????\n\t\t\n\t\tREP(i, 3) {\n\t\t\tint cnt = c[i];\n\t\t\t\n\t\t\twhile (cnt > 0) {\n\t\t\t\tint len = data[pos.first].y - data[pos.first].x;\n\t\t\t\tint diff = min(cnt, len - pos.second);\n\t\t\t\t\n\t\t\t\tres[i].push_back(pii(diff, max(0, min(data[pos.first].cnt - pos.second, diff))));\n\t\t\t\t\n\t\t\t\tcnt -= diff;\n\t\t\t\tpos.second += diff;\n\t\t\t\t\n\t\t\t\tif (pos.second == len)\n\t\t\t\t\tpos = pii(pos.first + 1, 0);\n\t\t\t\t\n\t\t\t}\n\t\t}\n\t\t\n\t\tdata.clear();\n\t\tint cnt = 0;\n\t\tfor (int i = 2; i >= 0; i--) {\n\t\t\tREP(j, res[i].size()) {\n\t\t\t\tdata.push_back(Data(cnt, cnt + res[i][j].first, res[i][j].second));\n\t\t\t\tcnt += res[i][j].first;\n\t\t\t}\n\t\t}\n\t}\n\t\n\tint ans, pos = 0;\n\twhile (data[pos].y <= p) pos++;\n\t\n\tans = max(0, data[pos].cnt - (p - data[pos].x));\n\t\n\tif (data[pos].y > q) {\n\t\tans = min(ans, q - p + 1);\n\t}\n\telse {\n\t\tpos++;\n\t\twhile (data[pos].y <= q) ans += data[pos++].cnt;\n\t\tans += min(data[pos].cnt, q - data[pos].x + 1);\n\t}\n\t\n\tcout << ans << endl;\n\t\n\treturn 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include <iostream>\n#include <utility>\n#include <list>\n#include <algorithm>\n\nint main() {\n\tlong long n, m, p, q, r;\n\twhile (std::cin >> n, n != 0) {\n\t\tstd::list<std::pair<long long, long long>> cards;\n\t\tcards.push_back({ 1, n });\n\n\t\tstd::cin >> m >> p >> q >> r;\n\t\tfor (long long i = 0; i < m; ++i) {\n\t\t\tlong long x, y;\n\t\t\tstd::cin >> x >> y;\n\t\t\t\n\t\t\tbool flag = false, which;\n\t\t\tdecltype(cards)::iterator sec1, sec2;\n\t\t\tfor (auto itr = cards.begin(); itr != cards.end(); ++itr) {\n\t\t\t\tif (itr->first <= x && x <= itr->second) {\n\t\t\t\t\tcards.insert(itr, { {itr->first, x}, {x + 1, itr->second} });\n\t\t\t\t\tsec1 = itr = cards.erase(itr);\n\t\t\t\t\t--itr;\n\t\t\t\t\tif (!flag)\n\t\t\t\t\t\t----sec1, which = false, flag = true;\n\t\t\t\t\telse\n\t\t\t\t\t\t--sec1, ++sec2;\n\t\t\t\t}\n\t\t\t\tif (itr->first <= y && y <= itr->second) {\n\t\t\t\t\tcards.insert(itr, { { itr->first, y },{ y + 1, itr->second } });\n\t\t\t\t\tsec2 = itr = cards.erase(itr);\n\t\t\t\t\t--itr;\n\t\t\t\t\tif (!flag)\n\t\t\t\t\t\t----sec2, which = true, flag = true;\n\t\t\t\t\telse\n\t\t\t\t\t\t--sec2, ++sec1;\n\t\t\t\t}\n\t\t\t}\n\n\t\t\tif (which) {\n\t\t\t\tcards.splice(cards.end(), cards, sec2, sec1);\n\t\t\t\tcards.splice(cards.end(), cards, cards.begin(), sec1);\n\t\t\t}\n\t\t\telse {\n\t\t\t\tcards.splice(cards.end(), cards, sec1, sec2);\n\t\t\t\tcards.splice(cards.end(), cards, cards.begin(), sec2);\n\t\t\t}\n\t\t}\n\n\t\tlong long count = 0, ans = 0;\n\t\tfor (auto&& rng : cards) {\n\t\t\tlong long rngSize = rng.second - rng.first + 1;\n\n\t\t\tcount += rngSize;\n\n\t\t\tif (rng.first > r)\n\t\t\t\tcontinue;\n\t\t\telse if (rng.first <= r && r < rng.second)\n\t\t\t\trngSize -= rng.second - r;\n\n\t\t\tif (count > q) {\n\t\t\t\tans += std::max(0ll, rngSize - (count - q));\n\t\t\t\tbreak;\n\t\t\t}\n\t\t\tif (count >= p)\n\t\t\t\tans += std::min(rngSize, count - p);\n\t\t}\n\n\t\tstd::cout << ans << std::endl;\n\t}\n}"
  },
  {
    "language": "C++",
    "code": "\n#include<iostream>\nusing namespace std;\nint cards,n,i,p,q,r,x[5000],y[5000],counter;\n  int numberStart[10001];\n  int numberFast[10001];\n  int numberEnd[10001];\n  int searchB[10001];\nint numberLong(int value){\n\treturn numberEnd[value]-numberStart[value]+1;\n}\n\n\nint searchD(int seed){\n\t\tint l=0;\n  for (int a=1;a<=counter+1;a++){\n\tif(seed>l+numberLong(searchB[a])){\n\tl+=numberLong(searchB[a]);\n\t}\n\telse{\n\t return numberFast[searchB[a]];\n\t}\n  }\n return -100;\n\t\n}\nint searchNumber(int value){\n\tint l=0;\n  for (int a=1;a<=counter+1;a++){\n\tif(value>l+numberLong(searchB[a])){\n\tl+=numberLong(searchB[a]);\n\t}\n\telse{\n\t return numberStart[searchB[a]]+value-l-1;\n\t}\n  }\n return -100;\n}\n\nvoid cut(int g){\n\tif(searchD(g)==searchD(g+1)){\n  //カットする場所が入ってる数列を求める\n\tint\tsearchNumberG=searchNumber(g);\n  int seachX=searchB[searchD(g)];\n  int seachXX=searchNumberG;\n//数列ができる範囲の後ろの番号FASTを変える\n     for(int j=1;j<=counter;j++){\n      if (numberFast[j]>=numberFast[seachX]+1){\n      numberFast[j]++;\n     }\n    }\n\n  //の数列の後ろに新しい数列を作る\n counter++;\n  numberFast[counter]=numberFast[seachX]+1;\n  numberStart[counter] =searchNumberG+1;\n  numberEnd[counter]=numberEnd[seachX];\n  //できた数列の前の数列の最後を調整する\n  numberEnd[seachX]=searchNumberG;\n \n\n  \n  for ( int a=1;a<=counter+1;a++){\n\t  searchB[numberFast[a]]=a;\n    }\n    }\n\n}\nvoid shuffle(int x,int y){\n\t\n\tint StartHead[10001];\n\tint  numberFastNew[10001];\n\t\n\tint longs=1;\n\tfor (int i=1;i<=counter;i++){\n\t\tStartHead[searchB[i]]=longs;\n\t\tlongs+=numberLong(searchB[i]);\n\t}\n\tint newCounter[3];\n\tfor(int i=0;i<3;i++){\n\t\tnewCounter[i]=0;\n\t}\n\tfor(int j=1;j<=counter;j++){\n\t\tif (StartHead[j]>y){\n\t\t\tnewCounter[0]++;\n\t\tnumberFastNew[j]=0;\n\t\t}\n\t\tif (StartHead[j]>x && StartHead[j]+numberLong(j)-1<=y){\n\t\t\tnewCounter[1]++;\n\t\tnumberFastNew[j]=1;\n\t\t}\n\t\tif (StartHead[j]+numberLong(j)-1<=x){\n\t\t\tnewCounter[2]++;\n\t\tnumberFastNew[j]=2;\n\t\t}\n\t}\n\t\n\tfor(int j=1;j<=counter;j++){\n\t\tswitch(numberFastNew[j]){\n\t\t\tcase 0:\n\t\t\t\tnumberFast[j]+=-newCounter[1]-newCounter[2];\n\t\t\t\tbreak;\n\t\t\tcase 1:\n\t\t\t\tnumberFast[j]+=newCounter[0]-newCounter[2];\n\t\t\t\tbreak;\n\t\t\tcase 2:\n\t\t\t\tnumberFast[j]+=newCounter[1]+newCounter[0];\n\t\t\t\tbreak;\n\t\t}\n\n\t}\n\t  for ( int a=1;a<=counter+1;a++){\n\t  searchB[numberFast[a]]=a;\n    }\n\n}\n\n\nint main(void)\n{\n\twhile(true){\n\tcards=0;\n\tn=0;\n\tcounter=0;\n\tfor (int i=0;i<10001;i++){\n   numberStart[i]=0;\n   numberFast[i]=0;\n   numberEnd[i]=0;\n   searchB[i]=0;\n\t}\n\tint points=0;\n  counter=1;\n  cin >> cards;\n  if (cards==0){\n\t  break;\n  }\n  numberStart[1]=1;\n  numberEnd[1]=cards;\n  numberFast[1]=1;\n  searchB[1]=1;\n  cin >> n;\n  cin >> p  >> q  >> r ;\n  for (i=1;i<=n;i++){\n    cin >> x[i] >> y[i];\n  }\n  for (i=1;i<=n;i++){\n     cut(x[i]);\n\t \n      cut(y[i]);\n\t  \n     shuffle(x[i],y[i]);\n  }\n\n  for(int j=p;j<=q;j++){\n\t  if(searchNumber(j)<=r){\n\t\t  points++;\n\t  }\n  }\n  cout << points << endl;\n\t}\n}"
  },
  {
    "language": "C++",
    "code": "#include <cstdio>\n#include <vector>\n#include <algorithm>\n\nusing namespace std;\n\ntypedef struct {\n    int begin;\n    int end;\n} Range;\n\ninline int length(Range r) {\n    return r.end - r.begin + 1;\n}\n\nvoid shuffle(vector<Range> &ranges, int x, int y) {\n    int count = 1;\n    int pos_x;\n    int pos_y;\n    vector<Range> tmp;\n    tmp.clear();\n\n    for (int i=0; i < ranges.size(); i++) {\n        int len = length(ranges[i]);\n\n        if (count + len > x) {\n             Range new_range;\n             new_range.end = ranges[i].end;\n\n             ranges[i].end = ranges[i].end - (count + len - x - 1);\n             if (count + len - 1 != x) {\n                 new_range.begin = ranges[i].end + 1;\n                 ranges.insert(ranges.begin() + i + 1, new_range);\n             }\n\n             pos_x = i+1;\n             break;\n        }\n\n        count += len;\n    }\n\n    count = 1;\n    for (int i=0; i < ranges.size(); i++) {\n        int len = length(ranges[i]);\n\n        if (count + len > y) {\n             Range new_range;\n             new_range.end = ranges[i].end;\n\n             ranges[i].end = ranges[i].end - (count + len - y - 1);\n             if (count + len - 1 != y) {\n                 new_range.begin = ranges[i].end + 1;\n                 ranges.insert(ranges.begin() + i + 1, new_range);\n             }\n\n             pos_y = i+1;\n             break;\n         }\n\n         count += len;\n     }\n\n     for (int i=pos_y; i < ranges.size(); i++) {\n         tmp.push_back(ranges[i]);\n     }\n\n     for (int i=pos_x; i < pos_y; i++) {\n         tmp.push_back(ranges[i]);\n     }\n\n     for (int i=0; i < pos_x; i++) {\n         tmp.push_back(ranges[i]);\n     }\n\n     ranges.swap(tmp);\n}\n\nint main() {\n    while (1) {\n        int n;\n        int m;\n        int p, q, r;\n        int count;\n        int num;\n        Range first_range;\n        vector<Range> ranges(1);\n    \n        scanf(\"%d\", &n);\n        if (n == 0) return 0;\n\n        scanf(\"%d\", &m);\n        scanf(\"%d %d %d\", &p, &q, &r);\n    \n        first_range.begin = 1;\n        first_range.end = n;\n        ranges[0] = first_range;\n    \n        for (int i=0; i<m; i++) {\n            int x, y;\n    \n            scanf(\"%d %d\", &x, &y);\n            shuffle(ranges, x, y);\n        }\n    \n        num = 0;\n        count = 1;\n        for (vector<Range>::iterator itr = ranges.begin(); itr != ranges.end(); itr++) {\n             int start;\n             int end;\n             int len = length(*itr);\n    \n             if (count > q) break;\n    \n             if (count + len > p) {\n                 end = itr->end;\n                 start = itr->begin;\n    \n                 if (count < p) {\n                     start += (count + len - p);\n                 } \n    \n                 if (count + len > q) {\n                     end -= (count + len - q - 1);\n                 }\n    \n                 if (start <= r) {\n                     if (end <= r) {\n                         num += end - start + 1 ;\n                     } else {\n                         num += r - start + 1;\n                     }\n                 }\n             }\n    \n             count += len;\n        }\n     \n        printf(\"%d\\n\", num);   \n    }\n}"
  },
  {
    "language": "C++",
    "code": "//確か、r以下とそれ以外の境界部分のインデックスをうごうごやっていた……気がする。\n//書いた当時のことを覚えていないので、誰か解読してください。\n\n#include <iostream>\n#include <algorithm>\n#include <vector>\nusing namespace std;\n\nint main(){\n\tint n, m, p, q, r, x, y;\n\tvector<int>::iterator itx, ity, it;\n\twhile( cin >> n >> m >> p >> q >> r ){\n\t\tvector<int> v1, v2;\n\t\tv1.push_back(0);\n\t\tv1.push_back(r);\n\t\t\n\t\tfor(int i = 0; i < m; ++i){\n\t\t\tcin >> x >> y;\n\t\t\titx = upper_bound(v1.begin(), v1.end(), x);\n\t\t\tity = upper_bound(v1.begin(), v1.end(), y);\n\t\t\t\n\t\t\tif( (ity - v1.begin()) % 2 == 0 ) v2.push_back(0);\n\t\t\tv2.push_back(0);\n\n\t\t\tfor(it = ity; it != v1.end(); ++it)\n\t\t\t\tv2.push_back(*it - y);\n\n\t\t\tif( (v1.end() - itx) % 2 != 0 ) v2.push_back(n-y);\n\t\t\tfor(it = itx; it != ity; ++it)\n\t\t\t\tv2.push_back(*it - x + n - y);\n\t\t\t\n\t\t\tit = v1.begin();\n\t\t\tif( (ity - v1.begin()) % 2 != 0 ) ++it;\n\t\t\tif( !it[1] ) it+=2;\t//重複排除\n\t\t\tif( *it + n - x == v2.back() ){\t//重複排除\n\t\t\t\t++it;\n\t\t\t\tv2.pop_back();\n\t\t\t}\n\t\t\tfor( ; it != itx; ++it)\n\t\t\t\tv2.push_back(*it + n - x);\n\t\t\t\n\t\t\tv1.swap(v2);\n\t\t\tv2.clear();\n\t\t}\n\t\tv1.insert( upper_bound(v1.begin(), v1.end(), p - 1), 2, p - 1);\n\t\tv1.insert( lower_bound(v1.begin(), v1.end(), q), q);\n\t\tv1.push_back(n);\n\t\tit = upper_bound(v1.begin(), v1.end(), p - 1);\n\t\tif( (it - v1.begin()) % 2 != 0) --it;\n\t\tfor(x = 0; *it < q; ++it){\n\t\t\tm = *it;\n\t\t\t++it;\n\t\t\tx += *it - m;\n\t\t}\n\t\t\n\t\tcout << x << endl;\n\t}\n}"
  },
  {
    "language": "C++",
    "code": "#include <iostream>\n#include <algorithm>\n#include <vector>\nusing namespace std;\n\nvoid loop(){while(1);}\n\nint main(){\n\tint n, m, p, q, r, x, y;\n\tvector<int>::iterator itx, ity, it;\n\n\twhile( cin >> n >> m >> p >> q >> r ){\n\t\tvector<int> v1, v2;\n\t\tv1.push_back(0);\n\t\tv1.push_back(r);\n\t\t\n\t\tfor(int i = 0; i < m; ++i){\n\t\t\tcin >> x >> y;\n\t\t\titx = upper_bound(v1.begin(), v1.end(), x);\n\t\t\tity = upper_bound(v1.begin(), v1.end(), y);\nif(itx>ity)loop();\n\t\t\tif( (ity - v1.begin()) % 2 == 0 ){\tv2.push_back(0);\t}\n\t\t\tv2.push_back(0);\n\n\t\t\tfor(it = ity; it != v1.end(); ++it){\n\t\t\t\tv2.push_back(*it - y);\n\t\t\t}\n\n\t\t\tif( (v1.end() - itx) % 2 != 0 ){\tv2.push_back(n - y);\t}\n\t\t\tfor(it = itx; it != ity; ++it){\n\t\t\t\tv2.push_back(*it - x + n - y);\n\t\t\t}\n\t\t\t\n\t\t\tit = v1.begin();\n\t\t\tif( (ity - v1.begin()) % 2 != 0 ){\t++it;\t}\nif(it+1>=v1.end())loop();\n\t\t\tif( !it[1] ){\n\t\t\t\t it += 2;\t//重複排除\n\t\t\t}\n\t\t\tif( *it + n - x == v2.back() ){\t//重複排除\n\t\t\t\t++it;\n\t\t\t\tv2.pop_back();\n\t\t\t}\nif(it>itx)loop();\n\t\t\tfor( ; it != itx; ++it){\n\t\t\t\tv2.push_back(*it + n - x);\n\t\t\t}\n\n\t\t\tv1.swap(v2);\n\t\t\tv2.clear();\n\t\t}\n\n\t\tv1.insert( upper_bound(v1.begin(), v1.end(), p - 1), 2, p - 1);\n\t\tv1.insert( lower_bound(v1.begin(), v1.end(), q), q);\n\t\tv1.push_back(n);\n\n\t\tit = upper_bound(v1.begin(), v1.end(), p - 1);\n\t\tif( (it - v1.begin()) % 2 != 0) --it;\n\n\t\tint ans = 0;\n\t\tfor( ; *it < q; ++it){\n\t\t\tint prev = *it;\n\t\t\t++it;\n\t\t\tans += *it - prev;\n\t\t}\n\t\t\n\t\tcout << ans << '\\n';\n\t}\n}"
  },
  {
    "language": "C++",
    "code": "#include <stdio.h>\n#include <cmath>\n#include <algorithm>\n#include <cfloat>\n#include <stack>\n#include <queue>\n#include <vector>\n#include <string>\n#include <iostream>\ntypedef long long int ll;\ntypedef unsigned long long int ull;\n#define BIG_NUM 2000000000\n#define MOD 1000000007\n#define EPS 0.000000001\nusing namespace std;\n\nstruct Data{\n\tData(int arg_left_index,int arg_right_index){\n\t\tleft_index = arg_left_index;\n\t\tright_index = arg_right_index;\n\t}\n\tint left_index,right_index;\n};\n\nstruct Info{\n\tint length;\n\tvector<Data> children;\n};\n\n\nint N,M,P,Q,R;\n\nvoid func(){\n\n\tscanf(\"%d\",&M);\n\n\tscanf(\"%d %d %d\",&P,&Q,&R);\n\n\tInfo info[3],work[3];\n\n\tint a,b;\n\n\tscanf(\"%d %d\",&a,&b);\n\n\tinfo[0].children.push_back(Data(b+1,N));\n\tinfo[1].children.push_back(Data(a+1,b));\n\tinfo[2].children.push_back(Data(1,a));\n\n\tfor(int i = 0; i < 3; i++){\n\t\tinfo[i].length = info[i].children[0].right_index-info[i].children[0].left_index+1;\n\t}\n\n\tint tmp,a_last_info,a_last_child;\n\n\tfor(int loop = 1; loop <= M; loop++){\n\t\tif(loop < M){\n\t\t\tscanf(\"%d %d\",&a,&b);\n\t\t}else{\n\t\t\ta = P-1;\n\t\t\tb = Q;\n\t\t}\n\n\t\tif(a <= info[0].length){\n\n\t\t\ttmp = 0;\n\t\t\tfor(int i = 0; i < info[0].children.size(); i++){\n\t\t\t\tif(tmp + info[0].children[i].right_index-info[0].children[i].left_index+1 < a){\n\t\t\t\t\ttmp += info[0].children[i].right_index-info[0].children[i].left_index+1;\n\t\t\t\t\twork[0].children.push_back(info[0].children[i]);\n\n\t\t\t\t}else{\n\t\t\t\t\tif(tmp + info[0].children[i].right_index-info[0].children[i].left_index+1 == a){\n\t\t\t\t\t\twork[0].children.push_back(info[0].children[i]);\n\t\t\t\t\t\ta_last_child = i;\n\t\t\t\t\t}else{\n\t\t\t\t\t\twork[0].children.push_back(Data(info[0].children[i].left_index,info[0].children[i].left_index+(a-tmp)-1));\n\t\t\t\t\t\tinfo[0].children[i].left_index += (a-tmp);\n\t\t\t\t\t\ta_last_child = i-1;\n\t\t\t\t\t}\n\t\t\t\t\tbreak;\n\t\t\t\t}\n\t\t\t}\n\n\t\t\ta_last_info = 0;\n\n\t\t}else if(a <= info[0].length+info[1].length){\n\n\t\t\tfor(int i = 0; i < info[0].children.size(); i++){\n\t\t\t\twork[0].children.push_back(info[0].children[i]);\n\t\t\t}\n\t\t\ttmp = info[0].length;\n\n\t\t\tfor(int i = 0; i < info[1].children.size(); i++){\n\t\t\t\tif(tmp + info[1].children[i].right_index-info[1].children[i].left_index+1 < a){\n\t\t\t\t\ttmp += info[1].children[i].right_index-info[1].children[i].left_index+1;\n\t\t\t\t\twork[0].children.push_back(info[1].children[i]);\n\n\t\t\t\t}else{\n\n\t\t\t\t\tif(tmp + info[1].children[i].right_index-info[1].children[i].left_index+1 == a){\n\t\t\t\t\t\twork[0].children.push_back(info[1].children[i]);\n\t\t\t\t\t\ta_last_child = i;\n\t\t\t\t\t}else{\n\t\t\t\t\t\twork[0].children.push_back(Data(info[1].children[i].left_index,info[1].children[i].left_index+(a-tmp)-1));\n\t\t\t\t\t\tinfo[1].children[i].left_index += (a-tmp);\n\t\t\t\t\t\ta_last_child = i-1;\n\t\t\t\t\t}\n\t\t\t\t\tbreak;\n\t\t\t\t}\n\t\t\t}\n\n\t\t\ta_last_info = 1;\n\n\t\t}else{\n\t\t\tfor(int i = 0; i < info[0].children.size(); i++){\n\t\t\t\twork[0].children.push_back(info[0].children[i]);\n\t\t\t}\n\n\t\t\tfor(int i = 0; i < info[1].children.size(); i++){\n\t\t\t\twork[0].children.push_back(info[1].children[i]);\n\t\t\t}\n\t\t\ttmp = info[0].length + info[1].length;\n\n\t\t\tfor(int i = 0; i < info[2].children.size(); i++){\n\t\t\t\tif(tmp + info[2].children[i].right_index-info[2].children[i].left_index+1 < a){\n\t\t\t\t\ttmp += info[2].children[i].right_index-info[2].children[i].left_index+1;\n\t\t\t\t\twork[0].children.push_back(info[2].children[i]);\n\n\t\t\t\t}else{\n\t\t\t\t\tif(tmp + info[2].children[i].right_index-info[2].children[i].left_index+1 == a){\n\t\t\t\t\t\twork[0].children.push_back(info[2].children[i]);\n\t\t\t\t\t\ta_last_child = i;\n\t\t\t\t\t}else{\n\t\t\t\t\t\twork[0].children.push_back(Data(info[2].children[i].left_index,info[2].children[i].left_index+(a-tmp)-1));\n\t\t\t\t\t\tinfo[2].children[i].left_index += (a-tmp);\n\t\t\t\t\t\ta_last_child = i-1;\n\t\t\t\t\t}\n\t\t\t\t\tbreak;\n\t\t\t\t}\n\t\t\t}\n\t\t\ta_last_info = 2;\n\t\t}\n\n\n\n\t\tif(b <= info[0].length){\n\n\t\t\ttmp = 0;\n\t\t\tfor(int i = 0; i <  work[0].children.size(); i++){\n\t\t\t\ttmp += work[0].children[i].right_index-work[0].children[i].left_index+1;\n\t\t\t}\n\n\t\t\tfor(int i = a_last_child+1; i < info[0].children.size(); i++){\n\t\t\t\tif(tmp + info[0].children[i].right_index-info[0].children[i].left_index+1 < b){\n\t\t\t\t\ttmp += info[0].children[i].right_index-info[0].children[i].left_index+1;\n\t\t\t\t}else{\n\n\t\t\t\t\tif(tmp + info[0].children[i].right_index-info[0].children[i].left_index+1 == b){\n\t\t\t\t\t\tfor(int k = a_last_child+1; k <= i; k++){\n\t\t\t\t\t\t\twork[1].children.push_back(info[0].children[k]);\n\t\t\t\t\t\t}\n\t\t\t\t\t\tfor(int k = i+1; k < info[0].children.size(); k++){\n\t\t\t\t\t\t\twork[2].children.push_back(info[0].children[k]);\n\t\t\t\t\t\t}\n\n\t\t\t\t\t}else{\n\t\t\t\t\t\tfor(int k = a_last_child+1; k <= i-1; k++){\n\t\t\t\t\t\t\twork[1].children.push_back(info[0].children[k]);\n\t\t\t\t\t\t}\n\t\t\t\t\t\twork[1].children.push_back(Data(info[0].children[i].left_index,info[0].children[i].left_index+(b-tmp)-1));\n\t\t\t\t\t\twork[2].children.push_back(Data(info[0].children[i].left_index+(b-tmp),info[0].children[i].right_index));\n\t\t\t\t\t\tfor(int k = i+1; k < info[0].children.size(); k++){\n\t\t\t\t\t\t\twork[2].children.push_back(info[0].children[k]);\n\t\t\t\t\t\t}\n\t\t\t\t\t}\n\n\t\t\t\t\tfor(int k = 0; k < info[1].children.size(); k++){\n\t\t\t\t\t\twork[2].children.push_back(info[1].children[k]);\n\t\t\t\t\t}\n\t\t\t\t\tfor(int k = 0; k < info[2].children.size(); k++){\n\t\t\t\t\t\twork[2].children.push_back(info[2].children[k]);\n\t\t\t\t\t}\n\t\t\t\t\tbreak;\n\t\t\t\t}\n\t\t\t}\n\n\t\t}else if(b <= info[0].length+info[1].length){\n\n\t\t\tif(a_last_info == 0){\n\n\t\t\t\tfor(int i = a_last_child+1;i < info[0].children.size(); i++){\n\t\t\t\t\twork[1].children.push_back(info[0].children[i]);\n\t\t\t\t}\n\t\t\t\ta_last_child = -1;\n\t\t\t\ttmp = info[0].length;\n\t\t\t}else{\n\t\t\t\ttmp = 0;\n\t\t\t\tfor(int i = 0; i < work[0].children.size(); i++){\n\t\t\t\t\ttmp += work[0].children[i].right_index-work[0].children[i].left_index+1;\n\t\t\t\t}\n\t\t\t}\n\n\t\t\tfor(int i = a_last_child+1; i < info[1].children.size(); i++){\n\t\t\t\tif(tmp + info[1].children[i].right_index-info[1].children[i].left_index + 1 < b){\n\t\t\t\t\ttmp += info[1].children[i].right_index-info[1].children[i].left_index+1;\n\t\t\t\t}else{\n\t\t\t\t\tif(tmp + info[1].children[i].right_index-info[1].children[i].left_index + 1 == b){\n\t\t\t\t\t\tfor(int k = a_last_child+1; k <= i; k++){\n\t\t\t\t\t\t\twork[1].children.push_back(info[1].children[k]);\n\t\t\t\t\t\t\t}\n\t\t\t\t\t\t\tfor(int k = i+1; k < info[1].children.size(); k++){\n\t\t\t\t\t\t\t\twork[2].children.push_back(info[1].children[k]);\n\t\t\t\t\t\t\t}\n\n\t\t\t\t\t}else{\n\t\t\t\t\t\tfor(int k = a_last_child+1; k <= i-1; k++){\n\t\t\t\t\t\t\twork[1].children.push_back(info[1].children[k]);\n\t\t\t\t\t\t}\n\t\t\t\t\t\twork[1].children.push_back(Data(info[1].children[i].left_index,info[1].children[i].left_index+(b-tmp)-1));\n\t\t\t\t\t\twork[2].children.push_back(Data(info[1].children[i].left_index+(b-tmp),info[1].children[i].right_index));\n\t\t\t\t\t\tfor(int k = i+1; k < info[1].children.size(); k++){\n\t\t\t\t\t\t\twork[2].children.push_back(info[1].children[k]);\n\t\t\t\t\t\t}\n\t\t\t\t\t}\n\t\t\t\t\tfor(int k = 0; k < info[2].children.size(); k++){\n\t\t\t\t\t\twork[2].children.push_back(info[2].children[k]);\n\t\t\t\t\t}\n\t\t\t\t\tbreak;\n\t\t\t\t}\n\t\t\t}\n\n\t\t}else{\n\n\t\t\tif(a_last_info == 0){\n\n\t\t\t\tfor(int i = a_last_child+1; i < info[0].children.size(); i++){\n\t\t\t\t\twork[1].children.push_back(info[0].children[i]);\n\t\t\t\t}\n\t\t\t\tfor(int i = 0; i < info[1].children.size(); i++){\n\t\t\t\t\twork[1].children.push_back(info[1].children[i]);\n\t\t\t\t}\n\t\t\t\ta_last_child = -1;\n\t\t\t\ttmp = info[0].length+info[1].length;\n\t\t\t}else if(a_last_info == 1){\n\n\t\t\t\tfor(int i = a_last_child+1; i < info[1].children.size(); i++){\n\t\t\t\t\twork[1].children.push_back(info[1].children[i]);\n\t\t\t\t}\n\t\t\t\ta_last_child = -1;\n\t\t\t\ttmp = info[0].length+info[1].length;\n\t\t\t}else{\n\t\t\t\ttmp = 0;\n\t\t\t\tfor(int i = 0; i < work[0].children.size(); i++){\n\t\t\t\t\ttmp += work[0].children[i].right_index-work[0].children[i].left_index+1;\n\t\t\t\t}\n\t\t\t}\n\n\t\t\tfor(int i = a_last_child+1; i < info[2].children.size(); i++){\n\t\t\t\tif(tmp + info[2].children[i].right_index-info[2].children[i].left_index + 1 < b){\n\t\t\t\t\ttmp += info[2].children[i].right_index-info[2].children[i].left_index+1;\n\t\t\t\t}else{\n\n\t\t\t\t\tif(tmp + info[2].children[i].right_index-info[2].children[i].left_index + 1 == b){\n\t\t\t\t\t\tfor(int k = a_last_child+1; k <= i; k++){\n\t\t\t\t\t\t\twork[1].children.push_back(info[2].children[k]);\n\t\t\t\t\t\t}\n\t\t\t\t\t\tfor(int k = i+1; k < info[2].children.size(); k++){\n\t\t\t\t\t\t\twork[2].children.push_back(info[2].children[k]);\n\t\t\t\t\t\t}\n\n\t\t\t\t\t}else{\n\t\t\t\t\t\tfor(int k = a_last_child+1; k <= i-1; k++){\n\t\t\t\t\t\t\twork[1].children.push_back(info[2].children[k]);\n\t\t\t\t\t\t}\n\t\t\t\t\t\twork[1].children.push_back(Data(info[2].children[i].left_index,info[2].children[i].left_index+(b-tmp)-1));\n\t\t\t\t\t\twork[2].children.push_back(Data(info[2].children[i].left_index+(b-tmp),info[2].children[i].right_index));\n\t\t\t\t\t\tfor(int k = i+1; k < info[2].children.size(); k++){\n\t\t\t\t\t\t\twork[2].children.push_back(info[2].children[k]);\n\t\t\t\t\t\t}\n\t\t\t\t\t}\n\t\t\t\t\tbreak;\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\n\t\tfor(int i = 0; i < 3; i++){\n\t\t\tinfo[i].children.clear();\n\t\t}\n\n\t\tfor(int i = 0; i < work[2].children.size(); i++){\n\t\t\tinfo[0].children.push_back(work[2].children[i]);\n\t\t}\n\n\t\tfor(int i = 0; i < work[1].children.size(); i++){\n\t\t\tinfo[1].children.push_back(work[1].children[i]);\n\t\t}\n\n\t\tfor(int i = 0; i < work[0].children.size(); i++){\n\t\t\tinfo[2].children.push_back(work[0].children[i]);\n\t\t}\n\n\t\tfor(int i = 0; i < 3; i++){\n\t\t\ttmp = 0;\n\t\t\tfor(int k = 0; k < info[i].children.size(); k++){\n\t\t\t\ttmp += info[i].children[k].right_index-info[i].children[k].left_index+1;\n\t\t\t}\n\t\t\tinfo[i].length = tmp;\n\t\t}\n\n\t\tfor(int i = 0; i < 3; i++){\n\t\t\twork[i].children.clear();\n\t\t}\n\n\t}\n\n\tint ans = 0;\n\n\tfor(int i = 0; i < info[1].children.size(); i++){\n\t\tif(info[1].children[i].left_index > R)continue;\n\n\t\tif(info[1].children[i].right_index <= R){\n\t\t\tans += info[1].children[i].right_index-info[1].children[i].left_index+1;\n\t\t}else{\n\t\t\tans += R-info[1].children[i].left_index+1;\n\t\t}\n\t}\n\n\tprintf(\"%d\\n\",ans);\n\n}\n\n\nint main(){\n\n\twhile(true){\n\t\tscanf(\"%d\",&N);\n\t\tif(N == 0)break;\n\n\t\tfunc();\n\t}\n\n\treturn 0;\n}"
  },
  {
    "language": "C++",
    "code": "//  4???27??\\  ????????????0535 ; ?????£?????????\n// http://judge.u-aizu.ac.jp/onlinejudge/description.jsp?id=0536\n\n#include <iostream>\n#define NUM 1000\nusing namespace std;\n\nint main(){\n\n  int n;//?????????????????°\n  int m;//?????£??????????????°\n  int p,q;//p ???????????? q ?????????????????????\n  int r;// r??\\?????????????????????????????????\n  register int x[5000],y[5000];//????????????????????´???\n  register int card[NUM];\n  int i;\n  int A[NUM];\n  int B[NUM];\n  int C[NUM];\n\n  do{\n    int j = 0;\n    int count = 1;\n    int step = 1;\n    int red = 1;\n    int blue = 1;\n    int green = 0;\n\n    cin >> n;\n    cin >> m;\n    cin >> p >> q >> r;\n\n    if (!n){\n      break;\n    }\n\n    for (i=0; i < m; i++){\n      cin >> x[i] >> y[i];\n    }\n\n    while (j < m){\n\n      for (i=1; i <= n; i++ ){//??°?????£??\\\n        card[i] = i;\n      }\n\n      for (i=1 ; i <= x[j] ;i++ ){//????????????1~X???????????§\n        A[i] = card[i];\n      }\n\n      while (i <= y[j]){//????????????X+1~Y???????????§\n        B[count] = card[i];\n        i++;\n        count++;\n      }\n\n      while (i <= n){//????????????Y+1~n???????????§\n        C[step] = card[i];\n        i++;\n        step++;\n      }\n\n      for (i=1; i <= (n - y[j]); i++ ){//C?????°?????£??\\\n        card[i] = C[i];\n      }\n\n      while (red <= count){//B?????°?????£??\\\n        card[i] = B[red];\n        i++;\n        red++;\n      }\n\n      while (blue <= step){//A?????°?????£??\\\n        card[i] = A[blue];\n        i++;\n        blue++;\n      }\n      j++;\n    }\n\n    for (i=p; i <= q; i++){\n      if (card[i] <= r){\n        green++;\n      }\n    }\n\n    cout << green << endl;\n  } while (n);\n\n  return 0;\n\n}"
  },
  {
    "language": "C++",
    "code": "#include <iostream>\n#include <vector>\n\nbool solve() {\n    int n;\n    std::cin >> n;\n    if (n == 0) return false;\n\n    std::vector<std::pair<int, int>> segs{{0, n}};\n\n    int q, l, r, m;\n    std::cin >> q >> l >> r >> m;\n\n    std::vector<std::pair<int, int>> front, mid;\n    while (q--) {\n        int x, y;\n        std::cin >> x >> y;\n        y -= x;\n\n        int it = 0;\n        while (x > 0) {\n            auto& p = segs[it];\n            int len = p.second - p.first;\n\n            if (len <= x) {\n                x -= len;\n                front.push_back(p);\n                ++it;\n            } else {\n                front.emplace_back(p.first, p.first + x);\n                p.first += x;\n                x = 0;\n            }\n        }\n\n        while (y > 0) {\n            auto& p = segs[it];\n            int len = p.second - p.first;\n\n            if (len <= y) {\n                y -= len;\n                mid.push_back(p);\n                ++it;\n            } else {\n                mid.emplace_back(p.first, p.first + y);\n                p.first += y;\n                y = 0;\n            }\n        }\n\n        segs.erase(segs.begin(), segs.begin() + it);\n        std::copy(mid.begin(), mid.end(), std::back_inserter(segs));\n        std::copy(front.begin(), front.end(), std::back_inserter(segs));\n\n        mid.clear();\n        front.clear();\n    }\n\n    int it = 0;\n    --l, --m;\n    r -= l;\n\n    while (l > 0) {\n        auto& p = segs[it];\n        int len = p.second - p.first;\n\n        if (len <= l) {\n            l -= len;\n            ++it;\n        } else {\n            p.first += l;\n            l = 0;\n        }\n    }\n\n    while (r > 0) {\n        auto& p = segs[it];\n        int len = p.second - p.first;\n\n        if (len <= r) {\n            r -= len;\n            mid.push_back(p);\n            ++it;\n        } else {\n            mid.emplace_back(p.first, p.first + r);\n            p.first += r;\n            r = 0;\n        }\n    }\n\n    int ans = 0;\n    for (auto p : mid) {\n        p.second = std::min(p.second, m + 1);\n        ans += std::max(0, p.second - p.first);\n    }\n    std::cout << ans << \"\\n\";\n\n    return true;\n}\n\nint main() {\n    std::cin.tie(nullptr);\n    std::ios::sync_with_stdio(false);\n\n    while (solve()) {}\n\n    return 0;\n}\n\n"
  },
  {
    "language": "C++",
    "code": "#include<iostream>\n#include<cstdio>\n#include<vector>\n#include<queue>\n#include<algorithm>\n#include<functional>\n#include<cstring>\n#include<iterator>\nusing namespace std;\n\nconst int INF = 1e9;\n\nint main() {\n\tint n, m, pp, q, r;\n\n\twhile (cin >> n&&n){\t\n\t\tint save = -1, ans = 0;\n\t\tvector<int>vep, vep2, vep3;\n\t\tvep.push_back(1);\n\t\tvep.push_back(n);\n\t    vector<int> vec, vec2, vec3;\n\t\tvec.push_back(1);\n\t\tvec.push_back(n);\n\t\tcin >> m >> pp >> q >> r;\n\t\tfor (int i = 0; i < m; i++) {\n\t\t\tint x, y, p, p2;\n\t\t\tscanf(\"%d%d\", &x, &y);\n\t\t\tp = lower_bound(vec.begin(), vec.end(), x) - vec.begin();\n\t\t\tif (vec[p] != x) {\n\t\t\t\tvec.insert(vec.begin() + p, x);\n\t\t\t\tvep.insert(vep.begin() + p, vec[p] - vec[p - 1] + vep[p - 1]);\n\t\t\t}\n\t\t\tif (vec[p] + 1 != vec[p + 1]) {\n\t\t\t\tvec.insert(vec.begin() + p + 1, x + 1);\n\t\t\t\tvep.insert(vep.begin() + p + 1, vep[p] + 1);\n\t\t\t}\n\t\t\tp2 = lower_bound(vec.begin(), vec.end(), y) - vec.begin();\n\t\t\tif (vec[p2] != y) {\n\t\t\t\tvec.insert(vec.begin() + p2, y);\n\t\t\t\tvep.insert(vep.begin() + p2, vec[p2] - vec[p2 - 1] + vep[p2 - 1]);\n\t\t\t}\n\t\t\tif (vec[p2] + 1 != vec[p2 + 1]) {\n\t\t\t\tvec.insert(vec.begin() + p2 + 1, y + 1);\n\t\t\t\tvep.insert(vep.begin() + p2 + 1, vep[p2] + 1);\n\t\t\t}\n\t\t\tfor (int j = p2 + 1; j < vec.size(); j++) {\n\t\t\t\tvec2.push_back(vec[j] - vec[p2 + 1] + 1);\n\t\t\t\tvep2.push_back(vep[j]);\n\t\t\t}\n\t\t\tint size = vec2[vec2.size() - 1];\n\t\t\tfor (int j = p + 1; j < p2 + 1; j++) {\n\t\t\t\tvec2.push_back(vec[j] - vec[p + 1] + 1 + size);\n\t\t\t\tvep2.push_back(vep[j]);\n\t\t\t}\n\t\t\tsize = vec2[vec2.size() - 1];\n\t\t\tfor (int j = 0; j < p + 1; j++) {\n\t\t\t\tvec2.push_back(vec[j] - vec[0] + 1+size);\n\t\t\t\tvep2.push_back(vep[j]);\n\t\t\t}\n\t\t\tvec3 = vec;\n\t\t\tvep3 = vep;\n\t\t\tvec = vec2;\n\t\t\tvep = vep2;\n\t\t\tvec2 = vec3;\n\t\t\tvep2 = vep3;\n\t\t\tvec2.clear();\n\t\t\tvep2.clear();\n\t\t}\n\t\tint p, p2;\n\t\tp = lower_bound(vec.begin(), vec.end(), pp) - vec.begin();\n\t\t\n\t\tif (vec[p] != pp) {\n\t\t\tvec.insert(vec.begin() + p, pp);\n\t\t\tvep.insert(vep.begin() + p, vec[p] - vec[p - 1] + vep[p - 1]);\n\t\t}\n\t\tif (vec[p] + 1 != vec[p + 1]) {\n\t\t\tvec.insert(vec.begin() + p + 1, pp + 1);\n\t\t\tvep.insert(vep.begin() + p + 1, vep[p] + 1);\n\t\t}\n\t\tp2 = lower_bound(vec.begin(), vec.end(), q) - vec.begin();\n\t\tif (vec[p2] != q) {\n\t\t\tvec.insert(vec.begin() + p2, q);\n\t\t\tvep.insert(vep.begin() + p2, vec[p2] - vec[p2 - 1] + vep[p2 - 1]);\n\t\t}\n\t\tif (vec[p2] + 1 != vec[p2 + 1]) {\n\t\t\tvec.insert(vec.begin() + p2 + 1, q + 1);\n\t\t\tvep.insert(vep.begin() + p2 + 1, vep[p2] + 1);\n\t\t}\n\t\tfor (int i = p; i <= p2; i++) {\n\t\t\tif (i + 1<=p2 && vep[i + 1] - vep[i] == vec[i + 1] - vec[i]) {\n\t\t\t\tif (vep[i + 1] <= r) {\n\t\t\t\t\tans += vep[i + 1] - vep[i];\n\t\t\t\t\tif (save != vep[i])\n\t\t\t\t\t\tans++;\n\t\t\t\t\tsave = vep[i + 1];\n\t\t\t\t}\n\t\t\t\tif (vep[i] <= r&&vep[i + 1] > r) {\n\t\t\t\t\tans += r - vep[i];\n\t\t\t\t\tif (save != vep[i])\n\t\t\t\t\t\tans++;\n\t\t\t\t\tsave = q;\n\t\t\t\t}\n\t\t\t}\n\t\t\telse{\n\t\t\t\tif (vep[i] <= r&&save != vep[i]) {\n\t\t\t\t\tans++;\n\t\t\t\t\tsave = vep[i];\n\t\t\t\t}\n\t\t\t}\n\t}\n\t\tcout << ans << endl;\n\t}\n}"
  },
  {
    "language": "C++",
    "code": "#include <iostream>\n#include <vector>\n#include <deque>\n\nusing namespace std;\n\n#define fst first\n#define scd second\n#define PB push_back\n#define omajinai ios::sync_with_stdio(false);cin.tie(0)\n#define rep(i,x) for(int i=0;i<(int)(x);++i)\n\nusing pii = pair<int, int>;\nusing vpii = vector<pii>;\n\nint n, m, p, q, r;\n\nint calc(pii seg, int n)\n{\n\tint len = seg.scd - seg.fst + 1;\n\n\tif (n < p && p <= n + len - 1) {\n\t\tint a = (n + len - 1) - p;\n\n\t\treturn calc(pii(seg.scd - a, seg.scd), p);\n\t}\n\n\tif (p <= n && n + len - 1 <= q) {\n\t\treturn max(min(r - seg.fst + 1, len), 0);\n\t}\n\n\tif (n <= q && q < n + len - 1) {\n\t\tint a = q - n;\n\n\t\treturn calc(pii(seg.fst, seg.fst + a), n);\n\t}\n\n\treturn 0;\n}\n\nint main()\n{\n\tomajinai;\n\n\twhile (cin >> n >> m >> p >> q >> r, n) {\n\t\tdeque<pii> dat;\n\n\t\tdat.push_back(pii(1, n));\n\n\t\trep(_, m) {\n\t\t\tint x, y; cin >> x >> y;\n\n\t\t\tint sum = 0;\n\n\t\t\tvpii Top, Mid, Bottom;\n\n\t\t\t// Top?????????\n\t\t\twhile (true) {\n\t\t\t\tpii a = dat.front();\n\n\t\t\t\tint v = a.scd - a.fst + 1;\n\n\t\t\t\tif (sum + v >= x) {\n\t\t\t\t\tint dif = x - sum-1;\n\n\t\t\t\t\tsum += dif + 1;\n\n\t\t\t\t\tTop.push_back(pii(a.fst, a.fst + dif));\n\n\t\t\t\t\tdat.pop_front();\n\n\t\t\t\t\tif (a.fst + dif + 1 <= a.scd) dat.push_front(pii(a.fst + dif + 1, a.scd));\n\n\t\t\t\t\tbreak;\n\t\t\t\t} else {\n\t\t\t\t\tTop.PB(a);\n\t\t\t\t\tsum += v;\n\t\t\t\t}\n\n\t\t\t\tdat.pop_front();\n\t\t\t}\n\n\t\t\t// Mid?????????\n\t\t\twhile (true) {\n\t\t\t\tpii a = dat.front();\n\n\t\t\t\tint v = a.scd - a.fst + 1;\n\n\t\t\t\tif (sum + v >= y) {\n\t\t\t\t\tint dif = y - sum-1;\n\n\t\t\t\t\tsum += dif + 1;\n\n\t\t\t\t\tMid.push_back(pii(a.fst, a.fst + dif));\n\n\t\t\t\t\tdat.pop_front();\n\n\t\t\t\t\tif (a.fst + dif + 1 <= a.scd) dat.push_front(pii(a.fst + dif + 1, a.scd));\n\n\t\t\t\t\tbreak;\n\t\t\t\t} else {\n\t\t\t\t\tMid.PB(a);\n\t\t\t\t\tsum += v;\n\t\t\t\t}\n\t\t\t\tdat.pop_front();\n\t\t\t}\n\n\t\t\t// Bottom?????????\n\t\t\twhile (true) {\n\t\t\t\tpii a = dat.front();\n\n\t\t\t\tint v = a.scd - a.fst + 1;\n\n\t\t\t\tif (sum + v == n) {\n\t\t\t\t\tsum += v;\n\n\t\t\t\t\tBottom.push_back(pii(a.fst, a.scd));\n\n\t\t\t\t\tdat.pop_front();\n\n\t\t\t\t\tbreak;\n\t\t\t\t} else {\n\t\t\t\t\tBottom.PB(a);\n\t\t\t\t\tsum += v;\n\t\t\t\t}\n\n\t\t\t\tdat.pop_front();\n\t\t\t}\n\n\t\t\trep(i, Bottom.size()) dat.push_back(Bottom[i]);\n\t\t\trep(i, Mid.size()) dat.push_back(Mid[i]);\n\t\t\trep(i, Top.size()) dat.push_back(Top[i]);\n\t\t}\n\n\t\tint sum = 1;\n\t\tint ans = 0;\n\n        rep(i, dat.size()) {\n            pii a = dat[i];\n\t\t\tans += calc(a, sum);\n\t\t\tsum += a.scd - a.fst + 1;\n\t\t}\n\n\t\tcout << ans << endl;\n\t}\n}"
  },
  {
    "language": "C++",
    "code": "#include <tuple>\n#include <vector>\n#include <iostream>\n#include <algorithm>\n\n#pragma warning(disable : 4996)\n\nusing namespace std;\n\nint n, m, p, q, c, r1, r2;\n\nvector<tuple<int, int, int> > dat; // (l, r, lnum)\n\nvoid divide(int pos)\n{\n\tvector<tuple<int, int, int> > dat1;\n\n\tfor (int i = 0; i < dat.size(); i++)\n\t{\n\t\tint l = get<0>(dat[i]);\n\t\tint r = get<1>(dat[i]);\n\t\tint t = get<2>(dat[i]);\n\n\t\tif (l < pos && pos < r)\n\t\t{\n\t\t\tdat1.push_back(make_tuple(l, pos, t));\n\t\t\tdat1.push_back(make_tuple(pos, r, t + pos - l));\n\t\t}\n\t\telse\n\t\t{\n\t\t\tdat1.push_back(make_tuple(l, r, t));\n\t\t}\n\t}\n\n\tdat = dat1;\n}\n\nint position(int num)\n{\n\tfor (int i = 0; i < dat.size(); i++)\n\t{\n\t\tif (get<0>(dat[i]) <= num && num < get<1>(dat[i]))\n\t\t{\n\t\t\treturn i;\n\t\t}\n\t}\n\n\treturn -1;\n}\n\nvoid shuffle(int a, int b)\n{\n\tdivide(a);\n\tdivide(b);\n\n\tint l = position(a);\n\tint r = position(b);\n\n\tvector<tuple<int, int, int> > dat1;\n\n\tint pos = 0;\n\n\tfor (int i = r; i < dat.size(); i++)\n\t{\n\t\tdat1.push_back(make_tuple(pos, pos - get<0>(dat[i]) + get<1>(dat[i]), get<2>(dat[i]))); pos += get<1>(dat[i]) - get<0>(dat[i]);\n\t}\n\n\tfor (int i = l; i < r; i++)\n\t{\n\t\tdat1.push_back(make_tuple(pos, pos - get<0>(dat[i]) + get<1>(dat[i]), get<2>(dat[i]))); pos += get<1>(dat[i]) - get<0>(dat[i]);\n\t}\n\n\tfor (int i = 0; i < l; i++)\n\t{\n\t\tdat1.push_back(make_tuple(pos, pos - get<0>(dat[i]) + get<1>(dat[i]), get<2>(dat[i]))); pos += get<1>(dat[i]) - get<0>(dat[i]);\n\t}\n\n\tdat = dat1;\n}\n\nint main()\n{\n\twhile(true)\n\t{\n\t\tscanf(\"%d\", &n); if (n == 0) { break; }\n\t\tscanf(\"%d\", &m);\n\t\tscanf(\"%d\", &p); p--;\n\t\tscanf(\"%d\", &q); q--;\n\t\tscanf(\"%d\", &c);\n\n\t\tdat.clear();\n\n\t\tdat.push_back(make_tuple(0, n, 1));\n\n\t\tfor (int i = 0; i < m; i++)\n\t\t{\n\t\t\tscanf(\"%d\", &r1);\n\t\t\tscanf(\"%d\", &r2);\n\n\t\t\tshuffle(r1, r2);\n\t\t}\n\n\t\tint ret = 0;\n\n\t\tfor (int i = 0; i < dat.size(); i++)\n\t\t{\n\t\t\tint l = get<0>(dat[i]);\n\t\t\tint r = get<1>(dat[i]);\n\t\t\tint t = get<2>(dat[i]);\n\n\t\t\tif (p <= l && r <= q + 1)\n\t\t\t{\n\t\t\t\tret += min(max(c - t + 1, 0), r - l);\n\t\t\t}\n\t\t\telse if (p <= l && l <= q)\n\t\t\t{\n\t\t\t\tret += min(max(c - t + 1, 0), q - l + 1);\n\t\t\t}\n\t\t\telse if (p <= r && r <= q)\n\t\t\t{\n\t\t\t\tret += max(c - (t + (p - l)) + 1, 0);\n\t\t\t}\n\t\t}\n\n\t\tprintf(\"%d\\n\", ret);\n\t}\n\n\treturn 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include <iostream>\n#include <list>\n#include <vector>\n#include <set>\nusing namespace std;\ntypedef pair<int,int> pa;\n\nint X[10010],Y[10010];\nint main(){\n\tint N,M,P,Q,R,cnt,in,ou,res,le,ri;\n\tbool xfl,yfl;\n\tlist<pa> li[2];\n\tlist<pa>::iterator tit;\n\twhile(true){\n\t\tcin>>N;\n\t\tif(N==0) break;\n\t\tcin>>M>>P>>Q>>R;\n\t\tfor(int i=1;i<=M;i++){\n\t\t\tcin>>X[i]>>Y[i];\n\t\t}\n\t\tin=0;ou=1;\n\t\tli[in].clear();\n\t\tli[in].push_back(pa(1,N));\n\t\tfor(int i=1;i<=M;i++){\n\t\t\tcnt=0;xfl=yfl=false;\n\t\t\tli[ou].clear();\n\t\t\ttit=li[ou].end();\n\t\t\tfor(auto it=li[in].begin();it!=li[in].end();it++){\n\t\t\t\tif((!xfl)&&cnt+((it->second)-(it->first)+1)>=X[i]){\n\t\t\t\t\tli[ou].insert(tit,pa(it->first,it->first+(X[i]-cnt)-1));\n\t\t\t\t\ttit=li[ou].begin();\n\t\t\t\t\tif(cnt+((it->second)-(it->first))+1>=Y[i]){\n\t\t\t\t\t\tli[ou].insert(tit,pa(it->first+(X[i]-cnt),it->first+(Y[i]-cnt)-1));\n\t\t\t\t\t\ttit=li[ou].begin();\n\t\t\t\t\t\tli[ou].insert(tit,pa(it->first+(Y[i]-cnt),it->second));\n\t\t\t\t\t\tyfl=true;\n\t\t\t\t\t}\n\t\t\t\t\telse if(cnt+((it->second)-(it->first))+1>X[i])li[ou].insert(tit,pa(it->first+(X[i]-cnt),it->second));\n\t\t\t\t\txfl=true;\n\t\t\t\t}\n\t\t\t\telse if((!yfl)&&cnt+((it->second)-(it->first))+1>=Y[i]){\n\t\t\t\t\tli[ou].insert(tit,pa(it->first,it->first+(Y[i]-cnt)-1));\n\t\t\t\t\ttit=li[ou].begin();\n\t\t\t\t\tif(cnt+((it->second)-(it->first))+1>Y[i]) li[ou].insert(tit,pa(it->first+(Y[i]-cnt),it->second));\n\t\t\t\t\tyfl=true;\n\t\t\t\t}\n\t\t\t\telse{\n\t\t\t\t\tli[ou].insert(tit,(*it));\n\t\t\t\t}\n\t\t\t\tcnt+=(it->second-it->first+1);\n\t\t\t}\n\t\t\tswap(in,ou);\n\t\t}\n\t\tres=0,cnt=0;\n\t\tfor(auto it=li[in].begin();it!=li[in].end();it++){\n\t\t\tif(R<it->first){\n\t\t\t\tcnt+=((it->second)-(it->first)+1);\n\t\t\t\tcontinue;\n\t\t\t}\n\t\t\tle=cnt+1;\n\t\t\tri=min(cnt+it->second-it->first+1,R-(it->first)+le);\n\t\t\tres+=max(0,min(ri,Q)-max(le,P)+1);\n\t\t\tcnt+=((it->second)-(it->first)+1);\n\t\t}\n\t\tcout<<res<<endl;\n\t}\n\treturn 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include <iostream>\n#include <algorithm>\n#include <vector>\nusing namespace std;\nint main(){\n\tint n,m,p,q,r,x,y;\n\tvector<int>::iterator itx,ity,it;\n\tfor(;cin>>n>>m>>p>>q>>r;cout<<x<<endl){\n\t\tvector<int> v1(1),v2;\n\t\t\n\t\tfor(v1.push_back(r);m--;v2.clear()){\n\t\t\tcin>>x>>y;\n\t\t\titx=upper_bound(v1.begin(),v1.end(),x);\n\t\t\tity=upper_bound(v1.begin(),v1.end(),y);\n\t\t\t\n\t\t\tif( ity-v1.begin()+1 & 1 )v2.push_back(0);\n\t\t\tv2.push_back(0);\n//\t\t\tv2.insert(v2.end(),ity-v1.begin()&1?1:2,0);\n\t\t\tfor(it=ity;it!=v1.end();++it)\n\t\t\t\tv2.push_back(*it - y);\n\t\t\t\n\t\t\tif(v1.end()-itx & 1)v2.push_back(n-y);\n\t\t\tfor(it=itx;it!=ity;++it)\n\t\t\t\tv2.push_back(*it-x+n-y);\n\t\t\t\n\t\t\tit = v1.begin();\n\t\t\tif(ity-v1.begin() & 1)++it;\n\t\t\tif(!it[1])it+=2;\n\t\t\tif(*it+n-x==v2.back())++it,v2.pop_back();\n\t\t\tfor(;it!=itx;++it)\n\t\t\t\tv2.push_back(*it+n-x);\n\t\t\t\n\t\t\tv1.swap(v2);\n\t\t}\n\t\tv1.insert( upper_bound(v1.begin(),v1.end(),p-1), 2, p-1);\n\t\tv1.insert( lower_bound(v1.begin(),v1.end(),q), q );\n\t\tv1.push_back(n);\n\t\tit = upper_bound(v1.begin(),v1.end(),p-1);\n\t\tif(it-v1.begin() & 1) --it;\n\t\tfor(x=0;*it<q;++it){\n\t\t\tm=*it;++it;\n\t\t\tx+=*it-m;\n\t\t}\n\t}\n}"
  },
  {
    "language": "C++",
    "code": "#include <iostream>\n#include <algorithm>\n#include <vector>\nusing namespace std;\nint main(){\n\tint n,m,p,q,r,x,y;\n\tvector<int>::iterator itx,ity,it;\n\tfor(;cin>>n>>m>>p>>q>>r;cout<<x<<endl){\n\t\tvector<int> v1,v2;\n\t\tv1.push_back(0);\n\t\tfor(v1.push_back(r);m--;v2.clear()){\n\t\t\tcin>>x>>y;\n\t\t\titx=upper_bound(v1.begin(),v1.end(),x);\n\t\t\tity=upper_bound(v1.begin(),v1.end(),y);\n\t\t\t\n//\t\t\tif( ity-v1.begin()+1 & 1 )v2.push_back(0);\n//\t\t\tv2.push_back(0);\n\t\t\tv2.insert(v2.end(),ity-v1.begin()&1?1:2,0);\n\t\t\tfor(it=ity;it!=v1.end();++it)\n\t\t\t\tv2.push_back(*it - y);\n\t\t\t\n\t\t\tif(v1.end()-itx & 1)v2.push_back(n-y);\n\t\t\tfor(it=itx;it!=ity;++it)\n\t\t\t\tv2.push_back(*it-x+n-y);\n\t\t\t\n\t\t\tit = v1.begin();\n\t\t\tif(ity-v1.begin() & 1)++it;\n\t\t\tif(!it[1])it+=2;\n\t\t\tif(*it+n-x==v2.back()){++it;v2.pop_back();}\n\t\t\tfor(;it!=itx;++it)\n\t\t\t\tv2.push_back(*it+n-x);\n\t\t\t\n\t\t\tv1.swap(v2);\n\t\t}\n\t\tv1.insert( upper_bound(v1.begin(),v1.end(),p-1), 2, p-1);\n\t\tv1.insert( lower_bound(v1.begin(),v1.end(),q), q );\n\t\tv1.push_back(n);\n\t\tit = upper_bound(v1.begin(),v1.end(),p-1);\n\t\tif(it-v1.begin() & 1) --it;\n\t\tfor(x=0;*it<q;++it)\n\t\t\tm=*it++,x+=*it-m;\n\t}\n}"
  },
  {
    "language": "C++",
    "code": "#include <iostream>\n#include <sstream>\n#include <string>\n#include <algorithm>\n#include <vector>\n#include <list>\n#include <stack>\n#include <queue>\n#include <set>\n#include <map>\n#include <cstdio>\n#include <cstdlib>\n#include <cstring>\n#include <cmath>\n\nusing namespace std;\n\n#define FOR(i,k,n) for(int i=(k); i<(int)n; ++i)\n#define REP(i,n) FOR(i,0,n)\n#define FORIT(i,c) for(__typeof((c).begin())i=(c).begin();i!=(c).end();++i)\ntypedef pair<int,int> P;\nlist<P> card;\nint cnum(P p){\n  return p.second - p.first + 1;\n}\nvoid printcard(list<P> card){\n  for(list<P>::iterator it = card.begin(); it != card.end(); it++){\n    printf(\"%d-%d \",it->first,it->second);\n  }\n  putchar('\\n');\n}\n\nvoid shuffle(int x,int y){ //[y,n) [x,y) [0,x)\n  list<P> C;\n  list<P>::iterator ins = C.begin();\n  int count = 0;\n  for(list<P>::iterator it = card.begin(); it != card.end(); it++ ){\n    P ncd = *it;\n    while(true){\n      if(count < x){\n        if(count + cnum(ncd) > x){\n          C.push_back(P(ncd.first, ncd.first + (x - count - 1)));\n          ncd = P(ncd.first+(x-count), ncd.second);\n          count += cnum(C.back());\n        }else{\n          C.push_back(ncd);\n          count += cnum(ncd);\n          break;\n        }\n        ins = C.begin();\n      }else if(count < y){\n        if(count + cnum(ncd) > y){\n          ins = C.insert(ins,P(ncd.first, ncd.first + (y - count - 1)));\n          ncd = P(ncd.first+(y-count), ncd.second);\n          count += y - count;\n        }else{\n          ins = C.insert(ins,ncd);\n          count += cnum(ncd);\n          break;\n        }\n        if(count>=y) ins = C.begin();\n      }else{\n        ins = C.insert(ins,ncd);\n        break;\n      }\n    }\n  }\n  /*\n  printcard(A);\n  printcard(B);\n  printcard(C);\n  */\n  /*\n  C.insert(C.end(),B.begin(),B.end());\n  C.insert(C.end(),A.begin(),A.end());\n  */\n  card = C;\n}\nint calc(int p, int q, int r){\n  int ret = 0;\n  int count = 0;\n  for(list<P>::iterator it = card.begin(); it != card.end(); it++){\n    int lw = count + 1;\n    int up = count + cnum(*it);\n    if(lw >= p && lw < q){\n      if(up >= p && up < q){\n        ret += max(0,  it->second - max(r+1,it->first) + 1); \n      }else{\n        ret += max(0,  (it->first+(q-lw)) - max(r+1,it->first) + 1); \n        break;\n      }\n    }else{\n      if(up >= p && up < q){\n        ret += max(0,  it->second - max(r+1,it->second-(up-p)) + 1); \n      }else{\n        //nothing\n      }\n    }\n    //printf(\"%d->%d:%d \",lw,up, ret);\n    count = up;\n  }\n  return (q-p+1)-ret;  \n}\n\nint main(){\n  int n,m,p,q,r;\n  while(cin>>n>>m>>p>>q>>r){\n    card.clear();\n    card.push_back(P(1,n));\n    REP(i,m){\n      int x,y;\n      cin>>x>>y;\n      shuffle(x,y);\n    }\n    int ans = calc(p,q,r);\n    cout<<ans<<endl;\n  }\n  return 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include<iostream>\nusing namespace std;\nint main() {\n\tint size;\n\tint *card;\n\tint *dommy;\n\tint search[3];\n\tint shuffle[2];\n\tint time;\n\twhile (cin >> size&&size) {\n\t\tcard = new int[size];\n\t\tfor (int i = 0; i < size; ++i) {\n\t\t\tcard[i] = i + 1;\n\t\t}\n\t\tcin >> time;\n\t\tfor (int i = 0; i < 3; ++i) {\n\t\t\tcin >> search[i];\n\t\t}\n\t\tfor (int i = 0; i < time; ++i) {\n\t\t\tfor (int j = 0; j < 2; ++j) {\n\t\t\t\tcin>>shuffle[j];\n\t\t\t}\n\t\t\tdommy = new int[size];\n\t\t\tfor (int j = shuffle[1]; j < size; ++j) {\n\t\t\t\tdommy[j - shuffle[1]] = card[j];\n\t\t\t}\n\t\t\tfor (int j = shuffle[0]; j < shuffle[1]; ++j) {\n\t\t\t\tdommy[size - shuffle[1] + j - shuffle[0]] = card[j];\n\t\t\t}\n\t\t\tfor (int j = 0; j < shuffle[0]; ++j) {\n\t\t\t\tdommy[size - shuffle[0] + j] = card[j];\n\t\t\t}\n\t\t\tcard = dommy;\n\t\t}\n\t\tint answer = 0;\n\t\tfor (int i = search[0] - 1; i < search[1]; ++i) {\n\t\t\tif (card[i] <= search[2]) {\n\t\t\t\t++answer;\n\t\t\t}\n\t\t}\n\t\tcout << answer << endl;\n\t}\n\treturn 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include<iostream>\n#include<sstream>\n#include<cstdio>\n#include<cstdlib>\n#include<vector>\n#include<string>\n#include<stack>\n#include<queue>\n#include<deque>\n#include<set>\n#include<map>\n#include<algorithm>\n#include<functional>\n#include<utility>\n#include<cmath>\n#include<ctime>\n#include<complex>\n\nusing namespace std;\n\n#define REP(i,s,e) for(int i=int(s);i<=int(e);i++)\n#define rep(i,n) for(int i=0;i<int(n);i++)\n\nvector<int>u1,v1,u2,v2;\nvoid f(int x,int y,vector<int>& u1,vector<int>& v1,vector<int>& u2,vector<int>& v2){\n\tint c=0; int a,b,c1,c2;\n\trep(i,u1.size()){\n\t\tc+=v1[i]-u1[i]+1;\n\t\tif(c>=x){\n\t\t\ta=i; c1=c; break;\n\t\t}\n\t}\n\tc=0;\n\trep(i,u1.size()){\n\t\tc+=v1[i]-u1[i]+1;\n\t\tif(c>=y){\n\t\t\tb=i; c2=c; break;\n\t\t}\n\t}\n\n\n\tif(c2!=y){\n\t\tu2.push_back(v1[b]-(c2-y)+1);\n\t\tv2.push_back(v1[b]);\n\n\t\tREP(i,b+1,u1.size()-1){\n\t\t\tu2.push_back(u1[i]);\n\t\t\tv2.push_back(v1[i]);\n\t\t}\n\t}\n\telse{\n\t\tREP(i,b+1,u1.size()-1){\n\t\t\tu2.push_back(u1[i]);\n\t\t\tv2.push_back(v1[i]);\n\t\t}\n\t}\n\n\n    if(a!=b){\n\n\tif(c1!=x){\n\t\tu2.push_back(v1[a]-(c1-x)+1);\n\t\tv2.push_back(v1[a]);\n\n\t\tREP(i,a+1,b-1){\n\t\t\tu2.push_back(u1[i]);\n\t\t\tv2.push_back(v1[i]);\n\t\t}\n\t\tu2.push_back(u1[b]);\n\t\tv2.push_back(v1[b]-(c2-y));\n\t\t}\n\telse{\n\t\tREP(i,a+1,b-1){\n\t\t\tu2.push_back(u1[i]);\n\t\t\tv2.push_back(v1[i]);\n\t\t}\n\t\tu2.push_back(u1[b]);\n\t\tv2.push_back(v1[b]-(c2-y));\n\t}\n    }\n\n    else{\n\n    \tu2.push_back(v1[a]-(c1-x)+1);\n    \tu2.push_back(v1[b]-(c2-y));\n    }\n\n\n\t\tREP(i,0,a-1){\n\t\t\tu2.push_back(u1[i]);\n\t\t\tv2.push_back(v1[i]);\n\t\t}\n\t\tu2.push_back(u1[a]);\n\t\tv2.push_back(v1[a]-(c1-x));\n\n}\n\nint main(){\n\n\tint m,n,p,q,r,x,y;\n\n\twhile(1){\n\n\t\tcin >> n;\n\t\tif(n==0) break;\n\t\tcin >> m >> p >> q >> r;\n\n\n\t\tREP(i,1,m){\n\n\t\t\tcin >> x >> y;\n\n\t\t\tif(i==1){\n\t\t\t\tu1.push_back(y+1); v1.push_back(n);\n\t\t\t\tu1.push_back(x+1); v1.push_back(y);\n\t\t\t\tu1.push_back(1); v1.push_back(x);\n\t\t\t}\n\t\t\telse if(i%2==0){ u2.clear(); v2.clear(); f(x,y,u1,v1,u2,v2);}\n\t\t\telse if(i%2==1){ u1.clear(); v1.clear(); f(x,y,u2,v2,u1,v1);}\n\t\t}\n\n\n\t\tint s=0; int c=0; int a,b,c1,c2;\n\t\tif(m%2==0){\n\n\t\t\trep(i,u2.size()){\n\t\t\t\tc+=v2[i]-u2[i]+1;\n\t\t\t\tif(c>=p){\n\t\t\t\t\ta=i; c1=c; break;\n\t\t\t\t}\n\t\t\t}\n\t\t\tc=0;\n\t\t\trep(i,u2.size()){\n\t\t\t\tc+=v2[i]-u2[i]+1;\n\t\t\t\tif(c>=q){\n\t\t\t\t\tb=i; c2=c; break;\n\t\t\t\t}\n\t\t\t}\n\n\t\t\tif(a!=b){\n\n\t\t\tREP(i,v2[a]-(c1-p),v2[a])\n\t\t\tif(i<=r) s++;\n\t\t\tREP(i,a+1,b-1){\n\t\t\t\tREP(j,u2[i],v2[i]){\n\t\t\t\tif(j<=r) s++;\n\t\t\t\t}\n\t\t\t}\n\t\t\tREP(i,u2[b],v2[b]-(c2-q))\n\t\t\tif(i<=r) s++;\n\n\t\t\t}\n\n\t\t\telse{\n\n\t\t\tREP(i,v2[a]-(c1-p),v2[a]-(c2-q))\n\t\t\tif(i<=r) s++;\n\t\t\t}\n\n\t\t\tcout << s << endl;\n\n\t\t}\n\n\n\t\telse{\n\n\t\t\trep(i,u1.size()){\n\t\t\t\tc+=v1[i]-u1[i]+1;\n\t\t\t\tif(c>=p){\n\t\t\t\t\ta=i; c1=c; break;\n\t\t\t\t}\n\t\t\t}\n\t\t\tc=0;\n\t\t\trep(i,u1.size()){\n\t\t\t\tc+=v1[i]-u1[i]+1;\n\t\t\t\tif(c>=q){\n\t\t\t\t\tb=i; c2=c; break;\n\t\t\t\t}\n\t\t\t}\n\n\t\t\tif(a!=b){\n\n\t\t\tREP(i,v1[a]-(c1-p),v1[a])\n\t\t\tif(i<=r) s++;\n\t\t\tREP(i,a+1,b-1){\n\t\t\t\tREP(j,u1[i],v1[i]){\n\t\t\t\tif(j<=r) s++;\n\t\t\t\t}\n\t\t\t}\n\t\t\tREP(i,u1[b],v1[b]-(c2-q))\n\t\t\tif(i<=r) s++;\n\n\t\t\t}\n\n\t\t\telse{\n\n\t\t\tREP(i,v1[a]-(c1-p),v1[a]-(c2-q))\n\t\t\tif(i<=r) s++;\n\t\t\t}\n\n\t\t\tcout << s << endl;\n\t\t}\n\n\t\tu1.clear(); v1.clear(); u2.clear(); v2.clear();\n\n\t}\n\n\treturn 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include <tuple>\n#include <vector>\n#include <iostream>\n#include <algorithm>\n\n#pragma warning(disable : 4996)\n\nusing namespace std;\n\nint n, m, p, q, c, r1, r2;\n\nvector<tuple<int, int, int> > dat; // (l, r, lnum)\n\ninline void divide(int pos)\n{\n\tvector<tuple<int, int, int> > dat1;\n\n\tfor (int i = 0; i < dat.size(); i++)\n\t{\n\t\tint l = get<0>(dat[i]);\n\t\tint r = get<1>(dat[i]);\n\t\tint t = get<2>(dat[i]);\n\n\t\tif (l < pos && pos < r)\n\t\t{\n\t\t\tdat1.push_back(make_tuple(l, pos, t));\n\t\t\tdat1.push_back(make_tuple(pos, r, t + pos - l));\n\t\t}\n\t\telse\n\t\t{\n\t\t\tdat1.push_back(make_tuple(l, r, t));\n\t\t}\n\t}\n\n\tdat = dat1;\n}\n\ninline void shuffle(int a, int b)\n{\n\tdivide(a);\n\tdivide(b);\n\n\tint l = lower_bound(dat.begin(), dat.end(), make_tuple(a, 0, 0)) - dat.begin();\n\tint r = lower_bound(dat.begin(), dat.end(), make_tuple(b, 0, 0)) - dat.begin();\n\n\tvector<tuple<int, int, int> > dat1;\n\n\tint pos = 0;\n\n\tfor (int i = r; i < dat.size(); i++)\n\t{\n\t\tdat1.push_back(make_tuple(pos, pos - get<0>(dat[i]) + get<1>(dat[i]), get<2>(dat[i]))); pos += get<1>(dat[i]) - get<0>(dat[i]);\n\t}\n\n\tfor (int i = l; i < r; i++)\n\t{\n\t\tdat1.push_back(make_tuple(pos, pos - get<0>(dat[i]) + get<1>(dat[i]), get<2>(dat[i]))); pos += get<1>(dat[i]) - get<0>(dat[i]);\n\t}\n\n\tfor (int i = 0; i < l; i++)\n\t{\n\t\tdat1.push_back(make_tuple(pos, pos - get<0>(dat[i]) + get<1>(dat[i]), get<2>(dat[i]))); pos += get<1>(dat[i]) - get<0>(dat[i]);\n\t}\n\n\tdat = dat1;\n}\n\nint main()\n{\n\twhile(true)\n\t{\n\t\tscanf(\"%d\", &n); if (n == 0) { break; }\n\t\tscanf(\"%d\", &m);\n\t\tscanf(\"%d\", &p); p--;\n\t\tscanf(\"%d\", &q); q--;\n\t\tscanf(\"%d\", &c);\n\n\t\tdat.clear();\n\n\t\tdat.push_back(make_tuple(0, n, 1));\n\n\t\tfor (int i = 0; i < m; i++)\n\t\t{\n\t\t\tscanf(\"%d\", &r1);\n\t\t\tscanf(\"%d\", &r2);\n\n\t\t\tshuffle(r1, r2);\n\t\t}\n\n\t\tint ret = 0;\n\n\t\tfor (int i = 0; i < dat.size(); i++)\n\t\t{\n\t\t\tint l = get<0>(dat[i]);\n\t\t\tint r = get<1>(dat[i]);\n\t\t\tint t = get<2>(dat[i]);\n\n\t\t\tif (p <= l && r <= q + 1)\n\t\t\t{\n\t\t\t\tret += min(max(c - t + 1, 0), r - l);\n\t\t\t}\n\t\t\telse if (p <= l && l <= q)\n\t\t\t{\n\t\t\t\tret += min(max(c - t + 1, 0), q - l + 1);\n\t\t\t}\n\t\t\telse if (p <= r && r <= q)\n\t\t\t{\n\t\t\t\tret += max(c - (t + (p - l)) + 1, 0);\n\t\t\t}\n\t\t}\n\n\t\tprintf(\"%d\\n\", ret);\n\t}\n\n\treturn 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include<iostream>\n#include<cstdio>\n#include<vector>\n#include<queue>\n#include<algorithm>\n#include<functional>\n#include<cstring>\n#include<iterator>\n#define MAX_N 100000\n#define F first\n#define S second \n#define MP make_pair\nusing namespace std;\ntypedef pair<int, int> P;\n\nconst int INF = 1e9;\n\nint main() {\n\tint n, m, pp, q, r;\n\n\twhile (cin >> n&&n){\t\n\t\tint save = -1, ans = 0;\n\t\tvector<int>vep, vep2, vep3;\n\t\tvep.push_back(1);\n\t\tvep.push_back(n);\n\t    vector<int> vec, vec2, vec3;\n\t\tvec.push_back(1);\n\t\tvec.push_back(n);\n\t\tcin >> m >> pp >> q >> r;\n\t\tfor (int i = 0; i < m; i++) {\n\t\t\tint x, y, p, p2;\n\t\t\tscanf(\"%d%d\", &x, &y);\n\t\t\tp = lower_bound(vec.begin(), vec.end(), x) - vec.begin();\n\t\t\tif (vec[p] != x) {\n\t\t\t\tvec.insert(vec.begin() + p, x);\n\t\t\t\tvep.insert(vep.begin() + p, vec[p] - vec[p - 1] + vep[p - 1]);\n\t\t\t}\n\t\t\tif (vec[p] + 1 != vec[p + 1]) {\n\t\t\t\tvec.insert(vec.begin() + p + 1, x + 1);\n\t\t\t\tvep.insert(vep.begin() + p + 1, vep[p] + 1);\n\t\t\t}\n\t\t\tp2 = lower_bound(vec.begin(), vec.end(), y) - vec.begin();\n\t\t\tif (vec[p2] != y) {\n\t\t\t\tvec.insert(vec.begin() + p2, y);\n\t\t\t\tvep.insert(vep.begin() + p2, vec[p2] - vec[p2 - 1] + vep[p2 - 1]);\n\t\t\t}\n\t\t\tif (vec[p2] + 1 != vec[p2 + 1]) {\n\t\t\t\tvec.insert(vec.begin() + p2 + 1, y + 1);\n\t\t\t\tvep.insert(vep.begin() + p2 + 1, vep[p2] + 1);\n\t\t\t}\n\t\t\tfor (int j = p2 + 1; j < vec.size(); j++) {\n\t\t\t\tvec2.push_back(vec[j] - vec[p2 + 1] + 1);\n\t\t\t\tvep2.push_back(vep[j]);\n\t\t\t}\n\t\t\tint size = vec2[vec2.size() - 1];\n\t\t\tfor (int j = p + 1; j < p2 + 1; j++) {\n\t\t\t\tvec2.push_back(vec[j] - vec[p + 1] + 1 + size);\n\t\t\t\tvep2.push_back(vep[j]);\n\t\t\t}\n\t\t\tsize = vec2[vec2.size() - 1];\n\t\t\tfor (int j = 0; j < p + 1; j++) {\n\t\t\t\tvec2.push_back(vec[j] - vec[0] + 1+size);\n\t\t\t\tvep2.push_back(vep[j]);\n\t\t\t}\n\t\t\tvec3 = vec;\n\t\t\tvep3 = vep;\n\t\t\tvec = vec2;\n\t\t\tvep = vep2;\n\t\t\tvec2 = vec3;\n\t\t\tvep2 = vep3;\n\t\t\tvec2.clear();\n\t\t\tvep2.clear();\n\t\t\t/*cout << endl;\n\t\t\tfor (int i = 0; i < vec.size(); i++) {\n\t\t\t\tcout << vec[i] << \"  \" << vep[i] << endl;\n\t\t\t}\n\t\t\tcout << endl;*/\n\t\t}\n\t\tint p, p2;\n\t\tp = lower_bound(vec.begin(), vec.end(), pp) - vec.begin();\n\t\t\n\t\tif (vec[p] != pp) {\n\t\t\tvec.insert(vec.begin() + p, pp);\n\t\t\tvep.insert(vep.begin() + p, vec[p] - vec[p - 1] + vep[p - 1]);\n\t\t}\n\t\tif (vec[p] + 1 != vec[p + 1]) {\n\t\t\tvec.insert(vec.begin() + p + 1, pp + 1);\n\t\t\tvep.insert(vep.begin() + p + 1, vep[p] + 1);\n\t\t}\n\t\tp2 = lower_bound(vec.begin(), vec.end(), q) - vec.begin();\n\t\tif (vec[p2] != q) {\n\t\t\tvec.insert(vec.begin() + p2, q);\n\t\t\tvep.insert(vep.begin() + p2, vec[p2] - vec[p2 - 1] + vep[p2 - 1]);\n\t\t}\n\t\tif (vec[p2] + 1 != vec[p2 + 1]) {\n\t\t\tvec.insert(vec.begin() + p2 + 1, q + 1);\n\t\t\tvep.insert(vep.begin() + p2 + 1, vep[p2] + 1);\n\t\t}\n\t\tfor (int i = p; i <= p2; i++) {\n\t\t\tif (i + 1<=p2 && vep[i + 1] - vep[i] == vec[i + 1] - vec[i]) {\n\t\t\t\tif (vep[i + 1] <= r) {\n\t\t\t\t\tans += vep[i + 1] - vep[i];\n\t\t\t\t\tif (save != vep[i])\n\t\t\t\t\t\tans++;\n\t\t\t\t\tsave = vep[i + 1];\n\t\t\t\t}\n\t\t\t\tif (vep[i] <= r&&vep[i + 1] > r) {\n\t\t\t\t\tans += r - vep[i];\n\t\t\t\t\tif (save != vep[i])\n\t\t\t\t\t\tans++;\n\t\t\t\t\tsave = q;\n\t\t\t\t}\n\t\t\t}\n\t\t\telse{\n\t\t\t\tif (vep[i] <= r&&save != vep[i]) {\n\t\t\t\t\tans++;\n\t\t\t\t\tsave = vep[i];\n\t\t\t\t}\n\t\t\t}\n\t}\n\t\tcout << ans << endl;\n\t}\n}// 0 172 "
  },
  {
    "language": "C++",
    "code": "#include<iostream>\n#include<cstring>\n#include<queue>\n#include<algorithm>\nusing namespace std;\n\nint x[5001][3];\nint z[25000][2];\n\nqueue<int>Q1;\nqueue<int>R1;\nqueue<int>S1;\nqueue<int>Q2;\nqueue<int>R2;\nqueue<int>S2;\n\nint main(){\n\tint n,m,a,b,c,k,p,sum,sum2,sum3,t;\n\twhile(true){\n\t\tcin>>n>>m;\n\t\tcin>>a>>b>>c;\n\t\tz[0][0]=1;\n\t\tz[0][1]=n;\n\n\t\tk=1;\n\t\tfor(int i=1;i<=m;i++){\n\t\t\tcin>>x[i][1]>>x[i][2];\n\n\t\t\tfor(int j=0;j<k;j++){\n\t\t\t\tif(z[j][1]<=x[i][1]){\n\t\t\t\t\tQ1.push(z[j][0]);\n\t\t\t\t\tQ2.push(z[j][1]);\n\t\t\t\t}\n\t\t\t\telse if(z[j][0]>x[i][2]){\n\t\t\t\t\tS1.push(z[j][0]);\n\t\t\t\t\tS2.push(z[j][1]);\n\t\t\t\t}\n\t\t\t\telse if(z[j][1]<=x[i][2] && z[j][0]>x[i][1]){\n\t\t\t\t\tR1.push(z[j][0]);\n\t\t\t\t\tR2.push(z[j][1]);\n\t\t\t\t}\n\t\t\t\telse if(z[j][1]<=x[i][2] && z[j][0]<=x[i][1]){\n\t\t\t\t\tQ1.push(z[j][0]);\n\t\t\t\t\tQ2.push(x[i][1]);\n\t\t\t\t\tR1.push(x[i][1]+1);\n\t\t\t\t\tR2.push(z[j][1]);\n\t\t\t\t}\n\t\t\t\telse if(z[j][1]>x[i][2] && z[j][0]>x[i][1]){\n\t\t\t\t\tR1.push(z[j][0]);\n\t\t\t\t\tR2.push(x[i][2]);\n\t\t\t\t\tS1.push(x[i][2]+1);\n\t\t\t\t\tS2.push(z[j][1]);\n\t\t\t\t}\n\t\t\t\telse{\n\t\t\t\t\tQ1.push(z[j][0]);\n\t\t\t\t\tQ2.push(x[i][1]);\n\t\t\t\t\tR1.push(x[i][1]+1);\n\t\t\t\t\tR2.push(x[i][2]);\n\t\t\t\t\tS1.push(x[i][2]+1);\n\t\t\t\t\tS2.push(z[j][1]);\n\t\t\t\t}\n\t\t\t}\n\t\t\tk=0;\n\t\t\tk+=Q1.size();\n\t\t\tk+=R1.size();\n\t\t\tk+=S1.size();\n\t\t\tp=0;\n\t\t\t\n\t\t\twhile(!S1.empty()){\n\t\t\t\tz[p][0]=S1.front();\n\t\t\t\tz[p][1]=S2.front();\n\t\t\t\tS1.pop();\n\t\t\t\tS2.pop();\n\t\t\t\tp++;\n\t\t\t}\n\t\t\twhile(!R1.empty()){\n\t\t\t\tz[p][0]=R1.front();\n\t\t\t\tz[p][1]=R2.front();\n\t\t\t\tR1.pop();\n\t\t\t\tR2.pop();\n\t\t\t\tp++;\n\t\t\t}\n\t\t\twhile(!Q1.empty()){\n\t\t\t\tz[p][0]=Q1.front();\n\t\t\t\tz[p][1]=Q2.front();\n\t\t\t\tQ1.pop();\n\t\t\t\tQ2.pop();\n\t\t\t\tp++;\n\t\t\t}\n\t\t}\n\t\tsum=0;\n\t\tsum2=1;\n\t\tsum3=1;\n\t\tfor(int i=0;i<k;i++){\n\t\t\tsum2 += z[i][1]-z[i][0]+1;\n\t\t\tif(sum2-1>=a && sum3<=b){\n\t\t\t\tif(z[i][1]<=c){\n\t\t\t\t\tsum += min(b,sum2-1)-max(a,sum3)+1;\n\t\t\t\t}\n\t\t\t\telse if(z[i][0]<=c){\n\t\t\t\t\tt=min(b,sum2-1);\n\t\t\t\t\tt=min(t,sum3+c-z[i][0]);\n\t\t\t\t\tif(t-max(a,sum3)>=0){\n\t\t\t\t\t\tsum += t-max(a,sum3)+1;\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t}\n\t\t\tsum3=sum2;\n\t\t}\n\t\tcout<<sum<<endl;\n\t}\n}"
  },
  {
    "language": "C++",
    "code": "#include<iostream>\n#include<cstring>\n#include<queue>\n#include<algorithm>\nusing namespace std;\n\nint x[5001][3];\nint z[25000][2];\n\nqueue<int>Q1;\nqueue<int>R1;\nqueue<int>S1;\nqueue<int>Q2;\nqueue<int>R2;\nqueue<int>S2;\n\nint main(){\n\tint n,m,a,b,c,k,p,sum,sum2,sum3,t;\n\twhile(true){\n\t\tcin>>n>>m;\n\t\tcin>>a>>b>>c;\n\t\tz[0][0]=1;\n\t\tz[0][1]=n;\n\n\t\tk=1;\n\t\tfor(int i=1;i<=m;i++){\n\t\t\tcin>>x[i][1]>>x[i][2];\n\n\t\t\tfor(int j=0;j<k;j++){\n\t\t\t\tif(z[j][1]<=x[i][1]){\n\t\t\t\t\tQ1.push(z[j][0]);\n\t\t\t\t\tQ2.push(z[j][1]);\n\t\t\t\t}\n\t\t\t\telse if(z[j][0]>x[i][2]){\n\t\t\t\t\tS1.push(z[j][0]);\n\t\t\t\t\tS2.push(z[j][1]);\n\t\t\t\t}\n\t\t\t\telse if(z[j][1]<=x[i][2] && z[j][0]>x[i][1]){\n\t\t\t\t\tR1.push(z[j][0]);\n\t\t\t\t\tR2.push(z[j][1]);\n\t\t\t\t}\n\t\t\t\telse if(z[j][1]<=x[i][2] && z[j][0]<=x[i][1]){\n\t\t\t\t\tQ1.push(z[j][0]);\n\t\t\t\t\tQ2.push(x[i][1]);\n\t\t\t\t\tR1.push(x[i][1]+1);\n\t\t\t\t\tR2.push(z[j][1]);\n\t\t\t\t}\n\t\t\t\telse if(z[j][1]>x[i][2] && z[j][0]>x[i][1]){\n\t\t\t\t\tR1.push(z[j][0]);\n\t\t\t\t\tR2.push(x[i][2]);\n\t\t\t\t\tS1.push(x[i][2]+1);\n\t\t\t\t\tS2.push(z[j][1]);\n\t\t\t\t}\n\t\t\t\telse{\n\t\t\t\t\tQ1.push(z[j][0]);\n\t\t\t\t\tQ2.push(x[i][1]);\n\t\t\t\t\tR1.push(x[i][1]+1);\n\t\t\t\t\tR2.push(x[i][2]);\n\t\t\t\t\tS1.push(x[i][2]+1);\n\t\t\t\t\tS2.push(z[j][1]);\n\t\t\t\t}\n\t\t\t}\n\t\t\tk=0;\n\t\t\tk+=Q1.size();\n\t\t\tk+=R1.size();\n\t\t\tk+=S1.size();\n\t\t\tp=0;\n\t\t\t\n\t\t\twhile(!S1.empty()){\n\t\t\t\tz[p][0]=S1.front();\n\t\t\t\tz[p][1]=S2.front();\n\t\t\t\tS1.pop();\n\t\t\t\tS2.pop();\n\t\t\t\tp++;\n\t\t\t}\n\t\t\twhile(!R1.empty()){\n\t\t\t\tz[p][0]=R1.front();\n\t\t\t\tz[p][1]=R2.front();\n\t\t\t\tR1.pop();\n\t\t\t\tR2.pop();\n\t\t\t\tp++;\n\t\t\t}\n\t\t\twhile(!Q1.empty()){\n\t\t\t\tz[p][0]=Q1.front();\n\t\t\t\tz[p][1]=Q2.front();\n\t\t\t\tQ1.pop();\n\t\t\t\tQ2.pop();\n\t\t\t\tp++;\n\t\t\t}\n\t\t}\n\t\tsum=0;\n\t\tsum2=1;\n\t\tsum3=1;\n\t\tfor(int i=0;i<k;i++){\n\t\t\tsum2 += z[i][1]-z[i][0]+1;\n\t\t\tif(sum2-1>=a && sum3<=b){\n\t\t\t\tif(z[i][1]<=c){\n\t\t\t\t\tsum += min(b,sum2-1)-max(a,sum3)+1;\n\t\t\t\t}\n\t\t\t\telse if(z[i][0]<=c){\n\t\t\t\t\tt=min(b,sum2-1);\n\t\t\t\t\tt=min(t,sum3+c-z[i][0]);\n\t\t\t\t\tif(t-max(a,sum3)>=0){\n\t\t\t\t\t\tsum += t-max(a,sum3)+1;\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t}\n\t\t\tsum3=sum2;\n\t\t}\n\t\tcout<<sum<<endl;\n\t}\n}"
  },
  {
    "language": "C++",
    "code": "#include <iostream>\n#include <algorithm>\n#include <vector>\nusing namespace std;\nint main(){\n\tint n,m,p,q,r,x,y,t;\n\tvector<int>::iterator itx,ity,it;\n\tfor(;cin>>n>>m>>p>>q>>r;cout<<x<<endl){\n\t\tvector<int> v1,v2;\n\t\tv1.push_back(0);\n\t\tv1.push_back(r);\n\t\t\n\t\tfor(;m--;v2.clear()){\n\t\t\tcin>>x>>y;\n\t\t\titx=upper_bound(v1.begin(),v1.end(),x);\n\t\t\tity=upper_bound(v1.begin(),v1.end(),y);\n\t\t\t\n\t\t\tif( ity-v1.begin() & 1 )v2.push_back(0);\n\t\t\tfor(it=ity;it!=v1.end();++it)\n\t\t\t\tv2.push_back(*it - y);\n\n\t\t\tif(v1.end()-itx & 1)v2.push_back(n-y);\n\t\t\tfor(it=itx;it!=ity;++it)\n\t\t\t\tv2.push_back(*it-x+n-y);\n\n\t\t\tit = v1.begin();\n\t\t\tif(ity-v1.begin() & 1)++it;\n\t\t\tfor(;it<itx;++it)\n\t\t\t\tv2.push_back(*it+n-x);\n\t\t\t\n\t\t\tv1.swap(v2);\n\t\t}\n\t\tv1.insert( upper_bound(v1.begin(),v1.end(),p-1), 2, p-1);\n\t\tv1.insert( lower_bound(v1.begin(),v1.end(),q), q );\n\t\tv1.push_back(n);\n\t\tit = upper_bound(v1.begin(),v1.end(),p-1);\n\t\tif(it-v1.begin() & 1) --it;\n\t\tfor(x=0;*it<q;++it){\n\t\t\tm=*it;\n\t\t\t++it;\n\t\t\tx+=*it-m;\n\t\t}\n\t}\n}"
  },
  {
    "language": "C++",
    "code": "#include <iostream>\n#include <algorithm>\n#include <vector>\nusing namespace std;\n\nint c1[5010],c2[5010];\nint main(){\n\tint N,M,P,Q,R,ac1,ac2,cnt;\n\tvector<int> vv;\n\tvv.reserve(1000000010);\n\twhile(1){\n\t\tcin>>N;\n\t\tif(N==0) break;\n\t\tcin>>M>>P>>Q>>R;\n\t\tfor(int i=0;i<M;i++){\n\t\t\tcin>>ac1>>ac2;\n\t\t\tc1[i]=ac1;\n\t\t\tc2[i]=ac2;\n\t\t}\n\t\tfor(int i=1;i<=N;i++) vv[i]=i;\n\t\t\n\t\tfor(int i=0;i<M;i++){\n\t\t\treverse(&vv+1,&vv+c1[i]+1);\n\t\t\treverse(&vv+c1[i]+1,&vv+c2[i]+1);\n\t\t\treverse(&vv+c2[i]+1,&vv+N+1);\n\t\t\treverse(&vv+1,&vv+N+1);\n\t\t}\n\t\tcnt=0;\n\t\tfor(int i=P;i<=Q;i++){\n\t\t\tif(vv[i]<=R) cnt++;\n\t\t}\n\t\tcout<<cnt<<endl;\n\t}\n\treturn 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include<bits/stdc++.h>\nusing namespace std;\n#define h first\n#define w second\nvector<pair<bool,pair<int,int> > >v;\nint n,m,p,q,r,i;\nvoid Vp(bool a,int b,int c){v.push_back(make_pair(a,make_pair(b,c)));}\nint main(){\n\twhile(cin>>n&&n){\n\tcin>>m>>p>>q>>r;v.clear();\n\tVp(1,1,r);Vp(0,r+1,n);\n\twhile(m--){\n\t\tint x,y;scanf(\"%d%d\",&x,&y);\n\t\tfor(i=0;i<v.size();i++){\n\t\t\tint a=v[i].w.h,b=v[i].w.w;bool c=v[i].h;\n\t\t\tif(a<=x&&x<b){Vp(c,x+1,b);b=x;}\n\t\t\tif(a<=y&&y<b){Vp(c,y+1,b);b=y;}\n\t\t\tif(0<a&&b<=x)a+=n-x,b+=n-x;\n\t\t\telse if(x<a&&b<=y)a+=n-x-y,b+=n-x-y;\n\t\t\telse if(y<a&&b<=n)a-=y,b-=y;\n\t\t\tv[i].w.h=a,v[i].w.w=b;\n\t\t}\n\t}n=0;\n\tfor(i=0;i<v.size();i++)if(v[i].h)n+=max(0,1+min(v[i].w.w,q)-max(v[i].w.h,p));\n\tcout<<n<<endl;\n\t}\n\treturn 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include <iostream>\n#include <list>\n\nint n, m;\nint p, q, r;\n\nusing Pair = std::pair<int, int>;\n\nint main() {\n    while(std::cin >> n, n) {\n    std::cin >> m;\n    std::cin >> p >> q >> r;\n    --p, --q;\n    \n    std::list<Pair> list;\n    \n    list.push_back({0, n});\n    \n    int x, y;\n    for(int i = 0; i < m; ++i) {\n        std::cin >> x >> y;\n        \n        auto it = list.begin();\n        decltype(it) xr[2], yr[2];\n        xr[0] = it;\n        int cnt = 0;\n        while(1) {\n            int c = it->second - it->first;\n            cnt += c;\n            \n            if(cnt == x) {\n                xr[1] = it;\n                ++it;\n                yr[0] = it;\n                \n                break;\n            }else if(cnt > x) {\n                auto p = Pair(it->first + c - (cnt - x), it->second);\n                \n                it->second = it->first + c - (cnt - x);\n                \n                ++it;\n                \n                it = xr[1] = yr[0] = list.insert(it, p);\n                --xr[1];\n                \n                break;\n            }\n            ++it;\n        }\n        \n        cnt = 0;\n        y -= x;\n        while(1) {\n            int c = it->second - it->first;\n            cnt += c;\n            \n            if(cnt == y) {\n                yr[1] = it;\n                break;\n            }else if(cnt > y) {\n                auto p = Pair(it->first + c - (cnt - y), it->second);\n                \n                it->second = it->first + c - (cnt - y);\n                \n                ++it;\n                \n                yr[1] = list.insert(it, p);\n                \n                --yr[1];\n                break;\n            }\n            ++it;\n        }\n        \n        ++yr[1];\n        list.splice(list.end(), list, yr[0], yr[1]);\n        ++xr[1];\n        list.splice(list.end(), list, xr[0], xr[1]);\n        \n    }\n    \n    {\n        int x = p, y = q + 1;\n        auto it = list.begin();\n        decltype(it) xr[2], yr[2];\n        xr[0] = it;\n        int cnt = 0;\n        while(1) {\n            int c = it->second - it->first;\n            cnt += c;\n            \n            if(cnt == x) {\n                xr[1] = it;\n                ++it;\n                yr[0] = it;\n                \n                break;\n            }else if(cnt > x) {\n                auto p = Pair(it->first + c - (cnt - x), it->second);\n                \n                it->second = it->first + c - (cnt - x);\n                \n                ++it;\n                \n                it = xr[1] = yr[0] = list.insert(it, p);\n                --xr[1];\n                \n                break;\n            }\n            ++it;\n        }\n        \n        cnt = 0;\n        y -= x;\n        while(1) {\n            int c = it->second - it->first;\n            cnt += c;\n            \n            if(cnt == y) {\n                yr[1] = it;\n                break;\n            }else if(cnt > y) {\n\n                auto p = Pair(it->first + c - (cnt - y), it->second);\n                \n                it->second = it->first + c - (cnt - y);\n                \n                ++it;\n                \n                yr[1] = list.insert(it, p);\n                \n                --yr[1];\n                break;\n            }\n            ++it;\n        }\n        \n        int ans = 0;\n        ++yr[1];\n        for(auto it = yr[0]; it != yr[1]; ++it) {\n            if(it->second <= r) {\n                ans += it->second - it->first;\n            }else {\n                if(it->first + 1 <= r) {\n                    ans += r - it->first;\n                }\n            }\n        }\n        std::cout << ans << std::endl;\n    }\n    }\n}"
  },
  {
    "language": "C++",
    "code": "#include <tuple>\n#include <vector>\n#include <iostream>\n#include <algorithm>\n\n#pragma warning(disable : 4996)\n\nusing namespace std;\n\nint n, m, p, q, c, r1, r2;\n\nvector<tuple<int, int, int> > dat; // (l, r, lnum)\n\nvoid divide(int pos)\n{\n\tvector<tuple<int, int, int> > dat1;\n\n\tfor (int i = 0; i < dat.size(); i++)\n\t{\n\t\tint l = get<0>(dat[i]);\n\t\tint r = get<1>(dat[i]);\n\t\tint t = get<2>(dat[i]);\n\n\t\tif (l < pos && pos < r)\n\t\t{\n\t\t\tdat1.push_back(make_tuple(l, pos, t));\n\t\t\tdat1.push_back(make_tuple(pos, r, t + pos - l));\n\t\t}\n\t\telse\n\t\t{\n\t\t\tdat1.push_back(make_tuple(l, r, t));\n\t\t}\n\t}\n\n\tdat = dat1;\n}\n\nint position(int num)\n{\n\tfor (int i = 0; i < dat.size(); i++)\n\t{\n\t\tif (get<0>(dat[i]) <= num && num < get<1>(dat[i]))\n\t\t{\n\t\t\treturn i;\n\t\t}\n\t}\n\n\treturn -1;\n}\n\nvoid shuffle(int a, int b)\n{\n\tdivide(a);\n\tdivide(b);\n\n\tint l = position(a);\n\tint r = position(b);\n\n\tvector<tuple<int, int, int> > dat1;\n\n\tint pos = 0;\n\n\tfor (int i = r; i < dat.size(); i++)\n\t{\n\t\tdat1.push_back(make_tuple(pos, pos - get<0>(dat[i]) + get<1>(dat[i]), get<2>(dat[i]))); pos += get<1>(dat[i]) - get<0>(dat[i]);\n\t}\n\n\tfor (int i = l; i < r; i++)\n\t{\n\t\tdat1.push_back(make_tuple(pos, pos - get<0>(dat[i]) + get<1>(dat[i]), get<2>(dat[i]))); pos += get<1>(dat[i]) - get<0>(dat[i]);\n\t}\n\n\tfor (int i = 0; i < l; i++)\n\t{\n\t\tdat1.push_back(make_tuple(pos, pos - get<0>(dat[i]) + get<1>(dat[i]), get<2>(dat[i]))); pos += get<1>(dat[i]) - get<0>(dat[i]);\n\t}\n\n\tdat = dat1;\n}\n\nint main()\n{\n\twhile(true)\n\t{\n\t\tscanf(\"%d\", &n); if (n == 0) { break; }\n\t\tscanf(\"%d\", &m);\n\t\tscanf(\"%d\", &p); p--;\n\t\tscanf(\"%d\", &q); q--;\n\t\tscanf(\"%d\", &c);\n\n\t\tdat.push_back(make_tuple(0, n, 1));\n\n\t\tfor (int i = 0; i < m; i++)\n\t\t{\n\t\t\tscanf(\"%d\", &r1);\n\t\t\tscanf(\"%d\", &r2);\n\n\t\t\tshuffle(r1, r2);\n\t\t}\n\n\t\tint ret = 0;\n\n\t\tfor (int i = 0; i < dat.size(); i++)\n\t\t{\n\t\t\tint l = get<0>(dat[i]);\n\t\t\tint r = get<1>(dat[i]);\n\t\t\tint t = get<2>(dat[i]);\n\n\t\t\tif (p <= l && r <= q + 1)\n\t\t\t{\n\t\t\t\tret += max(c - t + 1, 0);\n\t\t\t}\n\t\t\telse if (p <= l)\n\t\t\t{\n\t\t\t\tret += min(max(c - t + 1, 0), q - l + 1);\n\t\t\t}\n\t\t\telse if (q <= r)\n\t\t\t{\n\t\t\t\tret += max(c - (t + (p - l)) + 1, 0);\n\t\t\t}\n\t\t}\n\n\t\tprintf(\"%d\\n\", ret);\n\t}\n\n\treturn 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include<iostream>\n#include<string>\n#include<cmath>\n#include<queue>\n#include<map>\n#include<set>\n#include<list>\n#include<iomanip>\n#include<vector>\n#include<functional>\n#include<algorithm>\n#include<cstdio>\n#include<unordered_map>\nusing namespace std;\n//---------------------------------------------------\n//????????????????????????????????????\n//#define int long long\n#define str string\n#define rep(i,j) for(int i=0;i<(int)(j);i++)\ntypedef long long ll;\ntypedef long double ld;\nconst ll inf = 4523372036854775807;\nconst int inf2 = 1145141919;\nconst ld pi = 3.14159265358979323846264338327950288419716939937510582097494459230781640628620899;\nstruct P {\n\tll pos, cost;\n};\nbool operator<(P a, P b) { return a.cost < b.cost; }\nbool operator>(P a, P b) { return a.cost > b.cost; }\nstruct B {//??£??\\???????????¨???\n\tll to, cost;\n};\nstruct S {//???????????±?????\\???????????°\n\tint from, to, cost;\n};\nbool operator<(S a, S b) { return a.cost < b.cost; }\nbool operator>(S a, S b) { return a.cost > b.cost; }\nstruct H {\n\tint x, y;\n};\nll gcm(ll i, ll j) {//?????§??¬?´???°\n\tif (i > j) swap(i, j);\n\tif (i == 0) return j;\n\treturn gcm(j%i, i);\n}\nld rad(ld a, ld b, ld c, ld d) {\n\treturn sqrt(pow(a - c, 2) + pow(b - d, 2));\n}//rad?????§?¨???????2??????????????¢\n //---------------------------------------------------\n //+++++++++++++++++++++++++++++++++++++++++++++++++++\nstruct A {\n\tint s, e, s2, size;\n\t//????????????????????????????????????????????????????????????????????????\n};\nint n, m, p, q, r;\nvector<A>a[2];\nvector<int>b[2];\nsigned main() {\n\twhile (cin >> n) {\n\t\tcin >> m >> p >> q >> r;\n\t\tint d = 0, e = 1, k, t, x, y;\n\t\ta[0].clear(); a[1].clear();\n\t\tb[0].clear(); b[1].clear();\n\t\ta[d].push_back(A{ 1,n,1,n });\n\t\tb[d].push_back(1);\n\t\tfor (int z = 0; z < m; z++) {\n\t\t\ta[e].clear(); b[e].clear();\n\t\t\tcin >> x >> y;\n\t\t\t//y+1??????????????????????????§????????????????????????????????????\n\t\t\tk = lower_bound(b[d].begin(), b[d].end(), y + 1) - b[d].begin();\n\t\t\tif (k == b[d].size() || a[d][k].s2 > y + 1)\n\t\t\t\tk--;\n\t\t\tb[e].push_back(1);\n\t\t\ta[e].push_back(A{ a[d][k].s + (y + 1 - a[d][k].s2),a[d][k].e,1,a[d][k].size - (y + 1 - a[d][k].s2) });\n\t\t\tint sum = a[d][k].size - (y + 1 - a[d][k].s2) + 1;\n\t\t\tk++;\n\t\t\tfor (; k < a[d].size(); k++) {\n\t\t\t\tb[e].push_back(sum);\n\t\t\t\ta[e].push_back(A{ a[d][k].s,a[d][k].e,sum,a[d][k].size });\n\t\t\t\tsum += a[d][k].size;\n\t\t\t}\n\t\t\t//x+1?????????y?????§???????????????????????????????????????\n\t\t\tk = lower_bound(b[d].begin(), b[d].end(), x + 1) - b[d].begin();\n\t\t\tt = lower_bound(b[d].begin(), b[d].end(), y) - b[d].begin();\n\t\t\tif (k == a[d].size() || a[d][k].s2 > x + 1)\n\t\t\t\tk--;\n\t\t\tif (t == a[d].size() || a[d][t].s2 > y)\n\t\t\t\tt--;\n\t\t\tif (k == t) {\n\t\t\t\tb[e].push_back(sum);\n\t\t\t\ta[e].push_back(A{ a[d][k].s + (x + 1 - a[d][k].s2),a[d][k].s + (y - a[d][k].s2),sum,y - x });\n\t\t\t\tsum += y - x;\n\t\t\t}\n\t\t\telse {\n\t\t\t\tb[e].push_back(sum);\n\t\t\t\ta[e].push_back(A{ a[d][k].s + (x + 1 - a[d][k].s2),a[d][k].e,sum,a[d][k].size - (x + 1 - a[d][k].s2) });\n\t\t\t\tsum += (a[d][k].size - (x + 1 - a[d][k].s2));\n\t\t\t\tk++;\n\t\t\t\tfor (; k < t; k++) {\n\t\t\t\t\tb[e].push_back(sum);\n\t\t\t\t\ta[e].push_back(A{ a[d][k].s,a[d][k].e,sum,a[d][k].size });\n\t\t\t\t\tsum += a[d][k].size;\n\t\t\t\t}\n\t\t\t\tb[e].push_back(sum);\n\t\t\t\ta[e].push_back(A{ a[d][k].s,a[d][k].s + (y - a[d][k].s2),sum,y - a[d][k].s2 + 1 });\n\t\t\t\tsum += y - a[d][k].s2 + 1;\n\t\t\t}\n\t\t\t//1??????x?????§????????????????????????????????§?????????\n\t\t\tk = lower_bound(b[d].begin(), b[d].end(), x) - b[d].begin();\n\t\t\tif (k == b[d].size() || a[d][k].s2 > x)\n\t\t\t\tk--;\n\t\t\tfor (int i = 0; i < k; i++) {\n\t\t\t\tb[e].push_back(sum);\n\t\t\t\ta[e].push_back(A{ a[d][i].s,a[d][i].e,sum,a[d][i].size });\n\t\t\t\tsum += a[d][i].size;\n\t\t\t}\n\t\t\tb[e].push_back(sum);\n\t\t\ta[e].push_back(A{ a[d][k].s,a[d][k].s + (x - a[d][k].s2),sum,x - a[d][k].s2 + 1 });\n\t\t\tswap(d, e);\n\t\t}\n\t\tk = lower_bound(b[d].begin(), b[d].end(), p) - b[d].begin();\n\t\tt = lower_bound(b[d].begin(), b[d].end(), q) - b[d].begin();\n\t\tif (k == b[d].size() || a[d][k].s2 > p) k--;\n\t\tif (t == b[d].size() || a[d][t].s2 > q) t--;\n\t\ta[d][k].size -= (p - a[d][k].s2);\n\t\ta[d][k].s = a[d][k].s + (p - a[d][k].s2);\n\t\ta[d][t].size = (q - a[d][t].s2+1);\n\t\ta[d][t].e = a[d][t].s + (q - a[d][t].s2);\n\t\tint sum = 0;\n\t\tif (k == t) {\n\t\t\tif (a[d][k].e <= r)\n\t\t\t\tsum = a[d][k].size;\n\t\t\telse if (a[d][k].s <= r)\n\t\t\t\tsum = r - a[d][k].s + 1;\n\t\t}\n\t\telse {\n\t\t\tfor (; k <= t; k++) {\n\t\t\t\tif (a[d][k].e <= r)\n\t\t\t\t\tsum += a[d][k].size;\n\t\t\t\telse if (a[d][k].s <= r)\n\t\t\t\t\tsum += r - a[d][k].s + 1;\n\t\t\t}\n\t\t}\n\t\tcout << sum << endl;\n\t}\n\tgetchar(); getchar();\n}"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\nusing namespace std;\n\nusing VI = vector<int>;\nusing VVI = vector<VI>;\nusing PII = pair<int, int>;\nusing LL = long long;\nusing VL = vector<LL>;\nusing VVL = vector<VL>;\nusing PLL = pair<LL, LL>;\nusing VS = vector<string>;\n\n#define ALL(a)  begin((a)),end((a))\n#define RALL(a) (a).rbegin(), (a).rend()\n#define PB push_back\n#define EB emplace_back\n#define MP make_pair\n#define SZ(a) int((a).size())\n#define SORT(c) sort(ALL((c)))\n#define RSORT(c) sort(RALL((c)))\n#define UNIQ(c) (c).erase(unique(ALL((c))), end((c)))\n\n#define FOR(i,a,b) for(int i=(a);i<(b);++i)\n#define REP(i,n)  FOR(i,0,n)\n\n#define FF first\n#define SS second\ntemplate<class S, class T>\nistream& operator>>(istream& is, pair<S,T>& p){\n  return is >> p.FF >> p.SS;\n}\ntemplate<class S, class T>\nostream& operator<<(ostream& os, const pair<S,T>& p){\n  return os << p.FF << \" \" << p.SS;\n}\ntemplate<class T>\nvoid maxi(T& x, T y){\n  if(x < y) x = y;\n}\ntemplate<class T>\nvoid mini(T& x, T y){\n  if(x > y) x = y;\n}\n\n\nconst double EPS = 1e-10;\nconst double PI  = acos(-1.0);\nconst LL MOD = 1e9+7;\n\n\nint main(){\n  cin.tie(0);\n  ios_base::sync_with_stdio(false);\n\n  int N;\n  while(cin>>N, N){\n\tint M;\n\tcin >> M;\n\tint P, Q, R;\n\tcin >> P >> Q >> R;\n\t--P;\n\t\n\tvector<PII> s[2];\n\tint crt = 0, nxt = 1;\n\ts[crt].PB(MP(P,Q));\n\tvector<PII> qs(M);\n\tREP(i,M){\n\t  cin >> qs[M-1-i].FF >> qs[M-1-i].SS;\n\t  --qs[M-1-i].FF;\n\t}\n\t\n\tREP(i,M){\n\t  s[nxt].clear();\n\t  int b = N - qs[i].FF;\n\t  int a = N - qs[i].SS;\n\t  \n\t  for(auto&& r: s[crt]){\n\t\tint l1 = N - b;\n\t\tint l2 = l1 + b - a;\n\t\t\n\t\tif(r.SS <= a){\n\t\t  s[nxt].PB(MP(l2+r.FF, l2+r.SS));\n\t\t}\n\t\telse if(r.FF < a){\n\t\t  if(r.SS <= b){\n\t\t\ts[nxt].PB(MP(l2+r.FF, N));\n\t\t\ts[nxt].PB(MP(l1, l1+r.SS-a));\n\t\t  }\n\t\t  else{\n\t\t\ts[nxt].PB(MP(l2+r.FF, N));\n\t\t\ts[nxt].PB(MP(l1,l2));\n\t\t\ts[nxt].PB(MP(0,r.SS-b));\n\t\t  }\n\t\t}\n\t\telse if(r.FF < b){\n\t\t  if(r.SS <= b){\n\t\t\ts[nxt].PB(MP(l1+r.FF-a,l1+r.SS-a));\n\t\t  }\n\t\t  else{\n\t\t\ts[nxt].PB(MP(l1+r.FF-a,l2));\n\t\t\ts[nxt].PB(MP(0,r.SS-b));\n\t\t  }\n\t\t}\n\t\telse{\n\t\t  s[nxt].PB(MP(r.FF-b,r.SS-b));\n\t\t}\n\t  }\n\t  swap(crt, nxt);\n\t  //for(auto&&p:s[crt])cout<<p<<endl;cout<<\"==\"<<endl;\n\t}\n\t\n\tint ans = 0;\n\tfor(auto&& p: s[crt]){\n\t  if(p.FF >= R) continue;\n\t  int r = min(R, p.SS);\n\t  ans += r - p.FF;\n\t}\n\tcout << ans << endl;\n  }\n\n  return 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include<iostream>\n#include<vector>\n#include<algorithm>\nusing namespace std;\nvector<pair<int, int>>vec;\nint n, m, l, r, p;\nint main() {\n\tcin >> n >> m; cin >> l >> r >> p;\n\tvec.push_back(make_pair(1, n));\n\tfor (int i = 0; i < m; i++) {\n\t\tint r1, r2; cin >> r1 >> r2;\n\t\tvector<pair<int, int>>A, B, C; int sum1 = 0, c = 0;\n\t\tfor (int j = 0; j < vec.size(); j++) {\n\t\t\tsum1 += (vec[j].second - vec[j].first + 1);\n\t\t\tbool H = false;\n\t\t\tif (sum1 > r2 && c == 0) {\n\t\t\t\tint Border1 = vec[j].second - (sum1 - r1);\n\t\t\t\tint Border2 = vec[j].second - (sum1 - r2);\n\t\t\t\tA.push_back(make_pair(vec[j].first, Border1));\n\t\t\t\tB.push_back(make_pair(Border1+1, Border2));\n\t\t\t\tC.push_back(make_pair(Border2 + 1, vec[j].second));\n\t\t\t\tc = 2; H = true;\n\t\t\t}\n\t\t\tif (sum1 > r1 && c == 0) {\n\t\t\t\tint Border = vec[j].second - (sum1 - r1);\n\t\t\t\tA.push_back(make_pair(vec[j].first, Border));\n\t\t\t\tB.push_back(make_pair(Border + 1, vec[j].second));\n\t\t\t\tc = 1; H = true;\n\t\t\t}\n\t\t\tif (sum1 > r2 && c == 1 && H == false) {\n\t\t\t\tint Border = vec[j].second - (sum1 - r2);\n\t\t\t\tB.push_back(make_pair(vec[j].first, Border));\n\t\t\t\tC.push_back(make_pair(Border + 1, vec[j].second));\n\t\t\t\tc = 2; H = true;\n\t\t\t}\n\t\t\tif (H == false) {\n\t\t\t\tif (c == 0) { A.push_back(make_pair(vec[j].first, vec[j].second)); }\n\t\t\t\tif (c == 1) { B.push_back(make_pair(vec[j].first, vec[j].second)); }\n\t\t\t\tif (c == 2) { C.push_back(make_pair(vec[j].first, vec[j].second)); }\n\t\t\t}\n\t\t}\n\t\tvec.clear();\n\t\tfor (int i = 0; i < C.size(); i++)vec.push_back(C[i]);\n\t\tfor (int i = 0; i < B.size(); i++)vec.push_back(B[i]);\n\t\tfor (int i = 0; i < A.size(); i++)vec.push_back(A[i]);\n\t}\n\tint sum2 = 0, sum3 = 0;\n\tfor (int i = 0; i < vec.size(); i++) {\n\t\tif (vec[i].first > vec[i].second)continue;\n\t\tint HB = (vec[i].second - vec[i].first + 1); sum2 += HB;\n\t\tint L1 = vec[i].first, R1 = vec[i].second;\n\t\tint L2 = 1, R2 = p;\n\t\tif (sum2 > r && sum2 - HB <= r) { R1 = vec[i].first + (r - (sum2 - HB)) - 1; }\n\t\tif (sum2 - HB < l && sum2 >= l) { L1 = vec[i].first + (l - (sum2 - HB)) - 1; }\n\t\tif (sum2 - HB > r)continue;\n\t\tif (sum2 < l)continue;\n\n\t\tint L3 = max(L1, L2), R3 = min(R1, R2);\n\t\tsum3 += max(0, R3 - L3 + 1);\n\t}\n\tcout << sum3 << endl;\n\treturn 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include <iostream>\n#include <vector>\nusing namespace std;\n\nvector<int> pile;\nvector<int> new_pile;\n\nvoid shuffle(int x, int y, int n) {\n    int index = 0;\n    for (int i = y; i < n; i++) {\n        new_pile[index] = pile[i];\n        index++;\n    }\n    for (int i = x; i < y; i++) {\n        new_pile[index] = pile[i];\n        index++;\n    }\n    for (int i = 0; i < x; i++) {\n        new_pile[index] = pile[i];\n        index++;\n    }\n    pile = new_pile;\n    new_pile.clear();\n    new_pile.resize(n);\n}\n\nint count_under_r(int p, int q, int r) {\n    int c = 0;\n    for (int i = p - 1; i < q; i++) {\n        if (r >= pile[i]) {\n            c++;\n        }\n    }\n    return c;\n}\n\nvoid solve(int n) {\n    pile.resize(n);\n    for (int i = 0; i < n; i++) pile[i] = i+1;\n    new_pile.resize(n);\n\n    int m;\n    cin >> m;\n    \n    int p, q, r;\n    cin >> p >> q >> r;\n\n    for (int i = 0; i < m; i++) {\n        int x, y;\n        cin >> x >> y;\n        shuffle(x, y, n);\n    }\n\n    cout << count_under_r(p, q, r) << endl;\n}\n\nint main() {\n    int n;\n    while (cin >> n) {\n        if (n == 0) break;\n        solve(n);\n    }\n    return 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include<iostream>\n#include<vector>\n#include<algorithm>\nusing namespace std;\ntypedef pair<int,int> pii;\n\nbool solve(){\n  int n,m,p,q,r;\n  vector<pii> v;\n  cin >> n;\n  if(n==0) return false;\n  cin >> m >> p >> q >> r;\n  v.push_back(pii(1,n));\n  for(int i=0;i<m;i++){\n    int x[3],cnt = 0, now = 0;\n    vector<pii> t[3];\n    cin >> x[0] >> x[1];\n    x[2] = n;\n    for(int j=0;j<v.size();j++){\n      int l = v[j].second - v[j].first + 1;\n      if(cnt + l <= x[now]){\n        t[now].push_back(v[j]);\n        if(cnt + l == x[now]) now++;\n      }else{\n        l = x[now] - cnt;\n        t[now].push_back(pii(v[j].first,v[j].first + l - 1));\n        v[j].first = v[j].first + l;\n        j--;\n        now++;\n      }\n      cnt += l;\n    }\n    vector<pii> tmp;\n    for(int i=2;i>=0;i--) copy(t[i].begin(),t[i].end(),back_inserter(tmp));\n    if(v.size() > tmp.size()) cout << \"oaksii\" << endl;\n    for(int i=0;i<tmp.size();i++){\n      if(i < v.size()) v[i] = tmp[i];\n      else v.push_back(tmp[i]);\n    }\n  }\n  int cnt = 0, now = 0, x[3] = {p-1,q,n};\n  vector<pii> t[3];\n  for(int j=0;j<v.size();j++){\n    int l = v[j].second - v[j].first + 1;\n    if(cnt + l <= x[now]){\n      t[now].push_back(v[j]);\n      if(cnt + l == x[now]) now++;\n    }else{\n      l = x[now] - cnt;\n      t[now].push_back(pii(v[j].first,v[j].first + l - 1));\n      v[j].first = v[j].first + l;\n      j--;\n      now++;\n    }\n    cnt += l;\n  }\n  int ans = 0;\n  for(int i=0;i<t[1].size();i++){\n    if(r>=t[1][i].first) ans += min(r,t[1][i].second) - t[1][i].first + 1;\n  }\n  cout << ans << endl;\n  return true;\n}\n\nint main(){\n  while(true) if(!solve()) return 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include <iostream>\n#include <cstdio>\n#include <cstring>\n#include <cstdlib>\n#include <cmath>\n#include <vector>\n#include <string>\n#include <map>\n#include <set>\n#include <queue>\n#include <stack>\n#include <algorithm>\n#include <deque>\n \nusing namespace std;\n \n#define rep(i,j) REP((i), 0, (j))\n#define REP(i,j,k) for(int i=(j);(i)<(k);++i)\n#define BW(a,x,b) ((a)<=(x)&&(x)<=(b))\n#define ALL(v) (v).begin(), (v).end()\n#define LENGTHOF(x) (sizeof(x) / sizeof(*(x)))\n#define AFILL(a, b) fill((int*)a, (int*)(a + LENGTHOF(a)), b)\n#define SQ(x) ((x)*(x))\n#define Mod(x, mod) (((x)+(mod)%(mod))\n#define MP make_pair\n#define PB push_back\n#define F first\n#define S second\n#define INF 1 << 30\n#define EPS 1e-10\n#define MOD 1000000007\n \ntypedef pair<int, int> pi;\ntypedef pair<int, pi> pii;\ntypedef vector<int> vi;\ntypedef queue<int> qi;\ntypedef long long ll;\n \ndeque<pi>vec, a, b, c;\nint N, M, P, Q, R;\n \nint cnt(int p, int q, int r){\n  if(p > r) return 0;\n  if(r >= q) return q-p+1;\n  return r-p+1;\n}\n \nint countR(int p, int q, int r){\n  int n = 1, vp, res = 0;\n  for(vp=0;vp<vec.size();vp++){\n    int f = vec[vp].F, l = vec[vp].S;\n    int c = l-f+1;\n    if(n <= p){\n      if(n+c < p){\n      }\n      else if(n + c > q){\n    res += cnt(f+p-n, f+q-n, r);\n      }else{\n    res += cnt(f+p-n, l, r);\n      }\n      n += c;\n    }else if(n <= q){\n      if(n+c<=q){\n    res += cnt(f, l, r);\n      }else{\n    res += cnt(f, f+q-n, r);\n      }\n      n += c;\n    }\n  }\n  return res;\n}\n \n \nint main(){\n  while(1){\n    cin >> N;\n    if(!N) break;\n    cin >> M >> P >> Q >> R;\n    vec.clear();\n    vec.push_back(MP(1,N));\n    int x, y;\n    rep(i, M){\n      cin >> x >> y;\n      a.clear(); b.clear();\n      int p=1;\n      while(p<=x){\n    int f = vec[0].F, s = vec[0].S;\n    if(p+s-f<=x){\n      a.push_back(MP(f,s));\n      p += s-f+1;\n      vec.pop_front();\n    }else if(p+s-f>x){\n      a.push_back(MP(f, f+x-p));\n      vec[0].F = f+x-p+1;\n      p = x+1;\n    }\n      }\n      while(p<=y){\n    int f = vec[0].F, s = vec[0].S;\n    if(p+s-f<=y){\n      b.push_back(MP(f, s));\n      p += s-f+1;\n      vec.pop_front();\n    }else if(p+s-f>y){\n      b.push_back(MP(f, f+y-p));\n      vec[0].F = f+y-p+1;\n      p = y+1;\n    }\n      }\n \n      vec.insert(vec.end(), b.begin(), b.end());\n      vec.insert(vec.end(), a.begin(), a.end());\n \n    }\n \n \n    /*    rep(i, vec.size()){\n      for(int j=vec[i].F;j<=vec[i].S;j++) cout << j << endl;;\n      }*/\n    cout << countR(P, Q, R) << endl;\n  }\n"
  },
  {
    "language": "C++",
    "code": "#define _CRT_SECURE_NO_WARNINGS\n#include \"bits/stdc++.h\"\nusing namespace std;\n\n#define int int64_t\n\n#define CHOOSE(a) CHOOSE2 a\n#define CHOOSE2(a0,a1,a2,a3,x,...) x\n#define REP1(i, s, cond, cal) for (signed i = signed(s); i cond; i cal)\n#define REP2(i, s, n) REP1(i, s, < signed(n), ++)\n#define REP3(i, n) REP2(i, 0, n)\n#define rep(...) CHOOSE((__VA_ARGS__,REP1,REP2,REP3))(__VA_ARGS__)\n#define rrep(i, s) rep(i, s, >= 0, --)\n\n#define all(c) begin(c), end(c)\n#define maxup(ans, x) (ans = (ans < x ? x : ans))\n#define minup(ans, x) (ans = (ans > x ? x : ans))\n\n#define breakif(cond) if(cond) break; else\n\nusing VV = vector<vector<int>>;\nusing V = vector<int>;\nusing P = pair<int, int>;\nusing IP = pair<int, P>;\n\ntemplate<typename T>\ninline void input(vector<T>& v) { for (auto& x : v) cin >> x; }\n\nsigned main() {\n\tint n, m, p, q, r;\n\tvector<P> pre(5000), next(5000);\n\twhile (cin >> n && n) {\n\t\tcin >> m >> p >> q >> r;\n\t\tpre.clear();\n\t\tpre.push_back(P(1, n));\n\t\tvector<P> a(m), b(m), c(m);\n\t\trep(i, m) {\n\t\t\ta.clear(); b.clear(); c.clear();\n\t\t\tnext.clear();\n\t\t\tint x, y; cin >> x >> y;\n\t\t\tint sum = 0;\n\t\t\tfor (P p : pre) {\n\t\t\t\tint tmp = p.second - p.first + 1;\n\t\t\t\tif (sum + tmp <= x) {\n\t\t\t\t\ta.push_back(p);\n\t\t\t\t} else if (y <= sum) {\n\t\t\t\t\tc.push_back(p);\n\t\t\t\t} else if (x <= sum && sum + tmp <= y) {\n\t\t\t\t\tb.push_back(p);\n\t\t\t\t} else if (sum < x && y < sum + tmp) {\n\t\t\t\t\tP fst = P(p.first, p.first + (x - sum) - 1);\n\t\t\t\t\tP snd = P(fst.second + 1, fst.second + (y - x));\n\t\t\t\t\tP trd = P(snd.second + 1, p.second);\n\t\t\t\t\ta.push_back(fst);\n\t\t\t\t\tb.push_back(snd);\n\t\t\t\t\tc.push_back(trd);\n\t\t\t\t} else if (sum < x && x < sum + tmp) {\n\t\t\t\t\tP fst = P(p.first, p.first + (x - sum) - 1);\n\t\t\t\t\tP snd = P(fst.second + 1, p.second);\n\t\t\t\t\ta.push_back(fst);\n\t\t\t\t\tb.push_back(snd);\n\t\t\t\t} else if (sum < y && y < sum + tmp) {\n\t\t\t\t\tP fst = P(p.first, p.first + (y - sum) - 1);\n\t\t\t\t\tP snd = P(fst.second + 1, p.second);\n\t\t\t\t\tb.push_back(fst);\n\t\t\t\t\tc.push_back(snd);\n\t\t\t\t}\n\t\t\t\tsum += tmp;\n\t\t\t}\n\t\t\tnext.insert(next.end(), all(c));\n\t\t\tnext.insert(next.end(), all(b));\n\t\t\tnext.insert(next.end(), all(a));\n\t\t\tpre = move(next);\n\t\t}\n\n\t\tint sum = 0;\n\t\tint ans = 0;\n\t\tp--;\n\t\tfor (P item : pre) {\n\t\t\tint tmp = item.second - item.first + 1;\n\t\t\tP ra = P(1ll << 60, 1ll << 60);\n\t\t\tif (sum + tmp <= p) {\n\t\t\t\t//skip\n\t\t\t} else if (q <= sum) {\n\t\t\t\t//skip\n\t\t\t} else if (p <= sum && sum + tmp <= q) {\n\t\t\t\tra = item;\n\t\t\t} else if (sum < p && q < sum + tmp) {\n\t\t\t\tint l = item.first + (p - sum);\n\t\t\t\tint r = l + (q - p);\n\t\t\t\tra = P(l, r);\n\t\t\t} else if (sum < p && p < sum + tmp) {\n\t\t\t\tint l = item.first + (p - sum);\n\t\t\t\tint r = item.second;\n\t\t\t\tra = P(l, r);\n\t\t\t} else if (sum < q && q < sum + tmp) {\n\t\t\t\tra = P(item.first, item.first + (q - sum) - 1);\n\t\t\t}\n\n\t\t\tans += max(0ll, min(r, ra.second) - ra.first + 1ll);\n\t\t\tsum += tmp;\n\t\t}\n\t\tcout << ans << endl;\n\t}\n}"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\nusing namespace std;\n\nint main()\n{\n    int n;\n    while(cin >> n, n){\n        int m, p, q, r;\n        cin >> m >> p >> q >> r; --p;\n        vector<pair<int, int>> a;\n        a.emplace_back(0, n);\n        while(m--){\n            int x, y;\n            cin >> x >> y;\n            vector<pair<int, int>> t[3] = {};\n            int it = 0, id = 0;\n            for(auto pp : a){\n                int c = pp.second - pp.first;\n                id += it == x || it == y;\n                if(it < x && y < it + c){\n                    t[id].emplace_back(pp.first, x - it + pp.first);\n                    id += 1;\n                    t[id].emplace_back(x - it + pp.first, y - it + pp.first);\n                    id += 1;\n                    t[id].emplace_back(y - it + pp.first, pp.second);\n                }\n                else if(it < x && x < it + c){\n                    t[id].emplace_back(pp.first, x - it + pp.first);\n                    id += 1;\n                    t[id].emplace_back(x - it + pp.first, pp.second);\n                }\n                else if(it < y && y < it + c){\n                    t[id].emplace_back(pp.first, y - it + pp.first);\n                    id += 1;\n                    t[id].emplace_back(y - it + pp.first, pp.second);\n                }\n                else{\n                    t[id].push_back(pp);\n                }\n                it += c;\n            }\n            a.clear();\n            for(int i = 2;i >= 0;i--){\n                for(auto& pp : t[i]){\n                    a.push_back(pp);\n                }\n            }\n        }\n        int res = 0;\n        int it = 0;\n        for(auto pp : a){\n            int c = pp.second - pp.first;\n            if(it <= p && q <= it + c){\n                int s = pp.first + p - it;\n                int t = pp.first + q - it;\n                res += max(0, min(t, r) - s);\n            }\n            else if(it <= p && p < it + c){\n                int s = pp.first + p - it;\n                int t = pp.second;\n                res += max(0, min(t, r) - s);\n            }\n            else if(it < q && q <= it + c){\n                int s = pp.first;\n                int t = pp.first + q - it;\n                res += max(0, min(t, r) - s);\n            }\n            else if(p <= it && it + c <= q){\n                int s = pp.first;\n                int t = pp.second;\n                res += max(0, min(t, r) - s);\n            }\n            it += c;\n        }\n        cout << res << endl;\n    }\n    return 0;\n}\n\n"
  },
  {
    "language": "C++",
    "code": "     #include <bits/stdc++.h>\n\n//    #include <boost/multiprecision/cpp_int.hpp>\n #define int long long\n #define inf  1000000007\n #define pa pair<int,int>\n #define ll long long\n #define pal pair<double,double>\n #define ppap pair<pa,int>\n//  #define PI 3.14159265358979323846\n  #define paa pair<int,char>\n  #define  mp make_pair\n  #define  pb push_back\n  #define EPS (1e-10)\n                                          \n    int dx[8]={0,-1,0,1,1,1,-1,-1};\n    int dy[8]={1,0,-1,0,-1,1,1,-1};\n                                            using namespace std;\n                                   \t\t\tclass pa3{\n                                            \tpublic:\n                                            \tint x,y,z;\n                                            \tpa3(int x=0,int y=0,int z=0):x(x),y(y),z(z) {}\n                                            \tbool operator < (const pa3 &p) const{\n                                            \t\tif(x!=p.x) return x<p.x;\n                                            \t\tif(y!=p.y) return y<p.y;\n                                            \t\t return z<p.z;\n                                            \t\t//return x != p.x ? x<p.x: y<p.y;\n                                            \t}\n                                   \t\t\t\tbool operator > (const pa3 &p) const{\n                                            \t\tif(x!=p.x) return x>p.x;\n                                            \t\tif(y!=p.y) return y>p.y;\n                                            \t\t return z>p.z;\n                                            \t\t//return x != p.x ? x<p.x: y<p.y;\n                                            \t}\n                                            \tbool operator == (const pa3 &p) const{\n                                            \t\treturn x==p.x && y==p.y && z==p.z;\n                                            \t}\n                                            \t\tbool operator != (const pa3 &p) const{\n                                            \t\t\treturn !( x==p.x && y==p.y && z==p.z);\n                                            \t}\n                                            \n                                            };\n                                            \n                                            class pa4{\n                                            \tpublic:\n                                            \tdouble x;\n                                            \tint y,z,w;\n                                            \tpa4(double x=0,int y=0,int z=0,int w=0):x(x),y(y),z(z),w(w) {}\n                                            \tbool operator < (const pa4 &p) const{\n                                            \t\tif(x!=p.x) return x<p.x;\n                                            \t\tif(y!=p.y) return y<p.y;\n                                            \t\tif(z!=p.z)return z<p.z;\n                                            \t\treturn w<p.w;\n                                            \t\t//return x != p.x ? x<p.x: y<p.y;\n                                            \t}\n                                            \tbool operator > (const pa4 &p) const{\n                                            \t\tif(x!=p.x) return x>p.x;\n                                            \t\tif(y!=p.y) return y>p.y;\n                                            \t\tif(z!=p.z)return z>p.z;\n                                            \t\treturn w>p.w;\n                                            \t\t//return x != p.x ? x<p.x: y<p.y;\n                                            \t}\n                                            \tbool operator == (const pa4 &p) const{\n                                            \t\treturn x==p.x && y==p.y && z==p.z &&w==p.w;\n                                            \t}\n                                            \t\t\n                                            \n                                            };\n                                            class pa2{\n                                            \tpublic:\n                                            \tint x,y;\n                                            \tpa2(int x=0,int y=0):x(x),y(y) {}\n                                            \tpa2 operator + (pa2 p) {return pa2(x+p.x,y+p.y);}\n                                            \tpa2 operator - (pa2 p) {return pa2(x-p.x,y-p.y);}\n                                            \tbool operator < (const pa2 &p) const{\n                                            \t\treturn y != p.y ? y<p.y: x<p.x;\n                                            \t}\n                                            \tbool operator > (const pa2 &p) const{\n                                            \t\treturn x != p.x ? x<p.x: y<p.y;\n                                            \t}\n                                            \tbool operator == (const pa2 &p) const{\n                                            \t\treturn abs(x-p.x)==0 && abs(y-p.y)==0;\n                                            \t}\n                                            \tbool operator != (const pa2 &p) const{\n                                            \t\treturn !(abs(x-p.x)==0 && abs(y-p.y)==0);\n                                            \t}\n                                            \t\t\n                                            \n                                            };\n                                            \n/*\n                                            class Point{\n                                            \tpublic:\n                                            \tdouble x,y;\n                                            \tPoint(double x=0,double y=0):x(x),y(y) {}\n                                            \tPoint operator + (Point p) {return Point(x+p.x,y+p.y);}\n                                            \tPoint operator - (Point p) {return Point(x-p.x,y-p.y);}\n                                            \tPoint operator * (double a) {return Point(x*a,y*a);}\n                                            \tPoint operator / (double a) {return Point(x/a,y/a);}\n                                            \tdouble absv() {return sqrt(norm());}\n                                            \tdouble norm() {return x*x+y*y;}\n                                            \tbool operator < (const Point &p) const{\n                                            \t\treturn x != p.x ? x<p.x: y<p.y;\n                                            \t}\n                                            \tbool operator == (const Point &p) const{\n                                            \t\treturn fabs(x-p.x)<EPS && fabs(y-p.y)<EPS;\n                                            \t}\n                                            };\n                                            typedef Point Vector;\n                                     #define pl pair<int,pas>\n                                            struct Segment{\n                                            Point p1,p2;\n                                            };\n                                             double dot(Vector a,Vector b){\n                                            \treturn a.x*b.x+a.y*b.y;\n                                            }\n                                            double cross(Vector a,Vector b){\n                                            \treturn a.x*b.y-a.y*b.x;\n                                            }\n                                        \n                bool parareru(Point a,Point b,Point c,Point d){\n                //\tif(abs(cross(a-b,d-c))<EPS)cout<<\"dd \"<<cross(a-b,d-c)<<endl;\n                \treturn abs(cross(a-b,d-c))<EPS;\n                }\n                double distance_ls_p(Point a, Point b, Point c) {\n                  if ( dot(b-a, c-a) < EPS ) return (c-a).absv();\n                  if ( dot(a-b, c-b) < EPS ) return (c-b).absv();\n                  return abs(cross(b-a, c-a)) / (b-a).absv();\n                }\n                bool is_intersected_ls(Segment a,Segment b) {\n                \tif(a.p1==b.p1||a.p2==b.p1||a.p1==b.p2||a.p2==b.p2) return false;\n                \tif(parareru((a.p2),(a.p1),(a.p1),(b.p2))&&parareru((a.p2),(a.p1),(a.p1),(b.p1))){\n                //\t\tcout<<\"sss\"<<endl;\n                \t\tif(dot(a.p1-b.p1,a.p1-b.p2)<EPS) return true;\n                \t\tif(dot(a.p2-b.p1,a.p2-b.p2)<EPS) return true;\n                \t\tif(dot(a.p1-b.p1,a.p2-b.p1)<EPS) return true;\n                \t\tif(dot(a.p1-b.p2,a.p2-b.p2)<EPS) return true;\n                \t\treturn false;\n                \t}\n                  else return ( cross(a.p2-a.p1, b.p1-a.p1) * cross(a.p2-a.p1, b.p2-a.p1) < EPS ) && ( cross(b.p2-b.p1, a.p1-b.p1) * cross(b.p2-b.p1, a.p2-b.p1) < EPS );\n                }\n                 \n                double segment_dis(Segment a,Segment b){\n                \tif(is_intersected_ls(a,b))return 0;\n                \tdouble r=distance_ls_p(a.p1, a.p2, b.p1);\n                \tr=min(r,distance_ls_p(a.p1, a.p2, b.p2));\n                \tr=min(r,distance_ls_p(b.p1, b.p2, a.p2));\n                \tr=min(r,distance_ls_p(b.p1, b.p2, a.p1));\n                \treturn r;\n                }\n                Point intersection_ls(Segment a, Segment b) {\n                  Point ba = b.p2-b.p1;\n                  double d1 = abs(cross(ba, a.p1-b.p1));\n                  double d2 = abs(cross(ba, a.p2-b.p1));\n                  double t = d1 / (d1 + d2);\n                 \n                  return a.p1 + (a.p2-a.p1) * t;\n                }\n */                \n                                string itos( int i ) {\n                                ostringstream s ;\n                                s << i ;\n                                return s.str() ;\n                                }\n                                 \n                                int gcd(int v,int b){\n                                \tif(v>b) return gcd(b,v);\n                                \tif(v==b) return b;\n                                \tif(b%v==0) return v;\n                                \treturn gcd(v,b%v);\n                                }\n                 \n                                double distans(double x1,double y1,double x2,double y2){\n                                \tdouble rr=(x1-x2)*(x1-x2)+(y1-y2)*(y1-y2);\n                                \treturn sqrt(rr);\n                                \t\n                                }\n                                int mod;\n                                \n                int pr[500010];\n                int inv[500010];\n                \n                int beki(int wa,int rr,int warukazu){\n                \tif(rr==0) return 1%warukazu;\n                \tif(rr==1) return wa%warukazu;\n                \tif(rr%2==1) return (beki(wa,rr-1,warukazu)*wa)%warukazu;\n                \tint zx=beki(wa,rr/2,warukazu);\n                \treturn (zx*zx)%warukazu;\n                }\n    double bekid(double w,int r){\n    \tif(r==0) return 1.0;\n    \tif(r==1) return w;\n    \tif(r%2) return bekid(w,r-1)*w;\n    \tdouble f=bekid(w,r/2);\n    \treturn f*f;\n    }\n                \n    \t\t\tint comb(int nn,int rr){\n    \t\t\t\tint r=pr[nn]*inv[rr];\n    \t\t\t\tr%=mod;\n    \t\t\t\tr*=inv[nn-rr];\n    \t\t\t\tr%=mod;\n    \t\t\t\treturn r;\n    \t\t\t}\n                \n                void gya(int ert){\n                \tpr[0]=1;\n                \tfor(int i=1;i<ert;i++){\n                \t\tpr[i]=(pr[i-1]*i)%mod;\n                \t}\n                \tfor(int i=0;i<ert;i++) inv[i]=beki(pr[i],mod-2,mod);\n                \t\n                }\n                \n              //   cin.tie(0);\n    \t\t//\tios::sync_with_stdio(false);\n    \t\t\t//priority_queue<pa3,vector<pa3>,greater<pa3>> pq;            \n                 //sort(ve.begin(),ve.end(),greater<int>());\n                                         //----------------kokomade tenpure------------\n                //vector<double> ans(100000000),ans2(100000000)\n    \n    vector<pa> ve;\n      \nint n,m,p,q,r;\n  signed main(){\n    \t       cin.tie(0);\n    \t\t\tios::sync_with_stdio(false);\nwhile(1){\ncin>>n;\nif(n==0)exit(0);\nve.clear();\n cin>> \tm>>p>>q>>r;\n  \tve.pb(mp(1,r));\n  \t\n  \tfor(int rr=0;rr<m;rr++){\n  \t\tint x,y;\n  \t\tcin>>x>>y;\n  \t\t\n  \t\tint l=ve.size();\n  \t\tfor(int i=0;i<l;i++){\n  \t\t\tif(ve[i].first<=x && ve[i].second>=y+1){\n  \t\t\t\tve.pb(mp(x+1,y));\n  \t\t\t\tve.pb(mp(y+1,ve[i].second));\n  \t\t\t\tve[i].second=x;\n  \t\t\t}\n  \t\t\telse if(ve[i].first<=x && ve[i].second>=x+1){\n  \t\t\t\tve.pb(mp(x+1,ve[i].second));\n  \t\t\t\tve[i].second=x;\n  \t\t\t}\n  \t\t\telse if(ve[i].first<=y && ve[i].second>=y+1){\n  \t\t\t\tve.pb(mp(y+1,ve[i].second));\n  \t\t\t\tve[i].second=y;\n  \t\t\t}\n  \t\t}\n  \t\tl=ve.size();\n  \t\t\n  \t\tfor(int i=0;i<l;i++){\n  \t\t\t\n  \t\t\tif(ve[i].second<=x){\n  \t\t\t\tve[i].first+=n-x;\n  \t\t\t\tve[i].second+=n-x;\n  \t\t\t}\n  \t\t\telse if(ve[i].second<=y){\n  \t\t\tve[i].first+=n-x-y;\n  \t\t\t\tve[i].second+=n-x-y;\n  \t\t\t}\n  \t\t\telse{\n  \t\t\tve[i].first+=-y;\n  \t\t\t\tve[i].second+=-y;\n  \t\t\t}\n  \t\t}\n  \t\t\n  \t\t\n  \t\t\n  \t}\n  \tint ans=0;\n  \tfor(auto v:ve){\n  \t//\tcout<<v.first<<\" \"<<v.second<<endl;\n  \t\tint l=max(p,v.first);\n  \t\tint r=min(q,v.second);\n  \t\tif(l<=r) ans+=r-l+1;\n  \t}\n  \tcout<<ans<<endl;\n  \t}\n  \treturn 0;\n    }\n\n"
  },
  {
    "language": "C++",
    "code": "#include <iostream>\n#include <deque>\nusing namespace std;\n\nclass Card{\npublic:\n\tint f,t;\n\n\tCard(int from,int to){\n\t\tf = from;\n\t\tt = to;\n\t}\n};\n\nint n,m,p,q,r;\ndeque<Card> d;\n\ndeque<Card> removeCard(int x){\n\tdeque<Card> res;\n\n\twhile(1){\n\t\tCard tmp = d.front(); d.pop_front();\n\t\tx -= tmp.t - tmp.f + 1;\n\n\t\tif(x <= 0){\n\t\t\tif(x != 0){\n\t\t\t\td.push_front(Card(tmp.t + x + 1, tmp.t));\n\t\t\t\ttmp.t += x;\n\t\t\t}\n\t\t\tres.push_back(tmp);\n\t\t\tbreak;\n\t\t}\n\t\tres.push_back(tmp);\n\t}\n\treturn res;\n}\n\nvoid shuffle(int x,int y){\n\tdeque<Card> A = removeCard(x);\n\tdeque<Card> B = removeCard(y-x);\n\tfor(int i=0;i<B.size();i++) d.push_back(B[i]);\n\tfor(int i=0;i<A.size();i++) d.push_back(A[i]);\n}\n\nint main(void){\n\twhile(cin>>n,n){\n\t\tcin>>m>>p>>q>>r;\n\t\td.clear();\n\t\td.push_back(Card(1,n));\n\t\twhile(m--){\n\t\t\tint x,y;\n\t\t\tcin>>x>>y;\n\t\t\tshuffle(x,y);\n\t\t}\n\n\t\tint ans = 0;\n\t\tremoveCard(p-1);\n\t\tdeque<Card> rem = removeCard(q-p+1);\n\t\tfor(int i=0;i<rem.size();i++){\n\t\t\tif(rem[i].f <= r) ans += r - rem[i].f - (rem[i].t < r ? r-rem[i].t : 0) + 1;\n\t\t}\n\t\tcout<<ans<<endl;\n\t}\n\n\treturn 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include<iostream>\n#include<stdio.h>\n#include<math.h>\n#include    <iomanip>\n#include    <map>\n#include    <set>\n#include    <vector>\nusing namespace std;\nvector<int> func(vector<int> &vec,int a,int b){\n    vector<int> v1,v2,v3;\n    int flag=1;\n    //1-a\n    for(auto it:vec){\n        if (flag<=a) {\n            v1.push_back(it);\n        }else if (flag<=b){\n            v2.push_back(it);\n        }else{\n            v3.push_back(it);\n        }\n        flag++;\n    }\n    \n    for(auto it:v2){\n        v3.push_back(it);\n    }\n    for(auto it:v1){\n        v3.push_back(it);\n    }\n    //a+1 - b\n    //b+1 - n1\n    return v3;\n}\nint a[1000][2];\nint main(){\n    int n1,n2,n3,n4;\n    while(cin>>n1&&n1!=0){\n        cin>>n2;\n        int p,q,r;\n        cin>>p>>q>>r;;\n        \n        for (int i=0; i<n2; i++) {\n            for (int j=0; j<2; j++) {\n                cin>>a[i][j];\n            }\n        }\n        \n        //1-n1\n        vector<int> vec;\n        for(int i=1;i<n1+1;i++){\n            vec.push_back(i);\n        }\n        \n        for (int i=0; i<n2; i++) {\n            vec=func(vec,a[i][0],a[i][1]);\n        }\n        int sum=0;\n        for(int i=p;i<=q;i++){\n            if(vec[i-1]<=r)sum++;\n        }\n        cout<<sum<<endl;\n    }\n    return 0;\n}"
  },
  {
    "language": "C++",
    "code": "\n#include<iostream>\n#include<vector>\n#include<algorithm>\nusing namespace std;\n\nclass Deck\n{\npublic:\n  int start, end;\n  Deck(int s, int e)\n  {\n    start = s;\n    end = e;\n  }\n\n  vector<Deck> divide(int a, int b = -1)\n  {\n    vector<Deck> v;\n    v.push_back(Deck(start, a));\n    if(b == -1)\n      v.push_back(Deck(a   1, end));\n    else\n      v.push_back(Deck(a   1, b));\n      v.push_back(Deck(b   1, end));\n    return v;\n  }\n\n  int get_ans(int n, int p, int q, int r)\n  {\n    int s = max(n, p);\n    int res = min(min(q - s   1, end - start   n - s   1), r - start);\n    if(res < 0)\n      res = 0;\n    cout << start << \" \" << end << \":\" << s << \" \" << res << endl;\n    return res;\n  }\n\n  int size()\n  {\n    return end - start   1;\n  }\n};\n\nint main()\n{\n  vector<Deck> vp;\n  vector<Deck> *v = "
  },
  {
    "language": "C++",
    "code": "#include <cstdio>\n#include <cstring>\n#include <vector>\n#include <algorithm>\n\nusing namespace std;\n\ntypedef pair<int,int>P;\n\nint N;\nvector<P>card;\n\nint main(){\n  while(scanf(\"%d\", &N) && N){\n    card.clear();\n    card.push_back(P(1,N));\n    int m,p,q,r;\n    scanf(\"%d%d%d%d\",&m,&p,&q,&r);\n    for(int i=0;i<m;i++){\n      int x,y; scanf(\"%d%d\",&x,&y);\n      vector<P>A,B,C;\n      int pos = 0;\n      while(pos <= x){\n\tif(pos + (card[0].second-card[0].first+1) > x){\n\t  A.push_back(P(card[0].first, card[0].first+x-pos-1));\n\t  card[0].first += x-pos;\n\t  pos = x+1;\n\t  break;\n\t}\n\tpos += card[0].second-card[0].first+1;\n\tA.push_back(card[0]);\n\tcard.erase(card.begin());\n      }\n      while(pos <= y){\n\tif(pos + (card[0].second-card[0].first+1) > y){\n\t  B.push_back(P(card[0].first, card[0].first+y-pos));\n\t  card[0].first += y-pos+1;\n\t  pos = y+1;\n\t  break;\n\t}\n \tpos += card[0].second-card[0].first+1;\n\tB.push_back(card[0]);\n\tcard.erase(card.begin());\n      }    \n      card.insert(card.end(), B.begin(), B.end());\n      card.insert(card.end(), A.begin(), A.end());\n    }\n    \n    //    for(int i=0;i<card.size();i++) printf(\"%d %d\\n\", card[i].first, card[i].second);\n    int pos = 1;\n    int res = 0;\n    for(int i=0;i<card.size();i++){\n      if(p <= pos && pos <= q){\n\t//\tprintf(\"%d 1\\n\", i);\n\tif(pos + card[i].second-card[i].first+1 < q){\n\t  if(card[i].first <= r && card[i].second <= r) res += card[i].second-card[i].first+1;\n\t  else if(card[i].first <= r) res += r-card[i].first+1;\n\t}else if(pos + card[i].second-card[i].first+1 >= q){\n\t  int vl = card[i].first, vr = card[i].first+q-pos;\n\t  //\t  printf(\"%d %d %d\\n\",pos, vl ,vr);\n\t  if(vl <= r && vr <= r) res += vr-vl+1;\n\t  else if(vl <= r) res += r-vl+1;\n\t}\n\t//\tprintf(\"%d\\n\", res);\n      }else if(pos + card[i].second-card[i].first+1 > p && pos <= q){\n\t//\tprintf(\"%d 2\\n\", i);\n\tint vl = card[i].first + p-pos;\n\t//\tprintf(\"vl %d\\n\", vl);\n\tif(pos + card[i].second-card[i].first+1 < q){\n\t  if(vl <= r && card[i].second <= r) res += card[i].second-vl+1;\n\t  else if(vl <= r) res += r - vl + 1;\n\t}else if(pos + card[i].second - card[i].first+ 1 >= q){\n\t  int vr = vl + q - pos;\n\t  if(vl <= r && vr <= r) res += vr-vl+1;\n\t  else if(vl <= r) res += r-vl+1;\n\t}\n\t//\tprintf(\"%d\\n\", res);\n      }\n      pos += card[i].second-card[i].first+1;\n    }\n    printf(\"%d\\n\", res);\n  }\n  return 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include <iostream>\n#include <list>\n\n#define T_CT 1\n#define T_NC 2\n\nusing namespace std;\n\ntypedef struct\n{\n\tint count;\n\tint type;\n} bulk;\n\nint N,M,P,Q,R;\nlist<bulk> S;\nbulk tb;\n\nbulk* makebulk(int count,int type)\n{\n\ttb.count = count;\n\ttb.type = type;\n\treturn &tb;\n}\n\nvoid shuffle(int x,int y)\n{\n\tint sum = 0;\n\tint countv = 0;\n\tauto endi = S.end();\n\tauto sfront = S.begin();\n\twhile(true)\n\t{\n\t\tsfront = S.begin();\n\t\tif(sum + sfront->count <= x)\n\t\t{\n\t\t\tS.push_back(*sfront);\n\t\t\tsum += sfront->count;\n\t\t\tS.pop_front();\n\t\t\tcountv++;\n\t\t}\n\t\telse\n\t\t{\n\t\t\tif(sum != x)\n\t\t\t{\n\t\t\t\tsfront->count -= x - sum;\n\t\t\t\tS.push_back(*makebulk(x-sum,sfront->type));\n\t\t\t\tcountv++;\n\t\t\t}\n\t\t\tbreak;\n\t\t}\n\t}\n\tsum = 0;\n\tfor(int i = 0;i < countv;i++)\n\t{\n\t\tendi--;\n\t}\n\twhile(true)\n\t{\n\t\tsfront = S.begin();\n\t\tif(sum + sfront->count <= y-x)\n\t\t{\n\t\t\tS.insert(endi,*sfront);\n\t\t\tsum += sfront->count;\n\t\t\tS.pop_front();\n\t\t}\n\t\telse\n\t\t{\n\t\t\tif(sum != y-x)\n\t\t\t{\n\t\t\t\tsfront->count -= (y-x) - sum;\n\t\t\t\tS.insert(endi,*makebulk((y-x)-sum,sfront->type));\n\t\t\t\tendi++;\n\t\t\t}\n\t\t\tbreak;\n\t\t}\n\t}\n\t/*\n\tfor(auto it = S.begin();it < S.end()-1;it++)\n\t{\n\t\tif(it->type == (it+1)->type)\n\t\t{\n\t\t\tit->count += (it+1)->count;\n\t\t\tS.erase(it+1);\n\t\t\tit--;\n\t\t}\n\t}\n\t*/\n}\n\nint main(void)\n{\n\twhile(true)\n\t{\n\t\tcin >> N;\n\t\tif(N == 0)\n\t\t\texit(0);\n\t\tcin >> M >> P >> Q >> R;\n\t\tS.clear();\n\t\tS.push_back(*makebulk(R,T_CT));\n\t\tS.push_back(*makebulk(N-R,T_NC));\n\t\tint a,b;\n\t\tfor(int i = 0;i < M;i++)\n\t\t{\n\t\t\tcin >> a >> b;\n\t\t\tshuffle(a,b);\n\t\t}\n\t\tint sum = 0;\n\t\tauto sfront = S.begin();\n\t\twhile(true)\n\t\t{\n\t\t\tsfront = S.begin();\n\t\t\tif(sum + sfront->count <= P-1)\n\t\t\t{\n\t\t\t\tsum += sfront->count;\n\t\t\t\tS.pop_front();\n\t\t\t}\n\t\t\telse\n\t\t\t{\n\t\t\t\tif(sum != P-1)\n\t\t\t\t{\n\t\t\t\t\tsfront->count -= (P-1)-sum;\n\t\t\t\t}\n\t\t\t\tbreak;\n\t\t\t}\n\t\t}\n\t\tsum = 0;\n\t\tint count = (Q - P) + 1;\n\t\tint result = 0;\n\t\twhile(true)\n\t\t{\n\t\t\tsfront = S.begin();\n\t\t\tif(sum + sfront->count <= count)\n\t\t\t{\n\t\t\t\tif(sfront->type == T_CT)\n\t\t\t\t{\n\t\t\t\t\tresult += sfront->count;\n\t\t\t\t}\n\t\t\t\tsum += sfront->count;\n\t\t\t\tS.pop_front();\n\t\t\t}\n\t\t\telse\n\t\t\t{\n\t\t\t\tif(sum != count)\n\t\t\t\t{\n\t\t\t\t\tif(sfront->type == T_CT)\n\t\t\t\t\t{\n\t\t\t\t\t\tresult += count - sum;\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t\tbreak;\n\t\t\t}\n\t\t}\n\t\tcout << result << endl;\n\t}\n}"
  },
  {
    "language": "C++",
    "code": "//確か、r以下とそれ以外の境界部分のインデックスをうごうごやっていた……気がする。\n//書いた当時のことを覚えていないので、誰か解読してください。\n\n#include <iostream>\n#include <algorithm>\n#include <vector>\nusing namespace std;\n\nint main(){\n\tint n, m, p, q, r, x, y;\n\tvector<int>::iterator itx, ity, it;\n\n\twhile( cin >> n >> m >> p >> q >> r ){\n\t\tvector<int> v1, v2;\n\t\tv1.push_back(0);\n\t\tv1.push_back(r);\n\t\t\n\t\tfor(int i = 0; i < m; ++i){\n\t\t\tcin >> x >> y;\n\t\t\titx = upper_bound(v1.begin(), v1.end(), x);\n\t\t\tity = upper_bound(v1.begin(), v1.end(), y);\n\t\t\t\n\t\t\tif( (ity - v1.begin()) % 2 == 0 ){\tv2.push_back(0);\t}\n\t\t\tv2.push_back(0);\n\n\t\t\tfor(it = ity; it != v1.end(); ++it){\n\t\t\t\tv2.push_back(*it - y);\n\t\t\t}\n\n\t\t\tif( (v1.end() - itx) % 2 != 0 ){\tv2.push_back(n - y);\t}\n\t\t\tfor(it = itx; it != ity; ++it){\n\t\t\t\tv2.push_back(*it - x + n - y);\n\t\t\t}\n\t\t\t\n\t\t\tit = v1.begin();\n\t\t\tif( (ity - v1.begin()) % 2 != 0 ){\t++it;\t}\n\t\t\tif( !it[1] ){\n\t\t\t\t it += 2;\t//重複排除\n\t\t\t}\n\t\t\tif( *it + n - x == v2.back() ){\t//重複排除\n\t\t\t\t++it;\n\t\t\t\tv2.pop_back();\n\t\t\t}\n\t\t\tfor( ; it != itx; ++it){\n\t\t\t\tv2.push_back(*it + n - x);\n\t\t\t}\n\n\t\t\tv1.swap(v2);\n\t\t\tv2.clear();\n\t\t}\n/*\n\t\tv1.insert( upper_bound(v1.begin(), v1.end(), p - 1), 2, p - 1);\n\t\tv1.insert( lower_bound(v1.begin(), v1.end(), q), q);\n\t\tv1.push_back(n);\n\n\t\tit = upper_bound(v1.begin(), v1.end(), p - 1);\n\t\tif( (it - v1.begin()) % 2 != 0) --it;\n\n\t\tint ans = 0;\n\t\tfor( ; *it < q; ++it){\n\t\t\tint prev = *it;\n\t\t\t++it;\n\t\t\tans += *it - prev;\n\t\t}\n\t\t\n\t\tcout << ans << '\\n';*/\n\t}\n}"
  },
  {
    "language": "C++",
    "code": "#include<bits/stdc++.h>\nusing namespace std;\n\nclass Bundle {\npublic:\n  Bundle(int t, int b) : top_(t), bottom_(b) {}\n  int top() const {return top_;}\n  int bottom() const {return bottom_;}\n  int size() const {return bottom() - top() + 1;}\n  int count(int r) const {\n    if(r < top()) return 0;\n    if(bottom() <= r) return size();\n    return r - top() + 1;\n  }\n  Bundle split(int i) {\n    Bundle res(i, bottom());\n    bottom_ = i - 1;\n    return res;\n  }\nprivate:\n  int top_, bottom_;\n};\n\nint main() {\n  int n;\n  while(cin >> n, n) {\n    int m;\n    cin >> m;\n    int p, q, r;\n    cin >> p >> q >> r;\n\n    vector<Bundle> bundle;\n    bundle.emplace_back(1, n);\n\n    for(int k = 0; k < m; ++k) {\n      int x, y;\n      cin >> x >> y;\n      int cnt = 0;\n      for(int i = 0; i < bundle.size(); ++i) {\n        cnt += bundle[i].size();\n        if(cnt < x) continue;\n        if(cnt != x) bundle.insert(begin(bundle) + i + 1, bundle[i].split(bundle[i].top() + bundle[i].size() - (cnt - x)));\n        cnt = x;\n        ++i;\n        for(int j = i; j < bundle.size(); ++j) {\n          cnt += bundle[j].size();\n          if(cnt < y) continue;\n          if(cnt != y) bundle.insert(begin(bundle) + j + 1, bundle[j].split(bundle[j].top() + bundle[j].size() - (cnt - y)));\n          auto A = vector<Bundle>(begin(bundle), begin(bundle) + i);\n          auto B = vector<Bundle>(begin(bundle) + i, begin(bundle) + j + 1);\n          auto C = vector<Bundle>(begin(bundle) + j + 1, end(bundle));\n          bundle = A;\n          bundle.insert(begin(bundle), begin(B), end(B));\n          bundle.insert(begin(bundle), begin(C), end(C));\n          break;\n        }\n        break;\n      }\n    }\n\n    int answer = 0;\n    int cnt = 0;\n    for(int i = 0; i < bundle.size(); ++i) {\n      cnt += bundle[i].size();\n      if(cnt < p - 1) continue;\n      if(cnt != p - 1) bundle.insert(begin(bundle) + i + 1, bundle[i].split(bundle[i].top() + bundle[i].size() - (cnt - p + 1)));\n      cnt = p - 1;\n      ++i;\n      for(int j = i; j < bundle.size(); ++j) {\n        cnt += bundle[j].size();\n        if(cnt < q) continue;\n        if(cnt != q) bundle.insert(begin(bundle) + j + 1, bundle[j].split(bundle[j].top() + bundle[j].size() - (cnt - q)));\n        for(int k = i; k <= j; ++k) answer += bundle[k].count(r);\n        break;\n      }\n      break;\n    }\n    cout << answer << endl;\n  }\n}"
  },
  {
    "language": "C++",
    "code": "#include<deque>\n#include<list>\n#include<map>\n#include<queue>\n#include<set>\n#include<stack>\n#include<vector>\n#include<algorithm>\n#include<string>\n#include<iostream>\n#include<sstream>\n#include<cmath>\n#include<cstdio>\nusing namespace std;\npair<int,int> a[11000],b[11000];\nint sm,l;\nint fi(int i,int p){\n  for(;sm<p;++i)\n    sm+=a[i].second;\n  if(sm>p){\n    copy_backward(a+i,a+l,a+l+1);\n    ++l;\n    a[i-1].second-=sm-p;\n    a[i]=make_pair(a[i-1].first+a[i-1].second,sm-p);\n    sm=p;\n  }\n  return i;\n}\nint main(){\n  int i,j,k;\n  int n;\n  while(cin>>n){\n    int m,p,q,r;\n    cin>>m>>p>>q>>r;\n    if(r==n){\n      for(i=0;i<m;++i){\n\tint x,y;\n\tcin>>x>>y;\n      }\n      cout<<q-p+1<<endl;\n      continue;\n    }else{\n      a[0]=make_pair(1,r);\n      a[1]=make_pair(r+1,n-r);\n      l=2;\n    }\n    for(i=0;i<m;++i){\n      int x,y;\n      cin>>x>>y;\n      sm=0;\n      j=fi(0,x);\n      k=fi(j,y);\n      copy(a+k,a+l,b);\n      copy(a+j,a+k,b+l-k);\n      copy(a,a+j,b+l-j);\n      copy(b,b+l,a);\n    }\n    sm=0;\n    j=fi(0,p-1);\n    k=fi(j,q);\n    int ct=0;\n    for(i=j;i<k;++i){\n      if(a[i].first<=r)\n\tct+=a[i].second;\n    }\n    cout<<ct<<endl;\n  }\n  return 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include<iostream>\n#include<vector>\n#include<algorithm>\nusing namespace std;\nstruct data{int l,r,lv,rv;};\n\nint n,m,p,q,r;\nvector< data > t;\n\nvoid func(){\n  int u[3]={0,0,1e9},id=0;\n  cin>>u[0]>>u[1];\n  vector< data > A[3];\n\n  for(int i=0;i<(int)t.size();i++){\n    data a=t[i];\n    if(a.l==u[id]+1)id++;\n    if(a.r<=u[id])A[id].push_back(a);\n    else{\n      int nrv=a.lv+u[id]-a.l;\n      A[id].push_back((data){0,0,a.lv,nrv});\n      a.l=u[id]+1;\n      a.lv=nrv+1;\n      t[i]=a;\n      i--;\n      id++;\n    }\n  }\n  t.clear();\n  int sum=0;\n  for(int i=2;i>=0;i--){\n    for(int j=0;j<(int)A[i].size();j++){\n      data a=A[i][j];\n      a.l=sum+1;\n      a.r=a.l+(a.rv-a.lv);\n      sum=a.r;\n      t.push_back(a);\n    }\n  }\n}\n\nint main(){\n  while(cin>>n&&n){\n    cin>>m>>p>>q>>r;\n    t.clear();\n    t.push_back((data){1,n,1,n});\n    for(int i=0;i<m;i++)func();\n    int ans=0;\n    for(int i=0;i<(int)t.size();i++){\n      data  a=t[i];\n      //cout<<a.l<<\" \"<<a.r<<\" \"<<a.lv<<\" \"<<a.rv<<\" \"<<ans<<endl;\n      if(r<a.lv || q<a.l || a.r<p)continue;\n      int L=max(p,a.l);\n      int R=min(a.r,min(q,a.l+(r-a.lv)));\n      ans+=(R-L+1);\n    }\n    cout<<ans<<endl;\n  }\n  return 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include <cstdio>\n#include <vector>\n#include <map>\nusing namespace std;\ntypedef pair<int, int> P;\ntypedef vector<P> vi;\n#define f first\n#define s second\n#define pb push_back\n#define sz(x) x.size()\nvi shuffle(int x, int y, vi c) {\n    int cnt=0, i;\n    int sz=sz(c);\n    vi res, temp1, temp2, temp3;\n    for (i=0; i<sz; i++) {\n        int s=c[i].f, e=c[i].s;\n        if (cnt+e-s+1>=x) {\n            temp1.pb(P(s,s+x-cnt-1));\n            break;\n        }\n        temp1.pb(c[i]); \n        cnt+=e-s+1;\n    }\n    if (cnt+c[i].s-c[i].f+1>=y) {\n        temp2.pb(P(c[i].f+x-cnt,c[i].f+y-cnt-1));\n        temp3.pb(P(c[i].f+y-cnt,c[i].s));\n        for (i+=1;i<sz; i++) temp3.pb(c[i]);\n    } else {\n        temp2.pb(P(c[i].f+x-cnt,c[i].s));\n        cnt+=c[i].s-c[i].f+1;\n        int a=++i;\n        for (;i<sz; i++) {\n            int s=c[i].f, e=c[i].s;\n            if (cnt+e-s+1>=y) {\n                temp2.pb(P(s,s+y-cnt-1));\n                break;\n            }\n            temp2.pb(c[i]);\n            cnt+=e-s+1;\n        }\n        if (cnt+c[i].s-c[i].f+1!=y) temp3.pb(P(c[i].f+y-cnt,c[i].s));\n        for (i+=1; i<sz; i++) temp3.pb(c[i]);\n    }\n/*\n    for (i=0; i<sz(temp1); i++) printf(\"%d %d\\n\",temp1[i].f,temp1[i].s);\n    puts(\"\");\n    for (i=0; i<sz(temp2); i++) printf(\"%d %d\\n\",temp2[i].f,temp2[i].s);\n    puts(\"\");\n    for (i=0; i<sz(temp3); i++) printf(\"%d %d\\n\",temp3[i].f,temp3[i].s);\n    puts(\"\");\n*/\n    for (i=0; i<sz(temp3); i++) res.pb(temp3[i]);\n    for (i=0; i<sz(temp2); i++) res.pb(temp2[i]);\n    for (i=0; i<sz(temp1); i++) res.pb(temp1[i]);\n    return res;\n}\n\nint main() {\n    int n, m, p, q, r;\n    while (scanf(\"%d\",&n)) {\n        if (!n) break;\n        scanf(\"%d%d%d%d\",&m,&p,&q,&r);\n        vi card;\n        card.pb(P(1,n));\n        for (int i=0; i<m; i++) {\n            int x, y; scanf(\"%d%d\",&x,&y);\n            card=shuffle(x,y,card);\n        }\n        int cnt=0, res=0;\n        for (int i=0; i<sz(card); i++) {\n            int s=card[i].f, e=card[i].s;\n//            printf(\"%d %d\\n\",s,e);\n            if (cnt+e-s+1>=p&&q>=cnt) {\n                int m=max(s+p-cnt-1,s), M=min(s+q-cnt-1,e);\n//                printf(\"%d %d\\n\",m,M);\n                if (r>=m&&r<=M) res+=r-m+1;\n                else if (r>=M) res+=M-m+1;\n            }\n            cnt+=e-s+1;\n        }\n        printf(\"%d\\n\",res);\n    }\n}"
  },
  {
    "language": "C++",
    "code": "#include <cstdio>\n#include <cstring>\n#include <cstdlib>\n#include <cmath>\n#include <complex>\n#include <string>\n#include <sstream>\n#include <algorithm>\n#include <vector>\n#include <queue>\n#include <stack>\n#include <functional>\n#include <iostream>\n#include <map>\n#include <set>\nusing namespace std;\ntypedef pair<int,int> P;\ntypedef long long ll;\ntypedef vector<int> vi;\ntypedef vector<ll> vll;\n#define pu push\n#define pb push_back\n#define mp make_pair\n#define eps 1e-9\n#define INF 2000000000\n#define sz(x) ((int)(x).size())\n#define fi first\n#define sec second\n#define SORT(x) sort((x).begin(),(x).end())\n#define all(x) (x).begin(),(x).end()\n#define EQ(a,b) (abs((a)-(b))<EPS)\nint n,m,p,q,r;\nstruct cards\n{\n\tint from,to;\n\tcards(int f,int t)\n\t{\n\t\tfrom=f,to=t;\n\t}\n};\ndeque<cards> all;\ndeque<cards> split(int k)\n{\n\tdeque<cards> sub;\n\tfor(;;)\n\t{\n\t\tcards t=all.front();\n\t\tall.pop_front();\n\t\tk -= t.to-t.from+1;\n\t\tif(k==0)\n\t\t{\n\t\t\tsub.pb(t);\n\t\t\tbreak;\n\t\t}\n\t\tif(k<0)\n\t\t{\n\t\t\tall.push_front(cards(t.to+k+1,t.to));\n\t\t\tt.to+=k;\n\t\t\tsub.pb(t);\n\t\t\tbreak;\n\t\t}\n\t\tsub.pb(t);\n\t}\n\treturn sub;\n}\nvoid shuffle(int x,int y)\n{\n\tdeque<cards> a=split(x);\n\tdeque<cards> b=split(y-x);\n\tfor(int i=0;i<b.size();i++)all.pb(b[i]);\n\tfor(int i=0;i<a.size();i++)all.pb(a[i]);\n}\nint main()\n{\n\twhile(1)\n\t{\n\t\tcin >> n;\n\t\tif(n==0)break;\n\t\tall.clear();\n\t\tall.pb(cards(1,n));\n\t\tcin >> m;\n\t\tcin >> p >> q >> r;\n\t\tfor(int i=0;i<m;i++)\n\t\t{\n\t\t\tint x,y;\n\t\t\tcin >> x >> y;\n\t\t\tshuffle(x,y);\n\t\t}\n\t\tint ans=0;\n\t\tsplit(p-1);\n\t\tdeque<cards> res=split(q-p+1);\n\t\tfor(int i=0;i<res.size();i++)\n\t\t{\n\t\t\tif(res[i].from<=r)\n\t\t\t{\n\t\t\t\tif(res[i].to>=r)\n\t\t\t\t{\n\t\t\t\t\tans+=r-res[i].from+1;\n\t\t\t\t}\n\t\t\t\telse\n\t\t\t\t{\n\t\t\t\t\tans+=res[i].to-res[i].from+1;\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t\tcout << ans << endl;\n\t}\n\treturn 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include<iostream>\n#include<vector>\n#include<algorithm>\n\nusing namespace std;\n\nvector<int> Shuffle(int, int, vector<int>);\n\nint main(){\n  int i, n, m, p, q, r, x, y, count;\n  vector<int> card;\n\n  while(1){\n    cin >> n;\n    if(n == 0) break;\n\n    for(i=0; i<n; ++i)\n      card.push_back(i+1);\n\n    cin >> m >> p >> q >> r;\n\n    for(i=0; i<m; ++i){\n      cin >> x >> y;\n      card = Shuffle(x, y, card);\n    }\n\n    count = 0;\n    for(i=p-1; i<q; ++i){\n      if(card[i] <= r) ++count;\n    }\n\n    cout << count << endl;\n    card.clear();\n  }\n\n  return 0;\n}\n\nvector<int> Shuffle(int x, int y, vector<int> before){\n  vector<int> after;\n\n  copy(before.begin()+y, before.end(), back_inserter(after));\n  copy(before.begin()+x, before.begin()+y, back_inserter(after));\n  copy(before.begin(), before.begin()+x, back_inserter(after));\n\n  return after;\n}"
  },
  {
    "language": "C++",
    "code": "//  4???27??\\  ????????????0535 ; ?????£?????????\n// http://judge.u-aizu.ac.jp/onlinejudge/description.jsp?id=0536\n\n#include <iostream>\n#define NUM 100000\nusing namespace std;\n\nint main(){\n\n  int n;//?????????????????°\n  int m;//?????£??????????????°\n  int p,q;//p ???????????? q ?????????????????????\n  int r;// r??\\?????????????????????????????????\n  int x[5000],y[5000];//????????????????????´???\n  int card[NUM];\n  int i;\n  int A[NUM];\n  int B[NUM];\n  int C[NUM];\n\n  do{\n    int j = 0;\n    int count = 1;\n    int step = 1;\n    int red = 1;\n    int blue = 1;\n    int green = 0;\n\n    cin >> n;\n    cin >> m;\n    cin >> p >> q >> r;\n\n    if (!n){\n      break;\n    }\n\n    for (i=0; i < m; i++){\n      cin >> x[i] >> y[i];\n    }\n\n    while (j < m){\n\n      for (i=1; i <= n; i++ ){//??°?????£??\\\n        card[i] = i;\n      }\n\n      for (i=1 ; i <= x[j] ;i++ ){//????????????1~X???????????§\n        A[i] = card[i];\n      }\n\n      while (i <= y[j]){//????????????X+1~Y???????????§\n        B[count] = card[i];\n        i++;\n        count++;\n      }\n\n      while (i <= n){//????????????Y+1~n???????????§\n        C[step] = card[i];\n        i++;\n        step++;\n      }\n\n      for (i=1; i <= (n - y[j]); i++ ){//C?????°?????£??\\\n        card[i] = C[i];\n      }\n\n      while (red <= count){//B?????°?????£??\\\n        card[i] = B[red];\n        i++;\n        red++;\n      }\n\n      while (blue <= step){//A?????°?????£??\\\n        card[i] = A[blue];\n        i++;\n        blue++;\n      }\n      j++;\n    }\n\n    for (i=p; i <= q; i++){\n      if (card[i] <= r){\n        green++;\n      }\n    }\n\n    cout << green << endl;\n  } while (n);\n\n  return 0;\n\n}"
  },
  {
    "language": "C++",
    "code": "#include<vector>\n#include<list>\n#include<algorithm>\n#include<iostream>\n#include<string>\n#include<cstdio>\n#include<cstdlib>\n#include<cstring>\n#include<cmath>\nusing namespace std;\nint main(){\n  int h,i;\n  int m,n,p,q,r,x,y;\n  int ct;\n  list<int> a,b,c;\n  list<int>::iterator it,jt,kt,lt;\n  while(cin>>n&&n){\n    cin>>m>>p>>q>>r;\n    a.clear();\n    a.push_back(1);\n    a.push_back(n);\n    for(h=0;h<m;h++){\n      cin>>x>>y;\n      it=jt=a.begin();\n      jt++;\n      for(i=0;i<x;){\n\tif(i+*jt-*it+1>x){\n\t  it=jt=kt=a.insert(a.insert(jt,*it+x-i),*it+x-i-1);\n\t  it++;\n\t  advance(jt,2);\n\t  kt++;\n\t  i=x;\n\t}else if(i+*jt-*it+1<x){\n\t  i+=*jt-*it+1;\n\t  advance(it,2);\n\t  advance(jt,2);\n\t}else if(i+*jt-*it+1==x){\n\t  advance(it,2);\n\t  advance(jt,2);\n\t  kt=it;\n\t  i=x;\n\t}\n      }\n      for(;i<y;){\n\tif(i+*jt-*it+1>y){\n\t  lt=a.insert(a.insert(jt,*it+y-i),*it+y-i-1);\n\t  lt++;\n\t  i=y;\n\t}else if(i+*jt-*it+1<y){\n\t  i+=*jt-*it+1;\n\t  advance(it,2);\n\t  advance(jt,2);\n\t}else if(i+*jt-*it+1==y){\n\t  lt=it;\n\t  advance(lt,2);\n\t  i=y;\n\t}\n      }\n      b.assign(a.begin(),kt);\n      c.assign(kt,lt);\n      a.erase(a.begin(),lt);\n      a.splice(a.end(),c);\n      a.splice(a.end(),b);\n    }\n    it=jt=a.begin();\n    jt++;\n    ct=0;\n    for(i=0;i<p;){\n      if(i+*jt-*it+1>=p){\n\tif(*it+p-i-1<=r&&r<=*jt)\n\t  ct+=r-*it-p+i+2;\n\telse if(*jt<r)\n\t  ct+=*jt-*it-p+i+2;\n\ti=p;\n\tadvance(it,2);\n\tadvance(jt,2);\n      }else{\n\ti+=*jt-*it+1;\n\tadvance(it,2);\n\tadvance(jt,2);\n      }\n    }\n    for(;i<q;){\n      if(i+*jt-*it+1>=q){\n\tif(*it<=r&&r<=*it+q-i-1)\n\t  ct+=r-*it+1;\n\telse if(*it+q-i-1<r)\n\t  ct+=q-i-1;\n\ti=q;\n      }else{\n\tif(*it<=r&&r<=*jt)\n\t  ct+=r-*it+1;\n\telse if(*jt<r)\n\t  ct+=*jt-*it+1;\n\ti+=*jt-*it+1;\n\tadvance(it,2);\n\tadvance(jt,2);\n      }\n    }\n    cout<<ct<<endl;\n  }\n  return 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include <cstdio>\n#include <vector>\n#include <map>\nusing namespace std;\ntypedef pair<int, int> P;\ntypedef vector<P> vi;\n#define f first\n#define s second\n#define pb push_back\n#define sz(x) x.size()\nvi c;\nvoid shuffle(int x, int y) {\n    int cnt=0, i;\n    int sz=sz(c);\n    vi temp1, temp2, temp3;\n    for (i=0; i<sz; i++) {\n        int s=c[i].f, e=c[i].s;\n        if (cnt+e-s+1>=x) {\n            temp1.pb(P(s,s+x-cnt-1));\n            break;\n        }\n        temp1.pb(c[i]); \n        cnt+=e-s+1;\n    }\n    if (cnt+c[i].s-c[i].f+1>=y) {\n        temp2.pb(P(c[i].f+x-cnt,c[i].f+y-cnt-1));\n        temp3.pb(P(c[i].f+y-cnt,c[i].s));\n        for (i+=1;i<sz; i++) temp3.pb(c[i]);\n    } else {\n        temp2.pb(P(c[i].f+x-cnt,c[i].s));\n        cnt+=c[i].s-c[i].f+1;\n        int a=++i;\n        for (;i<sz; i++) {\n            int s=c[i].f, e=c[i].s;\n            if (cnt+e-s+1>=y) {\n                temp2.pb(P(s,s+y-cnt-1));\n                break;\n            }\n            temp2.pb(c[i]);\n            cnt+=e-s+1;\n        }\n        if (cnt+c[i].s-c[i].f+1!=y) temp3.pb(P(c[i].f+y-cnt,c[i].s));\n        for (i+=1; i<sz; i++) temp3.pb(c[i]);\n    }\n/*\n    for (i=0; i<sz(temp1); i++) printf(\"%d %d\\n\",temp1[i].f,temp1[i].s);\n    puts(\"\");\n    for (i=0; i<sz(temp2); i++) printf(\"%d %d\\n\",temp2[i].f,temp2[i].s);\n    puts(\"\");\n    for (i=0; i<sz(temp3); i++) printf(\"%d %d\\n\",temp3[i].f,temp3[i].s);\n    puts(\"\");\n*/\n    for (i=0; i<sz(temp3); i++) c.pb(temp3[i]);\n    for (i=0; i<sz(temp2); i++) c.pb(temp2[i]);\n    for (i=0; i<sz(temp1); i++) c.pb(temp1[i]);\n}\n\nint main() {\n    int n, m, p, q, r;\n    while (scanf(\"%d\",&n)) {\n        if (!n) break;\n        scanf(\"%d%d%d%d\",&m,&p,&q,&r);\n        c=vi(1,P(1,n));\n        for (int i=0; i<m; i++) {\n            int x, y; scanf(\"%d%d\",&x,&y);\n            shuffle(x,y);\n        }\n        int cnt=0, res=0;\n        for (int i=0; i<sz(c); i++) {\n            int s=c[i].f, e=c[i].s;\n//            printf(\"%d %d\\n\",s,e);\n            if (cnt+e-s+1>=p&&q>=cnt) {\n                int m=max(s+p-cnt-1,s), M=min(s+q-cnt-1,e);\n//                printf(\"%d %d\\n\",m,M);\n                if (r>=m&&r<=M) res+=r-m+1;\n                else if (r>=M) res+=M-m+1;\n            }\n            cnt+=e-s+1;\n        }\n        printf(\"%d\\n\",res);\n    }\n}"
  },
  {
    "language": "C++",
    "code": "#include <vector>\n#include <iostream>\n#include <algorithm>\nusing namespace std;\nstruct query {\n\tint p1, p2;\n\tquery() : p1(0), p2(0) {};\n};\nint N, M, x1, x2, x3; vector<query> v;\nint main() {\n\twhile (cin >> N, N) {\n\t\tcin >> M >> x1 >> x2 >> x3; x1--; v.resize(M);\n\t\tfor (int i = 0; i < M; i++) cin >> v[i].p1 >> v[i].p2;\n\t\tvector<int> compress;\n\t\tcompress.push_back(0);\n\t\tcompress.push_back(N);\n\t\tcompress.push_back(x1);\n\t\tcompress.push_back(x2);\n\t\tfor (int i = 0; i < M; i++) {\n\t\t\tcompress.push_back(v[i].p1);\n\t\t\tcompress.push_back(v[i].p2);\n\t\t}\n\t\tsort(compress.begin(), compress.end());\n\t\tcompress.erase(unique(compress.begin(), compress.end()), compress.end());\n\t\tfor (int i = 0; i < M; i++) {\n\t\t\tv[i].p1 = lower_bound(compress.begin(), compress.end(), v[i].p1) - compress.begin();\n\t\t\tv[i].p2 = lower_bound(compress.begin(), compress.end(), v[i].p2) - compress.begin();\n\t\t}\n\t\tint z = compress.size();\n\t\tvector<int> x(z - 1);\n\t\tfor (int i = 0; i < z - 1; i++) x[i] = i;\n\t\tfor (int i = 0; i < M; i++) {\n\t\t\tvector<int> w;\n\t\t\tfor (int j = v[i].p2; j < z - 1; j++) w.push_back(x[j]);\n\t\t\tfor (int j = v[i].p1; j < v[i].p2; j++) w.push_back(x[j]);\n\t\t\tfor (int j = 0; j < v[i].p1; j++) w.push_back(x[j]);\n\t\t\tx = w;\n\t\t}\n\t\tint ret = 0, sum = 0;\n\t\tfor (int i = 0; i < z - 1; i++) {\n\t\t\tint l = sum, r = sum + compress[x[i] + 1] - compress[x[i]]; sum = r;\n\t\t\tif (!(x1 <= l && r <= x2)) continue;\n\t\t\tint ptr = x3 - compress[x[i]] + l;\n\t\t\tret += min(r - 1, ptr) - min(l - 1, ptr);\n\t\t}\n\t\tcout << ret << endl;\n\t}\n\treturn 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include<iostream>\n#include<vector>\nusing namespace std;\ntypedef pair<int,int>P;\ntypedef vector<P>V;\ntypedef V::iterator I;\nI divide(V&v,int x){\n\tI i=v.begin();\n\tint c=0;\n\tfor(;c<x;++i){\n\t\tc+=i->second-i->first;\n\t}\n\tint&s=i[-1].second;\n\ti=v.insert(i,P(s-(c-x),s));\n\ts-=c-x;\n\treturn i;\n}\nvoid shuffle(V&v,int x,int y){\n\tV v0;\n\tI ix,iy;\n\tv0.swap(v);\n\tv0.reserve(v0.size()+2);\n\tix=divide(v0,x);\n\tiy=divide(v0,y);\n\tv.insert(v.end(),iy,v0.end());\n\tv.insert(v.end(),ix,iy);\n\tv.insert(v.end(),v0.begin(),ix);\n}\nint main(){\n\tint n,m,p,q,r,x,y;\n\tfor(;cin>>n>>m>>p>>q>>r,n;){\n\t\tV v;\n\t\tv.push_back(P(1,n+1));\n\t\tv.push_back(P(n+1,n+1));\n\t\tfor(;m--;){\n\t\t\tcin>>x>>y;\n\t\t\tshuffle(v,x,y);\n\t\t}\n\t\tI is,ie;\n\t\tv.reserve(v.size()+2);\n\t\tis=divide(v,p-1);\n\t\tie=divide(v,q);\n\t\tint c=0;\n\t\tfor(;is!=ie;++is){\n\t\t\tif(is->second-1<=r){\n\t\t\t\tc+=is->second-is->first;\n\t\t\t}else if(is->first<=r){\n\t\t\t\tc+=r-is->first+1;\n\t\t\t}\n\t\t}\n\t\tcout<<c<<endl;\n\t}\n\tcout<<endl;\n}"
  },
  {
    "language": "C++",
    "code": "#include <set>\n#include <map>\n#include <list>\n#include <queue>\n#include <stack>\n#include <cmath>\n#include <ctime>\n#include <cstdio>\n#include <vector>\n#include <string>\n#include <bitset>\n#include <cctype>\n#include <cstdlib>\n#include <cstring>\n#include <utility>\n#include <numeric>\n#include <complex>\n#include <sstream>\n#include <fstream>\n#include <iomanip>\n#include <cassert>\n#include <iostream>\n#include <iterator>\n#include <algorithm>\n\nusing namespace std;\n\n//4方向ベクトル→↑←↓\nint dx[4] ={1,0,-1,0};\nint dy[4] ={0,-1,0,1};\n\nvector<int> Card;\nvector<int> Cardtemp;\nunsigned long n;//カードの枚数\nint m;//シャッフルの回数\nunsigned long x,y;//シャッフルする(x,y)\nunsigned long p,q,r;//p行q行以下に番号r以下のカードが何枚含まれているか\nint main()\n{\n  while(1){\n  scanf(\"%lu\",&n);\n  if(n==0)\n    break;\n  scanf(\"%d\",&m);\n  scanf(\"%lu %lu %lu\",&p,&q,&r);\n  Card.clear();\n  Cardtemp.clear();\n  for(int i = 1;i <=n;i++){\n    Card.push_back(i);\n  }\n  unsigned long ans = 0;\n  for(int i = 1;i <=m;i++){\n    Cardtemp = Card;\n    scanf(\"%lu %lu\",&x,&y);\n    for(int j = 0;j <=n-(y+1);j++){\n      Card[j] = Cardtemp[y+j];\n    }\n    for(int j = 0;j <=y-(x+1);j++){\n      Card[n-y+j] = Cardtemp[x+j];\n\t}\n    for(int j = 0;j <=x-1;j++){\n      Card[n-x+j] = Cardtemp[j];\n    }\n  }\n  for(int i = p-1;i < q;i++){\n    if(Card[i] <= r)\n      ans++;\n  }\n  printf(\"%lu\\n\",ans);\n  }\n  return 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include <iostream>\n#include <cstdio>\n#include <algorithm>\n#include <cmath>\n#include <vector>\n#include <queue>\n#include <deque>\n\nusing namespace std;\n\ntypedef pair<long long int, bool> P;\n\nint main(){\n\t\n\twhile(true){\n\t\tlong long int n, m, p, q, r;\n\t\tcin >> n;\n\t\tif(n == 0){\n\t\t\tbreak;\n\t\t}\n\t\tcin >> m >> p >> q >> r;\n\t\tdeque<P> v;\n\t\tP pp;\n\t\tpp.first = r;\n\t\tpp.second = true;\n\t\tv.push_back(pp);\n\t\tpp.first = n - r;\n\t\tpp.second = false;\n\t\tv.push_back(pp);\n\t\t\n\t\tfor(int i = 0; i < m; i++){\n\t\t\t\n\t\t\tint x, y;\n\t\t\tcin >> x >> y;\n\t\t\ty = n - y;\n\t\t\t\n\t\t\tdeque<P> v1, v2;\n\t\t\t\n\t\t\twhile(true){\n\t\t\t\tx -= v[0].first;\n\t\t\t\tif(x <= 0){\n\t\t\t\t\tP p2;\n\t\t\t\t\tp2.first = v[0].first + x;\n\t\t\t\t\tp2.second = v[0].second;\n\t\t\t\t\tv1.push_back(p2);\n\t\t\t\t\tv[0].first = -x;\n\t\t\t\t\tbreak;\n\t\t\t\t}\n\t\t\t\tv1.push_back(v[0]);\n\t\t\t\tv.pop_front();\n\t\t\t}\n\t\t\t\n\t\t\twhile(true){\n\t\t\t\tint sz = v.size();\n\t\t\t\ty -= v[sz - 1].first;\n\t\t\t\tif(y <= 0){\n\t\t\t\t\tP p2;\n\t\t\t\t\tp2.first = v[sz - 1].first + y;\n\t\t\t\t\tp2.second = v[sz - 1].second;\n\t\t\t\t\tv2.push_back(p2);\n\t\t\t\t\tv[sz - 1].first = -y;\n\t\t\t\t\tbreak;\n\t\t\t\t}\n\t\t\t\tv2.push_back(v[sz - 1]);\n\t\t\t\tv.pop_back();\n\t\t\t}\n\t\t\t\n\t\t\tfor(int i = 0; i < v1.size(); i++){\n\t\t\t\tv.push_back(v1[i]);\n\t\t\t}\n\t\t\t\n\t\t\tfor(int i = 0; i < v2.size(); i++){\n\t\t\t\tv.push_front(v2[i]);\n\t\t\t}\n\t\t}\n\t\t\n\t\tlong long int ans = 0;\n\t\t\n\t\tfor(int i = 0; i < v.size(); i++){\n\t\t\tq -= v[i].first;\n\t\t\tif(q <= 0){\n\t\t\t\tif(v[i].second){\n\t\t\t\t\tans += v[i].first + q;\n\t\t\t\t}\n\t\t\t\tbreak;\n\t\t\t}\n\t\t\tif(v[i].second){\n\t\t\t\tans += v[i].first;\n\t\t\t}\n\t\t}\n\t\t\n\t\tp--;\n\t\tfor(int i = 0; i < v.size(); i++){\n\t\t\tp -= v[i].first;\n\t\t\tif(p <= 0){\n\t\t\t\tif(v[i].second){\n\t\t\t\t\tans -= v[i].first + p;\n\t\t\t\t}\n\t\t\t\tbreak;\n\t\t\t}\n\t\t\tif(v[i].second){\n\t\t\t\tans -= v[i].first;\n\t\t\t}\n\t\t}\n\t\t\n\t\tcout << ans << endl;\n\t\t\n\t}\n\t\n\treturn 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include <iostream>\n#include <cstdio>\n#include <cstring>\n#include <cstdlib>\n#include <cmath>\n#include <vector>\n#include <string>\n#include <map>\n#include <set>\n#include <queue>\n#include <stack>\n#include <algorithm>\n#include <deque>\n\nusing namespace std;\n\n#define rep(i,j) REP((i), 0, (j))\n#define REP(i,j,k) for(int i=(j);(i)<(k);++i)\n#define BW(a,x,b) ((a)<=(x)&&(x)<=(b))\n#define ALL(v) (v).begin(), (v).end()\n#define LENGTHOF(x) (sizeof(x) / sizeof(*(x)))\n#define AFILL(a, b) fill((int*)a, (int*)(a + LENGTHOF(a)), b)\n#define SQ(x) ((x)*(x))\n#define Mod(x, mod) (((x)+(mod)%(mod))\n#define MP make_pair\n#define PB push_back\n#define F first\n#define S second\n#define INF 1 << 30\n#define EPS 1e-10\n#define MOD 1000000007\n\ntypedef pair<int, int> pi;\ntypedef pair<int, pi> pii;\ntypedef vector<int> vi;\ntypedef queue<int> qi;\ntypedef long long ll;\n\ndeque<pi>vec, a, b, c;\nint N, M, P, Q, R;\n\nint cnt(int p, int q, int r){\n  if(p > r) return 0;\n  if(r >= q) return q-p+1;\n  return r-p+1;\n}\n\nint countR(int p, int q, int r){\n  int n = 1, vp, res = 0;\n  for(vp=0;vp<vec.size();vp++){\n    int f = vec[vp].F, l = vec[vp].S;\n    int c = l-f+1;\n    if(n <= p){\n      if(n+c < p){\n      }\n      else if(n + c > q){\n\tres += cnt(f+p-n, f+q-n, r);\n      }else{\n\tres += cnt(f+p-n, l, r);\n      }\n      n += c;\n    }else if(n <= q){\n      if(n+c<=q){\n\tres += cnt(f, l, r);\n      }else{\n\tres += cnt(f, f+q-n, r);\n      }\n      n += c;\n    }\n  }\n  return res;\n}\n\n\nint main(){\n  while(1){\n    cin >> N;\n    if(!N) break;\n    cin >> M >> P >> Q >> R;\n    vec.clear();\n    vec.push_back(MP(1,N));\n    int x, y;\n    rep(i, M){\n      cin >> x >> y;\n      a.clear(); b.clear();\n      int p=1;\n      while(p<=x){\n\tint f = vec[0].F, s = vec[0].S;\n\tif(p+s-f<=x){\n\t  a.push_back(MP(f,s));\n\t  p += s-f+1;\n\t  vec.pop_front();\n\t}else if(p+s-f>x){\n\t  a.push_back(MP(f, f+x-p));\n\t  vec[0].F = f+x-p+1;\n\t  p = x+1;\n\t}\n      }\n      while(p<=y){\n\tint f = vec[0].F, s = vec[0].S;\n\tif(p+s-f<=y){\n\t  b.push_back(MP(f, s));\n\t  p += s-f+1;\n\t  vec.pop_front();\n\t}else if(p+s-f>y){\n\t  b.push_back(MP(f, f+y-p));\n\t  vec[0].F = f+y-p+1;\n\t  p = y+1;\n\t}\n      }\n\n      vec.insert(vec.end(), b.begin(), b.end());\n      vec.insert(vec.end(), a.begin(), a.end());\n\n    }\n\n\n    /*    rep(i, vec.size()){\n      for(int j=vec[i].F;j<=vec[i].S;j++) cout << j << endl;;\n      }*/\n    cout << countR(P, Q, R) << endl;\n  }\n  return 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include <iostream>\n#include <vector>\n\nusing namespace std;\n\nclass range {\nprivate:\n  struct Iterator {\n    int val;\n    int operator*() {return val;}\n    bool operator!=(Iterator &itr) {return val < itr.val;}\n    void operator++() {++val;}\n  };\n  Iterator i, n;\npublic:\n  range(int n) : i({0}), n({n}) {}\n  range(int i, int n) : i({i}), n({n}) {}\n  Iterator &begin() {return i;}\n  Iterator &end() {return n;}\n};\n\ntemplate<class T> T at(vector<T> v, int i) {return v[(i % (int)v.size() + v.size()) % v.size()];}\n\nint main() {\n  while (true) {\n    int n, m, p, q, r;\n    cin >> n;\n    if (n == 0) break; \n    cin >> m >> p >> q >> r;;\n    --p;\n    vector<pair<int, int>> dp[2];\n    dp[0].emplace_back(1, n);\n    for (int i : range(m)) {\n      int x, y, sum = 0;\n      cin >> x >> y;\n      for (const auto &i : dp[0]) {\n        int nsum = sum + i.second - i.first + 1;\n        int xx = max(sum, y);\n        int yy = min(nsum, n);\n        if (xx < yy) dp[1].emplace_back(i.first + max(0, y - sum), i.second - max(0, nsum - n));\n        sum = nsum;\n      }\n      sum = 0;\n      for (const auto &i : dp[0]) {\n        int nsum = sum + i.second - i.first + 1;\n        int xx = max(sum, x);\n        int yy = min(nsum, y);\n        if (xx < yy) dp[1].emplace_back(i.first + max(0, x - sum), i.second - max(0, nsum - y));\n        sum = nsum;\n      }\n      sum = 0;\n      for (const auto &i : dp[0]) {\n        int nsum = sum + i.second - i.first + 1;\n        int xx = max(sum, 0);\n        int yy = min(nsum, x);\n        if (xx < yy) dp[1].emplace_back(i.first + max(0, 0 - sum), i.second - max(0, nsum - x));\n        sum = nsum;\n      }\n      dp[0] = dp[1];\n      dp[1].clear();\n    }\n    int sum = 0;\n    int res = 0;\n    for (const auto &i : dp[0]) {\n      int nsum = sum + i.second - i.first + 1;\n      int xx = max(sum, p);\n      int yy = min(nsum, q);\n      if (xx < yy) {\n        int s = i.first + max(0, p - sum);\n        int t = min(i.second - max(0, nsum - q), r);\n        if (s <= r) res += t - s + 1;\n      }\n      sum = nsum;\n    }\n    cout << res << endl;\n  }\n}"
  },
  {
    "language": "C++",
    "code": "#include <iostream>\n#include <vector>\n\nusing namespace std;\n\ntypedef struct\n{\n\tint begin;\n\tint end;\n} seq;\n\nvector<seq> cards,A,B;\nint N,M,P,Q,R;\nseq ts;\n\nseq* makeseq(int begin,int end)\n{\n\tts.begin = begin;\n\tts.end = end;\n\treturn &ts;\n}\n\nvoid shuffle(int x,int y)\n{\n\tA.clear();\n\tB.clear();\n\tint sum = 0;\n\tfor(auto itr = cards.begin();itr < cards.end();itr++)\n\t{\n\t\tif(sum + (itr->end - itr->begin) < x)\n\t\t{\n\t\t\tA.push_back(*itr);\n\t\t\tsum += (itr->end - itr->begin) + 1;\n\t\t\tcards.erase(itr);\n\t\t\titr--;\n\t\t}\n\t\telse\n\t\t{\n\t\t\tif(sum != x)\n\t\t\t{\n\t\t\t\tA.push_back(*makeseq(itr->begin,itr->begin+((x-sum)-1)));\n\t\t\t\titr->begin = itr->begin+(x-sum);\n\t\t\t}\n\t\t\tbreak;\n\t\t}\n\t}\n\tsum = x;\n\tfor(auto itr = cards.begin();itr < cards.end();itr++)\n\t{\n\t\tif(sum + (itr->end - itr->begin) < y)\n\t\t{\n\t\t\tcards.push_back(*itr);\n\t\t\tsum += (itr->end - itr->begin) + 1;\n\t\t\tcards.erase(itr);\n\t\t\titr--;\n\t\t}\n\t\telse\n\t\t{\n\t\t\tif(sum != y)\n\t\t\t{\n\t\t\t\tB.push_back(*makeseq(itr->begin,itr->begin+((y-sum)-1)));\n\t\t\t\titr->begin = itr->begin+(y-sum);\n\t\t\t}\n\t\t\tbreak;\n\t\t}\n\t}\n\tfor(auto itr = B.begin();itr < B.end();itr++)\n\t{\n\t\tcards.push_back(*itr);\n\t}\n\tfor(auto itr = A.begin();itr < A.end();itr++)\n\t{\n\t\tcards.push_back(*itr);\n\t}\n}\n\nint main(void)\n{\n\twhile(true)\n\t{\n\t\tcin >> N;\n\t\tif(N == 0)\n\t\t\texit(0);\n\t\tcards.clear();\n\t\tA.clear();\n\t\tB.clear();\n\t\tcin >> M >> P >> Q >> R;\n\t\tcards.push_back(*makeseq(1,N));\n\t\tint x,y;\n\t\tfor(int i = 0;i < M;i++)\n\t\t{\n\t\t\tcin >> x >> y;\n\t\t\tshuffle(x,y);\n\t\t}\n\t\tint result = 0;\n\t\tint sum = 0;\n\t\tfor(auto itr = cards.begin();itr < cards.end();itr++)\n\t\t{\n\t\t\tif(sum + (itr->end - itr->begin) < P-1)\n\t\t\t{\n\t\t\t\tsum += (itr->end - itr->begin)+1;\n\t\t\t\tcards.erase(itr);\n\t\t\t\titr--;\n\t\t\t}\n\t\t\telse\n\t\t\t{\n\t\t\t\tif(sum != P-1)\n\t\t\t\t{\n\t\t\t\t\titr->begin = itr->begin + ((P - sum) - 1);\n\t\t\t\t}\n\t\t\t\tbreak;\n\t\t\t}\n\t\t}\n\t\tsum = 0;\n\t\tint count = (Q - P) + 1;\n\t\tfor(auto itr = cards.begin();itr < cards.end();itr++)\n\t\t{\n\t\t\tif(sum + (itr->end - itr->begin) < count)\n\t\t\t{\n\t\t\t\tsum += (itr->end - itr->begin)+1;\n\t\t\t\tif(itr->begin <= R)\n\t\t\t\t{\n\t\t\t\t\tresult += (min(R,itr->end) - itr->begin)+1;\n\t\t\t\t}\n\t\t\t}\n\t\t\telse\n\t\t\t{\n\t\t\t\tif(sum != count)\n\t\t\t\t{\n\t\t\t\t\titr->end = itr->end - (((itr->end - itr->begin)+1)-(count-sum));\n\t\t\t\t\tresult += (min(R,itr->end) - itr->begin)+1;\n\t\t\t\t}\n\t\t\t\tbreak;\n\t\t\t}\n\t\t}\n\t\tcout << result << endl;\n\t}\n}"
  },
  {
    "language": "C++",
    "code": "#include <tuple>\n#include <vector>\n#include <iostream>\n#include <algorithm>\n\nusing namespace std;\n\nint n, m, p, q, c, r1, r2;\n\nvector<tuple<int, int, int> > dat;\n\ninline void divide(int pos)\n{\n\tvector<tuple<int, int, int> > dat1;\n\n\tfor (int i = 0; i < dat.size(); i++)\n\t{\n\t\tint l = get<0>(dat[i]);\n\t\tint r = get<1>(dat[i]);\n\t\tint t = get<2>(dat[i]);\n\n\t\tif (l < pos && pos < r)\n\t\t{\n\t\t\tdat1.push_back(make_tuple(l, pos, t));\n\t\t\tdat1.push_back(make_tuple(pos, r, t + pos - l));\n\t\t}\n\t\telse\n\t\t{\n\t\t\tdat1.push_back(make_tuple(l, r, t));\n\t\t}\n\t}\n\n\tdat = dat1;\n}\n\ninline void shuffle(int a, int b)\n{\n\tdivide(a);\n\tdivide(b);\n\n\tint l = lower_bound(dat.begin(), dat.end(), make_tuple(a, 0, 0)) - dat.begin();\n\tint r = lower_bound(dat.begin(), dat.end(), make_tuple(b, 0, 0)) - dat.begin();\n\n\tvector<tuple<int, int, int> > dat1;\n\n\tint pos = 0;\n\n\tfor (int i = r; i < dat.size(); i++)\n\t{\n\t\tdat1.push_back(make_tuple(pos, pos - get<0>(dat[i]) + get<1>(dat[i]), get<2>(dat[i]))); pos += get<1>(dat[i]) - get<0>(dat[i]);\n\t}\n\n\tfor (int i = l; i < r; i++)\n\t{\n\t\tdat1.push_back(make_tuple(pos, pos - get<0>(dat[i]) + get<1>(dat[i]), get<2>(dat[i]))); pos += get<1>(dat[i]) - get<0>(dat[i]);\n\t}\n\n\tfor (int i = 0; i < l; i++)\n\t{\n\t\tdat1.push_back(make_tuple(pos, pos - get<0>(dat[i]) + get<1>(dat[i]), get<2>(dat[i]))); pos += get<1>(dat[i]) - get<0>(dat[i]);\n\t}\n\n\tdat = dat1;\n}\n\nint main()\n{\n\twhile(true)\n\t{\n\t\tscanf(\"%d\", &n); if (n == 0) { break; }\n\t\tscanf(\"%d\", &m);\n\t\tscanf(\"%d\", &p); p--;\n\t\tscanf(\"%d\", &q); q--;\n\t\tscanf(\"%d\", &c);\n\n\t\tdat = { make_tuple(0, n, 1) };\n\n\t\tfor (int i = 0; i < m; i++)\n\t\t{\n\t\t\tscanf(\"%d\", &r1);\n\t\t\tscanf(\"%d\", &r2);\n\n\t\t\tshuffle(r1, r2);\n\t\t}\n\n\t\tint ret = 0;\n\n\t\tfor (int i = 0; i < dat.size(); i++)\n\t\t{\n\t\t\tint l = get<0>(dat[i]);\n\t\t\tint r = get<1>(dat[i]);\n\t\t\tint t = get<2>(dat[i]);\n\n\t\t\tif (p <= l && r <= q + 1)\n\t\t\t{\n\t\t\t\tret += min(max(c - t + 1, 0), r - l);\n\t\t\t}\n\t\t\telse if (p <= l && l <= q)\n\t\t\t{\n\t\t\t\tret += min(max(c - t + 1, 0), q - l + 1);\n\t\t\t}\n\t\t\telse if (p <= r && r <= q)\n\t\t\t{\n\t\t\t\tret += max(c - (t + (p - l)) + 1, 0);\n\t\t\t}\n\t\t}\n\n\t\tprintf(\"%d\\n\", ret);\n\t}\n\n\treturn 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include \"iostream\"\n#include \"climits\"\n#include \"list\"\n#include \"queue\"\n#include \"stack\"\n#include \"set\"\n#include \"functional\"\n#include \"algorithm\"\n#include \"string\"\n#include \"map\"\n#include \"unordered_map\"\n#include \"unordered_set\"\n#include \"iomanip\"\n#include \"cmath\"\n#include \"random\"\n#include \"bitset\"\n#include \"cstdio\"\n#include \"numeric\"\n#include \"cassert\"\n#include \"functional\"\n#include \"ctime\"\n\nusing namespace std;\n\nconstexpr long long int MOD = 1000000007;\n//constexpr int MOD = 1000000007;\n//constexpr int MOD = 998244353;\n//constexpr long long int MOD = 998244353;\nconstexpr double EPS = 1e-8;\n\nint N, M, K, H, W, L, R;\n//long long int N, M, K, H, W, L, R;\n\ntypedef pair<int, int> Node;\n\nNode w[15000], y[15000], z[15000],v[45000];\n\nint main() {\n\tios::sync_with_stdio(false);\n\tcin.tie(0);\n\n\tcin >> N ;\n\twhile(N){\n\t  cin>>M;\n\tcin >> L >> R >> K;\n\tv[0] = { 1,N };\n\tint vs = 1;\n\tfor (int i = 0; i < M; i++) {\n\t\tcin >> H >> W;\n\t\tint ws = 0, ys = 0, zs = 0;\n\t\tint used = 0;\n\t\tfor (int k = 0; k < vs; k++) {\n\t\t\tauto j = v[k];\n\t\t\tif (used < H) {\n\t\t\t\tif (used + j.second - j.first + 1 > H) {\n\t\t\t\t\tw[ws++] = Node(j.first, H - used + j.first - 1);\n\t\t\t\t\tj.first = H - used + j.first;\n\t\t\t\t\tused = H;\n\t\t\t\t}\n\t\t\t\telse {\n\t\t\t\t\tused += j.second - j.first + 1;\n\t\t\t\t\tw[ws++] = j;\n\t\t\t\t\tcontinue;\n\t\t\t\t}\n\t\t\t}\n\t\t\tif (used < W) {\n\t\t\t\tif (used + j.second - j.first + 1 > W) {\n\t\t\t\t\ty[ys++] = Node(j.first, W - used + j.first - 1);\n\t\t\t\t\tj.first = W - used + j.first;\n\t\t\t\t\tused = W;\n\t\t\t\t}\n\t\t\t\telse {\n\t\t\t\t\tused += j.second - j.first + 1;\n\t\t\t\t\ty[ys++] = j;\n\t\t\t\t\tcontinue;\n\t\t\t\t}\n\t\t\t}\n\t\t\tif (used >= W) {\n\t\t\t\tused += j.second - j.first + 1;\n\t\t\t\tz[zs++] = j;\n\t\t\t}\n\t\t}\n\t\tvs = zs + ws + ys;\n\t\tfor (int j = 0; j < zs; j++)v[j] = z[j];\n\t\tfor (int j = 0; j < ys; j++)v[j + zs] = y[j];\n\t\tfor (int j = 0; j < ws; j++)v[j + zs + ys] = w[j];\n\t}\n\tint ans = 0;\n\tint used = 0;\n\t//for (auto i : v) {\n\tfor(int j=0;j<vs;j++){\n\t\tauto i = v[j];\n\t\t//for (int j = i.first; j <= i.second; j++) {\n\t\t//\t//if (used > R)break;\n\t\t//\tif (used >= L && used <= R && j <= K)ans++;\n\t\t//\tused++;\n\t\t//}\n\n\t//\tcout << i.first << \" \" << i.second << endl;\n\t\tif (used + i.second - i.first + 1 < L) {\n\t\t\tused += i.second - i.first + 1;\n\t\t\tcontinue;\n\t\t}\n\t\tif (used < L) {\n\t\t\ti.first += L - used - 1;\n\t\t\tused = L - 1;\n\t\t}\n\t\tif (used > R)continue;\n\t\tint add = max(0, min(min(K, i.second) - i.first + 1, R - used));\n\t\tans += add;\n\t\tused += i.second - i.first + 1;\n\t//\tcout << ans << endl;\n\t}\n\tcout << ans << endl;\n\tcin>>N;\n\t}\n\treturn 0;\n}\n"
  },
  {
    "language": "C++",
    "code": "#include <iostream>\n#include <list>\n#define P pair<int,int>\nusing namespace std;\nvoid shuffle(list< P > &v, int x, int y)\n{\n  list< P > t;\n  list< P >::iterator p = v.begin();\n  while((*p).second - (*p).first + 1 <= x){\n    x -= (*p).second - (*p).first + 1;\n    t.push_back(*p);\n    v.pop_front();\n    p = v.begin();\n  }\n  if(x != 0){\n    t.push_back( P((*p).first, (*p).first+x-1) );\n    P q((*p).first+x, (*p).second);\n    v.pop_front();\n    v.push_front(q);\n  }\n  p = v.begin();\n  while((*p).second - (*p).first + 1 <= y){\n    y -= (*p).second - (*p).first + 1;\n    v.push_back(*p);\n    v.pop_front();\n    p = v.begin();\n  }\n  if(y != 0){\n    v.push_back( P((*p).first, (*p).first+y-1) );\n    P r((*p).first+y, (*p).second);\n    v.pop_front();\n    v.push_front(r);\n  }\n  p = t.begin();\n  while(p != t.end()){\n    v.push_back(*p);\n    p++;\n  }\n}\nint main()\n{\n  int n,m,p,q,r,x,y,c;\n  for(;;){\n    cin >> n;\n    if(n==0)break;\n    cin >> m;\n    cin >> p >> q >> r;\n    list< P > v;\n    list< P >::iterator it;\n    v.push_back( P(1,n) );\n    while(m--){\n      cin >> x >> y;\n      shuffle(v, x, y-x);\n      it = v.begin();\n    }\n    it = v.begin();\n    q -= p - 1;\n    while((*it).second - (*it).first + 1 < p){\n      p -= (*it).second - (*it).first + 1;\n      v.pop_front();\n      it = v.begin();\n    }\n    if((*it).second - (*it).first + 1 == p){\n      P t((*it).second, (*it).second);\n      v.pop_front();\n      v.push_front(t);\n    }else if(p > 1){\n      P t((*it).first + p - 1, (*it).second);\n      v.pop_front();\n      v.push_front(t);\n    }\n    c = 0;\n    it = v.begin();\n    while((*it).second - (*it).first + 1 <= q){\n      if((*it).second <= r){\n\tc += (*it).second - (*it).first + 1;\n      }else if((*it).first <= r){\n\tc += r - (*it).first + 1;\n      }\n      q -= (*it).second - (*it).first + 1;\n      v.pop_front();\n      it = v.begin();\n    }\n    if(q != 0){\n      if((*it).first <= r){\n\tint w = r < ((*it).first + q - 1) ? r : ((*it).first + q - 1);\n\tc += w - (*it).first + 1;\n      }\n    }\n    cout << c << endl;\n  }\n  return 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include <iostream>\n#include <list>\n#include <vector>\n#include <set>\nusing namespace std;\ntypedef pair<int,int> pa;\n\nint X[10010],Y[10010];\nint main(){\n\tint N,M,P,Q,R,cnt,in,ou,res,le,ri;\n\tbool xfl,yfl;\n\tlist<pa> li[2];\n\tlist<pa>::iterator tit;\n\twhile(true){\n\t\tcin>>N;\n\t\tif(N==0) break;\n\t\tcin>>M>>P>>Q>>R;\n\t\tfor(int i=1;i<=M;i++){\n\t\t\tcin>>X[i]>>Y[i];\n\t\t}\n\t\tin=0;ou=1;\n\t\tli[in].clear();\n\t\tli[in].push_back(pa(1,N));\n\t\tfor(int i=1;i<=M;i++){\n\t\t\tcnt=0;xfl=yfl=false;\n\t\t\tli[ou].clear();\n\t\t\ttit=li[ou].end();\n\t\t\tfor(auto it=li[in].begin();it!=li[in].end();it++){\n\t\t\t\tif((!xfl)&&cnt+((it->second)-(it->first)+1)>=X[i]){\n\t\t\t\t\tli[ou].insert(tit,pa(it->first,it->first+(X[i]-cnt)-1));\n\t\t\t\t\ttit=li[ou].begin();\n\t\t\t\t\tif(cnt+((it->second)-(it->first))+1>=Y[i]){\n\t\t\t\t\t\tli[ou].insert(tit,pa(it->first+(X[i]-cnt),it->first+(Y[i]-cnt)-1));\n\t\t\t\t\t\ttit=li[ou].begin();\n\t\t\t\t\t\tli[ou].insert(tit,pa(it->first+(Y[i]-cnt),it->second));\n\t\t\t\t\t\tyfl=true;\n\t\t\t\t\t}\n\t\t\t\t\telse if(cnt+((it->second)-(it->first))+1>X[i])li[ou].insert(tit,pa(it->first+(X[i]-cnt),it->second));\n\t\t\t\t\txfl=true;\n\t\t\t\t}\n\t\t\t\telse if((!yfl)&&cnt+((it->second)-(it->first))+1>=Y[i]){\n\t\t\t\t\tli[ou].insert(tit,pa(it->first,it->first+(Y[i]-cnt)-1));\n\t\t\t\t\ttit=li[ou].begin();\n\t\t\t\t\tif(cnt+((it->second)-(it->first))+1>Y[i]) li[ou].insert(tit,pa(it->first+(Y[i]-cnt),it->second));\n\t\t\t\t\tyfl=true;\n\t\t\t\t}\n\t\t\t\telse{\n\t\t\t\t\tli[ou].insert(tit,(*it));\n\t\t\t\t}\n\t\t\t\tcnt+=(it->second-it->first+1);\n\t\t\t}\n\t\t\tswap(in,ou);\n\t\t}\n\t\tres=0,cnt=0;\n\t\tfor(auto it=li[in].begin();it!=li[in].end();it++){\n\t\t\tif(R<it->first){\n\t\t\t\tcnt+=((it->second)-(it->first)+1);\n\t\t\t\tcontinue;\n\t\t\t}\n\t\t\tle=cnt+1;\n\t\t\tri=min(cnt+it->second-it->first+1,R-(it->first)+le);\n\t\t\tres+=max(0,min(ri,Q)-max(le,P)+1);\n\t\t\tcnt+=((it->second)-(it->first)+1);\n\t\t}\n\t\tcout<<res<<endl;\n\t}\n\treturn 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include<bits/stdc++.h>\n#define P pair<int,int>\nusing namespace std;\n\nlist<P>operator +(list<P>a, list<P>b) {\n\twhile (b.size()) {\n\t\ta.push_back(b.front()); b.pop_front();\n\t}\n\treturn a;\n}\nlist<P>L;\nint main() {\n\tint a;\n\twhile (cin >> a, a) {\n\t\tint b, c, d, e; scanf(\"%d%d%d%d\", &b, &c, &d, &e);\n\t\tL.clear();\n\t\tL.push_back(P(1, a));\n\t\tfor (int f = 0; f < b; f++) {\n\t\t\tint g, h; scanf(\"%d%d\", &g, &h);\n\t\t\tlist<P>A, B, C;\n\t\t\tint sum = 0,j=0;\n\t\t\twhile (L.size()) {\n\t\t\t\tP i = L.front(); L.pop_front();\n\t\t\t\tsum += i.second - i.first+1;\n\t\t\t\tif (j < g&&sum > g) {\n\t\t\t\t\tif (j < h&&sum > h) {\n\t\t\t\t\t\tA.push_back(P(i.first, i.first + (g - j) - 1));\n\t\t\t\t\t\tB.push_back(P(i.first + (g - j), i.first + (h - j)-1));\n\t\t\t\t\t\tC.push_back(P(i.first + (h - j), i.second));\n\t\t\t\t\t}\n\t\t\t\t\telse {\n\t\t\t\t\t\tA.push_back(P(i.first, i.first + (g - j) - 1));\n\t\t\t\t\t\tB.push_back(P(i.first + (g - j), i.second));\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t\telse {\n\t\t\t\t\tif (j < h&&sum > h) {\n\t\t\t\t\t\tB.push_back(P(i.first, i.first + (h - j) - 1));\n\t\t\t\t\t\tC.push_back(P(i.first + (h - j), i.second));\n\t\t\t\t\t}\n\t\t\t\t\telse {\n\t\t\t\t\t\tif (sum > h) {\n\t\t\t\t\t\t\tC.push_back(i);\n\t\t\t\t\t\t}\n\t\t\t\t\t\telse if (sum > g) {\n\t\t\t\t\t\t\tB.push_back(i);\n\t\t\t\t\t\t}\n\t\t\t\t\t\telse {\n\t\t\t\t\t\t\tA.push_back(i);\n\t\t\t\t\t\t}\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t\tj += i.second - i.first+1;\n\t\t\t}\n\t\t\tL = C + B + A;\n\t\t}\n\t\tint x = 0, y = 0;\n\t\tvector<P>W;\n\t\twhile (L.size()) {\n\t\t\tP t = L.front(); L.pop_front();\n\t\t\tx += t.second - t.first + 1;\n\t\t\tif (x <= d&&x>=c) {\n\t\t\t\tif (y <= d&&y >= c) {\n\t\t\t\t\tW.push_back(P(t.first,t.second));\n\t\t\t\t}\n\t\t\t\telse {\n\t\t\t\t\tW.push_back(P(t.second-(x-c),t.second));\n\t\t\t\t}\n\t\t\t}\n\t\t\telse {\n\t\t\t\tif (y<=d&&y>=c) {\n\t\t\t\t\tW.push_back(P(t.first,t.first+d-y-1));\n\t\t\t\t}\n\t\t\t}\n\t\t\ty += t.second - t.first + 1;\n\t\t}\n\t\tint ans = 0;\n\t\tfor (P i: W) {\n\t\t\tans += max(0, min(e, i.second) - i.first + 1);\n\t\t}\n\t\tcout<<ans<<endl;\n\t}\n}"
  },
  {
    "language": "C++",
    "code": "#include<cstdio>\n#include<vector>\n#include<algorithm>\nusing namespace std;\nint main(){\n    int n,m,p,q,r;\n    for(;;){\n        scanf(\"%d%d%d%d%d\",&n,&m,&p,&q,&r);\n        if(n==0) break;\n        pair<int,int> *cards=new pair<int,int>[1];\n        cards[0]=make_pair(1,n);\n        int csize=1;\n        for(int ix=0;ix<m;ix++){\n            int x,y;\n            scanf(\"%d%d\",&x,&y);\n            int *maif=new int[csize],*mais=new int[csize];\n            maif[0]=1;\n            mais[0]=cards[0].second-cards[0].first+1;\n            for(int i=1;i<csize;i++){\n                mais[i]=mais[i-1]+(cards[i].second-cards[i].first+1);\n                maif[i]=mais[i-1]+1;\n            }\n            vector<pair<int,int> > a,b,c;\n            for(int i=0;i<csize;i++){\n                if(mais[i]<=x) a.push_back(cards[i]);\n                else if(y<maif[i]) c.push_back(cards[i]);\n                else if(x<maif[i]&&mais[i]<=y) b.push_back(cards[i]);\n                else if(x<maif[i]&&y<mais[i]){\n                    b.push_back(make_pair(cards[i].first,y+(cards[i].first-maif[i])));\n                    c.push_back(make_pair(y+(cards[i].first-maif[i])+1,cards[i].second));\n                }\n                else if(maif[i]<=x&&mais[i]<=y){\n                    a.push_back(make_pair(cards[i].first,x+(cards[i].first-maif[i])));\n                    b.push_back(make_pair(x+(cards[i].first-maif[i])+1,cards[i].second));\n                }\n                else if(maif[i]<=x&&y<mais[i]){\n                    a.push_back(make_pair(cards[i].first,x+(cards[i].first-maif[i])));\n                    b.push_back(make_pair(x+(cards[i].first-maif[i])+1,y+(cards[i].first-maif[i])));\n                    c.push_back(make_pair(y+(cards[i].first-maif[i])+1,cards[i].second));\n                }\n            }\n            delete[] cards,maif,mais;\n            csize=c.size()+b.size()+a.size();\n            cards=new pair<int,int>[csize];\n            for(int ii=0;ii<c.size();ii++)cards[ii]=c[ii];\n            for(int ii=0;ii<b.size();ii++)cards[ii+c.size()]=b[ii];\n            for(int ii=0;ii<a.size();ii++)cards[ii+c.size()+b.size()]=a[ii];\n        }\n        int *maif=new int[csize],*mais=new int[csize];\n        maif[0]=1;\n        mais[0]=cards[0].second-cards[0].first+1;\n        for(int i=1;i<csize;i++){\n            mais[i]=mais[i-1]+(cards[i].second-cards[i].first+1);\n            maif[i]=mais[i-1]+1;\n        }\n        int ans=0;\n        for(int i=0;i<csize;i++){\n            if(p<=maif[i]&&mais[i]<=q) ans+=max(0,min(r,cards[i].second)-cards[i].first+1);\n            else if(maif[i]<p) ans+=max(0,min(r,cards[i].second)-(cards[i].first+(p-maif[i])+1));\n            else if(q<mais[i]) ans+=max(0,min(r,cards[i].second-(mais[i]-q))-cards[i].first+1);\n            else ans+=max(0,min(r,cards[i].second-(mais[i]-q))-(cards[i].first+(p-maif[i])+1));\n        }\n        printf(\"%d\\n\",ans);\n    }\n}"
  },
  {
    "language": "C++",
    "code": "#include<iostream>\n#include<string>\n#include<algorithm>\n#include<math.h>\n#include<queue>\n#include<set>\n#include<map>\n#include<random>\n#include<functional>\n#include<utility>\n\ntypedef long long ll;\n\n#define rep(i,n) for(int i=0; i<n; i++)\n#define pb push_back\n#define P pair<int, int>\n#define PLI pair<ll, int>\n#define PLL pair<ll, ll>\n\nusing namespace std;\n\n\nint N, M, p, q, r;\nint main() {\n\twhile (cin >> N, N)\n\t{\n\t\tcin >> M >> p >> q >> r;\n\t\tvector<P> group;\n\t\tgroup.emplace_back(1, r);\n\t\trep(i, M) {\n\t\t\tint x, y;\n\t\t\tcin >> x >> y;\n\t\t\trep(j, group.size()) {\n\t\t\t\tint a = group[j].first, b = group[j].second;\n\t\t\t\tif (a <= x && x < b) {\n\t\t\t\t\tgroup[j].second = x;\n\t\t\t\t\tgroup.emplace_back(x + 1, b);\n\t\t\t\t\tcontinue;\n\t\t\t\t}\n\t\t\t\tif (a <= y && y < b) {\n\t\t\t\t\tgroup[j].second = y;\n\t\t\t\t\tgroup.emplace_back(y + 1, b);\n\t\t\t\t}\n\t\t\t}\n\t\t\trep(j, group.size()) {\n\t\t\t\tint a = group[j].first;\n\t\t\t\tif (a <= x) {\n\t\t\t\t\tgroup[j].first += N - x;\n\t\t\t\t\tgroup[j].second += N - x;\n\t\t\t\t}\n\t\t\t\telse if (a <= y) {\n\t\t\t\t\tgroup[j].first += N - y - x;\n\t\t\t\t\tgroup[j].second += N - y - x;\n\t\t\t\t}\n\t\t\t\telse{\n\t\t\t\t\tgroup[j].first += -y;\n\t\t\t\t\tgroup[j].second += -y;\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\n\t\tint ans = 0;\n\t\trep(i, group.size()) {\n\t\t\tint a = group[i].first, b = group[i].second;\n\t\t\tif (p <= a && b <= q) {\n\t\t\t\tans += b - a + 1;\n\t\t\t}\n\t\t\telse if (p <= a && a <= q) {\n\t\t\t\tans += q - a + 1;\n\t\t\t}\n\t\t\telse if (p <= b && b <= q) {\n\t\t\t\tans += b - p + 1;\n\t\t\t}\n\t\t}\n\n\t\tcout << ans << endl;\n\n\t}\n\n\n\treturn 0;\n}\n"
  },
  {
    "language": "C++",
    "code": "#include <algorithm>\n#include <climits>\n#include <iostream>\n#include <string>\n#include <vector>\n#include<queue>\n#include<queue>\n#define P pair<int,int>\nusing namespace std;\n\nqueue<P>operator +(queue<P>a, queue<P>b) {\n\twhile (b.size()) {\n\t\ta.push(b.front()); b.pop();\n\t}\n\treturn a;\n}\nqueue<P>L;\nint main() {\n\tint a;\n\twhile (cin >> a, a) {\n\t\tint b, c, d, e; scanf(\"%d%d%d%d\", &b, &c, &d, &e);\n\t\tqueue<P>tmp;\n\t\tswap(L, tmp);\n\t\tL.push(P(1, a));\n\t\tfor (int f = 0; f < b; f++) {\n\t\t\tint g, h; scanf(\"%d%d\", &g, &h);\n\t\t\tqueue<P>A, B, C;\n\t\t\tint sum = 0, j = 0;\n\t\t\twhile (L.size()) {\n\t\t\t\tP i = L.front(); L.pop();\n\t\t\t\tsum += i.second - i.first + 1;\n\t\t\t\tif (j < g&&sum > g) {\n\t\t\t\t\tif (j < h&&sum > h) {\n\t\t\t\t\t\tA.push(P(i.first, i.first + (g - j) - 1));\n\t\t\t\t\t\tB.push(P(i.first + (g - j), i.first + (h - j) - 1));\n\t\t\t\t\t\tC.push(P(i.first + (h - j), i.second));\n\t\t\t\t\t}\n\t\t\t\t\telse {\n\t\t\t\t\t\tA.push(P(i.first, i.first + (g - j) - 1));\n\t\t\t\t\t\tB.push(P(i.first + (g - j), i.second));\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t\telse {\n\t\t\t\t\tif (j < h&&sum > h) {\n\t\t\t\t\t\tB.push(P(i.first, i.first + (h - j) - 1));\n\t\t\t\t\t\tC.push(P(i.first + (h - j), i.second));\n\t\t\t\t\t}\n\t\t\t\t\telse {\n\t\t\t\t\t\tif (sum > h) {\n\t\t\t\t\t\t\tC.push(i);\n\t\t\t\t\t\t}\n\t\t\t\t\t\telse if (sum > g) {\n\t\t\t\t\t\t\tB.push(i);\n\t\t\t\t\t\t}\n\t\t\t\t\t\telse {\n\t\t\t\t\t\t\tA.push(i);\n\t\t\t\t\t\t}\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t\tj += i.second - i.first + 1;\n\t\t\t}\n\t\t\tL = C + B + A;\n\t\t}\n}"
  },
  {
    "language": "C++",
    "code": "#include <iostream>\n#include <vector>\n#include <utility>\nusing namespace std;\n\nvoid shuffle(int,int,vector<int>);\n\nint main(void){\n\twhile(true){\n  int m,n,p,q,r;\n  vector<int> v;\n  cin >> n;\n  if(n==0)\n  break;\n  for(int i=1;i<=n;i++) v.push_back(i);\n\n  cin >> m;\n  \n  cin >> p >> q >> r;\n  for(int i=0;i<m;i++){\n    int x,y;\n    cin >> x >> y;\n    shuffle(x,y,v);\n  }\n\n  int cnt=0;\n  for(int i=p-1;i<=q-1;i++) if(v[i]<=r) cnt++;\n  \n  cout << cnt << endl;\n\t}\n  return 0;\n}\n\nvoid shuffle(int x,int y,vector<int> v1){\n  vector<int> v2;\n  for(int i=y;i<v1.size();i++) v2.push_back(v1[i]);\n  for(int i=x;i<y;i++) v2.push_back(v1[i]);\n  for(int i=0;i<x;i++) v2.push_back(v1[i]);\n  for(int i=0;i<v2.size();i++) v1[i]=v2[i];\n  \n}"
  },
  {
    "language": "C++",
    "code": "#include<iostream>\n#include<vector>\n#include<algorithm>\n#include<cassert>\n#include<cstdio>\nusing namespace std;\n\nstruct P\n{\n  int s,e;\n  P(int s,int e):s(s),e(e){}\n};\n\nvoid shuffle(vector<P>& vec,int x,int y,int n)\n{\n  vector<P> ins;\n  for(int i=0;i<vec.size();i++)\n    {\n      if(vec[i].e <= x)\n\t{\n\t  vec[i].s += (n-x),vec[i].e += (n-x);\n\t}\n      else if(vec[i].s <= x && vec[i].e <= y)\n\t{\n\t  ins.push_back(P(x+1,vec[i].e));\n\t  ins[ins.size()-1].s += (n-y)-x,ins[ins.size()-1].e += (n-y)-x;\n\t  vec[i].e = x;\n\t  vec[i].s += (n-x),vec[i].e += (n-x);\n\t}\n      else if(vec[i].s <= x && vec[i].e  > y)\n\t{\n\t  ins.push_back(P(vec[i].s,x));\n\t  ins[ins.size()-1].s += (n-x),ins[ins.size()-1].e += (n-x);\n\t  ins.push_back(P(x+1,y));\n\t  ins[ins.size()-1].s += (n-y)-x,ins[ins.size()-1].e += (n-y)-x;\n\t  vec[i].s = y+1;\n\t  vec[i].s -= y,vec[i].e -= y;\n\t}\n      else if(vec[i].s  > x && vec[i].e <= y)\n\t{\n\t  vec[i].s += (n-y)-x,vec[i].e += (n-y)-x;\n\t}\n      else if(vec[i].s  > x && vec[i].s <= y && vec[i].e  > y)\n\t{\n\t  ins.push_back(P(vec[i].s,y));\n\t  ins[ins.size()-1].s += (n-y)-x, ins[ins.size()-1].e += (n-y)-x;\n\t  vec[i].s = y+1;\n\t  vec[i].s -= y,vec[i].e -= y;\n\t}\n      else if(vec[i].s  > y)\n\t{\n\t  vec[i].s -= y,vec[i].e -= y;\n\t}\n      else \n\tassert(false);\n    }\nfor(int i=0;i<ins.size();i++)\n  vec.push_back(ins[i]);\n}\n\nint main()\n{\n  int n;\n  while(scanf(\"%d\",&n),n)\n    {\n      int m;\n      scanf(\"%d\",&m);\n      int p,q,r;\n      scanf(\"%d %d %d\",&p,&q,&r);\n      vector<P> vec;\n      vec.push_back(P(1,r));\n\n      for(int i=0;i<m;i++)\n\t{\n\t  int x,y;\n\t  scanf(\"%d %d\",&x,&y);\n\t  shuffle(vec,x,y,n);\n\t}\n   \n      int cnt = 0;\n      for(int i=0;i<vec.size();i++)\n\t{\n\t  if(vec[i].s > q || vec[i].e < p)\n\t    continue;\n\t  cnt += min(vec[i].e,q) - max(vec[i].s,p)+1;\n\t}\n      cout << cnt << endl;\n    }\n  return 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include <set>\n#include <map>\n#include <list>\n#include <queue>\n#include <stack>\n#include <cmath>\n#include <ctime>\n#include <cstdio>\n#include <vector>\n#include <string>\n#include <bitset>\n#include <cctype>\n#include <cstdlib>\n#include <cstring>\n#include <utility>\n#include <numeric>\n#include <complex>\n#include <sstream>\n#include <fstream>\n#include <iomanip>\n#include <cassert>\n#include <iostream>\n#include <iterator>\n#include <algorithm>\n\nusing namespace std;\n\n//4方向ベクトル→↑←↓\nint dx[4] ={1,0,-1,0};\nint dy[4] ={0,-1,0,1};\n\nvector<int> Card;\nvector<int> Cardtemp;\nint n;//カードの枚数\nint m;//シャッフルの回数\nint x,y;//シャッフルする(x,y)\nint p,q,r;//p行q行以下に番号r以下のカードが何枚含まれているか\nint main()\n{\n  while(1){\n  scanf(\"%d\",&n);\n  if(n==0)\n    break;\n  scanf(\"%d\",&m);\n  scanf(\"%d %d %d\",&p,&q,&r);\n  Card.clear();\n  Cardtemp.clear();\n  for(int i = 1;i <=n;i++){\n    Card.push_back(i);\n  }\n  int ans = 0;\n  for(int i = 1;i <=m;i++){\n    Cardtemp = Card;\n    scanf(\"%d %d\",&x,&y);\n    for(int j = 0;j <=n-(y+1);j++){\n      Card[j] = Cardtemp[y+j];\n    }\n    for(int j = 0;j <=y-(x+1);j++){\n      Card[n-y+j] = Cardtemp[x+j];\n\t}\n    for(int j = 0;j <=x-1;j++){\n      Card[n-x+j] = Cardtemp[j];\n    }\n  }\n  for(int i = p-1;i < q;i++){\n    if(Card[i] <= r)\n      ans++;\n  }\n  cout <<ans<<endl;\n  }\n  return 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include<iostream>\n#include<algorithm>\nusing namespace std;\nint bef[10000],aft[10000];\nint main(){\n\tint n,m,p,q,r,x,y;\n\twhile(true){\n\tcin>>n;\n\tif(n==0)break;\n\tcin>>m>>p>>q>>r;\n\tint top=1;\n\tbef[0]=0,aft[0]=r;\n\tfor(int u=0;u<m;u++){\n\t\tcin>>x>>y;\n\t\tfor(int i=0;i<top;i++){\n\t\t\tif(x>bef[i]&&x<aft[i])bef[top]=bef[i],aft[top]=x,bef[i]=x,top++;\n\t\t\tif(y>bef[i]&&y<aft[i])bef[top]=bef[i],aft[top]=y,bef[i]=y,top++;\n\t\t\tif(aft[i]<x){bef[i]+=n-x,aft[i]+=n-x;}\n\t\t\tif(bef[i]>=x&&aft[i]<y){bef[i]+=n-x-y,aft[i]+=n-x-y;}\n\t\t\tif(bef[i]>=y){bef[i]-=y,aft[i]-=y;}\n\t\t}\n\t}\n\tlong long ans=0;\n\tfor(int i=0;i<top;i++){ans+=max(0,min(q,aft[i]+1)-max(p+1,bef[i]));}\n\tcout<<ans<<endl;\n\t}\n\treturn 0;\n}"
  },
  {
    "language": "C++",
    "code": "//  4???27??\\  ????????????0535 ; ?????£?????????\n// http://judge.u-aizu.ac.jp/onlinejudge/description.jsp?id=0536\n\n#include <iostream>\n#define NUM 100000\nusing namespace std;\n\nint main(){\n\n  register int n;//?????????????????°\n  register int m;//?????£??????????????°\n  register int p,q;//p ???????????? q ?????????????????????\n  register int r;// r??\\?????????????????????????????????\n  register int x[5000],y[5000];//????????????????????´???\n  register int card[NUM];\n  register int i;\n  register int A[NUM];\n  register int B[NUM];\n  register int C[NUM];\n\n  do{\n    register int j = 0;\n    register int count = 1;\n    register int step = 1;\n    register int red = 1;\n    register int blue = 1;\n    register int green = 0;\n\n    cin >> n;\n    cin >> m;\n    cin >> p >> q >> r;\n\n    if (!n){\n      break;\n    }\n\n    for (i=0; i < m; i++){\n      cin >> x[i] >> y[i];\n    }\n\n    while (j < m){\n\n      for (i=1; i <= n; i++ ){//??°?????£??\\\n        card[i] = i;\n      }\n\n      for (i=1 ; i <= x[j] ;i++ ){//????????????1~X???????????§\n        A[i] = card[i];\n      }\n\n      while (i <= y[j]){//????????????X+1~Y???????????§\n        B[count] = card[i];\n        i++;\n        count++;\n      }\n\n      while (i <= n){//????????????Y+1~n???????????§\n        C[step] = card[i];\n        i++;\n        step++;\n      }\n\n      for (i=1; i <= (n - y[j]); i++ ){//C?????°?????£??\\\n        card[i] = C[i];\n      }\n\n      while (red <= count){//B?????°?????£??\\\n        card[i] = B[red];\n        i++;\n        red++;\n      }\n\n      while (blue <= step){//A?????°?????£??\\\n        card[i] = A[blue];\n        i++;\n        blue++;\n      }\n      j++;\n    }\n\n    for (i=p; i <= q; i++){\n      if (card[i] <= r){\n        green++;\n      }\n    }\n\n    cout << green << endl;\n  } while (n);\n\n  return 0;\n\n}"
  },
  {
    "language": "C++",
    "code": "#include <iostream>\n#include <cstdio>\n#include <vector>\n#include <algorithm>\n#include <complex>\n#include <queue>\n#include <map>\n#include <set>\n#include <cstring>\n#include <cstdlib>\n#include <string>\n#include <cmath>\nusing namespace std;\n\n#define REP(i,n) for(int i=0;i<(int)n;++i)\n#define FOR(i,c) for(__typeof((c).begin())i=(c).begin();i!=(c).end();++i)\n#define ALL(c) (c).begin(), (c).end()\nconst int INF = 1<<29;\ntypedef pair<int,int> pii;\n#define F first\n#define S second\nint main() {\n  int n, m, p, q, r;\n  while(cin >> n, n) {\n    cin >> m >> p >> q >> r;\n    vector<pii> v;\n    v.push_back(pii(1, n));\n    REP(i, m) {\n      int x, y;\n      cin >> x >> y;\n      int num = 0;\n      int xpos=-1, ypos;\n      int xrem, yrem;\n      REP(i, v.size()) {\n        int tmp = v[i].S - v[i].F + 1;\n        if (num < x && x <= num+tmp) {\n          xpos = i;\n          xrem = x-num;\n        }\n        if (num < y && y <= num+tmp) {\n          ypos = i;\n          yrem = y-num;\n          break;\n        }\n        num += tmp;\n      }\n//      printf(\"xpos=%d,xrem=%d, ypos=%d,yrem=%d\\n\",xpos,xrem,ypos,yrem);\n      vector<pii> next;\n      if (xpos==ypos) {\n        if (v[xpos].F+yrem <= v[xpos].S)\n          next.push_back(pii(v[xpos].F+yrem, v[xpos].S));\n        next.insert(next.end(), v.begin()+xpos+1, v.end());\n        if (v[xpos].F+xrem <= v[xpos].F+yrem-1)\n          next.push_back(pii(v[xpos].F+xrem, v[xpos].F+yrem-1));\n        next.insert(next.end(), v.begin(), v.begin() + xpos);\n        if (v[xpos].F <= v[xpos].F+xrem-1)\n          next.push_back(pii(v[xpos].F, v[xpos].F+xrem-1));\n      } else {\n        if (v[ypos].F+yrem <= v[ypos].S)\n          next.push_back(pii(v[ypos].F+yrem, v[ypos].S));\n        next.insert(next.end(), v.begin()+ypos+1, v.end());\n        if (v[xpos].F+xrem <= v[xpos].S)\n          next.push_back(pii(v[xpos].F+xrem, v[xpos].S));\n        next.insert(next.end(), v.begin()+xpos+1, v.begin()+ypos);\n        if (v[ypos].F <= v[ypos].F+yrem-1)\n          next.push_back(pii(v[ypos].F, v[ypos].F+yrem-1));\n        next.insert(next.end(), v.begin(), v.begin() + xpos);\n        if (v[xpos].F <= v[xpos].F+xrem-1)\n          next.push_back(pii(v[xpos].F, v[xpos].F+xrem-1));\n      }\n      v = next;\n      // FOR(it, v) {\n      //   printf(\"(%d,%d)\",it->F,it->S);\n      // }\n      // cout << endl;\n    }\n    int res = 0;\n    int num = 0;\n    bool f = 0;\n    REP(i, v.size()) {\n      int tmp = v[i].S - v[i].F + 1;\n      if (f) {\n        if (num < q && q <= num+tmp) {\n          if (v[i].F <= r) res += min(min(r, v[i].S), v[i].F+q-num-1) - v[i].F + 1;\n          break;\n        }\n        if (v[i].F <= r) res += min(r, v[i].S)-v[i].F+1;\n      } else if (num < p && p <= num+tmp) {\n        if (v[i].F + p-num-1 <= r) res += min(r, v[i].S) - (v[i].F+p-num-1) + 1;\n        f = 1;\n      }\n      num += tmp;\n    }\n    cout << res << endl;\n  }\n}"
  },
  {
    "language": "C++",
    "code": "#include <iostream>\n#include <algorithm>\n#include <vector>\nusing namespace std;\nint main(){\n\tint n,m,p,q,r,x,y;\n\tvector<int>::iterator itx,ity,it;\n\tfor(;cin>>n>>m>>p>>q>>r;cout<<x<<endl){\n\t\tvector<int> v1,v2;\n\t\tv1.push_back(0);\n\t\tfor(v1.push_back(r);m--;v2.clear()){\n\t\t\tcin>>x>>y;\n\t\t\titx=upper_bound(v1.begin(),v1.end(),x);\n\t\t\tity=upper_bound(v1.begin(),v1.end(),y);\n\t\t\t\n//\t\t\tif( ity-v1.begin()+1 & 1 )v2.push_back(0);\n//\t\t\tv2.push_back(0);\n\t\t\tv2.insert(v2.end(),ity-v1.begin()&1?1:2,0);\n\t\t\tfor(it=ity;it!=v1.end();++it)\n\t\t\t\tv2.push_back(*it - y);\n\t\t\t\n\t\t\tif(v1.end()-itx & 1)v2.push_back(n-y);\n\t\t\tfor(it=itx;it!=ity;++it)\n\t\t\t\tv2.push_back(*it-x+n-y);\n\t\t\t\n\t\t\tit = v1.begin();\n\t\t\tif(ity-v1.begin() & 1)++it;\n\t\t\tif(!it[1])it+=2;\n\t\t\tif(*it+n-x==v2.back()){++it;v2.pop_back();}\n\t\t\tfor(;it!=itx;++it)\n\t\t\t\tv2.push_back(*it+n-x);\n\t\t\t\n\t\t\tv1.swap(v2);\n\t\t}\n\t\tv1.insert( upper_bound(v1.begin(),v1.end(),p-1), 2, p-1);\n\t\tv1.insert( lower_bound(v1.begin(),v1.end(),q), q );\n\t\tv1.push_back(n);\n\t\tit = upper_bound(v1.begin(),v1.end(),p-1);\n\t\tif(it-v1.begin() & 1) --it;\n\t\tfor(x=0;*it<q;\n\t\t\tx+=*it++-m)\n\t\t\tm=*it++;\n\t}\n}"
  },
  {
    "language": "C++",
    "code": "#include<iostream>\n#include<vector>\n#include<utility>\nusing namespace std;\ntypedef pair<int, int> PII;\ntypedef vector<PII> VP;\ntypedef VP::iterator VPI;\n\nint main()\n{\n  while(true){\n    int n;\n    cin >> n;\n    if(!n) break;\n\n    int m, p, q, r, x[5000], y[5000];\n    cin >> m >> p >> q >> r;\n    for(int i = 0; i < m; i++) cin >> x[i] >> y[i];\n\n    VP c;\n    c.push_back(make_pair(1, r));\n\n    for(int i = 0; i < m; i++){\n      for(int j = 0; j < c.size(); j++){\n\tif(c[j].first <= x[i] && x[i] < c[j].second && c[j].second <= y[i]){\n          c.push_back(make_pair(x[i] + 1, c[j].second));\n\t  c[j].second = x[i];\n\t}\n\telse if(x[i] < c[j].first && c[j].first <= y[i] && y[i] < c[j].second){\n\t  c.push_back(make_pair(y[i] + 1, c[j].second));\n\t  c[j].second = y[i];\n\t}\n\telse if(c[j].first <= x[i] && y[i] < c[j].second){\n\t  c.push_back(make_pair(x[i] + 1, y[i]));\n\t  c.push_back(make_pair(y[i] + 1, c[j].second));\n\t  c[j].second = x[i];\n\t}\n\t\n\tif(c[j].second <= x[i]){\n\t  c[j].first += n - x[i];\n\t  c[j].second += n - x[i];\n\t}\n\telse if(y[i] < c[j].first){\n\t  c[j].first += - y[i];\n\t  c[j].second += - y[i];\n\t}\n\telse{\n\t  c[j].first += - x[i] + n - y[i];\n\t  c[j].second += - x[i] + n - y[i];\n\t}    \n      }\n    }\n\n    int ans = 0;\n    for(int i = 0; i < c.size(); i++){\n      if(p <= c[i].first && c[i].second <= q) ans += c[i].second - c[i].first + 1;\n      else if(c[i].first < p && p <= c[i].second && c[i].second <= q) ans += c[i].second - p + 1;\n      else if(p <= c[i].first && c[i].first <= q && q < c[i].second) ans += q - c[i].first + 1;\n      else if(c[i].first < p && q < c[i].second) ans += q - p + 1;\n    }\n    \n    cout << ans << endl;\n  }\n  return 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include <iostream>\n#include <algorithm>\n#include <vector>\nusing namespace std;\n\nvoid loop(){while(1);}\n\nint main(){\n\tint n, m, p, q, r, x, y;\n\tvector<int>::iterator itx, ity, it;\n\n\twhile( cin >> n >> m >> p >> q >> r ){\n\t\tvector<int> v1, v2;\n\t\tv1.push_back(0);\n\t\tv1.push_back(r);\n\t\t\n\t\tfor(int i = 0; i < m; ++i){\n\t\t\tcin >> x >> y;\n\t\t\titx = upper_bound(v1.begin(), v1.end(), x);\n\t\t\tity = upper_bound(v1.begin(), v1.end(), y);\n\n\t\t\tif( (ity - v1.begin()) % 2 == 0 ){\tv2.push_back(0);\t}\n\t\t\tv2.push_back(0);\n\n\t\t\tfor(it = ity; it != v1.end(); ++it){\n\t\t\t\tv2.push_back(*it - y);\n\t\t\t}\n\n\t\t\tif( (v1.end() - itx) % 2 != 0 ){\tv2.push_back(n - y);\t}\n\t\t\tfor(it = itx; it != ity; ++it){\n\t\t\t\tv2.push_back(*it - x + n - y);\n\t\t\t}\n\t\t\t\n\t\t\tit = v1.begin();\n\t\t\tif( (ity - v1.begin()) % 2 != 0 ){\t++it;\t}\nif(it+1>=v1.end())loop();\n\t\t\tif( !it[1] ){\n\t\t\t\t it += 2;\t//重複排除\n\t\t\t}\n\t\t\tif( *it + n - x == v2.back() ){\t//重複排除\n\t\t\t\t++it;\n\t\t\t\tv2.pop_back();\n\t\t\t}\n\n\t\t\tfor( ; it != itx; ++it){\n\t\t\t\tv2.push_back(*it + n - x);\n\t\t\t}\n\n\t\t\tv1.swap(v2);\n\t\t\tv2.clear();\n\t\t}\n\n\t\tv1.insert( upper_bound(v1.begin(), v1.end(), p - 1), 2, p - 1);\n\t\tv1.insert( lower_bound(v1.begin(), v1.end(), q), q);\n\t\tv1.push_back(n);\n\n\t\tit = upper_bound(v1.begin(), v1.end(), p - 1);\n\t\tif( (it - v1.begin()) % 2 != 0) --it;\n\n\t\tint ans = 0;\n\t\tfor( ; *it < q; ++it){\n\t\t\tint prev = *it;\n\t\t\t++it;\n\t\t\tans += *it - prev;\n\t\t}\n\t\t\n\t\tcout << ans << '\\n';\n\t}\n}"
  },
  {
    "language": "C++",
    "code": "#include<stdio.h>\n#include<vector>\n#include<map>\n#include<algorithm>\nusing namespace std;\ntypedef struct pair<int,int> P;\nvector<P> v;\nint search(int x){\n\tint l=0,r=v.size(),mid;\n\tint i;\n\tfor(i=0;i<20;i++){\n\t\tmid=(l+r)/2;\n\t\tif(v[mid].first==x)return mid;\n\t\telse if(v[mid].first>x)r=mid;\n\t\telse l=mid;\n\t}\n\treturn mid;\n}\nint min(int a,int b){return a<b?a:b;}\nint max(int a,int b){return a>b?a:b;}\nint main(){\n\tint n,m,p,q,r;\n\tint i,j;\n\twhile(1){\n\tscanf(\"%d\",&n);\n\tif(n==0)return 0;\n\tscanf(\"%d\",&m);\n\tscanf(\"%d %d %d\",&p,&q,&r);\n\tp--;q--;\n\tv.clear();\n\tv.push_back(P(-1,0));\n\tv.push_back(P(0,r));\n\tfor(i=0;i<m;i++){\n\t\tint a,b;\n\t\tscanf(\"%d %d\",&a,&b);\n\t\tint x=search(a);\n\t\tint y=search(b);\n\t\tprintf(\"%d %d\\n\",x,y);\n\t\tif(b<=v[y].first+v[y].second){\n\t\t\tv.push_back(P(b,v[y].first+v[y].second-b));\n\t\t\tv[y].second-=v[y].first+v[y].second-b;\n\t\t}\n\t\tif(a<=v[x].first+v[x].second){\n\t\t\tv.push_back(P(n,v[x].first+v[x].second-a));\n\t\t\tv[x].second-=v[x].first+v[x].second-a;\n\t\t}\n\t\tfor(j=1;j<=x;j++)v[j].first+=n-a;\n\t\tfor(j=x+1;j<=y;j++)v[j].first+=(n-b)-a;\n\t\tfor(j=y+1;j<v.size();j++)v[j].first-=b;\n\t\tsort(v.begin(),v.end());\n\t}\n\tint ans=0;\n\tfor(i=0;i<v.size();i++){\n\t\tif(v[i].first>=p&&v[i].first<=q){\n\t\t\tans+=min(v[i].second,q-v[i].first+1);\n\t\t}\n\t}\n\tprintf(\"%d\\n\",ans);\n\t}\n}"
  },
  {
    "language": "C++",
    "code": "#include <tuple>\n#include <vector>\n#include <iostream>\n#include <algorithm>\n\nusing namespace std;\n\nint n, m, p, q, c, r1, r2;\n\nvector<tuple<int, int, int> > dat;\n\ninline void divide(int pos)\n{\n\tvector<tuple<int, int, int> > dat1;\n\n\tfor (int i = 0; i < dat.size(); i++)\n\t{\n\t\tint l = get<0>(dat[i]);\n\t\tint r = get<1>(dat[i]);\n\t\tint t = get<2>(dat[i]);\n\n\t\tif (l < pos && pos < r)\n\t\t{\n\t\t\tdat1.push_back(make_tuple(l, pos, t));\n\t\t\tdat1.push_back(make_tuple(pos, r, t + pos - l));\n\t\t}\n\t\telse\n\t\t{\n\t\t\tdat1.push_back(make_tuple(l, r, t));\n\t\t}\n\t}\n\n\tdat = dat1;\n}\n\ninline void shuffle(int a, int b)\n{\n\tdivide(a);\n\tdivide(b);\n\n\tint l = lower_bound(dat.begin(), dat.end(), make_tuple(a, 0, 0)) - dat.begin();\n\tint r = lower_bound(dat.begin(), dat.end(), make_tuple(b, 0, 0)) - dat.begin();\n\n\tvector<tuple<int, int, int> > dat1;\n\n\tint pos = 0;\n\n\tfor (int i = r; i < dat.size(); i++)\n\t{\n\t\tdat1.push_back(make_tuple(pos, pos - get<0>(dat[i]) + get<1>(dat[i]), get<2>(dat[i]))); pos += get<1>(dat[i]) - get<0>(dat[i]);\n\t}\n\n\tfor (int i = l; i < r; i++)\n\t{\n\t\tdat1.push_back(make_tuple(pos, pos - get<0>(dat[i]) + get<1>(dat[i]), get<2>(dat[i]))); pos += get<1>(dat[i]) - get<0>(dat[i]);\n\t}\n\n\tfor (int i = 0; i < l; i++)\n\t{\n\t\tdat1.push_back(make_tuple(pos, pos - get<0>(dat[i]) + get<1>(dat[i]), get<2>(dat[i]))); pos += get<1>(dat[i]) - get<0>(dat[i]);\n\t}\n\n\tdat = dat1;\n}\n\nint main()\n{\n\twhile(true)\n\t{\n\t\tscanf(\"%d\", &n); if (n == 0) { break; }\n\t\tscanf(\"%d\", &m);\n\t\tscanf(\"%d\", &p); p--;\n\t\tscanf(\"%d\", &q); q--;\n\t\tscanf(\"%d\", &c);\n\n\t\tdat.clear();\n\n\t\tdat.push_back(make_tuple(0, n, 1));\n\n\t\tfor (int i = 0; i < m; i++)\n\t\t{\n\t\t\tscanf(\"%d\", &r1);\n\t\t\tscanf(\"%d\", &r2);\n\n\t\t\tshuffle(r1, r2);\n\t\t}\n\n\t\tint ret = 0;\n\n\t\tfor (int i = 0; i < dat.size(); i++)\n\t\t{\n\t\t\tint l = get<0>(dat[i]);\n\t\t\tint r = get<1>(dat[i]);\n\t\t\tint t = get<2>(dat[i]);\n\n\t\t\tif (p <= l && r <= q + 1)\n\t\t\t{\n\t\t\t\tret += min(max(c - t + 1, 0), r - l);\n\t\t\t}\n\t\t\telse if (p <= l && l <= q)\n\t\t\t{\n\t\t\t\tret += min(max(c - t + 1, 0), q - l + 1);\n\t\t\t}\n\t\t\telse if (p <= r && r <= q)\n\t\t\t{\n\t\t\t\tret += max(c - (t + (p - l)) + 1, 0);\n\t\t\t}\n\t\t}\n\n\t\tprintf(\"%d\\n\", ret);\n\t}\n\n\treturn 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include<iostream>\n#include<string>\n#include<cmath>\n#include<queue>\n#include<map>\n#include<set>\n#include<list>\n#include<iomanip>\n#include<vector>\n#include<functional>\n#include<algorithm>\n#include<cstdio>\n#include<unordered_map>\nusing namespace std;\n//---------------------------------------------------\n//????????????????????????????????????\n#define int long long\n#define str string\n#define rep(i,j) for(int i=0;i<(int)(j);i++)\ntypedef long long ll;\ntypedef long double ld;\nconst ll inf = 4523372036854775807;\nconst int inf2 = 1145141919;\nconst ld pi = 3.14159265358979323846264338327950288419716939937510582097494459230781640628620899;\nstruct P {\n\tll pos, cost;\n};\nbool operator<(P a, P b) { return a.cost < b.cost; }\nbool operator>(P a, P b) { return a.cost > b.cost; }\nstruct B {//??£??\\???????????¨???\n\tll to, cost;\n};\nstruct S {//???????????±?????\\???????????°\n\tint from, to, cost;\n};\nbool operator<(S a, S b) { return a.cost < b.cost; }\nbool operator>(S a, S b) { return a.cost > b.cost; }\nstruct H {\n\tint x, y;\n};\nll gcm(ll i, ll j) {//?????§??¬?´???°\n\tif (i > j) swap(i, j);\n\tif (i == 0) return j;\n\treturn gcm(j%i, i);\n}\nld rad(ld a, ld b, ld c, ld d) {\n\treturn sqrt(pow(a - c, 2) + pow(b - d, 2));\n}//rad?????§?¨???????2??????????????¢\n //---------------------------------------------------\n //+++++++++++++++++++++++++++++++++++++++++++++++++++\nstruct A {\n\tint s, e, s2, size;\n\t//????????????????????????????????????????????????????????????????????????\n};\nint n, m, p, q, r;\nvector<A>a[2];\nvector<int>b[2];\nsigned main() {\n\twhile (cin >> n&&n!=0) {\n\t\tcin >> m >> p >> q >> r;\n\t\tint d = 0, e = 1, k, t, x, y;\n\t\ta[0].clear(); a[1].clear();\n\t\tb[0].clear(); b[1].clear();\n\t\ta[d].push_back(A{ 1,n,1,n });\n\t\tb[d].push_back(1);\n\t\tfor (int z = 0; z < m; z++) {\n\t\t\ta[e].clear(); b[e].clear();\n\t\t\tcin >> x >> y;\n\t\t\t//y+1??????????????????????????§????????????????????????????????????\n\t\t\tk = lower_bound(b[d].begin(), b[d].end(), y + 1) - b[d].begin();\n\t\t\tif (k == b[d].size() || a[d][k].s2 > y + 1)\n\t\t\t\tk--;\n\t\t\tb[e].push_back(1);\n\t\t\ta[e].push_back(A{ a[d][k].s + (y + 1 - a[d][k].s2),a[d][k].e,1,a[d][k].size - (y + 1 - a[d][k].s2) });\n\t\t\tint sum = a[d][k].size - (y + 1 - a[d][k].s2) + 1;\n\t\t\tk++;\n\t\t\tfor (; k < a[d].size(); k++) {\n\t\t\t\tb[e].push_back(sum);\n\t\t\t\ta[e].push_back(A{ a[d][k].s,a[d][k].e,sum,a[d][k].size });\n\t\t\t\tsum += a[d][k].size;\n\t\t\t}\n\t\t\t//x+1?????????y?????§???????????????????????????????????????\n\t\t\tk = lower_bound(b[d].begin(), b[d].end(), x + 1) - b[d].begin();\n\t\t\tt = lower_bound(b[d].begin(), b[d].end(), y) - b[d].begin();\n\t\t\tif (k == a[d].size() || a[d][k].s2 > x + 1)\n\t\t\t\tk--;\n\t\t\tif (t == a[d].size() || a[d][t].s2 > y)\n\t\t\t\tt--;\n\t\t\tif (k == t) {\n\t\t\t\tb[e].push_back(sum);\n\t\t\t\ta[e].push_back(A{ a[d][k].s + (x + 1 - a[d][k].s2),a[d][k].s + (y - a[d][k].s2),sum,y - x });\n\t\t\t\tsum += y - x;\n\t\t\t}\n\t\t\telse {\n\t\t\t\tb[e].push_back(sum);\n\t\t\t\ta[e].push_back(A{ a[d][k].s + (x + 1 - a[d][k].s2),a[d][k].e,sum,a[d][k].size - (x + 1 - a[d][k].s2) });\n\t\t\t\tsum += (a[d][k].size - (x + 1 - a[d][k].s2));\n\t\t\t\tk++;\n\t\t\t\tfor (; k < t; k++) {\n\t\t\t\t\tb[e].push_back(sum);\n\t\t\t\t\ta[e].push_back(A{ a[d][k].s,a[d][k].e,sum,a[d][k].size });\n\t\t\t\t\tsum += a[d][k].size;\n\t\t\t\t}\n\t\t\t\tb[e].push_back(sum);\n\t\t\t\ta[e].push_back(A{ a[d][k].s,a[d][k].s + (y - a[d][k].s2),sum,y - a[d][k].s2 + 1 });\n\t\t\t\tsum += y - a[d][k].s2 + 1;\n\t\t\t}\n\t\t\t//1??????x?????§????????????????????????????????§?????????\n\t\t\tk = lower_bound(b[d].begin(), b[d].end(), x) - b[d].begin();\n\t\t\tif (k == b[d].size() || a[d][k].s2 > x)\n\t\t\t\tk--;\n\t\t\tfor (int i = 0; i < k; i++) {\n\t\t\t\tb[e].push_back(sum);\n\t\t\t\ta[e].push_back(A{ a[d][i].s,a[d][i].e,sum,a[d][i].size });\n\t\t\t\tsum += a[d][i].size;\n\t\t\t}\n\t\t\tb[e].push_back(sum);\n\t\t\ta[e].push_back(A{ a[d][k].s,a[d][k].s + (x - a[d][k].s2),sum,x - a[d][k].s2 + 1 });\n\t\t\tswap(d, e);\n\t\t}\n\t\tk = lower_bound(b[d].begin(), b[d].end(), p) - b[d].begin();\n\t\tt = lower_bound(b[d].begin(), b[d].end(), q) - b[d].begin();\n\t\tif (k == b[d].size() || a[d][k].s2 > p) k--;\n\t\tif (t == b[d].size() || a[d][t].s2 > q) t--;\n\t\ta[d][k].size -= (p - a[d][k].s2);\n\t\ta[d][k].s = a[d][k].s + (p - a[d][k].s2);\n\t\ta[d][t].size = (q - a[d][t].s2 + 1);\n\t\ta[d][t].e = a[d][t].s + (q - a[d][t].s2);\n\t\tint sum = 0;\n\t\tif (k == t) {\n\t\t\tif (a[d][k].e <= r)\n\t\t\t\tsum = a[d][k].size;\n\t\t\telse if (a[d][k].s <= r)\n\t\t\t\tsum = r - a[d][k].s + 1;\n\t\t}\n\t\telse {\n\t\t\tfor (; k <= t; k++) {\n\t\t\t\tif (a[d][k].e <= r)\n\t\t\t\t\tsum += a[d][k].size;\n\t\t\t\telse if (a[d][k].s <= r)\n\t\t\t\t\tsum += r - a[d][k].s + 1;\n\t\t\t}\n\t\t}\n\t\tcout << sum << endl;\n\t}\n\tgetchar(); getchar();\n}"
  },
  {
    "language": "C++",
    "code": "#include <iostream>\n#include <vector>\nusing namespace std;\n\nclass Cards\n{\n  public:\n    Cards(int n);\n\n  public:\n    void Shuffle(int x, int y);\n    int Ans(int p, int q, int r);\n\n  private:\n    int m_n;\n    vector<int> m_cards;\n};\n\nCards::Cards(int n) :\n  m_n(n), m_cards(n)\n{\n  for (int i = 0; i < n; ++i)\n  {\n    m_cards[i] = i + 1;\n  }\n}\n\nvoid Cards::Shuffle(int x, int y)\n{\n  vector<int> new_cards;\n  for (int i = y; i < m_n; ++i)\n  {\n    new_cards.push_back(m_cards[i]);\n  }\n\n  for (int i = x; i < y; ++i)\n  {\n    new_cards.push_back(m_cards[i]);\n  }\n\n  for (int i = 0; i < x; ++i)\n  {\n    new_cards.push_back(m_cards[i]);\n  }\n  m_cards.swap(new_cards);\n}\n\nint Cards::Ans(int p, int q, int r)\n{\n  int result = 0;\n  for (int i = p - 1; i < q; ++i)\n  {\n    if (m_cards[i] <= r)\n    {\n      result++;\n    }\n  }\n  return result;\n}\n\nint main(void)\n{\n  while (true)\n  {\n    int n;\n    cin >> n;\n    if (n == 0) break;\n    Cards cards(n);\n\n    int m;\n    cin >> m;\n    int p, q, r;\n    cin >> p >> q >> r;\n\n    for (int i = 0; i < m; ++i)\n    {\n      int x, y;\n      cin >> x >> y;\n      cards.Shuffle(x, y);\n    }\n    cout << cards.Ans(p, q, r) << endl;\n  }\n  return 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include <cstdio>\n#include <algorithm>\n#include <queue>\nusing namespace std;\ntypedef pair<int,int> P;\n#define mp make_pair\n#define f first\n#define s second\nint main(){\nwhile(1){\nint n,m,p,q,r;\nqueue<P>que;\nscanf(\"%d\",&n);\nif(!n) break;\nscanf(\"%d\",&m);\nscanf(\"%d %d %d\",&p,&q,&r);\nque.push(mp(1,r));\nfor(int i=0;i<m;i++){\n\tint x,y;\n\tscanf(\"%d %d\",&x,&y);\n\tint e=que.size();\n\tfor(int j=0;j<e;j++){\n\t\tP pp=que.front(); que.pop();\n\t\tint a=pp.f,b=pp.s;\n\t\tif(b<=x){\n\t\t\tque.push(mp(n-x+a,n-x+b));\n\t\t}else if(b>x && b<=y){\n\t\t\tif(a<=x){\n\t\t\t\tque.push(mp(n-x+a,n));\n\t\t\t\tque.push(mp(n-y+1,n+b-x-y));\n\t\t\t}else{\n\t\t\t\tque.push(mp(n-y+a-x,n+b-x-y));\n\t\t\t}\n\t\t}else{\n\t\t\tif(a<=x){\n\t\t\t\tque.push(mp(1,b-y));\n\t\t\t\tque.push(mp(n-x+a,n));\n\t\t\t\tque.push(mp(n-y+1,n-x));\n\t\t\t}else if(a>x && a<=y){\n\t\t\t\tque.push(mp(1,b-y));\n\t\t\t\tque.push(mp(n-y-x+a,n-x));\n\t\t\t}else{\n\t\t\t\tque.push(mp(a-y,b-y));\n\t\t\t}\n\t\t}\n\t}\n}\nint ans=0;\nwhile(que.size()){\nP pp=que.front(); que.pop();\nif(pp.s<p || pp.f>q){\n}else{\nans+=min(q,pp.s)-max(p,pp.f)+1;\n}\n}\nprintf(\"%d\\n\",ans);\nans=0;\n}\nreturn 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include<iostream>\nusing namespace std;\nint main() {\n\tint n;\n\twhile (cin >> n&&n != 0) {\n\t\tint *line;\n\t\tline = new int[n];\n\t\tfor (int i = 0; i < n; ++i) {\n\t\t\tline[i] = i + 1;\n\t\t}\n\t\tint search[3];\n\t\tint act[2];\n\t\tint time;\n\t\tcin >> time;\n\t\tfor (int i = 0; i < 3; ++i) {\n\t\t\tcin >> search[i];\n\t\t}\n\t\tint *dommy;\n\t\tfor (int i = 0; i < time; ++i) {\n\t\t\tint nsize = 0;\n\t\t\tdommy = new int[n];\n\t\t\tfor (int j = 0; j < 2; ++j) {\n\t\t\t\tcin >> act[j];\n\t\t\t}\n\t\t\tfor (int j = act[1]; j < n; ++j) {\n\t\t\t\tdommy[nsize] = line[j];\n\t\t\t\t++nsize;\n\t\t\t}\n\t\t\tfor (int j = act[0]; j < act[1]; ++j) {\n\t\t\t\tdommy[nsize] = line[j];\n\t\t\t\t++nsize;\n\t\t\t}\n\t\t\tfor (int j = 0; j < act[0]; ++j) {\n\t\t\t\tdommy[nsize] = line[j];\n\t\t\t\t++nsize;\n\t\t\t}\n\t\t\tdelete[] line;\n\t\t\tline = dommy;\n\t\t}\n\t\tint answer = 0;\n\t\tfor (int i = search[0] - 1; i < search[1]; ++i) {\n\t\t\tif (line[i] <= search[2]) {\n\t\t\t\t++answer;\n\t\t\t}\n\t\t}\n\t\tcout << answer << endl;\n\t\tdelete[] line;\n\t}\n\treturn 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include<vector>\n#include<map>\n#include<set>\n#include<algorithm>\n#include<functional>\n#include<numeric>\n#include<utility>\n#include<sstream>\n#include<iostream>\n#include<iomanip>\n#include<cstdio>\n#include<cmath>\n#include<cstdlib>\n#include<cctype>\n#include<string>\n#include<cstring>\n#include<list>\nusing namespace std;\ntypedef vector<int>VI;\ntypedef vector<VI>VVI;\ntypedef vector<string>VS;\ntypedef pair<int,int>PII;\ntypedef long long LL;\n#define ALL(a) (a).begin(),(a).end()\n#define RALL(a) (a).rbegin(),(a).rend()\n#define PB push_back\n#define EACH(i,c) for(typeof((c).begin())i=(c).begin();i!=(c).end();i++)\n#define FOR(i,a,b) for(int i=(a);i<(b);++i)\n#define REP(i,n) FOR(i,0,n)\n\nstruct data{\n    int l,r;\n    data(int a,int b):l(a),r(b){}\n    data(){}\n};\n\nint N,M;\nint p,q,r;\nint x[5001],y[5001];\n\nint solve(){\n    list<data>L;\n    L.push_back(data(1,N));\n    x[M]=p-1,y[M]=q;\n    REP(i,M+1){\n        list<data>a,b,c;\n        int sum=0;\n        list<data>::iterator it=L.begin();\n        while(true){\n            data d=*it;\n            if(x[i]==0)break;\n            if(sum+(d.r-d.l+1)<=x[i]){\n                a.push_back(d);\n                L.pop_front();\n                it=L.begin();\n                sum+=(d.r-d.l+1);\n                if(sum==x[i])break;\n            }\n            else{\n                a.push_back(data(d.l,x[i]+d.l-1-sum));\n                //cout<<\"**** \"<<d.l<<\" \"<<x[i]+d.l-1-sum<<endl<<endl;\n                L.pop_front();\n                L.push_front(data(x[i]+d.l-sum,d.r));\n                it=L.begin();\n                break;\n            }\n        }\n        sum=x[i];\n        while(true){\n            data d=*it;\n            if(x[i]==y[i])break;\n            if(sum+(d.r-d.l+1)<=y[i]){\n                b.push_back(d);\n                L.pop_front();\n                it=L.begin();\n                sum+=(d.r-d.l+1);\n                if(sum==y[i])break;\n            }\n            else{\n                b.push_back(data(d.l,y[i]+d.l-1-sum));\n                L.pop_front();\n                L.push_front(data(y[i]-sum+d.l,d.r));\n                it=L.begin();\n                break;\n            }\n        }\n        c=L;\n        L.clear();\n        if(i==M){\n            L=b;\n            break;\n        }\n        L.insert(L.end(),c.begin(),c.end());\n        L.insert(L.end(),b.begin(),b.end());\n        L.insert(L.end(),a.begin(),a.end());\n        //cout<<endl;EACH(it,L)cout<<it->l<<\" \"<<it->r<<endl;\n    }\n    //cout<<endl;EACH(it,L)cout<<it->l<<\" \"<<it->r<<endl;\n    int cnt=0;\n    EACH(it,L){\n        int l=it->l,u=it->r;\n        if(l>r)continue;\n        if(u<=r)cnt+=u-l+1;\n        else{\n            cnt+=r-l+1;\n        }\n    }\n    return cnt;\n}\n\n\n\n\n\n\n\nint main(){\n    while(cin>>N,N){\n        cin>>M;\n        cin>>p>>q>>r;\n        REP(i,M)cin>>x[i]>>y[i];\n        cout<<solve()<<endl;\n    }\n    return 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include <iostream>\n#include <algorithm>\n#include <vector>\nusing namespace std;\n\nint c1[5010],c2[5010],vv[5010];\nint main(){\n\tint N,M,P,Q,R,ac1,ac2,cnt;\n\twhile(1){\n\t\tcin>>N;\n\t\tif(N==0) break;\n\t\tcin>>M>>P>>Q>>R;\n\t\tfor(int i=0;i<M;i++){\n\t\t\tcin>>ac1>>ac2;\n\t\t\tc1[i]=ac1;\n\t\t\tc2[i]=ac2;\n\t\t}\n\t\tfor(int i=1;i<=N;i++) vv[i]=i;\n\t\t\n\t\tfor(int i=0;i<M;i++){\n\t\t\treverse(vv+1,vv+c1[i]+1);\n\t\t\treverse(vv+c1[i]+1,vv+c2[i]+1);\n\t\t\treverse(vv+c2[i]+1,vv+N+1);\n\t\t\treverse(vv+1,vv+N+1);\n\t\t}\n\t\tcnt=0;\n\t\tfor(int i=P;i<=Q;i++){\n\t\t\tif(vv[i]<=R) cnt++;\n\t\t}\n\t\tcout<<cnt<<endl;\n\t}\n\treturn 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include<iostream>\n#include<map>\n#include<queue>\nusing namespace std;\ntypedef pair<int,int> P;\n#define fr first\n#define sc second\n#define rep(i,n) for(int i = 0 ; i < n ; ++i )\n\nint n,m,p,q,r;int a;\ndeque<P> card;\n\nint query(){\n  int sum = 0,ans = 0;\n  while(sum + card.front().sc - card.front().fr + 1 < p){\n    sum += card.front().sc - card.front().fr + 1;\n    card.pop_front();\n  }\n  if(sum + 1 != p) card.front().fr = card.front().fr + p - sum;\n  sum = p;\n  while(sum + card.front().sc - card.front().fr + 1 <= q){\n    if(card.front().sc <= r){ //完全に含む\n      ans += card.front().sc - card.front().fr + 1;\n    }else if(card.front().fr <= r){ //微妙に含む\n      ans += r - card.front().fr + 1;\n    }\n    sum += card.front().sc - card.front().fr + 1;\n    card.pop_front();\n  }\n  if(!card.empty() && sum != q){\n    card.push_front(P(card.front().fr,card.front().fr+q-sum-1));\n    if(card.front().sc <= r){ //完全に含む\n      ans += card.front().sc - card.front().fr + 1;\n    }else if(card.front().fr <= r){ //微妙に含む\n      ans += r - card.front().fr + 1; \n    }\n  }\n  return ans;\n}\ndeque<P> shuffle(int x,int y){\n  deque<P> A,B,C;\n  int sum = 0;\n  while(sum + card.front().sc - card.front().fr + 1 <= x){\n    A.push_back(card.front());\n    sum += card.front().sc - card.front().fr + 1;\n    card.pop_front();\n  }\n\n  if(sum != x){\n    A.push_back(P(card.front().fr,card.front().fr + x - sum - 1));\n    card.front().fr = card.front().fr + x - sum;\n    sum = x;\n  }\n  while(sum + card.front().sc - card.front().fr + 1 <= y){\n    B.push_back(card.front());\n    sum += card.front().sc - card.front().fr + 1;\n    card.pop_front();\n  }\n\n  if(sum != y){\n    B.push_back(P(card.front().fr,card.front().fr + y - sum - 1));\n    card.front().fr = card.front().fr + y - sum;\n    sum = y;\n  }\n  while(!card.empty()){\n    C.push_back(card.front());\n    card.pop_front();\n  }\n  C.insert(C.end(),B.begin(),B.end());\n  C.insert(C.end(),A.begin(),A.end());\n  return C;\n}\n\nint main(){\n  while(cin >> n , n){\n    cin >> m >> p >> q >> r;\n    card.push_back(P(1,n));\n    while(m--){\n      int x,y;\n      cin >> x >> y;\n      card = shuffle(x,y);\n    }\n    cout << query() << endl;\n    card.clear();\n  }\n}"
  },
  {
    "language": "C++",
    "code": "#define _USE_MATH_DEFINES\n#define INF 0x3f3f3f3f\n\n#include <iostream>\n#include <cstdio>\n#include <sstream>\n#include <cmath>\n#include <cstdlib>\n#include <algorithm>\n#include <queue>\n#include <stack>\n#include <limits>\n#include <map>\n#include <string>\n#include <cstring>\n#include <set>\n#include <deque>\n#include <bitset>\n#include <list>\n#include <cctype>\n#include <utility>\n  \nusing namespace std;\n  \ntypedef long long ll;\ntypedef pair <int,int> P;\ntypedef pair <int,P> PP;\n  \nstatic const double EPS = 1e-8;\n  \nstatic const int tx[] = {0,1,0,-1};\nstatic const int ty[] = {-1,0,1,0};\n\nint main(){\n  int total_cards;\n  while(~scanf(\"%d\",&total_cards)){\n    if(total_cards == 0) break;\n    int total_shuffles;\n    int first,last,upper;\n\n    scanf(\"%d\",&total_shuffles);\n    scanf(\"%d %d %d\",&first,&last,&upper);\n    \n    vector<P> cards;\n    cards.push_back(P(1,total_cards));\n\n    for(int shuffle_idx=0;shuffle_idx<total_shuffles;shuffle_idx++){\n      int x,y;\n      scanf(\"%d %d\",&x,&y);\n      //x -> none\n      //y -> 1\n      //n -> x+1\n      //C -> B -> A\n      vector<P> A;\n      vector<P> B;\n      vector<P> C;\n      vector<P> next;\n\n      int sum = 0;\n      int prev_sum = 0;\n      for(int j=0;j<cards.size();j++){\n        prev_sum = sum;\n        sum += cards[j].second - cards[j].first + 1;\n        if(prev_sum < x){\n          if(sum <= x){\n            A.push_back(cards[j]);\n          }\n          else if(sum > x && sum <= y){\n            A.push_back(P(cards[j].first,cards[j].first + (x - prev_sum - 1)));\n            B.push_back(P(cards[j].first + (x - prev_sum),\n                          cards[j].second));\n          }\n          else if(sum > y){\n            A.push_back(P(cards[j].first,cards[j].first + (x - prev_sum - 1)));\n            B.push_back(P(cards[j].first + (x - prev_sum),\n                          cards[j].first + (x - prev_sum) + (y - x - 1)));\n            C.push_back(P(cards[j].first + (x - prev_sum) + (y - x),\n                          cards[j].second));\n          }\n        }\n        else if(prev_sum >= x){\n          if(prev_sum < y){\n            if(sum <= y){\n              B.push_back(P(cards[j].first,cards[j].second));\n            }\n            else if(sum > y){\n              B.push_back(P(cards[j].first,cards[j].first + (y - prev_sum - 1)));\n              C.push_back(P(cards[j].first + (y - prev_sum),cards[j].second));\n            }\n          }\n          else if(prev_sum >= y){\n            C.push_back(P(cards[j].first,cards[j].second));\n          }\n        }\n      }\n      for(int i=0;i<C.size();i++){\n        next.push_back(C[i]);\n        // cout << \"C<f,s>=\" << C[i].first << \",\" << C[i].second << endl;\n      }\n      for(int i=0;i<B.size();i++){\n        next.push_back(B[i]);\n        // cout << \"B<f,s>=\" << B[i].first << \",\" << B[i].second << endl;\n      }\n      for(int i=0;i<A.size();i++){\n        next.push_back(A[i]);\n        // cout << \"A<f,s>=\" << A[i].first << \",\" << A[i].second << endl;\n      }\n      // cout << endl;\n      cards = next;\n    }\n\n    int offset = 0;\n    int res = 0;\n    for(int i=0;i<cards.size();i++){\n      int current = cards[i].second - cards[i].first + 1;\n      // cout << \"offset \" << offset << endl;\n      // cout << \"<f,s>=\" << cards[i].first << \",\" << cards[i].second << endl;\n\n      for(int j=0;j<cards[i].second - cards[i].first;j++){\n        if(cards[i].first + j <= upper){\n          res++;\n        }\n      }\n    }\n    printf(\"%d\\n\",res);\n  }\n}"
  },
  {
    "language": "Haskell",
    "code": "import Control.Monad (replicateM)\nimport Data.List (foldl')\n\ntype Stack = [(Int,Int)]\n\nmain = do\n    n <- readLn :: IO Int\n    if n == 0 then return () else do\n        m <- readLn\n        [p,q,r] <- getLine >>= return . map read . words :: IO [Int]\n        xys <- replicateM m\n                (getLine >>= return . (\\[x,y]->(x,y)) . map read . words)\n        let shuffled = foldl' (flip $ uncurry shuffle) [(1,n)] xys\n        print $ countUnder r $ extract p q $ shuffled\n        main\n\nshuffle :: Int -> Int -> Stack -> Stack\nshuffle x y stack = stack2 ++ stack1 ++ stack0\n    where\n    (stack0,stack') = cut x stack\n    (stack1,stack2) = cut (y-x) stack'\n\nextract :: Int -> Int -> Stack -> Stack\nextract p q stack = stack1\n    where\n    (_,stack') = cut (p-1) stack\n    (stack1,_) = cut (q-p+1) stack'\n\ncountUnder :: Int -> Stack -> Int\ncountUnder r [] = 0\ncountUnder r ((a,b):ps)\n    | b <= r = (b-a+1) + countUnder r ps\n    | r < a  = countUnder r ps\n    | otherwise = (r-a+1) + countUnder r ps\n\ncut :: Int -> Stack -> (Stack,Stack)\ncut 0 stack = ([],stack)\ncut k stack = cut' [] stack k\n    where\n    cut' ps ((a,b):qs) k\n        | k <  d = (reverse ((a,a+k-1):ps), (a+k,b):qs)\n        | k == d = (reverse ((a,b):ps), qs)\n        | k >  d = cut' ((a,b):ps) qs (k-d)\n        where\n        d = b-a+1"
  },
  {
    "language": "Haskell",
    "code": "import Control.Applicative\nimport Control.Monad\n\ntype Shuffle = (Int, Int)\n\nmyRead' :: String -> Shuffle\nmyRead' xs = (a, b)\n  where (a:b:_) = map (read :: String -> Int) $ words xs\n\nmyRead :: [String] -> [Shuffle]\nmyRead = map myRead'\n\noperation :: [Int] -> Shuffle -> [Int]\noperation cards (x, y) =\n  let a = take x cards\n      b = take (y - x) $ drop x cards\n      c = drop y cards\n  in\n      c ++ b ++ a\n\nsolver :: [Int] -> [Shuffle] -> Int -> Int -> Int -> Int\nsolver cards op p q r =\n  let result  = foldl operation cards op\n      ansList = drop (p - 1) $ take q result\n  in\n      length $ filter (<= r) ansList\n\nmain :: IO()\nmain = do\n  n <- (read :: String -> Int) <$> getLine -- number of cards\n  unless (n == 0) $ do\n    m <- (read :: String -> Int) <$> getLine -- number of shuffles\n    (p:q:r:_) <- map (read :: String -> Int) . words <$> getLine\n    shuffles <- myRead <$> replicateM m getLine\n    print $ solver [1..n] shuffles p q r\n    main"
  },
  {
    "language": "Haskell",
    "code": "import Control.Applicative\nimport Control.Monad\nimport Data.List (foldl')\n\nmain :: IO ()\nmain = do\n  n <- readLn\n  unless (n == 0) $ do\n    m <- readLn\n    solve n <$> f <*> replicateM m f >>= print\n    main\n  where\n    f = map read <$> words <$> getLine\n\nsolve :: Int -> [Int] -> [[Int]] -> Int\nsolve n [p, q, r] =  g . foldl' f il\n  where\n    il = if n == r then [(r, True)] else [(r, True),(n-r, False)]\n    f ls [x, y] = let (as, bs) = split x ls\n                      (cs, ds) = split (y-x) bs\n                  in ds ++ cs ++ as\n    g ls = let (_, as) = split (p-1) ls\n               (bs, _) = split (q - p + 1) as\n           in sum . map fst . filter snd $ bs\n    \nsplit :: Int -> [(Int,Bool)] -> ([(Int,Bool)], [(Int,Bool)])\nsplit _ [] = ([], [])\nsplit n ((x,b):xs)\n  | n == 0 = ([], (x,b):xs)\n  | n < x = ([(n, b)], (x-n, b):xs)\n  | otherwise = let (as, bs) = split (n - x) xs\n                in ((x,b):as, bs)\n\n"
  },
  {
    "language": "Haskell",
    "code": "import Control.Applicative\nimport Data.List (\\\\)\nimport Control.Monad\n\ntype Shuffle = (Int, Int)\n\nmyRead' :: String -> Shuffle\nmyRead' xs = (a, b)\n  where (a:b:_) = map (read :: String -> Int) $ words xs\n\nmyRead :: [String] -> [Shuffle]\nmyRead = map myRead'\n\noperation :: [Int] -> Shuffle -> [Int]\noperation cards (x, y) =\n  let a = take x cards\n      c = drop y cards\n      b = (cards \\\\ a) \\\\ c\n  in\n      c ++ b ++ a\n\nsolver :: [Int] -> [Shuffle] -> Int -> Int -> Int -> Int\nsolver cards op p q r =\n  let result  = foldl operation cards op\n      ansList = drop (p - 1) $ take q result\n  in\n      length $ filter (<= r) ansList\n\nmain :: IO()\nmain = do\n  n <- (read :: String -> Int) <$> getLine -- number of cards\n  unless (n == 0) $ do\n    m <- (read :: String -> Int) <$> getLine -- number of shuffles\n    (p:q:r:_) <- map (read :: String -> Int) . words <$> getLine\n    shuffles <- myRead <$> replicateM m getLine\n    print $ solver [1..n] shuffles p q r\n    main"
  },
  {
    "language": "Haskell",
    "code": "import Control.Applicative\nimport Data.List\nimport Control.Monad\n\ntype Shuffle = (Int, Int)\n\nmyRead' :: String -> Shuffle\nmyRead' xs = (a, b)\n  where (a:b:_) = map (read :: String -> Int) $ words xs\n\nmyRead :: [String] -> [Shuffle]\nmyRead = map myRead'\n\noperation :: [Int] -> Shuffle -> [Int]\noperation cards (x, y) =\n  let a = take x cards\n      c = drop y cards\n      b = (cards \\\\ a) \\\\ c\n  in\n      c ++ b ++ a\n\nsolver :: [Int] -> [Shuffle] -> Int -> Int -> Int -> Int\nsolver cards op p q r =\n  let result  = foldl operation cards op\n      ansList = drop (p - 1) $ take q result\n  in\n      length $ filter (<= r) ansList\n\nmain :: IO()\nmain = do\n  n <- (read :: String -> Int) <$> getLine -- number of cards\n  unless (n == 0) $ do\n    m <- (read :: String -> Int) <$> getLine -- number of shuffles\n    (p:q:r:_) <- map (read :: String -> Int) . words <$> getLine\n    shuffles <- myRead <$> replicateM m getLine\n    print $ solver [1..n] shuffles p q r\n    main"
  },
  {
    "language": "C",
    "code": "// Aizu 0536: Shuffle\n// 2017.10.25 bal4u@uu\n\n#include <stdio.h>\n#include <stdlib.h>\n#include <string.h>\n\ntypedef struct { int x1, x2; } TABA;\nTABA taba[2][15002]; int sz;\nint k1, k2;\n\nint split(int x)\n{\n\tint s, i, k;\n\n\tfor (s = 0, i = 0; ; i++) {\n\t\tk = taba[k1][i].x2 - taba[k1][i].x1 + 1;\n\t\tif (s + k == x) return i;\n\t\tif (s + k > x) break;\n\t\ts += k;\n\t}\n\tmemcpy(taba[k1]+i+1, taba[k1]+i, sizeof(TABA)*(sz-i)), sz++;\n\tx = (x-s)+taba[k1][i].x1-1;\n\ttaba[k1][i].x2 = x, taba[k1][i+1].x1 = x+1;\n\treturn i;\n}\n\nvoid shuffle(int x, int y)\n{\n\tint i, j, s;\n\ti = split(x), j = split(y);\n\n\ts = 0;\n\tmemcpy(taba[k2],   taba[k1]+j+1, sizeof(TABA)*(sz-j-1)); s += sz - j - 1;\n\tmemcpy(taba[k2]+s, taba[k1]+i+1, sizeof(TABA)*(j-i));    s += j-i;\n\tmemcpy(taba[k2]+s, taba[k1],     sizeof(TABA)*(i+1));\n\tk1 = k2, k2 = !k2;\n}\n\nint main()\n{\n\tint n, m, p, q, r, x, y;\n\tint i, ans;\n\n\twhile (scanf(\"%d\", &n) && n > 0) {\n\t\tscanf(\"%d%d%d%d\", &m, &p, &q, &r);\n\t\ttaba[0][0].x1 = 1, taba[0][0].x2 = n, k1 = 0, k2 = 1, sz = 1;\n\t\twhile (m-- > 0) {\n\t\t\tscanf(\"%d%d\", &x, &y);\n\t\t\tshuffle(x, y);\n\t\t}\n\t\tif (p > 1) x = split(p-1) + 1;\n\t\ty = split(q);\n\t\tfor (ans = 0, i = x; i <= y; i++) {\n\t\t\tif (taba[k1][i].x1 > r) continue;\n\t\t\tif (taba[k1][i].x2 <= r) ans += taba[k1][i].x2 - taba[k1][i].x1 + 1;\n\t\t\telse \t\t\t         ans += r - taba[k1][i].x1 + 1;\n\t\t}\n\t\tprintf(\"%d\\n\", ans);\n\t}\n\treturn 0;\n}"
  },
  {
    "language": "C",
    "code": "// Aizu 0536: Shuffle\n// 2017.10.25 bal4u@uu\n\n#include <stdio.h>\n#include <stdlib.h>\n#include <string.h>\n\ntypedef struct { int x1, x2; } TABA;\nTABA taba[2][100000005]; int sz;\nint k1, k2;\n\nint split(int x)\n{\n\tint s, i, k;\n\n\tfor (s = 0, i = 0; ; i++) {\n\t\tk = taba[k1][i].x2 - taba[k1][i].x1 + 1;\n\t\tif (s + k == x) return i;\n\t\tif (s + k > x) break;\n\t\ts += k;\n\t}\n\tmemcpy(taba[k1]+i+1, taba[k1]+i, sizeof(TABA)*(sz-i)), sz++;\n\tx = (x-s)+taba[k1][i].x1-1;\n\ttaba[k1][i].x2 = x, taba[k1][i+1].x1 = x+1;\n\treturn i;\n}\n\nvoid shuffle(int x, int y)\n{\n\tint i, j, s;\n\ti = split(x), j = split(y);\n\n\ts = 0;\n\tmemcpy(taba[k2],   taba[k1]+j+1, sizeof(TABA)*(sz-j-1)); s += sz - j - 1;\n\tmemcpy(taba[k2]+s, taba[k1]+i+1, sizeof(TABA)*(j-i));    s += j-i;\n\tmemcpy(taba[k2]+s, taba[k1],     sizeof(TABA)*(i+1));\n\tk1 = k2, k2 = !k2;\n}\n\nint main()\n{\n\tint n, m, p, q, r, x, y;\n\tint i, ans;\n\n\twhile (scanf(\"%d\", &n) && n > 0) {\n\t\tscanf(\"%d%d%d%d\", &m, &p, &q, &r);\n\t\ttaba[0][0].x1 = 1, taba[0][0].x2 = n, k1 = 0, k2 = 1, sz = 1;\n\t\twhile (m-- > 0) {\n\t\t\tscanf(\"%d%d\", &x, &y);\n\t\t\tshuffle(x, y);\n\t\t}\n\t\tif (p > 1) x = split(p-1) + 1;\n\t\ty = split(q);\n\t\tfor (ans = 0, i = x; i <= y; i++) {\n\t\t\tif (taba[k1][i].x1 > r) continue;\n\t\t\tif (taba[k1][i].x2 <= r) ans += taba[k1][i].x2 - taba[k1][i].x1 + 1;\n\t\t\telse \t\t\t         ans += r - taba[k1][i].x1 + 1;\n\t\t}\n\t\tprintf(\"%d\\n\", ans);\n\t}\n\treturn 0;\n}"
  },
  {
    "language": "C",
    "code": "#include <stdio.h>\n#include <string.h>\n \ntypedef struct { int x1, x2; } TABA;\nTABA taba[2][10005]; int sz;\nint k1, k2;\n \nint split(int x)\n{\n    int s, i, k;\n \n    for (s = 0, i = 0; ; i++) {\n        k = taba[k1][i].x2 - taba[k1][i].x1 + 1;\n        if (s + k == x) return i;\n        if (s + k > x) break;\n        s += k;\n    }\n    memmove(taba[k1]+i+1, taba[k1]+i, sizeof(TABA)*(sz-i)), sz++;\n    x = (x-s)+taba[k1][i].x1-1;\n    taba[k1][i].x2 = x, taba[k1][i+1].x1 = x+1;\n    return i;\n}\n \nvoid shuffle(int x, int y)\n{\n    int i, j, s;\n \n    i = split(x), j = split(y);\n    s = 0;\n    memcpy(taba[k2],   taba[k1]+j+1, sizeof(TABA)*(sz-j-1)); s += sz - j - 1;\n    memcpy(taba[k2]+s, taba[k1]+i+1, sizeof(TABA)*(j-i));    s += j-i;\n    memcpy(taba[k2]+s, taba[k1],     sizeof(TABA)*(i+1));\n    k1 = k2, k2 = !k2;\n}\n \nint main()\n{\n    int n, m, p, q, r, x, y;\n    int i, ans;\n \n    while (scanf(\"%d\", &n) && n > 0) {\n        scanf(\"%d%d%d%d\", &m, &p, &q, &r);\n        taba[0][0].x1 = 1, taba[0][0].x2 = n, k1 = 0, k2 = 1, sz = 1;\n        while (m-- > 0) {\n            scanf(\"%d%d\", &x, &y);\n            shuffle(x, y);\n        }\n        x = 0; if (p > 1) x = split(p-1) + 1;\n        y = split(q);\n        for (ans = 0, i = x; i <= y; i++) {\n            if (taba[k1][i].x1 > r) continue;\n            if (taba[k1][i].x2 <= r) ans += taba[k1][i].x2 - taba[k1][i].x1 + 1;\n            else                     ans += r - taba[k1][i].x1 + 1;\n        }\n        printf(\"%d\\n\", ans);\n    }\n    return 0;\n}\n"
  },
  {
    "language": "C",
    "code": "#include <stdio.h>\n#include <stdlib.h>\n//Impossibly large number\n#define ILN 1000000002\n\n\ntypedef struct tag_node{\n\tint num;\n\tstruct tag_node *next_series;\n\tstruct tag_node *next_one;\n}NODE;\n\nNODE *createNode(int i);\nNODE *retNode(NODE *START,int i);\nvoid shuffle(int x,int y,NODE *HEAD,NODE *TAIL,int n);\nint countCard(NODE *P,int p,int q,int r);\nvoid dbgPrint(NODE *P);\nvoid freeNode(NODE *P);\n\nint main(){\n\tint n,m;\n\tint p,q,r;\n\tint x,y;\n\tNODE *HEAD,*TAIL,*Pnode;\n\tint i;\n\tint ans;\n\n\twhile(1){\n\t\tscanf(\"%d\\n\",&n);\n\t\tif(!n)break;\n\t\tscanf(\"%d\\n\",&m);\n\t\tscanf(\"%d %d %d\\n\",&p,&q,&r);\n\n\t\tHEAD=createNode(0);\n\t\tTAIL=createNode(ILN);\n\n\t\tPnode=createNode(1);\n\t\tHEAD->next_one=Pnode;\n\t\tPnode=createNode(n);\n\t\tHEAD->next_one->next_series=Pnode;\n\t\tPnode->next_one=TAIL;\n\t\t\n//dbgPrint(HEAD);\t\n\t\tfor(i=0;i<m;i++){\n\t\t\tscanf(\"%d %d\\n\",&x,&y);\n\t\t\tshuffle(x,y,HEAD,TAIL,n);\n//dbgPrint(HEAD);\t\n\t\t}\n\t\t\n\t\tans=countCard(HEAD,p,q,r);\n\n\t\tprintf(\"%d\\n\",ans);\n\t\tfreeNode(HEAD);\n\n\t}\n\treturn 0;\n}\n\n\nNODE *createNode(int i){\n\tNODE *P;\n\tP=(NODE *)malloc(sizeof(NODE));\n\tif(!P){printf(\"malloc error\");exit(1);}\n\tP->num=i;\n\tP->next_series=NULL;\n\tP->next_one=NULL;\n\t\n\treturn P;\n}\n\nvoid dbgPrint(NODE *P){\n\tprintf(P->num==ILN?\"E\":\"%d\",P->num);\n\tif(P->next_series!=NULL){printf(\"=>\");dbgPrint(P->next_series);}\n\tif(P->next_one!=NULL){printf(\"->\");dbgPrint(P->next_one);}\n\tif(P->next_series==NULL && P->next_one==NULL )printf(\"-*\\n\");\n\treturn;\n}\n\nvoid freeNode(NODE *P){\n\tif(P->next_series!=NULL)freeNode(P->next_series);\n\tif(P->next_one!=NULL )free(P->next_one);\n\tif(P->next_series==NULL && P->next_one==NULL )free(P);\n}\n\nNODE *retNode(NODE *START,int i){\n\t// return i-th pointer from START;\n\t//  if not exists :add Node & connect next_one(->)\n\t//    (a) 0->1=>9->ILN\t5th?\n\t//        0->1=>5->6=>9->ILN-*\treturn ( 5-> )\n\t//    (b) 0->1=>9->ILN\t8th?\n\t//        0->1=>8->9->ILN-*\treturn ( 8-> )\n\n\tNODE *P;\n\tint d;\n\tif(i==0){\n\t\tif(START->next_series==NULL)return START;\n\t\tP=createNode(START->num+1);\n\t\tP->next_series=START->next_series;\n\t\tSTART->next_series=NULL;\n\t\tSTART->next_one=P;\n\t\treturn START;\n\t}\n\tif(START->num==ILN)return START;\n\tif(START->next_one!=NULL){\n\t\treturn retNode(START->next_one,i-1);\n\t}\n\tif(START->next_series!=NULL){\n\t\td=START->next_series->num - START->num;\n\t\tif(i>=d){\n\t\t\treturn retNode(START->next_series,i-d);\n\t\t}\n\t\tif(i<d){\n\t\t\tif(i==d-1){ //case(b)\n\t\t\t\tP=createNode(START->num+i);\n\t\t\t\tP->next_one=START->next_series;\n\t\t\t\tSTART->next_series=P;\n\t\t\t\treturn retNode(P,0);\n\t\t\t}\n\t\t\tif(i<d-1){ //case(a)\n\t\t\t\tP=createNode(START->num+i+1);\n\t\t\t\tP->next_series=START->next_series;\n\t\t\t\tSTART->next_series=P;\n\t\t\t\tP=createNode(START->num+i);\n\t\t\t\tP->next_one=START->next_series;\n\t\t\t\tSTART->next_series=P;\n\t\t\t\treturn retNode(P,0);\n\t\t\t}\n\t\t}\n\t}\n\treturn START;\n}\n\nvoid shuffle(int x,int y,NODE *HEAD,NODE *TAIL,int n){\n\n\tNODE *Px,*Py,*Pend;\n\tNODE *Ptmp;\n\t\n\tPx=retNode(HEAD,x);\n\tPy=retNode(HEAD,y);\n\tPend=retNode(HEAD,n);\n\t\n\tPtmp=HEAD->next_one;//bak\n\tHEAD->next_one=Py->next_one;\n\tPend->next_one=Px->next_one;\n\tPy->next_one=Ptmp;\n\tPx->next_one=TAIL;\n\treturn;\n}\n\n\nint countCard(NODE *P,int p,int q,int r){\n//printf(\"p=%d,q=%d,r=%d\\t\",p,q,r);dbgPrint(P);\t\n\n\tstatic int cnt;\n\tNODE *Pp,*Pq;\n\tint d,p0,q0;\n\tif(P->num==0){\n\t\tcnt=0;\n\t\tPp=retNode(P,p);\n\t\tPq=retNode(P,q);\n\t\tcountCard(Pp,0,q-p,r);\n\t}\n\t\n\tif(p==0){\n\t\tif(q==0){\n\t\t\tif(P->num<=r)cnt++;\n\t\t\treturn cnt;\n\t\t}\n\t\tif(P->next_one!=NULL){\n\t\t\tif(P->num<=r)cnt++;\n\t\t\tcountCard(P->next_one,0,q-1,r);\n\t\t}\n\t\tif(P->next_series!=NULL){\n\t\t\tp0=P->num;\n\t\t\tq0=P->next_series->num;\n\t\t\td=q0-p0;\n\t\t\tif(r<p0){cnt=cnt;}\n\t\t\tif(q0<=r){cnt+=d;}\n\t\t\tif(p0<=r && r<q0){cnt+=r-p0+1;}\n\t\t\tcountCard(P->next_series,0,q-d,r);\n\t\t}\n\t}\n\treturn cnt;\n}"
  },
  {
    "language": "C",
    "code": "#include <stdio.h>\n#include <stdlib.h>\n#include <string.h>\nint main()\n{\n  int n,m,p,q,r,i,x,y;\n  int *a,*s,*t,*u;\n  for(;;){\n    scanf(\"%d\",&n);\n    if(n == 0) break;\n    a = (int *)(malloc(sizeof(int)*n));\n    s = (int *)(malloc(sizeof(int)*n));\n    t = (int *)(malloc(sizeof(int)*n));\n    u = (int *)(malloc(sizeof(int)*n));\n    for(i=0;i<n;i++){\n      a[i] = i+1;\n    }\n    scanf(\"%d\",&m);\n    scanf(\"%d%d%d\",&p,&q,&r);\n    for(i=0;i<m;i++){\n      scanf(\"%d%d\",&x,&y);\n      memcpy(s,a,sizeof(int)*x);\n      memcpy(t,a+x,sizeof(int)*(y-x));\n      memcpy(u,a+y,sizeof(int)*(n-y));\n      memcpy(a,u,sizeof(int)*(n-y));\n      memcpy(a+(n-y),t,sizeof(int)*(y-x));\n      memcpy(a+(n-x),s,sizeof(int)*x);\n    }\n    x = 0;\n    for(i=p-1;i<q;i++){\n      if(a[i] <= r) x++;\n    }\n    printf(\"%d\\n\",x);\n    free(a);\n    free(s);\n    free(t);\n    free(u);\n  }\n  return 0;\n}"
  },
  {
    "language": "C",
    "code": "#include <stdio.h>\n\ntypedef struct {\n\tint start,end;\n\tint next;\n} card_t;\n\nint card_num;\ncard_t cards[10010];\n\nint main(void) {\n\tint n,m;\n\tint p,q,r;\n\tint x,y;\n\tint i,j,rest,status;\n\tint cut1,cut2,cut3,temp;\n\tint start,end,count;\n\tscanf(\"%d\",&n);\n\tscanf(\"%d\",&m);\n\tscanf(\"%d%d%d\",&p,&q,&r);\n\tcards[0].start=0;\n\tcards[0].end=-1;\n\tcards[0].next=1;\n\tcards[1].start=1;\n\tcards[1].end=n;\n\tcards[1].next=0;\n\tcard_num=2;\n\tfor(i=0;i<m;i++) {\n\t\tscanf(\"%d%d\",&x,&y);\n\t\tfor(j=cards[0].next,rest=x;j>0;j=cards[j].next) {\n\t\t\trest-=cards[j].end-cards[j].start+1;\n\t\t\tif(rest==0) {\n\t\t\t\tcut1=j;\n\t\t\t\tbreak;\n\t\t\t} else if(rest<0) {\n\t\t\t\tcards[card_num].start=cards[j].end+rest+1;\n\t\t\t\tcards[card_num].end=cards[j].end;\n\t\t\t\tcards[card_num].next=cards[j].next;\n\t\t\t\tcards[j].end=cards[j].end+rest;\n\t\t\t\tcards[j].next=card_num;\n\t\t\t\tcard_num++;\n\t\t\t\tcut1=j;\n\t\t\t\tbreak;\n\t\t\t}\n\t\t}\n\t\tif(j<=0)return 1;/* bug */\n\t\tfor(j=cards[j].next,rest=y-x;j>0;j=cards[j].next) {\n\t\t\trest-=cards[j].end-cards[j].start+1;\n\t\t\tif(rest==0) {\n\t\t\t\tcut2=j;\n\t\t\t\tbreak;\n\t\t\t} else if(rest<0) {\n\t\t\t\tcards[card_num].start=cards[j].end+rest+1;\n\t\t\t\tcards[card_num].end=cards[j].end;\n\t\t\t\tcards[card_num].next=cards[j].next;\n\t\t\t\tcards[j].end=cards[j].end+rest;\n\t\t\t\tcards[j].next=card_num;\n\t\t\t\tcard_num++;\n\t\t\t\tcut2=j;\n\t\t\t\tbreak;\n\t\t\t}\n\t\t}\n\t\tif(j<=0)return 1;/* bug */\n\t\tfor(j=cards[j].next;j>0;j=cards[j].next) {\n\t\t\tif(cards[j].next==0)cut3=j;\n\t\t}\n\t\ttemp=cards[0].next;\n\t\tcards[0].next=cards[cut2].next;\n\t\tcards[cut3].next=cards[cut1].next;\n\t\tcards[cut2].next=temp;\n\t\tcards[cut1].next=0;\n\t}\n\tstatus=0;rest=p;count=0;\n\tfor(j=cards[0].next;j>0;j=cards[j].next) {\n\t\trest-=cards[j].end-cards[j].start+1;\n\t\tif(status==0) {\n\t\t\tif(rest==0) {\n\t\t\t\tstatus=1;\n\t\t\t\tif(cards[j].end<=r)count++;\n\t\t\t\trest=q-p;\n\t\t\t} else if(rest<0) {\n\t\t\t\tstatus=1;\n\t\t\t\tstart=cards[j].end+rest;\n\t\t\t\tend=cards[j].end;\n\t\t\t\tif(end>r)end=r;\n\t\t\t\tif(start<=end)count+=end-start+1;\n\t\t\t\trest+=q-p;\n\t\t\t}\n\t\t} else if(status==1) {\n\t\t\tif(rest<=0) {\n\t\t\t\tstatus=2;\n\t\t\t\tstart=cards[j].start;\n\t\t\t\tend=cards[j].end+rest;\n\t\t\t\tif(end>r)end=r;\n\t\t\t\tif(start<=end)count+=end-start+1;\n\t\t\t} else {\n\t\t\t\tstart=cards[j].start;\n\t\t\t\tend=cards[j].end;\n\t\t\t\tif(end>r)end=r;\n\t\t\t\tif(start<=end)count+=end-start+1;\n\t\t\t}\n\t\t}\n\t}\n\tprintf(\"%d\\n\",count);\n\treturn 0;\n}"
  },
  {
    "language": "C",
    "code": "v[2]['~e'],l,n,m,a,c,*i,*s;D(x){c=0;for(i=v+a;c<x;i+=2)c+=i[1];memmove(i+2,i,(v[a]+l-i)*4);l+=2;*i=i[-2]+(i[-1]-=i[1]=c-x);return i;}C(d,s,e){c=memcpy(d,s,e-s)+e-s;}main(p,q,r,x,y){for(;scanf(\"%d%d%d%d%d\",&n,&m,&p,&q,&r)*n;printf(\"%d\\n\",c)){v[a=**v=0][1]=n;for(l=2;m--;a^=1)scanf(\"%d%d\",&x,&y),C(C(C(v[a^1],y,v[a]+l),x,y=D(y)),v[a],x=D(x));s=D(p-1);i=D(q);for(c=0;s-i;s+=2)c+=*s+s[1]>r?*s<r?r-*s:0:s[1];}}"
  },
  {
    "language": "C",
    "code": "#include <stdio.h>\n\ntypedef struct {\n\tint start,end;\n\tint next;\n} card_t;\n\nint card_num;\ncard_t cards[10010];\n\nint main(void) {\n\tint n,m;\n\tint p,q,r;\n\tint x,y;\n\tint i,j,rest,status;\n\tint cut1,cut2,cut3,temp;\n\tint start,end,count;\n\twhile(1) {\n\t\tscanf(\"%d\",&n);\n\t\tif(n==0)break;\n\t\tscanf(\"%d\",&m);\n\t\tscanf(\"%d%d%d\",&p,&q,&r);\n\t\tcards[0].start=0;\n\t\tcards[0].end=-1;\n\t\tcards[0].next=1;\n\t\tcards[1].start=1;\n\t\tcards[1].end=n;\n\t\tcards[1].next=0;\n\t\tcard_num=2;\n\t\tfor(i=0;i<m;i++) {\n\t\t\tscanf(\"%d%d\",&x,&y);\n\t\t\tfor(j=cards[0].next,rest=x;j>0;j=cards[j].next) {\n\t\t\t\trest-=cards[j].end-cards[j].start+1;\n\t\t\t\tif(rest==0) {\n\t\t\t\t\tcut1=j;\n\t\t\t\t\tbreak;\n\t\t\t\t} else if(rest<0) {\n\t\t\t\t\tcards[card_num].start=cards[j].end+rest+1;\n\t\t\t\t\tcards[card_num].end=cards[j].end;\n\t\t\t\t\tcards[card_num].next=cards[j].next;\n\t\t\t\t\tcards[j].end=cards[j].end+rest;\n\t\t\t\t\tcards[j].next=card_num;\n\t\t\t\t\tcard_num++;\n\t\t\t\t\tcut1=j;\n\t\t\t\t\tbreak;\n\t\t\t\t}\n\t\t\t}\n\t\t\tif(j<=0)return 1;/* bug */\n\t\t\tfor(j=cards[j].next,rest=y-x;j>0;j=cards[j].next) {\n\t\t\t\trest-=cards[j].end-cards[j].start+1;\n\t\t\t\tif(rest==0) {\n\t\t\t\t\tcut2=j;\n\t\t\t\t\tbreak;\n\t\t\t\t} else if(rest<0) {\n\t\t\t\t\tcards[card_num].start=cards[j].end+rest+1;\n\t\t\t\t\tcards[card_num].end=cards[j].end;\n\t\t\t\t\tcards[card_num].next=cards[j].next;\n\t\t\t\t\tcards[j].end=cards[j].end+rest;\n\t\t\t\t\tcards[j].next=card_num;\n\t\t\t\t\tcard_num++;\n\t\t\t\t\tcut2=j;\n\t\t\t\t\tbreak;\n\t\t\t\t}\n\t\t\t}\n\t\t\tif(j<=0)return 1;/* bug */\n\t\t\tfor(j=cards[j].next;j>0;j=cards[j].next) {\n\t\t\t\tif(cards[j].next==0)cut3=j;\n\t\t\t}\n\t\t\ttemp=cards[0].next;\n\t\t\tcards[0].next=cards[cut2].next;\n\t\t\tcards[cut3].next=cards[cut1].next;\n\t\t\tcards[cut2].next=temp;\n\t\t\tcards[cut1].next=0;\n\t\t}\n\t\tstatus=0;rest=p;count=0;\n\t\tfor(j=cards[0].next;j>0;j=cards[j].next) {\n\t\t\trest-=cards[j].end-cards[j].start+1;\n\t\t\tif(status==0) {\n\t\t\t\tif(rest==0) {\n\t\t\t\t\tstatus=1;\n\t\t\t\t\tif(cards[j].end<=r)count++;\n\t\t\t\t\trest=q-p;\n\t\t\t\t} else if(rest<0) {\n\t\t\t\t\tstatus=1;\n\t\t\t\t\tstart=cards[j].end+rest;\n\t\t\t\t\tend=cards[j].end;\n\t\t\t\t\tif(end>r)end=r;\n\t\t\t\t\tif(start<=end)count+=end-start+1;\n\t\t\t\t\trest+=q-p;\n\t\t\t\t}\n\t\t\t} else if(status==1) {\n\t\t\t\tif(rest<=0) {\n\t\t\t\t\tstatus=2;\n\t\t\t\t\tstart=cards[j].start;\n\t\t\t\t\tend=cards[j].end+rest;\n\t\t\t\t\tif(end>r)end=r;\n\t\t\t\t\tif(start<=end)count+=end-start+1;\n\t\t\t\t} else {\n\t\t\t\t\tstart=cards[j].start;\n\t\t\t\t\tend=cards[j].end;\n\t\t\t\t\tif(end>r)end=r;\n\t\t\t\t\tif(start<=end)count+=end-start+1;\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t\tprintf(\"%d\\n\",count);\n\t}\n\treturn 0;\n}"
  },
  {
    "language": "C",
    "code": "// Aizu 0536: Shuffle\n// 2017.10.26 bal4u@uu\n\n#include <stdio.h>\n#include <string.h>\n\ntypedef struct { int x1, x2; } TABA;\nTABA taba[2][10005]; int sz;\nint k1, k2;\n\nint split(int x)\n{\n\tint s, i, k;\n\n\tfor (s = 0, i = 0; ; i++) {\n\t\tk = taba[k1][i].x2 - taba[k1][i].x1 + 1;\n\t\tif (s + k == x) return i;\n\t\tif (s + k > x) break;\n\t\ts += k;\n\t}\n\tmemmove(taba[k1]+i+1, taba[k1]+i, sizeof(TABA)*(sz-i)), sz++;\n\tx = (x-s)+taba[k1][i].x1-1;\n\ttaba[k1][i].x2 = x, taba[k1][i+1].x1 = x+1;\n\treturn i;\n}\n\nvoid shuffle(int x, int y)\n{\n\tint i, j, s;\n\n\ti = split(x), j = split(y);\n\ts = 0;\n\tmemcpy(taba[k2],   taba[k1]+j+1, sizeof(TABA)*(sz-j-1)); s += sz - j - 1;\n\tmemcpy(taba[k2]+s, taba[k1]+i+1, sizeof(TABA)*(j-i));    s += j-i;\n\tmemcpy(taba[k2]+s, taba[k1],     sizeof(TABA)*(i+1));\n\tk1 = k2, k2 = !k2;\n}\n\nint main()\n{\n\tint n, m, p, q, r, x, y;\n\tint i, ans;\n\n\twhile (scanf(\"%d\", &n) && n > 0) {\n\t\tscanf(\"%d%d%d%d\", &m, &p, &q, &r);\n\t\ttaba[0][0].x1 = 1, taba[0][0].x2 = n, k1 = 0, k2 = 1, sz = 1;\n\t\twhile (m-- > 0) {\n\t\t\tscanf(\"%d%d\", &x, &y);\n\t\t\tshuffle(x, y);\n\t\t}\n\t\tx = 0; if (p > 1) x = split(p-1) + 1;\n\t\ty = split(q);\n\t\tfor (ans = 0, i = x; i <= y; i++) {\n\t\t\tif (taba[k1][i].x1 > r) continue;\n\t\t\tif (taba[k1][i].x2 <= r) ans += taba[k1][i].x2 - taba[k1][i].x1 + 1;\n\t\t\telse \t\t\t         ans += r - taba[k1][i].x1 + 1;\n\t\t}\n\t\tprintf(\"%d\\n\", ans);\n\t}\n\treturn 0;\n}"
  },
  {
    "language": "C",
    "code": "v[2]['#N'],l,n,m,a,c,*i,*s;D(x){c=0;for(i=v+a;c<x;i+=2)c+=i[1];memmove(i+2,i,(v[a]+l-i)*4);l+=2;*i=i[-2]+(i[-1]-=i[1]=c-x);return i;}C(d,s,e){c=memcpy(d,s,e-s)+e-s;}main(p,q,r,x,y){for(;scanf(\"%d%d%d%d%d\",&n,&m,&p,&q,&r)*n;printf(\"%d\\n\",c)){v[a=**v=0][1]=n;for(l=2;m--;a^=1)scanf(\"%d%d\",&x,&y),C(C(C(v[a^1],y,v[a]+l),x,y=D(y)),v[a],x=D(x));s=D(p-1);i=D(q);for(c=0;s-i;s+=2)c+=*s+s[1]>r?*s<r?r-*s:0:s[1];}}"
  },
  {
    "language": "C",
    "code": "#include<stdio.h>\n#include<string.h>\n#define N 100000000\nint s[N],t[N],i,j,m,n,p,q,r,x,y,c;\n\nvoid sh(int x,int y)\n{\n\tint p=0;\n\tmemcpy(t,s+y,(n-y)*4);\n\tp+=n-y;\n\tmemcpy(t+p,s+x,(y-x)*4);\n\tp+=y-x;\n\tmemcpy(t+p,s,x*4);\n\tmemcpy(s,t,n*4);\n}\n\nint main()\n{\n\tfor(;scanf(\"%d%d%d%d%d\",&n,&m,&p,&q,&r),n;)\n\t{\n\t\tfor(i=0;i<n;i++)\n\t\t\ts[i]=i+1;\n\t\tfor(;m--;)\n\t\t{\n\t\t\tscanf(\"%d%d\",&x,&y);\n\t\t\tsh(x,y);\n\t\t}\n\t\tfor(i=p-1,c=0;i<q;i++)\n\t\t\tif(s[i]<=r)c++;\n\t\tprintf(\"%d\\n\",c);\n\t}\n\treturn 0;\n}"
  },
  {
    "language": "C",
    "code": "#include <stdio.h>\n\nint main(){\n  int i, j, k, n, m, p, q, r;\n\n  while(1){\n    scanf(\"%d\",&n);\n    if(n == 0) break;\n    scanf(\"%d\",&m);\n    scanf(\"%d%d%d\",&p,&q,&r);\n    int d[n], a[n], b[n], c[n], x[m][2], count = 0;\n    for(i = 0 ; i < n ; i++){\n      d[i] = i + 1;\n    }\n    for(i = 0 ; i < m ; i++){\n      for(j = 0 ; j < 2 ; j++){\n\tscanf(\"%d\",&x[i][j]);\n      }\n    }\n    for(j = 0 ; j < m ; j++){\n      for(i = 0 ; i < x[j][0] ; i++){\n\ta[i] = d[i];\n      }\n      for(i = 0 ; i < x[j][1]-x[j][0] ; i++){\n\tb[i] = d[x[k][0]];\n      }\n      for(i = 0 ; i < n-x[j][1] ; i++){\n\tc[i] = d[x[j][1]-x[j][0]];\n      }\n      for(i = 0 ; i < n-x[j][1] ; i++){\n\td[i] = c[i];\n      }\n      for(i = 0 ; i < x[j][1]-x[j][0] ; i++){\n\td[n-x[j][1]] = b[i];\n      }\n      for(i = 0 ; i < x[j][0] ; i++){\n\td[x[j][1]-x[j][0]] = a[i];\n      }\n    }\n    for(i = 0 ; i < q-p+1 ; i++){\n      if(d[i+p] <= r)\n\tcount++;\n    }\n    printf(\"%d\\n\",count);\n  }\n\n  return 0;\n\n}"
  },
  {
    "language": "C",
    "code": "#include <stdio.h>\n\nint main(){\n  int i, j, n, m, p, q, r;\n\n  while(1){\n    scanf(\"%d\",&n);\n    if(n == 0) break;\n    scanf(\"%d\",&m);\n    scanf(\"%d%d%d\",&p,&q,&r);\n    int d[n], a[n], b[n], c[n], x[m][2], count = 0;\n    for(i = 0 ; i < n ; i++){\n      d[i] = i + 1;\n    }\n    for(i = 0 ; i < m ; i++){\n      for(j = 0 ; j < 2 ; j++){\n\tscanf(\"%d\",&x[i][j]);\n      }\n    }\n    for(j = 0 ; j < m ; j++){\n      for(i = 0 ; i < x[j][0] ; i++){\n\ta[i] = d[i];\n      }\n      for(i = 0 ; i < x[j][1]-x[j][0] ; i++){\n\tb[i] = d[x[k][0]];\n      }\n      for(i = 0 ; i < n-x[j][1] ; i++){\n\tc[i] = d[x[j][1]-x[j][0]];\n      }\n      for(i = 0 ; i < n-x[j][1] ; i++){\n\td[i] = c[i];\n      }\n      for(i = 0 ; i < x[j][1]-x[j][0] ; i++){\n\td[n-x[j][1]] = b[i];\n      }\n      for(i = 0 ; i < x[j][0] ; i++){\n\td[x[j][1]-x[j][0]] = a[i];\n      }\n    }\n    for(i = 0 ; i < q-p+1 ; i++){\n      if(d[i+p] <= r)\n\tcount++;\n    }\n    printf(\"%d\\n\",count);\n  }\n\n  return 0;\n\n}"
  },
  {
    "language": "C",
    "code": "#include <stdio.h>\n#include <stdlib.h>\n//Impossibly large number\n#define ILN 1000000002\n\n\ntypedef struct tag_node{\n\tint num;\n\tstruct tag_node *next_series;\n\tstruct tag_node *next_one;\n}NODE;\n\nNODE *createNode(int i);\nNODE *retNode(NODE *START,int i);\nvoid shuffle(int x,int y,NODE *HEAD,NODE *TAIL,int n);\nint countCard(NODE *P,int p,int q,int r);\nvoid dbgPrint(NODE *P);\nvoid freeNode(NODE *P);\n\nint main(){\n\tint n,m;\n\tint p,q,r;\n\tint x,y;\n\tNODE *HEAD,*TAIL,*Pnode;\n\tint i;\n\tint ans;\n\n\twhile(1){\n\t\tscanf(\"%d\\n\",&n);\n\t\tif(!n)break;\n\t\tscanf(\"%d\\n\",&m);\n\t\tscanf(\"%d %d %d\\n\",&p,&q,&r);\n\n\t\tHEAD=createNode(0);\n\t\tTAIL=createNode(ILN);\n\n\t\tPnode=createNode(1);\n\t\tHEAD->next_one=Pnode;\n\t\tPnode=createNode(n);\n\t\tHEAD->next_one->next_series=Pnode;\n\t\tPnode->next_one=TAIL;\n\t\t\n//dbgPrint(HEAD);\t\n\t\tfor(i=0;i<m;i++){\n\t\t\tscanf(\"%d %d\\n\",&x,&y);\n\t\t\tshuffle(x,y,HEAD,TAIL,n);\n//dbgPrint(HEAD);\t\n\t\t}\n//puts(\"shuffle\");\t\t\n\t\tans=countCard(HEAD,p,q,r);\n\n\t\tprintf(\"%d\\n\",ans);\n\t\t//freeNode(HEAD);\n\n\t}\n\treturn 0;\n}\n\n\nNODE *createNode(int i){\n\tNODE *P;\n\tP=(NODE *)malloc(sizeof(NODE));\n\tif(!P){printf(\"malloc error\");exit(1);}\n\tP->num=i;\n\tP->next_series=NULL;\n\tP->next_one=NULL;\n\t\n\treturn P;\n}\n\nvoid dbgPrint(NODE *P){\n\tprintf(P->num==ILN?\"E\":\"%d\",P->num);\n\tif(P->next_series!=NULL){printf(\"=>\");dbgPrint(P->next_series);}\n\tif(P->next_one!=NULL){printf(\"->\");dbgPrint(P->next_one);}\n\tif(P->next_series==NULL && P->next_one==NULL )printf(\"-*\\n\");\n\treturn;\n}\n\nvoid freeNode(NODE *P){\n\tif(P->next_series!=NULL)freeNode(P->next_series);\n\tif(P->next_one!=NULL )free(P->next_one);\n\tif(P->next_series==NULL && P->next_one==NULL )free(P);\n}\n\nNODE *retNode(NODE *START,int i){\n\t// return i-th pointer from START;\n\t//  if not exists :add Node & connect next_one(->)\n\t//    (a) 0->1=>9->ILN\t5th?\n\t//        0->1=>5->6=>9->ILN-*\treturn ( 5-> )\n\t//    (b) 0->1=>9->ILN\t8th?\n\t//        0->1=>8->9->ILN-*\treturn ( 8-> )\n\t//    (c) 0->1=>9->ILN\t1st?\n\t//        0->1->2=>9->ILN-*\treturn ( 1-> )\n\n\tNODE *P,*Q;\n\tint d;\n\n\tP=START;\n\twhile(1){\n\t\tif(i==0){//(c)\n\t\t\tif(P->next_series==NULL)return P;\n\t\t\tQ=createNode(P->num+1);\n\t\t\tQ->next_series=P->next_series;\n\t\t\tP->next_series=NULL;\n\t\t\tP->next_one=Q;\n\t\t\treturn P;\n\t\t}\n\t\tif(P->num==ILN)return P;\n\t\tif(P->next_one!=NULL){\n\t\t\ti--;\n\t\t\tP=P->next_one;\n\t\t}else if(P->next_series!=NULL){\n\t\t\td=P->next_series->num - P->num;\n\t\t\tif(i>=d){\n\t\t\t\ti=i-d;\n\t\t\t\tP=P->next_series;\n\t\t\t}else if(i==d-1){ //case(b)\n\t\t\t\tQ=createNode(P->num+i);\n\t\t\t\tQ->next_one=P->next_series;\n\t\t\t\tP->next_series=Q;\n\t\t\t\treturn Q;\n\t\t\t}else if(i<d-1){ //case(a)\n\t\t\t\tQ=createNode(P->num+i+1);\n\t\t\t\tQ->next_series=P->next_series;\n\t\t\t\tP->next_series=Q;\n\t\t\t\tQ=createNode(P->num+i);\n\t\t\t\tQ->next_one=P->next_series;\n\t\t\t\tP->next_series=Q;\n\t\t\t\t//return retNode(P,0);\n\t\t\t\treturn Q;\n\t\t\t}\n\t\t}\n\t}\n}\n\nvoid shuffle(int x,int y,NODE *HEAD,NODE *TAIL,int n){\n\n\tNODE *Px,*Py,*Pend;\n\tNODE *Ptmp;\n\t\n\tPx=retNode(HEAD,x);\n\tPy=retNode(HEAD,y);\n\tPend=retNode(HEAD,n);\n\t\n\tPtmp=HEAD->next_one;//bak\n\tHEAD->next_one=Py->next_one;\n\tPend->next_one=Px->next_one;\n\tPy->next_one=Ptmp;\n\tPx->next_one=TAIL;\n\treturn;\n}\n\n\nint countCard(NODE *START,int p,int q,int r){\n//printf(\"p=%d,q=%d,r=%d\\t\",p,q,r);dbgPrint(P);\t\n\n\tstatic int cnt;\n\tNODE *Pp,*Pq,*P;\n\tint d,p0,q0;\n\n\tPp=retNode(START,p);\n\tPq=retNode(START,q);\n\n\tP=Pp;\n\tcnt=0;\n\twhile(1){\n\t\tif(P->next_one!=NULL){\n\t\t\tif(P->num<=r)cnt++;\n\t\t\tif(P==Pq)return cnt;\n\t\t\tP=P->next_one;\n\t\t}else if(P->next_series!=NULL){\n\t\t\tp0=P->num;\n\t\t\tq0=P->next_series->num;\n\t\t\td=q0-p0;\n\t\t\tif(r<p0){cnt=cnt;\n\t\t\t}else if(q0<=r){cnt+=d;\n\t\t\t}else if(p0<=r && r<q0){cnt+=r-p0+1;\n\t\t\t}\n\t\t\tif(P==Pq)return cnt;\n\t\t\tP=P->next_series;\n\t\t}else{return cnt;\n\t\t}\n\t}\n}"
  },
  {
    "language": "C",
    "code": "#include <stdio.h>\n#include <string.h>\nunsigned int a[1000000000];\nunsigned int s[1000000000];\nunsigned int t[1000000000];\nunsigned int u[1000000000];\nint main()\n{\n  int n,m,p,q,r,i,x,y;\n  for(;;){\n    scanf(\"%d\",&n);\n    if(n == 0) break;\n    for(i=0;i<n;i++){\n      a[i] = i+1;\n    }\n    scanf(\"%d\",&m);\n    scanf(\"%d%d%d\",&p,&q,&r);\n    for(i=0;i<m;i++){\n      scanf(\"%d%d\",&x,&y);\n      memcpy(s,a,sizeof(int)*x);\n      memcpy(t,a+x,sizeof(int)*(y-x));\n      memcpy(u,a+y,sizeof(int)*(n-y));\n      memcpy(a,u,sizeof(int)*(n-y));\n      memcpy(a+(n-y),t,sizeof(int)*(y-x));\n      memcpy(a+(n-x),s,sizeof(int)*x);\n    }\n    x = 0;\n    for(i=p-1;i<q;i++){\n      if(a[i] <= r) x++;\n    }\n    printf(\"%d\\n\",x);\n  }\n  return 0;\n}"
  },
  {
    "language": "C",
    "code": "v[2]['~~'],l,n,m,a,c,*i,*s;D(x){c=0;for(i=v+a;c<x;i+=2)c+=i[1];memmove(i+2,i,(v[a]+l-i)*4);l+=2;*i=i[-2]+(i[-1]-=i[1]=c-x);return i;}C(d,s,e){c=memmove(d,s,e-s)+e-s;}main(p,q,r,x,y){for(;scanf(\"%d%d%d%d%d\",&n,&m,&p,&q,&r)*n;printf(\"%d\\n\",c)){v[a=**v=0][1]=n;for(l=2;m--;a^=1)scanf(\"%d%d\",&x,&y),C(C(C(v[a^1],y,v[a]+l),x,y=D(y)),v[a],x=D(x));s=D(p-1);i=D(q);for(c=0;s-i;s+=2)c+=*s+s[1]>r?*s<r?r-*s:0:s[1];}}"
  },
  {
    "language": "C",
    "code": "v[2]['~~'],l;\nn,m,a;\nD(x){\n\tint*p,c=0;\n\tfor(p=v[a];c<x;p+=2)\n\t\tc+=p[1]-p[0];\n\tmemmove(p+2,p,(v[a]+l-p)*4);\n\tl+=2;\n\tp[1]=p[-1];\n\tp[0]=p[-1]-=c-x;\n\treturn p;\n}\nC(d,s,e){\n\treturn memcpy(d,s,e-s)+e-s;\n}\nS(x,y){\n\tint i,j,e;\n\ti=D(x);\n\tj=D(y);\n\te=C(v[a^1],j,v[a]+l);\n\te=C(e,i,j);\n\tC(e,v[a],i);\n\ta^=1;\n}\nmain(p,q,r,x,y,c){\n\tint*i,*e;\n\tfor(;scanf(\"%d%d%d%d%d\",&n,&m,&p,&q,&r)*n;){\n\t\ta=0;\n\t\tv[a][0]=0;\n\t\tv[a][1]=n;\n\t\tl=2;\n\t\tfor(;m--;){\n\t\t\tscanf(\"%d%d\",&x,&y);\n\t\t\tS(x,y);\n\t\t}\n\t\ti=D(p-1);\n\t\te=D(q);\n\t\tfor(c=0;i-e;i+=2)\n\t\t\tc+=i[1]<=r?i[1]-i[0]:i[0]<r?r-i[0]:0;\n\t\tprintf(\"%d \\n\",c);\n\t}\n}"
  },
  {
    "language": "C",
    "code": "#include<stdio.h>\n#include<string.h>\n#define N 100\nint s[N],t[N],i,j,m,n,p,q,r,x,y,c;\n\nvoid sh(int x,int y)\n{\n\tint p=0;\n\tmemcpy(t,s+y,(n-y)*4);\n\tp+=n-y;\n\tmemcpy(t+p,s+x,(y-x)*4);\n\tp+=y-x;\n\tmemcpy(t+p,s,x*4);\n\tmemcpy(s,t,n*4);\n}\n\nint main()\n{\n\tfor(;scanf(\"%d%d%d%d%d\",&n,&m,&p,&q,&r),n;)\n\t{\n\t\tfor(i=0;i<n;i++)\n\t\t\ts[i]=i+1;\n\t\tfor(;m--;)\n\t\t{\n\t\t\tscanf(\"%d%d\",&x,&y);\n\t\t\tsh(x,y);\n\t\t}\n\t\tfor(i=p-1,c=0;i<q;i++)\n\t\t\tif(s[i]<=r)c++;\n\t\tprintf(\"%d\\n\",c);\n\t}\n\treturn 0;\n}"
  },
  {
    "language": "C",
    "code": "#include <stdio.h>\n#include <stdlib.h>\n//Impossibly large number\n#define ILN 1000000002\n\n\ntypedef struct tag_node{\n\tint num;\n\tstruct tag_node *next_series;\n\tstruct tag_node *next_one;\n}NODE;\n\nNODE *createNode(int i);\nNODE *retNode(NODE *START,int i);\nvoid shuffle(int x,int y,NODE *HEAD,NODE *TAIL,int n);\nint countCard(NODE *P,int p,int q,int r);\nvoid dbgPrint(NODE *P);\nvoid freeNode(NODE *P);\n\nint main(){\n\tint n,m;\n\tint p,q,r;\n\tint x,y;\n\tNODE *HEAD,*TAIL,*Pnode;\n\tint i;\n\tint ans;\n\n\twhile(1){\n\t\tscanf(\"%d\\n\",&n);\n\t\tif(!n)break;\n\t\tscanf(\"%d\\n\",&m);\n\t\tscanf(\"%d %d %d\\n\",&p,&q,&r);\n\n\t\tHEAD=createNode(0);\n\t\tTAIL=createNode(ILN);\n\n\t\tPnode=createNode(1);\n\t\tHEAD->next_one=Pnode;\n\t\tPnode=createNode(n);\n\t\tHEAD->next_one->next_series=Pnode;\n\t\tPnode->next_one=TAIL;\n\t\t\n//dbgPrint(HEAD);\t\n\t\tfor(i=0;i<m;i++){\n\t\t\tscanf(\"%d %d\\n\",&x,&y);\n\t\t\tshuffle(x,y,HEAD,TAIL,n);\n//dbgPrint(HEAD);\t\n\t\t}\n\t\t\n\t\tans=countCard(HEAD,p,q,r);\n\n\t\tprintf(\"%d\\n\",ans);\n\t\tfreeNode(HEAD);\n\n\t}\n\treturn 0;\n}\n\n\nNODE *createNode(int i){\n\tNODE *P;\n\tP=(NODE *)malloc(sizeof(NODE));\n\tif(!P){printf(\"malloc error\");exit(1);}\n\tP->num=i;\n\tP->next_series=NULL;\n\tP->next_one=NULL;\n\t\n\treturn P;\n}\n\nvoid dbgPrint(NODE *P){\n\tprintf(P->num==ILN?\"E\":\"%d\",P->num);\n\tif(P->next_series!=NULL){printf(\"=>\");dbgPrint(P->next_series);}\n\tif(P->next_one!=NULL){printf(\"->\");dbgPrint(P->next_one);}\n\tif(P->next_series==NULL && P->next_one==NULL )printf(\"-*\\n\");\n\treturn;\n}\n\nvoid freeNode(NODE *P){\n\tif(P->next_series!=NULL)freeNode(P->next_series);\n\tif(P->next_one!=NULL )free(P->next_one);\n\tif(P->next_series==NULL && P->next_one==NULL )free(P);\n}\n\nNODE *retNode(NODE *START,int i){\n\t// return i-th pointer from START;\n\t//  if not exists :add Node & connect next_one(->)\n\t//    (a) 0->1=>9->ILN\t5th?\n\t//        0->1=>5->6=>9->ILN-*\treturn ( 5-> )\n\t//    (b) 0->1=>9->ILN\t8th?\n\t//        0->1=>8->9->ILN-*\treturn ( 8-> )\n\n\tNODE *P;\n\tint d;\n\tif(i==0){\n\t\tif(START->next_series==NULL)return START;\n\t\tP=createNode(START->num+1);\n\t\tP->next_series=START->next_series;\n\t\tSTART->next_series=NULL;\n\t\tSTART->next_one=P;\n\t\treturn START;\n\t}\n\tif(START->num==ILN)return START;\n\tif(START->next_one!=NULL){\n\t\treturn retNode(START->next_one,i-1);\n\t}\n\tif(START->next_series!=NULL){\n\t\td=START->next_series->num - START->num;\n\t\tif(i>=d){\n\t\t\treturn retNode(START->next_series,i-d);\n\t\t}else if(i==d-1){ //case(b)\n\t\t\t\tP=createNode(START->num+i);\n\t\t\t\tP->next_one=START->next_series;\n\t\t\t\tSTART->next_series=P;\n\t\t\t\treturn retNode(P,0);\n\t\t}else if(i<d-1){ //case(a)\n\t\t\t\tP=createNode(START->num+i+1);\n\t\t\t\tP->next_series=START->next_series;\n\t\t\t\tSTART->next_series=P;\n\t\t\t\tP=createNode(START->num+i);\n\t\t\t\tP->next_one=START->next_series;\n\t\t\t\tSTART->next_series=P;\n\t\t\t\treturn retNode(P,0);\n\t\t}\n\t}\n\treturn START;\n}\n\nvoid shuffle(int x,int y,NODE *HEAD,NODE *TAIL,int n){\n\n\tNODE *Px,*Py,*Pend;\n\tNODE *Ptmp;\n\t\n\tPx=retNode(HEAD,x);\n\tPy=retNode(Px,y-x);\n\tPend=retNode(HEAD,n);\n\t\n\tPtmp=HEAD->next_one;//bak\n\tHEAD->next_one=Py->next_one;\n\tPend->next_one=Px->next_one;\n\tPy->next_one=Ptmp;\n\tPx->next_one=TAIL;\n\treturn;\n}\n\n\nint countCard(NODE *P,int p,int q,int r){\n//printf(\"p=%d,q=%d,r=%d\\t\",p,q,r);dbgPrint(P);\t\n\n\tstatic int cnt;\n\tNODE *Pp,*Pq;\n\tint d,p0,q0;\n\tif(P->num==0){\n\t\tcnt=0;\n\t\tPp=retNode(P,p);\n\t\tPq=retNode(P,q);\n\t\tcountCard(Pp,0,q-p,r);\n\t}\n\t\n\tif(p==0){\n\t\tif(q==0){\n\t\t\tif(P->num<=r)cnt++;\n\t\t\treturn cnt;\n\t\t}\n\t\tif(P->next_one!=NULL){\n\t\t\tif(P->num<=r)cnt++;\n\t\t\tcountCard(P->next_one,0,q-1,r);\n\t\t}\n\t\tif(P->next_series!=NULL){\n\t\t\tp0=P->num;\n\t\t\tq0=P->next_series->num;\n\t\t\td=q0-p0;\n\t\t\tif(r<p0){cnt=cnt;\n\t\t\t}else if(q0<=r){cnt+=d;\n\t\t\t}else if(p0<=r && r<q0){cnt+=r-p0+1;}\n\t\t\tcountCard(P->next_series,0,q-d,r);\n\t\t}\n\t}\n\treturn cnt;\n}"
  },
  {
    "language": "C",
    "code": "#include <stdio.h>\n#include <stdlib.h>\n//Impossibly large number\n#define ILN 1000000002\n\n\ntypedef struct tag_node{\n\tint num;\n\tstruct tag_node *next_series;\n\tstruct tag_node *next_one;\n}NODE;\n\nNODE *createNode(int i);\nNODE *retNode(NODE *START,int i);\nvoid shuffle(int x,int y,NODE *HEAD,NODE *TAIL,int n);\nint countCard(NODE *P,int p,int q,int r);\nvoid dbgPrint(NODE *P);\nvoid freeNode(NODE *P);\n\nint main(){\n\tint n,m;\n\tint p,q,r;\n\tint x,y;\n\tNODE *HEAD,*TAIL,*Pnode;\n\tint i;\n\tint ans;\n\n\twhile(1){\n\t\tscanf(\"%d\\n\",&n);\n\t\tif(!n)break;\n\t\tscanf(\"%d\\n\",&m);\n\t\tscanf(\"%d %d %d\\n\",&p,&q,&r);\n\n\t\tHEAD=createNode(0);\n\t\tTAIL=createNode(ILN);\n\n\t\tPnode=createNode(1);\n\t\tHEAD->next_one=Pnode;\n\t\tPnode=createNode(n);\n\t\tHEAD->next_one->next_series=Pnode;\n\t\tPnode->next_one=TAIL;\n\t\t\n//dbgPrint(HEAD);\t\n\t\tfor(i=0;i<m;i++){\n\t\t\tscanf(\"%d %d\\n\",&x,&y);\n\t\t\tshuffle(x,y,HEAD,TAIL,n);\n//dbgPrint(HEAD);\t\n\t\t}\n\t\t\n\t\tans=countCard(HEAD,p,q,r);\n\n\t\tprintf(\"%d\\n\",ans);\n\t\tfreeNode(HEAD);\n\n\t}\n\treturn 0;\n}\n\n\nNODE *createNode(int i){\n\tNODE *P;\n\tP=(NODE *)malloc(sizeof(NODE));\n\tif(!P){printf(\"malloc error\");exit(1);}\n\tP->num=i;\n\tP->next_series=NULL;\n\tP->next_one=NULL;\n\t\n\treturn P;\n}\n\nvoid dbgPrint(NODE *P){\n\tprintf(P->num==ILN?\"E\":\"%d\",P->num);\n\tif(P->next_series!=NULL){printf(\"=>\");dbgPrint(P->next_series);}\n\tif(P->next_one!=NULL){printf(\"->\");dbgPrint(P->next_one);}\n\tif(P->next_series==NULL && P->next_one==NULL )printf(\"-*\\n\");\n\treturn;\n}\n\nvoid freeNode(NODE *P){\n\tif(P->next_series!=NULL)freeNode(P->next_series);\n\tif(P->next_one!=NULL )free(P->next_one);\n\tif(P->next_series==NULL && P->next_one==NULL )free(P);\n}\n\nNODE *retNode(NODE *START,int i){\n\t// return i-th pointer from START;\n\t//  if not exists :add Node & connect next_one(->)\n\t//    (a) 0->1=>9->ILN\t5th?\n\t//        0->1=>5->6=>9->ILN-*\treturn ( 5-> )\n\t//    (b) 0->1=>9->ILN\t8th?\n\t//        0->1=>8->9->ILN-*\treturn ( 8-> )\n\t//    (c) 0->1=>9->ILN\t1st?\n\t//        0->1->2=>9->ILN-*\treturn ( 1-> )\n\n\tNODE *P;\n\tint d;\n\tif(i==0){//(c)\n\t\tif(START->next_series==NULL)return START;\n\t\tP=createNode(START->num+1);\n\t\tP->next_series=START->next_series;\n\t\tSTART->next_series=NULL;\n\t\tSTART->next_one=P;\n\t\treturn START;\n\t}\n\tif(START->num==ILN)return START;\n\tif(START->next_one!=NULL){\n\t\treturn retNode(START->next_one,i-1);\n\t}\n\tif(START->next_series!=NULL){\n\t\td=START->next_series->num - START->num;\n\t\tif(i>=d){\n\t\t\treturn retNode(START->next_series,i-d);\n\t\t}else if(i==d-1){ //case(b)\n\t\t\t\tP=createNode(START->num+i);\n\t\t\t\tP->next_one=START->next_series;\n\t\t\t\tSTART->next_series=P;\n\t\t\t\treturn retNode(P,0);\n\t\t}else if(i<d-1){ //case(a)\n\t\t\t\tP=createNode(START->num+i+1);\n\t\t\t\tP->next_series=START->next_series;\n\t\t\t\tSTART->next_series=P;\n\t\t\t\tP=createNode(START->num+i);\n\t\t\t\tP->next_one=START->next_series;\n\t\t\t\tSTART->next_series=P;\n\t\t\t\treturn retNode(P,0);\n\t\t}\n\t}\n\treturn START;\n}\n\nvoid shuffle(int x,int y,NODE *HEAD,NODE *TAIL,int n){\n\n\tNODE *Px,*Py,*Pend;\n\tNODE *Ptmp;\n\t\n\tPx=retNode(HEAD,x);\n\tPy=retNode(HEAD,y);\n\tPend=retNode(HEAD,n);\n\t\n\tPtmp=HEAD->next_one;//bak\n\tHEAD->next_one=Py->next_one;\n\tPend->next_one=Px->next_one;\n\tPy->next_one=Ptmp;\n\tPx->next_one=TAIL;\n\treturn;\n}\n\n\nint countCard(NODE *START,int p,int q,int r){\n//printf(\"p=%d,q=%d,r=%d\\t\",p,q,r);dbgPrint(P);\t\n\n\tstatic int cnt;\n\tNODE *Pp,*Pq,*P;\n\tint d,p0,q0;\n\n\tPp=retNode(START,p);\n\tPq=retNode(START,q);\n\n\tP=Pp;\n\tcnt=0;\n\twhile(1){\n\t\tif(P->next_one!=NULL){\n\t\t\tif(P->num<=r)cnt++;\n\t\t\tif(P==Pq)return cnt;\n\t\t\tP=P->next_one;\n\t\t}else if(P->next_series!=NULL){\n\t\t\tp0=P->num;\n\t\t\tq0=P->next_series->num;\n\t\t\td=q0-p0;\n\t\t\tif(r<p0){cnt=cnt;\n\t\t\t}else if(q0<=r){cnt+=d;\n\t\t\t}else if(p0<=r && r<q0){cnt+=r-p0+1;\n\t\t\t}\n\t\t\tif(P==Pq)return cnt;\n\t\t\tP=P->next_series;\n\t\t}else{return cnt;\n\t\t}\n\t}\n}"
  },
  {
    "language": "C",
    "code": "#include <stdio.h>\n#include <stdlib.h>\n//Impossibly large number\n#define ILN 1000000002\n\n\ntypedef struct tag_node{\n\tint num;\n\tstruct tag_node *next_series;\n\tstruct tag_node *next_one;\n}NODE;\n\nNODE *createNode(int i);\nNODE *retNode(NODE *START,int i);\nvoid shuffle(int x,int y,NODE *HEAD,NODE *TAIL,int n);\nint countCard(NODE *P,int p,int q,int r);\nvoid dbgPrint(NODE *P);\nvoid freeNode(NODE *P);\n\nint main(){\n\tint n,m;\n\tint p,q,r;\n\tint x,y;\n\tNODE *HEAD,*TAIL,*Pnode;\n\tint i;\n\tint ans;\n\n\twhile(1){\n\t\tscanf(\"%d\\n\",&n);\n\t\tif(!n)break;\n\t\tscanf(\"%d\\n\",&m);\n\t\tscanf(\"%d %d %d\\n\",&p,&q,&r);\n\n\t\tHEAD=createNode(0);\n\t\tTAIL=createNode(ILN);\n\n\t\tPnode=createNode(1);\n\t\tHEAD->next_one=Pnode;\n\t\tPnode=createNode(n);\n\t\tHEAD->next_one->next_series=Pnode;\n\t\tPnode->next_one=TAIL;\n\t\t\n//dbgPrint(HEAD);\t\n\t\tfor(i=0;i<m;i++){\n\t\t\tscanf(\"%d %d\\n\",&x,&y);\n\t\t\tshuffle(x,y,HEAD,TAIL,n);\n//dbgPrint(HEAD);\t\n\t\t}\n\t\t\n\t\tans=countCard(HEAD,p,q,r);\n\n\t\tprintf(\"%d\\n\",ans);\n\t\tfreeNode(HEAD);\n\n\t}\n\treturn 0;\n}\n\n\nNODE *createNode(int i){\n\tNODE *P;\n\tP=(NODE *)malloc(sizeof(NODE));\n\tif(!P){printf(\"malloc error\");exit(1);}\n\tP->num=i;\n\tP->next_series=NULL;\n\tP->next_one=NULL;\n\t\n\treturn P;\n}\n\nvoid dbgPrint(NODE *P){\n\tprintf(P->num==ILN?\"E\":\"%d\",P->num);\n\tif(P->next_series!=NULL){printf(\"=>\");dbgPrint(P->next_series);}\n\tif(P->next_one!=NULL){printf(\"->\");dbgPrint(P->next_one);}\n\tif(P->next_series==NULL && P->next_one==NULL )printf(\"-*\\n\");\n\treturn;\n}\n\nvoid freeNode(NODE *P){\n\tif(P->next_series!=NULL)freeNode(P->next_series);\n\tif(P->next_one!=NULL )free(P->next_one);\n\tif(P->next_series==NULL && P->next_one==NULL )free(P);\n}\n\nNODE *retNode(NODE *START,int i){\n\t// return i-th pointer from START;\n\t//  if not exists :add Node & connect next_one(->)\n\t//    (a) 0->1=>9->ILN\t5th?\n\t//        0->1=>5->6=>9->ILN-*\treturn ( 5-> )\n\t//    (b) 0->1=>9->ILN\t8th?\n\t//        0->1=>8->9->ILN-*\treturn ( 8-> )\n\n\tNODE *P;\n\tint d;\n\tif(i==0){\n\t\tif(START->next_series==NULL)return START;\n\t\tP=createNode(START->num+1);\n\t\tP->next_series=START->next_series;\n\t\tSTART->next_series=NULL;\n\t\tSTART->next_one=P;\n\t\treturn START;\n\t}\n\tif(START->num==ILN)return START;\n\tif(START->next_one!=NULL){\n\t\treturn retNode(START->next_one,i-1);\n\t}\n\tif(START->next_series!=NULL){\n\t\td=START->next_series->num - START->num;\n\t\tif(i>=d){\n\t\t\treturn retNode(START->next_series,i-d);\n\t\t}else if(i==d-1){ //case(b)\n\t\t\t\tP=createNode(START->num+i);\n\t\t\t\tP->next_one=START->next_series;\n\t\t\t\tSTART->next_series=P;\n\t\t\t\treturn retNode(P,0);\n\t\t}else if(i<d-1){ //case(a)\n\t\t\t\tP=createNode(START->num+i+1);\n\t\t\t\tP->next_series=START->next_series;\n\t\t\t\tSTART->next_series=P;\n\t\t\t\tP=createNode(START->num+i);\n\t\t\t\tP->next_one=START->next_series;\n\t\t\t\tSTART->next_series=P;\n\t\t\t\treturn retNode(P,0);\n\t\t}\n\t}\n\treturn START;\n}\n\nvoid shuffle(int x,int y,NODE *HEAD,NODE *TAIL,int n){\n\n\tNODE *Px,*Py,*Pend;\n\tNODE *Ptmp;\n\t\n\tPx=retNode(HEAD,x);\n\tPy=retNode(Px,y-x);\n\tPend=retNode(Py,n-y);\n\t\n\tPtmp=HEAD->next_one;//bak\n\tHEAD->next_one=Py->next_one;\n\tPend->next_one=Px->next_one;\n\tPy->next_one=Ptmp;\n\tPx->next_one=TAIL;\n\treturn;\n}\n\n\nint countCard(NODE *P,int p,int q,int r){\n//printf(\"p=%d,q=%d,r=%d\\t\",p,q,r);dbgPrint(P);\t\n\n\tstatic int cnt;\n\tNODE *Pp,*Pq;\n\tint d,p0,q0;\n\tif(P->num==0){\n\t\tcnt=0;\n\t\tPp=retNode(P,p);\n\t\tPq=retNode(Pp,q-p);\n\t\tcountCard(Pp,0,q-p,r);\n\t}\n\t\n\tif(p==0){\n\t\tif(q==0){\n\t\t\tif(P->num<=r)cnt++;\n\t\t\treturn cnt;\n\t\t}\n\t\tif(P->next_one!=NULL){\n\t\t\tif(P->num<=r)cnt++;\n\t\t\tcountCard(P->next_one,0,q-1,r);\n\t\t}\n\t\tif(P->next_series!=NULL){\n\t\t\tp0=P->num;\n\t\t\tq0=P->next_series->num;\n\t\t\td=q0-p0;\n\t\t\tif(r<p0){cnt=cnt;\n\t\t\t}else if(q0<=r){cnt+=d;\n\t\t\t}else if(p0<=r && r<q0){cnt+=r-p0+1;}\n\t\t\tcountCard(P->next_series,0,q-d,r);\n\t\t}\n\t}\n\treturn cnt;\n}"
  },
  {
    "language": "C",
    "code": "#include <stdio.h>\n#include <stdlib.h>\n#include <string.h>\n\nvoid proc(int n);\n\ntypedef struct pile PILE;\nPILE *pile_new(int n);\nvoid pile_delete(PILE *self);\nvoid pile_shuffle(PILE *self, int x, int y);\nint pile_count(PILE *self, int p, int q, int r);\nPILE *pile_cut(PILE *self, int x);\nvoid pile_join(PILE *self, PILE *joined);\n\ntypedef struct group GROUP;\n\nint main()\n{\n\twhile (1) {\n\t\tint n;\n\t\tscanf(\"%d\", &n);\n\t\tif (n == 0) {\n\t\t\tbreak;\n\t\t} else {\n\t\t\tproc(n);\n\t\t}\n\t}\n\treturn 0;\n}\n\nvoid proc(int n)\n{\n\tint m, p, q, r;\n\tscanf(\"%d\", &m);\n\tscanf(\"%d %d %d\", &p, &q, &r);\n\n\tPILE *pile = pile_new(n);\n\n\tfor (; m > 0; m--) {\n\t\tint x, y;\n\t\tscanf(\"%d %d\", &x, &y);\n\t\tpile_shuffle(pile, x, y);\n\t}\n\n\tprintf(\"%d\\n\", pile_count(pile, p, q, r));\n\n\tpile_delete(pile);\n}\n\nstruct pile {\n\tGROUP *first;\n\tGROUP *last;\n};\n\nstruct group {\n\tint start;\n\tint length;\n\tGROUP *next;\n};\n\nPILE *pile_new(int n)\n{\n\tPILE *self;\n\tself = malloc(sizeof(PILE));\n\tself->first = self->last = malloc(sizeof(GROUP));\n\tself->first->start = 1;\n\tself->first->length = n;\n\tself->first->next = NULL;\n\treturn self;\n}\n\nvoid pile_delete(PILE *self)\n{\n\tGROUP *w;\n\twhile (self->first) {\n\t\tw = self->first->next;\n\t\tfree(self->first);\n\t\tself->first = w;\n\t}\n\tfree(self);\n}\n\nvoid pile_shuffle(PILE *self, int x, int y)\n{\n\tPILE *p0, *p1, *p2;\n\n\tp0 = malloc(sizeof(PILE));\n\tp0->first = self->first;\n\tp0->last = self->last;\n\tp1 = pile_cut(p0, x);\n\tp2 = pile_cut(p1, y-x);\n\tpile_join(p2, p1);\n\tpile_join(p2, p0);\n\tself->first = p2->first;\n\tself->last = p2->last;\n\tfree(p2);\n}\n\nPILE *pile_cut(PILE *self, int x)\n{\n\tPILE *cut;\n\tint rest;\n\tGROUP *cur;\n\n\tcut = malloc(sizeof(PILE));\n\trest = x;\n\tcur = self->first;\n\n\twhile (cur->length < rest) {\n\t\trest -= cur->length;\n\t\tcur = cur->next;\n\t}\n\n\tif (cur->length == rest) {\n\t\tcut->first = cur->next;\n\t\tcut->last = self->last;\n\t\tcur->next = NULL;\n\t\tself->last = cur;\n\t} else {\n\t\tcut->first = malloc(sizeof(GROUP));\n\t\tcut->first->start = cur->start + rest;\n\t\tcut->first->length = cur->length - rest;\n\t\tcut->first->next = cur->next;\n\t\tcut->last = (cur == self->last) ? cut->first : self->last;\n\t\tcur->length = rest;\n\t\tcur->next = NULL;\n\t\tself->last = cur;\n\t}\n\n\treturn cut;\n}\n\nvoid pile_join(PILE *self, PILE *joined)\n{\n\tself->last->next = joined->first;\n\tself->last = joined->last;\n\tfree(joined);\n}\n\nint pile_count(PILE *self, int p, int q, int r)\n{\n\tint offset, count;\n\tGROUP *cur;\n\toffset = 0;\n\tcount = 0;\n\tcur = self->first;\n\twhile (cur) {\n\t\tif (p <= offset + cur->length && q > offset) {\n\t\t\tint out_p, out_q, start, length;\n\t\t\tout_p = p <= offset ? 0 : p - offset - 1;\n\t\t\tout_q = q >= offset + cur->length ? 0 : offset + cur->length - q;\n\t\t\tstart = cur->start + out_p;\n\t\t\tlength = cur->length - out_p - out_q;\n\t\t\tif (start + length - 1 <= r) {\n\t\t\t\tcount += length;\n\t\t\t} else if (start <= r) {\n\t\t\t\tcount += r - start + 1;\n\t\t\t}\n\t\t}\n\t\toffset += cur->length;\n\t\tcur = cur->next;\n\t}\n\n\treturn count;\n}"
  },
  {
    "language": "C",
    "code": "#include <stdio.h>\n#include <stdlib.h>\n//Impossibly large number\n#define ILN 1000000002\n\n\ntypedef struct tag_node{\n\tint num;\n\tstruct tag_node *next_series;\n\tstruct tag_node *next_one;\n}NODE;\n\nNODE *createNode(int i);\nNODE *retNode(NODE *START,int i);\nvoid shuffle(int x,int y,NODE *HEAD,NODE *TAIL,int n);\nint countCard(NODE *P,int p,int q,int r);\nvoid dbgPrint(NODE *P);\nvoid freeNode(NODE *P);\n\nint main(){\n\tint n,m;\n\tint p,q,r;\n\tint x,y;\n\tNODE *HEAD,*TAIL,*Pnode;\n\tint i;\n\tint ans;\n\n\twhile(1){\n\t\tscanf(\"%d\\n\",&n);\n\t\tif(!n)break;\n\t\tscanf(\"%d\\n\",&m);\n\t\tscanf(\"%d %d %d\\n\",&p,&q,&r);\n\n\t\tHEAD=createNode(0);\n\t\tTAIL=createNode(ILN);\n\n\t\tPnode=createNode(1);\n\t\tHEAD->next_one=Pnode;\n\t\tPnode=createNode(n);\n\t\tHEAD->next_one->next_series=Pnode;\n\t\tPnode->next_one=TAIL;\n\t\t\n//dbgPrint(HEAD);\t\n\t\tfor(i=0;i<m;i++){\n\t\t\tscanf(\"%d %d\\n\",&x,&y);\n\t\t\tshuffle(x,y,HEAD,TAIL,n);\n//dbgPrint(HEAD);\t\n\t\t}\n//puts(\"shuffle\");\t\t\n\t\tans=countCard(HEAD,p,q,r);\n\n\t\tprintf(\"%d\\n\",ans);\n\t\t//freeNode(HEAD);\n\n\t}\n\treturn 0;\n}\n\n\nNODE *createNode(int i){\n\tNODE *P;\n\tP=(NODE *)malloc(sizeof(NODE));\n\tif(!P){printf(\"malloc error\");exit(1);}\n\tP->num=i;\n\tP->next_series=NULL;\n\tP->next_one=NULL;\n\t\n\treturn P;\n}\n\nvoid dbgPrint(NODE *P){\n\tprintf(P->num==ILN?\"E\":\"%d\",P->num);\n\tif(P->next_series!=NULL){printf(\"=>\");dbgPrint(P->next_series);}\n\tif(P->next_one!=NULL){printf(\"->\");dbgPrint(P->next_one);}\n\tif(P->next_series==NULL && P->next_one==NULL )printf(\"-*\\n\");\n\treturn;\n}\n\nvoid freeNode(NODE *P){\n\tif(P->next_series!=NULL)freeNode(P->next_series);\n\tif(P->next_one!=NULL )free(P->next_one);\n\tif(P->next_series==NULL && P->next_one==NULL )free(P);\n}\n\nNODE *retNode(NODE *START,int i){\n\t// return i-th pointer from START;\n\t//  if not exists :add Node & connect next_one(->)\n\t//    (a) 0->1=>9->ILN\t5th?\n\t//        0->1=>5->6=>9->ILN-*\treturn ( 5-> )\n\t//    (b) 0->1=>9->ILN\t8th?\n\t//        0->1=>8->9->ILN-*\treturn ( 8-> )\n\t//    (c) 0->1=>9->ILN\t1st?\n\t//        0->1->2=>9->ILN-*\treturn ( 1-> )\n\n\tNODE *P;\n\tint d;\n\tif(i==0){//(c)\n\t\tif(START->next_series==NULL)return START;\n\t\tP=createNode(START->num+1);\n\t\tP->next_series=START->next_series;\n\t\tSTART->next_series=NULL;\n\t\tSTART->next_one=P;\n\t\treturn START;\n\t}\n\tif(START->num==ILN)return START;\n\tif(START->next_one!=NULL){\n\t\treturn retNode(START->next_one,i-1);\n\t}\n\tif(START->next_series!=NULL){\n\t\td=START->next_series->num - START->num;\n\t\tif(i>=d){\n\t\t\treturn retNode(START->next_series,i-d);\n\t\t}else if(i==d-1){ //case(b)\n\t\t\t\tP=createNode(START->num+i);\n\t\t\t\tP->next_one=START->next_series;\n\t\t\t\tSTART->next_series=P;\n\t\t\t\t//return retNode(P,0);\n\t\t\t\treturn P;\n\t\t}else if(i<d-1){ //case(a)\n\t\t\t\tP=createNode(START->num+i+1);\n\t\t\t\tP->next_series=START->next_series;\n\t\t\t\tSTART->next_series=P;\n\t\t\t\tP=createNode(START->num+i);\n\t\t\t\tP->next_one=START->next_series;\n\t\t\t\tSTART->next_series=P;\n\t\t\t\t//return retNode(P,0);\n\t\t\t\treturn P;\n\t\t}\n\t}\n\treturn START;\n}\n\nvoid shuffle(int x,int y,NODE *HEAD,NODE *TAIL,int n){\n\n\tNODE *Px,*Py,*Pend;\n\tNODE *Ptmp;\n\t\n\tPx=retNode(HEAD,x);\n\tPy=retNode(HEAD,y);\n\tPend=retNode(HEAD,n);\n\t\n\tPtmp=HEAD->next_one;//bak\n\tHEAD->next_one=Py->next_one;\n\tPend->next_one=Px->next_one;\n\tPy->next_one=Ptmp;\n\tPx->next_one=TAIL;\n\treturn;\n}\n\n\nint countCard(NODE *START,int p,int q,int r){\n//printf(\"p=%d,q=%d,r=%d\\t\",p,q,r);dbgPrint(P);\t\n\n\tstatic int cnt;\n\tNODE *Pp,*Pq,*P;\n\tint d,p0,q0;\n\n\tPp=retNode(START,p);\n\tPq=retNode(START,q);\n\n\tP=Pp;\n\tcnt=0;\n\twhile(1){\n\t\tif(P->next_one!=NULL){\n\t\t\tif(P->num<=r)cnt++;\n\t\t\tif(P==Pq)return cnt;\n\t\t\tP=P->next_one;\n\t\t}else if(P->next_series!=NULL){\n\t\t\tp0=P->num;\n\t\t\tq0=P->next_series->num;\n\t\t\td=q0-p0;\n\t\t\tif(r<p0){cnt=cnt;\n\t\t\t}else if(q0<=r){cnt+=d;\n\t\t\t}else if(p0<=r && r<q0){cnt+=r-p0+1;\n\t\t\t}\n\t\t\tif(P==Pq)return cnt;\n\t\t\tP=P->next_series;\n\t\t}else{return cnt;\n\t\t}\n\t}\n}"
  },
  {
    "language": "C",
    "code": "#include<stdio.h>\n#include<string.h>\n#define Max(x,y) ((x>y)?x:y)\ntypedef struct card{\n\tint s,t,n;\n}card;\ncard x[10500],y[10500];\nint main(){\n\tint i,j,n,m,p,q,r,a,b,c,d;//(a,b)cut c,d:absolute point\n\tint xn,yn,e,f,g;//f:flag g:\n\twhile(1){\n\t\tscanf(\"%d\",&n);\n\t\tif(n==0)break;\n\t\tscanf(\"%d%d%d%d\",&m,&p,&q,&r);\n\t\txn=1;\n\t\tx[0]=(card){1,n+1,n};\n\t\twhile(m--){\n\t\t\tscanf(\"%d%d\",&a,&b);\n\t\t\td=n+1;c=d-x[xn-1].n;\n\t\t\tf=0;yn=0;\n\t\t\t//for(i=0;i<xn;i++)printf(\"(%d-%d)\",x[i].s,x[i].t);\n\t\t\t//printf(\"\\n\");\n\t\t\tfor(i=xn-1;i>=0;){\n\t\t\t\t//printf(\"c:%d  d:%d\\n\",c,d);\n\t\t\t\tif(f==0){\n\t\t\t\t\tif(c==b+1){\n\t\t\t\t\t\tfor(j=i;j<xn;j++)y[yn++]=x[j];\n\t\t\t\t\t\tf=1;g=i-1;i--;\n\t\t\t\t\t}else if(c<b+1 && b+1<d){\n\t\t\t\t\t\ty[yn++]=(card){x[i].s+b+1-c,x[i].t,x[i].t-x[i].s-b-1+c};\n\t\t\t\t\t\tfor(j=i+1;j<xn;j++)y[yn++]=x[j];\n\t\t\t\t\t\tx[i]=(card){x[i].s,x[i].s+b+1-c,b+1-c};\n\t\t\t\t\t\t//for(j=0;j<=i;j++)printf(\"(%d-%d)\",x[j].s,x[j].t);\n\t\t\t\t\t\t//printf(\"\\n\");\n\t\t\t\t\t\tf=1;g=i;d=c+x[i].n;\n\t\t\t\t\t\tcontinue;\n\t\t\t\t\t}else i--;\n\t\t\t\t}else{\n\t\t\t\t\tif(c==a+1){\n\t\t\t\t\t\tfor(j=i;j<=g;j++)y[yn++]=x[j];\n\t\t\t\t\t\tfor(j=0;j<i;j++)y[yn++]=x[j];\n\t\t\t\t\t\tbreak;\n\t\t\t\t\t}else if(c<a+1 && a+1<d){\n\t\t\t\t\t\ty[yn++]=(card){x[i].s+a+1-c,x[i].t,x[i].t-x[i].s-a-1+c};\n\t\t\t\t\t\tfor(j=i+1;j<=g;j++)y[yn++]=x[j];\n\t\t\t\t\t\tx[i]=(card){x[i].s,x[i].s+a+1-c,a+1-c};\n\t\t\t\t\t\tfor(j=0;j<=i;j++)y[yn++]=x[j];\n\t\t\t\t\t\tbreak;\n\t\t\t\t\t}else i--;\n\t\t\t\t}\n\t\t\t\td=c;\n\t\t\t\tc=d-x[i].n;\n\t\t\t}\n\t\t\t//for(i=0;i<yn;i++)printf(\"(%d-%d)\",y[i].s,y[i].t);\n\t\t\t//printf(\"\\n\");\n\t\t\tmemcpy(x,y,sizeof(card)*yn);\n\t\t\txn=yn;\n\t\t}\n\t\t//printf(\"\\n\");\n\t\t//for(i=0;i<xn;i++)printf(\"(%d - %d)\",x[i].s,x[i].t);\n\t\t//printf(\"\\n\\n\");\n\t\ta=0;b=1;\n\t\tfor(i=0;i<xn;i++){\n\t\t\t/*if(b<p){\n\t\t\t\tif(q>=b){\n\t\t\t\t\tif(q<b+x[i].n){\n\t\t\t\t\t\ta+=(x[i].s>r)?0:( (r<=x[i].s+q-b)?(r-x[i].s+1):(q-b+1) );\n\t\t\t\t\t\tbreak;\n\t\t\t\t\t}\n\t\t\t\t\telse\n\t\t\t\t\t\ta+=(x[i].s>r)?0:( (r<x[i].t)?(r-x[i].s+1):(x[i].n) );\n\t\t\t\t}\n\t\t\t}else if(b==p){\n\t\t\t\tif(q<b+x[i].n){\n\t\t\t\t\ta+=(x[i].s>r)?0:( (r<=x[i].s+q-p)?(r-x[i].s+1):(q-b+1) );\n\t\t\t\t\tbreak;\n\t\t\t\t}\n\t\t\t\telse\n\t\t\t\t\ta+=(x[i].s>r)?0:( (r<x[i].t)?(r-x[i].s+1):(x[i].n) );\n\t\t\t}else if(b<p && p<b+x[i].n){\n\t\t\t\tif(q<b+x[i].n){\n\t\t\t\t\ta+=(x[i].s+p-b>r)?0:( (r<=x[i].s+q-b)?(r-x[i].s-p+b+1):(q-p+1) );\n\t\t\t\t}\n\t\t\t\telse\n\t\t\t\t\ta+=(x[i].s+p-b>r)?0:( (r<x[i].t)?(r-x[i].s-p+b+1):(x[i].n-p+b) );\n\t\t\t}*/\n\t\t\t//printf(\"%d \",b);\n\t\t\tif(p<b+x[i].n && b<=q){\n\t\t\t\tc=x[i].s;\n\t\t\t\td=x[i].t;\n\t\t\t\tif(b<p)c+=p-b;\n\t\t\t\tif(b+x[i].n>q)d+=q-b-x[i].n+1;\n\t\t\t\tif(d>r)d=r+1;\n\t\t\t\tif(c>r)c=d+1;\n\t\t\t\t//printf(\"%d %d\",c,d);\n\t\t\t\t> printf(\"%d %d\",c,d);\n> \t\t\t\t\n\t\t\t\ta+=Max(0,d-c);\n\t\t\t}\n\t\t\t//printf(\"\\n\");\n\t\t\tb+=x[i].n;\n\t\t}\n\t\tprintf(\"%d\\n\",a);\n\t}\n\treturn 0;\n}"
  },
  {
    "language": "C",
    "code": "#include <stdio.h>\n#include <stdlib.h>\n#include <string.h>\nint main()\n{\n  int n,m,p,q,r,i,x,y;\n  int *a,*s,*t,*u;\n  for(;;){\n    scanf(\"%d\",&n);\n    if(n == 0) break;\n    a = (int *)(malloc(sizeof(int)*n));\n    for(i=0;i<n;i++){\n      a[i] = i+1;\n    }\n    scanf(\"%d\",&m);\n    scanf(\"%d%d%d\",&p,&q,&r);\n    for(i=0;i<m;i++){\n      scanf(\"%d%d\",&x,&y);\n      s = (int *)(malloc(sizeof(int)*x));\n      t = (int *)(malloc(sizeof(int)*(y-x)));\n      u = (int *)(malloc(sizeof(int)*(n-y)));\n      memcpy(s,a,sizeof(int)*x);\n      memcpy(t,a+x,sizeof(int)*(y-x));\n      memcpy(u,a+y,sizeof(int)*(n-y));\n      memcpy(a,u,sizeof(int)*(n-y));\n      memcpy(a+(n-y),t,sizeof(int)*(y-x));\n      memcpy(a+(n-x),s,sizeof(int)*x);\n      free(s);\n      free(t);\n      free(u);\n    }\n    x = 0;\n    for(i=p-1;i<q;i++){\n      if(a[i] <= r) x++;\n    }\n    printf(\"%d\\n\",x);\n    free(a);\n  }\n  return 0;\n}"
  },
  {
    "language": "C",
    "code": "// Aizu 0536: Shuffle\n// 2017.10.26 bal4u@uu\n\n#include <stdio.h>\n#include <string.h>\n\ntypedef struct { int x1, x2; } TABA;\nTABA taba[2][100005]; int sz;\nint k1, k2;\n\nint split(int x)\n{\n\tint s, i, k;\n\n\tfor (s = 0, i = 0; ; i++) {\n\t\tk = taba[k1][i].x2 - taba[k1][i].x1 + 1;\n\t\tif (s + k == x) return i;\n\t\tif (s + k > x) break;\n\t\ts += k;\n\t}\n\tmemcpy(taba[k1]+i+1, taba[k1]+i, sizeof(TABA)*(sz-i)), sz++;\n\tx = (x-s)+taba[k1][i].x1-1;\n\ttaba[k1][i].x2 = x, taba[k1][i+1].x1 = x+1;\n\treturn i;\n}\n\nvoid shuffle(int x, int y)\n{\n\tint i, j, s;\n\n\ti = split(x), j = split(y);\n\ts = 0;\n\tmemcpy(taba[k2],   taba[k1]+j+1, sizeof(TABA)*(sz-j-1)); s += sz - j - 1;\n\tmemcpy(taba[k2]+s, taba[k1]+i+1, sizeof(TABA)*(j-i));    s += j-i;\n\tmemcpy(taba[k2]+s, taba[k1],     sizeof(TABA)*(i+1));\n\tk1 = k2, k2 = !k2;\n}\n\nint main()\n{\n\tint n, m, p, q, r, x, y;\n\tint i, ans;\n\n\twhile (scanf(\"%d\", &n) && n > 0) {\n\t\tscanf(\"%d%d%d%d\", &m, &p, &q, &r);\n\t\ttaba[0][0].x1 = 1, taba[0][0].x2 = n, k1 = 0, k2 = 1, sz = 1;\n\t\twhile (m-- > 0) {\n\t\t\tscanf(\"%d%d\", &x, &y);\n\t\t\tshuffle(x, y);\n\t\t}\n\t\tx = 0; if (p > 1) x = split(p-1) + 1;\n\t\ty = split(q);\n\t\tfor (ans = 0, i = x; i <= y; i++) {\n\t\t\tif (taba[k1][i].x1 > r) continue;\n\t\t\tif (taba[k1][i].x2 <= r) ans += taba[k1][i].x2 - taba[k1][i].x1 + 1;\n\t\t\telse \t\t\t         ans += r - taba[k1][i].x1 + 1;\n\t\t}\n\t\tprintf(\"%d\\n\", ans);\n\t}\n\treturn 0;\n}"
  },
  {
    "language": "C",
    "code": "#include <stdio.h>\n#include <stdlib.h>\n\ntypedef struct _node {\n    int s, e, num;\n    struct _node *next;\n} CARD;\n\nint mmax(int a, int b)\n{\n    return (a > b ? a : b);\n}\n\nint getNum(int p, int q, int r, int start, int end, int sum, int num){\n    int x, y;\n    \n    x = y = 0;\n    if (sum < p){\n        x = p - sum - 1;\n    }\n    if (sum + num > q){\n        y = q - sum - num;\n    }\n    \n    start += x;\n    end += y;\n    if (end > r){\n        end = r;\n    }\n    return (mmax(0, end - start + 1));\n}\n\nint main(void)\n{\n    CARD *newnode, *thisnode, *head, *tail, *del;\n    CARD *A, *Bstart, *Bend, *C;\n    int n, shuf;\n    int p, q, r;\n    int st, end;\n    int i, j, k;\n    int sum;\n    int ans;\n    \n    while (1){\n        scanf(\"%d\", &n);\n        \n        if (n == 0){\n            break;\n        }\n        \n        scanf(\"%d\", &shuf);\n        \n        scanf(\"%d%d%d\", &p, &q, &r);\n        \n        newnode = (CARD *)malloc(sizeof(CARD));\n        newnode->s = 1;\n        newnode->e = n;\n        newnode->num = n;\n        \n        head = tail = newnode;\n        newnode->next = NULL;\n        \n        for (i = 0; i < shuf; i++){\n            scanf(\"%d%d\", &st, &end);\n                                                    /* search the #st card */\n            sum = 0;                                /* initialize */\n            for (thisnode = head; thisnode != NULL; thisnode = thisnode->next){\n                if (thisnode->num + sum > st){\n                    break;\n                }\n                else {\n                    sum += thisnode->num;\n                }\n            }\n            Bstart = (CARD *)malloc(sizeof(CARD));\n            Bstart->s = thisnode->s + st - sum;\n            Bstart->e = thisnode->e;\n            Bstart->num = Bstart->e - Bstart->s + 1;\n            thisnode->e = Bstart->s - 1;\n            thisnode->num = thisnode->e - thisnode->s + 1;\n            A = thisnode;\n            \n            Bstart->next = A->next;\n            A->next = Bstart;\n            \n            sum = 0;\n            for (thisnode = head; thisnode != NULL; thisnode = thisnode->next){\n                if (thisnode->num + sum > end){\n                    break;\n                }\n                else {\n                    sum += thisnode->num;\n                }\n            }\n            C = (CARD *)malloc(sizeof(CARD));\n            C->s = thisnode->s + end - sum;\n            C->e = thisnode->e;\n            C->num = C->e - C->s + 1;\n            thisnode->e = C->s - 1;\n            thisnode->num = thisnode->e - thisnode->s + 1;\n            Bend = thisnode;\n            \n            C->next = Bend->next;\n            Bend->next = C;\n            \n            for (thisnode = head; thisnode != NULL; thisnode = thisnode->next){\n                tail = thisnode;\n            }\n            \n            tail->next = Bstart;\n            Bend->next = head;\n            A->next = NULL;\n            head = C;\n            tail = A;\n        }\n        ans = sum = 0;\n        for (thisnode = head; thisnode != NULL;){\n            if (thisnode->num != 0 && p <= thisnode->num + sum && sum <= q){\n                ans += getNum(p, q, r, thisnode->s, thisnode->e, sum, thisnode->num);\n            }\n            sum += thisnode->num;\n            del = thisnode;\n            thisnode = thisnode->next;\n            free(del);\n        }\n        \n        \n        printf(\"%d\\n\", ans);\n    }\n    \n    return (0);\n}"
  },
  {
    "language": "C",
    "code": "#include <stdio.h>\n#include <stdlib.h>\n\n\ntypedef struct _node {\n\tint start;\n\tint end;\n\tint no;\n\tstruct _node *next;\n} NODE;\n\nNODE *head;\n\nNODE *yama_a = NULL;\nNODE *yama_b = NULL;\nNODE *yama_c = NULL;\n\nvoid shuffle(int x, int y);\nvoid add_newnode_tail(NODE **yama, NODE *newnode);\n\nint main(void)\n{\n\tint n, m;\n\tint p, q, r;\n\tint\ti;\n\tint x, y;\n\t\n\tscanf(\"%d%d\", &n, &m);\n\tscanf(\"%d%d%d\", &p, &q, &r);\n\t\n\thead = (NODE *)malloc(sizeof(NODE));\n\thead->start = 1;\n\thead->end = n;\n\thead->no = n;\n\thead->next = NULL;\n\t\n\tfor (i = 0; i < m; i++){\n\t\tscanf(\"%d%d\", &x, &y);\n\t\tshuffle(x, y);\n\t}\n\n\treturn (0);\n}\n\n\t\n\nvoid shuffle(int x, int y)\n{\n\tint n;\n\tNODE *node;\n\tNODE *new_node;\n\tNODE *split;\n\t\n    yama_a = NULL;\n    yama_b = NULL;\n    yama_c = NULL;\n\t\n\t\n\t/* A */\n\t\n\tn = 0;\n\twhile (1){\n\t\tif (n + head->no > x){\n\t\t\tbreak;\n\t\t}\n\t\tn += head->no;\n\n\t\tnode = head;\n\t\thead = head->next;\n\n\t\tadd_newnode_tail(&yama_a, node);\n\t}\n\t\n\tif (n < x){\n\t\tsplit = (NODE *)malloc(sizeof(NODE));\n\t\tsplit->start = head->start;\n\t\tsplit->end = split->start + x - n - 1;\n\t\tsplit->no = x - n;\n\t\tadd_newnode_tail(&yama_a, split);\n\t\thead->start = split->end + 1;\n\t\thead->no -= split->no;\n\t}\n\t\n\t/* B */\n\t\n\tn = 0;\n\twhile (1){\n\t\tif (n + head->no > y){\n\t\t\tbreak;\n\t\t}\n\t\tn += head->no;\n\n\t\tnode = head;\n\t\thead = head->next;\n\n\t\tadd_newnode_tail(&yama_b, node);\n\t}\n\t\n\tif (n < y){\n\t\tsplit = (NODE *)malloc(sizeof(NODE));\n\t\tsplit->start = head->start;\n\t\tsplit->end = split->start + x - n - 1;\n\t\tsplit->no = x - n;\n\t\tadd_newnode_tail(&yama_b, split);\n\t\thead->start = split->end + 1;\n\t\thead->no -= split->no;\n\t}\n\n\t/* C */\n\t\n\tif (head != NULL){\n\t\tnode = head;\n\t\tadd_newnode_tail(&yama_c, node);\n\t\twhile (node->next != NULL){\n\t\t\tadd_newnode_tail(&yama_c, node);\n\t\t\tnode = node->next;\n\t\t}\n\t}\n\t\n\t/* join */\n\t\n\tif (yama_a != NULL){\n\t\tnode = yama_a;\n\t\tadd_newnode_tail(&head, node);\n\t\twhile (node->next != NULL){\n\t\t\tadd_newnode_tail(&head, node);\n\t\t\tnode = node->next;\n\t\t}\n\t}\n\tif (yama_b != NULL){\n\t\tnode = yama_b;\n\t\tadd_newnode_tail(&head, node);\n\t\twhile (node->next != NULL){\n\t\t\tadd_newnode_tail(&head, node);\n\t\t\tnode = node->next;\n\t\t}\n\t}\n\tif (yama_c != NULL){\n\t\tnode = yama_c;\n\t\tadd_newnode_tail(&head, node);\n\t\twhile (node->next != NULL){\n\t\t\tadd_newnode_tail(&head, node);\n\t\t\tnode = node->next;\n\t\t}\n\t}\n}\n\n\t\t\n\t\t\nvoid add_newnode_tail(NODE **yama, NODE *newnode)\n{\n\tNODE *node;\n\t\n\tnode = *yama;\n\t\n\tif (node == NULL){\n\t\t*yama = newnode;\n\t}\n\telse {\n\t\twhile (node->next != NULL){\n\t\t\tnode = node->next;\n\t\t}\n\t\t\n\t\tnode->next = newnode;\n\t}\n\tnewnode->next = NULL;\n}"
  },
  {
    "language": "C",
    "code": "#include <stdio.h>\n#include <stdlib.h>\n//Impossibly large number\n#define ILN 1000000002\n\n\ntypedef struct tag_node{\n\tint num;\n\tstruct tag_node *next_series;\n\tstruct tag_node *next_one;\n}NODE;\n\nNODE *createNode(int i);\nNODE *retNode(NODE *START,int i);\nvoid shuffle(int x,int y,NODE *HEAD,NODE *TAIL,int n);\nint countCard(NODE *P,int p,int q,int r);\nvoid dbgPrint(NODE *P);\nvoid freeNode(NODE *P);\n\nint main(){\n\tint n,m;\n\tint p,q,r;\n\tint x,y;\n\tNODE *HEAD,*TAIL,*Pnode;\n\tint i;\n\tint ans;\n\n\twhile(1){\n\t\tscanf(\"%d\\n\",&n);\n\t\tif(!n)break;\n\t\tscanf(\"%d\\n\",&m);\n\t\tscanf(\"%d %d %d\\n\",&p,&q,&r);\n\n\t\tHEAD=createNode(0);\n\t\tTAIL=createNode(ILN);\n\n\t\tPnode=createNode(1);\n\t\tHEAD->next_one=Pnode;\n\t\tPnode=createNode(n);\n\t\tHEAD->next_one->next_series=Pnode;\n\t\tPnode->next_one=TAIL;\n\t\t\n//dbgPrint(HEAD);\t\n\t\tfor(i=0;i<m;i++){\n\t\t\tscanf(\"%d %d\\n\",&x,&y);\n\t\t\tshuffle(x,y,HEAD,TAIL,n);\n//dbgPrint(HEAD);\t\n\t\t}\n//puts(\"shuffle\");\t\t\n\t\tans=countCard(HEAD,p,q,r);\n\n\t\tprintf(\"%d\\n\",ans);\n\t\tfreeNode(HEAD);\n\n\t}\n\treturn 0;\n}\n\n\nNODE *createNode(int i){\n\tNODE *P;\n\tP=(NODE *)malloc(sizeof(NODE));\n\tif(!P){printf(\"malloc error\");exit(1);}\n\tP->num=i;\n\tP->next_series=NULL;\n\tP->next_one=NULL;\n\t\n\treturn P;\n}\n\nvoid dbgPrint(NODE *P){\n\tprintf(P->num==ILN?\"E\":\"%d\",P->num);\n\tif(P->next_series!=NULL){printf(\"=>\");dbgPrint(P->next_series);}\n\tif(P->next_one!=NULL){printf(\"->\");dbgPrint(P->next_one);}\n\tif(P->next_series==NULL && P->next_one==NULL )printf(\"-*\\n\");\n\treturn;\n}\n\nvoid freeNode(NODE *P){\n\tif(P->next_series!=NULL)freeNode(P->next_series);\n\tif(P->next_one!=NULL )free(P->next_one);\n\tif(P->next_series==NULL && P->next_one==NULL )free(P);\n}\n\nNODE *retNode(NODE *START,int i){\n\t// return i-th pointer from START;\n\t//  if not exists :add Node & connect next_one(->)\n\t//    (a) 0->1=>9->ILN\t5th?\n\t//        0->1=>5->6=>9->ILN-*\treturn ( 5-> )\n\t//    (b) 0->1=>9->ILN\t8th?\n\t//        0->1=>8->9->ILN-*\treturn ( 8-> )\n\t//    (c) 0->1=>9->ILN\t1st?\n\t//        0->1->2=>9->ILN-*\treturn ( 1-> )\n\n\tNODE *P,*Q;\n\tint d;\n\n\tP=START;\n\twhile(1){\n\t\tif(i==0){//(c)\n\t\t\tif(P->next_series==NULL)return P;\n\t\t\tQ=createNode(P->num+1);\n\t\t\tQ->next_series=P->next_series;\n\t\t\tP->next_series=NULL;\n\t\t\tP->next_one=Q;\n\t\t\treturn P;\n\t\t}\n\t\tif(P->num==ILN)return P;\n\t\tif(P->next_one!=NULL){\n\t\t\ti--;\n\t\t\tP=P->next_one;\n\t\t}else if(P->next_series!=NULL){\n\t\t\td=P->next_series->num - P->num;\n\t\t\tif(i>=d){\n\t\t\t\ti=i-d;\n\t\t\t\tP=P->next_series;\n\t\t\t}else if(i==d-1){ //case(b)\n\t\t\t\tQ=createNode(P->num+i);\n\t\t\t\tQ->next_one=P->next_series;\n\t\t\t\tP->next_series=Q;\n\t\t\t\treturn Q;\n\t\t\t}else if(i<d-1){ //case(a)\n\t\t\t\tQ=createNode(P->num+i+1);\n\t\t\t\tQ->next_series=P->next_series;\n\t\t\t\tP->next_series=Q;\n\t\t\t\tQ=createNode(P->num+i);\n\t\t\t\tQ->next_one=P->next_series;\n\t\t\t\tP->next_series=Q;\n\t\t\t\t//return retNode(P,0);\n\t\t\t\treturn Q;\n\t\t\t}\n\t\t}\n\t}\n}\n\nvoid shuffle(int x,int y,NODE *HEAD,NODE *TAIL,int n){\n\n\tNODE *Px,*Py,*Pend;\n\tNODE *Ptmp;\n\t\n\tPx=retNode(HEAD,x);\n\tPy=retNode(HEAD,y);\n\tPend=retNode(HEAD,n);\n\t\n\tPtmp=HEAD->next_one;//bak\n\tHEAD->next_one=Py->next_one;\n\tPend->next_one=Px->next_one;\n\tPy->next_one=Ptmp;\n\tPx->next_one=TAIL;\n\treturn;\n}\n\n\nint countCard(NODE *START,int p,int q,int r){\n//printf(\"p=%d,q=%d,r=%d\\t\",p,q,r);dbgPrint(P);\t\n\n\tstatic int cnt;\n\tNODE *Pp,*Pq,*P;\n\tint d,p0,q0;\n\n\tPp=retNode(START,p);\n\tPq=retNode(START,q);\n\n\tP=Pp;\n\tcnt=0;\n\twhile(1){\n\t\tif(P->next_one!=NULL){\n\t\t\tif(P->num<=r)cnt++;\n\t\t\tif(P==Pq)return cnt;\n\t\t\tP=P->next_one;\n\t\t}else if(P->next_series!=NULL){\n\t\t\tp0=P->num;\n\t\t\tq0=P->next_series->num;\n\t\t\td=q0-p0;\n\t\t\tif(r<p0){cnt=cnt;\n\t\t\t}else if(q0<=r){cnt+=d;\n\t\t\t}else if(p0<=r && r<q0){cnt+=r-p0+1;\n\t\t\t}\n\t\t\tif(P==Pq)return cnt;\n\t\t\tP=P->next_series;\n\t\t}else{return cnt;\n\t\t}\n\t}\n}"
  },
  {
    "language": "C",
    "code": "#include <stdio.h>\n#include <stdlib.h>\n//Impossibly large number\n#define ILN 1000000002\n\n\ntypedef struct tag_node{\n\tint num;\n\tstruct tag_node *next_series;\n\tstruct tag_node *next_one;\n}NODE;\n\nNODE *createNode(int i);\nNODE *retNode(NODE *START,int i);\nvoid shuffle(int x,int y,NODE *HEAD,NODE *TAIL,int n);\nint countCard(NODE *P,int p,int q,int r);\nvoid dbgPrint(NODE *P);\nvoid freeNode(NODE *P);\n\nint main(){\n\tint n,m;\n\tint p,q,r;\n\tint x,y;\n\tNODE *HEAD,*TAIL,*Pnode;\n\tint i;\n\tint ans;\n\n\twhile(1){\n\t\tscanf(\"%d\\n\",&n);\n\t\tif(!n)break;\n\t\tscanf(\"%d\\n\",&m);\n\t\tscanf(\"%d %d %d\\n\",&p,&q,&r);\n\n\t\tHEAD=createNode(0);\n\t\tTAIL=createNode(ILN);\n\n\t\tPnode=createNode(1);\n\t\tHEAD->next_one=Pnode;\n\t\tPnode=createNode(n);\n\t\tHEAD->next_one->next_series=Pnode;\n\t\tPnode->next_one=TAIL;\n\t\t\n//dbgPrint(HEAD);\t\n\t\tfor(i=0;i<m;i++){\n\t\t\tscanf(\"%d %d\\n\",&x,&y);\n\t\t\tshuffle(x,y,HEAD,TAIL,n);\n//dbgPrint(HEAD);\t\n\t\t}\n\t\t\n\t\tans=countCard(HEAD,p,q,r);\n\n\t\tprintf(\"%d\\n\",ans);\n\t\tfreeNode(HEAD);\n\n\t}\n\treturn 0;\n}\n\n\nNODE *createNode(int i){\n\tNODE *P;\n\tP=(NODE *)malloc(sizeof(NODE));\n\tif(!P){printf(\"malloc error\");exit(1);}\n\tP->num=i;\n\tP->next_series=NULL;\n\tP->next_one=NULL;\n\t\n\treturn P;\n}\n\nvoid dbgPrint(NODE *P){\n\tprintf(P->num==ILN?\"E\":\"%d\",P->num);\n\tif(P->next_series!=NULL){printf(\"=>\");dbgPrint(P->next_series);}\n\tif(P->next_one!=NULL){printf(\"->\");dbgPrint(P->next_one);}\n\tif(P->next_series==NULL && P->next_one==NULL )printf(\"-*\\n\");\n\treturn;\n}\n\nvoid freeNode(NODE *P){\n\tif(P->next_series!=NULL)freeNode(P->next_series);\n\tif(P->next_one!=NULL )free(P->next_one);\n\tif(P->next_series==NULL && P->next_one==NULL )free(P);\n}\n\nNODE *retNode(NODE *START,int i){\n\t// return i-th pointer from START;\n\t//  if not exists :add Node & connect next_one(->)\n\t//    (a) 0->1=>9->ILN\t5th?\n\t//        0->1=>5->6=>9->ILN-*\treturn ( 5-> )\n\t//    (b) 0->1=>9->ILN\t8th?\n\t//        0->1=>8->9->ILN-*\treturn ( 8-> )\n\n\tNODE *P;\n\tint d;\n\tif(i==0){\n\t\tif(START->next_series==NULL)return START;\n\t\tP=createNode(START->num+1);\n\t\tP->next_series=START->next_series;\n\t\tSTART->next_series=NULL;\n\t\tSTART->next_one=P;\n\t\treturn START;\n\t}\n\tif(START->num==ILN)return START;\n\tif(START->next_one!=NULL){\n\t\treturn retNode(START->next_one,i-1);\n\t}\n\tif(START->next_series!=NULL){\n\t\td=START->next_series->num - START->num;\n\t\tif(i>=d){\n\t\t\treturn retNode(START->next_series,i-d);\n\t\t}else if(i==d-1){ //case(b)\n\t\t\t\tP=createNode(START->num+i);\n\t\t\t\tP->next_one=START->next_series;\n\t\t\t\tSTART->next_series=P;\n\t\t\t\treturn retNode(P,0);\n\t\t}else if(i<d-1){ //case(a)\n\t\t\t\tP=createNode(START->num+i+1);\n\t\t\t\tP->next_series=START->next_series;\n\t\t\t\tSTART->next_series=P;\n\t\t\t\tP=createNode(START->num+i);\n\t\t\t\tP->next_one=START->next_series;\n\t\t\t\tSTART->next_series=P;\n\t\t\t\treturn retNode(P,0);\n\t\t\t}\n\t\t}\n\t}\n\treturn START;\n}\n\nvoid shuffle(int x,int y,NODE *HEAD,NODE *TAIL,int n){\n\n\tNODE *Px,*Py,*Pend;\n\tNODE *Ptmp;\n\t\n\tPx=retNode(HEAD,x);\n\tPy=retNode(HEAD,y);\n\tPend=retNode(HEAD,n);\n\t\n\tPtmp=HEAD->next_one;//bak\n\tHEAD->next_one=Py->next_one;\n\tPend->next_one=Px->next_one;\n\tPy->next_one=Ptmp;\n\tPx->next_one=TAIL;\n\treturn;\n}\n\n\nint countCard(NODE *P,int p,int q,int r){\n//printf(\"p=%d,q=%d,r=%d\\t\",p,q,r);dbgPrint(P);\t\n\n\tstatic int cnt;\n\tNODE *Pp,*Pq;\n\tint d,p0,q0;\n\tif(P->num==0){\n\t\tcnt=0;\n\t\tPp=retNode(P,p);\n\t\tPq=retNode(P,q);\n\t\tcountCard(Pp,0,q-p,r);\n\t}\n\t\n\tif(p==0){\n\t\tif(q==0){\n\t\t\tif(P->num<=r)cnt++;\n\t\t\treturn cnt;\n\t\t}\n\t\tif(P->next_one!=NULL){\n\t\t\tif(P->num<=r)cnt++;\n\t\t\tcountCard(P->next_one,0,q-1,r);\n\t\t}\n\t\tif(P->next_series!=NULL){\n\t\t\tp0=P->num;\n\t\t\tq0=P->next_series->num;\n\t\t\td=q0-p0;\n\t\t\tif(r<p0){cnt=cnt;\n\t\t\t}else if(q0<=r){cnt+=d;\n\t\t\t}else if(p0<=r && r<q0){cnt+=r-p0+1;}\n\t\t\tcountCard(P->next_series,0,q-d,r);\n\t\t}\n\t}\n\treturn cnt;\n}"
  },
  {
    "language": "C",
    "code": "#include <stdio.h>\n#include <stdlib.h>\n//Impossibly large number\n#define ILN 1000000002\n\n\ntypedef struct tag_node{\n\tint num;\n\tstruct tag_node *next_series;\n\tstruct tag_node *next_one;\n}NODE;\n\nNODE *createNode(int i);\nNODE *retNode(NODE *START,int i);\nvoid shuffle(int x,int y,NODE *HEAD,NODE *TAIL,int n);\nint countCard(NODE *P,int p,int q,int r);\nvoid dbgPrint(NODE *P);\nvoid freeNode(NODE *P);\n\nint main(){\n\tint n,m;\n\tint p,q,r;\n\tint x,y;\n\tNODE *HEAD,*TAIL,*Pnode;\n\tint i;\n\tint ans;\n\n\twhile(1){\n\t\tscanf(\"%d\\n\",&n);\n\t\tif(!n)break;\n\t\tscanf(\"%d\\n\",&m);\n\t\tscanf(\"%d %d %d\\n\",&p,&q,&r);\n\n\t\tHEAD=createNode(0);\n\t\tTAIL=createNode(ILN);\n\n\t\tPnode=createNode(1);\n\t\tHEAD->next_one=Pnode;\n\t\tPnode=createNode(n);\n\t\tHEAD->next_one->next_series=Pnode;\n\t\tPnode->next_one=TAIL;\n\t\t\n//dbgPrint(HEAD);\t\n\t\tfor(i=0;i<m;i++){\n\t\t\tscanf(\"%d %d\\n\",&x,&y);\n\t\t\tshuffle(x,y,HEAD,TAIL,n);\n//dbgPrint(HEAD);\t\n\t\t}\n\t\t\n\t\tans=countCard(HEAD,p,q,r);\n\n\t\tprintf(\"%d\\n\",ans);\n\t\tfreeNode(HEAD);\n\n\t}\n\treturn 0;\n}\n\n\nNODE *createNode(int i){\n\tNODE *P;\n\tP=(NODE *)malloc(sizeof(NODE));\n\tif(!P){printf(\"malloc error\");exit(1);}\n\tP->num=i;\n\tP->next_series=NULL;\n\tP->next_one=NULL;\n\t\n\treturn P;\n}\n\nvoid dbgPrint(NODE *P){\n\tprintf(P->num==ILN?\"E\":\"%d\",P->num);\n\tif(P->next_series!=NULL){printf(\"=>\");dbgPrint(P->next_series);}\n\tif(P->next_one!=NULL){printf(\"->\");dbgPrint(P->next_one);}\n\tif(P->next_series==NULL && P->next_one==NULL )printf(\"-*\\n\");\n\treturn;\n}\n\nvoid freeNode(NODE *P){\n\tif(P->next_series!=NULL)freeNode(P->next_series);\n\tif(P->next_one!=NULL )free(P->next_one);\n\tif(P->next_series==NULL && P->next_one==NULL )free(P);\n}\n\nNODE *retNode(NODE *START,int i){\n\t// return i-th pointer from START;\n\t//  if not exists :add Node & connect next_one(->)\n\t//    (a) 0->1=>9->ILN\t5th?\n\t//        0->1=>5->6=>9->ILN-*\treturn ( 5-> )\n\t//    (b) 0->1=>9->ILN\t8th?\n\t//        0->1=>8->9->ILN-*\treturn ( 8-> )\n\n\tNODE *P;\n\tint d;\n\tif(i==0){\n\t\tif(START->next_series==NULL)return START;\n\t\tP=createNode(START->num+1);\n\t\tP->next_series=START->next_series;\n\t\tSTART->next_series=NULL;\n\t\tSTART->next_one=P;\n\t\treturn START;\n\t}\n\tif(START->num==ILN)return START;\n\tif(START->next_one!=NULL){\n\t\treturn retNode(START->next_one,i-1);\n\t}\n\tif(START->next_series!=NULL){\n\t\td=START->next_series->num - START->num;\n\t\tif(i>=d){\n\t\t\treturn retNode(START->next_series,i-d);\n\t\t}else if(i==d-1){ //case(b)\n\t\t\t\tP=createNode(START->num+i);\n\t\t\t\tP->next_one=START->next_series;\n\t\t\t\tSTART->next_series=P;\n\t\t\t\t//return retNode(P,0);\n\t\t\t\treturn P;\n\t\t}else if(i<d-1){ //case(a)\n\t\t\t\tP=createNode(START->num+i+1);\n\t\t\t\tP->next_series=START->next_series;\n\t\t\t\tSTART->next_series=P;\n\t\t\t\tP=createNode(START->num+i);\n\t\t\t\tP->next_one=START->next_series;\n\t\t\t\tSTART->next_series=P;\n\t\t\t\t//return retNode(P,0);\n\t\t\t\treturn P;\n\t\t}\n\t}\n\treturn START;\n}\n\nvoid shuffle(int x,int y,NODE *HEAD,NODE *TAIL,int n){\n\n\tNODE *Px,*Py,*Pend;\n\tNODE *Ptmp;\n\t\n\tPx=retNode(HEAD,x);\n\tPy=retNode(HEAD,y);\n\tPend=retNode(HEAD,n);\n\t\n\tPtmp=HEAD->next_one;//bak\n\tHEAD->next_one=Py->next_one;\n\tPend->next_one=Px->next_one;\n\tPy->next_one=Ptmp;\n\tPx->next_one=TAIL;\n\treturn;\n}\n\n\nint countCard(NODE *P,int p,int q,int r){\n//printf(\"p=%d,q=%d,r=%d\\t\",p,q,r);dbgPrint(P);\t\n\n\tstatic int cnt;\n\tNODE *Pp,*Pq;\n\tint d,p0,q0;\n\tif(P->num==0){\n\t\tcnt=0;\n\t\tPp=retNode(P,p);\n\t\tPq=retNode(P,q);\n\t\tcountCard(Pp,0,q-p,r);\n\t}\n\t\n\tif(p==0){\n\t\tif(q==0){\n\t\t\tif(P->num<=r)cnt++;\n\t\t\treturn cnt;\n\t\t}\n\t\tif(P->next_one!=NULL){\n\t\t\tif(P->num<=r)cnt++;\n\t\t\tcountCard(P->next_one,0,q-1,r);\n\t\t}\n\t\tif(P->next_series!=NULL){\n\t\t\tp0=P->num;\n\t\t\tq0=P->next_series->num;\n\t\t\td=q0-p0;\n\t\t\tif(r<p0){cnt=cnt;\n\t\t\t}else if(q0<=r){cnt+=d;\n\t\t\t}else if(p0<=r && r<q0){cnt+=r-p0+1;}\n\t\t\tcountCard(P->next_series,0,q-d,r);\n\t\t}\n\t}\n\treturn cnt;\n}"
  },
  {
    "language": "C",
    "code": "#include<stdio.h>\n#include<string.h>\n#define Max(x,y) ((x>y)?x:y)\ntypedef struct card{\n\tint s,t,n;\n}card;\ncard x[10500],y[10500];\nint main(){\n\tint i,j,n,m,p,q,r,a,b,c,d;//(a,b)cut c,d:absolute point\n\tint xn,yn,e,f,g;//f:flag g:\n\twhile(1){\n\t\tscanf(\"%d\",&n);\n\t\tif(n==0)break;\n\t\tscanf(\"%d%d%d%d\",&m,&p,&q,&r);\n\t\txn=1;\n\t\tx[0]=(card){1,n+1,n};\n\t\twhile(m--){\n\t\t\tscanf(\"%d%d\",&a,&b);\n\t\t\td=n+1;c=d-x[xn-1].n;\n\t\t\tf=0;yn=0;\n\t\t\t//for(i=0;i<xn;i++)printf(\"(%d-%d)\",x[i].s,x[i].t);\n\t\t\t//printf(\"\\n\");\n\t\t\tfor(i=xn-1;i>=0;){\n\t\t\t\t//printf(\"c:%d  d:%d\\n\",c,d);\n\t\t\t\tif(f==0){\n\t\t\t\t\tif(c==b+1){\n\t\t\t\t\t\tfor(j=i;j<xn;j++)y[yn++]=x[j];\n\t\t\t\t\t\tf=1;g=i-1;i--;\n\t\t\t\t\t}else if(c<b+1 && b+1<d){\n\t\t\t\t\t\ty[yn++]=(card){x[i].s+b+1-c,x[i].t,x[i].t-x[i].s-b-1+c};\n\t\t\t\t\t\tfor(j=i+1;j<xn;j++)y[yn++]=x[j];\n\t\t\t\t\t\tx[i]=(card){x[i].s,x[i].s+b+1-c,b+1-c};\n\t\t\t\t\t\t//for(j=0;j<=i;j++)printf(\"(%d-%d)\",x[j].s,x[j].t);\n\t\t\t\t\t\t//printf(\"\\n\");\n\t\t\t\t\t\tf=1;g=i;d=c+x[i].n;\n\t\t\t\t\t\tcontinue;\n\t\t\t\t\t}else i--;\n\t\t\t\t}else{\n\t\t\t\t\tif(c==a+1){\n\t\t\t\t\t\tfor(j=i;j<=g;j++)y[yn++]=x[j];\n\t\t\t\t\t\tfor(j=0;j<i;j++)y[yn++]=x[j];\n\t\t\t\t\t\tbreak;\n\t\t\t\t\t}else if(c<a+1 && a+1<d){\n\t\t\t\t\t\ty[yn++]=(card){x[i].s+a+1-c,x[i].t,x[i].t-x[i].s-a-1+c};\n\t\t\t\t\t\tfor(j=i+1;j<=g;j++)y[yn++]=x[j];\n\t\t\t\t\t\tx[i]=(card){x[i].s,x[i].s+a+1-c,a+1-c};\n\t\t\t\t\t\tfor(j=0;j<=i;j++)y[yn++]=x[j];\n\t\t\t\t\t\tbreak;\n\t\t\t\t\t}else i--;\n\t\t\t\t}\n\t\t\t\td=c;\n\t\t\t\tc=d-x[i].n;\n\t\t\t}\n\t\t\t//for(i=0;i<yn;i++)printf(\"(%d-%d)\",y[i].s,y[i].t);\n\t\t\t//printf(\"\\n\");\n\t\t\tmemcpy(x,y,sizeof(card)*yn);\n\t\t\txn=yn;\n\t\t}\n\t\t//printf(\"\\n\");\n\t\t//for(i=0;i<xn;i++)printf(\"(%d - %d)\",x[i].s,x[i].t);\n\t\t//printf(\"\\n\\n\");\n\t\ta=0;b=1;\n\t\tfor(i=0;i<xn;i++){\n\t\t\t//printf(\"%d \",b);\n\t\t\tif(p<b+x[i].n && b<=q){\n\t\t\t\tc=x[i].s;\n\t\t\t\td=x[i].t;\n\t\t\t\tif(b<p)c+=p-b;\n\t\t\t\tif(b+x[i].n>q)d+=q-b-x[i].n+1;\n\t\t\t\tif(d>r)d=r+1;\n\t\t\t\tif(c>r)c=d+1;\n\t\t\t\t//printf(\"%d %d\",c,d);\n\t\t\t\t\n\t\t\t\ta+=Max(0,d-c);\n\t\t\t}\n\t\t\t//printf(\"\\n\");\n\t\t\tb+=x[i].n;\n\t\t}\n\t\tprintf(\"%d\\n\",a);\n\t}\n\treturn 0;\n}"
  },
  {
    "language": "C",
    "code": "#include <stdio.h>\n#include <stdlib.h>\n//Impossibly large number\n#define ILN 1000000002\n\n\ntypedef struct tag_node{\n\tint num;\n\tstruct tag_node *next_series;\n\tstruct tag_node *next_one;\n}NODE;\n\nNODE *createNode(int i);\nNODE *retNode(NODE *START,int i);\nvoid shuffle(int x,int y,NODE *HEAD,NODE *TAIL,int n);\nint countCard(NODE *P,int p,int q,int r);\nvoid dbgPrint(NODE *P);\nvoid freeNode(NODE *P);\n\nint main(){\n\tint n,m;\n\tint p,q,r;\n\tint x,y;\n\tNODE *HEAD,*TAIL,*Pnode;\n\tint i;\n\tint ans;\n\n\twhile(1){\n\t\tscanf(\"%d\\n\",&n);\n\t\tif(!n)break;\n\t\tscanf(\"%d\\n\",&m);\n\t\tscanf(\"%d %d %d\\n\",&p,&q,&r);\n\n\t\tHEAD=createNode(0);\n\t\tTAIL=createNode(ILN);\n\n\t\tPnode=createNode(1);\n\t\tHEAD->next_one=Pnode;\n\t\tPnode=createNode(n);\n\t\tHEAD->next_one->next_series=Pnode;\n\t\tPnode->next_one=TAIL;\n\t\t\n//dbgPrint(HEAD);\t\n\t\tfor(i=0;i<m;i++){\n\t\t\tscanf(\"%d %d\\n\",&x,&y);\n\t\t\tshuffle(x,y,HEAD,TAIL,n);\n//dbgPrint(HEAD);\t\n\t\t}\n\t\t\n\t\tans=countCard(HEAD,p,q,r);\n\n\t\tprintf(\"%d\\n\",ans);\n\t\tfreeNode(HEAD);\n\n\t}\n\treturn 0;\n}\n\n\nNODE *createNode(int i){\n\tNODE *P;\n\tP=(NODE *)malloc(sizeof(NODE));\n\tif(!P){printf(\"malloc error\");exit(1);}\n\tP->num=i;\n\tP->next_series=NULL;\n\tP->next_one=NULL;\n\t\n\treturn P;\n}\n\nvoid dbgPrint(NODE *P){\n\tprintf(P->num==ILN?\"E\":\"%d\",P->num);\n\tif(P->next_series!=NULL){printf(\"=>\");dbgPrint(P->next_series);}\n\tif(P->next_one!=NULL){printf(\"->\");dbgPrint(P->next_one);}\n\tif(P->next_series==NULL && P->next_one==NULL )printf(\"-*\\n\");\n\treturn;\n}\n\nvoid freeNode(NODE *P){\n\tif(P->next_series!=NULL)freeNode(P->next_series);\n\tif(P->next_one!=NULL )free(P->next_one);\n\tif(P->next_series==NULL && P->next_one==NULL )free(P);\n}\n\nNODE *retNode(NODE *START,int i){\n\t// return i-th pointer from START;\n\t//  if not exists :add Node & connect next_one(->)\n\t//    (a) 0->1=>9->ILN\t5th?\n\t//        0->1=>5->6=>9->ILN-*\treturn ( 5-> )\n\t//    (b) 0->1=>9->ILN\t8th?\n\t//        0->1=>8->9->ILN-*\treturn ( 8-> )\n\n\tNODE *P;\n\tint d;\n\tif(i==0){\n\t\tif(START->next_series==NULL)return START;\n\t\tP=createNode(START->num+1);\n\t\tP->next_series=START->next_series;\n\t\tSTART->next_series=NULL;\n\t\tSTART->next_one=P;\n\t\treturn START;\n\t}\n\tif(START->num==ILN)return START;\n\tif(START->next_one!=NULL){\n\t\treturn retNode(START->next_one,i-1);\n\t}\n\tif(START->next_series!=NULL){\n\t\td=START->next_series->num - START->num;\n\t\tif(i>=d){\n\t\t\treturn retNode(START->next_series,i-d);\n\t\t}else if(i==d-1){ //case(b)\n\t\t\t\tP=createNode(START->num+i);\n\t\t\t\tP->next_one=START->next_series;\n\t\t\t\tSTART->next_series=P;\n\t\t\t\treturn retNode(P,0);\n\t\t}else if(i<d-1){ //case(a)\n\t\t\t\tP=createNode(START->num+i+1);\n\t\t\t\tP->next_series=START->next_series;\n\t\t\t\tSTART->next_series=P;\n\t\t\t\tP=createNode(START->num+i);\n\t\t\t\tP->next_one=START->next_series;\n\t\t\t\tSTART->next_series=P;\n\t\t\t\treturn retNode(P,0);\n\t\t}\n\t}\n\treturn START;\n}\n\nvoid shuffle(int x,int y,NODE *HEAD,NODE *TAIL,int n){\n\n\tNODE *Px,*Py,*Pend;\n\tNODE *Ptmp;\n\t\n\tPx=retNode(HEAD,x);\n\tPy=retNode(HEAD,y);\n\tPend=retNode(HEAD,n);\n\t\n\tPtmp=HEAD->next_one;//bak\n\tHEAD->next_one=Py->next_one;\n\tPend->next_one=Px->next_one;\n\tPy->next_one=Ptmp;\n\tPx->next_one=TAIL;\n\treturn;\n}\n\n\nint countCard(NODE *P,int p,int q,int r){\n//printf(\"p=%d,q=%d,r=%d\\t\",p,q,r);dbgPrint(P);\t\n\n\tstatic int cnt;\n\tNODE *Pp,*Pq;\n\tint d,p0,q0;\n\tif(P->num==0){\n\t\tcnt=0;\n\t\tPp=retNode(P,p);\n\t\tPq=retNode(P,q);\n\t\tcountCard(Pp,0,q-p,r);\n\t}\n\t\n\tif(p==0){\n\t\tif(q==0){\n\t\t\tif(P->num<=r)cnt++;\n\t\t\treturn cnt;\n\t\t}\n\t\tif(P->next_one!=NULL){\n\t\t\tif(P->num<=r)cnt++;\n\t\t\tcountCard(P->next_one,0,q-1,r);\n\t\t}\n\t\tif(P->next_series!=NULL){\n\t\t\tp0=P->num;\n\t\t\tq0=P->next_series->num;\n\t\t\td=q0-p0;\n\t\t\tif(r<p0){cnt=cnt;\n\t\t\t}else if(q0<=r){cnt+=d;\n\t\t\t}else if(p0<=r && r<q0){cnt+=r-p0+1;}\n\t\t\tcountCard(P->next_series,0,q-d,r);\n\t\t}\n\t}\n\treturn cnt;\n}"
  },
  {
    "language": "C",
    "code": "v[2]['&N'],l,n,m,a,c,*i,*s;D(x){c=0;for(i=v+a;c<x;i+=2)c+=i[1];memmove(i+2,i,(v[a]+l-i)*4);l+=2;*i=i[-2]+(i[-1]-=i[1]=c-x);return i;}C(d,s,e){c=memcpy(d,s,e-s)+e-s;}main(p,q,r,x,y){for(;scanf(\"%d%d%d%d%d\",&n,&m,&p,&q,&r)*n;printf(\"%d\\n\",c)){v[a=**v=0][1]=n;for(l=2;m--;a^=1)scanf(\"%d%d\",&x,&y),C(C(C(v[a^1],y,v[a]+l),x,y=D(y)),v[a],x=D(x));s=D(p-1);i=D(q);for(c=0;s-i;s+=2)c+=*s+s[1]>r?*s<r?r-*s:0:s[1];}}"
  },
  {
    "language": "C",
    "code": "#include <stdio.h>\n\nint main(){\n  int i, j, n, m, p, q, r;\n\n  while(1){\n    scanf(\"%d\",&n);\n    if(n == 0) break;\n    scanf(\"%d\",&m);\n    scanf(\"%d%d%d\",&p,&q,&r);\n    int d[n], a[n], b[n], c[n], x[m][2], count = 0;\n    for(i = 0 ; i < n ; i++){\n      d[i] = i + 1;\n    }\n    for(i = 0 ; i < m ; i++){\n      for(j = 0 ; j < 2 ; j++){\n\tscanf(\"%d\",&x[i][j]);\n      }\n    }\n    for(j = 0 ; j < m ; j++){\n      for(i = 0 ; i < x[j][0] ; i++){\n\ta[i] = d[i];\n      }\n      for(i = 0 ; i < x[j][1]-x[j][0] ; i++){\n\tb[i] = d[x[j][0]];\n      }\n      for(i = 0 ; i < n-x[j][1] ; i++){\n\tc[i] = d[x[j][1]-x[j][0]];\n      }\n      for(i = 0 ; i < n-x[j][1] ; i++){\n\td[i] = c[i];\n      }\n      for(i = 0 ; i < x[j][1]-x[j][0] ; i++){\n\td[n-x[j][1]] = b[i];\n      }\n      for(i = 0 ; i < x[j][0] ; i++){\n\td[x[j][1]-x[j][0]] = a[i];\n      }\n    }\n    for(i = 0 ; i < q-p+1 ; i++){\n      if(d[i+p] <= r)\n\tcount++;\n    }\n    printf(\"%d\\n\",count);\n  }\n\n  return 0;\n\n}"
  },
  {
    "language": "C",
    "code": "#include <stdio.h>\n\nint main(){\n  int i, j, k, l, n, m, p, q, r;\n\n  while(1){\n    scanf(\"%d\",&n);\n    if(n == 0) break;\n    scanf(\"%d\",&m);\n    scanf(\"%d%d%d\",&p,&q,&r);\n    int d[n], a[n], b[n], c[n], x[m][2], count = 0;\n    for(i = 0 ; i < n ; i++){\n      d[i] = i + 1;\n    }\n    for(i = 0 ; i < m ; i++){\n      for(j = 0 ; j < 2 ; j++){\n\tscanf(\"%d\",&x[i][j]);\n      }\n    }\n    for(k = 0 ; k < m ; k++){\n      for(i = 0 ; i < x[k][0] ; i++){\n\ta[i] = d[i];\n      }\n      for(j = 0 ; j < x[k][1]-x[k][0] ; j++){\n\tb[j] = d[x[k][0]];\n      }\n      for(l = 0 ; l < n-x[k][1] ; l++){\n\tc[l] = d[x[k][1]-x[k][0]];\n      }\n      for(l = 0 ; l < n-x[k][1] ; l++){\n\td[l] = c[l];\n      }\n      for(j = 0 ; j < x[k][1]-x[k][0] ; j++){\n\td[n-x[k][1]] = b[j];\n      }\n      for(i = 0 ; i < x[k][0] ; i++){\n\td[x[k][1]-x[k][0]] = a[i];\n      }\n    }\n    for(i = 0 ; i < q-p+1 ; i++){\n      if(d[i+p] <= r)\n\tcount++;\n    }\n    printf(\"%d\\n\",count);\n  }\n\n  return 0;\n\n}"
  },
  {
    "language": "C",
    "code": "v[2][' )'],l,n,m,a,c,*i,*s;D(x){c=0;for(i=v+a;c<x;i+=2)c+=i[1];memmove(i+2,i,(v[a]+l-i)*4);l+=2;*i=i[-2]+(i[-1]-=i[1]=c-x);return i;}C(d,s,e){c=memcpy(d,s,e-s)+e-s;}main(p,q,r,x,y){for(;scanf(\"%d%d%d%d%d\",&n,&m,&p,&q,&r)*n;printf(\"%d\\n\",c)){v[a=**v=0][1]=n;for(l=2;m--;a^=1)scanf(\"%d%d\",&x,&y),C(C(C(v[a^1],y,v[a]+l),x,y=D(y)),v[a],x=D(x));s=D(p-1);i=D(q);for(c=0;s-i;s+=2)c+=*s+s[1]>r?*s<r?r-*s:0:s[1];}}"
  },
  {
    "language": "C",
    "code": "// Aizu 0536: Shuffle\n// 2017.10.26 bal4u@uu\n\n#include <stdio.h>\n#include <string.h>\n\ntypedef struct { int x1, x2; } TABA;\nTABA taba[2][10005]; int sz;\nint k1, k2;\n\nint split(int x)\n{\n\tint s, i, k;\n\n\tfor (s = 0, i = 0; ; i++) {\n\t\tk = taba[k1][i].x2 - taba[k1][i].x1 + 1;\n\t\tif (s + k == x) return i;\n\t\tif (s + k > x) break;\n\t\ts += k;\n\t}\n\n// don't using memcpy() for overlap memory copy on Linux \n//\tmemcpy(taba[k1]+i+1, taba[k1]+i, sizeof(TABA)*(sz-i)), sz++;\n\tmemmove(taba[k1]+i+1, taba[k1]+i, sizeof(TABA)*(sz-i)), sz++;\n\n\tx = (x-s)+taba[k1][i].x1-1;\n\ttaba[k1][i].x2 = x, taba[k1][i+1].x1 = x+1;\n\treturn i;\n}\n\nvoid shuffle(int x, int y)\n{\n\tint i, j, s;\n\n\ti = split(x), j = split(y);\n\ts = 0;\n\tmemcpy(taba[k2],   taba[k1]+j+1, sizeof(TABA)*(sz-j-1)); s += sz - j - 1;\n\tmemcpy(taba[k2]+s, taba[k1]+i+1, sizeof(TABA)*(j-i));    s += j-i;\n\tmemcpy(taba[k2]+s, taba[k1],     sizeof(TABA)*(i+1));\n\tk1 = k2, k2 = !k2;\n}\n\nchar buf[130], *pp;\nint getInt(void)\n{\n\tint n = 0;\n\twhile (*pp >= '0') n = (n<<3) + (n<<1) + (*pp++ & 0xf);\n\treturn n;\n}\nint main()\n{\n\tint n, m, p, q, r, x, y;\n\tint i, ans;\n\n\twhile (fgets(pp=buf, 128, stdin) && *buf != '0') {\n\t\tn = getInt();\n\t\tfgets(pp=buf, 128, stdin), m = getInt();\n\t\tfgets(pp=buf, 128, stdin), p = getInt(), pp++, q = getInt(), pp++, r = getInt();\n\t\ttaba[0][0].x1 = 1, taba[0][0].x2 = n, k1 = 0, k2 = 1, sz = 1;\n\t\twhile (m--) {\n\t\t\tfgets(pp=buf, 128, stdin), x = getInt(), pp++, y = getInt();\n\t\t\tshuffle(x, y);\n\t\t}\n\t\tx = 0; if (p > 1) x = split(p-1) + 1;\n\t\ty = split(q);\n\t\tfor (ans = 0, i = x; i <= y; i++) {\n\t\t\tif (taba[k1][i].x1 > r) continue;\n\t\t\tif (taba[k1][i].x2 <= r) ans += taba[k1][i].x2 - taba[k1][i].x1 + 1;\n\t\t\telse \t\t\t         ans += r - taba[k1][i].x1 + 1;\n\t\t}\n\t\tprintf(\"%d\\n\", ans);\n\t}\n\treturn 0;\n}"
  },
  {
    "language": "C",
    "code": "v[2]['~~'],l;\nn,m,a;\nD(x){\n\tint*p,c=0;\n\tfor(p=v[a];c<x;p+=2)\n\t\tc+=p[1];\n\tmemmove(p+2,p,(v[a]+l-p)*4);\n\tl+=2;\n\tp[-1]-=p[1]=c-x;\n\tp[0]=p[-2]+p[-1];\n\treturn p;\n}\nC(d,s,e){\n\treturn memcpy(d,s,e-s)+e-s;\n}\nS(x,y){\n\tint i,j,e;\n\ti=D(x);\n\tj=D(y);\n\te=C(v[a^1],j,v[a]+l);\n\te=C(e,i,j);\n\tC(e,v[a],i);\n\ta^=1;\n}\nmain(p,q,r,x,y,c){\n\tint*i,*e;\n\tfor(;scanf(\"%d%d%d%d%d\",&n,&m,&p,&q,&r)*n;){\n\t\ta=0;\n\t\tv[a][0]=0;\n\t\tv[a][1]=n;\n\t\tl=2;\n\t\tfor(;m--;){\n\t\t\tscanf(\"%d%d\",&x,&y);\n\t\t\tS(x,y);\n\t\t}\n\t\ti=D(p-1);\n\t\te=D(q);\n\t\tfor(c=0;i-e;i+=2)\n\t\t\tc+=i[0]+i[1]<=r?i[1]:i[0]<r?r-i[0]:0;\n\t\tprintf(\"%d \\n\",c);\n\t}\n}"
  },
  {
    "language": "C",
    "code": "v[2]['~~'],l,n,m,a,c,*i,*s;D(x){c=0;for(i=v+a;c<x;i+=2)c+=i[1];memmove(i+2,i,(v[a]+l-i)*4);l+=2;*i=i[-2]+(i[-1]-=i[1]=c-x);return i;}C(d,s,e){c=memcpy(d,s,e-s)+e-s;}main(p,q,r,x,y){for(;scanf(\"%d%d%d%d%d\",&n,&m,&p,&q,&r)*n;printf(\"%d\\n\",c)){v[a=**v=0][1]=n;for(l=2;m--;a^=1)scanf(\"%d%d\",&x,&y),C(C(C(v[a^1],y,v[a]+l),x,y=D(y)),v[a],x=D(x));s=D(p-1);i=D(q);for(c=0;s-i;s+=2)c+=*s+s[1]>r?*s<r?r-*s:0:s[1];}}"
  },
  {
    "language": "C",
    "code": "// Aizu 0536: Shuffle\n// 2017.10.26 bal4u@uu\n\n#include <stdio.h>\n#include <string.h>\n\ntypedef struct { int x1, x2; } TABA;\nTABA taba[2][10005]; int sz;\nint k1, k2;\n\nint split(int x)\n{\n\tint s, i, k;\n\n\tfor (s = 0, i = 0; ; i++) {\n\t\tk = taba[k1][i].x2 - taba[k1][i].x1 + 1;\n\t\tif (s + k == x) return i;\n\t\tif (s + k > x) break;\n\t\ts += k;\n\t}\n\tmemcpy(taba[k1]+i+1, taba[k1]+i, sizeof(TABA)*(sz-i)), sz++;\n\tx = (x-s)+taba[k1][i].x1-1;\n\ttaba[k1][i].x2 = x, taba[k1][i+1].x1 = x+1;\n\treturn i;\n}\n\nvoid shuffle(int x, int y)\n{\n\tint i, j, s;\n\n\ti = split(x), j = split(y);\n\ts = 0;\n\tmemcpy(taba[k2],   taba[k1]+j+1, sizeof(TABA)*(sz-j-1)); s += sz - j - 1;\n\tmemcpy(taba[k2]+s, taba[k1]+i+1, sizeof(TABA)*(j-i));    s += j-i;\n\tmemcpy(taba[k2]+s, taba[k1],     sizeof(TABA)*(i+1));\n\tk1 = k2, k2 = !k2;\n}\n\nint main()\n{\n\tint n, m, p, q, r, x, y;\n\tint i, ans;\n\n\twhile (scanf(\"%d\", &n) && n > 0) {\n\t\tscanf(\"%d%d%d%d\", &m, &p, &q, &r);\n\t\ttaba[0][0].x1 = 1, taba[0][0].x2 = n, k1 = 0, k2 = 1, sz = 1;\n\t\twhile (m-- > 0) {\n\t\t\tscanf(\"%d%d\", &x, &y);\n\t\t\tshuffle(x, y);\n\t\t}\n\t\tx = 0; if (p > 1) x = split(p-1) + 1;\n\t\ty = split(q);\n\t\tfor (ans = 0, i = x; i <= y; i++) {\n\t\t\tif (taba[k1][i].x1 > r) continue;\n\t\t\tif (taba[k1][i].x2 <= r) ans += taba[k1][i].x2 - taba[k1][i].x1 + 1;\n\t\t\telse \t\t\t         ans += r - taba[k1][i].x1 + 1;\n\t\t}\n\t\tprintf(\"%d\\n\", ans);\n\t}\n\treturn 0;\n}"
  },
  {
    "language": "C",
    "code": "#include<stdio.h>\n#include<stdlib.h>\nstruct ml{\n  int a;\n  struct ml *p;\n};\nint main(){\n  int i,j;\n  int m,n,p,q,r,x,y;\n  int sm;\n  struct ml *a,*b,*c,*d,*e,*z;\n  while(scanf(\"%d\",&n)&&n){\n    scanf(\"%d%d%d%d\",&m,&p,&q,&r);\n    z=(struct ml*)malloc((n+1)*sizeof(struct ml));\n    for(i=0;i<n;i++){\n      (z+i)->a=i+1;\n      (z+i)->p=(z+i+1);\n    }\n    a=z;\n    for(i=0;i<m;i++){\n      scanf(\"%d%d\",&x,&y);\n      b=a;\n      for(j=0;j<x-1;j++)\n\tb=b->p;\n      c=b;\n      for(j=0;j<y-x;j++)\n\tc=c->p;\n      d=c;\n      for(j=0;j<n-y;j++)\n\td=d->p;\n      e=a;\n      a=c->p;\n      c->p=e;\n      d->p=b->p;\n    }\n    sm=0;\n    for(i=0;i<p-1;i++)\n      a=a->p;\n    for(i=0;i<q-p+1;i++){\n      if(a->a<=r)\n\tsm++;\n      a=a->p;\n    }\n    free(z);\n    printf(\"%d\\n\",sm);\n  }\n  return 0;\n}"
  },
  {
    "language": "Java",
    "code": "import java.util.Collections;\nimport java.util.Comparator;\nimport java.util.LinkedList;\nimport java.util.List;\nimport java.util.Scanner;\n\n//Shuffle\npublic class Main{\n\t\n\tvoid run(){\n\t\tScanner sc = new Scanner(System.in);\n\t\tlong mask = (1L << 32)-1;\n\t\tComparator<Long> C = new Comparator<Long>() {\n\t\t\tpublic int compare(Long o1, Long o2) {\n\t\t\t\treturn (int) ((o1>>32)-(o2>>32));\n\t\t\t}\n\t\t};\n\t\tfor(;;){\n\t\t\tint n = sc.nextInt();\n\t\t\tif(n==0)break;\n\t\t\tint m = sc.nextInt(), P = sc.nextInt(), Q = sc.nextInt(), R = sc.nextInt();\n\t\t\tList<Long> l = new LinkedList<Long>();\n\t\t\tl.add(((long)P<<32)|Q);\n\t\t\tint[] p = new int[m], q = new int[m];\n\t\t\tfor(int i=0;i<m;i++){\n\t\t\t\tp[i] = sc.nextInt(); q[i] = sc.nextInt();\n\t\t\t}\n\t\t\tfor(int i=m-1;i>=0;i--){\n\t\t\t\tlong t1 = n-q[i], s2 = t1+1, t2 = n-p[i], s3 = n-p[i]+1, y = q[i];\n//\t\t\t\tSystem.out.println(\"s1:\"+s1+\" t1:\"+t1+\" s2:\"+s2+\" t2:\"+t2+\" s3:\"+s3+\" t3:\"+t3);\n//\t\t\t\tlong d = n-q[i]-p[i];\n//\t\t\t\tSystem.out.println(\"Ranges\");\n//\t\t\t\tfor(long x:l){\n//\t\t\t\t\tlong s = x>>32, t = x&mask;\n//\t\t\t\t\tSystem.out.println(s+\",\"+t);\n//\t\t\t\t}\n//\t\t\t\tSystem.out.println(\"end Ranges\");\n\t\t\t\tList<Long> next = new LinkedList<Long>();\n\t\t\t\tfor(int j=0;j<l.size();j++){\n\t\t\t\t\tlong x = l.get(j);\n\t\t\t\t\tlong s = x>>32, t = x&mask;\n//\t\t\t\t\tSystem.out.println(s+\",\"+t);\n\t\t\t\t\tif(t<=t1){\n//\t\t\t\t\t\tSystem.out.println(\"T1\");\n//\t\t\t\t\t\tSystem.out.println((s+y)+\",\"+(t+y));\n\t\t\t\t\t\tnext.add((s+y)<<32 | (t+y));\n\t\t\t\t\t}\n\t\t\t\t\telse if(t<=t2){\n//\t\t\t\t\t\tSystem.out.println(\"T2\");\n\t\t\t\t\t\tif(s<=t1){\n//\t\t\t\t\t\t\tSystem.out.println((s+y)+\",\"+(t1+y));\n\t\t\t\t\t\t\tnext.add((s+y)<<32 | (t1+y));\n\t\t\t\t\t\t\ts = s2;\n\t\t\t\t\t\t}\n//\t\t\t\t\t\tSystem.out.println((s-s2+p[i]+1)+\",\"+(t-s2+p[i]+1));\n\t\t\t\t\t\tnext.add((s-s2+p[i]+1)<<32 | (t-s2+p[i]+1));\n\t\t\t\t\t}\n\t\t\t\t\telse{\n//\t\t\t\t\t\tSystem.out.println(\"T3\");\n\t\t\t\t\t\tif(s<=t1){\n//\t\t\t\t\t\t\tSystem.out.println((s+y)+\",\"+(t1+y));\n\t\t\t\t\t\t\tnext.add((s+y)<<32 | (t1+y));\n\t\t\t\t\t\t\ts = s2;\n\t\t\t\t\t\t}\n\t\t\t\t\t\tif(s<=t2){\n//\t\t\t\t\t\t\tSystem.out.println((s-s2+p[i]+1)+\",\"+(t2-s2+p[i]+1));\n\t\t\t\t\t\t\tnext.add((s-s2+p[i]+1)<<32 | (t2-s2+p[i]+1));\n\t\t\t\t\t\t\ts = s3;\n\t\t\t\t\t\t}\n//\t\t\t\t\t\tSystem.out.println((s-s3+1)+\",\"+(t-s3+1));\n\t\t\t\t\t\tnext.add((s-s3+1)<<32 | (t-s3+1));\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t\tl = next;\n\t\t\t\tCollections.sort(l, C);\n\t\t\t\tfor(int j=0;j+1<l.size();j++){\n\t\t\t\t\tlong x1 = l.get(j), x2 = l.get(j+1);\n\t\t\t\t\tlong t = x1&mask, s = x2>>32;\n\t\t\t\t\tif(t+1==s){\n\t\t\t\t\t\tl.remove(j); l.remove(j);\n\t\t\t\t\t\ts = x1>>32; t = x2&mask;\n\t\t\t\t\t\tl.add(j--, (s<<32)|t);\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t}\n\t\t\tint res = 0;\n//\t\t\tSystem.out.println(l.size()+\" size\");\n\t\t\tfor(long x:l){\n\t\t\t\tlong s = x>>32, t = x&mask;\n//\t\t\t\tSystem.out.println(s+\",\"+t);\n\t\t\t\tif(R<s)break;\n\t\t\t\tif(R<t)t = R;\n\t\t\t\tres+=t-s+1;\n\t\t\t}\n\t\t\tSystem.out.println(res);\n\t\t}\n\t}\n\t\n\tpublic static void main(String[] args) {\n\t\tnew Main().run();\n\t}\n}"
  },
  {
    "language": "Java",
    "code": "import java.util.Collections;\nimport java.util.Comparator;\nimport java.util.LinkedList;\nimport java.util.List;\nimport java.util.Scanner;\n\n//Shuffle\npublic class Main{\n\t\n\tvoid run(){\n\t\tScanner sc = new Scanner(System.in);\n\t\tlong mask = (1L << 32)-1;\n\t\tComparator<Long> C = new Comparator<Long>() {\n\t\t\tpublic int compare(Long o1, Long o2) {\n\t\t\t\treturn (int) ((o1>>32)-(o2>>32));\n\t\t\t}\n\t\t};\n\t\tfor(;;){\n\t\t\tint n = sc.nextInt();\n\t\t\tif(n==0)break;\n\t\t\tint m = sc.nextInt(), P = sc.nextInt(), Q = sc.nextInt(), R = sc.nextInt();\n\t\t\tList<Long> l = new LinkedList<Long>();\n\t\t\tl.add(((long)P<<32)|Q);\n\t\t\tint[] p = new int[m], q = new int[m];\n\t\t\tfor(int i=0;i<m;i++){\n\t\t\t\tp[i] = sc.nextInt(); q[i] = sc.nextInt();\n\t\t\t}\n\t\t\tfor(int i=m-1;i>=0;i--){\n\t\t\t\tlong t1 = n-q[i], s2 = t1+1, t2 = n-p[i], s3 = n-p[i]+1, y = q[i];\n//\t\t\t\tSystem.out.println(\"s1:\"+s1+\" t1:\"+t1+\" s2:\"+s2+\" t2:\"+t2+\" s3:\"+s3+\" t3:\"+t3);\n//\t\t\t\tlong d = n-q[i]-p[i];\n//\t\t\t\tSystem.out.println(\"Ranges\");\n//\t\t\t\tfor(long x:l){\n//\t\t\t\t\tlong s = x>>32, t = x&mask;\n//\t\t\t\t\tSystem.out.println(s+\",\"+t);\n//\t\t\t\t}\n//\t\t\t\tSystem.out.println(\"end Ranges\");\n\t\t\t\tList<Long> next = new LinkedList<Long>();\n\t\t\t\tfor(int j=0;j<l.size();j++){\n\t\t\t\t\tlong x = l.get(j);\n\t\t\t\t\tlong s = x>>32, t = x&mask;\n//\t\t\t\t\tSystem.out.println(s+\",\"+t);\n\t\t\t\t\tif(t<=t1){\n//\t\t\t\t\t\tSystem.out.println(\"T1\");\n//\t\t\t\t\t\tSystem.out.println((s+y)+\",\"+(t+y));\n\t\t\t\t\t\tnext.add((s+y)<<32 | (t+y));\n\t\t\t\t\t}\n\t\t\t\t\telse if(t<=t2){\n//\t\t\t\t\t\tSystem.out.println(\"T2\");\n\t\t\t\t\t\tif(s<=t1){\n//\t\t\t\t\t\t\tSystem.out.println((s+y)+\",\"+(t1+y));\n\t\t\t\t\t\t\tnext.add((s+y)<<32 | (t1+y));\n\t\t\t\t\t\t\ts = s2;\n\t\t\t\t\t\t}\n//\t\t\t\t\t\tSystem.out.println((s-s2+p[i]+1)+\",\"+(t-s2+p[i]+1));\n\t\t\t\t\t\tnext.add((s-s2+p[i]+1)<<32 | (t-s2+p[i]+1));\n\t\t\t\t\t}\n\t\t\t\t\telse{\n//\t\t\t\t\t\tSystem.out.println(\"T3\");\n\t\t\t\t\t\tif(s<=t1){\n//\t\t\t\t\t\t\tSystem.out.println((s+y)+\",\"+(t1+y));\n\t\t\t\t\t\t\tnext.add((s+y)<<32 | (t1+y));\n\t\t\t\t\t\t\ts = s2;\n\t\t\t\t\t\t}\n\t\t\t\t\t\tif(s<=t2){\n//\t\t\t\t\t\t\tSystem.out.println((s-s2+p[i]+1)+\",\"+(t2-s2+p[i]+1));\n\t\t\t\t\t\t\tnext.add((s-s2+p[i]+1)<<32 | (t2-s2+p[i]+1));\n\t\t\t\t\t\t\ts = s3;\n\t\t\t\t\t\t}\n//\t\t\t\t\t\tSystem.out.println((s-s3+1)+\",\"+(t-s3+1));\n\t\t\t\t\t\tnext.add((s-s3+1)<<32 | (t-s3+1));\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t\tl = next;\n\t\t\t}\n\t\t\tint res = 0;\n\t\t\tCollections.sort(l, C);\n//\t\t\tSystem.out.println(l.size()+\" size\");\n\t\t\tfor(long x:l){\n\t\t\t\tlong s = x>>32, t = x&mask;\n//\t\t\t\tSystem.out.println(s+\",\"+t);\n\t\t\t\tif(R<s)break;\n\t\t\t\tif(R<t)t = R;\n\t\t\t\tres+=t-s+1;\n\t\t\t}\n\t\t\tSystem.out.println(res);\n\t\t}\n\t}\n\t\n\tpublic static void main(String[] args) {\n\t\tnew Main().run();\n\t}\n}"
  },
  {
    "language": "Java",
    "code": "import java.util.ArrayList;\nimport java.util.Collections;\nimport java.util.Comparator;\nimport java.util.List;\n\n//Shuffle\npublic class Main{\n\n\tclass Scanner {\n\t\tint nextInt() {\n\t\t\ttry {\n\t\t\t\tint c = System.in.read();\n\t\t\t\twhile (c != '-' && (c < '0' || '9' < c))\n\t\t\t\t\tc = System.in.read();\n\t\t\t\tif (c == '-') return -nextInt();\n\t\t\t\tint res = 0;\n\t\t\t\tdo {\n\t\t\t\t\tres *= 10;\n\t\t\t\t\tres += c - '0';\n\t\t\t\t\tc = System.in.read();\n\t\t\t\t} while ('0' <= c && c <= '9');\n\t\t\t\treturn res;\n\t\t\t} catch (Exception e) {\n\t\t\t\treturn -1;\n\t\t\t}\n\t\t}\n\t}\n\n\tvoid run(){\n\t\tScanner sc = new Scanner();\n\t\tlong mask = (1L << 32)-1;\n\t\tComparator<Long> C = new Comparator<Long>() {\n\t\t\tpublic int compare(Long o1, Long o2) {\n\t\t\t\treturn (int) ((o1>>32)-(o2>>32));\n\t\t\t}\n\t\t};\n\t\tint[] p = new int[5000], q = new int[5000];\n\t\tfor(;;){\n\t\t\tint n = sc.nextInt();\n\t\t\tif(n==0)break;\n//\t\t\t            long T = System.currentTimeMillis();\n\t\t\tint m = sc.nextInt(), P = sc.nextInt(), Q = sc.nextInt(), R = sc.nextInt();\n\t\t\tList<Long> l = new ArrayList<Long>();\n\t\t\tl.add(((long)P<<32)|Q);\n\t\t\tfor(int i=0;i<m;i++){\n\t\t\t\tp[i] = sc.nextInt(); q[i] = sc.nextInt();\n\t\t\t}\n\t\t\tfor(int i=m-1;i>=0;i--){\n\t\t\t\tlong t1 = n-q[i], s2 = t1+1, t2 = n-p[i], s3 = n-p[i]+1, y = q[i];\n\t\t\t\tList<Long> next = new ArrayList<Long>();\n\t\t\t\tfor(int j=0;j<l.size();j++){\n\t\t\t\t\tlong x = l.get(j);\n\t\t\t\t\tlong s = x>>32, t = x&mask;\n\t\t\t\t\tif(t<=t1){\n\t\t\t\t\t\tnext.add((s+y)<<32 | (t+y));\n\t\t\t\t\t}\n\t\t\t\t\telse if(t<=t2){\n\t\t\t\t\t\tif(s<=t1){\n\t\t\t\t\t\t\tnext.add((s+y)<<32 | (t1+y));\n\t\t\t\t\t\t\ts = s2;\n\t\t\t\t\t\t}\n\t\t\t\t\t\tnext.add((s-s2+p[i]+1)<<32 | (t-s2+p[i]+1));\n\t\t\t\t\t}\n\t\t\t\t\telse{\n\t\t\t\t\t\tif(s<=t1){\n\t\t\t\t\t\t\tnext.add((s+y)<<32 | (t1+y));\n\t\t\t\t\t\t\ts = s2;\n\t\t\t\t\t\t}\n\t\t\t\t\t\tif(s<=t2){\n\t\t\t\t\t\t\tnext.add((s-s2+p[i]+1)<<32 | (t2-s2+p[i]+1));\n\t\t\t\t\t\t\ts = s3;\n\t\t\t\t\t\t}\n\t\t\t\t\t\tnext.add((s-s3+1)<<32 | (t-s3+1));\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t\tif(i==0||1100<=next.size()){\n\t\t\t\t\tl = new ArrayList<Long>();\n\t\t\t\t\tCollections.sort(next, C);\n\t\t\t\t\tlong ss = next.get(0)>>32, tt = next.get(0)&mask;\n\t\t\t\t\tfor(int j=1;j<next.size();j++){\n\t\t\t\t\t\tlong x = next.get(j);\n\t\t\t\t\t\tlong s = x>>32, t = x&mask;\n\t\t\t\t\t\tif(tt+1==s)tt = t;\n\t\t\t\t\t\telse{\n\t\t\t\t\t\t\tl.add((ss<<32)|tt);\n\t\t\t\t\t\t\tss = s; tt = t;\n\t\t\t\t\t\t}\n\t\t\t\t\t}\n\t\t\t\t\tl.add((ss<<32)|tt);\n\t\t\t\t}\n\t\t\t\telse{\n\t\t\t\t\tl = next;\n\t\t\t\t}\n\t\t\t}\n\t\t\tint res = 0;\n\t\t\tfor(long x:l){\n\t\t\t\tlong s = x>>32, t = x&mask;\n\t\t\t\tif(R<s)break;\n\t\t\t\tif(R<t)t = R;\n\t\t\t\tres+=t-s+1;\n\t\t\t}\n\t\t\tSystem.out.println(res);\n//\t\t\t            System.out.println((System.currentTimeMillis()-T)+\" ms.\");\n\t\t}\n\t}\n\n\tpublic static void main(String[] args) {\n\t\tnew Main().run();\n\t}\n}"
  },
  {
    "language": "Java",
    "code": "import java.io.File;\nimport java.io.FileNotFoundException;\nimport java.util.ArrayList;\nimport java.util.Collections;\nimport java.util.Comparator;\nimport java.util.List;\nimport java.util.Scanner;\n\npublic class Main {\n\n\tpublic static void main(String[] args) throws FileNotFoundException {\n\n\t\t Scanner scan = new Scanner(System.in);\n\t\t//Scanner scan = new Scanner(new File(\"D:\\\\UserArea\\\\J0124567\\\\Downloads\\\\0536-input.txt\"));\n\n\t\twhile (scan.hasNext()) {\n\n\t\t\tint n = scan.nextInt();\n\t\t\tif (n == 0)\n\t\t\t\tbreak;\n\t\t\tint m = scan.nextInt();\n\t\t\tint p = scan.nextInt();\n\t\t\tint q = scan.nextInt();\n\t\t\tint r = scan.nextInt();\n\n\t\t\tCard c = new Card(n, m);\n\t\t\tfor (int i = 0; i < m; i++) {\n\t\t\t\tc.shuffle(scan.nextInt(), scan.nextInt(), n);\n\t\t\t\t// c.print();\n\t\t\t}\n\n\t\t\tSystem.out.println(c.count(p, q, r));\n\t\t}\n\n\t\tscan.close();\n\t\tSystem.exit(0);\n\n\t}\n}\n\nclass Card {\n\tclass Bulk {\n\t\tpublic Bulk(int _st, int _pcs, int _next) {\n\t\t\tst = _st;\n\t\t\tpcs = _pcs;\n\t\t\tnext = _next;\n\t\t}\n\n\t\tint st;\n\t\tint pcs;\n\t\tint next;\n\t}\n\n\tint top;\n\tint empty;\n\tBulk[] bu;\n\n\tpublic Card(int n, int m) {\n\t\tbu = new Bulk[m * 3];\n\t\tbu[0] = new Bulk(1, n, -1);\n\t\ttop = 0;\n\t\tempty = 1;\n\t}\n\n\tpublic void print() {\n\t\tint i = top;\n\t\twhile (true) {\n\n\t\t\tSystem.out.print(\" {\" + bu[i].st + \" \" + (bu[i].st + bu[i].pcs - 1) + \"}\");\n\t\t\ti = bu[i].next;\n\t\t\tif (i == -1)\n\t\t\t\tbreak;\n\t\t}\n\t\tSystem.out.println();\n\t}\n\n\tpublic int count(int p, int q, int r) {\n\t\tint i = top;\n\t\tint pcs = 0;\n\t\tint cto = 0;\n\t\tint cfr;\n\t\twhile (true) {\n\t\t\tcfr = cto + 1;\n\t\t\tcto += bu[i].pcs;\n\t\t\tif (cfr > q)\n\t\t\t\tbreak;\n\t\t\tif (cto < p) {\n\t\t\t\ti = bu[i].next;\n\t\t\t\tcontinue;\n\t\t\t}\n\t\t\tint a, b;\n\t\t\tif (cfr < p)\n\t\t\t\ta = p - cfr;\n\t\t\telse\n\t\t\t\ta = 0;\n\t\t\tif (cto > q)\n\t\t\t\tb = bu[i].pcs - (cto - q) - 1;\n\t\t\telse\n\t\t\t\tb = bu[i].pcs - 1;\n\t\t\tif (bu[i].st + a <= r)\n\t\t\t\tif (bu[i].st + b <= r)\n\t\t\t\t\tpcs += (b - a + 1);\n\t\t\t\telse\n\t\t\t\t\tpcs += (r - (bu[i].st + a) + 1);\n\n\t\t\ti = bu[i].next;\n\n\t\t}\n\t\treturn pcs;\n\t}\n\n\tpublic void shuffle(int x, int y, int n) {\n\t\t// this.print();\n\n\t\tint i = top;\n\t\tint cto = 0, cfr = 0;\n\t\tint xlast = 0, ylast = 0, zlast = 0;\n\t\twhile (true) {\n\t\t\tcfr = cto + 1;\n\t\t\tcto += bu[i].pcs;\n\t\t\tif (cfr <= x && x <= cto) {\n\t\t\t\tif (x < cto) {\n\t\t\t\t\tthis.devide(i, cto - x);\n\t\t\t\t\tcto = x;\n\t\t\t\t}\n\t\t\t\txlast = i;\n\t\t\t}\n\t\t\tif (cfr <= y && y <= cto) {\n\t\t\t\tif (y < cto) {\n\t\t\t\t\tthis.devide(i, cto - y);\n\t\t\t\t\tcto = y;\n\t\t\t\t}\n\t\t\t\tylast = i;\n\t\t\t}\n\n\t\t\tif (bu[i].next == -1) {\n\t\t\t\tzlast = i;\n\t\t\t\tbreak;\n\t\t\t}\n\t\t\ti = bu[i].next;\n\t\t}\n\t\tint temp = top;\n\t\ttop = bu[ylast].next;\n\t\tbu[ylast].next = temp;\n\t\tbu[zlast].next = bu[xlast].next;\n\t\tbu[xlast].next = -1;\n\n\t}\n\n\tprivate int devide(int i, int pcs) {\n\t\tbu[empty] = new Bulk(bu[i].st + bu[i].pcs - pcs, pcs, bu[i].next);\n\t\tbu[i].pcs -= pcs;\n\t\tbu[i].next = empty;\n\t\treturn empty++;\n\t}\n\n}"
  },
  {
    "language": "Java",
    "code": "\nimport java.util.*;\n\nimport static java.lang.Math.*;\nimport static java.util.Arrays.*;\n\npublic class Main{\n\n\tint INF = 1 << 28;\n\tint n, m;\n\tlong[] card = new long[15000];\n\tlong[] tmp = new long[15000];\n\tint x, y;\n\tint s, t, u;\n\tint p, q, r;\n\tint len;\n\tint n_len;\n\tint indx, indy;\n\n\tvoid run() {\n\t\tScanner sc = new Scanner(System.in);\n\t\tfor(;;) {\n\t\t\tn = sc.nextInt();\n\t\t\tif(n == 0) break;\n\t\t\tm = sc.nextInt();\n\t\t\tp = sc.nextInt();\n\t\t\tq = sc.nextInt();\n\t\t\tr = sc.nextInt();\n\t\t\t\n\t\t\tlen = 1;\n\t\t\tfill(card, 0);\n\t\t\tcard[0] = int2long(1, n);\n\t\t\tfor(int h=0;h<m;h++) {\n\t\t\t\tx = sc.nextInt();\n\t\t\t\ty = sc.nextInt();\n\t\t\t\tn_len = 0;\n\t\t\t\tfor(int i=0;i<len;i++) {\n//\t\t\t\t\tSystem.out.println(card[i]-((card[i]>>32)<<32));\n\t\t\t\t\ts = (int)(card[i]>>32);\n\t\t\t\t\tt = (int)(card[i]-((long)s<<32));\n\t\t\t\t\tu = t - s + 1;\n//\t\t\t\t\tSystem.out.println(s + \" \" + t + \" \" + u + \" \" + x + \" \" + y);\n\t\t\t\t\tif(  u <= x ) {\n\t\t\t\t\t\tif(x==u) {\n\t\t\t\t\t\t\ttmp[n_len++] = int2long(s, t);\n\t\t\t\t\t\t\tindx = n_len;\n\t\t\t\t\t\t\ty -= x;\n\t\t\t\t\t\t\tx=0;\n\t\t\t\t\t\t}\n\t\t\t\t\t\telse {\n\t\t\t\t\t\t\ttmp[n_len++] = card[i];\n\t\t\t\t\t\t\tx -= u;\n\t\t\t\t\t\t\ty -= u;\n\t\t\t\t\t\t}\n\t\t\t\t\t}\n\t\t\t\t\telse if(u <= y) {\n\t\t\t\t\t\tif(y==u) {\n\t\t\t\t\t\t\ttmp[n_len++] = int2long(s, t);\n\t\t\t\t\t\t\tindy = n_len;\n\t\t\t\t\t\t\ty=0;\n\t\t\t\t\t\t}\n\t\t\t\t\t\telse {\n\t\t\t\t\t\t\ttmp[n_len++] = card[i];\n\t\t\t\t\t\t\ty -= u;\n\t\t\t\t\t\t}\n\t\t\t\t\t}\n\t\t\t\t\telse if( x > 0 && x < u && y < u ) {\n//\t\t\t\t\t\tSystem.out.println(s + \" \" + (s+x-1) + \" \" + (s+y-1));\n\t\t\t\t\t\ttmp[n_len++] = int2long(s, s+x-1);\n\t\t\t\t\t\tindx = n_len;\n\t\t\t\t\t\ttmp[n_len++] = int2long(s+x, s+y-1);\n\t\t\t\t\t\tindy = n_len;\n\t\t\t\t\t\ttmp[n_len++] = int2long(s+y, t);\n\t\t\t\t\t\t\n\t\t\t\t\t}\n\t\t\t\t\telse if(x > 0 && x < u) {\n\t\t\t\t\t\ttmp[n_len++] = int2long(s, s+x-1);\n\t\t\t\t\t\tindx = n_len;\n\t\t\t\t\t\ttmp[n_len++] = int2long(s+x, t);\n\t\t\t\t\t\ty -= x;\n\t\t\t\t\t\tx = 0;\n\t\t\t\t\t}\n\t\t\t\t\telse if(y > 0 && y < u) {\n\t\t\t\t\t\ttmp[n_len++] = int2long(s, s+y-1);\n\t\t\t\t\t\tindy = n_len;\n\t\t\t\t\t\ttmp[n_len++] = int2long(s+y, t);\n\t\t\t\t\t\ty = 0;\n\t\t\t\t\t}\n\t\t\t\t\telse {\n\t\t\t\t\t\ttmp[n_len++] = card[i];\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t\tlen = n_len;\n\t\t\t\tn_len=0;\n\t\t\t\tfor(int i=indy;i<len;i++) card[n_len++] = tmp[i];\n\t\t\t\tfor(int i=indx;i<indy;i++) card[n_len++] = tmp[i];\n\t\t\t\tfor(int i=0;i<indx;i++) card[n_len++] = tmp[i];\n\t\t\t\t\n\t\t\t}\n\t\t\tint ans = 0;\n\t\t\tfor(int i=0;i<len;i++) {\n\t\t\t\ts = (int)(card[i]>>32);\n\t\t\t\tt = (int)(card[i]-((long)s<<32));\n\t\t\t\tu = t - s + 1;\n//\t\t\t\tSystem.out.println(s + \" \" + t + \" \" + u + \" \" + p + \" \" + q);\n\t\t\t\tif( u <= p ) {\n\t\t\t\t\tif(p == u)\n\t\t\t\t\t\tans += (t < r)? 1:0;\n\t\t\t\t\tp -= u;\n\t\t\t\t\tq -= u;\n\t\t\t\t}\n\t\t\t\t\n\t\t\t\telse if( p>0 && u>p && u>q ) {\n\t\t\t\t\tans += max(0, min(q-p, r-(s+p)+1));\n\t\t\t\t\tbreak;\n\t\t\t\t}\n\t\t\t\telse if( p>0 && u>p) {\n\t\t\t\t\tans += max(0, min(t-(s+p)+1, r-(s+p)+1));\n\t\t\t\t\tp -= u;\n\t\t\t\t\tq -= u;\n\t\t\t\t}\n\t\t\t\telse if( u <= q ) {\n\t\t\t\t\tans += max(0, min(u, r-s+1));\n\t\t\t\t\tif( q == u) break;\n\t\t\t\t\tq -= u;\n\t\t\t\t}\n\t\t\t\telse if(q>0 && u>q) {\n\t\t\t\t\tans += max(0, min(q, r-q+1));\n\t\t\t\t\tbreak;\n\t\t\t\t}\n\t\t\t}\n\t\t\tSystem.out.println(ans);\n\t\t}\n\t}\n\t\n\tlong int2long(int f, int t) {\n\t\treturn (((long)f << 32) + t);\n\t}\n\n\tpublic static void main(String[] args) {\n\t\tnew Main().run();\n\t}\n\t\n\tvoid debug(Object...os){\n\t\tSystem.err.println(Arrays.deepToString(os));\n\t}\n}"
  },
  {
    "language": "Java",
    "code": "\nimport java.awt.Point;\nimport java.io.BufferedReader;\nimport java.io.IOException;\nimport java.io.InputStreamReader;\nimport java.util.ArrayList;\nimport java.util.List;\nimport java.util.StringTokenizer;\n\npublic class Main {\n\n\tpublic static void main(String[] args) throws IOException {\n\n\t\tnew Main().run();\n\t}\n\n\tprivate void run() throws IOException {\n\t\tBufferedReader reader = new BufferedReader(new InputStreamReader(System.in));\n\t\twhile (true) {\n\t\t\tint n = Integer.parseInt(reader.readLine());\n\t\t\tif (n == 0)\n\t\t\t\tbreak;\n\t\t\tint m = Integer.parseInt(reader.readLine());\n\t\t\tStringTokenizer t = new StringTokenizer(reader.readLine());\n\t\t\tint p = Integer.parseInt(t.nextToken());\n\t\t\tint q = Integer.parseInt(t.nextToken());\n\t\t\tint r = Integer.parseInt(t.nextToken());\n\t\t\tList<Point> v = new ArrayList<Point>();\n\t\t\tv.add(new Point(1, n));\n\t\t\twhile (m-- > 0) {\n\t\t\t\tt = new StringTokenizer(reader.readLine());\n\t\t\t\tint x = Integer.parseInt(t.nextToken());\n\t\t\t\tint y = Integer.parseInt(t.nextToken());\n\t\t\t\tList<Point> a, b, c;\n\t\t\t\ta = new ArrayList<Point>();\n\t\t\t\tb = new ArrayList<Point>();\n\t\t\t\tc = new ArrayList<Point>();\n\t\t\t\tcut(v, y, c);\n\t\t\t\tcut(v, x, b);\n\t\t\t\ta = v;\n\t\t\t\tv = c;\n\t\t\t\tv.addAll(b);\n\t\t\t\tv.addAll(a);\n\t\t\t}\n\t\t\tList<Point> rv = new ArrayList<Point>();\n\t\t\tcut(v, q, rv);\n\t\t\tcut(v, p - 1, rv);\n\t\t\tint ans = 0;\n\t\t\tfor (int i = 0; i < rv.size(); i++)\n\t\t\t\tans += Math.max(0, Math.min(r - rv.get(i).x + 1, rv.get(i).y));\n\t\t\tSystem.out.println(ans);\n\t\t}\n\t}\n\n\tprivate void cut(List<Point> v, int x, List<Point> r) {\n\t\tr.clear();\n\t\tint n = 0;\n\t\tint p = 0;\n\t\twhile (n + v.get(p).y <= x) {\n\t\t\tn += v.get(p).y;\n\t\t\tp++;\n\t\t}\n\t\tPoint ns = new Point(v.get(p).x + x - n, v.get(p).y - (x - n));\n\t\tr.add(ns);\n\t\tfor (int j = p + 1; j < v.size(); j++) {\n\t\t\tr.add(new Point(v.get(j).x, v.get(j).y));\n\t\t}\n\t\tfor (int j = v.size() - 1; j >= p + 1; j--)\n\t\t\tv.remove(j);\n\t\tv.get(v.size() - 1).y = x - n;\n\n\t}\n}"
  },
  {
    "language": "Java",
    "code": "import java.util.ArrayList;\nimport java.util.Collections;\nimport java.util.Comparator;\nimport java.util.List;\nimport java.util.Scanner;\n\n//Shuffle\npublic class Main{\n\t\n\tvoid run(){\n\t\tScanner sc = new Scanner(System.in);\n\t\tlong mask = (1L << 32)-1;\n\t\tComparator<Long> C = new Comparator<Long>() {\n\t\t\tpublic int compare(Long o1, Long o2) {\n\t\t\t\treturn (int) ((o1>>32)-(o2>>32));\n\t\t\t}\n\t\t};\n\t\tfor(;;){\n\t\t\tint n = sc.nextInt();\n\t\t\tif(n==0)break;\n//\t\t\tlong T = System.currentTimeMillis();\n\t\t\tint m = sc.nextInt(), P = sc.nextInt(), Q = sc.nextInt(), R = sc.nextInt();\n\t\t\tList<Long> l = new ArrayList<Long>();\n\t\t\tl.add(((long)P<<32)|Q);\n\t\t\tint[] p = new int[m], q = new int[m];\n\t\t\tfor(int i=0;i<m;i++){\n\t\t\t\tp[i] = sc.nextInt(); q[i] = sc.nextInt();\n\t\t\t}\n\t\t\tfor(int i=m-1;i>=0;i--){\n//\t\t\t\tSystem.out.println(\"L:\"+l.size());\n\t\t\t\tlong t1 = n-q[i], s2 = t1+1, t2 = n-p[i], s3 = n-p[i]+1, y = q[i];\n\t\t\t\tList<Long> next = new ArrayList<Long>();\n\t\t\t\tfor(int j=0;j<l.size();j++){\n\t\t\t\t\tlong x = l.get(j);\n\t\t\t\t\tlong s = x>>32, t = x&mask;\n\t\t\t\t\tif(t<=t1){\n\t\t\t\t\t\tnext.add((s+y)<<32 | (t+y));\n\t\t\t\t\t}\n\t\t\t\t\telse if(t<=t2){\n\t\t\t\t\t\tif(s<=t1){\n\t\t\t\t\t\t\tnext.add((s+y)<<32 | (t1+y));\n\t\t\t\t\t\t\ts = s2;\n\t\t\t\t\t\t}\n\t\t\t\t\t\tnext.add((s-s2+p[i]+1)<<32 | (t-s2+p[i]+1));\n\t\t\t\t\t}\n\t\t\t\t\telse{\n\t\t\t\t\t\tif(s<=t1){\n\t\t\t\t\t\t\tnext.add((s+y)<<32 | (t1+y));\n\t\t\t\t\t\t\ts = s2;\n\t\t\t\t\t\t}\n\t\t\t\t\t\tif(s<=t2){\n\t\t\t\t\t\t\tnext.add((s-s2+p[i]+1)<<32 | (t2-s2+p[i]+1));\n\t\t\t\t\t\t\ts = s3;\n\t\t\t\t\t\t}\n\t\t\t\t\t\tnext.add((s-s3+1)<<32 | (t-s3+1));\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t\tl = new ArrayList<Long>();\n//\t\t\t\tl = next;\n\t\t\t\tCollections.sort(next, C);\n\t\t\t\tlong ss = next.get(0)>>32, tt = next.get(0)&mask;\n\t\t\t\tfor(int j=1;j<next.size();j++){\n\t\t\t\t\tlong x = next.get(j);\n\t\t\t\t\tlong s = x>>32, t = x&mask;\n\t\t\t\t\tif(tt+1==s)tt = t;\n\t\t\t\t\telse{\n\t\t\t\t\t\tl.add((ss<<32)|tt);\n\t\t\t\t\t\tss = s; tt = t;\n\t\t\t\t\t}\n//\t\t\t\t\tlong x1 = next.get(j), x2 = next.get(j+1);\n//\t\t\t\t\tlong t = x1&mask, s = x2>>32;\n//\t\t\t\t\tif(t+1==s){\n//\t\t\t\t\t\tl.remove(j); l.remove(j);\n//\t\t\t\t\t\ts = x1>>32; t = x2&mask;\n//\t\t\t\t\t\tl.add(j--, (s<<32)|t);\n//\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t\tl.add((ss<<32)|tt);\n\t\t\t}\n\t\t\tint res = 0;\n\t\t\tfor(long x:l){\n\t\t\t\tlong s = x>>32, t = x&mask;\n\t\t\t\tif(R<s)break;\n\t\t\t\tif(R<t)t = R;\n\t\t\t\tres+=t-s+1;\n\t\t\t}\n\t\t\tSystem.out.println(res);\n//\t\t\tSystem.out.println((System.currentTimeMillis()-T)+\" ms.\");\n\t\t}\n\t}\n\t\n\tpublic static void main(String[] args) {\n\t\tnew Main().run();\n\t}\n}"
  },
  {
    "language": "Java",
    "code": "\nimport java.util.*;\n\nimport static java.lang.Math.*;\nimport static java.util.Arrays.*;\n\npublic class Main {\n\n\tint INF = 1 << 28;\n\tlong n;\n\tint m;\n\tlong p;\n\tlong q;\n\tlong r;\n\tLinkedList<Segment> card;\n\tvoid run() {\n\t\tScanner sc = new Scanner(System.in);\n\t\tLinkedList<Segment> a = new LinkedList<Segment>();\n\t\tLinkedList<Segment> b = new LinkedList<Segment>();\n\t\tfor(;;) {\n\t\t\tn = sc.nextLong();\n\t\t\tif( n == 0) break;\n\t\t\tcard = new LinkedList<Segment>();\n\t\t\tcard.add(new Segment(1, n));\n\t\t\tm = sc.nextInt();\n\t\t\tp = sc.nextLong();\n\t\t\tq = sc.nextLong();\n\t\t\tr = sc.nextLong();\n\t\t\tfor(int i=0;i<m;i++) {\n\t\t\t\tlong x = sc.nextLong();\n\t\t\t\tlong y = sc.nextLong();\n\t\t\t\tfor(;!card.isEmpty();) {\n//\t\t\t\t\tSystem.out.println(x +\" \" + y);\n\t\t\t\t\tSegment s = card.removeFirst();\n\t\t\t\t\tif(s.size <= x ) {\n\t\t\t\t\t\ta.addLast(s);\n\t\t\t\t\t\tx -= s.size;\n\t\t\t\t\t\ty -= s.size;\n\t\t\t\t\t}\n\t\t\t\t\telse if( x>0 && s.size > x){\n\t\t\t\t\t\tSegment[] sp = s.split(x);\n\t\t\t\t\t\ta.addLast(sp[0]);\n\t\t\t\t\t\ty -= x;\n\t\t\t\t\t\tif( sp[1].size<=y ) {\n\t\t\t\t\t\t\tb.addLast(sp[1]);\n\t\t\t\t\t\t\ty -= sp[1].size;\n\t\t\t\t\t\t\t\n\t\t\t\t\t\t}\n\t\t\t\t\t\telse {\n\t\t\t\t\t\t\tSegment tmp[] = sp[1].split(y); \n\t\t\t\t\t\t\tb.addLast(tmp[0]);\n\t\t\t\t\t\t\tcard.addFirst(tmp[1]);\n\t\t\t\t\t\t\ty=0;\n\t\t\t\t\t\t}\n\t\t\t\t\t\tx = 0;\n\t\t\t\t\t\tif(y==0) break;\n\t\t\t\t\t}\n\t\t\t\t\telse if( s.size <= y ) {\n\t\t\t\t\t\tb.addLast(s);\n\t\t\t\t\t\ty -= s.size;\n\t\t\t\t\t\tif(y==0) break;\n\t\t\t\t\t}\n\t\t\t\t\telse if(y>0 && s.size > y) {\n\t\t\t\t\t\tSegment[] sp = s.split(y);\n\t\t\t\t\t\tcard.addFirst(sp[1]);\n\t\t\t\t\t\tb.addLast(sp[0]);\n\t\t\t\t\t\ty = 0;\n\t\t\t\t\t\tbreak;\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t\tfor(;!b.isEmpty();)card.addLast(b.remove());\n\t\t\t\tfor(;!a.isEmpty();)card.addLast(a.remove());\n\t\t\t\t\n//\t\t\t\tfor(Segment s: card) System.err.println(\"(\" + s.s + \",\" + s.e + \")\");\n//\t\t\t\tSystem.err.println();\n\t\t\t}\n\t\t\tlong ans = 0;\n\t\t\tfor(;!card.isEmpty();) {\n\t\t\t\tSegment s = card.removeFirst();\n\t\t\t\tif(s.size < p) {\n\t\t\t\t\tp -= s.size;\n\t\t\t\t\tq -= s.size;\n\t\t\t\t}\n\t\t\t\telse if(p > 0 && s.size>=p) {\n\t\t\t\t\tif(s.size == 1) {\n\t\t\t\t\t\tans += s.cntElement(r);\n\t\t\t\t\t}\n\t\t\t\t\telse {\n\t\t\t\t\t\tSegment[] sp = s.split(p);\n\t\t\t\t\t\tcard.addFirst(sp[1]);\n\t\t\t\t\t}\n\t\t\t\t\t\n\t\t\t\t\tq -= p;\n\t\t\t\t\tp = 0;\n\t\t\t\t}\n\t\t\t\telse if(q > s.size) {\n\t\t\t\t\tq -= s.size;\n\t\t\t\t\tans += s.cntElement(r);\n\t\t\t\t}\n\t\t\t\telse if(s.size>=q) {\n\t\t\t\t\tSegment[] sp = s.split(q);\n\t\t\t\t\tans += sp[0].cntElement(r);\n\t\t\t\t\tbreak;\n\t\t\t\t}\n\t\t\t}\n\t\t\tSystem.out.println(ans);\n\t\t}\n\t}\n\t\n\tvoid debug(Object...os){\n\t\tSystem.err.println(Arrays.deepToString(os));\n\t}\n\n\tpublic static void main(String[] args) {\n\t\tnew Main().run();\n\t}\n\tclass Segment {\n\t\tlong s, e;\n\t\tlong size;\n\t\tSegment (long s, long e) {\n\t\t\tthis.s = s;\n\t\t\tthis.e = e;\n\t\t\tsize = e-s+1;\n\t\t}\n\t\t\n\t\tSegment[] split(long x) {\n\t\t\tSegment[] sp = new Segment[2];\n\t\t\tsp[0] = new Segment(s, s+x-1);\n\t\t\tsp[1] = new Segment(s+x, e);\n\t\t\treturn sp;\n\t\t}\n\t\t\n\t\tlong cntElement(long r) {\n\t\t\tif(r >= e) return size;\n\t\t\telse if( r>= s) return r-s+1;\n\t\t\treturn 0;\n\t\t}\n\t}\n}"
  },
  {
    "language": "Java",
    "code": "import java.util.ArrayList;\nimport java.util.Collections;\nimport java.util.Comparator;\nimport java.util.List;\n\n//Shuffle\npublic class Main{\n\t\n\tclass Scanner {\n\t\tint nextInt() {\n\t\t\ttry {\n\t\t\t\tint c = System.in.read();\n\t\t\t\twhile (c != '-' && (c < '0' || '9' < c))\n\t\t\t\t\tc = System.in.read();\n\t\t\t\tif (c == '-') return -nextInt();\n\t\t\t\tint res = 0;\n\t\t\t\tdo {\n\t\t\t\t\tres *= 10;\n\t\t\t\t\tres += c - '0';\n\t\t\t\t\tc = System.in.read();\n\t\t\t\t} while ('0' <= c && c <= '9');\n\t\t\t\treturn res;\n\t\t\t} catch (Exception e) {\n\t\t\t\treturn -1;\n\t\t\t}\n\t\t}\n\t}\n\t\n\tvoid run(){\n\t\tScanner sc = new Scanner();\n        long mask = (1L << 32)-1;\n        Comparator<Long> C = new Comparator<Long>() {\n            public int compare(Long o1, Long o2) {\n                return (int) ((o1>>32)-(o2>>32));\n            }\n        };\n        int[] p = new int[5000], q = new int[5000];\n        for(;;){\n            int n = sc.nextInt();\n            if(n==0)break;\n//            long T = System.currentTimeMillis();\n            int m = sc.nextInt(), P = sc.nextInt(), Q = sc.nextInt(), R = sc.nextInt();\n            List<Long> l = new ArrayList<Long>();\n            l.add(((long)P<<32)|Q);\n            for(int i=0;i<m;i++){\n                p[i] = sc.nextInt(); q[i] = sc.nextInt();\n            }\n            for(int i=m-1;i>=0;i--){\n                long t1 = n-q[i], s2 = t1+1, t2 = n-p[i], s3 = n-p[i]+1, y = q[i];\n                List<Long> next = new ArrayList<Long>();\n                for(int j=0;j<l.size();j++){\n                    long x = l.get(j);\n                    long s = x>>32, t = x&mask;\n                    if(t<=t1){\n                        next.add((s+y)<<32 | (t+y));\n                    }\n                    else if(t<=t2){\n                        if(s<=t1){\n                            next.add((s+y)<<32 | (t1+y));\n                            s = s2;\n                        }\n                        next.add((s-s2+p[i]+1)<<32 | (t-s2+p[i]+1));\n                    }\n                    else{\n                        if(s<=t1){\n                            next.add((s+y)<<32 | (t1+y));\n                            s = s2;\n                        }\n                        if(s<=t2){\n                            next.add((s-s2+p[i]+1)<<32 | (t2-s2+p[i]+1));\n                            s = s3;\n                        }\n                        next.add((s-s3+1)<<32 | (t-s3+1));\n                    }\n                }\n                l = new ArrayList<Long>();\n                Collections.sort(next, C);\n                long ss = next.get(0)>>32, tt = next.get(0)&mask;\n                for(int j=1;j<next.size();j++){\n                    long x = next.get(j);\n                    long s = x>>32, t = x&mask;\n                    if(tt+1==s)tt = t;\n                    else{\n                        l.add((ss<<32)|tt);\n                        ss = s; tt = t;\n                    }\n                }\n                l.add((ss<<32)|tt);\n            }\n            int res = 0;\n            for(long x:l){\n                long s = x>>32, t = x&mask;\n                if(R<s)break;\n                if(R<t)t = R;\n                res+=t-s+1;\n            }\n            System.out.println(res);\n//            System.out.println((System.currentTimeMillis()-T)+\" ms.\");\n        }\n\t}\n\t\n\tpublic static void main(String[] args) {\n\t\tnew Main().run();\n\t}\n}"
  },
  {
    "language": "Java",
    "code": "import java.util.Scanner;\npublic class Main{\n\tpublic static void main(String[] args){\n\t\tScanner scan = new Scanner(System.in);\n\t\twhile(scan.hasNext()){\n\t\t\tint n = scan.nextInt();\n\t\t\tif(n == 0){\n\t\t\t\tbreak;\n\t\t\t}\n\t\t\tint m = scan.nextInt();\n\t\t\tint p = scan.nextInt();\n\t\t\tint q = scan.nextInt();\n\t\t\tint r = scan.nextInt();\n\t\t\tString[] card = new String[n];\n\t\t\tfor(int i = 0;i < n;i++){\n\t\t\t\tcard[i] = String.valueOf(i+1);\n\t\t\t}\n\t\t\tfor(int i = 0;i < m;i++){\n\t\t\t\tcard = shuffle(card,scan.nextInt(),scan.nextInt(),n);\n\t\t\t}\n\t\t\tint count = 0;\n\t\t\tfor(int i = p-1;i < q;i++){\n\t\t\t\tif(Integer.parseInt(card[i]) <= r){\n\t\t\t\t\tcount++;\n\t\t\t\t}\n\t\t\t}\n\t\t\tSystem.out.println(count);\n\t\t}\n\t}\n\t\n\tpublic static String[] shuffle(String[] a,int x,int y,int n){\n\t\tString[] ans = new String[n];\n\t\tfor(int i = 0;i < n-y;i++){\n\t\t\tans[i] = a[i+y];\n\t\t}\n\t\tfor(int i = 0;i < y-x;i++){\n\t\t\tans[n-y+i] = a[i+x];\n\t\t}\n\t\tfor(int i = 0;i < x;i++){\n\t\t\tans[n-x+i] = a[i];\n\t\t}\n\t\treturn ans;\n\t}\n}"
  },
  {
    "language": "Java",
    "code": "/**\n * Shuffle\n */\n\nimport java.io.BufferedReader;\nimport java.io.IOException;\nimport java.io.InputStreamReader;\nimport java.util.ArrayDeque;\nimport java.util.Queue;\nimport java.util.StringTokenizer;\n\nimport static java.lang.Integer.parseInt;\n\npublic class Main {\n\n\tpublic static void main(String[] args) throws IOException {\n\t\tBufferedReader br = new BufferedReader(new InputStreamReader(System.in));\n\t\tString line;\n\n\t\twhile ((line = br.readLine()) != null && !line.isEmpty()) {\n\t\t\tint n = parseInt(line);\n\t\t\tif (n == 0) break;\n\n\t\t\tQueue<Bundle> bundles = new ArrayDeque<Bundle>();\n\t\t\tbundles.offer(new Bundle(1, n));\n\n\t\t\tint m = parseInt(br.readLine());\n\t\t\tint p, q, r;\n\t\t\tStringTokenizer st = new StringTokenizer(br.readLine());\n\t\t\tp = parseInt(st.nextToken());\n\t\t\tq = parseInt(st.nextToken());\n\t\t\tr = parseInt(st.nextToken());\n\n\t\t\t//shuffle\n\t\t\tint count = 0;\n\t\t\tfor (int i = 0; i < m + 1; i++) {\n\t\t\t\tint x, y;\n\t\t\t\tint[] pos;\n\t\t\t\tif (i < m) {\n\t\t\t\t\tline = br.readLine();\n\t\t\t\t\tx = parseInt(line.substring(0, line.indexOf(' ')));\n\t\t\t\t\ty = parseInt(line.substring(line.indexOf(' ') + 1));\n\t\t\t\t\tpos = new int[]{x, y - x, n - y};\n\t\t\t\t} else {\n\t\t\t\t\tpos = new int[]{p - 1, q - p - 1, n - q};\n\t\t\t\t}\n\t\t\t\tfor (int j = 0; j < pos.length; j++) {\n\t\t\t\t\twhile (pos[j] != 0) {\n\t\t\t\t\t\tBundle seg;\n\t\t\t\t\t\tif (bundles.peek().size > pos[j]) {\n\t\t\t\t\t\t\tseg = bundles.peek().divide(pos[j]);\n\t\t\t\t\t\t} else {\n\t\t\t\t\t\t\tseg = bundles.poll();\n\t\t\t\t\t\t}\n\t\t\t\t\t\tbundles.offer(seg);\n\t\t\t\t\t\tpos[j] -= seg.size;\n\t\t\t\t\t\tif (i == m && j == 1) {\n\t\t\t\t\t\t\tcount += seg.query(r);\n\t\t\t\t\t\t}\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t}\n\t\t\tSystem.out.println(count);\n\t\t} //end while\n\t} //end main\n}\n\nclass Bundle {\n\tint start, end, size;\n\n\tBundle(int start, int end) {\n\t\tthis.start = start;\n\t\tthis.end = end;\n\t\tthis.size = end - start + 1;\n\t}\n\n\tint query(int query) {\n\t\tif (end <= query) return size;\n\t\telse if (start <= query) return query - start + 1;\n\t\telse return 0;\n\t}\n\n\tBundle divide(int size) {\n\t\tint _start = this.start;\n\t\tthis.start += size;\n\t\tthis.size = this.end - this.start + 1;\n\t\treturn new Bundle(_start, _start + size - 1);\n\t}\n}"
  },
  {
    "language": "Java",
    "code": "import java.util.Scanner;\n\npublic class Main {\n\n\tstatic Scanner sc = new Scanner(System.in);\n\tstatic int MOD = 100000;\n\n\tpublic static void main(String[] args) {\n\t\twhile (true) {\n\t\t\tint N = sc.nextInt();\n\t\t\tif (N == 0) break;\n\t\t\tint M = sc.nextInt();\n\t\t\tint P = sc.nextInt() - 1;\n\t\t\tint Q = sc.nextInt() - 1;\n\t\t\tint R = sc.nextInt();\n\t\t\tNode EDGE = new Node(0, 0);\n\t\t\tNode top = new Node(1, N);\n\t\t\ttop.prev = top.next = EDGE;\n\t\t\tEDGE.next = EDGE.prev = top;\n\t\t\tfor (int i = 0; i < M; ++i) {\n\t\t\t\tint x = sc.nextInt();\n\t\t\t\tint y = sc.nextInt();\n\t\t\t\tNode sy = walk(EDGE.next, x);\n\t\t\t\tNode sz = walk(sy, y - x);\n\t\t\t\texchange(EDGE.next, sy.prev, sz, EDGE.prev);\n\t\t\t}\n\t\t\tint count = 0;\n\t\t\tfor (Node cur = EDGE.next; cur != EDGE; count += cur.len, cur = cur.next) {\n\t\t\t\tif (count > Q) break;\n\t\t\t\tif (count + cur.len <= P) continue;\n\t\t\t\tif (count < P) {\n\t\t\t\t\tcur.divide(P - count);\n\t\t\t\t\tcontinue;\n\t\t\t\t}\n\t\t\t\tif (count + cur.len > Q + 1) {\n\t\t\t\t\tcur.divide(Q - count + 1);\n\t\t\t\t\tbreak;\n\t\t\t\t}\n\t\t\t}\n\t\t\tcount = 0;\n\t\t\tint ans = 0;\n\t\t\tfor (Node cur = EDGE.next; cur != EDGE; count += cur.len, cur = cur.next) {\n\t\t\t\tif (count > Q) break;\n\t\t\t\tif (count + cur.len <= P) continue;\n\t\t\t\tif (cur.start > R) continue;\n\t\t\t\tif (cur.start + cur.len - 1 <= R) {\n\t\t\t\t\tans += cur.len;\n\t\t\t\t} else {\n\t\t\t\t\tans += R - cur.start + 1;\n\t\t\t\t}\n\n\t\t\t}\n\t\t\tSystem.out.println(ans);\n\t\t}\n\t}\n\n\tstatic Node walk(Node cur, int count) {\n\t\tint sum = 0;\n\t\twhile (true) {\n\t\t\tsum += cur.len;\n\t\t\tif (sum == count) {\n\t\t\t\treturn cur.next;\n\t\t\t}\n\t\t\tif (sum > count) {\n\t\t\t\treturn cur.divide(cur.len - (sum - count));\n\t\t\t}\n\t\t\tcur = cur.next;\n\t\t}\n\t}\n\n\tstatic void exchange(Node xs, Node xe, Node zs, Node ze) {\n\t\tNode xp = xs.prev;\n\t\tNode xn = xe.next;\n\t\tNode zp = zs.prev;\n\t\tNode zn = ze.next;\n\t\txp.next = zs;\n\t\tzs.prev = xp;\n\t\txn.prev = ze;\n\t\tze.next = xn;\n\t\tzp.next = xs;\n\t\txs.prev = zp;\n\t\tzn.prev = xe;\n\t\txe.next = zn;\n\t}\n\n\tstatic class Node {\n\t\tNode prev, next;\n\t\tint start, len;\n\n\t\tNode(int start, int len) {\n\t\t\tthis.start = start;\n\t\t\tthis.len = len;\n\t\t}\n\n\t\tNode divide(int ns) {\n\t\t\tNode nn = new Node(start + ns, len - ns);\n\t\t\tthis.len = ns;\n\t\t\tthis.next.prev = nn;\n\t\t\tnn.next = this.next;\n\t\t\tnn.prev = this;\n\t\t\tthis.next = nn;\n\t\t\treturn nn;\n\t\t}\n\t}\n}"
  },
  {
    "language": "Java",
    "code": "import java.util.Arrays;\nimport java.util.LinkedList;\nimport java.util.Scanner;\n\npublic class Main {\n\t\n\tpublic static class Cards{\n\t\tint first, last;\n\n\t\tpublic Cards(int first, int last) {\n\t\t\tsuper();\n\t\t\tthis.first = first;\n\t\t\tthis.last = last;\n\t\t}\n\t\t\n\t\tpublic int getSize(){\n\t\t\treturn last - first + 1;\n\t\t}\n\t\t\n\t\tpublic int getLower(int l){\n\t\t\t//System.out.println(l + \" \" + first + \" \" + last);\n\t\t\t\n\t\t\tif(l < first){\n\t\t\t\treturn 0;\n\t\t\t}else{\n\t\t\t\t//System.out.println(l - first + 1);\n\t\t\t\treturn Math.min(last, l) - first + 1;\n\t\t\t}\n\t\t}\n\t\t\n\t\tpublic Cards split(int sp){\n\t\t\tif(sp < 0){\n\t\t\t\treturn null;\n\t\t\t}else if(sp > this.getSize()){\n\t\t\t\treturn null;\n\t\t\t}else if(sp == 0){\n\t\t\t\treturn this;\n\t\t\t}else if(sp == getSize()){\n\t\t\t\treturn this;\n\t\t\t}else{\n\t\t\t\tfinal int tmp_last = this.last;\n\t\t\t\tthis.last = this.first + sp - 1; \n\t\t\t\treturn new Cards(this.first + sp, tmp_last);\n\t\t\t}\n\t\t}\n\t\t\n\t\tpublic String toString(){\n\t\t\treturn this.first + \" \" + this.last;\n\t\t}\n\t}\n\t\n\tpublic static void split(LinkedList<Cards> main_list, int x, int y, LinkedList<Cards> a_list, LinkedList<Cards> b_list, LinkedList<Cards> c_list){\n\t\tint first = 1;\n\t\t\n\t\tfor(Cards cards : main_list){\n\t\t\t//System.out.println(x + \" \" + y );\n\t\t\t//System.out.println(main_list);\n\t\t\t//System.out.println(a_list);\n\t\t\t//System.out.println(b_list);\n\t\t\t//System.out.println(c_list);\n\t\t\t\n\t\t\tfinal int last = first + cards.getSize() - 1;\n\t\t\t//System.out.println(x + \" \" + y + \" : \" + first + \" \" + last + \" <> \" + cards);\n\t\t\t\n\t\t\tif(first <= x && last <= x){\n\t\t\t\ta_list.add(cards);\n\t\t\t}else if(first <= x){\n\t\t\t\tCards split = cards.split(x - first + 1);\n\t\t\t\t\n\t\t\t\ta_list.add(cards);\n\t\t\t\t\n\t\t\t\tif(last <= y){\n\t\t\t\t\tb_list.add(split);\n\t\t\t\t}else{\n\t\t\t\t\tCards split2 = split.split(y - x);\n\t\t\t\t\tb_list.add(split);\n\t\t\t\t\tc_list.add(split2);\n\t\t\t\t}\n\t\t\t}else if(first <= y && last <= y){\n\t\t\t\tb_list.add(cards);\n\t\t\t}else if(first <= y){\n\t\t\t\tCards split = cards.split(y - first + 1);\n\t\t\t\t\n\t\t\t\tb_list.add(cards);\n\t\t\t\tc_list.add(split);\n\t\t\t}else{\n\t\t\t\tc_list.add(cards);\n\t\t\t}\n\t\t\t\n\t\t\tfirst = last + 1;\n\t\t}\n\t}\n\n\tpublic static void main(String[] args) {\n\t\tScanner sc = new Scanner(System.in);\n\t\t\n\t\tLinkedList<Cards> list = new LinkedList<Cards>();\n\t\t\n\t\tLinkedList<Cards> a_list = new LinkedList<Main.Cards>();\n\t\tLinkedList<Cards> b_list = new LinkedList<Main.Cards>();\n\t\tLinkedList<Cards> c_list = new LinkedList<Main.Cards>();\n\t\t\n\t\twhile(true){\n\t\t\tfinal int n = sc.nextInt();\n\t\t\t\n\t\t\tif(n == 0){\n\t\t\t\tbreak;\n\t\t\t}\n\t\t\t\n\t\t\tlist.add(new Cards(1, n));\n\t\t\t\n\t\t\tfinal int m = sc.nextInt();\n\t\t\tfinal int p = sc.nextInt();\n\t\t\tfinal int q = sc.nextInt();\n\t\t\tfinal int r = sc.nextInt();\n\t\t\t\n\t\t\t\n\t\t\tfor(int i = 0; i < m; i++){\n\t\t\t\tfinal int x = sc.nextInt();\n\t\t\t\tfinal int y = sc.nextInt();\n\t\t\t\t\n\t\t\t\tsplit(list, x, y, a_list, b_list, c_list);\n\t\t\t\t\n\t\t\t\tlist.clear();\n\t\t\t\t\n\t\t\t\tlist.addAll(c_list);\n\t\t\t\tlist.addAll(b_list);\n\t\t\t\tlist.addAll(a_list);\n\t\t\t\t\n\t\t\t\ta_list.clear();\n\t\t\t\tb_list.clear();\n\t\t\t\tc_list.clear();\n\t\t\t}\n\t\t\t\n\t\t\tint sum = 0;\n\t\t\tsplit(list, p - 1, q, a_list, b_list, c_list);\n\t\t\t//System.out.println(a_list + \" \" + b_list + \" \" + c_list);\n\t\t\tfor(Cards cards : b_list){\n\t\t\t\tsum += cards.getLower(r);\n\t\t\t}\n\t\t\tSystem.out.println(sum);\n\t\t\t\n\n\t\t\tlist.clear();\n\t\t\ta_list.clear();\n\t\t\tb_list.clear();\n\t\t\tc_list.clear();\n\t\t\t\n\t\t\tSystem.gc();\n\t\t}\n\t}\n\n}"
  },
  {
    "language": "Java",
    "code": "import java.util.Arrays;\nimport java.util.LinkedList;\nimport java.util.Scanner;\n\npublic class Main {\n\t\n\tpublic static class Cards{\n\t\tint first, last;\n\n\t\tpublic Cards(int first, int last) {\n\t\t\tsuper();\n\t\t\tthis.first = first;\n\t\t\tthis.last = last;\n\t\t}\n\t\t\n\t\tpublic int getSize(){\n\t\t\treturn last - first + 1;\n\t\t}\n\t\t\n\t\tpublic int getLower(int l){\n\t\t\t//System.out.println(l + \" \" + first + \" \" + last);\n\t\t\t\n\t\t\tif(l < first){\n\t\t\t\treturn 0;\n\t\t\t}else{\n\t\t\t\t//System.out.println(l - first + 1);\n\t\t\t\treturn Math.min(last, l) - first + 1;\n\t\t\t}\n\t\t}\n\t\t\n\t\tpublic Cards[] split(int sp){\n\t\t\tif(sp < 0){\n\t\t\t\treturn new Cards[0];\n\t\t\t}else if(sp > this.getSize()){\n\t\t\t\treturn new Cards[0];\n\t\t\t}else if(sp == 0){\n\t\t\t\treturn new Cards[]{this};\n\t\t\t}else if(sp == getSize()){\n\t\t\t\treturn new Cards[]{this};\n\t\t\t}else{\n\t\t\t\treturn new Cards[]{new Cards(first, first + sp - 1), new Cards(first + sp, last)};\n\t\t\t}\n\t\t}\n\t\t\n\t\tpublic String toString(){\n\t\t\treturn this.first + \" \" + this.last;\n\t\t}\n\t}\n\t\n\tpublic static void split(LinkedList<Cards> main_list, int x, int y, LinkedList<Cards> a_list, LinkedList<Cards> b_list, LinkedList<Cards> c_list){\n\t\tint first = 1;\n\t\t\n\t\tfor(Cards cards : main_list){\n\t\t\t//System.out.println(x + \" \" + y );\n\t\t\t//System.out.println(main_list);\n\t\t\t//System.out.println(a_list);\n\t\t\t//System.out.println(b_list);\n\t\t\t//System.out.println(c_list);\n\t\t\t\n\t\t\tfinal int last = first + cards.getSize() - 1;\n\t\t\t//System.out.println(x + \" \" + y + \" : \" + first + \" \" + last + \" <> \" + cards);\n\t\t\t\n\t\t\tif(first <= x && last <= x){\n\t\t\t\ta_list.add(cards);\n\t\t\t}else if(first <= x){\n\t\t\t\tCards[] split = cards.split(x - first + 1);\n\t\t\t\t\n\t\t\t\ta_list.add(split[0]);\n\t\t\t\t\n\t\t\t\tif(last <= y){\n\t\t\t\t\tb_list.add(split[1]);\n\t\t\t\t}else{\n\t\t\t\t\tCards[] split2 = split[1].split(y - x);\n\t\t\t\t\tb_list.add(split2[0]);\n\t\t\t\t\tc_list.add(split2[1]);\n\t\t\t\t}\n\t\t\t}else if(first <= y && last <= y){\n\t\t\t\tb_list.add(cards);\n\t\t\t}else if(first <= y){\n\t\t\t\tCards[] split = cards.split(y - first + 1);\n\t\t\t\t\n\t\t\t\tb_list.add(split[0]);\n\t\t\t\tc_list.add(split[1]);\n\t\t\t}else{\n\t\t\t\tc_list.add(cards);\n\t\t\t}\n\t\t\t\n\t\t\tfirst = last + 1;\n\t\t}\n\t}\n\n\tpublic static void main(String[] args) {\n\t\tScanner sc = new Scanner(System.in);\n\n\t\twhile(true){\n\t\t\tfinal int n = sc.nextInt();\n\t\t\t\n\t\t\tif(n == 0){\n\t\t\t\tbreak;\n\t\t\t}\n\t\t\t\n\t\t\tLinkedList<Cards> list = new LinkedList<Cards>();\n\t\t\tlist.add(new Cards(1, n));\n\t\t\t\n\t\t\tfinal int m = sc.nextInt();\n\t\t\tfinal int p = sc.nextInt();\n\t\t\tfinal int q = sc.nextInt();\n\t\t\tfinal int r = sc.nextInt();\n\t\t\t\n\t\t\tLinkedList<Cards> a_list = new LinkedList<Main.Cards>();\n\t\t\tLinkedList<Cards> b_list = new LinkedList<Main.Cards>();\n\t\t\tLinkedList<Cards> c_list = new LinkedList<Main.Cards>();\n\t\t\tfor(int i = 0; i < m; i++){\n\t\t\t\tfinal int x = sc.nextInt();\n\t\t\t\tfinal int y = sc.nextInt();\n\t\t\t\t\n\t\t\t\tsplit(list, x, y, a_list, b_list, c_list);\n\t\t\t\t\n\t\t\t\tlist.clear();\n\t\t\t\t\n\t\t\t\tlist.addAll(c_list);\n\t\t\t\tlist.addAll(b_list);\n\t\t\t\tlist.addAll(a_list);\n\t\t\t\t\n\t\t\t\ta_list.clear();\n\t\t\t\tb_list.clear();\n\t\t\t\tc_list.clear();\n\t\t\t}\n\t\t\t\n\t\t\tint sum = 0;\n\t\t\tsplit(list, p - 1, q, a_list, b_list, c_list);\n\t\t\t//System.out.println(a_list + \" \" + b_list + \" \" + c_list);\n\t\t\tfor(Cards cards : b_list){\n\t\t\t\tsum += cards.getLower(r);\n\t\t\t}\n\t\t\tSystem.out.println(sum);\n\t\t}\n\t}\n\n}"
  },
  {
    "language": "Java",
    "code": "import java.util.Scanner;\n\npublic class Main{\n\tpublic static int[] shuffle(int[] n, int x, int y){\n\t\tint[] result = new int[n.length];\n\t\tfor(int i = 0; i < n.length-y; i++){\n\t\t\tresult[i] = n[i+y];\n\t\t}\n\t\tfor(int i = n.length-y; i < n.length-x; i++){\n\t\t\tresult[i] = n[i-n.length+y+x];\n\t\t}\n\t\tfor(int i = n.length-x; i < n.length; i++){\n\t\t\tresult[i] = n[i-n.length+x];\n\t\t}\n\t\treturn result;\n\t}\n\t\n\tpublic static int solve(int[] n, int p, int q, int r){\n\t\tint count = 0;\n\t\tfor(int i = p-1; i < q; i++){\n\t\t\tif( n[i] <= r ){\n\t\t\t\tcount++;\n\t\t\t}\n\t\t}\n\t\treturn count;\n\t}\n\t\n\tpublic static void main(String[] args){\n\t\tScanner stdIn = new Scanner(System.in);\n\t\tint[] result = new int[100];\n\t\tint index = 0;\n\t\t\n\t\tint n = stdIn.nextInt();\n\t\twhile( n != 0 ){\n\t\t\tint m = stdIn.nextInt();\n\t\t\tint p = stdIn.nextInt();\n\t\t\tint q = stdIn.nextInt();\n\t\t\tint r = stdIn.nextInt();\n\t\t\t\n\t\t\tint[] x = new int[m];\n\t\t\tint[] y = new int[m];\n\t\t\tfor(int i = 0; i < m; i++){\n\t\t\t\tx[i] = stdIn.nextInt();\n\t\t\t\ty[i] = stdIn.nextInt();\n\t\t\t}\n\t\t\t\n\t\t\tint[] card = new int[n];\n\t\t\tfor(int i = 0; i < n; i++){\n\t\t\t\tcard[i] = i+1;\n\t\t\t}\n\t\t\tfor(int i = 0; i < m; i++){\n\t\t\t\tcard = shuffle(card, x[i], y[i]);\n\t\t\t}\n\t\t\t\n\t\t/*\tfor(int i = 0; i < n; i++){\n\t\t\t\tSystem.out.print(card[i] + \" \");\n\t\t\t}\n\t\t\tSystem.out.println();*/\n\t\t\tresult[index] = solve(card, p, q, r);\n\t\t\tindex++;\n\t\t\tn = stdIn.nextInt();\n\t\t}\n\t\t\n\t\tfor(int i = 0; i < index; i++){\n\t\t\tSystem.out.println(result[i]);\n\t\t}\n\t}\n}"
  },
  {
    "language": "Java",
    "code": "import java.util.LinkedList;\nimport java.util.Scanner;\n\n//Shuffle\npublic class Main{\n\n\tclass R implements Comparable<R>{\n\t\tint s, t;\n\t\tpublic R(int s, int t) {\n\t\t\tthis.s = s;\n\t\t\tthis.t = t;\n\t\t}\n\t\tpublic int compareTo(R o) {\n\t\t\treturn s-o.s;\n\t\t}\n\t}\n\t\n\tvoid run(){\n\t\tScanner sc = new Scanner(System.in);\n\t\tfor(;;){\n\t\t\tint n = sc.nextInt();\n\t\t\tif(n==0)break;\n\t\t\tint m = sc.nextInt(), p = sc.nextInt(), q = sc.nextInt(), r = sc.nextInt();\n\t\t\tint[] ps = new int[m], qs = new int[m];\n\t\t\tfor(int i=0;i<m;i++){\n\t\t\t\tps[i] = sc.nextInt(); qs[i] = sc.nextInt();\n\t\t\t}\n\t\t\tLinkedList<R> l = new LinkedList<R>();\n\t\t\tl.add(new R(p, q));\n\t\t\tfor(int Q=m-1;Q>=0;Q--){\n\t\t\t\tint x = ps[Q], y = qs[Q];\n\t\t\t\tLinkedList<R> next = new LinkedList<R>();\n\t\t\t\tfor(int i=0;i<l.size();i++){\n\t\t\t\t\tR v = l.get(i);\n\t\t\t\t\tif(v.t<=n-y)next.add(new R(v.s+y, v.t+y));\n\t\t\t\t\telse if(v.s<=n-y){\n\t\t\t\t\t\tl.remove(i); l.add(i, new R(n-y+1, v.t)); i--;\n\t\t\t\t\t\tnext.add(new R(v.s+y, n));\n\t\t\t\t\t}\n\t\t\t\t\telse if(v.t<=n-x){\n\t\t\t\t\t\tnext.add(new R(v.s+x+y-n, v.t+x-n+y));\n\t\t\t\t\t}\n\t\t\t\t\telse if(v.s<=n-x){\n\t\t\t\t\t\tl.remove(i); l.add(i, new R(n-x+1, v.t)); i--;\n\t\t\t\t\t\tnext.add(new R(v.s+x+y-n, y));\n\t\t\t\t\t}\n\t\t\t\t\telse next.add(new R(v.s+x-n, v.t+x-n));\n\t\t\t\t}\n//\t\t\t\tCollections.sort(next);\n//\t\t\t\tfor(int i=0;i+1<next.size();i++){\n//\t\t\t\t\tif(next.get(i).t+1==next.get(i+1).s){\n//\t\t\t\t\t\tR v = new R(next.get(i).s, next.get(i+1).t);\n//\t\t\t\t\t\tnext.remove(i); next.remove(i); next.add(i, v); i--;\n//\t\t\t\t\t}\n//\t\t\t\t}\n\t\t\t\tl = next;\n\t\t\t}\n\t\t\tint res = 0;\n\t\t\tfor(R v:l){\n\t\t\t\tif(v.t<=r)res+=v.t-v.s+1;\n\t\t\t\telse if(v.s<=r)res+=r-v.s+1;\n\t\t\t}\n\t\t\tSystem.out.println(res);\n\t\t}\n\t}\n\t\n\tpublic static void main(String[] args) {\n\t\tnew Main().run();\n\t}\n}"
  },
  {
    "language": "Java",
    "code": "import java.io.File;\nimport java.io.FileNotFoundException;\nimport java.util.ArrayList;\nimport java.util.Collections;\nimport java.util.Comparator;\nimport java.util.List;\nimport java.util.Scanner;\n\npublic class Main {\n\n\tpublic static void main(String[] args) throws FileNotFoundException {\n\n\t\tScanner scan = new Scanner(System.in);\n\t\t// Scanner scan = new Scanner(new\n\t\t// File(\"D:\\\\UserArea\\\\J0124567\\\\Downloads\\\\0536-input.txt\"));\n\n\t\twhile (scan.hasNext()) {\n\n\t\t\tint n = scan.nextInt();\n\t\t\tif (n == 0)\n\t\t\t\tbreak;\n\t\t\tint m = scan.nextInt();\n\t\t\tint p = scan.nextInt();\n\t\t\tint q = scan.nextInt();\n\t\t\tint r = scan.nextInt();\n\n\t\t\tCard c = new Card(n);\n\t\t\tfor (int i = 0; i < m; i++) {\n\t\t\t\tc.shuffle(scan.nextInt(), scan.nextInt());\n\t\t\t\t// c.print();\n\t\t\t}\n\n\t\t\tSystem.out.println(c.count(p, q, r));\n\t\t}\n\n\t\tscan.close();\n\t\tSystem.exit(0);\n\n\t}\n}\n\nclass Card {\n\tclass Bulk {\n\t\tpublic Bulk(int _st, int _pcs) {\n\t\t\tst = _st;\n\t\t\tpcs = _pcs;\n\t\t}\n\n\t\tint st;\n\t\tint pcs;\n\t}\n\n\tList<Bulk> bulk = new ArrayList<Bulk>();\n\n\tpublic Card(int n) {\n\t\tbulk.add(new Bulk(1, n));\n\t}\n\n\tpublic void print() {\n\t\tfor (int i = 0; i < bulk.size(); i++) {\n\t\t\tfor (int c = 0; c < bulk.get(i).pcs; c++)\n\t\t\t\tSystem.out.print(\" \" + (bulk.get(i).st + c));\n\t\t}\n\t\tSystem.out.println();\n\t}\n\n\tpublic int count(int p, int q, int r) {\n\t\tint pcs = 0;\n\t\tint cto = 0;\n\t\tint cfr;\n\t\tfor (int i = 0; i < bulk.size(); i++) {\n\t\t\tcfr = cto + 1;\n\t\t\tcto += bulk.get(i).pcs;\n\t\t\tif (cfr > q)\n\t\t\t\tbreak;\n\t\t\tif (cto < p)\n\t\t\t\tcontinue;\n\t\t\tint a, b;\n\t\t\tif (cfr < p)\n\t\t\t\ta = p - cfr;\n\t\t\telse\n\t\t\t\ta = 0;\n\t\t\tif (cto > q)\n\t\t\t\tb = bulk.get(i).pcs - (cto - q) - 1;\n\t\t\telse\n\t\t\t\tb = bulk.get(i).pcs - 1;\n\t\t\tif (bulk.get(i).st + a <= r)\n\t\t\t\tif (bulk.get(i).st + b <= r)\n\t\t\t\t\tpcs += (b - a + 1);\n\t\t\t\telse\n\t\t\t\t\tpcs += (r - (bulk.get(i).st + a) + 1);\n\n\t\t}\n\t\treturn pcs;\n\t}\n\n\tpublic void shuffle(int x, int y) {\n\t\tthis.moveLast(x + 1, y);\n\t\tthis.moveLast(1, x);\n\t}\n\n\tprivate void moveLast(int fr, int to) {\n\t\tint i = 0;\n\t\tint cfr;\n\t\tint cto = 0;\n\t\twhile (i < bulk.size()) {\n\t\t\tcfr = cto + 1;\n\t\t\tcto += bulk.get(i).pcs;\n\t\t\tif (cto < fr) {\n\t\t\t\ti++;\n\t\t\t\tcontinue;\n\t\t\t}\n\t\t\tif (cto <= to) {\n\t\t\t\tif (cfr < fr) {\n\t\t\t\t\tbulk.add(new Bulk(bulk.get(i).st + (fr - cfr), cto - fr + 1));\n\t\t\t\t\tbulk.get(i).pcs -= (cto - fr + 1);\n\t\t\t\t\ti++;\n\t\t\t\t\tcontinue;\n\t\t\t\t} else {\n\t\t\t\t\tbulk.add(new Bulk(bulk.get(i).st, bulk.get(i).pcs));\n\t\t\t\t\tbulk.remove(i);\n\t\t\t\t\tcontinue;\n\t\t\t\t}\n\t\t\t} else {\n\t\t\t\tif (cfr < fr) {\n\t\t\t\t\tbulk.add(new Bulk(bulk.get(i).st + (fr - cfr), to - fr + 1));\n\t\t\t\t\tbulk.add(i, new Bulk(bulk.get(i).st, fr - cfr));\n\t\t\t\t\tbulk.get(i + 1).st += (to - cfr + 1);\n\t\t\t\t\tbulk.get(i + 1).pcs -= (to - cfr + 1);\n\t\t\t\t\tbreak;\n\t\t\t\t} else {\n\t\t\t\t\tbulk.add(new Bulk(bulk.get(i).st, to - cfr + 1));\n\t\t\t\t\tbulk.get(i).st += (to - cfr + 1);\n\t\t\t\t\tbulk.get(i).pcs -= (to - cfr + 1);\n\t\t\t\t\tbreak;\n\t\t\t\t}\n\t\t\t}\n\n\t\t}\n\t}\n}"
  },
  {
    "language": "Java",
    "code": "import java.util.*;\nimport java.lang.*;\nimport java.math.*;\nimport java.io.*;\n\nimport static java.lang.Math.*;\nimport static java.util.Arrays.*;\nimport static java.util.Collections.*;\n\n// AC\npublic class Main{\n\n\tBufferedReader br=new BufferedReader(new InputStreamReader(System.in));\n\n\tint INF=1<<28;\n\tdouble EPS=1e-12;\n\n\tint n, m;\n\tint p, q, r;\n\tint[] x, y;\n\n\tvoid run(){\n\t\ttry{\n\t\t\tfor(;;){\n\t\t\t\tn=Integer.parseInt(br.readLine());\n\t\t\t\tif(n==0){\n\t\t\t\t\tbreak;\n\t\t\t\t}\n\t\t\t\tm=Integer.parseInt(br.readLine());\n\t\t\t\tString[] ss=br.readLine().split(\" \");\n\t\t\t\tp=Integer.parseInt(ss[0]);\n\t\t\t\tq=Integer.parseInt(ss[1]);\n\t\t\t\tr=Integer.parseInt(ss[2]);\n\t\t\t\tx=new int[m];\n\t\t\t\ty=new int[m];\n\t\t\t\tfor(int i=0; i<m; i++){\n\t\t\t\t\tss=br.readLine().split(\" \");\n\t\t\t\t\tx[i]=Integer.parseInt(ss[0]);\n\t\t\t\t\ty[i]=Integer.parseInt(ss[1]);\n\t\t\t\t}\n\t\t\t\tsolve();\n\t\t\t}\n\t\t}catch(IOException e){\n\t\t}\n\t}\n\n\tlong[] cards=new long[20000];\n\tlong[] a=new long[20000];\n\tlong[] b=new long[20000];\n\tlong[] c=new long[20000];\n\t\n\tvoid solve(){\n\t\t// long[] cards=new long[20000];\n\t\tint nCards=0;\n\t\tcards[nCards++]=hoge(1, n+1);\n\t\t// long[] a=new long[20000];\n\t\t// long[] b=new long[20000];\n\t\t// long[] c=new long[20000];\n\t\tfor(int k=0; k<m; k++){\n\t\t\tint ai=0, bi=0, ci=0;\n\t\t\tint left=0, right=0;\n\t\t\tfor(int i=0; i<nCards; i++){\n\t\t\t\tint offset=(int)cards[i];\n\t\t\t\tint len=(int)(cards[i]>>>32);\n\t\t\t\tright+=len;\n\t\t\t\tboolean xCut=left<x[k]&&x[k]<right;\n\t\t\t\tboolean yCut=left<y[k]&&y[k]<right;\n\t\t\t\tif(xCut&&yCut){\n\t\t\t\t\ta[ai++]=hoge(offset, offset+x[k]-left);\n\t\t\t\t\tb[bi++]=hoge(offset+x[k]-left, offset+y[k]-left);\n\t\t\t\t\tc[ci++]=hoge(offset+y[k]-left, offset+len);\n\t\t\t\t}else if(xCut){\n\t\t\t\t\ta[ai++]=hoge(offset, offset+x[k]-left);\n\t\t\t\t\tb[bi++]=hoge(offset+x[k]-left, offset+len);\n\t\t\t\t}else if(yCut){\n\t\t\t\t\tb[bi++]=hoge(offset, offset+y[k]-left);\n\t\t\t\t\tc[ci++]=hoge(offset+y[k]-left, offset+len);\n\t\t\t\t}else{\n\t\t\t\t\tif(right<=x[k]){\n\t\t\t\t\t\ta[ai++]=cards[i];\n\t\t\t\t\t}else if(right<=y[k]){\n\t\t\t\t\t\tb[bi++]=cards[i];\n\t\t\t\t\t}else{\n\t\t\t\t\t\tc[ci++]=cards[i];\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t\tleft=right;\n\t\t\t}\n\t\t\tnCards=0;\n\t\t\tfor(int i=0; i<ci; i++){\n\t\t\t\tcards[nCards++]=c[i];\n\t\t\t}\n\t\t\tfor(int i=0; i<bi; i++){\n\t\t\t\tcards[nCards++]=b[i];\n\t\t\t}\n\t\t\tfor(int i=0; i<ai; i++){\n\t\t\t\tcards[nCards++]=a[i];\n\t\t\t}\n\t\t}\n\t\tp--;\n\t\tq--;\n\t\t// [p, q]ªrÈº=[p, q+1)ªrÈº\n\t\tint ans=0;\n\t\tq++;\n\t\tint left=0, right=0;\n\t\tfor(int k=0; k<nCards; k++){\n\t\t\tint offset=(int)cards[k];\n\t\t\tint len=(int)(cards[k]>>>32);\n\t\t\tright+=len;\n\t\t\tif(left<=q&&p<=right){\n\t\t\t\tint min=max(left, p)-left+offset;\n\t\t\t\tint max=min(right, q)-left+offset;\n\t\t\t\t// [i, j)ÅrÈºÌàÌÍH=[i, j)År+1¢ÌàÌÍH\n\t\t\t\tmax=min(max, r+1);\n\t\t\t\tans+=max(max-min, 0);\n\t\t\t}\n\t\t\tleft=right;\n\t\t}\n\t\tprintln(ans+\"\");\n\t}\n\n\tlong hoge(long left, long right){\n\t\tlong offset=left;\n\t\tlong len=right-left;\n\t\treturn (len<<32)|offset;\n\t}\n\n\tvoid debug(Object... os){\n\t\tSystem.err.println(Arrays.deepToString(os));\n\t}\n\n\tvoid print(String s){\n\t\tSystem.out.print(s);\n\t}\n\n\tvoid println(String s){\n\t\tSystem.out.println(s);\n\t}\n\n\tpublic static void main(String[] args){\n\t\tSystem.setOut(new PrintStream(new BufferedOutputStream(System.out)));\n\t\tnew Main().run();\n\t\tSystem.out.close();\n\t}\n}"
  },
  {
    "language": "Java",
    "code": "import java.util.ArrayList;\nimport java.util.Collections;\nimport java.util.Comparator;\nimport java.util.List;\n\n//Shuffle\npublic class Main{\n\n\tclass Scanner {\n\t\tint nextInt() {\n\t\t\ttry {\n\t\t\t\tint c = System.in.read();\n\t\t\t\twhile (c != '-' && (c < '0' || '9' < c))\n\t\t\t\t\tc = System.in.read();\n\t\t\t\tif (c == '-') return -nextInt();\n\t\t\t\tint res = 0;\n\t\t\t\tdo {\n\t\t\t\t\tres *= 10;\n\t\t\t\t\tres += c - '0';\n\t\t\t\t\tc = System.in.read();\n\t\t\t\t} while ('0' <= c && c <= '9');\n\t\t\t\treturn res;\n\t\t\t} catch (Exception e) {\n\t\t\t\treturn -1;\n\t\t\t}\n\t\t}\n\t}\n\n\tvoid run(){\n\t\tScanner sc = new Scanner();\n\t\tlong mask = (1L << 32)-1;\n\t\tComparator<Long> C = new Comparator<Long>() {\n\t\t\tpublic int compare(Long o1, Long o2) {\n\t\t\t\treturn (int) ((o1>>32)-(o2>>32));\n\t\t\t}\n\t\t};\n\t\tint[] p = new int[5000], q = new int[5000];\n\t\tfor(;;){\n\t\t\tint n = sc.nextInt();\n\t\t\tif(n==0)break;\n//\t\t\t            long T = System.currentTimeMillis();\n\t\t\tint m = sc.nextInt(), P = sc.nextInt(), Q = sc.nextInt(), R = sc.nextInt();\n\t\t\tList<Long> l = new ArrayList<Long>();\n\t\t\tl.add(((long)P<<32)|Q);\n\t\t\tfor(int i=0;i<m;i++){\n\t\t\t\tp[i] = sc.nextInt(); q[i] = sc.nextInt();\n\t\t\t}\n//\t\t\tboolean f = true;\n\t\t\tfor(int i=m-1;i>=0;i--){\n\t\t\t\tlong t1 = n-q[i], s2 = t1+1, t2 = n-p[i], s3 = n-p[i]+1, y = q[i];\n\t\t\t\tList<Long> next = new ArrayList<Long>();\n\t\t\t\tfor(int j=0;j<l.size();j++){\n\t\t\t\t\tlong x = l.get(j);\n\t\t\t\t\tlong s = x>>32, t = x&mask;\n\t\t\t\t\tif(t<=t1){\n\t\t\t\t\t\tnext.add((s+y)<<32 | (t+y));\n\t\t\t\t\t}\n\t\t\t\t\telse if(t<=t2){\n\t\t\t\t\t\tif(s<=t1){\n\t\t\t\t\t\t\tnext.add((s+y)<<32 | (t1+y));\n\t\t\t\t\t\t\ts = s2;\n\t\t\t\t\t\t}\n\t\t\t\t\t\tnext.add((s-s2+p[i]+1)<<32 | (t-s2+p[i]+1));\n\t\t\t\t\t}\n\t\t\t\t\telse{\n\t\t\t\t\t\tif(s<=t1){\n\t\t\t\t\t\t\tnext.add((s+y)<<32 | (t1+y));\n\t\t\t\t\t\t\ts = s2;\n\t\t\t\t\t\t}\n\t\t\t\t\t\tif(s<=t2){\n\t\t\t\t\t\t\tnext.add((s-s2+p[i]+1)<<32 | (t2-s2+p[i]+1));\n\t\t\t\t\t\t\ts = s3;\n\t\t\t\t\t\t}\n\t\t\t\t\t\tnext.add((s-s3+1)<<32 | (t-s3+1));\n\t\t\t\t\t}\n\t\t\t\t}\n//\t\t\t\tif(f&&next.size()>=1000){\n//\t\t\t\t\tSystem.out.println(\"I:\"+i); f = false;\n//\t\t\t\t}\n\t\t\t\tif(1000<=next.size()){\n\t\t\t\t\tl = new ArrayList<Long>();\n\t\t\t\t\tCollections.sort(next, C);\n\t\t\t\t\tlong ss = next.get(0)>>32, tt = next.get(0)&mask;\n\t\t\t\t\tfor(int j=1;j<next.size();j++){\n\t\t\t\t\t\tlong x = next.get(j);\n\t\t\t\t\t\tlong s = x>>32, t = x&mask;\n\t\t\t\t\t\tif(tt+1==s)tt = t;\n\t\t\t\t\t\telse{\n\t\t\t\t\t\t\tl.add((ss<<32)|tt);\n\t\t\t\t\t\t\tss = s; tt = t;\n\t\t\t\t\t\t}\n\t\t\t\t\t}\n\t\t\t\t\tl.add((ss<<32)|tt);\n\t\t\t\t}\n\t\t\t\telse{\n\t\t\t\t\tl = next;\n\t\t\t\t\tCollections.sort(l, C);\n\t\t\t\t}\n\t\t\t}\n\t\t\tint res = 0;\n\t\t\tfor(long x:l){\n\t\t\t\tlong s = x>>32, t = x&mask;\n\t\t\t\tif(R<s)break;\n\t\t\t\tif(R<t)t = R;\n\t\t\t\tres+=t-s+1;\n\t\t\t}\n\t\t\tSystem.out.println(res);\n//\t\t\t            System.out.println((System.currentTimeMillis()-T)+\" ms.\");\n\t\t}\n\t}\n\n\tpublic static void main(String[] args) {\n\t\tnew Main().run();\n\t}\n}"
  },
  {
    "language": "Java",
    "code": "import java.util.Scanner;\npublic class Main{\n\tpublic static void main(String[] args){\n\t\tScanner scan = new Scanner(System.in);\n\t\twhile(scan.hasNext()){\n\t\t\tint n = scan.nextInt();\n\t\t\tif(n == 0){\n\t\t\t\tbreak;\n\t\t\t}\n\t\t\tint m = scan.nextInt();\n\t\t\tint p = scan.nextInt();\n\t\t\tint q = scan.nextInt();\n\t\t\tint r = scan.nextInt();\n\t\t\tint[] card = new int[n];\n\t\t\tfor(int i = 0;i < n;i++){\n\t\t\t\tcard[i] = i+1;\n\t\t\t}\n\t\t\tfor(int i = 0;i < m;i++){\n\t\t\t\tcard = shuffle(card,scan.nextInt(),scan.nextInt(),n);\n\t\t\t}\n\t\t\tint count = 0;\n\t\t\tfor(int i = p-1;i < q;i++){\n\t\t\t\tif(card[i] <= r){\n\t\t\t\t\tcount++;\n\t\t\t\t}\n\t\t\t}\n\t\t\tSystem.out.println(count);\n\t\t}\n\t}\n\t\n\tpublic static int[] shuffle(int[] a,int x,int y,int n){\n\t\tint[] ans = new int[n];\n\t\tfor(int i = 0;i < n-y;i++){\n\t\t\tans[i] = a[i+y];\n\t\t}\n\t\tfor(int i = 0;i < y-x;i++){\n\t\t\tans[n-y+i] = a[i+x];\n\t\t}\n\t\tfor(int i = 0;i < x;i++){\n\t\t\tans[n-x+i] = a[i];\n\t\t}\n\t\treturn ans;\n\t}\n}"
  },
  {
    "language": "Java",
    "code": "import java.util.Arrays;\nimport java.util.LinkedList;\nimport java.util.Scanner;\n\npublic class Main {\n\n\tpublic static void split(LinkedList<Integer> list_first,\n\t\t\tLinkedList<Integer> list_last, int x, int y,\n\t\t\tLinkedList<Integer> a_list_first, LinkedList<Integer> a_list_last,\n\t\t\tLinkedList<Integer> b_list_first, LinkedList<Integer> b_list_last,\n\t\t\tLinkedList<Integer> c_list_first, LinkedList<Integer> c_list_last) {\n\n\t\tint first = 1;\n\n\t\twhile (!list_first.isEmpty()) {\n\t\t\tfinal int card_first = list_first.poll();\n\t\t\tfinal int card_last = list_last.poll();\n\n\t\t\tfinal int last = first + (card_last - card_first);\n\n\t\t\t//System.out.println(x + \" \" + y + \" \" + first + \" \" + last + \" \"\n\t\t\t//\t\t+ card_first + \" \" + card_last);\n\n\t\t\tif (first <= x && last <= x) {\n\t\t\t\ta_list_first.add(card_first);\n\t\t\t\ta_list_last.add(card_last);\n\t\t\t} else if (first <= x) {\n\t\t\t\tfinal int sp1 = x - first + 1;\n\n\t\t\t\ta_list_first.add(card_first);\n\t\t\t\ta_list_last.add(card_first + sp1 - 1);\n\n\t\t\t\tif (last <= y) {\n\t\t\t\t\tb_list_first.add(card_first + sp1);\n\t\t\t\t\tb_list_last.add(card_last);\n\t\t\t\t} else {\n\t\t\t\t\tfinal int sp2 = y - x;\n\n\t\t\t\t\tb_list_first.add(card_first + sp1);\n\t\t\t\t\tb_list_last.add(card_first + sp1 + sp2 - 1);\n\n\t\t\t\t\tc_list_first.add(card_first + sp1 + sp2);\n\t\t\t\t\tc_list_last.add(card_last);\n\t\t\t\t}\n\n\t\t\t} else if (first <= y && last <= y) {\n\t\t\t\tb_list_first.add(card_first);\n\t\t\t\tb_list_last.add(card_last);\n\n\t\t\t} else if (first <= y) {\n\t\t\t\tfinal int sp1 = y - first + 1;\n\n\t\t\t\tb_list_first.add(card_first);\n\t\t\t\tb_list_last.add(card_first + sp1 - 1);\n\n\t\t\t\tc_list_first.add(card_first + sp1);\n\t\t\t\tc_list_last.add(card_last);\n\t\t\t} else {\n\t\t\t\tc_list_first.add(card_first);\n\t\t\t\tc_list_last.add(card_last);\n\t\t\t}\n\n\t\t\tfirst = last + 1;\n\t\t}\n\t}\n\n\tpublic static void main(String[] args) {\n\t\tScanner sc = new Scanner(System.in);\n\n\t\tLinkedList<Integer> list_first = new LinkedList<Integer>();\n\t\tLinkedList<Integer> list_last = new LinkedList<Integer>();\n\t\tLinkedList<Integer> a_list_first = new LinkedList<Integer>();\n\t\tLinkedList<Integer> a_list_last = new LinkedList<Integer>();\n\t\tLinkedList<Integer> b_list_first = new LinkedList<Integer>();\n\t\tLinkedList<Integer> b_list_last = new LinkedList<Integer>();\n\t\tLinkedList<Integer> c_list_first = new LinkedList<Integer>();\n\t\tLinkedList<Integer> c_list_last = new LinkedList<Integer>();\n\n\t\twhile (true) {\n\t\t\tfinal int n = sc.nextInt();\n\n\t\t\tif (n == 0) {\n\t\t\t\tbreak;\n\t\t\t}\n\n\t\t\tlist_first.add(1);\n\t\t\tlist_last.add(n);\n\n\t\t\tfinal int m = sc.nextInt();\n\t\t\tfinal int p = sc.nextInt();\n\t\t\tfinal int q = sc.nextInt();\n\t\t\tfinal int r = sc.nextInt();\n\n\t\t\tfor (int i = 0; i < m; i++) {\n\t\t\t\tfinal int x = sc.nextInt();\n\t\t\t\tfinal int y = sc.nextInt();\n\n\t\t\t\t//System.out.println(list_first + \" \" + list_last);\n\t\t\t\tsplit(list_first, list_last, x, y, a_list_first, a_list_last,\n\t\t\t\t\t\tb_list_first, b_list_last, c_list_first, c_list_last);\n\n\t\t\t\tlist_first.addAll(c_list_first);\n\t\t\t\tlist_last.addAll(c_list_last);\n\t\t\t\tlist_first.addAll(b_list_first);\n\t\t\t\tlist_last.addAll(b_list_last);\n\t\t\t\tlist_first.addAll(a_list_first);\n\t\t\t\tlist_last.addAll(a_list_last);\n\n\t\t\t\ta_list_first.clear();\n\t\t\t\ta_list_last.clear();\n\t\t\t\tb_list_first.clear();\n\t\t\t\tb_list_last.clear();\n\t\t\t\tc_list_first.clear();\n\t\t\t\tc_list_last.clear();\n\t\t\t}\n\n\t\t\t//System.out.println(list_first);\n\t\t\t//System.out.println(list_last);\n\n\t\t\tint sum = 0;\n\t\t\tsplit(list_first, list_last, p - 1, q, a_list_first, a_list_last,\n\t\t\t\t\tb_list_first, b_list_last, c_list_first, c_list_last);\n\t\t\t// System.out.println(a_list + \" \" + b_list + \" \" + c_list);\n\t\t\twhile (!b_list_first.isEmpty()) {\n\t\t\t\tfinal int first = b_list_first.poll();\n\t\t\t\tfinal int last = b_list_last.poll();\n\n\t\t\t\t//System.out.println(first + \" : \" + last);\n\n\t\t\t\tsum += Math.max(0, Math.min(last, r) - first + 1);\n\t\t\t}\n\t\t\tSystem.out.println(sum);\n\n\t\t\ta_list_first.clear();\n\t\t\ta_list_last.clear();\n\t\t\tb_list_first.clear();\n\t\t\tb_list_last.clear();\n\t\t\tc_list_first.clear();\n\t\t\tc_list_last.clear();\n\t\t\t\n\t\t\tSystem.gc();\n\t\t}\n\t}\n\n}"
  },
  {
    "language": "Java",
    "code": "import java.util.Scanner;\n\npublic class Main{\n\tpublic static int[] shuffle(int[] n, int x, int y){\n\t\tint[] result = new int[n.length];\n\t\tfor(int i = 0; i < n.length-y; i++){\n\t\t\tresult[i] = n[i+y];\n\t\t}\n\t\tfor(int i = n.length-y; i < n.length-x; i++){\n\t\t\tresult[i] = n[i-n.length+y+x];\n\t\t}\n\t\tfor(int i = n.length-x; i < n.length; i++){\n\t\t\tresult[i] = n[i-n.length+x];\n\t\t}\n\t\treturn result;\n\t}\n\t\n\tpublic static int solve(int[] n, int p, int q, int r){\n\t\tint count = 0;\n\t\tfor(int i = p-1; i < q; i++){\n\t\t\tif( n[i] <= r ){\n\t\t\t\tcount++;\n\t\t\t}\n\t\t}\n\t\treturn count;\n\t}\n\t\n\tpublic static void main(String[] args){\n\t\tScanner stdIn = new Scanner(System.in);\n\t\tint[] result = new int[100];\n\t\tint index = 0;\n\t\t\n\t\tint n = stdIn.nextInt();\n\t\twhile( n != 0 ){\n\t\t\tint m = stdIn.nextInt();\n\t\t\tint p = stdIn.nextInt();\n\t\t\tint q = stdIn.nextInt();\n\t\t\tint r = stdIn.nextInt();\n\t\t\t\n\t\t\tint[] x = new int[m];\n\t\t\tint[] y = new int[m];\n\t\t\tfor(int i = 0; i < m; i++){\n\t\t\t\tx[i] = stdIn.nextInt();\n\t\t\t\ty[i] = stdIn.nextInt();\n\t\t\t}\n\t\t\t\n\t\t\tint[] card = new int[n];\n\t\t\tfor(int i = 0; i < n; i++){\n\t\t\t\tcard[i] = i+1;\n\t\t\t}\n\t\t\tfor(int i = 0; i < m; i++){\n\t\t\t\tcard = shuffle(card, x[i], y[i]);\n\t\t\t}\n\t\t\t\n\t\t/*\tfor(int i = 0; i < n; i++){\n\t\t\t\tSystem.out.print(card[i] + \" \");\n\t\t\t}\n\t\t\tSystem.out.println();*/\n\t\t\tresult[index] = solve(card, p, q, r);\n\t\t\tindex++;\n\t\t\tn = stdIn.nextInt();\n\t\t}\n\t\t\n\t\tfor(int i = 0; i < index; i++){\n\t\t\tSystem.out.println(result[i]);\n\t\t}\n\t}\n}"
  },
  {
    "language": "Java",
    "code": "// run# 2215108\nimport java.io.BufferedReader;\nimport java.io.IOException;\nimport java.io.InputStreamReader;\n\npublic class Main {\n\tpublic static int hitnum(int a0, int a1, int r){\n\t\tif(a1<=r){\n\t\t\treturn a1-a0+1;\n\t\t}else if(a0<=r){\n\t\t\treturn r-a0+1;\n\t\t}else{\n\t\t\treturn 0;\n\t\t}\n\t}\n\n\n\tpublic static void main(String[] args)throws IOException {\n\t\tBufferedReader br = new BufferedReader(new InputStreamReader(System.in));\n\t\twhile(true){\n\t\t\tint n = Integer.parseInt(br.readLine());\n\t\t\tif(n==0) break;\n\t\t\tint m = Integer.parseInt(br.readLine());\n\t\t\tint deck[][][] = new int [2][2*m+3][2];\n\t\t\tdeck[0][0][0] = 1;\n\t\t\tdeck[0][0][1] = n;\n\n\t\t\tString line[] = br.readLine().split(\" \");\n\t\t\tint p = Integer.parseInt(line[0]);\n\t\t\tint q = Integer.parseInt(line[1]);\n\t\t\tint r = Integer.parseInt(line[2]);\n\n\t\t\tfor(int im=0; im<m; im++){\n\t\t\t\tString query[] = br.readLine().split(\" \");\n\t\t\t\tint x = Integer.parseInt(query[0]);\n\t\t\t\tint y = Integer.parseInt(query[1]);\n\n\t\t\t\tint cntr = 0;\n\t\t\t\tint i = 0;\n\t\t\t\tint[] sectiona = {0,0};\n\t\t\t\tint[] sectionb = {0,0};\n\n\t\t\t\twhile(cntr < x){\n\t\t\t\t\tint nextsize = deck[0][i][1] - deck[0][i][0] + 1;\n\t\t\t\t\tif(x-cntr >= nextsize){\n\t\t\t\t\t\tcntr += nextsize;\n\t\t\t\t\t\ti++;\n\t\t\t\t\t}else{\n\t\t\t\t\t\tsectiona[0] = deck[0][i][0];\n\t\t\t\t\t\tsectiona[1] = deck[0][i][0] + x-cntr -1;\n\t\t\t\t\t\tdeck[0][i][0] += x-cntr;\n\t\t\t\t\t\tcntr = x;\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t\tint memoa = i;\n\t\t\t\twhile(cntr < y){\n\t\t\t\t\tint nextsize = deck[0][i][1] - deck[0][i][0] + 1;\n\t\t\t\t\tif(y-cntr >= nextsize){\n\t\t\t\t\t\tcntr += nextsize;\n\t\t\t\t\t\ti++;\n\t\t\t\t\t}else{\n\t\t\t\t\t\tsectionb[0] = deck[0][i][0];\n\t\t\t\t\t\tsectionb[1] = deck[0][i][0] + y-cntr -1;\n\t\t\t\t\t\tdeck[0][i][0] += y-cntr;\n\t\t\t\t\t\tcntr = y;\n\t\t\t\t\t}\n\t\t\t\t}\n\n\t\t\t\tint itr = 0;\n\t\t\t\twhile(deck[0][i+itr][0] != 0){\n\t\t\t\t\tdeck[1][itr][0] = deck[0][i+itr][0];\n\t\t\t\t\tdeck[1][itr][1] = deck[0][i+itr][1];\n\t\t\t\t\titr++;\n\t\t\t\t}\n\t\t\t\tfor(int j=memoa; j<i; j++){\n\t\t\t\t\tdeck[1][itr][0] = deck[0][j][0];\n\t\t\t\t\tdeck[1][itr][1] = deck[0][j][1];\n\t\t\t\t\titr++;\n\t\t\t\t}\n\t\t\t\tif (sectionb[1] != 0){\n\t\t\t\t\tdeck[1][itr][0] = sectionb[0];\n\t\t\t\t\tdeck[1][itr][1] = sectionb[1];\n\t\t\t\t\titr++;\n\t\t\t\t}\n\t\t\t\tfor(int j=0; j<memoa; j++){\n\t\t\t\t\tdeck[1][itr][0] = deck[0][j][0];\n\t\t\t\t\tdeck[1][itr][1] = deck[0][j][1];\n\t\t\t\t\titr++;\n\t\t\t\t}\n\t\t\t\tif (sectiona[1] != 0){\n\t\t\t\t\tdeck[1][itr][0] = sectiona[0];\n\t\t\t\t\tdeck[1][itr][1] = sectiona[1];\n\t\t\t\t\titr++;\n\t\t\t\t}\n\t\t\t\titr--;\n\n\t\t\t\twhile(itr>=0){\n\t\t\t\t\tdeck[0][itr][0] = deck[1][itr][0];\n\t\t\t\t\tdeck[0][itr][1] = deck[1][itr][1];\n\t\t\t\t\titr--;\n\t\t\t\t}\n\t\t\t}\n\n\t\t\tint answerq = 0;\n\t\t\tint cnter = 0;\n\t\t\tint i = 0;\n\t\t\twhile (cnter < q){\n\t\t\t\tint nextsize = deck[0][i][1] - deck[0][i][0] + 1;\n\t\t\t\tif(q-cnter >= nextsize){\n\t\t\t\t\tanswerq += hitnum(deck[0][i][0],deck[0][i][1], r);\n\t\t\t\t\tcnter += nextsize;\n\t\t\t\t\ti++;\n\t\t\t\t}else{\n\t\t\t\t\tanswerq += hitnum(deck[0][i][0], deck[0][i][0] + q-cnter -1,r);\n\t\t\t\t\tcnter = q;\n\t\t\t\t}\n\t\t\t}\n\n\t\t\tint answerp = 0;\n\t\t\tcnter = 0;\n\t\t\ti = 0;\n\t\t\twhile (cnter < p-1){\n\t\t\t\tint nextsize = deck[0][i][1] - deck[0][i][0] + 1;\n\t\t\t\tif(p-1-cnter >= nextsize){\n\t\t\t\t\tanswerp += hitnum(deck[0][i][0],deck[0][i][1], r);\n\t\t\t\t\tcnter += nextsize;\n\t\t\t\t\ti++;\n\t\t\t\t}else{\n\t\t\t\t\tanswerp += hitnum(deck[0][i][0], deck[0][i][0] + p-1-cnter -1,r);\n\t\t\t\t\tcnter = p-1;\n\t\t\t\t}\n\t\t\t}\n\t\t\tint answer = answerq-answerp;\n\t\t\tSystem.out.println(answer);\n\t\t}\n\t}\n}"
  },
  {
    "language": "Java",
    "code": "\nimport java.util.*;\n\nimport static java.lang.Math.*;\nimport static java.util.Arrays.*;\n\npublic class Main {\n\n\tint INF = 1 << 28;\n\tlong n;\n\tint m;\n\tlong p;\n\tlong q;\n\tlong r;\n\tLinkedList<Segment> card;\n\tvoid run() {\n\t\tScanner sc = new Scanner(System.in);\n\t\tfor(;;) {\n\t\t\tn = sc.nextLong();\n\t\t\tif( n == 0) break;\n\t\t\tcard = new LinkedList<Segment>();\n\t\t\tcard.add(new Segment(1, n));\n\t\t\tm = sc.nextInt();\n\t\t\tp = sc.nextLong();\n\t\t\tq = sc.nextLong();\n\t\t\tr = sc.nextLong();\n\t\t\tLinkedList<Segment> a = new LinkedList<Segment>();\n\t\t\tLinkedList<Segment> b = new LinkedList<Segment>();\n\t\t\tLinkedList<Segment> c = new LinkedList<Segment>();\n\t\t\tfor(int i=0;i<m;i++) {\n\t\t\t\tlong x = sc.nextLong();\n\t\t\t\tlong y = sc.nextLong();\n\t\t\t\tfor(;!card.isEmpty();) {\n//\t\t\t\t\tSystem.out.println(x +\" \" + y);\n\t\t\t\t\tSegment s = card.removeFirst();\n\t\t\t\t\tif(s.size <= x ) {\n\t\t\t\t\t\ta.addLast(s);\n\t\t\t\t\t\tx -= s.size;\n\t\t\t\t\t\ty -= s.size;\n\t\t\t\t\t}\n\t\t\t\t\telse if( x>0 && s.size > x){\n\t\t\t\t\t\tSegment[] sp = s.split(x);\n\t\t\t\t\t\tcard.addFirst(sp[1]);\n\t\t\t\t\t\ta.addLast(sp[0]);\n\t\t\t\t\t\ty -= x;\n\t\t\t\t\t\tx = 0;\n\t\t\t\t\t\tcontinue;\n\t\t\t\t\t}\n\t\t\t\t\telse if( s.size <= y ) {\n\t\t\t\t\t\tb.addLast(s);\n\t\t\t\t\t\ty -= s.size;\n\t\t\t\t\t}\n\t\t\t\t\telse if(y>0 && s.size > y) {\n\t\t\t\t\t\tSegment[] sp = s.split(y);\n\t\t\t\t\t\tcard.addFirst(sp[1]);\n\t\t\t\t\t\tb.addLast(sp[0]);\n\t\t\t\t\t\ty = 0;\n\t\t\t\t\t}\n\t\t\t\t\telse {\n\t\t\t\t\t\tc.addLast(s);\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t\tcard.addAll(c);\n\t\t\t\tcard.addAll(b);\n\t\t\t\tcard.addAll(a);\n\t\t\t\ta.clear();\n\t\t\t\tb.clear();\n\t\t\t\tc.clear();\n\t\t\t\t\n//\t\t\t\tfor(Segment s: card) System.err.println(\"(\" + s.s + \",\" + s.e + \")\");\n//\t\t\t\tSystem.err.println();\n\t\t\t}\n\t\t\t\n\t\t\tLinkedList<Segment> ansList = new LinkedList<Segment>();\n\t\t\tfor(;!card.isEmpty();) {\n\t\t\t\tSegment s = card.removeFirst();\n\t\t\t\tif(s.size < p) {\n\t\t\t\t\tp -= s.size;\n\t\t\t\t\tq -= s.size;\n\t\t\t\t}\n\t\t\t\telse if(p > 0 && s.size>=p) {\n\t\t\t\t\tif(s.size == 1) {\n\t\t\t\t\t\tansList.add(s);\n\t\t\t\t\t}\n\t\t\t\t\telse {\n\t\t\t\t\t\tSegment[] sp = s.split(p);\n\t\t\t\t\t\tcard.addFirst(sp[1]);\n\t\t\t\t\t}\n\t\t\t\t\t\n\t\t\t\t\tq -= p;\n\t\t\t\t\tp = 0;\n\t\t\t\t}\n\t\t\t\telse if(q > s.size) {\n\t\t\t\t\tq -= s.size;\n\t\t\t\t\tansList.addFirst(s);\n\t\t\t\t}\n\t\t\t\telse if(s.size>=q) {\n\t\t\t\t\tSegment[] sp = s.split(q);\n\t\t\t\t\tansList.add(sp[0]);\n\t\t\t\t\tbreak;\n\t\t\t\t}\n\t\t\t}\n\t\t\tlong ans = 0;\n\t\t\tfor(Segment s: ansList) {\n\t\t\t\tans += s.cntElement(r);\n\t\t\t}\n\t\t\tSystem.out.println(ans);\n\t\t}\n\t}\n\t\n\tvoid debug(Object...os){\n\t\tSystem.err.println(Arrays.deepToString(os));\n\t}\n\n\tpublic static void main(String[] args) {\n\t\tnew Main().run();\n\t}\n\tclass Segment {\n\t\tlong s, e;\n\t\tlong size;\n\t\tSegment (long s, long e) {\n\t\t\tthis.s = s;\n\t\t\tthis.e = e;\n\t\t\tsize = e-s+1;\n\t\t}\n\t\t\n\t\tSegment[] split(long x) {\n\t\t\tSegment[] sp = new Segment[2];\n\t\t\tsp[0] = new Segment(s, s+x-1);\n\t\t\tsp[1] = new Segment(s+x, e);\n\t\t\treturn sp;\n\t\t}\n\t\t\n\t\tlong cntElement(long r) {\n\t\t\tif(r >= e) return size;\n\t\t\telse if( r>= s) return r-s+1;\n\t\t\treturn 0;\n\t\t}\n\t}\n}"
  },
  {
    "language": "Java",
    "code": "import java.util.Deque;\nimport java.util.LinkedList;\nimport java.util.Scanner;\n\npublic class Main {\n\tpublic static void main(String[] args) {\n\t\tScanner in = new Scanner(System.in);\n\t\tint n, m, p, q, r;\n\t\twhile ((n = in.nextInt()) > 0) {\n\t\t\tm = in.nextInt();\n\t\t\tp = in.nextInt() - 1;\n\t\t\tq = in.nextInt();\n\t\t\tr = in.nextInt();\n\t\t\tDeque<Integer> allDeque = getNewDeque();\n\t\t\tallDeque.add(Integer.valueOf(r));\n\t\t\tallDeque.add(Integer.valueOf(n - r));\n\t\t\tDeque<Integer> a = getNewDeque();\n\t\t\tDeque<Integer> c = getNewDeque();\n\t\t\tboolean top = true;\n\t\t\tboolean bottom = false;\n\t\t\tfor (int i = 0; i < m; i++) {\n\t\t\t\tboolean atop = top, abottm, ctop, cbottom = bottom;\n\t\t\t\tint asize = in.nextInt();\n\t\t\t\ta.clear();\n\t\t\t\twhile (asize >= allDeque.peekFirst().intValue()) {\n\t\t\t\t\ttop = !top;\n\t\t\t\t\tfinal Integer first = allDeque.removeFirst();\n\t\t\t\t\ta.addLast(first);\n\t\t\t\t\tasize -= first.intValue();\n\t\t\t\t}\n\t\t\t\tif (asize != 0) {\n\t\t\t\t\ta.addLast(Integer.valueOf(asize));\n\t\t\t\t\tfinal Integer first = allDeque.removeFirst();\n\t\t\t\t\tallDeque.addFirst(Integer.valueOf(first - asize));\n\t\t\t\t}\n\t\t\t\tabottm = (a.size() % 2 == 1) ? atop : !atop;\n\t\t\t\tint csize = n - in.nextInt();\n\t\t\t\tc.clear();\n\t\t\t\twhile (csize >= allDeque.peekLast().intValue()) {\n\t\t\t\t\tbottom = !bottom;\n\t\t\t\t\tfinal Integer last = allDeque.removeLast();\n\t\t\t\t\tc.addFirst(last);\n\t\t\t\t\tcsize -= last.intValue();\n\t\t\t\t}\n\t\t\t\tif (csize != 0) {\n\t\t\t\t\tc.addFirst(Integer.valueOf(csize));\n\t\t\t\t\tfinal Integer last = allDeque.removeLast();\n\t\t\t\t\tallDeque.addLast(Integer.valueOf(last - csize));\n\t\t\t\t}\n\t\t\t\tctop = (c.size() % 2 == 1) ? cbottom : !cbottom;\n\t\t\t\tif (atop == bottom) {\n\t\t\t\t\tint afirst = a.removeFirst().intValue();\n\t\t\t\t\tallDeque.addLast(Integer.valueOf(afirst\n\t\t\t\t\t\t\t+ allDeque.removeLast().intValue()));\n\t\t\t\t}\n\t\t\t\tif (cbottom == top) {\n\t\t\t\t\tint clast = c.removeLast().intValue();\n\t\t\t\t\tallDeque.addFirst(Integer.valueOf(clast\n\t\t\t\t\t\t\t+ allDeque.removeFirst().intValue()));\n\t\t\t\t}\n\t\t\t\tDeque<Integer> b = allDeque;\n\t\t\t\tallDeque = c;\n\t\t\t\tc = b;\n\t\t\t\tallDeque.addAll(b);\n\t\t\t\tallDeque.addAll(a);\n\t\t\t\ttop = ctop;\n\t\t\t\tbottom = abottm;\n\t\t\t}\n\t\t\twhile (p >= allDeque.peekFirst().intValue()) {\n\t\t\t\tfinal int val = allDeque.removeFirst().intValue();\n\t\t\t\tq -= val;\n\t\t\t\tp -= val;\n\t\t\t\ttop = !top;\n\t\t\t}\n\t\t\tint count = (top) ? -p : 0;\n\t\t\twhile (q >= allDeque.peekFirst().intValue()) {\n\t\t\t\tfinal int intValue = allDeque.removeFirst().intValue();\n\t\t\t\tq -= intValue;\n\t\t\t\tif (top)\n\t\t\t\t\tcount += intValue;\n\t\t\t\ttop = !top;\n\t\t\t}\n\t\t\tif (top) {\n\t\t\t\tcount += q;\n\t\t\t}\n\t\t\tSystem.out.println(count);\n\t\t}\n\t}\n\n\tprivate static Deque<Integer> getNewDeque() {\n\t\treturn new LinkedList<Integer>();\n\t}\n}"
  },
  {
    "language": "Java",
    "code": "import java.util.Collections;\nimport java.util.LinkedList;\nimport java.util.Scanner;\n\n//Shuffle\npublic class Main{\n\n\tclass R implements Comparable<R>{\n\t\tint s, t;\n\t\tpublic R(int s, int t) {\n\t\t\tthis.s = s;\n\t\t\tthis.t = t;\n\t\t}\n\t\tpublic int compareTo(R o) {\n\t\t\treturn s-o.s;\n\t\t}\n\t}\n\t\n\tvoid run(){\n\t\tScanner sc = new Scanner(System.in);\n\t\tfor(;;){\n\t\t\tint n = sc.nextInt();\n\t\t\tif(n==0)break;\n\t\t\tint m = sc.nextInt(), p = sc.nextInt(), q = sc.nextInt(), r = sc.nextInt();\n\t\t\tint[] ps = new int[m], qs = new int[m];\n\t\t\tfor(int i=0;i<m;i++){\n\t\t\t\tps[i] = sc.nextInt(); qs[i] = sc.nextInt();\n\t\t\t}\n\t\t\tLinkedList<R> l = new LinkedList<R>();\n\t\t\tl.add(new R(p, q));\n\t\t\tfor(int Q=m-1;Q>=0;Q--){\n\t\t\t\tint x = ps[Q], y = qs[Q];\n//\t\t\t\tLinkedList<R> next = new LinkedList<R>();\n\t\t\t\tint L = l.size();\n\t\t\t\tfor(int i=0;i<L;i++){\n\t\t\t\t\tR v = l.get(i);\n\t\t\t\t\tif(v.t<=n-y){\n\t\t\t\t\t\tv.s+=y; v.t+=y;\n//\t\t\t\t\t\tnext.add(new R(v.s+y, v.t+y));\n\t\t\t\t\t}\n\t\t\t\t\telse if(v.s<=n-y){\n\t\t\t\t\t\tif(v.t<=n-x){\n\t\t\t\t\t\t\tl.add(new R(x+1, v.t+x+y-n));\n\t\t\t\t\t\t\tv.s+=y; v.t = n;\n\t\t\t\t\t\t}\n\t\t\t\t\t\telse{\n\t\t\t\t\t\t\tl.add(new R(x+1, y));\n\t\t\t\t\t\t\tl.add(new R(1, v.t+x-n));\n\t\t\t\t\t\t\tv.s+=y; v.t = n;\n\t\t\t\t\t\t}\n//\t\t\t\t\t\tnext.add(new R(v.s+y, n));\n//\t\t\t\t\t\tl.remove(i); l.add(i, new R(n-y+1, v.t)); i--;\n\t\t\t\t\t}\n\t\t\t\t\telse if(v.t<=n-x){\n\t\t\t\t\t\tv.s+=x+y-n; v.t+=x+y-n;\n//\t\t\t\t\t\tnext.add(new R(v.s+x+y-n, v.t+x-n+y));\n\t\t\t\t\t}\n\t\t\t\t\telse if(v.s<=n-x){\n\t\t\t\t\t\tl.add(new R(1, v.t+x-n));\n\t\t\t\t\t\tv.s += x+y-n; v.t = y;\n//\t\t\t\t\t\tl.remove(i); l.add(i, new R(n-x+1, v.t)); i--;\n//\t\t\t\t\t\tnext.add(new R(v.s+x+y-n, y));\n\t\t\t\t\t}\n\t\t\t\t\telse {\n\t\t\t\t\t\tv.s+=x-n; v.t+=x-n;\n//\t\t\t\t\t\tnext.add(new R(v.s+x-n, v.t+x-n));\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t\tCollections.sort(l);\n\t\t\t\tfor(int i=0;i+1<l.size();i++){\n\t\t\t\t\tif(l.get(i).t+1==l.get(i+1).s){\n\t\t\t\t\t\tR v = new R(l.get(i).s, l.get(i+1).t);\n\t\t\t\t\t\tl.remove(i); l.remove(i); l.add(i, v); i--;\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t}\n\t\t\tint res = 0;\n\t\t\tfor(R v:l){\n\t\t\t\tif(v.t<=r)res+=v.t-v.s+1;\n\t\t\t\telse if(v.s<=r)res+=r-v.s+1;\n\t\t\t}\n\t\t\tSystem.out.println(res);\n\t\t}\n\t}\n\t\n\tpublic static void main(String[] args) {\n\t\tnew Main().run();\n\t}\n}"
  },
  {
    "language": "Java",
    "code": "\nimport java.awt.Point;\nimport java.io.BufferedReader;\nimport java.io.IOException;\nimport java.io.InputStreamReader;\nimport java.util.ArrayList;\nimport java.util.List;\nimport java.util.StringTokenizer;\n\npublic class Main {\n\n\tpublic static void main(String[] args) throws IOException {\n\n\t\tnew Main().run();\n\t}\n\n\tprivate void run() throws IOException {\n\t\tBufferedReader reader = new BufferedReader(new InputStreamReader(System.in));\n\t\twhile (true) {\n\t\t\tint n = Integer.parseInt(reader.readLine());\n\t\t\tif (n == 0)\n\t\t\t\tbreak;\n\t\t\tint m = Integer.parseInt(reader.readLine());\n\t\t\tStringTokenizer t = new StringTokenizer(reader.readLine());\n\t\t\tint p = Integer.parseInt(t.nextToken());\n\t\t\tint q = Integer.parseInt(t.nextToken());\n\t\t\tint r = Integer.parseInt(t.nextToken());\n\t\t\tList<Point> v = new ArrayList<Point>();\n\t\t\t\n\t\t\tv.add(new Point(1, n));\n\t\t\twhile (m-- > 0) {\n\t\t\t\tt = new StringTokenizer(reader.readLine());\n\t\t\t\tint x = Integer.parseInt(t.nextToken());\n\t\t\t\tint y = Integer.parseInt(t.nextToken());\n\t\t\t\tList<Point> a, b, c;\n\t\t\t\tb = new ArrayList<Point>();\n\t\t\t\tc = new ArrayList<Point>();\n\t\t\t\ta = new ArrayList<Point>();\n\t\t\t\tcut(v, y, c);\n\t\t\t\tcut(v, x, b);\n\t\t\t\ta = v;\n\t\t\t\tv = c;\n\t\t\t\tv.addAll(b);\n\t\t\t\tv.addAll(a);\n\t\t\t}\n\t\t\tList<Point> rv = new ArrayList<Point>();\n\t\t\tcut(v, q, rv);\n\t\t\tcut(v, p - 1, rv);\n\t\t\tint ans = 0;\n\t\t\tfor (int i = 0; i < rv.size(); i++)\n\t\t\t\tans += Math.max(0, Math.min(r - rv.get(i).x + 1, rv.get(i).y));\n\t\t\tSystem.out.println(ans);\n\t\t}\n\t}\n\tclass Point{\n\t\tint x,y;\n\n\t\tpublic Point(int x, int y) {\n\t\t\tsuper();\n\t\t\tthis.x = x;\n\t\t\tthis.y = y;\n\t\t}\n\n\t\t@Override\n\t\tpublic String toString() {\n\t\t\treturn \"Point [x=\" + x + \", y=\" + y + \"]\";\n\t\t}\n\t\t\n\t}\n\n\tprivate void cut(List<Point> v, int x, List<Point> r) {\n\t\tr.clear();\n\t\tint n = 0;\n\t\tint p = 0;\n\t\twhile (n + v.get(p).y <= x) {\n\t\t\tn += v.get(p).y;\n\t\t\tp++;\n\t\t}\n\t\tPoint ns = new Point(v.get(p).x + x - n, v.get(p).y - (x - n));\n\t\tr.add(ns);\n\t\tfor (int j = p + 1; j < v.size(); j++) {\n\t\t\tr.add(new Point(v.get(j).x, v.get(j).y));\n\t\t}\n\t\tfor (int j = v.size() - 1; j >= p + 1; j--)\n\t\t\tv.remove(j);\n\t\tv.get(v.size() - 1).y = x - n;\n\n\t}\n}"
  },
  {
    "language": "Java",
    "code": "import java.util.Scanner;\n\npublic class Main {\n\n\tpublic static void split(int x, int y) {\n\n\t\tint first = 1;\n\t\t\n\t\tfor(int index = 0; index < list_size; index++){\n\t\t\tfinal int card_first = list_first[index];\n\t\t\tfinal int card_last  = list_last [index];\n\n\t\t\tfinal int last = first + (card_last - card_first);\n\n\t\t\t//System.out.println(x + \" \" + y + \" \" + first + \" \" + last + \" \"\n\t\t\t//\t\t+ card_first + \" \" + card_last);\n\n\t\t\tif (first <= x && last <= x) {\n\t\t\t\ta_list_add(card_first, card_last);\n\t\t\t\t\n\t\t\t} else if (first <= x) {\n\t\t\t\tfinal int sp1 = x - first + 1;\n\t\t\t\t\n\t\t\t\ta_list_add(card_first, card_first + sp1 - 1);\n\n\t\t\t\tif (last <= y) {\n\t\t\t\t\tb_list_add(card_first + sp1, card_last);\n\t\t\t\t} else {\n\t\t\t\t\tfinal int sp2 = y - x;\n\t\t\t\t\t\n\t\t\t\t\tb_list_add(card_first + sp1, card_first + sp1 + sp2 - 1);\n\t\t\t\t\tc_list_add(card_first + sp1 + sp2, card_last);\n\t\t\t\t}\n\n\t\t\t} else if (first <= y && last <= y) {\n\t\t\t\tb_list_add(card_first, card_last);\n\n\t\t\t} else if (first <= y) {\n\t\t\t\tfinal int sp1 = y - first + 1;\n\n\t\t\t\tb_list_add(card_first, card_first + sp1 - 1);\n\t\t\t\tc_list_add(card_first + sp1, card_last);\n\t\t\t\t\n\t\t\t} else {\n\t\t\t\tc_list_add(card_first, card_last);\n\t\t\t\t\n\t\t\t}\n\n\t\t\tfirst = last + 1;\n\t\t}\n\t}\n\t\n\tpublic static final int MAX = 5000 * 3 + 1;\n\t\n\tpublic static int[] list_first = new int[MAX];\n\tpublic static int[] list_last = new int[MAX];\n\tpublic static int   list_size = 0;\n\t\n\tpublic static int[] a_list_first = new int[MAX];\n\tpublic static int[] a_list_last = new int[MAX];\n\tpublic static int   a_list_size = 0;\n\t\n\tpublic static int[] b_list_first = new int[MAX];\n\tpublic static int[] b_list_last = new int[MAX];\n\tpublic static int   b_list_size = 0;\n\t\n\tpublic static int[] c_list_first = new int[MAX];\n\tpublic static int[] c_list_last = new int[MAX];\n\tpublic static int   c_list_size = 0;\n\t\n\tpublic static void list_add(int first, int last){\n\t\tlist_first[list_size] = first;\n\t\tlist_last [list_size] = last;\n\t\tlist_size++;\n\t}\n\t\n\tpublic static void a_list_add(int first, int last){\n\t\ta_list_first[a_list_size] = first;\n\t\ta_list_last [a_list_size] = last;\n\t\ta_list_size++;\n\t}\n\t\n\tpublic static void b_list_add(int first, int last){\n\t\tb_list_first[b_list_size] = first;\n\t\tb_list_last [b_list_size] = last;\n\t\tb_list_size++;\n\t}\n\t\n\tpublic static void c_list_add(int first, int last){\n\t\tc_list_first[c_list_size] = first;\n\t\tc_list_last [c_list_size] = last;\n\t\tc_list_size++;\n\t}\n\t\n\tpublic static void list_clear(){\n\t\tlist_size = 0;\n\t}\n\t\n\tpublic static void additional_list_clear(){\n\t\ta_list_size = 0;\n\t\tb_list_size = 0;\n\t\tc_list_size = 0;\n\t}\n\t\n\tpublic static void all_list_clear(){\n\t\tlist_clear();\n\t\tadditional_list_clear();\n\t}\n\t\n\tpublic static void main(String[] args) {\n\t\tScanner sc = new Scanner(System.in);\n\n\t\twhile (true) {\n\t\t\tfinal int n = sc.nextInt();\n\n\t\t\tif (n == 0) {\n\t\t\t\tbreak;\n\t\t\t}\n\n\t\t\tlist_add(1, n);\n\n\t\t\tfinal int m = sc.nextInt();\n\t\t\tfinal int p = sc.nextInt();\n\t\t\tfinal int q = sc.nextInt();\n\t\t\tfinal int r = sc.nextInt();\n\n\t\t\tfor (int i = 0; i < m; i++) {\n\t\t\t\tfinal int x = sc.nextInt();\n\t\t\t\tfinal int y = sc.nextInt();\n\n\t\t\t\t//System.out.println(list_first + \" \" + list_last);\n\t\t\t\tsplit(x, y);\n\t\t\t\tlist_clear();\n\t\t\t\t\n\t\t\t\tfor(int index = 0; index < c_list_size; index++){\n\t\t\t\t\tlist_add(c_list_first[index], c_list_last[index]);\n\t\t\t\t}\n\t\t\t\tfor(int index = 0; index < b_list_size; index++){\n\t\t\t\t\tlist_add(b_list_first[index], b_list_last[index]);\n\t\t\t\t}\n\t\t\t\tfor(int index = 0; index < a_list_size; index++){\n\t\t\t\t\tlist_add(a_list_first[index], a_list_last[index]);\n\t\t\t\t}\n\n\t\t\t\tadditional_list_clear();\n\t\t\t}\n\n\t\t\t//System.out.println(list_first);\n\t\t\t//System.out.println(list_last);\n\n\t\t\tint sum = 0;\n\t\t\tsplit(p - 1, q);\n\t\t\t// System.out.println(a_list + \" \" + b_list + \" \" + c_list);\n\t\t\tfor(int index = 0; index < b_list_size; index++){\n\t\t\t\tfinal int first = b_list_first[index];\n\t\t\t\tfinal int last = b_list_last[index];\n\n\t\t\t\t//System.out.println(first + \" : \" + last);\n\n\t\t\t\tsum += Math.max(0, Math.min(last, r) - first + 1);\n\t\t\t}\n\t\t\tSystem.out.println(sum);\n\t\t\t\n\t\t\tall_list_clear();\n\t\t}\n\t}\n\n}"
  },
  {
    "language": "Java",
    "code": "import java.io.File;\nimport java.io.FileNotFoundException;\nimport java.util.ArrayList;\nimport java.util.Collections;\nimport java.util.Comparator;\nimport java.util.List;\nimport java.util.Scanner;\n\npublic class Main {\n\n\tpublic static void main(String[] args) throws FileNotFoundException {\n\n\t\tScanner scan = new Scanner(System.in);\n\t\t// Scanner scan = new Scanner(new\n\t\t// File(\"D:\\\\UserArea\\\\J0124567\\\\Downloads\\\\0534-input.txt\"));\n\n\t\twhile (scan.hasNext()) {\n\n\t\t\tint n = scan.nextInt();\n\t\t\tif (n == 0)\n\t\t\t\tbreak;\n\t\t\tint m = scan.nextInt();\n\t\t\tint p = scan.nextInt();\n\t\t\tint q = scan.nextInt();\n\t\t\tint r = scan.nextInt();\n\n\t\t\tCard c = new Card(n);\n\t\t\tfor (int i = 0; i < m; i++)\n\t\t\t\tc.shuffle(scan.nextInt(), scan.nextInt());\n\t\t\tSystem.out.println(c.count(p, q, r));\n\t\t}\n\n\t\tscan.close();\n\t\tSystem.exit(0);\n\n\t}\n}\n\nclass Card {\n\tint[][] card;\n\tint current = 0;\n\n\tpublic Card(int n) {\n\t\tcard = new int[n][2];\n\t\tfor (int i = 0; i < n; i++)\n\t\t\tcard[i][current] = i + 1;\n\t}\n\n\tpublic int count(int p, int q, int r) {\n\t\tp = p - 1;\n\t\tq = q - 1;\n\t\tint pcs = 0;\n\t\tfor (int i = p; i <= q; i++)\n\t\t\tif (card[i][current] <= r)\n\t\t\t\tpcs++;\n\t\treturn pcs;\n\t}\n\n\tpublic void shuffle(int x, int y) {\n\t\tx = x - 1;\n\t\ty = y - 1;\n\t\tint t = 0;\n\t\tint next = current ^ 1;\n\t\tfor (int i = y + 1; i < card.length; i++, t++)\n\t\t\tcard[t][next] = card[i][current];\n\t\tfor (int i = x + 1; i <= y; i++, t++)\n\t\t\tcard[t][next] = card[i][current];\n\t\tfor (int i = 0; i <= x; i++, t++)\n\t\t\tcard[t][next] = card[i][current];\n\t\tcurrent = next;\n\t}\n}"
  },
  {
    "language": "Java",
    "code": "import java.util.Deque;\nimport java.util.LinkedList;\nimport java.util.Scanner;\n\npublic class Main {\n\tpublic static void main(String[] args) {\n\t\tScanner in = new Scanner(System.in);\n\t\tint n, m, p, q, r;\n\t\twhile ((n = in.nextInt()) > 0) {\n\t\t\tm = in.nextInt();\n\t\t\tp = in.nextInt() - 1;\n\t\t\tq = in.nextInt();\n\t\t\tr = in.nextInt();\n\t\t\tDeque<Integer> allDeque = getNewDeque();\n\t\t\tallDeque.add(Integer.valueOf(r));\n\t\t\tallDeque.add(Integer.valueOf(n - r));\n\t\t\tDeque<Integer> a = getNewDeque();\n\t\t\tDeque<Integer> c = getNewDeque();\n\t\t\tboolean top = true;\n\t\t\tboolean bottom = false;\n\t\t\tfor (int i = 0; i < m; i++) {\n\t\t\t\tboolean atop = top, abottm, ctop, cbottom = bottom;\n\t\t\t\tint asize = in.nextInt();\n\t\t\t\ta.clear();\n\t\t\t\twhile (asize >= allDeque.peekFirst().intValue()) {\n\t\t\t\t\ttop = !top;\n\t\t\t\t\tfinal Integer first = allDeque.removeFirst();\n\t\t\t\t\ta.addLast(first);\n\t\t\t\t\tasize -= first.intValue();\n\t\t\t\t}\n\t\t\t\tif (asize != 0) {\n\t\t\t\t\ta.addLast(Integer.valueOf(asize));\n\t\t\t\t\tfinal Integer first = allDeque.removeFirst();\n\t\t\t\t\tallDeque.addFirst(Integer.valueOf(first - asize));\n\t\t\t\t}\n\t\t\t\tabottm = (a.size() % 2 == 1) ? atop : !atop;\n\t\t\t\tint csize = n - in.nextInt();\n\t\t\t\tc.clear();\n\t\t\t\twhile (csize >= allDeque.peekLast().intValue()) {\n\t\t\t\t\tbottom = !bottom;\n\t\t\t\t\tfinal Integer last = allDeque.removeLast();\n\t\t\t\t\tc.addFirst(last);\n\t\t\t\t\tcsize -= last.intValue();\n\t\t\t\t}\n\t\t\t\tif (csize != 0) {\n\t\t\t\t\tc.addFirst(Integer.valueOf(csize));\n\t\t\t\t\tfinal Integer last = allDeque.removeLast();\n\t\t\t\t\tallDeque.addLast(Integer.valueOf(last - csize));\n\t\t\t\t}\n\t\t\t\tctop = (c.size() % 2 == 1) ? cbottom : !cbottom;\n\t\t\t\tif (atop == bottom) {\n\t\t\t\t\tint afirst = a.removeFirst().intValue();\n\t\t\t\t\tallDeque.addLast(Integer.valueOf(afirst\n\t\t\t\t\t\t\t+ allDeque.removeLast().intValue()));\n\t\t\t\t}\n\t\t\t\tif (cbottom == top) {\n\t\t\t\t\tint clast = a.removeLast().intValue();\n\t\t\t\t\tallDeque.addFirst(Integer.valueOf(clast\n\t\t\t\t\t\t\t+ allDeque.removeFirst().intValue()));\n\t\t\t\t}\n\t\t\t\tDeque<Integer> b = allDeque;\n\t\t\t\tallDeque = c;\n\t\t\t\tc = b;\n\t\t\t\tallDeque.addAll(b);\n\t\t\t\tallDeque.addAll(a);\n\t\t\t\ttop = ctop;\n\t\t\t\tbottom = abottm;\n\t\t\t}\n\t\t\twhile (p >= allDeque.peekFirst().intValue()) {\n\t\t\t\tfinal int val = allDeque.removeFirst().intValue();\n\t\t\t\tq -= val;\n\t\t\t\tp -= val;\n\t\t\t\ttop = !top;\n\t\t\t}\n\t\t\tint count = (top) ? -p : 0;\n\t\t\twhile (q >= allDeque.peekFirst().intValue()) {\n\t\t\t\tfinal int intValue = allDeque.removeFirst().intValue();\n\t\t\t\tq -= intValue;\n\t\t\t\tif (top)\n\t\t\t\t\tcount += intValue;\n\t\t\t\ttop = !top;\n\t\t\t}\n\t\t\tif (top) {\n\t\t\t\tcount += q;\n\t\t\t}\n\t\t\tSystem.out.println(count);\n\t\t}\n\t}\n\n\tprivate static Deque<Integer> getNewDeque() {\n\t\treturn new LinkedList<Integer>();\n\t}\n}"
  },
  {
    "language": "Java",
    "code": "\nimport java.awt.Point;\nimport java.io.IOException;\nimport java.util.ArrayList;\nimport java.util.List;\nimport java.util.Scanner;\n\npublic class Main {\n\n\tpublic static void main(String[] args) throws IOException {\n\n\t\tnew Main().run();\n\t}\n\n\tprivate void run() throws IOException {\n\t\tScanner scanner = new Scanner(System.in);\n\t\twhile (true) {\n\t\t\tint n = scanner.nextInt();\n\t\t\tif (n == 0)\n\t\t\t\tbreak;\n\t\t\tint m = scanner.nextInt();\n\t\t\tint p = scanner.nextInt();\n\t\t\tint q = scanner.nextInt();\n\t\t\tint r = scanner.nextInt();\n\t\t\tList<Point> v = new ArrayList<Point>();\n\t\t\tv.add(new Point(1, n));\n\t\t\twhile (m-- > 0) {\n\t\t\t\tint x = scanner.nextInt();\n\t\t\t\tint y = scanner.nextInt();\n\t\t\t\tList<Point> a, b, c;\n\t\t\t\ta = new ArrayList<Point>();\n\t\t\t\tb = new ArrayList<Point>();\n\t\t\t\tc = new ArrayList<Point>();\n\t\t\t\tcut(v, y, c);\n\t\t\t\tcut(v, x, b);\n\t\t\t\ta = v;\n\t\t\t\tv = c;\n\t\t\t\tv.addAll(b);\n\t\t\t\tv.addAll(a);\n\t\t\t}\n\t\t\tList<Point> rv = new ArrayList<Point>();\n\t\t\tcut(v, q, rv);\n\t\t\tcut(v, p - 1, rv);\n\t\t\tint ans = 0;\n\t\t\tfor (int i = 0; i < rv.size(); i++)\n\t\t\t\tans += Math.max(0, Math.min(r - rv.get(i).x + 1, rv.get(i).y));\n\t\t\tSystem.out.println(ans);\n\t\t}\n\t}\n\n\tprivate void cut(List<Point> v, int x, List<Point> r) {\n\t\tr.clear();\n\t\tint n = 0;\n\t\tint p = 0;\n\t\twhile (n + v.get(p).y <= x) {\n\t\t\tn += v.get(p).y;\n\t\t\tp++;\n\t\t}\n\t\tPoint ns = new Point(v.get(p).x + x - n, v.get(p).y - (x - n));\n\t\tr.add(ns);\n\t\tfor (int j = p + 1; j < v.size(); j++) {\n\t\t\tr.add(new Point(v.get(j).x, v.get(j).y));\n\t\t}\n\t\tfor (int j = v.size() - 1; j >= p + 1; j--)\n\t\t\tv.remove(j);\n\t\tv.get(v.size() - 1).y = x - n;\n\n\t}\n}"
  },
  {
    "language": "Java",
    "code": "import java.util.ArrayDeque;\nimport java.util.Deque;\nimport java.util.LinkedList;\nimport java.util.Scanner;\n\npublic class Main {\n\tpublic static void main(String[] args) {\n\t\tScanner in = new Scanner(System.in);\n\t\tint n, m, p, q, r;\n\t\twhile ((n = in.nextInt()) > 0) {\n\t\t\tm = in.nextInt();\n\t\t\tp = in.nextInt() - 1;\n\t\t\tq = in.nextInt();\n\t\t\tr = in.nextInt();\n\t\t\tDeque<Integer> allDeque = getNewDeque();\n\t\t\tallDeque.add(Integer.valueOf(r));\n\t\t\tallDeque.add(Integer.valueOf(n - r));\n\t\t\tDeque<Integer> a = getNewDeque();\n\t\t\tDeque<Integer> c = getNewDeque();\n\t\t\tboolean top = true;\n\t\t\tboolean bottom = false;\n\t\t\tfor (int i = 0; i < m; i++) {\n\t\t\t\tboolean atop = top, abottm, ctop, cbottom = bottom;\n\t\t\t\tint asize = in.nextInt();\n\t\t\t\ta.clear();\n\t\t\t\twhile (asize >= allDeque.peekFirst().intValue()) {\n\t\t\t\t\ttop = !top;\n\t\t\t\t\tfinal Integer first = allDeque.removeFirst();\n\t\t\t\t\ta.addLast(first);\n\t\t\t\t\tasize -= first.intValue();\n\t\t\t\t}\n\t\t\t\tif (asize != 0) {\n\t\t\t\t\ta.addLast(Integer.valueOf(asize));\n\t\t\t\t\tfinal Integer first = allDeque.removeFirst();\n\t\t\t\t\tallDeque.addFirst(Integer.valueOf(first - asize));\n\t\t\t\t}\n\t\t\t\tabottm = (a.size() % 2 == 1) ? atop : !atop;\n\t\t\t\tint csize = n - in.nextInt();\n\t\t\t\tc.clear();\n\t\t\t\twhile (csize >= allDeque.peekLast().intValue()) {\n\t\t\t\t\tbottom = !bottom;\n\t\t\t\t\tfinal Integer last = allDeque.removeLast();\n\t\t\t\t\tc.addFirst(last);\n\t\t\t\t\tcsize -= last.intValue();\n\t\t\t\t}\n\t\t\t\tif (csize != 0) {\n\t\t\t\t\tc.addFirst(Integer.valueOf(csize));\n\t\t\t\t\tfinal Integer last = allDeque.removeLast();\n\t\t\t\t\tallDeque.addLast(Integer.valueOf(last - csize));\n\t\t\t\t}\n\t\t\t\tctop = (c.size() % 2 == 1) ? cbottom : !cbottom;\n\t\t\t\tif (atop == bottom) {\n\t\t\t\t\tint afirst = a.removeFirst().intValue();\n\t\t\t\t\tallDeque.addLast(Integer.valueOf(afirst\n\t\t\t\t\t\t\t+ allDeque.removeLast().intValue()));\n\t\t\t\t}\n\t\t\t\tif (cbottom == top) {\n\t\t\t\t\tint clast = c.removeLast().intValue();\n\t\t\t\t\tallDeque.addFirst(Integer.valueOf(clast\n\t\t\t\t\t\t\t+ allDeque.removeFirst().intValue()));\n\t\t\t\t}\n\t\t\t\tDeque<Integer> b = allDeque;\n\t\t\t\tallDeque = c;\n\t\t\t\tc = b;\n\t\t\t\tallDeque.addAll(b);\n\t\t\t\tallDeque.addAll(a);\n\t\t\t\ttop = ctop;\n\t\t\t\tbottom = abottm;\n\t\t\t}\n\t\t\twhile (p >= allDeque.peekFirst().intValue()) {\n\t\t\t\tfinal int val = allDeque.removeFirst().intValue();\n\t\t\t\tq -= val;\n\t\t\t\tp -= val;\n\t\t\t\ttop = !top;\n\t\t\t}\n\t\t\tint count = (top) ? -p : 0;\n\t\t\twhile (q >= allDeque.peekFirst().intValue()) {\n\t\t\t\tfinal int intValue = allDeque.removeFirst().intValue();\n\t\t\t\tq -= intValue;\n\t\t\t\tif (top)\n\t\t\t\t\tcount += intValue;\n\t\t\t\ttop = !top;\n\t\t\t}\n\t\t\tif (top) {\n\t\t\t\tcount += q;\n\t\t\t}\n\t\t\tSystem.out.println(count);\n\t\t}\n\t}\n\n\tprivate static Deque<Integer> getNewDeque() {\n\t\treturn new ArrayDeque<Integer>();\n\t}\n}"
  },
  {
    "language": "Java",
    "code": "import java.util.*;\nimport java.lang.*;\nimport java.math.*;\nimport java.io.*;\n\nimport static java.lang.Math.*;\nimport static java.util.Arrays.*;\nimport static java.util.Collections.*;\n\npublic class Main{\n\n\tScanner sc=new Scanner(System.in);\n\n\tint INF=1<<28;\n\tdouble EPS=1e-12;\n\n\tint n, m;\n\tint p, q, r;\n\tint[] x, y;\n\n\tvoid run(){\n\t\tfor(;;){\n\t\t\tn=sc.nextInt();\n\t\t\tif(n==0){\n\t\t\t\tbreak;\n\t\t\t}\n\t\t\tm=sc.nextInt();\n\t\t\tp=sc.nextInt();\n\t\t\tq=sc.nextInt();\n\t\t\tr=sc.nextInt();\n\t\t\tx=new int[m];\n\t\t\ty=new int[m];\n\t\t\tfor(int i=0; i<m; i++){\n\t\t\t\tx[i]=sc.nextInt();\n\t\t\t\ty[i]=sc.nextInt();\n\t\t\t}\n\t\t\tsolve();\n\t\t}\n\t}\n\n\tvoid solve(){\n\t\t// [left, right)\n\t\t// (len<<32)|left\n\t\tlong[] cards=new long[20000];\n\t\tint nCards=0;\n\t\tcards[nCards++]=hoge(1, n+1);\n\t\tlong[] a=new long[20000];\n\t\tlong[] b=new long[20000];\n\t\tlong[] c=new long[20000];\n\t\tfor(int k=0; k<m; k++){\n\t\t\tint ai=0, bi=0, ci=0;\n\t\t\tint left=0, right=0;\n\t\t\tint state=0;\n\t\t\tfor(int i=0; i<nCards; i++){\n\t\t\t\tint offset=(int)cards[i];\n\t\t\t\tint len=(int)(cards[i]>>>32);\n\t\t\t\tright+=len;\n\t\t\t\tboolean xCut=left<x[k]&&x[k]<right;\n\t\t\t\tboolean yCut=left<y[k]&&y[k]<right;\n\t\t\t\tif(xCut&&yCut){\n\t\t\t\t\t// offset+([0, x[k]-left) + [x[k]-left, y[k]-left) +\n\t\t\t\t\t// [y[k]-left, right-left))\n\t\t\t\t\ta[ai++]=hoge(offset, offset+x[k]-left);\n\t\t\t\t\tb[bi++]=hoge(offset+x[k]-left, offset+y[k]-left);\n\t\t\t\t\tc[ci++]=hoge(offset+y[k]-left, offset+len);\n\t\t\t\t\tstate+=2;\n\t\t\t\t}else if(xCut){\n\t\t\t\t\t// offset+([0, x[k]-left) + [x[k]-left, right-left))\n\t\t\t\t\ta[ai++]=hoge(offset, offset+x[k]-left);\n\t\t\t\t\tb[bi++]=hoge(offset+x[k]-left, offset+len);\n\t\t\t\t\tstate++;\n\t\t\t\t}else if(yCut){\n\t\t\t\t\tb[bi++]=hoge(offset, offset+y[k]-left);\n\t\t\t\t\tc[ci++]=hoge(offset+y[k]-left, offset+len);\n\t\t\t\t\tstate++;\n\t\t\t\t}else{\n\t\t\t\t\tif(right<=x[k]){\n\t\t\t\t\t\ta[ai++]=cards[i];\n\t\t\t\t\t}else if(right<=y[k]){\n\t\t\t\t\t\tb[bi++]=cards[i];\n\t\t\t\t\t}else{\n\t\t\t\t\t\tc[ci++]=cards[i];\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t\tleft=right;\n\t\t\t}\n\t\t\tnCards=0;\n\t\t\tfor(int i=0; i<ci; i++){\n\t\t\t\tcards[nCards++]=c[i];\n\t\t\t}\n\t\t\tfor(int i=0; i<bi; i++){\n\t\t\t\tcards[nCards++]=b[i];\n\t\t\t}\n\t\t\tfor(int i=0; i<ai; i++){\n\t\t\t\tcards[nCards++]=a[i];\n\t\t\t}\n\t\t\tif(false){\n\t\t\t\tdebug(\"k\", k);\n\t\t\t\tfor(int i=0; i<nCards; i++){\n\t\t\t\t\tint offset=(int)cards[i];\n\t\t\t\t\tint len=(int)(cards[i]>>>32);\n\t\t\t\t\tdebug(offset, len);\n\t\t\t\t}\n\t\t\t\tdebug();\n\t\t\t}\n\t\t}\n\t\tp--;\n\t\tq--;\n\t\t// [p, q]ªrÈº\n\t\t// [p, q+1)ªrÈº\n\t\tint ans=0;\n\t\tq++;\n\t\tint left=0, right=0;\n\t\tfor(int k=0; k<nCards; k++){\n\t\t\tint offset=(int)cards[k];\n\t\t\tint len=(int)(cards[k]>>>32);\n\t\t\tright+=len;\n\n\t\t\tif(left<=q&&p<=right){\n\t\t\t\tint min=max(left, p)-left+offset;\n\t\t\t\tint max=min(right, q)-left+offset;\n\t\t\t\t// debug(\"\", min, max);\n\t\t\t\t// [i, j)ÅrÈºÌàÌÍH\n\t\t\t\t// [i, j)År+1¢ÌàÌÍH\n\t\t\t\tmax=min(max, r+1);\n\t\t\t\t// debug(\"\", min, max);\n\t\t\t\tans+=max(max-min, 0);\n\t\t\t}\n\t\t\tleft=right;\n\t\t}\n\t\tprintln(ans+\"\");\n\t}\n\n\tlong hoge(long left, long right){\n\t\tlong offset=left;\n\t\tlong len=right-left;\n\t\treturn (len<<32)|offset;\n\t}\n\n\tvoid debug(Object... os){\n\t\tSystem.err.println(Arrays.deepToString(os));\n\t}\n\n\tvoid print(String s){\n\t\tSystem.out.print(s);\n\t}\n\n\tvoid println(String s){\n\t\tSystem.out.println(s);\n\t}\n\n\tpublic static void main(String[] args){\n\t\t// System.setOut(new PrintStream(new BufferedOutputStream(System.out)));\n\t\tnew Main().run();\n\t}\n}"
  },
  {
    "language": "Java",
    "code": "\nimport java.util.*;\n\nimport static java.lang.Math.*;\nimport static java.util.Arrays.*;\n\npublic class Main {\n\n\tint INF = 1 << 28;\n\tlong n;\n\tint m;\n\tlong p;\n\tlong q;\n\tlong r;\n\tLinkedList<Segment> card;\n\tvoid run() {\n\t\tScanner sc = new Scanner(System.in);\n\t\tfor(;;) {\n\t\t\tn = sc.nextLong();\n\t\t\tif( n == 0) break;\n\t\t\tcard = new LinkedList<Segment>();\n\t\t\tcard.add(new Segment(1, n));\n\t\t\tm = sc.nextInt();\n\t\t\tp = sc.nextLong();\n\t\t\tq = sc.nextLong();\n\t\t\tr = sc.nextLong();\n\t\t\tLinkedList<Segment> a = new LinkedList<Segment>();\n\t\t\tLinkedList<Segment> b = new LinkedList<Segment>();\n\t\t\tfor(int i=0;i<m;i++) {\n\t\t\t\tlong x = sc.nextLong();\n\t\t\t\tlong y = sc.nextLong();\n\t\t\t\tfor(;!card.isEmpty();) {\n//\t\t\t\t\tSystem.out.println(x +\" \" + y);\n\t\t\t\t\tSegment s = card.removeFirst();\n\t\t\t\t\tif(s.size <= x ) {\n\t\t\t\t\t\ta.addLast(s);\n\t\t\t\t\t\tx -= s.size;\n\t\t\t\t\t\ty -= s.size;\n\t\t\t\t\t}\n\t\t\t\t\telse if( x>0 && s.size > x){\n\t\t\t\t\t\tSegment[] sp = s.split(x);\n\t\t\t\t\t\tcard.addFirst(sp[1]);\n\t\t\t\t\t\ta.addLast(sp[0]);\n\t\t\t\t\t\ty -= x;\n\t\t\t\t\t\tx = 0;\n\t\t\t\t\t\tcontinue;\n\t\t\t\t\t}\n\t\t\t\t\telse if( s.size <= y ) {\n\t\t\t\t\t\tb.addLast(s);\n\t\t\t\t\t\ty -= s.size;\n\t\t\t\t\t\tif(y==0) break;\n\t\t\t\t\t}\n\t\t\t\t\telse if(y>0 && s.size > y) {\n\t\t\t\t\t\tSegment[] sp = s.split(y);\n\t\t\t\t\t\tcard.addFirst(sp[1]);\n\t\t\t\t\t\tb.addLast(sp[0]);\n\t\t\t\t\t\ty = 0;\n\t\t\t\t\t\tbreak;\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t\tfor(Segment s: b)card.addLast(s);\n\t\t\t\tfor(Segment s: a)card.addLast(s);\n\t\t\t\ta.clear();\n\t\t\t\tb.clear();\n\t\t\t\t\n//\t\t\t\tfor(Segment s: card) System.err.println(\"(\" + s.s + \",\" + s.e + \")\");\n//\t\t\t\tSystem.err.println();\n\t\t\t}\n\t\t\tlong ans = 0;\n\t\t\tfor(;!card.isEmpty();) {\n\t\t\t\tSegment s = card.removeFirst();\n\t\t\t\tif(s.size < p) {\n\t\t\t\t\tp -= s.size;\n\t\t\t\t\tq -= s.size;\n\t\t\t\t}\n\t\t\t\telse if(p > 0 && s.size>=p) {\n\t\t\t\t\tif(s.size == 1) {\n\t\t\t\t\t\tans += s.cntElement(r);\n\t\t\t\t\t}\n\t\t\t\t\telse {\n\t\t\t\t\t\tSegment[] sp = s.split(p);\n\t\t\t\t\t\tcard.addFirst(sp[1]);\n\t\t\t\t\t}\n\t\t\t\t\t\n\t\t\t\t\tq -= p;\n\t\t\t\t\tp = 0;\n\t\t\t\t}\n\t\t\t\telse if(q > s.size) {\n\t\t\t\t\tq -= s.size;\n\t\t\t\t\tans += s.cntElement(r);\n\t\t\t\t}\n\t\t\t\telse if(s.size>=q) {\n\t\t\t\t\tSegment[] sp = s.split(q);\n\t\t\t\t\tans += sp[0].cntElement(r);\n\t\t\t\t\tbreak;\n\t\t\t\t}\n\t\t\t}\n\t\t\tSystem.out.println(ans);\n\t\t}\n\t}\n\t\n\tvoid debug(Object...os){\n\t\tSystem.err.println(Arrays.deepToString(os));\n\t}\n\n\tpublic static void main(String[] args) {\n\t\tnew Main().run();\n\t}\n\tclass Segment {\n\t\tlong s, e;\n\t\tlong size;\n\t\tSegment (long s, long e) {\n\t\t\tthis.s = s;\n\t\t\tthis.e = e;\n\t\t\tsize = e-s+1;\n\t\t}\n\t\t\n\t\tSegment[] split(long x) {\n\t\t\tSegment[] sp = new Segment[2];\n\t\t\tsp[0] = new Segment(s, s+x-1);\n\t\t\tsp[1] = new Segment(s+x, e);\n\t\t\treturn sp;\n\t\t}\n\t\t\n\t\tlong cntElement(long r) {\n\t\t\tif(r >= e) return size;\n\t\t\telse if( r>= s) return r-s+1;\n\t\t\treturn 0;\n\t\t}\n\t}\n}"
  },
  {
    "language": "Java",
    "code": "import java.util.ArrayList;\nimport java.util.Collections;\nimport java.util.Comparator;\nimport java.util.List;\n\n//Shuffle\npublic class Main{\n\n\tclass Scanner {\n\t\tint nextInt() {\n\t\t\ttry {\n\t\t\t\tint c = System.in.read();\n\t\t\t\twhile (c != '-' && (c < '0' || '9' < c))\n\t\t\t\t\tc = System.in.read();\n\t\t\t\tif (c == '-') return -nextInt();\n\t\t\t\tint res = 0;\n\t\t\t\tdo {\n\t\t\t\t\tres *= 10;\n\t\t\t\t\tres += c - '0';\n\t\t\t\t\tc = System.in.read();\n\t\t\t\t} while ('0' <= c && c <= '9');\n\t\t\t\treturn res;\n\t\t\t} catch (Exception e) {\n\t\t\t\treturn -1;\n\t\t\t}\n\t\t}\n\t}\n\n\tvoid run(){\n\t\tScanner sc = new Scanner();\n\t\tlong mask = (1L << 32)-1;\n\t\tComparator<Long> C = new Comparator<Long>() {\n\t\t\tpublic int compare(Long o1, Long o2) {\n\t\t\t\treturn (int) ((o1>>32)-(o2>>32));\n\t\t\t}\n\t\t};\n\t\tint[] p = new int[5000], q = new int[5000];\n\t\tfor(;;){\n\t\t\tint n = sc.nextInt();\n\t\t\tif(n==0)break;\n\t\t\tint m = sc.nextInt(), P = sc.nextInt(), Q = sc.nextInt(), R = sc.nextInt();\n\t\t\tList<Long> l = new ArrayList<Long>();\n\t\t\t//int(32bit)を2つ並べて1つのlong(64bit)とする、2つの値は区間の左端、右端\n\t\t\tl.add(((long)P<<32)|Q);\n\t\t\tfor(int i=0;i<m;i++){\n\t\t\t\tp[i] = sc.nextInt(); q[i] = sc.nextInt();\n\t\t\t}\n\t\t\tfor(int i=m-1;i>=0;i--){\n\t\t\t\tlong t1 = n-q[i], s2 = t1+1, t2 = n-p[i], s3 = n-p[i]+1, y = q[i];\n\t\t\t\tList<Long> next = new ArrayList<Long>(1500);\n\t\t\t\tfor(int j=0;j<l.size();j++){\n\t\t\t\t\tlong x = l.get(j);\n\t\t\t\t\tlong s = x>>32, t = x&mask;\n\t\t\t\t\tif(t<=t1){\n\t\t\t\t\t\tnext.add((s+y)<<32 | (t+y));\n\t\t\t\t\t}\n\t\t\t\t\telse if(t<=t2){\n\t\t\t\t\t\tif(s<=t1){\n\t\t\t\t\t\t\tnext.add((s+y)<<32 | (t1+y));\n\t\t\t\t\t\t\ts = s2;\n\t\t\t\t\t\t}\n\t\t\t\t\t\tnext.add((s-s2+p[i]+1)<<32 | (t-s2+p[i]+1));\n\t\t\t\t\t}\n\t\t\t\t\telse{\n\t\t\t\t\t\tif(s<=t1){\n\t\t\t\t\t\t\tnext.add((s+y)<<32 | (t1+y));\n\t\t\t\t\t\t\ts = s2;\n\t\t\t\t\t\t}\n\t\t\t\t\t\tif(s<=t2){\n\t\t\t\t\t\t\tnext.add((s-s2+p[i]+1)<<32 | (t2-s2+p[i]+1));\n\t\t\t\t\t\t\ts = s3;\n\t\t\t\t\t\t}\n\t\t\t\t\t\tnext.add((s-s3+1)<<32 | (t-s3+1));\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t\t//区間数が多くなってきたら隣り合っている区間の結合処理\n\t\t\t\t//あと最後は必ず行う\n\t\t\t\tif(i==0||1100<=next.size()){\n\t\t\t\t\tl = new ArrayList<Long>();\n\t\t\t\t\tCollections.sort(next, C);\n\t\t\t\t\tlong ss = next.get(0)>>32, tt = next.get(0)&mask;\n\t\t\t\t\tfor(int j=1;j<next.size();j++){\n\t\t\t\t\t\tlong x = next.get(j);\n\t\t\t\t\t\tlong s = x>>32, t = x&mask;\n\t\t\t\t\t\tif(tt+1==s)tt = t;\n\t\t\t\t\t\telse{\n\t\t\t\t\t\t\tl.add((ss<<32)|tt);\n\t\t\t\t\t\t\tss = s; tt = t;\n\t\t\t\t\t\t}\n\t\t\t\t\t}\n\t\t\t\t\tl.add((ss<<32)|tt);\n\t\t\t\t}\n\t\t\t\telse{\n\t\t\t\t\tl = next;\n\t\t\t\t}\n\t\t\t}\n\t\t\tint res = 0;\n\t\t\tfor(long x:l){\n\t\t\t\tlong s = x>>32, t = x&mask;\n\t\t\t\tif(R<s)break;\n\t\t\t\tif(R<t)t = R;\n\t\t\t\tres+=t-s+1;\n\t\t\t}\n\t\t\tSystem.out.println(res);\n\t\t}\n\t}\n\n\tpublic static void main(String[] args) {\n\t\tnew Main().run();\n\t}\n}"
  },
  {
    "language": "Java",
    "code": "import java.util.*;\n\npublic class Main {\n\t\n\tpublic static void main(String[] args) {\n\t\tScanner sc = new Scanner(System.in);\n\t\t\n\t\twhile(true){\n\t\t\tint n = sc.nextInt();\n\t\t\tif(n==0) break;\n\t\t\tint m = sc.nextInt();\n\t\t\tint p = sc.nextInt();\n\t\t\tint q = sc.nextInt();\n\t\t\tint r = sc.nextInt();\n\t\t\tint x, y;\n\t\t\t\n\t\t\tint[] a = new int[n];\n\t\t\tint[] b = new int[n];\n\t\t\tfor(int i=0;i<n;i++) a[i] = i+1;\n\t\t\t\n\t\t\tfor(int i=0;i<m;i++){\n\t\t\t\tx = sc.nextInt();\n\t\t\t\ty = sc.nextInt();\n\t\t\t\t\n\t\t\t\tfor(int j=0;j<y;j++) b[j] = a[j];\n\t\t\t\tfor(int j=y;j<n;j++) a[j-y] = a[j];\n\t\t\t\tfor(int j=0;j<y-x;j++) a[n-y+j] = b[x+j];\n\t\t\t\tfor(int j=0;j<x;j++) a[n-x+j] = b[j];\n\t\t\t}\n\t\t\tint count = 0;\n\t\t\tfor(int j=p-1;j<q;j++){\n\t\t\t\tif(a[j]<=r) count++;\n\t\t\t}\n\t\t\tSystem.out.println(count);\n\t\t}\t\n\t}\t\n}"
  },
  {
    "language": "Java",
    "code": "import java.util.Collections;\nimport java.util.LinkedList;\nimport java.util.Scanner;\n\n//Shuffle\npublic class Main{\n\n\tclass R implements Comparable<R>{\n\t\tint s, t;\n\t\tpublic R(int s, int t) {\n\t\t\tthis.s = s;\n\t\t\tthis.t = t;\n\t\t}\n\t\tpublic int compareTo(R o) {\n\t\t\treturn s-o.s;\n\t\t}\n\t}\n\t\n\tvoid run(){\n\t\tScanner sc = new Scanner(System.in);\n\t\tfor(;;){\n\t\t\tint n = sc.nextInt();\n\t\t\tif(n==0)break;\n\t\t\tint m = sc.nextInt(), p = sc.nextInt(), q = sc.nextInt(), r = sc.nextInt();\n\t\t\tint[] ps = new int[m], qs = new int[m];\n\t\t\tfor(int i=0;i<m;i++){\n\t\t\t\tps[i] = sc.nextInt(); qs[i] = sc.nextInt();\n\t\t\t}\n\t\t\tLinkedList<R> l = new LinkedList<R>();\n\t\t\tl.add(new R(p, q));\n\t\t\tfor(int Q=m-1;Q>=0;Q--){\n\t\t\t\tint x = ps[Q], y = qs[Q];\n\t\t\t\tLinkedList<R> next = new LinkedList<R>();\n\t\t\t\tfor(int i=0;i<l.size();i++){\n\t\t\t\t\tR v = l.get(i);\n\t\t\t\t\tif(v.t<=n-y)next.add(new R(v.s+y, v.t+y));\n\t\t\t\t\telse if(v.s<=n-y){\n\t\t\t\t\t\tl.remove(i); l.add(i, new R(n-y+1, v.t)); i--;\n\t\t\t\t\t\tnext.add(new R(v.s+y, n));\n\t\t\t\t\t}\n\t\t\t\t\telse if(v.t<=n-x){\n\t\t\t\t\t\tnext.add(new R(v.s+x+y-n, v.t+x-n+y));\n\t\t\t\t\t}\n\t\t\t\t\telse if(v.s<=n-x){\n\t\t\t\t\t\tl.remove(i); l.add(i, new R(n-x+1, v.t)); i--;\n\t\t\t\t\t\tnext.add(new R(v.s+x+y-n, y));\n\t\t\t\t\t}\n\t\t\t\t\telse next.add(new R(v.s+x-n, v.t+x-n));\n\t\t\t\t}\n\t\t\t\tCollections.sort(next);\n\t\t\t\tfor(int i=0;i+1<next.size();i++){\n\t\t\t\t\tif(next.get(i).t+1==next.get(i+1).s){\n\t\t\t\t\t\tR v = new R(next.get(i).s, next.get(i+1).t);\n\t\t\t\t\t\tnext.remove(i); next.remove(i); next.add(i, v); i--;\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t\tl = next;\n\t\t\t}\n\t\t\tint res = 0;\n\t\t\tfor(R v:l){\n\t\t\t\tif(v.t<=r)res+=v.t-v.s+1;\n\t\t\t\telse if(v.s<=r)res+=r-v.s+1;\n\t\t\t}\n\t\t\tSystem.out.println(res);\n\t\t}\n\t}\n\t\n\tpublic static void main(String[] args) {\n\t\tnew Main().run();\n\t}\n}"
  },
  {
    "language": "Java",
    "code": "import java.util.ArrayList;\nimport java.util.Collections;\nimport java.util.Comparator;\nimport java.util.List;\n\n//Shuffle\npublic class Main{\n\n\tclass Scanner {\n\t\tint nextInt() {\n\t\t\ttry {\n\t\t\t\tint c = System.in.read();\n\t\t\t\twhile (c != '-' && (c < '0' || '9' < c))\n\t\t\t\t\tc = System.in.read();\n\t\t\t\tif (c == '-') return -nextInt();\n\t\t\t\tint res = 0;\n\t\t\t\tdo {\n\t\t\t\t\tres *= 10;\n\t\t\t\t\tres += c - '0';\n\t\t\t\t\tc = System.in.read();\n\t\t\t\t} while ('0' <= c && c <= '9');\n\t\t\t\treturn res;\n\t\t\t} catch (Exception e) {\n\t\t\t\treturn -1;\n\t\t\t}\n\t\t}\n\t}\n\n\tvoid run(){\n\t\tScanner sc = new Scanner();\n\t\tlong mask = (1L << 32)-1;\n\t\tComparator<Long> C = new Comparator<Long>() {\n\t\t\tpublic int compare(Long o1, Long o2) {\n\t\t\t\treturn (int) ((o1>>32)-(o2>>32));\n\t\t\t}\n\t\t};\n\t\tint[] p = new int[5000], q = new int[5000];\n\t\tfor(;;){\n\t\t\tint n = sc.nextInt();\n\t\t\tif(n==0)break;\n\t\t\tint m = sc.nextInt(), P = sc.nextInt(), Q = sc.nextInt(), R = sc.nextInt();\n\t\t\tList<Long> l = new ArrayList<Long>();\n\t\t\t//int(32bit)を2つ並べて1つのlong(64bit)とする、2つの値は区間の左端、右端\n\t\t\tl.add(((long)P<<32)|Q);\n\t\t\tfor(int i=0;i<m;i++){\n\t\t\t\tp[i] = sc.nextInt(); q[i] = sc.nextInt();\n\t\t\t}\n\t\t\tfor(int i=m-1;i>=0;i--){\n\t\t\t\tlong t1 = n-q[i], s2 = t1+1, t2 = n-p[i], s3 = n-p[i]+1, y = q[i];\n\t\t\t\tList<Long> next = new ArrayList<Long>();\n\t\t\t\tfor(int j=0;j<l.size();j++){\n\t\t\t\t\tlong x = l.get(j);\n\t\t\t\t\tlong s = x>>32, t = x&mask;\n\t\t\t\t\tif(t<=t1){\n\t\t\t\t\t\tnext.add((s+y)<<32 | (t+y));\n\t\t\t\t\t}\n\t\t\t\t\telse if(t<=t2){\n\t\t\t\t\t\tif(s<=t1){\n\t\t\t\t\t\t\tnext.add((s+y)<<32 | (t1+y));\n\t\t\t\t\t\t\ts = s2;\n\t\t\t\t\t\t}\n\t\t\t\t\t\tnext.add((s-s2+p[i]+1)<<32 | (t-s2+p[i]+1));\n\t\t\t\t\t}\n\t\t\t\t\telse{\n\t\t\t\t\t\tif(s<=t1){\n\t\t\t\t\t\t\tnext.add((s+y)<<32 | (t1+y));\n\t\t\t\t\t\t\ts = s2;\n\t\t\t\t\t\t}\n\t\t\t\t\t\tif(s<=t2){\n\t\t\t\t\t\t\tnext.add((s-s2+p[i]+1)<<32 | (t2-s2+p[i]+1));\n\t\t\t\t\t\t\ts = s3;\n\t\t\t\t\t\t}\n\t\t\t\t\t\tnext.add((s-s3+1)<<32 | (t-s3+1));\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t\t//区間数が多くなってきたら隣り合っている区間の結合処理\n\t\t\t\t//あと最後は必ず行う\n\t\t\t\tif(i==0||1100<=next.size()){\n\t\t\t\t\tl = new ArrayList<Long>();\n\t\t\t\t\tCollections.sort(next, C);\n\t\t\t\t\tlong ss = next.get(0)>>32, tt = next.get(0)&mask;\n\t\t\t\t\tfor(int j=1;j<next.size();j++){\n\t\t\t\t\t\tlong x = next.get(j);\n\t\t\t\t\t\tlong s = x>>32, t = x&mask;\n\t\t\t\t\t\tif(tt+1==s)tt = t;\n\t\t\t\t\t\telse{\n\t\t\t\t\t\t\tl.add((ss<<32)|tt);\n\t\t\t\t\t\t\tss = s; tt = t;\n\t\t\t\t\t\t}\n\t\t\t\t\t}\n\t\t\t\t\tl.add((ss<<32)|tt);\n\t\t\t\t}\n\t\t\t\telse{\n\t\t\t\t\tl = next;\n\t\t\t\t}\n\t\t\t}\n\t\t\tint res = 0;\n\t\t\tfor(long x:l){\n\t\t\t\tlong s = x>>32, t = x&mask;\n\t\t\t\tif(R<s)break;\n\t\t\t\tif(R<t)t = R;\n\t\t\t\tres+=t-s+1;\n\t\t\t}\n\t\t\tSystem.out.println(res);\n\t\t}\n\t}\n\n\tpublic static void main(String[] args) {\n\t\tnew Main().run();\n\t}\n}"
  },
  {
    "language": "Java",
    "code": "import java.util.Scanner;\n\npublic class Main {\n\tpublic static void main(String args[]) {\n\t\tScanner sc = new Scanner(System.in);\n\t\tint a[];\n\t\tint n, m;\n\t\tint x, y;\n\t\tint p, q, r;\n\t\tint count;\n\n\t\tn = sc.nextInt();\n\t\twhile (n != 0) {\n\t\t\ta = new int [n];\n\t\t\tfor (int i = 0; i < n; i++) {\n\t\t\t\ta[i] = i + 1;\n\t\t\t}\n\t\t\tm = sc.nextInt();\n\t\t\tp = sc.nextInt();\n\t\t\tq = sc.nextInt();\n\t\t\tr = sc.nextInt();\n\t\t\tfor (int i = 0; i < m; i++) {\n\t\t\t\tx = sc.nextInt();\n\t\t\t\ty = sc.nextInt();\n\t\t\t\tf(a, n, x, y);\n\t\t\t}\n\t\t\tcount = 0;\n\t\t\tfor (int i = p - 1; i < q; i++) {\n\t\t\t\tif (a[i] <= r) {\n\t\t\t\t\tcount++;\n\t\t\t\t}\n\t\t\t}\n\t\t\tSystem.out.println(count);\n\t\t\tn = sc.nextInt();\n\t\t}\n\t}\n\n\tpublic static void f(int a[], int n, int x, int y) {\n\t\tint b[] = new int[n];\n\t\tfor (int i = 0; i < n; i++) {\n\t\t\tb[i] = a[i];\n\t\t}\n\t\tfor (int i = 0; i < n; i++) {\n\t\t\tif (i < x) {\n\t\t\t\ta[i - x + n] = b[i];\n\t\t\t} else if (x <= i && i < y) {\n\t\t\t\ta[i - x - y + n] = b[i];\n\t\t\t} else {\n\t\t\t\ta[i - y] = b[i];\n\t\t\t}\n\t\t}\n\t}\n}"
  },
  {
    "language": "Java",
    "code": "\nimport java.awt.Point;\nimport java.io.IOException;\nimport java.util.ArrayList;\nimport java.util.Collections;\nimport java.util.List;\nimport java.util.Scanner;\n\npublic class Main {\n\n\tpublic static void main(String[] args) throws IOException {\n\n\t\tnew Main().run();\n\t}\n\n\tprivate void run() throws IOException {\n\t\tScanner scanner = new Scanner(System.in);\n\t\twhile (true) {\n\t\t\tint n = scanner.nextInt();\n\t\t\tif (n == 0)\n\t\t\t\tbreak;\n\t\t\tint m = scanner.nextInt();\n\t\t\tint p = scanner.nextInt();\n\t\t\tint q = scanner.nextInt();\n\t\t\tint r = scanner.nextInt();\n\t\t\tList<Point> v = new ArrayList<Point>();\n\t\t\tv.add(new Point(1, n));\n\t\t\twhile (m-- > 0) {\n\t\t\t\tint x = scanner.nextInt();\n\t\t\t\tint y = scanner.nextInt();\n\t\t\t\tList<Point> a, b, c;\n\t\t\t\ta = new ArrayList<Point>();\n\t\t\t\tb = new ArrayList<Point>();\n\t\t\t\tc = new ArrayList<Point>();\n\t\t\t\tcut(v, y, c);\n\t\t\t\tcut(v, x, b);\n\t\t\t\ta = v;\n\t\t\t\tv = c;\n\t\t\t\tv.addAll(b);\n\t\t\t\tv.addAll(a);\n\t\t\t}\n\t\t\tList<Point> rv = new ArrayList<Point>();\n\t\t\tcut(v, q, rv);\n\t\t\tcut(v, p - 1, rv);\n\t\t\tint ans = 0;\n\t\t\tfor (int i = 0; i < rv.size(); i++)\n\t\t\t\tans += Math.max(0, Math.min(r - rv.get(i).x + 1, rv.get(i).y));\n\t\t\tSystem.out.println(ans);\n\t\t}\n\t}\n\n\tprivate void cut(List<Point> v, int x, List<Point> r) {\n\t\tr.clear();\n\t\tint n = 0;\n\t\tint p = 0;\n\t\tfor (; n + v.get(p).y <= x; n += v.get(p).y, p++)\n\t\t\t;\n\t\tPoint ns = new Point(v.get(p).x + x - n, v.get(p).y - (x - n));\n\t\tr.add(ns);\n\t\tfor (int j = p + 1; j < v.size(); j++) {\n\t\t\tr.add(new Point(v.get(j).x, v.get(j).y));\n\t\t}\n\t\tfor(int j = p+1;j<v.size();)\n\t\t\tv.remove(j);\n\t\tv.get(v.size() - 1).y = x - n;\n\n\t}\n}"
  },
  {
    "language": "Java",
    "code": "\nimport java.util.*;\n\nimport static java.lang.Math.*;\nimport static java.util.Arrays.*;\n\npublic class Main {\n\n\tint INF = 1 << 28;\n\tlong n;\n\tint m;\n\tlong p;\n\tlong q;\n\tlong r;\n\tLinkedList<Segment> card;\n\tvoid run() {\n\t\tScanner sc = new Scanner(System.in);\n\t\tfor(;;) {\n\t\t\tn = sc.nextLong();\n\t\t\tif( n == 0) break;\n\t\t\tcard = new LinkedList<Segment>();\n\t\t\tcard.add(new Segment(1, n));\n\t\t\tm = sc.nextInt();\n\t\t\tp = sc.nextLong();\n\t\t\tq = sc.nextLong();\n\t\t\tr = sc.nextLong();\n\t\t\tLinkedList<Segment> a = new LinkedList<Segment>();\n\t\t\tLinkedList<Segment> b = new LinkedList<Segment>();\n\t\t\tLinkedList<Segment> c = new LinkedList<Segment>();\n\t\t\tfor(int i=0;i<m;i++) {\n\t\t\t\tlong x = sc.nextLong();\n\t\t\t\tlong y = sc.nextLong();\n\t\t\t\tfor(;!card.isEmpty();) {\n//\t\t\t\t\tSystem.out.println(x +\" \" + y);\n\t\t\t\t\tSegment s = card.removeFirst();\n\t\t\t\t\tif(s.size <= x ) {\n\t\t\t\t\t\ta.addLast(s);\n\t\t\t\t\t\tx -= s.size;\n\t\t\t\t\t\ty -= s.size;\n\t\t\t\t\t}\n\t\t\t\t\telse if( x>0 && s.size > x){\n\t\t\t\t\t\tSegment[] sp = s.split(x);\n\t\t\t\t\t\tcard.addFirst(sp[1]);\n\t\t\t\t\t\ta.addLast(sp[0]);\n\t\t\t\t\t\ty -= x;\n\t\t\t\t\t\tx = 0;\n\t\t\t\t\t\tcontinue;\n\t\t\t\t\t}\n\t\t\t\t\telse if( s.size <= y ) {\n\t\t\t\t\t\tb.addLast(s);\n\t\t\t\t\t\ty -= s.size;\n\t\t\t\t\t}\n\t\t\t\t\telse if(y>0 && s.size > y) {\n\t\t\t\t\t\tSegment[] sp = s.split(y);\n\t\t\t\t\t\tcard.addFirst(sp[1]);\n\t\t\t\t\t\tb.addLast(sp[0]);\n\t\t\t\t\t\ty = 0;\n\t\t\t\t\t}\n\t\t\t\t\telse {\n\t\t\t\t\t\tc.addLast(s);\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t\tcard.addAll(c);\n\t\t\t\tcard.addAll(b);\n\t\t\t\tcard.addAll(a);\n\t\t\t\ta.clear();\n\t\t\t\tb.clear();\n\t\t\t\tc.clear();\n\t\t\t\t\n//\t\t\t\tfor(Segment s: card) System.err.println(\"(\" + s.s + \",\" + s.e + \")\");\n//\t\t\t\tSystem.err.println();\n\t\t\t}\n\t\t\tlong ans = 0;\n\t\t\tfor(;!card.isEmpty();) {\n\t\t\t\tSegment s = card.removeFirst();\n\t\t\t\tif(s.size < p) {\n\t\t\t\t\tp -= s.size;\n\t\t\t\t\tq -= s.size;\n\t\t\t\t}\n\t\t\t\telse if(p > 0 && s.size>=p) {\n\t\t\t\t\tif(s.size == 1) {\n\t\t\t\t\t\tans += s.cntElement(r);\n\t\t\t\t\t}\n\t\t\t\t\telse {\n\t\t\t\t\t\tSegment[] sp = s.split(p);\n\t\t\t\t\t\tcard.addFirst(sp[1]);\n\t\t\t\t\t}\n\t\t\t\t\t\n\t\t\t\t\tq -= p;\n\t\t\t\t\tp = 0;\n\t\t\t\t}\n\t\t\t\telse if(q > s.size) {\n\t\t\t\t\tq -= s.size;\n\t\t\t\t\tans += s.cntElement(r);\n\t\t\t\t}\n\t\t\t\telse if(s.size>=q) {\n\t\t\t\t\tSegment[] sp = s.split(q);\n\t\t\t\t\tans += sp[0].cntElement(r);\n\t\t\t\t\tbreak;\n\t\t\t\t}\n\t\t\t}\n\t\t\tSystem.out.println(ans);\n\t\t}\n\t}\n\t\n\tvoid debug(Object...os){\n\t\tSystem.err.println(Arrays.deepToString(os));\n\t}\n\n\tpublic static void main(String[] args) {\n\t\tnew Main().run();\n\t}\n\tclass Segment {\n\t\tlong s, e;\n\t\tlong size;\n\t\tSegment (long s, long e) {\n\t\t\tthis.s = s;\n\t\t\tthis.e = e;\n\t\t\tsize = e-s+1;\n\t\t}\n\t\t\n\t\tSegment[] split(long x) {\n\t\t\tSegment[] sp = new Segment[2];\n\t\t\tsp[0] = new Segment(s, s+x-1);\n\t\t\tsp[1] = new Segment(s+x, e);\n\t\t\treturn sp;\n\t\t}\n\t\t\n\t\tlong cntElement(long r) {\n\t\t\tif(r >= e) return size;\n\t\t\telse if( r>= s) return r-s+1;\n\t\t\treturn 0;\n\t\t}\n\t}\n}"
  },
  {
    "language": "Java",
    "code": "\nimport java.io.BufferedReader;\nimport java.io.IOException;\nimport java.io.InputStreamReader;\nimport java.util.ArrayList;\nimport java.util.List;\nimport java.util.StringTokenizer;\n\npublic class Main {\n\n\tpublic static void main(String[] args) throws IOException {\n\n\t\tnew Main().run();\n\t}\n\n\tprivate void run() throws IOException {\n\t\tBufferedReader reader = new BufferedReader(new InputStreamReader(System.in));\n\t\twhile (true) {\n\t\t\tint n = Integer.parseInt(reader.readLine());\n\t\t\tif (n == 0)\n\t\t\t\tbreak;\n\t\t\tint m = Integer.parseInt(reader.readLine());\n\t\t\tStringTokenizer t = new StringTokenizer(reader.readLine());\n\t\t\tint p = Integer.parseInt(t.nextToken());\n\t\t\tint q = Integer.parseInt(t.nextToken());\n\t\t\tint r = Integer.parseInt(t.nextToken());\n\t\t\tList<Point> v = new ArrayList<Point>();\n\t\t\t\n\t\t\tv.add(new Point(1, n));\n\t\t\twhile (m-- > 0) {\n\t\t\t\tt = new StringTokenizer(reader.readLine());\n\t\t\t\tint x = Integer.parseInt(t.nextToken());\n\t\t\t\tint y = Integer.parseInt(t.nextToken());\n\t\t\t\tList<Point> a, b, c;\n\t\t\t\tb = new ArrayList<Point>();\n\t\t\t\tc = new ArrayList<Point>();\n\t\t\t\ta = new ArrayList<Point>();\n\t\t\t\tcut(v, y, c);\n\t\t\t\tcut(v, x, b);\n\t\t\t\ta = v;\n\t\t\t\tv = c;\n\t\t\t\tv.addAll(b);\n\t\t\t\tv.addAll(a);\n\t\t\t}\n\t\t\tList<Point> rv = new ArrayList<Point>();\n\t\t\tcut(v, q, rv);\n\t\t\tcut(v, p - 1, rv);\n\t\t\tint ans = 0;\n\t\t\tfor (int i = 0; i < rv.size(); i++)\n\t\t\t\tans += Math.max(0, Math.min(r - rv.get(i).x + 1, rv.get(i).y));\n\t\t\tSystem.out.println(ans);\n\t\t}\n\t}\n\tclass Point{\n\t\tint x,y;\n\n\t\tpublic Point(int x, int y) {\n\t\t\tsuper();\n\t\t\tthis.x = x;\n\t\t\tthis.y = y;\n\t\t}\n\n\t\t@Override\n\t\tpublic String toString() {\n\t\t\treturn \"Point [x=\" + x + \", y=\" + y + \"]\";\n\t\t}\n\t\t\n\t}\n\n\tprivate void cut(List<Point> v, int x, List<Point> r) {\n\t\tr.clear();\n\t\tint n = 0;\n\t\tint p = 0;\n\t\twhile (n + v.get(p).y <= x) {\n\t\t\tn += v.get(p).y;\n\t\t\tp++;\n\t\t}\n\t\tPoint ns = new Point(v.get(p).x + x - n, v.get(p).y - (x - n));\n\t\tr.add(ns);\n\t\tfor (int j = p + 1; j < v.size(); j++) {\n\t\t\tr.add(new Point(v.get(j).x, v.get(j).y));\n\t\t}\n\t\tfor (int j = v.size() - 1; j >= p + 1; j--)\n\t\t\tv.remove(j);\n\t\tv.get(v.size() - 1).y = x - n;\n\n\t}\n}"
  },
  {
    "language": "Java",
    "code": "import java.util.ArrayList;\nimport java.util.Collections;\nimport java.util.Comparator;\nimport java.util.List;\nimport java.util.Scanner;\n\n//Shuffle\npublic class Main{\n\t\n\tvoid run(){\n\t\tScanner sc = new Scanner(System.in);\n\t\tlong mask = (1L << 32)-1;\n\t\tComparator<Long> C = new Comparator<Long>() {\n\t\t\tpublic int compare(Long o1, Long o2) {\n\t\t\t\treturn (int) ((o1>>32)-(o2>>32));\n\t\t\t}\n\t\t};\n\t\tfor(;;){\n\t\t\tint n = sc.nextInt();\n\t\t\tif(n==0)break;\n//\t\t\tlong T = System.currentTimeMillis();\n\t\t\tint m = sc.nextInt(), P = sc.nextInt(), Q = sc.nextInt(), R = sc.nextInt();\n\t\t\tList<Long> l = new ArrayList<Long>();\n\t\t\tl.add(((long)P<<32)|Q);\n\t\t\tint[] p = new int[m], q = new int[m];\n\t\t\tfor(int i=0;i<m;i++){\n\t\t\t\tp[i] = sc.nextInt(); q[i] = sc.nextInt();\n\t\t\t}\n\t\t\tint maxSize = 0;\n\t\t\tfor(int i=m-1;i>=0;i--){\n//\t\t\t\tSystem.out.println(\"L:\"+l.size());\n\t\t\t\tlong t1 = n-q[i], s2 = t1+1, t2 = n-p[i], s3 = n-p[i]+1, y = q[i];\n\t\t\t\tList<Long> next = new ArrayList<Long>();\n\t\t\t\tfor(int j=0;j<l.size();j++){\n\t\t\t\t\tlong x = l.get(j);\n\t\t\t\t\tlong s = x>>32, t = x&mask;\n\t\t\t\t\tif(t<=t1){\n\t\t\t\t\t\tnext.add((s+y)<<32 | (t+y));\n\t\t\t\t\t}\n\t\t\t\t\telse if(t<=t2){\n\t\t\t\t\t\tif(s<=t1){\n\t\t\t\t\t\t\tnext.add((s+y)<<32 | (t1+y));\n\t\t\t\t\t\t\ts = s2;\n\t\t\t\t\t\t}\n\t\t\t\t\t\tnext.add((s-s2+p[i]+1)<<32 | (t-s2+p[i]+1));\n\t\t\t\t\t}\n\t\t\t\t\telse{\n\t\t\t\t\t\tif(s<=t1){\n\t\t\t\t\t\t\tnext.add((s+y)<<32 | (t1+y));\n\t\t\t\t\t\t\ts = s2;\n\t\t\t\t\t\t}\n\t\t\t\t\t\tif(s<=t2){\n\t\t\t\t\t\t\tnext.add((s-s2+p[i]+1)<<32 | (t2-s2+p[i]+1));\n\t\t\t\t\t\t\ts = s3;\n\t\t\t\t\t\t}\n\t\t\t\t\t\tnext.add((s-s3+1)<<32 | (t-s3+1));\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t\t\n\t\t\t\tl.clear();\n//\t\t\t\tl = next;\n\t\t\t\tmaxSize = Math.max(maxSize, l.size());\n\t\t\t\tCollections.sort(next, C);\n\t\t\t\tlong ss = next.get(0)>>32, tt = next.get(0)&mask;\n\t\t\t\tfor(int j=1;j<next.size();j++){\n\t\t\t\t\tlong x = next.get(j);\n\t\t\t\t\tlong s = x>>32, t = x&mask;\n\t\t\t\t\tif(tt+1==s)tt = t;\n\t\t\t\t\telse{\n\t\t\t\t\t\tl.add((ss<<32)|tt);\n\t\t\t\t\t\tss = s; tt = t;\n\t\t\t\t\t}\n//\t\t\t\t\tlong x1 = next.get(j), x2 = next.get(j+1);\n//\t\t\t\t\tlong t = x1&mask, s = x2>>32;\n//\t\t\t\t\tif(t+1==s){\n//\t\t\t\t\t\tl.remove(j); l.remove(j);\n//\t\t\t\t\t\ts = x1>>32; t = x2&mask;\n//\t\t\t\t\t\tl.add(j--, (s<<32)|t);\n//\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t\tl.add((ss<<32)|tt);\n\t\t\t}\n\t\t\tint res = 0;\n\t\t\tfor(long x:l){\n\t\t\t\tlong s = x>>32, t = x&mask;\n\t\t\t\tif(R<s)break;\n\t\t\t\tif(R<t)t = R;\n\t\t\t\tres+=t-s+1;\n\t\t\t}\n\t\t\tSystem.out.println(res);\n//\t\t\tSystem.out.println((System.currentTimeMillis()-T)+\" ms.\");\n\t\t}\n\t}\n\t\n\tpublic static void main(String[] args) {\n\t\tnew Main().run();\n\t}\n}"
  },
  {
    "language": "Java",
    "code": "import java.io.BufferedReader;\nimport java.io.IOException;\nimport java.io.InputStreamReader;\nimport java.util.ArrayDeque;\nimport java.util.Deque;\n\nimport static java.lang.Integer.parseInt;\n\n/**\n * Shuffle\n * JOI 8th, Pre 5\n */\npublic class Main {\n\n\tpublic static void main(String[] args) throws IOException {\n\t\tBufferedReader br = new BufferedReader(new InputStreamReader(System.in));\n\t\tString line;\n\t\tString[] words;\n\n\t\twhile ((line = br.readLine()) != null && !line.isEmpty()) {\n\n\t\t\tint n = parseInt(line);\n\t\t\tif (n == 0) break;\n\n\t\t\tint m = parseInt(br.readLine());\n\n\t\t\twords = br.readLine().split(\" \");\n\n\t\t\tint p, q, r;\n\t\t\tp = parseInt(words[0]);\n\t\t\tq = parseInt(words[1]);\n\t\t\tr = parseInt(words[2]);\n\n\t\t\t//shuffle\n\t\t\t//ABC -> CBA\n\t\t\tDeque<int[]> ABC = new ArrayDeque<>();\n\t\t\tABC.offer(new int[]{1, n});\n\n\t\t\tfor (int i = 0; i < m; i++) {\n\t\t\t\tline = br.readLine();\n\n\t\t\t\tint x, y;\n\t\t\t\tx = parseInt(line.substring(0, line.indexOf(' ')));\n\t\t\t\ty = parseInt(line.substring(line.indexOf(' ') + 1));\n\t\t\t\ty -= x;\n\n\t\t\t\tDeque<int[]> A = head(ABC, x);\n\t\t\t\tDeque<int[]> B = head(ABC, y);\n\n\t\t\t\t//C+B+A\n\t\t\t\tfor (int[] b : B) ABC.offer(b);\n\t\t\t\tfor (int[] a : A) ABC.offer(a);\n\t\t\t}\n\n\t\t\t//solve\n\t\t\tint count = 0;\n\t\t\tp--;\n\t\t\tq -= p;\n\n\t\t\thead(ABC, p);\n\t\t\tABC = head(ABC, q);\n\n\t\t\tfor (int[] c : ABC) {\n\t\t\t\tif (c[1] <= r) {\n\t\t\t\t\tcount += c[1] - c[0] + 1;\n\t\t\t\t} else if (c[0] <= r && r < c[1]) {\n\t\t\t\t\tcount += r - c[0] + 1;\n\t\t\t\t}\n\t\t\t}\n\n\t\t\tSystem.out.println(count);\n\n\t\t}\n\t}\n\n\tstatic Deque<int[]> head(Deque<int[]> deque, int size) {\n\n\t\tDeque<int[]> head = new ArrayDeque<>();\n\n\t\twhile (size > 0) {\n\t\t\tint _x = deque.peek()[1] - deque.peek()[0] + 1;\n\t\t\tif (size == _x) {\n\t\t\t\thead.offer(deque.poll());\n\t\t\t\tsize = 0;\n\t\t\t} else if (size > _x) {\n\t\t\t\thead.offer(deque.poll());\n\t\t\t\tsize -= _x;\n\t\t\t} else if (size < _x) {\n\t\t\t\thead.offer(new int[]{\n\t\t\t\t\t\tdeque.peek()[0],\n\t\t\t\t\t\tdeque.peek()[0] + size - 1\n\t\t\t\t});\n\t\t\t\tdeque.peek()[0] = deque.peek()[0] + size;\n\t\t\t\tsize = 0;\n\t\t\t}\n\t\t}\n\n\t\treturn head;\n\t}\n}"
  },
  {
    "language": "Java",
    "code": "import java.util.Arrays;\nimport java.util.Scanner;\n\npublic class Main {\n\tpublic static void main(String[] args) {\n\t\tScanner in = new Scanner(System.in);\n\t\tint n, m, p, q, r;\n\t\twhile ((n = in.nextInt()) > 0) {\n\t\t\tm = in.nextInt();\n\t\t\tp = in.nextInt() - 1;\n\t\t\tq = in.nextInt() - 1;\n\t\t\tboolean[] cards = new boolean[n];\n\t\t\tArrays.fill(cards, 0, in.nextInt(), true);\n\t\t\tboolean[] next = new boolean[n];\n\t\t\tfor (int i = 0; i < m; i++) {\n\t\t\t\tint x = in.nextInt();\n\t\t\t\tint y = in.nextInt();\n\t\t\t\tSystem.arraycopy(cards, 0, next, n - x, x);\n\t\t\t\tSystem.arraycopy(cards, x, next, n - y, y - x);\n\t\t\t\tSystem.arraycopy(cards, y, next, 0, n - y);\n\t\t\t\tboolean[] c = cards;\n\t\t\t\tcards = next;\n\t\t\t\tnext = c;\n\t\t\t}\n\t\t\tint count = 0;\n\t\t\tfor (int i = p; i <= q; i++) {\n\t\t\t\tif (cards[i])\n\t\t\t\t\tcount++;\n\t\t\t}\n\t\t\tSystem.out.println(count);\n\t\t}\n\t}\n}"
  },
  {
    "language": "Java",
    "code": "import java.util.Scanner;\n\npublic class Main {\n\n\tstatic Scanner sc = new Scanner(System.in);\n\tstatic int MOD = 100000;\n\n\tpublic static void main(String[] args) {\n\t\twhile (true) {\n\t\t\tint N = sc.nextInt();\n\t\t\tif (N == 0) break;\n\t\t\tint M = sc.nextInt();\n\t\t\tint P = sc.nextInt() - 1;\n\t\t\tint Q = sc.nextInt() - 1;\n\t\t\tint R = sc.nextInt();\n\t\t\tNode EDGE = new Node(0, 0);\n\t\t\tNode top = new Node(1, N);\n\t\t\ttop.prev = top.next = EDGE;\n\t\t\tEDGE.next = EDGE.prev = top;\n\t\t\tfor (int i = 0; i < M; ++i) {\n\t\t\t\tint x = sc.nextInt();\n\t\t\t\tint y = sc.nextInt();\n\t\t\t\tNode sy = walk(EDGE.next, x);\n\t\t\t\tNode sz = walk(sy, y - x);\n\t\t\t\texchange(EDGE.next, sy.prev, sz, EDGE.prev);\n\t\t\t}\n\t\t\tint count = 0;\n\t\t\tfor (Node cur = EDGE.next; cur != EDGE; count += cur.len, cur = cur.next) {\n\t\t\t\tif (count > Q) break;\n\t\t\t\tif (count + cur.len <= P) continue;\n\t\t\t\tif (count < P) {\n\t\t\t\t\tcur.divide(P - count);\n\t\t\t\t\tcontinue;\n\t\t\t\t}\n\t\t\t\tif (count + cur.len > Q + 1) {\n\t\t\t\t\tcur.divide(Q - count + 1);\n\t\t\t\t\tbreak;\n\t\t\t\t}\n\t\t\t}\n\t\t\tcount = 0;\n\t\t\tint ans = 0;\n\t\t\tfor (Node cur = EDGE.next; cur != EDGE; count += cur.len, cur = cur.next) {\n\t\t\t\tif (count > Q) break;\n\t\t\t\tif (count + cur.len <= P) continue;\n\t\t\t\tif (cur.start > R) continue;\n\t\t\t\tif (cur.start + cur.len - 1 <= R) {\n\t\t\t\t\tans += cur.len;\n\t\t\t\t} else {\n\t\t\t\t\tans += R - cur.start + 1;\n\t\t\t\t}\n\n\t\t\t}\n\t\t\tSystem.out.println(ans);\n\t\t}\n\t}\n\n\tstatic Node walk(Node cur, int count) {\n\t\tint sum = 0;\n\t\twhile (true) {\n\t\t\tsum += cur.len;\n\t\t\tif (sum == count) {\n\t\t\t\treturn cur.next;\n\t\t\t}\n\t\t\tif (sum > count) {\n\t\t\t\treturn cur.divide(cur.len - (sum - count));\n\t\t\t}\n\t\t}\n\t}\n\n\tstatic void exchange(Node xs, Node xe, Node zs, Node ze) {\n\t\tNode xp = xs.prev;\n\t\tNode xn = xe.next;\n\t\tNode zp = zs.prev;\n\t\tNode zn = ze.next;\n\t\txp.next = zs;\n\t\tzs.prev = xp;\n\t\txn.prev = ze;\n\t\tze.next = xn;\n\t\tzp.next = xs;\n\t\txs.prev = zp;\n\t\tzn.prev = xe;\n\t\txe.next = zn;\n\t}\n\n\tstatic class Node {\n\t\tNode prev, next;\n\t\tint start, len;\n\n\t\tNode(int start, int len) {\n\t\t\tthis.start = start;\n\t\t\tthis.len = len;\n\t\t}\n\n\t\tNode divide(int ns) {\n\t\t\tNode nn = new Node(start + ns, len - ns);\n\t\t\tthis.len = ns;\n\t\t\tthis.next.prev = nn;\n\t\t\tnn.next = this.next;\n\t\t\tnn.prev = this;\n\t\t\tthis.next = nn;\n\t\t\treturn nn;\n\t\t}\n\t}\n}"
  },
  {
    "language": "Java",
    "code": "import java.util.Scanner;\n\npublic class Main {\n\tpublic static void main(String args[]) {\n\t\tScanner sc = new Scanner(System.in);\n\t\tint a[];\n\t\tint n, m;\n\t\tint x, y;\n\t\tint p, q, r;\n\t\tint count;\n\n\t\tn = sc.nextInt();\n\t\twhile (n != 0) {\n\t\t\ta = new int [n];\n\t\t\tfor (int i = 0; i < n; i++) {\n\t\t\t\ta[i] = i + 1;\n\t\t\t}\n\t\t\tm = sc.nextInt();\n\t\t\tp = sc.nextInt();\n\t\t\tq = sc.nextInt();\n\t\t\tr = sc.nextInt();\n\t\t\tfor (int i = 0; i < m; i++) {\n\t\t\t\tx = sc.nextInt();\n\t\t\t\ty = sc.nextInt();\n\t\t\t\tf(a, n, x, y);\n\t\t\t}\n\t\t\tcount = 0;\n\t\t\tfor (int i = p - 1; i < q; i++) {\n\t\t\t\tif (a[i] <= r) {\n\t\t\t\t\tcount++;\n\t\t\t\t}\n\t\t\t}\n\t\t\tSystem.out.println(count);\n\t\t\tn = sc.nextInt();\n\t\t}\n\t}\n\n\tpublic static void f(int a[], int n, int x, int y) {\n\t\tint b[] = new int[n];\n\t\tfor (int i = 0; i < n; i++) {\n\t\t\tb[i] = a[i];\n\t\t}\n\t\tfor (int i = 0; i < n; i++) {\n\t\t\tif (i < x) {\n\t\t\t\ta[i - x + n] = b[i];\n\t\t\t} else if (x <= i && i < y) {\n\t\t\t\ta[i - x - y + n] = b[i];\n\t\t\t} else {\n\t\t\t\ta[i - y] = b[i];\n\t\t\t}\n\t\t}\n\t}\n}"
  },
  {
    "language": "Java",
    "code": "\nimport java.io.IOException;\nimport java.util.ArrayDeque;\nimport java.util.Deque;\nimport java.util.Scanner;\n\npublic class Main {\n\n\tpublic static void main(String[] args) throws IOException {\n\n\t\tnew Main().run();\n\t}\n\n\tprivate void run() throws IOException {\n\t\tScanner scanner = new Scanner(System.in);\n\t\twhile (true) {\n\t\t\tint n = scanner.nextInt();\n\t\t\tif (n == 0)\n\t\t\t\tbreak;\n\t\t\tint m = scanner.nextInt();\n\t\t\tint p = scanner.nextInt() - 1;\n\t\t\tint q = scanner.nextInt();\n\t\t\tint r = scanner.nextInt();\n\t\t\tDeque<Point> deque = new ArrayDeque<Main.Point>();\n\t\t\tdeque.push(new Point(1, n));\n\t\t\twhile (m-- > 0) {\n\t\t\t\tint x = scanner.nextInt();\n\t\t\t\tint y = scanner.nextInt();\n\t\t\t\tDeque<Point> tmp = new ArrayDeque<Point>();\n\t\t\t\tint ny = n - y;\n\t\t\t\twhile (ny != 0) {\n\t\t\t\t\tPoint point = deque.peekLast();\n\t\t\t\t\tif (point.len <= ny) {\n\t\t\t\t\t\ttmp.push(deque.pollLast());\n\t\t\t\t\t\tny -= point.len;\n\t\t\t\t\t} else {\n\t\t\t\t\t\ttmp.push(new Point(point.len - ny + point.start, ny));\n\t\t\t\t\t\tdeque.peekLast().len -= ny;\n\t\t\t\t\t\tbreak;\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t\tint nx = y - x;\n\t\t\t\twhile (nx != 0) {\n\t\t\t\t\tPoint point = deque.peekLast();\n\t\t\t\t\tif (point.len <= nx) {\n\t\t\t\t\t\tdeque.push(deque.pollLast());\n\t\t\t\t\t\tnx -= point.len;\n\t\t\t\t\t} else {\n\t\t\t\t\t\tdeque.push(new Point(point.len - nx + point.start, nx));\n\t\t\t\t\t\tdeque.peekLast().len -= nx;\n\t\t\t\t\t\tbreak;\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t\ttmp.addAll(deque);\n\t\t\t\tdeque = tmp;\n\n\t\t\t}\n\t\t\tint ny = n - q;\n\t\t\twhile (ny != 0) {\n\t\t\t\tPoint point = deque.peekLast();\n\t\t\t\tif (point.len <= ny) {\n\t\t\t\t\tdeque.pollLast();\n\t\t\t\t\tny -= point.len;\n\t\t\t\t} else {\n\t\t\t\t\tdeque.peekLast().len -= ny;\n\t\t\t\t\tbreak;\n\t\t\t\t}\n\t\t\t}\n\t\t\twhile (p != 0) {\n\t\t\t\tPoint point = deque.peek();\n\t\t\t\tif (point.len <= p) {\n\t\t\t\t\tdeque.poll();\n\t\t\t\t\tp -= point.len;\n\t\t\t\t} else {\n\t\t\t\t\tdeque.peek().start += p;\n\t\t\t\t\tdeque.peek().len -= p;\n\t\t\t\t\tbreak;\n\t\t\t\t}\n\t\t\t}\n\t\t\tint ans = 0;\n\t\t\twhile (!deque.isEmpty()) {\n\t\t\t\tPoint point = deque.poll();\n\t\t\t\tans += Math.max(0, Math.min(r - point.start + 1, point.len));\n\t\t\t}\n\t\t\tSystem.out.println(ans);\n\t\t}\n\t}\n\n\tclass Point {\n\t\tint start, len;\n\n\t\tpublic Point(int start, int len) {\n\t\t\tsuper();\n\t\t\tthis.start = start;\n\t\t\tthis.len = len;\n\t\t}\n\n\t\t@Override\n\t\tpublic String toString() {\n\t\t\treturn \"Point [start=\" + start + \", len=\" + len + \"]\";\n\t\t}\n\n\t}\n}"
  },
  {
    "language": "Java",
    "code": "\nimport java.util.*;\n\nimport static java.lang.Math.*;\nimport static java.util.Arrays.*;\n\npublic class Main {\n\n\tint INF = 1 << 28;\n\tint n, m;\n\tlong[] card = new long[100000];\n\tlong[] tmp = new long[100000];\n\tint x, y;\n\tint s, t, u;\n\tint p, q, r;\n\tint len;\n\tint n_len;\n\tint indx, indy;\n\n\tvoid run() {\n\t\tScanner sc = new Scanner(System.in);\n\t\tfor(;;) {\n\t\t\tn = sc.nextInt();\n\t\t\tif(n == 0) break;\n\t\t\tm = sc.nextInt();\n\t\t\tp = sc.nextInt();\n\t\t\tq = sc.nextInt();\n\t\t\tr = sc.nextInt();\n\t\t\t\n\t\t\tlen = 1;\n\t\t\tfill(card, 0);\n\t\t\tfill(tmp, 0);\n\t\t\tcard[0] = int2long(1, n);\n\t\t\tfor(int h=0;h<m;h++) {\n\t\t\t\tx = sc.nextInt();\n\t\t\t\ty = sc.nextInt();\n\t\t\t\tn_len = 0;\n\t\t\t\tfor(int i=0;i<len;i++) {\n//\t\t\t\t\tSystem.out.println(card[i]-((card[i]>>32)<<32));\n\t\t\t\t\ts = (int)(card[i]>>32);\n\t\t\t\t\tt = (int)(card[i]-((long)s<<32));\n\t\t\t\t\tu = t - s + 1;\n//\t\t\t\t\tSystem.out.println(s + \" \" + t + \" \" + u + \" \" + x + \" \" + y);\n\t\t\t\t\tif(  u <= x ) {\n\t\t\t\t\t\tif(x==u) {\n\t\t\t\t\t\t\ttmp[n_len++] = int2long(s, t);\n\t\t\t\t\t\t\tindx = n_len;\n\t\t\t\t\t\t\ty -= x;\n\t\t\t\t\t\t\tx=0;\n\t\t\t\t\t\t}\n\t\t\t\t\t\telse {\n\t\t\t\t\t\t\ttmp[n_len++] = card[i];\n\t\t\t\t\t\t\tx -= u;\n\t\t\t\t\t\t\ty -= u;\n\t\t\t\t\t\t}\n\t\t\t\t\t}\n\t\t\t\t\telse if(u <= y) {\n\t\t\t\t\t\tif(y==u) {\n\t\t\t\t\t\t\ttmp[n_len++] = int2long(s, t);\n\t\t\t\t\t\t\tindy = n_len;\n\t\t\t\t\t\t\ty=0;\n\t\t\t\t\t\t}\n\t\t\t\t\t\telse {\n\t\t\t\t\t\t\ttmp[n_len++] = card[i];\n\t\t\t\t\t\t\ty -= u;\n\t\t\t\t\t\t}\n\t\t\t\t\t}\n\t\t\t\t\telse if( x > 0 && x < u && y < u ) {\n//\t\t\t\t\t\tSystem.out.println(s + \" \" + (s+x-1) + \" \" + (s+y-1));\n\t\t\t\t\t\ttmp[n_len++] = int2long(s, s+x-1);\n\t\t\t\t\t\tindx = n_len;\n\t\t\t\t\t\ttmp[n_len++] = int2long(s+x, s+y-1);\n\t\t\t\t\t\tindy = n_len;\n\t\t\t\t\t\ttmp[n_len++] = int2long(s+y, t);\n\t\t\t\t\t\t\n\t\t\t\t\t}\n\t\t\t\t\telse if(x > 0 && x < u) {\n\t\t\t\t\t\ttmp[n_len++] = int2long(s, s+x-1);\n\t\t\t\t\t\tindx = n_len;\n\t\t\t\t\t\ttmp[n_len++] = int2long(s+x, t);\n\t\t\t\t\t\ty -= x;\n\t\t\t\t\t\tx = 0;\n\t\t\t\t\t}\n\t\t\t\t\telse if(y > 0 && y < u) {\n\t\t\t\t\t\ttmp[n_len++] = int2long(s, s+y-1);\n\t\t\t\t\t\tindy = n_len;\n\t\t\t\t\t\ttmp[n_len++] = int2long(s+y, t);\n\t\t\t\t\t\ty = 0;\n\t\t\t\t\t}\n\t\t\t\t\telse {\n\t\t\t\t\t\ttmp[n_len++] = card[i];\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t\tlen = n_len;\n\t\t\t\tn_len=0;\n\t\t\t\tfor(int i=indy;i<len;i++) card[n_len++] = tmp[i];\n\t\t\t\tfor(int i=indx;i<indy;i++) card[n_len++] = tmp[i];\n\t\t\t\tfor(int i=0;i<indx;i++) card[n_len++] = tmp[i];\n\t\t\t}\n\t\t\tint ans = 0;\n\t\t\tfor(int i=0;i<len;i++) {\n\t\t\t\ts = (int)(card[i]>>32);\n\t\t\t\tt = (int)(card[i]-((long)s<<32));\n\t\t\t\tu = t - s + 1;\n//\t\t\t\tSystem.out.println(s + \" \" + t + \" \" + u + \" \" + p + \" \" + q);\n\t\t\t\tif( u <= p ) {\n\t\t\t\t\tif(p == u)\n\t\t\t\t\t\tans += (t < r)? 1:0;\n\t\t\t\t\tp -= u;\n\t\t\t\t\tq -= u;\n\t\t\t\t}\n\t\t\t\t\n\t\t\t\telse if( p>0 && u>p && u>q ) {\n\t\t\t\t\tans += max(0, min(q-p, r-(s+p)+1));\n\t\t\t\t\tbreak;\n\t\t\t\t}\n\t\t\t\telse if( p>0 && u>p) {\n\t\t\t\t\tans += max(0, min(t-(s+p)+1, r-(s+p)+1));\n\t\t\t\t\tp -= u;\n\t\t\t\t\tq -= u;\n\t\t\t\t}\n\t\t\t\telse if( u <= q ) {\n\t\t\t\t\tans += max(0, min(u, r-s+1));\n\t\t\t\t\tif( q == u) break;\n\t\t\t\t\tq -= u;\n\t\t\t\t}\n\t\t\t\telse if(q>0 && u>q) {\n\t\t\t\t\tans += max(0, min(q, r-q+1));\n\t\t\t\t\tbreak;\n\t\t\t\t}\n\t\t\t}\n\t\t\tSystem.out.println(ans);\n\t\t}\n\t}\n\t\n\tlong int2long(int f, int t) {\n\t\treturn (((long)f << 32) + t);\n\t}\n\n\tpublic static void main(String[] args) {\n\t\tnew Main().run();\n\t}\n\t\n\tvoid debug(Object...os){\n\t\tSystem.err.println(Arrays.deepToString(os));\n\t}\n}"
  },
  {
    "language": "Java",
    "code": "import java.util.LinkedList;\nimport java.util.Scanner;\n\n//Shuffle\npublic class Main{\n\n\tclass R implements Comparable<R>{\n\t\tint s, t;\n\t\tpublic R(int s, int t) {\n\t\t\tthis.s = s;\n\t\t\tthis.t = t;\n\t\t}\n\t\tpublic int compareTo(R o) {\n\t\t\treturn s-o.s;\n\t\t}\n\t}\n\t\n\tvoid run(){\n\t\tScanner sc = new Scanner(System.in);\n\t\tfor(;;){\n\t\t\tint n = sc.nextInt();\n\t\t\tif(n==0)break;\n\t\t\tint m = sc.nextInt(), p = sc.nextInt(), q = sc.nextInt(), r = sc.nextInt();\n\t\t\tint[] ps = new int[m], qs = new int[m];\n\t\t\tfor(int i=0;i<m;i++){\n\t\t\t\tps[i] = sc.nextInt(); qs[i] = sc.nextInt();\n\t\t\t}\n\t\t\tLinkedList<R> l = new LinkedList<R>();\n\t\t\tl.add(new R(p, q));\n\t\t\tfor(int Q=m-1;Q>=0;Q--){\n\t\t\t\tint x = ps[Q], y = qs[Q];\n//\t\t\t\tLinkedList<R> next = new LinkedList<R>();\n\t\t\t\tint L = l.size();\n\t\t\t\tfor(int i=0;i<L;i++){\n\t\t\t\t\tR v = l.get(i);\n\t\t\t\t\tif(v.t<=n-y){\n\t\t\t\t\t\tv.s+=y; v.t+=y;\n//\t\t\t\t\t\tnext.add(new R(v.s+y, v.t+y));\n\t\t\t\t\t}\n\t\t\t\t\telse if(v.s<=n-y){\n\t\t\t\t\t\tif(v.t<=n-x){\n\t\t\t\t\t\t\tl.add(new R(x+1, v.t+x+y-n));\n\t\t\t\t\t\t\tv.s+=y; v.t = n;\n\t\t\t\t\t\t}\n\t\t\t\t\t\telse{\n\t\t\t\t\t\t\tl.add(new R(x+1, y));\n\t\t\t\t\t\t\tl.add(new R(1, v.t+x-n));\n\t\t\t\t\t\t\tv.s+=y; v.t = n;\n\t\t\t\t\t\t}\n//\t\t\t\t\t\tnext.add(new R(v.s+y, n));\n//\t\t\t\t\t\tl.remove(i); l.add(i, new R(n-y+1, v.t)); i--;\n\t\t\t\t\t}\n\t\t\t\t\telse if(v.t<=n-x){\n\t\t\t\t\t\tv.s+=x+y-n; v.t+=x+y-n;\n//\t\t\t\t\t\tnext.add(new R(v.s+x+y-n, v.t+x-n+y));\n\t\t\t\t\t}\n\t\t\t\t\telse if(v.s<=n-x){\n\t\t\t\t\t\tl.add(new R(1, v.t+x-n));\n\t\t\t\t\t\tv.s += x+y-n; v.t = y;\n//\t\t\t\t\t\tl.remove(i); l.add(i, new R(n-x+1, v.t)); i--;\n//\t\t\t\t\t\tnext.add(new R(v.s+x+y-n, y));\n\t\t\t\t\t}\n\t\t\t\t\telse {\n\t\t\t\t\t\tv.s+=x-n; v.t+=x-n;\n//\t\t\t\t\t\tnext.add(new R(v.s+x-n, v.t+x-n));\n\t\t\t\t\t}\n\t\t\t\t}\n//\t\t\t\tCollections.sort(l);\n//\t\t\t\tfor(int i=0;i+1<l.size();i++){\n//\t\t\t\t\tif(l.get(i).t+1==l.get(i+1).s){\n//\t\t\t\t\t\tR v = new R(l.get(i).s, l.get(i+1).t);\n//\t\t\t\t\t\tl.remove(i); l.remove(i); l.add(i, v); i--;\n//\t\t\t\t\t}\n//\t\t\t\t}\n\t\t\t}\n\t\t\tint res = 0;\n\t\t\tfor(R v:l){\n\t\t\t\tif(v.t<=r)res+=v.t-v.s+1;\n\t\t\t\telse if(v.s<=r)res+=r-v.s+1;\n\t\t\t}\n\t\t\tSystem.out.println(res);\n\t\t}\n\t}\n\t\n\tpublic static void main(String[] args) {\n\t\tnew Main().run();\n\t}\n}"
  },
  {
    "language": "Java",
    "code": "import java.util.ArrayList;\nimport java.util.Collections;\nimport java.util.Comparator;\nimport java.util.List;\n\n//Shuffle\npublic class Main{\n\t\n\tclass Scanner {\n\t\tint nextInt() {\n\t\t\ttry {\n\t\t\t\tint c = System.in.read();\n\t\t\t\twhile (c != '-' && (c < '0' || '9' < c))\n\t\t\t\t\tc = System.in.read();\n\t\t\t\tif (c == '-') return -nextInt();\n\t\t\t\tint res = 0;\n\t\t\t\tdo {\n\t\t\t\t\tres *= 10;\n\t\t\t\t\tres += c - '0';\n\t\t\t\t\tc = System.in.read();\n\t\t\t\t} while ('0' <= c && c <= '9');\n\t\t\t\treturn res;\n\t\t\t} catch (Exception e) {\n\t\t\t\treturn -1;\n\t\t\t}\n\t\t}\n\t}\n\t\n\tvoid run(){\n\t\tScanner sc = new Scanner();\n        long mask = (1L << 32)-1;\n        Comparator<Long> C = new Comparator<Long>() {\n            public int compare(Long o1, Long o2) {\n                return (int) ((o1>>32)-(o2>>32));\n            }\n        };\n        for(;;){\n            int n = sc.nextInt();\n            if(n==0)break;\n//            long T = System.currentTimeMillis();\n            int m = sc.nextInt(), P = sc.nextInt(), Q = sc.nextInt(), R = sc.nextInt();\n            List<Long> l = new ArrayList<Long>();\n            l.add(((long)P<<32)|Q);\n            int[] p = new int[m], q = new int[m];\n            for(int i=0;i<m;i++){\n                p[i] = sc.nextInt(); q[i] = sc.nextInt();\n            }\n            for(int i=m-1;i>=0;i--){\n                long t1 = n-q[i], s2 = t1+1, t2 = n-p[i], s3 = n-p[i]+1, y = q[i];\n                List<Long> next = new ArrayList<Long>();\n                for(int j=0;j<l.size();j++){\n                    long x = l.get(j);\n                    long s = x>>32, t = x&mask;\n                    if(t<=t1){\n                        next.add((s+y)<<32 | (t+y));\n                    }\n                    else if(t<=t2){\n                        if(s<=t1){\n                            next.add((s+y)<<32 | (t1+y));\n                            s = s2;\n                        }\n                        next.add((s-s2+p[i]+1)<<32 | (t-s2+p[i]+1));\n                    }\n                    else{\n                        if(s<=t1){\n                            next.add((s+y)<<32 | (t1+y));\n                            s = s2;\n                        }\n                        if(s<=t2){\n                            next.add((s-s2+p[i]+1)<<32 | (t2-s2+p[i]+1));\n                            s = s3;\n                        }\n                        next.add((s-s3+1)<<32 | (t-s3+1));\n                    }\n                }\n                l = new ArrayList<Long>();\n                Collections.sort(next, C);\n                long ss = next.get(0)>>32, tt = next.get(0)&mask;\n                for(int j=1;j<next.size();j++){\n                    long x = next.get(j);\n                    long s = x>>32, t = x&mask;\n                    if(tt+1==s)tt = t;\n                    else{\n                        l.add((ss<<32)|tt);\n                        ss = s; tt = t;\n                    }\n                }\n                l.add((ss<<32)|tt);\n            }\n            int res = 0;\n            for(long x:l){\n                long s = x>>32, t = x&mask;\n                if(R<s)break;\n                if(R<t)t = R;\n                res+=t-s+1;\n            }\n            System.out.println(res);\n//            System.out.println((System.currentTimeMillis()-T)+\" ms.\");\n        }\n\t}\n\t\n\tpublic static void main(String[] args) {\n\t\tnew Main().run();\n\t}\n}"
  },
  {
    "language": "Java",
    "code": "import java.util.Arrays;\nimport java.util.LinkedList;\nimport java.util.Scanner;\n\npublic class Main {\n\t\n\tpublic static class Cards{\n\t\tint first, last;\n\n\t\tpublic Cards(int first, int last) {\n\t\t\tsuper();\n\t\t\tthis.first = first;\n\t\t\tthis.last = last;\n\t\t}\n\t\t\n\t\tpublic int getSize(){\n\t\t\treturn last - first + 1;\n\t\t}\n\t\t\n\t\tpublic int getLower(int l){\n\t\t\t//System.out.println(l + \" \" + first + \" \" + last);\n\t\t\t\n\t\t\tif(l < first){\n\t\t\t\treturn 0;\n\t\t\t}else{\n\t\t\t\t//System.out.println(l - first + 1);\n\t\t\t\treturn Math.min(last, l) - first + 1;\n\t\t\t}\n\t\t}\n\t\t\n\t\tpublic Cards[] split(int sp){\n\t\t\tif(sp < 0){\n\t\t\t\treturn new Cards[0];\n\t\t\t}else if(sp > this.getSize()){\n\t\t\t\treturn new Cards[0];\n\t\t\t}else if(sp == 0){\n\t\t\t\treturn new Cards[]{this};\n\t\t\t}else if(sp == getSize()){\n\t\t\t\treturn new Cards[]{this};\n\t\t\t}else{\n\t\t\t\treturn new Cards[]{new Cards(first, first + sp - 1), new Cards(first + sp, last)};\n\t\t\t}\n\t\t}\n\t\t\n\t\tpublic String toString(){\n\t\t\treturn this.first + \" \" + this.last;\n\t\t}\n\t}\n\t\n\tpublic static void split(LinkedList<Cards> main_list, int x, int y, LinkedList<Cards> a_list, LinkedList<Cards> b_list, LinkedList<Cards> c_list){\n\t\tint first = 1;\n\t\t\n\t\tfor(Cards cards : main_list){\n\t\t\t//System.out.println(x + \" \" + y );\n\t\t\t//System.out.println(main_list);\n\t\t\t//System.out.println(a_list);\n\t\t\t//System.out.println(b_list);\n\t\t\t//System.out.println(c_list);\n\t\t\t\n\t\t\tfinal int last = first + cards.getSize() - 1;\n\t\t\t//System.out.println(x + \" \" + y + \" : \" + first + \" \" + last + \" <> \" + cards);\n\t\t\t\n\t\t\tif(first <= x && last <= x){\n\t\t\t\ta_list.add(cards);\n\t\t\t}else if(first <= x){\n\t\t\t\tCards[] split = cards.split(x - first + 1);\n\t\t\t\t\n\t\t\t\ta_list.add(split[0]);\n\t\t\t\t\n\t\t\t\tif(last <= y){\n\t\t\t\t\tb_list.add(split[1]);\n\t\t\t\t}else{\n\t\t\t\t\tCards[] split2 = split[1].split(y - x);\n\t\t\t\t\tb_list.add(split2[0]);\n\t\t\t\t\tc_list.add(split2[1]);\n\t\t\t\t}\n\t\t\t}else if(first <= y && last <= y){\n\t\t\t\tb_list.add(cards);\n\t\t\t}else if(first <= y){\n\t\t\t\tCards[] split = cards.split(y - first + 1);\n\t\t\t\t\n\t\t\t\tb_list.add(split[0]);\n\t\t\t\tc_list.add(split[1]);\n\t\t\t}else{\n\t\t\t\tc_list.add(cards);\n\t\t\t}\n\t\t\t\n\t\t\tfirst = last + 1;\n\t\t}\n\t}\n\n\tpublic static void main(String[] args) {\n\t\tScanner sc = new Scanner(System.in);\n\n\t\twhile(true){\n\t\t\tfinal int n = sc.nextInt();\n\t\t\t\n\t\t\tif(n == 0){\n\t\t\t\tbreak;\n\t\t\t}\n\t\t\t\n\t\t\tLinkedList<Cards> list = new LinkedList<Cards>();\n\t\t\tlist.add(new Cards(1, n));\n\t\t\t\n\t\t\tfinal int m = sc.nextInt();\n\t\t\tfinal int p = sc.nextInt();\n\t\t\tfinal int q = sc.nextInt();\n\t\t\tfinal int r = sc.nextInt();\n\t\t\t\n\t\t\tLinkedList<Cards> a_list = new LinkedList<Main.Cards>();\n\t\t\tLinkedList<Cards> b_list = new LinkedList<Main.Cards>();\n\t\t\tLinkedList<Cards> c_list = new LinkedList<Main.Cards>();\n\t\t\tfor(int i = 0; i < m; i++){\n\t\t\t\tfinal int x = sc.nextInt();\n\t\t\t\tfinal int y = sc.nextInt();\n\t\t\t\t\n\t\t\t\tsplit(list, x, y, a_list, b_list, c_list);\n\t\t\t\t\n\t\t\t\tlist.clear();\n\t\t\t\t\n\t\t\t\tlist.addAll(c_list);\n\t\t\t\tlist.addAll(b_list);\n\t\t\t\tlist.addAll(a_list);\n\t\t\t\t\n\t\t\t\ta_list.clear();\n\t\t\t\tb_list.clear();\n\t\t\t\tc_list.clear();\n\t\t\t}\n\t\t\t\n\t\t\tint sum = 0;\n\t\t\tsplit(list, p - 1, q, a_list, b_list, c_list);\n\t\t\t//System.out.println(a_list + \" \" + b_list + \" \" + c_list);\n\t\t\tfor(Cards cards : b_list){\n\t\t\t\tsum += cards.getLower(r);\n\t\t\t}\n\t\t\tSystem.out.println(sum);\n\t\t\t\n\t\t\tSystem.gc();\n\t\t}\n\t}\n\n}"
  },
  {
    "language": "Java",
    "code": "import java.util.Collections;\nimport java.util.LinkedList;\nimport java.util.Scanner;\n\n//Shuffle\npublic class Main{\n\n\tclass R implements Comparable<R>{\n\t\tint s, t;\n\t\tpublic R(int s, int t) {\n\t\t\tthis.s = s;\n\t\t\tthis.t = t;\n\t\t}\n\t\tpublic int compareTo(R o) {\n\t\t\treturn s-o.s;\n\t\t}\n\t}\n\t\n\tvoid run(){\n\t\tScanner sc = new Scanner(System.in);\n\t\tfor(;;){\n\t\t\tint n = sc.nextInt();\n\t\t\tif(n==0)break;\n\t\t\tint m = sc.nextInt(), p = sc.nextInt(), q = sc.nextInt(), r = sc.nextInt();\n\t\t\tint[] ps = new int[m], qs = new int[m];\n\t\t\tfor(int i=0;i<m;i++){\n\t\t\t\tps[i] = sc.nextInt(); qs[i] = sc.nextInt();\n\t\t\t}\n\t\t\tLinkedList<R> l = new LinkedList<R>();\n\t\t\tl.add(new R(p, q));\n\t\t\tfor(int Q=m-1;Q>=0;Q--){\n\t\t\t\tint x = ps[Q], y = qs[Q];\n//\t\t\t\tLinkedList<R> next = new LinkedList<R>();\n\t\t\t\tint L = l.size();\n\t\t\t\tfor(int i=0;i<L;i++){\n\t\t\t\t\tR v = l.get(i);\n\t\t\t\t\tif(v.t<=n-y){\n\t\t\t\t\t\tv.s+=y; v.t+=y;\n//\t\t\t\t\t\tnext.add(new R(v.s+y, v.t+y));\n\t\t\t\t\t}\n\t\t\t\t\telse if(v.s<=n-y){\n\t\t\t\t\t\tif(v.t<=n-x){\n\t\t\t\t\t\t\tl.add(new R(x+1, v.t+x+y-n));\n\t\t\t\t\t\t\tv.s+=y; v.t = n;\n\t\t\t\t\t\t}\n\t\t\t\t\t\telse{\n\t\t\t\t\t\t\tl.add(new R(x+1, y));\n\t\t\t\t\t\t\tl.add(new R(1, v.t+x-n));\n\t\t\t\t\t\t\tv.s+=y; v.t = n;\n\t\t\t\t\t\t}\n//\t\t\t\t\t\tnext.add(new R(v.s+y, n));\n//\t\t\t\t\t\tl.remove(i); l.add(i, new R(n-y+1, v.t)); i--;\n\t\t\t\t\t}\n\t\t\t\t\telse if(v.t<=n-x){\n\t\t\t\t\t\tv.s+=x+y-n; v.t+=x+y-n;\n//\t\t\t\t\t\tnext.add(new R(v.s+x+y-n, v.t+x-n+y));\n\t\t\t\t\t}\n\t\t\t\t\telse if(v.s<=n-x){\n\t\t\t\t\t\tl.add(new R(1, v.t+x-n));\n\t\t\t\t\t\tv.s += x+y-n; v.t = y;\n//\t\t\t\t\t\tl.remove(i); l.add(i, new R(n-x+1, v.t)); i--;\n//\t\t\t\t\t\tnext.add(new R(v.s+x+y-n, y));\n\t\t\t\t\t}\n\t\t\t\t\telse {\n\t\t\t\t\t\tv.s+=x-n; v.t+=x-n;\n//\t\t\t\t\t\tnext.add(new R(v.s+x-n, v.t+x-n));\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t\tCollections.sort(l);\n\t\t\t\tfor(int i=0;i+1<l.size();i++){\n\t\t\t\t\tif(l.get(i).t+1==l.get(i+1).s){\n\t\t\t\t\t\tl.get(i).t = l.get(i+1).t;\n\t\t\t\t\t\tl.remove(i+1); i--;\n//\t\t\t\t\t\tR v = new R(l.get(i).s, l.get(i+1).t);\n//\t\t\t\t\t\tl.remove(i); l.remove(i); l.add(i, v); i--;\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t}\n\t\t\tint res = 0;\n\t\t\tfor(R v:l){\n\t\t\t\tif(v.t<=r)res+=v.t-v.s+1;\n\t\t\t\telse if(v.s<=r)res+=r-v.s+1;\n\t\t\t\telse break;\n\t\t\t}\n\t\t\tSystem.out.println(res);\n\t\t}\n\t}\n\t\n\tpublic static void main(String[] args) {\n\t\tnew Main().run();\n\t}\n}"
  },
  {
    "language": "Java",
    "code": "import java.util.Arrays;\nimport java.util.LinkedList;\nimport java.util.Scanner;\n\npublic class Main {\n\t\n\tpublic static class Cards{\n\t\tint first, last;\n\n\t\tpublic Cards(int first, int last) {\n\t\t\tsuper();\n\t\t\tthis.first = first;\n\t\t\tthis.last = last;\n\t\t}\n\t\t\n\t\tpublic int getSize(){\n\t\t\treturn last - first + 1;\n\t\t}\n\t\t\n\t\tpublic int getLower(int l){\n\t\t\t//System.out.println(l + \" \" + first + \" \" + last);\n\t\t\t\n\t\t\tif(l < first){\n\t\t\t\treturn 0;\n\t\t\t}else{\n\t\t\t\t//System.out.println(l - first + 1);\n\t\t\t\treturn Math.min(last, l) - first + 1;\n\t\t\t}\n\t\t}\n\t\t\n\t\tpublic Cards[] split(int sp){\n\t\t\tif(sp < 0){\n\t\t\t\treturn new Cards[0];\n\t\t\t}else if(sp > this.getSize()){\n\t\t\t\treturn new Cards[0];\n\t\t\t}else if(sp == 0){\n\t\t\t\treturn new Cards[]{this};\n\t\t\t}else if(sp == getSize()){\n\t\t\t\treturn new Cards[]{this};\n\t\t\t}else{\n\t\t\t\treturn new Cards[]{new Cards(first, first + sp - 1), new Cards(first + sp, last)};\n\t\t\t}\n\t\t}\n\t\t\n\t\tpublic String toString(){\n\t\t\treturn this.first + \" \" + this.last;\n\t\t}\n\t}\n\t\n\tpublic static void split(LinkedList<Cards> main_list, int x, int y, LinkedList<Cards> a_list, LinkedList<Cards> b_list, LinkedList<Cards> c_list){\n\t\tint first = 1;\n\t\t\n\t\tfor(Cards cards : main_list){\n\t\t\t//System.out.println(x + \" \" + y );\n\t\t\t//System.out.println(main_list);\n\t\t\t//System.out.println(a_list);\n\t\t\t//System.out.println(b_list);\n\t\t\t//System.out.println(c_list);\n\t\t\t\n\t\t\tfinal int last = first + cards.getSize() - 1;\n\t\t\t//System.out.println(x + \" \" + y + \" : \" + first + \" \" + last + \" <> \" + cards);\n\t\t\t\n\t\t\tif(first <= x && last <= x){\n\t\t\t\ta_list.add(cards);\n\t\t\t}else if(first <= x){\n\t\t\t\tCards[] split = cards.split(x - first + 1);\n\t\t\t\t\n\t\t\t\ta_list.add(split[0]);\n\t\t\t\t\n\t\t\t\tif(last <= y){\n\t\t\t\t\tb_list.add(split[1]);\n\t\t\t\t}else{\n\t\t\t\t\tCards[] split2 = split[1].split(y - x);\n\t\t\t\t\tb_list.add(split2[0]);\n\t\t\t\t\tc_list.add(split2[1]);\n\t\t\t\t}\n\t\t\t}else if(first <= y && last <= y){\n\t\t\t\tb_list.add(cards);\n\t\t\t}else if(first <= y){\n\t\t\t\tCards[] split = cards.split(y - first + 1);\n\t\t\t\t\n\t\t\t\tb_list.add(split[0]);\n\t\t\t\tc_list.add(split[1]);\n\t\t\t}else{\n\t\t\t\tc_list.add(cards);\n\t\t\t}\n\t\t\t\n\t\t\tfirst = last + 1;\n\t\t}\n\t}\n\n\tpublic static void main(String[] args) {\n\t\tScanner sc = new Scanner(System.in);\n\t\t\n\t\tLinkedList<Cards> list = new LinkedList<Cards>();\n\t\t\n\t\tLinkedList<Cards> a_list = new LinkedList<Main.Cards>();\n\t\tLinkedList<Cards> b_list = new LinkedList<Main.Cards>();\n\t\tLinkedList<Cards> c_list = new LinkedList<Main.Cards>();\n\t\t\n\t\twhile(true){\n\t\t\tfinal int n = sc.nextInt();\n\t\t\t\n\t\t\tif(n == 0){\n\t\t\t\tbreak;\n\t\t\t}\n\t\t\t\n\t\t\tlist.add(new Cards(1, n));\n\t\t\t\n\t\t\tfinal int m = sc.nextInt();\n\t\t\tfinal int p = sc.nextInt();\n\t\t\tfinal int q = sc.nextInt();\n\t\t\tfinal int r = sc.nextInt();\n\t\t\t\n\t\t\t\n\t\t\tfor(int i = 0; i < m; i++){\n\t\t\t\tfinal int x = sc.nextInt();\n\t\t\t\tfinal int y = sc.nextInt();\n\t\t\t\t\n\t\t\t\tsplit(list, x, y, a_list, b_list, c_list);\n\t\t\t\t\n\t\t\t\tlist.clear();\n\t\t\t\t\n\t\t\t\tlist.addAll(c_list);\n\t\t\t\tlist.addAll(b_list);\n\t\t\t\tlist.addAll(a_list);\n\t\t\t\t\n\t\t\t\ta_list.clear();\n\t\t\t\tb_list.clear();\n\t\t\t\tc_list.clear();\n\t\t\t}\n\t\t\t\n\t\t\tint sum = 0;\n\t\t\tsplit(list, p - 1, q, a_list, b_list, c_list);\n\t\t\t//System.out.println(a_list + \" \" + b_list + \" \" + c_list);\n\t\t\tfor(Cards cards : b_list){\n\t\t\t\tsum += cards.getLower(r);\n\t\t\t}\n\t\t\tSystem.out.println(sum);\n\t\t\t\n\n\t\t\tlist.clear();\n\t\t\ta_list.clear();\n\t\t\tb_list.clear();\n\t\t\tc_list.clear();\n\t\t\t\n\t\t\tSystem.gc();\n\t\t}\n\t}\n\n}"
  },
  {
    "language": "Java",
    "code": "// run# 2215108\nimport java.io.BufferedReader;\nimport java.io.IOException;\nimport java.io.InputStreamReader;\n\npublic class Main {\n\tpublic static int hitnum(int a0, int a1, int r){\n\t\tif(a1<=r){\n\t\t\treturn a1-a0+1;\n\t\t}else if(a0<=r){\n\t\t\treturn r-a0+1;\n\t\t}else{\n\t\t\treturn 0;\n\t\t}\n\t}\n\n\n\tpublic static void main(String[] args)throws IOException {\n\t\tBufferedReader br = new BufferedReader(new InputStreamReader(System.in));\n\t\twhile(true){\n\t\t\tint n = Integer.parseInt(br.readLine());\n\t\t\tif(n==0) break;\n\t\t\tint m = Integer.parseInt(br.readLine());\n\t\t\tint deck[][][] = new int [m+1][2*m+3][2];\n\t\t\tdeck[0][0][0] = 1;\n\t\t\tdeck[0][0][1] = n;\n\n\t\t\tString line[] = br.readLine().split(\" \");\n\t\t\tint p = Integer.parseInt(line[0]);\n\t\t\tint q = Integer.parseInt(line[1]);\n\t\t\tint r = Integer.parseInt(line[2]);\n\n\t\t\tfor(int im=0; im<m; im++){\n\t\t\t\tString query[] = br.readLine().split(\" \");\n\t\t\t\tint x = Integer.parseInt(query[0]);\n\t\t\t\tint y = Integer.parseInt(query[1]);\n\n\t\t\t\tint cntr = 0;\n\t\t\t\tint i = 0;\n\t\t\t\tint[] sectiona = {0,0};\n\t\t\t\tint[] sectionb = {0,0};\n\n\t\t\t\twhile(cntr < x){\n\t\t\t\t\tint nextsize = deck[im][i][1] - deck[im][i][0] + 1;\n\t\t\t\t\tif(x-cntr >= nextsize){\n\t\t\t\t\t\tcntr += nextsize;\n\t\t\t\t\t\ti++;\n\t\t\t\t\t}else{\n\t\t\t\t\t\tsectiona[0] = deck[im][i][0];\n\t\t\t\t\t\tsectiona[1] = deck[im][i][0] + x-cntr -1;\n\t\t\t\t\t\tdeck[im][i][0] += x-cntr;\n\t\t\t\t\t\tcntr = x;\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t\tint memoa = i;\n\t\t\t\twhile(cntr < y){\n\t\t\t\t\tint nextsize = deck[im][i][1] - deck[im][i][0] + 1;\n\t\t\t\t\tif(y-cntr >= nextsize){\n\t\t\t\t\t\tcntr += nextsize;\n\t\t\t\t\t\ti++;\n\t\t\t\t\t}else{\n\t\t\t\t\t\tsectionb[0] = deck[im][i][0];\n\t\t\t\t\t\tsectionb[1] = deck[im][i][0] + y-cntr -1;\n\t\t\t\t\t\tdeck[im][i][0] += y-cntr;\n\t\t\t\t\t\tcntr = y;\n\t\t\t\t\t}\n\t\t\t\t}\n\n\t\t\t\tint itr = 0;\n\t\t\t\twhile(deck[im][i+itr][0] != 0){\n\t\t\t\t\tdeck[im+1][itr][0] = deck[im][i+itr][0];\n\t\t\t\t\tdeck[im+1][itr][1] = deck[im][i+itr][1];\n\t\t\t\t\titr++;\n\t\t\t\t}\n\t\t\t\tfor(int j=memoa; j<i; j++){\n\t\t\t\t\tdeck[im+1][itr][0] = deck[im][j][0];\n\t\t\t\t\tdeck[im+1][itr][1] = deck[im][j][1];\n\t\t\t\t\titr++;\n\t\t\t\t}\n\t\t\t\tif (sectionb[1] != 0){\n\t\t\t\t\tdeck[im+1][itr][0] = sectionb[0];\n\t\t\t\t\tdeck[im+1][itr][1] = sectionb[1];\n\t\t\t\t\titr++;\n\t\t\t\t}\n\t\t\t\tfor(int j=0; j<memoa; j++){\n\t\t\t\t\tdeck[im+1][itr][0] = deck[im][j][0];\n\t\t\t\t\tdeck[im+1][itr][1] = deck[im][j][1];\n\t\t\t\t\titr++;\n\t\t\t\t}\n\t\t\t\tif (sectiona[1] != 0){\n\t\t\t\t\tdeck[im+1][itr][0] = sectiona[0];\n\t\t\t\t\tdeck[im+1][itr][1] = sectiona[1];\n\t\t\t\t\titr++;\n\t\t\t\t}\n\t\t\t}\n\n\t\t\tint answerq = 0;\n\t\t\tint cnter = 0;\n\t\t\tint i = 0;\n\t\t\twhile (cnter < q){\n\t\t\t\tint nextsize = deck[m][i][1] - deck[m][i][0] + 1;\n\t\t\t\tif(q-cnter >= nextsize){\n\t\t\t\t\tanswerq += hitnum(deck[m][i][0],deck[m][i][1], r);\n\t\t\t\t\tcnter += nextsize;\n\t\t\t\t\ti++;\n\t\t\t\t}else{\n\t\t\t\t\tanswerq += hitnum(deck[m][i][0], deck[m][i][0] + q-cnter -1,r);\n\t\t\t\t\tcnter = q;\n\t\t\t\t}\n\t\t\t}\n\n\t\t\tint answerp = 0;\n\t\t\tcnter = 0;\n\t\t\ti = 0;\n\t\t\twhile (cnter < p-1){\n\t\t\t\tint nextsize = deck[m][i][1] - deck[m][i][0] + 1;\n\t\t\t\tif(p-1-cnter >= nextsize){\n\t\t\t\t\tanswerp += hitnum(deck[m][i][0],deck[m][i][1], r);\n\t\t\t\t\tcnter += nextsize;\n\t\t\t\t\ti++;\n\t\t\t\t}else{\n\t\t\t\t\tanswerp += hitnum(deck[m][i][0], deck[m][i][0] + p-1-cnter -1,r);\n\t\t\t\t\tcnter = p-1;\n\t\t\t\t}\n\t\t\t}\n\t\t\tint answer = answerq-answerp;\n\t\t\tSystem.out.println(answer);\n\t\t}\n\t}\n}"
  },
  {
    "language": "Java",
    "code": "import java.util.ArrayList;\nimport java.util.Collections;\nimport java.util.Comparator;\nimport java.util.List;\n\n//Shuffle\npublic class Main{\n\n\tclass Scanner {\n\t\tint nextInt() {\n\t\t\ttry {\n\t\t\t\tint c = System.in.read();\n\t\t\t\twhile (c != '-' && (c < '0' || '9' < c))\n\t\t\t\t\tc = System.in.read();\n\t\t\t\tif (c == '-') return -nextInt();\n\t\t\t\tint res = 0;\n\t\t\t\tdo {\n\t\t\t\t\tres *= 10;\n\t\t\t\t\tres += c - '0';\n\t\t\t\t\tc = System.in.read();\n\t\t\t\t} while ('0' <= c && c <= '9');\n\t\t\t\treturn res;\n\t\t\t} catch (Exception e) {\n\t\t\t\treturn -1;\n\t\t\t}\n\t\t}\n\t}\n\n\tvoid run(){\n\t\tScanner sc = new Scanner();\n\t\tlong mask = (1L << 32)-1;\n\t\tComparator<Long> C = new Comparator<Long>() {\n\t\t\tpublic int compare(Long o1, Long o2) {\n\t\t\t\treturn (int) ((o1>>32)-(o2>>32));\n\t\t\t}\n\t\t};\n\t\tint[] p = new int[5000], q = new int[5000];\n\t\tfor(;;){\n\t\t\tint n = sc.nextInt();\n\t\t\tif(n==0)break;\n//\t\t\t            long T = System.currentTimeMillis();\n\t\t\tint m = sc.nextInt(), P = sc.nextInt(), Q = sc.nextInt(), R = sc.nextInt();\n\t\t\tList<Long> l = new ArrayList<Long>();\n\t\t\tl.add(((long)P<<32)|Q);\n\t\t\tfor(int i=0;i<m;i++){\n\t\t\t\tp[i] = sc.nextInt(); q[i] = sc.nextInt();\n\t\t\t}\n\t\t\tfor(int i=m-1;i>=0;i--){\n\t\t\t\tlong t1 = n-q[i], s2 = t1+1, t2 = n-p[i], s3 = n-p[i]+1, y = q[i];\n\t\t\t\tList<Long> next = new ArrayList<Long>();\n\t\t\t\tfor(int j=0;j<l.size();j++){\n\t\t\t\t\tlong x = l.get(j);\n\t\t\t\t\tlong s = x>>32, t = x&mask;\n\t\t\t\t\tif(t<=t1){\n\t\t\t\t\t\tnext.add((s+y)<<32 | (t+y));\n\t\t\t\t\t}\n\t\t\t\t\telse if(t<=t2){\n\t\t\t\t\t\tif(s<=t1){\n\t\t\t\t\t\t\tnext.add((s+y)<<32 | (t1+y));\n\t\t\t\t\t\t\ts = s2;\n\t\t\t\t\t\t}\n\t\t\t\t\t\tnext.add((s-s2+p[i]+1)<<32 | (t-s2+p[i]+1));\n\t\t\t\t\t}\n\t\t\t\t\telse{\n\t\t\t\t\t\tif(s<=t1){\n\t\t\t\t\t\t\tnext.add((s+y)<<32 | (t1+y));\n\t\t\t\t\t\t\ts = s2;\n\t\t\t\t\t\t}\n\t\t\t\t\t\tif(s<=t2){\n\t\t\t\t\t\t\tnext.add((s-s2+p[i]+1)<<32 | (t2-s2+p[i]+1));\n\t\t\t\t\t\t\ts = s3;\n\t\t\t\t\t\t}\n\t\t\t\t\t\tnext.add((s-s3+1)<<32 | (t-s3+1));\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t\tif(i<=4000){\n\t\t\t\t\tl = new ArrayList<Long>();\n\t\t\t\t\tCollections.sort(next, C);\n\t\t\t\t\tlong ss = next.get(0)>>32, tt = next.get(0)&mask;\n\t\t\t\t\tfor(int j=1;j<next.size();j++){\n\t\t\t\t\t\tlong x = next.get(j);\n\t\t\t\t\t\tlong s = x>>32, t = x&mask;\n\t\t\t\t\t\tif(tt+1==s)tt = t;\n\t\t\t\t\t\telse{\n\t\t\t\t\t\t\tl.add((ss<<32)|tt);\n\t\t\t\t\t\t\tss = s; tt = t;\n\t\t\t\t\t\t}\n\t\t\t\t\t}\n\t\t\t\t\tl.add((ss<<32)|tt);\n\t\t\t\t}\n\t\t\t\telse{\n\t\t\t\t\tl = next;\n\t\t\t\t\tCollections.sort(l, C);\n\t\t\t\t}\n\t\t\t}\n\t\t\tint res = 0;\n\t\t\tfor(long x:l){\n\t\t\t\tlong s = x>>32, t = x&mask;\n\t\t\t\tif(R<s)break;\n\t\t\t\tif(R<t)t = R;\n\t\t\t\tres+=t-s+1;\n\t\t\t}\n\t\t\tSystem.out.println(res);\n//\t\t\t            System.out.println((System.currentTimeMillis()-T)+\" ms.\");\n\t\t}\n\t}\n\n\tpublic static void main(String[] args) {\n\t\tnew Main().run();\n\t}\n}"
  },
  {
    "language": "Java",
    "code": "import java.util.Deque;\nimport java.util.LinkedList;\nimport java.util.Scanner;\n\npublic class Main {\n\tpublic static void main(String[] args) {\n\t\tScanner in = new Scanner(System.in);\n\t\tint n, m, p, q, r;\n\t\twhile ((n = in.nextInt()) > 0) {\n\t\t\tm = in.nextInt();\n\t\t\tp = in.nextInt() - 1;\n\t\t\tq = in.nextInt();\n\t\t\tr = in.nextInt();\n\t\t\tDeque<Integer> allDeque = getNewDeque();\n\t\t\tallDeque.add(Integer.valueOf(r));\n\t\t\tallDeque.add(Integer.valueOf(n - r));\n\t\t\tDeque<Integer> a = getNewDeque();\n\t\t\tDeque<Integer> c = getNewDeque();\n\t\t\tboolean top = true;\n\t\t\tboolean bottom = false;\n\t\t\tfor (int i = 0; i < m; i++) {\n\t\t\t\tboolean atop = top, abottm, ctop, cbottom = bottom;\n\t\t\t\tint asize = in.nextInt();\n\t\t\t\ta.clear();\n\t\t\t\twhile (asize >= allDeque.peekFirst().intValue()) {\n\t\t\t\t\ttop = !top;\n\t\t\t\t\tfinal Integer first = allDeque.removeFirst();\n\t\t\t\t\ta.addLast(first);\n\t\t\t\t\tasize -= first.intValue();\n\t\t\t\t}\n\t\t\t\tif (asize != 0) {\n\t\t\t\t\ta.addLast(Integer.valueOf(asize));\n\t\t\t\t\tfinal Integer first = allDeque.removeFirst();\n\t\t\t\t\tallDeque.addFirst(Integer.valueOf(first - asize));\n\t\t\t\t}\n\t\t\t\tabottm = (a.size() % 2 == 1) ? atop : !atop;\n\t\t\t\tint csize = n - in.nextInt();\n\t\t\t\tc.clear();\n\t\t\t\twhile (csize >= allDeque.peekLast().intValue()) {\n\t\t\t\t\tbottom = !bottom;\n\t\t\t\t\tfinal Integer last = allDeque.removeLast();\n\t\t\t\t\tc.addFirst(last);\n\t\t\t\t\tcsize -= last.intValue();\n\t\t\t\t}\n\t\t\t\tif (csize != 0) {\n\t\t\t\t\tc.addFirst(Integer.valueOf(csize));\n\t\t\t\t\tfinal Integer last = allDeque.removeLast();\n\t\t\t\t\tallDeque.addLast(Integer.valueOf(last - csize));\n\t\t\t\t}\n\t\t\t\tctop = (c.size() % 2 == 1) ? cbottom : !cbottom;\n\t\t\t\tif (atop == bottom) {\n\t\t\t\t\tint afirst = a.removeFirst().intValue();\n\t\t\t\t\tallDeque.addLast(Integer.valueOf(afirst\n\t\t\t\t\t\t\t+ allDeque.removeLast().intValue()));\n\t\t\t\t}\n\t\t\t\tif (cbottom == top) {\n\t\t\t\t\tint clast = a.removeLast().intValue();\n\t\t\t\t\tallDeque.addFirst(Integer.valueOf(clast\n\t\t\t\t\t\t\t+ allDeque.removeFirst().intValue()));\n\t\t\t\t}\n\t\t\t\tDeque<Integer> b = allDeque;\n\t\t\t\tallDeque = c;\n\t\t\t\tc = b;\n\t\t\t\tallDeque.addAll(b);\n\t\t\t\tallDeque.addAll(a);\n\t\t\t\ttop = ctop;\n\t\t\t\tbottom = abottm;\n\t\t\t}\n\t\t\twhile (p >= allDeque.peekFirst().intValue()) {\n\t\t\t\tfinal int val = allDeque.removeFirst().intValue();\n\t\t\t\tq -= val;\n\t\t\t\tp -= val;\n\t\t\t\ttop = !top;\n\t\t\t}\n\t\t\tint count = (top) ? -p : 0;\n\t\t\twhile (q >= allDeque.peekFirst().intValue()) {\n\t\t\t\tfinal int intValue = allDeque.removeFirst().intValue();\n\t\t\t\tq -= intValue;\n\t\t\t\tif (top)\n\t\t\t\t\tcount += intValue;\n\t\t\t\ttop = !top;\n\t\t\t}\n\t\t\tif (top) {\n\t\t\t\tcount += q;\n\t\t\t}\n\t\t\tSystem.out.println(count);\n\t\t}\n\t}\n\n\tprivate static Deque<Integer> getNewDeque() {\n\t\treturn new LinkedList<Integer>();\n\t}\n}"
  },
  {
    "language": "C#",
    "code": "#include<bits/stdc++.h>\n#define rep(i,n)for(int i=0;i<n;i++)\nusing namespace std;\ntypedef pair<int, int>P;\ntypedef long long ll;\n\nint main() {\n\tint n, m, p, q, r;\n\twhile (scanf(\"%d\", &n), n) {\n\t\tscanf(\"%d%d%d%d\", &m, &p, &q, &r);\n\t\tqueue<P>que, que1, que2, que3;\n\t\tque.push(P(1, n));\n\t\trep(i, m) {\n\t\t\tint x, y; scanf(\"%d%d\", &x, &y);\n\t\t\tint cnt = 0;\n\t\t\twhile (!que.empty()) {\n\t\t\t\tP p = que.front(); que.pop();\n\t\t\t\tint f = p.first, s = p.second;\n\t\t\t\tif (cnt + s - f + 1 <= x) {\n\t\t\t\t\tque1.push(p);\n\t\t\t\t\tgoto g;\n\t\t\t\t}\n\t\t\t\tif (y <= cnt) {\n\t\t\t\t\tque3.push(p);\n\t\t\t\t\tgoto g;\n\t\t\t\t}\n\t\t\t\tif (cnt < x) {\n\t\t\t\t\tque1.push(P(f, f + x - cnt - 1));\n\t\t\t\t\tp.first = f + x - cnt;\n\t\t\t\t}\n\t\t\t\tif (y < cnt + s - f + 1) {\n\t\t\t\t\tque3.push(P(f + y - cnt, s));\n\t\t\t\t\tp.second = f + y - cnt - 1;\n\t\t\t\t}\n\t\t\t\tque2.push(P(p.first, p.second));\n\t\t\tg:\n\t\t\t\tcnt += s - f + 1;\n\t\t\t}\n\t\t\twhile (!que3.empty()) { que.push(que3.front()); que3.pop(); }\n\t\t\twhile (!que2.empty()) { que.push(que2.front()); que2.pop(); }\n\t\t\twhile (!que1.empty()) { que.push(que1.front()); que1.pop(); }\n\t\t}\n\t\tint cnt = 0, ans = 0;\n\t\twhile (!que.empty()) {\n\t\t\tP pa = que.front(); que.pop();\n\t\t\tint f = pa.first, s = pa.second;\n\t\t\tif (cnt + s - f + 1 < p)goto e;\n\t\t\tif (r < f)goto e;\n\t\t\tif (cnt <= p)\n\t\t\t\tpa.first = f + p - cnt - 1;\n\t\t\tif (q < cnt + s - f + 1)\n\t\t\t\tpa.second = f + q - cnt - 1;\n\t\t\tif (pa.second <= r) {\n\t\t\t\tans += pa.second - pa.first + 1;\n\t\t\t\tgoto e;\n\t\t\t}\n\t\t\tans += r - pa.first + 1;\n\t\te:\n\t\t\tcnt += s - f + 1;\n\t\t\tif (q <= cnt)break;\n\t\t}\n\t\tprintf(\"%d\\n\", ans);\n\t}\n\treturn 0;\n}"
  },
  {
    "language": "C#",
    "code": "using System.Linq;\nusing System.Collections.Generic;\nusing System;\n\npublic class hello\n{\n    public static void Main()\n    {\n        while (true)\n        {\n            var n = int.Parse(Console.ReadLine().Trim());\n            if (n == 0) break;\n            var card = Enumerable.Range(1, n).ToList();\n            var m = int.Parse(Console.ReadLine().Trim());\n            string[] line = Console.ReadLine().Trim().Split(' ');\n            var p = int.Parse(line[0]);\n            var q = int.Parse(line[1]);\n            var r = int.Parse(line[2]);\n            for (int i = 0; i < m; i++)\n            {\n                string[] line2 = Console.ReadLine().Trim().Split(' ');\n                var sx = int.Parse(line2[0]);\n                var sy = int.Parse(line2[1]);\n                Shuffle(card, sx, sy, n);\n            }\n            var ans = card.Skip(p - 1).Take(q - p + 1).Count(x => x <= r);\n            Console.WriteLine(ans);\n        }\n    }\n    public static void Shuffle (List<int> c , int sx ,int sy ,int n )\n    {\n        var templist = new List<int>();\n        for (int i = sy; i < n; i++)\n            templist.Add(c[i]);\n        for (int i = sx; i < sy; i++)\n            templist.Add(c[i]);\n        for (int i = 0; i < sx; i++)\n            templist.Add(c[i]);\n        c.RemoveAll(x => x > 0);\n        foreach (var x in templist) c.Add(x);\n    }\n}"
  },
  {
    "language": "C#",
    "code": "using System.Linq;\nusing System;\n\npublic class hello\n{\n    public static void Main()\n    {\n        while (true)\n        {\n            var n = int.Parse(Console.ReadLine().Trim());\n            if (n == 0) break;\n            var card = Enumerable.Range(1, n).ToArray();\n            var m = int.Parse(Console.ReadLine().Trim());\n            string[] line = Console.ReadLine().Trim().Split(' ');\n            var p = int.Parse(line[0]);\n            var q = int.Parse(line[1]);\n            var r = int.Parse(line[2]);\n            for (int i = 0; i < m; i++)\n            {\n                string[] line2 = Console.ReadLine().Trim().Split(' ');\n                var sx = int.Parse(line2[0]);\n                var sy = int.Parse(line2[1]);\n                Shuffle(card, sx, sy, n);\n            }\n            var count = 0;\n            for (int i = p - 1; i < q ; i++)\n                if (card[i] <= r) count++;\n            Console.WriteLine(count);\n        }\n    }\n    public static void Shuffle (int[] c , int sx ,int sy ,int n )\n    {\n        var tempary = new int[n];\n        for (int i = 0; i < n - sy; i++)\n            tempary[i] = c[sy + i];\n        for (int i = 0; i < sy - sx; i++)\n            tempary[n-sy+i] = c[i + sx];\n        for (int i = 0; i < sx; i++)\n            tempary[n- sx + i] = c[i];\n        for (int i = 0; i < n; i++)\n            c[i] = tempary[i];\n     }\n}"
  },
  {
    "language": "Ruby",
    "code": "def shuffle(x)\n  ret = []\n  ret_s = []\n  while $sum + $card_s[$cnt] < x\n    ret << $cards[$cnt]\n    ret_s << $card_s[$cnt]\n    $sum += $card_s[$cnt]\n    $cnt += 1\n  end\n  t, b = $cards[$cnt]\n  len = $card_s[$cnt]\n  len1 = x - $sum\n  m = t - 1 + len1\n  ret << [t, m]\n  ret_s << len1\n  $sum += len1\n  if len1 < len\n    $cards[$cnt] = [m+1, b]\n    $card_s[$cnt] = len - len1\n  else $cnt += 1\n  end\n  [ret, ret_s]\nend\n\nwhile true\n  n = gets.to_i\n  break if n == 0\n  m = gets.to_i\n  p, q, r = gets.split.map(&:to_i)\n  $cards = [[1,n]]\n  $card_s = [n]\n  m.times do \n    x, y = gets.split.map(&:to_i)\n    $sum = 0\n    $cnt = 0\n    top, top_s = shuffle(x)\n    mid, mid_s = shuffle(y)\n    btm = $cards[$cnt..-1]\n    btm_s = $card_s[$cnt..-1]\n    $cards = btm + mid + top\n    $card_s = btm_s + mid_s + top_s\n  end\n  $sum = 0\n  $cnt = 0\n  top = shuffle(p-1)[0]\n  mid = shuffle(q)[0]\n  ret = 0\n  for cds in mid\n    if cds[0] <= r\n      ret += (cds[1] <= r ? cds[1] : r) - cds[0] + 1\n    end\n  end\n  p ret\nend"
  },
  {
    "language": "Ruby",
    "code": "n = gets.to_i\nm = gets.to_i\np, q, r = gets.split.map(&:to_i)\npos = Array.new(n){ |i| i+1 }\nnpos = Array.new(n)\nm.times do \n  x, y = gets.split.map(&:to_i)\n  npos[0...n-y] = pos[y..-1]\n  npos[n-y...n-x] = pos[x...y]\n  npos[n-x..-1] = pos[0...x]\n  pos = npos\nend\np pos[p-1..q-1].count{ |i| i <= r }"
  },
  {
    "language": "Ruby",
    "code": "def shuffle(x)\n  ret = []\n  while $sum + $card_s[$cnt] < x\n    ret << $cards[$cnt]\n    $sum += $card_s[$cnt]\n    $cnt += 1\n  end\n  t, b = $cards[$cnt]\n  len = $card_s[$cnt]\n  len1 = x - $sum\n  m = t - 1 + len1\n  ret << [t, m]\n  $sum += len1\n  if len1 < len\n    $cards[$cnt] = [m+1, b]\n    $card_s[$cnt] = len - len1\n  else $cnt += 1\n  end\n  ret\nend\n\nwhile true\n  n = gets.to_i\n  break if n == 0\n  m = gets.to_i\n  p, q, r = gets.split.map(&:to_i)\n  $cards = [[1,n]]\n  $card_s = [n]\n  m.times do \n    x, y = gets.split.map(&:to_i)\n    $sum = 0\n    $cnt = 0\n    top = shuffle(x)\n    mid = shuffle(y)\n    btm = $cards[$cnt..-1]\n    $cards = btm + mid + top\n    $cards.size.times{ |i| $card_s[i] = $cards[i][1] - $cards[i][0] + 1 }\n  end\n  $sum = 0\n  $cnt = 0\n  top = shuffle(p-1)\n  mid = shuffle(q)\n  ret = 0\n  for cds in mid\n    if cds[0] <= r\n      ret += (cds[1] <= r ? cds[1] : r) - cds[0] + 1\n    end\n  end\n  p ret\nend"
  },
  {
    "language": "Ruby",
    "code": "def div_cards(cards, xi, yi)\n  cds0 = []\n  cds1 = []\n  cds2 = []\n  k = 0\n  sum = 0\n\n  while sum + cards[k][2] < xi\n    cds0 << cards[k]\n    sum += cards[k][2]\n    k += 1\n  end\n\n  a0, c0, w = cards[k]\n  w0 = xi - sum\n  b0 = a0 - 1 + w0\n\n  cds0 << [a0, b0, w0]\n  sum += w0\n\n  if w0 < w\n    cards[k] = [b0 + 1, c0, w - w0]\n  else\n    k += 1\n  end\n\n  while sum + cards[k][2] < yi\n    cds1 << cards[k]\n    sum += cards[k][2]\n    k += 1\n  end\n\n  a0, c0, w = cards[k]\n  w0 = yi - sum\n  b0 = a0 - 1 + w0\n\n  cds1 << [a0, b0, w0]\n  sum += w0\n\n  if w0 < w\n    cards[k] = [b0 + 1, c0, w - w0]\n  else\n    k += 1\n  end\n\n  cds2 = cards[k...cards.length]\n\n  [cds0, cds1, cds2]\nend\n\n### main\n\nloop do\n  n = gets.strip.to_i\n  break if n == 0\n\n  m = gets.strip.to_i\n  pn, qn, rn = gets.strip.split(' ').map{|s| s.to_i}\n\n  cards = [[1, n, n]]\n  #p cards\n\n  m.times do\n    xi, yi = gets.strip.split(' ').map{|s| s.to_i}\n\n    cds0, cds1, cds2 = div_cards(cards, xi, yi)\n    cards = cds2 + cds1 + cds0\n    #p ['shffle', xi, yi]\n    #p ['cds0', cds0]\n    #p ['cds1', cds1]\n    #p ['cds2', cds2]\n    #p ['cards', cards]\n  end\n  #p cards\n\n  cds0, cds1, cds2 = div_cards(cards, pn - 1, qn)\n  #p cds1\n\n  count = 0\n  for cg in cds1\n    if cg[0] <= rn\n      count += (cg[1] <= rn ? cg[1] : rn) - cg[0] + 1\n    end\n  end\n\n  puts count\nend"
  },
  {
    "language": "Ruby",
    "code": "def shuffle(x)\n  ret = []\n  while $sum + $cards[$cnt][2] < x\n    ret << $cards[$cnt]\n    $sum += $cards[$cnt][2]\n    $cnt += 1\n  end\n  t, b, len = $cards[$cnt]\n  len1 = x - $sum\n  m = t - 1 + len1\n  ret << [t, m, len1]\n  $sum += len1\n  if len1 < len\n    $cards[$cnt] = [m+1, b, len - len1]\n  else $cnt += 1\n  end\n  ret\nend\n\nwhile true\n  n = gets.to_i\n  break if n == 0\n  m = gets.to_i\n  p, q, r = gets.split.map(&:to_i)\n  $cards = [[1,n,n]]\n  m.times do \n    x, y = gets.split.map(&:to_i)\n    $sum = 0\n    $cnt = 0\n    top = shuffle(x)\n    mid = shuffle(y)\n    btm = $cards[$cnt..-1]\n    $cards = btm + mid + top\n  end\n  $sum = 0\n  $cnt = 0\n  top = shuffle(p-1)\n  mid = shuffle(q)\n  ret = 0\n  for cds in mid\n    if cds[0] <= r\n      ret += (cds[1] <= r ? cds[1] : r) - cds[0] + 1\n    end\n  end\n  p ret\nend"
  },
  {
    "language": "Ruby",
    "code": "while true\n  n = gets.to_i\n  break if n == 0\n  m = gets.to_i\n  p, q, r = gets.split.map(&:to_i)\n  pos = Array.new(n){ |i| i+1 }\n  npos = Array.new(n)\n  m.times do \n    x, y = gets.split.map(&:to_i)\n    npos[0...n-y] = pos[y..-1]\n    npos[n-y...n-x] = pos[x...y]\n    npos[n-x..-1] = pos[0...x]\n    pos = npos\n  end\n  p pos[p-1..q-1].count{ |i| i <= r }\nend"
  },
  {
    "language": "Ruby",
    "code": "def shuffle(x, cnt, sum)\n  ret = []\n  while sum + $cards[cnt][2] < x\n    ret << $cards[cnt]\n    sum += $cards[cnt][2]\n    cnt += 1\n  end\n  t, b, len = $cards[cnt]\n  len1 = x - sum\n  m = t - 1 + len1\n  ret << [t, m, len1]\n  sum += len1\n  if len1 < len\n    $cards[cnt] = [m+1, b, len - len1]\n  else cnt += 1\n  end\n  [ret, cnt, sum]\nend\n\ndef shuffle2(x, y)\n  btm, cnt, sum = shuffle(x, 0, 0)\n  mid, cnt, sum = shuffle(y, cnt, sum)\n  $cards[cnt..-1] + mid + btm\nend\n\nwhile true\n  n = gets.to_i\n  break if n == 0\n  m = gets.to_i\n  p, q, r = gets.split.map(&:to_i)\n  $cards = [[1,n,n]]\n  m.times do \n    x, y = gets.split.map(&:to_i)\n    $cards = shuffle2(x, y)\n  end\n  top, cnt, sum = shuffle(p-1, 0, 0)\n  mid, cnt, sum = shuffle(q, cnt, sum)\n  ret = 0\n  for cds in mid\n    if cds[0] <= r\n      ret += (cds[1] <= r ? cds[1] : r) - cds[0] + 1\n    end\n  end\n  p ret\nend"
  },
  {
    "language": "Ruby",
    "code": "def take(cards, x)\n  head, tail = [], []\n\n  num = 0\n\n  cards.each do |c|\n    if num + c[1] <= x\n      head << c\n    elsif x <= num\n      tail << c\n    elsif x < num + c[1]\n      head << [c[0], x - num]\n      tail << [c[0] + x - num, c[1] - (x - num)]\n    else\n      raise Error\n    end\n\n    num += c[1]\n  end\n\n  [head, tail]\nend\n\n\ndef count(cards, r)\n  res = 0\n\n  cards.each do |c|\n    res += [r - c[0] + 1, c[1]].min if c[0] <= r\n  end\n\n  res\nend\n\n\nn = gets.chomp.to_i\nm = gets.chomp.to_i\np, q, r = gets.split.map(&:to_i)\n\ncards = [[1, n]]\n\nm.times do\n  x, y = gets.split.map(&:to_i)\n\n  a, cards = take(cards, x)\n  b, c = take(cards, y - x)\n\n  cards = c + b + a\nend\n\n\nputs count(take(take(cards, p-1)[1], q - p + 1)[0], r)"
  },
  {
    "language": "Ruby",
    "code": "## main\n\nloop do\n  n = gets.strip.to_i\n  break if n == 0\n\n  m = gets.strip.to_i\n  pn, qn, rn = gets.strip.split(' ').map{|s| s.to_i}\n\n  cards = (1..n).to_a\n  #p cards\n\n  m.times do\n    xi, yi = gets.strip.split(' ').map{|s| s.to_i}\n\n    cards = cards[yi...n] + cards[xi...yi] + cards[0...xi]\n  end\n  #p cards\n\n  puts cards[(pn - 1)..(qn - 1)].select{|c| c <= rn}.length\nend"
  },
  {
    "language": "Ruby",
    "code": "m, n = gets.split.map(&:to_i)\nk = gets.to_i\njoi = Array.new(m)\nm.times do |i|\n  joi[i] = gets.chomp\nend\njs = Array.new(m){ Array.new(n, 0) }\nos = Array.new(m){ Array.new(n, 0) }\nis = Array.new(m){ Array.new(n, 0) }\nm.times do |i|\n  n.times do |j|\n    if joi[i][j] == 'J' then js[i][j] = 1\n    elsif joi[i][j] == 'O' then os[i][j] = 1\n    else is[i][j] = 1\n    end\n  end\nend\nm.times do |i|\n  (1...n).each do |j|\n    js[i][j] += js[i][j-1]\n    os[i][j] += os[i][j-1]\n    is[i][j] += is[i][j-1]\n  end\nend\n\nk.times do\n  a, b, c, d = gets.split.map(&:to_i)\n  jc, oc, ic = 0, 0, 0\n  (a-1..c-1).each do |i|\n    jc += b > 1 ? js[i][d-1] - js[i][b-2] : js[i][d-1]\n    oc += b > 1 ? os[i][d-1] - os[i][b-2] : os[i][d-1]\n    ic += b > 1 ? is[i][d-1] - is[i][b-2] : is[i][d-1]\n  end\n  puts \"#{jc} #{oc} #{ic}\"\nend"
  },
  {
    "language": "Ruby",
    "code": "def take(cards, x)\n  head, tail = [], []\n\n  num = 0\n\n  cards.each do |c|\n    if num + c[1] <= x\n      head << c\n    elsif x <= num\n      tail << c\n    elsif x < num + c[1]\n      head << [c[0], x - num]\n      tail << [c[0] + x - num, c[1] - (x - num)]\n    else\n      raise Error\n    end\n\n    num += c[1]\n  end\n\n  [head, tail]\nend\n\n\ndef count(cards, r)\n  res = 0\n\n  cards.each do |c|\n    res += [r - c[0] + 1, c[1]].min if c[0] <= r\n  end\n\n  res\nend\n\n\nwhile (n = gets.chomp.to_i) != 0\n  m = gets.chomp.to_i\n  p, q, r = gets.split.map(&:to_i)\n\n  cards = [[1, n]]\n\n  m.times do\n    x, y = gets.split.map(&:to_i)\n\n    a, cards = take(cards, x)\n    b, c = take(cards, y - x)\n\n    cards = c + b + a\n  end\n\n\n  puts count(take(take(cards, p-1)[1], q - p + 1)[0], r)\nend"
  },
  {
    "language": "D",
    "code": "import std.stdio;\nimport std.algorithm;\nimport std.string;\nimport std.range;\nimport std.array;\nimport std.conv;\nimport std.complex;\nimport std.math;\nimport std.ascii;\nimport std.bigint;\nimport std.container;\nimport core.memory;\n\nint[][] shuffle(int[][] c, int n, int x, int y) {\n\tint[][] d;\n\tforeach(ci; c) {\n\t\tif(ci[0] <= x) {\n\t\t\tif(ci[1] <= x){\n\t\t\t\td ~= [ci[0]+n-x, ci[1]+n-x];\n\t\t\t\tcontinue;\n\t\t\t} else {\n\t\t\t\td ~= [ci[0]+n-x, n];\n\t\t\t\tci[0] = x+1;\n\t\t\t}\n\t\t}\n\t\tif(ci[0] <= y) {\n\t\t\tif(ci[1] <= y) {\n\t\t\t\td ~= [ci[0]+n-x-y, ci[1]+n-x-y];\n\t\t\t\tcontinue;\n\t\t\t} else {\n\t\t\t\td ~= [ci[0]+n-x-y, n-x];\n\t\t\t\tci[0] = y+1;\n\t\t\t}\n\t\t}\n\t\td ~= [ci[0]-y, ci[1]-y];\n\t}\n\treturn d;\n}\n\nvoid main() {\n\tGC.disable();\n\tint n = to!int(readln().strip());\n\twhile(n) {\n\t\tint m = to!int(readln().strip());\n\t\tauto pqr = map!(to!int)(readln().strip().split());\n\t\tint[][] c;\n\t\tc ~= [pqr[0],pqr[1]];\n\t\tint[][] s;\n\t\tforeach(i; 0..m) {\n\t\t\ts ~= array(map!(to!int)(readln().strip().split()));\n\t\t}\n\t\tforeach_reverse(si; s) {\n\t\t\tc = shuffle(c, n, n-si[1], n-si[0]);\n\t\t}\n\t\tint ans;\n\t\tforeach(ci; c) {\n\t\t\tif(ci[0] <= pqr[2]) {\n\t\t\t\tans += min(pqr[2],ci[1])-ci[0]+1;\n\t\t\t}\n\t\t}\n\t\twriteln(ans);\n\t\tGC.collect();\n\t\tn = to!int(readln().strip());\n\t}\n}"
  },
  {
    "language": "D",
    "code": "import std.stdio;\nimport std.algorithm;\nimport std.string;\nimport std.range;\nimport std.array;\nimport std.conv;\nimport std.complex;\nimport std.math;\nimport std.ascii;\nimport std.bigint;\nimport std.container;\n\nint[][] shuffle(int[][] c, int n, int x, int y) {\n\tint[][] d;\n\tforeach(ci; c) {\n\t\tif(ci[0] <= x) {\n\t\t\tif(ci[1] <= x){\n\t\t\t\td ~= [ci[0]+n-x, ci[1]+n-x];\n\t\t\t\tcontinue;\n\t\t\t} else {\n\t\t\t\td ~= [ci[0]+n-x, n];\n\t\t\t\tci[0] = x+1;\n\t\t\t}\n\t\t}\n\t\tif(ci[0] <= y) {\n\t\t\tif(ci[1] <= y) {\n\t\t\t\td ~= [ci[0]+n-x-y, ci[1]+n-x-y];\n\t\t\t\tcontinue;\n\t\t\t} else {\n\t\t\t\td ~= [ci[0]+n-x-y, n-x];\n\t\t\t\tci[0] = y+1;\n\t\t\t}\n\t\t}\n\t\td ~= [ci[0]-y, ci[1]-y];\n\t}\n\treturn d;\n}\n\nvoid main() {\n\tint n = to!int(readln().strip());\n\twhile(n) {\n\t\tint m = to!int(readln().strip());\n\t\tauto pqr = map!(to!int)(readln().strip().split());\n\t\tint[][] c;\n\t\tc ~= [pqr[0],pqr[1]];\n\t\tint[][] s;\n\t\tforeach(i; 0..m) {\n\t\t\ts ~= array(map!(to!int)(readln().strip().split()));\n\t\t}\n\t\tforeach_reverse(si; s) {\n\t\t\tc = shuffle(c, n, n-si[1], n-si[0]);\n\t\t}\n\t\tint ans;\n\t\tforeach(ci; c) {\n\t\t\tif(ci[0] <= pqr[2]) {\n\t\t\t\tans += min(pqr[2],ci[1])-ci[0]+1;\n\t\t\t}\n\t\t}\n\t\twriteln(ans);\n\t\tn = to!int(readln().strip());\n\t}\n}"
  },
  {
    "language": "D",
    "code": "import std.stdio;\nimport std.algorithm;\nimport std.string;\nimport std.range;\nimport std.array;\nimport std.conv;\nimport std.complex;\nimport std.math;\nimport std.ascii;\nimport std.bigint;\nimport std.container;\nimport core.memory;\n\nauto shuffle(SList!(int[]) c, int n, int x, int y) {\n\tSList!(int[]) d;\n\tforeach(ci; c) {\n\t\tif(ci[0] <= x) {\n\t\t\tif(ci[1] <= x){\n\t\t\t\td.insert([ci[0]+n-x, ci[1]+n-x]);\n\t\t\t\tcontinue;\n\t\t\t} else {\n\t\t\t\td.insert([ci[0]+n-x, n]);\n\t\t\t\tci[0] = x+1;\n\t\t\t}\n\t\t}\n\t\tif(ci[0] <= y) {\n\t\t\tif(ci[1] <= y) {\n\t\t\t\td.insert([ci[0]+n-x-y, ci[1]+n-x-y]);\n\t\t\t\tcontinue;\n\t\t\t} else {\n\t\t\t\td.insert([ci[0]+n-x-y, n-x]);\n\t\t\t\tci[0] = y+1;\n\t\t\t}\n\t\t}\n\t\td.insert([ci[0]-y, ci[1]-y]);\n\t}\n\treturn d;\n}\n\nvoid main() {\n\tint n = to!int(readln().strip());\n\twhile(n) {\n\t\tint m = to!int(readln().strip());\n\t\tauto pqr = map!(to!int)(readln().strip().split());\n\t\tSList!(int[]) c;\n\t\tc.insert([pqr[0],pqr[1]]);\n\t\tint[][] s;\n\t\tforeach(i; 0..m) {\n\t\t\ts ~= array(map!(to!int)(readln().strip().split()));\n\t\t}\n\t\tforeach_reverse(si; s) {\n\t\t\tc = shuffle(c, n, n-si[1], n-si[0]);\n\t\t}\n\t\tint ans;\n\t\tforeach(ci; c) {\n\t\t\tif(ci[0] <= pqr[2]) {\n\t\t\t\tans += min(pqr[2],ci[1])-ci[0]+1;\n\t\t\t}\n\t\t}\n\t\twriteln(ans);\n\t\tn = to!int(readln().strip());\n\t}\n}"
  },
  {
    "language": "D",
    "code": "import std.stdio;\nimport std.c.stdio;\nimport std.range;\nimport std.array;\nimport std.functional;\nimport std.algorithm;\nimport std.conv;\nimport std.container;\nimport std.math;\nimport std.numeric;\nimport std.string;\nimport std.c.string;\nimport std.regex;\nimport std.typecons;\n\nclass M {\n    struct R {\n        int from, to;\n        int length() {\n            return to - from;\n        }\n        int countUnder(int l) {\n            if (l < from) return 0;\n            if (l >= to) return to - from;\n            return l - from + 1;\n        }\n    }\n    R[] rs;\n    this(int from, int to) {\n        rs = [R(from, to)];\n    }\n    int count(int p, int q, int l) {\n        int ret = 0;\n        foreach (r; split(p, q)[1]) {\n            ret += r.countUnder(l);\n        }\n        return ret;\n    }\n    void shuffle(int x, int y) {\n        auto a = split(x, y);\n        rs = a[2] ~ a[1] ~ a[0];\n    }\n    R[][] split(int x, int y) {\n        R[][] a = new R[][3];\n        int t1 = 0, t2 = 0;\n        int index = 0;\n        foreach (r; rs) {\n            t2 += r.length;\n            if (t1 <= x && x < t2) {\n                if (t1 != x) a[index] ~= R(r.from, r.from + x - t1);\n                index++;\n                if (t1 <= y && y < t2) {\n                    a[index] ~= R(r.from + x - t1, r.from + y - t1);\n                    index++;\n                    a[index] ~= R(r.from + y - t1, r.to);\n                } else {\n                    a[index] ~= R(r.from + x - t1, r.to);\n                }\n            } else if (t1 <= y && y < t2) {\n                if (t1 != y) a[index] ~= R(r.from, r.from + y - t1);\n                index++;\n                a[index] ~= R(r.from + y - t1, r.to);\n            } else {\n                a[index] ~= r;\n            }\n            t1 += r.length;\n        }\n        return a;\n    }\n}\n\nvoid main() {\n    int n; \n    while (readf(\"%d\\n\", &n), n) {\n        int m; readf(\"%d\\n\", &m);\n        int p, q, r; readf(\"%d %d %d\\n\", &p, &q, &r);\n        M rs = new M(1, n + 1);\n        foreach (i; 0 .. m) {\n            int x, y; readf(\"%d %d\\n\", &x, &y);\n            rs.shuffle(x, y);\n        }\n        rs.count(p - 1, q, r).writeln;\n    }\n}"
  },
  {
    "language": "D",
    "code": "import std.stdio;\nimport std.algorithm;\nimport std.string;\nimport std.range;\nimport std.array;\nimport std.conv;\nimport std.complex;\nimport std.math;\nimport std.ascii;\nimport std.bigint;\nimport std.container;\nimport core.memory;\n\nauto shuffle(SList!(int[]) c, int n, int x, int y) {\n\tSList!(int[]) d;\n\tforeach(ci; c) {\n\t\tif(ci[0] <= x) {\n\t\t\tif(ci[1] <= x){\n\t\t\t\td.insert([ci[0]+n-x, ci[1]+n-x]);\n\t\t\t\tcontinue;\n\t\t\t} else {\n\t\t\t\td.insert([ci[0]+n-x, n]);\n\t\t\t\tci[0] = x+1;\n\t\t\t}\n\t\t}\n\t\tif(ci[0] <= y) {\n\t\t\tif(ci[1] <= y) {\n\t\t\t\td.insert([ci[0]+n-x-y, ci[1]+n-x-y]);\n\t\t\t\tcontinue;\n\t\t\t} else {\n\t\t\t\td.insert([ci[0]+n-x-y, n-x]);\n\t\t\t\tci[0] = y+1;\n\t\t\t}\n\t\t}\n\t\td.insert([ci[0]-y, ci[1]-y]);\n\t}\n\treturn d;\n}\n\nvoid main() {\n\tint n = to!int(readln().strip());\n\twhile(n) {\n\t\tint m = to!int(readln().strip());\n\t\tauto pqr = map!(to!int)(readln().strip().split());\n\t\tSList!(int[]) c;\n\t\tc.insert([pqr[0],pqr[1]]);\n\t\tint[][] s;\n\t\tforeach(i; 0..m) {\n\t\t\ts ~= array(map!(to!int)(readln().strip().split()));\n\t\t}\n{\n\t\tforeach_reverse(si; s) {\n\t\t\tc = shuffle(c, n, n-si[1], n-si[0]);\n\t\t}\n\t\tint ans;\n\t\tforeach(ci; c) {\n\t\t\tif(ci[0] <= pqr[2]) {\n\t\t\t\tans += min(pqr[2],ci[1])-ci[0]+1;\n\t\t\t}\n\t\t}\n\t\twriteln(ans);\n}\n\t\tn = to!int(readln().strip());\n\t}\n}"
  },
  {
    "language": "D",
    "code": "import std.stdio;\nimport std.algorithm;\nimport std.string;\nimport std.range;\nimport std.array;\nimport std.conv;\nimport std.complex;\nimport std.math;\nimport std.ascii;\nimport std.bigint;\nimport std.container;\nimport core.memory;\n\nint[][] shuffle(int[][] c, int n, int x, int y) {\n\tint[][] d;\n\tforeach(ci; c) {\n\t\tif(ci[0] <= x) {\n\t\t\tif(ci[1] <= x){\n\t\t\t\td ~= [ci[0]+n-x, ci[1]+n-x];\n\t\t\t\tcontinue;\n\t\t\t} else {\n\t\t\t\td ~= [ci[0]+n-x, n];\n\t\t\t\tci[0] = x+1;\n\t\t\t}\n\t\t}\n\t\tif(ci[0] <= y) {\n\t\t\tif(ci[1] <= y) {\n\t\t\t\td ~= [ci[0]+n-x-y, ci[1]+n-x-y];\n\t\t\t\tcontinue;\n\t\t\t} else {\n\t\t\t\td ~= [ci[0]+n-x-y, n-x];\n\t\t\t\tci[0] = y+1;\n\t\t\t}\n\t\t}\n\t\td ~= [ci[0]-y, ci[1]-y];\n\t}\n\treturn d;\n}\n\nvoid main() {\n\tGC.disable();\n\tint n = to!int(readln().strip());\n\twhile(n) {\n\t\tint m = to!int(readln().strip());\n\t\tauto pqr = map!(to!int)(readln().strip().split());\n\t\tint[][] c;\n\t\tc ~= [pqr[0],pqr[1]];\n\t\tint[][] s;\n\t\tforeach(i; 0..m) {\n\t\t\ts ~= array(map!(to!int)(readln().strip().split()));\n\t\t}\n\t\tforeach_reverse(si; s) {\n\t\t\tc = shuffle(c, n, n-si[1], n-si[0]);\n\t\t}\n\t\tint ans;\n\t\tforeach(ci; c) {\n\t\t\tif(ci[0] <= pqr[2]) {\n\t\t\t\tans += min(pqr[2],ci[1])-ci[0]+1;\n\t\t\t}\n\t\t}\n\t\twriteln(ans);\n\t\tn = to!int(readln().strip());\n\t}\n}"
  },
  {
    "language": "D",
    "code": "import std.stdio;\nimport std.c.stdio;\nimport std.range;\nimport std.array;\nimport std.functional;\nimport std.algorithm;\nimport std.conv;\nimport std.container;\nimport std.math;\nimport std.numeric;\nimport std.string;\nimport std.c.string;\nimport std.regex;\nimport std.typecons;\n\nclass M {\n    struct R {\n        int from, to;\n        int length() {\n            return to - from;\n        }\n        int countUnder(int l) {\n            if (l < from) return 0;\n            if (l >= to) return to - from;\n            return l - from + 1;\n        }\n    }\n    R[] rs;\n    this(int from, int to) {\n        rs = [R(from, to)];\n    }\n    int count(int p, int q, int l) {\n        int ret = 0;\n        foreach (r; split(p, q)[1]) {\n            ret += r.countUnder(l);\n        }\n        return ret;\n    }\n    void shuffle(int x, int y) {\n        auto a = split(x, y);\n        rs = a[2] ~ a[1] ~ a[0];\n    }\n    R[][] split(int x, int y) {\n        R[][] a = new R[][3];\n        int t1 = 0, t2 = 0;\n        int index = 0;\n        foreach (r; rs) {\n            t2 += r.length;\n            if (t1 <= x && x < t2) {\n                if (t1 != x) a[index] ~= R(r.from, r.from + x - t1);\n                index++;\n                if (t1 <= y && y < t2) {\n                    a[index] ~= R(r.from + x - t1, r.from + y - t1);\n                    index++;\n                    a[index] ~= R(r.from + y - t1, r.to);\n                } else {\n                    a[index] ~= R(r.from + x - t1, r.to);\n                }\n            } else if (t1 <= y && y < t2) {\n                if (t1 != y) a[index] ~= R(r.from, r.from + y - t1);\n                index++;\n                a[index] ~= R(r.from + y - t1, r.to);\n            } else {\n                a[index] ~= r;\n            }\n            t1 += r.length;\n        }\n        return a;\n    }\n}\n\nvoid main() {\n    int n; \n    while (scanf(\"%d\\n\", &n), n) {\n        int m; scanf(\"%d\\n\", &m);\n        int p, q, r; scanf(\"%d %d %d\\n\", &p, &q, &r);\n        M rs = new M(1, n + 1);\n        foreach (i; 0 .. m) {\n            int x, y; scanf(\"%d %d\\n\", &x, &y);\n            rs.shuffle(x, y);\n        }\n        rs.count(p - 1, q, r).writeln;\n    }\n}"
  },
  {
    "language": "D",
    "code": "import std.stdio;\nimport std.algorithm;\nimport std.string;\nimport std.range;\nimport std.array;\nimport std.conv;\nimport std.complex;\nimport std.math;\nimport std.ascii;\nimport std.bigint;\nimport std.container;\nimport core.memory;\n\nauto shuffle(SList!(int[]) c, int n, int x, int y) {\n\tSList!(int[]) d;\n\tforeach(ci; c) {\n\t\tif(ci[0] <= x) {\n\t\t\tif(ci[1] <= x){\n\t\t\t\td.insert([ci[0]+n-x, ci[1]+n-x]);\n\t\t\t\tcontinue;\n\t\t\t} else {\n\t\t\t\td.insert([ci[0]+n-x, n]);\n\t\t\t\tci[0] = x+1;\n\t\t\t}\n\t\t}\n\t\tif(ci[0] <= y) {\n\t\t\tif(ci[1] <= y) {\n\t\t\t\td.insert([ci[0]+n-x-y, ci[1]+n-x-y]);\n\t\t\t\tcontinue;\n\t\t\t} else {\n\t\t\t\td.insert([ci[0]+n-x-y, n-x]);\n\t\t\t\tci[0] = y+1;\n\t\t\t}\n\t\t}\n\t\td.insert([ci[0]-y, ci[1]-y]);\n\t}\n\treturn d;\n}\n\nvoid main() {\n\tint n = to!int(readln().strip());\n\twhile(n) {\n\t\tint m = to!int(readln().strip());\n\t\tauto pqr = map!(to!int)(readln().strip().split());\n\t\tSList!(int[]) c;\n\t\tc.insert([pqr[0],pqr[1]]);\n\t\tint[][] s;\n\t\tforeach(i; 0..m) {\n\t\t\ts ~= array(map!(to!int)(readln().strip().split()));\n\t\t}\nif(0){\n\t\tforeach_reverse(si; s) {\n\t\t\tc = shuffle(c, n, n-si[1], n-si[0]);\n\t\t}\n\t\tint ans;\n\t\tforeach(ci; c) {\n\t\t\tif(ci[0] <= pqr[2]) {\n\t\t\t\tans += min(pqr[2],ci[1])-ci[0]+1;\n\t\t\t}\n\t\t}\n\t\twriteln(ans);\n}\n\t\tn = to!int(readln().strip());\n\t}\n}"
  },
  {
    "language": "D",
    "code": "import std.stdio;\nimport std.conv;\nimport std.array;\nimport std.container;\nimport std.algorithm;\nimport core.stdc.stdio;\n\nstruct punc{\n\tint u = -1;\n\tint d = -1;\n\tthis(int a,int b){\n\t\tu = a;\n\t\td = b;\n\t}\n\tbool opEquals(punc rhs){\n\t\treturn u == rhs.u;\n\t}\n\tint opCmp(punc rhs){\n\t\tif(u > rhs.u)\n\t\t\treturn 1;\n\t\tif(u < rhs.u)\n\t\t\treturn -1;\n\t\treturn 0;\n\t}\n}\n\nstatic immutable int maxm = 5000;\n\nvoid main(){\n\tpunc[] buf1 = new punc[maxm*2+1];\n\tpunc[] buf2 = new punc[maxm*2+1];\n\twhile(true){\n\t\n\tint n;\n\tscanf(\"%d\",&n);\n\tif(n==0)\n\t\tbreak;\n\tint m;\n\tscanf(\"%d\",&m);\n\tint p;\n\tint q;\n\tint r;\n\tscanf(\"%d%d%d\",&p,&q,&r);\n\t\n\tauto q1 = BinaryHeap!(punc[])(buf1,0);\n\tauto now = &q1;\n\tauto q2 = BinaryHeap!(punc[])(buf2,0);\n\tauto next = &q2;\n\tnow.insert(punc(0,1));\n\t\n\tfor(int i = 0;i<m;++i){\n\t\tint x;\n\t\tint y;\n\t\tscanf(\"%d%d\",&x,&y);\n\t\tint lastd = n;\n\t\t\n\t\twhile(!now.empty()){\n\t\t\tpunc t = now.front();\n\t\t\tnow.removeFront();\n\t\t\tif(t.u >= y){\n\t\t\t\tnext.insert(punc(t.u-y,t.d));\n\t\t\t}else if(t.u >= x){\n\t\t\t\tnext.insert(punc(t.u-x+n-y,t.d));\n\t\t\t\tif(lastd>y){\n\t\t\t\t\tnext.insert(punc(0,t.d+y-t.u));\n\t\t\t\t}\n\t\t\t}else{\n\t\t\t\tnext.insert(punc(n-x+t.u,t.d));\n\t\t\t\tif(lastd>x){\n\t\t\t\t\tnext.insert(punc(n-y,t.d+x-t.u));\n\t\t\t\t\tif(lastd>y){\n\t\t\t\t\t\tnext.insert(punc(0,t.d+y-t.u));\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t}\n\t\t\tlastd = t.u;\n\t\t}\n\t\t\n\t\tauto tmp = now;\n\t\tnow = next;\n\t\tnext = tmp;\n\t}\n\t\n\tint lastd = q;\n\tint res = 0;\n\twhile(!now.empty()){\n\t\tpunc t = now.front();\n\t\tnow.removeFront();\n\t\tbool br = false;\n\t\tif(t.u < p-1){\n\t\t\tt.d += p-1-t.u;\n\t\t\tt.u = p-1;\n\t\t\tbr = true;\n\t\t}\n\t\tif(t.u < q){\n\t\t\tres += min(lastd-t.u,max(0,r+1-t.d));\n\t\t\tlastd = t.u;\n\t\t}\n\t\tif(br){\n\t\t\tbreak;\n\t\t}\n\t}\n\twriteln(res);\n\t\n\t}\n}"
  },
  {
    "language": "D",
    "code": "import std.stdio;\nimport std.c.stdio;\nimport std.range;\nimport std.array;\nimport std.functional;\nimport std.algorithm;\nimport std.conv;\nimport std.container;\nimport std.math;\nimport std.numeric;\nimport std.string;\nimport std.c.string;\nimport std.regex;\nimport std.typecons;\n\nclass M {\n    struct R {\n        int from, to;\n        int length() {\n            return to - from;\n        }\n        int countUnder(int l) {\n            if (l < from) return 0;\n            if (l >= to) return to - from;\n            return l - from + 1;\n        }\n    }\n    R[] rs;\n    this(int from, int to) {\n        rs = [R(from, to)];\n    }\n    int count(int p, int q, int l) {\n        int ret = 0;\n        split(q);\n        auto a = split(p);\n        foreach (r; a) {\n            ret += r.countUnder(l);\n        }\n        return ret;\n    }\n    void shuffle(int x, int y) {\n        auto a = split(y);\n        auto b = split(x);\n        auto c = rs;\n        rs = a ~ b ~ c;\n    }\n    R[] split(int x) {\n        R[] ret;\n        int i = 0;\n        int t = 0;\n        R b;\n        foreach (r; rs) {\n            t += r.length;\n            if (t >= x) {\n                t -= r.length;\n                b = r;\n                break;\n            }\n            i++;\n        }\n        if (t == x) {\n            ret = rs[i .. $];\n            rs = rs[0 .. i];\n        } else {\n            ret ~= R(b.from + x - t, b.to);\n            ret ~= rs[i + 1 .. $];\n            rs = rs[0 .. i];\n            rs ~= R(b.from, b.from + x - t);\n        }\n        return ret;\n    }\n}\n\nvoid main() {\n    int n; \n    while (readf(\"%d\\n\", &n), n) {\n        int m; readf(\"%d\\n\", &m);\n        int p, q, r; readf(\"%d %d %d\\n\", &p, &q, &r);\n        M rs = new M(1, n + 1);\n        foreach (i; 0 .. m) {\n            int x, y; readf(\"%d %d\\n\", &x, &y);\n            rs.shuffle(x, y);\n        }\n        rs.count(p - 1, q, r).writeln;\n    }\n}"
  },
  {
    "language": "D",
    "code": "import std.stdio;\nimport std.algorithm;\nimport core.stdc.stdio;\n\nstatic immutable maxM = 5000;\n\nstruct t{\n\tint idx;\n\tint len;\n}\n\nclass State{\n\tint[] sizes;\n\tt[][] data;\n\tthis(){\n\t\tsizes = new int[3];\n\t\tdata = new t[][3];\n\t\tt[] buf = new t[3*(maxM*2+1)];\n\t\tfor(int i=0;i<3;i++){\n\t\t\tdata[i] = buf[i*(maxM*2+1)..(i+1)*(maxM*2+1)];\n\t\t}\n\t}\n\tvoid Clear(){\n\t\tsizes[] = 0;\n\t}\n}\n\nvoid main(){\n\tState now = new State;\n\tState next = new State;\n\t\n\twhile(true){\n\t\n\tint n,m,p,q,r;\n\tscanf(\"%d\",&n);\n\tif(n==0)\n\t\tbreak;\n\tscanf(\"%d%d%d%d\",&m,&p,&q,&r);\n\tp--;\n\tnow.Clear;\n\tnow.data[0][now.sizes[0]++] = t(1,n);\n\tfor(int _=0;_<m;_++){\n\t\tnext.Clear;\n\t\tint x,y;\n\t\tscanf(\"%d%d\",&x,&y);\n\t\tint len=0;\n\t\tfor(int i=0;i<3;i++){\n\t\t\tfor(int j=0;j<now.sizes[i];j++){\n\t\t\t\tt a = now.data[i][j];\n\t\t\t\tt b;\n\t\t\t\tif(len < x){\n\t\t\t\t\tif(len+a.len > x){\n\t\t\t\t\t\tb.len = len+a.len-x;\n\t\t\t\t\t\ta.len -= b.len;\n\t\t\t\t\t\tb.idx = a.idx+a.len;\n\t\t\t\t\t\tnow.data[i][j] = b;\n\t\t\t\t\t\tj--;\n\t\t\t\t\t}\n\t\t\t\t\tnext.data[2][next.sizes[2]++] = a;\n\t\t\t\t}else if(len < y){\n\t\t\t\t\tif(len+a.len > y){\n\t\t\t\t\t\tb.len = len+a.len-y;\n\t\t\t\t\t\ta.len -= b.len;\n\t\t\t\t\t\tb.idx = a.idx+a.len;\n\t\t\t\t\t\tnow.data[i][j] = b;\n\t\t\t\t\t\tj--;\n\t\t\t\t\t}\n\t\t\t\t\tnext.data[1][next.sizes[1]++] = a;\n\t\t\t\t}else{\n\t\t\t\t\tnext.data[0][next.sizes[0]++] = a;\n\t\t\t\t}\n\t\t\t\tlen += a.len;\n\t\t\t}\n\t\t}\n\t\tswap(now,next);\n\t}\n\tint res=0;\n\tint len=0;\n\tfor(int i=0;i<3;i++){\n\t\tfor(int j=0;j<now.sizes[i];j++){\n\t\t\tt a = now.data[i][j];\n\t\t\tt b;\n\t\t\tif(len < p){\n\t\t\t\tif(len+a.len > p){\n\t\t\t\t\tb.len = len+a.len-p;\n\t\t\t\t\ta.len -= b.len;\n\t\t\t\t\tb.idx = a.idx+a.len;\n\t\t\t\t\tnow.data[i][j] = b;\n\t\t\t\t\tj--;\n\t\t\t\t}\n\t\t\t}else if(len < q){\n\t\t\t\tif(len+a.len > q){\n\t\t\t\t\ta.len = q-len;\n\t\t\t\t}\n\t\t\t\tres += max(0,min(a.len,r+1-a.idx));\n\t\t\t}\n\t\t\tlen += a.len;\n\t\t}\n\t}\n\tprintf(\"%d\\n\",res);\n\t\n\t}\n}"
  },
  {
    "language": "D",
    "code": "import std.stdio;\nimport std.conv;\nimport std.array;\nimport std.container;\nimport std.algorithm;\n\nstruct punc{\n\tint u = -1;\n\tint d = -1;\n\tthis(int a,int b){\n\t\tu = a;\n\t\td = b;\n\t}\n\tbool opEquals(punc rhs){\n\t\treturn u == rhs.u;\n\t}\n\tint opCmp(punc rhs){\n\t\tif(u > rhs.u)\n\t\t\treturn 1;\n\t\tif(u < rhs.u)\n\t\t\treturn -1;\n\t\treturn 0;\n\t}\n}\n\nimmutable int maxm = 5000;\n\nvoid main(){\n\twhile(true){\n\tint n = to!int(readln().split()[0]);\n\tif(n == 0)\n\t\tbreak;\n\tint m = to!int(readln().split()[0]);\n\tstring[] inpqr = readln().split();\n\tint p = to!int(inpqr[0]);\n\tint q = to!int(inpqr[1]);\n\tint r = to!int(inpqr[2]);\n\t\n\tauto q1 = BinaryHeap!(punc[])(new punc[maxm*2+1],0);\n\tauto now = &q1;\n\tauto q2 = BinaryHeap!(punc[])(new punc[maxm*2+1],0);\n\tauto next = &q2;\n\tnow.insert(punc(0,1));\n\t\n\tfor(int i = 0;i<m;++i){\n\t\tstring[] inxy = readln().split();\n\t\tint x = to!int(inxy[0]);\n\t\tint y = to!int(inxy[1]);\n\t\tint lastd = n;\n\t\t\n\t\twhile(!now.empty()){\n\t\t\tpunc t = now.front();\n\t\t\tnow.removeFront();\n\t\t\tif(t.u >= y){\n\t\t\t\tnext.insert(punc(t.u-y,t.d));\n\t\t\t}else if(t.u >= x){\n\t\t\t\tnext.insert(punc(t.u-x+n-y,t.d));\n\t\t\t\tif(lastd>y){\n\t\t\t\t\tnext.insert(punc(0,t.d+y-t.u));\n\t\t\t\t}\n\t\t\t}else{\n\t\t\t\tnext.insert(punc(n-x+t.u,t.d));\n\t\t\t\tif(lastd>x){\n\t\t\t\t\tnext.insert(punc(n-y,t.d+x-t.u));\n\t\t\t\t\tif(lastd>y){\n\t\t\t\t\t\tnext.insert(punc(0,t.d+y-t.u));\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t}\n\t\t\tlastd = t.u;\n\t\t}\n\t\t\n\t\tauto tmp = now;\n\t\tnow = next;\n\t\tnext = tmp;\n\t}\n\t\n\tint lastd = q;\n\tint res = 0;\n\twhile(!now.empty()){\n\t\tpunc t = now.front();\n\t\tnow.removeFront();\n\t\tbool br = false;\n\t\tif(t.u < p-1){\n\t\t\tt.d += p-1-t.u;\n\t\t\tt.u = p-1;\n\t\t\tbr = true;\n\t\t}\n\t\tif(t.u < q){\n\t\t\tres += min(lastd-t.u,max(0,r+1-t.d));\n\t\t\tlastd = t.u;\n\t\t}\n\t\tif(br){\n\t\t\tbreak;\n\t\t}\n\t}\n\twriteln(res);\n\t\n\t}\n}"
  },
  {
    "language": "D",
    "code": "import std.stdio;\nimport std.algorithm;\nimport std.string;\nimport std.range;\nimport std.array;\nimport std.conv;\nimport std.complex;\nimport std.math;\nimport std.ascii;\nimport std.bigint;\nimport std.container;\nimport core.memory;\n\nauto shuffle(SList!(int[]) c, int n, int x, int y) {\n\tSList!(int[]) d;\n\tforeach(ci; c) {\n\t\tif(ci[0] <= x) {\n\t\t\tif(ci[1] <= x){\n\t\t\t\td.insert([ci[0]+n-x, ci[1]+n-x]);\n\t\t\t\tcontinue;\n\t\t\t} else {\n\t\t\t\td.insert([ci[0]+n-x, n]);\n\t\t\t\tci[0] = x+1;\n\t\t\t}\n\t\t}\n\t\tif(ci[0] <= y) {\n\t\t\tif(ci[1] <= y) {\n\t\t\t\td.insert([ci[0]+n-x-y, ci[1]+n-x-y]);\n\t\t\t\tcontinue;\n\t\t\t} else {\n\t\t\t\td.insert([ci[0]+n-x-y, n-x]);\n\t\t\t\tci[0] = y+1;\n\t\t\t}\n\t\t}\n\t\td.insert([ci[0]-y, ci[1]-y]);\n\t}\n\treturn d;\n}\n\nvoid main() {\n\tint n = to!int(readln().strip());\n\twhile(n) {\n\t\tint m = to!int(readln().strip());\n\t\tauto pqr = map!(to!int)(readln().strip().split());\n\t\tSList!(int[]) c;\n\t\tc.insert([pqr[0],pqr[1]]);\n\t\tint[][] s;\n\t\tforeach(i; 0..m) {\n\t\t\ts ~= array(map!(to!int)(readln().strip().split()));\n\t\t}\n\t\tforeach_reverse(si; s) {\n\t\t\tc = shuffle(c, n, n-si[1], n-si[0]);\n\t\t}\n\t\tint ans;\nif(0){\n\t\tforeach(ci; c) {\n\t\t\tif(ci[0] <= pqr[2]) {\n\t\t\t\tans += min(pqr[2],ci[1])-ci[0]+1;\n\t\t\t}\n\t\t}\n\t\twriteln(ans);\n}\n\t\tn = to!int(readln().strip());\n\t}\n}"
  },
  {
    "language": "D",
    "code": "import std.stdio;\nimport std.algorithm;\nimport std.string;\nimport std.range;\nimport std.array;\nimport std.conv;\nimport std.complex;\nimport std.math;\nimport std.ascii;\nimport std.bigint;\nimport std.container;\n\nint[2][] shuffle(int[2][] c, int n, int x, int y) {\n\tauto d = new int[2][](10000);\n\tint i;\n\tforeach(ci; c) {\n\t\tif(ci[0] <= x) {\n\t\t\tif(ci[1] <= x){\n\t\t\t\twriteln(i);\n\t\t\t\td[i++] = [ci[0]+n-x, ci[1]+n-x];\n\t\t\t\tcontinue;\n\t\t\t} else {\n\t\t\t\td[i++] = [ci[0]+n-x, n];\n\t\t\t\tci[0] = x+1;\n\t\t\t}\n\t\t}\n\t\tif(ci[0] <= y) {\n\t\t\tif(ci[1] <= y) {\n\t\t\t\td[i++] = [ci[0]+n-x-y, ci[1]+n-x-y];\n\t\t\t\tcontinue;\n\t\t\t} else {\n\t\t\t\td[i++] = [ci[0]+n-x-y, n-x];\n\t\t\t\tci[0] = y+1;\n\t\t\t}\n\t\t}\n\t\td[i++] = [ci[0]-y, ci[1]-y];\n\t}\n\treturn d[0..i];\n}\n\nvoid main() {\n\tint n = to!int(readln().strip());\n\twhile(n) {\n\t\tint m = to!int(readln().strip());\n\t\tauto pqr = map!(to!int)(readln().strip().split());\n\t\tint[2][] c;\n\t\tc ~= [pqr[0],pqr[1]];\n\t\tint[2][] s;\n\t\tforeach(i; 0..m) {\n\t\t\tauto t = array(map!(to!int)(readln().strip().split()));\n\t\t\ts ~= [t[0], t[1]];\n\t\t}\n\t\tforeach_reverse(si; s) {\n\t\t\tc = shuffle(c, n, n-si[1], n-si[0]);\n\t\t}\n\t\tint ans;\n\t\tforeach(ci; c) {\n\t\t\tif(ci[0] <= pqr[2]) {\n\t\t\t\tans += min(pqr[2],ci[1])-ci[0]+1;\n\t\t\t}\n\t\t}\n\t\twriteln(ans);\n\t\tn = to!int(readln().strip());\n\t}\n}"
  },
  {
    "language": "Python",
    "code": "for e in iter(input,'0'):\n n=int(e)\n C=[*range(1,n+1)]\n m=int(input())\n p,q,r=map(int,input().split())\n for _ in[0]*m:\n  x,y=map(int,input().split())\n  C=C[y:]+C[x:y]+C[:x]\n print(sum(x<=r for x in C[p-1:q]))\n"
  },
  {
    "language": "Python",
    "code": "def shuffle(deck,x,y):\n    cnter = 0\n    i = 0\n    sectiona = sectionb = []\n    while (cnter < x):\n        nextsize = deck[i][1] - deck[i][0] + 1\n        if(x-cnter >= nextsize):\n            cnter += nextsize\n            i += 1\n        else:\n            sectiona = [[deck[i][0],deck[i][0] + x-cnter - 1]]\n            deck[i][0] = deck[i][0] + x-cnter\n            cnter = x\n    memoa = i\n    while (cnter < y):\n        nextsize = deck[i][1] - deck[i][0] + 1\n        if(y-cnter >= nextsize):\n            cnter += nextsize\n            i += 1\n        else:\n            sectionb = [[deck[i][0],deck[i][0] + y-cnter - 1]]\n            deck[i][0] = deck[i][0] + y-cnter\n            cnter = y\n\n    newdeck = deck[i:] + deck[memoa:i] + sectionb + deck[0:memoa] + sectiona\n    return newdeck\n\ndef hitnum(a,r):\n    if a[1] <= r:\n        return a[1]-a[0]+1\n    elif a[0] <= r:\n        return r-a[0]+1\n    else:\n        return 0\n\nwhile True:\n    n = int(input())\n    if n==0: break\n    deck = [[1,n]]\n    m = int(input())\n\n    p,q,r = map(int,input().split())\n\n    for i in range(m):\n        x,y = map(int,input().split())\n        deck = shuffle(deck, x, y)\n\n    deck = shuffle(deck,0,p-1)\n\n    answer = 0\n    cnter = 0\n    i = 0\n    while (cnter < q-p+1):\n        nextsize = deck[i][1] - deck[i][0] + 1\n        if(q-p+1-cnter >= nextsize):\n            answer += hitnum(deck[i],r)\n            cnter += nextsize\n            i += 1\n        else:\n            answer += hitnum([deck[i][0],deck[i][0] + q-p+1-cnter - 1],r)\n            deck[i][0] = deck[i][0] + q-p+1-cnter\n            cnter = q-p+1\n\n    print(answer)"
  },
  {
    "language": "Python",
    "code": "def solve():\n    for e in iter(input, '0'):\n        n = int(e)\n        Cards = [(n, 1, n)]\n        m = int(input())\n        p, q, r = map(int, input().split())\n        for _ in [0] * m:\n            x, y = map(int, input().split())\n            total = 0\n            A, B, C = [], [], []\n            for k, s, t in Cards:\n                if y < total + k:\n                    if total < y:\n                        C += [(total + k - y, s + y - total, t)]\n                        if total < x:\n                            B += [(y - x, s + x - total, s + y - total - 1)]\n                            A += [(x - total, s, s + x - total - 1)]\n                        else:\n                            B += [(y - total, s, s + y - total - 1)]\n                    else:\n                        C += [(k, s, t)]\n                elif x < total + k:\n                    if total < x:\n                        B += [(total + k - x, s + x - total, t)]\n                        A += [(x - total, s, s + x - total - 1)]\n                    else:\n                        B += [(k, s, t)]\n                else:\n                    A += [(k, s, t)]\n                total += k\n            Cards = C + B + A\n        total = 0\n        D = []\n        p = p - 1\n        for k, s, t in Cards:\n            if q < total + k:\n                if total < q:\n                    if total < p:\n                        D += [(s + x - total, s + q - total - 1)]\n                    else:\n                        D += [(s, s + q - total - 1)]\n            elif p < total + k:\n                if total < p:\n                    D += [(s + p - total, t)]\n                else:\n                    D += [(s, t)]\n            total += k\n        ans = 0\n        for s, t in D:\n            if t < r:\n                ans += t - s + 1\n            elif s <= r <= t:\n                ans += r - s + 1\n        print(ans)\n\n\nif __name__ == '__main__':\n    solve()\n"
  },
  {
    "language": "Python",
    "code": "def solve():\n    import sys\n    read = sys.stdin.readline\n    for e in iter(read, '0\\n'):\n        n = int(e)\n        Cards = [(n, 1, n)]\n        m = int(read())\n        p, q, r = map(int, read().split())\n        for _ in [0] * m:\n            x, y = map(int, read().split())\n            total = 0\n            A, B, C = [], [], []\n            for k, s, t in Cards:\n                if y < total + k:\n                    if total < y:\n                        C += [(total + k - y, s + y - total, t)]\n                        if total < x:\n                            B += [(y - x, s + x - total, s + y - total - 1)]\n                            A += [(x - total, s, s + x - total - 1)]\n                        else:\n                            B += [(y - total, s, s + y - total - 1)]\n                    else:\n                        C += [(k, s, t)]\n                elif x < total + k:\n                    if total < x:\n                        B += [(total + k - x, s + x - total, t)]\n                        A += [(x - total, s, s + x - total - 1)]\n                    else:\n                        B += [(k, s, t)]\n                else:\n                    A += [(k, s, t)]\n                total += k\n            Cards = C + B + A\n        total = 0\n        D = []\n        p = p - 1\n        for k, s, t in Cards:\n            if q < total + k:\n                if total < q:\n                    if total < p:\n                        D += [(s + x - total, s + q - total - 1)]\n                    else:\n                        D += [(s, s + q - total - 1)]\n            elif p < total + k:\n                if total < p:\n                    D += [(s + p - total, t)]\n                else:\n                    D += [(s, t)]\n            total += k\n        ans = 0\n        for s, t in D:\n            if t < r:\n                ans += t - s + 1\n            elif s <= r <= t:\n                ans += r - s + 1\n        print(ans)\n\n\nif __name__ == '__main__':\n    solve()\n"
  },
  {
    "language": "Python",
    "code": "def shuffle(deck,x,y):\n    cnter = 0\n    i = 0\n    sectiona = []\n    while (cnter < x):\n        nextsize = deck[i][1] - deck[i][0] + 1\n        if(x-cnter >= nextsize):\n            sectiona.append(deck[i])\n            cnter += nextsize\n            i += 1\n        else:\n            sectiona.append([deck[i][0],deck[i][0] + x-cnter - 1])\n            deck[i][0] = deck[i][0] + x-cnter\n            cnter = x\n\n    sectionb = []\n    while (cnter < y):\n        nextsize = deck[i][1] - deck[i][0] + 1\n        if(y-cnter >= nextsize):\n            sectionb.append(deck[i])\n            cnter += nextsize\n            i += 1\n        else:\n            sectionb.append([deck[i][0],deck[i][0] + y-cnter - 1])\n            deck[i][0] = deck[i][0] + y-cnter\n            cnter = y\n\n    newdeck = deck[i:] + sectionb + sectiona\n    return newdeck\n\ndef hitnum(a,r):\n    if a[1] <= r:\n        return a[1]-a[0]+1\n    elif a[0] <= r:\n        return r-a[0]+1\n    else:\n        return 0\n\nwhile True:\n    n = int(input())\n    if n==0: break\n    deck = [[1,n]]\n    m = int(input())\n\n    p,q,r = map(int,input().split())\n\n    for i in range(m):\n        x,y = map(int,input().split())\n        deck = shuffle(deck, x, y)\n    deck = shuffle(deck,0,p-1)\n\n    answer = 0\n    cnter = 0\n    i = 0\n    while (cnter < q-p+1):\n        nextsize = deck[i][1] - deck[i][0] + 1\n        if(q-p+1-cnter >= nextsize):\n            answer += hitnum(deck[i],r)\n            cnter += nextsize\n            i += 1\n        else:\n            answer += hitnum([deck[i][0],deck[i][0] + q-p+1-cnter - 1],r)\n            deck[i][0] = deck[i][0] + q-p+1-cnter\n            cnter = q-p+1\n\n    print(answer)"
  },
  {
    "language": "Python",
    "code": "def solve():\n    import sys\n    line = sys.stdin.readline\n    for n in iter(line, '0\\n'):\n        Cards = [(int(n), 1)]\n        m = int(line())\n        p, q, r = map(int, line().split())\n        for _ in range(m):\n            x, y = map(int, line().split())\n            total = 0\n            A, B, C = [], [], []\n            for k, s in Cards:\n                t = total + k\n                if total < x:\n                    A += [(x - total, s)]\n                if t <= x:\n                    A += [(k, s)]\n                if total < y < t:\n                    B += [(y - max(x, total), s + (x - total) * (total < x))]\n                if x < t <= y:\n                    B += [([k, t - x][total < x], s + (x - total) * (total < x))]\n                if y < t:\n                    C += [([k, t - y][total < y], s + (y - total) * (total < y))]\n                total = t\n            Cards = C + B + A\n        ans = total = 0\n        p = p - 1\n        for k, s in Cards:\n            if 0 < q - total < k:\n                v = s + (x - total) * (total < p)\n                if v <= r:\n                    ans += min(s + q - total - 1, r) - v + 1\n            if p < total + k <= q:\n                v = s + (p - total) * (total < p)\n                if v <= r:\n                    ans += min(s + k - 1, r) - v + 1\n            total += k\n        print(ans)\n\n\nif __name__ == '__main__':\n    solve()\n"
  },
  {
    "language": "Python",
    "code": "while True:\n    n=input()\n    if n==0:break\n    L=range(1,n+1)\n    m=input()\n    p,q,r=map(int,raw_input().split())\n    for i in range(m):\n        x,y=map(int,raw_input().split())\n        A,B,C=L[:x],L[x:y],L[y:]\n        L=C+B+A\n    print sum(1 for i in L[p-1:q] if i<=r)"
  },
  {
    "language": "Python",
    "code": "def solve():\n    import sys\n    r = sys.stdin.readline\n    for e in iter(r, '0'):\n        n = int(e)\n        Cards = [(n, 1, n)]\n        m = int(r())\n        p, q, r = map(int, r().split())\n        for _ in [0] * m:\n            x, y = map(int, r().split())\n            total = 0\n            A, B, C = [], [], []\n            for k, s, t in Cards:\n                if y < total + k:\n                    if total < y:\n                        C += [(total + k - y, s + y - total, t)]\n                        if total < x:\n                            B += [(y - x, s + x - total, s + y - total - 1)]\n                            A += [(x - total, s, s + x - total - 1)]\n                        else:\n                            B += [(y - total, s, s + y - total - 1)]\n                    else:\n                        C += [(k, s, t)]\n                elif x < total + k:\n                    if total < x:\n                        B += [(total + k - x, s + x - total, t)]\n                        A += [(x - total, s, s + x - total - 1)]\n                    else:\n                        B += [(k, s, t)]\n                else:\n                    A += [(k, s, t)]\n                total += k\n            Cards = C + B + A\n        total = 0\n        D = []\n        p = p - 1\n        for k, s, t in Cards:\n            if q < total + k:\n                if total < q:\n                    if total < p:\n                        D += [(s + x - total, s + q - total - 1)]\n                    else:\n                        D += [(s, s + q - total - 1)]\n            elif p < total + k:\n                if total < p:\n                    D += [(s + p - total, t)]\n                else:\n                    D += [(s, t)]\n            total += k\n        ans = 0\n        for s, t in D:\n            if t < r:\n                ans += t - s + 1\n            elif s <= r <= t:\n                ans += r - s + 1\n        print(ans)\n\n\nif __name__ == '__main__':\n    solve()\n"
  },
  {
    "language": "Python",
    "code": "while True:\n  n = int(input())\n  if not n: break\n  m = int(input())\n  p, q, r = map(int,input().split())\n  S = [[1,n]] #init,last\n\n  for i in range(m):\n    x,y = map(int,input().split())\n    ix = iy = 0\n    dx = dy = 0\n    c = 0\n    for j in range(len(S)):\n      temp = c + (S[j][1] - S[j][0]) + 1 \n      if not dx and temp >= x:\n        ix = j\n        dx = x - c\n      if temp > y:\n        iy = j\n        dy = y - c\n        break\n      c = temp\n\n    X = S[ix][0]\n    Y = S[iy][0]\n    if ix == iy:\n      S = [[Y + dy, S[iy][1]]] + S[iy + 1:] + [[X + dx , Y + dy - 1]] + S[:ix] + [[X, X + dx - 1]]\n    else:\n      S = [[Y + dy, S[iy][1]]] + S[iy + 1:] + [[X + dx, S[ix][1]]] + S[ix + 1 : iy] + [[Y, Y + dy - 1]] + S[:ix] +  [[X, X + dx - 1]]\n  \n  count = 0\n  ans = 0\n  for section in S:\n    l = section[1] - section[0] + 1\n    if p <= count + l and count + l <= q:\n      if r < section[0]: pass\n      elif section[0] <= r and r < section[1]:\n        ans += (r - section[0] + 1)\n      elif section[1] <= r:\n        ans += l\n    elif p <= count + l and q < count + l:\n      if r < section[0]: pass\n      elif section[0] <= r and r < section[1]:\n        ans += min(r - section[0] + 1, q - count)\n      elif section[1] <= r:\n        ans += (q - count)\n      break\n    count += l\n  print(ans)\n"
  },
  {
    "language": "Python",
    "code": "while True:\n    n = int(input())\n    if n == 0:\n        break\n    card = [v+1 for v in range(n)]\n    m = int(input())\n    p, q, r = map(int, input().split())\n    for _ in range(m):\n        x, y = map(int, input().split())\n        A, B, C = card[:x], card[x:y], card[y:]\n        card = C + B + A\n    print(sum([1 for i in range(p-1, q) if card[i] <= r]))"
  },
  {
    "language": "Python",
    "code": "for e in iter(input, '0'):\n    n = int(e)\n    Cards = [(n, 1, n)]\n    m = int(input())\n    p, q, r = map(int, input().split())\n    for _ in [0] * m:\n        x, y = map(int, input().split())\n        total = 0\n        A, B, C = [], [], []\n        for k, s, t in Cards:\n            if y < total + k:\n                if total < y:\n                    C += [(total + k - y, s + y - total, t)]\n                    if total < x:\n                        B += [(y - x, s + x - total, s + y - total - 1)]\n                        A += [(x - total, s, s + x - total - 1)]\n                    else:\n                        B += [(y - total, s, s + y - total - 1)]\n                else:\n                    C += [(k, s, t)]\n            elif x < total + k:\n                if total < x:\n                    B += [(total + k - x, s + x - total, t)]\n                    A += [(x - total, s, s + x - total - 1)]\n                else:\n                    B += [(k, s, t)]\n            else:\n                A += [(k, s, t)]\n            total += k\n        Cards = C + B + A\n    total = 0\n    D = []\n    p = p - 1\n    for k, s, t in Cards:\n        if q < total + k:\n            if total < q:\n                if total < p:\n                    D += [(s + x - total, s + q - total - 1)]\n                else:\n                    D += [(s, s + q - total - 1)]\n        elif p < total + k:\n            if total < p:\n                D += [(s + p - total, t)]\n            else:\n                D += [(s, t)]\n        total += k\n    ans = 0\n    for s, t in D:\n        if t < r:\n            ans += t - s + 1\n        elif s <= r <= t:\n            ans += r - s + 1\n    print(ans)\n"
  },
  {
    "language": "Python",
    "code": "def solve():\n    import sys\n    line = sys.stdin.readline\n    for e in iter(line, '0\\n'):\n        n = int(e)\n        Cards = [(n, 1)]\n        m = int(line())\n        p, q, r = map(int, line().split())\n        for _ in range(m):\n            x, y = map(int, line().split())\n            total = 0\n            A, B, C = [], [], []\n            for k, s in Cards:\n                if y < total + k:\n                    if total < y:\n                        C += [(total + k - y, s + y - total)]\n                        if total < x:\n                            B += [(y - x, s + x - total)]\n                            A += [(x - total, s)]\n                        else:\n                            B += [(y - total, s)]\n                    else:\n                        C += [(k, s)]\n                elif x < total + k:\n                    if total < x:\n                        B += [(total + k - x, s + x - total)]\n                        A += [(x - total, s)]\n                    else:\n                        B += [(k, s)]\n                else:\n                    A += [(k, s)]\n                total += k\n            Cards = C + B + A\n        total = 0\n        ans = 0\n        D = []\n        p = p - 1\n        for k, s in Cards:\n            if 0 < q - total < k:\n                v = (x - total) * (total < p)\n                if v <= r - s:\n                    ans += min(q - total - 1, r - s) - v + 1\n            elif p < total + k:\n                v = (p - total) * (total < p)\n                if v <= r - s:\n                    ans += min(k - 1, r - s) - v + 1\n            total += k\n        print(ans)\n\n\nif __name__ == '__main__':\n    solve()\n"
  },
  {
    "language": "Python",
    "code": "def solve():\n    import sys\n    line = sys.stdin.readline\n    for n in iter(line, '0\\n'):\n        Cards = [(int(n), 1)]\n        m = int(line())\n        p, q, r = map(int, line().split())\n        for _ in range(m):\n            x, y = map(int, line().split())\n            total = 0\n            A, B, C = [], [], []\n            for k, s in Cards:\n                t = total + k\n                if y < t:\n                    if total < y:\n                        C += [(t - y, s + y - total)]\n                        if total < x:\n                            B += [(y - x, s + x - total)]\n                            A += [(x - total, s)]\n                        else:\n                            B += [(y - total, s)]\n                    else:\n                        C += [(k, s)]\n                elif x < t:\n                    if total < x:\n                        B += [(t - x, s + x - total)]\n                        A += [(x - total, s)]\n                    else:\n                        B += [(k, s)]\n                else:\n                    A += [(k, s)]\n                total = t\n            Cards = C + B + A\n        ans = total = 0\n        p = p - 1\n        for k, s in Cards:\n            if q < total + k:\n                if total < q:\n                    v = s + (x - total) * (total < p)\n                    if v <= r:\n                        ans += min(s + q - total - 1, r) - v + 1\n            elif p < total + k:\n                v = s + (p - total) * (total < p)\n                if v <= r:\n                    ans += min(s + k - 1, r) - v + 1\n            total += k\n        print(ans)\n\n\nif __name__ == '__main__':\n    solve()\n"
  },
  {
    "language": "Python",
    "code": "def solve():\n    import sys\n    line = sys.stdin.readline\n    for e in iter(line, '0\\n'):\n        n = int(e)\n        Cards = [(n, 1)]\n        m = int(line())\n        p, q, r = map(int, line().split())\n        for _ in range(m):\n            x, y = map(int, line().split())\n            total = 0\n            A, B, C = [], [], []\n            for k, s in Cards:\n                if y < total + k:\n                    if total < y:\n                        C += [(total + k - y, s + y - total)]\n                        if total < x:\n                            B += [(y - x, s + x - total)]\n                            A += [(x - total, s)]\n                        else:\n                            B += [(y - total, s)]\n                    else:\n                        C += [(k, s)]\n                elif x < total + k:\n                    if total < x:\n                        B += [(total + k - x, s + x - total)]\n                        A += [(x - total, s)]\n                    else:\n                        B += [(k, s)]\n                else:\n                    A += [(k, s)]\n                total += k\n            Cards = C + B + A\n        total = 0\n        ans = 0\n        D = []\n        p = p - 1\n        for k, s in Cards:\n            if q < total + k:\n                if total < q:\n                    v, w = s + (x - total) * (total < p), s + q - total - 1\n                    if w < r:\n                        ans += w - v + 1\n                    elif v <= r <= w:\n                        ans += r - v + 1\n            elif p < total + k:\n                v, w = s + (p - total) * (total < p), s + k - 1\n                if w < r:\n                    ans += w - v + 1\n                elif v <= r <= w:\n                    ans += r - v + 1\n            total += k\n        print(ans)\n\n\nif __name__ == '__main__':\n    solve()\n"
  },
  {
    "language": "Python",
    "code": "def solve():\n    import sys\n    line = sys.stdin.readline\n    for e in iter(line, '0\\n'):\n        n = int(e)\n        Cards = [(n, 1, n)]\n        m = int(line())\n        p, q, r = map(int, line().split())\n        for _ in range(m):\n            x, y = map(int, line().split())\n            total = 0\n            A, B, C = [], [], []\n            for k, s, t in Cards:\n                if y < total + k:\n                    if total < y:\n                        C += [(total + k - y, s + y - total, t)]\n                        if total < x:\n                            B += [(y - x, s + x - total, s + y - total - 1)]\n                            A += [(x - total, s, s + x - total - 1)]\n                        else:\n                            B += [(y - total, s, s + y - total - 1)]\n                    else:\n                        C += [(k, s, t)]\n                elif x < total + k:\n                    if total < x:\n                        B += [(total + k - x, s + x - total, t)]\n                        A += [(x - total, s, s + x - total - 1)]\n                    else:\n                        B += [(k, s, t)]\n                else:\n                    A += [(k, s, t)]\n                total += k\n            Cards = C + B + A\n        total = 0\n        D = []\n        p = p - 1\n        for k, s, t in Cards:\n            if q < total + k:\n                if total < q:\n                    if total < p:\n                        D += [(s + x - total, s + q - total - 1)]\n                    else:\n                        D += [(s, s + q - total - 1)]\n            elif p < total + k:\n                if total < p:\n                    D += [(s + p - total, t)]\n                else:\n                    D += [(s, t)]\n            total += k\n        ans = 0\n        for s, t in D:\n            if t < r:\n                ans += t - s + 1\n            elif s <= r:\n                ans += r - s + 1\n        print(ans)\n\n\nif __name__ == '__main__':\n    solve()\n"
  },
  {
    "language": "Python",
    "code": "def solve():\n    import sys\n    line = sys.stdin.readline\n    for e in iter(line, '0\\n'):\n        n = int(e)\n        Cards = [(n, 1, n)]\n        m = int(line())\n        p, q, r = map(int, line().split())\n        for _ in range(m):\n            x, y = map(int, line().split())\n            total = 0\n            A, B, C = [], [], []\n            for k, s, t in Cards:\n                if y < total + k:\n                    if total < y:\n                        C += [(total + k - y, s + y - total, t)]\n                        if total < x:\n                            B += [(y - x, s + x - total, s + y - total - 1)]\n                            A += [(x - total, s, s + x - total - 1)]\n                        else:\n                            B += [(y - total, s, s + y - total - 1)]\n                    else:\n                        C += [(k, s, t)]\n                elif x < total + k:\n                    if total < x:\n                        B += [(total + k - x, s + x - total, t)]\n                        A += [(x - total, s, s + x - total - 1)]\n                    else:\n                        B += [(k, s, t)]\n                else:\n                    A += [(k, s, t)]\n                total += k\n            Cards = C + B + A\n        total = 0\n        D = []\n        p = p - 1\n        for k, s, t in Cards:\n            if q < total + k:\n                if total < q:\n                    if total < p:\n                        D += [(s + x - total, s + q - total - 1)]\n                    else:\n                        D += [(s, s + q - total - 1)]\n            elif p < total + k:\n                if total < p:\n                    D += [(s + p - total, t)]\n                else:\n                    D += [(s, t)]\n            total += k\n        ans = 0\n        for s, t in D:\n            if t < r:\n                ans += t - s + 1\n            elif s <= r <= t:\n                ans += r - s + 1\n        print(ans)\n\n\nif __name__ == '__main__':\n    solve()\n"
  },
  {
    "language": "Python",
    "code": "def solve():\n    import sys\n    line = sys.stdin.readline\n    for e in iter(line, '0\\n'):\n        n = int(e)\n        Cards = [(n, 1)]\n        m = int(line())\n        p, q, r = map(int, line().split())\n        for _ in range(m):\n            x, y = map(int, line().split())\n            total = 0\n            A, B, C = [], [], []\n            for k, s in Cards:\n                if y < total + k:\n                    if total < y:\n                        C += [(total + k - y, s + y - total)]\n                        if total < x:\n                            B += [(y - x, s + x - total)]\n                            A += [(x - total, s)]\n                        else:\n                            B += [(y - total, s)]\n                    else:\n                        C += [(k, s)]\n                elif x < total + k:\n                    if total < x:\n                        B += [(total + k - x, s + x - total)]\n                        A += [(x - total, s)]\n                    else:\n                        B += [(k, s)]\n                else:\n                    A += [(k, s)]\n                total += k\n            Cards = C + B + A\n        total = 0\n        D = []\n        p = p - 1\n        for k, s in Cards:\n            if q < total + k:\n                if total < q:\n                    if total < p:\n                        D += [(s + x - total, s + q - total - 1)]\n                    else:\n                        D += [(s, s + q - total - 1)]\n            elif p < total + k:\n                if total < p:\n                    D += [(s + p - total, s + k - 1)]\n                else:\n                    D += [(s, s + k - 1)]\n            total += k\n        ans = 0\n        for s, t in D:\n            if t < r:\n                ans += t - s + 1\n            elif s <= r <= t:\n                ans += r - s + 1\n        print(ans)\n\n\nif __name__ == '__main__':\n    solve()\n"
  },
  {
    "language": "Python",
    "code": "\n\ndef shuffle(deck,x,y):\n    cnter = 0\n    i = 0\n    sectiona = [0,0]\n    sectionb = [0,0]\n    while (cnter < x):\n        nextsize = deck[i][1] - deck[i][0] + 1\n        if(x-cnter >= nextsize):\n            cnter += nextsize\n            i += 1\n        else:\n            sectiona[0] = deck[i][0]\n            sectiona[1] = deck[i][0] + x-cnter - 1\n            deck[i][0] = deck[i][0] + x-cnter\n            cnter = x\n    memoa = i\n    while (cnter < y):\n        nextsize = deck[i][1] - deck[i][0] + 1\n        if(y-cnter >= nextsize):\n            cnter += nextsize\n            i += 1\n        else:\n            sectionb[0] = deck[i][0]\n            sectionb[1] = deck[i][0] + y-cnter - 1\n            deck[i][0] = deck[i][0] + y-cnter\n            cnter = y\n\n    # + is too slow\n    newdeck =deck[i:]\n    newdeck.extend(deck[memoa:i])\n    if sectionb[1]:\n        newdeck.append(sectionb)\n    newdeck.extend(deck[0:memoa])\n    if sectiona[1]:\n        newdeck.append(sectiona)\n    return newdeck\n\ndef hitnum(a,r):\n    if a[1] <= r:\n        return a[1]-a[0]+1\n    elif a[0] <= r:\n        return r-a[0]+1\n    else:\n        return 0\n\nwhile True:\n    n = int(input())\n    if n==0: break\n    deck = [[1,n]]\n    m = int(input())\n\n    p,q,r = map(int,input().split())\n\n    for i in range(m):\n        x,y = map(int,input().split())\n        deck = shuffle(deck, x, y)\n\n    deck = shuffle(deck,0,p-1)\n\n    answer = 0\n    cnter = 0\n    i = 0\n    while (cnter < q-p+1):\n        nextsize = deck[i][1] - deck[i][0] + 1\n        if(q-p+1-cnter >= nextsize):\n            answer += hitnum(deck[i],r)\n            cnter += nextsize\n            i += 1\n        else:\n            answer += hitnum([deck[i][0],deck[i][0] + q-p+1-cnter - 1],r)\n            deck[i][0] = deck[i][0] + q-p+1-cnter\n            cnter = q-p+1\n\n    print(answer)"
  },
  {
    "language": "Python",
    "code": "def solve():\n    import sys\n    r = sys.stdin.readline\n    for e in iter(r, '0\\n'):\n        n = int(e)\n        Cards = [(n, 1, n)]\n        m = int(r())\n        p, q, r = map(int, r().split())\n        for _ in [0] * m:\n            x, y = map(int, r().split())\n            total = 0\n            A, B, C = [], [], []\n            for k, s, t in Cards:\n                if y < total + k:\n                    if total < y:\n                        C += [(total + k - y, s + y - total, t)]\n                        if total < x:\n                            B += [(y - x, s + x - total, s + y - total - 1)]\n                            A += [(x - total, s, s + x - total - 1)]\n                        else:\n                            B += [(y - total, s, s + y - total - 1)]\n                    else:\n                        C += [(k, s, t)]\n                elif x < total + k:\n                    if total < x:\n                        B += [(total + k - x, s + x - total, t)]\n                        A += [(x - total, s, s + x - total - 1)]\n                    else:\n                        B += [(k, s, t)]\n                else:\n                    A += [(k, s, t)]\n                total += k\n            Cards = C + B + A\n        total = 0\n        D = []\n        p = p - 1\n        for k, s, t in Cards:\n            if q < total + k:\n                if total < q:\n                    if total < p:\n                        D += [(s + x - total, s + q - total - 1)]\n                    else:\n                        D += [(s, s + q - total - 1)]\n            elif p < total + k:\n                if total < p:\n                    D += [(s + p - total, t)]\n                else:\n                    D += [(s, t)]\n            total += k\n        ans = 0\n        for s, t in D:\n            if t < r:\n                ans += t - s + 1\n            elif s <= r <= t:\n                ans += r - s + 1\n        print(ans)\n\n\nif __name__ == '__main__':\n    solve()\n"
  },
  {
    "language": "Python",
    "code": "while True:\n    n=input()\n    if n==0:break\n    m=input()\n    p,q,r=map(int,raw_input().split())\n    L=\"0\"*r+\"1\"*(n-r)\n    for i in range(m):\n        x,y=map(int,raw_input().split())\n        L=L[:x]+L[x:y]+L[y:]\n    print sum(1 for i in L[p-1:q] if i==\"0\")"
  },
  {
    "language": "Python",
    "code": "while True:\n  n = int(input())\n  if not n: break\n  m = int(input())\n  p, q, r = map(int,input().split())\n  S = [(1,n)]\n\n  for i in range(m):\n    x,y = map(int,input().split())\n    ix = iy = 0\n    dx = dy = 0\n    c = 0\n    for j in range(len(S)):\n      temp = c + (S[j][1] - S[j][0]) + 1 \n      if not dx and temp >= x:\n        ix = j\n        dx = x - c\n      if temp > y:\n        iy = j\n        dy = y - c\n        break\n      c = temp\n\n    X = S[ix][0]\n    Y = S[iy][0]\n    if ix == iy:\n      S1 =  [(Y + dy, S[iy][1])]\n      extend = S1.extend\n      append = S1.append\n      extend(S[iy + 1:])\n      append((X + dx , Y + dy - 1))\n      extend(S[:ix])\n      append((X, X + dx - 1))\n      S = S1\n    else:\n      S1 = [(Y + dy, S[iy][1])] \n      extend = S1.extend\n      append = S1.append\n      extend(S[iy + 1:])\n      append((X + dx, S[ix][1]))\n      extend(S[ix + 1 : iy])\n      append((Y, Y + dy - 1))\n      extend(S[:ix])\n      append((X, X + dx - 1))\n      S = S1\n  \n  count = 0\n  ans = 0\n  for section in S:\n    l = section[1] - section[0] + 1\n    if p <= count + l and count + l <= q:\n      if r < section[0]: pass\n      elif section[0] <= r and r < section[1]:\n        ans += (r - section[0] + 1)\n      elif section[1] <= r:\n        ans += l\n    elif p <= count + l and q < count + l:\n      if r < section[0]: pass\n      elif section[0] <= r and r < section[1]:\n        ans += min(r - section[0] + 1, q - count)\n      elif section[1] <= r:\n        ans += (q - count)\n      break\n    count += l\n  print(ans)\n"
  },
  {
    "language": "Python",
    "code": "while True:\n    n = int(input())\n    if n == 0: break\n    m = int(input())\n    p, q, r = map(int, input().split())\n    card = [i+1 for i in range(n)]\n    for _ in range(m):\n        x, y = map(int, input().split())\n        A, B = card[:x], card[x:y]\n        card = card[y:] + B + A\n    print(sum([1 for v in card[p-1:q] if v <= r]))"
  },
  {
    "language": "Rust",
    "code": "#[allow(unused_imports)]\nuse std::io::{stdin, Read, StdinLock};\n#[allow(unused_imports)]\nuse std::cmp::{max, min, Ordering};\n#[allow(unused_imports)]\nuse std::str::FromStr;\n#[allow(unused_imports)]\nuse std::collections::{HashSet, HashMap, BinaryHeap, VecDeque};\n#[allow(unused_imports)]\nuse std::vec::Vec;\n\n#[allow(dead_code)]\nconst INF: i32 = 1000_000_000;\n#[allow(dead_code)]\nconst INFLL: i64 = 1000_000_000_000_000_000;\n#[allow(dead_code)]\nconst EPS: f64 = 1.0e-10;\n#[allow(dead_code)]\nconst MOD: i32 = 1000_000_007;\n#[allow(dead_code)]\nconst MODLL: i64 = 1000_000_007;\n\nstruct Scanner<'a> {\n    cin: StdinLock<'a>,\n}\n\n#[allow(dead_code)]\nimpl<'a> Scanner<'a> {\n    fn new(cin: StdinLock<'a>) -> Scanner<'a> {\n        Scanner {cin: cin}\n    }\n    fn read1<T: FromStr>(&mut self) -> Option<T> {\n        let token = self.cin.by_ref().bytes().map(|c| c.unwrap() as char)\n                    .skip_while(|c| c.is_whitespace())\n                    .take_while(|c| !c.is_whitespace())\n                    .collect::<String>();\n        token.parse::<T>().ok()\n    }\n    fn read<T: FromStr>(&mut self) -> T {\n        self.read1().unwrap()\n    }\n}\n\n\nfn main() {\n    let cin = stdin();\n    let cin = cin.lock();\n    let mut sc = Scanner::new(cin);\n\n    loop {\n        let n: usize = sc.read();\n        if n == 0 {\n            break;\n        }\n        let m: usize = sc.read();\n        let (p, q, r): (i32, i32, i32) = (sc.read(), sc.read(), sc.read());\n        let mut x: Vec<i32> = vec![0; m];\n        let mut y: Vec<i32> = vec![0; m];\n        for i in 0..m {\n            x[i] = sc.read();\n            y[i] = sc.read();\n        }\n        let x = x; let y = y;\n\n        let mut v: Vec<(i32, i32)> = vec![(1, n as i32)]; // [l, r]\n\n        for i in 0..m {\n            let (x, y) = (x[i], y[i]);\n            let mut front: Vec<(i32, i32)> = Vec::new();\n            let mut mid: Vec<(i32, i32)> = Vec::new();\n            let mut back: Vec<(i32, i32)> = Vec::new();\n            let mut sum = 0;\n            let mut j = 0;\n            while j < v.len() { // front\n                let (l, r) = v[j];\n                if sum + r - l + 1 >= x {\n                    front.push((l, l + x - sum - 1));\n                    if l + x - sum - 1 == r {\n                        sum += r - l + 1;\n                        j += 1;\n                    }\n                    break;\n                }\n                front.push((l, r));\n                j += 1;\n                sum += r - l + 1;\n            }\n            while j < v.len() { // mid\n                let (l, r) = v[j];\n                let add = max(0, min(x - sum, r - l)); // performed only first\n                if sum + r - l + 1 >= y {\n                    mid.push((l + add, l + y - sum - 1));\n                    if l + y - sum - 1 == r {\n                        sum += r - l + 1;\n                        j += 1;\n                    }\n                    break;\n                }\n                sum += r - l + 1;\n                let l = l + add;\n                mid.push((l, r));\n                j += 1;\n            }\n            while j < v.len() { // back\n                let (l, r) = v[j];\n                let add = max(0, min(y - sum, r - l));\n                sum += r - l + 1;\n                let l = l + add;\n                back.push((l, r));\n                j += 1;\n            }\n            v.clear();\n            v.append(&mut back);\n            v.append(&mut mid);\n            v.append(&mut front);\n        }\n\n        let mut ans = 0;\n        let mut sum = 0;\n        for (l, u) in v {\n            if sum + u - l + 1 >= p {\n                let lv = l + max(p - sum - 1, 0);\n                let lr = min(u, l + (q - sum - 1));\n                let lr = min(lr, r);\n                if lv <= lr {\n                    ans += lr - lv + 1;\n                }\n            }\n            sum += u - l + 1;\n        }\n\n        println!(\"{}\", ans);\n    }\n}\n"
  }
]