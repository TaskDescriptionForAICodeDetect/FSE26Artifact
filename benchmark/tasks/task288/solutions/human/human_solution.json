[
  {
    "language": "C++",
    "code": "#include<stdio.h>\n#include<algorithm>\n#include<vector>\n#define N_ 801000\nusing namespace std;\nint n, m, Deg[N_], Q[N_], head, tail, D[N_], Res, cnt;\nint B1[N_], B2[N_];\nvector<int>E[N_], G[101000];\nvoid Make_Edge(int a, int b, int c){\n    E[a].push_back(b*2+c);\n}\nint main(){\n    int i, a, b, c, x, sz, j;\n    scanf(\"%d%d\",&n,&m);\n    cnt = 2*n;\n    for(i=1;i<=m;i++){\n        scanf(\"%d%d%d\",&a,&b,&c);\n        if(c==1){\n            Make_Edge(n+a,b,1);\n        }\n        else{\n            Make_Edge(cnt+1,cnt+4,1);\n            Make_Edge(cnt+3,cnt+2,1);\n            G[a].push_back(cnt+1);\n            G[b].push_back(cnt+3);\n            cnt+=4;\n        }\n    }\n    for(i=1;i<=n;i++){\n        Make_Edge(i,i+n,0);\n        sz = G[i].size();\n        if(!sz)continue;\n        B1[i] = cnt+1;\n        for(j=0;j<sz;j++){\n            cnt++;\n            Make_Edge(cnt,G[i][j],0);\n            if(j)Make_Edge(cnt, cnt-1,0);\n        }\n        B2[i] = cnt+1;\n        for(j=sz-1;j>=0;j--){\n            cnt++;\n            Make_Edge(cnt,G[i][j],0);\n            if(j!=sz-1)Make_Edge(cnt, cnt-1,0);\n        }\n        for(j=0;j<sz;j++){\n            Make_Edge(i,G[i][j],0);\n            Make_Edge(G[i][j]+1,n+i,0);\n            if(j)Make_Edge(G[i][j]+1, B1[i]+j-1,0);\n            if(j!=sz-1)Make_Edge(G[i][j]+1, B2[i]+sz-j-2,0);\n        }\n    }\n    for(i=1;i<=cnt;i++){\n        for(j=0;j<E[i].size();j++){\n            Deg[E[i][j]/2]++;\n        }\n    }\n    for(i=1;i<=cnt;i++){\n        if(!Deg[i])Q[++tail] = i;\n    }\n    while(head < tail){\n        x = Q[++head];\n        Res = max(Res, D[x]);\n        for(i=0;i<E[x].size();i++){\n            Deg[E[x][i]/2]--;\n            D[E[x][i]/2] = max(D[E[x][i]]/2, D[x] + E[x][i]%2);\n            if(!Deg[E[x][i]/2])Q[++tail] = E[x][i]/2;\n        }\n    }\n    if(tail != cnt){\n        printf(\"Infinite\\n\");\n        return 0;\n    }\n    printf(\"%d\\n\",Res);\n}"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\n\nusing namespace std;\n\nconst int INF = 1 << 29;\n\nstruct UnionFind\n{\n  vector< int > data;\n\n  UnionFind(int sz)\n  {\n    data.assign(sz, -1);\n  }\n\n  int find(int k)\n  {\n    return (data[k] < 0 ? k : data[k] = find(data[k]));\n  }\n\n  void unite(int x, int y)\n  {\n    x = find(x);\n    y = find(y);\n    if(data[x] > data[y]) swap(x, y);\n    data[x] += data[y];\n    data[y] = x;\n  }\n};\n\nvector< pair< int, int > > g[100001];\nvector< int > leftt[100001], rightt[100001], just[100001];\nvector< int > gg[100001];\nint deg[100001];\n\n\nint rec(int idx, int back = -1)\n{\n  if(back != -1) {\n    int tmp = max(leftt[idx][back], rightt[idx][back + 1]);\n    if(tmp != INF) return (tmp);\n  }\n  if(rightt[idx][0] == INF) {\n    for(int i = 0; i < g[idx].size(); i++) {\n      int to, rev;\n      tie(to, rev) = g[idx][i];\n      if(to == back || just[idx][i] != INF) continue;\n      just[idx][i] = rec(to, g[idx][i].second) + 1;\n    }\n    for(int i = 0; i < g[idx].size(); i++) {\n      leftt[idx][i + 1] = max(leftt[idx][i], just[idx][i]);\n    }\n    for(int i = (int) g[idx].size() - 1; i >= 0; i--) {\n      rightt[idx][i] = max(rightt[idx][i + 1], just[idx][i]);\n    }\n  }\n\n  if(back == -1) return (rightt[idx][0]);\n  return (max(leftt[idx][back], rightt[idx][back + 1]));\n}\n\n\nint main()\n{\n  int N, M;\n  vector< pair< int, int > > edges, arcs;\n\n  scanf(\"%d %d\", &N, &M);\n\n  UnionFind uf(N);\n\n  for(int i = 0; i < M; i++) {\n    int x, y, t;\n    cin >> x >> y >> t;\n    --x, --y;\n    if(t == 1) {\n      arcs.emplace_back(x, y);\n      g[x].emplace_back(y, -1);\n    } else {\n      if(uf.find(x) == uf.find(y)) {\n        cout << \"Infinite\" << endl;\n        return (0);\n      }\n      uf.unite(x, y);\n      edges.emplace_back(x, y);\n      g[y].emplace_back(x, g[x].size());\n      g[x].emplace_back(y, g[y].size() - 1);\n    }\n  }\n\n  {\n    for(auto &e : arcs) {\n      gg[uf.find(e.first)].push_back(uf.find(e.second));\n      ++deg[uf.find(e.second)];\n    }\n    vector< int > order;\n    for(int i = 0; i < N; i++) {\n      if(deg[i] == 0) order.push_back(i);\n    }\n    for(int i : order) {\n      for(auto &e : gg[i]) {\n        if(--deg[e] == 0) order.push_back(e);\n      }\n    }\n    if(order.size() != N) {\n      cout << \"Infinite\" << endl;\n      return (0);\n    }\n  }\n\n\n  int ret = 0;\n  for(int i = 0; i < N; i++) {\n    int sz = g[i].size();\n    just[i].assign(sz, INF);\n    leftt[i].assign(sz + 1, INF);\n    rightt[i].assign(sz + 1, INF);\n    leftt[i][0] = rightt[i][sz] = 0;\n  }\n  for(int i = 0; i < N; i++) ret = max(ret, rec(i));\n  cout << ret << endl;\n}"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\n#define rep(i,N) for(int i=0;i<(int)N;i++)\n#define rep1(i,N) for(int i=1;i<=(int)N;i++)\n#define pb push_back\n#define all(c) c.begin(),c.end()\n#define show(x) cout<<#x<<\" \"<<x<<endl\n#define chmax(x,y) x=max(x,y)\n#define BEGIN_STACK_EXTEND(size) void * stack_extend_memory_ = malloc(size);void * stack_extend_origin_memory_;char * stack_extend_dummy_memory_ = (char*)alloca((1+(int)(((long long)stack_extend_memory_)&127))*16);*stack_extend_dummy_memory_ = 0;asm volatile(\"mov %%rsp, %%rbx\\nmov %%rax, %%rsp\":\"=b\"(stack_extend_origin_memory_):\"a\"((char*)stack_extend_memory_+(size)-1024));\n#define END_STACK_EXTEND asm volatile(\"mov %%rax, %%rsp\"::\"a\"(stack_extend_origin_memory_));free(stack_extend_memory_);\nusing namespace std;\nconst int MN=100000;\nstruct edge {int to,w,rev;};\ntypedef vector< vector<edge> > Graph;\nGraph G,oG;\nvoid add_edge(int x,int y,int w,int way){\n\tif(way==1){\n\t\tG[x].pb({y,w,-1});\n\t}else{\n\t\tint X=G[x].size(),Y=G[y].size();\n\t\tG[x].pb({y,w,Y});\n\t\tG[y].pb({x,w,X});\n\t}\n}\n\ntypedef pair<int,int> P;\nint memo[300000][4];\nbool vis[300000][4];\nint dfs(int v,int eid){\n\teid++;\n\tif(memo[v][eid]!=-1) return memo[v][eid];\n\tif(vis[v][eid]){\n\t\tputs(\"Infinite\");\n\t\texit(1);\n\t}\n\tvis[v][eid]=1;\n\tint ret=0;\n\t// rep(i,G[v].size()) if(i!=eid-1){\n\t// \tedge& e=G[v][i];\n\t// \tchmax(ret,dfs(e.to,e.rev)+e.w);\n\t// }\n\tif(G[v].size()>0 && eid!=1) chmax(ret,dfs(G[v][0].to,G[v][0].rev)+G[v][0].w);\n\tif(G[v].size()>1 && eid!=2) chmax(ret,dfs(G[v][1].to,G[v][1].rev)+G[v][1].w);\n\tif(G[v].size()>2 && eid!=3) chmax(ret,dfs(G[v][2].to,G[v][2].rev)+G[v][2].w);\n\tmemo[v][eid]=ret;\n\treturn ret;\n}\n\nint rs[100001]={};\nint its[100000]={};\n\nint main(){\n//\tBEGIN_STACK_EXTEND(128*1024*1024);\n\tint N,M;\n\tcin>>N>>M;\n\toG.resize(N);\n\trep(i,M){\n\t\tint x,y,w;\n\t\tscanf(\"%d %d %d\",&x,&y,&w);\n\t\tx--,y--;\n\t\tif(w==1){\n\t\t\toG[x].pb(edge{y,1,-1});\n\t\t}else{\n\t\t\tint X=oG[x].size(),Y=oG[y].size();\n\t\t\toG[x].pb(edge{y,1,Y});\n\t\t\toG[y].pb(edge{x,1,X});\n\t\t}\n\t}\n\tint newN=0;\n\trep(i,N){\n\t\tint sz=oG[i].size();\n\t\tif(sz==0) sz=1;\n\t\trs[i]=newN;\n\t\tits[i]=rs[i];\n\t\tnewN+=sz;\n\t}\n\trs[N]=newN;\n\tG.resize(newN);\n\trep(x,N){\n\t\tint n=rs[x+1]-rs[x];\n\t\tfor(int v=rs[x];v<rs[x]+n-1;v++) add_edge(v,v+1,0,2);\n\t\tfor(edge e: oG[x]){\n\t\t\tif(e.rev==-1){\t//one way\n\t\t\t\tadd_edge(its[x],rs[e.to],1,1);\n\t\t\t\tits[x]++;\n\t\t\t}else{\n\t\t\t\tif(x<e.to){\n\t\t\t\t\tadd_edge(its[x],its[e.to],1,2);\n\t\t\t\t\tits[x]++;\n\t\t\t\t\tits[e.to]++;\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t}\n\tint ans=0;\n\tN=newN;\n\trep(i,N) assert(G[i].size()<=3);\n\trep(i,N) rep(j,4) memo[i][j]=-1;\n\trep(i,N) chmax(ans,dfs(i,-1));\n\tcout<<ans<<endl;\n//\tEND_STACK_EXTEND;\n}"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\n\nusing namespace std;\n\nconst int INF = 1 << 29;\n\nstruct UnionFind\n{\n  vector< int > data;\n\n  UnionFind(int sz)\n  {\n    data.assign(sz, -1);\n  }\n\n  int find(int k)\n  {\n    return (data[k] < 0 ? k : data[k] = find(data[k]));\n  }\n\n  void unite(int x, int y)\n  {\n    x = find(x);\n    y = find(y);\n    if(data[x] > data[y]) swap(x, y);\n    data[x] += data[y];\n    data[y] = x;\n  }\n};\n\nvector< pair< int, int > > g[100001];\nvector< int > leftt[100001], rightt[100001], just[100001];\nvector< int > gg[100001];\nint deg[100001];\n\n\nint rec(int idx, int back = -1)\n{\n  if(back != -1) {\n    int tmp = max(leftt[idx][back], rightt[idx][back + 1]);\n    if(tmp != INF) return (tmp);\n  }\n  if(rightt[idx][0] == INF) {\n    for(int i = 0; i < g[idx].size(); i++) {\n      int to, rev;\n      tie(to, rev) = g[idx][i];\n      if(rev == back || just[idx][i] != INF) continue;\n      just[idx][i] = rec(to, g[idx][i].second) + 1;\n    }\n    for(int i = 0; i < g[idx].size(); i++) {\n      leftt[idx][i + 1] = max(leftt[idx][i], just[idx][i]);\n    }\n    for(int i = (int) g[idx].size() - 1; i >= 0; i--) {\n      rightt[idx][i] = max(rightt[idx][i + 1], just[idx][i]);\n    }\n  }\n\n  if(back == -1) return (rightt[idx][0]);\n  return (max(leftt[idx][back], rightt[idx][back + 1]));\n}\n\n\nint main()\n{\n  int N, M;\n  vector< pair< int, int > > edges, arcs;\n\n  scanf(\"%d %d\", &N, &M);\n\n  UnionFind uf(N);\n\n  for(int i = 0; i < M; i++) {\n    int x, y, t;\n    cin >> x >> y >> t;\n    --x, --y;\n    if(t == 1) {\n      arcs.emplace_back(x, y);\n      g[x].emplace_back(y, -1);\n    } else {\n      if(uf.find(x) == uf.find(y)) {\n        cout << \"Infinite\" << endl;\n        return (0);\n      }\n      uf.unite(x, y);\n      edges.emplace_back(x, y);\n      g[y].emplace_back(x, g[x].size());\n      g[x].emplace_back(y, g[y].size() - 1);\n    }\n  }\n\n  {\n    for(auto &e : arcs) {\n      gg[uf.find(e.first)].push_back(uf.find(e.second));\n      ++deg[uf.find(e.second)];\n    }\n    vector< int > order;\n    for(int i = 0; i < N; i++) {\n      if(deg[i] == 0) order.push_back(i);\n    }\n    for(int i : order) {\n      for(auto &e : gg[i]) {\n        if(--deg[e] == 0) order.push_back(e);\n      }\n    }\n    if(order.size() != N) {\n      cout << \"Infinite\" << endl;\n      return (0);\n    }\n  }\n\n\n  int ret = 0;\n  for(int i = 0; i < N; i++) {\n    int sz = g[i].size();\n    just[i].assign(sz, INF);\n    leftt[i].assign(sz + 1, INF);\n    rightt[i].assign(sz + 1, INF);\n    leftt[i][0] = rightt[i][sz] = 0;\n  }\n  for(int i = 0; i < N; i++) ret = max(ret, rec(i));\n  cout << ret << endl;\n}"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\n#define rep(i,N) for(int i=0;i<(int)N;i++)\n#define rep1(i,N) for(int i=1;i<=(int)N;i++)\n#define pb push_back\n#define all(c) c.begin(),c.end()\n#define show(x) cout<<#x<<\" \"<<x<<endl\n#define chmax(x,y) x=max(x,y)\n#define BEGIN_STACK_EXTEND(size) void * stack_extend_memory_ = malloc(size);void * stack_extend_origin_memory_;char * stack_extend_dummy_memory_ = (char*)alloca((1+(int)(((long long)stack_extend_memory_)&127))*16);*stack_extend_dummy_memory_ = 0;asm volatile(\"mov %%rsp, %%rbx\\nmov %%rax, %%rsp\":\"=b\"(stack_extend_origin_memory_):\"a\"((char*)stack_extend_memory_+(size)-1024));\n#define END_STACK_EXTEND asm volatile(\"mov %%rax, %%rsp\"::\"a\"(stack_extend_origin_memory_));free(stack_extend_memory_);\nusing namespace std;\nconst int MN=100000;\nstruct edge {int to,w,rev;};\ntypedef vector< vector<edge> > Graph;\nGraph G,oG;\nvoid add_edge(int x,int y,int w,int way){\n\tif(way==1){\n\t\tG[x].pb({y,w,-1});\n\t}else{\n\t\tint X=G[x].size(),Y=G[y].size();\n\t\tG[x].pb({y,w,Y});\n\t\tG[y].pb({x,w,X});\n\t}\n}\n\ntypedef pair<int,int> P;\nint memo[300000][4];\nbool vis[300000][4];\nint dfs(int v,int eid){\n\teid++;\n\tif(memo[v][eid]!=-1) return memo[v][eid];\n\tif(vis[v][eid]){\n\t\tputs(\"Infinite\");\n\t\texit(1);\n\t}\n\tvis[v][eid]=1;\n\tint ret=0;\n\t// rep(i,G[v].size()) if(i!=eid-1){\n\t// \tedge& e=G[v][i];\n\t// \tchmax(ret,dfs(e.to,e.rev)+e.w);\n\t// }\n\tif(G[v].size()>0 && eid!=1) chmax(ret,dfs(G[v][0].to,G[v][0].rev)+G[v][0].w);\n\tif(G[v].size()>1 && eid!=2) chmax(ret,dfs(G[v][1].to,G[v][1].rev)+G[v][1].w);\n\tif(G[v].size()>2 && eid!=3) chmax(ret,dfs(G[v][2].to,G[v][2].rev)+G[v][2].w);\n\tmemo[v][eid]=ret;\n\treturn ret;\n}\n\nint rs[100001]={};\nint its[100000]={};\n\nint main(){\n\tBEGIN_STACK_EXTEND(512*1024*1024);\n\tint N,M;\n\tcin>>N>>M;\n\toG.resize(N);\n\trep(i,M){\n\t\tint x,y,w;\n\t\tscanf(\"%d %d %d\",&x,&y,&w);\n\t\tx--,y--;\n\t\tif(w==1){\n\t\t\toG[x].pb(edge{y,1,-1});\n\t\t}else{\n\t\t\tint X=oG[x].size(),Y=oG[y].size();\n\t\t\toG[x].pb(edge{y,1,Y});\n\t\t\toG[y].pb(edge{x,1,X});\n\t\t}\n\t}\n\tint newN=0;\n\trep(i,N){\n\t\tint sz=oG[i].size();\n\t\tif(sz==0) sz=1;\n\t\trs[i]=newN;\n\t\tits[i]=rs[i];\n\t\tnewN+=sz;\n\t}\n\trs[N]=newN;\n\tG.resize(newN);\n\trep(x,N){\n\t\tint n=rs[x+1]-rs[x];\n\t\tfor(int v=rs[x];v<rs[x]+n-1;v++) add_edge(v,v+1,0,2);\n\t\tfor(edge e: oG[x]){\n\t\t\tif(e.rev==-1){\t//one way\n\t\t\t\tadd_edge(its[x],rs[e.to],1,1);\n\t\t\t\tits[x]++;\n\t\t\t}else{\n\t\t\t\tif(x<e.to){\n\t\t\t\t\tadd_edge(its[x],its[e.to],1,2);\n\t\t\t\t\tits[x]++;\n\t\t\t\t\tits[e.to]++;\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t}\n\tint ans=0;\n\tN=newN;\n//\trep(i,N) assert(G[i].size()<=3);\n\trep(i,N) rep(j,4) memo[i][j]=-1;\n\trep(i,N) chmax(ans,dfs(i,-1));\n\tcout<<ans<<endl;\n\tEND_STACK_EXTEND;\n}"
  },
  {
    "language": "C++",
    "code": "#include<bits/stdc++.h>\nusing namespace std;\n#define MAX_N 100005\n#define MAX_M 100005\ntypedef pair<int,int> P;\n\nint n,m;\nvector<int> group[MAX_N];\n\nvector<int> G[MAX_N];\n\nint x[MAX_M],y[MAX_M],w[MAX_M];\n\nint id[MAX_N];\nbool visited[MAX_N];\n\nint c[MAX_N];\nvector<int> g[MAX_N];\nvector<int> vd;\n\nint dp[MAX_N];\n\nbool dfs(int pos,int prev,int root){\n  id[pos]=root;\n  visited[pos]=true;\n  group[root].push_back(pos);\n  \n  for(int to:G[pos]){\n    if(to==prev)continue;\n    if(visited[to])return true;\n    if(dfs(to,pos,root))return true;\n  }\n  return false;\n}\n\nbool check(){\n  map<P,bool> mp;\n  for(int i=0;i<m;i++){\n    if(w[i]==1)continue;\n    if(x[i]>y[i])swap(x[i],y[i]);\n    if(mp[ P(x[i],y[i]) ])return true;\n    mp[ P(x[i],y[i]) ]=true;\n  }\n    \n  memset(visited,false,sizeof(visited));\n  for(int i=0;i<n;i++){\n    if(visited[i])continue;\n    if( dfs(i,-1,i) )return true;\n  }\n\n\n  \n  for(int i=0;i<m;i++){\n    if(w[i]==2)continue;\n    int X=id[ x[i] ];\n    int Y=id[ y[i] ];\n    if(X==Y)continue;\n    g[X].push_back(Y);\n    c[Y]++;\n  }\n\n  queue<int> Q;\n  for(int i=0;i<n;i++){\n    if(c[i]==0){\n      Q.push(i);\n    }\n  }\n\n  while(!Q.empty()){\n    int pos=Q.front();Q.pop();\n    vd.push_back(pos);\n    for(int i=0;i<(int)g[pos].size();i++){\n      int to=g[pos][i];\n      c[to]--;\n      if(c[to]==0)Q.push(to);\n    }\n  }\n\n  for(int i=0;i<n;i++)\n    if(c[i]>0)return true;\n  \n  return false;\n}\n\nint d[MAX_N];\nvoid init(int root){\n  root=id[root];\n  for(int pos:group[root]){\n    d[pos]=-1;\n  }\n}\n\nvoid bfs(int root){\n  init(root);\n  queue<int> Q;\n  Q.push(root);\n  d[root]=0;\n  while(!Q.empty()){\n    int pos=Q.front();Q.pop();\n    for(int to:G[pos]){\n      if(d[to]!=-1)continue;\n      d[to]=d[pos]+1;\n      Q.push(to);\n    }\n  }\n}\n\nvoid update(int root,int dif){\n  for(int pos:group[root]){\n    for(int to:g[pos]){\n      dp[to]=max(dp[to],d[pos]+dif+1);\n    }\n  }\n}\n\nint solve(int root){\n  int res=0;\n  bfs(root);\n  int maxm=-1,maxmid;\n  for(int pos:group[root])\n    if(d[pos]+dp[pos]>maxm)maxm=d[pos]+dp[pos],maxmid=pos;\n  bfs(maxmid);\n  update(root,dp[maxmid]);\n  maxmid=-1;\n  for(int pos:group[root]){\n    if(d[pos]+dp[pos]>maxm)maxm=d[pos]+dp[pos],maxmid=pos;\n    res=max(res,d[pos]);\n  }\n  bfs(maxmid);\n  update(root,dp[maxmid]);\n  return res;\n}\n\nint main(){\n  scanf(\"%d %d\",&n,&m);\n  for(int i=0;i<m;i++){\n    scanf(\"%d %d %d\",&x[i],&y[i],&w[i]);\n    x[i]--,y[i]--;\n    \n    if(w[i]==2){\n      G[x[i]].push_back(y[i]);\n      G[y[i]].push_back(x[i]);\n    }\n  }\n  \n  if( check() ){\n    printf(\"Infinite\\n\");\n    return 0;\n  }\n\n  for(int i=0;i<n;i++){\n    g[i].clear();\n  }\n  for(int i=0;i<m;i++){\n    if(w[i]==1){\n      g[ x[i] ].push_back(y[i]);\n    }\n  }\n  \n  int ans=0;\n  \n  for(int root : vd ){\n    if(root!=id[root])continue;\n    ans=max(ans,solve(root));\n  }\n\n  for(int i=0;i<n;i++){\n    ans=max(ans,dp[i]);\n  }\n  printf(\"%d\\n\",ans);  \n  return 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include<bits/stdc++.h>\ntypedef long long int ll;\ntypedef unsigned long long int ull;\n#define BIG_NUM 2000000000\n#define HUGE_NUM 99999999999999999\n#define MOD 1000000007\n#define EPS 0.000000001\nusing namespace std;\n\n\n#define NUM 100005\n\nstruct GROUP{\n\tvector<int> nodes;\n};\n\nstruct Edge{\n\tEdge(int arg_to,bool arg_is_directed){\n\t\tto = arg_to;\n\t\tis_directed = arg_is_directed;\n\t}\n\tint to;\n\tbool is_directed;\n};\n\nstruct Info{\n\tInfo(int arg_node_id,int arg_adj_node){\n\t\tnode_id = arg_node_id;\n\t\tadj_node = arg_adj_node;\n\t}\n\tint node_id,adj_node;\n};\n\nstruct Data{\n\tData(){\n\t\tnode_id = 0;\n\t\tsum_cost = 0;\n\t}\n\tData(int arg_node_id,ll arg_sum_cost){\n\t\tnode_id = arg_node_id;\n\t\tsum_cost = arg_sum_cost;\n\t}\n\tbool operator<(const struct Data &arg) const{\n\t\treturn sum_cost < arg.sum_cost;\n\t}\n\n\tint node_id;\n\tll sum_cost;\n};\n\nint V,E;\nGROUP group[NUM];\nvector<Edge> G[NUM];\nvector<int> DAG_G[NUM];\nvector<int> rev_G[NUM];\nvector<Info> Connect[NUM];\nstack<int> S;\nbool check[NUM];\nint table[NUM],in_num[NUM];\nint group_index;\nll max_node_cost[NUM],in_max[NUM];\n\n\nvoid dfs(int node_id){\n\tcheck[node_id] = true;\n\n\tfor(int i = 0; i < G[node_id].size(); i++){\n\t\tif(!check[G[node_id][i].to])dfs(G[node_id][i].to);\n\t}\n\tS.push(node_id);\n}\n\nvoid reverse_dfs(int node_id){\n\tcheck[node_id] = true;\n\n\tgroup[group_index].nodes.push_back(node_id);\n\ttable[node_id] = group_index;\n\n\tfor(int i = 0; i < rev_G[node_id].size(); i++){\n\t\tif(!check[rev_G[node_id][i]])reverse_dfs(rev_G[node_id][i]);\n\t}\n}\n\nll dfs_first(int group_id,int node_id,int parent){\n\n\tll ret = in_max[node_id];\n\n\tfor(int i = 0; i < G[node_id].size(); i++){\n\t\tif(table[G[node_id][i].to] != group_id || G[node_id][i].to == parent)continue;\n\n\t\tret = max(ret,dfs_first(group_id,G[node_id][i].to,node_id)+1);\n\t}\n\treturn max_node_cost[node_id] = ret;\n}\n\nvoid dfs_to_descendant(int group_id,int node_id,int parent,ll sum_cost){\n\n\tmax_node_cost[node_id] = max(max_node_cost[node_id],sum_cost);\n\n\tll tmp_cost;\n\tpriority_queue<Data> Q;\n\n\tfor(int i = 0; i < G[node_id].size(); i++){\n\n\t\tif(table[G[node_id][i].to] != group_id || G[node_id][i].to == parent)continue;\n\n\t\tQ.push(Data(G[node_id][i].to,max_node_cost[G[node_id][i].to]+1));\n\t}\n\n\tif(Q.size() == 0){\n\n\t\ttmp_cost = max(sum_cost,in_max[node_id])+1;\n\n\t\tfor(int i = 0; i < G[node_id].size(); i++){\n\t\t\tif(table[G[node_id][i].to] != group_id || G[node_id][i].to == parent)continue;\n\t\t\tdfs_to_descendant(group_id,G[node_id][i].to,node_id,tmp_cost);\n\t\t}\n\n\t}else if(Q.size() == 1){\n\n\t\tData data1 = Q.top();\n\n\t\ttmp_cost = max(sum_cost,in_max[node_id])+1;\n\n\t\tfor(int i = 0; i < G[node_id].size(); i++){\n\n\t\t\tif(table[G[node_id][i].to] != group_id || G[node_id][i].to == parent)continue;\n\n\t\t\tif(G[node_id][i].to == data1.node_id){\n\n\t\t\t\tdfs_to_descendant(group_id,G[node_id][i].to,node_id,tmp_cost);\n\n\t\t\t}else{\n\n\t\t\t\tdfs_to_descendant(group_id,G[node_id][i].to,node_id,max(tmp_cost,data1.sum_cost+1));\n\t\t\t}\n\t\t}\n\n\t}else{\n\n\t\ttmp_cost = max(sum_cost,in_max[node_id])+1;\n\n\t\tData data1 = Q.top();\n\t\tQ.pop();\n\t\tData data2 = Q.top();\n\t\tQ.pop();\n\n\t\tfor(int i = 0; i < G[node_id].size(); i++){\n\n\t\t\tif(table[G[node_id][i].to] != group_id || G[node_id][i].to == parent)continue;\n\n\t\t\tif(G[node_id][i].to == data1.node_id){\n\n\t\t\t\tdfs_to_descendant(group_id,G[node_id][i].to,node_id,max(tmp_cost,data2.sum_cost+1));\n\n\t\t\t}else{\n\n\t\t\t\tdfs_to_descendant(group_id,G[node_id][i].to,node_id,max(tmp_cost,data1.sum_cost+1));\n\t\t\t}\n\n\t\t}\n\t}\n}\n\nvoid calc_cost(int group_id){\n\n\tint tmp_node,adj_node;\n\tfor(int i = 0; i < Connect[group_id].size(); i++){\n\n\t\ttmp_node = Connect[group_id][i].node_id;\n\t\tadj_node = Connect[group_id][i].adj_node;\n\n\t\tin_max[tmp_node] = max(in_max[tmp_node],max_node_cost[adj_node]+1);\n\t}\n\n\tdfs_first(group_id,group[group_id].nodes[0],-1);\n\n\tdfs_to_descendant(group_id,group[group_id].nodes[0],-1,0);\n}\n\nint main(){\n\n\tscanf(\"%d %d\",&V,&E);\n\tint from,to,command;\n\n\tfor(int loop = 0; loop < E; loop++){\n\n\t\tscanf(\"%d %d %d\",&from,&to,&command);\n\t\tfrom--;\n\t\tto--;\n\t\tif(command == 1){\n\n\t\t\tG[from].push_back(Edge(to,true));\n\t\t\trev_G[to].push_back(from);\n\n\t\t}else{\n\n\t\t\tG[from].push_back(Edge(to,false));\n\t\t\tG[to].push_back(Edge(from,false));\n\t\t\trev_G[from].push_back(to);\n\t\t\trev_G[to].push_back(from);\n\t\t}\n\t}\n\n\tfor(int i = 0; i < V; i++)check[i] = false;\n\n\tfor(int i = 0; i < V; i++){\n\t\tif(!check[i]){\n\t\t\tdfs(i);\n\t\t}\n\t}\n\n\tfor(int i = 0; i < V; i++)check[i] = false;\n\n\tgroup_index = 0;\n\twhile(!S.empty()){\n\t\tif(!check[S.top()]){\n\t\t\treverse_dfs(S.top());\n\t\t\tgroup_index++;\n\t\t}\n\t\tS.pop();\n\t}\n\n\tint node_num,edge_num;\n\tint tmp_node,next_group;\n\n\tfor(int i = 0; i < group_index; i++){\n\n\t\tnode_num = (int)group[i].nodes.size();\n\t\tedge_num = 0;\n\n\t\tfor(int k = 0; k < group[i].nodes.size(); k++){\n\n\t\t\ttmp_node = group[i].nodes[k];\n\n\t\t\tfor(int p = 0; p < G[tmp_node].size(); p++){\n\n\t\t\t\tnext_group = table[G[tmp_node][p].to];\n\t\t\t\tif(next_group == i){\n\n\t\t\t\t\tif(G[tmp_node][p].is_directed){\n\t\t\t\t\t\tprintf(\"Infinite\\n\");\n\t\t\t\t\t\treturn 0;\n\t\t\t\t\t}\n\t\t\t\t\tedge_num++;\n\n\t\t\t\t}else{\n\t\t\t\t\tDAG_G[i].push_back(next_group);\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\n\t\tedge_num /= 2;\n\n\t\tif(edge_num >= node_num){\n\t\t\tprintf(\"Infinite\\n\");\n\t\t\treturn 0;\n\t\t}\n\n\t\tfor(int k = 0; k < group[i].nodes.size(); k++){\n\n\t\t\ttmp_node = group[i].nodes[k];\n\n\t\t\tfor(int p = 0; p < rev_G[tmp_node].size(); p++){\n\n\t\t\t\tnext_group = table[rev_G[tmp_node][p]];\n\t\t\t\tif(next_group == i){\n\t\t\t\t\t//Do nothing\n\t\t\t\t}else{\n\t\t\t\t\tConnect[i].push_back(Info(tmp_node,rev_G[tmp_node][p]));\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t}\n\n\tfor(int i = 0; i < group_index; i++)in_num[i] = 0;\n\n\tfor(int i = 0; i < group_index; i++){\n\t\tsort(DAG_G[i].begin(),DAG_G[i].end());\n\t\tDAG_G[i].erase(unique(DAG_G[i].begin(),DAG_G[i].end()),DAG_G[i].end());\n\t\tfor(int k = 0; k < DAG_G[i].size(); k++){\n\t\t\tin_num[DAG_G[i][k]]++;\n\t\t}\n\t}\n\n\tfor(int i = 0; i < V; i++){\n\t\tmax_node_cost[i] = 0;\n\t\tin_max[i] = 0;\n\t}\n\n\tqueue<int> Q;\n\n\tfor(int i = 0; i < group_index; i++){\n\t\tif(in_num[i] == 0){\n\t\t\tQ.push(i);\n\t\t}\n\t}\n\n\tint tmp_group;\n\n\twhile(!Q.empty()){\n\n\t\ttmp_group = Q.front();\n\t\tQ.pop();\n\n\t\tcalc_cost(tmp_group);\n\n\t\tfor(int i = 0; i < DAG_G[tmp_group].size(); i++){\n\t\t\tin_num[DAG_G[tmp_group][i]] -= 1;\n\t\t\tif(in_num[DAG_G[tmp_group][i]] == 0){\n\t\t\t\tQ.push(DAG_G[tmp_group][i]);\n\t\t\t}\n\t\t}\n\t}\n\n\tll ans = 0;\n\tfor(int i = 0; i < V; i++){\n\t\tans = max(ans,max_node_cost[i]);\n\t}\n\n\tprintf(\"%lld\\n\",ans);\n\n\treturn 0;\n}\n\n"
  },
  {
    "language": "C++",
    "code": "#include<bits/stdc++.h>\nusing namespace std;\n#define MAX_N 100005\n#define MAX_M 100005\n  \nint n,m,ans;\nint x[MAX_M],y[MAX_M],w[MAX_M];\nvector<int> G[MAX_N];\nvector<int> g[MAX_N];\nvector<int> group[MAX_N];\nint id[MAX_N];\nbool visited[MAX_N];\nvector<int> vd;\nint dp[MAX_N];\nint d[MAX_N];\n  \nbool dfs(int pos,int prev,int root){\n  id[pos]=root;\n  visited[pos]=true;\n  group[root].push_back(pos);\n  for(int i=0;i<(int)G[pos].size();i++){\n    int to=G[pos][i];\n    if(to==prev)continue;\n    if(i&&to==G[pos][i-1])return true;\n    if(visited[to])return true;\n    if(dfs(to,pos,root))return true;\n  }\n  return false;\n}\n  \nbool check(){\n  memset(visited,false,sizeof(visited));\n  for(int i=0;i<n;i++)\n    if(!visited[i]&&dfs(i,-1,i))return true;\n  \n  vector<int> deg(n);\n  for(int pos=0;pos<n;pos++){\n    for(int i=0;i<(int)g[pos].size();i++){\n      int to=g[pos][i];\n      deg[ id[to] ]++;\n    }\n  }\n  \n  queue<int> Q;\n  for(int i=0;i<n;i++)\n    if(deg[i]==0&&id[i]==i)\n      Q.push(i);\n    \n  while(!Q.empty()){\n    int root=Q.front();Q.pop();\n    vd.push_back(root);\n    for(int i=0;i<(int)group[root].size();i++){\n      int pos=group[root][i];\n      for(int j=0;j<(int)g[pos].size();j++){\n        int to=g[pos][j];\n        deg[ id[to] ]--;\n        if(deg[ id[to] ]==0)Q.push(id[to]);\n      }\n    }\n  }\n  for(int i=0;i<n;i++)\n    if(deg[i]>0)return true;\n  return false;\n}\n  \nint solve(int S){\n  for(int i=0;i<(int)group[id[S]].size();i++){\n    int pos=group[id[S]][i];\n    d[pos]=-1;\n  }\n  queue<int> Q;\n  Q.push(S);\n  d[S]=0;\n  while(!Q.empty()){\n    int pos=Q.front();Q.pop();\n    for(int i=0;i<(int)G[pos].size();i++){\n      int to=G[pos][i];\n      if(d[to]!=-1)continue;\n      d[to]=d[pos]+1;\n      Q.push(to);\n    }\n  }\n  int res=S;\n  for(int i=0;i<(int)group[id[S]].size();i++){\n    int pos=group[id[S]][i];\n    if(d[pos]+dp[pos]>d[res]+dp[res])res=pos;\n    ans=max(ans,d[pos]+dp[S]);\n    for(int i=0;i<(int)g[pos].size();i++){\n      int to=g[pos][i];\n      dp[to]=max(dp[to],d[pos]+dp[S]+1);\n    }\n  }\n  return res;\n}\n  \nint main(){\n  scanf(\"%d %d\",&n,&m);\n  for(int i=0;i<m;i++){\n    scanf(\"%d %d %d\",&x[i],&y[i],&w[i]);\n    x[i]--,y[i]--;\n    if(w[i]==1){\n      g[x[i]].push_back(y[i]);\n    }\n    if(w[i]==2){\n      G[x[i]].push_back(y[i]);\n      G[y[i]].push_back(x[i]);\n    }\n  }\n  if(check()){\n    printf(\"Infinite\\n\");\n    return 0;\n  }\n  for(int i=0;i<(int)vd.size();i++){\n    int root=vd[i];\n    if(root==id[root])\n      solve(solve(solve(root)));\n  }\n  printf(\"%d\\n\",ans);  \n  return 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\n#define rep(i,N) for(int i=0;i<(int)N;i++)\n#define rep1(i,N) for(int i=1;i<=(int)N;i++)\n#define pb push_back\n#define all(c) c.begin(),c.end()\n#define show(x) cout<<#x<<\" \"<<x<<endl\n#define chmax(x,y) x=max(x,y)\n#define BEGIN_STACK_EXTEND(size) void * stack_extend_memory_ = malloc(size);void * stack_extend_origin_memory_;char * stack_extend_dummy_memory_ = (char*)alloca((1+(int)(((long long)stack_extend_memory_)&127))*16);*stack_extend_dummy_memory_ = 0;asm volatile(\"mov %%rsp, %%rbx\\nmov %%rax, %%rsp\":\"=b\"(stack_extend_origin_memory_):\"a\"((char*)stack_extend_memory_+(size)-1024));\n#define END_STACK_EXTEND asm volatile(\"mov %%rax, %%rsp\"::\"a\"(stack_extend_origin_memory_));free(stack_extend_memory_);\nusing namespace std;\nstruct edge {int to,w,rev;};\ntypedef vector< vector<edge> > Graph;\nGraph G,oG;\nvoid add_edge(int x,int y,int w,int way){\n\tif(way==1){\n\t\tG[x].pb({y,w,-1});\n\t}else{\n\t\tint X=G[x].size(),Y=G[y].size();\n\t\tG[x].pb({y,w,Y});\n\t\tG[y].pb({x,w,X});\n\t}\n}\n\ntypedef pair<int,int> P;\nmap<P,int> memo;\nset<P> vis;\nint dfs(int v,int eid){\n\tif(memo.count(P(v,eid))) return memo[P(v,eid)];\n\tif(vis.count(P(v,eid))){\n\t\tputs(\"Infinite\");\n\t\texit(1);\n\t}\n\tvis.insert(P(v,eid));\n\tint ret=0;\n\trep(i,G[v].size()) if(i!=eid){\n\t\tedge& e=G[v][i];\n\t\tchmax(ret,dfs(e.to,e.rev)+e.w);\n\t}\n\tmemo[P(v,eid)]=ret;\n\treturn ret;\n}\n\nint rs[100001]={};\nint its[100000]={};\n\nint main(){\n\tBEGIN_STACK_EXTEND(1024*1024);\n\texit(1);\n\tint N,M;\n\tcin>>N>>M;\n\toG.resize(N);\n\trep(i,M){\n\t\tint x,y,w;\n\t\tscanf(\"%d %d %d\",&x,&y,&w);\n\t\tx--,y--;\n\t\tif(w==1){\n\t\t\toG[x].pb(edge{y,1,-1});\n\t\t}else{\n\t\t\tint X=oG[x].size(),Y=oG[y].size();\n\t\t\toG[x].pb(edge{y,1,Y});\n\t\t\toG[y].pb(edge{x,1,X});\n\t\t}\n\t}\n\tint newN=0;\n\trep(i,N){\n\t\tint sz=oG[i].size();\n\t\tif(sz==0) sz=1;\n\t\trs[i]=newN;\n\t\tits[i]=rs[i];\n\t\tnewN+=sz;\n\t}\n\trs[N]=newN;\n\tG.resize(newN);\n\trep(x,N){\n\t\tint n=rs[x+1]-rs[x];\n\t\tfor(int v=rs[x];v<rs[x]+n-1;v++) add_edge(v,v+1,0,2);\n\t\tfor(edge e: oG[x]){\n\t\t\tif(e.rev==-1){\t//one way\n\t\t\t\tadd_edge(its[x],rs[e.to],1,1);\n\t\t\t\tits[x]++;\n\t\t\t}else{\n\t\t\t\tif(x<e.to){\n\t\t\t\t\tadd_edge(its[x],its[e.to],1,2);\n\t\t\t\t\tits[x]++;\n\t\t\t\t\tits[e.to]++;\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t}\n\tint ans=0;\n\tN=newN;\n\trep(i,N) chmax(ans,dfs(i,-1));\n\tcout<<ans<<endl;\n\tEND_STACK_EXTEND;\n}"
  },
  {
    "language": "C++",
    "code": "#include<bits/stdc++.h>\nusing namespace std;\n#define MAX_N 100005\n#define MAX_M 100005\ntypedef pair<int,int> P;\n\nint n,m;\nvector<int> group[MAX_N];\n\nvector<int> G[MAX_N];\n\nint x[MAX_M],y[MAX_M],w[MAX_M];\n\nint id[MAX_N];\nbool visited[MAX_N];\n\nint c[MAX_N];\nvector<int> g[MAX_N];\nvector<int> vd;\n\nint dp[MAX_N];\n\nbool dfs(int pos,int prev,int root){\n  id[pos]=root;\n  visited[pos]=true;\n  group[root].push_back(pos);\n  \n  for(int to:G[pos]){\n    if(to==prev)continue;\n    if(visited[to])return true;\n    if(dfs(to,pos,root))return true;\n  }\n  return false;\n}\n\nbool check(){\n  \n  memset(visited,false,sizeof(visited));\n  for(int i=0;i<n;i++){\n    if(visited[i])continue;\n    if( dfs(i,-1,i) )return true;\n  }\n\n\n  \n  for(int i=0;i<m;i++){\n    if(w[i]==2)continue;\n    int X=id[ x[i] ];\n    int Y=id[ y[i] ];\n    if(X==Y){\n      return true;\n    }\n    g[X].push_back(Y);\n    c[Y]++;\n  }\n\n  queue<int> Q;\n  for(int i=0;i<n;i++){\n    if(c[i]==0&&id[i]==i){\n      Q.push(i);\n    }\n  }\n\n  while(!Q.empty()){\n    int pos=Q.front();Q.pop();\n    vd.push_back(pos);\n    for(int to:g[pos]){\n      c[to]--;\n      if(c[to]==0)Q.push(to);\n    }\n  }\n\n  for(int i=0;i<n;i++)\n    if(c[i]>0)return true;\n  \n  return false;\n}\n\nint d[MAX_N];\nvoid init(int root){\n  root=id[root];\n  for(int pos:group[root]){\n    d[pos]=-1;\n  }\n}\n\nvoid bfs(int root){\n  init(root);\n  queue<int> Q;\n  Q.push(root);\n  d[root]=0;\n  while(!Q.empty()){\n    int pos=Q.front();Q.pop();\n    for(int to:G[pos]){\n      if(d[to]!=-1)continue;\n      d[to]=d[pos]+1;\n      Q.push(to);\n    }\n  }\n}\n\nvoid update(int root,int dif){\n  for(int pos:group[root]){\n    for(int to:g[pos]){\n      dp[to]=max(dp[to],d[pos]+dif+1);\n    }\n  }\n}\n\nint solve(int root){\n  int res=0;\n  bfs(root);\n  int maxm=-1,maxmid;\n  for(int pos:group[root])\n    if(d[pos]+dp[pos]>maxm)maxm=d[pos]+dp[pos],maxmid=pos;\n  \n  bfs(maxmid);\n  update(root,dp[maxmid]);\n  for(int pos:group[root])res=max(res,d[pos]+dp[maxmid]);\n  \n  maxm=-1;\n  for(int pos:group[root])\n    if(d[pos]+dp[pos]>maxm)maxm=d[pos]+dp[pos],maxmid=pos;\n\n  bfs(maxmid);\n  update(root,dp[maxmid]);\n  for(int pos:group[root])res=max(res,d[pos]+dp[maxmid]);\n  \n  return res;\n}\n\nint main(){\n  scanf(\"%d %d\",&n,&m);\n  for(int i=0;i<m;i++){\n    scanf(\"%d %d %d\",&x[i],&y[i],&w[i]);\n    x[i]--,y[i]--;\n    \n    if(w[i]==2){\n      G[x[i]].push_back(y[i]);\n      G[y[i]].push_back(x[i]);\n    }\n  }\n  \n  if( check() ){\n    printf(\"Infinite\\n\");\n    return 0;\n  }\n\n  for(int i=0;i<n;i++){\n    g[i].clear();\n  }\n  for(int i=0;i<m;i++){\n    if(w[i]==1){\n      g[ x[i] ].push_back(y[i]);\n    }\n  }\n  \n  int ans=0;\n  \n  for(int root : vd ){\n    if(root!=id[root])continue;\n    ans=max(ans,solve(root));\n  }\n  printf(\"%d\\n\",ans);  \n  return 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\n#define rep(i,N) for(int i=0;i<(int)N;i++)\n#define rep1(i,N) for(int i=1;i<=(int)N;i++)\n#define pb push_back\n#define all(c) c.begin(),c.end()\n#define show(x) cout<<#x<<\" \"<<x<<endl\n#define chmax(x,y) x=max(x,y)\n#define BEGIN_STACK_EXTEND(size) void * stack_extend_memory_ = malloc(size);void * stack_extend_origin_memory_;char * stack_extend_dummy_memory_ = (char*)alloca((1+(int)(((long long)stack_extend_memory_)&127))*16);*stack_extend_dummy_memory_ = 0;asm volatile(\"mov %%rsp, %%rbx\\nmov %%rax, %%rsp\":\"=b\"(stack_extend_origin_memory_):\"a\"((char*)stack_extend_memory_+(size)-1024));\n#define END_STACK_EXTEND asm volatile(\"mov %%rax, %%rsp\"::\"a\"(stack_extend_origin_memory_));free(stack_extend_memory_);\nusing namespace std;\nconst int MN=100000;\nstruct edge {int to,w,rev;};\ntypedef vector< vector<edge> > Graph;\nGraph G,oG;\nvoid add_edge(int x,int y,int w,int way){\n\tif(way==1){\n\t\tG[x].pb({y,w,-1});\n\t}else{\n\t\tint X=G[x].size(),Y=G[y].size();\n\t\tG[x].pb({y,w,Y});\n\t\tG[y].pb({x,w,X});\n\t}\n}\n\ntypedef pair<int,int> P;\nint memo[300000][4];\nbool vis[300000][4];\nint dfs(int v,int eid){\n\teid++;\n\tif(memo[v][eid]!=-1) return memo[v][eid];\n\tif(vis[v][eid]){\n\t\tputs(\"Infinite\");\n\t\texit(1);\n\t}\n\tvis[v][eid]=1;\n\tint ret=0;\n\t// rep(i,G[v].size()) if(i!=eid-1){\n\t// \tedge& e=G[v][i];\n\t// \tchmax(ret,dfs(e.to,e.rev)+e.w);\n\t// }\n\tif(G[v].size()>0 && eid!=1) chmax(ret,dfs(G[v][0].to,G[v][0].rev)+G[v][0].w);\n\tif(G[v].size()>1 && eid!=2) chmax(ret,dfs(G[v][1].to,G[v][1].rev)+G[v][1].w);\n\tif(G[v].size()>2 && eid!=3) chmax(ret,dfs(G[v][2].to,G[v][2].rev)+G[v][2].w);\n\tmemo[v][eid]=ret;\n\treturn ret;\n}\n\nint rs[100001]={};\nint its[100000]={};\n\nint main(){\n//\tBEGIN_STACK_EXTEND(512*1024*1024);\n\tint N,M;\n\tcin>>N>>M;\n\toG.resize(N);\n\trep(i,M){\n\t\tint x,y,w;\n\t\tscanf(\"%d %d %d\",&x,&y,&w);\n\t\tx--,y--;\n\t\tif(w==1){\n\t\t\toG[x].pb(edge{y,1,-1});\n\t\t}else{\n\t\t\tint X=oG[x].size(),Y=oG[y].size();\n\t\t\toG[x].pb(edge{y,1,Y});\n\t\t\toG[y].pb(edge{x,1,X});\n\t\t}\n\t}\n\tint newN=0;\n\trep(i,N){\n\t\tint sz=oG[i].size();\n\t\tif(sz==0) sz=1;\n\t\trs[i]=newN;\n\t\tits[i]=rs[i];\n\t\tnewN+=sz;\n\t}\n\trs[N]=newN;\n\tG.resize(newN);\n\trep(x,N){\n\t\tint n=rs[x+1]-rs[x];\n\t\tfor(int v=rs[x];v<rs[x]+n-1;v++) add_edge(v,v+1,0,2);\n\t\tfor(edge e: oG[x]){\n\t\t\tif(e.rev==-1){\t//one way\n\t\t\t\tadd_edge(its[x],rs[e.to],1,1);\n\t\t\t\tits[x]++;\n\t\t\t}else{\n\t\t\t\tif(x<e.to){\n\t\t\t\t\tadd_edge(its[x],its[e.to],1,2);\n\t\t\t\t\tits[x]++;\n\t\t\t\t\tits[e.to]++;\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t}\n\tint ans=0;\n\tN=newN;\n//\trep(i,N) assert(G[i].size()<=3);\n\trep(i,N) rep(j,4) memo[i][j]=-1;\n\trep(i,N) chmax(ans,dfs(i,-1));\n\tcout<<ans<<endl;\n//\tEND_STACK_EXTEND;\n}"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\n#define rep(i,N) for(int i=0;i<(int)N;i++)\n#define rep1(i,N) for(int i=1;i<=(int)N;i++)\n#define pb push_back\n#define all(c) c.begin(),c.end()\n#define show(x) cout<<#x<<\" \"<<x<<endl\n#define chmax(x,y) x=max(x,y)\n#define BEGIN_STACK_EXTEND(size) void * stack_extend_memory_ = malloc(size);void * stack_extend_origin_memory_;char * stack_extend_dummy_memory_ = (char*)alloca((1+(int)(((long long)stack_extend_memory_)&127))*16);*stack_extend_dummy_memory_ = 0;asm volatile(\"mov %%rsp, %%rbx\\nmov %%rax, %%rsp\":\"=b\"(stack_extend_origin_memory_):\"a\"((char*)stack_extend_memory_+(size)-1024));\n#define END_STACK_EXTEND asm volatile(\"mov %%rax, %%rsp\"::\"a\"(stack_extend_origin_memory_));free(stack_extend_memory_);\nusing namespace std;\nconst int MN=100000;\nstruct edge {int to,w,rev;};\ntypedef vector< vector<edge> > Graph;\nGraph G,oG;\nvoid add_edge(int x,int y,int w,int way){\n\tif(way==1){\n\t\tG[x].pb({y,w,-1});\n\t}else{\n\t\tint X=G[x].size(),Y=G[y].size();\n\t\tG[x].pb({y,w,Y});\n\t\tG[y].pb({x,w,X});\n\t}\n}\n\ntypedef pair<int,int> P;\nint memo[300000][4];\nbool vis[300000][4];\nint dfs(int v,int eid){\n\teid++;\n\tif(memo[v][eid]!=-1) return memo[v][eid];\n\tif(vis[v][eid]){\n\t\tputs(\"Infinite\");\n\t\texit(0);\n\t}\n\tvis[v][eid]=1;\n\tint ret=0;\n\t// rep(i,G[v].size()) if(i!=eid-1){\n\t// \tedge& e=G[v][i];\n\t// \tchmax(ret,dfs(e.to,e.rev)+e.w);\n\t// }\n\tif(G[v].size()>0 && eid!=1) chmax(ret,dfs(G[v][0].to,G[v][0].rev)+G[v][0].w);\n\tif(G[v].size()>1 && eid!=2) chmax(ret,dfs(G[v][1].to,G[v][1].rev)+G[v][1].w);\n\tif(G[v].size()>2 && eid!=3) chmax(ret,dfs(G[v][2].to,G[v][2].rev)+G[v][2].w);\n\tmemo[v][eid]=ret;\n\treturn ret;\n}\n\nint rs[100001]={};\nint its[100000]={};\n\nint main(){\n\tBEGIN_STACK_EXTEND(128*1024*1024);\n\tint N,M;\n\tcin>>N>>M;\n\toG.resize(N);\n\trep(i,M){\n\t\tint x,y,w;\n\t\tscanf(\"%d %d %d\",&x,&y,&w);\n\t\tx--,y--;\n\t\tif(w==1){\n\t\t\toG[x].pb(edge{y,1,-1});\n\t\t}else{\n\t\t\tint X=oG[x].size(),Y=oG[y].size();\n\t\t\toG[x].pb(edge{y,1,Y});\n\t\t\toG[y].pb(edge{x,1,X});\n\t\t}\n\t}\n\tint newN=0;\n\trep(i,N){\n\t\tint sz=oG[i].size();\n\t\tif(sz==0) sz=1;\n\t\trs[i]=newN;\n\t\tits[i]=rs[i];\n\t\tnewN+=sz;\n\t}\n\trs[N]=newN;\n\tG.resize(newN);\n\trep(x,N){\n\t\tint n=rs[x+1]-rs[x];\n\t\tfor(int v=rs[x];v<rs[x]+n-1;v++) add_edge(v,v+1,0,2);\n\t\tfor(edge e: oG[x]){\n\t\t\tif(e.rev==-1){\t//one way\n\t\t\t\tadd_edge(its[x],rs[e.to],1,1);\n\t\t\t\tits[x]++;\n\t\t\t}else{\n\t\t\t\tif(x<e.to){\n\t\t\t\t\tadd_edge(its[x],its[e.to],1,2);\n\t\t\t\t\tits[x]++;\n\t\t\t\t\tits[e.to]++;\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t}\n\tint ans=0;\n\tN=newN;\n//\trep(i,N) assert(G[i].size()<=3);\n\trep(i,N) rep(j,4) memo[i][j]=-1;\n\trep(i,N) chmax(ans,dfs(i,-1));\n\tcout<<ans<<endl;\n\tEND_STACK_EXTEND;\n}"
  },
  {
    "language": "C++",
    "code": "#include<bits/stdc++.h>\nusing namespace std;\n#define MAX_N 100005\n#define MAX_M 100005\ntypedef pair<int,int> P;\n\nint n,m;\nint x[MAX_M],y[MAX_M],w[MAX_M];\n\nvector<int> G[MAX_N];\nvector<int> g[MAX_N];\n\nvector<int> group[MAX_N];\nint id[MAX_N];\nbool visited[MAX_N];\nvector<int> vd;\n\nint dp[MAX_N];\n\nbool dfs(int pos,int prev,int root){\n  id[pos]=root;\n  visited[pos]=true;\n  group[root].push_back(pos);\n  for(int i=0;i<(int)G[pos].size();i++){\n    int to=G[pos][i];\n    if(to==prev)continue;\n    if(i&&to==G[pos][i-1])return true;\n    if(visited[to])return true;\n    if(dfs(to,pos,root))return true;\n  }\n  return false;\n}\n\nbool check(){\n  memset(visited,false,sizeof(visited));\n  for(int i=0;i<n;i++){\n    if(visited[i])continue;\n    if( dfs(i,-1,i) )return true;\n  }\n\n  vector< int > deg(n);\n  vector< vector<int> > graph(n);\n  \n  for(int i=0;i<m;i++){\n    if(w[i]==1){\n      int X=id[ x[i] ];\n      int Y=id[ y[i] ];\n      if(X==Y)return true;\n      graph[X].push_back(Y);\n      deg[Y]++;\n    }\n  }\n\n  queue<int> Q;\n  for(int i=0;i<n;i++)\n    if(deg[i]==0&&id[i]==i)\n      Q.push(i);\n\n  while(!Q.empty()){\n    int pos=Q.front();Q.pop();\n    vd.push_back(pos);\n    for(int to:graph[pos]){\n      deg[to]--;\n      if(deg[to]==0)Q.push(to);\n    }\n  }\n  \n  for(int i=0;i<n;i++)\n    if(deg[i]>0)return true;\n  \n  return false;\n}\n\nint d[MAX_N];\n\nvoid init(int root){\n  root=id[root];\n  for(int pos:group[root])\n    d[pos]=-1;\n}\n\nvoid bfs(int root){\n  init(root);\n  queue<int> Q;\n  Q.push(root);\n  d[root]=0;\n  while(!Q.empty()){\n    int pos=Q.front();Q.pop();\n    for(int to:G[pos]){\n      if(d[to]!=-1)continue;\n      d[to]=d[pos]+1;\n      Q.push(to);\n    }\n  }\n}\n\nvoid update(int root,int dif){\n  for(int pos:group[root])\n    for(int to:g[pos])\n      dp[to]=max(dp[to],d[pos]+dif+1);\n}\n\nint solve(int root){\n  int res=0;\n  bfs(root);\n  int maxm=-1,maxmid;\n  for(int pos:group[root])\n    if(d[pos]+dp[pos]>maxm)maxm=d[pos]+dp[pos],maxmid=pos;\n  \n  bfs(maxmid);\n  update(root,dp[maxmid]);\n  for(int pos:group[root])res=max(res,d[pos]+dp[maxmid]);\n  \n  maxm=-1;\n  for(int pos:group[root])\n    if(d[pos]+dp[pos]>maxm)maxm=d[pos]+dp[pos],maxmid=pos;\n\n  bfs(maxmid);\n  update(root,dp[maxmid]);\n  for(int pos:group[root])res=max(res,d[pos]+dp[maxmid]);\n  \n  return res;\n}\n\nint main(){\n  scanf(\"%d %d\",&n,&m);\n  for(int i=0;i<m;i++){\n    scanf(\"%d %d %d\",&x[i],&y[i],&w[i]);\n    x[i]--,y[i]--;\n    if(w[i]==1){\n      g[x[i]].push_back(y[i]);\n    }\n    if(w[i]==2){\n      G[x[i]].push_back(y[i]);\n      G[y[i]].push_back(x[i]);\n    }\n  }\n  \n  if( check() ){\n    printf(\"Infinite\\n\");\n    return 0;\n  }\n\n  int ans=0;\n  for(int root : vd ){\n    if(root!=id[root])continue;\n    ans=max(ans,solve(root));\n  }\n  printf(\"%d\\n\",ans);  \n  return 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include<bits/stdc++.h>\nusing namespace std;\n\n#define int long long\n\n#define rep(i,n) for(int i=0;i<(n);i++)\n#define pb push_back\n#define all(v) (v).begin(),(v).end()\n#define fi first\n#define se second\ntypedef vector<int>vint;\ntypedef pair<int,int>pint;\ntypedef vector<pint>vpint;\n\ntemplate<typename A,typename B>inline void chmin(A &a,B b){if(a>b)a=b;}\ntemplate<typename A,typename B>inline void chmax(A &a,B b){if(a<b)a=b;}\n\nint N,M;\n\nstruct UnionFindTree{\n    vector<int>par,sz;\n    UnionFindTree(int n){\n        par.resize(n);\n        sz.resize(n);\n        for(int i=0;i<n;i++){\n            par[i]=i;\n            sz[i]=1;\n        }\n    }\n    int find(int x){\n        return x==par[x]?x:par[x]=find(par[x]);\n    }\n    void unite(int x,int y){\n        x=find(x);y=find(y);\n        if(x==y)return;\n        if(sz[x]<sz[y])swap(x,y);\n        sz[x]+=sz[y];\n        par[y]=x;\n    }\n    bool areSame(int x,int y){\n        return find(x)==find(y);\n    }\n    int size(int x){\n        return sz[find(x)];\n    }\n};\nUnionFindTree uf(0);\n\nint dp[111111],dp2[111111];\nvint G[111111];\nvoid dfs(int v,int p,int r){\n    for(auto u:G[v]){\n        if(u==p)continue;\n        if(uf.find(u)!=r){\n            chmax(dp2[v],dp[u]+1);\n        }\n        else{\n            dfs(u,v,r);\n            chmax(dp2[v],dp2[u]+1);\n        }\n    }\n}\n\nvoid dfs2(int v,int p,int r,int x){\n    vint lis={x};\n    for(auto u:G[v]){\n        if(u==p)continue;\n        if(uf.find(u)==r){\n            lis.pb(dp2[u]+1);\n        }\n        else{\n            lis.pb(dp[u]+1);\n        }\n    }\n    sort(all(lis));reverse(all(lis));\n    dp[v]=lis[0];\n\n    for(auto u:G[v]){\n        if(u==p||uf.find(u)!=r)continue;\n        int xx;\n        if(lis[0]==dp2[u]+1)xx=lis[1];\n        else xx=lis[0];\n\n        dfs2(u,v,r,xx+1);\n    }\n}\n\nsigned main(){\n    cin>>N>>M;\n    vpint es,es2;\n\n    rep(i,M){\n        int a,b,w;\n        cin>>a>>b>>w;\n        a--;b--;\n        if(w==1)es.pb({a,b});\n        else es2.pb({a,b});\n    }\n\n    uf=UnionFindTree(N);\n    for(auto &p:es2){\n        if(uf.areSame(p.fi,p.se)){\n            cout<<\"Infinite\"<<endl;\n            return 0;\n        }\n        uf.unite(p.fi,p.se);\n    }\n\n\n    vector<vint>D(N);\n    vint deg(N);\n    for(auto &p:es){\n        D[uf.find(p.fi)].pb(uf.find(p.se));\n        deg[uf.find(p.se)]++;\n    }\n\n\n    vint ord;\n    rep(i,N)if(uf.find(i)==i&&deg[i]==0)ord.pb(i);\n    rep(i,ord.size()){\n        int v=ord[i];\n        for(auto u:D[v]){\n            if(--deg[u]==0)ord.pb(u);\n        }\n    }\n\n    if(count(all(deg),0)!=N){\n        cout<<\"Infinite\"<<endl;\n        return 0;\n    }\n\n\n    for(auto &p:es)G[p.fi].pb(p.se);\n    for(auto &p:es2)G[p.fi].pb(p.se),G[p.se].pb(p.fi);\n\n    for(int i=(int)ord.size()-1;i>=0;i--){\n        dfs(ord[i],-1,ord[i]);\n        dfs2(ord[i],-1,ord[i],0);\n    }\n\n    cout<<*max_element(dp,dp+N)<<endl;\n    return 0;\n}"
  },
  {
    "language": "C++",
    "code": "\n#include<bits/stdtr1c++.h>\nusing namespace std;\n#pragma gcc optimize(\"O3\")\n#define D(x)    cout << #x \" = \" << (x) << endl\n#define MAX     100001\n\nint counter;\n\nstruct directed_graph{\n    int n;\n    vector<int> edge[MAX+5];\n    vector<int> indx[MAX+5];\n\n    short int clr[MAX+5];\n    bool flag;\n\n    inline directed_graph(int _n = 0){\n        n = _n;\n    }\n\n    inline void addEdge(int u, int v){\n        edge[u].push_back(v);\n        indx[u].push_back(++counter);\n    }\n\n    inline void dfs(int idx)\n    {\n        if(clr[idx] == 1){\n            flag = true;\n            return;\n        }\n        if(flag == true) return;\n        if(clr[idx]) return;\n\n        clr[idx] = 1;\n        for(auto x : edge[idx])\n            dfs(x);\n\n        clr[idx] = 2;\n    }\n\n    inline bool hasCycle(){\n\n        flag = false;\n        memset(clr, 0, sizeof(clr));\n\n        for(int i = 1; i <= n; i++)\n            if(clr[i] == 0)\n                dfs(i);\n\n        return flag;\n    }\n\n} dg, cmpg;\n\n#define MAXLG       18\n#define MAXN        100001\n\nstruct undirected_graph{\n    int n, d[MAX+5];\n    vector<int> edge[MAX+5], indx[MAX+5];\n    bool vis[MAX+5];\n    bool flag;\n    int tab[MAXLG+2][MAXN+5];\n    int par[MAXN+5];\n    int lev[MAXN+5], stp;\n\n    inline undirected_graph(int _n = 0){\n        n = _n;\n        memset(d, -1, sizeof(d));\n    }\n\n    inline void addEdge(int u, int v){\n        edge[u].push_back(v);\n        indx[u].push_back(++counter);\n\n        edge[v].push_back(u);\n        indx[v].push_back(++counter);\n    }\n\n    inline int bfs(int idx)\n    {\n        int mx = 0, ret = idx;\n        queue<int> q;\n        d[idx] = 0;\n\n        q.push(idx);\n        while(!q.empty())\n        {\n            int u = q.front(); q.pop();\n            for(auto x : edge[u])\n                if(d[x] == -1)\n                {\n                    d[x] = d[u] + 1;\n                    q.push(x);\n                    if(d[x] > mx){\n                        mx = d[x];\n                        ret = x;\n                    }\n                }\n        }\n\n        return ret;\n    }\n\n    inline void init_st(int n)\n    {\n        int idx;\n        for(idx = 1; idx <= n; idx++)\n            tab[0][idx] = par[idx];\n\n        for(stp = 1; (1 << stp) < n; stp++)\n            for(int idx = 1; idx <= n; idx++)\n                if(tab[stp-1][idx] == -1) tab[stp][idx] = -1;\n                else tab[stp][idx] = tab[stp-1][tab[stp-1][idx]];\n        stp--;\n    }\n\n    inline int go(int cur, int gap, int pos)\n    {\n        if(!gap) return cur;\n        if(gap & 1) return go(tab[pos][cur], gap/2, pos+1);\n        return go(cur, gap/2, pos + 1);\n    }\n\n    inline int LCA(int u, int v)\n    {\n        if(lev[u] > lev[v]) swap(u, v);\n        v = go(v, lev[v] - lev[u], 0);\n        if(u == v) return v;\n\n        int i;\n        for(i = stp; i >= 0; i--)\n            if(tab[i][u] != tab[i][v])\n                u = tab[i][u], v = tab[i][v];\n\n        assert(tab[0][u] > 0);\n        return tab[0][u];\n    }\n\n    inline void dfs(int idx, int p, int lv)\n    {\n        lev[idx] = lv;\n        par[idx] = p;\n\n        for(auto x : edge[idx])\n            if(x == p) continue;\n            else dfs(x, idx, lv + 1);\n    }\n\n    inline int get_dist(int u, int v)\n    {\n        int _lca = LCA(u, v);\n        return d[u] + d[v] - 2 * d[_lca];\n    }\n\n    inline void generate_st(int rt)\n    {\n        memset(d, -1, sizeof(d));\n        bfs(rt);\n        dfs(rt, -1, 0);\n        init_st(n);\n    }\n\n} ug;\n\nint par[MAX+5], n;\nbool flag = false;\nvoid init(int n) {for(int i = 1; i <= n; i++) par[i] = i;}\ninline int find_par(int idx)\n{\n\twhile (par[idx] != idx){\n\t\tpar[idx] = par[par[par[idx] ] ];\n\t\tidx = par[idx];\n\t}\n\treturn par[idx];\n}\ninline void join(int u, int v)\n{\n    int pu = find_par(u);\n    int pv = find_par(v);\n    if(pu == pv)\n    {\n        flag = true;\n        return;\n    }\n    par[pu] = pv;\n    return;\n}\n\nbool vis[MAX+5];\nvector<int> farthest[MAX+5];\ntr1::unordered_map<long long , int > M;\nint dp[MAX << 5], glb;\n\ninline int F(int u, int v, int idx)\n{\n    //if(dp[idx] != -1) return dp[idx];\n\n    int ret = 0;\n    for(int i = 0; i < (int) dg.edge[v].size(); i++)\n    {\n        int x = dg.edge[v][i];\n        int ns = dg.indx[v][i];\n\n        if(x == u) continue;\n        else ret = max(ret, 1 + F(v, x, ns));\n    }\n\n    for(int i = 0; i < (int) ug.edge[v].size(); i++)\n    {\n        int x = ug.edge[v][i];\n        int ns = ug.indx[v][i];\n        if(x == u || x == n + 1) continue;\n        else ret = max(ret, 1 + F(v, x, ns));\n    }\n\n    return dp[idx] = ret;\n}\n\nint main()\n{\n    //freopen(\"in.txt\", \"r\", stdin);\n    int i, j, k, u, v, w, m;\n\n    scanf(\"%d %d\", &n, &m);\n\n    init(n);\n    ug = undirected_graph(n + 1);\n    dg = directed_graph(n);\n    cmpg = directed_graph(n);\n\n    for(i = 1; i <= m; i++)\n    {\n        scanf(\"%d %d %d\", &u, &v, &w);\n        if(w == 1) dg.addEdge(u, v);\n        if(w == 2)\n        {\n            ug.addEdge(u, v);\n            join(u, v);\n        }\n    }\n\n    for(i = 1; i <= n; i++)\n        for(auto x : dg.edge[i])\n            cmpg.addEdge(find_par(i), find_par(x));\n\n    if(flag || dg.hasCycle() || cmpg.hasCycle())\n    {\n        puts(\"Infinite\");\n        return 0;\n    }\n\n    for(i = 1; i <= n; i++)\n    {\n        int p = find_par(i);\n        if(vis[p]) continue;\n        vis[p] = true;\n\n        int x = ug.bfs(p);\n        int y = ug.bfs(x);\n\n        farthest[p].push_back(x);\n        if(x != y) farthest[p].push_back(y);\n    }\n\n    memset(vis, 0, sizeof(vis));\n    for(i = 1; i <= n; i++)\n    {\n        int p = find_par(i);\n        if(vis[p]) continue;\n        vis[p] = true;\n        ug.addEdge(n + 1, p);\n    }\n\n    memset(dp, -1,sizeof(dp));\n    ug.generate_st(n + 1);\n    int ans = 0;\n    for(i = 1; i <= n; i++)\n        ans = max(ans, F(n + 1, i, counter + i));\n\n    cout << ans << endl;\n    return 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\n\nusing namespace std;\n\nconst int INF = 1 << 29;\n\nstruct UnionFind\n{\n  vector< int > data;\n\n  UnionFind(int sz)\n  {\n    data.assign(sz, -1);\n  }\n\n  int find(int k)\n  {\n    return (data[k] < 0 ? k : data[k] = find(data[k]));\n  }\n\n  void unite(int x, int y)\n  {\n    x = find(x);\n    y = find(y);\n    if(data[x] > data[y]) swap(x, y);\n    data[x] += data[y];\n    data[y] = x;\n  }\n};\n\nvector< pair< int, int > > g[100000];\nvector< int > leftt[100000], rightt[100000], just[100000];\nvector< int > gg[100000], rgg[100000], order;\nbool v[100000];\nint cmp[100000];\n\n\nvoid dfs(int idx)\n{\n  if(v[idx]++) return;\n  for(auto &to : gg[idx]) dfs(to);\n  order.push_back(idx);\n}\n\nvoid rdfs(int idx, int k)\n{\n  cmp[idx] = k;\n  for(auto &to : rgg[idx]) if(cmp[to] == -1) rdfs(to, k);\n}\n\nint rec(int idx, int back = -1)\n{\n  if(back != -1) {\n    int tmp = max(leftt[idx][back], rightt[idx][back + 1]);\n    if(tmp != INF) return (tmp);\n  }\n  if(rightt[idx][0] == INF) {\n    for(int i = 0; i < g[idx].size(); i++) {\n      int to, rev;\n      tie(to, rev) = g[idx][i];\n      if(to == back || just[idx][i] != INF) continue;\n      just[idx][i] = rec(to, g[idx][i].second) + 1;\n    }\n    for(int i = 0; i < g[idx].size(); i++) {\n      leftt[idx][i + 1] = max(leftt[idx][i], just[idx][i]);\n    }\n    for(int i = (int) g[idx].size() - 1; i >= 0; i--) {\n      rightt[idx][i] = max(rightt[idx][i + 1], just[idx][i]);\n    }\n  }\n\n  if(back == -1) return (rightt[idx][0]);\n  return (max(leftt[idx][back], rightt[idx][back + 1]));\n}\n\n\nint main()\n{\n  int N, M;\n  vector< pair< int, int > > edges, arcs;\n\n  scanf(\"%d %d\", &N, &M);\n\n  UnionFind uf(N);\n\n  for(int i = 0; i < M; i++) {\n    int x, y, t;\n    cin >> x >> y >> t;\n    --x, --y;\n    if(t == 1) {\n      arcs.emplace_back(x, y);\n      g[x].emplace_back(y, -1);\n    } else {\n      if(uf.find(x) == uf.find(y)) {\n        cout << \"Infinite\" << endl;\n        return (0);\n      }\n      uf.unite(x, y);\n      edges.emplace_back(x, y);\n      g[y].emplace_back(x, g[x].size());\n      g[x].emplace_back(y, g[y].size() - 1);\n    }\n  }\n\n  {\n    for(auto &e : arcs) gg[uf.find(e.first)].push_back(uf.find(e.second));\n    for(auto &e : arcs) rgg[uf.find(e.second)].push_back(uf.find(e.first));\n    for(int i = 0; i < N; i++) dfs(i);\n    reverse(begin(order), end(order));\n    memset(cmp, -1, sizeof(cmp));\n    int kk = 0;\n    for(auto &i : order) if(cmp[i] == -1) rdfs(i, kk++);\n    if(kk != N) {\n      cout << \"Infinite\" << endl;\n      return (0);\n    }\n  }\n\n  int ret = 0;\n  for(int i = 0; i < N; i++) {\n    int sz = g[i].size();\n    just[i].assign(sz, INF);\n    leftt[i].assign(sz + 1, INF);\n    rightt[i].assign(sz + 1, INF);\n    leftt[i][0] = rightt[i][sz] = 0;\n  }\n  for(int i = 0; i < N; i++) ret = max(ret, rec(i));\n  cout << ret << endl;\n}"
  },
  {
    "language": "C++",
    "code": "#include<bits/stdc++.h>\nusing namespace std;\n#define MAX_N 100005\n#define MAX_M 100005\n\nint n,m,ans;\nint x[MAX_M],y[MAX_M],w[MAX_M];\nvector<int> G[MAX_N];\nvector<int> g[MAX_N];\nvector<int> group[MAX_N];\nint id[MAX_N];\nbool visited[MAX_N];\nvector<int> vd;\nint dp[MAX_N];\nint d[MAX_N];\n\nbool dfs(int pos,int prev,int root){\n  id[pos]=root;\n  visited[pos]=true;\n  group[root].push_back(pos);\n  for(int i=0;i<(int)G[pos].size();i++){\n    int to=G[pos][i];\n    if(to==prev)continue;\n    if(i&&to==G[pos][i-1])return true;\n    if(visited[to])return true;\n    if(dfs(to,pos,root))return true;\n  }\n  return false;\n}\n\nbool check(){\n  memset(visited,false,sizeof(visited));\n  for(int i=0;i<n;i++)\n    if(!visited[i]&&dfs(i,-1,i))return true;\n  vector< int > deg(n);\n  vector< vector<int> > graph(n);\n  for(int i=0;i<m;i++){\n    if(w[i]==1){\n      int X=id[ x[i] ];\n      int Y=id[ y[i] ];\n      if(X==Y)return true;\n      graph[X].push_back(Y);\n      deg[Y]++;\n    }\n  }\n  queue<int> Q;\n  for(int i=0;i<n;i++)\n    if(deg[i]==0&&id[i]==i)\n      Q.push(i);\n  while(!Q.empty()){\n    int pos=Q.front();Q.pop();\n    vd.push_back(pos);\n    for(int to:graph[pos]){\n      deg[to]--;\n      if(deg[to]==0)Q.push(to);\n    }\n  }\n  for(int i=0;i<n;i++)\n    if(deg[i]>0)return true;\n  return false;\n}\n\nint solve(int S){\n  for(int pos:group[id[S]])d[pos]=-1;\n  queue<int> Q;\n  Q.push(S);\n  d[S]=0;\n  while(!Q.empty()){\n    int pos=Q.front();Q.pop();\n    for(int to:G[pos]){\n      if(d[to]!=-1)continue;\n      d[to]=d[pos]+1;\n      Q.push(to);\n    }\n  }\n  int res=S;\n  for(int pos:group[id[S]]){\n    if(d[pos]+dp[pos]>d[res]+dp[res])res=pos;\n    ans=max(ans,d[pos]+dp[S]);\n    for(int to:g[pos])dp[to]=max(dp[to],d[pos]+dp[S]+1);\n  }\n  return res;\n}\n\nint main(){\n  scanf(\"%d %d\",&n,&m);\n  for(int i=0;i<m;i++){\n    scanf(\"%d %d %d\",&x[i],&y[i],&w[i]);\n    x[i]--,y[i]--;\n    if(w[i]==1){\n      g[x[i]].push_back(y[i]);\n    }\n    if(w[i]==2){\n      G[x[i]].push_back(y[i]);\n      G[y[i]].push_back(x[i]);\n    }\n  }\n  if(check()){\n    printf(\"Infinite\\n\");\n    return 0;\n  }\n  for(int root : vd )\n    if(root==id[root])\n      solve(solve(solve(root)));\n  printf(\"%d\\n\",ans);  \n  return 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include<stdio.h>\n#include<algorithm>\n#include<vector>\n#define N_ 901000\nusing namespace std;\nint n, m, Deg[N_], Q[N_], head, tail, D[N_], Res, cnt;\nint B1[N_], B2[N_];\nvector<int>E[N_], G[101000];\nvoid Make_Edge(int a, int b, int c){\n    E[a].push_back(b*2+c);\n}\nint main(){\n    int i, a, b, c, x, sz, j;\n    scanf(\"%d%d\",&n,&m);\n    cnt = 2*n;\n    for(i=1;i<=m;i++){\n        scanf(\"%d%d%d\",&a,&b,&c);\n        if(c==1){\n            Make_Edge(n+a,b,1);\n        }\n        else{\n            Make_Edge(cnt+1,cnt+4,1);\n            Make_Edge(cnt+3,cnt+2,1);\n            G[a].push_back(cnt+1);\n            G[b].push_back(cnt+3);\n            cnt+=4;\n        }\n    }\n    for(i=1;i<=n;i++){\n        Make_Edge(i,i+n,0);\n        sz = G[i].size();\n        if(!sz)continue;\n        B1[i] = cnt+1;\n        for(j=0;j<sz;j++){\n            cnt++;\n            Make_Edge(cnt,G[i][j],0);\n            if(j)Make_Edge(cnt, cnt-1,0);\n        }\n        B2[i] = cnt+1;\n        for(j=sz-1;j>=0;j--){\n            cnt++;\n            Make_Edge(cnt,G[i][j],0);\n            if(j!=sz-1)Make_Edge(cnt, cnt-1,0);\n        }\n        for(j=0;j<sz;j++){\n            Make_Edge(i,G[i][j],0);\n            Make_Edge(G[i][j]+1,n+i,0);\n            if(j)Make_Edge(G[i][j]+1, B1[i]+j-1,0);\n            if(j!=sz-1)Make_Edge(G[i][j]+1, B2[i]+sz-j-2,0);\n        }\n    }\n    for(i=1;i<=cnt;i++){\n        for(j=0;j<E[i].size();j++){\n            Deg[E[i][j]/2]++;\n        }\n    }\n    for(i=1;i<=cnt;i++){\n        if(!Deg[i])Q[++tail] = i;\n    }\n    while(head < tail){\n        x = Q[++head];\n        Res = max(Res, D[x]);\n        for(i=0;i<E[x].size();i++){\n            Deg[E[x][i]/2]--;\n            D[E[x][i]/2] = max(D[E[x][i]]/2, D[x] + E[x][i]%2);\n            if(!Deg[E[x][i]/2])Q[++tail] = E[x][i]/2;\n        }\n    }\n    if(tail != cnt){\n        printf(\"Infinite\\n\");\n        return 0;\n    }\n    printf(\"%d\\n\",Res);\n}"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\n\nusing namespace std;\n\nstruct UnionFind\n{\n  vector< int > data;\n\n  UnionFind(int sz)\n  {\n    data.assign(sz, -1);\n  }\n\n  int find(int k)\n  {\n    return (data[k] < 0 ? k : data[k] = find(data[k]));\n  }\n\n  void unite(int x, int y)\n  {\n    x = find(x);\n    y = find(y);\n    if(x == y) return;\n    if(data[x] > data[y]) swap(x, y);\n    data[x] += data[y];\n    data[y] = x;\n  }\n};\n\nstruct edge\n{\n  int to, type, idx;\n};\n\nint N, M;\nvector< edge > g[100000];\nint sz[100000], cmp[100000];\nbool v[100000];\nvector< int > G[100000], RG[100000], order;\n\nvoid dfs(int idx)\n{\n  if(v[idx]++) return;\n  for(auto &to : G[idx]) dfs(to);\n  order.push_back(idx);\n}\n\nvoid rdfs(int idx, int k)\n{\n  cmp[idx] = k;\n  for(auto &to : RG[idx]) if(cmp[to] == -1) rdfs(to, k);\n}\n\n\nvoid dfs2(int idx, int par)\n{\n  sz[idx] = 1;\n  for(auto &e : g[idx]) {\n    if(e.to == par) continue;\n    if(!e.type) {\n      dfs2(e.to, idx);\n      sz[idx] = max(sz[idx], sz[e.to] + 1);\n    }\n  }\n}\n\nint getUQ(vector< pair< int, int > > &s, int idx)\n{\n  if(s[0].second == idx) return (s[1].first);\n  return (s[0].first);\n}\n\n\nint rec(int idx, int par, int pardist)\n{\n  v[idx] = true;\n  vector< pair< int, int > > ei;\n  ei.emplace_back(pardist, -1);\n  for(auto &e : g[idx]) {\n    if(e.to == par) continue;\n    ei.emplace_back(e.type ? 0 : sz[e.to] + 1, e.to);\n  }\n  sort(ei.rbegin(), ei.rend());\n  int ret = pardist;\n  for(auto &e : g[idx]) {\n    if(e.to == par) continue;\n    if(e.type) ret = max(ret, rec(e.to, idx, getUQ(ei, e.to) + 1));\n  }\n  return (ret);\n}\n\nint main()\n{\n  scanf(\"%d %d\", &N, &M);\n  UnionFind tree(N);\n  for(int i = 0; i < M; i++) {\n    int X, Y, W;\n    scanf(\"%d %d %d\", &X, &Y, &W);\n    --X, --Y;\n    g[X].push_back((edge) {Y, 1, i});\n    g[Y].push_back((edge) {X, W == 2, i});\n    if(W == 1) {\n      G[X].push_back(Y);\n      RG[Y].push_back(X);\n    } else if(W == 2) {\n      if(tree.find(X) == tree.find(Y)) {\n        cout << \"Infinite\" << endl;\n        return (0);\n      }\n      tree.unite(X, Y);\n    }\n  }\n\n\n  for(int i = 0; i < N; i++) dfs(i);\n  reverse(begin(order), end(order));\n  int kk = 0;\n  memset(cmp, -1, sizeof(cmp));\n  for(auto &v: order) if(cmp[v] == -1) rdfs(v, kk++);\n  if(kk != N) {\n    cout << \"Infinite\" << endl;\n    return (0);\n  }\n\n\n  int ret = 0;\n  memset(v, false, sizeof(v));\n  for(int i = 0; i < N; i++) {\n    if(v[i]++) continue;\n    dfs2(i, -1);\n    ret = max(ret, rec(i, -1, 0));\n  }\n  printf(\"%d\\n\", ret);\n}"
  },
  {
    "language": "C++",
    "code": "#include<bits/stdc++.h>\nusing namespace std;\n#define MAX_N 100005\n#define MAX_M 100005\n\nint n,m;\nint x[MAX_M],y[MAX_M],w[MAX_M];\n\nvector<int> G[MAX_N];\nvector<int> g[MAX_N];\n\nvector<int> group[MAX_N];\nint id[MAX_N];\nbool visited[MAX_N];\nvector<int> vd;\n\nint dp[MAX_N];\n\nbool dfs(int pos,int prev,int root){\n  id[pos]=root;\n  visited[pos]=true;\n  group[root].push_back(pos);\n  for(int i=0;i<(int)G[pos].size();i++){\n    int to=G[pos][i];\n    if(to==prev)continue;\n    if(i&&to==G[pos][i-1])return true;\n    if(visited[to])return true;\n    if(dfs(to,pos,root))return true;\n  }\n  return false;\n}\n\nbool check(){\n  memset(visited,false,sizeof(visited));\n  for(int i=0;i<n;i++){\n    if(visited[i])continue;\n    if( dfs(i,-1,i) )return true;\n  }\n\n  vector< int > deg(n);\n  vector< vector<int> > graph(n);\n  \n  for(int i=0;i<m;i++){\n    if(w[i]==1){\n      int X=id[ x[i] ];\n      int Y=id[ y[i] ];\n      if(X==Y)return true;\n      graph[X].push_back(Y);\n      deg[Y]++;\n    }\n  }\n\n  queue<int> Q;\n  for(int i=0;i<n;i++)\n    if(deg[i]==0&&id[i]==i)\n      Q.push(i);\n\n  while(!Q.empty()){\n    int pos=Q.front();Q.pop();\n    vd.push_back(pos);\n    for(int to:graph[pos]){\n      deg[to]--;\n      if(deg[to]==0)Q.push(to);\n    }\n  }\n  \n  for(int i=0;i<n;i++)\n    if(deg[i]>0)return true;\n  \n  return false;\n}\n\nint d[MAX_N];\n\nvoid init(int root){\n  root=id[root];\n  for(int pos:group[root])\n    d[pos]=-1;\n}\n\nvoid bfs(int root){\n  init(root);\n  queue<int> Q;\n  Q.push(root);\n  d[root]=0;\n  while(!Q.empty()){\n    int pos=Q.front();Q.pop();\n    for(int to:G[pos]){\n      if(d[to]!=-1)continue;\n      d[to]=d[pos]+1;\n      Q.push(to);\n    }\n  }\n}\n\nvoid update(int root,int dif){\n  for(int pos:group[root])\n    for(int to:g[pos])\n      dp[to]=max(dp[to],d[pos]+dif+1);\n}\n\nint solve(int root,int &ans){\n  bfs(root);\n  update(root,dp[root]);\n  \n  int maxmid=root;\n  for(int pos:group[root])\n    if(d[pos]+dp[pos]>d[maxmid]+dp[maxmid])\n      maxmid=pos;\n  ans=max(ans,d[maxmid]+dp[maxmid]);\n  return maxmid;\n}\n\n  /*\n  int res=0;\n  bfs(root);\n  int maxm=-1,maxmid;\n  for(int pos:group[root])\n    if(d[pos]+dp[pos]>maxm)maxm=d[pos]+dp[pos],maxmid=pos;\n  \n  bfs(maxmid);\n  update(root,dp[maxmid]);\n  for(int pos:group[root])res=max(res,d[pos]+dp[maxmid]);\n  \n  maxm=-1;\n  for(int pos:group[root])\n    if(d[pos]+dp[pos]>maxm)maxm=d[pos]+dp[pos],maxmid=pos;\n\n  bfs(maxmid);\n  update(root,dp[maxmid]);\n  for(int pos:group[root])res=max(res,d[pos]+dp[maxmid]);\n  \n  return res;\n  */\n\n\nint main(){\n  scanf(\"%d %d\",&n,&m);\n  for(int i=0;i<m;i++){\n    scanf(\"%d %d %d\",&x[i],&y[i],&w[i]);\n    x[i]--,y[i]--;\n    if(w[i]==1){\n      g[x[i]].push_back(y[i]);\n    }\n    if(w[i]==2){\n      G[x[i]].push_back(y[i]);\n      G[y[i]].push_back(x[i]);\n    }\n  }\n  \n  if( check() ){\n    printf(\"Infinite\\n\");\n    return 0;\n  }\n\n  int ans=0;\n  for(int root : vd ){\n    if(root!=id[root])continue;\n    solve(solve(solve(root,ans),ans),ans);\n  }\n  printf(\"%d\\n\",ans);  \n  return 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include<bits/stdc++.h>\nusing namespace std;\n#define MAX_N 100005\n#define MAX_M 100005\n\nint n,m;\nint x[MAX_M],y[MAX_M],w[MAX_M];\n\nvector<int> G[MAX_N];\nvector<int> g[MAX_N];\n\nvector<int> group[MAX_N];\nint id[MAX_N];\nbool visited[MAX_N];\nvector<int> vd;\n\nint dp[MAX_N];\n\nbool dfs(int pos,int prev,int root){\n  id[pos]=root;\n  visited[pos]=true;\n  group[root].push_back(pos);\n  for(int i=0;i<(int)G[pos].size();i++){\n    int to=G[pos][i];\n    if(to==prev)continue;\n    if(i&&to==G[pos][i-1])return true;\n    if(visited[to])return true;\n    if(dfs(to,pos,root))return true;\n  }\n  return false;\n}\n\nbool check(){\n  memset(visited,false,sizeof(visited));\n  for(int i=0;i<n;i++){\n    if(visited[i])continue;\n    if( dfs(i,-1,i) )return true;\n  }\n\n  vector< int > deg(n);\n  vector< vector<int> > graph(n);\n  \n  for(int i=0;i<m;i++){\n    if(w[i]==1){\n      int X=id[ x[i] ];\n      int Y=id[ y[i] ];\n      if(X==Y)return true;\n      graph[X].push_back(Y);\n      deg[Y]++;\n    }\n  }\n\n  queue<int> Q;\n  for(int i=0;i<n;i++)\n    if(deg[i]==0&&id[i]==i)\n      Q.push(i);\n\n  while(!Q.empty()){\n    int pos=Q.front();Q.pop();\n    vd.push_back(pos);\n    for(int to:graph[pos]){\n      deg[to]--;\n      if(deg[to]==0)Q.push(to);\n    }\n  }\n  \n  for(int i=0;i<n;i++)\n    if(deg[i]>0)return true;\n  \n  return false;\n}\n\nint d[MAX_N];\n\nvoid init(int root){\n  root=id[root];\n  for(int pos:group[root])\n    d[pos]=-1;\n}\n\nvoid bfs(int S){\n  init(S);\n  queue<int> Q;\n  Q.push(S);\n  d[S]=0;\n  while(!Q.empty()){\n    int pos=Q.front();Q.pop();\n    for(int to:G[pos]){\n      if(d[to]!=-1)continue;\n      d[to]=d[pos]+1;\n      Q.push(to);\n    }\n  }\n}\n\nint solve(int S,int &ans){\n  bfs(S);\n  int res=S;\n  for(int pos:group[id[S]]){\n    if(d[pos]+dp[pos]>d[res]+dp[res])res=pos;\n    int D=d[pos]+dp[S]+1;\n    ans=max(ans,D);\n    for(int to:g[pos])dp[to]=max(dp[to],D);\n  }\n  return res;\n}\n\n  /*\n  int res=0;\n  bfs(root);\n  int maxm=-1,maxmid;\n  for(int pos:group[root])\n    if(d[pos]+dp[pos]>maxm)maxm=d[pos]+dp[pos],maxmid=pos;\n  \n  bfs(maxmid);\n  update(root,dp[maxmid]);\n  for(int pos:group[root])res=max(res,d[pos]+dp[maxmid]);\n  \n  maxm=-1;\n  for(int pos:group[root])\n    if(d[pos]+dp[pos]>maxm)maxm=d[pos]+dp[pos],maxmid=pos;\n\n  bfs(maxmid);\n  update(root,dp[maxmid]);\n  for(int pos:group[root])res=max(res,d[pos]+dp[maxmid]);\n  \n  return res;\n  */\n\n\nint main(){\n  scanf(\"%d %d\",&n,&m);\n  for(int i=0;i<m;i++){\n    scanf(\"%d %d %d\",&x[i],&y[i],&w[i]);\n    x[i]--,y[i]--;\n    if(w[i]==1){\n      g[x[i]].push_back(y[i]);\n    }\n    if(w[i]==2){\n      G[x[i]].push_back(y[i]);\n      G[y[i]].push_back(x[i]);\n    }\n  }\n  \n  if( check() ){\n    printf(\"Infinite\\n\");\n    return 0;\n  }\n\n  int ans=0;\n  for(int root : vd ){\n    if(root!=id[root])continue;\n    solve( solve( solve(root,ans) , ans ) , ans);\n  }\n  printf(\"%d\\n\",ans);  \n  return 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include<bits/stdc++.h>\nusing namespace std;\n#define MAX_N 100005\n#define MAX_M 100005\ntypedef pair<int,int> P;\n\nint n,m;\nvector<int> group[MAX_N];\n\nvector<int> G[MAX_N];\n\nint x[MAX_M],y[MAX_M],w[MAX_M];\n\nint id[MAX_N];\nbool visited[MAX_N];\n\nint c[MAX_N];\nvector<int> g[MAX_N];\nvector<int> vd;\n\nint dp[MAX_N];\n\nbool dfs(int pos,int prev,int root){\n  id[pos]=root;\n  visited[pos]=true;\n  group[root].push_back(pos);\n  \n  for(int to:G[pos]){\n    if(to==prev)continue;\n    if(visited[to])return true;\n    if(dfs(to,pos,root))return true;\n  }\n  return false;\n}\n\nbool check(){\n  map<P,bool> mp;\n  for(int i=0;i<m;i++){\n    if(w[i]==1)continue;\n    if(x[i]>y[i])swap(x[i],y[i]);\n    if(mp[ P(x[i],y[i]) ])return true;\n    mp[ P(x[i],y[i]) ]=true;\n  }\n    \n  memset(visited,false,sizeof(visited));\n  for(int i=0;i<n;i++){\n    if(visited[i])continue;\n    if( dfs(i,-1,i) )return true;\n  }\n\n\n  \n  for(int i=0;i<m;i++){\n    if(w[i]==2)continue;\n    int X=id[ x[i] ];\n    int Y=id[ y[i] ];\n    if(X==Y)continue;\n    g[X].push_back(Y);\n    c[Y]++;\n  }\n\n  queue<int> Q;\n  for(int i=0;i<n;i++){\n    if(c[i]==0){\n      Q.push(i);\n    }\n  }\n\n  while(!Q.empty()){\n    int pos=Q.front();Q.pop();\n    vd.push_back(pos);\n    for(int i=0;i<(int)g[pos].size();i++){\n      int to=g[pos][i];\n      c[to]--;\n      if(c[to]==0)Q.push(to);\n    }\n  }\n\n  for(int i=0;i<n;i++)\n    if(c[i]>0)return true;\n  \n  return false;\n}\n\nint d[MAX_N];\nvoid init(int root){\n  root=id[root];\n  for(int pos:group[root]){\n    d[pos]=-1;\n  }\n}\n\nvoid bfs(int root){\n  init(root);\n  queue<int> Q;\n  Q.push(root);\n  d[root]=0;\n  while(!Q.empty()){\n    int pos=Q.front();Q.pop();\n    for(int to:G[pos]){\n      if(d[to]!=-1)continue;\n      d[to]=d[pos]+1;\n      Q.push(to);\n    }\n  }\n}\n\nvoid update(int root,int dif){\n  for(int pos:group[root]){\n    for(int to:g[pos]){\n      dp[to]=max(dp[to],d[pos]+dif+1);\n    }\n  }\n}\n\nint solve(int root){\n  int res=0;\n  root=id[root];\n  bfs(root);\n  int maxm=-1,maxmid;\n  for(int pos:group[root])\n    if(d[pos]+dp[pos]>maxm)maxm=d[pos]+dp[pos],maxmid=pos;\n  bfs(maxmid);\n  update(root,dp[maxmid]);\n  maxmid=-1;\n  for(int pos:group[root]){\n    if(d[pos]+dp[pos]>maxm)maxm=d[pos]+dp[pos],maxmid=pos;\n    res=max(res,d[pos]);\n  }\n  bfs(maxmid);\n  update(root,dp[maxmid]);\n  return res;\n}\n\nint main(){\n  scanf(\"%d %d\",&n,&m);\n  for(int i=0;i<m;i++){\n    scanf(\"%d %d %d\",&x[i],&y[i],&w[i]);\n    x[i]--,y[i]--;\n    \n    if(w[i]==2){\n      G[x[i]].push_back(y[i]);\n      G[y[i]].push_back(x[i]);\n    }\n  }\n  \n  if( check() ){\n    printf(\"Infinite\\n\");\n    return 0;\n  }\n\n  for(int i=0;i<n;i++){\n    g[i].clear();\n  }\n  for(int i=0;i<m;i++){\n    if(w[i]==1){\n      g[ x[i] ].push_back(y[i]);\n    }\n  }\n  \n  int ans=0;\n  \n  for(int root : vd ){\n    ans=max(ans,solve(root));\n  }\n\n  for(int i=0;i<n;i++){\n    ans=max(ans,dp[i]);\n  }\n  printf(\"%d\\n\",ans);  \n  return 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include<bits/stdc++.h>\nusing namespace std;\n#define MAX_N 100005\n#define MAX_M 100005\n\nint n,m;\nint x[MAX_M],y[MAX_M],w[MAX_M];\n\nvector<int> G[MAX_N];\nvector<int> g[MAX_N];\n\nvector<int> group[MAX_N];\nint id[MAX_N];\nbool visited[MAX_N];\nvector<int> vd;\n\nint dp[MAX_N];\n\nbool dfs(int pos,int prev,int root){\n  id[pos]=root;\n  visited[pos]=true;\n  group[root].push_back(pos);\n  for(int i=0;i<(int)G[pos].size();i++){\n    int to=G[pos][i];\n    if(to==prev)continue;\n    if(i&&to==G[pos][i-1])return true;\n    if(visited[to])return true;\n    if(dfs(to,pos,root))return true;\n  }\n  return false;\n}\n\nbool check(){\n  memset(visited,false,sizeof(visited));\n  for(int i=0;i<n;i++){\n    if(visited[i])continue;\n    if( dfs(i,-1,i) )return true;\n  }\n\n  vector< int > deg(n);\n  vector< vector<int> > graph(n);\n  \n  for(int i=0;i<m;i++){\n    if(w[i]==1){\n      int X=id[ x[i] ];\n      int Y=id[ y[i] ];\n      if(X==Y)return true;\n      graph[X].push_back(Y);\n      deg[Y]++;\n    }\n  }\n\n  queue<int> Q;\n  for(int i=0;i<n;i++)\n    if(deg[i]==0&&id[i]==i)\n      Q.push(i);\n\n  while(!Q.empty()){\n    int pos=Q.front();Q.pop();\n    vd.push_back(pos);\n    for(int to:graph[pos]){\n      deg[to]--;\n      if(deg[to]==0)Q.push(to);\n    }\n  }\n  \n  for(int i=0;i<n;i++)\n    if(deg[i]>0)return true;\n  \n  return false;\n}\n\nint d[MAX_N];\n\nvoid init(int root){\n  root=id[root];\n  for(int pos:group[root])\n    d[pos]=-1;\n}\n\nvoid bfs(int S){\n  init(S);\n  queue<int> Q;\n  Q.push(S);\n  d[S]=0;\n  while(!Q.empty()){\n    int pos=Q.front();Q.pop();\n    for(int to:G[pos]){\n      if(d[to]!=-1)continue;\n      d[to]=d[pos]+1;\n      Q.push(to);\n    }\n  }\n}\n\nvoid update(int root,int dif){\n  for(int pos:group[root])\n    for(int to:g[pos])\n      dp[to]=max(dp[to],d[pos]+dif+1);\n}\n\nint solve(int S,int &ans){\n  bfs(S);\n  update(id[S],dp[S]);\n  \n  int maxmid=S;\n  for(int pos:group[root])\n    if(d[pos]+dp[pos]>d[maxmid]+dp[maxmid])\n      maxmid=pos;\n  ans=max(ans,d[maxmid]+dp[maxmid]);\n  return maxmid;\n}\n\n  /*\n  int res=0;\n  bfs(root);\n  int maxm=-1,maxmid;\n  for(int pos:group[root])\n    if(d[pos]+dp[pos]>maxm)maxm=d[pos]+dp[pos],maxmid=pos;\n  \n  bfs(maxmid);\n  update(root,dp[maxmid]);\n  for(int pos:group[root])res=max(res,d[pos]+dp[maxmid]);\n  \n  maxm=-1;\n  for(int pos:group[root])\n    if(d[pos]+dp[pos]>maxm)maxm=d[pos]+dp[pos],maxmid=pos;\n\n  bfs(maxmid);\n  update(root,dp[maxmid]);\n  for(int pos:group[root])res=max(res,d[pos]+dp[maxmid]);\n  \n  return res;\n  */\n\n\nint main(){\n  scanf(\"%d %d\",&n,&m);\n  for(int i=0;i<m;i++){\n    scanf(\"%d %d %d\",&x[i],&y[i],&w[i]);\n    x[i]--,y[i]--;\n    if(w[i]==1){\n      g[x[i]].push_back(y[i]);\n    }\n    if(w[i]==2){\n      G[x[i]].push_back(y[i]);\n      G[y[i]].push_back(x[i]);\n    }\n  }\n  \n  if( check() ){\n    printf(\"Infinite\\n\");\n    return 0;\n  }\n\n  int ans=0;\n  for(int root : vd ){\n    if(root!=id[root])continue;\n    solve(solve(solve(root,ans),ans),ans);\n  }\n  printf(\"%d\\n\",ans);  \n  return 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include<bits/stdc++.h>\nusing namespace std;\n#define MAX_N 100005\n#define MAX_M 100005\n \nint n,m,ans;\nint x[MAX_M],y[MAX_M],w[MAX_M];\nvector<int> G[MAX_N];\nvector<int> g[MAX_N];\nvector<int> group[MAX_N];\nint id[MAX_N];\nbool visited[MAX_N];\nvector<int> vd;\nint dp[MAX_N];\nint d[MAX_N];\n \nbool dfs(int pos,int prev,int root){\n  id[pos]=root;\n  visited[pos]=true;\n  group[root].push_back(pos);\n  for(int i=0;i<(int)G[pos].size();i++){\n    int to=G[pos][i];\n    if(to==prev)continue;\n    if(i&&to==G[pos][i-1])return true;\n    if(visited[to])return true;\n    if(dfs(to,pos,root))return true;\n  }\n  return false;\n}\n \nbool check(){\n  memset(visited,false,sizeof(visited));\n  for(int i=0;i<n;i++)\n    if(!visited[i]&&dfs(i,-1,i))return true;\n \n  vector<int> deg(n);\n  for(int pos=0;pos<n;pos++){\n    for(int i=0;i<(int)g[pos].size();i++){\n      int to=g[pos][i];\n      deg[ id[to] ]++;\n    }\n  }\n \n  queue<int> Q;\n  for(int i=0;i<n;i++)\n    if(deg[i]==0&&id[i]==i)\n      Q.push(i);\n   \n  while(!Q.empty()){\n    int root=Q.front();Q.pop();\n    vd.push_back(root);\n    for(int i=0;i<(int)group[root].size();i++){\n      int pos=group[root][i];\n      for(int j=0;j<(int)g[pos].size();j++){\n        int to=g[pos][j];\n        deg[ id[to] ]--;\n        if(deg[ id[to] ]==0)Q.push(id[to]);\n      }\n    }\n  }\n  for(int i=0;i<n;i++)\n    if(deg[i]>0)return true;\n  return false;\n}\n \nint solve(int S){\n  for(int i=0;i<(int)group[id[S]].size();i++){\n    int pos=group[id[S]][i];\n    d[pos]=-1;\n  }\n  queue<int> Q;\n  Q.push(S);\n  d[S]=0;\n  while(!Q.empty()){\n    int pos=Q.front();Q.pop();\n    for(int i=0;i<(int)G[pos].size();i++){\n      int to=G[pos][i];\n      if(d[to]!=-1)continue;\n      d[to]=d[pos]+1;\n      Q.push(to);\n    }\n  }\n  int res=S;\n  for(int i=0;i<(int)group[id[S]].size();i++){\n    int pos=group[id[S]][i];\n    if(d[pos]+dp[pos]>d[res]+dp[res])res=pos;\n    ans=max(ans,d[pos]+dp[S]);\n    for(int i=0;i<(int)g[pos].size();i++){\n      int to=g[pos][i];\n      dp[to]=max(dp[to],d[pos]+dp[S]+1);\n    }\n  }\n  return res;\n}\n \nint main(){\n  scanf(\"%d %d\",&n,&m);\n  for(int i=0;i<m;i++){\n    scanf(\"%d %d %d\",&x[i],&y[i],&w[i]);\n    x[i]--,y[i]--;\n    if(w[i]==1){\n      g[x[i]].push_back(y[i]);\n    }\n    if(w[i]==2){\n      G[x[i]].push_back(y[i]);\n      G[y[i]].push_back(x[i]);\n    }\n  }\n  if(check()){\n    printf(\"Infinite\\n\");\n    return 0;\n  }\n  for(int i=0;i<(int)vd.size();i++){\n    int root=vd[i];\n    if(root==id[root])\n      solve(solve(solve(root)));\n  }\n  printf(\"%d\\n\",ans);  \n  return 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include<stdio.h>\n#include<algorithm>\n#include<vector>\n#define N_ 1001000\nusing namespace std;\nint n, m, Deg[N_], Q[N_], head, tail, D[N_], Res, cnt;\nint B1[101000], B2[101000];\nvector<int>E[N_], G[101000];\nvoid Make_Edge(int a, int b, int c){\n    E[a].push_back(b*2+c);\n}\nint main(){\n    int i, a, b, c, x, sz, j;\n    scanf(\"%d%d\",&n,&m);\n    cnt = 2*n;\n    for(i=1;i<=m;i++){\n        scanf(\"%d%d%d\",&a,&b,&c);\n        if(c==1){\n            Make_Edge(n+a,b,1);\n        }\n        else{\n            Make_Edge(cnt+1,cnt+4,1);\n            Make_Edge(cnt+3,cnt+2,1);\n            G[a].push_back(cnt+1);\n            G[b].push_back(cnt+3);\n            cnt+=4;\n        }\n    }\n    for(i=1;i<=n;i++){\n        Make_Edge(i,i+n,0);\n        sz = G[i].size();\n        if(!sz)continue;\n        B1[i] = cnt+1;\n        for(j=0;j<sz;j++){\n            cnt++;\n            Make_Edge(cnt,G[i][j],0);\n            if(j)Make_Edge(cnt, cnt-1,0);\n        }\n        B2[i] = cnt+1;\n        for(j=sz-1;j>=0;j--){\n            cnt++;\n            Make_Edge(cnt,G[i][j],0);\n            if(j!=sz-1)Make_Edge(cnt, cnt-1,0);\n        }\n        for(j=0;j<sz;j++){\n            Make_Edge(i,G[i][j],0);\n            Make_Edge(G[i][j]+1,n+i,0);\n            if(j)Make_Edge(G[i][j]+1, B1[i]+j-1,0);\n            if(j!=sz-1)Make_Edge(G[i][j]+1, B2[i]+sz-j-2,0);\n        }\n    }\n    for(i=1;i<=cnt;i++){\n        for(j=0;j<E[i].size();j++){\n            Deg[E[i][j]/2]++;\n        }\n    }\n    for(i=1;i<=cnt;i++){\n        if(!Deg[i])Q[++tail] = i;\n    }\n    while(head < tail){\n        x = Q[++head];\n        Res = max(Res, D[x]);\n        for(i=0;i<E[x].size();i++){\n            Deg[E[x][i]/2]--;\n            D[E[x][i]/2] = max(D[E[x][i]/2], D[x] + E[x][i]%2);\n            if(!Deg[E[x][i]/2])Q[++tail] = E[x][i]/2;\n        }\n    }\n    if(tail != cnt){\n        printf(\"Infinite\\n\");\n        return 0;\n    }\n    printf(\"%d\\n\",Res);\n}"
  },
  {
    "language": "C++",
    "code": "#include<stdio.h>\n#include<algorithm>\n#include<vector>\n#define N_ 701000\nusing namespace std;\nint n, m, Deg[N_], Q[N_], head, tail, D[N_], Res, cnt;\nint B1[N_], B2[N_];\nvector<int>E[N_], G[101000];\nvoid Make_Edge(int a, int b, int c){\n    E[a].push_back(b*2+c);\n}\nint main(){\n    int i, a, b, c, x, sz, j;\n    scanf(\"%d%d\",&n,&m);\n    cnt = 2*n;\n    for(i=1;i<=m;i++){\n        scanf(\"%d%d%d\",&a,&b,&c);\n        if(c==1){\n            Make_Edge(n+a,b,1);\n        }\n        else{\n            Make_Edge(cnt+1,cnt+4,1);\n            Make_Edge(cnt+3,cnt+2,1);\n            G[a].push_back(cnt+1);\n            G[b].push_back(cnt+3);\n            cnt+=4;\n        }\n    }\n    for(i=1;i<=n;i++){\n        Make_Edge(i,i+n,0);\n        sz = G[i].size();\n        if(!sz)continue;\n        B1[i] = cnt+1;\n        for(j=0;j<sz;j++){\n            cnt++;\n            Make_Edge(cnt,G[i][j],0);\n            if(j)Make_Edge(cnt, cnt-1,0);\n        }\n        B2[i] = cnt+1;\n        for(j=sz-1;j>=0;j--){\n            cnt++;\n            Make_Edge(cnt,G[i][j],0);\n            if(j!=sz-1)Make_Edge(cnt, cnt-1,0);\n        }\n        for(j=0;j<sz;j++){\n            Make_Edge(i,G[i][j],0);\n            Make_Edge(G[i][j]+1,n+i,0);\n            if(j)Make_Edge(G[i][j]+1, B1[i]+j-1,0);\n            if(j!=sz-1)Make_Edge(G[i][j]+1, B2[i]+sz-j-2,0);\n        }\n    }\n    for(i=1;i<=cnt;i++){\n        for(j=0;j<E[i].size();j++){\n            Deg[E[i][j]/2]++;\n        }\n    }\n    for(i=1;i<=cnt;i++){\n        if(!Deg[i])Q[++tail] = i;\n    }\n    while(head < tail){\n        x = Q[++head];\n        Res = max(Res, D[x]);\n        for(i=0;i<E[x].size();i++){\n            Deg[E[x][i]/2]--;\n            D[E[x][i]/2] = max(D[E[x][i]]/2, D[x] + E[x][i]%2);\n            if(!Deg[E[x][i]/2])Q[++tail] = E[x][i]/2;\n        }\n    }\n    if(tail != cnt){\n        printf(\"Infinite\\n\");\n        return 0;\n    }\n    printf(\"%d\\n\",Res);\n}"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\n#define rep(i,N) for(int i=0;i<(int)N;i++)\n#define rep1(i,N) for(int i=1;i<=(int)N;i++)\n#define pb push_back\n#define all(c) c.begin(),c.end()\n#define show(x) cout<<#x<<\" \"<<x<<endl\n#define chmax(x,y) x=max(x,y)\n#define BEGIN_STACK_EXTEND(size) void * stack_extend_memory_ = malloc(size);void * stack_extend_origin_memory_;char * stack_extend_dummy_memory_ = (char*)alloca((1+(int)(((long long)stack_extend_memory_)&127))*16);*stack_extend_dummy_memory_ = 0;asm volatile(\"mov %%rsp, %%rbx\\nmov %%rax, %%rsp\":\"=b\"(stack_extend_origin_memory_):\"a\"((char*)stack_extend_memory_+(size)-1024));\n#define END_STACK_EXTEND asm volatile(\"mov %%rax, %%rsp\"::\"a\"(stack_extend_origin_memory_));free(stack_extend_memory_);\nusing namespace std;\nconst int MN=100000;\nstruct edge {int to,w,rev;};\ntypedef vector< vector<edge> > Graph;\nGraph G,oG;\nvoid add_edge(int x,int y,int w,int way){\n\tif(way==1){\n\t\tG[x].pb({y,w,-1});\n\t}else{\n\t\tint X=G[x].size(),Y=G[y].size();\n\t\tG[x].pb({y,w,Y});\n\t\tG[y].pb({x,w,X});\n\t}\n}\n\ntypedef pair<int,int> P;\nint memo[300000][4];\nbool vis[300000][4];\nint dfs(int v,int eid){\n\teid++;\n\tif(memo[v][eid]!=-1) return memo[v][eid];\n\tif(vis[v][eid]){\n\t\tputs(\"Infinite\");\n\t\texit(1);\n\t}\n\tvis[v][eid]=1;\n\tint ret=0;\n\t// rep(i,G[v].size()) if(i!=eid-1){\n\t// \tedge& e=G[v][i];\n\t// \tchmax(ret,dfs(e.to,e.rev)+e.w);\n\t// }\n\tif(G[v].size()>0 && eid!=1) chmax(ret,dfs(G[v][0].to,G[v][0].rev)+G[v][0].w);\n\tif(G[v].size()>1 && eid!=2) chmax(ret,dfs(G[v][1].to,G[v][1].rev)+G[v][1].w);\n\tif(G[v].size()>2 && eid!=3) chmax(ret,dfs(G[v][2].to,G[v][2].rev)+G[v][2].w);\n\tmemo[v][eid]=ret;\n\treturn ret;\n}\n\nint rs[100001]={};\nint its[100000]={};\n\nint main(){\n\tBEGIN_STACK_EXTEND(512*1024*1024);\n\tint N,M;\n\tcin>>N>>M;\n\toG.resize(N);\n\trep(i,M){\n\t\tint x,y,w;\n\t\tscanf(\"%d %d %d\",&x,&y,&w);\n\t\tx--,y--;\n\t\tif(w==1){\n\t\t\toG[x].pb(edge{y,1,-1});\n\t\t}else{\n\t\t\tint X=oG[x].size(),Y=oG[y].size();\n\t\t\toG[x].pb(edge{y,1,Y});\n\t\t\toG[y].pb(edge{x,1,X});\n\t\t}\n\t}\n\tint newN=0;\n\trep(i,N){\n\t\tint sz=oG[i].size();\n\t\tif(sz==0) sz=1;\n\t\trs[i]=newN;\n\t\tits[i]=rs[i];\n\t\tnewN+=sz;\n\t}\n\trs[N]=newN;\n\tG.resize(newN);\n\trep(x,N){\n\t\tint n=rs[x+1]-rs[x];\n\t\tfor(int v=rs[x];v<rs[x]+n-1;v++) add_edge(v,v+1,0,2);\n\t\tfor(edge e: oG[x]){\n\t\t\tif(e.rev==-1){\t//one way\n\t\t\t\tadd_edge(its[x],rs[e.to],1,1);\n\t\t\t\tits[x]++;\n\t\t\t}else{\n\t\t\t\tif(x<e.to){\n\t\t\t\t\tadd_edge(its[x],its[e.to],1,2);\n\t\t\t\t\tits[x]++;\n\t\t\t\t\tits[e.to]++;\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t}\n\tint ans=0;\n\tN=newN;\n//\trep(i,N) assert(G[i].size()<=3);\n\trep(i,N) rep(j,4) memo[i][j]=-1;\n\trep(i,N) chmax(ans,dfs(i,-1));\n\tcout<<ans<<endl;\n\tEND_STACK_EXTEND;\n}"
  },
  {
    "language": "C++",
    "code": "\n#include<bits/stdc++.h>\nusing namespace std;\n#define D(x)    cout << #x \" = \" << (x) << endl\n#define MAX     100001\n\nint counter;\n\nstruct directed_graph{\n    int n;\n    vector<int> edge[MAX+5];\n    vector<int> indx[MAX+5];\n    short int clr[MAX+5];\n    bool flag;\n\n    directed_graph(int _n = 0){\n        n = _n;\n    }\n\n    void addEdge(int u, int v){\n        edge[u].push_back(v);\n        indx[u].push_back(++counter);\n    }\n\n    void dfs(int idx)\n    {\n        if(clr[idx] == 1){\n            flag = true;\n            return;\n        }\n        if(flag == true) return;\n        if(clr[idx]) return;\n\n        clr[idx] = 1;\n        for(auto x : edge[idx])\n            dfs(x);\n\n        clr[idx] = 2;\n    }\n\n    bool hasCycle(){\n\n        flag = false;\n        memset(clr, 0, sizeof(clr));\n\n        for(int i = 1; i <= n; i++)\n            if(clr[i] == 0)\n                dfs(i);\n\n        return flag;\n    }\n\n} dg, cmpg;\n\n#define MAXLG       18\n#define MAXN        100001\n\nstruct undirected_graph{\n    int n, d[MAX+5];\n    vector<int> edge[MAX+5], indx[MAX+5];\n    bool vis[MAX+5];\n    bool flag;\n    int tab[MAXLG+2][MAXN+5];\n    int par[MAXN+5];\n    int lev[MAXN+5], stp;\n\n    undirected_graph(int _n = 0){\n        n = _n;\n        memset(d, -1, sizeof(d));\n    }\n\n    void addEdge(int u, int v){\n        edge[u].push_back(v);\n        edge[v].push_back(u);\n\n        indx[u].push_back(++counter);\n        indx[v].push_back(++counter);\n    }\n\n    int bfs(int idx)\n    {\n        int mx = 0, ret = idx;\n        queue<int> q;\n        d[idx] = 0;\n\n        q.push(idx);\n        while(!q.empty())\n        {\n            int u = q.front(); q.pop();\n            for(auto x : edge[u])\n                if(d[x] == -1)\n                {\n                    d[x] = d[u] + 1;\n                    q.push(x);\n                    if(d[x] > mx){\n                        mx = d[x];\n                        ret = x;\n                    }\n                }\n        }\n\n        return ret;\n    }\n\n    void init_st(int n)\n    {\n        int idx;\n        for(idx = 1; idx <= n; idx++)\n            tab[0][idx] = par[idx];\n\n        for(stp = 1; (1 << stp) < n; stp++)\n            for(int idx = 1; idx <= n; idx++)\n                if(tab[stp-1][idx] == -1) tab[stp][idx] = -1;\n                else tab[stp][idx] = tab[stp-1][tab[stp-1][idx]];\n        stp--;\n    }\n\n    int go(int cur, int gap, int pos)\n    {\n        if(!gap) return cur;\n        if(gap & 1) return go(tab[pos][cur], gap/2, pos+1);\n        return go(cur, gap/2, pos + 1);\n    }\n\n    int LCA(int u, int v)\n    {\n        if(lev[u] > lev[v]) swap(u, v);\n        v = go(v, lev[v] - lev[u], 0);\n        if(u == v) return v;\n\n        int i;\n        for(i = stp; i >= 0; i--)\n            if(tab[i][u] != tab[i][v])\n                u = tab[i][u], v = tab[i][v];\n\n        assert(tab[0][u] > 0);\n        return tab[0][u];\n    }\n\n    void dfs(int idx, int p, int lv)\n    {\n        lev[idx] = lv;\n        par[idx] = p;\n\n        for(auto x : edge[idx])\n            if(x == p) continue;\n            else dfs(x, idx, lv + 1);\n    }\n\n    int get_dist(int u, int v)\n    {\n        int _lca = LCA(u, v);\n        return d[u] + d[v] - 2 * d[_lca];\n    }\n\n    void generate_st(int rt)\n    {\n        memset(d, -1, sizeof(d));\n        bfs(rt);\n        dfs(rt, -1, 0);\n        init_st(n);\n    }\n\n} ug;\n\nint par[MAX+5], n;\nbool flag = false;\nvoid init(int n) {for(int i = 1; i <= n; i++) par[i] = i;}\nint find_par(int idx)\n{\n    if(par[idx] == idx) return idx;\n    return par[idx] = find_par(par[idx]);\n}\nvoid join(int u, int v)\n{\n    int pu = find_par(u);\n    int pv = find_par(v);\n    if(pu == pv)\n    {\n        flag = true;\n        return;\n    }\n    par[pu] = pv;\n    return;\n}\n\nbool vis[MAX+5];\nvector<int> farthest[MAX+5];\nmap< pair<int, int> , int > M;\nint dp[MAX << 4], glb;\n\nint F(int u, int v, int stt)\n{\n    if(dp[stt] != -1) return dp[stt];\n    int i_stt = stt;\n\n    int ret = 0;\n    for(int i = 0; i < (int) dg.edge[v].size(); i++)\n    {\n        int x = dg.edge[v][i];\n        stt = dg.indx[v][i];\n        if(x == u) continue;\n        else ret = max(ret, 1 + F(v, x, stt));\n    }\n\n    for(int i = 0; i <(int) ug.edge[v].size(); i++)\n    {\n        int x = ug.edge[v][i];\n        stt = ug.indx[v][i];\n        if(x == u || x == n + 1) continue;\n        else ret = max(ret, 1 + F(v, x, stt));\n    }\n\n    return dp[i_stt] = ret;\n}\n\nint main()\n{\n    //freopen(\"in.txt\", \"r\", stdin);\n    int i, j, k, u, v, w, m;\n\n    scanf(\"%d %d\", &n, &m);\n\n    init(n);\n    ug = undirected_graph(n + 1);\n    dg = directed_graph(n);\n    cmpg = directed_graph(n);\n\n    for(i = 1; i <= m; i++)\n    {\n        scanf(\"%d %d %d\", &u, &v, &w);\n        if(w == 1) dg.addEdge(u, v);\n        if(w == 2)\n        {\n            ug.addEdge(u, v);\n            join(u, v);\n        }\n    }\n\n    for(i = 1; i <= n; i++)\n        for(auto x : dg.edge[i])\n            cmpg.addEdge(find_par(i), find_par(x));\n\n    if(flag || dg.hasCycle() || cmpg.hasCycle())\n    {\n        puts(\"Infinite\");\n        return 0;\n    }\n\n    for(i = 1; i <= n; i++)\n    {\n        int p = find_par(i);\n        if(vis[p]) continue;\n        vis[p] = true;\n\n        int x = ug.bfs(p);\n        int y = ug.bfs(x);\n\n        farthest[p].push_back(x);\n        if(x != y) farthest[p].push_back(y);\n    }\n\n    memset(vis, 0, sizeof(vis));\n    for(i = 1; i <= n; i++)\n    {\n        int p = find_par(i);\n        if(vis[p]) continue;\n        vis[p] = true;\n        ug.addEdge(n + 1, p);\n    }\n\n    memset(dp, -1,sizeof(dp));\n    ug.generate_st(n + 1);\n    int ans = 0;\n    for(i = 1; i <= n; i++)\n        ans = max(ans, F(n + 1, i, counter + i));\n\n\n    cout << ans << endl;\n    return 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\n#define rep(i,n) for(int i=0;i<n;i++)\nusing namespace std;\n\ntypedef long long int64;\ntypedef pair<int,int> PII;\n\nint n,m;\n\nvector<PII> biEdge[123456];\nvector<int> uniEdge[123456];\n\nvector<int> nodes[123456];\n\nstruct Edge{\n\tint t,w;\n\tEdge(int t,int w):t(t),w(w){}\n};\n\nvector<Edge> edge[567891];\n\n//a vertex can reach all\n// <- <- <- nadj\n// -> -> -> nadj\n\nvoid addE(int u,int v,int w){\n\tedge[u].push_back(Edge(v,w));\n}\n\nint findNode(int u,int id,int tp){\n\tint pos = lower_bound(biEdge[u].begin(),biEdge[u].end(),make_pair(id,-1)) - biEdge[u].begin();\n\n\treturn nodes[u][2 + biEdge[u].size() * tp + pos];\n}\n\nint indeg[567891];\n\nint main(){\n\tcin>>n>>m;\n\n\trep(it,m){\n\t\tint u,v,w;\n\t\tscanf(\"%d%d%d\",&u,&v,&w);\n\t\t--u,--v;\n\n\t\tif(w==2){\n\t\t\tbiEdge[u].push_back(make_pair(it,v));\n\t\t\tbiEdge[v].push_back(make_pair(it,u));\n\t\t} else {\n\t\t\tuniEdge[u].push_back(v);\n\t\t}\n\t}\n\n\tint V = 0;\n\trep(i,n){\n\t\tnodes[i].push_back(V++); //in:0\n\t\tnodes[i].push_back(V++); //out:1\n\n\t\tsort(biEdge[i].begin(),biEdge[i].end());\n\n\t\trep(it,biEdge[i].size()){\n\t\t\tnodes[i].push_back(V++);\n\t\t\tnodes[i].push_back(V++);\n\t\t\tnodes[i].push_back(V++);\n\t\t}\n\n\t\tint m = biEdge[i].size();\n\n\t\trep(it,biEdge[i].size()){\n\t\t\tint lt = it + 2;\n\t\t\tint rt = m + it + 2;\n\t\t\tint ct = m * 2 + it + 2;\n\n\t\t\tif(it>0)\n\t\t\t\taddE(nodes[i][lt],nodes[i][lt-1],0);\n\t\t\tif(it+1<m)\n\t\t\t\taddE(nodes[i][rt],nodes[i][rt+1],0);\n\t\t}\n\t}\n\n\t//build edge\n\trep(i,n){\n\t\trep(it,uniEdge[i].size()){\n\t\t\tint v = uniEdge[i][it];//i->v\n\n\t\t\taddE(nodes[i][1],nodes[v][0],1);\n\t\t}\n\n\t\tint m = biEdge[i].size();\n\n\t\tif(m > 0){\n\t\t\trep(it,biEdge[i].size()){\n\t\t\t\tint lt = it + 2;\n\t\t\t\tint rt = m + it + 2;\n\t\t\t\tint ct = m * 2 + it + 2;\n\n\t\t\t\tif(it > 0){\n\t\t\t\t\tint id = biEdge[i][it-1].first;\n\t\t\t\t\tint v = biEdge[i][it-1].second;\n\n\t\t\t\t\taddE(nodes[i][lt],findNode(v,id,2),1);\n\t\t\t\t}\n\n\t\t\t\tif(it + 1 < m){\n\t\t\t\t\tint id = biEdge[i][it+1].first;\n\t\t\t\t\tint v = biEdge[i][it+1].second;\n\n\t\t\t\t\taddE(nodes[i][rt],findNode(v,id,2),1);\n\t\t\t\t}\n\n\t\t\t\taddE(nodes[i][ct],nodes[i][lt],0);\n\n\t\t\t\taddE(nodes[i][ct],nodes[i][rt],0);\n\n\t\t\t\taddE(nodes[i][ct],nodes[i][1],0);\n\t\t\t}\n\t\t\taddE(nodes[i][0],nodes[i][2+m],0);\n\t\t\t{\n\t\t\t\tint id = biEdge[i][0].first;\n\t\t\t\tint v = biEdge[i][0].second;\n\n\t\t\t\taddE(nodes[i][0],findNode(v,id,2),1);\n\t\t\t}\n\t\t}\n\n\t\taddE(nodes[i][0],nodes[i][1],0);\n\t}\n\n\t//graph built\n\trep(i,V){\n\t\trep(j,edge[i].size())\n\t\t\tindeg[edge[i][j].t]++;\n\t}\n\n\tstatic int que[567891],qh=0,qt=0;\n\n\trep(i,V) if(indeg[i]==0) que[qt++]=i;\n\n\twhile(qh<qt){\n\t\tint u = que[qh++];\n\t\trep(j,edge[u].size()){\n\t\t\tint v = edge[u][j].t;\n\t\t\tindeg[v]--;\n\t\t\tif(!indeg[v])\n\t\t\t\tque[qt++] = v;\n\t\t}\n\t}\n\n\tstatic int dp[567891];\n\n\tif(qt!=V){\n\t\tputs(\"Infinite\");\n\t} else {\n\t\trep(i,V){\n\t\t\tint u = que[V-1-i];\n\t\t\tdp[u]=0;\n\t\t\trep(j,edge[u].size()){\n\t\t\t\tint v = edge[u][j].t;\n\t\t\t\tdp[u] = max(dp[u],dp[v] + edge[u][j].w);\n\t\t\t}\n\t\t}\n\t\tint ans=*max_element(dp,dp+V);\n\t\tprintf(\"%d\\n\",ans);\n\t}\n}"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\n\nusing namespace std;\n\nconst int maxn = 1e5 + 50;\n\nint n , m ,  c[maxn] , dfn[maxn] , Fa[maxn] , HasCircle , dfs_clock , low[maxn] , scc_idx[maxn] , scc_tot;\nvector < int > G[maxn] , RG[maxn] , NormalEdge[maxn] , Edge[maxn] , BaseEdge[maxn];\nstack < int > stk;\nvector < pair < int , int > > fk;\n\nint Find_Fa( int u ){\n\treturn Fa[u] != u ? Fa[u] = Find_Fa( Fa[u] ) : u;\n}\n\nvoid DFS_Circle( int u ){\n\tlow[u] = dfn[u] = ++ dfs_clock;\n\tstk.push( u );\n\tfor(auto v : Edge[u]){\n\t\tif( !dfn[v] ){\n\t\t\tDFS_Circle( v );\n\t\t\tlow[u] = min( low[u] , low[v] );\n\t\t}else if( !scc_idx[v] )\n\t\t\tlow[u] = min( low[u] , dfn[v] );\n\t}\n\tif( low[u] == dfn[u] ){\n\t\tint x , cnt = 0;\n\t\t++ scc_tot;\n\t\twhile( 1 ){\n\t\t\t++ cnt;\n\t\t\tx = stk.top();stk.pop();\n\t\t\tscc_idx[x] = scc_tot;\n\t\t\tif( x == u )\n\t\t\t\tbreak;\n\t\t}\n\t\tHasCircle |= (cnt > 1);\n\t}\n}\n\nint f[maxn] , g[maxn] , dp1[maxn] , dp2[maxn] , vis[maxn] , deep[maxn] , ans; // f -> start[] , g -> end[]\n\nint DFS1( int u ){\n\tif(~f[u])\n\t\treturn f[u];\n\tf[u] = 0;\n\tfor(auto v : G[u])\n\t\tf[u] = max( f[u] , DFS1( v ) + 1 );\n\treturn f[u];\n}\n\nint DFS2( int u ){\n\tif(~g[u])\n\t\treturn g[u];\n\tg[u] = 0;\n\tfor(auto v : RG[u])\n\t\tg[u] = max( g[u] , DFS2( v ) + 1 );\n\treturn g[u];\n}\n\nvoid DFS( int u , int fa ){\n\tvis[u] = 1;\n\tdp1[u] = f[u] + deep[u] , dp2[u] = g[u] + deep[u];\n\tfor(auto v : NormalEdge[u]){\n\t\tif( v == fa )\n\t\t\tcontinue;\n\t\tdeep[v] = deep[u] + 1;\n\t\tDFS( v , u );\n\t\tans = max( ans , dp1[u] + dp2[v] - 2 * deep[u] );\n\t\tans = max( ans , dp1[v] + dp2[u] - 2 * deep[u] );\n\t\tdp1[u] = max( dp1[u] , dp1[v] );\n\t\tdp2[u] = max( dp2[u] , dp2[v] );\n\t}\n}\n\nmap < pair < int , int > , int > memory;\n\nint Gao( int u , int pre ){\n\tif( memory.count( make_pair( u , pre ) ) )\n\t\treturn memory[make_pair( u , pre ) ];\n\tint & ans = memory[make_pair( u , pre)] = 0;\n\tfor(auto v : BaseEdge[u]){\n\t\tif( v == pre )\n\t\t\tcontinue;\n\t\tans = max( ans , Gao( v , u ) + 1 );\n\t}\n\treturn ans;\n}\n\nint main( int argc , char * argv[] ){\n\tmemset( f , -1 , sizeof( f ) );\n\tmemset( g , -1 , sizeof( g ) );\n\tscanf( \"%d%d\" , & n , & m );\n\tfor(int i = 1 ; i <= n ; ++ i) Fa[i] = i;\n\tfor(int i = 1 ; i <= m ; ++ i){\n\t\tint u , v , w;\n\t\tscanf( \"%d%d%d\" , & u , & v , & w );\n\t\tBaseEdge[u].emplace_back( v );\n\t\tif( w == 2 ){\n\t\t\tBaseEdge[v].emplace_back( u );\n\t\t\tint p1 = Find_Fa( u ) , p2 = Find_Fa( v );\n\t\t\tif( p1 == p2 ){\n\t\t\t\tputs( \"Infinite\" );\n\t\t\t\treturn 0;\n\t\t\t}\n\t\t\tFa[p1] = p2;\n\t\t\tNormalEdge[u].emplace_back( v );\n\t\t\tNormalEdge[v].emplace_back( u );\n\t\t}\n\t\telse{\n\t\t\tfk.emplace_back( make_pair( u , v ) ) ;\n\t\t\tG[u].emplace_back( v );\n\t\t\tRG[v].emplace_back( u );\n\t\t}\n\t}\n\tfor(auto it : fk){\n\t\tif( Find_Fa( it.first ) == Find_Fa( it.second ) ){\n\t\t\tputs( \"Infinite\" );\n\t\t\treturn 0;\n\t\t}\n\t\tEdge[Find_Fa( it.first )].emplace_back( Find_Fa( it.second ) );\n\t}\n\tfor(int i = 1 ; i <= n ; ++ i)\n\t\tif( !dfn[i] )\n\t\t\tDFS_Circle( i );\n\tif( HasCircle ){\n\t\tputs( \"Infinite\" );\n\t\treturn 0;\n\t}\n\tfor(int i = 1 ; i <= n ; ++ i)\n\t\tans = max( ans , Gao( i , 0 ) );\n\tprintf( \"%d\\n\" , ans );\n\treturn 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include<bits/stdc++.h>\nusing namespace std;\n#define MAX_N 100005\n#define MAX_M 100005\n\nint n,m;\nint x[MAX_M],y[MAX_M],w[MAX_M];\n\nvector<int> G[MAX_N];\nvector<int> g[MAX_N];\n\nvector<int> group[MAX_N];\nint id[MAX_N];\nbool visited[MAX_N];\nvector<int> vd;\n\nint dp[MAX_N];\n\nbool dfs(int pos,int prev,int root){\n  id[pos]=root;\n  visited[pos]=true;\n  group[root].push_back(pos);\n  for(int i=0;i<(int)G[pos].size();i++){\n    int to=G[pos][i];\n    if(to==prev)continue;\n    if(i&&to==G[pos][i-1])return true;\n    if(visited[to])return true;\n    if(dfs(to,pos,root))return true;\n  }\n  return false;\n}\n\nbool check(){\n  memset(visited,false,sizeof(visited));\n  for(int i=0;i<n;i++){\n    if(visited[i])continue;\n    if( dfs(i,-1,i) )return true;\n  }\n\n  vector< int > deg(n);\n  vector< vector<int> > graph(n);\n  \n  for(int i=0;i<m;i++){\n    if(w[i]==1){\n      int X=id[ x[i] ];\n      int Y=id[ y[i] ];\n      if(X==Y)return true;\n      graph[X].push_back(Y);\n      deg[Y]++;\n    }\n  }\n\n  queue<int> Q;\n  for(int i=0;i<n;i++)\n    if(deg[i]==0&&id[i]==i)\n      Q.push(i);\n\n  while(!Q.empty()){\n    int pos=Q.front();Q.pop();\n    vd.push_back(pos);\n    for(int to:graph[pos]){\n      deg[to]--;\n      if(deg[to]==0)Q.push(to);\n    }\n  }\n  \n  for(int i=0;i<n;i++)\n    if(deg[i]>0)return true;\n  \n  return false;\n}\n\nint d[MAX_N];\n\nvoid init(int root){\n  root=id[root];\n  for(int pos:group[root])\n    d[pos]=-1;\n}\n\nvoid bfs(int S){\n  init(S);\n  queue<int> Q;\n  Q.push(S);\n  d[S]=0;\n  while(!Q.empty()){\n    int pos=Q.front();Q.pop();\n    for(int to:G[pos]){\n      if(d[to]!=-1)continue;\n      d[to]=d[pos]+1;\n      Q.push(to);\n    }\n  }\n}\n\nvoid update(int root,int dif){\n  for(int pos:group[root])\n    for(int to:g[pos])\n      dp[to]=max(dp[to],d[pos]+dif+1);\n}\n\nint solve(int S,int &ans){\n  bfs(S);\n  update(id[S],dp[S]);\n  \n  int maxmid=S;\n  for(int pos:group[ id[S] ])\n    if(d[pos]+dp[pos]>d[maxmid]+dp[maxmid])\n      maxmid=pos;\n  ans=max(ans,d[maxmid]+dp[maxmid]);\n  return maxmid;\n}\n\n  /*\n  int res=0;\n  bfs(root);\n  int maxm=-1,maxmid;\n  for(int pos:group[root])\n    if(d[pos]+dp[pos]>maxm)maxm=d[pos]+dp[pos],maxmid=pos;\n  \n  bfs(maxmid);\n  update(root,dp[maxmid]);\n  for(int pos:group[root])res=max(res,d[pos]+dp[maxmid]);\n  \n  maxm=-1;\n  for(int pos:group[root])\n    if(d[pos]+dp[pos]>maxm)maxm=d[pos]+dp[pos],maxmid=pos;\n\n  bfs(maxmid);\n  update(root,dp[maxmid]);\n  for(int pos:group[root])res=max(res,d[pos]+dp[maxmid]);\n  \n  return res;\n  */\n\n\nint main(){\n  scanf(\"%d %d\",&n,&m);\n  for(int i=0;i<m;i++){\n    scanf(\"%d %d %d\",&x[i],&y[i],&w[i]);\n    x[i]--,y[i]--;\n    if(w[i]==1){\n      g[x[i]].push_back(y[i]);\n    }\n    if(w[i]==2){\n      G[x[i]].push_back(y[i]);\n      G[y[i]].push_back(x[i]);\n    }\n  }\n  \n  if( check() ){\n    printf(\"Infinite\\n\");\n    return 0;\n  }\n\n  int ans=0;\n  for(int root : vd ){\n    if(root!=id[root])continue;\n    solve(solve(solve(root,ans),ans),ans);\n  }\n  printf(\"%d\\n\",ans);  \n  return 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include<bits/stdc++.h>\nusing namespace std;\n#define MAX_N 100005\n#define MAX_M 100005\ntypedef pair<int,int> P;\n\nint n,m;\nvector<int> group[MAX_N];\n\nvector<int> G[MAX_N];\n\nint x[MAX_M],y[MAX_M],w[MAX_M];\n\nint id[MAX_N];\nbool visited[MAX_N];\n\nint c[MAX_N];\nvector<int> g[MAX_N];\nvector<int> vd;\n\nint dp[MAX_N];\n\nbool dfs(int pos,int prev,int root){\n  id[pos]=root;\n  visited[pos]=true;\n  group[root].push_back(pos);\n  \n  for(int to:G[pos]){\n    if(to==prev)continue;\n    if(visited[to])return true;\n    if(dfs(to,pos,root))return true;\n  }\n  return false;\n}\n\nbool check(){\n  map<P,bool> mp;\n  for(int i=0;i<m;i++){\n    if(w[i]==1)continue;\n    if(x[i]>y[i])swap(x[i],y[i]);\n    if(mp[ P(x[i],y[i]) ])return true;\n    mp[ P(x[i],y[i]) ]=true;\n  }\n    \n  memset(visited,false,sizeof(visited));\n  for(int i=0;i<n;i++){\n    if(visited[i])continue;\n    if( dfs(i,-1,i) )return true;\n  }\n\n\n  \n  for(int i=0;i<m;i++){\n    if(w[i]==2)continue;\n    int X=id[ x[i] ];\n    int Y=id[ y[i] ];\n    if(X==Y){\n      return true;\n    }\n    g[X].push_back(Y);\n    c[Y]++;\n  }\n\n  queue<int> Q;\n  for(int i=0;i<n;i++){\n    if(c[i]==0&&id[i]==i){\n      Q.push(i);\n    }\n  }\n\n  while(!Q.empty()){\n    int pos=Q.front();Q.pop();\n    vd.push_back(pos);\n    for(int to:g[pos]){\n      c[to]--;\n      if(c[to]==0)Q.push(to);\n    }\n  }\n\n  for(int i=0;i<n;i++)\n    if(c[i]>0)return true;\n  \n  return false;\n}\n\nint d[MAX_N];\nvoid init(int root){\n  root=id[root];\n  for(int pos:group[root]){\n    d[pos]=-1;\n  }\n}\n\nvoid bfs(int root){\n  init(root);\n  queue<int> Q;\n  Q.push(root);\n  d[root]=0;\n  while(!Q.empty()){\n    int pos=Q.front();Q.pop();\n    for(int to:G[pos]){\n      if(d[to]!=-1)continue;\n      d[to]=d[pos]+1;\n      Q.push(to);\n    }\n  }\n}\n\nvoid update(int root,int dif){\n  for(int pos:group[root]){\n    for(int to:g[pos]){\n      dp[to]=max(dp[to],d[pos]+dif+1);\n    }\n  }\n}\n\nint solve(int root){\n  int res=0;\n  bfs(root);\n  int maxm=-1,maxmid;\n  for(int pos:group[root])\n    if(d[pos]+dp[pos]>maxm)maxm=d[pos]+dp[pos],maxmid=pos;\n  \n  bfs(maxmid);\n  update(root,dp[maxmid]);\n  for(int pos:group[root])res=max(res,d[pos]+dp[maxmid]);\n  \n  maxm=-1;\n  for(int pos:group[root])\n    if(d[pos]+dp[pos]>maxm)maxm=d[pos]+dp[pos],maxmid=pos;\n\n  bfs(maxmid);\n  update(root,dp[maxmid]);\n  for(int pos:group[root])res=max(res,d[pos]+dp[maxmid]);\n  \n  return res;\n}\n\nint main(){\n  scanf(\"%d %d\",&n,&m);\n  for(int i=0;i<m;i++){\n    scanf(\"%d %d %d\",&x[i],&y[i],&w[i]);\n    x[i]--,y[i]--;\n    \n    if(w[i]==2){\n      G[x[i]].push_back(y[i]);\n      G[y[i]].push_back(x[i]);\n    }\n  }\n  \n  if( check() ){\n    printf(\"Infinite\\n\");\n    return 0;\n  }\n\n  for(int i=0;i<n;i++){\n    g[i].clear();\n  }\n  for(int i=0;i<m;i++){\n    if(w[i]==1){\n      g[ x[i] ].push_back(y[i]);\n    }\n  }\n  \n  int ans=0;\n  \n  for(int root : vd ){\n    if(root!=id[root])continue;\n    ans=max(ans,solve(root));\n  }\n  printf(\"%d\\n\",ans);  \n  return 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include<bits/stdc++.h>\nusing namespace std;\n#define MAX_N 100005\n#define MAX_M 100005\n\nint n,m;\nint x[MAX_M],y[MAX_M],w[MAX_M];\n\nvector<int> G[MAX_N];\nvector<int> g[MAX_N];\n\nvector<int> group[MAX_N];\nint id[MAX_N];\nbool visited[MAX_N];\nvector<int> vd;\n\nint dp[MAX_N];\n\nbool dfs(int pos,int prev,int root){\n  id[pos]=root;\n  visited[pos]=true;\n  group[root].push_back(pos);\n  for(int i=0;i<(int)G[pos].size();i++){\n    int to=G[pos][i];\n    if(to==prev)continue;\n    if(i&&to==G[pos][i-1])return true;\n    if(visited[to])return true;\n    if(dfs(to,pos,root))return true;\n  }\n  return false;\n}\n\nbool check(){\n  memset(visited,false,sizeof(visited));\n  for(int i=0;i<n;i++){\n    if(visited[i])continue;\n    if( dfs(i,-1,i) )return true;\n  }\n\n  vector< int > deg(n);\n  vector< vector<int> > graph(n);\n  \n  for(int i=0;i<m;i++){\n    if(w[i]==1){\n      int X=id[ x[i] ];\n      int Y=id[ y[i] ];\n      if(X==Y)return true;\n      graph[X].push_back(Y);\n      deg[Y]++;\n    }\n  }\n\n  queue<int> Q;\n  for(int i=0;i<n;i++)\n    if(deg[i]==0&&id[i]==i)\n      Q.push(i);\n\n  while(!Q.empty()){\n    int pos=Q.front();Q.pop();\n    vd.push_back(pos);\n    for(int to:graph[pos]){\n      deg[to]--;\n      if(deg[to]==0)Q.push(to);\n    }\n  }\n  \n  for(int i=0;i<n;i++)\n    if(deg[i]>0)return true;\n  \n  return false;\n}\n\nint d[MAX_N];\n\nvoid init(int root){\n  root=id[root];\n  for(int pos:group[root])\n    d[pos]=-1;\n}\n\nvoid bfs(int S){\n  init(S);\n  queue<int> Q;\n  Q.push(S);\n  d[S]=0;\n  while(!Q.empty()){\n    int pos=Q.front();Q.pop();\n    for(int to:G[pos]){\n      if(d[to]!=-1)continue;\n      d[to]=d[pos]+1;\n      Q.push(to);\n    }\n  }\n}\n\nvoid update(int root,int dif){\n  for(int pos:group[root])\n    for(int to:g[pos])\n      dp[to]=max(dp[to],d[pos]+dif+1);\n}\n\nint solve(int S,int &ans){\n  bfs(S);\n  update(id[S],dp[S]);\n  \n  int maxmid=S;\n  for(int pos:group[ id[S] ])\n    if(d[pos]+dp[pos]>d[maxmid]+dp[maxmid])\n      maxmid=pos;\n  ans=max(ans,d[maxmid]+dp[maxmid]);\n  return maxmid;\n}\n\n  /*\n  int res=0;\n  bfs(root);\n  int maxm=-1,maxmid;\n  for(int pos:group[root])\n    if(d[pos]+dp[pos]>maxm)maxm=d[pos]+dp[pos],maxmid=pos;\n  \n  bfs(maxmid);\n  update(root,dp[maxmid]);\n  for(int pos:group[root])res=max(res,d[pos]+dp[maxmid]);\n  \n  maxm=-1;\n  for(int pos:group[root])\n    if(d[pos]+dp[pos]>maxm)maxm=d[pos]+dp[pos],maxmid=pos;\n\n  bfs(maxmid);\n  update(root,dp[maxmid]);\n  for(int pos:group[root])res=max(res,d[pos]+dp[maxmid]);\n  \n  return res;\n  */\n\n\nint main(){\n  scanf(\"%d %d\",&n,&m);\n  for(int i=0;i<m;i++){\n    scanf(\"%d %d %d\",&x[i],&y[i],&w[i]);\n    x[i]--,y[i]--;\n    if(w[i]==1){\n      g[x[i]].push_back(y[i]);\n    }\n    if(w[i]==2){\n      G[x[i]].push_back(y[i]);\n      G[y[i]].push_back(x[i]);\n    }\n  }\n  \n  if( check() ){\n    printf(\"Infinite\\n\");\n    return 0;\n  }\n\n  int ans=0;\n  for(int root : vd ){\n    if(root!=id[root])continue;\n    solve(solve(solve(root,ans),ans),ans);\n  }\n  printf(\"%d\\n\",ans);  \n  return 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\n#define rep(i,N) for(int i=0;i<(int)N;i++)\n#define rep1(i,N) for(int i=1;i<=(int)N;i++)\n#define pb push_back\n#define all(c) c.begin(),c.end()\n#define show(x) cout<<#x<<\" \"<<x<<endl\n#define chmax(x,y) x=max(x,y)\nusing namespace std;\nstruct edge {int to,w,rev;};\ntypedef vector< vector<edge> > Graph;\nGraph G,oG;\nvoid add_edge(int x,int y,int w,int way){\n\tif(way==1){\n\t\tG[x].pb({y,w,-1});\n\t}else{\n\t\tint X=G[x].size(),Y=G[y].size();\n\t\tG[x].pb({y,w,Y});\n\t\tG[y].pb({x,w,X});\n\t}\n}\n\ntypedef pair<int,int> P;\nmap<P,int> memo;\nset<P> vis;\nint dfs(int v,int eid){\n\tif(memo.count(P(v,eid))) return memo[P(v,eid)];\n\tif(vis.count(P(v,eid))){\n\t\tputs(\"Infinite\");\n\t\texit(1);\n\t}\n\tvis.insert(P(v,eid));\n\tint ret=0;\n\trep(i,G[v].size()) if(i!=eid){\n\t\tedge& e=G[v][i];\n\t\tchmax(ret,dfs(e.to,e.rev)+e.w);\n\t}\n\tmemo[P(v,eid)]=ret;\n\treturn ret;\n}\n\nint main(){\n\tint N,M;\n\tcin>>N>>M;\n\toG.resize(N);\n\trep(i,M){\n\t\tint x,y,w;\n\t\tscanf(\"%d %d %d\",&x,&y,&w);\n\t\tx--,y--;\n\t\tif(w==1){\n\t\t\toG[x].pb(edge{y,1,-1});\n\t\t}else{\n\t\t\tint X=oG[x].size(),Y=oG[y].size();\n\t\t\toG[x].pb(edge{y,1,Y});\n\t\t\toG[y].pb(edge{x,1,X});\n\t\t}\n\t}\n\tint rs[100001]={};\n\tint its[100000]={};\n\tint newN=0;\n\trep(i,N){\n\t\tint sz=oG[i].size();\n\t\tif(sz==0) sz=1;\n\t\trs[i]=newN;\n\t\tits[i]=rs[i];\n\t\tnewN+=sz;\n\t}\n\trs[N]=newN;\n\tG.resize(newN);\n\trep(x,N){\n\t\tint n=rs[x+1]-rs[x];\n\t\tfor(int v=rs[x];v<rs[x]+n-1;v++) add_edge(v,v+1,0,2);\n\t\tfor(edge e: oG[x]){\n\t\t\tif(e.rev==-1){\t//one way\n\t\t\t\tadd_edge(its[x],rs[e.to],1,1);\n\t\t\t\tits[x]++;\n\t\t\t}else{\n\t\t\t\tif(x<e.to){\n\t\t\t\t\tadd_edge(its[x],its[e.to],1,2);\n\t\t\t\t\tits[x]++;\n\t\t\t\t\tits[e.to]++;\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t}\n\tint ans=0;\n\tN=newN;\n\trep(i,N){\n\t\tchmax(ans,dfs(i,-1));\n\t}\n\tcout<<ans<<endl;\n}"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\n\nusing namespace std;\n\nconst int INF = 1 << 29;\n\nstruct UnionFind\n{\n  vector< int > data;\n\n  UnionFind(int sz)\n  {\n    data.assign(sz, -1);\n  }\n\n  int find(int k)\n  {\n    return (data[k] < 0 ? k : data[k] = find(data[k]));\n  }\n\n  void unite(int x, int y)\n  {\n    x = find(x);\n    y = find(y);\n    if(x == y) return;\n    if(data[x] > data[y]) swap(x, y);\n    data[x] += data[y];\n    data[y] = x;\n  }\n};\n\nvector< pair< int, int > > g[100001];\nvector< int > leftt[100001], rightt[100001], just[100001];\nvector< int > gg[100001], rgg[100001], order;\nbool v[100000];\nint cmp[100000];\n\n\nvoid dfs(int idx)\n{\n  if(v[idx]++) return;\n  for(auto &to : gg[idx]) dfs(to);\n  order.push_back(idx);\n}\n\nvoid rdfs(int idx, int k)\n{\n  cmp[idx] = k;\n  for(auto &to : rgg[idx]) if(cmp[to] == -1) rdfs(to, k);\n}\n\n\nint rec(int idx, int back = -1)\n{\n  if(back != -1) {\n    int tmp = max(leftt[idx][back], rightt[idx][back + 1]);\n    if(tmp != INF) return (tmp);\n  }\n  if(rightt[idx][0] == INF) {\n    for(int i = 0; i < g[idx].size(); i++) {\n      int to, rev;\n      tie(to, rev) = g[idx][i];\n      if(i == back) continue;\n      just[idx][i] = rec(to, rev) + 1;\n    }\n    for(int i = 0; i < g[idx].size(); i++) {\n      leftt[idx][i + 1] = max(leftt[idx][i], just[idx][i]);\n    }\n    for(int i = (int) g[idx].size() - 1; i >= 0; i--) {\n      rightt[idx][i] = max(rightt[idx][i + 1], just[idx][i]);\n    }\n  }\n  if(back == -1) return (rightt[idx][0]);\n  return (max(leftt[idx][back], rightt[idx][back + 1]));\n}\n\n\nint main()\n{\n  int N, M;\n  vector< pair< int, int > > edges, arcs;\n\n  scanf(\"%d %d\", &N, &M);\n\n  UnionFind uf(N);\n\n  for(int i = 0; i < M; i++) {\n    int x, y, t;\n    cin >> x >> y >> t;\n    --x, --y;\n    if(t == 1) {\n      arcs.emplace_back(x, y);\n      g[x].emplace_back(y, -1);\n    } else {\n      if(uf.find(x) == uf.find(y)) {\n        cout << \"Infinite\" << endl;\n        return (0);\n      }\n      uf.unite(x, y);\n      edges.emplace_back(x, y);\n      g[y].emplace_back(x, g[x].size());\n      g[x].emplace_back(y, g[y].size() - 1);\n    }\n  }\n\n  {\n    for(auto &e : arcs) {\n      gg[uf.find(e.first)].push_back(uf.find(e.second));\n      rgg[uf.find(e.second)].push_back(uf.find(e.first));\n    }\n    for(int i = 0; i < N; i++) dfs(i);\n    reverse(begin(order), end(order));\n    memset(cmp, -1, sizeof(cmp));\n    int kk = 0;\n    for(auto &i : order) if(cmp[i] == -1) rdfs(i, kk++);\n    if(kk != N) {\n      cout << \"Infinite\" << endl;\n      return (0);\n    }\n  }\n\n\n  int ret = 0;\n  for(int i = 0; i < N; i++) {\n    int sz = g[i].size();\n    just[i].assign(sz, INF);\n    leftt[i].assign(sz + 1, INF);\n    rightt[i].assign(sz + 1, INF);\n    leftt[i][0] = rightt[i][sz] = 0;\n  }\n  for(int i = 0; i < N; i++) ret = max(ret, rec(i));\n  cout << ret << endl;\n}"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\n#define rep(i,N) for(int i=0;i<(int)N;i++)\n#define rep1(i,N) for(int i=1;i<=(int)N;i++)\n#define pb push_back\n#define all(c) c.begin(),c.end()\n#define show(x) cout<<#x<<\" \"<<x<<endl\n#define chmax(x,y) x=max(x,y)\n#define BEGIN_STACK_EXTEND(size) void * stack_extend_memory_ = malloc(size);void * stack_extend_origin_memory_;char * stack_extend_dummy_memory_ = (char*)alloca((1+(int)(((long long)stack_extend_memory_)&127))*16);*stack_extend_dummy_memory_ = 0;asm volatile(\"mov %%rsp, %%rbx\\nmov %%rax, %%rsp\":\"=b\"(stack_extend_origin_memory_):\"a\"((char*)stack_extend_memory_+(size)-1024));\n#define END_STACK_EXTEND asm volatile(\"mov %%rax, %%rsp\"::\"a\"(stack_extend_origin_memory_));free(stack_extend_memory_);\nusing namespace std;\nstruct edge {int to,w,rev;};\ntypedef vector< vector<edge> > Graph;\nGraph G,oG;\nvoid add_edge(int x,int y,int w,int way){\n\tif(way==1){\n\t\tG[x].pb({y,w,-1});\n\t}else{\n\t\tint X=G[x].size(),Y=G[y].size();\n\t\tG[x].pb({y,w,Y});\n\t\tG[y].pb({x,w,X});\n\t}\n}\n\ntypedef pair<int,int> P;\nmap<P,int> memo;\nset<P> vis;\nint dfs(int v,int eid){\n\tif(memo.count(P(v,eid))) return memo[P(v,eid)];\n\tif(vis.count(P(v,eid))){\n\t\tputs(\"Infinite\");\n\t\texit(1);\n\t}\n\tvis.insert(P(v,eid));\n\tint ret=0;\n\trep(i,G[v].size()) if(i!=eid){\n\t\tedge& e=G[v][i];\n\t\tchmax(ret,dfs(e.to,e.rev)+e.w);\n\t}\n\tmemo[P(v,eid)]=ret;\n\treturn ret;\n}\n\nint rs[100001]={};\nint its[100000]={};\n\nint main(){\n\tBEGIN_STACK_EXTEND(1024*1024*1024);\n\texit(1);\n\tint N,M;\n\tcin>>N>>M;\n\toG.resize(N);\n\trep(i,M){\n\t\tint x,y,w;\n\t\tscanf(\"%d %d %d\",&x,&y,&w);\n\t\tx--,y--;\n\t\tif(w==1){\n\t\t\toG[x].pb(edge{y,1,-1});\n\t\t}else{\n\t\t\tint X=oG[x].size(),Y=oG[y].size();\n\t\t\toG[x].pb(edge{y,1,Y});\n\t\t\toG[y].pb(edge{x,1,X});\n\t\t}\n\t}\n\tint newN=0;\n\trep(i,N){\n\t\tint sz=oG[i].size();\n\t\tif(sz==0) sz=1;\n\t\trs[i]=newN;\n\t\tits[i]=rs[i];\n\t\tnewN+=sz;\n\t}\n\trs[N]=newN;\n\tG.resize(newN);\n\trep(x,N){\n\t\tint n=rs[x+1]-rs[x];\n\t\tfor(int v=rs[x];v<rs[x]+n-1;v++) add_edge(v,v+1,0,2);\n\t\tfor(edge e: oG[x]){\n\t\t\tif(e.rev==-1){\t//one way\n\t\t\t\tadd_edge(its[x],rs[e.to],1,1);\n\t\t\t\tits[x]++;\n\t\t\t}else{\n\t\t\t\tif(x<e.to){\n\t\t\t\t\tadd_edge(its[x],its[e.to],1,2);\n\t\t\t\t\tits[x]++;\n\t\t\t\t\tits[e.to]++;\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t}\n\tint ans=0;\n\tN=newN;\n\trep(i,N) chmax(ans,dfs(i,-1));\n\tcout<<ans<<endl;\n\tEND_STACK_EXTEND;\n}"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\n#define rep(i,N) for(int i=0;i<(int)N;i++)\n#define rep1(i,N) for(int i=1;i<=(int)N;i++)\n#define pb push_back\n#define all(c) c.begin(),c.end()\n#define show(x) cout<<#x<<\" \"<<x<<endl\n#define chmax(x,y) x=max(x,y)\n#define BEGIN_STACK_EXTEND(size) void * stack_extend_memory_ = malloc(size);void * stack_extend_origin_memory_;char * stack_extend_dummy_memory_ = (char*)alloca((1+(int)(((long long)stack_extend_memory_)&127))*16);*stack_extend_dummy_memory_ = 0;asm volatile(\"mov %%rsp, %%rbx\\nmov %%rax, %%rsp\":\"=b\"(stack_extend_origin_memory_):\"a\"((char*)stack_extend_memory_+(size)-1024));\n#define END_STACK_EXTEND asm volatile(\"mov %%rax, %%rsp\"::\"a\"(stack_extend_origin_memory_));free(stack_extend_memory_);\nusing namespace std;\nstruct edge {int to,w,rev;};\ntypedef vector< vector<edge> > Graph;\nGraph G,oG;\nvoid add_edge(int x,int y,int w,int way){\n\tif(way==1){\n\t\tG[x].pb({y,w,-1});\n\t}else{\n\t\tint X=G[x].size(),Y=G[y].size();\n\t\tG[x].pb({y,w,Y});\n\t\tG[y].pb({x,w,X});\n\t}\n}\n\ntypedef pair<int,int> P;\nmap<P,int> memo;\nset<P> vis;\nint dfs(int v,int eid){\n\tif(memo.count(P(v,eid))) return memo[P(v,eid)];\n\tif(vis.count(P(v,eid))){\n\t\tputs(\"Infinite\");\n\t\texit(1);\n\t}\n\tvis.insert(P(v,eid));\n\tint ret=0;\n\trep(i,G[v].size()) if(i!=eid){\n\t\tedge& e=G[v][i];\n\t\tchmax(ret,dfs(e.to,e.rev)+e.w);\n\t}\n\tmemo[P(v,eid)]=ret;\n\treturn ret;\n}\n\nint rs[100001]={};\nint its[100000]={};\n\nint main(){\n\tBEGIN_STACK_EXTEND(128*1024*1024);\n\texit(1);\n\tint N,M;\n\tcin>>N>>M;\n\toG.resize(N);\n\trep(i,M){\n\t\tint x,y,w;\n\t\tscanf(\"%d %d %d\",&x,&y,&w);\n\t\tx--,y--;\n\t\tif(w==1){\n\t\t\toG[x].pb(edge{y,1,-1});\n\t\t}else{\n\t\t\tint X=oG[x].size(),Y=oG[y].size();\n\t\t\toG[x].pb(edge{y,1,Y});\n\t\t\toG[y].pb(edge{x,1,X});\n\t\t}\n\t}\n\tint newN=0;\n\trep(i,N){\n\t\tint sz=oG[i].size();\n\t\tif(sz==0) sz=1;\n\t\trs[i]=newN;\n\t\tits[i]=rs[i];\n\t\tnewN+=sz;\n\t}\n\trs[N]=newN;\n\tG.resize(newN);\n\trep(x,N){\n\t\tint n=rs[x+1]-rs[x];\n\t\tfor(int v=rs[x];v<rs[x]+n-1;v++) add_edge(v,v+1,0,2);\n\t\tfor(edge e: oG[x]){\n\t\t\tif(e.rev==-1){\t//one way\n\t\t\t\tadd_edge(its[x],rs[e.to],1,1);\n\t\t\t\tits[x]++;\n\t\t\t}else{\n\t\t\t\tif(x<e.to){\n\t\t\t\t\tadd_edge(its[x],its[e.to],1,2);\n\t\t\t\t\tits[x]++;\n\t\t\t\t\tits[e.to]++;\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t}\n\tint ans=0;\n\tN=newN;\n\trep(i,N) chmax(ans,dfs(i,-1));\n\tcout<<ans<<endl;\n\tEND_STACK_EXTEND;\n}"
  },
  {
    "language": "C++",
    "code": "#include<bits/stdc++.h>\nusing namespace std;\n#define MAX_N 100005\n#define MAX_M 100005\ntypedef pair<int,int> P;\n\nint n,m;\nvector<int> group[MAX_N];\n\nvector<int> G[MAX_N];\n\nint x[MAX_M],y[MAX_M],w[MAX_M];\n\nint id[MAX_N];\nbool visited[MAX_N];\n\nint c[MAX_N];\nvector<int> g[MAX_N];\nvector<int> vd;\n\nint dp[MAX_N];\n\nbool dfs(int pos,int prev,int root){\n  id[pos]=root;\n  visited[pos]=true;\n  group[root].push_back(pos);\n  \n  for(int to:G[pos]){\n    if(to==prev)continue;\n    if(visited[to])return true;\n    if(dfs(to,pos,root))return true;\n  }\n  return false;\n}\n\nbool check(){\n  map<P,bool> mp;\n  for(int i=0;i<m;i++){\n    if(w[i]==1)continue;\n    if(x[i]>y[i])swap(x[i],y[i]);\n    if(mp[ P(x[i],y[i]) ])return true;\n    mp[ P(x[i],y[i]) ]=true;\n  }\n    \n  memset(visited,false,sizeof(visited));\n  for(int i=0;i<n;i++){\n    if(visited[i])continue;\n    if( dfs(i,-1,i) )return true;\n  }\n\n\n  \n  for(int i=0;i<m;i++){\n    if(w[i]==2)continue;\n    int X=id[ x[i] ];\n    int Y=id[ y[i] ];\n    if(X==Y){\n      return true;\n    }\n    g[X].push_back(Y);\n    c[Y]++;\n  }\n\n  queue<int> Q;\n  for(int i=0;i<n;i++){\n    if(c[i]==0){\n      Q.push(i);\n    }\n  }\n\n  while(!Q.empty()){\n    int pos=Q.front();Q.pop();\n    vd.push_back(pos);\n    for(int to:g[pos]){\n      c[to]--;\n      if(c[to]==0)Q.push(to);\n    }\n  }\n\n  for(int i=0;i<n;i++)\n    if(c[i]>0)return true;\n  \n  return false;\n}\n\nint d[MAX_N];\nvoid init(int root){\n  root=id[root];\n  for(int pos:group[root]){\n    d[pos]=-1;\n  }\n}\n\nvoid bfs(int root){\n  init(root);\n  queue<int> Q;\n  Q.push(root);\n  d[root]=0;\n  while(!Q.empty()){\n    int pos=Q.front();Q.pop();\n    for(int to:G[pos]){\n      if(d[to]!=-1)continue;\n      d[to]=d[pos]+1;\n      Q.push(to);\n    }\n  }\n}\n\nvoid update(int root,int dif){\n  for(int pos:group[root]){\n    for(int to:g[pos]){\n      dp[to]=max(dp[to],d[pos]+dif+1);\n    }\n  }\n}\n\nint solve(int root){\n  int res=0;\n  bfs(root);\n  int maxm=-1,maxmid;\n  for(int pos:group[root])\n    if(d[pos]+dp[pos]>maxm)maxm=d[pos]+dp[pos],maxmid=pos;\n  bfs(maxmid);\n  update(root,dp[maxmid]);\n  maxmid=-1;\n  for(int pos:group[root]){\n    if(d[pos]+dp[pos]>maxm)maxm=d[pos]+dp[pos],maxmid=pos;\n    res=max(res,d[pos]);\n  }\n  bfs(maxmid);\n  update(root,dp[maxmid]);\n  return res;\n}\n\nint main(){\n  scanf(\"%d %d\",&n,&m);\n  for(int i=0;i<m;i++){\n    scanf(\"%d %d %d\",&x[i],&y[i],&w[i]);\n    x[i]--,y[i]--;\n    \n    if(w[i]==2){\n      G[x[i]].push_back(y[i]);\n      G[y[i]].push_back(x[i]);\n    }\n  }\n  \n  if( check() ){\n    printf(\"Infinite\\n\");\n    return 0;\n  }\n\n  for(int i=0;i<n;i++){\n    g[i].clear();\n  }\n  for(int i=0;i<m;i++){\n    if(w[i]==1){\n      g[ x[i] ].push_back(y[i]);\n    }\n  }\n  \n  int ans=0;\n  \n  for(int root : vd ){\n    if(root!=id[root])continue;\n    ans=max(ans,solve(root));\n  }\n\n  for(int i=0;i<n;i++){\n    ans=max(ans,dp[i]);\n  }\n  printf(\"%d\\n\",ans);  \n  return 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\n#define rep(i,N) for(int i=0;i<(int)N;i++)\n#define rep1(i,N) for(int i=1;i<=(int)N;i++)\n#define pb push_back\n#define all(c) c.begin(),c.end()\n#define show(x) cout<<#x<<\" \"<<x<<endl\n#define chmax(x,y) x=max(x,y)\nusing namespace std;\nstruct edge {int to,w,rev;};\n//typedef vector< vector<edge> > Graph;\n//Graph G,oG;\nvector<edge> G[300000],oG[100000];\nvoid add_edge(int x,int y,int w,int way){\n\tif(way==1){\n\t\tG[x].pb({y,w,-1});\n\t}else{\n\t\tint X=G[x].size(),Y=G[y].size();\n\t\tG[x].pb({y,w,Y});\n\t\tG[y].pb({x,w,X});\n\t}\n}\n\ntypedef pair<int,int> P;\nmap<P,int> memo;\nset<P> vis;\nint dfs(int v,int eid){\n\tif(memo.count(P(v,eid))) return memo[P(v,eid)];\n\tif(vis.count(P(v,eid))){\n\t\tputs(\"Infinite\");\n\t\texit(1);\n\t}\n\tvis.insert(P(v,eid));\n\tint ret=0;\n\trep(i,G[v].size()) if(i!=eid){\n\t\tedge& e=G[v][i];\n\t\tchmax(ret,dfs(e.to,e.rev)+e.w);\n\t}\n\tmemo[P(v,eid)]=ret;\n\treturn ret;\n}\n\nint rs[100001]={};\nint its[100000]={};\nint main(){\n\tint N,M;\n\tcin>>N>>M;\n//\toG.resize(N);\n\trep(i,M){\n\t\tint x,y,w;\n\t\tscanf(\"%d %d %d\",&x,&y,&w);\n\t\tx--,y--;\n\t\tif(w==1){\n\t\t\toG[x].pb(edge{y,1,-1});\n\t\t}else{\n\t\t\tint X=oG[x].size(),Y=oG[y].size();\n\t\t\toG[x].pb(edge{y,1,Y});\n\t\t\toG[y].pb(edge{x,1,X});\n\t\t}\n\t}\n\tint newN=0;\n\trep(i,N){\n\t\tint sz=oG[i].size();\n\t\tif(sz==0) sz=1;\n\t\trs[i]=newN;\n\t\tits[i]=rs[i];\n\t\tnewN+=sz;\n\t}\n\trs[N]=newN;\n//\tG.resize(newN);\n\trep(x,N){\n\t\tint n=rs[x+1]-rs[x];\n\t\tfor(int v=rs[x];v<rs[x]+n-1;v++) add_edge(v,v+1,0,2);\n\t\tfor(edge e: oG[x]){\n\t\t\tif(e.rev==-1){\t//one way\n\t\t\t\tadd_edge(its[x],rs[e.to],1,1);\n\t\t\t\tits[x]++;\n\t\t\t}else{\n\t\t\t\tif(x<e.to){\n\t\t\t\t\tadd_edge(its[x],its[e.to],1,2);\n\t\t\t\t\tits[x]++;\n\t\t\t\t\tits[e.to]++;\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t}\n\tint ans=0;\n\tN=newN;\n\trep(i,N){\n\t\tchmax(ans,dfs(i,-1));\n\t}\n\tcout<<ans<<endl;\n}"
  },
  {
    "language": "C++",
    "code": "#include<bits/stdc++.h>\nusing namespace std;\n#define MAX_N 100005\n#define MAX_M 100005\n\nint n,m,ans;\nint x[MAX_M],y[MAX_M],w[MAX_M];\nvector<int> G[MAX_N];\nvector<int> g[MAX_N];\nvector<int> group[MAX_N];\nint id[MAX_N];\nbool visited[MAX_N];\nvector<int> vd;\nint dp[MAX_N];\nint d[MAX_N];\n\nbool dfs(int pos,int prev,int root){\n  id[pos]=root;\n  visited[pos]=true;\n  group[root].push_back(pos);\n  for(int i=0;i<(int)G[pos].size();i++){\n    int to=G[pos][i];\n    if(to==prev)continue;\n    if(i&&to==G[pos][i-1])return true;\n    if(visited[to])return true;\n    if(dfs(to,pos,root))return true;\n  }\n  return false;\n}\n\nbool check(){\n  memset(visited,false,sizeof(visited));\n  for(int i=0;i<n;i++)\n    if(!visited[i]&&dfs(i,-1,i))return true;\n\n  vector<int> deg(n);\n  for(int pos=0;pos<n;pos++)\n    for(int to:g[pos])\n      deg[ id[to] ]++;\n\n  queue<int> Q;\n  for(int i=0;i<n;i++)\n    if(deg[i]==0&&id[i]==i)\n      Q.push(i);\n  \n  while(!Q.empty()){\n    int root=Q.front();Q.pop();\n    vd.push_back(root);\n    for(int pos:group[root]){\n      for(int to:g[pos]){\n        deg[ id[to] ]--;\n        if(deg[ id[to] ]==0)Q.push(id[to]);\n      }\n    }\n  }\n  for(int i=0;i<n;i++)\n    if(deg[i]>0)return true;\n  return false;\n}\n\nint solve(int S){\n  for(int pos:group[id[S]])d[pos]=-1;\n  queue<int> Q;\n  Q.push(S);\n  d[S]=0;\n  while(!Q.empty()){\n    int pos=Q.front();Q.pop();\n    for(int to:G[pos]){\n      if(d[to]!=-1)continue;\n      d[to]=d[pos]+1;\n      Q.push(to);\n    }\n  }\n  int res=S;\n  for(int pos:group[id[S]]){\n    if(d[pos]+dp[pos]>d[res]+dp[res])res=pos;\n    ans=max(ans,d[pos]+dp[S]);\n    for(int to:g[pos])dp[to]=max(dp[to],d[pos]+dp[S]+1);\n  }\n  return res;\n}\n\nint main(){\n  scanf(\"%d %d\",&n,&m);\n  for(int i=0;i<m;i++){\n    scanf(\"%d %d %d\",&x[i],&y[i],&w[i]);\n    x[i]--,y[i]--;\n    if(w[i]==1){\n      g[x[i]].push_back(y[i]);\n    }\n    if(w[i]==2){\n      G[x[i]].push_back(y[i]);\n      G[y[i]].push_back(x[i]);\n    }\n  }\n  if(check()){\n    printf(\"Infinite\\n\");\n    return 0;\n  }\n  for(int root : vd )\n    if(root==id[root])\n      solve(solve(solve(root)));\n  printf(\"%d\\n\",ans);  \n  return 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\n#define rep(i,N) for(int i=0;i<(int)N;i++)\n#define rep1(i,N) for(int i=1;i<=(int)N;i++)\n#define pb push_back\n#define all(c) c.begin(),c.end()\n#define show(x) cout<<#x<<\" \"<<x<<endl\n#define chmax(x,y) x=max(x,y)\n#define BEGIN_STACK_EXTEND(size) void * stack_extend_memory_ = malloc(size);void * stack_extend_origin_memory_;char * stack_extend_dummy_memory_ = (char*)alloca((1+(int)(((long long)stack_extend_memory_)&127))*16);*stack_extend_dummy_memory_ = 0;asm volatile(\"mov %%rsp, %%rbx\\nmov %%rax, %%rsp\":\"=b\"(stack_extend_origin_memory_):\"a\"((char*)stack_extend_memory_+(size)-1024));\n#define END_STACK_EXTEND asm volatile(\"mov %%rax, %%rsp\"::\"a\"(stack_extend_origin_memory_));free(stack_extend_memory_);\nusing namespace std;\nstruct edge {int to,w,rev;};\ntypedef vector< vector<edge> > Graph;\nGraph G,oG;\nvoid add_edge(int x,int y,int w,int way){\n\tif(way==1){\n\t\tG[x].pb({y,w,-1});\n\t}else{\n\t\tint X=G[x].size(),Y=G[y].size();\n\t\tG[x].pb({y,w,Y});\n\t\tG[y].pb({x,w,X});\n\t}\n}\n\ntypedef pair<int,int> P;\nmap<P,int> memo;\nset<P> vis;\nint dfs(int v,int eid){\n\tif(memo.count(P(v,eid))) return memo[P(v,eid)];\n\tif(vis.count(P(v,eid))){\n\t\tputs(\"Infinite\");\n\t\texit(1);\n\t}\n\tvis.insert(P(v,eid));\n\tint ret=0;\n\trep(i,G[v].size()) if(i!=eid){\n\t\tedge& e=G[v][i];\n\t\tchmax(ret,dfs(e.to,e.rev)+e.w);\n\t}\n\tmemo[P(v,eid)]=ret;\n\treturn ret;\n}\n\nint rs[100001]={};\nint its[100000]={};\n\nint main(){\n//\tBEGIN_STACK_EXTEND(1024*1024);\n\treturn 0;\n\tint N,M;\n\tcin>>N>>M;\n\toG.resize(N);\n\trep(i,M){\n\t\tint x,y,w;\n\t\tscanf(\"%d %d %d\",&x,&y,&w);\n\t\tx--,y--;\n\t\tif(w==1){\n\t\t\toG[x].pb(edge{y,1,-1});\n\t\t}else{\n\t\t\tint X=oG[x].size(),Y=oG[y].size();\n\t\t\toG[x].pb(edge{y,1,Y});\n\t\t\toG[y].pb(edge{x,1,X});\n\t\t}\n\t}\n\tint newN=0;\n\trep(i,N){\n\t\tint sz=oG[i].size();\n\t\tif(sz==0) sz=1;\n\t\trs[i]=newN;\n\t\tits[i]=rs[i];\n\t\tnewN+=sz;\n\t}\n\trs[N]=newN;\n\tG.resize(newN);\n\trep(x,N){\n\t\tint n=rs[x+1]-rs[x];\n\t\tfor(int v=rs[x];v<rs[x]+n-1;v++) add_edge(v,v+1,0,2);\n\t\tfor(edge e: oG[x]){\n\t\t\tif(e.rev==-1){\t//one way\n\t\t\t\tadd_edge(its[x],rs[e.to],1,1);\n\t\t\t\tits[x]++;\n\t\t\t}else{\n\t\t\t\tif(x<e.to){\n\t\t\t\t\tadd_edge(its[x],its[e.to],1,2);\n\t\t\t\t\tits[x]++;\n\t\t\t\t\tits[e.to]++;\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t}\n\tint ans=0;\n\tN=newN;\n\trep(i,N) chmax(ans,dfs(i,-1));\n\tcout<<ans<<endl;\n//\tEND_STACK_EXTEND;\n}"
  },
  {
    "language": "C++",
    "code": "#include<bits/stdc++.h>\nusing namespace std;\n#define MAX_N 100005\n#define MAX_M 100005\ntypedef pair<int,int> P;\n\nint n,m;\nint x[MAX_M],y[MAX_M],w[MAX_M];\n\nvector<int> G[MAX_N];\nvector<int> g[MAX_N];\n\nvector<int> group[MAX_N];\nint id[MAX_N];\nbool visited[MAX_N];\nvector<int> vd;\n\nint dp[MAX_N];\n\nbool dfs(int pos,int prev,int root){\n  id[pos]=root;\n  visited[pos]=true;\n  group[root].push_back(pos);\n  for(int i=0;i<(int)G[pos].size();i++){\n    int to=G[pos][i];\n    if(to==prev)continue;\n    if(i&&to==G[pos][i-1])return true;\n    if(visited[to])return true;\n    if(dfs(to,pos,root))return true;\n  }\n  return false;\n}\n\nbool check(){\n  memset(visited,false,sizeof(visited));\n  for(int i=0;i<n;i++){\n    if(visited[i])continue;\n    if( dfs(i,-1,i) )return true;\n  }\n\n  vector< int > deg(n);\n  vector< vector<int> > graph(n);\n  \n  for(int i=0;i<m;i++){\n    if(w[i]==1){\n      int X=id[ x[i] ];\n      int Y=id[ y[i] ];\n      if(X==Y)return true;\n      graph[X].push_back(Y);\n      deg[Y]++;\n    }\n  }\n\n  queue<int> Q;\n  for(int i=0;i<n;i++)\n    if(deg[i]==0&&id[i]==i)\n      Q.push(i);\n\n  while(!Q.empty()){\n    int pos=Q.front();Q.pop();\n    vd.push_back(pos);\n    for(int to:graph[pos]){\n      deg[to]--;\n      if(deg[to]==0)Q.push(to);\n    }\n  }\n  \n  for(int i=0;i<n;i++)\n    if(deg[i]>0)return true;\n  \n  return false;\n}\n\nint d[MAX_N];\n\nvoid init(int root){\n  root=id[root];\n  for(int pos:group[root])\n    d[pos]=-1;\n}\n\nvoid bfs(int root){\n  init(root);\n  queue<int> Q;\n  Q.push(root);\n  d[root]=0;\n  while(!Q.empty()){\n    int pos=Q.front();Q.pop();\n    for(int to:G[pos]){\n      if(d[to]!=-1)continue;\n      d[to]=d[pos]+1;\n      Q.push(to);\n    }\n  }\n}\n\nvoid update(int root,int dif){\n  for(int pos:group[root])\n    for(int to:g[pos])\n      dp[to]=max(dp[to],d[pos]+dif+1);\n}\n\nint solve(int root){\n  int res=0;\n  bfs(root);\n  int maxm=-1,maxmid;\n  for(int pos:group[root])\n    if(d[pos]+dp[pos]>maxm)maxm=d[pos]+dp[pos],maxmid=pos;\n  \n  bfs(maxmid);\n  update(root,dp[maxmid]);\n  for(int pos:group[root])res=max(res,d[pos]+dp[maxmid]);\n  \n  maxm=-1;\n  for(int pos:group[root])\n    if(d[pos]+dp[pos]>maxm)maxm=d[pos]+dp[pos],maxmid=pos;\n\n  bfs(maxmid);\n  update(root,dp[maxmid]);\n  for(int pos:group[root])res=max(res,d[pos]+dp[maxmid]);\n  \n  return res;\n}\n\nint main(){\n  scanf(\"%d %d\",&n,&m);\n  for(int i=0;i<m;i++){\n    scanf(\"%d %d %d\",&x[i],&y[i],&w[i]);\n    x[i]--,y[i]--;\n    if(w[i]==1){\n      g[x[i]].push_back(y[i]);\n    }\n    if(w[i]==2){\n      G[x[i]].push_back(y[i]);\n      G[y[i]].push_back(x[i]);\n    }\n  }\n  \n  if( check() ){\n    printf(\"Infinite\\n\");\n    return 0;\n  }\n\n  int ans=0;\n  for(int root : vd ){\n    if(root!=id[root])continue;\n    ans=max(ans,solve(root));\n  }\n  printf(\"%d\\n\",ans);  \n  return 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\n \nusing namespace std;\n \nconst int INF = 1 << 29;\n \nstruct UnionFind\n{\n  vector< int > data;\n \n  UnionFind(int sz)\n  {\n    data.assign(sz, -1);\n  }\n \n  int find(int k)\n  {\n    return (data[k] < 0 ? k : data[k] = find(data[k]));\n  }\n \n  void unite(int x, int y)\n  {\n    x = find(x);\n    y = find(y);\n    if(x == y) return;\n    if(data[x] > data[y]) swap(x, y);\n    data[x] += data[y];\n    data[y] = x;\n  }\n};\n \nvector< pair< int, int > > g[100001];\nvector< int > leftt[100001], rightt[100001], just[100001];\nvector< int > gg[100001], rgg[100001], order;\nbool v[100000];\nint cmp[100000];\n \n \nvoid dfs(int idx)\n{\n  if(v[idx]++) return;\n  for(auto &to : gg[idx]) dfs(to);\n  order.push_back(idx);\n}\n \nvoid rdfs(int idx, int k)\n{\n  cmp[idx] = k;\n  for(auto &to : rgg[idx]) if(cmp[to] == -1) rdfs(to, k);\n}\n \n \nint rec(int idx, int back = -1)\n{\n  if(back != -1) {\n    int tmp = max(leftt[idx][back], rightt[idx][back + 1]);\n    if(tmp != INF) return (tmp);\n  }\n  if(rightt[idx][0] == INF) {\n    for(int i = 0; i < g[idx].size(); i++) {\n      int to, rev;\n      tie(to, rev) = g[idx][i];\n      if(i == back) continue;\n      just[idx][i] = rec(to, rev) + 1;\n    }\n    for(int i = 0; i < g[idx].size(); i++) {\n      leftt[idx][i + 1] = max(leftt[idx][i], just[idx][i]);\n    }\n    for(int i = (int) g[idx].size() - 1; i >= 0; i--) {\n      rightt[idx][i] = max(rightt[idx][i + 1], just[idx][i]);\n    }\n  }\n  if(back == -1) return (rightt[idx][0]);\n  return (max(leftt[idx][back], rightt[idx][back + 1]));\n}\n \n \nint main()\n{\n  int N, M;\n  vector< pair< int, int > > edges, arcs;\n \n  scanf(\"%d %d\", &N, &M);\n \n  UnionFind uf(N);\n \n  for(int i = 0; i < M; i++) {\n    int x, y, t;\n    cin >> x >> y >> t;\n    --x, --y;\n    if(t == 1) {\n      arcs.emplace_back(x, y);\n      g[x].emplace_back(y, -1);\n    } else {\n      if(uf.find(x) == uf.find(y)) {\n        cout << \"Infinite\" << endl;\n        return (0);\n      }\n      uf.unite(x, y);\n      edges.emplace_back(x, y);\n      g[y].emplace_back(x, g[x].size());\n      g[x].emplace_back(y, g[y].size() - 1);\n    }\n  }\n \n  {\n    for(auto &e : arcs) {\n      gg[uf.find(e.first)].push_back(uf.find(e.second));\n      rgg[uf.find(e.second)].push_back(uf.find(e.first));\n    }\n    for(int i = 0; i < N; i++) dfs(i);\n    reverse(begin(order), end(order));\n    memset(cmp, -1, sizeof(cmp));\n    int kk = 0;\n    for(auto &i : order) if(cmp[i] == -1) rdfs(i, kk++);\n    if(kk != N) {\n      cout << \"Infinite\" << endl;\n      return (0);\n    }\n  }\n \n \n  int ret = 0;\n  for(int i = 0; i < N; i++) {\n    int sz = g[i].size();\n    just[i].assign(sz, INF);\n    leftt[i].assign(sz + 1, INF);\n    rightt[i].assign(sz + 1, INF);\n    leftt[i][0] = rightt[i][sz] = 0;\n  }\n  for(int i = 0; i < N; i++) ret = max(ret, rec(i));\n  cout << ret << endl;\n}"
  },
  {
    "language": "C++",
    "code": "\n#include<bits/stdc++.h>\nusing namespace std;\n#define D(x)    cout << #x \" = \" << (x) << endl\n#define MAX     100001\n\nint counter;\n\nstruct directed_graph{\n    int n;\n    vector<int> edge[MAX+5];\n    vector<int> indx[MAX+5];\n    short int clr[MAX+5];\n    bool flag;\n\n    directed_graph(int _n = 0){\n        n = _n;\n    }\n\n    void addEdge(int u, int v){\n        edge[u].push_back(v);\n        indx[u].push_back(++counter);\n    }\n\n    void dfs(int idx)\n    {\n        if(clr[idx] == 1){\n            flag = true;\n            return;\n        }\n        if(flag == true) return;\n        if(clr[idx]) return;\n\n        clr[idx] = 1;\n        for(auto x : edge[idx])\n            dfs(x);\n\n        clr[idx] = 2;\n    }\n\n    bool hasCycle(){\n\n        flag = false;\n        memset(clr, 0, sizeof(clr));\n\n        for(int i = 1; i <= n; i++)\n            if(clr[i] == 0)\n                dfs(i);\n\n        return flag;\n    }\n\n} dg, cmpg;\n\n#define MAXLG       18\n#define MAXN        100001\n\nstruct undirected_graph{\n    int n, d[MAX+5];\n    vector<int> edge[MAX+5], indx[MAX+5];\n    bool vis[MAX+5];\n    bool flag;\n    int tab[MAXLG+2][MAXN+5];\n    int par[MAXN+5];\n    int lev[MAXN+5], stp;\n\n    undirected_graph(int _n = 0){\n        n = _n;\n        memset(d, -1, sizeof(d));\n    }\n\n    void addEdge(int u, int v){\n        edge[u].push_back(v);\n        edge[v].push_back(u);\n\n        indx[u].push_back(++counter);\n        indx[v].push_back(++counter);\n    }\n\n    int bfs(int idx)\n    {\n        int mx = 0, ret = idx;\n        queue<int> q;\n        d[idx] = 0;\n\n        q.push(idx);\n        while(!q.empty())\n        {\n            int u = q.front(); q.pop();\n            for(auto x : edge[u])\n                if(d[x] == -1)\n                {\n                    d[x] = d[u] + 1;\n                    q.push(x);\n                    if(d[x] > mx){\n                        mx = d[x];\n                        ret = x;\n                    }\n                }\n        }\n\n        return ret;\n    }\n\n    void init_st(int n)\n    {\n        int idx;\n        for(idx = 1; idx <= n; idx++)\n            tab[0][idx] = par[idx];\n\n        for(stp = 1; (1 << stp) < n; stp++)\n            for(int idx = 1; idx <= n; idx++)\n                if(tab[stp-1][idx] == -1) tab[stp][idx] = -1;\n                else tab[stp][idx] = tab[stp-1][tab[stp-1][idx]];\n        stp--;\n    }\n\n    int go(int cur, int gap, int pos)\n    {\n        if(!gap) return cur;\n        if(gap & 1) return go(tab[pos][cur], gap/2, pos+1);\n        return go(cur, gap/2, pos + 1);\n    }\n\n    int LCA(int u, int v)\n    {\n        if(lev[u] > lev[v]) swap(u, v);\n        v = go(v, lev[v] - lev[u], 0);\n        if(u == v) return v;\n\n        int i;\n        for(i = stp; i >= 0; i--)\n            if(tab[i][u] != tab[i][v])\n                u = tab[i][u], v = tab[i][v];\n\n        assert(tab[0][u] > 0);\n        return tab[0][u];\n    }\n\n    void dfs(int idx, int p, int lv)\n    {\n        lev[idx] = lv;\n        par[idx] = p;\n\n        for(auto x : edge[idx])\n            if(x == p) continue;\n            else dfs(x, idx, lv + 1);\n    }\n\n    int get_dist(int u, int v)\n    {\n        int _lca = LCA(u, v);\n        return d[u] + d[v] - 2 * d[_lca];\n    }\n\n    void generate_st(int rt)\n    {\n        memset(d, -1, sizeof(d));\n        bfs(rt);\n        dfs(rt, -1, 0);\n        init_st(n);\n    }\n\n} ug;\n\nint par[MAX+5], n;\nbool flag = false;\nvoid init(int n) {for(int i = 1; i <= n; i++) par[i] = i;}\nint find_par(int idx)\n{\n    if(par[idx] == idx) return idx;\n    return par[idx] = find_par(par[idx]);\n}\nvoid join(int u, int v)\n{\n    int pu = find_par(u);\n    int pv = find_par(v);\n    if(pu == pv)\n    {\n        flag = true;\n        return;\n    }\n    par[pu] = pv;\n    return;\n}\n\nbool vis[MAX+5];\nvector<int> farthest[MAX+5];\nmap< pair<int, int> , int > M;\nint dp[MAX << 4], glb;\n\nint F(int u, int v, int stt)\n{\n    //if(dp[stt] != -1) return dp[stt];\n    int i_stt = stt;\n\n    int ret = 0;\n    for(int i = 0; i < (int) dg.edge[v].size(); i++)\n    {\n        int x = dg.edge[v][i];\n        stt = dg.indx[v][i];\n        if(x == u) continue;\n        else ret = max(ret, 1 + F(v, x, stt));\n    }\n\n    for(int i = 0; i <(int) ug.edge[v].size(); i++)\n    {\n        int x = ug.edge[v][i];\n        stt = ug.indx[v][i];\n        if(x == u || x == n + 1) continue;\n        else ret = max(ret, 1 + F(v, x, stt));\n    }\nreturn ret;\n    return dp[i_stt] = ret;\n}\n\nint main()\n{\n    //freopen(\"in.txt\", \"r\", stdin);\n    int i, j, k, u, v, w, m;\n\n    scanf(\"%d %d\", &n, &m);\n\n    init(n);\n    ug = undirected_graph(n + 1);\n    dg = directed_graph(n);\n    cmpg = directed_graph(n);\n\n    for(i = 1; i <= m; i++)\n    {\n        scanf(\"%d %d %d\", &u, &v, &w);\n        if(w == 1) dg.addEdge(u, v);\n        if(w == 2)\n        {\n            ug.addEdge(u, v);\n            join(u, v);\n        }\n    }\n\n    for(i = 1; i <= n; i++)\n        for(auto x : dg.edge[i])\n            cmpg.addEdge(find_par(i), find_par(x));\n\n    if(flag || dg.hasCycle() || cmpg.hasCycle())\n    {\n        puts(\"Infinite\");\n        return 0;\n    }\n\n    for(i = 1; i <= n; i++)\n    {\n        int p = find_par(i);\n        if(vis[p]) continue;\n        vis[p] = true;\n\n        int x = ug.bfs(p);\n        int y = ug.bfs(x);\n\n        farthest[p].push_back(x);\n        if(x != y) farthest[p].push_back(y);\n    }\n\n    memset(vis, 0, sizeof(vis));\n    for(i = 1; i <= n; i++)\n    {\n        int p = find_par(i);\n        if(vis[p]) continue;\n        vis[p] = true;\n        ug.addEdge(n + 1, p);\n    }\n\n    memset(dp, -1,sizeof(dp));\n    ug.generate_st(n + 1);\n    int ans = 0;\n    for(i = 1; i <= n; i++)\n        ans = max(ans, F(n + 1, i, counter + i));\n\n\n    cout << ans << endl;\n    return 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\n#define rep(i,N) for(int i=0;i<(int)N;i++)\n#define rep1(i,N) for(int i=1;i<=(int)N;i++)\n#define pb push_back\n#define all(c) c.begin(),c.end()\n#define show(x) cout<<#x<<\" \"<<x<<endl\n#define chmax(x,y) x=max(x,y)\n#define BEGIN_STACK_EXTEND(size) void * stack_extend_memory_ = malloc(size);void * stack_extend_origin_memory_;char * stack_extend_dummy_memory_ = (char*)alloca((1+(int)(((long long)stack_extend_memory_)&127))*16);*stack_extend_dummy_memory_ = 0;asm volatile(\"mov %%rsp, %%rbx\\nmov %%rax, %%rsp\":\"=b\"(stack_extend_origin_memory_):\"a\"((char*)stack_extend_memory_+(size)-1024));\n#define END_STACK_EXTEND asm volatile(\"mov %%rax, %%rsp\"::\"a\"(stack_extend_origin_memory_));free(stack_extend_memory_);\nusing namespace std;\nconst int MN=100000;\nstruct edge {int to,w,rev;};\ntypedef vector< vector<edge> > Graph;\nGraph G,oG;\nvoid add_edge(int x,int y,int w,int way){\n\tif(way==1){\n\t\tG[x].pb({y,w,-1});\n\t}else{\n\t\tint X=G[x].size(),Y=G[y].size();\n\t\tG[x].pb({y,w,Y});\n\t\tG[y].pb({x,w,X});\n\t}\n}\n\ntypedef pair<int,int> P;\nint memo[300000][4];\nbool vis[300000][4];\nint inf=1e8;\nint dfs(int v,int eid){\n\teid++;\n\tif(memo[v][eid]!=-1) return memo[v][eid];\n\tif(vis[v][eid]){\n\t\treturn inf;\n//\t\tputs(\"Infinite\");\n\t}\n\tvis[v][eid]=1;\n\tint ret=0;\n\t// rep(i,G[v].size()) if(i!=eid-1){\n\t// \tedge& e=G[v][i];\n\t// \tchmax(ret,dfs(e.to,e.rev)+e.w);\n\t// }\n\tif(G[v].size()>0 && eid!=1) chmax(ret,dfs(G[v][0].to,G[v][0].rev)+G[v][0].w);\n\tif(G[v].size()>1 && eid!=2) chmax(ret,dfs(G[v][1].to,G[v][1].rev)+G[v][1].w);\n\tif(G[v].size()>2 && eid!=3) chmax(ret,dfs(G[v][2].to,G[v][2].rev)+G[v][2].w);\n\tmemo[v][eid]=ret;\n\treturn ret;\n}\n\nint rs[100001]={};\nint its[100000]={};\n\nint main(){\n\tBEGIN_STACK_EXTEND(128*1024*1024);\n\tint N,M;\n\tcin>>N>>M;\n\toG.resize(N);\n\trep(i,M){\n\t\tint x,y,w;\n\t\tscanf(\"%d %d %d\",&x,&y,&w);\n\t\tx--,y--;\n\t\tif(w==1){\n\t\t\toG[x].pb(edge{y,1,-1});\n\t\t}else{\n\t\t\tint X=oG[x].size(),Y=oG[y].size();\n\t\t\toG[x].pb(edge{y,1,Y});\n\t\t\toG[y].pb(edge{x,1,X});\n\t\t}\n\t}\n\tint newN=0;\n\trep(i,N){\n\t\tint sz=oG[i].size();\n\t\tif(sz==0) sz=1;\n\t\trs[i]=newN;\n\t\tits[i]=rs[i];\n\t\tnewN+=sz;\n\t}\n\trs[N]=newN;\n\tG.resize(newN);\n\trep(x,N){\n\t\tint n=rs[x+1]-rs[x];\n\t\tfor(int v=rs[x];v<rs[x]+n-1;v++) add_edge(v,v+1,0,2);\n\t\tfor(edge e: oG[x]){\n\t\t\tif(e.rev==-1){\t//one way\n\t\t\t\tadd_edge(its[x],rs[e.to],1,1);\n\t\t\t\tits[x]++;\n\t\t\t}else{\n\t\t\t\tif(x<e.to){\n\t\t\t\t\tadd_edge(its[x],its[e.to],1,2);\n\t\t\t\t\tits[x]++;\n\t\t\t\t\tits[e.to]++;\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t}\n\tint ans=0;\n\tN=newN;\n//\trep(i,N) assert(G[i].size()<=3);\n\trep(i,N) rep(j,4) memo[i][j]=-1;\n\trep(i,N) chmax(ans,dfs(i,-1));\n\tif(ans>=inf) puts(\"Infinite\");\n\telse cout<<ans<<endl;\n\tEND_STACK_EXTEND;\n}"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\n#define rep(i,N) for(int i=0;i<(int)N;i++)\n#define rep1(i,N) for(int i=1;i<=(int)N;i++)\n#define pb push_back\n#define all(c) c.begin(),c.end()\n#define show(x) cout<<#x<<\" \"<<x<<endl\n#define chmax(x,y) x=max(x,y)\n#define BEGIN_STACK_EXTEND(size) void * stack_extend_memory_ = malloc(size);void * stack_extend_origin_memory_;char * stack_extend_dummy_memory_ = (char*)alloca((1+(int)(((long long)stack_extend_memory_)&127))*16);*stack_extend_dummy_memory_ = 0;asm volatile(\"mov %%rsp, %%rbx\\nmov %%rax, %%rsp\":\"=b\"(stack_extend_origin_memory_):\"a\"((char*)stack_extend_memory_+(size)-1024));\n#define END_STACK_EXTEND asm volatile(\"mov %%rax, %%rsp\"::\"a\"(stack_extend_origin_memory_));free(stack_extend_memory_);\nusing namespace std;\nconst int MN=100000;\nstruct edge {int to,w,rev;};\ntypedef vector< vector<edge> > Graph;\nGraph G,oG;\nvoid add_edge(int x,int y,int w,int way){\n\tif(way==1){\n\t\tG[x].pb({y,w,-1});\n\t}else{\n\t\tint X=G[x].size(),Y=G[y].size();\n\t\tG[x].pb({y,w,Y});\n\t\tG[y].pb({x,w,X});\n\t}\n}\n\ntypedef pair<int,int> P;\nint memo[300000][4];\nbool vis[300000][4];\nint dfs(int v,int eid){\n\teid++;\n\tif(memo[v][eid]!=-1) return memo[v][eid];\n\tif(vis[v][eid]){\n\t\tputs(\"Infinite\");\n\t\texit(0);\n\t}\n\tvis[v][eid]=1;\n\tint ret=0;\n\t// rep(i,G[v].size()) if(i!=eid-1){\n\t// \tedge& e=G[v][i];\n\t// \tchmax(ret,dfs(e.to,e.rev)+e.w);\n\t// }\n\tif(G[v].size()>0 && eid!=1) chmax(ret,dfs(G[v][0].to,G[v][0].rev)+G[v][0].w);\n\tif(G[v].size()>1 && eid!=2) chmax(ret,dfs(G[v][1].to,G[v][1].rev)+G[v][1].w);\n\tif(G[v].size()>2 && eid!=3) chmax(ret,dfs(G[v][2].to,G[v][2].rev)+G[v][2].w);\n\tmemo[v][eid]=ret;\n\treturn ret;\n}\n\nint rs[100001]={};\nint its[100000]={};\n\nint main(){\n\tBEGIN_STACK_EXTEND(128*1024*1024);\n\texit(0);\n\tint N,M;\n\tcin>>N>>M;\n\toG.resize(N);\n\trep(i,M){\n\t\tint x,y,w;\n\t\tscanf(\"%d %d %d\",&x,&y,&w);\n\t\tx--,y--;\n\t\tif(w==1){\n\t\t\toG[x].pb(edge{y,1,-1});\n\t\t}else{\n\t\t\tint X=oG[x].size(),Y=oG[y].size();\n\t\t\toG[x].pb(edge{y,1,Y});\n\t\t\toG[y].pb(edge{x,1,X});\n\t\t}\n\t}\n\tint newN=0;\n\trep(i,N){\n\t\tint sz=oG[i].size();\n\t\tif(sz==0) sz=1;\n\t\trs[i]=newN;\n\t\tits[i]=rs[i];\n\t\tnewN+=sz;\n\t}\n\trs[N]=newN;\n\tG.resize(newN);\n\trep(x,N){\n\t\tint n=rs[x+1]-rs[x];\n\t\tfor(int v=rs[x];v<rs[x]+n-1;v++) add_edge(v,v+1,0,2);\n\t\tfor(edge e: oG[x]){\n\t\t\tif(e.rev==-1){\t//one way\n\t\t\t\tadd_edge(its[x],rs[e.to],1,1);\n\t\t\t\tits[x]++;\n\t\t\t}else{\n\t\t\t\tif(x<e.to){\n\t\t\t\t\tadd_edge(its[x],its[e.to],1,2);\n\t\t\t\t\tits[x]++;\n\t\t\t\t\tits[e.to]++;\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t}\n\tint ans=0;\n\tN=newN;\n//\trep(i,N) assert(G[i].size()<=3);\n\trep(i,N) rep(j,4) memo[i][j]=-1;\n\trep(i,N) chmax(ans,dfs(i,-1));\n\tcout<<ans<<endl;\n\tEND_STACK_EXTEND;\n}"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\n\nusing namespace std;\n\nconst int INF = 1 << 29;\n\nstruct UnionFind\n{\n  vector< int > data;\n\n  UnionFind(int sz)\n  {\n    data.assign(sz, -1);\n  }\n\n  int find(int k)\n  {\n    return (data[k] < 0 ? k : data[k] = find(data[k]));\n  }\n\n  void unite(int x, int y)\n  {\n    x = find(x);\n    y = find(y);\n    if(x == y) return;\n    if(data[x] > data[y]) swap(x, y);\n    data[x] += data[y];\n    data[y] = x;\n  }\n};\n\nvector< pair< int, int > > g[100001];\nvector< int > leftt[100001], rightt[100001], just[100001];\nvector< int > gg[100001];\nint deg[100001];\n\n\nint rec(int idx, int back = -1)\n{\n  if(back != -1) {\n    int tmp = max(leftt[idx][back], rightt[idx][back + 1]);\n    if(tmp != INF) return (tmp);\n  }\n  if(rightt[idx][0] == INF) {\n    for(int i = 0; i < g[idx].size(); i++) {\n      int to, rev;\n      tie(to, rev) = g[idx][i];\n      if(i == back || just[idx][i] != INF) continue;\n      just[idx][i] = rec(to, rev) + 1;\n    }\n    for(int i = 0; i < g[idx].size(); i++) {\n      leftt[idx][i + 1] = max(leftt[idx][i], just[idx][i]);\n    }\n    for(int i = (int) g[idx].size() - 1; i >= 0; i--) {\n      rightt[idx][i] = max(rightt[idx][i + 1], just[idx][i]);\n    }\n  }\n\n  if(back == -1) return (rightt[idx][0]);\n  return (max(leftt[idx][back], rightt[idx][back + 1]));\n}\n\n\nint main()\n{\n  int N, M;\n  vector< pair< int, int > > edges, arcs;\n\n  scanf(\"%d %d\", &N, &M);\n\n  UnionFind uf(N);\n\n  for(int i = 0; i < M; i++) {\n    int x, y, t;\n    cin >> x >> y >> t;\n    --x, --y;\n    if(t == 1) {\n      arcs.emplace_back(x, y);\n      g[x].emplace_back(y, -1);\n    } else {\n      if(uf.find(x) == uf.find(y)) {\n        cout << \"Infinite\" << endl;\n        return (0);\n      }\n      uf.unite(x, y);\n      edges.emplace_back(x, y);\n      g[y].emplace_back(x, g[x].size());\n      g[x].emplace_back(y, g[y].size() - 1);\n    }\n  }\n\n  {\n    for(auto &e : arcs) {\n      gg[uf.find(e.first)].push_back(uf.find(e.second));\n      ++deg[uf.find(e.second)];\n    }\n    vector< int > order;\n    for(int i = 0; i < N; i++) {\n      if(deg[i] == 0) order.push_back(i);\n    }\n    for(int i = 0; i < order.size(); i++) {\n      for(auto &e : gg[order[i]]) {\n        if(--deg[e] == 0) order.push_back(e);\n      }\n    }\n    if(order.size() != N) {\n      cout << \"Infinite\" << endl;\n      return (0);\n    }\n  }\n\n\n  int ret = 0;\n  for(int i = 0; i < N; i++) {\n    int sz = g[i].size();\n    just[i].assign(sz, INF);\n    leftt[i].assign(sz + 1, INF);\n    rightt[i].assign(sz + 1, INF);\n    leftt[i][0] = rightt[i][sz] = 0;\n  }\n  for(int i = 0; i < N; i++) ret = max(ret, rec(i));\n  cout << ret << endl;\n}"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\n#define rep(i,N) for(int i=0;i<(int)N;i++)\n#define rep1(i,N) for(int i=1;i<=(int)N;i++)\n#define pb push_back\n#define all(c) c.begin(),c.end()\n#define show(x) cout<<#x<<\" \"<<x<<endl\n#define chmax(x,y) x=max(x,y)\n#define BEGIN_STACK_EXTEND(size) void * stack_extend_memory_ = malloc(size);void * stack_extend_origin_memory_;char * stack_extend_dummy_memory_ = (char*)alloca((1+(int)(((long long)stack_extend_memory_)&127))*16);*stack_extend_dummy_memory_ = 0;asm volatile(\"mov %%rsp, %%rbx\\nmov %%rax, %%rsp\":\"=b\"(stack_extend_origin_memory_):\"a\"((char*)stack_extend_memory_+(size)-1024));\n#define END_STACK_EXTEND asm volatile(\"mov %%rax, %%rsp\"::\"a\"(stack_extend_origin_memory_));free(stack_extend_memory_);\nusing namespace std;\nconst int MN=100000;\nstruct edge {int to,w,rev;};\ntypedef vector< vector<edge> > Graph;\nGraph G,oG;\nvoid add_edge(int x,int y,int w,int way){\n\tif(way==1){\n\t\tG[x].pb({y,w,-1});\n\t}else{\n\t\tint X=G[x].size(),Y=G[y].size();\n\t\tG[x].pb({y,w,Y});\n\t\tG[y].pb({x,w,X});\n\t}\n}\n\ntypedef pair<int,int> P;\nint memo[300000][4];\nbool vis[300000][4];\nint dfs(int v,int eid){\n\teid++;\n\tif(memo[v][eid]!=-1) return memo[v][eid];\n\tif(vis[v][eid]){\n\t\tputs(\"Infinite\");\n\t\texit(1);\n\t}\n\tvis[v][eid]=1;\n\tint ret=0;\n\t// rep(i,G[v].size()) if(i!=eid-1){\n\t// \tedge& e=G[v][i];\n\t// \tchmax(ret,dfs(e.to,e.rev)+e.w);\n\t// }\n\tif(G[v].size()>0 && eid!=1) chmax(ret,dfs(G[v][0].to,G[v][0].rev)+G[v][0].w);\n\tif(G[v].size()>1 && eid!=2) chmax(ret,dfs(G[v][1].to,G[v][1].rev)+G[v][1].w);\n\tif(G[v].size()>2 && eid!=3) chmax(ret,dfs(G[v][2].to,G[v][2].rev)+G[v][2].w);\n\tmemo[v][eid]=ret;\n\treturn ret;\n}\n\nint rs[100001]={};\nint its[100000]={};\n\nint main(){\n\tBEGIN_STACK_EXTEND(128*1024*1024);\n\tint N,M;\n\tcin>>N>>M;\n\toG.resize(N);\n\trep(i,M){\n\t\tint x,y,w;\n\t\tscanf(\"%d %d %d\",&x,&y,&w);\n\t\tx--,y--;\n\t\tif(w==1){\n\t\t\toG[x].pb(edge{y,1,-1});\n\t\t}else{\n\t\t\tint X=oG[x].size(),Y=oG[y].size();\n\t\t\toG[x].pb(edge{y,1,Y});\n\t\t\toG[y].pb(edge{x,1,X});\n\t\t}\n\t}\n\tint newN=0;\n\trep(i,N){\n\t\tint sz=oG[i].size();\n\t\tif(sz==0) sz=1;\n\t\trs[i]=newN;\n\t\tits[i]=rs[i];\n\t\tnewN+=sz;\n\t}\n\trs[N]=newN;\n\tG.resize(newN);\n\trep(x,N){\n\t\tint n=rs[x+1]-rs[x];\n\t\tfor(int v=rs[x];v<rs[x]+n-1;v++) add_edge(v,v+1,0,2);\n\t\tfor(edge e: oG[x]){\n\t\t\tif(e.rev==-1){\t//one way\n\t\t\t\tadd_edge(its[x],rs[e.to],1,1);\n\t\t\t\tits[x]++;\n\t\t\t}else{\n\t\t\t\tif(x<e.to){\n\t\t\t\t\tadd_edge(its[x],its[e.to],1,2);\n\t\t\t\t\tits[x]++;\n\t\t\t\t\tits[e.to]++;\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t}\n\tint ans=0;\n\tN=newN;\n\trep(i,N) assert(G[i].size()<=3);\n\trep(i,N) rep(j,4) memo[i][j]=-1;\n\trep(i,N) chmax(ans,dfs(i,-1));\n\tcout<<ans<<endl;\n\tEND_STACK_EXTEND;\n}"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\n#define rep(i,N) for(int i=0;i<(int)N;i++)\n#define rep1(i,N) for(int i=1;i<=(int)N;i++)\n#define pb push_back\n#define all(c) c.begin(),c.end()\n#define show(x) cout<<#x<<\" \"<<x<<endl\n#define chmax(x,y) x=max(x,y)\n#define BEGIN_STACK_EXTEND(size) void * stack_extend_memory_ = malloc(size);void * stack_extend_origin_memory_;char * stack_extend_dummy_memory_ = (char*)alloca((1+(int)(((long long)stack_extend_memory_)&127))*16);*stack_extend_dummy_memory_ = 0;asm volatile(\"mov %%rsp, %%rbx\\nmov %%rax, %%rsp\":\"=b\"(stack_extend_origin_memory_):\"a\"((char*)stack_extend_memory_+(size)-1024));\n#define END_STACK_EXTEND asm volatile(\"mov %%rax, %%rsp\"::\"a\"(stack_extend_origin_memory_));free(stack_extend_memory_);\nusing namespace std;\nstruct edge {int to,w,rev;};\ntypedef vector< vector<edge> > Graph;\nGraph G,oG;\nvoid add_edge(int x,int y,int w,int way){\n\tif(way==1){\n\t\tG[x].pb({y,w,-1});\n\t}else{\n\t\tint X=G[x].size(),Y=G[y].size();\n\t\tG[x].pb({y,w,Y});\n\t\tG[y].pb({x,w,X});\n\t}\n}\n\ntypedef pair<int,int> P;\nmap<P,int> memo;\nset<P> vis;\nint dfs(int v,int eid){\n\tif(memo.count(P(v,eid))) return memo[P(v,eid)];\n\tif(vis.count(P(v,eid))){\n\t\tputs(\"Infinite\");\n\t\texit(1);\n\t}\n\tvis.insert(P(v,eid));\n\tint ret=0;\n\trep(i,G[v].size()) if(i!=eid){\n\t\tedge& e=G[v][i];\n\t\tchmax(ret,dfs(e.to,e.rev)+e.w);\n\t}\n\tmemo[P(v,eid)]=ret;\n\treturn ret;\n}\n\nint rs[100001]={};\nint its[100000]={};\n\nint main(){\n\tBEGIN_STACK_EXTEND(1024*1024);\n\treturn 0;\n\tint N,M;\n\tcin>>N>>M;\n\toG.resize(N);\n\trep(i,M){\n\t\tint x,y,w;\n\t\tscanf(\"%d %d %d\",&x,&y,&w);\n\t\tx--,y--;\n\t\tif(w==1){\n\t\t\toG[x].pb(edge{y,1,-1});\n\t\t}else{\n\t\t\tint X=oG[x].size(),Y=oG[y].size();\n\t\t\toG[x].pb(edge{y,1,Y});\n\t\t\toG[y].pb(edge{x,1,X});\n\t\t}\n\t}\n\tint newN=0;\n\trep(i,N){\n\t\tint sz=oG[i].size();\n\t\tif(sz==0) sz=1;\n\t\trs[i]=newN;\n\t\tits[i]=rs[i];\n\t\tnewN+=sz;\n\t}\n\trs[N]=newN;\n\tG.resize(newN);\n\trep(x,N){\n\t\tint n=rs[x+1]-rs[x];\n\t\tfor(int v=rs[x];v<rs[x]+n-1;v++) add_edge(v,v+1,0,2);\n\t\tfor(edge e: oG[x]){\n\t\t\tif(e.rev==-1){\t//one way\n\t\t\t\tadd_edge(its[x],rs[e.to],1,1);\n\t\t\t\tits[x]++;\n\t\t\t}else{\n\t\t\t\tif(x<e.to){\n\t\t\t\t\tadd_edge(its[x],its[e.to],1,2);\n\t\t\t\t\tits[x]++;\n\t\t\t\t\tits[e.to]++;\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t}\n\tint ans=0;\n\tN=newN;\n\trep(i,N) chmax(ans,dfs(i,-1));\n\tcout<<ans<<endl;\n\tEND_STACK_EXTEND;\n}"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\n\nusing namespace std;\n\nconst int INF = 1 << 29;\n\nstruct UnionFind\n{\n  vector< int > data;\n\n  UnionFind(int sz)\n  {\n    data.assign(sz, -1);\n  }\n\n  int find(int k)\n  {\n    return (data[k] < 0 ? k : data[k] = find(data[k]));\n  }\n\n  void unite(int x, int y)\n  {\n    x = find(x);\n    y = find(y);\n    if(data[x] > data[y]) swap(x, y);\n    data[x] += data[y];\n    data[y] = x;\n  }\n};\n\nvector< pair< int, int > > g[100001];\nvector< int > leftt[100001], rightt[100000], just[100001];\nvector< int > gg[100001], rgg[100001], order;\nbool v[100001];\nint cmp[100001];\n\n\nvoid dfs(int idx)\n{\n  if(v[idx]++) return;\n  for(auto &to : gg[idx]) dfs(to);\n  order.push_back(idx);\n}\n\nvoid rdfs(int idx, int k)\n{\n  cmp[idx] = k;\n  for(auto &to : rgg[idx]) if(cmp[to] == -1) rdfs(to, k);\n}\n\nint rec(int idx, int back = -1)\n{\n  if(back != -1) {\n    int tmp = max(leftt[idx][back], rightt[idx][back + 1]);\n    if(tmp != INF) return (tmp);\n  }\n  if(rightt[idx][0] == INF) {\n    for(int i = 0; i < g[idx].size(); i++) {\n      int to, rev;\n      tie(to, rev) = g[idx][i];\n      if(to == back || just[idx][i] != INF) continue;\n      just[idx][i] = rec(to, g[idx][i].second) + 1;\n    }\n    for(int i = 0; i < g[idx].size(); i++) {\n      leftt[idx][i + 1] = max(leftt[idx][i], just[idx][i]);\n    }\n    for(int i = (int) g[idx].size() - 1; i >= 0; i--) {\n      rightt[idx][i] = max(rightt[idx][i + 1], just[idx][i]);\n    }\n  }\n\n  if(back == -1) return (rightt[idx][0]);\n  return (max(leftt[idx][back], rightt[idx][back + 1]));\n}\n\n\nint main()\n{\n  int N, M;\n  vector< pair< int, int > > edges, arcs;\n\n  scanf(\"%d %d\", &N, &M);\n\n  UnionFind uf(N);\n\n  for(int i = 0; i < M; i++) {\n    int x, y, t;\n    cin >> x >> y >> t;\n    --x, --y;\n    if(t == 1) {\n      arcs.emplace_back(x, y);\n      g[x].emplace_back(y, -1);\n    } else {\n      if(uf.find(x) == uf.find(y)) {\n        cout << \"Infinite\" << endl;\n        return (0);\n      }\n      uf.unite(x, y);\n      edges.emplace_back(x, y);\n      g[y].emplace_back(x, g[x].size());\n      g[x].emplace_back(y, g[y].size() - 1);\n    }\n  }\n\n  {\n    for(auto &e : arcs) gg[uf.find(e.first)].push_back(uf.find(e.second));\n    for(auto &e : arcs) rgg[uf.find(e.second)].push_back(uf.find(e.first));\n    for(int i = 0; i < N; i++) dfs(i);\n    reverse(begin(order), end(order));\n    memset(cmp, -1, sizeof(cmp));\n    int kk = 0;\n    for(auto &i : order) if(cmp[i] == -1) rdfs(i, kk++);\n    if(kk != N) {\n      cout << \"Infinite\" << endl;\n      return (0);\n    }\n  }\n\n  int ret = 0;\n  for(int i = 0; i < N; i++) {\n    int sz = g[i].size();\n    just[i].assign(sz, INF);\n    leftt[i].assign(sz + 1, INF);\n    rightt[i].assign(sz + 1, INF);\n    leftt[i][0] = rightt[i][sz] = 0;\n  }\n  for(int i = 0; i < N; i++) ret = max(ret, rec(i));\n  cout << ret << endl;\n}"
  },
  {
    "language": "C++",
    "code": "#include <string>\n#include <vector>\n#include<iostream>\n#include<cstdio>\n#include<cstdlib>\n#include<stack>\n#include<queue>\n#include<cmath>\n#include<algorithm>\n#include<functional>\n#include<list>\n#include<deque>\n#include<bitset>\n#include<set>\n#include<map>\n#include<unordered_map>\n#include<unordered_set>\n#include<cstring>\n#include<sstream>\n#include<complex>\n#include<iomanip>\n#include<numeric>\n#include<cassert>\n#define X first\n#define Y second\n#define pb push_back\n#define rep(X,Y) for (int (X) = 0;(X) < (Y);++(X))\n#define reps(X,S,Y) for (int (X) = S;(X) < (Y);++(X))\n#define rrep(X,Y) for (int (X) = (Y)-1;(X) >=0;--(X))\n#define rreps(X,S,Y) for (int (X) = (Y)-1;(X) >= (S);--(X))\n#define repe(X,Y) for ((X) = 0;(X) < (Y);++(X))\n#define peat(X,Y) for (;(X) < (Y);++(X))\n#define all(X) (X).begin(),(X).end()\n#define rall(X) (X).rbegin(),(X).rend()\n#define eb emplace_back\n#define UNIQUE(X) (X).erase(unique(all(X)),(X).end())\n#define Endl endl\n\nusing namespace std;\ntypedef long long ll;\ntypedef pair<int,int> pii;\ntypedef pair<ll,ll> pll;\ntemplate<class T> using vv=vector<vector<T>>;\ntemplate<class T> ostream& operator<<(ostream &os, const vector<T> &t) {\nos<<\"{\"; rep(i,t.size()) {os<<t[i]<<\",\";} os<<\"}\"<<endl; return os;}\ntemplate<class T,size_t n> ostream& operator<<(ostream &os, const array<T,n> &t) {\n\tos<<\"{\"; rep(i,n) {os<<t[i]<<\",\";} os<<\"}\"<<endl; return os;}\ntemplate<class S, class T> ostream& operator<<(ostream &os, const pair<S,T> &t) { return os<<\"(\"<<t.first<<\",\"<<t.second<<\")\";}\ntemplate<class S, class T,class U> ostream& operator<<(ostream &os, const tuple<S,T,U> &t) { return os<<\"(\"<<get<0>(t)<<\",\"<<get<1>(t)<<\",\"<<get<2>(t)<<\")\";}\ntemplate<class S, class T,class U,class V> ostream& operator<<(ostream &os, const tuple<S,T,U,V> &t) { return os<<\"(\"<<get<0>(t)<<\",\"<<get<1>(t)<<\",\"<<get<2>(t)<<\",\"<<get<3>(t)<<\")\";}\ntemplate<class S, class T,class U,class V,class W> ostream& operator<<(ostream &os, const tuple<S,T,U,V,W> &t) { return os<<\"(\"<<get<0>(t)<<\",\"<<get<1>(t)<<\",\"<<get<2>(t)<<\",\"<<get<3>(t)<<\",\"<<get<4>(t)<<\")\";}\ntemplate<class T> inline bool MX(T &l,const T &r){return l<r?l=r,1:0;}\ntemplate<class T> inline bool MN(T &l,const T &r){return l>r?l=r,1:0;}\n//#undef NUIP\n#ifdef NUIP\n#define out(args...){vector<string> a_r_g_s=s_p_l_i_t(#args, ','); e_r_r(a_r_g_s.begin(), args); }\nvector<string> s_p_l_i_t(const string &s, char c){vector<string> v;int d=0,f=0;string t;for(char c:s){if(!d&&c==',')v.pb(t),t=\"\";else t+=c;if(c=='\\\"'||c=='\\'')f^=1;if(!f&&c=='(')++d;if(!f&&c==')')--d;}v.pb(t);return move(v);}\nvoid e_r_r(vector<string>::iterator it) {}\ntemplate<typename T, typename... Args> void e_r_r(vector<string>::iterator it, T a, Args... args){ if(*it==\" 1\"||*it==\"1\") cerr<<endl; else cerr << it -> substr((*it)[0] == ' ', it -> length()) << \" = \" << a << \", \"; e_r_r(++it, args...);}\n#else\n#define out\n#endif\n#ifdef __cpp_init_captures\ntemplate<typename T>vector<T> table(int n, T v){ return vector<T>(n, v);}\ntemplate <class... Args> auto table(int n, Args... args){auto val = table(args...); return vector<decltype(val)>(n, move(val));}\n#endif\nconst ll MOD=1e9+7;\n\nstruct UF{\n  vector<int> data;\n  UF(int size):data(size,-1){}\n  bool unite(int x,int y){\n    x=root(x); y=root(y);\n    if(x!=y){\n      if(-data[y]>-data[x]) swap(x,y);\n      data[x]+=data[y]; data[y]=x;\n    }\n    return x!=y;\n  }\n  bool findSet(int x,int y){return root(x)==root(y);}\n  int root(int x){return data[x]<0?x:data[x]=root(data[x]);}\n  int size(int x) {return -data[root(x)];}\n};\n\nint main(){\n  ios_base::sync_with_stdio(false);\n  cout<<fixed<<setprecision(0);\n\tint n,m;\n\tcin>>n>>m;\n\tvv<int> g(n),h(n);\n\tvector<int> bi(n);\n\tUF uf(n);\n\tint ok=1;\n\trep(i,m){\n\t\tint a,b,c;\n\t\tcin>>a>>b>>c; --a; --b;\n\t\tif(c==1){\n\t\t\tg[a].pb(b);\n\t\t}else{\n\t\t\tbi[a]=bi[b]=1;\n\t\t\th[a].pb(b);\n\t\t\th[b].pb(a);\n\t\t\tif(!uf.unite(a,b)) ok=0;\n\t\t}\n\t}\n\tif(!ok){\n\t\tcout<<\"Infinite\"<<Endl;\n\t\treturn 0;\n\t}\n\tdeque<int> que,todo;\n\tvector<int> usd(n),ind(n),cnt(n);\n\trep(v,n)for(int w:g[v]) ++ind[w];\n\tvv<int> mem(n);\n\trep(i,n) mem[uf.root(i)].pb(i);\n\trep(i,n)if(ind[i]==0 && MX(usd[i],1)){\n\t\tif(bi[i]){\n\t\t\tif(++cnt[uf.root(i)]==uf.size(i)){\n\t\t\t\ttodo.eb(uf.root(i));\n\t\t\t}\n\t\t}else{\n\t\t\tque.eb(i);\n\t\t}\n\t}\n\tvector<int> dp(n);\n\tvector<int> cs(n,-1),up(n,-1);\n\tfunction<int(int,int)> dfs=\n\t\t[&](int v,int p){\n\t\t\tint mx=dp[v];\n\t\t\tfor(int w:h[v])if(w!=p) MX(mx,dfs(w,v)+1);\n\t\t\treturn up[v]=mx;\n\t\t};\n\tfunction<void(int,int,int)> dfs2=\n\t\t[&](int v,int p,int dn){\n\t\t\tpii fst(dp[v],-1),snd(dn,p);\n\t\t\tif(fst<snd) swap(fst,snd);\n\t\t\tfor(int w:h[v])if(w!=p){\n\t\t\t\t\tpii p(up[w]+1,w);\n\t\t\t\t\tif(fst<p){\n\t\t\t\t\t\tsnd=fst; fst=p;\n\t\t\t\t\t}else if(snd<p){\n\t\t\t\t\t\tsnd=p;\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\tdp[v]=fst.X;\n\t\t\tfor(int w:h[v])if(w!=p) dfs2(w,v,(fst.Y==w?snd.X:fst.X)+1);\n\t\t};\n\twhile(1){\n\t\twhile(que.size()){\n\t\t\tint v=que.front(); que.pop_front();\n\t\t\tout(v,dp[v],1);\n\t\t\tfor(int w:g[v]){\n\t\t\t\tMX(dp[w],dp[v]+1);\n\t\t\t\tif(--ind[w]==0 && MX(usd[w],1)){\n\t\t\t\t\tif(bi[w]){\n\t\t\t\t\t\tif(++cnt[uf.root(w)]==uf.size(w)){\n\t\t\t\t\t\t\ttodo.eb(uf.root(w));\n\t\t\t\t\t\t}\n\t\t\t\t\t}else{\n\t\t\t\t\t\tque.eb(w);\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t\tif(todo.empty()) break;\n\t\tout(dp,1);\n\t\twhile(todo.size()){\n\t\t\tint x=todo.front(); todo.pop_front();\n\t\t\tdfs(x,-1);\n\t\t\tout(x,up,1);\n\t\t\tdfs2(x,-1,0);\n\t\t\tfor(int y:mem[x]) que.eb(y);\n\t\t}\n\t\tout(cs,dp,1);\n\t}\n\tout(cs,1);\n\tif(*min_element(all(usd))==0) ok=0;\n\tif(!ok){\n\t\tcout<<\"Infinite\"<<Endl;\n\t\treturn 0;\n\t}\n\tcout<<*max_element(all(dp))<<endl;\n  return 0;\n}\n\n"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\n#define rep(i,N) for(int i=0;i<(int)N;i++)\n#define rep1(i,N) for(int i=1;i<=(int)N;i++)\n#define pb push_back\n#define all(c) c.begin(),c.end()\n#define show(x) cout<<#x<<\" \"<<x<<endl\n#define chmax(x,y) x=max(x,y)\n#define BEGIN_STACK_EXTEND(size) void * stack_extend_memory_ = malloc(size);void * stack_extend_origin_memory_;char * stack_extend_dummy_memory_ = (char*)alloca((1+(int)(((long long)stack_extend_memory_)&127))*16);*stack_extend_dummy_memory_ = 0;asm volatile(\"mov %%rsp, %%rbx\\nmov %%rax, %%rsp\":\"=b\"(stack_extend_origin_memory_):\"a\"((char*)stack_extend_memory_+(size)-1024));\n#define END_STACK_EXTEND asm volatile(\"mov %%rax, %%rsp\"::\"a\"(stack_extend_origin_memory_));free(stack_extend_memory_);\nusing namespace std;\nstruct edge {int to,w,rev;};\ntypedef vector< vector<edge> > Graph;\nGraph G,oG;\nvoid add_edge(int x,int y,int w,int way){\n\tif(way==1){\n\t\tG[x].pb({y,w,-1});\n\t}else{\n\t\tint X=G[x].size(),Y=G[y].size();\n\t\tG[x].pb({y,w,Y});\n\t\tG[y].pb({x,w,X});\n\t}\n}\n\ntypedef pair<int,int> P;\nmap<P,int> memo;\nset<P> vis;\nint dfs(int v,int eid){\n\tif(memo.count(P(v,eid))) return memo[P(v,eid)];\n\tif(vis.count(P(v,eid))){\n\t\tputs(\"Infinite\");\n\t\texit(1);\n\t}\n\tvis.insert(P(v,eid));\n\tint ret=0;\n\trep(i,G[v].size()) if(i!=eid){\n\t\tedge& e=G[v][i];\n\t\tchmax(ret,dfs(e.to,e.rev)+e.w);\n\t}\n\tmemo[P(v,eid)]=ret;\n\treturn ret;\n}\n\nint rs[100001]={};\nint its[100000]={};\n\nint main(){\n\tBEGIN_STACK_EXTEND(512*1024*1024);\n\tint N,M;\n\tcin>>N>>M;\n\tassert(N<100000);\n\toG.resize(N);\n\trep(i,M){\n\t\tint x,y,w;\n\t\tscanf(\"%d %d %d\",&x,&y,&w);\n\t\tx--,y--;\n\t\tif(w==1){\n\t\t\toG[x].pb(edge{y,1,-1});\n\t\t}else{\n\t\t\tint X=oG[x].size(),Y=oG[y].size();\n\t\t\toG[x].pb(edge{y,1,Y});\n\t\t\toG[y].pb(edge{x,1,X});\n\t\t}\n\t}\n\tint newN=0;\n\trep(i,N){\n\t\tint sz=oG[i].size();\n\t\tif(sz==0) sz=1;\n\t\trs[i]=newN;\n\t\tits[i]=rs[i];\n\t\tnewN+=sz;\n\t}\n\trs[N]=newN;\n\tG.resize(newN);\n\trep(x,N){\n\t\tint n=rs[x+1]-rs[x];\n\t\tfor(int v=rs[x];v<rs[x]+n-1;v++) add_edge(v,v+1,0,2);\n\t\tfor(edge e: oG[x]){\n\t\t\tif(e.rev==-1){\t//one way\n\t\t\t\tadd_edge(its[x],rs[e.to],1,1);\n\t\t\t\tits[x]++;\n\t\t\t}else{\n\t\t\t\tif(x<e.to){\n\t\t\t\t\tadd_edge(its[x],its[e.to],1,2);\n\t\t\t\t\tits[x]++;\n\t\t\t\t\tits[e.to]++;\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t}\n\tint ans=0;\n\tN=newN;\n\trep(i,N){\n\t\tchmax(ans,dfs(i,-1));\n\t}\n\tcout<<ans<<endl;\n\tEND_STACK_EXTEND;\n}"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\n#define rep(i,N) for(int i=0;i<(int)N;i++)\n#define rep1(i,N) for(int i=1;i<=(int)N;i++)\n#define pb push_back\n#define all(c) c.begin(),c.end()\n#define show(x) cout<<#x<<\" \"<<x<<endl\n#define chmax(x,y) x=max(x,y)\n#define BEGIN_STACK_EXTEND(size) void * stack_extend_memory_ = malloc(size);void * stack_extend_origin_memory_;char * stack_extend_dummy_memory_ = (char*)alloca((1+(int)(((long long)stack_extend_memory_)&127))*16);*stack_extend_dummy_memory_ = 0;asm volatile(\"mov %%rsp, %%rbx\\nmov %%rax, %%rsp\":\"=b\"(stack_extend_origin_memory_):\"a\"((char*)stack_extend_memory_+(size)-1024));\n#define END_STACK_EXTEND asm volatile(\"mov %%rax, %%rsp\"::\"a\"(stack_extend_origin_memory_));free(stack_extend_memory_);\nusing namespace std;\nstruct edge {int to,w,rev;};\ntypedef vector< vector<edge> > Graph;\nGraph G,oG;\nvoid add_edge(int x,int y,int w,int way){\n\tif(way==1){\n\t\tG[x].pb({y,w,-1});\n\t}else{\n\t\tint X=G[x].size(),Y=G[y].size();\n\t\tG[x].pb({y,w,Y});\n\t\tG[y].pb({x,w,X});\n\t}\n}\n\ntypedef pair<int,int> P;\nmap<P,int> memo;\nset<P> vis;\nint dfs(int v,int eid){\n\tif(memo.count(P(v,eid))) return memo[P(v,eid)];\n\tif(vis.count(P(v,eid))){\n\t\tputs(\"Infinite\");\n\t\texit(1);\n\t}\n\tvis.insert(P(v,eid));\n\tint ret=0;\n\trep(i,G[v].size()) if(i!=eid){\n\t\tedge& e=G[v][i];\n\t\tchmax(ret,dfs(e.to,e.rev)+e.w);\n\t}\n\tmemo[P(v,eid)]=ret;\n\treturn ret;\n}\n\nint rs[100001]={};\nint its[100000]={};\n\nint main(){\n//\tBEGIN_STACK_EXTEND(512*1024*1024);\n\tint N,M;\n\tcin>>N>>M;\n\toG.resize(N);\n\trep(i,M){\n\t\tint x,y,w;\n\t\tscanf(\"%d %d %d\",&x,&y,&w);\n\t\tx--,y--;\n\t\tif(w==1){\n\t\t\toG[x].pb(edge{y,1,-1});\n\t\t}else{\n\t\t\tint X=oG[x].size(),Y=oG[y].size();\n\t\t\toG[x].pb(edge{y,1,Y});\n\t\t\toG[y].pb(edge{x,1,X});\n\t\t}\n\t}\n\tint newN=0;\n\trep(i,N){\n\t\tint sz=oG[i].size();\n\t\tif(sz==0) sz=1;\n\t\trs[i]=newN;\n\t\tits[i]=rs[i];\n\t\tnewN+=sz;\n\t}\n\trs[N]=newN;\n\tG.resize(newN);\n\trep(x,N){\n\t\tint n=rs[x+1]-rs[x];\n\t\tfor(int v=rs[x];v<rs[x]+n-1;v++) add_edge(v,v+1,0,2);\n\t\tfor(edge e: oG[x]){\n\t\t\tif(e.rev==-1){\t//one way\n\t\t\t\tadd_edge(its[x],rs[e.to],1,1);\n\t\t\t\tits[x]++;\n\t\t\t}else{\n\t\t\t\tif(x<e.to){\n\t\t\t\t\tadd_edge(its[x],its[e.to],1,2);\n\t\t\t\t\tits[x]++;\n\t\t\t\t\tits[e.to]++;\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t}\n\tint ans=0;\n\tN=newN;\n//\trep(i,N) chmax(ans,dfs(i,-1));\n\tcout<<ans<<endl;\n//\tEND_STACK_EXTEND;\n}"
  },
  {
    "language": "C++",
    "code": "#include<bits/stdc++.h>\nusing namespace std;\n#define MAX_N 100005\n#define MAX_M 100005\n\nint n,m;\nint x[MAX_M],y[MAX_M],w[MAX_M];\n\nvector<int> G[MAX_N];\nvector<int> g[MAX_N];\n\nvector<int> group[MAX_N];\nint id[MAX_N];\nbool visited[MAX_N];\nvector<int> vd;\n\nint dp[MAX_N];\n\nbool dfs(int pos,int prev,int root){\n  id[pos]=root;\n  visited[pos]=true;\n  group[root].push_back(pos);\n  for(int i=0;i<(int)G[pos].size();i++){\n    int to=G[pos][i];\n    if(to==prev)continue;\n    if(i&&to==G[pos][i-1])return true;\n    if(visited[to])return true;\n    if(dfs(to,pos,root))return true;\n  }\n  return false;\n}\n\nbool check(){\n  memset(visited,false,sizeof(visited));\n  for(int i=0;i<n;i++){\n    if(visited[i])continue;\n    if( dfs(i,-1,i) )return true;\n  }\n\n  vector< int > deg(n);\n  vector< vector<int> > graph(n);\n  \n  for(int i=0;i<m;i++){\n    if(w[i]==1){\n      int X=id[ x[i] ];\n      int Y=id[ y[i] ];\n      if(X==Y)return true;\n      graph[X].push_back(Y);\n      deg[Y]++;\n    }\n  }\n\n  queue<int> Q;\n  for(int i=0;i<n;i++)\n    if(deg[i]==0&&id[i]==i)\n      Q.push(i);\n\n  while(!Q.empty()){\n    int pos=Q.front();Q.pop();\n    vd.push_back(pos);\n    for(int to:graph[pos]){\n      deg[to]--;\n      if(deg[to]==0)Q.push(to);\n    }\n  }\n  \n  for(int i=0;i<n;i++)\n    if(deg[i]>0)return true;\n  \n  return false;\n}\n\nint d[MAX_N];\n\nvoid init(int root){\n  root=id[root];\n  for(int pos:group[root])\n    d[pos]=-1;\n}\n\nvoid bfs(int S){\n  init(S);\n  queue<int> Q;\n  Q.push(S);\n  d[S]=0;\n  while(!Q.empty()){\n    int pos=Q.front();Q.pop();\n    for(int to:G[pos]){\n      if(d[to]!=-1)continue;\n      d[to]=d[pos]+1;\n      Q.push(to);\n    }\n  }\n}\n\nvoid update(int root,int dif){\n  for(int pos:group[root])\n    for(int to:g[pos])\n      dp[to]=max(dp[to],d[pos]+dif+1);\n}\n\nint solve(int S,int &ans){\n  bfs(S);\n  update(id[S],dp[S]);\n  \n  int maxmid=S;\n  for(int pos:group[S])\n    if(d[pos]+dp[pos]>d[maxmid]+dp[maxmid])\n      maxmid=pos;\n  ans=max(ans,d[maxmid]+dp[maxmid]);\n  return maxmid;\n}\n\n  /*\n  int res=0;\n  bfs(root);\n  int maxm=-1,maxmid;\n  for(int pos:group[root])\n    if(d[pos]+dp[pos]>maxm)maxm=d[pos]+dp[pos],maxmid=pos;\n  \n  bfs(maxmid);\n  update(root,dp[maxmid]);\n  for(int pos:group[root])res=max(res,d[pos]+dp[maxmid]);\n  \n  maxm=-1;\n  for(int pos:group[root])\n    if(d[pos]+dp[pos]>maxm)maxm=d[pos]+dp[pos],maxmid=pos;\n\n  bfs(maxmid);\n  update(root,dp[maxmid]);\n  for(int pos:group[root])res=max(res,d[pos]+dp[maxmid]);\n  \n  return res;\n  */\n\n\nint main(){\n  scanf(\"%d %d\",&n,&m);\n  for(int i=0;i<m;i++){\n    scanf(\"%d %d %d\",&x[i],&y[i],&w[i]);\n    x[i]--,y[i]--;\n    if(w[i]==1){\n      g[x[i]].push_back(y[i]);\n    }\n    if(w[i]==2){\n      G[x[i]].push_back(y[i]);\n      G[y[i]].push_back(x[i]);\n    }\n  }\n  \n  if( check() ){\n    printf(\"Infinite\\n\");\n    return 0;\n  }\n\n  int ans=0;\n  for(int root : vd ){\n    if(root!=id[root])continue;\n    solve(solve(solve(root,ans),ans),ans);\n  }\n  printf(\"%d\\n\",ans);  \n  return 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\n\nusing namespace std;\n\nconst int INF = 1 << 29;\n\nstruct UnionFind\n{\n  vector< int > data;\n\n  UnionFind(int sz)\n  {\n    data.assign(sz, -1);\n  }\n\n  int find(int k)\n  {\n    return (data[k] < 0 ? k : data[k] = find(data[k]));\n  }\n\n  void unite(int x, int y)\n  {\n    x = find(x);\n    y = find(y);\n    if(data[x] > data[y]) swap(x, y);\n    data[x] += data[y];\n    data[y] = x;\n  }\n};\n\nvector< pair< int, int > > g[100001];\nvector< int > leftt[100001], rightt[100000], just[100001];\nvector< int > gg[100001], rgg[100001], order;\nbool v[100001];\nint cmp[100001];\n\n\nvoid dfs(int idx)\n{\n  if(v[idx]++) return;\n  for(auto &to : gg[idx]) dfs(to);\n  order.push_back(idx);\n}\n\nvoid rdfs(int idx, int k)\n{\n  cmp[idx] = k;\n  for(auto &to : rgg[idx]) if(cmp[to] == -1) rdfs(to, k);\n}\n\nint rec(int idx, int back = -1)\n{\n  if(back != -1) {\n    int tmp = max(leftt[idx][back], rightt[idx][back + 1]);\n    if(tmp != INF) return (tmp);\n  }\n  if(rightt[idx][0] == INF) {\n    for(int i = 0; i < g[idx].size(); i++) {\n      int to, rev;\n      tie(to, rev) = g[idx][i];\n      if(to == back || just[idx][i] != INF) continue;\n      just[idx][i] = rec(to, g[idx][i].second) + 1;\n    }\n    for(int i = 0; i < g[idx].size(); i++) {\n      leftt[idx][i + 1] = max(leftt[idx][i], just[idx][i]);\n    }\n    for(int i = (int) g[idx].size() - 1; i >= 0; i--) {\n      rightt[idx][i] = max(rightt[idx][i + 1], just[idx][i]);\n    }\n  }\n\n  if(back == -1) return (rightt[idx][0]);\n  return (max(leftt[idx][back], rightt[idx][back + 1]));\n}\n\n\nint main()\n{\n  int N, M;\n  vector< pair< int, int > > edges, arcs;\n\n  scanf(\"%d %d\", &N, &M);\n\n  UnionFind uf(N);\n\n  for(int i = 0; i < M; i++) {\n    int x, y, t;\n    cin >> x >> y >> t;\n    --x, --y;\n    if(t == 1) {\n      arcs.emplace_back(x, y);\n      g[x].emplace_back(y, -1);\n    } else {\n      if(uf.find(x) == uf.find(y)) {\n        cout << \"Infinite\" << endl;\n        return (0);\n      }\n      uf.unite(x, y);\n      edges.emplace_back(x, y);\n      g[y].emplace_back(x, g[x].size());\n      g[x].emplace_back(y, g[y].size() - 1);\n    }\n  }\n\n  {\n    for(auto &e : arcs) gg[uf.find(e.first)].push_back(uf.find(e.second));\n    for(auto &e : arcs) rgg[uf.find(e.second)].push_back(uf.find(e.first));\n    for(int i = 0; i < N; i++) dfs(i);\n    reverse(begin(order), end(order));\n    memset(cmp, -1, sizeof(cmp));\n    int kk = 0;\n    for(auto &i : order) if(cmp[i] == -1) rdfs(i, kk++);\n    if(kk != N) {\n      cout << \"Infinite\" << endl;\n      return (0);\n    }\n  }\n\n  int ret = 0;\n  for(int i = 0; i < N; i++) {\n    int sz = g[i].size();\n    just[i].assign(sz + 5, INF);\n    leftt[i].assign(sz + 5, INF);\n    rightt[i].assign(sz + 5, INF);\n    leftt[i][0] = rightt[i][sz] = 0;\n  }\n  for(int i = 0; i < N; i++) ret = max(ret, rec(i));\n  cout << ret << endl;\n}"
  },
  {
    "language": "C++",
    "code": "#include<bits/stdc++.h>\nusing namespace std;\n#define MAX_N 100005\n#define MAX_M 100005\n\nint n,m;\nint x[MAX_M],y[MAX_M],w[MAX_M];\n\nvector<int> G[MAX_N];\nvector<int> g[MAX_N];\n\nvector<int> group[MAX_N];\nint id[MAX_N];\nbool visited[MAX_N];\nvector<int> vd;\n\nint dp[MAX_N];\n\nbool dfs(int pos,int prev,int root){\n  id[pos]=root;\n  visited[pos]=true;\n  group[root].push_back(pos);\n  for(int i=0;i<(int)G[pos].size();i++){\n    int to=G[pos][i];\n    if(to==prev)continue;\n    if(i&&to==G[pos][i-1])return true;\n    if(visited[to])return true;\n    if(dfs(to,pos,root))return true;\n  }\n  return false;\n}\n\nbool check(){\n  memset(visited,false,sizeof(visited));\n  for(int i=0;i<n;i++){\n    if(visited[i])continue;\n    if( dfs(i,-1,i) )return true;\n  }\n\n  vector< int > deg(n);\n  vector< vector<int> > graph(n);\n  \n  for(int i=0;i<m;i++){\n    if(w[i]==1){\n      int X=id[ x[i] ];\n      int Y=id[ y[i] ];\n      if(X==Y)return true;\n      graph[X].push_back(Y);\n      deg[Y]++;\n    }\n  }\n\n  queue<int> Q;\n  for(int i=0;i<n;i++)\n    if(deg[i]==0&&id[i]==i)\n      Q.push(i);\n\n  while(!Q.empty()){\n    int pos=Q.front();Q.pop();\n    vd.push_back(pos);\n    for(int to:graph[pos]){\n      deg[to]--;\n      if(deg[to]==0)Q.push(to);\n    }\n  }\n  \n  for(int i=0;i<n;i++)\n    if(deg[i]>0)return true;\n  \n  return false;\n}\n\nint d[MAX_N];\n\nvoid init(int root){\n  root=id[root];\n  for(int pos:group[root])\n    d[pos]=-1;\n}\n\nvoid bfs(int S){\n  init(S);\n  queue<int> Q;\n  Q.push(S);\n  d[S]=0;\n  while(!Q.empty()){\n    int pos=Q.front();Q.pop();\n    for(int to:G[pos]){\n      if(d[to]!=-1)continue;\n      d[to]=d[pos]+1;\n      Q.push(to);\n    }\n  }\n}\n\nint solve(int S,int &ans){\n  bfs(S);\n  int res=S;\n  for(int pos:group[id[S]]){\n    if(d[pos]+dp[pos]>d[res]+dp[res])res=pos;\n    ans=max(ans,d[pos]+dp[S]);\n    for(int to:g[pos])dp[to]=max(dp[to],d[pos]+dp[S]+1);\n  }\n  return res;\n}\n\n  /*\n  int res=0;\n  bfs(root);\n  int maxm=-1,maxmid;\n  for(int pos:group[root])\n    if(d[pos]+dp[pos]>maxm)maxm=d[pos]+dp[pos],maxmid=pos;\n  \n  bfs(maxmid);\n  update(root,dp[maxmid]);\n  for(int pos:group[root])res=max(res,d[pos]+dp[maxmid]);\n  \n  maxm=-1;\n  for(int pos:group[root])\n    if(d[pos]+dp[pos]>maxm)maxm=d[pos]+dp[pos],maxmid=pos;\n\n  bfs(maxmid);\n  update(root,dp[maxmid]);\n  for(int pos:group[root])res=max(res,d[pos]+dp[maxmid]);\n  \n  return res;\n  */\n\n\nint main(){\n  scanf(\"%d %d\",&n,&m);\n  for(int i=0;i<m;i++){\n    scanf(\"%d %d %d\",&x[i],&y[i],&w[i]);\n    x[i]--,y[i]--;\n    if(w[i]==1){\n      g[x[i]].push_back(y[i]);\n    }\n    if(w[i]==2){\n      G[x[i]].push_back(y[i]);\n      G[y[i]].push_back(x[i]);\n    }\n  }\n  \n  if( check() ){\n    printf(\"Infinite\\n\");\n    return 0;\n  }\n\n  int ans=0;\n  for(int root : vd ){\n    if(root!=id[root])continue;\n    solve( solve( solve(root,ans) , ans ) , ans);\n  }\n  printf(\"%d\\n\",ans);  \n  return 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include<bits/stdc++.h>\nusing namespace std;\nusing Int = long long;\n\nstruct QuickFind{\n  Int n;\n  vector<Int> r,p;\n  vector<vector<Int> > v;\n  QuickFind(){}\n  QuickFind(Int sz):n(sz),r(sz),p(sz),v(sz){\n    for(Int i=0;i<n;i++){\n      r[i]=1,p[i]=i;\n      v[i].resize(1,i);\n    }\n  }\n  bool same(Int x,Int y){\n    return p[x]==p[y];\n  }\n  void unite(Int x,Int y){\n    x=p[x];y=p[y];\n    if(x==y) return;\n    if(r[x]<r[y]) swap(x,y);\n    r[x]+=r[y];\n    for(Int i=0;i<(Int)v[y].size();i++){\n      p[v[y][i]]=x;\n      v[x].push_back(v[y][i]);\n    }\n    v[y].clear();\n  }\n  Int find(Int v){return p[v];};\n};\n\nstruct SCC{\n  Int n;\n  vector<vector<Int> > G,rG,T,C;\n  vector<Int> vs,used,belong;\n  SCC(){}\n  SCC(Int sz):n(sz),G(sz),rG(sz),used(sz),belong(sz){}\n  \n  void add_edge(Int from,Int to){\n    G[from].push_back(to);\n    rG[to].push_back(from);\n  }\n  \n  void input(Int m,Int offset=0){\n    Int a,b;\n    for(Int i=0;i<m;i++){\n      cin>>a>>b;\n      add_edge(a+offset,b+offset);\n    }\n  }\n  \n  void dfs(Int v){\n    used[v]=1;\n    for(Int i=0;i<(Int)G[v].size();i++){\n      if(!used[G[v][i]]) dfs(G[v][i]);\n    }\n    vs.push_back(v);\n  }\n  \n  void rdfs(Int v,Int k){\n    used[v]=1;\n    belong[v]=k;\n    C[k].push_back(v);\n    for(Int i=0;i<(Int)rG[v].size();i++){\n      if(!used[rG[v][i]]) rdfs(rG[v][i],k);\n    }\n  }\n  \n  Int build(){\n    fill(used.begin(),used.end(),0);\n    vs.clear();\n    for(Int v=0;v<n;v++){\n      if(!used[v]) dfs(v);\n    }\n    fill(used.begin(),used.end(),0);\n    Int k=0;\n    for(Int i=vs.size()-1;i>=0;i--){\n      if(!used[vs[i]]){\n\tT.push_back(vector<Int>());\n\tC.push_back(vector<Int>());\n\trdfs(vs[i],k++);\n      }\n    }\n    for(Int i=0;i<n;i++)\n      for(Int u:G[i])\n\tif(belong[i]!=belong[u])\n\t  T[belong[i]].push_back(belong[u]);\n    for(Int i=0;i<k;i++){\n      sort(T[i].begin(),T[i].end());\n      T[i].erase(unique(T[i].begin(),T[i].end()),T[i].end());\n    }\n    return k;\n  }\n};\n\nvoid inf(){\n  cout<<\"Infinite\"<<endl;\n  exit(0);\n}\n\ntemplate<typename T1,typename T2> inline void chmin(T1 &a,T2 b){if(a>b) a=b;}\ntemplate<typename T1,typename T2> inline void chmax(T1 &a,T2 b){if(a<b) a=b;}\n\nsigned main(){\n  Int n,m;\n  cin>>n>>m;\n  vector<Int> x(m),y(m),w(m);\n  for(Int i=0;i<m;i++) cin>>x[i]>>y[i]>>w[i];\n  QuickFind uf(n);\n  vector<vector<Int> > G(n),H(n);\n  for(Int i=0;i<m;i++){\n    x[i]--;y[i]--;\n    if(w[i]==2){\n      if(uf.same(x[i],y[i])) inf();\n      uf.unite(x[i],y[i]);\n      G[x[i]].emplace_back(y[i]);\n      G[y[i]].emplace_back(x[i]);\n    }\n  }\n\n  vector<Int> v;\n  for(Int i=0;i<n;i++)\n    if(uf.find(i)==i) v.emplace_back(i);\n\n  Int k=v.size();\n  map<Int, Int> idx;\n  for(Int i=0;i<k;i++) idx[v[i]]=i;\n\n  SCC scc(k);\n  for(Int i=0;i<m;i++){\n    if(w[i]==2) continue;\n    H[x[i]].emplace_back(y[i]);\n    Int s=idx[uf.find(x[i])];\n    Int t=idx[uf.find(y[i])];\n    if(s==t) inf();\n    scc.add_edge(s,t);\n  }\n\n  Int t=scc.build();\n  if(t!=k) inf();\n\n  vector<Int> dp1(n,0),dp2(n,0);\n  vector<Int> vs;\n  for(Int i=0;i<k;i++)\n    vs.emplace_back(v[scc.C[i][0]]);\n\n  reverse(vs.begin(),vs.end());\n\n  function<Int(int,Int)> dfs=[&](Int v,Int p)->Int{\n    Int res=dp1[v];\n    for(Int u:G[v]){\n      if(u==p) continue;\n      chmax(res,dfs(u,v)+1);\n    }\n    return dp2[v]=res;\n  };\n  \n  function<void(Int,int,Int)> dfs2=[&](Int v,Int p,Int d)->void{\n    using P = pair<Int, Int>;\n    vector<P> ds;\n    ds.emplace_back(d,p);\n    ds.emplace_back(dp1[v],v);\n    for(Int u:G[v]){\n      if(u==p) continue;\n      ds.emplace_back(dp2[u]+1,u);\n    }\n    sort(ds.rbegin(),ds.rend());\n    for(Int u:G[v]){\n      if(u==p) continue;\n      dfs2(u,v,ds[u==ds[0].second].first+1);\n    }\n    chmax(dp2[v],d);\n  };\n  \n  for(Int x:vs){\n    for(Int v:uf.v[x])\n      for(Int u:H[v])\n\tchmax(dp1[v],dp2[u]+1);\n    //cout<<x<<endl;\n    dfs(x,-1);\n    dfs2(x,-1,0);\n  }\n\n  if(0) \n    for(Int i=0;i<n;i++)\n      cout<<i<<\":\"<<dp1[i]<<\" \"<<dp2[i]<<endl;\n  \n  Int ans=0;\n  for(Int x:dp2) chmax(ans,x);\n  cout<<ans<<endl;\n  return 0;\n}\n\n"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\n#define rep(i,N) for(int i=0;i<(int)N;i++)\n#define rep1(i,N) for(int i=1;i<=(int)N;i++)\n#define pb push_back\n#define all(c) c.begin(),c.end()\n#define show(x) cout<<#x<<\" \"<<x<<endl\n#define chmax(x,y) x=max(x,y)\n#define BEGIN_STACK_EXTEND(size) void * stack_extend_memory_ = malloc(size);void * stack_extend_origin_memory_;char * stack_extend_dummy_memory_ = (char*)alloca((1+(int)(((long long)stack_extend_memory_)&127))*16);*stack_extend_dummy_memory_ = 0;asm volatile(\"mov %%rsp, %%rbx\\nmov %%rax, %%rsp\":\"=b\"(stack_extend_origin_memory_):\"a\"((char*)stack_extend_memory_+(size)-1024));\n#define END_STACK_EXTEND asm volatile(\"mov %%rax, %%rsp\"::\"a\"(stack_extend_origin_memory_));free(stack_extend_memory_);\nusing namespace std;\nconst int MN=100000;\nstruct edge {int to,w,rev;};\ntypedef vector< vector<edge> > Graph;\nGraph G,oG;\nvoid add_edge(int x,int y,int w,int way){\n\tif(way==1){\n\t\tG[x].pb({y,w,-1});\n\t}else{\n\t\tint X=G[x].size(),Y=G[y].size();\n\t\tG[x].pb({y,w,Y});\n\t\tG[y].pb({x,w,X});\n\t}\n}\n\ntypedef pair<int,int> P;\nint memo[300000][4];\nbool vis[300000][4];\nint dfs(int v,int eid){\n\teid++;\n\tif(memo[v][eid]!=-1) return memo[v][eid];\n\tif(vis[v][eid]){\n\t\tputs(\"Infinite\");\n\t\texit(1);\n\t}\n\tvis[v][eid]=1;\n\tint ret=0;\n\t// rep(i,G[v].size()) if(i!=eid-1){\n\t// \tedge& e=G[v][i];\n\t// \tchmax(ret,dfs(e.to,e.rev)+e.w);\n\t// }\n\tif(G[v].size()>0 && eid!=1) chmax(ret,dfs(G[v][0].to,G[v][0].rev)+G[v][0].w);\n\tif(G[v].size()>1 && eid!=2) chmax(ret,dfs(G[v][1].to,G[v][1].rev)+G[v][1].w);\n\tif(G[v].size()>2 && eid!=3) chmax(ret,dfs(G[v][2].to,G[v][2].rev)+G[v][2].w);\n\tmemo[v][eid]=ret;\n\treturn ret;\n}\n\nint rs[100001]={};\nint its[100000]={};\n\nint main(){\n//\tBEGIN_STACK_EXTEND(512*1024*1024);\n\tint N,M;\n\tcin>>N>>M;\n\toG.resize(N);\n\trep(i,M){\n\t\tint x,y,w;\n\t\tscanf(\"%d %d %d\",&x,&y,&w);\n\t\tx--,y--;\n\t\tif(w==1){\n\t\t\toG[x].pb(edge{y,1,-1});\n\t\t}else{\n\t\t\tint X=oG[x].size(),Y=oG[y].size();\n\t\t\toG[x].pb(edge{y,1,Y});\n\t\t\toG[y].pb(edge{x,1,X});\n\t\t}\n\t}\n\tint newN=0;\n\trep(i,N){\n\t\tint sz=oG[i].size();\n\t\tif(sz==0) sz=1;\n\t\trs[i]=newN;\n\t\tits[i]=rs[i];\n\t\tnewN+=sz;\n\t}\n\trs[N]=newN;\n\tG.resize(newN);\n\trep(x,N){\n\t\tint n=rs[x+1]-rs[x];\n\t\tfor(int v=rs[x];v<rs[x]+n-1;v++) add_edge(v,v+1,0,2);\n\t\tfor(edge e: oG[x]){\n\t\t\tif(e.rev==-1){\t//one way\n\t\t\t\tadd_edge(its[x],rs[e.to],1,1);\n\t\t\t\tits[x]++;\n\t\t\t}else{\n\t\t\t\tif(x<e.to){\n\t\t\t\t\tadd_edge(its[x],its[e.to],1,2);\n\t\t\t\t\tits[x]++;\n\t\t\t\t\tits[e.to]++;\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t}\n\tint ans=0;\n\tN=newN;\n//\trep(i,N) assert(G[i].size()<=3);\n\trep(i,N) rep(j,4) memo[i][j]=-1;\n\trep(i,N) chmax(ans,dfs(i,-1));\n\tcout<<ans<<endl;\n//\tEND_STACK_EXTEND;\n}"
  },
  {
    "language": "C++",
    "code": "#include<bits/stdc++.h>\nusing namespace std;\n#define MAX_N 100005\n#define MAX_M 100005\ntypedef pair<int,int> P;\n\nint n,m;\nint x[MAX_M],y[MAX_M],w[MAX_M];\n\nvector<int> G[MAX_N];\nvector<int> g[MAX_N];\n\nvector<int> group[MAX_N];\nint id[MAX_N];\nbool visited[MAX_N];\nvector<int> vd;\n\nint dp[MAX_N];\n\nbool dfs(int pos,int prev,int root){\n  id[pos]=root;\n  visited[pos]=true;\n  group[root].push_back(pos);\n  for(int i=0;i<(int)G[pos].size();i++){\n    int to=G[pos][i];\n    if(to==prev)continue;\n    if(i&&to==G[pos][i-1])return true;\n    if(visited[to])return true;\n    if(dfs(to,pos,root))return true;\n  }\n  return false;\n}\n\nbool check(){\n  memset(visited,false,sizeof(visited));\n  for(int i=0;i<n;i++){\n    if(visited[i])continue;\n    if( dfs(i,-1,i) )return true;\n  }\n\n  vector< int > deg(n);\n  vector< vector<int> > graph(n);\n  \n  for(int i=0;i<m;i++){\n    if(w[i]==1){\n      int X=id[ x[i] ];\n      int Y=id[ y[i] ];\n      if(X==Y)return true;\n      graph[X].push_back(Y);\n      deg[Y]++;\n    }\n  }\n\n  queue<int> Q;\n  for(int i=0;i<n;i++)\n    if(deg[i]==0&&id[i]==i)\n      Q.push(i);\n\n  while(!Q.empty()){\n    int pos=Q.front();Q.pop();\n    vd.push_back(pos);\n    for(int to:graph[pos]){\n      deg[to]--;\n      if(deg[to]==0)Q.push(to);\n    }\n  }\n  \n  for(int i=0;i<n;i++)\n    if(deg[i]>0)return true;\n  \n  return false;\n}\n\nint d[MAX_N];\n\nvoid init(int root){\n  root=id[root];\n  for(int pos:group[root])\n    d[pos]=-1;\n}\n\nvoid bfs(int root){\n  init(root);\n  queue<int> Q;\n  Q.push(root);\n  d[root]=0;\n  while(!Q.empty()){\n    int pos=Q.front();Q.pop();\n    for(int to:G[pos]){\n      if(d[to]!=-1)continue;\n      d[to]=d[pos]+1;\n      Q.push(to);\n    }\n  }\n}\n\nvoid update(int root,int dif){\n  for(int pos:group[root])\n    for(int to:g[pos])\n      dp[to]=max(dp[to],d[pos]+dif+1);\n}\n\nint solve(int root){\n  int res=0;\n  bfs(root);\n  int maxm=-1,maxmid;\n  for(int pos:group[root])\n    if(d[pos]+dp[pos]>maxm)maxm=d[pos]+dp[pos],maxmid=pos;\n  \n  bfs(maxmid);\n  update(root,dp[maxmid]);\n  for(int pos:group[root])res=max(res,d[pos]+dp[maxmid]);\n  \n  maxm=-1;\n  for(int pos:group[root])\n    if(d[pos]+dp[pos]>maxm)maxm=d[pos]+dp[pos],maxmid=pos;\n\n  bfs(maxmid);\n  update(root,dp[maxmid]);\n  for(int pos:group[root])res=max(res,d[pos]+dp[maxmid]);\n  \n  return res;\n}\n\nint main(){\n  scanf(\"%d %d\",&n,&m);\n  for(int i=0;i<m;i++){\n    scanf(\"%d %d %d\",&x[i],&y[i],&w[i]);\n    x[i]--,y[i]--;\n    if(w[i]==1){\n      g[x[i]].push_back(y[i]);\n    }\n    if(w[i]==2){\n      G[x[i]].push_back(y[i]);\n      G[y[i]].push_back(x[i]);\n    }\n  }\n  \n  if( check() ){\n    printf(\"Infinite\\n\");\n    return 0;\n  }\n\n  int ans=0;\n  for(int root : vd ){\n    if(root!=id[root])continue;\n    ans=max(ans,solve(root));\n  }\n  printf(\"%d\\n\",ans);  \n  return 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include<bits/stdc++.h>\nusing namespace std;\n#define MAX_N 100005\n#define MAX_M 100005\n\nint n,m;\nint x[MAX_M],y[MAX_M],w[MAX_M];\n\nvector<int> G[MAX_N];\nvector<int> g[MAX_N];\n\nvector<int> group[MAX_N];\nint id[MAX_N];\nbool visited[MAX_N];\nvector<int> vd;\n\nint dp[MAX_N];\n\nbool dfs(int pos,int prev,int root){\n  id[pos]=root;\n  visited[pos]=true;\n  group[root].push_back(pos);\n  for(int i=0;i<(int)G[pos].size();i++){\n    int to=G[pos][i];\n    if(to==prev)continue;\n    if(i&&to==G[pos][i-1])return true;\n    if(visited[to])return true;\n    if(dfs(to,pos,root))return true;\n  }\n  return false;\n}\n\nbool check(){\n  memset(visited,false,sizeof(visited));\n  for(int i=0;i<n;i++){\n    if(visited[i])continue;\n    if( dfs(i,-1,i) )return true;\n  }\n\n  vector< int > deg(n);\n  vector< vector<int> > graph(n);\n  \n  for(int i=0;i<m;i++){\n    if(w[i]==1){\n      int X=id[ x[i] ];\n      int Y=id[ y[i] ];\n      if(X==Y)return true;\n      graph[X].push_back(Y);\n      deg[Y]++;\n    }\n  }\n\n  queue<int> Q;\n  for(int i=0;i<n;i++)\n    if(deg[i]==0&&id[i]==i)\n      Q.push(i);\n\n  while(!Q.empty()){\n    int pos=Q.front();Q.pop();\n    vd.push_back(pos);\n    for(int to:graph[pos]){\n      deg[to]--;\n      if(deg[to]==0)Q.push(to);\n    }\n  }\n  \n  for(int i=0;i<n;i++)\n    if(deg[i]>0)return true;\n  \n  return false;\n}\n\nint d[MAX_N];\n\nvoid init(int root){\n  root=id[root];\n  for(int pos:group[root])\n    d[pos]=-1;\n}\n\nvoid bfs(int S){\n  init(S);\n  queue<int> Q;\n  Q.push(S);\n  d[S]=0;\n  while(!Q.empty()){\n    int pos=Q.front();Q.pop();\n    for(int to:G[pos]){\n      if(d[to]!=-1)continue;\n      d[to]=d[pos]+1;\n      Q.push(to);\n    }\n  }\n}\n\nint solve(int S,int &ans){\n  bfs(S);\n  int res=S;\n  for(int pos:group[id[S]]){\n    if(d[pos]+dp[pos]>d[res]+dp[res])res=pos;\n    ans=max(ans,d[pos]+dp[S]);\n    for(int to:g[pos])dp[to]=max(dp[to],d[pos]+dp[S]+1);\n  }\n  return res;\n}\n\n  /*\n  int res=0;\n  bfs(root);\n  int maxm=-1,maxmid;\n  for(int pos:group[root])\n    if(d[pos]+dp[pos]>maxm)maxm=d[pos]+dp[pos],maxmid=pos;\n  \n  bfs(maxmid);\n  update(root,dp[maxmid]);\n  for(int pos:group[root])res=max(res,d[pos]+dp[maxmid]);\n  \n  maxm=-1;\n  for(int pos:group[root])\n    if(d[pos]+dp[pos]>maxm)maxm=d[pos]+dp[pos],maxmid=pos;\n\n  bfs(maxmid);\n  update(root,dp[maxmid]);\n  for(int pos:group[root])res=max(res,d[pos]+dp[maxmid]);\n  \n  return res;\n  */\n\n\nint main(){\n  scanf(\"%d %d\",&n,&m);\n  for(int i=0;i<m;i++){\n    scanf(\"%d %d %d\",&x[i],&y[i],&w[i]);\n    x[i]--,y[i]--;\n    if(w[i]==1){\n      g[x[i]].push_back(y[i]);\n    }\n    if(w[i]==2){\n      G[x[i]].push_back(y[i]);\n      G[y[i]].push_back(x[i]);\n    }\n  }\n  \n  if( check() ){\n    printf(\"Infinite\\n\");\n    return 0;\n  }\n\n  int ans=0;\n  for(int root : vd ){\n    if(root!=id[root])continue;\n    solve( solve( solve(root,ans) , ans ) , ans);\n  }\n  printf(\"%d\\n\",ans);  \n  return 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include<stdio.h>\n#include<algorithm>\n#include<vector>\n#define N_ 901000\nusing namespace std;\nint n, m, Deg[N_], Q[N_], head, tail, D[N_], Res, cnt;\nint B1[101000], B2[101000];\nvector<int>E[N_], G[101000];\nvoid Make_Edge(int a, int b, int c){\n    E[a].push_back(b*2+c);\n}\nint main(){\n    int i, a, b, c, x, sz, j;\n    scanf(\"%d%d\",&n,&m);\n    cnt = 2*n;\n    for(i=1;i<=m;i++){\n        scanf(\"%d%d%d\",&a,&b,&c);\n        if(c==1){\n            Make_Edge(n+a,b,1);\n        }\n        else{\n            Make_Edge(cnt+1,cnt+4,1);\n            Make_Edge(cnt+3,cnt+2,1);\n            G[a].push_back(cnt+1);\n            G[b].push_back(cnt+3);\n            cnt+=4;\n        }\n    }\n    for(i=1;i<=n;i++){\n        Make_Edge(i,i+n,0);\n        sz = G[i].size();\n        if(!sz)continue;\n        B1[i] = cnt+1;\n        for(j=0;j<sz;j++){\n            cnt++;\n            Make_Edge(cnt,G[i][j],0);\n            if(j)Make_Edge(cnt, cnt-1,0);\n        }\n        B2[i] = cnt+1;\n        for(j=sz-1;j>=0;j--){\n            cnt++;\n            Make_Edge(cnt,G[i][j],0);\n            if(j!=sz-1)Make_Edge(cnt, cnt-1,0);\n        }\n        for(j=0;j<sz;j++){\n            Make_Edge(i,G[i][j],0);\n            Make_Edge(G[i][j]+1,n+i,0);\n            if(j)Make_Edge(G[i][j]+1, B1[i]+j-1,0);\n            if(j!=sz-1)Make_Edge(G[i][j]+1, B2[i]+sz-j-2,0);\n        }\n    }\n    if(n==100000)return 0;\n    for(i=1;i<=cnt;i++){\n        for(j=0;j<E[i].size();j++){\n            Deg[E[i][j]/2]++;\n        }\n    }\n    for(i=1;i<=cnt;i++){\n        if(!Deg[i])Q[++tail] = i;\n    }\n    while(head < tail){\n        x = Q[++head];\n        Res = max(Res, D[x]);\n        for(i=0;i<E[x].size();i++){\n            Deg[E[x][i]/2]--;\n            D[E[x][i]/2] = max(D[E[x][i]]/2, D[x] + E[x][i]%2);\n            if(!Deg[E[x][i]/2])Q[++tail] = E[x][i]/2;\n        }\n    }\n    if(tail != cnt){\n        printf(\"Infinite\\n\");\n        return 0;\n    }\n    printf(\"%d\\n\",Res);\n}"
  },
  {
    "language": "C++",
    "code": "#include <algorithm>\n#include <bitset>\n#include <cassert>\n#include <cmath>\n#include <complex>\n#include <cstdint>\n#include <cstdio>\n#include <deque>\n#include <functional>\n#include <iomanip>\n#include <iostream>\n#include <limits>\n#include <map>\n#include <numeric>\n#include <queue>\n#include <set>\n#include <sstream>\n#include <stack>\n#include <tuple>\n#include <utility>\n#include <vector>\nusing namespace std;\n\n#define rep(i,n) for(int i=0;i<(n);i++)\n#define pb push_back\n#define fi first\n#define se second\n\nusing i64 = int64_t;\n\nstruct edge{\n    int from,to;\n    int idx;\n    edge(int f,int t,int n): from(f) , to(t) , idx(n) {}\n};\n\nint n,m;\nvector<vector<edge>> g; \n\nbool visited[100005];\nmap<int,map<int,int>> memo;\n\nint dfs(int cur,int par){\n    int ret=0;\n    if(memo.count(cur) and memo[cur].count(par)) return memo[cur][par];\n    for(const edge& e : g[cur]){\n        if(e.to == par) continue;\n        int tmp = 1 + dfs(e.to,cur);\n        ret = max(ret,tmp);\n    }\n    memo[cur][par] = ret;\n    return ret;\n}\n\nnamespace Yuudachi{\n    vector<bool> used;\n    // heiro -> false\n    bool dfs(int cur,int last_edge){\n        //cout << cur << \" \" << endl;\n        if(used[cur]) return false;\n        used[cur] = true;\n        for(const edge& e : g[cur]){\n            if(e.idx == last_edge) continue;\n            if(!dfs(e.to,e.idx)){\n                //cout << \"false : \" << e.to << \"  \" << e.idx << endl;\n                return false;\n            }\n        }\n        used[cur] = false;\n        return true;\n    }\n    bool poi(){\n        used.assign(n,false);\n        bool ret=dfs(0,-1);\n        return ret;\n    }\n}\n\nint main(){\n    cin >> n >> m;\n    g.resize(n);\n    rep(i,m){\n        int x,y,w;\n        cin >> x >> y >> w;\n        x--;\n        y--;\n        if(w==1){\n            g[x].pb(edge(x,y,i));\n        }else{\n            g[x].pb(edge(x,y,i));\n            g[y].pb(edge(y,x,i));\n        }\n    }\n    \n    if(!Yuudachi::poi()){\n        cout << \"Infinite\" << endl;\n        return 0;\n    }\n\n    //cout << \"NO heiro\" << endl;\n    fill(visited,visited+n,false);\n    //cout << dfs(0,0) << endl;\n    int ans = 0;\n    rep(i,n) if(!visited[i]){\n        ans = max(ans,dfs(i,i));\n    }\n    cout << ans << endl;\n    return 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\n\nusing namespace std;\n\nconst int INF = 1 << 29;\n\nstruct UnionFind\n{\n  vector< int > data;\n\n  UnionFind(int sz)\n  {\n    data.assign(sz, -1);\n  }\n\n  int find(int k)\n  {\n    return (data[k] < 0 ? k : data[k] = find(data[k]));\n  }\n\n  void unite(int x, int y)\n  {\n    x = find(x);\n    y = find(y);\n    if(data[x] > data[y]) swap(x, y);\n    data[x] += data[y];\n    data[y] = x;\n  }\n};\n\nvector< pair< int, int > > g[100001];\nvector< int > leftt[100001], rightt[100001], just[100001];\nvector< int > gg[100001], rgg[100001], order;\nbool v[100001];\nint cmp[100001];\n\n\nvoid dfs(int idx)\n{\n  if(v[idx]++) return;\n  for(auto &to : gg[idx]) dfs(to);\n  order.push_back(idx);\n}\n\nvoid rdfs(int idx, int k)\n{\n  cmp[idx] = k;\n  for(auto &to : rgg[idx]) if(cmp[to] == -1) rdfs(to, k);\n}\n\nint rec(int idx, int back = -1)\n{\n  if(back != -1) {\n    int tmp = max(leftt[idx][back], rightt[idx][back + 1]);\n    if(tmp != INF) return (tmp);\n  }\n  if(rightt[idx][0] == INF) {\n    for(int i = 0; i < g[idx].size(); i++) {\n      int to, rev;\n      tie(to, rev) = g[idx][i];\n      if(to == back || just[idx][i] != INF) continue;\n      just[idx][i] = rec(to, g[idx][i].second) + 1;\n    }\n    for(int i = 0; i < g[idx].size(); i++) {\n      leftt[idx][i + 1] = max(leftt[idx][i], just[idx][i]);\n    }\n    for(int i = (int) g[idx].size() - 1; i >= 0; i--) {\n      rightt[idx][i] = max(rightt[idx][i + 1], just[idx][i]);\n    }\n  }\n\n  if(back == -1) return (rightt[idx][0]);\n  return (max(leftt[idx][back], rightt[idx][back + 1]));\n}\n\n\nint main()\n{\n  int N, M;\n  vector< pair< int, int > > edges, arcs;\n\n  scanf(\"%d %d\", &N, &M);\n\n  UnionFind uf(N);\n\n  for(int i = 0; i < M; i++) {\n    int x, y, t;\n    cin >> x >> y >> t;\n    --x, --y;\n    if(t == 1) {\n      arcs.emplace_back(x, y);\n      g[x].emplace_back(y, -1);\n    } else {\n      if(uf.find(x) == uf.find(y)) {\n        cout << \"Infinite\" << endl;\n        return (0);\n      }\n      uf.unite(x, y);\n      edges.emplace_back(x, y);\n      g[y].emplace_back(x, g[x].size());\n      g[x].emplace_back(y, g[y].size() - 1);\n    }\n  }\n\n  /*\n  {\n    for(auto &e : arcs) gg[uf.find(e.first)].push_back(uf.find(e.second));\n    for(auto &e : arcs) rgg[uf.find(e.second)].push_back(uf.find(e.first));\n    for(int i = 0; i < N; i++) dfs(i);\n    reverse(begin(order), end(order));\n    memset(cmp, -1, sizeof(cmp));\n    int kk = 0;\n    for(auto &i : order) if(cmp[i] == -1) rdfs(i, kk++);\n    if(kk != N) {\n      cout << \"Infinite\" << endl;\n      return (0);\n    }\n  }\n   */\n\n  int ret = 0;\n  for(int i = 0; i < N; i++) {\n    int sz = g[i].size();\n    just[i].assign(sz + 5, INF);\n    leftt[i].assign(sz + 5, INF);\n    rightt[i].assign(sz + 5, INF);\n    leftt[i][0] = rightt[i][sz] = 0;\n  }\n  for(int i = 0; i < N; i++) ret = max(ret, rec(i));\n  cout << ret << endl;\n}"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\n\nusing namespace std;\n\nconst int INF = 1 << 29;\n\nstruct UnionFind\n{\n  vector< int > data;\n\n  UnionFind(int sz)\n  {\n    data.assign(sz, -1);\n  }\n\n  int find(int k)\n  {\n    return (data[k] < 0 ? k : data[k] = find(data[k]));\n  }\n\n  void unite(int x, int y)\n  {\n    x = find(x);\n    y = find(y);\n    if(x == y) return;\n    if(data[x] > data[y]) swap(x, y);\n    data[x] += data[y];\n    data[y] = x;\n  }\n};\n\nvector< pair< int, int > > g[100001];\nvector< int > leftt[100001], rightt[100001], just[100001];\nvector< int > gg[100001];\nint deg[100001];\n\n\nint rec(int idx, int back = -1)\n{\n  if(rightt[idx][0] == INF) {\n    for(int i = 0; i < g[idx].size(); i++) {\n      int to, rev;\n      tie(to, rev) = g[idx][i];\n      if(i == back) continue;\n      just[idx][i] = rec(to, rev) + 1;\n    }\n    for(int i = 0; i < g[idx].size(); i++) {\n      leftt[idx][i + 1] = max(leftt[idx][i], just[idx][i]);\n    }\n    for(int i = (int) g[idx].size() - 1; i >= 0; i--) {\n      rightt[idx][i] = max(rightt[idx][i + 1], just[idx][i]);\n    }\n  }\n  if(back == -1) return (rightt[idx][0]);\n  return (max(leftt[idx][back], rightt[idx][back + 1]));\n}\n\n\nint main()\n{\n  int N, M;\n  vector< pair< int, int > > edges, arcs;\n\n  scanf(\"%d %d\", &N, &M);\n\n  UnionFind uf(N);\n\n  for(int i = 0; i < M; i++) {\n    int x, y, t;\n    cin >> x >> y >> t;\n    --x, --y;\n    if(t == 1) {\n      arcs.emplace_back(x, y);\n      g[x].emplace_back(y, -1);\n    } else {\n      if(uf.find(x) == uf.find(y)) {\n        cout << \"Infinite\" << endl;\n        return (0);\n      }\n      uf.unite(x, y);\n      edges.emplace_back(x, y);\n      g[y].emplace_back(x, g[x].size());\n      g[x].emplace_back(y, g[y].size() - 1);\n    }\n  }\n\n  {\n    for(auto &e : arcs) {\n      gg[uf.find(e.first)].push_back(uf.find(e.second));\n      ++deg[uf.find(e.second)];\n    }\n    vector< int > order;\n    for(int i = 0; i < N; i++) {\n      if(deg[i] == 0) order.push_back(i);\n    }\n    for(int i = 0; i < order.size(); i++) {\n      for(auto &e : gg[order[i]]) {\n        if(--deg[e] == 0) order.push_back(e);\n      }\n    }\n    if(order.size() != N) {\n      cout << \"Infinite\" << endl;\n      return (0);\n    }\n  }\n\n\n  int ret = 0;\n  for(int i = 0; i < N; i++) {\n    int sz = g[i].size();\n    just[i].assign(sz, INF);\n    leftt[i].assign(sz + 1, INF);\n    rightt[i].assign(sz + 1, INF);\n    leftt[i][0] = rightt[i][sz] = 0;\n  }\n  for(int i = 0; i < N; i++) ret = max(ret, rec(i));\n  cout << ret << endl;\n}"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\n\nusing namespace std;\n\nconst int INF = 1 << 29;\n\nstruct UnionFind\n{\n  vector< int > data;\n\n  UnionFind(int sz)\n  {\n    data.assign(sz, -1);\n  }\n\n  int find(int k)\n  {\n    return (data[k] < 0 ? k : data[k] = find(data[k]));\n  }\n\n  void unite(int x, int y)\n  {\n    x = find(x);\n    y = find(y);\n    if(data[x] > data[y]) swap(x, y);\n    data[x] += data[y];\n    data[y] = x;\n  }\n};\n\nvector< pair< int, int > > g[100001];\nvector< int > leftt[100001], rightt[100001], just[100001];\nvector< int > gg[100001];\nint deg[100001];\n\n\nint rec(int idx, int back = -1)\n{\n  if(back != -1) {\n    int tmp = max(leftt[idx][back], rightt[idx][back + 1]);\n    if(tmp != INF) return (tmp);\n  }\n  if(rightt[idx][0] == INF) {\n    for(int i = 0; i < g[idx].size(); i++) {\n      int to, rev;\n      tie(to, rev) = g[idx][i];\n      if(i == back || just[idx][i] != INF) continue;\n      just[idx][i] = rec(to, g[idx][i].second) + 1;\n    }\n    for(int i = 0; i < g[idx].size(); i++) {\n      leftt[idx][i + 1] = max(leftt[idx][i], just[idx][i]);\n    }\n    for(int i = (int) g[idx].size() - 1; i >= 0; i--) {\n      rightt[idx][i] = max(rightt[idx][i + 1], just[idx][i]);\n    }\n  }\n\n  if(back == -1) return (rightt[idx][0]);\n  return (max(leftt[idx][back], rightt[idx][back + 1]));\n}\n\n\nint main()\n{\n  int N, M;\n  vector< pair< int, int > > edges, arcs;\n\n  scanf(\"%d %d\", &N, &M);\n\n  UnionFind uf(N);\n\n  for(int i = 0; i < M; i++) {\n    int x, y, t;\n    cin >> x >> y >> t;\n    --x, --y;\n    if(t == 1) {\n      arcs.emplace_back(x, y);\n      g[x].emplace_back(y, -1);\n    } else {\n      if(uf.find(x) == uf.find(y)) {\n        cout << \"Infinite\" << endl;\n        return (0);\n      }\n      uf.unite(x, y);\n      edges.emplace_back(x, y);\n      g[y].emplace_back(x, g[x].size());\n      g[x].emplace_back(y, g[y].size() - 1);\n    }\n  }\n\n  {\n    for(auto &e : arcs) {\n      gg[uf.find(e.first)].push_back(uf.find(e.second));\n      ++deg[uf.find(e.second)];\n    }\n    vector< int > order;\n    for(int i = 0; i < N; i++) {\n      if(deg[i] == 0) order.push_back(i);\n    }\n    for(int i : order) {\n      for(auto &e : gg[i]) {\n        if(--deg[e] == 0) order.push_back(e);\n      }\n    }\n    if(order.size() != N) {\n      cout << \"Infinite\" << endl;\n      return (0);\n    }\n  }\n\n\n  int ret = 0;\n  for(int i = 0; i < N; i++) {\n    int sz = g[i].size();\n    just[i].assign(sz, INF);\n    leftt[i].assign(sz + 1, INF);\n    rightt[i].assign(sz + 1, INF);\n    leftt[i][0] = rightt[i][sz] = 0;\n  }\n  for(int i = 0; i < N; i++) ret = max(ret, rec(i));\n  cout << ret << endl;\n}"
  },
  {
    "language": "C++",
    "code": "#include<bits/stdc++.h>\nusing namespace std;\n#define MAX_N 100005\n#define MAX_M 100005\ntypedef pair<int,int> P;\n\nint n,m;\nvector<int> group[MAX_N];\n\nvector<int> G[MAX_N];\n\nint x[MAX_M],y[MAX_M],w[MAX_M];\n\nint id[MAX_N];\nbool visited[MAX_N];\n\nint c[MAX_N];\nvector<int> g[MAX_N];\nvector<int> vd;\n\nint dp[MAX_N];\n\nbool dfs(int pos,int prev,int root){\n  id[pos]=root;\n  visited[pos]=true;\n  group[root].push_back(pos);\n  \n  for(int to:G[pos]){\n    if(to==prev)continue;\n    if(visited[to])return true;\n    if(dfs(to,pos,root))return true;\n  }\n  return false;\n}\n\nbool check(){\n  map<P,bool> mp;\n  for(int i=0;i<m;i++){\n    if(w[i]==1)continue;\n    if(x[i]>y[i])swap(x[i],y[i]);\n    if(mp[ P(x[i],y[i]) ])return true;\n    mp[ P(x[i],y[i]) ]=true;\n  }\n    \n  memset(visited,false,sizeof(visited));\n  for(int i=0;i<n;i++){\n    if(visited[i])continue;\n    if( dfs(i,-1,i) )return true;\n  }\n\n\n  \n  for(int i=0;i<m;i++){\n    if(w[i]==2)continue;\n    int X=id[ x[i] ];\n    int Y=id[ y[i] ];\n    if(X==Y){\n      return true;\n    }\n    g[X].push_back(Y);\n    c[Y]++;\n  }\n\n  queue<int> Q;\n  for(int i=0;i<n;i++){\n    if(c[i]==0&&id[i]==i){\n      Q.push(i);\n    }\n  }\n\n  while(!Q.empty()){\n    int pos=Q.front();Q.pop();\n    vd.push_back(pos);\n    for(int to:g[pos]){\n      c[to]--;\n      if(c[to]==0)Q.push(to);\n    }\n  }\n\n  for(int i=0;i<n;i++)\n    if(c[i]>0)return true;\n  \n  return false;\n}\n\nint d[MAX_N];\nvoid init(int root){\n  root=id[root];\n  for(int pos:group[root]){\n    d[pos]=-1;\n  }\n}\n\nvoid bfs(int root){\n  init(root);\n  queue<int> Q;\n  Q.push(root);\n  d[root]=0;\n  while(!Q.empty()){\n    int pos=Q.front();Q.pop();\n    for(int to:G[pos]){\n      if(d[to]!=-1)continue;\n      d[to]=d[pos]+1;\n      Q.push(to);\n    }\n  }\n}\n\nvoid update(int root,int dif){\n  for(int pos:group[root]){\n    for(int to:g[pos]){\n      dp[to]=max(dp[to],d[pos]+dif+1);\n    }\n  }\n}\n\nint solve(int root){\n  int res=0;\n  bfs(root);\n  int maxm=-1,maxmid;\n  for(int pos:group[root])\n    if(d[pos]+dp[pos]>maxm)maxm=d[pos]+dp[pos],maxmid=pos;\n  bfs(maxmid);\n  update(root,dp[maxmid]);\n  \n  maxm=-1;\n  for(int pos:group[root]){\n    if(d[pos]+dp[pos]>maxm)maxm=d[pos]+dp[pos],maxmid=pos;\n    res=max(res,d[pos]);\n  }\n  bfs(maxmid);\n  update(root,dp[maxmid]);\n  return res;\n}\n\nint main(){\n  scanf(\"%d %d\",&n,&m);\n  for(int i=0;i<m;i++){\n    scanf(\"%d %d %d\",&x[i],&y[i],&w[i]);\n    x[i]--,y[i]--;\n    \n    if(w[i]==2){\n      G[x[i]].push_back(y[i]);\n      G[y[i]].push_back(x[i]);\n    }\n  }\n  \n  if( check() ){\n    printf(\"Infinite\\n\");\n    return 0;\n  }\n\n  for(int i=0;i<n;i++){\n    g[i].clear();\n  }\n  for(int i=0;i<m;i++){\n    if(w[i]==1){\n      g[ x[i] ].push_back(y[i]);\n    }\n  }\n  \n  int ans=0;\n  \n  for(int root : vd ){\n    if(root!=id[root])continue;\n    ans=max(ans,solve(root));\n  }\n\n  for(int i=0;i<n;i++){\n    ans=max(ans,dp[i]);\n  }\n  printf(\"%d\\n\",ans);  \n  return 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\n#define rep(i,N) for(int i=0;i<(int)N;i++)\n#define rep1(i,N) for(int i=1;i<=(int)N;i++)\n#define pb push_back\n#define all(c) c.begin(),c.end()\n#define show(x) cout<<#x<<\" \"<<x<<endl\n#define chmax(x,y) x=max(x,y)\n#define BEGIN_STACK_EXTEND(size) void * stack_extend_memory_ = malloc(size);void * stack_extend_origin_memory_;char * stack_extend_dummy_memory_ = (char*)alloca((1+(int)(((long long)stack_extend_memory_)&127))*16);*stack_extend_dummy_memory_ = 0;asm volatile(\"mov %%rsp, %%rbx\\nmov %%rax, %%rsp\":\"=b\"(stack_extend_origin_memory_):\"a\"((char*)stack_extend_memory_+(size)-1024));\n#define END_STACK_EXTEND asm volatile(\"mov %%rax, %%rsp\"::\"a\"(stack_extend_origin_memory_));free(stack_extend_memory_);\nusing namespace std;\nconst int MN=100000;\nstruct edge {int to,w,rev;};\ntypedef vector< vector<edge> > Graph;\nGraph G,oG;\nvoid add_edge(int x,int y,int w,int way){\n\tif(way==1){\n\t\tG[x].pb({y,w,-1});\n\t}else{\n\t\tint X=G[x].size(),Y=G[y].size();\n\t\tG[x].pb({y,w,Y});\n\t\tG[y].pb({x,w,X});\n\t}\n}\n\ntypedef pair<int,int> P;\nint memo[300000][4];\nbool vis[300000][4];\nint dfs(int v,int eid){\n\teid++;\n\tif(memo[v][eid]!=-1) return memo[v][eid];\n\tif(vis[v][eid]){\n\t\tputs(\"Infinite\");\n\t\texit(1);\n\t}\n\tvis[v][eid]=1;\n\tint ret=0;\n\t// rep(i,G[v].size()) if(i!=eid-1){\n\t// \tedge& e=G[v][i];\n\t// \tchmax(ret,dfs(e.to,e.rev)+e.w);\n\t// }\n\tif(G[v].size()>0 && eid!=1) chmax(ret,dfs(G[v][0].to,G[v][0].rev)+G[v][0].w);\n\tif(G[v].size()>1 && eid!=2) chmax(ret,dfs(G[v][1].to,G[v][1].rev)+G[v][1].w);\n\tif(G[v].size()>2 && eid!=3) chmax(ret,dfs(G[v][2].to,G[v][2].rev)+G[v][2].w);\n\tmemo[v][eid]=ret;\n\treturn ret;\n}\n\nint rs[100001]={};\nint its[100000]={};\n\nint main(){\n\tBEGIN_STACK_EXTEND(128*1024*1024);\n\texit(1);\n\tint N,M;\n\tcin>>N>>M;\n\toG.resize(N);\n\trep(i,M){\n\t\tint x,y,w;\n\t\tscanf(\"%d %d %d\",&x,&y,&w);\n\t\tx--,y--;\n\t\tif(w==1){\n\t\t\toG[x].pb(edge{y,1,-1});\n\t\t}else{\n\t\t\tint X=oG[x].size(),Y=oG[y].size();\n\t\t\toG[x].pb(edge{y,1,Y});\n\t\t\toG[y].pb(edge{x,1,X});\n\t\t}\n\t}\n\tint newN=0;\n\trep(i,N){\n\t\tint sz=oG[i].size();\n\t\tif(sz==0) sz=1;\n\t\trs[i]=newN;\n\t\tits[i]=rs[i];\n\t\tnewN+=sz;\n\t}\n\trs[N]=newN;\n\tG.resize(newN);\n\trep(x,N){\n\t\tint n=rs[x+1]-rs[x];\n\t\tfor(int v=rs[x];v<rs[x]+n-1;v++) add_edge(v,v+1,0,2);\n\t\tfor(edge e: oG[x]){\n\t\t\tif(e.rev==-1){\t//one way\n\t\t\t\tadd_edge(its[x],rs[e.to],1,1);\n\t\t\t\tits[x]++;\n\t\t\t}else{\n\t\t\t\tif(x<e.to){\n\t\t\t\t\tadd_edge(its[x],its[e.to],1,2);\n\t\t\t\t\tits[x]++;\n\t\t\t\t\tits[e.to]++;\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t}\n\tint ans=0;\n\tN=newN;\n//\trep(i,N) assert(G[i].size()<=3);\n\trep(i,N) rep(j,4) memo[i][j]=-1;\n\trep(i,N) chmax(ans,dfs(i,-1));\n\tcout<<ans<<endl;\n\tEND_STACK_EXTEND;\n}"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\n#define rep(i,n) for(int i=0;i<n;i++)\nusing namespace std;\n\ntypedef long long int64;\ntypedef pair<int,int> PII;\n\nint n,m;\n\nvector<PII> biEdge[123456];\nvector<int> uniEdge[123456];\n\nvector<int> nodes[123456];\n\nstruct Edge{\n\tint t,w;\n\tEdge(int t,int w):t(t),w(w){}\n};\n\nvector<Edge> edge[2345678];\n\n//a vertex can reach all\n// <- <- <- nadj\n// -> -> -> nadj\n\nvoid addE(int u,int v,int w){\n\tedge[u].push_back(Edge(v,w));\n}\n\nint findNode(int u,int id,int tp){\n\tint pos = lower_bound(biEdge[u].begin(),biEdge[u].end(),make_pair(id,-1)) - biEdge[u].begin();\n\n\treturn nodes[u][2 + biEdge[u].size() * tp + pos];\n}\n\nint indeg[2345678];\n\nint main(){\n\tcin>>n>>m;\n\n\trep(it,m){\n\t\tint u,v,w;\n\t\tscanf(\"%d%d%d\",&u,&v,&w);\n\t\t--u,--v;\n\n\t\tif(w==2){\n\t\t\tbiEdge[u].push_back(make_pair(it,v));\n\t\t\tbiEdge[v].push_back(make_pair(it,u));\n\t\t} else {\n\t\t\tuniEdge[u].push_back(v);\n\t\t}\n\t}\n\n\tint V = 0;\n\trep(i,n){\n\t\tnodes[i].push_back(V++); //in:0\n\t\tnodes[i].push_back(V++); //out:1\n\n\t\tsort(biEdge[i].begin(),biEdge[i].end());\n\n\t\trep(it,biEdge[i].size()){\n\t\t\tnodes[i].push_back(V++);\n\t\t\tnodes[i].push_back(V++);\n\t\t\tnodes[i].push_back(V++);\n\t\t}\n\n\t\tint m = biEdge[i].size();\n\n\t\trep(it,biEdge[i].size()){\n\t\t\tint lt = it + 2;\n\t\t\tint rt = m + it + 2;\n\t\t\tint ct = m * 2 + it + 2;\n\n\t\t\tif(it>0)\n\t\t\t\taddE(nodes[i][lt],nodes[i][lt-1],0);\n\t\t\tif(it+1<m)\n\t\t\t\taddE(nodes[i][rt],nodes[i][rt+1],0);\n\t\t}\n\t}\n\n\t//build edge\n\trep(i,n){\n\t\trep(it,uniEdge[i].size()){\n\t\t\tint v = uniEdge[i][it];//i->v\n\n\t\t\taddE(nodes[i][1],nodes[v][0],1);\n\t\t}\n\n\t\tint m = biEdge[i].size();\n\n\t\tif(m > 0){\n\t\t\trep(it,biEdge[i].size()){\n\t\t\t\tint lt = it + 2;\n\t\t\t\tint rt = m + it + 2;\n\t\t\t\tint ct = m * 2 + it + 2;\n\n\t\t\t\tif(it > 0){\n\t\t\t\t\tint id = biEdge[i][it-1].first;\n\t\t\t\t\tint v = biEdge[i][it-1].second;\n\n\t\t\t\t\taddE(nodes[i][lt],findNode(v,id,2),1);\n\t\t\t\t}\n\n\t\t\t\tif(it + 1 < m){\n\t\t\t\t\tint id = biEdge[i][it+1].first;\n\t\t\t\t\tint v = biEdge[i][it+1].second;\n\n\t\t\t\t\taddE(nodes[i][rt],findNode(v,id,2),1);\n\t\t\t\t}\n\n\t\t\t\taddE(nodes[i][ct],nodes[i][lt],0);\n\n\t\t\t\taddE(nodes[i][ct],nodes[i][rt],0);\n\n\t\t\t\taddE(nodes[i][ct],nodes[i][1],0);\n\t\t\t}\n\t\t\taddE(nodes[i][0],nodes[i][2+m],0);\n\t\t\t{\n\t\t\t\tint id = biEdge[i][0].first;\n\t\t\t\tint v = biEdge[i][0].second;\n\n\t\t\t\taddE(nodes[i][0],findNode(v,id,2),1);\n\t\t\t}\n\t\t}\n\n\t\taddE(nodes[i][0],nodes[i][1],0);\n\t}\n\n\t//graph built\n\trep(i,V){\n\t\trep(j,edge[i].size())\n\t\t\tindeg[edge[i][j].t]++;\n\t}\n\n\tstatic int que[2345678],qh=0,qt=0;\n\n\trep(i,V) if(indeg[i]==0) que[qt++]=i;\n\n\twhile(qh<qt){\n\t\tint u = que[qh++];\n\t\trep(j,edge[u].size()){\n\t\t\tint v = edge[u][j].t;\n\t\t\tindeg[v]--;\n\t\t\tif(!indeg[v])\n\t\t\t\tque[qt++] = v;\n\t\t}\n\t}\n\n\tstatic int dp[2345678];\n\n\tif(qt!=V){\n\t\tputs(\"Infinite\");\n\t} else {\n\t\trep(i,V){\n\t\t\tint u = que[V-1-i];\n\t\t\tdp[u]=0;\n\t\t\trep(j,edge[u].size()){\n\t\t\t\tint v = edge[u][j].t;\n\t\t\t\tdp[u] = max(dp[u],dp[v] + edge[u][j].w);\n\t\t\t}\n\t\t}\n\t\tint ans=*max_element(dp,dp+V);\n\t\tprintf(\"%d\\n\",ans);\n\t}\n}"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\n#define rep(i,N) for(int i=0;i<(int)N;i++)\n#define rep1(i,N) for(int i=1;i<=(int)N;i++)\n#define pb push_back\n#define all(c) c.begin(),c.end()\n#define show(x) cout<<#x<<\" \"<<x<<endl\n#define chmax(x,y) x=max(x,y)\n#define BEGIN_STACK_EXTEND(size) void * stack_extend_memory_ = malloc(size);void * stack_extend_origin_memory_;char * stack_extend_dummy_memory_ = (char*)alloca((1+(int)(((long long)stack_extend_memory_)&127))*16);*stack_extend_dummy_memory_ = 0;asm volatile(\"mov %%rsp, %%rbx\\nmov %%rax, %%rsp\":\"=b\"(stack_extend_origin_memory_):\"a\"((char*)stack_extend_memory_+(size)-1024));\n#define END_STACK_EXTEND asm volatile(\"mov %%rax, %%rsp\"::\"a\"(stack_extend_origin_memory_));free(stack_extend_memory_);\nusing namespace std;\nconst int MN=100000;\nstruct edge {int to,w,rev;};\ntypedef vector< vector<edge> > Graph;\nGraph G,oG;\nvoid add_edge(int x,int y,int w,int way){\n\tif(way==1){\n\t\tG[x].pb({y,w,-1});\n\t}else{\n\t\tint X=G[x].size(),Y=G[y].size();\n\t\tG[x].pb({y,w,Y});\n\t\tG[y].pb({x,w,X});\n\t}\n}\n\ntypedef pair<int,int> P;\nint memo[300000][4];\nbool vis[300000][4];\nint inf=1e8;\nint dfs(int v,int eid){\n\teid++;\n\tif(memo[v][eid]!=-1) return memo[v][eid];\n\tif(vis[v][eid]){\n\t\treturn inf;\n//\t\tputs(\"Infinite\");\n\t}\n\tvis[v][eid]=1;\n\tint ret=0;\n\t// rep(i,G[v].size()) if(i!=eid-1){\n\t// \tedge& e=G[v][i];\n\t// \tchmax(ret,dfs(e.to,e.rev)+e.w);\n\t// }\n\tif(G[v].size()>0 && eid!=1) chmax(ret,dfs(G[v][0].to,G[v][0].rev)+G[v][0].w);\n\tif(G[v].size()>1 && eid!=2) chmax(ret,dfs(G[v][1].to,G[v][1].rev)+G[v][1].w);\n\tif(G[v].size()>2 && eid!=3) chmax(ret,dfs(G[v][2].to,G[v][2].rev)+G[v][2].w);\n\tmemo[v][eid]=ret;\n\treturn ret;\n}\n\nint rs[100001]={};\nint its[100000]={};\n\nint main(){\n\tBEGIN_STACK_EXTEND(128*1024*1024);\n\tint N,M;\n\tcin>>N>>M;\n\toG.resize(N);\n\trep(i,M){\n\t\tint x,y,w;\n\t\tscanf(\"%d %d %d\",&x,&y,&w);\n\t\tx--,y--;\n\t\tif(w==1){\n\t\t\toG[x].pb(edge{y,1,-1});\n\t\t}else{\n\t\t\tint X=oG[x].size(),Y=oG[y].size();\n\t\t\toG[x].pb(edge{y,1,Y});\n\t\t\toG[y].pb(edge{x,1,X});\n\t\t}\n\t}\n\tint newN=0;\n\trep(i,N){\n\t\tint sz=oG[i].size();\n\t\tif(sz==0) sz=1;\n\t\trs[i]=newN;\n\t\tits[i]=rs[i];\n\t\tnewN+=sz;\n\t}\n\trs[N]=newN;\n\tG.resize(newN);\n\trep(x,N){\n\t\tint n=rs[x+1]-rs[x];\n\t\tfor(int v=rs[x];v<rs[x]+n-1;v++) add_edge(v,v+1,0,2);\n\t\tfor(edge e: oG[x]){\n\t\t\tif(e.rev==-1){\t//one way\n\t\t\t\tadd_edge(its[x],rs[e.to],1,1);\n\t\t\t\tits[x]++;\n\t\t\t}else{\n\t\t\t\tif(x<e.to){\n\t\t\t\t\tadd_edge(its[x],its[e.to],1,2);\n\t\t\t\t\tits[x]++;\n\t\t\t\t\tits[e.to]++;\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t}\n\tint ans=0;\n\tN=newN;\n//\trep(i,N) assert(G[i].size()<=3);\n\trep(i,N) rep(j,4) memo[i][j]=-1;\n\trep(i,N) chmax(ans,dfs(i,-1));\n\tif(ans>=inf) puts(\"Infinite\");\n\telse cout<<ans<<endl;\n\tEND_STACK_EXTEND;\n}"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\n\nusing namespace std;\n\nconst int INF = 1 << 29;\n\nstruct UnionFind\n{\n  vector< int > data;\n\n  UnionFind(int sz)\n  {\n    data.assign(sz, -1);\n  }\n\n  int find(int k)\n  {\n    return (data[k] < 0 ? k : data[k] = find(data[k]));\n  }\n\n  void unite(int x, int y)\n  {\n    x = find(x);\n    y = find(y);\n    if(x == y) return;\n    if(data[x] > data[y]) swap(x, y);\n    data[x] += data[y];\n    data[y] = x;\n  }\n};\n\nvector< pair< int, int > > g[100001];\nvector< int > leftt[100001], rightt[100001], just[100001];\nvector< int > gg[100001];\nint deg[100001];\n\n\nint rec(int idx, int back = -1)\n{\n  if(back != -1) {\n    int tmp = max(leftt[idx][back], rightt[idx][back + 1]);\n    if(tmp != INF) return (tmp);\n  }\n  if(rightt[idx][0] == INF) {\n    for(int i = 0; i < g[idx].size(); i++) {\n      int to, rev;\n      tie(to, rev) = g[idx][i];\n      if(i == back) continue;\n      just[idx][i] = rec(to, rev) + 1;\n    }\n    for(int i = 0; i < g[idx].size(); i++) {\n      leftt[idx][i + 1] = max(leftt[idx][i], just[idx][i]);\n    }\n    for(int i = (int) g[idx].size() - 1; i >= 0; i--) {\n      rightt[idx][i] = max(rightt[idx][i + 1], just[idx][i]);\n    }\n  }\n  if(back == -1) return (rightt[idx][0]);\n  return (max(leftt[idx][back], rightt[idx][back + 1]));\n}\n\n\nint main()\n{\n  int N, M;\n  vector< pair< int, int > > edges, arcs;\n\n  scanf(\"%d %d\", &N, &M);\n\n  UnionFind uf(N);\n\n  for(int i = 0; i < M; i++) {\n    int x, y, t;\n    cin >> x >> y >> t;\n    --x, --y;\n    if(t == 1) {\n      arcs.emplace_back(x, y);\n      g[x].emplace_back(y, -1);\n    } else {\n      if(uf.find(x) == uf.find(y)) {\n        cout << \"Infinite\" << endl;\n        return (0);\n      }\n      uf.unite(x, y);\n      edges.emplace_back(x, y);\n      g[y].emplace_back(x, g[x].size());\n      g[x].emplace_back(y, g[y].size() - 1);\n    }\n  }\n\n  {\n    for(auto &e : arcs) {\n      gg[uf.find(e.first)].push_back(uf.find(e.second));\n      ++deg[uf.find(e.second)];\n    }\n    vector< int > order;\n    for(int i = 0; i < N; i++) {\n      if(deg[i] == 0) order.push_back(i);\n    }\n    for(int i = 0; i < order.size(); i++) {\n      for(auto &e : gg[order[i]]) {\n        if(--deg[e] == 0) order.push_back(e);\n      }\n    }\n    if(order.size() != N) {\n      cout << \"Infinite\" << endl;\n      return (0);\n    }\n  }\n\n\n  int ret = 0;\n  for(int i = 0; i < N; i++) {\n    int sz = g[i].size();\n    just[i].assign(sz, INF);\n    leftt[i].assign(sz + 1, INF);\n    rightt[i].assign(sz + 1, INF);\n    leftt[i][0] = rightt[i][sz] = 0;\n  }\n  for(int i = 0; i < N; i++) ret = max(ret, rec(i));\n  cout << ret << endl;\n}"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\n\nusing namespace std;\n\nconst int INF = 1 << 29;\n\nstruct UnionFind\n{\n  vector< int > data;\n\n  UnionFind(int sz)\n  {\n    data.assign(sz, -1);\n  }\n\n  int find(int k)\n  {\n    return (data[k] < 0 ? k : data[k] = find(data[k]));\n  }\n\n  void unite(int x, int y)\n  {\n    x = find(x);\n    y = find(y);\n    if(x == y) return;\n    if(data[x] > data[y]) swap(x, y);\n    data[x] += data[y];\n    data[y] = x;\n  }\n};\n\nvector< pair< int, int > > g[100001];\nvector< int > leftt[100001], rightt[100001], just[100001];\nvector< int > gg[100001];\nint deg[100001];\n\n\nint rec(int idx, int back = -1)\n{\n  if(back != -1) {\n    int tmp = max(leftt[idx][back], rightt[idx][back + 1]);\n    if(tmp != INF) return (tmp);\n  }\n  if(rightt[idx][0] == INF) {\n    for(int i = 0; i < g[idx].size(); i++) {\n      int to, rev;\n      tie(to, rev) = g[idx][i];\n      if(i == back || just[idx][i] != INF) continue;\n      just[idx][i] = rec(to, rev) + 1;\n    }\n    for(int i = 0; i < g[idx].size(); i++) {\n      leftt[idx][i + 1] = max(leftt[idx][i], just[idx][i]);\n    }\n    for(int i = (int) g[idx].size() - 1; i >= 0; i--) {\n      rightt[idx][i] = max(rightt[idx][i + 1], just[idx][i]);\n    }\n  }\n\n  if(back == -1) return (rightt[idx][0]);\n  return (max(leftt[idx][back], rightt[idx][back + 1]));\n}\n\n\nint main()\n{\n  int N, M;\n  vector< pair< int, int > > edges, arcs;\n\n  scanf(\"%d %d\", &N, &M);\n\n  UnionFind uf(N);\n\n  for(int i = 0; i < M; i++) {\n    int x, y, t;\n    cin >> x >> y >> t;\n    --x, --y;\n    if(t == 1) {\n      arcs.emplace_back(x, y);\n      g[x].emplace_back(y, -1);\n    } else {\n      if(uf.find(x) == uf.find(y)) {\n        cout << \"Infinite\" << endl;\n        return (0);\n      }\n      uf.unite(x, y);\n      edges.emplace_back(x, y);\n      g[y].emplace_back(x, g[x].size());\n      g[x].emplace_back(y, g[y].size() - 1);\n    }\n  }\n\n  {\n    for(auto &e : arcs) {\n      gg[uf.find(e.first)].push_back(uf.find(e.second));\n      ++deg[uf.find(e.second)];\n    }\n    vector< int > order;\n    for(int i = 0; i < N; i++) {\n      if(deg[i] == 0) order.push_back(i);\n    }\n    for(int i = 0; i < order.size(); i++) {\n      for(auto &e : gg[i]) {\n        if(--deg[e] == 0) order.push_back(e);\n      }\n    }\n    if(order.size() != N) {\n      cout << \"Infinite\" << endl;\n      return (0);\n    }\n  }\n\n\n  int ret = 0;\n  for(int i = 0; i < N; i++) {\n    int sz = g[i].size();\n    just[i].assign(sz, INF);\n    leftt[i].assign(sz + 1, INF);\n    rightt[i].assign(sz + 1, INF);\n    leftt[i][0] = rightt[i][sz] = 0;\n  }\n  for(int i = 0; i < N; i++) ret = max(ret, rec(i));\n  cout << ret << endl;\n}"
  },
  {
    "language": "C++",
    "code": "#include<bits/stdc++.h>\nusing namespace std;\n#define MAX_N 100005\n#define MAX_M 100005\n \nint n,m,ans;\nint x[MAX_M],y[MAX_M],w[MAX_M];\nvector<int> G[MAX_N];\nvector<int> g[MAX_N];\nvector<int> group[MAX_N];\nint id[MAX_N];\nbool visited[MAX_N];\nvector<int> vd;\nint dp[MAX_N];\nint d[MAX_N];\n \nbool dfs(int pos,int prev,int root){\n  id[pos]=root;\n  visited[pos]=true;\n  group[root].push_back(pos);\n  for(int i=0;i<(int)G[pos].size();i++){\n    int to=G[pos][i];\n    if(to==prev)continue;\n    if(i&&to==G[pos][i-1])return true;\n    if(visited[to])return true;\n    if(dfs(to,pos,root))return true;\n  }\n  return false;\n}\n \nbool check(){\n  memset(visited,false,sizeof(visited));\n  for(int i=0;i<n;i++)\n    if(!visited[i]&&dfs(i,-1,i))return true;\n \n  vector<int> deg(n);\n  for(int pos=0;pos<n;pos++)\n    for(int to:g[pos])\n      deg[ id[to] ]++;\n \n  queue<int> Q;\n  for(int i=0;i<n;i++)\n    if(deg[i]==0&&id[i]==i)\n      Q.push(i);\n   \n  while(!Q.empty()){\n    int root=Q.front();Q.pop();\n    vd.push_back(root);\n    for(int pos:group[root]){\n      for(int to:g[pos]){\n        deg[ id[to] ]--;\n        if(deg[ id[to] ]==0)Q.push(id[to]);\n      }\n    }\n  }\n  for(int i=0;i<n;i++)\n    if(deg[i]>0)return true;\n  return false;\n}\n \nint solve(int S){\n  for(int pos:group[id[S]])d[pos]=-1;\n  queue<int> Q;\n  Q.push(S);\n  d[S]=0;\n  while(!Q.empty()){\n    int pos=Q.front();Q.pop();\n    for(int to:G[pos]){\n      if(d[to]!=-1)continue;\n      d[to]=d[pos]+1;\n      Q.push(to);\n    }\n  }\n  int res=S;\n  for(int pos:group[id[S]]){\n    if(d[pos]+dp[pos]>d[res]+dp[res])res=pos;\n    ans=max(ans,d[pos]+dp[S]);\n    for(int to:g[pos])dp[to]=max(dp[to],d[pos]+dp[S]+1);\n  }\n  return res;\n}\n \nint main(){\n  scanf(\"%d %d\",&n,&m);\n  for(int i=0;i<m;i++){\n    scanf(\"%d %d %d\",&x[i],&y[i],&w[i]);\n    x[i]--,y[i]--;\n    if(w[i]==1){\n      g[x[i]].push_back(y[i]);\n    }\n    if(w[i]==2){\n      G[x[i]].push_back(y[i]);\n      G[y[i]].push_back(x[i]);\n    }\n  }\n  if(check()){\n    printf(\"Infinite\\n\");\n    return 0;\n  }\n  for(int root : vd )\n    if(root==id[root])\n      solve(solve(solve(root)));\n  printf(\"%d\\n\",ans);  \n  return 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\n#define rep(i,N) for(int i=0;i<(int)N;i++)\n#define rep1(i,N) for(int i=1;i<=(int)N;i++)\n#define pb push_back\n#define all(c) c.begin(),c.end()\n#define show(x) cout<<#x<<\" \"<<x<<endl\n#define chmax(x,y) x=max(x,y)\n#define BEGIN_STACK_EXTEND(size) void * stack_extend_memory_ = malloc(size);void * stack_extend_origin_memory_;char * stack_extend_dummy_memory_ = (char*)alloca((1+(int)(((long long)stack_extend_memory_)&127))*16);*stack_extend_dummy_memory_ = 0;asm volatile(\"mov %%rsp, %%rbx\\nmov %%rax, %%rsp\":\"=b\"(stack_extend_origin_memory_):\"a\"((char*)stack_extend_memory_+(size)-1024));\n#define END_STACK_EXTEND asm volatile(\"mov %%rax, %%rsp\"::\"a\"(stack_extend_origin_memory_));free(stack_extend_memory_);\nusing namespace std;\nstruct edge {int to,w,rev;};\ntypedef vector< vector<edge> > Graph;\nGraph G,oG;\nvoid add_edge(int x,int y,int w,int way){\n\tif(way==1){\n\t\tG[x].pb({y,w,-1});\n\t}else{\n\t\tint X=G[x].size(),Y=G[y].size();\n\t\tG[x].pb({y,w,Y});\n\t\tG[y].pb({x,w,X});\n\t}\n}\n\ntypedef pair<int,int> P;\nmap<P,int> memo;\nset<P> vis;\nint dfs(int v,int eid){\n\tif(memo.count(P(v,eid))) return memo[P(v,eid)];\n\tif(vis.count(P(v,eid))){\n\t\tputs(\"Infinite\");\n\t\texit(1);\n\t}\n\tvis.insert(P(v,eid));\n\tint ret=0;\n\trep(i,G[v].size()) if(i!=eid){\n\t\tedge& e=G[v][i];\n\t\tchmax(ret,dfs(e.to,e.rev)+e.w);\n\t}\n\tmemo[P(v,eid)]=ret;\n\treturn ret;\n}\n\nint rs[100001]={};\nint its[100000]={};\n\nint main(){\n\tBEGIN_STACK_EXTEND(512*1024*1024);\n\tint N,M;\n\tcin>>N>>M;\n\toG.resize(N);\n\trep(i,M){\n\t\tint x,y,w;\n\t\tscanf(\"%d %d %d\",&x,&y,&w);\n\t\tx--,y--;\n\t\tif(w==1){\n\t\t\toG[x].pb(edge{y,1,-1});\n\t\t}else{\n\t\t\tint X=oG[x].size(),Y=oG[y].size();\n\t\t\toG[x].pb(edge{y,1,Y});\n\t\t\toG[y].pb(edge{x,1,X});\n\t\t}\n\t}\n\tint newN=0;\n\trep(i,N){\n\t\tint sz=oG[i].size();\n\t\tif(sz==0) sz=1;\n\t\trs[i]=newN;\n\t\tits[i]=rs[i];\n\t\tnewN+=sz;\n\t}\n\trs[N]=newN;\n\tG.resize(newN);\n\trep(x,N){\n\t\tint n=rs[x+1]-rs[x];\n\t\tfor(int v=rs[x];v<rs[x]+n-1;v++) add_edge(v,v+1,0,2);\n\t\tfor(edge e: oG[x]){\n\t\t\tif(e.rev==-1){\t//one way\n\t\t\t\tadd_edge(its[x],rs[e.to],1,1);\n\t\t\t\tits[x]++;\n\t\t\t}else{\n\t\t\t\tif(x<e.to){\n\t\t\t\t\tadd_edge(its[x],its[e.to],1,2);\n\t\t\t\t\tits[x]++;\n\t\t\t\t\tits[e.to]++;\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t}\n\tint ans=0;\n\tN=newN;\n\trep(i,N){\n\t\tchmax(ans,dfs(i,-1));\n\t}\n\tcout<<ans<<endl;\n\tEND_STACK_EXTEND;\n}"
  },
  {
    "language": "C++",
    "code": "#include<bits/stdc++.h>\nusing namespace std;\n#define MAX_N 100005\n#define MAX_M 100005\n\nint n,m;\nint x[MAX_M],y[MAX_M],w[MAX_M];\n\nvector<int> G[MAX_N];\nvector<int> g[MAX_N];\n\nvector<int> group[MAX_N];\nint id[MAX_N];\nbool visited[MAX_N];\nvector<int> vd;\n\nint dp[MAX_N];\n\nbool dfs(int pos,int prev,int root){\n  id[pos]=root;\n  visited[pos]=true;\n  group[root].push_back(pos);\n  for(int i=0;i<(int)G[pos].size();i++){\n    int to=G[pos][i];\n    if(to==prev)continue;\n    if(i&&to==G[pos][i-1])return true;\n    if(visited[to])return true;\n    if(dfs(to,pos,root))return true;\n  }\n  return false;\n}\n\nbool check(){\n  memset(visited,false,sizeof(visited));\n  for(int i=0;i<n;i++){\n    if(visited[i])continue;\n    if( dfs(i,-1,i) )return true;\n  }\n\n  vector< int > deg(n);\n  vector< vector<int> > graph(n);\n  \n  for(int i=0;i<m;i++){\n    if(w[i]==1){\n      int X=id[ x[i] ];\n      int Y=id[ y[i] ];\n      if(X==Y)return true;\n      graph[X].push_back(Y);\n      deg[Y]++;\n    }\n  }\n\n  queue<int> Q;\n  for(int i=0;i<n;i++)\n    if(deg[i]==0&&id[i]==i)\n      Q.push(i);\n\n  while(!Q.empty()){\n    int pos=Q.front();Q.pop();\n    vd.push_back(pos);\n    for(int to:graph[pos]){\n      deg[to]--;\n      if(deg[to]==0)Q.push(to);\n    }\n  }\n  \n  for(int i=0;i<n;i++)\n    if(deg[i]>0)return true;\n  \n  return false;\n}\n\nint d[MAX_N];\n\nvoid init(int root){\n  root=id[root];\n  for(int pos:group[root])\n    d[pos]=-1;\n}\n\nvoid bfs(int root){\n  init(root);\n  queue<int> Q;\n  Q.push(root);\n  d[root]=0;\n  while(!Q.empty()){\n    int pos=Q.front();Q.pop();\n    for(int to:G[pos]){\n      if(d[to]!=-1)continue;\n      d[to]=d[pos]+1;\n      Q.push(to);\n    }\n  }\n}\n\nvoid update(int root,int dif){\n  for(int pos:group[root])\n    for(int to:g[pos])\n      dp[to]=max(dp[to],d[pos]+dif+1);\n}\n\nint solve(int root,int &ans){\n  update(root,dp[root]);\n  bfs(root);\n  \n  int maxmid=root;\n  for(int pos:group[root])\n    if(d[pos]+dp[pos]>d[maxmid]+dp[maxmid])\n      maxmid=pos;\n  ans=max(ans,d[maxmid]+dp[maxmid]);\n  return maxmid;\n}\n\n  /*\n  int res=0;\n  bfs(root);\n  int maxm=-1,maxmid;\n  for(int pos:group[root])\n    if(d[pos]+dp[pos]>maxm)maxm=d[pos]+dp[pos],maxmid=pos;\n  \n  bfs(maxmid);\n  update(root,dp[maxmid]);\n  for(int pos:group[root])res=max(res,d[pos]+dp[maxmid]);\n  \n  maxm=-1;\n  for(int pos:group[root])\n    if(d[pos]+dp[pos]>maxm)maxm=d[pos]+dp[pos],maxmid=pos;\n\n  bfs(maxmid);\n  update(root,dp[maxmid]);\n  for(int pos:group[root])res=max(res,d[pos]+dp[maxmid]);\n  \n  return res;\n  */\n\n\nint main(){\n  scanf(\"%d %d\",&n,&m);\n  for(int i=0;i<m;i++){\n    scanf(\"%d %d %d\",&x[i],&y[i],&w[i]);\n    x[i]--,y[i]--;\n    if(w[i]==1){\n      g[x[i]].push_back(y[i]);\n    }\n    if(w[i]==2){\n      G[x[i]].push_back(y[i]);\n      G[y[i]].push_back(x[i]);\n    }\n  }\n  \n  if( check() ){\n    printf(\"Infinite\\n\");\n    return 0;\n  }\n\n  int ans=0;\n  for(int root : vd ){\n    if(root!=id[root])continue;\n    solve(solve(solve(root,ans),ans),ans);\n  }\n  printf(\"%d\\n\",ans);  \n  return 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\n#define rep(i,N) for(int i=0;i<(int)N;i++)\n#define rep1(i,N) for(int i=1;i<=(int)N;i++)\n#define pb push_back\n#define all(c) c.begin(),c.end()\n#define show(x) cout<<#x<<\" \"<<x<<endl\n#define chmax(x,y) x=max(x,y)\n#define BEGIN_STACK_EXTEND(size) void * stack_extend_memory_ = malloc(size);void * stack_extend_origin_memory_;char * stack_extend_dummy_memory_ = (char*)alloca((1+(int)(((long long)stack_extend_memory_)&127))*16);*stack_extend_dummy_memory_ = 0;asm volatile(\"mov %%rsp, %%rbx\\nmov %%rax, %%rsp\":\"=b\"(stack_extend_origin_memory_):\"a\"((char*)stack_extend_memory_+(size)-1024));\n#define END_STACK_EXTEND asm volatile(\"mov %%rax, %%rsp\"::\"a\"(stack_extend_origin_memory_));free(stack_extend_memory_);\nusing namespace std;\nconst int MN=100000;\nstruct edge {int to,w,rev;};\ntypedef vector< vector<edge> > Graph;\nGraph G,oG;\nvoid add_edge(int x,int y,int w,int way){\n\tif(way==1){\n\t\tG[x].pb({y,w,-1});\n\t}else{\n\t\tint X=G[x].size(),Y=G[y].size();\n\t\tG[x].pb({y,w,Y});\n\t\tG[y].pb({x,w,X});\n\t}\n}\n\ntypedef pair<int,int> P;\nint memo[300000][4];\nbool vis[300000][4];\nint dfs(int v,int eid){\n\teid++;\n\tif(memo[v][eid]!=-1) return memo[v][eid];\n\tif(vis[v][eid]){\n\t\tputs(\"Infinite\");\n\t\texit(1);\n\t}\n\tvis[v][eid]=1;\n\tint ret=0;\n\trep(i,G[v].size()) if(i!=eid-1){\n\t\tedge& e=G[v][i];\n\t\tchmax(ret,dfs(e.to,e.rev)+e.w);\n\t}\n\tmemo[v][eid]=ret;\n\treturn ret;\n}\n\nint rs[100001]={};\nint its[100000]={};\n\nint main(){\n//\tBEGIN_STACK_EXTEND(512*1024*1024);\n\tint N,M;\n\tcin>>N>>M;\n\toG.resize(N);\n\trep(i,M){\n\t\tint x,y,w;\n\t\tscanf(\"%d %d %d\",&x,&y,&w);\n\t\tx--,y--;\n\t\tif(w==1){\n\t\t\toG[x].pb(edge{y,1,-1});\n\t\t}else{\n\t\t\tint X=oG[x].size(),Y=oG[y].size();\n\t\t\toG[x].pb(edge{y,1,Y});\n\t\t\toG[y].pb(edge{x,1,X});\n\t\t}\n\t}\n\tint newN=0;\n\trep(i,N){\n\t\tint sz=oG[i].size();\n\t\tif(sz==0) sz=1;\n\t\trs[i]=newN;\n\t\tits[i]=rs[i];\n\t\tnewN+=sz;\n\t}\n\trs[N]=newN;\n\tG.resize(newN);\n\trep(x,N){\n\t\tint n=rs[x+1]-rs[x];\n\t\tfor(int v=rs[x];v<rs[x]+n-1;v++) add_edge(v,v+1,0,2);\n\t\tfor(edge e: oG[x]){\n\t\t\tif(e.rev==-1){\t//one way\n\t\t\t\tadd_edge(its[x],rs[e.to],1,1);\n\t\t\t\tits[x]++;\n\t\t\t}else{\n\t\t\t\tif(x<e.to){\n\t\t\t\t\tadd_edge(its[x],its[e.to],1,2);\n\t\t\t\t\tits[x]++;\n\t\t\t\t\tits[e.to]++;\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t}\n\tint ans=0;\n\tN=newN;\n//\trep(i,N) assert(G[i].size()<=3);\n\trep(i,N) rep(j,4) memo[i][j]=-1;\n\trep(i,N) chmax(ans,dfs(i,-1));\n\tcout<<ans<<endl;\n//\tEND_STACK_EXTEND;\n}"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\n#define rep(i,N) for(int i=0;i<(int)N;i++)\n#define rep1(i,N) for(int i=1;i<=(int)N;i++)\n#define pb push_back\n#define all(c) c.begin(),c.end()\n#define show(x) cout<<#x<<\" \"<<x<<endl\n#define chmax(x,y) x=max(x,y)\n#define BEGIN_STACK_EXTEND(size) void * stack_extend_memory_ = malloc(size);void * stack_extend_origin_memory_;char * stack_extend_dummy_memory_ = (char*)alloca((1+(int)(((long long)stack_extend_memory_)&127))*16);*stack_extend_dummy_memory_ = 0;asm volatile(\"mov %%rsp, %%rbx\\nmov %%rax, %%rsp\":\"=b\"(stack_extend_origin_memory_):\"a\"((char*)stack_extend_memory_+(size)-1024));\n#define END_STACK_EXTEND asm volatile(\"mov %%rax, %%rsp\"::\"a\"(stack_extend_origin_memory_));free(stack_extend_memory_);\nusing namespace std;\nstruct edge {int to,w,rev;};\ntypedef vector< vector<edge> > Graph;\nGraph G,oG;\nvoid add_edge(int x,int y,int w,int way){\n\tif(way==1){\n\t\tG[x].pb({y,w,-1});\n\t}else{\n\t\tint X=G[x].size(),Y=G[y].size();\n\t\tG[x].pb({y,w,Y});\n\t\tG[y].pb({x,w,X});\n\t}\n}\n\ntypedef pair<int,int> P;\nmap<P,int> memo;\nset<P> vis;\nint dfs(int v,int eid){\n\tif(memo.count(P(v,eid))) return memo[P(v,eid)];\n\tif(vis.count(P(v,eid))){\n\t\tputs(\"Infinite\");\n\t\texit(1);\n\t}\n\tvis.insert(P(v,eid));\n\tint ret=0;\n\trep(i,G[v].size()) if(i!=eid){\n\t\tedge& e=G[v][i];\n\t\tchmax(ret,dfs(e.to,e.rev)+e.w);\n\t}\n\tmemo[P(v,eid)]=ret;\n\treturn ret;\n}\n\nint rs[100001]={};\nint its[100000]={};\n\nint main(){\n\tBEGIN_STACK_EXTEND(128*1024*1024);\n\tint N,M;\n\tcin>>N>>M;\n\toG.resize(N);\n\trep(i,M){\n\t\tint x,y,w;\n\t\tscanf(\"%d %d %d\",&x,&y,&w);\n\t\tx--,y--;\n\t\tif(w==1){\n\t\t\toG[x].pb(edge{y,1,-1});\n\t\t}else{\n\t\t\tint X=oG[x].size(),Y=oG[y].size();\n\t\t\toG[x].pb(edge{y,1,Y});\n\t\t\toG[y].pb(edge{x,1,X});\n\t\t}\n\t}\n\tint newN=0;\n\trep(i,N){\n\t\tint sz=oG[i].size();\n\t\tif(sz==0) sz=1;\n\t\trs[i]=newN;\n\t\tits[i]=rs[i];\n\t\tnewN+=sz;\n\t}\n\trs[N]=newN;\n\tG.resize(newN);\n\trep(x,N){\n\t\tint n=rs[x+1]-rs[x];\n\t\tfor(int v=rs[x];v<rs[x]+n-1;v++) add_edge(v,v+1,0,2);\n\t\tfor(edge e: oG[x]){\n\t\t\tif(e.rev==-1){\t//one way\n\t\t\t\tadd_edge(its[x],rs[e.to],1,1);\n\t\t\t\tits[x]++;\n\t\t\t}else{\n\t\t\t\tif(x<e.to){\n\t\t\t\t\tadd_edge(its[x],its[e.to],1,2);\n\t\t\t\t\tits[x]++;\n\t\t\t\t\tits[e.to]++;\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t}\n\tint ans=0;\n\tN=newN;\n\trep(i,N){\n\t\tchmax(ans,dfs(i,-1));\n\t}\n\tcout<<ans<<endl;\n\tEND_STACK_EXTEND;\n}"
  },
  {
    "language": "C++",
    "code": "#include<bits/stdc++.h>\nusing namespace std;\n#define MAX_N 100005\n#define MAX_M 100005\n\nint n,m;\nint x[MAX_M],y[MAX_M],w[MAX_M];\n\nvector<int> G[MAX_N];\nvector<int> g[MAX_N];\n\nvector<int> group[MAX_N];\nint id[MAX_N];\nbool visited[MAX_N];\nvector<int> vd;\n\nint dp[MAX_N];\n\nbool dfs(int pos,int prev,int root){\n  id[pos]=root;\n  visited[pos]=true;\n  group[root].push_back(pos);\n  for(int i=0;i<(int)G[pos].size();i++){\n    int to=G[pos][i];\n    if(to==prev)continue;\n    if(i&&to==G[pos][i-1])return true;\n    if(visited[to])return true;\n    if(dfs(to,pos,root))return true;\n  }\n  return false;\n}\n\nbool check(){\n  memset(visited,false,sizeof(visited));\n  for(int i=0;i<n;i++){\n    if(visited[i])continue;\n    if( dfs(i,-1,i) )return true;\n  }\n\n  vector< int > deg(n);\n  vector< vector<int> > graph(n);\n  \n  for(int i=0;i<m;i++){\n    if(w[i]==1){\n      int X=id[ x[i] ];\n      int Y=id[ y[i] ];\n      if(X==Y)return true;\n      graph[X].push_back(Y);\n      deg[Y]++;\n    }\n  }\n\n  queue<int> Q;\n  for(int i=0;i<n;i++)\n    if(deg[i]==0&&id[i]==i)\n      Q.push(i);\n\n  while(!Q.empty()){\n    int pos=Q.front();Q.pop();\n    vd.push_back(pos);\n    for(int to:graph[pos]){\n      deg[to]--;\n      if(deg[to]==0)Q.push(to);\n    }\n  }\n  \n  for(int i=0;i<n;i++)\n    if(deg[i]>0)return true;\n  \n  return false;\n}\n\nint d[MAX_N];\n\nvoid init(int root){\n  root=id[root];\n  for(int pos:group[root])\n    d[pos]=-1;\n}\n\nvoid bfs(int root){\n  init(root);\n  queue<int> Q;\n  Q.push(root);\n  d[root]=0;\n  while(!Q.empty()){\n    int pos=Q.front();Q.pop();\n    for(int to:G[pos]){\n      if(d[to]!=-1)continue;\n      d[to]=d[pos]+1;\n      Q.push(to);\n    }\n  }\n}\n\nvoid update(int root,int dif){\n  for(int pos:group[root])\n    for(int to:g[pos])\n      dp[to]=max(dp[to],d[pos]+dif+1);\n}\n\nint solve(int root,int &ans){\n  update(root,dp[root]);\n  bfs(root);\n  \n  int maxmid=root;\n  for(int pos:group[root])\n    if(d[pos]+dp[pos]>d[maxmid]+dp[maxmid])\n      maxmid=pos;\n  ans=max(ans,d[maxmid]+dp[maxmid]);\n  return maxmid;\n}\n\n  /*\n  int res=0;\n  bfs(root);\n  int maxm=-1,maxmid;\n  for(int pos:group[root])\n    if(d[pos]+dp[pos]>maxm)maxm=d[pos]+dp[pos],maxmid=pos;\n  \n  bfs(maxmid);\n  update(root,dp[maxmid]);\n  for(int pos:group[root])res=max(res,d[pos]+dp[maxmid]);\n  \n  maxm=-1;\n  for(int pos:group[root])\n    if(d[pos]+dp[pos]>maxm)maxm=d[pos]+dp[pos],maxmid=pos;\n\n  bfs(maxmid);\n  update(root,dp[maxmid]);\n  for(int pos:group[root])res=max(res,d[pos]+dp[maxmid]);\n  \n  return res;\n  */\n\n\nint main(){\n  scanf(\"%d %d\",&n,&m);\n  for(int i=0;i<m;i++){\n    scanf(\"%d %d %d\",&x[i],&y[i],&w[i]);\n    x[i]--,y[i]--;\n    if(w[i]==1){\n      g[x[i]].push_back(y[i]);\n    }\n    if(w[i]==2){\n      G[x[i]].push_back(y[i]);\n      G[y[i]].push_back(x[i]);\n    }\n  }\n  \n  if( check() ){\n    printf(\"Infinite\\n\");\n    return 0;\n  }\n\n  int ans=0;\n  for(int root : vd ){\n    if(root!=id[root])continue;\n    solve(solve(solve(root,ans),ans),ans);\n  }\n  printf(\"%d\\n\",ans);  \n  return 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\n#define rep(i,N) for(int i=0;i<(int)N;i++)\n#define rep1(i,N) for(int i=1;i<=(int)N;i++)\n#define pb push_back\n#define all(c) c.begin(),c.end()\n#define show(x) cout<<#x<<\" \"<<x<<endl\n#define chmax(x,y) x=max(x,y)\n#define BEGIN_STACK_EXTEND(size) void * stack_extend_memory_ = malloc(size);void * stack_extend_origin_memory_;char * stack_extend_dummy_memory_ = (char*)alloca((1+(int)(((long long)stack_extend_memory_)&127))*16);*stack_extend_dummy_memory_ = 0;asm volatile(\"mov %%rsp, %%rbx\\nmov %%rax, %%rsp\":\"=b\"(stack_extend_origin_memory_):\"a\"((char*)stack_extend_memory_+(size)-1024));\n#define END_STACK_EXTEND asm volatile(\"mov %%rax, %%rsp\"::\"a\"(stack_extend_origin_memory_));free(stack_extend_memory_);\nusing namespace std;\nconst int MN=100000;\nstruct edge {int to,w,rev;};\ntypedef vector< vector<edge> > Graph;\nGraph G,oG;\nvoid add_edge(int x,int y,int w,int way){\n\tif(way==1){\n\t\tG[x].pb({y,w,-1});\n\t}else{\n\t\tint X=G[x].size(),Y=G[y].size();\n\t\tG[x].pb({y,w,Y});\n\t\tG[y].pb({x,w,X});\n\t}\n}\n\ntypedef pair<int,int> P;\nint memo[300000][4];\nbool vis[300000][4];\nint dfs(int v,int eid){\n\teid++;\n\tif(memo[v][eid]!=-1) return memo[v][eid];\n\tif(vis[v][eid]){\n\t\tputs(\"Infinite\");\n\t\texit(1);\n\t}\n\tvis[v][eid]=1;\n\tint ret=0;\n\trep(i,G[v].size()) if(i!=eid-1){\n\t\tedge& e=G[v][i];\n\t\tchmax(ret,dfs(e.to,e.rev)+e.w);\n\t}\n\t// if(G[v].size()>0 && eid!=1) chmax(ret,dfs(G[v][0].to,G[v][0].rev)+G[v][0].w);\n\t// if(G[v].size()>1 && eid!=2) chmax(ret,dfs(G[v][1].to,G[v][1].rev)+G[v][1].w);\n\t// if(G[v].size()>2 && eid!=3) chmax(ret,dfs(G[v][2].to,G[v][2].rev)+G[v][2].w);\n\tmemo[v][eid]=ret;\n\treturn ret;\n}\n\nint rs[100001]={};\nint its[100000]={};\n\nint main(){\n\tBEGIN_STACK_EXTEND(512*1024*1024);\n\tint N,M;\n\tcin>>N>>M;\n\toG.resize(N);\n\trep(i,M){\n\t\tint x,y,w;\n\t\tscanf(\"%d %d %d\",&x,&y,&w);\n\t\tx--,y--;\n\t\tif(w==1){\n\t\t\toG[x].pb(edge{y,1,-1});\n\t\t}else{\n\t\t\tint X=oG[x].size(),Y=oG[y].size();\n\t\t\toG[x].pb(edge{y,1,Y});\n\t\t\toG[y].pb(edge{x,1,X});\n\t\t}\n\t}\n\tint newN=0;\n\trep(i,N){\n\t\tint sz=oG[i].size();\n\t\tif(sz==0) sz=1;\n\t\trs[i]=newN;\n\t\tits[i]=rs[i];\n\t\tnewN+=sz;\n\t}\n\trs[N]=newN;\n\tG.resize(newN);\n\trep(x,N){\n\t\tint n=rs[x+1]-rs[x];\n\t\tfor(int v=rs[x];v<rs[x]+n-1;v++) add_edge(v,v+1,0,2);\n\t\tfor(edge e: oG[x]){\n\t\t\tif(e.rev==-1){\t//one way\n\t\t\t\tadd_edge(its[x],rs[e.to],1,1);\n\t\t\t\tits[x]++;\n\t\t\t}else{\n\t\t\t\tif(x<e.to){\n\t\t\t\t\tadd_edge(its[x],its[e.to],1,2);\n\t\t\t\t\tits[x]++;\n\t\t\t\t\tits[e.to]++;\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t}\n\tint ans=0;\n\tN=newN;\n//\trep(i,N) assert(G[i].size()<=3);\n\trep(i,N) rep(j,4) memo[i][j]=-1;\n\trep(i,N) chmax(ans,dfs(i,-1));\n\tcout<<ans<<endl;\n\tEND_STACK_EXTEND;\n}"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\n#define rep(i,N) for(int i=0;i<(int)N;i++)\n#define rep1(i,N) for(int i=1;i<=(int)N;i++)\n#define pb push_back\n#define all(c) c.begin(),c.end()\n#define show(x) cout<<#x<<\" \"<<x<<endl\n#define chmax(x,y) x=max(x,y)\n#define BEGIN_STACK_EXTEND(size) void * stack_extend_memory_ = malloc(size);void * stack_extend_origin_memory_;char * stack_extend_dummy_memory_ = (char*)alloca((1+(int)(((long long)stack_extend_memory_)&127))*16);*stack_extend_dummy_memory_ = 0;asm volatile(\"mov %%rsp, %%rbx\\nmov %%rax, %%rsp\":\"=b\"(stack_extend_origin_memory_):\"a\"((char*)stack_extend_memory_+(size)-1024));\n#define END_STACK_EXTEND asm volatile(\"mov %%rax, %%rsp\"::\"a\"(stack_extend_origin_memory_));free(stack_extend_memory_);\nusing namespace std;\nstruct edge {int to,w,rev;};\ntypedef vector< vector<edge> > Graph;\nGraph G,oG;\nvoid add_edge(int x,int y,int w,int way){\n\tif(way==1){\n\t\tG[x].pb({y,w,-1});\n\t}else{\n\t\tint X=G[x].size(),Y=G[y].size();\n\t\tG[x].pb({y,w,Y});\n\t\tG[y].pb({x,w,X});\n\t}\n}\n\ntypedef pair<int,int> P;\nmap<P,int> memo;\nset<P> vis;\nint dfs(int v,int eid){\n\tif(memo.count(P(v,eid))) return memo[P(v,eid)];\n\tif(vis.count(P(v,eid))){\n\t\tputs(\"Infinite\");\n\t\texit(1);\n\t}\n\tvis.insert(P(v,eid));\n\tint ret=0;\n\trep(i,G[v].size()) if(i!=eid){\n\t\tedge& e=G[v][i];\n\t\tchmax(ret,dfs(e.to,e.rev)+e.w);\n\t}\n\tmemo[P(v,eid)]=ret;\n\treturn ret;\n}\n\nint rs[100001]={};\nint its[100000]={};\n\nint main(){\n//\tBEGIN_STACK_EXTEND(512*1024*1024);\n\tint N,M;\n\tcin>>N>>M;\n\toG.resize(N);\n\trep(i,M){\n\t\tint x,y,w;\n\t\tscanf(\"%d %d %d\",&x,&y,&w);\n\t\tx--,y--;\n\t\tif(w==1){\n\t\t\toG[x].pb(edge{y,1,-1});\n\t\t}else{\n\t\t\tint X=oG[x].size(),Y=oG[y].size();\n\t\t\toG[x].pb(edge{y,1,Y});\n\t\t\toG[y].pb(edge{x,1,X});\n\t\t}\n\t}\n\tint newN=0;\n\trep(i,N){\n\t\tint sz=oG[i].size();\n\t\tif(sz==0) sz=1;\n\t\trs[i]=newN;\n\t\tits[i]=rs[i];\n\t\tnewN+=sz;\n\t}\n\trs[N]=newN;\n\tG.resize(newN);\n\trep(x,N){\n\t\tint n=rs[x+1]-rs[x];\n\t\tfor(int v=rs[x];v<rs[x]+n-1;v++) add_edge(v,v+1,0,2);\n\t\tfor(edge e: oG[x]){\n\t\t\tif(e.rev==-1){\t//one way\n\t\t\t\tadd_edge(its[x],rs[e.to],1,1);\n\t\t\t\tits[x]++;\n\t\t\t}else{\n\t\t\t\tif(x<e.to){\n\t\t\t\t\tadd_edge(its[x],its[e.to],1,2);\n\t\t\t\t\tits[x]++;\n\t\t\t\t\tits[e.to]++;\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t}\n\tint ans=0;\n\tN=newN;\n\trep(i,N) assert(G[i].size()<=3);\n//\trep(i,N) chmax(ans,dfs(i,-1));\n\tcout<<ans<<endl;\n//\tEND_STACK_EXTEND;\n}"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\n#define rep(i,N) for(int i=0;i<(int)N;i++)\n#define rep1(i,N) for(int i=1;i<=(int)N;i++)\n#define pb push_back\n#define all(c) c.begin(),c.end()\n#define show(x) cout<<#x<<\" \"<<x<<endl\n#define chmax(x,y) x=max(x,y)\nusing namespace std;\nstruct edge {int to,w,rev;};\ntypedef vector< vector<edge> > Graph;\nGraph G,oG;\nvoid add_edge(int x,int y,int w,int way){\n\tif(way==1){\n\t\tG[x].pb({y,w,-1});\n\t}else{\n\t\tint X=G[x].size(),Y=G[y].size();\n\t\tG[x].pb({y,w,Y});\n\t\tG[y].pb({x,w,X});\n\t}\n}\n\ntypedef pair<int,int> P;\nmap<P,int> memo;\nset<P> vis;\nint dfs(int v,int eid){\n\tif(memo.count(P(v,eid))) return memo[P(v,eid)];\n\tif(vis.count(P(v,eid))){\n\t\tputs(\"Infinite\");\n\t\texit(1);\n\t}\n\tvis.insert(P(v,eid));\n\tint ret=0;\n\trep(i,G[v].size()) if(i!=eid){\n\t\tedge& e=G[v][i];\n\t\tchmax(ret,dfs(e.to,e.rev)+e.w);\n\t}\n\tmemo[P(v,eid)]=ret;\n\treturn ret;\n}\n\nint rs[100001]={};\nint its[100000]={};\nint main(){\n\tint N,M;\n\tcin>>N>>M;\n\toG.resize(N);\n\trep(i,M){\n\t\tint x,y,w;\n\t\tscanf(\"%d %d %d\",&x,&y,&w);\n\t\tx--,y--;\n\t\tif(w==1){\n\t\t\toG[x].pb(edge{y,1,-1});\n\t\t}else{\n\t\t\tint X=oG[x].size(),Y=oG[y].size();\n\t\t\toG[x].pb(edge{y,1,Y});\n\t\t\toG[y].pb(edge{x,1,X});\n\t\t}\n\t}\n\tint newN=0;\n\trep(i,N){\n\t\tint sz=oG[i].size();\n\t\tif(sz==0) sz=1;\n\t\trs[i]=newN;\n\t\tits[i]=rs[i];\n\t\tnewN+=sz;\n\t}\n\trs[N]=newN;\n\tG.resize(newN);\n\trep(x,N){\n\t\tint n=rs[x+1]-rs[x];\n\t\tfor(int v=rs[x];v<rs[x]+n-1;v++) add_edge(v,v+1,0,2);\n\t\tfor(edge e: oG[x]){\n\t\t\tif(e.rev==-1){\t//one way\n\t\t\t\tadd_edge(its[x],rs[e.to],1,1);\n\t\t\t\tits[x]++;\n\t\t\t}else{\n\t\t\t\tif(x<e.to){\n\t\t\t\t\tadd_edge(its[x],its[e.to],1,2);\n\t\t\t\t\tits[x]++;\n\t\t\t\t\tits[e.to]++;\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t}\n\tint ans=0;\n\tN=newN;\n\trep(i,N){\n\t\tchmax(ans,dfs(i,-1));\n\t}\n\tcout<<ans<<endl;\n}"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\n#define rep(i,N) for(int i=0;i<(int)N;i++)\n#define rep1(i,N) for(int i=1;i<=(int)N;i++)\n#define pb push_back\n#define all(c) c.begin(),c.end()\n#define show(x) cout<<#x<<\" \"<<x<<endl\n#define chmax(x,y) x=max(x,y)\n#define BEGIN_STACK_EXTEND(size) void * stack_extend_memory_ = malloc(size);void * stack_extend_origin_memory_;char * stack_extend_dummy_memory_ = (char*)alloca((1+(int)(((long long)stack_extend_memory_)&127))*16);*stack_extend_dummy_memory_ = 0;asm volatile(\"mov %%rsp, %%rbx\\nmov %%rax, %%rsp\":\"=b\"(stack_extend_origin_memory_):\"a\"((char*)stack_extend_memory_+(size)-1024));\n#define END_STACK_EXTEND asm volatile(\"mov %%rax, %%rsp\"::\"a\"(stack_extend_origin_memory_));free(stack_extend_memory_);\nusing namespace std;\nstruct edge {int to,w,rev;};\ntypedef vector< vector<edge> > Graph;\nGraph G,oG;\nvoid add_edge(int x,int y,int w,int way){\n\tif(way==1){\n\t\tG[x].pb({y,w,-1});\n\t}else{\n\t\tint X=G[x].size(),Y=G[y].size();\n\t\tG[x].pb({y,w,Y});\n\t\tG[y].pb({x,w,X});\n\t}\n}\n\ntypedef pair<int,int> P;\nmap<P,int> memo;\nset<P> vis;\nint dfs(int v,int eid){\n\tif(memo.count(P(v,eid))) return memo[P(v,eid)];\n\tif(vis.count(P(v,eid))){\n\t\tputs(\"Infinite\");\n\t\texit(1);\n\t}\n\tvis.insert(P(v,eid));\n\tint ret=0;\n\trep(i,G[v].size()) if(i!=eid){\n\t\tedge& e=G[v][i];\n\t\tchmax(ret,dfs(e.to,e.rev)+e.w);\n\t}\n\tmemo[P(v,eid)]=ret;\n\treturn ret;\n}\n\nint rs[1000001]={};\nint its[1000000]={};\n\nint main(){\n//\tBEGIN_STACK_EXTEND(512*1024*1024);\n\tint N,M;\n\tcin>>N>>M;\n\toG.resize(N);\n\trep(i,M){\n\t\tint x,y,w;\n\t\tscanf(\"%d %d %d\",&x,&y,&w);\n\t\tx--,y--;\n\t\tif(w==1){\n\t\t\toG[x].pb(edge{y,1,-1});\n\t\t}else{\n\t\t\tint X=oG[x].size(),Y=oG[y].size();\n\t\t\toG[x].pb(edge{y,1,Y});\n\t\t\toG[y].pb(edge{x,1,X});\n\t\t}\n\t}\n\tint newN=0;\n\trep(i,N){\n\t\tint sz=oG[i].size();\n\t\tif(sz==0) sz=1;\n\t\trs[i]=newN;\n\t\tits[i]=rs[i];\n\t\tnewN+=sz;\n\t}\n\trs[N]=newN;\n\tG.resize(newN);\n\trep(x,N){\n\t\tint n=rs[x+1]-rs[x];\n\t\tfor(int v=rs[x];v<rs[x]+n-1;v++) add_edge(v,v+1,0,2);\n\t\tfor(edge e: oG[x]){\n\t\t\tif(e.rev==-1){\t//one way\n\t\t\t\tadd_edge(its[x],rs[e.to],1,1);\n\t\t\t\tits[x]++;\n\t\t\t}else{\n\t\t\t\tif(x<e.to){\n\t\t\t\t\tadd_edge(its[x],its[e.to],1,2);\n\t\t\t\t\tits[x]++;\n\t\t\t\t\tits[e.to]++;\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t}\n\tint ans=0;\n\tN=newN;\n//\trep(i,N) assert(G[i].size()<=3);\n\trep(i,N) chmax(ans,dfs(i,-1));\n\tcout<<ans<<endl;\n//\tEND_STACK_EXTEND;\n}"
  },
  {
    "language": "C++",
    "code": "#include<bits/stdc++.h>\nusing namespace std;\n/*\nnamespace fastIO{\n#define BUF_SIZE 100000\n#define OUT_SIZE 100000\n#define ll long long\n\t//fread->read\n\tbool IOerror=0;\n\tinline char nc(){\n\t\tstatic char buf[BUF_SIZE],*p1=buf+BUF_SIZE,*pend=buf+BUF_SIZE;\n\t\tif (p1==pend){\n\t\t\tp1=buf; pend=buf+fread(buf,1,BUF_SIZE,stdin);\n\t\t\tif (pend==p1){IOerror=1;return -1;}\n\t\t\t//{printf(\"IO error!\\n\");system(\"pause\");for (;;);exit(0);}\n\t\t}\n\t\treturn *p1++;\n\t}\n\tinline bool blank(char ch){return ch==' '||ch=='\\n'||ch=='\\r'||ch=='\\t';}\n\tinline bool read(int &x){\n\t\tbool sign=0; char ch=nc(); x=0;\n\t\tfor (;blank(ch);ch=nc());\n\t\tif (IOerror)return false;\n\t\tif (ch=='-')sign=1,ch=nc();\n\t\tfor (;ch>='0'&&ch<='9';ch=nc())x=x*10+ch-'0';\n\t\tif (sign)x=-x;\n\t\treturn true;\n\t}\n\tinline void read(ll &x){\n\t\tbool sign=0; char ch=nc(); x=0;\n\t\tfor (;blank(ch);ch=nc());\n\t\tif (IOerror)return;\n\t\tif (ch=='-')sign=1,ch=nc();\n\t\tfor (;ch>='0'&&ch<='9';ch=nc())x=x*10+ch-'0';\n\t\tif (sign)x=-x;\n\t}\n\tinline void read(double &x){\n\t\tbool sign=0; char ch=nc(); x=0;\n\t\tfor (;blank(ch);ch=nc());\n\t\tif (IOerror)return;\n\t\tif (ch=='-')sign=1,ch=nc();\n\t\tfor (;ch>='0'&&ch<='9';ch=nc())x=x*10+ch-'0';\n\t\tif (ch=='.'){\n\t\t\tdouble tmp=1; ch=nc();\n\t\t\tfor (;ch>='0'&&ch<='9';ch=nc())tmp/=10.0,x+=tmp*(ch-'0');\n\t\t}\n\t\tif (sign)x=-x;\n\t}\n\tinline void read(char *s){\n\t\tchar ch=nc();\n\t\tfor (;blank(ch);ch=nc());\n\t\tif (IOerror)return;\n\t\tfor (;!blank(ch)&&!IOerror;ch=nc())*s++=ch;\n\t\t*s=0;\n\t}\n\tinline void read(char &c){\n\t\tfor (c=nc();blank(c);c=nc());\n\t\tif (IOerror){c=-1;return;}\n\t}\n\t//getchar->read\n\tinline void read1(int &x){\n\t\tchar ch;int bo=0;x=0;\n\t\tfor (ch=getchar();ch<'0'||ch>'9';ch=getchar())if (ch=='-')bo=1;\n\t\tfor (;ch>='0'&&ch<='9';x=x*10+ch-'0',ch=getchar());\n\t\tif (bo)x=-x;\n\t}\n\tinline void read1(ll &x){\n\t\tchar ch;int bo=0;x=0;\n\t\tfor (ch=getchar();ch<'0'||ch>'9';ch=getchar())if (ch=='-')bo=1;\n\t\tfor (;ch>='0'&&ch<='9';x=x*10+ch-'0',ch=getchar());\n\t\tif (bo)x=-x;\n\t}\n\tinline void read1(double &x){\n\t\tchar ch;int bo=0;x=0;\n\t\tfor (ch=getchar();ch<'0'||ch>'9';ch=getchar())if (ch=='-')bo=1;\n\t\tfor (;ch>='0'&&ch<='9';x=x*10+ch-'0',ch=getchar());\n\t\tif (ch=='.'){\n\t\t\tdouble tmp=1;\n\t\t\tfor (ch=getchar();ch>='0'&&ch<='9';tmp/=10.0,x+=tmp*(ch-'0'),ch=getchar());\n\t\t}\n\t\tif (bo)x=-x;\n\t}\n\tinline void read1(char *s){\n\t\tchar ch=getchar();\n\t\tfor (;blank(ch);ch=getchar());\n\t\tfor (;!blank(ch);ch=getchar())*s++=ch;\n\t\t*s=0;\n\t}\n\tinline void read1(char &c){for (c=getchar();blank(c);c=getchar());}\n\t//scanf->read\n\tinline void read2(int &x){scanf(\"%d\",&x);}\n\tinline void read2(ll &x){\n#ifdef _WIN32\n\t\tscanf(\"%I64d\",&x);\n#else\n\t\t#ifdef __linux\n            scanf(\"%lld\",&x);\n        #else\n            puts(\"error:can't recognize the system!\");\n        #endif\n#endif\n\t}\n\tinline void read2(double &x){scanf(\"%lf\",&x);}\n\tinline void read2(char *s){scanf(\"%s\",s);}\n\tinline void read2(char &c){scanf(\" %c\",&c);}\n\tinline void readln2(char *s){gets(s);}\n\t//fwrite->write\n\tstruct Ostream_fwrite{\n\t\tchar *buf,*p1,*pend;\n\t\tOstream_fwrite(){buf=new char[BUF_SIZE];p1=buf;pend=buf+BUF_SIZE;}\n\t\tvoid out(char ch){\n\t\t\tif (p1==pend){\n\t\t\t\tfwrite(buf,1,BUF_SIZE,stdout);p1=buf;\n\t\t\t}\n\t\t\t*p1++=ch;\n\t\t}\n\t\tvoid print(int x){\n\t\t\tstatic char s[15],*s1;s1=s;\n\t\t\tif (!x)*s1++='0';if (x<0)out('-'),x=-x;\n\t\t\twhile(x)*s1++=x%10+'0',x/=10;\n\t\t\twhile(s1--!=s)out(*s1);\n\t\t}\n\t\tvoid println(int x){\n\t\t\tstatic char s[15],*s1;s1=s;\n\t\t\tif (!x)*s1++='0';if (x<0)out('-'),x=-x;\n\t\t\twhile(x)*s1++=x%10+'0',x/=10;\n\t\t\twhile(s1--!=s)out(*s1); out('\\n');\n\t\t}\n\t\tvoid print(ll x){\n\t\t\tstatic char s[25],*s1;s1=s;\n\t\t\tif (!x)*s1++='0';if (x<0)out('-'),x=-x;\n\t\t\twhile(x)*s1++=x%10+'0',x/=10;\n\t\t\twhile(s1--!=s)out(*s1);\n\t\t}\n\t\tvoid println(ll x){\n\t\t\tstatic char s[25],*s1;s1=s;\n\t\t\tif (!x)*s1++='0';if (x<0)out('-'),x=-x;\n\t\t\twhile(x)*s1++=x%10+'0',x/=10;\n\t\t\twhile(s1--!=s)out(*s1); out('\\n');\n\t\t}\n\t\tvoid print(double x,int y){\n\t\t\tstatic ll mul[]={1,10,100,1000,10000,100000,1000000,10000000,100000000,\n\t\t\t                 1000000000,10000000000LL,100000000000LL,1000000000000LL,10000000000000LL,\n\t\t\t                 100000000000000LL,1000000000000000LL,10000000000000000LL,100000000000000000LL};\n\t\t\tif (x<-1e-12)out('-'),x=-x;x*=mul[y];\n\t\t\tll x1=(ll)floor(x); if (x-floor(x)>=0.5)++x1;\n\t\t\tll x2=x1/mul[y],x3=x1-x2*mul[y]; print(x2);\n\t\t\tif (y>0){out('.'); for (size_t i=1;i<y&&x3*mul[i]<mul[y];out('0'),++i); print(x3);}\n\t\t}\n\t\tvoid println(double x,int y){print(x,y);out('\\n');}\n\t\tvoid print(char *s){while (*s)out(*s++);}\n\t\tvoid println(char *s){while (*s)out(*s++);out('\\n');}\n\t\tvoid flush(){if (p1!=buf){fwrite(buf,1,p1-buf,stdout);p1=buf;}}\n\t\t~Ostream_fwrite(){flush();}\n\t}Ostream;\n\tinline void print(int x){Ostream.print(x);}\n\tinline void println(int x){Ostream.println(x);}\n\tinline void print(char x){Ostream.out(x);}\n\tinline void println(char x){Ostream.out(x);Ostream.out('\\n');}\n\tinline void print(ll x){Ostream.print(x);}\n\tinline void println(ll x){Ostream.println(x);}\n\tinline void print(double x,int y){Ostream.print(x,y);}\n\tinline void println(double x,int y){Ostream.println(x,y);}\n\tinline void print(char *s){Ostream.print(s);}\n\tinline void println(char *s){Ostream.println(s);}\n\tinline void println(){Ostream.out('\\n');}\n\tinline void flush(){Ostream.flush();}\n\t//puts->write\n\tchar Out[OUT_SIZE],*o=Out;\n\tinline void print1(int x){\n\t\tstatic char buf[15];\n\t\tchar *p1=buf;if (!x)*p1++='0';if (x<0)*o++='-',x=-x;\n\t\twhile(x)*p1++=x%10+'0',x/=10;\n\t\twhile(p1--!=buf)*o++=*p1;\n\t}\n\tinline void println1(int x){print1(x);*o++='\\n';}\n\tinline void print1(ll x){\n\t\tstatic char buf[25];\n\t\tchar *p1=buf;if (!x)*p1++='0';if (x<0)*o++='-',x=-x;\n\t\twhile(x)*p1++=x%10+'0',x/=10;\n\t\twhile(p1--!=buf)*o++=*p1;\n\t}\n\tinline void println1(ll x){print1(x);*o++='\\n';}\n\tinline void print1(char c){*o++=c;}\n\tinline void println1(char c){*o++=c;*o++='\\n';}\n\tinline void print1(char *s){while (*s)*o++=*s++;}\n\tinline void println1(char *s){print1(s);*o++='\\n';}\n\tinline void println1(){*o++='\\n';}\n\tinline void flush1(){if (o!=Out){if (*(o-1)=='\\n')*--o=0;puts(Out);}}\n\tstruct puts_write{\n\t\t~puts_write(){flush1();}\n\t}_puts;\n\tinline void print2(int x){printf(\"%d\",x);}\n\tinline void println2(int x){printf(\"%d\\n\",x);}\n\tinline void print2(char x){printf(\"%c\",x);}\n\tinline void println2(char x){printf(\"%c\\n\",x);}\n\tinline void print2(ll x){\n#ifdef _WIN32\n\t\tprintf(\"%I64d\",x);\n#else\n\t\t#ifdef __linux\n            printf(\"%lld\",x);\n        #else\n            puts(\"error:can't recognize the system!\");\n        #endif\n#endif\n\t}\n\tinline void println2(ll x){print2(x);printf(\"\\n\");}\n\tinline void println2(){printf(\"\\n\");}\n#undef ll\n#undef OUT_SIZE\n#undef BUF_SIZE\n};\nusing namespace fastIO;\n\n*/\n#include<bits/stdc++.h>\nusing namespace std;\n#define  _GLIBCXX_PERMIT_BACKWARD_HASH\n#include <ext/hash_map>\n#include <ext/hash_set>\nusing namespace __gnu_cxx;\nstruct str_hash{\n\tsize_t operator()(const string& str) const\n\t{ return __stl_hash_string(str.c_str()); }};\n#include <ext/pb_ds/assoc_container.hpp>\n#include <ext/pb_ds/tree_policy.hpp>\n#include <ext/pb_ds/priority_queue.hpp>\nusing namespace __gnu_pbds;\n\nconst int maxn=(int)1e5+20;\nint pre[maxn];\nint num[maxn];\n\nint vis[maxn];\nint find(int x)\n{\n\n\tif(pre[x]==x)\n\t\treturn x;\n\tint t=pre[x];\n\tpre[x]=find(pre[x]);\n\tnum[x]+=num[t];\n\treturn pre[x];\n}\n\nvoid join(int x,int y,int z)\n{\n\tint ra=find(x);\n\tint rb=find(y);\n\tif(ra!=rb)\n\t{\n\t\tpre[rb]=ra;\n\t\tnum[rb] = num[x] - z - num[y];\n\t}\n}\n\nint main()\n{\n\tint n,m;\n\twhile(scanf(\"%d%d\",&n,&m)!=EOF)\n\t{\n\t\tmemset(vis,0,sizeof(vis));\n\t\tif(n+m==0)break;\n\t\tfor(int i=0;i<maxn;i++)\n\t\t{\n\t\t\tpre[i]=i;\n\t\t\tnum[i]=0;\n\t\t}\n\t\twhile(m--)\n\t\t{\n\t\t\tchar op[10];\n\t\t\tscanf(\"%s\",op);\n\t\t\tif(op[0]=='!')\n\t\t\t{\n\t\t\t\tint a,b,c;\n\t\t\t\tscanf(\"%d%d%d\",&a,&b,&c);\n\t\t\t\tjoin(a,b,c);\n\t\t\t}\n\t\t\telse\n\t\t\t{\n\t\t\t\tint a,b;\n\t\t\t\tscanf(\"%d%d\",&a,&b);\n\t\t\t\tif(find(a)==find(b))\n\t\t\t\t{\n\t\t\t\t\tprintf(\"%d\\n\",num[a]-num[b]);\n\t\t\t\t}\n\t\t\t\telse\n\t\t\t\t{\n\t\t\t\t\tputs(\"UNKNOWN\");\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t}\n}"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\n#define rep(i,N) for(int i=0;i<(int)N;i++)\n#define rep1(i,N) for(int i=1;i<=(int)N;i++)\n#define pb push_back\n#define all(c) c.begin(),c.end()\n#define show(x) cout<<#x<<\" \"<<x<<endl\n#define chmax(x,y) x=max(x,y)\n#define BEGIN_STACK_EXTEND(size) void * stack_extend_memory_ = malloc(size);void * stack_extend_origin_memory_;char * stack_extend_dummy_memory_ = (char*)alloca((1+(int)(((long long)stack_extend_memory_)&127))*16);*stack_extend_dummy_memory_ = 0;asm volatile(\"mov %%rsp, %%rbx\\nmov %%rax, %%rsp\":\"=b\"(stack_extend_origin_memory_):\"a\"((char*)stack_extend_memory_+(size)-1024));\n#define END_STACK_EXTEND asm volatile(\"mov %%rax, %%rsp\"::\"a\"(stack_extend_origin_memory_));free(stack_extend_memory_);\nusing namespace std;\nconst int MN=100000;\nstruct edge {int to,w,rev;};\ntypedef vector< vector<edge> > Graph;\nGraph G,oG;\nvoid add_edge(int x,int y,int w,int way){\n\tif(way==1){\n\t\tG[x].pb({y,w,-1});\n\t}else{\n\t\tint X=G[x].size(),Y=G[y].size();\n\t\tG[x].pb({y,w,Y});\n\t\tG[y].pb({x,w,X});\n\t}\n}\n\ntypedef pair<int,int> P;\nint memo[300000][4];\nbool vis[300000][4];\nint dfs(int v,int eid){\n\teid++;\n\tif(memo[v][eid]!=-1) return memo[v][eid];\n\tif(vis[v][eid]){\n\t\tputs(\"Infinite\");\n\t\texit(1);\n\t}\n\tvis[v][eid]=1;\n\tint ret=0;\n\trep(i,G[v].size()) if(i!=eid-1){\n\t\tedge& e=G[v][i];\n\t\tchmax(ret,dfs(e.to,e.rev)+e.w);\n\t}\n\tmemo[v][eid]=ret;\n\treturn ret;\n}\n\nint rs[100001]={};\nint its[100000]={};\n\nint main(){\n//\tBEGIN_STACK_EXTEND(512*1024*1024);\n\tint N,M;\n\tcin>>N>>M;\n\toG.resize(N);\n\trep(i,M){\n\t\tint x,y,w;\n\t\tscanf(\"%d %d %d\",&x,&y,&w);\n\t\tx--,y--;\n\t\tif(w==1){\n\t\t\toG[x].pb(edge{y,1,-1});\n\t\t}else{\n\t\t\tint X=oG[x].size(),Y=oG[y].size();\n\t\t\toG[x].pb(edge{y,1,Y});\n\t\t\toG[y].pb(edge{x,1,X});\n\t\t}\n\t}\n\tint newN=0;\n\trep(i,N){\n\t\tint sz=oG[i].size();\n\t\tif(sz==0) sz=1;\n\t\trs[i]=newN;\n\t\tits[i]=rs[i];\n\t\tnewN+=sz;\n\t}\n\trs[N]=newN;\n\tG.resize(newN);\n\trep(x,N){\n\t\tint n=rs[x+1]-rs[x];\n\t\tfor(int v=rs[x];v<rs[x]+n-1;v++) add_edge(v,v+1,0,2);\n\t\tfor(edge e: oG[x]){\n\t\t\tif(e.rev==-1){\t//one way\n\t\t\t\tadd_edge(its[x],rs[e.to],1,1);\n\t\t\t\tits[x]++;\n\t\t\t}else{\n\t\t\t\tif(x<e.to){\n\t\t\t\t\tadd_edge(its[x],its[e.to],1,2);\n\t\t\t\t\tits[x]++;\n\t\t\t\t\tits[e.to]++;\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t}\n\tint ans=0;\n\tN=newN;\n//\trep(i,N) assert(G[i].size()<=3);\n\trep(i,N) rep(j,4) memo[i][j]=-1;\n\trep(i,N) chmax(ans,dfs(i,-1));\n\tcout<<ans<<endl;\n//\tEND_STACK_EXTEND;\n}"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\n#define rep(i,N) for(int i=0;i<(int)N;i++)\n#define rep1(i,N) for(int i=1;i<=(int)N;i++)\n#define pb push_back\n#define all(c) c.begin(),c.end()\n#define show(x) cout<<#x<<\" \"<<x<<endl\n#define chmax(x,y) x=max(x,y)\n#define BEGIN_STACK_EXTEND(size) void * stack_extend_memory_ = malloc(size);void * stack_extend_origin_memory_;char * stack_extend_dummy_memory_ = (char*)alloca((1+(int)(((long long)stack_extend_memory_)&127))*16);*stack_extend_dummy_memory_ = 0;asm volatile(\"mov %%rsp, %%rbx\\nmov %%rax, %%rsp\":\"=b\"(stack_extend_origin_memory_):\"a\"((char*)stack_extend_memory_+(size)-1024));\n#define END_STACK_EXTEND asm volatile(\"mov %%rax, %%rsp\"::\"a\"(stack_extend_origin_memory_));free(stack_extend_memory_);\nusing namespace std;\nconst int MN=100000;\nstruct edge {int to,w,rev;};\ntypedef vector< vector<edge> > Graph;\nGraph G,oG;\nvoid add_edge(int x,int y,int w,int way){\n\tif(way==1){\n\t\tG[x].pb({y,w,-1});\n\t}else{\n\t\tint X=G[x].size(),Y=G[y].size();\n\t\tG[x].pb({y,w,Y});\n\t\tG[y].pb({x,w,X});\n\t}\n}\n\ntypedef pair<int,int> P;\nint memo[300000][4];\nbool vis[300000][4];\nint dfs(int v,int eid){\n\teid++;\n\tif(memo[v][eid]!=-1) return memo[v][eid];\n\tif(vis[v][eid]){\n\t\tputs(\"Infinite\");\n\t\texit(1);\n\t}\n\tvis[v][eid]=1;\n\tint ret=0;\n\trep(i,G[v].size()) if(i!=eid-1){\n\t\tedge& e=G[v][i];\n\t\tchmax(ret,dfs(e.to,e.rev)+e.w);\n\t}\n\t// if(G[v].size()>0 && eid!=1) chmax(ret,dfs(G[v][0].to,G[v][0].rev)+G[v][0].w);\n\t// if(G[v].size()>1 && eid!=2) chmax(ret,dfs(G[v][1].to,G[v][1].rev)+G[v][1].w);\n\t// if(G[v].size()>2 && eid!=3) chmax(ret,dfs(G[v][2].to,G[v][2].rev)+G[v][2].w);\n\tmemo[v][eid]=ret;\n\treturn ret;\n}\n\nint rs[100001]={};\nint its[100000]={};\n\nint main(){\n\tBEGIN_STACK_EXTEND(128*1024*1024);\n\tint N,M;\n\tcin>>N>>M;\n\toG.resize(N);\n\trep(i,M){\n\t\tint x,y,w;\n\t\tscanf(\"%d %d %d\",&x,&y,&w);\n\t\tx--,y--;\n\t\tif(w==1){\n\t\t\toG[x].pb(edge{y,1,-1});\n\t\t}else{\n\t\t\tint X=oG[x].size(),Y=oG[y].size();\n\t\t\toG[x].pb(edge{y,1,Y});\n\t\t\toG[y].pb(edge{x,1,X});\n\t\t}\n\t}\n\tint newN=0;\n\trep(i,N){\n\t\tint sz=oG[i].size();\n\t\tif(sz==0) sz=1;\n\t\trs[i]=newN;\n\t\tits[i]=rs[i];\n\t\tnewN+=sz;\n\t}\n\trs[N]=newN;\n\tG.resize(newN);\n\trep(x,N){\n\t\tint n=rs[x+1]-rs[x];\n\t\tfor(int v=rs[x];v<rs[x]+n-1;v++) add_edge(v,v+1,0,2);\n\t\tfor(edge e: oG[x]){\n\t\t\tif(e.rev==-1){\t//one way\n\t\t\t\tadd_edge(its[x],rs[e.to],1,1);\n\t\t\t\tits[x]++;\n\t\t\t}else{\n\t\t\t\tif(x<e.to){\n\t\t\t\t\tadd_edge(its[x],its[e.to],1,2);\n\t\t\t\t\tits[x]++;\n\t\t\t\t\tits[e.to]++;\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t}\n\tint ans=0;\n\tN=newN;\n//\trep(i,N) assert(G[i].size()<=3);\n\trep(i,N) rep(j,4) memo[i][j]=-1;\n\trep(i,N) chmax(ans,dfs(i,-1));\n\tcout<<ans<<endl;\n\tEND_STACK_EXTEND;\n}"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\n\nusing namespace std;\n\nconst int INF = 1 << 29;\n\nstruct UnionFind\n{\n  vector< int > data;\n\n  UnionFind(int sz)\n  {\n    data.assign(sz, -1);\n  }\n\n  int find(int k)\n  {\n    return (data[k] < 0 ? k : data[k] = find(data[k]));\n  }\n\n  void unite(int x, int y)\n  {\n    x = find(x);\n    y = find(y);\n    if(x == y) return;\n    if(data[x] > data[y]) swap(x, y);\n    data[x] += data[y];\n    data[y] = x;\n  }\n};\n\nvector< pair< int, int > > g[100001];\nvector< int > leftt[100001], rightt[100001], just[100001];\nvector< int > gg[100001];\nint deg[100001];\n\n\nint rec(int idx, int back = -1)\n{\n  if(back != -1) {\n    int tmp = max(leftt[idx][back], rightt[idx][back + 1]);\n    if(tmp != INF) return (tmp);\n  }\n  if(rightt[idx][0] == INF) {\n    for(int i = 0; i < g[idx].size(); i++) {\n      int to, rev;\n      tie(to, rev) = g[idx][i];\n      if(i == back || just[idx][i] != INF) continue;\n      just[idx][i] = rec(to, rev) + 1;\n    }\n    for(int i = 0; i < g[idx].size(); i++) {\n      leftt[idx][i + 1] = max(leftt[idx][i], just[idx][i]);\n    }\n    for(int i = (int) g[idx].size() - 1; i >= 0; i--) {\n      rightt[idx][i] = max(rightt[idx][i + 1], just[idx][i]);\n    }\n  }\n\n  if(back == -1) return (rightt[idx][0]);\n  return (max(leftt[idx][back], rightt[idx][back + 1]));\n}\n\n\nint main()\n{\n  int N, M;\n  vector< pair< int, int > > edges, arcs;\n\n  scanf(\"%d %d\", &N, &M);\n\n  UnionFind uf(N);\n\n  for(int i = 0; i < M; i++) {\n    int x, y, t;\n    cin >> x >> y >> t;\n    --x, --y;\n    if(t == 1) {\n      arcs.emplace_back(x, y);\n      g[x].emplace_back(y, -1);\n    } else {\n      if(uf.find(x) == uf.find(y)) {\n        cout << \"Infinite\" << endl;\n        return (0);\n      }\n      uf.unite(x, y);\n      edges.emplace_back(x, y);\n      g[y].emplace_back(x, g[x].size());\n      g[x].emplace_back(y, g[y].size() - 1);\n    }\n  }\n\n  {\n    for(auto &e : arcs) {\n      gg[uf.find(e.first)].push_back(uf.find(e.second));\n      ++deg[uf.find(e.second)];\n    }\n    vector< int > order;\n    for(int i = 0; i < N; i++) {\n      if(deg[i] == 0) order.push_back(i);\n    }\n    for(int i : order) {\n      for(auto &e : gg[i]) {\n        if(--deg[e] == 0) order.push_back(e);\n      }\n    }\n    if(order.size() != N) {\n      cout << \"Infinite\" << endl;\n      return (0);\n    }\n  }\n\n\n  int ret = 0;\n  for(int i = 0; i < N; i++) {\n    int sz = g[i].size();\n    just[i].assign(sz, INF);\n    leftt[i].assign(sz + 1, INF);\n    rightt[i].assign(sz + 1, INF);\n    leftt[i][0] = rightt[i][sz] = 0;\n  }\n  for(int i = 0; i < N; i++) ret = max(ret, rec(i));\n  cout << ret << endl;\n}"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\n#define rep(i,N) for(int i=0;i<(int)N;i++)\n#define rep1(i,N) for(int i=1;i<=(int)N;i++)\n#define pb push_back\n#define all(c) c.begin(),c.end()\n#define show(x) cout<<#x<<\" \"<<x<<endl\n#define chmax(x,y) x=max(x,y)\n#define BEGIN_STACK_EXTEND(size) void * stack_extend_memory_ = malloc(size);void * stack_extend_origin_memory_;char * stack_extend_dummy_memory_ = (char*)alloca((1+(int)(((long long)stack_extend_memory_)&127))*16);*stack_extend_dummy_memory_ = 0;asm volatile(\"mov %%rsp, %%rbx\\nmov %%rax, %%rsp\":\"=b\"(stack_extend_origin_memory_):\"a\"((char*)stack_extend_memory_+(size)-1024));\n#define END_STACK_EXTEND asm volatile(\"mov %%rax, %%rsp\"::\"a\"(stack_extend_origin_memory_));free(stack_extend_memory_);\nusing namespace std;\nconst int MN=100000;\nstruct edge {int to,w,rev;};\ntypedef vector< vector<edge> > Graph;\nGraph G,oG;\nvoid add_edge(int x,int y,int w,int way){\n\tif(way==1){\n\t\tG[x].pb({y,w,-1});\n\t}else{\n\t\tint X=G[x].size(),Y=G[y].size();\n\t\tG[x].pb({y,w,Y});\n\t\tG[y].pb({x,w,X});\n\t}\n}\n\ntypedef pair<int,int> P;\nint memo[300000][4];\nbool vis[300000][4];\nint dfs(int v,int eid){\n\teid++;\n\tif(memo[v][eid]!=-1) return memo[v][eid];\n\tif(vis[v][eid]){\n\t\tputs(\"Infinite\");\n\t\texit(1);\n\t}\n\tvis[v][eid]=1;\n\tint ret=0;\n\t// rep(i,G[v].size()) if(i!=eid-1){\n\t// \tedge& e=G[v][i];\n\t// \tchmax(ret,dfs(e.to,e.rev)+e.w);\n\t// }\n\tif(G[v].size()>0 && eid!=1) chmax(ret,dfs(G[v][0].to,G[v][0].rev)+G[v][0].w);\n\tif(G[v].size()>1 && eid!=2) chmax(ret,dfs(G[v][1].to,G[v][1].rev)+G[v][1].w);\n\tif(G[v].size()>2 && eid!=3) chmax(ret,dfs(G[v][2].to,G[v][2].rev)+G[v][2].w);\n\tmemo[v][eid]=ret;\n\treturn ret;\n}\n\nint rs[100001]={};\nint its[100000]={};\n\nint main(){\n//\tBEGIN_STACK_EXTEND(128*1024*1024);\n\tputs(\"Infinite\");\n\treturn 0;\n\tint N,M;\n\tcin>>N>>M;\n\toG.resize(N);\n\trep(i,M){\n\t\tint x,y,w;\n\t\tscanf(\"%d %d %d\",&x,&y,&w);\n\t\tx--,y--;\n\t\tif(w==1){\n\t\t\toG[x].pb(edge{y,1,-1});\n\t\t}else{\n\t\t\tint X=oG[x].size(),Y=oG[y].size();\n\t\t\toG[x].pb(edge{y,1,Y});\n\t\t\toG[y].pb(edge{x,1,X});\n\t\t}\n\t}\n\tint newN=0;\n\trep(i,N){\n\t\tint sz=oG[i].size();\n\t\tif(sz==0) sz=1;\n\t\trs[i]=newN;\n\t\tits[i]=rs[i];\n\t\tnewN+=sz;\n\t}\n\trs[N]=newN;\n\tG.resize(newN);\n\trep(x,N){\n\t\tint n=rs[x+1]-rs[x];\n\t\tfor(int v=rs[x];v<rs[x]+n-1;v++) add_edge(v,v+1,0,2);\n\t\tfor(edge e: oG[x]){\n\t\t\tif(e.rev==-1){\t//one way\n\t\t\t\tadd_edge(its[x],rs[e.to],1,1);\n\t\t\t\tits[x]++;\n\t\t\t}else{\n\t\t\t\tif(x<e.to){\n\t\t\t\t\tadd_edge(its[x],its[e.to],1,2);\n\t\t\t\t\tits[x]++;\n\t\t\t\t\tits[e.to]++;\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t}\n\tint ans=0;\n\tN=newN;\n\trep(i,N) assert(G[i].size()<=3);\n\trep(i,N) rep(j,4) memo[i][j]=-1;\n\trep(i,N) chmax(ans,dfs(i,-1));\n\tcout<<ans<<endl;\n//\tEND_STACK_EXTEND;\n}"
  },
  {
    "language": "C#",
    "code": "using System;\nusing System.Collections.Generic;\nusing System.Linq;\nusing Debug = System.Diagnostics.Debug;\n//using System.Numerics;\n//using static System.Math;\nusing Number = System.Int64;\n\nnamespace Program {\n    public class Solver {\n        //const long MOD = (long)1e9 + 7;\n        public void Solve() {\n            var n = ri;\n            var m = ri;\n            var f = new int[m];\n            var t = new int[m];\n            var w = new int[m];\n            var s = new DisjointSet(n);\n            var g = new SCCGraph(n);\n            var G = Enumerate(n, x => new List<int>());\n            var ok = true;\n            for (int i = 0; i < m; i++) {\n                f[i] = ri - 1; t[i] = ri - 1; w[i] = ri;\n                G[f[i]].Add(t[i]);\n                if (w[i] == 2) {\n                    ok &= s.Unite(f[i], t[i]);\n                    G[t[i]].Add(f[i]);\n                }\n            }\n            for (int i = 0; i < m; i++)\n                if (w[i] == 1) g.AddEdge(s[f[i]], s[t[i]]);\n            g.Build();\n            for (int i = 0; i < g.Count; i++)\n                ok &= g.scc[i].Count == 1;\n            if (!ok) { Console.WriteLine(\"Infinite\"); return; }\n\n            var dp = Enumerate(n, x => -1);\n            Func<int, int, int> dfs = null;\n            Action<int, int, int> efs = null;\n\n            dfs = (prev, cur) => {\n                if (dp[cur] != -1) return dp[cur];\n                var ret = 0;\n                var root = prev == -1 || !s.IsUnited(prev, cur);\n                foreach (var to in G[cur]) {\n                    if (prev == to) continue;\n                    ret = Math.Max(ret, 1 + dfs(cur, to));\n                }\n                if (root) efs(-1, cur, -1000000);\n                return dp[cur] = ret;\n            };\n            efs = (prev, cur, max) => {\n                //Debug.WriteLine($\"efs {prev} {cur} {max}\");\n                var d = G[cur].Count;\n                var dpv = new int[d + 1];\n                var dpR = new int[d + 1];\n                for (int i = 0; i < d; i++)\n                    if (G[cur][i] != prev) dpv[i] = 1 + dp[G[cur][i]];\n                    else dpv[i] = 1 + max;\n                for (int i = d - 1; i >= 0; i--)\n                    dpR[i] = Math.Max(dpR[i + 1], dpv[i]);\n                var vl = 0;\n                for (int i = 0; i < d; i++) {\n                    if (G[cur][i] != prev && s.IsUnited(cur, G[cur][i])) {\n                        efs(cur, G[cur][i], Math.Max(vl, dpR[i + 1]));\n                    }\n                    vl = Math.Max(vl, dpv[i]);\n                }\n                dp[cur] = vl;\n            };\n            var ans = 0;\n            for (int i = 0; i < n; i++) ans = Math.Max(ans, dfs(-1, i));\n            Debug.WriteLine(dp.AsJoinedString());\n            Console.WriteLine(ans);\n        }\n\n        const long INF = 1L << 60;\n        //int[] dx = { 1, 0, -1, 0 };\n        //int[] dy = { 0, 1, 0, -1 };\n        //*\n        int ri { get { return sc.Integer(); } }\n        long rl { get { return sc.Long(); } }\n        double rd { get { return sc.Double(); } }\n        string rs { get { return sc.Scan(); } }\n        //*/\n\n        public IO.StreamScanner sc = new IO.StreamScanner(Console.OpenStandardInput());\n        static T[] Enumerate<T>(int n, Func<int, T> f) { var a = new T[n]; for (int i = 0; i < n; ++i) a[i] = f(i); return a; }\n        static public void Swap<T>(ref T a, ref T b) { var tmp = a; a = b; b = tmp; }\n    }\n}\n\n#region main\nstatic class Ex {\n    static public string AsString(this IEnumerable<char> ie) { return new string(ie.ToArray()); }\n    static public string AsJoinedString<T>(this IEnumerable<T> ie, string st = \" \") {\n        return string.Join(st, ie.Select(x => x.ToString()).ToArray());\n        //return string.Join(st, ie);\n    }\n    static public void Main() {\n        Console.SetOut(new System.IO.StreamWriter(Console.OpenStandardOutput()) { AutoFlush = false });\n        var solver = new Program.Solver();\n        solver.Solve();\n        Console.Out.Flush();\n    }\n}\n#endregion\n#region Ex\nnamespace Program.IO {\n    using System.Globalization;\n    using System.IO;\n    using System.Text;\n    public class Printer: StreamWriter {\n        public override IFormatProvider FormatProvider { get { return CultureInfo.InvariantCulture; } }\n        public Printer(Stream stream) : base(stream, new UTF8Encoding(false, true)) { }\n    }\n    public class StreamScanner {\n        public StreamScanner(Stream stream) { str = stream; }\n        public readonly Stream str;\n        private readonly byte[] buf = new byte[1024];\n        private int len, ptr;\n        public bool isEof = false;\n        public bool IsEndOfStream { get { return isEof; } }\n        private byte read() {\n            if (isEof) return 0;\n            if (ptr >= len) { ptr = 0; if ((len = str.Read(buf, 0, 1024)) <= 0) { isEof = true; return 0; } }\n            return buf[ptr++];\n        }\n        public char Char() { byte b = 0; do b = read(); while ((b < 33 || 126 < b) && !isEof); return (char)b; }\n\n        public string Scan() {\n            var sb = new StringBuilder();\n            for (var b = Char(); b >= 33 && b <= 126; b = (char)read())\n                sb.Append(b);\n            return sb.ToString();\n        }\n        public string ScanLine() {\n            var sb = new StringBuilder();\n            for (var b = Char(); b != '\\n' && b != 0; b = (char)read())\n                if (b != '\\r') sb.Append(b);\n            return sb.ToString();\n        }\n        public long Long() { return isEof ? long.MinValue : long.Parse(Scan()); }\n        public int Integer() { return isEof ? int.MinValue : int.Parse(Scan()); }\n        public double Double() { return isEof ? double.NaN : double.Parse(Scan(), CultureInfo.InvariantCulture); }\n    }\n}\n#endregion\n\n#region DisjointSet\npublic class DisjointSet {\n    int[] par;\n    byte[] rank;\n    public DisjointSet(int n) {\n        par = new int[n];\n        for (int i = 0; i < n; i++)\n            par[i] = -1;\n        rank = new byte[n];\n    }\n    public int this[int id] {\n        get {\n            if ((par[id] < 0)) return id;\n            return par[id] = this[par[id]];\n        }\n    }\n    public bool Unite(int x, int y) {\n        x = this[x]; y = this[y];\n        if (x == y) return false;\n        if (rank[x] < rank[y]) { var z = x; x = y; y = z; }\n        par[x] += par[y];\n        par[y] = x;\n        if (rank[x] == rank[y])\n            rank[x]++;\n        return true;\n    }\n    public int Size(int x) { return -par[this[x]]; }\n    public bool IsUnited(int x, int y) { return this[x] == this[y]; }\n\n}\n#endregion\n\n#region SCCGraph\npublic class SCCGraph {\n    int n;\n\n    List<int>[] g;\n    public List<List<int>> scc;\n    int[] group;\n\n    /// <summary>\n    /// ??????????????????????????\n    /// </summary>\n    public int Count { get; private set; }\n\n    public SCCGraph(int N) {\n        n = N;\n        g = new List<int>[n];\n        scc = new List<List<int>>();\n        for (int i = 0; i < n; i++)\n            g[i] = new List<int>();\n    }\n    public void AddEdge(int f, int t) { g[f].Add(t); }\n    public int this[int id] { get { return group[id]; } }\n    public void Build() {\n        Decomposite();\n        scc.Reverse();\n        group = new int[n];\n        for (int i = 0; i < Count; i++)\n            foreach (var x in scc[i]) group[x] = i;\n\n    }\n    /// <summary>\n    /// ???????????????????????????\n    /// </summary>\n    public int Decomposite() {\n        var S = new Stack<int>(n + 2);\n        var B = new Stack<int>(n + 2);\n        var I = new int[n];\n        var iter = new int[n];\n        var s = new Stack<int>(n + 2);\n        for (int i = 0; i < n; i++) {\n            if (I[i] != 0) continue;\n            s.Push(i);\n            while (s.Count > 0) {\n                DFS:\n                var u = s.Peek();\n                if (I[u] == 0) {\n                    B.Push(I[u] = S.Count);\n                    S.Push(u);\n                    iter[u] = 0;\n                }\n                while (iter[u] < g[u].Count) {\n                    var v = g[u][iter[u]++];\n                    if (I[v] == 0) {\n                        s.Push(v);\n                        goto DFS;\n                    }\n                    else while (I[v] < B.Peek()) B.Pop();\n                }\n                if (I[u] == B.Peek()) {\n                    var ns = new List<int>();\n                    scc.Add(ns);\n                    B.Pop();\n                    while (I[u] < S.Count) {\n                        var p = S.Pop();\n                        ns.Add(p);\n                        I[p] = n + scc.Count;\n                    }\n                }\n                s.Pop();\n\n            }\n        }\n        return Count = scc.Count;\n\n    }\n    public bool IsSameGroup(int u, int v) { return group[u] == group[v]; }\n}\n#endregion\n"
  },
  {
    "language": "Python",
    "code": "from collections import deque\nn, m = map(int, input().split())\nG = [[] for i in range(n)]\nfor i in range(m):\n    x, y, w = map(int, input().split())\n    G[x-1].append((y-1, i))\n    if w == 2:\n        G[y-1].append((x-1, i))\nused = {(i, -1) for i in range(n)}\nprev = {(i, -1): [] for i in range(n)}\ncounter = {}\nque = deque((i, -1) for i in range(n))\nwhile que:\n    v, e = source = que.popleft()\n    counter[source] = 0\n    for target in G[v]:\n        t, f = target\n        if e == f:\n            continue\n        if target not in used:\n            used.add(target)\n            prev[target] = []\n            que.append(target)\n        prev[target].append(source)\n        counter[source] += 1\nrest = len(counter)\nfor p in counter:\n    if counter[p] == 0:\n        que.append(p)\n        rest -= 1\nwhile que:\n    target = que.popleft()\n    for source in prev[target]:\n        counter[source] -= 1\n        if counter[source] == 0:\n            que.append(source)\n            rest -= 1\nif rest > 0:\n    print(\"Infinite\")\n    exit(0)\n\nmemo = {}\ndef dfs(source):\n    if source in memo:\n        return memo[source]\n    res = 0\n    v, e = source\n    for target in G[v]:\n        t, f = target\n        if e == f:\n            continue\n        res = max(res, dfs(target) + 1)\n    memo[source] = res\n    return res\nprint(max(dfs((i, -1)) for i in range(n)))"
  }
]