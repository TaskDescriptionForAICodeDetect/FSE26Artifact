[
  {
    "model": "deepseek-v3",
    "prompt_type": "zero_shot",
    "language": "C",
    "code": "#include <stdio.h>\n#include <stdlib.h>\n#include <string.h>\n\n#define MAX_N 1000\n\ntypedef struct {\n    int adj[MAX_N];\n    int adj_count;\n} Room;\n\nRoom rooms[MAX_N];\nint visited[MAX_N];\nint recursion_stack[MAX_N];\nint infinite_found = 0;\n\nvoid dfs(int room) {\n    if (infinite_found) return;\n    visited[room] = 1;\n    recursion_stack[room] = 1;\n\n    for (int i = 0; i < rooms[room].adj_count; ++i) {\n        int next = rooms[room].adj[i];\n        if (!visited[next]) {\n            dfs(next);\n        } else if (recursion_stack[next]) {\n            infinite_found = 1;\n            return;\n        }\n    }\n\n    recursion_stack[room] = 0;\n}\n\nint main() {\n    int n;\n    scanf(\"%d\", &n);\n\n    for (int i = 0; i < n; ++i) {\n        int k;\n        scanf(\"%d\", &k);\n        rooms[i].adj_count = k;\n        for (int j = 0; j < k; ++j) {\n            scanf(\"%d\", &rooms[i].adj[j]);\n            rooms[i].adj[j]--; // converting to 0-based index\n        }\n    }\n\n    for (int i = 0; i < n; ++i) {\n        memset(visited, 0, sizeof(visited));\n        memset(recursion_stack, 0, sizeof(recursion_stack));\n        dfs(i);\n        if (infinite_found) {\n            printf(\"Infinite\\n\");\n            return 0;\n        }\n    }\n\n    printf(\"Finite\\n\");\n    return 0;\n}",
    "timestamp": "2025-08-05 20:55:59"
  },
  {
    "model": "deepseek-v3",
    "prompt_type": "zero_shot",
    "language": "C++",
    "code": "#include <iostream>\n#include <vector>\n#include <queue>\n#include <algorithm>\n\nusing namespace std;\n\nbool isInfinite(const vector<vector<int>>& adj) {\n    int n = adj.size();\n    vector<int> in_degree(n, 0);\n    for (int u = 0; u < n; ++u) {\n        for (int v : adj[u]) {\n            in_degree[v]++;\n        }\n    }\n\n    queue<int> q;\n    for (int i = 0; i < n; ++i) {\n        if (in_degree[i] == 0) {\n            q.push(i);\n        }\n    }\n\n    int cnt = 0;\n    while (!q.empty()) {\n        int u = q.front();\n        q.pop();\n        cnt++;\n        for (int v : adj[u]) {\n            if (--in_degree[v] == 0) {\n                q.push(v);\n            }\n        }\n    }\n\n    return cnt != n;\n}\n\nint main() {\n    int n, m;\n    cin >> n >> m;\n    vector<vector<int>> adj(n);\n    for (int i = 0; i < m; ++i) {\n        int u, v;\n        cin >> u >> v;\n        u--; v--;\n        adj[u].push_back(v);\n    }\n\n    if (isInfinite(adj)) {\n        cout << \"Infinite\" << endl;\n    } else {\n        vector<int> max_time(n, 1);\n        bool updated;\n        do {\n            updated = false;\n            for (int u = 0; u < n; ++u) {\n                for (int v : adj[u]) {\n                    if (max_time[v] < max_time[u] + 1) {\n                        max_time[v] = max_time[u] + 1;\n                        updated = true;\n                    }\n                }\n            }\n        } while (updated);\n\n        cout << *max_element(max_time.begin(), max_time.end()) << endl;\n    }\n\n    return 0;\n}",
    "timestamp": "2025-08-05 20:56:22"
  },
  {
    "model": "deepseek-v3",
    "prompt_type": "zero_shot",
    "language": "Java",
    "code": "import java.util.*;\n\npublic class MonkeyMaze {\n    public static void main(String[] args) {\n        Scanner scanner = new Scanner(System.in);\n        int N = scanner.nextInt();\n        int M = scanner.nextInt();\n        List<List<Integer>> adj = new ArrayList<>();\n        for (int i = 0; i < N; i++) {\n            adj.add(new ArrayList<>());\n        }\n        for (int i = 0; i < M; i++) {\n            int u = scanner.nextInt();\n            int v = scanner.nextInt();\n            adj.get(u).add(v);\n        }\n\n        boolean infinite = false;\n        for (int start = 0; start < N; start++) {\n            if (hasInfinitePath(start, adj, N)) {\n                infinite = true;\n                break;\n            }\n        }\n        System.out.println(infinite ? \"Infinite\" : \"Finite\");\n    }\n\n    private static boolean hasInfinitePath(int start, List<List<Integer>> adj, int N) {\n        boolean[][] visited = new boolean[N][N];\n        Queue<State> queue = new LinkedList<>();\n        queue.add(new State(start, -1));\n\n        while (!queue.isEmpty()) {\n            State current = queue.poll();\n            int u = current.current;\n            int prev = current.prev;\n\n            for (int v : adj.get(u)) {\n                if (v == prev) continue;\n                if (visited[u][v]) return true;\n                visited[u][v] = true;\n                queue.add(new State(v, u));\n            }\n        }\n        return false;\n    }\n\n    static class State {\n        int current;\n        int prev;\n        State(int current, int prev) {\n            this.current = current;\n            this.prev = prev;\n        }\n    }\n}",
    "timestamp": "2025-08-05 20:56:38"
  },
  {
    "model": "claude-3-5-haiku-20241022",
    "prompt_type": "zero_shot",
    "language": "Java",
    "code": "import java.util.*;\n\npublic class MonkeyEscape {\n    static int n, m;\n    static List<List<Integer>> graph;\n    static boolean[] deadEnd;\n\n    public static String solveMonkeyEscape(int rooms, int connections, int[][] doors) {\n        n = rooms;\n        m = connections;\n        graph = new ArrayList<>(n + 1);\n        for (int i = 0; i <= n; i++) {\n            graph.add(new ArrayList<>());\n        }\n        \n        for (int[] door : doors) {\n            graph.get(door[0]).add(door[1]);\n        }\n        \n        deadEnd = new boolean[n + 1];\n        \n        for (int start = 1; start <= n; start++) {\n            if (!canEscape(start, new boolean[n + 1])) {\n                return \"Infinite\";\n            }\n        }\n        \n        return String.valueOf(calculateMaxSteps());\n    }\n    \n    static boolean canEscape(int room, boolean[] visited) {\n        if (visited[room]) return false;\n        visited[room] = true;\n        \n        for (int nextRoom : graph.get(room)) {\n            if (!visited[nextRoom] && canEscape(nextRoom, visited.clone())) {\n                return true;\n            }\n        }\n        \n        deadEnd[room] = graph.get(room).isEmpty();\n        return !deadEnd[room];\n    }\n    \n    static int calculateMaxSteps() {\n        int maxSteps = 0;\n        for (int room = 1; room <= n; room++) {\n            if (!deadEnd[room]) {\n                maxSteps = Math.max(maxSteps, dfs(room, new boolean[n + 1]));\n            }\n        }\n        return maxSteps;\n    }\n    \n    static int dfs(int room, boolean[] visited) {\n        if (visited[room]) return 0;\n        visited[room] = true;\n        \n        int maxSteps = 1;\n        for (int nextRoom : graph.get(room)) {\n            if (!visited[nextRoom]) {\n                maxSteps = Math.max(maxSteps, 1 + dfs(nextRoom, visited.clone()));\n            }\n        }\n        \n        return maxSteps;\n    }\n}",
    "timestamp": "2025-08-05 20:56:46"
  },
  {
    "model": "claude-3-5-haiku-20241022",
    "prompt_type": "zero_shot",
    "language": "C",
    "code": "#include <stdio.h>\n#include <stdlib.h>\n#include <stdbool.h>\n#include <string.h>\n\n#define MAX_ROOMS 100\n\ntypedef struct {\n    int adjacentRooms[MAX_ROOMS];\n    int numAdjacentRooms;\n} Room;\n\nRoom rooms[MAX_ROOMS];\nint numRooms;\nint initialRoom;\n\ndouble expectedSteps(int currentRoom, bool* visited) {\n    visited[currentRoom] = true;\n    \n    // If room has only one exit back to previous room, it's a trap\n    if (rooms[currentRoom].numAdjacentRooms == 1) {\n        return 1.0;\n    }\n    \n    // Count valid rooms George can move to\n    int validRooms = 0;\n    double totalExpectedSteps = 0.0;\n    \n    for (int i = 0; i < rooms[currentRoom].numAdjacentRooms; i++) {\n        int nextRoom = rooms[currentRoom].adjacentRooms[i];\n        \n        // Skip if already visited\n        if (visited[nextRoom]) continue;\n        \n        validRooms++;\n        \n        // Create a copy of visited rooms\n        bool newVisited[MAX_ROOMS];\n        memcpy(newVisited, visited, sizeof(newVisited));\n        \n        double subSteps = expectedSteps(nextRoom, newVisited);\n        \n        totalExpectedSteps += subSteps;\n    }\n    \n    // If no valid rooms, trap detected\n    if (validRooms == 0) {\n        return 1.0;\n    }\n    \n    // Average steps + 1 for current move\n    return 1.0 + (totalExpectedSteps / validRooms);\n}\n\nint main() {\n    scanf(\"%d %d\", &numRooms, &initialRoom);\n    \n    // Input room connections\n    for (int i = 0; i < numRooms; i++) {\n        int roomId, connections;\n        scanf(\"%d %d\", &roomId, &connections);\n        \n        rooms[roomId].numAdjacentRooms = connections;\n        \n        for (int j = 0; j < connections; j++) {\n            int adjacentRoom;\n            scanf(\"%d\", &adjacentRoom);\n            rooms[roomId].adjacentRooms[j] = adjacentRoom;\n        }\n    }\n    \n    // Check for infinite scenario\n    bool visited[MAX_ROOMS] = {false};\n    double result = expectedSteps(initialRoom, visited);\n    \n    if (result >= 1e9) {\n        printf(\"Infinite\\n\");\n    } else {\n        printf(\"%.2f\\n\", result);\n    }\n    \n    return 0;\n}",
    "timestamp": "2025-08-05 20:56:56"
  },
  {
    "model": "claude-3-5-haiku-20241022",
    "prompt_type": "zero_shot",
    "language": "C++",
    "code": "#include <iostream>\n#include <vector>\n#include <map>\n#include <queue>\n#include <limits>\n\nusing namespace std;\n\nint solve(vector<vector<int>>& graph, int start) {\n    int n = graph.size();\n    vector<int> indegree(n, 0);\n    vector<bool> visited(n, false);\n    queue<int> q;\n\n    for (int i = 0; i < n; i++) {\n        for (int j : graph[i]) {\n            indegree[j]++;\n        }\n    }\n\n    int maxTime = 0;\n    q.push(start);\n    visited[start] = true;\n\n    while (!q.empty()) {\n        int curr = q.front();\n        q.pop();\n\n        int possibleMoves = 0;\n        for (int next : graph[curr]) {\n            if (!visited[next]) {\n                possibleMoves++;\n                indegree[next]--;\n                if (indegree[next] == 0) {\n                    q.push(next);\n                    visited[next] = true;\n                }\n            }\n        }\n\n        if (possibleMoves == 0) {\n            maxTime = max(maxTime, 1);\n        }\n    }\n\n    for (bool v : visited) {\n        if (!v) return -1;\n    }\n\n    return maxTime == 0 ? -1 : maxTime;\n}\n\nint main() {\n    int n, m;\n    cin >> n >> m;\n\n    vector<vector<int>> graph(n);\n    for (int i = 0; i < m; i++) {\n        int u, v;\n        cin >> u >> v;\n        graph[u-1].push_back(v-1);\n    }\n\n    int result = 0;\n    for (int start = 0; start < n; start++) {\n        int time = solve(graph, start);\n        if (time == -1) {\n            cout << \"Infinite\" << endl;\n            return 0;\n        }\n        result = max(result, time);\n    }\n\n    cout << result << endl;\n    return 0;\n}",
    "timestamp": "2025-08-05 20:57:03"
  },
  {
    "model": "gpt-4o",
    "prompt_type": "zero_shot",
    "language": "python",
    "code": "def find_exit_cycles(n, edges):\n    from collections import defaultdict\n    \n    def reverse_graph(n, edges):\n        reverse_edges = defaultdict(list)\n        for u, v in edges:\n            reverse_edges[v].append(u)\n        return reverse_edges\n    \n    def kosaraju_scc(n, edges):\n        reverse_edges = reverse_graph(n, edges)\n        \n        visited = [False] * n\n        finish_stack = []\n\n        def dfs_1(node):\n            visited[node] = True\n            for neighbor in edges[node]:\n                if not visited[neighbor]:\n                    dfs_1(neighbor)\n            finish_stack.append(node)\n\n        for i in range(n):\n            if not visited[i]:\n                dfs_1(i)\n        \n        visited = [False] * n\n        components = []\n\n        def dfs_2(node, component):\n            visited[node] = True\n            component.append(node)\n            for neighbor in reverse_edges[node]:\n                if not visited[neighbor]:\n                    dfs_2(neighbor, component)\n        \n        while finish_stack:\n            node = finish_stack.pop()\n            if not visited[node]:\n                component = []\n                dfs_2(node, component)\n                components.append(component)\n        \n        return components\n    \n    def is_exit(node, edges, non_exit):\n        if node in non_exit:\n            return False\n        stack, visited = [node], set()\n        while stack:\n            current = stack.pop()\n            if current in visited:\n                continue\n            visited.add(current)\n            for neighbor in edges[current]:\n                if neighbor not in visited:\n                    stack.append(neighbor)\n        if len(visited) != n:\n            non_exit.update(visited)\n            return False\n        return True\n\n    edges_list = defaultdict(list)\n    for u, v in edges:\n        edges_list[u].append(v)\n\n    components = kosaraju_scc(n, edges_list)\n    components_set = [set(component) for component in components]\n\n    non_exit = set()\n    infinite = False\n    for component in components_set:\n        if len(component) > 1:\n            if all(is_exit(node, edges_list, non_exit) for node in component):\n                infinite = True\n                break\n\n    return \"Infinite\" if infinite else \"Finite\"\n\n\n# Example usage:\n# Edges are represented as a list of (from, to) pairs.\n# n is the number of rooms (nodes), and edges represent connections.\nprint(find_exit_cycles(4, [(0, 1), (1, 2), (2, 1), (2, 3)]))",
    "timestamp": "2025-08-13 04:11:51"
  },
  {
    "model": "gpt-4o",
    "prompt_type": "zero_shot",
    "language": "java",
    "code": "import java.util.*;\n\npublic class MonkeyInMaze {\n    \n    public static void main(String[] args) {\n        Scanner scanner = new Scanner(System.in);\n        \n        int numberOfRooms = scanner.nextInt();\n        int numberOfDoors = scanner.nextInt();\n        \n        List<List<Integer>> graph = new ArrayList<>();\n        for (int i = 0; i < numberOfRooms; i++) {\n            graph.add(new ArrayList<>());\n        }\n        \n        for (int i = 0; i < numberOfDoors; i++) {\n            int from = scanner.nextInt();\n            int to = scanner.nextInt();\n            graph.get(from).add(to);\n        }\n        \n        boolean infinite = false;\n        for (int start = 0; start < numberOfRooms; start++) {\n            if (detectInfiniteLoop(graph, start, numberOfRooms)) {\n                infinite = true;\n                break;\n            }\n        }\n        \n        System.out.println(infinite ? \"Infinite\" : \"Finite\");\n    }\n    \n    private static boolean detectInfiniteLoop(List<List<Integer>> graph, int start, int numberOfRooms) {\n        boolean[] visited = new boolean[numberOfRooms];\n        boolean[] stackPath = new boolean[numberOfRooms];\n        \n        return dfsCycleDetection(graph, start, visited, stackPath);\n    }\n    \n    private static boolean dfsCycleDetection(List<List<Integer>> graph, int node, boolean[] visited, boolean[] stackPath) {\n        if (stackPath[node]) {\n            return true;\n        }\n        \n        if (visited[node]) {\n            return false;\n        }\n        \n        visited[node] = true;\n        stackPath[node] = true;\n        \n        for (int neighbour : graph.get(node)) {\n            if (dfsCycleDetection(graph, neighbour, visited, stackPath)) {\n                return true;\n            }\n        }\n        \n        stackPath[node] = false;\n        return false;\n    }\n}",
    "timestamp": "2025-08-13 04:11:57"
  },
  {
    "model": "gpt-4o",
    "prompt_type": "zero_shot",
    "language": "c",
    "code": "#include <stdio.h>\n#include <stdlib.h>\n\n#define MAX_N 100\n\nint visited[MAX_N];\nint inStack[MAX_N];\nint adj[MAX_N][MAX_N];\nint n;\n\nint dfs(int v) {\n    visited[v] = 1;\n    inStack[v] = 1;\n\n    for (int u = 0; u < n; u++) {\n        if (adj[v][u]) { // If there's a door from v to u\n            if (!visited[u] && dfs(u))\n                return 1;\n            else if (inStack[u])\n                return 1;\n        }\n    }\n\n    inStack[v] = 0;\n    return 0;\n}\n\nint canEscapeInfinite() {\n    for (int i = 0; i < n; i++) {\n        if (!visited[i] && dfs(i))\n            return 1;\n    }\n    return 0;\n}\n\nint main() {\n    scanf(\"%d\", &n);\n    for (int i = 0; i < n; i++)\n        for (int j = 0; j < n; j++)\n            scanf(\"%d\", &adj[i][j]);\n\n    if (canEscapeInfinite())\n        printf(\"Infinite\\n\");\n    else\n        printf(\"Finite\\n\");\n\n    return 0;\n}",
    "timestamp": "2025-08-13 04:12:04"
  },
  {
    "model": "claude-3-5-haiku-20241022",
    "prompt_type": "zero_shot",
    "language": "python",
    "code": "def solve_monkey_maze(maze):\n    def dfs(node, visited):\n        if node in visited:\n            return False\n        visited.add(node)\n        \n        for neighbor in maze[node]:\n            if neighbor not in visited:\n                if not dfs(neighbor, visited.copy()):\n                    return False\n        \n        return True\n\n    for start_room in range(len(maze)):\n        visited = set()\n        if not dfs(start_room, visited):\n            return 'Infinite'\n    \n    max_steps = 0\n    for start_room in range(len(maze)):\n        steps = bfs(start_room, maze)\n        max_steps = max(max_steps, steps)\n    \n    return max_steps\n\ndef bfs(start, maze):\n    queue = [(start, 0)]\n    visited = set([start])\n    max_steps = 0\n    \n    while queue:\n        current, steps = queue.pop(0)\n        max_steps = max(max_steps, steps)\n        \n        for neighbor in maze[current]:\n            if neighbor not in visited:\n                visited.add(neighbor)\n                queue.append((neighbor, steps + 1))\n    \n    return max_steps",
    "timestamp": "2025-08-13 04:12:14"
  },
  {
    "model": "deepseek-v3",
    "prompt_type": "zero_shot",
    "language": "python",
    "code": "import sys\nfrom collections import defaultdict, deque\n\ndef solve():\n    n = int(sys.stdin.readline())\n    adj = [[] for _ in range(n)]\n    reverse_adj = [[] for _ in range(n)]\n    for i in range(n):\n        parts = list(map(int, sys.stdin.readline().split()))\n        k = parts[0]\n        for j in range(1, k + 1):\n            neighbor = parts[j] - 1  # converting to 0-based\n            adj[i].append(neighbor)\n            reverse_adj[neighbor].append(i)\n    \n    # Check for infinite loops: any node in a cycle that has out-degree >= 2\n    # We can use Kosaraju's algorithm to find SCCs\n    visited = [False] * n\n    order = []\n    \n    def dfs(u):\n        stack = [(u, False)]\n        while stack:\n            node, processed = stack.pop()\n            if processed:\n                order.append(node)\n                continue\n            if visited[node]:\n                continue\n            visited[node] = True\n            stack.append((node, True))\n            for v in adj[node]:\n                if not visited[v]:\n                    stack.append((v, False))\n    \n    for i in range(n):\n        if not visited[i]:\n            dfs(i)\n    \n    visited = [False] * n\n    scc_id = [0] * n\n    current_id = 0\n    \n    for node in reversed(order):\n        if not visited[node]:\n            stack = [node]\n            visited[node] = True\n            component = []\n            while stack:\n                u = stack.pop()\n                component.append(u)\n                for v in reverse_adj[u]:\n                    if not visited[v]:\n                        visited[v] = True\n                        stack.append(v)\n            for u in component:\n                scc_id[u] = current_id\n            current_id += 1\n    \n    scc_count = current_id\n    scc_adj = [[] for _ in range(scc_count)]\n    scc_out_degree = [0] * scc_count\n    scc_size = [0] * scc_count\n    \n    for u in range(n):\n        scc_u = scc_id[u]\n        scc_size[scc_u] += 1\n        for v in adj[u]:\n            scc_v = scc_id[v]\n            if scc_u != scc_v:\n                scc_adj[scc_u].append(scc_v)\n    \n    for u in range(scc_count):\n        unique_v = set(scc_adj[u])\n        scc_out_degree[u] = len(unique_v)\n    \n    # Check if any SCC with size >= 2 has out_degree >= 1 (since it's a cycle)\n    infinite = False\n    for u in range(scc_count):\n        if scc_size[u] >= 2 and scc_out_degree[u] >= 1:\n            infinite = True\n            break\n        if scc_size[u] == 1:\n            original_node = -1\n            for i in range(n):\n                if scc_id[i] == u:\n                    original_node = i\n                    break\n            if len(adj[original_node]) >= 2:\n                infinite = True\n                break\n    \n    if infinite:\n        print(\"Infinite\")\n        return\n    \n    # Now compute the longest path in the DAG of SCCs\n    # We need to process SCCs in topological order\n    # Build the DAG's adjacency list and in-degree\n    in_degree = [0] * scc_count\n    dag_adj = [[] for _ in range(scc_count)]\n    for u in range(n):\n        scc_u = scc_id[u]\n        for v in adj[u]:\n            scc_v = scc_id[v]\n            if scc_u != scc_v:\n                dag_adj[scc_u].append(scc_v)\n    \n    # Remove duplicates\n    for u in range(scc_count):\n        dag_adj[u] = list(set(dag_adj[u]))\n    \n    in_degree = [0] * scc_count\n    for u in range(scc_count):\n        for v in dag_adj[u]:\n            in_degree[v] += 1\n    \n    # Topological sort\n    q = deque()\n    for u in range(scc_count):\n        if in_degree[u] == 0:\n            q.append(u)\n    \n    topo_order = []\n    while q:\n        u = q.popleft()\n        topo_order.append(u)\n        for v in dag_adj[u]:\n            in_degree[v] -= 1\n            if in_degree[v] == 0:\n                q.append(v)\n    \n    # Compute longest path\n    dp = [0] * scc_count\n    for u in topo_order:\n        for v in dag_adj[u]:\n            if dp[v] < dp[u] + scc_size[u]:\n                dp[v] = dp[u] + scc_size[u]\n    \n    max_length = max(dp) + (1 if scc_count > 0 else 0)\n    print(max_length)\n\nsolve()",
    "timestamp": "2025-08-13 04:12:41"
  },
  {
    "model": "gpt-4o",
    "prompt_type": "zero_shot",
    "language": "c++",
    "code": "#include <iostream>\n#include <vector>\n#include <queue>\nusing namespace std;\n\nvector<vector<int>> graph;\nvector<int> outdegree;\nvector<bool> visited;\nvector<bool> visitedTranspose;\nvector<vector<int>> reverseGraph;\nqueue<int> q;\n\nvoid dfsReverseGraph(int node) {\n    visitedTranspose[node] = true;\n    for (int nei : reverseGraph[node]) {\n        if (!visitedTranspose[nei]) {\n            dfsReverseGraph(nei);\n        }\n    }\n}\n\nbool isInStronglyConnectedComponent(int n) {\n    visitedTranspose.assign(n, false);\n    // Reversed DFS from exit point nodes\n    for(int i = 0; i < n; ++i) {\n        if (outdegree[i] == 0) {\n            dfsReverseGraph(i);\n        }\n    }\n    for (int i = 0; i < n; ++i) {\n        if (!visitedTranspose[i] && outdegree[i] > 0) {\n            return true;\n        }\n    }\n    return false;\n}\n\nstring findEscapeTime(int n) {\n    outdegree.assign(n, 0);\n    reverseGraph.assign(n, vector<int>());\n    // Calculate outdegrees and build reverse graph\n    for (int i = 0; i < n; ++i) {\n        for (int j : graph[i]) {\n            reverseGraph[j].push_back(i);\n            outdegree[i]++;\n        }\n    }\n    \n    // Initialize queue with rooms with zero outdegree\n    for (int i = 0; i < n; ++i) {\n        if (outdegree[i] == 0) {\n            q.push(i);\n        }\n    }\n    \n    // Topological sorting using Kahn's algorithm\n    while (!q.empty()) {\n        int node = q.front();\n        q.pop();\n        for (int nei : reverseGraph[node]) {\n            outdegree[nei]--;\n            if (outdegree[nei] == 0) {\n                q.push(nei);\n            }\n        }\n    }\n    \n    // Check for any node part of a cycle (SCC with more than one node)\n    return isInStronglyConnectedComponent(n) ? \"Infinite\" : \"Finite\";\n}\n\nint main() {\n    int n, m;\n    cin >> n >> m;\n    graph.assign(n, vector<int>());\n\n    for (int i = 0; i < m; ++i) {\n        int u, v;\n        cin >> u >> v;\n        graph[u].push_back(v);\n    }\n    \n    cout << findEscapeTime(n) << endl;\n    return 0;\n}",
    "timestamp": "2025-08-13 11:17:47"
  }
]