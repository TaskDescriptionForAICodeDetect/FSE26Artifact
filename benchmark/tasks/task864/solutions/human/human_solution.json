[
  {
    "language": "C++",
    "code": "#include <cstdio>\n#include <cstring>\n#include <cstdlib>\n#include <cmath>\n#include <ctime>\n#include <cassert>\n#include <string>\n#include <algorithm>\n#include <vector>\n#include <queue>\n#include <stack>\n#include <functional>\n#include <iostream>\n#include <map>\n#include <set>\n#include <cassert>\nusing namespace std;\ntypedef long long ll;\ntypedef pair<int,int> P;\ntypedef pair<int,P> P1;\ntypedef pair<P,P> P2;\n#define pu push\n#define pb push_back\n#define mp make_pair\n#define eps 1e-7\n#define INF 1000000000\n#define mod 1000000007\n#define fi first\n#define sc second\n#define rep(i,x) for(int i=0;i<x;i++)\n#define repn(i,x) for(int i=1;i<=x;i++)\n#define SORT(x) sort(x.begin(),x.end())\n#define ERASE(x) x.erase(unique(x.begin(),x.end()),x.end())\n#define POSL(x,v) (lower_bound(x.begin(),x.end(),v)-x.begin())\n#define POSU(x,v) (upper_bound(x.begin(),x.end(),v)-x.begin())\nvector<int>zx,zy;\nint h,w,n,a[35],b[35];\nvector<P1>za,zb;\nvector<int>cx,cy;\nint revx[1000005],revy[1000005];\nbool bad[105][105];\nint main(){\n\tcin>>h>>w>>n;\n\trep(i,n){\n\t\tcin>>a[i]>>b[i]; a[i]++; b[i]++;\n\t\tzx.pb(a[i]);\n\t\tzy.pb(b[i]);\n\t}\n\tSORT(zx); ERASE(zx);\n\tSORT(zy); ERASE(zy);\n\tint cur = 1;\n\trep(i,zx.size()){\n\t\tif(cur != zx[i]){\n\t\t\tza.pb(mp(0,mp(cur,zx[i]-1)));\n\t\t}\n\t\tza.pb(mp(1,mp(zx[i],zx[i])));\n\t\tcur = zx[i]+1;\n\t}\n\tif(cur <= h){\n\t\tza.pb(mp(0,mp(cur,h)));\n\t}\n\t\n\tcur = 1;\n\trep(i,zy.size()){\n\t\tif(cur != zy[i]){\n\t\t\tzb.pb(mp(0,mp(cur,zy[i]-1)));\n\t\t}\n\t\tzb.pb(mp(1,mp(zy[i],zy[i])));\n\t\tcur = zy[i]+1;\n\t}\n\tif(cur <= w){\n\t\tzb.pb(mp(0,mp(cur,w)));\n\t}\n\trep(i,za.size()){\n\t\trep(j,zb.size()){\n\t\t\tcx.pb(za[i].sc.fi); cx.pb(za[i].sc.sc);\n\t\t\tcy.pb(zb[j].sc.fi); cy.pb(zb[j].sc.sc);\n\t\t}\n\t}\n\tSORT(cx); ERASE(cx);\n\tSORT(cy); ERASE(cy);\n\trep(i,cx.size()) revx[cx[i]] = i+1;\n\trep(i,cy.size()) revy[cy[i]] = i+1;\n\trep(i,cx.size()){\n        rep(j,cy.size()){\n            rep(k,n) if(a[k]==cx[i]&&b[k]==cy[j]) bad[i+1][j+1] = 1;\n        }\n\t}\n\tll add = 0; ll sum = 0;\n\trep(i,za.size()){\n\t\trep(j,zb.size()){\n\t\t\tint x = za[i].sc.fi,y = zb[j].sc.fi;\n\t\t\tx = revx[x]; y = revy[y];\n\t\t\tif(bad[x][y]) continue;\n\t\t\tll cnt = 1LL*(za[i].sc.sc-za[i].sc.fi+1)*(zb[j].sc.sc-zb[j].sc.fi+1);\n\t\t\tcnt %= mod;\n\t\t\tint dist[95][95];\n\t\t\trep(x,95) rep(y,95) dist[x][y] = INF;\n\t\t\tdist[x][y] = 0;\n\t\t\tpriority_queue<P1>que;\n\t\t\tque.push(mp(0,mp(x,y)));\n\t\t\twhile(!que.empty()){\n\t\t\t\tP1 p = que.top(); que.pop();\n\t\t\t\tif(dist[p.sc.fi][p.sc.sc] != p.fi) continue;\n\t\t\t\tint X = p.sc.fi,Y = p.sc.sc;\n\t\t\t\tint dx[4]={0,1,0,-1};\n\t\t\t\tint dy[4]={1,0,-1,0};\n\t\t\t\trep(k,4){\n\t\t\t\t\tint nx = X+dx[k];\n\t\t\t\t\tint ny = Y+dy[k];\n\t\t\t\t\tif(1<=nx&&nx<=cx.size()&&1<=ny&&ny<=cy.size()&&!bad[nx][ny]){\n\t\t\t\t\t\tint dt;\n\t\t\t\t\t\tif(k%2 == 0) dt = cy[max(Y,ny)-1]-cy[min(Y,ny)-1];\n\t\t\t\t\t\telse dt = cx[max(X,nx)-1]-cx[min(X,nx)-1];\n\t\t\t\t\t\tif(dist[nx][ny] > dist[X][Y]+dt){\n\t\t\t\t\t\t\tdist[nx][ny] = dist[X][Y]+dt;\n\t\t\t\t\t\t\tque.push(mp(dist[nx][ny],mp(nx,ny)));\n\t\t\t\t\t\t}\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t}\n\t\t\trep(ii,za.size()){\n\t\t\t\trep(jj,zb.size()){\n\t\t\t\t\tint xx = za[ii].sc.fi,yy = zb[jj].sc.fi;\n\t\t\t\t\txx = revx[xx]; yy = revy[yy];\n\t\t\t\t\tll cntt = 1LL*(za[ii].sc.sc-za[ii].sc.fi+1)*(zb[jj].sc.sc-zb[jj].sc.fi+1);\n\t\t\t\t\tcntt %= mod;\n\t\t\t\t\tint dif = dist[xx][yy];\n\t\t\t\t\t//cout << x << y << xx << yy << dif << endl;\n\t\t\t\t\tif(dif == INF) continue;\n\t\t\t\t\tsum+=dif;\n\t\t\t\t\tdif -= cx[max(xx,x)-1]-cx[min(xx,x)-1]+cy[max(yy,y)-1]-cy[min(yy,y)-1];\n\t\t\t\t\tassert(dif >= 0);\n\t\t\t\t\tadd += (dif * (cnt * cntt % mod) % mod);\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t}\n\tadd %= mod;\n\tadd = add*(mod+1)/2%mod;\n\t//cout << add << endl;\n\tll ret = 0;\n\tfor(int i=1;i<w;i++){\n\t\tret += 1LL*h*h%mod*i%mod*(w-i)%mod;\n\t\tret %= mod;\n\t}\n\tfor(int i=1;i<h;i++){\n\t\tret += 1LL*w*w%mod*i%mod*(h-i)%mod;\n\t\tret %= mod;\n\t}\n\tfor(int i=0;i<n;i++){\n\t\tret -= 1LL*(a[i]-1)*a[i]%mod*((mod+1)/2)%mod*w%mod;\n\t\tret -= 1LL*(h-a[i])*(h-a[i]+1)%mod*((mod+1)/2)%mod*w%mod;\n\t\tret -= 1LL*(b[i]-1)*b[i]%mod*((mod+1)/2)%mod*h%mod;\n\t\tret -= 1LL*(w-b[i])*(w-b[i]+1)%mod*((mod+1)/2)%mod*h%mod;\n\t\tret %= mod;\n\t}\n\tfor(int i=0;i<n;i++){\n\t\tfor(int j=i+1;j<n;j++){\n\t\t\tret += abs(a[i]-a[j])+abs(b[i]-b[j]);\n\t\t\tret %= mod;\n\t\t}\n\t}\n\tret = (ret%mod+mod)%mod;\n\t//cout << ret << \" \" << add << endl;\n\tcout << (ret+add)%mod << endl;\n}"
  },
  {
    "language": "C++",
    "code": "#include<algorithm> \n#include<iostream>\n#include<cstring>\n#include<cstdio>\n#define MN 61\n#define mod 1000000007\nusing namespace std;\ninline int read()\n{\n\tint x=0,f=1;char ch=getchar();\n\twhile(ch<'0'||ch>'9'){if(ch=='-')f=-1;ch=getchar();}\n\twhile(ch>='0'&&ch<='9'){x=x*10+ch-'0';ch=getchar();}\n\treturn x*f;\n}\npair<int,int> q[MN*MN*2+5];\nint h,w,n,Lx[MN+5],num1,Ly[MN+5],x[MN+5],y[MN+5],num2,ans;\nint vis[MN+5][MN+5],b[MN+5][MN+5],d[MN+5][MN+5],W[4],top;\nconst int dis[4][2]={{-1,0},{1,0},{0,-1},{0,1}};\nvoid Update(int x,int y)\n{\n\tif(vis[x][y]) return;vis[x][y]=1;\n\tfor(int k=0;k<4;++k)\n\t{\n\t\tint nx=x+dis[k][0],ny=y+dis[k][1];\n\t\tif(nx<1||ny<1||nx>num1||ny>num2||b[nx][ny]) continue;\n\t\tif(d[x][y]+W[k]<d[nx][ny])\n\t\t{\n\t\t\td[nx][ny]=d[x][y]+W[k];\n\t\t\tif(!W[k]) Update(nx,ny);\n\t\t\telse q[++top]=make_pair(nx,ny);\n\t\t}\n\t}\t\n}\nvoid Bfs(int x,int y)\n{\n\tmemset(vis,0,sizeof(vis));\n\tmemset(d,63,sizeof(d));d[x][y]=0;q[top=MN*MN]=make_pair(x,y);\n\tfor(int i=MN*MN;i<=top;++i)\n\t{\n\t\tint x=q[i].first,y=q[i].second;\n\t\tUpdate(x,y);\n\t}\n}\ninline int S(int x,int y){return 1LL*(Lx[x]-Lx[x-1])*(Ly[y]-Ly[y-1])%mod;}\nint main()\n{\n\th=read();w=read();n=read();\n\tLx[num1=1]=h;Ly[num2=1]=w;\n\tfor(int i=1;i<=n;++i)\n\t{\n\t\tx[i]=read()+1,y[i]=read()+1;\n\t\tLx[++num1]=x[i];if(x[i]>1) Lx[++num1]=x[i]-1;\n\t\tLy[++num2]=y[i];if(y[i]>1) Ly[++num2]=y[i]-1;\n\t}\n\tsort(Lx+1,Lx+num1+1);num1=unique(Lx+1,Lx+num1+1)-Lx-1;\n\tsort(Ly+1,Ly+num2+1);num2=unique(Ly+1,Ly+num2+1)-Ly-1;\n\tfor(int i=1;i<=n;++i)\n\t\tb[lower_bound(Lx+1,Lx+num1+1,x[i])-Lx]\n\t\t [lower_bound(Ly+1,Ly+num2+1,y[i])-Ly]=1;\n\tfor(int i=1;i<h;++i)\n\t{\n\t\tint a=1LL*w*i%mod,b=1LL*w*(h-i)%mod;\n\t\tfor(int j=1;j<=n;++j) \n\t\t\tif(x[j]<=i) --a<0?a+=mod:0;\n\t\t\telse --b<0?b+=mod:0;\n\t\tans=(ans+1LL*a*b)%mod;\n\t}\n\tfor(int i=1;i<w;++i)\n\t{\n\t\tint a=1LL*h*i%mod,b=1LL*h*(w-i)%mod;\n\t\tfor(int j=1;j<=n;++j) \n\t\t\tif(y[j]<=i) --a<0?a+=mod:0;\n\t\t\telse --b<0?b+=mod:0;\n\t\tans=(ans+1LL*a*b)%mod;\n\t}\n\tfor(int i=1;i<=num1;++i) for(int j=1;j<=num2;++j) if(!b[i][j])\n\t{\n\t\tW[0]=0;W[1]=1;W[2]=1;W[3]=0;Bfs(i,j);\n\t\tfor(int x=1;x<i;++x) for(int y=j;y<=num2;++y) if(!b[x][y])\n\t\t\tans=(ans+1LL*d[x][y]*S(i,j)%mod*S(x,y))%mod;\n\t\tW[0]=1;W[1]=0;W[2]=1;W[3]=0;Bfs(i,j);\n\t\tfor(int x=i;x<=num1;++x) for(int y=j+1;y<=num2;++y) if(!b[x][y])\n\t\t\tans=(ans+1LL*d[x][y]*S(i,j)%mod*S(x,y))%mod;\t\n\t\tW[0]=1;W[1]=0;W[2]=0;W[3]=1;Bfs(i,j);\n\t\tfor(int x=i+1;x<=num1;++x) for(int y=1;y<=j;++y) if(!b[x][y])\n\t\t\tans=(ans+1LL*d[x][y]*S(i,j)%mod*S(x,y))%mod;\n\t\tW[0]=0;W[1]=1;W[2]=0;W[3]=1;Bfs(i,j);\n\t\tfor(int x=1;x<=i;++x) for(int y=1;y<j;++y) if(!b[x][y])\n\t\t\tans=(ans+1LL*d[x][y]*S(i,j)%mod*S(x,y))%mod;\n\t}\n\tcout<<ans;\n\treturn 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\nusing namespace std;\n#define int long long\n#define p (int)(1e9 + 7)\n\nint MOD(int a){\n\treturn a % p;\n}\n\nint h, w;\nconst int inv2 = 500000004, inv6 = 166666668;\n\nint calc(int dis, int x1, int dx1, int x2, int dx2, int y1, int dy1, int y2, int dy2){\n\tif(x2 < x1){\n\t\treturn calc(dis, x2, dx2, x1, dx1, y2, dy2, y1, dy1);\n\t}\n\telse if(y2 < y1){\n\t\treturn calc(dis + dx2 - dx1, x1, dx2, x2 + dx2 - dx1, dx1, y2, dy2, y1, dy1);\n\t}\n\telse if(x1 == x2){\n\t\treturn calc(dis, y1, dy1, y2, dy2, x1, dx1, x2, dx2);\n\t}\n\tif(y1 == y2){\n\t\tif(dy1 == 1){\n\t\t\treturn MOD(inv2 * MOD(MOD(dx1 * dx2) * (2 * dis + (dx2 - dx1))));\n\t\t}\n\t\telse{\n\t\t\treturn MOD(inv6 * MOD(MOD(dx1 * dx2 * dy1) * MOD(3 * dy1 * (2 * (x2 - x1) + (dx2 - dx1)) + (2 * (dy1 - 1) * (dy1 + 1)))));\n\t\t}\n\t}\n\telse{\n\t\treturn MOD(inv2 * MOD(MOD(MOD(dx1 * dx2) * MOD(dy1 * dy2)) * (2 * dis + (dx2 - dx1) + (dy2 - dy1))));\n\t}\n}\n\nsigned main(){\n\tint H, W, N, i, j, k, l;\n\tscanf(\"%lld%lld\", &H, &W);\n\tscanf(\"%lld\", &N);\n\tvector<int> x_sub(N), y_sub(N), x(0), y(0);\n\tfor(i = 0; i < N; i++){\n\t\tscanf(\"%lld%lld\", &x_sub[i], &y_sub[i]);\n\t\tx.push_back(x_sub[i]);\n\t\tx.push_back(x_sub[i] + 1);\n\t\tx.push_back(max(0ll, x_sub[i] - 1));\n\t\ty.push_back(y_sub[i]);\n\t\ty.push_back(y_sub[i] + 1);\n\t\ty.push_back(max(0ll, y_sub[i] - 1));\n\t}\n\tx.push_back(0);\n\tx.push_back(H);\n\ty.push_back(0);\n\ty.push_back(W);\n\tsort(x.begin(), x.end());\n\tsort(y.begin(), y.end());\n\tfor(i = 1, j = 1; j < x.size(); j++){\n\t\tif(x[j - 1] < x[j]){\n\t\t\tx[i] = x[j];\n\t\t\ti++;\n\t\t}\n\t}\n\th = i - 1;\n\tfor(i = 1, j = 1; j < y.size(); j++){\n\t\tif(y[j - 1] < y[j]){\n\t\t\ty[i] = y[j];\n\t\t\ti++;\n\t\t}\n\t}\n\tw = i - 1;\n\tvector<int> dx(h), dy(w);\n\tfor(i = 0; i < h; i++){\n\t\tdx[i] = x[i + 1] - x[i];\n\t}\n\tfor(i = 0; i < w; i++){\n\t\tdy[i] = y[i + 1] - y[i];\n\t}\n\tvector<vector<char>> A(h, vector<char>(w, '.'));\n\tfor(i = 0; i < h; i++){\n\t\tfor(j = 0; j < w; j++){\n\t\t\tfor(k = 0; k < N; k++){\n\t\t\t\tif(x[i] == x_sub[k] && y[j] == y_sub[k]){\n\t\t\t\t\tA[i][j] = '#';\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t}\n\tvector<vector<int>> dis(h, vector<int>(w, 1000000000));\n\tint ans = 0;\n\tfor(i = 0; i < h; i++){\n\t\tfor(j = (i % 2) * (w - 1); 0 <= j && j < w; j = j + 1 - 2 * (i % 2)){\n\t\t\tif(A[i][j] == '#'){\n\t\t\t\tcontinue;\n\t\t\t}\n\t\t\tint sub = MOD(inv6 * MOD(MOD(dx[i] * dy[j]) * MOD((dx[i] + dy[j]) * MOD(dx[i] * dy[j] - 1))));\n\t\t\tans = MOD(ans + sub);\n\t\t\tint old_dis = dis[i][j];\n\t\t\tfor(k = 0; k < h; k++){\n\t\t\t\tfor(l = 0; l < w; l++){\n\t\t\t\t\tdis[k][l] += old_dis;\n\t\t\t\t}\n\t\t\t}\n\t\t\tqueue<pair<pair<int, int>, int>> q;\n\t\t\tq.push(pair<pair<int, int>, int>(pair<int, int>(i, j), 0));\n\t\t\twhile(q.size() > 0){\n\t\t\t\tk = q.front().first.first;\n\t\t\t\tl = q.front().first.second;\n\t\t\t\tint d = q.front().second;\n\t\t\t\tq.pop();\n\t\t\t\tif(A[k][l] == '#' || dis[k][l] <= d){\n\t\t\t\t\tcontinue;\n\t\t\t\t}\n\t\t\t\tdis[k][l] = d;\n\t\t\t\tif(l < w - 1){\n\t\t\t\t\tq.push(pair<pair<int, int>, int>(pair<int, int>(k + 0, l + 1), d + dy[l]));\n\t\t\t\t}\n\t\t\t\tif(k < h - 1){\n\t\t\t\t\tq.push(pair<pair<int, int>, int>(pair<int, int>(k + 1, l + 0), d + dx[k]));\n\t\t\t\t}\n\t\t\t\tif(l > 0){\n\t\t\t\t\tq.push(pair<pair<int, int>, int>(pair<int, int>(k + 0, l - 1), d + dy[l - 1]));\n\t\t\t\t}\n\t\t\t\tif(k > 0){\n\t\t\t\t\tq.push(pair<pair<int, int>, int>(pair<int, int>(k - 1, l + 0), d + dx[k - 1]));\n\t\t\t\t}\n\t\t\t}\n\t\t\tfor(k = 0; k < h; k++){\n\t\t\t\tfor(l = 0; l < w; l++){\n\t\t\t\t\tif(k < i || (i == k && l <= j) || A[k][l] == '#'){\n\t\t\t\t\t\tcontinue;\n\t\t\t\t\t}\n\t\t\t\t\tint res = calc(dis[k][l], x[i], dx[i], x[k], dx[k], y[j], dy[j], y[l], dy[l]);\n\t\t\t\t\tans = MOD(ans + res);\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t}\n\tprintf(\"%lld\\n\", MOD(ans + p));\n\treturn 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\nusing namespace std;\n#define int long long\n#define p (int)(1e9 + 7)\n\nint MOD(int a){\n\treturn a % p;\n}\n\nint h, w;\nconst int inv2 = 500000004, inv6 = 166666668;\n\nint calc(int dis, int x1, int dx1, int x2, int dx2, int y1, int dy1, int y2, int dy2){\n\tif(x2 < x1){\n\t\treturn calc(dis, x2, dx2, x1, dx1, y2, dy2, y1, dy1);\n\t}\n\telse if(y2 < y1){\n\t\treturn calc(dis + dx2 - dx1, x1, dx2, x2 + dx2 - dx1, dx1, y2, dy2, y1, dy1);\n\t}\n\telse if(x1 == x2){\n\t\treturn calc(dis, y1, dy1, y2, dy2, x1, dx1, x2, dx2);\n\t}\n\tif(y1 == y2){\n\t\tif(dy1 == 1){\n\t\t\treturn MOD(inv2 * MOD(MOD(dx1 * dx2) * (2 * dis + (dx2 - dx1))));\n\t\t}\n\t\telse{\n\t\t\treturn MOD(inv6 * MOD(MOD(dx1 * dx2 * dy1) * MOD(3 * dy1 * (2 * (x2 - x1) + (dx2 - dx1)) + (2 * (dy1 - 1) * (dy1 + 1)))));\n\t\t}\n\t}\n\telse{\n\t\treturn MOD(inv2 * MOD(MOD(MOD(dx1 * dx2) * MOD(dy1 * dy2)) * (2 * dis + (dx2 - dx1) + (dy2 - dy1))));\n\t}\n}\n\nsigned main(){\n\tint H, W, N, i, j, k, l;\n\tscanf(\"%lld%lld\", &H, &W);\n\tscanf(\"%lld\", &N);\n\tvector<int> x_sub(N), y_sub(N), x(0), y(0);\n\tfor(i = 0; i < N; i++){\n\t\tscanf(\"%lld%lld\", &x_sub[i], &y_sub[i]);\n\t\tx.push_back(x_sub[i]);\n\t\tx.push_back(x_sub[i] + 1);\n\t\tx.push_back(max(0ll, x_sub[i] - 1));\n\t\ty.push_back(y_sub[i]);\n\t\ty.push_back(y_sub[i] + 1);\n\t\ty.push_back(max(0ll, y_sub[i] - 1));\n\t}\n\tx.push_back(0);\n\tx.push_back(H);\n\ty.push_back(0);\n\ty.push_back(W);\n\tsort(x.begin(), x.end());\n\tsort(y.begin(), y.end());\n\tfor(i = 1, j = 1; j < x.size(); j++){\n\t\tif(x[j - 1] < x[j]){\n\t\t\tx[i] = x[j];\n\t\t\ti++;\n\t\t}\n\t}\n\th = i - 1;\n\tfor(i = 1, j = 1; j < y.size(); j++){\n\t\tif(y[j - 1] < y[j]){\n\t\t\ty[i] = y[j];\n\t\t\ti++;\n\t\t}\n\t}\n\tw = i - 1;\n\tvector<int> dx(h), dy(w);\n\tfor(i = 0; i < h; i++){\n\t\tdx[i] = x[i + 1] - x[i];\n\t}\n\tfor(i = 0; i < w; i++){\n\t\tdy[i] = y[i + 1] - y[i];\n\t}\n\tvector<vector<char>> A(h, vector<char>(w, '.'));\n\tfor(i = 0; i < h; i++){\n\t\tfor(j = 0; j < w; j++){\n\t\t\tfor(k = 0; k < N; k++){\n\t\t\t\tif(x[i] == x_sub[k] && y[j] == y_sub[k]){\n\t\t\t\t\tA[i][j] = '#';\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t}\n\tvector<vector<int>> dis(h, vector<int>(w, 1000000000));\n\tint ans = 0;\n\tfor(i = 0; i < h; i++){\n\t\tfor(j = (i % 2) * (w - 1); 0 <= j && j < w; j = j + 1 - 2 * (i % 2)){\n\t\t\tif(A[i][j] == '#'){\n\t\t\t\tcontinue;\n\t\t\t}\n\t\t\tint sub = MOD(inv6 * MOD(MOD(dx[i] * dy[j]) * MOD((dx[i] + dy[j]) * MOD(dx[i] * dy[j] - 1))));\n\t\t\tans = MOD(ans + sub);\n\t\t\tint old_dis = dis[i][j];\n\t\t\tfor(k = 0; k < h; k++){\n\t\t\t\tfor(l = 0; l < w; l++){\n\t\t\t\t\tdis[k][l] += old_dis;\n\t\t\t\t}\n\t\t\t}\n\t\t\tqueue<pair<pair<int, int>, int>> q;\n\t\t\tq.push(pair<pair<int, int>, int>(pair<int, int>(i, j), 0));\n\t\t\twhile(q.size() > 0){\n\t\t\t\tk = q.front().first.first;\n\t\t\t\tl = q.front().first.second;\n\t\t\t\tint d = q.front().second;\n\t\t\t\tq.pop();\n\t\t\t\tif(A[k][l] == '#' || dis[k][l] <= d){\n\t\t\t\t\tcontinue;\n\t\t\t\t}\n\t\t\t\tdis[k][l] = d;\n\t\t\t\tif(l < w - 1){\n\t\t\t\t\tq.push(pair<pair<int, int>, int>(pair<int, int>(k + 0, l + 1), d + dy[l]));\n\t\t\t\t}\n\t\t\t\tif(k < h - 1){\n\t\t\t\t\tq.push(pair<pair<int, int>, int>(pair<int, int>(k + 1, l + 0), d + dx[k]));\n\t\t\t\t}\n\t\t\t\tif(l > 0){\n\t\t\t\t\tq.push(pair<pair<int, int>, int>(pair<int, int>(k + 0, l - 1), d + dy[l - 1]));\n\t\t\t\t}\n\t\t\t\tif(k > 0){\n\t\t\t\t\tq.push(pair<pair<int, int>, int>(pair<int, int>(k - 1, l + 0), d + dx[k - 1]));\n\t\t\t\t}\n\t\t\t}\n\t\t\tfor(k = 0; k < h; k++){\n\t\t\t\tfor(l = 0; l < w; l++){\n\t\t\t\t\tif(k < i || (i == k && l <= j) || A[k][l] == '#'){\n\t\t\t\t\t\tcontinue;\n\t\t\t\t\t}\n\t\t\t\t\tint res = calc(dis[k][l], x[i], dx[i], x[k], dx[k], y[j], dy[j], y[l], dy[l]);\n\t\t\t\t\tans = MOD(ans + res);\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t}\n\tprintf(\"%lld\\n\", MOD(ans + p));\n\treturn 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include <cstdio>\n#include <cstring>\n#include <algorithm>\n#include <vector>\n#include <queue>\n\nconst int MOD = (int)1e9 + 7;\nconst int inv2 = MOD + 1 >> 1;\nconst int kN = 30;\nconst int kM = kN * 2 + 5;\nint h, w, n, x[kN], y[kN];\nstd::vector<int> sx, sy;\nint mat[kM][kM];\nint dir[4][2] = {1,0,0,1,-1,0,0,-1};\n\ninline void add(int &a, int b)\n{\n    a += b;\n    if (a >= MOD) a -= MOD;\n}\n\nint main()\n{\n    scanf(\"%d%d%d\", &h, &w, &n);\n    sx.emplace_back(-1);\n    sx.emplace_back(h);\n    sy.emplace_back(-1);\n    sy.emplace_back(w);\n    for (int i = 0; i < n; ++ i) {\n        scanf(\"%d%d\", x + i, y + i);\n        sx.emplace_back(x[i]);\n        sy.emplace_back(y[i]);\n    }\n    auto prepare = [](std::vector<int> &v) {\n        std::sort(v.begin(), v.end());\n        v.erase(std::unique(v.begin(), v.end()), v.end());\n        std::vector<int> w;\n        for (int i = 0; i < v.size(); ++ i) {\n            if (w.empty() || w.back() != v[i]) w.emplace_back(v[i]);\n            if (i + 1 < v.size()) w.emplace_back(v[i] + 1);\n        }\n        w.swap(v);\n    };\n    auto get = [](const std::vector<int> &v, int x) {\n        return std::lower_bound(v.begin(), v.end(), x) - v.begin();\n    };\n    prepare(sx);\n    prepare(sy);\n    for (int i = 0; i < n; ++ i) {\n        mat[get(sx, x[i])][get(sy, y[i])] = 1;\n    }\n    int result = 0;\n    auto calcEmpty = [&result](const std::vector<int> &sx, int w, int h, int* x, int n) {\n        for (int i = 1; i + 1 < sx.size(); ++ i) if (sx[i + 1] - sx[i] > 1) {\n            int t = sx[i + 1] - sx[i];\n            int up = sx[i] * 1LL * w % MOD;\n            int down = (h - sx[i + 1]) * 1LL * w % MOD;\n            for (int j = 0; j < n; ++ j) {\n                if (x[j] < sx[i]) add(up, MOD - 1);\n                else add(down, MOD - 1);\n            }\n            // printf(\"t = %d, up = %d, down = %d\\n\", t, up, down);\n            // printf(\"sx[i] = %d, sx[i + 1] = %d\\n\", sx[i], sx[i + 1]);\n            for (int j = 1; j < t; ++ j)\n                add(result, (up + j * 1LL * w) % MOD * 1LL * ((down + (t - j) * 1LL * w) % MOD) % MOD);\n        }\n    };\n    calcEmpty(sx, w, h, x, n);\n    // printf(\"%d\\n\", result);\n    calcEmpty(sy, h, w, y, n);\n    // printf(\"%d\\n\", result);\n    // for (int i = 0; i < sx.size(); ++ i)\n    //     for (int j = 0; j < sy.size(); ++ j)\n    //         printf(\"%d%c\", mat[i][j], \" \\n\"[j + 1 == sy.size()]);\n    for (int i = 1; i + 1 < sx.size(); ++ i) {\n        for (int j = 1; j + 1 < sy.size(); ++ j) if (mat[i][j] == 0) {\n            std::vector<std::vector<int>> dist(sx.size(), std::vector<int>(sy.size(), -1));\n            dist[i][j] = 0;\n            std::queue<int> que;\n            que.emplace(i);\n            que.emplace(j);\n            while (!que.empty()) {\n                int x = que.front(); que.pop();\n                int y = que.front(); que.pop();\n                for (int d = 0; d < 4; ++ d) {\n                    int tx = x + dir[d][0];\n                    int ty = y + dir[d][1];\n                    if (tx <= 0 || tx + 1 >= sx.size() || ty <= 0 || ty + 1 >= sy.size() || mat[tx][ty] || dist[tx][ty] != -1) continue;\n                    dist[tx][ty] = dist[x][y] + 1;\n                    que.emplace(tx);\n                    que.emplace(ty);\n                }\n            }\n            for (int ii = 1; ii + 1 < sx.size(); ++ ii)\n                for (int jj = 1; jj + 1 < sy.size(); ++ jj) \n                    if (dist[ii][jj] > 0) {\n                        add(result, dist[ii][jj] * 1LL * (sx[i + 1] - sx[i]) % MOD * (sy[j + 1] - sy[j]) % MOD *\n                            (sx[ii + 1] - sx[ii]) % MOD * (sy[jj + 1] - sy[jj]) % MOD * inv2 % MOD);\n                        // printf(\"i = %d, j = %d, ii = %d, jj = %d\\n\", i, j, ii, jj);\n                    }\n        }\n    }\n    printf(\"%d\\n\", result);\n}\n"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\nusing namespace std;\n#define int long long\n#define p (int)(1e9 + 7)\n\nint MOD(int a){\n\treturn (a %= p) >= 0 ? a : a + p;\n}\n\nint power(int a, int N){\n\tif(N == 0){\n\t\treturn 1;\n\t}\n\telse if(N % 2 == 0){\n\t\treturn power(MOD(a * a), N / 2);\n\t}\n\telse{\n\t\treturn MOD(a * power(a, N - 1));\n\t}\n}\n\nint inverse(int a){\n\treturn power(a, p - 2);\n}\n\n#define inf (int)(1e9)\n\nstruct edge{\n\tint to;\n\tint cost;\n\n\tedge(int to, int cost) : to(to), cost(cost){}\n};\n\nvector<int> dijkstra(vector<vector<edge> > &g, int s){\n\tvector<int> ans(g.size(), inf);\n\tpriority_queue<pair<int, int>, vector<pair<int, int> >, greater<pair<int, int> > > q;//(距離, 頂点番号)\n\tq.push(pair<int, int>(0, s));\n\twhile(q.size() > 0){\n\t\tint dis = q.top().first, v = q.top().second;\n\t\tq.pop();\n\t\tif(dis < ans[v]){\n\t\t\tans[v] = dis;\n\t\t\tfor(int i = 0; i < g[v].size(); i++){\n\t\t\t\tq.push(pair<int, int>(dis + g[v][i].cost, g[v][i].to));\n\t\t\t}\n\t\t}\n\t}\n\treturn ans;\n}\n\nint h, w;\nint inv2, inv6;\n\nint align(int i, int j){\n\treturn i * w + j;\n}\n\nint calc(int dis, int x1, int dx1, int x2, int dx2, int y1, int dy1, int y2, int dy2){\n//\tprintf(\"calc(%lld, %lld, %lld, %lld, %lld, %lld, %lld, %lld, %lld)\\n\", dis, x1, dx1, x2, dx2, y1, dy1, y2, dy2);\n\tif(x2 < x1){\n\t\treturn calc(dis, x2, dx2, x1, dx1, y2, dy2, y1, dy1);\n\t}\n\telse if(y2 < y1){\n\t\treturn calc(dis + dx2 - dx1, x1, dx2, x2 + dx2 - dx1, dx1, y2, dy2, y1, dy1);\n\t}\n\telse if(x1 == x2){\n\t\treturn calc(dis, y1, dy1, y2, dy2, x1, dx1, x2, dx2);\n\t}\n\tif(y1 == y2){\n\t\tif(dy1 == 1){\n//\t\t\tprintf(\"test1\\n\");\n\t\t\treturn MOD(inv2 * MOD(MOD(dx1 * dx2) * (2 * dis + (dx2 - dx1))));\n\t\t}\n\t\telse{\n//\t\t\tprintf(\"test2\\n\");\n\t\t\treturn MOD(inv6 * MOD(MOD(MOD(dx1 * dx2) * dy1) * (MOD(3 * dy1 * (2 * (x2 - x1) + (dx2 - dx1))) + MOD(2 * (dy1 - 1) * (dy1 + 1)))));\n\t\t}\n\t}\n\telse{\n//\t\tprintf(\"test3\\n\");\n\t\treturn MOD(inv2 * MOD(MOD(MOD(dx1 * dx2) * MOD(dy1 * dy2)) * MOD(2 * dis + (dx2 - dx1) + (dy2 - dy1))));\n\t}\n}\n\nsigned main(){\n\tint H, W, N, i, j, k, l;\n\tscanf(\"%lld%lld\", &H, &W);\n\tscanf(\"%lld\", &N);\n\tvector<int> x_sub(N), y_sub(N), x(0), y(0);\n\tfor(i = 0; i < N; i++){\n\t\tscanf(\"%lld%lld\", &x_sub[i], &y_sub[i]);\n\t\tx.push_back(x_sub[i]);\n\t\tx.push_back(x_sub[i] + 1);\n\t\tx.push_back(max(0ll, x_sub[i] - 1));\n\t\ty.push_back(y_sub[i]);\n\t\ty.push_back(y_sub[i] + 1);\n\t\ty.push_back(max(0ll, y_sub[i] - 1));\n\t}\n\tx.push_back(0);\n\tx.push_back(H);\n\ty.push_back(0);\n\ty.push_back(W);\n\tsort(x.begin(), x.end());\n\tsort(y.begin(), y.end());\n\tfor(i = 1, j = 1; j < x.size(); j++){\n\t\tif(x[j - 1] < x[j]){\n\t\t\tx[i] = x[j];\n\t\t\ti++;\n\t\t}\n\t}\n\th = i - 1;\n\tfor(i = 1, j = 1; j < y.size(); j++){\n\t\tif(y[j - 1] < y[j]){\n\t\t\ty[i] = y[j];\n\t\t\ti++;\n\t\t}\n\t}\n\tw = i - 1;\n\tvector<int> dx(h), dy(w);\n\tfor(i = 0; i < h; i++){\n\t\tdx[i] = x[i + 1] - x[i];\n\t}\n\tfor(i = 0; i < w; i++){\n\t\tdy[i] = y[i + 1] - y[i];\n\t}\n/*\tprintf(\"x:\\n\");\n\tfor(i = 0; i < h; i++){\n\t\tprintf(\"%lld \", x[i]);\n\t}\n\tprintf(\"\\n\");\n\tprintf(\"dx:\\n\");\n\tfor(i = 0; i < h; i++){\n\t\tprintf(\"%lld \", dx[i]);\n\t}\n\tprintf(\"\\n\");\n\tprintf(\"y:\\n\");\n\tfor(j = 0; j < w; j++){\n\t\tprintf(\"%lld \", y[j]);\n\t}\n\tprintf(\"\\n\");\n\tprintf(\"dy:\\n\");\n\tfor(i = 0; i < w; i++){\n\t\tprintf(\"%lld \", dy[i]);\n\t}\n\tprintf(\"\\n\");\n*/\tvector<vector<char>> A(h, vector<char>(w, '.'));\n\tfor(i = 0; i < h; i++){\n\t\tfor(j = 0; j < w; j++){\n\t\t\tfor(k = 0; k < N; k++){\n\t\t\t\tif(x[i] == x_sub[k] && y[j] == y_sub[k]){\n\t\t\t\t\tA[i][j] = '#';\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t}\n/*\tprintf(\"A:\\n\");\n\tfor(i = 0; i < h; i++){\n\t\tfor(j = 0; j < w; j++){\n\t\t\tprintf(\"%c\", A[i][j]);\n\t\t}\n\t\tprintf(\"\\n\");\n\t}\n\tprintf(\"\\n\");\n*/\n/*\tvector<vector<edge>> g(h * w, vector<edge>());\n\tfor(i = 0; i < h; i++){\n\t\tfor(j = 1; j < w; j++){\n\t\t\tif(A[i][j - 1] == '.' && A[i][j] == '.'){\n\t\t\t\tg[align(i, j - 1)].push_back(edge(align(i, j), y[j] - y[j - 1]));\n\t\t\t\tg[align(i, j)].push_back(edge(align(i, j - 1), y[j] - y[j - 1]));\n\t\t\t}\n\t\t}\n\t}\n\tfor(i = 1; i < h; i++){\n\t\tfor(j = 0; j < w; j++){\n\t\t\tif(A[i - 1][j] == '.' && A[i][j] == '.'){\n\t\t\t\tg[align(i - 1, j)].push_back(edge(align(i, j), x[i] - x[i - 1]));\n\t\t\t\tg[align(i, j)].push_back(edge(align(i - 1, j), x[i] - x[i - 1]));\n\t\t\t}\n\t\t}\n\t}\n*/\tvector<vector<int>> dis(h, vector<int>(w, inf));\n\tint ans = 0;\n\tinv2 = inverse(2);\n\tinv6 = inverse(6);\n\tfor(i = 0; i < h; i++){\n\t\tfor(j = 0; j < w; j++){\n\t\t\tif(A[i][j] == '#'){\n\t\t\t\tcontinue;\n\t\t\t}\n//\t\t\tprintf(\"(i, j) = (%lld, %lld)\\n\", i, j);\n\t\t\tint sub = MOD(inv6 * MOD(MOD(dx[i] * dy[j]) * MOD((dx[i] + dy[j]) * MOD(dx[i] * dy[j] - 1))));\n//\t\t\tprintf(\"ans += 2 * %lld\\n\", sub);\n\t\t\tans = MOD(ans + sub);\n\t\t\tint old_dis = dis[i][j];\n\t\t\tfor(k = 0; k < h; k++){\n\t\t\t\tfor(l = 0; l < w; l++){\n\t\t\t\t\tdis[k][l] += old_dis;\n\t\t\t\t}\n\t\t\t}\n\t\t\tqueue<pair<pair<int, int>, int>> q;\n\t\t\tq.push(pair<pair<int, int>, int>(pair<int, int>(i, j), 0));\n\t\t\twhile(q.size() > 0){\n\t\t\t\tk = q.front().first.first;\n\t\t\t\tl = q.front().first.second;\n\t\t\t\tint d = q.front().second;\n\t\t\t\tq.pop();\n\t\t\t\tif(A[k][l] == '#' || dis[k][l] <= d){\n\t\t\t\t\tcontinue;\n\t\t\t\t}\n\t\t\t\tdis[k][l] = d;\n\t\t\t\tif(l < w - 1){\n\t\t\t\t\tq.push(pair<pair<int, int>, int>(pair<int, int>(k + 0, l + 1), d + dy[l]));\n\t\t\t\t}\n\t\t\t\tif(k < h - 1){\n\t\t\t\t\tq.push(pair<pair<int, int>, int>(pair<int, int>(k + 1, l + 0), d + dx[k]));\n\t\t\t\t}\n\t\t\t\tif(l > 0){\n\t\t\t\t\tq.push(pair<pair<int, int>, int>(pair<int, int>(k + 0, l - 1), d + dy[l - 1]));\n\t\t\t\t}\n\t\t\t\tif(k > 0){\n\t\t\t\t\tq.push(pair<pair<int, int>, int>(pair<int, int>(k - 1, l + 0), d + dx[k - 1]));\n\t\t\t\t}\n\t\t\t}\n//\t\t\tvector<int> dis = dijkstra(g, align(i, j));\n\t\t\tfor(k = 0; k < h; k++){\n\t\t\t\tfor(l = 0; l < w; l++){\n\t\t\t\t\tif(k < i || (i == k && l <= j) || A[k][l] == '#'){\n\t\t\t\t\t\tcontinue;\n\t\t\t\t\t}\n//\t\t\t\t\tprintf(\"(k, l) = (%lld, %lld)\\n\", k, l);\n\t\t\t\t\tint res = calc(dis[k][l], x[i], dx[i], x[k], dx[k], y[j], dy[j], y[l], dy[l]);\n//\t\t\t\t\tprintf(\"ans += %lld\\n\", res);\n\t\t\t\t\tans = MOD(ans + res);\n\t\t\t\t}\n\t\t\t}\n//\t\t\tprintf(\"\\n\");\n\t\t}\n\t}\n//\tans = MOD(ans * inv2);\n\tprintf(\"%lld\\n\", ans);\n\treturn 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include <iostream>\n#include <vector>\n#include <map>\n#include <queue>\n#include <algorithm>\n#include <cstring>\nusing namespace std;\n\n#define REP(i, s) for (int i = 0; i < s; ++i)\n#define ALL(v) (v.begin(), v.end())\n#define COUT(x) cout << #x << \" = \" << (x) << \" (L\" << __LINE__ << \")\" << endl\n#define EACH(i, s) for (__typeof__((s).begin()) i = (s).begin(); i != (s).end(); ++i)\n\ntemplate<class T> inline bool chmax(T& a, T b) { if (a < b) { a = b; return 1; } return 0; }\ntemplate<class T> inline bool chmin(T& a, T b) { if (a > b) { a = b; return 1; } return 0; }\ntemplate<class T1, class T2> ostream& operator << (ostream &s, pair<T1, T2> P)\n{\n\treturn s << '<' << P.first << \", \" << P.second << '>';\n}\ntemplate<class T> ostream& operator << (ostream &s, vector<T> P)\n{\n\tfor (int i = 0; i < P.size(); ++i) { if (i > 0) { s << \" \"; } s << P[i]; } return s;\n}\ntemplate<class T> ostream& operator << (ostream &s, vector<vector<T> > P)\n{\n\tfor (int i = 0; i < P.size(); ++i) { s << endl << P[i]; } return s << endl;\n}\n\nconst int MOD = 1000000007;\ninline long long mod(long long a, long long m) { return (a % m + m) % m; }\nstruct Fp {\n\tint MOD = 1000000007;\n\tlong long val;\n\n\tFp() : val(0) {}\n\tFp(long long val_) { this->val = mod(val_, MOD); }\n\tFp operator = (long long val_) { this->val = mod(val_, MOD); return *this; }\n\tinline Fp operator - () { return mod(-val, MOD); }\n\tinline const Fp& operator += (const Fp &x);\n\tinline const Fp& operator -= (const Fp &x);\n\tinline const Fp& operator *= (const Fp &x);\n\tinline const Fp& operator /= (const Fp &x);\n};\n\ninline bool operator == (Fp x, Fp y) { return x.val == y.val; }\ninline bool operator != (Fp x, Fp y) { return !(x == y); }\n\nostream &operator << (ostream &os, Fp x) { return os << x.val; }\nistream &operator >> (istream &is, Fp &x) { is >> x; return is; }\n\ninline Fp operator + (Fp x, Fp y) { return mod(x.val + y.val, x.MOD); }\ninline Fp operator - (Fp x, Fp y) { return mod(x.val - y.val, x.MOD); }\ninline Fp operator * (Fp x, Fp y) { return mod(x.val * y.val, x.MOD); }\ninline Fp operator / (Fp x, Fp y) {\n\tlong long a = y.val, b = x.MOD, u = 1, v = 0;\n\twhile (b) {\n\t\tlong long t = a / b;\n\t\ta -= t*b; swap(a, b);\n\t\tu -= t*v; swap(u, v);\n\t}\n\treturn x * u;\n}\ninline Fp abs(Fp a) { return a; }\ninline Fp fpow(Fp a, long long n) {\n\tif (n == 0) return Fp(1);\n\tFp t = fpow(a, n / 2);\n\tt = t * t; if (n & 1) t = t * a;\n\treturn t;\n}\ninline const Fp& Fp::operator += (const Fp &x) { *this = *this + x; return *this; }\ninline const Fp& Fp::operator -= (const Fp &x) { *this = *this - x; return *this; }\ninline const Fp& Fp::operator *= (const Fp &x) { *this = *this * x; return *this; }\ninline const Fp& Fp::operator /= (const Fp &x) { *this = *this / x; return *this; }\n\n// calc comb (small n, r ver)\nconst int FACT_MAX = 210000;\nstatic Fp fp_fact_val[FACT_MAX];\n\nvoid calcFact(int MAX = FACT_MAX) {\n\tfp_fact_val[0] = 1;\n\tfor (int val = 1; val < MAX; ++val) {\n\t\tfp_fact_val[val] = fp_fact_val[val - 1] * val;\n\t}\n}\n\nFp fact(int n) {\n\treturn fp_fact_val[n];\n}\n\nFp com(int n, int r) {\n\treturn fact(n) / fact(r) / fact(n - r);\n}\n\nint dx[4] = {1, 0, -1, 0};\nint dy[4] = {0, 1, 0, -1};\n\nlong long H, W, N;\nlong long bx[210], by[210];\nvector<long long> altx, alty;\nlong long nH, nW;\n\nlong long xnum[1100000], ynum[1100000];\n\nbool cb[210][210];\nlong long dist[210][210];\n\ntypedef pair<int, int> pint;\n\nlong long subsolve() {\n\t//COUT(nH); COUT(nW); COUT(altx); COUT(alty);\n\n\tfor (int x = 0; x < nH - 1; ++x) {\n\t\tfor (int y = 0; y < nW - 1; ++y) {\n\t\t\t//cout << cb[x][y];\n\t\t}\n\t\t//cout << endl;\n\t}\n\n  long long res = 0;\n\tfor (int x = 0; x < nH - 1; ++x) {\n\t\tfor (int y = 0; y < nW - 1; ++y) {\n\t\t\tif (cb[x][y]) continue;\n\t\t\tmemset(dist, -1, sizeof(dist));\n\t\t\tqueue<pint> que;\n\t\t\tque.push(pint(x, y));\n\t\t\tdist[x][y] = 0;\n\t\t\twhile (!que.empty()) {\n\t\t\t\tpint cur = que.front();\n\t\t\t\tque.pop();\n\t\t\t\tfor (int dir = 0; dir < 4; ++dir) {\n\t\t\t\t\tint nx = cur.first + dx[dir];\n\t\t\t\t\tint ny = cur.second + dy[dir];\n\t\t\t\t\tif (nx < 0 || nx >= H || ny < 0 || ny >= W) continue;\n\t\t\t\t\tif (cb[nx][ny]) continue;\n\t\t\t\t\tif (dist[nx][ny] == -1) {\n\t\t\t\t\t\tdist[nx][ny] = dist[cur.first][cur.second] + 1;\n\t\t\t\t\t\tque.push(pint(nx, ny));\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t}\n\t\t\t\n\t\t\tfor (int nx = 0; nx < nH - 1; ++nx) {\n\t\t\t\tfor (int ny = 0; ny < nW - 1; ++ny) {\n\t\t\t\t\tif (nW * nx + ny <= nW * x + y) continue;\n\t\t\t\t\tif (dist[nx][ny] == -1) continue;\n\t\t\t\t\tif (cb[nx][ny]) continue;\n\n\t\t\t\t\tlong long ss = ((long long)(altx[x + 1] - altx[x]) * (alty[y + 1] - alty[y])) % MOD;\n\t\t\t\t\tlong long st = ((long long)(altx[nx + 1] - altx[nx]) * (alty[ny + 1] - alty[ny])) % MOD;\n\t\t\t\t\tres += (dist[nx][ny] % MOD) * ss % MOD * st % MOD;\n\n\t\t\t\t\t//cout << pint(x, y) << \", \" << pint(nx, ny) << \": \" << dist[nx][ny] << \", \" << ss << \", \" << st << endl;\n\t\t\t\t}\n\t\t\t}\n\t\t\t\n\t\t}\n\t}\n\t//COUT(res);\n\t//res /= 2;\n\n\treturn res;\n}\n\nFp solve() {\n  memset(xnum, 0, sizeof(xnum));\n  memset(ynum, 0, sizeof(ynum));\n\taltx.clear();\n\talty.clear();\n  altx.push_back(0);\n  altx.push_back(H);\n  alty.push_back(0);\n  alty.push_back(W);\n  for (int i = 0; i < N; ++i) {\n\t\taltx.push_back(bx[i]);\n\t\taltx.push_back(bx[i] + 1);\n\t\talty.push_back(by[i]);\n\t\talty.push_back(by[i] + 1);\n\t\txnum[bx[i]]++;\n\t\tynum[by[i]]++;\n  }\n  sort(altx.begin(), altx.end());\n  sort(alty.begin(), alty.end());\n  altx.erase(unique(altx.begin(), altx.end()), altx.end());\n  alty.erase(unique(alty.begin(), alty.end()), alty.end());\n  nH = altx.size();\n  nW = alty.size();\n\n  memset(cb, 0, sizeof(cb));\n  for (int i = 0; i < N; ++i) {\n\t\tint itx = lower_bound(altx.begin(), altx.end(), bx[i]) - altx.begin();\n\t\tint ity = lower_bound(alty.begin(), alty.end(), by[i]) - alty.begin();\n\t\tcb[itx][ity] = true;\n  }\n\n  long long all = (long long)H * W - N;\n  Fp add = 0;\n  long long width = W;\n\tlong long num_comped = 0;\n  long long sum = width - xnum[0];\n  for (int i = 1; i < H; ++i) {\n\t\tif (xnum[i] == 0 && xnum[i-1] == 0) {   // i-1 -> i\n\t\t\tFp up = sum - width * num_comped;\n\t\t\tFp down = all - sum;\n\t\t\tadd += up * down;\n\t\t}\n\t\tsum += width - xnum[i];\n  }\n  long long height = H - num_comped;\n  all -= width * num_comped;\n  num_comped = 0;\n  sum = height - ynum[0];\n  for (int i = 1; i < W; ++i) {\n\t\tif (ynum[i] == 0 && ynum[i-1] == 0) {   // i-1 -> i\n\t\t\tFp left = sum - height * num_comped;\n\t\t\tFp right = all - sum;\n\t\t\tadd += left * right;\n\t\t}\n\t\tsum += height - ynum[i];\n  }\n\n  Fp comp = subsolve();\n  Fp res = comp + add;\n\n\t//COUT(add);\n\n  return res;\n}\n\nint main() {\n  while (cin >> H >> W >> N) {\n\t\tfor (int i = 0; i < N; ++i) cin >> bx[i] >> by[i];\n\t\tcout << solve() << endl;\n  }\n}\n"
  },
  {
    "language": "C++",
    "code": "#include <cstdio>\n#include <cstring>\n#include <cstdlib>\n#include <cmath>\n#include <ctime>\n#include <cassert>\n#include <string>\n#include <algorithm>\n#include <vector>\n#include <queue>\n#include <stack>\n#include <functional>\n#include <iostream>\n#include <map>\n#include <set>\n#include <cassert>\nusing namespace std;\ntypedef long long ll;\ntypedef pair<int,int> P;\ntypedef pair<int,P> P1;\ntypedef pair<P,P> P2;\n#define pu push\n#define pb push_back\n#define mp make_pair\n#define eps 1e-7\n#define INF 1000000000\n#define mod 1000000007\n#define fi first\n#define sc second\n#define rep(i,x) for(int i=0;i<x;i++)\n#define repn(i,x) for(int i=1;i<=x;i++)\n#define SORT(x) sort(x.begin(),x.end())\n#define ERASE(x) x.erase(unique(x.begin(),x.end()),x.end())\n#define POSL(x,v) (lower_bound(x.begin(),x.end(),v)-x.begin())\n#define POSU(x,v) (upper_bound(x.begin(),x.end(),v)-x.begin())\nvector<int>zx,zy;\nint h,w,n,a[35],b[35];\nvector<P1>za,zb;\nvector<int>cx,cy;\nint revx[1000005],revy[1000005];\nbool bad[105][105];\nint dist[95][95];\nbool u[95][95];\nint main(){\n\tcin>>h>>w>>n;\n\trep(i,n){\n\t\tcin>>a[i]>>b[i]; a[i]++; b[i]++;\n\t\tzx.pb(a[i]);\n\t\tzy.pb(b[i]);\n\t}\n\tSORT(zx); ERASE(zx);\n\tSORT(zy); ERASE(zy);\n\tint cur = 1;\n\trep(i,zx.size()){\n\t\tif(cur != zx[i]){\n\t\t\tza.pb(mp(0,mp(cur,zx[i]-1)));\n\t\t}\n\t\tza.pb(mp(1,mp(zx[i],zx[i])));\n\t\tcur = zx[i]+1;\n\t}\n\tif(cur <= h){\n\t\tza.pb(mp(0,mp(cur,h)));\n\t}\n\t\n\tcur = 1;\n\trep(i,zy.size()){\n\t\tif(cur != zy[i]){\n\t\t\tzb.pb(mp(0,mp(cur,zy[i]-1)));\n\t\t}\n\t\tzb.pb(mp(1,mp(zy[i],zy[i])));\n\t\tcur = zy[i]+1;\n\t}\n\tif(cur <= w){\n\t\tzb.pb(mp(0,mp(cur,w)));\n\t}\n\trep(i,za.size()){\n\t\trep(j,zb.size()){\n\t\t\tcx.pb(za[i].sc.fi); cx.pb(za[i].sc.sc);\n\t\t\tcy.pb(zb[j].sc.fi); cy.pb(zb[j].sc.sc);\n\t\t}\n\t}\n\tSORT(cx); ERASE(cx);\n\tSORT(cy); ERASE(cy);\n\trep(i,cx.size()) revx[cx[i]] = i+1;\n\trep(i,cy.size()) revy[cy[i]] = i+1;\n\trep(i,cx.size()){\n        rep(j,cy.size()){\n            rep(k,n) if(a[k]==cx[i]&&b[k]==cy[j]) bad[i+1][j+1] = 1;\n        }\n\t}\n\tll add = 0,add2 = 0;\n\trep(i,za.size()){\n\t\trep(j,zb.size()){\n\t\t\tint x = za[i].sc.fi,y = zb[j].sc.fi;\n\t\t\tx = revx[x]; y = revy[y];\n\t\t\tif(bad[x][y]) continue;\n\t\t\tif(!za[i].fi && !zb[j].fi) continue;\n\t\t\tll cnt = 1LL*(za[i].sc.sc-za[i].sc.fi+1)*(zb[j].sc.sc-zb[j].sc.fi+1);\n\t\t\tcnt %= mod;\n\t\t\trep(x,95) rep(y,95) {\n\t\t\t\tdist[x][y] = INF;\n\t\t\t\tu[x][y] = 0;\n\t\t\t}\n\t\t\tdist[x][y] = 0;\n\t\t\tqueue<P1>que;\n\t\t\tque.push(mp(0,mp(x,y)));\n\t\t\twhile(!que.empty()){\n\t\t\t\tP1 p = que.front(); que.pop();\n\t\t\t\tif(u[p.sc.fi][p.sc.sc]) continue;\n\t\t\t\tu[p.sc.fi][p.sc.sc] = 1;\n\t\t\t\tint X = p.sc.fi,Y = p.sc.sc;\n\t\t\t\tint dx[4]={0,1,0,-1};\n\t\t\t\tint dy[4]={1,0,-1,0};\n\t\t\t\trep(k,4){\n\t\t\t\t\tint nx = X+dx[k];\n\t\t\t\t\tint ny = Y+dy[k];\n\t\t\t\t\tif(1<=nx&&nx<=cx.size()&&1<=ny&&ny<=cy.size()&&!bad[nx][ny]){\n\t\t\t\t\t\tint dt;\n\t\t\t\t\t\tif(k%2 == 0) dt = cy[max(Y,ny)-1]-cy[min(Y,ny)-1];\n\t\t\t\t\t\telse dt = cx[max(X,nx)-1]-cx[min(X,nx)-1];\n\t\t\t\t\t\tif(dist[nx][ny] > dist[X][Y]+dt && !u[nx][ny]){\n\t\t\t\t\t\t\tdist[nx][ny] = dist[X][Y]+dt;\n\t\t\t\t\t\t\tque.push(mp(dist[nx][ny],mp(nx,ny)));\n\t\t\t\t\t\t}\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t}\n\t\t\trep(ii,za.size()){\n\t\t\t\trep(jj,zb.size()){\n\t\t\t\t\tint xx = za[ii].sc.fi,yy = zb[jj].sc.fi;\n\t\t\t\t\txx = revx[xx]; yy = revy[yy];\n\t\t\t\t\tll cntt = 1LL*(za[ii].sc.sc-za[ii].sc.fi+1)*(zb[jj].sc.sc-zb[jj].sc.fi+1);\n\t\t\t\t\tcntt %= mod;\n\t\t\t\t\tint dif = dist[xx][yy];\n\t\t\t\t\tif(dif == INF) continue;\n\t\t\t\t\tdif -= cx[max(xx,x)-1]-cx[min(xx,x)-1]+cy[max(yy,y)-1]-cy[min(yy,y)-1];\n\t\t\t\t\tassert(dif >= 0);\n\t\t\t\t\tif(!za[ii].fi && !zb[jj].fi) add2 += (dif * (cnt * cntt % mod) % mod);\n\t\t\t\t\telse add += (dif * (cnt * cntt % mod) % mod);\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t}\n\tadd %= mod;\n\tadd = add*(mod+1)/2%mod;\n\tadd = (add+add2)%mod;\n\t//cout << add << endl;\n\tll ret = 0;\n\tfor(int i=1;i<w;i++){\n\t\tret += 1LL*h*h%mod*i%mod*(w-i)%mod;\n\t\tret %= mod;\n\t}\n\tfor(int i=1;i<h;i++){\n\t\tret += 1LL*w*w%mod*i%mod*(h-i)%mod;\n\t\tret %= mod;\n\t}\n\tfor(int i=0;i<n;i++){\n\t\tret -= 1LL*(a[i]-1)*a[i]%mod*((mod+1)/2)%mod*w%mod;\n\t\tret -= 1LL*(h-a[i])*(h-a[i]+1)%mod*((mod+1)/2)%mod*w%mod;\n\t\tret -= 1LL*(b[i]-1)*b[i]%mod*((mod+1)/2)%mod*h%mod;\n\t\tret -= 1LL*(w-b[i])*(w-b[i]+1)%mod*((mod+1)/2)%mod*h%mod;\n\t\tret %= mod;\n\t}\n\tfor(int i=0;i<n;i++){\n\t\tfor(int j=i+1;j<n;j++){\n\t\t\tret += abs(a[i]-a[j])+abs(b[i]-b[j]);\n\t\t\tret %= mod;\n\t\t}\n\t}\n\tret = (ret%mod+mod)%mod;\n\t//cout << ret << \" \" << add << endl;\n\tcout << (ret+add)%mod << endl;\n}"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\nusing namespace std;\nconst int MAX = 1e6 + 5;\nconst int mod = 1e9 + 7;\nconst int dx[] = {0, 0, -1, +1}, dy[] = {-1, +1, 0, 0};\n\nint H, W, n;\nint x[70], y[70];\nbool mark[70][70];\nint cntx, cnty, d[70][70], X[70], Y[70];\nint posx[MAX], posy[MAX], cntrow[MAX], cntcol[MAX];\nvector<int> zx, zy;\nint ans;\n\nvoid add(int &x, int y) {\n\tx += y; while(x < 0) x += mod; while(x >= mod) x -= mod;\n}\n\nvoid bfs(int sx, int sy) {\n\tfor (int i = 1; i <= cntx; ++i) for (int j = 1; j <= cnty; ++j) d[i][j] = -1;\n\tqueue< pair<int,int> > q; q.push(make_pair(sx, sy)); d[sx][sy] = 0;\n\twhile(!q.empty()) {\n\t\tint x = q.front().first, y = q.front().second; q.pop();\n\t\tfor (int dir = 0; dir < 4; ++dir) {\n\t\t\tint nx = x + dx[dir], ny = y + dy[dir];\n\t\t\tif (nx < 1 || nx > cntx || ny < 1 || ny > cnty || d[nx][ny] != -1) continue;\n\t\t\tif (mark[nx][ny]) continue;\n\t\t\td[nx][ny] = d[x][y] + 1;\n\t\t\tq.push(make_pair(nx, ny));\n\t\t}\n\t}\n\n\tint w = 1LL * X[sx] * Y[sy] % mod;\n\tfor (int i = 1; i <= cntx; ++i) {\n\t\tfor (int j = 1; j <= cnty; ++j) {\n\t\t\tif (i == sx && j == sy) continue;\n\t\t\tif (d[i][j] == -1) continue;\n\t\t\tint wij = 1LL * X[i] * Y[j] % mod;\n\t\t\tint cur = 1LL * w * wij % mod;\n\t\t\tadd(ans, 1LL * d[i][j] * cur % mod);\n\t\t}\n\t}\n}\n\nint main() {\n\tios_base::sync_with_stdio(false); cin.tie(0);\n\tcin >> H >> W >> n;\n\tfor (int i = 1; i <= n; ++i) {\n\t\tcin >> x[i] >> y[i];\n\t\tcntrow[x[i]]++;\n\t\tcntcol[y[i]]++;\n\t}\n\tlong long blank = 0;\n\tfor (int row = 0; row < H - 1; ++row) {\n\t\tblank += W - cntrow[row];\n\t\tif (cntrow[row] == 0 && cntrow[row+1] == 0) \n\t\t\tadd(ans, ( (blank % mod) * ((1LL * H * W - n - blank) % mod) ) % mod);\n\t}\n\tblank = 0;\n\tfor (int col = 0; col < W - 1; ++col) {\n\t\tblank += H - cntcol[col];\n\t\tif (cntcol[col] == 0 && cntcol[col+1] == 0)\n\t\t\tadd(ans, ( (blank % mod) * ((1LL * H * W - n - blank) % mod) ) % mod);\n\t}\n\tans = 2LL * ans % mod;\n\n\t// compress the cells\n\tfor (int i = 1; i <= n; ++i) zx.push_back(x[i]);\n\tfor (int i = 1; i <= n; ++i) zy.push_back(y[i]);\n\tsort(zx.begin(), zx.end()); zx.erase(unique(zx.begin(), zx.end()), zx.end());\n\tsort(zy.begin(), zy.end()); zy.erase(unique(zy.begin(), zy.end()), zy.end());\n\n\tfor (int i = 0; i < zx.size(); ++i) {\n\t\tX[++cntx] = zx[i] - (i == 0 ? -1 : zx[i - 1]) - 1;\n\t\tif (X[cntx] <= 0) --cntx;\n\t\tX[++cntx] = 1; // zx[i]\n\t\tposx[zx[i]] = cntx;\n\t}\n\tX[++cntx] = H - zx.back() - 1;\n\tif (X[cntx] <= 0) --cntx;\n\n\tfor (int i = 0; i < zy.size(); ++i) {\n\t\tY[++cnty] = zy[i] - (i == 0 ? -1 : zy[i - 1]) - 1;\n\t\tif (Y[cnty] <= 0) --cnty;\n\t\tY[++cnty] = 1; // zy[i]\n\t\tposy[zy[i]] = cnty;\n\t}\n\tY[++cnty] = W - zy.back() - 1;\n\tif (Y[cnty] <= 0) --cnty;\n\n\t// mark all black cells\n\tfor (int i = 1; i <= n; ++i) mark[posx[x[i]]][posy[y[i]]] = true;\n\n\t// new board: [1...cntx][1...cnty]\n\tfor (int i = 1; i <= cntx; ++i) {\n\t\tfor (int j = 1; j <= cnty; ++j) if (!mark[i][j]) {\n\t\t\tbfs(i, j);\n\t\t}\n\t}\n\n\tcout << 1LL * ans * (int)(5e8 + 4) % mod << endl;\n}"
  },
  {
    "language": "C++",
    "code": "#ifndef __clang__\n#pragma GCC optimize \"-O3\"\n#pragma GCC target \"tune=native\"\n#endif\n#ifdef ONLINE_JUDGE\n#define NDEBUG 1\n#endif\n#include <stdio.h>\n#include <bits/stdc++.h>\n\n#define FOR(i, n)     for(lli i = 0; i < (lli)(n); ++i)\n#define FORU(i, j, k) for(lli i = (j); i <= (lli)(k); ++i)\n#define FORD(i, j, k) for(lli i = (j); i >= (lli)(k); --i)\n\n#define SQ(x) ((x)*(x))\n\n#define all(x) begin(x), end(x)\n#define rall(x) rbegin(x), rend(x)\n#define mp make_pair\n#define mt make_tuple\n#define pb push_back\n#define eb emplace_back\n\nusing namespace std;\n\ntemplate<typename... As>\nstruct tpl : public std::tuple<As...> {\n  using std::tuple<As...>::tuple;\n  tpl(){}\n  tpl(std::tuple<As...> const& b) { std::tuple<As...>::operator=(b); }\n\n  template<typename T = tuple<As...> >\n  typename tuple_element<0, T>::type const&\n  x() const { return get<0>(*this); }\n  template<typename T = tuple<As...> >\n  typename tuple_element<0, T>::type&\n  x() { return get<0>(*this); }\n\n  template<typename T = tuple<As...> >\n  typename tuple_element<1, T>::type const&\n  y() const { return get<1>(*this); }\n  template<typename T = tuple<As...> >\n  typename tuple_element<1, T>::type&\n  y() { return get<1>(*this); }\n\n  template<typename T = tuple<As...> >\n  typename tuple_element<2, T>::type const&\n  z() const { return get<2>(*this); }\n  template<typename T = tuple<As...> >\n  typename tuple_element<2, T>::type&\n  z() { return get<2>(*this); }\n\n  template<typename T = tuple<As...> >\n  typename tuple_element<3, T>::type const&\n  w() const { return get<3>(*this); }\n  template<typename T = tuple<As...> >\n  typename tuple_element<3, T>::type&\n  w() { return get<3>(*this); }\n};\n\nusing lli   = long long int;\nusing llu   = long long unsigned;\n\nusing pii   = tpl<lli, lli>;\nusing piii  = tpl<lli, lli, lli>;\nusing piiii = tpl<lli, lli, lli, lli>;\nusing vi    = vector<lli>;\nusing vii   = vector<pii>;\nusing viii  = vector<piii>;\nusing vvi   = vector<vi>;\nusing vvii  = vector<vii>;\nusing vviii = vector<viii>;\n\ntemplate<class T>\nusing min_queue = priority_queue<T, vector<T>, greater<T> >;\ntemplate<class T>\nusing max_queue = priority_queue<T>;\n\ntemplate<size_t... I>\nstruct my_index_sequence {\n  using type = my_index_sequence;\n  static constexpr array<size_t, sizeof...(I)> value = { {I...} };\n};\n\nnamespace my_index_sequence_detail {\n  template<typename I, typename J> struct concat;\n  template<size_t... I, size_t... J>\n  struct concat<my_index_sequence<I...>, my_index_sequence<J...> > :\n    my_index_sequence<I..., (sizeof...(I)+J)...> { };\n  template<size_t N> struct make_index_sequence :\n    concat<typename make_index_sequence<N/2>::type, typename make_index_sequence<N-N/2>::type>::type { };\n  template <> struct make_index_sequence<0> : my_index_sequence<>{};\n  template <> struct make_index_sequence<1> : my_index_sequence<0>{};\n}\n\ntemplate<class... A>\nusing my_index_sequence_for = typename my_index_sequence_detail::make_index_sequence<sizeof...(A)>::type;\n\ntemplate<class T, size_t... I>\nvoid print_tuple(ostream& s, T const& a, my_index_sequence<I...>){\n  using swallow = int[];\n  (void)swallow{0, (void(s << (I == 0? \"\" : \", \") << get<I>(a)), 0)...};\n}\n\ntemplate<class T>\nostream& print_collection(ostream& s, T const& a);\ntemplate<class... A>\nostream& operator<<(ostream& s, tpl<A...> const& a);\ntemplate<class... A>\nostream& operator<<(ostream& s, tuple<A...> const& a);\ntemplate<class A, class B>\nostream& operator<<(ostream& s, pair<A, B> const& a);\n\ntemplate<class T, size_t I>\nostream& operator<<(ostream& s, array<T, I> const& a) { return print_collection(s, a); }\ntemplate<class T>\nostream& operator<<(ostream& s, vector<T> const& a) { return print_collection(s, a); }\ntemplate<class T, class U>\nostream& operator<<(ostream& s, multimap<T, U> const& a) { return print_collection(s, a); }\ntemplate<class T>\nostream& operator<<(ostream& s, multiset<T> const& a) { return print_collection(s, a); }\ntemplate<class T, class U>\nostream& operator<<(ostream& s, map<T, U> const& a) { return print_collection(s, a); }\ntemplate<class T>\nostream& operator<<(ostream& s, set<T> const& a) { return print_collection(s, a); }\n\ntemplate<class T>\nostream& print_collection(ostream& s, T const& a){\n  s << '[';\n  for(auto it = begin(a); it != end(a); ++it){\n    s << *it;\n    if(it != prev(end(a))) s << \" \";\n  }\n  return s << ']';\n}\n\ntemplate<class... A>\nostream& operator<<(ostream& s, tpl<A...> const& a){\n  s << '(';\n  print_tuple(s, a, my_index_sequence_for<A...>{});\n  return s << ')';\n}\n\ntemplate<class... A>\nostream& operator<<(ostream& s, tuple<A...> const& a){\n  s << '(';\n  print_tuple(s, a, my_index_sequence_for<A...>{});\n  return s << ')';\n}\n\ntemplate<class A, class B>\nostream& operator<<(ostream& s, pair<A, B> const& a){\n  return s << \"(\" << get<0>(a) << \", \" << get<1>(a) << \")\";\n}\n\n//------------------------------------------------------------------------------\n\nconst lli MOD = 1e9+7;\n\nconst int N = 2e6;\nbool A[N];\nbool B[N];\n\nlli R[100], C[100];\nlli WR[100], WC[100];\nbool E[100][100];\nbool V[100][100];\nlli D[100][100];\n\nconst lli dx[4] = {1,-1,0,0};\nconst lli dy[4] = {0,0,1,-1};\n\nint main(){\n  ios::sync_with_stdio(0); cin.tie(0);\n  lli n,m; cin>>n>>m;\n  vii ps;\n  vvi xs(n), ys(m);\n  lli np; cin>>np;\n  FOR(i,np) {\n    lli x,y; cin>>x>>y;\n    A[x]=1; B[y]=1;\n    xs[x].pb(y); ys[y].pb(x);\n    ps.pb(mt(x,y));\n  }\n  lli tot = (n*m - np) % MOD;\n  lli ans = 0;\n  lli nr = -1, nc = -1;\n  FOR(i,100) WR[i]=WC[i] = -1;\n  { lli l = 0;\n    FOR(i,n) {\n      l %= MOD;\n      if(A[i]) {\n        nr++; R[nr] = 1; WR[nr] = i;\n        l += m - xs[i].size();\n      } else if(i==0 || A[i-1]) {\n        nr++; R[nr] = 1; l += m;\n      } else {\n        R[nr]++;\n        (ans += (l * (tot-l+MOD)) % MOD) %= MOD;\n        l += m;\n      }\n    }\n  }\n  { lli l = 0;\n    FOR(j,m) {\n      l %= MOD;\n      if(B[j]) {\n        nc++; C[nc] = 1; WC[nc] = j;\n        l += n - ys[j].size();\n      } else if(j==0 || B[j-1]) {\n        nc++; C[nc] = 1; l += n;\n      } else {\n        C[nc]++;\n        (ans += (l * (tot-l+MOD)) % MOD) %= MOD;\n        l += n;\n      }\n    }\n  }\n  nr++; nc++;\n  FOR(i,nr) FOR(j,nc) { E[i][j] = 1; for(auto p : ps) if(p == mt(WR[i],WC[j])) E[i][j] = 0; }\n  FOR(i,nr) FOR(j,nc) if(E[i][j]) {\n    FOR(x,nr) FOR(y,nc) { V[x][y] = 0; D[x][y] = (1<<20); }\n    queue<pii> Q; Q.push(mt(i,j)); D[i][j] = 0; V[i][j] = 1;\n    while(!Q.empty()) {\n      lli x,y; tie(x,y) = Q.front(); Q.pop();\n      // cout << mt(i,j) << \" \" << mt(x,y) << \" \" << D[x][y] << endl;\n      if(mt(i,j) < mt(x,y)) (ans += D[x][y] * R[i] % MOD * C[j] % MOD * R[x] % MOD * C[y] % MOD) %= MOD;\n      FOR(d,4) {\n        lli x_ = x+dx[d], y_ = y+dy[d];\n        if(x_<0||x_>=nr||y_<0||y_>=nc) continue;\n        if(!E[x_][y_]) continue;\n        if(V[x_][y_]) continue;\n        V[x_][y_] = 1;\n        D[x_][y_] = D[x][y]+1;\n        Q.push(mt(x_,y_));\n      }\n    }\n  }\n  cout << ans << endl;\n  return 0;\n}\n"
  },
  {
    "language": "C++",
    "code": "#include<iostream>\n#include<cstdio>\n#include<cstdlib>\n#include<cmath>\n#include<cstring>\n#include<algorithm>\n#include<vector>\n#define rep(i,a,b) for(register int i=a;i<=b;i++)\n#define dep(i,a,b) for(register int i=a;i>=b;i--)\n#define ll long long\n#define mem(x,num) memset(x,num,sizeof x)\n#define reg(x) for(int i=last[x];i;i=e[i].next)\nusing namespace std;\ninline ll read(){\n\tll f=1,x=0;char ch=getchar();\n\twhile(ch<'0'||ch>'9'){if(ch=='-')f=-1;ch=getchar();}\n\twhile(ch>='0'&&ch<='9'){x=x*10+ch-'0';ch=getchar();}\n\treturn x*f;\n}\n//**********head by yjjr**********\n#define pb push_back\n#define inf 1e9\nconst int maxn=66,maxm=1e6+6,dx[4]={-1,1,0,0},dy[4]={0,0,-1,1},mod=1e9+7;\nstruct node{int x,y;}a[maxn<<1],que[maxn*maxn*4];\nint n,m,K,ans,lx,ly,cnt[maxn][maxn],s1[maxm],s2[maxm],dis[maxn][maxn],head,tail;\nbool fb[maxn][maxn],mark1[maxm],mark2[maxm];\nvector<int>px,py;\nvoid vnique(vector <int> &r){\n\tsort(r.begin(),r.end());\n\tauto t=unique(r.begin(),r.end());\n\tr.erase(t,r.end());\n}\nvoid bfs(int x,int y){\n\trep(i,0,lx)rep(j,0,ly)dis[i][j]=inf;\n\tdis[x][y]=0;que[head=tail=1]=(node){x,y};\n\twhile(head<=tail){\n\t\tint nx=que[head].x,ny=que[head++].y;\n\t\trep(i,0,3){\n\t\t\tint nex=nx+dx[i],ney=ny+dy[i];\n\t\t\tif(nex>lx||nex<0||ney>ly||ney<0||dis[nex][ney]<=dis[nx][ny]+1||fb[nex][ney])continue;\n\t\t\tdis[nex][ney]=dis[nx][ny]+1;que[++tail]=(node){nex,ney};\n\t\t}\n\t}\n}\nint main()\n{\n\tn=read(),m=read(),K=read();\n\tpx.pb(1);px.pb(n+1);py.pb(1);py.pb(m+1);\n\trep(i,1,n)s1[i]=m;\n\trep(i,1,m)s2[i]=n;\n\trep(i,1,K){\n\t\ta[i].x=read()+1,a[i].y=read()+1;\n\t\tpx.pb(a[i].x),px.pb(a[i].x+1);\n\t\tpy.pb(a[i].y),py.pb(a[i].y+1);\n\t\ts1[a[i].x]--,mark1[a[i].x]=1;\n\t\ts2[a[i].y]--,mark2[a[i].y]=1;\n\t}\n\trep(i,1,n)s1[i]=(s1[i]+s1[i-1])%mod;\n\trep(i,1,m)s2[i]=(s2[i]+s2[i-1])%mod;\n\trep(i,1,n-1)if(!mark1[i]&&!mark1[i+1])ans=(ans+1ll*2*s1[i]*(s1[n]-s1[i]))%mod;\n\trep(i,1,m-1)if(!mark2[i]&&!mark2[i+1])ans=(ans+1ll*2*s2[i]*(s2[m]-s2[i]))%mod;\n\tvnique(px);vnique(py);lx=px.size()-2;ly=py.size()-2;\n\trep(i,1,K)\n\t\tfb[lower_bound(px.begin(),px.end(),a[i].x)-px.begin()][lower_bound(py.begin(),py.end(),a[i].y)-py.begin()]=1;\n\trep(i,0,lx)rep(j,0,ly)cnt[i][j]=1ll*(px[i+1]-px[i])*(py[j+1]-py[j])%mod;\n\trep(i,0,lx)rep(j,0,ly)\n\t\tif(!fb[i][j]){\n\t\t\tbfs(i,j);\n\t\t\trep(k,0,lx)rep(p,0,ly)\n\t\t\t\tif(!fb[k][p])ans=(ans+1ll*cnt[i][j]*dis[k][p]%mod*cnt[k][p])%mod; \n   \t\t}\n\tans=(ans+mod)%mod;ans=1ll*ans*(mod/2+1)%mod;\n\tcout<<ans<<endl;\n\treturn 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\n#define rf(x) (x)=0;while(*p<48)p++;while(47<*p)(x)=((x)<<3)+((x)<<1)+(*p++&15);\n#define pb push_back\n#define eb emplace_back\n#define sz(V) ((int)(V).size())\n#define befv(V) ((V)[(sz(V)-2)])\n#define allv(V) ((V).begin()),((V).end())\n#define sorv(V) sort(allv(V))\n#define revv(V) reverse(allv(V))\n#define univ(V) (V).erase(unique(allv(V)),(V).end())\n#define clv(V) (V).clear()\n#define upmin(a,b) (a)=min((a),(b))\n#define upmax(a,b) (a)=max((a),(b))\n#define rb(x) ((x)&(-(x)))\n#define INF (0x3f3f3f3f)\n#define INFLL (0x3f3f3f3f3f3f3f3fll)\nusing namespace std;\ntypedef long long ll;\ntypedef long double ld;\ntypedef pair<int, int> pii;\nconst int dx[] = {0, 1, 0, -1}, dy[] = {1, 0, -1, 0};\n\nconst int MOD = 1000000007;\nconst int MAXN = 35;\nconst int MAXX = 1000055;\n\ninline void add(int &a, int b) { a += b; if(MOD <= a) a -= MOD; }\n\nvector<pii> YV, XV;\n\nint S[MAXX];\n\nint C[MAXN*2][MAXN*2], D[MAXN*2][MAXN*2];\nint fac[MAXX], rfac[MAXX];\n\nint A[MAXN], B[MAXN];\n\nint H, W, N, Ans;\n\nint pw(int n, int k) {\n\tint r = 1; for(; k; k >>= 1) {\n\t\tif(k & 1) r = ll(r) * n % MOD;\n\t\tn = ll(n) * n % MOD;\n\t}\n\treturn r;\n}\n\nint main() {\n\tios::sync_with_stdio(false);\n\tfac[0] = 1; for(int i = 1; i < MAXX; i++) fac[i] = ll(fac[i-1]) * i % MOD;\n\trfac[MAXX-1] = pw(fac[MAXX-1], MOD-2);\n\tfor(int i = MAXX-1; i; i--) rfac[i-1] = ll(rfac[i]) * i % MOD;\n\n\tcin >> H >> W >> N;\n\tfor(int i = 1; i <= N; i++) {\n\t\tcin >> A[i] >> B[i];\n\t\tA[i]++; B[i]++;\n\t}\n\n\t{\n\t\tvector<int> V;\n\t\tfor(int i = 1; i <= N; i++) V.eb(A[i]);\n\t\tsorv(V); univ(V);\n\n\t\tif(1 < V[0]) YV.eb(1, V[0]-1);\n\t\tfor(int i = 0, n = sz(V); i < n; i++) {\n\t\t\tYV.eb(V[i], V[i]);\n\t\t\tif(i+1 < n && V[i]+1 <= V[i+1]-1)\n\t\t\t\tYV.eb(V[i]+1, V[i+1]-1);\n\t\t}\n\t\tif(V.back() < H) YV.eb(V.back()+1, H);\n\t}\n\t{\n\t\tvector<int> V;\n\t\tfor(int i = 1; i <= N; i++) V.eb(B[i]);\n\t\tsorv(V); univ(V);\n\n\t\tif(1 < V[0]) XV.eb(1, V[0]-1);\n\t\tfor(int i = 0, n = sz(V); i < n; i++) {\n\t\t\tXV.eb(V[i], V[i]);\n\t\t\tif(i+1 < n && V[i]+1 <= V[i+1]-1)\n\t\t\t\tXV.eb(V[i]+1, V[i+1]-1);\n\t\t}\n\t\tif(V.back() < W) XV.eb(V.back()+1, W);\n\t}\n\n\tfor(int i = 1; i <= N; i++) S[A[i]]++;\n\tfor(int i = 1; i <= H; i++) S[i] += S[i-1];\n\tfor(auto &v : YV) {\n\t\tint s, e; tie(s, e) = v;\n\t\tif(s == e) continue;\n\t\tint ret = 0;\n\t\tfor(int i = s; i < e; i++) {\n\t\t\tint lc = (ll(W) * i - S[i]) % MOD;\n\t\t\tint rc = (ll(H) * W - N - lc) % MOD;\n\t\t\tret = (ll(lc) * rc + ret) % MOD;\n\t\t}\n\t\tadd(Ans, ret);\n\t}\n\tfill(S, S+H+1, 0);\n\n\tfor(int i = 1; i <= N; i++) S[B[i]]++;\n\tfor(int i = 1; i <= W; i++) S[i] += S[i-1];\n\tfor(auto &v : XV) {\n\t\tint s, e; tie(s, e) = v;\n\t\tif(s == e) continue;\n\t\tint ret = 0;\n\t\tfor(int i = s; i < e; i++) {\n\t\t\tint lc = (ll(H) * i - S[i]) % MOD;\n\t\t\tint rc = (ll(H) * W - N - lc) % MOD;\n\t\t\tret = (ll(lc) * rc + ret) % MOD;\n\t\t}\n\t\tadd(Ans, ret);\n\t}\n\n\tH = sz(YV); W = sz(XV);\n\tfor(int i = 0; i < H; i++) for(int j = 0; j < W; j++)\n\t\tC[i][j] = ll(YV[i].second - YV[i].first + 1) * (XV[j].second - XV[j].first + 1) % MOD;\n\tfor(int i = 1, y, x; i <= N; i++) {\n\t\ty = int(lower_bound(allv(YV), pii(A[i], A[i])) - YV.begin());\n\t\tx = int(lower_bound(allv(XV), pii(B[i], B[i])) - XV.begin());\n\t\tC[y][x] = 0;\n\t}\n\n\tfor(int i = 0; i < H; i++) for(int j = 0; j < W; j++) if(C[i][j]) {\n\t\tfor(int k = 0; k < H; k++) fill(D[k], D[k]+W, 0);\n\t\tqueue<pii> PQ; D[i][j] = 1; PQ.push(pii(i, j));\n\t\tfor(int y, x, dst; !PQ.empty(); PQ.pop()) {\n\t\t\ttie(y, x) = PQ.front();\n\t\t\tdst = D[y][x] + 1;\n\t\t\tfor(int dr = 0, ny, nx; dr < 4; dr++) {\n\t\t\t\tny = y+dy[dr]; nx = x+dx[dr];\n\t\t\t\tif(ny < 0 || nx < 0 || H <= ny || W <= nx || !C[ny][nx] || D[ny][nx]) continue;\n\t\t\t\tD[ny][nx] = dst;\n\t\t\t\tPQ.push(pii(ny, nx));\n\t\t\t}\n\t\t}\n\n\t\tfor(int y = 0; y < H; y++) for(int x = 0; x < W; x++) {\n\t\t\tint ret = C[i][j];\n\t\t\tret = ll(ret) * C[y][x] % MOD;\n\t\t\tret = ll(ret) * (D[y][x]-1) % MOD;\n\t\t\tret = ll(ret) * rfac[2] % MOD;\n\t\t\tadd(Ans, ret);\n\t\t}\n\t}\n\n\tcout << Ans << endl;\n\treturn 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\n// iostream is too mainstream\n#include <cstdio>\n// bitch please\n#include <iostream>\n#include <algorithm>\n#include <cstdlib>\n#include <vector>\n#include <set>\n#include <map>\n#include <queue>\n#include <stack>\n#include <list>\n#include <cmath>\n#include <iomanip>\n#include <time.h>\n#include <unistd.h>\n#define dibs reserve\n#define OVER9000 1034567890\n#define ALL_THE(CAKE,LIE) for(auto LIE =CAKE.begin(); LIE != CAKE.end(); LIE++)\n#define tisic 47\n#define soclose 1e-8\n#define chocolate win\n// so much chocolate\n#define patkan 9\n#define ff first\n#define ss second\n#define abs(x) ((x < 0)?-(x):x)\n#define uint unsigned int\n#define dbl long double\n#define pi 3.14159265358979323846\nusing namespace std;\n// mylittledoge\n\ntypedef long long cat;\n\n#ifdef DONLINE_JUDGE\n\t// palindromic tree is better than splay tree!\n\t#define lld I64d\n#endif\n\ncat encode(int a, int b, int c) {\n\treturn ((1LL*a)<<40)+((1LL*b)<<20)+c;\n}\n\nint main() {\n\tcin.sync_with_stdio(0);\n\tcin.tie(0);\n\tcout << fixed << setprecision(10);\n\tint H, W, N;\n\tcin >> H >> W >> N;\n\tvector< pair<int, int> > bl(N);\n\tmap<int, int> Mx, My;\n\tMx[0] =Mx[H] =0;\n\tMy[0] =My[W] =0;\n\tfor(int i =0; i < N; i++) {\n\t\tcin >> bl[i].ff >> bl[i].ss;\n\t\tMx[bl[i].ff] =Mx[bl[i].ff+1] =0;\n\t\tMy[bl[i].ss] =My[bl[i].ss+1] =0;\n\t}\n\tint mx =0, my =0;\n\tvector< pair<int,int> > Ix, Iy;\n\tint last =-1;\n\tALL_THE(Mx, it) {\n\t\tit->ss =mx++;\n\t\tif(last >= 0) Ix.push_back(make_pair(last, it->ff));\n\t\tlast =it->ff;\n\t}\n\tlast =-1;\n\tALL_THE(My, it) {\n\t\tit->ss =my++;\n\t\tif(last >= 0) Iy.push_back(make_pair(last, it->ff));\n\t\tlast =it->ff;\n\t}\n\tvector< vector<bool> > BL(mx, vector<bool>(my, 0));\n\tfor(int i =0; i < N; i++) BL[Mx[bl[i].ff]][My[bl[i].ss]] =1;\n\tmx--, my--;\n\n\tcat mod =1000000007;\n\t// sum of Manhattan distances\n\tcat ans =((1LL*(H-1)*H*(H+1)/6)%mod*W%mod*W+(1LL*(W-1)*W*(W+1)/6)%mod*H%mod*H)%mod;\n\tfor(int i =0; i < N; i++) {\n\t\tcat sum =0;\n\t\tsum =(sum+(1LL*bl[i].ff*(bl[i].ff+1)/2+1LL*(H-1-bl[i].ff)*(H-bl[i].ff)/2)%mod*W)%mod;\n\t\tsum =(sum+(1LL*bl[i].ss*(bl[i].ss+1)/2+1LL*(W-1-bl[i].ss)*(W-bl[i].ss)/2)%mod*H)%mod;\n\t\tfor(int j =0; j < N; j++)\n\t\t\tsum -=abs(bl[j].ff-bl[i].ff)+abs(bl[j].ss-bl[i].ss);\n\t\tans =(ans-sum)%mod;\n\t}\n\tfor(int i =0; i < N; i++) for(int j =0; j < i; j++)\n\t\tans -=abs(bl[j].ff-bl[i].ff)+abs(bl[j].ss-bl[i].ss);\n\n\tvector< vector< vector<int> > > Dx(mx, vector< vector<int> >(my, vector<int>(my, OVER9000)));\n\tvector< vector< vector<int> > > Dy(my, vector< vector<int> >(mx, vector<int>(mx, OVER9000)));\n\tpriority_queue< pair<int, cat>, vector< pair<int, cat> >, greater< pair<int, cat> > > qx, qy;\n\tfor(int i =0; i < mx; i++) for(int j =0; j < my; j++) if(!BL[i][j]) {\n\t\tDx[i][j][j] =Dy[j][i][i] =0;\n\t\tqx.push(make_pair(0, encode(i, j, j)));\n\t\tqy.push(make_pair(0, encode(j, i, i)));\n\t}\n\n\twhile(!qx.empty()) {\n\t\tpair<int, cat> p =qx.top();\n\t\tqx.pop();\n\t\tint x =p.ss>>40, y1 =(p.ss>>20)&((1LL<<20)-1), y2 =p.ss&((1LL<<20)-1);\n\t\tif(Dx[x][y1][y2] != p.ff) continue;\n\t\t// +1, in row-direction\n\t\tif(y1 > 0 && !BL[x][y1-1] && Dx[x][y1-1][y2] > Dx[x][y1][y2]) {\n\t\t\tDx[x][y1-1][y2] =Dx[x][y1][y2];\n\t\t\tqx.push(make_pair(Dx[x][y1-1][y2], encode(x, y1-1, y2)));\n\t\t}\n\t\tif(y2+1 < my && !BL[x][y2+1] && Dx[x][y1][y2+1] > Dx[x][y1][y2]) {\n\t\t\tDx[x][y1][y2+1] =Dx[x][y1][y2];\n\t\t\tqx.push(make_pair(Dx[x][y1][y2+1], encode(x, y1, y2+1)));\n\t\t}\n\t\t// -1 in the row-direction\n\t\tif(y1 < y2 && !BL[x][y1+1] && Dx[x][y1+1][y2] > Dx[x][y1][y2]+1) {\n\t\t\tDx[x][y1+1][y2] =Dx[x][y1][y2]+1;\n\t\t\tqx.push(make_pair(Dx[x][y1+1][y2], encode(x, y1+1, y2)));\n\t\t}\n\t\tif(y1 < y2 && !BL[x][y2-1] && Dx[x][y1][y2-1] > Dx[x][y1][y2]+1) {\n\t\t\tDx[x][y1][y2-1] =Dx[x][y1][y2]+1;\n\t\t\tqx.push(make_pair(Dx[x][y1][y2-1], encode(x, y1, y2-1)));\n\t\t}\n\t\t// +1,+1 in the same col-direction\n\t\tif(x > 0 && !BL[x-1][y1] && !BL[x-1][y2] && Dx[x-1][y1][y2] > Dx[x][y1][y2]+1) {\n\t\t\tDx[x-1][y1][y2] =Dx[x][y1][y2]+1;\n\t\t\tqx.push(make_pair(Dx[x-1][y1][y2], encode(x-1, y1, y2)));\n\t\t}\n\t\tif(x+1 < mx && !BL[x+1][y1] && !BL[x+1][y2] && Dx[x+1][y1][y2] > Dx[x][y1][y2]+1) {\n\t\t\tDx[x+1][y1][y2] =Dx[x][y1][y2]+1;\n\t\t\tqx.push(make_pair(Dx[x+1][y1][y2], encode(x+1, y1, y2)));\n\t\t}\n\t}\n\twhile(!qy.empty()) {\n\t\tpair<int, cat> p =qy.top();\n\t\tqy.pop();\n\t\tint y =p.ss>>40, x1 =(p.ss>>20)&((1LL<<20)-1), x2 =p.ss&((1LL<<20)-1);\n\t\tif(Dy[y][x1][x2] != p.ff) continue;\n\t\t// +1, in row-direction\n\t\tif(x1 > 0 && !BL[x1-1][y] && Dy[y][x1-1][x2] > Dy[y][x1][x2]) {\n\t\t\tDy[y][x1-1][x2] =Dy[y][x1][x2];\n\t\t\tqy.push(make_pair(Dy[y][x1-1][x2], encode(y, x1-1, x2)));\n\t\t}\n\t\tif(x2+1 < mx && !BL[x2+1][y] && Dy[y][x1][x2+1] > Dy[y][x1][x2]) {\n\t\t\tDy[y][x1][x2+1] =Dy[y][x1][x2];\n\t\t\tqy.push(make_pair(Dy[y][x1][x2+1], encode(y, x1, x2+1)));\n\t\t}\n\t\t// -1 in the row-direction\n\t\tif(x1 < x2 && !BL[x1+1][y] && Dy[y][x1+1][x2] > Dy[y][x1][x2]+1) {\n\t\t\tDy[y][x1+1][x2] =Dy[y][x1][x2]+1;\n\t\t\tqy.push(make_pair(Dy[y][x1+1][x2], encode(y, x1+1, x2)));\n\t\t}\n\t\tif(x1 < x2 && !BL[x2-1][y] && Dy[y][x1][x2-1] > Dy[y][x1][x2]+1) {\n\t\t\tDy[y][x1][x2-1] =Dy[y][x1][x2]+1;\n\t\t\tqy.push(make_pair(Dy[y][x1][x2-1], encode(y, x1, x2-1)));\n\t\t}\n\t\t// +1,+1 in the same col-direction\n\t\tif(y > 0 && !BL[x1][y-1] && !BL[x2][y-1] && Dy[y-1][x1][x2] > Dy[y][x1][x2]+1) {\n\t\t\tDy[y-1][x1][x2] =Dy[y][x1][x2]+1;\n\t\t\tqy.push(make_pair(Dy[y-1][x1][x2], encode(y-1, x1, x2)));\n\t\t}\n\t\tif(y+1 < my && !BL[x1][y+1] && !BL[x2][y+1] && Dy[y+1][x1][x2] > Dy[y][x1][x2]+1) {\n\t\t\tDy[y+1][x1][x2] =Dy[y][x1][x2]+1;\n\t\t\tqy.push(make_pair(Dy[y+1][x1][x2], encode(y+1, x1, x2)));\n\t\t}\n\t}\n\n\tfor(int x =0; x < mx; x++)\n\t\tfor(int y1 =0; y1 < my; y1++) for(int y2 =0; y2 < y1; y2++)\n\t\t\tDx[x][y1][y2] =Dx[x][y2][y1];\n\tfor(int y =0; y < my; y++)\n\t\tfor(int x1 =0; x1 < mx; x1++) for(int x2 =0; x2 < x1; x2++)\n\t\t\tDy[y][x1][x2] =Dy[y][x2][x1];\n\n\tvector< vector<int> > D(mx*my, vector<int>(mx*my, OVER9000));\n\tfor(int i =0; i < mx; i++) for(int j =0; j < my; j++) if(!BL[i][j]) {\n\t\tD[i*my+j][i*my+j] =0;\n\t\tfor(int k =0; k < mx; k++) if(!BL[k][j])\n\t\t\tD[i*my+j][k*my+j] =D[k*my+j][i*my+j] =2*Dy[j][i][k]+abs(i-k);\n\t\tfor(int k =0; k < my; k++) if(!BL[i][k])\n\t\t\tD[i*my+j][i*my+k] =D[i*my+k][i*my+j] =2*Dx[i][j][k]+abs(j-k);\n\t}\n\n\t// Dijkstra from everywhere\n\tpriority_queue< pair<int, int>, vector< pair<int, int> >, greater< pair<int, int> > > q;\n\tvector<bool> vis(mx*my);\n\tfor(int i =0; i < mx*my; i++) if(!BL[i/my][i%my]) {\n\t\tfor(int j =0; j < mx*my; j++) vis[j] =0;\n\t\tvis[i] =1;\n\t\tq.push(make_pair(0, i));\n\t\twhile(!q.empty()) {\n\t\t\tpair<int, int> p =q.top();\n\t\t\tq.pop();\n\t\t\tif(D[i][p.ss] != p.ff) continue;\n\t\t\tfor(int x =0; x < mx; x++) if(D[i][x*my+(p.ss%my)] > p.ff+D[p.ss][x*my+(p.ss%my)] || !vis[x*my+(p.ss%my)]) {\n\t\t\t\tvis[x*my+(p.ss%my)] =1;\n\t\t\t\tD[i][x*my+(p.ss%my)] =D[x*my+(p.ss%my)][i] =min(D[i][x*my+(p.ss%my)], p.ff+D[p.ss][x*my+(p.ss%my)]);\n\t\t\t\tq.push(make_pair(D[i][x*my+(p.ss%my)], x*my+(p.ss%my)));\n\t\t\t}\n\t\t\tfor(int y =0; y < my; y++) if(D[i][(p.ss/my)*my+y] > p.ff+D[p.ss][(p.ss/my)*my+y] || !vis[(p.ss/my)*my+y]) {\n\t\t\t\tvis[(p.ss/my)*my+y] =1;\n\t\t\t\tD[i][(p.ss/my)*my+y] =D[(p.ss/my)*my+y][i] =min(D[i][(p.ss/my)*my+y], p.ff+D[p.ss][(p.ss/my)*my+y]);\n\t\t\t\tq.push(make_pair(D[i][(p.ss/my)*my+y], (p.ss/my)*my+y));\n\t\t\t}\n\t\t}\n//\t\tfor(int j =0; j < mx*my; j++) for(int k =0; k < mx*my; k++)\n//\t\t\tif(D[j][k] > D[j][i]+D[i][k]) D[j][k] =D[j][i]+D[i][k];\n\t}\n\n\tfor(int x1 =0; x1 < mx; x1++) for(int y1 =0; y1 < my; y1++)\n\t\tfor(int x2 =0; x2 <= x1; x2++) for(int y2 =0; y2 < my; y2++) {\n\t\t\tif(x2 == x1 && y2 >= y1) continue;\n\t\t\tif(D[x1*my+y1][x2*my+y2] == OVER9000) continue;\n\t\t\tcat cnt1 =1LL*(Ix[x1].ss-Ix[x1].ff)*(Iy[y1].ss-Iy[y1].ff)%mod;\n\t\t\tcat cnt2 =1LL*(Ix[x2].ss-Ix[x2].ff)*(Iy[y2].ss-Iy[y2].ff)%mod;\n\t\t\tans =(ans+(cnt1*cnt2)%mod*(D[x1*my+y1][x2*my+y2]-abs(x1-x2)-abs(y1-y2)))%mod;\n\t\t}\n\n\tans %=mod;\n\tif(ans < 0) ans +=mod;\n\tcout << ans << \"\\n\";\n\treturn 0;}\n\n// look at my code\n// my code is amazing\n"
  },
  {
    "language": "C++",
    "code": "#include<bits/stdc++.h>\nusing namespace std;\n#define int long long \n#define mod 1000000007\n#define nn 65536*16\nint bx[nn],by[nn],bbx[nn],bby[nn];\nint cntx[nn],cnty[nn];\nint n,m,k;\nstruct asfdgt{\n\tint tree[nn];\n\tvoid add(int x,int y){\n\t\tfor(;x<nn;x+=x&-x) tree[x]=(tree[x]+y)%mod;\n\t}\n\tint ask(int x){\n\t\tint y=0;for(;x;x-=x&-x) y=(y+tree[x])%mod;return y;\n\t}\n\tint ask(int l,int r){\n\t\treturn ask(r)-ask(l-1);\n\t}\n}bitx,bity;\n\nvector<int> vx,vy;\n\n#undef nn \n#define nn 102\nint dp[nn][nn],black[nn][nn];\nint ax[]={1,-1,0,0},ay[]={0,0,-1,1};\nvoid bfs(int x,int y){\n\tmemset(dp,0x3f,sizeof dp);\n\tqueue<int> qx,qy;dp[x][y]=0;qx.push(x);qy.push(y);\n\twhile(qx.size()){\n\t\tx=qx.front();qx.pop();\n\t\ty=qy.front();qy.pop();\n\t\t\n\t\tfor(int i=0;i<4;i++) {\n\t\t\tint xx=x+ax[i],yy=y+ay[i];\n\t\t\tif(xx>=1 and yy>=1 and xx<=n and yy<=m and dp[xx][yy]>dp[x][y]+1 and !black[xx][yy])\n\t\t\t\tdp[xx][yy]=dp[x][y]+1,qx.push(xx),qy.push(yy);\n\t\t}\n\t}\n}\n\nint find(int x,vector<int>&v){\n\treturn lower_bound(v.begin(),v.end(),x)-v.begin()+1;\n}\nint adx[1000008],ady[1000008],fun[nn][nn];\nsigned main(){\n\tscanf(\"%d%d%d\",&n,&m,&k);\n\tfor(int i=1;i<=n;i++) bitx.add(i,m),adx[i]=1;\n\tfor(int i=1;i<=m;i++) bity.add(i,n),ady[i]=1;\n\t\n\tfor(int i=1;i<=k;i++) scanf(\"%d%d\",&bx[i],&by[i]),bx[i]++,by[i]++,bitx.add(bx[i],-1),bity.add(by[i],-1),bbx[bx[i]]=bby[by[i]]=1;\n//\tmemset(bbx,1,sizeof bbx);memset(bby,1,sizeof bby);\n\tint ans=0;\n\tfor(int i=1;i<=n;i++){\n\t\tint j=i+1;while(j<=n){\n\t\t\tif(!bbx[i] and !bbx[j]){\n\t\t\t\tadx[i]+=adx[j];\n\t\t\t\tans+=bitx.ask(1,j-1)*bitx.ask(j,n)%mod;ans%=mod;\n\t\t\t\tj++;\n\t\t\t}\n\t\t\telse break;\n\t\t}\n\t\tvx.push_back(i);\n\t\ti=j-1;\n\t}\n\t\n\tfor(int i=1;i<=m;i++){\n\t\tint j=i+1;while(j<=m){\n\t\t\tif(!bby[i] and !bby[j]){\n\t\t\t\tady[i]+=ady[j];\n\t\t\t\tans+=bity.ask(1,j-1)*bity.ask(j,m)%mod;ans%=mod;\n\t\t\t\tj++;\n\t\t\t}\n\t\t\telse break;\n\t\t}\n\t\tvy.push_back(i);\n\t\ti=j-1;\n\t}\n\t\n\t\n\tans*=2;//cout<<ans;\n\tfor(int i=1;i<=k;i++) black[find(bx[i],vx)][find(by[i],vy)]=1;\n\tn=vx.size(),m=vy.size();\n\tfor(int i=1;i<=n;i++) for(int j=1;j<=m;j++) fun[i][j]=adx[vx[i-1]]*ady[vy[j-1]]%mod;\n\tfor(int i=1;i<=vx.size();i++) for(int j=1;j<=vy.size();j++)if(!black[i][j]){\n\t\tbfs(i,j);\n\t\tfor(int x=1;x<=vx.size();x++) for(int y=1;y<=vy.size();y++) if(!black[x][y]) ans=(ans+dp[x][y]*fun[i][j]%mod*fun[x][y])%mod;\n\t//\tcout<<i<<\" \"<<j<<\":\"<<ans<<\"\\n\";\n\t}\n\t\n\t\n\tprintf(\"%lld\\n\",(ans%mod*(mod+1)/2%mod+mod)%mod);\n\treturn 0;\n} "
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\n// iostream is too mainstream\n#include <cstdio>\n// bitch please\n#include <iostream>\n#include <algorithm>\n#include <cstdlib>\n#include <vector>\n#include <set>\n#include <map>\n#include <queue>\n#include <stack>\n#include <list>\n#include <cmath>\n#include <iomanip>\n#include <time.h>\n#include <unistd.h>\n#define dibs reserve\n#define OVER9000 1034567890\n#define ALL_THE(CAKE,LIE) for(auto LIE =CAKE.begin(); LIE != CAKE.end(); LIE++)\n#define tisic 47\n#define soclose 1e-8\n#define chocolate win\n// so much chocolate\n#define patkan 9\n#define ff first\n#define ss second\n#define abs(x) ((x < 0)?-(x):x)\n#define uint unsigned int\n#define dbl long double\n#define pi 3.14159265358979323846\nusing namespace std;\n// mylittledoge\n\ntypedef long long cat;\n\n#ifdef DONLINE_JUDGE\n\t// palindromic tree is better than splay tree!\n\t#define lld I64d\n#endif\n\ncat encode(int a, int b, int c) {\n\treturn ((1LL*a)<<40)+((1LL*b)<<20)+c;\n}\n\nint main() {\n\tcin.sync_with_stdio(0);\n\tcin.tie(0);\n\tcout << fixed << setprecision(10);\n\tint H, W, N;\n\tcin >> H >> W >> N;\n\tvector< pair<int, int> > bl(N);\n\tmap<int, int> Mx, My;\n\tMx[0] =Mx[H] =0;\n\tMy[0] =My[W] =0;\n\tfor(int i =0; i < N; i++) {\n\t\tcin >> bl[i].ff >> bl[i].ss;\n\t\tMx[bl[i].ff] =Mx[bl[i].ff+1] =0;\n\t\tMy[bl[i].ss] =My[bl[i].ss+1] =0;\n\t}\n\tint mx =0, my =0;\n\tvector< pair<int,int> > Ix, Iy;\n\tint last =-1;\n\tALL_THE(Mx, it) {\n\t\tit->ss =mx++;\n\t\tif(last >= 0) Ix.push_back(make_pair(last, it->ff));\n\t\tlast =it->ff;\n\t}\n\tlast =-1;\n\tALL_THE(My, it) {\n\t\tit->ss =my++;\n\t\tif(last >= 0) Iy.push_back(make_pair(last, it->ff));\n\t\tlast =it->ff;\n\t}\n\tvector< vector<bool> > BL(mx, vector<bool>(my, 0));\n\tfor(int i =0; i < N; i++) BL[Mx[bl[i].ff]][My[bl[i].ss]] =1;\n\tmx--, my--;\n\n\tcat mod =1000000007;\n\t// sum of Manhattan distances\n\tcat ans =((1LL*(H-1)*H*(H+1)/6)%mod*W%mod*W+(1LL*(W-1)*W*(W+1)/6)%mod*H%mod*H)%mod;\n\tfor(int i =0; i < N; i++) {\n\t\tcat sum =0;\n\t\tsum =(sum+(1LL*bl[i].ff*(bl[i].ff+1)/2+1LL*(H-1-bl[i].ff)*(H-bl[i].ff)/2)%mod*W)%mod;\n\t\tsum =(sum+(1LL*bl[i].ss*(bl[i].ss+1)/2+1LL*(W-1-bl[i].ss)*(W-bl[i].ss)/2)%mod*H)%mod;\n\t\tfor(int j =0; j < N; j++)\n\t\t\tsum -=abs(bl[j].ff-bl[i].ff)+abs(bl[j].ss-bl[i].ss);\n\t\tans =(ans-sum)%mod;\n\t}\n\tfor(int i =0; i < N; i++) for(int j =0; j < i; j++)\n\t\tans -=abs(bl[j].ff-bl[i].ff)+abs(bl[j].ss-bl[i].ss);\n\n\tvector< vector< vector<int> > > Dx(mx, vector< vector<int> >(my, vector<int>(my, OVER9000)));\n\tvector< vector< vector<int> > > Dy(my, vector< vector<int> >(mx, vector<int>(mx, OVER9000)));\n\tpriority_queue< pair<int, cat>, vector< pair<int, cat> >, greater< pair<int, cat> > > qx, qy;\n\tfor(int i =0; i < mx; i++) for(int j =0; j < my; j++) if(!BL[i][j]) {\n\t\tDx[i][j][j] =Dy[j][i][i] =0;\n\t\tqx.push(make_pair(0, encode(i, j, j)));\n\t\tqy.push(make_pair(0, encode(j, i, i)));\n\t}\n\n\twhile(!qx.empty()) {\n\t\tpair<int, cat> p =qx.top();\n\t\tqx.pop();\n\t\tint x =p.ss>>40, y1 =(p.ss>>20)&((1LL<<20)-1), y2 =p.ss&((1LL<<20)-1);\n\t\tif(Dx[x][y1][y2] != p.ff) continue;\n\t\t// +1, in row-direction\n\t\tif(y1 > 0 && !BL[x][y1-1] && Dx[x][y1-1][y2] > Dx[x][y1][y2]) {\n\t\t\tDx[x][y1-1][y2] =Dx[x][y1][y2];\n\t\t\tqx.push(make_pair(Dx[x][y1-1][y2], encode(x, y1-1, y2)));\n\t\t}\n\t\tif(y2+1 < my && !BL[x][y2+1] && Dx[x][y1][y2+1] > Dx[x][y1][y2]) {\n\t\t\tDx[x][y1][y2+1] =Dx[x][y1][y2];\n\t\t\tqx.push(make_pair(Dx[x][y1][y2+1], encode(x, y1, y2+1)));\n\t\t}\n\t\t// -1 in the row-direction\n\t\tif(y1 < y2 && !BL[x][y1+1] && Dx[x][y1+1][y2] > Dx[x][y1][y2]+1) {\n\t\t\tDx[x][y1+1][y2] =Dx[x][y1][y2]+1;\n\t\t\tqx.push(make_pair(Dx[x][y1+1][y2], encode(x, y1+1, y2)));\n\t\t}\n\t\tif(y1 < y2 && !BL[x][y2-1] && Dx[x][y1][y2-1] > Dx[x][y1][y2]+1) {\n\t\t\tDx[x][y1][y2-1] =Dx[x][y1][y2]+1;\n\t\t\tqx.push(make_pair(Dx[x][y1][y2-1], encode(x, y1, y2-1)));\n\t\t}\n\t\t// +1,+1 in the same col-direction\n\t\tif(x > 0 && !BL[x-1][y1] && !BL[x-1][y2] && Dx[x-1][y1][y2] > Dx[x][y1][y2]+1) {\n\t\t\tDx[x-1][y1][y2] =Dx[x][y1][y2]+1;\n\t\t\tqx.push(make_pair(Dx[x-1][y1][y2], encode(x-1, y1, y2)));\n\t\t}\n\t\tif(x+1 < mx && !BL[x+1][y1] && !BL[x+1][y2] && Dx[x+1][y1][y2] > Dx[x][y1][y2]+1) {\n\t\t\tDx[x+1][y1][y2] =Dx[x][y1][y2]+1;\n\t\t\tqx.push(make_pair(Dx[x+1][y1][y2], encode(x+1, y1, y2)));\n\t\t}\n\t}\n\twhile(!qy.empty()) {\n\t\tpair<int, cat> p =qy.top();\n\t\tqy.pop();\n\t\tint y =p.ss>>40, x1 =(p.ss>>20)&((1LL<<20)-1), x2 =p.ss&((1LL<<20)-1);\n\t\tif(Dy[y][x1][x2] != p.ff) continue;\n\t\t// +1, in row-direction\n\t\tif(x1 > 0 && !BL[x1-1][y] && Dy[y][x1-1][x2] > Dy[y][x1][x2]) {\n\t\t\tDy[y][x1-1][x2] =Dy[y][x1][x2];\n\t\t\tqy.push(make_pair(Dy[y][x1-1][x2], encode(y, x1-1, x2)));\n\t\t}\n\t\tif(x2+1 < mx && !BL[x2+1][y] && Dy[y][x1][x2+1] > Dy[y][x1][x2]) {\n\t\t\tDy[y][x1][x2+1] =Dy[y][x1][x2];\n\t\t\tqy.push(make_pair(Dy[y][x1][x2+1], encode(y, x1, x2+1)));\n\t\t}\n\t\t// -1 in the row-direction\n\t\tif(x1 < x2 && !BL[x1+1][y] && Dy[y][x1+1][x2] > Dy[y][x1][x2]+1) {\n\t\t\tDy[y][x1+1][x2] =Dy[y][x1][x2]+1;\n\t\t\tqy.push(make_pair(Dy[y][x1+1][x2], encode(y, x1+1, x2)));\n\t\t}\n\t\tif(x1 < x2 && !BL[x2-1][y] && Dy[y][x1][x2-1] > Dy[y][x1][x2]+1) {\n\t\t\tDy[y][x1][x2-1] =Dy[y][x1][x2]+1;\n\t\t\tqy.push(make_pair(Dy[y][x1][x2-1], encode(y, x1, x2-1)));\n\t\t}\n\t\t// +1,+1 in the same col-direction\n\t\tif(y > 0 && !BL[x1][y-1] && !BL[x2][y-1] && Dy[y-1][x1][x2] > Dy[y][x1][x2]+1) {\n\t\t\tDy[y-1][x1][x2] =Dy[y][x1][x2]+1;\n\t\t\tqy.push(make_pair(Dy[y-1][x1][x2], encode(y-1, x1, x2)));\n\t\t}\n\t\tif(y+1 < my && !BL[x1][y+1] && !BL[x2][y+1] && Dy[y+1][x1][x2] > Dy[y][x1][x2]+1) {\n\t\t\tDy[y+1][x1][x2] =Dy[y][x1][x2]+1;\n\t\t\tqy.push(make_pair(Dy[y+1][x1][x2], encode(y+1, x1, x2)));\n\t\t}\n\t}\n\n\tfor(int x =0; x < mx; x++)\n\t\tfor(int y1 =0; y1 < my; y1++) for(int y2 =0; y2 < y1; y2++)\n\t\t\tDx[x][y1][y2] =Dx[x][y2][y1];\n\tfor(int y =0; y < my; y++)\n\t\tfor(int x1 =0; x1 < mx; x1++) for(int x2 =0; x2 < x1; x2++)\n\t\t\tDy[y][x1][x2] =Dy[y][x2][x1];\n\n\tvector< vector<int> > D(mx*my, vector<int>(mx*my, OVER9000));\n\tfor(int i =0; i < mx; i++) for(int j =0; j < my; j++) if(!BL[i][j]) {\n\t\tD[i*my+j][i*my+j] =0;\n\t\tfor(int k =0; k < mx; k++) if(!BL[k][j])\n\t\t\tD[i*my+j][k*my+j] =D[k*my+j][i*my+j] =2*Dy[j][i][k]+abs(i-k);\n\t\tfor(int k =0; k < my; k++) if(!BL[i][k])\n\t\t\tD[i*my+j][i*my+k] =D[i*my+k][i*my+j] =2*Dx[i][j][k]+abs(j-k);\n\t}\n\n\tfor(int i =0; i < mx*my; i++)\n\t\tfor(int j =0; j < mx*my; j++) for(int k =0; k < mx*my; k++)\n\t\t\tif(D[j][k] > D[j][i]+D[i][k]) D[j][k] =D[j][i]+D[i][k];\n\n\tfor(int x1 =0; x1 < mx; x1++) for(int y1 =0; y1 < my; y1++)\n\t\tfor(int x2 =0; x2 <= x1; x2++) for(int y2 =0; y2 < my; y2++) {\n\t\t\tif(x2 == x1 && y2 >= y1) continue;\n\t\t\tif(D[x1*my+y1][x2*my+y2] == OVER9000) continue;\n\t\t\tcat cnt1 =1LL*(Ix[x1].ss-Ix[x1].ff)*(Iy[y1].ss-Iy[y1].ff)%mod;\n\t\t\tcat cnt2 =1LL*(Ix[x2].ss-Ix[x2].ff)*(Iy[y2].ss-Iy[y2].ff)%mod;\n\t\t\tans =(ans+(cnt1*cnt2)%mod*(D[x1*my+y1][x2*my+y2]-abs(x1-x2)-abs(y1-y2)))%mod;\n\t\t}\n\n\tans %=mod;\n\tif(ans < 0) ans +=mod;\n\tcout << ans << \"\\n\";\n\treturn 0;}\n\n// look at my code\n// my code is amazing\n"
  },
  {
    "language": "C++",
    "code": "#include <iostream>\n#include <vector>\n#include <map>\n#include <queue>\n#include <algorithm>\n#include <cstring>\nusing namespace std;\n\n#define REP(i, s) for (int i = 0; i < s; ++i)\n#define ALL(v) (v.begin(), v.end())\n#define COUT(x) cout << #x << \" = \" << (x) << \" (L\" << __LINE__ << \")\" << endl\n#define EACH(i, s) for (__typeof__((s).begin()) i = (s).begin(); i != (s).end(); ++i)\n\ntemplate<class T> inline bool chmax(T& a, T b) { if (a < b) { a = b; return 1; } return 0; }\ntemplate<class T> inline bool chmin(T& a, T b) { if (a > b) { a = b; return 1; } return 0; }\ntemplate<class T1, class T2> ostream& operator << (ostream &s, pair<T1, T2> P)\n{\n\treturn s << '<' << P.first << \", \" << P.second << '>';\n}\ntemplate<class T> ostream& operator << (ostream &s, vector<T> P)\n{\n\tfor (int i = 0; i < P.size(); ++i) { if (i > 0) { s << \" \"; } s << P[i]; } return s;\n}\ntemplate<class T> ostream& operator << (ostream &s, vector<vector<T> > P)\n{\n\tfor (int i = 0; i < P.size(); ++i) { s << endl << P[i]; } return s << endl;\n}\n\n\ninline long long mod(long long a, long long m) { return (a % m + m) % m; }\nstruct Fp {\n\tint MOD = 1000000007;\n\tlong long val;\n\n\tFp() : val(0) {}\n\tFp(long long val_) { this->val = mod(val_, MOD); }\n\tFp operator = (long long val_) { this->val = mod(val_, MOD); return *this; }\n\tinline Fp operator - () { return mod(-val, MOD); }\n\tinline const Fp& operator += (const Fp &x);\n\tinline const Fp& operator -= (const Fp &x);\n\tinline const Fp& operator *= (const Fp &x);\n\tinline const Fp& operator /= (const Fp &x);\n};\n\ninline bool operator == (Fp x, Fp y) { return x.val == y.val; }\ninline bool operator != (Fp x, Fp y) { return !(x == y); }\n\nostream &operator << (ostream &os, Fp x) { return os << x.val; }\nistream &operator >> (istream &is, Fp &x) { is >> x; return is; }\n\ninline Fp operator + (Fp x, Fp y) { return mod(x.val + y.val, x.MOD); }\ninline Fp operator - (Fp x, Fp y) { return mod(x.val - y.val, x.MOD); }\ninline Fp operator * (Fp x, Fp y) { return mod(x.val * y.val, x.MOD); }\ninline Fp operator / (Fp x, Fp y) {\n\tlong long a = y.val, b = x.MOD, u = 1, v = 0;\n\twhile (b) {\n\t\tlong long t = a / b;\n\t\ta -= t*b; swap(a, b);\n\t\tu -= t*v; swap(u, v);\n\t}\n\treturn x * u;\n}\ninline Fp abs(Fp a) { return a; }\ninline Fp fpow(Fp a, long long n) {\n\tif (n == 0) return Fp(1);\n\tFp t = fpow(a, n / 2);\n\tt = t * t; if (n & 1) t = t * a;\n\treturn t;\n}\ninline const Fp& Fp::operator += (const Fp &x) { *this = *this + x; return *this; }\ninline const Fp& Fp::operator -= (const Fp &x) { *this = *this - x; return *this; }\ninline const Fp& Fp::operator *= (const Fp &x) { *this = *this * x; return *this; }\ninline const Fp& Fp::operator /= (const Fp &x) { *this = *this / x; return *this; }\n\n// calc comb (small n, r ver)\nconst int FACT_MAX = 210000;\nstatic Fp fp_fact_val[FACT_MAX];\n\nvoid calcFact(int MAX = FACT_MAX) {\n\tfp_fact_val[0] = 1;\n\tfor (int val = 1; val < MAX; ++val) {\n\t\tfp_fact_val[val] = fp_fact_val[val - 1] * val;\n\t}\n}\n\nFp fact(int n) {\n\treturn fp_fact_val[n];\n}\n\nFp com(int n, int r) {\n\treturn fact(n) / fact(r) / fact(n - r);\n}\n\nint dx[4] = {1, 0, -1, 0};\nint dy[4] = {0, 1, 0, -1};\n\nlong long H, W, N;\nlong long bx[210], by[210];\nvector<long long> altx, alty;\nlong long nH, nW;\n\nlong long xnum[1100000], ynum[1100000];\n\nbool cb[210][210];\n\ntypedef pair<int, int> pint;\nFp subsolve() {\n\t//COUT(nH); COUT(nW); COUT(altx); COUT(alty);\n  Fp res = 0;\n\tfor (int x = 0; x < nH - 1; ++x) {\n\t\tfor (int y = 0; y < nW - 1; ++y) {\n\t\t\t//cout << cb[x][y];\n\t\t\tif (cb[x][y]) continue;\n\n\t\t\tint dist[210][210];\n\t\t\tmemset(dist, -1, sizeof(dist));\n\t\t\tqueue<pint> que;\n\t\t\tque.push(pint(x, y));\n\t\t\tdist[x][y] = 0;\n\t\t\twhile (!que.empty()) {\n\t\t\t\tpint cur = que.front();\n\t\t\t\tque.pop();\n\t\t\t\tfor (int dir = 0; dir < 4; ++dir) {\n\t\t\t\t\tint nx = cur.first + dx[dir];\n\t\t\t\t\tint ny = cur.second + dy[dir];\n\t\t\t\t\tif (nx < 0 || nx >= H || ny < 0 || ny >= W) continue;\n\t\t\t\t\tif (cb[nx][ny]) continue;\n\t\t\t\t\tif (dist[nx][ny] == -1) {\n\t\t\t\t\t\tdist[nx][ny] = dist[cur.first][cur.second] + 1;\n\t\t\t\t\t\tque.push(pint(nx, ny));\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t}\n\t\t\tfor (int nx = 0; nx < nH - 1; ++nx) {\n\t\t\t\tfor (int ny = 0; ny < nW - 1; ++ny) {\n\t\t\t\t\tif (dist[nx][ny] == -1) continue;\n\t\t\t\t\tif (cb[nx][ny]) continue;\n\n\t\t\t\t\tFp ss = (altx[x + 1] - altx[x]) * (alty[y + 1] - alty[y]);\n\t\t\t\t\tFp st = (altx[nx + 1] - altx[nx]) * (alty[ny + 1] - alty[ny]);\n\t\t\t\t\tres += Fp(dist[nx][ny]) * ss * st;\n\n\t\t\t\t\t//cout << pint(x, y) << \", \" << pint(nx, ny) << \": \" << dist[nx][ny] << \", \" << ss << \", \" << st << endl;\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t\t//cout << endl;\n\t}\n\t//COUT(res);\n\tres /= 2;\n\n\treturn res;\n}\n\nFp solve() {\n  memset(xnum, 0, sizeof(xnum));\n  memset(ynum, 0, sizeof(ynum));\n\taltx.clear();\n\talty.clear();\n  altx.push_back(0);\n  altx.push_back(H);\n  alty.push_back(0);\n  alty.push_back(W);\n  for (int i = 0; i < N; ++i) {\n\t\taltx.push_back(bx[i]);\n\t\taltx.push_back(bx[i] + 1);\n\t\talty.push_back(by[i]);\n\t\talty.push_back(by[i] + 1);\n\t\txnum[bx[i]]++;\n\t\tynum[by[i]]++;\n  }\n  sort(altx.begin(), altx.end());\n  sort(alty.begin(), alty.end());\n  altx.erase(unique(altx.begin(), altx.end()), altx.end());\n  alty.erase(unique(alty.begin(), alty.end()), alty.end());\n  nH = altx.size();\n  nW = alty.size();\n\n  memset(cb, 0, sizeof(cb));\n  for (int i = 0; i < N; ++i) {\n\t\tint itx = lower_bound(altx.begin(), altx.end(), bx[i]) - altx.begin();\n\t\tint ity = lower_bound(alty.begin(), alty.end(), by[i]) - alty.begin();\n\t\tcb[itx][ity] = true;\n  }\n\n  long long all = (long long)H * W - N;\n  Fp add = 0;\n  long long width = W;\n  int num_comped = 0;\n  long long sum = width - xnum[0];\n  for (int i = 1; i < H; ++i) {\n\t\tif (xnum[i] == 0 && xnum[i-1] == 0) {   // i-1 -> i\n\t\t\tFp up = sum - width * num_comped;\n\t\t\tFp down = all - sum;\n\t\t\tadd += up * down;\n\t\t}\n\t\tsum += width - xnum[i];\n  }\n  long long height = H - num_comped;\n  all -= width * num_comped;\n  num_comped = 0;\n  sum = height - ynum[0];\n  for (int i = 1; i < W; ++i) {\n\t\tif (ynum[i] == 0 && ynum[i-1] == 0) {   // i-1 -> i\n\t\t\tFp left = sum - height * num_comped;\n\t\t\tFp right = all - sum;\n\t\t\tadd += left * right;\n\t\t}\n\t\tsum += height - ynum[i];\n  }\n\n  Fp comp = subsolve();\n  Fp res = comp + add;\n\n\t//COUT(add);\n\n  return res;\n}\n\nint main() {\n  while (cin >> H >> W >> N) {\n\t\tfor (int i = 0; i < N; ++i) cin >> bx[i] >> by[i];\n\t\tcout << solve() << endl;\n  }\n}\n"
  },
  {
    "language": "C++",
    "code": "#include<bits/stdc++.h>\n#define rep(i,a,b) for(int i=(a);i<=(b);i++)\n#define per(i,a,b) for(int i=(a);i>=(b);i--)\n#define REP(i,n) for(int i=0;i<(n);i++)\n#define fi first\n#define se second\n#define pb push_back\n#define mp make_pair\nusing namespace std;\ntypedef pair<int,int> pii;\ntypedef vector<int> vi;\ntypedef long long ll;\n\ntemplate<class T> void read(T &x){\n\tint f=0; x=0; char ch=getchar();\n\tfor(;!isdigit(ch);ch=getchar()) f|=(ch=='-');\n\tfor(;isdigit(ch);ch=getchar()) x=x*10+ch-'0';\n\tif(f) x=-x;\n}\n\nconst int dx[4]={-1,1,0,0},dy[4]={0,0,-1,1};\nconst int N=105,mod=1e9+7,inv2=(mod+1)/2;\nint xx[N],yy[N],x[N],y[N],w[N][N],d[N][N],q[N*N][2];\nint H,W,n,m,cnt,ans;\n\nint S2(int n){\n\treturn (ll)n*(n+1)/2%mod;\n}\n\nint main(){\n\tread(H),read(W),read(cnt);\n\txx[++n]=1,xx[++n]=H+1,yy[++m]=1,yy[++m]=W+1;\n\trep(i,1,cnt){\n\t\tread(x[i]),read(y[i]),x[i]++,y[i]++;\n\t\txx[++n]=x[i],xx[++n]=x[i]+1;\n\t\tyy[++m]=y[i],yy[++m]=y[i]+1;\n\t}\n\tsort(xx+1,xx+n+1),n=unique(xx+1,xx+n+1)-xx-1;\n\tsort(yy+1,yy+m+1),m=unique(yy+1,yy+m+1)-yy-1;\n\trep(i,1,n-1) rep(j,1,m-1){\n\t\tw[i][j]=(ll)(xx[i+1]-xx[i])*(yy[j+1]-yy[j])%mod;\n\t}\n\trep(i,1,cnt){\n\t\tx[i]=lower_bound(xx+1,xx+n+1,x[i])-xx;\n\t\ty[i]=lower_bound(yy+1,yy+n+1,y[i])-yy;\n\t\tw[x[i]][y[i]]=0;\n\t}\n\trep(k,1,n-1) if(xx[k+1]-xx[k]>=2){\n\t\tint up=0,down=0;\n\t\trep(i,1,n-1) rep(j,1,m-1){\n\t\t\tif(i<k) up=(up+w[i][j])%mod;\n\t\t\tif(i>k) down=(down+w[i][j])%mod;\n\t\t}\n\t\tans=(ans+(ll)up*down%mod*(xx[k+1]-xx[k]-1))%mod;\n\t\tans=(ans+(ll)(up+down)*W%mod*S2(xx[k+1]-xx[k]-1))%mod;\n\t\tint sum=0;\n\t\trep(i,1,xx[k+1]-xx[k]-1) sum=(sum+(ll)i*(xx[k+1]-xx[k]-i))%mod;\n\t\tans=(ans+(ll)W*W%mod*sum)%mod;\n\t}\n\trep(k,1,m-1) if(yy[k+1]-yy[k]>=2){\n\t\tint le=0,ri=0;\n\t\trep(i,1,n-1) rep(j,1,m-1){\n\t\t\tif(j<k) le=(le+w[i][j])%mod;\n\t\t\tif(j>k) ri=(ri+w[i][j])%mod;\n\t\t}\n\t\tans=(ans+(ll)le*ri%mod*(yy[k+1]-yy[k]-1))%mod;\n\t\tans=(ans+(ll)(le+ri)*H%mod*S2(yy[k+1]-yy[k]-1))%mod;\n\t\tint sum=0;\n\t\trep(i,1,yy[k+1]-yy[k]-1) sum=(sum+(ll)i*(yy[k+1]-yy[k]-i))%mod;\n\t\tans=(ans+(ll)H*H%mod*sum)%mod;\n\t}\n\trep(i,1,n-1) rep(j,1,m-1) if(w[i][j]){\n\t\tint r=0;\n\t\tmemset(d,-1,sizeof d);\n\t\tq[++r][0]=i,q[r][1]=j,d[i][j]=0;\n\t\trep(l,1,r){\n\t\t\tint x=q[l][0],y=q[l][1];\n\t\t\tREP(dir,4){\n\t\t\t\tint xx=x+dx[dir],yy=y+dy[dir];\n\t\t\t\tif(!w[xx][yy]||d[xx][yy]>=0) continue;\n\t\t\t\td[xx][yy]=d[x][y]+1;\n\t\t\t\tq[++r][0]=xx,q[r][1]=yy;\n\t\t\t}\n\t\t}\n\t\trep(x,1,n-1) rep(y,1,m-1) if(w[x][y])\n\t\t\tans=(ans+(ll)w[i][j]*w[x][y]%mod*d[x][y]%mod*inv2)%mod;\n\t}\n\tcout<<ans<<endl;\n\treturn 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\n// iostream is too mainstream\n#include <cstdio>\n// bitch please\n#include <iostream>\n#include <algorithm>\n#include <cstdlib>\n#include <vector>\n#include <set>\n#include <map>\n#include <queue>\n#include <stack>\n#include <list>\n#include <cmath>\n#include <iomanip>\n#include <time.h>\n#include <unistd.h>\n#define dibs reserve\n#define OVER9000 1034567890\n#define ALL_THE(CAKE,LIE) for(auto LIE =CAKE.begin(); LIE != CAKE.end(); LIE++)\n#define tisic 47\n#define soclose 1e-8\n#define chocolate win\n// so much chocolate\n#define patkan 9\n#define ff first\n#define ss second\n#define abs(x) ((x < 0)?-(x):x)\n#define uint unsigned int\n#define dbl long double\n#define pi 3.14159265358979323846\nusing namespace std;\n// mylittledoge\n\ntypedef long long cat;\n\n#ifdef DONLINE_JUDGE\n\t// palindromic tree is better than splay tree!\n\t#define lld I64d\n#endif\n\ncat encode(int a, int b, int c) {\n\treturn ((1LL*a)<<40)+((1LL*b)<<20)+c;\n}\n\nint main() {\n\tcin.sync_with_stdio(0);\n\tcin.tie(0);\n\tcout << fixed << setprecision(10);\n\tint H, W, N;\n\tcin >> H >> W >> N;\n\tvector< pair<int, int> > bl(N);\n\tmap<int, int> Mx, My;\n\tMx[0] =Mx[H] =0;\n\tMy[0] =My[W] =0;\n\tfor(int i =0; i < N; i++) {\n\t\tcin >> bl[i].ff >> bl[i].ss;\n\t\tMx[bl[i].ff] =Mx[bl[i].ff+1] =0;\n\t\tMy[bl[i].ss] =My[bl[i].ss+1] =0;\n\t}\n\tint mx =0, my =0;\n\tvector< pair<int,int> > Ix, Iy;\n\tint last =-1;\n\tALL_THE(Mx, it) {\n\t\tit->ss =mx++;\n\t\tif(last >= 0) Ix.push_back(make_pair(last, it->ff));\n\t\tlast =it->ff;\n\t}\n\tlast =-1;\n\tALL_THE(My, it) {\n\t\tit->ss =my++;\n\t\tif(last >= 0) Iy.push_back(make_pair(last, it->ff));\n\t\tlast =it->ff;\n\t}\n\tvector< vector<bool> > BL(mx, vector<bool>(my, 0));\n\tfor(int i =0; i < N; i++) BL[Mx[bl[i].ff]][My[bl[i].ss]] =1;\n\tmx--, my--;\n\n\tcat mod =1000000007;\n\t// sum of Manhattan distances\n\tcat ans =((1LL*(H-1)*H*(H+1)/6)%mod*W%mod*W+(1LL*(W-1)*W*(W+1)/6)%mod*H%mod*H)%mod;\n\tfor(int i =0; i < N; i++) {\n\t\tcat sum =0;\n\t\tsum =(sum+(1LL*bl[i].ff*(bl[i].ff+1)/2+1LL*(H-1-bl[i].ff)*(H-bl[i].ff)/2)%mod*W)%mod;\n\t\tsum =(sum+(1LL*bl[i].ss*(bl[i].ss+1)/2+1LL*(W-1-bl[i].ss)*(W-bl[i].ss)/2)%mod*H)%mod;\n\t\tfor(int j =0; j < N; j++)\n\t\t\tsum -=abs(bl[j].ff-bl[i].ff)+abs(bl[j].ss-bl[i].ss);\n\t\tans =(ans-sum)%mod;\n\t}\n\tfor(int i =0; i < N; i++) for(int j =0; j < i; j++)\n\t\tans -=abs(bl[j].ff-bl[i].ff)+abs(bl[j].ss-bl[i].ss);\n\n\tvector< vector< vector<int> > > Dx(mx, vector< vector<int> >(my, vector<int>(my, OVER9000)));\n\tvector< vector< vector<int> > > Dy(my, vector< vector<int> >(mx, vector<int>(mx, OVER9000)));\n\tpriority_queue< pair<int, cat>, vector< pair<int, cat> >, greater< pair<int, cat> > > qx, qy;\n\tfor(int i =0; i < mx; i++) for(int j =0; j < my; j++) if(!BL[i][j]) {\n\t\tDx[i][j][j] =Dy[j][i][i] =0;\n\t\tqx.push(make_pair(0, encode(i, j, j)));\n\t\tqy.push(make_pair(0, encode(j, i, i)));\n\t}\n\n\twhile(!qx.empty()) {\n\t\tpair<int, cat> p =qx.top();\n\t\tqx.pop();\n\t\tint x =p.ss>>40, y1 =(p.ss>>20)&((1LL<<20)-1), y2 =p.ss&((1LL<<20)-1);\n\t\tif(Dx[x][y1][y2] != p.ff) continue;\n\t\t// +1, in row-direction\n\t\tif(y1 > 0 && !BL[x][y1-1] && Dx[x][y1-1][y2] > Dx[x][y1][y2]) {\n\t\t\tDx[x][y1-1][y2] =Dx[x][y1][y2];\n\t\t\tqx.push(make_pair(Dx[x][y1-1][y2], encode(x, y1-1, y2)));\n\t\t}\n\t\tif(y2+1 < my && !BL[x][y2+1] && Dx[x][y1][y2+1] > Dx[x][y1][y2]) {\n\t\t\tDx[x][y1][y2+1] =Dx[x][y1][y2];\n\t\t\tqx.push(make_pair(Dx[x][y1][y2+1], encode(x, y1, y2+1)));\n\t\t}\n\t\t// -1 in the row-direction\n\t\tif(y1 < y2 && !BL[x][y1+1] && Dx[x][y1+1][y2] > Dx[x][y1][y2]+1) {\n\t\t\tDx[x][y1+1][y2] =Dx[x][y1][y2]+1;\n\t\t\tqx.push(make_pair(Dx[x][y1+1][y2], encode(x, y1+1, y2)));\n\t\t}\n\t\tif(y1 < y2 && !BL[x][y2-1] && Dx[x][y1][y2-1] > Dx[x][y1][y2]+1) {\n\t\t\tDx[x][y1][y2-1] =Dx[x][y1][y2]+1;\n\t\t\tqx.push(make_pair(Dx[x][y1][y2-1], encode(x, y1, y2-1)));\n\t\t}\n\t\t// +1,+1 in the same col-direction\n\t\tif(x > 0 && !BL[x-1][y1] && !BL[x-1][y2] && Dx[x-1][y1][y2] > Dx[x][y1][y2]+1) {\n\t\t\tDx[x-1][y1][y2] =Dx[x][y1][y2]+1;\n\t\t\tqx.push(make_pair(Dx[x-1][y1][y2], encode(x-1, y1, y2)));\n\t\t}\n\t\tif(x+1 < mx && !BL[x+1][y1] && !BL[x+1][y2] && Dx[x+1][y1][y2] > Dx[x][y1][y2]+1) {\n\t\t\tDx[x+1][y1][y2] =Dx[x][y1][y2]+1;\n\t\t\tqx.push(make_pair(Dx[x+1][y1][y2], encode(x+1, y1, y2)));\n\t\t}\n\t}\n\twhile(!qy.empty()) {\n\t\tpair<int, cat> p =qy.top();\n\t\tqy.pop();\n\t\tint y =p.ss>>40, x1 =(p.ss>>20)&((1LL<<20)-1), x2 =p.ss&((1LL<<20)-1);\n\t\tif(Dy[y][x1][x2] != p.ff) continue;\n\t\t// +1, in row-direction\n\t\tif(x1 > 0 && !BL[x1-1][y] && Dy[y][x1-1][x2] > Dy[y][x1][x2]) {\n\t\t\tDy[y][x1-1][x2] =Dy[y][x1][x2];\n\t\t\tqy.push(make_pair(Dy[y][x1-1][x2], encode(y, x1-1, x2)));\n\t\t}\n\t\tif(x2+1 < mx && !BL[x2+1][y] && Dy[y][x1][x2+1] > Dy[y][x1][x2]) {\n\t\t\tDy[y][x1][x2+1] =Dy[y][x1][x2];\n\t\t\tqy.push(make_pair(Dy[y][x1][x2+1], encode(y, x1, x2+1)));\n\t\t}\n\t\t// -1 in the row-direction\n\t\tif(x1 < x2 && !BL[x1+1][y] && Dy[y][x1+1][x2] > Dy[y][x1][x2]+1) {\n\t\t\tDy[y][x1+1][x2] =Dy[y][x1][x2]+1;\n\t\t\tqy.push(make_pair(Dy[y][x1+1][x2], encode(y, x1+1, x2)));\n\t\t}\n\t\tif(x1 < x2 && !BL[x2-1][y] && Dy[y][x1][x2-1] > Dy[y][x1][x2]+1) {\n\t\t\tDy[y][x1][x2-1] =Dy[y][x1][x2]+1;\n\t\t\tqy.push(make_pair(Dy[y][x1][x2-1], encode(y, x1, x2-1)));\n\t\t}\n\t\t// +1,+1 in the same col-direction\n\t\tif(y > 0 && !BL[x1][y-1] && !BL[x2][y-1] && Dy[y-1][x1][x2] > Dy[y][x1][x2]+1) {\n\t\t\tDy[y-1][x1][x2] =Dy[y][x1][x2]+1;\n\t\t\tqy.push(make_pair(Dy[y-1][x1][x2], encode(y-1, x1, x2)));\n\t\t}\n\t\tif(y+1 < my && !BL[x1][y+1] && !BL[x2][y+1] && Dy[y+1][x1][x2] > Dy[y][x1][x2]+1) {\n\t\t\tDy[y+1][x1][x2] =Dy[y][x1][x2]+1;\n\t\t\tqy.push(make_pair(Dy[y+1][x1][x2], encode(y+1, x1, x2)));\n\t\t}\n\t}\n\n\tfor(int x =0; x < mx; x++)\n\t\tfor(int y1 =0; y1 < my; y1++) for(int y2 =0; y2 < y1; y2++)\n\t\t\tDx[x][y1][y2] =Dx[x][y2][y1];\n\tfor(int y =0; y < my; y++)\n\t\tfor(int x1 =0; x1 < mx; x1++) for(int x2 =0; x2 < x1; x2++)\n\t\t\tDy[y][x1][x2] =Dy[y][x2][x1];\n\n\tvector< vector<int> > D(mx*my, vector<int>(mx*my, OVER9000));\n\tfor(int i =0; i < mx; i++) for(int j =0; j < my; j++) if(!BL[i][j]) {\n\t\tD[i*my+j][i*my+j] =0;\n\t\tfor(int k =0; k < mx; k++) if(!BL[k][j])\n\t\t\tD[i*my+j][k*my+j] =D[k*my+j][i*my+j] =2*Dy[j][i][k]+abs(i-k);\n\t\tfor(int k =0; k < my; k++) if(!BL[i][k])\n\t\t\tD[i*my+j][i*my+k] =D[i*my+k][i*my+j] =2*Dx[i][j][k]+abs(j-k);\n\t}\n\n\t// Dijkstra from everywhere\n\tqueue<int> q;\n\tvector<bool> vis(mx*my);\n\tint dx[] ={1, -1, 0, 0};\n\tint dy[] ={0, 0, 1, -1};\n\tfor(int i =0; i < mx*my; i++) if(!BL[i/my][i%my]) {\n\t\tq.push(i);\n\t\tfor(int j =0; j < mx*my; j++) vis[j] =0;\n\t\tvis[i] =1;\n\t\twhile(!q.empty()) {\n\t\t\tint x =q.front()/my, y =q.front()%my, p =q.front();\n\t\t\tfor(int k =0; k < 4; k++) if(x+dx[k] >= 0 && y+dy[k] >= 0 && x+dx[k] < mx && y+dy[k] < my) {\n\t\t\t\tif(vis[p+dx[k]*my+dy[k]] || BL[x+dx[k]][y+dy[k]]) continue;\n\t\t\t\tD[i][p+dx[k]*my+dy[k]] =D[i][p]+1;\n\t\t\t\tvis[p+dx[k]*my+dy[k]] =1;\n\t\t\t\tq.push(p+dx[k]*my+dy[k]);\n\t\t\t}\n\t\t\tq.pop();\n\t\t}\n//\t\tfor(int j =0; j < mx*my; j++) for(int k =0; k < mx*my; k++)\n//\t\t\tif(D[j][k] > D[j][i]+D[i][k]) D[j][k] =D[j][i]+D[i][k];\n\t}\n\n\tfor(int x1 =0; x1 < mx; x1++) for(int y1 =0; y1 < my; y1++)\n\t\tfor(int x2 =0; x2 <= x1; x2++) for(int y2 =0; y2 < my; y2++) {\n\t\t\tif(x2 == x1 && y2 >= y1) continue;\n\t\t\tif(D[x1*my+y1][x2*my+y2] == OVER9000) continue;\n\t\t\tcat cnt1 =1LL*(Ix[x1].ss-Ix[x1].ff)*(Iy[y1].ss-Iy[y1].ff)%mod;\n\t\t\tcat cnt2 =1LL*(Ix[x2].ss-Ix[x2].ff)*(Iy[y2].ss-Iy[y2].ff)%mod;\n\t\t\tans =(ans+(cnt1*cnt2)%mod*(D[x1*my+y1][x2*my+y2]-abs(x1-x2)-abs(y1-y2)))%mod;\n\t\t}\n\n\tans %=mod;\n\tif(ans < 0) ans +=mod;\n\tcout << ans << \"\\n\";\n\treturn 0;}\n\n// look at my code\n// my code is amazing\n"
  },
  {
    "language": "C++",
    "code": "#include <iostream>\n#include <vector>\n#include <queue>\n#include <algorithm>\n#include <cstring>\nusing namespace std;\n\nconst int MOD = 1000000007;\nint dx[4] = {1, 0, -1, 0};\nint dy[4] = {0, 1, 0, -1};\n\nint H, W, N;\nint bx[110], by[110];\nvector<int> altx, alty;\nint nH, nW;\nint xnum[1100000], ynum[1100000];\nbool cb[110][110];\nint dist[110][110];\ntypedef pair<int, int> pint;\n\nlong long subsolve() {\n  long long res = 0;\n  for (int x = 0; x < nH; ++x) {\n\tfor (int y = 0; y < nW; ++y) {\n\t  if (cb[x][y]) continue;\n\t  memset(dist, -1, sizeof(dist));\n\t  queue<pint> que;\n\t  que.push(pint(x, y));\n\t  dist[x][y] = 0;\n\t  while (!que.empty()) {\n\t\tpint cur = que.front();\n\t\tque.pop();\n\t\tfor (int dir = 0; dir < 4; ++dir) {\n\t\t  int nx = cur.first + dx[dir];\n\t\t  int ny = cur.second + dy[dir];\n\t\t  if (nx < 0 || nx >= nH || ny < 0 || ny >= nW) continue;\n\t\t  if (cb[nx][ny]) continue;\n\t\t  if (dist[nx][ny] == -1) {\n\t\t\tdist[nx][ny] = dist[cur.first][cur.second] + 1;\n\t\t\tque.push(pint(nx, ny));\n\t\t  }\n\t\t}\n\t  }\n\t  for (int nx = 0; nx < nH; ++nx) {\n\t\tfor (int ny = 0; ny < nW; ++ny) {\n\t\t  if (nW * nx + ny <= nW * x + y) continue;\n\t\t  if (dist[nx][ny] == -1) continue;\n\t\t  if (cb[nx][ny]) continue;\n\t\t  long long ss = ((long long)(altx[x + 1] - altx[x]) * (alty[y + 1] - alty[y])) % MOD;\n\t\t  long long st = ((long long)(altx[nx + 1] - altx[nx]) * (alty[ny + 1] - alty[ny])) % MOD;\n\t\t  res += (dist[nx][ny] % MOD) * ss % MOD * st % MOD;\n\t\t  res %= MOD;\n\t\t}\n\t  }\t\n\t}\n  }\n  return res;\n}\n\nlong long solve() {\n  memset(xnum, 0, sizeof(xnum));\n  memset(ynum, 0, sizeof(ynum));\n  altx.clear(); alty.clear();\n  altx.push_back(0); altx.push_back(H);\n  alty.push_back(0); alty.push_back(W);\n  for (int i = 0; i < N; ++i) {\n\taltx.push_back(bx[i]);\n\taltx.push_back(bx[i] + 1);\n\talty.push_back(by[i]);\n\talty.push_back(by[i] + 1);\n\txnum[bx[i]]++;\n\tynum[by[i]]++;\n  }\n  sort(altx.begin(), altx.end());\n  sort(alty.begin(), alty.end());\n  altx.erase(unique(altx.begin(), altx.end()), altx.end());\n  alty.erase(unique(alty.begin(), alty.end()), alty.end());\n  nH = (int)altx.size()-1;\n  nW = (int)alty.size()-1;\n  memset(cb, 0, sizeof(cb));\n  for (int i = 0; i < N; ++i) {\n\tint itx = lower_bound(altx.begin(), altx.end(), bx[i]) - altx.begin();\n\tint ity = lower_bound(alty.begin(), alty.end(), by[i]) - alty.begin();\n\tcb[itx][ity] = true;\n  }\n\n  long long all = (long long)H * W - N;\n  long long add = 0;\n  long long sum = W - xnum[0];\n  for (int i = 1; i < H; ++i) {\n\tif (xnum[i] == 0 && xnum[i-1] == 0) {   // i-1 -> i\n\t  long long up = sum % MOD;\n\t  long long down = (all - sum) % MOD;\n\t  add += (up * down) % MOD;\n\t  add %= MOD;\n\t}\n\tsum += W - xnum[i];\n  }\n  sum = H - ynum[0];\n  for (int i = 1; i < W; ++i) {\n\tif (ynum[i] == 0 && ynum[i-1] == 0) {   // i-1 -> i\n\t  long long left = sum % MOD;\n\t  long long right = (all - sum) % MOD;\n\t  add += (left * right) % MOD;\n\t  add %= MOD;\n\t}\n\tsum += H - ynum[i];\n  }\n  long long comp = subsolve();\n  long long res = (comp + add) % MOD;\n  return res;\n}\n\nint main() {\n  while (cin >> H >> W >> N) {\n\tfor (int i = 0; i < N; ++i) cin >> bx[i] >> by[i];\n\tcout << solve() << endl;\n  }\n}\n"
  },
  {
    "language": "C++",
    "code": "#include<iostream>\n#include<cstdio>\n#include<cstdlib>\n#include<cmath>\n#include<cstring>\n#include<algorithm>\n#include<vector>\n#define rep(i,a,b) for(register int i=a;i<=b;i++)\n#define dep(i,a,b) for(register int i=a;i>=b;i--)\n#define ll long long\n#define mem(x,num) memset(x,num,sizeof x)\n#define reg(x) for(int i=last[x];i;i=e[i].next)\nusing namespace std;\ninline ll read(){\n\tll f=1,x=0;char ch=getchar();\n\twhile(ch<'0'||ch>'9'){if(ch=='-')f=-1;ch=getchar();}\n\twhile(ch>='0'&&ch<='9'){x=x*10+ch-'0';ch=getchar();}\n\treturn x*f;\n}\n//**********head by yjjr**********\n#define pb push_back\n#define inf 1e9\nconst int maxn=66,maxm=1e6+6,dx[4]={-1,1,0,0},dy[4]={0,0,-1,1},mod=1e9+7;\nstruct node{int x,y;}a[maxn<<1],que[maxn*maxn*4];\nint n,m,K,ans,lx,ly,cnt[maxn][maxn],s1[maxm],s2[maxm],dis[maxn][maxn],head,tail;\nbool fb[maxn][maxn],mark1[maxm],mark2[maxm];\nvector<int>px,py;\nvoid vnique(vector <int> &r){\n\tsort(r.begin(),r.end());\n\tauto t=unique(r.begin(),r.end());\n\tr.erase(t,r.end());\n}\nvoid bfs(int x,int y){\n\trep(i,0,lx)rep(j,0,ly)dis[i][j]=inf;\n\tdis[x][y]=0;que[head=tail=1]=(node){x,y};\n\twhile(head<=tail){\n\t\tint nx=que[head].x,ny=que[head++].y;\n\t\trep(i,0,3){\n\t\t\tint nex=nx+dx[i],ney=ny+dy[i];\n\t\t\tif(nex>lx||nex<0||ney>ly||ney<0||dis[nex][ney]<=dis[nx][ny]+1||fb[nex][ney])continue;\n\t\t\tdis[nex][ney]=dis[nx][ny]+1;que[++tail]=(node){nex,ney};\n\t\t}\n\t}\n}\nint main() {\n\tn=read(),m=read(),K=read();\n\tpx.pb(1);px.pb(n+1);py.pb(1);py.pb(m+1);\n\trep(i,1,n)s1[i]=m;\n\trep(i,1,m)s2[i]=n;\n\trep(i,1,K){\n\t\ta[i].x=read()+1,a[i].y=read()+1;\n\t\tpx.pb(a[i].x),px.pb(a[i].x+1);\n\t\tpy.pb(a[i].y),py.pb(a[i].y+1);\n\t\ts1[a[i].x]--,mark1[a[i].x]=1;\n\t\ts2[a[i].y]--,mark2[a[i].y]=1;\n\t}\n\trep(i,1,n)s1[i]=(s1[i]+s1[i-1])%mod;\n\trep(i,1,m)s2[i]=(s2[i]+s2[i-1])%mod;\n\trep(i,1,n-1)if(!mark1[i]&&!mark1[i+1])ans=(ans+1ll*2*s1[i]*(s1[n]-s1[i]))%mod;\n\trep(i,1,m-1)if(!mark2[i]&&!mark2[i+1])ans=(ans+1ll*2*s2[i]*(s2[m]-s2[i]))%mod;\n\tvnique(px);vnique(py);lx=px.size()-2;ly=py.size()-2;\n\trep(i,1,K)\n\t\tfb[lower_bound(px.begin(),px.end(),a[i].x)-px.begin()][lower_bound(py.begin(),py.end(),a[i].y)-py.begin()]=1;\n\trep(i,0,lx)rep(j,0,ly)cnt[i][j]=1ll*(px[i+1]-px[i])*(py[j+1]-py[j])%mod;\n\trep(i,0,lx)rep(j,0,ly)\n\t\tif(!fb[i][j]){\n\t\t\tbfs(i,j);\n\t\t\trep(k,0,lx)rep(p,0,ly)\n\t\t\t\tif(!fb[k][p])ans=(ans+1ll*cnt[i][j]*dis[k][p]%mod*cnt[k][p])%mod; \n   \t\t}\n\tans=(ans+mod)%mod;ans=1ll*ans*(mod/2+1)%mod;\n\tcout<<ans<<endl;\n\treturn 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include <algorithm>\n#include <climits>\n#include <cmath>\n#include <cstdio>\n#include <cstdlib>\n#include <ctime>\n#include <iostream>\n#include <sstream>\n#include <functional>\n#include <map>\n#include <set>\n#include <unordered_map>\n#include <unordered_set>\n#include <bitset>\n#include <string>\n#include <cstring>\n#include <vector>\n#include <queue>\n#include <stack>\n#include <deque>\n#include <list>\n#include <numeric>\nusing namespace std;\ntypedef long long ll;\ntypedef unsigned long long ull;\ntypedef long double ld;\ntypedef pair<ll,ll> P;\ntypedef pair<P,ll> PPI;\ntypedef pair<ll,P> PIP;\ntypedef vector<ll> vl;\ntypedef vector<vl> vvl;\ntypedef vector<P> vp;\n#define PQ(T) priority_queue<T,vector<T>,greater<T>>\n#define PQ2(T) priority_queue<T>\nconst double PI = 3.14159265358979323846;\nconst double EPS = 1e-12;\nconst ll INF = 1LL<<59;\nconst ll mod = 1e9+7;\n#define REP(i,a,b) for(ll (i)=a;(i)<(ll)(b);++(i))\n#define rep(i,n) REP(i,0,n)\n#define rep1(i,n) REP(i,1,n+1)\n#define repd(i,n,d) for(ll (i)=0;(i)<(ll)(n);(i)+=(d))\n#define all(v) (v).begin(), (v).end()\n#define pb(x) push_back(x)\n#define mp(x,y) make_pair((x),(y))\n#define mset(m,v) memset((m),(v),sizeof(m))\n#define chmin(x,y) ((x)=min((x),(y)))\n#define chmax(x,y) ((x)=max((x),(y)))\n#define fst first\n#define snd second\n#define UNIQUE(x) (x).erase(unique(all(x)),(x).end())\n#define DEBUG(x) cerr<<\"line (\"<<__LINE__<<\")  \"<<#x<<\": \"<<x<<endl;\ntemplate<class T> ostream &operator<<(ostream &os, const vector<T> &v){int n=v.size();rep(i,n)os<<v[i]<<(i==n-1?\"\":\" \");return os;}\n\n#define N 30\n#define M 65*65*4\nint h, w, n, h2, w2;\nint x[N], y[N], xy[N][N];\nvector<int> x2, y2;\nunordered_map<int, int> xd, yd;\nll d[M];\n\nll pow_mod(ll a, ll r, ll m = mod){\n\tll x = 1;\n\twhile(r){\n\t\tif(r&1) (x*=a)%=m;\n\t\t(a*=a)%=m;\n\t\tr>>=1;\n\t}\n\treturn x;\n}\n\nll inv2 = pow_mod(2, mod-2, mod);\nll inv3 = pow_mod(3, mod-2, mod);\n\nll f(ll a, ll b, ll c){\n\treturn (a*w2+b)*4+c;\n}\n\nvoid comp(int *a, vector<int> &b, unordered_map<int, int> &c, int d, int &d2){\n\tb.clear(); c.clear();\n\trep(i, n){ b.pb(a[i]); b.pb(a[i]+1);}\n\tb.pb(0); b.pb(d);\n\tsort(all(b));\n\tUNIQUE(b);\n\td2 = b.size();\n\trep(i, d2) c[b[i]] = i;\n\trep(i, n) a[i] = c[a[i]];\n}\n\nll solve(int a, int b, int c, bool xf, bool yf){\n\tfill(d, d+M, INF);\n\trep(i, n) rep(j, 4) d[f(x[i], y[i], j)] = -1;\n\tll abc = f(a, b, c);\n\td[abc] = 0;\n\tPQ(P) q;\n\tq.push(P(0, abc));\n\tll res = 0;\n\twhile(!q.empty()){\n\t\tP p = q.top(); q.pop();\n\t\tll l = p.fst, u = (p.snd>>2)/w2, v = (p.snd>>2)%w2, k = p.snd&3;\n\t\tif(d[p.snd]<l) continue;\n\t\t//cerr<<\"dijk \"<<u<<\" \"<<v<<\" \"<<k<<\" \"<<l<<endl;\n\t\tll kx = k>>1, ky = k&1;\n\t\tll u2 = u+kx*2-1, v2 = v+ky*2-1;\n\t\tif(0<=u2&&u2<h2-1){\n\t\t\tll p2 = f(u2, v, k^2);\n\t\t\tif(d[p2]>=0 && l+1<d[p2]){\n\t\t\t\td[p2] = l+1;\n\t\t\t\tq.push(P(d[p2], p2));\n\t\t\t}\n\t\t}\n\t\tif(0<=v2&&v2<w2-1){\n\t\t\tll p2 = f(u, v2, k^1);\n\t\t\tif(d[p2]>=0 && l+1<d[p2]){\n\t\t\t\td[p2] = l+1;\n\t\t\t\tq.push(P(d[p2], p2));\n\t\t\t}\n\t\t}\n\t\trep1(i, 3){\n\t\t\tll k2 = k^i;\n\t\t\tll l2 = l;\n\t\t\tif(i&2) l2 += x2[u+1]-x2[u]-1;\n\t\t\tif(i&1) l2 += y2[v+1]-y2[v]-1;\n\t\t\tll p2 = f(u, v, k2);\n\t\t\tif(d[p2]>=0 && l2<d[p2]){\n\t\t\t\td[p2] = l2;\n\t\t\t\tq.push(P(d[p2], p2));\n\t\t\t}\n\t\t}\n\t}\n\trep(i, h2-1) rep(j, w2-1){\n\t\tif(xy[i][j]) continue;\n\t\tif(xf && i==a) continue;\n\t\tif(yf && j==b) continue;\n\t\t(res+=(d[f(i, j, 0)]+d[f(i, j, 3)])%mod*(x2[i+1]-x2[i])%mod*(y2[j+1]-y2[j])%mod*inv2)%=mod;\n\t}\n\treturn res;\n\trep(i, h2-1){\n\t\trep(j, w2-1) cerr<<d[f(i, j, 0)]<<\" \";\n\t\tcerr<<endl;\n\t}\n\treturn res;\n}\n\nll f5(ll h){\n\tll r1 = ((3*h-2)*(h-1)+2*(h-1)*(h-1)%mod*(h-1))%mod*(h-1)%mod;\n\tll r2 = ((4*h-4)*(h-1)+2*(h-2)*(h-1)%mod*(h-1))%mod*(h-1)%mod*(h-1)%mod*inv2%mod;\n\treturn (r1+r2)%mod;\n}\n\nint main(){\n\tcin>>h>>w>>n;\n\trep(i, n) cin>>x[i]>>y[i];\n\tcomp(x, x2, xd, h, h2);\n\tcomp(y, y2, yd, w, w2);\n\trep(i, n) xy[x[i]][y[i]] = -1;\n\tll res = 0;\n\trep(i, h2-1) rep(j, w2-1){\n\t\tif(xy[i][j]) continue;\n\t\tll xx = x2[i+1]-x2[i], yy = y2[j+1]-y2[j];\n\t\tbool xf = xx>1, yf = yy>1;\n\t\tll r0 = solve(i, j, 0, xf, yf);\n\t\tll r3 = (!xf&&!yf)?r0:solve(i, j, 3, xf, yf);\n\t\t//cerr<<\"xx yy \"<<xx<<\" \"<<yy<<endl;\n\t\tll res2 = res;\n\t\t(res+=(r0+r3)*(xx)%mod*(yy)%mod*inv2)%=mod;\n\t\t//cerr<<\"diff1 \"<<(res-res2+mod)%mod<<endl;\n\t\tif(!xf&&!yf) continue;\n\t\tll xx1 = x2[i], xx2 = h-x2[i+1], yy1 = y2[j], yy2 = w-y2[j+1];\n\t\tif(xf&&yf){\n\t\t\tll rx = (pow_mod(xx, 3)-xx)*w%mod*yy%mod*inv3%mod + (yy1*(yy1+1)+yy2*(yy2+1))%mod*xx%mod*xx%mod*yy%mod*inv2%mod + xx*xx%mod*yy%mod*(w-yy)%mod*(yy-1)%mod*inv2%mod;\n\t\t\tll ry = (pow_mod(yy, 3)-yy)*h%mod*xx%mod*inv3%mod + (xx1*(xx1+1)+xx2*(xx2+1))%mod*yy%mod*yy%mod*xx%mod*inv2%mod + yy*yy%mod*xx%mod*(h-xx)%mod*(xx-1)%mod*inv2%mod;\n\t\t\t(res+=rx+ry)%=mod;\n\t\t\t//cerr<<\"rx ry \"<<rx<<\" \"<<ry<<endl;\n\t\t} else if(xf){\n\t\t\t(res+=(pow_mod(xx, 3)-xx)*w%mod*inv3%mod + (yy1*(yy1+1)+yy2*(yy2+1))%mod*xx%mod*xx%mod*inv2%mod)%=mod;\n\t\t} else {\n\t\t\t(res+=(pow_mod(yy, 3)-yy)*h%mod*inv3%mod + (xx1*(xx1+1)+xx2*(xx2+1))%mod*yy%mod*yy%mod*inv2%mod)%=mod;\n\t\t}\n\t\tcerr<<\"diff \"<<(res-res2+mod)%mod<<endl;\n\t}\n\tcout<<(res*inv2%mod+mod)%mod<<endl;\n\t//cerr<<res<<endl;\n\t//cerr<<f5(h)*inv2%mod<<endl;\n\treturn 0;\n}\n"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\nusing namespace std;\n\ntypedef pair<int, int> pii;\ntypedef long long ll;\ntypedef vector<int> vi;\n\n#define pb push_back\n#define eb emplace_back\n#define mp make_pair\n#define fi first\n#define se second\n#define rep(i,n) rep2(i,0,n)\n#define rep2(i,m,n) for(int i=m;i<(n);i++)\n#define ALL(c) (c).begin(),(c).end()\n\nconst ll MOD = 1000000007;\nconst int MN = 70;\nconst int MX = 1000010;\nconst int dx[] = {1, -1, 0, 0};\nconst int dy[] = {0, 0, 1, -1};\n\nbool ex[MX], ey[MX];\nll f[MN][MN];\n\nint main() {\n\tint H, W, N;\n\tcin >> H >> W >> N;\n\n\tvector<pii> pt(N);\n\n\tvi xs, ys;\n\txs.pb(0); xs.pb(H); ys.pb(0); ys.pb(W);\n\n\trep(i, N) {\n\t\tcin >> pt[i].fi >> pt[i].se;\n\t\tex[pt[i].fi] = ey[pt[i].se] = 1;\n\t\txs.pb(pt[i].fi); xs.pb(pt[i].fi + 1);\n\t\tys.pb(pt[i].se); ys.pb(pt[i].se + 1);\n\t}\n\n\tsort(ALL(xs)); sort(ALL(ys));\n\txs.erase(unique(ALL(xs)), xs.end()); ys.erase(unique(ALL(ys)), ys.end());\n\n\tint sx = xs.size(), sy = ys.size();\n\n\trep(i, N) {\n\t\tint p = lower_bound(ALL(xs), pt[i].fi) - xs.begin();\n\t\tint q = lower_bound(ALL(ys), pt[i].se) - ys.begin();\n\t\tf[p][q] = -1;\n\t}\n\n\trep(i, sx-1) {\n\t\trep(j, sy-1) {\n\t\t\tif (f[i][j] != -1) {\n\t\t\t\tf[i][j] = (ll)(xs[i+1] - xs[i]) * (ys[j+1] - ys[j]) % MOD;\n\t\t\t}\n\t\t}\n\t}\n\n\tll ret = 0;\n\trep(i, sx-1) {\n\t\trep(j, sy-1) if (f[i][j] != -1) {\n\t\t\tqueue<pii> que;\n\t\t\tque.push(mp(i, j));\n\n\t\t\tvector<vi> d(sx, vi(sy));\n\t\t\trep(ii, sx) rep(jj, sy) d[ii][jj] = -1;\n\t\t\td[i][j] = 0;\n\n\t\t\twhile (!que.empty()) {\n\t\t\t\tpii p = que.front(); que.pop();\n\t\t\t\tint x = p.fi, y = p.se;\n\t\t\t\trep(dir, 4) {\n\t\t\t\t\tint nx = x + dx[dir], ny = y + dy[dir];\n\t\t\t\t\tif (nx >= 0 && nx < sx-1 && ny >= 0 && ny < sy-1 && f[nx][ny] != -1 && d[nx][ny] == -1) {\n\t\t\t\t\t\td[nx][ny] = d[x][y] + 1;\n\t\t\t\t\t\tque.push(mp(nx, ny));\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t}\n\n\t\t\trep(p, sx) {\n\t\t\t\trep(q, sy) {\n\t\t\t\t\tif (d[p][q] != -1) {\n\t\t\t\t\t\tret = (ret + f[p][q] * f[i][j] % MOD * d[p][q]) % MOD;\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t}\n\n\tret = (MOD + 1) / 2 * ret % MOD;\n\n\tsort(ALL(pt));\n\tint p = 0;\n\n\trep(i, H-1) {\n\t\tif (!ex[i] && !ex[i+1]) {\n\t\t\twhile (p < N && pt[p].fi <= i) {\n\t\t\t\t++p;\n\t\t\t}\n\t\t\tll nx = ((ll)W * (i + 1) - p) % MOD;\n\t\t\tll ny = ((ll)W * (H - i - 1) - (N - p)) % MOD;\n\t\t\tret = (ret + nx * ny) % MOD;\n\t\t}\n\t}\n\n\tp = 0;\n\trep(i, N) swap(pt[i].fi, pt[i].se);\n\tsort(ALL(pt));\n\n\trep(i, W-1) {\n\t\tif (!ey[i] && !ey[i+1]) {\n\t\t\twhile (p < N && pt[p].fi <= i) {\n\t\t\t\t++p;\n\t\t\t}\n\t\t\tll nx = ((ll)H * (i + 1) - p) % MOD;\n\t\t\tll ny = ((ll)H * (W - i - 1) - (N - p)) % MOD;\n\t\t\tret = (ret + nx * ny) % MOD;\t\n\t\t}\n\t}\n\n\tcout << ret << endl;\n\treturn 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include<iostream>\n#include<cstdio>\n#include<cstdlib>\n#include<cmath>\n#include<cstring>\n#include<algorithm>\n#include<vector>\n#define rep(i,a,b) for(int i=a;i<=b;i++)\n#define dep(i,a,b) for(int i=a;i>=b;i--)\n#define ll long long\n#define mem(x,num) memset(x,num,sizeof x)\n#define reg(x) for(int i=last[x];i;i=e[i].next)\nusing namespace std;\ninline ll read(){\n\tll f=1,x=0;char ch=getchar();\n\twhile(ch<'0'||ch>'9'){if(ch=='-')f=-1;ch=getchar();}\n\twhile(ch>='0'&&ch<='9'){x=x*10+ch-'0';ch=getchar();}\n\treturn x*f;\n}\n//**********head by yjjr**********\n#define pb push_back\n#define inf 1e9\ntemplate<class T>void vnique(vector<T> &r){sort(r.begin(),r.end());auto t=unique(r.begin(),r.end());r.erase(t,r.end());}\nconst int maxn=66,maxm=1e6+6,dx[4]={-1,1,0,0},dy[4]={0,0,-1,1},mod=1e9+7;\nstruct node{int x,y;}a[maxn<<1],que[maxn<<2];\nint n,m,K,ans,lx,ly,cnt[maxn][maxn],s1[maxm],s2[maxm],dis[maxn][maxn],head,tail;\nbool fb[maxn][maxn],mark1[maxm],mark2[maxm];\nvector<int>px,py;\nvoid bfs(int x,int y){\n\trep(i,0,lx)rep(j,0,ly)dis[i][j]=inf;\n\tdis[x][y]=0;que[head=tail=1]=(node){x,y};\n\twhile(head<=tail){\n\t\tint nx=que[head].x,ny=que[head++].y;\n\t\trep(i,0,3){\n\t\t\tint nex=nx+dx[i],ney=ny+dy[i];\n\t\t\tif(nex>lx||nex<0||ney>ly||ney<0||dis[nex][ney]<=dis[nx][ny]+1||fb[nex][ney])continue;\n\t\t\tdis[nex][ney]=dis[nx][ny]+1;que[++tail]=(node){nex,ney};\n\t\t}\n\t}\n}\nint main()\n{\n\tn=read(),m=read(),K=read();\n\tpx.pb(1);px.pb(n+1);py.pb(1);py.pb(m+1);\n\trep(i,1,n)s1[i]=m;\n\trep(i,1,m)s2[i]=n;\n\trep(i,1,K){\n\t\ta[i].x=read()+1,a[i].y=read()+1;\n\t\tpx.pb(a[i].x),px.pb(a[i].x+1);\n\t\tpy.pb(a[i].y),py.pb(a[i].y+1);\n\t\ts1[a[i].x]--,mark1[a[i].x]=1;\n\t\ts2[a[i].y]--,mark2[a[i].y]=1;\n\t}\n\trep(i,1,n)s1[i]=(s1[i]+s1[i-1])%mod;\n\trep(i,1,m)s2[i]=(s2[i]+s2[i-1])%mod;\n\trep(i,1,n-1)if(!mark1[i]&&!mark1[i+1])ans=(ans+1ll*2*s1[i]*(s1[n]-s1[i]))%mod;\n\trep(i,1,m-1)if(!mark2[i]&&!mark2[i+1])ans=(ans+1ll*2*s2[i]*(s2[m]-s2[i]))%mod;\n\tvnique(px);vnique(py);lx=px.size()-2;ly=py.size()-2;\n\trep(i,1,K)\n\t\tfb[lower_bound(px.begin(),px.end(),a[i].x)-px.begin()][lower_bound(py.begin(),py.end(),a[i].y)-py.begin()]=1;\n\trep(i,0,lx)rep(j,0,ly)cnt[i][j]=1ll*(px[i+1]-px[i])*(py[j+1]-py[j])%mod;\n\trep(i,0,lx)rep(j,0,ly)\n\t\tif(!fb[i][j]){\n\t\t\tbfs(i,j);\n\t\t\trep(k,0,lx)rep(p,0,ly)\n\t\t\t\tif(!fb[k][p])ans=(ans+1ll*cnt[i][j]*dis[k][p]%mod*cnt[k][p])%mod; \n   \t\t}\n\tans=(ans+mod)%mod;ans=1ll*ans*(mod/2+1)%mod;\n\tcout<<ans<<endl;\n\treturn 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include <cstdio>\n#include <vector>\n#include <algorithm>\n#include <functional>\n#include <map>\n#include <set>\n#include <string>\n#include <iostream>\n#include <cassert>\n#include <cmath>\n#include <queue>\nusing namespace std;\n\nconst int MOD = 1e9 + 7;\n\nstruct state { int y, x, step; };\nstatic const int dx[] = {1, 0, -1, 0}, dy[] = {0, 1, 0, -1};\n\nlong long Inv(long long a) {\n        long long res = 1;\n        long long n = MOD - 2;\n        while (n > 0) {\n                if (n & 1) res = res * a % MOD;\n                a = a * a % MOD;\n                n >>= 1;\n        }\n        return res;\n}\n\n/*\n#define unittest_name_helper(counter) unittest_ ## counter\n#define unittest_name(counter) unittest_name_helper(counter)\n#define unittest __attribute__((constructor)) void unittest_name(__COUNTER__) ()\n\nunittest {\n        int n = 3;\n        long long ans = 0;\n        while (n --) {\n                long long a, b, c;\n                cin >> a >> b >> c;\n                long long res = 1LL;\n                res *= a;\n                res %= MOD;\n                res *= b;\n                res %= MOD;\n                res *= c;\n                res %= MOD;\n                ans += res;\n        }\n        ans += 331183839;\n        cout << ans % MOD<< endl;\n}\n*/\n\nint main() {\n        long long h, w;\n        scanf(\"%lld %lld\", &h, &w);\n        int n;\n        scanf(\"%d\", &n);\n        vector<int> w_cnt(w, 0), h_cnt(h, 0);\n        vector<bool> w_exist(w, false), h_exist(h, false);\n        vector<pair<int, int>> black;\n        for (int i = 0; i < n; i ++) {\n                int y, x;\n                scanf(\"%d %d\", &y, &x);\n                w_cnt[x] ++;\n                h_cnt[y] ++;\n                w_exist[x] = true;\n                h_exist[y] = true;\n                black.emplace_back(x, y);\n        }\n        for (int i = 1; i < w; i ++) {\n                w_cnt[i] += w_cnt[i - 1];\n        }\n        for (int i = 1; i < h; i ++) {\n                h_cnt[i] += h_cnt[i - 1];\n        }\n        //for (int i = 0; i < w; i ++) cerr << w_cnt[i] << ' '; cerr << endl;\n        //for (int i = 0; i < h; i ++) cerr << h_cnt[i] << ' '; cerr << endl;\n        long long ans = 0;\n        //precalc\n        for (int i = 0; i < w - 1; i ++) {\n                if (!w_exist[i] && !w_exist[i + 1]) {\n                        long long left = (long long) (i + 1) * h % MOD - w_cnt[i];\n                        long long right = (long long) (w - (i + 1)) * h % MOD - (n - w_cnt[i]);\n                        ans += left * right;\n                        ans %= MOD;\n                }\n        }\n        for (int i = 0; i < h - 1; i ++) {\n                if (!h_exist[i] && !h_exist[i + 1]) {\n                        long long left = (long long) (i + 1) * w % MOD - h_cnt[i];\n                        long long right = (long long) (h - (i + 1)) * w % MOD - (n - h_cnt[i]);\n                        ans += left * right;\n                        ans %= MOD;\n                }\n        }\n        //compress\n        map<int, int> newx, newy;\n        vector<pair<long long, bool>> widths, heights; //(length, is_white)\n        {\n                int cnt = 0;\n                for (int i = 0; i < w; i ++) {\n                        if (!w_exist[i]) {\n                                cnt ++;\n                        } else {\n                                if (cnt) {\n                                        widths.emplace_back(cnt, true);\n                                        cnt = 0;\n                                }\n                                newx[i] = (int) widths.size();\n                                widths.emplace_back(1, false);\n                        }\n                }\n                if (cnt) widths.emplace_back(cnt, true);\n        }\n        {\n                int cnt = 0;\n                for (int i = 0; i < h; i ++) {\n                        if (!h_exist[i]) {\n                                cnt ++;\n                        } else {\n                                if (cnt) {\n                                        heights.emplace_back(cnt, true);\n                                        cnt = 0;\n                                }\n                                newy[i] = (int) heights.size();\n                                heights.emplace_back(1, false);\n                        }\n                }\n                if (cnt) heights.emplace_back(cnt, true);\n        }\n        //cerr << \"widths\" << endl;\n        //for (auto it : widths) cerr << it.first << ' ' << it.second << endl;\n        //cerr << \"heights\" << endl;\n        //for (auto it : heights) cerr << it.first << ' ' << it.second << endl;\n        int neww = (int) widths.size();\n        int newh = (int) heights.size();\n        //cerr << \"neww = \" << neww << endl;\n        //cerr << \"newh = \" << newh << endl;\n        vector<vector<long long>> s(newh, vector<long long> (neww, 1)); //-1 when it's black, weight when it's white\n        for (auto b : black) {\n                s[newy[b.second]][newx[b.first]] = -1;\n        }\n        for (int i = 0; i < newh; i ++) {\n                for (int j = 0; j < neww; j ++) {\n                        if (heights[i].second || widths[j].second) {\n                                s[i][j] = heights[i].first * widths[j].first % MOD;\n                        }\n                }\n        }\n        /*\n        cerr << \"s---------------------------\" << endl;\n        for (int i = 0; i < newh; i ++) {\n                for (int j = 0; j < neww; j ++) {\n                        cerr << s[i][j] << ' ';\n                }\n                cerr << endl;\n        }\n        cerr << \"s---------------------------\" << endl;\n        */\n        //cerr << \"ans = \" << ans << endl;\n        long long sum = 0;\n        for (int sy = 0; sy < newh; sy ++) {\n                for (int sx = 0; sx < neww; sx ++) {\n                        if (s[sy][sx] == -1) continue;\n                        long long res = s[sy][sx];\n                        vector<vector<bool>> used(newh, vector<bool>(neww, false));\n                        queue<state> q;\n                        q.push({sy, sx, 0});\n                        used[sy][sx] = true;\n                        while (!q.empty()) {\n                                state p = q.front(); q.pop();\n                                if (p.y != sy || p.x != sx) {\n                                        assert(s[p.y][p.x] != -1);\n                                        sum += (long long) p.step * res % MOD * s[p.y][p.x] % MOD;\n                                        //cerr << p.step << ' ' << res << ' ' << s[p.y][p.x] << endl;\n                                        sum %= MOD;\n                                }\n                                for (int d = 0; d < 4; d ++) {\n                                        int xx = p.x + dx[d], yy = p.y + dy[d];\n                                        if (xx < 0 || xx >= neww || yy < 0 || yy >= newh) continue;\n                                        if (used[yy][xx] || s[yy][xx] == -1) continue;\n                                        used[yy][xx] = true;\n                                        q.push({yy, xx, p.step + 1});\n                                }\n                        }\n                }\n        }\n        /*\n        const long long mil = 1000000;\n        ans += 2 * (mil - 1) * (mil - 1) % MOD;\n        ans %= MOD;\n        ans += (mil - 1) * (mil - 1) % MOD * (mil - 1);\n        ans %= MOD;\n        ans += (mil - 1) * (mil - 1) % MOD * (mil - 1);\n        */\n        sum *= (MOD + 1) / 2;\n        sum %= MOD;\n        ans += sum;\n        ans %= MOD;\n        printf(\"%lld\\n\", ans);\n        return 0;\n}\n\n"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\n\n#ifdef DEBUG\n#define debug(...) fprintf(stderr, __VA_ARGS__)\n#else\n#define debug(...)\n#endif\n\n#ifdef __WIN32\n#define LLFORMAT \"I64\"\n#define Rand() ((rand() << 15) + rand())\n#else\n#define LLFORMAT \"ll\"\n#define Rand() (rand())\n#endif\n\nusing namespace std;\n\nconst int maxn = 62, maxm = 1e6 + 10, mod = 1e9 + 7, dx[] = {-1, 0, 0, 1}, dy[] = {0, -1, 1, 0}, oo = 1e9, i2 = mod + 1 >> 1;\n\nint k, n, m, H, W, f[maxm], ans;\nset<pair<int, int> > blk;\nvector<int> allx, ally;\npriority_queue<pair<pair<int, int>, pair<pair<int, int>, int> >, vector<pair<pair<int, int>, pair<pair<int, int>, int> > >, greater<pair<pair<int, int>, pair<pair<int, int>, int> > > > heap;\npair<int, int> d[maxn][maxn][4];\n\nstruct rect {\n\tint x1, y1, x2, y2;\n\tbool blk;\n\n\trect() { blk = 0; }\n\trect(int x1, int y1, int x2, int y2): x1(x1), y1(y1), x2(x2), y2(y2) { blk = 0; }\n\n\tinline void get(int t, int &x, int &y) const {\n\t\tx = t & 2 ? x1 : x2;\n\t\ty = t & 1 ? y1 : y2;\n\t\treturn;\n\t}\n} rng[maxn][maxn];\n\nint F(int l) {\n\tif(~f[l]) {\n\t\treturn f[l];\n\t}\n\tint &x = f[l];\n\tif(l <= 1) {\n\t\treturn x = 0;\n\t}\n\treturn x = ((long long) l * (l - 1) + F(l - 1)) % mod;\n}\n\nint F(int l, int d, int a, int b) {\n\treturn ((((long long) a * (a - 1) % mod * b + (long long) b * (b - 1) % mod * a) % mod * i2 + (long long) a * b % mod * d) % mod * l % mod * l + (long long) F(l) * a % mod * b) % mod;\n}\n\nint F(int n, int m) {\n\tif(!m) {\n\t\treturn 0;\n\t}\n\tif(m == 1) {\n\t\treturn (long long) F(n) * i2 % mod;\n\t}\n\tif(m & 1) {\n\t\treturn ((long long) F(n, m - 1) + (long long) F(1, n) + (long long) F(n, 1, m - 1, 1)) % mod;\n\t}\n\treturn (((long long) F(n, m >> 1) << 1) + (long long) F(n, 1, m >> 1, m >> 1)) % mod;\n}\n\nint D(int n, int m) {\n\treturn (long long) (m + n - 2) * n % mod * m % mod * i2 % mod;\n}\n\nint main() {\n\tmemset(f, -1, sizeof f);\n\tscanf(\"%d%d%d\", &H, &W, &k);\n\tallx.push_back(0);\n\tally.push_back(0);\n\tfor (int i = 1; i <= k; ++i) {\n\t\tint x, y;\n\t\tscanf(\"%d%d\", &x, &y);\n\t\tif(x + 1 < H) {\n\t\t\tallx.push_back(x + 1);\n\t\t}\n\t\tallx.push_back(x);\n\t\tif(y + 1 < W) {\n\t\t\tally.push_back(y + 1);\n\t\t}\n\t\tally.push_back(y);\n\t\tblk.insert(make_pair(x, y));\n\t}\n\tsort(allx.begin(), allx.end());\n\tsort(ally.begin(), ally.end());\n\tallx.resize(unique(allx.begin(), allx.end()) - allx.begin());\n\tally.resize(unique(ally.begin(), ally.end()) - ally.begin());\n\tn = allx.size();\n\tm = ally.size();\n\tallx.push_back(H);\n\tally.push_back(W);\n\tfor (int i = 0; i < n; ++i) {\n\t\tfor (int j = 0; j < m; ++j) {\n\t\t\tint x1, y1, x2, y2;\n\t\t\trng[i][j] = rect(x1 = allx[i], y1 = ally[j], x2 = allx[i + 1] - 1, y2 = ally[j + 1] - 1);\n\t\t\tif(x1 == x2 && y1 == y2 && blk.find(make_pair(x1, y1)) != blk.end()) {\n\t\t\t\trng[i][j].blk = 1;\n\t\t\t}\n\t\t}\n\t}\n\tfor (int i = 0; i < n; ++i) {\n\t\tfor (int j = 0; j < m; ++j) {\n\t\t\tif(rng[i][j].blk) {\n\t\t\t\tcontinue;\n\t\t\t}\n\t\t\tans = (F(rng[i][j].x2 - rng[i][j].x1 + 1, rng[i][j].y2 - rng[i][j].y1 + 1) + ans) % mod;\n\t\t\tfor (int a = 0; a < n; ++a) {\n\t\t\t\tfor (int b = 0; b < m; ++b) {\n\t\t\t\t\tfor (int c = 0; c < 4; ++c) {\n\t\t\t\t\t\td[a][b][c] = make_pair(oo, -1);\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t}\n\t\t\tfor (int c = 0; c < 4; ++c) {\n\t\t\t\theap.push(make_pair(d[i][j][c] = make_pair(0, c), make_pair(make_pair(i, j), c)));\n\t\t\t}\n\t\t\twhile(!heap.empty()) {\n\t\t\t\tauto &T = heap.top();\n\t\t\t\tint i = T.second.first.first, j = T.second.first.second, k = T.second.second;\n\t\t\t\tauto t = T.first;\n\t\t\t\theap.pop();\n\t\t\t\tif(t != d[i][j][k]) {\n\t\t\t\t\tcontinue;\n\t\t\t\t}\n\t\t\t\tint x1, y1;\n\t\t\t\trng[i][j].get(k, x1, y1);\n\t\t\t\tfor (int dir = 0; dir < 4; ++dir) {\n\t\t\t\t\tint x = i + dx[dir], y = j + dy[dir];\n\t\t\t\t\tif(x >= 0 && y >= 0 && x < n && y < m && !rng[x][y].blk) {\n\t\t\t\t\t\tfor (int c = 0; c < 4; ++c) {\n\t\t\t\t\t\t\tint x2, y2, s;\n\t\t\t\t\t\t\trng[x][y].get(c, x2, y2);\n\t\t\t\t\t\t\ts = t.first + abs(x2 - x1) + abs(y2 - y1);\n\t\t\t\t\t\t\tif(s < d[x][y][c].first) {\n\t\t\t\t\t\t\t\theap.push(make_pair(d[x][y][c] = make_pair(s, t.second), make_pair(make_pair(x, y), c)));\n\t\t\t\t\t\t\t}\n\t\t\t\t\t\t}\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t}\n\t\t\tfor (int a = 0; a <= i; ++a) {\n\t\t\t\tfor (int b = 0; b < m; ++b) {\n\t\t\t\t\tif(a == i && b == j) {\n\t\t\t\t\t\tbreak;\n\t\t\t\t\t}\n\t\t\t\t\tif(!rng[a][b].blk) {\n\t\t\t\t\t\tint c = 0;\n\t\t\t\t\t\tfor (int cc = 0; cc < 4; ++cc) {\n\t\t\t\t\t\t\tif(d[a][b][cc] < d[a][b][c]) {\n\t\t\t\t\t\t\t\tc = cc;\n\t\t\t\t\t\t\t}\n\t\t\t\t\t\t}\n\t\t\t\t\t\tint k = d[a][b][c].second, dst = d[a][b][c].first, x1, y1, x2, y2;\n\t\t\t\t\t\trng[i][j].get(k, x1, y1);\n\t\t\t\t\t\trng[a][b].get(c, x2, y2);\n\t\t\t\t\t\tif(dst == abs(x1 - x2) + abs(y1 - y2)) {\n\t\t\t\t\t\t\tif(i == a) {\n\t\t\t\t\t\t\t\tans = (F(rng[i][j].x2 - rng[i][j].x1 + 1, j < b ? rng[a][b].y1 - rng[i][j].y2 : rng[i][j].y1 - rng[a][b].y2, rng[i][j].y2 - rng[i][j].y1 + 1, rng[a][b].y2 - rng[a][b].y1 + 1) + ans) % mod;\n\t\t\t\t\t\t\t\tcontinue;\n\t\t\t\t\t\t\t}\n\t\t\t\t\t\t\tif(j == b) {\n\t\t\t\t\t\t\t\tans = (F(rng[i][j].y2 - rng[i][j].y1 + 1, rng[i][j].x1 - rng[a][b].x2, rng[i][j].x2 - rng[i][j].x1 + 1, rng[a][b].x2 - rng[a][b].x1 + 1) + ans) % mod;\n\t\t\t\t\t\t\t\tcontinue;\n\t\t\t\t\t\t\t}\n\t\t\t\t\t\t}\n\t\t\t\t\t\tx1 = rng[i][j].x2 - rng[i][j].x1 + 1;\n\t\t\t\t\t\ty1 = rng[i][j].y2 - rng[i][j].y1 + 1;\n\t\t\t\t\t\tx2 = rng[a][b].x2 - rng[a][b].x1 + 1;\n\t\t\t\t\t\ty2 = rng[a][b].y2 - rng[a][b].y1 + 1;\n\t\t\t\t\t\tint s1 = (long long) x1 * y1 % mod, s2 = (long long) x2 * y2 % mod;\n\t\t\t\t\t\tans = ((long long) D(x1, y1) * s2 + (long long) D(x2, y2) * s1 + (long long) dst * s1 % mod * s2 + (long long) ans) % mod;\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t}\n\tprintf(\"%d\\n\", ans);\n\treturn 0;\n}\n"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\n\nusing namespace std;\n\n#ifdef DEBUG_MODE\n\t#define DBG(n) n;\n#else\n\t#define DBG(n) ;\n#endif\n#define REP(i,n) for(ll (i) = (0);(i) < (n);++i)\n#define PB push_back\n#define MP make_pair\n#define FI first\n#define SE second\n#define SHOW1d(v,n) {for(int W = 0;W < (n);W++)cerr << v[W] << ' ';cerr << endl << endl;}\n#define SHOW2d(v,i,j) {for(int aaa = 0;aaa < i;aaa++){for(int bbb = 0;bbb < j;bbb++)cerr << v[aaa][bbb] << ' ';cerr << endl;}cerr << endl;}\n#define ALL(v) v.begin(),v.end()\n#define Decimal fixed<<setprecision(20)\n#define INF 1000000000\n#define LLINF 1000000000000000000\n#define MOD 1000000007\n\ntypedef long long ll;\ntypedef pair<ll,ll> P;\n\nlong long mod_div(long long a,long long b){\n\tif(a % b == 0)return a/b;\n\tlong long tmp = MOD - 2,c = b,ret = 1;\n\twhile(tmp > 0){\n\t\tif(tmp & 1){\n\t\t\tret *= c;ret %= MOD;\n\t\t}\n\t\tc *= c;c %= MOD;tmp >>= 1;\n\t}\n\treturn a*ret%MOD;\n}\n\nint n,h,w;\nll ans,distSum;\nvector<pair<ll,ll>> v;\nvector<ll> xx;\nvector<ll> yy;\n\nbool mp[111][111];\nbool used[111][111];\nll dx[] = {1,0,-1,0};\nll dy[] = {0,1,0,-1};\nll couX[111];\nll couY[111];\n\nvoid seicaAdd(ll &a,ll &b){\n\ta += b;\n\tif(a >= MOD)a -= MOD;\n}\n\nvoid makeTable(){\n\tyy.PB(0);\n\tyy.PB(h);\n\txx.PB(0);\n\txx.PB(w);\n\t\n\tREP(i,n){\n\t\txx.PB(max(0LL,v[i].FI));\n\t\txx.PB(max(0LL,v[i].FI+1));\n\t\tyy.PB(max(0LL,v[i].SE));\n\t\tyy.PB(max(0LL,v[i].SE+1));\n\t}\n\t\n\tsort(ALL(xx));\n\tsort(ALL(yy));\n\t\n\txx.erase(unique(ALL(xx)),xx.end());\n\tyy.erase(unique(ALL(yy)),yy.end());\n\t\n\tREP(i,n){\n\t\tint x = lower_bound(ALL(xx),v[i].FI) - xx.begin();\n\t\tint y = lower_bound(ALL(yy),v[i].SE) - yy.begin();\n\t\tmp[y][x] = true;\n\t\tcouX[x]++;\n\t\tcouY[y]++;\n\t}\t\n\t\t\n\tll blackSum = 0;\n\tll pointer = 0;\n\tREP(i,w){\n\t\tif(i == xx[pointer]){\n\t\t\tblackSum += couX[pointer];\n\t\t\tpointer++;\n\t\t}\n\t\telse{\n\t\t\tll A = ((h * i % MOD) - blackSum + MOD) % MOD;\n\t\t\tll B = ((h * (w - i) % MOD) - (n - blackSum) + MOD) % MOD;\n\t\t\tll tmp = A * B % MOD;\n\t\t\tseicaAdd(ans,tmp);\n\t\t}\n\t}\n\t\n\tblackSum = 0;\n\tpointer = 0;\n\tREP(i,h){\n\t\tif(i == yy[pointer]){\n\t\t\tblackSum += couY[pointer];\n\t\t\tpointer++;\n\t\t}\n\t\telse{\n\t\t\tll A = ((w * i % MOD) - blackSum + MOD) % MOD;\n\t\t\tll B = ((w * (h - i\t) % MOD) - (n - blackSum) + MOD) % MOD;\n\t\t\tll tmp = A * B % MOD;\n\t\t\tseicaAdd(ans,tmp);\n\t\t}\n\t}\n}\n\nint main(){\n\t\n\tcin >> h >> w >> n;\n\tREP(i,n){\n\t\tint a,b;cin >> a >> b;\n\t\tv.PB(MP(b,a));\n\t}\n\t\n\tmakeTable();\n\t\n\tREP(i,yy.size()-1){\n\t\tREP(j,xx.size()-1){\n\t\t\tif(!mp[i][j]){\n\t\t\t\tREP(ii,111)REP(jj,111)used[ii][jj] = false;\n\t\t\t\tll nowMul = ((yy[i+1] - yy[i]) * (xx[j+1] - xx[j])) % MOD;\n\t\t\t\tqueue<pair<pair<ll,ll>,ll>> que;\n\t\t\t\tque.push(MP(MP(i,j),0));\n\t\t\t\tused[i][j] = true;\n\t\t\t\twhile(!que.empty()){\n\t\t\t\t\tauto now = que.front();que.pop();\n\t\t\t\t\tnow.SE++;\n\t\t\t\t\tREP(k,4){\n\t\t\t\t\t\tll y = now.FI.FI + dy[k];\n\t\t\t\t\t\tll x = now.FI.SE + dx[k];\n\t\t\t\t\t\tif(x < 0 || y < 0 || x >= xx.size() - 1 || y >= yy.size() - 1)continue;\n\t\t\t\t\t\tif(mp[y][x] || used[y][x])continue;\n\t\t\t\t\t\tll thisMul = (yy[y+1] - yy[y]) * (xx[x+1] - xx[x]) % MOD;\n\t\t\t\t\t\tll tmp = (((nowMul * thisMul) % MOD) * now.SE) % MOD;\n\t\t\t\t\t\tseicaAdd(distSum,tmp);\t\n\t\t\t\t\t\tque.push(MP(MP(y,x),now.SE));\n\t\t\t\t\t\tused[y][x] = true;\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t}\n\tdistSum = mod_div(distSum,2);\n\tcout << (ans + distSum) % MOD << endl;\n\t\n\treturn 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\nusing namespace std;\n#define int long long\n#define p (int)(1e9 + 7)\n\nint MOD(int a){\n\treturn (a %= p) >= 0 ? a : a + p;\n}\n\nint power(int a, int N){\n\tif(N == 0){\n\t\treturn 1;\n\t}\n\telse if(N % 2 == 0){\n\t\treturn power(MOD(a * a), N / 2);\n\t}\n\telse{\n\t\treturn MOD(a * power(a, N - 1));\n\t}\n}\n\nint inverse(int a){\n\treturn power(a, p - 2);\n}\n\n#define inf (int)(1e9)\n\nstruct edge{\n\tint to;\n\tint cost;\n\n\tedge(int to, int cost) : to(to), cost(cost){}\n};\n\nvector<int> dijkstra(vector<vector<edge> > &g, int s){\n\tvector<int> ans(g.size(), inf);\n\tpriority_queue<pair<int, int>, vector<pair<int, int> >, greater<pair<int, int> > > q;//(距離, 頂点番号)\n\tq.push(pair<int, int>(0, s));\n\twhile(q.size() > 0){\n\t\tint dis = q.top().first, v = q.top().second;\n\t\tq.pop();\n\t\tif(dis < ans[v]){\n\t\t\tans[v] = dis;\n\t\t\tfor(int i = 0; i < g[v].size(); i++){\n\t\t\t\tq.push(pair<int, int>(dis + g[v][i].cost, g[v][i].to));\n\t\t\t}\n\t\t}\n\t}\n\treturn ans;\n}\n\nint h, w;\nint inv2, inv6;\n\nint align(int i, int j){\n\treturn i * w + j;\n}\n\nint calc(int dis, int x1, int dx1, int x2, int dx2, int y1, int dy1, int y2, int dy2){\n//\tprintf(\"calc(%lld, %lld, %lld, %lld, %lld, %lld, %lld, %lld, %lld)\\n\", dis, x1, dx1, x2, dx2, y1, dy1, y2, dy2);\n\tif(x2 < x1){\n\t\treturn calc(dis, x2, dx2, x1, dx1, y2, dy2, y1, dy1);\n\t}\n\telse if(y2 < y1){\n\t\treturn calc(dis + dx2 - dx1, x1, dx2, x2 + dx2 - dx1, dx1, y2, dy2, y1, dy1);\n\t}\n\telse if(x1 == x2){\n\t\treturn calc(dis, y1, dy1, y2, dy2, x1, dx1, x2, dx2);\n\t}\n\tif(y1 == y2){\n\t\tif(dy1 == 1){\n//\t\t\tprintf(\"test1\\n\");\n\t\t\treturn MOD(inv2 * MOD(MOD(dx1 * dx2) * (2 * dis + (dx2 - dx1))));\n\t\t}\n\t\telse{\n//\t\t\tprintf(\"test2\\n\");\n\t\t\treturn MOD(inv6 * MOD(MOD(MOD(dx1 * dx2) * dy1) * (MOD(3 * dy1 * (2 * (x2 - x1) + (dx2 - dx1))) + MOD(2 * (dy1 - 1) * (dy1 + 1)))));\n\t\t}\n\t}\n\telse{\n//\t\tprintf(\"test3\\n\");\n\t\treturn MOD(inv2 * MOD(MOD(MOD(dx1 * dx2) * MOD(dy1 * dy2)) * MOD(2 * dis + (dx2 - dx1) + (dy2 - dy1))));\n\t}\n}\n\nsigned main(){\n\tint H, W, N, i, j, k, l;\n\tscanf(\"%lld%lld\", &H, &W);\n\tscanf(\"%lld\", &N);\n\tvector<int> x_sub(N), y_sub(N), x(0), y(0);\n\tfor(i = 0; i < N; i++){\n\t\tscanf(\"%lld%lld\", &x_sub[i], &y_sub[i]);\n\t\tx.push_back(x_sub[i]);\n\t\tx.push_back(x_sub[i] + 1);\n\t\tx.push_back(max(0ll, x_sub[i] - 1));\n\t\ty.push_back(y_sub[i]);\n\t\ty.push_back(y_sub[i] + 1);\n\t\ty.push_back(max(0ll, y_sub[i] - 1));\n\t}\n\tx.push_back(0);\n\tx.push_back(H);\n\ty.push_back(0);\n\ty.push_back(W);\n\tsort(x.begin(), x.end());\n\tsort(y.begin(), y.end());\n\tfor(i = 1, j = 1; j < x.size(); j++){\n\t\tif(x[j - 1] < x[j]){\n\t\t\tx[i] = x[j];\n\t\t\ti++;\n\t\t}\n\t}\n\th = i - 1;\n\tfor(i = 1, j = 1; j < y.size(); j++){\n\t\tif(y[j - 1] < y[j]){\n\t\t\ty[i] = y[j];\n\t\t\ti++;\n\t\t}\n\t}\n\tw = i - 1;\n\tvector<int> dx(h), dy(w);\n\tfor(i = 0; i < h; i++){\n\t\tdx[i] = x[i + 1] - x[i];\n\t}\n\tfor(i = 0; i < w; i++){\n\t\tdy[i] = y[i + 1] - y[i];\n\t}\n/*\tprintf(\"x:\\n\");\n\tfor(i = 0; i < h; i++){\n\t\tprintf(\"%lld \", x[i]);\n\t}\n\tprintf(\"\\n\");\n\tprintf(\"dx:\\n\");\n\tfor(i = 0; i < h; i++){\n\t\tprintf(\"%lld \", dx[i]);\n\t}\n\tprintf(\"\\n\");\n\tprintf(\"y:\\n\");\n\tfor(j = 0; j < w; j++){\n\t\tprintf(\"%lld \", y[j]);\n\t}\n\tprintf(\"\\n\");\n\tprintf(\"dy:\\n\");\n\tfor(i = 0; i < w; i++){\n\t\tprintf(\"%lld \", dy[i]);\n\t}\n\tprintf(\"\\n\");\n*/\tvector<vector<char>> A(h, vector<char>(w, '.'));\n\tfor(i = 0; i < h; i++){\n\t\tfor(j = 0; j < w; j++){\n\t\t\tfor(k = 0; k < N; k++){\n\t\t\t\tif(x[i] == x_sub[k] && y[j] == y_sub[k]){\n\t\t\t\t\tA[i][j] = '#';\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t}\n/*\tprintf(\"A:\\n\");\n\tfor(i = 0; i < h; i++){\n\t\tfor(j = 0; j < w; j++){\n\t\t\tprintf(\"%c\", A[i][j]);\n\t\t}\n\t\tprintf(\"\\n\");\n\t}\n\tprintf(\"\\n\");\n*/\n/*\tvector<vector<edge>> g(h * w, vector<edge>());\n\tfor(i = 0; i < h; i++){\n\t\tfor(j = 1; j < w; j++){\n\t\t\tif(A[i][j - 1] == '.' && A[i][j] == '.'){\n\t\t\t\tg[align(i, j - 1)].push_back(edge(align(i, j), y[j] - y[j - 1]));\n\t\t\t\tg[align(i, j)].push_back(edge(align(i, j - 1), y[j] - y[j - 1]));\n\t\t\t}\n\t\t}\n\t}\n\tfor(i = 1; i < h; i++){\n\t\tfor(j = 0; j < w; j++){\n\t\t\tif(A[i - 1][j] == '.' && A[i][j] == '.'){\n\t\t\t\tg[align(i - 1, j)].push_back(edge(align(i, j), x[i] - x[i - 1]));\n\t\t\t\tg[align(i, j)].push_back(edge(align(i - 1, j), x[i] - x[i - 1]));\n\t\t\t}\n\t\t}\n\t}\n*/\tvector<vector<int>> dis(h, vector<int>(w, inf));\n\tint ans = 0;\n\tinv2 = inverse(2);\n\tinv6 = inverse(6);\n\tfor(i = 0; i < h; i++){\n\t\tfor(j = 0; j < w; j++){\n\t\t\tif(A[i][j] == '#'){\n\t\t\t\tcontinue;\n\t\t\t}\n//\t\t\tprintf(\"(i, j) = (%lld, %lld)\\n\", i, j);\n\t\t\tint sub = MOD(inv6 * MOD(MOD(dx[i] * dy[j]) * MOD((dx[i] + dy[j]) * MOD(dx[i] * dy[j] - 1))));\n//\t\t\tprintf(\"ans += 2 * %lld\\n\", sub);\n\t\t\tans = MOD(ans + sub);\n\t\t\tfor(k = 0; k < h; k++){\n\t\t\t\tfor(l = 0; l < w; l++){\n\t\t\t\t\tdis[k][l] = inf;\n\t\t\t\t}\n\t\t\t}\n\t\t\tqueue<pair<pair<int, int>, int>> q;\n\t\t\tq.push(pair<pair<int, int>, int>(pair<int, int>(i, j), 0));\n\t\t\twhile(q.size() > 0){\n\t\t\t\tk = q.front().first.first;\n\t\t\t\tl = q.front().first.second;\n\t\t\t\tint d = q.front().second;\n\t\t\t\tq.pop();\n\t\t\t\tif(k < 0 || h <= k || l < 0 || w <= l || A[k][l] == '#' || dis[k][l] <= d){\n\t\t\t\t\tcontinue;\n\t\t\t\t}\n\t\t\t\tdis[k][l] = d;\n\t\t\t\tif(l < w - 1){\n\t\t\t\t\tq.push(pair<pair<int, int>, int>(pair<int, int>(k + 0, l + 1), d + dy[l]));\n\t\t\t\t}\n\t\t\t\tif(k < h - 1){\n\t\t\t\t\tq.push(pair<pair<int, int>, int>(pair<int, int>(k + 1, l + 0), d + dx[k]));\n\t\t\t\t}\n\t\t\t\tif(l > 0){\n\t\t\t\t\tq.push(pair<pair<int, int>, int>(pair<int, int>(k + 0, l - 1), d + dy[l - 1]));\n\t\t\t\t}\n\t\t\t\tif(k > 0){\n\t\t\t\t\tq.push(pair<pair<int, int>, int>(pair<int, int>(k - 1, l + 0), d + dx[k - 1]));\n\t\t\t\t}\n\t\t\t}\n//\t\t\tvector<int> dis = dijkstra(g, align(i, j));\n\t\t\tfor(k = 0; k < h; k++){\n\t\t\t\tfor(l = 0; l < w; l++){\n\t\t\t\t\tif(k < i || (i == k && l <= j) || A[k][l] == '#'){\n\t\t\t\t\t\tcontinue;\n\t\t\t\t\t}\n//\t\t\t\t\tprintf(\"(k, l) = (%lld, %lld)\\n\", k, l);\n\t\t\t\t\tint res = calc(dis[k][l], x[i], dx[i], x[k], dx[k], y[j], dy[j], y[l], dy[l]);\n//\t\t\t\t\tprintf(\"ans += %lld\\n\", res);\n\t\t\t\t\tans = MOD(ans + res);\n\t\t\t\t}\n\t\t\t}\n//\t\t\tprintf(\"\\n\");\n\t\t}\n\t}\n//\tans = MOD(ans * inv2);\n\tprintf(\"%lld\\n\", ans);\n\treturn 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\n\nusing namespace std;\n\n#define fi first\n#define se second\n#define mp make_pair\n#define pb push_back\n#define all(x) (x).begin (),(x).end()\n#define sqrt(x) sqrt(abs(x))\n#define re return\n#define sz(x) ((int)(x).size ())\n#define prev PREV\n#define next NEXT\n\nusing ll = long long;\nusing ii = pair<int, int>;\nusing ld = long double;\nusing D = double;\nusing vi = vector<int>;\nusing vii = vector<ii>;\nusing vvi = vector<vi>;\nusing vs = vector<string>;\n\ntemplate<typename T> T abs (T x) { re x < 0 ? -x : x; }\ntemplate<typename T> T sgn (T x) { re x < 0 ? -1 : (x > 0 ? 1 : 0); }\ntemplate<typename T> T sqr (T x) { re x * x; }\ntemplate<typename T> T gcd (T a, T b) { re a ? gcd (b % a, a) : b; }\n\nconst int mod = 1000*1000*1000+7;\nint rev2;\nint rev3;\nint rev6;\n\nint n;\nint m;\n\nmap<ii, int> num;\nii rct[15000];\nint d[15000];\nint mark[15000];\nint xx[15000];\nint yy[15000];\nint x[30];\nint y[30];\nint g[61][61][2][2];\nii gc[61][61][2][2];\nint bad[61][61];\nvii wx, wy;\nvi vx, vy;\nint o;\npriority_queue<ii> all;\nint q;\nset<ii> pts;\n\nvii build (vi v, int n) {\n\tvii w;\n\tif (v[0] > 0) w.pb (mp (0, v[0] - 1));\n\tfor (int i = 0; i + 1 < sz (v); i++)\n\t\tif (v[i] + 1 < v[i + 1])\n\t\t\tw.pb (mp (v[i] + 1, v[i + 1] - 1));\n\tif (v[sz (v) - 1] + 1 < n)\n\t\tw.pb (mp (v[sz (v) - 1] + 1, n - 1));\n\tfor (int i = 0; i < sz (v); i++) w.pb (mp (v[i], v[i]));\n\tsort (all (w));\n\tre w;\n}\n\nint get (int x, int y, int i, int j) {\n\tif (num.find (mp (x, y)) != num.end ()) re num[mp (x, y)];\n\txx[o] = x;\n\tyy[o] = y;\n\trct[o] = mp (i, j);\n\tnum[mp (x, y)] = o;\n\to++;\n\tre o - 1;\n}\n\nint bar;\n\nvoid upd (int i, int j) {\n\tif (rct[i].fi > bar) re;\n\tif (d[i] > j) {\n\t\td[i] = j;\n\t\tmark[i] = 1;\n\t\tall.push (mp (-d[i], i));\n\t}\n}\n\nint c2c (int a) {\n\tre ((ll)(a - 1) * a % mod * (a + 1) % mod * rev3) % mod;\n}\n\nint self (int a, int b) {\n\tre ((ll)c2c (a) * b % mod * b + (ll)c2c (b) * a % mod * a) % mod;\n}\n\nint same (int a, int b, int c, int dist) {\n//\tprintf (\"same %d %d %d %d\\n\", a, b, c, dist);\n\tre ((ll)c2c (a) * b % mod * c % mod + (ll)a * a % mod * b % mod * c % mod * (2 * dist + (b + c - 2)) % mod * rev2 % mod) % mod;\n}\n\nint diff (int a, int b, int c, int d, int dist) {\n\tre ((ll)a * b % mod * c % mod * d % mod * (a + b + c + d - 4 + 2 * dist) % mod * rev2) % mod;\n}\n\nint power (int a, int b) {\n\tint c = 1;\n\twhile (b) {\n\t\tif (b & 1) c = ((ll)c * a) % mod;\n\t\ta = ((ll)a * a) % mod;\n\t\tb /= 2;\n\t}\n\tre c;\n}\n\nint main () {\n\trev2 = power (2, mod - 2);\n\trev3 = power (3, mod - 2);\n\trev6 = power (6, mod - 2);\n\tscanf (\"%d%d\", &n, &m);\n\tscanf (\"%d\", &q);\n\tfor (int i = 0; i < q; i++) {\n\t\tscanf (\"%d%d\", &x[i], &y[i]);\n\t\tpts.insert (mp (x[i], y[i]));\n\t\tvx.pb (x[i]);\n\t\tvy.pb (y[i]);\n\t}\n\tsort (all (vx));\n\tsort (all (vy));\n\tvx.resize (unique (all (vx)) - vx.begin ());\n\tvy.resize (unique (all (vy)) - vy.begin ());\n\twx = build (vx, n);\n\twy = build (vy, m);\n\tint nx = sz (wx);\n\tint ny = sz (wy);\n\tfor (int i = 0; i < nx; i++)\n\t\tfor (int j = 0; j < ny; j++) {\n\t\t\tbad[i][j] = 1;\n\t\t\tif (wx[i].fi == wx[i].se && wy[j].fi == wy[j].se && pts.count (mp (wx[i].fi, wy[j].fi))) continue;\n\t\t\tbad[i][j] = 0;\n\t\t\tfor (int a = 0; a < 2; a++)\n\t\t\t\tfor (int b = 0; b < 2; b++) {\n\t\t\t\t\tgc[i][j][a][b] = mp (wx[i].fi + (wx[i].se - wx[i].fi) * a, wy[j].fi + (wy[j].se - wy[j].fi) * b);\n\t\t\t\t\tg[i][j][a][b] = get (wx[i].fi + (wx[i].se - wx[i].fi) * a, wy[j].fi + (wy[j].se - wy[j].fi) * b, i, j);\n\t\t\t\t}\n\t\t}\n//\tprintf (\"%d\\n\", o);\n\tint ans = 0;\n\tfor (int ii = 0; ii < nx; ii++)\n\t\tfor (int jj = 0; jj < ny; jj++) {\n\t\t\tif (bad[ii][jj]) continue;\n//\t\t\tprintf (\"%d %d\\n\", wx[ii].se - wx[ii].fi + 1, wy[jj].se - wy[jj].fi + 1);\n\t\t\tans = (ans + (ll)self (wx[ii].se - wx[ii].fi + 1, wy[jj].se - wy[jj].fi + 1) * rev2) % mod;\n\t\t\tfor (int j = 0; j < o; j++) {\n\t\t\t\td[j] = 1e9;\n\t\t\t\tmark[j] = 0;\n\t\t\t}\n\t\t\twhile (!all.empty ()) all.pop ();\n\t\t\tfor (int a = 0; a < 2; a++)\n\t\t\t\tfor (int b = 0; b < 2; b++)\n\t\t\t\t\tif (!mark[g[ii][jj][a][b]]) {\n\t\t\t\t\t\td[g[ii][jj][a][b]] = 0;\n\t\t\t\t\t\tmark[g[ii][jj][a][b]] = 1;\n\t\t\t\t\t\tall.push (mp (0, g[ii][jj][a][b]));\n\t\t\t\t\t}\n\t\t\tbar = ii + 1;\n\t\t\twhile (bar < nx && wx[bar].fi == wx[bar].se) bar++;\n\t\t\twhile (!all.empty ()) {\n\t\t\t\tint j = all.top ().se;\n\t\t\t\tall.pop ();\n\t\t\t\tif (mark[j] == 2) continue;\n\t\t\t\tmark[j] = 2;\n\t\t\t\tint cx = xx[j];\n\t\t\t\tint cy = yy[j];\n\t\t\t\tint p = rct[j].fi;\n\t\t\t\tint q = rct[j].se;\n\t\t\t\tint ca = int (cx == wx[p].se);\n\t\t\t\tint cb = int (cy == wy[q].se);\n\t\t\t\tfor (int a = 0; a < 2; a++)\n\t\t\t\t\tfor (int b = 0; b < 2; b++) {\n\t\t\t\t\t\tint nx = gc[p][q][a][b].fi;\n\t\t\t\t\t\tint ny = gc[p][q][a][b].se;\n\t\t\t\t\t\tupd (g[p][q][a][b], d[j] + abs (cx - nx) + abs (cy - ny));\n\t\t\t\t\t}\n\t\t\t\tif (cx == wx[p].fi && p > 0 && !bad[p - 1][q]) upd (g[p - 1][q][1][cb], d[j] + 1);\n\t\t\t\tif (cx == wx[p].se && p + 1 < nx && !bad[p + 1][q]) upd (g[p + 1][q][0][cb], d[j] + 1);\n\t\t\t\tif (cy == wy[q].fi && q > 0 && !bad[p][q - 1]) upd (g[p][q - 1][ca][1], d[j] + 1);\n\t\t\t\tif (cy == wy[q].se && q + 1 < ny && !bad[p][q + 1]) upd (g[p][q + 1][ca][0], d[j] + 1);\n\t\t\t}\n//\t\t\tprintf (\"self = %d\\n\", ans);\n\t\t\tfor (int pp = 0; pp < nx; pp++)\n\t\t\t\tfor (int qq = 0; qq < ny; qq++) {\n\t\t\t\t\tif (mp (pp, qq) > mp (ii, jj)) continue;\n\t\t\t\t\tif (bad[pp][qq]) continue;\n\t\t\t\t\tint dist = 1e9;\n\t\t\t\t\tfor (int a = 0; a < 2; a++)\n\t\t\t\t\t\tfor (int b = 0; b < 2; b++)\n\t\t\t\t\t\t\tdist = min (dist, d[g[pp][qq][a][b]]);\n\t\t\t\t\tif (dist == 0) continue;\n\t\t\t\t\tif (pp == ii) ans = (ans + same (wx[ii].se - wx[ii].fi + 1, wy[jj].se - wy[jj].fi + 1, wy[qq].se - wy[qq].fi + 1, dist)) % mod; else\n\t\t\t\t\tif (qq == jj) ans = (ans + same (wy[jj].se - wy[jj].fi + 1, wx[ii].se - wx[ii].fi + 1, wx[pp].se - wx[pp].fi + 1, dist)) % mod; else\n\t\t\t\t\t\t\t\t  ans = (ans + diff (wx[ii].se - wx[ii].fi + 1, wy[jj].se - wy[jj].fi + 1, wx[pp].se - wx[pp].fi + 1, wy[qq].se - wy[qq].fi + 1, dist)) % mod;\n//\t\t\t\t\tprintf (\"%d %d - %d %d = %d = %d\\n\", ii, jj, pp, qq, ans, dist);\n\t\t\t\t}\n\t\t}\n\tcout << ((ll)ans) % mod << endl;\n\tcerr << clock () << endl;\n\treturn 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\n\n#ifdef DEBUG\n#define debug(...) fprintf(stderr, __VA_ARGS__)\n#else\n#define debug(...)\n#endif\n\n#ifdef __WIN32\n#define LLFORMAT \"I64\"\n#define Rand() ((rand() << 15) + rand())\n#else\n#define LLFORMAT \"ll\"\n#define Rand() (rand())\n#endif\n\nusing namespace std;\n\nconst int maxn = 62, maxm = 1e6 + 10, mod = 1e9 + 7, dx[] = {-1, 1, 0, 0}, dy[] = {0, 0, -1, 1}, oo = 1e9, i2 = mod + 1 >> 1;\n\nint k, n, m, H, W, f[maxm], ans, nn, mm;\nset<pair<int, int> > blk;\nvector<int> allx, ally;\npriority_queue<pair<pair<int, int>, pair<int, int> >, vector<pair<pair<int, int>, pair<int, int> > >, greater<pair<pair<int, int>, pair<int, int> > > > heap;\npair<int, int> d[100][100], id[maxn][maxn][4];\nint x[100][100], y[100][100], ex[100];\nbool ban[100][100], banx[100];\n\nstruct rect {\n\tint x1, y1, x2, y2;\n\tbool blk;\n\n\trect() { blk = 0; }\n\trect(int x1, int y1, int x2, int y2): x1(x1), y1(y1), x2(x2), y2(y2) { blk = 0; }\n\n\tinline void get(int t, int &x, int &y) const {\n\t\tx = t & 2 ? x2 : x1;\n\t\ty = t & 1 ? y2 : y1;\n\t\treturn;\n\t}\n} rng[maxn][maxn];\n\nint F(int l) {\n\tif(~f[l]) {\n\t\treturn f[l];\n\t}\n\tint &x = f[l];\n\tif(l <= 1) {\n\t\treturn x = 0;\n\t}\n\treturn x = ((long long) l * (l - 1) + F(l - 1)) % mod;\n}\n\nint F(int l, int d, int a, int b) {\n\treturn (((((long long) a * (a - 1) * b + (long long) b * (b - 1) * a) >> 1) + (long long) a * b * d) % mod * l % mod * l + (long long) F(l) * a % mod * b) % mod;\n}\n\nint F(int n, int m) {\n\tif(!m) {\n\t\treturn 0;\n\t}\n\tif(m == 1) {\n\t\treturn (long long) F(n) * i2 % mod;\n\t}\n\tif(m & 1) {\n\t\treturn ((long long) F(n, m - 1) + (long long) F(1, n) + (long long) F(n, 1, m - 1, 1)) % mod;\n\t}\n\treturn (((long long) F(n, m >> 1) << 1) + (long long) F(n, 1, m >> 1, m >> 1)) % mod;\n}\n\nint D(int n, int m) {\n\treturn (long long) (m + n - 2) * n % mod * m % mod * i2 % mod;\n}\n\nint main() {\n\tmemset(f, -1, sizeof f);\n\tscanf(\"%d%d%d\", &H, &W, &k);\n\tallx.push_back(0);\n\tally.push_back(0);\n\tfor (int i = 1; i <= k; ++i) {\n\t\tint x, y;\n\t\tscanf(\"%d%d\", &x, &y);\n\t\tif(x + 1 < H) {\n\t\t\tallx.push_back(x + 1);\n\t\t}\n\t\tallx.push_back(x);\n\t\tif(y + 1 < W) {\n\t\t\tally.push_back(y + 1);\n\t\t}\n\t\tally.push_back(y);\n\t\tblk.insert(make_pair(x, y));\n\t}\n\tsort(allx.begin(), allx.end());\n\tsort(ally.begin(), ally.end());\n\tallx.resize(unique(allx.begin(), allx.end()) - allx.begin());\n\tally.resize(unique(ally.begin(), ally.end()) - ally.begin());\n\tn = allx.size();\n\tm = ally.size();\n\tallx.push_back(H);\n\tally.push_back(W);\n\tfor (int i = 0; i < n; ++i) {\n\t\tfor (int j = 0; j < m; ++j) {\n\t\t\tint x1, y1, x2, y2;\n\t\t\trng[i][j] = rect(x1 = allx[i], y1 = ally[j], x2 = allx[i + 1] - 1, y2 = ally[j + 1] - 1);\n\t\t\tif(x1 == x2 && y1 == y2 && blk.find(make_pair(x1, y1)) != blk.end()) {\n\t\t\t\trng[i][j].blk = 1;\n\t\t\t}\n\t\t}\n\t}\n\tfor (int i = 0; i < n; ++i) {\n\t\tmm = 0;\n\t\tfor (int j = 0; j < m; ++j) {\n\t\t\tx[nn][mm] = rng[i][j].x1;\n\t\t\ty[nn][mm] = rng[i][j].y1;\n\t\t\tban[nn][mm] = rng[i][j].blk;\n\t\t\tid[i][j][0] = make_pair(nn, mm);\n\t\t\t++mm;\n\t\t\tif(rng[i][j].y2 > rng[i][j].y1) {\n\t\t\t\tx[nn][mm] = rng[i][j].x1;\n\t\t\t\ty[nn][mm] = rng[i][j].y2;\n\t\t\t\tban[nn][mm] = rng[i][j].blk;\n\t\t\t\tid[i][j][1] = make_pair(nn, mm);\n\t\t\t\t++mm;\n\t\t\t}\n\t\t\telse {\n\t\t\t\tid[i][j][1] = id[i][j][0];\n\t\t\t}\n\t\t}\n\t\t++nn;\n\t\tif(rng[i][0].x1 < rng[i][0].x2) {\n\t\t\tmm = 0;\n\t\t\tfor (int j = 0; j < m; ++j) {\n\t\t\t\tx[nn][mm] = rng[i][j].x2;\n\t\t\t\ty[nn][mm] = rng[i][j].y1;\n\t\t\t\tban[nn][mm] = rng[i][j].blk;\n\t\t\t\tid[i][j][2] = make_pair(nn, mm);\n\t\t\t\t++mm;\n\t\t\t\tif(rng[i][j].y2 > rng[i][j].y1) {\n\t\t\t\t\tx[nn][mm] = rng[i][j].x2;\n\t\t\t\t\ty[nn][mm] = rng[i][j].y2;\n\t\t\t\t\tban[nn][mm] = rng[i][j].blk;\n\t\t\t\t\tid[i][j][3] = make_pair(nn, mm);\n\t\t\t\t\t++mm;\n\t\t\t\t}\n\t\t\t\telse {\n\t\t\t\t\tid[i][j][3] = id[i][j][2];\n\t\t\t\t}\n\t\t\t}\n\t\t\t++nn;\n\t\t}\n\t\telse {\n\t\t\tfor (int j = 0; j < m; ++j) {\n\t\t\t\tid[i][j][2] = id[i][j][0];\n\t\t\t\tid[i][j][3] = id[i][j][1];\n\t\t\t}\n\t\t}\n\t}\n\tfor (int i = 0; i < nn; ++i) {\n\t\tfor (int j = 0; j < mm; ++j) {\n\t\t\tbanx[i] |= ban[i][j];\n\t\t}\n\t}\n\tfor (int i = 0; i < nn; ++i) {\n\t\tex[i] = i;\n\t\twhile(banx[ex[i]]) {\n\t\t\t++ex[i];\n\t\t}\n\t\tex[i] = min(ex[i], nn - 1);\n\t}\n\tfor (int i = 0; i < n; ++i) {\n\t\tfor (int j = 0; j < m; ++j) {\n\t\t\tif(rng[i][j].blk) {\n\t\t\t\tcontinue;\n\t\t\t}\n\t\t\tint lx = rng[i][j].x2 - rng[i][j].x1 + 1, ly = rng[i][j].y2 - rng[i][j].y1 + 1;\n\t\t\tans = (F(lx, ly) + ans) % mod;\n\t\t\tfor (int i = 0; i < nn; ++i) {\n\t\t\t\tfor (int j = 0; j < mm; ++j) {\n\t\t\t\t\td[i][j] = make_pair(oo, -1);\n\t\t\t\t}\n\t\t\t}\n\t\t\tint EX = -1;\n\t\t\tfor (int c = 0; c < 4; ++c) {\n\t\t\t\tauto &t = id[i][j][c];\n\t\t\t\theap.push(make_pair(d[t.first][t.second] = make_pair(0, c), make_pair(t.first, t.second)));\n\t\t\t\tEX = max(EX, ex[t.first]);\n\t\t\t}\n\t\t\twhile(!heap.empty()) {\n\t\t\t\tauto T = heap.top();\n\t\t\t\theap.pop();\n\t\t\t\tauto &t = T.first;\n\t\t\t\tint &i = T.second.first, &j = T.second.second;\n\t\t\t\tif(t != d[i][j]) {\n\t\t\t\t\tcontinue;\n\t\t\t\t}\n\t\t\t\tint &dd = t.first, &xx = x[i][j], &yy = y[i][j];\n\t\t\t\tfor (register int k = 0; k < 4; ++k) {\n\t\t\t\t\tregister int x = i + dx[k], y = j + dy[k];\n\t\t\t\t\tif(x >= 0 && y >= 0 && x <= EX && y < mm && !ban[x][y]) {\n\t\t\t\t\t\tregister int s = dd + (k < 2 ? abs(::x[x][y] - xx) : abs(::y[x][y] - yy));\n\t\t\t\t\t\tif(s < d[x][y].first) {\n\t\t\t\t\t\t\theap.push(make_pair(d[x][y] = make_pair(s, t.second), make_pair(x, y)));\n\t\t\t\t\t\t}\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t}\n\t\t\tfor (int a = 0; a <= i; ++a) {\n\t\t\t\tfor (int b = 0; b < m; ++b) {\n\t\t\t\t\tif(a == i && b == j) {\n\t\t\t\t\t\tbreak;\n\t\t\t\t\t}\n\t\t\t\t\tif(!rng[a][b].blk) {\n\t\t\t\t\t\tint c = 0;\n\t\t\t\t\t\tfor (int cc = 1; cc < 4; ++cc) {\n\t\t\t\t\t\t\tauto &t = id[a][b][cc], &s = id[a][b][c];\n\t\t\t\t\t\t\tif(d[t.first][t.second] < d[s.first][s.second]) {\n\t\t\t\t\t\t\t\tc = cc;\n\t\t\t\t\t\t\t}\n\t\t\t\t\t\t}\n\t\t\t\t\t\tauto &s = id[a][b][c];\n\t\t\t\t\t\tint k = d[s.first][s.second].second, dst = d[s.first][s.second].first, x1, y1, x2, y2;\n\t\t\t\t\t\trng[i][j].get(k, x1, y1);\n\t\t\t\t\t\trng[a][b].get(c, x2, y2);\n\t\t\t\t\t\tif(dst == abs(x1 - x2) + abs(y1 - y2)) {\n\t\t\t\t\t\t\tif(i == a) {\n\t\t\t\t\t\t\t\tans = (F(lx, j < b ? rng[a][b].y1 - rng[i][j].y2 : rng[i][j].y1 - rng[a][b].y2, ly, rng[a][b].y2 - rng[a][b].y1 + 1) + ans) % mod;\n\t\t\t\t\t\t\t\tcontinue;\n\t\t\t\t\t\t\t}\n\t\t\t\t\t\t\tif(j == b) {\n\t\t\t\t\t\t\t\tans = (F(ly, rng[i][j].x1 - rng[a][b].x2, lx, rng[a][b].x2 - rng[a][b].x1 + 1) + ans) % mod;\n\t\t\t\t\t\t\t\tcontinue;\n\t\t\t\t\t\t\t}\n\t\t\t\t\t\t}\n\t\t\t\t\t\tx1 = lx;\n\t\t\t\t\t\ty1 = ly;\n\t\t\t\t\t\tx2 = rng[a][b].x2 - rng[a][b].x1 + 1;\n\t\t\t\t\t\ty2 = rng[a][b].y2 - rng[a][b].y1 + 1;\n\t\t\t\t\t\tint s1 = (long long) x1 * y1 % mod, s2 = (long long) x2 * y2 % mod;\n\t\t\t\t\t\tans = ((long long) D(x1, y1) * s2 + (long long) D(x2, y2) * s1 + (long long) dst * s1 % mod * s2 + ans) % mod;\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t}\n\tprintf(\"%d\\n\", ans);\n\treturn 0;\n}\n"
  },
  {
    "language": "C++",
    "code": "#include<bits/stdc++.h>\n#define LL long long\n#define pb push_back\n#define mp make_pair\n#define pii pair<int,int>\nusing namespace std;\nnamespace IO\n{\n    const int sz=1<<15;\n    char inbuf[sz],outbuf[sz];\n    char *pinbuf=inbuf+sz;\n    char *poutbuf=outbuf;\n    inline char _getchar()\n    {\n        if (pinbuf==inbuf+sz)fread(inbuf,1,sz,stdin),pinbuf=inbuf;\n        return *(pinbuf++);\n    }\n    inline void _putchar(char x)\n    {\n        if (poutbuf==outbuf+sz)fwrite(outbuf,1,sz,stdout),poutbuf=outbuf;\n        *(poutbuf++)=x;\n    }\n    inline void flush()\n    {\n        if (poutbuf!=outbuf)fwrite(outbuf,1,poutbuf-outbuf,stdout),poutbuf=outbuf;\n    }\n}\ninline int read(){\n\tint v=0,f=1;\n\tchar c=getchar();\n\twhile (c<'0' || c>'9'){\n\t\tif (c=='-') f=-1;\n\t\tc=getchar();\n\t}\n\twhile (c>='0' && c<='9'){\n\t\tv=v*10+c-'0';\n\t\tc=getchar();\n\t}\n\treturn v*f;\n}\n\nconst int Maxn=35;\nconst int mod=1e9+7; \nconst int Maxm=1e6+5;\nconst int dx[]={0,0,1,-1};\nconst int dy[]={1,-1,0,0};\nint H,W;\nint ox[Maxm],oy[Maxm],cx[Maxm],cy[Maxm],Sx[Maxm],Sy[Maxm];\nint x[Maxn],y[Maxn],n;\nvector<int> hr,wr;\nint b[99][99],dist[99][99];\nint Wx[99],Wy[99];\nint qx[9999],qy[9999],sq,eq;\nint h=0,w=0;\nvoid Add(int &X,int Y){\n\tX+=Y;\n\tif (X>=mod) X%=mod;\n}\nint bfs(int x,int y){\n\tfor(int i=0;i<h;i++) for(int j=0;j<w;j++){\n\t\tdist[i][j]=-1;\n\t}\n\tint cf=1ll*Wx[x]*Wy[y]%mod;\n\tsq=eq=0;\n\tqx[eq]=x;qy[eq++]=y;\n\tdist[x][y]=0;\n\tint ret=0;\n\twhile (sq<eq){\n\t\tint X=qx[sq],Y=qy[sq++];\n\t\tfor (int i=0;i<4;i++){\n\t\t\tint nx=X+dx[i],ny=Y+dy[i];\n\t\t\tif (nx>=0 && ny>=0 && nx<h && ny<w){\n\t\t\t\tif (dist[nx][ny]==-1 && !b[nx][ny]){\n\t\t\t\t\tdist[nx][ny]=dist[X][Y]+1;\n\t\t\t\t\tAdd(ret,1ll*cf*Wx[nx]%mod*Wy[ny]%mod*dist[nx][ny]%mod);\n\t\t\t\t\tqx[eq]=nx;qy[eq++]=ny;\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t}\n\treturn ret;\n}\nint main(){\n\tH=read();W=read();n=read();\n\tfor (int i=1;i<=n;i++) x[i]=read(),y[i]=read(),x[i]++,y[i]++;\n\tox[1]=ox[H]=1;oy[1]=oy[W]=1;\n\tfor (int i=1;i<=n;i++){\n\t\tox[x[i]]=1;ox[x[i]-1]=1;ox[x[i]+1]=1;\n\t\toy[y[i]]=1;oy[y[i]-1]=1;oy[y[i]+1]=1;\n\t\tcx[x[i]]++;cy[y[i]]++;\n\t}\n\tfor (int i=1;i<=H;i++){\n\t\tSx[i]=Sx[i-1]+cx[i];\n\t}\n\tfor (int i=1;i<=W;i++){\n\t\tSy[i]=Sy[i-1]+cy[i];\n\t}\n\tint ans=0;\n\tint r=0;\n\tint bf=0;\n\tfor (int i=1;i<=H;i++){\n\t\tif(!ox[i]){\n\t\t\t//Add(ans,row);\n\t\t\tint lf=1ll*(i-1-r)*W%mod-Sx[i-1],rg=1ll*(H-i+1)*W%mod-(Sx[H]-Sx[i]);\n\t\t\tif (lf<0) lf+=mod;\n\t\t\tif (rg<0) rg+=mod;\n\t\t\tAdd(ans,1ll*lf*rg%mod);\n\t\t\tWx[h-1]++;\n\t\t}\n\t\telse{\n\t\t\th++;Wx[h-1]=1;hr.pb(i);\n\t\t}\n\t}\n\tr=0;\n\tfor (int i=1;i<=W;i++){\n\t\tif (!oy[i]){\n\t\t\t//Add(ans,col);\n\t\t\tint lf=1ll*(i-1-r)*H%mod-Sy[i-1],rg=1ll*(W-i+1)*H%mod-(Sy[W]-Sy[i]);\n\t\t\tif (lf<0) lf+=mod;\n\t\t\tif (rg<0) rg+=mod;  \n\t\t\tAdd(ans,1ll*lf*rg%mod);\n\t\t\tWy[w-1]++;\n\t\t}\n\t\telse{\n\t\t\tw++;Wy[w-1]=1;wr.pb(i);\n\t\t}\n\t}\n//\tcerr<<ans<<endl;\n\t//cerr<<h<<' '<<w<<\n//\tcerr<<w<<' '<<h<<endl;\n\tfor(int i=0;i<h;i++){\n\t\tfor (int j=0;j<w;j++){\n\t\t\tfor (int k=1;k<=n;k++){\n\t\t\t\tif (hr[i]==x[k] && wr[j]==y[k]) b[i][j]=1;\n\t\t\t}\n\t\t//\tcout<<b[i][j]<<' ';\n\t\t}\n\t//\tcout<<endl;\n\t}\n\t/*\n\tfor (int i=0;i<h;i++){\n\t\tfor (int j=0;j<w;j++){\n\t\t\tcout<<1ll*Wx[i]*Wy[j]%mod<<' ';\n\t\t}\n\t\tcout<<endl;\n\t}*/\n\tint ans2=0;\n\tfor (int i=0;i<h;i++){\n\t\tfor (int j=0;j<w;j++){\n\t\t\tif(!b[i][j]){\n\t\t\t//\tcerr<<i<<' '<<j<<endl;\n\t\t\t\tAdd(ans2,bfs(i,j));\n\t\t\t}\n\t\t}\n\t}\n\t//cerr<<ans2<<endl;\n\tif (ans2%2==0) ans2/=2;\n\telse ans2+=mod,ans2/=2;\n\tAdd(ans,ans2);\n\tprintf(\"%d\\n\",ans);\n\treturn 0;\n}\n/*\n4 4\n0\n*/"
  },
  {
    "language": "C++",
    "code": "#include <algorithm>\n#include <climits>\n#include <cmath>\n#include <cstdio>\n#include <cstdlib>\n#include <ctime>\n#include <iostream>\n#include <sstream>\n#include <functional>\n#include <map>\n#include <set>\n#include <unordered_map>\n#include <unordered_set>\n#include <bitset>\n#include <string>\n#include <cstring>\n#include <vector>\n#include <queue>\n#include <stack>\n#include <deque>\n#include <list>\n#include <numeric>\nusing namespace std;\ntypedef long long ll;\ntypedef unsigned long long ull;\ntypedef long double ld;\ntypedef pair<ll,ll> P;\ntypedef pair<P,ll> PPI;\ntypedef pair<ll,P> PIP;\ntypedef vector<ll> vl;\ntypedef vector<vl> vvl;\ntypedef vector<P> vp;\n#define PQ(T) priority_queue<T,vector<T>,greater<T>>\n#define PQ2(T) priority_queue<T>\nconst double PI = 3.14159265358979323846;\nconst double EPS = 1e-12;\nconst ll INF = 1LL<<59;\nconst ll mod = 1e9+7;\n#define REP(i,a,b) for(ll (i)=a;(i)<(ll)(b);++(i))\n#define rep(i,n) REP(i,0,n)\n#define rep1(i,n) REP(i,1,n+1)\n#define repd(i,n,d) for(ll (i)=0;(i)<(ll)(n);(i)+=(d))\n#define all(v) (v).begin(), (v).end()\n#define pb(x) push_back(x)\n#define mp(x,y) make_pair((x),(y))\n#define mset(m,v) memset((m),(v),sizeof(m))\n#define chmin(x,y) ((x)=min((x),(y)))\n#define chmax(x,y) ((x)=max((x),(y)))\n#define fst first\n#define snd second\n#define UNIQUE(x) (x).erase(unique(all(x)),(x).end())\n#define DEBUG(x) cerr<<\"line (\"<<__LINE__<<\")  \"<<#x<<\": \"<<x<<endl;\ntemplate<class T> ostream &operator<<(ostream &os, const vector<T> &v){int n=v.size();rep(i,n)os<<v[i]<<(i==n-1?\"\":\" \");return os;}\n\n#define N 90\n#define M 65*65*4\nint h, w, n, h2, w2;\nint x[N], y[N], xy[N][N];\nvector<int> x2, y2;\nunordered_map<int, int> xd, yd;\nll d[M];\n\nll pow_mod(ll a, ll r, ll m = mod){\n\tll x = 1;\n\twhile(r){\n\t\tif(r&1) (x*=a)%=m;\n\t\t(a*=a)%=m;\n\t\tr>>=1;\n\t}\n\treturn x;\n}\n\nll inv2 = pow_mod(2, mod-2, mod);\nll inv3 = pow_mod(3, mod-2, mod);\n\nll f(ll a, ll b, ll c){\n\treturn (a*w2+b)*4+c;\n}\n\nvoid comp(int *a, vector<int> &b, unordered_map<int, int> &c, int d, int &d2){\n\tb.clear(); c.clear();\n\trep(i, n){ b.pb(a[i]); b.pb(a[i]+1);}\n\tb.pb(0); b.pb(d);\n\tsort(all(b));\n\tUNIQUE(b);\n\td2 = b.size();\n\trep(i, d2) c[b[i]] = i;\n\trep(i, n) a[i] = c[a[i]];\n}\n\nll solve(int a, int b, int c, bool xf, bool yf){\n\tfill(d, d+M, INF);\n\trep(i, n) rep(j, 4) d[f(x[i], y[i], j)] = -1;\n\tll abc = f(a, b, c);\n\td[abc] = 0;\n\tqueue<P> q;\n\tq.push(P(0, abc));\n\tll res = 0;\n\twhile(!q.empty()){\n\t\tP p = q.front(); q.pop();\n\t\tll l = p.fst, u = (p.snd>>2)/w2, v = (p.snd>>2)%w2, k = p.snd&3;\n\t\tif(d[p.snd]<l) continue;\n\t\t//cerr<<\"dijk \"<<u<<\" \"<<v<<\" \"<<k<<\" \"<<l<<endl;\n\t\tll kx = k>>1, ky = k&1;\n\t\tll u2 = u+kx*2-1, v2 = v+ky*2-1;\n\t\tif(0<=u2&&u2<h2-1){\n\t\t\tll p2 = f(u2, v, k^2);\n\t\t\tif(d[p2]>=0 && l+1<d[p2]){\n\t\t\t\td[p2] = l+1;\n\t\t\t\tq.push(P(d[p2], p2));\n\t\t\t}\n\t\t}\n\t\tif(0<=v2&&v2<w2-1){\n\t\t\tll p2 = f(u, v2, k^1);\n\t\t\tif(d[p2]>=0 && l+1<d[p2]){\n\t\t\t\td[p2] = l+1;\n\t\t\t\tq.push(P(d[p2], p2));\n\t\t\t}\n\t\t}\n\t\trep1(i, 3){\n\t\t\tll k2 = k^i;\n\t\t\tll l2 = l;\n\t\t\tif(i&2) l2 += x2[u+1]-x2[u]-1;\n\t\t\tif(i&1) l2 += y2[v+1]-y2[v]-1;\n\t\t\tll p2 = f(u, v, k2);\n\t\t\tif(d[p2]>=0 && l2<d[p2]){\n\t\t\t\td[p2] = l2;\n\t\t\t\tq.push(P(d[p2], p2));\n\t\t\t}\n\t\t}\n\t}\n\trep(i, h2-1) rep(j, w2-1){\n\t\tif(xy[i][j]) continue;\n\t\tif(xf && i==a) continue;\n\t\tif(yf && j==b) continue;\n\t\t(res+=(d[f(i, j, 0)]+d[f(i, j, 3)])%mod*(x2[i+1]-x2[i])%mod*(y2[j+1]-y2[j])%mod*inv2)%=mod;\n\t}\n\treturn res;\n\trep(i, h2-1){\n\t\trep(j, w2-1) cerr<<d[f(i, j, 0)]<<\" \";\n\t\tcerr<<endl;\n\t}\n\treturn res;\n}\n\nll f5(ll h){\n\tll r1 = ((3*h-2)*(h-1)+2*(h-1)*(h-1)%mod*(h-1))%mod*(h-1)%mod;\n\tll r2 = ((4*h-4)*(h-1)+2*(h-2)*(h-1)%mod*(h-1))%mod*(h-1)%mod*(h-1)%mod*inv2%mod;\n\treturn (r1+r2)%mod;\n}\n\nint main(){\n\tcin>>h>>w>>n;\n\trep(i, n) cin>>x[i]>>y[i];\n\tcomp(x, x2, xd, h, h2);\n\tcomp(y, y2, yd, w, w2);\n\trep(i, n) xy[x[i]][y[i]] = -1;\n\tll res = 0;\n\trep(i, h2-1) rep(j, w2-1){\n\t\tif(xy[i][j]) continue;\n\t\tll xx = x2[i+1]-x2[i], yy = y2[j+1]-y2[j];\n\t\tbool xf = xx>1, yf = yy>1;\n\t\tll r0 = solve(i, j, 0, xf, yf);\n\t\tll r3 = (!xf&&!yf)?r0:solve(i, j, 3, xf, yf);\n\t\t//cerr<<\"xx yy \"<<xx<<\" \"<<yy<<endl;\n\t\tll res2 = res;\n\t\t(res+=(r0+r3)*(xx)%mod*(yy)%mod*inv2)%=mod;\n\t\t//cerr<<\"diff1 \"<<(res-res2+mod)%mod<<endl;\n\t\tif(!xf&&!yf) continue;\n\t\tll xx1 = x2[i], xx2 = h-x2[i+1], yy1 = y2[j], yy2 = w-y2[j+1];\n\t\tif(xf&&yf){\n\t\t\tll rx = (pow_mod(xx, 3)-xx)*w%mod*yy%mod*inv3%mod + (yy1*(yy1+1)+yy2*(yy2+1))%mod*xx%mod*xx%mod*yy%mod*inv2%mod + xx*xx%mod*yy%mod*(w-yy)%mod*(yy-1)%mod*inv2%mod;\n\t\t\tll ry = (pow_mod(yy, 3)-yy)*h%mod*xx%mod*inv3%mod + (xx1*(xx1+1)+xx2*(xx2+1))%mod*yy%mod*yy%mod*xx%mod*inv2%mod + yy*yy%mod*xx%mod*(h-xx)%mod*(xx-1)%mod*inv2%mod;\n\t\t\t(res+=rx+ry)%=mod;\n\t\t\t//cerr<<\"rx ry \"<<rx<<\" \"<<ry<<endl;\n\t\t} else if(xf){\n\t\t\t(res+=(pow_mod(xx, 3)-xx)*w%mod*inv3%mod + (yy1*(yy1+1)+yy2*(yy2+1))%mod*xx%mod*xx%mod*inv2%mod)%=mod;\n\t\t} else {\n\t\t\t(res+=(pow_mod(yy, 3)-yy)*h%mod*inv3%mod + (xx1*(xx1+1)+xx2*(xx2+1))%mod*yy%mod*yy%mod*inv2%mod)%=mod;\n\t\t}\n\t\t//cerr<<\"diff \"<<(res-res2+mod)%mod<<endl;\n\t}\n\tcout<<(res*inv2%mod+mod)%mod<<endl;\n\t//cerr<<res<<endl;\n\t//cerr<<f5(h)*inv2%mod<<endl;\n\treturn 0;\n}\n"
  },
  {
    "language": "C++",
    "code": "#include<bits/stdc++.h>\nusing namespace std;\nconst long long md=1e9+7;\nconst int maxn=110;\nconst int drx[4]={1,-1,0,0};\nconst int dry[4]={0,0,-1,1};\nint H,W,n;\nstruct node{\n\tint x,y;\n}a[maxn];\nlong long val[maxn][maxn];\nint dis[maxn][maxn];\nlong long ans;\nlong long Sum(long long x){\n\treturn (x*(x+1)/2)%md;\n}\nint Abs(int x){\n\treturn x<0?-x:x;\n}\nint getdis(const node &A,const node &B){\n\treturn Abs(A.x-B.x)+Abs(A.y-B.y);\n}\nvoid get_ans(){\n\tfor(int i=1;i<W;i++)\n\t\tans=(ans+i*(long long)(W-i)%md*H%md*H)%md;\n\tfor(int i=1;i<H;i++)\n\t\tans=(ans+i*(long long)(H-i)%md*W%md*W)%md;\n\tfor(int i=1;i<=n;i++){\n\t\tans=(ans-Sum(H-a[i].x)*W%md+md-Sum(a[i].x-1)*W%md+md)%md;\n\t\tans=(ans-Sum(W-a[i].y)*H%md+md-Sum(a[i].y-1)*H%md+md)%md;\n\t}\n\tans=ans*2;\n\tfor(int i=1;i<=n;i++)\n\t\tfor(int j=1;j<=n;j++)\n\t\t\tans=(ans+getdis(a[i],a[j])+md)%md;\n}\nint bx[maxn],by[maxn];\nint vx[maxn],vy[maxn];\nint mpx[1001000],mpy[1001000];\nint cntx,cnty;\nvoid build_val(){\n\tcntx=0,cnty=0;\n\tint numx,numy;\n\n\tfor(int i=1;i<=n;i++)\n\t\tbx[i]=a[i].x;\n\tsort(bx+1,bx+n+1);\n\tnumx=unique(bx+1,bx+n+1)-(bx+1);\n\tbx[0]=0,bx[numx+1]=H+1;\n\tfor(int i=1;i<=numx+1;i++){\n\t\tif(bx[i]-bx[i-1]>1)\n\t\t\tvx[++cntx]=bx[i]-bx[i-1]-1;\n\t\tvx[++cntx]=1;\n\t\tmpx[bx[i]]=cntx;\n\t}\n\tcntx--;\n\n\tfor(int i=1;i<=n;i++)\n\t\tby[i]=a[i].y;\n\tsort(by+1,by+n+1);\n\tnumy=unique(by+1,by+n+1)-(by+1);\n\tby[0]=0,by[numy+1]=W+1;\n\tfor(int i=1;i<=numy+1;i++){\n\t\tif(by[i]-by[i-1]>1)\n\t\t\tvy[++cnty]=by[i]-by[i-1]-1;\n\t\tvy[++cnty]=1;\n\t\tmpy[by[i]]=cnty;\n\t}\n\tcnty--;\n\n\tfor(int i=1;i<=cntx;i++)\n\t\tfor(int j=1;j<=cnty;j++)\n\t\t\tval[i][j]=vx[i]*(long long)vy[i]%md;\n\tfor(int i=1;i<=n;i++)\n\t\tval[mpx[a[i].x]][mpy[a[i].y]]=-1;\n}\nqueue<node> q;\nbool out(int x,int y){\n\tif(x<1||x>cntx) return 1;\n\tif(y<1||y>cnty) return 1;\n\treturn 0;\n}\nvoid BFS(node st){\n\tfor(int i=1;i<=cntx;i++)\n\t\tfor(int j=1;j<=cnty;j++)\n\t\t\tdis[i][j]=-1;\n\tdis[st.x][st.y]=0;\n\tq.push(st);\n\tint xx,yy;\n\twhile(!q.empty()){\n\t\tst=q.front(),q.pop();\n\t\tfor(int i=0;i<4;i++){\n\t\t\txx=st.x+drx[i],yy=st.y+dry[i];\n\t\t\tif(out(xx,yy)) continue;\n\t\t\tif(val[xx][yy]==-1) continue;\n\t\t\tif(dis[xx][yy]!=-1) continue;\n\t\t\tdis[xx][yy]=dis[st.x][st.y]+1;\n\t\t\tq.push((node){xx,yy});\n\t\t}\n\t}\n}\nvoid updata(int x,int y){\n\tint dd;\n\tfor(int i=1;i<=cntx;i++){\n\t\tfor(int j=1;j<=cnty;j++){\n\t\t\tif(val[i][j]==-1) continue;\n\t\t\tdd=dis[i][j]-(Abs(x-i)+Abs(y-j));\n\t\t\tif(dd==0) continue;\n\t\t\tans=(ans+val[x][y]*val[i][j]%md*dd)%md;\n\t\t}\n\t}\n}\nint main(){\n//\tfreopen(\"I.in\",\"r\",stdin);\n\tscanf(\"%d%d%d\",&H,&W,&n);\n\tfor(int i=1;i<=n;i++){\n\t\tscanf(\"%d%d\",&a[i].x,&a[i].y);\n\t\ta[i].x++,a[i].y++;\n\t}\n\tget_ans();\n\tbuild_val();\n\tfor(int i=1;i<=cntx;i++){\n\t\tfor(int j=1;j<=cnty;j++){\n\t\t\tif(val[i][j]==-1) continue;\n\t\t\tBFS((node){i,j});\n\t\t\tupdata(i,j);\n\t\t}\n\t}\n\tprintf(\"%lld\\n\",(ans*((md+1)/2))%md);\n\treturn 0;\n}\n"
  },
  {
    "language": "C++",
    "code": "#include<bits/stdc++.h>\n#define mod 1000000007\nusing namespace std;\nbool vh[1000005],vw[1000005],ban[65][65];\nint bh[1000005],bw[1000005],nh[1000005];\nint nw[1000005],h,w,n,x[31],y[31],c1=0,c2=0;\nint kh[105],kw[105],wgt[65][65],dis[65][65];\nint que[10005][2],l=1,r=0;\ninline int mul(int a,int b){\n\treturn 1ll*a*b%mod;\n}\n\ninline int sub(int a,int b){\n\treturn(a-b<0?a-b+mod:a-b);\n}\n\ninline bool ok(int a,int b){\n\tif(a<=0||a>c1||b<=0||b>c2||ban[a][b])\n\treturn 0;\n\treturn 1;\n}\n\nint main(){\n\tint i,j,k,l,ans=0;\n\tscanf(\"%d%d%d\",&h,&w,&n);\n\tfor(i=1;i<=n;++i){\n\t\tscanf(\"%d%d\",&x[i],&y[i]);\n\t\t++x[i];++y[i];\n\t\t++nh[x[i]];++nw[y[i]];\n\t\tvh[x[i]]=vw[y[i]]=1;\n\t}\n\tbh[1]=++c1;++kh[1];\n\tint lo=0,tot=mul(h,w)-n;\n\tif(tot<0) tot+=mod;\n\tfor(i=2;i<=h;++i){\n\t\tlo+=(w-nh[i-1]);\n\t\tif(lo>=mod)lo-=mod;\n\t\tif((!vh[i-1])&&(!vh[i])){\n\t\t\tans+=mul(lo,sub(tot,lo));\n\t\t\tif(ans>=mod)ans-=mod;\n\t\t\tbh[i]=bh[i-1];++kh[c1];\n\t\t}else{\n\t\t\tbh[i]=++c1;\n\t\t\tkh[c1]=1;\n\t\t}\n\t}\n\tbw[1]=++c2;++kw[1];\n\tlo=0;tot=mul(h,w)-n;\n\tif(tot<0)tot+=mod;\n\tfor(i=2;i<=w;++i){\n\t\tlo+=(h-nw[i-1]);\n\t\tif(lo>=mod)lo-=mod;\n\t\tif((!vw[i-1])&&(!vw[i])){\n\t\t\tans+=mul(lo,sub(tot,lo));\n\t\t\tif(ans>=mod)ans-=mod;\n\t\t\tbw[i]=bw[i-1];++kw[c2];\n\t\t}else{\n\t\t\tbw[i]=++c2;\n\t\t\tkw[c2]=1;\n\t\t}\n\t}\n\tfor(i=1;i<=c1;++i){\n\t\tfor(j=1;j<=c2;++j){\n\t\t\twgt[i][j]=mul(kh[i],kw[j]);\n\t\t}\n\t}\n\tfor(i=1;i<=n;++i){\n\t\tban[bh[x[i]]][bw[y[i]]]=1;\n\t}\n\tans<<=1;\n\tif(ans>=mod)ans-=mod;\n\tfo(i=1;i<=c1;++i){\n\t\tfor(j=1;j<=c2;++j){\n\t\t\tif(ban[i][j])continue;\n\t\t\tl=1;r=0;que[++r][0]=i;\n\t\t\tque[r][1]=j;\n\t\t\tmemset(dis,0x7f,sizeof(dis));\n\t\t\tdis[i][j]=0;\n\t\t\twhile(l<=r){\n\t\t\t\tint a=que[l][0],b=que[l][1];\n\t\t\t\t++l;\n\t\t\t\tif(ok(a-1,b)&&\n\t\t\t\tdis[a-1][b]>dis[a][b]+1){\n\t\t\t\t\tdis[a-1][b]=dis[a][b]+1;\n\t\t\t\t\tque[++r][0]=a-1;\n\t\t\t\t\tque[r][1]=b;\n\t\t\t\t}\n\t\t\t\tif(ok(a+1,b)&&\n\t\t\t\tdis[a+1][b]>dis[a][b]+1){\n\t\t\t\t\tdis[a+1][b]=dis[a][b]+1;\n\t\t\t\t\tque[++r][0]=a+1;\n\t\t\t\t\tque[r][1]=b;\n\t\t\t\t}\n\t\t\t\tif(ok(a-1,b)&&\n\t\t\t\tdis[a-1][b]>dis[a][b]+1){\n\t\t\t\t\tdis[a-1][b]=dis[a][b]+1;\n\t\t\t\t\tque[++r][0]=a-1;\n\t\t\t\t\tque[r][1]=b;\n\t\t\t\t}\n\t\t\t\tif(ok(a,b-1)&&\n\t\t\t\tdis[a][b-1]>dis[a][b]+1){\n\t\t\t\t\tdis[a][b-1]=dis[a][b]+1;\n\t\t\t\t\tque[++r][0]=a;\n\t\t\t\t\tque[r][1]=b-1;\n\t\t\t\t}\n\t\t\t\tif(ok(a,b+1)&&\n\t\t\t\tdis[a][b+1]>dis[a][b]+1){\n\t\t\t\t\tdis[a][b+1]=dis[a][b]+1;\n\t\t\t\t\tque[++r][0]=a;\n\t\t\t\t\tque[r][1]=b+1;\n\t\t\t\t}\n\t\t\t}\n\t\t\tint tp=0;\n\t\t\tfor(k=1;k<=c1;++k){\n\t\t\t\tfor(l=1;l<=c2;++l){\n\t\t\t\t\tif(ban[k][l])continue;\n\t\t\t\t\tint x=dis[k][l];\n\t\t\t\t\ttp+=mul(x,wgt[k][l]);\n\t\t\t\t\tif(tp>=mod)tp-=mod;\n\t\t\t\t}\n\t\t\t}\n\t\t\ttp=mul(tp,wgt[i][j]);\n\t\t\tans+=tp;\n\t\t\tif(ans>=mod)ans-=mod;\n\t\t}\n\t}\n\tif(ans&1)ans+=mod;\n\tprintf(\"%d\\n\",ans>>1);\n\treturn 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include <cstdio>\n#include <algorithm>\n#include <vector>\n#include <queue>\nusing namespace std;\ntypedef long long i64;\nconst i64 MOD = 1000000007;\ntemplate<typename T> void ADD(T& a, const T& b) { a = (a + b) % MOD; }\n\ni64 H, W;\nint N, X[30], Y[30];\nint hist[1001001];\n\ni64 precomp(i64 H, i64 W, int *Y)\n{\n    for (int i = 0; i < H; ++i) hist[i] = 0;\n    for (int i = 0; i < N; ++i) hist[Y[i]]++;\n\n    i64 tot = (H * W - N) % MOD;\n    i64 suml = 0;\n    i64 ret = 0;\n    for (int i = 1; i < H; ++i) {\n        ADD(suml, W - hist[i - 1]);\n        i64 sumr = (MOD + tot - suml) % MOD;\n        if (hist[i - 1] == 0 && hist[i] == 0) {\n            ADD(ret, suml * sumr);\n        }\n    }\n    return ret;\n}\nvector<pair<int, int>> summarize(int H, int *Y)\n{\n    vector<int> ys;\n    for (int i = 0; i < N; ++i) ys.push_back(Y[i]);\n    sort(ys.begin(), ys.end());\n    ys.erase(unique(ys.begin(), ys.end()), ys.end());\n    \n    vector<pair<int, int>> ret;\n    if (ys[0] != 0) ret.push_back({0, ys[0] - 1});\n    ret.push_back({ys[0], ys[0]});\n    for (int i = 1; i < ys.size(); ++i) {\n        if (ys[i - 1] < ys[i] - 1) ret.push_back({ys[i - 1] + 1, ys[i] - 1});\n        ret.push_back({ys[i], ys[i]});\n    }\n    if (ys.back() != H - 1) ret.push_back({ys.back() + 1, H - 1});\n    return ret;\n}\n\nint R, C; i64 weight[60][60];\nint dis[60][60];\n\nconst int dy[] = {-1, 0, 1, 0}, dx[] = {0, -1, 0, 1};\n\ni64 dfs(int y, int x)\n{\n    for (int i = 0; i < R; ++i) for (int j = 0; j < C; ++j) dis[i][j] = -1;\n    dis[y][x] = 0;\n    queue<pair<int, int>> qu; qu.push({y, x});\n    i64 ret = 0;\n    while (!qu.empty()) {\n        auto loc = qu.front(); qu.pop();\n        int d = dis[loc.first][loc.second];\n        if (make_pair(y, x) < make_pair(loc.first, loc.second)) {\n            ADD(ret, d * weight[loc.first][loc.second]);\n        }\n        for (int i = 0; i < 4; ++i) {\n            int y2 = loc.first + dy[i], x2 = loc.second + dx[i];\n            if (y2 < 0 || x2 < 0 || y2 >= R || x2 >= C || weight[y2][x2] == 0 || dis[y2][x2] != -1) continue;\n            dis[y2][x2] = d + 1;\n            qu.push({y2, x2});\n        }\n    }\n    return ret;\n}\n\nint main()\n{\n    scanf(\"%lld%lld%d\", &H, &W, &N);\n    for (int i = 0; i < N; ++i) {\n        scanf(\"%d%d\", Y + i, X + i);\n    }\n\n    i64 ret = 0;\n    ADD(ret, precomp(H, W, Y));\n    ADD(ret, precomp(W, H, X));\n\n    vector<pair<int, int>> ys = summarize(H, Y), xs = summarize(W, X);\n    R = ys.size(); C = xs.size();\n    for (int i = 0; i < R; ++i) {\n        for (int j = 0; j < C; ++j) {\n            weight[i][j] = (i64)(ys[i].second - ys[i].first + 1) * (xs[j].second - xs[j].first + 1);\n        }\n    }\n    for (int i = 0; i < N; ++i) {\n        --weight[find(ys.begin(), ys.end(), make_pair(Y[i], Y[i])) - ys.begin()][find(xs.begin(), xs.end(), make_pair(X[i], X[i])) - xs.begin()];\n    }\n    for (int i = 0; i < R; ++i) {\n        for (int j = 0; j < C; ++j) {\n            if (weight[i][j] != 0) {\n                ADD(ret, weight[i][j] % MOD * dfs(i, j));\n            }\n        }\n    }\n    printf(\"%lld\\n\", ret);\n\n    return 0;\n}\n"
  },
  {
    "language": "C++",
    "code": "// SUBLIME HAX\n\t/*nope\n\tcat\n\t// sixteen chars// sixteen chars// sixteen chars// sixteen chars// sixteen chars// sixteen chars// sixteen chars// sixteen chars// sixteen chars// sixteen chars// sixteen chars// sixteen chars// sixteen chars// sixteen chars// sixteen chars// sixteen chars// sixteen chars// sixteen chars// sixteen chars// sixteen chars// sixteen chars// sixteen chars// sixteen chars// sixteen chars// sixteen chars// sixteen chars// sixteen chars// sixteen chars// sixteen chars// sixteen chars// sixteen chars// sixteen chars// sixteen chars// sixteen chars// sixteen chars// sixteen chars// sixteen chars// sixteen chars// sixteen chars// sixteen chars// sixteen chars// sixteen chars// sixteen chars// sixteen chars// sixteen chars// sixteen chars// sixteen chars// sixteen chars// sixteen chars// sixteen chars// sixteen chars// sixteen chars// sixteen chars// sixteen chars// sixteen chars// sixteen chars// sixteen chars// sixteen chars// sixteen chars// sixteen chars// sixteen chars// sixteen chars// sixteen chars// sixteen chars\n\t// ayy\n\t// ' lamo\n\t*/\n\t#include <bits/stdc++.h>\n\tusing namespace std;\n\ttemplate<class T,class U>\n\tostream &operator<<(ostream &os,const pair<T,U> &x) {\n\t\treturn os<<\"(\"<<x.first<<\",\"<<x.second<<\")\";\n\t}\n\tnamespace dbg_ns {\n\t\ttemplate<typename C>\n\t\tstruct is_iterable {\n\t\t\ttemplate<class T> static long check(...);\n\t\t\ttemplate<class T> static char check(int,\n\t\t\t\ttypename T::const_iterator = C().end());\n\t\t\tenum {\n\t\t\t\tvalue = sizeof(check<C>(0)) == sizeof(char),\n\t\t\t\tneg_value = sizeof(check<C>(0)) != sizeof(char)\n\t\t\t};\n\t\t};\n\t\ttemplate<class T> ostream &_out_str(ostream &os,const T &x) {\n\t\t\treturn os<<'\"'<<x<<'\"';\n\t\t}\n\t\ttemplate<class T> ostream &_dbg2_5(ostream &,const T &);\n\t\ttemplate<bool B,typename T=void> using eit=typename enable_if<B,T>::type;\n\t\ttemplate<class T>\n\t\tinline ostream &_dbg3(ostream &os,eit<is_iterable<T>::neg_value,const T> &x) {\n\t\t\treturn os<<x;\n\t\t}\n\t\ttemplate<class T>\n\t\tinline ostream &_dbg3(ostream &os,eit<is_iterable<T>::value,const T> &V) {\n\t\t\tos<<\"{\";\n\t\t\tbool ff=0;\n\t\t\tfor(const auto &E:V) _dbg2_5(ff?os<<\",\":os,E), ff=1;\n\t\t\treturn os<<\"}\";\n\t\t}\n\t\ttemplate<>\n\t\tinline ostream &_dbg3<string>(ostream &os,const string &x) {\n\t\t\treturn _out_str(os,x);\n\t\t}\n\t\ttemplate<>\n\t\tinline ostream &_dbg3<const char *>(ostream &os,const char *const &x) {\n\t\t\treturn _out_str(os,x);\n\t\t}\n\t\ttemplate<class T> inline ostream &_dbg2_5(ostream &os,const T &x) {\n\t\t\treturn _dbg3<T>(os,x);\n\t\t}\n\t\ttemplate<class T,typename... Args> ostream &_dbg2(ostream &os,vector<string>::iterator nm,const T &x,Args&&... args);\n\t\tinline ostream &_dbg2(ostream &os,vector<string>::iterator) { return os; }\n\t\ttemplate<typename... Args>\n\t\tinline ostream &_dbg2(ostream &os,vector<string>::iterator nm,const char *x,Args&&... args) {\n\t\t\treturn _dbg2(_dbg3<const char *>(os<<\"  \",x),nm+1,args...);\n\t\t}\n\t\ttemplate<class T,typename... Args>\n\t\tinline ostream &_dbg2(ostream &os,vector<string>::iterator nm,const T &x,Args&&... args) {\n\t\t\treturn _dbg2(_dbg3<T>(os<<\"  \"<<*nm<<\"=\",x),nm+1,args...);\n\t\t}\n\t\tvector<string> split(string s) {\n\t\t\tvector<string> Z;\n\t\t\tstring z=\"\";\n\t\t\ts+=',';\n\t\t\tint dep=0;\n\t\t\tfor(char c:s) {\n\t\t\t\tif(c==',' && !dep) Z.push_back(z),z=\"\";\n\t\t\t\telse z+=c;\n\t\t\t\tif(c=='(') ++dep;\n\t\t\t\tif(c==')') --dep;\n\t\t\t}\n\t\t\treturn Z;\n\t\t}\n\t\ttemplate<typename... Args> inline ostream &_dbg1(int ln,const string &nm,Args&&... args) {\n\t\t\tauto nms=split(nm);\n\t\t\treturn _dbg2(cerr<<\"L\"<<ln<<\":\",nms.begin(),args...)<<endl;\n\t\t}\n\t}\n\t#define dbg(...) dbg_ns::_dbg1(__LINE__,#__VA_ARGS__,__VA_ARGS__)\n\t#define sz(x) (int(x.size()))\n\t#define eprintf(...) fprintf(stderr,__VA_ARGS__)\n\t#define fi first\n\t#define se second\n\t#define pb push_back\n// END SUBLIME HAX\n// #include <bits/extc++.h>\n// using namespace __gnu_pbds;\ntypedef unsigned long long ull;\ntypedef long long ll;\ntypedef long double ld; //CARE\ntypedef complex<ld> pt;\nconst ld eps=(ld)1e-8;\nconst ld tau=2*(ld)acosl(-1);\nconst int inf=1e9+99;\nconst ll linf=1e18+99;\nconst int P=1e9+7;\n\n\n// #define int __int128\n// #define ll __int128\n\nint32_t H,W;\nint32_t n;\n\nconst int32_t N=8192;\nint D[N][N];\nvector<pair<int,int> > adj[N];\nvector<pair<int,int> > rels;\nvector<int> relx,rely;\nset<pair<int,int> > bads;\nset<int> bx,by;\nvector<pair<int,int> > bandx,bandy;\n\nmap<int,int> ddec[1<<20];\n\nint dec(int x,int y) {\n\treturn ddec[x].count(y) ? ddec[x][y] : -1;\n\tauto it=lower_bound(rels.begin(),rels.end(),pair<int,int>(x,y));\n\tif(it!=rels.end() && it->fi==x && it->se==y)\n\t\treturn int(it-rels.begin());\n\treturn -1;\n}\n\n\nint sL(int x) { // 0+..+x-1\n\treturn int(1LL*x*(x-1)/2%P);\n}\nint ww(int x) {\n\tstatic bool init=0;\n\tstatic int Z[1<<20];\n\tassert(1<=x && x<(1<<20));\n\tif(!init) {\n\t\tinit=1;\n\t\tassert(!sL(0) && !sL(1));\n\t\tfor(int i=1;i<(1<<20);i++) {\n\t\t\tZ[i]=sL(i)+Z[i-1];\n\t\t\tif(Z[i]>=P) Z[i]-=P;\n\t\t}\n\t}\n\treturn Z[x];\n}\nint qq(int x,int y) {\n\treturn int((1LL*x*sL(y)+1LL*y*sL(x))%P);\n}\ninline int _w(const pair<int,int> &P) {\n\tif(~P.se) return P.se-P.fi+1;\n\treturn 1;\n}\nint g_same(int w,int h) {\n\t// dbg(\"SS\",w,h);\n\t// dbg(ww(h));\n\treturn int((1LL*w*w%P*ww(h) + 1LL*h*h%P*ww(w))%P);\n}\nint g_same(int w,const pair<int,int> &X,const pair<int,int> &_X) {\n\tif(X==_X) return g_same(w,_w(X));\n\tint d0;\n\tint a= X.fi,b=~ X.se? X.se: X.fi;\n\tint c=_X.fi,d=~_X.se?_X.se:_X.fi;\n\tassert(a<=b && c<=d);\n\tif(b<c) d0=c-b; else\n\tif(d<a) d0=a-d; else\n\tassert(0);\n\tint h1=_w(X);\n\tint h2=_w(_X);\n\n\tll ZZ=d0;\n\tZZ=ZZ*w%P*h1%P*w%P*h2%P;\n\tZZ+=1LL*h1*h2%P*ww(w)*2; //dbg(h1,h2,w,ww(w));\n\tZZ+=1LL*w*w%P*qq(h1,h2);\n\t// dbg(\"HIT\",w,h1,h2,ZZ,d0);\n\treturn int(ZZ%P);\n}\ninline int close(const pair<int,int> &X,int x) {\n\tif(!~X.se) return X.fi;\n\tif(x<X.fi) return X.fi;\n\tif(x>X.se) return X.se;\n\tassert(0);\n}\nint g(const pair<int,int> &X,const pair<int,int> &Y,\n\tconst pair<int,int> &_X,const pair<int,int> &_Y) {\n\n\tif(X==_X && Y==_Y && !~X.se && !~Y.se) return 0;\n\n\tif(X==_X && ~X.se) return g_same(_w(X),Y,_Y);\n\tif(Y==_Y && ~Y.se) return g_same(_w(Y),X,_X);\n\n\tint  Cx=_w(X);\n\tint  Cy=_w(Y);\n\tint _Cx=_w(_X);\n\tint _Cy=_w(_Y);\n\tint CCx=int(1LL*Cx*_Cx%P);\n\tint CCy=int(1LL*Cy*_Cy%P);\n\n\tint u=dec(close(X,_X.fi),close(Y,_Y.fi)); assert(~u);\n\tint v=dec(close(_X,X.fi),close(_Y,Y.fi)); assert(~v);\n\n\tll ZZ=D[u][v]; assert(ZZ<inf);\n\n\tZZ=ZZ*CCx%P*CCy;\n\t// dbg(C,_C,ZZ,ZZ%P);\n\n\tZZ+=1LL*CCx*qq(Cy,_Cy);\n\tZZ+=1LL*CCy*qq(Cx,_Cx);\n\n\t// dbg(ZZ,ZZ%P);\n\n\treturn int(ZZ%P);\n}\n\n\ntemplate<class T> struct PQ {\n\tint n=0;\n\tT A[N*4];\n\tvoid push(const T &x) {\n\t\tint i=++n;\n\t\tA[i]=x;\n\t\tfor(;i>1 && A[i>>1]<A[i];) swap(A[i>>1],A[i]), i>>=1;\n\t}\n\tT top() const { return A[1]; }\n\tvoid pop() {\n\t\tassert(n>=1);\n\t\tif(n>1) swap(A[1],A[n]);\n\t\tn--;\n\t\tint i=1;\n\t\tfor(;;) {\n\t\t\tint j=i<<1;\n\t\t\tif(j>n) break;\n\t\t\tif(j==n) {\n\t\t\t\tif(A[j]>A[i]) swap(A[j],A[i]);\n\t\t\t\tbreak;\n\t\t\t}\n\t\t\tif(A[j+1]>A[j]) ++j;\n\t\t\tif(A[j]>A[i]) swap(A[j],A[i]);\n\t\t\telse break;\n\t\t\ti=j;\n\t\t}\n\t}\n\tint size() const {\n\t\treturn n;\n\t}\n};\n// PQ<pair<int,int> > pq;\n// priority_queue<pair<int,int> > pq;\nqueue<pair<int,int> > pq;\n#define top front\n\nvoid dijk(int src,int *DD) {\n\t// for(int u=0;u<n;u++) DD[u]=inf;\n\tfor(int u=0;u<=src;u++) DD[u]=D[u][src], pq.push({-DD[u],u});\n\tfor(int u=src+1;u<n;u++) DD[u]=inf;\n\tif(src) for(int u=src+1;u<n;u++) DD[u]=D[src-1][u]+DD[src-1], pq.push({-DD[u],u});\n\t// DD[src]=0;\n\t// pq.push({0,src});\n\tfor(;sz(pq);) {\n\t\tauto P=pq.top();\n\t\tint u=P.se;\n\t\tint d=-P.fi;\n\t\tpq.pop();\n\t\tif(DD[u]<d) continue;\n\t\tfor(const auto &P:adj[u]) if(d+P.se<DD[P.fi]) {\n\t\t\tDD[P.fi]=d+P.se;\n\t\t\tpq.push({-DD[P.fi],P.fi});\n\t\t}\n\t}\n}\n\n\nint32_t main() {\n\t// for(int i=1;i<6;i++) dbg(i,ww(i));\n\tcin>>H>>W>>n;\n\tfor(int i=0;i<n;i++) {\n\t\tint32_t x,y; cin>>x>>y;\n\t\tbads.insert({x,y});\n\t\tbx.insert(x), by.insert(y);\n\t}\n\tfor(int _x:bx) for(int x=_x-1;x<=_x+1;x++)\n\t\tif(!sz(relx) || x>relx.back()) if(0<=x && x<H)\n\t\t\trelx.pb(x);\n\tfor(int _y:by) for(int y=_y-1;y<=_y+1;y++)\n\t\tif(!sz(rely) || y>rely.back()) if(0<=y && y<W)\n\t\t\trely.pb(y);\n\n\tfor(int x:relx) for(int y:rely) if(!bads.count({x,y})) rels.pb({x,y});\n\tsort(rels.begin(),rels.end());\n\tn=sz(rels);\n\tassert(n<N);\n\tfor(int i=0;i<n;i++) ddec[rels[i].fi][rels[i].se]=i;\n\n\tfor(int i=1;i<sz(relx);i++) for(int y:rely) {\n\t\tint u=dec(relx[i-1],y);\n\t\tint v=dec(relx[i],y);\n\t\tint d=relx[i]-relx[i-1];\n\t\tif(~u && ~v) {\n\t\t\tadj[u].pb({v,d});\n\t\t\tadj[v].pb({u,d});\n\t\t}\n\t}\n\tfor(int i=1;i<sz(rely);i++) for(int x:relx) {\n\t\tint u=dec(x,rely[i-1]);\n\t\tint v=dec(x,rely[i]);\n\t\tint d=rely[i]-rely[i-1];\n\t\tif(~u && ~v) {\n\t\t\tadj[u].pb({v,d});\n\t\t\tadj[v].pb({u,d});\n\t\t}\n\t}\n\n\tfor(int i=0;i<n;i++) dijk(i,D[i]);\n\t// for(int i=0;i<n;i++) for(int j=0;j<n;j++) dbg(rels[i],rels[j],D[i][j]);\n\n\t{\n\t\tint pr=-1;\n\t\tfor(int x:bx) {\n\t\t\tif(x-1>pr) bandx.pb({pr+1,x-1});\n\t\t\tbandx.pb({x,-1});\n\t\t\tpr=x;\n\t\t}\n\t\tif(H-1>pr) bandx.pb({pr+1,H-1});\n\t}\n\t{\n\t\tint pr=-1;\n\t\tfor(int y:by) {\n\t\t\tif(y-1>pr) bandy.pb({pr+1,y-1});\n\t\t\tbandy.pb({y,-1});\n\t\t\tpr=y;\n\t\t}\n\t\tif(W-1>pr) bandy.pb({pr+1,W-1});\n\t}\n\n\tassert(sz(bandx)<=61 && sz(bandy)<=61);\n\n\tll Z=0;\n\tfor(const auto &BX:bandx) for(const auto &BY:bandy) {\n\t\tif(bads.count({BX.fi,BY.fi})) continue;\n\t\tfor(const auto &_BX:bandx) for(const auto &_BY:bandy) {\n\t\t\tif(BX>_BX) continue;\n\t\t\tif(BX==_BX && BY>_BY) continue;\n\t\t\tif(!~_BX.se && !~_BY.se && bads.count({_BX.fi,_BY.fi})) continue;\n\t\t\tint w=g(BX,BY,_BX,_BY);\n\t\t\tZ+=w;\n\t\t}\n\t}\n\tcout<<int32_t(Z%P)<<endl;\n}\n\n\n\n\n\n\n\n\n\n\n\n"
  },
  {
    "language": "C++",
    "code": "#include<bits/stdc++.h>\n#define mod 1000000007\nusing namespace std;\nbool vh[1000005],vw[1000005],ban[65][65];\nint bh[1000005],bw[1000005],nh[1000005];\nint nw[1000005],h,w,n,x[31],y[31],c1=0,c2=0;\nint kh[105],kw[105],wgt[65][65],dis[65][65];\nint que[10005][2],l=1,r=0;\ninline int mul(int a,int b){\n\treturn 1ll*a*b%mod;\n}\n\ninline int sub(int a,int b){\n\treturn(a-b<0?a-b+mod:a-b);\n}\n\ninline bool ok(int a,int b){\n\tif(a<=0||a>c1||b<=0||b>c2||ban[a][b])\n\treturn 0;\n\treturn 1;\n}\n\nint main(){\n\tint i,j,k,l,ans=0;\n\tscanf(\"%d%d%d\",&h,&w,&n);\n\tfor(i=1;i<=n;++i){\n\t\tscanf(\"%d%d\",&x[i],&y[i]);\n\t\t++x[i];++y[i];\n\t\t++nh[x[i]];++nw[y[i]];\n\t\tvh[x[i]]=vw[y[i]]=1;\n\t}\n\tbh[1]=++c1;++kh[1];\n\tint lo=0,tot=mul(h,w)-n;\n\tif(tot<0) tot+=mod;\n\tfor(i=2;i<=h;++i){\n\t\tlo+=(w-nh[i-1]);\n\t\tif(lo>=mod)lo-=mod;\n\t\tif((!vh[i-1])&&(!vh[i])){\n\t\t\tans+=mul(lo,sub(tot,lo));\n\t\t\tif(ans>=mod)ans-=mod;\n\t\t\tbh[i]=bh[i-1];++kh[c1];\n\t\t}else{\n\t\t\tbh[i]=++c1;\n\t\t\tkh[c1]=1;\n\t\t}\n\t}\n\tbw[1]=++c2;++kw[1];\n\tlo=0;tot=mul(h,w)-n;\n\tif(tot<0)tot+=mod;\n\tfor(i=2;i<=w;++i){\n\t\tlo+=(h-nw[i-1]);\n\t\tif(lo>=mod)lo-=mod;\n\t\tif((!vw[i-1])&&(!vw[i])){\n\t\t\tans+=mul(lo,sub(tot,lo));\n\t\t\tif(ans>=mod)ans-=mod;\n\t\t\tbw[i]=bw[i-1];++kw[c2];\n\t\t}else{\n\t\t\tbw[i]=++c2;\n\t\t\tkw[c2]=1;\n\t\t}\n\t}\n\tfor(i=1;i<=c1;++i){\n\t\tfor(j=1;j<=c2;++j){\n\t\t\twgt[i][j]=mul(kh[i],kw[j]);\n\t\t}\n\t}\n\tfor(i=1;i<=n;++i){\n\t\tban[bh[x[i]]][bw[y[i]]]=1;\n\t}\n\tans<<=1;\n\tif(ans>=mod)ans-=mod;\n\tfor(i=1;i<=c1;++i){\n\t\tfor(j=1;j<=c2;++j){\n\t\t\tif(ban[i][j])continue;\n\t\t\tl=1;r=0;que[++r][0]=i;\n\t\t\tque[r][1]=j;\n\t\t\tmemset(dis,0x7f,sizeof(dis));\n\t\t\tdis[i][j]=0;\n\t\t\twhile(l<=r){\n\t\t\t\tint a=que[l][0],b=que[l][1];\n\t\t\t\t++l;\n\t\t\t\tif(ok(a-1,b)&&\n\t\t\t\tdis[a-1][b]>dis[a][b]+1){\n\t\t\t\t\tdis[a-1][b]=dis[a][b]+1;\n\t\t\t\t\tque[++r][0]=a-1;\n\t\t\t\t\tque[r][1]=b;\n\t\t\t\t}\n\t\t\t\tif(ok(a+1,b)&&\n\t\t\t\tdis[a+1][b]>dis[a][b]+1){\n\t\t\t\t\tdis[a+1][b]=dis[a][b]+1;\n\t\t\t\t\tque[++r][0]=a+1;\n\t\t\t\t\tque[r][1]=b;\n\t\t\t\t}\n\t\t\t\tif(ok(a-1,b)&&\n\t\t\t\tdis[a-1][b]>dis[a][b]+1){\n\t\t\t\t\tdis[a-1][b]=dis[a][b]+1;\n\t\t\t\t\tque[++r][0]=a-1;\n\t\t\t\t\tque[r][1]=b;\n\t\t\t\t}\n\t\t\t\tif(ok(a,b-1)&&\n\t\t\t\tdis[a][b-1]>dis[a][b]+1){\n\t\t\t\t\tdis[a][b-1]=dis[a][b]+1;\n\t\t\t\t\tque[++r][0]=a;\n\t\t\t\t\tque[r][1]=b-1;\n\t\t\t\t}\n\t\t\t\tif(ok(a,b+1)&&\n\t\t\t\tdis[a][b+1]>dis[a][b]+1){\n\t\t\t\t\tdis[a][b+1]=dis[a][b]+1;\n\t\t\t\t\tque[++r][0]=a;\n\t\t\t\t\tque[r][1]=b+1;\n\t\t\t\t}\n\t\t\t}\n\t\t\tint tp=0;\n\t\t\tfor(k=1;k<=c1;++k){\n\t\t\t\tfor(l=1;l<=c2;++l){\n\t\t\t\t\tif(ban[k][l])continue;\n\t\t\t\t\tint x=dis[k][l];\n\t\t\t\t\ttp+=mul(x,wgt[k][l]);\n\t\t\t\t\tif(tp>=mod)tp-=mod;\n\t\t\t\t}\n\t\t\t}\n\t\t\ttp=mul(tp,wgt[i][j]);\n\t\t\tans+=tp;\n\t\t\tif(ans>=mod)ans-=mod;\n\t\t}\n\t}\n\tif(ans&1)ans+=mod;\n\tprintf(\"%d\\n\",ans>>1);\n\treturn 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\nusing namespace std;\n#define int long long\n#define p (int)(1e9 + 7)\n\nint MOD(int a){\n\treturn a % p;\n}\n\nint h, w;\nconst int inv2 = 500000004, inv6 = 166666668;\n\nint calc(int dis, int x1, int dx1, int x2, int dx2, int y1, int dy1, int y2, int dy2){\n\tif(x2 < x1){\n\t\treturn calc(dis, x2, dx2, x1, dx1, y2, dy2, y1, dy1);\n\t}\n\telse if(y2 < y1){\n\t\treturn calc(dis + dx2 - dx1, x1, dx2, x2 + dx2 - dx1, dx1, y2, dy2, y1, dy1);\n\t}\n\telse if(x1 == x2){\n\t\treturn calc(dis, y1, dy1, y2, dy2, x1, dx1, x2, dx2);\n\t}\n\tif(y1 == y2){\n\t\tif(dy1 == 1){\n\t\t\treturn MOD(inv2 * MOD(MOD(dx1 * dx2) * (2 * dis + (dx2 - dx1))));\n\t\t}\n\t\telse{\n\t\t\treturn MOD(inv6 * MOD(MOD(dx1 * dx2 * dy1) * MOD(3 * dy1 * (2 * (x2 - x1) + (dx2 - dx1)) + (2 * (dy1 - 1) * (dy1 + 1)))));\n\t\t}\n\t}\n\telse{\n\t\treturn MOD(inv2 * MOD(MOD(MOD(dx1 * dx2) * MOD(dy1 * dy2)) * (2 * dis + (dx2 - dx1) + (dy2 - dy1))));\n\t}\n}\n\nsigned main(){\n\tint H, W, N, i, j, k, l;\n\tscanf(\"%lld%lld\", &H, &W);\n\tscanf(\"%lld\", &N);\n\tvector<int> x_sub(N), y_sub(N), x(0), y(0);\n\tfor(i = 0; i < N; i++){\n\t\tscanf(\"%lld%lld\", &x_sub[i], &y_sub[i]);\n\t\tx.push_back(x_sub[i]);\n\t\tx.push_back(x_sub[i] + 1);\n\t\tx.push_back(max(0ll, x_sub[i] - 1));\n\t\ty.push_back(y_sub[i]);\n\t\ty.push_back(y_sub[i] + 1);\n\t\ty.push_back(max(0ll, y_sub[i] - 1));\n\t}\n\tx.push_back(0);\n\tx.push_back(H);\n\ty.push_back(0);\n\ty.push_back(W);\n\tsort(x.begin(), x.end());\n\tsort(y.begin(), y.end());\n\tfor(i = 1, j = 1; j < x.size(); j++){\n\t\tif(x[j - 1] < x[j]){\n\t\t\tx[i] = x[j];\n\t\t\ti++;\n\t\t}\n\t}\n\th = i - 1;\n\tfor(i = 1, j = 1; j < y.size(); j++){\n\t\tif(y[j - 1] < y[j]){\n\t\t\ty[i] = y[j];\n\t\t\ti++;\n\t\t}\n\t}\n\tw = i - 1;\n\tvector<int> dx(h), dy(w);\n\tfor(i = 0; i < h; i++){\n\t\tdx[i] = x[i + 1] - x[i];\n\t}\n\tfor(i = 0; i < w; i++){\n\t\tdy[i] = y[i + 1] - y[i];\n\t}\n\tvector<vector<char>> A(h, vector<char>(w, '.'));\n\tfor(i = 0; i < h; i++){\n\t\tfor(j = 0; j < w; j++){\n\t\t\tfor(k = 0; k < N; k++){\n\t\t\t\tif(x[i] == x_sub[k] && y[j] == y_sub[k]){\n\t\t\t\t\tA[i][j] = '#';\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t}\n\tvector<vector<int>> dis(h, vector<int>(w, 1000000000));\n\tint ans = 0;\n\tfor(i = 0; i < h; i++){\n\t\tfor(j = 0; j < w; j++){\n\t\t\tif(A[i][j] == '#'){\n\t\t\t\tcontinue;\n\t\t\t}\n\t\t\tint sub = MOD(inv6 * MOD(MOD(dx[i] * dy[j]) * MOD((dx[i] + dy[j]) * MOD(dx[i] * dy[j] - 1))));\n\t\t\tans = MOD(ans + sub);\n\t\t\tint old_dis = dis[i][j];\n\t\t\tfor(k = 0; k < h; k++){\n\t\t\t\tfor(l = 0; l < w; l++){\n\t\t\t\t\tdis[k][l] += old_dis;\n\t\t\t\t}\n\t\t\t}\n\t\t\tqueue<pair<pair<int, int>, int>> q;\n\t\t\tq.push(pair<pair<int, int>, int>(pair<int, int>(i, j), 0));\n\t\t\twhile(q.size() > 0){\n\t\t\t\tk = q.front().first.first;\n\t\t\t\tl = q.front().first.second;\n\t\t\t\tint d = q.front().second;\n\t\t\t\tq.pop();\n\t\t\t\tif(A[k][l] == '#' || dis[k][l] <= d){\n\t\t\t\t\tcontinue;\n\t\t\t\t}\n\t\t\t\tdis[k][l] = d;\n\t\t\t\tif(l < w - 1){\n\t\t\t\t\tq.push(pair<pair<int, int>, int>(pair<int, int>(k + 0, l + 1), d + dy[l]));\n\t\t\t\t}\n\t\t\t\tif(k < h - 1){\n\t\t\t\t\tq.push(pair<pair<int, int>, int>(pair<int, int>(k + 1, l + 0), d + dx[k]));\n\t\t\t\t}\n\t\t\t\tif(l > 0){\n\t\t\t\t\tq.push(pair<pair<int, int>, int>(pair<int, int>(k + 0, l - 1), d + dy[l - 1]));\n\t\t\t\t}\n\t\t\t\tif(k > 0){\n\t\t\t\t\tq.push(pair<pair<int, int>, int>(pair<int, int>(k - 1, l + 0), d + dx[k - 1]));\n\t\t\t\t}\n\t\t\t}\n\t\t\tfor(k = 0; k < h; k++){\n\t\t\t\tfor(l = 0; l < w; l++){\n\t\t\t\t\tif(k < i || (i == k && l <= j) || A[k][l] == '#'){\n\t\t\t\t\t\tcontinue;\n\t\t\t\t\t}\n\t\t\t\t\tint res = calc(dis[k][l], x[i], dx[i], x[k], dx[k], y[j], dy[j], y[l], dy[l]);\n\t\t\t\t\tans = MOD(ans + res);\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t}\n\tprintf(\"%lld\\n\", MOD(ans + p));\n\treturn 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\nusing namespace std;\ntypedef signed long long ll;\n\n#undef _P\n#define _P(...) (void)printf(__VA_ARGS__)\n#define FOR(x,to) for(x=0;x<(to);x++)\n#define FORR(x,arr) for(auto& x:arr)\n#define ITR(x,c) for(__typeof(c.begin()) x=c.begin();x!=c.end();x++)\n#define ALL(a) (a.begin()),(a.end())\n#define ZERO(a) memset(a,0,sizeof(a))\n#define MINUS(a) memset(a,0xff,sizeof(a))\n//-------------------------------------------------------\n\nll H,W;\nint N;\nset<pair<int,int>> S;\nvector<int> Rs,Cs;\nint NR,NC;\nll weight[1010][1010];\nll ret;\nll mo=1000000007;\nint D[100][100];\n\nvoid solve() {\n\tint i,j,k,l,r,x,y; string s;\n\t\n\tll r2=(mo+1)/2;\n\tll r3=(mo+1)/3;\n\t\n\tcin>>H>>W>>N;\n\tRs.push_back(0);\n\tRs.push_back(H);\n\tCs.push_back(0);\n\tCs.push_back(W);\n\tFOR(i,N) {\n\t\tcin>>y>>x;\n\t\tRs.push_back(y);\n\t\tRs.push_back(y+1);\n\t\tCs.push_back(x);\n\t\tCs.push_back(x+1);\n\t\tS.insert({y,x});\n\t}\n\tsort(ALL(Rs));\n\tsort(ALL(Cs));\n\tRs.erase(unique(ALL(Rs)),Rs.end());\n\tCs.erase(unique(ALL(Cs)),Cs.end());\n\t\n\tNR=Rs.size();\n\tNC=Cs.size();\n\tFOR(y,NR) FOR(x,NC) {\n\t\tweight[y][x]=(Rs[y+1]-Rs[y])*(Cs[x+1]-Cs[x])%mo;\n\t\tif(S.count({Rs[y],Cs[x]})) weight[y][x]=0;\n\t}\n\t\n\tFOR(y,NR) {\n\t\tll t=Rs[y+1]-Rs[y];\n\t\tll L=0,R=0;\n\t\tFOR(x,NC) {\n\t\t\tFOR(i,y) L+=weight[i][x];\n\t\t\tfor(i=y+1;i<NR;i++) R+=weight[i][x];\n\t\t}\n\t\t(ret+=(L%mo)*(R%mo)%mo*(t-1))%=mo;\n\t\t(ret+=(W%mo)*((L+R)%mo)%mo*((t*(t-1)/2)%mo))%=mo;\n\t\t(ret+=W*W%mo*t%mo*(t+1)%mo*r2%mo*r2%mo*(((2*t+1)*r3+mo-1)%mo))%=mo;\n\t}\n\tFOR(x,NC) {\n\t\tll t=Cs[x+1]-Cs[x];\n\t\tll L=0,R=0;\n\t\tFOR(y,NR) {\n\t\t\tFOR(i,x) L+=weight[y][i];\n\t\t\tfor(i=x+1;i<NC;i++) R+=weight[y][i];\n\t\t}\n\t\t(ret+=(L%mo)*(R%mo)%mo*(t-1))%=mo;\n\t\t(ret+=(H%mo)*((L+R)%mo)%mo*((t*(t-1)/2)%mo))%=mo;\n\t\t(ret+=H*H%mo*t%mo*(t+1)%mo*r2%mo*r2%mo*(((2*t+1)*r3+mo-1)%mo))%=mo;\n\t}\n\t\n\tFOR(y,NR) FOR(x,NC) if(weight[y][x]) {\n\t\tint cy,cx,ty,tx;\n\t\tFOR(ty,NR) FOR(tx,NC) D[ty][tx]=101010;\n\t\tqueue<int> Q;\n\t\tD[y][x]=0;\n\t\tQ.push(y*100+x);\n\t\twhile(Q.size()) {\n\t\t\tcy=Q.front()/100;\n\t\t\tcx=Q.front()%100;\n\t\t\tQ.pop();\n\t\t\t\n\t\t\tint d[4]={1,0,-1,0};\n\t\t\tFOR(i,4) {\n\t\t\t\tty=cy+d[i];\n\t\t\t\ttx=cx+d[i^1];\n\t\t\t\tif(ty<0 || ty>=NR || tx<0 || tx>=NC) continue;\n\t\t\t\tif(weight[ty][tx]==0) continue;\n\t\t\t\tif(D[ty][tx]<=D[cy][cx]+1) continue;\n\t\t\t\tD[ty][tx]=D[cy][cx]+1;\n\t\t\t\tQ.push(ty*100+tx);\n\t\t\t\tif(y*100+x<ty*100+tx) (ret+=weight[y][x]*weight[ty][tx]%mo*D[ty][tx])%=mo;\n\t\t\t}\n\t\t}\n\t\t\n\t}\n\t\n\tcout<<ret<<endl;\n}\n\n\nint main(int argc,char** argv){\n\tstring s;int i;\n\tif(argc==1) ios::sync_with_stdio(false), cin.tie(0);\n\tFOR(i,argc-1) s+=argv[i+1],s+='\\n'; FOR(i,s.size()) ungetc(s[s.size()-1-i],stdin);\n\tcout.tie(0); solve(); return 0;\n}\n"
  },
  {
    "language": "C++",
    "code": "#include<iostream>\n#include<cstdio>\n#include<cstdlib>\n#include<cmath>\n#include<cstring>\n#include<algorithm>\n#define rep(i,a,b) for(int i=a;i<=b;i++)\n#define dep(i,a,b) for(int i=a;i>=b;i--)\n#define ll long long\n#define mem(x,num) memset(x,num,sizeof x)\n#define reg(x) for(int i=last[x];i;i=e[i].next)\nusing namespace std;\ninline ll read(){\n\tll f=1,x=0;char ch=getchar();\n\twhile(ch<'0'||ch>'9'){if(ch=='-')f=-1;ch=getchar();}\n\twhile(ch>='0'&&ch<='9'){x=x*10+ch-'0';ch=getchar();}\n\treturn x*f;\n}\n//**********head by yjjr**********\n#define pb push_back\n#define inf 1e9\ntemplate<class T>inline void vnique(vector<T> &r){sort(r.begin(),r.end());auto t=unique(r.begin(),r.end());r.erase(t,r.end());}\nconst int maxn=66,maxm=1e6+6,dx[4]={-1,1,0,0},dy[4]={0,0,-1,1},mod=1e9+7;\nstruct node{int x,y;}a[maxn<<1],que[maxn<<2];\nint n,m,K,ans,lx,ly,cnt[maxn][maxn],s1[maxm],s2[maxm],dis[maxn][maxn],head,tail;\nbool fb[maxn][maxn],mark1[maxm],mark2[maxm];\nvector<int>px,py;\nvoid bfs(int x,int y){\n\trep(i,0,lx)rep(j,0,ly)dis[i][j]=inf;\n\tdis[x][y]=0;que[head=tail=1]=(node){x,y};\n\twhile(head<=tail){\n\t\tint nx=que[head].x,ny=que[head++].y;\n\t\trep(i,0,3){\n\t\t\tint nex=nx+dx[i],ney=ny+dy[i];\n\t\t\tif(nex>lx||nex<0||ney>ly||ney<0||dis[nex][ney]<=dis[nx][ny]+1||fb[nex][ney])continue;\n\t\t\tdis[nex][ney]=dis[nx][ny]+1;que[++tail]=(node){nex,ney};\n\t\t}\n\t}\n}\nint main()\n{\n\tn=read(),m=read(),K=read();\n\tpx.pb(1);px.pb(n+1);py.pb(1);py.pb(m+1);\n\trep(i,1,n)s1[i]=m;\n\trep(i,1,m)s2[i]=n;\n\trep(i,1,K){\n\t\ta[i].x=read()+1,a[i].y=read()+1;\n\t\tpx.pb(a[i].x),px.pb(a[i].x+1);\n\t\tpy.pb(a[i].y),py.pb(a[i].y+1);\n\t\ts1[a[i].x]--,mark1[a[i].x]=1;\n\t\ts2[a[i].y]--,mark2[a[i].y]=1;\n\t}\n\trep(i,1,n)s1[i]=(s1[i]+s1[i-1])%mod;\n\trep(i,1,m)s2[i]=(s2[i]+s2[i-1])%mod;\n\trep(i,1,n-1)if(!mark1[i]&&!mark1[i+1])ans=(ans+1ll*2*s1[i]*(s1[n]-s1[i]))%mod;\n\trep(i,1,m-1)if(!mark2[i]&&!mark2[i+1])ans=(ans+1ll*2*s2[i]*(s2[m]-s2[i]))%mod;\n\tvnique(px);vnique(py);lx=px.size()-2;ly=py.size()-2;\n\trep(i,1,K)\n\t\tfb[lower_bound(px.begin(),px.end(),a[i].x)-px.begin()][lower_bound(py.begin(),py.end(),a[i].y)-py.begin()]=1;\n\trep(i,0,lx)rep(j,0,ly)cnt[i][j]=1ll*(px[i+1]-px[i])*(py[j+1]-py[j])%mod;\n\trep(i,0,lx)rep(j,0,ly)\n\t\tif(!fb[i][j]){\n\t\t\tbfs(i,j);\n\t\t\trep(k,0,lx)rep(p,0,ly)\n\t\t\t\tif(!fb[k][p])ans=(ans+1ll*cnt[i][j]*dis[k][p]%mod*cnt[k][p])%mod; \n   \t\t}\n\tans=(ans+mod)%mod;ans=1ll*ans*(mod/2+1)%mod;\n\tcout<<ans<<endl;\n\treturn 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include<iostream>\n#include<cstdio>\n#include<cstdlib>\n#include<cmath>\n#include<cstring>\n#include<algorithm>\n#include<vector>\n#define rep(i,a,b) for(int i=a;i<=b;i++)\n#define dep(i,a,b) for(int i=a;i>=b;i--)\n#define ll long long\n#define mem(x,num) memset(x,num,sizeof x)\n#define reg(x) for(int i=last[x];i;i=e[i].next)\nusing namespace std;\ninline ll read(){\n\tll f=1,x=0;char ch=getchar();\n\twhile(ch<'0'||ch>'9'){if(ch=='-')f=-1;ch=getchar();}\n\twhile(ch>='0'&&ch<='9'){x=x*10+ch-'0';ch=getchar();}\n\treturn x*f;\n}\n//**********head by yjjr**********\n#define pb push_back\n#define inf 1e9\ntemplate<class T>void vnique(vector<T> &r){sort(r.begin(),r.end());auto t=unique(r.begin(),r.end());r.erase(t,r.end());}\nconst int maxn=66,maxm=1e6+6,dx[4]={-1,1,0,0},dy[4]={0,0,-1,1},mod=1e9+7;\nstruct node{int x,y;}a[maxn<<1],que[maxn*maxn*8];\nint n,m,K,ans,lx,ly,cnt[maxn][maxn],s1[maxm],s2[maxm],dis[maxn][maxn],head,tail;\nbool fb[maxn][maxn],mark1[maxm],mark2[maxm];\nvector<int>px,py;\nvoid bfs(int x,int y){\n\trep(i,0,lx)rep(j,0,ly)dis[i][j]=inf;\n\tdis[x][y]=0;que[head=tail=1]=(node){x,y};\n\twhile(head<=tail){\n\t\tint nx=que[head].x,ny=que[head++].y;\n\t\trep(i,0,3){\n\t\t\tint nex=nx+dx[i],ney=ny+dy[i];\n\t\t\tif(nex>lx||nex<0||ney>ly||ney<0||dis[nex][ney]<=dis[nx][ny]+1||fb[nex][ney])continue;\n\t\t\tdis[nex][ney]=dis[nx][ny]+1;que[++tail]=(node){nex,ney};\n\t\t}\n\t}\n}\nint main()\n{\n\tn=read(),m=read(),K=read();\n\tpx.pb(1);px.pb(n+1);py.pb(1);py.pb(m+1);\n\trep(i,1,n)s1[i]=m;\n\trep(i,1,m)s2[i]=n;\n\trep(i,1,K){\n\t\ta[i].x=read()+1,a[i].y=read()+1;\n\t\tpx.pb(a[i].x),px.pb(a[i].x+1);\n\t\tpy.pb(a[i].y),py.pb(a[i].y+1);\n\t\ts1[a[i].x]--,mark1[a[i].x]=1;\n\t\ts2[a[i].y]--,mark2[a[i].y]=1;\n\t}\n\trep(i,1,n)s1[i]=(s1[i]+s1[i-1])%mod;\n\trep(i,1,m)s2[i]=(s2[i]+s2[i-1])%mod;\n\trep(i,1,n-1)if(!mark1[i]&&!mark1[i+1])ans=(ans+1ll*2*s1[i]*(s1[n]-s1[i]))%mod;\n\trep(i,1,m-1)if(!mark2[i]&&!mark2[i+1])ans=(ans+1ll*2*s2[i]*(s2[m]-s2[i]))%mod;\n\tvnique(px);vnique(py);lx=px.size()-2;ly=py.size()-2;\n\trep(i,1,K)\n\t\tfb[lower_bound(px.begin(),px.end(),a[i].x)-px.begin()][lower_bound(py.begin(),py.end(),a[i].y)-py.begin()]=1;\n\trep(i,0,lx)rep(j,0,ly)cnt[i][j]=1ll*(px[i+1]-px[i])*(py[j+1]-py[j])%mod;\n\trep(i,0,lx)rep(j,0,ly)\n\t\tif(!fb[i][j]){\n\t\t\tbfs(i,j);\n\t\t\trep(k,0,lx)rep(p,0,ly)\n\t\t\t\tif(!fb[k][p])ans=(ans+1ll*cnt[i][j]*dis[k][p]%mod*cnt[k][p])%mod; \n   \t\t}\n\tans=(ans+mod)%mod;ans=1ll*ans*(mod/2+1)%mod;\n\tcout<<ans<<endl;\n\treturn 0;\n}"
  },
  {
    "language": "C++",
    "code": "/*\n妙题，神\n考虑第 i 行和第 i + 1 行之间的边的贡献\n显然是 (1 ~ i 行白点贡献) * (i + 1 ~ h 行白点贡献)\n那么算过贡献以后将 i 和 i + 1 合并，将该行的值从 1 变为 2\n对列也这么做一遍\n最后剩下的是个 2n * 2n 的方格图\nbfs一遍，n^4\n*/\n#include <bits/stdc++.h>\n#define rep(i, x, y) for (int i = x; i <= y; i++)\nusing namespace std;\n\ntypedef long long ll;\nconst int mod = 1e9 + 7, N = 1e6 + 10, M = 105, inf = 0x3f3f3f3f;\nll h, w, n, xx, yy, r[N], c[N], ans, cnt[M][M];\nint dis[M][M];\nbool mp[M][M];\nstruct node { ll x, y; }a[N];\nvector<int> row, col;\nconst int d[][2] = {{0, 1}, {0, -1}, {1, 0}, {-1, 0}};\n\nvoid uniq(vector<int> &vec) {\n    sort(vec.begin(), vec.end());\n    vec.erase(unique(vec.begin(), vec.end()), vec.end());  // !!!\n}\n\nqueue<node> q;\nvoid bfs(int sx, int sy) {\n    memset(dis, 0x3f, sizeof(dis));\n    q.push((node){sx, sy});\n    dis[sx][sy] = 0;\n    while (q.size()) {\n        node t = q.front(); q.pop();\n        rep(i, 0, 3) {\n            int tx = t.x + d[i][0], ty = t.y + d[i][1];\n            if (tx < 0 || ty < 0 || tx > xx || ty > yy || mp[tx][ty] || dis[tx][ty] != inf) continue;\n            dis[tx][ty] = dis[t.x][t.y] + 1;\n            q.push((node){tx, ty});\n        }\n    }\n}\n\nint main() {\n    cin >> h >> w >> n;\n    rep(i, 1, h) r[i] = w;\n    rep(i, 1, w) c[i] = h;\n    row.push_back(1), row.push_back(h + 1), col.push_back(1), col.push_back(w + 1);\n    rep(i, 1, n) {\n        scanf(\"%lld%lld\", &a[i].x, &a[i].y);\n        ++a[i].x, ++a[i].y;\n        row.push_back(a[i].x), row.push_back(a[i].x + 1);\n        col.push_back(a[i].y), col.push_back(a[i].y + 1);\n        r[a[i].x]--, c[a[i].y]--;\n    }\n    uniq(row), uniq(col);\n    rep(i, 1, n) {\n        int x = lower_bound(row.begin(), row.end(), a[i].x) - row.begin();\n        int y = lower_bound(col.begin(), col.end(), a[i].y) - col.begin();\n        mp[x][y] = 1;\n    }\n    \n    rep(i, 1, h) r[i] = (r[i] + r[i - 1]) % mod;\n    rep(i, 1, w) c[i] = (c[i] + c[i - 1]) % mod;\n    rep(i, 1, h - 1)\n        if ((r[i] - r[i - 1] + mod) % mod == w && (r[i + 1] - r[i] + mod) % mod == w)\n            ans = (ans + 2 * r[i] * (r[h] - r[i] + mod) % mod) % mod;  // * 2, 后面会 / 回去\n    rep(i, 1, w - 1)\n        if ((c[i] - c[i - 1] + mod) % mod == h && (c[i + 1] - c[i] + mod) % mod == h)\n            ans = (ans + 2 * c[i] * (c[w] - c[i] + mod) % mod) % mod;\n    \n    xx = row.size() - 2;\n    yy = col.size() - 2;\n    rep(i, 0, xx)\n        rep(j, 0, yy)\n            if (!mp[i][j])\n                cnt[i][j] = 1ll * (row[i + 1] - row[i]) * (col[j + 1] - col[j]) % mod;  // !!!\n\n    rep(i, 0, xx) {\n        rep(j, 0, yy) {\n            if (!mp[i][j]) {\n                bfs(i, j);\n                rep(k, 0, xx) {\n                    rep(l, 0, yy) {\n                        if (!mp[k][l]) {\n                            ans = (ans + cnt[i][j] * dis[k][l] % mod * cnt[k][l] % mod) % mod;\n                        }\n                    }\n                }\n            }\n        }\n    }\n    printf(\"%lld\\n\", ans * (mod / 2 + 1) % mod);  // mod / 2 + 1 = (mod - mod / 2) * inv[mod % 2] % mod\n    return 0;\n}\n"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\n#define fe first\n#define se second\n\nusing namespace std;\n\nconst int maxn = 105, mo = int(1e9) + 7;\nconst int inv_2 = 500000004, inv_6 = 166666668;\nconst int xy[4][2] = {{1,0},{0,1},{-1,0},{0,-1}};\n\ntypedef pair<int,int> pi;\n\nmap<pi,bool> hole;\n\nbool bl[maxn][maxn];\npi pos[maxn];\nint H,W,n,new_r[maxn][2],new_c[maxn][2],w[maxn][maxn],r_cnt,c_cnt;\nint ans;\n\nint sq_sum(int l,int r)\n{\n\tif (l > r) return 0;\n\tif (l > 1) return (sq_sum(1,r) - sq_sum(1,l - 1) + mo) % mo;\n\treturn r * 1ll * (r + 1) % mo * (2ll * r + 1) % mo * inv_6 % mo;\n}\n\nint n_sum(int l,int r)\n{\n\tif (l > r) return 0;\n\treturn (l + r) * 1ll * (r - l + 1) % mo * inv_2 % mo;\n}\n\nvoid row_compress()\n{\n\tsort(pos + 1,pos + n + 1);\n\tfor(int i = 1;i <= n + 1;i ++)\n\t{\n\t\tint lr = pos[i - 1].fe + 1, rr = pos[i].fe - 1;\n\t\tif (lr <= rr)\n\t\t{\n\t\t\tnew_r[++ r_cnt][0] = lr,new_r[r_cnt][1] = rr;\n\t\t\tlong long C1 = 1 - i,C2 = (W * 1ll * H % mo - n + i - 1) % mo;\n\t\t\tans = ((ans - W * 1ll * W % mo * sq_sum(lr,rr - 1)) % mo + \n\t\t\t\t\t(C2 - C1) % mo * 1ll * W % mo * n_sum(lr,rr - 1) % mo) % mo;\n\t\t\tans = (ans + C1 * 1ll * C2 % mo * (rr - lr)) % mo; \n\t\t}\n\t\tif (pos[i].fe != pos[i - 1].fe && i != n + 1)\n\t\t\tnew_r[++ r_cnt][0] = new_r[r_cnt][1] = pos[i].fe;\n\t}\n}\n\nvoid whole_dp()\n{\n\tfor(int i = 1;i <= n;i ++)\n\t\thole[pos[i]] = 1;\n\tfor(int i = 1;i <= r_cnt;i ++)\n\t\tfor(int j = 1;j <= c_cnt;j ++)\n\t\t{\n\t\t\tw[i][j] = (new_r[i][1] - new_r[i][0] + 1) * 1ll * (new_c[j][1] - new_c[j][0] + 1) % mo;\n\t\t\tif (w[i][j] == 1)\n\t\t\t\tbl[i][j] = hole[pi(new_r[i][0],new_c[j][0])];\n\t\t}\n\tstatic int vis[maxn][maxn];\n\tint vis_cnt = 0;\n\tfor(int i = 1;i <= r_cnt;i ++)\n\t\tfor(int j = 1;j <= c_cnt;j ++)\n\t\t\tif (!bl[i][j])\n\t\t\t{\n\t\t\t\tstatic int que[maxn * maxn][3];\n\t\t\t\t++ vis_cnt;\n\t\t\t\tint en = 1;\n\t\t\t\tque[en][0] = i,que[en][1] = j,que[en][2] = 0;\n\t\t\t\tvis[i][j] = vis_cnt;\n\t\t\t\tfor(int k = 1;k <= en;k ++)\n\t\t\t\t{\n\t\t\t\t\tint x = que[k][0],y = que[k][1],d = que[k][2];\n\t\t\t\t\tans = (ans + w[i][j] * 1ll * w[x][y] % mo * d) % mo;\n\t\t\t\t\tfor(int p = 0;p < 4;p ++)\n\t\t\t\t\t{\n\t\t\t\t\t\tint nx = x + xy[p][0],ny = y + xy[p][1];\n\t\t\t\t\t\tif (nx && ny && nx <= r_cnt && ny <= c_cnt && !bl[nx][ny] && vis[nx][ny] != vis_cnt)\n\t\t\t\t\t\t{\n\t\t\t\t\t\t\tvis[nx][ny] = vis_cnt;\n\t\t\t\t\t\t\tque[++ en][0] = nx, que[en][1] = ny, que[en][2] = d + 1;\n\t\t\t\t\t\t}\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t}\n}\n\nint main()\n{\n\tscanf(\"%d%d%d\", &H, &W, &n);\n\tfor(int i = 1;i <= n;i ++)\n\t{\n\t\tscanf(\"%d%d\", &pos[i].fe, &pos[i].se);\n\t\tpos[i].fe ++, pos[i].se ++;\n\t}\n\tpos[n + 1] = pi(H + 1,W + 1);\n\trow_compress();\n\tswap(new_r,new_c),swap(r_cnt,c_cnt);\n\tfor(int i = 1;i <= n + 1;i ++) swap(pos[i].fe, pos[i].se);\n\tswap(H,W);\n\trow_compress();\n\tans = (ans + mo) % mo * 2ll % mo;\n\twhole_dp();\n\tprintf(\"%d\\n\", ans * 1ll * inv_2 % mo);\n\treturn 0;\n}\n"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\n#define rep(i,n) for(int i=0;i<(int)(n);i++)\n#define rep1(i,n) for(int i=1;i<=(int)(n);i++)\n#define all(c) c.begin(),c.end()\n#define pb push_back\n#define fs first\n#define sc second\n#define show(x) cout << #x << \" = \" << x << endl\n#define chmin(x,y) x=min(x,y)\n#define chmax(x,y) x=max(x,y)\nusing namespace std;\ntemplate<class S,class T> ostream& operator<<(ostream& o,const pair<S,T> &p){return o<<\"(\"<<p.fs<<\",\"<<p.sc<<\")\";}\ntemplate<class T> ostream& operator<<(ostream& o,const vector<T> &vc){o<<\"sz = \"<<vc.size()<<endl<<\"[\";for(const T& v:vc) o<<v<<\",\";o<<\"]\";return o;}\n \ntemplate<unsigned int mod_>\nstruct ModInt{\n\tusing uint = unsigned int;\n\tusing ll = long long;\n\tusing ull = unsigned long long;\n \n\tconstexpr static uint mod = mod_;\n \n\tuint v;\n\tModInt():v(0){}\n\tModInt(ll v):v(normS(v%mod+mod)){}\n\texplicit operator bool() const {return v!=0;}\n\tstatic uint normS(const uint &x){return (x<mod)?x:x-mod;}\t\t// [0 , 2*mod-1] -> [0 , mod-1]\n\tstatic ModInt make(const uint &x){ModInt m; m.v=x; return m;}\n\tModInt operator+(const ModInt& b) const { return make(normS(v+b.v));}\n\tModInt operator-(const ModInt& b) const { return make(normS(v+mod-b.v));}\n\tModInt operator-() const { return make(normS(mod-v)); }\n\tModInt operator*(const ModInt& b) const { return make((ull)v*b.v%mod);}\n\tModInt operator/(const ModInt& b) const { return *this*b.inv();}\n\tModInt& operator+=(const ModInt& b){ return *this=*this+b;}\n\tModInt& operator-=(const ModInt& b){ return *this=*this-b;}\n\tModInt& operator*=(const ModInt& b){ return *this=*this*b;}\n\tModInt& operator/=(const ModInt& b){ return *this=*this/b;}\n\tll extgcd(ll a,ll b,ll &x,ll &y) const{\n\t\tll u[]={a,1,0},v[]={b,0,1};\n\t\twhile(*v){\n\t\t\tll t=*u/ *v;\n\t\t\trep(i,3) swap(u[i]-=t*v[i],v[i]);\n\t\t}\n\t\tif(u[0]<0) rep(i,3) u[i]=-u[i];\n\t\tx=u[1],y=u[2];\n\t\treturn u[0];\n\t}\n\tModInt inv() const{\n\t\tll x,y;\n\t\textgcd(v,mod,x,y);\n\t\treturn make(normS(x+mod));\n\t}\n\tbool operator==(const ModInt& b) const { return v==b.v;}\n\tbool operator!=(const ModInt& b) const { return v!=b.v;}\n\tfriend istream& operator>>(istream &o,ModInt& x){\n\t\tll tmp;\n\t\to>>tmp;\n\t\tx=ModInt(tmp);\n\t\treturn o;\n\t}\n\tfriend ostream& operator<<(ostream &o,const ModInt& x){ return o<<x.v;}\n};\nusing mint = ModInt<1000000007>;\n \nconst int MX = 1000010;\nint numx[MX],numy[MX];\n \nint main(){\n\tint X,Y,N;\n\tcin>>X>>Y>>N;\n\tvector<int> x(N),y(N);\n\tvector<int> xs,ys;\n\trep(i,N){\n\t\tcin>>x[i]>>y[i];\n\t\tnumx[x[i]+1]++;\n\t\tnumy[y[i]+1]++;\n\t\txs.pb(x[i]);xs.pb(x[i]+1);\n\t\tys.pb(y[i]);ys.pb(y[i]+1);\n\t}\n\trep(i,MX-1) numx[i+1]+=numx[i],numy[i+1]+=numy[i];\n \n\txs.pb(0);xs.pb(X);\n\tys.pb(0);ys.pb(Y);\n\tsort(all(xs));xs.erase(unique(xs.begin(),xs.end()),xs.end());\n\tsort(all(ys));ys.erase(unique(ys.begin(),ys.end()),ys.end());\n \n\tmint ans = 0;\n \n\trep1(i,X-1){\n\t\tif(numx[i]!=numx[i+1] || numx[i]!=numx[i-1]) continue;\n\t\tmint a = mint(1)*i*Y - numx[i];\n\t\tmint b = mint(1)*X*Y - N - a;\n\t\tans += a*b;\n\t}\n\trep1(i,Y-1){\n\t\tif(numy[i]!=numy[i+1] || numy[i]!=numy[i-1]) continue;\n\t\tmint a = mint(1)*i*X - numy[i];\n\t\tmint b = mint(1)*X*Y - N - a;\n\t\tans += a*b;\n\t}\n \n\tX = xs.size()-1, Y = ys.size()-1;\n \n\tvector<vector<bool>> board(X,vector<bool>(Y,false));\n\tvector<vector<mint>> w(X,vector<mint>(Y));\n \n\trep(i,N){\n\t\tint xid = lower_bound(all(xs),x[i]) - xs.begin();\n\t\tint yid = lower_bound(all(ys),y[i]) - ys.begin();\n\t\tboard[xid][yid] = 1;\n\t}\n \n\trep(i,X){\n\t\trep(j,Y){\n\t\t\tw[i][j] = mint(1) * (xs[i+1]-xs[i]) * (ys[j+1]-ys[j]);\n\t\t}\n\t}\n \n\tint dx[4] = {1,0,-1,0};\n\tint dy[4] = {0,1,0,-1};\n\tauto is = [&](int x,int y){\n\t\treturn 0<=x && x<X && 0<=y && y<Y && !board[x][y];\n\t};\n\tint inf = 1e5;\n \n\tmint ans2 = 0;\n \n\trep(sx,X){\n\t\trep(sy,Y){\n\t\t\tif(board[sx][sy]) continue;\n\t\t\tvector<vector<int>> d(X,vector<int>(Y,inf));\n\t\t\tqueue<int> qx,qy;\n \n\t\t\td[sx][sy] = 0;\n\t\t\tqx.push(sx),qy.push(sy);\n \n\t\t\twhile(!qx.empty()){\n\t\t\t\tint x = qx.front(), y = qy.front();\n\t\t\t\tqx.pop(),qy.pop();\n\t\t\t\trep(j,4){\n\t\t\t\t\tint nx = x+dx[j], ny = y+dy[j];\n\t\t\t\t\tif(is(nx,ny) && d[nx][ny]==inf){\n\t\t\t\t\t\td[nx][ny] = d[x][y] + 1;\n\t\t\t\t\t\tqx.push(nx),qy.push(ny);\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t}\n\t\t\trep(tx,X) rep(ty,Y) if(!board[tx][ty]){\n\t\t\t\tmint tmp = w[sx][sy] * w[tx][ty] * d[tx][ty];\n\t\t\t\tans2 += tmp;\n\t\t\t}\n\t\t}\n\t}\n\tans2 /= 2;\n \n\tans += ans2;\n \n\tcout << ans << endl;\n \n}"
  },
  {
    "language": "C++",
    "code": "#include<bits/stdc++.h>\n#define mod 1000000007\nusing namespace std;\nbool vh[1000005],vw[1000005],ban[65][65];\nint bh[1000005],bw[1000005],nh[1000005];\nint nw[1000005],h,w,n,x[31],y[31],c1=0,c2=0;\nint kh[105],kw[105],wgt[65][65],dis[65][65];\nint que[10005][2],l=1,r=0;\ninline int mul(int a,int b){\n\treturn 1ll*a*b%mod;\n}\n\ninline int sub(int a,int b){\n\treturn(a-b<0?a-b+mod:a-b);\n}\n\ninline bool ok(int a,int b){\n\tif(a<=0||a>c1||b<=0||b>c2||ban[a][b])\n\treturn 0;\n\treturn 1;\n}\n\nint main(){\n\tint i,j,k,l,ans=0;\n\tscanf(\"%d%d%d\",&h,&w,&n);\n\tfor(i=1;i<=n;++i){\n\t\tscanf(\"%d%d\",&x[i],&y[i]);\n\t\t++x[i];++y[i];\n\t\t++nh[x[i]];++nw[y[i]];\n\t\tvh[x[i]]=vw[y[i]]=1;\n\t}\n\tbh[1]=++c1;++kh[1];\n\tint lo=0,tot=mul(h,w)-n;\n\tif(tot<0) tot+=mod;\n\tfor(i=2;i<=h;++i){\n\t\tlo+=(w-nh[i-1]);\n\t\tif(lo>=mod)lo-=mod;\n\t\tif((!vh[i-1])&&(!vh[i])){\n\t\t\tans+=mul(lo,sub(tot,lo));\n\t\t\tif(ans>=mod)ans-=mod;\n\t\t\tbh[i]=bh[i-1];++kh[c1];\n\t\t}else{\n\t\t\tbh[i]=++c1;\n\t\t\tkh[c1]=1;\n\t\t}\n\t}\n\tbw[1]=++c2;++kw[1];\n\tlo=0;tot=mul(h,w)-n;\n\tif(tot<0)tot+=mod;\n\tfor(i=2;i<=w;++i){\n\t\tlo+=(h-nw[i-1]);\n\t\tif(lo>=mod)lo-=mod;\n\t\tif((!vw[i-1])&&(!vw[i])){\n\t\t\tans+=mul(lo,sub(tot,lo));\n\t\t\tif(ans>=mod)ans-=mod;\n\t\t\tbw[i]=bw[i-1];++kw[c2];\n\t\t}else{\n\t\t\tbw[i]=++c2;\n\t\t\tkw[c2]=1;\n\t\t}\n\t}\n\tfor(i=1;i<=c1;++i){\n\t\tfor(j=1;j<=c2;++j){\n\t\t\twgt[i][j]=mul(kh[i],kw[j]);\n\t\t}\n\t}\n\tfor(i=1;i<=n;++i){\n\t\tban[bh[x[i]]][bw[y[i]]]=1;\n\t}\n\tans<<=1;\n\tif(ans>=mod)ans-=mod;\n\tfor(i=1;i<=c1;++i){\n\t\tfor(j=1;j<=c2;++j){\n\t\t\tif(ban[i][j])continue;\n\t\t\tl=1;r=0;que[++r][0]=i;\n\t\t\tque[r][1]=j;\n\t\t\tmemset(dis,0x7f,sizeof(dis));\n\t\t\tdis[i][j]=0;\n\t\t\twhile(l<=r){\n\t\t\t\tint a=que[l][0],b=que[l][1];\n\t\t\t\t++l;\n\t\t\t\tif(ok(a-1,b)&&\n\t\t\t\tdis[a-1][b]>dis[a][b]+1){\n\t\t\t\t\tdis[a-1][b]=dis[a][b]+1;\n\t\t\t\t\tque[++r][0]=a-1;\n\t\t\t\t\tque[r][1]=b;\n\t\t\t\t}\n\t\t\t\tif(ok(a+1,b)&&\n\t\t\t\tdis[a+1][b]>dis[a][b]+1){\n\t\t\t\t\tdis[a+1][b]=dis[a][b]+1;\n\t\t\t\t\tque[++r][0]=a+1;\n\t\t\t\t\tque[r][1]=b;\n\t\t\t\t}\n\t\t\t\tif(ok(a-1,b)&&\n\t\t\t\tdis[a-1][b]>dis[a][b]+1){\n\t\t\t\t\tdis[a-1][b]=dis[a][b]+1;\n\t\t\t\t\tque[++r][0]=a-1;\n\t\t\t\t\tque[r][1]=b;\n\t\t\t\t}\n\t\t\t\tif(ok(a,b-1)&&\n\t\t\t\tdis[a][b-1]>dis[a][b]+1){\n\t\t\t\t\tdis[a][b-1]=dis[a][b]+1;\n\t\t\t\t\tque[++r][0]=a;\n\t\t\t\t\tque[r][1]=b-1;\n\t\t\t\t}\n\t\t\t\tif(ok(a,b+1)&&\n\t\t\t\tdis[a][b+1]>dis[a][b]+1){\n\t\t\t\t\tdis[a][b+1]=dis[a][b]+1;\n\t\t\t\t\tque[++r][0]=a;\n\t\t\t\t\tque[r][1]=b+1;\n\t\t\t\t}\n\t\t\t}\n\t\t\tint tp=0;\n\t\t\tfor(k=1;k<=c1;++k){\n\t\t\t\tfor(l=1;l<=c2;++l){\n\t\t\t\t\tif(ban[k][l])continue;\n\t\t\t\t\tint x=dis[k][l];\n\t\t\t\t\ttp+=mul(x,wgt[k][l]);\n\t\t\t\t\tif(tp>=mod)tp-=mod;\n\t\t\t\t}\n\t\t\t}\n\t\t\ttp=mul(tp,wgt[i][j]);\n\t\t\tans+=tp;\n\t\t\tif(ans>=mod)ans-=mod;\n\t\t}\n\t}\n\tif(ans&1)ans+=mod;\n\tprintf(\"%d\\n\",ans>>1);\n\treturn 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include <iostream>\n#include <cstdio>\n#include <cstring>\n#include <vector>\n#include <algorithm>\n#include <cmath>\n#include <queue>\n\nusing namespace std;\n\n#define mp make_pair\n#define pb push_back\n#define ll long long\n\n#define maxN 111\n#define mod 1000000007\n#define cos vraja_muntelui_in_marea_albastra\n\nll defX[4] = {-1, 1, 0, 0};\nll defY[4] = {0, 0, -1, 1};\n\nll H, W, i, j, n;\npair<ll, ll> P[maxN];\nvector<ll> xx, yy;\nll ans;\n\nll lns, cos;\nll coef_ln[maxN], coef_co[maxN];\n\nbool deny[maxN][maxN];\nll dist[maxN][maxN];\nll coef[maxN][maxN];\nqueue< pair<ll, ll> > Q;\n\nvoid compress_line(int ln) {\n    ll up, down;\n    int i;\n\n    up = ln * W;\n    down = (H - ln) * W;\n\n    for (i = 1; i <= n; i++) {\n        if (P[i].first <= ln)\n            up--;\n        else\n            down--;\n    }\n\n    up %= mod;\n    down %= mod;\n    ans += up * down;\n    ans %= mod;\n}\n\nvoid compress_column(int co) {\n    ll le, ri;\n    int i;\n\n    le = co * H;\n    ri = (W - co) * H;\n\n    for (i = 1; i <= n; i++) {\n        if (P[i].second <= co)\n            le--;\n        else\n            ri--;\n    }\n\n    le %= mod;\n    ri %= mod;\n    ans += le * ri;\n    ans %= mod;\n}\n\nvoid add_black_cell(int x, int y) {\n    int i, x_comp, y_comp;\n\n    for (x_comp = 1; coef_ln[x_comp] < x; x -= coef_ln[x_comp++]);\n    for (y_comp = 1; coef_co[y_comp] < y; y -= coef_co[y_comp++]);\n\n    deny[x_comp][y_comp] = true;\n}\n\nvoid run_bfs() {\n    int i, x, y, xx, yy;\n\n    while (!Q.empty()) {\n        x = Q.front().first;\n        y = Q.front().second;\n        Q.pop();\n\n        for (i = 0; i < 4; i++) {\n            xx = x + defX[i];\n            yy = y + defY[i];\n\n            if (deny[xx][yy] || (dist[xx][yy] != 0)) continue;\n            dist[xx][yy] = dist[x][y] + 1;\n            Q.push(mp(xx, yy));\n        }\n    }\n}\n\nvoid brute() {\n    int i, j, k, l;\n\n    for (i = 1; i <= lns; i++) {\n        for (j = 1; j <= cos; j++) {\n            if (deny[i][j]) continue;\n\n            memset(dist, 0, sizeof(dist));\n            Q.push(mp(i, j));\n            dist[i][j] = 1;\n\n            run_bfs();\n\n            for (k = 1; k <= lns; k++)\n                for (l = 1; l <= cos; l++)\n                    if (!deny[k][l])\n                        ans += ((coef[i][j] * coef[k][l]) % mod) * (dist[k][l] - 1), ans %= mod;\n        }\n    }\n}\n\nint main()\n{\n   // freopen(\"test.in\",\"r\",stdin);\n\n    cin >> H >> W >> n;\n    for (i = 1; i <= n; i++) {\n        cin >> P[i].first >> P[i].second;\n        P[i].first++;\n        P[i].second++;\n        xx.pb(P[i].first);\n        yy.pb(P[i].second);\n    }\n\n    xx.pb(0);\n    xx.pb(H + 1);\n\n    yy.pb(0);\n    yy.pb(W + 1);\n\n    sort(xx.begin(), xx.end());\n    xx.resize(unique(xx.begin(), xx.end()) - xx.begin());\n\n    sort(yy.begin(), yy.end());\n    yy.resize(unique(yy.begin(), yy.end()) - yy.begin());\n\n    for (i = 0; i + 1 < xx.size(); i++) {\n        if (i != 0) coef_ln[++lns] = 1;\n\n        if (xx[i + 1] - xx[i] >= 2) {\n            coef_ln[++lns] = xx[i + 1] - xx[i] - 1;\n\n            for (j = xx[i] + 1; j + 1 < xx[i + 1]; j++)\n                compress_line(j);\n        }\n    }\n\n    for (i = 0; i + 1 < yy.size(); i++) {\n        if (i != 0) coef_co[++cos] = 1;\n\n        if (yy[i + 1] - yy[i] >= 2) {\n            coef_co[++cos] = yy[i + 1] - yy[i] - 1;\n\n            for (j = yy[i] + 1; j + 1 < yy[i + 1]; j++)\n                compress_column(j);\n        }\n    }\n\n    for (i = 0; i <= cos; i++)\n        deny[0][i] = deny[lns + 1][i] = true;\n\n    for (i = 0; i <= lns; i++)\n        deny[i][0] = deny[i][cos + 1] = true;\n\n    for (i = 1; i <= n; i++)\n        add_black_cell(P[i].first, P[i].second);\n\n    for (i = 1; i <= lns; i++)\n        for (j = 1; j <= cos; j++)\n            coef[i][j] = (coef_ln[i] * coef_co[j]) % mod;\n\n    ans *= 2;\n    brute();\n    ans = (ans * ( (mod + 1) / 2 )) % mod;\n\n    cout << ans;\n\n    return 0;\n}\n"
  },
  {
    "language": "C++",
    "code": "#include<iostream>\n#include<vector>\n#include<algorithm>\n#include<cstring>\n#include<cstdio>\n#include<cmath>\n#include<cstdlib>\n#include<ctime>\n#include<queue>\n#include<set>\n#include<map>\n#include<stack>\n#include<bitset>\n\n#define pb push_back\n#define mp make_pair\n\nusing namespace std;\n\ntemplate<typename T>inline void upmin(T &x,T y) { y<x?x=y:0; }\ntemplate<typename T>inline void upmax(T &x,T y) { x<y?x=y:0; }\n\ntypedef unsigned int u32;\ntypedef long long LL;\ntypedef unsigned long long ULL;\ntypedef long double lod;\ntypedef pair<int,int> PR;\ntypedef vector<int> VI;\n\nconst lod pi=acos(-1);\nconst int oo=1<<30;\nconst LL OO=1e18;\n\nconst int N=110,M=1e6+100;\n\nint gi() {\n\tint w=0;bool q=1;char c=getchar();\n\twhile ((c<'0'||c>'9') && c!='-') c=getchar();\n\tif (c=='-') q=0,c=getchar();\n\twhile (c>='0'&&c <= '9') w=w*10+c-'0',c=getchar();\n\treturn q? w:-w;\n}\n\nconst int mod=1e9+7;\nconst int dx[4]={1,-1,0,0};\nconst int dy[4]={0,0,1,-1};\n\nint X[N],Y[N];\nstruct P{ int x,y; }p[N];\nbool can[N][N],vis[N][N];\nint pre[M],suf[M],dis[N][N];\nint main()\n{\n\tint n=gi(),m=gi(),T=gi(),i,j,lx=0,ly=0,x,y,ans=0,t;LL sum;\n\tqueue<P>q;\n\tX[++lx]=Y[++ly]=1;\n\tfor (i=0;i<T;i++) {\n\t\tX[++lx]=p[i].x=gi()+1,Y[++ly]=p[i].y=gi()+1;\n\t\tif (X[lx]!=n) X[++lx]=p[i].x+1;\n\t\tif (Y[ly]!=m) Y[++ly]=p[i].y+1;\n\t}\n\tsort(X+1,X+lx+1);lx=unique(X+1,X+lx+1)-X-1;\n\tsort(Y+1,Y+ly+1);ly=unique(Y+1,Y+ly+1)-Y-1;\n\tX[lx+1]=n+1;Y[ly+1]=m+1;\n\tfor (i=1;i<=lx;i++)\n\t\tfor (j=1;j<=ly;j++)\n\t\t\tcan[i][j]=true;\n\tfor (i=0;i<T;i++)\n\t\tcan[find(X+1,X+lx+1,p[i].x)-X][find(Y+1,Y+ly+1,p[i].y)-Y]=false;\n\n\tfor (i=0;i<T;i++)\n\t\t++pre[p[i].x];\n\tfor (i=n;i;i--) suf[i]=(suf[i+1]+m-pre[i])%mod;\n\tfor (i=1,sum=0;i<n;i++) {\n\t\tsum+=m-pre[i];\n\t\tif (!pre[i]&&!pre[i+1])\n\t\t\tans=(ans+sum%mod*suf[i+1])%mod;\n\t}\n\tfor (i=1;i<=n;i++) pre[i]=suf[i]=0;\n\tfor (i=0;i<T;i++)\n\t\t++pre[p[i].y];\n\tfor (i=m;i;i--) suf[i]=(suf[i+1]+n-pre[i])%mod;\n\tfor (i=1,sum=0;i<m;i++) {\n\t\tsum+=n-pre[i];\n\t\tif (!pre[i]&&!pre[i+1])\n\t\t\tans=(ans+sum%mod*suf[i+1])%mod;\n\t}\n\tfor (i=1;i<=lx;i++)\n\t\tfor (j=1;j<=ly;j++)\n\t\t\tif (can[i][j]) {\n\t\t\t\tfor (x=1;x<=lx;x++)\n\t\t\t\t\tfor (y=1;y<=ly;y++)\n\t\t\t\t\t\tvis[x][y]=can[x][y];\n\t\t\t\tq.push((P){i,j});vis[i][j]=false;dis[i][j]=0;\n\t\t\t\twhile (!q.empty()) {\n\t\t\t\t\tx=q.front().x;y=q.front().y;q.pop();\n\t\t\t\t\tif (x>i||(x==i&&y>j))\n\t\t\t\t\t\tans=(ans+1LL*(X[x+1]-X[x])*(Y[y+1]-Y[y])%mod*(X[i+1]-X[i])%mod*(Y[j+1]-Y[j])%mod*dis[x][y])%mod;\n\t\t\t\t\tfor (t=0;t<4;t++)\n\t\t\t\t\t\tif (vis[x+dx[t]][y+dy[t]]) {\n\t\t\t\t\t\t\tdis[x+dx[t]][y+dy[t]]=dis[x][y]+1;\n\t\t\t\t\t\t\tvis[x+dx[t]][y+dy[t]]=false;\n\t\t\t\t\t\t\tq.push((P){x+dx[t],y+dy[t]});\n\t\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t}\n\tcout<<ans<<endl;\n\treturn 0;\n}\n"
  },
  {
    "language": "C++",
    "code": "#include <cstring>\n#include <cstdio>\nusing ll = long long;\nconstexpr int MOD = 1e9 + 7;\nconstexpr int dx[] = {1, -1, 0, 0}, dy[] = {0, 0, 1, -1};\nint app_x[1000005], app_y[1000005], idx_x[1000005], idx_y[1000005];\nint px[65], py[65], dis[65][65], que[100005], sz_x[65], sz_y[65], ans;\nbool ban[65][65];\nvoid compress(int n, int m, int k, int *app, int *idx, int *sz)\n{\n\tsz[0] = 1;\n\tint u = m - app[0], d = ((ll)n * m - k - u) % MOD;\n\tfor (int i = 1; i < n; i++)\n\t{\n\t\tidx[i] = idx[i - 1];\n\t\tif (!app[i] && !app[i - 1])\n\t\t\tans = (ans + (ll)2 * u * d) % MOD;\n\t\telse\n\t\t\tidx[i]++;\n\t\tsz[idx[i]]++;\n\t\tu = (u + m - app[i]) % MOD;\n\t\td = (d + app[i] - m + MOD) % MOD;\n\t}\n}\ninline int calc(int x, int y) { return (ll)sz_x[x] * sz_y[y] % MOD; }\ninline void bfs(int n, int m, int sx, int sy)\n{\n\tmemset(dis, 0x3f, sizeof(dis));\n\tint he = 0, ta = 0;\n\tque[ta++] = sx;\n\tque[ta++] = sy;\n\tdis[sx][sy] = 0;\n\twhile (he < ta)\n\t{\n\t\tint x = que[he++], y = que[he++];\n\t\tans = (ans + (ll)calc(x, y) * calc(sx, sy) % MOD * dis[x][y]) % MOD;\n\t\tfor (int i = 0; i < 4; i++)\n\t\t{\n\t\t\tint xx = x + dx[i], yy = y + dy[i];\n\t\t\tif (xx < 0 || xx >= n || yy < 0 || yy >= m)\n\t\t\t\tcontinue;\n\t\t\tif (!ban[xx][yy] && dis[xx][yy] > 1e9)\n\t\t\t{\n\t\t\t\tdis[xx][yy] = dis[x][y] + 1;\n\t\t\t\tque[ta++] = xx;\n\t\t\t\tque[ta++] = yy;\n\t\t\t}\n\t\t}\n\t}\n}\nint main()\n{\n\t// freopen(\"J.in\", \"r\", stdin);\n\tint n, m, k;\n\tscanf(\"%d%d%d\", &n, &m, &k);\n\tfor (int i = 0; i < k; i++)\n\t{\n\t\tscanf(\"%d%d\", px + i, py + i);\n\t\tapp_x[px[i]]++;\n\t\tapp_y[py[i]]++;\n\t}\n\tcompress(n, m, k, app_x, idx_x, sz_x);\n\tcompress(m, n, k, app_y, idx_y, sz_y);\n\tfor (int i = 0; i < k; i++)\n\t\tban[idx_x[px[i]]][idx_y[py[i]]] = true;\n\tfor (int i = 0; i <= idx_x[n - 1]; i++)\n\t{\n\t\tfor (int j = 0; j <= idx_y[m - 1]; j++)\n\t\t{\n\t\t\tif (!ban[i][j])\n\t\t\t\tbfs(idx_x[n - 1] + 1, idx_y[m - 1] + 1, i, j);\n\t\t}\n\t}\n\tprintf(\"%lld\\n\", (ll)ans * (MOD + 1) / 2 % MOD);\n\treturn 0;\n}\n"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\nusing namespace std;\n\nusing ll = long long;\nusing i128 = __int128_t;\n\nint main(){\n\tios_base::sync_with_stdio(0), cin.tie(0), cout.tie(0);\n\tint A, B;\n\tcin >> A >> B;\n\tint k;\n\tcin >> k;\n\tvector<pair<int,int> > pts(k);\n\tset<int> verts_x, verts_y;\n\tverts_x.insert(0); verts_x.insert(A);\n\tverts_y.insert(0); verts_y.insert(B);\n\tfor(pair<int,int>& p : pts){\n\t\tcin >> p.first >> p.second;\n\t\tfor(int j = -1; j <= 2; j++) if(p.first + j >= 0 && p.first + j <= A) verts_x.insert(p.first + j);\n\t\tfor(int j = -1; j <= 2; j++) if(p.second + j >= 0 && p.second + j <= B) verts_y.insert(p.second + j);\n\t}\n\tvector<int> loc_x, loc_y;\n\tfor(int x : verts_x) loc_x.push_back(x);\n\tfor(int y : verts_y) loc_y.push_back(y);\n\tint num_x = (int)loc_x.size() - 1;\n\tint num_y = (int)loc_y.size() - 1;\n\tvector<vector<bool> > occ(num_x, vector<bool>(num_y, false));\n\tfor(int i = 0; i < num_x; i++){\n\t\tfor(int j = 0; j < num_y; j++){\n\t\t\tfor(pair<int,int> p : pts){\n\t\t\t\tif(loc_x[i] == p.first && loc_y[j] == p.second) occ[i][j] = true;\n\t\t\t}\n\t\t}\n\t}\n\n\ti128 ans = 0;\n\tvector<int> dx = {1, 0, -1, 0};\n\tvector<int> dy = {0, 1, 0, -1};\n\tfor(int x = 0; x < num_x; x++){\n\t\tfor(int y = 0; y < num_y; y++){\n\t\t\tif(occ[x][y]) continue;\n\t\t\tvector<vector<bool> > vis(num_x, vector<bool>(num_y, false));\n\t\t\tvector<vector<int> > dist(num_x, vector<int>(num_y, 1e9));\n\t\t\tpriority_queue<pair<int, pair<int,int> > > s;\n\t\t\tdist[x][y] = 0;\n\t\t\ts.push({-dist[x][y], {x, y}});\n\t\t\twhile(!s.empty()){\n\t\t\t\tint cx = s.top().second.first;\n\t\t\t\tint cy = s.top().second.second;\n\t\t\t\ts.pop();\n\t\t\t\tif(vis[cx][cy]) continue;\n\t\t\t\tvis[cx][cy] = true;\n\t\t\t\tfor(int d = 0; d < 4; d++){\n\t\t\t\t\tint nx = cx + dx[d];\n\t\t\t\t\tint ny = cy + dy[d];\n\t\t\t\t\tif(nx < 0 || ny < 0 || nx >= num_x || ny >= num_y) continue;\n\t\t\t\t\tif(occ[nx][ny]) continue;\n\t\t\t\t\tint new_dist = dist[cx][cy] + abs(loc_x[cx] - loc_x[nx]) + abs(loc_y[cy] - loc_y[ny]);\n\t\t\t\t\tif(new_dist < dist[nx][ny]){\n\t\t\t\t\t\tdist[nx][ny] = new_dist;\n\t\t\t\t\t\ts.push({-dist[nx][ny], {nx, ny}});\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t}\n\t\t\tfor(int nx = 0; nx < num_x; nx++){\n\t\t\t\tfor(int ny = 0; ny < num_y; ny++){\n\t\t\t\t\tif(occ[nx][ny]) continue;\n\t\t\t\t\ti128 dx0 = loc_x[x + 1] - loc_x[x];\n\t\t\t\t\ti128 dy0 = loc_y[y + 1] - loc_y[y];\n\t\t\t\t\ti128 dx1 = loc_x[nx + 1] - loc_x[nx];\n\t\t\t\t\ti128 dy1 = loc_y[ny + 1] - loc_y[ny];\n\t\t\t\t\tif((x == nx && dx0 > 1) || (y == ny && dy0 > 1)){\n\t\t\t\t\t\t// can travel by manhattan distance\n\t\t\t\t\t\ti128 xdist = (x == nx) ? ((dx0 * dx0 * dx0 - dx0) / 3) : \n\t\t\t\t\t\t\tdx0 * dx1 * abs(loc_x[nx + 1] + loc_x[nx] - loc_x[x + 1] - loc_x[x]) / 2;\n\t\t\t\t\t\txdist *= dy0 * dy1;\n\t\t\t\t\t\ti128 ydist = (y == ny) ? ((dy0 * dy0 * dy0 - dy0) / 3) : \n\t\t\t\t\t\t\tdy0 * dy1 * abs(loc_y[ny + 1] + loc_y[ny] - loc_y[y + 1] - loc_y[y]) / 2;\n\t\t\t\t\t\tydist *= dx0 * dx1;\n\t\t\t\t\t\tans += xdist + ydist;\n\t\t\t\t\t} else {\n\t\t\t\t\t\ti128 twice_avg = 2 * i128(dist[nx][ny])\n\t\t\t\t\t\t\t+ abs(loc_x[nx + 1] + loc_x[nx] - loc_x[x + 1] - loc_x[x]) - 2 * abs(loc_x[nx] - loc_x[x])\n\t\t\t\t\t\t\t+ abs(loc_y[ny + 1] + loc_y[ny] - loc_y[y + 1] - loc_y[y]) - 2 * abs(loc_y[ny] - loc_y[y]);\n\t\t\t\t\t\tans += twice_avg * dx0 * dy0 * dx1 * dy1 / 2;\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t}\n\tll ans_mod = (ans / 2) % (int(1e9) + 7);\n\tcout << ans_mod << '\\n';\n}"
  },
  {
    "language": "C++",
    "code": "#include<iostream>\n#include<cstdio>\n#include<cstdlib>\n#include<cmath>\n#include<cstring>\n#include<algorithm>\n#define rep(i,a,b) for(int i=a;i<=b;i++)\n#define dep(i,a,b) for(int i=a;i>=b;i--)\n#define ll long long\n#define mem(x,num) memset(x,num,sizeof x)\n#define reg(x) for(int i=last[x];i;i=e[i].next)\nusing namespace std;\ninline ll read(){\n\tll f=1,x=0;char ch=getchar();\n\twhile(ch<'0'||ch>'9'){if(ch=='-')f=-1;ch=getchar();}\n\twhile(ch>='0'&&ch<='9'){x=x*10+ch-'0';ch=getchar();}\n\treturn x*f;\n}\n//**********head by yjjr**********\n#define pb push_back\n#define inf 1e9\ntemplate<class T>inline void vnique(vector<T> &r){sort(r.begin(),r.end());auto t=unique(r.begin(),r.end());r.erase(t,r.end());}\nconst int maxn=66,maxm=1e6+6,dx[4]={-1,1,0,0},dy[4]={0,0,-1,1},mod=1e9+7;\nstruct node{int x,y;}a[maxn<<1],que[maxn<<2];\nint n,m,K,ans,lx,ly,cnt[maxn][maxn],s1[maxm],s2[maxm],dis[maxn][maxn],head,tail;\nbool fb[maxn][maxn],mark1[maxm],mark2[maxm];\nvector<int>px,py;\nvoid bfs(int x,int y){\n\trep(i,0,lx)rep(j,0,ly)dis[i][j]=inf;\n\tdis[x][y]=0;que[head=tail=1]=(node){x,y};\n\twhile(head<=tail){\n\t\tint nx=que[head].x,ny=que[head++].y;\n\t\trep(i,0,3){\n\t\t\tint nex=nx+dx[i],ney=ny+dy[i];\n\t\t\tif(nex>lx||nex<0||ney>ly||ney<0||dis[nex][ney]<=dis[nx][ny]+1||fb[nex][ney])continue;\n\t\t\tdis[nex][ney]=dis[nx][ny]+1;que[++tail]=(node){nex,ney};\n\t\t}\n\t}\n}\nint main()\n{\n\tn=read(),m=read(),K=read();\n\tpx.pb(1);px.pb(n+1);py.pb(1);py.pb(m+1);\n\trep(i,1,n)s1[i]=m;\n\trep(i,1,m)s2[i]=n;\n\trep(i,1,K){\n\t\ta[i].x=read()+1,a[i].y=read()+1;\n\t\tpx.pb(a[i].x),px.pb(a[i].x+1);\n\t\tpy.pb(a[i].y),py.pb(a[i].y+1);\n\t\ts1[a[i].x]--,mark1[a[i].x]=1;\n\t\ts2[a[i].y]--,mark2[a[i].y]=1;\n\t}\n\trep(i,1,n)s1[i]=(s1[i]+s1[i-1])%mod;\n\trep(i,1,m)s2[i]=(s2[i]+s2[i-1])%mod;\n\trep(i,1,n-1)if(!mark1[i]&&!mark1[i+1])ans=(ans+1ll*2*s1[i]*(s1[n]-s1[i]))%mod;\n\trep(i,1,m-1)if(!mark2[i]&&!mark2[i+1])ans=(ans+1ll*2*s2[i]*(s2[m]-s2[i]))%mod;\n\tvnique(px);vnique(py);lx=px.size()-2;ly=py.size()-2;\n\trep(i,1,K)\n\t\tfb[lower_bound(px.begin(),px.end(),a[i].x)-px.begin()][lower_bound(py.begin(),py.end(),a[i].y)-py.begin()]=1;\n\trep(i,0,lx)rep(j,0,ly)cnt[i][j]=1ll*(px[i+1]-px[i])*(py[j+1]-py[j])%mod;\n\trep(i,0,lx)rep(j,0,ly)\n\t\tif(!fb[i][j]){\n\t\t\tbfs(i,j);\n\t\t\trep(k,0,lx)rep(p,0,ly)\n\t\t\t\tif(!fb[k][p])ans=(ans+1ll*cnt[i][j]*dis[k][p]%mod*cnt[k][p])%mod; \n   \t\t}\n\tans=(ans+mod)%mod;ans=1ll*ans*(mod/2+1)%mod;\n\tcout<<ans<<endl;\n\treturn 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include <algorithm>\n#include <climits>\n#include <cmath>\n#include <cstdio>\n#include <cstdlib>\n#include <ctime>\n#include <iostream>\n#include <sstream>\n#include <functional>\n#include <map>\n#include <set>\n#include <unordered_map>\n#include <unordered_set>\n#include <bitset>\n#include <string>\n#include <cstring>\n#include <vector>\n#include <queue>\n#include <stack>\n#include <deque>\n#include <list>\n#include <numeric>\nusing namespace std;\ntypedef long long ll;\ntypedef unsigned long long ull;\ntypedef long double ld;\ntypedef pair<ll,ll> P;\ntypedef pair<P,ll> PPI;\ntypedef pair<ll,P> PIP;\ntypedef vector<ll> vl;\ntypedef vector<vl> vvl;\ntypedef vector<P> vp;\n#define PQ(T) priority_queue<T,vector<T>,greater<T>>\n#define PQ2(T) priority_queue<T>\nconst double PI = 3.14159265358979323846;\nconst double EPS = 1e-12;\nconst ll INF = 1LL<<59;\nconst ll mod = 1e9+7;\n#define REP(i,a,b) for(ll (i)=a;(i)<(ll)(b);++(i))\n#define rep(i,n) REP(i,0,n)\n#define rep1(i,n) REP(i,1,n+1)\n#define repd(i,n,d) for(ll (i)=0;(i)<(ll)(n);(i)+=(d))\n#define all(v) (v).begin(), (v).end()\n#define pb(x) push_back(x)\n#define mp(x,y) make_pair((x),(y))\n#define mset(m,v) memset((m),(v),sizeof(m))\n#define chmin(x,y) ((x)=min((x),(y)))\n#define chmax(x,y) ((x)=max((x),(y)))\n#define fst first\n#define snd second\n#define UNIQUE(x) (x).erase(unique(all(x)),(x).end())\n#define DEBUG(x) cerr<<\"line (\"<<__LINE__<<\")  \"<<#x<<\": \"<<x<<endl;\ntemplate<class T> ostream &operator<<(ostream &os, const vector<T> &v){int n=v.size();rep(i,n)os<<v[i]<<(i==n-1?\"\":\" \");return os;}\n\n#define N 90\n#define M 65*65*4\nint h, w, n, h2, w2;\nint x[N], y[N], xy[N][N];\nint dx[] = {1, 0, -1, 0}, dy[] = {0, 1, 0, -1};\nvector<int> x2, y2;\nunordered_map<int, int> xd, yd;\nll d[M];\n\nll pow_mod(ll a, ll r, ll m = mod){\n\tll x = 1;\n\twhile(r){\n\t\tif(r&1) (x*=a)%=m;\n\t\t(a*=a)%=m;\n\t\tr>>=1;\n\t}\n\treturn x;\n}\n\nll inv2 = pow_mod(2, mod-2, mod);\nll inv3 = pow_mod(3, mod-2, mod);\n\nll f(ll a, ll b, ll c){\n\treturn (a*w2+b)*4+c;\n}\n\nvoid comp(int *a, vector<int> &b, unordered_map<int, int> &c, int d, int &d2){\n\tb.clear(); c.clear();\n\trep(i, n){ b.pb(a[i]); b.pb(a[i]+1);}\n\tb.pb(0); b.pb(d);\n\tsort(all(b));\n\tUNIQUE(b);\n\td2 = b.size();\n\trep(i, d2) c[b[i]] = i;\n\trep(i, n) a[i] = c[a[i]];\n}\n\nll solve(int a, int b, int c, bool xf, bool yf){\n\tfill(d, d+M, INF);\n\trep(i, n) rep(j, 4) d[f(x[i], y[i], j)] = -1;\n\tll abc = f(a, b, c);\n\td[abc] = 0;\n\tqueue<P> q;\n\tq.push(P(0, abc));\n\tll res = 0;\n\twhile(!q.empty()){\n\t\tP p = q.front(); q.pop();\n\t\tll l = p.fst, u = (p.snd>>2)/w2, v = (p.snd>>2)%w2, k = p.snd&3;\n\t\tif(d[p.snd]<l) continue;\n\t\t//cerr<<\"dijk \"<<u<<\" \"<<v<<\" \"<<k<<\" \"<<l<<endl;\n\n\t\trep(i, 4){\n\t\t\tint u2 = u+dx[i], v2 = v+dy[i], k2;\n\t\t\tll l2 = l+1;\n\t\t\tif(u2<0||u2>=h2-1||v2<0||v2>=w2-1) continue;\n\t\t\tif(i%2==0){\n\t\t\t\tif(i/2==(1&(k>>1))) l2 += x2[u+1]-x2[u]-1;\n\t\t\t\tk2 = i/2*2+(k%2);\n\t\t\t}\n\t\t\tif(i%2==1){\n\t\t\t\tif(i/2==(1&k)) l2 += y2[v+1]-y2[v]-1;\n\t\t\t\tk2 = i/2+(k/2*2);\n\t\t\t}\n\t\t\tll p2 = f(u2, v2, k2);\n\t\t\tif(d[p2]>=0 && l2<d[p2]){\n\t\t\t\td[p2] = l2;\n\t\t\t\tq.push(P(d[p2], p2));\n\t\t\t}\n\t\t}\n\t\trep1(i, 3){\n\t\t\tll k2 = k^i;\n\t\t\tll l2 = l;\n\t\t\tif(i&2) l2 += x2[u+1]-x2[u]-1;\n\t\t\tif(i&1) l2 += y2[v+1]-y2[v]-1;\n\t\t\tll p2 = f(u, v, k2);\n\t\t\tif(d[p2]>=0 && l2<d[p2]){\n\t\t\t\td[p2] = l2;\n\t\t\t\t//q.push(P(d[p2], p2));\n\t\t\t}\n\t\t}\n\t}\n\trep(i, h2-1) rep(j, w2-1){\n\t\tif(xy[i][j]) continue;\n\t\tif(xf && i==a) continue;\n\t\tif(yf && j==b) continue;\n\t\t(res+=(d[f(i, j, 0)]+d[f(i, j, 3)])%mod*(x2[i+1]-x2[i])%mod*(y2[j+1]-y2[j])%mod*inv2)%=mod;\n\t}\n\treturn res;\n\trep(i, h2-1){\n\t\trep(j, w2-1) cerr<<d[f(i, j, 0)]<<\" \";\n\t\tcerr<<endl;\n\t}\n\treturn res;\n}\n\nll f5(ll h){\n\tll r1 = ((3*h-2)*(h-1)+2*(h-1)*(h-1)%mod*(h-1))%mod*(h-1)%mod;\n\tll r2 = ((4*h-4)*(h-1)+2*(h-2)*(h-1)%mod*(h-1))%mod*(h-1)%mod*(h-1)%mod*inv2%mod;\n\treturn (r1+r2)%mod;\n}\n\nint main(){\n\tcin>>h>>w>>n;\n\trep(i, n) cin>>x[i]>>y[i];\n\tcomp(x, x2, xd, h, h2);\n\tcomp(y, y2, yd, w, w2);\n\trep(i, n) xy[x[i]][y[i]] = -1;\n\tll res = 0;\n\trep(i, h2-1) rep(j, w2-1){\n\t\tif(xy[i][j]) continue;\n\t\tll xx = x2[i+1]-x2[i], yy = y2[j+1]-y2[j];\n\t\tbool xf = xx>1, yf = yy>1;\n\t\tll r0 = solve(i, j, 0, xf, yf);\n\t\tll r3 = (!xf&&!yf)?r0:solve(i, j, 3, xf, yf);\n\t\t//cerr<<\"xx yy \"<<xx<<\" \"<<yy<<endl;\n\t\tll res2 = res;\n\t\t(res+=(r0+r3)*(xx)%mod*(yy)%mod*inv2)%=mod;\n\t\t//cerr<<\"diff1 \"<<(res-res2+mod)%mod<<endl;\n\t\tif(!xf&&!yf) continue;\n\t\tll xx1 = x2[i], xx2 = h-x2[i+1], yy1 = y2[j], yy2 = w-y2[j+1];\n\t\tif(xf&&yf){\n\t\t\tll rx = (pow_mod(xx, 3)-xx)*w%mod*yy%mod*inv3%mod + (yy1*(yy1+1)+yy2*(yy2+1))%mod*xx%mod*xx%mod*yy%mod*inv2%mod + xx*xx%mod*yy%mod*(w-yy)%mod*(yy-1)%mod*inv2%mod;\n\t\t\tll ry = (pow_mod(yy, 3)-yy)*h%mod*xx%mod*inv3%mod + (xx1*(xx1+1)+xx2*(xx2+1))%mod*yy%mod*yy%mod*xx%mod*inv2%mod + yy*yy%mod*xx%mod*(h-xx)%mod*(xx-1)%mod*inv2%mod;\n\t\t\t(res+=rx+ry)%=mod;\n\t\t\t//cerr<<\"rx ry \"<<rx<<\" \"<<ry<<endl;\n\t\t} else if(xf){\n\t\t\t(res+=(pow_mod(xx, 3)-xx)*w%mod*inv3%mod + (yy1*(yy1+1)+yy2*(yy2+1))%mod*xx%mod*xx%mod*inv2%mod)%=mod;\n\t\t} else {\n\t\t\t(res+=(pow_mod(yy, 3)-yy)*h%mod*inv3%mod + (xx1*(xx1+1)+xx2*(xx2+1))%mod*yy%mod*yy%mod*inv2%mod)%=mod;\n\t\t}\n\t\t//cerr<<\"diff \"<<(res-res2+mod)%mod<<endl;\n\t}\n\tcout<<(res*inv2%mod+mod)%mod<<endl;\n\t//cerr<<res<<endl;\n\t//cerr<<f5(h)*inv2%mod<<endl;\n\treturn 0;\n}\n"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\n\nusing namespace std;\n\n#ifdef DEBUG_MODE\n\t#define DBG(n) n;\n#else\n\t#define DBG(n) ;\n#endif\n#define REP(i,n) for(ll (i) = (0);(i) < (n);++i)\n#define PB push_back\n#define MP make_pair\n#define FI first\n#define SE second\n#define SHOW1d(v,n) {for(int W = 0;W < (n);W++)cerr << v[W] << ' ';cerr << endl << endl;}\n#define SHOW2d(v,i,j) {for(int aaa = 0;aaa < i;aaa++){for(int bbb = 0;bbb < j;bbb++)cerr << v[aaa][bbb] << ' ';cerr << endl;}cerr << endl;}\n#define ALL(v) v.begin(),v.end()\n#define Decimal fixed<<setprecision(20)\n#define INF 1000000000\n#define LLINF 1000000000000000000\n#define MOD 1000000007\n\ntypedef long long ll;\ntypedef pair<ll,ll> P;\n\nlong long mod_div(long long a,long long b){\n\tif(a % b == 0)return a/b;\n\tlong long tmp = MOD - 2,c = b,ret = 1;\n\twhile(tmp > 0){\n\t\tif(tmp & 1){\n\t\t\tret *= c;ret %= MOD;\n\t\t}\n\t\tc *= c;c %= MOD;tmp >>= 1;\n\t}\n\treturn a*ret%MOD;\n}\n\nint n,h,w;\nll ans,distSum;\nvector<pair<ll,ll>> v;\nvector<ll> xx;\nvector<ll> yy;\n\nbool mp[111][111];\nbool used[111][111];\nll dx[] = {1,0,-1,0};\nll dy[] = {0,1,0,-1};\nll couX[111];\nll couY[111];\n\nvoid seicaAdd(ll &a,ll &b){\n\ta += b;\n\tif(a >= MOD)a -= MOD;\n}\n\nvoid makeTable(){\n\tyy.PB(0);\n\tyy.PB(h);\n\txx.PB(0);\n\txx.PB(w);\n\t\n\tREP(i,n){\n\t\t//xx.PB(max(0LL,v[i].FI-1));\n\t\txx.PB(max(0LL,v[i].FI));\n\t\txx.PB(max(0LL,v[i].FI+1));\n\t\t//yy.PB(max(0LL,v[i].SE-1));\n\t\tyy.PB(max(0LL,v[i].SE));\n\t\tyy.PB(max(0LL,v[i].SE+1));\n\t}\n\t\n\tsort(ALL(xx));\n\tsort(ALL(yy));\n\t\n\txx.erase(unique(ALL(xx)),xx.end());\n\tyy.erase(unique(ALL(yy)),yy.end());\n\t\n\tREP(i,n){\n\t\tint x = lower_bound(ALL(xx),v[i].FI) - xx.begin();\n\t\tint y = lower_bound(ALL(yy),v[i].SE) - yy.begin();\n\t\tmp[y][x] = true;\n\t\tcouX[x]++;\n\t\tcouY[y]++;\n\t}\t\n\t\t\n\tll blackSum = 0;\n\tll pointer = 0;\n\tREP(i,w){\n\t\tif(i == xx[pointer]){\n\t\t\tblackSum += couX[pointer];\n\t\t\tpointer++;\n\t\t}\n\t\telse{\n\t\t\tll A = ((h * i % MOD) - blackSum + MOD) % MOD;\n\t\t\tll B = ((h * (w - i) % MOD) - (n - blackSum) + MOD) % MOD;\n\t\t\tll tmp = A * B % MOD;\n\t\t\tseicaAdd(ans,tmp);\n\t\t}\n\t}\n\t\n\tblackSum = 0;\n\tpointer = 0;\n\tREP(i,h){\n\t\tif(i == yy[pointer]){\n\t\t\tblackSum += couY[pointer];\n\t\t\tpointer++;\n\t\t}\n\t\telse{\n\t\t\tll A = ((w * i % MOD) - blackSum + MOD) % MOD;\n\t\t\tll B = ((w * (h - i\t) % MOD) - (n - blackSum) + MOD) % MOD;\n\t\t\tll tmp = A * B % MOD;\n\t\t\tseicaAdd(ans,tmp);\n\t\t}\n\t}\n}\n\nint main(){\n\t\n\tcin >> h >> w >> n;\n\tREP(i,n){\n\t\tint a,b;cin >> a >> b;\n\t\tv.PB(MP(b,a));\n\t}\n\t\n\tmakeTable();\n\t\n\tREP(i,yy.size()-1){\n\t\tREP(j,xx.size()-1){\n\t\t\tif(!mp[i][j]){\n\t\t\t\tREP(ii,111)REP(jj,111)used[ii][jj] = false;\n\t\t\t\tll nowMul = ((yy[i+1] - yy[i]) * (xx[j+1] - xx[j])) % MOD;\n\t\t\t\tqueue<pair<pair<ll,ll>,ll>> que;\n\t\t\t\tque.push(MP(MP(i,j),0));\n\t\t\t\tused[i][j] = true;\n\t\t\t\twhile(!que.empty()){\n\t\t\t\t\tauto now = que.front();que.pop();\n\t\t\t\t\tnow.SE++;\n\t\t\t\t\tREP(k,4){\n\t\t\t\t\t\tll y = now.FI.FI + dy[k];\n\t\t\t\t\t\tll x = now.FI.SE + dx[k];\n\t\t\t\t\t\tif(x < 0 || y < 0 || x >= xx.size() - 1 || y >= yy.size() - 1)continue;\n\t\t\t\t\t\tif(mp[y][x] || used[y][x])continue;\n\t\t\t\t\t\tll thisMul = (yy[y+1] - yy[y]) * (xx[x+1] - xx[x]) % MOD;\n\t\t\t\t\t\tll tmp = (((nowMul * thisMul) % MOD) * now.SE) % MOD;\n\t\t\t\t\t\tseicaAdd(distSum,tmp);\t\n\t\t\t\t\t\tque.push(MP(MP(y,x),now.SE));\n\t\t\t\t\t\tused[y][x] = true;\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t}\n\tdistSum = mod_div(distSum,2);\n\tcout << (ans + distSum) % MOD << endl;\n\t\n\treturn 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\n#define mod 1000000007\nusing namespace std;\nbool vh[1000005],vw[1000005];\nint bh[1000005],bw[1000005];\nint nh[1000005],nw[1000005];\nint h,w,n,x[31],y[31],c1=0,c2=0;\nint kh[105],kw[105],wgt[65][65];\nint dis[65][65],que[10005][2],l=1,r=0;\nbool ban[65][65];\ninline int mul(int a,int b)\n{return 1ll*a*b%mod;}\ninline int sub(int a,int b)\n{return (a-b<0?a-b+mod:a-b);}\ninline bool ok(int a,int b)\n{if (a<=0||a>c1||b<=0||b>c2||ban[a][b]) return 0;\nreturn 1;\n}\nint main (){\n\tint i,j,k,l,ans=0;\n\tscanf (\"%d%d%d\",&h,&w,&n);\n\tfor (i=1;i<=n;i++)\n\t{scanf (\"%d%d\",&x[i],&y[i]);\n\tx[i]++;y[i]++;\n\tnh[x[i]]++;nw[y[i]]++;\n\tvh[x[i]]=vw[y[i]]=1;\n\t}\n\tbh[1]=++c1;kh[1]++;\n\tint lo=0,tot=mul(h,w)-n;\n\tif (tot<0) tot+=mod;\n\tfor (i=2;i<=h;i++)\n\t{lo+=(w-nh[i-1]);\n\tif (lo>=mod) lo-=mod;\n\tif ((!vh[i-1])&&(!vh[i]))\n\t{ans+=mul(lo,sub(tot,lo));\n\tif (ans>=mod) ans-=mod;\n\tbh[i]=bh[i-1];kh[c1]++;\n\t}\n\telse {bh[i]=++c1;kh[c1]=1;}\n\t}\n\tbw[1]=++c2;kw[1]++;\n\tlo=0;tot=mul(h,w)-n;\n\tif (tot<0) tot+=mod;\n\tfor (i=2;i<=w;i++)\n\t{lo+=(h-nw[i-1]);\n\tif (lo>=mod) lo-=mod;\n\tif ((!vw[i-1])&&(!vw[i]))\n\t{ans+=mul(lo,sub(tot,lo));\n\tif (ans>=mod) ans-=mod;\n\tbw[i]=bw[i-1];kw[c2]++;\n\t}\n\telse {bw[i]=++c2;kw[c2]=1;}\n\t}\n\tfor (i=1;i<=c1;i++)\n\t{for (j=1;j<=c2;j++)\n\t{wgt[i][j]=mul(kh[i],kw[j]);}\n\t}\n\tfor (i=1;i<=n;i++)\n\t{ban[bh[x[i]]][bw[y[i]]]=1;}\n\tans*=2;\n\tif (ans>=mod) ans-=mod;\n\tfor (i=1;i<=c1;i++)\n\t{for (j=1;j<=c2;j++)\n\t{if (ban[i][j]) continue;\n\tl=1;r=0;que[++r][0]=i;que[r][1]=j;\n\tmemset (dis,0x7f,sizeof(dis));\n\tdis[i][j]=0;\n\twhile (l<=r)\n\t{int a=que[l][0],b=que[l][1];l++;\n\tif (ok(a-1,b)&&dis[a-1][b]>dis[a][b]+1)\n\t{dis[a-1][b]=dis[a][b]+1;\n\tque[++r][0]=a-1;que[r][1]=b;\n\t}\n\tif (ok(a+1,b)&&dis[a+1][b]>dis[a][b]+1)\n\t{dis[a+1][b]=dis[a][b]+1;\n\tque[++r][0]=a+1;que[r][1]=b;\n\t}\n\tif (ok(a-1,b)&&dis[a-1][b]>dis[a][b]+1)\n\t{dis[a-1][b]=dis[a][b]+1;\n\tque[++r][0]=a-1;que[r][1]=b;\n\t}\n\tif (ok(a,b-1)&&dis[a][b-1]>dis[a][b]+1)\n\t{dis[a][b-1]=dis[a][b]+1;\n\tque[++r][0]=a;que[r][1]=b-1;\n\t}\n\tif (ok(a,b+1)&&dis[a][b+1]>dis[a][b]+1)\n\t{dis[a][b+1]=dis[a][b]+1;\n\tque[++r][0]=a;que[r][1]=b+1;\n\t}\n\t}\n\tint tp=0;\n\tfor (k=1;k<=c1;k++)\n\t{for (l=1;l<=c2;l++)\n\t{if (ban[k][l]) continue;\n\ttp+=mul(dis[k][l],wgt[k][l]);\n\tif (tp>=mod) tp-=mod;\n\t}\n\t}\n\ttp=mul(tp,wgt[i][j]);\n\tans+=tp;\n\tif (ans>=mod) ans-=mod;\n\t}\n\t}\n\tif (ans&1) ans+=mod;\n\tprintf (\"%d\\n\",ans>>1);\n\treturn 0;\n}\n\n\t\n\t"
  },
  {
    "language": "C++",
    "code": "#include <algorithm>  \n#include <iostream>  \n#include <sstream>  \n#include <string>  \n#include <cstring>\n#include <vector>  \n#include <queue>  \n#include <set>  \n#include <map>  \n#include <cstdio>  \n#include <cstdlib>  \n#include <cctype>  \n#include <cmath>  \n#include <list>  \n#include <cassert>\n#include <ctime>\n#include <climits>\nusing namespace std;  \n\n#define PB push_back  \n#define MP make_pair  \n#define SZ(v) ((int)(v).size())  \n#define FOR(i,a,b) for(int i=(a);i<(b);++i)  \n#define REP(i,n) FOR(i,0,n)  \n#define FORE(i,a,b) for(int i=(a);i<=(b);++i)  \n#define REPE(i,n) FORE(i,0,n)  \n#define FORSZ(i,a,v) FOR(i,a,SZ(v))  \n#define REPSZ(i,v) REP(i,SZ(v))  \ntypedef long long ll;\ntypedef unsigned long long ull;\nll gcd(ll a,ll b) { return b==0?a:gcd(b,a%b); }\n\nconst int MAXN=30;\nconst int MAXDIM=2*MAXN+1;\nconst int MOD=1000000007;\nconst int INV2=(MOD+1)/2;\nconst int DX[]={-1,0,+1,0},DY[]={0,+1,0,-1};\n\nint h,w,n;\nint px[MAXN],py[MAXN];\n\nint xx[2*MAXN+2],yy[2*MAXN+2],nxx,nyy;\n\nbool blocked[MAXDIM][MAXDIM];\nint cnt[MAXDIM][MAXDIM];\n\nint dst[MAXDIM][MAXDIM];\nint qx[MAXDIM*MAXDIM],qy[MAXDIM*MAXDIM],qhead,qtail;\nvoid upd(int x,int y,int d) { if(dst[x][y]!=INT_MAX) return; dst[x][y]=d; qx[qhead]=x,qy[qhead]=y,++qhead; }\n\n\nvoid run() {\n\tscanf(\"%d%d%d\",&h,&w,&n);\n\tREP(i,n) scanf(\"%d%d\",&px[i],&py[i]);\n\n\tnxx=0; xx[nxx++]=0,xx[nxx++]=h; REP(i,n) xx[nxx++]=px[i],xx[nxx++]=px[i]+1; sort(xx,xx+nxx); nxx=unique(xx,xx+nxx)-xx; REP(i,n) px[i]=lower_bound(xx,xx+nxx,px[i])-xx;\n\tnyy=0; yy[nyy++]=0,yy[nyy++]=w; REP(i,n) yy[nyy++]=py[i],yy[nyy++]=py[i]+1; sort(yy,yy+nyy); nyy=unique(yy,yy+nyy)-yy; REP(i,n) py[i]=lower_bound(yy,yy+nyy,py[i])-yy;\n\n\tREP(x,nxx-1) REP(y,nyy-1) blocked[x][y]=false,cnt[x][y]=(ll)(xx[x+1]-xx[x])*(yy[y+1]-yy[y])%MOD;\n\tREP(i,n) blocked[px[i]][py[i]]=true;\n\t//REP(x,nxx-1) { REP(y,nyy-1) printf(\"%c\",blocked[x][y]?'#':'.'); puts(\"\"); }\n\n\tint ret=0;\n\tREP(sx,nxx-1) REP(sy,nyy-1) if(!blocked[sx][sy]) {\n\t\tREP(x,nxx-1) REP(y,nyy-1) dst[x][y]=INT_MAX; qhead=qtail=0;\n\t\tupd(sx,sy,0);\n\t\twhile(qtail<qhead) {\n\t\t\tint x=qx[qtail],y=qy[qtail]; ++qtail;\n\t\t\tREP(k,4) {\n\t\t\t\tint nx=x+DX[k],ny=y+DY[k]; if(nx<0||nx>=h||ny<0||ny>=w||blocked[nx][ny]) continue;\n\t\t\t\tupd(nx,ny,dst[x][y]+1);\n\t\t\t}\n\t\t}\n\t\tREP(x,nxx-1) REP(y,nyy-1) if(!blocked[x][y]) {\n\t\t\tret=(ret+(ll)cnt[sx][sy]*cnt[x][y]%MOD*dst[x][y])%MOD;\n\t\t}\n\t}\n\tret=(ll)ret*INV2%MOD;\n\n\tREP(x,nxx-1) {\n\t\tint len=xx[x+1]-xx[x]; if(len==1) continue;\n\t\tint a=(ll)(len-1)*len*(len+1)/6%MOD;\n\t\tint b=(ll)h*h%MOD;\n\t\tint c=(ll)len*(len-1)/2%MOD;\n\t\tint lft=0,rgt=0; REP(cx,nxx-1) REP(cy,nyy-1) if(!blocked[cx][cy]) if(cx<x) lft=(lft+cnt[cx][cy])%MOD; else if(cx>x) rgt=(rgt+cnt[cx][cy])%MOD;\n\t\t//printf(\"cnt=%d a=%d b=%d c=%d lft=%d rgt=%d\\n\",len,a,b,c,lft,rgt);\n\t\tret=(ret+(ll)a*b)%MOD;\n\t\tret=(ret+(ll)lft*rgt%MOD*(len-1))%MOD;\n\t\tret=(ret+(ll)(lft+rgt)*c%MOD*h)%MOD;\n\t}\n\tREP(y,nyy-1) {\n\t\tint len=yy[y+1]-yy[y]; if(len==1) continue;\n\t\tint a=(ll)(len-1)*len*(len+1)/6%MOD;\n\t\tint b=(ll)h*h%MOD;\n\t\tint c=(ll)len*(len-1)/2%MOD;\n\t\tint lft=0,rgt=0; REP(cx,nxx-1) REP(cy,nyy-1) if(!blocked[cx][cy]) if(cy<y) lft=(lft+cnt[cx][cy])%MOD; else if(cy>y) rgt=(rgt+cnt[cx][cy])%MOD;\n\t\t//printf(\"cnt=%d a=%d b=%d c=%d lft=%d rgt=%d\\n\",len,a,b,c,lft,rgt);\n\t\tret=(ret+(ll)a*b)%MOD;\n\t\tret=(ret+(ll)lft*rgt%MOD*(len-1))%MOD;\n\t\tret=(ret+(ll)(lft+rgt)*c%MOD*h)%MOD;\n\t}\n\n\tprintf(\"%d\\n\",ret);\n}\n\nint main() {\n\trun();\n\treturn 0;\n}\n"
  },
  {
    "language": "C++",
    "code": "#include <cstdio>\n#include <cstring>\n#include <cstdlib>\n#include <cmath>\n#include <ctime>\n#include <cassert>\n#include <string>\n#include <algorithm>\n#include <vector>\n#include <queue>\n#include <stack>\n#include <functional>\n#include <iostream>\n#include <map>\n#include <set>\n#include <cassert>\nusing namespace std;\ntypedef long long ll;\ntypedef pair<int,int> P;\ntypedef pair<int,P> P1;\ntypedef pair<P,P> P2;\n#define pu push\n#define pb push_back\n#define mp make_pair\n#define eps 1e-7\n#define INF 1000000000\n#define mod 1000000007\n#define fi first\n#define sc second\n#define rep(i,x) for(int i=0;i<x;i++)\n#define repn(i,x) for(int i=1;i<=x;i++)\n#define SORT(x) sort(x.begin(),x.end())\n#define ERASE(x) x.erase(unique(x.begin(),x.end()),x.end())\n#define POSL(x,v) (lower_bound(x.begin(),x.end(),v)-x.begin())\n#define POSU(x,v) (upper_bound(x.begin(),x.end(),v)-x.begin())\nvector<int>zx,zy;\nint h,w,n,a[35],b[35];\nvector<P1>za,zb;\nvector<int>cx,cy;\nint revx[1000005],revy[1000005];\nbool bad[105][105];\nint main(){\n\tcin>>h>>w>>n;\n\trep(i,n){\n\t\tcin>>a[i]>>b[i]; a[i]++; b[i]++;\n\t\tzx.pb(a[i]);\n\t\tzy.pb(b[i]);\n\t}\n\tSORT(zx); ERASE(zx);\n\tSORT(zy); ERASE(zy);\n\tint cur = 1;\n\trep(i,zx.size()){\n\t\tif(cur != zx[i]){\n\t\t\tza.pb(mp(0,mp(cur,zx[i]-1)));\n\t\t}\n\t\tza.pb(mp(1,mp(zx[i],zx[i])));\n\t\tcur = zx[i]+1;\n\t}\n\tif(cur <= h){\n\t\tza.pb(mp(0,mp(cur,h)));\n\t}\n\t\n\tcur = 1;\n\trep(i,zy.size()){\n\t\tif(cur != zy[i]){\n\t\t\tzb.pb(mp(0,mp(cur,zy[i]-1)));\n\t\t}\n\t\tzb.pb(mp(1,mp(zy[i],zy[i])));\n\t\tcur = zy[i]+1;\n\t}\n\tif(cur <= w){\n\t\tzb.pb(mp(0,mp(cur,w)));\n\t}\n\trep(i,za.size()){\n\t\trep(j,zb.size()){\n\t\t\tcx.pb(za[i].sc.fi); cx.pb(za[i].sc.sc);\n\t\t\tcy.pb(zb[j].sc.fi); cy.pb(zb[j].sc.sc);\n\t\t}\n\t}\n\tSORT(cx); ERASE(cx);\n\tSORT(cy); ERASE(cy);\n\trep(i,cx.size()) revx[cx[i]] = i+1;\n\trep(i,cy.size()) revy[cy[i]] = i+1;\n\trep(i,cx.size()){\n        rep(j,cy.size()){\n            rep(k,n) if(a[k]==cx[i]&&b[k]==cy[j]) bad[i+1][j+1] = 1;\n        }\n\t}\n\tll add = 0,add2 = 0;\n\trep(i,za.size()){\n\t\trep(j,zb.size()){\n\t\t\tint x = za[i].sc.fi,y = zb[j].sc.fi;\n\t\t\tx = revx[x]; y = revy[y];\n\t\t\tif(bad[x][y]) continue;\n\t\t\tif(!za[i].fi && !zb[j].fi) continue;\n\t\t\tll cnt = 1LL*(za[i].sc.sc-za[i].sc.fi+1)*(zb[j].sc.sc-zb[j].sc.fi+1);\n\t\t\tcnt %= mod;\n\t\t\tint dist[95][95];\n\t\t\trep(x,95) rep(y,95) dist[x][y] = INF;\n\t\t\tdist[x][y] = 0;\n\t\t\tpriority_queue<P1>que;\n\t\t\tque.push(mp(0,mp(x,y)));\n\t\t\twhile(!que.empty()){\n\t\t\t\tP1 p = que.top(); que.pop();\n\t\t\t\tif(dist[p.sc.fi][p.sc.sc] != p.fi) continue;\n\t\t\t\tint X = p.sc.fi,Y = p.sc.sc;\n\t\t\t\tint dx[4]={0,1,0,-1};\n\t\t\t\tint dy[4]={1,0,-1,0};\n\t\t\t\trep(k,4){\n\t\t\t\t\tint nx = X+dx[k];\n\t\t\t\t\tint ny = Y+dy[k];\n\t\t\t\t\tif(1<=nx&&nx<=cx.size()&&1<=ny&&ny<=cy.size()&&!bad[nx][ny]){\n\t\t\t\t\t\tint dt;\n\t\t\t\t\t\tif(k%2 == 0) dt = cy[max(Y,ny)-1]-cy[min(Y,ny)-1];\n\t\t\t\t\t\telse dt = cx[max(X,nx)-1]-cx[min(X,nx)-1];\n\t\t\t\t\t\tif(dist[nx][ny] > dist[X][Y]+dt){\n\t\t\t\t\t\t\tdist[nx][ny] = dist[X][Y]+dt;\n\t\t\t\t\t\t\tque.push(mp(dist[nx][ny],mp(nx,ny)));\n\t\t\t\t\t\t}\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t}\n\t\t\trep(ii,za.size()){\n\t\t\t\trep(jj,zb.size()){\n\t\t\t\t\tint xx = za[ii].sc.fi,yy = zb[jj].sc.fi;\n\t\t\t\t\txx = revx[xx]; yy = revy[yy];\n\t\t\t\t\tll cntt = 1LL*(za[ii].sc.sc-za[ii].sc.fi+1)*(zb[jj].sc.sc-zb[jj].sc.fi+1);\n\t\t\t\t\tcntt %= mod;\n\t\t\t\t\tint dif = dist[xx][yy];\n\t\t\t\t\t//cout << x << y << xx << yy << dif << endl;\n\t\t\t\t\tif(dif == INF) continue;\n\t\t\t\t\tdif -= cx[max(xx,x)-1]-cx[min(xx,x)-1]+cy[max(yy,y)-1]-cy[min(yy,y)-1];\n\t\t\t\t\tassert(dif >= 0);\n\t\t\t\t\tif(!za[ii].fi && !zb[jj].fi) add2 += (dif * (cnt * cntt % mod) % mod);\n\t\t\t\t\telse add += (dif * (cnt * cntt % mod) % mod);\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t}\n\tadd %= mod;\n\tadd = add*(mod+1)/2%mod;\n\tadd = (add+add2)%mod;\n\t//cout << add << endl;\n\tll ret = 0;\n\tfor(int i=1;i<w;i++){\n\t\tret += 1LL*h*h%mod*i%mod*(w-i)%mod;\n\t\tret %= mod;\n\t}\n\tfor(int i=1;i<h;i++){\n\t\tret += 1LL*w*w%mod*i%mod*(h-i)%mod;\n\t\tret %= mod;\n\t}\n\tfor(int i=0;i<n;i++){\n\t\tret -= 1LL*(a[i]-1)*a[i]%mod*((mod+1)/2)%mod*w%mod;\n\t\tret -= 1LL*(h-a[i])*(h-a[i]+1)%mod*((mod+1)/2)%mod*w%mod;\n\t\tret -= 1LL*(b[i]-1)*b[i]%mod*((mod+1)/2)%mod*h%mod;\n\t\tret -= 1LL*(w-b[i])*(w-b[i]+1)%mod*((mod+1)/2)%mod*h%mod;\n\t\tret %= mod;\n\t}\n\tfor(int i=0;i<n;i++){\n\t\tfor(int j=i+1;j<n;j++){\n\t\t\tret += abs(a[i]-a[j])+abs(b[i]-b[j]);\n\t\t\tret %= mod;\n\t\t}\n\t}\n\tret = (ret%mod+mod)%mod;\n\t//cout << ret << \" \" << add << endl;\n\tcout << (ret+add)%mod << endl;\n}"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\n#define il inline\n#define RG register\n#define ll long long\n#define rhl (1000000007)\n#define N (1000005)\n\nusing namespace std;\n\nstruct data{ int x,y; }a[35];\n\nconst int dx[4]={1,0,-1,0},dy[4]={0,1,0,-1};\n\nint cnt[65][65],can[65][65],dis[65][65],ans;\nint sx[N],sy[N],covx[N],covy[N],n,m,k,lx,ly;\nqueue<pair<int,int> > Q;\nvector<int> px,py;\n\nil int gi(){\n  RG int x=0,q=1; RG char ch=getchar();\n  while ((ch<'0' || ch>'9') && ch!='-') ch=getchar();\n  if (ch=='-') q=-1,ch=getchar();\n  while (ch>='0' && ch<='9') x=x*10+ch-'0',ch=getchar();\n  return q*x;\n}\n\nil void bfs(RG int sx,RG int sy){\n  memset(dis,0,sizeof(dis)),dis[sx][sy]=1,Q.push(make_pair(sx,sy));\n  while (!Q.empty()){\n    pair<int,int> now=Q.front(); Q.pop();\n    for (RG int i=0,x,y;i<4;++i){\n      x=now.first+dx[i],y=now.second+dy[i];\n      if (x<0 || x>lx || y<0 || y>ly || dis[x][y] || can[x][y]) continue;\n      dis[x][y]=dis[now.first][now.second]+1,Q.push(make_pair(x,y));\n      ans=(ans+1LL*cnt[sx][sy]*cnt[x][y]%rhl*(dis[x][y]-1))%rhl;\n    }\n  }\n  return;\n}\n\nint main(){\n  n=gi(),m=gi(),k=gi();\n  px.push_back(1),px.push_back(n+1);\n  py.push_back(1),py.push_back(m+1);\n  for (RG int i=1;i<=n;++i) sx[i]=m;\n  for (RG int i=1;i<=m;++i) sy[i]=n;\n  for (RG int i=1;i<=k;++i){\n    px.push_back(a[i].x=gi()+1),px.push_back(a[i].x+1);\n    py.push_back(a[i].y=gi()+1),py.push_back(a[i].y+1);\n    --sx[a[i].x],--sy[a[i].y],covx[a[i].x]=covy[a[i].y]=1;\n  }\n  for (RG int i=1;i<=n;++i) (sx[i]+=sx[i-1])%=rhl;\n  for (RG int i=1;i<=m;++i) (sy[i]+=sy[i-1])%=rhl;\n  for (RG int i=1;i<n;++i) if (!covx[i] && !covx[i+1]) ans=(ans+2LL*sx[i]*(sx[n]-sx[i]))%rhl;\n  for (RG int i=1;i<m;++i) if (!covy[i] && !covy[i+1]) ans=(ans+2LL*sy[i]*(sy[m]-sy[i]))%rhl;\n  sort(px.begin(),px.end()),px.erase(unique(px.begin(),px.end()),px.end()),lx=px.size()-2;\n  sort(py.begin(),py.end()),py.erase(unique(py.begin(),py.end()),py.end()),ly=py.size()-2;\n  for (RG int i=1;i<=k;++i){\n    a[i].x=lower_bound(px.begin(),px.end(),a[i].x)-px.begin();\n    a[i].y=lower_bound(py.begin(),py.end(),a[i].y)-py.begin();\n    can[a[i].x][a[i].y]=1;\n  }\n  for (RG int i=0;i<=lx;++i)\n    for (RG int j=0;j<=ly;++j)\n      cnt[i][j]=1LL*(px[i+1]-px[i])*(py[j+1]-py[j])%rhl;\n  for (RG int i=0;i<=lx;++i)\n    for (RG int j=0;j<=ly;++j) if (!can[i][j]) bfs(i,j);\n  cout<<1LL*(ans+rhl)*(rhl/2+1)%rhl; return 0;\n}\n"
  },
  {
    "language": "C++",
    "code": "#include<iostream>\n#include<cstdio>\n#include<cstdlib>\n#include<cmath>\n#include<cstring>\n#include<algorithm>\n#include<vector>\n#define rep(i,a,b) for(register int i=a;i<=b;i++)\n#define dep(i,a,b) for(register int i=a;i>=b;i--)\n#define ll long long\n#define mem(x,num) memset(x,num,sizeof x)\n#define reg(x) for(int i=last[x];i;i=e[i].next)\nusing namespace std;\ninline ll read(){\n    ll f=1,x=0;char ch=getchar();\n    while(ch<'0'||ch>'9'){if(ch=='-')f=-1;ch=getchar();}\n    while(ch>='0'&&ch<='9'){x=x*10+ch-'0';ch=getchar();}\n    return x*f;\n}\n//**********head by yjjr**********\n#define pb push_back\n#define inf 1e9\nconst int maxn=66,maxm=1e6+6,dx[4]={-1,1,0,0},dy[4]={0,0,-1,1},mod=1e9+7;\nstruct node{int x,y;}a[maxn<<1],que[maxn*maxn*4];\nint n,m,K,ans,lx,ly,cnt[maxn][maxn],s1[maxm],s2[maxm],dis[maxn][maxn],head,tail;\nbool fb[maxn][maxn],mark1[maxm],mark2[maxm];\nvector<int>px,py;\nvoid vnique(vector <int> &r){\n    sort(r.begin(),r.end());\n    auto t=unique(r.begin(),r.end());\n    r.erase(t,r.end());\n}\nvoid bfs(int x,int y){\n    rep(i,0,lx)rep(j,0,ly)dis[i][j]=inf;\n    dis[x][y]=0;que[head=tail=1]=(node){x,y};\n    while(head<=tail){\n        int nx=que[head].x,ny=que[head++].y;\n        rep(i,0,3){\n            int nex=nx+dx[i],ney=ny+dy[i];\n            if(nex>lx||nex<0||ney>ly||ney<0||dis[nex][ney]<=dis[nx][ny]+1||fb[nex][ney])continue;\n            dis[nex][ney]=dis[nx][ny]+1;que[++tail]=(node){nex,ney};\n        }\n    }\n}\nint main()\n{\n    n=read(),m=read(),K=read();\n    px.pb(1);px.pb(n+1);py.pb(1);py.pb(m+1);\n    rep(i,1,n)s1[i]=m;\n    rep(i,1,m)s2[i]=n;\n    rep(i,1,K){\n        a[i].x=read()+1,a[i].y=read()+1;\n        px.pb(a[i].x),px.pb(a[i].x+1);\n        py.pb(a[i].y),py.pb(a[i].y+1);\n        s1[a[i].x]--,mark1[a[i].x]=1;\n        s2[a[i].y]--,mark2[a[i].y]=1;\n    }\n    rep(i,1,n)s1[i]=(s1[i]+s1[i-1])%mod;\n    rep(i,1,m)s2[i]=(s2[i]+s2[i-1])%mod;\n    rep(i,1,n-1)if(!mark1[i]&&!mark1[i+1])ans=(ans+1ll*2*s1[i]*(s1[n]-s1[i]))%mod;\n    rep(i,1,m-1)if(!mark2[i]&&!mark2[i+1])ans=(ans+1ll*2*s2[i]*(s2[m]-s2[i]))%mod;\n    vnique(px);vnique(py);lx=px.size()-2;ly=py.size()-2;\n    rep(i,1,K)\n        fb[lower_bound(px.begin(),px.end(),a[i].x)-px.begin()][lower_bound(py.begin(),py.end(),a[i].y)-py.begin()]=1;\n    rep(i,0,lx)rep(j,0,ly)cnt[i][j]=1ll*(px[i+1]-px[i])*(py[j+1]-py[j])%mod;\n    rep(i,0,lx)rep(j,0,ly)\n        if(!fb[i][j]){\n            bfs(i,j);\n            rep(k,0,lx)rep(p,0,ly)\n                if(!fb[k][p])ans=(ans+1ll*cnt[i][j]*dis[k][p]%mod*cnt[k][p])%mod; \n        }\n    ans=(ans+mod)%mod;ans=1ll*ans*(mod/2+1)%mod;\n    cout<<ans<<endl;\n    return 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\nusing namespace std;\ntypedef signed long long ll;\n\n#undef _P\n#define _P(...) (void)printf(__VA_ARGS__)\n#define FOR(x,to) for(x=0;x<(to);x++)\n#define FORR(x,arr) for(auto& x:arr)\n#define ITR(x,c) for(__typeof(c.begin()) x=c.begin();x!=c.end();x++)\n#define ALL(a) (a.begin()),(a.end())\n#define ZERO(a) memset(a,0,sizeof(a))\n#define MINUS(a) memset(a,0xff,sizeof(a))\n//-------------------------------------------------------\n\nll H,W;\nint N;\nset<pair<int,int>> S;\nvector<int> Rs,Cs;\nint NR,NC;\nll weight[1010][1010];\nll ret;\nll mo=1000000007;\nint D[100][100];\n\nvoid solve() {\n\tint i,j,k,l,r,x,y; string s;\n\t\n\tll r2=(mo+1)/2;\n\tll r3=(mo+1)/3;\n\t\n\tcin>>H>>W>>N;\n\tRs.push_back(0);\n\tRs.push_back(H);\n\tCs.push_back(0);\n\tCs.push_back(W);\n\tFOR(i,N) {\n\t\tcin>>y>>x;\n\t\tRs.push_back(y);\n\t\tRs.push_back(y+1);\n\t\tCs.push_back(x);\n\t\tCs.push_back(x+1);\n\t\tS.insert({y,x});\n\t}\n\tsort(ALL(Rs));\n\tsort(ALL(Cs));\n\tRs.erase(unique(ALL(Rs)),Rs.end());\n\tCs.erase(unique(ALL(Cs)),Cs.end());\n\t\n\tNR=Rs.size()-1;\n\tNC=Cs.size()-1;\n\tFOR(y,NR) FOR(x,NC) {\n\t\tweight[y][x]=(Rs[y+1]-Rs[y])*(Cs[x+1]-Cs[x])%mo;\n\t\tif(S.count({Rs[y],Cs[x]})) weight[y][x]=0;\n\t}\n\t\n\tFOR(y,NR) {\n\t\tll t=Rs[y+1]-Rs[y];\n\t\tll L=0,R=0;\n\t\tFOR(x,NC) {\n\t\t\tFOR(i,y) L+=weight[i][x];\n\t\t\tfor(i=y+1;i<NR;i++) R+=weight[i][x];\n\t\t}\n\t\t(ret+=(L%mo)*(R%mo)%mo*(t-1))%=mo;\n\t\t(ret+=(W%mo)*((L+R)%mo)%mo*((t*(t-1)/2)%mo))%=mo;\n\t\t(ret+=W*W%mo*t%mo*(t+1)%mo*r2%mo*r2%mo*(((2*t+1)*r3+mo-1)%mo))%=mo;\n\t}\n\tFOR(x,NC) {\n\t\tll t=Cs[x+1]-Cs[x];\n\t\tll L=0,R=0;\n\t\tFOR(y,NR) {\n\t\t\tFOR(i,x) L+=weight[y][i];\n\t\t\tfor(i=x+1;i<NC;i++) R+=weight[y][i];\n\t\t}\n\t\t(ret+=(L%mo)*(R%mo)%mo*(t-1))%=mo;\n\t\t(ret+=(H%mo)*((L+R)%mo)%mo*((t*(t-1)/2)%mo))%=mo;\n\t\t(ret+=H*H%mo*t%mo*(t+1)%mo*r2%mo*r2%mo*(((2*t+1)*r3+mo-1)%mo))%=mo;\n\t}\n\t\n\tFOR(y,NR) FOR(x,NC) if(weight[y][x]) {\n\t\tint cy,cx,ty,tx;\n\t\tFOR(ty,NR) FOR(tx,NC) D[ty][tx]=101010;\n\t\tqueue<int> Q;\n\t\tD[y][x]=0;\n\t\tQ.push(y*100+x);\n\t\twhile(Q.size()) {\n\t\t\tcy=Q.front()/100;\n\t\t\tcx=Q.front()%100;\n\t\t\tQ.pop();\n\t\t\t\n\t\t\tint d[4]={1,0,-1,0};\n\t\t\tFOR(i,4) {\n\t\t\t\tty=cy+d[i];\n\t\t\t\ttx=cx+d[i^1];\n\t\t\t\tif(ty<0 || ty>=NR || tx<0 || tx>=NC) continue;\n\t\t\t\tif(weight[ty][tx]==0) continue;\n\t\t\t\tif(D[ty][tx]<=D[cy][cx]+1) continue;\n\t\t\t\tD[ty][tx]=D[cy][cx]+1;\n\t\t\t\tQ.push(ty*100+tx);\n\t\t\t\tif(y*100+x<ty*100+tx) {\n\t\t\t\t\t(ret+=weight[y][x]*weight[ty][tx]%mo*D[ty][tx])%=mo;\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t\t\n\t}\n\t\n\tcout<<ret<<endl;\n}\n\n\nint main(int argc,char** argv){\n\tstring s;int i;\n\tif(argc==1) ios::sync_with_stdio(false), cin.tie(0);\n\tFOR(i,argc-1) s+=argv[i+1],s+='\\n'; FOR(i,s.size()) ungetc(s[s.size()-1-i],stdin);\n\tcout.tie(0); solve(); return 0;\n}\n"
  },
  {
    "language": "C++",
    "code": "/*\n妙题，神\n考虑第 i 行和第 i + 1 行之间的边的贡献\n显然是 (1 ~ i 行白点贡献) * (i + 1 ~ h 行白点贡献)\n那么算过贡献以后将 i 和 i + 1 合并，将该行的值从 1 变为 2\n对列也这么做一遍\n最后剩下的是个 2n * 2n 的方格图\nbfs一遍，n^4\n*/\n#include <bits/stdc++.h>\n#define rep(i, x, y) for (int i = x; i <= y; i++)\nusing namespace std;\n\ntypedef long long ll;\nconst int mod = 1e9 + 7, N = 1e6 + 10, M = 105, inf = 0x3f3f3f3f;\nll h, w, n, xx, yy, r[N], c[N], ans, cnt[M][M];\nint dis[M][M];\nbool mp[M][M];\nstruct node { ll x, y; }a[N];\nvector<int> row, col;\nconst int d[][2] = {{0, 1}, {0, -1}, {1, 0}, {-1, 0}};\n\nvoid uniq(vector<int> &vec) {\n    sort(vec.begin(), vec.end());\n    vec.erase(unique(vec.begin(), vec.end()), vec.end());  // !!!\n}\n\nqueue<node> q;\nvoid bfs(int sx, int sy) {\n    memset(dis, 0x3f, sizeof(dis));\n    q.push((node){sx, sy});\n    dis[sx][sy] = 0;\n    while (q.size()) {\n        node t = q.front(); q.pop();\n        rep(i, 0, 3) {\n            int tx = t.x + d[i][0], ty = t.y + d[i][1];\n            if (tx < 0 || ty < 0 || tx > xx || ty > yy || mp[tx][ty] || dis[tx][ty] != inf) continue;\n            dis[tx][ty] = dis[t.x][t.y] + 1;\n            q.push((node){tx, ty});\n        }\n    }\n}\n\nint main() {\n    cin >> h >> w >> n;\n    rep(i, 1, h) r[i] = w;\n    rep(i, 1, w) c[i] = h;\n    row.push_back(1), row.push_back(h + 1), col.push_back(1), col.push_back(w + 1);\n    rep(i, 1, n) {\n        scanf(\"%lld%lld\", &a[i].x, &a[i].y);\n        ++a[i].x, ++a[i].y;\n        row.push_back(a[i].x), row.push_back(a[i].x + 1);\n        col.push_back(a[i].y), col.push_back(a[i].y + 1);\n        r[a[i].x]--, c[a[i].y]--;\n    }\n    uniq(row), uniq(col);\n    rep(i, 1, n) {\n        int x = lower_bound(row.begin(), row.end(), a[i].x) - row.begin();\n        int y = lower_bound(col.begin(), col.end(), a[i].y) - col.begin();\n        mp[x][y] = 1;\n    }\n    \n    rep(i, 1, h) r[i] = (r[i] + r[i - 1]) % mod;\n    rep(i, 1, w) c[i] = (c[i] + c[i - 1]) % mod;\n    rep(i, 1, h - 1)\n        if ((r[i] - r[i - 1] + mod) % mod == w && (r[i + 1] - r[i] + mod) % mod == w)\n            ans = (ans + 2 * r[i] * (r[h] - r[i] + mod) % mod) % mod;  // * 2, 后面会 / 回去\n    rep(i, 1, w - 1)\n        if ((c[i] - c[i - 1] + mod) % mod == h && (c[i + 1] - c[i] + mod) % mod == h)\n            ans = (ans + 2 * c[i] * (c[w] - c[i] + mod) % mod) % mod;\n    \n    xx = row.size() - 2;\n    yy = col.size() - 2;\n    rep(i, 0, xx)\n        rep(j, 0, yy)\n            if (!mp[i][j])\n                cnt[i][j] = 1ll * (row[i + 1] - row[i]) * (col[j + 1] - col[j]) % mod;  // !!!\n\n    rep(i, 0, xx) {\n        rep(j, 0, yy) {\n            if (!mp[i][j]) {\n                bfs(i, j);\n                rep(k, 0, xx) {\n                    rep(l, 0, yy) {\n                        if (!mp[k][l]) {\n                            ans = (ans + cnt[i][j] * dis[k][l] % mod * cnt[k][l] % mod) % mod;\n                        }\n                    }\n                }\n            }\n        }\n    }\n    printf(\"%lld\\n\", ans * (mod / 2 + 1) % mod);  // mod / 2 + 1 = (mod - mod / 2) * inv[mod % 2] % mod\n    return 0;\n}\n"
  },
  {
    "language": "C++",
    "code": "\n#include<bits/stdc++.h>\nusing namespace std;\n#define DB(x){if(DEBUG)cerr<<__LINE__<<\" \"<<#x<<\" \" <<x<<endl;}\n#define REP(i,b)for(LL i=(0);i<(b);++i)\n#define FOR(i,a,b)for(LL i=(a);i<=(b);++i)\n#define FORD(i,a,b)for(LL i=(a);i>=(b);--i)\n#define ALL(x) (x).begin(),(x).end()\n#define VV vector\ntemplate<typename X,typename Y>void MAX(X&a,Y b){a=(a>=b?a:b);}\ntemplate<typename X,typename Y>void MIN(X&a,Y b){a=(a<=b?a:b);}\ntypedef long long LL;typedef long double LD;\nint DEBUG=0,MULTI=0,GCJ=0;\n\nstruct solver_t;solver_t *solver;\nconst int MOD = 1e9 + 7;\nstruct solver_t {\n  int ROWS = -1, COLS = -1;\n  int IS_BLACK[70][70] = {};\n  int HEI[70][70] = {};\n  int WID[70][70] = {};\n\n  LL calculate(LL source_r, LL source_c) {\n    struct pkt_t { LL R = -1, C = -1; LL dst = -1;\n      bool operator < (const pkt_t rhs) const {\n        return dst < rhs.dst;\n      }\n    };\n    DB(source_r<<\" \"<<source_c);\n\n    LL DST[70][70];\n    memset(DST, 0x7f, sizeof(DST));\n    DST[source_r][source_c] = 0;\n\n    multiset <pkt_t> KOL;\n    KOL.insert({source_r, source_c, 0});\n    while (KOL.size() > 0) {\n      auto front = KOL.begin();\n      auto top = *front;\n      KOL.erase(front);\n      if (DST[top.R][top.C] != top.dst) continue;\n\n      FOR (dr, -1, 1) FOR (dc, -1, 1) if (abs(dr) + abs(dc) == 1) {\n        if (dr) {\n          int next_r = top.R + dr;\n          int next_c = top.C;\n          if (!(next_r >=0 && next_r < ROWS)) continue;\n          if (IS_BLACK[next_r][next_c]) continue;\n\n          LL diff_dst;\n          if (next_r == source_r || top.R == source_r) diff_dst = 1;\n          else diff_dst = HEI[top.R][top.C];\n\n          if (DST[next_r][next_c] > diff_dst + top.dst) {\n            DST[next_r][next_c] = diff_dst + top.dst;\n            KOL.insert( { next_r, next_c, DST[next_r][next_c]} );\n          }\n        }\n        if (dc) {\n\n          int next_r = top.R;\n          int next_c = top.C + dc;\n          if (!(next_c >= 0 && next_c < COLS)) continue;\n          if (IS_BLACK[next_r][next_c]) continue;\n\n          int diff_dst;\n          if (next_c == source_c || top.C == source_c) diff_dst = 1;\n          else diff_dst = WID[top.R][top.C];\n\n          if (DST[next_r][next_c] > diff_dst + top.dst) {\n            DST[next_r][next_c] = diff_dst + top.dst;\n            KOL.insert( { next_r, next_c, DST[next_r][next_c]} );\n          }\n        }\n      }\n    }\n\n\n\n    auto power=[](LL a, LL b) {\n      LL res = 1;\n      while (b) {\n        if (b&1) res=(res*a)%MOD;\n        b/=2; a=(a*a)%MOD;\n      }\n      return res;\n    };\n    LL rev3 = power(3, MOD - 2);\n    LL res = 0;\n    REP (r, ROWS) REP (c, COLS) if (IS_BLACK[r][c] == 0) {\n      DB(source_r<<\" \"<<source_c<<\" \"<<r<<\" \"<<c<<\" \"<<DST[r][c]);\n      pair<int,int> V1(source_r, source_c);\n      pair<int,int> V2(r, c);\n      //if (!(V1 <= V2)) continue;\n\n      res += DST[r][c] % MOD * HEI[r][c] % MOD * WID[r][c] % MOD *\n             HEI[source_r][source_c] % MOD * WID[source_r][source_c] % MOD;\n\n      auto oblicz=[&](LL wid) {\n        LL N = wid + 1;\n        if (N < 3) return 0LL;\n        LL res = ((N * (N-1) % MOD) *(N-2)) % MOD;\n        res = (res * rev3) % MOD;\n\n        return res;\n      };\n      DB(oblicz(0));\n      DB(oblicz(1));\n      DB(oblicz(2));\n      DB(oblicz(3));\n      DB(oblicz(4));\n      DB(oblicz(5));\n      DB(oblicz(10));\n\n      auto oblicz2=[](LL wid1,LL wid2) {\n        LL p1 = (wid1 - 1) * wid1 / 2 % MOD * wid2;\n        LL p2 = (wid2 - 1) * wid2 / 2 % MOD * wid1;\n        return p1 + p2;\n      };\n\n      LL v1 = 0;\n      if (source_r == r) {\n        int hei = HEI[r][c];\n        assert(HEI[r][c] == HEI[source_r][source_c]);\n\n        LL tmp = oblicz(hei) % MOD;\n        tmp = (tmp * WID[r][c] % MOD * WID[source_r][source_c]) % MOD;\n\n        res += tmp;\n      }\n      else {\n        LL tmp = oblicz2(HEI[r][c], HEI[source_r][source_c]);\n        tmp = (tmp * WID[r][c] % MOD * WID[source_r][source_c]) % MOD;\n        res += tmp;\n      }\n      if (source_c == c) {\n        int wid = WID[r][c];\n        assert(WID[r][c] == WID[source_r][source_c]);\n        LL tmp = oblicz(wid) % MOD;\n        tmp = (tmp * HEI[r][c] % MOD * HEI[source_r][source_c]) % MOD;\n\n        res += tmp;\n      }\n      else {\n        LL tmp = oblicz2(WID[r][c], WID[source_r][source_c]) % MOD;\n\n        tmp = (tmp * HEI[r][c] % MOD * HEI[source_r][source_c]) % MOD;\n        res += tmp;\n      }\n      res %= MOD;\n    }\n\n    return res;\n  }\n\n\n  void solve() {\n    int H, W;cin >>H>>W;\n    int N; cin >> N;\n\n    VV<int> CORD_R;\n    VV<int> CORD_C;\n\n    VV<array<int,2> > BLACK;\n    REP (i, N) {\n      int r, c;\n      cin >> r >> c;\n      BLACK.push_back({r,c});\n      CORD_R.push_back(r);\n      CORD_R.push_back(r + 1);\n\n      CORD_C.push_back(c);\n      CORD_C.push_back(c + 1);\n    }\n    CORD_R.push_back(0);\n    CORD_R.push_back(H);\n\n    CORD_C.push_back(0);\n    CORD_C.push_back(W);\n\n    sort( ALL(CORD_R) ); CORD_R.erase(unique(ALL(CORD_R)), CORD_R.end());\n    sort( ALL(CORD_C) ); CORD_C.erase(unique(ALL(CORD_C)), CORD_C.end());\n\n    for (int cr : CORD_R) DB(cr);\n    for (int cc : CORD_C) DB(cc);\n\n\n    ROWS = CORD_R.size() - 1;\n    COLS = CORD_C.size() - 1;\n\n    for (auto black : BLACK) {\n      int r = lower_bound(ALL(CORD_R), black[0]) - CORD_R.begin();\n      int c = lower_bound(ALL(CORD_C), black[1]) - CORD_C.begin();\n      IS_BLACK[r][c] = 1;\n    }\n    REP (r, ROWS) REP (c, COLS) {\n      HEI[r][c] = CORD_R[r + 1] - CORD_R[r];\n      WID[r][c] = CORD_C[c + 1] - CORD_C[c];\n    }\n\n\n    LL res = 0;\n    auto power=[](LL a, LL b) {\n      LL res = 1;\n      while (b) {\n        if (b&1) res=(res*a)%MOD;\n        b/=2; a=(a*a)%MOD;\n      }\n      return res;\n    };\n    LL rev2 = power(2, MOD - 2);\n    REP (r, ROWS) REP (c, COLS) if (IS_BLACK[r][c] == 0) {\n      res += calculate(r, c);\n      res %= MOD;\n    }\n    cout << (res * rev2) % MOD << \"\\n\";\n  }\n\n\n  void gen() {}\n  void brute() {}\n};\n\nint main(int argc,char** argv){\n  FOR(i,1,argc-1)for(int j=0;argv[i][j];j++)if(argv[i][j]=='.')freopen(argv[i],\"r\",stdin);\n  FOR(i,1,argc-1)if(argv[i]==string(\"q\"))DEBUG=1<<30;\n  FOR(i,1,argc-1)if(argv[i]==string(\"gen\")){(solver=new solver_t())->gen();exit(0);}\n  FOR(i,1,argc-1)if(argv[i]==string(\"brute\")){(solver=new solver_t())->brute();exit(0);}\n  ios::sync_with_stdio(false),cin.tie(0);\n  cout.setf(ios::fixed),cout.precision(10);int t;if(MULTI||GCJ)cin>>t;else t=1;\n  FOR(i,1,t){if(DEBUG)cerr<<__LINE__<<\" \"<<i<<endl;if(GCJ)cout<<\"Case #\"<<i<<\": \";\n    solver = new solver_t();\n    solver->solve();\n  }return 0;\n}\n\n"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\nusing namespace std;\n \ntypedef long long ll;\ntypedef long double ld; \ntypedef double db; \ntypedef string str; \n\ntypedef pair<int, int> pi;\ntypedef pair<ll,ll> pl; \ntypedef pair<ld,ld> pd; \n#define mp make_pair\n#define f first\n#define s second\n\ntypedef vector<int> vi; \ntypedef vector<ll> vl; \ntypedef vector<ld> vd; \ntypedef vector<str> vs; \ntypedef vector<pi> vpi; \ntypedef vector<pl> vpl; \ntypedef vector<pd> vpd; \n\n#define sz(x) (int)x.size()\n#define all(x) begin(x), end(x)\n#define rall(x) (x).rbegin(), (x).rend() \n#define rsz resize\n#define ins insert \n#define ft front() \n#define bk back() \n#define pf push_front \n#define pb push_back\n#define eb emplace_back \n#define lb lower_bound \n#define ub upper_bound \n\n#define FOR(i,a,b) for (int i = (a); i < (b); ++i)\n#define F0R(i,a) FOR(i,0,a)\n#define ROF(i,a,b) for (int i = (b)-1; i >= (a); --i)\n#define R0F(i,a) ROF(i,0,a)\n#define trav(a,x) for (auto& a: x)\n\nconst int MOD = 1e9+7; // 998244353; // = (119<<23)+1\nconst int MX = 2e5+5; \nconst ll INF = 1e18; \nconst ld PI = 4*atan((ld)1); \nconst int xd[4] = {0,1,0,-1}, yd[4] = {1,0,-1,0}; \n\ntemplate<class T> bool ckmin(T& a, const T& b) { \n\treturn a > b ? a = b, 1 : 0; }\ntemplate<class T> bool ckmax(T& a, const T& b) { \n\treturn a < b ? a = b, 1 : 0; }\nmt19937 rng((uint32_t)chrono::steady_clock::now().time_since_epoch().count());\n\n#include <ext/pb_ds/tree_policy.hpp>\n#include <ext/pb_ds/assoc_container.hpp>\nusing namespace __gnu_pbds;\n\ntemplate <class T> using Tree = tree<T, null_type, less<T>, \n\trb_tree_tag, tree_order_statistics_node_update>; \n// change null_type for map\n#define ook order_of_key\n#define fbo find_by_order\n\nvoid treeExample() {\n\tTree<int> t, t2; t.insert(8);\n\tauto it = t.insert(10).f; assert(it == t.lb(9));\n\tassert(t.ook(10) == 1); assert(t.ook(11) == 2);\n\tassert(*t.fbo(0) == 8);\n\tt.join(t2); // assuming T < T2 or T > T2, merge t2 into t\n}\n\nnamespace input {\n\ttemplate<class T> void re(complex<T>& x);\n\ttemplate<class T1, class T2> void re(pair<T1,T2>& p);\n\ttemplate<class T> void re(vector<T>& a);\n\ttemplate<class T, size_t SZ> void re(array<T,SZ>& a);\n\n\ttemplate<class T> void re(T& x) { cin >> x; }\n\tvoid re(double& x) { string t; re(t); x = stod(t); }\n\tvoid re(ld& x) { string t; re(t); x = stold(t); }\n\ttemplate<class T, class... Ts> void re(T& t, Ts&... ts) { \n\t\tre(t); re(ts...); \n\t}\n\n\ttemplate<class T> void re(complex<T>& x) { T a,b; re(a,b); x = cd(a,b); }\n\ttemplate<class T1, class T2> void re(pair<T1,T2>& p) { re(p.f,p.s); }\n\ttemplate<class T> void re(vector<T>& a) { F0R(i,sz(a)) re(a[i]); }\n\ttemplate<class T, size_t SZ> void re(array<T,SZ>& a) { F0R(i,SZ) re(a[i]); }\n}\n\nusing namespace input;\n\nnamespace output {\n\tvoid pr(int x) { cout << x; }\n\tvoid pr(long x) { cout << x; }\n\tvoid pr(ll x) { cout << x; }\n\tvoid pr(unsigned x) { cout << x; }\n\tvoid pr(unsigned long x) { cout << x; }\n\tvoid pr(unsigned long long x) { cout << x; }\n\tvoid pr(float x) { cout << x; }\n\tvoid pr(double x) { cout << x; }\n\tvoid pr(ld x) { cout << x; }\n\tvoid pr(char x) { cout << x; }\n\tvoid pr(const char* x) { cout << x; }\n\tvoid pr(const string& x) { cout << x; }\n\tvoid pr(bool x) { pr(x ? \"true\" : \"false\"); }\n\ttemplate<class T> void pr(const complex<T>& x) { cout << x; }\n\t\n\ttemplate<class T1, class T2> void pr(const pair<T1,T2>& x);\n\ttemplate<class T> void pr(const T& x);\n\t\n\ttemplate<class T, class... Ts> void pr(const T& t, const Ts&... ts) { \n\t\tpr(t); pr(ts...); \n\t}\n\ttemplate<class T1, class T2> void pr(const pair<T1,T2>& x) { \n\t\tpr(\"{\",x.f,\", \",x.s,\"}\"); \n\t}\n\ttemplate<class T> void pr(const T& x) { \n\t\tpr(\"{\"); // const iterator needed for vector<bool>\n\t\tbool fst = 1; for (const auto& a: x) pr(!fst?\", \":\"\",a), fst = 0; \n\t\tpr(\"}\");\n\t}\n\t\n\tvoid ps() { pr(\"\\n\"); } // print w/ spaces\n\ttemplate<class T, class... Ts> void ps(const T& t, const Ts&... ts) { \n\t\tpr(t); if (sizeof...(ts)) pr(\" \"); ps(ts...); \n\t}\n\t\n\tvoid pc() { pr(\"]\\n\"); } // debug w/ commas\n\ttemplate<class T, class... Ts> void pc(const T& t, const Ts&... ts) { \n\t\tpr(t); if (sizeof...(ts)) pr(\", \"); pc(ts...); \n\t}\n\t#define dbg(x...) pr(\"[\",#x,\"] = [\"), pc(x);\n}\n\nusing namespace output;\n\nnamespace io {\n\tvoid setIn(string s) { freopen(s.c_str(),\"r\",stdin); }\n\tvoid setOut(string s) { freopen(s.c_str(),\"w\",stdout); }\n\tvoid setIO(string s = \"\") {\n\t\tios_base::sync_with_stdio(0); cin.tie(0); // fast I/O\n\t\t// cin.exceptions(cin.failbit); // ex. throws exception when you try to read letter into int\n\t\tif (sz(s)) { setIn(s+\".in\"), setOut(s+\".out\"); } // for USACO\n\t}\n}\n\nusing namespace io;\n\nstruct mi {\n\ttypedef decay<decltype(MOD)>::type T;\n\tT val; \n\texplicit operator T() const { return val; }\n\tmi() { val = 0; }\n\tmi(ll v) { \n\t\tval = (-MOD <= v && v <= MOD) ? v : v % MOD;\n\t\tif (val < 0) val += MOD;\n\t}\n\tfriend bool operator==(const mi& a, const mi& b) { \n\t\treturn a.val == b.val; }\n\tfriend bool operator!=(const mi& a, const mi& b) { \n\t\treturn !(a == b); }\n\tfriend bool operator<(const mi& a, const mi& b) { \n\t\treturn a.val < b.val; }\n\tfriend void re(mi& a) { ll x; re(x); a = mi(x); }\n\tfriend void pr(const mi& a) { pr(a.val); }\n\tfriend ostream& operator<<(ostream& os, const mi& a) { \n\t\treturn os << a.val; }\n   \n\tmi operator-() const { return mi(-val); }\n\tmi& operator+=(const mi& m) { \n\t\tif ((val += m.val) >= MOD) val -= MOD; \n\t\treturn *this; }\n\tmi& operator-=(const mi& m) { \n\t\tif ((val -= m.val) < 0) val += MOD; \n\t\treturn *this; }\n\tmi& operator++() { return *this += 1; }\n\tmi& operator--() { return *this -= 1; }\n\tfriend mi operator+(mi a, const mi& b) { return a += b; }\n\tfriend mi operator-(mi a, const mi& b) { return a -= b; }\n\n\tmi& operator*=(const mi& m) { \n\t\tval = (ll)val*m.val%MOD; return *this; }\n\tfriend mi pow(mi a, ll p) {\n\t\tmi ans = 1; assert(p >= 0);\n\t\tfor (; p; p /= 2, a *= a) if (p&1) ans *= a;\n\t\treturn ans;\n\t}\n\tfriend mi inv(const mi& a) { \n\t\tassert(!(a == 0)); return pow(a,MOD-2); }\n\tmi& operator/=(const mi& m) { return (*this) *= inv(m); }\n\tfriend mi operator*(mi a, const mi& b) { return a *= b; }\n\tfriend mi operator/(mi a, const mi& b) { return a /= b; }\n};\ntypedef pair<mi,mi> pmi;\ntypedef vector<mi> vmi;\ntypedef vector<pmi> vpmi;\n\nll H,W,N;\nint dist[100][100];\nvpi v,X,Y;\nvi x,y;\nmi ans;\nmi w[100][100];\nbool bad[100][100];\n\nvoid xsum(pi p) {\n\tint l = 0;\n\ttrav(t,v) if (t.f < p.f) l ++;\n\tint r = sz(v)-l;\n\tFOR(i,p.f,p.s) {\n\t\tmi A = W*(i+1)-l;\n\t\tmi B = W*(H-1-i)-r;\n\t\tans += A*B;\n\t}\n}\n\nvoid ysum(pi p) {\n\tint l = 0;\n\ttrav(t,v) if (t.s < p.f) l ++;\n\tint r = sz(v)-l;\n\tFOR(i,p.f,p.s) {\n\t\tmi A = H*(i+1)-l;\n\t\tmi B = H*(W-1-i)-r;\n\t\tans += A*B;\n\t}\n}\n\nvoid genDist(pi p) {\n\tF0R(i,sz(X)) F0R(j,sz(Y)) dist[i][j] = MOD;\n\tdist[p.f][p.s] = 0;\n\tqueue<pi> q; q.push(p);\n\twhile (sz(q)) {\n\t\tauto a = q.front(); q.pop();\n\t\tF0R(i,4) {\n\t\t\tpi A = {a.f+xd[i],a.s+yd[i]};\n\t\t\tif (A.f < 0 || A.f >= sz(X) || A.s < 0 || A.s >= sz(Y)) continue;\n\t\t\tif (bad[A.f][A.s] || dist[A.f][A.s] != MOD) continue;\n\t\t\tdist[A.f][A.s] = dist[a.f][a.s]+1;\n\t\t\tq.push(A);\n\t\t}\n\t}\n}\n\nint main() {\n\tios_base::sync_with_stdio(0); cin.tie(0);\n\tre(H,W,N);\n\tv.rsz(N); re(v);\n\ttrav(t,v) {\n\t\tx.pb(t.f), y.pb(t.s);\n\t}\n\tsort(all(x)), sort(all(y));\n\tx.erase(unique(all(x)),end(x)), y.erase(unique(all(y)),end(y));\n\tint lx = 0;\n\ttrav(t,x) {\n\t\tif (lx < t) X.pb({lx,t-1});\n\t\tX.pb({t,t});\n\t\tlx = t+1;\n\t}\n\tif (lx < H) X.pb({lx,H-1});\n\tint ly = 0;\n\ttrav(t,y) {\n\t\tif (ly < t) Y.pb({ly,t-1});\n\t\tY.pb({t,t});\n\t\tly = t+1;\n\t}\n\tif (ly < W) Y.pb({ly,W-1});\n\ttrav(t,X) if (t.f != t.s) xsum(t);\n\ttrav(t,Y) if (t.f != t.s) ysum(t);\n\tF0R(i,sz(X)) F0R(j,sz(Y)) {\n\t\tw[i][j] = (ll)(X[i].s-X[i].f+1)*(Y[j].s-Y[j].f+1);\n\t\tif (find(all(v),mp(X[i].f,Y[j].f)) != end(v)) {\n\t\t\t// ps(\"WUT\",mp(X[i].f,Y[j].f));\n\t\t\tbad[i][j] = 1;\n\t\t}\n\t}\n\t// F0R(i,sz(X)) F0R(j,sz(Y)) ps(i,j,w[i][j],bad[i][j]);\n\tF0R(i,sz(X)) F0R(j,sz(Y)) if (!bad[i][j]) {\n\t\tgenDist({i,j});\n\t\tF0R(I,sz(X)) F0R(J,sz(Y)) if (mp(I,J) > mp(i,j) && !bad[I][J])\n\t\t\tans += w[i][j]*w[I][J]*dist[I][J];\n\t}\n\tps(ans);\n\t// you should actually read the stuff at the bottom\n}\n\n/* stuff you should look for\n\t* int overflow, array bounds\n\t* special cases (n=1?), slow multiset operations\n\t* do smth instead of nothing and stay organized\n*/"
  },
  {
    "language": "C++",
    "code": "#include <algorithm>  \n#include <iostream>  \n#include <sstream>  \n#include <string>  \n#include <cstring>\n#include <vector>  \n#include <queue>  \n#include <set>  \n#include <map>  \n#include <cstdio>  \n#include <cstdlib>  \n#include <cctype>  \n#include <cmath>  \n#include <list>  \n#include <cassert>\n#include <ctime>\n#include <climits>\nusing namespace std;  \n\n#define PB push_back  \n#define MP make_pair  \n#define SZ(v) ((int)(v).size())  \n#define FOR(i,a,b) for(int i=(a);i<(b);++i)  \n#define REP(i,n) FOR(i,0,n)  \n#define FORE(i,a,b) for(int i=(a);i<=(b);++i)  \n#define REPE(i,n) FORE(i,0,n)  \n#define FORSZ(i,a,v) FOR(i,a,SZ(v))  \n#define REPSZ(i,v) REP(i,SZ(v))  \ntypedef long long ll;\ntypedef unsigned long long ull;\nll gcd(ll a,ll b) { return b==0?a:gcd(b,a%b); }\n\nconst int MAXN=30;\nconst int MAXDIM=2*MAXN+1;\nconst int MOD=1000000007;\nconst int INV2=(MOD+1)/2;\nconst int DX[]={-1,0,+1,0},DY[]={0,+1,0,-1};\n\nint h,w,n;\nint px[MAXN],py[MAXN];\n\nint xx[2*MAXN+2],yy[2*MAXN+2],nxx,nyy;\n\nbool blocked[MAXDIM][MAXDIM];\nint cnt[MAXDIM][MAXDIM];\n\nint dst[MAXDIM][MAXDIM];\nint qx[MAXDIM*MAXDIM],qy[MAXDIM*MAXDIM],qhead,qtail;\nvoid upd(int x,int y,int d) { if(dst[x][y]!=INT_MAX) return; dst[x][y]=d; qx[qhead]=x,qy[qhead]=y,++qhead; }\n\nbool reachall;\nint solvecompressed() {\n\tint ret=0; reachall=true;\n\t//REP(x,nxx-1) { REP(y,nyy-1) printf(\"%c\",blocked[x][y]?'#':'.'); puts(\"\"); }\n\tREP(sx,nxx-1) REP(sy,nyy-1) if(!blocked[sx][sy]) {\n\t\tREP(x,nxx-1) REP(y,nyy-1) dst[x][y]=INT_MAX; qhead=qtail=0;\n\t\tupd(sx,sy,0);\n\t\twhile(qtail<qhead) {\n\t\t\tint x=qx[qtail],y=qy[qtail]; ++qtail;\n\t\t\tREP(k,4) {\n\t\t\t\tint nx=x+DX[k],ny=y+DY[k]; if(nx<0||nx>=nxx-1||ny<0||ny>=nyy-1||blocked[nx][ny]) continue;\n\t\t\t\tupd(nx,ny,dst[x][y]+1);\n\t\t\t}\n\t\t}\n\t\tREP(x,nxx-1) REP(y,nyy-1) if(!blocked[x][y]) {\n\t\t\tif(dst[x][y]==INT_MAX) reachall=false;\n\t\t\t//printf(\"(%d,%d)->(%d,%d) : %d * %d * %d\\n\",sx,sy,x,y,cnt[sx][sy],cnt[x][y],dst[x][y]);\n\t\t\tret=(ret+(ll)cnt[sx][sy]*cnt[x][y]%MOD*dst[x][y])%MOD;\n\t\t}\n\t}\n\t//printf(\"%d\\n\",ret);\n\tret=(ll)ret*INV2%MOD;\n\treturn ret;\n}\n\nint solve() {\n\tnxx=0; xx[nxx++]=0,xx[nxx++]=h; REP(i,n) xx[nxx++]=px[i],xx[nxx++]=px[i]+1; sort(xx,xx+nxx); nxx=unique(xx,xx+nxx)-xx; REP(i,n) px[i]=lower_bound(xx,xx+nxx,px[i])-xx;\n\tnyy=0; yy[nyy++]=0,yy[nyy++]=w; REP(i,n) yy[nyy++]=py[i],yy[nyy++]=py[i]+1; sort(yy,yy+nyy); nyy=unique(yy,yy+nyy)-yy; REP(i,n) py[i]=lower_bound(yy,yy+nyy,py[i])-yy;\n\n\tREP(x,nxx-1) REP(y,nyy-1) blocked[x][y]=false,cnt[x][y]=(ll)(xx[x+1]-xx[x])*(yy[y+1]-yy[y])%MOD;\n\tREP(i,n) blocked[px[i]][py[i]]=true;\n\n\tint ret=solvecompressed();\n\n\tREP(x,nxx-1) {\n\t\tint len=xx[x+1]-xx[x]; if(len==1) continue;\n\t\tint a=(ll)(len-1)*len*(len+1)/6%MOD;\n\t\tint b=(ll)w*w%MOD;\n\t\tint c=(ll)len*(len-1)/2%MOD;\n\t\tint lft=0,rgt=0; REP(cx,nxx-1) REP(cy,nyy-1) if(!blocked[cx][cy]) if(cx<x) lft=(lft+cnt[cx][cy])%MOD; else if(cx>x) rgt=(rgt+cnt[cx][cy])%MOD;\n\t\t//printf(\"cnt=%d a=%d b=%d c=%d lft=%d rgt=%d\\n\",len,a,b,c,lft,rgt);\n\t\tret=(ret+(ll)a*b)%MOD;\n\t\tret=(ret+(ll)lft*rgt%MOD*(len-1))%MOD;\n\t\tret=(ret+(ll)(lft+rgt)*c%MOD*w)%MOD;\n\t}\n\tREP(y,nyy-1) {\n\t\tint len=yy[y+1]-yy[y]; if(len==1) continue;\n\t\tint a=(ll)(len-1)*len*(len+1)/6%MOD;\n\t\tint b=(ll)h*h%MOD;\n\t\tint c=(ll)len*(len-1)/2%MOD;\n\t\tint lft=0,rgt=0; REP(cx,nxx-1) REP(cy,nyy-1) if(!blocked[cx][cy]) if(cy<y) lft=(lft+cnt[cx][cy])%MOD; else if(cy>y) rgt=(rgt+cnt[cx][cy])%MOD;\n\t\t//printf(\"cnt=%d a=%d b=%d c=%d lft=%d rgt=%d\\n\",len,a,b,c,lft,rgt);\n\t\tret=(ret+(ll)a*b)%MOD;\n\t\tret=(ret+(ll)lft*rgt%MOD*(len-1))%MOD;\n\t\tret=(ret+(ll)(lft+rgt)*c%MOD*h)%MOD;\n\t}\n\treturn ret;\n}\n\nvoid run() {\n\tscanf(\"%d%d%d\",&h,&w,&n);\n\tREP(i,n) scanf(\"%d%d\",&px[i],&py[i]);\n\tprintf(\"%d\\n\",solve());\n}\n\nint main() {\n\trun();\n\treturn 0;\n}\n"
  },
  {
    "language": "C++",
    "code": "\n#include<bits/stdc++.h>\n#define int long long\nusing namespace std;\n#define DB(x){if(DEBUG)cerr<<__LINE__<<\" \"<<#x<<\" \" <<x<<endl;}\n#define REP(i,b)for(LL i=(0);i<(b);++i)\n#define FOR(i,a,b)for(LL i=(a);i<=(b);++i)\n#define FORD(i,a,b)for(LL i=(a);i>=(b);--i)\n#define ALL(x) (x).begin(),(x).end()\n#define VV vector\ntemplate<typename X,typename Y>void MAX(X&a,Y b){a=(a>=b?a:b);}\ntemplate<typename X,typename Y>void MIN(X&a,Y b){a=(a<=b?a:b);}\ntypedef long long LL;typedef long double LD;\nint DEBUG=0,MULTI=0,GCJ=0;\n\nstruct solver_t;solver_t *solver;\nconst int MOD = 1e9 + 7;\nstruct solver_t {\n  int ROWS = -1, COLS = -1;\n  int IS_BLACK[70][70] = {};\n  LL HEI[70][70] = {};\n  LL WID[70][70] = {};\n\n  LL calculate(LL source_r, LL source_c) {\n    struct pkt_t { LL R = -1, C = -1; LL dst = -1;\n      bool operator < (const pkt_t rhs) const {\n        return dst < rhs.dst;\n      }\n    };\n    DB(source_r<<\" \"<<source_c);\n\n    LL DST[70][70];\n    memset(DST, 0x7f, sizeof(DST));\n    DST[source_r][source_c] = 0;\n\n    multiset <pkt_t> KOL;\n    KOL.insert({source_r, source_c, 0});\n    while (KOL.size() > 0) {\n      auto front = KOL.begin();\n      auto top = *front;\n      KOL.erase(front);\n      if (DST[top.R][top.C] != top.dst) continue;\n\n      FOR (dr, -1, 1) FOR (dc, -1, 1) if (abs(dr) + abs(dc) == 1) {\n        if (dr) {\n          int next_r = top.R + dr;\n          int next_c = top.C;\n          if (!(next_r >=0 && next_r < ROWS)) continue;\n          if (IS_BLACK[next_r][next_c]) continue;\n\n          LL diff_dst;\n          if (next_r == source_r || top.R == source_r) diff_dst = 1;\n          else diff_dst = HEI[top.R][top.C];\n\n          if (DST[next_r][next_c] > diff_dst + top.dst) {\n            DST[next_r][next_c] = diff_dst + top.dst;\n            KOL.insert( { next_r, next_c, DST[next_r][next_c]} );\n          }\n        }\n        if (dc) {\n\n          int next_r = top.R;\n          int next_c = top.C + dc;\n          if (!(next_c >= 0 && next_c < COLS)) continue;\n          if (IS_BLACK[next_r][next_c]) continue;\n\n          int diff_dst;\n          if (next_c == source_c || top.C == source_c) diff_dst = 1;\n          else diff_dst = WID[top.R][top.C];\n\n          if (DST[next_r][next_c] > diff_dst + top.dst) {\n            DST[next_r][next_c] = diff_dst + top.dst;\n            KOL.insert( { next_r, next_c, DST[next_r][next_c]} );\n          }\n        }\n      }\n    }\n\n\n\n    auto power=[](LL a, LL b) {\n      LL res = 1;\n      while (b) {\n        if (b&1) res=(res*a)%MOD;\n        b/=2; a=(a*a)%MOD;\n      }\n      return res;\n    };\n    LL rev3 = power(3, MOD - 2);\n    LL res = 0;\n    REP (r, ROWS) REP (c, COLS) if (IS_BLACK[r][c] == 0) {\n      DB(source_r<<\" \"<<source_c<<\" \"<<r<<\" \"<<c<<\" \"<<DST[r][c]);\n      pair<int,int> V1(source_r, source_c);\n      pair<int,int> V2(r, c);\n      //if (!(V1 <= V2)) continue;\n\n      res += DST[r][c] % MOD * HEI[r][c] % MOD * WID[r][c] % MOD *\n             HEI[source_r][source_c] % MOD * WID[source_r][source_c] % MOD;\n\n      auto oblicz=[&](LL wid) {\n        LL N = wid + 1;\n        if (N < 3) return 0LL;\n        LL res = ((N * (N-1) % MOD) *(N-2)) % MOD;\n        res = (res * rev3) % MOD;\n\n        return res;\n      };\n      DB(oblicz(0));\n      DB(oblicz(1));\n      DB(oblicz(2));\n      DB(oblicz(3));\n      DB(oblicz(4));\n      DB(oblicz(5));\n      DB(oblicz(10));\n\n      auto oblicz2=[](LL wid1,LL wid2) {\n        LL p1 = (wid1 - 1) * wid1 / 2 % MOD * wid2;\n        LL p2 = (wid2 - 1) * wid2 / 2 % MOD * wid1;\n        return p1 + p2;\n      };\n\n      LL v1 = 0;\n      if (source_r == r) {\n        int hei = HEI[r][c];\n        assert(HEI[r][c] == HEI[source_r][source_c]);\n\n        LL tmp = oblicz(hei) % MOD;\n        tmp = (tmp * WID[r][c] % MOD * WID[source_r][source_c]) % MOD;\n\n        res += tmp;\n      }\n      else {\n        LL tmp = oblicz2(HEI[r][c], HEI[source_r][source_c]);\n        tmp = (tmp * WID[r][c] % MOD * WID[source_r][source_c]) % MOD;\n        res += tmp;\n      }\n      if (source_c == c) {\n        int wid = WID[r][c];\n        assert(WID[r][c] == WID[source_r][source_c]);\n        LL tmp = oblicz(wid) % MOD;\n        tmp = (tmp * HEI[r][c] % MOD * HEI[source_r][source_c]) % MOD;\n\n        res += tmp;\n      }\n      else {\n        LL tmp = oblicz2(WID[r][c], WID[source_r][source_c]) % MOD;\n\n        tmp = (tmp * HEI[r][c] % MOD * HEI[source_r][source_c]) % MOD;\n        res += tmp;\n      }\n      res %= MOD;\n    }\n\n    return res;\n  }\n\n\n  void solve() {\n    int H, W;cin >>H>>W;\n    int N; cin >> N;\n\n    VV<int> CORD_R;\n    VV<int> CORD_C;\n\n    VV<array<int,2> > BLACK;\n    REP (i, N) {\n      int r, c;\n      cin >> r >> c;\n      BLACK.push_back({r,c});\n      CORD_R.push_back(r);\n      CORD_R.push_back(r + 1);\n\n      CORD_C.push_back(c);\n      CORD_C.push_back(c + 1);\n    }\n    CORD_R.push_back(0);\n    CORD_R.push_back(H);\n\n    CORD_C.push_back(0);\n    CORD_C.push_back(W);\n\n    sort( ALL(CORD_R) ); CORD_R.erase(unique(ALL(CORD_R)), CORD_R.end());\n    sort( ALL(CORD_C) ); CORD_C.erase(unique(ALL(CORD_C)), CORD_C.end());\n\n    for (int cr : CORD_R) DB(cr);\n    for (int cc : CORD_C) DB(cc);\n\n\n    ROWS = CORD_R.size() - 1;\n    COLS = CORD_C.size() - 1;\n\n    for (auto black : BLACK) {\n      int r = lower_bound(ALL(CORD_R), black[0]) - CORD_R.begin();\n      int c = lower_bound(ALL(CORD_C), black[1]) - CORD_C.begin();\n      IS_BLACK[r][c] = 1;\n    }\n    REP (r, ROWS) REP (c, COLS) {\n      HEI[r][c] = CORD_R[r + 1] - CORD_R[r];\n      WID[r][c] = CORD_C[c + 1] - CORD_C[c];\n    }\n\n\n    LL res = 0;\n    auto power=[](LL a, LL b) {\n      LL res = 1;\n      while (b) {\n        if (b&1) res=(res*a)%MOD;\n        b/=2; a=(a*a)%MOD;\n      }\n      return res;\n    };\n    LL rev2 = power(2, MOD - 2);\n    REP (r, ROWS) REP (c, COLS) if (IS_BLACK[r][c] == 0) {\n      res += calculate(r, c);\n      res %= MOD;\n    }\n    cout << (res * rev2) % MOD << \"\\n\";\n  }\n\n\n  void gen() {}\n  void brute() {}\n};\n\n#undef int\nint main(int argc,char** argv){\n  FOR(i,1,argc-1)for(int j=0;argv[i][j];j++)if(argv[i][j]=='.')freopen(argv[i],\"r\",stdin);\n  FOR(i,1,argc-1)if(argv[i]==string(\"q\"))DEBUG=1<<30;\n  FOR(i,1,argc-1)if(argv[i]==string(\"gen\")){(solver=new solver_t())->gen();exit(0);}\n  FOR(i,1,argc-1)if(argv[i]==string(\"brute\")){(solver=new solver_t())->brute();exit(0);}\n  ios::sync_with_stdio(false),cin.tie(0);\n  cout.setf(ios::fixed),cout.precision(10);int t;if(MULTI||GCJ)cin>>t;else t=1;\n  FOR(i,1,t){if(DEBUG)cerr<<__LINE__<<\" \"<<i<<endl;if(GCJ)cout<<\"Case #\"<<i<<\": \";\n    solver = new solver_t();\n    solver->solve();\n  }return 0;\n}\n\n"
  },
  {
    "language": "C++",
    "code": "// SUBLIME HAX\n\t/*nope\n\tcat\n\t// sixteen chars// sixteen chars// sixteen chars// sixteen chars// sixteen chars// sixteen chars// sixteen chars// sixteen chars// sixteen chars// sixteen chars// sixteen chars// sixteen chars// sixteen chars// sixteen chars// sixteen chars// sixteen chars// sixteen chars// sixteen chars// sixteen chars// sixteen chars// sixteen chars// sixteen chars// sixteen chars// sixteen chars// sixteen chars// sixteen chars// sixteen chars// sixteen chars// sixteen chars// sixteen chars// sixteen chars// sixteen chars// sixteen chars// sixteen chars// sixteen chars// sixteen chars// sixteen chars// sixteen chars// sixteen chars// sixteen chars// sixteen chars// sixteen chars// sixteen chars// sixteen chars// sixteen chars// sixteen chars// sixteen chars// sixteen chars// sixteen chars// sixteen chars// sixteen chars// sixteen chars// sixteen chars// sixteen chars// sixteen chars// sixteen chars// sixteen chars// sixteen chars// sixteen chars// sixteen chars// sixteen chars// sixteen chars// sixteen chars// sixteen chars\n\t// ayy\n\t// ' lamo\n\t*/\n\t#include <bits/stdc++.h>\n\tusing namespace std;\n\ttemplate<class T,class U>\n\tostream &operator<<(ostream &os,const pair<T,U> &x) {\n\t\treturn os<<\"(\"<<x.first<<\",\"<<x.second<<\")\";\n\t}\n\tnamespace dbg_ns {\n\t\ttemplate<typename C>\n\t\tstruct is_iterable {\n\t\t\ttemplate<class T> static long check(...);\n\t\t\ttemplate<class T> static char check(int,\n\t\t\t\ttypename T::const_iterator = C().end());\n\t\t\tenum {\n\t\t\t\tvalue = sizeof(check<C>(0)) == sizeof(char),\n\t\t\t\tneg_value = sizeof(check<C>(0)) != sizeof(char)\n\t\t\t};\n\t\t};\n\t\ttemplate<class T> ostream &_out_str(ostream &os,const T &x) {\n\t\t\treturn os<<'\"'<<x<<'\"';\n\t\t}\n\t\ttemplate<class T> ostream &_dbg2_5(ostream &,const T &);\n\t\ttemplate<bool B,typename T=void> using eit=typename enable_if<B,T>::type;\n\t\ttemplate<class T>\n\t\tinline ostream &_dbg3(ostream &os,eit<is_iterable<T>::neg_value,const T> &x) {\n\t\t\treturn os<<x;\n\t\t}\n\t\ttemplate<class T>\n\t\tinline ostream &_dbg3(ostream &os,eit<is_iterable<T>::value,const T> &V) {\n\t\t\tos<<\"{\";\n\t\t\tbool ff=0;\n\t\t\tfor(const auto &E:V) _dbg2_5(ff?os<<\",\":os,E), ff=1;\n\t\t\treturn os<<\"}\";\n\t\t}\n\t\ttemplate<>\n\t\tinline ostream &_dbg3<string>(ostream &os,const string &x) {\n\t\t\treturn _out_str(os,x);\n\t\t}\n\t\ttemplate<>\n\t\tinline ostream &_dbg3<const char *>(ostream &os,const char *const &x) {\n\t\t\treturn _out_str(os,x);\n\t\t}\n\t\ttemplate<class T> inline ostream &_dbg2_5(ostream &os,const T &x) {\n\t\t\treturn _dbg3<T>(os,x);\n\t\t}\n\t\ttemplate<class T,typename... Args> ostream &_dbg2(ostream &os,vector<string>::iterator nm,const T &x,Args&&... args);\n\t\tinline ostream &_dbg2(ostream &os,vector<string>::iterator) { return os; }\n\t\ttemplate<typename... Args>\n\t\tinline ostream &_dbg2(ostream &os,vector<string>::iterator nm,const char *x,Args&&... args) {\n\t\t\treturn _dbg2(_dbg3<const char *>(os<<\"  \",x),nm+1,args...);\n\t\t}\n\t\ttemplate<class T,typename... Args>\n\t\tinline ostream &_dbg2(ostream &os,vector<string>::iterator nm,const T &x,Args&&... args) {\n\t\t\treturn _dbg2(_dbg3<T>(os<<\"  \"<<*nm<<\"=\",x),nm+1,args...);\n\t\t}\n\t\tvector<string> split(string s) {\n\t\t\tvector<string> Z;\n\t\t\tstring z=\"\";\n\t\t\ts+=',';\n\t\t\tint dep=0;\n\t\t\tfor(char c:s) {\n\t\t\t\tif(c==',' && !dep) Z.push_back(z),z=\"\";\n\t\t\t\telse z+=c;\n\t\t\t\tif(c=='(') ++dep;\n\t\t\t\tif(c==')') --dep;\n\t\t\t}\n\t\t\treturn Z;\n\t\t}\n\t\ttemplate<typename... Args> inline ostream &_dbg1(int ln,const string &nm,Args&&... args) {\n\t\t\tauto nms=split(nm);\n\t\t\treturn _dbg2(cerr<<\"L\"<<ln<<\":\",nms.begin(),args...)<<endl;\n\t\t}\n\t}\n\t#define dbg(...) dbg_ns::_dbg1(__LINE__,#__VA_ARGS__,__VA_ARGS__)\n\t#define sz(x) (int(x.size()))\n\t#define eprintf(...) fprintf(stderr,__VA_ARGS__)\n\t#define fi first\n\t#define se second\n\t#define pb push_back\n// END SUBLIME HAX\n// #include <bits/extc++.h>\n// using namespace __gnu_pbds;\ntypedef unsigned long long ull;\ntypedef long long ll;\ntypedef long double ld; //CARE\ntypedef complex<ld> pt;\nconst ld eps=(ld)1e-8;\nconst ld tau=2*(ld)acosl(-1);\nconst int inf=1e9+99;\nconst ll linf=1e18+99;\nconst int P=1e9+7;\n\n\n// #define int __int128\n// #define ll __int128\n\nint32_t H,W;\nint32_t n;\n\nconst int32_t N=8192;\nconst int NN=8070;\nint D[NN][NN];\nvector<pair<int,int> > adj[N];\nvector<pair<int,int> > rels;\nvector<int> relx,rely;\nset<pair<int,int> > bads;\nset<int> bx,by;\nvector<pair<int,int> > bandx,bandy;\n\nmap<int,int> ddec[1<<20];\n\nint dec(int x,int y) {\n\treturn ddec[x].count(y) ? ddec[x][y] : -1;\n\tauto it=lower_bound(rels.begin(),rels.end(),pair<int,int>(x,y));\n\tif(it!=rels.end() && it->fi==x && it->se==y)\n\t\treturn int(it-rels.begin());\n\treturn -1;\n}\n\n\nint sL(int x) { // 0+..+x-1\n\treturn int(1LL*x*(x-1)/2%P);\n}\nint ww(int x) {\n\tstatic bool init=0;\n\tstatic int Z[1<<20];\n\tassert(1<=x && x<(1<<20));\n\tif(!init) {\n\t\tinit=1;\n\t\tassert(!sL(0) && !sL(1));\n\t\tfor(int i=1;i<(1<<20);i++) {\n\t\t\tZ[i]=sL(i)+Z[i-1];\n\t\t\tif(Z[i]>=P) Z[i]-=P;\n\t\t}\n\t}\n\treturn Z[x];\n}\nint qq(int x,int y) {\n\treturn int((1LL*x*sL(y)+1LL*y*sL(x))%P);\n}\ninline int _w(const pair<int,int> &P) {\n\tif(~P.se) return P.se-P.fi+1;\n\treturn 1;\n}\nint g_same(int w,int h) {\n\t// dbg(\"SS\",w,h);\n\t// dbg(ww(h));\n\treturn int((1LL*w*w%P*ww(h) + 1LL*h*h%P*ww(w))%P);\n}\nint g_same(int w,const pair<int,int> &X,const pair<int,int> &_X) {\n\tif(X==_X) return g_same(w,_w(X));\n\tint d0;\n\tint a= X.fi,b=~ X.se? X.se: X.fi;\n\tint c=_X.fi,d=~_X.se?_X.se:_X.fi;\n\tassert(a<=b && c<=d);\n\tif(b<c) d0=c-b; else\n\tif(d<a) d0=a-d; else\n\tassert(0);\n\tint h1=_w(X);\n\tint h2=_w(_X);\n\n\tll ZZ=d0;\n\tZZ=ZZ*w%P*h1%P*w%P*h2%P;\n\tZZ+=1LL*h1*h2%P*ww(w)*2; //dbg(h1,h2,w,ww(w));\n\tZZ+=1LL*w*w%P*qq(h1,h2);\n\t// dbg(\"HIT\",w,h1,h2,ZZ,d0);\n\treturn int(ZZ%P);\n}\ninline int close(const pair<int,int> &X,int x) {\n\tif(!~X.se) return X.fi;\n\tif(x<X.fi) return X.fi;\n\tif(x>X.se) return X.se;\n\tassert(0);\n}\nint g(const pair<int,int> &X,const pair<int,int> &Y,\n\tconst pair<int,int> &_X,const pair<int,int> &_Y) {\n\n\tif(X==_X && Y==_Y && !~X.se && !~Y.se) return 0;\n\n\tif(X==_X && ~X.se) return g_same(_w(X),Y,_Y);\n\tif(Y==_Y && ~Y.se) return g_same(_w(Y),X,_X);\n\n\tint  Cx=_w(X);\n\tint  Cy=_w(Y);\n\tint _Cx=_w(_X);\n\tint _Cy=_w(_Y);\n\tint CCx=int(1LL*Cx*_Cx%P);\n\tint CCy=int(1LL*Cy*_Cy%P);\n\n\tint u=dec(close(X,_X.fi),close(Y,_Y.fi)); assert(~u);\n\tint v=dec(close(_X,X.fi),close(_Y,Y.fi)); assert(~v);\n\n\tll ZZ=D[u][v]; assert(ZZ<inf);\n\n\tZZ=ZZ*CCx%P*CCy;\n\t// dbg(C,_C,ZZ,ZZ%P);\n\n\tZZ+=1LL*CCx*qq(Cy,_Cy);\n\tZZ+=1LL*CCy*qq(Cx,_Cx);\n\n\t// dbg(ZZ,ZZ%P);\n\n\treturn int(ZZ%P);\n}\n\n\ntemplate<class T> struct PQ {\n\tint n=0;\n\tT A[N*4];\n\tvoid push(const T &x) {\n\t\tint i=++n;\n\t\tA[i]=x;\n\t\tfor(;i>1 && A[i>>1]<A[i];) swap(A[i>>1],A[i]), i>>=1;\n\t}\n\tT top() const { return A[1]; }\n\tvoid pop() {\n\t\tassert(n>=1);\n\t\tif(n>1) swap(A[1],A[n]);\n\t\tn--;\n\t\tint i=1;\n\t\tfor(;;) {\n\t\t\tint j=i<<1;\n\t\t\tif(j>n) break;\n\t\t\tif(j==n) {\n\t\t\t\tif(A[j]>A[i]) swap(A[j],A[i]);\n\t\t\t\tbreak;\n\t\t\t}\n\t\t\tif(A[j+1]>A[j]) ++j;\n\t\t\tif(A[j]>A[i]) swap(A[j],A[i]);\n\t\t\telse break;\n\t\t\ti=j;\n\t\t}\n\t}\n\tint size() const {\n\t\treturn n;\n\t}\n};\n// PQ<pair<int,int> > pq;\n// priority_queue<pair<int,int> > pq;\n// queue<pair<int,int> > pq;\nint pq[N];\nbool inq[N];\n#define top front\n\nvoid dijk(int src,int *DD) {\n\t// for(int u=0;u<n;u++) DD[u]=inf;\n\t// for(int u=0;u<=src;u++) DD[u]=D[u][src], pq.push({-DD[u],u});\n\t// for(int u=src+1;u<n;u++) DD[u]=inf;\n\t// if(src) for(int u=src+1;u<n;u++) DD[u]=D[src-1][u]+DD[src-1], pq.push({-DD[u],u});\n\tint pn=0;\n\tfor(int u=0;u<=src;u++) DD[u]=D[u][src], pq[pn++]=u;\n\tfor(int u=src+1;u<n;u++) DD[u]=inf;\n\tif(src) for(int u=src+1;u<n;u++) DD[u]=D[src-1][u]+DD[src-1], pq[pn++]=u;\n\n\tint ii=0;\n\tfor(int i=0;i<n;i++) inq[i]=0;\n\tfor(int i=0;i<pn;i++) inq[pq[i]]=1;\n\t// DD[src]=0;\n\t// pq.push({0,src});\n\t// for(;sz(pq);) {\n\tfor(;ii<pn;) {\n\t\t// auto P=pq.top();\n\t\t// int u=P.se;\n\t\t// int d=-P.fi;\n\t\t// pq.pop();\n\t\t// if(DD[u]<d) continue;\n\t\tint u=pq[(ii++)&(N-1)];\n\t\tinq[u]=0;\n\t\tint d=DD[u];\n\t\tfor(const auto &P:adj[u]) if(d+P.se<DD[P.fi]) {\n\t\t\tDD[P.fi]=d+P.se;\n\t\t\t// pq.push({-DD[P.fi],P.fi});\n\t\t\tif(!inq[P.fi]) pq[(pn++)&(N-1)]=P.fi;\n\t\t}\n\t}\n}\n\n\nint32_t main() {\n\t// for(int i=1;i<6;i++) dbg(i,ww(i));\n\tcin>>H>>W>>n;\n\tfor(int i=0;i<n;i++) {\n\t\tint32_t x,y; cin>>x>>y;\n\t\tbads.insert({x,y});\n\t\tbx.insert(x), by.insert(y);\n\t}\n\tfor(int _x:bx) for(int x=_x-1;x<=_x+1;x++)\n\t\tif(!sz(relx) || x>relx.back()) if(0<=x && x<H)\n\t\t\trelx.pb(x);\n\tfor(int _y:by) for(int y=_y-1;y<=_y+1;y++)\n\t\tif(!sz(rely) || y>rely.back()) if(0<=y && y<W)\n\t\t\trely.pb(y);\n\n\tfor(int x:relx) for(int y:rely) if(!bads.count({x,y})) rels.pb({x,y});\n\tsort(rels.begin(),rels.end());\n\tn=sz(rels);\n\tassert(n<NN);\n\tfor(int i=0;i<n;i++) ddec[rels[i].fi][rels[i].se]=i;\n\n\tfor(int i=1;i<sz(relx);i++) for(int y:rely) {\n\t\tint u=dec(relx[i-1],y);\n\t\tint v=dec(relx[i],y);\n\t\tint d=relx[i]-relx[i-1];\n\t\tif(~u && ~v) {\n\t\t\tadj[u].pb({v,d});\n\t\t\tadj[v].pb({u,d});\n\t\t}\n\t}\n\tfor(int i=1;i<sz(rely);i++) for(int x:relx) {\n\t\tint u=dec(x,rely[i-1]);\n\t\tint v=dec(x,rely[i]);\n\t\tint d=rely[i]-rely[i-1];\n\t\tif(~u && ~v) {\n\t\t\tadj[u].pb({v,d});\n\t\t\tadj[v].pb({u,d});\n\t\t}\n\t}\n\n\tfor(int i=0;i<n;i++) dijk(i,D[i]);\n\t// for(int i=0;i<n;i++) for(int j=0;j<n;j++) dbg(rels[i],rels[j],D[i][j]);\n\n\t{\n\t\tint pr=-1;\n\t\tfor(int x:bx) {\n\t\t\tif(x-1>pr) bandx.pb({pr+1,x-1});\n\t\t\tbandx.pb({x,-1});\n\t\t\tpr=x;\n\t\t}\n\t\tif(H-1>pr) bandx.pb({pr+1,H-1});\n\t}\n\t{\n\t\tint pr=-1;\n\t\tfor(int y:by) {\n\t\t\tif(y-1>pr) bandy.pb({pr+1,y-1});\n\t\t\tbandy.pb({y,-1});\n\t\t\tpr=y;\n\t\t}\n\t\tif(W-1>pr) bandy.pb({pr+1,W-1});\n\t}\n\n\tassert(sz(bandx)<=61 && sz(bandy)<=61);\n\n\tll Z=0;\n\tfor(const auto &BX:bandx) for(const auto &BY:bandy) {\n\t\tif(bads.count({BX.fi,BY.fi})) continue;\n\t\tfor(const auto &_BX:bandx) for(const auto &_BY:bandy) {\n\t\t\tif(BX>_BX) continue;\n\t\t\tif(BX==_BX && BY>_BY) continue;\n\t\t\tif(!~_BX.se && !~_BY.se && bads.count({_BX.fi,_BY.fi})) continue;\n\t\t\tint w=g(BX,BY,_BX,_BY);\n\t\t\tZ+=w;\n\t\t}\n\t}\n\tcout<<int32_t(Z%P)<<endl;\n}\n\n\n\n\n\n\n\n\n\n\n\n"
  },
  {
    "language": "C++",
    "code": "#include<bits/stdc++.h>\n#define sqr(x) ((x)*(x))\n#define ll long long\n#define ull unsigned long long\n#define ui unsigned int\n#define ld long double\n#define vi vector<int>\n#define all(a) a.begin(),a.end()\n#define HEAP(...) priority_queue<__VA_ARGS__ >\n#define heap(...) priority_queue<__VA_ARGS__,vector<__VA_ARGS__ >,greater<__VA_ARGS__ > > \n#define pii pair<int,int> \n#define pb push_back\n#define mp make_pair\n#define debuge cerr<<\"isok\"<<endl\n#define debug(x) cerr<<#x<<\"=\"<<x<<endl\n#define dprintf(...) fprintf(stderr,__VA_ARGS__)\n#define SS second\n#define FF first\n#define ls (k<<1)\n#define rs (k<<1|1)\n#define clr(a,x) memset(a,x,sizeof(a))\n#define cpy(a,x) memcpy(a,x,sizeof(a))\n#define file(x) freopen(x\".in\",\"r\",stdin),freopen(x\".out\",\"w\",stdout)\n#define SZ(x) ((int)x.size())\nusing namespace std;\ntemplate<class T> inline void gmin(T &x,const T &y){x=x>y?y:x;}\ntemplate<class T> inline void gmax(T &x,const T &y){x=x<y?y:x;}\ntemplate<class T> inline bool Gmin(T &x,const T &y){return x>y?x=y,1:0;}\ntemplate<class T> inline bool Gmax(T &x,const T &y){return x<y?x=y,1:0;}\nconst int BufferSize=1<<16;\nchar buffer[BufferSize],*Bufferhead,*Buffertail;\nbool Terminal;\ninline char Getchar(){\n\tif(Bufferhead==Buffertail){\n\t\tint l=fread(buffer,1,BufferSize,stdin);\n\t\tif(!l){Terminal=1;return 0;}\n\t\tBuffertail=(Bufferhead=buffer)+l;\n\t}\n\treturn *Bufferhead++;\n}\ntemplate<class T>inline bool read(T &x){\n\tx=0;char c=Getchar(),rev=0;\n\twhile(c<'0'||c>'9'){rev|=c=='-';c=Getchar();if(Terminal)return 0;}\n\twhile(c>='0'&&c<='9') x=x*10+c-'0',c=Getchar();\n\tif(c=='.'){\n\t\tc=Getchar();double t=0.1;\n\t\twhile(c>='0'&&c<='9') x=x+(c-'0')*t,c=Getchar(),t=t/10;\n\t}\n\tx=rev?-x:x;\n\treturn 1;\n}\ntemplate<class T1,class T2> inline bool read(T1 &x,T2 &y){return read(x)&read(y);}\ntemplate<class T1,class T2,class T3> inline bool read(T1 &x,T2 &y,T3 &z){return read(x)&read(y)&read(z);}\ntemplate<class T1,class T2,class T3,class T4> inline bool read(T1 &x,T2 &y,T3 &z,T4 &w){return read(x)&read(y)&read(z)&read(w);}\ninline bool reads(char *x){\n\tchar c=Getchar();\n\twhile(c<33||c>126){c=Getchar();if(Terminal)return 0;}\n\twhile(c>=33&&c<=126) (*x++)=c,c=Getchar();\n\t*x=0;return 1;\n}\ntemplate<class T>inline void print(T x,const char c='\\n'){\n\tif(!x){putchar('0');putchar(c);return;}\n\tif(x<0) putchar('-'),x=-x;\n\tint m=0,a[20];\n\twhile(x) a[m++]=x%10,x/=10;\n\twhile(m--) putchar(a[m]+'0');\n\tputchar(c);\n}\n//--------------------------------head---------------------------------------------\n\nconst int inf=0x3f3f3f3f;\nconst int N=105,M=100005,mod=1e9+7;\ntemplate<class T,class S> inline void ch(T &x,const S y){x=(x+y)%mod;}\ninline int exp(int x,int y,const int mod=::mod){\n\tint ans=1;\n\twhile(y){\n\t\tif(y&1) ans=(ll)ans*x%mod;\n\t\tx=(ll)x*x%mod;y>>=1;\n\t}return ans;\n}\n\nint h,w,H,W,n,ans,xx[N],yy[N],x[N],y[N];\nbool fake[N][N];\n\ninline void bfs(int sx,int sy,int tag){\n\tstatic const int u[4][2]={1,0,0,1,-1,0,0,-1};\n\tstatic int st[N][N];clr(st,-1);\n\tqueue<pii> q;\n\tq.push(mp(sx,sy));st[sx][sy]=0;\n\twhile(!q.empty()){\n\t\tint x=q.front().FF,y=q.front().SS;q.pop();\n\t\tfor(int i=0;i<4;i++){\n\t\t\tint tx=x+u[i][0],ty=y+u[i][1];\n\t\t\tif(tx<1||ty<1||tx>H||ty>W||fake[tx][ty]||~st[tx][ty]) continue;\n\t\t\tst[tx][ty]=st[x][y]+1;\n\t\t\tq.push(mp(tx,ty));\n\t\t\tch(ans,(ll)st[tx][ty]*tag*(xx[tx+1]-xx[tx])%mod*(yy[ty+1]-yy[ty]));\n\t\t}\n\t}\n}\n\nint main(){\n#ifdef rqgao2014\n\tassert(freopen(\"input.txt\",\"r\",stdin));\n#endif\n\tscanf(\"%d%d%d\",&h,&w,&n);\n\tfor(int i=1;i<=n;i++){\n\t\tscanf(\"%d%d\",&x[i],&y[i]);\n\t\tx[i]++;y[i]++;\n\t\txx[i]=x[i];\n\t\tyy[i]=y[i];\n\t}\n\tsort(xx+1,xx+n+1);sort(yy+1,yy+n+1);\n\txx[n+1]=h+1;yy[n+1]=w+1;\n\tfor(int i=0;i<=n;i++){\n\t\tfor(int j=xx[i]+1;j<xx[i+1]-1;j++)\n\t\t\tch(ans,(ll)(((ll)w*j-i)%mod)*(((ll)w*(h-j)-n+i)%mod));\n\t\tfor(int j=yy[i]+1;j<yy[i+1]-1;j++)\n\t\t\tch(ans,(ll)(((ll)h*j-i)%mod)*(((ll)h*(w-j)-n+i)%mod));\n\t}\n\tH=n*2,W=n*2;\n\tfor(int i=1;i<=n;i++)\n\t\txx[i+n]=xx[i]+1,yy[i+n]=yy[i]+1;\n\txx[++H]=h+1;xx[++H]=1;\n\tyy[++W]=w+1;yy[++W]=1;\n\tsort(xx+1,xx+H+1);sort(yy+1,yy+W+1);\n\tH=unique(xx+1,xx+H+1)-xx-1;\n\tW=unique(yy+1,yy+W+1)-yy-1;\n\tH--;W--;\n\tans=ans*2%mod;\n\tfor(int i=1;i<=n;i++){\n\t\tint tx=lower_bound(xx+1,xx+H+1,x[i])-xx;\n\t\tint ty=lower_bound(yy+1,yy+W+1,y[i])-yy;\n\t\tfake[tx][ty]=1;\n\t}\n\tfor(int i=1;i<=H;i++)\n\t\tfor(int j=1;j<=W;j++)\n\t\t\tif(!fake[i][j]) bfs(i,j,(ll)(xx[i+1]-xx[i])*(yy[j+1]-yy[j])%mod);\n\tans=(ll)ans*(mod+1)/2%mod;\n\tprintf(\"%d\\n\",ans);\n\treturn 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include <cstdio>\n#include <cstring>\n#include <queue>\n#include <utility>\n\nconst int N = 30;\nconst int N2 = N * 2 + 1;\nconst int M = 1000000;\nconst int MOD = (int)1e9 + 7;\nconst int DELTA_X[] = {-1, 0, 0, 1};\nconst int DELTA_Y[] = {0, -1, 1, 0};\n\nvoid update(int& x, int a)\n{\n    x += a;\n    if (x >= MOD) {\n        x -= MOD;\n    }\n}\n\nint extra(int* c, int* id, int* sz, int w, int h, int n)\n{\n    int up = h - c[0], down = (1LL * w * h - n - up) % MOD, result = id[0] = 0;\n    sz[0] = 1;\n    for (int i = 1; i < w; ++ i) {\n        id[i] = id[i - 1];\n        if (!c[i - 1] && !c[i]) {\n            update(result, 1LL * up * down % MOD);\n        } else {\n            id[i] ++;\n        }\n        sz[id[i]] ++;\n        update(up, h - c[i]);\n        update(down, MOD - h + c[i]);\n    }\n    return result;\n}\n\nint h, w, n, x[N], y[N], cx[M], cy[M], idx[M], idy[M], szx[N2], szy[N2], blk[N2][N2], dis[N2][N2];\n\nint sz(int x, int y)\n{\n    return 1LL * szx[x] * szy[y] % MOD;\n}\n\nint main()\n{\n#ifdef LOCAL_JUDGE\n    freopen(\"I.in\", \"r\", stdin);\n#endif\n    scanf(\"%d%d%d\", &h, &w, &n);\n    for (int i = 0; i < n; ++ i) {\n        scanf(\"%d%d\", x + i, y + i);\n        cx[x[i]] ++, cy[y[i]] ++;\n    }\n    int result = (2LL * (extra(cx, idx, szx, h, w, n) + extra(cy, idy, szy, w, h, n))) % MOD;\n    for (int i = 0; i < n; ++ i) {\n        blk[idx[x[i]]][idy[y[i]]] = true;\n    }\n    for (int sx = 0; sx <= idx[h - 1]; ++ sx) {\n        for (int sy = 0; sy <= idy[w - 1]; ++ sy) {\n            if (!blk[sx][sy]) {\n                memset(dis, -1, sizeof(dis));\n                dis[sx][sy] = 0;\n                std::queue<std::pair<int, int>> q;\n                q.emplace(sx, sy);\n                while (!q.empty()) {\n                    int x = q.front().first;\n                    int y = q.front().second;\n                    q.pop();\n                    update(result, 1LL * sz(sx, sy) * sz(x, y) % MOD * dis[x][y] % MOD);\n                    for (int k = 0; k < 4; ++ k) {\n                        int xx = x + DELTA_X[k];\n                        int yy = y + DELTA_Y[k];\n                        if (0 <= xx && xx <= idx[h - 1] && 0 <= yy && yy <= idy[w - 1] && !blk[xx][yy] && !~dis[xx][yy]) {\n                            dis[xx][yy] = dis[x][y] + 1;\n                            q.emplace(xx, yy);\n                        }\n                    }\n                }\n            }\n        }\n    }\n    printf(\"%d\\n\", static_cast<int>(500000004LL * result % MOD));\n}\n"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\nusing namespace std;\n#define int long long\n#define p (int)(1e9 + 7)\n\nint MOD(int a){\n\treturn a % p;\n}\n\nint h, w;\nconst int inv2 = 500000004, inv6 = 166666668;\n\nint calc(int dis, int x1, int dx1, int x2, int dx2, int y1, int dy1, int y2, int dy2){\n\tif(x2 < x1){\n\t\treturn calc(dis, x2, dx2, x1, dx1, y2, dy2, y1, dy1);\n\t}\n\telse if(y2 < y1){\n\t\treturn calc(dis + dx2 - dx1, x1, dx2, x2 + dx2 - dx1, dx1, y2, dy2, y1, dy1);\n\t}\n\telse if(x1 == x2){\n\t\treturn calc(dis, y1, dy1, y2, dy2, x1, dx1, x2, dx2);\n\t}\n\tif(y1 == y2){\n\t\tif(dy1 == 1){\n\t\t\treturn MOD(inv2 * MOD(MOD(dx1 * dx2) * (2 * dis + (dx2 - dx1))));\n\t\t}\n\t\telse{\n\t\t\treturn MOD(inv6 * MOD(MOD(dx1 * dx2 * dy1) * MOD(3 * dy1 * (2 * (x2 - x1) + (dx2 - dx1)) + (2 * (dy1 - 1) * (dy1 + 1)))));\n\t\t}\n\t}\n\telse{\n\t\treturn MOD(inv2 * MOD(MOD(MOD(dx1 * dx2) * MOD(dy1 * dy2)) * (2 * dis + (dx2 - dx1) + (dy2 - dy1))));\n\t}\n}\n\nsigned main(){\n\tint H, W, N, i, j, k, l;\n\tscanf(\"%lld%lld\", &H, &W);\n\tscanf(\"%lld\", &N);\n\tvector<int> x_sub(N), y_sub(N), x(0), y(0);\n\tfor(i = 0; i < N; i++){\n\t\tscanf(\"%lld%lld\", &x_sub[i], &y_sub[i]);\n\t\tx.push_back(x_sub[i]);\n\t\tx.push_back(x_sub[i] + 1);\n\t\tx.push_back(max(0ll, x_sub[i] - 1));\n\t\ty.push_back(y_sub[i]);\n\t\ty.push_back(y_sub[i] + 1);\n\t\ty.push_back(max(0ll, y_sub[i] - 1));\n\t}\n\tx.push_back(0);\n\tx.push_back(H);\n\ty.push_back(0);\n\ty.push_back(W);\n\tsort(x.begin(), x.end());\n\tsort(y.begin(), y.end());\n\tfor(i = 1, j = 1; j < x.size(); j++){\n\t\tif(x[j - 1] < x[j]){\n\t\t\tx[i] = x[j];\n\t\t\ti++;\n\t\t}\n\t}\n\th = i - 1;\n\tfor(i = 1, j = 1; j < y.size(); j++){\n\t\tif(y[j - 1] < y[j]){\n\t\t\ty[i] = y[j];\n\t\t\ti++;\n\t\t}\n\t}\n\tw = i - 1;\n\tvector<int> dx(h), dy(w);\n\tfor(i = 0; i < h; i++){\n\t\tdx[i] = x[i + 1] - x[i];\n\t}\n\tfor(i = 0; i < w; i++){\n\t\tdy[i] = y[i + 1] - y[i];\n\t}\n\tvector<vector<char>> A(h, vector<char>(w, '.'));\n\tfor(i = 0; i < h; i++){\n\t\tfor(j = 0; j < w; j++){\n\t\t\tfor(k = 0; k < N; k++){\n\t\t\t\tif(x[i] == x_sub[k] && y[j] == y_sub[k]){\n\t\t\t\t\tA[i][j] = '#';\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t}\n\tqueue<pair<pair<int, int>, int>> q;\n\tvector<vector<int>> dis(h, vector<int>(w, 1000000000));\n\tint ans = 0;\n\tfor(i = 0; i < h; i++){\n\t\tfor(j = (i % 2) * (w - 1); 0 <= j && j < w; j = j + 1 - 2 * (i % 2)){\n\t\t\tif(A[i][j] == '#'){\n\t\t\t\tcontinue;\n\t\t\t}\n\t\t\tint sub = MOD(inv6 * MOD(MOD(dx[i] * dy[j]) * MOD((dx[i] + dy[j]) * MOD(dx[i] * dy[j] - 1))));\n\t\t\tans = MOD(ans + sub);\n\t\t\tint old_dis = dis[i][j];\n\t\t\tfor(k = 0; k < h; k++){\n\t\t\t\tfor(l = 0; l < w; l++){\n\t\t\t\t\tdis[k][l] += old_dis;\n\t\t\t\t}\n\t\t\t}\n\t\t\tq.push(pair<pair<int, int>, int>(pair<int, int>(i, j), 0));\n\t\t\twhile(q.size() > 0){\n\t\t\t\tk = q.front().first.first;\n\t\t\t\tl = q.front().first.second;\n\t\t\t\tint d = q.front().second;\n\t\t\t\tq.pop();\n\t\t\t\tif(A[k][l] == '#' || dis[k][l] <= d){\n\t\t\t\t\tcontinue;\n\t\t\t\t}\n\t\t\t\tdis[k][l] = d;\n\t\t\t\tif(l < w - 1){\n\t\t\t\t\tq.push(pair<pair<int, int>, int>(pair<int, int>(k + 0, l + 1), d + dy[l]));\n\t\t\t\t}\n\t\t\t\tif(k < h - 1){\n\t\t\t\t\tq.push(pair<pair<int, int>, int>(pair<int, int>(k + 1, l + 0), d + dx[k]));\n\t\t\t\t}\n\t\t\t\tif(l > 0){\n\t\t\t\t\tq.push(pair<pair<int, int>, int>(pair<int, int>(k + 0, l - 1), d + dy[l - 1]));\n\t\t\t\t}\n\t\t\t\tif(k > 0){\n\t\t\t\t\tq.push(pair<pair<int, int>, int>(pair<int, int>(k - 1, l + 0), d + dx[k - 1]));\n\t\t\t\t}\n\t\t\t}\n\t\t\tfor(k = 0; k < h; k++){\n\t\t\t\tfor(l = 0; l < w; l++){\n\t\t\t\t\tif(k < i || (i == k && l <= j) || A[k][l] == '#'){\n\t\t\t\t\t\tcontinue;\n\t\t\t\t\t}\n\t\t\t\t\tint res = calc(dis[k][l], x[i], dx[i], x[k], dx[k], y[j], dy[j], y[l], dy[l]);\n\t\t\t\t\tans = MOD(ans + res);\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t}\n\tprintf(\"%lld\\n\", MOD(ans + p));\n\treturn 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\nusing namespace std;\n\nusing ll = long long;\nusing i128 = __int128_t;\n\nint main(){\n\tios_base::sync_with_stdio(0), cin.tie(0), cout.tie(0);\n\tint A, B;\n\tcin >> A >> B;\n\tint k;\n\tcin >> k;\n\tvector<pair<int,int> > pts(k);\n\tset<int> verts_x, verts_y;\n\tverts_x.insert(0); verts_x.insert(A);\n\tverts_y.insert(0); verts_y.insert(B);\n\tfor(pair<int,int>& p : pts){\n\t\tcin >> p.first >> p.second;\n\t\tfor(int j = -1; j <= 1; j++) if(p.first + j >= 0 && p.first + j <= A) verts_x.insert(p.first + j);\n\t\tfor(int j = -1; j <= 1; j++) if(p.second + j >= 0 && p.second + j <= B) verts_y.insert(p.second + j);\n\t}\n\tvector<int> loc_x, loc_y;\n\tfor(int x : verts_x) loc_x.push_back(x);\n\tfor(int y : verts_y) loc_y.push_back(y);\n\tint num_x = (int)loc_x.size() - 1;\n\tint num_y = (int)loc_y.size() - 1;\n\tvector<vector<bool> > occ(num_x, vector<bool>(num_y, false));\n\tfor(int i = 0; i < num_x; i++){\n\t\tfor(int j = 0; j < num_y; j++){\n\t\t\tfor(pair<int,int> p : pts){\n\t\t\t\tif(loc_x[i] == p.first && loc_y[j] == p.second) occ[i][j] = true;\n\t\t\t}\n\t\t}\n\t}\n\n\ti128 ans = 0;\n\tvector<int> dx = {1, 0, -1, 0};\n\tvector<int> dy = {0, 1, 0, -1};\n\tfor(int x = 0; x < num_x; x++){\n\t\tfor(int y = 0; y < num_y; y++){\n\t\t\tif(occ[x][y]) continue;\n\t\t\tvector<vector<bool> > vis(num_x, vector<bool>(num_y, false));\n\t\t\tvector<vector<int> > dist(num_x, vector<int>(num_y, 1e9));\n\t\t\tpriority_queue<pair<int, pair<int,int> > > s;\n\t\t\tdist[x][y] = 0;\n\t\t\ts.push({-dist[x][y], {x, y}});\n\t\t\twhile(!s.empty()){\n\t\t\t\tint cx = s.top().second.first;\n\t\t\t\tint cy = s.top().second.second;\n\t\t\t\ts.pop();\n\t\t\t\tif(vis[cx][cy]) continue;\n\t\t\t\tvis[cx][cy] = true;\n\t\t\t\tfor(int d = 0; d < 4; d++){\n\t\t\t\t\tint nx = cx + dx[d];\n\t\t\t\t\tint ny = cy + dy[d];\n\t\t\t\t\tif(nx < 0 || ny < 0 || nx >= num_x || ny >= num_y) continue;\n\t\t\t\t\tif(occ[nx][ny]) continue;\n\t\t\t\t\tint new_dist = dist[cx][cy] + abs(loc_x[cx] - loc_x[nx]) + abs(loc_y[cy] - loc_y[ny]);\n\t\t\t\t\tif(new_dist < dist[nx][ny]){\n\t\t\t\t\t\tdist[nx][ny] = new_dist;\n\t\t\t\t\t\ts.push({-dist[nx][ny], {nx, ny}});\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t}\n\t\t\tfor(int nx = 0; nx < num_x; nx++){\n\t\t\t\tfor(int ny = 0; ny < num_y; ny++){\n\t\t\t\t\tif(occ[nx][ny]) continue;\n\t\t\t\t\ti128 dx0 = loc_x[x + 1] - loc_x[x];\n\t\t\t\t\ti128 dy0 = loc_y[y + 1] - loc_y[y];\n\t\t\t\t\ti128 dx1 = loc_x[nx + 1] - loc_x[nx];\n\t\t\t\t\ti128 dy1 = loc_y[ny + 1] - loc_y[ny];\n\t\t\t\t\tif((x == nx && dx0 > 1) || (y == ny && dy0 > 1)){\n\t\t\t\t\t\t// can travel by manhattan distance\n\t\t\t\t\t\ti128 xdist = (x == nx) ? ((dx0 * dx0 * dx0 - dx0) / 3) : \n\t\t\t\t\t\t\tdx0 * dx1 * abs(loc_x[nx + 1] + loc_x[nx] - loc_x[x + 1] - loc_x[x]) / 2;\n\t\t\t\t\t\txdist *= dy0 * dy1;\n\t\t\t\t\t\ti128 ydist = (y == ny) ? ((dy0 * dy0 * dy0 - dy0) / 3) : \n\t\t\t\t\t\t\tdy0 * dy1 * abs(loc_y[ny + 1] + loc_y[ny] - loc_y[y + 1] - loc_y[y]) / 2;\n\t\t\t\t\t\tydist *= dx0 * dx1;\n\t\t\t\t\t\tans += xdist + ydist;\n\t\t\t\t\t} else {\n\t\t\t\t\t\ti128 twice_avg = 2 * i128(dist[nx][ny])\n\t\t\t\t\t\t\t+ abs(loc_x[nx + 1] + loc_x[nx] - loc_x[x + 1] - loc_x[x]) - 2 * abs(loc_x[nx] - loc_x[x])\n\t\t\t\t\t\t\t+ abs(loc_y[ny + 1] + loc_y[ny] - loc_y[y + 1] - loc_y[y]) - 2 * abs(loc_y[ny] - loc_y[y]);\n\t\t\t\t\t\tans += twice_avg * dx0 * dy0 * dx1 * dy1 / 2;\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t}\n\tll ans_mod = (ans / 2) % (int(1e9) + 7);\n\tcout << ans_mod << '\\n';\n}\n"
  },
  {
    "language": "C++",
    "code": "#include <algorithm>  \n#include <iostream>  \n#include <sstream>  \n#include <string>  \n#include <cstring>\n#include <vector>  \n#include <queue>  \n#include <set>  \n#include <map>  \n#include <cstdio>  \n#include <cstdlib>  \n#include <cctype>  \n#include <cmath>  \n#include <list>  \n#include <cassert>\n#include <ctime>\n#include <climits>\nusing namespace std;  \n\n#define PB push_back  \n#define MP make_pair  \n#define SZ(v) ((int)(v).size())  \n#define FOR(i,a,b) for(int i=(a);i<(b);++i)  \n#define REP(i,n) FOR(i,0,n)  \n#define FORE(i,a,b) for(int i=(a);i<=(b);++i)  \n#define REPE(i,n) FORE(i,0,n)  \n#define FORSZ(i,a,v) FOR(i,a,SZ(v))  \n#define REPSZ(i,v) REP(i,SZ(v))  \ntypedef long long ll;\ntypedef unsigned long long ull;\nll gcd(ll a,ll b) { return b==0?a:gcd(b,a%b); }\n\nconst int MAXN=30;\nconst int MAXDIM=2*MAXN+1;\nconst int MOD=1000000007;\nconst int INV2=(MOD+1)/2;\nconst int DX[]={-1,0,+1,0},DY[]={0,+1,0,-1};\n\nint h,w,n;\nint px[MAXN],py[MAXN];\n\nint xx[2*MAXN+2],yy[2*MAXN+2],nxx,nyy;\n\nbool blocked[MAXDIM][MAXDIM];\nint cnt[MAXDIM][MAXDIM];\n\nint dst[MAXDIM][MAXDIM];\nint qx[MAXDIM*MAXDIM],qy[MAXDIM*MAXDIM],qhead,qtail;\nvoid upd(int x,int y,int d) { if(dst[x][y]!=INT_MAX) return; dst[x][y]=d; qx[qhead]=x,qy[qhead]=y,++qhead; }\n\nbool reachall;\nint solvecompressed() {\n\tint ret=0; reachall=true;\n\t//REP(x,nxx-1) { REP(y,nyy-1) printf(\"%c\",blocked[x][y]?'#':'.'); puts(\"\"); }\n\tREP(sx,nxx-1) REP(sy,nyy-1) if(!blocked[sx][sy]) {\n\t\tREP(x,nxx-1) REP(y,nyy-1) dst[x][y]=INT_MAX; qhead=qtail=0;\n\t\tupd(sx,sy,0);\n\t\twhile(qtail<qhead) {\n\t\t\tint x=qx[qtail],y=qy[qtail]; ++qtail;\n\t\t\tREP(k,4) {\n\t\t\t\tint nx=x+DX[k],ny=y+DY[k]; if(nx<0||nx>=h||ny<0||ny>=w||blocked[nx][ny]) continue;\n\t\t\t\tupd(nx,ny,dst[x][y]+1);\n\t\t\t}\n\t\t}\n\t\tREP(x,nxx-1) REP(y,nyy-1) if(!blocked[x][y]) {\n\t\t\tif(dst[x][y]==INT_MAX) reachall=false;\n\t\t\t//printf(\"(%d,%d)->(%d,%d) : %d * %d * %d\\n\",sx,sy,x,y,cnt[sx][sy],cnt[x][y],dst[x][y]);\n\t\t\tret=(ret+(ll)cnt[sx][sy]*cnt[x][y]%MOD*dst[x][y])%MOD;\n\t\t}\n\t}\n\t//printf(\"%d\\n\",ret);\n\tret=(ll)ret*INV2%MOD;\n\treturn ret;\n}\n\nint solve() {\n\tnxx=0; xx[nxx++]=0,xx[nxx++]=h; REP(i,n) xx[nxx++]=px[i],xx[nxx++]=px[i]+1; sort(xx,xx+nxx); nxx=unique(xx,xx+nxx)-xx; REP(i,n) px[i]=lower_bound(xx,xx+nxx,px[i])-xx;\n\tnyy=0; yy[nyy++]=0,yy[nyy++]=w; REP(i,n) yy[nyy++]=py[i],yy[nyy++]=py[i]+1; sort(yy,yy+nyy); nyy=unique(yy,yy+nyy)-yy; REP(i,n) py[i]=lower_bound(yy,yy+nyy,py[i])-yy;\n\n\tREP(x,nxx-1) REP(y,nyy-1) blocked[x][y]=false,cnt[x][y]=(ll)(xx[x+1]-xx[x])*(yy[y+1]-yy[y])%MOD;\n\tREP(i,n) blocked[px[i]][py[i]]=true;\n\n\tint ret=solvecompressed();\n\n\tREP(x,nxx-1) {\n\t\tint len=xx[x+1]-xx[x]; if(len==1) continue;\n\t\tint a=(ll)(len-1)*len*(len+1)/6%MOD;\n\t\tint b=(ll)w*w%MOD;\n\t\tint c=(ll)len*(len-1)/2%MOD;\n\t\tint lft=0,rgt=0; REP(cx,nxx-1) REP(cy,nyy-1) if(!blocked[cx][cy]) if(cx<x) lft=(lft+cnt[cx][cy])%MOD; else if(cx>x) rgt=(rgt+cnt[cx][cy])%MOD;\n\t\t//printf(\"cnt=%d a=%d b=%d c=%d lft=%d rgt=%d\\n\",len,a,b,c,lft,rgt);\n\t\tret=(ret+(ll)a*b)%MOD;\n\t\tret=(ret+(ll)lft*rgt%MOD*(len-1))%MOD;\n\t\tret=(ret+(ll)(lft+rgt)*c%MOD*w)%MOD;\n\t}\n\tREP(y,nyy-1) {\n\t\tint len=yy[y+1]-yy[y]; if(len==1) continue;\n\t\tint a=(ll)(len-1)*len*(len+1)/6%MOD;\n\t\tint b=(ll)h*h%MOD;\n\t\tint c=(ll)len*(len-1)/2%MOD;\n\t\tint lft=0,rgt=0; REP(cx,nxx-1) REP(cy,nyy-1) if(!blocked[cx][cy]) if(cy<y) lft=(lft+cnt[cx][cy])%MOD; else if(cy>y) rgt=(rgt+cnt[cx][cy])%MOD;\n\t\t//printf(\"cnt=%d a=%d b=%d c=%d lft=%d rgt=%d\\n\",len,a,b,c,lft,rgt);\n\t\tret=(ret+(ll)a*b)%MOD;\n\t\tret=(ret+(ll)lft*rgt%MOD*(len-1))%MOD;\n\t\tret=(ret+(ll)(lft+rgt)*c%MOD*h)%MOD;\n\t}\n\treturn ret;\n}\n\nvoid run() {\n\tscanf(\"%d%d%d\",&h,&w,&n);\n\tREP(i,n) scanf(\"%d%d\",&px[i],&py[i]);\n\tprintf(\"%d\\n\",solve());\n}\n\nint solvestupid() {\n\tnxx=0; REPE(x,h) xx[nxx++]=x;\n\tnyy=0; REPE(y,w) yy[nyy++]=y;\n\tREP(x,nxx-1) REP(y,nyy-1) blocked[x][y]=false,cnt[x][y]=(ll)(xx[x+1]-xx[x])*(yy[y+1]-yy[y])%MOD;\n\tREP(i,n) blocked[px[i]][py[i]]=true;\n\treturn solvecompressed();\n}\n\nint opx[MAXN],opy[MAXN];\nvoid stress() {\n\tREP(rep,1000) {\n\t\th=10,w=40,n=10;\n\t\tREP(i,n) opx[i]=px[i]=rand()%h,opy[i]=py[i]=rand()%w;\n\t\t//if(rep!=974) continue;\n\t\tint want=solvestupid(); if(!reachall) { printf(\",\"); continue; }\n\t\tint have=solve();\n\t\tif(have==want) { printf(\".\"); continue; }\n\t\tprintf(\"%d: have=%d want=%d\\n\",rep,have,want);\n\t\tprintf(\"%d %d %d\\n\",h,w,n); REP(i,n) printf(\"%d %d\\n\",opx[i],opy[i]);\n\t\t//solvestupid(); REP(x,nxx-1) { REP(y,nyy-1) printf(\"%c\",blocked[x][y]?'#':'.'); puts(\"\"); }\n\t}\n}\n\nint main() {\n\trun();\n\t//stress();\n\treturn 0;\n}\n"
  },
  {
    "language": "C++",
    "code": "#include<bits/stdc++.h>\nusing namespace std;\n\nconst int maxn=75;\nconst int maxm=4005;\nconst int maxs=1000005;\nconst int mod=1e9+7;\nconst int INF=0x3f3f3f3f;\nint n,m,k,kx,ky,cnt,tot,ans;\nint x[maxn],y[maxn],allx[maxn],ally[maxn];\npair<int,int>pos[maxm];\nset<pair<int,int> >bad;\nmap<pair<int,int>,int>id;\nvector<int>valr[maxs],valc[maxs];\nvector<pair<int,int> >edge[maxm]; \nint dist[maxm][maxm],ver[maxm];\nbool tmp[maxm];\npriority_queue<pair<int,int> >pq;\n\nvoid add(pair<int,int>p){\n\tif(p.first<1||p.first>n||p.second<1||p.second>m)return;\n\tif(bad.count(p))return;\n\tif(id.count(p))return;\n\tid[p]=++tot;\n\tpos[tot]=p;\n\tvalr[p.first].push_back(p.second);\n\tvalc[p.second].push_back(p.first);\n}\n\nclass Seg{\npublic:\n\tpair<int,int>s,t;\n\tint p;\n\tSeg(){}\n\tSeg(pair<int,int>_s,pair<int,int>_t):s(_s),t(_t){add(t),p=id[t];}\n\tint area()const{return 1LL*(t.first-s.first+1)*(t.second-s.second+1)%mod;}\n\tint calc(const Seg &o)const{\n\t\treturn dist[p][o.p]-abs(pos[p].first-pos[o.p].first)-abs(pos[p].second-pos[o.p].second);\n\t}\n}val[maxm];\n\nvoid dij(int s){\n\twhile(!pq.empty())pq.pop();\n\tfor(int i=1;i<=tot;i++)dist[s][i]=INF;\n\tdist[s][s]=0;\n\tpq.push(make_pair(0,s));\n\twhile(!pq.empty()){\n\t\tint x=pq.top().second,cur=-pq.top().first;\n\t\tpq.pop();\n\t\tif(dist[s][x]!=cur)continue;\n\t\tfor(int i=0;i<int(edge[x].size());i++){\n\t\t\tpair<int,int>y=edge[x][i];\n\t\t\tif(dist[s][y.first]>dist[s][x]+y.second){\n\t\t\t\tdist[s][y.first]=dist[s][x]+y.second;\n\t\t\t\tpq.push(make_pair(-dist[s][y.first],y.first));\n\t\t\t}\n\t\t}\n\t}\n}\n\nint main(){\n\tscanf(\"%d%d%d\",&n,&m,&k);\n\tallx[++kx]=1;\n\tallx[++kx]=n+1;\n\tally[++ky]=1;\n\tally[++ky]=m+1;\n\tfor(int i=1;i<=k;i++){\n\t\tscanf(\"%d%d\",&x[i],&y[i]);\n\t\tx[i]++;y[i]++;\n\t\tallx[++kx]=x[i];\n\t\tallx[++kx]=x[i]+1;\n\t\tally[++ky]=y[i];\n\t\tally[++ky]=y[i]+1;\n\t\tbad.insert(make_pair(x[i],y[i]));\n\t\tvalr[x[i]].push_back(y[i]);\n\t\tvalc[y[i]].push_back(x[i]);\n\t}\n\tfor(int i=1;i<=k;i++)\n\t\tfor(int dx=-1;dx<=1;dx++)for(int dy=-1;dy<=1;dy++)\n\t\t\tadd(make_pair(x[i]+dx,y[i]+dy));\n\tsort(allx+1,allx+1+kx);\n\tsort(ally+1,ally+1+ky);\n\tkx=unique(allx+1,allx+1+kx)-allx-1;\n\tky=unique(ally+1,ally+1+ky)-ally-1;\n\tfor(int i=1;i<kx;i++)for(int j=1;j<ky;j++)if(!bad.count(make_pair(allx[i],ally[j])))\n\t\tval[++cnt]=Seg(make_pair(allx[i],ally[j]),make_pair(allx[i+1]-1,ally[j+1]-1));\n\tlong long sum=0;\n\tfor(int i=1;i<=n;i++){\n\t\tsort(valr[i].begin(),valr[i].end());\n\t\tint cur=0;\n\t\tfor(int j=0;j<int(valr[i].size());j++){\n\t\t\ttmp[j]=bad.count(make_pair(i,valr[i][j]));\n\t\t\tver[j]=id.count(make_pair(i,valr[i][j]))?id[make_pair(i,valr[i][j])]:0;\n\t\t\tcur+=tmp[j];\n\t\t\tif(j>0&&!tmp[j-1]&&!tmp[j])\n\t\t\t\tedge[ver[j-1]].push_back(make_pair(ver[j],valr[i][j]-valr[i][j-1])),\n\t\t\t\tedge[ver[j]].push_back(make_pair(ver[j-1],valr[i][j]-valr[i][j-1]));\n\t\t}\n\t\tcur=m-cur;\n\t\tans=(ans+1LL*(sum-1LL*n*m+k+sum+cur)%mod*i%mod*cur)%mod;\n\t\tsum+=cur;\n\t}\n\tsum=0;\n\tfor(int i=1;i<=m;i++){\n\t\tsort(valc[i].begin(),valc[i].end());\n\t\tint cur=0;\n\t\tfor(int j=0;j<int(valc[i].size());j++){\n\t\t\ttmp[j]=bad.count(make_pair(valc[i][j],i));\n\t\t\tver[j]=id.count(make_pair(valc[i][j],i))?id[make_pair(valc[i][j],i)]:0;\n\t\t\tcur+=tmp[j];\n\t\t\tif(j>0&&!tmp[j-1]&&!tmp[j])\n\t\t\t\tedge[ver[j-1]].push_back(make_pair(ver[j],valc[i][j]-valc[i][j-1])),\n\t\t\t\tedge[ver[j]].push_back(make_pair(ver[j-1],valc[i][j]-valc[i][j-1]));\n\t\t}\n\t\tcur=n-cur;\n\t\tans=(ans+1LL*(sum-1LL*n*m+k+sum+cur)%mod*i%mod*cur)%mod;\n\t\tsum+=cur;\n\t}\n\tans=(ans%mod+mod)%mod;\n\tans=2LL*ans%mod;\n\tfor(int i=1;i<=tot;i++)dij(i);\n\tfor(int i=1;i<=cnt;i++)for(int j=1;j<=cnt;j++)\n\t\tans=(ans+1LL*val[i].calc(val[j])*val[i].area()%mod*val[j].area())%mod;\n\t\t\t//cerr<<val[i].s.first<<\" \"<<val[i].s.second<<\" \"<<val[i].t.first<<\" \"<<val[i].t.second<<endl,\n\t\t\t//cerr<<val[j].s.first<<\" \"<<val[j].s.second<<\" \"<<val[j].t.first<<\" \"<<val[j].t.second<<endl,\n\t\t\t//cerr<<val[i].calc(val[j])<<\" \"<<val[i].p<<\" \"<<val[j].p<<\" \"<<dist[val[i].p][val[j].p]<<endl;\n\tprintf(\"%d\\n\",int(1LL*ans*(mod+1)/2%mod));\n\treturn 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\n#define fe first\n#define se second\n\nusing namespace std;\n\nconst int maxn = 105, mo = int(1e9) + 7;\nconst int inv_2 = 500000004, inv_6 = 166666668;\nconst int xy[4][2] = {{1,0},{0,1},{-1,0},{0,-1}};\n\ntypedef pair<int,int> pi;\n\nmap<pi,bool> hole;\n\nbool bl[maxn][maxn];\npi pos[maxn];\nint H,W,n,new_r[maxn][2],new_c[maxn][2],w[maxn][maxn],r_cnt,c_cnt;\nint ans;\n\nint sq_sum(int l,int r)\n{\n\tif (l > r) return 0;\n\tif (l > 1) return (sq_sum(1,r) - sq_sum(1,l - 1) + mo) % mo;\n\treturn r * 1ll * (r + 1) % mo * (2ll * r + 1) % mo * inv_6 % mo;\n}\n\nint n_sum(int l,int r)\n{\n\tif (l > r) return 0;\n\treturn (l + r) * 1ll * (r - l + 1) % mo * inv_2 % mo;\n}\n\nvoid row_compress()\n{\n\tsort(pos + 1,pos + n + 1);\n\tfor(int i = 1;i <= n + 1;i ++)\n\t{\n\t\tint lr = pos[i - 1].fe + 1, rr = pos[i].fe - 1;\n\t\tif (lr <= rr)\n\t\t{\n\t\t\tnew_r[++ r_cnt][0] = lr,new_r[r_cnt][1] = rr;\n\t\t\tint C1 = 1 - i,C2 = (W * 1ll * H % mo - n + i - 1) % mo;\n\t\t\tans = ((ans - W * 1ll * W % mo * sq_sum(lr,rr - 1)) % mo + \n\t\t\t\t\t(C2 - C1) % mo * 1ll * W % mo * n_sum(lr,rr - 1) % mo) % mo;\n\t\t\tans = (ans + C1 * 1ll * C2 % mo * (rr - lr)) % mo; \n\t\t}\n\t\tif (pos[i].fe != pos[i - 1].fe && i != n + 1)\n\t\t\tnew_r[++ r_cnt][0] = new_r[r_cnt][1] = pos[i].fe;\n\t}\n}\n\nvoid whole_dp()\n{\n\tfor(int i = 1;i <= n;i ++)\n\t\thole[pos[i]] = 1;\n\tfor(int i = 1;i <= r_cnt;i ++)\n\t\tfor(int j = 1;j <= c_cnt;j ++)\n\t\t{\n\t\t\tw[i][j] = (new_r[i][1] - new_r[i][0] + 1) * 1ll * (new_c[j][1] - new_c[j][0] + 1) % mo;\n\t\t\tif (w[i][j] == 1)\n\t\t\t\tbl[i][j] = hole[pi(new_r[i][0],new_c[j][0])];\n\t\t}\n\tstatic int vis[maxn][maxn];\n\tint vis_cnt = 0;\n\tfor(int i = 1;i <= r_cnt;i ++)\n\t\tfor(int j = 1;j <= c_cnt;j ++)\n\t\t\tif (!bl[i][j])\n\t\t\t{\n\t\t\t\tstatic int que[maxn * maxn][3];\n\t\t\t\t++ vis_cnt;\n\t\t\t\tint en = 1;\n\t\t\t\tque[en][0] = i,que[en][1] = j,que[en][2] = 0;\n\t\t\t\tvis[i][j] = vis_cnt;\n\t\t\t\tfor(int k = 1;k <= en;k ++)\n\t\t\t\t{\n\t\t\t\t\tint x = que[k][0],y = que[k][1],d = que[k][2];\n\t\t\t\t\tans = (ans + w[i][j] * 1ll * w[x][y] % mo * d) % mo;\n\t\t\t\t\tfor(int p = 0;p < 4;p ++)\n\t\t\t\t\t{\n\t\t\t\t\t\tint nx = x + xy[p][0],ny = y + xy[p][1];\n\t\t\t\t\t\tif (nx && ny && nx <= r_cnt && ny <= c_cnt && !bl[nx][ny] && vis[nx][ny] != vis_cnt)\n\t\t\t\t\t\t{\n\t\t\t\t\t\t\tvis[nx][ny] = vis_cnt;\n\t\t\t\t\t\t\tque[++ en][0] = nx, que[en][1] = ny, que[en][2] = d + 1;\n\t\t\t\t\t\t}\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t}\n}\n\nint main()\n{\n\tscanf(\"%d%d%d\", &H, &W, &n);\n\tfor(int i = 1;i <= n;i ++)\n\t{\n\t\tscanf(\"%d%d\", &pos[i].fe, &pos[i].se);\n\t\tpos[i].fe ++, pos[i].se ++;\n\t}\n\tpos[n + 1] = pi(H + 1,W + 1);\n\trow_compress();\n\tswap(new_r,new_c),swap(r_cnt,c_cnt);\n\tfor(int i = 1;i <= n + 1;i ++) swap(pos[i].fe, pos[i].se);\n\tswap(H,W);\n\trow_compress();\n\tans = ans * 2ll % mo;\n\twhole_dp();\n\tprintf(\"%d\\n\", ans * 1ll * inv_2 % mo);\n\treturn 0;\n}\n"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\nusing namespace std;\ntypedef signed long long ll;\n\n#undef _P\n#define _P(...) (void)printf(__VA_ARGS__)\n#define FOR(x,to) for(x=0;x<(to);x++)\n#define FORR(x,arr) for(auto& x:arr)\n#define ITR(x,c) for(__typeof(c.begin()) x=c.begin();x!=c.end();x++)\n#define ALL(a) (a.begin()),(a.end())\n#define ZERO(a) memset(a,0,sizeof(a))\n#define MINUS(a) memset(a,0xff,sizeof(a))\n//-------------------------------------------------------\n\nll H,W;\nint N;\nset<pair<int,int>> S;\nvector<ll> Rs,Cs;\nll NR,NC;\nll weight[1010][1010];\nll ret;\nll mo=1000000007;\nint D[100][100];\n\nvoid solve() {\n\tint i,j,k,l,r,x,y; string s;\n\t\n\tll r2=(mo+1)/2;\n\tll r3=(mo+1)/3;\n\t\n\tcin>>H>>W>>N;\n\tRs.push_back(0);\n\tRs.push_back(H);\n\tCs.push_back(0);\n\tCs.push_back(W);\n\tFOR(i,N) {\n\t\tcin>>y>>x;\n\t\tRs.push_back(y);\n\t\tRs.push_back(y+1);\n\t\tCs.push_back(x);\n\t\tCs.push_back(x+1);\n\t\tS.insert({y,x});\n\t}\n\tsort(ALL(Rs));\n\tsort(ALL(Cs));\n\tRs.erase(unique(ALL(Rs)),Rs.end());\n\tCs.erase(unique(ALL(Cs)),Cs.end());\n\t\n\tNR=Rs.size()-1;\n\tNC=Cs.size()-1;\n\tFOR(y,NR) FOR(x,NC) {\n\t\tweight[y][x]=(Rs[y+1]-Rs[y])*(Cs[x+1]-Cs[x])%mo;\n\t\tif(S.count({Rs[y],Cs[x]})) weight[y][x]=0;\n\t}\n\t\n\tFOR(y,NR) {\n\t\tll t=Rs[y+1]-Rs[y];\n\t\tll L=0,R=0;\n\t\tFOR(x,NC) {\n\t\t\tFOR(i,y) L+=weight[i][x];\n\t\t\tfor(i=y+1;i<NR;i++) R+=weight[i][x];\n\t\t}\n\t\t(ret+=(L%mo)*(R%mo)%mo*(t-1))%=mo;\n\t\t(ret+=(W%mo)*((L+R)%mo)%mo*((t*(t-1)/2)%mo))%=mo;\n\t\t(ret+=W*W%mo*t%mo*(t+1)%mo*r2%mo*r2%mo*(((2*t+1)*r3+mo-1)%mo))%=mo;\n\t}\n\tFOR(x,NC) {\n\t\tll t=Cs[x+1]-Cs[x];\n\t\tll L=0,R=0;\n\t\tFOR(y,NR) {\n\t\t\tFOR(i,x) L+=weight[y][i];\n\t\t\tfor(i=x+1;i<NC;i++) R+=weight[y][i];\n\t\t}\n\t\t(ret+=(L%mo)*(R%mo)%mo*(t-1))%=mo;\n\t\t(ret+=(H%mo)*((L+R)%mo)%mo*((t*(t-1)/2)%mo))%=mo;\n\t\t(ret+=H*H%mo*t%mo*(t+1)%mo*r2%mo*r2%mo*(((2*t+1)*r3+mo-1)%mo))%=mo;\n\t}\n\t\n\tFOR(y,NR) FOR(x,NC) if(weight[y][x]) {\n\t\tint cy,cx,ty,tx;\n\t\tFOR(ty,NR) FOR(tx,NC) D[ty][tx]=101010;\n\t\tqueue<int> Q;\n\t\tD[y][x]=0;\n\t\tQ.push(y*100+x);\n\t\twhile(Q.size()) {\n\t\t\tcy=Q.front()/100;\n\t\t\tcx=Q.front()%100;\n\t\t\tQ.pop();\n\t\t\t\n\t\t\tint d[4]={1,0,-1,0};\n\t\t\tFOR(i,4) {\n\t\t\t\tty=cy+d[i];\n\t\t\t\ttx=cx+d[i^1];\n\t\t\t\tif(ty<0 || ty>=NR || tx<0 || tx>=NC) continue;\n\t\t\t\tif(weight[ty][tx]==0) continue;\n\t\t\t\tif(D[ty][tx]<=D[cy][cx]+1) continue;\n\t\t\t\tD[ty][tx]=D[cy][cx]+1;\n\t\t\t\tQ.push(ty*100+tx);\n\t\t\t\tif(y*100+x<ty*100+tx) {\n\t\t\t\t\t(ret+=weight[y][x]*weight[ty][tx]%mo*D[ty][tx])%=mo;\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t\t\n\t}\n\t\n\tcout<<ret<<endl;\n}\n\n\nint main(int argc,char** argv){\n\tstring s;int i;\n\tif(argc==1) ios::sync_with_stdio(false), cin.tie(0);\n\tFOR(i,argc-1) s+=argv[i+1],s+='\\n'; FOR(i,s.size()) ungetc(s[s.size()-1-i],stdin);\n\tcout.tie(0); solve(); return 0;\n}\n"
  },
  {
    "language": "C++",
    "code": "#include<cstdio>\n#include<algorithm>\nusing namespace std;\nint n, H, W, OH, OW, P[70][70], D[70][70], vis[70][70], head, tail;\nstruct point {\n\tint x, y;\n\tbool operator < (const point &p)const {\n\t\treturn x < p.x;\n\t}\n}w[32], Q[5010];\nlong long res, Mod = 1000000007, CC[70][70];\nint XX[70], YY[70];\nvoid Com2(int bx, int ex, int &X, int &Y, int ck) {\n\tif (!ck) XX[bx] = ex - bx + 1;\n\telse YY[bx] = ex - bx + 1;\n\tint i, c1 = 0, c2 = 0;\n\tfor (i = 1; i <= n; i++) {\n\t\tif (w[i].x <= bx)c1++;\n\t\telse c2++;\n\t}\n\tlong long ll = 0, rr = 1ll * (X - 1 - ex) * Y - c2;\n\tfor (i = 0; i < bx; i++) {\n\t\tif (!ck)ll += XX[i];\n\t\telse ll += YY[i];\n\t}\n\tll *= Y;\n\tll -= c1;\n\tfor (i = 1; i <= ex - bx; i++) {\n\t\tlong long t1 = (ll + 1ll*i*Y)%Mod;\n\t\tlong long t2 = (rr + 1ll * (ex - bx + 1 - i)*Y) % Mod;\n\t\tres = (res + t1*t2) % Mod;\n\t}\n\tfor (i = 1; i <= n; i++) {\n\t\tif (w[i].x >= ex)w[i].x -= (ex - bx);\n\t}\n\tX -= (ex - bx);\n}\nbool XCom() {\n\tint i;\n\tsort(w + 1, w + n + 1);\n\tif (w[1].x > 1) {\n\t\tCom2(0, w[1].x - 1, H, OW, 0);\n\t\treturn true;\n\t}\n\tfor (i = 1; i < n; i++) {\n\t\tif (w[i + 1].x - w[i].x > 2) {\n\t\t\tCom2(w[i].x + 1, w[i + 1].x - 1, H, OW, 0);\n\t\t\treturn true;\n\t\t}\n\t}\n\tif (w[n].x < H - 2) {\n\t\tCom2(w[n].x + 1, H - 1, H, OW, 0);\n\t\treturn true;\n\t}\n\treturn false;\n}\nbool YCom() {\n\tint i;\n\tsort(w + 1, w + n + 1);\n\tif (w[1].x > 1) {\n\t\tCom2(0, w[1].x - 1, W, OH, 1);\n\t\treturn true;\n\t}\n\tfor (i = 1; i < n; i++) {\n\t\tif (w[i + 1].x - w[i].x > 2) {\n\t\t\tCom2(w[i].x + 1, w[i + 1].x - 1, W, OH, 1);\n\t\t\treturn true;\n\t\t}\n\t}\n\tif (w[n].x < W - 2) {\n\t\tCom2(w[n].x + 1, W - 1, W, OH, 1);\n\t\treturn true;\n\t}\n\treturn false;\n}\nint dx[4] = { 1,0,-1,0 }, dy[4] = { 0,1,0,-1 };\nvoid Put(int x, int y, int d) {\n\tif (x>=0&&x<H&&y>=0&&y<W&&!P[x][y]&&!vis[x][y]) {\n\t\tvis[x][y] = 1;\n\t\tQ[++tail] = { x,y };\n\t\tD[x][y] = d;\n\t}\n}\nvoid BFS(int x, int y) {\n\tint i, j;\n\tfor (i = 0; i < H; i++)for (j = 0; j < W; j++)vis[i][j] = 0;\n\tD[x][y] = 0;\n\tvis[x][y] = 1;\n\thead = tail = 0;\n\tQ[++tail] = { x,y };\n\twhile (head < tail) {\n\t\tpoint t = Q[++head];\n\t\tif(t.x>x || (t.x==x&&t.y>y))res = (res + CC[x][y] * CC[t.x][t.y] % Mod * D[t.x][t.y])%Mod;\n\t\tfor (j = 0; j < 4; j++) {\n\t\t\tPut(t.x + dx[j], t.y + dy[j], D[t.x][t.y] + 1);\n\t\t}\n\t}\n}\nint main() {\n\tint i, j;\n\tscanf(\"%d%d\", &H, &W);\n\tOH = H, OW = W;\n\tfor (i = 0; i < 70; i++)XX[i] = 1;\n\tfor (i = 0; i < 70; i++)YY[i] = 1;\n\tscanf(\"%d\", &n);\n\tfor (i = 1; i <= n; i++) {\n\t\tscanf(\"%d%d\", &w[i].x, &w[i].y);\n\t}\n\twhile (XCom());\n\tfor (i = 1; i <= n; i++)swap(w[i].x, w[i].y);\n\twhile (YCom());\n\tfor (i = 1; i <= n; i++)swap(w[i].x, w[i].y);\n\tfor (i = 1; i <= n; i++) {\n\t\tP[w[i].x][w[i].y] = 1;\n\t}\n\tfor (i = 0; i < H; i++)for (j = 0; j < W; j++)CC[i][j] = 1ll * XX[i] * YY[j] % Mod;\n\tfor (i = 0; i < H; i++) for (j = 0; j < W; j++) if(!P[i][j])BFS(i, j);\n\tprintf(\"%lld\\n\", res);\n\treturn 0;\n\n}"
  },
  {
    "language": "C++",
    "code": "// SUBLIME HAX\n\t/*nope\n\tcat\n\t// sixteen chars// sixteen chars// sixteen chars// sixteen chars// sixteen chars// sixteen chars// sixteen chars// sixteen chars// sixteen chars// sixteen chars// sixteen chars// sixteen chars// sixteen chars// sixteen chars// sixteen chars// sixteen chars// sixteen chars// sixteen chars// sixteen chars// sixteen chars// sixteen chars// sixteen chars// sixteen chars// sixteen chars// sixteen chars// sixteen chars// sixteen chars// sixteen chars// sixteen chars// sixteen chars// sixteen chars// sixteen chars// sixteen chars// sixteen chars// sixteen chars// sixteen chars// sixteen chars// sixteen chars// sixteen chars// sixteen chars// sixteen chars// sixteen chars// sixteen chars// sixteen chars// sixteen chars// sixteen chars// sixteen chars// sixteen chars// sixteen chars// sixteen chars// sixteen chars// sixteen chars// sixteen chars// sixteen chars// sixteen chars// sixteen chars// sixteen chars// sixteen chars// sixteen chars// sixteen chars// sixteen chars// sixteen chars// sixteen chars// sixteen chars\n\t// ayy\n\t// ' lamo\n\t*/\n\t#include <bits/stdc++.h>\n\tusing namespace std;\n\ttemplate<class T,class U>\n\tostream &operator<<(ostream &os,const pair<T,U> &x) {\n\t\treturn os<<\"(\"<<x.first<<\",\"<<x.second<<\")\";\n\t}\n\tnamespace dbg_ns {\n\t\ttemplate<typename C>\n\t\tstruct is_iterable {\n\t\t\ttemplate<class T> static long check(...);\n\t\t\ttemplate<class T> static char check(int,\n\t\t\t\ttypename T::const_iterator = C().end());\n\t\t\tenum {\n\t\t\t\tvalue = sizeof(check<C>(0)) == sizeof(char),\n\t\t\t\tneg_value = sizeof(check<C>(0)) != sizeof(char)\n\t\t\t};\n\t\t};\n\t\ttemplate<class T> ostream &_out_str(ostream &os,const T &x) {\n\t\t\treturn os<<'\"'<<x<<'\"';\n\t\t}\n\t\ttemplate<class T> ostream &_dbg2_5(ostream &,const T &);\n\t\ttemplate<bool B,typename T=void> using eit=typename enable_if<B,T>::type;\n\t\ttemplate<class T>\n\t\tinline ostream &_dbg3(ostream &os,eit<is_iterable<T>::neg_value,const T> &x) {\n\t\t\treturn os<<x;\n\t\t}\n\t\ttemplate<class T>\n\t\tinline ostream &_dbg3(ostream &os,eit<is_iterable<T>::value,const T> &V) {\n\t\t\tos<<\"{\";\n\t\t\tbool ff=0;\n\t\t\tfor(const auto &E:V) _dbg2_5(ff?os<<\",\":os,E), ff=1;\n\t\t\treturn os<<\"}\";\n\t\t}\n\t\ttemplate<>\n\t\tinline ostream &_dbg3<string>(ostream &os,const string &x) {\n\t\t\treturn _out_str(os,x);\n\t\t}\n\t\ttemplate<>\n\t\tinline ostream &_dbg3<const char *>(ostream &os,const char *const &x) {\n\t\t\treturn _out_str(os,x);\n\t\t}\n\t\ttemplate<class T> inline ostream &_dbg2_5(ostream &os,const T &x) {\n\t\t\treturn _dbg3<T>(os,x);\n\t\t}\n\t\ttemplate<class T,typename... Args> ostream &_dbg2(ostream &os,vector<string>::iterator nm,const T &x,Args&&... args);\n\t\tinline ostream &_dbg2(ostream &os,vector<string>::iterator) { return os; }\n\t\ttemplate<typename... Args>\n\t\tinline ostream &_dbg2(ostream &os,vector<string>::iterator nm,const char *x,Args&&... args) {\n\t\t\treturn _dbg2(_dbg3<const char *>(os<<\"  \",x),nm+1,args...);\n\t\t}\n\t\ttemplate<class T,typename... Args>\n\t\tinline ostream &_dbg2(ostream &os,vector<string>::iterator nm,const T &x,Args&&... args) {\n\t\t\treturn _dbg2(_dbg3<T>(os<<\"  \"<<*nm<<\"=\",x),nm+1,args...);\n\t\t}\n\t\tvector<string> split(string s) {\n\t\t\tvector<string> Z;\n\t\t\tstring z=\"\";\n\t\t\ts+=',';\n\t\t\tint dep=0;\n\t\t\tfor(char c:s) {\n\t\t\t\tif(c==',' && !dep) Z.push_back(z),z=\"\";\n\t\t\t\telse z+=c;\n\t\t\t\tif(c=='(') ++dep;\n\t\t\t\tif(c==')') --dep;\n\t\t\t}\n\t\t\treturn Z;\n\t\t}\n\t\ttemplate<typename... Args> inline ostream &_dbg1(int ln,const string &nm,Args&&... args) {\n\t\t\tauto nms=split(nm);\n\t\t\treturn _dbg2(cerr<<\"L\"<<ln<<\":\",nms.begin(),args...)<<endl;\n\t\t}\n\t}\n\t#define dbg(...) dbg_ns::_dbg1(__LINE__,#__VA_ARGS__,__VA_ARGS__)\n\t#define sz(x) (int(x.size()))\n\t#define eprintf(...) fprintf(stderr,__VA_ARGS__)\n\t#define fi first\n\t#define se second\n\t#define pb push_back\n// END SUBLIME HAX\n// #include <bits/extc++.h>\n// using namespace __gnu_pbds;\ntypedef unsigned long long ull;\ntypedef long long ll;\ntypedef long double ld; //CARE\ntypedef complex<ld> pt;\nconst ld eps=(ld)1e-8;\nconst ld tau=2*(ld)acosl(-1);\nconst int inf=1e9+99;\nconst ll linf=1e18+99;\nconst int P=1e9+7;\n\n\n// #define int __int128\n// #define ll __int128\n\nint32_t H,W;\nint32_t n;\n\nconst int32_t N=8192;\nconst int NN=8074;\nint D1[NN/2][NN/2];\nint D2[NN/2][NN];\ninline int &D(int x,int y) {\n\tif(x<y) swap(x,y);\n\tif(x+x<NN) return D1[x][y];\n\treturn D2[x-(NN>>1)][y];\n}\nvector<pair<int,int> > adj[N];\nvector<pair<int,int> > rels;\nvector<int> relx,rely;\nset<pair<int,int> > bads;\nset<int> bx,by;\nvector<pair<int,int> > bandx,bandy;\n\nmap<int,int> ddec[1<<20];\n\nint dec(int x,int y) {\n\treturn ddec[x].count(y) ? ddec[x][y] : -1;\n\tauto it=lower_bound(rels.begin(),rels.end(),pair<int,int>(x,y));\n\tif(it!=rels.end() && it->fi==x && it->se==y)\n\t\treturn int(it-rels.begin());\n\treturn -1;\n}\n\n\nint sL(int x) { // 0+..+x-1\n\treturn int(1LL*x*(x-1)/2%P);\n}\nint ww(int x) {\n\tstatic bool init=0;\n\tstatic int Z[1<<20];\n\tassert(1<=x && x<(1<<20));\n\tif(!init) {\n\t\tinit=1;\n\t\tassert(!sL(0) && !sL(1));\n\t\tfor(int i=1;i<(1<<20);i++) {\n\t\t\tZ[i]=sL(i)+Z[i-1];\n\t\t\tif(Z[i]>=P) Z[i]-=P;\n\t\t}\n\t}\n\treturn Z[x];\n}\nint qq(int x,int y) {\n\treturn int((1LL*x*sL(y)+1LL*y*sL(x))%P);\n}\ninline int _w(const pair<int,int> &P) {\n\tif(~P.se) return P.se-P.fi+1;\n\treturn 1;\n}\nint g_same(int w,int h) {\n\t// dbg(\"SS\",w,h);\n\t// dbg(ww(h));\n\treturn int((1LL*w*w%P*ww(h) + 1LL*h*h%P*ww(w))%P);\n}\nint g_same(int w,const pair<int,int> &X,const pair<int,int> &_X) {\n\tif(X==_X) return g_same(w,_w(X));\n\tint d0;\n\tint a= X.fi,b=~ X.se? X.se: X.fi;\n\tint c=_X.fi,d=~_X.se?_X.se:_X.fi;\n\tassert(a<=b && c<=d);\n\tif(b<c) d0=c-b; else\n\tif(d<a) d0=a-d; else\n\tassert(0);\n\tint h1=_w(X);\n\tint h2=_w(_X);\n\n\tll ZZ=d0;\n\tZZ=ZZ*w%P*h1%P*w%P*h2%P;\n\tZZ+=1LL*h1*h2%P*ww(w)*2; //dbg(h1,h2,w,ww(w));\n\tZZ+=1LL*w*w%P*qq(h1,h2);\n\t// dbg(\"HIT\",w,h1,h2,ZZ,d0);\n\treturn int(ZZ%P);\n}\ninline int close(const pair<int,int> &X,int x) {\n\tif(!~X.se) return X.fi;\n\tif(x<X.fi) return X.fi;\n\tif(x>X.se) return X.se;\n\tassert(0);\n}\nint g(const pair<int,int> &X,const pair<int,int> &Y,\n\tconst pair<int,int> &_X,const pair<int,int> &_Y) {\n\n\tif(X==_X && Y==_Y && !~X.se && !~Y.se) return 0;\n\n\tif(X==_X && ~X.se) return g_same(_w(X),Y,_Y);\n\tif(Y==_Y && ~Y.se) return g_same(_w(Y),X,_X);\n\n\tint  Cx=_w(X);\n\tint  Cy=_w(Y);\n\tint _Cx=_w(_X);\n\tint _Cy=_w(_Y);\n\tint CCx=int(1LL*Cx*_Cx%P);\n\tint CCy=int(1LL*Cy*_Cy%P);\n\n\tint u=dec(close(X,_X.fi),close(Y,_Y.fi)); assert(~u);\n\tint v=dec(close(_X,X.fi),close(_Y,Y.fi)); assert(~v);\n\n\tll ZZ=D(u,v); assert(ZZ<inf);\n\n\tZZ=ZZ*CCx%P*CCy;\n\t// dbg(C,_C,ZZ,ZZ%P);\n\n\tZZ+=1LL*CCx*qq(Cy,_Cy);\n\tZZ+=1LL*CCy*qq(Cx,_Cx);\n\n\t// dbg(ZZ,ZZ%P);\n\n\treturn int(ZZ%P);\n}\n\n\ntemplate<class T> struct PQ {\n\tint n=0;\n\tT A[N*4];\n\tvoid push(const T &x) {\n\t\tint i=++n;\n\t\tA[i]=x;\n\t\tfor(;i>1 && A[i>>1]<A[i];) swap(A[i>>1],A[i]), i>>=1;\n\t}\n\tT top() const { return A[1]; }\n\tvoid pop() {\n\t\tassert(n>=1);\n\t\tif(n>1) swap(A[1],A[n]);\n\t\tn--;\n\t\tint i=1;\n\t\tfor(;;) {\n\t\t\tint j=i<<1;\n\t\t\tif(j>n) break;\n\t\t\tif(j==n) {\n\t\t\t\tif(A[j]>A[i]) swap(A[j],A[i]);\n\t\t\t\tbreak;\n\t\t\t}\n\t\t\tif(A[j+1]>A[j]) ++j;\n\t\t\tif(A[j]>A[i]) swap(A[j],A[i]);\n\t\t\telse break;\n\t\t\ti=j;\n\t\t}\n\t}\n\tint size() const {\n\t\treturn n;\n\t}\n};\n// PQ<pair<int,int> > pq;\n// priority_queue<pair<int,int> > pq;\n// queue<pair<int,int> > pq;\nint pq[N];\nbool inq[N];\n#define top front\n\nvoid dijk(int src,int *DD) {\n\t// for(int u=0;u<n;u++) DD[u]=inf;\n\t// for(int u=0;u<=src;u++) DD[u]=D[u][src], pq.push({-DD[u],u});\n\t// for(int u=src+1;u<n;u++) DD[u]=inf;\n\t// if(src) for(int u=src+1;u<n;u++) DD[u]=D[src-1][u]+DD[src-1], pq.push({-DD[u],u});\n\tint pn=0;\n\tfor(int u=0;u<=src;u++) DD[u]=D(u,src), pq[pn++]=u;\n\tfor(int u=src+1;u<n;u++) DD[u]=inf;\n\tif(src) for(int u=src+1;u<n;u++) DD[u]=D(src-1,u)+DD[src-1], pq[pn++]=u;\n\n\tint ii=0;\n\tfor(int i=0;i<n;i++) inq[i]=0;\n\tfor(int i=0;i<pn;i++) inq[pq[i]]=1;\n\t// DD[src]=0;\n\t// pq.push({0,src});\n\t// for(;sz(pq);) {\n\tfor(;ii<pn;) {\n\t\t// auto P=pq.top();\n\t\t// int u=P.se;\n\t\t// int d=-P.fi;\n\t\t// pq.pop();\n\t\t// if(DD[u]<d) continue;\n\t\tint u=pq[(ii++)&(N-1)];\n\t\tinq[u]=0;\n\t\tint d=DD[u];\n\t\tfor(const auto &P:adj[u]) if(d+P.se<DD[P.fi]) {\n\t\t\tDD[P.fi]=d+P.se;\n\t\t\t// pq.push({-DD[P.fi],P.fi});\n\t\t\tif(!inq[P.fi]) pq[(pn++)&(N-1)]=P.fi;\n\t\t}\n\t}\n}\n\n\nint32_t main() {\n\t// for(int i=1;i<6;i++) dbg(i,ww(i));\n\tcin>>H>>W>>n;\n\tfor(int i=0;i<n;i++) {\n\t\tint32_t x,y; cin>>x>>y;\n\t\tbads.insert({x,y});\n\t\tbx.insert(x), by.insert(y);\n\t}\n\tfor(int _x:bx) for(int x=_x-1;x<=_x+1;x++)\n\t\tif(!sz(relx) || x>relx.back()) if(0<=x && x<H)\n\t\t\trelx.pb(x);\n\tfor(int _y:by) for(int y=_y-1;y<=_y+1;y++)\n\t\tif(!sz(rely) || y>rely.back()) if(0<=y && y<W)\n\t\t\trely.pb(y);\n\n\tfor(int x:relx) for(int y:rely) if(!bads.count({x,y})) rels.pb({x,y});\n\tsort(rels.begin(),rels.end());\n\tn=sz(rels);\n\tassert(n<=NN);\n\tfor(int i=0;i<n;i++) ddec[rels[i].fi][rels[i].se]=i;\n\n\tfor(int i=1;i<sz(relx);i++) for(int y:rely) {\n\t\tint u=dec(relx[i-1],y);\n\t\tint v=dec(relx[i],y);\n\t\tint d=relx[i]-relx[i-1];\n\t\tif(~u && ~v) {\n\t\t\tadj[u].pb({v,d});\n\t\t\tadj[v].pb({u,d});\n\t\t}\n\t}\n\tfor(int i=1;i<sz(rely);i++) for(int x:relx) {\n\t\tint u=dec(x,rely[i-1]);\n\t\tint v=dec(x,rely[i]);\n\t\tint d=rely[i]-rely[i-1];\n\t\tif(~u && ~v) {\n\t\t\tadj[u].pb({v,d});\n\t\t\tadj[v].pb({u,d});\n\t\t}\n\t}\n\n\tstatic int DD[N];\n\tfor(int i=0;i<n;i++) {\n\t\tdijk(i,DD);\n\t\tfor(int j=0;j<n;j++) D(i,j)=DD[j];\n\t}\n\t// for(int i=0;i<n;i++) for(int j=0;j<n;j++) dbg(rels[i],rels[j],D[i][j]);\n\n\t{\n\t\tint pr=-1;\n\t\tfor(int x:bx) {\n\t\t\tif(x-1>pr) bandx.pb({pr+1,x-1});\n\t\t\tbandx.pb({x,-1});\n\t\t\tpr=x;\n\t\t}\n\t\tif(H-1>pr) bandx.pb({pr+1,H-1});\n\t}\n\t{\n\t\tint pr=-1;\n\t\tfor(int y:by) {\n\t\t\tif(y-1>pr) bandy.pb({pr+1,y-1});\n\t\t\tbandy.pb({y,-1});\n\t\t\tpr=y;\n\t\t}\n\t\tif(W-1>pr) bandy.pb({pr+1,W-1});\n\t}\n\n\tassert(sz(bandx)<=61 && sz(bandy)<=61);\n\n\tll Z=0;\n\tfor(const auto &BX:bandx) for(const auto &BY:bandy) {\n\t\tif(bads.count({BX.fi,BY.fi})) continue;\n\t\tfor(const auto &_BX:bandx) for(const auto &_BY:bandy) {\n\t\t\tif(BX>_BX) continue;\n\t\t\tif(BX==_BX && BY>_BY) continue;\n\t\t\tif(!~_BX.se && !~_BY.se && bads.count({_BX.fi,_BY.fi})) continue;\n\t\t\tint w=g(BX,BY,_BX,_BY);\n\t\t\tZ+=w;\n\t\t}\n\t}\n\tcout<<int32_t(Z%P)<<endl;\n}\n\n\n\n\n\n\n\n\n\n\n\n"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\nusing namespace std;\n#define int long long\n#define p (int)(1e9 + 7)\n\nint MOD(int a){\n\treturn a % p;\n}\n\nint h, w;\nconst int inv2 = 500000004, inv6 = 166666668;\n\nint calc(int dis, int x1, int dx1, int x2, int dx2, int y1, int dy1, int y2, int dy2){\n\tif(x2 < x1){\n\t\treturn calc(dis, x2, dx2, x1, dx1, y2, dy2, y1, dy1);\n\t}\n\telse if(y2 < y1){\n\t\treturn calc(dis + dx2 - dx1, x1, dx2, x2 + dx2 - dx1, dx1, y2, dy2, y1, dy1);\n\t}\n\telse if(x1 == x2){\n\t\treturn calc(dis, y1, dy1, y2, dy2, x1, dx1, x2, dx2);\n\t}\n\tif(y1 == y2){\n\t\tif(dy1 == 1){\n\t\t\treturn MOD(inv2 * MOD(MOD(dx1 * dx2) * (2 * dis + (dx2 - dx1))));\n\t\t}\n\t\telse{\n\t\t\treturn MOD(inv6 * MOD(MOD(dx1 * dx2 * dy1) * MOD(3 * dy1 * (2 * (x2 - x1) + (dx2 - dx1)) + (2 * (dy1 - 1) * (dy1 + 1)))));\n\t\t}\n\t}\n\telse{\n\t\treturn MOD(inv2 * MOD(MOD(MOD(dx1 * dx2) * MOD(dy1 * dy2)) * (2 * dis + (dx2 - dx1) + (dy2 - dy1))));\n\t}\n}\n\nsigned main(){\n\tint H, W, N, i, j, k, l;\n\tscanf(\"%lld%lld\", &H, &W);\n\tscanf(\"%lld\", &N);\n\tvector<int> x_sub(N), y_sub(N), x(0), y(0);\n\tfor(i = 0; i < N; i++){\n\t\tscanf(\"%lld%lld\", &x_sub[i], &y_sub[i]);\n\t\tx.push_back(x_sub[i]);\n\t\tx.push_back(x_sub[i] + 1);\n\t\tx.push_back(max(0ll, x_sub[i] - 1));\n\t\ty.push_back(y_sub[i]);\n\t\ty.push_back(y_sub[i] + 1);\n\t\ty.push_back(max(0ll, y_sub[i] - 1));\n\t}\n\tx.push_back(0);\n\tx.push_back(H);\n\ty.push_back(0);\n\ty.push_back(W);\n\tsort(x.begin(), x.end());\n\tsort(y.begin(), y.end());\n\tfor(i = 1, j = 1; j < x.size(); j++){\n\t\tif(x[j - 1] < x[j]){\n\t\t\tx[i] = x[j];\n\t\t\ti++;\n\t\t}\n\t}\n\th = i - 1;\n\tfor(i = 1, j = 1; j < y.size(); j++){\n\t\tif(y[j - 1] < y[j]){\n\t\t\ty[i] = y[j];\n\t\t\ti++;\n\t\t}\n\t}\n\tw = i - 1;\n\tvector<int> dx(h), dy(w);\n\tfor(i = 0; i < h; i++){\n\t\tdx[i] = x[i + 1] - x[i];\n\t}\n\tfor(i = 0; i < w; i++){\n\t\tdy[i] = y[i + 1] - y[i];\n\t}\n\tvector<vector<char>> A(h, vector<char>(w, '.'));\n\tfor(i = 0; i < h; i++){\n\t\tfor(j = 0; j < w; j++){\n\t\t\tfor(k = 0; k < N; k++){\n\t\t\t\tif(x[i] == x_sub[k] && y[j] == y_sub[k]){\n\t\t\t\t\tA[i][j] = '#';\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t}\n\tvector<vector<int>> dis(h, vector<int>(w, 1000000000));\n\tint ans = 0;\n\tfor(i = 0; i < h; i++){\n\t\tfor(j = (i % 2) * (w - 1); 0 <= j && j < w; j = j + 1 - 2 * (i % 2)){\n\t\t\tif(A[i][j] == '#'){\n\t\t\t\tcontinue;\n\t\t\t}\n\t\t\tint sub = MOD(inv6 * MOD(MOD(dx[i] * dy[j]) * MOD((dx[i] + dy[j]) * MOD(dx[i] * dy[j] - 1))));\n\t\t\tans = MOD(ans + sub);\n\t\t\tint old_dis = dis[i][j];\n\t\t\tfor(k = 0; k < h; k++){\n\t\t\t\tfor(l = 0; l < w; l++){\n\t\t\t\t\tdis[k][l] += old_dis;\n\t\t\t\t}\n\t\t\t}\n\t\t\tqueue<pair<pair<int, int>, int>> q;\n\t\t\tq.push(pair<pair<int, int>, int>(pair<int, int>(i, j), 0));\n\t\t\twhile(q.size() > 0){\n\t\t\t\tk = q.front().first.first;\n\t\t\t\tl = q.front().first.second;\n\t\t\t\tint d = q.front().second;\n\t\t\t\tq.pop();\n\t\t\t\tif(A[k][l] == '#' || dis[k][l] <= d){\n\t\t\t\t\tcontinue;\n\t\t\t\t}\n\t\t\t\tdis[k][l] = d;\n\t\t\t\tif(l < w - 1){\n\t\t\t\t\tq.push(pair<pair<int, int>, int>(pair<int, int>(k + 0, l + 1), d + dy[l]));\n\t\t\t\t}\n\t\t\t\tif(k < h - 1){\n\t\t\t\t\tq.push(pair<pair<int, int>, int>(pair<int, int>(k + 1, l + 0), d + dx[k]));\n\t\t\t\t}\n\t\t\t\tif(l > 0){\n\t\t\t\t\tq.push(pair<pair<int, int>, int>(pair<int, int>(k + 0, l - 1), d + dy[l - 1]));\n\t\t\t\t}\n\t\t\t\tif(k > 0){\n\t\t\t\t\tq.push(pair<pair<int, int>, int>(pair<int, int>(k - 1, l + 0), d + dx[k - 1]));\n\t\t\t\t}\n\t\t\t}\n\t\t\tfor(k = 0; k < h; k++){\n\t\t\t\tfor(l = 0; l < w; l++){\n\t\t\t\t\tif(k < i || (i == k && l <= j) || A[k][l] == '#'){\n\t\t\t\t\t\tcontinue;\n\t\t\t\t\t}\n\t\t\t\t\tint res = calc(dis[k][l], x[i], dx[i], x[k], dx[k], y[j], dy[j], y[l], dy[l]);\n\t\t\t\t\tans = MOD(ans + res);\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t}\n\tprintf(\"%lld\\n\", MOD(ans + p));\n\treturn 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include <cstdio>\n#include <algorithm>\n#include <vector>\n#include <queue>\nusing namespace std;\ntypedef long long i64;\nconst i64 MOD = 1000000007;\ntemplate<typename T> void ADD(T& a, const T& b) { a = (a + b) % MOD; }\n\ni64 H, W;\nint N, X[30], Y[30];\nint hist[1001001];\n\ni64 precomp(i64 H, i64 W, int *Y)\n{\n    for (int i = 0; i < H; ++i) hist[i] = 0;\n    for (int i = 0; i < N; ++i) hist[Y[i]]++;\n\n    i64 tot = (H * W - N) % MOD;\n    i64 suml = 0;\n    i64 ret = 0;\n    for (int i = 1; i < H; ++i) {\n        ADD(suml, W - hist[i - 1]);\n        i64 sumr = (MOD + tot - suml) % MOD;\n        if (hist[i - 1] == 0 && hist[i] == 0) {\n            ADD(ret, suml * sumr);\n        }\n    }\n    return ret;\n}\nvector<pair<int, int>> summarize(int H, int *Y)\n{\n    vector<int> ys;\n    for (int i = 0; i < N; ++i) ys.push_back(Y[i]);\n    sort(ys.begin(), ys.end());\n    ys.erase(unique(ys.begin(), ys.end()), ys.end());\n    \n    vector<pair<int, int>> ret;\n    if (ys[0] != 0) ret.push_back({0, ys[0] - 1});\n    ret.push_back({ys[0], ys[0]});\n    for (int i = 1; i < ys.size(); ++i) {\n        if (ys[i - 1] < ys[i] - 1) ret.push_back({ys[i - 1] + 1, ys[i] - 1});\n        ret.push_back({ys[i], ys[i]});\n    }\n    if (ys.back() != H - 1) ret.push_back({ys.back() + 1, H - 1});\n    return ret;\n}\n\nint R, C; i64 weight[60][60];\nint dis[60][60];\n\nconst int dy[] = {-1, 0, 1, 0}, dx[] = {0, -1, 0, 1};\n\ni64 dfs(int y, int x)\n{\n    for (int i = 0; i < R; ++i) for (int j = 0; j < C; ++j) dis[i][j] = -1;\n    dis[y][x] = 0;\n    queue<pair<int, int>> qu; qu.push({y, x});\n    i64 ret = 0;\n    while (!qu.empty()) {\n        auto loc = qu.front(); qu.pop();\n        int d = dis[loc.first][loc.second];\n        if (make_pair(y, x) < make_pair(loc.first, loc.second)) {\n            ADD(ret, d * weight[loc.first][loc.second]);\n        }\n        for (int i = 0; i < 4; ++i) {\n            int y2 = loc.first + dy[i], x2 = loc.second + dx[i];\n            if (weight[y2][x2] == 0 || dis[y2][x2] != -1) continue;\n            dis[y2][x2] = d + 1;\n            qu.push({y2, x2});\n        }\n    }\n    return ret;\n}\n\nint main()\n{\n    scanf(\"%lld%lld%d\", &H, &W, &N);\n    for (int i = 0; i < N; ++i) {\n        scanf(\"%d%d\", Y + i, X + i);\n    }\n\n    i64 ret = 0;\n    ADD(ret, precomp(H, W, Y));\n    ADD(ret, precomp(W, H, X));\n\n    vector<pair<int, int>> ys = summarize(H, Y), xs = summarize(W, X);\n    R = ys.size(); C = xs.size();\n    for (int i = 0; i < R; ++i) {\n        for (int j = 0; j < C; ++j) {\n            weight[i][j] = (i64)(ys[i].second - ys[i].first + 1) * (xs[j].second - xs[j].first + 1);\n        }\n    }\n    for (int i = 0; i < N; ++i) {\n        --weight[find(ys.begin(), ys.end(), make_pair(Y[i], Y[i])) - ys.begin()][find(xs.begin(), xs.end(), make_pair(X[i], X[i])) - xs.begin()];\n    }\n    for (int i = 0; i < R; ++i) {\n        for (int j = 0; j < C; ++j) {\n            if (weight[i][j] != 0) {\n                ADD(ret, weight[i][j] % MOD * dfs(i, j));\n            }\n        }\n    }\n    printf(\"%lld\\n\", ret);\n\n    return 0;\n}\n"
  },
  {
    "language": "C++",
    "code": "#include<bits/stdc++.h>\nusing namespace std;\nconst int mod=1e9+7,iv=(mod+1)/2;\nint dx[]={1,0,-1,0},dy[]={0,1,0,-1};\nint h,w,n,x[33],y[33],prex[1111111],prey[1111111],ans,arrx[111],arry[111],cntx,cnty,dist[111][111],res;\nint fx[111],fy[111];\nbool ex[1111111],ey[1111111],ff[111][111];\nmap<pair<int,int>,int> mp;\nbool In(int x,int y)\n{\n\treturn (x>=1 && x<=cntx && y>=1 && y<=cnty);\n}\nvoid bfs(int i,int j)\n{\n\tmemset(dist,-1,sizeof(dist));\n\tdist[i][j]=0;\n\tqueue<pair<int,int> > q;\n\tq.push(make_pair(i,j));\n\twhile(!q.empty())\n\t{\n\t\tint xx=q.front().first,yy=q.front().second;\n\t\tq.pop();\n\t\tfor (int i=0;i<4;i++)\n\t\t{\n\t\t\tint xxx=xx+dx[i],yyy=yy+dy[i];\n\t\t\tif (!In(xxx,yyy) || ff[xxx][yyy]) continue;\n\t\t\tif (!~dist[xxx][yyy])\n\t\t\t{\n\t\t\t\tdist[xxx][yyy]=dist[xx][yy]+1;\n\t\t\t\tq.push(make_pair(xxx,yyy));\n\t\t\t}\n\t\t}\n\t}\n}\nint main()\n{\n\tscanf(\"%d%d%d\",&h,&w,&n);\n\tfor (int i=1;i<=n;i++)\n\t{\n\t\tscanf(\"%d%d\",&x[i],&y[i]);x[i]++;y[i]++;\n\t\tex[x[i]]=ey[y[i]]=1;\n\t\tmp[make_pair(x[i],y[i])]=1;\n\t\tprex[x[i]]++;prey[y[i]]++;\n\t}\n\tfor (int i=1;i<=h;i++) prex[i]+=prex[i-1];\n\tfor (int i=1;i<=w;i++) prey[i]+=prey[i-1];\n\tfor (int i=1;i<h;i++)\n\t{\n\t\tif (!ex[i] && !ex[i+1])\n\t\t{\n\t\t\tans=(1ll*(1ll*w*i-prex[i])%mod*((1ll*w*(h-i)-(n-prex[i]))%mod)+ans)%mod;\n\t\t}\n\t}\n\tfor (int i=1;i<w;i++)\n\t{\n\t\tif (!ey[i] && !ey[i+1])\n\t\t{\n\t\t\tans=(1ll*(1ll*h*i-prey[i])%mod*((1ll*h*(w-i)-(n-prey[i]))%mod)+ans)%mod;\n\t\t}\n\t}\n\tfor (int i=1;i<=h;i++)\n\t{\n\t\tif (ex[i] || ex[i-1] || i==1) \n\t\t{\n\t\t\tarrx[++cntx]=i;\n\t\t\tif (ex[i]) fx[cntx]=1;\n\t\t\telse\n\t\t\t{\n\t\t\t\tfor (int j=i;j<=h && !ex[j];j++)\n\t\t\t\t{\n\t\t\t\t\tfx[cntx]++;\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t}\n\tfor (int i=1;i<=w;i++)\n\t{\n\t\tif (ey[i] || ey[i-1] || i==1) \n\t\t{\n\t\t\tarry[++cnty]=i;\n\t\t\tif (ey[i]) fy[cnty]=1;\n\t\t\telse\n\t\t\t{\n\t\t\t\tfor (int j=i;j<=w && !ey[j];j++)\n\t\t\t\t{\n\t\t\t\t\tfy[cnty]++;\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t}\n\tfor (int i=1;i<=cntx;i++)\n\t{\n\t\tfor (int j=1;j<=cnty;j++)\n\t\t{\n\t\t\tff[i][j]=mp[make_pair(arrx[i],arry[j])];\n\t\t}\n\t}\n\tfor (int i=1;i<=cntx;i++)\n\t{\n\t\tfor (int j=1;j<=cnty;j++)\n\t\t{\n\t\t\tif (ff[i][j]) continue;\n\t\t\tbfs(i,j);\n\t\t\tfor (int k=1;k<=cntx;k++)\n\t\t\t{\n\t\t\t\tfor (int h=1;h<=cnty;h++)\n\t\t\t\t{\n\t\t\t\t\tif (!ff[k][h]) res=(1ll*dist[k][h]*fx[i]%mod*fy[j]%mod*fx[k]%mod*fy[h]+res)%mod;\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t}\n\tans=(1ll*res*iv+ans)%mod;\n\tprintf(\"%d\\n\",(ans+mod)%mod);\n\treturn 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include <algorithm>\n#include <array>\n#include <bitset>\n#include <cassert>\n#include <climits>\n#include <cmath>\n#include <complex>\n#include <cstdio>\n#include <cstdlib>\n#include <cstring>\n#include <functional>\n#include <iostream>\n#include <map>\n#include <memory>\n#include <numeric>\n#include <queue>\n#include <random>\n#include <set>\n#include <stack>\n#include <unordered_map>\n#include <vector>\n\nusing namespace std;\n\ntypedef long long lint;\n\nconst int mod = 1e9 + 7, inv6 = (mod + 1) / 6;\n\nstruct edge_t {\n  int u, dist;\n};\n\nint sum_x(int n) {\n  return (lint)n * (n + 1) / 2 % mod;\n}\n\nint sum_x2(int n) {\n  return (lint)n * (2 * n + 1) % mod * (n + 1) % mod * inv6 % mod;\n}\n\nint all_to_corner(int small, int big) {\n  if (small > big) return all_to_corner(big, small);\n  const int max_dist = (small - 1) + (big - 1);\n  int result = (lint)max_dist * sum_x(small - 1) % mod;\n  result =\n    (result + (lint)(sum_x(big - 1) - sum_x(small - 2)) * small) % mod;\n  if (result < 0) result += mod;\n  return result;\n}\n\nint solve_self_one_coord(int r, int c) {\n  int result = 0;\n  int sum_a = ((lint)c * sum_x(c) - sum_x2(c)) % mod;\n  if (sum_a < 0) sum_a += mod;\n  result = (result + (lint)r * (r - 1) % mod * sum_a) % mod;\n  result = (result + (lint)r * sum_a) % mod;\n  return result;\n}\n\nint solve_self(int h, int w) {\n  int result = solve_self_one_coord(h, w) + solve_self_one_coord(w, h);\n  if (result >= mod) result -= mod;\n  return result;\n}\n\nint solve_by_corner(int dist, int h1, int w1, int h2, int w2) {\n  int s1 = (lint)h1 * w1 % mod, s2 = (lint)h2 * w2 % mod;\n  int result = (lint)dist * s1 % mod * s2 % mod;\n  result = (result + (lint)all_to_corner(h1, w1) * s2) % mod;\n  result = (result + (lint)all_to_corner(h2, w2) * s1) % mod;\n  return result;\n}\n\nint unit_to_corner(int h, int w, int dist) {\n  int result = all_to_corner(h, w);\n  result = (result + (lint)h * w % mod * dist) % mod;\n  return result;\n}\n\nint solve_unit_to_rectangle(int h, int w, int d0, int d1, int d2, int d3) {\n  int div_y = (d2 - d0 + h - 1) / 2;\n  int div_x = (d1 - d0 + w - 1) / 2;\n  int result = unit_to_corner(div_y + 1, div_x + 1, d0);\n  if (div_y + 1 < h) {\n    result += unit_to_corner(h - (div_y + 1), div_x + 1, d2);\n    if (result >= mod) result -= mod;\n  }\n  if (div_x + 1 < w) {\n    result += unit_to_corner(div_y + 1, w - (div_x + 1), d1);\n    if (result >= mod) result -= mod;\n  }\n  if (div_y + 1 < h && div_x + 1 < w) {\n    result += unit_to_corner(h - (div_y + 1), w - (div_x + 1), d3);\n    if (result >= mod) result -= mod;\n  }\n  return result;\n}\n\nint solve_greedy_same_row(int r, int c1, int c2, int dist) {\n  int sum_a = ((lint)r * sum_x(r) - sum_x2(r)) % mod;\n  if (sum_a < 0) sum_a += mod;\n  int result = 2LL * c1 * c2 % mod * sum_a % mod;\n  result = (result + (lint)r * r % mod * c2 % mod * sum_x(c1 - 1)) % mod;\n  result = (result + (lint)r * r % mod * c1 % mod * sum_x(c2 - 1)) % mod;\n  result = (result + (lint)r * r % mod * c1 % mod * c2 % mod * dist) % mod;\n  return result;\n}\n\nvector<int> dijkstra(const vector<vector<edge_t>> &adj, int source) {\n  const int n = adj.size();\n  vector<int> min_dist(n, INT_MAX);\n  priority_queue<pair<int, int>, vector<pair<int, int>>,\n                 greater<pair<int, int>>> pq;\n  min_dist[source] = 0;\n  pq.emplace(min_dist[source], source);\n  while (!pq.empty()) {\n    pair<int, int> dist_and_v = pq.top(); pq.pop();\n    int dist_v, v;\n    tie(dist_v, v) = dist_and_v;\n    if (min_dist[v] != dist_v) continue;\n    for (const edge_t &ed : adj[v])\n      if (min_dist[ed.u] > min_dist[v] + ed.dist) {\n        min_dist[ed.u] = min_dist[v] + ed.dist;\n        pq.emplace(min_dist[ed.u], ed.u);\n      }\n  }\n  for (int i = 0; i < n; ++i)\n    assert(min_dist[i] < INT_MAX);\n  return min_dist;\n}\n\nint main() {\n  int height, width;\n  scanf(\"%d %d\", &height, &width);\n  int nblack;\n  scanf(\"%d\", &nblack);\n  vector<pair<int, int>> blacks(nblack);\n  for (int i = 0; i < nblack; ++i) {\n    int y, x;\n    scanf(\"%d %d\", &y, &x);\n    blacks[i] = {y, x};\n  }\n  vector<int> ys = {0, height}, xs = {0, width};\n  for (int i = 0; i < nblack; ++i) {\n    ys.push_back(blacks[i].first);\n    ys.push_back(blacks[i].first + 1);\n    xs.push_back(blacks[i].second);\n    xs.push_back(blacks[i].second + 1);\n  }\n  sort(ys.begin(), ys.end());\n  ys.resize(unique(ys.begin(), ys.end()) - ys.begin());\n  sort(xs.begin(), xs.end());\n  xs.resize(unique(xs.begin(), xs.end()) - xs.begin());\n  const int ny = ys.size() - 1, nx = xs.size() - 1;\n  vector<bool> row_has_black(ny), col_has_black(nx);\n  vector<vector<bool>> is_black(ny, vector<bool>(nx, false));\n  for (int i = 0; i < nblack; ++i) {\n    int y = lower_bound(ys.begin(), ys.end(), blacks[i].first) - ys.begin();\n    int x = lower_bound(xs.begin(), xs.end(), blacks[i].second) - xs.begin();\n    row_has_black[y] = true;\n    col_has_black[x] = true;\n    is_black[y][x] = true;\n  }\n  vector<vector<edge_t>> adj;\n  vector<vector<array<int, 4>>> corner_id(ny, vector<array<int, 4>>(nx));\n  auto new_node = [&]() {\n    int result = adj.size();\n    adj.emplace_back();\n    return result;\n  };\n  auto add_edge = [&](int u, int v, int dist) {\n    adj[u].push_back({v, dist});\n    adj[v].push_back({u, dist});\n  };\n  for (int y = 0; y < ny; ++y)\n    for (int x = 0; x < nx; ++x)\n      if (!is_black[y][x]) {\n        const int cell_height = ys[y + 1] - ys[y];\n        const int cell_width = xs[x + 1] - xs[x];\n        corner_id[y][x][0] = new_node();\n        if (cell_width == 1) {\n          corner_id[y][x][1] = corner_id[y][x][0];\n        } else {\n          corner_id[y][x][1] = new_node();\n          add_edge(corner_id[y][x][1], corner_id[y][x][0], cell_width - 1);\n        }\n        if (cell_height == 1) {\n          corner_id[y][x][2] = corner_id[y][x][0];\n          corner_id[y][x][3] = corner_id[y][x][1];\n        } else {\n          corner_id[y][x][2] = new_node();\n          add_edge(corner_id[y][x][2], corner_id[y][x][0], cell_height - 1);\n          if (cell_width == 1) {\n            corner_id[y][x][3] = corner_id[y][x][2];\n          } else {\n            corner_id[y][x][3] = new_node();\n            add_edge(corner_id[y][x][3], corner_id[y][x][2], cell_width - 1);\n            add_edge(corner_id[y][x][3], corner_id[y][x][1], cell_height - 1);\n          }\n        }\n\n        if (y - 1 >= 0 && !is_black[y - 1][x]) {\n          add_edge(corner_id[y][x][0], corner_id[y - 1][x][2], 1);\n          if (cell_width > 1) {\n            add_edge(corner_id[y][x][1], corner_id[y - 1][x][3], 1);\n          }\n        }\n        if (x - 1 >= 0 && !is_black[y][x - 1]) {\n          add_edge(corner_id[y][x][0], corner_id[y][x - 1][1], 1);\n          if (cell_height > 1) {\n            add_edge(corner_id[y][x][2], corner_id[y][x - 1][3], 1);\n          }\n        }\n      }\n  int result = 0;\n  for (int y = 0; y < ny; ++y)\n    for (int x = 0; x < nx; ++x)\n      if (!is_black[y][x]) {\n        const int cell_height = ys[y + 1] - ys[y];\n        const int cell_width = xs[x + 1] - xs[x];\n        result += solve_self(cell_height, cell_width);\n        if (result >= mod) result -= mod;\n\n        if (row_has_black[y] && col_has_black[x]) {\n          vector<int> dists = dijkstra(adj, corner_id[y][x][0]);\n          for (int y2 = 0; y2 < ny; ++y2)\n            for (int x2 = 0; x2 < nx; ++x2)\n              if (!is_black[y2][x2] &&\n                  (!(row_has_black[y2] && col_has_black[x2]) ||\n                   make_pair(y, x) < make_pair(y2, x2))) {\n                result += solve_unit_to_rectangle(\n                    ys[y2 + 1] - ys[y2], xs[x2 + 1] - xs[x2],\n                    dists[corner_id[y2][x2][0]], dists[corner_id[y2][x2][1]],\n                    dists[corner_id[y2][x2][2]], dists[corner_id[y2][x2][3]]);\n                if (result >= mod) result -= mod;\n              }\n        } else {\n          vector<vector<int>> min_dists(4);\n\n          for (int y2 = y; y2 < ny; ++y2)\n            for (int x2 = 0; x2 < nx; ++x2)\n              if (!is_black[y2][x2] && make_pair(y2, x2) > make_pair(y, x) &&\n                  !(row_has_black[y2] && col_has_black[x2])) {\n                if (row_has_black[y] && row_has_black[y2] && x != x2) {\n                  int min_dist;\n                  if (x2 > x) {\n                    if (min_dists[1].empty())\n                      min_dists[1] = dijkstra(adj, corner_id[y][x][1]);\n                    min_dist = min_dists[1][corner_id[y2][x2][0]];\n                  } else {\n                    if (min_dists[0].empty())\n                      min_dists[0] = dijkstra(adj, corner_id[y][x][0]);\n                    min_dist = min_dists[0][corner_id[y2][x2][1]];\n                  }\n                  result += solve_by_corner(min_dist, 1, xs[x + 1] - xs[x],\n                                            1, xs[x2 + 1] - xs[x2]);\n                  if (result >= mod) result -= mod;\n                } else if (col_has_black[x] && col_has_black[x2] && y != y2) {\n                  int min_dist;\n                  if (y2 > y) {\n                    if (min_dists[2].empty())\n                      min_dists[2] = dijkstra(adj, corner_id[y][x][2]);\n                    min_dist = min_dists[2][corner_id[y2][x2][0]];\n                  } else {\n                    if (min_dists[0].empty())\n                      min_dists[0] = dijkstra(adj, corner_id[y][x][0]);\n                    min_dist = min_dists[0][corner_id[y2][x2][2]];\n                  }\n                  result += solve_by_corner(min_dist, 1, ys[y + 1] - ys[y],\n                                            1, ys[y2 + 1] - ys[y2]);\n                  if (result >= mod) result -= mod;\n                } else if (y == y2) {\n                  int min_dist;\n                  if (x2 > x) min_dist = xs[x2] - xs[x + 1] + 1;\n                  else min_dist = xs[x] - xs[x2 + 1] + 1;\n                  result += solve_greedy_same_row(ys[y + 1] - ys[y],\n                                                  xs[x + 1] - xs[x],\n                                                  xs[x2 + 1] - xs[x2],\n                                                  min_dist);\n                  if (result >= mod) result -= mod;\n                } else if (x == x2) {\n                  int min_dist;\n                  if (y2 > y) min_dist = ys[y2] - ys[y + 1] + 1;\n                  else min_dist = ys[y] - ys[y2 + 1] + 1;\n                  result += solve_greedy_same_row(xs[x + 1] - xs[x],\n                                                  ys[y + 1] - ys[y],\n                                                  ys[y2 + 1] - ys[y2],\n                                                  min_dist);\n                  if (result >= mod) result -= mod;\n                } else {\n                  int min_dist = 0;\n                  if (y2 > y) min_dist += ys[y2] - ys[y + 1] + 1;\n                  else min_dist += ys[y] - ys[y2 + 1] + 1;\n                  if (x2 > x) min_dist += xs[x2] - xs[x + 1] + 1;\n                  else min_dist += xs[x] - xs[x2 + 1] + 1;\n                  result += solve_by_corner(min_dist,\n                                            ys[y + 1] - ys[y],\n                                            xs[x + 1] - xs[x],\n                                            ys[y2 + 1] - ys[y2],\n                                            xs[x2 + 1] - xs[x2]);\n                  if (result >= mod) result -= mod;\n                }\n              }\n        }\n      }\n  printf(\"%d\\n\", result);\n  return 0;\n}\n"
  },
  {
    "language": "C++",
    "code": "#include<algorithm> \n#include<iostream>\n#include<cstring>\n#include<cstdio>\n#define MN 61\n#define mod 1000000007\nusing namespace std;\ninline int read()\n{\n\tint x=0,f=1;char ch=getchar();\n\twhile(ch<'0'||ch>'9'){if(ch=='-')f=-1;ch=getchar();}\n\twhile(ch>='0'&&ch<='9'){x=x*10+ch-'0';ch=getchar();}\n\treturn x*f;\n}\npair<int,int> q[MN*MN*2+5];\nint h,w,n,Lx[MN+5],num1,Ly[MN+5],x[MN+5],y[MN+5],num2,ans;\nint vis[MN+5][MN+5],b[MN+5][MN+5],d[MN+5][MN+5],W[4],top;\nconst int dis[4][2]={{-1,0},{1,0},{0,-1},{0,1}};\nvoid Update(int x,int y)\n{\n\tif(vis[x][y]) return;vis[x][y]=1;\n\tfor(int k=0;k<4;++k)\n\t{\n\t\tint nx=x+dis[k][0],ny=y+dis[k][1];\n\t\tif(nx<1||ny<1||nx>num1||ny>num2||b[nx][ny]) continue;\n\t\tif(d[x][y]+W[k]<d[nx][ny])\n\t\t{\n\t\t\td[nx][ny]=d[x][y]+W[k];\n\t\t\tif(!W[k]) Update(nx,ny);\n\t\t\telse q[++top]=make_pair(nx,ny);\n\t\t}\n\t}\t\n}\nvoid Bfs(int x,int y)\n{\n\tmemset(vis,0,sizeof(vis));\n\tmemset(d,63,sizeof(d));d[x][y]=0;q[top=MN*MN]=make_pair(x,y);\n\tfor(int i=MN*MN;i<=top;++i)\n\t{\n\t\tint x=q[i].first,y=q[i].second;\n\t\tUpdate(x,y);\n\t}\n}\ninline int S(int x,int y){return 1LL*(Lx[x]-Lx[x-1])*(Ly[y]-Ly[y-1])%mod;}\nint main()\n{\n\th=read();w=read();n=read();\n\tLx[num1=1]=h;Ly[num2=1]=w;\n\tfor(int i=1;i<=n;++i)\n\t{\n\t\tx[i]=read()+1,y[i]=read()+1;\n\t\tLx[++num1]=x[i];if(x[i]>1) Lx[++num1]=x[i]-1;\n\t\tLy[++num2]=y[i];if(y[i]>1) Ly[++num2]=y[i]-1;\n\t}\n\tsort(Lx+1,Lx+num1+1);num1=unique(Lx+1,Lx+num1+1)-Lx-1;\n\tsort(Ly+1,Ly+num2+1);num2=unique(Ly+1,Ly+num2+1)-Ly-1;\n\tfor(int i=1;i<=n;++i)\n\t\tb[lower_bound(Lx+1,Lx+num1+1,x[i])-Lx]\n\t\t [lower_bound(Ly+1,Ly+num2+1,y[i])-Ly]=1;\n\tfor(int i=1;i<h;++i)\n\t{\n\t\tint a=1LL*w*i%mod,b=1LL*w*(h-i)%mod;\n\t\tfor(int j=1;j<=n;++j) \n\t\t\tif(x[j]<=i) --a<0?a+=mod:0;\n\t\t\telse --b<0?b+=mod:0;\n\t\tans=(ans+1LL*a*b)%mod;\n\t}\n\tfor(int i=1;i<w;++i)\n\t{\n\t\tint a=1LL*h*i%mod,b=1LL*h*(w-i)%mod;\n\t\tfor(int j=1;j<=n;++j) \n\t\t\tif(y[j]<=i) --a<0?a+=mod:0;\n\t\t\telse --b<0?b+=mod:0;\n\t\tans=(ans+1LL*a*b)%mod;\n\t}\n\tfor(int i=1;i<=num1;++i) for(int j=1;j<=num2;++j) if(Lx[i]==Lx[i-1]+1&&Ly[j]==Ly[j-1]+1&&!b[i][j])\n\t{\n\t\tW[0]=0;W[1]=1;W[2]=1;W[3]=0;Bfs(i,j);\n\t\tfor(int x=1;x<i;++x) for(int y=j;y<=num2;++y) if(!b[x][y])\n\t\t\tans=(ans+1LL*d[x][y]*S(i,j)%mod*S(x,y))%mod;\n\t\tW[0]=1;W[1]=0;W[2]=1;W[3]=0;Bfs(i,j);\n\t\tfor(int x=i;x<=num1;++x) for(int y=j+1;y<=num2;++y) if(!b[x][y])\n\t\t\tans=(ans+1LL*d[x][y]*S(i,j)%mod*S(x,y))%mod;\t\n\t\tW[0]=1;W[1]=0;W[2]=0;W[3]=1;Bfs(i,j);\n\t\tfor(int x=i+1;x<=num1;++x) for(int y=1;y<=j;++y) if(!b[x][y])\n\t\t\tans=(ans+1LL*d[x][y]*S(i,j)%mod*S(x,y))%mod;\n\t\tW[0]=0;W[1]=1;W[2]=0;W[3]=1;Bfs(i,j);\n\t\tfor(int x=1;x<=i;++x) for(int y=1;y<j;++y) if(!b[x][y])\n\t\t\tans=(ans+1LL*d[x][y]*S(i,j)%mod*S(x,y))%mod;\n\t}\n\tcout<<ans;\n\treturn 0;\n}"
  },
  {
    "language": "C++",
    "code": "// SUBLIME HAX\n\t/*nope\n\tcat\n\t// sixteen chars// sixteen chars// sixteen chars// sixteen chars// sixteen chars// sixteen chars// sixteen chars// sixteen chars// sixteen chars// sixteen chars// sixteen chars// sixteen chars// sixteen chars// sixteen chars// sixteen chars// sixteen chars// sixteen chars// sixteen chars// sixteen chars// sixteen chars// sixteen chars// sixteen chars// sixteen chars// sixteen chars// sixteen chars// sixteen chars// sixteen chars// sixteen chars// sixteen chars// sixteen chars// sixteen chars// sixteen chars// sixteen chars// sixteen chars// sixteen chars// sixteen chars// sixteen chars// sixteen chars// sixteen chars// sixteen chars// sixteen chars// sixteen chars// sixteen chars// sixteen chars// sixteen chars// sixteen chars// sixteen chars// sixteen chars// sixteen chars// sixteen chars// sixteen chars// sixteen chars// sixteen chars// sixteen chars// sixteen chars// sixteen chars// sixteen chars// sixteen chars// sixteen chars// sixteen chars// sixteen chars// sixteen chars// sixteen chars// sixteen chars\n\t// ayy\n\t// ' lamo\n\t*/\n\t#include <bits/stdc++.h>\n\tusing namespace std;\n\ttemplate<class T,class U>\n\tostream &operator<<(ostream &os,const pair<T,U> &x) {\n\t\treturn os<<\"(\"<<x.first<<\",\"<<x.second<<\")\";\n\t}\n\tnamespace dbg_ns {\n\t\ttemplate<typename C>\n\t\tstruct is_iterable {\n\t\t\ttemplate<class T> static long check(...);\n\t\t\ttemplate<class T> static char check(int,\n\t\t\t\ttypename T::const_iterator = C().end());\n\t\t\tenum {\n\t\t\t\tvalue = sizeof(check<C>(0)) == sizeof(char),\n\t\t\t\tneg_value = sizeof(check<C>(0)) != sizeof(char)\n\t\t\t};\n\t\t};\n\t\ttemplate<class T> ostream &_out_str(ostream &os,const T &x) {\n\t\t\treturn os<<'\"'<<x<<'\"';\n\t\t}\n\t\ttemplate<class T> ostream &_dbg2_5(ostream &,const T &);\n\t\ttemplate<bool B,typename T=void> using eit=typename enable_if<B,T>::type;\n\t\ttemplate<class T>\n\t\tinline ostream &_dbg3(ostream &os,eit<is_iterable<T>::neg_value,const T> &x) {\n\t\t\treturn os<<x;\n\t\t}\n\t\ttemplate<class T>\n\t\tinline ostream &_dbg3(ostream &os,eit<is_iterable<T>::value,const T> &V) {\n\t\t\tos<<\"{\";\n\t\t\tbool ff=0;\n\t\t\tfor(const auto &E:V) _dbg2_5(ff?os<<\",\":os,E), ff=1;\n\t\t\treturn os<<\"}\";\n\t\t}\n\t\ttemplate<>\n\t\tinline ostream &_dbg3<string>(ostream &os,const string &x) {\n\t\t\treturn _out_str(os,x);\n\t\t}\n\t\ttemplate<>\n\t\tinline ostream &_dbg3<const char *>(ostream &os,const char *const &x) {\n\t\t\treturn _out_str(os,x);\n\t\t}\n\t\ttemplate<class T> inline ostream &_dbg2_5(ostream &os,const T &x) {\n\t\t\treturn _dbg3<T>(os,x);\n\t\t}\n\t\ttemplate<class T,typename... Args> ostream &_dbg2(ostream &os,vector<string>::iterator nm,const T &x,Args&&... args);\n\t\tinline ostream &_dbg2(ostream &os,vector<string>::iterator) { return os; }\n\t\ttemplate<typename... Args>\n\t\tinline ostream &_dbg2(ostream &os,vector<string>::iterator nm,const char *x,Args&&... args) {\n\t\t\treturn _dbg2(_dbg3<const char *>(os<<\"  \",x),nm+1,args...);\n\t\t}\n\t\ttemplate<class T,typename... Args>\n\t\tinline ostream &_dbg2(ostream &os,vector<string>::iterator nm,const T &x,Args&&... args) {\n\t\t\treturn _dbg2(_dbg3<T>(os<<\"  \"<<*nm<<\"=\",x),nm+1,args...);\n\t\t}\n\t\tvector<string> split(string s) {\n\t\t\tvector<string> Z;\n\t\t\tstring z=\"\";\n\t\t\ts+=',';\n\t\t\tint dep=0;\n\t\t\tfor(char c:s) {\n\t\t\t\tif(c==',' && !dep) Z.push_back(z),z=\"\";\n\t\t\t\telse z+=c;\n\t\t\t\tif(c=='(') ++dep;\n\t\t\t\tif(c==')') --dep;\n\t\t\t}\n\t\t\treturn Z;\n\t\t}\n\t\ttemplate<typename... Args> inline ostream &_dbg1(int ln,const string &nm,Args&&... args) {\n\t\t\tauto nms=split(nm);\n\t\t\treturn _dbg2(cerr<<\"L\"<<ln<<\":\",nms.begin(),args...)<<endl;\n\t\t}\n\t}\n\t#define dbg(...) dbg_ns::_dbg1(__LINE__,#__VA_ARGS__,__VA_ARGS__)\n\t#define sz(x) (int(x.size()))\n\t#define eprintf(...) fprintf(stderr,__VA_ARGS__)\n\t#define fi first\n\t#define se second\n\t#define pb push_back\n// END SUBLIME HAX\n// #include <bits/extc++.h>\n// using namespace __gnu_pbds;\ntypedef unsigned long long ull;\ntypedef long long ll;\ntypedef long double ld; //CARE\ntypedef complex<ld> pt;\nconst ld eps=(ld)1e-8;\nconst ld tau=2*(ld)acosl(-1);\nconst int inf=1e9+99;\nconst ll linf=1e18+99;\nconst int P=1e9+7;\n\n\n// #define int __int128\n// #define ll __int128\n\nint32_t H,W;\nint32_t n;\n\nconst int32_t N=8192;\nint D[N][N];\nvector<pair<int,int> > adj[N];\nvector<pair<int,int> > rels;\nvector<int> relx,rely;\nset<pair<int,int> > bads;\nset<int> bx,by;\nvector<pair<int,int> > bandx,bandy;\n\nint dec(int x,int y) {\n\tauto it=lower_bound(rels.begin(),rels.end(),pair<int,int>(x,y));\n\tif(it!=rels.end() && it->fi==x && it->se==y)\n\t\treturn int(it-rels.begin());\n\treturn -1;\n}\n\n\nint sL(int x) { // 0+..+x-1\n\treturn int(1LL*x*(x-1)/2%P);\n}\nint ww(int x) {\n\tstatic bool init=0;\n\tstatic int Z[1<<20];\n\tassert(1<=x && x<(1<<20));\n\tif(!init) {\n\t\tinit=1;\n\t\tassert(!sL(0) && !sL(1));\n\t\tfor(int i=1;i<(1<<20);i++) {\n\t\t\tZ[i]=sL(i)+Z[i-1];\n\t\t\tif(Z[i]>=P) Z[i]-=P;\n\t\t}\n\t}\n\treturn Z[x];\n}\nint qq(int x,int y) {\n\treturn int((1LL*x*sL(y)+1LL*y*sL(x))%P);\n}\ninline int _w(const pair<int,int> &P) {\n\tif(~P.se) return P.se-P.fi+1;\n\treturn 1;\n}\nint g_same(int w,int h) {\n\t// dbg(\"SS\",w,h);\n\t// dbg(ww(h));\n\treturn int((1LL*w*w%P*ww(h) + 1LL*h*h%P*ww(w))%P);\n}\nint g_same(int w,const pair<int,int> &X,const pair<int,int> &_X) {\n\tif(X==_X) return g_same(w,_w(X));\n\tint d0;\n\tint a= X.fi,b=~ X.se? X.se: X.fi;\n\tint c=_X.fi,d=~_X.se?_X.se:_X.fi;\n\tassert(a<=b && c<=d);\n\tif(b<c) d0=c-b; else\n\tif(d<a) d0=a-d; else\n\tassert(0);\n\tint h1=_w(X);\n\tint h2=_w(_X);\n\n\tll ZZ=d0;\n\tZZ=ZZ*w%P*h1%P*w%P*h2%P;\n\tZZ+=1LL*h1*h2%P*ww(w)*2; //dbg(h1,h2,w,ww(w));\n\tZZ+=1LL*w*w%P*qq(h1,h2);\n\t// dbg(\"HIT\",w,h1,h2,ZZ,d0);\n\treturn int(ZZ%P);\n}\nint close(const pair<int,int> &X,int x) {\n\tif(!~X.se) return X.fi;\n\tif(x<X.fi) return X.fi;\n\tif(x>X.se) return X.se;\n\tassert(0);\n}\nint g(const pair<int,int> &X,const pair<int,int> &Y,\n\tconst pair<int,int> &_X,const pair<int,int> &_Y) {\n\tif(!~ X.se && !~ Y.se && bads.count({ X.fi, Y.fi})) return 0;\n\tif(!~_X.se && !~_Y.se && bads.count({_X.fi,_Y.fi})) return 0;\n\n\tif(X==_X && Y==_Y && !~X.se && !~Y.se) return 0;\n\n\tif(X==_X && ~X.se) return g_same(_w(X),Y,_Y);\n\tif(Y==_Y && ~Y.se) return g_same(_w(Y),X,_X);\n\n\tpair<int,int>  Z={close(X,_X.fi),close(Y,_Y.fi)};\n\tpair<int,int> _Z={close(_X,X.fi),close(_Y,Y.fi)};\n\n\tint  Cx=_w(X);\n\tint  Cy=_w(Y);\n\tint  C=int(1LL*Cx*Cy%P);\n\tint _Cx=_w(_X);\n\tint _Cy=_w(_Y);\n\tint _C=int(1LL*_Cx*_Cy%P);\n\n\tint u=dec(Z.fi,Z.se); assert(~u);\n\tint v=dec(_Z.fi,_Z.se); assert(~v);\n\n\tll ZZ=D[u][v]; assert(ZZ<inf);\n\n\tZZ=ZZ*C%P*_C;\n\t// dbg(C,_C,ZZ,ZZ%P);\n\n\tZZ+=1LL*Cx*_Cx%P*qq(Cy,_Cy);\n\tZZ+=1LL*Cy*_Cy%P*qq(Cx,_Cx);\n\n\t// dbg(ZZ,ZZ%P);\n\n\treturn int(ZZ%P);\n}\n\n\nvoid dijk(int src,int *D) {\n\tfor(int u=0;u<n;u++) D[u]=inf;\n\tD[src]=0;\n\tpriority_queue<pair<int,int> > pq;\n\tpq.push({0,src});\n\tfor(;sz(pq);) {\n\t\tint u=pq.top().se;\n\t\tint d=-pq.top().fi;\n\t\tpq.pop();\n\t\tif(D[u]<d) continue;\n\t\tfor(const auto &P:adj[u]) if(d+P.se<D[P.fi]) {\n\t\t\tD[P.fi]=d+P.se;\n\t\t\tpq.push({-D[P.fi],P.fi});\n\t\t}\n\t}\n}\n\n\nint32_t main() {\n\t// for(int i=1;i<6;i++) dbg(i,ww(i));\n\tcin>>H>>W>>n;\n\tfor(int i=0;i<n;i++) {\n\t\tint32_t x,y; cin>>x>>y;\n\t\tbads.insert({x,y});\n\t\tbx.insert(x), by.insert(y);\n\t}\n\tfor(int _x:bx) for(int x=_x-1;x<=_x+1;x++)\n\t\tif(!sz(relx) || x>relx.back()) if(0<=x && x<H)\n\t\t\trelx.pb(x);\n\tfor(int _y:by) for(int y=_y-1;y<=_y+1;y++)\n\t\tif(!sz(rely) || y>rely.back()) if(0<=y && y<W)\n\t\t\trely.pb(y);\n\n\tfor(int x:relx) for(int y:rely) if(!bads.count({x,y})) rels.pb({x,y});\n\tsort(rels.begin(),rels.end());\n\tn=sz(rels);\n\tassert(n<N);\n\n\tfor(int i=1;i<sz(relx);i++) for(int y:rely) {\n\t\tint u=dec(relx[i-1],y);\n\t\tint v=dec(relx[i],y);\n\t\tint d=relx[i]-relx[i-1];\n\t\tif(~u && ~v) {\n\t\t\tadj[u].pb({v,d});\n\t\t\tadj[v].pb({u,d});\n\t\t}\n\t}\n\tfor(int i=1;i<sz(rely);i++) for(int x:relx) {\n\t\tint u=dec(x,rely[i-1]);\n\t\tint v=dec(x,rely[i]);\n\t\tint d=rely[i]-rely[i-1];\n\t\tif(~u && ~v) {\n\t\t\tadj[u].pb({v,d});\n\t\t\tadj[v].pb({u,d});\n\t\t}\n\t}\n\n\tfor(int i=0;i<n;i++) dijk(i,D[i]);\n\t// for(int i=0;i<n;i++) for(int j=0;j<n;j++) dbg(rels[i],rels[j],D[i][j]);\n\n\t{\n\t\tint pr=-1;\n\t\tfor(int x:bx) {\n\t\t\tif(x-1>pr) bandx.pb({pr+1,x-1});\n\t\t\tbandx.pb({x,-1});\n\t\t\tpr=x;\n\t\t}\n\t\tif(H-1>pr) bandx.pb({pr+1,H-1});\n\t}\n\t{\n\t\tint pr=-1;\n\t\tfor(int y:by) {\n\t\t\tif(y-1>pr) bandy.pb({pr+1,y-1});\n\t\t\tbandy.pb({y,-1});\n\t\t\tpr=y;\n\t\t}\n\t\tif(W-1>pr) bandy.pb({pr+1,W-1});\n\t}\n\n\tll Z=0;\n\tfor(const auto &BX:bandx) for(const auto &BY:bandy) {\n\t\tfor(const auto &_BX:bandx) for(const auto &_BY:bandy) {\n\t\t\tif(BX>_BX) continue;\n\t\t\tif(BX==_BX && BY>_BY) continue;\n\t\t\tint w=g(BX,BY,_BX,_BY);\n\t\t\t// if(w) dbg(BX,BY,_BX,_BY,w);\n\t\t\tZ+=w;\n\t\t}\n\t}\n\tcout<<int32_t(Z%P)<<endl;\n}\n\n\n\n\n\n\n\n\n\n\n\n"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\n\nusing std::pair;\nusing std::vector;\nusing std::string;\n\ntypedef long long ll;\ntypedef pair<int, int> pii;\n\n#define fst first\n#define snd second\n#define pb(a) push_back(a)\n#define mp(a, b) std::make_pair(a, b)\n#define debug(...) fprintf(stderr, __VA_ARGS__)\n\ntemplate <typename T> bool chkmax(T& a, T b) { return a < b ? a = b, 1 : 0; }\ntemplate <typename T> bool chkmin(T& a, T b) { return a > b ? a = b, 1 : 0; }\n\nconst int oo = 0x3f3f3f3f;\n\nstring procStatus() {\n    std::ifstream t(\"/proc/self/status\");\n    return string(std::istreambuf_iterator<char>(t), std::istreambuf_iterator<char>());\n}\n\ntemplate <typename T> T read(T& x) {\n    int f = 1; x = 0;\n    char ch = getchar();\n    for(;!isdigit(ch); ch = getchar()) if(ch == '-') f = -1;\n    for(; isdigit(ch); ch = getchar()) x = x * 10 + ch - 48;\n    return x *= f;\n}\n\nconst int P = 100;\nconst int N = 1000000;\nconst int mo = 1e9 + 7;\n\nconst int dx[] = { -1, 1, 0, 0 };\nconst int dy[] = { 0, 0, -1, 1 };\n\nint n, ans;\nint cx[N + 5], cy[N + 5];\nint ix[N + 5], iy[N + 5];\nint sx[N + 5], sy[N + 5], totX, totY;\n\ninline int size(int x, int y) {\n    return 1ll * sx[x] * sy[y] % mo;\n}\n\nint solve(int *cnt, int *id, int *s, int R, int C) {\n    int l = R - cnt[0], r = (1ll * R * C - n - l) % mo;\n\n    ++ s[0];\n    for(int i = 1; i < C; ++i) {\n        id[i] = id[i-1];\n\n        if(!cnt[i] && !cnt[i-1]) {\n            ans = (ans + 1ll * l * r) % mo;\n        } else {\n            ++ id[i];\n        }\n        ++ s[id[i]];\n        l = (l + R - cnt[i]) % mo;\n        r = (r + cnt[i] - R) % mo;\n    }\n    return id[C - 1] + 1;\n}\n\nint r, c;\nint dis[P + 5][P + 5];\nbool vis[P + 5][P + 5];\nint x[P + 5], y[P + 5];\n\nint main() {\n#ifdef Wearry\n    freopen(\"in\", \"r\", stdin);\n    freopen(\"out\", \"w\", stdout);\n#endif\n\n    read(r), read(c), read(n);\n    for(int i = 0; i < n; ++i) {\n        read(x[i]), read(y[i]);\n        ++ cx[x[i]], ++ cy[y[i]];\n    }\n\n    totY = solve(cy, iy, sy, r, c);\n    totX = solve(cx, ix, sx, c, r);\n\n    ans = ans * 2 % mo;\n    for(int i = 0; i < n; ++i) vis[ix[x[i]]][iy[y[i]]] = true;\n    for(int i = 0; i < totX; ++i) \n        for(int j = 0; j < totY; ++j) if(!vis[i][j]) {\n            std::queue<pii> q;\n            memset(dis, 0xff, sizeof dis);\n\n            dis[i][j] = 0;\n            q.push(mp(i, j));\n\n            while(!q.empty()) {\n                pii cur = q.front(); q.pop();\n\n                ans = (ans + 1ll * dis[cur.fst][cur.snd] * size(cur.fst, cur.snd) % mo * size(i, j)) % mo;\n\n                for(int d = 0; d < 4; ++ d) {\n                    pii nxt = mp(cur.fst + dx[d], cur.snd + dy[d]);\n\n                    if(nxt.fst >= 0 && nxt.fst < totX &&!~dis[nxt.fst][nxt.snd]\n                    && nxt.snd >= 0 && nxt.snd < totY && !vis[nxt.fst][nxt.snd]) {\n                        dis[nxt.fst][nxt.snd] = dis[cur.fst][cur.snd] + 1;\n                        q.push(nxt);\n                    }\n                }\n            }\n        }\n\n    printf(\"%lld\\n\", 1ll * ans * (mo + 1) / 2 % mo);\n\n    return 0;\n}\n"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\nusing namespace std;\n\nusing ll=long long;\n#define int ll\n\n#define rng(i,a,b) for(int i=int(a);i<int(b);i++)\n#define rep(i,b) rng(i,0,b)\n#define gnr(i,a,b) for(int i=int(b)-1;i>=int(a);i--)\n#define per(i,b) gnr(i,0,b)\n#define pb push_back\n#define eb emplace_back\n#define a first\n#define b second\n#define bg begin()\n#define ed end()\n#define all(x) x.bg,x.ed\n#ifdef LOCAL\n#define dmp(x) cerr<<__LINE__<<\" \"<<#x<<\" \"<<x<<endl\n#else\n#define dmp(x) void(0)\n#endif\n\ntemplate<class t,class u> void chmax(t&a,u b){if(a<b)a=b;}\ntemplate<class t,class u> void chmin(t&a,u b){if(b<a)a=b;}\n\ntemplate<class t> using vc=vector<t>;\ntemplate<class t> using vvc=vc<vc<t>>;\n\nusing pi=pair<int,int>;\nusing vi=vc<int>;\n\ntemplate<class t,class u>\nostream& operator<<(ostream& os,const pair<t,u>& p){\n\treturn os<<\"{\"<<p.a<<\",\"<<p.b<<\"}\";\n}\n\ntemplate<class t> ostream& operator<<(ostream& os,const vc<t>& v){\n\tos<<\"{\";\n\tfor(auto e:v)os<<e<<\",\";\n\treturn os<<\"}\";\n}\n\n#define mp make_pair\n#define mt make_tuple\n#define one(x) memset(x,-1,sizeof(x))\n#define zero(x) memset(x,0,sizeof(x))\n#ifdef LOCAL\nvoid dmpr(ostream&os){os<<endl;}\ntemplate<class T,class... Args>\nvoid dmpr(ostream&os,const T&t,const Args&... args){\n\tos<<t<<\" \";\n\tdmpr(os,args...);\n}\n#define dmp2(...) dmpr(cerr,\"Line:\",__LINE__,##__VA_ARGS__)\n#else\n#define dmp2(...) void(0)\n#endif\n\nusing uint=unsigned;\nusing ull=unsigned long long;\n\ntemplate<int i,class T>\nvoid print_tuple(ostream&,const T&){\n}\n\ntemplate<int i,class T,class H,class ...Args>\nvoid print_tuple(ostream&os,const T&t){\n\tif(i)os<<\",\";\n\tos<<get<i>(t);\n\tprint_tuple<i+1,T,Args...>(os,t);\n}\n\ntemplate<class ...Args>\nostream& operator<<(ostream&os,const tuple<Args...>&t){\n\tos<<\"{\";\n\tprint_tuple<0,tuple<Args...>,Args...>(os,t);\n\treturn os<<\"}\";\n}\n\nvoid print(ll x,int suc=1){\n\tcout<<x;\n\tif(suc==1)\n\t\tcout<<\"\\n\";\n\tif(suc==2)\n\t\tcout<<\" \";\n}\n\nll read(){\n\tll i;\n\tcin>>i;\n\treturn i;\n}\n\nvi readvi(int n,int off=0){\n\tvi v(n);\n\trep(i,n)v[i]=read()+off;\n\treturn v;\n}\n\ntemplate<class T>\nvoid print(const vector<T>&v,int suc=1){\n\trep(i,v.size())\n\t\tprint(v[i],i==int(v.size())-1?suc:2);\n}\n\nstring readString(){\n\tstring s;\n\tcin>>s;\n\treturn s;\n}\n\ntemplate<class T>\nT sq(const T& t){\n\treturn t*t;\n}\n\n//#define CAPITAL\nvoid yes(bool ex=true){\n\t#ifdef CAPITAL\n\tcout<<\"YES\"<<endl;\n\t#else\n\tcout<<\"Yes\"<<endl;\n\t#endif\n\tif(ex)exit(0);\n}\nvoid no(bool ex=true){\n\t#ifdef CAPITAL\n\tcout<<\"NO\"<<endl;\n\t#else\n\tcout<<\"No\"<<endl;\n\t#endif\n\tif(ex)exit(0);\n}\n\nconstexpr ll ten(int n){\n\treturn n==0?1:ten(n-1)*10;\n}\n\nconst ll infLL=LLONG_MAX/3;\n\n#ifdef int\nconst int inf=infLL;\n#else\nconst int inf=INT_MAX/2-100;\n#endif\n\nint topbit(signed t){\n\treturn t==0?-1:31-__builtin_clz(t);\n}\nint topbit(ll t){\n\treturn t==0?-1:63-__builtin_clzll(t);\n}\nint botbit(signed a){\n\treturn a==0?32:__builtin_ctz(a);\n}\nint botbit(ll a){\n\treturn a==0?64:__builtin_ctzll(a);\n}\nint popcount(signed t){\n\treturn __builtin_popcount(t);\n}\nint popcount(ll t){\n\treturn __builtin_popcountll(t);\n}\nbool ispow2(int i){\n\treturn i&&(i&-i)==i;\n}\nint mask(int i){\n\treturn (int(1)<<i)-1;\n}\n\nbool inc(int a,int b,int c){\n\treturn a<=b&&b<=c;\n}\n\ntemplate<class t> void mkuni(vc<t>&v){\n\tsort(all(v));\n\tv.erase(unique(all(v)),v.ed);\n}\n\nll rand_int(ll l, ll r) { //[l, r]\n\t#ifdef LOCAL\n\tstatic mt19937_64 gen;\n\t#else\n    static random_device rd;\n    static mt19937_64 gen(rd());\n    #endif\n    return uniform_int_distribution<ll>(l, r)(gen);\n}\n\ntemplate<class t>\nint lwb(const vc<t>&v,const t&a){\n\treturn lower_bound(all(v),a)-v.bg;\n}\n\nusing uint=unsigned;\nusing ull=unsigned long long;\n\n//initfact();\n//const uint mod=998244353;\nconst uint mod=1000000007;\n//uint mod=1;\nstruct mint{\n\tuint v;\n\tmint(ll vv=0){s(vv%mod+mod);}\n\tmint& s(uint vv){\n\t\tv=vv<mod?vv:vv-mod;\n\t\treturn *this;\n\t}\n\tmint operator-()const{return mint()-*this;}\n\tmint& operator+=(const mint&rhs){return s(v+rhs.v);}\n\tmint&operator-=(const mint&rhs){return s(v+mod-rhs.v);}\n\tmint&operator*=(const mint&rhs){\n\t\tv=ull(v)*rhs.v%mod;\n\t\treturn *this;\n\t}\n\tmint&operator/=(const mint&rhs){return *this*=rhs.inv();}\n\tmint operator+(const mint&rhs)const{return mint(*this)+=rhs;}\n\tmint operator-(const mint&rhs)const{return mint(*this)-=rhs;}\n\tmint operator*(const mint&rhs)const{return mint(*this)*=rhs;}\n\tmint operator/(const mint&rhs)const{return mint(*this)/=rhs;}\n\tmint pow(int n)const{\n\t\tmint res(1),x(*this);\n\t\twhile(n){\n\t\t\tif(n&1)res*=x;\n\t\t\tx*=x;\n\t\t\tn>>=1;\n\t\t}\n\t\treturn res;\n\t}\n\tmint inv()const{return pow(mod-2);}\n\t/*mint inv()const{\n\t\tint x,y;\n\t\tint g=extgcd(v,mod,x,y);\n\t\tassert(g==1);\n\t\tif(x<0)x+=mod;\n\t\treturn mint(x);\n\t}*/\n\tfriend ostream& operator<<(ostream&os,const mint&m){\n\t\treturn os<<m.v;\n\t}\n\tbool operator<(const mint&r)const{return v<r.v;}\n\tbool operator==(const mint&r)const{return v==r.v;}\n};\n\nconst int vmax=(1<<21)+10;\nmint fact[vmax],finv[vmax],invs[vmax];\nvoid initfact(){\n\tfact[0]=1;\n\trng(i,1,vmax){\n\t\tfact[i]=fact[i-1]*i;\n\t}\n\tfinv[vmax-1]=fact[vmax-1].inv();\n\tfor(int i=vmax-2;i>=0;i--){\n\t\tfinv[i]=finv[i+1]*(i+1);\n\t}\n\tfor(int i=vmax-1;i>=1;i--){\n\t\tinvs[i]=finv[i]*fact[i-1];\n\t}\n}\nmint choose(int n,int k){\n\treturn fact[n]*finv[n-k]*finv[k];\n}\nmint binom(int a,int b){\n\treturn fact[a+b]*finv[a]*finv[b];\n}\nmint catalan(int n){\n\treturn binom(n,n)-(n-1>=0?binom(n-1,n+1):0);\n}\n\nvvc<int> getdist(const vc<string>&z,int sr,int sc){\n\tint n=z.size(),m=z[0].size();\n\tvvc<int> dist(n,vi(m,-1));\n\tqueue<tuple<int,int,int>> q;\n\tauto rc=[&](int i,int j,int d){\n\t\tif(inc(0,i,n-1)&&inc(0,j,m-1)&&z[i][j]=='.'){\n\t\t\tif(dist[i][j]==-1){\n\t\t\t\tdist[i][j]=d;\n\t\t\t\tq.emplace(i,j,d);\n\t\t\t}\n\t\t}\n\t};\n\trc(sr,sc,0);\n\twhile(q.size()){\n\t\tint i,j,d;tie(i,j,d)=q.front();q.pop();\n\t\tconst int dyx[]{-1,0,1,0,-1};\n\t\trep(k,4)\n\t\t\trc(i+dyx[k],j+dyx[k+1],d+1);\n\t}\n\treturn dist;\n}\n\nsigned main(){\n\tcin.tie(0);\n\tios::sync_with_stdio(0);\n\tcout<<fixed<<setprecision(20);\n\t\n\tinitfact();\n\t\n\tint h,w;cin>>h>>w;\n\tint n;cin>>n;\n\t\n\tvi rs{0,h},cs{0,w};\n\tvc<pi> obs;\n\trep(i,n){\n\t\tint r,c;cin>>r>>c;\n\t\trs.pb(r);\n\t\trs.pb(r+1);\n\t\tcs.pb(c);\n\t\tcs.pb(c+1);\n\t\tobs.eb(r,c);\n\t}\n\t\n\tmkuni(rs);\n\tmkuni(cs);\n\t\n\tmint tot=h*w-n;\n\t\n\tconst auto waf=[&](mint a,mint b,mint c,mint d){\n\t\treturn a*d*(d+1)*(d*2+1)*invs[6]+b*d*(d+1)*invs[2]+c*d;\n\t};\n\t\n\tmint ans;\n\trep(_,2){\n\t\trep(i,(int)rs.size()-1){\n\t\t\tint a=rs[i],b=rs[i+1];\n\t\t\tmint p=0;\n\t\t\tfor(auto o:obs)if(o.a<a)p+=1;\n\t\t\tans+=waf(-mint(w)*w,mint(w)*(tot+p+p),-p*(tot+p),b-1);\n\t\t\tans-=waf(-mint(w)*w,mint(w)*(tot+p+p),-p*(tot+p),a);\n\t\t}\n\t\t\n\t\tswap(rs,cs);\n\t\tswap(h,w);\n\t\tfor(auto&o:obs)\n\t\t\tswap(o.a,o.b);\n\t}\n\t\n\tint r=rs.size()-1,c=cs.size()-1;\n\tvc<string> z(r,string(c,'.'));\n\tvvc<mint> cnt(r,vc<mint>(c));\n\trep(i,r)rep(j,c)\n\t\tcnt[i][j]=(rs[i+1]-rs[i])*(cs[j+1]-cs[j]);\n\tfor(auto o:obs)\n\t\tz[lwb(rs,o.a)][lwb(cs,o.b)]='#';\n\t\n\tdmp(ans);\n\tdmp(cnt);\n\tdmp(z);\n\t\n\tmint tmp;\n\trep(i,r)rep(j,c)if(z[i][j]=='.'){\n\t\tauto d=getdist(z,i,j);\n\t\trep(p,r)rep(q,c)\n\t\t\tif(d[p][q]!=-1)\n\t\t\t\ttmp+=cnt[i][j]*cnt[p][q]*d[p][q];\n\t}\n\t\n\tans+=tmp/2;\n\t\n\tcout<<ans<<endl;\n}\n"
  },
  {
    "language": "C++",
    "code": "#include <iostream>\n#include <vector>\n#include <map>\n#include <queue>\n#include <algorithm>\n#include <cstring>\nusing namespace std;\n\n#define REP(i, s) for (int i = 0; i < s; ++i)\n#define ALL(v) (v.begin(), v.end())\n#define COUT(x) cout << #x << \" = \" << (x) << \" (L\" << __LINE__ << \")\" << endl\n#define EACH(i, s) for (__typeof__((s).begin()) i = (s).begin(); i != (s).end(); ++i)\n\ntemplate<class T> inline bool chmax(T& a, T b) { if (a < b) { a = b; return 1; } return 0; }\ntemplate<class T> inline bool chmin(T& a, T b) { if (a > b) { a = b; return 1; } return 0; }\ntemplate<class T1, class T2> ostream& operator << (ostream &s, pair<T1, T2> P)\n{\n\treturn s << '<' << P.first << \", \" << P.second << '>';\n}\ntemplate<class T> ostream& operator << (ostream &s, vector<T> P)\n{\n\tfor (int i = 0; i < P.size(); ++i) { if (i > 0) { s << \" \"; } s << P[i]; } return s;\n}\ntemplate<class T> ostream& operator << (ostream &s, vector<vector<T> > P)\n{\n\tfor (int i = 0; i < P.size(); ++i) { s << endl << P[i]; } return s << endl;\n}\n\nconst int MOD = 1000000007;\ninline long long mod(long long a, long long m) { return (a % m + m) % m; }\nstruct Fp {\n\tint MOD = 1000000007;\n\tlong long val;\n\n\tFp() : val(0) {}\n\tFp(long long val_) { this->val = mod(val_, MOD); }\n\tFp operator = (long long val_) { this->val = mod(val_, MOD); return *this; }\n\tinline Fp operator - () { return mod(-val, MOD); }\n\tinline const Fp& operator += (const Fp &x);\n\tinline const Fp& operator -= (const Fp &x);\n\tinline const Fp& operator *= (const Fp &x);\n\tinline const Fp& operator /= (const Fp &x);\n};\n\ninline bool operator == (Fp x, Fp y) { return x.val == y.val; }\ninline bool operator != (Fp x, Fp y) { return !(x == y); }\n\nostream &operator << (ostream &os, Fp x) { return os << x.val; }\nistream &operator >> (istream &is, Fp &x) { is >> x; return is; }\n\ninline Fp operator + (Fp x, Fp y) { return mod(x.val + y.val, x.MOD); }\ninline Fp operator - (Fp x, Fp y) { return mod(x.val - y.val, x.MOD); }\ninline Fp operator * (Fp x, Fp y) { return mod(x.val * y.val, x.MOD); }\ninline Fp operator / (Fp x, Fp y) {\n\tlong long a = y.val, b = x.MOD, u = 1, v = 0;\n\twhile (b) {\n\t\tlong long t = a / b;\n\t\ta -= t*b; swap(a, b);\n\t\tu -= t*v; swap(u, v);\n\t}\n\treturn x * u;\n}\ninline Fp abs(Fp a) { return a; }\ninline Fp fpow(Fp a, long long n) {\n\tif (n == 0) return Fp(1);\n\tFp t = fpow(a, n / 2);\n\tt = t * t; if (n & 1) t = t * a;\n\treturn t;\n}\ninline const Fp& Fp::operator += (const Fp &x) { *this = *this + x; return *this; }\ninline const Fp& Fp::operator -= (const Fp &x) { *this = *this - x; return *this; }\ninline const Fp& Fp::operator *= (const Fp &x) { *this = *this * x; return *this; }\ninline const Fp& Fp::operator /= (const Fp &x) { *this = *this / x; return *this; }\n\n// calc comb (small n, r ver)\nconst int FACT_MAX = 210000;\nstatic Fp fp_fact_val[FACT_MAX];\n\nvoid calcFact(int MAX = FACT_MAX) {\n\tfp_fact_val[0] = 1;\n\tfor (int val = 1; val < MAX; ++val) {\n\t\tfp_fact_val[val] = fp_fact_val[val - 1] * val;\n\t}\n}\n\nFp fact(int n) {\n\treturn fp_fact_val[n];\n}\n\nFp com(int n, int r) {\n\treturn fact(n) / fact(r) / fact(n - r);\n}\n\nint dx[4] = {1, 0, -1, 0};\nint dy[4] = {0, 1, 0, -1};\n\nlong long H, W, N;\nlong long bx[210], by[210];\nvector<long long> altx, alty;\nlong long nH, nW;\n\nlong long xnum[1100000], ynum[1100000];\n\nbool cb[210][210];\nlong long dist[210][210];\n\ntypedef pair<int, int> pint;\n\nlong long subsolve() {\n\t//COUT(nH); COUT(nW); COUT(altx); COUT(alty);\n\n\tfor (int x = 0; x < nH - 1; ++x) {\n\t\tfor (int y = 0; y < nW - 1; ++y) {\n\t\t\t//cout << cb[x][y];\n\t\t}\n\t\t//cout << endl;\n\t}\n\n  long long res = 0;\n\tfor (int x = 0; x < nH - 1; ++x) {\n\t\tfor (int y = 0; y < nW - 1; ++y) {\n\t\t\tif (cb[x][y]) continue;\n\t\t\tmemset(dist, -1, sizeof(dist));\n\t\t\tqueue<pint> que;\n\t\t\tque.push(pint(x, y));\n\t\t\tdist[x][y] = 0;\n\t\t\twhile (!que.empty()) {\n\t\t\t\tpint cur = que.front();\n\t\t\t\tque.pop();\n\t\t\t\tfor (int dir = 0; dir < 4; ++dir) {\n\t\t\t\t\tint nx = cur.first + dx[dir];\n\t\t\t\t\tint ny = cur.second + dy[dir];\n\t\t\t\t\tif (nx < 0 || nx >= nH || ny < 0 || ny >= nW) continue;\n\t\t\t\t\tif (cb[nx][ny]) continue;\n\t\t\t\t\tif (dist[nx][ny] == -1) {\n\t\t\t\t\t\tdist[nx][ny] = dist[cur.first][cur.second] + 1;\n\t\t\t\t\t\tque.push(pint(nx, ny));\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t}\n\t\t\t\n\t\t\tfor (int nx = 0; nx < nH - 1; ++nx) {\n\t\t\t\tfor (int ny = 0; ny < nW - 1; ++ny) {\n\t\t\t\t\tif (nW * nx + ny <= nW * x + y) continue;\n\t\t\t\t\tif (dist[nx][ny] == -1) continue;\n\t\t\t\t\tif (cb[nx][ny]) continue;\n\n\t\t\t\t\tlong long ss = ((long long)(altx[x + 1] - altx[x]) * (alty[y + 1] - alty[y])) % MOD;\n\t\t\t\t\tlong long st = ((long long)(altx[nx + 1] - altx[nx]) * (alty[ny + 1] - alty[ny])) % MOD;\n\t\t\t\t\tres += (dist[nx][ny] % MOD) * ss % MOD * st % MOD;\n\n\t\t\t\t\t//cout << pint(x, y) << \", \" << pint(nx, ny) << \": \" << dist[nx][ny] << \", \" << ss << \", \" << st << endl;\n\t\t\t\t}\n\t\t\t}\n\t\t\t\n\t\t}\n\t}\n\t//COUT(res);\n\t//res /= 2;\n\n\treturn res;\n}\n\nFp solve() {\n  memset(xnum, 0, sizeof(xnum));\n  memset(ynum, 0, sizeof(ynum));\n\taltx.clear();\n\talty.clear();\n  altx.push_back(0);\n  altx.push_back(H);\n  alty.push_back(0);\n  alty.push_back(W);\n  for (int i = 0; i < N; ++i) {\n\t\taltx.push_back(bx[i]);\n\t\taltx.push_back(bx[i] + 1);\n\t\talty.push_back(by[i]);\n\t\talty.push_back(by[i] + 1);\n\t\txnum[bx[i]]++;\n\t\tynum[by[i]]++;\n  }\n  sort(altx.begin(), altx.end());\n  sort(alty.begin(), alty.end());\n  altx.erase(unique(altx.begin(), altx.end()), altx.end());\n  alty.erase(unique(alty.begin(), alty.end()), alty.end());\n  nH = altx.size();\n  nW = alty.size();\n\n  memset(cb, 0, sizeof(cb));\n  for (int i = 0; i < N; ++i) {\n\t\tint itx = lower_bound(altx.begin(), altx.end(), bx[i]) - altx.begin();\n\t\tint ity = lower_bound(alty.begin(), alty.end(), by[i]) - alty.begin();\n\t\tcb[itx][ity] = true;\n  }\n\n  long long all = (long long)H * W - N;\n  Fp add = 0;\n  long long width = W;\n\tlong long num_comped = 0;\n  long long sum = width - xnum[0];\n  for (int i = 1; i < H; ++i) {\n\t\tif (xnum[i] == 0 && xnum[i-1] == 0) {   // i-1 -> i\n\t\t\tFp up = sum - width * num_comped;\n\t\t\tFp down = all - sum;\n\t\t\tadd += up * down;\n\t\t}\n\t\tsum += width - xnum[i];\n  }\n  long long height = H - num_comped;\n  all -= width * num_comped;\n  num_comped = 0;\n  sum = height - ynum[0];\n  for (int i = 1; i < W; ++i) {\n\t\tif (ynum[i] == 0 && ynum[i-1] == 0) {   // i-1 -> i\n\t\t\tFp left = sum - height * num_comped;\n\t\t\tFp right = all - sum;\n\t\t\tadd += left * right;\n\t\t}\n\t\tsum += height - ynum[i];\n  }\n\n  Fp comp = subsolve();\n  Fp res = comp + add;\n\n\t//COUT(add);\n\n  return res;\n}\n\nint main() {\n  while (cin >> H >> W >> N) {\n\t\tfor (int i = 0; i < N; ++i) cin >> bx[i] >> by[i];\n\t\tcout << solve() << endl;\n  }\n}\n"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\nusing namespace std;\n\ntypedef pair<int, int> pii;\ntypedef long long ll;\ntypedef vector<int> vi;\n\n#define pb push_back\n#define eb emplace_back\n#define mp make_pair\n#define fi first\n#define se second\n#define rep(i,n) rep2(i,0,n)\n#define rep2(i,m,n) for(int i=m;i<(n);i++)\n#define ALL(c) (c).begin(),(c).end()\n\nconst ll MOD = 1000000007;\nconst int MN = 70;\nconst int MX = 1000010;\nconst int dx[] = {1, -1, 0, 0};\nconst int dy[] = {0, 0, 1, -1};\n\nbool ex[MX], ey[MX];\nll f[MN][MN];\n\nint main() {\n\tint H, W, N;\n\tcin >> H >> W >> N;\n\n\tvector<pii> pt(N);\n\n\tvi xs, ys;\n\txs.pb(0); xs.pb(H); ys.pb(0); ys.pb(W);\n\n\trep(i, N) {\n\t\tcin >> pt[i].fi >> pt[i].se;\n\t\tex[pt[i].fi] = ey[pt[i].se] = 1;\n\t\txs.pb(pt[i].fi); xs.pb(pt[i].fi + 1);\n\t\tys.pb(pt[i].se); ys.pb(pt[i].se + 1);\n\t}\n\n\tsort(ALL(xs)); sort(ALL(ys));\n\txs.erase(unique(ALL(xs)), xs.end()); ys.erase(unique(ALL(ys)), ys.end());\n\n\tint sx = xs.size(), sy = ys.size();\n\n\trep(i, N) {\n\t\tint p = lower_bound(ALL(xs), pt[i].fi) - xs.begin();\n\t\tint q = lower_bound(ALL(ys), pt[i].se) - ys.begin();\n\t\tf[p][q] = -1;\n\t}\n\n\trep(i, sx-1) {\n\t\trep(j, sy-1) {\n\t\t\tif (f[i][j] != -1) {\n\t\t\t\tf[i][j] = (ll)(xs[i+1] - xs[i]) * (ys[j+1] - ys[j]);\n\t\t\t}\n\t\t}\n\t}\n\n\tll ret = 0;\n\trep(i, sx-1) {\n\t\trep(j, sy-1) if (f[i][j] != -1) {\n\t\t\tqueue<pii> que;\n\t\t\tque.push(mp(i, j));\n\n\t\t\tvector<vi> d(sx, vi(sy));\n\t\t\trep(ii, sx) rep(jj, sy) d[ii][jj] = -1;\n\t\t\td[i][j] = 0;\n\n\t\t\twhile (!que.empty()) {\n\t\t\t\tpii p = que.front(); que.pop();\n\t\t\t\tint x = p.fi, y = p.se;\n\t\t\t\trep(dir, 4) {\n\t\t\t\t\tint nx = x + dx[dir], ny = y + dy[dir];\n\t\t\t\t\tif (nx >= 0 && nx < sx-1 && ny >= 0 && ny < sy-1 && f[nx][ny] != -1 && d[nx][ny] == -1) {\n\t\t\t\t\t\td[nx][ny] = d[x][y] + 1;\n\t\t\t\t\t\tque.push(mp(nx, ny));\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t}\n\n\t\t\trep(p, sx) {\n\t\t\t\trep(q, sy) {\n\t\t\t\t\tif (d[p][q] != -1) {\n\t\t\t\t\t\tret = (ret + f[p][q] * f[i][j] % MOD * d[p][q]) % MOD;\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t}\n\n\tret = (MOD + 1) / 2 * ret % MOD;\n\n\tsort(ALL(pt));\n\tint p = 0;\n\n\trep(i, H-1) {\n\t\tif (!ex[i] && !ex[i+1]) {\n\t\t\twhile (p < N && pt[p].fi <= i) {\n\t\t\t\t++p;\n\t\t\t}\n\t\t\tll nx = ((ll)W * (i + 1) - p) % MOD;\n\t\t\tll ny = ((ll)W * (H - i - 1) - (N - p)) % MOD;\n\t\t\tret = (ret + nx * ny) % MOD;\n\t\t}\n\t}\n\n\tp = 0;\n\trep(i, N) swap(pt[i].fi, pt[i].se);\n\tsort(ALL(pt));\n\n\trep(i, W-1) {\n\t\tif (!ey[i] && !ey[i+1]) {\n\t\t\twhile (p < N && pt[p].fi <= i) {\n\t\t\t\t++p;\n\t\t\t}\n\t\t\tll nx = ((ll)H * (i + 1) - p) % MOD;\n\t\t\tll ny = ((ll)H * (W - i - 1) - (N - p)) % MOD;\n\t\t\tret = (ret + nx * ny) % MOD;\t\n\t\t}\n\t}\n\n\tcout << ret << endl;\n\treturn 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include <iostream>\n#include <vector>\n#include <map>\n#include <queue>\n#include <algorithm>\n#include <cstring>\nusing namespace std;\n\n#define REP(i, s) for (int i = 0; i < s; ++i)\n#define ALL(v) (v.begin(), v.end())\n#define COUT(x) cout << #x << \" = \" << (x) << \" (L\" << __LINE__ << \")\" << endl\n#define EACH(i, s) for (__typeof__((s).begin()) i = (s).begin(); i != (s).end(); ++i)\n\ntemplate<class T> inline bool chmax(T& a, T b) { if (a < b) { a = b; return 1; } return 0; }\ntemplate<class T> inline bool chmin(T& a, T b) { if (a > b) { a = b; return 1; } return 0; }\ntemplate<class T1, class T2> ostream& operator << (ostream &s, pair<T1, T2> P)\n{\n\treturn s << '<' << P.first << \", \" << P.second << '>';\n}\ntemplate<class T> ostream& operator << (ostream &s, vector<T> P)\n{\n\tfor (int i = 0; i < P.size(); ++i) { if (i > 0) { s << \" \"; } s << P[i]; } return s;\n}\ntemplate<class T> ostream& operator << (ostream &s, vector<vector<T> > P)\n{\n\tfor (int i = 0; i < P.size(); ++i) { s << endl << P[i]; } return s << endl;\n}\n\nconst int MOD = 1000000007;\ninline long long mod(long long a, long long m) { return (a % m + m) % m; }\nstruct Fp {\n\tint MOD = 1000000007;\n\tlong long val;\n\n\tFp() : val(0) {}\n\tFp(long long val_) { this->val = mod(val_, MOD); }\n\tFp operator = (long long val_) { this->val = mod(val_, MOD); return *this; }\n\tinline Fp operator - () { return mod(-val, MOD); }\n\tinline const Fp& operator += (const Fp &x);\n\tinline const Fp& operator -= (const Fp &x);\n\tinline const Fp& operator *= (const Fp &x);\n\tinline const Fp& operator /= (const Fp &x);\n};\n\ninline bool operator == (Fp x, Fp y) { return x.val == y.val; }\ninline bool operator != (Fp x, Fp y) { return !(x == y); }\n\nostream &operator << (ostream &os, Fp x) { return os << x.val; }\nistream &operator >> (istream &is, Fp &x) { is >> x; return is; }\n\ninline Fp operator + (Fp x, Fp y) { return mod(x.val + y.val, x.MOD); }\ninline Fp operator - (Fp x, Fp y) { return mod(x.val - y.val, x.MOD); }\ninline Fp operator * (Fp x, Fp y) { return mod(x.val * y.val, x.MOD); }\ninline Fp operator / (Fp x, Fp y) {\n\tlong long a = y.val, b = x.MOD, u = 1, v = 0;\n\twhile (b) {\n\t\tlong long t = a / b;\n\t\ta -= t*b; swap(a, b);\n\t\tu -= t*v; swap(u, v);\n\t}\n\treturn x * u;\n}\ninline Fp abs(Fp a) { return a; }\ninline Fp fpow(Fp a, long long n) {\n\tif (n == 0) return Fp(1);\n\tFp t = fpow(a, n / 2);\n\tt = t * t; if (n & 1) t = t * a;\n\treturn t;\n}\ninline const Fp& Fp::operator += (const Fp &x) { *this = *this + x; return *this; }\ninline const Fp& Fp::operator -= (const Fp &x) { *this = *this - x; return *this; }\ninline const Fp& Fp::operator *= (const Fp &x) { *this = *this * x; return *this; }\ninline const Fp& Fp::operator /= (const Fp &x) { *this = *this / x; return *this; }\n\n// calc comb (small n, r ver)\nconst int FACT_MAX = 210000;\nstatic Fp fp_fact_val[FACT_MAX];\n\nvoid calcFact(int MAX = FACT_MAX) {\n\tfp_fact_val[0] = 1;\n\tfor (int val = 1; val < MAX; ++val) {\n\t\tfp_fact_val[val] = fp_fact_val[val - 1] * val;\n\t}\n}\n\nFp fact(int n) {\n\treturn fp_fact_val[n];\n}\n\nFp com(int n, int r) {\n\treturn fact(n) / fact(r) / fact(n - r);\n}\n\nint dx[4] = {1, 0, -1, 0};\nint dy[4] = {0, 1, 0, -1};\n\nlong long H, W, N;\nlong long bx[210], by[210];\nvector<long long> altx, alty;\nlong long nH, nW;\n\nlong long xnum[1100000], ynum[1100000];\n\nbool cb[210][210];\nlong long dist[210][210];\n\ntypedef pair<int, int> pint;\n\nFp subsolve() {\n\t//COUT(nH); COUT(nW); COUT(altx); COUT(alty);\n\n\tfor (int x = 0; x < nH - 1; ++x) {\n\t\tfor (int y = 0; y < nW - 1; ++y) {\n\t\t\t//cout << cb[x][y];\n\t\t}\n\t\t//cout << endl;\n\t}\n\n  Fp res = 0;\n\tfor (int x = 0; x < nH - 1; ++x) {\n\t\tfor (int y = 0; y < nW - 1; ++y) {\n\t\t\tif (cb[x][y]) continue;\n\t\t\tmemset(dist, -1, sizeof(dist));\n\t\t\tqueue<pint> que;\n\t\t\tque.push(pint(x, y));\n\t\t\tdist[x][y] = 0;\n\t\t\twhile (!que.empty()) {\n\t\t\t\tpint cur = que.front();\n\t\t\t\tque.pop();\n\t\t\t\tfor (int dir = 0; dir < 4; ++dir) {\n\t\t\t\t\tint nx = cur.first + dx[dir];\n\t\t\t\t\tint ny = cur.second + dy[dir];\n\t\t\t\t\tif (nx < 0 || nx >= H || ny < 0 || ny >= W) continue;\n\t\t\t\t\tif (cb[nx][ny]) continue;\n\t\t\t\t\tif (dist[nx][ny] == -1) {\n\t\t\t\t\t\tdist[nx][ny] = dist[cur.first][cur.second] + 1;\n\t\t\t\t\t\tque.push(pint(nx, ny));\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t}\n\t\t\t\n\t\t\tfor (int nx = 0; nx < nH - 1; ++nx) {\n\t\t\t\tfor (int ny = 0; ny < nW - 1; ++ny) {\n\t\t\t\t\t//if (nW * nx + ny <= nW * x + y) continue;\n\t\t\t\t\tif (dist[nx][ny] == -1) continue;\n\t\t\t\t\tif (cb[nx][ny]) continue;\n\n\t\t\t\t\tlong long ss = ((long long)(altx[x + 1] - altx[x]) * (alty[y + 1] - alty[y])) % MOD;\n\t\t\t\t\tlong long st = ((long long)(altx[nx + 1] - altx[nx]) * (alty[ny + 1] - alty[ny])) % MOD;\n\t\t\t\t\tres += Fp(dist[nx][ny]) * ss * st;\n\n\t\t\t\t\t//cout << pint(x, y) << \", \" << pint(nx, ny) << \": \" << dist[nx][ny] << \", \" << ss << \", \" << st << endl;\n\t\t\t\t}\n\t\t\t}\n\t\t\t\n\t\t}\n\t}\n\t//COUT(res);\n\tres /= 2;\n\n\treturn res;\n}\n\nFp solve() {\n  memset(xnum, 0, sizeof(xnum));\n  memset(ynum, 0, sizeof(ynum));\n\taltx.clear();\n\talty.clear();\n  altx.push_back(0);\n  altx.push_back(H);\n  alty.push_back(0);\n  alty.push_back(W);\n  for (int i = 0; i < N; ++i) {\n\t\taltx.push_back(bx[i]);\n\t\taltx.push_back(bx[i] + 1);\n\t\talty.push_back(by[i]);\n\t\talty.push_back(by[i] + 1);\n\t\txnum[bx[i]]++;\n\t\tynum[by[i]]++;\n  }\n  sort(altx.begin(), altx.end());\n  sort(alty.begin(), alty.end());\n  altx.erase(unique(altx.begin(), altx.end()), altx.end());\n  alty.erase(unique(alty.begin(), alty.end()), alty.end());\n  nH = altx.size();\n  nW = alty.size();\n\n  memset(cb, 0, sizeof(cb));\n  for (int i = 0; i < N; ++i) {\n\t\tint itx = lower_bound(altx.begin(), altx.end(), bx[i]) - altx.begin();\n\t\tint ity = lower_bound(alty.begin(), alty.end(), by[i]) - alty.begin();\n\t\tcb[itx][ity] = true;\n  }\n\n  long long all = (long long)H * W - N;\n  Fp add = 0;\n  long long width = W;\n\tlong long num_comped = 0;\n  long long sum = width - xnum[0];\n  for (int i = 1; i < H; ++i) {\n\t\tif (xnum[i] == 0 && xnum[i-1] == 0) {   // i-1 -> i\n\t\t\tFp up = sum - width * num_comped;\n\t\t\tFp down = all - sum;\n\t\t\tadd += up * down;\n\t\t}\n\t\tsum += width - xnum[i];\n  }\n  long long height = H - num_comped;\n  all -= width * num_comped;\n  num_comped = 0;\n  sum = height - ynum[0];\n  for (int i = 1; i < W; ++i) {\n\t\tif (ynum[i] == 0 && ynum[i-1] == 0) {   // i-1 -> i\n\t\t\tFp left = sum - height * num_comped;\n\t\t\tFp right = all - sum;\n\t\t\tadd += left * right;\n\t\t}\n\t\tsum += height - ynum[i];\n  }\n\n  Fp comp = subsolve();\n  Fp res = comp + add;\n\n\t//COUT(add);\n\n  return res;\n}\n\nint main() {\n  while (cin >> H >> W >> N) {\n\t\tfor (int i = 0; i < N; ++i) cin >> bx[i] >> by[i];\n\t\tcout << solve() << endl;\n  }\n}\n"
  },
  {
    "language": "C++",
    "code": "#include <cstdio>\n#include <algorithm>\n#include <vector>\n#include <queue>\nusing namespace std;\ntypedef long long i64;\nconst i64 MOD = 1000000007;\nvoid ADD(i64& a, const i64& b) { a = (a + b) % MOD; }\n\ni64 H, W;\nint N, X[30], Y[30];\nint hist[1001001];\n\ni64 precomp(i64 H, i64 W, int *Y)\n{\n    for (int i = 0; i < H; ++i) hist[i] = 0;\n    for (int i = 0; i < N; ++i) hist[Y[i]]++;\n\n    i64 tot = (H * W - N) % MOD;\n    i64 suml = 0;\n    i64 ret = 0;\n    for (int i = 1; i < H; ++i) {\n        ADD(suml, W - hist[i - 1]);\n        i64 sumr = (MOD + tot - suml) % MOD;\n        if (hist[i - 1] == 0 && hist[i] == 0) {\n            ADD(ret, suml * sumr);\n        }\n    }\n    return ret;\n}\nvector<pair<int, int>> summarize(int H, int *Y)\n{\n    vector<int> ys;\n    for (int i = 0; i < N; ++i) ys.push_back(Y[i]);\n    sort(ys.begin(), ys.end());\n    ys.erase(unique(ys.begin(), ys.end()), ys.end());\n    \n    vector<pair<int, int>> ret;\n    if (ys[0] != 0) ret.push_back({0, ys[0] - 1});\n    ret.push_back({ys[0], ys[0]});\n    for (int i = 1; i < ys.size(); ++i) {\n        if (ys[i - 1] < ys[i] - 1) ret.push_back({ys[i - 1] + 1, ys[i] - 1});\n        ret.push_back({ys[i], ys[i]});\n    }\n    if (ys.back() != H - 1) ret.push_back({ys.back() + 1, H - 1});\n    return ret;\n}\n\nint R, C; i64 weight[90][90];\nint dis[90][90];\n\nconst int dy[] = {-1, 0, 1, 0}, dx[] = {0, -1, 0, 1};\n\ni64 bfs(int y, int x)\n{\n    for (int i = 0; i < R; ++i) for (int j = 0; j < C; ++j) dis[i][j] = -1;\n    dis[y][x] = 0;\n    queue<pair<int, int>> qu; qu.push({y, x});\n    i64 ret = 0;\n    while (!qu.empty()) {\n        auto loc = qu.front(); qu.pop();\n        int d = dis[loc.first][loc.second];\n        if (make_pair(y, x) < make_pair(loc.first, loc.second)) {\n            ADD(ret, d * weight[loc.first][loc.second]);\n        }\n        for (int i = 0; i < 4; ++i) {\n            int y2 = loc.first + dy[i], x2 = loc.second + dx[i];\n            if (y2 < 0 || x2 < 0 || y2 >= R || x2 >= C || weight[y2][x2] == 0 || dis[y2][x2] != -1) continue;\n            dis[y2][x2] = d + 1;\n            qu.push({y2, x2});\n        }\n    }\n    return ret;\n}\n\nint main()\n{\n    scanf(\"%lld%lld%d\", &H, &W, &N);\n    for (int i = 0; i < N; ++i) {\n        scanf(\"%d%d\", Y + i, X + i);\n    }\n\n    i64 ret = 0;\n    ADD(ret, precomp(H, W, Y));\n    ADD(ret, precomp(W, H, X));\n\n    vector<pair<int, int>> ys = summarize(H, Y), xs = summarize(W, X);\n    R = ys.size(); C = xs.size();\n    for (int i = 0; i < R; ++i) {\n        for (int j = 0; j < C; ++j) {\n            weight[i][j] = (i64)(ys[i].second - ys[i].first + 1) * (xs[j].second - xs[j].first + 1);\n        }\n    }\n    for (int i = 0; i < N; ++i) {\n        int u = find(ys.begin(), ys.end(), make_pair(Y[i], Y[i])) - ys.begin();\n        --weight[find(ys.begin(), ys.end(), make_pair(Y[i], Y[i])) - ys.begin()][find(xs.begin(), xs.end(), make_pair(X[i], X[i])) - xs.begin()];\n    }\n    for (int i = 0; i < R; ++i) {\n        for (int j = 0; j < C; ++j) {\n            if (weight[i][j] != 0) {\n                ADD(ret, weight[i][j] % MOD * bfs(i, j));\n            }\n        }\n    }\n    printf(\"%lld\\n\", ret);\n\n    return 0;\n}\n"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\nusing namespace std;\n\nusing ll = long long;\nusing i128 = __int128_t;\n\nint main(){\n\tios_base::sync_with_stdio(0), cin.tie(0), cout.tie(0);\n\tint A, B;\n\tcin >> A >> B;\n\tint k;\n\tcin >> k;\n\tvector<pair<int,int> > pts(k);\n\tset<int> verts_x, verts_y;\n\tverts_x.insert(0); verts_x.insert(A);\n\tverts_y.insert(0); verts_y.insert(B);\n\tfor(pair<int,int>& p : pts){\n\t\tcin >> p.first >> p.second;\n\t\tfor(int j = 0; j <= 1; j++) verts_x.insert(p.first + j);\n\t\tfor(int j = 0; j <= 1; j++) verts_y.insert(p.second + j);\n\t}\n\tvector<int> loc_x, loc_y;\n\tfor(int x : verts_x) loc_x.push_back(x);\n\tfor(int y : verts_y) loc_y.push_back(y);\n\tint num_x = (int)loc_x.size() - 1;\n\tint num_y = (int)loc_y.size() - 1;\n\tvector<vector<bool> > occ(num_x, vector<bool>(num_y, false));\n\tfor(int i = 0; i < num_x; i++){\n\t\tfor(int j = 0; j < num_y; j++){\n\t\t\tfor(pair<int,int> p : pts){\n\t\t\t\tif(loc_x[i] == p.first && loc_y[j] == p.second) occ[i][j] = true;\n\t\t\t}\n\t\t}\n\t}\n\n\ti128 ans = 0;\n\tvector<int> dx = {1, 0, -1, 0};\n\tvector<int> dy = {0, 1, 0, -1};\n\tfor(int x = 0; x < num_x; x++){\n\t\tfor(int y = 0; y < num_y; y++){\n\t\t\tif(occ[x][y]) continue;\n\t\t\tvector<vector<int> > dist(num_x, vector<int>(num_y, 1e9));\n\t\t\tvector<pair<int,int> > bfs;\n\t\t\tdist[x][y] = 0;\n\t\t\tbfs.push_back({x, y});\n\t\t\tint s = 0;\n\t\t\twhile(s < (int)bfs.size()){\n\t\t\t\tint cx = bfs[s].first;\n\t\t\t\tint cy = bfs[s].second;\n\t\t\t\ts++;\n\t\t\t\tfor(int d = 0; d < 4; d++){\n\t\t\t\t\tint nx = cx + dx[d];\n\t\t\t\t\tint ny = cy + dy[d];\n\t\t\t\t\tif(nx < 0 || ny < 0 || nx >= num_x || ny >= num_y) continue;\n\t\t\t\t\tif(occ[nx][ny]) continue;\n\t\t\t\t\tint new_dist = dist[cx][cy] + 1;\n\t\t\t\t\tif(new_dist < dist[nx][ny]){\n\t\t\t\t\t\tdist[nx][ny] = new_dist;\n\t\t\t\t\t\tbfs.push_back({nx, ny});\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t}\n\t\t\tfor(int nx = 0; nx < num_x; nx++){\n\t\t\t\tfor(int ny = 0; ny < num_y; ny++){\n\t\t\t\t\tif(occ[nx][ny]) continue;\n\t\t\t\t\ti128 dx0 = loc_x[x + 1] - loc_x[x];\n\t\t\t\t\ti128 dy0 = loc_y[y + 1] - loc_y[y];\n\t\t\t\t\ti128 dx1 = loc_x[nx + 1] - loc_x[nx];\n\t\t\t\t\ti128 dy1 = loc_y[ny + 1] - loc_y[ny];\n\t\t\t\t\tif((x == nx && dx0 > 1) || (y == ny && dy0 > 1)){\n\t\t\t\t\t\t// can travel by manhattan distance\n\t\t\t\t\t\ti128 xdist = (x == nx) ? ((dx0 * dx0 * dx0 - dx0) / 3) : \n\t\t\t\t\t\t\tdx0 * dx1 * abs(loc_x[nx + 1] + loc_x[nx] - loc_x[x + 1] - loc_x[x]) / 2;\n\t\t\t\t\t\txdist *= dy0 * dy1;\n\t\t\t\t\t\ti128 ydist = (y == ny) ? ((dy0 * dy0 * dy0 - dy0) / 3) : \n\t\t\t\t\t\t\tdy0 * dy1 * abs(loc_y[ny + 1] + loc_y[ny] - loc_y[y + 1] - loc_y[y]) / 2;\n\t\t\t\t\t\tydist *= dx0 * dx1;\n\t\t\t\t\t\tans += xdist + ydist;\n\t\t\t\t\t} else {\n\t\t\t\t\t\ti128 real_dist = dist[nx][ny] + abs(loc_x[nx] - loc_x[x]) - abs(nx - x) \n\t\t\t\t\t\t\t\t\t\t\t\t\t\t+ abs(loc_y[ny] - loc_y[y]) - abs(ny - y);\n\t\t\t\t\t\ti128 twice_avg = 2 * i128(real_dist)\n\t\t\t\t\t\t\t+ abs(loc_x[nx + 1] + loc_x[nx] - loc_x[x + 1] - loc_x[x]) - 2 * abs(loc_x[nx] - loc_x[x])\n\t\t\t\t\t\t\t+ abs(loc_y[ny + 1] + loc_y[ny] - loc_y[y + 1] - loc_y[y]) - 2 * abs(loc_y[ny] - loc_y[y]);\n\t\t\t\t\t\tans += twice_avg * dx0 * dy0 * dx1 * dy1 / 2;\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t}\n\tll ans_mod = (ans / 2) % (int(1e9) + 7);\n\tcout << ans_mod << '\\n';\n}"
  },
  {
    "language": "C++",
    "code": "// SUBLIME HAX\n\t/*nope\n\tcat\n\t// sixteen chars// sixteen chars// sixteen chars// sixteen chars// sixteen chars// sixteen chars// sixteen chars// sixteen chars// sixteen chars// sixteen chars// sixteen chars// sixteen chars// sixteen chars// sixteen chars// sixteen chars// sixteen chars// sixteen chars// sixteen chars// sixteen chars// sixteen chars// sixteen chars// sixteen chars// sixteen chars// sixteen chars// sixteen chars// sixteen chars// sixteen chars// sixteen chars// sixteen chars// sixteen chars// sixteen chars// sixteen chars// sixteen chars// sixteen chars// sixteen chars// sixteen chars// sixteen chars// sixteen chars// sixteen chars// sixteen chars// sixteen chars// sixteen chars// sixteen chars// sixteen chars// sixteen chars// sixteen chars// sixteen chars// sixteen chars// sixteen chars// sixteen chars// sixteen chars// sixteen chars// sixteen chars// sixteen chars// sixteen chars// sixteen chars// sixteen chars// sixteen chars// sixteen chars// sixteen chars// sixteen chars// sixteen chars// sixteen chars// sixteen chars\n\t// ayy\n\t// ' lamo\n\t*/\n\t#include <bits/stdc++.h>\n\tusing namespace std;\n\ttemplate<class T,class U>\n\tostream &operator<<(ostream &os,const pair<T,U> &x) {\n\t\treturn os<<\"(\"<<x.first<<\",\"<<x.second<<\")\";\n\t}\n\tnamespace dbg_ns {\n\t\ttemplate<typename C>\n\t\tstruct is_iterable {\n\t\t\ttemplate<class T> static long check(...);\n\t\t\ttemplate<class T> static char check(int,\n\t\t\t\ttypename T::const_iterator = C().end());\n\t\t\tenum {\n\t\t\t\tvalue = sizeof(check<C>(0)) == sizeof(char),\n\t\t\t\tneg_value = sizeof(check<C>(0)) != sizeof(char)\n\t\t\t};\n\t\t};\n\t\ttemplate<class T> ostream &_out_str(ostream &os,const T &x) {\n\t\t\treturn os<<'\"'<<x<<'\"';\n\t\t}\n\t\ttemplate<class T> ostream &_dbg2_5(ostream &,const T &);\n\t\ttemplate<bool B,typename T=void> using eit=typename enable_if<B,T>::type;\n\t\ttemplate<class T>\n\t\tinline ostream &_dbg3(ostream &os,eit<is_iterable<T>::neg_value,const T> &x) {\n\t\t\treturn os<<x;\n\t\t}\n\t\ttemplate<class T>\n\t\tinline ostream &_dbg3(ostream &os,eit<is_iterable<T>::value,const T> &V) {\n\t\t\tos<<\"{\";\n\t\t\tbool ff=0;\n\t\t\tfor(const auto &E:V) _dbg2_5(ff?os<<\",\":os,E), ff=1;\n\t\t\treturn os<<\"}\";\n\t\t}\n\t\ttemplate<>\n\t\tinline ostream &_dbg3<string>(ostream &os,const string &x) {\n\t\t\treturn _out_str(os,x);\n\t\t}\n\t\ttemplate<>\n\t\tinline ostream &_dbg3<const char *>(ostream &os,const char *const &x) {\n\t\t\treturn _out_str(os,x);\n\t\t}\n\t\ttemplate<class T> inline ostream &_dbg2_5(ostream &os,const T &x) {\n\t\t\treturn _dbg3<T>(os,x);\n\t\t}\n\t\ttemplate<class T,typename... Args> ostream &_dbg2(ostream &os,vector<string>::iterator nm,const T &x,Args&&... args);\n\t\tinline ostream &_dbg2(ostream &os,vector<string>::iterator) { return os; }\n\t\ttemplate<typename... Args>\n\t\tinline ostream &_dbg2(ostream &os,vector<string>::iterator nm,const char *x,Args&&... args) {\n\t\t\treturn _dbg2(_dbg3<const char *>(os<<\"  \",x),nm+1,args...);\n\t\t}\n\t\ttemplate<class T,typename... Args>\n\t\tinline ostream &_dbg2(ostream &os,vector<string>::iterator nm,const T &x,Args&&... args) {\n\t\t\treturn _dbg2(_dbg3<T>(os<<\"  \"<<*nm<<\"=\",x),nm+1,args...);\n\t\t}\n\t\tvector<string> split(string s) {\n\t\t\tvector<string> Z;\n\t\t\tstring z=\"\";\n\t\t\ts+=',';\n\t\t\tint dep=0;\n\t\t\tfor(char c:s) {\n\t\t\t\tif(c==',' && !dep) Z.push_back(z),z=\"\";\n\t\t\t\telse z+=c;\n\t\t\t\tif(c=='(') ++dep;\n\t\t\t\tif(c==')') --dep;\n\t\t\t}\n\t\t\treturn Z;\n\t\t}\n\t\ttemplate<typename... Args> inline ostream &_dbg1(int ln,const string &nm,Args&&... args) {\n\t\t\tauto nms=split(nm);\n\t\t\treturn _dbg2(cerr<<\"L\"<<ln<<\":\",nms.begin(),args...)<<endl;\n\t\t}\n\t}\n\t#define dbg(...) dbg_ns::_dbg1(__LINE__,#__VA_ARGS__,__VA_ARGS__)\n\t#define sz(x) (int(x.size()))\n\t#define eprintf(...) fprintf(stderr,__VA_ARGS__)\n\t#define fi first\n\t#define se second\n\t#define pb push_back\n// END SUBLIME HAX\n// #include <bits/extc++.h>\n// using namespace __gnu_pbds;\ntypedef unsigned long long ull;\ntypedef long long ll;\ntypedef long double ld; //CARE\ntypedef complex<ld> pt;\nconst ld eps=(ld)1e-8;\nconst ld tau=2*(ld)acosl(-1);\nconst int inf=1e9+99;\nconst ll linf=1e18+99;\nconst int P=1e9+7;\n\n\n// #define int __int128\n// #define ll __int128\n\nint32_t H,W;\nint32_t n;\n\nconst int32_t N=8192;\nint D[N][N];\nvector<pair<int,int> > adj[N];\nvector<pair<int,int> > rels;\nvector<int> relx,rely;\nset<pair<int,int> > bads;\nset<int> bx,by;\nvector<pair<int,int> > bandx,bandy;\n\nmap<int,int> ddec[1<<20];\n\nint dec(int x,int y) {\n\treturn ddec[x].count(y) ? ddec[x][y] : -1;\n\tauto it=lower_bound(rels.begin(),rels.end(),pair<int,int>(x,y));\n\tif(it!=rels.end() && it->fi==x && it->se==y)\n\t\treturn int(it-rels.begin());\n\treturn -1;\n}\n\n\nint sL(int x) { // 0+..+x-1\n\treturn int(1LL*x*(x-1)/2%P);\n}\nint ww(int x) {\n\tstatic bool init=0;\n\tstatic int Z[1<<20];\n\tassert(1<=x && x<(1<<20));\n\tif(!init) {\n\t\tinit=1;\n\t\tassert(!sL(0) && !sL(1));\n\t\tfor(int i=1;i<(1<<20);i++) {\n\t\t\tZ[i]=sL(i)+Z[i-1];\n\t\t\tif(Z[i]>=P) Z[i]-=P;\n\t\t}\n\t}\n\treturn Z[x];\n}\nint qq(int x,int y) {\n\treturn int((1LL*x*sL(y)+1LL*y*sL(x))%P);\n}\ninline int _w(const pair<int,int> &P) {\n\tif(~P.se) return P.se-P.fi+1;\n\treturn 1;\n}\nint g_same(int w,int h) {\n\t// dbg(\"SS\",w,h);\n\t// dbg(ww(h));\n\treturn int((1LL*w*w%P*ww(h) + 1LL*h*h%P*ww(w))%P);\n}\nint g_same(int w,const pair<int,int> &X,const pair<int,int> &_X) {\n\tif(X==_X) return g_same(w,_w(X));\n\tint d0;\n\tint a= X.fi,b=~ X.se? X.se: X.fi;\n\tint c=_X.fi,d=~_X.se?_X.se:_X.fi;\n\tassert(a<=b && c<=d);\n\tif(b<c) d0=c-b; else\n\tif(d<a) d0=a-d; else\n\tassert(0);\n\tint h1=_w(X);\n\tint h2=_w(_X);\n\n\tll ZZ=d0;\n\tZZ=ZZ*w%P*h1%P*w%P*h2%P;\n\tZZ+=1LL*h1*h2%P*ww(w)*2; //dbg(h1,h2,w,ww(w));\n\tZZ+=1LL*w*w%P*qq(h1,h2);\n\t// dbg(\"HIT\",w,h1,h2,ZZ,d0);\n\treturn int(ZZ%P);\n}\ninline int close(const pair<int,int> &X,int x) {\n\tif(!~X.se) return X.fi;\n\tif(x<X.fi) return X.fi;\n\tif(x>X.se) return X.se;\n\tassert(0);\n}\nint g(const pair<int,int> &X,const pair<int,int> &Y,\n\tconst pair<int,int> &_X,const pair<int,int> &_Y) {\n\n\tif(X==_X && Y==_Y && !~X.se && !~Y.se) return 0;\n\n\tif(X==_X && ~X.se) return g_same(_w(X),Y,_Y);\n\tif(Y==_Y && ~Y.se) return g_same(_w(Y),X,_X);\n\n\tint  Cx=_w(X);\n\tint  Cy=_w(Y);\n\tint _Cx=_w(_X);\n\tint _Cy=_w(_Y);\n\tint CCx=int(1LL*Cx*_Cx%P);\n\tint CCy=int(1LL*Cy*_Cy%P);\n\n\tint u=dec(close(X,_X.fi),close(Y,_Y.fi)); assert(~u);\n\tint v=dec(close(_X,X.fi),close(_Y,Y.fi)); assert(~v);\n\n\tll ZZ=D[u][v]; assert(ZZ<inf);\n\n\tZZ=ZZ*CCx%P*CCy;\n\t// dbg(C,_C,ZZ,ZZ%P);\n\n\tZZ+=1LL*CCx*qq(Cy,_Cy);\n\tZZ+=1LL*CCy*qq(Cx,_Cx);\n\n\t// dbg(ZZ,ZZ%P);\n\n\treturn int(ZZ%P);\n}\n\n\nvoid dijk(int src,int *D) {\n\tfor(int u=0;u<n;u++) D[u]=inf;\n\tD[src]=0;\n\tpriority_queue<pair<int,int> > pq;\n\tpq.push({0,src});\n\tfor(;sz(pq);) {\n\t\tint u=pq.top().se;\n\t\tint d=-pq.top().fi;\n\t\tpq.pop();\n\t\tif(D[u]<d) continue;\n\t\tfor(const auto &P:adj[u]) if(d+P.se<D[P.fi]) {\n\t\t\tD[P.fi]=d+P.se;\n\t\t\tpq.push({-D[P.fi],P.fi});\n\t\t}\n\t}\n}\n\n\nint32_t main() {\n\t// for(int i=1;i<6;i++) dbg(i,ww(i));\n\tcin>>H>>W>>n;\n\tfor(int i=0;i<n;i++) {\n\t\tint32_t x,y; cin>>x>>y;\n\t\tbads.insert({x,y});\n\t\tbx.insert(x), by.insert(y);\n\t}\n\tfor(int _x:bx) for(int x=_x-1;x<=_x+1;x++)\n\t\tif(!sz(relx) || x>relx.back()) if(0<=x && x<H)\n\t\t\trelx.pb(x);\n\tfor(int _y:by) for(int y=_y-1;y<=_y+1;y++)\n\t\tif(!sz(rely) || y>rely.back()) if(0<=y && y<W)\n\t\t\trely.pb(y);\n\n\tfor(int x:relx) for(int y:rely) if(!bads.count({x,y})) rels.pb({x,y});\n\tsort(rels.begin(),rels.end());\n\tn=sz(rels);\n\tassert(n<N);\n\tfor(int i=0;i<n;i++) ddec[rels[i].fi][rels[i].se]=i;\n\n\tfor(int i=1;i<sz(relx);i++) for(int y:rely) {\n\t\tint u=dec(relx[i-1],y);\n\t\tint v=dec(relx[i],y);\n\t\tint d=relx[i]-relx[i-1];\n\t\tif(~u && ~v) {\n\t\t\tadj[u].pb({v,d});\n\t\t\tadj[v].pb({u,d});\n\t\t}\n\t}\n\tfor(int i=1;i<sz(rely);i++) for(int x:relx) {\n\t\tint u=dec(x,rely[i-1]);\n\t\tint v=dec(x,rely[i]);\n\t\tint d=rely[i]-rely[i-1];\n\t\tif(~u && ~v) {\n\t\t\tadj[u].pb({v,d});\n\t\t\tadj[v].pb({u,d});\n\t\t}\n\t}\n\n\tfor(int i=0;i<n;i++) dijk(i,D[i]);\n\t// for(int i=0;i<n;i++) for(int j=0;j<n;j++) dbg(rels[i],rels[j],D[i][j]);\n\n\t{\n\t\tint pr=-1;\n\t\tfor(int x:bx) {\n\t\t\tif(x-1>pr) bandx.pb({pr+1,x-1});\n\t\t\tbandx.pb({x,-1});\n\t\t\tpr=x;\n\t\t}\n\t\tif(H-1>pr) bandx.pb({pr+1,H-1});\n\t}\n\t{\n\t\tint pr=-1;\n\t\tfor(int y:by) {\n\t\t\tif(y-1>pr) bandy.pb({pr+1,y-1});\n\t\t\tbandy.pb({y,-1});\n\t\t\tpr=y;\n\t\t}\n\t\tif(W-1>pr) bandy.pb({pr+1,W-1});\n\t}\n\n\tassert(sz(bandx)<=61 && sz(bandy)<=61);\n\n\tll Z=0;\n\tfor(const auto &BX:bandx) for(const auto &BY:bandy) {\n\t\tif(bads.count({BX.fi,BY.fi})) continue;\n\t\tfor(const auto &_BX:bandx) for(const auto &_BY:bandy) {\n\t\t\tif(BX>_BX) continue;\n\t\t\tif(BX==_BX && BY>_BY) continue;\n\t\t\tif(!~_BX.se && !~_BY.se && bads.count({_BX.fi,_BY.fi})) continue;\n\t\t\tint w=g(BX,BY,_BX,_BY);\n\t\t\tZ+=w;\n\t\t}\n\t}\n\tcout<<int32_t(Z%P)<<endl;\n}\n\n\n\n\n\n\n\n\n\n\n\n"
  },
  {
    "language": "C++",
    "code": "#include<iostream>\n#include<cstdio>\n#include<cstdlib>\n#include<cmath>\n#include<cstring>\n#include<algorithm>\n#include<vector>\n#define rep(i,a,b) for(register int i=a;i<=b;i++)\n#define dep(i,a,b) for(register int i=a;i>=b;i--)\n#define ll long long\n#define mem(x,num) memset(x,num,sizeof x)\n#define reg(x) for(int i=last[x];i;i=e[i].next)\nusing namespace std;\ninline ll read(){\n    ll f=1,x=0;char ch=getchar();\n    while(ch<'0'||ch>'9'){if(ch=='-')f=-1;ch=getchar();}\n    while(ch>='0'&&ch<='9'){x=x*10+ch-'0';ch=getchar();}\n    return x*f;\n}\n//**********head by yjjr**********\n#define pb push_back\n#define inf 1e9\nconst int maxn=66,maxm=1e6+6,dx[4]={-1,1,0,0},dy[4]={0,0,-1,1},mod=1e9+7;\nstruct node{int x,y;}a[maxn<<1],que[maxn*maxn*4];\nint n,m,K,ans,lx,ly,cnt[maxn][maxn],s1[maxm],s2[maxm],dis[maxn][maxn],head,tail;\nbool fb[maxn][maxn],mark1[maxm],mark2[maxm];\nvector<int>px,py;\nvoid vnique(vector <int> &r){\n    sort(r.begin(),r.end());\n    auto t=unique(r.begin(),r.end());\n    r.erase(t,r.end());\n}\nvoid bfs(int x,int y){\n    rep(i,0,lx)rep(j,0,ly)dis[i][j]=inf;\n    dis[x][y]=0;que[head=tail=1]=(node){x,y};\n    while(head<=tail){\n        int nx=que[head].x,ny=que[head++].y;\n        rep(i,0,3){\n            int nex=nx+dx[i],ney=ny+dy[i];\n            if(nex>lx||nex<0||ney>ly||ney<0||dis[nex][ney]<=dis[nx][ny]+1||fb[nex][ney])continue;\n            dis[nex][ney]=dis[nx][ny]+1;que[++tail]=(node){nex,ney};\n        }\n    }\n}\nint main()\n{\n    n=read(),m=read(),K=read();\n    px.pb(1);px.pb(n+1);py.pb(1);py.pb(m+1);\n    rep(i,1,n)s1[i]=m;\n    rep(i,1,m)s2[i]=n;\n    rep(i,1,K){\n        a[i].x=read()+1,a[i].y=read()+1;\n        px.pb(a[i].x),px.pb(a[i].x+1);\n        py.pb(a[i].y),py.pb(a[i].y+1);\n        s1[a[i].x]--,mark1[a[i].x]=1;\n        s2[a[i].y]--,mark2[a[i].y]=1;\n    }\n    rep(i,1,n)s1[i]=(s1[i]+s1[i-1])%mod;\n    rep(i,1,m)s2[i]=(s2[i]+s2[i-1])%mod;\n    rep(i,1,n-1)if(!mark1[i]&&!mark1[i+1])ans=(ans+1ll*2*s1[i]*(s1[n]-s1[i]))%mod;\n    rep(i,1,m-1)if(!mark2[i]&&!mark2[i+1])ans=(ans+1ll*2*s2[i]*(s2[m]-s2[i]))%mod;\n    vnique(px);vnique(py);lx=px.size()-2;ly=py.size()-2;\n    rep(i,1,K)\n        fb[lower_bound(px.begin(),px.end(),a[i].x)-px.begin()][lower_bound(py.begin(),py.end(),a[i].y)-py.begin()]=1;\n    rep(i,0,lx)rep(j,0,ly)cnt[i][j]=1ll*(px[i+1]-px[i])*(py[j+1]-py[j])%mod;\n    rep(i,0,lx)rep(j,0,ly)\n        if(!fb[i][j]){\n            bfs(i,j);\n            rep(k,0,lx)rep(p,0,ly)\n                if(!fb[k][p])ans=(ans+1ll*cnt[i][j]*dis[k][p]%mod*cnt[k][p])%mod; \n        }\n    ans=(ans+mod)%mod;ans=1ll*ans*(mod/2+1)%mod;\n    cout<<ans<<endl;\n    return 0;\n}"
  },
  {
    "language": "C++",
    "code": "// SUBLIME HAX\n\t/*nope\n\tcat\n\t// sixteen chars// sixteen chars// sixteen chars// sixteen chars// sixteen chars// sixteen chars// sixteen chars// sixteen chars// sixteen chars// sixteen chars// sixteen chars// sixteen chars// sixteen chars// sixteen chars// sixteen chars// sixteen chars// sixteen chars// sixteen chars// sixteen chars// sixteen chars// sixteen chars// sixteen chars// sixteen chars// sixteen chars// sixteen chars// sixteen chars// sixteen chars// sixteen chars// sixteen chars// sixteen chars// sixteen chars// sixteen chars// sixteen chars// sixteen chars// sixteen chars// sixteen chars// sixteen chars// sixteen chars// sixteen chars// sixteen chars// sixteen chars// sixteen chars// sixteen chars// sixteen chars// sixteen chars// sixteen chars// sixteen chars// sixteen chars// sixteen chars// sixteen chars// sixteen chars// sixteen chars// sixteen chars// sixteen chars// sixteen chars// sixteen chars// sixteen chars// sixteen chars// sixteen chars// sixteen chars// sixteen chars// sixteen chars// sixteen chars// sixteen chars\n\t// ayy\n\t// ' lamo\n\t*/\n\t#include <bits/stdc++.h>\n\tusing namespace std;\n\ttemplate<class T,class U>\n\tostream &operator<<(ostream &os,const pair<T,U> &x) {\n\t\treturn os<<\"(\"<<x.first<<\",\"<<x.second<<\")\";\n\t}\n\tnamespace dbg_ns {\n\t\ttemplate<typename C>\n\t\tstruct is_iterable {\n\t\t\ttemplate<class T> static long check(...);\n\t\t\ttemplate<class T> static char check(int,\n\t\t\t\ttypename T::const_iterator = C().end());\n\t\t\tenum {\n\t\t\t\tvalue = sizeof(check<C>(0)) == sizeof(char),\n\t\t\t\tneg_value = sizeof(check<C>(0)) != sizeof(char)\n\t\t\t};\n\t\t};\n\t\ttemplate<class T> ostream &_out_str(ostream &os,const T &x) {\n\t\t\treturn os<<'\"'<<x<<'\"';\n\t\t}\n\t\ttemplate<class T> ostream &_dbg2_5(ostream &,const T &);\n\t\ttemplate<bool B,typename T=void> using eit=typename enable_if<B,T>::type;\n\t\ttemplate<class T>\n\t\tinline ostream &_dbg3(ostream &os,eit<is_iterable<T>::neg_value,const T> &x) {\n\t\t\treturn os<<x;\n\t\t}\n\t\ttemplate<class T>\n\t\tinline ostream &_dbg3(ostream &os,eit<is_iterable<T>::value,const T> &V) {\n\t\t\tos<<\"{\";\n\t\t\tbool ff=0;\n\t\t\tfor(const auto &E:V) _dbg2_5(ff?os<<\",\":os,E), ff=1;\n\t\t\treturn os<<\"}\";\n\t\t}\n\t\ttemplate<>\n\t\tinline ostream &_dbg3<string>(ostream &os,const string &x) {\n\t\t\treturn _out_str(os,x);\n\t\t}\n\t\ttemplate<>\n\t\tinline ostream &_dbg3<const char *>(ostream &os,const char *const &x) {\n\t\t\treturn _out_str(os,x);\n\t\t}\n\t\ttemplate<class T> inline ostream &_dbg2_5(ostream &os,const T &x) {\n\t\t\treturn _dbg3<T>(os,x);\n\t\t}\n\t\ttemplate<class T,typename... Args> ostream &_dbg2(ostream &os,vector<string>::iterator nm,const T &x,Args&&... args);\n\t\tinline ostream &_dbg2(ostream &os,vector<string>::iterator) { return os; }\n\t\ttemplate<typename... Args>\n\t\tinline ostream &_dbg2(ostream &os,vector<string>::iterator nm,const char *x,Args&&... args) {\n\t\t\treturn _dbg2(_dbg3<const char *>(os<<\"  \",x),nm+1,args...);\n\t\t}\n\t\ttemplate<class T,typename... Args>\n\t\tinline ostream &_dbg2(ostream &os,vector<string>::iterator nm,const T &x,Args&&... args) {\n\t\t\treturn _dbg2(_dbg3<T>(os<<\"  \"<<*nm<<\"=\",x),nm+1,args...);\n\t\t}\n\t\tvector<string> split(string s) {\n\t\t\tvector<string> Z;\n\t\t\tstring z=\"\";\n\t\t\ts+=',';\n\t\t\tint dep=0;\n\t\t\tfor(char c:s) {\n\t\t\t\tif(c==',' && !dep) Z.push_back(z),z=\"\";\n\t\t\t\telse z+=c;\n\t\t\t\tif(c=='(') ++dep;\n\t\t\t\tif(c==')') --dep;\n\t\t\t}\n\t\t\treturn Z;\n\t\t}\n\t\ttemplate<typename... Args> inline ostream &_dbg1(int ln,const string &nm,Args&&... args) {\n\t\t\tauto nms=split(nm);\n\t\t\treturn _dbg2(cerr<<\"L\"<<ln<<\":\",nms.begin(),args...)<<endl;\n\t\t}\n\t}\n\t#define dbg(...) dbg_ns::_dbg1(__LINE__,#__VA_ARGS__,__VA_ARGS__)\n\t#define sz(x) (int(x.size()))\n\t#define eprintf(...) fprintf(stderr,__VA_ARGS__)\n\t#define fi first\n\t#define se second\n\t#define pb push_back\n// END SUBLIME HAX\n// #include <bits/extc++.h>\n// using namespace __gnu_pbds;\ntypedef unsigned long long ull;\ntypedef long long ll;\ntypedef long double ld; //CARE\ntypedef complex<ld> pt;\nconst ld eps=(ld)1e-8;\nconst ld tau=2*(ld)acosl(-1);\nconst int inf=1e9+99;\nconst ll linf=1e18+99;\nconst int P=1e9+7;\n\n\n// #define int __int128\n// #define ll __int128\n\nint32_t H,W;\nint32_t n;\n\nconst int32_t N=8192;\nint D[N][N];\nvector<pair<int,int> > adj[N];\nvector<pair<int,int> > rels;\nvector<int> relx,rely;\nset<pair<int,int> > bads;\nset<int> bx,by;\nvector<pair<int,int> > bandx,bandy;\n\nmap<int,int> ddec[1<<20];\n\nint dec(int x,int y) {\n\treturn ddec[x].count(y) ? ddec[x][y] : -1;\n\tauto it=lower_bound(rels.begin(),rels.end(),pair<int,int>(x,y));\n\tif(it!=rels.end() && it->fi==x && it->se==y)\n\t\treturn int(it-rels.begin());\n\treturn -1;\n}\n\n\nint sL(int x) { // 0+..+x-1\n\treturn int(1LL*x*(x-1)/2%P);\n}\nint ww(int x) {\n\tstatic bool init=0;\n\tstatic int Z[1<<20];\n\tassert(1<=x && x<(1<<20));\n\tif(!init) {\n\t\tinit=1;\n\t\tassert(!sL(0) && !sL(1));\n\t\tfor(int i=1;i<(1<<20);i++) {\n\t\t\tZ[i]=sL(i)+Z[i-1];\n\t\t\tif(Z[i]>=P) Z[i]-=P;\n\t\t}\n\t}\n\treturn Z[x];\n}\nint qq(int x,int y) {\n\treturn int((1LL*x*sL(y)+1LL*y*sL(x))%P);\n}\ninline int _w(const pair<int,int> &P) {\n\tif(~P.se) return P.se-P.fi+1;\n\treturn 1;\n}\nint g_same(int w,int h) {\n\t// dbg(\"SS\",w,h);\n\t// dbg(ww(h));\n\treturn int((1LL*w*w%P*ww(h) + 1LL*h*h%P*ww(w))%P);\n}\nint g_same(int w,const pair<int,int> &X,const pair<int,int> &_X) {\n\tif(X==_X) return g_same(w,_w(X));\n\tint d0;\n\tint a= X.fi,b=~ X.se? X.se: X.fi;\n\tint c=_X.fi,d=~_X.se?_X.se:_X.fi;\n\tassert(a<=b && c<=d);\n\tif(b<c) d0=c-b; else\n\tif(d<a) d0=a-d; else\n\tassert(0);\n\tint h1=_w(X);\n\tint h2=_w(_X);\n\n\tll ZZ=d0;\n\tZZ=ZZ*w%P*h1%P*w%P*h2%P;\n\tZZ+=1LL*h1*h2%P*ww(w)*2; //dbg(h1,h2,w,ww(w));\n\tZZ+=1LL*w*w%P*qq(h1,h2);\n\t// dbg(\"HIT\",w,h1,h2,ZZ,d0);\n\treturn int(ZZ%P);\n}\ninline int close(const pair<int,int> &X,int x) {\n\tif(!~X.se) return X.fi;\n\tif(x<X.fi) return X.fi;\n\tif(x>X.se) return X.se;\n\tassert(0);\n}\nint g(const pair<int,int> &X,const pair<int,int> &Y,\n\tconst pair<int,int> &_X,const pair<int,int> &_Y) {\n\n\tif(X==_X && Y==_Y && !~X.se && !~Y.se) return 0;\n\n\tif(X==_X && ~X.se) return g_same(_w(X),Y,_Y);\n\tif(Y==_Y && ~Y.se) return g_same(_w(Y),X,_X);\n\n\tint  Cx=_w(X);\n\tint  Cy=_w(Y);\n\tint _Cx=_w(_X);\n\tint _Cy=_w(_Y);\n\tint CCx=int(1LL*Cx*_Cx%P);\n\tint CCy=int(1LL*Cy*_Cy%P);\n\n\tint u=dec(close(X,_X.fi),close(Y,_Y.fi)); assert(~u);\n\tint v=dec(close(_X,X.fi),close(_Y,Y.fi)); assert(~v);\n\n\tll ZZ=D[u][v]; assert(ZZ<inf);\n\n\tZZ=ZZ*CCx%P*CCy;\n\t// dbg(C,_C,ZZ,ZZ%P);\n\n\tZZ+=1LL*CCx*qq(Cy,_Cy);\n\tZZ+=1LL*CCy*qq(Cx,_Cx);\n\n\t// dbg(ZZ,ZZ%P);\n\n\treturn int(ZZ%P);\n}\n\n\ntemplate<class T> struct PQ {\n\tint n=0;\n\tT A[N*4];\n\tvoid push(const T &x) {\n\t\tint i=++n;\n\t\tA[i]=x;\n\t\tfor(;i>1 && A[i>>1]<A[i];) swap(A[i>>1],A[i]), i>>=1;\n\t}\n\tT top() const { return A[1]; }\n\tvoid pop() {\n\t\tassert(n>=1);\n\t\tif(n>1) swap(A[1],A[n]);\n\t\tn--;\n\t\tint i=1;\n\t\tfor(;;) {\n\t\t\tint j=i<<1;\n\t\t\tif(j>n) break;\n\t\t\tif(j==n) {\n\t\t\t\tif(A[j]>A[i]) swap(A[j],A[i]);\n\t\t\t\tbreak;\n\t\t\t}\n\t\t\tif(A[j+1]>A[j]) ++j;\n\t\t\tif(A[j]>A[i]) swap(A[j],A[i]);\n\t\t\telse break;\n\t\t\ti=j;\n\t\t}\n\t}\n\tint size() const {\n\t\treturn n;\n\t}\n};\n// PQ<pair<int,int> > pq;\n// priority_queue<pair<int,int> > pq;\n// queue<pair<int,int> > pq;\nint pq[N];\nbool inq[N];\n#define top front\n\nvoid dijk(int src,int *DD) {\n\t// for(int u=0;u<n;u++) DD[u]=inf;\n\t// for(int u=0;u<=src;u++) DD[u]=D[u][src], pq.push({-DD[u],u});\n\t// for(int u=src+1;u<n;u++) DD[u]=inf;\n\t// if(src) for(int u=src+1;u<n;u++) DD[u]=D[src-1][u]+DD[src-1], pq.push({-DD[u],u});\n\tint pn=0;\n\tfor(int u=0;u<=src;u++) DD[u]=D[u][src], pq[pn++]=u;\n\tfor(int u=src+1;u<n;u++) DD[u]=inf;\n\tif(src) for(int u=src+1;u<n;u++) DD[u]=D[src-1][u]+DD[src-1], pq[pn++]=u;\n\n\tint ii=0;\n\tfor(int i=0;i<n;i++) inq[i]=0;\n\tfor(int i=0;i<pn;i++) inq[pq[i]]=1;\n\t// DD[src]=0;\n\t// pq.push({0,src});\n\t// for(;sz(pq);) {\n\tfor(;ii<pn;) {\n\t\t// auto P=pq.top();\n\t\t// int u=P.se;\n\t\t// int d=-P.fi;\n\t\t// pq.pop();\n\t\t// if(DD[u]<d) continue;\n\t\tint u=pq[(ii++)&(N-1)];\n\t\tinq[u]=0;\n\t\tint d=DD[u];\n\t\tfor(const auto &P:adj[u]) if(d+P.se<DD[P.fi]) {\n\t\t\tDD[P.fi]=d+P.se;\n\t\t\t// pq.push({-DD[P.fi],P.fi});\n\t\t\tif(!inq[P.fi]) pq[(pn++)&(N-1)]=P.fi;\n\t\t}\n\t}\n}\n\n\nint32_t main() {\n\t// for(int i=1;i<6;i++) dbg(i,ww(i));\n\tcin>>H>>W>>n;\n\tfor(int i=0;i<n;i++) {\n\t\tint32_t x,y; cin>>x>>y;\n\t\tbads.insert({x,y});\n\t\tbx.insert(x), by.insert(y);\n\t}\n\tfor(int _x:bx) for(int x=_x-1;x<=_x+1;x++)\n\t\tif(!sz(relx) || x>relx.back()) if(0<=x && x<H)\n\t\t\trelx.pb(x);\n\tfor(int _y:by) for(int y=_y-1;y<=_y+1;y++)\n\t\tif(!sz(rely) || y>rely.back()) if(0<=y && y<W)\n\t\t\trely.pb(y);\n\n\tfor(int x:relx) for(int y:rely) if(!bads.count({x,y})) rels.pb({x,y});\n\tsort(rels.begin(),rels.end());\n\tn=sz(rels);\n\tassert(n<N);\n\tfor(int i=0;i<n;i++) ddec[rels[i].fi][rels[i].se]=i;\n\n\tfor(int i=1;i<sz(relx);i++) for(int y:rely) {\n\t\tint u=dec(relx[i-1],y);\n\t\tint v=dec(relx[i],y);\n\t\tint d=relx[i]-relx[i-1];\n\t\tif(~u && ~v) {\n\t\t\tadj[u].pb({v,d});\n\t\t\tadj[v].pb({u,d});\n\t\t}\n\t}\n\tfor(int i=1;i<sz(rely);i++) for(int x:relx) {\n\t\tint u=dec(x,rely[i-1]);\n\t\tint v=dec(x,rely[i]);\n\t\tint d=rely[i]-rely[i-1];\n\t\tif(~u && ~v) {\n\t\t\tadj[u].pb({v,d});\n\t\t\tadj[v].pb({u,d});\n\t\t}\n\t}\n\n\tfor(int i=0;i<n;i++) dijk(i,D[i]);\n\t// for(int i=0;i<n;i++) for(int j=0;j<n;j++) dbg(rels[i],rels[j],D[i][j]);\n\n\t{\n\t\tint pr=-1;\n\t\tfor(int x:bx) {\n\t\t\tif(x-1>pr) bandx.pb({pr+1,x-1});\n\t\t\tbandx.pb({x,-1});\n\t\t\tpr=x;\n\t\t}\n\t\tif(H-1>pr) bandx.pb({pr+1,H-1});\n\t}\n\t{\n\t\tint pr=-1;\n\t\tfor(int y:by) {\n\t\t\tif(y-1>pr) bandy.pb({pr+1,y-1});\n\t\t\tbandy.pb({y,-1});\n\t\t\tpr=y;\n\t\t}\n\t\tif(W-1>pr) bandy.pb({pr+1,W-1});\n\t}\n\n\tassert(sz(bandx)<=61 && sz(bandy)<=61);\n\n\tll Z=0;\n\tfor(const auto &BX:bandx) for(const auto &BY:bandy) {\n\t\tif(bads.count({BX.fi,BY.fi})) continue;\n\t\tfor(const auto &_BX:bandx) for(const auto &_BY:bandy) {\n\t\t\tif(BX>_BX) continue;\n\t\t\tif(BX==_BX && BY>_BY) continue;\n\t\t\tif(!~_BX.se && !~_BY.se && bads.count({_BX.fi,_BY.fi})) continue;\n\t\t\tint w=g(BX,BY,_BX,_BY);\n\t\t\tZ+=w;\n\t\t}\n\t}\n\tcout<<int32_t(Z%P)<<endl;\n}\n\n\n\n\n\n\n\n\n\n\n\n"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\n\nusing namespace std;\n\ntypedef long long ll;\ntypedef unsigned long long ull;\ntypedef vector<int> vi;\ntypedef vector<ll> vl;\ntypedef pair<int, int> pii;\ntypedef pair<ll, ll> pll;\n\n#define REP(i, n) for(int i=0; i<(n); ++i)\n#define FOR(i, a, b) for(int i=(a); i<(b); ++i)\n#define FORR(i, a, b) for(int i=(b)-1; i>=(a); --i)\n\n#define DEBUG(x) cout<<#x<<\": \"<<x<<'\\n'\n#define DEBUG_VEC(v) cout<<#v<<\":\";REP(i, v.size())cout<<' '<<v[i];cout<<'\\n'\n#define ALL(a) (a).begin(), (a).end()\n\n#define CHMIN(a, b) a=min((a), (b))\n#define CHMAX(a, b) a=max((a), (b))\n\nconst ll MOD=1000000007ll;\n// const ll MOD=998244353ll;\n#define FIX(a) ((a)%MOD+MOD)%MOD\n\nconst double EPS=1e-11;\n#define EQ0(x) (abs((x))<EPS)\n#define EQ(a, b) (abs((a)-(b))<EPS)\n\nint h, w, n, x[40], y[40], xnum[1364364], ynum[1364364], H, W;\nvi X, Y;\nll ans;\nbool used[70][70];\nint d[70][70], dx[4]={1, 0, -1, 0}, dy[4]={0, 1, 0, -1};\n\nll bfs(){\n\tll res=0;\n\tREP(i, H){\n\t\tREP(j, W){\n\t\t\tif(used[i][j]){\n\t\t\t\tcontinue;\n\t\t\t}\n\t\t\tREP(k, H){\n\t\t\t\tREP(l, W){\n\t\t\t\t\td[k][l]=-1;\n\t\t\t\t}\n\t\t\t}\n\t\t\tqueue<pii> q;\n\t\t\tq.push(pii(i, j));\n\t\t\td[i][j]=0;\n\t\t\twhile(!q.empty()){\n\t\t\t\tpii p=q.front();\n\t\t\t\tq.pop();\n\t\t\t\tint sx=p.first, sy=p.second;\n\t\t\t\tREP(k, 4){\n\t\t\t\t\tint tx=sx+dx[k], ty=sy+dy[k];\n\t\t\t\t\tif(tx<0 || tx>=H || ty<0 || ty>=W || used[tx][ty] || d[tx][ty]!=-1){\n\t\t\t\t\t\tcontinue;\n\t\t\t\t\t}\n\t\t\t\t\td[tx][ty]=d[sx][sy]+1;\n\t\t\t\t\tq.push(pii(tx, ty));\n\t\t\t\t}\n\t\t\t}\n\t\t\tREP(k, H){\n\t\t\t\tREP(l, W){\n\t\t\t\t\tif(used[k][l] || d[k][l]==-1){\n\t\t\t\t\t\tcontinue;\n\t\t\t\t\t}\n\t\t\t\t\tll tmp1=((ll)X[i+1]-X[i])*(Y[j+1]-Y[j])%MOD, tmp2=((ll)X[k+1]-X[k])*(Y[l+1]-Y[l])%MOD;\n\t\t\t\t\tres=(res+d[k][l]*tmp1%MOD*tmp2%MOD)%MOD;\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t}\n\treturn (res*500000004)%MOD;\n}\n\nvoid compress(){\n\tX.push_back(0);\n\tX.push_back(h);\n\tY.push_back(0);\n\tY.push_back(w);\n\tREP(i, n){\n\t\tX.push_back(x[i]);\n\t\tX.push_back(x[i]+1);\n\t\tY.push_back(y[i]);\n\t\tY.push_back(y[i]+1);\n\t\t++xnum[x[i]];\n\t\t++ynum[y[i]];\n\t}\n\tsort(ALL(X));\n\tsort(ALL(Y));\n\tX.erase(unique(ALL(X)), X.end());\n\tY.erase(unique(ALL(Y)), Y.end());\n\tH=X.size()-1;\n\tW=Y.size()-1;\n\tREP(i, n){\n\t\tint itrx=find(ALL(X), x[i])-X.begin();\n\t\tint itry=find(ALL(Y), y[i])-Y.begin();\n\t\tused[itrx][itry]=true;\n\t}\n\treturn;\n}\n\nint main(){\n\tios::sync_with_stdio(false);\n\tcin.tie(0);\n\tcin>>h>>w>>n;\n\tREP(i, n){\n\t\tcin>>x[i]>>y[i];\n\t}\n\tcompress();\n\tll sub=w-xnum[0], sum=(ll)h*w-n;\n\tREP(i, h-1){\n\t\tif(xnum[i]==0 && xnum[i+1]==0){\n\t\t\tll tmp1=sub%MOD, tmp2=(sum-sub)%MOD;\n\t\t\tans=(ans+tmp1*tmp2)%MOD;\n\t\t}\n\t\tsub+=w-xnum[i+1];\n\t}\n\t// DEBUG(ans);\n\tsub=h-ynum[0];\n\tREP(i, w-1){\n\t\tif(ynum[i]==0 && ynum[i+1]==0){\n\t\t\tll tmp1=sub%MOD, tmp2=(sum-sub)%MOD;\n\t\t\tans=(ans+tmp1*tmp2)%MOD;\n\t\t}\n\t\tsub+=h-ynum[i+1];\n\t}\n\t// DEBUG(ans);\n\tans=(ans+bfs())%MOD;\n\tcout<<ans<<'\\n';\n\treturn 0;\n}\n"
  },
  {
    "language": "C++",
    "code": "#include <iostream>\n#include <algorithm>\n#include<cmath>\n#include<cstring>\n#include<cstdio>\n#include<cstdlib>\n#include<vector>\n#include<iomanip>\n#include<ctime>\n#include<set>\n#include<map>\n#include<queue>\n#include<stack>\n#include<bitset>\n#define sqr(x) ((x)*(x))\n#define fz1(i,n) for ((i)=1;(i)<=(n);(i)++)\n#define fd1(i,n) for ((i)=(n);(i)>=1;(i)--)\n#define fz0g(i,n) for ((i)=0;(i)<=(n);(i)++)\n#define fd0g(i,n) for ((i)=(n);(i)>=0;(i)--)\n#define fz0k(i,n) for ((i)=0;(i)<(n);(i)++)\n#define fd0k(i,n) for ((i)=(long long)((n)-1);(i)>=0;(i)--)\n#define fz(i,x,y) for ((i)=(x);(i)<=(y);(i)++)\n#define fd(i,y,x) for ((i)=(y);(i)>=(x);(i)--)\n#define fzin fz1(i,n)\n#define fzim fz1(i,m)\n#define fzjn fz1(j,n)\n#define fzjm fz1(j,m)\n#define ff(c,itr) for (__typeof((c).begin()) itr=(c).begin();itr!=(c).end();++itr)\n#define rdst(st,len){static char ss[len];scanf(\" %s\",ss);(st)=ss;}\n#define inc(x,y) {x+=(y);if(x>=mod)x-=mod;}\n#define dec(x,y) {x-=(y);if(x<0)x+=mod;}\n#define spln(i,n) (i==n?'\\n':' ')\n#define fac_init(n){fac[0]=fac[1]=inv[1]=fi[0]=fi[1]=1;fz(i,2,n){fac[i]=1ll*fac[i-1]*i%mod;inv[i]=1ll*(mod-mod/i)*inv[mod%i]%mod;fi[i]=1ll*fi[i-1]*inv[i]%mod;}}\nusing namespace std;\ninline void read(int &x)\n{\n\tchar c;int f=1;\n\twhile(!isdigit(c=getchar()))if(c=='-')f=-1;\n\tx=(c&15);while(isdigit(c=getchar()))x=(x<<1)+(x<<3)+(c&15);\n\tx*=f;\n}\nconst int dx[4]={0,0,-1,1},dy[4]={-1,1,0,0};\nconst int mod=1e9+7;\nint n,m,k,i,j,su[1000005],sd[1000005],sl[1000005],sr[1000005],ans,px[35],py[35],d[65][65],a[65][65],idx[1000005],idy[1000005],szx[65],szy[65],lx,ly,lst;\nvector<int> allx,ally;\nint calc(int sx,int sy)\n{\n\tint ans=0,i,j;\n\tmemset(d,0x3f,sizeof(d));\n\td[sx][sy]=0;\n\tqueue<int> qx,qy;\n\tqx.push(sx);qy.push(sy);\n\twhile(!qx.empty()){\n\t\tint x=qx.front(),y=qy.front();qx.pop();qy.pop();\n\t\tfz0k(i,4){\n\t\t\tint xx=x+dx[i],yy=y+dy[i];\n\t\t\tif(1<=xx&&xx<=lx&&1<=yy&&yy<=ly&&!a[xx][yy]){\n\t\t\t\tif(d[xx][yy]>d[x][y]+1){\n\t\t\t\t\td[xx][yy]=d[x][y]+1;\n\t\t\t\t\tqx.push(xx);qy.push(yy);\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t}\n\tfz1(i,lx)fz1(j,ly)if((i>sx||(i==sx&&j>sy))&&!a[i][j]){\n\t\tans=(ans+1ll*szx[i]*szy[j]%mod*d[i][j])%mod;\n\t}\n\treturn ans;\n}\nint main()\n{\n\tread(n);read(m);read(k);\n\tfz1(i,k){\n\t\tread(px[i]);read(py[i]);\n\t\tpx[i]++;py[i]++;\n\t\tsu[px[i]]--;sd[px[i]]--;\n\t\tsl[py[i]]--;sr[py[i]]--;\n\t\tallx.push_back(px[i]);\n\t\tally.push_back(py[i]);\n\t}\n\tfz1(i,n){\n\t\t(su[i]+=su[i-1]+m)%=mod;\n\t}\n\tfd1(i,n){\n\t\t(sd[i]+=sd[i+1]+m)%=mod;\n\t}\n\tfz1(i,m){\n\t\t(sl[i]+=sl[i-1]+n)%=mod;\n\t}\n\tfd1(i,m){\n\t\t(sr[i]+=sr[i+1]+n)%=mod;\n\t}\n\tsort(allx.begin(),allx.end());\n\tallx.resize(unique(allx.begin(),allx.end())-allx.begin());\n\tsort(ally.begin(),ally.end());\n\tally.resize(unique(ally.begin(),ally.end())-ally.begin());\n\tlst=0;\n\tfor(i=0;i<allx.size();i++){\n\t\tif(allx[i]-1>lst){\n\t\t\tszx[++lx]=allx[i]-1-lst;\n\t\t\tfor(j=lst+1;j<allx[i]-1;j++){\n\t\t\t\tans=(ans+1ll*su[j]*sd[j+1])%mod;\n\t\t\t}\n\t\t}\n\t\tlst=allx[i];\n\t\tszx[++lx]=1;idx[allx[i]]=lx;\n\t}\n\tif(lst<n){\n\t\tszx[++lx]=n-lst;\n\t\tfor(j=lst+1;j<n;j++){\n\t\t\tans=(ans+1ll*su[j]*sd[j+1])%mod;\n\t\t}\n\t}\n\tlst=0;\n\tfor(i=0;i<ally.size();i++){\n\t\tif(ally[i]-1>lst){\n\t\t\tszy[++ly]=ally[i]-1-lst;\n\t\t\tfor(j=lst+1;j<ally[i]-1;j++){\n\t\t\t\tans=(ans+1ll*sl[j]*sr[j+1])%mod;\n\t\t\t}\n\t\t}\n\t\tlst=ally[i];\n\t\tszy[++ly]=1;idy[ally[i]]=ly;\n\t}\n\tif(lst<m){\n\t\tszy[++ly]=m-lst;\n\t\tfor(j=lst+1;j<m;j++){\n\t\t\tans=(ans+1ll*sl[j]*sr[j+1])%mod;\n\t\t}\n\t}\n\tfz1(i,k){\n\t\ta[idx[px[i]]][idy[py[i]]]=1;\n\t}\n\tfz1(i,lx){\n\t\tfz1(j,ly)if(!a[i][j]){\n\t\t\tans=(ans+1ll*szx[i]*szy[j]%mod*calc(i,j))%mod;\n\t\t}\n\t}\n\tprintf(\"%d\\n\",ans);\n\treturn 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include<stdio.h>\n#include<string.h>\ntypedef long long ll;\nconst int mod=1000000007;\nconst int go[4][2]={{0,1},{0,-1},{1,0},{-1,0}};\nint mul(int a,int b){return(ll)a*b%mod;}\nint x[40],y[40],sx[1000010],sy[1000010],ix[1000010],iy[1000010],mx,my;\nbool bx[1000010],by[1000010],mp[70][70];\nint dis[70][70],vx[70],vy[70];\nstruct pr{\n\tint x,y;\n\tpr(int x=0,int y=0):x(x),y(y){}\n}q[4010];\nbool ok(int x,int y){\n\treturn 0<x&&x<=mx&&0<y&&y<=my&&!mp[x][y];\n}\nvoid bfs(pr t){\n\tint head,tail,x,y,i;\n\tmemset(dis,63,sizeof(dis));\n\thead=tail=1;\n\tq[1]=t;\n\tdis[t.x][t.y]=0;\n\twhile(head<=tail){\n\t\tt=q[head++];\n\t\tfor(i=0;i<4;i++){\n\t\t\tx=t.x+go[i][0];\n\t\t\ty=t.y+go[i][1];\n\t\t\tif(ok(x,y)&&dis[t.x][t.y]+1<dis[x][y]){\n\t\t\t\tdis[x][y]=dis[t.x][t.y]+1;\n\t\t\t\tq[++tail]=pr(x,y);\n\t\t\t}\n\t\t}\n\t}\n}\nint main(){\n\tint h,w,n,i,j,k,l,res,tmp;\n\tscanf(\"%d%d%d\",&h,&w,&n);\n\tfor(i=1;i<=n;i++){\n\t\tscanf(\"%d%d\",x+i,y+i);\n\t\tbx[++x[i]]=1;\n\t\tby[++y[i]]=1;\n\t\tsx[x[i]]++;\n\t\tsy[y[i]]++;\n\t}\n\tres=0;\n\tfor(i=1;i<=h;i++)sx[i]+=sx[i-1];\n\tfor(i=1;i<=w;i++)sy[i]+=sy[i-1];\n\tix[1]=++mx;\n\tfor(i=2;i<=h;i++){\n\t\tif(!bx[i]&&!bx[i-1]){\n\t\t\tix[i]=ix[i-1];\n\t\t\t(res+=mul(mul(i-1,w)-sx[i-1],mul(h-i+1,w)-(sx[h]-sx[i-1])))%=mod;\n\t\t}else\n\t\t\tix[i]=++mx;\n\t}\n\tiy[1]=++my;\n\tfor(i=2;i<=w;i++){\n\t\tif(!by[i]&&!by[i-1]){\n\t\t\tiy[i]=iy[i-1];\n\t\t\t(res+=mul(mul(i-1,h)-sy[i-1],mul(w-i+1,h)-(sy[w]-sy[i-1])))%=mod;\n\t\t}else\n\t\t\tiy[i]=++my;\n\t}\n\tfor(i=1;i<=h;i=j){\n\t\tfor(j=i;ix[j]==ix[i];j++);\n\t\tvx[ix[i]]=j-i;\n\t}\n\tfor(i=1;i<=w;i=j){\n\t\tfor(j=i;iy[j]==iy[i];j++);\n\t\tvy[iy[i]]=j-i;\n\t}\n\tfor(i=1;i<=n;i++)mp[ix[x[i]]][iy[y[i]]]=1;\n\tfor(i=1;i<=mx;i++){\n\t\tfor(j=1;j<=my;j++){\n\t\t\tif(!mp[i][j]){\n\t\t\t\tbfs(pr(i,j));\n\t\t\t\ttmp=0;\n\t\t\t\tfor(k=i;k<=mx;k++){\n\t\t\t\t\tfor(l=1;l<=my;l++){\n\t\t\t\t\t\tif((k>i||l>j)&&!mp[k][l])(tmp+=mul(dis[k][l],mul(vx[k],vy[l])))%=mod;\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t\t(res+=mul(tmp,mul(vx[i],vy[j])))%=mod;\n\t\t\t}\n\t\t}\n\t}\n\tprintf(\"%d\",(res+mod)%mod);\n}"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\n\nusing std::pair;\nusing std::vector;\nusing std::string;\n\ntypedef long long ll;\ntypedef pair<int, int> pii;\n\n#define fst first\n#define snd second\n#define pb(a) push_back(a)\n#define mp(a, b) std::make_pair(a, b)\n#define debug(...) fprintf(stderr, __VA_ARGS__)\n\ntemplate <typename T> bool chkmax(T& a, T b) { return a < b ? a = b, 1 : 0; }\ntemplate <typename T> bool chkmin(T& a, T b) { return a > b ? a = b, 1 : 0; }\n\nconst int oo = 0x3f3f3f3f;\n\nstring procStatus() {\n    std::ifstream t(\"/proc/self/status\");\n    return string(std::istreambuf_iterator<char>(t), std::istreambuf_iterator<char>());\n}\n\ntemplate <typename T> T read(T& x) {\n    int f = 1; x = 0;\n    char ch = getchar();\n    for(;!isdigit(ch); ch = getchar()) if(ch == '-') f = -1;\n    for(; isdigit(ch); ch = getchar()) x = x * 10 + ch - 48;\n    return x *= f;\n}\n\nconst int P = 100;\nconst int N = 1000000;\nconst int mo = 1e9 + 7;\n\nconst int dx[] = { -1, 1, 0, 0 };\nconst int dy[] = { 0, 0, -1, 1 };\n\nint n, ans;\nint cx[N + 5], cy[N + 5];\nint ix[N + 5], iy[N + 5];\nint sx[N + 5], sy[N + 5], totX, totY;\n\ninline int size(int x, int y) {\n    return 1ll * sx[x] * sy[y] % mo;\n}\n\nint solve(int *cnt, int *id, int *s, int R, int C) {\n    int l = R - cnt[0], r = (1ll * R * C - n - l) % mo;\n\n    ++ s[0];\n    for(int i = 1; i < C; ++i) {\n        id[i] = id[i-1];\n\n        if(!cnt[i] && !cnt[i-1]) {\n            ans = (ans + 1ll * l * r) % mo;\n        } else {\n            ++ id[i];\n        }\n        ++ s[id[i]];\n        l = (l + R - cnt[i]) % mo;\n        r = (r + cnt[i] - R) % mo;\n    }\n    return id[C - 1] + 1;\n}\n\nint r, c;\nint dis[P + 5][P + 5];\nbool vis[P + 5][P + 5];\nint x[P + 5], y[P + 5];\n\nint main() {\n#ifdef Wearry\n    freopen(\"in\", \"r\", stdin);\n    freopen(\"out\", \"w\", stdout);\n#endif\n\n    read(r), read(c), read(n);\n    for(int i = 0; i < n; ++i) {\n        read(x[i]), read(y[i]);\n        ++ cx[x[i]], ++ cy[y[i]];\n    }\n\n    totY = solve(cy, iy, sy, r, c);\n    totX = solve(cx, ix, sx, c, r);\n\n    ans = ans * 2 % mo;\n    for(int i = 0; i < n; ++i) vis[ix[x[i]]][iy[y[i]]] = true;\n    for(int i = 0; i < totX; ++i) \n        for(int j = 0; j < totY; ++j) if(!vis[i][j]) {\n            std::queue<pii> q;\n            memset(dis, 0xff, sizeof dis);\n\n            dis[i][j] = 0;\n            q.push(mp(i, j));\n\n            while(!q.empty()) {\n                pii cur = q.front(); q.pop();\n\n                ans = (ans + 1ll * dis[cur.fst][cur.snd] * size(cur.fst, cur.snd) % mo * size(i, j)) % mo;\n\n                for(int d = 0; d < 4; ++ d) {\n                    pii nxt = mp(cur.fst + dx[d], cur.snd + dy[d]);\n\n                    if(nxt.fst >= 0 && nxt.fst < totX &&!~dis[nxt.fst][nxt.snd]\n                    && nxt.snd >= 0 && nxt.snd < totY && !vis[nxt.fst][nxt.snd]) {\n                        dis[nxt.fst][nxt.snd] = dis[cur.fst][cur.snd] + 1;\n                        q.push(nxt);\n                    }\n                }\n            }\n        }\n\n    printf(\"%lld\\n\", 1ll * ans * (mo + 1) / 2 % mo);\n\n    return 0;\n}\n"
  },
  {
    "language": "C++",
    "code": "#include <iostream>\n#include <vector>\n#include <map>\n#include <queue>\n#include <algorithm>\n#include <cstring>\nusing namespace std;\n\n#define REP(i, s) for (int i = 0; i < s; ++i)\n#define ALL(v) (v.begin(), v.end())\n#define COUT(x) cout << #x << \" = \" << (x) << \" (L\" << __LINE__ << \")\" << endl\n#define EACH(i, s) for (__typeof__((s).begin()) i = (s).begin(); i != (s).end(); ++i)\n\ntemplate<class T> inline bool chmax(T& a, T b) { if (a < b) { a = b; return 1; } return 0; }\ntemplate<class T> inline bool chmin(T& a, T b) { if (a > b) { a = b; return 1; } return 0; }\ntemplate<class T1, class T2> ostream& operator << (ostream &s, pair<T1, T2> P)\n{\n\treturn s << '<' << P.first << \", \" << P.second << '>';\n}\ntemplate<class T> ostream& operator << (ostream &s, vector<T> P)\n{\n\tfor (int i = 0; i < P.size(); ++i) { if (i > 0) { s << \" \"; } s << P[i]; } return s;\n}\ntemplate<class T> ostream& operator << (ostream &s, vector<vector<T> > P)\n{\n\tfor (int i = 0; i < P.size(); ++i) { s << endl << P[i]; } return s << endl;\n}\n\nconst int MOD = 1000000007;\ninline long long mod(long long a, long long m) { return (a % m + m) % m; }\nstruct Fp {\n\tint MOD = 1000000007;\n\tlong long val;\n\n\tFp() : val(0) {}\n\tFp(long long val_) { this->val = mod(val_, MOD); }\n\tFp operator = (long long val_) { this->val = mod(val_, MOD); return *this; }\n\tinline Fp operator - () { return mod(-val, MOD); }\n\tinline const Fp& operator += (const Fp &x);\n\tinline const Fp& operator -= (const Fp &x);\n\tinline const Fp& operator *= (const Fp &x);\n\tinline const Fp& operator /= (const Fp &x);\n};\n\ninline bool operator == (Fp x, Fp y) { return x.val == y.val; }\ninline bool operator != (Fp x, Fp y) { return !(x == y); }\n\nostream &operator << (ostream &os, Fp x) { return os << x.val; }\nistream &operator >> (istream &is, Fp &x) { is >> x; return is; }\n\ninline Fp operator + (Fp x, Fp y) { return mod(x.val + y.val, x.MOD); }\ninline Fp operator - (Fp x, Fp y) { return mod(x.val - y.val, x.MOD); }\ninline Fp operator * (Fp x, Fp y) { return mod(x.val * y.val, x.MOD); }\ninline Fp operator / (Fp x, Fp y) {\n\tlong long a = y.val, b = x.MOD, u = 1, v = 0;\n\twhile (b) {\n\t\tlong long t = a / b;\n\t\ta -= t*b; swap(a, b);\n\t\tu -= t*v; swap(u, v);\n\t}\n\treturn x * u;\n}\ninline Fp abs(Fp a) { return a; }\ninline Fp fpow(Fp a, long long n) {\n\tif (n == 0) return Fp(1);\n\tFp t = fpow(a, n / 2);\n\tt = t * t; if (n & 1) t = t * a;\n\treturn t;\n}\ninline const Fp& Fp::operator += (const Fp &x) { *this = *this + x; return *this; }\ninline const Fp& Fp::operator -= (const Fp &x) { *this = *this - x; return *this; }\ninline const Fp& Fp::operator *= (const Fp &x) { *this = *this * x; return *this; }\ninline const Fp& Fp::operator /= (const Fp &x) { *this = *this / x; return *this; }\n\n// calc comb (small n, r ver)\nconst int FACT_MAX = 210000;\nstatic Fp fp_fact_val[FACT_MAX];\n\nvoid calcFact(int MAX = FACT_MAX) {\n\tfp_fact_val[0] = 1;\n\tfor (int val = 1; val < MAX; ++val) {\n\t\tfp_fact_val[val] = fp_fact_val[val - 1] * val;\n\t}\n}\n\nFp fact(int n) {\n\treturn fp_fact_val[n];\n}\n\nFp com(int n, int r) {\n\treturn fact(n) / fact(r) / fact(n - r);\n}\n\nint dx[4] = {1, 0, -1, 0};\nint dy[4] = {0, 1, 0, -1};\n\nlong long H, W, N;\nlong long bx[210], by[210];\nvector<long long> altx, alty;\nlong long nH, nW;\n\nlong long xnum[1100000], ynum[1100000];\n\nbool cb[210][210];\nlong long dist[110][110];\n\ntypedef pair<int, int> pint;\n\nFp subsolve() {\n\t//COUT(nH); COUT(nW); COUT(altx); COUT(alty);\n\n\tfor (int x = 0; x < nH - 1; ++x) {\n\t\tfor (int y = 0; y < nW - 1; ++y) {\n\t\t\t//cout << cb[x][y];\n\t\t}\n\t\t//cout << endl;\n\t}\n\n  Fp res = 0;\n\tfor (int x = 0; x < nH - 1; ++x) {\n\t\tfor (int y = 0; y < nW - 1; ++y) {\n\t\t\tif (cb[x][y]) continue;\n\t\t\tmemset(dist, -1, sizeof(dist));\n\t\t\tqueue<pint> que;\n\t\t\tque.push(pint(x, y));\n\t\t\tdist[x][y] = 0;\n\t\t\twhile (!que.empty()) {\n\t\t\t\tpint cur = que.front();\n\t\t\t\tque.pop();\n\t\t\t\tfor (int dir = 0; dir < 4; ++dir) {\n\t\t\t\t\tint nx = cur.first + dx[dir];\n\t\t\t\t\tint ny = cur.second + dy[dir];\n\t\t\t\t\tif (nx < 0 || nx >= H || ny < 0 || ny >= W) continue;\n\t\t\t\t\tif (cb[nx][ny]) continue;\n\t\t\t\t\tif (dist[nx][ny] == -1) {\n\t\t\t\t\t\tdist[nx][ny] = dist[cur.first][cur.second] + 1;\n\t\t\t\t\t\tque.push(pint(nx, ny));\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t}\n\t\t\t\n\t\t\tfor (int nx = 0; nx < nH - 1; ++nx) {\n\t\t\t\tfor (int ny = 0; ny < nW - 1; ++ny) {\n\t\t\t\t\t//if (nW * nx + ny <= nW * x + y) continue;\n\t\t\t\t\tif (dist[nx][ny] == -1) continue;\n\t\t\t\t\tif (cb[nx][ny]) continue;\n\n\t\t\t\t\tlong long ss = ((long long)(altx[x + 1] - altx[x]) * (alty[y + 1] - alty[y])) % MOD;\n\t\t\t\t\tlong long st = ((long long)(altx[nx + 1] - altx[nx]) * (alty[ny + 1] - alty[ny])) % MOD;\n\t\t\t\t\tres += ((long long)(dist[nx][ny]) * ss % MOD) * st % MOD;\n\n\t\t\t\t\t//cout << pint(x, y) << \", \" << pint(nx, ny) << \": \" << dist[nx][ny] << \", \" << ss << \", \" << st << endl;\n\t\t\t\t}\n\t\t\t}\n\t\t\t\n\t\t}\n\t}\n\t//COUT(res);\n\tres /= 2;\n\n\treturn res;\n}\n\nFp solve() {\n  memset(xnum, 0, sizeof(xnum));\n  memset(ynum, 0, sizeof(ynum));\n\taltx.clear();\n\talty.clear();\n  altx.push_back(0);\n  altx.push_back(H);\n  alty.push_back(0);\n  alty.push_back(W);\n  for (int i = 0; i < N; ++i) {\n\t\taltx.push_back(bx[i]);\n\t\taltx.push_back(bx[i] + 1);\n\t\talty.push_back(by[i]);\n\t\talty.push_back(by[i] + 1);\n\t\txnum[bx[i]]++;\n\t\tynum[by[i]]++;\n  }\n  sort(altx.begin(), altx.end());\n  sort(alty.begin(), alty.end());\n  altx.erase(unique(altx.begin(), altx.end()), altx.end());\n  alty.erase(unique(alty.begin(), alty.end()), alty.end());\n  nH = altx.size();\n  nW = alty.size();\n\n  memset(cb, 0, sizeof(cb));\n  for (int i = 0; i < N; ++i) {\n\t\tint itx = lower_bound(altx.begin(), altx.end(), bx[i]) - altx.begin();\n\t\tint ity = lower_bound(alty.begin(), alty.end(), by[i]) - alty.begin();\n\t\tcb[itx][ity] = true;\n  }\n\n  long long all = (long long)H * W - N;\n  Fp add = 0;\n  long long width = W;\n\tlong long num_comped = 0;\n  long long sum = width - xnum[0];\n  for (int i = 1; i < H; ++i) {\n\t\tif (xnum[i] == 0 && xnum[i-1] == 0) {   // i-1 -> i\n\t\t\tFp up = sum - width * num_comped;\n\t\t\tFp down = all - sum;\n\t\t\tadd += up * down;\n\t\t}\n\t\tsum += width - xnum[i];\n  }\n  long long height = H - num_comped;\n  all -= width * num_comped;\n  num_comped = 0;\n  sum = height - ynum[0];\n  for (int i = 1; i < W; ++i) {\n\t\tif (ynum[i] == 0 && ynum[i-1] == 0) {   // i-1 -> i\n\t\t\tFp left = sum - height * num_comped;\n\t\t\tFp right = all - sum;\n\t\t\tadd += left * right;\n\t\t}\n\t\tsum += height - ynum[i];\n  }\n\n  Fp comp = subsolve();\n  Fp res = comp + add;\n\n\t//COUT(add);\n\n  return res;\n}\n\nint main() {\n  while (cin >> H >> W >> N) {\n\t\tfor (int i = 0; i < N; ++i) cin >> bx[i] >> by[i];\n\t\tcout << solve() << endl;\n  }\n}\n"
  },
  {
    "language": "C++",
    "code": "/*#include<cstdio>\n#include<algorithm>\n#include<vector>\n#define pii pair<int,int>\nusing namespace std;\nint n, m, Deg[1010], M;\npii P[1010];\nvector<int>E[1010];\nint main() {\n\tfreopen(\"input.txt\", \"r\", stdin);\n\tfreopen(\"output.txt\", \"w\", stdout);\n\tint i, j, a, b;\n\tscanf(\"%d%d%d\", &n, &m,&M);\n\tfor (i = 1; i < n; i++) {\n\t\tscanf(\"%d%d\", &a, &b);\n\t\tDeg[a]++, Deg[b]++;\n\t\tE[a].push_back(b);\n\t\tE[b].push_back(a);\n\t}\n\tfor (i = 1; i <= n; i++)P[i] = { Deg[i], i };\n\tsort(P + 1, P + n + 1);\n\tfor (i = 1; i < M; i++) {\n\t}\n}*/\n\n#include<cstdio>\n#include<algorithm>\n#include<queue>\nusing namespace std;\nint H, W, N;\nstruct point {\n\tint x, y;\n}w[31], U[91][91][4];\nstruct AA {\n\tint x, y, ck, d;\n\tbool operator<(const AA &p)const {\n\t\treturn d > p.d;\n\t}\n};\npriority_queue<AA>PQ;\nint i, X[31], Y[31], CX, CY;\nstruct Range {\n\tint b, e;\n}XX[91], YY[91];\nint XL[91], YL[91];\nint D[91][91][4], P[91][91];\nvoid Put(int x, int y, int ck, int d) {\n\tif (D[x][y][ck] <= d)return;\n\tD[x][y][ck] = d;\n\tPQ.push({ x,y,ck,d });\n}\nint dx[4] = { 1,0,-1,0 }, dy[4] = { 0,1,0,-1 };\nint dist(point a, point b) {\n\treturn abs(a.x - b.x) + abs(a.y - b.y);\n}\nint DD[91][91], Mod = 1000000007;\nlong long res = 0;\nint Area(int x, int y) {\n\treturn 1ll * XL[x]*YL[y] % Mod;\n}\nint Calc2(int a) {\n\treturn (1ll * a*(a + 1)*(2 * a - 2) / 6)%Mod;\n}\nint Calc(int a, int b, int c, int d) {\n\tint r = 0;\n\tif (a == c) {\n\t\tr = (r + 1ll * Calc2(XL[a]) * YL[b] % Mod * YL[d] % Mod) % Mod;\n\t}\n\telse {\n\t\tint t = abs(XX[c].b - XX[a].b) + abs(XX[c].e - XX[a].b) + abs(XX[c].b - XX[a].e) + abs(XX[c].e - XX[a].e);\n\t\tr = (r + (1ll * t*XL[a] * XL[c] / 4)%Mod*YL[b]%Mod*YL[d]) % Mod;\n\t}\n\tif (b == d) {\n\t\tr = (r + 1ll * Calc2(YL[b]) * XL[a] % Mod * XL[c] % Mod) % Mod;\n\t}\n\telse {\n\t\tint t = abs(YY[d].b - YY[b].b) + abs(YY[d].b - YY[b].e) + abs(YY[d].e - YY[b].b) + abs(YY[d].e - YY[b].e);\n\t\tr = (r + (1ll * t*YL[b] * YL[d] / 4)%Mod*XL[a]%Mod*XL[c]) % Mod;\n\t}\n\treturn r;\n\n}\nvoid Do(int x, int y) {\n\tint i, j, k;\n\tfor (i = 1; i <= CX; i++)for (j = 1; j <= CY; j++)for (k = 0; k < 4; k++)D[i][j][k] = 1e9;\n\tPut(x, y, 0, 0);\n\twhile (!PQ.empty()) {\n\t\tAA tp = PQ.top();\n\t\tPQ.pop();\n\t\tint dd = D[tp.x][tp.y][tp.ck];\n\t\tif (dd != tp.d)continue;\n\t\tpoint tt = U[tp.x][tp.y][tp.ck] ;\n\t\tfor (i = 0; i < 4; i++) {\n\t\t\tfor (j = 0; j < 4; j++) {\n\t\t\t\tint xx = tp.x + dx[i], yy = tp.y + dy[i];\n\t\t\t\tif (xx<1 || xx>CX || yy<1 || yy>CY || P[xx][yy])continue;\n\t\t\t\tPut(xx, yy, j, dist(tt, U[xx][yy][j]) + dd);\n\t\t\t}\n\t\t}\n\t}\n\tfor (i = 1; i <= CX; i++)for (j = 1; j <= CY; j++) {\n\t\tif (P[i][j])continue;\n\t\tDD[i][j] = D[i][j][0] - dist(U[x][y][0], U[i][j][0]);\n\t\tres = (res + 1ll * Area(i, j)*Area(x, y) % Mod*DD[i][j]) % Mod;\n\t\tres = (res + Calc(i, j, x, y)) % Mod;\n\t}\n}\nint main() {\n\tint i, j;\n\tscanf(\"%d%d%d\", &H, &W, &N);\n\tfor (i = 0; i < N; i++) {\n\t\tscanf(\"%d%d\", &w[i].x, &w[i].y);\n\t\tw[i].x++, w[i].y++;\n\t\tX[CX++] = w[i].x;\n\t\tY[CY++] = w[i].y;\n\t}\n\tX[CX++] = 0; X[CX++] = H + 1;\n\tY[CY++] = 0; Y[CY++] = W + 1;\n\tsort(X, X + CX); sort(Y, Y + CY);\n\tCX = unique(X, X + CX) - X;\n\tCY = unique(Y, Y + CY) - Y;\n\tint c1 = 0, c2 = 0;\n\tfor (i = 0; i < CX - 1; i++) {\n\t\tif (X[i] >= 1 && X[i] <= H) {\n\t\t\tXX[++c1] = { X[i],X[i] };\n\t\t}\n\t\tif (X[i + 1] - X[i] >= 2) XX[++c1] = { X[i] + 1,X[i + 1] - 1 };\n\t}\n\tfor (i = 0; i < CY - 1; i++) {\n\t\tif (Y[i] >= 1 && Y[i] <= W) {\n\t\t\tYY[++c2] = { Y[i],Y[i] };\n\t\t}\n\t\tif (Y[i + 1] - Y[i] >= 2) YY[++c2] = { Y[i] + 1,Y[i + 1] - 1 };\n\t}\n\tCX = c1, CY = c2;\n\tfor (int ii = 0; ii < N; ii++) {\n\t\tfor (i = 1; i <= CX; i++)for (j = 1; j <= CY; j++) {\n\t\t\tif (XX[i].b == w[ii].x && YY[j].b == w[ii].y) {\n\t\t\t\tP[i][j] = 1;\n\t\t\t}\n\t\t}\n\t}\n\tfor (i = 1; i <= CX; i++)for (j = 1; j <= CY; j++) {\n\t\tU[i][j][0] = { XX[i].b,YY[j].b };\n\t\tU[i][j][1] = { XX[i].b,YY[j].e };\n\t\tU[i][j][2] = { XX[i].e,YY[j].b };\n\t\tU[i][j][3] = { XX[i].e,YY[j].e };\n\t}\n\tfor (i = 1; i <= CX; i++)XL[i] = XX[i].e - XX[i].b + 1;\n\tfor (i = 1; i <= CY; i++)YL[i] = YY[i].e - YY[i].b + 1;\n\tfor (i = 1; i <= CX; i++)for (j = 1; j <= CY; j++) {\n\t\tif(!P[i][j])Do(i, j);\n\t}\n\tprintf(\"%lld\\n\", 1ll*res*((Mod+1)/2)%Mod);\n\treturn 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include <cstring>\n#include <cstdio>\nusing ll = long long;\nconstexpr int MOD = 1e9 + 7;\nconstexpr int dx[] = {1, -1, 0, 0}, dy[] = {0, 0, 1, -1};\nint app_x[1000005], app_y[1000005], idx_x[1000005], idx_y[1000005];\nint px[65], py[65], dis[65][65], que[100005], sz_x[65], sz_y[65], ans;\nbool vis[65][65];\nvoid compress(int n, int m, int k, int *app, int *idx, int *sz)\n{\n\tsz[0] = 1;\n\tint u = m - app[0], d = ((ll)n * m - k - u) % MOD;\n\tfor (int i = 1; i < n; i++)\n\t{\n\t\tidx[i] = idx[i - 1];\n\t\tif (!app[i] && !app[i - 1])\n\t\t\tans = (ans + (ll)2 * u * d) % MOD;\n\t\telse\n\t\t\tidx[i]++;\n\t\tsz[idx[i]]++;\n\t\tu = (u + m - app[i]) % MOD;\n\t\td = (d + app[i] - m + MOD) % MOD;\n\t}\n}\ninline int calc(int x, int y) { return (ll)sz_x[x] * sz_y[y] % MOD; }\ninline void bfs(int n, int m, int sx, int sy)\n{\n\tmemset(dis, 0x3f, sizeof(dis));\n\tint he = 0, ta = 0;\n\tque[ta++] = sx;\n\tque[ta++] = sy;\n\tdis[sx][sy] = 0;\n\twhile (he < ta)\n\t{\n\t\tint x = que[he++], y = que[he++];\n\t\tans = (ans + (ll)calc(x, y) * calc(sx, sy) % MOD * dis[x][y]) % MOD;\n\t\tfor (int i = 0; i < 4; i++)\n\t\t{\n\t\t\tint xx = x + dx[i], yy = y + dy[i];\n\t\t\tif (xx < 0 || xx >= n || yy < 0 || yy >= m)\n\t\t\t\tcontinue;\n\t\t\tif (!vis[xx][yy] && dis[xx][yy] > 1e9)\n\t\t\t{\n\t\t\t\tdis[xx][yy] = dis[x][y] + 1;\n\t\t\t\tque[ta++] = xx;\n\t\t\t\tque[ta++] = yy;\n\t\t\t}\n\t\t}\n\t}\n}\nint main()\n{\n\t// freopen(\"J.in\", \"r\", stdin);\n\tint n, m, k;\n\tscanf(\"%d%d%d\", &n, &m, &k);\n\tfor (int i = 0; i < n; i++)\n\t{\n\t\tscanf(\"%d%d\", px + i, py + i);\n\t\tapp_x[px[i]]++;\n\t\tapp_y[py[i]]++;\n\t}\n\tcompress(n, m, k, app_x, idx_x, sz_x);\n\tcompress(m, n, k, app_y, idx_y, sz_y);\n\tfor (int i = 0; i < k; i++)\n\t\tvis[idx_x[px[i]]][idx_y[py[i]]] = true;\n\tfor (int i = 0; i <= idx_x[n - 1]; i++)\n\t{\n\t\tfor (int j = 0; j <= idx_y[m - 1]; j++)\n\t\t{\n\t\t\tif (!vis[i][j])\n\t\t\t\tbfs(idx_x[n - 1] + 1, idx_y[m - 1] + 1, i, j);\n\t\t}\n\t}\n\tprintf(\"%lld\\n\", (ll)ans * (MOD + 1) / 2 % MOD);\n\treturn 0;\n}\n"
  },
  {
    "language": "C++",
    "code": "#include <cstdio>\n#include <vector>\n#include <algorithm>\n#include <functional>\n#include <map>\n#include <set>\n#include <string>\n#include <iostream>\n#include <cassert>\n#include <cmath>\n#include <queue>\nusing namespace std;\n\nconst int MOD = 1e9 + 7;\n\nstruct state { int y, x, step; };\nstatic const int dx[] = {1, 0, -1, 0}, dy[] = {0, 1, 0, -1};\n\nint main() {\n        long long h, w;\n        scanf(\"%lld %lld\", &h, &w);\n        int n;\n        scanf(\"%d\", &n);\n        vector<int> w_cnt(w, 0), h_cnt(h, 0);\n        vector<bool> w_exist(w, false), h_exist(h, false);\n        vector<pair<int, int>> black;\n        for (int i = 0; i < n; i ++) {\n                int y, x;\n                scanf(\"%d %d\", &y, &x);\n                w_cnt[x] ++;\n                h_cnt[y] ++;\n                w_exist[x] = true;\n                h_exist[y] = true;\n                black.emplace_back(x, y);\n        }\n        for (int i = 1; i < w; i ++) w_cnt[i] += w_cnt[i - 1];\n        for (int i = 1; i < h; i ++) h_cnt[i] += h_cnt[i - 1];\n        long long ans = 0;\n        //precalc\n        for (int i = 0; i < w - 1; i ++) {\n                if (!w_exist[i] && !w_exist[i + 1]) {\n                        long long left = (long long) (i + 1) * h % MOD - w_cnt[i];\n                        long long right = (long long) (w - (i + 1)) * h % MOD - (n - w_cnt[i]);\n                        ans += left * right;\n                        ans %= MOD;\n                }\n        }\n        for (int i = 0; i < h - 1; i ++) {\n                if (!h_exist[i] && !h_exist[i + 1]) {\n                        long long left = (long long) (i + 1) * w % MOD - h_cnt[i];\n                        long long right = (long long) (h - (i + 1)) * w % MOD - (n - h_cnt[i]);\n                        ans += left * right;\n                        ans %= MOD;\n                }\n        }\n        //compress\n        map<int, int> newx, newy;\n        vector<pair<long long, bool>> widths, heights; //(length, is_white)\n        {\n                int cnt = 0;\n                for (int i = 0; i < w; i ++) {\n                        if (!w_exist[i]) {\n                                cnt ++;\n                        } else {\n                                if (cnt) {\n                                        widths.emplace_back(cnt, true);\n                                        cnt = 0;\n                                }\n                                newx[i] = (int) widths.size();\n                                widths.emplace_back(1, false);\n                        }\n                }\n                if (cnt) widths.emplace_back(cnt, true);\n        }\n        {\n                int cnt = 0;\n                for (int i = 0; i < h; i ++) {\n                        if (!h_exist[i]) {\n                                cnt ++;\n                        } else {\n                                if (cnt) {\n                                        heights.emplace_back(cnt, true);\n                                        cnt = 0;\n                                }\n                                newy[i] = (int) heights.size();\n                                heights.emplace_back(1, false);\n                        }\n                }\n                if (cnt) heights.emplace_back(cnt, true);\n        }\n        //re-write the grid\n        int neww = (int) widths.size();\n        int newh = (int) heights.size();\n        vector<vector<long long>> s(newh, vector<long long> (neww, 1)); //-1 when it's black, weight when it's white\n        for (auto b : black) {\n                s[newy[b.second]][newx[b.first]] = -1;\n        }\n        for (int i = 0; i < newh; i ++) {\n                for (int j = 0; j < neww; j ++) {\n                        if (heights[i].second || widths[j].second) {\n                                s[i][j] = heights[i].first * widths[j].first % MOD;\n                        }\n                }\n        }\n        //BFS\n        long long sum = 0;\n        for (int sy = 0; sy < newh; sy ++) {\n                for (int sx = 0; sx < neww; sx ++) {\n                        if (s[sy][sx] == -1) continue;\n                        long long res = s[sy][sx];\n                        vector<vector<bool>> used(newh, vector<bool>(neww, false));\n                        queue<state> q;\n                        q.push({sy, sx, 0});\n                        used[sy][sx] = true;\n                        while (!q.empty()) {\n                                state p = q.front(); q.pop();\n                                if (p.y != sy || p.x != sx) {\n                                        assert(s[p.y][p.x] != -1);\n                                        sum += (long long) p.step * res % MOD * s[p.y][p.x] % MOD;\n                                        sum %= MOD;\n                                }\n                                for (int d = 0; d < 4; d ++) {\n                                        int xx = p.x + dx[d], yy = p.y + dy[d];\n                                        if (xx < 0 || xx >= neww || yy < 0 || yy >= newh) continue;\n                                        if (used[yy][xx] || s[yy][xx] == -1) continue;\n                                        used[yy][xx] = true;\n                                        q.push({yy, xx, p.step + 1});\n                                }\n                        }\n                }\n        }\n        sum *= (MOD + 1) / 2;\n        sum %= MOD;\n        ans += sum;\n        ans %= MOD;\n        printf(\"%lld\\n\", ans);\n        return 0;\n}\n"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\nusing namespace std;\n\n#define pii pair<int, int>\n#define mp make_pair\n\nconst int maxN = 1e6 + 10, mod = 1e9 + 7, I = (mod + 1) / 2;\nconst int mv[4][2] = {{1, 0}, {-1, 0}, {0, 1}, {0, -1}};\n\nint n, m, s, ans, clk;\nint v1[maxN + 1], v2[maxN + 1];\nint id1[105], id2[105], w, h;\nint t1[105], t2[105];\nint val[105][105], vis[105][105], dep[105][105];\n\nmap<pii, bool> f;\n\ninline void update(int &x, int y) { x = x + y >= mod ? x + y - mod : x + y; }\n\ninline void bfs(int xs, int ys)\n{\n\tclk ++;\n\tqueue<pii> q;\n\tq.push( mp(xs, ys) ); \n\tvis[xs][ys] = clk; dep[xs][ys] = 0;\n\twhile(!q.empty())\n\t{\n\t\tint x = q.front().first, y = q.front().second; q.pop();\n\t\tfor(int i = 0; i < 4; i++)\n\t\t{\n\t\t\tint nx = x + mv[i][0], ny = y + mv[i][1];\n\t\t\tif(nx < 1 || ny < 1 || nx > w || ny > h) continue;\n\t\t\tif(vis[nx][ny] != clk && val[nx][ny])\n\t\t\t{\n\t\t\t\tvis[nx][ny] = clk;\n\t\t\t\tdep[nx][ny] = dep[x][y] + 1;\n\t\t\t\tq.push( mp(nx, ny) );\n\t\t\t}\n\t\t}\n\t}\n}\n\nint main()\n{\n\tscanf(\"%d %d\", &n, &m);\n\tscanf(\"%d\", &s);\n\tfor(int i = 1; i <= s; i++)\n\t{\n\t\tint x, y;\n\t\tscanf(\"%d %d\", &x, &y);\n\t\tx ++, y ++;\n\t\tv1[x] ++, v2[y] ++;\n\t\tf[ mp(x, y) ] = true;\n\t}\n\n\tint sum = 0;\n\tfor(int i = 1; i < n; i++)\n\t{\n\t\tupdate(sum, v1[i]);\n\t\tif(v1[i] || v1[i + 1]) continue;\n\t\tint a = (1ll * i * m - sum) % mod, b = (1ll * (n - i) * m - (s - sum)) % mod;\n\t\tupdate(ans, 1ll * a * b % mod);\n\t}\n\tsum = 0;\n\tfor(int i = 1; i < m; i++)\n\t{\n\t\tupdate(sum, v2[i]);\n\t\tif(v2[i] || v2[i + 1]) continue;\n\t\tint a = (1ll * n * i - sum) % mod, b = (1ll * n * (m - i) - (s - sum)) % mod;\n\t\tupdate(ans, 1ll * a * b % mod);\n\t}\n\n\tint l = 1, r;\n\twhile(l <= n)\n\t{\n\t\tr = l;\n\t\twhile(!v1[r] && r <= n) r ++;\n\t\tw ++;\n\t\tif(l == r) id1[w] = r, t1[w] = 1, l = r + 1;\n\t\telse id1[w] = r - 1, t1[w] = r - l, l = r;\n\t}\n\tl = 1, r;\n\twhile(l <= m)\n\t{\n\t\tr = l;\n\t\twhile(!v2[r] && r <= m) r ++;\n\t\th ++;\n\t\tif(l == r) id2[h] = r, t2[h] = 1, l = r + 1;\n\t\telse id2[h] = r - 1, t2[h] = r - l, l = r;\n\t}\n\n\tfor(int i = 1; i <= w; i++)\n\t\tfor(int j = 1; j <= h; j++)\n\t\t\tif(f.find( mp(id1[i], id2[j]) ) != f.end()) val[i][j] = 0;\n\t\t\telse val[i][j] = 1ll * t1[i] * t2[j] % mod;\n\n\tint res = 0;\n\tfor(int i = 1; i <= w; i++)\n\t\tfor(int j = 1; j <= h; j++)\n\t\t{\n\t\t\tif(!val[i][j]) continue;\n\t\t\tbfs(i, j);\n\t\t\tfor(int k = 1; k <= w; k++)\n\t\t\t\tfor(int t = 1; t <= h; t++)\n\t\t\t\t\tupdate(res, 1ll * dep[k][t] * val[k][t] % mod * val[i][j] % mod);\n\t\t}\n\tupdate(ans, 1ll * res * I % mod);\n\n\tprintf(\"%d\\n\", ans);\n\treturn 0;\n}\n"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\nusing namespace std;\ntypedef long long lint;\ntypedef pair<int, int> pi;\nconst int MAXN = 100005;\nconst int mod = 1e9 + 7;\nconst lint inv2 = (mod + 1) / 2;\n\nstruct rt{\n\tint sx, ex, sy, ey;\n\tint ssi, sei, esi, eei;\n\tint type;\n\tbool operator<(const rt &r)const{\n\t\treturn type < r.type;\n\t}\n};\n\nlint sum(int x){\n\treturn ( 1ll * x * (x+1) / 2 ) % mod;\n}\n\nvector<rt> rect;\nvector<pi> pnt;\nvector<pi> gph[9000];\nint dist1[9000], dist2[9000];\n\nvoid dijkstra(int p, int *d){\n\tpriority_queue<pi, vector<pi>, greater<pi> > pq;\n\tpq.push(pi(0, p));\n\td[p] = 0;\n\twhile(!pq.empty()){\n\t\tauto x = pq.top();\n\t\tpq.pop();\n\t\tif(d[x.second] != x.first) continue;\n\t\tfor(auto &i : gph[x.second]){\n\t\t\tif(d[i.second] > x.first + i.first){\n\t\t\t\td[i.second] = x.first + i.first;\n\t\t\t\tpq.push(pi(d[i.second], i.second));\n\t\t\t}\n\t\t}\n\t}\n}\n\nlint sum2(int x){\n\tlint k = x * (1ll * (x + 1) * (2 * x + 1) % mod) % mod;\n\tk *= (mod + 1) / 6;\n\tk %= mod;\n\treturn k;\n}\n\nlint twostrip(int sx, int ex, int sy, int ey){\n\tif(sx == sy && ex == ey){\n\t\tint dx = ex - sx;\n\t\tlint ans = (dx + 1) * sum(dx) % mod;\n\t\tans += mod - sum2(dx);\n\t\tans <<= 1;\n\t\treturn ans % mod;\n\t}\n\telse{\n\t\tif(ex < sy){\n\t\t\tlint ans = 0;\n\t\t\tans += sum(ex - sx) * (ey - sy + 1);\n\t\t\tans += sum(ey - sy) * (ex - sx + 1);\n\t\t\tans += (sy - ex) * (ey - sy + 1) * (ex - sx + 1);\n\t\t\tans %= mod;\n\t\t\treturn ans;\n\t\t}\n\t\telse return twostrip(sy, ey, sx, ex);\n\t}\n}\n\nvoid debug(rt r){\n\treturn;\n\tprintf(\"%d %d %d %d %d\\n\", r.sx, r.ex, r.sy, r.ey, r.type);\n}\nlint getMyself(int x, int y){\n\tlint ans = 0;\n\tans += twostrip(1, x, 1, x) * (1ll * y * y % mod) % mod;\n\tans += twostrip(1, y, 1, y) * (1ll * x * x % mod) % mod;\n\tans %= mod;\n\tans *= inv2;\n\tans %= mod;\n\treturn ans;\n}\n\nlint get33(rt a, rt b){\n\tlint ans = 0;\n\tans += twostrip(a.sx, a.ex, b.sx, b.ex) * (1ll * (a.ey - a.sy + 1) * (b.ey - b.sy + 1) % mod) % mod;\n\tans += twostrip(a.sy, a.ey, b.sy, b.ey) * (1ll * (a.ex - a.sx + 1) * (b.ex - b.sx + 1) % mod) % mod;\n\treturn ans % mod;\n}\n\nlint get12(int l, int r, int n){\n\tlint ans = 0;\n\tif(l + n <= r) return (sum(l + n) - sum(l - 1) + mod) % mod;\n\tif(r + n <= l) return (sum(r + n) - sum(r - 1) + mod) % mod;\n\tif(l > r) swap(l, r);\n\tint m = (r + n - l) / 2;\n\tans += sum(l + m) - sum(l - 1);\n\tans += sum(r + (n - m) - 1) - sum(r - 1);\n\tans %= mod;\n\tans += mod;\n\tans %= mod;\n\tans %= mod;\n\treturn ans;\n}\n\nlint get13(int k, int n, int m){\n\tlint ans = 1ll * k * (n+1) * (m+1) % mod;\n\tans += sum(n) * (m + 1);\n\tans += sum(m) * (n + 1);\n\treturn ans % mod;\n}\n\nlint solve(){\n\tlint ans = 0;\n\tfor(int i=0; i<rect.size(); i++){\n\t\tans += getMyself(rect[i].ex - rect[i].sx + 1, rect[i].ey - rect[i].sy + 1);\n\t\tif(rect[i].type != 3){\n\t\t\t// Dijkstra SHOULD BE VERY FAST!\n\t\t\tmemset(dist1, 0x3f, sizeof(dist1));\n\t\t\tdijkstra(rect[i].ssi, dist1);\n\t\t\tif(rect[i].eei != rect[i].ssi){\n\t\t\t\tmemset(dist2, 0x3f, sizeof(dist2));\n\t\t\t\tdijkstra(rect[i].eei, dist2);\n\t\t\t}\n\t\t}\n\t\tfor(int j=i+1; j<rect.size(); j++){\n\t\t\tif(rect[i].type == 1 && rect[j].type == 1){\n\t\t\t\t// Easy, just use result from dijkstra\n\t\t\t\tans += dist1[rect[j].ssi]; \n\t\t\t}\n\t\t\tif(rect[i].type == 1 && rect[j].type == 2){\n\t\t\t\t// Try two sinks, and brute force from there.\n\t\t\t\tint p1 = dist1[rect[j].ssi];\n\t\t\t\tint p2 = dist1[rect[j].eei];\n\t\t\t\tans += get12(p1, p2, max(rect[j].ex - rect[j].sx, rect[j].ey - rect[j].sy));\n\t\t\t}\n\t\t\tif(rect[i].type == 1 && rect[j].type == 3){\n\t\t\t\t// Observation : It's always advantageous to go to fastest corner.\n\t\t\t\tint fastest = \n\t\t\t\t\tmin({dist1[rect[j].ssi], dist1[rect[j].sei], dist1[rect[j].esi], dist1[rect[j].eei]});\n\t\t\t\t// Fastest corners are detected, and we can calculate with math formula.\n\t\t\t\tans += get13(fastest, rect[j].ex - rect[j].sx, rect[j].ey - rect[j].sy);\n\t\t\t}\n\t\t\tif(rect[i].type == 2 && rect[j].type == 2){\n\t\t\t\tdebug(rect[i]);\n\t\t\t\tdebug(rect[j]);\n\t\t\t\tif(rect[i].sx < rect[i].ex && rect[j].sx < rect[j].ex && rect[i].sx == rect[j].sx){\n\t\t\t\t\t// X-intervals coincide\n\t\t\t\t\tans += get33(rect[i], rect[j]);\n\t\t\t\t}\n\t\t\t\telse if(rect[i].sy < rect[i].ey && rect[j].sy < rect[j].ey && rect[i].sy == rect[j].sy){\n\t\t\t\t\t// Y-intervals coincide\n\t\t\t\t\tans += get33(rect[i], rect[j]);\n\t\t\t\t}\n\t\t\t\telse{\n\t\t\t\t\t// Now we can assure that intervals ONLY coincide when they are points.\n\t\t\t\t\t//\n\t\t\t\t\tint fastest = min(dist1[rect[j].ssi], dist1[rect[j].eei]);\n\t\t\t\t\tif(rect[i].ssi != rect[i].eei){\n\t\t\t\t\t\tfastest = min({fastest, dist2[rect[j].ssi], dist2[rect[j].eei]});\n\t\t\t\t\t}\n\t\t\t\t\tans += get13(fastest, \n\t\t\t\t\t\t\trect[i].ex - rect[i].sx + rect[i].ey - rect[i].sy,\n\t\t\t\t\t\t\trect[j].ex - rect[j].sx + rect[j].ey - rect[j].sy);\n\t\t\t\t}\n\t\t\t}\n\t\t\tif(rect[i].type == 2 && rect[j].type == 3){\n\t\t\t\t// This is analogous with 3-3 case.\n\t\t\t\tans += get33(rect[i], rect[j]);\n\t\t\t}\n\t\t\tif(rect[i].type == 3 && rect[j].type == 3){\n\t\t\t\t// Obstacles are not important in here.\n\t\t\t\tans += get33(rect[i], rect[j]);\n\t\t\t}\n\t\t}\n\t}\n\tans %= mod;\n\treturn ans;\n}\n\nint h, w, n, x[31], y[31];\nvector<int> vx, vy;\n\nint getsum(pi a, pi b){\n\tfor(int i=0; i<n; i++){\n\t\tif(a.first <= x[i] && x[i] <= b.first && a.second <= y[i] && y[i] <= b.second){\n\t\t\treturn 1;\n\t\t}\n\t}\n\treturn 0;\n}\n\nvoid make_edge(vector<pi> v){\n\tfor(int i=1; i<v.size(); i++){\n\t\tif(v[i-1].first == v[i].first || v[i-1].second == v[i].second){\n\t\t\tint p1 = lower_bound(pnt.begin(), pnt.end(), v[i-1]) - pnt.begin();\n\t\t\tint p2 = lower_bound(pnt.begin(), pnt.end(), v[i]) - pnt.begin();\n\t\t\tint dx = abs(v[i].first - v[i-1].first) + abs(v[i].second - v[i-1].second);\n\t\t\tif(getsum(v[i-1], v[i]) == 0){\n\t\t\t\tgph[p1].push_back(pi(dx, p2));\n\t\t\t\tgph[p2].push_back(pi(dx, p1));\n\t\t\t}\n\t\t}\n\t}\n}\n\nint main(){\n\tcin >> h >> w >> n;\n\tfor(int i=0; i<n; i++){\n\t\tcin >> x[i] >> y[i];\n\t\tx[i]++;\n\t\ty[i]++;\n\t\tvx.push_back(x[i]);\n\t\tvy.push_back(y[i]);\n\t}\n\tvx.push_back(0); vx.push_back(h+1);\n\tvy.push_back(0); vy.push_back(w+1);\n\tsort(vx.begin(), vx.end());\n\tsort(vy.begin(), vy.end());\n\tvx.resize(unique(vx.begin(), vx.end()) - vx.begin());\n\tvy.resize(unique(vy.begin(), vy.end()) - vy.begin());\n\tvector<pi> ix, iy;\n\tfor(int i=0; i+1<vx.size(); i++){\n\t\tif(i != 0) ix.push_back(pi(vx[i], vx[i]));\n\t\tif(vx[i] + 1 < vx[i+1]) ix.push_back(pi(vx[i] + 1, vx[i+1] - 1));\n\t}\n\tfor(int i=0; i+1<vy.size(); i++){\n\t\tif(i != 0) iy.push_back(pi(vy[i], vy[i]));\n\t\tif(vy[i] + 1 < vy[i+1]) iy.push_back(pi(vy[i] + 1, vy[i+1] - 1));\n\t}\n\tfor(auto &i : ix){\n\t\tfor(auto &j : iy){\n\t\t\t// Build rectangles from parsed intervals\n\t\t\tint type = 1;\n\t\t\tif(i.first != i.second || *lower_bound(vx.begin(), vx.end(), i.first) != i.first){\n\t\t\t\t// X coordinates are not bounded\n\t\t\t\ttype++;\n\t\t\t}\n\t\t\tif(j.first != j.second || *lower_bound(vy.begin(), vy.end(), j.first) != j.first){\n\t\t\t\t// Y coordinates are not bounded\n\t\t\t\ttype++;\n\t\t\t}\n\t\t\tfor(int k=0; k<n; k++){\n\t\t\t\tif(type == 1 && x[k] == i.first && y[k] == j.first){\n\t\t\t\t\t// Both coordinates are bounded, and it coincides with black point\n\t\t\t\t\ttype--;\n\t\t\t\t}\n\t\t\t}\n\t\t\tif(type == 0) continue;\n\t\t\t// Good\n\t\t\trect.push_back({i.first, i.second, j.first, j.second, -1, -1, -1, -1, type});\n\t\t}\n\t}\n\tsort(rect.begin(), rect.end());\n\tfor(auto &i : rect){\n\t\tpnt.push_back(pi(i.sx, i.sy));\n\t\tpnt.push_back(pi(i.sx, i.ey));\n\t\tpnt.push_back(pi(i.ex, i.sy));\n\t\tpnt.push_back(pi(i.ex, i.ey));\n\t}\n\tsort(pnt.begin(), pnt.end());\n\tpnt.resize(unique(pnt.begin(), pnt.end()) - pnt.begin());\n\tvector<pi> w = pnt;\n\tmake_edge(w);\n\tsort(w.begin(), w.end(), [&](const pi &a, const pi &b){\n\t\treturn pi(a.second, a.first) < pi(b.second, b.first);\n\t});\n\tmake_edge(w);\n\tfor(auto &i : rect){\n\t\ti.ssi = lower_bound(pnt.begin(), pnt.end(), pi(i.sx, i.sy)) - pnt.begin();\n\t\ti.sei = lower_bound(pnt.begin(), pnt.end(), pi(i.sx, i.ey)) - pnt.begin();\n\t\ti.esi = lower_bound(pnt.begin(), pnt.end(), pi(i.ex, i.sy)) - pnt.begin();\n\t\ti.eei = lower_bound(pnt.begin(), pnt.end(), pi(i.ex, i.ey)) - pnt.begin();\n\t}\n\tcout << solve() << endl;\n}\n"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\nusing namespace std;\n#define ll long long\n#define p (ll)(1e9 + 7)\n#define inf (int)(1e9)\n\nll MOD(ll a){\n\treturn a % p;\n}\n\nint h, w;\nconst ll inv2 = 500000004, inv6 = 166666668;\n\nll calc(int dis, int x1, int dx1, int x2, int dx2, int y1, int dy1, int y2, int dy2){\n\tif(x2 < x1){\n\t\treturn calc(dis, x2, dx2, x1, dx1, y2, dy2, y1, dy1);\n\t}\n\telse if(y2 < y1){\n\t\treturn calc(dis + dx2 - dx1, x1, dx2, x2 + dx2 - dx1, dx1, y2, dy2, y1, dy1);\n\t}\n\telse if(x1 == x2){\n\t\treturn calc(dis, y1, dy1, y2, dy2, x1, dx1, x2, dx2);\n\t}\n\tif(y1 == y2){\n\t\tif(dy1 == 1){\n\t\t\treturn MOD(inv2 * MOD(MOD((ll)dx1 * dx2) * (2 * dis + (dx2 - dx1))));\n\t\t}\n\t\telse{\n\t\t\treturn MOD(inv6 * MOD(MOD((ll)dx1 * dx2 * dy1) * MOD(3ll * dy1 * (2 * (x2 - x1) + (dx2 - dx1)) + (2 * (dy1 - 1) * (dy1 + 1)))));\n\t\t}\n\t}\n\telse{\n\t\treturn MOD(inv2 * MOD(MOD(MOD((ll)dx1 * dx2) * MOD((ll)dy1 * dy2)) * (2 * dis + (dx2 - dx1) + (dy2 - dy1))));\n\t}\n}\n\nint main(){\n\tint H, W, N, i, j, k, l;\n\tscanf(\"%d%d\", &H, &W);\n\tscanf(\"%d\", &N);\n\tvector<int> x_sub(N), y_sub(N), x(0), y(0);\n\tfor(i = 0; i < N; i++){\n\t\tscanf(\"%d%d\", &x_sub[i], &y_sub[i]);\n\t\tx.push_back(x_sub[i]);\n\t\tx.push_back(x_sub[i] + 1);\n\t\tx.push_back(max(0, x_sub[i] - 1));\n\t\ty.push_back(y_sub[i]);\n\t\ty.push_back(y_sub[i] + 1);\n\t\ty.push_back(max(0, y_sub[i] - 1));\n\t}\n\tx.push_back(0);\n\tx.push_back(H);\n\ty.push_back(0);\n\ty.push_back(W);\n\tsort(x.begin(), x.end());\n\tsort(y.begin(), y.end());\n\tfor(i = 1, j = 1; j < x.size(); j++){\n\t\tif(x[j - 1] < x[j]){\n\t\t\tx[i] = x[j];\n\t\t\ti++;\n\t\t}\n\t}\n\th = i - 1;\n\tfor(i = 1, j = 1; j < y.size(); j++){\n\t\tif(y[j - 1] < y[j]){\n\t\t\ty[i] = y[j];\n\t\t\ti++;\n\t\t}\n\t}\n\tw = i - 1;\n\tvector<int> dx(h), dy(w);\n\tfor(i = 0; i < h; i++){\n\t\tdx[i] = x[i + 1] - x[i];\n\t}\n\tfor(i = 0; i < w; i++){\n\t\tdy[i] = y[i + 1] - y[i];\n\t}\n\tvector<vector<char>> A(h, vector<char>(w, '.'));\n\tfor(i = 0; i < h; i++){\n\t\tfor(j = 0; j < w; j++){\n\t\t\tfor(k = 0; k < N; k++){\n\t\t\t\tif(x[i] == x_sub[k] && y[j] == y_sub[k]){\n\t\t\t\t\tA[i][j] = '#';\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t}\n\tvector<vector<int>> dis(h, vector<int>(w, inf));\n\tll ans = 0;\n\tfor(i = 0; i < h; i++){\n\t\tfor(j = (i % 2) * (w - 1); 0 <= j && j < w; j = j + 1 - 2 * (i % 2)){\n\t\t\tif(A[i][j] == '#'){\n\t\t\t\tcontinue;\n\t\t\t}\n\t\t\tll sub = MOD(inv6 * MOD(MOD((ll)dx[i] * dy[j]) * MOD(((ll)dx[i] + dy[j]) * MOD((ll)dx[i] * dy[j] - 1))));\n\t\t\tans = MOD(ans + sub);\n\t\t\tint old_dis = dis[i][j];\n\t\t\tfor(k = 0; k < h; k++){\n\t\t\t\tfor(l = 0; l < w; l++){\n\t\t\t\t\tdis[k][l] = min(dis[k][l] + old_dis, inf);\n\t\t\t\t}\n\t\t\t}\n\t\t\tqueue<pair<pair<int, int>, int>> q;\n\t\t\tq.push(pair<pair<int, int>, int>(pair<int, int>(i, j), 0));\n\t\t\twhile(q.size() > 0){\n\t\t\t\tk = q.front().first.first;\n\t\t\t\tl = q.front().first.second;\n\t\t\t\tint d = q.front().second;\n\t\t\t\tq.pop();\n\t\t\t\tif(A[k][l] == '#' || dis[k][l] <= d){\n\t\t\t\t\tcontinue;\n\t\t\t\t}\n\t\t\t\tdis[k][l] = d;\n\t\t\t\tif(l < w - 1){\n\t\t\t\t\tq.push(pair<pair<int, int>, int>(pair<int, int>(k + 0, l + 1), d + dy[l]));\n\t\t\t\t}\n\t\t\t\tif(k < h - 1){\n\t\t\t\t\tq.push(pair<pair<int, int>, int>(pair<int, int>(k + 1, l + 0), d + dx[k]));\n\t\t\t\t}\n\t\t\t\tif(l > 0){\n\t\t\t\t\tq.push(pair<pair<int, int>, int>(pair<int, int>(k + 0, l - 1), d + dy[l - 1]));\n\t\t\t\t}\n\t\t\t\tif(k > 0){\n\t\t\t\t\tq.push(pair<pair<int, int>, int>(pair<int, int>(k - 1, l + 0), d + dx[k - 1]));\n\t\t\t\t}\n\t\t\t}\n\t\t\tfor(k = 0; k < h; k++){\n\t\t\t\tfor(l = 0; l < w; l++){\n\t\t\t\t\tif(k < i || (i == k && l <= j) || A[k][l] == '#'){\n\t\t\t\t\t\tcontinue;\n\t\t\t\t\t}\n\t\t\t\t\tll res = calc(dis[k][l], x[i], dx[i], x[k], dx[k], y[j], dy[j], y[l], dy[l]);\n\t\t\t\t\tans = MOD(ans + res);\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t}\n\tprintf(\"%lld\\n\", MOD(ans + p));\n\treturn 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\nusing namespace std;\n#define int long long\n#define p (int)(1e9 + 7)\n\nint MOD(int a){\n\treturn (a %= p) >= 0 ? a : a + p;\n}\n\nint power(int a, int N){\n\tif(N == 0){\n\t\treturn 1;\n\t}\n\telse if(N % 2 == 0){\n\t\treturn power(MOD(a * a), N / 2);\n\t}\n\telse{\n\t\treturn MOD(a * power(a, N - 1));\n\t}\n}\n\nint inverse(int a){\n\treturn power(a, p - 2);\n}\n\n#define inf (int)(1e9)\n\nstruct edge{\n\tint to;\n\tint cost;\n\n\tedge(int to, int cost) : to(to), cost(cost){}\n};\n\nvector<int> dijkstra(vector<vector<edge> > &g, int s){\n\tvector<int> ans(g.size(), inf);\n\tpriority_queue<pair<int, int>, vector<pair<int, int> >, greater<pair<int, int> > > q;//(距離, 頂点番号)\n\tq.push(pair<int, int>(0, s));\n\twhile(q.size() > 0){\n\t\tint dis = q.top().first, v = q.top().second;\n\t\tq.pop();\n\t\tif(dis < ans[v]){\n\t\t\tans[v] = dis;\n\t\t\tfor(int i = 0; i < g[v].size(); i++){\n\t\t\t\tq.push(pair<int, int>(dis + g[v][i].cost, g[v][i].to));\n\t\t\t}\n\t\t}\n\t}\n\treturn ans;\n}\n\nint h, w;\nint inv2, inv6;\n\nint align(int i, int j){\n\treturn i * w + j;\n}\n\nint calc(int dis, int x1, int dx1, int x2, int dx2, int y1, int dy1, int y2, int dy2){\n//\tprintf(\"calc(%lld, %lld, %lld, %lld, %lld, %lld, %lld, %lld, %lld)\\n\", dis, x1, dx1, x2, dx2, y1, dy1, y2, dy2);\n\tif(x2 < x1){\n\t\treturn calc(dis, x2, dx2, x1, dx1, y2, dy2, y1, dy1);\n\t}\n\telse if(y2 < y1){\n\t\treturn calc(dis + dx2 - dx1, x1, dx2, x2 + dx2 - dx1, dx1, y2, dy2, y1, dy1);\n\t}\n\telse if(x1 == x2){\n\t\treturn calc(dis, y1, dy1, y2, dy2, x1, dx1, x2, dx2);\n\t}\n\tif(y1 == y2){\n\t\tif(dy1 == 1){\n//\t\t\tprintf(\"test1\\n\");\n\t\t\treturn MOD(inv2 * MOD(MOD(dx1 * dx2) * (2 * dis + (dx2 - dx1))));\n\t\t}\n\t\telse{\n//\t\t\tprintf(\"test2\\n\");\n\t\t\treturn MOD(inv6 * MOD(MOD(MOD(dx1 * dx2) * dy1) * (MOD(3 * dy1 * (2 * (x2 - x1) + (dx2 - dx1))) + MOD(2 * (dy1 - 1) * (dy1 + 1)))));\n\t\t}\n\t}\n\telse{\n//\t\tprintf(\"test3\\n\");\n\t\treturn MOD(inv2 * MOD(MOD(MOD(dx1 * dx2) * MOD(dy1 * dy2)) * MOD(2 * dis + (dx2 - dx1) + (dy2 - dy1))));\n\t}\n}\n\nsigned main(){\n\tint H, W, N, i, j, k, l;\n\tscanf(\"%lld%lld\", &H, &W);\n\tscanf(\"%lld\", &N);\n\tvector<int> x_sub(N), y_sub(N), x(0), y(0);\n\tfor(i = 0; i < N; i++){\n\t\tscanf(\"%lld%lld\", &x_sub[i], &y_sub[i]);\n\t\tx.push_back(x_sub[i]);\n\t\tx.push_back(x_sub[i] + 1);\n\t\tx.push_back(max(0ll, x_sub[i] - 1));\n\t\ty.push_back(y_sub[i]);\n\t\ty.push_back(y_sub[i] + 1);\n\t\ty.push_back(max(0ll, y_sub[i] - 1));\n\t}\n\tx.push_back(0);\n\tx.push_back(H);\n\ty.push_back(0);\n\ty.push_back(W);\n\tsort(x.begin(), x.end());\n\tsort(y.begin(), y.end());\n\tfor(i = 1, j = 1; j < x.size(); j++){\n\t\tif(x[j - 1] < x[j]){\n\t\t\tx[i] = x[j];\n\t\t\ti++;\n\t\t}\n\t}\n\th = i - 1;\n\tfor(i = 1, j = 1; j < y.size(); j++){\n\t\tif(y[j - 1] < y[j]){\n\t\t\ty[i] = y[j];\n\t\t\ti++;\n\t\t}\n\t}\n\tw = i - 1;\n\tvector<int> dx(h), dy(w);\n\tfor(i = 0; i < h; i++){\n\t\tdx[i] = x[i + 1] - x[i];\n\t}\n\tfor(i = 0; i < w; i++){\n\t\tdy[i] = y[i + 1] - y[i];\n\t}\n/*\tprintf(\"x:\\n\");\n\tfor(i = 0; i < h; i++){\n\t\tprintf(\"%lld \", x[i]);\n\t}\n\tprintf(\"\\n\");\n\tprintf(\"dx:\\n\");\n\tfor(i = 0; i < h; i++){\n\t\tprintf(\"%lld \", dx[i]);\n\t}\n\tprintf(\"\\n\");\n\tprintf(\"y:\\n\");\n\tfor(j = 0; j < w; j++){\n\t\tprintf(\"%lld \", y[j]);\n\t}\n\tprintf(\"\\n\");\n\tprintf(\"dy:\\n\");\n\tfor(i = 0; i < w; i++){\n\t\tprintf(\"%lld \", dy[i]);\n\t}\n\tprintf(\"\\n\");\n*/\tvector<vector<char>> A(h, vector<char>(w, '.'));\n\tfor(i = 0; i < h; i++){\n\t\tfor(j = 0; j < w; j++){\n\t\t\tfor(k = 0; k < N; k++){\n\t\t\t\tif(x[i] == x_sub[k] && y[j] == y_sub[k]){\n\t\t\t\t\tA[i][j] = '#';\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t}\n/*\tprintf(\"A:\\n\");\n\tfor(i = 0; i < h; i++){\n\t\tfor(j = 0; j < w; j++){\n\t\t\tprintf(\"%c\", A[i][j]);\n\t\t}\n\t\tprintf(\"\\n\");\n\t}\n\tprintf(\"\\n\");\n*/\tvector<vector<edge>> g(h * w, vector<edge>());\n\tfor(i = 0; i < h; i++){\n\t\tfor(j = 1; j < w; j++){\n\t\t\tif(A[i][j - 1] == '.' && A[i][j] == '.'){\n\t\t\t\tg[align(i, j - 1)].push_back(edge(align(i, j), y[j] - y[j - 1]));\n\t\t\t\tg[align(i, j)].push_back(edge(align(i, j - 1), y[j] - y[j - 1]));\n\t\t\t}\n\t\t}\n\t}\n\tfor(i = 1; i < h; i++){\n\t\tfor(j = 0; j < w; j++){\n\t\t\tif(A[i - 1][j] == '.' && A[i][j] == '.'){\n\t\t\t\tg[align(i - 1, j)].push_back(edge(align(i, j), x[i] - x[i - 1]));\n\t\t\t\tg[align(i, j)].push_back(edge(align(i - 1, j), x[i] - x[i - 1]));\n\t\t\t}\n\t\t}\n\t}\n\tint ans = 0;\n\tinv2 = inverse(2);\n\tinv6 = inverse(6);\n\tfor(i = 0; i < h; i++){\n\t\tfor(j = 0; j < w; j++){\n\t\t\tif(A[i][j] == '#'){\n\t\t\t\tcontinue;\n\t\t\t}\n//\t\t\tprintf(\"(i, j) = (%lld, %lld)\\n\", i, j);\n\t\t\tint sub = MOD(inv6 * MOD(MOD(dx[i] * dy[j]) * MOD((dx[i] + dy[j]) * MOD(dx[i] * dy[j] - 1))));\n//\t\t\tprintf(\"ans += 2 * %lld\\n\", sub);\n\t\t\tans = MOD(ans + sub);\n\t\t\tvector<int> dis = dijkstra(g, align(i, j));\n\t\t\tfor(k = 0; k < h; k++){\n\t\t\t\tfor(l = 0; l < w; l++){\n\t\t\t\t\tif(k < i || (i == k && l <= j) || A[k][l] == '#'){\n\t\t\t\t\t\tcontinue;\n\t\t\t\t\t}\n//\t\t\t\t\tprintf(\"(k, l) = (%lld, %lld)\\n\", k, l);\n\t\t\t\t\tint res = calc(dis[align(k, l)], x[i], dx[i], x[k], dx[k], y[j], dy[j], y[l], dy[l]);\n//\t\t\t\t\tprintf(\"ans += %lld\\n\", res);\n\t\t\t\t\tans = MOD(ans + res);\n\t\t\t\t}\n\t\t\t}\n//\t\t\tprintf(\"\\n\");\n\t\t}\n\t}\n//\tans = MOD(ans * inv2);\n\tprintf(\"%lld\\n\", ans);\n\treturn 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\nusing namespace std;\n\nusing ll = long long;\nusing i128 = __int128_t;\n\nint main(){\n\tios_base::sync_with_stdio(0), cin.tie(0), cout.tie(0);\n\tint A, B;\n\tcin >> A >> B;\n\tint k;\n\tcin >> k;\n\tvector<pair<int,int> > pts(k);\n\tset<int> verts_x, verts_y;\n\tverts_x.insert(0); verts_x.insert(A);\n\tverts_y.insert(0); verts_y.insert(B);\n\tfor(pair<int,int>& p : pts){\n\t\tcin >> p.first >> p.second;\n\t\tfor(int j = -2; j <= 1; j++) if(p.first + j >= 0) verts_x.insert(p.first + j);\n\t\tfor(int j = -2; j <= 1; j++) if(p.second + j >= 0) verts_y.insert(p.second + j);\n\t}\n\tvector<int> loc_x, loc_y;\n\tfor(int x : verts_x) loc_x.push_back(x);\n\tfor(int y : verts_y) loc_y.push_back(y);\n\tint num_x = (int)loc_x.size() - 1;\n\tint num_y = (int)loc_y.size() - 1;\n\tvector<vector<bool> > occ(num_x, vector<bool>(num_y, false));\n\tfor(int i = 0; i < num_x; i++){\n\t\tfor(int j = 0; j < num_y; j++){\n\t\t\tfor(pair<int,int> p : pts){\n\t\t\t\tif(loc_x[i] == p.first && loc_y[j] == p.second) occ[i][j] = true;\n\t\t\t}\n\t\t}\n\t}\n\n\ti128 ans = 0;\n\tvector<int> dx = {1, 0, -1, 0};\n\tvector<int> dy = {0, 1, 0, -1};\n\tfor(int x = 0; x < num_x; x++){\n\t\tfor(int y = 0; y < num_y; y++){\n\t\t\tif(occ[x][y]) continue;\n\t\t\tvector<vector<bool> > vis(num_x, vector<bool>(num_y, false));\n\t\t\tvector<vector<int> > dist(num_x, vector<int>(num_y, 1e9));\n\t\t\tpriority_queue<pair<int, pair<int,int> > > s;\n\t\t\tdist[x][y] = 0;\n\t\t\ts.push({-dist[x][y], {x, y}});\n\t\t\twhile(!s.empty()){\n\t\t\t\tint cx = s.top().second.first;\n\t\t\t\tint cy = s.top().second.second;\n\t\t\t\ts.pop();\n\t\t\t\tif(vis[cx][cy]) continue;\n\t\t\t\tvis[cx][cy] = true;\n\t\t\t\tfor(int d = 0; d < 4; d++){\n\t\t\t\t\tint nx = cx + dx[d];\n\t\t\t\t\tint ny = cy + dy[d];\n\t\t\t\t\tif(nx < 0 || ny < 0 || nx >= num_x || ny >= num_y) continue;\n\t\t\t\t\tif(occ[nx][ny]) continue;\n\t\t\t\t\tint new_dist = dist[cx][cy] + abs(loc_x[cx] - loc_x[nx]) + abs(loc_y[cy] - loc_y[ny]);\n\t\t\t\t\tif(new_dist < dist[nx][ny]){\n\t\t\t\t\t\tdist[nx][ny] = new_dist;\n\t\t\t\t\t\ts.push({-dist[nx][ny], {nx, ny}});\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t}\n\t\t\tfor(int nx = 0; nx < num_x; nx++){\n\t\t\t\tfor(int ny = 0; ny < num_y; ny++){\n\t\t\t\t\tif(occ[nx][ny]) continue;\n\t\t\t\t\ti128 dx0 = loc_x[x + 1] - loc_x[x];\n\t\t\t\t\ti128 dy0 = loc_y[y + 1] - loc_y[y];\n\t\t\t\t\ti128 dx1 = loc_x[nx + 1] - loc_x[nx];\n\t\t\t\t\ti128 dy1 = loc_y[ny + 1] - loc_y[ny];\n\t\t\t\t\ti128 cnt0 = dx0 * dy0;\n\t\t\t\t\ti128 cnt1 = dx1 * dy1;\n\t\t\t\t\tif(cnt0 > 1 && cnt1 > 1){\n\t\t\t\t\t\t// can travel by manhattan distance\n\t\t\t\t\t\ti128 xdist = (x == nx) ? ((dx0 * dx0 * dx0 - dx0) / 3) : \n\t\t\t\t\t\t\tdx0 * dx1 * abs(loc_x[nx + 1] + loc_x[nx] - loc_x[x + 1] - loc_x[x]) / 2;\n\t\t\t\t\t\txdist *= dy0 * dy1;\n\t\t\t\t\t\ti128 ydist = (y == ny) ? ((dy0 * dy0 * dy0 - dy0) / 3) : \n\t\t\t\t\t\t\tdy0 * dy1 * abs(loc_y[ny + 1] + loc_y[ny] - loc_y[y + 1] - loc_y[y]) / 2;\n\t\t\t\t\t\tydist *= dx0 * dx1;\n\t\t\t\t\t\tans += xdist + ydist;\n\t\t\t\t\t} else {\n\t\t\t\t\t\ti128 twice_avg = 2 * i128(dist[nx][ny])\n\t\t\t\t\t\t\t+ abs(loc_x[nx + 1] + loc_x[nx] - loc_x[x + 1] - loc_x[x]) - 2 * abs(loc_x[nx] - loc_x[x])\n\t\t\t\t\t\t\t+ abs(loc_y[ny + 1] + loc_y[ny] - loc_y[y + 1] - loc_y[y]) - 2 * abs(loc_y[ny] - loc_y[y]);\n\t\t\t\t\t\tans += twice_avg * cnt0 * cnt1 / 2;\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t}\n\tll ans_mod = (ans / 2) % (int(1e9) + 7);\n\tcout << ans_mod << '\\n';\n}"
  },
  {
    "language": "C++",
    "code": "#include<stdio.h>\n#include<vector>\n#include<algorithm>\n#include<queue>\n#include<math.h>\n#include<stdlib.h>\nusing namespace std;\ntypedef long long ll;\nll mod = 1000000007;\ntypedef pair<ll, ll>pii;\ntypedef pair<ll, pii>pi3;\nvector<pii>zat(vector<ll>v, ll gen)\n{\n\tsort(v.begin(), v.end());\n\tvector<ll>zv;\n\tll now = -1;\n\tfor (int i = 0; i < v.size(); i++)\n\t{\n\t\tif (now != v[i])now = v[i], zv.push_back(now);\n\t}\n\tv = zv;\n\tvector<pii>ret;\n\tint beg = 0;\n\tfor (int i = 0; i < v.size(); i++)\n\t{\n\t\tif (beg < v[i])ret.push_back(make_pair(beg, v[i] - 1));\n\t\tret.push_back(make_pair(v[i], v[i]));\n\t\tbeg = v[i] + 1;\n\t}\n\tif (beg != gen)ret.push_back(make_pair(beg, gen - 1));\n\treturn ret;\n}\nll dat[100][100];\nll dist[70][70][70][70];\nbool flag[70][70];\nint dx[4] = { 1,0,-1,0 };\nint dy[4] = { 0,1,0,-1 };\nvoid calcdist(int sx, int sy, int mx, int my)\n{\n\tqueue<pi3>que;\n\tque.push(make_pair(0, make_pair(sx, sy)));\n\tfor (int i = 0; i < mx; i++)for (int j = 0; j < my; j++)flag[i][j] = false;\n\tfor (;;)\n\t{\n\t\tif (que.empty())break;\n\t\tpi3 z = que.front();\n\t\tque.pop();\n\t\tll x = z.second.first, y = z.second.second;\n\t\tif (flag[x][y])continue;\n\t\tflag[x][y] = true;\n\t\tdist[sx][sy][x][y] = z.first;\n\t\tfor (int i = 0; i < 4; i++)\n\t\t{\n\t\t\tint nx = x + dx[i], ny = y + dy[i];\n\t\t\tif (0 <= nx&&nx < mx && 0 <= ny&&ny < my&&dat[nx][ny] == 0)\n\t\t\t{\n\t\t\t\tque.push(make_pair(z.first + 1, make_pair(nx, ny)));\n\t\t\t}\n\t\t}\n\t}\n}\nll getall(ll x, ll y)\n{\n\treturn (y*y%mod*((x + 1)*x*(x - 1) / 6 % mod) + x*x%mod*((y + 1)*y*(y - 1) / 6 % mod)) % mod;\n}\nll get1d(ll mx, ll x)\n{\n\tll a = x*(x + 1) / 2;\n\tll b = (mx - x - 1)*(mx - x) / 2;\n\treturn (a + b) % mod;\n}\nll get(ll mx, ll my, ll x, ll y)\n{\n\treturn (get1d(mx, x)*my + get1d(my, y)*mx) % mod;\n}\nint main()\n{\n\tll mx, my;\n\tint num;\n\tscanf(\"%lld%lld%d\", &mx, &my, &num);\n\tvector<ll>zx, zy;\n\tvector<pii>v;\n\tfor (int i = 0; i < num; i++)\n\t{\n\t\tint za, zb;\n\t\tscanf(\"%d%d\", &za, &zb);\n\t\tv.push_back(make_pair(za, zb));\n\t\tzx.push_back(za);\n\t\tzy.push_back(zb);\n\t}\n\tvector<pii>xs = zat(zx, mx), ys = zat(zy, my);\n\t//for (int i = 0; i < xs.size(); i++)printf(\"%lld %lld\\n\", xs[i].first, xs[i].second);\n\t//for (int i = 0; i < ys.size(); i++)printf(\"%lld %lld\\n\", ys[i].first, ys[i].second);\n\tfor (int i = 0; i < num; i++)\n\t{\n\t\tint lx = lower_bound(xs.begin(), xs.end(), make_pair(v[i].first, v[i].first)) - xs.begin();\n\t\tint ly = lower_bound(ys.begin(), ys.end(), make_pair(v[i].second, v[i].second)) - ys.begin();\n\t\tdat[lx][ly] = 1;\n\t}\n\tfor (int i = 0; i < xs.size(); i++)for (int j = 0; j < ys.size(); j++)if (dat[i][j] == 0)calcdist(i, j, xs.size(), ys.size());\n\tll ans = getall(mx, my);\n\tfor (int i = 0; i < v.size(); i++)ans = (ans + mod - get(mx, my, v[i].first, v[i].second)) % mod;\n\tfor (int i = 0; i < v.size(); i++)for (int j = i + 1; j < v.size(); j++)ans = (ans + abs(v[i].first - v[j].first) + abs(v[i].second - v[j].second)) % mod;\n\tll add = 0;\n\tfor (int i = 0; i < xs.size(); i++)\n\t{\n\t\tfor (int j = 0; j < ys.size(); j++)\n\t\t{\n\t\t\tfor (int k = 0; k < xs.size(); k++)\n\t\t\t{\n\t\t\t\tfor (int l = 0; l < ys.size(); l++)\n\t\t\t\t{\n\t\t\t\t\tif (dat[i][j] == 1 || dat[k][l] == 1)continue;\n\t\t\t\t\tll t = (xs[i].second - xs[i].first + 1)*(ys[j].second - ys[j].first + 1) % mod;\n\t\t\t\t\tll s = (xs[k].second - xs[k].first + 1)*(ys[l].second - ys[l].first + 1) % mod;\n\t\t\t\t\tll u = dist[i][j][k][l] - abs(k - i) - abs(l - j);\n\t\t\t\t\tadd += t*s%mod*u;\n\t\t\t\t\tadd %= mod;\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t}\n\tadd = add*(mod + 1) / 2 % mod;\n\tprintf(\"%lld\\n\", (ans + add) % mod);\n}"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\n// iostream is too mainstream\n#include <cstdio>\n// bitch please\n#include <iostream>\n#include <algorithm>\n#include <cstdlib>\n#include <vector>\n#include <set>\n#include <map>\n#include <queue>\n#include <stack>\n#include <list>\n#include <cmath>\n#include <iomanip>\n#include <time.h>\n#include <unistd.h>\n#define dibs reserve\n#define OVER9000 1034567890\n#define ALL_THE(CAKE,LIE) for(auto LIE =CAKE.begin(); LIE != CAKE.end(); LIE++)\n#define tisic 47\n#define soclose 1e-8\n#define chocolate win\n// so much chocolate\n#define patkan 9\n#define ff first\n#define ss second\n#define abs(x) ((x < 0)?-(x):x)\n#define uint unsigned int\n#define dbl long double\n#define pi 3.14159265358979323846\nusing namespace std;\n// mylittledoge\n\ntypedef long long cat;\n\n#ifdef DONLINE_JUDGE\n\t// palindromic tree is better than splay tree!\n\t#define lld I64d\n#endif\n\ncat encode(int a, int b, int c) {\n\treturn ((1LL*a)<<40)+((1LL*b)<<20)+c;\n}\n\nint main() {\n\tcin.sync_with_stdio(0);\n\tcin.tie(0);\n\tcout << fixed << setprecision(10);\n\tint H, W, N;\n\tcin >> H >> W >> N;\n\tvector< pair<int, int> > bl(N);\n\tmap<int, int> Mx, My;\n\tMx[0] =Mx[H] =0;\n\tMy[0] =My[W] =0;\n\tfor(int i =0; i < N; i++) {\n\t\tcin >> bl[i].ff >> bl[i].ss;\n\t\tMx[bl[i].ff] =Mx[bl[i].ff+1] =0;\n\t\tMy[bl[i].ss] =My[bl[i].ss+1] =0;\n\t}\n\tint mx =0, my =0;\n\tvector< pair<int,int> > Ix, Iy;\n\tint last =-1;\n\tALL_THE(Mx, it) {\n\t\tit->ss =mx++;\n\t\tif(last >= 0) Ix.push_back(make_pair(last, it->ff));\n\t\tlast =it->ff;\n\t}\n\tlast =-1;\n\tALL_THE(My, it) {\n\t\tit->ss =my++;\n\t\tif(last >= 0) Iy.push_back(make_pair(last, it->ff));\n\t\tlast =it->ff;\n\t}\n\tvector< vector<bool> > BL(mx, vector<bool>(my, 0));\n\tfor(int i =0; i < N; i++) BL[Mx[bl[i].ff]][My[bl[i].ss]] =1;\n\tmx--, my--;\n\n\tcat mod =1000000007;\n\t// sum of Manhattan distances\n\tcat ans =((1LL*(H-1)*H*(H+1)/6)%mod*W%mod*W+(1LL*(W-1)*W*(W+1)/6)%mod*H%mod*H)%mod;\n\tfor(int i =0; i < N; i++) {\n\t\tcat sum =0;\n\t\tsum =(sum+(1LL*bl[i].ff*(bl[i].ff+1)/2+1LL*(H-1-bl[i].ff)*(H-bl[i].ff)/2)%mod*W)%mod;\n\t\tsum =(sum+(1LL*bl[i].ss*(bl[i].ss+1)/2+1LL*(W-1-bl[i].ss)*(W-bl[i].ss)/2)%mod*H)%mod;\n\t\tfor(int j =0; j < N; j++)\n\t\t\tsum -=abs(bl[j].ff-bl[i].ff)+abs(bl[j].ss-bl[i].ss);\n\t\tans =(ans-sum)%mod;\n\t}\n\tfor(int i =0; i < N; i++) for(int j =0; j < i; j++)\n\t\tans -=abs(bl[j].ff-bl[i].ff)+abs(bl[j].ss-bl[i].ss);\n\n\tvector< vector< vector<int> > > Dx(mx, vector< vector<int> >(my, vector<int>(my, OVER9000)));\n\tvector< vector< vector<int> > > Dy(my, vector< vector<int> >(mx, vector<int>(mx, OVER9000)));\n\tpriority_queue< pair<int, cat>, vector< pair<int, cat> >, greater< pair<int, cat> > > qx, qy;\n\tfor(int i =0; i < mx; i++) for(int j =0; j < my; j++) if(!BL[i][j]) {\n\t\tDx[i][j][j] =Dy[j][i][i] =0;\n\t\tqx.push(make_pair(0, encode(i, j, j)));\n\t\tqy.push(make_pair(0, encode(j, i, i)));\n\t}\n\n\twhile(!qx.empty()) {\n\t\tpair<int, cat> p =qx.top();\n\t\tqx.pop();\n\t\tint x =p.ss>>40, y1 =(p.ss>>20)&((1LL<<20)-1), y2 =p.ss&((1LL<<20)-1);\n\t\tif(Dx[x][y1][y2] != p.ff) continue;\n\t\t// +1, in row-direction\n\t\tif(y1 > 0 && !BL[x][y1-1] && Dx[x][y1-1][y2] > Dx[x][y1][y2]) {\n\t\t\tDx[x][y1-1][y2] =Dx[x][y1][y2];\n\t\t\tqx.push(make_pair(Dx[x][y1-1][y2], encode(x, y1-1, y2)));\n\t\t}\n\t\tif(y2+1 < my && !BL[x][y2+1] && Dx[x][y1][y2+1] > Dx[x][y1][y2]) {\n\t\t\tDx[x][y1][y2+1] =Dx[x][y1][y2];\n\t\t\tqx.push(make_pair(Dx[x][y1][y2+1], encode(x, y1, y2+1)));\n\t\t}\n\t\t// -1 in the row-direction\n\t\tif(y1 < y2 && !BL[x][y1+1] && Dx[x][y1+1][y2] > Dx[x][y1][y2]+1) {\n\t\t\tDx[x][y1+1][y2] =Dx[x][y1][y2]+1;\n\t\t\tqx.push(make_pair(Dx[x][y1+1][y2], encode(x, y1+1, y2)));\n\t\t}\n\t\tif(y1 < y2 && !BL[x][y2-1] && Dx[x][y1][y2-1] > Dx[x][y1][y2]+1) {\n\t\t\tDx[x][y1][y2-1] =Dx[x][y1][y2]+1;\n\t\t\tqx.push(make_pair(Dx[x][y1][y2-1], encode(x, y1, y2-1)));\n\t\t}\n\t\t// +1,+1 in the same col-direction\n\t\tif(x > 0 && !BL[x-1][y1] && !BL[x-1][y2] && Dx[x-1][y1][y2] > Dx[x][y1][y2]+1) {\n\t\t\tDx[x-1][y1][y2] =Dx[x][y1][y2]+1;\n\t\t\tqx.push(make_pair(Dx[x-1][y1][y2], encode(x-1, y1, y2)));\n\t\t}\n\t\tif(x+1 < mx && !BL[x+1][y1] && !BL[x+1][y2] && Dx[x+1][y1][y2] > Dx[x][y1][y2]+1) {\n\t\t\tDx[x+1][y1][y2] =Dx[x][y1][y2]+1;\n\t\t\tqx.push(make_pair(Dx[x+1][y1][y2], encode(x+1, y1, y2)));\n\t\t}\n\t}\n\twhile(!qy.empty()) {\n\t\tpair<int, cat> p =qy.top();\n\t\tqy.pop();\n\t\tint y =p.ss>>40, x1 =(p.ss>>20)&((1LL<<20)-1), x2 =p.ss&((1LL<<20)-1);\n\t\tif(Dy[y][x1][x2] != p.ff) continue;\n\t\t// +1, in row-direction\n\t\tif(x1 > 0 && !BL[x1-1][y] && Dy[y][x1-1][x2] > Dy[y][x1][x2]) {\n\t\t\tDy[y][x1-1][x2] =Dy[y][x1][x2];\n\t\t\tqy.push(make_pair(Dy[y][x1-1][x2], encode(y, x1-1, x2)));\n\t\t}\n\t\tif(x2+1 < mx && !BL[x2+1][y] && Dy[y][x1][x2+1] > Dy[y][x1][x2]) {\n\t\t\tDy[y][x1][x2+1] =Dy[y][x1][x2];\n\t\t\tqy.push(make_pair(Dy[y][x1][x2+1], encode(y, x1, x2+1)));\n\t\t}\n\t\t// -1 in the row-direction\n\t\tif(x1 < x2 && !BL[x1+1][y] && Dy[y][x1+1][x2] > Dy[y][x1][x2]+1) {\n\t\t\tDy[y][x1+1][x2] =Dy[y][x1][x2]+1;\n\t\t\tqy.push(make_pair(Dy[y][x1+1][x2], encode(y, x1+1, x2)));\n\t\t}\n\t\tif(x1 < x2 && !BL[x2-1][y] && Dy[y][x1][x2-1] > Dy[y][x1][x2]+1) {\n\t\t\tDy[y][x1][x2-1] =Dy[y][x1][x2]+1;\n\t\t\tqy.push(make_pair(Dy[y][x1][x2-1], encode(y, x1, x2-1)));\n\t\t}\n\t\t// +1,+1 in the same col-direction\n\t\tif(y > 0 && !BL[x1][y-1] && !BL[x2][y-1] && Dy[y-1][x1][x2] > Dy[y][x1][x2]+1) {\n\t\t\tDy[y-1][x1][x2] =Dy[y][x1][x2]+1;\n\t\t\tqy.push(make_pair(Dy[y-1][x1][x2], encode(y-1, x1, x2)));\n\t\t}\n\t\tif(y+1 < my && !BL[x1][y+1] && !BL[x2][y+1] && Dy[y+1][x1][x2] > Dy[y][x1][x2]+1) {\n\t\t\tDy[y+1][x1][x2] =Dy[y][x1][x2]+1;\n\t\t\tqy.push(make_pair(Dy[y+1][x1][x2], encode(y+1, x1, x2)));\n\t\t}\n\t}\n\n\tfor(int x =0; x < mx; x++)\n\t\tfor(int y1 =0; y1 < my; y1++) for(int y2 =0; y2 < y1; y2++)\n\t\t\tDx[x][y1][y2] =Dx[x][y2][y1];\n\tfor(int y =0; y < my; y++)\n\t\tfor(int x1 =0; x1 < mx; x1++) for(int x2 =0; x2 < x1; x2++)\n\t\t\tDy[y][x1][x2] =Dy[y][x2][x1];\n\n\tvector< vector<int> > D(mx*my, vector<int>(mx*my, OVER9000));\n\tfor(int i =0; i < mx; i++) for(int j =0; j < my; j++) if(!BL[i][j]) {\n\t\tD[i*my+j][i*my+j] =0;\n\t\tfor(int k =0; k < mx; k++) if(!BL[k][j])\n\t\t\tD[i*my+j][k*my+j] =D[k*my+j][i*my+j] =2*Dy[j][i][k]+abs(i-k);\n\t\tfor(int k =0; k < my; k++) if(!BL[i][k])\n\t\t\tD[i*my+j][i*my+k] =D[i*my+k][i*my+j] =2*Dx[i][j][k]+abs(j-k);\n\t}\n\treturn 0;\n\n\t// Dijkstra from everywhere\n\tpriority_queue< pair<int, int>, vector< pair<int, int> >, greater< pair<int, int> > > q;\n\tvector<bool> vis(mx*my);\n\tfor(int i =0; i < mx*my; i++) if(!BL[i/my][i%my]) {\n\t\tfor(int j =0; j < mx*my; j++) vis[j] =0;\n\t\tvis[i] =1;\n\t\tq.push(make_pair(0, i));\n\t\twhile(!q.empty()) {\n\t\t\tpair<int, int> p =q.top();\n\t\t\tq.pop();\n\t\t\tif(D[i][p.ss] != p.ff) continue;\n\t\t\tfor(int x =0; x < mx; x++) if(D[i][x*my+(p.ss%my)] > p.ff+D[p.ss][x*my+(p.ss%my)] || !vis[x*my+(p.ss%my)]) {\n\t\t\t\tvis[x*my+(p.ss%my)] =1;\n\t\t\t\tD[i][x*my+(p.ss%my)] =D[x*my+(p.ss%my)][i] =min(D[i][x*my+(p.ss%my)], p.ff+D[p.ss][x*my+(p.ss%my)]);\n\t\t\t\tq.push(make_pair(D[i][x*my+(p.ss%my)], x*my+(p.ss%my)));\n\t\t\t}\n\t\t\tfor(int y =0; y < my; y++) if(D[i][(p.ss/my)*my+y] > p.ff+D[p.ss][(p.ss/my)*my+y] || !vis[(p.ss/my)*my+y]) {\n\t\t\t\tvis[(p.ss/my)*my+y] =1;\n\t\t\t\tD[i][(p.ss/my)*my+y] =D[(p.ss/my)*my+y][i] =min(D[i][(p.ss/my)*my+y], p.ff+D[p.ss][(p.ss/my)*my+y]);\n\t\t\t\tq.push(make_pair(D[i][(p.ss/my)*my+y], (p.ss/my)*my+y));\n\t\t\t}\n\t\t}\n//\t\tfor(int j =0; j < mx*my; j++) for(int k =0; k < mx*my; k++)\n//\t\t\tif(D[j][k] > D[j][i]+D[i][k]) D[j][k] =D[j][i]+D[i][k];\n\t}\n\n\tfor(int x1 =0; x1 < mx; x1++) for(int y1 =0; y1 < my; y1++)\n\t\tfor(int x2 =0; x2 <= x1; x2++) for(int y2 =0; y2 < my; y2++) {\n\t\t\tif(x2 == x1 && y2 >= y1) continue;\n\t\t\tif(D[x1*my+y1][x2*my+y2] == OVER9000) continue;\n\t\t\tcat cnt1 =1LL*(Ix[x1].ss-Ix[x1].ff)*(Iy[y1].ss-Iy[y1].ff)%mod;\n\t\t\tcat cnt2 =1LL*(Ix[x2].ss-Ix[x2].ff)*(Iy[y2].ss-Iy[y2].ff)%mod;\n\t\t\tans =(ans+(cnt1*cnt2)%mod*(D[x1*my+y1][x2*my+y2]-abs(x1-x2)-abs(y1-y2)))%mod;\n\t\t}\n\n\tans %=mod;\n\tif(ans < 0) ans +=mod;\n\tcout << ans << \"\\n\";\n\treturn 0;}\n\n// look at my code\n// my code is amazing\n"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\n\nusing namespace std;\n\n#ifdef DEBUG_MODE\n\t#define DBG(n) n;\n#else\n\t#define DBG(n) ;\n#endif\n#define REP(i,n) for(ll (i) = (0);(i) < (n);++i)\n#define PB push_back\n#define MP make_pair\n#define FI first\n#define SE second\n#define SHOW1d(v,n) {for(int W = 0;W < (n);W++)cerr << v[W] << ' ';cerr << endl << endl;}\n#define SHOW2d(v,i,j) {for(int aaa = 0;aaa < i;aaa++){for(int bbb = 0;bbb < j;bbb++)cerr << v[aaa][bbb] << ' ';cerr << endl;}cerr << endl;}\n#define ALL(v) v.begin(),v.end()\n#define Decimal fixed<<setprecision(20)\n#define INF 1000000000\n#define LLINF 1000000000000000000\n#define MOD 1000000007\n\ntypedef long long ll;\ntypedef pair<ll,ll> P;\n\nlong long mod_div(long long a,long long b){\n\tif(a % b == 0)return a/b;\n\tlong long tmp = MOD - 2,c = b,ret = 1;\n\twhile(tmp > 0){\n\t\tif(tmp & 1){\n\t\t\tret *= c;ret %= MOD;\n\t\t}\n\t\tc *= c;c %= MOD;tmp >>= 1;\n\t}\n\treturn a*ret%MOD;\n}\n\nint n,h,w;\nll ans,distSum;\nvector<pair<ll,ll>> v;\nvector<ll> xx;\nvector<ll> yy;\n\nbool mp[111][111];\nbool used[111][111];\nll dx[] = {1,0,-1,0};\nll dy[] = {0,1,0,-1};\nll couX[111];\nll couY[111];\n\nvoid seicaAdd(ll &a,ll &b){\n\ta += b;\n\tif(a >= MOD)a -= MOD;\n}\n\nvoid makeTable(){\n\tyy.PB(0);\n\tyy.PB(h);\n\txx.PB(0);\n\txx.PB(w);\n\t\n\tREP(i,n){\n\t\txx.PB(max(0LL,v[i].FI-1));\n\t\txx.PB(max(0LL,v[i].FI));\n\t\txx.PB(max(0LL,v[i].FI+1));\n\t\tyy.PB(max(0LL,v[i].SE-1));\n\t\tyy.PB(max(0LL,v[i].SE));\n\t\tyy.PB(max(0LL,v[i].SE+1));\n\t}\n\t\n\tsort(ALL(xx));\n\tsort(ALL(yy));\n\t\n\txx.erase(unique(ALL(xx)),xx.end());\n\tyy.erase(unique(ALL(yy)),yy.end());\n\t\n\tREP(i,n){\n\t\tint x = lower_bound(ALL(xx),v[i].FI) - xx.begin();\n\t\tint y = lower_bound(ALL(yy),v[i].SE) - yy.begin();\n\t\tmp[y][x] = true;\n\t\tcouX[x]++;\n\t\tcouY[y]++;\n\t}\t\n\t\n\t/*\n\tSHOW1d(xx,xx.size());\n\tSHOW1d(yy,yy.size());\n\tSHOW1d(couX,xx.size());\n\tSHOW1d(couY,yy.size());\n\tSHOW2d(mp,yy.size(),xx.size());\n\t*/\n\t\n\tll blackSum = 0;\n\tll pointer = 0;\n\tREP(i,w){\n\t\t//cout << i << endl;\n\t\tif(i == xx[pointer]){\n\t\t\tblackSum += couX[pointer];\n\t\t\tpointer++;\n\t\t}\n\t\telse{\n\t\t\tll A = ((h * i % MOD) - blackSum + MOD) % MOD;\n\t\t\tll B = ((h * (w - i) % MOD) - (n - blackSum) + MOD) % MOD;\n\t\t\tll tmp = A * B % MOD;\n\t\t//\tcout << \"A B tmp is \"  << A << \" \" << B << \" \" << tmp << endl;\n\t\t\tseicaAdd(ans,tmp);\n\t\t}\n\t}\n\t\n\tblackSum = 0;\n\tpointer = 0;\n\tREP(i,h){\n\t\t//cout << i << endl;\n\t\tif(i == yy[pointer]){\n\t\t\tblackSum += couY[pointer];\n\t\t\tpointer++;\n\t\t}\n\t\telse{\n\t\t\tll A = ((w * i % MOD) - blackSum + MOD) % MOD;\n\t\t\tll B = ((w * (h - i\t) % MOD) - (n - blackSum) + MOD) % MOD;\n\t\t\tll tmp = A * B % MOD;\n\t\t\t//cout << \"A B tmp is \"  << A << \" \" << B << \" \" << tmp << endl;\n\t\t\tseicaAdd(ans,tmp);\n\t\t}\n\t}\n}\n\nvoid tmpMakeTable(){\n\tREP(i,h+1)yy.PB(i);\n\tREP(i,w+1)xx.PB(i);\n\tREP(i,n){\n\t\tmp[v[i].SE][v[i].FI] = true;\n\t}\n\tSHOW1d(xx,xx.size());\n\tSHOW1d(yy,yy.size());\n\tSHOW2d(mp,yy.size(),xx.size());\t\n}\n\nint main(){\n\t\n\tcin >> h >> w >> n;\n\tREP(i,n){\n\t\tint a,b;cin >> a >> b;\n\t\tv.PB(MP(b,a));\n\t}\n\t\n\tmakeTable();\n\t//tmpMakeTable();\n\t\n\tREP(i,yy.size()-1){\n\t\tREP(j,xx.size()-1){\n\t\t\tif(!mp[i][j]){\n\t\t\t\tREP(ii,111)REP(jj,111)used[ii][jj] = false;\n\t\t\t\tll nowMul = ((yy[i+1] - yy[i]) * (xx[j+1] - xx[j])) % MOD;\n\t\t\t\tqueue<pair<pair<ll,ll>,ll>> que;\n\t\t\t\tque.push(MP(MP(i,j),0));\n\t\t\t\tused[i][j] = true;\n\t\t\t\twhile(!que.empty()){\n\t\t\t\t\tauto now = que.front();que.pop();\n\t\t\t\t\tnow.SE++;\n\t\t\t\t\tREP(k,4){\n\t\t\t\t\t\tll y = now.FI.FI + dy[k];\n\t\t\t\t\t\tll x = now.FI.SE + dx[k];\n\t\t\t\t\t\tif(x < 0 || y < 0 || x >= xx.size() - 1 || y >= yy.size() - 1)continue;\n\t\t\t\t\t\tif(mp[y][x] || used[y][x])continue;\n\t\t\t\t\t\tll thisMul = (yy[y+1] - yy[y]) * (xx[x+1] - xx[x]) % MOD;\n\t\t\t\t\t\tll tmp = (((nowMul * thisMul) % MOD) * now.SE) % MOD;\n\t\t\t\t\t\tseicaAdd(distSum,tmp);\t\n\t\t\t\t\t\tque.push(MP(MP(y,x),now.SE));\n\t\t\t\t\t\tused[y][x] = true;\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t}\n\tdistSum = mod_div(distSum,2);\n\t//cout << distSum << endl;\n\t//cout << ans << endl;\n\tcout << (ans + distSum) % MOD << endl;\n\t\n\treturn 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include <iostream>\n#include <vector>\n#include <map>\n#include <queue>\n#include <algorithm>\n#include <cstring>\nusing namespace std;\n\n#define REP(i, s) for (int i = 0; i < s; ++i)\n#define ALL(v) (v.begin(), v.end())\n#define COUT(x) cout << #x << \" = \" << (x) << \" (L\" << __LINE__ << \")\" << endl\n#define EACH(i, s) for (__typeof__((s).begin()) i = (s).begin(); i != (s).end(); ++i)\n\ntemplate<class T> inline bool chmax(T& a, T b) { if (a < b) { a = b; return 1; } return 0; }\ntemplate<class T> inline bool chmin(T& a, T b) { if (a > b) { a = b; return 1; } return 0; }\ntemplate<class T1, class T2> ostream& operator << (ostream &s, pair<T1, T2> P)\n{\n\treturn s << '<' << P.first << \", \" << P.second << '>';\n}\ntemplate<class T> ostream& operator << (ostream &s, vector<T> P)\n{\n\tfor (int i = 0; i < P.size(); ++i) { if (i > 0) { s << \" \"; } s << P[i]; } return s;\n}\ntemplate<class T> ostream& operator << (ostream &s, vector<vector<T> > P)\n{\n\tfor (int i = 0; i < P.size(); ++i) { s << endl << P[i]; } return s << endl;\n}\n\nconst int MOD = 1000000007;\ninline long long mod(long long a, long long m) { return (a % m + m) % m; }\nstruct Fp {\n\tint MOD = 1000000007;\n\tlong long val;\n\n\tFp() : val(0) {}\n\tFp(long long val_) { this->val = mod(val_, MOD); }\n\tFp operator = (long long val_) { this->val = mod(val_, MOD); return *this; }\n\tinline Fp operator - () { return mod(-val, MOD); }\n\tinline const Fp& operator += (const Fp &x);\n\tinline const Fp& operator -= (const Fp &x);\n\tinline const Fp& operator *= (const Fp &x);\n\tinline const Fp& operator /= (const Fp &x);\n};\n\ninline bool operator == (Fp x, Fp y) { return x.val == y.val; }\ninline bool operator != (Fp x, Fp y) { return !(x == y); }\n\nostream &operator << (ostream &os, Fp x) { return os << x.val; }\nistream &operator >> (istream &is, Fp &x) { is >> x; return is; }\n\ninline Fp operator + (Fp x, Fp y) { return mod(x.val + y.val, x.MOD); }\ninline Fp operator - (Fp x, Fp y) { return mod(x.val - y.val, x.MOD); }\ninline Fp operator * (Fp x, Fp y) { return mod(x.val * y.val, x.MOD); }\ninline Fp operator / (Fp x, Fp y) {\n\tlong long a = y.val, b = x.MOD, u = 1, v = 0;\n\twhile (b) {\n\t\tlong long t = a / b;\n\t\ta -= t*b; swap(a, b);\n\t\tu -= t*v; swap(u, v);\n\t}\n\treturn x * u;\n}\ninline Fp abs(Fp a) { return a; }\ninline Fp fpow(Fp a, long long n) {\n\tif (n == 0) return Fp(1);\n\tFp t = fpow(a, n / 2);\n\tt = t * t; if (n & 1) t = t * a;\n\treturn t;\n}\ninline const Fp& Fp::operator += (const Fp &x) { *this = *this + x; return *this; }\ninline const Fp& Fp::operator -= (const Fp &x) { *this = *this - x; return *this; }\ninline const Fp& Fp::operator *= (const Fp &x) { *this = *this * x; return *this; }\ninline const Fp& Fp::operator /= (const Fp &x) { *this = *this / x; return *this; }\n\n// calc comb (small n, r ver)\nconst int FACT_MAX = 210000;\nstatic Fp fp_fact_val[FACT_MAX];\n\nvoid calcFact(int MAX = FACT_MAX) {\n\tfp_fact_val[0] = 1;\n\tfor (int val = 1; val < MAX; ++val) {\n\t\tfp_fact_val[val] = fp_fact_val[val - 1] * val;\n\t}\n}\n\nFp fact(int n) {\n\treturn fp_fact_val[n];\n}\n\nFp com(int n, int r) {\n\treturn fact(n) / fact(r) / fact(n - r);\n}\n\nint dx[4] = {1, 0, -1, 0};\nint dy[4] = {0, 1, 0, -1};\n\nlong long H, W, N;\nlong long bx[210], by[210];\nvector<long long> altx, alty;\nlong long nH, nW;\n\nlong long xnum[1100000], ynum[1100000];\n\nbool cb[210][210];\nlong long dist[110][110];\n\ntypedef pair<int, int> pint;\n\nlong long subsolve() {\n\t//COUT(nH); COUT(nW); COUT(altx); COUT(alty);\n\n\tfor (int x = 0; x < nH - 1; ++x) {\n\t\tfor (int y = 0; y < nW - 1; ++y) {\n\t\t\t//cout << cb[x][y];\n\t\t}\n\t\t//cout << endl;\n\t}\n\n  long long res = 0;\n\tfor (int x = 0; x < nH - 1; ++x) {\n\t\tfor (int y = 0; y < nW - 1; ++y) {\n\t\t\tif (cb[x][y]) continue;\n\t\t\tmemset(dist, -1, sizeof(dist));\n\t\t\tqueue<pint> que;\n\t\t\tque.push(pint(x, y));\n\t\t\tdist[x][y] = 0;\n\t\t\twhile (!que.empty()) {\n\t\t\t\tpint cur = que.front();\n\t\t\t\tque.pop();\n\t\t\t\tfor (int dir = 0; dir < 4; ++dir) {\n\t\t\t\t\tint nx = cur.first + dx[dir];\n\t\t\t\t\tint ny = cur.second + dy[dir];\n\t\t\t\t\tif (nx < 0 || nx >= H || ny < 0 || ny >= W) continue;\n\t\t\t\t\tif (cb[nx][ny]) continue;\n\t\t\t\t\tif (dist[nx][ny] == -1) {\n\t\t\t\t\t\tdist[nx][ny] = dist[cur.first][cur.second] + 1;\n\t\t\t\t\t\tque.push(pint(nx, ny));\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t}\n\t\t\t\n\t\t\tfor (int nx = 0; nx < nH - 1; ++nx) {\n\t\t\t\tfor (int ny = 0; ny < nW - 1; ++ny) {\n\t\t\t\t\tif (nW * nx + ny <= nW * x + y) continue;\n\t\t\t\t\tif (dist[nx][ny] == -1) continue;\n\t\t\t\t\tif (cb[nx][ny]) continue;\n\n\t\t\t\t\tlong long ss = ((long long)(altx[x + 1] - altx[x]) * (alty[y + 1] - alty[y])) % MOD;\n\t\t\t\t\tlong long st = ((long long)(altx[nx + 1] - altx[nx]) * (alty[ny + 1] - alty[ny])) % MOD;\n\t\t\t\t\tres += ((long long)(dist[nx][ny]) * ss % MOD) * st % MOD;\n\t\t\t\t\tres %= MOD;\n\t\t\t\t\t\n\t\t\t\t\t//cout << pint(x, y) << \", \" << pint(nx, ny) << \": \" << dist[nx][ny] << \", \" << ss << \", \" << st << endl;\n\t\t\t\t}\n\t\t\t}\n\t\t\t\n\t\t}\n\t}\n\t//COUT(res);\n\n\treturn res;\n}\n\nFp solve() {\n  memset(xnum, 0, sizeof(xnum));\n  memset(ynum, 0, sizeof(ynum));\n\taltx.clear();\n\talty.clear();\n  altx.push_back(0);\n  altx.push_back(H);\n  alty.push_back(0);\n  alty.push_back(W);\n  for (int i = 0; i < N; ++i) {\n\t\taltx.push_back(bx[i]);\n\t\taltx.push_back(bx[i] + 1);\n\t\talty.push_back(by[i]);\n\t\talty.push_back(by[i] + 1);\n\t\txnum[bx[i]]++;\n\t\tynum[by[i]]++;\n  }\n  sort(altx.begin(), altx.end());\n  sort(alty.begin(), alty.end());\n  altx.erase(unique(altx.begin(), altx.end()), altx.end());\n  alty.erase(unique(alty.begin(), alty.end()), alty.end());\n  nH = altx.size();\n  nW = alty.size();\n\n  memset(cb, 0, sizeof(cb));\n  for (int i = 0; i < N; ++i) {\n\t\tint itx = lower_bound(altx.begin(), altx.end(), bx[i]) - altx.begin();\n\t\tint ity = lower_bound(alty.begin(), alty.end(), by[i]) - alty.begin();\n\t\tcb[itx][ity] = true;\n  }\n\n  long long all = (long long)H * W - N;\n  Fp add = 0;\n  long long width = W;\n\tlong long num_comped = 0;\n  long long sum = width - xnum[0];\n  for (int i = 1; i < H; ++i) {\n\t\tif (xnum[i] == 0 && xnum[i-1] == 0) {   // i-1 -> i\n\t\t\tFp up = sum - width * num_comped;\n\t\t\tFp down = all - sum;\n\t\t\tadd += up * down;\n\t\t}\n\t\tsum += width - xnum[i];\n  }\n  long long height = H - num_comped;\n  all -= width * num_comped;\n  num_comped = 0;\n  sum = height - ynum[0];\n  for (int i = 1; i < W; ++i) {\n\t\tif (ynum[i] == 0 && ynum[i-1] == 0) {   // i-1 -> i\n\t\t\tFp left = sum - height * num_comped;\n\t\t\tFp right = all - sum;\n\t\t\tadd += left * right;\n\t\t}\n\t\tsum += height - ynum[i];\n  }\n\n  Fp comp = subsolve();\n  Fp res = comp + add;\n\n\t//COUT(add);\n\n  return res;\n}\n\nint main() {\n  while (cin >> H >> W >> N) {\n\t\tfor (int i = 0; i < N; ++i) cin >> bx[i] >> by[i];\n\t\tcout << solve() << endl;\n  }\n}\n"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\n\nusing namespace std;\n\n#define fi first\n#define se second\n#define mp make_pair\n#define pb push_back\n#define all(x) (x).begin (),(x).end()\n#define sqrt(x) sqrt(abs(x))\n#define re return\n#define sz(x) ((int)(x).size ())\n#define prev PREV\n#define next NEXT\n\nusing ll = long long;\nusing ii = pair<int, int>;\nusing ld = long double;\nusing D = double;\nusing vi = vector<int>;\nusing vii = vector<ii>;\nusing vvi = vector<vi>;\nusing vs = vector<string>;\n\ntemplate<typename T> T abs (T x) { re x < 0 ? -x : x; }\ntemplate<typename T> T sgn (T x) { re x < 0 ? -1 : (x > 0 ? 1 : 0); }\ntemplate<typename T> T sqr (T x) { re x * x; }\ntemplate<typename T> T gcd (T a, T b) { re a ? gcd (b % a, a) : b; }\n\nconst int mod = 1000*1000*1000+7;\nint rev2;\nint rev3;\nint rev6;\n\nint n;\nint m;\n\nmap<ii, int> num;\nii rct[15000];\nint d[15000];\nint mark[15000];\nint xx[15000];\nint yy[15000];\nint x[30];\nint y[30];\nint g[61][61][2][2];\nii gc[61][61][2][2];\nint bad[61][61];\nvii wx, wy;\nvi vx, vy;\nint o;\npriority_queue<ii> all;\nint q;\nset<ii> pts;\n\nvii build (vi v, int n) {\n\tvii w;\n\tif (v[0] > 0) w.pb (mp (0, v[0] - 1));\n\tfor (int i = 0; i + 1 < sz (v); i++)\n\t\tif (v[i] + 1 < v[i + 1])\n\t\t\tw.pb (mp (v[i] + 1, v[i + 1] - 1));\n\tif (v[sz (v) - 1] + 1 < n)\n\t\tw.pb (mp (v[sz (v) - 1] + 1, n - 1));\n\tfor (int i = 0; i < sz (v); i++) w.pb (mp (v[i], v[i]));\n\tsort (all (w));\n\tre w;\n}\n\nint get (int x, int y, int i, int j) {\n\tif (num.find (mp (x, y)) != num.end ()) re num[mp (x, y)];\n\txx[o] = x;\n\tyy[o] = y;\n\trct[o] = mp (i, j);\n\tnum[mp (x, y)] = o;\n\to++;\n\tre o - 1;\n}\n\nvoid upd (int i, int j) {\n\tif (d[i] > j) {\n\t\td[i] = j;\n\t\tmark[i] = 1;\n\t\tall.push (mp (-d[i], i));\n\t}\n}\n\nint c2c (int a) {\n\tre ((ll)(a - 1) * a % mod * (a + 1) % mod * rev3) % mod;\n}\n\nint self (int a, int b) {\n\tre ((ll)c2c (a) * b % mod * b + (ll)c2c (b) * a % mod * a) % mod;\n}\n\nint same (int a, int b, int c, int dist) {\n//\tprintf (\"same %d %d %d %d\\n\", a, b, c, dist);\n\tre ((ll)c2c (a) * b % mod * c % mod + (ll)a * a % mod * b % mod * c % mod * (2 * dist + (b + c - 2)) % mod * rev2 % mod) % mod;\n}\n\nint diff (int a, int b, int c, int d, int dist) {\n\tre ((ll)a * b % mod * c % mod * d % mod * (a + b + c + d - 4 + 2 * dist) % mod * rev2) % mod;\n}\n\nint power (int a, int b) {\n\tint c = 1;\n\twhile (b) {\n\t\tif (b & 1) c = ((ll)c * a) % mod;\n\t\ta = ((ll)a * a) % mod;\n\t\tb /= 2;\n\t}\n\tre c;\n}\n\nint main () {\n\trev2 = power (2, mod - 2);\n\trev3 = power (3, mod - 2);\n\trev6 = power (6, mod - 2);\n\tscanf (\"%d%d\", &n, &m);\n\tscanf (\"%d\", &q);\n\tfor (int i = 0; i < q; i++) {\n\t\tscanf (\"%d%d\", &x[i], &y[i]);\n\t\tpts.insert (mp (x[i], y[i]));\n\t\tvx.pb (x[i]);\n\t\tvy.pb (y[i]);\n\t}\n\tsort (all (vx));\n\tsort (all (vy));\n\tvx.resize (unique (all (vx)) - vx.begin ());\n\tvy.resize (unique (all (vy)) - vy.begin ());\n\twx = build (vx, n);\n\twy = build (vy, m);\n\tint nx = sz (wx);\n\tint ny = sz (wy);\n\tfor (int i = 0; i < nx; i++)\n\t\tfor (int j = 0; j < ny; j++) {\n\t\t\tbad[i][j] = 1;\n\t\t\tif (wx[i].fi == wx[i].se && wy[j].fi == wy[j].se && pts.count (mp (wx[i].fi, wy[j].fi))) continue;\n\t\t\tbad[i][j] = 0;\n\t\t\tfor (int a = 0; a < 2; a++)\n\t\t\t\tfor (int b = 0; b < 2; b++) {\n\t\t\t\t\tgc[i][j][a][b] = mp (wx[i].fi + (wx[i].se - wx[i].fi) * a, wy[j].fi + (wy[j].se - wy[j].fi) * b);\n\t\t\t\t\tg[i][j][a][b] = get (wx[i].fi + (wx[i].se - wx[i].fi) * a, wy[j].fi + (wy[j].se - wy[j].fi) * b, i, j);\n\t\t\t\t}\n\t\t}\n//\tprintf (\"%d\\n\", o);\n\tint ans = 0;\n\tfor (int ii = 0; ii < nx; ii++)\n\t\tfor (int jj = 0; jj < ny; jj++) {\n\t\t\tif (bad[ii][jj]) continue;\n//\t\t\tprintf (\"%d %d\\n\", wx[ii].se - wx[ii].fi + 1, wy[jj].se - wy[jj].fi + 1);\n\t\t\tans = (ans + self (wx[ii].se - wx[ii].fi + 1, wy[jj].se - wy[jj].fi + 1)) % mod;\n\t\t\tfor (int j = 0; j < o; j++) {\n\t\t\t\td[j] = 1e9;\n\t\t\t\tmark[j] = 0;\n\t\t\t}\n\t\t\twhile (!all.empty ()) all.pop ();\n\t\t\tfor (int a = 0; a < 2; a++)\n\t\t\t\tfor (int b = 0; b < 2; b++)\n\t\t\t\t\tif (!mark[g[ii][jj][a][b]]) {\n\t\t\t\t\t\td[g[ii][jj][a][b]] = 0;\n\t\t\t\t\t\tmark[g[ii][jj][a][b]] = 1;\n\t\t\t\t\t\tall.push (mp (0, g[ii][jj][a][b]));\n\t\t\t\t\t}\n\t\t\twhile (!all.empty ()) {\n\t\t\t\tint j = all.top ().se;\n\t\t\t\tall.pop ();\n\t\t\t\tif (mark[j] == 2) continue;\n\t\t\t\tmark[j] = 2;\n\t\t\t\tint cx = xx[j];\n\t\t\t\tint cy = yy[j];\n\t\t\t\tint p = rct[j].fi;\n\t\t\t\tint q = rct[j].se;\n\t\t\t\tint ca = int (cx == wx[p].se);\n\t\t\t\tint cb = int (cy == wy[q].se);\n\t\t\t\tfor (int a = 0; a < 2; a++)\n\t\t\t\t\tfor (int b = 0; b < 2; b++) {\n\t\t\t\t\t\tint nx = gc[p][q][a][b].fi;\n\t\t\t\t\t\tint ny = gc[p][q][a][b].se;\n\t\t\t\t\t\tupd (g[p][q][a][b], d[j] + abs (cx - nx) + abs (cy - ny));\n\t\t\t\t\t}\n\t\t\t\tif (cx == wx[p].fi && p > 0 && !bad[p - 1][q]) upd (g[p - 1][q][1][cb], d[j] + 1);\n\t\t\t\tif (cx == wx[p].se && p + 1 < nx && !bad[p + 1][q]) upd (g[p + 1][q][0][cb], d[j] + 1);\n\t\t\t\tif (cy == wy[q].fi && q > 0 && !bad[p][q - 1]) upd (g[p][q - 1][ca][1], d[j] + 1);\n\t\t\t\tif (cy == wy[q].se && q + 1 < ny && !bad[p][q + 1]) upd (g[p][q + 1][ca][0], d[j] + 1);\n\t\t\t}\n//\t\t\tprintf (\"self = %d\\n\", ans);\n\t\t\tfor (int pp = 0; pp < nx; pp++)\n\t\t\t\tfor (int qq = 0; qq < ny; qq++) {\n\t\t\t\t\tif (bad[pp][qq]) continue;\n\t\t\t\t\tint dist = 1e9;\n\t\t\t\t\tfor (int a = 0; a < 2; a++)\n\t\t\t\t\t\tfor (int b = 0; b < 2; b++)\n\t\t\t\t\t\t\tdist = min (dist, d[g[pp][qq][a][b]]);\n\t\t\t\t\tif (dist == 0) continue;\n\t\t\t\t\tif (pp == ii) ans = (ans + same (wx[ii].se - wx[ii].fi + 1, wy[jj].se - wy[jj].fi + 1, wy[qq].se - wy[qq].fi + 1, dist)) % mod; else\n\t\t\t\t\tif (qq == jj) ans = (ans + same (wy[jj].se - wy[jj].fi + 1, wx[ii].se - wx[ii].fi + 1, wx[pp].se - wx[pp].fi + 1, dist)) % mod; else\n\t\t\t\t\t\t\t\t  ans = (ans + diff (wx[ii].se - wx[ii].fi + 1, wy[jj].se - wy[jj].fi + 1, wx[pp].se - wx[pp].fi + 1, wy[qq].se - wy[qq].fi + 1, dist)) % mod;\n//\t\t\t\t\tprintf (\"%d %d - %d %d = %d = %d\\n\", ii, jj, pp, qq, ans, dist);\n\t\t\t\t}\n\t\t}\n\tcout << ((ll)ans * rev2) % mod << endl;\n//\tcerr << clock () << endl;\n\treturn 0;\n}"
  },
  {
    "language": "C++",
    "code": "// SUBLIME HAX\n\t/*nope\n\tcat\n\t// sixteen chars// sixteen chars// sixteen chars// sixteen chars// sixteen chars// sixteen chars// sixteen chars// sixteen chars// sixteen chars// sixteen chars// sixteen chars// sixteen chars// sixteen chars// sixteen chars// sixteen chars// sixteen chars// sixteen chars// sixteen chars// sixteen chars// sixteen chars// sixteen chars// sixteen chars// sixteen chars// sixteen chars// sixteen chars// sixteen chars// sixteen chars// sixteen chars// sixteen chars// sixteen chars// sixteen chars// sixteen chars// sixteen chars// sixteen chars// sixteen chars// sixteen chars// sixteen chars// sixteen chars// sixteen chars// sixteen chars// sixteen chars// sixteen chars// sixteen chars// sixteen chars// sixteen chars// sixteen chars// sixteen chars// sixteen chars// sixteen chars// sixteen chars// sixteen chars// sixteen chars// sixteen chars// sixteen chars// sixteen chars// sixteen chars// sixteen chars// sixteen chars// sixteen chars// sixteen chars// sixteen chars// sixteen chars// sixteen chars// sixteen chars\n\t// ayy\n\t// ' lamo\n\t*/\n\t#include <bits/stdc++.h>\n\tusing namespace std;\n\ttemplate<class T,class U>\n\tostream &operator<<(ostream &os,const pair<T,U> &x) {\n\t\treturn os<<\"(\"<<x.first<<\",\"<<x.second<<\")\";\n\t}\n\tnamespace dbg_ns {\n\t\ttemplate<typename C>\n\t\tstruct is_iterable {\n\t\t\ttemplate<class T> static long check(...);\n\t\t\ttemplate<class T> static char check(int,\n\t\t\t\ttypename T::const_iterator = C().end());\n\t\t\tenum {\n\t\t\t\tvalue = sizeof(check<C>(0)) == sizeof(char),\n\t\t\t\tneg_value = sizeof(check<C>(0)) != sizeof(char)\n\t\t\t};\n\t\t};\n\t\ttemplate<class T> ostream &_out_str(ostream &os,const T &x) {\n\t\t\treturn os<<'\"'<<x<<'\"';\n\t\t}\n\t\ttemplate<class T> ostream &_dbg2_5(ostream &,const T &);\n\t\ttemplate<bool B,typename T=void> using eit=typename enable_if<B,T>::type;\n\t\ttemplate<class T>\n\t\tinline ostream &_dbg3(ostream &os,eit<is_iterable<T>::neg_value,const T> &x) {\n\t\t\treturn os<<x;\n\t\t}\n\t\ttemplate<class T>\n\t\tinline ostream &_dbg3(ostream &os,eit<is_iterable<T>::value,const T> &V) {\n\t\t\tos<<\"{\";\n\t\t\tbool ff=0;\n\t\t\tfor(const auto &E:V) _dbg2_5(ff?os<<\",\":os,E), ff=1;\n\t\t\treturn os<<\"}\";\n\t\t}\n\t\ttemplate<>\n\t\tinline ostream &_dbg3<string>(ostream &os,const string &x) {\n\t\t\treturn _out_str(os,x);\n\t\t}\n\t\ttemplate<>\n\t\tinline ostream &_dbg3<const char *>(ostream &os,const char *const &x) {\n\t\t\treturn _out_str(os,x);\n\t\t}\n\t\ttemplate<class T> inline ostream &_dbg2_5(ostream &os,const T &x) {\n\t\t\treturn _dbg3<T>(os,x);\n\t\t}\n\t\ttemplate<class T,typename... Args> ostream &_dbg2(ostream &os,vector<string>::iterator nm,const T &x,Args&&... args);\n\t\tinline ostream &_dbg2(ostream &os,vector<string>::iterator) { return os; }\n\t\ttemplate<typename... Args>\n\t\tinline ostream &_dbg2(ostream &os,vector<string>::iterator nm,const char *x,Args&&... args) {\n\t\t\treturn _dbg2(_dbg3<const char *>(os<<\"  \",x),nm+1,args...);\n\t\t}\n\t\ttemplate<class T,typename... Args>\n\t\tinline ostream &_dbg2(ostream &os,vector<string>::iterator nm,const T &x,Args&&... args) {\n\t\t\treturn _dbg2(_dbg3<T>(os<<\"  \"<<*nm<<\"=\",x),nm+1,args...);\n\t\t}\n\t\tvector<string> split(string s) {\n\t\t\tvector<string> Z;\n\t\t\tstring z=\"\";\n\t\t\ts+=',';\n\t\t\tint dep=0;\n\t\t\tfor(char c:s) {\n\t\t\t\tif(c==',' && !dep) Z.push_back(z),z=\"\";\n\t\t\t\telse z+=c;\n\t\t\t\tif(c=='(') ++dep;\n\t\t\t\tif(c==')') --dep;\n\t\t\t}\n\t\t\treturn Z;\n\t\t}\n\t\ttemplate<typename... Args> inline ostream &_dbg1(int ln,const string &nm,Args&&... args) {\n\t\t\tauto nms=split(nm);\n\t\t\treturn _dbg2(cerr<<\"L\"<<ln<<\":\",nms.begin(),args...)<<endl;\n\t\t}\n\t}\n\t#define dbg(...) dbg_ns::_dbg1(__LINE__,#__VA_ARGS__,__VA_ARGS__)\n\t#define sz(x) (int(x.size()))\n\t#define eprintf(...) fprintf(stderr,__VA_ARGS__)\n\t#define fi first\n\t#define se second\n\t#define pb push_back\n// END SUBLIME HAX\n// #include <bits/extc++.h>\n// using namespace __gnu_pbds;\ntypedef unsigned long long ull;\ntypedef long long ll;\ntypedef long double ld; //CARE\ntypedef complex<ld> pt;\nconst ld eps=(ld)1e-8;\nconst ld tau=2*(ld)acosl(-1);\nconst int inf=1e9+99;\nconst ll linf=1e18+99;\nconst int P=1e9+7;\n\n\n// #define int __int128\n// #define ll __int128\n\nint32_t H,W;\nint32_t n;\n\nconst int32_t N=8192;\nconst int NN=8070;\nint D[NN][NN];\nvector<pair<int,int> > adj[N];\nvector<pair<int,int> > rels;\nvector<int> relx,rely;\nset<pair<int,int> > bads;\nset<int> bx,by;\nvector<pair<int,int> > bandx,bandy;\n\nmap<int,int> ddec[1<<20];\n\nint dec(int x,int y) {\n\treturn ddec[x].count(y) ? ddec[x][y] : -1;\n\tauto it=lower_bound(rels.begin(),rels.end(),pair<int,int>(x,y));\n\tif(it!=rels.end() && it->fi==x && it->se==y)\n\t\treturn int(it-rels.begin());\n\treturn -1;\n}\n\n\nint sL(int x) { // 0+..+x-1\n\treturn int(1LL*x*(x-1)/2%P);\n}\nint ww(int x) {\n\tstatic bool init=0;\n\tstatic int Z[1<<20];\n\tassert(1<=x && x<(1<<20));\n\tif(!init) {\n\t\tinit=1;\n\t\tassert(!sL(0) && !sL(1));\n\t\tfor(int i=1;i<(1<<20);i++) {\n\t\t\tZ[i]=sL(i)+Z[i-1];\n\t\t\tif(Z[i]>=P) Z[i]-=P;\n\t\t}\n\t}\n\treturn Z[x];\n}\nint qq(int x,int y) {\n\treturn int((1LL*x*sL(y)+1LL*y*sL(x))%P);\n}\ninline int _w(const pair<int,int> &P) {\n\tif(~P.se) return P.se-P.fi+1;\n\treturn 1;\n}\nint g_same(int w,int h) {\n\t// dbg(\"SS\",w,h);\n\t// dbg(ww(h));\n\treturn int((1LL*w*w%P*ww(h) + 1LL*h*h%P*ww(w))%P);\n}\nint g_same(int w,const pair<int,int> &X,const pair<int,int> &_X) {\n\tif(X==_X) return g_same(w,_w(X));\n\tint d0;\n\tint a= X.fi,b=~ X.se? X.se: X.fi;\n\tint c=_X.fi,d=~_X.se?_X.se:_X.fi;\n\tassert(a<=b && c<=d);\n\tif(b<c) d0=c-b; else\n\tif(d<a) d0=a-d; else\n\tassert(0);\n\tint h1=_w(X);\n\tint h2=_w(_X);\n\n\tll ZZ=d0;\n\tZZ=ZZ*w%P*h1%P*w%P*h2%P;\n\tZZ+=1LL*h1*h2%P*ww(w)*2; //dbg(h1,h2,w,ww(w));\n\tZZ+=1LL*w*w%P*qq(h1,h2);\n\t// dbg(\"HIT\",w,h1,h2,ZZ,d0);\n\treturn int(ZZ%P);\n}\ninline int close(const pair<int,int> &X,int x) {\n\tif(!~X.se) return X.fi;\n\tif(x<X.fi) return X.fi;\n\tif(x>X.se) return X.se;\n\tassert(0);\n}\nint g(const pair<int,int> &X,const pair<int,int> &Y,\n\tconst pair<int,int> &_X,const pair<int,int> &_Y) {\n\n\tif(X==_X && Y==_Y && !~X.se && !~Y.se) return 0;\n\n\tif(X==_X && ~X.se) return g_same(_w(X),Y,_Y);\n\tif(Y==_Y && ~Y.se) return g_same(_w(Y),X,_X);\n\n\tint  Cx=_w(X);\n\tint  Cy=_w(Y);\n\tint _Cx=_w(_X);\n\tint _Cy=_w(_Y);\n\tint CCx=int(1LL*Cx*_Cx%P);\n\tint CCy=int(1LL*Cy*_Cy%P);\n\n\tint u=dec(close(X,_X.fi),close(Y,_Y.fi)); assert(~u);\n\tint v=dec(close(_X,X.fi),close(_Y,Y.fi)); assert(~v);\n\n\tll ZZ=D[u][v]; assert(ZZ<inf);\n\n\tZZ=ZZ*CCx%P*CCy;\n\t// dbg(C,_C,ZZ,ZZ%P);\n\n\tZZ+=1LL*CCx*qq(Cy,_Cy);\n\tZZ+=1LL*CCy*qq(Cx,_Cx);\n\n\t// dbg(ZZ,ZZ%P);\n\n\treturn int(ZZ%P);\n}\n\n\ntemplate<class T> struct PQ {\n\tint n=0;\n\tT A[N*4];\n\tvoid push(const T &x) {\n\t\tint i=++n;\n\t\tA[i]=x;\n\t\tfor(;i>1 && A[i>>1]<A[i];) swap(A[i>>1],A[i]), i>>=1;\n\t}\n\tT top() const { return A[1]; }\n\tvoid pop() {\n\t\tassert(n>=1);\n\t\tif(n>1) swap(A[1],A[n]);\n\t\tn--;\n\t\tint i=1;\n\t\tfor(;;) {\n\t\t\tint j=i<<1;\n\t\t\tif(j>n) break;\n\t\t\tif(j==n) {\n\t\t\t\tif(A[j]>A[i]) swap(A[j],A[i]);\n\t\t\t\tbreak;\n\t\t\t}\n\t\t\tif(A[j+1]>A[j]) ++j;\n\t\t\tif(A[j]>A[i]) swap(A[j],A[i]);\n\t\t\telse break;\n\t\t\ti=j;\n\t\t}\n\t}\n\tint size() const {\n\t\treturn n;\n\t}\n};\n// PQ<pair<int,int> > pq;\n// priority_queue<pair<int,int> > pq;\n// queue<pair<int,int> > pq;\nint pq[N];\nbool inq[N];\n#define top front\n\nvoid dijk(int src,int *DD) {\n\t// for(int u=0;u<n;u++) DD[u]=inf;\n\t// for(int u=0;u<=src;u++) DD[u]=D[u][src], pq.push({-DD[u],u});\n\t// for(int u=src+1;u<n;u++) DD[u]=inf;\n\t// if(src) for(int u=src+1;u<n;u++) DD[u]=D[src-1][u]+DD[src-1], pq.push({-DD[u],u});\n\tint pn=0;\n\tfor(int u=0;u<=src;u++) DD[u]=D[u][src], pq[pn++]=u;\n\tfor(int u=src+1;u<n;u++) DD[u]=inf;\n\tif(src) for(int u=src+1;u<n;u++) DD[u]=D[src-1][u]+DD[src-1], pq[pn++]=u;\n\n\tint ii=0;\n\tfor(int i=0;i<n;i++) inq[i]=0;\n\tfor(int i=0;i<pn;i++) inq[pq[i]]=1;\n\t// DD[src]=0;\n\t// pq.push({0,src});\n\t// for(;sz(pq);) {\n\tfor(;ii<pn;) {\n\t\t// auto P=pq.top();\n\t\t// int u=P.se;\n\t\t// int d=-P.fi;\n\t\t// pq.pop();\n\t\t// if(DD[u]<d) continue;\n\t\tint u=pq[(ii++)&(N-1)];\n\t\tinq[u]=0;\n\t\tint d=DD[u];\n\t\tfor(const auto &P:adj[u]) if(d+P.se<DD[P.fi]) {\n\t\t\tDD[P.fi]=d+P.se;\n\t\t\t// pq.push({-DD[P.fi],P.fi});\n\t\t\tif(!inq[P.fi]) pq[(pn++)&(N-1)]=P.fi;\n\t\t}\n\t}\n}\n\n\nint32_t main() {\n\t// for(int i=1;i<6;i++) dbg(i,ww(i));\n\tcin>>H>>W>>n;\n\tfor(int i=0;i<n;i++) {\n\t\tint32_t x,y; cin>>x>>y;\n\t\tbads.insert({x,y});\n\t\tbx.insert(x), by.insert(y);\n\t}\n\tfor(int _x:bx) for(int x=_x-1;x<=_x+1;x++)\n\t\tif(!sz(relx) || x>relx.back()) if(0<=x && x<H)\n\t\t\trelx.pb(x);\n\tfor(int _y:by) for(int y=_y-1;y<=_y+1;y++)\n\t\tif(!sz(rely) || y>rely.back()) if(0<=y && y<W)\n\t\t\trely.pb(y);\n\n\tfor(int x:relx) for(int y:rely) if(!bads.count({x,y})) rels.pb({x,y});\n\tsort(rels.begin(),rels.end());\n\tn=sz(rels);\n\tassert(n<=NN);\n\tfor(int i=0;i<n;i++) ddec[rels[i].fi][rels[i].se]=i;\n\n\tfor(int i=1;i<sz(relx);i++) for(int y:rely) {\n\t\tint u=dec(relx[i-1],y);\n\t\tint v=dec(relx[i],y);\n\t\tint d=relx[i]-relx[i-1];\n\t\tif(~u && ~v) {\n\t\t\tadj[u].pb({v,d});\n\t\t\tadj[v].pb({u,d});\n\t\t}\n\t}\n\tfor(int i=1;i<sz(rely);i++) for(int x:relx) {\n\t\tint u=dec(x,rely[i-1]);\n\t\tint v=dec(x,rely[i]);\n\t\tint d=rely[i]-rely[i-1];\n\t\tif(~u && ~v) {\n\t\t\tadj[u].pb({v,d});\n\t\t\tadj[v].pb({u,d});\n\t\t}\n\t}\n\n\tfor(int i=0;i<n;i++) dijk(i,D[i]);\n\t// for(int i=0;i<n;i++) for(int j=0;j<n;j++) dbg(rels[i],rels[j],D[i][j]);\n\n\t{\n\t\tint pr=-1;\n\t\tfor(int x:bx) {\n\t\t\tif(x-1>pr) bandx.pb({pr+1,x-1});\n\t\t\tbandx.pb({x,-1});\n\t\t\tpr=x;\n\t\t}\n\t\tif(H-1>pr) bandx.pb({pr+1,H-1});\n\t}\n\t{\n\t\tint pr=-1;\n\t\tfor(int y:by) {\n\t\t\tif(y-1>pr) bandy.pb({pr+1,y-1});\n\t\t\tbandy.pb({y,-1});\n\t\t\tpr=y;\n\t\t}\n\t\tif(W-1>pr) bandy.pb({pr+1,W-1});\n\t}\n\n\tassert(sz(bandx)<=61 && sz(bandy)<=61);\n\n\tll Z=0;\n\tfor(const auto &BX:bandx) for(const auto &BY:bandy) {\n\t\tif(bads.count({BX.fi,BY.fi})) continue;\n\t\tfor(const auto &_BX:bandx) for(const auto &_BY:bandy) {\n\t\t\tif(BX>_BX) continue;\n\t\t\tif(BX==_BX && BY>_BY) continue;\n\t\t\tif(!~_BX.se && !~_BY.se && bads.count({_BX.fi,_BY.fi})) continue;\n\t\t\tint w=g(BX,BY,_BX,_BY);\n\t\t\tZ+=w;\n\t\t}\n\t}\n\tcout<<int32_t(Z%P)<<endl;\n}\n\n\n\n\n\n\n\n\n\n\n\n"
  },
  {
    "language": "C++",
    "code": "#include <algorithm>\n#include <climits>\n#include <cmath>\n#include <cstdio>\n#include <cstdlib>\n#include <ctime>\n#include <iostream>\n#include <sstream>\n#include <functional>\n#include <map>\n#include <set>\n#include <unordered_map>\n#include <unordered_set>\n#include <bitset>\n#include <string>\n#include <cstring>\n#include <vector>\n#include <queue>\n#include <stack>\n#include <deque>\n#include <list>\n#include <numeric>\nusing namespace std;\ntypedef long long ll;\ntypedef unsigned long long ull;\ntypedef long double ld;\ntypedef pair<ll,ll> P;\ntypedef pair<P,ll> PPI;\ntypedef pair<ll,P> PIP;\ntypedef vector<ll> vl;\ntypedef vector<vl> vvl;\ntypedef vector<P> vp;\n#define PQ(T) priority_queue<T,vector<T>,greater<T>>\n#define PQ2(T) priority_queue<T>\nconst double PI = 3.14159265358979323846;\nconst double EPS = 1e-12;\nconst ll INF = 1LL<<59;\nconst ll mod = 1e9+7;\n#define REP(i,a,b) for(ll (i)=a;(i)<(ll)(b);++(i))\n#define rep(i,n) REP(i,0,n)\n#define rep1(i,n) REP(i,1,n+1)\n#define repd(i,n,d) for(ll (i)=0;(i)<(ll)(n);(i)+=(d))\n#define all(v) (v).begin(), (v).end()\n#define pb(x) push_back(x)\n#define mp(x,y) make_pair((x),(y))\n#define mset(m,v) memset((m),(v),sizeof(m))\n#define chmin(x,y) ((x)=min((x),(y)))\n#define chmax(x,y) ((x)=max((x),(y)))\n#define fst first\n#define snd second\n#define UNIQUE(x) (x).erase(unique(all(x)),(x).end())\n#define DEBUG(x) cerr<<\"line (\"<<__LINE__<<\")  \"<<#x<<\": \"<<x<<endl;\ntemplate<class T> ostream &operator<<(ostream &os, const vector<T> &v){int n=v.size();rep(i,n)os<<v[i]<<(i==n-1?\"\":\" \");return os;}\n\n#define N 90\n#define M 65*65*4\nint h, w, n, h2, w2;\nint x[N], y[N], xy[N][N];\nvector<int> x2, y2;\nunordered_map<int, int> xd, yd;\nll d[M];\n\nll pow_mod(ll a, ll r, ll m = mod){\n\tll x = 1;\n\twhile(r){\n\t\tif(r&1) (x*=a)%=m;\n\t\t(a*=a)%=m;\n\t\tr>>=1;\n\t}\n\treturn x;\n}\n\nll inv2 = pow_mod(2, mod-2, mod);\nll inv3 = pow_mod(3, mod-2, mod);\n\nll f(ll a, ll b, ll c){\n\treturn (a*w2+b)*4+c;\n}\n\nvoid comp(int *a, vector<int> &b, unordered_map<int, int> &c, int d, int &d2){\n\tb.clear(); c.clear();\n\trep(i, n){ b.pb(a[i]); b.pb(a[i]+1);}\n\tb.pb(0); b.pb(d);\n\tsort(all(b));\n\tUNIQUE(b);\n\td2 = b.size();\n\trep(i, d2) c[b[i]] = i;\n\trep(i, n) a[i] = c[a[i]];\n}\n\nll solve(int a, int b, int c, bool xf, bool yf){\n\tfill(d, d+M, INF);\n\trep(i, n) rep(j, 4) d[f(x[i], y[i], j)] = -1;\n\tll abc = f(a, b, c);\n\td[abc] = 0;\n\tPQ(P) q;\n\tq.push(P(0, abc));\n\tll res = 0;\n\twhile(!q.empty()){\n\t\tP p = q.top(); q.pop();\n\t\tll l = p.fst, u = (p.snd>>2)/w2, v = (p.snd>>2)%w2, k = p.snd&3;\n\t\tif(d[p.snd]<l) continue;\n\t\t//cerr<<\"dijk \"<<u<<\" \"<<v<<\" \"<<k<<\" \"<<l<<endl;\n\t\tll kx = k>>1, ky = k&1;\n\t\tll u2 = u+kx*2-1, v2 = v+ky*2-1;\n\t\tif(0<=u2&&u2<h2-1){\n\t\t\tll p2 = f(u2, v, k^2);\n\t\t\tif(d[p2]>=0 && l+1<d[p2]){\n\t\t\t\td[p2] = l+1;\n\t\t\t\tq.push(P(d[p2], p2));\n\t\t\t}\n\t\t}\n\t\tif(0<=v2&&v2<w2-1){\n\t\t\tll p2 = f(u, v2, k^1);\n\t\t\tif(d[p2]>=0 && l+1<d[p2]){\n\t\t\t\td[p2] = l+1;\n\t\t\t\tq.push(P(d[p2], p2));\n\t\t\t}\n\t\t}\n\t\trep1(i, 3){\n\t\t\tll k2 = k^i;\n\t\t\tll l2 = l;\n\t\t\tif(i&2) l2 += x2[u+1]-x2[u]-1;\n\t\t\tif(i&1) l2 += y2[v+1]-y2[v]-1;\n\t\t\tll p2 = f(u, v, k2);\n\t\t\tif(d[p2]>=0 && l2<d[p2]){\n\t\t\t\td[p2] = l2;\n\t\t\t\tq.push(P(d[p2], p2));\n\t\t\t}\n\t\t}\n\t}\n\trep(i, h2-1) rep(j, w2-1){\n\t\tif(xy[i][j]) continue;\n\t\tif(xf && i==a) continue;\n\t\tif(yf && j==b) continue;\n\t\t(res+=(d[f(i, j, 0)]+d[f(i, j, 3)])%mod*(x2[i+1]-x2[i])%mod*(y2[j+1]-y2[j])%mod*inv2)%=mod;\n\t}\n\treturn res;\n\trep(i, h2-1){\n\t\trep(j, w2-1) cerr<<d[f(i, j, 0)]<<\" \";\n\t\tcerr<<endl;\n\t}\n\treturn res;\n}\n\nll f5(ll h){\n\tll r1 = ((3*h-2)*(h-1)+2*(h-1)*(h-1)%mod*(h-1))%mod*(h-1)%mod;\n\tll r2 = ((4*h-4)*(h-1)+2*(h-2)*(h-1)%mod*(h-1))%mod*(h-1)%mod*(h-1)%mod*inv2%mod;\n\treturn (r1+r2)%mod;\n}\n\nint main(){\n\tcin>>h>>w>>n;\n\trep(i, n) cin>>x[i]>>y[i];\n\tcomp(x, x2, xd, h, h2);\n\tcomp(y, y2, yd, w, w2);\n\trep(i, n) xy[x[i]][y[i]] = -1;\n\tll res = 0;\n\trep(i, h2-1) rep(j, w2-1){\n\t\tif(xy[i][j]) continue;\n\t\tll xx = x2[i+1]-x2[i], yy = y2[j+1]-y2[j];\n\t\tbool xf = xx>1, yf = yy>1;\n\t\tll r0 = solve(i, j, 0, xf, yf);\n\t\tll r3 = (!xf&&!yf)?r0:solve(i, j, 3, xf, yf);\n\t\t//cerr<<\"xx yy \"<<xx<<\" \"<<yy<<endl;\n\t\tll res2 = res;\n\t\t(res+=(r0+r3)*(xx)%mod*(yy)%mod*inv2)%=mod;\n\t\t//cerr<<\"diff1 \"<<(res-res2+mod)%mod<<endl;\n\t\tif(!xf&&!yf) continue;\n\t\tll xx1 = x2[i], xx2 = h-x2[i+1], yy1 = y2[j], yy2 = w-y2[j+1];\n\t\tif(xf&&yf){\n\t\t\tll rx = (pow_mod(xx, 3)-xx)*w%mod*yy%mod*inv3%mod + (yy1*(yy1+1)+yy2*(yy2+1))%mod*xx%mod*xx%mod*yy%mod*inv2%mod + xx*xx%mod*yy%mod*(w-yy)%mod*(yy-1)%mod*inv2%mod;\n\t\t\tll ry = (pow_mod(yy, 3)-yy)*h%mod*xx%mod*inv3%mod + (xx1*(xx1+1)+xx2*(xx2+1))%mod*yy%mod*yy%mod*xx%mod*inv2%mod + yy*yy%mod*xx%mod*(h-xx)%mod*(xx-1)%mod*inv2%mod;\n\t\t\t(res+=rx+ry)%=mod;\n\t\t\t//cerr<<\"rx ry \"<<rx<<\" \"<<ry<<endl;\n\t\t} else if(xf){\n\t\t\t(res+=(pow_mod(xx, 3)-xx)*w%mod*inv3%mod + (yy1*(yy1+1)+yy2*(yy2+1))%mod*xx%mod*xx%mod*inv2%mod)%=mod;\n\t\t} else {\n\t\t\t(res+=(pow_mod(yy, 3)-yy)*h%mod*inv3%mod + (xx1*(xx1+1)+xx2*(xx2+1))%mod*yy%mod*yy%mod*inv2%mod)%=mod;\n\t\t}\n\t\tcerr<<\"diff \"<<(res-res2+mod)%mod<<endl;\n\t}\n\tcout<<(res*inv2%mod+mod)%mod<<endl;\n\t//cerr<<res<<endl;\n\t//cerr<<f5(h)*inv2%mod<<endl;\n\treturn 0;\n}\n"
  },
  {
    "language": "C++",
    "code": "#include <iostream>\n#include <vector>\n#include <map>\n#include <queue>\n#include <algorithm>\n#include <cstring>\nusing namespace std;\n\n#define REP(i, s) for (int i = 0; i < s; ++i)\n#define ALL(v) (v.begin(), v.end())\n#define COUT(x) cout << #x << \" = \" << (x) << \" (L\" << __LINE__ << \")\" << endl\n#define EACH(i, s) for (__typeof__((s).begin()) i = (s).begin(); i != (s).end(); ++i)\n\ntemplate<class T> inline bool chmax(T& a, T b) { if (a < b) { a = b; return 1; } return 0; }\ntemplate<class T> inline bool chmin(T& a, T b) { if (a > b) { a = b; return 1; } return 0; }\ntemplate<class T1, class T2> ostream& operator << (ostream &s, pair<T1, T2> P)\n{\n\treturn s << '<' << P.first << \", \" << P.second << '>';\n}\ntemplate<class T> ostream& operator << (ostream &s, vector<T> P)\n{\n\tfor (int i = 0; i < P.size(); ++i) { if (i > 0) { s << \" \"; } s << P[i]; } return s;\n}\ntemplate<class T> ostream& operator << (ostream &s, vector<vector<T> > P)\n{\n\tfor (int i = 0; i < P.size(); ++i) { s << endl << P[i]; } return s << endl;\n}\n\nconst int MOD = 1000000007;\ninline long long mod(long long a, long long m) { return (a % m + m) % m; }\nstruct Fp {\n\tint MOD = 1000000007;\n\tlong long val;\n\n\tFp() : val(0) {}\n\tFp(long long val_) { this->val = mod(val_, MOD); }\n\tFp operator = (long long val_) { this->val = mod(val_, MOD); return *this; }\n\tinline Fp operator - () { return mod(-val, MOD); }\n\tinline const Fp& operator += (const Fp &x);\n\tinline const Fp& operator -= (const Fp &x);\n\tinline const Fp& operator *= (const Fp &x);\n\tinline const Fp& operator /= (const Fp &x);\n};\n\ninline bool operator == (Fp x, Fp y) { return x.val == y.val; }\ninline bool operator != (Fp x, Fp y) { return !(x == y); }\n\nostream &operator << (ostream &os, Fp x) { return os << x.val; }\nistream &operator >> (istream &is, Fp &x) { is >> x; return is; }\n\ninline Fp operator + (Fp x, Fp y) { return mod(x.val + y.val, x.MOD); }\ninline Fp operator - (Fp x, Fp y) { return mod(x.val - y.val, x.MOD); }\ninline Fp operator * (Fp x, Fp y) { return mod(x.val * y.val, x.MOD); }\ninline Fp operator / (Fp x, Fp y) {\n\tlong long a = y.val, b = x.MOD, u = 1, v = 0;\n\twhile (b) {\n\t\tlong long t = a / b;\n\t\ta -= t*b; swap(a, b);\n\t\tu -= t*v; swap(u, v);\n\t}\n\treturn x * u;\n}\ninline Fp abs(Fp a) { return a; }\ninline Fp fpow(Fp a, long long n) {\n\tif (n == 0) return Fp(1);\n\tFp t = fpow(a, n / 2);\n\tt = t * t; if (n & 1) t = t * a;\n\treturn t;\n}\ninline const Fp& Fp::operator += (const Fp &x) { *this = *this + x; return *this; }\ninline const Fp& Fp::operator -= (const Fp &x) { *this = *this - x; return *this; }\ninline const Fp& Fp::operator *= (const Fp &x) { *this = *this * x; return *this; }\ninline const Fp& Fp::operator /= (const Fp &x) { *this = *this / x; return *this; }\n\n// calc comb (small n, r ver)\nconst int FACT_MAX = 210000;\nstatic Fp fp_fact_val[FACT_MAX];\n\nvoid calcFact(int MAX = FACT_MAX) {\n\tfp_fact_val[0] = 1;\n\tfor (int val = 1; val < MAX; ++val) {\n\t\tfp_fact_val[val] = fp_fact_val[val - 1] * val;\n\t}\n}\n\nFp fact(int n) {\n\treturn fp_fact_val[n];\n}\n\nFp com(int n, int r) {\n\treturn fact(n) / fact(r) / fact(n - r);\n}\n\nint dx[4] = {1, 0, -1, 0};\nint dy[4] = {0, 1, 0, -1};\n\nlong long H, W, N;\nlong long bx[210], by[210];\nvector<long long> altx, alty;\nlong long nH, nW;\n\nlong long xnum[1100000], ynum[1100000];\n\nbool cb[210][210];\nlong long dist[210][210];\n\ntypedef pair<int, int> pint;\n\nFp subsolve() {\n\t//COUT(nH); COUT(nW); COUT(altx); COUT(alty);\n\n\tfor (int x = 0; x < nH - 1; ++x) {\n\t\tfor (int y = 0; y < nW - 1; ++y) {\n\t\t\t//cout << cb[x][y];\n\t\t}\n\t\t//cout << endl;\n\t}\n\n  Fp res = 0;\n\tfor (int x = 0; x < nH - 1; ++x) {\n\t\tfor (int y = 0; y < nW - 1; ++y) {\n\t\t\tif (cb[x][y]) continue;\n\t\t\tmemset(dist, -1, sizeof(dist));\n\t\t\tqueue<pint> que;\n\t\t\tque.push(pint(x, y));\n\t\t\tdist[x][y] = 0;\n\t\t\twhile (!que.empty()) {\n\t\t\t\tpint cur = que.front();\n\t\t\t\tque.pop();\n\t\t\t\tfor (int dir = 0; dir < 4; ++dir) {\n\t\t\t\t\tint nx = cur.first + dx[dir];\n\t\t\t\t\tint ny = cur.second + dy[dir];\n\t\t\t\t\tif (nx < 0 || nx >= H || ny < 0 || ny >= W) continue;\n\t\t\t\t\tif (cb[nx][ny]) continue;\n\t\t\t\t\tif (dist[nx][ny] == -1) {\n\t\t\t\t\t\tdist[nx][ny] = dist[cur.first][cur.second] + 1;\n\t\t\t\t\t\tque.push(pint(nx, ny));\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t}\n\t\t\t\n\t\t\tfor (int nx = 0; nx < nH - 1; ++nx) {\n\t\t\t\tfor (int ny = 0; ny < nW - 1; ++ny) {\n\t\t\t\t\tif (nW * nx + ny <= nW * x + y) continue;\n\t\t\t\t\tif (dist[nx][ny] == -1) continue;\n\t\t\t\t\tif (cb[nx][ny]) continue;\n\n\t\t\t\t\tlong long ss = ((long long)(altx[x + 1] - altx[x]) * (alty[y + 1] - alty[y])) % MOD;\n\t\t\t\t\tlong long st = ((long long)(altx[nx + 1] - altx[nx]) * (alty[ny + 1] - alty[ny])) % MOD;\n\t\t\t\t\tres += Fp(dist[nx][ny]) * ss * st;\n\n\t\t\t\t\t//cout << pint(x, y) << \", \" << pint(nx, ny) << \": \" << dist[nx][ny] << \", \" << ss << \", \" << st << endl;\n\t\t\t\t}\n\t\t\t}\n\t\t\t\n\t\t}\n\t}\n\t//COUT(res);\n\t//res /= 2;\n\n\treturn res;\n}\n\nFp solve() {\n  memset(xnum, 0, sizeof(xnum));\n  memset(ynum, 0, sizeof(ynum));\n\taltx.clear();\n\talty.clear();\n  altx.push_back(0);\n  altx.push_back(H);\n  alty.push_back(0);\n  alty.push_back(W);\n  for (int i = 0; i < N; ++i) {\n\t\taltx.push_back(bx[i]);\n\t\taltx.push_back(bx[i] + 1);\n\t\talty.push_back(by[i]);\n\t\talty.push_back(by[i] + 1);\n\t\txnum[bx[i]]++;\n\t\tynum[by[i]]++;\n  }\n  sort(altx.begin(), altx.end());\n  sort(alty.begin(), alty.end());\n  altx.erase(unique(altx.begin(), altx.end()), altx.end());\n  alty.erase(unique(alty.begin(), alty.end()), alty.end());\n  nH = altx.size();\n  nW = alty.size();\n\n  memset(cb, 0, sizeof(cb));\n  for (int i = 0; i < N; ++i) {\n\t\tint itx = lower_bound(altx.begin(), altx.end(), bx[i]) - altx.begin();\n\t\tint ity = lower_bound(alty.begin(), alty.end(), by[i]) - alty.begin();\n\t\tcb[itx][ity] = true;\n  }\n\n  long long all = (long long)H * W - N;\n  Fp add = 0;\n  long long width = W;\n\tlong long num_comped = 0;\n  long long sum = width - xnum[0];\n  for (int i = 1; i < H; ++i) {\n\t\tif (xnum[i] == 0 && xnum[i-1] == 0) {   // i-1 -> i\n\t\t\tFp up = sum - width * num_comped;\n\t\t\tFp down = all - sum;\n\t\t\tadd += up * down;\n\t\t}\n\t\tsum += width - xnum[i];\n  }\n  long long height = H - num_comped;\n  all -= width * num_comped;\n  num_comped = 0;\n  sum = height - ynum[0];\n  for (int i = 1; i < W; ++i) {\n\t\tif (ynum[i] == 0 && ynum[i-1] == 0) {   // i-1 -> i\n\t\t\tFp left = sum - height * num_comped;\n\t\t\tFp right = all - sum;\n\t\t\tadd += left * right;\n\t\t}\n\t\tsum += height - ynum[i];\n  }\n\n  Fp comp = subsolve();\n  Fp res = comp + add;\n\n\t//COUT(add);\n\n  return res;\n}\n\nint main() {\n  while (cin >> H >> W >> N) {\n\t\tfor (int i = 0; i < N; ++i) cin >> bx[i] >> by[i];\n\t\tcout << solve() << endl;\n  }\n}\n"
  },
  {
    "language": "C++",
    "code": "// SUBLIME HAX\n\t/*nope\n\tcat\n\t// sixteen chars// sixteen chars// sixteen chars// sixteen chars// sixteen chars// sixteen chars// sixteen chars// sixteen chars// sixteen chars// sixteen chars// sixteen chars// sixteen chars// sixteen chars// sixteen chars// sixteen chars// sixteen chars// sixteen chars// sixteen chars// sixteen chars// sixteen chars// sixteen chars// sixteen chars// sixteen chars// sixteen chars// sixteen chars// sixteen chars// sixteen chars// sixteen chars// sixteen chars// sixteen chars// sixteen chars// sixteen chars// sixteen chars// sixteen chars// sixteen chars// sixteen chars// sixteen chars// sixteen chars// sixteen chars// sixteen chars// sixteen chars// sixteen chars// sixteen chars// sixteen chars// sixteen chars// sixteen chars// sixteen chars// sixteen chars// sixteen chars// sixteen chars// sixteen chars// sixteen chars// sixteen chars// sixteen chars// sixteen chars// sixteen chars// sixteen chars// sixteen chars// sixteen chars// sixteen chars// sixteen chars// sixteen chars// sixteen chars// sixteen chars\n\t// ayy\n\t// ' lamo\n\t*/\n\t#include <bits/stdc++.h>\n\tusing namespace std;\n\ttemplate<class T,class U>\n\tostream &operator<<(ostream &os,const pair<T,U> &x) {\n\t\treturn os<<\"(\"<<x.first<<\",\"<<x.second<<\")\";\n\t}\n\tnamespace dbg_ns {\n\t\ttemplate<typename C>\n\t\tstruct is_iterable {\n\t\t\ttemplate<class T> static long check(...);\n\t\t\ttemplate<class T> static char check(int,\n\t\t\t\ttypename T::const_iterator = C().end());\n\t\t\tenum {\n\t\t\t\tvalue = sizeof(check<C>(0)) == sizeof(char),\n\t\t\t\tneg_value = sizeof(check<C>(0)) != sizeof(char)\n\t\t\t};\n\t\t};\n\t\ttemplate<class T> ostream &_out_str(ostream &os,const T &x) {\n\t\t\treturn os<<'\"'<<x<<'\"';\n\t\t}\n\t\ttemplate<class T> ostream &_dbg2_5(ostream &,const T &);\n\t\ttemplate<bool B,typename T=void> using eit=typename enable_if<B,T>::type;\n\t\ttemplate<class T>\n\t\tinline ostream &_dbg3(ostream &os,eit<is_iterable<T>::neg_value,const T> &x) {\n\t\t\treturn os<<x;\n\t\t}\n\t\ttemplate<class T>\n\t\tinline ostream &_dbg3(ostream &os,eit<is_iterable<T>::value,const T> &V) {\n\t\t\tos<<\"{\";\n\t\t\tbool ff=0;\n\t\t\tfor(const auto &E:V) _dbg2_5(ff?os<<\",\":os,E), ff=1;\n\t\t\treturn os<<\"}\";\n\t\t}\n\t\ttemplate<>\n\t\tinline ostream &_dbg3<string>(ostream &os,const string &x) {\n\t\t\treturn _out_str(os,x);\n\t\t}\n\t\ttemplate<>\n\t\tinline ostream &_dbg3<const char *>(ostream &os,const char *const &x) {\n\t\t\treturn _out_str(os,x);\n\t\t}\n\t\ttemplate<class T> inline ostream &_dbg2_5(ostream &os,const T &x) {\n\t\t\treturn _dbg3<T>(os,x);\n\t\t}\n\t\ttemplate<class T,typename... Args> ostream &_dbg2(ostream &os,vector<string>::iterator nm,const T &x,Args&&... args);\n\t\tinline ostream &_dbg2(ostream &os,vector<string>::iterator) { return os; }\n\t\ttemplate<typename... Args>\n\t\tinline ostream &_dbg2(ostream &os,vector<string>::iterator nm,const char *x,Args&&... args) {\n\t\t\treturn _dbg2(_dbg3<const char *>(os<<\"  \",x),nm+1,args...);\n\t\t}\n\t\ttemplate<class T,typename... Args>\n\t\tinline ostream &_dbg2(ostream &os,vector<string>::iterator nm,const T &x,Args&&... args) {\n\t\t\treturn _dbg2(_dbg3<T>(os<<\"  \"<<*nm<<\"=\",x),nm+1,args...);\n\t\t}\n\t\tvector<string> split(string s) {\n\t\t\tvector<string> Z;\n\t\t\tstring z=\"\";\n\t\t\ts+=',';\n\t\t\tint dep=0;\n\t\t\tfor(char c:s) {\n\t\t\t\tif(c==',' && !dep) Z.push_back(z),z=\"\";\n\t\t\t\telse z+=c;\n\t\t\t\tif(c=='(') ++dep;\n\t\t\t\tif(c==')') --dep;\n\t\t\t}\n\t\t\treturn Z;\n\t\t}\n\t\ttemplate<typename... Args> inline ostream &_dbg1(int ln,const string &nm,Args&&... args) {\n\t\t\tauto nms=split(nm);\n\t\t\treturn _dbg2(cerr<<\"L\"<<ln<<\":\",nms.begin(),args...)<<endl;\n\t\t}\n\t}\n\t#define dbg(...) dbg_ns::_dbg1(__LINE__,#__VA_ARGS__,__VA_ARGS__)\n\t#define sz(x) (int(x.size()))\n\t#define eprintf(...) fprintf(stderr,__VA_ARGS__)\n\t#define fi first\n\t#define se second\n\t#define pb push_back\n// END SUBLIME HAX\n// #include <bits/extc++.h>\n// using namespace __gnu_pbds;\ntypedef unsigned long long ull;\ntypedef long long ll;\ntypedef long double ld; //CARE\ntypedef complex<ld> pt;\nconst ld eps=(ld)1e-8;\nconst ld tau=2*(ld)acosl(-1);\nconst int inf=1e9+99;\nconst ll linf=1e18+99;\nconst int P=1e9+7;\n\n\n// #define int __int128\n// #define ll __int128\n\nint32_t H,W;\nint32_t n;\n\nconst int32_t N=8192;\nint D[N][N];\nvector<pair<int,int> > adj[N];\nvector<pair<int,int> > rels;\nvector<int> relx,rely;\nset<pair<int,int> > bads;\nset<int> bx,by;\nvector<pair<int,int> > bandx,bandy;\n\nmap<int,int> ddec[1<<20];\n\nint dec(int x,int y) {\n\treturn ddec[x].count(y) ? ddec[x][y] : -1;\n\tauto it=lower_bound(rels.begin(),rels.end(),pair<int,int>(x,y));\n\tif(it!=rels.end() && it->fi==x && it->se==y)\n\t\treturn int(it-rels.begin());\n\treturn -1;\n}\n\n\nint sL(int x) { // 0+..+x-1\n\treturn int(1LL*x*(x-1)/2%P);\n}\nint ww(int x) {\n\tstatic bool init=0;\n\tstatic int Z[1<<20];\n\tassert(1<=x && x<(1<<20));\n\tif(!init) {\n\t\tinit=1;\n\t\tassert(!sL(0) && !sL(1));\n\t\tfor(int i=1;i<(1<<20);i++) {\n\t\t\tZ[i]=sL(i)+Z[i-1];\n\t\t\tif(Z[i]>=P) Z[i]-=P;\n\t\t}\n\t}\n\treturn Z[x];\n}\nint qq(int x,int y) {\n\treturn int((1LL*x*sL(y)+1LL*y*sL(x))%P);\n}\ninline int _w(const pair<int,int> &P) {\n\tif(~P.se) return P.se-P.fi+1;\n\treturn 1;\n}\nint g_same(int w,int h) {\n\t// dbg(\"SS\",w,h);\n\t// dbg(ww(h));\n\treturn int((1LL*w*w%P*ww(h) + 1LL*h*h%P*ww(w))%P);\n}\nint g_same(int w,const pair<int,int> &X,const pair<int,int> &_X) {\n\tif(X==_X) return g_same(w,_w(X));\n\tint d0;\n\tint a= X.fi,b=~ X.se? X.se: X.fi;\n\tint c=_X.fi,d=~_X.se?_X.se:_X.fi;\n\tassert(a<=b && c<=d);\n\tif(b<c) d0=c-b; else\n\tif(d<a) d0=a-d; else\n\tassert(0);\n\tint h1=_w(X);\n\tint h2=_w(_X);\n\n\tll ZZ=d0;\n\tZZ=ZZ*w%P*h1%P*w%P*h2%P;\n\tZZ+=1LL*h1*h2%P*ww(w)*2; //dbg(h1,h2,w,ww(w));\n\tZZ+=1LL*w*w%P*qq(h1,h2);\n\t// dbg(\"HIT\",w,h1,h2,ZZ,d0);\n\treturn int(ZZ%P);\n}\ninline int close(const pair<int,int> &X,int x) {\n\tif(!~X.se) return X.fi;\n\tif(x<X.fi) return X.fi;\n\tif(x>X.se) return X.se;\n\tassert(0);\n}\nint g(const pair<int,int> &X,const pair<int,int> &Y,\n\tconst pair<int,int> &_X,const pair<int,int> &_Y) {\n\n\tif(X==_X && Y==_Y && !~X.se && !~Y.se) return 0;\n\n\tif(X==_X && ~X.se) return g_same(_w(X),Y,_Y);\n\tif(Y==_Y && ~Y.se) return g_same(_w(Y),X,_X);\n\n\tint  Cx=_w(X);\n\tint  Cy=_w(Y);\n\tint _Cx=_w(_X);\n\tint _Cy=_w(_Y);\n\tint CCx=int(1LL*Cx*_Cx%P);\n\tint CCy=int(1LL*Cy*_Cy%P);\n\n\tint u=dec(close(X,_X.fi),close(Y,_Y.fi)); assert(~u);\n\tint v=dec(close(_X,X.fi),close(_Y,Y.fi)); assert(~v);\n\n\tll ZZ=D[u][v]; assert(ZZ<inf);\n\n\tZZ=ZZ*CCx%P*CCy;\n\t// dbg(C,_C,ZZ,ZZ%P);\n\n\tZZ+=1LL*CCx*qq(Cy,_Cy);\n\tZZ+=1LL*CCy*qq(Cx,_Cx);\n\n\t// dbg(ZZ,ZZ%P);\n\n\treturn int(ZZ%P);\n}\n\n\ntemplate<class T> struct PQ {\n\tint n=0;\n\tT A[N*4];\n\tvoid push(const T &x) {\n\t\tint i=++n;\n\t\tA[i]=x;\n\t\tfor(;i>1 && A[i>>1]<A[i];) swap(A[i>>1],A[i]), i>>=1;\n\t}\n\tT top() const { return A[1]; }\n\tvoid pop() {\n\t\tassert(n>=1);\n\t\tif(n>1) swap(A[1],A[n]);\n\t\tn--;\n\t\tint i=1;\n\t\tfor(;;) {\n\t\t\tint j=i<<1;\n\t\t\tif(j>n) break;\n\t\t\tif(j==n) {\n\t\t\t\tif(A[j]>A[i]) swap(A[j],A[i]);\n\t\t\t\tbreak;\n\t\t\t}\n\t\t\tif(A[j+1]>A[j]) ++j;\n\t\t\tif(A[j]>A[i]) swap(A[j],A[i]);\n\t\t\telse break;\n\t\t\ti=j;\n\t\t}\n\t}\n\tint size() const {\n\t\treturn n;\n\t}\n};\n// PQ<pair<int,int> > pq;\n// priority_queue<pair<int,int> > pq;\n// queue<pair<int,int> > pq;\nint pq[8<<20];\nbool inq[N];\n#define top front\n\nvoid dijk(int src,int *DD) {\n\t// for(int u=0;u<n;u++) DD[u]=inf;\n\t// for(int u=0;u<=src;u++) DD[u]=D[u][src], pq.push({-DD[u],u});\n\t// for(int u=src+1;u<n;u++) DD[u]=inf;\n\t// if(src) for(int u=src+1;u<n;u++) DD[u]=D[src-1][u]+DD[src-1], pq.push({-DD[u],u});\n\tint pn=0;\n\tfor(int u=0;u<=src;u++) DD[u]=D[u][src], pq[pn++]=u;\n\tfor(int u=src+1;u<n;u++) DD[u]=inf;\n\tif(src) for(int u=src+1;u<n;u++) DD[u]=D[src-1][u]+DD[src-1], pq[pn++]=u;\n\n\tint ii=0;\n\tfor(int i=0;i<n;i++) inq[i]=0;\n\tfor(int i=0;i<pn;i++) inq[pq[i]]=1;\n\t// DD[src]=0;\n\t// pq.push({0,src});\n\t// for(;sz(pq);) {\n\tfor(;ii<pn;) {\n\t\t// auto P=pq.top();\n\t\t// int u=P.se;\n\t\t// int d=-P.fi;\n\t\t// pq.pop();\n\t\t// if(DD[u]<d) continue;\n\t\tint u=pq[ii++];\n\t\tinq[u]=0;\n\t\tint d=DD[u];\n\t\tfor(const auto &P:adj[u]) if(d+P.se<DD[P.fi]) {\n\t\t\tDD[P.fi]=d+P.se;\n\t\t\t// pq.push({-DD[P.fi],P.fi});\n\t\t\tif(!inq[P.fi]) pq[pn++]=P.fi;\n\t\t}\n\t}\n}\n\n\nint32_t main() {\n\t// for(int i=1;i<6;i++) dbg(i,ww(i));\n\tcin>>H>>W>>n;\n\tfor(int i=0;i<n;i++) {\n\t\tint32_t x,y; cin>>x>>y;\n\t\tbads.insert({x,y});\n\t\tbx.insert(x), by.insert(y);\n\t}\n\tfor(int _x:bx) for(int x=_x-1;x<=_x+1;x++)\n\t\tif(!sz(relx) || x>relx.back()) if(0<=x && x<H)\n\t\t\trelx.pb(x);\n\tfor(int _y:by) for(int y=_y-1;y<=_y+1;y++)\n\t\tif(!sz(rely) || y>rely.back()) if(0<=y && y<W)\n\t\t\trely.pb(y);\n\n\tfor(int x:relx) for(int y:rely) if(!bads.count({x,y})) rels.pb({x,y});\n\tsort(rels.begin(),rels.end());\n\tn=sz(rels);\n\tassert(n<N);\n\tfor(int i=0;i<n;i++) ddec[rels[i].fi][rels[i].se]=i;\n\n\tfor(int i=1;i<sz(relx);i++) for(int y:rely) {\n\t\tint u=dec(relx[i-1],y);\n\t\tint v=dec(relx[i],y);\n\t\tint d=relx[i]-relx[i-1];\n\t\tif(~u && ~v) {\n\t\t\tadj[u].pb({v,d});\n\t\t\tadj[v].pb({u,d});\n\t\t}\n\t}\n\tfor(int i=1;i<sz(rely);i++) for(int x:relx) {\n\t\tint u=dec(x,rely[i-1]);\n\t\tint v=dec(x,rely[i]);\n\t\tint d=rely[i]-rely[i-1];\n\t\tif(~u && ~v) {\n\t\t\tadj[u].pb({v,d});\n\t\t\tadj[v].pb({u,d});\n\t\t}\n\t}\n\n\tfor(int i=0;i<n;i++) dijk(i,D[i]);\n\t// for(int i=0;i<n;i++) for(int j=0;j<n;j++) dbg(rels[i],rels[j],D[i][j]);\n\n\t{\n\t\tint pr=-1;\n\t\tfor(int x:bx) {\n\t\t\tif(x-1>pr) bandx.pb({pr+1,x-1});\n\t\t\tbandx.pb({x,-1});\n\t\t\tpr=x;\n\t\t}\n\t\tif(H-1>pr) bandx.pb({pr+1,H-1});\n\t}\n\t{\n\t\tint pr=-1;\n\t\tfor(int y:by) {\n\t\t\tif(y-1>pr) bandy.pb({pr+1,y-1});\n\t\t\tbandy.pb({y,-1});\n\t\t\tpr=y;\n\t\t}\n\t\tif(W-1>pr) bandy.pb({pr+1,W-1});\n\t}\n\n\tassert(sz(bandx)<=61 && sz(bandy)<=61);\n\n\tll Z=0;\n\tfor(const auto &BX:bandx) for(const auto &BY:bandy) {\n\t\tif(bads.count({BX.fi,BY.fi})) continue;\n\t\tfor(const auto &_BX:bandx) for(const auto &_BY:bandy) {\n\t\t\tif(BX>_BX) continue;\n\t\t\tif(BX==_BX && BY>_BY) continue;\n\t\t\tif(!~_BX.se && !~_BY.se && bads.count({_BX.fi,_BY.fi})) continue;\n\t\t\tint w=g(BX,BY,_BX,_BY);\n\t\t\tZ+=w;\n\t\t}\n\t}\n\tcout<<int32_t(Z%P)<<endl;\n}\n\n\n\n\n\n\n\n\n\n\n\n"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\n#define fi first\n#define se second\n#define rep(i,n) for(int i = 0; i < (n); ++i)\n#define rrep(i,n) for(int i = 1; i <= (n); ++i)\n#define drep(i,n) for(int i = (n)-1; i >= 0; --i)\n#define srep(i,s,t) for (int i = s; i < t; ++i)\n#define each(it,c) for(__typeof((c).begin()) it=(c).begin();it!=(c).end();it++)\n#define rng(a) a.begin(),a.end()\n#define maxs(x,y) x = max(x,y)\n#define mins(x,y) x = min(x,y)\n#define pb push_back\n#define sz(x) (int)(x).size()\n#define pcnt __builtin_popcountll\n#define uni(x) x.erase(unique(rng(x)),x.end())\n#define snuke srand((unsigned)clock()+(unsigned)time(NULL));\n#define df(x) int x = in()\n#define dame { puts(\"-1\"); return 0;}\n#define show(x) cout<<#x<<\" = \"<<x<<endl;\n#define PQ(T) priority_queue<T,vector<T>,greater<T> >\n#define bn(x) ((1<<x)-1)\n#define newline puts(\"\")\n#define v(T) vector<T>\n#define vv(T) vector<vector<T>>\nusing namespace std;\ntypedef long long int ll;\ntypedef unsigned uint;\ntypedef unsigned long long ull;\ntypedef pair<int,int> P;\ntypedef vector<int> vi;\ntypedef vector<vi> vvi;\ntypedef vector<ll> vl;\ntypedef vector<vl> vvl;\ntypedef vector<P> vp;\ninline int in() { int x; scanf(\"%d\",&x); return x;}\ninline void priv(vi a) { rep(i,sz(a)) printf(\"%d%c\",a[i],i==sz(a)-1?'\\n':' ');}\ntemplate<typename T>inline istream& operator>>(istream&i,vector<T>&v)\n{rep(j,sz(v))i>>v[j];return i;}\ntemplate<typename T>string join(const vector<T>&v)\n{stringstream s;rep(i,sz(v))s<<' '<<v[i];return s.str().substr(1);}\ntemplate<typename T>inline ostream& operator<<(ostream&o,const vector<T>&v)\n{if(sz(v))o<<join(v);return o;}\ntemplate<typename T1,typename T2>inline istream& operator>>(istream&i,pair<T1,T2>&v)\n{return i>>v.fi>>v.se;}\ntemplate<typename T1,typename T2>inline ostream& operator<<(ostream&o,const pair<T1,T2>&v)\n{return o<<v.fi<<\",\"<<v.se;}\nconst int MX = 200005, INF = 1001001001;\nconst ll LINF = 1e18;\nconst double eps = 1e-10;\nconst int di[] = {-1,0,1,0}, dj[] = {0,-1,0,1}; //^<v>\n\n// Mod int\nconst int mod = 1000000007;\nstruct mint {\n  ll x;\n  mint():x(0){}\n  mint(ll x):x((x%mod+mod)%mod){}\n  // mint(ll x):x(x){}\n  mint& fix() { x = (x%mod+mod)%mod; return *this;}\n  mint& operator+=(const mint& a){ if((x+=a.x)>=mod) x-=mod; return *this;}\n  mint& operator-=(const mint& a){ if((x+=mod-a.x)>=mod) x-=mod; return *this;}\n  mint& operator*=(const mint& a){ (x*=a.x)%=mod; return *this;}\n  mint operator+(const mint& a)const{ return mint(*this) += a;}\n  mint operator-(const mint& a)const{ return mint(*this) -= a;}\n  mint operator*(const mint& a)const{ return mint(*this) *= a;}\n  bool operator<(const mint& a)const{ return x < a.x;}\n  bool operator==(const mint& a)const{ return x == a.x;}\n};\nistream& operator>>(istream&i,mint&a){i>>a.x;return i;}\nostream& operator<<(ostream&o,const mint&a){o<<a.x;return o;}\ntypedef vector<mint> vm;\n//\n\n// coordinate compression\nstruct X {\n  typedef int T;\n  vector<T> d;\n  X() {}\n  void add(T x) { d.pb(x);}\n  void init() {\n    sort(rng(d));\n    d.erase(unique(rng(d)), d.end());\n  }\n  int size() const { return sz(d);}\n  T operator[](int i) const { return d[i];}\n  int operator()(T x) const { return upper_bound(rng(d),x)-d.begin()-1;}\n};\n//\n\nint H, W;\nX xs, ys;\nvoid initXY(vp& a) {\n  xs.add(0); xs.add(H);\n  ys.add(0); ys.add(W);\n  rep(i,2) for (P p : a) {\n    xs.add(p.fi+i);\n    ys.add(p.se+i);\n  }\n  xs.init(); ys.init();\n  for (P& p : a) p.fi = xs(p.fi), p.se = ys(p.se);\n}\n\n\n\nint main() {\n  int n;\n  scanf(\"%d%d%d\",&H,&W,&n);\n  vp p(n);\n  cin>>p;\n  initXY(p);\n  int h = sz(xs)-1, w = sz(ys)-1;\n  vvl a(h,vl(w));\n  rep(i,h)rep(j,w) {\n    ll dx = xs[i+1]-xs[i];\n    ll dy = ys[j+1]-ys[j];\n    a[i][j] = dx*dy;\n  }\n  mint ans = 0;\n  rep(i,n) a[p[i].fi][p[i].se] = -1;\n  rep(si,h)rep(sj,w) if (a[si][sj] != -1) {\n    vvi dist(h,vi(w,INF));\n    queue<P> q;\n    q.push(P(si,sj)); dist[si][sj] = 0;\n    while (sz(q)) {\n      int i = q.front().fi, j = q.front().se; q.pop();\n      if (P(i,j) < P(si,sj)) ans += mint(a[si][sj])*a[i][j]*dist[i][j];\n      rep(v,4) {\n        int ni = i+di[v], nj = j+dj[v];\n        if (ni<0||nj<0||ni>=h||nj>=w) continue;\n        if (a[ni][nj] == -1) continue;\n        if (dist[ni][nj] != INF) continue;\n        dist[ni][nj] = dist[i][j]+1;\n        q.push(P(ni,nj));\n      }\n    }\n  }\n  vi x(H+1), y(W+1);\n  rep(i,h) x[xs[i]] = 1;\n  rep(i,w) y[ys[i]] = 1;\n  vi xc(H), yc(W);\n  rep(i,n) xc[xs[p[i].fi]]++;\n  rep(i,n) yc[ys[p[i].se]]++;\n  int cnt = 0;\n  rep(i,H) {\n    cnt += xc[i];\n    if (x[i]) continue;\n    ans += mint((ll)W*i-cnt)*((ll)W*(H-i)-(n-cnt));\n  }\n  cnt = 0;\n  rep(i,W) {\n    cnt += yc[i];\n    if (y[i]) continue;\n    ans += mint((ll)H*i-cnt)*((ll)H*(W-i)-(n-cnt));\n  }\n  cout<<ans<<endl;\n  return 0;\n}\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n"
  },
  {
    "language": "C++",
    "code": "#include <iostream>\n#include <iomanip>\n#include <cstdio>\n#include <cstdlib>\n#include <cstring>\n#include <cassert>\n#include <algorithm>\n#include <numeric>\n#include <random>\n#include <vector>\n#include <array>\n#include <bitset>\n#include <queue>\n#include <set>\n#include <unordered_set>\n#include <map>\n#include <unordered_map>\n\nusing namespace std;\nusing uint = unsigned int;\nusing ll = long long;\nusing ull = unsigned long long;\ntemplate<class T> using V = vector<T>;\ntemplate<class T> using VV = V<V<T>>;\nconstexpr ll TEN(int n) { return (n==0) ? 1 : 10*TEN(n-1); }\nint bsr(uint x) { return 31 - __builtin_clz(x); }\nint bsr(ull x) { return 63 - __builtin_clzll(x); }\nint bsf(uint x) { return __builtin_ctz(x); }\nint bsf(ull x) { return __builtin_ctzll(x); }\n\ntemplate<class T>\nT pow(T x, ll n, T r = 1) {\n    while (n) {\n        if (n & 1) r *= x;\n        x *= x;\n        n >>= 1;\n    }\n    return r;\n}\n\ntemplate<uint MD>\nstruct ModInt {\n    uint v;\n    ModInt() : v{0} {}\n    ModInt(ll v) : v{normS(v%MD+MD)} {}\n    explicit operator bool() const {return v != 0;}\n    static uint normS(const uint &x) {return (x<MD)?x:x-MD;};\n    static ModInt make(const uint &x) {ModInt m; m.v = x; return m;}\n    static ModInt inv(const ModInt &x) {return pow(ModInt(x), MD-2);} \n    ModInt operator+(const ModInt &r) const {return make(normS(v+r.v));}\n    ModInt operator-(const ModInt &r) const {return make(normS(v+MD-r.v));}\n    ModInt operator*(const ModInt &r) const {return make((ull)v*r.v%MD);}\n    ModInt operator/(const ModInt &r) const {return *this*inv(r);}\n    ModInt& operator+=(const ModInt &r) {return *this=*this+r;}\n    ModInt& operator-=(const ModInt &r) {return *this=*this-r;}\n    ModInt& operator*=(const ModInt &r) {return *this=*this*r;}\n    ModInt& operator/=(const ModInt &r) {return *this=*this/r;}\n};\ntemplate<uint MD> string to_string(ModInt<MD> m) {return to_string(m.v);}\nusing Mint = ModInt<TEN(9)+7>;\n\nconst int d4[4][2] = {\n    {1, 0},\n    {0, 1},\n    {-1, 0},\n    {0, -1},\n};\n\nusing P = array<int, 2>;\n\nconst int MN = 1000;\nint h, w;\nbool g[MN][MN];\nMint wei[MN][MN];\n\nbool used[MN][MN];\nint dist[MN][MN];\nMint calc(int sx, int sy) {\n    if (g[sy][sx]) return Mint(0);\n    //init\n    for (int i = 0; i < h; i++) {\n        for (int j = 0; j < w; j++) {\n            used[i][j] = false;\n            dist[i][j] = TEN(9);\n        }\n    }\n\n    queue<P> q;\n    q.push(P{sx, sy});\n    dist[sy][sx] = 0;\n    Mint sm = 0;\n    while (q.size()) {\n        P p = q.front(); q.pop();\n        int x = p[0], y = p[1];\n        if (used[y][x]) continue;\n        used[y][x] = true;\n        sm += wei[y][x] * dist[y][x];\n        for (int i = 0; i < 4; i++) {\n            int nx = x + d4[i][0], ny = y + d4[i][1];\n            if (!(0 <= nx && nx < w && 0 <= ny && ny < h)) continue;\n            if (g[ny][nx]) continue;\n            if (used[ny][nx]) continue;\n            if (dist[ny][nx] <= dist[y][x]+1) continue;\n            dist[ny][nx] = dist[y][x]+1;\n            q.push(P{nx, ny});\n        }\n    }\n    return sm * wei[sy][sx];\n}\n\nMint C(Mint l, Mint r, Mint h, Mint w) {\n    Mint sm = 0;\n    sm += (l*r+l*w*h)*(w-1);\n    sm += (r*h-l*h+w*h*h)*w*(w-1)/2;\n    sm -= h*h*(w-1)*w*(w*2-1)/6;\n    return sm;\n}\n\nMint calc(V<int> di) {\n    int n = int(di.size()) - 1;\n    Mint sm = 0;\n    Mint a = 0, b = Mint(di.back());\n    for (int i = 0; i < n; i++) {\n        Mint w = Mint(di[i+1]-di[i]);\n        b -= w;\n        sm += C(a, b, 1, w);\n        a += w;\n    }\n    return sm;\n}\nint main() {\n    int fh, fw;\n    cin >> fh >> fw;\n    int n;\n    cin >> n;\n    V<int> xv, yv;\n    V<P> points;\n    for (int i = 0; i < n; i++) {\n        int y, x;\n        cin >> y >> x;\n        xv.push_back(x); xv.push_back(x+1);\n        yv.push_back(y); yv.push_back(y+1);\n        points.push_back(P{x, y});\n    }\n    xv.push_back(0); yv.push_back(0);\n    xv.push_back(fw); yv.push_back(fh);\n    sort(begin(xv), end(xv));\n    sort(begin(yv), end(yv));\n    xv.erase(unique(begin(xv), end(xv)), end(xv));\n    yv.erase(unique(begin(yv), end(yv)), end(yv));\n    \n    h = int(yv.size())-1;\n    w = int(xv.size())-1;\n    for (auto p: points) {\n        int x = lower_bound(begin(xv), end(xv), p[0]) - begin(xv);\n        int y = lower_bound(begin(yv), end(yv), p[1]) - begin(yv);\n        g[y][x] = true;\n    }\n    for (int y = 0; y < h; y++) {\n        for (int x = 0; x < w; x++) {\n            wei[y][x] = Mint(xv[x+1]-xv[x]) * Mint(yv[y+1]-yv[y]);\n        }\n    }\n\n    Mint sm = 0;\n    {\n        Mint l = 0, r = Mint(fh)*Mint(fw)-Mint(n);\n        for (int i = 0; i < w; i++) {\n            Mint nw = xv[i+1]-xv[i];\n            Mint ws = Mint(nw)*Mint(fh);\n            for (int j = 0; j < h; j++) {\n                if (g[j][i]) ws -= Mint(1);\n            }\n            r -= ws;\n            sm += C(l, r, fh, nw);\n            l += ws;\n        }\n    }\n    {\n        Mint l = 0, r = Mint(fh)*Mint(fw)-Mint(n);\n        for (int i = 0; i < h; i++) {\n            Mint nw = yv[i+1]-yv[i];\n            Mint ws = Mint(nw)*Mint(fw);\n            for (int j = 0; j < w; j++) {\n                if (g[i][j]) ws -= Mint(1);\n            }\n            r -= ws;\n            sm += C(l, r, fw, nw);\n            l += ws;\n        }\n    }\n    for (int y = 0; y < h; y++) {\n        for (int x = 0; x < w; x++) {\n            sm += calc(x, y)/2;\n        }\n    }\n    cout << sm.v << endl;\n    return 0;\n}\n\n"
  },
  {
    "language": "C++",
    "code": "#include <cstring>\n#include <cstdio>\nusing ll = long long;\nconstexpr int MOD = 1e9 + 7;\nconstexpr int dx[] = {1, -1, 0, 0}, dy[] = {0, 0, 1, -1};\nint app_x[1000005], app_y[1000005], idx_x[1000005], idx_y[1000005];\nint px[65], py[65], dis[65][65], que[100005], sz_x[65], sz_y[65], ans;\nbool vis[65][65];\nvoid compress(int n, int m, int k, int *app, int *idx, int *sz)\n{\n\tsz[0] = 1;\n\tint u = m - app[0], d = ((ll)n * m - k - u) % MOD;\n\tfor (int i = 1; i < n; i++)\n\t{\n\t\tidx[i] = idx[i - 1];\n\t\tif (!app[i] && !app[i - 1])\n\t\t\tans = (ans + (ll)2 * u * d) % MOD;\n\t\telse\n\t\t\tidx[i]++;\n\t\tsz[idx[i]]++;\n\t\tu = (u + m - app[i]) % MOD;\n\t\td = (d + app[i] - m + MOD) % MOD;\n\t}\n}\ninline int calc(int x, int y) { return (ll)sz_x[x] * sz_y[y] % MOD; }\ninline void bfs(int n, int m, int sx, int sy)\n{\n\tmemset(dis, 0x3f, sizeof(dis));\n\tint he = 0, ta = 0;\n\tque[ta++] = sx;\n\tque[ta++] = sy;\n\tvis[sx][sy] = true;\n\tdis[sx][sy] = 0;\n\twhile (he < ta)\n\t{\n\t\tint x = que[he++], y = que[he++];\n\t\tans = (ans + (ll)calc(x, y) * calc(sx, sy) % MOD * dis[x][y]) % MOD;\n\t\tfor (int i = 0; i < 4; i++)\n\t\t{\n\t\t\tint xx = x + dx[i], yy = y + dy[i];\n\t\t\tif (xx < 0 || xx >= n || yy < 0 || yy >= m)\n\t\t\t\tcontinue;\n\t\t\tif (!vis[xx][yy] && dis[xx][yy] > 1e9)\n\t\t\t{\n\t\t\t\tdis[xx][yy] = dis[x][y] + 1;\n\t\t\t\tvis[xx][yy] = true;\n\t\t\t\tque[ta++] = xx;\n\t\t\t\tque[ta++] = yy;\n\t\t\t}\n\t\t}\n\t}\n}\nint main()\n{\n\t// freopen(\"J.in\", \"r\", stdin);\n\tint n, m, k;\n\tscanf(\"%d%d%d\", &n, &m, &k);\n\tfor (int i = 0; i < n; i++)\n\t{\n\t\tscanf(\"%d%d\", px + i, py + i);\n\t\tapp_x[px[i]]++;\n\t\tapp_y[py[i]]++;\n\t}\n\tcompress(n, m, k, app_x, idx_x, sz_x);\n\tcompress(m, n, k, app_y, idx_y, sz_y);\n\tfor (int i = 0; i < k; i++)\n\t\tvis[idx_x[px[i]]][idx_y[py[i]]] = true;\n\tfor (int i = 0; i <= idx_x[n - 1]; i++)\n\t{\n\t\tfor (int j = 0; j <= idx_y[m - 1]; j++)\n\t\t{\n\t\t\tif (!vis[i][j])\n\t\t\t\tbfs(idx_x[n - 1] + 1, idx_y[m - 1] + 1, i, j);\n\t\t}\n\t}\n\tprintf(\"%lld\\n\", (ll)ans * (MOD + 1) / 2 % MOD);\n\treturn 0;\n}\n"
  },
  {
    "language": "C++",
    "code": "\n#include<bits/stdc++.h>\nusing namespace std;\n#define DB(x){if(DEBUG)cerr<<__LINE__<<\" \"<<#x<<\" \" <<x<<endl;}\n#define REP(i,b)for(LL i=(0);i<(b);++i)\n#define FOR(i,a,b)for(LL i=(a);i<=(b);++i)\n#define FORD(i,a,b)for(LL i=(a);i>=(b);--i)\n#define ALL(x) (x).begin(),(x).end()\n#define VV vector\ntemplate<typename X,typename Y>void MAX(X&a,Y b){a=(a>=b?a:b);}\ntemplate<typename X,typename Y>void MIN(X&a,Y b){a=(a<=b?a:b);}\ntypedef long long LL;typedef long double LD;\nint DEBUG=0,MULTI=0,GCJ=0;\n\nstruct solver_t;solver_t *solver;\nconst int MOD = 1e9 + 7;\nstruct solver_t {\n  int ROWS = -1, COLS = -1;\n  int IS_BLACK[70][70] = {};\n  LL HEI[70][70] = {};\n  LL WID[70][70] = {};\n\n  LL calculate(LL source_r, LL source_c) {\n    struct pkt_t { LL R = -1, C = -1; LL dst = -1;\n      bool operator < (const pkt_t rhs) const {\n        return dst < rhs.dst;\n      }\n    };\n    DB(source_r<<\" \"<<source_c);\n\n    LL DST[70][70];\n    memset(DST, 0x7f, sizeof(DST));\n\n    multiset <pkt_t> KOL;\n    DST[source_r][source_c] = 0;\n    KOL.insert({source_r, source_c, 0});\n    while (KOL.size() > 0) {\n      auto front = KOL.begin();\n      auto top = *front;\n      KOL.erase(front);\n      if (DST[top.R][top.C] != top.dst) continue;\n\n      FOR (dr, -1, 1) FOR (dc, -1, 1) if (abs(dr) + abs(dc) == 1) {\n        if (dr) {\n          int next_r = top.R + dr;\n          int next_c = top.C;\n          if (!(next_r >=0 && next_r < ROWS)) continue;\n          if (IS_BLACK[next_r][next_c]) continue;\n\n          LL diff_dst;\n          if (next_r == source_r || top.R == source_r && top.C == source_c) diff_dst = 1;\n          else diff_dst = HEI[top.R][top.C];\n\n          if (DST[next_r][next_c] > diff_dst + top.dst) {\n            DST[next_r][next_c] = diff_dst + top.dst;\n            KOL.insert( { next_r, next_c, DST[next_r][next_c]} );\n          }\n        }\n        if (dc) {\n\n          int next_r = top.R;\n          int next_c = top.C + dc;\n          if (!(next_c >= 0 && next_c < COLS)) continue;\n          if (IS_BLACK[next_r][next_c]) continue;\n\n          int diff_dst;\n          if (next_c == source_c || top.C == source_c && top.R == source_r) diff_dst = 1;\n          else diff_dst = WID[top.R][top.C];\n\n          if (DST[next_r][next_c] > diff_dst + top.dst) {\n            DST[next_r][next_c] = diff_dst + top.dst;\n            KOL.insert( { next_r, next_c, DST[next_r][next_c]} );\n          }\n        }\n      }\n    }\n\n\n\n    auto power=[](LL a, LL b) {\n      LL res = 1;\n      while (b) {\n        if (b&1) res=(res*a)%MOD;\n        b/=2; a=(a*a)%MOD;\n      }\n      return res;\n    };\n    LL rev3 = power(3, MOD - 2);\n    LL rev2 = power(2, MOD - 2);\n    LL res = 0;\n    REP (r, ROWS) REP (c, COLS) if (IS_BLACK[r][c] == 0) {\n      DB(source_r<<\" \"<<source_c<<\" \"<<r<<\" \"<<c<<\" \"<<DST[r][c]);\n      pair<int,int> V1(source_r, source_c);\n      pair<int,int> V2(r, c);\n      //if (!(V1 <= V2)) continue;\n\n      res += DST[r][c] % MOD * HEI[r][c] % MOD * WID[r][c] % MOD *\n             HEI[source_r][source_c] % MOD * WID[source_r][source_c] % MOD;\n      res %= MOD;\n\n      auto oblicz=[&](LL wid) {\n        LL N = wid + 1;\n        if (N < 3) return 0LL;\n        LL res = ((N * (N-1) % MOD) *(N-2)) % MOD;\n        res = (res * rev3) % MOD;\n\n        return res;\n      };\n      DB(oblicz(0));\n      DB(oblicz(1));\n      DB(oblicz(2));\n      DB(oblicz(3));\n      DB(oblicz(4));\n      DB(oblicz(5));\n      DB(oblicz(10));\n\n      auto oblicz2=[&](LL wid1,LL wid2) {\n        LL p1 = (wid1 - 1)  % MOD * wid1 % MOD * rev2 % MOD * wid2;\n        LL p2 = (wid2 - 1)  % MOD* wid2 % MOD * rev2 % MOD * wid1;\n        return (p1 + p2) % MOD;\n      };\n\n      if (source_r == r) {\n        LL hei = HEI[r][c];\n        assert(HEI[r][c] == HEI[source_r][source_c]);\n\n        LL tmp = oblicz(hei) % MOD;\n        tmp = (tmp * WID[r][c] % MOD * WID[source_r][source_c]) % MOD;\n\n        res += tmp;\n      }\n      else {\n        LL tmp = oblicz2(HEI[r][c], HEI[source_r][source_c]) % MOD;\n        tmp = (tmp * WID[r][c] % MOD * WID[source_r][source_c]) % MOD;\n        res += tmp;\n      }\n      if (source_c == c) {\n        int wid = WID[r][c];\n        assert(WID[r][c] == WID[source_r][source_c]);\n        LL tmp = oblicz(wid) % MOD;\n        tmp = (tmp * HEI[r][c] % MOD * HEI[source_r][source_c]) % MOD;\n\n        res += tmp;\n      }\n      else {\n        LL tmp = oblicz2(WID[r][c], WID[source_r][source_c]) % MOD;\n\n        tmp = (tmp * HEI[r][c] % MOD * HEI[source_r][source_c]) % MOD;\n        res += tmp;\n      }\n      res %= MOD;\n    }\n\n    return res;\n  }\n\n\n  void solve() {\n    int H, W;cin >>H>>W;\n    int N; cin >> N;\n\n    VV<int> CORD_R;\n    VV<int> CORD_C;\n\n    VV<array<int,2> > BLACK;\n    REP (i, N) {\n      int r, c;\n      cin >> r >> c;\n      BLACK.push_back({r,c});\n      CORD_R.push_back(r);\n      CORD_R.push_back(r + 1);\n\n      CORD_C.push_back(c);\n      CORD_C.push_back(c + 1);\n    }\n    CORD_R.push_back(0);\n    CORD_R.push_back(H);\n\n    CORD_C.push_back(0);\n    CORD_C.push_back(W);\n\n    sort( ALL(CORD_R) ); CORD_R.erase(unique(ALL(CORD_R)), CORD_R.end());\n    sort( ALL(CORD_C) ); CORD_C.erase(unique(ALL(CORD_C)), CORD_C.end());\n\n    for (int cr : CORD_R) DB(cr);\n    for (int cc : CORD_C) DB(cc);\n\n\n    ROWS = CORD_R.size() - 1;\n    COLS = CORD_C.size() - 1;\n\n    for (auto black : BLACK) {\n      int r = lower_bound(ALL(CORD_R), black[0]) - CORD_R.begin();\n      int c = lower_bound(ALL(CORD_C), black[1]) - CORD_C.begin();\n      IS_BLACK[r][c] = 1;\n    }\n    REP (r, ROWS) REP (c, COLS) {\n      HEI[r][c] = CORD_R[r + 1] - CORD_R[r];\n      WID[r][c] = CORD_C[c + 1] - CORD_C[c];\n    }\n\n\n    LL res = 0;\n    auto power=[](LL a, LL b) {\n      LL res = 1;\n      while (b) {\n        if (b&1) res=(res*a)%MOD;\n        b/=2; a=(a*a)%MOD;\n      }\n      return res;\n    };\n    LL rev2 = power(2, MOD - 2);\n    REP (r, ROWS) REP (c, COLS) if (IS_BLACK[r][c] == 0) {\n      res += calculate(r, c);\n      res %= MOD;\n    }\n    cout << ((res * rev2) % MOD +MOD)%MOD << \"\\n\";\n  }\n\n\n  void gen() {}\n  void brute() {}\n};\n\n#undef int\nint main(int argc,char** argv){\n  FOR(i,1,argc-1)for(int j=0;argv[i][j];j++)if(argv[i][j]=='.')freopen(argv[i],\"r\",stdin);\n  FOR(i,1,argc-1)if(argv[i]==string(\"q\"))DEBUG=1<<30;\n  FOR(i,1,argc-1)if(argv[i]==string(\"gen\")){(solver=new solver_t())->gen();exit(0);}\n  FOR(i,1,argc-1)if(argv[i]==string(\"brute\")){(solver=new solver_t())->brute();exit(0);}\n  ios::sync_with_stdio(false),cin.tie(0);\n  cout.setf(ios::fixed),cout.precision(10);int t;if(MULTI||GCJ)cin>>t;else t=1;\n  FOR(i,1,t){if(DEBUG)cerr<<__LINE__<<\" \"<<i<<endl;if(GCJ)cout<<\"Case #\"<<i<<\": \";\n    solver = new solver_t();\n    solver->solve();\n  }return 0;\n}\n\n"
  },
  {
    "language": "C++",
    "code": "#include<bits/stdc++.h>\n#define il inline\n#define RG register\n#define ll long long\n#define rhl (1000000007)\n#define N (1000005)\n#define lower_bound lb\nusing namespace std;\n\nstruct data{\n\tint x,y;\n}a[35];\nconst int dx[4]={1,0,-1,0},dy[4]={0,1,0,-1};\nint cnt[65][65],can[65][65],dis[65][65],ans;\nint sx[N],sy[N],covx[N],covy[N],n,m,k,lx,ly;\nqueue<pair<int,int> > Q;\nvector<int> px,py;\n\nil int gi(){\n\tRG int x=0;RG char ch=getchar();\n\tRG bool q=1;\n\twhile((ch<'0'||ch>'9')&& ch!='-')\n\tch=getchar();\n\tif (ch=='-')q=!q,ch=getchar();\n\twhile(ch>='0'&&ch<='9')\n\tx=x*10+ch-'0',ch=getchar();\n\treturn (q)?x:-x;;\n}\n\nil void bfs(RG int sx,RG int sy){\n\tmemset(dis,0,sizeof(dis));\n\tdis[sx][sy]=1,Q.push(make_pair(sx,sy));\n\twhile(!Q.empty()){\n\t\tpair<int,int>now=Q.front();\n\t\tQ.pop();\n\t\tfor(RG int i=0,x,y;i<4;++i){\n\t\t\tint a=now.first,b=now.second;\n\t\t\tx=a+dx[i];\n\t\t\ty=b+dy[i];\n\t\t\tif(x<0||x>lx||y<0||y>ly||\n\t\t\tdis[x][y]||can[x][y])continue;\n\t\t\tdis[x][y]=dis[a][b]+1;\n\t\t\tQ.push(make_pair(x,y));\n\t\t\tint c=1LL*cnt[sx][sy]*cnt[x][y];\n\t\t\tans+=c%rhl*(dis[x][y]-1))%rhl;\n\t\t}\n\t}\n\treturn;\n}\n\nint main(){\n\tn=gi(),m=gi(),k=gi();\n\tpx.push_back(1),px.push_back(n+1);\n\tpy.push_back(1),py.push_back(m+1);\n\tfor(RG int i=1;i<=n;++i)sx[i]=m;\n\tfor(RG int i=1;i<=m;++i)sy[i]=n;\n\tfor(RG int i=1;i<=k;++i){\n\t\tpx.push_back(a[i].x=gi()+1);\n\t\tpx.push_back(a[i].x+1);\n\t\tpy.push_back(a[i].y=gi()+1);\n\t\tpy.push_back(a[i].y+1);\n\t\t--sx[a[i].x],--sy[a[i].y];\n\t\tcovx[a[i].x]=covy[a[i].y]=1;\n\t}\n\tfor(RG int i=1;i<=n;++i)\n\t(sx[i]+=sx[i-1])%=rhl;\n\tfor(RG int i=1;i<=m;++i)\n\t(sy[i]+=sy[i-1])%=rhl;\n\tfor (RG int i=1;i<n;++i)\n\tif(!covx[i]&&!covx[i+1])\n\tans=(ans+2LL*sx[i]*(sx[n]-sx[i]))%rhl;\n\tfor (RG int i=1;i<m;++i)\n\tif(!covy[i]&&!covy[i+1])\n\tans=(ans+2LL*sy[i]*(sy[m]-sy[i]))%rhl;\n\tint*it1=px.end(),*it2=py.end();\n\tsort(px.begin(),it1);\n\tpx.erase(unique(px.begin(),it1);it1);\n\tlx=px.size()-2;\n\tsort(py.begin(),it2);\n\tpy.erase(unique(py.begin(),it2),it2);\n\tly=py.size()-2;\n\tfor (RG int i=1;i<=k;++i){\n\t\ta[i].x=lb(px.begin(),it1,a[i].x);\n\t\ta[i].x-=px.begin();\n\t\ta[i].y=lb(py.begin(),it2,a[i].y);\n\t\ta[i].y-=py.begin();\n\t\tcan[a[i].x][a[i].y]=1;\n\t}\n\tfor(RG int i=0;i<=lx;++i){\n\t\tfor(RG int j=0;j<=ly;++j){\n\t\t\tint x=px[i+1]-px[i];\n\t\t\tint y=py[j+1]-py[j];\n\t\t\tcnt[i][j]=1LL*x*y%rhl;\n\t\t}\n\t}\n\tfor(RG int i=0;i<=lx;++i){\n\t\tfor(RG int j=0;j<=ly;++j){\n\t\t\tif(!can[i][j])bfs(i,j);\n\t\t}\n\t}\n\tcout<<1LL*(ans+rhl)*(rhl/2+1)%rhl<<\"\\n\";\n\treturn 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include<bits/stdc++.h>\nusing namespace std;\n\nconst int maxn=75;\nconst int maxm=4005;\nconst int maxs=1000005;\nconst int mod=1e9+7;\nconst int INF=0x3f3f3f3f;\nint n,m,k,kx,ky,cnt,tot,ans;\nint x[maxn],y[maxn],allx[maxn],ally[maxn];\npair<int,int>pos[maxm];\nset<pair<int,int> >bad;\nmap<pair<int,int>,int>id;\nvector<int>valr[maxs],valc[maxs];\nvector<pair<int,int> >edge[maxm]; \nint dist[maxm][maxm],ver[maxm];\nbool tmp[maxm];\npriority_queue<pair<int,int> >pq;\n\nvoid add(pair<int,int>p){\n\tif(p.first<1||p.first>n||p.second<1||p.second>m)return;\n\tif(bad.count(p))return;\n\tif(id.count(p))return;\n\tid[p]=++tot;\n\tpos[tot]=p;\n\tvalr[p.first].push_back(p.second);\n\tvalc[p.second].push_back(p.first);\n}\n\nclass Seg{\npublic:\n\tpair<int,int>s,t;\n\tint p;\n\tSeg(){}\n\tSeg(pair<int,int>_s,pair<int,int>_t):s(_s),t(_t){add(t),p=id[t];}\n\tint area()const{return 1LL*(t.first-s.first+1)*(t.second-s.second+1)%mod;}\n\tint calc(const Seg &o)const{\n\t\treturn dist[p][o.p]-abs(pos[p].first-pos[o.p].first)-abs(pos[p].second-pos[o.p].second);\n\t}\n}val[maxm];\n\nvoid dij(int s){\n\twhile(!pq.empty())pq.pop();\n\tfor(int i=1;i<=tot;i++)dist[s][i]=INF;\n\tdist[s][s]=0;\n\tpq.push(make_pair(0,s));\n\twhile(!pq.empty()){\n\t\tint x=pq.top().second,cur=-pq.top().first;\n\t\tpq.pop();\n\t\tif(dist[s][x]!=cur)continue;\n\t\tfor(int i=0;i<int(edge[x].size());i++){\n\t\t\tpair<int,int>y=edge[x][i];\n\t\t\tif(dist[s][y.first]>dist[s][x]+y.second){\n\t\t\t\tdist[s][y.first]=dist[s][x]+y.second;\n\t\t\t\tpq.push(make_pair(-dist[s][y.first],y.first));\n\t\t\t}\n\t\t}\n\t}\n}\n\nint main(){\n\tscanf(\"%d%d%d\",&n,&m,&k);\n\tallx[++kx]=1;\n\tallx[++kx]=n+1;\n\tally[++ky]=1;\n\tally[++ky]=m+1;\n\tfor(int i=1;i<=k;i++){\n\t\tscanf(\"%d%d\",&x[i],&y[i]);\n\t\tx[i]++;y[i]++;\n\t\tallx[++kx]=x[i];\n\t\tallx[++kx]=x[i]+1;\n\t\tally[++ky]=y[i];\n\t\tally[++ky]=y[i]+1;\n\t\tbad.insert(make_pair(x[i],y[i]));\n\t\tvalr[x[i]].push_back(y[i]);\n\t\tvalc[y[i]].push_back(x[i]);\n\t}\n\tfor(int i=1;i<=k;i++)\n\t\tfor(int dx=-1;dx<=1;dx++)for(int dy=-1;dy<=1;dy++)\n\t\t\tadd(make_pair(x[i]+dx,y[i]+dy));\n\tsort(allx+1,allx+1+kx);\n\tsort(ally+1,ally+1+ky);\n\tkx=unique(allx+1,allx+1+kx)-allx-1;\n\tky=unique(ally+1,ally+1+ky)-ally-1;\n\tfor(int i=1;i<kx;i++)for(int j=1;j<ky;j++)if(!bad.count(make_pair(allx[i],ally[j])))\n\t\tval[++cnt]=Seg(make_pair(allx[i],ally[j]),make_pair(allx[i+1]-1,ally[j+1]-1));\n\tlong long sum=0;\n\tfor(int i=1;i<=n;i++){\n\t\tsort(valr[i].begin(),valr[i].end());\n\t\tint cur=0;\n\t\tfor(int j=0;j<int(valr[i].size());j++){\n\t\t\ttmp[j]=bad.count(make_pair(i,valr[i][j]));\n\t\t\tver[j]=id.count(make_pair(i,valr[i][j]))?id[make_pair(i,valr[i][j])]:0;\n\t\t\tcur+=tmp[j];\n\t\t\tif(j>0&&!tmp[j-1]&&!tmp[j])\n\t\t\t\tedge[ver[j-1]].push_back(make_pair(ver[j],valr[i][j]-valr[i][j-1])),\n\t\t\t\tedge[ver[j]].push_back(make_pair(ver[j-1],valr[i][j]-valr[i][j-1]));\n\t\t}\n\t\tcur=m-cur;\n\t\tans=(ans+1LL*(sum-1LL*n*m+k+sum+cur)%mod*i%mod*cur)%mod;\n\t\tsum+=cur;\n\t}\n\tsum=0;\n\tfor(int i=1;i<=m;i++){\n\t\tsort(valc[i].begin(),valc[i].end());\n\t\tint cur=0;\n\t\tfor(int j=0;j<int(valc[i].size());j++){\n\t\t\ttmp[j]=bad.count(make_pair(valc[i][j],i));\n\t\t\tver[j]=id.count(make_pair(valc[i][j],i))?id[make_pair(valc[i][j],i)]:0;\n\t\t\tcur+=tmp[j];\n\t\t\tif(j>0&&!tmp[j-1]&&!tmp[j])\n\t\t\t\tedge[ver[j-1]].push_back(make_pair(ver[j],valc[i][j]-valc[i][j-1])),\n\t\t\t\tedge[ver[j]].push_back(make_pair(ver[j-1],valc[i][j]-valc[i][j-1]));\n\t\t}\n\t\tcur=n-cur;\n\t\tans=(ans+1LL*(sum-1LL*n*m+k+sum+cur)%mod*i%mod*cur)%mod;\n\t\tsum+=cur;\n\t}\n\tans=(ans%mod+mod)%mod;\n\tans=2LL*ans%mod;\n\tfor(int i=1;i<=tot;i++)dij(i);\n\tfor(int i=1;i<=cnt;i++)for(int j=1;j<=cnt;j++)\n\t\tans=(ans+1LL*val[i].calc(val[j])*val[i].area()%mod*val[j].area())%mod;\n\t\t\t//cerr<<val[i].s.first<<\" \"<<val[i].s.second<<\" \"<<val[i].t.first<<\" \"<<val[i].t.second<<endl,\n\t\t\t//cerr<<val[j].s.first<<\" \"<<val[j].s.second<<\" \"<<val[j].t.first<<\" \"<<val[j].t.second<<endl,\n\t\t\t//cerr<<val[i].calc(val[j])<<\" \"<<val[i].p<<\" \"<<val[j].p<<\" \"<<dist[val[i].p][val[j].p]<<endl;\n\tprintf(\"%d\\n\",int(1LL*ans*(mod+1)/2));\n\treturn 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\nusing namespace std;\n\nusing ll = long long;\nusing i128 = __int128_t;\n\nint main(){\n\tios_base::sync_with_stdio(0), cin.tie(0), cout.tie(0);\n\tint A, B;\n\tcin >> A >> B;\n\tint k;\n\tcin >> k;\n\tvector<pair<int,int> > pts(k);\n\tset<int> verts_x, verts_y;\n\tverts_x.insert(0); verts_x.insert(A);\n\tverts_y.insert(0); verts_y.insert(B);\n\tfor(pair<int,int>& p : pts){\n\t\tcin >> p.first >> p.second;\n\t\tfor(int j = -1; j <= 1; j++) if(p.first + j >= 0 && p.first + j <= A) verts_x.insert(p.first + j);\n\t\tfor(int j = -1; j <= 1; j++) if(p.second + j >= 0 && p.second + j <= B) verts_y.insert(p.second + j);\n\t}\n\tvector<int> loc_x, loc_y;\n\tfor(int x : verts_x) loc_x.push_back(x);\n\tfor(int y : verts_y) loc_y.push_back(y);\n\tint num_x = (int)loc_x.size() - 1;\n\tint num_y = (int)loc_y.size() - 1;\n\tvector<vector<bool> > occ(num_x, vector<bool>(num_y, false));\n\tfor(int i = 0; i < num_x; i++){\n\t\tfor(int j = 0; j < num_y; j++){\n\t\t\tfor(pair<int,int> p : pts){\n\t\t\t\tif(loc_x[i] == p.first && loc_y[j] == p.second) occ[i][j] = true;\n\t\t\t}\n\t\t}\n\t}\n\n\ti128 ans = 0;\n\tvector<int> dx = {1, 0, -1, 0};\n\tvector<int> dy = {0, 1, 0, -1};\n\tfor(int x = 0; x < num_x; x++){\n\t\tfor(int y = 0; y < num_y; y++){\n\t\t\tif(occ[x][y]) continue;\n\t\t\tvector<vector<bool> > vis(num_x, vector<bool>(num_y, false));\n\t\t\tvector<vector<int> > dist(num_x, vector<int>(num_y, 1e9));\n\t\t\tvector<pair<int,int> > bfs;\n\t\t\tdist[x][y] = 0;\n\t\t\tbfs.push_back({x, y});\n\t\t\tint s = 0;\n\t\t\twhile(s < (int)bfs.size()){\n\t\t\t\tint cx = bfs[s].first;\n\t\t\t\tint cy = bfs[s].second;\n\t\t\t\ts++;\n\t\t\t\tif(vis[cx][cy]) continue;\n\t\t\t\tvis[cx][cy] = true;\n\t\t\t\tfor(int d = 0; d < 4; d++){\n\t\t\t\t\tint nx = cx + dx[d];\n\t\t\t\t\tint ny = cy + dy[d];\n\t\t\t\t\tif(nx < 0 || ny < 0 || nx >= num_x || ny >= num_y) continue;\n\t\t\t\t\tif(occ[nx][ny]) continue;\n\t\t\t\t\tint new_dist = dist[cx][cy] + abs(loc_x[cx] - loc_x[nx]) + abs(loc_y[cy] - loc_y[ny]);\n\t\t\t\t\tif(new_dist < dist[nx][ny]){\n\t\t\t\t\t\tdist[nx][ny] = new_dist;\n\t\t\t\t\t\tbfs.push_back({nx, ny});\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t}\n\t\t\tfor(int nx = 0; nx < num_x; nx++){\n\t\t\t\tfor(int ny = 0; ny < num_y; ny++){\n\t\t\t\t\tif(occ[nx][ny]) continue;\n\t\t\t\t\ti128 dx0 = loc_x[x + 1] - loc_x[x];\n\t\t\t\t\ti128 dy0 = loc_y[y + 1] - loc_y[y];\n\t\t\t\t\ti128 dx1 = loc_x[nx + 1] - loc_x[nx];\n\t\t\t\t\ti128 dy1 = loc_y[ny + 1] - loc_y[ny];\n\t\t\t\t\tif((x == nx && dx0 > 1) || (y == ny && dy0 > 1)){\n\t\t\t\t\t\t// can travel by manhattan distance\n\t\t\t\t\t\ti128 xdist = (x == nx) ? ((dx0 * dx0 * dx0 - dx0) / 3) : \n\t\t\t\t\t\t\tdx0 * dx1 * abs(loc_x[nx + 1] + loc_x[nx] - loc_x[x + 1] - loc_x[x]) / 2;\n\t\t\t\t\t\txdist *= dy0 * dy1;\n\t\t\t\t\t\ti128 ydist = (y == ny) ? ((dy0 * dy0 * dy0 - dy0) / 3) : \n\t\t\t\t\t\t\tdy0 * dy1 * abs(loc_y[ny + 1] + loc_y[ny] - loc_y[y + 1] - loc_y[y]) / 2;\n\t\t\t\t\t\tydist *= dx0 * dx1;\n\t\t\t\t\t\tans += xdist + ydist;\n\t\t\t\t\t} else {\n\t\t\t\t\t\ti128 twice_avg = 2 * i128(dist[nx][ny])\n\t\t\t\t\t\t\t+ abs(loc_x[nx + 1] + loc_x[nx] - loc_x[x + 1] - loc_x[x]) - 2 * abs(loc_x[nx] - loc_x[x])\n\t\t\t\t\t\t\t+ abs(loc_y[ny + 1] + loc_y[ny] - loc_y[y + 1] - loc_y[y]) - 2 * abs(loc_y[ny] - loc_y[y]);\n\t\t\t\t\t\tans += twice_avg * dx0 * dy0 * dx1 * dy1 / 2;\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t}\n\tll ans_mod = (ans / 2) % (int(1e9) + 7);\n\tcout << ans_mod << '\\n';\n}"
  },
  {
    "language": "C++",
    "code": "#include <algorithm>\n#include <array>\n#include <bitset>\n#include <cassert>\n#include <climits>\n#include <cmath>\n#include <complex>\n#include <cstdio>\n#include <cstdlib>\n#include <cstring>\n#include <functional>\n#include <iostream>\n#include <map>\n#include <memory>\n#include <numeric>\n#include <queue>\n#include <random>\n#include <set>\n#include <stack>\n#include <unordered_map>\n#include <vector>\n\nusing namespace std;\n\ntypedef long long lint;\n\nconst int mod = 1e9 + 7, inv6 = (mod + 1) / 6;\n\nstruct edge_t {\n  int u, dist;\n};\n\nint sum_x(int n) {\n  return (lint)n * (n + 1) / 2 % mod;\n}\n\nint sum_x2(int n) {\n  return (lint)n * (2 * n + 1) % mod * (n + 1) % mod * inv6 % mod;\n}\n\nint all_to_corner(int small, int big) {\n  if (small > big) return all_to_corner(big, small);\n  const int max_dist = (small - 1) + (big - 1);\n  int result = (lint)max_dist * sum_x(small - 1) % mod;\n  result =\n    (result + (lint)(sum_x(big - 1) - sum_x(small - 2)) * small) % mod;\n  if (result < 0) result += mod;\n  return result;\n}\n\nint solve_self_one_coord(int r, int c) {\n  int result = 0;\n  int sum_a = ((lint)c * sum_x(c) - sum_x2(c)) % mod;\n  if (sum_a < 0) sum_a += mod;\n  result = (result + (lint)r * (r - 1) % mod * sum_a) % mod;\n  result = (result + (lint)r * sum_a) % mod;\n  return result;\n}\n\nint solve_self(int h, int w) {\n  int result = solve_self_one_coord(h, w) + solve_self_one_coord(w, h);\n  if (result >= mod) result -= mod;\n  return result;\n}\n\nint solve_by_corner(int dist, int h1, int w1, int h2, int w2) {\n  int s1 = (lint)h1 * w1 % mod, s2 = (lint)h2 * w2 % mod;\n  int result = (lint)dist * s1 % mod * s2 % mod;\n  result = (result + (lint)all_to_corner(h1, w1) * s2) % mod;\n  result = (result + (lint)all_to_corner(h2, w2) * s1) % mod;\n  return result;\n}\n\nint unit_to_corner(int h, int w, int dist) {\n  int result = all_to_corner(h, w);\n  result = (result + (lint)h * w % mod * dist) % mod;\n  return result;\n}\n\nint solve_unit_to_rectangle(int h, int w, int d0, int d1, int d2, int d3) {\n  int div_y = (d2 - d0 + h - 1) / 2;\n  int div_x = (d1 - d0 + w - 1) / 2;\n  int result = unit_to_corner(div_y + 1, div_x + 1, d0);\n  if (div_y + 1 < h) {\n    result += unit_to_corner(h - (div_y + 1), div_x + 1, d2);\n    if (result >= mod) result -= mod;\n  }\n  if (div_x + 1 < w) {\n    result += unit_to_corner(div_y + 1, w - (div_x + 1), d1);\n    if (result >= mod) result -= mod;\n  }\n  if (div_y + 1 < h && div_x + 1 < w) {\n    result += unit_to_corner(h - (div_y + 1), w - (div_x + 1), d3);\n    if (result >= mod) result -= mod;\n  }\n  return result;\n}\n\nint solve_greedy_same_row(int r, int c1, int c2, int dist) {\n  int sum_a = ((lint)r * sum_x(r) - sum_x2(r)) % mod;\n  if (sum_a < 0) sum_a += mod;\n  int result = 2LL * c1 * c2 % mod * sum_a % mod;\n  result = (result + (lint)r * r % mod * c2 % mod * sum_x(c1 - 1)) % mod;\n  result = (result + (lint)r * r % mod * c1 % mod * sum_x(c2 - 1)) % mod;\n  result = (result + (lint)r * r % mod * c1 % mod * c2 % mod * dist) % mod;\n  return result;\n}\n\nvoid dijkstra(const vector<vector<edge_t>> &adj, int source,\n              vector<int> &min_dist) {\n  const int n = adj.size();\n  fill(min_dist.begin(), min_dist.end(), INT_MAX);\n  //  assert(min_dist.size() == n);\n  static priority_queue<pair<int, int>, vector<pair<int, int>>,\n                        greater<pair<int, int>>> pq;\n  min_dist[source] = 0;\n  pq.emplace(min_dist[source], source);\n  while (!pq.empty()) {\n    pair<int, int> dist_and_v = pq.top(); pq.pop();\n    int dist_v, v;\n    tie(dist_v, v) = dist_and_v;\n    if (dist_v != min_dist[v]) continue;\n    for (const edge_t &ed : adj[v])\n      if (min_dist[ed.u] > min_dist[v] + ed.dist) {\n        min_dist[ed.u] = min_dist[v] + ed.dist;\n        pq.emplace(min_dist[ed.u], ed.u);\n      }\n  }\n  //  for (int i = 0; i < n; ++i)\n  //    assert(min_dist[i] < INT_MAX);\n}\n\nint main() {\n  int height, width;\n  scanf(\"%d %d\", &height, &width);\n  int nblack;\n  scanf(\"%d\", &nblack);\n  vector<pair<int, int>> blacks(nblack);\n  for (int i = 0; i < nblack; ++i) {\n    int y, x;\n    scanf(\"%d %d\", &y, &x);\n    blacks[i] = {y, x};\n  }\n  vector<int> ys = {0, height}, xs = {0, width};\n  for (int i = 0; i < nblack; ++i) {\n    ys.push_back(blacks[i].first);\n    ys.push_back(blacks[i].first + 1);\n    xs.push_back(blacks[i].second);\n    xs.push_back(blacks[i].second + 1);\n  }\n  sort(ys.begin(), ys.end());\n  ys.resize(unique(ys.begin(), ys.end()) - ys.begin());\n  sort(xs.begin(), xs.end());\n  xs.resize(unique(xs.begin(), xs.end()) - xs.begin());\n  const int ny = ys.size() - 1, nx = xs.size() - 1;\n  vector<bool> row_has_black(ny), col_has_black(nx);\n  vector<vector<bool>> is_black(ny, vector<bool>(nx, false));\n  for (int i = 0; i < nblack; ++i) {\n    int y = lower_bound(ys.begin(), ys.end(), blacks[i].first) - ys.begin();\n    int x = lower_bound(xs.begin(), xs.end(), blacks[i].second) - xs.begin();\n    row_has_black[y] = true;\n    col_has_black[x] = true;\n    is_black[y][x] = true;\n  }\n  vector<vector<edge_t>> adj;\n  vector<vector<array<int, 4>>> corner_id(ny, vector<array<int, 4>>(nx));\n  auto new_node = [&]() {\n    int result = adj.size();\n    adj.emplace_back();\n    return result;\n  };\n  auto add_edge = [&](int u, int v, int dist) {\n    adj[u].push_back({v, dist});\n    adj[v].push_back({u, dist});\n  };\n  for (int y = 0; y < ny; ++y)\n    for (int x = 0; x < nx; ++x)\n      if (!is_black[y][x]) {\n        const int cell_height = ys[y + 1] - ys[y];\n        const int cell_width = xs[x + 1] - xs[x];\n        corner_id[y][x][0] = new_node();\n        if (cell_width == 1) {\n          corner_id[y][x][1] = corner_id[y][x][0];\n        } else {\n          corner_id[y][x][1] = new_node();\n          add_edge(corner_id[y][x][1], corner_id[y][x][0], cell_width - 1);\n        }\n        if (cell_height == 1) {\n          corner_id[y][x][2] = corner_id[y][x][0];\n          corner_id[y][x][3] = corner_id[y][x][1];\n        } else {\n          corner_id[y][x][2] = new_node();\n          add_edge(corner_id[y][x][2], corner_id[y][x][0], cell_height - 1);\n          if (cell_width == 1) {\n            corner_id[y][x][3] = corner_id[y][x][2];\n          } else {\n            corner_id[y][x][3] = new_node();\n            add_edge(corner_id[y][x][3], corner_id[y][x][2], cell_width - 1);\n            add_edge(corner_id[y][x][3], corner_id[y][x][1], cell_height - 1);\n          }\n        }\n\n        if (y - 1 >= 0 && !is_black[y - 1][x]) {\n          add_edge(corner_id[y][x][0], corner_id[y - 1][x][2], 1);\n          if (cell_width > 1) {\n            add_edge(corner_id[y][x][1], corner_id[y - 1][x][3], 1);\n          }\n        }\n        if (x - 1 >= 0 && !is_black[y][x - 1]) {\n          add_edge(corner_id[y][x][0], corner_id[y][x - 1][1], 1);\n          if (cell_height > 1) {\n            add_edge(corner_id[y][x][2], corner_id[y][x - 1][3], 1);\n          }\n        }\n      }\n  vector<int> dists(adj.size());\n  int result = 0;\n  for (int y = 0; y < ny; ++y)\n    for (int x = 0; x < nx; ++x)\n      if (!is_black[y][x]) {\n        const int cell_height = ys[y + 1] - ys[y];\n        const int cell_width = xs[x + 1] - xs[x];\n        result += solve_self(cell_height, cell_width);\n        if (result >= mod) result -= mod;\n\n        if (row_has_black[y] && col_has_black[x]) {\n          dijkstra(adj, corner_id[y][x][0], dists);\n          for (int y2 = 0; y2 < ny; ++y2)\n            for (int x2 = 0; x2 < nx; ++x2)\n              if (!is_black[y2][x2] &&\n                  (!(row_has_black[y2] && col_has_black[x2]) ||\n                   make_pair(y, x) < make_pair(y2, x2))) {\n                result += solve_unit_to_rectangle(\n                    ys[y2 + 1] - ys[y2], xs[x2 + 1] - xs[x2],\n                    dists[corner_id[y2][x2][0]], dists[corner_id[y2][x2][1]],\n                    dists[corner_id[y2][x2][2]], dists[corner_id[y2][x2][3]]);\n                if (result >= mod) result -= mod;\n              }\n        } else {\n          bool computed_dists = false;\n          for (int y2 = y; y2 < ny; ++y2)\n            for (int x2 = 0; x2 < nx; ++x2)\n              if (!is_black[y2][x2] && make_pair(y2, x2) > make_pair(y, x) &&\n                  !(row_has_black[y2] && col_has_black[x2])) {\n                if (row_has_black[y] && row_has_black[y2] && x != x2) {\n                  if (computed_dists == false) {\n                    dijkstra(adj, corner_id[y][x][0], dists);\n                    computed_dists = true;\n                  }\n                  int min_dist;\n                  if (x2 > x) {\n                    min_dist = dists[corner_id[y2][x2][0]] - (cell_width - 1);\n                  } else {\n                    min_dist = dists[corner_id[y2][x2][1]];\n                  }\n                  result += solve_by_corner(min_dist, 1, xs[x + 1] - xs[x],\n                                            1, xs[x2 + 1] - xs[x2]);\n                  if (result >= mod) result -= mod;\n                } else if (col_has_black[x] && col_has_black[x2] && y != y2) {\n                  if (computed_dists == false) {\n                    dijkstra(adj, corner_id[y][x][0], dists);\n                    computed_dists = true;\n                  }\n                  int min_dist;\n                  if (y2 > y) {\n                    min_dist = dists[corner_id[y2][x2][0]] - (cell_height - 1);\n                  } else {\n                    min_dist = dists[corner_id[y2][x2][2]];\n                  }\n                  result += solve_by_corner(min_dist, 1, ys[y + 1] - ys[y],\n                                            1, ys[y2 + 1] - ys[y2]);\n                  if (result >= mod) result -= mod;\n                } else if (y == y2) {\n                  int min_dist;\n                  if (x2 > x) min_dist = xs[x2] - xs[x + 1] + 1;\n                  else min_dist = xs[x] - xs[x2 + 1] + 1;\n                  result += solve_greedy_same_row(ys[y + 1] - ys[y],\n                                                  xs[x + 1] - xs[x],\n                                                  xs[x2 + 1] - xs[x2],\n                                                  min_dist);\n                  if (result >= mod) result -= mod;\n                } else if (x == x2) {\n                  int min_dist;\n                  if (y2 > y) min_dist = ys[y2] - ys[y + 1] + 1;\n                  else min_dist = ys[y] - ys[y2 + 1] + 1;\n                  result += solve_greedy_same_row(xs[x + 1] - xs[x],\n                                                  ys[y + 1] - ys[y],\n                                                  ys[y2 + 1] - ys[y2],\n                                                  min_dist);\n                  if (result >= mod) result -= mod;\n                } else {\n                  int min_dist = 0;\n                  if (y2 > y) min_dist += ys[y2] - ys[y + 1] + 1;\n                  else min_dist += ys[y] - ys[y2 + 1] + 1;\n                  if (x2 > x) min_dist += xs[x2] - xs[x + 1] + 1;\n                  else min_dist += xs[x] - xs[x2 + 1] + 1;\n                  result += solve_by_corner(min_dist,\n                                            ys[y + 1] - ys[y],\n                                            xs[x + 1] - xs[x],\n                                            ys[y2 + 1] - ys[y2],\n                                            xs[x2 + 1] - xs[x2]);\n                  if (result >= mod) result -= mod;\n                }\n              }\n        }\n      }\n  printf(\"%d\\n\", result);\n  return 0;\n}\n"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\n#define mod 1000000007\nusing namespace std;\nbool vh[1000005],vw[1000005];\nint bh[1000005],bw[1000005];\nint nh[1000005],nw[1000005];\nint h,w,n,x[31],y[31],c1=0,c2=0;\nint kh[105],kw[105],wgt[65][65];\nint dis[65][65],que[10005][2],l=1,r=0;\nbool ban[65][65];\ninline int mul(int a,int b)\n{return 1ll*a*b%mod;}\ninline int sub(int a,int b)\n{return (a-b<0?a-b+mod:a-b);}\ninline bool ok(int a,int b)\n{if (a<=0||a>c1||b<=0||b>c2||ban[a][b]) return 0;\nreturn 1;\n}\nint main (){\n\tint i,j,k,l,ans=0;\n\tscanf (\"%d%d%d\",&h,&w,&n);\n\tfor (i=1;i<=n;i++)\n\t{scanf (\"%d%d\",&x[i],&y[i]);\n\tx[i]++;y[i]++;\n\tnh[x[i]]++;nw[y[i]]++;\n\tvh[x[i]]=vw[y[i]]=1;\n\t}\n\tbh[1]=++c1;kh[1]++;\n\tint lo=0,tot=mul(h,w)-n;\n\tif (tot<0) tot+=mod;\n\tfor (i=2;i<=h;i++)\n\t{lo+=(w-nh[i-1]);\n\tif (lo>=mod) lo-=mod;\n\tif ((!vh[i-1])&&(!vh[i]))\n\t{ans+=mul(lo,sub(tot,lo));\n\tif (ans>=mod) ans-=mod;\n\tbh[i]=bh[i-1];kh[c1]++;\n\t}\n\telse {bh[i]=++c1;kh[c1]=1;}\n\t}\n\tbw[1]=++c2;kw[1]++;\n\tlo=0;tot=mul(h,w)-n;\n\tif (tot<0) tot+=mod;\n\tfor (i=2;i<=w;i++)\n\t{lo+=(h-nw[i-1]);\n\tif (lo>=mod) lo-=mod;\n\tif ((!vw[i-1])&&(!vw[i]))\n\t{ans+=mul(lo,sub(tot,lo));\n\tif (ans>=mod) ans-=mod;\n\tbw[i]=bw[i-1];kw[c2]++;\n\t}\n\telse {bw[i]=++c2;kw[c2]=1;}\n\t}\n\tfor (i=1;i<=c1;i++)\n\t{for (j=1;j<=c2;j++)\n\t{wgt[i][j]=mul(kh[i],kw[j]);}\n\t}\n\tfor (i=1;i<=n;i++)\n\t{ban[bh[x[i]]][bw[y[i]]]=1;}\n\tans*=2;\n\tfor (i=1;i<=c1;i++)\n\t{for (j=1;j<=c2;j++)\n\t{if (ban[i][j]) continue;\n\tl=1;r=0;que[++r][0]=i;que[r][1]=j;\n\tmemset (dis,0x7f,sizeof(dis));\n\tdis[i][j]=0;\n\twhile (l<=r)\n\t{int a=que[l][0],b=que[l][1];l++;\n\tif (ok(a-1,b)&&dis[a-1][b]>dis[a][b]+1)\n\t{dis[a-1][b]=dis[a][b]+1;\n\tque[++r][0]=a-1;que[r][1]=b;\n\t}\n\tif (ok(a+1,b)&&dis[a+1][b]>dis[a][b]+1)\n\t{dis[a+1][b]=dis[a][b]+1;\n\tque[++r][0]=a+1;que[r][1]=b;\n\t}\n\tif (ok(a-1,b)&&dis[a-1][b]>dis[a][b]+1)\n\t{dis[a-1][b]=dis[a][b]+1;\n\tque[++r][0]=a-1;que[r][1]=b;\n\t}\n\tif (ok(a,b-1)&&dis[a][b-1]>dis[a][b]+1)\n\t{dis[a][b-1]=dis[a][b]+1;\n\tque[++r][0]=a;que[r][1]=b-1;\n\t}\n\tif (ok(a,b+1)&&dis[a][b+1]>dis[a][b]+1)\n\t{dis[a][b+1]=dis[a][b]+1;\n\tque[++r][0]=a;que[r][1]=b+1;\n\t}\n\t}\n\tint tp=0;\n\tfor (k=1;k<=c1;k++)\n\t{for (l=1;l<=c2;l++)\n\t{if (ban[k][l]) continue;\n\ttp+=mul(dis[k][l],wgt[k][l]);\n\tif (tp>=mod) tp-=mod;\n\t}\n\t}\n\ttp=mul(tp,wgt[i][j]);\n\tans+=tp;\n\tif (ans>=mod) ans-=mod;\n\t}\n\t}\n\tif (ans&1) ans+=mod;\n\tprintf (\"%d\\n\",ans>>1);\n\treturn 0;\n}\n\t\n\t\n\t"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\n\nusing namespace std;\n\n#define fi first\n#define se second\n#define mp make_pair\n#define pb push_back\n#define all(x) (x).begin (),(x).end()\n#define sqrt(x) sqrt(abs(x))\n#define re return\n#define sz(x) ((int)(x).size ())\n#define prev PREV\n#define next NEXT\n\nusing ll = long long;\nusing ii = pair<int, int>;\nusing ld = long double;\nusing D = double;\nusing vi = vector<int>;\nusing vii = vector<ii>;\nusing vvi = vector<vi>;\nusing vs = vector<string>;\n\ntemplate<typename T> T abs (T x) { re x < 0 ? -x : x; }\ntemplate<typename T> T sgn (T x) { re x < 0 ? -1 : (x > 0 ? 1 : 0); }\ntemplate<typename T> T sqr (T x) { re x * x; }\ntemplate<typename T> T gcd (T a, T b) { re a ? gcd (b % a, a) : b; }\n\nconst int mod = 1000*1000*1000+7;\nint rev2;\nint rev3;\nint rev6;\n\nint n;\nint m;\n\nmap<ii, int> num;\nii rct[15000];\nint d[15000];\nint mark[15000];\nint xx[15000];\nint yy[15000];\nint x[30];\nint y[30];\nint g[61][61][2][2];\nii gc[61][61][2][2];\nint bad[61][61];\nvii wx, wy;\nvi vx, vy;\nint o;\npriority_queue<ii> all;\nint q;\nset<ii> pts;\n\nvii build (vi v, int n) {\n\tvii w;\n\tif (v[0] > 0) w.pb (mp (0, v[0] - 1));\n\tfor (int i = 0; i + 1 < sz (v); i++)\n\t\tif (v[i] + 1 < v[i + 1])\n\t\t\tw.pb (mp (v[i] + 1, v[i + 1] - 1));\n\tif (v[sz (v) - 1] + 1 < n)\n\t\tw.pb (mp (v[sz (v) - 1] + 1, n - 1));\n\tfor (int i = 0; i < sz (v); i++) w.pb (mp (v[i], v[i]));\n\tsort (all (w));\n\tre w;\n}\n\nint get (int x, int y, int i, int j) {\n\tif (num.find (mp (x, y)) != num.end ()) re num[mp (x, y)];\n\txx[o] = x;\n\tyy[o] = y;\n\trct[o] = mp (i, j);\n\tnum[mp (x, y)] = o;\n\to++;\n\tre o - 1;\n}\n\nvoid upd (int i, int j) {\n\tif (d[i] > j) {\n\t\td[i] = j;\n\t\tmark[i] = 1;\n\t\tall.push (mp (-d[i], i));\n\t}\n}\n\nint c2c (int a) {\n\tre ((ll)(a - 1) * a % mod * (a + 1) % mod * rev3) % mod;\n}\n\nint self (int a, int b) {\n\tre ((ll)c2c (a) * b % mod * b + (ll)c2c (b) * a % mod * a) % mod;\n}\n\nint same (int a, int b, int c, int dist) {\n//\tprintf (\"same %d %d %d %d\\n\", a, b, c, dist);\n\tre ((ll)c2c (a) * b % mod * c % mod + (ll)a * a % mod * b % mod * c % mod * (2 * dist + (b + c - 2)) % mod * rev2 % mod) % mod;\n}\n\nint diff (int a, int b, int c, int d, int dist) {\n\tre ((ll)a * b % mod * c % mod * d % mod * (a + b + c + d - 4 + 2 * dist) % mod * rev2) % mod;\n}\n\nint power (int a, int b) {\n\tint c = 1;\n\twhile (b) {\n\t\tif (b & 1) c = ((ll)c * a) % mod;\n\t\ta = ((ll)a * a) % mod;\n\t\tb /= 2;\n\t}\n\tre c;\n}\n\nint main () {\n\trev2 = power (2, mod - 2);\n\trev3 = power (3, mod - 2);\n\trev6 = power (6, mod - 2);\n\tscanf (\"%d%d\", &n, &m);\n\tscanf (\"%d\", &q);\n\tfor (int i = 0; i < q; i++) {\n\t\tscanf (\"%d%d\", &x[i], &y[i]);\n\t\tpts.insert (mp (x[i], y[i]));\n\t\tvx.pb (x[i]);\n\t\tvy.pb (y[i]);\n\t}\n\tsort (all (vx));\n\tsort (all (vy));\n\tvx.resize (unique (all (vx)) - vx.begin ());\n\tvy.resize (unique (all (vy)) - vy.begin ());\n\twx = build (vx, n);\n\twy = build (vy, m);\n\tint nx = sz (wx);\n\tint ny = sz (wy);\n\tfor (int i = 0; i < nx; i++)\n\t\tfor (int j = 0; j < ny; j++) {\n\t\t\tbad[i][j] = 1;\n\t\t\tif (wx[i].fi == wx[i].se && wy[j].fi == wy[j].se && pts.count (mp (wx[i].fi, wy[j].fi))) continue;\n\t\t\tbad[i][j] = 0;\n\t\t\tfor (int a = 0; a < 2; a++)\n\t\t\t\tfor (int b = 0; b < 2; b++) {\n\t\t\t\t\tgc[i][j][a][b] = mp (wx[i].fi + (wx[i].se - wx[i].fi) * a, wy[j].fi + (wy[j].se - wy[j].fi) * b);\n\t\t\t\t\tg[i][j][a][b] = get (wx[i].fi + (wx[i].se - wx[i].fi) * a, wy[j].fi + (wy[j].se - wy[j].fi) * b, i, j);\n\t\t\t\t}\n\t\t}\n//\tprintf (\"%d\\n\", o);\n\tint ans = 0;\n\tfor (int ii = 0; ii < nx; ii++)\n\t\tfor (int jj = 0; jj < ny; jj++) {\n\t\t\tif (bad[ii][jj]) continue;\n//\t\t\tprintf (\"%d %d\\n\", wx[ii].se - wx[ii].fi + 1, wy[jj].se - wy[jj].fi + 1);\n\t\t\tans = (ans + (ll)self (wx[ii].se - wx[ii].fi + 1, wy[jj].se - wy[jj].fi + 1) * rev2) % mod;\n\t\t\tfor (int j = 0; j < o; j++) {\n\t\t\t\td[j] = 1e9;\n\t\t\t\tmark[j] = 0;\n\t\t\t}\n\t\t\twhile (!all.empty ()) all.pop ();\n\t\t\tfor (int a = 0; a < 2; a++)\n\t\t\t\tfor (int b = 0; b < 2; b++)\n\t\t\t\t\tif (!mark[g[ii][jj][a][b]]) {\n\t\t\t\t\t\td[g[ii][jj][a][b]] = 0;\n\t\t\t\t\t\tmark[g[ii][jj][a][b]] = 1;\n\t\t\t\t\t\tall.push (mp (0, g[ii][jj][a][b]));\n\t\t\t\t\t}\n\t\t\twhile (!all.empty ()) {\n\t\t\t\tint j = all.top ().se;\n\t\t\t\tall.pop ();\n\t\t\t\tif (mark[j] == 2) continue;\n\t\t\t\tmark[j] = 2;\n\t\t\t\tint cx = xx[j];\n\t\t\t\tint cy = yy[j];\n\t\t\t\tint p = rct[j].fi;\n\t\t\t\tint q = rct[j].se;\n\t\t\t\tint ca = int (cx == wx[p].se);\n\t\t\t\tint cb = int (cy == wy[q].se);\n\t\t\t\tfor (int a = 0; a < 2; a++)\n\t\t\t\t\tfor (int b = 0; b < 2; b++) {\n\t\t\t\t\t\tint nx = gc[p][q][a][b].fi;\n\t\t\t\t\t\tint ny = gc[p][q][a][b].se;\n\t\t\t\t\t\tupd (g[p][q][a][b], d[j] + abs (cx - nx) + abs (cy - ny));\n\t\t\t\t\t}\n\t\t\t\tif (cx == wx[p].fi && p > 0 && !bad[p - 1][q]) upd (g[p - 1][q][1][cb], d[j] + 1);\n\t\t\t\tif (cx == wx[p].se && p + 1 < nx && !bad[p + 1][q]) upd (g[p + 1][q][0][cb], d[j] + 1);\n\t\t\t\tif (cy == wy[q].fi && q > 0 && !bad[p][q - 1]) upd (g[p][q - 1][ca][1], d[j] + 1);\n\t\t\t\tif (cy == wy[q].se && q + 1 < ny && !bad[p][q + 1]) upd (g[p][q + 1][ca][0], d[j] + 1);\n\t\t\t}\n//\t\t\tprintf (\"self = %d\\n\", ans);\n\t\t\tfor (int pp = 0; pp < nx; pp++)\n\t\t\t\tfor (int qq = 0; qq < ny; qq++) {\n\t\t\t\t\tif (mp (pp, qq) > mp (ii, jj)) continue;\n\t\t\t\t\tif (bad[pp][qq]) continue;\n\t\t\t\t\tint dist = 1e9;\n\t\t\t\t\tfor (int a = 0; a < 2; a++)\n\t\t\t\t\t\tfor (int b = 0; b < 2; b++)\n\t\t\t\t\t\t\tdist = min (dist, d[g[pp][qq][a][b]]);\n\t\t\t\t\tif (dist == 0) continue;\n\t\t\t\t\tif (pp == ii) ans = (ans + same (wx[ii].se - wx[ii].fi + 1, wy[jj].se - wy[jj].fi + 1, wy[qq].se - wy[qq].fi + 1, dist)) % mod; else\n\t\t\t\t\tif (qq == jj) ans = (ans + same (wy[jj].se - wy[jj].fi + 1, wx[ii].se - wx[ii].fi + 1, wx[pp].se - wx[pp].fi + 1, dist)) % mod; else\n\t\t\t\t\t\t\t\t  ans = (ans + diff (wx[ii].se - wx[ii].fi + 1, wy[jj].se - wy[jj].fi + 1, wx[pp].se - wx[pp].fi + 1, wy[qq].se - wy[qq].fi + 1, dist)) % mod;\n//\t\t\t\t\tprintf (\"%d %d - %d %d = %d = %d\\n\", ii, jj, pp, qq, ans, dist);\n\t\t\t\t}\n\t\t}\n\tcout << ((ll)ans) % mod << endl;\n\tcerr << clock () << endl;\n\treturn 0;\n}"
  },
  {
    "language": "C++",
    "code": "\n#include<bits/stdc++.h>\nusing namespace std;\n#define DB(x){if(DEBUG)cerr<<__LINE__<<\" \"<<#x<<\" \" <<x<<endl;}\n#define REP(i,b)for(LL i=(0);i<(b);++i)\n#define FOR(i,a,b)for(LL i=(a);i<=(b);++i)\n#define FORD(i,a,b)for(LL i=(a);i>=(b);--i)\n#define ALL(x) (x).begin(),(x).end()\n#define VV vector\ntemplate<typename X,typename Y>void MAX(X&a,Y b){a=(a>=b?a:b);}\ntemplate<typename X,typename Y>void MIN(X&a,Y b){a=(a<=b?a:b);}\ntypedef long long LL;typedef long double LD;\nint DEBUG=0,MULTI=0,GCJ=0;\n\nstruct solver_t;solver_t *solver;\nconst int MOD = 1e9 + 7;\nstruct solver_t {\n  int ROWS = -1, COLS = -1;\n  int IS_BLACK[70][70] = {};\n  LL HEI[70][70] = {};\n  LL WID[70][70] = {};\n\n  LL calculate(LL source_r, LL source_c) {\n    struct pkt_t { LL R = -1, C = -1; LL dst = -1;\n      bool operator < (const pkt_t rhs) const {\n        return dst < rhs.dst;\n      }\n    };\n    DB(source_r<<\" \"<<source_c);\n\n    LL DST[70][70];\n    memset(DST, 0x7f, sizeof(DST));\n\n    multiset <pkt_t> KOL;\n    DST[source_r][source_c] = 0;\n    KOL.insert({source_r, source_c, 0});\n    while (KOL.size() > 0) {\n      auto front = KOL.begin();\n      auto top = *front;\n      KOL.erase(front);\n      if (DST[top.R][top.C] != top.dst) continue;\n\n      FOR (dr, -1, 1) FOR (dc, -1, 1) if (abs(dr) + abs(dc) == 1) {\n        if (dr) {\n          int next_r = top.R + dr;\n          int next_c = top.C;\n          if (!(next_r >=0 && next_r < ROWS)) continue;\n          if (IS_BLACK[next_r][next_c]) continue;\n\n          LL diff_dst;\n          if (next_r == source_r || top.R == source_r) diff_dst = 1;\n          else diff_dst = HEI[top.R][top.C];\n\n          if (DST[next_r][next_c] > diff_dst + top.dst) {\n            DST[next_r][next_c] = diff_dst + top.dst;\n            KOL.insert( { next_r, next_c, DST[next_r][next_c]} );\n          }\n        }\n        if (dc) {\n\n          int next_r = top.R;\n          int next_c = top.C + dc;\n          if (!(next_c >= 0 && next_c < COLS)) continue;\n          if (IS_BLACK[next_r][next_c]) continue;\n\n          int diff_dst;\n          if (next_c == source_c || top.C == source_c) diff_dst = 1;\n          else diff_dst = WID[top.R][top.C];\n\n          if (DST[next_r][next_c] > diff_dst + top.dst) {\n            DST[next_r][next_c] = diff_dst + top.dst;\n            KOL.insert( { next_r, next_c, DST[next_r][next_c]} );\n          }\n        }\n      }\n    }\n\n\n\n    auto power=[](LL a, LL b) {\n      LL res = 1;\n      while (b) {\n        if (b&1) res=(res*a)%MOD;\n        b/=2; a=(a*a)%MOD;\n      }\n      return res;\n    };\n    LL rev3 = power(3, MOD - 2);\n    LL rev2 = power(2, MOD - 2);\n    LL res = 0;\n    REP (r, ROWS) REP (c, COLS) if (IS_BLACK[r][c] == 0) {\n      DB(source_r<<\" \"<<source_c<<\" \"<<r<<\" \"<<c<<\" \"<<DST[r][c]);\n      pair<int,int> V1(source_r, source_c);\n      pair<int,int> V2(r, c);\n      //if (!(V1 <= V2)) continue;\n\n      res += DST[r][c] % MOD * HEI[r][c] % MOD * WID[r][c] % MOD *\n             HEI[source_r][source_c] % MOD * WID[source_r][source_c] % MOD;\n      res %= MOD;\n\n      auto oblicz=[&](LL wid) {\n        LL N = wid + 1;\n        if (N < 3) return 0LL;\n        LL res = ((N * (N-1) % MOD) *(N-2)) % MOD;\n        res = (res * rev3) % MOD;\n\n        return res;\n      };\n      DB(oblicz(0));\n      DB(oblicz(1));\n      DB(oblicz(2));\n      DB(oblicz(3));\n      DB(oblicz(4));\n      DB(oblicz(5));\n      DB(oblicz(10));\n\n      auto oblicz2=[&](LL wid1,LL wid2) {\n        LL p1 = (wid1 - 1)  % MOD * wid1 % MOD * rev2 % MOD * wid2;\n        LL p2 = (wid2 - 1)  % MOD* wid2 % MOD * rev2 % MOD * wid1;\n        return (p1 + p2) % MOD;\n      };\n\n      if (source_r == r) {\n        LL hei = HEI[r][c];\n        assert(HEI[r][c] == HEI[source_r][source_c]);\n\n        LL tmp = oblicz(hei) % MOD;\n        tmp = (tmp * WID[r][c] % MOD * WID[source_r][source_c]) % MOD;\n\n        res += tmp;\n      }\n      else {\n        LL tmp = oblicz2(HEI[r][c], HEI[source_r][source_c]) % MOD;\n        tmp = (tmp * WID[r][c] % MOD * WID[source_r][source_c]) % MOD;\n        res += tmp;\n      }\n      if (source_c == c) {\n        int wid = WID[r][c];\n        assert(WID[r][c] == WID[source_r][source_c]);\n        LL tmp = oblicz(wid) % MOD;\n        tmp = (tmp * HEI[r][c] % MOD * HEI[source_r][source_c]) % MOD;\n\n        res += tmp;\n      }\n      else {\n        LL tmp = oblicz2(WID[r][c], WID[source_r][source_c]) % MOD;\n\n        tmp = (tmp * HEI[r][c] % MOD * HEI[source_r][source_c]) % MOD;\n        res += tmp;\n      }\n      res %= MOD;\n    }\n\n    return res;\n  }\n\n\n  void solve() {\n    int H, W;cin >>H>>W;\n    int N; cin >> N;\n\n    VV<int> CORD_R;\n    VV<int> CORD_C;\n\n    VV<array<int,2> > BLACK;\n    REP (i, N) {\n      int r, c;\n      cin >> r >> c;\n      BLACK.push_back({r,c});\n      CORD_R.push_back(r);\n      CORD_R.push_back(r + 1);\n\n      CORD_C.push_back(c);\n      CORD_C.push_back(c + 1);\n    }\n    CORD_R.push_back(0);\n    CORD_R.push_back(H);\n\n    CORD_C.push_back(0);\n    CORD_C.push_back(W);\n\n    sort( ALL(CORD_R) ); CORD_R.erase(unique(ALL(CORD_R)), CORD_R.end());\n    sort( ALL(CORD_C) ); CORD_C.erase(unique(ALL(CORD_C)), CORD_C.end());\n\n    for (int cr : CORD_R) DB(cr);\n    for (int cc : CORD_C) DB(cc);\n\n\n    ROWS = CORD_R.size() - 1;\n    COLS = CORD_C.size() - 1;\n\n    for (auto black : BLACK) {\n      int r = lower_bound(ALL(CORD_R), black[0]) - CORD_R.begin();\n      int c = lower_bound(ALL(CORD_C), black[1]) - CORD_C.begin();\n      IS_BLACK[r][c] = 1;\n    }\n    REP (r, ROWS) REP (c, COLS) {\n      HEI[r][c] = CORD_R[r + 1] - CORD_R[r];\n      WID[r][c] = CORD_C[c + 1] - CORD_C[c];\n    }\n\n\n    LL res = 0;\n    auto power=[](LL a, LL b) {\n      LL res = 1;\n      while (b) {\n        if (b&1) res=(res*a)%MOD;\n        b/=2; a=(a*a)%MOD;\n      }\n      return res;\n    };\n    LL rev2 = power(2, MOD - 2);\n    REP (r, ROWS) REP (c, COLS) if (IS_BLACK[r][c] == 0) {\n      res += calculate(r, c);\n      res %= MOD;\n    }\n    cout << ((res * rev2) % MOD +MOD)%MOD << \"\\n\";\n  }\n\n\n  void gen() {}\n  void brute() {}\n};\n\n#undef int\nint main(int argc,char** argv){\n  FOR(i,1,argc-1)for(int j=0;argv[i][j];j++)if(argv[i][j]=='.')freopen(argv[i],\"r\",stdin);\n  FOR(i,1,argc-1)if(argv[i]==string(\"q\"))DEBUG=1<<30;\n  FOR(i,1,argc-1)if(argv[i]==string(\"gen\")){(solver=new solver_t())->gen();exit(0);}\n  FOR(i,1,argc-1)if(argv[i]==string(\"brute\")){(solver=new solver_t())->brute();exit(0);}\n  ios::sync_with_stdio(false),cin.tie(0);\n  cout.setf(ios::fixed),cout.precision(10);int t;if(MULTI||GCJ)cin>>t;else t=1;\n  FOR(i,1,t){if(DEBUG)cerr<<__LINE__<<\" \"<<i<<endl;if(GCJ)cout<<\"Case #\"<<i<<\": \";\n    solver = new solver_t();\n    solver->solve();\n  }return 0;\n}\n\n"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\n\n#ifdef DEBUG\n#define debug(...) fprintf(stderr, __VA_ARGS__)\n#else\n#define debug(...)\n#endif\n\n#ifdef __WIN32\n#define LLFORMAT \"I64\"\n#define Rand() ((rand() << 15) + rand())\n#else\n#define LLFORMAT \"ll\"\n#define Rand() (rand())\n#endif\n\nusing namespace std;\n\nconst int maxn = 62, maxm = 1e6 + 10, mod = 1e9 + 7, dx[] = {-1, 1, 0, 0}, dy[] = {0, 0, -1, 1}, oo = 1e9, i2 = mod + 1 >> 1;\n\nint k, n, m, H, W, f[maxm], ans, nn, mm;\nset<pair<int, int> > blk;\nvector<int> allx, ally;\npriority_queue<pair<pair<int, int>, pair<int, int> >, vector<pair<pair<int, int>, pair<int, int> > >, greater<pair<pair<int, int>, pair<int, int> > > > heap;\npair<int, int> d[100][100], id[maxn][maxn][4];\nint x[100][100], y[100][100];\nbool ban[100][100];\n\nstruct rect {\n\tint x1, y1, x2, y2;\n\tbool blk;\n\n\trect() { blk = 0; }\n\trect(int x1, int y1, int x2, int y2): x1(x1), y1(y1), x2(x2), y2(y2) { blk = 0; }\n\n\tinline void get(int t, int &x, int &y) const {\n\t\tx = t & 2 ? x2 : x1;\n\t\ty = t & 1 ? y2 : y1;\n\t\treturn;\n\t}\n} rng[maxn][maxn];\n\nint F(int l) {\n\tif(~f[l]) {\n\t\treturn f[l];\n\t}\n\tint &x = f[l];\n\tif(l <= 1) {\n\t\treturn x = 0;\n\t}\n\treturn x = ((long long) l * (l - 1) + F(l - 1)) % mod;\n}\n\nint F(int l, int d, int a, int b) {\n\treturn (((((long long) a * (a - 1) * b + (long long) b * (b - 1) * a) >> 1) + (long long) a * b * d) % mod * l % mod * l + (long long) F(l) * a % mod * b) % mod;\n}\n\nint F(int n, int m) {\n\tif(!m) {\n\t\treturn 0;\n\t}\n\tif(m == 1) {\n\t\treturn (long long) F(n) * i2 % mod;\n\t}\n\tif(m & 1) {\n\t\treturn ((long long) F(n, m - 1) + (long long) F(1, n) + (long long) F(n, 1, m - 1, 1)) % mod;\n\t}\n\treturn (((long long) F(n, m >> 1) << 1) + (long long) F(n, 1, m >> 1, m >> 1)) % mod;\n}\n\nint D(int n, int m) {\n\treturn (long long) (m + n - 2) * n % mod * m % mod * i2 % mod;\n}\n\nint main() {\n\tmemset(f, -1, sizeof f);\n\tscanf(\"%d%d%d\", &H, &W, &k);\n\tallx.push_back(0);\n\tally.push_back(0);\n\tfor (int i = 1; i <= k; ++i) {\n\t\tint x, y;\n\t\tscanf(\"%d%d\", &x, &y);\n\t\tif(x + 1 < H) {\n\t\t\tallx.push_back(x + 1);\n\t\t}\n\t\tallx.push_back(x);\n\t\tif(y + 1 < W) {\n\t\t\tally.push_back(y + 1);\n\t\t}\n\t\tally.push_back(y);\n\t\tblk.insert(make_pair(x, y));\n\t}\n\tsort(allx.begin(), allx.end());\n\tsort(ally.begin(), ally.end());\n\tallx.resize(unique(allx.begin(), allx.end()) - allx.begin());\n\tally.resize(unique(ally.begin(), ally.end()) - ally.begin());\n\tn = allx.size();\n\tm = ally.size();\n\tallx.push_back(H);\n\tally.push_back(W);\n\tfor (int i = 0; i < n; ++i) {\n\t\tfor (int j = 0; j < m; ++j) {\n\t\t\tint x1, y1, x2, y2;\n\t\t\trng[i][j] = rect(x1 = allx[i], y1 = ally[j], x2 = allx[i + 1] - 1, y2 = ally[j + 1] - 1);\n\t\t\tif(x1 == x2 && y1 == y2 && blk.find(make_pair(x1, y1)) != blk.end()) {\n\t\t\t\trng[i][j].blk = 1;\n\t\t\t}\n\t\t}\n\t}\n\tfor (int i = 0; i < n; ++i) {\n\t\tmm = 0;\n\t\tfor (int j = 0; j < m; ++j) {\n\t\t\tx[nn][mm] = rng[i][j].x1;\n\t\t\ty[nn][mm] = rng[i][j].y1;\n\t\t\tban[nn][mm] = rng[i][j].blk;\n\t\t\tid[i][j][0] = make_pair(nn, mm);\n\t\t\t++mm;\n\t\t\tif(rng[i][j].y2 > rng[i][j].y1) {\n\t\t\t\tx[nn][mm] = rng[i][j].x1;\n\t\t\t\ty[nn][mm] = rng[i][j].y2;\n\t\t\t\tban[nn][mm] = rng[i][j].blk;\n\t\t\t\tid[i][j][1] = make_pair(nn, mm);\n\t\t\t\t++mm;\n\t\t\t}\n\t\t\telse {\n\t\t\t\tid[i][j][1] = id[i][j][0];\n\t\t\t}\n\t\t}\n\t\t++nn;\n\t\tif(rng[i][0].x1 < rng[i][0].x2) {\n\t\t\tmm = 0;\n\t\t\tfor (int j = 0; j < m; ++j) {\n\t\t\t\tx[nn][mm] = rng[i][j].x2;\n\t\t\t\ty[nn][mm] = rng[i][j].y1;\n\t\t\t\tban[nn][mm] = rng[i][j].blk;\n\t\t\t\tid[i][j][2] = make_pair(nn, mm);\n\t\t\t\t++mm;\n\t\t\t\tif(rng[i][j].y2 > rng[i][j].y1) {\n\t\t\t\t\tx[nn][mm] = rng[i][j].x2;\n\t\t\t\t\ty[nn][mm] = rng[i][j].y2;\n\t\t\t\t\tban[nn][mm] = rng[i][j].blk;\n\t\t\t\t\tid[i][j][3] = make_pair(nn, mm);\n\t\t\t\t\t++mm;\n\t\t\t\t}\n\t\t\t\telse {\n\t\t\t\t\tid[i][j][3] = id[i][j][2];\n\t\t\t\t}\n\t\t\t}\n\t\t\t++nn;\n\t\t}\n\t\telse {\n\t\t\tfor (int j = 0; j < m; ++j) {\n\t\t\t\tid[i][j][2] = id[i][j][0];\n\t\t\t\tid[i][j][3] = id[i][j][1];\n\t\t\t}\n\t\t}\n\t}\n\tfor (int i = 0; i < n; ++i) {\n\t\tfor (int j = 0; j < m; ++j) {\n\t\t\tif(rng[i][j].blk) {\n\t\t\t\tcontinue;\n\t\t\t}\n\t\t\tint lx = rng[i][j].x2 - rng[i][j].x1 + 1, ly = rng[i][j].y2 - rng[i][j].y1 + 1;\n\t\t\tans = (F(lx, ly) + ans) % mod;\n\t\t\tfor (int i = 0; i < nn; ++i) {\n\t\t\t\tfor (int j = 0; j < mm; ++j) {\n\t\t\t\t\td[i][j] = make_pair(oo, -1);\n\t\t\t\t}\n\t\t\t}\n\t\t\tfor (int c = 0; c < 4; ++c) {\n\t\t\t\tauto &t = id[i][j][c];\n\t\t\t\theap.push(make_pair(d[t.first][t.second] = make_pair(0, c), make_pair(t.first, t.second)));\n\t\t\t}\n\t\t\twhile(!heap.empty()) {\n\t\t\t\tauto T = heap.top();\n\t\t\t\theap.pop();\n\t\t\t\tauto &t = T.first;\n\t\t\t\tint &i = T.second.first, &j = T.second.second;\n\t\t\t\tif(t != d[i][j]) {\n\t\t\t\t\tcontinue;\n\t\t\t\t}\n\t\t\t\tint &dd = t.first, &xx = x[i][j], &yy = y[i][j];\n\t\t\t\tfor (register int k = 0; k < 4; ++k) {\n\t\t\t\t\tregister int x = i + dx[k], y = j + dy[k];\n\t\t\t\t\tif(x >= 0 && y >= 0 && x < nn && y < mm && !ban[x][y]) {\n\t\t\t\t\t\tregister int s = dd + (k < 2 ? abs(::x[x][y] - xx) : abs(::y[x][y] - yy));\n\t\t\t\t\t\tif(s < d[x][y].first) {\n\t\t\t\t\t\t\theap.push(make_pair(d[x][y] = make_pair(s, t.second), make_pair(x, y)));\n\t\t\t\t\t\t}\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t}\n\t\t\tfor (int a = 0; a <= i; ++a) {\n\t\t\t\tfor (int b = 0; b < m; ++b) {\n\t\t\t\t\tif(a == i && b == j) {\n\t\t\t\t\t\tbreak;\n\t\t\t\t\t}\n\t\t\t\t\tif(!rng[a][b].blk) {\n\t\t\t\t\t\tint c = 0;\n\t\t\t\t\t\tfor (int cc = 1; cc < 4; ++cc) {\n\t\t\t\t\t\t\tauto &t = id[a][b][cc], &s = id[a][b][c];\n\t\t\t\t\t\t\tif(d[t.first][t.second] < d[s.first][s.second]) {\n\t\t\t\t\t\t\t\tc = cc;\n\t\t\t\t\t\t\t}\n\t\t\t\t\t\t}\n\t\t\t\t\t\tauto &s = id[a][b][c];\n\t\t\t\t\t\tint k = d[s.first][s.second].second, dst = d[s.first][s.second].first, x1, y1, x2, y2;\n\t\t\t\t\t\trng[i][j].get(k, x1, y1);\n\t\t\t\t\t\trng[a][b].get(c, x2, y2);\n\t\t\t\t\t\tif(dst == abs(x1 - x2) + abs(y1 - y2)) {\n\t\t\t\t\t\t\tif(i == a) {\n\t\t\t\t\t\t\t\tans = (F(lx, j < b ? rng[a][b].y1 - rng[i][j].y2 : rng[i][j].y1 - rng[a][b].y2, ly, rng[a][b].y2 - rng[a][b].y1 + 1) + ans) % mod;\n\t\t\t\t\t\t\t\tcontinue;\n\t\t\t\t\t\t\t}\n\t\t\t\t\t\t\tif(j == b) {\n\t\t\t\t\t\t\t\tans = (F(ly, rng[i][j].x1 - rng[a][b].x2, lx, rng[a][b].x2 - rng[a][b].x1 + 1) + ans) % mod;\n\t\t\t\t\t\t\t\tcontinue;\n\t\t\t\t\t\t\t}\n\t\t\t\t\t\t}\n\t\t\t\t\t\tx1 = lx;\n\t\t\t\t\t\ty1 = ly;\n\t\t\t\t\t\tx2 = rng[a][b].x2 - rng[a][b].x1 + 1;\n\t\t\t\t\t\ty2 = rng[a][b].y2 - rng[a][b].y1 + 1;\n\t\t\t\t\t\tint s1 = (long long) x1 * y1 % mod, s2 = (long long) x2 * y2 % mod;\n\t\t\t\t\t\tans = ((long long) D(x1, y1) * s2 + (long long) D(x2, y2) * s1 + (long long) dst * s1 % mod * s2 + ans) % mod;\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t}\n\tprintf(\"%d\\n\", ans);\n\treturn 0;\n}\n"
  },
  {
    "language": "C++",
    "code": "\n#include<bits/stdc++.h>\nusing namespace std;\n#define DB(x){if(DEBUG)cerr<<__LINE__<<\" \"<<#x<<\" \" <<x<<endl;}\n#define REP(i,b)for(LL i=(0);i<(b);++i)\n#define FOR(i,a,b)for(LL i=(a);i<=(b);++i)\n#define FORD(i,a,b)for(LL i=(a);i>=(b);--i)\n#define ALL(x) (x).begin(),(x).end()\n#define VV vector\ntemplate<typename X,typename Y>void MAX(X&a,Y b){a=(a>=b?a:b);}\ntemplate<typename X,typename Y>void MIN(X&a,Y b){a=(a<=b?a:b);}\ntypedef long long LL;typedef long double LD;\nint DEBUG=0,MULTI=0,GCJ=0;\n\nstruct solver_t;solver_t *solver;\nconst int MOD = 1e9 + 7;\nstruct solver_t {\n  int ROWS = -1, COLS = -1;\n  int IS_BLACK[70][70] = {};\n  LL HEI[70][70] = {};\n  LL WID[70][70] = {};\n\n  LL calculate(LL source_r, LL source_c) {\n    struct pkt_t { LL R = -1, C = -1; LL dst = -1;\n      bool operator < (const pkt_t rhs) const {\n        return dst < rhs.dst;\n      }\n    };\n    DB(source_r<<\" \"<<source_c);\n\n    LL DST[70][70];\n    memset(DST, 0x7f, sizeof(DST));\n\n    multiset <pkt_t> KOL;\n    DST[source_r][source_c] = 0;\n    KOL.insert({source_r, source_c, 0});\n    while (KOL.size() > 0) {\n      auto front = KOL.begin();\n      auto top = *front;\n      KOL.erase(front);\n      if (DST[top.R][top.C] != top.dst) continue;\n\n      FOR (dr, -1, 1) FOR (dc, -1, 1) if (abs(dr) + abs(dc) == 1) {\n        if (dr) {\n          int next_r = top.R + dr;\n          int next_c = top.C;\n          if (!(next_r >=0 && next_r < ROWS)) continue;\n          if (IS_BLACK[next_r][next_c]) continue;\n\n          LL diff_dst;\n          if (top.R == source_r) diff_dst = 1;\n          else diff_dst = HEI[top.R][top.C];\n\n          if (DST[next_r][next_c] > diff_dst + top.dst) {\n            DST[next_r][next_c] = diff_dst + top.dst;\n            KOL.insert( { next_r, next_c, DST[next_r][next_c]} );\n          }\n        }\n        if (dc) {\n\n          int next_r = top.R;\n          int next_c = top.C + dc;\n          if (!(next_c >= 0 && next_c < COLS)) continue;\n          if (IS_BLACK[next_r][next_c]) continue;\n\n          int diff_dst;\n          if (top.C == source_c) diff_dst = 1;\n          else diff_dst = WID[top.R][top.C];\n\n          if (DST[next_r][next_c] > diff_dst + top.dst) {\n            DST[next_r][next_c] = diff_dst + top.dst;\n            KOL.insert( { next_r, next_c, DST[next_r][next_c]} );\n          }\n        }\n      }\n    }\n\n\n\n    auto power=[](LL a, LL b) {\n      LL res = 1;\n      while (b) {\n        if (b&1) res=(res*a)%MOD;\n        b/=2; a=(a*a)%MOD;\n      }\n      return res;\n    };\n    LL rev3 = power(3, MOD - 2);\n    LL rev2 = power(2, MOD - 2);\n    LL res = 0;\n    REP (r, ROWS) REP (c, COLS) if (IS_BLACK[r][c] == 0) {\n      DB(source_r<<\" \"<<source_c<<\" \"<<r<<\" \"<<c<<\" \"<<DST[r][c]);\n      pair<int,int> V1(source_r, source_c);\n      pair<int,int> V2(r, c);\n      //if (!(V1 <= V2)) continue;\n\n      res += DST[r][c] % MOD * HEI[r][c] % MOD * WID[r][c] % MOD *\n             HEI[source_r][source_c] % MOD * WID[source_r][source_c] % MOD;\n      res %= MOD;\n\n      auto oblicz=[&](LL wid) {\n        LL N = wid + 1;\n        if (N < 3) return 0LL;\n        LL res = ((N * (N-1) % MOD) *(N-2)) % MOD;\n        res = (res * rev3) % MOD;\n\n        return res;\n      };\n      DB(oblicz(0));\n      DB(oblicz(1));\n      DB(oblicz(2));\n      DB(oblicz(3));\n      DB(oblicz(4));\n      DB(oblicz(5));\n      DB(oblicz(10));\n\n      auto oblicz2=[&](LL wid1,LL wid2) {\n        LL p1 = (wid1 - 1)  % MOD * wid1 % MOD * rev2 % MOD * wid2;\n        LL p2 = (wid2 - 1)  % MOD* wid2 % MOD * rev2 % MOD * wid1;\n        return (p1 + p2) % MOD;\n      };\n\n      if (source_r == r) {\n        LL hei = HEI[r][c];\n        assert(HEI[r][c] == HEI[source_r][source_c]);\n\n        LL tmp = oblicz(hei) % MOD;\n        tmp = (tmp * WID[r][c] % MOD * WID[source_r][source_c]) % MOD;\n\n        res += tmp;\n      }\n      else {\n        LL tmp = oblicz2(HEI[r][c], HEI[source_r][source_c]) % MOD;\n        tmp = (tmp * WID[r][c] % MOD * WID[source_r][source_c]) % MOD;\n        res += tmp;\n      }\n      if (source_c == c) {\n        int wid = WID[r][c];\n        assert(WID[r][c] == WID[source_r][source_c]);\n        LL tmp = oblicz(wid) % MOD;\n        tmp = (tmp * HEI[r][c] % MOD * HEI[source_r][source_c]) % MOD;\n\n        res += tmp;\n      }\n      else {\n        LL tmp = oblicz2(WID[r][c], WID[source_r][source_c]) % MOD;\n\n        tmp = (tmp * HEI[r][c] % MOD * HEI[source_r][source_c]) % MOD;\n        res += tmp;\n      }\n      res %= MOD;\n    }\n\n    return res;\n  }\n\n\n  void solve() {\n    int H, W;cin >>H>>W;\n    int N; cin >> N;\n\n    VV<int> CORD_R;\n    VV<int> CORD_C;\n\n    VV<array<int,2> > BLACK;\n    REP (i, N) {\n      int r, c;\n      cin >> r >> c;\n      BLACK.push_back({r,c});\n      CORD_R.push_back(r);\n      CORD_R.push_back(r + 1);\n\n      CORD_C.push_back(c);\n      CORD_C.push_back(c + 1);\n    }\n    CORD_R.push_back(0);\n    CORD_R.push_back(H);\n\n    CORD_C.push_back(0);\n    CORD_C.push_back(W);\n\n    sort( ALL(CORD_R) ); CORD_R.erase(unique(ALL(CORD_R)), CORD_R.end());\n    sort( ALL(CORD_C) ); CORD_C.erase(unique(ALL(CORD_C)), CORD_C.end());\n\n    for (int cr : CORD_R) DB(cr);\n    for (int cc : CORD_C) DB(cc);\n\n\n    ROWS = CORD_R.size() - 1;\n    COLS = CORD_C.size() - 1;\n\n    for (auto black : BLACK) {\n      int r = lower_bound(ALL(CORD_R), black[0]) - CORD_R.begin();\n      int c = lower_bound(ALL(CORD_C), black[1]) - CORD_C.begin();\n      IS_BLACK[r][c] = 1;\n    }\n    REP (r, ROWS) REP (c, COLS) {\n      HEI[r][c] = CORD_R[r + 1] - CORD_R[r];\n      WID[r][c] = CORD_C[c + 1] - CORD_C[c];\n    }\n\n\n    LL res = 0;\n    auto power=[](LL a, LL b) {\n      LL res = 1;\n      while (b) {\n        if (b&1) res=(res*a)%MOD;\n        b/=2; a=(a*a)%MOD;\n      }\n      return res;\n    };\n    LL rev2 = power(2, MOD - 2);\n    REP (r, ROWS) REP (c, COLS) if (IS_BLACK[r][c] == 0) {\n      res += calculate(r, c);\n      res %= MOD;\n    }\n    cout << ((res * rev2) % MOD +MOD)%MOD << \"\\n\";\n  }\n\n\n  void gen() {}\n  void brute() {}\n};\n\n#undef int\nint main(int argc,char** argv){\n  FOR(i,1,argc-1)for(int j=0;argv[i][j];j++)if(argv[i][j]=='.')freopen(argv[i],\"r\",stdin);\n  FOR(i,1,argc-1)if(argv[i]==string(\"q\"))DEBUG=1<<30;\n  FOR(i,1,argc-1)if(argv[i]==string(\"gen\")){(solver=new solver_t())->gen();exit(0);}\n  FOR(i,1,argc-1)if(argv[i]==string(\"brute\")){(solver=new solver_t())->brute();exit(0);}\n  ios::sync_with_stdio(false),cin.tie(0);\n  cout.setf(ios::fixed),cout.precision(10);int t;if(MULTI||GCJ)cin>>t;else t=1;\n  FOR(i,1,t){if(DEBUG)cerr<<__LINE__<<\" \"<<i<<endl;if(GCJ)cout<<\"Case #\"<<i<<\": \";\n    solver = new solver_t();\n    solver->solve();\n  }return 0;\n}\n\n"
  },
  {
    "language": "C++",
    "code": "#include <iostream>\n#include <vector>\n#include <map>\n#include <queue>\n#include <algorithm>\n#include <cstring>\nusing namespace std;\n\n#define REP(i, s) for (int i = 0; i < s; ++i)\n#define ALL(v) (v.begin(), v.end())\n#define COUT(x) cout << #x << \" = \" << (x) << \" (L\" << __LINE__ << \")\" << endl\n#define EACH(i, s) for (__typeof__((s).begin()) i = (s).begin(); i != (s).end(); ++i)\n\ntemplate<class T> inline bool chmax(T& a, T b) { if (a < b) { a = b; return 1; } return 0; }\ntemplate<class T> inline bool chmin(T& a, T b) { if (a > b) { a = b; return 1; } return 0; }\ntemplate<class T1, class T2> ostream& operator << (ostream &s, pair<T1, T2> P)\n{\n\treturn s << '<' << P.first << \", \" << P.second << '>';\n}\ntemplate<class T> ostream& operator << (ostream &s, vector<T> P)\n{\n\tfor (int i = 0; i < P.size(); ++i) { if (i > 0) { s << \" \"; } s << P[i]; } return s;\n}\ntemplate<class T> ostream& operator << (ostream &s, vector<vector<T> > P)\n{\n\tfor (int i = 0; i < P.size(); ++i) { s << endl << P[i]; } return s << endl;\n}\n\nconst int MOD = 1000000007;\ninline long long mod(long long a, long long m) { return (a % m + m) % m; }\nstruct Fp {\n\tint MOD = 1000000007;\n\tlong long val;\n\n\tFp() : val(0) {}\n\tFp(long long val_) { this->val = mod(val_, MOD); }\n\tFp operator = (long long val_) { this->val = mod(val_, MOD); return *this; }\n\tinline Fp operator - () { return mod(-val, MOD); }\n\tinline const Fp& operator += (const Fp &x);\n\tinline const Fp& operator -= (const Fp &x);\n\tinline const Fp& operator *= (const Fp &x);\n\tinline const Fp& operator /= (const Fp &x);\n};\n\ninline bool operator == (Fp x, Fp y) { return x.val == y.val; }\ninline bool operator != (Fp x, Fp y) { return !(x == y); }\n\nostream &operator << (ostream &os, Fp x) { return os << x.val; }\nistream &operator >> (istream &is, Fp &x) { is >> x; return is; }\n\ninline Fp operator + (Fp x, Fp y) { return mod(x.val + y.val, x.MOD); }\ninline Fp operator - (Fp x, Fp y) { return mod(x.val - y.val, x.MOD); }\ninline Fp operator * (Fp x, Fp y) { return mod(x.val * y.val, x.MOD); }\ninline Fp operator / (Fp x, Fp y) {\n\tlong long a = y.val, b = x.MOD, u = 1, v = 0;\n\twhile (b) {\n\t\tlong long t = a / b;\n\t\ta -= t*b; swap(a, b);\n\t\tu -= t*v; swap(u, v);\n\t}\n\treturn x * u;\n}\ninline Fp abs(Fp a) { return a; }\ninline Fp fpow(Fp a, long long n) {\n\tif (n == 0) return Fp(1);\n\tFp t = fpow(a, n / 2);\n\tt = t * t; if (n & 1) t = t * a;\n\treturn t;\n}\ninline const Fp& Fp::operator += (const Fp &x) { *this = *this + x; return *this; }\ninline const Fp& Fp::operator -= (const Fp &x) { *this = *this - x; return *this; }\ninline const Fp& Fp::operator *= (const Fp &x) { *this = *this * x; return *this; }\ninline const Fp& Fp::operator /= (const Fp &x) { *this = *this / x; return *this; }\n\n// calc comb (small n, r ver)\nconst int FACT_MAX = 210000;\nstatic Fp fp_fact_val[FACT_MAX];\n\nvoid calcFact(int MAX = FACT_MAX) {\n\tfp_fact_val[0] = 1;\n\tfor (int val = 1; val < MAX; ++val) {\n\t\tfp_fact_val[val] = fp_fact_val[val - 1] * val;\n\t}\n}\n\nFp fact(int n) {\n\treturn fp_fact_val[n];\n}\n\nFp com(int n, int r) {\n\treturn fact(n) / fact(r) / fact(n - r);\n}\n\nint dx[4] = {1, 0, -1, 0};\nint dy[4] = {0, 1, 0, -1};\n\nlong long H, W, N;\nlong long bx[210], by[210];\nvector<long long> altx, alty;\nlong long nH, nW;\n\nlong long xnum[1100000], ynum[1100000];\n\nbool cb[210][210];\nlong long dist[210][210];\n\ntypedef pair<int, int> pint;\n\nlong long subsolve() {\n\t//COUT(nH); COUT(nW); COUT(altx); COUT(alty);\n\n\tfor (int x = 0; x < nH - 1; ++x) {\n\t\tfor (int y = 0; y < nW - 1; ++y) {\n\t\t\t//cout << cb[x][y];\n\t\t}\n\t\t//cout << endl;\n\t}\n\n  long long res = 0;\n\tfor (int x = 0; x < nH - 1; ++x) {\n\t\tfor (int y = 0; y < nW - 1; ++y) {\n\t\t\tif (cb[x][y]) continue;\n\t\t\tmemset(dist, -1, sizeof(dist));\n\t\t\tqueue<pint> que;\n\t\t\tque.push(pint(x, y));\n\t\t\tdist[x][y] = 0;\n\t\t\twhile (!que.empty()) {\n\t\t\t\tpint cur = que.front();\n\t\t\t\tque.pop();\n\t\t\t\tfor (int dir = 0; dir < 4; ++dir) {\n\t\t\t\t\tint nx = cur.first + dx[dir];\n\t\t\t\t\tint ny = cur.second + dy[dir];\n\t\t\t\t\tif (nx < 0 || nx >= nH-1 || ny < 0 || ny >= nW-1) continue;\n\t\t\t\t\tif (cb[nx][ny]) continue;\n\t\t\t\t\tif (dist[nx][ny] == -1) {\n\t\t\t\t\t\tdist[nx][ny] = dist[cur.first][cur.second] + 1;\n\t\t\t\t\t\tque.push(pint(nx, ny));\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t}\n\t\t\t\n\t\t\tfor (int nx = 0; nx < nH - 1; ++nx) {\n\t\t\t\tfor (int ny = 0; ny < nW - 1; ++ny) {\n\t\t\t\t\tif (nW * nx + ny <= nW * x + y) continue;\n\t\t\t\t\tif (dist[nx][ny] == -1) continue;\n\t\t\t\t\tif (cb[nx][ny]) continue;\n\n\t\t\t\t\tlong long ss = ((long long)(altx[x + 1] - altx[x]) * (alty[y + 1] - alty[y])) % MOD;\n\t\t\t\t\tlong long st = ((long long)(altx[nx + 1] - altx[nx]) * (alty[ny + 1] - alty[ny])) % MOD;\n\t\t\t\t\tres += (dist[nx][ny] % MOD) * ss % MOD * st % MOD;\n\t\t\t\t\tres %= MOD;\n\n\t\t\t\t\t//cout << pint(x, y) << \", \" << pint(nx, ny) << \": \" << dist[nx][ny] << \", \" << ss << \", \" << st << endl;\n\t\t\t\t}\n\t\t\t}\n\t\t\t\n\t\t}\n\t}\n\t//COUT(res);\n\t//res /= 2;\n\n\treturn res;\n}\n\nFp solve() {\n  memset(xnum, 0, sizeof(xnum));\n  memset(ynum, 0, sizeof(ynum));\n\taltx.clear();\n\talty.clear();\n  altx.push_back(0);\n  altx.push_back(H);\n  alty.push_back(0);\n  alty.push_back(W);\n  for (int i = 0; i < N; ++i) {\n\t\taltx.push_back(bx[i]);\n\t\taltx.push_back(bx[i] + 1);\n\t\talty.push_back(by[i]);\n\t\talty.push_back(by[i] + 1);\n\t\txnum[bx[i]]++;\n\t\tynum[by[i]]++;\n  }\n  sort(altx.begin(), altx.end());\n  sort(alty.begin(), alty.end());\n  altx.erase(unique(altx.begin(), altx.end()), altx.end());\n  alty.erase(unique(alty.begin(), alty.end()), alty.end());\n  nH = altx.size();\n  nW = alty.size();\n\n  memset(cb, 0, sizeof(cb));\n  for (int i = 0; i < N; ++i) {\n\t\tint itx = lower_bound(altx.begin(), altx.end(), bx[i]) - altx.begin();\n\t\tint ity = lower_bound(alty.begin(), alty.end(), by[i]) - alty.begin();\n\t\tcb[itx][ity] = true;\n  }\n\n  long long all = (long long)H * W - N;\n  Fp add = 0;\n  long long width = W;\n\tlong long num_comped = 0;\n  long long sum = width - xnum[0];\n  for (int i = 1; i < H; ++i) {\n\t\tif (xnum[i] == 0 && xnum[i-1] == 0) {   // i-1 -> i\n\t\t\tFp up = sum - width * num_comped;\n\t\t\tFp down = all - sum;\n\t\t\tadd += up * down;\n\t\t}\n\t\tsum += width - xnum[i];\n  }\n  long long height = H - num_comped;\n  all -= width * num_comped;\n  num_comped = 0;\n  sum = height - ynum[0];\n  for (int i = 1; i < W; ++i) {\n\t\tif (ynum[i] == 0 && ynum[i-1] == 0) {   // i-1 -> i\n\t\t\tFp left = sum - height * num_comped;\n\t\t\tFp right = all - sum;\n\t\t\tadd += left * right;\n\t\t}\n\t\tsum += height - ynum[i];\n  }\n\n  Fp comp = subsolve();\n  Fp res = comp + add;\n\n\t//COUT(add);\n\n  return res;\n}\n\nint main() {\n  while (cin >> H >> W >> N) {\n\t\tfor (int i = 0; i < N; ++i) cin >> bx[i] >> by[i];\n\t\tcout << solve() << endl;\n  }\n}\n"
  },
  {
    "language": "C++",
    "code": "#include <cstdio>\n#include <cctype>\n#include <cstring>\n#include <algorithm>\n#include <vector>\n\n#define debug(...) fprintf(stderr, __VA_ARGS__)\n\n#ifndef AT_HOME\n#define getchar() IO::myGetchar()\n#define putchar(x) IO::myPutchar(x)\n#endif\n\nnamespace IO {\n\tstatic const int IN_BUF = 1 << 23, OUT_BUF = 1 << 23;\n\n\tinline char myGetchar() {\n\t\tstatic char buf[IN_BUF], *ps = buf, *pt = buf;\n\t\tif (ps == pt) {\n\t\t\tps = buf, pt = buf + fread(buf, 1, IN_BUF, stdin);\n\t\t}\n\t\treturn ps == pt ? EOF : *ps++;\n\t}\n\n\ttemplate<typename T>\n\tinline bool read(T &x) {\n\t\tbool op = 0;\n\t\tchar ch = getchar();\n\t\tx = 0;\n\t\tfor (; !isdigit(ch) && ch != EOF; ch = getchar()) {\n\t\t\top ^= (ch == '-');\n\t\t}\n\t\tif (ch == EOF) {\n\t\t\treturn false;\n\t\t}\n\t\tfor (; isdigit(ch); ch = getchar()) {\n\t\t\tx = x * 10 + (ch ^ '0');\n\t\t}\n\t\tif (op) {\n\t\t\tx = -x;\n\t\t}\n\t\treturn true;\n\t}\n\n\tinline int readStr(char *s) {\n\t\tint n = 0;\n\t\tchar ch = getchar();\n\t\tfor (; isspace(ch) && ch != EOF; ch = getchar())\n\t\t\t;\n\t\tfor (; !isspace(ch) && ch != EOF; ch = getchar()) {\n\t\t\ts[n++] = ch;\n\t\t}\n\t\ts[n] = '\\0';\n\t\treturn n;\n\t}\n\n\tinline void myPutchar(char x) {\n\t\tstatic char pbuf[OUT_BUF], *pp = pbuf;\n\t\tstruct _flusher {\n\t\t\t~_flusher() {\n\t\t\t\tfwrite(pbuf, 1, pp - pbuf, stdout);\n\t\t\t}\n\t\t};\n\t\tstatic _flusher outputFlusher;\n\t\tif (pp == pbuf + OUT_BUF) {\n\t\t\tfwrite(pbuf, 1, OUT_BUF, stdout);\n\t\t\tpp = pbuf;\n\t\t}\n\t\t*pp++ = x;\n\t}\n\n\ttemplate<typename T>\n\tinline void print_(T x) {\n\t\tif (x == 0) {\n\t\t\tputchar('0');\n\t\t\treturn;\n\t\t}\n\t\tstd::vector<int> num;\n\t\tif (x < 0) {\n\t\t\tputchar('-');\n\t\t\tx = -x;\n\t\t}\n\t\tfor (; x; x /= 10) {\n\t\t\tnum.push_back(x % 10);\n\t\t}\n\t\twhile (!num.empty()) {\n\t\t\tputchar(num.back() ^ '0');\n\t\t\tnum.pop_back();\n\t\t}\n\t}\n\n\ttemplate<typename T>\n\tinline void print(T x, char ch = '\\n') {\n\t\tprint_(x);\n\t\tputchar(ch);\n\t}\n\n\tinline void printStr_(const char *s, int n = -1) {\n\t\tif (n == -1) {\n\t\t\tn = strlen(s);\n\t\t}\n\t\tfor (int i = 0; i < n; ++i) {\n\t\t\tputchar(s[i]);\n\t\t}\n\t}\n\n\tinline void printStr(const char *s, int n = -1, char ch = '\\n') {\n\t\tprintStr_(s, n);\n\t\tputchar(ch);\n\t}\n}\nusing namespace IO;\n\nconst int N = 105, M = 1000005;\nconst int P = 1000000007, Inv2 = (P + 1) / 2;\n\nconst int dx[] = {-1, 0, 1, 0}, dy[] = {0, -1, 0, 1};\n\nint n, m, k, x[N], y[N];\nint cntx[M], idx[M], wx[M], cnty[M], idy[M], wy[M];\nint a[N][N], ans;\n\nvoid solve(int *cnt, int *id, int *w, int n, int m) {\n\tint now = 0, idx = 0;\n\tfor (int i = 0; i < n - 1; ++i) {\n\t\tnow = (now + m - cnt[i]) % P;\n\t\tif (cnt[i] || cnt[i + 1]) {\n\t\t\tid[i] = idx++;\n\t\t\tcontinue;\n\t\t}\n\t\tint t = (1ll * n * m - k - now) % P;\n\t\tans = (ans + 2ll * now * t) % P;\n\t\tid[i] = idx;\n\t}\n\tid[n - 1] = idx++;\n\tfor (int i = 0; i < n; ++i) {\n\t\t++w[id[i]];\n\t}\n}\n\nint bfs(int x, int y) {\n\tstatic int dis[N][N];\n\tfor (int i = 0; i < n; ++i) {\n\t\tfor (int j = 0; j < m; ++j) {\n\t\t\tdis[i][j] = P;\n\t\t}\n\t}\n\tstd::vector<std::pair<int, int>> Q;\n\tint res = 0;\n\tdis[x][y] = 0, Q.push_back({x, y});\n\tfor (int i = 0; i < (int)Q.size(); ++i) {\n\t\tint x = Q[i].first, y = Q[i].second;\n\t\tres = (res + 1ll * a[x][y] * dis[x][y]) % P;\n\t\tfor (int k = 0; k < 4; ++k) {\n\t\t\tint nx = x + dx[k], ny = y + dy[k];\n\t\t\tif (nx < 0 || nx >= n || ny < 0 || ny >= m) {\n\t\t\t\tcontinue;\n\t\t\t}\n\t\t\tif (a[nx][ny] == -1 || dis[nx][ny] < P) {\n\t\t\t\tcontinue;\n\t\t\t}\n\t\t\tdis[nx][ny] = dis[x][y] + 1;\n\t\t\tQ.push_back({nx, ny});\n\t\t}\n\t}\n\treturn res;\n}\n\nint main() {\n\tread(n), read(m), read(k);\n\tfor (int i = 0; i < k; ++i) {\n\t\tread(x[i]), read(y[i]);\n\t\t++cntx[x[i]], ++cnty[y[i]];\n\t}\n\tsolve(cntx, idx, wx, n, m);\n\tsolve(cnty, idy, wy, m, n);\n\tn = idx[n - 1] + 1;\n\tm = idy[m - 1] + 1;\n\tfor (int i = 0; i < n; ++i) {\n\t\tfor (int j = 0; j < m; ++j) {\n\t\t\ta[i][j] = 1ll * wx[i] * wy[j] % P;\n\t\t}\n\t}\n\tfor (int i = 0; i < k; ++i) {\n\t\ta[idx[x[i]]][idy[y[i]]] = -1;\n\t}\n\tfor (int i = 0; i < n; ++i) {\n\t\tfor (int j = 0; j < m; ++j) {\n\t\t\tif (a[i][j] != -1) {\n\t\t\t\tans = (ans + 1ll * a[i][j] * bfs(i, j)) % P;\n\t\t\t}\n\t\t}\n\t}\n\tprint(1ll * ans * Inv2 % P);\n}\n"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\nusing namespace std;\n#define int long long\n#define p (int)(1e9 + 7)\n\nint MOD(int a){\n\treturn (a %= p) >= 0 ? a : a + p;\n}\n\nint power(int a, int N){\n\tif(N == 0){\n\t\treturn 1;\n\t}\n\telse if(N % 2 == 0){\n\t\treturn power(MOD(a * a), N / 2);\n\t}\n\telse{\n\t\treturn MOD(a * power(a, N - 1));\n\t}\n}\n\nint inverse(int a){\n\treturn power(a, p - 2);\n}\n\n#define inf (int)(1e9)\n\nstruct edge{\n\tint to;\n\tint cost;\n\n\tedge(int to, int cost) : to(to), cost(cost){}\n};\n\nvector<int> dijkstra(vector<vector<edge> > &g, int s){\n\tvector<int> ans(g.size(), inf);\n\tpriority_queue<pair<int, int>, vector<pair<int, int> >, greater<pair<int, int> > > q;//(距離, 頂点番号)\n\tq.push(pair<int, int>(0, s));\n\twhile(q.size() > 0){\n\t\tint dis = q.top().first, v = q.top().second;\n\t\tq.pop();\n\t\tif(dis < ans[v]){\n\t\t\tans[v] = dis;\n\t\t\tfor(int i = 0; i < g[v].size(); i++){\n\t\t\t\tq.push(pair<int, int>(dis + g[v][i].cost, g[v][i].to));\n\t\t\t}\n\t\t}\n\t}\n\treturn ans;\n}\n\nint h, w;\nint inv2, inv6;\n\nint align(int i, int j){\n\treturn i * w + j;\n}\n\nint calc(int dis, int x1, int dx1, int x2, int dx2, int y1, int dy1, int y2, int dy2){\n//\tprintf(\"calc(%lld, %lld, %lld, %lld, %lld, %lld, %lld, %lld, %lld)\\n\", dis, x1, dx1, x2, dx2, y1, dy1, y2, dy2);\n\tif(x2 < x1){\n\t\treturn calc(dis, x2, dx2, x1, dx1, y2, dy2, y1, dy1);\n\t}\n\telse if(y2 < y1){\n\t\treturn calc(dis + dx2 - dx1, x1, dx2, x2 + dx2 - dx1, dx1, y2, dy2, y1, dy1);\n\t}\n\telse if(x1 == x2){\n\t\treturn calc(dis, y1, dy1, y2, dy2, x1, dx1, x2, dx2);\n\t}\n\tif(y1 == y2){\n\t\tif(dy1 == 1){\n//\t\t\tprintf(\"test1\\n\");\n\t\t\treturn MOD(inv2 * MOD(MOD(dx1 * dx2) * (2 * dis + (dx2 - dx1))));\n\t\t}\n\t\telse{\n//\t\t\tprintf(\"test2\\n\");\n\t\t\treturn MOD(inv6 * MOD(MOD(MOD(dx1 * dx2) * dy1) * (MOD(3 * dy1 * (2 * (x2 - x1) + (dx2 - dx1))) + MOD(2 * (dy1 - 1) * (dy1 + 1)))));\n\t\t}\n\t}\n\telse{\n//\t\tprintf(\"test3\\n\");\n\t\treturn MOD(inv2 * MOD(MOD(MOD(dx1 * dx2) * MOD(dy1 * dy2)) * MOD(2 * dis + (dx2 - dx1) + (dy2 - dy1))));\n\t}\n}\n\nsigned main(){\n\tint H, W, N, i, j, k, l;\n\tscanf(\"%lld%lld\", &H, &W);\n\tscanf(\"%lld\", &N);\n\tvector<int> x_sub(N), y_sub(N), x(0), y(0);\n\tfor(i = 0; i < N; i++){\n\t\tscanf(\"%lld%lld\", &x_sub[i], &y_sub[i]);\n\t\tx.push_back(x_sub[i]);\n\t\tx.push_back(x_sub[i] + 1);\n\t\tx.push_back(max(0ll, x_sub[i] - 1));\n\t\ty.push_back(y_sub[i]);\n\t\ty.push_back(y_sub[i] + 1);\n\t\ty.push_back(max(0ll, y_sub[i] - 1));\n\t}\n\tx.push_back(0);\n\tx.push_back(H);\n\ty.push_back(0);\n\ty.push_back(W);\n\tsort(x.begin(), x.end());\n\tsort(y.begin(), y.end());\n\tfor(i = 1, j = 1; j < x.size(); j++){\n\t\tif(x[j - 1] < x[j]){\n\t\t\tx[i] = x[j];\n\t\t\ti++;\n\t\t}\n\t}\n\th = i - 1;\n\tfor(i = 1, j = 1; j < y.size(); j++){\n\t\tif(y[j - 1] < y[j]){\n\t\t\ty[i] = y[j];\n\t\t\ti++;\n\t\t}\n\t}\n\tw = i - 1;\n\tvector<int> dx(h), dy(w);\n\tfor(i = 0; i < h; i++){\n\t\tdx[i] = x[i + 1] - x[i];\n\t}\n\tfor(i = 0; i < w; i++){\n\t\tdy[i] = y[i + 1] - y[i];\n\t}\n/*\tprintf(\"x:\\n\");\n\tfor(i = 0; i < h; i++){\n\t\tprintf(\"%lld \", x[i]);\n\t}\n\tprintf(\"\\n\");\n\tprintf(\"dx:\\n\");\n\tfor(i = 0; i < h; i++){\n\t\tprintf(\"%lld \", dx[i]);\n\t}\n\tprintf(\"\\n\");\n\tprintf(\"y:\\n\");\n\tfor(j = 0; j < w; j++){\n\t\tprintf(\"%lld \", y[j]);\n\t}\n\tprintf(\"\\n\");\n\tprintf(\"dy:\\n\");\n\tfor(i = 0; i < w; i++){\n\t\tprintf(\"%lld \", dy[i]);\n\t}\n\tprintf(\"\\n\");\n*/\tvector<vector<char>> A(h, vector<char>(w, '.'));\n\tfor(i = 0; i < h; i++){\n\t\tfor(j = 0; j < w; j++){\n\t\t\tfor(k = 0; k < N; k++){\n\t\t\t\tif(x[i] == x_sub[k] && y[j] == y_sub[k]){\n\t\t\t\t\tA[i][j] = '#';\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t}\n/*\tprintf(\"A:\\n\");\n\tfor(i = 0; i < h; i++){\n\t\tfor(j = 0; j < w; j++){\n\t\t\tprintf(\"%c\", A[i][j]);\n\t\t}\n\t\tprintf(\"\\n\");\n\t}\n\tprintf(\"\\n\");\n*/\tvector<vector<edge>> g(h * w, vector<edge>());\n\tfor(i = 0; i < h; i++){\n\t\tfor(j = 1; j < w; j++){\n\t\t\tif(A[i][j - 1] == '.' && A[i][j] == '.'){\n\t\t\t\tg[align(i, j - 1)].push_back(edge(align(i, j), y[j] - y[j - 1]));\n\t\t\t\tg[align(i, j)].push_back(edge(align(i, j - 1), y[j] - y[j - 1]));\n\t\t\t}\n\t\t}\n\t}\n\tfor(i = 1; i < h; i++){\n\t\tfor(j = 0; j < w; j++){\n\t\t\tif(A[i - 1][j] == '.' && A[i][j] == '.'){\n\t\t\t\tg[align(i - 1, j)].push_back(edge(align(i, j), x[i] - x[i - 1]));\n\t\t\t\tg[align(i, j)].push_back(edge(align(i - 1, j), x[i] - x[i - 1]));\n\t\t\t}\n\t\t}\n\t}\n\tint ans = 0;\n\tinv2 = inverse(2);\n\tinv6 = inverse(6);\n\tfor(i = 0; i < h; i++){\n\t\tfor(j = 0; j < w; j++){\n\t\t\tif(A[i][j] == '#'){\n\t\t\t\tcontinue;\n\t\t\t}\n//\t\t\tprintf(\"(i, j) = (%lld, %lld)\\n\", i, j);\n\t\t\tint sub = MOD(inv6 * MOD(MOD(dx[i] * dy[j]) * MOD((dx[i] + dy[j]) * MOD(dx[i] * dy[j] - 1))));\n//\t\t\tprintf(\"ans += 2 * %lld\\n\", sub);\n\t\t\tans = MOD(ans + 2 * sub);\n\t\t\tvector<int> dis = dijkstra(g, align(i, j));\n\t\t\tfor(k = 0; k < h; k++){\n\t\t\t\tfor(l = 0; l < w; l++){\n\t\t\t\t\tif((i == k && j == l) || A[k][l] == '#'){\n\t\t\t\t\t\tcontinue;\n\t\t\t\t\t}\n//\t\t\t\t\tprintf(\"(k, l) = (%lld, %lld)\\n\", k, l);\n\t\t\t\t\tint res = calc(dis[align(k, l)], x[i], dx[i], x[k], dx[k], y[j], dy[j], y[l], dy[l]);\n//\t\t\t\t\tprintf(\"ans += %lld\\n\", res);\n\t\t\t\t\tans = MOD(ans + res);\n\t\t\t\t}\n\t\t\t}\n//\t\t\tprintf(\"\\n\");\n\t\t}\n\t}\n\tans = MOD(ans * inv2);\n\tprintf(\"%lld\\n\", ans);\n\treturn 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\nusing namespace std;\n\nusing ll = long long;\nusing i128 = __int128_t;\n\nint main(){\n\tios_base::sync_with_stdio(0), cin.tie(0), cout.tie(0);\n\tint A, B;\n\tcin >> A >> B;\n\tint k;\n\tcin >> k;\n\tvector<pair<int,int> > pts(k);\n\tset<int> verts_x, verts_y;\n\tfor(pair<int,int>& p : pts){\n\t\tcin >> p.first >> p.second;\n\t\tfor(int j = -1; j <= 1; j++) verts_x.insert(p.first + j);\n\t\tfor(int j = -1; j <= 1; j++) verts_y.insert(p.second + j);\n\t}\n\tverts_x.insert(0); verts_x.insert(A); verts_x.erase(-1);\n\tverts_y.insert(0); verts_y.insert(B); verts_y.erase(-1);\n\tvector<int> loc_x, loc_y;\n\tfor(int x : verts_x) loc_x.push_back(x);\n\tfor(int x : verts_y) loc_y.push_back(x);\n\tint num_x = (int)loc_x.size() - 1;\n\tint num_y = (int)loc_y.size() - 1;\n\tvector<vector<bool> > occ(num_x, vector<bool>(num_y, false));\n\tfor(int i = 0; i < num_x; i++){\n\t\tfor(int j = 0; j < num_y; j++){\n\t\t\tfor(pair<int,int> p : pts){\n\t\t\t\tif(loc_x[i] == p.first && loc_y[j] == p.second) occ[i][j] = true;\n\t\t\t}\n\t\t}\n\t}\n\n\ti128 ans = 0;\n\tvector<int> dx = {1, 0, -1, 0};\n\tvector<int> dy = {0, 1, 0, -1};\n\tfor(int x = 0; x < num_x; x++){\n\t\tfor(int y = 0; y < num_y; y++){\n\t\t\tif(occ[x][y]) continue;\n\t\t\tvector<vector<bool> > vis(num_x, vector<bool>(num_y, false));\n\t\t\tvector<vector<ll> > dist(num_x, vector<ll>(num_y, 1e18));\n\t\t\tpriority_queue<pair<ll, pair<int,int> > > s;\n\t\t\tdist[x][y] = 0;\n\t\t\ts.push({-dist[x][y], {x, y}});\n\t\t\twhile(!s.empty()){\n\t\t\t\tint cx = s.top().second.first;\n\t\t\t\tint cy = s.top().second.second;\n\t\t\t\ts.pop();\n\t\t\t\tif(vis[cx][cy]) continue;\n\t\t\t\tvis[cx][cy] = true;\n\t\t\t\tfor(int d = 0; d < 4; d++){\n\t\t\t\t\tint nx = cx + dx[d];\n\t\t\t\t\tint ny = cy + dy[d];\n\t\t\t\t\tif(nx < 0 || ny < 0 || nx >= num_x || ny >= num_y) continue;\n\t\t\t\t\tif(occ[nx][ny]) continue;\n\t\t\t\t\tll new_dist = dist[cx][cy] + abs(loc_x[cx] - loc_x[nx]) + abs(loc_y[cy] - loc_y[ny]);\n\t\t\t\t\tif(new_dist < dist[nx][ny]){\n\t\t\t\t\t\tdist[nx][ny] = new_dist;\n\t\t\t\t\t\ts.push({-dist[nx][ny], {nx, ny}});\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t}\n\t\t\tfor(int nx = 0; nx < num_x; nx++){\n\t\t\t\tfor(int ny = 0; ny < num_y; ny++){\n\t\t\t\t\tif(occ[nx][ny]) continue;\n\t\t\t\t\ti128 dx0 = loc_x[x + 1] - loc_x[x];\n\t\t\t\t\ti128 dy0 = loc_y[y + 1] - loc_y[y];\n\t\t\t\t\ti128 dx1 = loc_x[nx + 1] - loc_x[nx];\n\t\t\t\t\ti128 dy1 = loc_y[ny + 1] - loc_y[ny];\n\t\t\t\t\ti128 cnt0 = dx0 * dy0;\n\t\t\t\t\ti128 cnt1 = dx1 * dy1;\n\t\t\t\t\tif(cnt0 > 1 && cnt1 > 1){\n\t\t\t\t\t\t// can travel by manhattan distance\n\t\t\t\t\t\ti128 xdist = (x == nx) ? ((dx0 * dx0 * dx0 - dx0) / 3) : \n\t\t\t\t\t\t\tdx0 * dx1 * abs(loc_x[nx + 1] + loc_x[nx] - loc_x[x + 1] - loc_x[x]) / 2;\n\t\t\t\t\t\txdist *= dy0 * dy1;\n\t\t\t\t\t\ti128 ydist = (y == ny) ? ((dy0 * dy0 * dy0 - dy0) / 3) : \n\t\t\t\t\t\t\tdy0 * dy1 * abs(loc_y[ny + 1] + loc_y[ny] - loc_y[y + 1] - loc_y[y]) / 2;\n\t\t\t\t\t\tydist *= dx0 * dx1;\n\t\t\t\t\t\tans += xdist + ydist;\n\t\t\t\t\t} else {\n\t\t\t\t\t\ti128 twice_avg = 2 * dist[nx][ny]\n\t\t\t\t\t\t\t+ abs(loc_x[nx + 1] + loc_x[nx] - loc_x[x + 1] - loc_x[x]) - 2 * abs(loc_x[nx] - loc_x[x])\n\t\t\t\t\t\t\t+ abs(loc_y[ny + 1] + loc_y[ny] - loc_y[y + 1] - loc_y[y]) - 2 * abs(loc_y[ny] - loc_y[y]);\n\t\t\t\t\t\tans += twice_avg * cnt0 * cnt1 / 2;\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t}\n\tll ans_mod = (ans / 2) % (int(1e9) + 7);\n\tcout << ans_mod << '\\n';\n}"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\nusing namespace std;\n#define int long long\n#define p (int)(1e9 + 7)\n\nint MOD(int a){\n\treturn (a %= p) >= 0 ? a : a + p;\n}\n\nint power(int a, int N){\n\tif(N == 0){\n\t\treturn 1;\n\t}\n\telse if(N % 2 == 0){\n\t\treturn power(MOD(a * a), N / 2);\n\t}\n\telse{\n\t\treturn MOD(a * power(a, N - 1));\n\t}\n}\n\nint inverse(int a){\n\treturn power(a, p - 2);\n}\n\n#define inf (int)(1e9)\n\nstruct edge{\n\tint to;\n\tint cost;\n\n\tedge(int to, int cost) : to(to), cost(cost){}\n};\n\nvector<int> dijkstra(vector<vector<edge> > &g, int s){\n\tvector<int> ans(g.size(), inf);\n\tpriority_queue<pair<int, int>, vector<pair<int, int> >, greater<pair<int, int> > > q;//(距離, 頂点番号)\n\tq.push(pair<int, int>(0, s));\n\twhile(q.size() > 0){\n\t\tint dis = q.top().first, v = q.top().second;\n\t\tq.pop();\n\t\tif(dis < ans[v]){\n\t\t\tans[v] = dis;\n\t\t\tfor(int i = 0; i < g[v].size(); i++){\n\t\t\t\tq.push(pair<int, int>(dis + g[v][i].cost, g[v][i].to));\n\t\t\t}\n\t\t}\n\t}\n\treturn ans;\n}\n\nint h, w;\nint inv2, inv6;\n\nint align(int i, int j){\n\treturn i * w + j;\n}\n\nint calc(int dis, int x1, int dx1, int x2, int dx2, int y1, int dy1, int y2, int dy2){\n//\tprintf(\"calc(%lld, %lld, %lld, %lld, %lld, %lld, %lld, %lld, %lld)\\n\", dis, x1, dx1, x2, dx2, y1, dy1, y2, dy2);\n\tif(x2 < x1){\n\t\treturn calc(dis, x2, dx2, x1, dx1, y2, dy2, y1, dy1);\n\t}\n\telse if(y2 < y1){\n\t\treturn calc(dis + dx2 - dx1, x1, dx2, x2 + dx2 - dx1, dx1, y2, dy2, y1, dy1);\n\t}\n\telse if(x1 == x2){\n\t\treturn calc(dis, y1, dy1, y2, dy2, x1, dx1, x2, dx2);\n\t}\n\tif(y1 == y2){\n\t\tif(dy1 == 1){\n//\t\t\tprintf(\"test1\\n\");\n\t\t\treturn MOD(inv2 * MOD(MOD(dx1 * dx2) * (2 * dis + (dx2 - dx1))));\n\t\t}\n\t\telse{\n//\t\t\tprintf(\"test2\\n\");\n\t\t\treturn MOD(inv6 * MOD(MOD(MOD(dx1 * dx2) * dy1) * (MOD(3 * dy1 * (2 * (x2 - x1) + (dx2 - dx1))) + MOD(2 * (dy1 - 1) * (dy1 + 1)))));\n\t\t}\n\t}\n\telse{\n//\t\tprintf(\"test3\\n\");\n\t\treturn MOD(inv2 * MOD(MOD(MOD(dx1 * dx2) * MOD(dy1 * dy2)) * MOD(2 * dis + (dx2 - dx1) + (dy2 - dy1))));\n\t}\n}\n\nsigned main(){\n\tint H, W, N, i, j, k, l;\n\tscanf(\"%lld%lld\", &H, &W);\n\tscanf(\"%lld\", &N);\n\tvector<int> x_sub(N), y_sub(N), x(0), y(0);\n\tfor(i = 0; i < N; i++){\n\t\tscanf(\"%lld%lld\", &x_sub[i], &y_sub[i]);\n\t\tx.push_back(x_sub[i]);\n\t\tx.push_back(x_sub[i] + 1);\n\t\ty.push_back(y_sub[i]);\n\t\ty.push_back(y_sub[i] + 1);\n\t}\n\tx.push_back(0);\n\tx.push_back(H);\n\ty.push_back(0);\n\ty.push_back(W);\n\tsort(x.begin(), x.end());\n\tsort(y.begin(), y.end());\n\tfor(i = 1, j = 1; j < x.size(); j++){\n\t\tif(x[j - 1] < x[j]){\n\t\t\tx[i] = x[j];\n\t\t\ti++;\n\t\t}\n\t}\n\th = i - 1;\n\tfor(i = 1, j = 1; j < y.size(); j++){\n\t\tif(y[j - 1] < y[j]){\n\t\t\ty[i] = y[j];\n\t\t\ti++;\n\t\t}\n\t}\n\tw = i - 1;\n\tvector<int> dx(h), dy(w);\n\tfor(i = 0; i < h; i++){\n\t\tdx[i] = x[i + 1] - x[i];\n\t}\n\tfor(i = 0; i < w; i++){\n\t\tdy[i] = y[i + 1] - y[i];\n\t}\n/*\tprintf(\"x:\\n\");\n\tfor(i = 0; i < h; i++){\n\t\tprintf(\"%lld \", x[i]);\n\t}\n\tprintf(\"\\n\");\n\tprintf(\"dx:\\n\");\n\tfor(i = 0; i < h; i++){\n\t\tprintf(\"%lld \", dx[i]);\n\t}\n\tprintf(\"\\n\");\n\tprintf(\"y:\\n\");\n\tfor(j = 0; j < w; j++){\n\t\tprintf(\"%lld \", y[j]);\n\t}\n\tprintf(\"\\n\");\n\tprintf(\"dy:\\n\");\n\tfor(i = 0; i < w; i++){\n\t\tprintf(\"%lld \", dy[i]);\n\t}\n\tprintf(\"\\n\");\n*/\tvector<vector<char>> A(h, vector<char>(w, '.'));\n\tfor(i = 0; i < h; i++){\n\t\tfor(j = 0; j < w; j++){\n\t\t\tfor(k = 0; k < N; k++){\n\t\t\t\tif(x[i] == x_sub[k] && y[j] == y_sub[k]){\n\t\t\t\t\tA[i][j] = '#';\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t}\n/*\tprintf(\"A:\\n\");\n\tfor(i = 0; i < h; i++){\n\t\tfor(j = 0; j < w; j++){\n\t\t\tprintf(\"%c\", A[i][j]);\n\t\t}\n\t\tprintf(\"\\n\");\n\t}\n\tprintf(\"\\n\");\n*/\tvector<vector<edge>> g(h * w, vector<edge>());\n\tfor(i = 0; i < h; i++){\n\t\tfor(j = 1; j < w; j++){\n\t\t\tif(A[i][j - 1] == '.' && A[i][j] == '.'){\n\t\t\t\tg[align(i, j - 1)].push_back(edge(align(i, j), y[j] - y[j - 1]));\n\t\t\t\tg[align(i, j)].push_back(edge(align(i, j - 1), y[j] - y[j - 1]));\n\t\t\t}\n\t\t}\n\t}\n\tfor(i = 1; i < h; i++){\n\t\tfor(j = 0; j < w; j++){\n\t\t\tif(A[i - 1][j] == '.' && A[i][j] == '.'){\n\t\t\t\tg[align(i - 1, j)].push_back(edge(align(i, j), x[i] - x[i - 1]));\n\t\t\t\tg[align(i, j)].push_back(edge(align(i - 1, j), x[i] - x[i - 1]));\n\t\t\t}\n\t\t}\n\t}\n\tint ans = 0;\n\tinv2 = inverse(2);\n\tinv6 = inverse(6);\n\tfor(i = 0; i < h; i++){\n\t\tfor(j = 0; j < w; j++){\n\t\t\tif(A[i][j] == '#'){\n\t\t\t\tcontinue;\n\t\t\t}\n//\t\t\tprintf(\"(i, j) = (%lld, %lld)\\n\", i, j);\n\t\t\tint sub = MOD(inv6 * MOD(MOD(dx[i] * dy[j]) * MOD((dx[i] + dy[j]) * MOD(dx[i] * dy[j] - 1))));\n//\t\t\tprintf(\"ans += 2 * %lld\\n\", sub);\n\t\t\tans = MOD(ans + 2 * sub);\n\t\t\tvector<int> dis = dijkstra(g, align(i, j));\n\t\t\tfor(k = 0; k < h; k++){\n\t\t\t\tfor(l = 0; l < w; l++){\n\t\t\t\t\tif((i == k && j == l) || A[k][l] == '#'){\n\t\t\t\t\t\tcontinue;\n\t\t\t\t\t}\n//\t\t\t\t\tprintf(\"(k, l) = (%lld, %lld)\\n\", k, l);\n\t\t\t\t\tint res = calc(dis[align(k, l)], x[i], dx[i], x[k], dx[k], y[j], dy[j], y[l], dy[l]);\n//\t\t\t\t\tprintf(\"ans += %lld\\n\", res);\n\t\t\t\t\tans = MOD(ans + res);\n\t\t\t\t}\n\t\t\t}\n//\t\t\tprintf(\"\\n\");\n\t\t}\n\t}\n\tans = MOD(ans * inv2);\n\tprintf(\"%lld\\n\", ans);\n\treturn 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include<bits/stdc++.h>\nusing namespace std;\nconst int mod=1e9+7;\nint dx[]={1,0,-1,0},dy[]={0,1,0,-1};\nint h,w,n,x[33],y[33],prex[1111111],prey[1111111],ans,arrx[111],arry[111],cntx,cnty,dist[111][111],res;\nint fx[111],fy[111];\nbool ex[1111111],ey[1111111],ff[111][111];\nmap<pair<int,int>,int> mp;\nbool In(int x,int y)\n{\n\treturn (x>=1 && x<=cntx && y>=1 && y<=cnty);\n}\nvoid bfs(int i,int j)\n{\n\tmemset(dist,-1,sizeof(dist));\n\tdist[i][j]=0;\n\tqueue<pair<int,int> > q;\n\tq.push(make_pair(i,j));\n\twhile(!q.empty())\n\t{\n\t\tint xx=q.front().first,yy=q.front().second;\n\t\tq.pop();\n\t\tfor (int i=0;i<4;i++)\n\t\t{\n\t\t\tint xxx=xx+dx[i],yyy=yy+dy[i];\n\t\t\tif (!In(xxx,yyy) || ff[xxx][yyy]) continue;\n\t\t\tif (!~dist[xxx][yyy])\n\t\t\t{\n\t\t\t\tdist[xxx][yyy]=dist[xx][yy]+1;\n\t\t\t\tq.push(make_pair(xxx,yyy));\n\t\t\t}\n\t\t}\n\t}\n}\nint main()\n{\n\tscanf(\"%d%d%d\",&h,&w,&n);\n\tfor (int i=1;i<=n;i++)\n\t{\n\t\tscanf(\"%d%d\",&x[i],&y[i]);x[i]++;y[i]++;\n\t\tex[x[i]]=ey[y[i]]=1;\n\t\tmp[make_pair(x[i],y[i])]=1;\n\t\tprex[x[i]]++;prey[y[i]]++;\n\t}\n\tfor (int i=1;i<=h;i++) prex[i]+=prex[i-1];\n\tfor (int i=1;i<=w;i++) prey[i]+=prey[i-1];\n\tfor (int i=1;i<h;i++)\n\t{\n\t\tif (!ex[i] && !ex[i+1])\n\t\t{\n\t\t\tans=(1ll*(1ll*w*i-prex[i])%mod*((1ll*w*(h-i)-(n-prex[i]))%mod)+ans)%mod;\n\t\t}\n\t}\n\tfor (int i=1;i<w;i++)\n\t{\n\t\tif (!ey[i] && !ey[i+1])\n\t\t{\n\t\t\tans=(1ll*(1ll*h*i-prey[i])%mod*((1ll*h*(w-i)-(n-prey[i]))%mod)+ans)%mod;\n\t\t}\n\t}\n\tfor (int i=1;i<=h;i++)\n\t{\n\t\tif (ex[i] || ex[i-1] || i==1) \n\t\t{\n\t\t\tarrx[++cntx]=i;\n\t\t\tif (ex[i]) fx[cntx]=1;\n\t\t\telse\n\t\t\t{\n\t\t\t\tfor (int j=i;j<=h && !ex[j];j++)\n\t\t\t\t{\n\t\t\t\t\tfx[cntx]++;\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t}\n\tfor (int i=1;i<=w;i++)\n\t{\n\t\tif (ey[i] || ey[i-1] || i==1) \n\t\t{\n\t\t\tarry[++cnty]=i;\n\t\t\tif (ey[i]) fy[cnty]=1;\n\t\t\telse\n\t\t\t{\n\t\t\t\tfor (int j=i;j<=w && !ey[j];j++)\n\t\t\t\t{\n\t\t\t\t\tfy[cnty]++;\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t}\n\tfor (int i=1;i<=cntx;i++)\n\t{\n\t\tfor (int j=1;j<=cnty;j++)\n\t\t{\n\t\t\tff[i][j]=mp[make_pair(arrx[i],arry[j])];\n\t\t}\n\t}\n\tfor (int i=1;i<=cntx;i++)\n\t{\n\t\tfor (int j=1;j<=cnty;j++)\n\t\t{\n\t\t\tif (ff[i][j]) continue;\n\t\t\tbfs(i,j);\n\t\t\tfor (int k=1;k<=cntx;k++)\n\t\t\t{\n\t\t\t\tfor (int h=1;h<=cnty;h++)\n\t\t\t\t{\n\t\t\t\t\tif (!ff[k][h]) res=(1ll*dist[k][h]*fx[i]%mod*fy[j]%mod*fx[k]%mod*fy[h]+res)%mod;\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t}\n\tans=(ans+(res>>1))%mod;\n\tprintf(\"%d\\n\",(ans+mod)%mod);\n\treturn 0;\n}"
  },
  {
    "language": "C++",
    "code": "\n#include<bits/stdc++.h>\n#define int __int128\nusing namespace std;\n#define DB(x){}\n#define REP(i,b)for(long long i=(0);i<(b);++i)\n#define FOR(i,a,b)for(long long i=(a);i<=(b);++i)\n#define FORD(i,a,b)for(long long i=(a);i>=(b);--i)\n#define ALL(x) (x).begin(),(x).end()\n#define VV vector\ntemplate<typename X,typename Y>void MAX(X&a,Y b){a=(a>=b?a:b);}\ntemplate<typename X,typename Y>void MIN(X&a,Y b){a=(a<=b?a:b);}\ntypedef long long LL;typedef long double LD;\n#define LL __int128\nint DEBUG=0,MULTI=0,GCJ=0;\n\nstruct solver_t;solver_t *solver;\nconst int MOD = 1e9 + 7;\nstruct solver_t {\n  int ROWS = -1, COLS = -1;\n  int IS_BLACK[70][70] = {};\n  LL HEI[70][70] = {};\n  LL WID[70][70] = {};\n\n  LL calculate(LL source_r, LL source_c) {\n    struct pkt_t { LL R = -1, C = -1; LL dst = -1;\n      bool operator < (const pkt_t rhs) const {\n        return dst < rhs.dst;\n      }\n    };\n    DB(source_r<<\" \"<<source_c);\n\n    LL DST[70][70];\n    memset(DST, 0x7f, sizeof(DST));\n\n    multiset <pkt_t> KOL;\n    DST[source_r][source_c] = 0;\n    KOL.insert({source_r, source_c, 0});\n    while (KOL.size() > 0) {\n      auto front = KOL.begin();\n      auto top = *front;\n      KOL.erase(front);\n      if (DST[top.R][top.C] != top.dst) continue;\n\n      FOR (dr, -1, 1) FOR (dc, -1, 1) if (abs(dr) + abs(dc) == 1) {\n        if (dr) {\n          int next_r = top.R + dr;\n          int next_c = top.C;\n          if (!(next_r >=0 && next_r < ROWS)) continue;\n          if (IS_BLACK[next_r][next_c]) continue;\n\n          LL diff_dst;\n          if (next_r == source_r || top.R == source_r) diff_dst = 1;\n          else diff_dst = HEI[top.R][top.C];\n\n          if (DST[next_r][next_c] > diff_dst + top.dst) {\n            DST[next_r][next_c] = diff_dst + top.dst;\n            KOL.insert( { next_r, next_c, DST[next_r][next_c]} );\n          }\n        }\n        if (dc) {\n\n          int next_r = top.R;\n          int next_c = top.C + dc;\n          if (!(next_c >= 0 && next_c < COLS)) continue;\n          if (IS_BLACK[next_r][next_c]) continue;\n\n          int diff_dst;\n          if (next_c == source_c || top.C == source_c) diff_dst = 1;\n          else diff_dst = WID[top.R][top.C];\n\n          if (DST[next_r][next_c] > diff_dst + top.dst) {\n            DST[next_r][next_c] = diff_dst + top.dst;\n            KOL.insert( { next_r, next_c, DST[next_r][next_c]} );\n          }\n        }\n      }\n    }\n\n\n\n    auto power=[](LL a, LL b) {\n      LL res = 1;\n      while (b) {\n        if (b&1) res=(res*a)%MOD;\n        b/=2; a=(a*a)%MOD;\n      }\n      return res;\n    };\n    LL rev3 = power(3, MOD - 2);\n    LL res = 0;\n    REP (r, ROWS) REP (c, COLS) if (IS_BLACK[r][c] == 0) {\n      DB(source_r<<\" \"<<source_c<<\" \"<<r<<\" \"<<c<<\" \"<<DST[r][c]);\n      pair<int,int> V1(source_r, source_c);\n      pair<int,int> V2(r, c);\n      //if (!(V1 <= V2)) continue;\n\n      res += DST[r][c] % MOD * HEI[r][c] % MOD * WID[r][c] % MOD *\n             HEI[source_r][source_c] % MOD * WID[source_r][source_c] % MOD;\n\n      auto oblicz=[&](LL wid) {\n        LL N = wid + 1;\n        if (N < 3) return (LL)0LL;\n        LL res = ((N * (N-1) % MOD) *(N-2)) % MOD;\n        res = (res * rev3) % MOD;\n\n        return res;\n      };\n      DB(oblicz(0));\n      DB(oblicz(1));\n      DB(oblicz(2));\n      DB(oblicz(3));\n      DB(oblicz(4));\n      DB(oblicz(5));\n      DB(oblicz(10));\n\n      auto oblicz2=[](LL wid1,LL wid2) {\n        LL p1 = (wid1 - 1) * wid1 / 2 % MOD * wid2;\n        LL p2 = (wid2 - 1) * wid2 / 2 % MOD * wid1;\n        return p1 + p2;\n      };\n\n      LL v1 = 0;\n      if (source_r == r) {\n        int hei = HEI[r][c];\n        assert(HEI[r][c] == HEI[source_r][source_c]);\n\n        LL tmp = oblicz(hei) % MOD;\n        tmp = (tmp * WID[r][c] % MOD * WID[source_r][source_c]) % MOD;\n\n        res += tmp;\n      }\n      else {\n        LL tmp = oblicz2(HEI[r][c], HEI[source_r][source_c]) % MOD;\n        tmp = (tmp * WID[r][c] % MOD * WID[source_r][source_c]) % MOD;\n        res += tmp;\n      }\n      if (source_c == c) {\n        int wid = WID[r][c];\n        assert(WID[r][c] == WID[source_r][source_c]);\n        LL tmp = oblicz(wid) % MOD;\n        tmp = (tmp * HEI[r][c] % MOD * HEI[source_r][source_c]) % MOD;\n\n        res += tmp;\n      }\n      else {\n        LL tmp = oblicz2(WID[r][c], WID[source_r][source_c]) % MOD;\n\n        tmp = (tmp * HEI[r][c] % MOD * HEI[source_r][source_c]) % MOD;\n        res += tmp;\n      }\n      res %= MOD;\n    }\n\n    return res;\n  }\n\n\n  void solve() {\n    long long H, W;cin >>H>>W;\n    long long N; cin >> N;\n\n    VV<int> CORD_R;\n    VV<int> CORD_C;\n\n    VV<array<int,2> > BLACK;\n    REP (i, N) {\n      long long r, c;\n      cin >> r >> c;\n      BLACK.push_back({r,c});\n      CORD_R.push_back(r);\n      CORD_R.push_back(r + 1);\n\n      CORD_C.push_back(c);\n      CORD_C.push_back(c + 1);\n    }\n    CORD_R.push_back(0);\n    CORD_R.push_back(H);\n\n    CORD_C.push_back(0);\n    CORD_C.push_back(W);\n\n    sort( ALL(CORD_R) ); CORD_R.erase(unique(ALL(CORD_R)), CORD_R.end());\n    sort( ALL(CORD_C) ); CORD_C.erase(unique(ALL(CORD_C)), CORD_C.end());\n\n    for (int cr : CORD_R) DB(cr);\n    for (int cc : CORD_C) DB(cc);\n\n\n    ROWS = CORD_R.size() - 1;\n    COLS = CORD_C.size() - 1;\n\n    for (auto black : BLACK) {\n      int r = lower_bound(ALL(CORD_R), black[0]) - CORD_R.begin();\n      int c = lower_bound(ALL(CORD_C), black[1]) - CORD_C.begin();\n      IS_BLACK[r][c] = 1;\n    }\n    REP (r, ROWS) REP (c, COLS) {\n      HEI[r][c] = CORD_R[r + 1] - CORD_R[r];\n      WID[r][c] = CORD_C[c + 1] - CORD_C[c];\n    }\n\n\n    LL res = 0;\n    auto power=[](LL a, LL b) {\n      LL res = 1;\n      while (b) {\n        if (b&1) res=(res*a)%MOD;\n        b/=2; a=(a*a)%MOD;\n      }\n      return res;\n    };\n    LL rev2 = power(2, MOD - 2);\n    REP (r, ROWS) REP (c, COLS) if (IS_BLACK[r][c] == 0) {\n      res += calculate(r, c);\n      res %= MOD;\n    }\n    cout << (long long)((res * rev2) % MOD) << \"\\n\";\n  }\n\n\n  void gen() {}\n  void brute() {}\n};\n\n#undef int\nint main(int argc,char** argv){\n  FOR(i,1,argc-1)for(int j=0;argv[i][j];j++)if(argv[i][j]=='.')freopen(argv[i],\"r\",stdin);\n  FOR(i,1,argc-1)if(argv[i]==string(\"q\"))DEBUG=1<<30;\n  FOR(i,1,argc-1)if(argv[i]==string(\"gen\")){(solver=new solver_t())->gen();exit(0);}\n  FOR(i,1,argc-1)if(argv[i]==string(\"brute\")){(solver=new solver_t())->brute();exit(0);}\n  ios::sync_with_stdio(false),cin.tie(0);\n  cout.setf(ios::fixed),cout.precision(10);int t;if(MULTI||GCJ)cin>>t;else t=1;\n  FOR(i,1,t){if(DEBUG)cerr<<__LINE__<<\" \"<<i<<endl;if(GCJ)cout<<\"Case #\"<<i<<\": \";\n    solver = new solver_t();\n    solver->solve();\n  }return 0;\n}\n\n"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\nusing namespace std;\ntypedef long long lint;\ntypedef pair<int, int> pi;\nconst int MAXN = 100005;\nconst int mod = 1e9 + 7;\nconst lint inv2 = (mod + 1) / 2;\n\nstruct rt{\n\tint sx, ex, sy, ey;\n\tint ssi, sei, esi, eei;\n\tint type;\n\tbool operator<(const rt &r)const{\n\t\treturn type < r.type;\n\t}\n};\n\nlint sum(int x){\n\treturn ( 1ll * x * (x+1) / 2 ) % mod;\n}\n\nvector<rt> rect;\nvector<pi> pnt;\nvector<pi> gph[9000];\nint dist1[9000], dist2[9000];\n\nvoid dijkstra(int p, int *d){\n\tpriority_queue<pi, vector<pi>, greater<pi> > pq;\n\tpq.push(pi(0, p));\n\td[p] = 0;\n\twhile(!pq.empty()){\n\t\tauto x = pq.top();\n\t\tpq.pop();\n\t\tif(d[x.second] != x.first) continue;\n\t\tfor(auto &i : gph[x.second]){\n\t\t\tif(d[i.second] > x.first + i.first){\n\t\t\t\td[i.second] = x.first + i.first;\n\t\t\t\tpq.push(pi(d[i.second], i.second));\n\t\t\t}\n\t\t}\n\t}\n}\n\nlint sum2(int x){\n\tlint k = x * (1ll * (x + 1) * (2 * x + 1) % mod) % mod;\n\tk *= (mod + 1) / 6;\n\tk %= mod;\n\treturn k;\n}\n\nlint twostrip(int sx, int ex, int sy, int ey){\n\tif(sx == sy && ex == ey){\n\t\tint dx = ex - sx;\n\t\tlint ans = (dx + 1) * sum(dx) % mod;\n\t\tans += mod - sum2(dx);\n\t\tans <<= 1;\n\t\treturn ans % mod;\n\t}\n\telse{\n\t\tif(ex < sy){\n\t\t\tlint ans = 0;\n\t\t\tans += sum(ex - sx) * (ey - sy + 1);\n\t\t\tans += sum(ey - sy) * (ex - sx + 1);\n\t\t\tans += (sy - ex) * (ey - sy + 1) * (ex - sx + 1);\n\t\t\tans %= mod;\n\t\t\treturn ans;\n\t\t}\n\t\telse return twostrip(sy, ey, sx, ex);\n\t}\n}\n\nvoid debug(rt r){\n\treturn;\n\tprintf(\"%d %d %d %d %d\\n\", r.sx, r.ex, r.sy, r.ey, r.type);\n}\nlint getMyself(int x, int y){\n\tlint ans = 0;\n\tans += twostrip(1, x, 1, x) * (1ll * y * y % mod) % mod;\n\tans += twostrip(1, y, 1, y) * (1ll * x * x % mod) % mod;\n\tans %= mod;\n\tans *= inv2;\n\tans %= mod;\n\treturn ans;\n}\n\nlint get33(rt a, rt b){\n\tlint ans = 0;\n\tans += twostrip(a.sx, a.ex, b.sx, b.ex) * (1ll * (a.ey - a.sy + 1) * (b.ey - b.sy + 1) % mod) % mod;\n\tans += twostrip(a.sy, a.ey, b.sy, b.ey) * (1ll * (a.ex - a.sx + 1) * (b.ex - b.sx + 1) % mod) % mod;\n\treturn ans % mod;\n}\n\nlint get12(int l, int r, int n){\n\tlint ans = 0;\n\tif(l + n <= r) return (sum(l + n) - sum(l - 1) + mod) % mod;\n\tif(r + n <= l) return (sum(r + n) - sum(r - 1) + mod) % mod;\n\tif(l > r) swap(l, r);\n\tint m = (r + n - l) / 2;\n\tans += sum(l + m) - sum(l - 1);\n\tans += sum(r + (n - m) - 1) - sum(r - 1);\n\tans %= mod;\n\tans += mod;\n\tans %= mod;\n\tans %= mod;\n\treturn ans;\n}\n\nlint get13(int k, int n, int m){\n\tlint ans = 1ll * k * (n+1) * (m+1) % mod;\n\tans += sum(n) * (m + 1);\n\tans += sum(m) * (n + 1);\n\treturn ans % mod;\n}\n\nlint solve(){\n\tlint ans = 0;\n\tfor(int i=0; i<rect.size(); i++){\n\t\tans += getMyself(rect[i].ex - rect[i].sx + 1, rect[i].ey - rect[i].sy + 1);\n\t\tif(rect[i].type != 3){\n\t\t\t// Dijkstra SHOULD BE VERY FAST!\n\t\t\tmemset(dist1, 0x3f, sizeof(dist1));\n\t\t\tdijkstra(rect[i].ssi, dist1);\n\t\t\tif(rect[i].eei != rect[i].ssi){\n\t\t\t\tmemset(dist2, 0x3f, sizeof(dist2));\n\t\t\t\tdijkstra(rect[i].eei, dist2);\n\t\t\t}\n\t\t}\n\t\tfor(int j=i+1; j<rect.size(); j++){\n\t\t\tif(rect[i].type == 1 && rect[j].type == 1){\n\t\t\t\t// Easy, just use result from dijkstra\n\t\t\t\tans += dist1[rect[j].ssi]; \n\t\t\t}\n\t\t\tif(rect[i].type == 1 && rect[j].type == 2){\n\t\t\t\t// Try two sinks, and brute force from there.\n\t\t\t\tint p1 = dist1[rect[j].ssi];\n\t\t\t\tint p2 = dist1[rect[j].eei];\n\t\t\t\tans += get12(p1, p2, max(rect[j].ex - rect[j].sx, rect[j].ey - rect[j].sy));\n\t\t\t}\n\t\t\tif(rect[i].type == 1 && rect[j].type == 3){\n\t\t\t\t// Observation : It's always advantageous to go to fastest corner.\n\t\t\t\tint fastest = \n\t\t\t\t\tmin({dist1[rect[j].ssi], dist1[rect[j].sei], dist1[rect[j].esi], dist1[rect[j].eei]});\n\t\t\t\t// Fastest corners are detected, and we can calculate with math formula.\n\t\t\t\tans += get13(fastest, rect[j].ex - rect[j].sx, rect[j].ey - rect[j].sy);\n\t\t\t}\n\t\t\tif(rect[i].type == 2 && rect[j].type == 2){\n\t\t\t\tdebug(rect[i]);\n\t\t\t\tdebug(rect[j]);\n\t\t\t\tcout << ans << endl;\n\t\t\t\tif(rect[i].sx < rect[i].ex && rect[j].sx < rect[j].ex && rect[i].sx == rect[j].sx){\n\t\t\t\t\t// X-intervals coincide\n\t\t\t\t\tans += get33(rect[i], rect[j]);\n\t\t\t\t}\n\t\t\t\telse if(rect[i].sy < rect[i].ey && rect[j].sy < rect[j].ey && rect[i].sy == rect[j].sy){\n\t\t\t\t\t// Y-intervals coincide\n\t\t\t\t\tans += get33(rect[i], rect[j]);\n\t\t\t\t}\n\t\t\t\telse{\n\t\t\t\t\t// Now we can assure that intervals ONLY coincide when they are points.\n\t\t\t\t\t//\n\t\t\t\t\tint fastest = min(dist1[rect[j].ssi], dist1[rect[j].eei]);\n\t\t\t\t\tif(rect[i].ssi != rect[i].eei){\n\t\t\t\t\t\tfastest = min({fastest, dist2[rect[j].ssi], dist2[rect[j].eei]});\n\t\t\t\t\t}\n\t\t\t\t\tans += get13(fastest, \n\t\t\t\t\t\t\trect[i].ex - rect[i].sx + rect[i].ey - rect[i].sy,\n\t\t\t\t\t\t\trect[j].ex - rect[j].sx + rect[j].ey - rect[j].sy);\n\t\t\t\t}\n\t\t\t}\n\t\t\tif(rect[i].type == 2 && rect[j].type == 3){\n\t\t\t\t// This is analogous with 3-3 case.\n\t\t\t\tans += get33(rect[i], rect[j]);\n\t\t\t}\n\t\t\tif(rect[i].type == 3 && rect[j].type == 3){\n\t\t\t\t// Obstacles are not important in here.\n\t\t\t\tans += get33(rect[i], rect[j]);\n\t\t\t}\n\t\t}\n\t}\n\tans %= mod;\n\treturn ans;\n}\n\nint h, w, n, x[31], y[31];\nvector<int> vx, vy;\n\nint getsum(pi a, pi b){\n\tfor(int i=0; i<n; i++){\n\t\tif(a.first <= x[i] && x[i] <= b.first && a.second <= y[i] && y[i] <= b.second){\n\t\t\treturn 1;\n\t\t}\n\t}\n\treturn 0;\n}\n\nvoid make_edge(vector<pi> v){\n\tfor(int i=1; i<v.size(); i++){\n\t\tif(v[i-1].first == v[i].first || v[i-1].second == v[i].second){\n\t\t\tint p1 = lower_bound(pnt.begin(), pnt.end(), v[i-1]) - pnt.begin();\n\t\t\tint p2 = lower_bound(pnt.begin(), pnt.end(), v[i]) - pnt.begin();\n\t\t\tint dx = abs(v[i].first - v[i-1].first) + abs(v[i].second - v[i-1].second);\n\t\t\tif(getsum(v[i-1], v[i]) == 0){\n\t\t\t\tgph[p1].push_back(pi(dx, p2));\n\t\t\t\tgph[p2].push_back(pi(dx, p1));\n\t\t\t}\n\t\t}\n\t}\n}\n\nint main(){\n\tcin >> h >> w >> n;\n\tfor(int i=0; i<n; i++){\n\t\tcin >> x[i] >> y[i];\n\t\tx[i]++;\n\t\ty[i]++;\n\t\tvx.push_back(x[i]);\n\t\tvy.push_back(y[i]);\n\t}\n\tvx.push_back(0); vx.push_back(h+1);\n\tvy.push_back(0); vy.push_back(w+1);\n\tsort(vx.begin(), vx.end());\n\tsort(vy.begin(), vy.end());\n\tvx.resize(unique(vx.begin(), vx.end()) - vx.begin());\n\tvy.resize(unique(vy.begin(), vy.end()) - vy.begin());\n\tvector<pi> ix, iy;\n\tfor(int i=0; i+1<vx.size(); i++){\n\t\tif(i != 0) ix.push_back(pi(vx[i], vx[i]));\n\t\tif(vx[i] + 1 < vx[i+1]) ix.push_back(pi(vx[i] + 1, vx[i+1] - 1));\n\t}\n\tfor(int i=0; i+1<vy.size(); i++){\n\t\tif(i != 0) iy.push_back(pi(vy[i], vy[i]));\n\t\tif(vy[i] + 1 < vy[i+1]) iy.push_back(pi(vy[i] + 1, vy[i+1] - 1));\n\t}\n\tfor(auto &i : ix){\n\t\tfor(auto &j : iy){\n\t\t\t// Build rectangles from parsed intervals\n\t\t\tint type = 1;\n\t\t\tif(i.first != i.second || *lower_bound(vx.begin(), vx.end(), i.first) != i.first){\n\t\t\t\t// X coordinates are not bounded\n\t\t\t\ttype++;\n\t\t\t}\n\t\t\tif(j.first != j.second || *lower_bound(vy.begin(), vy.end(), j.first) != j.first){\n\t\t\t\t// Y coordinates are not bounded\n\t\t\t\ttype++;\n\t\t\t}\n\t\t\tfor(int k=0; k<n; k++){\n\t\t\t\tif(type == 1 && x[k] == i.first && y[k] == j.first){\n\t\t\t\t\t// Both coordinates are bounded, and it coincides with black point\n\t\t\t\t\ttype--;\n\t\t\t\t}\n\t\t\t}\n\t\t\tif(type == 0) continue;\n\t\t\t// Good\n\t\t\trect.push_back({i.first, i.second, j.first, j.second, -1, -1, -1, -1, type});\n\t\t}\n\t}\n\tsort(rect.begin(), rect.end());\n\tfor(auto &i : rect){\n\t\tpnt.push_back(pi(i.sx, i.sy));\n\t\tpnt.push_back(pi(i.sx, i.ey));\n\t\tpnt.push_back(pi(i.ex, i.sy));\n\t\tpnt.push_back(pi(i.ex, i.ey));\n\t}\n\tsort(pnt.begin(), pnt.end());\n\tpnt.resize(unique(pnt.begin(), pnt.end()) - pnt.begin());\n\tvector<pi> w = pnt;\n\tmake_edge(w);\n\tsort(w.begin(), w.end(), [&](const pi &a, const pi &b){\n\t\treturn pi(a.second, a.first) < pi(b.second, b.first);\n\t});\n\tmake_edge(w);\n\tfor(auto &i : rect){\n\t\ti.ssi = lower_bound(pnt.begin(), pnt.end(), pi(i.sx, i.sy)) - pnt.begin();\n\t\ti.sei = lower_bound(pnt.begin(), pnt.end(), pi(i.sx, i.ey)) - pnt.begin();\n\t\ti.esi = lower_bound(pnt.begin(), pnt.end(), pi(i.ex, i.sy)) - pnt.begin();\n\t\ti.eei = lower_bound(pnt.begin(), pnt.end(), pi(i.ex, i.ey)) - pnt.begin();\n\t}\n\tcout << solve() << endl;\n}\n"
  },
  {
    "language": "C++",
    "code": "#include<iostream>\n#include<vector>\n#include<algorithm>\n#include<cstring>\n#include<cstdio>\n#include<cmath>\n#include<cstdlib>\n#include<ctime>\n#include<queue>\n#include<set>\n#include<map>\n#include<stack>\n#include<bitset>\n\n#define pb push_back\n#define mp make_pair\n\nusing namespace std;\n\ntemplate<typename T>inline void upmin(T &x,T y) { y<x?x=y:0; }\ntemplate<typename T>inline void upmax(T &x,T y) { x<y?x=y:0; }\n\ntypedef unsigned int u32;\ntypedef long long LL;\ntypedef unsigned long long ULL;\ntypedef long double lod;\ntypedef pair<int,int> PR;\ntypedef vector<int> VI;\n\nconst lod pi=acos(-1);\nconst int oo=1<<30;\nconst LL OO=1e18;\n\nconst int N=110,M=1e6+100;\n\nint gi() {\n\tint w=0;bool q=1;char c=getchar();\n\twhile ((c<'0'||c>'9') && c!='-') c=getchar();\n\tif (c=='-') q=0,c=getchar();\n\twhile (c>='0'&&c <= '9') w=w*10+c-'0',c=getchar();\n\treturn q? w:-w;\n}\n\nconst int mod=1e9+7;\nconst int dx[4]={1,-1,0,0};\nconst int dy[4]={0,0,1,-1};\n\nint X[N],Y[N];\nstruct P{ int x,y; }p[N];\nbool can[N][N],vis[N][N];\nint pre[M],suf[M],dis[N][N];\nint main()\n{\n\tint n=gi(),m=gi(),T=gi(),i,j,lx=0,ly=0,x,y,ans=0,t;LL sum;\n\tqueue<P>q;\n\tX[++lx]=Y[++ly]=1;\n\tfor (i=0;i<T;i++) {\n\t\tX[++lx]=p[i].x=gi()+1,Y[++ly]=p[i].y=gi()+1;\n\t\tX[++lx]=p[i].x+1,Y[++ly]=p[i].y+1;\n\t}\n\tsort(X+1,X+lx+1);lx=unique(X+1,X+lx+1)-X-1;\n\tsort(Y+1,Y+ly+1);ly=unique(Y+1,Y+ly+1)-Y-1;\n\tX[lx+1]=n+1;Y[ly+1]=m+1;\n\tfor (i=1;i<=lx;i++)\n\t\tfor (j=1;j<=ly;j++)\n\t\t\tcan[i][j]=true;\n\tfor (i=0;i<T;i++)\n\t\tcan[find(X+1,X+lx+1,p[i].x)-X][find(Y+1,Y+ly+1,p[i].y)-Y]=false;\n\n\tfor (i=0;i<T;i++)\n\t\t++pre[p[i].x];\n\tfor (i=n;i;i--) suf[i]=(suf[i+1]+m-pre[i])%mod;\n\tfor (i=1,sum=0;i<n;i++) {\n\t\tsum+=m-pre[i];\n\t\tif (!pre[i]&&!pre[i+1])\n\t\t\tans=(ans+sum%mod*suf[i+1])%mod;\n\t}\n\tfor (i=1;i<=n;i++) pre[i]=suf[i]=0;\n\tfor (i=0;i<T;i++)\n\t\t++pre[p[i].y];\n\tfor (i=m;i;i--) suf[i]=(suf[i+1]+n-pre[i])%mod;\n\tfor (i=1,sum=0;i<m;i++) {\n\t\tsum+=n-pre[i];\n\t\tif (!pre[i]&&!pre[i+1])\n\t\t\tans=(ans+sum%mod*suf[i+1])%mod;\n\t}\n\tfor (i=1;i<=lx;i++)\n\t\tfor (j=1;j<=ly;j++)\n\t\t\tif (can[i][j]) {\n\t\t\t\tfor (x=1;x<=lx;x++)\n\t\t\t\t\tfor (y=1;y<=ly;y++)\n\t\t\t\t\t\tvis[x][y]=can[x][y];\n\t\t\t\tq.push((P){i,j});vis[i][j]=false;\n\t\t\t\tdis[i][j]=0;\n\t\t\t\twhile (!q.empty()) {\n\t\t\t\t\tx=q.front().x;y=q.front().y;q.pop();\n\t\t\t\t\tif (x>i||(x==i&&y>j))\n\t\t\t\t\t\tans=(ans+1LL*(X[x+1]-X[x])*(Y[y+1]-Y[y])%mod*(X[i+1]-X[i])%mod*(Y[j+1]-Y[j])%mod*dis[x][y])%mod;\n\t\t\t\t\tfor (t=0;t<4;t++)\n\t\t\t\t\t\tif (vis[x+dx[t]][y+dy[t]]) {\n\t\t\t\t\t\t\tdis[x+dx[t]][y+dy[t]]=dis[x][y]+1;\n\t\t\t\t\t\t\tvis[x+dx[t]][y+dy[t]]=false;\n\t\t\t\t\t\t\tq.push((P){x+dx[t],y+dy[t]});\n\t\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t}\n\tcout<<ans<<endl;\n\treturn 0;\n}\n"
  },
  {
    "language": "C++",
    "code": "#include<algorithm> \n#include<iostream>\n#include<cstring>\n#include<cstdio>\n#define MN 61\n#define mod 1000000007\nusing namespace std;\ninline int read()\n{\n\tint x=0,f=1;char ch=getchar();\n\twhile(ch<'0'||ch>'9'){if(ch=='-')f=-1;ch=getchar();}\n\twhile(ch>='0'&&ch<='9'){x=x*10+ch-'0';ch=getchar();}\n\treturn x*f;\n}\npair<int,int> q[MN*MN*2+5];\nint h,w,n,Lx[MN+5],num1,Ly[MN+5],x[MN+5],y[MN+5],num2,ans;\nint vis[MN+5][MN+5],b[MN+5][MN+5],d[MN+5][MN+5],W[4],top;\nconst int dis[4][2]={{-1,0},{1,0},{0,-1},{0,1}};\nvoid Update(int x,int y)\n{\n\tif(vis[x][y]) return;vis[x][y]=1;\n\tfor(int k=0;k<4;++k)\n\t{\n\t\tint nx=x+dis[k][0],ny=y+dis[k][1];\n\t\tif(nx<1||ny<1||nx>num1||ny>num2||b[nx][ny]) continue;\n\t\tif(d[x][y]+W[k]<d[nx][ny])\n\t\t{\n\t\t\td[nx][ny]=d[x][y]+W[k];\n\t\t\tif(!W[k]) Update(nx,ny);\n\t\t\telse q[++top]=make_pair(nx,ny);\n\t\t}\n\t}\t\n}\nvoid Bfs(int x,int y)\n{\n\tmemset(vis,0,sizeof(vis));\n\tmemset(d,63,sizeof(d));d[x][y]=0;q[top=MN*MN]=make_pair(x,y);\n\tfor(int i=MN*MN;i<=top;++i)\n\t{\n\t\tint x=q[i].first,y=q[i].second;\n\t\tUpdate(x,y);\n\t}\n}\ninline int S(int x,int y){return 1LL*(Lx[x]-Lx[x-1])*(Ly[y]-Ly[y-1])%mod;}\nint main()\n{\n\th=read();w=read();n=read();\n\tLx[num1=1]=h;Ly[num2=1]=w;\n\tfor(int i=1;i<=n;++i)\n\t{\n\t\tx[i]=read()+1,y[i]=read()+1;\n\t\tLx[++num1]=x[i];if(x[i]>1) Lx[++num1]=x[i]-1;\n\t\tLy[++num2]=y[i];if(y[i]>1) Ly[++num2]=y[i]-1;\n\t}\n\tsort(Lx+1,Lx+num1+1);num1=unique(Lx+1,Lx+num1+1)-Lx-1;\n\tsort(Ly+1,Ly+num2+1);num2=unique(Ly+1,Ly+num2+1)-Ly-1;\n\tfor(int i=1;i<=n;++i)\n\t\tb[lower_bound(Lx+1,Lx+num1+1,x[i])-Lx]\n\t\t [lower_bound(Ly+1,Ly+num2+1,y[i])-Ly]=1;\n\tfor(int i=1;i<h;++i)\n\t{\n\t\tint a=1LL*w*i%mod,b=1LL*w*(h-i)%mod;\n\t\tfor(int j=1;j<=n;++j) \n\t\t\tif(x[j]<=i) --a<0?a+=mod:0;\n\t\t\telse --b<0?b+=mod:0;\n\t\tans=(ans+1LL*a*b)%mod;\n\t}\n\tfor(int i=1;i<w;++i)\n\t{\n\t\tint a=1LL*h*i%mod,b=1LL*h*(w-i)%mod;\n\t\tfor(int j=1;j<=n;++j) \n\t\t\tif(y[j]<=i) --a<0?a+=mod:0;\n\t\t\telse --b<0?b+=mod:0;\n\t\tans=(ans+1LL*a*b)%mod;\n\t}\n\tfor(int i=1;i<=num1;++i) for(int j=1;j<=num2;++j) if((Lx[i]==Lx[i-1]+1||Ly[j]==Ly[j-1]+1)&&!b[i][j])\n\t{\n\t\tW[0]=0;W[1]=1;W[2]=1;W[3]=0;Bfs(i,j);\n\t\tfor(int x=1;x<i;++x) for(int y=j;y<=num2;++y) if(!b[x][y])\n\t\t\tans=(ans+1LL*d[x][y]*S(i,j)%mod*S(x,y))%mod;\n\t\tW[0]=1;W[1]=0;W[2]=1;W[3]=0;Bfs(i,j);\n\t\tfor(int x=i;x<=num1;++x) for(int y=j+1;y<=num2;++y) if(!b[x][y])\n\t\t\tans=(ans+1LL*d[x][y]*S(i,j)%mod*S(x,y))%mod;\t\n\t\tW[0]=1;W[1]=0;W[2]=0;W[3]=1;Bfs(i,j);\n\t\tfor(int x=i+1;x<=num1;++x) for(int y=1;y<=j;++y) if(!b[x][y])\n\t\t\tans=(ans+1LL*d[x][y]*S(i,j)%mod*S(x,y))%mod;\n\t\tW[0]=0;W[1]=1;W[2]=0;W[3]=1;Bfs(i,j);\n\t\tfor(int x=1;x<=i;++x) for(int y=1;y<j;++y) if(!b[x][y])\n\t\t\tans=(ans+1LL*d[x][y]*S(i,j)%mod*S(x,y))%mod;\n\t}\n\tcout<<ans;\n\treturn 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include<bits/stdc++.h>\n#define rep(i,a,b) for(int i=(a);i<=(b);i++)\n#define per(i,a,b) for(int i=(a);i>=(b);i--)\n#define REP(i,n) for(int i=0;i<(n);i++)\n#define fi first\n#define se second\n#define pb push_back\n#define mp make_pair\nusing namespace std;\ntypedef pair<int,int> pii;\ntypedef vector<int> vi;\ntypedef long long ll;\n\ntemplate<class T> void read(T &x){\n\tint f=0; x=0; char ch=getchar();\n\tfor(;!isdigit(ch);ch=getchar()) f|=(ch=='-');\n\tfor(;isdigit(ch);ch=getchar()) x=x*10+ch-'0';\n\tif(f) x=-x;\n}\n\nconst int dx[4]={-1,1,0,0},dy[4]={0,0,-1,1};\nconst int N=105,mod=1e9+7,inv2=(mod+1)/2;\nint xx[N],yy[N],x[N],y[N],w[N][N],d[N][N],q[N*N][2];\nint H,W,n,m,cnt,ans;\n\nint S2(int n){\n\treturn (ll)n*(n+1)/2%mod;\n}\n\nint main(){\n\tread(H),read(W),read(cnt);\n\txx[++n]=1,xx[++n]=H+1,yy[++m]=1,yy[++m]=W+1;\n\trep(i,1,cnt){\n\t\tread(x[i]),read(y[i]),x[i]++,y[i]++;\n\t\txx[++n]=x[i],xx[++n]=x[i]+1;\n\t\tyy[++m]=y[i],yy[++m]=y[i]+1;\n\t}\n\tsort(xx+1,xx+n+1),n=unique(xx+1,xx+n+1)-xx-1;\n\tsort(yy+1,yy+m+1),m=unique(yy+1,yy+m+1)-yy-1;\n\trep(i,1,n-1) rep(j,1,m-1){\n\t\tw[i][j]=(ll)(xx[i+1]-xx[i])*(yy[j+1]-yy[j])%mod;\n\t}\n\trep(i,1,cnt){\n\t\tx[i]=lower_bound(xx+1,xx+n+1,x[i])-xx;\n\t\ty[i]=lower_bound(yy+1,yy+m+1,y[i])-yy;\n\t\tw[x[i]][y[i]]=0;\n\t}\n\trep(k,1,n-1) if(xx[k+1]-xx[k]>=2){\n\t\tint up=0,down=0;\n\t\trep(i,1,n-1) rep(j,1,m-1){\n\t\t\tif(i<k) up=(up+w[i][j])%mod;\n\t\t\tif(i>k) down=(down+w[i][j])%mod;\n\t\t}\n\t\tans=(ans+(ll)up*down%mod*(xx[k+1]-xx[k]-1))%mod;\n\t\tans=(ans+(ll)(up+down)*W%mod*S2(xx[k+1]-xx[k]-1))%mod;\n\t\tint sum=0;\n\t\trep(i,1,xx[k+1]-xx[k]-1) sum=(sum+(ll)i*(xx[k+1]-xx[k]-i))%mod;\n\t\tans=(ans+(ll)W*W%mod*sum)%mod;\n\t}\n\trep(k,1,m-1) if(yy[k+1]-yy[k]>=2){\n\t\tint le=0,ri=0;\n\t\trep(i,1,n-1) rep(j,1,m-1){\n\t\t\tif(j<k) le=(le+w[i][j])%mod;\n\t\t\tif(j>k) ri=(ri+w[i][j])%mod;\n\t\t}\n\t\tans=(ans+(ll)le*ri%mod*(yy[k+1]-yy[k]-1))%mod;\n\t\tans=(ans+(ll)(le+ri)*H%mod*S2(yy[k+1]-yy[k]-1))%mod;\n\t\tint sum=0;\n\t\trep(i,1,yy[k+1]-yy[k]-1) sum=(sum+(ll)i*(yy[k+1]-yy[k]-i))%mod;\n\t\tans=(ans+(ll)H*H%mod*sum)%mod;\n\t}\n\trep(i,1,n-1) rep(j,1,m-1) if(w[i][j]){\n\t\tint r=0;\n\t\tmemset(d,-1,sizeof d);\n\t\tq[++r][0]=i,q[r][1]=j,d[i][j]=0;\n\t\trep(l,1,r){\n\t\t\tint x=q[l][0],y=q[l][1];\n\t\t\tREP(dir,4){\n\t\t\t\tint xx=x+dx[dir],yy=y+dy[dir];\n\t\t\t\tif(!w[xx][yy]||d[xx][yy]>=0) continue;\n\t\t\t\td[xx][yy]=d[x][y]+1;\n\t\t\t\tq[++r][0]=xx,q[r][1]=yy;\n\t\t\t}\n\t\t}\n\t\trep(x,1,n-1) rep(y,1,m-1) if(w[x][y])\n\t\t\tans=(ans+(ll)w[i][j]*w[x][y]%mod*d[x][y]%mod*inv2)%mod;\n\t}\n\tcout<<ans<<endl;\n\treturn 0;\n}"
  },
  {
    "language": "C++",
    "code": "\n#include<bits/stdc++.h>\nusing namespace std;\n#define DB(x){if(DEBUG)cerr<<__LINE__<<\" \"<<#x<<\" \" <<x<<endl;}\n#define REP(i,b)for(LL i=(0);i<(b);++i)\n#define FOR(i,a,b)for(LL i=(a);i<=(b);++i)\n#define FORD(i,a,b)for(LL i=(a);i>=(b);--i)\n#define ALL(x) (x).begin(),(x).end()\n#define VV vector\ntemplate<typename X,typename Y>void MAX(X&a,Y b){a=(a>=b?a:b);}\ntemplate<typename X,typename Y>void MIN(X&a,Y b){a=(a<=b?a:b);}\ntypedef long long LL;typedef long double LD;\nint DEBUG=0,MULTI=0,GCJ=0;\n\nstruct solver_t;solver_t *solver;\nconst int MOD = 1e9 + 7;\nstruct solver_t {\n  int ROWS = -1, COLS = -1;\n  int IS_BLACK[70][70] = {};\n  LL HEI[70][70] = {};\n  LL WID[70][70] = {};\n\n  LL calculate(LL source_r, LL source_c) {\n    struct pkt_t { LL R = -1, C = -1; LL dst = -1;\n      bool operator < (const pkt_t rhs) const {\n        return dst < rhs.dst;\n      }\n    };\n    DB(source_r<<\" \"<<source_c);\n\n    LL DST[70][70];\n    memset(DST, 0x7f, sizeof(DST));\n\n    multiset <pkt_t> KOL;\n    DST[source_r][source_c] = 0;\n    KOL.insert({source_r, source_c, 0});\n    while (KOL.size() > 0) {\n      auto front = KOL.begin();\n      auto top = *front;\n      KOL.erase(front);\n      if (DST[top.R][top.C] != top.dst) continue;\n\n      FOR (dr, -1, 1) FOR (dc, -1, 1) if (abs(dr) + abs(dc) == 1) {\n        if (dr) {\n          int next_r = top.R + dr;\n          int next_c = top.C;\n          if (!(next_r >=0 && next_r < ROWS)) continue;\n          if (IS_BLACK[next_r][next_c]) continue;\n\n          LL diff_dst;\n          if (next_r == source_r || top.R == source_r) diff_dst = 1;\n          else diff_dst = HEI[top.R][top.C];\n\n          if (DST[next_r][next_c] > diff_dst + top.dst) {\n            DST[next_r][next_c] = diff_dst + top.dst;\n            KOL.insert( { next_r, next_c, DST[next_r][next_c]} );\n          }\n        }\n        if (dc) {\n\n          int next_r = top.R;\n          int next_c = top.C + dc;\n          if (!(next_c >= 0 && next_c < COLS)) continue;\n          if (IS_BLACK[next_r][next_c]) continue;\n\n          int diff_dst;\n          if (next_c == source_c || top.C == source_c) diff_dst = 1;\n          else diff_dst = WID[top.R][top.C];\n\n          if (DST[next_r][next_c] > diff_dst + top.dst) {\n            DST[next_r][next_c] = diff_dst + top.dst;\n            KOL.insert( { next_r, next_c, DST[next_r][next_c]} );\n          }\n        }\n      }\n    }\n\n\n\n    auto power=[](LL a, LL b) {\n      LL res = 1;\n      while (b) {\n        if (b&1) res=(res*a)%MOD;\n        b/=2; a=(a*a)%MOD;\n      }\n      return res;\n    };\n    LL rev3 = power(3, MOD - 2);\n    LL rev2 = power(2, MOD - 2);\n    LL res = 0;\n    REP (r, ROWS) REP (c, COLS) if (IS_BLACK[r][c] == 0) {\n      DB(source_r<<\" \"<<source_c<<\" \"<<r<<\" \"<<c<<\" \"<<DST[r][c]);\n      pair<int,int> V1(source_r, source_c);\n      pair<int,int> V2(r, c);\n      //if (!(V1 <= V2)) continue;\n\n      res += DST[r][c] % MOD * HEI[r][c] % MOD * WID[r][c] % MOD *\n             HEI[source_r][source_c] % MOD * WID[source_r][source_c] % MOD;\n\n      auto oblicz=[&](LL wid) {\n        LL N = wid + 1;\n        if (N < 3) return 0LL;\n        LL res = ((N * (N-1) % MOD) *(N-2)) % MOD;\n        res = (res * rev3) % MOD;\n\n        return res;\n      };\n      DB(oblicz(0));\n      DB(oblicz(1));\n      DB(oblicz(2));\n      DB(oblicz(3));\n      DB(oblicz(4));\n      DB(oblicz(5));\n      DB(oblicz(10));\n\n      auto oblicz2=[&](LL wid1,LL wid2) {\n        LL p1 = (wid1 - 1)  % MOD * wid1 % MOD * rev2 % MOD * wid2;\n        LL p2 = (wid2 - 1)  % MOD* wid2 % MOD * rev2 % MOD * wid1;\n        return (p1 + p2) % MOD;\n      };\n\n      if (source_r == r) {\n        LL hei = HEI[r][c];\n        assert(HEI[r][c] == HEI[source_r][source_c]);\n\n        LL tmp = oblicz(hei) % MOD;\n        tmp = (tmp * WID[r][c] % MOD * WID[source_r][source_c]) % MOD;\n\n        res += tmp;\n      }\n      else {\n        LL tmp = oblicz2(HEI[r][c], HEI[source_r][source_c]) % MOD;\n        tmp = (tmp * WID[r][c] % MOD * WID[source_r][source_c]) % MOD;\n        res += tmp;\n      }\n      if (source_c == c) {\n        int wid = WID[r][c];\n        assert(WID[r][c] == WID[source_r][source_c]);\n        LL tmp = oblicz(wid) % MOD;\n        tmp = (tmp * HEI[r][c] % MOD * HEI[source_r][source_c]) % MOD;\n\n        res += tmp;\n      }\n      else {\n        LL tmp = oblicz2(WID[r][c], WID[source_r][source_c]) % MOD;\n\n        tmp = (tmp * HEI[r][c] % MOD * HEI[source_r][source_c]) % MOD;\n        res += tmp;\n      }\n      res %= MOD;\n    }\n\n    return res;\n  }\n\n\n  void solve() {\n    int H, W;cin >>H>>W;\n    int N; cin >> N;\n\n    VV<int> CORD_R;\n    VV<int> CORD_C;\n\n    VV<array<int,2> > BLACK;\n    REP (i, N) {\n      int r, c;\n      cin >> r >> c;\n      BLACK.push_back({r,c});\n      CORD_R.push_back(r);\n      CORD_R.push_back(r + 1);\n\n      CORD_C.push_back(c);\n      CORD_C.push_back(c + 1);\n    }\n    CORD_R.push_back(0);\n    CORD_R.push_back(H);\n\n    CORD_C.push_back(0);\n    CORD_C.push_back(W);\n\n    sort( ALL(CORD_R) ); CORD_R.erase(unique(ALL(CORD_R)), CORD_R.end());\n    sort( ALL(CORD_C) ); CORD_C.erase(unique(ALL(CORD_C)), CORD_C.end());\n\n    for (int cr : CORD_R) DB(cr);\n    for (int cc : CORD_C) DB(cc);\n\n\n    ROWS = CORD_R.size() - 1;\n    COLS = CORD_C.size() - 1;\n\n    for (auto black : BLACK) {\n      int r = lower_bound(ALL(CORD_R), black[0]) - CORD_R.begin();\n      int c = lower_bound(ALL(CORD_C), black[1]) - CORD_C.begin();\n      IS_BLACK[r][c] = 1;\n    }\n    REP (r, ROWS) REP (c, COLS) {\n      HEI[r][c] = CORD_R[r + 1] - CORD_R[r];\n      WID[r][c] = CORD_C[c + 1] - CORD_C[c];\n    }\n\n\n    LL res = 0;\n    auto power=[](LL a, LL b) {\n      LL res = 1;\n      while (b) {\n        if (b&1) res=(res*a)%MOD;\n        b/=2; a=(a*a)%MOD;\n      }\n      return res;\n    };\n    LL rev2 = power(2, MOD - 2);\n    REP (r, ROWS) REP (c, COLS) if (IS_BLACK[r][c] == 0) {\n      res += calculate(r, c);\n      res %= MOD;\n    }\n    cout << ((res * rev2) % MOD +MOD)%MOD << \"\\n\";\n  }\n\n\n  void gen() {}\n  void brute() {}\n};\n\n#undef int\nint main(int argc,char** argv){\n  FOR(i,1,argc-1)for(int j=0;argv[i][j];j++)if(argv[i][j]=='.')freopen(argv[i],\"r\",stdin);\n  FOR(i,1,argc-1)if(argv[i]==string(\"q\"))DEBUG=1<<30;\n  FOR(i,1,argc-1)if(argv[i]==string(\"gen\")){(solver=new solver_t())->gen();exit(0);}\n  FOR(i,1,argc-1)if(argv[i]==string(\"brute\")){(solver=new solver_t())->brute();exit(0);}\n  ios::sync_with_stdio(false),cin.tie(0);\n  cout.setf(ios::fixed),cout.precision(10);int t;if(MULTI||GCJ)cin>>t;else t=1;\n  FOR(i,1,t){if(DEBUG)cerr<<__LINE__<<\" \"<<i<<endl;if(GCJ)cout<<\"Case #\"<<i<<\": \";\n    solver = new solver_t();\n    solver->solve();\n  }return 0;\n}\n\n"
  },
  {
    "language": "C++",
    "code": "#include <iostream>\n#include <vector>\n#include <map>\n#include <queue>\n#include <algorithm>\n#include <cstring>\nusing namespace std;\n\n#define REP(i, s) for (int i = 0; i < s; ++i)\n#define ALL(v) (v.begin(), v.end())\n#define COUT(x) cout << #x << \" = \" << (x) << \" (L\" << __LINE__ << \")\" << endl\n#define EACH(i, s) for (__typeof__((s).begin()) i = (s).begin(); i != (s).end(); ++i)\n\ntemplate<class T> inline bool chmax(T& a, T b) { if (a < b) { a = b; return 1; } return 0; }\ntemplate<class T> inline bool chmin(T& a, T b) { if (a > b) { a = b; return 1; } return 0; }\ntemplate<class T1, class T2> ostream& operator << (ostream &s, pair<T1, T2> P)\n{\n\treturn s << '<' << P.first << \", \" << P.second << '>';\n}\ntemplate<class T> ostream& operator << (ostream &s, vector<T> P)\n{\n\tfor (int i = 0; i < P.size(); ++i) { if (i > 0) { s << \" \"; } s << P[i]; } return s;\n}\ntemplate<class T> ostream& operator << (ostream &s, vector<vector<T> > P)\n{\n\tfor (int i = 0; i < P.size(); ++i) { s << endl << P[i]; } return s << endl;\n}\n\nconst int MOD = 1000000007;\ninline long long mod(long long a, long long m) { return (a % m + m) % m; }\nstruct Fp {\n\tint MOD = 1000000007;\n\tlong long val;\n\n\tFp() : val(0) {}\n\tFp(long long val_) { this->val = mod(val_, MOD); }\n\tFp operator = (long long val_) { this->val = mod(val_, MOD); return *this; }\n\tinline Fp operator - () { return mod(-val, MOD); }\n\tinline const Fp& operator += (const Fp &x);\n\tinline const Fp& operator -= (const Fp &x);\n\tinline const Fp& operator *= (const Fp &x);\n\tinline const Fp& operator /= (const Fp &x);\n};\n\ninline bool operator == (Fp x, Fp y) { return x.val == y.val; }\ninline bool operator != (Fp x, Fp y) { return !(x == y); }\n\nostream &operator << (ostream &os, Fp x) { return os << x.val; }\nistream &operator >> (istream &is, Fp &x) { is >> x; return is; }\n\ninline Fp operator + (Fp x, Fp y) { return mod(x.val + y.val, x.MOD); }\ninline Fp operator - (Fp x, Fp y) { return mod(x.val - y.val, x.MOD); }\ninline Fp operator * (Fp x, Fp y) { return mod(x.val * y.val, x.MOD); }\ninline Fp operator / (Fp x, Fp y) {\n\tlong long a = y.val, b = x.MOD, u = 1, v = 0;\n\twhile (b) {\n\t\tlong long t = a / b;\n\t\ta -= t*b; swap(a, b);\n\t\tu -= t*v; swap(u, v);\n\t}\n\treturn x * u;\n}\ninline Fp abs(Fp a) { return a; }\ninline Fp fpow(Fp a, long long n) {\n\tif (n == 0) return Fp(1);\n\tFp t = fpow(a, n / 2);\n\tt = t * t; if (n & 1) t = t * a;\n\treturn t;\n}\ninline const Fp& Fp::operator += (const Fp &x) { *this = *this + x; return *this; }\ninline const Fp& Fp::operator -= (const Fp &x) { *this = *this - x; return *this; }\ninline const Fp& Fp::operator *= (const Fp &x) { *this = *this * x; return *this; }\ninline const Fp& Fp::operator /= (const Fp &x) { *this = *this / x; return *this; }\n\n// calc comb (small n, r ver)\nconst int FACT_MAX = 210000;\nstatic Fp fp_fact_val[FACT_MAX];\n\nvoid calcFact(int MAX = FACT_MAX) {\n\tfp_fact_val[0] = 1;\n\tfor (int val = 1; val < MAX; ++val) {\n\t\tfp_fact_val[val] = fp_fact_val[val - 1] * val;\n\t}\n}\n\nFp fact(int n) {\n\treturn fp_fact_val[n];\n}\n\nFp com(int n, int r) {\n\treturn fact(n) / fact(r) / fact(n - r);\n}\n\nint dx[4] = {1, 0, -1, 0};\nint dy[4] = {0, 1, 0, -1};\n\nlong long H, W, N;\nlong long bx[210], by[210];\nvector<long long> altx, alty;\nlong long nH, nW;\n\nlong long xnum[1100000], ynum[1100000];\n\nbool cb[210][210];\nint dist[110][110];\n\ntypedef pair<int, int> pint;\nlong long subsolve() {\n\t//COUT(nH); COUT(nW); COUT(altx); COUT(alty);\n  long long res = 0;\n\tfor (int x = 0; x < nH - 1; ++x) {\n\t\tfor (int y = 0; y < nW - 1; ++y) {\n\t\t\t//cout << cb[x][y];\n\t\t\tif (cb[x][y]) continue;\n\n\t\t\t\n\t\t\tmemset(dist, -1, sizeof(dist));\n\t\t\tqueue<pint> que;\n\t\t\tque.push(pint(x, y));\n\t\t\tdist[x][y] = 0;\n\t\t\twhile (!que.empty()) {\n\t\t\t\tpint cur = que.front();\n\t\t\t\tque.pop();\n\t\t\t\tfor (int dir = 0; dir < 4; ++dir) {\n\t\t\t\t\tint nx = cur.first + dx[dir];\n\t\t\t\t\tint ny = cur.second + dy[dir];\n\t\t\t\t\tif (nx < 0 || nx >= H || ny < 0 || ny >= W) continue;\n\t\t\t\t\tif (cb[nx][ny]) continue;\n\t\t\t\t\tif (dist[nx][ny] == -1) {\n\t\t\t\t\t\tdist[nx][ny] = dist[cur.first][cur.second] + 1;\n\t\t\t\t\t\tque.push(pint(nx, ny));\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t}\n\t\t\t\n\t\t\tfor (int nx = 0; nx < nH - 1; ++nx) {\n\t\t\t\tfor (int ny = 0; ny < nW - 1; ++ny) {\n\t\t\t\t\tif (nW * nx + ny <= nW * x + y) continue;\n\t\t\t\t\tif (dist[nx][ny] == -1) continue;\n\t\t\t\t\tif (cb[nx][ny]) continue;\n\n\t\t\t\t\tlong long ss = ((long long)(altx[x + 1] - altx[x]) * (alty[y + 1] - alty[y])) % MOD;\n\t\t\t\t\tlong long st = ((long long)(altx[nx + 1] - altx[nx]) * (alty[ny + 1] - alty[ny])) % MOD;\n\t\t\t\t\tres += (long long)(dist[nx][ny]) * ss % MOD * st % MOD;\n\t\t\t\t\tres %= MOD;\n\t\t\t\t\t//cout << pint(x, y) << \", \" << pint(nx, ny) << \": \" << dist[nx][ny] << \", \" << ss << \", \" << st << endl;\n\t\t\t\t}\n\t\t\t}\n\t\t\t\n\t\t}\n\t\t//cout << endl;\n\t}\n\t//COUT(res);\n\n\treturn res;\n}\n\nFp solve() {\n  memset(xnum, 0, sizeof(xnum));\n  memset(ynum, 0, sizeof(ynum));\n\taltx.clear();\n\talty.clear();\n  altx.push_back(0);\n  altx.push_back(H);\n  alty.push_back(0);\n  alty.push_back(W);\n  for (int i = 0; i < N; ++i) {\n\t\taltx.push_back(bx[i]);\n\t\taltx.push_back(bx[i] + 1);\n\t\talty.push_back(by[i]);\n\t\talty.push_back(by[i] + 1);\n\t\txnum[bx[i]]++;\n\t\tynum[by[i]]++;\n  }\n  sort(altx.begin(), altx.end());\n  sort(alty.begin(), alty.end());\n  altx.erase(unique(altx.begin(), altx.end()), altx.end());\n  alty.erase(unique(alty.begin(), alty.end()), alty.end());\n  nH = altx.size();\n  nW = alty.size();\n\n  memset(cb, 0, sizeof(cb));\n  for (int i = 0; i < N; ++i) {\n\t\tint itx = lower_bound(altx.begin(), altx.end(), bx[i]) - altx.begin();\n\t\tint ity = lower_bound(alty.begin(), alty.end(), by[i]) - alty.begin();\n\t\tcb[itx][ity] = true;\n  }\n\n  long long all = (long long)H * W - N;\n  Fp add = 0;\n  long long width = W;\n  int num_comped = 0;\n  long long sum = width - xnum[0];\n  for (int i = 1; i < H; ++i) {\n\t\tif (xnum[i] == 0 && xnum[i-1] == 0) {   // i-1 -> i\n\t\t\tFp up = sum - width * num_comped;\n\t\t\tFp down = all - sum;\n\t\t\tadd += up * down;\n\t\t}\n\t\tsum += width - xnum[i];\n  }\n  long long height = H - num_comped;\n  all -= width * num_comped;\n  num_comped = 0;\n  sum = height - ynum[0];\n  for (int i = 1; i < W; ++i) {\n\t\tif (ynum[i] == 0 && ynum[i-1] == 0) {   // i-1 -> i\n\t\t\tFp left = sum - height * num_comped;\n\t\t\tFp right = all - sum;\n\t\t\tadd += left * right;\n\t\t}\n\t\tsum += height - ynum[i];\n  }\n\n  Fp comp = subsolve();\n  Fp res = comp + add;\n\n\t//COUT(add);\n\n  return res;\n}\n\nint main() {\n  while (cin >> H >> W >> N) {\n\t\tfor (int i = 0; i < N; ++i) cin >> bx[i] >> by[i];\n\t\tcout << solve() << endl;\n  }\n}\n"
  },
  {
    "language": "C++",
    "code": "#ifndef __clang__\n#pragma GCC optimize \"-O3\"\n#pragma GCC target \"tune=native\"\n#endif\n#ifdef ONLINE_JUDGE\n#define NDEBUG 1\n#endif\n#include <stdio.h>\n#include <bits/stdc++.h>\n\n#define FOR(i, n)     for(lli i = 0; i < (lli)(n); ++i)\n#define FORU(i, j, k) for(lli i = (j); i <= (lli)(k); ++i)\n#define FORD(i, j, k) for(lli i = (j); i >= (lli)(k); --i)\n\n#define SQ(x) ((x)*(x))\n\n#define all(x) begin(x), end(x)\n#define rall(x) rbegin(x), rend(x)\n#define mp make_pair\n#define mt make_tuple\n#define pb push_back\n#define eb emplace_back\n\nusing namespace std;\n\ntemplate<typename... As>\nstruct tpl : public std::tuple<As...> {\n  using std::tuple<As...>::tuple;\n  tpl(){}\n  tpl(std::tuple<As...> const& b) { std::tuple<As...>::operator=(b); }\n\n  template<typename T = tuple<As...> >\n  typename tuple_element<0, T>::type const&\n  x() const { return get<0>(*this); }\n  template<typename T = tuple<As...> >\n  typename tuple_element<0, T>::type&\n  x() { return get<0>(*this); }\n\n  template<typename T = tuple<As...> >\n  typename tuple_element<1, T>::type const&\n  y() const { return get<1>(*this); }\n  template<typename T = tuple<As...> >\n  typename tuple_element<1, T>::type&\n  y() { return get<1>(*this); }\n\n  template<typename T = tuple<As...> >\n  typename tuple_element<2, T>::type const&\n  z() const { return get<2>(*this); }\n  template<typename T = tuple<As...> >\n  typename tuple_element<2, T>::type&\n  z() { return get<2>(*this); }\n\n  template<typename T = tuple<As...> >\n  typename tuple_element<3, T>::type const&\n  w() const { return get<3>(*this); }\n  template<typename T = tuple<As...> >\n  typename tuple_element<3, T>::type&\n  w() { return get<3>(*this); }\n};\n\nusing lli   = long long int;\nusing llu   = long long unsigned;\n\nusing pii   = tpl<lli, lli>;\nusing piii  = tpl<lli, lli, lli>;\nusing piiii = tpl<lli, lli, lli, lli>;\nusing vi    = vector<lli>;\nusing vii   = vector<pii>;\nusing viii  = vector<piii>;\nusing vvi   = vector<vi>;\nusing vvii  = vector<vii>;\nusing vviii = vector<viii>;\n\ntemplate<class T>\nusing min_queue = priority_queue<T, vector<T>, greater<T> >;\ntemplate<class T>\nusing max_queue = priority_queue<T>;\n\ntemplate<size_t... I>\nstruct my_index_sequence {\n  using type = my_index_sequence;\n  static constexpr array<size_t, sizeof...(I)> value = { {I...} };\n};\n\nnamespace my_index_sequence_detail {\n  template<typename I, typename J> struct concat;\n  template<size_t... I, size_t... J>\n  struct concat<my_index_sequence<I...>, my_index_sequence<J...> > :\n    my_index_sequence<I..., (sizeof...(I)+J)...> { };\n  template<size_t N> struct make_index_sequence :\n    concat<typename make_index_sequence<N/2>::type, typename make_index_sequence<N-N/2>::type>::type { };\n  template <> struct make_index_sequence<0> : my_index_sequence<>{};\n  template <> struct make_index_sequence<1> : my_index_sequence<0>{};\n}\n\ntemplate<class... A>\nusing my_index_sequence_for = typename my_index_sequence_detail::make_index_sequence<sizeof...(A)>::type;\n\ntemplate<class T, size_t... I>\nvoid print_tuple(ostream& s, T const& a, my_index_sequence<I...>){\n  using swallow = int[];\n  (void)swallow{0, (void(s << (I == 0? \"\" : \", \") << get<I>(a)), 0)...};\n}\n\ntemplate<class T>\nostream& print_collection(ostream& s, T const& a);\ntemplate<class... A>\nostream& operator<<(ostream& s, tpl<A...> const& a);\ntemplate<class... A>\nostream& operator<<(ostream& s, tuple<A...> const& a);\ntemplate<class A, class B>\nostream& operator<<(ostream& s, pair<A, B> const& a);\n\ntemplate<class T, size_t I>\nostream& operator<<(ostream& s, array<T, I> const& a) { return print_collection(s, a); }\ntemplate<class T>\nostream& operator<<(ostream& s, vector<T> const& a) { return print_collection(s, a); }\ntemplate<class T, class U>\nostream& operator<<(ostream& s, multimap<T, U> const& a) { return print_collection(s, a); }\ntemplate<class T>\nostream& operator<<(ostream& s, multiset<T> const& a) { return print_collection(s, a); }\ntemplate<class T, class U>\nostream& operator<<(ostream& s, map<T, U> const& a) { return print_collection(s, a); }\ntemplate<class T>\nostream& operator<<(ostream& s, set<T> const& a) { return print_collection(s, a); }\n\ntemplate<class T>\nostream& print_collection(ostream& s, T const& a){\n  s << '[';\n  for(auto it = begin(a); it != end(a); ++it){\n    s << *it;\n    if(it != prev(end(a))) s << \" \";\n  }\n  return s << ']';\n}\n\ntemplate<class... A>\nostream& operator<<(ostream& s, tpl<A...> const& a){\n  s << '(';\n  print_tuple(s, a, my_index_sequence_for<A...>{});\n  return s << ')';\n}\n\ntemplate<class... A>\nostream& operator<<(ostream& s, tuple<A...> const& a){\n  s << '(';\n  print_tuple(s, a, my_index_sequence_for<A...>{});\n  return s << ')';\n}\n\ntemplate<class A, class B>\nostream& operator<<(ostream& s, pair<A, B> const& a){\n  return s << \"(\" << get<0>(a) << \", \" << get<1>(a) << \")\";\n}\n\n//------------------------------------------------------------------------------\n\nconst lli MOD = 1e9+7;\n\nconst int N = 2e6;\nbool A[N];\nbool B[N];\n\nlli R[100], C[100];\nlli WR[100], WC[100];\nbool E[100][100];\nbool V[100][100];\nlli D[100][100];\n\nconst lli dx[4] = {1,-1,0,0};\nconst lli dy[4] = {0,0,1,-1};\n\nint main(){\n  ios::sync_with_stdio(0); cin.tie(0);\n  lli n,m; cin>>n>>m;\n  vii ps;\n  vvi xs(n), ys(m);\n  lli np; cin>>np;\n  FOR(i,np) {\n    lli x,y; cin>>x>>y;\n    A[x]=1; B[y]=1;\n    xs[x].pb(y); ys[y].pb(x);\n    ps.pb(mt(x,y));\n  }\n  lli tot = (n*m - np) % MOD;\n  lli ans = 0;\n  lli nr = -1, nc = -1;\n  FOR(i,100) WR[i]=WC[i] = -1;\n  { lli l = 0;\n    FOR(i,n) {\n      l %= MOD;\n      if(A[i]) {\n        nr++; R[nr] = 1; WR[nr] = i;\n        l += m - xs[i].size();\n      } else if(i==0 || A[i-1]) {\n        nr++; R[nr] = 1; l += m;\n      } else {\n        R[nr]++;\n        (ans += (l * (tot-l+MOD)) % MOD) %= MOD;\n        l += m;\n      }\n    }\n  }\n  { lli l = 0;\n    FOR(j,m) {\n      l %= MOD;\n      if(B[j]) {\n        nc++; C[nc] = 1; WC[nc] = j;\n        l += m - ys[j].size();\n      } else if(j==0 || B[j-1]) {\n        nc++; C[nc] = 1; l += n;\n      } else {\n        C[nc]++;\n        (ans += (l * (tot-l+MOD)) % MOD) %= MOD;\n        l += n;\n      }\n    }\n  }\n  nr++; nc++;\n  FOR(i,nr) FOR(j,nc) { E[i][j] = 1; for(auto p : ps) if(p == mt(WR[i],WC[j])) E[i][j] = 0; }\n  FOR(i,nr) FOR(j,nc) if(E[i][j]) {\n    FOR(x,nr) FOR(y,nc) { V[x][y] = 0; D[x][y] = (1<<20); }\n    queue<pii> Q; Q.push(mt(i,j)); D[i][j] = 0; V[i][j] = 1;\n    while(!Q.empty()) {\n      lli x,y; tie(x,y) = Q.front(); Q.pop();\n      // cout << mt(i,j) << \" \" << mt(x,y) << \" \" << D[x][y] << endl;\n      if(mt(i,j) < mt(x,y)) (ans += D[x][y] * R[i] % MOD * C[j] % MOD * R[x] % MOD * C[y] % MOD) %= MOD;\n      FOR(d,4) {\n        lli x_ = x+dx[d], y_ = y+dy[d];\n        if(x_<0||x_>=nr||y_<0||y_>=nc) continue;\n        if(!E[x_][y_]) continue;\n        if(V[x_][y_]) continue;\n        V[x_][y_] = 1;\n        D[x_][y_] = D[x][y]+1;\n        Q.push(mt(x_,y_));\n      }\n    }\n  }\n  cout << ans << endl;\n  return 0;\n}\n"
  },
  {
    "language": "C++",
    "code": "/**\n *    author:  tourist\n *    created: 29.11.2019 05:14:55       \n**/\n#include <bits/stdc++.h>\n\nusing namespace std;\n\ntemplate <typename A, typename B>\nstring to_string(pair<A, B> p);\n\ntemplate <typename A, typename B, typename C>\nstring to_string(tuple<A, B, C> p);\n\ntemplate <typename A, typename B, typename C, typename D>\nstring to_string(tuple<A, B, C, D> p);\n\nstring to_string(const string& s) {\n  return '\"' + s + '\"';\n}\n\nstring to_string(const char* s) {\n  return to_string((string) s);\n}\n\nstring to_string(bool b) {\n  return (b ? \"true\" : \"false\");\n}\n\nstring to_string(vector<bool> v) {\n  bool first = true;\n  string res = \"{\";\n  for (int i = 0; i < static_cast<int>(v.size()); i++) {\n    if (!first) {\n      res += \", \";\n    }\n    first = false;\n    res += to_string(v[i]);\n  }\n  res += \"}\";\n  return res;\n}\n\ntemplate <size_t N>\nstring to_string(bitset<N> v) {\n  string res = \"\";\n  for (size_t i = 0; i < N; i++) {\n    res += static_cast<char>('0' + v[i]);\n  }\n  return res;\n}\n\ntemplate <typename A>\nstring to_string(A v) {\n  bool first = true;\n  string res = \"{\";\n  for (const auto &x : v) {\n    if (!first) {\n      res += \", \";\n    }\n    first = false;\n    res += to_string(x);\n  }\n  res += \"}\";\n  return res;\n}\n\ntemplate <typename A, typename B>\nstring to_string(pair<A, B> p) {\n  return \"(\" + to_string(p.first) + \", \" + to_string(p.second) + \")\";\n}\n\ntemplate <typename A, typename B, typename C>\nstring to_string(tuple<A, B, C> p) {\n  return \"(\" + to_string(get<0>(p)) + \", \" + to_string(get<1>(p)) + \", \" + to_string(get<2>(p)) + \")\";\n}\n\ntemplate <typename A, typename B, typename C, typename D>\nstring to_string(tuple<A, B, C, D> p) {\n  return \"(\" + to_string(get<0>(p)) + \", \" + to_string(get<1>(p)) + \", \" + to_string(get<2>(p)) + \", \" + to_string(get<3>(p)) + \")\";\n}\n\nvoid debug_out() { cerr << endl; }\n\ntemplate <typename Head, typename... Tail>\nvoid debug_out(Head H, Tail... T) {\n  cerr << \" \" << to_string(H);\n  debug_out(T...);\n}\n\n#ifdef LOCAL\n#define debug(...) cerr << \"[\" << #__VA_ARGS__ << \"]:\", debug_out(__VA_ARGS__)\n#else\n#define debug(...) 42\n#endif\n\ntemplate <typename T>\nT inverse(T a, T m) {\n  T u = 0, v = 1;\n  while (a != 0) {\n    T t = m / a;\n    m -= t * a; swap(a, m);\n    u -= t * v; swap(u, v);\n  }\n  assert(m == 1);\n  return u;\n}\n\ntemplate <typename T>\nclass Modular {\n public:\n  using Type = typename decay<decltype(T::value)>::type;\n\n  constexpr Modular() : value() {}\n  template <typename U>\n  Modular(const U& x) {\n    value = normalize(x);\n  }\n\n  template <typename U>\n  static Type normalize(const U& x) {\n    Type v;\n    if (-mod() <= x && x < mod()) v = static_cast<Type>(x);\n    else v = static_cast<Type>(x % mod());\n    if (v < 0) v += mod();\n    return v;\n  }\n\n  const Type& operator()() const { return value; }\n  template <typename U>\n  explicit operator U() const { return static_cast<U>(value); }\n  constexpr static Type mod() { return T::value; }\n\n  Modular& operator+=(const Modular& other) { if ((value += other.value) >= mod()) value -= mod(); return *this; }\n  Modular& operator-=(const Modular& other) { if ((value -= other.value) < 0) value += mod(); return *this; }\n  template <typename U> Modular& operator+=(const U& other) { return *this += Modular(other); }\n  template <typename U> Modular& operator-=(const U& other) { return *this -= Modular(other); }\n  Modular& operator++() { return *this += 1; }\n  Modular& operator--() { return *this -= 1; }\n  Modular operator++(int) { Modular result(*this); *this += 1; return result; }\n  Modular operator--(int) { Modular result(*this); *this -= 1; return result; }\n  Modular operator-() const { return Modular(-value); }\n\n  template <typename U = T>\n  typename enable_if<is_same<typename Modular<U>::Type, int>::value, Modular>::type& operator*=(const Modular& rhs) {\n#ifdef _WIN32\n    uint64_t x = static_cast<int64_t>(value) * static_cast<int64_t>(rhs.value);\n    uint32_t xh = static_cast<uint32_t>(x >> 32), xl = static_cast<uint32_t>(x), d, m;\n    asm(\n      \"divl %4; \\n\\t\"\n      : \"=a\" (d), \"=d\" (m)\n      : \"d\" (xh), \"a\" (xl), \"r\" (mod())\n    );\n    value = m;\n#else\n    value = normalize(static_cast<int64_t>(value) * static_cast<int64_t>(rhs.value));\n#endif\n    return *this;\n  }\n  template <typename U = T>\n  typename enable_if<is_same<typename Modular<U>::Type, int64_t>::value, Modular>::type& operator*=(const Modular& rhs) {\n    int64_t q = static_cast<int64_t>(static_cast<long double>(value) * rhs.value / mod());\n    value = normalize(value * rhs.value - q * mod());\n    return *this;\n  }\n  template <typename U = T>\n  typename enable_if<!is_integral<typename Modular<U>::Type>::value, Modular>::type& operator*=(const Modular& rhs) {\n    value = normalize(value * rhs.value);\n    return *this;\n  }\n\n  Modular& operator/=(const Modular& other) { return *this *= Modular(inverse(other.value, mod())); }\n\n  template <typename U>\n  friend const Modular<U>& abs(const Modular<U>& v) { return v; }\n\n  template <typename U>\n  friend bool operator==(const Modular<U>& lhs, const Modular<U>& rhs);\n\n  template <typename U>\n  friend bool operator<(const Modular<U>& lhs, const Modular<U>& rhs);\n\n  template <typename U>\n  friend std::istream& operator>>(std::istream& stream, Modular<U>& number);\n\n private:\n  Type value;\n};\n\ntemplate <typename T> bool operator==(const Modular<T>& lhs, const Modular<T>& rhs) { return lhs.value == rhs.value; }\ntemplate <typename T, typename U> bool operator==(const Modular<T>& lhs, U rhs) { return lhs == Modular<T>(rhs); }\ntemplate <typename T, typename U> bool operator==(U lhs, const Modular<T>& rhs) { return Modular<T>(lhs) == rhs; }\n\ntemplate <typename T> bool operator!=(const Modular<T>& lhs, const Modular<T>& rhs) { return !(lhs == rhs); }\ntemplate <typename T, typename U> bool operator!=(const Modular<T>& lhs, U rhs) { return !(lhs == rhs); }\ntemplate <typename T, typename U> bool operator!=(U lhs, const Modular<T>& rhs) { return !(lhs == rhs); }\n\ntemplate <typename T> bool operator<(const Modular<T>& lhs, const Modular<T>& rhs) { return lhs.value < rhs.value; }\n\ntemplate <typename T> Modular<T> operator+(const Modular<T>& lhs, const Modular<T>& rhs) { return Modular<T>(lhs) += rhs; }\ntemplate <typename T, typename U> Modular<T> operator+(const Modular<T>& lhs, U rhs) { return Modular<T>(lhs) += rhs; }\ntemplate <typename T, typename U> Modular<T> operator+(U lhs, const Modular<T>& rhs) { return Modular<T>(lhs) += rhs; }\n\ntemplate <typename T> Modular<T> operator-(const Modular<T>& lhs, const Modular<T>& rhs) { return Modular<T>(lhs) -= rhs; }\ntemplate <typename T, typename U> Modular<T> operator-(const Modular<T>& lhs, U rhs) { return Modular<T>(lhs) -= rhs; }\ntemplate <typename T, typename U> Modular<T> operator-(U lhs, const Modular<T>& rhs) { return Modular<T>(lhs) -= rhs; }\n\ntemplate <typename T> Modular<T> operator*(const Modular<T>& lhs, const Modular<T>& rhs) { return Modular<T>(lhs) *= rhs; }\ntemplate <typename T, typename U> Modular<T> operator*(const Modular<T>& lhs, U rhs) { return Modular<T>(lhs) *= rhs; }\ntemplate <typename T, typename U> Modular<T> operator*(U lhs, const Modular<T>& rhs) { return Modular<T>(lhs) *= rhs; }\n\ntemplate <typename T> Modular<T> operator/(const Modular<T>& lhs, const Modular<T>& rhs) { return Modular<T>(lhs) /= rhs; }\ntemplate <typename T, typename U> Modular<T> operator/(const Modular<T>& lhs, U rhs) { return Modular<T>(lhs) /= rhs; }\ntemplate <typename T, typename U> Modular<T> operator/(U lhs, const Modular<T>& rhs) { return Modular<T>(lhs) /= rhs; }\n\ntemplate<typename T, typename U>\nModular<T> power(const Modular<T>& a, const U& b) {\n  assert(b >= 0);\n  Modular<T> x = a, res = 1;\n  U p = b;\n  while (p > 0) {\n    if (p & 1) res *= x;\n    x *= x;\n    p >>= 1;\n  }\n  return res;\n}\n\ntemplate <typename T>\nbool IsZero(const Modular<T>& number) {\n  return number() == 0;\n}\n\ntemplate <typename T>\nstring to_string(const Modular<T>& number) {\n  return to_string(number());\n}\n\ntemplate <typename T>\nstd::ostream& operator<<(std::ostream& stream, const Modular<T>& number) {\n  return stream << number();\n}\n\ntemplate <typename T>\nstd::istream& operator>>(std::istream& stream, Modular<T>& number) {\n  typename common_type<typename Modular<T>::Type, int64_t>::type x;\n  stream >> x;\n  number.value = Modular<T>::normalize(x);\n  return stream;\n}\n\n/*\nusing ModType = int;\n\nstruct VarMod { static ModType value; };\nModType VarMod::value;\nModType& md = VarMod::value;\nusing Mint = Modular<VarMod>;\n*/\n\nconstexpr int md = (int) 1e9 + 7;\nusing Mint = Modular<std::integral_constant<decay<decltype(md)>::type, md>>;\n\nint main() {\n  ios::sync_with_stdio(false);\n  cin.tie(0);\n  int h, w, n;\n  cin >> h >> w >> n;\n  vector<int> x(n), y(n);\n  for (int i = 0; i < n; i++) {\n    cin >> x[i] >> y[i];\n  }\n  vector<int> xs, ys;\n  for (int i = 0; i < n; i++) {\n    xs.push_back(x[i]);\n    xs.push_back(x[i] + 1);\n    ys.push_back(y[i]);\n    ys.push_back(y[i] + 1);\n  }\n  xs.push_back(0);\n  xs.push_back(h);\n  ys.push_back(0);\n  ys.push_back(w);\n  sort(xs.begin(), xs.end());\n  xs.resize(unique(xs.begin(), xs.end()) - xs.begin());\n  sort(ys.begin(), ys.end());\n  ys.resize(unique(ys.begin(), ys.end()) - ys.begin());\n  int xn = (int) xs.size() - 1;\n  int yn = (int) ys.size() - 1;\n  vector<vector<Mint>> weight(xn, vector<Mint>(yn));\n  for (int i = 0; i < xn; i++) {\n    for (int j = 0; j < yn; j++) {\n      weight[i][j] = Mint(xs[i + 1] - xs[i]) * (ys[j + 1] - ys[j]);\n    }\n  }\n  for (int i = 0; i < n; i++) {\n    int xp = (int) (lower_bound(xs.begin(), xs.end(), x[i]) - xs.begin());\n    int yp = (int) (lower_bound(ys.begin(), ys.end(), y[i]) - ys.begin());\n    weight[xp][yp] = 0;\n  }\n  Mint ans = 0;\n  for (int sx = 0; sx < xn; sx++) {\n    for (int sy = 0; sy < yn; sy++) {\n      if (weight[sx][sy] == 0) {\n        continue;\n      }\n      vector<vector<int>> dist(xn, vector<int>(yn, -1));\n      vector<pair<int, int>> que(1, make_pair(sx, sy));\n      dist[sx][sy] = 0;\n      for (int b = 0; b < (int) que.size(); b++) {\n        for (int dx = -1; dx <= 1; dx++) {\n          for (int dy = -1; dy <= 1; dy++) {\n            if (dx * dx + dy * dy != 1) {\n              continue;\n            }\n            int xk = que[b].first + dx;\n            int yk = que[b].second + dy;\n            if (xk >= 0 && yk >= 0 && xk < xn && yk < yn) {\n              if (weight[xk][yk] != 0 && dist[xk][yk] == -1) {\n                que.emplace_back(xk, yk);\n                dist[xk][yk] = dist[que[b].first][que[b].second] + 1;\n              }\n            }\n          }\n        }\n      }\n      for (int i = 0; i < xn; i++) {\n        for (int j = 0; j < yn; j++) {\n          ans += dist[i][j] * weight[sx][sy] * weight[i][j];\n        }\n      }\n    }\n  }\n  for (int i = 0; i < xn; i++) {\n    int steps = xs[i + 1] - xs[i] - 1;\n    Mint L = 0, R = 0;\n    for (int ii = 0; ii < i; ii++) {\n      for (int j = 0; j < yn; j++) {\n        L += weight[ii][j];\n      }\n    }\n    for (int ii = i; ii < xn; ii++) {\n      for (int j = 0; j < yn; j++) {\n        R += weight[ii][j];\n      }\n    }\n    while (steps--) {\n      L += w;\n      R -= w;\n      ans += 2 * L * R;\n    }\n  }\n  for (int j = 0; j < yn; j++) {\n    int steps = ys[j + 1] - ys[j] - 1;\n    Mint L = 0, R = 0;\n    for (int i = 0; i < xn; i++) {\n      for (int jj = 0; jj < j; jj++) {\n        L += weight[i][jj];\n      }\n    }\n    for (int i = 0; i < xn; i++) {\n      for (int jj = j; jj < yn; jj++) {\n        R += weight[i][jj];\n      }\n    }\n    while (steps--) {\n      L += h;\n      R -= h;\n      ans += 2 * L * R;\n    }\n  }\n  cout << ans / 2 << '\\n';\n  return 0;\n}\n"
  },
  {
    "language": "C++",
    "code": "#include <algorithm>  \n#include <iostream>  \n#include <sstream>  \n#include <string>  \n#include <cstring>\n#include <vector>  \n#include <queue>  \n#include <set>  \n#include <map>  \n#include <cstdio>  \n#include <cstdlib>  \n#include <cctype>  \n#include <cmath>  \n#include <list>  \n#include <cassert>\n#include <ctime>\n#include <climits>\nusing namespace std;  \n\n#define PB push_back  \n#define MP make_pair  \n#define SZ(v) ((int)(v).size())  \n#define FOR(i,a,b) for(int i=(a);i<(b);++i)  \n#define REP(i,n) FOR(i,0,n)  \n#define FORE(i,a,b) for(int i=(a);i<=(b);++i)  \n#define REPE(i,n) FORE(i,0,n)  \n#define FORSZ(i,a,v) FOR(i,a,SZ(v))  \n#define REPSZ(i,v) REP(i,SZ(v))  \ntypedef long long ll;\ntypedef unsigned long long ull;\nll gcd(ll a,ll b) { return b==0?a:gcd(b,a%b); }\n\nconst int MAXN=30;\nconst int MAXDIM=2*MAXN+1;\nconst int MOD=1000000007;\nconst int INV2=(MOD+1)/2;\nconst int DX[]={-1,0,+1,0},DY[]={0,+1,0,-1};\n\nint h,w,n;\nint px[MAXN],py[MAXN];\n\nint xx[2*MAXN+2],yy[2*MAXN+2],nxx,nyy;\n\nbool blocked[MAXDIM][MAXDIM];\nint cnt[MAXDIM][MAXDIM];\n\nint dst[MAXDIM][MAXDIM];\nint qx[MAXDIM*MAXDIM],qy[MAXDIM*MAXDIM],qhead,qtail;\nvoid upd(int x,int y,int d) { if(dst[x][y]!=INT_MAX) return; dst[x][y]=d; qx[qhead]=x,qy[qhead]=y,++qhead; }\n\n\nvoid run() {\n\tscanf(\"%d%d%d\",&h,&w,&n);\n\tREP(i,n) scanf(\"%d%d\",&px[i],&py[i]);\n\n\tnxx=0; xx[nxx++]=0,xx[nxx++]=h; REP(i,n) xx[nxx++]=px[i],xx[nxx++]=px[i]+1; sort(xx,xx+nxx); nxx=unique(xx,xx+nxx)-xx; REP(i,n) px[i]=lower_bound(xx,xx+nxx,px[i])-xx;\n\tnyy=0; yy[nyy++]=0,yy[nyy++]=w; REP(i,n) yy[nyy++]=py[i],yy[nyy++]=py[i]+1; sort(yy,yy+nyy); nyy=unique(yy,yy+nyy)-yy; REP(i,n) py[i]=lower_bound(yy,yy+nyy,py[i])-yy;\n\n\tREP(x,nxx-1) REP(y,nyy-1) blocked[x][y]=false,cnt[x][y]=(ll)(xx[x+1]-xx[x])*(yy[y+1]-yy[y])%MOD;\n\tREP(i,n) blocked[px[i]][py[i]]=true;\n\tREP(x,nxx-1) { REP(y,nyy-1) printf(\"%c\",blocked[x][y]?'#':'.'); puts(\"\"); }\n\n\tint ret=0;\n\tREP(sx,nxx-1) REP(sy,nyy-1) if(!blocked[sx][sy]) {\n\t\tREP(x,nxx-1) REP(y,nyy-1) dst[x][y]=INT_MAX; qhead=qtail=0;\n\t\tupd(sx,sy,0);\n\t\twhile(qtail<qhead) {\n\t\t\tint x=qx[qtail],y=qy[qtail]; ++qtail;\n\t\t\tREP(k,4) {\n\t\t\t\tint nx=x+DX[k],ny=y+DY[k]; if(nx<0||nx>=h||ny<0||ny>=w||blocked[nx][ny]) continue;\n\t\t\t\tupd(nx,ny,dst[x][y]+1);\n\t\t\t}\n\t\t}\n\t\tREP(x,nxx-1) REP(y,nyy-1) if(!blocked[x][y]) {\n\t\t\tret=(ret+(ll)cnt[sx][sy]*cnt[x][y]%MOD*dst[x][y])%MOD;\n\t\t}\n\t}\n\tret=(ll)ret*INV2%MOD;\n\n\tREP(x,nxx-1) {\n\t\tint len=xx[x+1]-xx[x]; if(len==1) continue;\n\t\tint a=(ll)(len-1)*len*(len+1)/6%MOD;\n\t\tint b=(ll)h*h%MOD;\n\t\tint c=(ll)len*(len-1)/2%MOD;\n\t\tint lft=0,rgt=0; REP(cx,nxx-1) REP(cy,nyy-1) if(!blocked[cx][cy]) if(cx<x) lft=(lft+cnt[cx][cy])%MOD; else if(cx>x) rgt=(rgt+cnt[cx][cy])%MOD;\n\t\t//printf(\"cnt=%d a=%d b=%d c=%d lft=%d rgt=%d\\n\",len,a,b,c,lft,rgt);\n\t\tret=(ret+(ll)a*b)%MOD;\n\t\tret=(ret+(ll)lft*rgt%MOD*(len-1))%MOD;\n\t\tret=(ret+(ll)(lft+rgt)*c%MOD*h)%MOD;\n\t}\n\tREP(y,nyy-1) {\n\t\tint len=yy[y+1]-yy[y]; if(len==1) continue;\n\t\tint a=(ll)(len-1)*len*(len+1)/6%MOD;\n\t\tint b=(ll)h*h%MOD;\n\t\tint c=(ll)len*(len-1)/2%MOD;\n\t\tint lft=0,rgt=0; REP(cx,nxx-1) REP(cy,nyy-1) if(!blocked[cx][cy]) if(cy<y) lft=(lft+cnt[cx][cy])%MOD; else if(cy>y) rgt=(rgt+cnt[cx][cy])%MOD;\n\t\t//printf(\"cnt=%d a=%d b=%d c=%d lft=%d rgt=%d\\n\",len,a,b,c,lft,rgt);\n\t\tret=(ret+(ll)a*b)%MOD;\n\t\tret=(ret+(ll)lft*rgt%MOD*(len-1))%MOD;\n\t\tret=(ret+(ll)(lft+rgt)*c%MOD*h)%MOD;\n\t}\n\n\tprintf(\"%d\\n\",ret);\n}\n\nint main() {\n\trun();\n\treturn 0;\n}\n"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\n#define fi first\n#define se second\n#define rep(i,n) for(int i = 0; i < (n); ++i)\n#define rrep(i,n) for(int i = 1; i <= (n); ++i)\n#define drep(i,n) for(int i = (n)-1; i >= 0; --i)\n#define srep(i,s,t) for (int i = s; i < t; ++i)\n#define each(it,c) for(__typeof((c).begin()) it=(c).begin();it!=(c).end();it++)\n#define rng(a) a.begin(),a.end()\n#define maxs(x,y) x = max(x,y)\n#define mins(x,y) x = min(x,y)\n#define pb push_back\n#define sz(x) (int)(x).size()\n#define pcnt __builtin_popcountll\n#define uni(x) x.erase(unique(rng(x)),x.end())\n#define snuke srand((unsigned)clock()+(unsigned)time(NULL));\n#define df(x) int x = in()\n#define dame { puts(\"-1\"); return 0;}\n#define show(x) cout<<#x<<\" = \"<<x<<endl;\n#define PQ(T) priority_queue<T,vector<T>,greater<T> >\n#define bn(x) ((1<<x)-1)\n#define newline puts(\"\")\n#define v(T) vector<T>\n#define vv(T) vector<vector<T>>\nusing namespace std;\ntypedef long long int ll;\ntypedef unsigned uint;\ntypedef unsigned long long ull;\ntypedef pair<int,int> P;\ntypedef vector<int> vi;\ntypedef vector<vi> vvi;\ntypedef vector<ll> vl;\ntypedef vector<vl> vvl;\ntypedef vector<P> vp;\ninline int in() { int x; scanf(\"%d\",&x); return x;}\ninline void priv(vi a) { rep(i,sz(a)) printf(\"%d%c\",a[i],i==sz(a)-1?'\\n':' ');}\ntemplate<typename T>inline istream& operator>>(istream&i,vector<T>&v)\n{rep(j,sz(v))i>>v[j];return i;}\ntemplate<typename T>string join(const vector<T>&v)\n{stringstream s;rep(i,sz(v))s<<' '<<v[i];return s.str().substr(1);}\ntemplate<typename T>inline ostream& operator<<(ostream&o,const vector<T>&v)\n{if(sz(v))o<<join(v);return o;}\ntemplate<typename T1,typename T2>inline istream& operator>>(istream&i,pair<T1,T2>&v)\n{return i>>v.fi>>v.se;}\ntemplate<typename T1,typename T2>inline ostream& operator<<(ostream&o,const pair<T1,T2>&v)\n{return o<<v.fi<<\",\"<<v.se;}\nconst int MX = 200005, INF = 1001001001;\nconst ll LINF = 1e18;\nconst double eps = 1e-10;\nconst int di[] = {-1,0,1,0}, dj[] = {0,-1,0,1}; //^<v>\n\n// Mod int\nconst int mod = 1000000007;\nstruct mint {\n  ll x;\n  mint():x(0){}\n  mint(ll x):x((x%mod+mod)%mod){}\n  // mint(ll x):x(x){}\n  mint& fix() { x = (x%mod+mod)%mod; return *this;}\n  mint& operator+=(const mint& a){ if((x+=a.x)>=mod) x-=mod; return *this;}\n  mint& operator-=(const mint& a){ if((x+=mod-a.x)>=mod) x-=mod; return *this;}\n  mint& operator*=(const mint& a){ (x*=a.x)%=mod; return *this;}\n  mint operator+(const mint& a)const{ return mint(*this) += a;}\n  mint operator-(const mint& a)const{ return mint(*this) -= a;}\n  mint operator*(const mint& a)const{ return mint(*this) *= a;}\n  bool operator<(const mint& a)const{ return x < a.x;}\n  bool operator==(const mint& a)const{ return x == a.x;}\n};\nistream& operator>>(istream&i,mint&a){i>>a.x;return i;}\nostream& operator<<(ostream&o,const mint&a){o<<a.x;return o;}\ntypedef vector<mint> vm;\n//\n\n// coordinate compression\nstruct X {\n  typedef int T;\n  vector<T> d;\n  X() {}\n  void add(T x) { d.pb(x);}\n  void init() {\n    sort(rng(d));\n    d.erase(unique(rng(d)), d.end());\n  }\n  int size() const { return sz(d);}\n  T operator[](int i) const { return d[i];}\n  int operator()(T x) const { return upper_bound(rng(d),x)-d.begin()-1;}\n};\n//\n\nint H, W;\nX xs, ys;\nvoid initXY(vp& a) {\n  xs.add(0); xs.add(H);\n  ys.add(0); ys.add(W);\n  rep(i,2) for (P p : a) {\n    xs.add(p.fi+i);\n    ys.add(p.se+i);\n  }\n  xs.init(); ys.init();\n  for (P& p : a) p.fi = xs(p.fi), p.se = ys(p.se);\n}\n\n\n\nint main() {\n  int n;\n  scanf(\"%d%d%d\",&H,&W,&n);\n  vp p(n);\n  cin>>p;\n  initXY(p);\n  int h = sz(xs)-1, w = sz(ys)-1;\n  vvl a(h,vl(w));\n  rep(i,h)rep(j,w) {\n    ll dx = xs[i+1]-xs[i];\n    ll dy = ys[j+1]-ys[j];\n    a[i][j] = dx*dy;\n  }\n  mint ans = 0;\n  rep(i,n) a[p[i].fi][p[i].se] = -1;\n  rep(si,h)rep(sj,w) if (a[si][sj] != -1) {\n    vvi dist(h,vi(w,INF));\n    queue<P> q;\n    q.push(P(si,sj)); dist[si][sj] = 0;\n    while (sz(q)) {\n      int i = q.front().fi, j = q.front().se; q.pop();\n      if (P(i,j) < P(si,sj)) ans += mint(a[si][sj])*a[i][j]*dist[i][j];\n      rep(v,4) {\n        int ni = i+di[v], nj = j+dj[v];\n        if (ni<0||nj<0||ni>=h||nj>=w) continue;\n        if (a[ni][nj] == -1) continue;\n        if (dist[ni][nj] != INF) continue;\n        dist[ni][nj] = dist[i][j]+1;\n        q.push(P(ni,nj));\n      }\n    }\n  }\n  vi x(H+1), y(W+1);\n  rep(i,h) x[xs[i]] = 1;\n  rep(i,w) y[ys[i]] = 1;\n  vi xc(H), yc(W);\n  rep(i,n) xc[p[i].fi+1]++;\n  rep(i,n) yc[p[i].se+1]++;\n  int cnt = 0;\n  rep(i,H) {\n    cnt += xc[i];\n    if (x[i]) continue;\n    ans += mint((ll)W*i-cnt)*((ll)W*(H-i)-(n-cnt));\n  }\n  cnt = 0;\n  rep(i,W) {\n    cnt += yc[i];\n    if (y[i]) continue;\n    ans += mint((ll)H*i-cnt)*((ll)H*(W-i)-(n-cnt));\n  }\n  cout<<ans<<endl;\n  return 0;\n}\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n"
  },
  {
    "language": "C++",
    "code": "#include<bits/stdc++.h>\nusing namespace std;\nconst long long md=1e9+7;\nconst int maxn=110;\nconst int drx[4]={1,-1,0,0};\nconst int dry[4]={0,0,-1,1};\nint H,W,n;\nstruct node{\n\tint x,y;\n}a[maxn];\nlong long val[maxn][maxn];\nint dis[maxn][maxn];\nlong long ans;\nlong long Sum(long long x){\n\treturn (x*(x+1)/2)%md;\n}\nint Abs(int x){\n\treturn x<0?-x:x;\n}\nint getdis(const node &A,const node &B){\n\treturn Abs(A.x-B.x)+Abs(A.y-B.y);\n}\nvoid get_ans(){\n\tfor(int i=1;i<W;i++)\n\t\tans=(ans+i*(long long)(W-i)%md*H%md*H)%md;\n\tfor(int i=1;i<H;i++)\n\t\tans=(ans+i*(long long)(H-i)%md*W%md*W)%md;\n\tfor(int i=1;i<=n;i++){\n\t\tans=(ans-Sum(H-a[i].x)*W%md+md-Sum(a[i].x-1)*W%md+md)%md;\n\t\tans=(ans-Sum(W-a[i].y)*H%md+md-Sum(a[i].y-1)*H%md+md)%md;\n\t}\n\tans=ans*2;\n\tfor(int i=1;i<=n;i++)\n\t\tfor(int j=1;j<=n;j++)\n\t\t\tans=(ans+getdis(a[i],a[j])+md)%md;\n}\nint bx[maxn],by[maxn];\nint vx[maxn],vy[maxn];\nint mpx[1001000],mpy[1001000];\nint cntx,cnty;\nvoid build_val(){\n\tcntx=0,cnty=0;\n\tint numx,numy;\n\n\tfor(int i=1;i<=n;i++)\n\t\tbx[i]=a[i].x;\n\tsort(bx+1,bx+n+1);\n\tnumx=unique(bx+1,bx+n+1)-(bx+1);\n\tbx[0]=0,bx[numx+1]=H+1;\n\tfor(int i=1;i<=numx+1;i++){\n\t\tif(bx[i]-bx[i-1]>1)\n\t\t\tvx[++cntx]=bx[i]-bx[i-1]-1;\n\t\tvx[++cntx]=1;\n\t\tmpx[bx[i]]=cntx;\n\t}\n\tcntx--;\n\n\tfor(int i=1;i<=n;i++)\n\t\tby[i]=a[i].y;\n\tsort(by+1,by+n+1);\n\tnumy=unique(by+1,by+n+1)-(by+1);\n\tby[0]=0,by[numy+1]=W+1;\n\tfor(int i=1;i<=numy+1;i++){\n\t\tif(by[i]-by[i-1]>1)\n\t\t\tvy[++cnty]=by[i]-by[i-1]-1;\n\t\tvy[++cnty]=1;\n\t\tmpy[by[i]]=cnty;\n\t}\n\tcnty--;\n\n\tfor(int i=1;i<=cntx;i++)\n\t\tfor(int j=1;j<=cnty;j++)\n\t\t\tval[i][j]=vx[i]*(long long)vy[i]%md;\n\tfor(int i=1;i<=n;i++)\n\t\tval[mpx[a[i].x]][mpy[a[i].y]]=-1;\n}\nqueue<node> q;\nbool out(int x,int y){\n\tif(x<1||x>cntx) return 1;\n\tif(y<1||y>cnty) return 1;\n\treturn 0;\n}\nvoid BFS(node st){\n\tfor(int i=1;i<=cntx;i++)\n\t\tfor(int j=1;j<=cnty;j++)\n\t\t\tdis[i][j]=-1;\n\tdis[st.x][st.y]=0;\n\tq.push(st);\n\tint xx,yy;\n\twhile(!q.empty()){\n\t\tst=q.front(),q.pop();\n\t\tfor(int i=0;i<4;i++){\n\t\t\txx=st.x+drx[i],yy=st.y+dry[i];\n\t\t\tif(out(xx,yy)) continue;\n\t\t\tif(val[xx][yy]==-1) continue;\n\t\t\tif(dis[xx][yy]!=-1) continue;\n\t\t\tdis[xx][yy]=dis[st.x][st.y]+1;\n\t\t\tq.push((node){xx,yy});\n\t\t}\n\t}\n}\nvoid updata(int x,int y){\n\tint dd;\n\tfor(int i=1;i<=cntx;i++){\n\t\tfor(int j=1;j<=cnty;j++){\n\t\t\tif(val[i][j]==-1) continue;\n\t\t\tdd=dis[i][j]-(Abs(x-i)+Abs(y-j));\n\t\t\tif(dd==0) continue;\n\t\t\tans=(ans+val[x][y]*val[i][j]%md*dd)%md;\n\t\t}\n\t}\n}\nint main(){\n//\tfreopen(\"I.in\",\"r\",stdin);\n\tscanf(\"%d%d%d\",&H,&W,&n);\n\tfor(int i=1;i<=n;i++){\n\t\tscanf(\"%d%d\",&a[i].x,&a[i].y);\n\t\ta[i].x++,a[i].y++;\n\t}\n\tget_ans();\n\tbuild_val();\n\tfor(int i=1;i<=cntx;i++){\n\t\tfor(int j=1;j<=cnty;j++){\n\t\t\tif(val[i][j]==-1) continue;\n\t\t\tBFS((node){i,j});\n\t\t\tupdata(i,j);\n\t\t}\n\t}\n\tprintf(\"%d %d\\n\",cntx,cnty);\n\tprintf(\"%lld\\n\",(ans*((md+1)/2))%md);\n\treturn 0;\n}\n"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\n#define fi first\n#define se second\n#define pii pair<int,int>\n#define pdi pair<db,int>\n#define mp make_pair\n#define pb push_back\n#define enter putchar('\\n')\n#define space putchar(' ')\n#define eps 1e-8\n#define mo 974711\n#define MAXN 1000005\n//#define ivorysi\nusing namespace std;\ntypedef long long int64;\ntypedef double db;\ntemplate<class T>\nvoid read(T &res) {\n    res = 0;char c = getchar();T f = 1;\n    while(c < '0' || c > '9') {\n\tif(c == '-') f = -1;\n\tc = getchar();\n    }\n    while(c >= '0' && c <= '9') {\n\tres = res * 10 + c - '0';\n\tc = getchar();\n    }\n    res *= f;\n}\ntemplate<class T>\nvoid out(T x) {\n    if(x < 0) {x = -x;putchar('-');}\n    if(x >= 10) {\n\tout(x / 10);\n    }\n    putchar('0' + x % 10);\n}\nconst int MOD = 1000000007;\n\nint H,W,N;\nint x[35],y[35];\nint sum[MAXN],a[MAXN],nxtr[MAXN],nxtc[MAXN];\nint pos[MAXN],ans;\nint g[65][65],r,c,f[65][65];\nbool vis[65][65];\nint dx[] = {0,-1,0,1},dy[] = {1,0,-1,0};\n\nint mul(int a,int b) {\n    return 1LL * a * b % MOD;\n}\nint inc(int a,int b) {\n    return a + b >= MOD ? a + b - MOD : a + b;\n}\nvoid update(int &x,int y) {\n    x = inc(x,y);\n}\nqueue<pii > Q;\nvoid BFS(int x,int y) {\n    memset(vis,0,sizeof(vis));\n    vis[x][y] = 1;f[x][y] = 0;\n    Q.push(mp(x,y));\n    while(!Q.empty()) {\n\tpii t = Q.front();Q.pop();\n\tfor(int k = 0 ; k < 4 ; ++k) {\n\t    int mx = t.fi + dx[k],my = t.se + dy[k];\n\t    if(mx >= 1 && mx <= r && my >= 1 && my <= c) {\n\t\tif(!vis[mx][my] && g[mx][my] != -1) {\n\t\t    f[mx][my] = f[t.fi][t.se] + 1;\n\t\t    Q.push(mp(mx,my));\n\t\t    vis[mx][my] = 1;\n\t\t}\n\t    }\n\t}\n    }\n}\nvoid Solve() {\n    read(H);read(W);\n    read(N);\n    for(int i = 1 ; i <= N ; ++i) {\n\tread(x[i]);read(y[i]);\n\t++x[i];++y[i];\n    }\n    for(int i = 1 ; i <= H ; ++i) a[i] = W;\n    a[H + 1] = 0;\n    for(int i = 1 ; i <= N ; ++i) --a[x[i]];\n    for(int i = 1 ; i <= H ; ++i) {\n\tsum[i] = inc(sum[i - 1],a[i]);\n    }\n    memset(pos,0,sizeof(pos));\n    for(int i = 1 ; i <= H ; ++i) pos[i] = i;\n    for(int i = 1 ; i <= H ; ++i) {\n\tif(a[i] == W && a[i + 1] == W) {\n\t    update(ans,mul(sum[i],inc(sum[H],MOD - sum[i])));\n\t    pos[i + 1] = pos[i];\n\t    nxtr[pos[i]] = i + 2;\n\t}\n\telse nxtr[pos[i]] = i + 1;\n    }\n    for(int i = 1 ; i <= W ; ++i) a[i] = H;\n    a[W + 1] = 0;\n    for(int i = 1 ; i <= N ; ++i) a[y[i]]--;\n    for(int i = 1 ; i <= W ; ++i) sum[i] = inc(sum[i - 1],a[i]);\n    memset(pos,0,sizeof(pos));\n    for(int i = 1 ; i <= W ; ++i) pos[i] = i;\n    for(int i = 1 ; i <= W ; ++i) {\n\tif(a[i] == H && a[i + 1] == H) {\n\t    update(ans,mul(sum[i],inc(sum[W],MOD - sum[i])));\n\t    pos[i + 1] = pos[i];\n\t    nxtc[pos[i]] = i + 2;\n\t}\n\telse nxtc[pos[i]] = i + 1;\n    }\n    int tmp = 1;\n    while(tmp != H + 1) {tmp = nxtr[tmp];++r;}\n    tmp = 1;\n    while(tmp != W + 1) {tmp = nxtc[tmp];++c;}\n    int p1 = 1;\n    for(int i = 1 ; i <= r ; ++i) {\n\tint p2 = 1;\n\tfor(int j = 1 ; j <= c ; ++j) {\n\t    g[i][j] = mul(nxtr[p1] - p1,nxtc[p2] - p2);\n\t    if(nxtr[p1] - p1 == 1 && nxtc[p2] - p2 == 1) {\n\t\tfor(int k = 1 ; k <= N ; ++k) {\n\t\t    if(x[k] == p1 && y[k] == p2) {\n\t\t\tg[i][j] = -1;\n\t\t\tbreak;\n\t\t    }\n\t\t}\n\t    }\n\t    p2 = nxtc[p2];\n\t}\n\tp1 = nxtr[p1];\n    }\n    tmp = 0;\n    for(int i = 1 ; i <= r ; ++i) {\n\tfor(int j = 1 ; j <= c ; ++j) {\n\t    if(g[i][j] != -1) {\n\t\tBFS(i,j);\n\t\tfor(int k = 1 ; k <= r ; ++k) {\n\t\t    for(int h = 1 ; h <= c ; ++h) {\n\t\t\tif(g[k][h] != -1) update(tmp,mul(f[k][h],mul(g[i][j],g[k][h])));\n\t\t    }\n\t\t}\n\t    }\n\t}\n    }\n    tmp = mul(tmp,(MOD + 1) / 2);\n    update(ans,tmp);\n    out(ans);enter;\n}\nint main() {\n#ifdef ivorysi\n    freopen(\"f1.in\",\"r\",stdin);\n#endif\n    Solve();\n}\n"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\nusing namespace std;\n#define int long long\n#define p (int)(1e9 + 7)\n\nint MOD(int a){\n\treturn (a %= p) >= 0 ? a : a + p;\n}\n\nint h, w;\nconst int inv2 = 500000004, inv6 = 166666668;\n\nint calc(int dis, int x1, int dx1, int x2, int dx2, int y1, int dy1, int y2, int dy2){\n//\tprintf(\"calc(%lld, %lld, %lld, %lld, %lld, %lld, %lld, %lld, %lld)\\n\", dis, x1, dx1, x2, dx2, y1, dy1, y2, dy2);\n\tif(x2 < x1){\n\t\treturn calc(dis, x2, dx2, x1, dx1, y2, dy2, y1, dy1);\n\t}\n\telse if(y2 < y1){\n\t\treturn calc(dis + dx2 - dx1, x1, dx2, x2 + dx2 - dx1, dx1, y2, dy2, y1, dy1);\n\t}\n\telse if(x1 == x2){\n\t\treturn calc(dis, y1, dy1, y2, dy2, x1, dx1, x2, dx2);\n\t}\n\tif(y1 == y2){\n\t\tif(dy1 == 1){\n//\t\t\tprintf(\"test1\\n\");\n\t\t\treturn MOD(inv2 * MOD(MOD(dx1 * dx2) * (2 * dis + (dx2 - dx1))));\n\t\t}\n\t\telse{\n//\t\t\tprintf(\"test2\\n\");\n\t\t\treturn MOD(inv6 * MOD(MOD(MOD(dx1 * dx2) * dy1) * (MOD(3 * dy1 * (2 * (x2 - x1) + (dx2 - dx1))) + MOD(2 * (dy1 - 1) * (dy1 + 1)))));\n\t\t}\n\t}\n\telse{\n//\t\tprintf(\"test3\\n\");\n\t\treturn MOD(inv2 * MOD(MOD(MOD(dx1 * dx2) * MOD(dy1 * dy2)) * MOD(2 * dis + (dx2 - dx1) + (dy2 - dy1))));\n\t}\n}\n\nsigned main(){\n\tint H, W, N, i, j, k, l;\n\tscanf(\"%lld%lld\", &H, &W);\n\tscanf(\"%lld\", &N);\n\tvector<int> x_sub(N), y_sub(N), x(0), y(0);\n\tfor(i = 0; i < N; i++){\n\t\tscanf(\"%lld%lld\", &x_sub[i], &y_sub[i]);\n\t\tx.push_back(x_sub[i]);\n\t\tx.push_back(x_sub[i] + 1);\n\t\tx.push_back(max(0ll, x_sub[i] - 1));\n\t\ty.push_back(y_sub[i]);\n\t\ty.push_back(y_sub[i] + 1);\n\t\ty.push_back(max(0ll, y_sub[i] - 1));\n\t}\n\tx.push_back(0);\n\tx.push_back(H);\n\ty.push_back(0);\n\ty.push_back(W);\n\tsort(x.begin(), x.end());\n\tsort(y.begin(), y.end());\n\tfor(i = 1, j = 1; j < x.size(); j++){\n\t\tif(x[j - 1] < x[j]){\n\t\t\tx[i] = x[j];\n\t\t\ti++;\n\t\t}\n\t}\n\th = i - 1;\n\tfor(i = 1, j = 1; j < y.size(); j++){\n\t\tif(y[j - 1] < y[j]){\n\t\t\ty[i] = y[j];\n\t\t\ti++;\n\t\t}\n\t}\n\tw = i - 1;\n\tvector<int> dx(h), dy(w);\n\tfor(i = 0; i < h; i++){\n\t\tdx[i] = x[i + 1] - x[i];\n\t}\n\tfor(i = 0; i < w; i++){\n\t\tdy[i] = y[i + 1] - y[i];\n\t}\n/*\tprintf(\"x:\\n\");\n\tfor(i = 0; i < h; i++){\n\t\tprintf(\"%lld \", x[i]);\n\t}\n\tprintf(\"\\n\");\n\tprintf(\"dx:\\n\");\n\tfor(i = 0; i < h; i++){\n\t\tprintf(\"%lld \", dx[i]);\n\t}\n\tprintf(\"\\n\");\n\tprintf(\"y:\\n\");\n\tfor(j = 0; j < w; j++){\n\t\tprintf(\"%lld \", y[j]);\n\t}\n\tprintf(\"\\n\");\n\tprintf(\"dy:\\n\");\n\tfor(i = 0; i < w; i++){\n\t\tprintf(\"%lld \", dy[i]);\n\t}\n\tprintf(\"\\n\");\n*/\tvector<vector<char>> A(h, vector<char>(w, '.'));\n\tfor(i = 0; i < h; i++){\n\t\tfor(j = 0; j < w; j++){\n\t\t\tfor(k = 0; k < N; k++){\n\t\t\t\tif(x[i] == x_sub[k] && y[j] == y_sub[k]){\n\t\t\t\t\tA[i][j] = '#';\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t}\n/*\tprintf(\"A:\\n\");\n\tfor(i = 0; i < h; i++){\n\t\tfor(j = 0; j < w; j++){\n\t\t\tprintf(\"%c\", A[i][j]);\n\t\t}\n\t\tprintf(\"\\n\");\n\t}\n\tprintf(\"\\n\");\n*/\tvector<vector<int>> dis(h, vector<int>(w, 1000000000));\n\tint ans = 0;\n\tfor(i = 0; i < h; i++){\n\t\tfor(j = 0; j < w; j++){\n\t\t\tif(A[i][j] == '#'){\n\t\t\t\tcontinue;\n\t\t\t}\n//\t\t\tprintf(\"(i, j) = (%lld, %lld)\\n\", i, j);\n\t\t\tint sub = MOD(inv6 * MOD(MOD(dx[i] * dy[j]) * MOD((dx[i] + dy[j]) * MOD(dx[i] * dy[j] - 1))));\n\t\t\tans = MOD(ans + sub);\n\t\t\tint old_dis = dis[i][j];\n\t\t\tfor(k = 0; k < h; k++){\n\t\t\t\tfor(l = 0; l < w; l++){\n\t\t\t\t\tdis[k][l] += old_dis;\n\t\t\t\t}\n\t\t\t}\n\t\t\tqueue<pair<pair<int, int>, int>> q;\n\t\t\tq.push(pair<pair<int, int>, int>(pair<int, int>(i, j), 0));\n\t\t\twhile(q.size() > 0){\n\t\t\t\tk = q.front().first.first;\n\t\t\t\tl = q.front().first.second;\n\t\t\t\tint d = q.front().second;\n\t\t\t\tq.pop();\n\t\t\t\tif(A[k][l] == '#' || dis[k][l] <= d){\n\t\t\t\t\tcontinue;\n\t\t\t\t}\n\t\t\t\tdis[k][l] = d;\n\t\t\t\tif(l < w - 1){\n\t\t\t\t\tq.push(pair<pair<int, int>, int>(pair<int, int>(k + 0, l + 1), d + dy[l]));\n\t\t\t\t}\n\t\t\t\tif(k < h - 1){\n\t\t\t\t\tq.push(pair<pair<int, int>, int>(pair<int, int>(k + 1, l + 0), d + dx[k]));\n\t\t\t\t}\n\t\t\t\tif(l > 0){\n\t\t\t\t\tq.push(pair<pair<int, int>, int>(pair<int, int>(k + 0, l - 1), d + dy[l - 1]));\n\t\t\t\t}\n\t\t\t\tif(k > 0){\n\t\t\t\t\tq.push(pair<pair<int, int>, int>(pair<int, int>(k - 1, l + 0), d + dx[k - 1]));\n\t\t\t\t}\n\t\t\t}\n\t\t\tfor(k = 0; k < h; k++){\n\t\t\t\tfor(l = 0; l < w; l++){\n\t\t\t\t\tif(k < i || (i == k && l <= j) || A[k][l] == '#'){\n\t\t\t\t\t\tcontinue;\n\t\t\t\t\t}\n//\t\t\t\t\tprintf(\"(k, l) = (%lld, %lld)\\n\", k, l);\n\t\t\t\t\tint res = calc(dis[k][l], x[i], dx[i], x[k], dx[k], y[j], dy[j], y[l], dy[l]);\n//\t\t\t\t\tprintf(\"ans += %lld\\n\", res);\n\t\t\t\t\tans = MOD(ans + res);\n\t\t\t\t}\n\t\t\t}\n//\t\t\tprintf(\"\\n\");\n\t\t}\n\t}\n//\tans = MOD(ans * inv2);\n\tprintf(\"%lld\\n\", ans);\n\treturn 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include <iostream>\n#include <vector>\n#include <queue>\n#include <algorithm>\n#include <cstring>\nusing namespace std;\ntypedef long long ll;\nconst int MOD = 1000000007;\nint dx[4] = {1, 0, -1, 0};\nint dy[4] = {0, 1, 0, -1};\n\nint H, W, N;\nint bx[65], by[65];\nvector<int> altx, alty;\nint nH, nW;\nint xnum[1100000], ynum[1100000];\nbool cb[65][65];\nint dist[65][65][65][65];\ntypedef pair<int, int> pint;\n\nlong long subsolve() {\n    long long res = 0;\n    memset(dist, -1, sizeof(dist));\n    for (int x = 0; x < nH; ++x) {\n        for (int y = 0; y < nW; ++y) {\n            if (cb[x][y]) continue;\n            queue<pint> que;\n            que.push(pint(x, y));\n            dist[x][y][x][y] = 0;\n            while (!que.empty()) {\n                pint cur = que.front();\n                que.pop();\n                for (int dir = 0; dir < 4; ++dir) {\n                    int nx = cur.first + dx[dir];\n                    int ny = cur.second + dy[dir];\n                    if (nx < 0 || nx >= nH || ny < 0 || ny >= nW) continue;\n                    if (cb[nx][ny]) continue;\n                    if (dist[x][y][nx][ny] == -1) {\n                        dist[x][y][nx][ny] = dist[x][y][cur.first][cur.second] + 1;\n                        //dist[nx][ny][x][y] = dist[x][y][cur.first][cur.second] + 1;\n                        que.push(pint(nx, ny));\n                    }\n                }\n            }\n            for (int nx = 0; nx < nH; ++nx) {\n                for (int ny = 0; ny < nW; ++ny) {\n                    if (nW * nx + ny <= nW * x + y) continue;\n                    if (dist[x][y][nx][ny] == -1) continue;\n                    if (cb[nx][ny]) continue;\n                    long long ss = ((long long)(altx[x + 1] - altx[x]) * (alty[y + 1] - alty[y])) % MOD;\n                    long long st = ((long long)(altx[nx + 1] - altx[nx]) * (alty[ny + 1] - alty[ny])) % MOD;\n                    res += (dist[x][y][nx][ny] % MOD) * ss % MOD * st % MOD;\n                    res %= MOD;\n                }\n            }\n        }\n    }\n    return res;\n}\nlong long solve() {\n  altx.clear(); alty.clear();\n  altx.push_back(0); altx.push_back(H);\n  alty.push_back(0); alty.push_back(W);\n  for (int i = 0; i < N; ++i) {\n\taltx.push_back(bx[i]);\n\taltx.push_back(bx[i] + 1);\n\talty.push_back(by[i]);\n\talty.push_back(by[i] + 1);\n\txnum[bx[i]]++;\n\tynum[by[i]]++;\n  }\n  sort(altx.begin(), altx.end());\n  sort(alty.begin(), alty.end());\n  altx.erase(unique(altx.begin(), altx.end()), altx.end());\n  alty.erase(unique(alty.begin(), alty.end()), alty.end());\n  nH = (int)altx.size()-1;\n  nW = (int)alty.size()-1;\n  memset(cb, 0, sizeof(cb));\n  for (int i = 0; i < N; ++i) {\n\tint itx = lower_bound(altx.begin(), altx.end(), bx[i]) - altx.begin();\n\tint ity = lower_bound(alty.begin(), alty.end(), by[i]) - alty.begin();\n\tcb[itx][ity] = true;\n  }\n  long long all = (long long)H * W - N;\n  long long add = 0;\n  long long sum = W - xnum[0];\n  for (int i = 1; i < H; ++i) {\n\tif (xnum[i] == 0 && xnum[i-1] == 0) {   // i-1 -> i\n\t  long long up = sum % MOD;\n\t  long long down = (all - sum) % MOD;\n\t  add += (up * down) % MOD;\n\t  add %= MOD;\n\t}\n\tsum += W - xnum[i];\n  }\n  sum = H - ynum[0];\n  for (int i = 1; i < W; ++i) {\n\tif (ynum[i] == 0 && ynum[i-1] == 0) {   // i-1 -> i\n\t  long long left = sum % MOD;\n\t  long long right = (all - sum) % MOD;\n\t  add += (left * right) % MOD;\n\t  add %= MOD;\n\t}\n\tsum += H - ynum[i];\n  }\n  long long comp = subsolve();\n  long long res = (comp + add) % MOD;\n  return res;\n}\nint main() {\n  cin >> H >> W >> N;\n  for (int i = 0; i < N; ++i) cin >> bx[i] >> by[i];\n  cout << solve() << endl;\n}\n"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\n\nusing namespace std;\n\n#define X first\n#define Y second\n#define mp make_pair\n#define pb push_back\n#define Debug(...) fprintf(stderr, __VA_ARGS__)\n\ntypedef long long LL;\ntypedef long double LD;\ntypedef unsigned int uint;\ntypedef pair <int, int> pii;\ntypedef unsigned long long uLL;\n\ntemplate <typename T> inline void Read(T &x) {\n  char c = getchar();\n  bool f = false;\n  for (x = 0; !isdigit(c); c = getchar()) {\n    if (c == '-') {\n      f = true;\n    }\n  }\n  for (; isdigit(c); c = getchar()) {\n    x = x * 10 + c - '0';\n  }\n  if (f) {\n    x = -x;\n  }\n}\n\ntemplate <typename T> inline bool CheckMax(T &a, const T &b) {\n  return a < b ? a = b, true : false;\n}\n\ntemplate <typename T> inline bool CheckMin(T &a, const T &b) {\n  return a > b ? a = b, true : false;\n}\n\nconst int N = 65;\nconst int M = 1000005;\nconst int mod = 1e9 + 7;\nconst int dx[] = {1, -1, 0, 0};\nconst int dy[] = {0, 0, 1, -1};\n\nint n, r, c, ans, x[N], y[N], cnt_x[M], cnt_y[M], idx_x[M], idx_y[M], siz_x[M], siz_y[M], dis[N][N];\nbool vis[N][N];\nqueue <pii> q;\n\ninline void Solve(int *cnt, int *idx, int *siz, int r, int c) {\n  int u = c - cnt[0], d = (1LL * r * c - n - u) % mod;\n  siz[0] = 1;\n  for (int i = 1; i < r; ++i) {\n    idx[i] = idx[i - 1];\n    if (!cnt[i] && !cnt[i - 1]) {\n      ans = (2LL * u * d + ans) % mod;\n    } else {\n      ++idx[i];\n    }\n    ++siz[idx[i]];\n    u = (u + c - cnt[i]) % mod, d = (d + cnt[i] - c + mod) % mod;\n  }\n}\n\ninline int Siz(int x, int y) {\n  return 1LL * siz_x[x] * siz_y[y] % mod;\n}\n\ninline void BFS(int s_x, int s_y) {\n  for (int i = 0; i <= idx_x[r - 1]; ++i) {\n    for (int j = 0; j <= idx_y[c - 1]; ++j) {\n      dis[i][j] = -1;\n    }\n  }\n  dis[s_x][s_y] = 0, q.push(mp(s_x, s_y));\n  while (!q.empty()) {\n    int x = q.front().X, y = q.front().Y;\n    q.pop(), ans = (1LL * Siz(x, y) * Siz(s_x, s_y) % mod * dis[x][y] + ans) % mod;\n    for (int i = 0; i < 4; ++i) {\n      int u = x + dx[i], v = y + dy[i];\n      if (u >= 0 && u <= idx_x[r - 1] && v >= 0 && v <= idx_y[c - 1] && !vis[u][v] && !~dis[u][v]) {\n        dis[u][v] = dis[x][y] + 1, q.push(mp(u, v));\n      }\n    }\n  }\n}\n\nint main() {\n#ifdef wxh010910\n  freopen(\"d.in\", \"r\", stdin);\n#endif\n  Read(r), Read(c), Read(n);\n  for (int i = 0; i < n; ++i) {\n    Read(x[i]), Read(y[i]);\n    ++cnt_x[x[i]], ++cnt_y[y[i]];\n  }\n  Solve(cnt_x, idx_x, siz_x, r, c);\n  Solve(cnt_y, idx_y, siz_y, c, r);\n  for (int i = 0; i < n; ++i) {\n    vis[idx_x[x[i]]][idx_y[y[i]]] = true;\n  }\n  for (int i = 0; i <= idx_x[r - 1]; ++i) {\n    for (int j = 0; j <= idx_y[c - 1]; ++j) {\n      if (!vis[i][j]) {\n        BFS(i, j);\n      }\n    }\n  }\n  printf(\"%d\\n\", 1LL * ans * (mod + 1) / 2 % mod);\n#ifdef wxh010910\n  Debug(\"My Time: %.3lfms\\n\", (double)clock() / CLOCKS_PER_SEC);\n#endif\n  return 0;\n}\n"
  },
  {
    "language": "C++",
    "code": "#include<bits/stdc++.h>\n\n#pragma GCC optimize(\"no-stack-protector\")\n#pragma GCC optimize(\"-funroll-loops\")\n#pragma GCC target(\"avx,sse4\")\n\n#define mms(a,n) memset(a,0,sizeof((a)[0])*(n))\n#define mmp(a,b,n) memcpy(a,b,sizeof((b)[0])*(n))\n#define lowbit(x) ((x)&-(x))\n#define pb push_back\n#define fi first\n#define se second\n#define debug(...) fprintf(stderr,__VA_ARGS__)\n#define fo(i,l,r) for(register int i=l,_lim_=r;i<=_lim_;i++)\n#define fd(i,r,l) for(register int i=r,_lim_=l;i>=_lim_;i--)\n#define fos(i,l,r,d) for(register int i=l,_lim_=r;i<=r;i+=d)\n#define fol(i,l,r) for(register ll i=l,_lim_=r;i<=_lim_;i++)\n#define fdl(i,r,l) for(register ll i=r,_lim_=l;i>=_lim_;i--)\n#define fosl(i,l,r,d) for(register ll i=l,_lim_=r;i<=r;i+=d)\n#define Clear(a) memset(a,0,sizeof(a))\n#define Copy(a,b) memcpy(a,b,sizeof(b))\n#define ALL(v) v.begin(),v.end()\n#define SZ(v) ((int)v.size())\n\nusing namespace std;\ntypedef unsigned long long ull;\ntypedef long long ll;\ntypedef long double ldb;\ntypedef double db;\ntypedef pair<int,int> pi;\ntemplate<class T>inline void vnique(vector<T> &r){sort(ALL(r));auto t=unique(ALL(r));r.erase(t,r.end());}\n\nconst int N=65,M=1000005,P=1e9+7,dx[]={-1,1,0,0},dy[]={0,0,-1,1};\n\nint n,m,K,a,x[N],y[N],lx,ly,cnt[N][N],s1[M],s2[M],dis[N][N],ql,qr;\nbool fb[N][N],mark1[M],mark2[M];\nvector<int>px,py;\npi qu[N*N];\n\nvoid bfs(int x,int y){\n\tfo(i,0,lx)fo(j,0,ly)dis[i][j]=N<<1;\n\tdis[x][y]=0;qu[ql=qr=1]={x,y};\n\twhile(ql<=qr){\n\t\tint u=qu[ql].fi,v=qu[ql].se;ql++;\n\t\tfo(i,0,3){\n\t\t\tint tu=u+dx[i],tv=v+dy[i];\n\t\t\tif(tu>lx||tv>ly||tu<0||tv<0||dis[tu][tv]<=dis[u][v]+1||fb[tu][tv])continue;\n\t\t\tdis[tu][tv]=dis[u][v]+1;qu[++qr]={tu,tv};\n\t\t}\n\t}\n}\n\nint main(){\n\tscanf(\"%d%d%d\",&n,&m,&K);\n\tpx.pb(1);px.pb(n+1);py.pb(1);py.pb(m+1); \n\tfo(i,1,n)s1[i]=m;fo(i,1,m)s2[i]=n;\n\tfo(i,1,K){\n\t\tscanf(\"%d%d\",&x[i],&y[i]);\n\t\tx[i]++,px.pb(x[i]),px.pb(x[i]+1);\n\t\ty[i]++,py.pb(y[i]),py.pb(y[i]+1);\n\t\ts1[x[i]]--;mark1[x[i]]=true;\n\t\ts2[y[i]]--;mark2[y[i]]=true;\n\t}\n\tfo(i,1,n)(s1[i]+=s1[i-1])%=P;fo(i,1,m)(s2[i]+=s2[i-1])%=P;\n\tfo(i,1,n-1)if(!mark1[i]&&!mark1[i+1])a=(a+(ll)2*s1[i]*(s1[n]-s1[i]))%P;\n\tfo(i,1,m-1)if(!mark2[i]&&!mark2[i+1])a=(a+(ll)2*s2[i]*(s2[m]-s2[i]))%P;\n\tvnique(px);vnique(py);lx=SZ(px)-2;ly=SZ(py)-2;\n\tfo(i,1,K)fb[lower_bound(ALL(px),x[i])-px.begin()][lower_bound(ALL(py),y[i])-py.begin()]=true;\n\tfo(i,0,lx)fo(j,0,ly)cnt[i][j]=(ll)(px[i+1]-px[i])*(py[j+1]-py[j])%P;\n\tfo(i,0,lx)fo(j,0,ly)if(!fb[i][j]){\n\t\tbfs(i,j);\n\t\tfo(k,0,lx)fo(t,0,ly)if(!fb[k][t])a=(a+(ll)cnt[i][j]*dis[k][t]%P*cnt[k][t])%P;\n\t}\n\tif(a<0)a+=P;a=(ll)a*(P/2+1)%P;\n\tprintf(\"%d\\n\",a);\n\treturn 0;\n}"
  },
  {
    "language": "C++",
    "code": "\n#include<bits/stdc++.h>\n#define int long long\nusing namespace std;\n#define DB(x){if(DEBUG)cerr<<__LINE__<<\" \"<<#x<<\" \" <<x<<endl;}\n#define REP(i,b)for(LL i=(0);i<(b);++i)\n#define FOR(i,a,b)for(LL i=(a);i<=(b);++i)\n#define FORD(i,a,b)for(LL i=(a);i>=(b);--i)\n#define ALL(x) (x).begin(),(x).end()\n#define VV vector\ntemplate<typename X,typename Y>void MAX(X&a,Y b){a=(a>=b?a:b);}\ntemplate<typename X,typename Y>void MIN(X&a,Y b){a=(a<=b?a:b);}\ntypedef long long LL;typedef long double LD;\nint DEBUG=0,MULTI=0,GCJ=0;\n\nstruct solver_t;solver_t *solver;\nconst int MOD = 1e9 + 7;\nstruct solver_t {\n  int ROWS = -1, COLS = -1;\n  int IS_BLACK[70][70] = {};\n  LL HEI[70][70] = {};\n  LL WID[70][70] = {};\n\n  LL calculate(LL source_r, LL source_c) {\n    struct pkt_t { LL R = -1, C = -1; LL dst = -1;\n      bool operator < (const pkt_t rhs) const {\n        return dst < rhs.dst;\n      }\n    };\n    DB(source_r<<\" \"<<source_c);\n\n    LL DST[70][70];\n    memset(DST, 0x7f, sizeof(DST));\n\n    multiset <pkt_t> KOL;\n    DST[source_r][source_c] = 0;\n    KOL.insert({source_r, source_c, 0});\n    while (KOL.size() > 0) {\n      auto front = KOL.begin();\n      auto top = *front;\n      KOL.erase(front);\n      if (DST[top.R][top.C] != top.dst) continue;\n\n      FOR (dr, -1, 1) FOR (dc, -1, 1) if (abs(dr) + abs(dc) == 1) {\n        if (dr) {\n          int next_r = top.R + dr;\n          int next_c = top.C;\n          if (!(next_r >=0 && next_r < ROWS)) continue;\n          if (IS_BLACK[next_r][next_c]) continue;\n\n          LL diff_dst;\n          if (next_r == source_r || top.R == source_r) diff_dst = 1;\n          else diff_dst = HEI[top.R][top.C];\n\n          if (DST[next_r][next_c] > diff_dst + top.dst) {\n            DST[next_r][next_c] = diff_dst + top.dst;\n            KOL.insert( { next_r, next_c, DST[next_r][next_c]} );\n          }\n        }\n        if (dc) {\n\n          int next_r = top.R;\n          int next_c = top.C + dc;\n          if (!(next_c >= 0 && next_c < COLS)) continue;\n          if (IS_BLACK[next_r][next_c]) continue;\n\n          int diff_dst;\n          if (next_c == source_c || top.C == source_c) diff_dst = 1;\n          else diff_dst = WID[top.R][top.C];\n\n          if (DST[next_r][next_c] > diff_dst + top.dst) {\n            DST[next_r][next_c] = diff_dst + top.dst;\n            KOL.insert( { next_r, next_c, DST[next_r][next_c]} );\n          }\n        }\n      }\n    }\n\n\n\n    auto power=[](LL a, LL b) {\n      LL res = 1;\n      while (b) {\n        if (b&1) res=(res*a)%MOD;\n        b/=2; a=(a*a)%MOD;\n      }\n      return res;\n    };\n    LL rev3 = power(3, MOD - 2);\n    LL res = 0;\n    REP (r, ROWS) REP (c, COLS) if (IS_BLACK[r][c] == 0) {\n      DB(source_r<<\" \"<<source_c<<\" \"<<r<<\" \"<<c<<\" \"<<DST[r][c]);\n      pair<int,int> V1(source_r, source_c);\n      pair<int,int> V2(r, c);\n      //if (!(V1 <= V2)) continue;\n\n      res += DST[r][c] % MOD * HEI[r][c] % MOD * WID[r][c] % MOD *\n             HEI[source_r][source_c] % MOD * WID[source_r][source_c] % MOD;\n\n      auto oblicz=[&](LL wid) {\n        LL N = wid + 1;\n        if (N < 3) return 0LL;\n        LL res = ((N * (N-1) % MOD) *(N-2)) % MOD;\n        res = (res * rev3) % MOD;\n\n        return res;\n      };\n      DB(oblicz(0));\n      DB(oblicz(1));\n      DB(oblicz(2));\n      DB(oblicz(3));\n      DB(oblicz(4));\n      DB(oblicz(5));\n      DB(oblicz(10));\n\n      auto oblicz2=[](LL wid1,LL wid2) {\n        LL p1 = (wid1 - 1) * wid1 / 2 % MOD * wid2;\n        LL p2 = (wid2 - 1) * wid2 / 2 % MOD * wid1;\n        return p1 + p2;\n      };\n\n      LL v1 = 0;\n      if (source_r == r) {\n        int hei = HEI[r][c];\n        assert(HEI[r][c] == HEI[source_r][source_c]);\n\n        LL tmp = oblicz(hei) % MOD;\n        tmp = (tmp * WID[r][c] % MOD * WID[source_r][source_c]) % MOD;\n\n        res += tmp;\n      }\n      else {\n        LL tmp = oblicz2(HEI[r][c], HEI[source_r][source_c]) % MOD;\n        tmp = (tmp * WID[r][c] % MOD * WID[source_r][source_c]) % MOD;\n        res += tmp;\n      }\n      if (source_c == c) {\n        int wid = WID[r][c];\n        assert(WID[r][c] == WID[source_r][source_c]);\n        LL tmp = oblicz(wid) % MOD;\n        tmp = (tmp * HEI[r][c] % MOD * HEI[source_r][source_c]) % MOD;\n\n        res += tmp;\n      }\n      else {\n        LL tmp = oblicz2(WID[r][c], WID[source_r][source_c]) % MOD;\n\n        tmp = (tmp * HEI[r][c] % MOD * HEI[source_r][source_c]) % MOD;\n        res += tmp;\n      }\n      res %= MOD;\n    }\n\n    return res;\n  }\n\n\n  void solve() {\n    int H, W;cin >>H>>W;\n    int N; cin >> N;\n\n    VV<int> CORD_R;\n    VV<int> CORD_C;\n\n    VV<array<int,2> > BLACK;\n    REP (i, N) {\n      int r, c;\n      cin >> r >> c;\n      BLACK.push_back({r,c});\n      CORD_R.push_back(r);\n      CORD_R.push_back(r + 1);\n\n      CORD_C.push_back(c);\n      CORD_C.push_back(c + 1);\n    }\n    CORD_R.push_back(0);\n    CORD_R.push_back(H);\n\n    CORD_C.push_back(0);\n    CORD_C.push_back(W);\n\n    sort( ALL(CORD_R) ); CORD_R.erase(unique(ALL(CORD_R)), CORD_R.end());\n    sort( ALL(CORD_C) ); CORD_C.erase(unique(ALL(CORD_C)), CORD_C.end());\n\n    for (int cr : CORD_R) DB(cr);\n    for (int cc : CORD_C) DB(cc);\n\n\n    ROWS = CORD_R.size() - 1;\n    COLS = CORD_C.size() - 1;\n\n    for (auto black : BLACK) {\n      int r = lower_bound(ALL(CORD_R), black[0]) - CORD_R.begin();\n      int c = lower_bound(ALL(CORD_C), black[1]) - CORD_C.begin();\n      IS_BLACK[r][c] = 1;\n    }\n    REP (r, ROWS) REP (c, COLS) {\n      HEI[r][c] = CORD_R[r + 1] - CORD_R[r];\n      WID[r][c] = CORD_C[c + 1] - CORD_C[c];\n    }\n\n\n    LL res = 0;\n    auto power=[](LL a, LL b) {\n      LL res = 1;\n      while (b) {\n        if (b&1) res=(res*a)%MOD;\n        b/=2; a=(a*a)%MOD;\n      }\n      return res;\n    };\n    LL rev2 = power(2, MOD - 2);\n    REP (r, ROWS) REP (c, COLS) if (IS_BLACK[r][c] == 0) {\n      res += calculate(r, c);\n      res %= MOD;\n    }\n    cout << (res * rev2) % MOD << \"\\n\";\n  }\n\n\n  void gen() {}\n  void brute() {}\n};\n\n#undef int\nint main(int argc,char** argv){\n  FOR(i,1,argc-1)for(int j=0;argv[i][j];j++)if(argv[i][j]=='.')freopen(argv[i],\"r\",stdin);\n  FOR(i,1,argc-1)if(argv[i]==string(\"q\"))DEBUG=1<<30;\n  FOR(i,1,argc-1)if(argv[i]==string(\"gen\")){(solver=new solver_t())->gen();exit(0);}\n  FOR(i,1,argc-1)if(argv[i]==string(\"brute\")){(solver=new solver_t())->brute();exit(0);}\n  ios::sync_with_stdio(false),cin.tie(0);\n  cout.setf(ios::fixed),cout.precision(10);int t;if(MULTI||GCJ)cin>>t;else t=1;\n  FOR(i,1,t){if(DEBUG)cerr<<__LINE__<<\" \"<<i<<endl;if(GCJ)cout<<\"Case #\"<<i<<\": \";\n    solver = new solver_t();\n    solver->solve();\n  }return 0;\n}\n\n"
  },
  {
    "language": "C++",
    "code": "#include<bits/stdc++.h>\nusing namespace std;\nconst long long md=1e9+7;\nconst int maxn=110;\nconst int drx[4]={1,-1,0,0};\nconst int dry[4]={0,0,-1,1};\nint H,W,n;\nstruct node{\n\tint x,y;\n}a[maxn];\nlong long val[maxn][maxn];\nint dis[maxn][maxn];\nlong long ans;\nlong long Sum(long long x){\n\treturn (x*(x+1)/2)%md;\n}\nint Abs(int x){\n\treturn x<0?-x:x;\n}\nint getdis(const node &A,const node &B){\n\treturn Abs(A.x-B.x)+Abs(A.y-B.y);\n}\nvoid get_ans(){\n\tfor(int i=1;i<W;i++)\n\t\tans=(ans+i*(long long)(W-i)%md*H%md*H)%md;\n\tfor(int i=1;i<H;i++)\n\t\tans=(ans+i*(long long)(H-i)%md*W%md*W)%md;\n\tfor(int i=1;i<=n;i++){\n\t\tans=(ans-Sum(H-a[i].x)*W%md+md-Sum(a[i].x-1)*W%md+md)%md;\n\t\tans=(ans-Sum(W-a[i].y)*H%md+md-Sum(a[i].y-1)*H%md+md)%md;\n\t}\n\tans=ans*2%md;\n\tfor(int i=1;i<=n;i++)\n\t\tfor(int j=1;j<=n;j++)\n\t\t\tans=(ans+getdis(a[i],a[j]))%md;\n}\nint bx[maxn],by[maxn];\nint vx[maxn],vy[maxn];\nint mpx[1001000],mpy[1001000];\nint cntx,cnty;\nvoid build_val(){\n\tcntx=0,cnty=0;\n\tint numx,numy;\n\n\tfor(int i=1;i<=n;i++)\n\t\tbx[i]=a[i].x;\n\tsort(bx+1,bx+n+1);\n\tnumx=unique(bx+1,bx+n+1)-(bx+1);\n\tbx[0]=0,bx[numx+1]=H+1;\n\tfor(int i=1;i<=numx+1;i++){\n\t\tif(bx[i]-bx[i-1]>1)\n\t\t\tvx[++cntx]=bx[i]-bx[i-1]-1;\n\t\tvx[++cntx]=1;\n\t\tmpx[bx[i]]=cntx;\n\t}\n\tcntx--;\n\n\tfor(int i=1;i<=n;i++)\n\t\tby[i]=a[i].y;\n\tsort(by+1,by+n+1);\n\tnumy=unique(by+1,by+n+1)-(by+1);\n\tby[0]=0,by[numy+1]=W+1;\n\tfor(int i=1;i<=numy+1;i++){\n\t\tif(by[i]-by[i-1]>1)\n\t\t\tvy[++cnty]=by[i]-by[i-1]-1;\n\t\tvy[++cnty]=1;\n\t\tmpy[by[i]]=cnty;\n\t}\n\tcnty--;\n\n\tfor(int i=1;i<=cntx;i++)\n\t\tfor(int j=1;j<=cnty;j++)\n\t\t\tval[i][j]=vx[i]*(long long)vy[j]%md;\n\tfor(int i=1;i<=n;i++)\n\t\tval[mpx[a[i].x]][mpy[a[i].y]]=-1;\n}\nqueue<node> q;\nbool out(int x,int y){\n\tif(x<1||x>cntx) return 1;\n\tif(y<1||y>cnty) return 1;\n\treturn 0;\n}\nvoid BFS(node st){\n\tfor(int i=1;i<=cntx;i++)\n\t\tfor(int j=1;j<=cnty;j++)\n\t\t\tdis[i][j]=-1;\n\tdis[st.x][st.y]=0;\n\tq.push(st);\n\tint xx,yy;\n\twhile(!q.empty()){\n\t\tst=q.front(),q.pop();\n\t\tfor(int i=0;i<4;i++){\n\t\t\txx=st.x+drx[i],yy=st.y+dry[i];\n\t\t\tif(out(xx,yy)) continue;\n\t\t\tif(val[xx][yy]==-1) continue;\n\t\t\tif(dis[xx][yy]!=-1) continue;\n\t\t\tdis[xx][yy]=dis[st.x][st.y]+1;\n\t\t\tq.push((node){xx,yy});\n\t\t}\n\t}\n}\nvoid updata(int x,int y){\n\tint dd;\n\tfor(int i=1;i<=cntx;i++){\n\t\tfor(int j=1;j<=cnty;j++){\n\t\t\tif(val[i][j]==-1) continue;\n\t\t\tdd=dis[i][j]-(Abs(x-i)+Abs(y-j));\n\t\t\tif(dd==0) continue;\n\t\t\tans=(ans+val[x][y]*val[i][j]%md*dd)%md;\n\t\t}\n\t}\n}\nint main(){\n//\tfreopen(\"I.in\",\"r\",stdin);\n\tscanf(\"%d%d%d\",&H,&W,&n);\n\tfor(int i=1;i<=n;i++){\n\t\tscanf(\"%d%d\",&a[i].x,&a[i].y);\n\t\ta[i].x++,a[i].y++;\n\t}\n\tget_ans();\n\tbuild_val();\n\tfor(int i=1;i<=cntx;i++){\n\t\tfor(int j=1;j<=cnty;j++){\n\t\t\tif(val[i][j]==-1) continue;\n\t\t\tBFS((node){i,j});\n\t\t\tupdata(i,j);\n\t\t}\n\t}\n\tprintf(\"%lld\\n\",(ans*((md+1)/2))%md);\n\treturn 0;\n}\n"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\nusing namespace std;\ntypedef long long lint;\ntypedef pair<int, int> pi;\nconst int MAXN = 100005;\nconst int mod = 1e9 + 7;\nconst lint inv2 = (mod + 1) / 2;\n\nstruct rt{\n\tint sx, ex, sy, ey;\n\tint ssi, sei, esi, eei;\n\tint type;\n\tbool operator<(const rt &r)const{\n\t\treturn type < r.type;\n\t}\n};\n\nlint sum(int x){\n\treturn ( 1ll * x * (x+1) / 2 ) % mod;\n}\n\nvector<rt> rect;\nvector<pi> pnt;\nvector<pi> gph[9000];\nint dist1[9000], dist2[9000];\n\nvoid dijkstra(int p, int *d){\n\tpriority_queue<pi, vector<pi>, greater<pi> > pq;\n\tpq.push(pi(0, p));\n\td[p] = 0;\n\twhile(!pq.empty()){\n\t\tauto x = pq.top();\n\t\tpq.pop();\n\t\tif(d[x.second] != x.first) continue;\n\t\tfor(auto &i : gph[x.second]){\n\t\t\tif(d[i.second] > x.first + i.first){\n\t\t\t\td[i.second] = x.first + i.first;\n\t\t\t\tpq.push(pi(d[i.second], i.second));\n\t\t\t}\n\t\t}\n\t}\n}\n\nlint sum2(int x){\n\tlint k = x * (1ll * (x + 1) * (2 * x + 1) % mod) % mod;\n\tk *= (mod + 1) / 6;\n\tk %= mod;\n\treturn k;\n}\n\nlint twostrip(int sx, int ex, int sy, int ey){\n\tif(sx == sy && ex == ey){\n\t\tint dx = ex - sx;\n\t\tlint ans = (dx + 1) * sum(dx) % mod;\n\t\tans += mod - sum2(dx);\n\t\tans <<= 1;\n\t\treturn ans % mod;\n\t}\n\telse{\n\t\tif(ex < sy){\n\t\t\tlint ans = 0;\n\t\t\tans += sum(ex - sx) * (ey - sy + 1);\n\t\t\tans += sum(ey - sy) * (ex - sx + 1);\n\t\t\tans += (sy - ex) * (ey - sy + 1) * (ex - sx + 1);\n\t\t\tans %= mod;\n\t\t\treturn ans;\n\t\t}\n\t\telse return twostrip(sy, ey, sx, ex);\n\t}\n}\n\nvoid debug(rt r){\n\treturn;\n\tprintf(\"%d %d %d %d %d\\n\", r.sx, r.ex, r.sy, r.ey, r.type);\n}\nlint getMyself(int x, int y){\n\tlint ans = 0;\n\tans += twostrip(1, x, 1, x) * (1ll * y * y % mod) % mod;\n\tans += twostrip(1, y, 1, y) * (1ll * x * x % mod) % mod;\n\tans %= mod;\n\tans *= inv2;\n\tans %= mod;\n\treturn ans;\n}\n\nlint get33(rt a, rt b){\n\tlint ans = 0;\n\tans += twostrip(a.sx, a.ex, b.sx, b.ex) * (1ll * (a.ey - a.sy + 1) * (b.ey - b.sy + 1) % mod) % mod;\n\tans += twostrip(a.sy, a.ey, b.sy, b.ey) * (1ll * (a.ex - a.sx + 1) * (b.ex - b.sx + 1) % mod) % mod;\n\treturn ans % mod;\n}\n\nlint get12(int l, int r, int n){\n\tlint ans = 0;\n\tif(l + n <= r) return (sum(l + n) - sum(l - 1) + mod) % mod;\n\tif(r + n <= l) return (sum(r + n) - sum(r - 1) + mod) % mod;\n\tif(l > r) swap(l, r);\n\tint m = (r + n - l) / 2;\n\tans += sum(l + m) - sum(l - 1);\n\tans += sum(r + (n - m) - 1) - sum(r - 1);\n\tans %= mod;\n\tans += mod;\n\tans %= mod;\n\tans %= mod;\n\treturn ans;\n}\n\nlint get13(int k, int n, int m){\n\tlint ans = 1ll * k * (n+1) * (m+1) % mod;\n\tans += sum(n) * (m + 1);\n\tans += sum(m) * (n + 1);\n\treturn ans % mod;\n}\n\nlint solve(){\n\tlint ans = 0;\n\tfor(int i=0; i<rect.size(); i++){\n\t\tans += getMyself(rect[i].ex - rect[i].sx + 1, rect[i].ey - rect[i].sy + 1);\n\t\tif(rect[i].type != 3){\n\t\t\t// Dijkstra SHOULD BE VERY FAST!\n\t\t\tmemset(dist1, 0x3f, sizeof(dist1));\n\t\t\tdijkstra(rect[i].ssi, dist1);\n\t\t\tif(rect[i].eei != rect[i].ssi){\n\t\t\t\tmemset(dist2, 0x3f, sizeof(dist2));\n\t\t\t\tdijkstra(rect[i].eei, dist2);\n\t\t\t}\n\t\t}\n\t\tfor(int j=i+1; j<rect.size(); j++){\n\t\t\tif(rect[i].type == 1 && rect[j].type == 1){\n\t\t\t\t// Easy, just use result from dijkstra\n\t\t\t\tans += dist1[rect[j].ssi]; \n\t\t\t}\n\t\t\tif(rect[i].type == 1 && rect[j].type == 2){\n\t\t\t\t// Try two sinks, and brute force from there.\n\t\t\t\tint p1 = dist1[rect[j].ssi];\n\t\t\t\tint p2 = dist1[rect[j].eei];\n\t\t\t\tans += get12(p1, p2, max(rect[j].ex - rect[j].sx, rect[j].ey - rect[j].sy));\n\t\t\t}\n\t\t\tif(rect[i].type == 1 && rect[j].type == 3){\n\t\t\t\t// Observation : It's always advantageous to go to fastest corner.\n\t\t\t\tint fastest = \n\t\t\t\t\tmin({dist1[rect[j].ssi], dist1[rect[j].sei], dist1[rect[j].esi], dist1[rect[j].eei]});\n\t\t\t\t// Fastest corners are detected, and we can calculate with math formula.\n\t\t\t\tans += get13(fastest, rect[j].ex - rect[j].sx, rect[j].ey - rect[j].sy);\n\t\t\t}\n\t\t\tif(rect[i].type == 2 && rect[j].type == 2){\n\t\t\t\tdebug(rect[i]);\n\t\t\t\tdebug(rect[j]);\n\t\t\t\tcout << ans << endl;\n\t\t\t\tif(rect[i].sx < rect[i].ex && rect[j].sx < rect[j].ex && rect[i].sx == rect[j].sx){\n\t\t\t\t\t// X-intervals coincide\n\t\t\t\t\tans += get33(rect[i], rect[j]);\n\t\t\t\t}\n\t\t\t\telse if(rect[i].sy < rect[i].ey && rect[j].sy < rect[j].ey && rect[i].sy == rect[j].sy){\n\t\t\t\t\t// Y-intervals coincide\n\t\t\t\t\tans += get33(rect[i], rect[j]);\n\t\t\t\t}\n\t\t\t\telse{\n\t\t\t\t\t// Now we can assure that intervals ONLY coincide when they are points.\n\t\t\t\t\t//\n\t\t\t\t\tint fastest = min(dist1[rect[j].ssi], dist1[rect[j].eei]);\n\t\t\t\t\tif(rect[i].ssi != rect[i].eei){\n\t\t\t\t\t\tfastest = min({fastest, dist2[rect[j].ssi], dist2[rect[j].eei]});\n\t\t\t\t\t}\n\t\t\t\t\tans += get13(fastest, \n\t\t\t\t\t\t\trect[i].ex - rect[i].sx + rect[i].ey - rect[i].sy,\n\t\t\t\t\t\t\trect[j].ex - rect[j].sx + rect[j].ey - rect[j].sy);\n\t\t\t\t}\n\t\t\t}\n\t\t\tif(rect[i].type == 2 && rect[j].type == 3){\n\t\t\t\t// This is analogous with 3-3 case.\n\t\t\t\tans += get33(rect[i], rect[j]);\n\t\t\t}\n\t\t\tif(rect[i].type == 3 && rect[j].type == 3){\n\t\t\t\t// Obstacles are not important in here.\n\t\t\t\tans += get33(rect[i], rect[j]);\n\t\t\t}\n\t\t}\n\t}\n\tans %= mod;\n\treturn ans;\n}\n\nint h, w, n, x[31], y[31];\nvector<int> vx, vy;\n\nint getsum(pi a, pi b){\n\tfor(int i=0; i<n; i++){\n\t\tif(a.first <= x[i] && x[i] <= b.first && a.second <= y[i] && y[i] <= b.second){\n\t\t\treturn 1;\n\t\t}\n\t}\n\treturn 0;\n}\n\nvoid make_edge(vector<pi> v){\n\tfor(int i=1; i<v.size(); i++){\n\t\tif(v[i-1].first == v[i].first || v[i-1].second == v[i].second){\n\t\t\tint p1 = lower_bound(pnt.begin(), pnt.end(), v[i-1]) - pnt.begin();\n\t\t\tint p2 = lower_bound(pnt.begin(), pnt.end(), v[i]) - pnt.begin();\n\t\t\tint dx = abs(v[i].first - v[i-1].first) + abs(v[i].second - v[i-1].second);\n\t\t\tif(getsum(v[i-1], v[i]) == 0){\n\t\t\t\tgph[p1].push_back(pi(dx, p2));\n\t\t\t\tgph[p2].push_back(pi(dx, p1));\n\t\t\t}\n\t\t}\n\t}\n}\n\nint main(){\n\tcin >> h >> w >> n;\n\tfor(int i=0; i<n; i++){\n\t\tcin >> x[i] >> y[i];\n\t\tx[i]++;\n\t\ty[i]++;\n\t\tvx.push_back(x[i]);\n\t\tvy.push_back(y[i]);\n\t}\n\tvx.push_back(0); vx.push_back(h+1);\n\tvy.push_back(0); vy.push_back(w+1);\n\tsort(vx.begin(), vx.end());\n\tsort(vy.begin(), vy.end());\n\tvx.resize(unique(vx.begin(), vx.end()) - vx.begin());\n\tvy.resize(unique(vy.begin(), vy.end()) - vy.begin());\n\tvector<pi> ix, iy;\n\tfor(int i=0; i+1<vx.size(); i++){\n\t\tif(i != 0) ix.push_back(pi(vx[i], vx[i]));\n\t\tif(vx[i] + 1 < vx[i+1]) ix.push_back(pi(vx[i] + 1, vx[i+1] - 1));\n\t}\n\tfor(int i=0; i+1<vy.size(); i++){\n\t\tif(i != 0) iy.push_back(pi(vy[i], vy[i]));\n\t\tif(vy[i] + 1 < vy[i+1]) iy.push_back(pi(vy[i] + 1, vy[i+1] - 1));\n\t}\n\tfor(auto &i : ix){\n\t\tfor(auto &j : iy){\n\t\t\t// Build rectangles from parsed intervals\n\t\t\tint type = 1;\n\t\t\tif(i.first != i.second || *lower_bound(vx.begin(), vx.end(), i.first) != i.first){\n\t\t\t\t// X coordinates are not bounded\n\t\t\t\ttype++;\n\t\t\t}\n\t\t\tif(j.first != j.second || *lower_bound(vy.begin(), vy.end(), j.first) != j.first){\n\t\t\t\t// Y coordinates are not bounded\n\t\t\t\ttype++;\n\t\t\t}\n\t\t\tfor(int k=0; k<n; k++){\n\t\t\t\tif(type == 1 && x[k] == i.first && y[k] == j.first){\n\t\t\t\t\t// Both coordinates are bounded, and it coincides with black point\n\t\t\t\t\ttype--;\n\t\t\t\t}\n\t\t\t}\n\t\t\tif(type == 0) continue;\n\t\t\t// Good\n\t\t\trect.push_back({i.first, i.second, j.first, j.second, -1, -1, -1, -1, type});\n\t\t}\n\t}\n\tsort(rect.begin(), rect.end());\n\tfor(auto &i : rect){\n\t\tpnt.push_back(pi(i.sx, i.sy));\n\t\tpnt.push_back(pi(i.sx, i.ey));\n\t\tpnt.push_back(pi(i.ex, i.sy));\n\t\tpnt.push_back(pi(i.ex, i.ey));\n\t}\n\tsort(pnt.begin(), pnt.end());\n\tpnt.resize(unique(pnt.begin(), pnt.end()) - pnt.begin());\n\tvector<pi> w = pnt;\n\tmake_edge(w);\n\tsort(w.begin(), w.end(), [&](const pi &a, const pi &b){\n\t\treturn pi(a.second, a.first) < pi(b.second, b.first);\n\t});\n\tmake_edge(w);\n\tfor(auto &i : rect){\n\t\ti.ssi = lower_bound(pnt.begin(), pnt.end(), pi(i.sx, i.sy)) - pnt.begin();\n\t\ti.sei = lower_bound(pnt.begin(), pnt.end(), pi(i.sx, i.ey)) - pnt.begin();\n\t\ti.esi = lower_bound(pnt.begin(), pnt.end(), pi(i.ex, i.sy)) - pnt.begin();\n\t\ti.eei = lower_bound(pnt.begin(), pnt.end(), pi(i.ex, i.ey)) - pnt.begin();\n\t}\n\tcout << solve();\n}\n"
  },
  {
    "language": "Java",
    "code": "import java.io.*;\nimport java.util.*;\n\npublic class Main {\n\n\tvoid submit() {\n\t\tint r = nextInt();\n\t\tint c = nextInt();\n\t\tint n = nextInt();\n\n\t\tint[] allX = new int[2 * n + 2];\n\t\tint[] allY = new int[2 * n + 2];\n\n\t\tint[] xb = new int[n];\n\t\tint[] yb = new int[n];\n\t\tfor (int i = 0; i < n; i++) {\n\t\t\txb[i] = nextInt();\n\t\t\tyb[i] = nextInt();\n\t\t\tallX[2 * i] = xb[i];\n\t\t\tallX[2 * i + 1] = xb[i] + 1;\n\t\t\tallY[2 * i] = yb[i];\n\t\t\tallY[2 * i + 1] = yb[i] + 1;\n\t\t}\n\t\tallX[2 * n] = 0;\n\t\tallX[2 * n + 1] = r;\n\t\tallY[2 * n] = 0;\n\t\tallY[2 * n + 1] = c;\n\n\t\tallX = unique(allX);\n\t\tallY = unique(allY);\n\n\t\tint tot = (int) (((long) r * c - n) % P);\n\n\t\tr = allX.length - 1;\n\t\tc = allY.length - 1;\n\n\t\tboolean[][] occ = new boolean[r][c];\n\t\tfor (int i = 0; i < n; i++) {\n\t\t\tint cx = Arrays.binarySearch(allX, xb[i]);\n\t\t\tint cy = Arrays.binarySearch(allY, yb[i]);\n\t\t\tocc[cx][cy] = true;\n\t\t}\n\n\t\tint ans = (go(occ, allX, tot, allY[c] - allY[0]) + go(transpose(occ),\n\t\t\t\tallY, tot, allX[r] - allX[0])) % P;\n\n\t\tint[][] d = new int[r][c];\n\t\tint[] que = new int[2 * r * c];\n\n\t\tint[][] cellSz = new int[r][c];\n\t\tfor (int i = 0; i < r; i++) {\n\t\t\tfor (int j = 0; j < c; j++) {\n\t\t\t\tcellSz[i][j] = (int) ((long) (allX[i + 1] - allX[i])\n\t\t\t\t\t\t* (allY[j + 1] - allY[j]) % P);\n\t\t\t}\n\t\t}\n\n\t\tfor (int x0 = 0; x0 < r; x0++) {\n\t\t\tfor (int y0 = 0; y0 < c; y0++) {\n\t\t\t\tif (occ[x0][y0]) {\n\t\t\t\t\tcontinue;\n\t\t\t\t}\n\t\t\t\tfor (int[] row : d) {\n\t\t\t\t\tArrays.fill(row, INF);\n\t\t\t\t}\n\t\t\t\td[x0][y0] = 0;\n\t\t\t\tint qh = 0, qt = 0;\n\t\t\t\tque[qt++] = x0;\n\t\t\t\tque[qt++] = y0;\n\n\t\t\t\twhile (qh < qt) {\n\t\t\t\t\tint x = que[qh++];\n\t\t\t\t\tint y = que[qh++];\n\t\t\t\t\tif (x0 * c + y0 < x * c + y) {\n\t\t\t\t\t\t\n//\t\t\t\t\t\tSystem.err.println(x0 + \" \" + y0 + \" \" + x + \" \" + y + \" \" + d[x][y]);\n\t\t\t\t\t\t\n\t\t\t\t\t\tans += (int) ((long) cellSz[x0][y0] * cellSz[x][y] % P\n\t\t\t\t\t\t\t\t* d[x][y] % P);\n\t\t\t\t\t\tif (ans >= P) {\n\t\t\t\t\t\t\tans -= P;\n\t\t\t\t\t\t}\n\t\t\t\t\t}\n\n\t\t\t\t\tfor (int dir = 0; dir < 4; dir++) {\n\t\t\t\t\t\tint nx = x + DX[dir];\n\t\t\t\t\t\tint ny = y + DY[dir];\n\t\t\t\t\t\tif (nx >= 0 && nx < r && ny >= 0 && ny < c\n\t\t\t\t\t\t\t\t&& !occ[nx][ny] && d[nx][ny] > d[x][y] + 1) {\n\t\t\t\t\t\t\td[nx][ny] = d[x][y] + 1;\n\t\t\t\t\t\t\tque[qt++] = nx;\n\t\t\t\t\t\t\tque[qt++] = ny;\n\t\t\t\t\t\t}\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\n\t\tout.println(ans);\n\t}\n\n\tstatic final int[] DX = { -1, 0, 1, 0 };\n\tstatic final int[] DY = { 0, -1, 0, 1 };\n\n\tstatic final int INF = Integer.MAX_VALUE;\n\n\tboolean[][] transpose(boolean[][] f) {\n\t\tboolean[][] g = new boolean[f[0].length][f.length];\n\t\tfor (int i = 0; i < f.length; i++) {\n\t\t\tfor (int j = 0; j < f[i].length; j++) {\n\t\t\t\tg[j][i] = f[i][j];\n\t\t\t}\n\t\t}\n\t\treturn g;\n\t}\n\n\tint go(boolean[][] occ, int[] allX, int tot, int width) {\n\t\tint top = 0;\n\t\tint btm = tot;\n\t\tint ret = 0;\n\t\tfor (int i = 0; i < occ.length; i++) {\n\t\t\tint blacks = 0;\n\t\t\tfor (int j = 0; j < occ[i].length; j++) {\n\t\t\t\tblacks += occ[i][j] ? 1 : 0;\n\t\t\t}\n\t\t\tif (blacks > 0) {\n\t\t\t\tint delta = width - blacks;\n\t\t\t\ttop += delta;\n\t\t\t\tif (top >= P) {\n\t\t\t\t\ttop -= P;\n\t\t\t\t}\n\n\t\t\t\tbtm -= delta;\n\t\t\t\tif (btm < 0) {\n\t\t\t\t\tbtm += P;\n\t\t\t\t}\n\t\t\t\tcontinue;\n\t\t\t}\n\t\t\tfor (int row = 1; row < allX[i + 1] - allX[i]; row++) {\n\t\t\t\ttop += width;\n\t\t\t\tif (top >= P) {\n\t\t\t\t\ttop -= P;\n\t\t\t\t}\n\n\t\t\t\tbtm -= width;\n\t\t\t\tif (btm < 0) {\n\t\t\t\t\tbtm += P;\n\t\t\t\t}\n\n\t\t\t\tret += (int) ((long) top * btm % P);\n\t\t\t\tif (ret >= P) {\n\t\t\t\t\tret -= P;\n\t\t\t\t}\n\t\t\t}\n\t\t\ttop += width;\n\t\t\tif (top >= P) {\n\t\t\t\ttop -= P;\n\t\t\t}\n\n\t\t\tbtm -= width;\n\t\t\tif (btm < 0) {\n\t\t\t\tbtm += P;\n\t\t\t}\n\t\t}\n\t\treturn ret;\n\t}\n\n\tstatic final int P = 1_000_000_007;\n\n\tint[] unique(int[] a) {\n\t\tArrays.sort(a);\n\t\tint sz = 1;\n\t\tfor (int i = 1; i < a.length; i++) {\n\t\t\tif (a[i] != a[sz - 1]) {\n\t\t\t\ta[sz++] = a[i];\n\t\t\t}\n\t\t}\n\t\treturn Arrays.copyOf(a, sz);\n\t}\n\n\tvoid preCalc() {\n\n\t}\n\n\tvoid stress() {\n\n\t}\n\n\tvoid test() {\n\n\t}\n\n\tMain() throws IOException {\n\t\tbr = new BufferedReader(new InputStreamReader(System.in));\n\t\tout = new PrintWriter(System.out);\n\t\tpreCalc();\n\t\tsubmit();\n\t\t// stress();\n\t\t// test();\n\t\tout.close();\n\t}\n\n\tstatic final Random rng = new Random();\n\n\tstatic int rand(int l, int r) {\n\t\treturn l + rng.nextInt(r - l + 1);\n\t}\n\n\tpublic static void main(String[] args) throws IOException {\n\t\tnew Main();\n\t}\n\n\tBufferedReader br;\n\tPrintWriter out;\n\tStringTokenizer st;\n\n\tString nextToken() {\n\t\twhile (st == null || !st.hasMoreTokens()) {\n\t\t\ttry {\n\t\t\t\tst = new StringTokenizer(br.readLine());\n\t\t\t} catch (IOException e) {\n\t\t\t\tthrow new RuntimeException(e);\n\t\t\t}\n\t\t}\n\t\treturn st.nextToken();\n\t}\n\n\tString nextString() {\n\t\ttry {\n\t\t\treturn br.readLine();\n\t\t} catch (IOException e) {\n\t\t\tthrow new RuntimeException(e);\n\t\t}\n\t}\n\n\tint nextInt() {\n\t\treturn Integer.parseInt(nextToken());\n\t}\n\n\tlong nextLong() {\n\t\treturn Long.parseLong(nextToken());\n\t}\n\n\tdouble nextDouble() {\n\t\treturn Double.parseDouble(nextToken());\n\t}\n}\n"
  },
  {
    "language": "C#",
    "code": "#include <algorithm>\n#include <iostream>\n#include <queue>\n#include <utility>\n#include <vector>\n\nusing namespace std;\nconst int N = 32;\nconst int T = N * N * 10;\n\nstruct area {\n\tint l, r, f, c;\n\t// left right floor ceil\n};\nvector<area> ar;\n\nint W, H, n;\npair<int, int> blocked[N];\nvector<int> xl, yl;\n\nsigned main() {\n\tcin >> W >> H >> n;\n\tfor (register int i = 1; i <= n; i++) {\n\t\tcin >> blocked[i].first >> blocked[i].second;\n\t\txl[i] = blocked[i].first;\n\t\tyl[i] = blocked[i].second;\n\t}\n\t\n\txl.push_back(0), xl.push_back(W);\n\tyl.push_back(0), yl.push_back(H);\n\tsort(xl.begin(), xl.end());\n\tsort(yl.begin(), yl.end());\n\txl.erase(unique(xl.begin(), xl.end()), xl.end());\n\tyl.erase(unique(yl.begin(), yl.end()), yl.end());\n\t\n\tfor (vector<int::iterator i = xl.begin() + 1; i < xl.end(); i++) { // x in (*(i - 1), *i)\n\t\tfor (vector<int::iterator j = xr.begin() + 1; j < xr.end(); j++) { // y in (*(j - 1), *j)\n\t\t\tif (*i - *(i - 1) <= 1) continue;\n\t\t\tif (*j - *(j - 1) <= 1) continue;\n\t\t\tarea cur{*(i - 1) + 1, *i - 1, }\n\t\t}\n\t}\n}"
  },
  {
    "language": "Python",
    "code": "from collections import deque\nmod = 10**9 + 7\nh, w = map(int, input().split())\nn = int(input())\n\nans = 0\n\nblack = []\nrow = [0]*h\ncolumn = [0]*w\nfor _ in range(n):\n    x, y = map(int, input().split())\n    row[x] += 1\n    column[y] += 1\n    black.append([x, y])\n\n\ncnt = 0\ntop = 0\nbottom = h*w - n\narea = []\nfor i in range(h):\n    if row[i] == 0:\n        cnt += 1\n        if i != h-1 and row[i+1] == 0:\n            top += w\n            bottom -= w\n            ans += top*bottom\n            ans %= mod\n        else:\n            area.append([cnt for _ in range(w)])\n    else:\n        top += w-row[i]\n        bottom -= w-row[i]\n        area.append([1 for _ in range(w)])\n        for x, y in black:\n            if x == i:\n                area[-1][y] = 0\n        cnt = 0\n\nR = len(area)\n\ncnt = 0\nleft = 0\nright = h*w - n\narea2 = []\nfor j in range(w):\n    if column[j] == 0:\n        cnt += 1\n        if j != w-1 and column[j+1] == 0:\n            left += h\n            right -= h\n            ans += left*right\n            ans %= mod\n        else:\n            area2.append([cnt*area[i][j] for i in range(R)])\n    else:\n        left += w-column[j]\n        right -= w-column[j]\n        area2.append([area[i][j] for i in range(R)])\n        cnt = 0\n\nC = len(area2)\nvec = [[1, 0], [0, 1], [-1, 0], [0, -1]]\n\n\ndef bfs(p, q):\n    dist = [[10**9 for _ in range(R)] for __ in range(C)]\n    visited = [[False for _ in range(R)] for __ in range(C)]\n    dist[p][q] = 0\n    visited[p][q] = True\n    q = deque([(p, q)])\n    while q:\n        x, y = q.popleft()\n        for dx, dy in vec:\n            if 0 <= x+dx < C and 0 <= y+dy < R and area2[x+dx][y+dy] != 0:\n                if not visited[x+dx][y+dy]:\n                    dist[x+dx][y+dy] = dist[x][y] + 1\n                    visited[x+dx][y+dy] = True\n                    q.append((x+dx, y+dy))\n    return dist\n\n\nans2 = 0\n\nfor i in range(C):\n    for j in range(R):\n        d = bfs(i, j)\n        for k in range(C):\n            for l in range(R):\n                ans2 += area2[i][j]*area2[k][l]*d[k][l]\n                ans2 %= mod\n\nans2 *= pow(2, mod-2, mod)\n\nprint((ans+ans2) % mod)\n"
  },
  {
    "language": "Python",
    "code": "from collections import deque, Counter\nmod = 10**9 + 7\nh, w = map(int, input().split())\nn = int(input())\n\nans = 0\n\nblack = []\nrow = Counter()\ncolumn = Counter()\nfor _ in range(n):\n    x, y = map(int, input().split())\n    row[x] += 1\n    column[y] += 1\n    black.append((x, y))\nrow[h] += 1\ncolumn[w] += 1\n\n\ndef sqsum(x):\n    return x*(x+1)*(2*x+1)//6\n\n\npre = -1\ntop = 0\nbottom = h*w - n\narea = []\nfor i in sorted(row.keys()):\n    if i == pre+2:\n        top += w\n        bottom -= w\n        area.append([-1, 1])\n    elif i > pre+2:\n        # for x in range(pre+1, i-1):\n        #     top += w\n        #     bottom -= w\n        #     ans += top*bottom\n        #     ans %= mod\n        ans += (i-pre-2)*top*bottom + ((i-pre-2)*(i-pre-1)//2) *w*(bottom-top) - sqsum(i-pre-2)*(w**2)\n        ans %= mod\n        top += (i-pre-1)*w\n        bottom -= (i-pre-1)*w\n        area.append([-1, i-pre-1])\n    if i != h:\n        top += w-row[i]\n        bottom -= w-row[i]\n        area.append([i])\n    pre = i\n\nR = len(area)\n\npre = -1\nleft = 0\nright = h*w-n\narea2 = []\nfor j in sorted(column.keys()):\n    if j == pre+2:\n        left += h\n        right -= h\n        area2.append([area[i][1] if area[i][0] == -1 else 1 for i in range(R)])\n    elif j > pre+2:\n        ans += (j-pre-2)*left*right + ((j-pre-2)*(j-pre-1)//2) *h*(right-left) - sqsum(j-pre-2)*(h**2)\n        ans %= mod\n        left += (j-pre-1)*h\n        right -= (j-pre-1)*h\n        area2.append([(j-pre-1)*area[i][1] if area[i][0]\n                      == -1 else (j-pre-1) for i in range(R)])\n    if j != w:\n        left += h-column[j]\n        right -= h-column[j]\n        tmp = []\n        for i in range(R):\n            if area[i][0] == -1:\n                tmp.append(area[i][1])\n            else:\n                if (area[i][0], j) in black:\n                    tmp.append(0)\n                else:\n                    tmp.append(1)\n        area2.append(tmp)\n    pre = j\n\n\nC = len(area2)\narea2 = [[area2[j][i] for j in range(C)] for i in range(R)]\n\nvec = [[1, 0], [0, 1], [-1, 0], [0, -1]]\n\n\ndef bfs(p, q):\n    dist = [[10**5 for _ in range(C)] for __ in range(R)]\n    visited = [[False for _ in range(C)] for __ in range(R)]\n    dist[p][q] = 0\n    visited[p][q] = True\n    q = deque([(p, q)])\n    while q:\n        x, y = q.popleft()\n        for dx, dy in vec:\n            if 0 <= x+dx < R and 0 <= y+dy < C and area2[x+dx][y+dy] != 0:\n                if not visited[x+dx][y+dy]:\n                    dist[x+dx][y+dy] = dist[x][y] + 1\n                    visited[x+dx][y+dy] = True\n                    q.append((x+dx, y+dy))\n    return dist\n\n\nans2 = 0\n\nfor i in range(R):\n    for j in range(C):\n        if area2[i][j] == 0:\n            continue\n        d = bfs(i, j)\n        for k in range(R):\n            for l in range(C):\n                if area2[k][l] == 0:\n                    continue\n                ans2 += area2[i][j]*area2[k][l]*d[k][l]\n                ans2 %= mod\n\nans2 *= pow(2, mod-2, mod)\n\nprint((ans+ans2) % mod)\n"
  },
  {
    "language": "Python",
    "code": "from collections import Counter\nmod = 10**9+7\nh, w = map(int, input().split())\nn = int(input())\n\nans = 0\n\nblack = []\nrow = Counter()\ncolumn = Counter()\nfor _ in range(n):\n    x, y = map(int, input().split())\n    row[x] += 1\n    column[y] += 1\n    black.append((x, y))\nrow[h] += 1\ncolumn[w] += 1\n\n\ndef sqsum(x):\n    return x*(x+1)*(2*x+1)//6\n\n\npre = -1\ntop = 0\nbottom = h*w - n\narea = []\nfor i in sorted(row.keys()):\n    if i == pre+2:\n        top += w\n        bottom -= w\n        area.append([-1, 1])\n    elif i > pre+2:\n        # for x in range(pre+1, i-1):\n        #     top += w\n        #     bottom -= w\n        #     ans += top*bottom\n        #     ans %= mod\n        ans += (i-pre-2)*top*bottom + ((i-pre-2)*(i-pre-1)//2) * \\\n            w*(bottom-top) - sqsum(i-pre-2)*(w**2)\n        ans %= mod\n        top += (i-pre-1)*w\n        bottom -= (i-pre-1)*w\n        area.append([-1, i-pre-1])\n    if i != h:\n        top += w-row[i]\n        bottom -= w-row[i]\n        area.append([i])\n    pre = i\n\nR = len(area)\n\npre = -1\nleft = 0\nright = h*w-n\narea2 = []\nfor j in sorted(column.keys()):\n    if j == pre+2:\n        left += h\n        right -= h\n        area2.append([area[i][1] if area[i][0] == -1 else 1 for i in range(R)])\n    elif j > pre+2:\n        ans += (j-pre-2)*left*right + ((j-pre-2)*(j-pre-1)//2) * \\\n            h*(right-left) - sqsum(j-pre-2)*(h**2)\n        ans %= mod\n        left += (j-pre-1)*h\n        right -= (j-pre-1)*h\n        area2.append([(j-pre-1)*area[i][1] if area[i][0]\n                      == -1 else (j-pre-1) for i in range(R)])\n    if j != w:\n        left += h-column[j]\n        right -= h-column[j]\n        tmp = []\n        for i in range(R):\n            if area[i][0] == -1:\n                tmp.append(area[i][1])\n            else:\n                if (area[i][0], j) in black:\n                    tmp.append(0)\n                else:\n                    tmp.append(1)\n        area2.append(tmp)\n    pre = j\n\n\nC = len(area2)\narea2 = [[area2[j][i] % mod for j in range(C)] for i in range(R)]\n\n# print(R, C)\n# for x in area2:\n#     print(*x)\n# exit()\n\nINF = 10**9+7\nd = [[INF]*(R*C) for _ in range(R*C)]\nvec = [[1, 0], [0, 1], [-1, 0], [0, -1]]\n\nfor i in range(R*C):\n    x = i//C\n    y = i % C\n    if area2[x][y] == 0:\n        continue\n    for dx, dy in vec:\n        j = (x+dx)*C + y+dy\n        if 0 <= x+dx < R and 0 <= y+dy < C and area2[x+dx][y+dy] != 0:\n            d[i][j] = d[j][i] = 1\n\n\ndef warfl(d, card):\n    for i in range(card):\n        d[i][i] = 0\n    for k in range(card):\n        for i in range(card):\n            for j in range(card):\n                if d[i][k] != INF and d[k][j] != INF:\n                    d[i][j] = min(d[i][j], d[i][k] + d[k][j])\n    return d\n\n\nans2 = 0\nd = warfl(d, R*C)\n\nfor i in range(R*C):\n    for j in range(R*C):\n        ans2 += area2[i//C][i % C]*area2[j//C][j % C]*d[i][j]\n        ans2 %= mod\n\nans2 *= pow(2, mod-2, mod)\n\nprint((ans+ans2) % mod)\n"
  },
  {
    "language": "Python",
    "code": "from collections import deque, Counter\nmod = 10**9 + 7\nh, w = map(int, input().split())\nn = int(input())\n\nans = 0\n\nblack = []\nrow = Counter()\ncolumn = Counter()\nfor _ in range(n):\n    x, y = map(int, input().split())\n    row[x] += 1\n    column[y] += 1\n    black.append((x, y))\nrow[h] += 1\ncolumn[w] += 1\n\n\ndef sqsum(x):\n    return x*(x+1)*(2*x+1)//6\n\n\npre = -1\ntop = 0\nbottom = h*w - n\narea = []\nfor i in sorted(row.keys()):\n    if i == pre+2:\n        top += w\n        bottom -= w\n        area.append([-1, 1])\n    elif i > pre+2:\n        # for x in range(pre+1, i-1):\n        #     top += w\n        #     bottom -= w\n        #     ans += top*bottom\n        #     ans %= mod\n        ans += (i-pre-2)*top*bottom + ((i-pre-2)*(i-pre-1)//2) *w*(bottom-top) - sqsum(i-pre-2)*(w**2)\n        ans %= mod\n        top += (i-pre-1)*w\n        bottom -= (i-pre-1)*w\n        area.append([-1, i-pre-1])\n    if i != h:\n        top += w-row[i]\n        bottom -= w-row[i]\n        area.append([i])\n    pre = i\n\nR = len(area)\n\npre = -1\nleft = 0\nright = h*w-n\narea2 = []\nfor j in sorted(column.keys()):\n    if j == pre+2:\n        left += h\n        right -= h\n        area2.append([area[i][1] if area[i][0] == -1 else 1 for i in range(R)])\n    elif j > pre+2:\n        ans += (j-pre-2)*left*right + ((j-pre-2)*(j-pre-1)//2) *h*(right-left) - sqsum(j-pre-2)*(h**2)\n        ans %= mod\n        left += (j-pre-1)*h\n        right -= (j-pre-1)*h\n        area2.append([(j-pre-1)*area[i][1] if area[i][0]\n                      == -1 else (j-pre-1) for i in range(R)])\n    if j != w:\n        left += h-column[j]\n        right -= h-column[j]\n        tmp = []\n        for i in range(R):\n            if area[i][0] == -1:\n                tmp.append(area[i][1])\n            else:\n                if (area[i][0], j) in black:\n                    tmp.append(0)\n                else:\n                    tmp.append(1)\n        area2.append(tmp)\n    pre = j\n\n\nC = len(area2)\narea2 = [[area2[j][i] for j in range(C)] for i in range(R)]\n\nvec = [[1, 0], [0, 1], [-1, 0], [0, -1]]\n\n\ndef bfs(p, q):\n    dist = [[10**5 for _ in range(C)] for __ in range(R)]\n    visited = [[False for _ in range(C)] for __ in range(R)]\n    dist[p][q] = 0\n    visited[p][q] = True\n    q = deque([(p, q)])\n    while q:\n        x, y = q.popleft()\n        for dx, dy in vec:\n            if 0 <= x+dx < R and 0 <= y+dy < C and area2[x+dx][y+dy] != 0:\n                if not visited[x+dx][y+dy]:\n                    dist[x+dx][y+dy] = dist[x][y] + 1\n                    visited[x+dx][y+dy] = True\n                    q.append((x+dx, y+dy))\n    return dist\n\n\nans2 = 0\n\nfor i in range(R):\n    for j in range(C):\n        if area2[i][j] == 0:\n            continue\n        d = bfs(i, j)\n        for k in range(R):\n            for l in range(C):\n                if area2[k][l] == 0:\n                    continue\n                ans2 += area2[i][j]*area2[k][l]*d[k][l]\n                ans2 %= mod\n\nans2 *= pow(2, mod-2, mod)\n\nprint((ans+ans2) % mod)\n"
  },
  {
    "language": "Python",
    "code": "from collections import Counter\nmod = 10**9+7\nh, w = map(int, input().split())\nn = int(input())\n\nans = 0\n\nblack = []\nrow = Counter()\ncolumn = Counter()\nfor _ in range(n):\n    x, y = map(int, input().split())\n    row[x] += 1\n    column[y] += 1\n    black.append((x, y))\nrow[h] += 1\ncolumn[w] += 1\n\n\ndef sqsum(x):\n    return x*(x+1)*(2*x+1)//6\n\n\npre = -1\ntop = 0\nbottom = h*w - n\narea = []\nfor i in sorted(row.keys()):\n    if i == pre+2:\n        top += w\n        bottom -= w\n        area.append([-1, 1])\n    elif i > pre+2:\n        ans += (i-pre-2)*top*bottom + ((i-pre-2)*(i-pre-1)//2) * \\\n            w*(bottom-top) - sqsum(i-pre-2)*(w**2)\n        ans %= mod\n        top += (i-pre-1)*w\n        bottom -= (i-pre-1)*w\n        area.append([-1, i-pre-1])\n    if i != h:\n        top += w-row[i]\n        bottom -= w-row[i]\n        area.append([i])\n    pre = i\n\nR = len(area)\n\npre = -1\nleft = 0\nright = h*w-n\narea2 = []\nfor j in sorted(column.keys()):\n    if j == pre+2:\n        left += h\n        right -= h\n        area2.append([area[i][1] if area[i][0] == -1 else 1 for i in range(R)])\n    elif j > pre+2:\n        ans += (j-pre-2)*left*right + ((j-pre-2)*(j-pre-1)//2) * \\\n            h*(right-left) - sqsum(j-pre-2)*(h**2)\n        ans %= mod\n        left += (j-pre-1)*h\n        right -= (j-pre-1)*h\n        area2.append([(j-pre-1)*area[i][1] if area[i][0]\n                      == -1 else (j-pre-1) for i in range(R)])\n    if j != w:\n        left += h-column[j]\n        right -= h-column[j]\n        tmp = []\n        for i in range(R):\n            if area[i][0] == -1:\n                tmp.append(area[i][1])\n            else:\n                if (area[i][0], j) in black:\n                    tmp.append(0)\n                else:\n                    tmp.append(1)\n        area2.append(tmp)\n    pre = j\n\n\nC = len(area2)\narea2 = [[area2[j][i] % mod for j in range(C)] for i in range(R)]\n\nINF = 10**9+7\nd = [[INF]*(R*C) for _ in range(R*C)]\nvec = [[1, 0], [0, 1], [-1, 0], [0, -1]]\n\nfor i in range(R*C):\n    x = i//C\n    y = i % C\n    if area2[x][y] == 0:\n        continue\n    for dx, dy in vec:\n        j = (x+dx)*C + y+dy\n        if 0 <= x+dx < R and 0 <= y+dy < C and area2[x+dx][y+dy] != 0:\n            d[i][j] = d[j][i] = 1\n\n\ndef warfl(d, card):\n    for i in range(card):\n        d[i][i] = 0\n    for k in range(card):\n        for i in range(card):\n            for j in range(card):\n                if d[i][k] != INF and d[k][j] != INF:\n                    d[i][j] = min(d[i][j], d[i][k] + d[k][j])\n    return d\n\n\nans2 = 0\nd = warfl(d, R*C)\n\nfor i in range(R*C):\n    for j in range(R*C):\n        ans2 += area2[i//C][i % C]*area2[j//C][j % C]*d[i][j]\n        ans2 %= mod\n\nans2 *= pow(2, mod-2, mod)\n\nprint((ans+ans2) % mod)\n"
  },
  {
    "language": "Python",
    "code": "from collections import deque, Counter\nimport sys\nsys.setrecursionlimit(10 ** 7)\ninput = sys.stdin.readline\n\nmod = 10**9 + 7\nh, w = map(int, input().split())\nn = int(input())\n\nans = 0\n\nblack = []\nrow = Counter()\ncolumn = Counter()\nfor _ in range(n):\n    x, y = map(int, input().split())\n    row[x] += 1\n    column[y] += 1\n    black.append((x, y))\nrow[h] += 1\ncolumn[w] += 1\n\n\ndef sqsum(x):\n    return x*(x+1)*(2*x+1)//6\n\n\npre = -1\ntop = 0\nbottom = h*w - n\narea = []\nfor i in sorted(row.keys()):\n    if i == pre+2:\n        top += w\n        bottom -= w\n        area.append([-1, 1])\n    elif i > pre+2:\n        ans += (i-pre-2)*top*bottom + ((i-pre-2)*(i-pre-1)//2) * \\\n            w*(bottom-top) - sqsum(i-pre-2)*(w**2)\n        ans %= mod\n        top += (i-pre-1)*w\n        bottom -= (i-pre-1)*w\n        area.append([-1, i-pre-1])\n    if i != h:\n        top += w-row[i]\n        bottom -= w-row[i]\n        area.append([i])\n    pre = i\n\nR = len(area)\n\npre = -1\nleft = 0\nright = h*w-n\narea2 = []\nfor j in sorted(column.keys()):\n    if j == pre+2:\n        left += h\n        right -= h\n        area2.append([area[i][1] if area[i][0] == -1 else 1 for i in range(R)])\n    elif j > pre+2:\n        ans += (j-pre-2)*left*right + ((j-pre-2)*(j-pre-1)//2) * \\\n            h*(right-left) - sqsum(j-pre-2)*(h**2)\n        ans %= mod\n        left += (j-pre-1)*h\n        right -= (j-pre-1)*h\n        area2.append([(j-pre-1)*area[i][1] if area[i][0]\n                      == -1 else (j-pre-1) for i in range(R)])\n    if j != w:\n        left += h-column[j]\n        right -= h-column[j]\n        tmp = []\n        for i in range(R):\n            if area[i][0] == -1:\n                tmp.append(area[i][1])\n            else:\n                if (area[i][0], j) in black:\n                    tmp.append(0)\n                else:\n                    tmp.append(1)\n        area2.append(tmp)\n    pre = j\n\n\nC = len(area2)\narea2 = [[area2[j][i] for j in range(C)] for i in range(R)]\n\nvec = [[1, 0], [0, 1], [-1, 0], [0, -1]]\n\n\ndef bfs(p, q):\n    dist = [[10**5 for _ in range(C)] for __ in range(R)]\n    visited = [[False for _ in range(C)] for __ in range(R)]\n    dist[p][q] = 0\n    visited[p][q] = True\n    q = deque([(p, q)])\n    while q:\n        x, y = q.popleft()\n        for dx, dy in vec:\n            if 0 <= x+dx < R and 0 <= y+dy < C and area2[x+dx][y+dy] != 0:\n                if not visited[x+dx][y+dy]:\n                    dist[x+dx][y+dy] = dist[x][y] + 1\n                    visited[x+dx][y+dy] = True\n                    q.append((x+dx, y+dy))\n    return dist\n\n\nans2 = 0\n\nfor x in range(R*C):\n    i = x//C\n    j = x % C\n    if area2[i][j] == 0:\n        continue\n    d = bfs(i, j)\n    for y in range(R*C):\n        k = y//C\n        l = y % C\n        if area2[k][l] == 0:\n            continue\n        ans2 += area2[i][j]*area2[k][l]*d[k][l]\n        ans2 %= mod\n\nans2 *= pow(2, mod-2, mod)\n\nprint((ans+ans2) % mod)\n"
  },
  {
    "language": "Python",
    "code": "print(\"bandzebo\")"
  }
]