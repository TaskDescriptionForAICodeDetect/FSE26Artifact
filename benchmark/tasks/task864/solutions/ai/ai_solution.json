[
  {
    "model": "claude-3-5-haiku-20241022",
    "prompt_type": "zero_shot",
    "language": "C",
    "code": "#include <stdio.h>\n#include <stdlib.h>\n#include <string.h>\n#include <limits.h>\n\n#define MOD 1000000007\n\nint min(int a, int b) {\n    return a < b ? a : b;\n}\n\nint main() {\n    int H, W, N;\n    scanf(\"%d %d %d\", &H, &W, &N);\n\n    int **grid = malloc(H * sizeof(int *));\n    for (int i = 0; i < H; i++) {\n        grid[i] = calloc(W, sizeof(int));\n    }\n\n    for (int i = 0; i < N; i++) {\n        int x, y;\n        scanf(\"%d %d\", &x, &y);\n        grid[x][y] = 1;\n    }\n\n    long long total_distance = 0;\n\n    for (int r1 = 0; r1 < H; r1++) {\n        for (int c1 = 0; c1 < W; c1++) {\n            if (grid[r1][c1]) continue;\n\n            for (int r2 = r1; r2 < H; r2++) {\n                for (int c2 = (r2 == r1 ? c1 + 1 : 0); c2 < W; c2++) {\n                    if (grid[r2][c2]) continue;\n\n                    int dist = abs(r1 - r2) + abs(c1 - c2);\n                    total_distance = (total_distance + dist) % MOD;\n                }\n            }\n        }\n    }\n\n    printf(\"%lld\\n\", total_distance);\n\n    for (int i = 0; i < H; i++) {\n        free(grid[i]);\n    }\n    free(grid);\n\n    return 0;\n}",
    "timestamp": "2025-08-05 23:09:44"
  },
  {
    "model": "deepseek-v3",
    "prompt_type": "zero_shot",
    "language": "C",
    "code": "#include <stdio.h>\n#include <stdlib.h>\n#include <limits.h>\n#include <stdbool.h>\n\n#define MOD 1000000007\n\ntypedef struct {\n    int x, y;\n} Point;\n\nint H, W, N;\nPoint *black;\nbool **is_black;\nint **dist;\nlong long total = 0;\n\nint dx[] = {-1, 1, 0, 0};\nint dy[] = {0, 0, -1, 1};\n\nvoid bfs(int start_x, int start_y) {\n    int **queue = malloc(H * W * sizeof(int *));\n    for (int i = 0; i < H * W; i++) {\n        queue[i] = malloc(2 * sizeof(int));\n    }\n    int front = 0, rear = 0;\n    queue[rear][0] = start_x;\n    queue[rear][1] = start_y;\n    rear++;\n    dist[start_x][start_y] = 0;\n    \n    while (front < rear) {\n        int x = queue[front][0];\n        int y = queue[front][1];\n        front++;\n        \n        for (int d = 0; d < 4; d++) {\n            int nx = x + dx[d];\n            int ny = y + dy[d];\n            \n            if (nx >= 0 && nx < H && ny >= 0 && ny < W && !is_black[nx][ny] && dist[nx][ny] == -1) {\n                dist[nx][ny] = dist[x][y] + 1;\n                total = (total + dist[nx][ny]) % MOD;\n                queue[rear][0] = nx;\n                queue[rear][1] = ny;\n                rear++;\n            }\n        }\n    }\n    \n    for (int i = 0; i < H * W; i++) {\n        free(queue[i]);\n    }\n    free(queue);\n}\n\nint main() {\n    scanf(\"%d %d %d\", &H, &W, &N);\n    \n    black = malloc(N * sizeof(Point));\n    is_black = malloc(H * sizeof(bool *));\n    for (int i = 0; i < H; i++) {\n        is_black[i] = malloc(W * sizeof(bool));\n        for (int j = 0; j < W; j++) {\n            is_black[i][j] = false;\n        }\n    }\n    \n    for (int i = 0; i < N; i++) {\n        scanf(\"%d %d\", &black[i].x, &black[i].y);\n        is_black[black[i].x][black[i].y] = true;\n    }\n    \n    dist = malloc(H * sizeof(int *));\n    for (int i = 0; i < H; i++) {\n        dist[i] = malloc(W * sizeof(int));\n    }\n    \n    for (int i = 0; i < H; i++) {\n        for (int j = 0; j < W; j++) {\n            if (!is_black[i][j]) {\n                for (int k = 0; k < H; k++) {\n                    for (int l = 0; l < W; l++) {\n                        dist[k][l] = -1;\n                    }\n                }\n                bfs(i, j);\n            }\n        }\n    }\n    \n    printf(\"%lld\\n\", total / 2 % MOD);\n    \n    for (int i = 0; i < H; i++) {\n        free(is_black[i]);\n        free(dist[i]);\n    }\n    free(is_black);\n    free(dist);\n    free(black);\n    \n    return 0;\n}",
    "timestamp": "2025-08-05 23:11:45"
  },
  {
    "model": "deepseek-v3",
    "prompt_type": "zero_shot",
    "language": "C++",
    "code": "#include <iostream>\n#include <vector>\n#include <queue>\n#include <utility>\n#include <algorithm>\nusing namespace std;\n\nconst int MOD = 1000000007;\nconst int INF = 1e9;\n\nint main() {\n    int H, W, N;\n    cin >> H >> W >> N;\n    vector<vector<bool>> isBlack(H, vector<bool>(W, false));\n    for (int i = 0; i < N; ++i) {\n        int x, y;\n        cin >> x >> y;\n        isBlack[x][y] = true;\n    }\n\n    vector<vector<int>> dist(H, vector<int>(W, INF));\n    queue<pair<int, int>> q;\n    for (int i = 0; i < H; ++i) {\n        for (int j = 0; j < W; ++j) {\n            if (!isBlack[i][j]) {\n                dist[i][j] = 0;\n                q.push({i, j});\n            }\n        }\n    }\n\n    int dx[] = {0, 1, 0, -1};\n    int dy[] = {1, 0, -1, 0};\n    while (!q.empty()) {\n        auto [x, y] = q.front();\n        q.pop();\n        for (int k = 0; k < 4; ++k) {\n            int nx = x + dx[k];\n            int ny = y + dy[k];\n            if (nx >= 0 && nx < H && ny >= 0 && ny < W && !isBlack[nx][ny]) {\n                if (dist[nx][ny] > dist[x][y] + 1) {\n                    dist[nx][ny] = dist[x][y] + 1;\n                    q.push({nx, ny});\n                }\n            }\n        }\n    }\n\n    long long sum = 0;\n    for (int i = 0; i < H; ++i) {\n        for (int j = 0; j < W; ++j) {\n            if (!isBlack[i][j]) {\n                sum = (sum + dist[i][j]) % MOD;\n            }\n        }\n    }\n\n    cout << sum << endl;\n    return 0;\n}",
    "timestamp": "2025-08-05 23:12:06"
  },
  {
    "model": "deepseek-v3",
    "prompt_type": "zero_shot",
    "language": "Java",
    "code": "import java.util.*;\nimport java.io.*;\n\npublic class Main {\n    static final int MOD = 1_000_000_007;\n    static int H, W, N;\n    static boolean[][] isBlack;\n    static int[][] dist;\n    static int[] dx = {0, 1, 0, -1};\n    static int[] dy = {1, 0, -1, 0};\n\n    public static void main(String[] args) throws IOException {\n        BufferedReader br = new BufferedReader(new InputStreamReader(System.in));\n        StringTokenizer st = new StringTokenizer(br.readLine());\n        H = Integer.parseInt(st.nextToken());\n        W = Integer.parseInt(st.nextToken());\n        N = Integer.parseInt(st.nextToken());\n        isBlack = new boolean[H][W];\n        for (int i = 0; i < N; i++) {\n            st = new StringTokenizer(br.readLine());\n            int x = Integer.parseInt(st.nextToken());\n            int y = Integer.parseInt(st.nextToken());\n            isBlack[x][y] = true;\n        }\n\n        long total = 0;\n        for (int i = 0; i < H; i++) {\n            for (int j = 0; j < W; j++) {\n                if (!isBlack[i][j]) {\n                    total = (total + bfs(i, j)) % MOD;\n                }\n            }\n        }\n        System.out.println(total / 2);\n    }\n\n    static long bfs(int sx, int sy) {\n        dist = new int[H][W];\n        for (int[] row : dist) Arrays.fill(row, -1);\n        Queue<int[]> queue = new LinkedList<>();\n        queue.add(new int[]{sx, sy});\n        dist[sx][sy] = 0;\n        long sum = 0;\n\n        while (!queue.isEmpty()) {\n            int[] curr = queue.poll();\n            int x = curr[0], y = curr[1];\n            for (int d = 0; d < 4; d++) {\n                int nx = x + dx[d];\n                int ny = y + dy[d];\n                if (nx >= 0 && nx < H && ny >= 0 && ny < W && !isBlack[nx][ny] && dist[nx][ny] == -1) {\n                    dist[nx][ny] = dist[x][y] + 1;\n                    sum = (sum + dist[nx][ny]) % MOD;\n                    queue.add(new int[]{nx, ny});\n                }\n            }\n        }\n        return sum;\n    }\n}",
    "timestamp": "2025-08-05 23:12:30"
  },
  {
    "model": "claude-3-5-haiku-20241022",
    "prompt_type": "zero_shot",
    "language": "Java",
    "code": "import java.util.*;\n\npublic class ShortestWhiteSquareDistances {\n    public static int calculateShortestDistances(int H, int W, int[][] blackSquares) {\n        boolean[][] grid = new boolean[H][W];\n        \n        // Mark black squares\n        for (int[] black : blackSquares) {\n            grid[black[0]][black[1]] = true;\n        }\n        \n        List<int[]> whiteSquares = new ArrayList<>();\n        \n        // Find white squares\n        for (int i = 0; i < H; i++) {\n            for (int j = 0; j < W; j++) {\n                if (!grid[i][j]) {\n                    whiteSquares.add(new int[]{i, j});\n                }\n            }\n        }\n        \n        long totalDistance = 0;\n        int mod = 1_000_000_007;\n        \n        // Calculate distances between all white square pairs\n        for (int i = 0; i < whiteSquares.size(); i++) {\n            for (int j = i + 1; j < whiteSquares.size(); j++) {\n                int[] square1 = whiteSquares.get(i);\n                int[] square2 = whiteSquares.get(j);\n                \n                int distance = Math.abs(square1[0] - square2[0]) + Math.abs(square1[1] - square2[1]);\n                totalDistance = (totalDistance + distance) % mod;\n            }\n        }\n        \n        return (int)totalDistance;\n    }\n}",
    "timestamp": "2025-08-05 23:12:35"
  },
  {
    "model": "claude-3-5-haiku-20241022",
    "prompt_type": "zero_shot",
    "language": "C++",
    "code": "#include <bits/stdc++.h>\nusing namespace std;\n\nconst int MOD = 1e9 + 7;\n\nint main() {\n    int H, W, N;\n    cin >> H >> W >> N;\n    \n    vector<vector<bool>> grid(H, vector<bool>(W, true));\n    vector<pair<int, int>> black_squares;\n    \n    for (int i = 0; i < N; i++) {\n        int x, y;\n        cin >> x >> y;\n        grid[x][y] = false;\n        black_squares.emplace_back(x, y);\n    }\n    \n    vector<pair<int, int>> white_squares;\n    for (int i = 0; i < H; i++) {\n        for (int j = 0; j < W; j++) {\n            if (grid[i][j]) {\n                white_squares.emplace_back(i, j);\n            }\n        }\n    }\n    \n    long long total_distance = 0;\n    int M = white_squares.size();\n    \n    for (int i = 0; i < M; i++) {\n        for (int j = i + 1; j < M; j++) {\n            int x1 = white_squares[i].first, y1 = white_squares[i].second;\n            int x2 = white_squares[j].first, y2 = white_squares[j].second;\n            \n            int distance = abs(x1 - x2) + abs(y1 - y2);\n            total_distance = (total_distance + distance) % MOD;\n        }\n    }\n    \n    cout << total_distance << endl;\n    \n    return 0;\n}",
    "timestamp": "2025-08-05 23:12:42"
  },
  {
    "model": "gpt-4o",
    "prompt_type": "zero_shot",
    "language": "python",
    "code": "from collections import deque\nimport itertools\n\nMOD = 1000000007\n\ndef bfs(grid, H, W, start):\n    directions = [(-1, 0), (1, 0), (0, -1), (0, 1)]\n    queue = deque([start])\n    distances = [[-1] * W for _ in range(H)]\n    distances[start[0]][start[1]] = 0\n    \n    while queue:\n        x, y = queue.popleft()\n        for dx, dy in directions:\n            nx, ny = x + dx, y + dy\n            if 0 <= nx < H and 0 <= ny < W and grid[nx][ny] == 0 and distances[nx][ny] == -1:\n                distances[nx][ny] = distances[x][y] + 1\n                queue.append((nx, ny))\n    \n    return distances\n\ndef sum_of_distances(H, W, black_squares):\n    grid = [[0] * W for _ in range(H)]\n    \n    for x, y in black_squares:\n        grid[x][y] = 1\n\n    white_squares = [(x, y) for x in range(H) for y in range(W) if grid[x][y] == 0]\n\n    total_distance = 0\n\n    for start in white_squares:\n        distances = bfs(grid, H, W, start)\n        for end in white_squares:\n            if start != end:\n                total_distance += distances[end[0]][end[1]]\n                total_distance %= MOD\n\n    return total_distance\n\n# Example usage:\nH = 3\nW = 3\nblack_squares = [(1, 1)]\nprint(sum_of_distances(H, W, black_squares))  # Output should be the sum of all pairwise distances modulo 1,000,000,007",
    "timestamp": "2025-08-13 13:56:27"
  },
  {
    "model": "gpt-4o",
    "prompt_type": "zero_shot",
    "language": "java",
    "code": "import java.util.*;\n\npublic class GridDistances {\n    private static final int MOD = 1_000_000_007;\n    private static final int[] DX = {-1, 1, 0, 0};\n    private static final int[] DY = {0, 0, -1, 1};\n\n    public static long sumOfShortestDistances(int H, int W, List<int[]> blackSquares) {\n        boolean[][] grid = new boolean[H][W];\n        for (int[] black : blackSquares) {\n            grid[black[0]][black[1]] = true;\n        }\n\n        int numWhite = H * W - blackSquares.size();\n        Map<Integer, Integer> distances = new HashMap<>();\n\n        for (int i = 0; i < H; i++) {\n            for (int j = 0; j < W; j++) {\n                if (!grid[i][j]) {\n                    bfs(i, j, grid, distances, numWhite);\n                }\n            }\n        }\n\n        return distances.values().stream().reduce(0L, (a, b) -> (a + b) % MOD);\n    }\n\n    private static void bfs(int startX, int startY, boolean[][] grid, \n                            Map<Integer, Integer> distances, int numWhite) {\n        int H = grid.length;\n        int W = grid[0].length;\n        Queue<int[]> queue = new LinkedList<>();\n        boolean[][] visited = new boolean[H][W];\n        queue.offer(new int[]{startX, startY});\n        visited[startX][startY] = true;\n        int level = 0;\n\n        while (!queue.isEmpty()) {\n            int size = queue.size();\n            for (int i = 0; i < size; i++) {\n                int[] cell = queue.poll();\n                int x = cell[0];\n                int y = cell[1];\n\n                int key = x * W + y;\n                distances.put(key, distances.getOrDefault(key, 0) + level);\n\n                for (int d = 0; d < 4; d++) {\n                    int nx = x + DX[d];\n                    int ny = y + DY[d];\n                    if (nx >= 0 && nx < H && ny >= 0 && ny < W && !grid[nx][ny] && !visited[nx][ny]) {\n                        visited[nx][ny] = true;\n                        queue.offer(new int[]{nx, ny});\n                    }\n                }\n            }\n            level++;\n        }\n    }\n\n    public static void main(String[] args) {\n        int H = 3, W = 3;\n        List<int[]> blackSquares = Arrays.asList(new int[]{0, 1}, new int[]{1, 1});\n        System.out.println(sumOfShortestDistances(H, W, blackSquares));\n    }\n}",
    "timestamp": "2025-08-13 13:56:33"
  },
  {
    "model": "gpt-4o",
    "prompt_type": "zero_shot",
    "language": "c",
    "code": "#include <stdio.h>\n#include <stdlib.h>\n#include <stdbool.h>\n\n#define MOD 1000000007\n#define INF 1000000000\n\ntypedef struct {\n    int x, y;\n} Point;\n\ntypedef struct {\n    int *data;\n    int size;\n} Queue;\n\nQueue* createQueue(int maxElements) {\n    Queue *Q = (Queue *)malloc(sizeof(Queue));\n    Q->data = (int *)malloc(sizeof(int) * maxElements * 2);\n    Q->size = 0;\n    return Q;\n}\n\nvoid enqueue(Queue *Q, int x, int y) {\n    Q->data[(Q->size) * 2] = x;\n    Q->data[(Q->size) * 2 + 1] = y;\n    Q->size++;\n}\n\nPoint dequeue(Queue *Q) {\n    Point p = {Q->data[0], Q->data[1]};\n    for(int i = 2; i < Q->size * 2; i++) {\n        Q->data[i - 2] = Q->data[i];\n    }\n    Q->size--;\n    return p;\n}\n\nbool isEmpty(Queue *Q) {\n    return Q->size == 0;\n}\n\nvoid freeQueue(Queue *Q) {\n    free(Q->data);\n    free(Q);\n}\n\nint shortestDistanceSum(int H, int W, int N, Point blackCells[]) {\n    bool grid[H][W];\n    int dist[H][W];\n    int dx[] = {0, 0, 1, -1};\n    int dy[] = {1, -1, 0, 0};\n\n    for(int i = 0; i < H; i++)\n        for(int j = 0; j < W; j++)\n            grid[i][j] = true;\n\n    for(int i = 0; i < N; i++)\n        grid[blackCells[i].x][blackCells[i].y] = false;\n\n    unsigned long long totalSum = 0;\n\n    for(int startX = 0; startX < H; startX++) {\n        for(int startY = 0; startY < W; startY++) {\n            if(!grid[startX][startY])\n                continue;\n            \n            Queue* Q = createQueue(H * W);\n            for(int i = 0; i < H; i++)\n                for(int j = 0; j < W; j++)\n                    dist[i][j] = INF;\n\n            dist[startX][startY] = 0;\n            enqueue(Q, startX, startY);\n\n            while(!isEmpty(Q)) {\n                Point p = dequeue(Q);\n                int x = p.x, y = p.y;\n\n                for(int d = 0; d < 4; d++) {\n                    int nx = x + dx[d];\n                    int ny = y + dy[d];\n                    if(nx >= 0 && nx < H && ny >= 0 && ny < W && grid[nx][ny] && dist[nx][ny] > dist[x][y] + 1) {\n                        dist[nx][ny] = dist[x][y] + 1;\n                        enqueue(Q, nx, ny);\n                    }\n                }\n            }\n\n            for(int endX = 0; endX < H; endX++) {\n                for(int endY = 0; endY < W; endY++) {\n                    if(grid[endX][endY] && dist[endX][endY] != INF && (endX != startX || endY != startY)) {\n                        totalSum = (totalSum + dist[endX][endY]) % MOD;\n                    }\n                }\n            }\n\n            freeQueue(Q);\n        }\n    }\n\n    return totalSum;\n}\n\nint main() {\n    int H, W, N;\n    scanf(\"%d %d %d\", &H, &W, &N);\n\n    Point blackCells[N];\n    for(int i = 0; i < N; i++)\n        scanf(\"%d %d\", &blackCells[i].x, &blackCells[i].y);\n\n    int result = shortestDistanceSum(H, W, N, blackCells);\n    printf(\"%d\\n\", result);\n\n    return 0;\n}",
    "timestamp": "2025-08-13 13:57:08"
  },
  {
    "model": "gpt-4o",
    "prompt_type": "zero_shot",
    "language": "js",
    "code": "function shortestWhiteDistancesSum(H, W, blackSquares) {\n    const MOD = 1000000007;\n    const totalCells = H * W;\n    const whites = new Set();\n    \n    // Filling the set with white squares\n    for (let i = 0; i < H; i++) {\n        for (let j = 0; j < W; j++) {\n            whites.add(`${i},${j}`);\n        }\n    }\n    // Remove black squares from whites set\n    for (const [x, y] of blackSquares) {\n        whites.delete(`${x},${y}`);\n    }\n\n    const whiteCoordinates = Array.from(whites).map(c => c.split(',').map(Number));\n    const numWhite = whiteCoordinates.length;\n    \n    let distanceSum = 0;\n\n    // Function to compute Manhattan distance\n    function manhattanDistance(x1, y1, x2, y2) {\n        return Math.abs(x1 - x2) + Math.abs(y1 - y2);\n    }\n\n    // Calculate sum of shortest distances between all pairs of white squares\n    for (let i = 0; i < numWhite; i++) {\n        for (let j = i + 1; j < numWhite; j++) {\n            const [x1, y1] = whiteCoordinates[i];\n            const [x2, y2] = whiteCoordinates[j];\n            const distance = manhattanDistance(x1, y1, x2, y2);\n            distanceSum = (distanceSum + distance) % MOD;\n        }\n    }\n\n    return distanceSum;\n}",
    "timestamp": "2025-08-13 13:57:14"
  },
  {
    "model": "claude-3-5-haiku-20241022",
    "prompt_type": "zero_shot",
    "language": "python",
    "code": "from itertools import combinations\nfrom heapq import heappush, heappop\n\ndef shortest_white_square_distances(H, W, black_squares):\n    # Create grid and mark black squares\n    grid = [[False] * W for _ in range(H)]\n    for x, y in black_squares:\n        grid[x][y] = True\n\n    # Find white squares\n    white_squares = [(x, y) for x in range(H) for y in range(W) if not grid[x][y]]\n\n    # Calculate pairwise distances using BFS\n    total_distance = 0\n    MOD = 10**9 + 7\n\n    for (x1, y1), (x2, y2) in combinations(white_squares, 2):\n        distance = bfs(grid, x1, y1, x2, y2)\n        total_distance = (total_distance + distance) % MOD\n\n    return total_distance\n\ndef bfs(grid, x1, y1, x2, y2):\n    H, W = len(grid), len(grid[0])\n    directions = [(0, 1), (0, -1), (1, 0), (-1, 0)]\n    \n    visited = [[False] * W for _ in range(H)]\n    queue = [(0, x1, y1)]\n    visited[x1][y1] = True\n\n    while queue:\n        dist, x, y = heappop(queue)\n        \n        if x == x2 and y == y2:\n            return dist\n\n        for dx, dy in directions:\n            nx, ny = x + dx, y + dy\n            if 0 <= nx < H and 0 <= ny < W and not grid[nx][ny] and not visited[nx][ny]:\n                visited[nx][ny] = True\n                heappush(queue, (dist + 1, nx, ny))\n\n    return -1  # No path found",
    "timestamp": "2025-08-13 13:57:22"
  },
  {
    "model": "claude-3-5-haiku-20241022",
    "prompt_type": "zero_shot",
    "language": "js",
    "code": "function shortestDistanceBetweenWhiteSquares(H, W, blackSquares) {\n    const blackSet = new Set(blackSquares.map(square => `${square[0]},${square[1]}`));\n    const whiteSquares = [];\n\n    for (let x = 0; x < H; x++) {\n        for (let y = 0; y < W; y++) {\n            if (!blackSet.has(`${x},${y}`)) {\n                whiteSquares.push([x, y]);\n            }\n        }\n    }\n\n    let totalDistance = 0;\n    const MOD = 1000000007;\n\n    for (let i = 0; i < whiteSquares.length; i++) {\n        for (let j = i + 1; j < whiteSquares.length; j++) {\n            const [x1, y1] = whiteSquares[i];\n            const [x2, y2] = whiteSquares[j];\n            const distance = Math.abs(x1 - x2) + Math.abs(y1 - y2);\n            totalDistance = (totalDistance + distance) % MOD;\n        }\n    }\n\n    return totalDistance;\n}",
    "timestamp": "2025-08-13 13:57:28"
  },
  {
    "model": "deepseek-v3",
    "prompt_type": "zero_shot",
    "language": "python",
    "code": "import sys\nfrom collections import deque\n\nMOD = 10**9 + 7\n\ndef solve():\n    H, W = map(int, sys.stdin.readline().split())\n    N = int(sys.stdin.readline())\n    black = set()\n    for _ in range(N):\n        x, y = map(int, sys.stdin.readline().split())\n        black.add((x-1, y-1))  # converting to 0-based\n    \n    # Directions: up, down, left, right\n    directions = [(-1, 0), (1, 0), (0, -1), (0, 1)]\n    \n    total = 0\n    visited = [[-1 for _ in range(W)] for __ in range(H)]\n    q = deque()\n    \n    # Initialize BFS with all white cells\n    white_count = H * W - N\n    if white_count < 2:\n        print(0)\n        return\n    \n    sum_dist = [[0 for _ in range(W)] for __ in range(H)]\n    count = [[0 for _ in range(W)] for __ in range(H)]\n    \n    for i in range(H):\n        for j in range(W):\n            if (i, j) not in black:\n                q.append((i, j))\n                visited[i][j] = 0\n                count[i][j] = 1\n    \n    while q:\n        x, y = q.popleft()\n        for dx, dy in directions:\n            nx, ny = x + dx, y + dy\n            if 0 <= nx < H and 0 <= ny < W:\n                if visited[nx][ny] == -1:\n                    visited[nx][ny] = visited[x][y] + 1\n                    sum_dist[nx][ny] = sum_dist[x][y] + count[x][y]\n                    count[nx][ny] = count[x][y]\n                    q.append((nx, ny))\n                elif visited[nx][ny] == visited[x][y] + 1:\n                    sum_dist[nx][ny] = (sum_dist[nx][ny] + sum_dist[x][y] + count[x][y]) % MOD\n                    count[nx][ny] = (count[nx][ny] + count[x][y]) % MOD\n    \n    total_sum = 0\n    for i in range(H):\n        for j in range(W):\n            if (i, j) not in black:\n                total_sum = (total_sum + sum_dist[i][j]) % MOD\n    \n    # Each pair is counted twice (u->v and v->u), so divide by 2\n    # Since we are working modulo MOD, multiply by inverse of 2 mod MOD\n    inv_two = (MOD + 1) // 2\n    total_sum = (total_sum * inv_two) % MOD\n    print(total_sum)\n\nsolve()",
    "timestamp": "2025-08-13 13:57:46"
  },
  {
    "model": "deepseek-v3",
    "prompt_type": "zero_shot",
    "language": "js",
    "code": "const MOD = 1e9 + 7;\n\nfunction solve(H, W, N, blackSquares) {\n    const isBlack = Array.from({ length: H }, () => Array(W).fill(false));\n    for (const [x, y] of blackSquares) {\n        isBlack[x][y] = true;\n    }\n\n    const whiteSquares = [];\n    for (let i = 0; i < H; i++) {\n        for (let j = 0; j < W; j++) {\n            if (!isBlack[i][j]) {\n                whiteSquares.push([i, j]);\n            }\n        }\n    }\n    const M = whiteSquares.length;\n    if (M < 2) return 0;\n\n    let total = 0;\n    for (let i = 0; i < M; i++) {\n        const [x1, y1] = whiteSquares[i];\n        for (let j = i + 1; j < M; j++) {\n            const [x2, y2] = whiteSquares[j];\n            const dx = Math.abs(x1 - x2);\n            const dy = Math.abs(y1 - y2);\n            total = (total + dx + dy) % MOD;\n        }\n    }\n    return total;\n}\n\n// Example usage:\n// const H = 2, W = 3, N = 1;\n// const blackSquares = [[0, 1]];\n// console.log(solve(H, W, N, blackSquares));",
    "timestamp": "2025-08-13 13:57:57"
  },
  {
    "model": "gpt-4o",
    "prompt_type": "zero_shot",
    "language": "c++",
    "code": "#include <iostream>\n#include <vector>\n#include <queue>\n#include <algorithm>\n\nusing namespace std;\n\nconst int MOD = 1000000007;\nconst int INF = 1000000000;\n\nint directions[4][2] = {{1, 0}, {-1, 0}, {0, 1}, {0, -1}};\n\nint H, W, N;\nvector<vector<int>> grid;\n\n// Function to check if a position is within bounds and not blocked\nbool isValid(int x, int y) {\n    return x >= 0 && x < H && y >= 0 && y < W && grid[x][y] == 0;\n}\n\n// BFS to calculate distances from the starting point to all other points\nvector<vector<int>> bfs(int startX, int startY) {\n    vector<vector<int>> dist(H, vector<int>(W, INF));\n    queue<pair<int, int>> q;\n    dist[startX][startY] = 0;\n    q.push({startX, startY});\n    \n    while (!q.empty()) {\n        auto [x, y] = q.front();\n        q.pop();\n        \n        for (auto &[dx, dy] : directions) {\n            int nx = x + dx, ny = y + dy;\n            if (isValid(nx, ny) && dist[nx][ny] == INF) {\n                dist[nx][ny] = dist[x][y] + 1;\n                q.push({nx, ny});\n            }\n        }\n    }\n    \n    return dist;\n}\n\n// Main function to calculate the sum of distances between all pairs of white squares\nlong long calculateSumOfDistances() {\n    long long totalSum = 0;\n    \n    for (int x = 0; x < H; ++x) {\n        for (int y = 0; y < W; ++y) {\n            if (grid[x][y] == 0) { // If the square is white\n                vector<vector<int>> distances = bfs(x, y);\n                \n                for (int i = 0; i < H; ++i) {\n                    for (int j = 0; j < W; ++j) {\n                        if (grid[i][j] == 0 && distances[i][j] != INF) {\n                            totalSum = (totalSum + distances[i][j]) % MOD;\n                        }\n                    }\n                }\n            }\n        }\n    }\n\n    // Since each pair is counted twice, divide the total sum by 2\n    totalSum = (totalSum * (MOD + 1) / 2) % MOD;\n\n    return totalSum;\n}\n\nint main() {\n    cin >> H >> W >> N;\n    grid.assign(H, vector<int>(W, 0));\n\n    for (int i = 0; i < N; ++i) {\n        int x, y;\n        cin >> x >> y;\n        grid[x][y] = 1; // Paint the square black\n    }\n\n    cout << calculateSumOfDistances() << endl;\n    \n    return 0;\n}",
    "timestamp": "2025-08-13 14:41:49"
  }
]