[
  {
    "language": "C++",
    "code": "#include<bits/stdc++.h>\nusing namespace std;\n\nvector<int> rights;\nint n, l, m;\nstring s;\n\nvector<int> conv(vector<int> a, vector<int> b) {\n    vector<int> ret(m);\n    for (int i = 0; i < m; ++i) {\n        ret[i] = a[b[i]];\n    }\n    return ret;\n}\n\nvector<int> dubl(vector<int> a, int times) {\n    vector<int> ret(m);\n    vector<int> dbs(m);\n    for (int i = 0; i < m; ++i) {\n        ret[i] = i;\n        dbs[i] = a[i];\n    }\n    for (int i = 0; (1 << i) <= times; ++i) {\n        if ((times >> i) & 1) {\n            ret = conv(ret, dbs);\n        }\n        dbs = conv(dbs, dbs);\n    }\n    return ret;\n}\n\nvector<int> dfs(int lef, int rig) {\n    vector<int> ret(m);\n    for (int i = 0; i < m; ++i) {\n        ret[i] = i;\n    }\n    if (rights[lef] < rig) {\n        int p = lef;\n        while (p < rig) {\n            ret = conv(ret, dfs(p, rights[p]));\n            p = rights[p];\n        }\n        return ret;\n    }\n    if (s[lef] == '(') {\n        int j = rig - 1;\n        for (; '0' <= s[j] && s[j] <= '9'; --j);\n        int times = 0;\n        for (int i = j + 1; i < rig; ++i) {\n            times = times * 10 + s[i] - '0';\n        }\n        return dubl(dfs(lef + 1, j), times);\n    }\n    int idx = 0;\n    for (int i = lef + 1; i < rig; ++i) {\n        idx = idx * 10 + s[i] - '0';\n    }\n    --idx;\n    if (s[lef] == 'R') {\n        for (int i = 0; i < n; ++i) {\n            --ret[idx * n + i];\n        }\n        ret[idx * n] += n;\n    }\n    if (s[lef] == 'L') {\n        for (int i = 0; i < n; ++i) {\n            ++ret[idx * n + i];\n        }\n        ret[idx * n + n - 1] -= n;\n    }\n    if (s[lef] == 'D') {\n        for (int i = 0; i < n; ++i) {\n            ret[i * n + idx] -= n;\n        }\n        ret[idx] += n * n;\n    }\n    if (s[lef] == 'U') {\n        for (int i = 0; i < n; ++i) {\n            ret[i * n + idx] += n;\n        }\n        ret[(n - 1) * n + idx] -= n * n;\n    }\n    return ret;\n}\n\n\nint main() {\n    cin >> n >> l >> s;\n    m = n * n;\n    rights.resize(l, -1);\n    for (int i = 0; i < l; ++i) {\n        if (('0' <= s[i] && s[i] <= '9') || s[i] == ')') continue;\n        if (s[i] == '(') {\n            int dep = 0;\n            for (int j = i; j < l; ++j) {\n                if (s[j] == '(') ++dep;\n                if (s[j] == ')') --dep;\n\n                if (dep == 0) {\n                    for (int k = j + 1; k < l; ++k) {\n                        if ('0' > s[k] || '9' < s[k]) {\n                            rights[i] = k;\n                            goto A;\n                        }\n                    }\n                    rights[i] = l;\n                }\n            }\n        }\n        else {\n            for (int j = i + 1; j < l; ++j) {\n                if ('0' > s[j] || '9' < s[j]) {\n                    rights[i] = j;\n                    goto A;\n                }\n            }\n            rights[i] = l;\n        }\n        A:\n        continue;\n    }\n    vector<int> ret = dfs(0, l);\n    for (int i = 0; i < n; ++i) {\n        for (int j = 0; j < n; ++j) {\n            int k = i * n + j;\n            if (j < n - 1)\n                cout << ret[k] + 1 << \" \";\n            else\n                cout << ret[k] + 1 << \"\\n\";\n        }\n    }\n\n    return 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\n#define GET_MACRO(_1,_2,_3,_4,_5,NAME,...) NAME\n#define pr(...) GET_MACRO(__VA_ARGS__,pr5,pr4,pr3,pr2,pr1)(__VA_ARGS__)\n#define pr1(a) (#a)<<\"=\"<<(a)\n#define pr2(a,b) pr1(a)<<\", \"<<pr1(b)\n#define pr3(a,b,c) pr2(a,b)<<\", \"<<pr1(c)\n#define pr4(a,b,c,d) pr3(a,b,c)<<\", \"<<pr1(d)\n#define pr5(a,b,c,d,e) pr4(a,b,c,d)<<\", \"<<pr1(e)\n#define int long long\n#define double long double\nusing namespace std;\nconst int N = 100010;\nconst int INF = 1LL<<55;\nconst int mod = (1e9)+7;\nconst double EPS = 1e-8;\nconst double PI = 6.0 * asin(0.5);\ntypedef pair<int,int> P;\ntypedef long long ll;\ntemplate<class T> T Max(T &a,T b){return a=max(a,b);}\ntemplate<class T> T Min(T &a,T b){return a=min(a,b);}\n//ostream& operator<<(ostream& o,P p){return o<<\"(\"<<p.first<<\",\"<<p.second<<\")\";}\n//istream& operator>>(istream& i,P &p){return i>>p.first>>p.second;}\n//ostream& operator<<(ostream& o,vector<auto> &a){int i=0;for(auto t:a)o<<(i++?\" \":\"\")<<t;return o;}\n//istream& operator>>(istream& i,vector<auto> &a){for(auto &t:a)i>>t;return i;}\n//void prArr(auto a,string s=\" \"){int i=0;for(auto t:a)cout<<(i++?s:\"\")<<t;cout<<endl;}\n\ntypedef vector<int> vec;\ntypedef vector<vec> mat;\n\nmat move(mat a,mat b){\n  int n = a.size();\n  mat res(n,vec(n));\n\n  assert(a.size() == b.size());\n  assert(a[0].size() == b[0].size());\n  assert(a[0].size() == a.size());\n  \n  for(int i=0;i<n;i++)\n    for(int j=0;j<n;j++) {\n      int y = a[i][j] / n;\n      int x = a[i][j] % n;\n      res[i][j] = b[y][x];\n    }\n  return res;\n}\n\nint n,len;\nint pos;\nstring str;\n\nmat bfs();\nmat repeat();\nint number();\n  \nmat repeat(){\n  assert(str[pos] == '(');\n  pos++;\n  mat x = bfs();\n  assert(str[pos]==')');\n  pos++;\n  int num = number();\n  \n  mat res(n,vec(n));\n  for(int i=0;i<n;i++)\n    for(int j=0;j<n;j++) res[i][j] = i * n + j;\n\n  while(num){\n    if(num%2) res = move(res,x);\n    x = move(x,x);\n    num = num/2;\n  }\n  return res;\n}\n\nint number(){\n  assert(isdigit(str[pos]));\n  int res = 0;\n  while(pos < (int)str.size() && isdigit(str[pos])) res = res * 10 + str[pos] - '0', pos++;\n  return res;\n}\n\nvoid L(mat &A){\n  assert(str[pos++] == 'L');\n  int k = number() - 1;\n  for(int i=0;i<n-1;i++) swap(A[k][i],A[k][i+1]);\n}\n\nvoid R(mat &A){\n  assert(str[pos++] == 'R');\n  int k = number() - 1;\n  for(int i=0;i<n-1;i++) swap(A[k][n-1-i],A[k][n-2-i]);\n};\n\nmat U(mat &A){\n  assert(str[pos++] == 'U');\n  int k = number() - 1;\n  for(int i=0;i<n-1;i++) swap(A[i][k],A[i+1][k]);\n};\nmat D(mat &A){\n  assert(str[pos++] == 'D');\n  int k = number() - 1;\n  for(int i=0;i<n-1;i++) swap(A[n-1-i][k],A[n-2-i][k]);\n};\n\nmat bfs(){\n  mat res(n,vec(n));\n  for(int i=0;i<n;i++)\n    for(int j=0;j<n;j++) res[i][j] = i*n + j;\n  \n  while(pos < (int)str.size()){\n    char ch = str[pos];\n    if(ch == '(') res = repeat();\n    else if(ch == 'L') L(res);\n    else if(ch == 'R') R(res);\n    else if(ch == 'U') U(res);\n    else if(ch == 'D') D(res);\n    else break;\n  }\n  return res;\n}\n\nsigned main(){\n  int L;\n  cin>>n>>L;\n  cin>>str;\n  str+='$';\n  \n  mat ans = bfs();\n  for(int i=0;i<n;i++)\n    for(int j=0;j<n;j++) ans[i][j] ++;\n  \n  for(int i=0;i<n;i++) {\n    for(int j=0;j<n;j++){\n      if(j) cout<<\" \";\n      cout<<ans[i][j];\n    }\n    cout<<endl;\n  }\n  \n  return 0;\n}\n\n"
  },
  {
    "language": "C++",
    "code": "#include <iostream>\n#include <string>\n#include <vector>\nusing namespace std;\n\nint N, L; string S;\n\nstruct State { vector<vector<int>>v; };\n\nState Initialize(int H, int W) {\n\tState S; S.v = vector<vector<int>>(H, vector<int>(W, 0));\n\tfor (int i = 0; i < H; i++) {\n\t\tfor (int j = 0; j < W; j++) S.v[i][j] = i*W + j;\n\t}\n\treturn S;\n}\nState Add(State A, State B) {\n\tState S = A;\n\tfor (int i = 0; i < N; i++) {\n\t\tfor (int j = 0; j < N; j++) {\n\t\t\tint xx = B.v[i][j], x = xx / N, y = xx%N;\n\t\t\tS.v[i][j] = A.v[x][y];\n\t\t}\n\t}\n\treturn S;\n}\nState Multiple(State A, long long x) {\n\tState B = A, C = Initialize(N, N);\n\tfor (int i = 0; i < 30; i++) {\n\t\tif ((x / (1 << i)) % 2 == 1) { C = Add(C, B); }\n\t\tB = Add(B, B);\n\t}\n\treturn C;\n}\nState parse(string S) {\n\tvector<string>vec; string T = \"\"; bool J = false; int depth = 0;\n\tfor (int i = 0; i < S.size(); i++) {\n\t\tT += S[i];\n\t\tif (i == S.size() - 1 || (depth == 0 && S[i] >= '0' && S[i] <= '9' && (S[i + 1] == '(' || S[i + 1] == 'L' || S[i + 1] == 'R' || S[i + 1] == 'U' || S[i + 1] == 'D'))) {\n\t\t\tvec.push_back(T); T = \"\";\n\t\t}\n\t\tif (S[i] == '(' || S[i] == ')') J = true;\n\t\tif (S[i] == '(') depth++;\n\t\tif (S[i] == ')') depth--;\n\t}\n\tif (vec.size() == 1 && J == false) {\n\t\t// 1 回のケース\n\t\tchar F = vec[0][0]; string Y = vec[0]; int R = stoi(Y.substr(1, Y.size() - 1));\n\t\t\n\t\tState V = Initialize(N, N);\n\t\tif (F == 'L') {\n\t\t\tvector<int>b(N, 0);\n\t\t\tfor (int i = 0; i < N; i++) b[(i + N - 1) % N] = V.v[R - 1][i];\n\t\t\tfor (int i = 0; i < N; i++) V.v[R - 1][i] = b[i];\n\t\t}\n\t\tif (F == 'R') {\n\t\t\tvector<int>b(N, 0);\n\t\t\tfor (int i = 0; i < N; i++) b[(i + 1) % N] = V.v[R - 1][i];\n\t\t\tfor (int i = 0; i < N; i++) V.v[R - 1][i] = b[i];\n\t\t}\n\t\tif (F == 'U') {\n\t\t\tvector<int>b(N, 0);\n\t\t\tfor (int i = 0; i < N; i++) b[(i + N - 1) % N] = V.v[i][R - 1];\n\t\t\tfor (int i = 0; i < N; i++) V.v[i][R - 1] = b[i];\n\t\t}\n\t\tif (F == 'D') {\n\t\t\tvector<int>b(N, 0);\n\t\t\tfor (int i = 0; i < N; i++) b[(i + 1) % N] = V.v[i][R - 1];\n\t\t\tfor (int i = 0; i < N; i++) V.v[i][R - 1] = b[i];\n\t\t}\n\t\treturn V;\n\t}\n\tif (vec.size() == 1 && J == true) {\n\t\t// 繰り返し\n\t\tstring U = vec[0]; int lx = 0, rx = 0, depth2 = 0;\n\t\tfor (int i = 0; i < U.size(); i++) {\n\t\t\tif (U[i] == '(') {\n\t\t\t\tif (depth == 0) lx = i;\n\t\t\t\tdepth++;\n\t\t\t}\n\t\t\tif (U[i] == ')') {\n\t\t\t\tdepth--;\n\t\t\t\tif (depth == 0) rx = i;\n\t\t\t}\n\t\t}\n\t\tstring V1 = U.substr(lx + 1, rx - lx - 1);\n\t\tstring V2 = U.substr(rx + 1, U.size() - (rx + 1));\n\t\tint V3 = stoi(V2);\n\t\tState V0 = parse(V1);\n\t\tState V = Multiple(V0, V3);\n\t\treturn V;\n\t}\n\tif (vec.size() != 1) {\n\t\t// 複数に分かれているやつ\n\t\tState V = Initialize(N, N);\n\t\tfor (int i = 0; i < vec.size(); i++) {\n\t\t\tState F = parse(vec[i]);\n\t\t\tV = Add(V, F);\n\t\t}\n\t\treturn V;\n\t}\n}\n\nint main() {\n\tcin >> N >> L >> S;\n\tState G = parse(S);\n\tfor (int i = 0; i < N; i++) {\n\t\tfor (int j = 0; j < N; j++) { if (j)cout << \" \"; cout << G.v[i][j] + 1; }\n\t\tcout << endl;\n\t}\n\treturn 0;\n}\n"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\nusing namespace std;\n\n#define rep(i,x,y) for(int i=(x);i<(y);++i)\n#define debug(x) #x << \"=\" << (x)\n\n#ifdef DEBUG\n#define _GLIBCXX_DEBUG\n#define print(x) std::cerr << debug(x) << \" (L:\" << __LINE__ << \")\" << std::endl\n#else\n#define print(x)\n#endif\n\nconst int inf=1e9;\nconst int64_t inf64=1e18;\nconst double eps=1e-9;\n\ntemplate <typename T> ostream &operator<<(ostream &os, const vector<T> &vec){\n    os << \"[\";\n    for (const auto &v : vec) {\n    \tos << v << \",\";\n    }\n    os << \"]\";\n    return os;\n}\n\ntypedef string::const_iterator state;\nclass parse_error{};\nvector<vector<int>> matrix;\nint n,l;\nstring s;\n\nvoid consume(state &begin,char expected){\n    if(*begin==expected) ++begin;\n    else{\n        cerr << \"Exptected '\" << expected << \"' but got '\" << *begin << \"'\" << endl;\n        cerr << \"Rest string is'\";\n        while(*begin) cerr << *begin++;\n        cerr << \"'\" << endl;\n        throw parse_error();\n    }\n}\n\nvoid sequence(state&);\nvoid repetition(state&);\nvoid operation(state&);\nint number(state&);\n\nvoid sequence(state &begin){\n    while(*begin){\n        if(*begin=='(') repetition(begin);\n        else if(*begin=='U' or *begin=='D' or *begin=='L' or *begin=='R') operation(begin);\n        else break;\n    }\n}\n\nvoid repetition(state &begin){\n    consume(begin,'(');\n    auto backup1=begin;\n    int depth=1;\n    while(depth){\n        if(*begin=='(') ++depth;\n        if(*begin==')') --depth;\n        ++begin;\n    }\n    --begin;\n    consume(begin,')');\n    int num=number(begin);\n    auto backup2=begin;\n    rep(i,0,num){\n        begin=backup1;\n        sequence(begin);\n    }\n    begin=backup2;\n}\n\nvoid operation(state &begin){\n    char d=*begin;\n    ++begin;\n    int num=number(begin);\n    if(d=='L') rotate(matrix[num-1].begin(),matrix[num-1].begin()+1,matrix[num-1].end());\n    if(d=='R') rotate(matrix[num-1].rbegin(),matrix[num-1].rbegin()+1,matrix[num-1].rend());\n    if(d=='U'){\n        vector<int> v;\n        rep(i,0,n) v.push_back(matrix[i][num-1]);\n        rotate(v.begin(),v.begin()+1,v.end());\n        rep(i,0,n) matrix[i][num-1]=v[i];\n    }\n    if(d=='D'){\n        vector<int> v;\n        rep(i,0,n) v.push_back(matrix[i][num-1]);\n        rotate(v.rbegin(),v.rbegin()+1,v.rend());\n        rep(i,0,n) matrix[i][num-1]=v[i];\n    }\n}\n\nint number(state &begin){\n    int res=0;\n    while(isdigit(*begin)){\n        res*=10;\n        res+=*begin-'0';\n        ++begin;\n    }\n    return res;\n}\n\nvoid solve(){\n    cin >> n >> l >> s;\n    matrix.resize(n);\n    rep(i,0,n){\n        matrix[i].resize(n);\n        rep(j,0,n) matrix[i][j]=i*n+j;\n    }\n    state begin=s.begin();\n    sequence(begin);\n    rep(i,0,n){\n        rep(j,0,n){\n            cout << matrix[i][j]+1;\n            if(j!=n-1) cout << \" \";\n        }\n        cout << endl;\n    }\n}\n\nint main(){\n    std::cin.tie(0);\n    std::ios::sync_with_stdio(false);\n    cout.setf(ios::fixed);\n    cout.precision(10);\n    solve();\n    return 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\n#define GET_MACRO(_1,_2,_3,_4,_5,NAME,...) NAME\n#define pr(...) GET_MACRO(__VA_ARGS__,pr5,pr4,pr3,pr2,pr1)(__VA_ARGS__)\n#define pr1(a) (#a)<<\"=\"<<(a)\n#define pr2(a,b) pr1(a)<<\", \"<<pr1(b)\n#define pr3(a,b,c) pr2(a,b)<<\", \"<<pr1(c)\n#define pr4(a,b,c,d) pr3(a,b,c)<<\", \"<<pr1(d)\n#define pr5(a,b,c,d,e) pr4(a,b,c,d)<<\", \"<<pr1(e)\n#define int long long\n#define double long double\nusing namespace std;\nconst int N = 100010;\nconst int INF = 1LL<<55;\nconst int mod = (1e9)+7;\nconst double EPS = 1e-8;\nconst double PI = 6.0 * asin(0.5);\ntypedef pair<int,int> P;\ntypedef long long ll;\ntemplate<class T> T Max(T &a,T b){return a=max(a,b);}\ntemplate<class T> T Min(T &a,T b){return a=min(a,b);}\nostream& operator<<(ostream& o,P p){return o<<\"(\"<<p.first<<\",\"<<p.second<<\")\";}\nistream& operator>>(istream& i,P &p){return i>>p.first>>p.second;}\nostream& operator<<(ostream& o,vector<auto> &a){int i=0;for(auto t:a)o<<(i++?\" \":\"\")<<t;return o;}\nistream& operator>>(istream& i,vector<auto> &a){for(auto &t:a)i>>t;return i;}\nvoid prArr(auto a,string s=\" \"){int i=0;for(auto t:a)cout<<(i++?s:\"\")<<t;cout<<endl;}\n\ntypedef vector<int> vec;\ntypedef vector<vec> mat;\n\nmat move(mat a,mat b){\n  int n = a.size();\n  mat res(n,vec(n));\n\n  for(int i=0;i<n;i++)\n    for(int j=0;j<n;j++) {\n      int y = a[i][j] / n;\n      int x = a[i][j] % n;\n      res[i][j] = b[y][x];\n    }\n  return res;\n}\n\nint n,len;\nint pos;\nstring str;\n\nmat bfs();\nmat repeat();\nint number();\n  \nmat repeat(){\n  assert(str[pos] == '(');\n  pos++;\n  mat x = bfs();\n  assert(str[pos]==')');\n  pos++;\n  int num = number();\n  \n  mat res(n,vec(n));\n  for(int i=0;i<n;i++)\n    for(int j=0;j<n;j++) res[i][j] = i * n + j;\n\n  while(num){\n    if(num%2) res = move(res,x);\n    x = move(x,x);\n    num = num/2;\n  }\n  return res;\n}\n\nint number(){\n  assert(isdigit(str[pos]));\n  int res = 0;\n  while(isdigit(str[pos])) res = res * 10 + str[pos] - '0', pos++;\n  return res;\n}\n\nvoid L(mat &A){\n  assert(str[pos++] == 'L');\n  int k = number() - 1;\n  for(int i=0;i<n-1;i++) swap(A[k][i],A[k][i+1]);\n}\n\nvoid R(mat &A){\n  assert(str[pos++] == 'R');\n  int k = number() - 1;\n  for(int i=0;i<n-1;i++) swap(A[k][n-1-i],A[k][n-2-i]);\n};\n\nmat U(mat &A){\n  assert(str[pos++] == 'U');\n  int k = number() - 1;\n  for(int i=0;i<n-1;i++) swap(A[i][k],A[i+1][k]);\n};\nmat D(mat &A){\n  assert(str[pos++] == 'D');\n  int k = number() - 1;\n  for(int i=0;i<n-1;i++) swap(A[n-1-i][k],A[n-2-i][k]);\n};\n\nmat bfs(){\n  mat res(n,vec(n));\n  for(int i=0;i<n;i++)\n    for(int j=0;j<n;j++) res[i][j] = i*n + j;\n  \n  while(pos < (int)str.size()){\n    char ch = str[pos];\n    if(ch == '(') res = repeat();\n    else if(ch == 'L') L(res);\n    else if(ch == 'R') R(res);\n    else if(ch == 'U') U(res);\n    else if(ch == 'D') D(res);\n    else break;\n  }\n  return res;\n}\n\nsigned main(){\n  int L;\n  cin>>n>>L;\n  cin>>str;\n  \n  mat ans = bfs();\n  for(int i=0;i<n;i++)\n    for(int j=0;j<n;j++) ans[i][j] ++;\n  for(int i=0;i<n;i++) cout<<ans[i]<<endl;\n  \n  return 0;\n}\n\n"
  },
  {
    "language": "C++",
    "code": "#include \"bits/stdc++.h\"\n\n#define REP(i,n) for(ll i=0;i<n;++i)\n#define RREP(i,n) for(ll i=n-1;i>=0;--i)\n#define FOR(i,m,n) for(ll i=m;i<n;++i)\n#define RFOR(i,m,n) for(ll i=n-1;i>=m;--i)\n#define ALL(v) (v).begin(),(v).end()\n#define PB(a) push_back(a)\n#define UNIQUE(v) v.erase(unique(ALL(v)),v.end());\n#define DUMP(v) REP(aa, (v).size()) { cout << v[a]; if (a != v.size() - 1)cout << \" \"; else cout << endl; }\n#define INF 1000000001ll\n#define MOD 1000000007ll\n#define EPS 1e-9\n\nconst int dx[8] = { 1,1,0,-1,-1,-1,0,1 };\nconst int dy[8] = { 0,1,1,1,0,-1,-1,-1 };\n\n\nusing namespace std;\ntypedef long long ll;\ntypedef vector<int> vi;\ntypedef vector<ll> vl;\ntypedef vector<vi> vvi;\ntypedef vector<vl> vvl;\ntypedef pair<int, int> pii;\ntypedef pair<ll, ll> pll;\nll max(ll a, int b) { return max(a, ll(b)); }\nll max(int a, ll b) { return max(ll(a), b); }\nll min(ll a, int b) { return min(a, ll(b)); }\nll min(int a, ll b) { return min(ll(a), b); }\n///(?´????????`)(?´????????`)(?´????????`)(?´????????`)(?´????????`)(?´????????`)///\nvvi id();\nint num(int &);\nvvi seq(int &);\nvvi rep(int &);\nvvi operation(int &);\nstring s;\nint n, l;\nint num(int &i) {\n\tint ret = 0;\n\twhile (i < l&&isdigit(s[i])) {\n\t\tret *= 10;\n\t\tret += s[i] - '0';\n\t\t++i;\n\t}\n\treturn ret;\n}\n\nvvi operation(int &i) {\n\tchar c = s[i];\n\t++i;\n\tint a = num(i);\n\tvvi ret(n, vi(n));\n\tREP(k, n) {\n\t\tREP(j, n) {\n\t\t\tret[k][j] = k*n + j;\n\t\t}\n\t}\n\tif (c == 'R') {\n\t\tREP(k, n - 1) {\n\t\t\tret[a - 1][k + 1] = (a - 1)*n + k;\n\t\t}\n\t\tret[a - 1][0] = (a - 1)*n + n - 1;\n\t}\n\telse if (c == 'L') {\n\t\tREP(k, n - 1) {\n\t\t\tret[a - 1][k] = (a - 1)*n + k + 1;\n\t\t}\n\t\tret[a - 1][n - 1] = (a - 1)*n;\n\t}\n\telse if (c == 'D') {\n\t\tREP(k, n - 1) {\n\t\t\tret[k + 1][a - 1] = k*n + a - 1;\n\t\t}\n\t\tret[0][a - 1] = (n-1)*n+a-1;\n\t}\n\telse if (c == 'U') {\n\t\tREP(k, n - 1) {\n\t\t\tret[k][a - 1] = (k + 1)*n + a - 1;\n\t\t}\n\t\tret[n - 1][a - 1] = a-1;\n\t}\n\treturn ret;\n}\n\nvvi con(vvi b, vvi a) {\n\tvvi ret(n, vi(n));\n\tREP(i, n) {\n\t\tREP(j, n) {\n\t\t\tint c = a[i][j];\n\t\t\tint e = c%n, d = c / n;\n\t\t\tint f = b[d][e];\n\t\t\tret[i][j] = f;\n\t\t}\n\t}\n\treturn ret;\n}\n\nvvi rep(int &i) {\n\t++i;\n\tvvi ret = seq(i);\n\t++i;\n\tint a = num(i);\n\tint c = ceil(log2(a));\n\tvector<vvi> x(c+1);\n\tx[0] = ret;\n\tint j = 0;\n\tREP(k, c) {\n\t\tx[k + 1] = con(x[k], x[k]);\n\t}\n\tvvi ans = id();\n\t//cout << a <<\" \"<<c<< endl;\n\tREP(k, c+1) {\n\t\tif (a&(1 << k)) {\n\t\t\tans = con(ans, x[k]);\n\t\t\tj += (1 << k);\n\t\t}\n\t\t\n\t}\n\t//cout << j << endl;\n\treturn ans;\n}\nvvi seq(int &i) {\n\tif (i == l || s[i] == ')') {\n\t\treturn id();\n\t}\n\tvvi a;\n\tif (s[i] == '(') {\n\t\ta = rep(i);\n\t}\n\telse {\n\t\ta = operation(i);\n\t}\n\tvvi ret = con(a, seq(i));\n\treturn ret;\n}\nvvi id() {\n\tvvi a(n, vi(n));\n\tREP(i, n) {\n\t\tREP(j, n) {\n\t\t\ta[i][j] = i*n + j;\n\t\t}\n\t}\n\treturn a;\n}\nint main() {\n\tcin.tie(0);\n\tios::sync_with_stdio(false);\n\n\tcin >> n >> l;\n\tcin >> s;\n\tint i = 0;\n\tvvi a = seq(i);\n\tREP(k, n) {\n\t\tREP(j, n) {\n\t\t\tcout << a[k][j] + 1;\n\t\t\tif (j != n - 1)cout << \" \";\n\t\t\telse cout << endl;\n\t\t}\n\t}\n\n\treturn 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\nusing namespace std;\ntypedef vector<int> vec;\nint n,len,pos;\nstring s;\n \nvec mul(vec a,vec b){\n  vec res(n*n);\n  for(int i=0;i<n*n;i++)res[i]=b[a[i]];\n  return res;\n}\n \nvec mpow(vec a,int t){\n  if(t==0){\n    vec res(n*n);\n    for(int i=0;i<n*n;i++)res[i]=i;\n    return res;\n  }  \n  vec res=mpow(mul(a,a),t/2);\n  if(t%2==1)res=mul(res,a);\n  return res;\n}\n \nvec calc();\n \nvec getNum(){\n \n  if(s[pos]=='('){\n    pos++;\n    vec res=calc();\n    \n    int num=0;\n    while(pos<len&&'0'<=s[pos]&&s[pos]<='9')\n      num=num*10+s[pos++]-'0';\n    vec Ra= mpow(res,num);\n    return Ra;\n  }\n  \n  char ch=s[pos++];\n  int num=0;\n  while(pos<len&&'0'<=s[pos]&&s[pos]<='9'){\n    num=num*10+s[pos]-'0';\n    pos++;\n  }\n  \n  vec res(n*n);  \n  for(int i=0;i<n;i++){\n    for(int j=0;j<n;j++){\n      int ni=i,nj=j;\n      if(ch=='D'&&j+1==num){\n        ni=(i+1)%n;\n        nj=j;\n      }else if(ch=='L'&&i+1==num){\n        ni=i;\n        nj=(j+n-1)%n;\n      }else if(ch=='U'&&j+1==num){\n        ni=(i+n-1)%n;\n        nj=j;\n      }else if(ch=='R'&&i+1==num){\n        ni=i;\n        nj=(j+1)%n;\n      }\n      res[i*n+j]=ni*n+nj;\n    }\n  }\n  return res;\n}\n \nint C=0;\nvec calc(){\n  vec res=getNum();\n  \n  while(pos<len){\n    if(s[pos]==')'){\n      pos++;\n      break;\n    }\n    vec num=getNum();\n    res=mul(res,num);\n  }\n  return res;\n}\n \nint main() {\n  while(cin>>n>>len) {\n    cin>>s;\n    pos=0;\n    vec ans(n*n),ans2=calc();\n    for(int i=0;i<n*n;i++){\n      ans[ ans2[i]]=i;\n    }\n    for(int i=0;i<n;i++){\n      for(int j=0;j<n;j++){\n        if(j)cout<<' ';\n        cout<<ans[i*n+j]+1;\n      }\n      cout<<endl;\n    }\n  }\n  return 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\nusing namespace std;\n\n#define rep(i,x,y) for(int i=(x);i<(y);++i)\n#define debug(x) #x << \"=\" << (x)\n\n#ifdef DEBUG\n#define _GLIBCXX_DEBUG\n#define print(x) std::cerr << debug(x) << \" (L:\" << __LINE__ << \")\" << std::endl\n#else\n#define print(x)\n#endif\n\nconst int inf=1e9;\nconst int64_t inf64=1e18;\nconst double eps=1e-9;\n\ntemplate <typename T> ostream &operator<<(ostream &os, const vector<T> &vec){\n    os << \"[\";\n    for (const auto &v : vec) {\n    \tos << v << \",\";\n    }\n    os << \"]\";\n    return os;\n}\n\ntypedef string::const_iterator state;\nclass parse_error{};\nvector<vector<int>> matrix;\nint n,l;\nstring s;\n\nvoid consume(state &begin,char expected){\n    if(*begin==expected) ++begin;\n    else{\n        cerr << \"Exptected '\" << expected << \"' but got '\" << *begin << \"'\" << endl;\n        cerr << \"Rest string is'\";\n        while(*begin) cerr << *begin++;\n        cerr << \"'\" << endl;\n        throw parse_error();\n    }\n}\n\nvoid sequence(state&);\nvoid repetition(state&);\nvoid operation(state&);\nint number(state&);\n\nvoid sequence(state &begin){\n    while(*begin){\n        if(*begin=='(') repetition(begin);\n        else operation(begin);\n    }\n}\n\nvoid repetition(state &begin){\n    consume(begin,'(');\n    auto backup1=begin;\n    int depth=1;\n    while(depth){\n        if(*begin=='(') ++depth;\n        if(*begin==')') --depth;\n        ++begin;\n    }\n    --begin;\n    consume(begin,')');\n    int num=number(begin);\n    auto backup2=begin;\n    rep(i,0,num){\n        begin=backup1;\n        sequence(begin);\n    }\n    begin=backup2;\n}\n\nvoid operation(state &begin){\n    char d=*begin;\n    ++begin;\n    int num=number(begin);\n    if(d=='L') rotate(matrix[num-1].begin(),matrix[num-1].begin()+1,matrix[num-1].end());\n    if(d=='R') rotate(matrix[num-1].rbegin(),matrix[num-1].rbegin()+1,matrix[num-1].rend());\n    if(d=='U'){\n        vector<int> v;\n        rep(i,0,n) v.push_back(matrix[i][num-1]);\n        rotate(v.begin(),v.begin()+1,v.end());\n        rep(i,0,n) matrix[i][num-1]=v[i];\n    }\n    if(d=='D'){\n        vector<int> v;\n        rep(i,0,n) v.push_back(matrix[i][num-1]);\n        rotate(v.rbegin(),v.rbegin()+1,v.rend());\n        rep(i,0,n) matrix[i][num-1]=v[i];\n    }\n}\n\nint number(state &begin){\n    int res=0;\n    while(isdigit(*begin)){\n        res*=10;\n        res+=*begin-'0';\n        ++begin;\n    }\n    return res;\n}\n\nvoid solve(){\n    cin >> n >> l >> s;\n    matrix.resize(n);\n    rep(i,0,n){\n        matrix[i].resize(n);\n        rep(j,0,n) matrix[i][j]=i*n+j;\n    }\n    state begin=s.begin();\n    sequence(begin);\n    rep(i,0,n){\n        rep(j,0,n){\n            cout << matrix[i][j]+1;\n            if(j!=n-1) cout << \" \";\n        }\n        cout << endl;\n    }\n}\n\nint main(){\n    std::cin.tie(0);\n    std::ios::sync_with_stdio(false);\n    cout.setf(ios::fixed);\n    cout.precision(10);\n    solve();\n    return 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\nusing namespace std;\n\n#define rep(i,x,y) for(int i=(x);i<(y);++i)\n#define debug(x) #x << \"=\" << (x)\n\n#ifdef DEBUG\n#define _GLIBCXX_DEBUG\n#define print(x) std::cerr << debug(x) << \" (L:\" << __LINE__ << \")\" << std::endl\n#else\n#define print(x)\n#endif\n\nconst int inf=1e9;\nconst int64_t inf64=1e18;\nconst double eps=1e-9;\n\ntemplate <typename T> ostream &operator<<(ostream &os, const vector<T> &vec){\n    os << \"[\";\n    for (const auto &v : vec) {\n    \tos << v << \",\";\n    }\n    os << \"]\";\n    return os;\n}\n\ntypedef string::const_iterator state;\ntypedef vector<vector<int>> my_matrix;\nclass parse_error{};\nmy_matrix matrix;\nint n,l;\nstring s;\n\nvoid consume(state &begin,char expected){\n    if(*begin==expected) ++begin;\n    else{\n        cerr << \"Exptected '\" << expected << \"' but got '\" << *begin << \"'\" << endl;\n        cerr << \"Rest string is'\";\n        while(*begin) cerr << *begin++;\n        cerr << \"'\" << endl;\n        throw parse_error();\n    }\n}\n\nvoid sequence(state&);\nvoid repetition(state&);\nvoid operation(state&);\nint number(state&);\n\nvoid sequence(state &begin){\n    while(*begin){\n        if(*begin=='(') repetition(begin);\n        else if(*begin=='U' or *begin=='D' or *begin=='L' or *begin=='R') operation(begin);\n        else break;\n    }\n}\n\nvoid repetition(state &begin){\n    consume(begin,'(');\n    const auto backup1=begin;\n    int depth=1;\n    while(depth){\n        if(*begin=='(') ++depth;\n        if(*begin==')') --depth;\n        ++begin;\n    }\n    --begin;\n    consume(begin,')');\n    int num=number(begin);\n    const auto backup2=begin;\n\n    const auto prev_matrix=matrix;\n    rep(i,0,n) rep(j,0,n) matrix[i][j]=i*n+j;\n\n    begin=backup1;\n    sequence(begin);\n\n    vector<vector<int>> perm(n,vector<int>(n)),v(n,vector<int>(n));\n    rep(i,0,n) rep(j,0,n) perm[matrix[i][j]/n][matrix[i][j]%n]=v[i][j]=i*n+j;\n\n    while(num>0){\n        if(num&1) rep(i,0,n) rep(j,0,n) v[i][j]=perm[v[i][j]/n][v[i][j]%n];\n        const auto prev_perm=perm;\n        rep(i,0,n) rep(j,0,n) perm[i][j]=prev_perm[perm[i][j]/n][perm[i][j]%n];\n        num>>=1;\n    }\n    rep(i,0,n) rep(j,0,n) matrix[v[i][j]/n][v[i][j]%n]=prev_matrix[i][j];\n\n    begin=backup2;\n}\n\nvoid operation(state &begin){\n    char d=*begin;\n    ++begin;\n    int num=number(begin);\n    if(d=='L'){\n        int prev=matrix[num-1][0];\n        rep(i,0,n-1) matrix[num-1][i]=matrix[num-1][i+1];\n        matrix[num-1][n-1]=prev;\n    }\n    if(d=='R'){\n        int prev=matrix[num-1][n-1];\n        for(int i=n-1; i>=1; --i) matrix[num-1][i]=matrix[num-1][i-1];\n        matrix[num-1][0]=prev;\n    }\n    if(d=='U'){\n        int prev=matrix[0][num-1];\n        rep(i,0,n-1) matrix[i][num-1]=matrix[i+1][num-1];\n        matrix[n-1][num-1]=prev;\n    }\n    if(d=='D'){\n        int prev=matrix[n-1][num-1];\n        for(int i=n-1; i>=1; --i) matrix[i][num-1]=matrix[i-1][num-1];\n        matrix[0][num-1]=prev;\n    }\n}\n\nint number(state &begin){\n    int res=0;\n    while(isdigit(*begin)){\n        res*=10;\n        res+=*begin-'0';\n        ++begin;\n    }\n    return res;\n}\n\nvoid solve(){\n    cin >> n >> l >> s;\n    matrix.resize(n);\n    rep(i,0,n){\n        matrix[i].resize(n);\n        rep(j,0,n) matrix[i][j]=i*n+j;\n    }\n    state begin=s.begin();\n    sequence(begin);\n    rep(i,0,n){\n        rep(j,0,n){\n            cout << matrix[i][j]+1;\n            if(j!=n-1) cout << \" \";\n        }\n        cout << endl;\n    }\n}\n\nint main(){\n    std::cin.tie(0);\n    std::ios::sync_with_stdio(false);\n    cout.setf(ios::fixed);\n    cout.precision(10);\n    solve();\n    return 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\n \n#define _overload(_1,_2,_3,name,...) name\n#define _rep(i,n) _range(i,0,n)\n#define _range(i,a,b) for(int i=(int)(a);i<(int)(b);++i)\n#define rep(...) _overload(__VA_ARGS__,_range,_rep,)(__VA_ARGS__)\n \n#define _rrep(i,n) _rrange(i,n,0)\n#define _rrange(i,a,b) for(int i=(int)(a)-1;i>=(int)(b);--i)\n#define rrep(...) _overload(__VA_ARGS__,_rrange,_rrep,)(__VA_ARGS__)\n \n#define _all(arg) begin(arg),end(arg)\n#define uniq(arg) sort(_all(arg)),(arg).erase(unique(_all(arg)),end(arg))\n#define getidx(ary,key) lower_bound(_all(ary),key)-begin(ary)\n#define clr(a,b) memset((a),(b),sizeof(a))\n#define bit(n) (1LL<<(n))\n \n// #define DEBUG\n \n#ifdef DEBUG\n    #define dump(...) fprintf(stderr, __VA_ARGS__)\n#else\n    #define dump(...)\n#endif\n \ntemplate<class T>bool chmax(T &a, const T &b) { return (a<b)?(a=b,1):0;}\ntemplate<class T>bool chmin(T &a, const T &b) { return (b<a)?(a=b,1):0;}\n \nusing namespace std;\nusing ll=long long;\nusing vi=vector<int>;\nusing vll=vector<ll>;\n \nconst double EPS = 1e-10;\nconst double PI = acos(-1.0);\nconst ll inf =1LL << 62;\nconst ll mod=1000000007LL;\nconst int dx[4]={1,0,-1,0};\nconst int dy[4]={0,1,0,-1};\n \n \nll extgcd(ll a,ll b,ll& x,ll& y){x=1,y=0;ll g=a;if(b!=0) g=extgcd(b,a%b,y,x),y-=a/b*x;return g;}\nll ADD(const ll &a, const ll &b,const ll &mod) { return (a+b)%mod;}\nll SUB(const ll &a, const ll &b,const ll &mod) { return (a-b+mod)%mod;}\nll MUL(const ll &a, const ll &b,const ll &mod) { return (1LL*a*b)%mod;}\nll DIV(const ll &a, const ll &b,const ll &mod) {ll x,y; extgcd(b,mod,x,y);return MUL(a,(x+mod)%mod,mod);}\n \nrandom_device rd;\nmt19937 mt(rd());\nuniform_int_distribution<int> dice(1,6);\nuniform_real_distribution<double> score(0.0,10.0);\n\nint n;\nint len;\nint idx;\nstring in;\n\nvoid Print(vi& tbl){\n    rep(i, n){\n        rep(j, n){\n            cerr << tbl[i * n + j] << \" \";\n        }\n        cerr << endl;\n    }\n    cerr << \"-----\" << endl;\n}\n\nvoid calc(vi& tbl, vi& dst){\n    vi ndst = dst;\n    rep(i, n * n){\n        ndst[i] = dst[tbl[i]];\n    }\n    dst = ndst;\n}\n\nvoid power(vi& tbl, int m, vi& dst){\n    vi cur = tbl;\n    while(m >= 1){\n        if(m % 2 == 1){\n            calc(cur, dst);\n        }\n        calc(cur, cur);\n        m /= 2;\n    }\n}\n\nvoid operate(char op, int k, vi& dst){\n    k--;\n    vi tbl(n * n);\n    rep(i, n * n) tbl[i] = i;\n\n    int tmp;\n    switch(op){\n        case 'L': \n            tmp = tbl[k * n];\n            rep(i, n - 1){\n                tbl[k * n + i] = tbl[k * n + i + 1];\n            }\n            tbl[(k + 1) * n - 1] = tmp;\n            break;\n        case 'R': \n            tmp = tbl[(k + 1) * n - 1];\n            rrep(i, n, 1){\n                tbl[k * n + i] = tbl[k * n + i - 1];\n            }\n            tbl[k * n] = tmp;\n            break;\n        case 'U':\n            tmp = tbl[k];\n            rep(i, n - 1){\n                tbl[n * i + k] = tbl[n * (i + 1) + k];\n            }\n            tbl[n * (n - 1) + k] = tmp;\n            break;\n        case 'D':\n            tmp = tbl[n * (n - 1) + k];\n            rrep(i, n, 1){\n                tbl[n * i + k] = tbl[n * (i - 1) + k];\n            }\n            tbl[k] = tmp;\n            break;\n        default:\n            assert(false);\n            break;\n    }\n\n    power(tbl, 1, dst);\n}\n\nvi parse(){\n    vi ret(n * n);\n    rep(i, n * n) ret[i] = i;\n\n    while(idx < len){\n        if(in[idx] == ')'){\n            break;\n        }\n        else if(in[idx] == '('){\n            assert(in[idx++] == '(');\n            vi tbl = parse();\n            assert(in[idx++] == ')');\n\n            int times = 0;\n            while(isdigit(in[idx])){\n                times = 10 * times + (int)(in[idx] - '0');\n                idx++;\n            }\n            power(tbl, times, ret);\n            Print(tbl);\n        }\n        else {\n            char op = in[idx]; idx++;\n            int  k  = 0;\n            while(isdigit(in[idx])){\n                k = 10 * k + (int)(in[idx] - '0');\n                idx++;\n            }\n            operate(op, k, ret);\n            Print(ret);\n        }\n    }\n\n    return ret;\n}\n\nint main(void){\n    cin.tie(0);\n    ios::sync_with_stdio(false);\n\n    cin >> n >> len;\n    cin >> in;\n    if(in[0] != '(') in = \"(\" + in + \")1\";\n\n    auto tbl = parse();\n\n    vi res(n * n);\n    rep(i, n * n){\n        res[i] = i + 1;\n    }\n    calc(tbl, res);\n\n    rep(i, n){\n        rep(j, n){\n            cout << (j ? \" \":\"\") << res[i * n + j];\n        }\n        cout << endl;\n    }\n\n    return 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\nusing namespace std;\n\nusing VI = vector<int>;\nusing VVI = vector<VI>;\nusing PII = pair<int, int>;\nusing LL = long long;\nusing VL = vector<LL>;\nusing VVL = vector<VL>;\nusing PLL = pair<LL, LL>;\nusing VS = vector<string>;\n\n#define ALL(a)  begin((a)),end((a))\n#define RALL(a) (a).rbegin(), (a).rend()\n#define PB push_back\n#define EB emplace_back\n#define MP make_pair\n#define SZ(a) int((a).size())\n#define SORT(c) sort(ALL((c)))\n#define RSORT(c) sort(RALL((c)))\n#define UNIQ(c) (c).erase(unique(ALL((c))), end((c)))\n\n#define FOR(i,a,b) for(int i=(a);i<(b);++i)\n#define REP(i,n)  FOR(i,0,n)\n\n#define FF first\n#define SS second\ntemplate<class S, class T>\nistream& operator>>(istream& is, pair<S,T>& p){\n  return is >> p.FF >> p.SS;\n}\ntemplate<class S, class T>\nostream& operator<<(ostream& os, const pair<S,T>& p){\n  return os << p.FF << \" \" << p.SS;\n}\ntemplate<class T>\nvoid maxi(T& x, T y){\n  if(x < y) x = y;\n}\ntemplate<class T>\nvoid mini(T& x, T y){\n  if(x > y) x = y;\n}\n\n\nconst double EPS = 1e-10;\nconst double PI  = acos(-1.0);\nconst LL MOD = 1e9+7;\n\nVL seq(int&,string&);\nVL rep(int&,string&);\nVL op(int&,string&);\nLL number(int&,string&);\n\nint N;\nVL comp(const VL& f1, const VL& f2){\n  VL res(N*N);\n  REP(i,N*N) res[i] = f2[f1[i]];\n  return res;\n}\n\nVL seq(int& i, string& s){\n  VL res(N*N);\n  REP(i,N*N) res[i] = i;\n\n  while(i < SZ(s)){\n\tVL tmp;\n\tif(s[i] == '('){\n\t  tmp = rep(i, s);\n\t}\n\telse if(string(\"UDLR\").find(s[i]) != string::npos){\n\t  tmp = op(i, s);\n\t}\n\telse{\n\t  break;\n\t}\n\tres = comp(res, tmp);\n  }\n  return res;\n}\nVL rep(int& i, string& s){\n  ++i;\n  VL tmp = seq(i, s);\n  ++i;\n  LL n = number(i, s);\n\n  VL res(N*N);\n  REP(i,N*N) res[i] = i;\n  while(n>0){\n\tif(n&1)\n\t  res = comp(res, tmp);\n\ttmp = comp(tmp, tmp);\n\tn >>= 1;\n  }\n\n  return res;\n}\nVL op(int& i, string& s){\n  char c = s[i];\n  ++i;\n  LL n = number(i, s);\n  --n;\n\n  VL res(N*N);\n  REP(i,N*N) res[i] = i;\n  switch(c){\n  case 'R':\n\tREP(i,N-1) res[n*N+i] = n*N+i+1;\n\tres[n*N+N-1] = n*N;\n\tbreak;\n  case 'L':\n\tREP(i,N-1) res[n*N+i+1] = n*N+i;\n\tres[n*N] = n*N + N-1;\n\tbreak;\n  case 'U':\n\tREP(i,N-1) res[(i+1)*N+n] = i*N+n;\n\tres[n] = (N-1)*N + n;\n\tbreak;\n  case 'D':\n\tREP(i,N-1) res[i*N+n] = (i+1)*N+n;\n\tres[(N-1)*N+n] = n;\n\tbreak;\n  }\n\n  return res;\n}\nLL number(int& i, string& s){\n  LL n = 0;\n  while(i < SZ(s) && '0' <= s[i] && s[i] <= '9'){\n\tn = n*10 + s[i] - '0';\n\t++i;\n  }\n  return n;\n}\n\nint main(){\n  cin.tie(0);\n  ios_base::sync_with_stdio(false);\n\n  int L;\n  cin >> N >> L;\n  string S;\n  cin >> S;\n  int i = 0;\n  VL rot = seq(i, S);\n  VVI ans(N, VI(N));\n  REP(i,N*N){\n\tint tx = rot[i] % N, ty = rot[i] / N;\n\tans[ty][tx] = i+1;\n  }\n\n  REP(y,N){\n\tREP(x,N) cout << (x?\" \":\"\") << ans[y][x];\n\tcout << endl;\n  }\n  \n  return 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\nusing namespace std;\nusing ll = long long;\n#define rep(i,n) for(int (i)=0;(i)<(int)(n);++(i))\n#define all(x) (x).begin(),(x).end()\n#define pb push_back\n#define fi first\n#define se second\n#define dbg(x) cout<<#x\" = \"<<((x))<<endl\ntemplate<class T,class U> ostream& operator<<(ostream& o, const pair<T,U> &p){o<<\"(\"<<p.fi<<\",\"<<p.se<<\")\";return o;}\ntemplate<class T> ostream& operator<<(ostream& o, const vector<T> &v){o<<\"[\";for(T t:v){o<<t<<\",\";}o<<\"]\";return o;}\n\nint n,L;\nstring s;\n\nvector<int> merge(const vector<int> &f, const vector<int> &g){\n    vector<int> h(n*n);\n    rep(i,n*n) h[i] = g[f[i]];\n    return h;\n}\n\nvector<int> pow(const vector<int> &f, int p){\n    vector<int> g(f);\n\n    vector<int> ret(n*n);\n    iota(all(ret),0);\n\n    while(p){\n        if(p&1) ret = merge(ret, g);\n        g = merge(g,g);\n        p >>= 1;\n    }\n    return ret;\n}\n\nint number(int &idx){\n    int ret = 0;\n    while(idx<L && isdigit(s[idx])){\n        ret = ret*10 + (s[idx]-'0');\n        ++idx;\n    }\n    return ret;\n}\n\nvector<int> sequence(int &idx);\nvector<int> repetition(int &idx);\nvector<int> operation(int &idx);\n\nvector<int> sequence(int &idx){\n    vector<int> f(n*n);\n    iota(all(f), 0);\n\n    if(idx < L && s[idx] != ')'){\n        if(s[idx] == '(') f = merge(f, repetition(idx));\n        else f = merge(f, operation(idx));\n    }\n\n    return f;\n}\n\nvector<int> repetition(int &idx){\n    ++idx;\n    vector<int> f = sequence(idx);\n\n    assert(s[idx]==')');\n    ++idx;\n\n    int num = number(idx);\n    return merge(pow(f, num), sequence(idx));\n}\n\nvector<int> operation(int &idx){\n    char op = s[idx];\n    ++idx;\n    int num = number(idx);\n    --num;\n\n    vector<int> f(n*n);\n    iota(all(f), 0);\n\n    if(op == 'R'){\n        int v = f[num*n];\n        for(int i=1; i<n; ++i) f[num*n + i-1] = f[num*n + i];\n        f[num*n + n-1] = v;\n    }\n    else if(op == 'L'){\n        int v = f[num*n + n-1];\n        for(int i=n-1; i>0; --i) f[num*n + i] = f[num*n + i-1];\n        f[num*n] = v;\n    }\n    else if(op == 'D'){\n        int v = f[num];\n        rep(i,n-1) f[i*n + num] = f[(i+1)*n + num];\n        f[(n-1)*n + num] = v;\n    }\n    else if(op == 'U'){\n        int v = f[(n-1)*n + num];\n        for(int i=n-1; i>0; --i) f[i*n + num] = f[(i-1)*n + num];\n        f[num] = v;\n    }\n    else assert(false);\n\n    return merge(f, sequence(idx));\n}\n\nint main(){\n    cin >>n >>L >>s;\n\n    int idx = 0;\n    vector<int> f = sequence(idx);\n\n    vector<vector<int>> a(n, vector<int>(n));\n    rep(i,n*n){\n        int pos = f[i];\n        a[pos/n][pos%n] = i+1;\n    }\n\n    rep(i,n){\n        rep(j,n) printf(\"%d%c\", a[i][j], \" \\n\"[j==n-1]);\n    }\n\n    return 0;\n}\n\n"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\n#define GET_MACRO(_1,_2,_3,_4,_5,NAME,...) NAME\n#define pr(...) GET_MACRO(__VA_ARGS__,pr5,pr4,pr3,pr2,pr1)(__VA_ARGS__)\n#define pr1(a) (#a)<<\"=\"<<(a)\n#define pr2(a,b) pr1(a)<<\", \"<<pr1(b)\n#define pr3(a,b,c) pr2(a,b)<<\", \"<<pr1(c)\n#define pr4(a,b,c,d) pr3(a,b,c)<<\", \"<<pr1(d)\n#define pr5(a,b,c,d,e) pr4(a,b,c,d)<<\", \"<<pr1(e)\n#define int long long\n#define double long double\nusing namespace std;\nconst int N = 100010;\nconst int INF = 1LL<<55;\nconst int mod = (1e9)+7;\nconst double EPS = 1e-8;\nconst double PI = 6.0 * asin(0.5);\ntypedef pair<int,int> P;\ntypedef long long ll;\ntemplate<class T> T Max(T &a,T b){return a=max(a,b);}\ntemplate<class T> T Min(T &a,T b){return a=min(a,b);}\n//ostream& operator<<(ostream& o,P p){return o<<\"(\"<<p.first<<\",\"<<p.second<<\")\";}\n//istream& operator>>(istream& i,P &p){return i>>p.first>>p.second;}\n//ostream& operator<<(ostream& o,vector<auto> &a){int i=0;for(auto t:a)o<<(i++?\" \":\"\")<<t;return o;}\n//istream& operator>>(istream& i,vector<auto> &a){for(auto &t:a)i>>t;return i;}\n//void prArr(auto a,string s=\" \"){int i=0;for(auto t:a)cout<<(i++?s:\"\")<<t;cout<<endl;}\n\ntypedef vector<int> vec;\ntypedef vector<vec> mat;\n\nmat move(mat a,mat b){\n  int n = a.size();\n  mat res(n,vec(n));\n\n  assert(a.size() == b.size());\n  assert(a[0].size() == b[0].size());\n  assert(a[0].size() == a.size());\n  \n  for(int i=0;i<n;i++)\n    for(int j=0;j<n;j++) {\n      int y = a[i][j] / n;\n      int x = a[i][j] % n;\n      assert(y < (int)b.size() && x < (int)b[y].size());\n      \n      res[i][j] = b[y][x];\n    }\n  return res;\n}\n\nint n;\nint pos;\nstring str;\n\nmat bfs();\nmat repeat();\nint number();\n  \nmat repeat(){\n  assert(str[pos] == '(');\n  pos++;\n  mat x = bfs();\n  assert(str[pos]==')');\n  pos++;\n  int num = number();\n  \n  mat res(n,vec(n));\n  for(int i=0;i<n;i++)\n    for(int j=0;j<n;j++) res[i][j] = i * n + j;\n\n  while(num){\n    if(num%2) res = move(res,x);\n    x = move(x,x);\n    num /= 2;\n  }\n  return res;\n}\n\nint number(){\n  assert(isdigit(str[pos]));\n  int res = 0;\n  while(pos < (int)str.size() && isdigit(str[pos])) res = res * 10 + str[pos++] - '0';\n  return res;\n}\n\nvoid L(mat &A){\n  assert(str[pos++] == 'L');\n  int k = number() - 1;\n  for(int i=0;i<n-1;i++) swap(A[k][i],A[k][i+1]);\n}\n\nvoid R(mat &A){\n  assert(str[pos++] == 'R');\n  int k = number() - 1;\n  for(int i=0;i<n-1;i++) swap(A[k][n-1-i],A[k][n-2-i]);\n};\n\nmat U(mat &A){\n  assert(str[pos++] == 'U');\n  int k = number() - 1;\n  for(int i=0;i<n-1;i++) swap(A[i][k],A[i+1][k]);\n};\n\nmat D(mat &A){\n  assert(str[pos++] == 'D');\n  int k = number() - 1;\n  for(int i=0;i<n-1;i++) swap(A[n-1-i][k],A[n-2-i][k]);\n};\n\nmat bfs(){\n  mat res(n,vec(n));\n  for(int i=0;i<n;i++)\n    for(int j=0;j<n;j++) res[i][j] = i*n + j;\n  \n  while(pos < (int)str.size()){\n    char ch = str[pos];\n    if(ch == '(') res = repeat();\n    else if(ch == 'L') L(res);\n    else if(ch == 'R') R(res);\n    else if(ch == 'U') U(res);\n    else if(ch == 'D') D(res);\n    else break;\n  }\n  return res;\n}\n\nsigned main(){\n  int L;\n  cin>>n>>L;\n  cin>>str;\n  str+=\"$$$$$$$$$$$$$\";\n  \n  mat ans = bfs();\n  for(int i=0;i<n;i++)\n    for(int j=0;j<n;j++) ans[i][j] ++;\n  \n  for(int i=0;i<n;i++) {\n    for(int j=0;j<n;j++){\n      if(j) cout<<\" \";\n      cout<<ans[i][j];\n    }\n    cout<<endl;\n  }\n  \n  return 0;\n}\n\n"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\n\nusing namespace std;\n\n#define int long long\n#define all(v) begin(v), end(v)\n#define rep(i, n) for(int i = 0; i < (int)(n); i++)\n#define reps(i, s, n) for(int i = (int)(s); i < (int)(n); i++)\n\ntemplate<class T1, class T2> void chmin(T1 &a, T2 b){if(a>b)a=b;}\ntemplate<class T1, class T2> void chmax(T1 &a, T2 b){if(a<b)a=b;}\n\nusing pint = pair<int, int>;\nusing tint = tuple<int, int, int>;\nusing vint = vector<int>;\nusing mat = vector<vint>;\n\nconst int inf = 1LL << 55;\nconst int mod = 1e9 + 7;\n\nstring ope = \"LRUD\";\n\nint N, L;\nstring S;\n\nint idx = 0;\n\nmat mat_calc(mat);\nmat mat_rept(mat);\n\nmat mat_init() {\n  mat res(N, vector<int>(N));\n  rep(i, N) rep(j, N) res[i][j] = N*i+j;\n  return res;\n}\n\nvoid mat_print(mat mtrx) {\n  rep(i, N) rep(j, N) cout << mtrx[i][j]+1 << (j==N-1 ? '\\n' : ' ');\n}\n\nint getNum() {\n  int res = 0;\n  for(; idx < L && isdigit(S[idx]); idx++) res = res*10 + (S[idx]-'0');\n  return res;\n}\n\nmat mat_shift(mat mtrx) {\n  char shift = S[idx++];\n  int num = getNum(); num--;\n  if(shift == 'L') {\n    int tmp = mtrx[num][0];\n    for(int j = 0; j < N-1; j++) mtrx[num][j] = mtrx[num][j+1];\n    mtrx[num][N-1] = tmp;\n  } else if(shift == 'R') {\n    int tmp = mtrx[num][N-1];\n    for(int j = N-1; j > 0; j--) mtrx[num][j] = mtrx[num][j-1];\n    mtrx[num][0] = tmp;\n  } else if(shift == 'U') {\n    int tmp = mtrx[0][num];\n    for(int j = 0; j < N-1; j++) mtrx[j][num] = mtrx[j+1][num];\n    mtrx[N-1][num] = tmp;\n  } else if(shift == 'D') {\n    int tmp = mtrx[N-1][num];\n    for(int j = N-1; j > 0; j--) mtrx[j][num] = mtrx[j-1][num];\n    mtrx[0][num] = tmp;\n  } else {\n    assert(false);\n  }\n  return mtrx;\n}\n\nmat mat_calc(mat mtrx) {\n  if(ope.find(S[idx]) != string::npos) mtrx = mat_shift(mtrx);\n  else if(S[idx] == '(') mtrx = mat_rept(mtrx);\n  else assert(false);\n  return mtrx;\n}\n\nmat mat_rept(mat mtrx) {\n  idx++; // (\n  mat res = mat_init();\n  mat tmp = mat_init();\n  while(S[idx] != ')') tmp = mat_calc(tmp);\n  idx++; // )\n  int num = getNum();\n  for(int i = 0; (num>>i); i++) {\n    if((num>>i)&1) {\n      rep(i, N) rep(j, N) res[i][j] = tmp[res[i][j]/N][res[i][j]%N];\n    }\n    mat tmp2 = tmp;\n    rep(i, N) rep(j, N) tmp[i][j] = tmp2[tmp[i][j]/N][tmp[i][j]%N];\n  }\n  mat tmp3 = mtrx;\n  rep(i, N) rep(j, N) mtrx[i][j] = tmp3[res[i][j]/N][res[i][j]%N];\n\n  return mtrx;\n}\n\nsigned main()\n{\n  cin.tie(0);\n  ios_base::sync_with_stdio(0);\n  cout << fixed << setprecision(12);\n\n  cin >> N >> L >> S;\n  mat mtrx = mat_init();\n  while(idx < L) mtrx = mat_calc(mtrx);\n  mat_print(mtrx);\n\n  return 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\n#define GET_MACRO(_1,_2,_3,_4,_5,NAME,...) NAME\n#define pr(...) GET_MACRO(__VA_ARGS__,pr5,pr4,pr3,pr2,pr1)(__VA_ARGS__)\n#define pr1(a) (#a)<<\"=\"<<(a)\n#define pr2(a,b) pr1(a)<<\", \"<<pr1(b)\n#define pr3(a,b,c) pr2(a,b)<<\", \"<<pr1(c)\n#define pr4(a,b,c,d) pr3(a,b,c)<<\", \"<<pr1(d)\n#define pr5(a,b,c,d,e) pr4(a,b,c,d)<<\", \"<<pr1(e)\n#define int long long\n#define double long double\nusing namespace std;\nconst int N = 100010;\nconst int INF = 1LL<<55;\nconst int mod = (1e9)+7;\nconst double EPS = 1e-8;\nconst double PI = 6.0 * asin(0.5);\ntypedef pair<int,int> P;\ntypedef long long ll;\ntemplate<class T> T Max(T &a,T b){return a=max(a,b);}\ntemplate<class T> T Min(T &a,T b){return a=min(a,b);}\nostream& operator<<(ostream& o,P p){return o<<\"(\"<<p.first<<\",\"<<p.second<<\")\";}\nistream& operator>>(istream& i,P &p){return i>>p.first>>p.second;}\nostream& operator<<(ostream& o,vector<auto> &a){int i=0;for(auto t:a)o<<(i++?\" \":\"\")<<t;return o;}\nistream& operator>>(istream& i,vector<auto> &a){for(auto &t:a)i>>t;return i;}\nvoid prArr(auto a,string s=\" \"){int i=0;for(auto t:a)cout<<(i++?s:\"\")<<t;cout<<endl;}\n\ntypedef vector<int> vec;\ntypedef vector<vec> mat;\n\nmat move(const mat a,const mat b){\n  int n = a.size();\n  mat res(n,vec(n));\n\n  for(int i=0;i<n;i++)\n    for(int j=0;j<n;j++) {\n      int y = a[i][j] / n;\n      int x = a[i][j] % n;\n      res[i][j] = b[y][x];\n    }\n  return res;\n}\n\nint n;\nint pos;\nstring str;\nmat E;\n\nmat bnf(mat);\nint number();\n\nmat repeat(mat res){\n  assert(str[pos++] == '(');\n  mat x = bnf(E);\n  assert(str[pos++]==')');\n  \n  int num = number();\n  while(num){\n    if(num%2) res = move(res,x);\n    x = move(x,x);\n    num /= 2;\n  }\n  return res;\n}\n\nint number(){\n  assert(isdigit(str[pos]));\n\n  int res = 0;\n  while(pos < (int)str.size() && isdigit(str[pos])) res = res * 10 + str[pos++] - '0';\n  return res;\n}\n\nmat L(){\n  assert(str[pos++] == 'L');\n\n  mat res = E;\n  int k = number() - 1;\n  for(int i=0;i<n-1;i++) swap(res[k][n-1-i],res[k][n-2-i]);\n  return res;\n}\n\nmat R(){\n  assert(str[pos++] == 'R');\n\n  mat res = E;\n  int k = number() - 1;\n  for(int i=0;i<n-1;i++) swap(res[k][i],res[k][i+1]);\n  return res;\n};\n\nmat U(){\n  assert(str[pos++] == 'U');\n\n  mat res = E;\n  int k = number() - 1;\n  for(int i=0;i<n-1;i++) swap(res[n-1-i][k],res[n-2-i][k]);\n  return res;\n};\n\nmat D(){\n  assert(str[pos++] == 'D');\n\n  mat res = E;\n  int k = number() - 1;\n  for(int i=0;i<n-1;i++) swap(res[i][k],res[i+1][k]);\n  return res;\n};\n\nmat bnf(mat res){\n  while(pos < (int)str.size()){\n    char ch = str[pos];\n    if(ch == '(') res = repeat(res);\n    else if(ch == 'L') res = move(res,L());\n    else if(ch == 'R') res = move(res,R());\n    else if(ch == 'U') res = move(res,U());\n    else if(ch == 'D') res = move(res,D());\n    else break;\n  }\n  return res;\n}\n\nsigned main(){\n  int L;\n  cin>>n>>L;\n  cin>>str;\n\n  E = mat(n,vec(n));\n\n  for(int i=0;i<n;i++)\n    for(int j=0;j<n;j++) E[i][j] = i * n + j;\n\n  mat mv = bnf(E);\n\n  mat ans(n,vec(n));\n  for(int i=0;i<n;i++)\n    for(int j=0;j<n;j++) {\n      int x = mv[i][j]%n;\n      int y = mv[i][j]/n;\n      ans[y][x] = i * n + j;\n    }\n  \n  for(int i=0;i<n;i++)\n    for(int j=0;j<n;j++) ans[i][j] ++;\n  \n  for(int i=0;i<n;i++) cout<<ans[i]<<endl;\n  return 0;\n}\n\n"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\nusing namespace std;\n\nusing pii = pair<int, int>;\n\nint N;\n\nvector<vector<pii>> make_initial() {\n    vector<vector<pii>> res(N, vector<pii>(N));\n    for(int i = 0; i < N; ++i) {\n        for(int j = 0; j < N; ++j) {\n            res[i][j] = make_pair(i, j);\n        }\n    }\n    return res;\n}\n\nvector<vector<pii>> eval(vector<vector<pii>> const& A, vector<vector<pii>> const& x) {\n    auto res = A;\n    for(int i = 0; i < N; ++i) {\n        for(int j = 0; j < N; ++j) {\n            res[i][j] = A[x[i][j].first][x[i][j].second];\n        }\n    }\n    return res;\n}\n\nvector<vector<pii>> sequence(string const& s, int& p);\nvector<vector<pii>> repetition(string const& s, int& p);\nvector<vector<pii>> operation(string const& s, int& p);\nint number(string const& s, int& p);\n\nvector<vector<pii>> sequence(string const& s, int& p) {\n    auto res = make_initial();\n    while(p < s.size() && (s[p] == '(' || isalpha(s[p]))) {\n        vector<vector<pii>> f;\n        if(s[p] == '(') {\n            f = repetition(s, p);\n        } else if(isalpha(s[p])) {\n            f = operation(s, p);\n        } else {\n            cout << \"error pos: \" << p << endl;\n            assert(false); // error\n        }\n        res = eval(res, f);\n    }\n    return res;\n}\n\nvector<vector<pii>> repetition(string const& s, int& p) {\n    auto x = sequence(s, ++p);\n    ++p;\n    assert(isdigit(s[p]));\n    int n = number(s, p);\n    auto res = make_initial();\n    while(n > 0) {\n        if(n & 1) {\n            res = eval(res, x);\n        }\n        x = eval(x, x);\n        n >>= 1;\n    }\n    return res;\n}\n\nvector<vector<pii>> operation(string const& s, int& p) {\n    auto res = make_initial();\n    char op = s[p++];\n    int i = number(s, p) - 1;\n    if(op == 'L') {\n        for(int j = 0; j < N; ++j) {\n            res[i][j].second = (j + 1) % N;\n        }\n    } else if(op == 'R') {\n        for(int j = 0; j < N; ++j) {\n            res[i][j].second = (j - 1 + N) % N;\n        }\n    } else if(op == 'U') {\n        for(int j = 0; j < N; ++j) {\n            res[j][i].first = (j + 1) % N;\n        }\n    } else if(op == 'D') {\n        for(int j = 0; j < N; ++j) {\n            res[j][i].first = (j - 1 + N) % N;\n        }\n    } else {\n        assert(false);\n    }\n    return res;\n}\n\nint number(string const& s, int& p) {\n    int res = 0;\n    while(isdigit(s[p])) {\n        res *= 10;\n        res += (s[p++] - '0');\n    }\n    return res;\n}\n\nint main() {\n    int L;\n    string S;\n    cin >> N >> L >> S;\n    int p = 0;\n    auto ans = sequence(S, p);\n    for(int i = 0; i < N; ++i) {\n        for(int j = 0; j < N; ++j) {\n            cout << (ans[i][j].first * N + ans[i][j].second + 1) << \" \\n\"[j + 1 == N];\n        }\n    }\n}\n"
  },
  {
    "language": "C++",
    "code": "#include <stdio.h>\n#include <cmath>\n#include <algorithm>\n#include <cfloat>\n#include <stack>\n#include <queue>\n#include <vector>\n#include <string>\n#include <iostream>\n#include <set>\n#include <map>\n#include <time.h>\ntypedef long long int ll;\ntypedef unsigned long long int ull;\n#define BIG_NUM 2000000000\n#define MOD 1000000007\n#define EPS 0.000000001\nusing namespace std;\n\ntypedef vector<int> MATRIX;\n\nint N,SIZE,length;\nchar buf[1001];\n\nint getLoc(int row,int col){\n\treturn N*row+col;\n}\n\nMATRIX calc(MATRIX left,MATRIX next_loc){\n\n\tMATRIX ret(SIZE);\n\n\tfor(int i = 0; i < SIZE; i++){\n\t\tret[i] = left[next_loc[i]];\n\t}\n\n\treturn ret;\n\n}\n\nMATRIX pow(MATRIX next_loc,int count){\n\n\tMATRIX ret(SIZE);\n\n\tfor(int i = 0; i < SIZE; i++)ret[i] = i;\n\n\twhile(count > 0){\n\t\tif(count%2 == 1){\n\t\t\tret = calc(ret,next_loc);\n\t\t}\n\t\tnext_loc = calc(next_loc,next_loc);\n\t\tcount /= 2;\n\t}\n\n\treturn ret;\n}\n\n\nMATRIX calcNextLoc(int left,int right){\n\n\tMATRIX first_loc(SIZE),next_loc(SIZE),work(SIZE);\n\tfor(int i = 0; i < SIZE; i++)first_loc[i] = i;\n\n\tint index = left;\n\n\twhile(index <= right){\n\n\t\tif(buf[index] == '('){\n\n\t\t\tint depth = 0,next_right;\n\n\t\t\tfor(int i = index; i <= right; i++){\n\t\t\t\tif(buf[i] == '(')depth++;\n\t\t\t\telse if(buf[i] == ')'){\n\t\t\t\t\tdepth--;\n\t\t\t\t\tif(depth == 0){\n\t\t\t\t\t\tnext_right = i;\n\t\t\t\t\t\tbreak;\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t}\n\n\t\t\tnext_loc = calcNextLoc(index+1,next_right-1);\n\n\t\t\tint count = 0;\n\n\t\t\tfor(index = next_right+1;buf[index] >= '0' && buf[index] <= '9'; index++){\n\t\t\t\tcount = 10*count+buf[index]-'0';\n\t\t\t}\n\n\t\t\tif(count > 1){\n\t\t\t\tnext_loc = pow(next_loc,count);\n\t\t\t}\n\n\t\t\tfor(int i = 0; i < SIZE; i++)work[i] = first_loc[next_loc[i]];\n\t\t\tfor(int i = 0; i < SIZE; i++)first_loc[i] = work[i];\n\n\t\t}else{\n\n\t\t\tint next_right;\n\t\t\tfor(next_right = index; next_right <= right && buf[next_right] != '('; next_right++);\n\t\t\tnext_right--;\n\n\t\t\tint num,k;\n\n\t\t\tfor(int i = index; i <= next_right;){\n\n\t\t\t\tnum = 0;\n\t\t\t\tfor(k = i+1; buf[k] >= '0' && buf[k] <= '9'; k++){\n\t\t\t\t\tnum = 10*num+buf[k]-'0';\n\t\t\t\t}\n\n\t\t\t\tnum--;\n\n\t\t\t\tswitch(buf[i]){\n\t\t\t\tcase 'L':\n\n\t\t\t\t\twork[getLoc(num,N-1)] = first_loc[getLoc(num,0)];\n\n\t\t\t\t\tfor(int col = 1; col < N; col++){\n\t\t\t\t\t\twork[getLoc(num,col-1)] = first_loc[getLoc(num,col)];\n\t\t\t\t\t}\n\t\t\t\t\tfor(int col = 0; col < N; col++){\n\t\t\t\t\t\tfirst_loc[getLoc(num,col)] = work[getLoc(num,col)];\n\t\t\t\t\t}\n\n\t\t\t\t\tbreak;\n\t\t\t\tcase 'R':\n\n\t\t\t\t\twork[getLoc(num,0)] = first_loc[getLoc(num,N-1)];\n\n\t\t\t\t\tfor(int col = 0; col < N-1; col++){\n\t\t\t\t\t\twork[getLoc(num,col+1)] = first_loc[getLoc(num,col)];\n\t\t\t\t\t}\n\t\t\t\t\tfor(int col = 0; col < N; col++){\n\t\t\t\t\t\tfirst_loc[getLoc(num,col)] = work[getLoc(num,col)];\n\t\t\t\t\t}\n\n\t\t\t\t\tbreak;\n\t\t\t\tcase 'U':\n\n\t\t\t\t\twork[getLoc(N-1,num)] = first_loc[getLoc(0,num)];\n\n\t\t\t\t\tfor(int row = 1; row < N; row++){\n\t\t\t\t\t\twork[getLoc(row-1,num)] = first_loc[getLoc(row,num)];\n\t\t\t\t\t}\n\n\t\t\t\t\tfor(int row = 0; row < N; row++){\n\t\t\t\t\t\tfirst_loc[getLoc(row,num)] = work[getLoc(row,num)];\n\t\t\t\t\t}\n\n\t\t\t\t\tbreak;\n\t\t\t\tcase 'D':\n\n\t\t\t\t\twork[getLoc(0,num)] = first_loc[getLoc(N-1,num)];\n\n\t\t\t\t\tfor(int row = 0; row < N-1; row++){\n\t\t\t\t\t\twork[getLoc(row+1,num)] = first_loc[getLoc(row,num)];\n\t\t\t\t\t}\n\n\t\t\t\t\tfor(int row = 0; row < N; row++){\n\t\t\t\t\t\tfirst_loc[getLoc(row,num)] = work[getLoc(row,num)];\n\t\t\t\t\t}\n\n\t\t\t\t\tbreak;\n\t\t\t\t}\n\t\t\t\ti = k;\n\t\t\t}\n\n\t\t\tindex = next_right+1;\n\t\t\tfor(int i = 0; i < SIZE; i++){\n\t\t\t\twork[first_loc[i]] = i;\n\t\t\t}\n\n\t\t\tfor(int i = 0; i < SIZE; i++){\n\t\t\t\tfirst_loc[i] = work[i];\n\t\t\t}\n\t\t}\n\t}\n\treturn first_loc;\n}\n\n\nint main(){\n\n\tscanf(\"%d %d\",&N,&length);\n\tSIZE = N*N;\n\n\tscanf(\"%s\",buf);\n\n\tMATRIX ans(SIZE),final_loc(SIZE);\n\tfinal_loc = calcNextLoc(0,length-1);\n\n\t/*for(int i = 0; i < SIZE; i++){\n\t\tprintf(\"final_loc[%d]:%d\\n\",i,final_loc[i]);\n\t}*/\n\n\tfor(int i = 0; i < SIZE; i++){\n\t\tans[final_loc[i]] = i+1;\n\t}\n\n\tfor(int row = 0; row < N; row++){\n\t\tprintf(\"%d\",ans[getLoc(row,0)]);\n\t\tfor(int col = 1; col < N; col++){\n\t\t\tprintf(\" %d\",ans[getLoc(row,col)]);\n\t\t}\n\t\tprintf(\"\\n\");\n\t}\n\n\treturn 0;\n}\n\n\n"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\n#define GET_MACRO(_1,_2,_3,_4,_5,NAME,...) NAME\n#define pr(...) GET_MACRO(__VA_ARGS__,pr5,pr4,pr3,pr2,pr1)(__VA_ARGS__)\n#define pr1(a) (#a)<<\"=\"<<(a)\n#define pr2(a,b) pr1(a)<<\", \"<<pr1(b)\n#define pr3(a,b,c) pr2(a,b)<<\", \"<<pr1(c)\n#define pr4(a,b,c,d) pr3(a,b,c)<<\", \"<<pr1(d)\n#define pr5(a,b,c,d,e) pr4(a,b,c,d)<<\", \"<<pr1(e)\n#define int long long\n#define double long double\nusing namespace std;\nconst int N = 100010;\nconst int INF = 1LL<<55;\nconst int mod = (1e9)+7;\nconst double EPS = 1e-8;\nconst double PI = 6.0 * asin(0.5);\ntypedef pair<int,int> P;\ntypedef long long ll;\ntemplate<class T> T Max(T &a,T b){return a=max(a,b);}\ntemplate<class T> T Min(T &a,T b){return a=min(a,b);}\n//ostream& operator<<(ostream& o,P p){return o<<\"(\"<<p.first<<\",\"<<p.second<<\")\";}\n//istream& operator>>(istream& i,P &p){return i>>p.first>>p.second;}\n//ostream& operator<<(ostream& o,vector<auto> &a){int i=0;for(auto t:a)o<<(i++?\" \":\"\")<<t;return o;}\n//istream& operator>>(istream& i,vector<auto> &a){for(auto &t:a)i>>t;return i;}\n//void prArr(auto a,string s=\" \"){int i=0;for(auto t:a)cout<<(i++?s:\"\")<<t;cout<<endl;}\n\ntypedef vector<int> vec;\ntypedef vector<vec> mat;\n\nmat move(mat a,mat b){\n  int n = a.size();\n  mat res(n,vec(n));\n\n  assert(a.size() == b.size());\n  assert(a[0].size() == b[0].size());\n  assert(a[0].size() == a.size());\n  \n  for(int i=0;i<n;i++)\n    for(int j=0;j<n;j++) {\n      int y = a[i][j] / n;\n      int x = a[i][j] % n;\n      res[i][j] = b[y][x];\n    }\n  return res;\n}\n\nint n,len;\nint pos;\nstring str;\n\nmat bfs();\nmat repeat();\nint number();\n  \nmat repeat(){\n  assert(str[pos] == '(');\n  pos++;\n  mat x = bfs();\n  assert(str[pos]==')');\n  pos++;\n  int num = number();\n  \n  mat res(n,vec(n));\n  for(int i=0;i<n;i++)\n    for(int j=0;j<n;j++) res[i][j] = i * n + j;\n\n  while(num){\n    if(num%2) res = move(res,x);\n    x = move(x,x);\n    num = num/2;\n  }\n  return res;\n}\n\nint number(){\n  assert(isdigit(str[pos]));\n  int res = 0;\n  while(pos < (int)str.size() && isdigit(str[pos])) res = res * 10 + str[pos] - '0', pos++;\n  return res;\n}\n\nvoid L(mat &A){\n  assert(str[pos++] == 'L');\n  int k = number() - 1;\n  for(int i=0;i<n-1;i++) swap(A[k][i],A[k][i+1]);\n}\n\nvoid R(mat &A){\n  assert(str[pos++] == 'R');\n  int k = number() - 1;\n  for(int i=0;i<n-1;i++) swap(A[k][n-1-i],A[k][n-2-i]);\n};\n\nmat U(mat &A){\n  assert(str[pos++] == 'U');\n  int k = number() - 1;\n  for(int i=0;i<n-1;i++) swap(A[i][k],A[i+1][k]);\n};\nmat D(mat &A){\n  assert(str[pos++] == 'D');\n  int k = number() - 1;\n  for(int i=0;i<n-1;i++) swap(A[n-1-i][k],A[n-2-i][k]);\n};\n\nmat bfs(){\n  mat res(n,vec(n));\n  for(int i=0;i<n;i++)\n    for(int j=0;j<n;j++) res[i][j] = i*n + j;\n  \n  while(pos < (int)str.size()-1){\n    char ch = str[pos];\n    if(ch == '(') res = repeat();\n    else if(ch == 'L') L(res);\n    else if(ch == 'R') R(res);\n    else if(ch == 'U') U(res);\n    else if(ch == 'D') D(res);\n    else break;\n  }\n  return res;\n}\n\nsigned main(){\n  int L;\n  cin>>n>>L;\n  cin>>str;\n  str+='$';\n  \n  mat ans = bfs();\n  for(int i=0;i<n;i++)\n    for(int j=0;j<n;j++) ans[i][j] ++;\n  \n  for(int i=0;i<n;i++) {\n    for(int j=0;j<n;j++){\n      if(j) cout<<\" \";\n      cout<<ans[i][j];\n    }\n    cout<<endl;\n  }\n  \n  return 0;\n}\n\n"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\nusing namespace std;\n\ntypedef long long ll;\ntypedef unsigned long long ull;\ntypedef pair<ll, ll> P;\n\n#define fi first\n#define se second\n#define repl(i,a,b) for(ll i=(ll)(a);i<(ll)(b);i++)\n#define rep(i,n) repl(i,0,n)\n#define all(x) (x).begin(),(x).end()\n#define dbg(x) cout<<#x\"=\"<<x<<endl\n#define mmax(x,y) (x>y?x:y)\n#define mmin(x,y) (x<y?x:y)\n#define maxch(x,y) x=mmax(x,y)\n#define minch(x,y) x=mmin(x,y)\n#define uni(x) x.erase(unique(all(x)),x.end())\n#define exist(x,y) (find(all(x),y)!=x.end())\n#define bcnt __builtin_popcount\n\nint N,L,M;\nstring s;\nvector<int> e;\n\nvector<int> operator*(const vector<int>& a,const vector<int>& b){\n  vector<int> res(a.size());\n  rep(i,a.size())res[i]=b[a[i]];\n  return res;\n}\n\nvector<int> seq(int l,int r){\n  if(s[l]!='('){\n    int i=l+1;\n    while(i<r&&isdigit(s[i]))i++;\n    if(i==r){ // opr\n      int num=stoi(s.substr(l+1,r-l-1));\n      num--;\n      vector<int> res=e;\n      if(s[l]=='L'){\n        rep(i,M){\n          if(i/N==num){\n            int base=(i/N)*N;\n            res[i]=(i-base-1+N)%N+base;\n          }\n        }\n      }else if(s[l]=='R'){\n        rep(i,M){\n          if(i/N==num){\n            int base=(i/N)*N;\n            res[i]=(i-base+1)%N+base;\n          }\n        }\n      }else if(s[l]=='U'){\n        rep(i,M){\n          if(i%N==num){\n            int base=i%N;\n            res[i]=((((i-base)/N)-1+N)%N)*N+base;\n          }\n        }\n      }else{\n        rep(i,M){\n          if(i%N==num){\n            int base=i%N;\n            res[i]=((((i-base)/N)+1)%N)*N+base;\n          }\n        }\n      }\n      return res;\n    }\n  }\n\n  vector<int> res=e;\n  for(int i=l;i<r;){\n    if(s[i]=='('){ // rept\n      int j=i+1;\n      int lev=1;\n      while(lev!=0){\n        if(s[j]=='(')lev++;\n        if(s[j]==')')lev--;\n        j++;\n      }\n      int k=j;\n      while(k<r&&isdigit(s[k]))k++;\n      vector<vector<int> > nxt(vector<vector<int> >(30,vector<int>(M)));\n      nxt[0]=seq(i+1,j-1);\n      repl(b,1,30)nxt[b]=nxt[b-1]*nxt[b-1];\n      int t=stoi(s.substr(j,k-j));\n      rep(b,30){\n        if((t>>b)&1)res=res*nxt[b];\n      }\n      i=k;\n    }else{ // seq\n      int j=i+1;\n      while(j<r&&isdigit(s[j]))j++;\n      res=res*seq(i,j);\n      i=j;\n    }\n  }\n  return res;\n}\n\nint main(){\n  cin>>N>>L;\n  M=N*N;\n  cin>>s;\n  rep(i,M)e.push_back(i);\n  vector<int> res=seq(0,L);\n  vector<int> ans;\n  rep(i,M)ans.push_back(i);\n  rep(i,M)ans[res[i]]=i;\n  rep(i,N){\n    rep(j,N){\n      printf(\"%d%c\", ans[i*N+j]+1,j==N-1?'\\n':' ');\n    }\n  }\n  return 0;\n}\n\n"
  },
  {
    "language": "C++",
    "code": "#include<bits/stdc++.h>\nusing namespace std;\n#define int long long\ntypedef vector<vector<int> > mat;\nint n,l,pos=0;\nstring s;\nmat init(){\n  mat res;\n  res.resize(n,vector<int>(n));\n  for(int i=0;i<n;i++)\n    for(int j=0;j<n;j++)\n      res[i][j]=i*n+j;\n  return res;\n}\n\nmat expr();\nmat repet();\n\nmat expr(){\n  mat res=init();\n  while(pos<l){\n    //cout<<pos<<endl;\n    if(isupper(s[pos])){\n      char c=s[pos++];\n      int m=0;\n      while(isdigit(s[pos]))\n\tm=m*10+s[pos++]-'0';\n      //cout<<c<<\" \"<<m<<endl;\n      m--;\n      if(c=='R'){\n\tint tmp=res[m][n-1];\n\tfor(int j=n-1;j>0;j--) res[m][j]=res[m][j-1];\n\tres[m][0]=tmp;\n      }\n      if(c=='L'){\n\tint tmp=res[m][0];\n\tfor(int j=0;j<n-1;j++) res[m][j]=res[m][j+1];\n\tres[m][n-1]=tmp;\n      }\n      if(c=='D'){\n\tint tmp=res[n-1][m];\n\tfor(int j=n-1;j>0;j--) res[j][m]=res[j-1][m];\n\tres[0][m]=tmp;\n      }\n      if(c=='U'){\n\tint tmp=res[0][m];\n\tfor(int j=0;j<n-1;j++) res[j][m]=res[j+1][m];\n\tres[n-1][m]=tmp;\n      }\n    }else if(s[pos]=='(') {\n      mat tmp=repet();\n      mat buf=res;\n       for(int i=0;i<n;i++)\n\t for(int j=0;j<n;j++)\n\t   res[i][j]=buf[tmp[i][j]/n][tmp[i][j]%n];\n    }else break;\n  }\n  return res;\n}\n\nmat repet(){\n  mat res=init();\n  assert(s[pos]=='(');\n  pos++;\n  mat tmp[100];\n  tmp[0]=expr();\n  assert(s[pos]==')');\n  pos++;\n  int m=0;\n  while(pos<l&&isdigit(s[pos]))\n    m=m*10+s[pos++]-'0';\n\n  /*\n  for(int i=0;i<n;i++)\n    for(int j=0;j<n;j++)\n      cout<<tmp[0][i][j]<<\" \\n\"[j==n-1];\n  */\n  \n  for(int k=0;(m>>k);k++){\n    if((m>>k)&1){\n      for(int i=0;i<n;i++)\n\tfor(int j=0;j<n;j++)\n\t  res[i][j]=tmp[k][res[i][j]/n][res[i][j]%n];\n    }\n    tmp[k+1]=init();\n    \n    for(int i=0;i<n;i++)\n      for(int j=0;j<n;j++)\n\ttmp[k+1][i][j]=tmp[k][tmp[k][i][j]/n][tmp[k][i][j]%n];\n\n    /*\n    for(int i=0;i<n;i++)\n      for(int j=0;j<n;j++)\n\tcout<<tmp[k+1][i][j]<<\" \\n\"[j==n-1];\n    */\n  }\n  \n  return res;\n}\nsigned main(){\n  cin>>n>>l>>s;\n  mat ans=expr();\n  for(int i=0;i<n;i++)\n    for(int j=0;j<n;j++)\n      cout<<ans[i][j]+1<<\" \\n\"[j==n-1];\n  return 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\n#define REP(i, a, n) for (ll i = ((ll) a); i < ((ll) n); i++)\nusing namespace std;\ntypedef long long ll;\n\nll N, L;\nstring S;\nll p = 0;\n\nvector<vector<ll>> sl(vector<vector<ll>> &a, ll r) {\n  vector<vector<ll>> b(a);\n  REP(i, 0, N) b[r][i] = a[r][(i + 1) % N];\n  return b;\n}\n\nvector<vector<ll>> sr(vector<vector<ll>> &a, ll r) {\n  vector<vector<ll>> b(a);\n  REP(i, 0, N) b[r][i] = a[r][(i + N - 1) % N];\n  return b;\n}\n\nvector<vector<ll>> su(vector<vector<ll>> &a, ll c) {\n  vector<vector<ll>> b(a);\n  REP(i, 0, N) b[i][c] = a[(i + 1) % N][c];\n  return b;\n}\n\nvector<vector<ll>> sd(vector<vector<ll>> &a, ll c) {\n  vector<vector<ll>> b(a);\n  REP(i, 0, N) b[i][c] = a[(i + N - 1) % N][c];\n  return b;\n}\n\nvector<vector<ll>> mg(vector<vector<ll>> &a, vector<vector<ll>> &b) {\n  vector<vector<ll>> c(N, vector<ll>(N));\n  REP(i, 0, N) REP(j, 0, N) {\n    ll y = b[i][j] / N, x = b[i][j] % N;\n    c[i][j] = a[y][x];\n  }\n  return c;\n}\n\nvector<vector<ll>> pw(vector<vector<ll>> &a, ll n) {\n  if (n == 0) {\n    vector<vector<ll>> e(N, vector<ll>(N));\n    REP(i, 0, N) REP(j, 0, N) e[i][j] = i * N + j;\n    return e;\n  }\n  if (n % 2 == 0) {\n    vector<vector<ll>> b = mg(a, a);\n    return pw(b, n / 2);\n  } else {\n    vector<vector<ll>> b = pw(a, n - 1);\n    return mg(a, b);\n  }\n}\n\nll number() {\n  ll n = 0;\n  while (p < L && isdigit(S[p])) {\n    n = n * 10 + (S[p++] - '0');\n  }\n  return n;\n}\n\nvector<vector<ll>> sequence() {\n  vector<vector<ll>> ret(N, vector<ll>(N));\n  REP(i, 0, N) REP(j, 0, N) ret[i][j] = i * N + j;\n\n  while (p < L) {\n    char c = S[p++];\n    if (c == 'L') {\n      ret = sl(ret, number() - 1);\n    } else if (c == 'R') {\n      ret = sr(ret, number() - 1);\n    } else if (c == 'U') {\n      ret = su(ret, number() - 1);\n    } else if (c == 'D') {\n      ret = sd(ret, number() - 1);\n    } else if (c == '(') {\n      vector<vector<ll>> a = sequence();\n      vector<vector<ll>> b = pw(a, number());\n      ret = mg(ret, b);\n    } else if (c == ')') {\n      break;\n    }\n  }\n\n  return ret;\n}\n\nint main(void) {\n  cin >> N >> L >> S;\n\n  vector<vector<ll>> s = sequence();\n  REP(i, 0, N) {\n    REP(j, 0, N) cout << s[i][j] + 1 << (j + 1 != N ? \" \" : \"\\n\");\n  }\n}\n"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\n#define r(i,n) for(int i=0;i<n;i++)\nusing namespace std;\ntypedef pair<int,int>P;\ntypedef vector<int> V;\ntypedef vector<V> VV;\n\nint n,m,PRE[11111],X[1111];\nstring s;\n\nVV init(){\n    VV v(n,V(n));\n    r(i,n)r(j,n)v[i][j]=i*n+j+1;\n    return v;\n}\ninline void MUL(VV &a,VV &b){r(i,n)r(j,n)a[i][j]=b[PRE[a[i][j]]/n][PRE[a[i][j]]%n];}\ninline void U(VV &a,int x){r(i,n-1)swap(a[i][x-1],a[i+1][x-1]);}\ninline void D(VV &a,int x){r(i,n-1)swap(a[n-i-1][x-1],a[n-i-2][x-1]);}\ninline void R(VV &a,int x){r(i,n-1)swap(a[x-1][n-i-1],a[x-1][n-i-2]);}\ninline void L(VV &a,int x){r(i,n-1)swap(a[x-1][i],a[x-1][i+1]);}\n\ninline void POW(VV &a,int x){ x--;\n    VV v[30];\n    v[0]=a;\n    r(i,29){\n        v[i+1]=v[i];\n        MUL(v[i+1],v[i]);\n    }\n    r(i,30)if((1<<i)&x)MUL(a,v[i]);\n}\n\ninline VV dfs(int l,int r){\n    VV res=init();\n    for(int i=l;i<=r;i++){\n        VV ret=init();\n        if(s[i]=='('){\n            int t=i,cc=1;\n            i=X[i];\n            ret=dfs(t+1,i-1);\n            int p=0; i++;\n            while(isdigit(s[i]))p=p*10+(s[i]-'0'),i++;\n            POW(ret,p);\n        }\n        else if(isalpha(s[i])){\n            int t=i,p=0; i++;\n            while(isdigit(s[i]))p=p*10+(s[i]-'0'),i++;\n            if(s[t]=='U')U(ret,p);\n            if(s[t]=='D')D(ret,p);\n            if(s[t]=='R')R(ret,p);\n            if(s[t]=='L')L(ret,p);\n        }\n        MUL(ret,res);\n        res=ret;\n        i--;\n    }\n    return res;\n}\n\n\nint main(){\n    r(i,11111)PRE[i]=i-1;\n    cin>>n>>m>>s;s+='@';\n    stack<int>st;\n    r(i,m){\n        if(s[i]=='(')st.push(i);\n        if(s[i]==')')X[st.top()]=i,st.pop();\n    }\n    VV ans=dfs(0,m-1);\n    r(i,n){\n        r(j,n){\n            if(j)cout<<' ';\n            cout<<ans[i][j];\n        }\n        cout<<endl;\n    }\n}\n"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\n#define GET_MACRO(_1,_2,_3,_4,_5,NAME,...) NAME\n#define pr(...) GET_MACRO(__VA_ARGS__,pr5,pr4,pr3,pr2,pr1)(__VA_ARGS__)\n#define pr1(a) (#a)<<\"=\"<<(a)\n#define pr2(a,b) pr1(a)<<\", \"<<pr1(b)\n#define pr3(a,b,c) pr2(a,b)<<\", \"<<pr1(c)\n#define pr4(a,b,c,d) pr3(a,b,c)<<\", \"<<pr1(d)\n#define pr5(a,b,c,d,e) pr4(a,b,c,d)<<\", \"<<pr1(e)\n#define int long long\n#define double long double\nusing namespace std;\nconst int N = 100010;\nconst int INF = 1LL<<55;\nconst int mod = (1e9)+7;\nconst double EPS = 1e-8;\nconst double PI = 6.0 * asin(0.5);\ntypedef pair<int,int> P;\ntypedef long long ll;\ntemplate<class T> T Max(T &a,T b){return a=max(a,b);}\ntemplate<class T> T Min(T &a,T b){return a=min(a,b);}\n//ostream& operator<<(ostream& o,P p){return o<<\"(\"<<p.first<<\",\"<<p.second<<\")\";}\n//istream& operator>>(istream& i,P &p){return i>>p.first>>p.second;}\n//ostream& operator<<(ostream& o,vector<auto> &a){int i=0;for(auto t:a)o<<(i++?\" \":\"\")<<t;return o;}\n//istream& operator>>(istream& i,vector<auto> &a){for(auto &t:a)i>>t;return i;}\n//void prArr(auto a,string s=\" \"){int i=0;for(auto t:a)cout<<(i++?s:\"\")<<t;cout<<endl;}\n\ntypedef vector<int> vec;\ntypedef vector<vec> mat;\n\nmat move(mat a,mat b){\n  int n = a.size();\n  mat res(n,vec(n));\n\n  assert(a.size() == b.size());\n  assert(a[0].size() == b[0].size());\n  assert(a[0].size() == a.size());\n  \n  for(int i=0;i<n;i++)\n    for(int j=0;j<n;j++) {\n      int y = a[i][j] / n;\n      int x = a[i][j] % n;\n      res[i][j] = b[y][x];\n    }\n  return res;\n}\n\nint n,len;\nint pos;\nstring str;\n\nmat bfs();\nmat repeat();\nint number();\n  \nmat repeat(){\n  assert(str[pos] == '(');\n  pos++;\n  mat x = bfs();\n  assert(str[pos]==')');\n  pos++;\n  int num = number();\n  \n  mat res(n,vec(n));\n  for(int i=0;i<n;i++)\n    for(int j=0;j<n;j++) res[i][j] = i * n + j;\n\n  while(num){\n    if(num%2) res = move(res,x);\n    x = move(x,x);\n    num = num/2;\n  }\n  return res;\n}\n\nint number(){\n  assert(isdigit(str[pos]));\n  int res = 0;\n  while(pos < (int)str.size() && isdigit(str[pos])) res = res * 10 + str[pos] - '0', pos++;\n  return res;\n}\n\nvoid L(mat &A){\n  assert(str[pos++] == 'L');\n  int k = number() - 1;\n  for(int i=0;i<n-1;i++) swap(A[k][i],A[k][i+1]);\n}\n\nvoid R(mat &A){\n  assert(str[pos++] == 'R');\n  int k = number() - 1;\n  for(int i=0;i<n-1;i++) swap(A[k][n-1-i],A[k][n-2-i]);\n};\n\nmat U(mat &A){\n  assert(str[pos++] == 'U');\n  int k = number() - 1;\n  for(int i=0;i<n-1;i++) swap(A[i][k],A[i+1][k]);\n};\nmat D(mat &A){\n  assert(str[pos++] == 'D');\n  int k = number() - 1;\n  for(int i=0;i<n-1;i++) swap(A[n-1-i][k],A[n-2-i][k]);\n};\n\nmat bfs(){\n  mat res(n,vec(n));\n  for(int i=0;i<n;i++)\n    for(int j=0;j<n;j++) res[i][j] = i*n + j;\n  \n  while(pos < (int)str.size()){\n    char ch = str[pos];\n    if(ch == '(') res = repeat();\n    else if(ch == 'L') L(res);\n    else if(ch == 'R') R(res);\n    else if(ch == 'U') U(res);\n    else if(ch == 'D') D(res);\n    else break;\n  }\n  return res;\n}\n\nsigned main(){\n  int L;\n  cin>>n>>L;\n  cin>>str;\n  \n  mat ans = bfs();\n  for(int i=0;i<n;i++)\n    for(int j=0;j<n;j++) ans[i][j] ++;\n  \n  for(int i=0;i<n;i++) {\n    for(int j=0;j<n;j++){\n      if(j) cout<<\" \";\n      cout<<ans[i][j];\n    }\n    cout<<endl;\n  }\n  \n  return 0;\n}\n\n"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\nusing namespace std;\nusing ll = long long;\n#define rep(i,n) for(int (i)=0;(i)<(int)(n);++(i))\n#define all(x) (x).begin(),(x).end()\n#define pb push_back\n#define fi first\n#define se second\n#define dbg(x) cout<<#x\" = \"<<((x))<<endl\ntemplate<class T,class U> ostream& operator<<(ostream& o, const pair<T,U> &p){o<<\"(\"<<p.fi<<\",\"<<p.se<<\")\";return o;}\ntemplate<class T> ostream& operator<<(ostream& o, const vector<T> &v){o<<\"[\";for(T t:v){o<<t<<\",\";}o<<\"]\";return o;}\n\nint n,L;\nstring s;\n\nvector<int> merge(const vector<int> &f, const vector<int> &g){\n    vector<int> h(n*n);\n    rep(i,n*n) h[i] = g[f[i]];\n    return h;\n}\n\nvector<int> pow(const vector<int> &f, int p){\n    vector<int> g(f);\n\n    vector<int> ret(n*n);\n    iota(all(ret),0);\n\n    while(p){\n        if(p&1) ret = merge(ret, g);\n        g = merge(g,g);\n        p >>= 1;\n    }\n    return ret;\n}\n\nint number(int &idx){\n    int ret = 0;\n    while(idx<L && isdigit(s[idx])){\n        ret = ret*10 + (s[idx]-'0');\n        ++idx;\n    }\n    return ret;\n}\n\nvector<int> sequence(int &idx);\nvector<int> repetition(int &idx);\nvector<int> operation(int &idx);\n\nvector<int> sequence(int &idx){\n    vector<int> f(n*n);\n    iota(all(f), 0);\n\n    if(idx < L && s[idx] != ')'){\n        if(s[idx] == '(') f = merge(f, repetition(idx));\n        else f = merge(f, operation(idx));\n    }\n\n    return f;\n}\n\nvector<int> repetition(int &idx){\n    ++idx;\n    vector<int> f = sequence(idx);\n\n    assert(s[idx]==')');\n    ++idx;\n\n    int num = number(idx);\n    return merge(pow(f, num), sequence(idx));\n}\n\nvector<int> operation(int &idx){\n    char op = s[idx];\n    ++idx;\n    int num = number(idx);\n    --num;\n\n    vector<int> f(n*n);\n    iota(all(f), 0);\n\n    if(op == 'R'){\n        int v = f[num*n];\n        for(int i=1; i<n; ++i) f[num*n + i-1] = f[num*n + i];\n        f[num*n + n-1] = v;\n    }\n    else if(op == 'L'){\n        int v = f[num*n + n-1];\n        for(int i=n-1; i>0; --i) f[num*n + i] = f[num*n + i-1];\n        f[num*n] = v;\n    }\n    else if(op == 'D'){\n        int v = f[num];\n        rep(i,n-1) f[i*n + num] = f[(i+1)*n + num];\n        f[(n-1)*n + num] = v;\n    }\n    else if(op == 'U'){\n        int v = f[(n-1)*n + num];\n        for(int i=n-1; i>0; --i) f[i*n + num] = f[(i-1)*n + num];\n        f[num] = v;\n    }\n    else assert(false);\n\n    return merge(f, sequence(idx));\n}\n\nint main(){\n    cin >>n >>L >>s;\n\n    int idx = 0;\n    vector<int> f = sequence(idx);\n\n    vector<vector<int>> a(n, vector<int>(n));\n    rep(i,n*n){\n        int pos = f[i];\n        a[pos/n][pos%n] = i+1;\n    }\n\n    rep(i,n){\n        rep(j,n) printf(\"%d%c\", a[i][j], \" \\n\"[j==n-1]);\n    }\n\n    return 0;\n}\n\n"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\n#define GET_MACRO(_1,_2,_3,_4,_5,NAME,...) NAME\n#define pr(...) GET_MACRO(__VA_ARGS__,pr5,pr4,pr3,pr2,pr1)(__VA_ARGS__)\n#define pr1(a) (#a)<<\"=\"<<(a)\n#define pr2(a,b) pr1(a)<<\", \"<<pr1(b)\n#define pr3(a,b,c) pr2(a,b)<<\", \"<<pr1(c)\n#define pr4(a,b,c,d) pr3(a,b,c)<<\", \"<<pr1(d)\n#define pr5(a,b,c,d,e) pr4(a,b,c,d)<<\", \"<<pr1(e)\n#define int long long\n#define double long double\nusing namespace std;\nconst int N = 100010;\nconst int INF = 1LL<<55;\nconst int mod = (1e9)+7;\nconst double EPS = 1e-8;\nconst double PI = 6.0 * asin(0.5);\ntypedef pair<int,int> P;\ntypedef long long ll;\ntemplate<class T> T Max(T &a,T b){return a=max(a,b);}\ntemplate<class T> T Min(T &a,T b){return a=min(a,b);}\nostream& operator<<(ostream& o,P p){return o<<\"(\"<<p.first<<\",\"<<p.second<<\")\";}\nistream& operator>>(istream& i,P &p){return i>>p.first>>p.second;}\nostream& operator<<(ostream& o,vector<auto> &a){int i=0;for(auto t:a)o<<(i++?\" \":\"\")<<t;return o;}\nistream& operator>>(istream& i,vector<auto> &a){for(auto &t:a)i>>t;return i;}\nvoid prArr(auto a,string s=\" \"){int i=0;for(auto t:a)cout<<(i++?s:\"\")<<t;cout<<endl;}\n\ntypedef vector<int> vec;\ntypedef vector<vec> mat;\n\nmat move(const mat &a,const mat &b){\n  int n = a.size();\n  mat res(n,vec(n));\n\n  assert(a.size() == b.size());\n  assert(a[0].size() == b[0].size());\n  assert(a[0].size() == a.size());\n  \n  for(int i=0;i<n;i++)\n    for(int j=0;j<n;j++) {\n      int y = a[i][j] / n;\n      int x = a[i][j] % n;\n      assert(y < (int)b.size() && x < (int)b[y].size());\n      res[i][j] = b[y][x];\n    }\n  return res;\n}\n\nint n;\nint pos;\nstring str;\n\nmat bfs();\nmat repeat();\nint number();\n  \nmat repeat(){\n  assert(str[pos] == '(');\n  pos++;\n  mat x = bfs();\n  assert(str[pos]==')');\n  pos++;\n  int num = number();\n  \n  mat res(n,vec(n));\n  for(int i=0;i<n;i++)\n    for(int j=0;j<n;j++) res[i][j] = i * n + j;\n\n  while(num){\n    if(num%2) res = move(res,x);\n    x = move(x,x);\n    num /= 2;\n  }\n  return res;\n}\n\nint number(){\n  assert(isdigit(str[pos]));\n  int res = 0;\n  while(pos < (int)str.size() && isdigit(str[pos])) res = res * 10 + str[pos++] - '0';\n  return res;\n}\n\nvoid L(mat &A){\n  assert(str[pos++] == 'L');\n  int k = number() - 1;\n  for(int i=0;i<n-1;i++) swap(A[k][i],A[k][i+1]);\n}\n\nvoid R(mat &A){\n  assert(str[pos++] == 'R');\n  int k = number() - 1;\n  for(int i=0;i<n-1;i++) swap(A[k][n-1-i],A[k][n-2-i]);\n};\n\nvoid U(mat &A){\n  assert(str[pos++] == 'U');\n  int k = number() - 1;\n  for(int i=0;i<n-1;i++) swap(A[i][k],A[i+1][k]);\n};\n\nvoid D(mat &A){\n  assert(str[pos++] == 'D');\n  int k = number() - 1;\n  for(int i=0;i<n-1;i++) swap(A[n-1-i][k],A[n-2-i][k]);\n};\n\nmat bfs(){\n  mat res(n,vec(n));\n  for(int i=0;i<n;i++)\n    for(int j=0;j<n;j++) res[i][j] = i*n + j;\n  \n  while(pos < (int)str.size()){\n    char ch = str[pos];\n    if(ch == '(') res = repeat();\n    else if(ch == 'L') L(res);\n    else if(ch == 'R') R(res);\n    else if(ch == 'U') U(res);\n    else if(ch == 'D') D(res);\n    else break;\n  }\n  return res;\n}\n\nsigned main(){\n  int L;\n  cin>>n>>L;\n  cin>>str;\n  \n  \n  mat ans = bfs();\n  for(int i=0;i<n;i++)\n    for(int j=0;j<n;j++) ans[i][j] ++;\n  \n  for(int i=0;i<n;i++) cout<<ans[i]<<endl;\n  return 0;\n}\n\n"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\n#define GET_MACRO(_1,_2,_3,_4,_5,NAME,...) NAME\n#define pr(...) GET_MACRO(__VA_ARGS__,pr5,pr4,pr3,pr2,pr1)(__VA_ARGS__)\n#define pr1(a) (#a)<<\"=\"<<(a)\n#define pr2(a,b) pr1(a)<<\", \"<<pr1(b)\n#define pr3(a,b,c) pr2(a,b)<<\", \"<<pr1(c)\n#define pr4(a,b,c,d) pr3(a,b,c)<<\", \"<<pr1(d)\n#define pr5(a,b,c,d,e) pr4(a,b,c,d)<<\", \"<<pr1(e)\n#define int long long\n#define double long double\nusing namespace std;\nconst int N = 100010;\nconst int INF = 1LL<<55;\nconst int mod = (1e9)+7;\nconst double EPS = 1e-8;\nconst double PI = 6.0 * asin(0.5);\ntypedef pair<int,int> P;\ntypedef long long ll;\ntemplate<class T> T Max(T &a,T b){return a=max(a,b);}\ntemplate<class T> T Min(T &a,T b){return a=min(a,b);}\nostream& operator<<(ostream& o,P p){return o<<\"(\"<<p.first<<\",\"<<p.second<<\")\";}\nistream& operator>>(istream& i,P &p){return i>>p.first>>p.second;}\nostream& operator<<(ostream& o,vector<auto> &a){int i=0;for(auto t:a)o<<(i++?\" \":\"\")<<t;return o;}\nistream& operator>>(istream& i,vector<auto> &a){for(auto &t:a)i>>t;return i;}\nvoid prArr(auto a,string s=\" \"){int i=0;for(auto t:a)cout<<(i++?s:\"\")<<t;cout<<endl;}\n\ntypedef vector<int> vec;\ntypedef vector<vec> mat;\n\nmat move(const mat a,const mat b){\n  int n = a.size();\n  mat res(n,vec(n));\n\n  for(int i=0;i<n;i++)\n    for(int j=0;j<n;j++) {\n      int y = a[i][j] / n;\n      int x = a[i][j] % n;\n      res[i][j] = b[y][x];\n    }\n  return res;\n}\n\nint n;\nint pos;\nstring str;\nmat E;\n\nmat bnf(mat);\nint number();\n\nmat repeat(mat res){\n  assert(str[pos++] == '(');\n  mat x = bnf(E);\n  assert(str[pos++]==')');\n  \n  int num = number();\n  while(num){\n    if(num%2) res = move(res,x);\n    x = move(x,x);\n    num /= 2;\n  }\n  return res;\n}\n\nint number(){\n  assert(isdigit(str[pos]));\n\n  int res = 0;\n  while(pos < (int)str.size() && isdigit(str[pos])) res = res * 10 + str[pos++] - '0';\n  return res;\n}\n\nmat L(){\n  assert(str[pos++] == 'L');\n\n  mat res = E;\n  int k = number() - 1;\n  for(int i=0;i<n-1;i++) swap(res[k][n-1-i],res[k][n-2-i]);\n  return res;\n}\n\nmat R(){\n  assert(str[pos++] == 'R');\n\n  mat res = E;\n  int k = number() - 1;\n  for(int i=0;i<n-1;i++) swap(res[k][i],res[k][i+1]);\n  return res;\n};\n\nmat U(){\n  assert(str[pos++] == 'U');\n\n  mat res = E;\n  int k = number() - 1;\n  for(int i=0;i<n-1;i++) swap(res[n-1-i][k],res[n-2-i][k]);\n  return res;\n};\n\nmat D(){\n  assert(str[pos++] == 'D');\n\n  mat res = E;\n  int k = number() - 1;\n  for(int i=0;i<n-1;i++) swap(res[i][k],res[i+1][k]);\n  return res;\n};\n\nmat bnf(mat res){\n  while(pos < (int)str.size()){\n    char ch = str[pos];\n    if(ch == '(') res = repeat(res);\n    else if(ch == 'L') res = move(res,L());\n    else if(ch == 'R') res = move(res,R());\n    else if(ch == 'U') res = move(res,U());\n    else if(ch == 'D') res = move(res,D());\n    else break;\n  }\n  return res;\n}\n\nsigned main(){\n  int L;\n  cin>>n>>L;\n  cin>>str;\n\n  E = mat(n,vec(n));\n\n  for(int i=0;i<n;i++)\n    for(int j=0;j<n;j++) E[i][j] = i * n + j;\n\n  mat mv = bnf(E);\n\n  mat ans(n,vec(n));\n  for(int i=0;i<n;i++)\n    for(int j=0;j<n;j++) {\n      int x = mv[i][j]%n;\n      int y = mv[i][j]/n;\n      ans[y][x] = i * n + j;\n    }\n  \n  for(int i=0;i<n;i++)\n    for(int j=0;j<n;j++) ans[i][j] ++;\n  \n  for(int i=0;i<n;i++) cout<<ans[i]<<endl;\n  return 0;\n}\n\n"
  },
  {
    "language": "C++",
    "code": "#include<bits/stdc++.h>\nusing namespace std;\n#define rep(i, a, b) for (int i = (int)(a); i < (int)(b); ++i)\n#define rrep(i, a, b) for (int i = (int)(b) - 1; i >= (int)(a); --i)\n\nstruct Parser{\n    using Iter=string::const_iterator;\n    Iter it;\n    Parser(Iter it):it(it){}\n    void cmp(char expected){\n        if(*it!=expected){\n            throw 0;\n            cerr<<*it<<\" is not \"<<expected<<endl;\n        }\n    }\n\n    vector<vector<vector<int>>> sub;\n\n    // LRUD\n    string LRUD = \"LRUD\";\n    const int di[4] = {0, 0, 1, -1};\n    const int dj[4] = {1, -1, 0, 0};\n    int id[128];\n\n    int N;\n    int NN;\n    void init(int n){\n        N = n;\n        NN = N * N;\n        sub.assign(4, vector<vector<int>>(N, vector<int>(NN)));\n        for(int i = 0; i < 4; i++)\n            id[LRUD[i]] = i;\n        rep(d, 0, 4) {\n            rep(k,0,n){\n                rep(i, 0, n)rep(j,0,n){\n                    if((d<2&&i==k)||(d>=2&&j==k)){\n                        int ni = (i + di[d] + n) % n, nj = (j + dj[d] + n) % n;\n                        sub[d][k][i*n+j]=ni*n+nj;\n                   }else\n                        sub[d][k][i*n+j]=i*n+j;\n                }\n            }\n        }\n    }\n\n    vector<int> mul(const vector<int> &a, const vector<int> &b) {\n        vector<int> r(NN);\n        rep(i,0,NN){\n            r[i] = a[b[i]];\n        }\n        return r;\n    }\n\n    vector<int> seq(){\n        vector<int> v(NN);\n        iota(v.begin(),v.end(),0);\n        while(*it!='$' && *it!=')'){\n            if(*it=='('){\n                it++;\n                vector<int> res = seq();\n                it++;\n                int num=integer();\n                //行列累乗\n                vector<int> a = res;\n                vector<int> r(NN); iota(r.begin(), r.end(), 0);\n                while(num) {\n                    if(num&1)r=mul(r,a);\n                    a=mul(a,a);\n                    num>>=1;\n                }\n                v=mul(v,r);\n            }else{\n                char shift=*it;\n                it++;\n                int num=integer()-1;\n                v=mul(v,sub[id[shift]][num]);\n            }\n        }\n        return v;\n    }\n    int integer(){\n        int ret=0;\n        while(isdigit(*it)){\n            ret*=10;\n            ret+=*it-'0';\n            it++;\n        }\n        return ret;\n    }\n};\n\nsigned main(){\n    int N, L; cin>>N>>L;\n    string S;cin>>S;S+=\"$\";\n    Parser p(S.begin());\n    p.init(N);\n    vector<int> res = p.seq();\n    rep(i,0,N) {\n        rep(j,0,N){\n            if(j!=0)cout<<\" \";\n            cout<<res[i*N+j]+1;\n        }\n        cout<<endl;\n    }\n    return 0;\n}\n"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\nusing namespace std;\n\n#define rep(i,x,y) for(int i=(x);i<(y);++i)\n#define debug(x) #x << \"=\" << (x)\n\n#ifdef DEBUG\n#define _GLIBCXX_DEBUG\n#define print(x) std::cerr << debug(x) << \" (L:\" << __LINE__ << \")\" << std::endl\n#else\n#define print(x)\n#endif\n\nconst int inf=1e9;\nconst int64_t inf64=1e18;\nconst double eps=1e-9;\n\ntemplate <typename T> ostream &operator<<(ostream &os, const vector<T> &vec){\n    os << \"[\";\n    for (const auto &v : vec) {\n    \tos << v << \",\";\n    }\n    os << \"]\";\n    return os;\n}\n\ntypedef string::const_iterator state;\ntypedef vector<vector<int>> my_matrix;\nclass parse_error{};\nmy_matrix matrix;\nint n,l;\nstring s;\n\nvoid consume(state &begin,char expected){\n    if(*begin==expected) ++begin;\n    else{\n        cerr << \"Exptected '\" << expected << \"' but got '\" << *begin << \"'\" << endl;\n        cerr << \"Rest string is'\";\n        while(*begin) cerr << *begin++;\n        cerr << \"'\" << endl;\n        throw parse_error();\n    }\n}\n\nvoid sequence(state&);\nvoid repetition(state&);\nvoid operation(state&);\nint number(state&);\n\nvoid sequence(state &begin){\n    while(*begin){\n        if(*begin=='(') repetition(begin);\n        else if(*begin=='U' or *begin=='D' or *begin=='L' or *begin=='R') operation(begin);\n        else break;\n    }\n}\n\nvoid repetition(state &begin){\n    consume(begin,'(');\n    const auto backup1=begin;\n    int depth=1;\n    while(depth){\n        if(*begin=='(') ++depth;\n        if(*begin==')') --depth;\n        ++begin;\n    }\n    --begin;\n    consume(begin,')');\n    int num=number(begin);\n    const auto backup2=begin;\n\n    const auto prev_matrix=matrix;\n    rep(i,0,n) rep(j,0,n) matrix[i][j]=i*n+j;\n\n    begin=backup1;\n    sequence(begin);\n\n    vector<vector<pair<int,int>>> perm(n,vector<pair<int,int>>(n)),v(n,vector<pair<int,int>>(n));\n    rep(i,0,n) rep(j,0,n){\n        perm[matrix[i][j]/n][matrix[i][j]%n]=make_pair(i,j);\n        v[i][j]=make_pair(i,j);\n    }\n\n    while(num>0){\n        if(num&1) rep(i,0,n) rep(j,0,n) v[i][j]=perm[v[i][j].first][v[i][j].second];\n        const auto prev_perm=perm;\n        rep(i,0,n) rep(j,0,n) perm[i][j]=prev_perm[perm[i][j].first][perm[i][j].second];\n        num>>=1;\n    }\n    rep(i,0,n) rep(j,0,n) matrix[v[i][j].first][v[i][j].second]=prev_matrix[i][j];\n\n    begin=backup2;\n}\n\nvoid operation(state &begin){\n    char d=*begin;\n    ++begin;\n    int num=number(begin);\n    if(d=='L'){\n        //rotate(matrix[num-1].begin(),matrix[num-1].begin()+1,matrix[num-1].end());\n        int prev=matrix[num-1][0];\n        rep(i,0,n-1) matrix[num-1][i]=matrix[num-1][i+1];\n        matrix[num-1][n-1]=prev;\n    }\n    if(d=='R'){\n        //rotate(matrix[num-1].rbegin(),matrix[num-1].rbegin()+1,matrix[num-1].rend());\n        int prev=matrix[num-1][n-1];\n        for(int i=n-1; i>=1; --i) matrix[num-1][i]=matrix[num-1][i-1];\n        matrix[num-1][0]=prev;\n    }\n    if(d=='U'){\n        int prev=matrix[0][num-1];\n        rep(i,0,n-1) matrix[i][num-1]=matrix[i+1][num-1];\n        matrix[n-1][num-1]=prev;\n    }\n    if(d=='D'){\n        int prev=matrix[n-1][num-1];\n        for(int i=n-1; i>=1; --i) matrix[i][num-1]=matrix[i-1][num-1];\n        matrix[0][num-1]=prev;\n    }\n}\n\nint number(state &begin){\n    int res=0;\n    while(isdigit(*begin)){\n        res*=10;\n        res+=*begin-'0';\n        ++begin;\n    }\n    return res;\n}\n\nvoid solve(){\n    cin >> n >> l >> s;\n    matrix.resize(n);\n    rep(i,0,n){\n        matrix[i].resize(n);\n        rep(j,0,n) matrix[i][j]=i*n+j;\n    }\n    state begin=s.begin();\n    sequence(begin);\n    rep(i,0,n){\n        rep(j,0,n){\n            cout << matrix[i][j]+1;\n            if(j!=n-1) cout << \" \";\n        }\n        cout << endl;\n    }\n}\n\nint main(){\n    std::cin.tie(0);\n    std::ios::sync_with_stdio(false);\n    cout.setf(ios::fixed);\n    cout.precision(10);\n    solve();\n    return 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\nusing namespace std;\n\n#define rep(i,x,y) for(int i=(x);i<(y);++i)\n#define debug(x) #x << \"=\" << (x)\n\n#ifdef DEBUG\n#define _GLIBCXX_DEBUG\n#define print(x) std::cerr << debug(x) << \" (L:\" << __LINE__ << \")\" << std::endl\n#else\n#define print(x)\n#endif\n\nconst int inf=1e9;\nconst int64_t inf64=1e18;\nconst double eps=1e-9;\n\ntemplate <typename T> ostream &operator<<(ostream &os, const vector<T> &vec){\n    os << \"[\";\n    for (const auto &v : vec) {\n    \tos << v << \",\";\n    }\n    os << \"]\";\n    return os;\n}\n\ntypedef string::const_iterator state;\ntypedef vector<vector<int>> my_matrix;\nclass parse_error{};\nmy_matrix matrix;\nint n,l;\nstring s;\n\nvoid consume(state &begin,char expected){\n    if(*begin==expected) ++begin;\n    else{\n        cerr << \"Exptected '\" << expected << \"' but got '\" << *begin << \"'\" << endl;\n        cerr << \"Rest string is'\";\n        while(*begin) cerr << *begin++;\n        cerr << \"'\" << endl;\n        throw parse_error();\n    }\n}\n\nvoid sequence(state&);\nvoid repetition(state&);\nvoid operation(state&);\nint number(state&);\nvector<int> memo(1000,-1);\n\nvoid sequence(state &begin){\n    while(*begin){\n        if(*begin=='(') repetition(begin);\n        else if(*begin=='U' or *begin=='D' or *begin=='L' or *begin=='R') operation(begin);\n        else break;\n    }\n}\n\nvoid repetition(state &begin){\n    int idx=begin-s.begin();\n    consume(begin,'(');\n    auto backup1=begin;\n    int depth=1;\n    while(depth){\n        if(*begin=='(') ++depth;\n        if(*begin==')') --depth;\n        ++begin;\n    }\n    --begin;\n    consume(begin,')');\n    int num=number(begin);\n    if(memo[idx]!=-1) num=memo[idx];\n    auto backup2=begin;\n    bool f=false;\n    auto initial_state=matrix;\n    int count=0;\n    rep(i,0,num){\n        begin=backup1;\n        sequence(begin);\n        if(memo[idx]!=-1 and !f){\n            ++count;\n            if(matrix==initial_state){\n                num%=count;\n                i=-1;\n                matrix=initial_state;\n                memo[idx]=num;\n                f=true;\n            }\n        }\n    }\n    begin=backup2;\n}\n\nvoid operation(state &begin){\n    char d=*begin;\n    ++begin;\n    int num=number(begin);\n    if(d=='L') rotate(matrix[num-1].begin(),matrix[num-1].begin()+1,matrix[num-1].end());\n    if(d=='R') rotate(matrix[num-1].rbegin(),matrix[num-1].rbegin()+1,matrix[num-1].rend());\n    if(d=='U'){\n        vector<int> v;\n        rep(i,0,n) v.push_back(matrix[i][num-1]);\n        rotate(v.begin(),v.begin()+1,v.end());\n        rep(i,0,n) matrix[i][num-1]=v[i];\n    }\n    if(d=='D'){\n        vector<int> v;\n        rep(i,0,n) v.push_back(matrix[i][num-1]);\n        rotate(v.rbegin(),v.rbegin()+1,v.rend());\n        rep(i,0,n) matrix[i][num-1]=v[i];\n    }\n}\n\nint number(state &begin){\n    int res=0;\n    while(isdigit(*begin)){\n        res*=10;\n        res+=*begin-'0';\n        ++begin;\n    }\n    return res;\n}\n\nvoid solve(){\n    cin >> n >> l >> s;\n    matrix.resize(n);\n    rep(i,0,n){\n        matrix[i].resize(n);\n        rep(j,0,n) matrix[i][j]=i*n+j;\n    }\n    state begin=s.begin();\n    sequence(begin);\n    rep(i,0,n){\n        rep(j,0,n){\n            cout << matrix[i][j]+1;\n            if(j!=n-1) cout << \" \";\n        }\n        cout << endl;\n    }\n}\n\nint main(){\n    std::cin.tie(0);\n    std::ios::sync_with_stdio(false);\n    cout.setf(ios::fixed);\n    cout.precision(10);\n    solve();\n    return 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\nusing namespace std;\n\n#define rep(i,x,y) for(int i=(x);i<(y);++i)\n#define debug(x) #x << \"=\" << (x)\n\n#ifdef DEBUG\n#define _GLIBCXX_DEBUG\n#define print(x) std::cerr << debug(x) << \" (L:\" << __LINE__ << \")\" << std::endl\n#else\n#define print(x)\n#endif\n\nconst int inf=1e9;\nconst int64_t inf64=1e18;\nconst double eps=1e-9;\n\ntemplate <typename T> ostream &operator<<(ostream &os, const vector<T> &vec){\n    os << \"[\";\n    for (const auto &v : vec) {\n    \tos << v << \",\";\n    }\n    os << \"]\";\n    return os;\n}\n\ntypedef string::const_iterator state;\nclass parse_error{};\nvector<vector<int>> matrix;\nint n,l;\nstring s;\n\nvoid consume(state &begin,char expected){\n    if(*begin==expected) ++begin;\n    else{\n        cerr << \"Exptected '\" << expected << \"' but got '\" << *begin << \"'\" << endl;\n        cerr << \"Rest string is'\";\n        while(*begin) cerr << *begin++;\n        cerr << \"'\" << endl;\n        throw parse_error();\n    }\n}\n\nvoid sequence(state&);\nvoid repetition(state&);\nvoid operation(state&);\nint number(state&);\n\nvoid sequence(state &begin){\n    while(*begin){\n        if(*begin=='(') repetition(begin);\n        else operation(begin);\n    }\n}\n\nvoid repetition(state &begin){\n    consume(begin,'(');\n    auto backup1=begin;\n    while(*begin!=')') ++begin;\n    consume(begin,')');\n    int num=number(begin);\n    auto backup2=begin;\n    rep(i,0,num){\n        begin=backup1;\n        sequence(begin);\n    }\n    begin=backup2;\n}\n\nvoid operation(state &begin){\n    char d=*begin;\n    ++begin;\n    int num=number(begin);\n    if(d=='L') rotate(matrix[num-1].begin(),matrix[num-1].begin()+1,matrix[num-1].end());\n    if(d=='R') rotate(matrix[num-1].rbegin(),matrix[num-1].rbegin()+1,matrix[num-1].rend());\n    if(d=='U'){\n        vector<int> v;\n        rep(i,0,n) v.push_back(matrix[i][num-1]);\n        rotate(v.begin(),v.begin()+1,v.end());\n        rep(i,0,n) matrix[i][num-1]=v[i];\n    }\n    if(d=='D'){\n        vector<int> v;\n        rep(i,0,n) v.push_back(matrix[i][num-1]);\n        rotate(v.rbegin(),v.rbegin()+1,v.rend());\n        rep(i,0,n) matrix[i][num-1]=v[i];\n    }\n}\n\nint number(state &begin){\n    int res=0;\n    while(isdigit(*begin)){\n        res*=10;\n        res+=*begin-'0';\n        ++begin;\n    }\n    return res;\n}\n\nvoid solve(){\n    cin >> n >> l >> s;\n    matrix.resize(n);\n    rep(i,0,n){\n        matrix[i].resize(n);\n        rep(j,0,n) matrix[i][j]=i*n+j;\n    }\n    state begin=s.begin();\n    sequence(begin);\n    rep(i,0,n){\n        rep(j,0,n){\n            cout << matrix[i][j]+1;\n            if(j!=n-1) cout << \" \";\n        }\n        cout << endl;\n    }\n}\n\nint main(){\n    std::cin.tie(0);\n    std::ios::sync_with_stdio(false);\n    cout.setf(ios::fixed);\n    cout.precision(10);\n    solve();\n    return 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include <iostream>\n#include <string>\n#include <algorithm>\n#include <vector>\n#include <queue>\n#include <functional>\nusing namespace std;\n\nusing ll = long long int;\nstring S;\nint pos;\nint N, L;\nvector<int> sequence() {\n\tvector<int> now;\n\tfor (int i = 0; i < N*N; i++) now.push_back(i);\n\twhile (pos < L && S[pos] != ')') {\n\t\tif (S[pos] == '(') {\n\t\t\tpos++;\n\t\t\tvector<int> ret = sequence();\n\t\t\tpos++;\n\t\t\tint num = 0;\n\t\t\twhile (isdigit(S[pos])) {\n\t\t\t\tnum *= 10;\n\t\t\t\tnum += S[pos] - '0';\n\t\t\t\tpos++;\n\t\t\t}\n\t\t\t// (ret)num\n\t\t\tvector<vector<int>> d(30, vector<int>(N*N));\n\t\t\td[0] = ret;\n\t\t\tfor (int i = 1; i < 30; ++i) {\n\t\t\t\t// d[i]\n\t\t\t\tfor (int j = 0; j < N*N; ++j) {\n\t\t\t\t\td[i][j] = d[i - 1][d[i - 1][j]];\n\t\t\t\t}\n\t\t\t}\n\n\t\t\t// numを2べきで分解\n\t\t\tfor (int i = 0; i < 30; ++i) {\n\t\t\t\tif (num & 1 << i) {\n\t\t\t\t\tfor (int j = 0; j < N*N; ++j) {\n\t\t\t\t\t\tnow[j] = d[i][now[j]];\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t\telse {\n\t\t\tchar shift = S[pos];\n\t\t\tpos++;\n\t\t\tint num = 0;\n\t\t\twhile (isdigit(S[pos])) {\n\t\t\t\tnum *= 10;\n\t\t\t\tnum += S[pos] - '0';\n\t\t\t\tpos++;\n\t\t\t}\n\t\t\tnum--;\n\t\t\tif (shift == 'L') {\n\t\t\t\tfor (int i = 0; i < N*N; ++i) {\n\t\t\t\t\tint y = now[i] / N, x = now[i]%N;\n\t\t\t\t\tif (y == num) {\n\t\t\t\t\t\tif (x == 0) x = N - 1;\n\t\t\t\t\t\telse x--;\n\t\t\t\t\t\tnow[i] = x + y*N;\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t} else if (shift == 'R') {\n\t\t\t\tfor (int i = 0; i < N*N; ++i) {\n\t\t\t\t\tint y = now[i] / N, x = now[i] % N;\n\t\t\t\t\tif (y == num) {\n\t\t\t\t\t\tif (x == N-1) x = 0;\n\t\t\t\t\t\telse x++;\n\t\t\t\t\t\tnow[i] = x + y*N;\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t}\n\t\t\telse if (shift == 'U') {\n\t\t\t\tfor (int i = 0; i < N*N; ++i) {\n\t\t\t\t\tint y = now[i] / N, x = now[i] % N;\n\t\t\t\t\tif (x == num) {\n\t\t\t\t\t\tif (y == 0) y = N - 1;\n\t\t\t\t\t\telse y--;\n\t\t\t\t\t\tnow[i] = x + y*N;\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t}\n\t\t\telse if (shift == 'D') {\n\t\t\t\tfor (int i = 0; i < N*N; ++i) {\n\t\t\t\t\tint y = now[i] / N, x = now[i] % N;\n\t\t\t\t\tif (x == num) {\n\t\t\t\t\t\tif (y == N-1) y = 0;\n\t\t\t\t\t\telse y++;\n\t\t\t\t\t\tnow[i] = x + y*N;\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t}\n\treturn now;\n}\nint main() {\n\tcin >> N >> L;\n\tcin >> S;\n\tpos = 0;\n\n\tvector<int> ret = sequence();\n\tvector<vector<int>> ans(N, vector<int>(N));\n\tfor (int i = 0; i < N*N; ++i) {\n\t\tint x = ret[i]%N, y = ret[i] / N;\n\t\tans[y][x] = i+1;\n\t}\n\tfor (int i = 0; i < N; ++i) {\n\t\tfor (int j = 0; j < N; ++j) {\n\t\t\tcout << ans[i][j] << (j == N-1 ? '\\n' : ' ');\n\t\t}\n\t}\n}\n"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\n#define GET_MACRO(_1,_2,_3,_4,_5,NAME,...) NAME\n#define pr(...) GET_MACRO(__VA_ARGS__,pr5,pr4,pr3,pr2,pr1)(__VA_ARGS__)\n#define pr1(a) (#a)<<\"=\"<<(a)\n#define pr2(a,b) pr1(a)<<\", \"<<pr1(b)\n#define pr3(a,b,c) pr2(a,b)<<\", \"<<pr1(c)\n#define pr4(a,b,c,d) pr3(a,b,c)<<\", \"<<pr1(d)\n#define pr5(a,b,c,d,e) pr4(a,b,c,d)<<\", \"<<pr1(e)\n#define int long long\n#define double long double\nusing namespace std;\nconst int N = 100010;\nconst int INF = 1LL<<55;\nconst int mod = (1e9)+7;\nconst double EPS = 1e-8;\nconst double PI = 6.0 * asin(0.5);\ntypedef pair<int,int> P;\ntypedef long long ll;\ntemplate<class T> T Max(T &a,T b){return a=max(a,b);}\ntemplate<class T> T Min(T &a,T b){return a=min(a,b);}\n//ostream& operator<<(ostream& o,P p){return o<<\"(\"<<p.first<<\",\"<<p.second<<\")\";}\n//istream& operator>>(istream& i,P &p){return i>>p.first>>p.second;}\n//ostream& operator<<(ostream& o,vector<auto> &a){int i=0;for(auto t:a)o<<(i++?\" \":\"\")<<t;return o;}\n//istream& operator>>(istream& i,vector<auto> &a){for(auto &t:a)i>>t;return i;}\n//void prArr(auto a,string s=\" \"){int i=0;for(auto t:a)cout<<(i++?s:\"\")<<t;cout<<endl;}\n\ntypedef vector<int> vec;\ntypedef vector<vec> mat;\n\nmat move(const mat &a,const mat &b){\n  int n = a.size();\n  mat res(n,vec(n));\n\n  assert(a.size() == b.size());\n  assert(a[0].size() == b[0].size());\n  assert(a[0].size() == a.size());\n  \n  for(int i=0;i<n;i++)\n    for(int j=0;j<n;j++) {\n      int y = a[i][j] / n;\n      int x = a[i][j] % n;\n      assert(y < (int)b.size() && x < (int)b[y].size());\n      res[i][j] = b[y][x];\n    }\n  return res;\n}\n\nint n;\nint pos;\nstring str;\n\nmat bfs();\nmat repeat();\nint number();\n  \nmat repeat(){\n  assert(str[pos] == '(');\n  pos++;\n  mat x = bfs();\n  assert(str[pos]==')');\n  pos++;\n  int num = number();\n  \n  mat res(n,vec(n));\n  for(int i=0;i<n;i++)\n    for(int j=0;j<n;j++) res[i][j] = i * n + j;\n\n  while(num){\n    if(num%2) res = move(res,x);\n    x = move(x,x);\n    num /= 2;\n  }\n  return res;\n}\n\nint number(){\n  assert(isdigit(str[pos]));\n  int res = 0;\n  while(pos < (int)str.size() && isdigit(str[pos])) res = res * 10 + str[pos++] - '0';\n  return res;\n}\n\nvoid L(mat &A){\n  assert(str[pos++] == 'L');\n  int k = number() - 1;\n  for(int i=0;i<n-1;i++) swap(A[k][i],A[k][i+1]);\n}\n\nvoid R(mat &A){\n  assert(str[pos++] == 'R');\n  int k = number() - 1;\n  for(int i=0;i<n-1;i++) swap(A[k][n-1-i],A[k][n-2-i]);\n};\n\nmat U(mat &A){\n  assert(str[pos++] == 'U');\n  int k = number() - 1;\n  for(int i=0;i<n-1;i++) swap(A[i][k],A[i+1][k]);\n};\n\nmat D(mat &A){\n  assert(str[pos++] == 'D');\n  int k = number() - 1;\n  for(int i=0;i<n-1;i++) swap(A[n-1-i][k],A[n-2-i][k]);\n};\n\nmat bfs(){\n  mat res(n,vec(n));\n  for(int i=0;i<n;i++)\n    for(int j=0;j<n;j++) res[i][j] = i*n + j;\n  \n  while(pos < (int)str.size()){\n    char ch = str[pos];\n    if(ch == '(') res = repeat();\n    else if(ch == 'L') L(res);\n    else if(ch == 'R') R(res);\n    else if(ch == 'U') U(res);\n    else if(ch == 'D') D(res);\n    else break;\n  }\n  return res;\n}\n\nsigned main(){\n  int L;\n  cin>>n>>L;\n  cin>>str;\n  \n  \n  mat ans = bfs();\n  for(int i=0;i<n;i++)\n    for(int j=0;j<n;j++) ans[i][j] ++;\n  \n  for(int i=0;i<n;i++) {\n    for(int j=0;j<n;j++){\n      if(j) cout<<\" \";\n      cout<<ans[i][j];\n    }\n    cout<<endl;\n  }\n  \n  return 0;\n}\n\n"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\n\nusing namespace std;\n\ntypedef vector< int > vi;\n\nvi mat;\nint N, L, idx;\nstring S;\n\nvi press(vi a, vi b)\n{\n  for(int i = 0; i < N * N; i++) b[i] = a[b[i]];\n  return (b);\n}\n\n\nvi fact(vi &v, int k)\n{\n  vi ret = mat;\n  while(k > 0) {\n    if(k & 1) ret = press(ret, v);\n    v = press(v, v);\n    k /= 2;\n  }\n  return (ret);\n}\n\nint num()\n{\n  int ret = 0;\n  while(idx < S.size() && isdigit(S[idx])) {\n    ret = ret * 10 + S[idx++] - '0';\n  }\n  return (ret);\n}\n\nvi sequence()\n{\n  if(idx == S.size() || S[idx] == ')') return (mat);\n  vi ret = mat;\n  if(S[idx] == '(') {\n    ++idx;\n    vi get = sequence();\n    ++idx;\n    ret = fact(get, num());\n  } else if(S[idx] == 'L') {\n    ++idx;\n    int rep = num() - 1;\n    for(int i = 0; i < N; i++) ret[rep * N + i] = rep * N + (i + 1) % N;\n  } else if(S[idx] == 'R') {\n    ++idx;\n    int rep = num() - 1;\n    for(int i = 0; i < N; i++) ret[rep * N + i] = rep * N + (i + N - 1) % N;\n  } else if(S[idx] == 'U') {\n    ++idx;\n    int rep = num() - 1;\n    for(int i = 0; i < N; i++) ret[i * N + rep] = (i + 1) % N * N + rep;\n  } else {\n    ++idx;\n    int rep = num() - 1;\n    for(int i = 0; i < N; i++) ret[i * N + rep] = (i + N - 1) % N * N + rep;\n  }\n  return (press(ret, sequence()));\n}\n\nint main()\n{\n  cin >> N >> L;\n  cin >> S;\n\n  mat.resize(N * N);\n  iota(begin(mat), end(mat), 0);\n  auto ret = sequence();\n\n  for(int i = 0; i < N; i++) {\n    for(int j = 0; j < N; j++) {\n      if(j > 0) cout << \" \";\n      cout << ret[i * N + j] + 1;\n    }\n    cout << endl;\n  }\n}"
  },
  {
    "language": "C++",
    "code": "#include <iostream>\n#include <numeric>\n#include <vector>\n#include <string>\n#include <cassert>\n\nstruct Mat {\n    static int n;\n    std::vector<int> mat;\n\n    Mat(char d = '$', int x = 0) : mat(n * n) {\n        std::iota(mat.begin(), mat.end(), 0);\n\n        if (d == 'L') {\n            int tmp = mat[n * x + (n - 1)];\n            for (int i = n - 1; i > 0; --i) {\n                mat[n * x + i] = mat[n * x + (i - 1)];\n            }\n            mat[n * x + 0] = tmp;\n\n        } else if (d == 'R') {\n            int tmp = mat[n * x + 0];\n            for (int i = 0; i < n - 1; ++i) {\n                mat[n * x + i] = mat[n * x + (i + 1)];\n            }\n            mat[n * x + (n - 1)] = tmp;\n\n        } else if (d == 'U') {\n            int tmp = mat[n * (n - 1) + x];\n            for (int i = n - 1; i > 0; --i) {\n                mat[n * i + x] = mat[n * (i - 1) + x];\n            }\n            mat[n * 0 + x] = tmp;\n\n        } else if (d == 'D') {\n            int tmp = mat[n * 0 + x];\n            for (int i = 0; i < n - 1; ++i) {\n                mat[n * i + x] = mat[n * (i + 1) + x];\n            }\n            mat[n * (n - 1) + x] = tmp;\n        }\n    }\n\n    Mat operator*(const Mat& m) const {\n        auto ret = Mat();\n        for (int i = 0; i < n * n; ++i) {\n            ret.mat[i] = m.mat[mat[i]];\n        }\n        return ret;\n    }\n\n    Mat pow(int n) const {\n        auto ret = Mat();\n        auto b = *this;\n        while (n > 0) {\n            if (n & 1) ret = ret * b;\n            n >>= 1;\n            b = b * b;\n        }\n        return ret;\n    }\n};\n\nint Mat::n;\n\nstruct Parser {\n    std::string s;\n    int i;\n\n    Mat seq() {\n        Mat ret;\n        while (i < (int)s.length() && s[i] != ')') {\n            if (s[i] == '(') {\n                ++i;\n                auto m = seq();\n\n                assert(s[i] == ')');\n                ++i;\n\n                int e = num();\n                ret = ret * m.pow(e);\n            } else {\n                assert(std::isupper(s[i]));\n                char c = s[i];\n                ++i;\n                int x = num() - 1;\n\n                ret = ret * Mat(c, x);\n            }\n        }\n        return ret;\n    }\n\n    int num() {\n        int ret = 0;\n        while (i < (int)s.length() && std::isdigit(s[i])) {\n            int d = s[i] - '0';\n            ret = ret * 10 + d;\n            ++i;\n        }\n        return ret;\n    }\n\n    Mat parse(const std::string& _s) {\n        s = _s;\n        i = 0;\n        return seq();\n    }\n};\n\nvoid solve() {\n    int n, l;\n    std::string s;\n    std::cin >> n >> l >> s;\n    Mat::n = n;\n\n    Parser parser;\n    auto m = parser.parse(s);\n\n    std::vector<int> ans(n * n);\n    for (int i = 0; i < n * n; ++i) {\n        ans[m.mat[i]] = i;\n    }\n\n    for (int i = 0; i < n * n; ++i) {\n        std::cout << ans[i] + 1 << \" \\n\"[i % n == n - 1];\n    }\n}\n\nint main() {\n    std::cin.tie(nullptr);\n    std::cout.tie(nullptr);\n    std::ios::sync_with_stdio(false);\n\n    solve();\n\n    return 0;\n}\n\n"
  },
  {
    "language": "C++",
    "code": "#include <iostream>\n#include <vector>\n\nusing namespace std;\n\nint N;\nvector<int> L(int n){\n    vector<int> V(N*N);\n    for(int i=0;i<N*N;i++) V[i]=i;\n    for(int i=N*(n-1);i<N*n-1;i++){\n        V[i]=i+1;\n    }\n    V[N*n-1]=N*(n-1);\n    return V;\n}\n\nvector<int> R(int n){\n    vector<int> V(N*N);\n    for(int i=0;i<N*N;i++) V[i]=i;\n    for(int i=N*(n-1)+1;i<N*n;i++){\n        V[i]=i-1;\n    }\n    V[N*(n-1)]=N*n-1;\n    return V;\n}\n\nvector<int> U(int n){\n    vector<int> V(N*N);\n    for(int i=0;i<N*N;i++) V[i]=i;\n    for(int i=n-1;i+N<N*N;i+=N) V[i]+=N; \n    V[N*(N-1)+(n-1)]=n-1;\n    return V;\n}\n\nvector<int> D(int n){\n    vector<int> V(N*N);\n    for(int i=0;i<N*N;i++) V[i]=i;\n    for(int i=N+n-1;i<N*N;i+=N) V[i]-=N;\n    V[n-1]=N*(N-1)+(n-1);\n    return V;\n}   \n\nvector<int> C(vector<int> V1, vector<int> V2){\n    vector<int> V(N*N);\n    for(int i=0;i<N*N;i++) V[i]=V1[V2[i]];\n    return V;\n}\n\nvector<int> T(vector<int> V ,int n){\n    int b=1;\n    vector<int> B=V;\n    vector<int> ret(N*N);\n    for(int i=0;i<N*N;i++) ret[i]=i;\n    while(n>=b){\n        if(b&n){\n            ret=C(ret,B);\n        }\n        B=C(B,B);\n        b<<=1;\n    }\n    return ret;\n}\n\nint number(string S, int& ite){\n    int n=0;\n    while('0'<=S[ite]&&S[ite]<='9'){\n        n*=10;\n        n+=S[ite]-'0';\n        ite++;//??????????????§???')'???????°?\n    }\n    return n;\n}\n\nvector<int> rec(string S, int& ite){\n    vector<int> ret(N*N),fac;\n    for(int i=0;i<N*N;i++) ret[i]=i;\n    while(ite<S.size()){\n        if(S[ite]=='('){\n            ite++;\n            fac=rec(S,ite);\n            ite++;//')'??????????£???°???\n            fac=T(fac,number(S,ite));\n            ret=C(ret,fac);\n        }else{\n            if(S[ite]=='R'){\n                ite++;\n                fac=R(number(S,ite));\n            }else if(S[ite]=='L'){\n                ite++;\n                fac=L(number(S,ite));\n            }else if(S[ite]=='D'){\n                ite++;\n                fac=D(number(S,ite));\n            }else if(S[ite]=='U'){\n                ite++;\n                fac=U(number(S,ite));\n            }else{\n                cout<<\"err\"<<endl;\n                exit(1);\n            }\n            ret=C(ret,fac);\n        }\n        if(S[ite]==')') break;\n    }\n    return ret;\n}\n\nint main(){\n    int l;\n    cin>>N>>l;\n    string S;\n    cin>>S;\n    if(N==1){\n        cout<<1<<endl;\n        return 0;\n    }\n    int i=0;\n    vector<int> ans = rec(S,i);\n    for(int i=0;i<N;i++){\n        for(int j=0;j<N;j++){\n            if(j)cout<<' ';\n            cout<<ans[i*N+j]+1;\n        }\n        cout<<endl;\n    }\n\n    return 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\n#define GET_MACRO(_1,_2,_3,_4,_5,NAME,...) NAME\n#define pr(...) GET_MACRO(__VA_ARGS__,pr5,pr4,pr3,pr2,pr1)(__VA_ARGS__)\n#define pr1(a) (#a)<<\"=\"<<(a)\n#define pr2(a,b) pr1(a)<<\", \"<<pr1(b)\n#define pr3(a,b,c) pr2(a,b)<<\", \"<<pr1(c)\n#define pr4(a,b,c,d) pr3(a,b,c)<<\", \"<<pr1(d)\n#define pr5(a,b,c,d,e) pr4(a,b,c,d)<<\", \"<<pr1(e)\n#define int long long\n#define double long double\nusing namespace std;\nconst int N = 100010;\nconst int INF = 1LL<<55;\nconst int mod = (1e9)+7;\nconst double EPS = 1e-8;\nconst double PI = 6.0 * asin(0.5);\ntypedef pair<int,int> P;\ntypedef long long ll;\ntemplate<class T> T Max(T &a,T b){return a=max(a,b);}\ntemplate<class T> T Min(T &a,T b){return a=min(a,b);}\n//ostream& operator<<(ostream& o,P p){return o<<\"(\"<<p.first<<\",\"<<p.second<<\")\";}\n//istream& operator>>(istream& i,P &p){return i>>p.first>>p.second;}\n//ostream& operator<<(ostream& o,vector<auto> &a){int i=0;for(auto t:a)o<<(i++?\" \":\"\")<<t;return o;}\n//istream& operator>>(istream& i,vector<auto> &a){for(auto &t:a)i>>t;return i;}\n//void prArr(auto a,string s=\" \"){int i=0;for(auto t:a)cout<<(i++?s:\"\")<<t;cout<<endl;}\n\ntypedef vector<int> vec;\ntypedef vector<vec> mat;\n\nmat move(mat a,mat b){\n  int n = a.size();\n  mat res(n,vec(n));\n\n  assert(a.size() == b.size());\n  assert(a[0].size() == b[0].size());\n  assert(a[0].size() == a.size());\n\n  for(int i=0;i<n;i++)\n    for(int j=0;j<n;j++) {\n      int y = a[i][j] / n;\n      int x = a[i][j] % n;\n      res[i][j] = b[y][x];\n    }\n  return res;\n}\n\nint n,len;\nint pos;\nstring str;\n\nmat bfs();\nmat repeat();\nint number();\n  \nmat repeat(){\n  assert(str[pos] == '(');\n  pos++;\n  mat x = bfs();\n  assert(str[pos]==')');\n  pos++;\n  int num = number();\n  \n  mat res(n,vec(n));\n  for(int i=0;i<n;i++)\n    for(int j=0;j<n;j++) res[i][j] = i * n + j;\n\n  while(num){\n    if(num%2) res = move(res,x);\n    x = move(x,x);\n    num = num/2;\n  }\n  return res;\n}\n\nint number(){\n  assert(isdigit(str[pos]));\n  int res = 0;\n  while(isdigit(str[pos])) res = res * 10 + str[pos] - '0', pos++;\n  return res;\n}\n\nvoid L(mat &A){\n  assert(str[pos++] == 'L');\n  int k = number() - 1;\n  for(int i=0;i<n-1;i++) swap(A[k][i],A[k][i+1]);\n}\n\nvoid R(mat &A){\n  assert(str[pos++] == 'R');\n  int k = number() - 1;\n  for(int i=0;i<n-1;i++) swap(A[k][n-1-i],A[k][n-2-i]);\n};\n\nmat U(mat &A){\n  assert(str[pos++] == 'U');\n  int k = number() - 1;\n  for(int i=0;i<n-1;i++) swap(A[i][k],A[i+1][k]);\n};\nmat D(mat &A){\n  assert(str[pos++] == 'D');\n  int k = number() - 1;\n  for(int i=0;i<n-1;i++) swap(A[n-1-i][k],A[n-2-i][k]);\n};\n\nmat bfs(){\n  mat res(n,vec(n));\n  for(int i=0;i<n;i++)\n    for(int j=0;j<n;j++) res[i][j] = i*n + j;\n  \n  while(pos < (int)str.size()){\n    char ch = str[pos];\n    if(ch == '(') res = repeat();\n    else if(ch == 'L') L(res);\n    else if(ch == 'R') R(res);\n    else if(ch == 'U') U(res);\n    else if(ch == 'D') D(res);\n    else break;\n  }\n  return res;\n}\n\nsigned main(){\n  int L;\n  cin>>n>>L;\n  cin>>str;\n  \n  mat ans = bfs();\n  for(int i=0;i<n;i++)\n    for(int j=0;j<n;j++) ans[i][j] ++;\n  \n  for(int i=0;i<n;i++) {\n    for(int j=0;j<n;j++){\n      if(j) cout<<\" \";\n      cout<<ans[i][j];\n    }\n    cout<<endl;\n  }\n  \n  return 0;\n}\n\n"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\n#define GET_MACRO(_1,_2,_3,_4,_5,NAME,...) NAME\n#define pr(...) GET_MACRO(__VA_ARGS__,pr5,pr4,pr3,pr2,pr1)(__VA_ARGS__)\n#define pr1(a) (#a)<<\"=\"<<(a)\n#define pr2(a,b) pr1(a)<<\", \"<<pr1(b)\n#define pr3(a,b,c) pr2(a,b)<<\", \"<<pr1(c)\n#define pr4(a,b,c,d) pr3(a,b,c)<<\", \"<<pr1(d)\n#define pr5(a,b,c,d,e) pr4(a,b,c,d)<<\", \"<<pr1(e)\n#define int long long\n#define double long double\nusing namespace std;\nconst int N = 100010;\nconst int INF = 1LL<<55;\nconst int mod = (1e9)+7;\nconst double EPS = 1e-8;\nconst double PI = 6.0 * asin(0.5);\ntypedef pair<int,int> P;\ntypedef long long ll;\ntemplate<class T> T Max(T &a,T b){return a=max(a,b);}\ntemplate<class T> T Min(T &a,T b){return a=min(a,b);}\n//ostream& operator<<(ostream& o,P p){return o<<\"(\"<<p.first<<\",\"<<p.second<<\")\";}\n//istream& operator>>(istream& i,P &p){return i>>p.first>>p.second;}\n//ostream& operator<<(ostream& o,vector<auto> &a){int i=0;for(auto t:a)o<<(i++?\" \":\"\")<<t;return o;}\n//istream& operator>>(istream& i,vector<auto> &a){for(auto &t:a)i>>t;return i;}\n//void prArr(auto a,string s=\" \"){int i=0;for(auto t:a)cout<<(i++?s:\"\")<<t;cout<<endl;}\n\ntypedef vector<int> vec;\ntypedef vector<vec> mat;\n\nmat move(mat a,mat b){\n  int n = a.size();\n  mat res(n,vec(n));\n\n  assert(a.size() == b.size());\n  assert(a[0].size() == b[0].size());\n  assert(a[0].size() == a.size());\n  \n  for(int i=0;i<n;i++)\n    for(int j=0;j<n;j++) {\n      int y = a[i][j] / n;\n      int x = a[i][j] % n;\n      assert(y < (int)b.size() && x < (int)b[y].size());\n      \n      res[i][j] = b[y][x];\n    }\n  return res;\n}\n\nint n;\nint pos;\nstring str;\n\nmat bfs();\nmat repeat();\nint number();\n  \nmat repeat(){\n  assert(str[pos] == '(');\n  pos++;\n  mat x = bfs();\n  assert(str[pos]==')');\n  pos++;\n  int num = number();\n  \n  mat res(n,vec(n));\n  for(int i=0;i<n;i++)\n    for(int j=0;j<n;j++) res[i][j] = i * n + j;\n\n  while(num){\n    if(num%2) res = move(res,x);\n    x = move(x,x);\n    num /= 2;\n  }\n  return res;\n}\n\nint number(){\n  assert(isdigit(str[pos]));\n  int res = 0;\n  while(pos < (int)str.size() && isdigit(str[pos])) res = res * 10 + str[pos++] - '0';\n  return res;\n}\n\nvoid L(mat &A){\n  assert(str[pos++] == 'L');\n  int k = number() - 1;\n  for(int i=0;i<n-1;i++) swap(A[k][i],A[k][i+1]);\n}\n\nvoid R(mat &A){\n  assert(str[pos++] == 'R');\n  int k = number() - 1;\n  for(int i=0;i<n-1;i++) swap(A[k][n-1-i],A[k][n-2-i]);\n};\n\nmat U(mat &A){\n  assert(str[pos++] == 'U');\n  int k = number() - 1;\n  for(int i=0;i<n-1;i++) swap(A[i][k],A[i+1][k]);\n};\n\nmat D(mat &A){\n  assert(str[pos++] == 'D');\n  int k = number() - 1;\n  for(int i=0;i<n-1;i++) swap(A[n-1-i][k],A[n-2-i][k]);\n};\n\nmat bfs(){\n  mat res(n,vec(n));\n  for(int i=0;i<n;i++)\n    for(int j=0;j<n;j++) res[i][j] = i*n + j;\n  \n  while(pos < (int)str.size()){\n    char ch = str[pos];\n    if(ch == '(') res = repeat();\n    else if(ch == 'L') L(res);\n    else if(ch == 'R') R(res);\n    else if(ch == 'U') U(res);\n    else if(ch == 'D') D(res);\n    else break;\n  }\n  return res;\n}\n\nsigned main(){\n  int L;\n  cin>>n>>L;\n  cin>>str;\n  \n  \n  mat ans = bfs();\n  for(int i=0;i<n;i++)\n    for(int j=0;j<n;j++) ans[i][j] ++;\n  \n  for(int i=0;i<n;i++) {\n    for(int j=0;j<n;j++){\n      if(j) cout<<\" \";\n      cout<<ans[i][j];\n    }\n    cout<<endl;\n  }\n  \n  return 0;\n}\n\n"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\nusing namespace std;\n\n#define rep(i,x,y) for(int i=(x);i<(y);++i)\n#define debug(x) #x << \"=\" << (x)\n\n#ifdef DEBUG\n#define _GLIBCXX_DEBUG\n#define print(x) std::cerr << debug(x) << \" (L:\" << __LINE__ << \")\" << std::endl\n#else\n#define print(x)\n#endif\n\nconst int inf=1e9;\nconst int64_t inf64=1e18;\nconst double eps=1e-9;\n\ntemplate <typename T> ostream &operator<<(ostream &os, const vector<T> &vec){\n    os << \"[\";\n    for (const auto &v : vec) {\n    \tos << v << \",\";\n    }\n    os << \"]\";\n    return os;\n}\n\ntypedef string::const_iterator state;\nclass parse_error{};\nvector<vector<int>> matrix;\nint n,l;\nstring s;\n\nvoid consume(state &begin,char expected){\n    if(*begin==expected) ++begin;\n    else{\n        cerr << \"Exptected '\" << expected << \"' but got '\" << *begin << \"'\" << endl;\n        cerr << \"Rest string is'\";\n        while(*begin) cerr << *begin++;\n        cerr << \"'\" << endl;\n        throw parse_error();\n    }\n}\n\nvoid sequence(state&);\nvoid repetition(state&);\nvoid operation(state&);\nint number(state&);\n\nvoid sequence(state &begin){\n    while(*begin){\n        if(*begin=='(') repetition(begin);\n        else operation(begin);\n    }\n}\n\nvoid repetition(state &begin){\n    consume(begin,'(');\n    auto backup1=begin;\n    int depth=1;\n    while(depth){\n        ++begin;\n        if(*begin=='(') ++depth;\n        if(*begin==')') --depth;\n    }\n    consume(begin,')');\n    int num=number(begin);\n    auto backup2=begin;\n    rep(i,0,num){\n        begin=backup1;\n        sequence(begin);\n    }\n    begin=backup2;\n}\n\nvoid operation(state &begin){\n    char d=*begin;\n    ++begin;\n    int num=number(begin);\n    if(d=='L') rotate(matrix[num-1].begin(),matrix[num-1].begin()+1,matrix[num-1].end());\n    if(d=='R') rotate(matrix[num-1].rbegin(),matrix[num-1].rbegin()+1,matrix[num-1].rend());\n    if(d=='U'){\n        vector<int> v;\n        rep(i,0,n) v.push_back(matrix[i][num-1]);\n        rotate(v.begin(),v.begin()+1,v.end());\n        rep(i,0,n) matrix[i][num-1]=v[i];\n    }\n    if(d=='D'){\n        vector<int> v;\n        rep(i,0,n) v.push_back(matrix[i][num-1]);\n        rotate(v.rbegin(),v.rbegin()+1,v.rend());\n        rep(i,0,n) matrix[i][num-1]=v[i];\n    }\n}\n\nint number(state &begin){\n    int res=0;\n    while(isdigit(*begin)){\n        res*=10;\n        res+=*begin-'0';\n        ++begin;\n    }\n    return res;\n}\n\nvoid solve(){\n    cin >> n >> l >> s;\n    matrix.resize(n);\n    rep(i,0,n){\n        matrix[i].resize(n);\n        rep(j,0,n) matrix[i][j]=i*n+j;\n    }\n    state begin=s.begin();\n    sequence(begin);\n    rep(i,0,n){\n        rep(j,0,n){\n            cout << matrix[i][j]+1;\n            if(j!=n-1) cout << \" \";\n        }\n        cout << endl;\n    }\n}\n\nint main(){\n    std::cin.tie(0);\n    std::ios::sync_with_stdio(false);\n    cout.setf(ios::fixed);\n    cout.precision(10);\n    solve();\n    return 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include<iostream>\n#include<cstdio>\n#include<vector>\n#include<string>\n#include<cstring>\n#include<functional>\n#include<stack>\n#include<queue>\n#include <iomanip>\n#include<map>\n#include<limits>\n#include<cmath>\n#include<algorithm>\n#include<bitset>\n#include<utility>\n#include<complex>\n#include<cstdlib>\n#include<set>\n#include<cctype>\n\n#define DBG cerr << '!' << endl;\n#define REP(i,n) for(int (i) = (0);(i) < (n);++i)\n#define rep(i,s,g) for(int (i) = (s);(i) < (g);++i)\n#define rrep(i,s,g) for(int (i) = (s);i >= (g);--(i))\n#define PB push_back\n#define MP make_pair\n#define FI first\n#define SE second\n#define SHOW1d(v,n) {for(int W = 0;W < (n);W++)cerr << v[W] << ' ';cerr << endl << endl;}\n#define SHOW2d(v,i,j) {for(int aaa = 0;aaa < i;aaa++){for(int bbb = 0;bbb < j;bbb++)cerr << v[aaa][bbb] << ' ';cerr << endl;}cerr << endl;}\n#define ALL(v) v.begin(),v.end()\n#define Decimal fixed<<setprecision(10)\n\nusing namespace std;\n\ntypedef long long ll;\ntypedef vector<int> iv;\ntypedef vector<iv> iiv;\ntypedef vector<string> sv;\n\ntypedef vector<vector<pair<int,int> > >  Mat;\n\nstring str;\nint n,pointer;\n\nMat calMat(Mat a,Mat b);\nMat readSequence();\nint readNum();\nMat init();\n\nint ans[101][101];\n\nMat init()\n{\n\tMat ret;\n\tREP(i,n)\n\t{\n\t\tvector<pair<int,int> > tmp;\n\t\tREP(j,n)\n\t\t{\n\t\t\ttmp.PB(MP(i,j));\n\t\t}\n\t\tret.PB(tmp);\n\t}\n\treturn ret;\n}\n\nint readNum()\n{\n\tint ret = 0;\n\twhile(isdigit(str[pointer]))\n\t{\n\t\tret *= 10;\n\t\tret += str[pointer] - '0';\n\t\tpointer++;\n\t}\n\treturn ret;\n}\n\nMat makeShift(char c,int q)\n{\n\tMat ret = init();\n\tq--;\n\tpair<int,int> tmp;\n\tif(c == 'U')\n\t{\n\t\ttmp = ret[n-1][q];\n\t\tfor(int i = n-1;i > 0;i--)ret[i][q] = ret[i-1][q];\n\t\tret[0][q] = tmp;\n\t}\n\telse if(c == 'D')\n\t{\n\t\ttmp = ret[0][q];\n\t\tfor(int i = 0;i < n-1;i++)ret[i][q] = ret[i+1][q];\n\t\tret[n-1][q] = tmp;\n\t}\n\telse if(c == 'R')\n\t{\n\t\ttmp = ret[q][0];\n\t\tfor(int i = 0;i < n-1;i++)ret[q][i] = ret[q][i+1];\n\t\tret[q][n-1] = tmp;\n\t}\n\telse\n\t{\n\t\ttmp = ret[q][n-1];\n\t\tfor(int i = n-1;i > 0;i--)ret[q][i] = ret[q][i-1];\n\t\tret[q][0] = tmp;\n\t}\n\treturn ret;\n}\n\nMat power(Mat m,int n)\n{\n\tMat tmp = m;\n\tMat ret = init();\n\twhile(n)\n\t{\n\t\tif(n & 1)\n\t\t{\n\t\t\tret = calMat(ret,tmp);\n\t\t}\n\t\ttmp = calMat(tmp,tmp);\n\t\tn >>= 1;\n\t}\n\treturn ret;\n}\n\nMat readSequence()\n{\n\tMat ret = init();\n\t\n\tfor(pointer = 0;pointer < str.size();)\n\t{\n\t\tif(str[pointer] == '(')\n\t\t{\n\t\t\tpointer++;\n\t\t\tcontinue;\n\t\t}\n\t\telse if(str[pointer] == ')')\n\t\t{\n\t\t\tpointer++;\n\t\t\tint num = readNum();\n\t\t\tret = power(ret,num);\n\t\t}\n\t\telse\n\t\t{\n\t\t\tchar c = str[pointer];\n\t\t\tpointer++;\n\t\t\tint num = readNum();\n\t\t\tMat mat = makeShift(c,num);\n\t\t\tret = calMat(ret,mat);\n\t\t}\n\t}\n\treturn ret;\n}\n\nMat calMat(Mat a,Mat b)\n{\n\tMat ret = a;\n\tREP(i,n)\n\t{\n\t\tREP(j,n)\n\t\t{\n\t\t\tret[i][j] = b[a[i][j].FI][a[i][j].SE];\n\t\t}\n\t}\n\treturn ret;\n}\n\n\nint main()\n{\n\tint l;\n\tcin >> n >> l;\n\tcin >> str;\n\t\n\tMat mat = readSequence();\n\tint num = 1;\n\tREP(i,n)\n\t{\n\t\tREP(j,n)\n\t\t{\n\t\t\tans[mat[i][j].FI][mat[i][j].SE] = num;\n\t\t\tnum++;\n\t\t}\n\t}\n\t\n\tREP(i,n)\n\t{\n\t\tREP(j,n-1)\n\t\t{\n\t\t\tcout << ans[i][j] << ' ';\n\t\t}\n\t\tcout << ans[i][n-1] << endl;\n\t}\n\t\n\treturn 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include <algorithm>\n#include <iostream>\n#include <vector>\n#include <cctype>\n#include <numeric>\nusing namespace std;\n\nint n;\nstring s;\n\nvector<int> operator*(const vector<int> &f, const vector<int> &g) {\n    vector<int> h(n * n);\n    for (int i = 0; i < n * n; i++) h[i] = g[f[i]];\n    return h;\n}\nvector<int> operator^(vector<int> f, int n_) {\n    vector<int> res(n * n);\n    iota(res.begin(), res.end(), 0);\n    while (n_ > 0) {\n        if (n_ & 1) res = res * f;\n        f = f * f;\n        n_ >>= 1;\n    }\n    return res;\n}\nvector<int> inv(vector<int> f) {\n    vector<int> res(n * n);\n    for (int i = 0; i < n * n; i++) res[f[i]] = i;\n    return res;\n}\n\nvector<int> sequence(int &idx);\nvector<int> repetition(int &idx);\nvector<int> operation(int &idx);\nint number(int &idx);\n\n// <sequence> := <sequence><repetition> | <sequence><operation> |\n//               <repetition> | <operation>\nvector<int> sequence(int &idx) {\n    vector<int> f(n * n);\n    iota(f.begin(), f.end(), 0);\n    while (idx < s.length() && s[idx] != ')') {\n        if (s[idx] == '(') {\n            f = f * repetition(idx);\n        } else {\n            f = f * operation(idx);\n        }\n    }\n    return f;\n}\n\n// <repetition> := '('<sequence>')'<number>\nvector<int> repetition(int &idx) {\n    idx++;      // skip '('\n    vector<int> f = sequence(idx);\n    idx++;      // skip ')'\n    int num = number(idx);\n    return f ^ num;\n}\n\n// <operation> := <shift><number>\n// <shift> := 'L' | 'R' | 'U' | 'D'\nvector<int> operation(int &idx) {\n    char op = s[idx++];\n    int num = number(idx); num--;\n    vector<int> f(n * n);\n    iota(f.begin(), f.end(), 0);\n    if (op == 'L') {\n        int tmp = f[num * n + n - 1];\n        for (int i = n - 1; i > 0; i--) f[num * n + i] = f[num * n + i - 1];\n        f[num * n + 0] = tmp;\n    } else if (op == 'R') {\n        int tmp = f[num * n + 0];\n        for (int i = 0; i < n - 1; i++) f[num * n + i] = f[num * n + i + 1];\n        f[num * n + n - 1] = tmp;\n    } else if (op == 'U') {\n        int tmp = f[(n - 1) * n + num];\n        for (int i = n - 1; i > 0; i--) f[i * n + num] = f[(i - 1) * n + num];\n        f[0 * n + num] = tmp;\n    } else if (op == 'D') {\n        int tmp = f[0 * n + num];\n        for (int i = 0; i < n - 1; i++) f[i * n + num] = f[(i + 1) * n + num];\n        f[(n - 1) * n + num] = tmp;\n    }\n    return f;\n}\n\n// <number> := <nonzero_digit> | <number><digit>\n// <digit> := '0' | <nonzero_digit>\n// <nonzero_digit> := '1' | '2' | '3' | '4' | '5' | '6' | '7' | '8' | '9'\nint number(int &idx) {\n    int res = 0;\n    while (idx < s.length() && isdigit(s[idx])) {\n        res = res * 10 + s[idx++] - '0';\n    }\n    return res;\n}\n\nint main() {\n    int _; cin >> n >> _;\n    cin >> s;\n    int idx = 0;\n    vector<int> res = inv(sequence(idx));\n    for (int i = 0; i < n; i++) {\n        for (int j = 0; j < n; j++) {\n            cout << res[i * n + j] + 1 << \" \\n\"[j == n - 1];\n        }\n    }\n    return 0;\n}\n"
  },
  {
    "language": "C++",
    "code": "#include <stdio.h>\n#include <cmath>\n#include <algorithm>\n#include <cfloat>\n#include <stack>\n#include <queue>\n#include <vector>\n#include <string>\n#include <iostream>\n#include <set>\n#include <map>\n#include <time.h>\ntypedef long long int ll;\ntypedef unsigned long long int ull;\n#define BIG_NUM 2000000000\n#define MOD 1000000007\n#define EPS 0.000000001\nusing namespace std;\n\ntypedef vector<int> MATRIX;\n\nint N,SIZE,length;\nchar buf[1001];\n\nint getLoc(int row,int col){\n\treturn N*row+col;\n}\n\nMATRIX calc(MATRIX left,MATRIX next_loc){\n\n\tMATRIX ret(SIZE);\n\n\tfor(int i = 0; i < SIZE; i++){\n\t\tret[i] = left[next_loc[i]];\n\t}\n\n\treturn ret;\n\n}\n\nMATRIX pow(MATRIX next_loc,int count){\n\n\tMATRIX ret(SIZE);\n\n\tfor(int i = 0; i < SIZE; i++)ret[i] = i;\n\n\twhile(count > 0){\n\t\tif(count%2 == 1)ret = calc(ret,next_loc);\n\t\tnext_loc = calc(next_loc,next_loc);\n\t\tcount /= 2;\n\t}\n\n\treturn ret;\n}\n\nMATRIX calcNextLoc(int left,int right){\n\n\tMATRIX first_loc(SIZE),next_loc(SIZE),work(SIZE);\n\tfor(int i = 0; i < SIZE; i++)first_loc[i] = i;\n\n\tint index = left;\n\n\twhile(index <= right){\n\n\t\tif(buf[index] == '('){\n\n\t\t\tint depth = 0,next_right;\n\n\t\t\tfor(int i = index; i <= right; i++){\n\t\t\t\tif(buf[i] == '(')depth++;\n\t\t\t\telse if(buf[i] == ')'){\n\t\t\t\t\tdepth--;\n\t\t\t\t\tif(depth == 0){\n\t\t\t\t\t\tnext_right = i;\n\t\t\t\t\t\tbreak;\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t}\n\n\t\t\tnext_loc = calcNextLoc(index+1,next_right-1);\n\n\t\t\tint count = 0;\n\n\t\t\tfor(index = next_right+1;buf[index] >= '0' && buf[index] <= '9'; index++){\n\t\t\t\tcount = 10*count+buf[index]-'0';\n\t\t\t}\n\n\t\t\tif(count > 1){\n\t\t\t\tnext_loc = pow(next_loc,count);\n\t\t\t}\n\n\t\t\tfor(int i = 0; i < SIZE; i++)work[i] = next_loc[first_loc[i]];\n\t\t\tfor(int i = 0; i < SIZE; i++)first_loc[i] = work[i];\n\n\t\t}else{\n\n\t\t\tint next_right;\n\t\t\tfor(next_right = index; next_right <= right && buf[next_right] != '('; next_right++);\n\t\t\tnext_right--;\n\n\t\t\tint num,k;\n\n\t\t\tfor(int i = index; i <= next_right;){\n\n\t\t\t\tnum = 0;\n\t\t\t\tfor(k = i+1; buf[k] >= '0' && buf[k] <= '9'; k++){\n\t\t\t\t\tnum = 10*num+buf[k]-'0';\n\t\t\t\t}\n\n\t\t\t\tnum--;\n\n\t\t\t\tswitch(buf[i]){\n\t\t\t\tcase 'L':\n\n\t\t\t\t\twork[getLoc(num,N-1)] = first_loc[getLoc(num,0)];\n\n\t\t\t\t\tfor(int col = 1; col < N; col++){\n\t\t\t\t\t\twork[getLoc(num,col-1)] = first_loc[getLoc(num,col)];\n\t\t\t\t\t}\n\t\t\t\t\tfor(int col = 0; col < N; col++){\n\t\t\t\t\t\tfirst_loc[getLoc(num,col)] = work[getLoc(num,col)];\n\t\t\t\t\t}\n\n\t\t\t\t\tbreak;\n\t\t\t\tcase 'R':\n\n\t\t\t\t\twork[getLoc(num,0)] = first_loc[getLoc(num,N-1)];\n\n\t\t\t\t\tfor(int col = 0; col < N-1; col++){\n\t\t\t\t\t\twork[getLoc(num,col+1)] = first_loc[getLoc(num,col)];\n\t\t\t\t\t}\n\t\t\t\t\tfor(int col = 0; col < N; col++){\n\t\t\t\t\t\tfirst_loc[getLoc(num,col)] = work[getLoc(num,col)];\n\t\t\t\t\t}\n\n\t\t\t\t\tbreak;\n\t\t\t\tcase 'U':\n\n\t\t\t\t\twork[getLoc(N-1,num)] = first_loc[getLoc(0,num)];\n\n\t\t\t\t\tfor(int row = 1; row < N; row++){\n\t\t\t\t\t\twork[getLoc(row-1,num)] = first_loc[getLoc(row,num)];\n\t\t\t\t\t}\n\n\t\t\t\t\tfor(int row = 0; row < N; row++){\n\t\t\t\t\t\tfirst_loc[getLoc(row,num)] = work[getLoc(row,num)];\n\t\t\t\t\t}\n\n\t\t\t\t\tbreak;\n\t\t\t\tcase 'D':\n\n\t\t\t\t\twork[getLoc(0,num)] = first_loc[getLoc(N-1,num)];\n\n\t\t\t\t\tfor(int row = 0; row < N-1; row++){\n\t\t\t\t\t\twork[getLoc(row+1,num)] = first_loc[getLoc(row,num)];\n\t\t\t\t\t}\n\n\t\t\t\t\tfor(int row = 0; row < N; row++){\n\t\t\t\t\t\tfirst_loc[getLoc(row,num)] = work[getLoc(row,num)];\n\t\t\t\t\t}\n\n\t\t\t\t\tbreak;\n\t\t\t\t}\n\t\t\t\ti = k;\n\t\t\t}\n\n\t\t\tindex = next_right+1;\n\t\t\tfor(int i = 0; i < SIZE; i++){\n\t\t\t\twork[first_loc[i]] = i;\n\t\t\t}\n\n\t\t\tfor(int i = 0; i < SIZE; i++){\n\t\t\t\tfirst_loc[i] = work[i];\n\t\t\t}\n\t\t}\n\t}\n\treturn first_loc;\n}\n\n\nint main(){\n\n\tscanf(\"%d %d\",&N,&length);\n\tSIZE = N*N;\n\n\tscanf(\"%s\",buf);\n\n\tMATRIX ans(SIZE),final_loc(SIZE);\n\tfinal_loc = calcNextLoc(0,length-1);\n\n\tfor(int i = 0; i < SIZE; i++){\n\t\tans[final_loc[i]] = i+1;\n\t}\n\n\tfor(int row = 0; row < N; row++){\n\t\tprintf(\"%d\",ans[getLoc(row,0)]);\n\t\tfor(int col = 1; col < N; col++){\n\t\t\tprintf(\" %d\",ans[getLoc(row,col)]);\n\t\t}\n\t\tprintf(\"\\n\");\n\t}\n\n\treturn 0;\n}\n\n\n"
  },
  {
    "language": "C++",
    "code": "#include <iostream>\n#include <vector>\n#include <string>\n#include <set>\nusing namespace std;\ntypedef long long ll;\n#define int long long\nstring s;\nint n,p;\nvector<vector<int> > a;\n\nvector<vector<int> > I;\n\nset<char> st={'L','R','U','D'};\nset<char> st2={'0','1','2','3','4','5','6','7','8','9'};\nvector<vector<int> > calc(vector<vector<int> > x,vector<vector<int> > y){\n    vector<pair<int,int> > p(n*n+1);\n    vector<vector<int> > ans(n,vector<int>(n));\n    for(int i=0;i<n;i++){\n        for(int j=0;j<n;j++){\n            p[y[i][j]] = make_pair(i,j);\n        }\n    }\n    for(int i=0;i<n;i++){\n        for(int j=0;j<n;j++){\n            ans[p[i*n+j+1].first][p[i*n+j+1].second] = x[i][j];\n            //cerr << p[i*n+j+1].first << \" \" <<p[i*n+j+1].second << endl;\n        }\n    }\n    return ans;\n}\nvector<vector<int> > saiki(vector<vector<int> > x,int c){\n    if(c==0){\n        return I;\n    }\n    if(c==1){\n        return x;\n    }\n    if(c%2==0){\n        vector<vector<int> > ss = saiki(x,c/2);\n        ss = calc(ss,ss);\n        return ss;\n    }else{\n        vector<vector<int> > ss = saiki(x,c/2);\n        ss = calc(ss,ss);\n        ss = calc(x,ss);\n        return ss;\n    }\n}\n\nvector<vector<int> > sequence(int l,int r){\n    vector<vector<int> > v(n,vector<int>(n));\n    for(int i=0;i<n;i++){\n        for(int j=0;j<n;j++){\n            v[i][j] = i*n+j+1;\n        }\n    }\n    if(l>r)return v;\n    if(st.count(s[l])==1){\n        int ind = l;\n        int c = 0;\n        for(int i=l+1;i<=r;i++){\n            if(st2.count(s[i])==1){\n                ind = i;\n                c *=10;\n                c += (int)(s[i]-'0');\n            }else{\n                break;\n            }\n        }\n        c--;\n        if(s[l]=='L'){\n            int tmp =v[c][0];\n            for(int k=0;k<n-1;k++){\n                v[c][k] = v[c][k+1];\n            }\n            v[c][n-1] = tmp;\n        }\n        if(s[l]=='R'){\n            int tmp =v[c][n-1];\n            for(int k=n-1;k>0;k--){\n                v[c][k] = v[c][k-1];\n            }\n            v[c][0] = tmp;\n        }\n        if(s[l]=='U'){\n            int tmp =v[0][c];\n            for(int k=0;k<n-1;k++){\n                v[k][c] = v[k+1][c];\n            }\n            v[n-1][c] = tmp;\n        }\n        if(s[l]=='D'){\n            int tmp =v[n-1][c];\n            for(int k=n-1;k>0;k--){\n                v[k][c] = v[k-1][c];\n            }\n            v[0][c] = tmp;\n        }\n        vector<vector<int > >v2 = sequence(ind+1,r);\n        return calc(v,v2);\n    }else{\n        int dep = 0;\n        int ind = l;\n        for(int i=l;i<=r;i++){\n            if(s[i]=='('){\n                dep++;\n            }else if(s[i]==')'){\n                dep--;\n            }\n            if(dep==0){\n                ind = i;\n                break;\n            }\n        }\n        int c = 0;\n        int ind2 = ind+1;\n        for(int i=ind+1;i<=r;i++){\n            if(st2.count(s[i])==1){\n                ind2 = i;\n                c *=10;\n                c += s[i]-'0';\n\n            }else{\n                break;\n            }\n        }\n        vector<vector<ll> >v = sequence(l+1,ind-1);\n        v = saiki(v,c);\n        //cerr << ind2 << endl;\n        vector<vector<ll> >v2 = sequence(ind2+1,r);\n        \n        return calc(v,v2);\n    }\n}\n\n\nsigned main(){\n    \n    cin >> n >> p;\n    a.resize(n);\n    I.resize(n);\n    for(int i=0;i<n;i++){\n        a[i].resize(n);\n        I[i].resize(n);\n        for(int j=0;j<n;j++){\n            a[i][j] = i*n+j+1;\n            I[i][j] = i*n+j+1;\n            //cerr << i << \" \" << j << \" \" <<a[i][j] << endl;\n        }\n    }\n    cin >> s;\n    \n    vector<vector<ll> > ans =sequence(0,p-1);\n    for(int i=0;i<n;i++){\n        for(int j=0;j<n;j++){\n            cout << ans[i][j];\n            if(j!=n-1)cout << \" \";\n        }\n        cout << endl;\n    }\n    return 0;\n}\n"
  },
  {
    "language": "C++",
    "code": "#include <stdio.h>\n#include <cmath>\n#include <algorithm>\n#include <cfloat>\n#include <stack>\n#include <queue>\n#include <vector>\n#include <string>\n#include <iostream>\n#include <set>\n#include <map>\n#include <time.h>\ntypedef long long int ll;\ntypedef unsigned long long int ull;\n#define BIG_NUM 2000000000\n#define MOD 1000000007\n#define EPS 0.000000001\nusing namespace std;\n\ntypedef vector<int> MATRIX;\n\nint N,SIZE,length;\nchar buf[1001];\n\nint getLoc(int row,int col){\n\treturn N*row+col;\n}\n\nMATRIX calc(MATRIX left,MATRIX next_loc){\n\n\tMATRIX ret(SIZE);\n\n\tfor(int i = 0; i < SIZE; i++){\n\t\tret[i] = next_loc[left[i]];\n\t}\n\n\treturn ret;\n\n}\n\nMATRIX pow(MATRIX next_loc,int count){\n\n\tMATRIX ret(SIZE);\n\n\tfor(int i = 0; i < SIZE; i++)ret[i] = i;\n\n\twhile(count > 0){\n\t\tif(count%2 == 1){\n\t\t\tret = calc(ret,next_loc);\n\t\t}\n\t\tnext_loc = calc(next_loc,next_loc);\n\t\tcount /= 2;\n\t}\n\n\treturn ret;\n}\n\n\nMATRIX calcNextLoc(int left,int right){\n\n\tMATRIX first_loc(SIZE),next_loc(SIZE),work(SIZE);\n\tfor(int i = 0; i < SIZE; i++)first_loc[i] = i;\n\n\tint index = left;\n\n\twhile(index <= right){\n\n\t\tif(buf[index] == '('){\n\n\t\t\tint depth = 0,next_right;\n\n\t\t\tfor(int i = index; i <= right; i++){\n\t\t\t\tif(buf[i] == '(')depth++;\n\t\t\t\telse if(buf[i] == ')'){\n\t\t\t\t\tdepth--;\n\t\t\t\t\tif(depth == 0){\n\t\t\t\t\t\tnext_right = i;\n\t\t\t\t\t\tbreak;\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t}\n\t\t\tnext_loc = calcNextLoc(index+1,next_right-1);\n\n\t\t\tint count = 0;\n\n\t\t\tfor(index = next_right+1;buf[index] >= '0' && buf[index] <= '9'; index++){\n\t\t\t\tcount = 10*count+buf[index]-'0';\n\t\t\t}\n\n\t\t\tif(count > 1){\n\t\t\t\tnext_loc = pow(next_loc,count);\n\t\t\t}\n\n\t\t\tfor(int i = 0; i < SIZE; i++)work[i] = next_loc[first_loc[i]];\n\t\t\tfor(int i = 0; i < SIZE; i++)first_loc[i] = work[i];\n\n\t\t}else{\n\n\t\t\tint next_right;\n\t\t\tfor(next_right = index; next_right <= right && buf[next_right] != '('; next_right++);\n\t\t\tnext_right--;\n\n\t\t\tint num,k;\n\n\t\t\tfor(int i = 0; i < SIZE; i++)next_loc[i] = i;\n\n\t\t\tfor(int i = index; i <= next_right;){\n\n\t\t\t\tnum = 0;\n\t\t\t\tfor(k = i+1; buf[k] >= '0' && buf[k] <= '9'; k++){\n\t\t\t\t\tnum = 10*num+buf[k]-'0';\n\t\t\t\t}\n\n\t\t\t\tnum--;\n\n\t\t\t\tswitch(buf[i]){\n\t\t\t\tcase 'L':\n\n\t\t\t\t\twork[getLoc(num,N-1)] = next_loc[getLoc(num,0)];\n\n\t\t\t\t\tfor(int col = 1; col < N; col++){\n\t\t\t\t\t\twork[getLoc(num,col-1)] = next_loc[getLoc(num,col)];\n\t\t\t\t\t}\n\t\t\t\t\tfor(int col = 0; col < N; col++){\n\t\t\t\t\t\tnext_loc[getLoc(num,col)] = work[getLoc(num,col)];\n\t\t\t\t\t}\n\n\t\t\t\t\tbreak;\n\t\t\t\tcase 'R':\n\n\t\t\t\t\twork[getLoc(num,0)] = next_loc[getLoc(num,N-1)];\n\n\t\t\t\t\tfor(int col = 0; col < N-1; col++){\n\t\t\t\t\t\twork[getLoc(num,col+1)] = next_loc[getLoc(num,col)];\n\t\t\t\t\t}\n\t\t\t\t\tfor(int col = 0; col < N; col++){\n\t\t\t\t\t\tnext_loc[getLoc(num,col)] = work[getLoc(num,col)];\n\t\t\t\t\t}\n\n\t\t\t\t\tbreak;\n\t\t\t\tcase 'U':\n\n\t\t\t\t\twork[getLoc(N-1,num)] = next_loc[getLoc(0,num)];\n\n\t\t\t\t\tfor(int row = 1; row < N; row++){\n\t\t\t\t\t\twork[getLoc(row-1,num)] = next_loc[getLoc(row,num)];\n\t\t\t\t\t}\n\n\t\t\t\t\tfor(int row = 0; row < N; row++){\n\t\t\t\t\t\tnext_loc[getLoc(row,num)] = work[getLoc(row,num)];\n\t\t\t\t\t}\n\n\t\t\t\t\tbreak;\n\t\t\t\tcase 'D':\n\n\t\t\t\t\twork[getLoc(0,num)] = next_loc[getLoc(N-1,num)];\n\n\t\t\t\t\tfor(int row = 0; row < N-1; row++){\n\t\t\t\t\t\twork[getLoc(row+1,num)] = next_loc[getLoc(row,num)];\n\t\t\t\t\t}\n\n\t\t\t\t\tfor(int row = 0; row < N; row++){\n\t\t\t\t\t\tnext_loc[getLoc(row,num)] = work[getLoc(row,num)];\n\t\t\t\t\t}\n\n\t\t\t\t\tbreak;\n\t\t\t\t}\n\t\t\t\ti = k;\n\t\t\t}\n\n\t\t\tindex = next_right+1;\n\t\t\tfor(int i = 0; i < SIZE; i++){\n\t\t\t\twork[next_loc[i]] = i;\n\t\t\t}\n\n\t\t\tfor(int i = 0; i < SIZE; i++){\n\t\t\t\tnext_loc[i] = work[i];\n\t\t\t}\n\n\t\t\tfor(int i = 0; i < SIZE; i++){\n\t\t\t\twork[i] = next_loc[first_loc[i]];\n\t\t\t}\n\n\t\t\tfor(int i = 0; i < SIZE; i++){\n\t\t\t\tfirst_loc[i] = work[i];\n\t\t\t}\n\t\t}\n\t}\n\treturn first_loc;\n}\n\n\nint main(){\n\n\tscanf(\"%d %d\",&N,&length);\n\tSIZE = N*N;\n\n\tscanf(\"%s\",buf);\n\n\tMATRIX ans(SIZE),final_loc(SIZE);\n\tfinal_loc = calcNextLoc(0,length-1);\n\n\tfor(int i = 0; i < SIZE; i++){\n\t\tans[final_loc[i]] = i+1;\n\t}\n\n\tfor(int row = 0; row < N; row++){\n\t\tprintf(\"%d\",ans[getLoc(row,0)]);\n\t\tfor(int col = 1; col < N; col++){\n\t\t\tprintf(\" %d\",ans[getLoc(row,col)]);\n\t\t}\n\t\tprintf(\"\\n\");\n\t}\n\n\treturn 0;\n}\n\n\n"
  },
  {
    "language": "C++",
    "code": "#include<bits/stdc++.h>\nusing namespace std;\n\nusing Vec=vector<int>;\nusing Mat=vector<vector<int>>;\nint n,l;\nMat E(){\n    Mat res(n,Vec(n));\n    for(int i=0;i<n;i++){\n        for(int j=0;j<n;j++){\n            res[i][j]=i*n+j;\n        }\n    }\n    return res;\n}\nMat merge(Mat lhs,Mat rhs){\n    Mat res(n,Vec(n));\n    for(int i=0;i<n;i++){\n        for(int j=0;j<n;j++){\n            int row=rhs[i][j]/n;\n            int col=rhs[i][j]%n;\n            res[i][j]=lhs[row][col];\n        }\n    }\n    return res;\n}\nint getNum(int &p,string s){\n    int res=0;\n    while(p<s.size() && isdigit(s[p])){\n        res*=10;\n        res+=s[p]-'0';\n        p++;\n    }\n    return res;\n}\nMat powM(Mat mat,int k){\n    Mat res=E();\n    while(k){\n        if(k&1) res=merge(res,mat);\n        k>>=1;\n        mat=merge(mat,mat);\n    }\n    return res;\n}\nMat prim(int &p,string s){\n    if(s[p]=='L' || s[p]=='R'){\n        char op=s[p++];\n        Mat res=E();\n        int k=getNum(p,s);\n        k--;\n        int diff=(op=='L' ? n-1 : 1);\n        for(int j=0;j<n;j++) res[k][(j+diff)%n]=k*n+j%n;\n        return res;\n    }\n    if(s[p]=='U' || s[p]=='D'){\n        char op=s[p++];\n        Mat res=E();\n        int k=getNum(p,s);\n        k--;\n        int diff=(op=='U' ? n-1 : 1);\n        for(int i=0;i<n;i++) res[(i+diff)%n][k]=i*n+k;\n        return res;\n    }\n    assert(false);\n}\n\nMat seq(int &p,string s){\n    Mat res=E();\n    while(p<s.size() && s[p]!=')'){\n        Mat ret;\n        if(s[p]=='('){\n            p++;\n            ret=seq(p,s);\n            assert(s[p++]==')');\n            int num=getNum(p,s);\n            ret=powM(ret,num);\n        }\n        else{\n            ret=prim(p,s);\n        }\n        res=merge(res,ret);\n    }\n    return res;\n}\n\nvoid output(Mat mat,ostream& out){\n    for(int i=0;i<n;i++){\n        for(int j=0;j<n;j++){\n            out<<mat[i][j]+1<<(j+1==n ? \"\\n\" : \" \");\n        }\n    }\n}\nint main(){\n    cin>>n>>l;\n    string s;\n    cin>>s;\n    int p=0;\n    Mat res=seq(p,s);\n    output(res,cout);\n    return 0;\n}\n\n"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\n#define GET_MACRO(_1,_2,_3,_4,_5,NAME,...) NAME\n#define pr(...) GET_MACRO(__VA_ARGS__,pr5,pr4,pr3,pr2,pr1)(__VA_ARGS__)\n#define pr1(a) (#a)<<\"=\"<<(a)\n#define pr2(a,b) pr1(a)<<\", \"<<pr1(b)\n#define pr3(a,b,c) pr2(a,b)<<\", \"<<pr1(c)\n#define pr4(a,b,c,d) pr3(a,b,c)<<\", \"<<pr1(d)\n#define pr5(a,b,c,d,e) pr4(a,b,c,d)<<\", \"<<pr1(e)\n#define int long long\n#define double long double\nusing namespace std;\nconst int N = 100010;\nconst int INF = 1LL<<55;\nconst int mod = (1e9)+7;\nconst double EPS = 1e-8;\nconst double PI = 6.0 * asin(0.5);\ntypedef pair<int,int> P;\ntypedef long long ll;\ntemplate<class T> T Max(T &a,T b){return a=max(a,b);}\ntemplate<class T> T Min(T &a,T b){return a=min(a,b);}\nostream& operator<<(ostream& o,P p){return o<<\"(\"<<p.first<<\",\"<<p.second<<\")\";}\nistream& operator>>(istream& i,P &p){return i>>p.first>>p.second;}\nostream& operator<<(ostream& o,vector<auto> &a){int i=0;for(auto t:a)o<<(i++?\" \":\"\")<<t;return o;}\nistream& operator>>(istream& i,vector<auto> &a){for(auto &t:a)i>>t;return i;}\nvoid prArr(auto a,string s=\" \"){int i=0;for(auto t:a)cout<<(i++?s:\"\")<<t;cout<<endl;}\n\ntypedef vector<int> vec;\ntypedef vector<vec> mat;\n\nmat move(mat a,mat b){\n  int n = a.size();\n  mat res(n,vec(n));\n\n  for(int i=0;i<n;i++)\n    for(int j=0;j<n;j++) {\n      int y = a[i][j] / n;\n      int x = a[i][j] % n;\n      res[i][j] = b[y][x];\n    }\n  return res;\n}\n\nint n,len;\nint pos;\nstring str;\n\nmat bfs();\nmat repeat();\nint number();\n  \nmat repeat(){\n  assert(str[pos] == '(');\n  pos++;\n  mat x = bfs();\n  assert(str[pos]==')');\n  pos++;\n  int num = number();\n  \n  mat res(n,vec(n));\n  for(int i=0;i<n;i++)\n    for(int j=0;j<n;j++) res[i][j] = i * n + j;\n\n  while(num){\n    if(num%2) res = move(res,x);\n    x = move(x,x);\n    num = num/2;\n  }\n  return res;\n}\n\nint number(){\n  assert(isdigit(str[pos]));\n  int res = 0;\n  while(isdigit(str[pos])) res = res * 10 + str[pos] - '0', pos++;\n  return res;\n}\n\nvoid L(mat &A){\n  assert(str[pos++] == 'L');\n  int k = number() - 1;\n  for(int i=0;i<n-1;i++) swap(A[k][i],A[k][i+1]);\n}\n\nvoid R(mat &A){\n  assert(str[pos++] == 'R');\n  int k = number() - 1;\n  for(int i=0;i<n-1;i++) swap(A[k][n-1-i],A[k][n-2-i]);\n};\n\nmat U(mat &A){\n  assert(str[pos++] == 'U');\n  int k = number() - 1;\n  for(int i=0;i<n-1;i++) swap(A[i][k],A[i+1][k]);\n};\nmat D(mat &A){\n  assert(str[pos++] == 'D');\n  int k = number() - 1;\n  for(int i=0;i<n-1;i++) swap(A[n-1-i][k],A[n-2-i][k]);\n};\n\nmat bfs(){\n  mat res(n,vec(n));\n  for(int i=0;i<n;i++)\n    for(int j=0;j<n;j++) res[i][j] = i*n + j;\n  \n  while(pos < (int)str.size()){\n    char ch = str[pos];\n    if(ch == '(') res = repeat();\n    else if(ch == 'L') L(res);\n    else if(ch == 'R') R(res);\n    else if(ch == 'U') U(res);\n    else if(ch == 'D') D(res);\n    else break;\n  }\n  return res;\n}\n\nsigned main(){\n  int L;\n  cin>>n>>L;\n  cin>>str;\n  \n  mat ans = bfs();\n  for(int i=0;i<n;i++)\n    for(int j=0;j<n;j++) ans[i][j] ++;\n  for(int i=0;i<n;i++) cout<<ans[i]<<endl;\n  \n  return 0;\n}\n\n"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\n#define int long long\nusing namespace std;\n\ntypedef vector<int> vec;\ntypedef vector<vec > mat;\n\ntypedef pair<int,int> P;\n\nmat bnf();\n\nint N, L, p;\nstring s;\n\nmat cal(char c, int num){\n  \n  mat res( N, vec( N ) );\n  \n  for(int i=0;i<N;i++)\n    for(int j=0;j<N;j++) res[i][j] = i * N + j + 1;\n  \n  num--;\n  \n  if( c == 'L' ){\n    int tmp = res[num][0];\n    for(int i=0;i<N-1;i++) res[num][i] = res[num][i+1];\n    res[num][N-1] = tmp;\n  }\n  \n  if( c == 'R' ){\n    int tmp = res[num][N-1];\n    for(int i=N-1;i>0;i--) res[num][i] = res[num][i-1];\n    res[num][0] = tmp;\n  }\n  \n  if( c == 'U' ){\n    int tmp = res[0][num];\n    for(int i=0;i<N-1;i++) res[i][num] = res[i+1][num];\n    res[N-1][num] = tmp;\n  }\n  \n  if( c == 'D' ){\n    int tmp = res[N-1][num];\n    for(int i=N-1;i>0;i--) res[i][num] = res[i-1][num];\n    res[0][num] = tmp;\n  }\n\n  return res;\n}\n\nmat marge1(mat A, mat B){\n  \n  mat res( N, vec( N ) );\n  \n  for(int i=0;i<N;i++){\n    \n    for(int j=0;j<N;j++){\n      B[i][j]--;\n      res[i][j] = A[B[i][j]/N][B[i][j]%N];\n    }\n    \n  }\n  \n  return res;\n}\n\nmat marge2(mat A, int num){ // doubling\n  \n  mat res( N, vec(N) );\n  \n  for(int i=0;i<N;i++)\n    for(int j=0;j<N;j++) res[i][j] = i * N + j + 1;\n  \n  while(num){\n    \n    if( num % 2 ) res = marge1( res, A );\n    \n    A = marge1( A, A );\n    \n    num /= 2;\n  }\n\n  return res;\n}\n\n\nmat get_num(){\n  \n  if( s[p] == '(' ){\n    \n    p++;\n    \n    mat r = bnf();\n    \n    int num = 0;\n    \n    while( '0' <= s[p] && s[p] <= '9' ) num = num * 10 + s[p++] - '0';\n    \n    r = marge2( r, num );\n    \n    return r;\n  }\n  \n  char c = s[p++];\n  \n  int num = 0;\n  \n  while( '0' <= s[p] && s[p] <= '9' ) num = num * 10 + s[p++] - '0';\n  \n  return cal( c, num );\n}\n\nmat bnf(){\n  \n  mat res = get_num();\n  \n  while( p < L ){\n    \n    if( s[p] == ')' ){\n      p++;\n      break;\n    }\n    \n    mat r = get_num();\n    \n    res = marge1( res, r );\n    \n  }\n  \n  return res;\n}\n\nsigned main(){\n  \n  cin>>N>>L;\n  \n  cin>>s;\n  \n  mat ans = bnf();\n  \n  for(int i=0;i<N;i++){\n    \n    for(int j=0;j<N;j++){\n      \n      if( j ) cout<<' ';\n\n      cout<<ans[i][j];\n      \n    }\n\n    cout<<endl;\n    \n  }\n  \n  return 0;\n}\n\n"
  },
  {
    "language": "C++",
    "code": "// g++ -std=c++11 a.cpp\n#include<iostream>\n#include<vector>\n#include<string>\n#include<algorithm>   \n#include<map>\n#include<set>\n#include<unordered_map>\n#include<utility>\n#include<cmath>\n#include<random>\n#include<cstring>\n#include<queue>\n#include<stack>\n#include<bitset>\n#include<cstdio>\n#include<sstream>\n#include<iomanip>\n#include<assert.h>\n#include<typeinfo>\n#define loop(i,a,b) for(ll i=a;i<b;i++) \n#define rep(i,a) loop(i,0,a)\n#define FOR(i,a) for(auto i:a)\n#define pb push_back\n#define all(in) in.begin(),in.end()\n#define shosu(x) fixed<<setprecision(x)\nusing namespace std;\n//kaewasuretyuui\ntypedef long long ll;\n//#define int ll\ntypedef int Def;\ntypedef pair<Def,Def> pii;\ntypedef vector<Def> vi;\ntypedef vector<vi> vvi;\ntypedef vector<pii> vp;\ntypedef vector<vp> vvp;\ntypedef vector<string> vs;\ntypedef vector<double> vd;\ntypedef vector<vd> vvd;\ntypedef pair<Def,pii> pip;\ntypedef vector<pip>vip;\n#define mt make_tuple\ntypedef tuple<int,int,int,int> tp;\ntypedef vector<tp> vt;\ntemplate<typename A,typename B>bool cmin(A &a,const B &b){return a>b?(a=b,true):false;}\ntemplate<typename A,typename B>bool cmax(A &a,const B &b){return a<b?(a=b,true):false;}\n//template<class C>constexpr int size(const C &c){return (int)c.size();}\n//template<class T,size_t N> constexpr int size(const T (&xs)[N])noexcept{return (int)N;}\nconst double PI=acos(-1);\nconst double EPS=1e-9;\nDef inf = sizeof(Def) == sizeof(long long) ? 2e18 : 1e9+10;\nint dx[]={0,1,0,-1};\nint dy[]={1,0,-1,0};\nint n,l,t=0;\nstring s;\nint number(){\n\tint q=0;\n\twhile(t<s.size()&&isdigit(s[t])){\n\t\tq*=10;\n\t\tq+=s[t]-'0';\n\t\tt++;\n\t}\n\treturn q;\n}\nvvi f(){\n\tvvi w(n,vi(n));\n\trep(i,n)rep(j,n)w[i][j]=i*n+j;\n\twhile(t<s.size()){\n\t\tif(s[t]=='('){\n\t\t\tt++;\n\t\t\tvvi ne=f();\n\t\t\tt++;\n\t\t\tint co=number();\n\t\t\twhile(co){\n\t\t\t\tif(co%2){\n\t\t\t\t\tvvi NE(n,vi(n));\n\t\t\t\t\trep(i,n)rep(j,n)NE[i][j]=w[ne[i][j]/n][ne[i][j]%n];\n\t\t\t\t\tw=NE;\n\t\t\t\t}\n\t\t\t\tvvi NE(n,vi(n));\n\t\t\t\trep(i,n)rep(j,n)NE[i][j]=ne[ne[i][j]/n][ne[i][j]%n];\n\t\t\t\tne=NE;\n\t\t\t\tco/=2;\n\t\t\t}\n\t\t}else if(s[t]==')')break;\n\t\telse{\n\t\t\tchar c=s[t];\n\t\t\tt++;\n\t\t\tint co=number()-1;\n\t\t\tint tmp;\n\t\t\tif(c=='U'){\n\t\t\t\ttmp=w[0][co];\n\t\t\t\trep(i,n-1)w[i][co]=w[i+1][co];\n\t\t\t\tw[n-1][co]=tmp;\n\t\t\t}\n\t\t\tif(c=='D'){\n\t\t\t\ttmp=w[n-1][co];\n\t\t\t\trep(i,n-1)w[n-1-i][co]=w[n-2-i][co];\n\t\t\t\tw[0][co]=tmp;\n\t\t\t}\n\t\t\tif(c=='L'){\n\t\t\t\ttmp=w[co][0];\n\t\t\t\trep(i,n-1)w[co][i]=w[co][i+1];\n\t\t\t\tw[co][n-1]=tmp;\n\t\t\t}\n\t\t\tif(c=='R'){\n\t\t\t\ttmp=w[co][n-1];\n\t\t\t\trep(i,n-1)w[co][n-1-i]=w[co][n-2-i];\n\t\t\t\tw[co][0]=tmp;\n\t\t\t}\n\t\t}\n\t}\n\treturn w;\n}\nint main(){\n\tcin>>n>>l>>s;\n\tt=0;\n\tvvi out=f();\n\trep(i,n)rep(j,n)cout<<out[i][j]+1<<\" \\n\"[j==n-1];\n}\n\n\n\n\n\n\n\n\n\n"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\nusing namespace std;\n\ntemplate<class T>\nbool chmax(T& a, const T& b) {\n    if (a < b) { a = b; return true; }\n    return false;\n}\ntemplate<class T>\nbool chmin(T& a, const T& b) {\n    if (b < a) { a = b; return true; }\n    return false;\n}\n\n// std::vector Declaration\ntemplate<typename T>\nvector<T> make_v(size_t a) { return vector<T>(a); }\ntemplate<typename T, typename... Ts>\nauto make_v(size_t a, Ts... ts) {\n    return vector<decltype(make_v<T>(ts...))>(a, make_v<T>(ts...));\n}\n\n// std::vector Declaration and Initialization\ntemplate<typename T>\nvector<T> make_vector(size_t a, T x) { return vector<T>(a, x); }\ntemplate<typename T, typename U, typename... Ts>\nauto make_vector(size_t a, U b, Ts... ts) {\n    return vector<decltype(make_vector<T>(b,ts...))>(a, make_vector<T>(b, ts...));\n}\n\n// std::vector Input\ntemplate<typename T>\nistream& operator>>(istream& is, vector<T>& v) {\n    for (auto &e : v) is >> e;\n    return is;\n}\n\n// std::vector Debug\ntemplate<typename T>\nostream& operator<<(ostream& os, const vector<T>& v) {\n    os << \"[\";\n    bool a = 1;\n    for (auto e : v) {\n        os << (a ? \"\" : \" \");\n        os << e;\n        a = 0;\n    }\n    os << \"]\";\n    return os;\n}\n\n// std::array Debug\ntemplate<typename T, size_t n>\nostream& operator<<(ostream& os, const array<T, n>& v) {\n    os << \"[\";\n    bool a = 1;\n    for (auto e : v) {\n        os << (a ? \"\" : \" \");\n        os << e;\n        a = 0;\n    }\n    os << \"]\";\n    return os;\n}\n\n// std::deque Debug\ntemplate<typename T>\nostream& operator<<(ostream& os, const deque<T>& d) {\n    os << \"[\";\n    bool a = 1;\n    for (auto e : d) {\n        os << (a ? \"\" : \" \");\n        os << e;\n        a = 0;\n    }\n    os << \"]\";\n    return os;\n}\n\n// std::pair Debug\ntemplate<typename T, typename U>\nostream& operator<<(ostream& os, const pair<T, U>& p) {\n    os << \"(\" << p.first << \" \" << p.second << \")\";\n    return os;\n}\n\n// std::set Debug\ntemplate<typename T>\nostream& operator<<(ostream& os, const set<T>& st) {\n    os << \"{\";\n    bool a = 1;\n    for (auto e : st) {\n        os << (a ? \"\" : \" \");\n        os << e;\n        a = 0;\n    }\n    os << \"}\";\n    return os;\n}\n\n// std::multiset Debug\ntemplate<typename T>\nostream& operator<<(ostream& os, const multiset<T>& st) {\n    os << \"{\";\n    bool a = 1;\n    for (auto e : st) {\n        os << (a ? \"\" : \" \");\n        os << e;\n        a = 0;\n    }\n    os << \"}\";\n    return os;\n}\n\n// std::map Debug\ntemplate<typename T, typename U>\nostream& operator<<(ostream& os, const map<T, U>& mp) {\n    os << \"{\";\n    bool a = 1;\n    for (auto e : mp) {\n        os << (a ? \"\" : \" \");\n        os << e.first << \":\" << e.second;\n        a = 0;\n    }\n    os << \"}\";\n    return os;\n}\n\n// std::tuple Debug\ntemplate<int N, class Tuple>\nvoid out(ostream& os, const Tuple& t){}\ntemplate<int N, class Tuple, class H, class ...Ts>\nvoid out(ostream& os, const Tuple& t) {\n    if (N) os << \" \";\n    os << get<N>(t);\n    out<N+1,Tuple,Ts...>(os, t);\n}\ntemplate<class ...Ts>\nostream& operator<<(ostream& os, const tuple<Ts...>& t) {\n    os << \"(\";\n    out<0,tuple<Ts...>,Ts...>(os, t);\n    os << \")\";\n    return os;\n}\n\n// Debug\n#define DUMP(x) cerr<<#x<<\" = \"<<(x)<<endl\n\n// Weighted edge\ntemplate<typename T>\nstruct edge {\n    int src, to;\n    T cost;\n\n    edge() {}\n    edge(int to, T cost) : src(-1), to(to), cost(cost) {}\n    edge(int src, int to, T cost) : src(src), to(to), cost(cost) {}\n\n    friend ostream& operator<<(ostream& os, const edge& e) {\n        return os << \"(\" << e.src << \"->\" << e.to << \":\" << e.cost << \")\";\n    }\n};\n\nusing LL = int64_t;\n\n#define fs first\n#define sc second\n\nconst int64_t MOD = 1e9+7;\n\n\n\nstruct Permutation {\n    vector<int> perm;\n    Permutation() {}\n    Permutation(int sz) : perm(sz) {\n        iota(perm.begin(), perm.end(), 0);\n    }\n    Permutation(initializer_list<int> init) : perm(init.begin(), init.end()) {}\n    size_t size() const {\n        return (perm.size());\n    }\n    inline int operator [](int k) const {\n        return perm.at(k);\n    }\n    inline int& operator [](int k) {\n        return perm.at(k);\n    }\n    Permutation& operator*=(const Permutation& rhs) {\n        assert(size() == rhs.size());\n        Permutation tmp(size());\n        for (int i = 0; i < size(); ++i) {\n            tmp[i] = perm[rhs[i]];\n        }\n        perm.swap(tmp.perm);\n        return (*this);\n    }\n    const Permutation operator*(const Permutation& rhs) const {\n        return (Permutation(*this) *= rhs);\n    }\n    Permutation pow(int64_t k) {\n        Permutation ret(size()), tmp = *this;\n        while (k) {\n            if (k & 1) ret *= tmp;\n            tmp *= tmp;\n            k >>= 1;\n        }\n        return (ret);\n    }\n};\n\n\nusing State = string::const_iterator;\nclass ParseError {};\n\n\nint number(State& begin) {\n    int ret = 0;\n    while ('0' <= *begin and *begin <= '9') {\n        ret *= 10;\n        ret += *begin - '0';\n        ++begin;\n    }\n    return ret;\n}\n\nint N = 3;\n\nPermutation operation(State& begin) {\n    char ch = *begin;\n    int num = number(++begin) - 1;\n    Permutation ord(N*N);\n    if (ch == 'R') {\n        int buff = ord[N-1 + num*N];\n        for (int i = N-1; i > 0; --i) {\n            ord[i + num*N] = ord[i-1 + num*N];\n        }\n        ord[num*N] = buff;\n    }\n    if (ch == 'L') {\n        int buff = ord[0 + num*N];\n        for (int i = 0; i < N-1; ++i) {\n            ord[i + num*N] = ord[i+1 + num*N];\n        }\n        ord[N-1 + num*N] = buff;\n    }\n    if (ch == 'D') {\n        int buff = ord[num + (N-1)*N];\n        for (int i = N-1; i > 0; --i) {\n            ord[num + i*N] = ord[num + (i-1)*N];\n        }\n        ord[num] = buff;\n    }\n    if (ch == 'U') {\n        int buff = ord[num];\n        for (int i = 0; i < N-1; ++i) {\n            ord[num + i*N] = ord[num + (i+1)*N];\n        }\n        ord[num + (N-1)*N] = buff;\n    }\n    return ord;\n}\n\nPermutation sequence(State& begin);\n\nPermutation repetition(State& begin) {\n    assert(*begin == '(');\n    Permutation ret = sequence(++begin);\n    assert(*begin == ')');\n    int num = number(++begin);\n    return ret.pow(num);\n}\n\nPermutation rep_or_op(State& begin) {\n    if (*begin == '(') {\n        return repetition(begin);\n    } else {\n        return operation(begin);\n    }\n}\n\nPermutation sequence(State& begin) {\n    Permutation ret = rep_or_op(begin);\n    while (*begin != ')' and *begin != '\\0') {\n        ret = ret * rep_or_op(begin);\n    }\n    return ret;\n}\n\nvoid test_operator() {\n    Permutation op = {2, 0, 1, 3, 4, 5, 6, 7, 8},\n               exp = {1, 2, 0, 3, 4, 5, 6, 7, 8};\n    auto ret = op * op;\n    for (int i = 0; i < 9; ++i) {\n        assert(ret[i] == exp[i]);\n    }\n    auto ret2 = op.pow(2);\n    for (int i = 0; i < 9; ++i) {\n        assert(ret2[i] == exp[i]);\n    }\n}\n\nvoid test_num() {\n    string s = \"283\";\n    State begin = s.begin();\n    assert(number(begin) == 283);\n}\nvoid test_operation() {\n    string s = \"R1\";\n    State begin = s.begin();\n    auto ret = operation(begin);\n    Permutation exp = {2, 0, 1, 3, 4, 5, 6, 7, 8};\n    for (int i = 0; i < 9; ++i) {\n        assert(ret[i] == exp[i]);\n    }\n}\nvoid test_single_sequence() {\n    string s = \"R1\";\n    State begin = s.begin();\n    auto ret = sequence(begin);\n    Permutation exp = {2, 0, 1, 3, 4, 5, 6, 7, 8};\n    for (int i = 0; i < 9; ++i) {\n        assert(ret[i] == exp[i]);\n    }\n}\nvoid test_repetition() {\n    string s = \"(U2)300\";\n    State begin = s.begin();\n    auto ret = repetition(begin);\n    vector<int> exp = {0, 1, 2, 3, 4, 5, 6, 7, 8};\n    for (int i = 0; i < 9; ++i) {\n        assert(ret[i] == exp[i]);\n    }\n}\nvoid test_sequence() {\n    string s = \"R1D1\";\n    State begin = s.begin();\n    auto ret = sequence(begin);\n    vector<int> exp = {6, 0, 1, 2, 4, 5, 3, 7, 8};\n    for (int i = 0; i < 9; ++i) {\n        assert(ret[i] == exp[i]);\n    }\n}\n\n\n\nint main()\n{\n    cin.tie(0);\n    ios::sync_with_stdio(false);\n    cout << fixed << setprecision(10);\n\n    test_operator();\n    test_num();\n    test_operation();\n    test_single_sequence();\n    test_repetition();\n    test_sequence();\n\n    int L; cin >> N >> L;\n    string S; cin >> S;\n    State begin = S.begin();\n\n    Permutation state = sequence(begin);\n    for (int i = 0; i < N; ++i) {\n        for (int j = 0; j < N; ++j) {\n            if (j) cout << \" \";\n            cout << state[i*N + j] + 1;\n        }\n        cout << endl;\n    }\n\n    return 0;\n}\n\n"
  },
  {
    "language": "C++",
    "code": "#include <stdio.h>\n#include <cmath>\n#include <algorithm>\n#include <cfloat>\n#include <stack>\n#include <queue>\n#include <vector>\n#include <string>\n#include <iostream>\n#include <set>\n#include <map>\n#include <time.h>\ntypedef long long int ll;\ntypedef unsigned long long int ull;\n#define BIG_NUM 2000000000\n#define MOD 1000000007\n#define EPS 0.000000001\nusing namespace std;\n\ntypedef vector<int> MATRIX;\n\nint N,SIZE,length;\nchar buf[1001];\n\nint getLoc(int row,int col){\n\treturn N*row+col;\n}\n\nMATRIX calc(MATRIX left,MATRIX next_loc){\n\n\tMATRIX ret(SIZE);\n\n\t/*for(int i = 0; i < SIZE; i++){\n\t\tprintf(\"next_loc[%d]:%d\\n\",i,next_loc[i]);\n\t}\n\tprintf(\"\\n\");\n\tfor(int i = 0; i < SIZE; i++){\n\t\t\tprintf(\"left[%d]:%d\\n\",i,left[i]);\n\t\t}*/\n\tfor(int i = 0; i < SIZE; i++){ //結局、iがwork[i]に移る\n\t\tret[i] = left[next_loc[i]];\n\t}\n\n\t/*printf(\"\\n\");\n\tfor(int i = 0; i < SIZE; i++){\n\t\tprintf(\"ret[%d]:%d\\n\",i,ret[i]);\n\t}*/\n\n\treturn ret;\n\n}\n\n//MULTのT乗を計算する\nMATRIX pow(MATRIX next_loc,int count){\n\n\tMATRIX ret(SIZE);\n\n\tfor(int i = 0; i < SIZE; i++)ret[i] = i;\n\n\twhile(count > 0){\n\t\tif(count%2 == 1){\n\t\t\t//printf(\"count:%d:mod1\\n\",count);\n\t\t\tret = calc(ret,next_loc);\n\t\t}\n\t\t//printf(\"count:%d\\n\",count);\n\t\tnext_loc = calc(next_loc,next_loc);\n\t\tcount /= 2;\n\t}\n\n\treturn ret;\n}\n\n\n//buf[left]～buf[right]の部分の、遷移配列を求める再帰関数\nMATRIX calcNextLoc(int left,int right){\n\n\tMATRIX first_loc(SIZE),next_loc(SIZE),work(SIZE);\n\tfor(int i = 0; i < SIZE; i++)first_loc[i] = i; //最初は移動なし\n\n\tint index = left;\n\n\twhile(index <= right){\n\n\t\tif(buf[index] == '('){\n\n\t\t\tint depth = 0,next_right;\n\n\t\t\tfor(int i = index; i <= right; i++){\n\t\t\t\tif(buf[i] == '(')depth++;\n\t\t\t\telse if(buf[i] == ')'){\n\t\t\t\t\tdepth--;\n\t\t\t\t\tif(depth == 0){\n\t\t\t\t\t\tnext_right = i;\n\t\t\t\t\t\tbreak;\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t}\n\n\t\t\t//操作配列を取得\n\t\t\tnext_loc = calcNextLoc(index+1,next_right-1);\n\n\t\t\t/*for(int i = 0; i < SIZE; i++){\n\t\t\t\tprintf(\"next_loc[%d]:%d\\n\",i,next_loc[i]);\n\t\t\t}*/\n\n\t\t\t//反復回数を取得\n\t\t\tint count = 0;\n\n\t\t\tfor(index = next_right+1;buf[index] >= '0' && buf[index] <= '9'; index++){\n\t\t\t\tcount = 10*count+buf[index]-'0';\n\t\t\t}\n\n\t\t\t//printf(\"count:%d\\n\",count);\n\n\t\t\tif(count > 1){\n\t\t\t\tnext_loc = pow(next_loc,count);\n\t\t\t}\n\n\t\t\t/*for(int i = 0; i < SIZE; i++){\n\t\t\t\t\t\t\tprintf(\"next_loc[%d]:%d\\n\",i,next_loc[i]);\n\t\t\t\t\t\t}*/\n\n\t\t\t/*for(int i = 0; i < SIZE; i++)work[i] = first_loc[next_loc[i]];\n\t\t\tfor(int i = 0; i < SIZE; i++)first_loc[i] = work[i];*/\n\n\t\t\tfor(int i = 0; i < SIZE; i++)work[i] = next_loc[first_loc[i]];\n\t\t\t\t\t\tfor(int i = 0; i < SIZE; i++)first_loc[i] = work[i];\n\n\t\t}else{ //カッコではない場合:buf[index]～buf[next_right]までが、操作支持列\n\n\t\t\t/*printf(\"カッコの外\\n\");\n\t\t\tfor(int k = index; k <= right; k++){\n\t\t\t\tprintf(\"%c\",buf[k]);\n\t\t\t}\n\t\t\tprintf(\"\\n\");*/\n\n\t\t\tint next_right;\n\t\t\tfor(next_right = index; next_right <= right && buf[next_right] != '('; next_right++);\n\t\t\tnext_right--;\n\n\t\t\tint num,k;\n\n\t\t\tfor(int i = index; i <= next_right;){\n\n\t\t\t\tnum = 0;\n\t\t\t\tfor(k = i+1; buf[k] >= '0' && buf[k] <= '9'; k++){\n\t\t\t\t\tnum = 10*num+buf[k]-'0';\n\t\t\t\t}\n\n\t\t\t\tnum--; //0オリジンにする\n\n\t\t\t\tswitch(buf[i]){\n\t\t\t\tcase 'L': //num行目を左にシフト\n\n\t\t\t\t\t//printf(\"左シフト\\n\");\n\n\t\t\t\t\twork[getLoc(num,N-1)] = first_loc[getLoc(num,0)];\n\n\t\t\t\t\tfor(int col = 1; col < N; col++){\n\t\t\t\t\t\twork[getLoc(num,col-1)] = first_loc[getLoc(num,col)];\n\t\t\t\t\t}\n\t\t\t\t\tfor(int col = 0; col < N; col++){\n\t\t\t\t\t\tfirst_loc[getLoc(num,col)] = work[getLoc(num,col)];\n\t\t\t\t\t}\n\n\t\t\t\t\tbreak;\n\t\t\t\tcase 'R': //num行目を右にシフト\n\n\t\t\t\t\t//printf(\"右シフト %d行目\\n\",num);\n\n\t\t\t\t\twork[getLoc(num,0)] = first_loc[getLoc(num,N-1)];\n\t\t\t\t\t//printf(\"first[%d]をwork[%d]に\\n\",getLoc(num,N-1),getLoc(num,0));\n\n\t\t\t\t\tfor(int col = 0; col < N-1; col++){\n\t\t\t\t\t\twork[getLoc(num,col+1)] = first_loc[getLoc(num,col)];\n\t\t\t\t\t\t//printf(\"first[%d]をwork[%d]に\\n\",getLoc(num,col),getLoc(num,col+1));\n\t\t\t\t\t}\n\t\t\t\t\tfor(int col = 0; col < N; col++){\n\t\t\t\t\t\tfirst_loc[getLoc(num,col)] = work[getLoc(num,col)];\n\t\t\t\t\t}\n\n\t\t\t\t\t/*for(int i = 0; i < 9; i++){\n\t\t\t\t\t\t\t\t\t\t\tprintf(\"first_loc[%d]:%d\\n\",i,first_loc[i]);\n\t\t\t\t\t\t\t\t\t\t}*/\n\n\t\t\t\t\tbreak;\n\t\t\t\tcase 'U': //num列目を上にシフト\n\n\t\t\t\t\t//printf(\"上シフト\\n\");\n\n\t\t\t\t\twork[getLoc(N-1,num)] = first_loc[getLoc(0,num)];\n\n\t\t\t\t\tfor(int row = 1; row < N; row++){\n\t\t\t\t\t\twork[getLoc(row-1,num)] = first_loc[getLoc(row,num)];\n\t\t\t\t\t}\n\n\t\t\t\t\tfor(int row = 0; row < N; row++){\n\t\t\t\t\t\tfirst_loc[getLoc(row,num)] = work[getLoc(row,num)];\n\t\t\t\t\t}\n\n\t\t\t\t\tbreak;\n\t\t\t\tcase 'D': //num列目を下にシフト\n\n\t\t\t\t\t//printf(\"下にシフト\\n\");\n\n\t\t\t\t\twork[getLoc(0,num)] = first_loc[getLoc(N-1,num)];\n\n\t\t\t\t\tfor(int row = 0; row < N-1; row++){\n\t\t\t\t\t\twork[getLoc(row+1,num)] = first_loc[getLoc(row,num)];\n\t\t\t\t\t}\n\n\t\t\t\t\tfor(int row = 0; row < N; row++){\n\t\t\t\t\t\tfirst_loc[getLoc(row,num)] = work[getLoc(row,num)];\n\t\t\t\t\t}\n\n\t\t\t\t\tbreak;\n\t\t\t\t}\n\t\t\t\ti = k;\n\t\t\t\t//printf(\"i:%dに\\n\",i);\n\t\t\t}\n\n\t\t\tindex = next_right+1;\n\t\t\tfor(int i = 0; i < SIZE; i++){ //first_loc[i]<元>がi<先>に移る\n\t\t\t\twork[first_loc[i]] = i;\n\t\t\t}\n\n\t\t\tfor(int i = 0; i < SIZE; i++){ //i<元>が<先>work[i]に移る\n\t\t\t\tfirst_loc[i] = work[i];\n\t\t\t}\n\t\t}\n\t}\n\treturn first_loc;\n}\n\n\nint main(){\n\n\tscanf(\"%d %d\",&N,&length);\n\tSIZE = N*N;\n\n\tscanf(\"%s\",buf);\n\n\tMATRIX ans(SIZE),final_loc(SIZE);\n\tfinal_loc = calcNextLoc(0,length-1);\n\n\t/*for(int i = 0; i < SIZE; i++){\n\t\tprintf(\"final_loc[%d]:%d\\n\",i,final_loc[i]);\n\t}*/\n\n\tfor(int i = 0; i < SIZE; i++){\n\t\tans[final_loc[i]] = i+1;\n\t}\n\n\tfor(int row = 0; row < N; row++){\n\t\tprintf(\"%d\",ans[getLoc(row,0)]);\n\t\tfor(int col = 1; col < N; col++){\n\t\t\tprintf(\" %d\",ans[getLoc(row,col)]);\n\t\t}\n\t\tprintf(\"\\n\");\n\t}\n\n\treturn 0;\n}\n\n\n"
  },
  {
    "language": "C++",
    "code": "#include<iostream>\n#include<vector>\n#include<algorithm>\n#include<set>\n#include<map>\n#include<unordered_map>\n#include<queue>\n#include<iomanip>\n#include<math.h>\n#include<bitset>\n#include<cassert>\n#include<random>\n#include<time.h>\n#include<functional>\nusing namespace std;\nusing ll=long long;\nusing ld=long double;\nusing P=pair<ll,ll>;\n#define MOD 1000000007LL\n#define INF 1000000000LL\n#define EPS 1e-10\n#define FOR(i,n,m) for(ll i=n;i<(ll)m;i++)\n#define REP(i,n) FOR(i,0,n)\n#define DUMP(a) REP(d,a.size()){cout<<a[d];if(d!=a.size()-1)cout<<\" \";else cout<<endl;}\n#define ALL(v) v.begin(),v.end()\n#define UNIQUE(v)  sort(ALL(v));v.erase(unique(ALL(v)),v.end());\n#define pb push_back\n\nstruct Shift {\n\tll n;\n\tvector<vector<ll>> mat;\n\n\tShift(ll n) : n(n) {\n\t\tmat.assign(n, vector<ll>(n));\n\t\tREP(i, n) REP(j, n) mat[i][j] = i * n + j;\n\t}\n\n\tShift(ll n, vector<vector<ll>> v) : n(n), mat(v) {\n\t\tREP(i, n) REP(j, n) mat[i][j] = v[i][j];\n\t}\n\n\tvoid left(ll m) {\n\t\tll tmp = mat[m][0];\n\t\tREP(i, n - 1) mat[m][i] = mat[m][i + 1];\n\t\tmat[m][n - 1] = tmp;\n\t\treturn;\n\t}\n\n\tvoid right(ll m) {\n\t\tll tmp = mat[m][n - 1];\n\t\tfor(ll i = n - 2; i >= 0; i--) mat[m][i + 1] = mat[m][i];\n\t\tmat[m][0] = tmp;\n\t\treturn;\n\t}\n\n\tvoid up(ll m) {\n\t\tll tmp = mat[0][m];\n\t\tREP(i, n - 1) mat[i][m] = mat[i + 1][m];\n\t\tmat[n - 1][m] = tmp;\n\t\treturn;\n\t}\n\n\tvoid down(ll m) {\n\t\tll tmp = mat[n - 1][m];\n\t\tfor(ll i = n - 2; i >= 0; i--) mat[i + 1][m] = mat[i][m];\n\t\tmat[0][m] = tmp;\n\t\treturn;\n\t}\n\n\tll get(ll r, ll c) {\n\t\treturn mat[r][c];\n\t}\n\n\tShift operator * (Shift obj) {\n\t\tvector<vector<ll>> ret(n, vector<ll>(n, 0));\n\t\tREP(i, n) REP(j, n) {\n\t\t\tll tmp1 = obj.get(i, j);\n\t\t\tll tmp2 = mat[tmp1 / n][tmp1 % n];\n\t\t\tret[i][j] = tmp2;\n\t\t}\n\t\treturn Shift(n, ret);\n\t}\n};\n\nll n, l;\nstring s;\nll pos = 0;\n\nShift operation();\nShift repetition();\nShift sequence();\n\nll number() {\n\tstring numstr = \"\";\n\twhile(pos < l && s[pos] >= '0' && s[pos] <= '9') {\n\t\tnumstr += s[pos];\n\t\tpos++;\n\t}\n\tll num = stol(numstr);\n\treturn num;\n}\n\nShift operation() {\n\tShift ret(n);\n\tchar shift = s[pos]; pos++;\n\tll num = number();\n\tif(shift == 'L') ret.left(num - 1);\n\tif(shift == 'R') ret.right(num - 1);\n\tif(shift == 'U') ret.up(num - 1);\n\tif(shift == 'D') ret.down(num - 1);\n\treturn ret;\n}\n\nShift repetition() {\n\tShift a(n);\n\tpos++; a = a * sequence(); pos++;\n\tll num = number();\n\tShift ret(n);\n\twhile(num > 0) {\n\t\tif(num % 2) ret = ret * a;\n\t\ta = a * a;\n\t\tnum /= 2;\n\t}\n\treturn ret;\n}\n\nShift sequence() {\n\tShift ret(n);\n\tif(s[pos] == '(') ret = ret * repetition();\n\telse ret = ret * operation();\n\tif(pos == l || s[pos] == ')') return ret;\n\telse return ret * sequence();\n}\n\nint main() {\n\tcin.tie(0);\n\tios::sync_with_stdio(false);\n\tcin >> n >> l >> s;\n\tShift ans = sequence();\n\tREP(i, n) REP(j, n) {\n\t\tcout << ans.get(i, j) + 1;\n\t\tif(j != n - 1) cout << \" \";\n\t\telse cout << endl;\n\t}\n \treturn 0;\n}\n\n/* --------------------------------------- */\n\n\n"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\nusing namespace std;\ntypedef vector<int> vec;\nint n,len,pos;\nstring s;\n  \nvec mul(vec a,vec b){\n  vec res(n*n);\n  for(int i=0;i<n*n;i++)res[i]=b[a[i]];\n  return res;\n}\n  \nvec mpow(vec a,int t){\n  if(t==0){\n    vec res(n*n);\n    for(int i=0;i<n*n;i++)res[i]=i;\n    return res;\n  }  \n  vec res=mpow(mul(a,a),t/2);\n  if(t%2==1)res=mul(res,a);\n  return res;\n}\n  \nvec calc();\n  \nvec getNum(){\n  \n  if(s[pos]=='('){\n    pos++;\n    vec res=calc();\n     \n    int num=0;\n    while(pos<len&&'0'<=s[pos]&&s[pos]<='9')\n      num=num*10+s[pos++]-'0';\n    vec Ra= mpow(res,num);\n    return Ra;\n  }\n   \n  char ch=s[pos++];\n  int num=0;\n  while(pos<len&&'0'<=s[pos]&&s[pos]<='9'){\n    num=num*10+s[pos]-'0';\n    pos++;\n  }\n   \n  vec res(n*n);  \n  for(int i=0;i<n;i++){\n    for(int j=0;j<n;j++){\n      int ni=i,nj=j;\n      if(ch=='D'&&j+1==num){\n        ni=(i+1)%n;\n        nj=j;\n      }else if(ch=='L'&&i+1==num){\n        ni=i;\n        nj=(j+n-1)%n;\n      }else if(ch=='U'&&j+1==num){\n        ni=(i+n-1)%n;\n        nj=j;\n      }else if(ch=='R'&&i+1==num){\n        ni=i;\n        nj=(j+1)%n;\n      }\n      res[i*n+j]=ni*n+nj;\n    }\n  }\n  return res;\n}\n  \nint C=0;\nvec calc(){\n  vec res=getNum();\n   \n  while(pos<len){\n    if(s[pos]==')'){\n      pos++;\n      break;\n    }\n    vec num=getNum();\n    res=mul(res,num);\n  }\n  return res;\n}\n  \nint main() {\n  while(cin>>n>>len) {\n    cin>>s;\n    pos=0;\n    vec ans(n*n),ans2=calc();\n    for(int i=0;i<n*n;i++){\n      ans[ ans2[i]]=i;\n    }\n    for(int i=0;i<n;i++){\n      for(int j=0;j<n;j++){\n        if(j)cout<<' ';\n        cout<<ans[i*n+j]+1;\n      }\n      cout<<endl;\n    }\n  }\n  return 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\n#define GET_MACRO(_1,_2,_3,_4,_5,NAME,...) NAME\n#define pr(...) GET_MACRO(__VA_ARGS__,pr5,pr4,pr3,pr2,pr1)(__VA_ARGS__)\n#define pr1(a) (#a)<<\"=\"<<(a)\n#define pr2(a,b) pr1(a)<<\", \"<<pr1(b)\n#define pr3(a,b,c) pr2(a,b)<<\", \"<<pr1(c)\n#define pr4(a,b,c,d) pr3(a,b,c)<<\", \"<<pr1(d)\n#define pr5(a,b,c,d,e) pr4(a,b,c,d)<<\", \"<<pr1(e)\n#define int long long\n#define double long double\nusing namespace std;\nconst int N = 100010;\nconst int INF = 1LL<<55;\nconst int mod = (1e9)+7;\nconst double EPS = 1e-8;\nconst double PI = 6.0 * asin(0.5);\ntypedef pair<int,int> P;\ntypedef long long ll;\ntemplate<class T> T Max(T &a,T b){return a=max(a,b);}\ntemplate<class T> T Min(T &a,T b){return a=min(a,b);}\nostream& operator<<(ostream& o,P p){return o<<\"(\"<<p.first<<\",\"<<p.second<<\")\";}\nistream& operator>>(istream& i,P &p){return i>>p.first>>p.second;}\nostream& operator<<(ostream& o,vector<auto> &a){int i=0;for(auto t:a)o<<(i++?\" \":\"\")<<t;return o;}\nistream& operator>>(istream& i,vector<auto> &a){for(auto &t:a)i>>t;return i;}\nvoid prArr(auto a,string s=\" \"){int i=0;for(auto t:a)cout<<(i++?s:\"\")<<t;cout<<endl;}\n\ntypedef vector<int> vec;\ntypedef vector<vec> mat;\n\nmat move(mat a,mat b){\n  int n = a.size();\n  mat res(n,vec(n));\n\n  for(int i=0;i<n;i++)\n    for(int j=0;j<n;j++) {\n      int y = a[i][j] / n;\n      int x = a[i][j] % n;\n      res[i][j] = b[y][x];\n    }\n  return res;\n}\n\nint n,len;\nint pos;\nstring str;\n\nmat bfs();\nmat repeat();\nint number();\n  \nmat repeat(){\n  assert(str[pos] == '(');\n  pos++;\n  mat x = bfs();\n  assert(str[pos]==')');\n  pos++;\n  int num = number();\n  \n  mat res(n,vec(n));\n  for(int i=0;i<n;i++)\n    for(int j=0;j<n;j++) res[i][j] = i * n + j;\n\n  while(num){\n    if(num%2) res = move(res,x);\n    x = move(x,x);\n    num = num/2;\n  }\n  return res;\n}\n\nint number(){\n  assert(isdigit(str[pos]));\n  int res = 0;\n  while(isdigit(str[pos])) res = res * 10 + str[pos] - '0', pos++;\n  return res;\n}\n\nvoid L(mat &A){\n  assert(str[pos++] == 'L');\n  int k = number() - 1;\n  for(int i=0;i<n-1;i++) swap(A[k][i],A[k][i+1]);\n}\n\nvoid R(mat &A){\n  assert(str[pos++] == 'R');\n  int k = number() - 1;\n  for(int i=0;i<n-1;i++) swap(A[k][n-1-i],A[k][n-2-i]);\n};\n\nmat U(mat &A){\n  assert(str[pos++] == 'U');\n  int k = number() - 1;\n  for(int i=0;i<n-1;i++) swap(A[i][k],A[i+1][k]);\n};\nmat D(mat &A){\n  assert(str[pos++] == 'D');\n  int k = number() - 1;\n  for(int i=0;i<n-1;i++) swap(A[n-1-i][k],A[n-2-i][k]);\n};\n\nmat bfs(){\n  mat res(n,vec(n));\n  for(int i=0;i<n;i++)\n    for(int j=0;j<n;j++) res[i][j] = i*n + j;\n  \n  while(pos < (int)str.size()){\n    char ch = str[pos];\n    if(ch == '(') res = repeat();\n    else if(ch == 'L') L(res);\n    else if(ch == 'R') R(res);\n    else if(ch == 'U') U(res);\n    else if(ch == 'D') D(res);\n    else break;\n  }\n  return res;\n}\n\nsigned main(){\n  int L;\n  cin>>n>>L;\n  cin>>str;\n  \n  mat ans = bfs();\n  for(int i=0;i<n;i++)\n    for(int j=0;j<n;j++) ans[i][j] ++;\n  for(int i=0;i<n;i++) cout<<ans[i]<<endl;\n  \n  return 0;\n}\n\n"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\n#define GET_MACRO(_1,_2,_3,_4,_5,NAME,...) NAME\n#define pr(...) GET_MACRO(__VA_ARGS__,pr5,pr4,pr3,pr2,pr1)(__VA_ARGS__)\n#define pr1(a) (#a)<<\"=\"<<(a)\n#define pr2(a,b) pr1(a)<<\", \"<<pr1(b)\n#define pr3(a,b,c) pr2(a,b)<<\", \"<<pr1(c)\n#define pr4(a,b,c,d) pr3(a,b,c)<<\", \"<<pr1(d)\n#define pr5(a,b,c,d,e) pr4(a,b,c,d)<<\", \"<<pr1(e)\n#define int long long\n#define double long double\nusing namespace std;\nconst int N = 100010;\nconst int INF = 1LL<<55;\nconst int mod = (1e9)+7;\nconst double EPS = 1e-8;\nconst double PI = 6.0 * asin(0.5);\ntypedef pair<int,int> P;\ntypedef long long ll;\ntemplate<class T> T Max(T &a,T b){return a=max(a,b);}\ntemplate<class T> T Min(T &a,T b){return a=min(a,b);}\nostream& operator<<(ostream& o,P p){return o<<\"(\"<<p.first<<\",\"<<p.second<<\")\";}\nistream& operator>>(istream& i,P &p){return i>>p.first>>p.second;}\nostream& operator<<(ostream& o,vector<auto> &a){int i=0;for(auto t:a)o<<(i++?\" \":\"\")<<t;return o;}\nistream& operator>>(istream& i,vector<auto> &a){for(auto &t:a)i>>t;return i;}\nvoid prArr(auto a,string s=\" \"){int i=0;for(auto t:a)cout<<(i++?s:\"\")<<t;cout<<endl;}\n\ntypedef vector<int> vec;\ntypedef vector<vec> mat;\n\nmat move(mat a,mat b){\n  int n = a.size();\n  mat res(n,vec(n));\n\n  for(int i=0;i<n;i++)\n    for(int j=0;j<n;j++) {\n      int y = a[i][j] / n;\n      int x = a[i][j] % n;\n      res[i][j] = b[y][x];\n    }\n  return res;\n}\n\nint n,len;\nint pos;\nstring str;\n\nmat bfs();\nmat repeat();\nint number();\n  \nmat repeat(){\n  //assert(str[pos] == '(');\n  pos++;\n  mat x = bfs();\n  //assert(str[pos]==')');\n  pos++;\n  int num = number();\n  \n  mat res(n,vec(n));\n  for(int i=0;i<n;i++)\n    for(int j=0;j<n;j++) res[i][j] = i * n + j;\n\n  while(num){\n    if(num%2) res = move(res,x);\n    x = move(x,x);\n    num = num/2;\n  }\n  return res;\n}\n\nint number(){\n  //assert(isdigit(str[pos]));\n  int res = 0;\n  while(isdigit(str[pos])) res = res * 10 + str[pos] - '0', pos++;\n  return res;\n}\n\nvoid L(mat &A){\n  //assert(str[pos] == 'L');\n  pos++;\n  int k = number() - 1;\n  for(int i=0;i<n-1;i++) swap(A[k][i],A[k][i+1]);\n}\n\nvoid R(mat &A){\n  //assert(str[pos] == 'R');\n  pos++;\n  int k = number() - 1;\n  for(int i=0;i<n-1;i++) swap(A[k][n-1-i],A[k][n-2-i]);\n};\n\nmat U(mat &A){\n  //assert(str[pos] == 'U');\n  pos++;\n  int k = number() - 1;\n  for(int i=0;i<n-1;i++) swap(A[i][k],A[i+1][k]);\n};\nmat D(mat &A){\n  //assert(str[pos] == 'D');\n  pos++;\n  int k = number() - 1;\n  for(int i=0;i<n-1;i++) swap(A[n-1-i][k],A[n-2-i][k]);\n};\n\nmat bfs(){\n  mat res(n,vec(n));\n  for(int i=0;i<n;i++)\n    for(int j=0;j<n;j++) res[i][j] = i*n + j;\n  \n  while(pos < (int)str.size()){\n    char ch = str[pos];\n    if(ch == '(') res = repeat();\n    else if(ch == 'L') L(res);\n    else if(ch == 'R') R(res);\n    else if(ch == 'U') U(res);\n    else if(ch == 'D') D(res);\n    else break;\n  }\n  return res;\n}\n\nsigned main(){\n  int L;\n  cin>>n>>L;\n  cin>>str;\n  \n  mat ans = bfs();\n  for(int i=0;i<n;i++)\n    for(int j=0;j<n;j++) ans[i][j] ++;\n  for(int i=0;i<n;i++) cout<<ans[i]<<endl;\n  \n  return 0;\n}\n\n"
  },
  {
    "language": "C++",
    "code": "#include <iostream>\n#include <vector>\n\nusing namespace std;\n\nint N;\nvector<int> L(int n){\n    vector<int> V(N*N);\n    for(int i=0;i<N*N;i++) V[i]=i;\n    for(int i=N*(n-1);i<N*n-1;i++){\n        V[i]=i+1;\n    }\n    V[N*n-1]=N*(n-1);\n    return V;\n}\n\nvector<int> R(int n){\n    vector<int> V(N*N);\n    for(int i=0;i<N*N;i++) V[i]=i;\n    for(int i=N*(n-1)+1;i<N*n;i++){\n        V[i]=i-1;\n    }\n    V[N*(n-1)]=N*n-1;\n    return V;\n}\n\nvector<int> U(int n){\n    vector<int> V(N*N);\n    for(int i=0;i<N*N;i++) V[i]=i;\n    for(int i=n-1;i+N<N*N;i+=N) V[i]+=N; \n    V[N*(N-1)+(n-1)]=n-1;\n    return V;\n}\n\nvector<int> D(int n){\n    vector<int> V(N*N);\n    for(int i=0;i<N*N;i++) V[i]=i;\n    for(int i=N+n-1;i<N*N;i+=N) V[i]-=N;\n    V[n-1]=N*(N-1)+(n-1);\n    return V;\n}   \n\nvector<int> C(vector<int> V1, vector<int> V2){\n    vector<int> V(N*N);\n    for(int i=0;i<N*N;i++) V[i]=V1[V2[i]];\n    return V;\n}\n\nvector<int> T(vector<int> V ,int n){\n    int b=1;\n    vector<int> B=V;\n    vector<int> ret(N*N);\n    for(int i=0;i<N*N;i++) ret[i]=i;\n    while(n>=b){\n        if(b&n){\n            ret=C(ret,B);\n        }\n        B=C(B,B);\n        b<<=1;\n    }\n    return ret;\n}\n\nint number(string S, int& ite){\n    int n=0;\n    while('0'<=S[ite]&&S[ite]<='9'){\n        n*=10;\n        n+=S[ite]-'0';\n        ite++;//テ」ツ?禿」ツ?ョテヲツ卍づァツつケテ」ツ?ァテ」ツ?ッ')'テ」ツ?凝ヲツ慊ォテ・ツーツセ\n    }\n    return n;\n}\n\nvector<int> rec(string S, int& ite){\n    vector<int> ret(N*N),fac;\n    for(int i=0;i<N*N;i++) ret[i]=i;\n    while(ite<S.size()){\n        if(S[ite]=='('){\n            ite++;\n            fac=rec(S,ite);\n            ite++;//')'テ」ツつ津ィツェツュテ」ツ?ソテゥツ」ツ崚」ツ?ーテ」ツ??\n            fac=T(fac,number(S,ite));\n            ret=C(ret,fac);\n        }else{\n            if(S[ite]=='R'){\n                ite++;\n                fac=R(number(S,ite));\n            }else if(S[ite]=='L'){\n                ite++;\n                fac=L(number(S,ite));\n            }else if(S[ite]=='D'){\n                ite++;\n                fac=D(number(S,ite));\n            }else if(S[ite]=='U'){\n                ite++;\n                fac=U(number(S,ite));\n            }else{\n                cout<<\"err\"<<endl;\n                exit(1);\n            }\n            ret=C(ret,fac);\n        }\n        if(S[ite]==')') break;\n    }\n    return ret;\n}\n\nint main(){\n    int l;\n    cin>>N>>l;\n    string S;\n    cin>>S;\n    if(N==1){\n        cout<<1<<endl;\n        return 0;\n    }\n    int i=0;\n    vector<int> ans = rec(S,i);\n    for(int i=0;i<N;i++){\n        for(int j=0;j<N;j++){\n            if(j)cout<<' ';\n            cout<<ans[i*N+j]+1;\n        }\n        cout<<endl;\n    }\n\n    return 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include <cstdio>\n#include <cstdint>\n#include <cctype>\n#include <cassert>\n#include <string>\n#include <vector>\n#include <algorithm>\n\nclass Permutation {\n  size_t n;\n  std::vector<std::vector<size_t>> body;\n\npublic:\n  Permutation(size_t n): n(n), body(n, std::vector<size_t>(n)) {\n    size_t k=0;\n    for (size_t i=0; i<n; ++i)\n      for (size_t j=0; j<n; ++j)\n        body[i][j] = k++;\n  }\n  Permutation(size_t n, char shift, size_t k): Permutation(n) {\n    if (shift == 'L') {\n      size_t tmp=body[k][0];\n      for (size_t j=1; j<n; ++j)\n        body[k][j-1] = body[k][j];\n      body[k][n-1] = tmp;\n    } else if (shift == 'R') {\n      size_t tmp=body[k][n-1];\n      for (size_t j=n-1; j--;)\n        body[k][j+1] = body[k][j];\n      body[k][0] = tmp;\n    } else if (shift == 'U') {\n      size_t tmp=body[0][k];\n      for (size_t i=1; i<n; ++i)\n        body[i-1][k] = body[i][k];\n      body[n-1][k] = tmp;\n    } else if (shift == 'D') {\n      size_t tmp=body[n-1][k];\n      for (size_t i=n-1; i--;)\n        body[i+1][k] = body[i][k];\n      body[0][k] = tmp;\n    }\n  }\n\n  Permutation& operator *=(const Permutation& other) {\n    Permutation tmp(n);\n    for (size_t i=0; i<n; ++i)\n      for (size_t j=0; j<n; ++j) {\n        size_t ii=other[i][j]/n;\n        size_t jj=other[i][j]%n;\n        tmp[i][j] = (*this)[ii][jj];\n      }\n\n    body = std::move(tmp.body);\n    return *this;\n  }\n\n  Permutation& operator ^=(uintmax_t iexp) {\n    Permutation tmp(n);\n    for (Permutation dbl=*this; iexp; iexp>>=1) {\n      if (iexp & 1) tmp *= dbl;\n      dbl *= dbl;\n    }\n    body = std::move(tmp.body);\n    return *this;\n  }\n\n  const std::vector<size_t>& operator [](size_t i) const {\n    return body[i];\n  }\n\n  std::vector<size_t>& operator [](size_t i) {\n    return body[i];\n  }\n\n  void print() const {\n    for (size_t i=0; i<n; ++i)\n      for (size_t j=0; j<n; ++j)\n        printf(\"%zu%c\", body[i][j]+1, j+1<n? ' ':'\\n');\n  }\n};\n\nuintmax_t parse_int(const std::string& s, size_t& i) {\n  uintmax_t res=s[i]-'0';\n  while (++i < s.length() && isdigit(s[i]))\n    res = res*10+s[i]-'0';\n  return res;\n}\n\nPermutation parse(const std::string& s, size_t& i, size_t n) {\n  Permutation res(n);\n  while (i < s.length() && s[i] != ')') {\n    if (s[i] == '(') {\n      Permutation tmp=parse(s, ++i, n);\n      assert(s[i] == ')');\n      tmp ^= parse_int(s, ++i);\n      res *= tmp;\n    } else {\n      char shift=s[i];\n      size_t number=parse_int(s, ++i);\n      Permutation tmp(n, shift, number-1);\n      res *= tmp;\n    }\n  }\n  return res;\n}\n\nint main() {\n  size_t N, L;\n  char buf[1024];\n  scanf(\"%zu %zu %s\", &N, &L, buf);\n  std::string S=buf;\n\n  size_t i=0;\n  parse(S, i, N).print();\n}\n"
  },
  {
    "language": "C++",
    "code": "#include<bits/stdc++.h>\nusing namespace std;\n#define int long long\ntypedef vector<vector<int> > mat;\nint n,l,pos=0;\nstring s;\nmat init(){\n  mat res;\n  res.resize(n,vector<int>(n));\n  for(int i=0;i<n;i++)\n    for(int j=0;j<n;j++)\n      res[i][j]=i*n+j;\n  return res;\n}\n\nmat expr();\nmat repet();\n\nmat expr(){\n  mat res=init();\n  while(pos<l){\n    //cout<<pos<<endl;\n    if(isupper(s[pos])){\n      char c=s[pos++];\n      int m=0;\n      while(isdigit(s[pos]))\n\tm=m*10+s[pos++]-'0';\n      //cout<<c<<\" \"<<m<<endl;\n      m--;\n      if(c=='R'){\n\tint tmp=res[m][n-1];\n\tfor(int j=n-1;j>0;j--) res[m][j]=res[m][j-1];\n\tres[m][0]=tmp;\n      }\n      if(c=='L'){\n\tint tmp=res[m][0];\n\tfor(int j=0;j<n-1;j++) res[m][j]=res[m][j+1];\n\tres[m][n-1]=tmp;\n      }\n      if(c=='D'){\n\tint tmp=res[n-1][m];\n\tfor(int j=n-1;j>0;j--) res[j][m]=res[j-1][m];\n\tres[0][m]=tmp;\n      }\n      if(c=='U'){\n\tint tmp=res[0][m];\n\tfor(int j=0;j<n-1;j++) res[j][m]=res[j+1][m];\n\tres[n-1][m]=tmp;\n      }\n    }else if(s[pos]=='(') {\n      mat tmp=repet();\n       for(int i=0;i<n;i++)\n\t for(int j=0;j<n;j++)\n\t   res[i][j]=tmp[res[i][j]/n][res[i][j]%n];\n    }else break;\n  }\n  return res;\n}\n\nmat repet(){\n  mat res=init();\n  assert(s[pos]=='(');\n  pos++;\n  mat tmp[100];\n  tmp[0]=expr();\n  assert(s[pos]==')');\n  pos++;\n  int m=0;\n  while(pos<l&&isdigit(s[pos]))\n    m=m*10+s[pos++]-'0';\n\n  /*\n  for(int i=0;i<n;i++)\n    for(int j=0;j<n;j++)\n      cout<<tmp[0][i][j]<<\" \\n\"[j==n-1];\n  */\n  \n  for(int k=0;(m>>k);k++){\n    if((m>>k)&1){\n      for(int i=0;i<n;i++)\n\tfor(int j=0;j<n;j++)\n\t  res[i][j]=tmp[k][res[i][j]/n][res[i][j]%n];\n    }\n    tmp[k+1]=init();\n    \n    for(int i=0;i<n;i++)\n      for(int j=0;j<n;j++)\n\ttmp[k+1][i][j]=tmp[k][tmp[k][i][j]/n][tmp[k][i][j]%n];\n\n    /*\n    for(int i=0;i<n;i++)\n      for(int j=0;j<n;j++)\n\tcout<<tmp[k+1][i][j]<<\" \\n\"[j==n-1];\n    */\n  }\n  \n  return res;\n}\nsigned main(){\n  cin>>n>>l>>s;\n  mat ans=expr();\n  for(int i=0;i<n;i++)\n    for(int j=0;j<n;j++)\n      cout<<ans[i][j]+1<<\" \\n\"[j==n-1];\n  return 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\n\nusing namespace std;\n\ntypedef vector< int > vi;\n\nvi mat;\nint N, L, idx;\nstring S;\n\nvi press(vi a, vi b)\n{\n  for(int i = 0; i < N * N; i++) b[i] = a[b[i]];\n  return (b);\n}\n\n\nvi fact(vi &v, int k)\n{\n  vi ret = mat;\n  while(k > 0) {\n    if(k & 1) ret = press(ret, v);\n    v = press(v, v);\n    k /= 2;\n  }\n  return (ret);\n}\n\nint num()\n{\n  int ret = 0;\n  while(idx < S.size() && isdigit(S[idx])) {\n    ret = ret * 10 + S[idx++] - '0';\n  }\n  return (ret);\n}\n\nvi sequence()\n{\n  if(idx == S.size() || S[idx] == ')') return (mat);\n  if(S[idx] == '(') {\n    ++idx;\n    vi get = sequence();\n    ++idx;\n    return (fact(get, num()));\n  }\n  vi ret = mat;\n  if(S[idx] == 'L') {\n    ++idx;\n    int rep = num() - 1;\n    for(int i = 0; i < N; i++) ret[rep * N + i] = rep * N + (i + 1) % N;\n  } else if(S[idx] == 'R') {\n    ++idx;\n    int rep = num() - 1;\n    for(int i = 0; i < N; i++) ret[rep * N + i] = rep * N + (i + N - 1) % N;\n  } else if(S[idx] == 'U') {\n    ++idx;\n    int rep = num() - 1;\n    for(int i = 0; i < N; i++) ret[i * N + rep] = (i + 1) % N * N + rep;\n  } else {\n    ++idx;\n    int rep = num() - 1;\n    for(int i = 0; i < N; i++) ret[i * N + rep] = (i + N - 1) % N * N + rep;\n  }\n  return (press(ret, sequence()));\n}\n\nint main()\n{\n  cin >> N >> L;\n  cin >> S;\n\n  mat.resize(N * N);\n  iota(begin(mat), end(mat), 0);\n  auto ret = sequence();\n\n  for(int i = 0; i < N; i++) {\n    for(int j = 0; j < N; j++) {\n      if(j > 0) cout << \" \";\n      cout << ret[i * N + j] + 1;\n    }\n    cout << endl;\n  }\n}"
  },
  {
    "language": "C++",
    "code": "#include \"bits/stdc++.h\"\n\n#define REP(i,n) for(ll i=0;i<n;++i)\n#define RREP(i,n) for(ll i=n-1;i>=0;--i)\n#define FOR(i,m,n) for(ll i=m;i<n;++i)\n#define RFOR(i,m,n) for(ll i=n-1;i>=m;--i)\n#define ALL(v) (v).begin(),(v).end()\n#define PB(a) push_back(a)\n#define UNIQUE(v) v.erase(unique(ALL(v)),v.end());\n#define DUMP(v) REP(aa, (v).size()) { cout << v[a]; if (a != v.size() - 1)cout << \" \"; else cout << endl; }\n#define INF 1000000001ll\n#define MOD 1000000007ll\n#define EPS 1e-9\n\nconst int dx[8] = { 1,1,0,-1,-1,-1,0,1 };\nconst int dy[8] = { 0,1,1,1,0,-1,-1,-1 };\n\n\nusing namespace std;\ntypedef long long ll;\ntypedef vector<int> vi;\ntypedef vector<ll> vl;\ntypedef vector<vi> vvi;\ntypedef vector<vl> vvl;\ntypedef pair<int, int> pii;\ntypedef pair<ll, ll> pll;\nll max(ll a, int b) { return max(a, ll(b)); }\nll max(int a, ll b) { return max(ll(a), b); }\nll min(ll a, int b) { return min(a, ll(b)); }\nll min(int a, ll b) { return min(ll(a), b); }\n///(´・ω・`)(´・ω・`)(´・ω・`)(´・ω・`)(´・ω・`)(´・ω・`)///\nvvi id();\nint num(int &);\nvvi seq(int &);\nvvi rep(int &);\nvvi operation(int &);\nstring s;\nint n, l;\nint num(int &i) {\n\tint ret = 0;\n\twhile (i < l&&isdigit(s[i])) {\n\t\tret *= 10;\n\t\tret += s[i] - '0';\n\t\t++i;\n\t}\n\treturn ret;\n}\n\nvvi operation(int &i) {\n\tchar c = s[i];\n\t++i;\n\tint a = num(i);\n\tvvi ret(n, vi(n));\n\tREP(k, n) {\n\t\tREP(j, n) {\n\t\t\tret[k][j] = k*n + j;\n\t\t}\n\t}\n\tif (c == 'R') {\n\t\tREP(k, n - 1) {\n\t\t\tret[a - 1][k + 1] = (a - 1)*n + k;\n\t\t}\n\t\tret[a - 1][0] = (a - 1)*n + n - 1;\n\t}\n\telse if (c == 'L') {\n\t\tREP(k, n - 1) {\n\t\t\tret[a - 1][k] = (a - 1)*n + k + 1;\n\t\t}\n\t\tret[a - 1][n - 1] = (a - 1)*n;\n\t}\n\telse if (c == 'D') {\n\t\tREP(k, n - 1) {\n\t\t\tret[k + 1][a - 1] = k*n + a - 1;\n\t\t}\n\t\tret[0][a - 1] = (n-1)*n+a-1;\n\t}\n\telse if (c == 'U') {\n\t\tREP(k, n - 1) {\n\t\t\tret[k][a - 1] = (k + 1)*n + a - 1;\n\t\t}\n\t\tret[n - 1][a - 1] = a-1;\n\t}\n\treturn ret;\n}\n\nvvi con(vvi b, vvi a) {\n\tvvi ret(n, vi(n));\n\tREP(i, n) {\n\t\tREP(j, n) {\n\t\t\tint c = a[i][j];\n\t\t\tint e = c%n, d = c / n;\n\t\t\tint f = b[d][e];\n\t\t\tret[i][j] = f;\n\t\t}\n\t}\n\treturn ret;\n}\n\nvvi rep(int &i) {\n\t++i;\n\tvvi ret = seq(i);\n\t++i;\n\tint a = num(i);\n\tint c = ceil(log2(a));\n\tvector<vvi> x(c+1);\n\tx[0] = ret;\n\tint j = 0;\n\tREP(k, c) {\n\t\tx[k + 1] = con(x[k], x[k]);\n\t}\n\tvvi ans = id();\n\t//cout << a <<\" \"<<c<< endl;\n\tREP(k, c+1) {\n\t\tif (a&(1 << k)) {\n\t\t\tans = con(ans, x[k]);\n\t\t\tj += (1 << k);\n\t\t}\n\t\t\n\t}\n\t//cout << j << endl;\n\treturn ans;\n}\nvvi seq(int &i) {\n\tif (i == l || s[i] == ')') {\n\t\treturn id();\n\t}\n\tvvi a;\n\tif (s[i] == '(') {\n\t\ta = rep(i);\n\t}\n\telse {\n\t\ta = operation(i);\n\t}\n\tvvi ret = con(a, seq(i));\n\treturn ret;\n}\nvvi id() {\n\tvvi a(n, vi(n));\n\tREP(i, n) {\n\t\tREP(j, n) {\n\t\t\ta[i][j] = i*n + j;\n\t\t}\n\t}\n\treturn a;\n}\nint main() {\n\tcin.tie(0);\n\tios::sync_with_stdio(false);\n\n\tcin >> n >> l;\n\tcin >> s;\n\tint i = 0;\n\tvvi a = seq(i);\n\tREP(k, n) {\n\t\tREP(j, n) {\n\t\t\tcout << a[k][j] + 1;\n\t\t\tif (j != n - 1)cout << \" \";\n\t\t\telse cout << endl;\n\t\t}\n\t}\n\n\treturn 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include <vector>\n#include <iostream>\n#include <utility>\n#include <algorithm>\n#include <string>\n#include <deque>\n#include <queue>\n#include <tuple>\n#include <queue>\n#include <functional>\n#include <cmath>\n#include <iomanip>\n#include <map>\n#include <set>\n#include <numeric>\n#include <unordered_map>\n#include <unordered_set>\n#include <complex>\n#include <iterator>\n#include <array>\n#include <memory>\n#include <random>\n//cin.sync_with_stdio(false);\n//streambuf\nusing namespace std;\ntypedef long long ll;\ntypedef long double ld;\ntypedef pair<int, int> pii;\ntypedef pair<ll, ll> pll;\ntypedef pair<double, double> pdd;\nusing vi = vector<int>;\nusing vll = vector<ll>;\nusing vpii = vector<pii>;\nusing vpll = vector<pll>;\nusing ti3 = tuple<int, int, int>;\nusing vti3 = vector<ti3>;\ntemplate<class T, int s>using va = vector<array<T, s>>;\ntemplate<class T, class T2> using umap = unordered_map<T, T2>;\ntemplate<class T> using uset = unordered_set<T>;\ntemplate<class T, class S> void cmin(T &a, const S &b) { if (a > b)a = b; }\ntemplate<class T, class S> void cmax(T &a, const S &b) { if (a < b)a = b; }\n#define ALL(a) a.begin(),a.end()\n#define rep(i,a) for(int i=0;i<a;i++)\n#define rep1(i,a) for(int i=1;i<=a;i++)\n#define rrep(i,a) for(int i=(a)-1;i>=0;i--)\n#define rrep1(i,a) for(int i=a;i;i--)\nconst ll mod = 1000000007;\n#define REP rep\ntemplate<class T>using heap = priority_queue<T, vector<T>, greater<T>>;\ntemplate<class T>using pque = priority_queue<T, vector<T>, function<T(T, T)>>;\ntemplate <class T>\ninline void hash_combine(size_t & seed, const T & v) {\n\thash<T> hasher;\n\tseed ^= hasher(v) + 0x9e3779b9 + (seed << 6) + (seed >> 2);\n}\nnamespace std {\n\ttemplate<typename S, typename T> struct hash<pair<S, T>> {\n\t\tinline size_t operator()(const pair<S, T> & v) const {\n\t\t\tsize_t seed = 0;\n\t\t\thash_combine(seed, v.first);\n\t\t\thash_combine(seed, v.second);\n\t\t\treturn seed;\n\t\t}\n\t};\n\t// Recursive template code derived from Matthieu M.\n\ttemplate <class Tuple, size_t Index = std::tuple_size<Tuple>::value - 1>\n\tstruct HashValueImpl {\n\t\tstatic void apply(size_t& seed, Tuple const& tuple) {\n\t\t\tHashValueImpl<Tuple, Index - 1>::apply(seed, tuple);\n\t\t\thash_combine(seed, std::get<Index>(tuple));\n\t\t}\n\t};\n\ttemplate <class Tuple>\n\tstruct HashValueImpl<Tuple, 0> {\n\t\tstatic void apply(size_t& seed, Tuple const& tuple) {\n\t\t\thash_combine(seed, std::get<0>(tuple));\n\t\t}\n\t};\n\ttemplate <typename ... TT>\n\tstruct hash<std::tuple<TT...>> {\n\t\tsize_t operator()(std::tuple<TT...> const& tt) const {\n\t\t\tsize_t seed = 0;\n\t\t\tHashValueImpl<std::tuple<TT...> >::apply(seed, tt);\n\t\t\treturn seed;\n\t\t}\n\t};\n}\ntemplate<class T>int id(vector<T> &a, T b) {\n\treturn lower_bound(ALL(a), b) - a.begin();\n}\nll pow(ll base, ll i, ll mod) {\n\tll a = 1;\n\twhile (i) {\n\t\tif (i & 1) {\n\t\t\ta *= base;\n\t\t\ta %= mod;\n\t\t}\n\t\tbase *= base;\n\t\tbase %= mod;\n\t\ti /= 2;\n\t}\n\treturn a;\n}\nll gcd(ll a, ll b) {\n\twhile (b) {\n\t\tll c = a%b;\n\t\ta = b;\n\t\tb = c;\n\t}\n\treturn a;\n}\nll lcm(ll a, ll b) {\n\treturn a / gcd(a, b)*b;\n}\nint popcnt(unsigned long long a) {\n\ta = (a & 0x5555555555555555) + (a >> 1 & 0x5555555555555555);\n\ta = (a & 0x3333333333333333) + (a >> 2 & 0x3333333333333333);\n\ta = (a & 0x0f0f0f0f0f0f0f0f) + (a >> 4 & 0x0f0f0f0f0f0f0f0f);\n\ta = (a & 0x00ff00ff00ff00ff) + (a >> 8 & 0x00ff00ff00ff00ff);\n\ta = (a & 0x0000ffff0000ffff) + (a >> 16 & 0x0000ffff0000ffff);\n\treturn (a & 0xffffffff) + (a >> 32);\n}\nclass unionfind {\n\tvector<int> par, rank, size_;//????????§??????????????¢???????????????????????????rank???????????????size?????????\npublic:\n\tunionfind(int n) :par(n), rank(n), size_(n, 1) {\n\t\tiota(ALL(par), 0);\n\t}\n\tint find(int x) {\n\t\tif (par[x] == x)return x;\n\t\treturn par[x] = find(par[x]);\n\t}\n\tvoid unite(int x, int y) {\n\t\tx = find(x), y = find(y);\n\t\tif (x == y)return;\n\t\tif (rank[x] < rank[y])swap(x, y);\n\t\tpar[y] = x;\n\t\tsize_[x] += size_[y];\n\t\tif (rank[x] == rank[y])rank[x]++;\n\t}\n\tbool same(int x, int y) {\n\t\treturn find(x) == find(y);\n\t}\n\tint size(int x) {\n\t\treturn size_[find(x)];\n\t}\n};\ntemplate<class T, class Func = function<T(T, T)>>\nclass segtree {\n\tvector<T> obj;\n\tint offset;\n\tFunc updater;\n\tT e;\n\tint bufsize(int num) {\n\t\tint i = 1;\n\t\tfor (; num >i; i <<= 1);\n\t\toffset = i - 1;\n\t\treturn (i << 1) - 1;\n\t}\n\tT query(int a, int b, int k, int l, int r) {\n\t\tif (r <= a || b <= l)return e;\n\t\tif (a <= l && r <= b)return obj[k];\n\t\telse return updater(query(a, b, k * 2 + 1, l, (l + r) / 2), query(a, b, k * 2 + 2, (l + r) / 2, r));\n\t}\n\t/*\n\ttemplate<class QF = function<T(T, T)>>\n\tauto query(int a, int b, int k, int l, int r,QF qf) {\n\tif (r <= a || b <= l)return e;\n\tif (a <= l && r <= b)return obj[k];\n\telse return qf(query(a, b, k * 2 + 1, l, (l + r) / 2, qf), query(a, b, k * 2 + 2, (l + r) / 2, r, qf));\n\t}*/\npublic:\n\tT query(int a, int b) {//[a,b)\n\t\treturn query(a, b, 0, 0, offset + 1);\n\t}/*\n\t template<class QF = function<T(T, T)>>\n\t auto query(int a, int b,QF &&qf) {//[a,b)\n\t return query(a, b, 0, 0, offset + 1,qf);\n\t }*/\n\tvoid updateall(int l = 0, int r = -1) {\n\t\tif (r < 0)r = offset + 1;\n\t\tl += offset, r += offset;\n\t\tdo {\n\t\t\tl = l - 1 >> 1, r = r - 1 >> 1;\n\t\t\tfor (int i = l; i < r; i++)obj[i] = updater(obj[i * 2 + 1], obj[i * 2 + 2]);\n\t\t} while (l);\n\t}\n\tvoid update(int k, T &a) {\n\t\tk += offset;\n\t\tobj[k] = a;\n\t\twhile (k) {\n\t\t\tk = k - 1 >> 1;\n\t\t\tobj[k] = updater(obj[k * 2 + 1], obj[k * 2 + 2]);\n\t\t}\n\t}\n\tsegtree(int n, T e, const Func &updater = Func()) :obj(bufsize(n), e), e(e), updater(updater) {}\n\tsegtree(vector<T> &vec, T e, const Func &updater = Func()) :obj(bufsize(vec.size()), e), e(e), updater(updater) {\n\t\tcopy(vec.begin(), vec.end(), obj.begin() + offset);\n\t\tupdateall();\n\t}\n\ttypename vector<T>::reference operator[](int n) {\n\t\treturn obj[n + offset];\n\t}\n};\ntemplate<class T = int>\nclass BIT {//????¬????BIT????????????????????????????????°??????????????????\n\tvector<T> bit;\n\tint n;\npublic:\n\tBIT(int n) :bit(n + 1, 0) {}\n\tvoid add(int i, T x) {\n\t\ti++;\n\t\twhile (i <= n) {\n\t\t\tbit[i] += x;\n\t\t\ti += i&-i;\n\t\t}\n\t}\n\tT sum(int i) {\n\t\tT s = 0;\n\t\ti++;\n\t\twhile (i) {\n\t\t\ts += bit[i];\n\t\t\ti &= i - 1;\n\t\t}\n\t\treturn s;\n\t}\n};\ntemplate<class T = int>\nclass rangeadd {\n\tBIT<T> b0, b1;\npublic:\n\trangeadd(int n) :b0(n), b1(n) {};\n\tvoid add(int l, int r, T x) {//[l,r)\n\t\tb0.add(l, -x*(l - 1));\n\t\tb1.add(l, x);\n\t\tb0.add(r, x*r);\n\t\tb1.add(r, -x);\n\t}\n\tT sum(int i) {\n\t\tif (i < 0)return 0;\n\t\treturn b0.sum(i) + b1.sum(i)*i;\n\t}\n\tT sum(int l, int r) {\n\t\treturn sum(r - 1) - sum(l - 1);\n\t}\n};\nstring s;\nint pos;\nint n, l;\nvector<vector<pii>> init;\nvector<vector<pii>> g(const vector<vector<pii>>&a,const vector<vector<pii>>&b) {\n\tvector<vector<pii>> r = init;\n\trep(i, n)rep(j, n)r[i][j] = b[a[i][j].first][a[i][j].second];\n\treturn r;\n}vector<vector<pii>> pow(vector<vector<pii>> base, int i) {\n\tvector<vector<pii>> r = init;\n\twhile (i) {\n\t\tif (i & 1) {\n\t\t\tr = g(r, base);\n\t\t}\n\t\tbase = g(base, base);\n\t\ti /= 2;\n\t}\n\treturn r;\n}\nint num() {\n\tint r = 0;\n\twhile ('0' <= s[pos] && s[pos] <= '9') {\n\t\tr *= 10;\n\t\tr += s[pos] - '0';\n\t\tpos++;\n\t}\n\treturn r;\n}\nvector<vector<pii>> f() {\n\tvector<vector<pii>> prev=init;\n\twhile (pos != l) {\n\t\tswitch (s[pos]) {\n\t\tcase '(':\n\t\t{\n\t\t\tpos++;\n\t\t\tvector<vector<pii>> buf = f();\n\t\t\tprev = g(prev, pow(buf, num()));\n\t\t\tbreak;\n\t\t}\n\t\tcase ')':\n\t\t\tpos++;\n\t\t\treturn prev;\n\t\tcase 'U':\n\t\t\t{\n\t\t\t\tpos++;\n\t\t\t\tint a = num();\n\t\t\t\ta--;\n\t\t\t\trep(i, n)rep(j, n) {\n\t\t\t\t\tif (prev[i][j].second == a) {\n\t\t\t\t\t\tprev[i][j].first = (prev[i][j].first + n - 1) % n;\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t}\n\t\t\tbreak;\n\t\tcase 'D':\n\t\t\t{\n\t\t\t\tpos++;\n\t\t\t\tint a = num();\n\t\t\t\ta--;\n\t\t\t\trep(i, n)rep(j, n) {\n\t\t\t\t\tif (prev[i][j].second == a) {\n\t\t\t\t\t\tprev[i][j].first = (prev[i][j].first + 1) % n;\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t}\n\t\t\tbreak;\n\t\tcase 'L':\n\t\t\t{\n\t\t\t\tpos++;\n\t\t\t\tint a = num();\n\t\t\t\ta--;\n\t\t\t\trep(i, n)rep(j, n) {\n\t\t\t\t\tif (prev[i][j].first == a) {\n\t\t\t\t\t\tprev[i][j].second = (prev[i][j].second + n - 1) % n;\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t}\n\t\t\tbreak;\n\t\tcase 'R':\n\t\t\t{\n\t\t\t\tpos++;\n\t\t\t\tint a = num();\n\t\t\t\ta--;\n\t\t\t\trep(i, n)rep(j, n) {\n\t\t\t\t\tif (prev[i][j].first == a) {\n\t\t\t\t\t\tprev[i][j].second = (prev[i][j].second + 1) % n;\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t}\n\t\t\tbreak;\n\t\t}\n\t}\n\treturn prev;\n}\nint main() {\n\tcin >> n >> l;\n\tcin >> s;\n\tinit.insert(init.end(), n, vector<pii>(n));\n\trep(i, n)rep(j, n)init[i][j] = pii(i,j);\n\tinit = f();\n\tvector<vi> a(n, vi(n));\n\trep(i, n)rep(j, n) {\n\t\ta[init[i][j].first][init[i][j].second] = i*n + j + 1;\n\t}\n\trep(i, n)rep(j, n) {\n\t\tcout << a[i][j] << (\" \\n\"[j == n - 1]);\n\t}\n\tcout << flush;\n}"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\n#define GET_MACRO(_1,_2,_3,_4,_5,NAME,...) NAME\n#define pr(...) GET_MACRO(__VA_ARGS__,pr5,pr4,pr3,pr2,pr1)(__VA_ARGS__)\n#define pr1(a) (#a)<<\"=\"<<(a)\n#define pr2(a,b) pr1(a)<<\", \"<<pr1(b)\n#define pr3(a,b,c) pr2(a,b)<<\", \"<<pr1(c)\n#define pr4(a,b,c,d) pr3(a,b,c)<<\", \"<<pr1(d)\n#define pr5(a,b,c,d,e) pr4(a,b,c,d)<<\", \"<<pr1(e)\n#define int long long\n#define double long double\nusing namespace std;\nconst int N = 100010;\nconst int INF = 1LL<<55;\nconst int mod = (1e9)+7;\nconst double EPS = 1e-8;\nconst double PI = 6.0 * asin(0.5);\ntypedef pair<int,int> P;\ntypedef long long ll;\ntemplate<class T> T Max(T &a,T b){return a=max(a,b);}\ntemplate<class T> T Min(T &a,T b){return a=min(a,b);}\n//ostream& operator<<(ostream& o,P p){return o<<\"(\"<<p.first<<\",\"<<p.second<<\")\";}\n//istream& operator>>(istream& i,P &p){return i>>p.first>>p.second;}\n//ostream& operator<<(ostream& o,vector<auto> &a){int i=0;for(auto t:a)o<<(i++?\" \":\"\")<<t;return o;}\n//istream& operator>>(istream& i,vector<auto> &a){for(auto &t:a)i>>t;return i;}\n//void prArr(auto a,string s=\" \"){int i=0;for(auto t:a)cout<<(i++?s:\"\")<<t;cout<<endl;}\n\ntypedef vector<int> vec;\ntypedef vector<vec> mat;\n\nmat move(mat a,mat b){\n  int n = a.size();\n  mat res(n,vec(n));\n\n  assert(a.size() == b.size());\n  assert(a[0].size() == b[0].size());\n  assert(a[0].size() == a.size());\n\n  for(int i=0;i<n;i++)\n    for(int j=0;j<n;j++) {\n      int y = a[i][j] / n;\n      int x = a[i][j] % n;\n      res[i][j] = b[y][x];\n    }\n  return res;\n}\n\nint n,len;\nint pos;\nstring str;\n\nmat bfs();\nmat repeat();\nint number();\n  \nmat repeat(){\n  assert(str[pos] == '(');\n  pos++;\n  mat x = bfs();\n  assert(str[pos]==')');\n  pos++;\n  int num = number();\n  \n  mat res(n,vec(n));\n  for(int i=0;i<n;i++)\n    for(int j=0;j<n;j++) res[i][j] = i * n + j;\n\n  while(num){\n    if(num%2) res = move(res,x);\n    x = move(x,x);\n    num = num/2;\n  }\n  return res;\n}\n\nint number(){\n  assert(isdigit(str[pos]));\n  int res = 0;\n  while(isdigit(str[pos])) res = res * 10 + str[pos] - '0', pos++;\n  return res;\n}\n\nvoid L(mat &A){\n  assert(str[pos++] == 'L');\n  int k = number() - 1;\n  for(int i=0;i<n-1;i++) swap(A[k][i],A[k][i+1]);\n}\n\nvoid R(mat &A){\n  assert(str[pos++] == 'R');\n  int k = number() - 1;\n  for(int i=0;i<n-1;i++) swap(A[k][n-1-i],A[k][n-2-i]);\n};\n\nmat U(mat &A){\n  assert(str[pos++] == 'U');\n  int k = number() - 1;\n  for(int i=0;i<n-1;i++) swap(A[i][k],A[i+1][k]);\n};\nmat D(mat &A){\n  assert(str[pos++] == 'D');\n  int k = number() - 1;\n  for(int i=0;i<n-1;i++) swap(A[n-1-i][k],A[n-2-i][k]);\n};\n\nmat bfs(){\n  mat res(n,vec(n));\n  for(int i=0;i<n;i++)\n    for(int j=0;j<n;j++) res[i][j] = i*n + j;\n  \n  while(pos < (int)str.size()){\n    char ch = str[pos];\n    if(ch == '(') res = repeat();\n    else if(ch == 'L') L(res);\n    else if(ch == 'R') R(res);\n    else if(ch == 'U') U(res);\n    else if(ch == 'D') D(res);\n    else break;\n  }\n  return res;\n}\n\nsigned main(){\n  int L;\n  cin>>n>>L;\n  cin>>str;\n  \n  mat ans = bfs();\n  for(int i=0;i<n;i++)\n    for(int j=0;j<n;j++) ans[i][j] ++;\n  for(int i=0;i<n;i++) cout<<ans[i]<<endl;\n  \n  return 0;\n}\n\n"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\nusing namespace std;\n\n#define rep(i,x,y) for(int i=(x);i<(y);++i)\n#define debug(x) #x << \"=\" << (x)\n\n#ifdef DEBUG\n#define _GLIBCXX_DEBUG\n#define print(x) std::cerr << debug(x) << \" (L:\" << __LINE__ << \")\" << std::endl\n#else\n#define print(x)\n#endif\n\nconst int inf=1e9;\nconst int64_t inf64=1e18;\nconst double eps=1e-9;\n\ntemplate <typename T> ostream &operator<<(ostream &os, const vector<T> &vec){\n    os << \"[\";\n    for (const auto &v : vec) {\n    \tos << v << \",\";\n    }\n    os << \"]\";\n    return os;\n}\n\ntypedef string::const_iterator state;\ntypedef vector<vector<int>> my_matrix;\nclass parse_error{};\nmy_matrix matrix;\nint n,l;\nstring s;\n\nvoid consume(state &begin,char expected){\n    if(*begin==expected) ++begin;\n    else{\n        cerr << \"Exptected '\" << expected << \"' but got '\" << *begin << \"'\" << endl;\n        cerr << \"Rest string is'\";\n        while(*begin) cerr << *begin++;\n        cerr << \"'\" << endl;\n        throw parse_error();\n    }\n}\n\nvoid sequence(state&);\nvoid repetition(state&);\nvoid operation(state&);\nint number(state&);\n\nvoid sequence(state &begin){\n    while(*begin){\n        if(*begin=='(') repetition(begin);\n        else if(*begin=='U' or *begin=='D' or *begin=='L' or *begin=='R') operation(begin);\n        else break;\n    }\n}\n\nvoid repetition(state &begin){\n    consume(begin,'(');\n    const auto backup1=begin;\n    int depth=1;\n    while(depth){\n        if(*begin=='(') ++depth;\n        if(*begin==')') --depth;\n        ++begin;\n    }\n    --begin;\n    consume(begin,')');\n    int num=number(begin);\n    const auto backup2=begin;\n\n    const auto prev_matrix=matrix;\n    rep(i,0,n) rep(j,0,n) matrix[i][j]=i*n+j;\n\n    begin=backup1;\n    sequence(begin);\n\n    vector<vector<int>> perm(n,vector<int>(n)),v(n,vector<int>(n));\n    rep(i,0,n) rep(j,0,n) perm[matrix[i][j]/n][matrix[i][j]%n]=v[i][j]=i*n+j;\n\n    while(num>0){\n        if(num&1) rep(i,0,n) rep(j,0,n) v[i][j]=perm[v[i][j]/n][v[i][j]%n];\n        const auto prev_perm=perm;\n        rep(i,0,n) rep(j,0,n) perm[i][j]=prev_perm[perm[i][j]/n][perm[i][j]%n];\n        num>>=1;\n    }\n    rep(i,0,n) rep(j,0,n) matrix[v[i][j]/n][v[i][j]%n]=prev_matrix[i][j];\n\n    begin=backup2;\n}\n\nvoid operation(state &begin){\n    char d=*begin;\n    ++begin;\n    int num=number(begin);\n    if(d=='L'){\n        rotate(matrix[num-1].begin(),matrix[num-1].begin()+1,matrix[num-1].end());\n        // int prev=matrix[num-1][0];\n        // rep(i,0,n-1) matrix[num-1][i]=matrix[num-1][i+1];\n        // matrix[num-1][n-1]=prev;\n    }\n    if(d=='R'){\n        rotate(matrix[num-1].rbegin(),matrix[num-1].rbegin()+1,matrix[num-1].rend());\n        // int prev=matrix[num-1][n-1];\n        // for(int i=n-1; i>=1; --i) matrix[num-1][i]=matrix[num-1][i-1];\n        // matrix[num-1][0]=prev;\n    }\n    if(d=='U'){\n        int prev=matrix[0][num-1];\n        rep(i,0,n-1) matrix[i][num-1]=matrix[i+1][num-1];\n        matrix[n-1][num-1]=prev;\n    }\n    if(d=='D'){\n        int prev=matrix[n-1][num-1];\n        for(int i=n-1; i>=1; --i) matrix[i][num-1]=matrix[i-1][num-1];\n        matrix[0][num-1]=prev;\n    }\n}\n\nint number(state &begin){\n    int res=0;\n    while(isdigit(*begin)){\n        res*=10;\n        res+=*begin-'0';\n        ++begin;\n    }\n    return res;\n}\n\nvoid solve(){\n    cin >> n >> l >> s;\n    matrix.resize(n);\n    rep(i,0,n){\n        matrix[i].resize(n);\n        rep(j,0,n) matrix[i][j]=i*n+j;\n    }\n    state begin=s.begin();\n    sequence(begin);\n    rep(i,0,n){\n        rep(j,0,n){\n            cout << matrix[i][j]+1;\n            if(j!=n-1) cout << \" \";\n        }\n        cout << endl;\n    }\n}\n\nint main(){\n    std::cin.tie(0);\n    std::ios::sync_with_stdio(false);\n    cout.setf(ios::fixed);\n    cout.precision(10);\n    solve();\n    return 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include<bits/stdc++.h>\nusing namespace std;\ntypedef vector<int> vi;\n\nint n,l;\nstring s;\nvi id;\n\nvi composition(vi a, vi b){\n  for(int i=0;i<n*n;i++){\n    b[i] = a[b[i]];\n  }\n  return b;\n}\n\nvi pow(vi a, int x){\n  vi res = id;\n  while(x){\n    if(x&1)res = composition(res,a);\n    a = composition(a,a);\n    x >>= 1;\n  }\n  return res;\n}\n\nint number(int &p){\n  int res = 0;\n  while(p<l && isdigit(s[p])){\n    res = res * 10 + (int)(s[p++]-'0');\n  }\n  return res;\n}\n\nvi operation(int &p){\n  if(s[p] == 'L'){\n    int i = number(++p) - 1;\n    vi res = id;\n    for(int k=0;k<n;k++)res[i*n+k] = i*n+(k+1)%n;\n    return res;\n  }\n  else if(s[p] == 'R'){\n    int i = number(++p) - 1;\n    vi res = id;\n    for(int k=0;k<n;k++)res[i*n+k] = i*n+(k+n-1)%n;\n    return res;\n  }\n  else if(s[p] == 'U'){\n    int j = number(++p) - 1;\n    vi res = id;\n    for(int k=0;k<n;k++)res[k*n+j] = (k+1)%n*n+j;\n    return res;\n  }\n  else if(s[p] == 'D'){\n    int j = number(++p) - 1;\n    vi res = id;\n    for(int k=0;k<n;k++)res[k*n+j] = (k+n-1)%n*n+j;\n    return res;\n  }\n  assert(true);\n}\n\nvi sequence(int &p){\n  if(p==l || s[p] == ')'){\n    return id;\n  }\n\n  vi a;\n  if(s[p] == '('){\n    vi t = sequence(++p);\n    int x = number(++p);\n    a = pow(t,x);\n  }else{\n    a = operation(p);\n  }\n  vi b = sequence(p);\n  \n  return composition(a,b);\n}\n\nint main(){\n  cin >> n >> l >> s;\n  \n  id.resize(n*n);\n  for(int i=0;i<n*n;i++)id[i] = i;\n\n  int p = 0;\n  vi ans = sequence(p);\n  \n  for(int i=0;i<n;i++){\n    for(int j=0;j<n;j++) cout << ans[i*n+j] + 1 << \" \\n\"[j==n-1];\n  }\n}"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\nusing namespace std;\n\nint N, L;\nint idx = 0;\nstring s;\n\nclass Mat {\npublic:\n    vector<vector<int>> m;\n    Mat(){}\n    Mat(vector<vector<int>> m_):m(m_){}\n\n    void output() {\n        for (int i = 0; i < N; i++) {\n            for (int j = 0; j < N; j++){\n                if (j) cout << \" \";\n                cout << m[i][j] + 1;\n            }\n            cout << endl;\n        }\n    }\n};\n\nMat init_state;\nMat move(const Mat &s, const Mat &t) {\n    vector<vector<int>> ret(N, vector<int>(N));\n    for (int i = 0; i < N; i++) {\n        for (int j = 0; j < N; j++) {\n            int ny = t.m[i][j] / N, nx = t.m[i][j] % N;\n            ret[i][j] = s.m[ny][nx];\n        }\n    }\n    return Mat(ret);\n}\n\nMat pow(const Mat &m, int x) {\n    Mat ret = init_state, tmp = m;\n    while (x) {\n        if (x & 1) ret = move(ret, tmp);\n        tmp = move(tmp, tmp);\n        x = x >> 1;\n    }\n    return ret;\n}\n\nMat seq();\nMat rep();\n\nint number() {\n    int ret = 0;\n    while (isdigit(s[idx])) {\n        ret = 10 * ret + (s[idx] - '0');\n        idx++;\n    }\n    return ret;\n}\n\nMat ope() {\n    char shift = s[idx++];\n    int num = number();\n    num--;\n\n    auto op_mat = init_state.m;\n    if (shift == 'L') {\n        for (int i = 0; i < N; i++)\n            op_mat[num][i] = init_state.m[num][i < N-1 ? i + 1 : 0];\n    } else if (shift == 'R') {\n        for (int i = 0; i < N; i++)\n            op_mat[num][i] = init_state.m[num][i ? i - 1 : N - 1];\n    } else if (shift == 'U') {\n        for (int i = 0; i < N; i++)\n            op_mat[i][num] = init_state.m[i < N - 1 ? i + 1 : 0][num];\n    } else { // shift == 'D'\n        for (int i = 0; i < N; i++)\n            op_mat[i][num] = init_state.m[i ? i - 1 : N - 1][num];\n    }\n\n    return Mat(op_mat);\n}\n\nMat rep() {\n    idx++; // skip '('\n    Mat ret = seq();\n    idx++;\n    int num = number();\n    ret = pow(ret, num);\n    return ret;\n}\n\nMat seq() {\n    Mat ret = init_state;\n    while (s[idx] == '(' || \"LRUD\"s.find(s[idx]) != string::npos) {\n        Mat right;\n        if (s[idx] == '(')\n            right = rep();\n        else\n            right = ope();\n        ret = move(ret, right);\n    }\n    return ret;\n}\n\nint main() {\n    idx = 0;\n    cin >> N >> L >> s;\n\n    vector<vector<int>> init(N, vector<int>(N));\n    for (int i = 0; i < N; i++)\n        for (int j = 0; j < N; j++)\n            init[i][j] = i * N + j;\n    init_state = Mat(init);\n\n    seq().output();\n}\n\n"
  },
  {
    "language": "C++",
    "code": "#include<iostream>\n#include<cstdio>\n#include<vector>\n#include<string>\n#include<cstring>\n#include<functional>\n#include<stack>\n#include<queue>\n#include <iomanip>\n#include<map>\n#include<limits>\n#include<cmath>\n#include<algorithm>\n#include<bitset>\n#include<utility>\n#include<complex>\n#include<cstdlib>\n#include<set>\n#include<cctype>\n\n#define DBG cerr << '!' << endl;\n#define REP(i,n) for(int (i) = (0);(i) < (n);++i)\n#define rep(i,s,g) for(int (i) = (s);(i) < (g);++i)\n#define rrep(i,s,g) for(int (i) = (s);i >= (g);--(i))\n#define PB push_back\n#define MP make_pair\n#define FI first\n#define SE second\n#define SHOW1d(v,n) {for(int W = 0;W < (n);W++)cerr << v[W] << ' ';cerr << endl << endl;}\n#define SHOW2d(v,i,j) {for(int aaa = 0;aaa < i;aaa++){for(int bbb = 0;bbb < j;bbb++)cerr << v[aaa][bbb] << ' ';cerr << endl;}cerr << endl;}\n#define ALL(v) v.begin(),v.end()\n#define Decimal fixed<<setprecision(10)\n\nusing namespace std;\n\ntypedef long long ll;\ntypedef vector<int> iv;\ntypedef vector<iv> iiv;\ntypedef vector<string> sv;\n\ntypedef vector<vector<pair<int,int> > >  Mat;\n\nstring str;\nint n,pointer;\n\nMat calMat(Mat a,Mat b);\nMat readSequence();\nint readNum();\nMat init();\n\nint ans[101][101];\n\nMat init()\n{\n\tMat ret;\n\tREP(i,n)\n\t{\n\t\tvector<pair<int,int> > tmp;\n\t\tREP(j,n)\n\t\t{\n\t\t\ttmp.PB(MP(i,j));\n\t\t}\n\t\tret.PB(tmp);\n\t}\n\treturn ret;\n}\n\nint readNum()\n{\n\tint ret = 0;\n\twhile(isdigit(str[pointer]))\n\t{\n\t\tret *= 10;\n\t\tret += str[pointer] - '0';\n\t\tpointer++;\n\t}\n\treturn ret;\n}\n\nMat makeShift(char c,int q)\n{\n\tMat ret = init();\n\tq--;\n\tpair<int,int> tmp;\n\tif(c == 'U')\n\t{\n\t\ttmp = ret[n-1][q];\n\t\tfor(int i = n-1;i > 0;i--)ret[i][q] = ret[i-1][q];\n\t\tret[0][q] = tmp;\n\t}\n\telse if(c == 'D')\n\t{\n\t\ttmp = ret[0][q];\n\t\tfor(int i = 0;i < n-1;i++)ret[i][q] = ret[i+1][q];\n\t\tret[n-1][q] = tmp;\n\t}\n\telse if(c == 'R')\n\t{\n\t\ttmp = ret[q][0];\n\t\tfor(int i = 0;i < n-1;i++)ret[q][i] = ret[q][i+1];\n\t\tret[q][n-1] = tmp;\n\t}\n\telse\n\t{\n\t\ttmp = ret[q][n-1];\n\t\tfor(int i = n-1;i > 0;i--)ret[q][i] = ret[q][i-1];\n\t\tret[q][0] = tmp;\n\t}\n\treturn ret;\n}\n\nMat power(Mat m,int n)\n{\n\tMat tmp = m;\n\tMat ret = init();\n\twhile(n)\n\t{\n\t\tif(n & 1)\n\t\t{\n\t\t\tret = calMat(ret,tmp);\n\t\t}\n\t\ttmp = calMat(tmp,tmp);\n\t\tn >>= 1;\n\t}\n\treturn ret;\n}\n\nMat readSequence()\n{\n\tMat ret = init();\n\t\n\twhile(pointer < str.size())\n\t{\n\t\tif(str[pointer] == '(')\n\t\t{\n\t\t\tpointer++;\n\t\t\tret = calMat(ret,readSequence());\n\t\t}\n\t\telse if(str[pointer] == ')')\n\t\t{\n\t\t\tpointer++;\n\t\t\tint num = readNum();\n\t\t\tret = power(ret,num);\n\t\t\treturn ret;\n\t\t}\n\t\telse\n\t\t{\n\t\t\tchar c = str[pointer];\n\t\t\tpointer++;\n\t\t\tint num = readNum();\n\t\t\tMat mat = makeShift(c,num);\n\t\t\tret = calMat(ret,mat);\n\t\t}\n\t}\n\treturn ret;\n}\n\nMat calMat(Mat a,Mat b)\n{\n\tMat ret = a;\n\tREP(i,n)\n\t{\n\t\tREP(j,n)\n\t\t{\n\t\t\tret[i][j] = b[a[i][j].FI][a[i][j].SE];\n\t\t}\n\t}\n\treturn ret;\n}\n\n\nint main()\n{\n\tint l;\n\tcin >> n >> l;\n\tcin >> str;\n\t\n\tMat mat = readSequence();\n\tint num = 1;\n\tREP(i,n)\n\t{\n\t\tREP(j,n)\n\t\t{\n\t\t\tans[mat[i][j].FI][mat[i][j].SE] = num;\n\t\t\tnum++;\n\t\t}\n\t}\n\t\n\tREP(i,n)\n\t{\n\t\tREP(j,n-1)\n\t\t{\n\t\t\tcout << ans[i][j] << ' ';\n\t\t}\n\t\tcout << ans[i][n-1] << endl;\n\t}\n\t\n\treturn 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\n \n#define _overload(_1,_2,_3,name,...) name\n#define _rep(i,n) _range(i,0,n)\n#define _range(i,a,b) for(int i=(int)(a);i<(int)(b);++i)\n#define rep(...) _overload(__VA_ARGS__,_range,_rep,)(__VA_ARGS__)\n \n#define _rrep(i,n) _rrange(i,n,0)\n#define _rrange(i,a,b) for(int i=(int)(a)-1;i>=(int)(b);--i)\n#define rrep(...) _overload(__VA_ARGS__,_rrange,_rrep,)(__VA_ARGS__)\n \n#define _all(arg) begin(arg),end(arg)\n#define uniq(arg) sort(_all(arg)),(arg).erase(unique(_all(arg)),end(arg))\n#define getidx(ary,key) lower_bound(_all(ary),key)-begin(ary)\n#define clr(a,b) memset((a),(b),sizeof(a))\n#define bit(n) (1LL<<(n))\n \n// #define DEBUG\n \n#ifdef DEBUG\n    #define dump(...) fprintf(stderr, __VA_ARGS__)\n#else\n    #define dump(...)\n#endif\n \ntemplate<class T>bool chmax(T &a, const T &b) { return (a<b)?(a=b,1):0;}\ntemplate<class T>bool chmin(T &a, const T &b) { return (b<a)?(a=b,1):0;}\n \nusing namespace std;\nusing ll=long long;\nusing vi=vector<int>;\nusing vll=vector<ll>;\n \nconst double EPS = 1e-10;\nconst double PI = acos(-1.0);\nconst ll inf =1LL << 62;\nconst ll mod=1000000007LL;\nconst int dx[4]={1,0,-1,0};\nconst int dy[4]={0,1,0,-1};\n \n \nll extgcd(ll a,ll b,ll& x,ll& y){x=1,y=0;ll g=a;if(b!=0) g=extgcd(b,a%b,y,x),y-=a/b*x;return g;}\nll ADD(const ll &a, const ll &b,const ll &mod) { return (a+b)%mod;}\nll SUB(const ll &a, const ll &b,const ll &mod) { return (a-b+mod)%mod;}\nll MUL(const ll &a, const ll &b,const ll &mod) { return (1LL*a*b)%mod;}\nll DIV(const ll &a, const ll &b,const ll &mod) {ll x,y; extgcd(b,mod,x,y);return MUL(a,(x+mod)%mod,mod);}\n \nrandom_device rd;\nmt19937 mt(rd());\nuniform_int_distribution<int> dice(1,6);\nuniform_real_distribution<double> score(0.0,10.0);\n\nint n;\nint len;\nint idx;\nstring in;\n\nvoid Print(vi& tbl){\n    rep(i, n){\n        rep(j, n){\n            cerr << tbl[i * n + j] << \" \";\n        }\n        cerr << endl;\n    }\n    cerr << \"-----\" << endl;\n}\n\nvoid calc(vi& tbl, vi& dst){\n    vi ndst = dst;\n    rep(i, n * n){\n        ndst[i] = dst[tbl[i]];\n    }\n    dst = ndst;\n}\n\nvoid power(vi& tbl, int m, vi& dst){\n    vi cur = tbl;\n    while(m >= 1){\n        if(m % 2 == 1){\n            calc(cur, dst);\n        }\n        calc(cur, cur);\n        m /= 2;\n    }\n}\n\nvoid operate(char op, int k, vi& dst){\n    k--;\n    vi tbl(n * n);\n    rep(i, n * n) tbl[i] = i;\n\n    int tmp;\n    switch(op){\n        case 'L': \n            tmp = tbl[k * n];\n            rep(i, n - 1){\n                tbl[k * n + i] = tbl[k * n + i + 1];\n            }\n            tbl[(k + 1) * n - 1] = tmp;\n            break;\n        case 'R': \n            tmp = tbl[(k + 1) * n - 1];\n            rrep(i, n, 1){\n                tbl[k * n + i] = tbl[k * n + i - 1];\n            }\n            tbl[k * n] = tmp;\n            break;\n        case 'U':\n            tmp = tbl[k];\n            rep(i, n - 1){\n                tbl[n * i + k] = tbl[n * (i + 1) + k];\n            }\n            tbl[n * (n - 1) + k] = tmp;\n            break;\n        case 'D':\n            tmp = tbl[n * (n - 1) + k];\n            rrep(i, n, 1){\n                tbl[n * i + k] = tbl[n * (i - 1) + k];\n            }\n            tbl[k] = tmp;\n            break;\n        default:\n            assert(false);\n            break;\n    }\n\n    power(tbl, 1, dst);\n}\n\nvi parse(){\n    vi ret(n * n);\n    rep(i, n * n) ret[i] = i;\n\n    while(idx < len){\n        if(in[idx] == ')'){\n            break;\n        }\n        else if(in[idx] == '('){\n            assert(in[idx++] == '(');\n            vi tbl = parse();\n            assert(in[idx++] == ')');\n\n            int times = 0;\n            while(isdigit(in[idx])){\n                times = 10 * times + (int)(in[idx] - '0');\n                idx++;\n            }\n            power(tbl, times, ret);\n        }\n        else {\n            char op = in[idx]; idx++;\n            int  k  = 0;\n            while(isdigit(in[idx])){\n                k = 10 * k + (int)(in[idx] - '0');\n                idx++;\n            }\n            operate(op, k, ret);\n        }\n    }\n\n    return ret;\n}\n\nint main(void){\n    cin.tie(0);\n    ios::sync_with_stdio(false);\n\n    cin >> n >> len;\n    cin >> in;\n    if(in[0] != '(') in = \"(\" + in + \")1\";\n\n    auto tbl = parse();\n\n    vi res(n * n);\n    rep(i, n * n){\n        res[i] = i + 1;\n    }\n    calc(tbl, res);\n\n    rep(i, n){\n        rep(j, n){\n            cout << (j ? \" \":\"\") << res[i * n + j];\n        }\n        cout << endl;\n    }\n\n    return 0;\n}"
  },
  {
    "language": "C++",
    "code": "// g++ -std=c++11 a.cpp\n#include<iostream>\n#include<vector>\n#include<string>\n#include<algorithm>   \n#include<map>\n#include<set>\n#include<unordered_map>\n#include<utility>\n#include<cmath>\n#include<random>\n#include<cstring>\n#include<queue>\n#include<stack>\n#include<bitset>\n#include<cstdio>\n#include<sstream>\n#include<iomanip>\n#include<assert.h>\n#include<typeinfo>\n#define loop(i,a,b) for(ll i=a;i<b;i++) \n#define rep(i,a) loop(i,0,a)\n#define FOR(i,a) for(auto i:a)\n#define pb push_back\n#define all(in) in.begin(),in.end()\n#define shosu(x) fixed<<setprecision(x)\nusing namespace std;\n//kaewasuretyuui\ntypedef long long ll;\n//#define int ll\ntypedef int Def;\ntypedef pair<Def,Def> pii;\ntypedef vector<Def> vi;\ntypedef vector<vi> vvi;\ntypedef vector<pii> vp;\ntypedef vector<vp> vvp;\ntypedef vector<string> vs;\ntypedef vector<double> vd;\ntypedef vector<vd> vvd;\ntypedef pair<Def,pii> pip;\ntypedef vector<pip>vip;\n#define mt make_tuple\ntypedef tuple<int,int,int,int> tp;\ntypedef vector<tp> vt;\ntemplate<typename A,typename B>bool cmin(A &a,const B &b){return a>b?(a=b,true):false;}\ntemplate<typename A,typename B>bool cmax(A &a,const B &b){return a<b?(a=b,true):false;}\n//template<class C>constexpr int size(const C &c){return (int)c.size();}\n//template<class T,size_t N> constexpr int size(const T (&xs)[N])noexcept{return (int)N;}\nconst double PI=acos(-1);\nconst double EPS=1e-9;\nDef inf = sizeof(Def) == sizeof(long long) ? 2e18 : 1e9+10;\nint dx[]={0,1,0,-1};\nint dy[]={1,0,-1,0};\nint n,l,t=0;\nstring s;\nint number(){\n\tint q=0;\n\twhile(t<s.size()&&isdigit(s[t])){\n\t\tq*=10;\n\t\tq+=s[t]-'0';\n\t\tt++;\n\t}\n\treturn q;\n}\nvvi f(){\n\tvvi w(n,vi(n));\n\trep(i,n)rep(j,n)w[i][j]=i*n+j;\n\twhile(t<s.size()){\n\t\tif(s[t]=='('){\n\t\t\tt++;\n\t\t\tvvi ne=f();\n\t\t\tt++;\n\t\t\tint co=number();\n\t\t\twhile(co){\n\t\t\t\tif(co%2){\n\t\t\t\t\tvvi NE(n,vi(n));\n\t\t\t\t\trep(i,n)rep(j,n)NE[i][j]=w[ne[i][j]/n][ne[i][j]%n];\n\t\t\t\t\tw=NE;\n\t\t\t\t}\n\t\t\t\tvvi NE(n,vi(n));\n\t\t\t\trep(i,n)rep(j,n)NE[i][j]=ne[ne[i][j]/n][ne[i][j]%n];\n\t\t\t\tne=NE;\n\t\t\t\tco/=2;\n\t\t\t}\n\t\t}else if(s[t]==')')break;\n\t\telse{\n\t\t\tchar c=s[t];\n\t\t\tt++;\n\t\t\tint co=number()-1;\n\t\t\tint tmp;\n\t\t\tif(c=='U'){\n\t\t\t\ttmp=w[0][co];\n\t\t\t\trep(i,n-1)w[i][co]=w[i+1][co];\n\t\t\t\tw[n-1][co]=tmp;\n\t\t\t}\n\t\t\tif(c=='D'){\n\t\t\t\ttmp=w[n-1][co];\n\t\t\t\trep(i,n-1)w[n-1-i][co]=w[n-2-i][co];\n\t\t\t\tw[0][co]=tmp;\n\t\t\t}\n\t\t\tif(c=='L'){\n\t\t\t\ttmp=w[co][0];\n\t\t\t\trep(i,n-1)w[co][i]=w[co][i+1];\n\t\t\t\tw[co][n-1]=tmp;\n\t\t\t}\n\t\t\tif(c=='R'){\n\t\t\t\ttmp=w[co][n-1];\n\t\t\t\trep(i,n-1)w[co][n-1-i]=w[co][n-2-i];\n\t\t\t\tw[co][0]=tmp;\n\t\t\t}\n\t\t}\n\t}\n\treturn w;\n}\nint main(){\n\tcin>>n>>l>>s;\n\tt=0;\n\tvvi out=f();\n\trep(i,n)rep(j,n)cout<<out[i][j]+1<<\" \\n\"[j==n-1];\n}\n\n\n\n\n\n\n\n\n\n"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\nusing namespace std;\n\n#define rep(i,x,y) for(int i=(x);i<(y);++i)\n#define debug(x) #x << \"=\" << (x)\n\n#ifdef DEBUG\n#define _GLIBCXX_DEBUG\n#define print(x) std::cerr << debug(x) << \" (L:\" << __LINE__ << \")\" << std::endl\n#else\n#define print(x)\n#endif\n\nconst int inf=1e9;\nconst int64_t inf64=1e18;\nconst double eps=1e-9;\n\ntemplate <typename T> ostream &operator<<(ostream &os, const vector<T> &vec){\n    os << \"[\";\n    for (const auto &v : vec) {\n    \tos << v << \",\";\n    }\n    os << \"]\";\n    return os;\n}\n\ntypedef string::const_iterator state;\ntypedef vector<vector<int>> my_matrix;\nclass parse_error{};\nmy_matrix matrix;\nint n,l;\nstring s;\n\nvoid consume(state &begin,char expected){\n    if(*begin==expected) ++begin;\n    else{\n        cerr << \"Exptected '\" << expected << \"' but got '\" << *begin << \"'\" << endl;\n        cerr << \"Rest string is'\";\n        while(*begin) cerr << *begin++;\n        cerr << \"'\" << endl;\n        throw parse_error();\n    }\n}\n\nvoid sequence(state&);\nvoid repetition(state&);\nvoid operation(state&);\nint number(state&);\nvector<int> memo(1000,-1);\n\nvoid sequence(state &begin){\n    while(*begin){\n        if(*begin=='(') repetition(begin);\n        else if(*begin=='U' or *begin=='D' or *begin=='L' or *begin=='R') operation(begin);\n        else break;\n    }\n}\n\nvoid repetition(state &begin){\n    int idx=begin-s.begin();\n    consume(begin,'(');\n    auto backup1=begin;\n    int depth=1;\n    while(depth){\n        if(*begin=='(') ++depth;\n        if(*begin==')') --depth;\n        ++begin;\n    }\n    --begin;\n    consume(begin,')');\n    int num=number(begin);\n    if(memo[idx]!=-1) num=memo[idx];\n    auto backup2=begin;\n    bool f=false;\n    auto initial_state=matrix;\n    int count=0;\n    rep(i,0,num){\n        begin=backup1;\n        sequence(begin);\n        if(memo[idx]==-1 and !f){\n            ++count;\n            if(matrix==initial_state){\n                num%=count;\n                i=-1;\n                matrix=initial_state;\n                memo[idx]=num;\n                f=true;\n            }\n        }\n    }\n    begin=backup2;\n}\n\nvoid operation(state &begin){\n    char d=*begin;\n    ++begin;\n    int num=number(begin);\n    if(d=='L') rotate(matrix[num-1].begin(),matrix[num-1].begin()+1,matrix[num-1].end());\n    if(d=='R') rotate(matrix[num-1].rbegin(),matrix[num-1].rbegin()+1,matrix[num-1].rend());\n    if(d=='U'){\n        vector<int> v;\n        rep(i,0,n) v.push_back(matrix[i][num-1]);\n        rotate(v.begin(),v.begin()+1,v.end());\n        rep(i,0,n) matrix[i][num-1]=v[i];\n    }\n    if(d=='D'){\n        vector<int> v;\n        rep(i,0,n) v.push_back(matrix[i][num-1]);\n        rotate(v.rbegin(),v.rbegin()+1,v.rend());\n        rep(i,0,n) matrix[i][num-1]=v[i];\n    }\n}\n\nint number(state &begin){\n    int res=0;\n    while(isdigit(*begin)){\n        res*=10;\n        res+=*begin-'0';\n        ++begin;\n    }\n    return res;\n}\n\nvoid solve(){\n    cin >> n >> l >> s;\n    matrix.resize(n);\n    rep(i,0,n){\n        matrix[i].resize(n);\n        rep(j,0,n) matrix[i][j]=i*n+j;\n    }\n    state begin=s.begin();\n    sequence(begin);\n    rep(i,0,n){\n        rep(j,0,n){\n            cout << matrix[i][j]+1;\n            if(j!=n-1) cout << \" \";\n        }\n        cout << endl;\n    }\n}\n\nint main(){\n    std::cin.tie(0);\n    std::ios::sync_with_stdio(false);\n    cout.setf(ios::fixed);\n    cout.precision(10);\n    solve();\n    return 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include <iostream>\n#include <vector>\n#include <algorithm>\n#include <utility>\nusing namespace std;\ntypedef pair<int, int> pii;\nvector<vector<pii>> unit;\n\nint getint(int &p, string s){\n    int res=0;\n    while(p<(int)s.length() && '0'<=s[p] && s[p]<='9'){\n        res *= 10;\n        res += s[p]-'0';\n        p++;\n    }\n    return res;\n}\nvector<vector<pii>> compose(vector<vector<pii>> &a, vector<vector<pii>> &b){\n    int n = a.size();\n    vector<vector<pii>> res(n, vector<pii>(n));\n    for(int i=0; i<n; i++){\n        for(int j=0; j<n; j++){\n            res[i][j] = b[a[i][j].first][a[i][j].second];\n        }\n    }\n    return res;\n}\nvector<vector<pii>> shiftmap(int &p, string s){\n    auto res = unit;\n    int n = unit.size();\n    while(p<(int)s.length() && s[p]!=')'){\n        vector<vector<pii>> ch = unit;\n        if(s[p] == '('){\n            ch = shiftmap(++p, s);\n            int rep = getint(++p, s);\n            auto curr = unit;\n            for(int i=31; i>=0; i--){\n                curr = compose(curr, curr);\n                if(rep>>i&1){\n                    curr = compose(curr, ch);\n                }\n            }\n            ch = curr;\n        }else if(s[p] == 'L'){\n            int i = getint(++p, s) - 1;\n            for(int j=0; j<n; j++){\n                ch[i][j] = pii(i, (j+n-1)%n);\n            }\n        }else if(s[p] == 'R'){\n            int i = getint(++p, s) - 1;\n            for(int j=0; j<n; j++){\n                ch[i][j] = pii(i, (j+1)%n);\n            }\n        }else if(s[p] == 'U'){\n            int j = getint(++p, s) - 1;\n            for(int i=0; i<n; i++){\n                ch[i][j] = pii((i+n-1)%n, j);\n            }\n        }else if(s[p] == 'D'){\n            int j = getint(++p, s) - 1;\n            for(int i=0; i<n; i++){\n                ch[i][j] = pii((i+1)%n, j);\n            }\n        }\n        res = compose(res, ch);\n    }\n    return res;\n}\n\nint main(){\n    int n,l;\n    string s;\n    cin >> n >> l >> s;\n    unit = vector<vector<pii>>(n);\n    for(int i=0; i<n; i++){\n        for(int j=0; j<n; j++){\n            unit[i].emplace_back(i, j);\n        }\n    }\n    int p=0;\n    auto shift = shiftmap(p, s);\n    vector<vector<int>> ans(n,vector<int>(n));\n    for(int i=0; i<n; i++){\n        for(int j=0; j<n; j++){\n            ans[shift[i][j].first][shift[i][j].second] = i*n +j +1;\n        }\n    }\n    for(int i=0; i<n; i++){\n        for(int j=0; j<n-1; j++){\n            cout << ans[i][j] << \" \";\n        }\n        cout << ans[i][n-1] << endl;\n    }\n    return 0;\n}\n\n"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\nusing namespace std;\n\nvector<int> change(const vector<int>& a, const vector<int>& b) {\n\tint n = a.size();\n\tvector<int> res(n);\n\tfor (int i = 0; i < n; i++) {\n\t\tres[i] = a[b[i]];\n\t}\n\treturn res;\n}\n\nvector<int> Pow(vector<int> a, int x) {\n\tint n = a.size();\n\tvector<int> res(n);\n\tfor (int i = 0; i < n; i++) {\n\t\tres[i] = i;\n\t}\n\twhile (x) {\n\t\tif (x & 1) {\n\t\t\tres = change(res, a);\n\t\t}\n\t\ta = change(a, a);\n\t\tx >>= 1;\n\t}\n\treturn res;\n}\n\nint it, len;\nint N, L;\nstring S;\n\nvector<int> sequence();\nvector<int> repetition();\nvector<int> operation();\nint number();\n\nvector<int> sequence() {\n\tvector<int> res(N * N);\n\tfor (int i = 0; i < N * N; i++) {\n\t\tres[i] = i;\n\t}\n\twhile (it < len && S[it] != ')') {\n\t\tif (S[it] == '(') {\n\t\t\tres = change(res, repetition());\n\t\t}\n\t\telse {\n\t\t\tres = change(res, operation());\n\t\t}\n\t}\n\treturn res;\n}\n\nvector<int> repetition() {\n\tassert(S[it++] == '(');\n\tauto res = sequence();\n\tassert(S[it++] == ')');\n\treturn Pow(res, number());\n}\n\nvector<int> operation() {\n\tvector<int> res(N * N);\n\tfor (int i = 0; i < N * N; i++) {\n\t\tres[i] = i;\n\t}\n\tauto tmp = res;\n\tchar c = S[it++];\n\tint cnt = number() - 1;\n\tswitch (c) {\n\tcase 'L':\n\t\tfor (int i = 0; i < N; i++) {\n\t\t\tres[cnt * N + i] = tmp[cnt * N + (i + 1) % N];\n\t\t}\n\t\tbreak;\n\tcase 'R':\n\t\tfor (int i = 0; i < N; i++) {\n\t\t\tres[cnt * N + i] = tmp[cnt * N + (i + N - 1) % N];\n\t\t}\n\t\tbreak;\n\tcase 'U':\n\t\tfor (int i = 0; i < N; i++) {\n\t\t\tres[i * N + cnt] = tmp[(i + 1) % N * N + cnt];\n\t\t}\n\t\tbreak;\n\tcase 'D':\n\t\tfor (int i = 0; i < N; i++) {\n\t\t\tres[i * N + cnt] = tmp[(i + N - 1) % N * N + cnt];\n\t\t}\n\t\tbreak;\n\t}\n\treturn res;\n}\n\nint number() {\n\tint res = 0;\n\twhile (it < len && isdigit(S[it])) {\n\t\tres = res * 10 + S[it++] - '0';\n\t}\n\treturn res;\n}\n\nint main()\n{\n\tcin >> N >> L >> S;\n\tlen = S.size();\n\tvector<int> tmp = sequence();\n\tvector<int> res(N * N);\n\tfor (int i = 0; i < N * N; i++) {\n\t\tres[i] = i + 1;\n\t}\n\tres = change(res, tmp);\n\tfor (int i = 0; i < N * N; i++) {\n\t\tcout << res[i] << \" \\n\"[(i + 1) % N == 0];\n\t}\n\treturn 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include<iostream>\n#include<string>\n#include<cstdio>\n#include<vector>\n#include<cmath>\n#include<algorithm>\n#include<functional>\n#include<iomanip>\n#include<queue>\n#include<ciso646>\n#include<random>\n#include<map>\n#include<set>\n#include<complex>\n#include<bitset>\n#include<stack>\n#include<unordered_map>\n#include<utility>\nusing namespace std;\ntypedef long long ll;\ntypedef unsigned long long ul;\ntypedef unsigned int ui;\nconst ll mod = 1000000007;\ntypedef double ld;\ntypedef complex<ld> Point;\nconst ll INF = mod * mod;\ntypedef pair<int, int> P;\n#define stop char nyaa;cin>>nyaa;\n#define rep(i,n) for(int i=0;i<n;i++)\n#define per(i,n) for(int i=n-1;i>=0;i--)\n#define Rep(i,sta,n) for(int i=sta;i<n;i++)\n#define rep1(i,n) for(int i=1;i<=n;i++)\n#define per1(i,n) for(int i=n;i>=1;i--)\n#define Rep1(i,sta,n) for(int i=sta;i<=n;i++)\nconst ld eps = 1e-8;\nconst ld pi = acos(-1.0);\ntypedef pair<ld, ld> LDP;\ntypedef pair<ll, ll> LP;\n#define fr first\n#define sc second\n\ntypedef vector<int> vec;\ntypedef vector<vec> mat;\nint n, l;\nstring s;\nbool is_num(char t) {\n\tif ('0' <= t && t <= '9')return true;\n\treturn false;\n}\nbool is_alf(char t) {\n\tif ('A' <= t && t <= 'Z')return true;\n\treturn false;\n}\n\nint nex[100][100];\nvoid mtmul(mat &A, mat &B) {\n\trep(i, n) {\n\t\trep(j, n) {\n\t\t\tint z = B[i][j];\n\t\t\tint x = z / n, y = z % n;\n\t\t\tnex[i][j] = A[x][y];\n\t\t}\n\t}\n\trep(i, n) {\n\t\trep(j, n) {\n\t\t\tA[i][j] = nex[i][j];\n\t\t}\n\t}\n}\nvoid repet(mat &A,int k) {\n\tmat ret(n);\n\trep(i, n) {\n\t\tret[i].resize(n);\n\t\trep(j, n) {\n\t\t\tret[i][j] = i * n + j;\n\t\t}\n\t}\n\twhile (k) {\n\t\tif (k % 2) {\n\t\t\tmtmul(ret, A);\n\t\t}\n\t\tk >>= 1;\n\t\tmtmul(A, A);\n\t}\n\tA = ret;\n}\nvoid solve() {\n\tcin >> n >> l;\n\tcin >> s;\n\tmat E(n);\n\trep(i, n) {\n\t\tE[i].resize(n);\n\t\trep(j, n) {\n\t\t\tE[i][j] = i * n + j;\n\t\t}\n\t}\n\tstack<mat> st;\n\tmat cur = E;\n\trep(i, l) {\n\t\tif (s[i] == '(') {\n\t\t\tst.push(cur); cur = E;\n\t\t}\n\t\telse if (is_alf(s[i])) {\n\t\t\tchar memo = s[i];\n\t\t\ti++;\n\t\t\tint le = i;\n\t\t\twhile (i + 1 < l&&is_num(s[i + 1]))i++;\n\t\t\tstring t = s.substr(le, i - le + 1);\n\t\t\tint z = stoi(t) - 1;\n\t\t\tif (memo == 'L') {\n\t\t\t\tint u = cur[z][0];\n\t\t\t\trep(j, n-1) {\n\t\t\t\t\tcur[z][j] = cur[z][j + 1];\n\t\t\t\t}\n\t\t\t\tcur[z][n - 1] = u;\n\t\t\t}\n\t\t\telse if (memo == 'R') {\n\t\t\t\tint u = cur[z][n - 1];\n\t\t\t\tfor (int j = n - 1; j > 0; j--) {\n\t\t\t\t\tcur[z][j] = cur[z][j - 1];\n\t\t\t\t}\n\t\t\t\tcur[z][0] = u;\n\t\t\t}\n\t\t\telse if (memo == 'U') {\n\t\t\t\tint u = cur[0][z];\n\t\t\t\trep(j, n - 1) {\n\t\t\t\t\tcur[j][z] = cur[j + 1][z];\n\t\t\t\t}\n\t\t\t\tcur[n - 1][z] = u;\n\t\t\t}\n\t\t\telse {\n\t\t\t\tint u = cur[n - 1][z];\n\t\t\t\tfor (int j = n - 1; j > 0; j--) {\n\t\t\t\t\tcur[j][z] = cur[j - 1][z];\n\t\t\t\t}\n\t\t\t\tcur[0][z] = u;\n\t\t\t}\n\t\t}\n\t\telse if (s[i] == ')') {\n\t\t\ti++;\n\t\t\tint le = i;\n\t\t\twhile (i + 1 < l&&is_num(s[i + 1]))i++;\n\t\t\tstring t = s.substr(le, i - le + 1);\n\t\t\tint z = stoi(t);\n\t\t\trepet(cur,z);\n\t\t\tmat m = st.top(); st.pop();\n\t\t\tmtmul(m, cur);\n\t\t\tcur = m;\n\t\t}\n\t}\n\trep(i, n) {\n\t\trep(j, n) {\n\t\t\tif (j > 0)cout << \" \";\n\t\t\tcout << cur[i][j] + 1;\n\t\t}\n\t\tcout << endl;\n\t}\n}\nint main() {\n\tios::sync_with_stdio(false);\n\tcin.tie(0);\n\tsolve();\n\t//stop\n\treturn 0;\n}\n\n"
  },
  {
    "language": "C",
    "code": "// AOJ 2731 Shifting a Matrix\n// 2018.2.11 bal4u\n\n#include <stdio.h>\n#include <ctype.h>\n\n#define SIZE 20\n\nint N;\ntypedef struct { short r, c; } T;\nT tbl[20][1002][1002];\nchar s[1002];\nchar used[20];\n\nchar *seq(int res, char *s);\n\nint new() {\tint i;\n\tfor (i = 0; i < SIZE; i++) if (!used[i]) { used[i] = 1; break; } return i;\n}\n\nvoid dis(int k) { used[k] = 0; }\n\nchar *in(int *res, char *p) { int n = 0;\n\twhile (isdigit(*p)) n = (n<<3)+(n<<1) + (*p++ & 0xf); *res = n; return p;\n}\n\nvoid calc(int a, int b)\n{\n\tint r, c;\n\tint tmp;\n\n\ttmp = new();\n\tfor (r = 0; r < N; r++) for (c = 0; c < N; c++) {\n\t\ttbl[tmp][r][c] = tbl[a][tbl[b][r][c].r][tbl[b][r][c].c];\n\t}\n\tfor (r = 0; r < N; r++) for (c = 0; c < N; c++) tbl[a][r][c] = tbl[tmp][r][c];\n\tdis(tmp);\n}\n\nchar *ope(int a, char *s)\n{\n\tint k, r, c;\n\tchar x;\n\n\tx = *s++;\n\ts = in(&k, s), k--;\n\tfor (r = 0; r < N; r++) for (c = 0; c < N; c++)\n\t\ttbl[a][r][c].r = r, tbl[a][r][c].c = c;\n\n\tif      (x == 'L') for (c = 0; c < N; c++) tbl[a][k][c].c = (c+1  ) % N;\n    else if (x == 'R') for (c = 0; c < N; c++) tbl[a][k][c].c = (c-1+N) % N;\n    else if (x == 'U') for (r = 0; r < N; r++) tbl[a][r][k].r = (r+1  ) % N;\n\telse               for (r = 0; r < N; r++) tbl[a][r][k].r = (r-1+N) % N;\n\treturn s;\n}\n\nchar *rep(int a, char *s)\n{\n\tint n, r, c;\n\tint b;\n\t\n\tb = new();\n\ts = seq(b, s)+1;\n\ts = in(&n, s);\n\tfor (r = 0; r < N; r++) for (c = 0; c < N; c++)\n\t\ttbl[a][r][c].r = r, tbl[a][r][c].c = c;\n\n\twhile (n) {\n\t\tif (n & 1) calc(a, b);\n\t\tcalc(b, b);\n\t\tn >>= 1;\n\t}\n\tdis(b);\n\treturn s;\n}\n\nchar *seq(int res, char *s)\n{\n\tint r, c;\n\tint tmp;\n\n\tfor (r = 0; r < N; r++) for (c = 0; c < N; c++)\n\t\ttbl[res][r][c].r = r, tbl[res][r][c].c = c;\n\ttmp = new();\n\twhile (*s == '(' || isalpha(*s)) {\n\t\tif (*s == '(') s = rep(tmp, s + 1);\n\t\telse s = ope(tmp, s);\n\t\tcalc(res, tmp);\n\t}\n\tdis(tmp);\n\treturn s;\n}\n\nint main()\n{\n\tint L, r, c;\n\tint ans;\n\tchar *p;\n\t\n\tfgets(p=s, 16, stdin), p = in(&N, p), in(&L, p+1);\n\tfgets(s, 1002, stdin);\n\n\tans = new();\n\tseq(ans, s);\n\tfor (r = 0; r < N; r++) {\n\t\tprintf(\"%d\", N*tbl[ans][r][0].r + tbl[ans][r][0].c + 1);\n\t\tfor (c = 1; c < N; c++)\n\t\t\tprintf(\" %d\", N*tbl[ans][r][c].r + tbl[ans][r][c].c + 1);\n\t\tputchar('\\n');\n\t}\n\treturn 0;\n}\n"
  },
  {
    "language": "C",
    "code": "// AOJ 2731 Shifting a Matrix\n// 2018.2.11 bal4u\n\n#include <stdio.h>\n#include <ctype.h>\n\n#define SIZE 1000\n\nint N;\ntypedef struct { short r, c; } T;\nT tbl[SIZE+2][101][101];\nchar s[1002], *p;\nchar used[SIZE+2];\n\nchar *seq(int res, char *s);\n\n// malloc\nint new() {\tint i;\n\tfor (i = 0; i < SIZE; i++) if (!used[i]) { used[i] = 1; break; }\n\treturn i;\n}\n\n// free\nvoid dis(int k) { used[k] = 0; }\n\nchar *in(int *res, char *p) { int n = 0;\n\twhile (isdigit(*p)) n = (n<<3)+(n<<1) + (*p++ & 0xf); *res = n; return p;\n}\n\nvoid calc(int a, int b)\n{\n\tint r, c;\n\tint tmp;\n\n\ttmp = new();\n\tfor (r = 0; r < N; r++) for (c = 0; c < N; c++) {\n\t\ttbl[tmp][r][c] = tbl[a][tbl[b][r][c].r][tbl[b][r][c].c];\n\t}\n\tfor (r = 0; r < N; r++) for (c = 0; c < N; c++) tbl[a][r][c] = tbl[tmp][r][c];\n\tdis(tmp);\n}\n\nchar *ope(int a, char *s)\n{\n\tint k, r, c;\n\tchar x;\n\n\tx = *s++;\n\ts = in(&k, s), k--;\n\tfor (r = 0; r < N; r++) for (c = 0; c < N; c++)\n\t\ttbl[a][r][c].r = r, tbl[a][r][c].c = c;\n\n\tif      (x == 'L') for (c = 0; c < N; c++) tbl[a][k][c].c = (c+1  ) % N;\n    else if (x == 'R') for (c = 0; c < N; c++) tbl[a][k][c].c = (c-1+N) % N;\n    else if (x == 'U') for (r = 0; r < N; r++) tbl[a][r][k].r = (r+1  ) % N;\n\telse               for (r = 0; r < N; r++) tbl[a][r][k].r = (r-1+N) % N;\n\treturn s;\n}\n\nchar *rep(int a, char *s)\n{\n\tint n, r, c;\n\tint b;\n\t\n\tb = new();\n\ts = seq(b, s)+1;\n\ts = in(&n, s);\n\tfor (r = 0; r < N; r++) for (c = 0; c < N; c++)\n\t\ttbl[a][r][c].r = r, tbl[a][r][c].c = c;\n\n\twhile (n) {\n\t\tif (n & 1) calc(a, b);\n\t\tcalc(b, b);\n\t\tn >>= 1;\n\t}\n\tdis(b);\n\treturn s;\n}\n\nchar *seq(int res, char *s)\n{\n\tint r, c;\n\tint tmp;\n\n\tfor (r = 0; r < N; r++) for (c = 0; c < N; c++)\n\t\ttbl[res][r][c].r = r, tbl[res][r][c].c = c;\n\ttmp = new();\n\twhile (*s == '(' || isalpha(*s)) {\n\t\tif (*s == '(') s = rep(tmp, s + 1);\n\t\telse s = ope(tmp, s);\n\t\tcalc(res, tmp);\n\t}\n\tdis(tmp);\n\treturn s;\n}\n\nint main()\n{\n\tint L, r, c;\n\tint ans;\n\t\n\tfgets(p=s, 16, stdin), p = in(&N, p), in(&L, p+1);\n\tfgets(s, 1002, stdin);\n\n\tans = new();\n\tseq(ans, s);\n\tfor (r = 0; r < N; r++) {\n\t\tprintf(\"%d\", N*tbl[ans][r][0].r + tbl[ans][r][0].c + 1);\n\t\tfor (c = 1; c < N; c++)\n\t\t\tprintf(\" %d\", N*tbl[ans][r][c].r + tbl[ans][r][c].c + 1);\n\t\tputchar('\\n');\n\t}\n\treturn 0;\n}\n"
  },
  {
    "language": "C",
    "code": "// AOJ 2731 Shifting a Matrix\n// 2018.2.11 bal4u\n\n#include <stdio.h>\n#include <ctype.h>\n#include <string.h>\n\n#define SIZE 700\n\nint N;\ntypedef struct { short r, c; } T;\nT ans[101][101], t0[101][101];\nT tbl[SIZE+1][101][101];\nchar used[SIZE+1]; int top;\nchar s[1002], *p;\n\nchar *seq(T res[101][101], char *s);\n\n// malloc\nint new() { int i, k;\n\tused[k=i=top] = 1;\n\twhile (++i < SIZE) if (!used[i]) { top = i; break; }\n\treturn k;\n}\n\n// free\nvoid dis(int k) { used[k] = 0; if (k < top) top = k; }\n\nchar *in(int *res, char *p) { int n = 0;\n\twhile (isdigit(*p)) n = (n<<3)+(n<<1) + (*p++ & 0xf); *res = n; return p;\n}\n\nvoid calc(T a[101][101], T b[101][101])\n{\n\tint r, c;\n\tT t[101][101];\n\n\tfor (r = 0; r < N; r++) for (c = 0; c < N; c++) {\n\t\tt[r][c] = a[b[r][c].r][b[r][c].c];\n\t}\n\tmemcpy(a, t, sizeof(t));\n}\n\nchar *ope(T a[101][101], char *s)\n{\n\tint k, r, c;\n\tchar x;\n\n\tx = *s++;\n\ts = in(&k, s), k--;\n\tmemcpy(a, t0, sizeof(t0));\n\n\tif      (x == 'L') { for (c = 0; c < N; c++) a[k][c].c = c+1; a[k][N-1].c = 0; }\n\telse if (x == 'R') { for (c = 0; c < N; c++) a[k][c].c = c-1; a[k][0].c = N-1; }\n\telse if (x == 'U') { for (r = 0; r < N; r++) a[r][k].r = r+1; a[N-1][k].r = 0; }\n\telse               { for (r = 0; r < N; r++) a[r][k].r = r-1; a[0][k].r = N-1; }\n\treturn s;\n}\n\nchar *rep(T a[101][101], char *s)\n{\n\tint n, _b;\n\tT (*b)[101];\n\t\n\tb = tbl[_b=new()];\n\ts = seq(b, s)+1;\n\ts = in(&n, s);\n\tmemcpy(a, t0, sizeof(t0));\n\n\twhile (n) {\n\t\tif (n & 1) calc(a, b);\n\t\tcalc(b, b);\n\t\tn >>= 1;\n\t}\n\tdis(_b);\n\treturn s;\n}\n\nchar *seq(T res[101][101], char *s)\n{\n\tint _t;\n\tT (*t)[101];\n\n\tmemcpy(res, t0, sizeof(t0));\n\tt = tbl[_t=new()];\n\twhile (*s == '(' || isalpha(*s)) {\n\t\tif (*s == '(') s = rep(t, s + 1);\n\t\telse           s = ope(t, s);\n\t\tcalc(res, t);\n\t}\n\tdis(_t);\n\treturn s;\n}\n\nint main()\n{\n\tint L, r, c;\n\t\n\tfgets(p=s, 16, stdin), p = in(&N, p), in(&L, p+1);\n\tfgets(s, 1002, stdin);\n\n\tfor (r = 0; r < N; r++) for (c = 0; c < N; c++)\n\t\tt0[r][c].r = r, t0[r][c].c = c;\n\n\tseq(ans, s);\n\tfor (r = 0; r < N; r++) {\n\t\tprintf(\"%d\", N*ans[r][0].r + ans[r][0].c + 1);\n\t\tfor (c = 1; c < N; c++)\n\t\t\tprintf(\" %d\", N*ans[r][c].r + ans[r][c].c + 1);\n\t\tputchar('\\n');\n\t}\n\treturn 0;\n}\n"
  },
  {
    "language": "C",
    "code": "// AOJ 2731 Shifting a Matrix\n// 2018.2.11 bal4u\n\n#include <stdio.h>\n#include <ctype.h>\n#include <string.h>\n\n#define SIZE 700\n\nint N;\ntypedef struct { short r, c; } T;\nT ans[101][101], t0[101][101];\nT tbl[SIZE+1][101][101];\nchar used[SIZE+1]; int top;\nchar s[1002], *p;\n\nchar *seq(T res[101][101], char *s);\n\n// malloc\nint new() { int i, k;\n\tused[k=i=top] = 1;\n\twhile (++i < SIZE) if (!used[i]) { top = i; break; }\n\treturn k;\n}\n\n// free\nvoid dis(int k) { used[k] = 0; if (k < top) top = k; }\n\nchar *in(int *res, char *p) { int n = 0;\n\twhile (isdigit(*p)) n = (n<<3)+(n<<1) + (*p++ & 0xf); *res = n; return p;\n}\n\nvoid calc(T a[101][101], T b[101][101])\n{\n\tint r, c;\n\tT t[101][101];\n\n\tfor (r = 0; r < N; r++) for (c = 0; c < N; c++) {\n\t\tt[r][c] = a[b[r][c].r][b[r][c].c];\n\t}\n\tmemcpy(a, t, sizeof(t));\n}\n\nchar *ope(T a[101][101], char *s)\n{\n\tint k, r, c;\n\tchar x;\n\n\tx = *s++;\n\ts = in(&k, s), k--;\n\tmemcpy(a, t0, sizeof(t0));\n\n\tif      (x == 'L') for (c = 0; c < N; c++) a[k][c].c = (c+1  ) % N;\n    else if (x == 'R') for (c = 0; c < N; c++) a[k][c].c = (c-1+N) % N;\n    else if (x == 'U') for (r = 0; r < N; r++) a[r][k].r = (r+1  ) % N;\n\telse               for (r = 0; r < N; r++) a[r][k].r = (r-1+N) % N;\n\treturn s;\n}\n\nchar *rep(T a[101][101], char *s)\n{\n\tint n, _b;\n\tT (*b)[101];\n\t\n\tb = tbl[_b=new()];\n\ts = seq(b, s)+1;\n\ts = in(&n, s);\n\tmemcpy(a, t0, sizeof(t0));\n\n\twhile (n) {\n\t\tif (n & 1) calc(a, b);\n\t\tcalc(b, b);\n\t\tn >>= 1;\n\t}\n\tdis(_b);\n\treturn s;\n}\n\nchar *seq(T res[101][101], char *s)\n{\n\tint _t;\n\tT (*t)[101];\n\n\tmemcpy(res, t0, sizeof(t0));\n\n\tt = tbl[_t=new()];\n\twhile (*s == '(' || isalpha(*s)) {\n//printf(\"seq %s\", s);\n\t\tif (*s == '(') s = rep(t, s + 1);\n\t\telse s = ope(t, s);\n\t\tcalc(res, t);\n\t}\n\tdis(_t);\n\treturn s;\n}\n\nint main()\n{\n\tint L, r, c;\n\t\n\tfgets(p=s, 16, stdin), p = in(&N, p), in(&L, p+1);\n\tfgets(s, 1002, stdin);\n\n\tfor (r = 0; r < N; r++) for (c = 0; c < N; c++)\n\t\tt0[r][c].r = r, t0[r][c].c = c;\n\n\tseq(ans, s);\n\tfor (r = 0; r < N; r++) {\n\t\tprintf(\"%d\", N*ans[r][0].r + ans[r][0].c + 1);\n\t\tfor (c = 1; c < N; c++)\n\t\t\tprintf(\" %d\", N*ans[r][c].r + ans[r][c].c + 1);\n\t\tputchar('\\n');\n\t}\n\treturn 0;\n}\n"
  },
  {
    "language": "C",
    "code": "// AOJ 2731 Shifting a Matrix\n// 2018.2.11 bal4u\n\n#include <stdio.h>\n#include <ctype.h>\n#include <string.h>\n\n#define SIZE 700\n\nint N, N2;\nshort ans[10001], t0[10001], tmp[10001];\nshort mat[SIZE+1][10001];\nchar used[SIZE+1]; int top;\nchar s[1002], *p;\n\nchar *seq(short *res, char *s);\n\n// malloc\nint new() { int i, k;\n\tused[k=i=top] = 1;\n\twhile (++i < SIZE) if (!used[i]) { top = i; break; }\n\treturn k;\n}\n\n// free\nvoid dis(int k) { used[k] = 0; if (k < top) top = k; }\n\nchar *in(int *res, char *p) { int n = 0;\n\twhile (isdigit(*p)) n = (n<<3)+(n<<1) + (*p++ & 0xf); *res = n; return p;\n}\n\nvoid calc(short *a, short *b)\n{\n\tint i;\n\tfor (i = 0; i < N2; i++) tmp[i] = a[b[i]];\n\tmemcpy(a, tmp, sizeof(tmp));\n}\n\nchar *ope(short *a, char *s)\n{\n\tint k, r, c;\n\tchar x;\n\n\tx = *s++;\n\ts = in(&k, s), k--;\n\n\tmemcpy(a, t0, sizeof(t0));\n\tif      (x == 'L') { for (c = 0; c < N; c++) a[k*N+c] = k*N+c+1; a[k*N+N-1] = k*N; }\n\telse if (x == 'R') { for (c = 0; c < N; c++) a[k*N+c] = k*N+c-1; a[k*N] = k*N+N-1; }\n\telse if (x == 'U') { for (r = 0; r < N; r++) a[r*N+k] = (r+1)*N+k; a[(N-1)*N+k] = k; }\n\telse               { for (r = 0; r < N; r++) a[r*N+k] = (r-1)*N+k; a[k] = (N-1)*N+k; }\n\treturn s;\n}\n\nchar *rep(short *a, char *s)\n{\n\tint n, _b;\n\tshort *b;\n\n\tb = mat[_b=new()];\n\ts = seq(b, s)+1;\n\ts = in(&n, s);\n\tmemcpy(a, t0, sizeof(t0));\n\n\twhile (n) {\n\t\tif (n & 1) calc(a, b);\n\t\tcalc(b, b);\n\t\tn >>= 1;\n\t}\n\tdis(_b);\n\treturn s;\n}\n\nchar *seq(short *res, char *s)\n{\n\tint _t;\n\tshort *t;\n\n\tmemcpy(res, t0, sizeof(t0));\n\tt = mat[_t=new()];\n\tmemcpy(t, t0, sizeof(t0));\n\twhile (*s == '(' || isalpha(*s)) {\n\t\tif (*s == '(') s = rep(t, s + 1);\n\t\telse           s = ope(t, s);\n\t\tcalc(res, t);\n\t}\n\tdis(_t);\n\treturn s;\n}\n\nint main()\n{\n\tint L, i, r, c, _r;\n\t\n\tfgets(p=s, 16, stdin), p = in(&N, p), in(&L, p+1), N2 = N*N;\n\tfgets(s, 1002, stdin);\n\tfor (i = 0; i < N2; i++) t0[i] = i;\n\n\tseq(ans, s);\n\tfor (_r = 0, r = 0; r < N; r++, _r += N) {\n\t\tprintf(\"%d\", 1+ans[_r]);\n\t\tfor (c = 1; c < N; c++)\tprintf(\" %d\", 1+ans[_r+c]);\n\t\tputchar('\\n');\n\t}\n\treturn 0;\n}\n"
  },
  {
    "language": "C#",
    "code": "using System;\nusing System.Linq;\nusing System.Collections.Generic;\nusing Debug = System.Diagnostics.Debug;\nusing SB = System.Text.StringBuilder;\nusing System.Numerics;\nusing static System.Math;\nusing Point = System.Numerics.Complex;\nusing Number = System.Int64;\nnamespace Program {\n    public class Solver {\n        Random rnd = new Random(0);\n        public void Solve() {\n            n = ri;\n            l = ri;\n            s = rs + \"$\";\n            var ptr = 0;\n            var to = seq(ref ptr);\n            var ans = Enumerate(n, x => new int[n]);\n            for (int i = 0; i < n; i++)\n                for (int j = 0; j < n; j++)\n                {\n                    var t = to[i][j];\n                    ans[t / n][t % n] = i * n + j + 1;\n                }\n            for (int i = 0; i < n; i++)\n                Console.WriteLine(ans[i].AsJoinedString());\n        }\n        int n, l;\n        string s;\n\n\n        int num(ref int ptr) {\n            var ret = 0;\n            while (char.IsDigit(s[ptr])) ret = ret * 10 + s[ptr++] - '0';\n            return ret;\n        }\n        int[][] rep_op(ref int ptr) {\n            var ans = Enumerate(n, x => new int[n]);\n            for (int i = 0; i < n; i++)\n                for (int j = 0; j < n; j++) ans[i][j] = i * n + j;\n            if (s[ptr] == '(')\n            {\n                ptr++;\n                var mat = seq(ref ptr);\n                ptr++;// ')'\n                var k = num(ref ptr);\n                for (; k > 0; k /= 2)\n                {\n                    if (k % 2 == 1) ans = mul(ans, mat);\n                    mat = mul(mat, mat);\n                }\n            }\n            else\n            {\n                var c = s[ptr++];\n                var k = num(ref ptr) - 1;\n                var tmp = -1;\n                if (c == 'R') tmp = ans[k][0];\n                if (c == 'L') tmp = ans[k][n - 1];\n                if (c == 'D') tmp = ans[0][k];\n                if (c == 'U') tmp = ans[n - 1][k];\n                for (int i = 0; i < n - 1; i++)\n                {\n                    if (c == 'R') ans[k][i] = ans[k][i + 1];\n                    if (c == 'L') ans[k][n - 1 - i] = ans[k][n - 2 - i];\n                    if (c == 'D') ans[i][k] = ans[i + 1][k];\n                    if (c == 'U') ans[n - 1 - i][k] = ans[n - 2 - i][k];\n                }\n                if (c == 'R') ans[k][n - 1] = tmp;\n                if (c == 'L') ans[k][0] = tmp;\n                if (c == 'D') ans[n - 1][k] = tmp;\n                if (c == 'U') ans[0][k] = tmp; ;\n            }\n            return ans;\n        }\n        int[][] seq(ref int ptr) {\n            var ans = Enumerate(n, x => new int[n]);\n            for (int i = 0; i < n; i++)\n                for (int j = 0; j < n; j++)\n                    ans[i][j] = i * n + j;\n            while (ptr < l && s[ptr] != ')')\n            {\n                var mat = rep_op(ref ptr);\n                ans = mul(ans, mat);\n            }\n            return ans;\n        }\n        int[][] mul(int[][] a, int[][] b) {\n            var ret = Enumerate(n, x => new int[n]);\n            for (int i = 0; i < n; i++)\n                for (int j = 0; j < n; j++)\n                {\n                    var to = a[i][j];\n                    ret[i][j] = b[to / n][to % n];\n                }\n            return ret;\n        }\n        const long INF = 1L << 60;\n        int ri { get { return sc.Integer(); } }\n        long rl { get { return sc.Long(); } }\n        double rd { get { return sc.Double(); } }\n        string rs { get { return sc.Scan(); } }\n        public IO.StreamScanner sc = new IO.StreamScanner(Console.OpenStandardInput());\n\n        static T[] Enumerate<T>(int n, Func<int, T> f) {\n            var a = new T[n];\n            for (int i = 0; i < n; ++i) a[i] = f(i);\n            return a;\n        }\n        static public void Swap<T>(ref T a, ref T b) { var tmp = a; a = b; b = tmp; }\n    }\n}\n\n#region main\nstatic class Ex {\n    static public string AsString(this IEnumerable<char> ie) { return new string(ie.ToArray()); }\n    static public string AsJoinedString<T>(this IEnumerable<T> ie, string st = \" \") {\n        return string.Join(st, ie);\n    }\n    static public void Main() {\n        Console.SetOut(new Program.IO.Printer(Console.OpenStandardOutput()) { AutoFlush = false });\n        var solver = new Program.Solver();\n        solver.Solve();\n        Console.Out.Flush();\n    }\n}\n#endregion\n#region Ex\nnamespace Program.IO {\n    using System.IO;\n    using System.Text;\n    using System.Globalization;\n\n    public class Printer: StreamWriter {\n        public override IFormatProvider FormatProvider { get { return CultureInfo.InvariantCulture; } }\n        public Printer(Stream stream) : base(stream, new UTF8Encoding(false, true)) { }\n    }\n\n    public class StreamScanner {\n        public StreamScanner(Stream stream) { str = stream; }\n\n        public readonly Stream str;\n        private readonly byte[] buf = new byte[1024];\n        private int len, ptr;\n        public bool isEof = false;\n        public bool IsEndOfStream { get { return isEof; } }\n\n        private byte read() {\n            if (isEof) return 0;\n            if (ptr >= len)\n            {\n                ptr = 0;\n                if ((len = str.Read(buf, 0, 1024)) <= 0)\n                {\n                    isEof = true;\n                    return 0;\n                }\n            }\n            return buf[ptr++];\n        }\n\n        public char Char() {\n            byte b = 0;\n            do b = read(); while ((b < 33 || 126 < b) && !isEof);\n            return (char)b;\n        }\n        public string Scan() {\n            var sb = new StringBuilder();\n            for (var b = Char(); b >= 33 && b <= 126; b = (char)read()) sb.Append(b);\n            return sb.ToString();\n        }\n        public string ScanLine() {\n            var sb = new StringBuilder();\n            for (var b = Char(); b != '\\n' && b != 0; b = (char)read()) if (b != '\\r') sb.Append(b);\n            return sb.ToString();\n        }\n        public long Long() { return isEof ? long.MinValue : long.Parse(Scan()); }\n        public int Integer() { return isEof ? int.MinValue : int.Parse(Scan()); }\n        public double Double() { return isEof ? double.NaN : double.Parse(Scan(), CultureInfo.InvariantCulture); }\n    }\n}\n\n#endregion\n\n\n"
  },
  {
    "language": "Ruby",
    "code": "class Array\n    def *(other)\n        map {|i| other[i]}\n    end\nend\n\ndef exp(m, k, mod = nil)\n    x = (0..m.size-1).to_a\n    r = m\n    while k > 0\n        x *= r if k & 1 == 1\n        r *= r\n        if mod\n            x %= mod\n            r %= mod\n        end\n        k >>= 1\n    end\n    x\nend\n\ndef parse(n, exp)\n    if exp == \"\"\n        return (0..n*n-1).to_a\n    end\n\n    if exp =~ /^([UDLR])(\\d+)/\n        k = $&.size\n        op, i = $1, $2.to_i - 1\n        perm = (0..n*n-1).to_a\n        case op\n        when ?L then\n            (i * n .. i * n + n - 1).each do |k|\n                if k == i * n + n - 1\n                    perm[k] = i * n\n                else\n                    perm[k] = k + 1\n                end\n            end\n        when ?R then\n            (i * n .. i * n + n - 1).each do |k|\n                if k == i * n\n                    perm[k] = k + n - 1\n                else\n                    perm[k] = k - 1\n                end\n            end\n        when ?D then\n            (0..n-1).each do |k|\n                if k == 0\n                    perm[k * n + i] = (n - 1) * n + i\n                else\n                    perm[k * n + i] = k * n + i - n\n                end\n            end\n        when ?U then\n            (0..n-1).each do |k|\n                if k == n - 1\n                    perm[k * n + i] = i\n                else\n                    perm[k * n + i] = k * n + i + n\n                end\n            end\n        end\n        return parse(n, exp[k..-1]) * perm\n    end\n\n    raise if exp[0] != ?(\n    i = 1\n    paren = 1\n    until paren == 0\n        paren += 1 if exp[i] == ?(\n        paren -= 1 if exp[i] == ?)\n        i += 1\n    end\n    j = i\n    j += 1 while exp[j] =~ /\\d/\n\n    parse(n, exp[j..-1]) * exp(parse(n, exp[1..i-2]), exp[i..j-1].to_i)\nend\n\nn, l = gets.split.map(&:to_i)\nret = parse(n, gets.chomp)\n(0..n-1).each do |i|\n    puts (0..n-1).map {|j| ret[i * n + j] + 1}.join(\" \")\nend\n\n"
  },
  {
    "language": "Python",
    "code": "from string import digits\nimport sys\nreadline = sys.stdin.readline\nwrite = sys.stdout.write\ndef solve():\n    N, L = map(int, readline().split())\n    S = readline().strip()\n    *I, = range(N*N)\n    LRUD = \"LRUD\"\n    FS = [[], [], [], []]\n    for i in range(N):\n        base = N*i\n        F = I[:]\n        for j in range(N):\n            F[base+j] = base+((j+1) % N)\n        FS[0].append(F)\n        F = I[:]\n        for j in range(N):\n            F[base+j] = base+((j-1) % N)\n        FS[1].append(F)\n\n        base = i\n        F = I[:]\n        for j in range(N):\n            F[base+N*j] = base+((j+1) % N)*N\n        FS[2].append(F)\n        F = I[:]\n        for j in range(N):\n            F[base+N*j] = base+((j-1) % N)*N\n        FS[3].append(F)\n\n    def fast_pow(f, n):\n        r = I[:]\n        while n:\n            if n & 1:\n                r = [f[x] for x in r]\n            f = [f[x] for x in f]\n            n >>= 1\n        return r\n\n    S += \"$\"\n    cur = 0\n    def number():\n        nonlocal cur\n        r = 0\n        while S[cur] in digits:\n            r = 10*r + int(S[cur])\n            cur += 1 # digits\n        return r\n\n    def expr():\n        nonlocal cur\n        f0 = I[:]\n        while 1:\n            if S[cur] == '(':\n                cur += 1 # '('\n                r1 = expr()\n                cur += 1 # ')'\n                num = number()\n                f1 = fast_pow(r1, num)\n            elif S[cur] in LRUD:\n                t = LRUD.index(S[cur])\n                cur += 1 # LRUD\n                num = number()\n                f1 = FS[t][num-1]\n            else:\n                break\n            f0 = [f0[x] for x in f1]\n        return f0\n\n    f = expr()\n    ans = [str(x+1) for x in f]\n    for i in range(N):\n        write(\" \".join(ans[i*N:i*N+N]))\n        write(\"\\n\")\nsolve()\n"
  }
]