[
  {
    "language": "Scala",
    "code": "//import java.util.Scanner\n\nimport java.io._\nimport java.nio.file.Files._\nimport java.nio.file.Path\nimport java.util.StringTokenizer\n\nimport scala.collection.immutable._\nimport scala.io.Codec\n\n/**\n  * Scala implementation of a faster java.util.Scanner\n  * See: http://codeforces.com/blog/entry/7018\n  */\n\nclass Scanner(reader: LineNumberReader) extends Iterable[String] with AutoCloseable {\n  def this(reader: BufferedReader) = this(new LineNumberReader(reader))\n\n  def this(reader: Reader) = this(new BufferedReader(reader))\n\n  def this(inputStream: InputStream)(implicit codec: Codec) = this(new InputStreamReader(inputStream, codec.charSet))\n\n  def this(path: Path)(implicit codec: Codec) = this(newBufferedReader(path, codec.charSet))\n\n  def this(file: File)(implicit codec: Codec) = this(file.toPath)(codec)\n\n  def this(str: String) = this(new StringReader(str))\n\n  override def iterator: Iterator[String] = for {\n    line <- Iterator.continually(reader.readLine()).takeWhile(_ != null)\n    tokenizer = new StringTokenizer(line)\n    tokens <- Iterator.continually(tokenizer).takeWhile(_.hasMoreTokens)\n  } yield tokens.nextToken()\n\n  private[this] var current = iterator\n\n  def hasNext: Boolean = current.hasNext\n\n  @inline def next(): String = current.next()\n\n  /**\n    * This is different from Java's scanner.nextLine\n    * The Java one is a misnomer since it actually travel to end of current line\n    * This one actually does fetch the next line\n    */\n  def nextLine(): String = {\n    val line = reader.readLine()\n    current = iterator\n    line\n  }\n\n  def lineNumber: Int = reader.getLineNumber\n\n  def nextString(): String = next()\n\n  def nextBoolean(): Boolean = next().toBoolean\n\n  def nextByte(radix: Int = 10): Byte = java.lang.Byte.parseByte(next(), radix)\n\n  def nextShort(radix: Int = 10): Short = java.lang.Short.parseShort(next(), radix)\n\n  def nextInt(radix: Int = 10): Int = java.lang.Integer.parseInt(next(), radix)\n\n  def nextLong(radix: Int = 10): Long = java.lang.Long.parseLong(next(), radix)\n\n  def nextBigInt(radix: Int = 10): BigInt = BigInt(next(), radix)\n\n  def nextFloat(): Float = next().toFloat\n\n  def nextDouble(): Double = next().toDouble\n\n  def nextBigDecimal(): BigDecimal = BigDecimal(next())\n\n  override def close(): Unit = reader.close()\n}\n\n\nclass IUnionFind(val size: Int) {\n\n  private case class Node(var parent: Option[Int], var treeSize: Int)\n\n  private val nodes = Array.fill[Node](size)(Node(None, treeSize = 1))\n\n  def union(t1: Int, t2: Int): IUnionFind = {\n    if (t1 == t2) return this\n\n    val root1 = root(t1)\n    val root2 = root(t2)\n    if (root1 == root2) return this\n\n    val node1 = nodes(root1)\n    val node2 = nodes(root2)\n\n    if (node1.treeSize < node2.treeSize) {\n      node1.parent = Some(t2)\n      node2.treeSize += node1.treeSize\n    } else {\n      node2.parent = Some(t1)\n      node1.treeSize += node2.treeSize\n    }\n    this\n  }\n\n  def connected(t1: Int, t2: Int): Boolean = t1 == t2 || root(t1) == root(t2)\n\n  def root(t: Int): Int = nodes(t).parent match {\n    case None => t\n    case Some(p) =>\n      nodes(t).parent = Some(root(p))\n      nodes(t).parent.get\n  }\n}\n\n\nobject Main {\n  @scala.annotation.tailrec\n  def solve(sc: => Scanner): Unit = {\n    val h, w = sc.nextInt()\n    if (h != 0 || w != 0) {\n      var M = Map[Char, (Int, Int)]()\n\n      Array.fill(h)(sc.next()).zipWithIndex.foreach(x => x._1.zipWithIndex.foreach(y => M += (y._1 -> (x._2, y._2))))\n      println(\n        ((0, 0) +: sc.next().map(x => M(x))).sliding(2).map(C => {\n          Math.abs(C(0)._1 - C(1)._1) + Math.abs(C(0)._2 - C(1)._2) + 1\n        }).sum)\n\n      solve(sc)\n    }\n  }\n\n  def recursive(AB: List[(Long, Long)], ansX: String, now: Long, usedA: Int, usedB: Int, MaxValues: List[Long]): Option[String] = {\n    if (AB.isEmpty) Some(ansX)\n    else if (MaxValues.head < now) None\n    else {\n      val A =\n        Array((AB.head._1, true), (AB.head._2, false))\n          .filter(_._1 >= now)\n          .filter(!_._2 || usedA > 0)\n          .filter(_._2 || usedB > 0)\n      A.foldLeft(None: Option[String])((x, y) =>\n        if (x.isEmpty)\n          if (y._2) recursive(AB.tail, ansX ++ \"A\", y._1, usedA - 1, usedB, MaxValues.tail)\n          else recursive(AB.tail, ansX ++ \"B\", y._1, usedA, usedB - 1, MaxValues.tail)\n        else x)\n    }\n  }\n\n  def flip(A: Array[Boolean], B: Array[(Int, Long)]): Array[(Int, Long)] = {\n    B.map { case (index, _) =>\n      (index, (if (0 < index && A(index - 1)) B(index - 1)._2 else 0L) + (if (index + 1 < B.length && !A(index + 1)) B(index + 1)._2 else 0L))\n    }\n  }\n\n  val mod: Long = (1e9 + 7).toLong\n\n\n  @scala.annotation.tailrec\n  def factorial(now: Long, ans: Long = 1): Long = {\n    if (now == 0) 0 else if (now == 1) ans else factorial(now - 1, now * ans)\n  }\n\n  implicit class implicitInt(val N: Int) {\n    def times[B](function: Int => B): IndexedSeq[B] = (0 until N).map(function)\n  }\n\n  def calc(input: (Long, Long, Long, Long, Long, Long)): Long = {\n    input match {\n      case (a, b, c, x, y, z) =>\n        var ans: Long = Long.MaxValue\n        if (b >= 3 && (a >= 2 || c >= 2)) {\n          ans = Math.min(ans, Math.max(a - (b - 1), 0) * x + Math.max(c - Math.min(a - 1, b - 2), 0) * z)\n          ans = Math.min(ans, Math.max(a - Math.min(c - 1, b - 2), 0) * x + Math.max(c - (b - 1), 0) * z)\n        }\n        //        println(ans)\n        if (b >= 2 && (a >= b && c >= b + 1)) {\n          ans = Math.min(ans, y + Math.max(0, a - (c - 1)) * x)\n        }\n        //        println(ans)\n        if (b >= 2 && (a >= b + 1 && c >= b)) {\n          ans = Math.min(ans, y + Math.max(0, c - (a - 1)) * z)\n        }\n        //        println(ans)\n        if (a >= 2 && c >= 2)\n          if (a != c)\n            ans = Math.min(ans, Math.max(0, b - (Math.min(a, c) - 1)) * y)\n          else if (a >= 3 && c >= 3)\n            ans = Math.min(ans, Math.max(0, b - (Math.min(a, c) - 2)) * y + Math.min(x, z))\n        //        println(ans)\n        if (ans == Long.MaxValue) ans = -1\n        ans\n    }\n  }\n\n  def time(s: String): Int =\n    s.substring(0, 2).toInt * 60 + s.substring(3, 5).toInt\n\n  /*\n  def getPermutation(begin: Long = 0): LazyList[Long] =\n    LazyList.cons(begin, getPermutation(begin + 1))\n\n  def getFibonacci(prevprev: Long = 0, prev: Long = 1): LazyList[Long] =\n    LazyList.cons(prevprev, getFibonacci(prev, prevprev + prev))\n\n  @scala.annotation.tailrec\n  def recursive2(X: Set[Long], Y: LazyList[Long]): Long = if (X.contains(Y.head)) X.size else recursive2(X + Y.head, Y.tail)\n*/\n  def check(i: Int, X: String): Long = {\n    if (X == \"\") 0 else check(i, X.tail) * i + X.head.toString.toLong\n  }\n\n  def shift(n: Long): Long = {\n    if (n == 0) 0\n    else if (n == 1) 1\n    else shift(n - 1) << 1\n  }\n\n  def unShift(n: Long): Long = {\n    if (n == 0) 0\n    else unShift(n >> 1) + 1\n  }\n\n  @scala.annotation.tailrec\n  def gcd(i: Long, j: Long): Long = {\n    if (i < j) gcd(j, i)\n    else if (j == 0) i\n    else gcd(j, i % j)\n  }\n\n  def primeFactors(i: Long): List[Long] = primeFactors_(i, 1).sorted\n\n\n  def primeFactors_(i: Long, j: Long): List[Long] = {\n    if (j * j > i) List.empty else if (i % j == 0) primeFactors_(i, j + 1) ++ List[Long](j, i / j) else primeFactors_(i, j + 1)\n  }\n\n  def main(args: Array[String]): Unit = {\n    val sc: Scanner = new Scanner(System.in)\n    solve(sc)\n  }\n}\n\n/*\nobject Util {\n  def getPermutation(begin: Long = 0): LazyList[Long] =\n    LazyList.cons(begin, getPermutation(begin + 1))\n\n  def getPrimeList: LazyList[Long] =\n    getPrimeListRecursive(getPermutation(begin = 2))\n\n  private def getPrimeListRecursive(A: LazyList[Long]): LazyList[Long] =\n    LazyList.cons(A.head, getPrimeListRecursive(A.tail.filter(_ % A.head != 0)))\n\n  def fib(a: Long = 0, b: Long = 1, mod: Long = Long.MaxValue): LazyList[Long] = a #:: fib(b % mod, (a + b) % mod, mod)\n}\n\n */\n\nobject ArabicRoman {\n\n  type =?>[A, B] = PartialFunction[A, B]\n\n  private val codeTable: List[(Int, String)] = List(\n    (1000, \"M\"), (900, \"CM\"), (500, \"D\"), (400, \"CD\"), (100, \"C\"),\n    (90, \"XC\"), (50, \"L\"), (40, \"XL\"), (10, \"X\"), (9, \"IX\"), (5, \"V\"), (4, \"IV\"), (1, \"I\"))\n\n  val arabicToRoman: Int =?> String = {\n    case src if src >= 1 && src <= 3999 =>\n\n      @scala.annotation.tailrec\n      def convert(left: Int, cont: String = \"\", code: List[(Int, String)] = codeTable): String = {\n        val (unitVal, unitChar) = code.head\n        left - unitVal match {\n          case n if n == 0 => cont + unitChar\n          case n if n > 0 => convert(n, cont + unitChar, code)\n          case _ => convert(left, cont, code.tail)\n        }\n      }\n\n      convert(src)\n  }\n\n  val romanToArabic: String =?> Int = {\n    case src if Option(src).exists { s => {\n      s.nonEmpty && \"\"\"[^MDCLXVI]\"\"\".r.findFirstMatchIn(s.toUpperCase).isEmpty\n    }\n    } =>\n\n      @scala.annotation.tailrec\n      def convert(left: String, cont: Int = 0, code: List[(Int, String)] = codeTable): Int = {\n        val (unitVal, unitChar) = code.head\n        left.splitAt(unitChar.length) match {\n          case (\"\", _) => cont\n          case (`unitChar`, tail) => convert(tail, cont + unitVal, code)\n          case _ => convert(left, cont, code.tail)\n        }\n      }\n\n      convert(src.toUpperCase())\n  }\n}\n\nobject PowMod {\n  def naivePowMod(a: Long, k: Long, m: Long): Long = {\n    var t: Long = 1\n    val aMod: Long = a % m\n\n    for (_ <- 1L to k) {\n      t = ((t % m) * aMod) % m\n    }\n    t.toInt\n  }\n\n  def powMod(a: Long, k: Long, m: Long): Long = {\n    if (k == 0) 1\n    else {\n      val t = powMod(a, k / 2, m)\n      if ((k % 2) == 0) (t * t) % m else (((t * t) % m) * a) % m\n    }\n  }\n}\n"
  },
  {
    "language": "Scala",
    "code": "import scala.annotation.tailrec\nimport scala.collection.mutable\n\nobject Main extends App{\n  import scala.io.StdIn._\n  solve()\n  @tailrec def solve(): Unit = {\n    val Array(h, w) = readLine.trim.split(' ').map(_.toInt)\n    if (h == 0) return\n    val map = mutable.Map[Char, Coordinate]()\n    for (height ← 0 until h){\n      val line = readLine.trim\n      for (width ← 0 until w if line(width) != '_') {\n        map(line(width)) = Coordinate(height, width)\n      }\n    }\n    val statement = readLine.trim\n    var current = Coordinate(0, 0)\n    var sum = 0\n    for (s ← statement) {\n      val next = map(s)\n      sum += current.manhattanDistance(next) + 1\n      current = next\n    }\n    println(sum)\n    solve()\n  }\n  case class Coordinate(x: Int, y: Int) {\n    def manhattanDistance(that: Coordinate): Int = math.abs(x - that.x) + math.abs(y - that.y)\n  }\n}\n"
  },
  {
    "language": "C++",
    "code": "#include <iostream>\n#include <string>\n#include <algorithm>\n\nusing namespace std;\n\nint main(void){\n\twhile(1){\n\t\tint h, w; cin >> h >> w;\n\t\tif(!h && !w) break;\n\n\t\tstring cell[55]; //与えられるセル\n\t\tfor(int i=0; i<h; i++){\n\t\t\tcin >> cell[i];\n\t\t}\n\t\tstring str; cin >> str; //入力したい文字列\n\n\t\tint ans = 0;\n\t\tint pos_x=0, pos_y=0; //最後に押した(強調されている)cellの位置\n\t\tfor(int s=0; s<str.length(); s++){\n\t\t\tfor(int y=0; y<h; y++){\n\t\t\t\tbool find = false; //二重ループを抜けるためのフラグ\n\t\t\t\tfor(int x=0; x<w; x++){\n\t\t\t\t\tif(cell[y][x] == str[s]){\n\t\t\t\t\t\tans += abs(y-pos_y) + abs(x-pos_x) + 1; //マンハッタン距離+1\n\t\t\t\t\t\tpos_x = x; \n\t\t\t\t\t\tpos_y = y;\n\t\t\t\t\t\tfind = true;\n\t\t\t\t\t\tbreak;\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t\tif(find) break;\n\t\t\t}\n\t\t}\n\t\tcout << ans << endl;\n\t}\n\treturn 0;\n}\n"
  },
  {
    "language": "C++",
    "code": "#include <iostream>\n#include <vector>\n#include <map>\n#include <cmath>\nusing namespace std;\n\nint main(){\n    int H,W;\n    while(cin >> H >> W && H){\n        map<char,pair<int,int>> m;\n        char c;\n        for(int i=1;i<=H;i++){\n            for(int j=1;j<=W;j++){\n                cin >> c;\n                m[c] = {i,j}; \n            }\n        }\n        string S;\n        cin >> S;\n        int ans = (int) S.size();\n        int x = 1,y = 1;\n        for(auto a:S){\n            ans += abs(x-m[a].first)+abs(y-m[a].second);\n            x = m[a].first; y = m[a].second;\n        }\n        cout << ans << endl;\n    }\n}\n"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\n\ntypedef long long ll;\n#define ALL(a) a, a+sizeof(a)/sizeof(a[0])\n#define all(a) a.begin(),a.end()\n#define MOD 1000000007\nusing namespace std;\nll gcd(ll n, ll m) {\n\tif (m == 0) return n;\n\treturn gcd(m, n % m);\n}\nll lcm(ll n, ll m) {return m / gcd(n, m) * n;}\n\nint code[127][2];\n\nint main(void) {\n\tint h,w,ans=0;\n\tstring s;\n\twhile (1) {\n\t\tans = 0;\n\t\tint before[2] = { 0,0 };\n\t\tcin >> h >> w;\n\t\tif (h == 0 && w == 0) break;\n\t\tvector<string> r(h);\n\t\tfor (int i = 0; i < h; i++) cin >> r[i];\n\t\tcin >> s;\n\t\tfor (int i = 0; i < h; i++) {\n\t\t\tfor (int j = 0; j < w; j++) {\n\t\t\t\tcode[r[i][j]][0] = i;\n\t\t\t\tcode[r[i][j]][1] = j;\n\t\t\t}\n\t\t}\n\t\tfor (int i = 0; i < s.length(); i++) {\n\t\t\tans += abs(code[s[i]][0] - before[0]);\n\t\t\tans += abs(code[s[i]][1] - before[1]) + 1;\n\t\t\tmemcpy(before, code[s[i]], sizeof(before));\n\t\t}\n\t\tcout << ans << \"\\n\";\n\t}\n\treturn 0;\n}\n"
  },
  {
    "language": "C++",
    "code": "#include<iostream>\n#include<string>\n#include<algorithm>\n#include<vector>\n#include<queue>\n#include<map>\n#include<math.h>\n#include<iomanip>\n#include<set>\n#include<numeric>\n#include<cstring>\n#include<cstdio>\n#include<functional>\n#include<bitset>\n#include<limits.h>\n#include<cassert>\n#include<iterator>\n#include<complex>\n#include<stack>\n#include<sstream>\n#include<iterator>\n#include<list>\n\nusing namespace std;\n\ntypedef  long long int lint;\n\n#define rep(i, n) for (lint i = 0; i < n; i++)\n#define sort(v) sort((v).begin(), (v).end())\n#define reverse(v) reverse((v).begin(), (v).end())\n#define upper(v,hoge) upper_bound(v.begin(),v.end(),hoge)\n#define lower(v,hoge) lower_bound(v.begin(),v.end(),hoge)\n#define llower(v,hoge) *lower_bound(v.begin(), v.end(), hoge)\n#define lupper(v,hoge) *upper_bound(v.begin(), v.end(), hoge)\n#define mp make_pair\n#define IP pair<int,int>\n#define enld endl\n\nint main() {\n\tlint H, W;\n\twhile (cin >> H >> W, H != 0 && W != 0) {\n\t\tvector<vector<char>>A(H, vector<char>(W));\n\t\trep(i, H) {\n\t\t\trep(j, W) {\n\t\t\t\tcin >> A[i][j];\n\t\t\t}\n\t\t}\n\t\tmap<char, lint>X;\n\t\tmap<char, lint>Y;\n\t\trep(i, H) {\n\t\t\trep(j, W) {\n\t\t\t\tif (A[i][j] != '_') {\n\t\t\t\t\tX[A[i][j]] = i;\n\t\t\t\t\tY[A[i][j]] = j;\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t\tstring S;\n\t\tcin >> S;\n\t\tlint ans = 0;\n\t\trep(i, S.size()) {\n\t\t\tif (i == 0) {\n\t\t\t\tans += X[S[i]];\n\t\t\t\tans += Y[S[i]];\n\t\t\t}\n\t\t\telse {\n\t\t\t\tans += abs(X[S[i - 1]] - X[S[i]]);\n\t\t\t\tans += abs(Y[S[i - 1]] - Y[S[i]]);\n\t\t\t}\n\t\t}\n\t\tans += S.size();\n\t\tcout << ans << endl;\n\t}\n}\n"
  },
  {
    "language": "C++",
    "code": "#include <iostream>\n#include <cstring>\n#include <cstdlib>\n#include <cmath>\n#include <algorithm>\n#include <functional>\n#include <vector>\n#include <list>\n#include <queue>\n#include <deque>\n#include <stack>\n#include <map>\n#include <set>\n#include <bitset>\n#include <fstream>\nusing namespace std;\ntypedef long long ll;\ntypedef unsigned long long ull;\ntypedef pair<ll,ll> P;\ntypedef vector<int> vi;\ntypedef vector<ll> vll;\ntypedef vector<char> vc;\ntypedef vector<string> vs;\ntypedef vector<P> vp;\n#define rep(i,a,n) for(ll i = (a);i < (n);i++)\n#define per(i,a,n) for(ll i = (a);i > (n);i--)\n#define lep(i,a,n) for(ll i = (a);i <= (n);i++)\n#define pel(i,a,n) for(ll i = (a);i >= (n);i--)\n#define clr(a,b) memset((a),(b),sizeof(a))\n#define pb push_back\n#define all(c) (c).begin(),(c).end()\n#define sz size()\n#define endl \"\\n\"\n#define print(X) cout << (X) << \"\\n\"\n// // #define input(X) getline(cin,X)\nstatic const ll  INF = 1e9+7;\nstatic const ll INFL = 1e18+7;\nll n,m,l, p;\nstring s,t;\nll d[200010],e[200010],dp[1001][1001];\nchar field[202][202];\n\nint x = 0,y = 0;\n\nvector<P> get(char c){\n\tvector<P> ans;\n\trep(i,0,n){\n\t\trep(j,0,m){\n\t\t\tif(field[i][j] == c)ans.pb(P{i,j});\n\t\t}\n\t}\n\treturn ans;\n}\n\nint calc(vector<P> vec){\n\tP now;\n\tint ans = INF;\n\trep(i,0,vec.sz){\n\t\tP point = vec[i];\n\t\tint l = abs(x-point.first)+abs(y-point.second) + 1;\n\t\tif(l < ans){\n\t\t\tnow = point;\n\t\t\tans = l;\n\t\t}\n\t}\n\n\tx = now.first;\n\ty = now.second;\n\treturn ans;\n}\n\nint solve(){\n\tint ans = 0;\n\trep(i,0,s.sz){\n\t\tvector<P> points = get(s[i]);\n\t\tans += calc(points);\n\t}\n\treturn ans;\n}\n\nint main(){\n\twhile(cin >> n >> m, n){\n\t\tint ans = 0;\n\t\tx = y = 0;\n\n\t\trep(i,0,n)cin >> field[i];\n\t\tcin >> s;\n\t\tprint(solve());\n\t}\n\treturn 0;\n}\n"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\nusing namespace std;\nint main(){\n  while(1){\n  long long n,m;\n    cin >> n >> m;\n    if(n==0ll and m==0ll) break;\n    char c[n][m];\n    string s;\n    map<char, pair<int, int> > mp;\n    for(int i=0;i<n;i++){\n      for(int j=0;j<m;j++){\n        cin >> c[i][j];\n        mp[c[i][j]]=make_pair(i,j);\n      }\n    }\n    cin >> s;\n    long long x=0,y=0,ans=0;\n    for(size_t i=0;i<s.size();i++){\n      ans+=abs(mp[s[i]].first-x)+abs(mp[s[i]].second-y)+1;\n      x=mp[s[i]].first;\n      y=mp[s[i]].second;\n    }\n    cout << ans << endl;\n  }\n  return 0;\n}\n\n"
  },
  {
    "language": "C++",
    "code": "#include<iostream>\n#include<vector>\nusing namespace std;\n\nint main(){\n    int h, w;\n    while(cin >> h >> w, h){\n        vector<string> r(h);\n        for(int i = 0 ; i < h ; ++i){\n            cin >> r[i];\n        }\n\n        string s;\n        cin >> s;\n\n        int y = 0, x = 0;\n        int ans = 0;\n        for(auto c : s){\n            for(int i = 0 ; i < h ; ++i){\n                for(int j = 0 ; j < w ; ++j){\n                    if(r[i][j] == c){\n                        ans += abs(i - y) + abs(j - x) + 1;\n                        y = i;\n                        x = j;\n                    }\n                }\n            }\n        }\n\n        cout << ans << endl;\n    }\n\n    return 0;\n}\n"
  },
  {
    "language": "C++",
    "code": "#include <iostream>\n#include <vector>\n#include <algorithm>\n#include <string>\n#include <numeric>\n\n#define REP(i, a, b) for (int i = int(a); i < int(b); i++)\nusing namespace std;\ntypedef long long int ll;\n\n// clang-format off\n#ifdef _DEBUG_\n#define dump(...) do{ cerr << __LINE__ << \":\\t\" << #__VA_ARGS__ << \" = \"; PPPPP(__VA_ARGS__); cerr << endl; } while(false)\ntemplate<typename T> void PPPPP(T t) { cerr << t; }\ntemplate<typename T, typename... S> void PPPPP(T t, S... s) { cerr << t << \", \"; PPPPP(s...); }\n#else\n#define dump(...)\n#endif\ntemplate<typename T> vector<T> make_v(size_t a, T b) { return vector<T>(a, b); }\ntemplate<typename... Ts> auto make_v(size_t a, Ts... ts) { return vector<decltype(make_v(ts...))>(a, make_v(ts...)); }\n    // clang-format on\n\n#include <utility>\nusing P = pair<int, int>;\n\nint main() {\n    cin.tie(nullptr);\n    ios::sync_with_stdio(false);\n    int h, w;\n    while (cin >> h >> w, h + w) {\n        P pos[128];\n        REP(i, 0, h) {\n            string s;\n            cin >> s;\n            REP(j, 0, s.size()) {\n                pos[s[j]] = make_pair(i, j);\n            }\n        }\n        string s;\n        cin >> s;\n        P p(0, 0);\n        int ans = 0;\n        for (auto c : s) {\n            ans += abs(p.first - pos[c].first) + abs(p.second - pos[c].second) + 1;\n            p = pos[c];\n        }\n        cout << ans << endl;\n    }\n    return 0;\n}\n\n"
  },
  {
    "language": "C++",
    "code": "// https://atcoder.jp/contests/agc037/submissions/6956246\n#include<bits/stdc++.h>\nusing namespace std;\ntypedef long long ll;\n#define F first\n#define S second\n#define pii pair<int, int>\n#define eb emplace_back\n#define all(v) v.begin(), v.end()\n#define rep(i, n) for (int i = 0; i < (n); ++i)\n#define rep3(i, l, n) for (int i = l; i < (n); ++i)\n#define chmax(a, b) a = (a >= b ? a : b)\n#define chmin(a, b) a = (a <= b ? a : b)\n#define sz(v) (int)v.size()\n#define inf (int)(1e9+7)\n#define ceil(a, b) a / b + !!(a % b)\nll pow(ll a, int b) { return b ? pow(a * a, b / 2) * (b % 2 ? a : 1) : 1; }\ntemplate<typename T> T gcd(T a, T b) { if (b == 0) return a; return gcd(b, a % b); }\n\nint dx[4] = {-1, 0, 1, 0};\nint dy[4] = {0, 1, 0, -1};\n\nint main() {\n    ios::sync_with_stdio(false);\n    cin.tie(0);\n    \n    int h;\n    while (cin >> h && h) {\n        int w;\n        cin >> w;\n        char r[h][w];\n        rep(i, h) rep(j, w) cin >> r[i][j];\n        \n        string str;\n        cin >> str;\n        \n        int ans = 0;\n        \n        pii now = pii(0, 0);\n        rep(k, sz(str)) {\n            queue<pii> q;\n            q.push(now);\n            \n            int reached[h][w];\n            rep(i, h) rep(j, w) reached[i][j] = -1;\n            reached[now.F][now.S] = 0;\n            \n            while (!q.empty()) {\n                pii cur = q.front();\n                q.pop();\n                \n                rep(i, 4) {\n                    int ny = cur.F + dy[i];\n                    int nx = cur.S + dx[i];\n                    if (ny < 0 || ny >= h || nx < 0 || nx >= w || reached[ny][nx] != -1) continue;\n                    reached[ny][nx] = reached[cur.F][cur.S] + 1;\n                    q.push(pii(ny, nx));\n                }\n            }\n            \n            rep(i, h) rep(j, w) if (r[i][j] == str[k]) {\n                ans += reached[i][j] + 1;\n                now = pii(i, j);\n            }\n            \n            // cout << endl; rep(i, h) { rep(j, w) cout << reached[i][j] << \" \"; cout << endl; }\n            // cout << ans << endl;\n        }\n        \n        cout << ans << endl;\n    }\n}\n\n\n"
  },
  {
    "language": "C++",
    "code": "#include <iostream>\n#include <vector>\n#include <algorithm>\n#include <map>\nusing namespace std;\nint main(){\n    int h,w;\n    while(cin>>h>>w){\n        if(h+w == 0)break;\n        vector<string> v(h);\n        map<char,pair<int,int>> mp;\n        for(int i=0;i<h;i++)cin>>v[i];\n        for(int i=0;i<h;i++){\n            for(int j=0;j<w;j++){\n                mp[v[i][j]] = pair<int,int>(i,j);\n            }\n        }\n        string s;\n        cin>>s;\n        pair<int,int> now = pair<int,int>(0,0);\n        int ans=0;\n        for(int i=0;i<s.size();i++){\n            pair<int,int> next = mp[s[i]];\n            ans += abs(now.first-next.first)+abs(now.second-next.second);\n            now = next;\n        }\n        cout<<ans + s.size()<<endl;\n    }\n}\n"
  },
  {
    "language": "C++",
    "code": "#include<bits/stdc++.h>\nusing namespace std;\n\nint main(){\n          int h, w;\n          int n;\n          int i,j,k;\n          while(1){\n                    int ans=0;\n                    int x=0, y=0; //座標\n                    cin >> h >> w;\n                    if(!h&&!w) break;\n                    string keybord[55];\n                    string s;\n                    for(i=0;i<h;i++) cin >> keybord[i];\n                    cin >> s;\n\n                    for(i=0;i<s.length();i++){\n                              for(j=0;j<h;j++){\n                                     n=keybord[j].find(s[i]);\n                                     if(n>=0){\n                                        ans+=abs(x-n)+abs(y-j)+1;\n                                        x=n;\n                                        y=j;\n                                        break;\n                                     }\n                              }   \n                    } \n                    cout << ans << endl;\n                       \n          }\n}\n"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\n//typedef\n//-------------------------#include <bits/stdc++.h>\n \n#define M_PI       3.14159265358979323846\n \nusing namespace std;\n \n//conversion\n//------------------------------------------\ninline int toInt(string s) { int v; istringstream sin(s); sin >> v; return v; }\ntemplate<class T> inline string toString(T x) { ostringstream sout; sout << x; return sout.str(); }\ninline int readInt() { int x; scanf(\"%d\", &x); return x; }\n \n//typedef\n//------------------------------------------\ntypedef vector<int> VI;\ntypedef vector<VI> VVI;\ntypedef vector<string> VS;\ntypedef pair<int, int> PII;\ntypedef pair<long long, long long> PLL;\ntypedef pair<int, PII> TIII;\ntypedef long long LL;\ntypedef unsigned long long ULL;\ntypedef vector<LL> VLL;\ntypedef vector<VLL> VVLL;\n \n \n//container util\n \n//------------------------------------------\n#define ALL(a)  (a).begin(),(a).end()\n#define RALL(a) (a).rbegin(), (a).rend()\n#define PB push_back\n#define MP make_pair\n#define SZ(a) int((a).size())\n#define SQ(a) ((a)*(a))\n#define EACH(i,c) for(typeof((c).begin()) i=(c).begin(); i!=(c).end(); ++i)\n#define EXIST(s,e) ((s).find(e)!=(s).end())\n#define SORT(c) sort((c).begin(),(c).end())\n \n//repetition\n//------------------------------------------\n#define FOR(i,s,n) for(int i=s;i<(int)n;++i)\n#define REP(i,n) FOR(i,0,n)\n#define MOD 1000000007\n \n#define rep(i, a, b) for(int i = a; i < (b); ++i)\n#define trav(a, x) for(auto& a : x)\n#define all(x) x.begin(), x.end()\n#define sz(x) (int)(x).size()\n \ntypedef long long ll;\ntypedef pair<int, int> pii;\ntypedef vector<int> vi;\nconst double EPS = 1E-8;\n \n#define chmin(x,y) x=min(x,y)\n#define chmax(x,y) x=max(x,y)\n \nclass UnionFind {\npublic:\n    vector <ll> par; \n    vector <ll> siz; \n    \n    vector <ll> maxv;\n    UnionFind(ll sz_): par(sz_), siz(sz_, 1LL) {\n        for (ll i = 0; i < sz_; ++i) par[i] = i;\n    }\n    void init(ll sz_) {\n        par.resize(sz_);\n        siz.assign(sz_, 1LL);\n        for (ll i = 0; i < sz_; ++i) par[i] = i;\n    }\n \n    ll root(ll x) { \n        while (par[x] != x) {\n            x = par[x] = par[par[x]];\n        }\n        return x;\n    }\n \n    bool merge(ll x, ll y) {\n        x = root(x);\n        y = root(y);\n        if (x == y) return false;\n        if (siz[x] < siz[y]) swap(x, y);\n        siz[x] += siz[y];\n        par[y] = x;\n        return true;\n    }\n \n    bool issame(ll x, ll y) { \n        return root(x) == root(y);\n    }\n \n    ll size(ll x) { \n        return siz[root(x)];\n    }\n};\n \n \nll mod_pow(ll x, ll n, ll mod){\n    ll res = 1;\n    while(n){\n        if(n&1) res = (res * x)%mod;\n \n        res %= mod;\n        x = x * x %mod;\n        n >>= 1;\n    }\n    return res;\n}\n \n#define SIEVE_SIZE 5000000+10\nbool sieve[SIEVE_SIZE];\nvoid make_sieve(){\n    for(int i=0; i<SIEVE_SIZE; ++i) sieve[i] = true;\n    sieve[0] = sieve[1] = false;\n    for(int i=2; i*i<SIEVE_SIZE; ++i) if(sieve[i]) for(int j=2; i*j<SIEVE_SIZE; ++j) sieve[i*j] = false;\n}\n \nbool isprime(ll n){\n    if(n == 0 || n == 1) return false;\n    for(ll i=2; i*i<=n; ++i) if(n%i==0) return false;\n    return true;\n}\n \nconst int MAX = 2000010;\nlong long fac[MAX], finv[MAX], inv[MAX];\n \n// テーブルを作る前処理\nvoid COMinit() {\n    fac[0] = fac[1] = 1;\n    finv[0] = finv[1] = 1;\n    inv[1] = 1;\n    for (int i = 2; i < MAX; i++){\n        fac[i] = fac[i - 1] * i % MOD;\n        inv[i] = MOD - inv[MOD%i] * (MOD / i) % MOD;\n        finv[i] = finv[i - 1] * inv[i] % MOD;\n    }\n}\n \n// 二項係数計算\nlong long COM(int n, int k){\n    if (n < k) return 0;\n    if (n < 0 || k < 0) return 0;\n    return fac[n] * (finv[k] * finv[n - k] % MOD) % MOD;\n}\n \nlong long extGCD(long long a, long long b, long long &x, long long &y) {\n    if (b == 0) {\n        x = 1;\n        y = 0;\n        return a;\n    }\n    long long d = extGCD(b, a%b, y, x);\n    y -= a/b * x;\n    return d;\n}\n// 負の数にも対応した mod (a = -11 とかでも OK) \ninline long long mod(long long a, long long m) {\n    return (a % m + m) % m;\n}\n \n// 逆元計算 (ここでは a と m が互いに素であることが必要)\nlong long modinv(long long a, long long m) {\n    long long x, y;\n    extGCD(a, m, x, y);\n    return mod(x, m); // 気持ち的には x % m だが、x が負かもしれないので\n}\nll GCD(ll a, ll b){\n    \n    if(b == 0) return a;\n    return GCD(b, a%b);\n}\n \n \n \nstruct LazySegmentTree {\nprivate:\n    int n;\n    vector<ll> node, lazy;\n \npublic:\n    LazySegmentTree(vector<ll> v) {\n        int sz = (int)v.size();\n        n = 1; while(n < sz) n *= 2;\n        node.resize(2*n-1);\n        lazy.resize(2*n-1, 0);\n \n        for(int i=0; i<sz; i++) node[i+n-1] = v[i];\n        for(int i=n-2; i>=0; i--) node[i] = node[i*2+1] + node[i*2+2];\n    }\n \n    void eval(int k, int l, int r) {\n        if(lazy[k] != 0) {\n            node[k] += lazy[k];\n            if(r - l > 1) {\n                lazy[2*k+1] += lazy[k] / 2;\n                lazy[2*k+2] += lazy[k] / 2;\n            }\n            lazy[k] = 0;\n        }\n    }\n \n    void add(int a, int b, ll x, int k=0, int l=0, int r=-1) {\n        if(r < 0) r = n;\n        eval(k, l, r);\n        if(b <= l || r <= a) return;\n        if(a <= l && r <= b) {\n            lazy[k] += (r - l) * x;\n            eval(k, l, r);\n        }\n        else {\n            add(a, b, x, 2*k+1, l, (l+r)/2);\n            add(a, b, x, 2*k+2, (l+r)/2, r);\n            node[k] = node[2*k+1] + node[2*k+2];\n        }\n    }\n \n    ll getsum(int a, int b, int k=0, int l=0, int r=-1) {\n        if(r < 0) r = n;\n        eval(k, l, r);\n        if(b <= l || r <= a) return 0;\n        if(a <= l && r <= b) return node[k];\n        ll vl = getsum(a, b, 2*k+1, l, (l+r)/2);\n        ll vr = getsum(a, b, 2*k+2, (l+r)/2, r);\n        return vl + vr;\n    }\n};\n\nint const INF = INT_MAX;\n\nstruct SegmentTree {\nprivate:\n    int n;\n    vector<int> node;\n\npublic:\n    SegmentTree(vector<int> v) {\n        int sz = v.size();\n        n = 1; while(n < sz) n *= 2;\n        node.resize(2*n-1, INF);\n        for(int i=0; i<sz; i++) node[i+n-1] = v[i];\n        for(int i=n-2; i>=0; i--) node[i] = min(node[2*i+1], node[2*i+2]);\n    }\n\n    void update(int x, int val) {\n        x += (n - 1);\n        node[x] = val;\n        while(x > 0) {\n            x = (x - 1) / 2;\n            node[x] = min(node[2*x+1], node[2*x+2]);\n        }\n    }\n\n    int getmin(int a, int b, int k=0, int l=0, int r=-1) {\n        if(r < 0) r = n;\n        if(r <= a || b <= l) return INF;\n        if(a <= l && r <= b) return node[k];\n\n        int vl = getmin(a, b, 2*k+1, l, (l+r)/2);\n        int vr = getmin(a, b, 2*k+2, (l+r)/2, r);\n        return min(vl, vr);\n    }\n};\nusing Weight = int;\nusing Flow = int;\nstruct Edge {\n    int src, dst;\n    Weight weight;\n    Flow cap;\n    Edge() : src(0), dst(0), weight(0) {}\n    Edge(int s, int d, Weight w) : src(s), dst(d), weight(w) {}\n};\nusing Edges = std::vector<Edge>;\nusing Graph = std::vector<Edges>;\nusing Array = std::vector<Weight>;\nusing Matrix = std::vector<Array>;\n \nvoid add_edge(Graph &g, int a, int b, Weight w = 1) {\n    g[a].emplace_back(a, b, w);\n    g[b].emplace_back(b, a, w);\n}\nvoid add_arc(Graph &g, int a, int b, Weight w = 1) { g[a].emplace_back(a, b, w); }\n\n// template<typename T> class basic_stopwatch: T {\n//     typedef typename T BaseTimer;\n\n// public:\n//     explicit basic_stopwatch(bool start);\n//     explicit basic_stopwatch(char const* activity = \"Stopwatch\", bool start = true);\n//     basic_stopwatch(std::ostream& log, char const* activity = \"Stopwatch\", bool start = true);\n//     basic_stopwatch();\n//     unsigned LapGet() const;\n//     bool IsStarted() const;\n//     unsigned Show(char const* event = \"show\");\n//     unsigned Start(char const* event_name = \"start\");\n//     unsigned Stop(char const* event_name = \"stop\");\n// private:\n//     char const*     m_activity;\n//     unsigned        m_lap;\n//     std::ostream&   m_log;\n// };\n\n// #include <chrono>\n// using namespace std::chrono;\n// class TimerBase {\n// public: \n\n//     // タイマをクリアする\n//     TimerBase(): m_start(system_clock::time_point::min()) {}\n\n//     void Clear(){\n//         m_start = system_clock::time_point::min();\n//     }\n\n//     bool IsStarted() const {\n//         return (m_start.time_since_epoch() != system_clock::duration(0));\n//     }\n\n//     void Start() {\n//         m_start = system_clock::now();\n//     }\n\n//     unsigned long GetMs(){\n//         if(IsStarted()) {\n//             system_clock::duration diff;\n//             diff = system_clock::now() - m_start;\n//             return (unsigned)(duration_cast<milliseconds>(diff).const();\n//         }\n//         return 0;\n//     }\n// private:\n//     system_clock::time_point m_start;\n// };\nbool used[100010];\nint main() {\n    cin.tie(0);\n    ios::sync_with_stdio(false);\n    cout << fixed << setprecision(15);\n    \n    int h, w;\n    while(cin >> h >> w, h&&w){\n        vector<string> r(h);\n        REP(i,h) cin >> r[i];\n\n        string s; cin >> s;\n        int ans = 0;\n        int px=0, py=0;\n        char pkey=' ';\n        map<char, pair<int, int>> mp;\n        REP(i,h){\n            REP(j,w){\n                mp[r[i][j]] = make_pair(i, j);\n            }\n        }\n        for(int i=0; i<s.size(); i++){\n\n            //cout << s[i] <<  endl;\n            if(px == -1){\n                ans += mp[s[i]].first + mp[s[i]].second;\n                px = mp[s[i]].second;\n                py = mp[s[i]].first;\n                \n                \n            }else{\n                ans += abs(mp[s[i]].first-py) + abs(mp[s[i]].second-px);\n                px = mp[s[i]].second;\n                py = mp[s[i]].first;\n            }\n            ans++;\n\n            //cout << px << \" \" << py <<\" \" << ans << endl;\n        }\n        cout << ans << endl;\n    }\n    return 0;\n}\n"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\nusing namespace std;\n/*{{{*/  //template\n#define rep(i,n) for(int i=0;i<(int)(n);i++)\n#define rrep(i,n) for(int i=(n)-1;i>=0;i--)\nconstexpr int INF = numeric_limits<int>::max()/2;\nconstexpr long long LINF = numeric_limits<long long>::max()/3;\n#define pb push_back\n#define eb emplace_back\n#define fi first\n#define se second\n#define all(v) (v).begin(),(v).end()\n#define sz(x) (int)(x).size()\n#define debug(x) cerr<<#x<<\":\"<<x<<endl\n#define debug2(x,y) cerr<<#x<<\",\"<<#y\":\"<<x<<\",\"<<y<<endl\n//struct fin{ fin(){ cin.tie(0); ios::sync_with_stdio(false); } } fin_;\nstruct Double{ double d; explicit Double(double x) : d(x){} };\nostream& operator<<(ostream& os,const Double x){ os << fixed << setprecision(20) << x.d; return os; }\ntemplate<typename T> ostream& operator<<(ostream& os,const vector<T>& vec){ os << \"[\"; for(const auto& v : vec){ os << v << \",\"; } os << \"]\"; return os; }\ntemplate<typename T,typename U> ostream& operator<<(ostream& os, const map<T,U>& mp){ os << \"{\"; for(auto& p : mp){ os << p << \",\"; } os << \"}\"; return os; }\ntemplate<typename T,typename U> ostream& operator<<(ostream& os,const pair<T,U>& p){ os << \"(\" << p.first << \",\"<< p.second <<\")\"; return os; }\ntemplate<typename T> ostream& operator<<(ostream& os,const set<T>& st){ os<<\"{\"; for(T v:st) os<<v<<\",\"; os <<\"}\"; return os; }\ntemplate<typename T,typename U> inline void chmax(T &x,U y){ if(y>x) x = y; }\ntemplate<typename T,typename U> inline void chmin(T &x,U y){ if(y<x) x = y; }\nusing ll = long long;\nusing ull = unsigned long long;\nusing pii = std::pair<int,int>;\nusing vi = std::vector<int>;\ntypedef vector<vi> vvi;\nll gcd(ll a,ll b){ if(b==0) return a; else return gcd(b,a%b); }\nconstexpr ll TEN(int n) { return (n == 0) ? 1 : 10 * TEN(n - 1); }\n//constexpr double eps = 1e-14; \nconstexpr double eps = 1e-10; \nconstexpr ll mod = 1e9+7;\nconst int dx[]={1,0,-1,0} ,dy[] = {0,1,0,-1};\n/*}}}*/\n\nint main(){\n    while(1){\n        int h,w; cin >> h >> w;\n        if(h == 0 and w == 0) break;\n\n        map<char,pii> mp;\n        rep(i,h){\n            string s; cin >> s;\n            rep(j,w){\n                mp[s[j]] = pii(i,j);\n            }\n        }\n\n        string s; cin >> s;\n        int n = s.size();\n\n        int x,y;\n        x = 0;\n        y = 0;\n        int ans = 0;\n        rep(i,n){\n            int nx = mp[s[i]].first;\n            int ny = mp[s[i]].second;\n            ans += abs(nx-x);\n            ans += abs(ny-y);\n            x = nx;\n            y = ny;\n        }\n        ans += s.size();\n        cout << ans << endl;\n    }\n}\n\n"
  },
  {
    "language": "C++",
    "code": "#include<bits/stdc++.h>\nusing namespace std;\n\n#define rep(i,n) for(long long i = 0; i < n; i++)\n#define REP(i,s,n) for(long long i = (s); i <= (n); i++)\n#define repr(i,n) for(long long i = n - 1; i >= 0; i--)\n#define REPR(i,s,n) for(long long i = (s); i >= (n); i--)\n#define all(a) (a).begin(), (a).end()\n#define rall(a) (a).rbegin(), (a).rend()\n#define sumvec(v) accumulate(all(v), 0LL)\n#define pb push_back\n#define DOUBLE fixed << setprecision(15)\n#define OK cerr << \"OK\\n\"\n#define OK1 cerr << \"OK1\\n\"\n#define OK2 cerr << \"OK2\\n\"\n#define sz(s) (long long)s.size()\n#define INF ((1LL << 62) - (1LL << 31))\n#define zero(x, n) setw(x) << setfill('0') << n\n//#define endl '\\n'\n\ntypedef long long ll;\ntypedef long double ld;\ntypedef vector<int> vi;\ntypedef vector<long long> vll;\ntypedef vector<double> vd;\ntypedef vector<char> vc;\ntypedef vector<bool> vb;\ntypedef vector<string> vs;\ntypedef vector<vi> vvi;\ntypedef vector<vll> vvll;\ntypedef vector<vd> vvd;\ntypedef vector<vc> vvc;\ntypedef vector<vb> vvb;\ntypedef pair<ll,ll> P;\ntypedef vector<P> vP;\n\ntemplate<class A, class B>\nostream& operator<<(ostream& ost, const pair<A, B>&p) {\n    ost << \"{\" << p.first << \", \" << p.second << \"} \";\n    return ost;\n}\n\ntemplate<class T>\nostream& operator<<(ostream& ost, const vector<T>&v) {\n    ost << \"{\";\n    for (int i = 0; i<(int)v.size(); i++) {\n        if (i)ost << \" \";\n        ost << v[i];\n    }\n    ost << \"} \\n\";\n    return ost;\n}\n\ntemplate<class A, class B>\nostream& operator<<(ostream& ost, const map<A, B>&v) {\n    ost << \"{\";\n    for (auto p:v) {\n        ost << \"{\" << p.first << \", \" << p.second << \"} \";\n    }\n    ost << \"} \";\n    return ost;\n}\n\nvoid out(){cout << \"\\n\";}\ntemplate<class T,class... Args>\nvoid out(const T &x,const Args &... args){\n    cout << x << \" \";\n    out(args...);\n}\n\ntemplate<typename T>\nistream& operator >> (istream& is, vector<T>& vec){\n    for(T& e: vec) is >> e;\n    return is;\n}\n\ntemplate<typename T>\nstring join(vector<T>& vec, string sep=\" \"){\n    stringstream ss;\n    for(int i=0;i<(int)vec.size();i++){\n        ss << vec[i] << (i+1==(int)vec.size()?\"\\n\":sep);\n    }\n    return ss.str();\n}\n\ntemplate<class T>\ninline bool chmax(T& a, T b){if(a<b){a=b;return true;} return false;}\n\ntemplate<class T>\ninline bool chmin(T& a, T b){if(a>b){a=b;return true;} return false;}\n\n#define INT(...) int __VA_ARGS__;IN(__VA_ARGS__)\n#define LL(...) long long __VA_ARGS__;IN(__VA_ARGS__)\n#define CHR(...) char __VA_ARGS__;IN(__VA_ARGS__)\n#define DBL(...) double __VA_ARGS__;IN(__VA_ARGS__)\n#define STR(...) string __VA_ARGS__;IN(__VA_ARGS__)\n#define LD(...) long double __VA_ARGS__;IN(__VA_ARGS__)\n\nvoid scan(int& a){ cin >> a; }\nvoid scan(long long& a){ cin >> a; }\nvoid scan(char& a){ cin >> a; }\nvoid scan(double& a){ cin >> a; }\nvoid scan(string& a){ cin >> a; }\nvoid scan(long double& a){ cin >> a; }\n\nvoid IN(){}\ntemplate<class Head,class... Tail> void IN(Head& head,Tail&... tail){ scan(head); IN(tail...); }\n\nvoid YES(bool b) {cout << ((b)?\"YES\\n\":\"NO\\n\");}\nvoid Yes(bool b) {cout << ((b)?\"Yes\\n\":\"No\\n\");}\nvoid yes(bool b) {cout << ((b)?\"yes\\n\":\"no\\n\");}\nvoid Yay(bool b) {cout << ((b)?\"Yay!\\n\":\":(\\n\");}\n\nconst long double pi = acos(-1.0);\nconst ll mod=1000000007;\n//const ll mod=998244353;\n\nll powmod(ll a,ll b){ll c=1; while(b>0){ if(b&1){ c=a*c%mod; } a=a*a%mod; b>>=1; } return c;}\nll nCrmod(ll n,ll r){ll x=1,y=1; for(ll i=0;i<r;i++) {x=x*(n-i)%mod; y=y*(i+1)%mod; } return x*powmod(y,mod-2)%mod;}\nll gcd(ll a,ll b){ while(b){ ll c=b; b=a%b; a=c; } return a; }\nll lcm(ll a,ll b){ if(!a || !b) return 0; return a*b/gcd(a,b); }\nvll divisor(ll x){ vll v; for(int i=1;i*i<=x;i++)if(x%i==0){ v.pb(i);if(i*i!=x)v.pb(x/i); } sort(all(v)); return v; };\nmap<ll,ll> prime_factor(ll n){ map<ll,ll> m; for(ll i=2;i*i<=n;i++){ while(n%i==0){ m[i]++; n/=i; } } if(n!=1) m[n]=1; return m; }\n\nint main()\n{\n    ll h, w;\n    while(cin >> h >> w, h && w) {\n        map<char, P> m;\n        rep(i, h)rep(j, w){\n            CHR(c);\n            m[c] = {i, j};\n        }\n        STR(s);\n        ll ans = 0;\n        P now = {0, 0};\n        for(auto&& e : s) {\n            P next = m[e];\n            ans += abs(now.first - next.first) + abs(now.second - next.second) + 1;\n            now = next;\n        }\n        cout << ans << endl;\n    }\n    return 0;\n}\n\n"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\nusing namespace std;\nusing Int = long long;\nint PREP = (cin.tie(nullptr), ios::sync_with_stdio(false), cout << fixed << setprecision(9), 0);\n//int SEGV = getenv(\"D\") || (exit(system(\"D= SEGFAULT_SIGNALS=all catchsegv ./prog.exe\") >> 8), 0);\nint main() {\n    for (;;) {\n        int H, W; cin >> H >> W;\n        if (H == 0 && W == 0) break;\n        vector<string> R(H); for (auto &r : R) cin >> r;\n        map<char, pair<int, int>> M;\n        for (int i = 0; i < H; i++) {\n            for (int j = 0; j < W; j++) {\n                M[R[i][j]] = make_pair(i, j);\n            }\n        }\n        string S; cin >> S;\n        int i = 0, j = 0;\n        int ans = 0;\n        for (auto &c : S) {\n            int k, l; tie(k, l) = M[c];\n            ans += abs(i - k) + abs(j - l) + 1;\n            i = k, j = l;\n        }\n        cout << ans << '\\n';\n    }\n    return 0;\n}\n\n"
  },
  {
    "language": "C++",
    "code": "#include<bits/stdc++.h>\nusing namespace std;\nmain(){\n    int h,w;\n    cin >> h >> w;\n    while(h != 0){\n    vector<vector<char> > scr(h,vector<char>(w));\n\n    for(int i = 0;i<h;i++){\n        for(int j = 0;j<w;j++){\n            cin >> scr.at(i).at(j);\n        }\n    }\n\n    string s;\n    cin >> s;\n    \n    int bx=0;int by=0;\n    // for(int i = 0;i<h;i++){\n    //     for(int j = 0;j<w;j++){\n    //         if(scr.at(i).at(j) == s[0]){\n    //             bx=i;by=j;\n    //         }\n    //     }\n    // }\n\n\n\n    int ans = 0;\n\n    for(int n = 0;n<s.length();n++){\n        for(int i = 0;i<h;i++){\n        for(int j = 0;j<w;j++){\n            if(scr.at(i).at(j) == s[n]){\n                ans += abs(bx-i) + abs(by-j) +1;\n                bx=i;by=j;\n            }\n        }\n    }\n      \n    }\n    cout << ans << endl;\n    cin >> h >> w;\n    }\n     \n    \n\n\n}\n"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\nusing namespace std;\n#define min(a,b) ((a)<(b)?(a):(b))\n#define max(a,b) ((a)>(b)?(a):(b))\n#define REP(i,n) for(ll i=0;i<n;i++)\n#define FOR(i,n1,n2) for(ll i=n1;i<n2;i++)\n#define bFOR(i,n1,n2) for(ll i=n1;i>=n2;i--)\n#define speed_up    ios_base::sync_with_stdio(false); cin.tie(0); cout.tie(0);\ntypedef long long int ll;\ntypedef pair<ll,ll> Pi;\ntypedef tuple<ll,ll,ll> Tu;\nconst int INF=(ll)(1LL<<30)-1;\nconst double INFd=100000000000.0;\nconst double PI=3.14151926535;\nconst ll INFl=(ll)9223372036854775807;\nconst int MAX=10000;\nconst ll MOD=(ll)1e9+7;\nconst ll tMOD=(ll)998244353;\nll gcd(ll a,ll b){return b?gcd(b,a%b):a;}\nll lcm(ll a,ll b){return a/gcd(a, b)*b;}\nint dx[4]={0,-1,0,1},dy[4]={-1,0,1,0};\nint mdx[8]={0,1,0,-1,1,1,-1,-1},mdy[8]={-1,0,1,0,1,-1,1,-1};\n\n\ntemplate<typename A, size_t N, typename T>\nvoid Fill(A (&array)[N], const T &val){\n    std::fill( (T*)array, (T*)(array+N), val );\n}\n\nint main(){\n    while(1){\n        int h,w;\n        cin>>h>>w;\n        if(h+w==0)break;\n        Pi c[1000];\n        REP(i,h){\n            REP(j,w){\n                char t;\n                cin>>t;\n                if(t=='_')continue;\n                c[t]=Pi{i,j};\n            }\n        }\n        int ans=0;\n        string s;\n        cin>>s;\n        int t1=0,t2=0;\n        REP(i,s.size()){\n            ans+=(abs(c[s[i]].first-t1)+abs(c[s[i]].second-t2));\n            t1=c[s[i]].first;\n            t2=c[s[i]].second;\n        }\n        cout<<ans+s.size()<<endl;\n    }\n    return 0;\n}\n"
  },
  {
    "language": "C++",
    "code": "#include <iostream>\nusing namespace std;\nint main(void){\n  for(;;){\n    int h, w;\n    cin >> h >> w;\n    if(h == 0 && w == 0){ return 0; }\n    string r[h];\n    for(int i=0;i<h;i++){\n      cin >> r[i];\n    }\n    string s;\n    cin >> s;\n\n    // Constructing a mapping from character to coordiante:\n    // c |-> (x[c], y[c]) \n    int x[128]; int y[128];\n    for(int i=0;i<h;i++){\n      for(int j=0;j<w;j++){\n\tx[r[i][j]] = i;\n\ty[r[i][j]] = j;\n      }\n    }\n\n    int tempx = 0; int tempy = 0;\n    int d=0;\n    for(int i=0;i<s.length();i++){\n      d += abs(x[s[i]] - tempx) + abs(y[s[i]] - tempy) + 1;\n      tempx = x[s[i]]; tempy = y[s[i]];\n    }\n\n    cout << d << endl;\n  }\n}\n\n"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\nusing namespace std;\n \ntypedef long long ll;\ntypedef double D;\ntypedef vector<int> VI;\ntypedef vector<ll> VL;\ntypedef pair<int,int> PII;\ntypedef pair<ll,ll> PLL;\n \n#define rd(x) scanf(\"%d\",&x)\n#define rd2(x,y) scanf(\"%d %d\",&x,&y)\n#define rl(x) scanf(\"%lld\",&x)\n#define rl2(x,y) scanf(\"%lld %lld\",&x,&y)\n#define wd(x) printf(\"%d\" ,x)\n#define wd2(x,y) printf(\"%d %d\",x,y)\n#define wl(x) printf(\"%lld\",x)\n#define wl2(x,y) printf(\"%lld %lld\",x,y)\n#define PC(x) putchar(x)\n#define GC() getchar()\n#define NL printf(\"\\n\")\n#define SP printf(\" \")\n \n#define F first\n#define S second\n#define MP make_pair\n#define PB push_back\n\n#define fastio ios_base::sync_with_stdio(false);cin.tie(0);cout.tie(0);\n#define fast_cin() ios_base::sync_with_stdio(false); cin.tie(NULL)\n#define fr(i,s,e) for(int i=s;i<e;i++)\n#define frl(i,s,e) for(ll i=s;i<e;i++)\n#define frr(i,s,e) for(int i=s-1;i>=e;i--)\n#define frv(i,a) for(int i = 0;i<(int)a.size();i++)\n#define frvr(i,a) for(int i = a.size()-1;i>=0;i--)\n#define tr(i,a) for(typeof(a.begin()) i = a.begin(); i != a.end();i++)\n\n#define mod 1000000007\n#define maxn 100009\n#define maxr 100009\nint main(){\n\tll h,w;\n\twhile(rl2(h,w),h,w)\n\t{\n\t\tif(h==0&&w==0)\n\t\t\tbreak;\n\t\tchar key[50][50];\n\t\tmap<char,PII>mp;\n\t\tfr(i,0,h)\n\t\t\tfr(j,0,w)\n\t\t\t{\n\t\t\t\tcin>>key[i][j];\n\t\t\t\tmp[key[i][j]]=MP(i,j);\n\t\t\t}\n\t\tstring str;\n\t\tcin>>str;\n\t\tll ct=0;\n\t\tPII pk=MP(0,0);\n\t\tfr(i,0,str.size())\n\t\t{\n\t\t\tPII tp=mp[str[i]];\n\t\t\tct+=abs(pk.F-tp.F)+abs(pk.S-tp.S)+1;\n\t\t\tpk=tp;\n\t\t}\n\t\twl(ct);\n\t\tNL;\n\t}\n\n\treturn 0;\n}\n\n\n"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\n#define rep(i,n) for(int (i)=0;i < (n);(i)++)\n#define ll long long\n\nusing namespace std;\n\n// input\nint h,w;\nchar field[52][52];\nstring query;\n\n\nint main()\n{\n  cin.tie(0);\n  ios::sync_with_stdio(false);\n  \n  while(true) {\n    cin >> h >> w;\n    if(h == 0) break;\n    rep(i,h) rep(j,w) cin >> field[i][j];\n    cin >> query;\n    \n    int p_x = 0,p_y = 0;\n    int ans = 0;\n    rep(i,query.length()) {\n      char target = query[i];\n      rep(y,h) rep(x,w) {\n        if(field[y][x] == target) {\n          ans += abs(x-p_x) + abs(y - p_y) + 1;\n          p_y = y; p_x = x;\n        }\n      }\n    }\n    cout << ans << endl;\n  }\n\n}\n"
  },
  {
    "language": "C++",
    "code": "#include <iostream>\n#include <vector>\n#include <algorithm>\n#include <set>\n#include <math.h>\nusing namespace std;\ntypedef long long int ll;\n\nint main(){\n\tcin.tie(nullptr);\n\tios::sync_with_stdio(false);\n\tint n,m;\n\twhile(1){\n\t\tcin >> n >> m;\n\t\tif(n==0&&m==0)break;\n\t\tpair<int,int> p[100];\n\t\tvector<string> s(n);\n\t\tfor(int i=0;i<n;i++){\n\t\t\tcin >> s[i];\n\t\t}\n\t\tstring t; cin >> t;\n\t\t// 座圧パート\n\t\tvector<char> v;\n\t\tfor(int i=0;i<t.size();i++){\n\t\t\tv.push_back(t[i]);\n\t\t}\n\t\tfor(int i=0;i<n;i++){\n\t\t\tfor(int j=0;j<m;j++){\n\t\t\t\tif(s[i][j]!='_')v.push_back(s[i][j]);\n\t\t\t}\n\t\t}\n\t\tsort(v.begin(),v.end());\n\t\tv.erase(unique(v.begin(),v.end()),v.end());\n\t\t// 座圧終了\n\t\tvector<int> a(t.size());\n\t\tfor(int i=0;i<t.size();i++){\n\t\t\ta[i]=(lower_bound(v.begin(),v.end(),t[i])-v.begin());\n\t\t}\n\t\tfor(int i=0;i<n;i++){\n\t\t\tfor(int j=0;j<m;j++){\n\t\t\t\tif(s[i][j]!='_'){\n\t\t\t\t\tp[lower_bound(v.begin(),v.end(),s[i][j])-v.begin()]=make_pair(i,j);\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t\tint ans=p[a[0]].first+p[a[0]].second+1;\n\t\tfor(int i=1;i<t.size();i++){\n\t\t\tans+=abs(p[a[i]].first-p[a[i-1]].first)+abs(p[a[i-1]].second-p[a[i]].second)+1;\n\t\t}\n\t\tcout << ans << endl;\n\t}\n}\n"
  },
  {
    "language": "C++",
    "code": "#include <iostream>\n#include<bits/stdc++.h>\nusing namespace std;\nint n,m,a,b,ans;\nstring t,s[50];\nint main(void){\n    while(1){\n    cin>>n>>m;\n    if(n==0&&m==0)return 0;\n    map<char,int> mpx,mpy;\n    for(int i=0;i<n;i++){\n        cin>>s[i];\n        for(int j=0;j<m;j++){\n            if(s[i][j]=='_')continue;\n            mpx[s[i][j]]=i;\n            mpy[s[i][j]]=j;\n        }\n    }\n    a=0;b=0;\n    ans=0;\n    cin>>t;\n    for(int i=0;i<t.size();i++){\n        ans+=abs(mpx[t[i]]-a)+abs(mpy[t[i]]-b);\n        a=mpx[t[i]],b=mpy[t[i]];\n    }\n    cout<<ans+t.size()<<endl;\n    }\n}\n\n"
  },
  {
    "language": "C++",
    "code": "#include <algorithm>\n#include <bitset>\n#include <complex>\n#include <deque>\n#include <exception>\n#include <fstream>\n#include <functional>\n#include <iomanip>\n#include <ios>\n#include <iosfwd>\n#include <iostream>\n#include <istream>\n#include <iterator>\n#include <limits>\n#include <list>\n#include <locale>\n#include <map>\n#include <memory>\n#include <new>\n#include <numeric>\n#include <ostream>\n#include <queue>\n#include <set>\n#include <sstream>\n#include <stack>\n#include <stdexcept>\n#include <streambuf>\n#include <string>\n#include <typeinfo>\n#include <utility>\n#include <valarray>\n#include <vector>\n#include <climits>\n#include <cstring>\n\n#define rep(i, m, n) for(int i=int(m);i<int(n);i++)\n#define all(c) begin(c),end(c)\n\ntemplate<typename T1, typename T2>\ninline void chmin(T1 &a, T2 b) { if (a > b) a = b; }\n\ntemplate<typename T1, typename T2>\ninline void chmax(T1 &a, T2 b) { if (a < b) a = b; }\n\ntypedef long long int ll;\nusing ll = long long int;\nusing ull = long long unsigned int;\nusing Int = long long int;\nusing namespace std;\n#define INF (1 << 30) - 1\n#define INFl (ll)5e15\n#define DEBUG 0\n#define dump(x)  cerr << #x << \" = \" << (x) << endl\n#define MOD 1000000007\n\n\n//edit\nclass Solve {\npublic:\n    bool solve() {\n        Int H, W;\n        cin >> H >> W;\n        if (H == 0) return false;\n        map<char, pair<Int, Int>> mp;\n\n        for (int i = 0; i < H; ++i) {\n            for (int j = 0; j < W; ++j) {\n                char c;\n                cin >> c;\n                mp[c] = make_pair(i, j);\n            }\n        }\n        string s;\n        cin >> s;\n        Int ans = 0;\n        Int h = 0, w = 0;\n        auto dist = [&](Int nh, Int nw) {\n            return abs(nh - h) + abs(w - nw);\n        };\n\n        for (auto e : s) {\n            auto p = mp[e];\n            Int nh = p.first;\n            Int nw = p.second;\n            Int d = dist(nh, nw);\n            h = nh;\n            w = nw;\n            ans += d + 1;\n        }\n        cout << ans << endl;\n\n        return true;\n    }\n\n};\n\n\nint main() {\n    cin.tie(0);\n    ios::sync_with_stdio(false);\n    cout << fixed << setprecision(10);\n    while (Solve().solve());\n\n    return 0;\n}\n\n"
  },
  {
    "language": "C++",
    "code": "#include <iostream>\n#include <vector>\n#include <algorithm>\nusing namespace std;\n\nint main(){\n    while(1){\n        int h,w;\n        cin >> h >> w;\n        if(h == 0) break;\n\n        vector<int> posy(256), posx(256);\n        for(int i=0; i<h; i++){\n            string s;\n            cin >> s;\n            for(int j=0; j<w; j++){\n                posy[s[j]] = i;\n                posx[s[j]] = j;\n            }\n        }\n        string s;\n        cin >> s;\n        int y=0, x=0;\n        int ans = 0;\n        for(char c: s){\n            int p = c;\n            ans += abs(posy[p]-y);\n            ans += abs(posx[p]-x);\n            ans++;\n            y = posy[p];\n            x = posx[p];\n        }\n        cout << ans << endl;\n    }\n    return 0;\n}\n"
  },
  {
    "language": "C++",
    "code": "#include <cstdlib>\n#include <iostream>\n#include <vector>\n\nusing namespace std;\n\nbool solve() {\n  int h, w;\n  cin >> h >> w;\n  if (h == 0 && w == 0) {\n    return false;\n  }\n  vector<string> r(h);\n  for (auto &i : r) {\n    cin >> i;\n  }\n  string s;\n  cin >> s;\n  int p = 0, q = 0, result = 0;\n  for (char c : s) {\n    for (int i = 0; i < h; ++i) {\n      for (int j = 0; j < w; ++j) {\n        if (c == r[i][j]) {\n          result += abs(p - i) + abs(q - j) + 1;\n          p = i;\n          q = j;\n        }\n      }\n    }\n  }\n  cout << result << endl;\n  return true;\n}\n\nint main() {\n  while (solve()) {\n  }\n}\n\n"
  },
  {
    "language": "C++",
    "code": "#include <cmath>\n#include <iostream>\n#include <map>\n#include <string>\n#include <utility>\n#include <vector>\nusing namespace std;\n\nint main() {\n  while (true) {\n    int h, w;\n    cin >> h >> w;\n    if (h == 0 && w == 0)\n      break;\n    vector<string> r(h);\n    for (int i = 0; i < h; ++i)\n      cin >> r[i];\n    string s;\n    cin >> s;\n\n    map<char, pair<int, int>> m;\n    for (int i = 0; i < h; ++i)\n      for (int j = 0; j < w; ++j)\n        if (r[i][j] != '_')\n          m[r[i][j]] = make_pair(i, j);\n\n    int pi = 0, pj = 0, ans = 0;\n    for (int k = 0; k < s.size(); ++k) {\n      ans += abs(m[s[k]].first - pi) + abs(m[s[k]].second - pj) + 1;\n      pi = m[s[k]].first, pj = m[s[k]].second;\n    }\n\n    cout << ans << endl;\n  }\n}\n"
  },
  {
    "language": "C++",
    "code": "#include<bits/stdc++.h>\ntypedef long long int ll;\ntypedef unsigned long long int ull;\n#define BIG_NUM 2000000000\n#define HUGE_NUM 99999999999999999\n#define MOD 1000000007\n#define EPS 0.000000001\nusing namespace std;\n\n\n#define SIZE 1005\n\nstruct LOC{\n\n\tint row,col;\n};\n\nstruct Info{\n\tInfo(int arg_row,int arg_col,char arg_ch){\n\t\tloc.row = arg_row;\n\t\tloc.col = arg_col;\n\t\tch = arg_ch;\n\t}\n\n\tLOC loc;\n\tchar ch;\n};\n\nint H,W;\nint info_index[128],min_dist[128][128];\nchar table[55][55],buf[SIZE];\nvector<Info> V;\n\n\nvoid func(){\n\n\tV.clear();\n\n\tfor(int row = 0; row < H; row++){\n\n\t\tscanf(\"%s\",table[row]);\n\t\tfor(int col = 0; col < W; col++){\n\n\t\t\tif(table[row][col] == '_')continue;\n\n\t\t\tinfo_index[table[row][col]] = V.size(); //文字からインデックスを調べる表\n\t\t\tV.push_back(Info(row,col,table[row][col]));\n\t\t}\n\t}\n\n\tscanf(\"%s\",buf);\n\n\tfor(int i = 0; i < V.size()-1; i++){\n\t\tfor(int k = i; k < V.size(); k++){\n\n\t\t\tmin_dist[V[i].ch][V[k].ch] = abs(V[i].loc.row-V[k].loc.row)+abs(V[i].loc.col-V[k].loc.col);\n\t\t\tmin_dist[V[k].ch][V[i].ch] = min_dist[V[i].ch][V[k].ch];\n\t\t}\n\t}\n\n\tint ans = V[info_index[buf[0]]].loc.row+V[info_index[buf[0]]].loc.col+1;\n\n\tchar pre = buf[0];\n\n\tfor(int i = 1; buf[i] != '\\0'; i++){\n\n\t\tans += min_dist[pre][buf[i]]+1;\n\t\tpre = buf[i];\n\t}\n\n\tprintf(\"%d\\n\",ans);\n}\n\nint main(){\n\n\twhile(true){\n\n\t\tscanf(\"%d %d\",&H,&W);\n\t\tif(H == 0 && W == 0)break;\n\n\t\tfunc();\n\t}\n\n\treturn 0;\n}\n\n"
  },
  {
    "language": "C++",
    "code": "#include <cstdlib>\n#include <iostream>\n#include <string>\n#include <utility>\n#include <vector>\nusing namespace std;\n\nint main() {\n\tint h, w;\n\twhile (cin >> h >> w, h && w) {\n\t\tvector<string> r(h);\n\t\tfor (string& i : r) cin >> i;\n\t\tstring s;\n\t\tcin >> s;\n\t\tint ans = s.size();\n\t\tpair<int, int> a;\n\t\tfor (char& i : s) {\n\t\t\tpair<int, int> b;\n\t\t\tfor (int j = 0; j < h; ++j) {\n\t\t\t\tfor (int k = 0; k < w; ++k) {\n\t\t\t\t\tif (i == r[j][k]) {\n\t\t\t\t\t\tb.first = j;\n\t\t\t\t\t\tb.second = k;\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t}\n\t\t\tans += abs(a.first - b.first) + abs(a.second - b.second);\n\t\t\ta = b;\n\t\t}\n\t\tcout << ans << endl;\n\t}\n}\n"
  },
  {
    "language": "C++",
    "code": "#include <iostream>\n#include <algorithm>\n#include <math.h>\n#include <vector>\n#include <queue>\nusing namespace std;\ntypedef long long ll;\n\nint main() {\n    int h, w;\n    while (cin >> h >> w) {\n        if (h == 0) return 0;\n        string r[100], s;\n        int x[200], y[200];\n        for (int i = 0; i < h; i++) {\n            cin >> r[i];\n            for (int j = 0; j < w; j++) {\n                if (char(r[i][j]) != '_') {\n                    x[int(r[i][j])] = i;\n                    y[int(r[i][j])] = j;\n                }\n            }\n        }\n        cin >> s;\n        \n        int ans = x[int(s[0])] + y[int(s[0])] + 1;\n        for (int i = 0; i < s.size() - 1; i++) {\n            ans += abs(x[int(s[i + 1])] - x[int(s[i])]) + abs(y[int(s[i + 1])] - y[int(s[i])]) + 1;\n        }\n        cout << ans << endl;\n    }\n    \n}\n"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\nusing namespace std;\ntypedef long long ll;\nconst ll inf = 100100100100100;\nconst ll mod = 1000000007;\nint dy[4]={-1,0,1,0},dx[4]={0,-1,0,1};\ntypedef pair<int,int> P;\n#define fi first\n#define se second\nint main(){\nint n,m;\n   while(cin>>n>>m){\n   if(n==0||m==0)return 0;\n   vector<vector<char>> a(n,vector<char>(m));\n   for(int i=0;i<n;i++)for(int j=0;j<m;j++)cin>>a.at(i).at(j);\n   string s;\n   cin>>s;\n   P pos={0,0};\n   int count=0;\n   vector<vector<int>>b(n,vector<int>(m,0));\n   for(int i=0;i<s.size();i++){\n        vector<vector<int>>b(n,vector<int>(m,0));\n       queue<P> q;\n       q.push(pos);\n       while(!q.empty()){\n            P np=q.front();\n            q.pop();\n            if(a[np.fi][np.se]==s.at(i)){pos=np;break;}\n            for(int i=0;i<4;i++){\n               int ny=np.fi+dy[i];\n               int nx=np.se+dx[i];\n               if(ny<0||ny>=n||nx<0||nx>=m)continue;\n               if(b[ny][nx]!=0)continue;\n               b[ny][nx]=b[np.fi][np.se]+1;\n               q.push(P(ny,nx));\n         }\n       }\n       count+=b[pos.fi][pos.se];\n   }\n   count+=(int)s.size();\n   cout<<count<<endl;\n   }\n}\n"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\n\nusing namespace std;\nusing i64 = long long;\n\nbool solve(){\n    int n,m;cin >> n >> m;\n    if(n == 0)return 0;\n    vector<string> vec;\n    for(int i = 0;i < n;i++){\n        string s;cin >> s;\n        vec.push_back(s);\n    }\n    string s;cin >> s;\n    long long ans = 0;\n    pair<int,int> now = make_pair(0, 0);\n    for(int i = 0;i < s.size();i++){\n        bool t = false;\n        for(int j = 0;j < n;j++){\n            for(int k = 0;k < m;k++){\n                if(vec.at(j).at(k) == s.at(i)){\n                    t = true;\n                    ans += abs(now.first - j);\n                    ans += abs(now.second - k);\n                    now = make_pair(j, k);\n                    break;\n                }\n            }\n            if(t)break;\n        }\n    }\n    cout<<ans+s.size()<<endl;\n    return true;\n}\n\nsigned main()\n{\n    while(solve());\n    return 0;\n}\n"
  },
  {
    "language": "C++",
    "code": "#include <cstdio>\n#include <cstring>\n#include <string>\n#include <iostream>\n#include <algorithm>\n#include <queue>\nusing namespace std;\nstatic const int INFTY = 2501;\nstring imap[51];\nstring str;\nint d[51][51];\nint dx[4] = {-1, 1, 0, 0};\nint dy[4] = {0, 0, -1, 1};\nint h, w;\nint x, y;\n\nint bfs(const int &idx) {\n    for (int i = 0; i < h; i++) fill(d[i], d[i]+w, INFTY);\n    queue<pair<int, int> > q;\n    pair<int, int> p;\n    d[x][y] = 0;\n    int nx, ny, sum = 0;\n    q.push({x, y});\n    while (!q.empty()) {\n        p = q.front(); q.pop();\n        if (imap[p.first][p.second] == str[idx]) { x = p.first, y = p.second; sum = d[p.first][p.second]; break; }\n        for (int i = 0; i < 4; i++) {\n            nx = p.first+dx[i], ny = p.second+dy[i];\n            if (nx >= 0 && nx < h && ny >= 0 && ny <= w && d[nx][ny] == INFTY) {\n                d[nx][ny] = d[p.first][p.second]+1;\n                q.push({nx, ny});\n            }\n        }\n    }\n    return sum;\n}\n\n\n\nint main(void){\n    for(; ;) {\n        cin >> h >> w;\n        if (h == 0 && w==0) break;\n        for (int i = 0; i < h; i++) {\n            cin >> imap[i];\n        }\n        cin >> str;\n        x = y = 0;\n        int sum = 0;\n\n        for (int i = 0; i < str.size(); i++) {\n            if (str[i] != imap[x][y]) sum+=bfs(i)+1;\n            else sum+=1;\n        }\n        printf(\"%d\\n\", sum);\n    }\n    return 0;\n}\n\n"
  },
  {
    "language": "C++",
    "code": "#include<iostream>\n#include<map>\nusing namespace std;\n\nint main(){\n    int h, w;\n    while(cin >> h >> w, h+w){\n        map<char, pair<int,int>> m;\n        for(int i = 0; i < h; i++){\n            for(int j = 0; j < w; j++){\n                char c; cin >> c;\n                if(c == '_')    continue;\n                m[c] = {i,j};\n            }\n        }\n        string s;\n        cin >> s;\n        int i = 0, j = 0, ans = s.length();\n        for(char c : s) ans += abs(m[c].first-i)+abs(m[c].second-j), i = m[c].first, j = m[c].second;\n        cout << ans << endl;\n    }\n    return 0;\n}\n"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\nusing namespace std;\n\nstruct data {\n  int x, y, id, cnt;\n};\n\nlong long h, w, n;\nint d[4] = {1, 0, -1, 0};\nvector<string> r;\nstring s;\nqueue<data> qu;\nbool memo[55][55][1005] = {0};\n\nbool isvalid(const data &now) {\n  return now.x >= 0 && now.x < h && now.y >= 0 && now.y < w;\n}\n\nlong long solve();\n\nint main() {\n  while(1) {\n    cin >> h >> w;\n    if(h + w == 0) break;\n    r.resize(h);\n    for(int i = 0; i < h; ++i) cin >> r[i];\n    cin >> s;\n    n = s.size();\n    cout << solve() << endl;\n  }\n  return 0;\n}\n\nlong long solve() {\n  while(!qu.empty()) qu.pop();\n  for(int i = 0; i < h; ++i)\n    for(int j = 0; j < w; ++j)\n      for(int k = 0; k <= n; ++k) memo[i][j][k] = 0;\n  qu.push({0, 0, 0, 0});\n  while(!qu.empty()) {\n    data now = qu.front();\n    qu.pop();\n    ++now.cnt;\n    if(r[now.x][now.y] == s[now.id]) {\n      ++now.id;\n      memo[now.x][now.y][now.id] = 1;\n      if(now.id == n) return now.cnt;\n      qu.push(now);\n      continue;\n    }\n    for(int i = 0; i < 4; ++i) {\n      data nextp = now;\n      nextp.x += d[i];\n      nextp.y += d[i ^ 1];\n      if(isvalid(nextp) &&\n         !memo[nextp.x][nextp.y][nextp.id]) {\n        memo[nextp.x][nextp.y][nextp.id] = 1;\n        qu.push(nextp);\n      }\n    }\n  }\n  return -1;\n}\n"
  },
  {
    "language": "C++",
    "code": "#include <iostream>\n#include <cstdlib>\n#include <string>\n\nusing namespace std;\n\nclass ScreenKeyboard {\nprivate:\n  char m_key[50][50];\n  int m_count;\n  int m_width, m_height;\n  struct Position {\n    int x;\n    int y;\n  };\n  Position m_position;\n\n  void findKey(char key, Position &pos)\n  {\n    for (int i = 0; i < m_width; i++) {\n      for (int j = 0; j < m_height; j++) {\n        if (m_key[i][j] == key) {\n          pos.x = i;\n          pos.y = j;\n        }\n      }\n    }\n  }\n\npublic:\n  ScreenKeyboard(int width, int height) : m_count(0), m_position(),\n                                          m_width(width), m_height(height)\n  {\n    for (int i = 0; i < width; i++) {\n      for (int j = 0; j < height; j++) {\n        m_key[i][j] = '_';\n      }\n    }\n  }\n\n  ~ScreenKeyboard()\n  {\n  }\n\n  void setKey(char key, int x, int y)\n  {\n    m_key[x][y] = key;\n  }\n\n  void moveKey(char key)\n  {\n    Position pos;\n    findKey(key, pos);\n    m_count += abs(m_position.x - pos.x) + abs(m_position.y - pos.y) + 1;\n    m_position.x = pos.x;\n    m_position.y = pos.y;\n  }\n\n  int getCount()\n  {\n    return m_count;\n  }\n};\n\nint main()\n{\n  int h, w;\n  \n  while (1) {\n    cin >> h >> w;\n    if (h == 0 && w == 0) return 0;\n    cin.ignore();\n    ScreenKeyboard* screenKeyboard = new ScreenKeyboard(h, w);\n    string keyString[50];\n    string inString;\n    for (int i = 0; i < h; i++) {\n      getline(cin, keyString[i]);\n      for (int j = 0; j < keyString[i].size(); j++) {\n        screenKeyboard->setKey(keyString[i][j], i, j);\n      }\n    }\n    getline(cin, inString);\n    for (int i = 0; i < inString.size(); i++) {\n      screenKeyboard->moveKey(inString[i]);\n    }\n    cout << screenKeyboard->getCount() << endl;\n    delete screenKeyboard;\n  }\n}\n\n"
  },
  {
    "language": "C++",
    "code": "//ICPC B\n#include <bits/stdc++.h>\nusing namespace std;\nusing ll=long long;\nconst ll mod=1e9+7;\n\nint main(){\n    vector<int> answers;\n    while(1){\n        int h,w;\n        cin>>h>>w;\n        if(h==0&&w==0) break;\n        string r;\n        pair<int,int> pos[256];\n        for(int i=0;i<h;i++){\n            cin>>r;\n            for(int j=0;j<w;j++){\n                if(r[j]!='_') pos[r[j]]={i,j};\n            }\n        }\n        string s;\n        cin>>s;\n        int x=0,y=0;\n        int ans=s.length();\n        for(int i=0;i<s.length();i++){\n            ans+=abs(y-pos[s[i]].first)+abs(x-pos[s[i]].second);\n            y=pos[s[i]].first;\n            x=pos[s[i]].second;\n        }\n        answers.push_back(ans);\n    }\n\n    for(auto ans:answers){\n        cout<<ans<<endl;\n    }\n    return 0;\n}\n\n"
  },
  {
    "language": "C++",
    "code": "#include <iostream>\n#include <cmath>\nusing namespace std;\n\nint h, w;\nchar a[51][51], b[1001];\n\nint main()\n{\n\tcin >> h >> w;\n\n\twhile (h != 0 && w != 0) {\n\t\tint t = 0, pi = 0, pj = 0;\n\n\t\tfor (int i = 0; i < h; i++)\n\t\t\tfor (int j = 0; j < w; j++)\n\t\t\t\tcin >> a[i][j];\n\n\t\tcin >> b;\n\n\t\tfor (int k = 0; b[k] != '\\0'; k++) {\n\t\t\tbool f = 0;\n\t\t\tfor (int i = 0; i < h; i++) {\n\t\t\t\tfor (int j = 0; j < w; j++) {\n\t\t\t\t\tif (a[i][j] == b[k]) {\n\t\t\t\t\t\tt += abs(pi - i) + abs(pj - j) + 1;\n\t\t\t\t\t\tpi = i;\n\t\t\t\t\t\tpj = j;\n\t\t\t\t\t\tf = 1;\n\t\t\t\t\t\tbreak;\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t\tif (f)\n\t\t\t\t\tbreak;\n\t\t\t}\n\t\t}\n\n\t\tcout << t << endl;\n\n\t\tcin >> h >> w;\n\t}\n\n\treturn 0;\n}\n"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\nusing namespace std;\ntypedef long long ll;\nconst int maxn = 1e5 + 5;\nconst ll mod = 1e9 + 7;\nconst ll p = 137;\nint h, w;\nchar g[55][55], s[1005];\nint x[305], y[305];\nint main() {\n    while(scanf(\"%d%d\", &h, &w) != EOF) {\n        if(h == 0 && w == 0) break;\n        for(int i = 0; i < h; ++i) {\n            scanf(\"%s\", g[i]);\n            for(int j = 0; j < w; ++j) {\n                int id = (int)g[i][j];\n                x[id] = i, y[id] = j;\n            }\n        }\n        scanf(\"%s\", s);\n        int len = strlen(s);\n        int px = 0, py = 0, ans = 0;\n        for(int i = 0; i < len; ++i) {\n            int id = (int) s[i];\n            ans += abs(px - x[id]) + abs(py - y[id]) + 1;\n            px = x[id], py = y[id];\n        }\n        printf(\"%d\\n\", ans);\n    }\n    return 0;\n}\n"
  },
  {
    "language": "C++",
    "code": "#include<iostream>\n#include<cmath>\n#include<string>\n#include<map>\nusing namespace std;\nmap<char, pair<int, int>>m;\nstring s;\nsigned main() {\n\tint h, w, x, y, ans;\n\twhile (cin >> h >> w, h) {\n\t\tm.clear(); x = 0; y = 0; ans = 0;\n\t\tfor (int i = 0; i < h; i++) {\n\t\t\tcin >> s;\n\t\t\tfor (int j = 0; j < w; j++)if (s[j] != '_')m[s[j]] = make_pair(i, j);\n\t\t}\n\t\tcin >> s;\n\t\tfor (int i = 0; i < s.size(); i++) {\n\t\t\tans += abs(x - m[s[i]].first) + abs(y - m[s[i]].second);\n\t\t\tx = m[s[i]].first; y = m[s[i]].second;\n\t\t}cout << ans+s.size() << endl;\n\t}\n}\n"
  },
  {
    "language": "C++",
    "code": "#include<bits/stdc++.h>\nusing namespace std;\n#define fs first\n#define sc second\n#define pb push_back\n#define mp make_pair\n#define eb emplace_back\n#define ALL(A) A.begin(),A.end()\n#define RALL(A) A.rbegin(),A.rend()\ntypedef long long LL;\ntypedef pair<int,int> P;\nconst LL mod=1000000007;\nconst LL LINF=1LL<<60;\nconst int INF=1<<30;\nint dx[]={1,0,-1,0};\nint dy[]={0,1,0,-1};\n\n\n\nint main(){\n    int h,r;\n    while(cin >> h >> r,h){\n        vector<string> s(h);\n        for (int i = 0; i < h; i++) {\n            cin >> s[i];\n        }\n        string t;cin >> t;\n        int y=0,x=0;\n        int ans=0;\n        for (int k = 0; k < t.length(); k++) {\n            bool f=false;\n            for (int i = 0; i < h; i++) {\n                if(f) break;\n                for (int j = 0; j < r; j++) {\n                    if(s[i][j]==t[k]){\n                        ans+=abs(i-y)+abs(j-x);\n                        x=j,y=i;\n                        f=true;\n                        break;\n                    }\n                }\n            }\n        }\n        cout << ans+t.length() << endl;\n    }\n    return 0;\n}\n\n"
  },
  {
    "language": "C++",
    "code": "#include <iostream>\n#include <string>\n#include <algorithm>\n\nusing namespace std;\n\nint main(){\n    while(1){\n        int px = 0, py = 0,t = 0; \n        int h,w; cin >> h >> w;\n        if(!h&&!w) break;\n        string cell[55];\n\n        for(int i = 0; i < h; i++){\n            cin >> cell[i];\n        }\n\n        string str; cin >> str ;\n\n        for(int x = 0; x < str.length(); x++){\n            for(int j  = 0; j < h; j++){\n                int find = 0;\n                for(int i = 0; i < w; i++){\n                    if(cell[j][i] == str[x]){\n                        t += abs(j - py) + abs(i - px) + 1;\n                        px = i;\n                        py = j;\n                        find = 1;\n                        break;\n                    }\n                }\n                if(find) break;\n            }\n        }\n\n        cout << t << endl;\n\n    }\n    return 0;\n}\n\n"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\n#include <type_traits>\nusing namespace std;\n\nusing ll = long long;\n\n#define rep(i, n) for (int i = 0; i < (n); ++i)\n#define rrep(i, n) for (int i = 1; i <= (n); ++i)\n#define drep(i, n) for (int i = (n)-1; i >= 0; --i)\n#define ddrep(i, n) for (int i = n; i > 0; --i)\n#define srep(i, s, t) for (int i = s; i < t; ++i)\n#define ssrep(i, s, t) for (int i = s; i <= t; ++i)\n\n#define rng(a) a.begin(), a.end()\n#define rrng(a) a.rbegin(), a.rend()\n#define pb push_back\n#define eb emplace_back\n#define fi first\n#define se second\n\n#define chmax(x, y) (x = max(x, y))\n#define chmin(x, y) (x = min(x, y))\n\nusing pi = pair<int, int>;\nusing vi = vector<int>;\nusing vvi = vector<vi>;\nusing vl = vector<ll>;\nusing vvl = vector<vl>;\nusing ld = long double;\n\ntemplate <class T, class U>\nostream &operator<<(ostream &os, const pair<T, U> &p) {\n  os << \"(\" << p.first << \",\" << p.second << \")\";\n  return os;\n}\n\ntemplate <class T> ostream &operator<<(ostream &os, const vector<T> &v) {\n  os << \"{\";\n  rep(i, (int)v.size()) {\n    if (i)\n      os << \",\";\n    os << v[i];\n  }\n  os << \"}\";\n  return os;\n}\n\ntemplate <typename T, size_t S> void printArray(const T (&array)[S]) {\n  for (auto val : array)\n    std::cout << val << \", \";\n  std::cout << \"\\n\";\n}\n\nconst int mod = 1e9 + 7;\nconst int inf = 1e9 + 5;\n\nvoid solve(int h, int w) {\n  vector<string> key(h); rep(i, h) std::cin >> key[i];\n  string in; std::cin >> in;\n  map<char, int> cp;\n  rep(i, h) rep(j, w) {\n    cp[key[i][j]] = i*w+j;\n  }\n  int x = 0, y = 0;\n  ll ans = 0;\n  for (auto &c : in) {\n    int nx = cp[c] % w, ny = cp[c] / w;\n    int dx = abs(nx - x), dy = abs(ny - y);\n    ans += dx + dy + 1;\n    x = nx, y = ny;\n  }\n  std::cout << ans << \"\\n\";\n}\n\nint main() {\n  cin.tie(0);\n  ios::sync_with_stdio(false);\n  cout << std::setprecision(10);\n\n  while (1) {\n    int h, w; std::cin >> h >> w;\n    if (h == 0 && w == 0) break;\n    solve(h, w);\n  }\n}\n\n"
  },
  {
    "language": "C++",
    "code": "#include <stdio.h>\n#include <string.h>\n#include <math.h>\n#define MAX 1000\nint n,m;\nchar  a[51][51],c[MAX];\nint pos[MAX][2];\nint main()\n{\n    while(scanf(\"%d%d\",&n,&m)&&(m||n))\n    {\n        for(int i=0; i<n; i++)\n        {\n            getchar();\n            for(int j=0; j<m; j++)\n                scanf(\"%c\",&a[i][j]);\n        }\n        getchar();\n       scanf(\"%s\",c);\n        int len=strlen(c);\n        for(int i=0; i<len; i++)\n        {\n            for(int j=0; j<n; j++)\n                for(int k=0; k<m; k++)\n                    if(a[j][k]==c[i])\n                    {\n                        pos[i][0]=j;\n                        pos[i][1]=k;\n                        break;\n                    }\n        }\n        int sum=pos[0][0]+pos[0][1];\n        for(int i=1; i<len; i++)\n            sum+=fabs(pos[i][0]-pos[i-1][0])+fabs(pos[i][1]-pos[i-1][1]);\n            printf(\"%d\\n\",sum+len);\n        }\n         return 0;\n}\n\n\n"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\n\n#define int long long\n#define REP(i, l, r) REPEAT(i,l,r,true) // [l, r)\n#define rep(i, n) REP(i,0,n)           // [0, n)\n#define REPEAT(i, l, r, condition) for(int i=(condition)?l:r-1;(condition)?i<r:i>=l;(condition)?++i:--i) // false<-[l, r)->true\n#define all(e) e.begin(),e.end()\n#define rall(e) e.rbegin(),e.rend()\n#define pb push_back\n#define fs first\n#define sc second\n#ifdef LOCAL\n#define show(...) cerr<<#__VA_ARGS__<<\" = \";_DEBUG(__VA_ARGS__)\n#define showlr(n, l, r) cerr<<#n<<\" = \";for(int i=l;i<r;i++){cerr<<n[i]<<\", \";}cerr<<endl // [l, r)\n#else\n#define show(...) true\n#define showlr(n,l,r) true\n#endif\n\n#define YN(condition) puts((condition)?\"YES\":\"NO\")\n#define Yn(condition) puts((condition)?\"Yes\":\"No\")\n#define yn(condition) puts((condition)?\"yes\":\"no\")\n#define YES puts(\"YES\")\n#define Yes puts(\"Yes\")\n#define yes puts(\"yes\")\n#define NO  puts(\"NO\")\n#define No  puts(\"No\")\n#define no  puts(\"no\")\n\n#define case(i) printf(\"Case #%lld: \",i)\n\nusing namespace std;\n\nusing vi=vector<int>;\nusing pint=pair<int, int>;\n\nstruct io {\n    io() {\n        cin.tie(0);\n        ios::sync_with_stdio(false);\n        cout.tie(0);\n        cout << fixed << setprecision(20);\n    }\n} io;\n\ntemplate<class T>\nistream &operator>>(istream &is, vector<T> &v) {\n    for (T &e:v)is >> e;\n    return is;\n}\n\ntemplate<class T>\nostream &operator<<(ostream &os, vector<T> v) {\n    os << \"{\";\n    for (T &e:v)os << e << (v.size() - (int) (&e - &v[0]) > 1 ? \", \" : \"\");\n    os << \"}\";\n    return os;\n}\n\nvoid _DEBUG() {}\n\ntemplate<typename H, typename... T>\nvoid _DEBUG(H a, T...b) {\n    cerr << a << (sizeof...(b) ? \",\" : \"\\n\");\n    _DEBUG(b...);\n}\n\ninline void in() {}\n\ntemplate<typename H, typename... T>\nvoid in(H &a, T &... b) {\n    cin >> a;\n    in(b...);\n}\n\ninline void out() {}\n\ntemplate<typename H, typename... T>\nvoid out(H a, T... b) {\n    cout << a << (sizeof...(b) ? \" \" : \"\\n\");\n    out(b...);\n}\n\ntemplate<class T>\nvoid resz(int n, T &v) { v.resize(n); }\n\ntemplate<class H, class... T>\nvoid resz(int n, H &a, T &... b) {\n    a.resize(n);\n    resz(n, b...);\n}\n\ntemplate<typename V, typename H>\nvoid resize(vector<V> &v, const H a) { v.resize(a); }\n\ntemplate<typename V, typename H, typename... T>\nvoid resize(vector<V> &v, const H &a, const T... b) {\n    v.resize(a);\n    for (auto &v:v) resize(v, b...);\n}\n\nconst int INF = 1LL << 55;\nconst int MOD = 1000000007;\nconst double EPS = 1e-8;\n\n/*------------end of definitions------------*/\n\nint H, W;\n\nvoid solve() {\n    map<char, pint> M;\n    rep(i, H) {\n        rep(j, W) {\n            char c;\n            in(c);\n            M[c] = {i, j};\n        }\n    }\n    vector<pint> V;\n    V.pb({0, 0});\n    string S;\n    in(S);\n    int ans = S.size();\n    for_each(all(S), [&V, &M](char c) { V.pb(M[c]); });\n\n    REP(i, 1, V.size()) {\n        ans += abs(V[i - 1].first - V[i].first) + abs(V[i - 1].second - V[i].second);\n    }\n    out(ans);\n}\n\nsigned main() {\n\n    while (in(H, W), H) {\n        solve();\n    }\n\n    return 0;\n}\n\n"
  },
  {
    "language": "C++",
    "code": "#define _CRT_SECURE_NO_WARNINGS\n#include <cstdio>\n#include <cstdlib>\n#include <climits>\nusing namespace std;\n\nstatic int mx[CHAR_MAX];\nstatic int my[CHAR_MAX];\nstatic char s[1024];\n\n\nint main(int argc, char* argv[])\n{\n\tfor (;;) {\n\t\tint h, w;\n\t\tint x, y;\n\t\tint result;\n\n\t\tscanf(\" %d %d\", &h, &w);\n\t\tif (w == 0 && h == 0) {\n\t\t\tbreak;\n\t\t}\n\t\tfor (int i = 0; i < h; ++i) {\n\t\t\tchar r[64];\n\n\t\t\tscanf(\" %s\", r);\n\t\t\tfor (int j = 0; r[j] != '\\0'; ++j) {\n\t\t\t\tmx[r[j]] = j;\n\t\t\t\tmy[r[j]] = i;\n\t\t\t}\n\t\t}\n\n\t\tscanf(\" %s\", s);\n\t\tx = y = 0;\n\t\tresult = 0;\n\t\tfor (int i = 0; s[i] != '\\0'; ++i) {\n\t\t\tresult += abs(mx[s[i]] - x) + abs(my[s[i]] - y) + 1;\n\t\t\tx = mx[s[i]];\n\t\t\ty = my[s[i]];\n\t\t}\n\t\tprintf(\"%d\\n\", result);\n\t}\n\n\treturn EXIT_SUCCESS;\n}\n\n"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\n\n#define REP(i,n) for (int i=0;i<(n);++i)\n\nusing namespace std;\n\nusing pii = pair<int, int>;\n\nint distance(pii p, pii q) {\n    return abs(p.first - q.first) + abs(p.second - q.second);\n}\n\nint main() {\n    while (true) {\n        int h, w;\n        cin >> h >> w;\n        if (h == 0)\n            break;\n        map<char, pii> position;\n        REP(i, h) {\n            string r;\n            cin >> r;\n            REP(j, w) {\n                position[r[j]] = pii(i, j);\n            }\n        }\n        string s;\n        cin >> s;\n        int count_presses = 0;\n        pii current_position = pii(0, 0);\n        for (char c: s) {\n            pii next_position = position[c];\n            count_presses += distance(current_position, next_position) + 1;\n            current_position = next_position;\n        }\n        cout << count_presses << endl;\n    }\n    return 0;\n}\n"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\nusing namespace std;\n\nusing Int = long long;\nusing ll = long long;\n\ntemplate<class T1, class T2> inline void chmin(T1 &a, T2 b){if(a > b) a = b;}\ntemplate<class T1, class T2> inline void chmax(T1 &a, T2 b){if(a < b) a = b;}\n\nint dp[52][52][1010];\nsigned main(){\n  cin.tie(0);\n  ios::sync_with_stdio(0);\n\n  int h,w;\n  while(cin>>h>>w,h||w){\n    vector<string> vs(h);\n    for(int i=0;i<h;i++) cin>>vs[i];\n    string st;\n    cin>>st;\n\n    memset(dp,-1,sizeof(dp));\n    using T = tuple<int, int, int>;\n    queue<T> que;\n    dp[0][0][0]=0;\n    que.emplace(0,0,0);\n\n    int dy[]={0,0,1,-1};\n    int dx[]={1,-1,0,0};\n    auto in=[&](int y,int x){return 0<=y&&y<h&&0<=x&&x<w;};\n\n    while(!que.empty()){\n      T cur=que.front();que.pop();\n      int y,x,p;\n      tie(y,x,p)=cur;\n\n      if(vs[y][x]==st[p]){\n        int ny=y,nx=x,np=p+1;\n        if(!in(ny,nx)) continue;\n        if(~dp[ny][nx][np]) continue;\n        dp[ny][nx][np]=dp[y][x][p]+1;\n        if(np==(int)st.size()){\n          cout<<dp[ny][nx][np]<<endl;\n          break;\n        }\n        que.emplace(ny,nx,np);\n      }\n\n      for(int k=0;k<4;k++){\n        int ny=y+dy[k],nx=x+dx[k],np=p;\n        if(!in(ny,nx)) continue;\n        if(~dp[ny][nx][np]) continue;\n        dp[ny][nx][np]=dp[y][x][p]+1;\n        que.emplace(ny,nx,np);\n      }\n    }\n  }\n\n  return 0;\n}\n\n"
  },
  {
    "language": "C",
    "code": "#include<stdio.h>\n#include<stdlib.h>\nint main(void){\n    while(1){\n        char x[50][50];\n        char y[1000];\n        int h, w;\n        scanf(\"%d%d\",&h,&w);\n        if(h==0) break;\n        for(int i=0;i<h;i++)\n        scanf(\"%s\",x[i]);\n        scanf(\"%s\",y);\n        //printf(\"%s\\n\",y);\n        int nh=0, nw=0;\n        int t = 0;\n        for(int i=0;y[i]!='\\0';i++){\n            for(int j=0;j<h;j++){\n                for(int k=0;k<w;k++){\n                    if(x[j][k]==y[i]){\n                        t += abs(nh-j)+abs(nw-k)+1;\n                        nh = j; nw = k;\n                    }\n                }\n            }\n        }\n        printf(\"%d\\n\",t);\n    }\n}\n\n"
  },
  {
    "language": "C",
    "code": "#include <stdio.h>\n#include <stdlib.h>\n\nint h, w;\nchar r[64][64];\nchar s[1024];\n\nint pos[256][2];\n\nint main(void) {\n\twhile (scanf(\"%d%d\", &h, &w) == 2 && (h|w) != 0) {\n\t\tint i, j;\n\t\tint mizuhasu = 0;\n\t\tfor (i = 0; i < h; i++) {\n\t\t\tif (scanf(\"%63s\", r[i]) != 1) return 1;\n\t\t}\n\t\tif (scanf(\"%1022s\", s + 1) != 1) return 1;\n\t\tfor (i = 0; i < h; i++) {\n\t\t\tfor (j = 0; j < w; j++) {\n\t\t\t\tint idx = (unsigned char)r[i][j];\n\t\t\t\tpos[idx][0] = i;\n\t\t\t\tpos[idx][1] = j;\n\t\t\t}\n\t\t}\n\t\tfor (i = 1; s[i] != '\\0'; i++) {\n\t\t\tint current = (unsigned char)s[i], prev = (unsigned char)s[i - 1];\n\t\t\tmizuhasu += abs(pos[current][0] - pos[prev][0]) + abs(pos[current][1] - pos[prev][1]) + 1;\n\t\t}\n\t\tprintf(\"%d\\n\", mizuhasu);\n\t}\n\treturn 0;\n}\n\n"
  },
  {
    "language": "C",
    "code": "// AOJ 1633 On-Screen Keyboard\n// bal4u 2019.8.12\n\n#include <stdio.h>\n\n//// 入出力関係\n#if 1\n#define gc() getchar_unlocked()\n#define pc(c) putchar_unlocked(c)\n#else\n#define gc() getchar()\n#define pc(c) putchar(c)\n#endif\n\nint in() {   // 非負整数の入力\n\tint n = 0, c = gc();\n\tdo n = 10 * n + (c & 0xf); while ((c = gc()) >= '0');\n\treturn n;\n}\n\nvoid ins(char *s) { // 文字列の入力　スペース以下の文字で入力終了\n\tdo *s = gc();\n\twhile (*s++ > ' ');\n\t*(s-1) = 0;\n}\n\nvoid out(int n) { // 正整数の表示（出力）\n\tint i; char b[20];\n\ti = 0; while (n) b[i++] = n % 10 + '0', n /= 10;\n\twhile (i--) pc(b[i]);\n\tpc('\\n');\n}\n\n//// 本問題関連\n#define ABS(x) ((x)>=0?(x):-(x))\nint ch[128][2];\nchar s[1005];\n\t\t\nint main()\n{\n\tint h, w, r, c, ans;\n\tchar *p;\n\t\n\twhile (h = in()) {\n\t\tw = in();\n\t\tfor (r = 0; r < h; r++) {\n\t\t\tfor (c = 0; c < w; c++) {\n\t\t\t\tint a = gc();\n\t\t\t\tch[a][0] = r, ch[a][1] = c;\n\t\t\t}\n\t\t\tgc();\n\t\t}\n\t\tins(s), ans = 0, r = c = 0;\n\t\tfor (p = s; *p; p++) {\n\t\t\tans += 1 + ABS(ch[*p][0] - r) + ABS(ch[*p][1] - c);\n\t\t\tr = ch[*p][0], c = ch[*p][1];\n\t\t}\n\t\tout(ans);\n\t}\n\treturn 0;\n}\n"
  },
  {
    "language": "C",
    "code": "//2020.1.22\n//s1270188 xxxmk2\n//icpc_2019 pre2\n\n#include<stdio.h>\n#define N 50\n#define LONG 1000\n\n//global\nchar data[N][N+1], input[LONG+1];\nint x, y, h, w;\n\n//prototype\nint find(char,int,int);\n\nint main(){\n  int i, sum;\n\n  while(1){\n    //input\n    scanf(\"%d %d\",&h,&w);\n    if(h==0 && w==0) break;\n    for(i=0;i<h;i++) scanf(\" %s\",data[i]);\n    scanf(\" %s\",input);\n\n    //count\n    for(i=sum=x=y=0;input[i]!='\\0';i++) sum+=find(input[i],x,y);\n    \n    //output\n    printf(\"%d\\n\",sum);\n  }\n  \n  return 0;\n}\n\n\n\nint find(char a,int xx,int yy){\n  int i, j, cnt=0;\n\n  for(i=0;i<h;i++){\n    for(j=0;j<w;j++) if(data[i][j]==a) break;\n    if(j<w) break;\n  }\n\n  if(xx<i) cnt+=i-xx;\n  else cnt+=xx-i;\n\n  if(yy<j) cnt+=j-yy;\n  else cnt+=yy-j;\n\n  x=i;\n  y=j;\n  \n  return cnt+1;\n}\n\n"
  },
  {
    "language": "Java",
    "code": "import java.util.*;\n\npublic class Main {\n    public static void main(String[] args) throws Exception {\n        Scanner in = new Scanner(System.in);\n        \n        while (in.hasNextLine()) {\n            int R = in.nextInt();\n            int C = in.nextInt();\n            if (R == 0 && C == 0) break;\n            \n            HashMap<Character, Loc> hm = new HashMap<Character, Loc>();\n            \n            for (int i = 0; i < R; i++) {\n                String str = in.next();\n                for (int j = 0; j < C; j++) {\n                    char c = str.charAt(j);\n                    if (c == '_') continue;\n                    hm.put(c, new Loc(i, j));\n                }\n            }\n            \n            String str = in.next();\n            \n            int iPos = 0;\n            int jPos = 0;\n            int count = str.length();\n            for (int i = 0; i < str.length(); i++) {\n                Loc loc = hm.get(str.charAt(i));\n                count += Math.abs(iPos - loc.i) + Math.abs(jPos - loc.j);\n                iPos = loc.i;\n                jPos = loc.j;\n            }\n            \n            System.out.println(count);\n        }\n    }\n    \n    public static class Loc {\n        int i;\n        int j;\n        \n        public Loc(int i, int j) {\n            this.i = i;\n            this.j = j;\n        }\n    }\n}\n\n"
  },
  {
    "language": "C#",
    "code": "using System.Collections.Generic;\nusing static System.Math;\nusing System;\n\npublic class P\n{\n    public int x { get; set; }\n    public int y { get; set; }\n}\n\npublic class hello\n{\n    public static void Main()\n    {\n        while (true)\n        {\n            string[] line = Console.ReadLine().Trim().Split(' ');\n            var h = int.Parse(line[0]);\n            var w = int.Parse(line[1]);\n            if (h == 0 && w == 0) break;\n            var d = new Dictionary<char, P>();\n            for (int i = 0; i < h; i++)\n            {\n                var s = Console.ReadLine().Trim();\n                for (int j = 0; j < w; j++)\n                    if (s[j] != '_') d[s[j]] = new P { x = i, y = j };\n            }\n            var st = Console.ReadLine().Trim();\n            getAns(d, st);\n        }\n    }\n    static void getAns(Dictionary<char, P> d, string s)\n    {\n        var ans = s.Length;\n        var tx = 0; var ty = 0;\n        for (int i = 0; i < s.Length; i++)\n        {\n            var pa = d[s[i]];\n            ans += Abs(pa.x - tx) + Abs(pa.y - ty);\n            tx = pa.x;\n            ty = pa.y;\n        }\n        Console.WriteLine(ans);\n    }\n}\n\n"
  },
  {
    "language": "C#",
    "code": "using System;\nclass icpc_1633{\n  public static void Main(){\n    const int MAX_ASCII = 127;\n    Pos cur = new Pos();\n    Pos next = new Pos();\n    Calc c = new Calc();\n    while(true){\n      int count = 0;\n      c.init(cur);\n      c.init(next);\n      String[] str = Console.ReadLine().Split(' ');\n      int h = int.Parse(str[0]);\n      int w = int.Parse(str[1]);\n      if(h ==0 && w == 0)\n        break;\n      String[] display = new String[h];\n      for(int i=0; i<h; i++){\n        display[i] = Console.ReadLine();\n      }\n      String input = Console.ReadLine();\n      bool[] isal = new bool[MAX_ASCII];\n      Pos[] ispos = new Pos[MAX_ASCII];\n      for(int i=0; i<MAX_ASCII; i++){\n        isal[i] = false;\n      }\n      foreach(char ch in input){\n        if(isal[(int)ch]){\n          count += Math.Abs(cur.H - ispos[(int)ch].H);\n          count += Math.Abs(cur.W - ispos[(int)ch].W);\n          count++;\n          cur = ispos[(int)ch];\n        }\n        else{\n          next = c.search(ch, display, w,h);\n          isal[(int)ch] = true;\n          ispos[(int)ch] = next;\n          count += Math.Abs(cur.H - next.H);\n          count += Math.Abs(cur.W - next.W);\n          count++;\n          cur = next;\n        }\n        //c.printpos(ch,cur);\n        //Console.WriteLine(\"Count is {0}\",count);\n        //Console.WriteLine(\"----------\");\n      }\n      Console.WriteLine(count);\n    }\n  }\n}\n\nclass Calc{\n  public Pos search(char c, String[] sr, int w, int h){\n    Pos ret = new Pos();\n    bool flag = true;\n    for(int i=0; i<h && flag; i++){\n      String s = sr[i];\n      for(int j=0; j<w && flag; j++){\n        if(s[j] == c){\n          ret.H = i;\n          ret.W = j;\n          flag = false;\n        }\n      }\n    }\n    return ret;\n  }\n  public void printpos(char c, Pos p){\n    Console.WriteLine(\"{0} is [{1}, {2}]\",c,p.H,p.W);\n  }\n  public void init(Pos p){\n    p.H = 0;\n    p.W = 0;\n  }\n}\n\nclass Pos{\n  int h,w;\n  public Pos(){\n    h = 0;\n    w = 0;\n  }\n  public int H{\n    set{ h=value; }\n    get{ return h; }\n  }\n  public int W{\n    set{ w=value; }\n    get{ return w; }\n  }\n}\n\n"
  },
  {
    "language": "JavaScript",
    "code": "var input = require('fs').readFileSync('/dev/stdin', 'utf8');\nvar arr=input.trim().split(\"\\n\");\nwhile(true){\n   var [h,w]=arr.shift().split(\" \").map(Number);\n   if(h==0 && w==0)break;\n   var k={};\n   for(var i=0;i<h;i++){\n      var r=arr.shift().split(\"\");\n      for(var j=0;j<w;j++){\n         k[r[j]]=[i,j];\n      }\n   }\n   var [s,sum,y,x]=[arr.shift().split(\"\"),0,0,0];\n   s.forEach(v=>{\n      sum+=Math.abs(y-k[v][0])+Math.abs(x- k[v][1])+1;\n      [y,x]=[k[v][0],k[v][1]];\n   });\n   console.log(sum);\n}\n"
  },
  {
    "language": "Ruby",
    "code": "loop do\n  h, w = gets.split.map(&:to_i)\n  break if h == 0\n  position = {}\n  (0..h-1).each do |i|\n    gets.chomp.each_char.with_index do |c, j|\n      next if c == ?_\n      position[c] = [i, j]\n    end\n  end\n  i = j = k = 0\n  s = gets.chomp.each_char do |c|\n    y, x = position[c]\n    k += (i - y).abs + (j - x).abs + 1\n    i, j = y, x\n  end\n  p k\nend\n"
  },
  {
    "language": "Ruby",
    "code": "while true\n    h, w = gets.chomp.split.map(&:to_i)\n    break if [h, w] == [0, 0]\n\n    keyboard = \"\"\n    h.times{keyboard += gets.chomp}\n    x, y, hit = 0, 0, 0\n    gets.chomp.split(\"\").each{|c|\n        z = keyboard.index(c)\n        y2, x2 = z.divmod(w)\n        hit += (x - x2).abs + (y - y2).abs + 1\n        x, y = x2, y2\n    }\n    puts hit\nend\n"
  },
  {
    "language": "Go",
    "code": "package main\n\nimport (\n\t\"bufio\"\n\t\"fmt\"\n\t\"os\"\n\t\"strconv\"\n)\n\nvar scanner = bufio.NewScanner(os.Stdin)\n\nfunc nextString() string {\n\tscanner.Scan()\n\treturn scanner.Text()\n}\n\nfunc nextInt() int {\n\tn, err := strconv.Atoi(nextString())\n\tif err != nil {\n\t\tfmt.Printf(\"strconv.Atoi failed: %v\\n\", err)\n\t}\n\treturn n\n}\n\ntype Position = []int\n\nfunc abs(x int) int {\n\tif x < 0 {\n\t\treturn -x\n\t}\n\treturn x\n}\n\nfunc main() {\n\tscanner.Split(bufio.ScanWords)\n\n\tfor {\n\t\th := nextInt()\n\t\tw := nextInt()\n\n\t\tif h == 0 && w == 0 {\n\t\t\tbreak\n\t\t}\n\t\tpositions := map[string]Position{}\n\t\tfor i := 0; i < h; i++ {\n\t\t\trow := nextString()\n\t\t\tfor j := 0; j < w; j++ {\n\t\t\t\tpos := []int{i, j}\n\t\t\t\tpositions[row[j:(j+1)]] = pos\n\t\t\t}\n\t\t}\n\t\t// fmt.Println(positions)\n\n\t\tx := 0\n\t\ty := 0\n\t\ttotalDistance := 0\n\n\t\tqueryRow := nextString()\n\t\tfor i := 0; i < len(queryRow); i++ {\n\t\t\tq := queryRow[i:(i + 1)]\n\n\t\t\tnextPos := positions[q]\n\t\t\txNext := nextPos[0]\n\t\t\tyNext := nextPos[1]\n\n\t\t\ttotalDistance += abs(xNext-x) + abs(yNext-y) + 1\n\t\t\tx = xNext\n\t\t\ty = yNext\n\t\t\t// fmt.Println(nextPos, totalDistance)\n\t\t}\n\t\tfmt.Println(totalDistance)\n\t}\n}\n\n"
  },
  {
    "language": "Python",
    "code": "while 1:\n    h, w = map(int, input().split())\n    if h == 0:\n        break\n    d = {}\n    for i in range(h):\n        s = input()\n        for j in range(w):\n            if s[j] != '_':\n                d[s[j]] = [j, i]\n    s = input()\n    cnt = 0\n    for i in range(len(s)):\n        if i == 0:\n            cnt += d[s[i]][0] + d[s[i]][1] + 1\n        else:\n            cnt += abs(d[s[i]][0]-d[s[i-1]][0]) + abs(d[s[i]][1]-d[s[i-1]][1]) + 1\n    print(cnt)\n"
  },
  {
    "language": "Python",
    "code": "#!/usr/bin/python3\n\nimport array\nfrom fractions import Fraction\nimport functools\nimport itertools\nimport math\nimport os\nimport sys\n\n\ndef main():\n    while True:\n        H, W = read_ints()\n        if (H, W) == (0, 0):\n            break\n        R = [inp() for _ in range(H)]\n        S = inp()\n        print(solve(H, W, R, S))\n\n\ndef solve(H, W, R, S):\n    pos_map = {}\n    for y in range(H):\n        for x in range(W):\n            c = R[y][x]\n            if c != '_':\n                pos_map[c] = (x, y)\n\n    ans = 0\n    cx = 0\n    cy = 0\n    for c in S:\n        x, y = pos_map[c]\n        ans += abs(x - cx) + abs(y - cy) + 1\n        cx, cy = x, y\n\n    return ans\n\n\n###############################################################################\n# AUXILIARY FUNCTIONS\n\nDEBUG = 'DEBUG' in os.environ\n\n\ndef inp():\n    return sys.stdin.readline().rstrip()\n\n\ndef read_int():\n    return int(inp())\n\n\ndef read_ints():\n    return [int(e) for e in inp().split()]\n\n\ndef dprint(*value, sep=' ', end='\\n'):\n    if DEBUG:\n        print(*value, sep=sep, end=end)\n\n\nif __name__ == '__main__':\n    main()\n\n"
  },
  {
    "language": "Python",
    "code": "while 1:\n    H, W = map(int, input().split())\n    if H == 0:\n        break\n    P = {}\n    for i in range(H):\n        r = input()\n        for j, c in enumerate(r):\n            P[c] = (i, j)\n    S = input()\n    ans = len(S)\n    px = 0; py = 0\n    for c in S:\n        x, y = P[c]\n        ans += abs(x - px) + abs(y - py)\n        px = x; py = y\n    print(ans)\n\n"
  },
  {
    "language": "Python",
    "code": "while True:\n    h,w = map(int,input().split())\n    if(h+w == 0):\n        break\n    li = list()\n    for i in range(h):\n        s = input()\n        li.append(s)\n    d = dict()\n    for i,l in enumerate(li):\n        for j,char in enumerate(l):\n            d[char] = (i,j)\n    target = input()\n    ans = 0\n    now = (0,0)\n    for t in target:\n        next = d[t]\n        ans += abs(now[0]-next[0]) + abs(now[1]-next[1])\n        now=next\n    print(ans + len(target))\n"
  },
  {
    "language": "Python",
    "code": "import os,re,sys,operator\nfrom collections import Counter,deque\nfrom operator import itemgetter\nfrom itertools import accumulate,combinations,groupby\nfrom sys import stdin,setrecursionlimit\nfrom copy import deepcopy\nimport heapq\n\nsetrecursionlimit(10**6)\nwhile 1:\n    h,w=map(int,stdin.readline().rstrip().split())\n    if (h,w)==(0,0):\n        break\n    a=[stdin.readline().rstrip() for _ in range(h)]\n    s=input()\n    nx,ny=0,0\n    o=0\n    cnt=0\n    for i in s:\n        nh=0\n        for j in range(h):\n            if i in a[j]:\n                o=a[j].index(i)\n                cnt+=(abs(nx-o)+abs(ny-nh)+1)\n                break\n            else:\n                nh+=1\n        nx,ny=o,nh\n    print(cnt)\n"
  },
  {
    "language": "Python",
    "code": "# -*- coding: utf-8 -*-\n\"\"\"\nスクリーンキーボード\nhttps://onlinejudge.u-aizu.ac.jp/challenges/sources/ICPC/Prelim/1633\n\n\"\"\"\nimport sys\n\n\ndef solve(h, w):\n    keyboard = dict()\n    for y in range(h):\n        for x, ch in enumerate(input()):\n            keyboard[ch] = (x, y)\n\n    cx, cy = 0, 0\n    ans = 0\n    for ch in input():\n        nx, ny = keyboard[ch]\n        ans += (abs(nx - cx) + abs(ny - cy) + 1)\n        cx, cy = nx, ny\n    return ans\n\n\ndef main(args):\n    while True:\n        h, w = map(int, input().split())\n        if h == 0 and w == 0:\n            break\n        ans = solve(h, w)\n        print(ans)\n\n\nif __name__ == '__main__':\n    main(sys.argv[1:])\n\n"
  },
  {
    "language": "Python",
    "code": "while True:\n    h, w = map(int, input().split())\n    if h == w == 0:\n        break\n    mp = {}\n    for r in range(h):\n        s = input()\n        for c in range(w):\n            mp[s[c]] = [r, c]\n    s = input()\n    now = [0, 0]\n    ans = 0\n    for i in range(len(s)):\n        to = mp[s[i]]\n        ans += abs(now[0] - to[0]) + abs(now[1] - to[1]) + 1\n        now = to\n    print(ans)\n"
  },
  {
    "language": "Python",
    "code": "# coding=utf-8\n\n###\n### for python program\n###\n\nimport sys\nimport math\n\n# math class\nclass mymath:\n    ### pi\n    pi = 3.14159265358979323846264338\n\n    ### Prime Number\n    def pnum_eratosthenes(self, n):\n        ptable = [0 for i in range(n+1)]\n        plist = []\n\n        for i in range(2, n+1):\n            if ptable[i]==0:\n                plist.append(i)\n                for j in range(i+i, n+1, i):\n                    ptable[j] = 1\n        return plist\n\n    def pnum_check(self, n):\n        if (n==1):\n            return False\n        elif (n==2):\n            return True\n        else:\n            for x in range(2,n):\n                if(n % x==0):\n                    return False\n            return True\n\n    ### GCD\n    def gcd(self, a, b):\n        if b == 0:\n            return a\n        return self.gcd(b, a%b)\n\n    ### LCM\n    def lcm(self, a, b):\n        return (a*b)//self.gcd(a,b)\n\n    ### Mat Multiplication\n    def mul(self, A, B):\n        ans = []\n        for a in A:\n            c = 0\n            for j, row in enumerate(a):\n                c += row*B[j]\n            ans.append(c)\n        return ans\n    \n    ### intチェック\n    def is_integer(self, n):\n        try:\n            float(n)\n        except ValueError:\n            return False\n        else:\n            return float(n).is_integer()\n\n    ### 幾何学問題用\n    def dist(self, A, B):\n        d = 0\n        for i in range(len(A)):\n            d += (A[i]-B[i])**2            \n        d = d**(1/2)\n        return d\n\n    ### 絶対値\n    def abs(self, n):\n        if n >= 0:\n            return n\n        else:\n            return -n\n\nmymath = mymath()\n\n### output class\nclass output:\n    ### list\n    def list(self, l):\n        l = list(l)\n        #print(\" \", end=\"\")\n        for i, num in enumerate(l):\n            print(num, end=\"\")\n            if i != len(l)-1:\n                print(\" \", end=\"\")\n        print()\n\noutput = output()\n\n### input sample\n#i = input()\n#N = int(input())\n#A, B, C = [x for x in input().split()]\n#N, K = [int(x) for x in input().split()]\n#inlist = [int(w) for w in input().split()]\n\n#R = float(input())\n#A.append(list(map(int,input().split())))\n\n#for line in sys.stdin.readlines():\n#    x, y = [int(temp) for temp in line.split()]\n\n#abc list\n#abc = [chr(ord('a') + i) for i in range(26)]\n\n### output sample\n# print(\"{0} {1} {2:.5f}\".format(A//B, A%B, A/B))\n# print(\"{0:.6f} {1:.6f}\".format(R*R*math.pi,R*2*math.pi))\n# print(\" {}\".format(i), end=\"\")\n\ndef printA(A):\n    N = len(A)\n    for i, n in enumerate(A):\n        print(n, end='')\n        if i != N-1:\n            print(' ', end='')\n    print()\n\n# リスト内包表記 ifあり\n# [x-k if x != 0 else x for x in C]\n\n# ソート\n# N = N.sort()\n\n# 10000個の素数リスト\n# P = mymath.pnum_eratosthenes(105000)\n\ndef get_input():\n    N = []\n    while True:\n        try:\n            N.append(input())\n            #N.append(int(input()))\n            #N.append(float(input()))\n        except EOFError:\n            break\n    return N\n\nwhile True:\n    H, W = [int(x) for x in input().split()]\n    if H==0 and W==0:\n        break\n    R = []\n    for i in range(H):\n        R.append(input())\n    S = input()\n\n    count = 0\n    x = 0\n    y = 0\n    for s in S:\n        for i, row in enumerate(R):\n            for j, r in enumerate(row):\n                if s == r:\n                    count += (mymath.abs(i-x)+mymath.abs(j-y)+1)\n                    x = i\n                    y = j\n                    break\n\n    print(count)\n\n"
  },
  {
    "language": "Python",
    "code": "import sys\ninput=sys.stdin.readline\nwhile True:\n\trr=[]\n\th,w=map(int,input().split())\n\tif h==w==0:\n\t\tbreak\n\telse:\n\t\tfor i in range(h):\n\t\t\tr=input().rstrip()\n\t\t\trr.append(r)\n\t\ts=input().rstrip()\n\t\tans=0\n\t\tnow=[0,0]\n\t\tfor i in range(len(s)):\n\t\t\tfor j in range(h):\n\t\t\t\tfor k in range(w):\n\t\t\t\t\tif rr[j][k]==s[i]:\n\t\t\t\t\t\tans+=abs(now[0]-j)+abs(now[1]-k)\n\t\t\t\t\t\tnow=[j,k]\n\t\tprint(ans+len(s))\n\n"
  },
  {
    "language": "Rust",
    "code": "fn main() {\n    loop {\n        let (n, m) = base();\n        if (0, 0) == (n, m) {\n            break;\n        }\n\n        let mut alphabet = std::collections::HashMap::new();\n        for i in 0..n {\n            let mut s = String::new();\n            std::io::stdin().read_line(&mut s).unwrap();\n\n            for (j, c) in s.trim().chars().enumerate() {\n                alphabet.insert(c, (i as i32, j as i32));\n            }\n        }\n\n        let mut word = String::new();\n        std::io::stdin().read_line(&mut word).unwrap();\n\n        let mut ans = 0;\n        let mut pre = (0, 0);\n        for c in word.trim().chars() {\n            ans += (alphabet.get(&c).unwrap().0 - pre.0).abs();\n            ans += (alphabet.get(&c).unwrap().1 - pre.1).abs();\n\n            pre = *alphabet.get(&c).unwrap();\n            ans += 1;\n        }\n\n        println!(\"{}\", ans);\n    }\n}\n\nfn base() -> (usize, usize) {\n    let v = input();\n\n    (v[0] as usize, v[1] as usize)\n}\n\nfn input() -> Vec<i32> {\n    let mut s = String::new();\n    std::io::stdin().read_line(&mut s).unwrap();\n\n    let v: Vec<i32> = s.trim().split_whitespace().map(|x| x.parse().unwrap()).collect::<_>();\n\n    v\n}\n\n"
  }
]