[
  {
    "language": "Scala",
    "code": "\nimport scala.annotation.tailrec\nimport scala.collection.{immutable, mutable}\nimport scala.io.StdIn._\nobject Main extends App {\n  loop()\n  @tailrec def loop(): Unit = {\n    readLine.trim match {\n      case \"#\" ⇒ return\n      case Equation(e) ⇒\n        println(if (e.isIdentify) \"YES\" else \"NO\")\n        loop()\n      case _ ⇒ ???\n    }\n  }\n}\n\nobject Equation {\n  def unapply(arg: String): Option[(Equation)] = {\n    arg.toList match {\n      case (l Formula '='::(r Formula Nil)) ⇒ Some(new Equation(l, r, arg.filter(_.isLower).map(c ⇒ (1 << (c - 'a'))).reduce(_ | _)))\n      case _ ⇒ None\n    }\n  }\n}\nclass Equation(left: Formula, right: Formula, variables: Int) {\n  val isIdentify: Boolean = (0 until (1 << 11)).filter(s ⇒ (s & ~variables) == 0).forall(state ⇒ left(state) == right(state))\n}\nobject Formula {\n  def unapply(arg: List[Char]): Option[(Formula, List[Char])] = {\n    arg match {\n      case t True r ⇒ Some(t, r)\n      case f False r ⇒ Some(f, r)\n      case v Variable r ⇒ Some(v, r)\n      case n Neg r ⇒ Some(n, r)\n      case b BiOperator r ⇒ Some(b, r)\n      case _ ⇒ None\n    }\n  }\n  object True extends Formula {\n    def unapply(arg: List[Char]): Option[(True.type, List[Char])] = {\n      arg match {\n        case 'T'::r ⇒ Some(this, r)\n        case _ ⇒ None\n      }\n    }\n    override def apply(state: Int): Boolean = true\n  }\n  object False extends Formula {\n    def unapply(arg: List[Char]): Option[(False.type, List[Char])] = {\n      arg match {\n        case 'F'::r ⇒ Some(this, r)\n        case _ ⇒ None\n      }\n    }\n    override def apply(state: Int): Boolean = false\n  }\n  object Neg {\n    def unapply(arg: List[Char]): Option[(Neg, List[Char])] = {\n      arg match {\n        case '-'::(f Formula r) ⇒Some(new Neg(f), r)\n        case _ ⇒ None\n      }\n    }\n  }\n  class Neg(formula: Formula) extends Formula {\n    override def apply(state: Int): Boolean = !formula(state)\n  }\n  object BiOperator {\n    def unapply(arg: List[Char]): Option[(BiOperator, List[Char])] = {\n      arg match {\n        case '('::(l Formula rest) ⇒\n          rest match {\n            case '+'::(r Formula ')'::ex) ⇒ Some(new Or(l, r), ex)\n            case '*'::(r Formula ')'::ex) ⇒Some(new And(l, r), ex)\n            case '-'::'>'::(r Formula ')'::ex) ⇒ Some(new :->(l, r), ex)\n            case _ ⇒ None\n          }\n      }\n    }\n  }\n  sealed trait BiOperator extends Formula\n  class Or(left: Formula, right: Formula) extends BiOperator {\n    override def apply(state: Int): Boolean = left(state) || right(state)\n  }\n  class And(left: Formula, right: Formula) extends BiOperator {\n    override def apply(state: Int): Boolean = left(state) && right(state)\n  }\n  class :->(left: Formula, right: Formula) extends BiOperator {\n    override def apply(state: Int): Boolean = !left(state) || right(state)\n  }\n  object Variable {\n    def unapply(arg: List[Char]): Option[(Variable, List[Char])] = {\n      arg match {\n        case letter::r if letter.isLower ⇒ Some(new Variable(letter), r)\n        case _ ⇒ None\n      }\n    }\n  }\n  class Variable(letter: Char) extends Formula {\n    override def apply(state: Int): Boolean = ((1 << (letter - 'a')) & state) != 0\n  }\n}\nsealed trait Formula {\n  def apply(state: Int): Boolean\n}\n\n"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\nusing namespace std;\n\nusing vi = vector<int>; using vvi = vector<vi>; using vvvi = vector<vvi>;\nusing ll = long long int;\nusing vll = vector<ll>; using vvll = vector<vll>; using vvvll = vector<vvll>;\nusing vd = vector<double>; using vvd = vector<vd>; using vvvd = vector<vvd>;\nusing P = pair<int, int>;\nusing Pll = pair<ll, ll>;\nusing cdouble = complex<double>;\n\nconst double eps = 1e-7;\n#define Loop(i, n) for(int i = 0; i < int(n); i++)\n#define Loopll(i, n) for(ll i = 0; i < ll(n); i++)\n#define Loop1(i, n) for(int i = 1; i <= int(n); i++)\n#define Loopll1(i, n) for(ll i = 1; i <= ll(n); i++)\n#define Loopr(i, n) for(int i = int(n) - 1; i >= 0; i--)\n#define Looprll(i, n) for(ll i = ll(n) - 1; i >= 0; i--)\n#define Loopr1(i, n) for(int i = int(n); i >= 1; i--)\n#define Looprll1(i, n) for(ll i = ll(n); i >= 1; i--)\n#define Foreach(buf, container) for(auto buf : container)\n#define Loopdiag(i, j, h, w, sum) for(int i = ((sum) >= (h) ? (h) - 1 : (sum)), j = (sum) - i; i >= 0 && j < (w); i--, j++)\n#define Loopdiagr(i, j, h, w, sum) for(int j = ((sum) >= (w) ? (w) - 1 : (sum)), i = (sum) - j; j >= 0 && i < (h); j--, i++)\n#define Loopdiagsym(i, j, h, w, gap) for (int i = ((gap) >= 0 ? (gap) : 0), j = i - (gap); i < (h) && j < (w); i++, j++)\n#define Loopdiagsymr(i, j, h, w, gap) for (int i = ((gap) > (h) - (w) - 1 ? (h) - 1 : (w) - 1 + (gap)), j = i - (gap); i >= 0 && j >= 0; i--, j--)\n#define Loopitr(itr, container) for(auto itr = container.begin(); itr != container.end(); itr++)\n#define printv(vector) Loop(ex_i, vector.size()) { cout << vector[ex_i] << \" \"; } cout << endl;\n#define printmx(matrix) Loop(ex_i, matrix.size()) { Loop(ex_j, matrix[ex_i].size()) { cout << matrix[ex_i][ex_j] << \" \"; } cout << endl; }\n#define quickio() ios::sync_with_stdio(false); cin.tie(0);\n#define bitmanip(m,val) static_cast<bitset<(int)m>>(val)\n#define Comp(type_t) bool operator<(const type_t &another) const\n#define fst first\n#define snd second\n#define INF INFINITY\nbool feq(double x, double y) { return abs(x - y) <= eps; }\nbool inrange(ll x, ll t) { return x >= 0 && x < t; }\nbool inrange(vll xs, ll t) { Foreach(x, xs) if (!(x >= 0 && x < t)) return false; return true; }\nint ceillog2(ll x) { int ret = 0;\tx--; while (x > 0) { ret++; x >>= 1; } return ret; }\nll rndf(double x) { return (ll)(x + (x >= 0 ? 0.5 : -0.5)); }\nll floorsqrt(ll x) { ll m = (ll)sqrt((double)x); return m + (m * m <= x ? 0 : -1); }\nll ceilsqrt(ll x) { ll m = (ll)sqrt((double)x); return m + (x <= m * m ? 0 : 1); }\nll rnddiv(ll a, ll b) { return (a / b + (a % b * 2 >= b ? 1 : 0)); }\nll ceildiv(ll a, ll b) { return (a / b + (a % b == 0 ? 0 : 1)); }\nll gcd(ll m, ll n) { if (n == 0) return m; else return gcd(n, m % n); }\nll lcm(ll m, ll n) { return m * n / gcd(m, n); }\n\n/*******************************************************/\n\npair<int, bool> equation(const string &s, int &id);\npair<int, bool> formula(const string &s, int &id);\npair<int, bool> var(const string &s, int &id);\n\nvi mp;\n\npair<int, bool> equation(const string &s, int &id) {\n\tauto c0 = formula(s, id);\n\tif (c0.snd) {\n\t\tif (s[id] == '=') {\n\t\t\tid++;\n\t\t\tauto c1 = formula(s, id);\n\t\t\tif (c1.snd && (id == s.length() - 1)) {\n\t\t\t\treturn { c0.fst == c1.fst ? 1 : 0, true };\n\t\t\t}\n\t\t\telse {\n\t\t\t\treturn { 0, false };\n\t\t\t}\n\t\t}\n\t\telse {\n\t\t\treturn { 0, false };\n\t\t}\n\t}\n\telse {\n\t\treturn { 0, false };\n\t}\n}\n\npair<int, bool> formula(const string &s, int &id) {\n\tauto c0 = var(s, id);\n\tif (c0.snd) {\n\t\treturn { c0.fst, true };\n\t}\n\telse if (s[id] == '-') {\n\t\tid++;\n\t\tauto c1 = formula(s, id);\n\t\tif (c1.snd) {\n\t\t\treturn { c1.fst ^ 1, true };\n\t\t}\n\t\telse {\n\t\t\treturn { 0, false };\n\t\t}\n\t}\n\telse if (s[id] == '(') {\n\t\tid++;\n\t\tauto c1 = formula(s, id);\n\t\tif (c1.snd) {\n\t\t\tint ret;\n\t\t\tif (s[id] == '*') {\n\t\t\t\tid++;\n\t\t\t\tauto c2 = formula(s, id);\n\t\t\t\tif (c2.snd) ret = c1.fst & c2.fst;\n\t\t\t\telse return { 0, false };\n\t\t\t}\n\t\t\telse if (s[id] == '+') {\n\t\t\t\tid++;\n\t\t\t\tauto c2 = formula(s, id);\n\t\t\t\tif (c2.snd) ret = c1.fst | c2.fst;\n\t\t\t\telse return { 0, false };\n\t\t\t}\n\t\t\telse if (s[id] == '-') {\n\t\t\t\tid++;\n\t\t\t\tif (s[id] == '>') {\n\t\t\t\t\tid++;\n\t\t\t\t\tauto c2 = formula(s, id);\n\t\t\t\t\tif (c2.snd) {\n\t\t\t\t\t\tif (c1.fst == 1 && c2.fst == 0) ret = 0;\n\t\t\t\t\t\telse ret = 1;\n\t\t\t\t\t}\n\t\t\t\t\telse return { 0, false };\n\t\t\t\t}\n\t\t\t\telse {\n\t\t\t\t\treturn { 0, false };\n\t\t\t\t}\n\t\t\t}\n\t\t\telse {\n\t\t\t\treturn { 0, false };\n\t\t\t}\n\t\t\tif (s[id] == ')') {\n\t\t\t\tid++;\n\t\t\t\treturn { ret, true };\n\t\t\t}\n\t\t\telse {\n\t\t\t\treturn { 0, false };\n\t\t\t}\n\t\t}\n\t\telse {\n\t\t\treturn { 0, false };\n\t\t}\n\t}\n}\n\npair<int, bool> var(const string &s, int &id) {\n\tif ('a' <= s[id] && s[id] <= 'k') {\n\t\tint ret = mp[s[id] - 'a'];\n\t\tid++;\n\t\treturn { ret, true };\n\t}\n\telse if (s[id] == 'T') {\n\t\tid++;\n\t\treturn { 1, true };\n\t}\n\telse if (s[id] == 'F') {\n\t\tid++;\n\t\treturn { 0, true };\n\t}\n\telse {\n\t\treturn { 0, false };\n\t}\n}\n\nint main() {\n\tmp.resize(11);\n\twhile (true) {\n\t\tstring s; cin >> s;\n\t\tif (s == \"#\") break;\n\t\ts += '$';\n\t\tbool ans = true;\n\t\tLoop(x, 1 << 11) {\n\t\t\tLoop(i, 11) {\n\t\t\t\tmp[i] = (x & (1 << i) ? 1 : 0);\n\t\t\t}\n\t\t\tint id = 0;\n\t\t\tauto c = equation(s, id);\n\t\t\tif (c.fst == 0) {\n\t\t\t\tans = false;\n\t\t\t\tbreak;\n\t\t\t}\n\t\t}\n\t\tif (ans) {\n\t\t\tcout << \"YES\" << endl;\n\t\t}\n\t\telse {\n\t\t\tcout << \"NO\" << endl;\n\t\t}\n\t}\n}\n"
  },
  {
    "language": "C++",
    "code": "#include <functional>\n#include <iostream>\n#include <memory>\n#include <string>\n#include <unordered_set>\n#include <vector>\n#define loop(i, a, n) for (int i = (a); i < (n); i++)\n#define rep(i, n) loop(i, 0, n)\ntemplate<typename A> using F = std::function<A>;\nusing namespace std;\n\ntemplate<typename T> struct ParseResult {\n  bool succeeded;\n  T object;\n  size_t pos;\n  ParseResult(const bool succeeded, const T &object, const size_t pos) : succeeded(succeeded), object(object), pos(pos) {}\n  friend std::ostream &operator<<(std::ostream &os, const ParseResult<T> &p) { return os << '{' << (p.succeeded ? \"true\" : \"false\") << ',' << p.object << ',' << p.pos << '}'; }\n};\n\ntemplate<typename T> using Parser = std::function<ParseResult<T>(const std::string &, size_t)>;\n\nParser<std::string> token(std::string s) {\n  const size_t n = s.size();\n  return [n = std::move(n), s = std::move(s)](const std::string &target, const size_t pos) {\n    if (target.size() < n) return ParseResult<std::string>(false, {}, pos);\n    return target.substr(pos, n) == s ? ParseResult<std::string>(true, s, pos + n) : ParseResult<std::string>(false, {}, pos);\n  };\n}\n\ntemplate<typename T> Parser<T> operator||(Parser<T> p1, Parser<T> p2) {\n  return [p1 = std::move(p1), p2 = std::move(p2)](const std::string &target, const size_t pos) {\n    auto r = p1(target, pos);\n    if (r.succeeded) return r;\n    r = p2(target, pos);\n    if (r.succeeded) return r;\n    return ParseResult<T>(false, {}, pos);\n  };\n}\n\ntemplate<typename T1, typename T2> Parser<std::pair<T1, T2>> operator+(Parser<T1> p1, Parser<T2> p2) {\n  return [p1 = std::move(p1), p2 = std::move(p2)](const std::string &target, const size_t pos) {\n    auto r1 = p1(target, pos);\n    if (!r1.succeeded) return ParseResult<std::pair<T1, T2>>(false, {}, pos);\n    auto r2 = p2(target, r1.pos);\n    if (!r2.succeeded) return ParseResult<std::pair<T1, T2>>(false, {}, pos);\n    return ParseResult<std::pair<T1, T2>>(true, {r1.object, r2.object}, r2.pos);\n  };\n}\n\ntemplate<typename T1, typename T2> Parser<T2> operator>>(Parser<T1> p1, Parser<T2> p2) {\n  return [p1 = std::move(p1), p2 = std::move(p2)](const std::string &target, const size_t pos) {\n    auto r1 = p1(target, pos);\n    if (!r1.succeeded) return ParseResult<T2>(false, {}, pos);\n    auto r2 = p2(target, r1.pos);\n    if (!r2.succeeded) return ParseResult<T2>(false, {}, pos);\n    return ParseResult<T2>(true, r2.object, r2.pos);\n  };\n}\n\ntemplate<typename T1, typename T2> Parser<T1> operator<<(Parser<T1> p1, Parser<T2> p2) {\n  return [p1 = std::move(p1), p2 = std::move(p2)](const std::string &target, const size_t pos) {\n    auto r1 = p1(target, pos);\n    if (!r1.succeeded) return ParseResult<T1>(false, {}, pos);\n    auto r2 = p2(target, r1.pos);\n    if (!r2.succeeded) return ParseResult<T1>(false, {}, pos);\n    return ParseResult<T1>(true, r1.object, r2.pos);\n  };\n}\n\nParser<char> oneOf(const std::string &s) {\n  std::unordered_set<char> d;\n  for (auto &c : s) d.insert(c);\n  return [d = std::move(d)](const std::string &target, const size_t pos) {\n    if (target.size() <= pos) return ParseResult<char>(false, {}, pos);\n    char c = target[pos];\n    return d.count(c) ? ParseResult<char>(true, c, pos + 1) : ParseResult<char>(false, {}, pos);\n  };\n}\n\ntemplate<typename T, typename S, typename F> Parser<S> fmap(Parser<T> p, F &&f) {\n  return [p = std::move(p), f = std::forward<F>(f)](const std::string &target, const size_t pos) {\n    auto r = p(target, pos);\n    return r.succeeded ? ParseResult<S>(true, f(r.object), r.pos) : ParseResult<S>(false, {}, r.pos);\n  };\n}\n\ntemplate<typename T, typename F> Parser<T> lazy(const F &f) {\n  bool instantiated = false;\n  Parser<T> p;\n  Parser<T> &&q = [f = std::move(f), p = std::move(p), instantiated = std::move(instantiated)](const std::string &target, const size_t pos) mutable {\n    if (!instantiated) {\n      p = f();\n      instantiated = true;\n    }\n    return p(target, pos);\n  };\n  return [q = std::make_shared<Parser<T>>(std::move(q))](const std::string &target, const size_t pos) { return (*q)(target, pos); };\n}\n\nstruct SyntaxTree {\n  string op;\n  char value;\n  vector<SyntaxTree> children;\n  SyntaxTree() {}\n  SyntaxTree(const string &op, const char value, const vector<SyntaxTree> &children) : op(op), value(value), children(children) {}\n};\n\nint main() {\n  Parser<SyntaxTree> formulaP = lazy<SyntaxTree>([&]() {\n    auto andP = fmap<pair<SyntaxTree, SyntaxTree>, SyntaxTree>((token(\"(\") >> formulaP << token(\"*\")) + (formulaP << token(\")\")), [](auto &o) { return SyntaxTree(\"*\", {}, {o.first, o.second}); });\n    auto orP = fmap<pair<SyntaxTree, SyntaxTree>, SyntaxTree>((token(\"(\") >> formulaP << token(\"+\")) + (formulaP << token(\")\")), [](auto &o) { return SyntaxTree(\"+\", {}, {o.first, o.second}); });\n    auto impP = fmap<pair<SyntaxTree, SyntaxTree>, SyntaxTree>((token(\"(\") >> formulaP << token(\"->\")) + (formulaP << token(\")\")), [](auto &o) { return SyntaxTree(\"->\", {}, {o.first, o.second}); });\n    auto notP = fmap<SyntaxTree, SyntaxTree>(token(\"-\") >> formulaP, [](auto &o) { return SyntaxTree(\"-\", {}, {o}); });\n    auto valP = fmap<char, SyntaxTree>(oneOf(\"abcdefghijkTF\"), [](char x) { return SyntaxTree({}, x, {}); });\n    return andP || orP || impP || notP || valP;\n  });\n  auto equationP = (formulaP << token(\"=\")) + formulaP;\n  string s;\n  while (cin >> s, s != \"#\") {\n    auto r = equationP(s, 0);\n    bool isValid = true;\n    rep(i, 1 << 11) {\n      auto toBool = [&](char c) -> bool {\n        if (c == 'T') return true;\n        if (c == 'F') return false;\n        return i >> (c - 'a') & 1;\n      };\n      F<bool(const SyntaxTree &)> evalF = [&](const SyntaxTree &f) {\n        switch (f.children.size()) {\n          case 0: return toBool(f.value);\n          case 1: return !evalF(f.children[0]);\n          case 2:\n            if (f.op == \"*\") return evalF(f.children[0]) && evalF(f.children[1]);\n            if (f.op == \"+\") return evalF(f.children[0]) || evalF(f.children[1]);\n            if (f.op == \"->\") return !evalF(f.children[0]) || evalF(f.children[1]);\n        }\n      };\n      isValid &= evalF(r.object.first) == evalF(r.object.second);\n    }\n    cout << (isValid ? \"YES\" : \"NO\") << endl;\n  }\n}"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\n#include<stdio.h>\nusing namespace std;\n#define FOR(i,k,n) for(int i = (k); i < (n); i++)\n#define REP(i,n) FOR(i,0,n)\n#define ALL(a) begin(a),end(a)\n#define MS(m,v) memset(m,v,sizeof(m))\n#define D10  fixed<<setprecision(10)\ntypedef vector<int> vi;\ntypedef vector<string> vs;\ntypedef pair<int, int> P;\ntypedef long long ll;\nconst ll INF = 114514810;\nconst ll MOD = 1000000007;\nconst double EPS = 1e-8;\nconst double PI = acos(-1.0);\nstruct edge\n{\n\tint to, cost;\n\tbool operator < (const edge& e) const { return cost < e.cost; }\n\tbool operator >(const edge& e) const { return cost > e.cost; }\n};\nint dx[] = { -1, 0, 0, 1 }; int dy[] = { 0, -1, 1, 0 };\ntemplate<class T> T &chmin(T &a, const T &b) { return a = min(a, b); }\ntemplate<class T> T &chmax(T &a, const T &b) { return a = max(a, b); }\nbool valid(int x, int y, int h, int w) { return (x >= 0 && y >= 0 && x < h&&y < w); }\n///*************************************************************************************///\n///*************************************************************************************///\n///*************************************************************************************///\n\nint p;\nmap<char, int> li;\nint solve(const string& s);\n\nint elem(const string &s)\n{\n\tif (s[p] == '(')\n\t{\n\t\tp++;\n\t\tint buf = solve(s);\n\t\tp++;\n\t\treturn buf;\n\t}\n\tif (s[p] == '-'&&s[p + 1] != '>')\n\t{\n\t\tp++;\n\t\treturn solve(s) == 0 ? 1 : 0;\n\t}\n\tint res = li[s[p]];\n\treturn res;\n}\n\nint solve(const string& s)\n{\n\tint tmp = elem(s);\n\twhile (s[p] == '*' || s[p] == '+')\n\t{\n\t\tchar c = s[p];\n\t\tp++;\n\t\tif (c == '*') tmp *= elem(s);\n\t\telse if (c == '+')\n\t\t{\n\t\t\ttmp += elem(s);\n\t\t\tif (tmp != 0) tmp = 1;\n\t\t}\n\t\telse\n\t\t{\n\t\t\ttmp = elem(s) == 0 ? 1 : 0;\n\t\t}\n\t}\n\twhile (s[p] == '-'&&s[p + 1] == '>')\n\t{\n\t\tp += 2;\n\t\tif (tmp == 1 && elem(s) == 0) tmp = 0;\n\t\telse tmp = 1;\n\t}\n\treturn tmp;\n}\n\nint main()\n{\n\tstring str, s, t;\n\twhile (cin >> str)\n\t{\n\t\tif (str == \"#\") break;\n\t\tint eq = str.find('=');\n\t\ts = str.substr(0, eq);\n\t\tt = str.substr(eq + 1);\n\t\tp = 0;\n\t\tbool ans = true;\n\t\tREP(i, 1 << 11)\n\t\t{\n\t\t\tli.clear();\n\t\t\tli['T'] = 1;\n\t\t\tli['F'] = 0;\n\t\t\tREP(j, 11)\n\t\t\t{\n\t\t\t\tli['a' + j] = ((i >> j) & 1) ? 1 : 0;\n\t\t\t}\n\t\t\tp = 0;\n\t\t\tint l = solve(s);\n\t\t\tp = 0;\n\t\t\tint r = solve(t);\n\t\t\tif (l != r) ans = false;\n\t\t}\n\t\tputs(ans ? \"YES\" : \"NO\");\n\t}\n\treturn 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include<iostream>\n#include<vector>\n#include<string>\n#include<algorithm>\n#define all(c) c.begin(),c.end()\n#define uni(c) c.erase(unique(c.begin(),c.end()),c.end())\n#define pb push_back\nusing namespace std;\n\nint expr(string& s, int& i);\nint term(string& s, int& i);\nint factor(string& s, int& i);\nint number(string& s, int& i);\n\n\nint expr(string& s, int& i) {\n  int val = term(s, i);\n  while(s[i] == '+' || s[i] == '-') {\n    char op = s[i];\n    i++;\n  \tif(!isdigit(s[i])){\n  \t\ti++;\n  \t\tint val2 = term(s, i);\n  \t\tif(val==1&&val2==0){\n  \t\t\tval=0;\n  \t\t}else{\n  \t\t\tval=1;\n  \t\t}\n  \t}else{\n  \t  int val2 = term(s, i);\n    \tif (op == '+') val |= val2;\n  \t}\n  }\n  return val;\n}\n\nint term(string& s, int& i) {\n  int val = factor(s, i);\n  while(s[i] == '*') {\n    char op = s[i];\n    i++;\n    int val2 = factor(s, i);\n    if (op == '*') val *= val2;\n  }\n  return val;\n}\n\nint factor(string& s, int& i) {\n\tint flag=0;\n\tif(s[i]=='-'){\n\t\tflag=1;\n\t\ti++;\n\t}\n\tif (isdigit(s[i])){\n\t\tif(flag)\n\t\t\treturn flag^number(s, i);\n\t\t\treturn number(s,i);\n\t}\n\n  // ここで構文が正しければ s[i] == '(' となる\n  i++; // '('を読み飛ばす\n  int ret = expr(s, i);\n  i++; // ')'を読み飛ばす\n\tif(flag)\n\treturn flag^ret;\n\treturn ret;\n}\n\nint number(string& s, int& i) {\n  int n = s[i++] - '0';\n  while(isdigit(s[i])) n = n*10 + s[i++] - '0';\n  return n;\n}\n\nint main(){\n\tstring s;\n\twhile(cin>>s,s!=\"#\"){\n\t\tint eq=0;\n\t\tstring a,b;\n\t\tfor(;s[eq]!='=';eq++);\n\t\ta=s.substr(0,eq),b=s.substr(eq+1,s.size()-eq);\n\t\t//cout<<a<<\" \"<<b<<endl;\n\t\tvector<char> ap;\n\t\tfor(int i=0;i<s.size();i++){\n\t\t\tif(isalpha(s[i]))\n\t\t\t\tap.pb(s[i]);\n\t\t}\n\t\tsort(all(ap));\n\t\tuni(ap);\n\t\tbool flag=true;\n\t\tfor(int i=0;i<(1<<ap.size());i++){\n\t\t\tstring x=a,y=b;\n\t\t\tfor(int j=0;j<ap.size();j++){\n\t\t\t\tchar c=ap[j];\n\t\t\t\tbool wh=false;\n\t\t\t\tif((1<<j)&i)\n\t\t\t\t\twh=true;\n\t\t\t\tfor(int k=0;k<x.size();k++){\n\t\t\t\t\tif(x[k]==c){\n\t\t\t\t\t\tif(wh)\n\t\t\t\t\t\t\tx[k]='1';\n\t\t\t\t\t\telse\n\t\t\t\t\t\t\tx[k]='0';\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t\tfor(int k=0;k<y.size();k++){\n\t\t\t\t\tif(y[k]==c){\n\t\t\t\t\t\tif(wh)\n\t\t\t\t\t\t\ty[k]='1';\n\t\t\t\t\t\telse\n\t\t\t\t\t\t\ty[k]='0';\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t}\n\t\t\t\n\t\t\tint i=0,j=0;\n\t\t\tif(expr(x,i)!=expr(y,j)){\n\t\t\t\tcout<<\"NO\"<<endl;\n\t\t\t\tflag=false;\n\t\t\t\tbreak;\n\t\t\t}\n\t\t\t\n\t\t}\n\t\tif(flag)\n\t\t\tcout<<\"YES\"<<endl;\n\t}\n\treturn 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include <iostream>\n#include <string>\n#include <sstream>\n#include <cctype>\n#include <cassert>\n#include <cstdlib>\nusing namespace std;\n\nistringstream iss;\n\nint m;\n\nvoid consume(char expect) {\n  char ch; iss>>ch;\n  if(expect!=ch) {\n    cerr<<\"Error: expect '\"<<expect<<\"' but got '\"<<ch<<\"'\"<<endl;\n    cerr<<\"Rest string is \";\n    string rest;\n    while(!iss.eof()) { iss>>rest; cerr<<rest; }\n    cerr<<endl;\n    exit(EXIT_FAILURE);\n  }\n}\n\nbool formula() {\n  char ch; iss>>ch;\n  \n  if(isalpha(ch)) {\n    if(ch=='T') return true;\n    if(ch=='F') return false;\n    else {\n      return m >> (ch-'a') & 1;\n    }\n  }\n\n  if(ch=='-') return !formula();\n\n  assert(ch=='(');\n  bool f1 = formula();\n  iss >> ch;\n  if(ch=='-') consume('>');\n  bool f2 = formula();\n  consume(')');\n  if(ch=='*') return f1&&f2;\n  if(ch=='+') return f1||f2;\n  return f1<=f2;\n}\n\nbool solve(const string &input) {\n  for(m = 0; m < (1<<11); m++) {\n    iss.clear(); iss.str(input);\n    bool left=formula();\n    consume('=');\n    bool right=formula();\n    if(left!=right) { return false; }\n  }\n  return true;\n}\n\nint main() {\n  string str;\n  \n  while(getline(cin,str), str!=\"#\") {\n    cout << (solve(str) ? \"YES\" : \"NO\") << endl;\n  }\n\n  return 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include <iostream>\n#include <stdio.h>\n#include <algorithm>\n#include <vector>\n#include <queue>\n#include <numeric>\n#include <string>\n#include <string.h>\n#include <map>\n#include <set>\n#include <functional>\n#include <complex>\n#include <stack>\n#include <tuple>\n\n#define ll long long int\n\nusing namespace std;\n\nconst int INF = (1<<30) - 1;\n\nbool formula(string str, int &vals){\n    char c = str[0];\n    \n    if(c == 'T')\n        return true;\n    else if(c == 'F')\n        return false;\n    \n    if('a'<=c && c<='k')\n        return vals>>(c-'a')&1;\n    \n    //substr???string &?????¨NG?\n    if(c == '-')\n        return !formula(str.substr(1, str.size()-1), vals);\n\n    //c == '('\n    int count = 0;\n    for(int i=1; i<str.size(); i++){\n        char c = str[i];\n        \n        if(c == '(')\n            count++;\n        if(c == ')')\n            count--;\n        if(count == 0){\n            if(c == '*'){\n                string left = str.substr(1, i-1);\n                string right = str.substr(i+1, str.size()-i-2);\n                return formula(left, vals) && formula(right, vals);\n            }\n            if(c == '+'){\n                string left = str.substr(1, i-1);\n                string right = str.substr(i+1, str.size()-i-2);\n                return formula(left, vals) || formula(right, vals);\n            }\n            if(str[i] == '-' && str[i+1] == '>'){\n                string left = str.substr(1, i-1);\n                string right = str.substr(i+2, str.size()-i-3);\n                return !(formula(left, vals)) || formula(right, vals);\n            }\n        }\n    }\n    //No Implement\n    return true;\n}\n\nint main(){\n    ios::sync_with_stdio(false);\n    cin.tie(0);\n    \n    string equation;\n    while(cin>>equation, equation!=\"#\"){\n        int s = equation.find(\"=\");\n        string left = equation.substr(0, s);\n        string right = equation.substr(s+1, equation.size()-s-1);\n        \n        bool is_identity = true;\n        for(int i=0; i<1<<11; i++){\n            is_identity &= formula(left, i)==formula(right, i);\n        }\n            \n        cout << (is_identity ? \"YES\" : \"NO\") << endl;\n    }\n    return 0;\n}"
  },
  {
    "language": "C++",
    "code": "#define _USE_MATH_DEFINES\n#define INF 0x3f3f3f3f\n\n#include <iostream>\n#include <cstdio>\n#include <sstream>\n#include <cmath>\n#include <cstdlib>\n#include <algorithm>\n#include <queue>\n#include <stack>\n#include <limits>\n#include <map>\n#include <string>\n#include <cstring>\n#include <set>\n#include <deque>\n#include <bitset>\n#include <list>\n#include <cctype>\n#include <utility>\n  \nusing namespace std;\n  \ntypedef long long ll;\ntypedef pair <int,int> P;\ntypedef pair <int,P> PP;\n  \nstatic const double EPS = 1e-8;\n  \nstatic const int tx[] = {0,1,0,-1};\nstatic const int ty[] = {-1,0,1,0};\n\nstruct ParseInfo {\n  int pos;\n  bool val;\n};\n\nset<char> char_set;\nbool char_table[256];\n\nParseInfo parse_formula(int pos, const string& str){\n\n  if('a' <= str[pos] && str[pos] <= 'k'){\n    bool val = false;\n    ParseInfo pi = {pos+1,val};\n    return pi;\n  }\n\n  else if(str[pos] == 'T'){\n    bool val = true;\n    ParseInfo pi = {pos+1,val};\n    return pi;\n  }\n\n  else if(str[pos] == 'F'){\n    bool val = false;\n    ParseInfo pi = {pos+1,val};\n    return pi;\n  }\n\n  else if(str[pos] == '-'){\n    ParseInfo pi = parse_formula(pos+1,str);\n    pi.val = ~pi.val;\n    return pi;\n  }\n\n  else if(str[pos] == '('){\n    ParseInfo pi1 = parse_formula(pos+1,str);\n    if(str[pi1.pos] == '*'){\n      ParseInfo pi2 = parse_formula(pi1.pos+1,str);\n      pi2.val = (pi1.val && pi2.val);\n      \n      //skip ')'\n      pi2.pos++;\n      return pi2;\n    }\n    else if(str[pi1.pos] == '+'){\n      ParseInfo pi2 = parse_formula(pi1.pos+1,str);\n      pi2.val = (pi1.val || pi2.val);\n\n      //skip ')'\n      pi2.pos++;\n      return pi2;\n    }\n    else if(str[pi1.pos] == '-'\n\t    && str[pi1.pos+1] == '>'){\n      ParseInfo pi2 = parse_formula(pi1.pos+2,str);\n      pi2.val = (~pi1.val || pi2.val);\n\n      //skip ')'\n      pi2.pos++;\n      return pi2;\n    }\n  }\n}\n\nParseInfo parse_equation(int pos, const string& str){\n  ParseInfo pi1 = parse_formula(pos,str);\n  \n  //skip '='\n  ParseInfo pi2 = parse_formula(pi1.pos+1,str);\n  pi2.val = (pi1.val == pi2.val) ? true : false;\n  return pi2;\n}\n\n\nint main(){\n  string str;\n  while(cin >> str){\n    if(str == \"#\") break;\n\n\n    for(int i=0;i<str.size();i++){\n      if('a' <= str[i] && str[i] <= 'k'){\n\tchar_set.insert(str[i]);\n      }\n    }\n\n    int idx = 0;\n    bool isok = true;\n    for(int S=0;S<=(1<<(char_set.size()-1));S++){\n      for(set<char>::iterator it = char_set.begin();\n\t  it != char_set.end();\n\t  it++){\n\tchar_table[*it] = (S & (1<<idx));\n\tidx++;\n      }\n      ParseInfo pi = parse_equation(0,str);\n      if(!pi.val) isok = false;\n    }\n    printf(\"%s\\n\",isok ? \"YES\" : \"NO\");\n  }\n}"
  },
  {
    "language": "C++",
    "code": "#include<string>\n#define MAX 13\nusing namespace std;\nbool o;\nvoid rec(string s){\n  if(!o) return;\n  //cout << s << endl;\n  bool f;\n  int p;\n  while(s.find(\"-0\")!=-1){\n    p=s.find(\"-0\");\n    s[p]='1';s[p+1]=' ';\n    f=true;\n  }\n  while(s.find(\"-1\")!=-1){\n    p=s.find(\"-1\");\n    s[p]='0';s[p+1]=' ';\n    f=true;\n  }\n  while(s.find(\"(0*0)\")!=-1){\n    p=s.find(\"(0*0)\");\n    s[p]='0';s[p+1]=' ';s[p+2]=' ';s[p+3]=' ';s[p+4]=' ';\n    f=true;\n  }\n  while(s.find(\"(0*1)\")!=-1){\n    p=s.find(\"(0*1)\");\n    s[p]='0';s[p+1]=' ';s[p+2]=' ';s[p+3]=' ';s[p+4]=' ';\n    f=true;\n  }\n  while(s.find(\"(1*0)\")!=-1){\n    p=s.find(\"(1*0)\");\n    s[p]='0';s[p+1]=' ';s[p+2]=' ';s[p+3]=' ';s[p+4]=' ';\n    f=true;\n  }\n  while(s.find(\"(1*1)\")!=-1){\n    p=s.find(\"(1*1)\");\n    s[p]='1';s[p+1]=' ';s[p+2]=' ';s[p+3]=' ';s[p+4]=' ';\n    f=true;\n  }\n  while(s.find(\"(0+0)\")!=-1){\n    p=s.find(\"(0+0)\");\n    s[p]='0';s[p+1]=' ';s[p+2]=' ';s[p+3]=' ';s[p+4]=' ';\n    f=true;\n  }\n  while(s.find(\"(0+1)\")!=-1){\n    p=s.find(\"(0+1)\");\n    s[p]='1';s[p+1]=' ';s[p+2]=' ';s[p+3]=' ';s[p+4]=' ';\n    f=true;\n  }\n  while(s.find(\"(1+0)\")!=-1){\n    p=s.find(\"(1+0)\");\n    s[p]='1';s[p+1]=' ';s[p+2]=' ';s[p+3]=' ';s[p+4]=' ';\n    f=true;\n  }\n  while(s.find(\"(1+1)\")!=-1){\n    p=s.find(\"(1+1)\");\n    s[p]='1';s[p+1]=' ';s[p+2]=' ';s[p+3]=' ';s[p+4]=' ';\n    f=true;\n  }\n  while(s.find(\"(0->0)\")!=-1){\n    p=s.find(\"(0->0)\");\n    s[p]='1';s[p+1]=' ';s[p+2]=' ';s[p+3]=' ';s[p+4]=' ';s[p+5]=' ';\n    f=true;\n  }\n  while(s.find(\"(0->1)\")!=-1){\n    p=s.find(\"(0->1)\");\n    s[p]='1';s[p+1]=' ';s[p+2]=' ';s[p+3]=' ';s[p+4]=' ';s[p+5]=' ';\n    f=true;\n  }\n  while(s.find(\"(1->0)\")!=-1){\n    p=s.find(\"(1->0)\");\n    s[p]='0';s[p+1]=' ';s[p+2]=' ';s[p+3]=' ';s[p+4]=' ';s[p+5]=' ';\n    f=true;\n  }\n  while(s.find(\"(1->1)\")!=-1){\n    p=s.find(\"(1->1)\");\n    s[p]='1';s[p+1]=' ';s[p+2]=' ';s[p+3]=' ';s[p+4]=' ';s[p+5]=' ';\n    f=true;\n  }\n  if(f){\n    string b;\n    for(int i=0;i<s.size();i++) if(s[i]!=' ') b+=s[i];\n    rec(b);\n  }else{\n    if(s[0]!=s[2]) o=false;\n    return;\n  }\n}\nvoid init(int n,string s){\n  int i,j;\n  for(i=0;i<s.size();i++){\n    for(j=0;j<=MAX;j++){\n      if(s[i]=='a'+j) s[i]='0'+(n>>j&1);\n      if(s[i]=='T') s[i]='1';\n      if(s[i]=='F') s[i]='0';\n    }\n  }\n  rec(s);\n}\nint main(){\n  string s;\n  while(cin >> s,s!=\"#\"){\n    o=true;\n    int i;\n    for(i=0;i<(1<<MAX);i++)\n      init(i,s);\n    cout << (o?\"YES\":\"NO\") << endl;\n  }\n  return 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include <algorithm>\n#include <iostream>\n#include <vector>\n#include <string>\n#include <cctype>\nusing namespace std;\n\nint mask;\n\ntemplate<class T> struct Parser {\n    typedef string::const_iterator State;\n\n    T solve(const string &S) {\n        State begin = S.begin();\n        return equation(begin);\n    }\n\n    // <equation> ::= <formula> \"=\" <formula>\n    T equation(State &begin) {\n        T left = formula(begin);\n        begin++;    // skip '='\n        T right = formula(begin);\n        return left == right;\n    }\n\n    // <formula> ::= <boolean> |\n    // \"-\" <formula> |\n    // \"(\" <formula> \"*\" <formula> \")\" |\n    // \"(\" <formula> \"+\" <formula> \")\" |\n    // \"(\" <formula> \"->\" <formula> \")\"\n    T formula(State &begin) {\n        if (*begin == '(') {\n            begin++;                    // skip '('\n            T left = formula(begin);\n            char op = *begin;\n            begin++;                    // skip '*' or '+' or '-'\n            if (op == '-') begin++;     // skip '>'\n            T right = formula(begin);\n            begin++;                    // skip ')'\n            T ret = deduce(left, op, right);\n            return ret;\n        } else if (*begin == '-') {\n            begin++;    // skip '-'\n            return !formula(begin);\n        } else {\n            return boolean(begin);\n        }\n    }\n\n    T deduce(T x, char op, T y) {\n        if (op == '*') {\n            return x and y;\n        } else if (op == '+') {\n            return x or y;\n        } else {    // \"->\"\n            return !x or y;\n        }\n    }\n\n    // <boolean> ::= \"T\" | \"F\" |\n    // \"a\" | \"b\" | \"c\" | \"d\" | \"e\" | \"f\" |\n    // \"g\" | \"h\" | \"i\" | \"j\" | \"k\" |\n    T boolean(State &begin) {\n        T ret;\n        if (*begin == 'T') ret = 1;\n        else if (*begin == 'F') ret = 0;\n        else ret = (mask >> (*begin - 'a')) & 1;\n        begin++;\n        return ret;\n    }\n};\n\nvoid solve(string S) {\n    // 恒等式とは，式に現れる変数がどのような値であっても成立する等式のことである．\n    Parser<bool> ps;\n    for (mask = 0; mask < (1 << 11); mask++) {\n        if (!ps.solve(S)) {\n            cout << \"NO\" << endl;\n            return ;\n        }\n    }\n    cout << \"YES\" << endl;\n}\n\nint main() {\n    string S;\n    while (cin >> S && S != \"#\") {\n        solve(S);\n    }\n    return 0;\n}\n"
  },
  {
    "language": "C++",
    "code": "// 2401.cpp : コンソール アプリケーションのエントリ ポイントを定義します。\n//\n\n//#include \"stdafx.h\"\n\n#include<iostream>\n#include<string>\n#include <map>\n \n \nusing namespace std;\nbool arg[11];\n \ntypedef pair<bool,int> BI;\n \nBI next(string s){\n    switch(s[0]){\n        case '-':\n                {\n                        BI sub=next(s.substr(1));\n                        return BI(!sub.first,sub.second+1);\n                }\n        case '(':\n                {\n                        BI sub1=next(s.substr(1));\n                        char op=s[sub1.second+1];\n                        int len=op=='-'?2:1;\n                        BI sub2=next(s.substr(sub1.second+1+len));\n                        return BI(op=='*'?sub1.first&&sub2.first:\n                                op=='+'?sub1.first||sub2.first:\n                                !sub1.first||sub2.first,1+sub1.second+len+sub2.second+1);\n                }\n        case 'T':\n        case 'F':\n                return BI(s[0]=='T',1);\n        default:\n                break;\n        }\n        return BI(arg[s[0]-'a'],1);\n \n}\n \nint main(){\n        string str;\n        while(cin>>str&&str!=\"#\"){\n                bool ok=true;\n                for(int i=0;i<1<<11;i++){\n                        for(int j=0;j<11;j++){\n                                arg[j]=(i&(1<<j))!=0;\n                        }\n                        BI sub1=next(str);\n                        BI sub2=next(str.substr(sub1.second+1));\n                        if(sub1.first!=sub2.first){\n                                ok=false;\n                                break;\n                        }\n                }\n                cout<<(ok?\"YES\":\"NO\")<<endl;\n        }\n        return 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\nusing namespace std;\nconst int dx[]={1,0,0,-1,1,-1,-1,1};\nconst int dy[]={0,1,-1,0,1,1,-1,-1};\nconst int INF = 1<<30;\nconst double EPS = 1e-8;\n#define PB push_back\n#define mk make_pair\n#define fr first\n#define sc second\n#define reps(i,j,k) for(int i = (j); i < (k); ++i)\n#define rep(i,j) reps(i,0,j)\n#define MOD 1000000007\n#define lengthof(x) (sizeof(x) / sizeof(*(x)))\ntypedef vector<int> vi;\ntypedef vector<vi> vvi;\ntypedef pair<int,int> Pii;\ntypedef pair<int,vi > P;\ntypedef long long ll;\nbool number(string& ,int& );\nbool rev(string& ,int& );\nbool term(string& ,int& );\nbool expr(string& ,int& );\nbool number(string &s,int& i){\n\tif(s[i++] == 'T'){\n\t\treturn true;\n\t}\n\telse{\n\t\treturn false;\n\t}\n}\nbool rev(string& s,int& i){\n\tif(isalpha(s[i]))return number(s,i);\n\tif(s[i] == '-'){\n\t\twhile(s[i] == '-'){\n\t\t\ti++;\n\t\t\treturn !rev(s,i);\n\t\t}\n\t}\n\ti++;\n\tbool ret = expr(s,i);\n\ti++;\n\treturn ret;\n}\nbool term(string& s ,int& i){\n\tbool val = rev(s,i);\n\twhile(s[i] == '+' || s[i] == '*' || s[i] == '&'){\n\t\tchar op = s[i];\n\t\ti++;\n\t\tbool val2 = rev(s,i);\n\t\tif(op == '+'){\n\t\t\tval |= val2;\n\t\t}\n\t\telse if(op == '*'){\n\t\t\tval &= val2;\n\t\t}\n\t\telse if(op == '&'){\n\t\t\tval = !(val & !val2);\n\t\t}\n\t}\n\treturn val;\n}\nbool expr(string& s,int& i){\n\tbool val = term(s,i);\n\treturn val;\n}\nmap < string , int > memo;\nbool select(string a,string b,int depth){\n\tbool ans = false;\n\tif(depth == 11){\n\t\tif(memo[a+b])return (bool)(1-memo[a+b]);\n\t\t//cout << a << \" \" << b << \" \";\n\t\tint idx = 0;\n\t\tbool p = expr(a,idx);\n\t\t//cout << \"*\" << idx << \" \";\n\t\tidx = 0;\n\t\tbool q = expr(b,idx);\n\t\t//cout << \"*\" << idx << \" \";\n\t\t//cout << p << \" \" << q  << \"\\n\";\n\t\tans |= !(p==q);\n\t\tmemo[a+b] = 1+(int)ans;\n\t\treturn ans;\n\t}\n\tstring aT,aF;\n\taT = \"\";\n\taF = \"\";\n\trep(i,a.size()){\n\t\tif(a[i] == depth+'a'){\n\t\t\taT += \"T\";\n\t\t\taF += \"F\";\n\t\t}\n\t\telse{\n\t\t\taT += a[i];\n\t\t\taF += a[i];\n\t\t}\n\t}\n\tstring bT,bF;\n\tbT = \"\";\n\tbF = \"\";\n\trep(i,b.size()){\n\t\tif(b[i] == depth+'a'){\n\t\t\tbT += \"T\";\n\t\t\tbF += \"F\";\n\t\t}\n\t\telse{\n\t\t\tbT += b[i];\n\t\t\tbF += b[i];\n\t\t}\n\t}\n\tans |= select(aT,bT,depth+1);\n\tans |= select(aF,bF,depth+1);\n\treturn ans;\n}\nint main(){\n\tstring tmp;\n\twhile(true){\n\t\tmemo.clear();\n\t\tstring a;\n\t\tstring b;\n\t\tcin >> tmp;\n\t\tif(tmp == \"#\")break;\n\t\t\n\t\tint idx = 0;\n\t\twhile(tmp[idx] != '='){\n\t\t\tif(tmp[idx] == '-' && tmp[idx+1] == '>'){\n\t\t\t\ta += \"&\";\n\t\t\t\tidx+=2;\n\t\t\t\tcontinue;\n\t\t\t}\n\t\t\ta += tmp[idx]; \n\t\t\tidx++;\n\t\t}\n\t\treps(i,idx+1,tmp.size()){\n\t\t\tif(tmp[i] == '-' && tmp[idx+1] == '>'){\n\t\t\t\tb += \"&\";\n\t\t\t\ti++;\n\t\t\t\tcontinue;\n\t\t\t}\n\t\t\tb += tmp[i];\n\t\t}\n\t\t!select(a,b,0) ? puts(\"YES\") : puts(\"NO\");\n\t}\n    return 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include<iostream>\n#include<string>\n#include<map>\n#include<sstream>\n#include<cctype>\n#include<algorithm>\nusing namespace std;\ntypedef string::const_iterator Cursol;\nbool ok;\nint bit;\nbool Formula(Cursol &c){\n  bool ret;\n  char z = *c++;\n\n  if(z == 'T'){\n    ret = true;\n  }else if(z == 'F'){\n    ret = false;\n  }else if(islower(z)){\n    ret = bit >> ((z) - 'a') & 1;\n  }else if(z == '-'){\n    return !Formula(c);\n  }else if(z == '('){\n    ret = Formula(c);\n    z = *c++;\n    if(z == '+'){\n      ret |= Formula(c);\n    }else if(z == '*'){\n      ret &= Formula(c);\n    }else if(z == '-'){ //->\n      c++;\n      ret = !ret | Formula(c);\n    }\n    c++;\n  }\n  // cout << ret << endl;\n  return ret;\n}\nint main(){\n  string s;\n  Cursol c;\n  while(cin >> s , ok = true, s != \"#\"){\n    string l = s.substr(0,s.find('='));\n    string r = s.substr(s.find('=')+1);\n\n    for(bit = 0 ; bit < (1 << 11) ; bit++ ){\n      c = l.begin();\n      bool java = Formula(c);\n      c = r.begin();\n      if( java != Formula(c) ){\n\tok = false;\n\tbreak;\n      }\n    }\n    if(ok) cout << \"YES\" << endl;\n    else cout << \"NO\" << endl;\n  }\n}"
  },
  {
    "language": "C++",
    "code": "//include\n//------------------------------------------\n#include <vector>\n#include <list>\n#include <map>\n#include <set>\n#include <deque>\n#include <stack>\n#include <bitset>\n#include <algorithm>\n#include <functional>\n#include <numeric>\n#include <utility>\n#include <sstream>\n#include <iostream>\n#include <iomanip>\n#include <cstdio>\n#include <cmath>\n#include <cstdlib>\n#include <cctype>\n#include <string>\n#include <cstring>\n#include <ctime>\n#include <climits>\n#include <queue>\n\nusing namespace std;\n\n//typedef\n//------------------------------------------\ntypedef vector<int> VI;\ntypedef vector<VI> VVI;\ntypedef vector<string> VS;\ntypedef pair<int, int> PII;\ntypedef long long LL;\n\n//container util\n//------------------------------------------\n#define ALL(a)  (a).begin(),(a).end()\n#define RALL(a) (a).rbegin(), (a).rend()\n#define PB push_back\n#define MP make_pair\n#define SZ(a) int((a).size())\n#define EACH(i,c) for(typeof((c).begin()) i=(c).begin(); i!=(c).end(); ++i)\n#define EXIST(s,e) ((s).find(e)!=(s).end())\n#define SORT(c) sort((c).begin(),(c).end())\n\n//repetition\n//------------------------------------------\n#define FOR(i,a,b) for(int i=(a);i<(b);++i)\n#define REP(i,n)  FOR(i,0,n)\n\n//constant\n//--------------------------------------------\nconst double EPS = 1e-10;\nconst double PI  = acos(-1.0);\n\nstring str;\nvector<bool> ass;\nbool calc(int a,int b, const string& str){\n  switch(str[a]){\n  case '-':\n\treturn !calc(a+1, b, str);\n  case 'T':\n\treturn true;\n  case 'F':\n\treturn false;\n  case '(':\n\tint cnt = 0;\n\tfor(int i=a+1;i<b-1;++i){\n\t  if(str[i] == '(') ++cnt;\n\t  else if(str[i] == ')') --cnt;\n\t  else if(cnt == 0){\n\t\tif(str[i] == '*') return calc(a+1, i, str) && calc(i+1, b, str);\n\t\telse if(str[i] == '+') return calc(a+1, i, str) || calc(i+1, b, str);\n\t\telse if(i+1<b-1 && str[i] == '-' && str[i+1] == '>')\n\t\t  return !calc(a+1, i, str) || calc(i+2, b, str);\n\t  }\n\t}\n  }\n  \n  return false;\n}\n\nbool dfs(int i){\n  if(i == 12){\n\tstring rep = str;\n\tint div;\n\tfor(int i=0;i<SZ(rep);++i){\n\t  if('a' <= rep[i] && rep[i] <= 'k')\n\t\trep[i] = (ass[rep[i]-'a']? 'T': 'F');\n\t  if(rep[i] == '=') div = i;\n\t}\n\tstring fr = rep.substr(0,div), bc = rep.substr(div+1);\n\treturn calc(0, SZ(fr), fr) == calc(0, SZ(bc), bc);\n  }\n  ass[i] = true;\n  if(!dfs(i+1)) return false;\n  ass[i] = false;\n  return dfs(i+1);\n}\n\nint main(){\n  cin.tie(0);\n  ios_base::sync_with_stdio(false);\n\n  while(cin >> str, str!=\"#\"){\n\tass.assign(12, false);\n\tcout << (dfs(0)? \"YES\": \"NO\") << endl;\n  }\n\n  return 0;\n}"
  },
  {
    "language": "C++",
    "code": "// clang-format off\n#include <bits/stdc++.h>\n#define int long long\n#define main signed main()\n#define loop(i, a, n) for (int i = (a); i < (n); i++)\n#define rep(i, n) loop(i, 0, n)\n#define forever for (;;)\n#define all(v) (v).begin(), (v).end()\n#define rall(v) (v).rbegin(), (v).rend()\n#define prec(n) fixed << setprecision(n)\ntemplate<typename A> using V = std::vector<A>;\ntemplate<typename A> using F = std::function<A>;\ntemplate<typename A, typename B> using P = std::pair<A, B>;\nusing pii = P<int, int>;\nusing vi = V<int>;\nusing vd = V<double>;\nusing vs = V<std::string>;\nusing vpii = V<pii>;\nusing vvi = V<vi>;\nusing vvpii = V<vpii>;\nconstexpr int INF = sizeof(int) == sizeof(long long) ? 1000000000000000000LL : 1000000000;\nconstexpr int MOD = 1000000007;\nconstexpr double PI = acos(-1);\ntemplate<typename A, typename B> bool cmin(A &a, const B &b) { return a > b ? (a = b, true) : false; }\ntemplate<typename A, typename B> bool cmax(A &a, const B &b) { return a < b ? (a = b, true) : false; }\nconstexpr bool odd(const int &n) { return n & 1; }\nconstexpr bool even(const int &n) { return ~n & 1; }\ntemplate<typename T> std::istream &operator>>(std::istream &is, std::vector<T> &v) { for (T &x : v) is >> x; return is; }\ntemplate<typename A, typename B> std::istream &operator>>(std::istream &is, std::pair<A, B> &p) { is >> p.first; is >> p.second; return is; }\nusing namespace std;\n// clang-format on\n\ntemplate<typename T> struct ParseResult {\n  bool succeeded;\n  T object;\n  int pos;\n  ParseResult(const bool succeeded, const T &object, const int pos) : succeeded(succeeded), object(object), pos(pos) {}\n  friend std::ostream &operator<<(std::ostream &os, const ParseResult<T> &p) { return os << '{' << (p.succeeded ? \"true\" : \"false\") << ',' << p.object << ',' << p.pos << '}'; }\n};\n\ntemplate<typename T> using Parser = std::function<ParseResult<T>(std::string, int)>;\n\nParser<std::string> token(const std::string &s) {\n  const int n = s.size();\n  return [n = std::move(n), s = std::move(s)](const std::string &target, const int pos) {\n    if (target.size() < n) return ParseResult<std::string>(false, {}, pos);\n    return target.substr(pos, n) == s ? ParseResult<std::string>(true, s, pos + n) : ParseResult<std::string>(false, {}, pos);\n  };\n}\n\ntemplate<typename T> Parser<T> operator||(const Parser<T> &p1, const Parser<T> &p2) {\n  return [p1 = std::move(p1), p2 = std::move(p2)](const std::string &target, const int pos) {\n    auto r = p1(target, pos);\n    if (r.succeeded) return r;\n    r = p2(target, pos);\n    if (r.succeeded) return r;\n    return ParseResult<T>(false, {}, pos);\n  };\n}\n\ntemplate<typename T1, typename T2> Parser<std::pair<T1, T2>> operator+(const Parser<T1> &p1, const Parser<T2> &p2) {\n  return [p1 = std::move(p1), p2 = std::move(p2)](const std::string &target, const int pos) {\n    auto r1 = p1(target, pos);\n    if (!r1.succeeded) return ParseResult<std::pair<T1, T2>>(false, {}, pos);\n    auto r2 = p2(target, r1.pos);\n    if (!r2.succeeded) return ParseResult<std::pair<T1, T2>>(false, {}, pos);\n    return ParseResult<std::pair<T1, T2>>(true, {r1.object, r2.object}, r2.pos);\n  };\n}\n\ntemplate<typename T1, typename T2> Parser<T2> operator>>(const Parser<T1> &p1, const Parser<T2> &p2) {\n  return [p1 = std::move(p1), p2 = std::move(p2)](const std::string &target, const int pos) {\n    auto r1 = p1(target, pos);\n    if (!r1.succeeded) return ParseResult<T2>(false, {}, pos);\n    auto r2 = p2(target, r1.pos);\n    if (!r2.succeeded) return ParseResult<T2>(false, {}, pos);\n    return ParseResult<T2>(true, r2.object, r2.pos);\n  };\n}\n\ntemplate<typename T1, typename T2> Parser<T1> operator<<(const Parser<T1> &p1, const Parser<T2> &p2) {\n  return [p1 = std::move(p1), p2 = std::move(p2)](const std::string &target, const int pos) {\n    auto r1 = p1(target, pos);\n    if (!r1.succeeded) return ParseResult<T1>(false, {}, pos);\n    auto r2 = p2(target, r1.pos);\n    if (!r2.succeeded) return ParseResult<T1>(false, {}, pos);\n    return ParseResult<T1>(true, r1.object, r2.pos);\n  };\n}\n\nParser<char> oneOf(const std::string &s) {\n  std::unordered_set<char> d;\n  for (auto &c : s) d.insert(c);\n  return [d = std::move(d)](const std::string &target, const int pos) {\n    if (target.size() <= pos) return ParseResult<char>(false, {}, pos);\n    char c = target[pos];\n    return d.count(c) ? ParseResult<char>(true, c, pos + 1) : ParseResult<char>(false, {}, pos);\n  };\n}\n\ntemplate<typename T, typename S, typename F> Parser<S> fmap(const Parser<T> &p, const F &f) {\n  return [p = std::move(p), f = std::move(f)](const std::string &target, const int pos) {\n    auto r = p(target, pos);\n    return r.succeeded ? ParseResult<S>(true, f(r.object), r.pos) : ParseResult<S>(false, {}, r.pos);\n  };\n}\n\ntemplate<typename T, typename F> Parser<T> lazy(const F &f) {\n  bool instantiated = false;\n  Parser<T> p;\n  return [f = std::move(f), p = std::move(p), instantiated = std::move(instantiated)](const std::string &target, const int pos) mutable {\n    if (!instantiated) {\n      p = f();\n      instantiated = true;\n    }\n    return p(target, pos);\n  };\n}\n\nstruct SyntaxTree {\n  string op;\n  char value;\n  vector<SyntaxTree> children;\n  SyntaxTree() {}\n  SyntaxTree(const string &op, const char value, const vector<SyntaxTree> &children) : op(op), value(value), children(children) {}\n};\n\nmain {\n  Parser<SyntaxTree> formulaP = lazy<SyntaxTree>([&]() {\n    auto andP = fmap<pair<SyntaxTree, SyntaxTree>, SyntaxTree>((token(\"(\") >> formulaP << token(\"*\")) + (formulaP << token(\")\")), [](auto &o) { return SyntaxTree(\"*\", {}, {o.first, o.second}); });\n    auto orP = fmap<pair<SyntaxTree, SyntaxTree>, SyntaxTree>((token(\"(\") >> formulaP << token(\"+\")) + (formulaP << token(\")\")), [](auto &o) { return SyntaxTree(\"+\", {}, {o.first, o.second}); });\n    auto impP = fmap<pair<SyntaxTree, SyntaxTree>, SyntaxTree>((token(\"(\") >> formulaP << token(\"->\")) + (formulaP << token(\")\")), [](auto &o) { return SyntaxTree(\"->\", {}, {o.first, o.second}); });\n    auto notP = fmap<SyntaxTree, SyntaxTree>(token(\"-\") >> formulaP, [](auto &o) { return SyntaxTree(\"-\", {}, {o}); });\n    auto valP = fmap<char, SyntaxTree>(oneOf(\"abcdefghijkTF\"), [](char x) { return SyntaxTree({}, x, {}); });\n    return andP || orP || impP || notP || valP;\n  });\n  auto equationP = (formulaP << token(\"=\")) + formulaP;\n  string s;\n  while (cin >> s, s != \"#\") {\n    s = regex_replace(s, regex(\"(--)+\"), \"\");\n    auto r = equationP(s, 0);\n    bool isValid = true;\n    rep(i, 1 << 11) {\n      auto toBool = [&](char c) -> bool {\n        if (c == 'T') return true;\n        if (c == 'F') return false;\n        return i >> (c - 'a') & 1;\n      };\n      F<bool(SyntaxTree)> eval = [&](const SyntaxTree &f) {\n        switch (f.children.size()) {\n          case 0: return toBool(f.value);\n          case 1: return !eval(f.children[0]);\n          case 2:\n            if (f.op == \"*\") return eval(f.children[0]) && eval(f.children[1]);\n            if (f.op == \"+\") return eval(f.children[0]) || eval(f.children[1]);\n            if (f.op == \"->\") return !eval(f.children[0]) || eval(f.children[1]);\n        }\n      };\n      isValid &= eval(r.object.first) == eval(r.object.second);\n    }\n    cout << (isValid ? \"YES\" : \"NO\") << endl;\n  }\n}"
  },
  {
    "language": "C++",
    "code": "#include<iostream>\n#include<string>\n#define MAX 11\nusing namespace std;\nbool o;\nvoid rec(string s){\n  if(!o) return;\n  //cout << s << endl;\n  bool f;\n  int p;\n\n  \n  while(s.find(\"-0\")!=-1){\n    p=s.find(\"-0\");\n    s[p]='1';s[p+1]=' ';\n    f=true;\n  }\n  while(s.find(\"-1\")!=-1){\n    p=s.find(\"-1\");\n    s[p]='0';s[p+1]=' ';\n    f=true;\n  }\n  /*\n  while(s.find(\"(0*0)\")!=-1){\n    p=s.find(\"(0*0)\");\n    s[p]='0';s[p+1]=' ';s[p+2]=' ';s[p+3]=' ';s[p+4]=' ';\n    f=true;\n  }\n  while(s.find(\"(0*1)\")!=-1){\n    p=s.find(\"(0*1)\");\n    s[p]='0';s[p+1]=' ';s[p+2]=' ';s[p+3]=' ';s[p+4]=' ';\n    f=true;\n  }\n  while(s.find(\"(1*0)\")!=-1){\n    p=s.find(\"(1*0)\");\n    s[p]='0';s[p+1]=' ';s[p+2]=' ';s[p+3]=' ';s[p+4]=' ';\n    f=true;\n  }\n  while(s.find(\"(1*1)\")!=-1){\n    p=s.find(\"(1*1)\");\n    s[p]='1';s[p+1]=' ';s[p+2]=' ';s[p+3]=' ';s[p+4]=' ';\n    f=true;\n  }\n  while(s.find(\"(0+0)\")!=-1){\n    p=s.find(\"(0+0)\");\n    s[p]='0';s[p+1]=' ';s[p+2]=' ';s[p+3]=' ';s[p+4]=' ';\n    f=true;\n  }\n  while(s.find(\"(0+1)\")!=-1){\n    p=s.find(\"(0+1)\");\n    s[p]='1';s[p+1]=' ';s[p+2]=' ';s[p+3]=' ';s[p+4]=' ';\n    f=true;\n  }\n  while(s.find(\"(1+0)\")!=-1){\n    p=s.find(\"(1+0)\");\n    s[p]='1';s[p+1]=' ';s[p+2]=' ';s[p+3]=' ';s[p+4]=' ';\n    f=true;\n  }\n  while(s.find(\"(1+1)\")!=-1){\n    p=s.find(\"(1+1)\");\n    s[p]='1';s[p+1]=' ';s[p+2]=' ';s[p+3]=' ';s[p+4]=' ';\n    f=true;\n  }\n  /*\n  while(s.find(\"(0->0)\")!=-1){\n    p=s.find(\"(0->0)\");\n    s[p]='1';s[p+1]=' ';s[p+2]=' ';s[p+3]=' ';s[p+4]=' ';s[p+5]=' ';\n    f=true;\n  }\n  while(s.find(\"(0->1)\")!=-1){\n    p=s.find(\"(0->1)\");\n    s[p]='1';s[p+1]=' ';s[p+2]=' ';s[p+3]=' ';s[p+4]=' ';s[p+5]=' ';\n    f=true;\n  }\n  while(s.find(\"(1->0)\")!=-1){\n    p=s.find(\"(1->0)\");\n    s[p]='0';s[p+1]=' ';s[p+2]=' ';s[p+3]=' ';s[p+4]=' ';s[p+5]=' ';\n    f=true;\n  }\n  while(s.find(\"(1->1)\")!=-1){\n    p=s.find(\"(1->1)\");\n    s[p]='1';s[p+1]=' ';s[p+2]=' ';s[p+3]=' ';s[p+4]=' ';s[p+5]=' ';\n    f=true;\n  }\n  */\n  if(f){\n    string b;\n    for(int i=0;i<s.size();i++) if(s[i]!=' ') b+=s[i];\n    rec(b);\n  }else{\n    if(s[0]!=s[2]) o=false;\n    return;\n  }\n}\nvoid init(int n,string s){\n  int i,j;\n  for(i=0;i<s.size();i++){\n    for(j=0;j<=MAX;j++){\n      if(s[i]=='a'+j) s[i]='0'+(n>>j&1);\n      if(s[i]=='T') s[i]='1';\n      if(s[i]=='F') s[i]='0';\n    }\n  }\n  rec(s);\n}\nint main(){\n  string s;\n  while(cin >> s,s!=\"#\"){\n    o=true;\n    int i;\n    for(i=0;i<(1<<MAX);i++)\n      init(i,s);\n    cout << (o?\"YES\":\"NO\") << endl;\n  }\n  return 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include <iostream>\n#include <vector>\n#include <algorithm>\n#include <string>\n#include <sstream>\n#include <cstring>\n#include <cstdlib>\n#include <cstdio>\n#include <cmath>\n#include <queue>\n#include <stack>\n#include <map>\n#include <set>\n#include <bitset>\n \n#define rep(i, n) for(int i = 0; i < (n); i++)\n#define FOR(i, a, b) for(int i = (a); i < (b); i++)\n#define all(v) (v).begin(), (v).end()\n#define rev(s) (s).rbegin(), (s).rend()\n#define MP make_pair\n#define X first\n#define Y second\n \nusing namespace std;\n \ntypedef long long ll;\ntypedef pair<int, int> P;\ntypedef vector<int> vi;\n\nvoid fin(){\n\tfreopen(\"test.txt\", \"r\", stdin);\n}\n\nbool formula(const string &s){\n\trep(i,2){\n\t\tif(s[0] == \"FT\"[i]) return i;\n\t}\n\n\tif(s[0] == '-'){\n\t\treturn !formula(s.substr(1));\n\t}\n\n\tint lidx = 1, llen, ridx, rlen;\n\tchar ope;\n\tint nest = 0;\n\trep(i, s.size()){\n\t\tif(s[i] == '(') nest++;\n\t\tif(s[i] == ')') nest--;\n\t\tif(nest != 1) continue;\n\t\trep(j, 3) if(s[i] == \"*+>\"[j]){\n\t\t\tope = s[i];\n\t\t\tllen= i-1-(s[i] == '>');\n\t\t\tridx = i+1;\n\t\t\trlen = s.size()-ridx-1;\n\t\t\tgoto next;\n\t\t}\n\t}\nnext:\n\tbool lhs = formula(s.substr(lidx, llen));\n\tbool rhs = formula(s.substr(ridx, rlen));\n\t\n\tif(ope == '+') return lhs|rhs;\n\tif(ope == '*') return lhs&rhs;\n\tif(lhs&(!rhs)) return false;\n\treturn true;\n}\n\nbool equation(string &s){\n\trep(i, s.size()){\n\t\tif(s[i] != '=') continue;\n\t\treturn formula(s.substr(0, i)) == formula(s.substr(i+1, s.size()));\n\t}\n}\n\nstring replace(const string &s, char from, char to){\n\tstring res = s;\n\trep(i, res.size()){\n\t\tif(res[i] == from) res[i] = to;\n\t}\n\treturn res;\n}\n\nbool include(const string &s, const char c){\n\trep(i, s.size()){\n\t\tif(s[i] == c) return true;\n\t}\n\treturn false;\n}\n\nstring val = \"abcdefghijk\";\nbool dfs(string &s, int i = 0){\n\tif(i == val.size()) return equation(s);\n\tif(!include(s, val[i])) return dfs(s, i+1);\n\trep(j, 2){\n\t\tif(!dfs(replace(s, val[i], \"TF\"[j]), i+1)) return false;\n\t}\n\treturn true;\n}\n\nint main(){\n//\tfin();\n\tstring s;\n\twhile(cin >> s){\n\t\tif(s[0] == '#') break;\n\t\tcout << (dfs(s)?\"YES\":\"NO\") << endl;\n\t}\n\n\treturn 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include <iostream>\n#include <cstdio>\n#include <vector>\n#include <complex>\n#include <algorithm>\n#include <set>\n#include <map>\n#include <queue>\n#include <string>\n#include <cstring>\n#include <stack>\n#include <cmath>\n#include <iomanip>\n#include <sstream>\n#include <cassert>\n \nusing namespace std;\n \ntypedef long long ll;\ntypedef ll li;\ntypedef pair<int,int> PI;\n#define EPS (1e-10L)\n#define rep(i,n) for(int i=0;i<(int)(n);++i)\n#define REP(i, n) rep (i, n)\n#define F first\n#define S second\n#define mp(a,b) make_pair((a),(b))\n#define list3(a,b,c) mp((a),mp((b),(c)))\n#define list4(a,b,c,d) mp((a),list3((b),(c),(d)))\n#define pb(a) push_back(a)\n#define SZ(a) (int)((a).size())\n#define ALL(a) a.begin(),a.end()\n#define CLR(a) memset((a),0,sizeof(a))\n#define FOR(it,a) for(__typeof(a.begin())it=a.begin();it!=a.end();++it)\ntemplate<typename T,typename U> ostream& operator<< (ostream& out, const pair<T,U>& val){return out << \"(\" << val.F << \", \" << val.S << \")\";}\ntemplate<class T> ostream& operator<< (ostream& out, const vector<T>& val){out << \"{\";rep(i,SZ(val)) out << (i?\", \":\"\") << val[i];return out << \"}\";}\nvoid pkuassert(bool t){t=1/t;};\nint dx[]={0,1,0,-1,1,1,-1,-1};\nint dy[]={1,0,-1,0,-1,1,1,-1};\n\nstring in;\nint pos;\nint val;\n\nint formula(){\n  if(islower(in[pos]))\n    return (val>>(in[pos++]-'a'))&1;\n  if(isupper(in[pos]))\n    return in[pos++]=='T';\n  if(in[pos]=='-'){\n    ++pos;\n    return !formula();\n  }\n\n  ++pos;\n  int a=formula();\n  char op=in[pos++];\n  if(op=='-') ++pos;\n  int b=formula();\n  int ret;\n  if(op=='+') ret=a|b;\n  else if(op=='*') ret=a&b;\n  else ret = !a|b;\n  ++pos;\n  return ret;\n}\n\nvoid solve(){\n  int p = in.find('=');\n  string a=in.substr(0,p);\n  string b=in.substr(p+1);\n  rep(i,(1<<11)){\n    val=i;\n    pos=0;\n    in=a;\n    int va=formula();\n    pos=0;\n    in=b;\n    int vb=formula();\n    if(va!=vb){\n      cout << \"NO\" << endl;\n      return;\n    }\n  }\n  cout << \"YES\" << endl;\n}\n\nint main(){\n  while(cin >> in && in!=\"#\") solve();\n}"
  },
  {
    "language": "C++",
    "code": "#include<bits/stdc++.h>\n\n#define fst first\n#define snd second\n#define pb push_back\n\n// Loop\n#define FOR(i,a,b) for(long i=(a);i<(b);++i)\n#define REP(i,a) for(long i=0;i<(a);++i)\n#define EACH(i,a) for(auto (i)=(a).begin(),_END=(a).end();i!=_END;++i)\n\n#define ALL(a) (a).begin(), a.end()\n#define EXIST(a,x) ((a).find(x)!=(a).end())\n#define SORT(a) std::sort((a).begin(), (a).end())\n#define UNIQUE(a) std::sort((a).begin(), a.end()), a.erase(std::unique((a).begin(), a.end()), a.end());\n\n//alias\ntypedef long long LL;\ntypedef std::vector<char> VC;\ntypedef std::vector<int>  VI;\ntypedef std::vector< VC > VC2;\ntypedef std::vector< VI > VI2;\ntypedef std::pair<int,int> PII;\n\ntypedef struct ParseState {\n    int pos;\n    int len;\n    std::string str;\n    std::deque<int> stack;\n\n    //EOF\n    bool isEOF() { return pos >= len; }\n    bool isNotEOF() { return pos < len; }\n\n    //advance\n    void eat(char ch) {\n        assert(pos < len && str[pos] == ch);\n        pos++;\n    }\n    char getCh() {\n        assert(pos < len);\n        return pos < len ? str[pos++] : -1; \n    }\n    //lookahead\n    char seek() {\n        return pos < len ? str[pos] : -1; \n    }\n    char seek(int offset) {\n        return (pos+offset) < len ? str[pos+offset] : -1;\n    }\n\n    //backtrack\n    void setBacktrack() { stack.push_front(pos); }\n    void delBacktrack() {\n        assert(!stack.empty());\n        stack.pop_front();\n    }\n    void backtrack() {\n        assert(!stack.empty());\n        pos = stack.front();\n        stack.pop_front();\n    }\n\n    //test\n    bool isDigit() {\n        return isDigit(0);\n    }\n    bool isDigit(int offset) {\n        char c = seek(offset);\n        return c >= '0' && c <= '9';\n    }\n    bool isUpperAlpha() {\n        return isUpperAlpha(0);\n    }\n    bool isUpperAlpha(int offset) {\n        char c = seek(offset);\n        return c >= 'A' && c <= 'Z';\n    }\n    bool isLowerAlpha() {\n        return isLowerAlpha(0);\n    }\n    bool isLowerAlpha(int offset) {\n        char c = seek(offset);\n        return c >= 'a' && c <= 'z';\n    }\n\n    //test2\n    bool isAlpha() {\n        return isLowerAlpha(0) || isUpperAlpha(0);\n    }\n    bool isAlpha(int offset) {\n        return isLowerAlpha(offset) || isUpperAlpha(offset);\n    }\n    bool isAlphaNum() {\n        return isLowerAlpha(0) || isUpperAlpha(0) || isDigit(0);\n    }\n    bool isAlphaNum(int offset) {\n        return isLowerAlpha(offset) || isUpperAlpha(offset) || isDigit(offset);\n    }\n} State;\n\nbool parseEq(State*);\nbool parseF(State*);\n\nstd::string S;\nstd::vector<char> vars;\nint vars_size = 0;\nstd::map<char, bool> map;\n\nbool parseEq(State* s) {\n    bool f1 = parseF(s);\n    s->eat('=');\n    bool f2 = parseF(s);\n\n    return f1 == f2;\n}\n\nbool parseF(State* s) {\n    char c = s->getCh();\n\n    if(c == 'T' || c == 'F') return c == 'T';\n    if(c >= 'a' && c <= 'k') return map[c];\n\n    if(c == '-') {\n        return !parseF(s);\n    }\n\n    bool f1 = parseF(s);\n    char op = s->getCh();\n    if(op == '-' && s->seek() == '>') {\n        s->eat('>');\n        op = '>';\n    }\n    bool f2 = parseF(s);\n    s->eat(')');\n\n    if(op == '*') {\n        return f1 && f2;\n    } else if(op == '+') {\n        return f1 || f2;\n    } else if(op == '>') {\n        return !(f1 && !f2);\n    }\n    std::cout << \"Assert\" << std::endl;\n    return false;\n}\n\nint main() {\n    std::string S;\n    while(std::cin >> S, S != \"#\") {\n        int len = S.length();\n        State state = State{0, len, S};\n\n        vars.clear();\n        for(int i=0; i<len; ++i) {\n            if(S[i] >= 'a' && S[i] <= 'k') {\n                vars.pb(S[i]);\n            }\n        }\n        UNIQUE(vars);\n        vars_size = vars.size();\n\n        map.clear();\n        int p = (1 << vars_size);\n\n        bool f = true;\n        REP(i, p) {\n            std::bitset<10> bit(i);\n            REP(j, vars_size) {\n                map[vars[j]] = bit[j];\n            }\n\n            state.pos = 0;\n            if(!parseEq(&state)) {\n                f = false;\n                break;\n            }\n        }\n        \n        std::cout << (f ? \"YES\" : \"NO\") << std::endl;\n    }\n}"
  },
  {
    "language": "C++",
    "code": "#include <vector>\n#include <iostream>\n#include <utility>\n#include <algorithm>\n#include <string>\n#include <deque>\n#include <queue>\n#include <functional>\n#include <cmath>\n#include <iomanip>\n#include <map>\n#include <numeric>\n#include <list>\n#include <assert.h>\n#include <math.h>\n#include <valarray>\n#include <stdio.h>\n#include <algorithm>\n#include <set>\n#include <complex>\n#include <list>\n\nusing namespace std;\ntypedef long long int LL;\ntypedef pair<long long int, long long int> pii;\ntypedef pair<double, double> pdd;\n\n#define SORT(c) sort((c).begin(),(c).end())\n#define BACKSORT(c) sort((c).begin(),(c).end(),std::greater<LL>())\n#define FOR(i,a,b) for(LL i=(a);i<(b);++i)\n#define REP(i,n)  FOR(i,0,n)\n\nbool equation(string& s, int& i,vector<bool>& v);\nbool formula(string& s, int& i, vector<bool>& v);\n\nbool equation(string& s, int& i, vector<bool>& v) {\n\tbool a = formula(s, i,v);\n\ti++;\n\tbool b = formula(s, i, v);\n\treturn a == b;\n}\n\nbool formula(string& s, int& i, vector<bool>& v) {\n\tif (s[i] == 'T') {\n\t\ti++;\n\t\treturn true;\n\t}\n\telse\n\t\tif (s[i] == 'F') {\n\t\t\ti++;\n\t\t\treturn false;\n\n\t\t}else\n\t\t\tif ('a' <= s[i] && s[i] <= 'k') {\n\t\t\t\tint aa = s[i] - 'a';\n\t\t\t\ti++;\n\t\t\t\treturn v[aa];\n\t\t\t}else\n\t\t\t\tif (s[i] == '-') {\n\t\t\t\t\ti++;\n\t\t\t\t\tbool a = formula(s, i, v);\n\t\t\t\t\treturn !a;\n\t\t\t\t}\n\t\t\t\telse {\n\t\t\t\t\ti++;\n\t\t\t\t\tbool a = formula(s, i, v);\n\t\t\t\t\tchar op = s[i];\n\t\t\t\t\tif (op == '-') {\n\t\t\t\t\t\ti++;\n\t\t\t\t\t}\n\t\t\t\t\ti++;\n\t\t\t\t\tbool b = formula(s, i, v);\n\t\t\t\t\ti++;\n\t\t\t\t\tif (op == '*') {\n\t\t\t\t\t\treturn a&&b;\n\t\t\t\t\t}else\n\t\t\t\t\t\tif (op == '+') {\n\t\t\t\t\t\t\treturn a || b;\n\t\t\t\t\t\t}\n\t\t\t\t\t\telse {\n\t\t\t\t\t\t\treturn (!a) || b;\n\t\t\t\t\t\t}\n\t\t\t\t}\n}\n\n\nint main()\n{\n\twhile (true) {\n\t\tstring ss;\n\t\tcin >> ss;\n\t\tif (ss[0] == '#') { break; }\n\t\tbool flag = true;\n\t\tfor (int j = 0; j < 2048; ++j) {\n\t\t\tint bai = 1;\n\t\t\tvector<bool> v(9999, false);\n\t\t\tfor (int k = 0; k < 11; ++k) {\n\t\t\t\tif (j % (bai * 2) - j % (bai * 1) == 0) {\n\t\t\t\t\tv[k] = false;\n\t\t\t\t}\n\t\t\t\telse {\n\t\t\t\t\tv[k] = true;\n\t\t\t\t}\n\t\t\t}\n\t\t\t\tint index = 0;\n\t\t\t\tif (!equation(ss, index, v)) {\n\t\t\t\t\tflag = false;\n\t\t\t\t\tbreak;\n\t\t\t\t\t}\n\t\t\t\n\t\t}\n\t\tif (flag) {\n\t\t\tcout << \"YES\" << endl;\n\t\t}\n\t\telse {\n\t\t\tcout << \"NO\" << endl;\n\t\t}\n\t}\n\n}"
  },
  {
    "language": "C++",
    "code": "#include <iostream>\n#include <vector>\n#include <cstdlib>\n#include <algorithm>\nusing namespace std;\n\nconst char *p;\n\nint solve() {\n  int ret = 0;\n  \n  ++p;\n  if(*p == '[') {\n    vector<int> v;\n    while(*p == '[') v.push_back(solve());\n    sort(v.begin(), v.end());\n    for(int i = v.size()/2; i>=0; i--) ret += v[i];\n  } else {\n    char *e;\n    ret = strtol(p, &e, 10)/2 + 1;\n    p = e;\n  }\n  ++p;\n  return ret;\n}\n\nint main() {\n  int n;\n  string s;\n  cin >> n;\n  for(int i = 0; i < n; i++) {\n    cin>>s;\n    p = s.c_str();\n    cout << solve() << endl;\n  }\n  return 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include<iostream>\n#include<string>\n#define MAX 11\nusing namespace std;\nbool o;\nvoid rec(string s){\n  if(!o) return;\n  //cout << s << endl;\n  bool f;\n  int p;\n\n  \n  while(s.find(\"-0\")!=-1){\n    p=s.find(\"-0\");\n    s[p]='1';s[p+1]=' ';\n    f=true;\n  }\n  while(s.find(\"-1\")!=-1){\n    p=s.find(\"-1\");\n    s[p]='0';s[p+1]=' ';\n    f=true;\n  }\n  while(s.find(\"(0*0)\")!=-1){\n    p=s.find(\"(0*0)\");\n    s[p]='0';s[p+1]=' ';s[p+2]=' ';s[p+3]=' ';s[p+4]=' ';\n    f=true;\n  }\n  while(s.find(\"(0*1)\")!=-1){\n    p=s.find(\"(0*1)\");\n    s[p]='0';s[p+1]=' ';s[p+2]=' ';s[p+3]=' ';s[p+4]=' ';\n    f=true;\n  }\n  while(s.find(\"(1*0)\")!=-1){\n    p=s.find(\"(1*0)\");\n    s[p]='0';s[p+1]=' ';s[p+2]=' ';s[p+3]=' ';s[p+4]=' ';\n    f=true;\n  }\n  while(s.find(\"(1*1)\")!=-1){\n    p=s.find(\"(1*1)\");\n    s[p]='1';s[p+1]=' ';s[p+2]=' ';s[p+3]=' ';s[p+4]=' ';\n    f=true;\n  }\n  while(s.find(\"(0+0)\")!=-1){\n    p=s.find(\"(0+0)\");\n    s[p]='0';s[p+1]=' ';s[p+2]=' ';s[p+3]=' ';s[p+4]=' ';\n    f=true;\n  }\n  while(s.find(\"(0+1)\")!=-1){\n    p=s.find(\"(0+1)\");\n    s[p]='1';s[p+1]=' ';s[p+2]=' ';s[p+3]=' ';s[p+4]=' ';\n    f=true;\n  }\n  while(s.find(\"(1+0)\")!=-1){\n    p=s.find(\"(1+0)\");\n    s[p]='1';s[p+1]=' ';s[p+2]=' ';s[p+3]=' ';s[p+4]=' ';\n    f=true;\n  }\n  while(s.find(\"(1+1)\")!=-1){\n    p=s.find(\"(1+1)\");\n    s[p]='1';s[p+1]=' ';s[p+2]=' ';s[p+3]=' ';s[p+4]=' ';\n    f=true;\n  }\n  /*\n  while(s.find(\"(0->0)\")!=-1){\n    p=s.find(\"(0->0)\");\n    s[p]='1';s[p+1]=' ';s[p+2]=' ';s[p+3]=' ';s[p+4]=' ';s[p+5]=' ';\n    f=true;\n  }\n  while(s.find(\"(0->1)\")!=-1){\n    p=s.find(\"(0->1)\");\n    s[p]='1';s[p+1]=' ';s[p+2]=' ';s[p+3]=' ';s[p+4]=' ';s[p+5]=' ';\n    f=true;\n  }\n  while(s.find(\"(1->0)\")!=-1){\n    p=s.find(\"(1->0)\");\n    s[p]='0';s[p+1]=' ';s[p+2]=' ';s[p+3]=' ';s[p+4]=' ';s[p+5]=' ';\n    f=true;\n  }\n  while(s.find(\"(1->1)\")!=-1){\n    p=s.find(\"(1->1)\");\n    s[p]='1';s[p+1]=' ';s[p+2]=' ';s[p+3]=' ';s[p+4]=' ';s[p+5]=' ';\n    f=true;\n  }\n  */\n  if(f){\n    string b;\n    for(int i=0;i<s.size();i++) if(s[i]!=' ') b+=s[i];\n    rec(b);\n  }else{\n    if(s[0]!=s[2]) o=false;\n    return;\n  }\n}\nvoid init(int n,string s){\n  int i,j;\n  for(i=0;i<s.size();i++){\n    for(j=0;j<=MAX;j++){\n      if(s[i]=='a'+j) s[i]='0'+(n>>j&1);\n      if(s[i]=='T') s[i]='1';\n      if(s[i]=='F') s[i]='0';\n    }\n  }\n  rec(s);\n}\nint main(){\n  string s;\n  while(cin >> s,s!=\"#\"){\n    o=true;\n    int i;\n    for(i=0;i<(1<<MAX);i++)\n      init(i,s);\n    cout << (o?\"YES\":\"NO\") << endl;\n  }\n  return 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include <cstdio>\n#include <cstdint>\n#include <cctype>\n#include <cassert>\n#include <vector>\n#include <string>\n#include <algorithm>\n\nvoid preprocess(const std::string &s, std::string &t) {\n  t.clear();\n  for (size_t i=s.length(); i--;) {\n    t += s[i];\n    if (s[i] == '>') --i;\n  }\n  std::reverse(t.begin(), t.end());\n}\n\nbool parse(const std::string &s, size_t &i, int bits, size_t preced=0) {\n  static const std::string ops=\"*+>\";\n  if (preced == 1) {\n    if (s[i] == '(') {\n      bool res=parse(s, ++i, bits, 0);\n      assert(s[i] == ')');\n      ++i;\n      return res;\n    }\n    if (s[i] == '-') {\n      return !parse(s, ++i, bits, 1);\n    }\n    if (islower(s[i])) {\n      return (bits>>(s[i++]-'a') & 1);\n    }\n    return s[i++] == 'T';\n  }\n  bool lhs=parse(s, i, bits, 1);\n  if (i < s.length()) {\n    char op=s[i];\n    if (!std::count(ops.begin(), ops.end(), op)) return lhs;\n    bool rhs=parse(s, ++i, bits, 1);\n    if (op == '*') return lhs && rhs;\n    if (op == '+') return lhs || rhs;\n    if (op == '>') return (!lhs) || rhs;\n  }\n  return lhs;\n}\n\nint testcase_ends() {\n  char buf[1024];\n  scanf(\"%s\", buf);\n  std::string s=buf, t;\n  if (s == \"#\") return 1;\n  preprocess(s, t);\n\n  for (int i=0; i<(1<<11); ++i) {\n    size_t j=0;\n    bool lhs=parse(t, j, i);\n    assert(t[j] == '=');\n    bool rhs=parse(t, ++j, i);\n    if (lhs != rhs) \n      return !printf(\"NO\\n\");\n  }\n  printf(\"YES\\n\");\n  return 0;\n}\n\nint main() {\n  while (!testcase_ends()) {}\n}\n\n"
  },
  {
    "language": "C++",
    "code": "#include <iostream>\n#include <complex>\n#include <sstream>\n#include <string>\n#include <algorithm>\n#include <deque>\n#include <list>\n#include <map>\n#include <numeric>\n#include <queue>\n#include <vector>\n#include <set>\n#include <limits>\n#include <cstdio>\n#include <cctype>\n#include <cmath>\n#include <cstring>\n#include <cstdlib>\n#include <ctime>\nusing namespace std;\n#define REP(i, j) for(int i = 0; i < (int)(j); ++i)\n#define FOR(i, j, k) for(int i = (int)(j); i < (int)(k); ++i)\n#define P pair<int, int>\n#define SORT(v) sort((v).begin(), (v).end())\n#define REVERSE(v) reverse((v).begin(), (v).end())\n\nstring s;\nint now;\nvector<char> chars;\n\nbool check(bool x, char op, bool y){\n  if(op == '*'){\n    if(x && y) return true;\n    else return false;\n  } else if(op == '+'){\n    if(!x && !y) return false;\n    else return true;\n  } else if(op == '>'){\n    if(x && !y) return false;\n    return true;\n  }\n  return false;\n}\n\nbool formula(){\n  //cout <<s <<\", \" <<now <<\", \" <<s[now] <<endl;\n  if(s[now] == 'T'){\n    ++now;\n    return true;\n  } else if(s[now] == 'F'){\n    ++now;\n    return false;\n  } else if(s[now] == '-'){\n    ++now;\n    bool res = formula();\n    return !res;\n  } else if(s[now] == '('){\n    //cout <<\"in \" <<now <<endl;\n    ++now;\n    bool x = formula();\n    char op = s[now];\n    ++now;\n    bool y = formula();\n    ++now;\n    //cout <<x <<\" \" <<op <<\" \" <<y <<\" | \" <<now <<endl;\n    return check(x, op, y);\n  }\n  return false;\n}\n\nmap<char, char> get_m(int bit){\n  map<char, char> ret;\n  int len = (int)(chars.size());\n  for(int i = 0; i < len; ++i){\n    if(bit & (1 << i)) ret[chars[i]] = 'T';\n    else ret[chars[i]] = 'F';\n  }\n  return ret;\n}\n\nbool calc(){\n  stringstream left_ss, right_ss;\n  bool left_end = false;\n  REP(i, s.length()){\n    if(s[i] == '=') left_end = true;\n    else{\n      if(left_end) right_ss << s[i];\n      else left_ss << s[i];\n    }\n  }\n  string left = left_ss.str(), right = right_ss.str();\n  REP(i, (1 << (int)(chars.size()))){\n    string tmp_l = left, tmp_r = right;\n    map<char, char> m = get_m(i);\n    REP(i, left.length()) if(isalpha(left[i]) && left[i] != 'T' && left[i] != 'F') left[i] = m[left[i]];\n    REP(i, right.length()) if(isalpha(right[i]) && right[i] != 'T' && right[i] != 'F') right[i] = m[right[i]];\n    s = left; now = 0;\n    bool left_ans = formula();\n    s = right; now = 0;\n    bool right_ans = formula();\n    //debug\n    //cout <<left <<\", \" <<right <<\" | \" <<left_ans <<\", \" <<right_ans <<endl;\n    if(left_ans != right_ans){\n      //cout <<\"! \" <<endl;\n      //for(map<char, char>::iterator it = m.begin(); it != m.end(); ++it) cout <<(*it).first <<\", \" <<(*it).second <<endl;\n      //cout <<left <<\", \" <<right <<\" | \" <<left_ans <<\", \" <<right_ans <<endl;\n      return false;\n    }\n    left = tmp_l; right = tmp_r;\n  }\n  return true;\n}\n\nint main() {\n  while(cin >>s && s != \"#\"){\n    set<char> chars_s;\n    stringstream ss;\n    REP(i, s.length()){\n      if(i + 1 != s.length() && s[i] == '-' && s[i + 1] == '>'){\n        ss << '>';\n        ++i;\n      } else{\n        //if(isalpha(s[i])) chars_s.insert(s[i]);\n        if(isalpha(s[i]) && s[i] != 'T' && s[i] != 'F') chars_s.insert(s[i]);\n        ss << s[i];\n      }\n    }\n    chars = vector<char>();\n    for(set<char>::iterator it = chars_s.begin(); it != chars_s.end(); ++it) chars.push_back((*it));\n    s = ss.str();\n    cout <<(calc() ? \"YES\" : \"NO\") <<endl;\n  }\n  return 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include<iostream>\n#include<vector>\n#include<string>\n#include<algorithm>\nusing namespace std;\n\n#define MAX_NUM 2\n#define MAX_CH 10\n#define MAX_N 1200\n\nstring S, T;\nchar NUM[MAX_NUM + 1] = \"01\";\nchar CH[MAX_CH + 1] = \"abcdefghij\";\nint TR[MAX_CH];\nint CNT[MAX_N];\n\nint Plus(int c1, int c2) {\n\treturn max(c1, c2);\n}\n\nint kake(int c1, int c2) {\n\treturn min(c1, c2);\n}\n\nint fukumi(int c1, int c2) {\n\tif (c1 == 1 && c2 == 0) {\n\t\treturn 0;\n\t}\n\treturn 1;\n}\n\nint STOI(char V) {\n\tif (V == '0') {\n\t\treturn 0;\n\t}\n\telse {\n\t\treturn 1;\n\t}\n}\n\nint calc2(string A2) {\n\n\tA2 = A2.substr(1, A2.size() - 1);\n\tif (A2.size() == 1)\n\t{\n\t\tint p1;\n\t\tp1 = STOI(A2[0]);\n\t\treturn p1;\n\t}\n\n\tif (A2.size() == 2)\n\t{\n\t\tint p1;\n\t\tp1 = STOI(A2[1]);\n\t\treturn 1 - p1;\n\t}\n\n\tif (A2.size() == 3)\n\t{\n\t\tint p1, p2;\n\t\tp1 = STOI(A2[0]);\n\t\tp2 = STOI(A2[2]);\n\t\tif (A2[1] == '+')\n\t\t{\n\t\t\treturn Plus(p1, p2);\n\t\t}\n\t\tif (A2[1] == '*')\n\t\t{\n\t\t\treturn kake(p1, p2);\n\t\t}\n\t\tif (A2[1] == '&')\n\t\t{\n\t\t\treturn fukumi(p1, p2);\n\t\t}\n\t}\n\n\telse if (A2.size() == 4)\n\t{\n\t\tif (A2[0] == '-')\n\t\t{\n\t\t\tint p1, p2;\n\t\t\tp1 = STOI(A2[1]);\n\t\t\tp2 = STOI(A2[3]);\n\t\t\tif (A2[1] == '+')\n\t\t\t{\n\t\t\t\treturn Plus(1 - p1, p2);\n\t\t\t}\n\t\t\tif (A2[1] == '*')\n\t\t\t{\n\t\t\t\treturn kake(1 - p1, p2);\n\t\t\t}\n\t\t\tif (A2[1] == '&')\n\t\t\t{\n\t\t\t\treturn fukumi(1 - p1, p2);\n\t\t\t}\n\t\t}\n\n\t\tif (A2[2] == '-')\n\t\t{\n\t\t\tint p1, p2;\n\t\t\tp1 = STOI(A2[0]);\n\t\t\tp2 = STOI(A2[3]);\n\t\t\tif (A2[1] == '+')\n\t\t\t{\n\t\t\t\treturn Plus(p1, 1 - p2);\n\t\t\t}\n\t\t\tif (A2[1] == '*')\n\t\t\t{\n\t\t\t\treturn kake(p1, 1 - p2);\n\t\t\t}\n\t\t\tif (A2[1] == '&')\n\t\t\t{\n\t\t\t\treturn fukumi(p1, 1 - p2);\n\t\t\t}\n\t\t}\n\t}\n\n\telse\n\t{\n\t\tint p1, p2;\n\t\tp1 = STOI(A2[1]);\n\t\tp2 = STOI(A2[4]);\n\t\tif (A2[1] == '+')\n\t\t{\n\t\t\treturn Plus(1 - p1, 1 - p2);\n\t\t}\n\t\tif (A2[1] == '*')\n\t\t{\n\t\t\treturn kake(1 - p1, 1 - p2);\n\t\t}\n\t\tif (A2[1] == '&')\n\t\t{\n\t\t\treturn fukumi(1 - p1, 1 - p2);\n\t\t}\n\t}\n}\n\nstring TOSTR(int d) {\n\tif (d == 0) {\n\t\treturn \"0\";\n\t}\n\telse {\n\t\treturn \"1\";\n\t}\n}\n\nint calc(string Y) {\n\tfor (int i = 0; i < MAX_N; i++)\n\t{\n\t\tCNT[i] = 0;\n\t}\n\tstring Z = Y, AA = \"\";\n\n\twhile (Z.size() >= 2)\n\t{\n\t\tint L = 0, MN = 0;\n\t\tbool ok1 = true;\n\t\tZ = \"\"; AA = \"\";\n\t\tint pass2 = 0;\n\t\tint pass3 = -1;\n\n\t\twhile (pass2 < Y.size())\n\t\t{\n\t\t\tif (Y[pass2] == '(') {\n\t\t\t\tL++;\n\t\t\t}\n\t\t\tif (Y[pass2] == ')') {\n\t\t\t\tL--;\n\t\t\t}\n\t\t\tCNT[pass2] = L;\n\t\t\tpass2++;\n\t\t\tMN = max(MN, L);\n\t\t}\n\n\t\tfor (int i = 0; i < Y.size(); i++)\n\t\t{\n\t\t\tif (CNT[i] == MN && ok1 == true) {\n\t\t\t\tif (pass3 == -1) {\n\t\t\t\t\tpass3 = i;\n\t\t\t\t}\n\t\t\t\tAA += Y[i];\n\t\t\t\tif (i < Y.size() - 1) {\n\t\t\t\t\tif (Y[i + 1] == ')') {\n\t\t\t\t\t\tok1 = false;\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t}\n\t\t\telse {\n\t\t\t\tZ += Y[i];\n\t\t\t}\n\t\t}\n\n\t\tint ZSIZE = Z.size();\n\t\tstring PART1 = \"\";\n\t\tstring PART2 = \"\";\n\t\tstring PART3 = TOSTR(calc2(AA));\n\t\tif (pass3 >= 1) {\n\t\t\tPART1 = Z.substr(0, pass3);\n\t\t}\n\t\tif ((ZSIZE - pass3 - 1) >= 1) {\n\t\t\tPART2= Z.substr(pass3 + 1, ZSIZE - pass3 - 1);\n\t\t}\n\t\tZ = PART1 + PART3 + PART2;\n\t\tY = Z;\n\t}\n\n\tif (Y == \"0\") {\n\t\treturn 0;\n\t}\n\telse {\n\t\treturn 1;\n\t}\n}\n\nint power(int a, int b) {\n\tint res2 = 1;\n\tfor (int i = 0; i < b; i++) {\n\t\tres2 *= a;\n\t}\n\treturn res2;\n}\n\nbool solve(string U) {\n\tbool RES = true;\n\tstring V = \"\";\n\tstring V1 = \"\", V2 = \"\";\n\tstring W1 = \"\", W2 = \"\";\n\n\tfor (int i = 0; i < U.size(); i++)\n\t{\n\t\tif (U[i] == 'T') {\n\t\t\tV += '1';\n\t\t\tgoto E;\n\t\t}\n\t\telse if (U[i] == '>') {\n\t\t\t//nanimo shinai.\n\t\t\tgoto E;\n\t\t}\n\t\telse if (U[i] == 'F') {\n\t\t\tV += '0';\n\t\t\tgoto E;\n\t\t}\n\t\telse if (i < U.size() - 1) {\n\t\t\tif (U.substr(i, 2) == \"->\") {\n\t\t\t\tV += '&';\n\t\t\t\tgoto E;\n\t\t\t}\n\t\t}\n\t\tV += U[i];\n\tE:;\n\t}\n\n\tint cnt1 = 0;\n\tfor (int i = 0; i < V.size(); i++) {\n\t\tif (V[i] == '=') {\n\t\t\tcnt1 = 1;\n\t\t}\n\t\telse if (cnt1 == 0) {\n\t\t\tV1 += V[i];\n\t\t}\n\t\telse if (cnt1 == 1) {\n\t\t\tV2 += V[i];\n\t\t}\n\t}\n\n\tint pass1 = 0;\n\twhile (true)\n\t{\n\t\tpass1 = 0;\n\t\tif (W1 != \"\") {\n\t\t\tV1 = W1; W1 = \"\";\n\t\t}\n\t\tfor (int i = 0; i < V1.size(); i++) {\n\t\t\tif (V1[i] == '-' && i == 0) {\n\t\t\t\tgoto H1;\n\t\t\t}\n\t\t\tif (i >= 1) {\n\t\t\t\tif (V1[i] == '-' && V1[i - 1] != '(') {\n\t\t\t\t\tgoto H1;\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t\tW1 = V1;\n\t\tbreak;\n\tH1:;\n\t\twhile (pass1 < V1.size()) {\n\t\t\tif (V1[pass1] == '-') {\n\t\t\t\tint cnt2 = 0;\n\t\t\t\twhile (V1[pass1] == '-') {\n\t\t\t\t\tcnt2++;\n\t\t\t\t\tpass1++;\n\t\t\t\t}\n\t\t\t\tif (cnt2 % 2 == 1) {\n\t\t\t\t\tW1 += '(';\n\t\t\t\t\tW1 += '-';\n\t\t\t\t\tint P = 0;\n\t\t\t\t\tfor (int i = pass1; i < V1.size(); i++) {\n\t\t\t\t\t\tW1 += V1[i];\n\t\t\t\t\t\tif (V1[i] == '(') {\n\t\t\t\t\t\t\tP++;\n\t\t\t\t\t\t}\n\t\t\t\t\t\telse if (V1[i] == ')') {\n\t\t\t\t\t\t\tP--;\n\t\t\t\t\t\t}\n\t\t\t\t\t\tif (P <= 0) {\n\t\t\t\t\t\t\tbreak;\n\t\t\t\t\t\t}\n\t\t\t\t\t\tpass1++;\n\t\t\t\t\t}\n\t\t\t\t\tW1 += ')';\n\t\t\t\t}\n\t\t\t\telse {\n\t\t\t\t\tW1 += V1[pass1];\n\t\t\t\t}\n\t\t\t\tpass1++;\n\t\t\t}\n\t\t\tif (pass1 < V1.size()) {\n\t\t\t\tW1 += V1[pass1];\n\t\t\t\tpass1++;\n\t\t\t}\n\t\t}\n\t}\n\n\tpass1 = 0;\n\twhile (true)\n\t{\n\t\tpass1 = 0;\n\t\tif (W2 != \"\") {\n\t\t\tV2 = W2; W2 = \"\";\n\t\t}\n\t\tfor (int i = 0; i < V2.size(); i++) {\n\t\t\tif (V2[i] == '-' && i == 0) {\n\t\t\t\tgoto H2;\n\t\t\t}\n\t\t\tif (i >= 1) {\n\t\t\t\tif (V2[i] == '-' && V2[i - 1] != '(') {\n\t\t\t\t\tgoto H2;\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t\tW2 = V2;\n\t\tbreak;\n\tH2:;\n\t\twhile (pass1 < V2.size()) {\n\t\t\tif (V2[pass1] == '-') {\n\t\t\t\tint cnt2 = 0;\n\t\t\t\twhile (V2[pass1] == '-') {\n\t\t\t\t\tcnt2++;\n\t\t\t\t\tpass1++;\n\t\t\t\t}\n\t\t\t\tif (cnt2 % 2 == 1) {\n\t\t\t\t\tW2 += '(';\n\t\t\t\t\tW2 += '-';\n\t\t\t\t\tint P = 0;\n\t\t\t\t\tfor (int i = pass1; i < V2.size(); i++) {\n\t\t\t\t\t\tW2 += V2[i];\n\t\t\t\t\t\tif (V2[i] == '(') {\n\t\t\t\t\t\t\tP++;\n\t\t\t\t\t\t}\n\t\t\t\t\t\telse if (V2[i] == ')') {\n\t\t\t\t\t\t\tP--;\n\t\t\t\t\t\t}\n\t\t\t\t\t\tif (P <= 0) {\n\t\t\t\t\t\t\tbreak;\n\t\t\t\t\t\t}\n\t\t\t\t\t\tpass1++;\n\t\t\t\t\t}\n\t\t\t\t\tW2 += ')';\n\t\t\t\t}\n\t\t\t\telse {\n\t\t\t\t\tW2 += V2[pass1];\n\t\t\t\t}\n\t\t\t\tpass1++;\n\t\t\t}\n\t\t\tif (pass1 < V2.size()) {\n\t\t\t\tW2 += V2[pass1];\n\t\t\t\tpass1++;\n\t\t\t}\n\t\t}\n\t}\n\n\tstring X1 = \"\", X2 = \"\";\n\n\tfor (int i = 0; i < power(2, MAX_CH); i++) {\n\t\tX1 = \"\"; X2 = \"\";\n\t\tfor (int j = 0; j < MAX_CH; j++) {\n\t\t\tint a1 = (i / power(2, j)) % 2;\n\t\t\tTR[j] = a1;\n\t\t}\n\n\t\tfor (int j = 0; j < W1.size(); j++) {\n\t\t\tfor (int k = 0; k < MAX_CH; k++) {\n\t\t\t\tif (W1[j] == CH[k]) {\n\t\t\t\t\tX1 += NUM[TR[k]];\n\t\t\t\t\tgoto F;\n\t\t\t\t}\n\t\t\t}\n\t\t\tX1 += W1[j];\n\t\tF:;\n\t\t}\n\n\t\tfor (int j = 0; j < W2.size(); j++) {\n\t\t\tfor (int k = 0; k < MAX_CH; k++) {\n\t\t\t\tif (W2[j] == CH[k]) {\n\t\t\t\t\tX2 += NUM[TR[k]];\n\t\t\t\t\tgoto G;\n\t\t\t\t}\n\t\t\t}\n\t\t\tX2 += W2[j];\n\t\tG:;\n\t\t}\n\n\t\tint res_1 = calc(X1);\n\t\tint res_2 = calc(X2);\n\t\tif (res_1 != res_2) {\n\t\t\tRES = false;\n\t\t}\n\t}\n\treturn RES;\n}\n\nint main() {\n\twhile (true) {\n\t\tcin >> S;\n\t\tif (S == \"#\") {\n\t\t\tbreak;\n\t\t}\n\t\tbool res = solve(S);\n\t\tif (res == true) {\n\t\t\tcout << \"YES\" << endl;\n\t\t}\n\t\telse {\n\t\t\tcout << \"NO\" << endl;\n\t\t}\n\t}\n\treturn 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include <iostream>\n#include <string>\n#include <stack>\n\nusing namespace std;\n\nchar wa(char a, char b);\nchar seki(char a, char b);\nchar naraba(char a, char b);\nchar not_k(char a);\n\nbool kaiseki(string b) {\n\tstack<char> stk1;\n\tstack<char> stk2;\n\tchar aa, bb;\n\tfor (int i = 0; i < b.size(); i++) {\n\t\tif (b[i] == '=') {\n\t\t\taa = stk2.top();\n\t\t\tstk2.pop();\n\t\t} else {\n\t\t\tif (b[i] == '0' || b[i] == '1') {\n\t\t\t\twhile (!stk1.empty() && stk1.top() == '-') {\n\t\t\t\t\tstk1.pop();\n\t\t\t\t\tb[i] = not_k(b[i]);\n\t\t\t\t}\n\t\t\t\tstk2.push(b[i]);\n\t\t\t} else if (b[i] == '+' || b[i] == '*' || b[i] == '>' || b[i] == '(') {\n\t\t\t\tstk1.push(b[i]);\n\t\t\t} else if (b[i] == ')') {\n\t\t\t\tchar p = stk2.top();\n\t\t\t\tstk2.pop();\n\t\t\t\tchar q = stk2.top();\n\t\t\t\tstk2.pop();\n\t\t\t\tchar k = stk1.top();\n\t\t\t\tstk1.pop();\n\t\t\t\tif (k == '+') {\n\t\t\t\t\tp = wa(p, q);\n\t\t\t\t} else if (k == '*'){\n\t\t\t\t\tp = seki(p, q);\n\t\t\t\t} else if (k == '>') {\n\t\t\t\t\tp = naraba(q, p);\n\t\t\t\t} else {\n\t\t\t\t\tstk2.push(q);\n\t\t\t\t\tp = not_k(p);\n\t\t\t\t}\n\t\t\t\tstk1.pop();\n\t\t\t\twhile (!stk1.empty() && stk1.top() == '-') {\n\t\t\t\t\tstk1.pop();\n\t\t\t\t\tp = not_k(p);\n\t\t\t\t}\n\t\t\t\tstk2.push(p);\n\t\t\t} else if (b[i] == '-') {\n\t\t\t\tif (b[i+1] == '>') {\n\t\t\t\t} else {\n\t\t\t\t\tif (!stk1.empty() && stk1.top() == '-') {\n\t\t\t\t\t\tstk1.pop();\n\t\t\t\t\t} else {\n\t\t\t\t\t\tstk1.push(b[i]);\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t}\n\tbb = stk2.top();\n\tstk2.pop();\n\treturn aa == bb;\n}\n\nchar wa(char a, char b) {\n\tif (a == '0' && b == '0') {\n\t\treturn '0';\n\t} else {\n\t\treturn '1';\n\t}\n}\n\nchar seki(char a, char b) {\n\tif (a == '1' && b == '1') {\n\t\treturn '1';\n\t} else {\n\t\treturn '0';\n\t}\n}\n\nchar naraba(char a, char b) {\n\tif (a == '1' && b == '0') {\n\t\treturn '0';\n\t} else {\n\t\treturn '1';\n\t}\n}\n\nchar not_k(char a) {\n\tif (a == '0') {\n\t\treturn '1';\n\t} else {\n\t\treturn '0';\n\t}\n}\n\nint main() {\n\tstring a;\n\tstring abc = \"abcdefghijk\";\n\twhile (cin >> a) {\n\t\tif (a == \"#\") {\n\t\t\tbreak;\n\t\t}\n\t\tint counter = 1;\n\t\tcounter <<= 11;\n\t\tstring b;\n\t\tbool hantei = true;\n\t\tfor (int i = 0; i < a.size(); i++) {\n\t\t\tif (a[i] == 'T') {\n\t\t\t\ta[i] = '1';\n\t\t\t} else if (b[i] == 'F') {\n\t\t\t\ta[i] = '0';\n\t\t\t}\n\t\t}\n\t\tfor (int i = 0; i < counter; i++) {\n\t\t\tb = a;\n\t\t\tfor (int j = 0; j < 11; j++) {\n\t\t\t\tif ((i&(1<<j)) != 0) {\n\t\t\t\t\twhile (b.find(abc[j]) != string::npos) {\n\t\t\t\t\t\tb[b.find(abc[j])] = '1';\n\t\t\t\t\t}\n\t\t\t\t} else {\n\t\t\t\t\twhile (b.find(abc[j]) != string::npos) {\n\t\t\t\t\t\tb[b.find(abc[j])] = '0';\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t}\n\t\t\tif (!kaiseki(b)) {\n\t\t\t\thantei = false;\n\t\t\t\tbreak;\n\t\t\t}\n\t\t}\n\t\tif (hantei) {\n\t\t\tcout << \"YES\" << endl;\n\t\t} else {\n\t\t\tcout << \"NO\" << endl;\n\t\t}\n\t}\n\treturn 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include<iostream>\n#include<string>\nusing namespace std;\nchar s1(char g1, char g2) { if (g1 == 'T' && g2 == 'T')return 'T'; return 'F'; }\nchar s2(char g1, char g2) { if (g1 == 'F' && g2 == 'F')return 'F'; return 'T'; }\nchar s3(char g1, char g2) { if (g1 == 'T' && g2 == 'F')return 'F'; return 'T'; }\nchar solve(string S) {\n\tint T = 0; string U = \"\";\n\twhile (T < S.size() && S[T] == '-') { T++; U += \"-\"; }\n\tint depth = 0;\n\tfor (int i = 0; i < S.size(); i++) {\n\t\tif (S[i] == '(')depth++;\n\t\tif (S[i] == ')')depth--;\n\t\tif (depth == 1) {\n\t\t\tif (S[i] == '*')return solve(U + s1(solve(S.substr(T + 1, i)), solve(S.substr(i + 1, S.size() - i - 2))));\n\t\t\tif (S[i] == '+')return solve(U + s2(solve(S.substr(T + 1, i)), solve(S.substr(i + 1, S.size() - i - 2))));\n\t\t\tif (S[i] == '>')return solve(U + s3(solve(S.substr(T + 1, i - 1)), solve(S.substr(i + 1, S.size() - i - 2))));\n\t\t}\n\t}\n\tif (T % 2 == 1) { if (S[T] == 'T')S[T] = 'F'; else S[T] = 'T'; }\n\treturn S[T];\n}\nint main() {\n\twhile (true) {\n\t\tbool OK = true;\n\t\tstring U, V1, V2; cin >> U; char R[3] = \"FT\"; if (U == \"#\")break;\n\t\tfor (int i = 0; i < U.size(); i++) {\n\t\t\tif (U[i] == '=') { V1 = U.substr(0, i); V2 = U.substr(i + 1, U.size() - i - 1); }\n\t\t}\n\t\tfor (int i = 0; i < (1 << 11); i++) {\n\t\t\tstring Y1 = V1, Y2 = V2; int bit[11];\n\t\t\tfor (int j = 0; j < 11; j++) { bit[j] = (i / (1 << j)) % 2; }\n\t\t\tfor (int j = 0; j < Y1.size(); j++) {\n\t\t\t\tif (Y1[j] >= 'a' && Y1[j] <= 'k') { Y1[j] = R[bit[Y1[j] - 'a']]; }\n\t\t\t}\n\t\t\tfor (int j = 0; j < Y2.size(); j++) {\n\t\t\t\tif (Y2[j] >= 'a' && Y2[j] <= 'k') { Y2[j] = R[bit[Y2[j] - 'a']]; }\n\t\t\t}\n\t\t\tif (solve(Y1) != solve(Y2)) {\n\t\t\t\tOK = false;\n\t\t\t}\n\t\t}\n\t\tif (OK == true)cout << \"YES\" << endl;\n\t\telse cout << \"NO\" << endl;\n\t}\n\treturn 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include <vector>\n#include <iostream>\n#include <utility>\n#include <algorithm>\n#include <string>\n#include <deque>\n#include <queue>\n#include <functional>\n#include <cmath>\n#include <iomanip>\n#include <map>\n#include <numeric>\n#include <list>\n#include <assert.h>\n#include <math.h>\n#include <valarray>\n#include <stdio.h>\n#include <algorithm>\n#include <set>\n#include <complex>\n#include <list>\n\nusing namespace std;\ntypedef long long int LL;\ntypedef pair<long long int, long long int> pii;\ntypedef pair<double, double> pdd;\n\n#define SORT(c) sort((c).begin(),(c).end())\n#define BACKSORT(c) sort((c).begin(),(c).end(),std::greater<LL>())\n#define FOR(i,a,b) for(LL i=(a);i<(b);++i)\n#define REP(i,n)  FOR(i,0,n)\n\nbool equation(string& s, int& i,vector<bool>& v);\nbool formula(string& s, int& i, vector<bool>& v);\n\nbool equation(string& s, int& i, vector<bool>& v) {\n\tbool a = formula(s, i,v);\n\ti++;\n\tbool b = formula(s, i, v);\n\treturn a == b;\n}\n\nbool formula(string& s, int& i, vector<bool>& v) {\n\tif (s[i] == 'T') {\n\t\ti++;\n\t\treturn true;\n\t}\n\telse\n\t\tif (s[i] == 'F') {\n\t\t\ti++;\n\t\t\treturn false;\n\n\t\t}else\n\t\t\tif ('a' <= s[i] && s[i] <= 'k') {\n\t\t\t\tint aa = s[i] - 'a';\n\t\t\t\ti++;\n\t\t\t\treturn v[aa];\n\t\t\t}else\n\t\t\t\tif (s[i] == '-') {\n\t\t\t\t\ti++;\n\t\t\t\t\tbool a = formula(s, i, v);\n\t\t\t\t\treturn !a;\n\t\t\t\t}\n\t\t\t\telse {\n\t\t\t\t\ti++;\n\t\t\t\t\tbool a = formula(s, i, v);\n\t\t\t\t\tchar op = s[i];\n\t\t\t\t\tif (op == '-') {\n\t\t\t\t\t\ti++;\n\t\t\t\t\t}\n\t\t\t\t\ti++;\n\t\t\t\t\tbool b = formula(s, i, v);\n\t\t\t\t\ti++;\n\t\t\t\t\tif (op == '*') {\n\t\t\t\t\t\treturn a&&b;\n\t\t\t\t\t}else\n\t\t\t\t\t\tif (op == '+') {\n\t\t\t\t\t\t\treturn a || b;\n\t\t\t\t\t\t}\n\t\t\t\t\t\telse {\n\t\t\t\t\t\t\treturn (!a) || b;\n\t\t\t\t\t\t}\n\t\t\t\t}\n}\n\n\nint main()\n{\n\twhile (true) {\n\t\tstring ss;\n\t\tcin >> ss;\n\t\tif (ss[0] == '#') { break; }\n\t\tbool flag = true;\n\t\tfor (int j = 0; j < 2048; ++j) {\n\t\t\tint bai = 1;\n\t\t\tfor (int k = 0; k < 11; ++k) {\n\t\t\t\tvector<bool> v(9999,false);\n\t\t\t\tif (j%(bai*2)-j%(bai*1)==0) {\n\t\t\t\t\tv[k] = false;\n\t\t\t\t}\n\t\t\t\telse {\n\t\t\t\t\tv[k] = true;\n\t\t\t\t}\n\t\t\t\tint index = 0;\n\t\t\t\tif (!equation(ss, index, v)) {\n\t\t\t\t\tflag = false;\n\t\t\t\t\tbreak;\n\t\t\t\t\t}\n\t\t\t}\n\t\t}\n\t\tif (flag) {\n\t\t\tcout << \"YES\" << endl;\n\t\t}\n\t\telse {\n\t\t\tcout << \"NO\" << endl;\n\t\t}\n\t}\n\n}"
  },
  {
    "language": "C++",
    "code": "#pragma GCC optimize(\"Ofast\")\n#pragma GCC optimize(\"unroll-loops\")\n#pragma GCC push_options\n#pragma GCC target(\"sse,sse2,sse3,ssse3,sse4,popcnt,abm,mmx,avx\")\n#include<bits/stdc++.h>\n#include <xmmintrin.h>\n#include <immintrin.h>\nusing namespace::std;\n__attribute__((constructor))void init(){cin.tie(0);ios::sync_with_stdio(false);cout<<fixed<<setprecision(15);}\n#include<ext/pb_ds/assoc_container.hpp>\n#include<ext/pb_ds/tree_policy.hpp>\n#include <ext/pb_ds/priority_queue.hpp>\n#include<ext/pb_ds/tag_and_trait.hpp>\n// #include <boost/multiprecision/cpp_dec_float.hpp>\n// #include <boost/multiprecision/cpp_int.hpp>\n// namespace mp = boost::multiprecision;\n// typedef mp::number<mp::cpp_dec_float<0>> cdouble;\n// typedef mp::cpp_int cint;\ntemplate<typename T>using pbds=__gnu_pbds::tree<T,__gnu_pbds::null_type,less<T>,__gnu_pbds::rb_tree_tag,__gnu_pbds::tree_order_statistics_node_update>;\ntemplate<typename T>using pbds_map=__gnu_pbds::tree<T,T,less<T>,__gnu_pbds::rb_tree_tag,__gnu_pbds::tree_order_statistics_node_update>;\ntemplate<typename T,typename E>using hash_map=__gnu_pbds::gp_hash_table<T,E>;\ntemplate<typename T>using pqueue =__gnu_pbds::priority_queue<T, greater<T>,__gnu_pbds::rc_binomial_heap_tag>;\ntypedef long long lint;\n#define INF (1LL<<60)\n#define IINF (1<<30)\n#define EPS (1e-10)\n#define endl ('\\n')\n#define MOD 1000000007LL\n//#define MOD 998244353LL\ntypedef vector<lint> vec;\ntypedef vector<vector<lint>> mat;\ntypedef vector<vector<vector<lint>>> mat3;\ntypedef vector<string> svec;\ntypedef vector<vector<string>> smat;\ntemplate<typename T>inline void numout(T t){bool f=0;for(auto i:t){cout<<(f?\" \":\"\")<<i<INF/2?i:\"INF\";f=1;}cout<<endl;}\ntemplate<typename T>inline void numout2(T t){for(auto i:t)numout(i);}\ntemplate<typename T>inline void output(T t){bool f=0;for(auto i:t){cout<<(f?\" \":\"\")<<i;f=1;}cout<<endl;}\ntemplate<typename T>inline void output2(T t){for(auto i:t)output(i);}\ntemplate<typename T>inline void _output(T t){bool f=0;for(lint i=0;i<t.size();i++){cout<<f?\"\":\" \"<<t[i];f=1;}cout<<endl;}\ntemplate<typename T>inline void _output2(T t){for(lint i=0;i<t.size();i++)output(t[i]);}\n#define rep(i,n) for(lint i=0;i<lint(n);++i)\n#define repi(i,a,b) for(lint i=lint(a);i<(lint)(b);++i)\n#define rrep(i,n) for(lint i=lint(n)-1;i>=0;--i)\n#define rrepi(i,a,b) for(lint i=lint(b)-1;i>=lint(a);--i)\n#define irep(i) for(lint i=0;;++i)\n#define all(n) begin(n),end(n)\n#define dist(a,b,c,d) sqrt(pow(a-c,2)+pow(b-d,2))\ninline lint gcd(lint A,lint B){return B?gcd(B,A%B):A;}\ninline lint lcm(lint A,lint B){return A/gcd(A,B)*B;}\n// inline cint cgcd(cint A,cint B){return B?cgcd(B,A%B):A;}\n// inline cint clcm(cint A,cint B){return A/cgcd(A,B)*B;}\nbool chmin(auto& s,const auto& t){bool res=s>t;s=min(s,t);return res;}\nbool chmax(auto& s,const auto& t){bool res=s<t;s=max(s,t);return res;}\nconst vector<lint> dx={1,0,-1,0,1,1,-1,-1};\nconst vector<lint> dy={0,1,0,-1,1,-1,1,-1};\n#define SUM(v) accumulate(all(v),0LL)\nauto call=[](auto f,auto... args){return f(f,args...);};\n\nbool expr(lint& i,string s,bitset<11>b);\nbool from(lint& i,string s,bitset<11>b);\nbool solve(string s){\n    rep(i,1<<11){\n        bitset<11>b(i);\n        lint k=0;\n        if(!expr(k,s,b))return 0;\n    }\n    return 1;\n}\nbool expr(lint& i,string s,bitset<11>b){\n    bool p=from(i,s,b);\n    assert(s[i]=='=');\n    i++;\n    bool q=from(i,s,b);\n    return p==q;\n}\nbool from(lint& i,string s,bitset<11>b){\n    if(s[i]=='('){\n        i++;\n        auto p=from(i,s,b);\n        if(s[i]=='*'){\n            i++;\n            auto q=from(i,s,b);\n            i++;\n            return p&q;\n        }else if(s[i]=='+'){\n            i++;\n            auto q=from(i,s,b);\n            i++;\n            return p|q;\n        }else{\n            i+=2;\n            auto q=from(i,s,b);\n            i++;\n            return p<=q;\n        }\n    }else{\n        if(s[i]=='-'){\n            i++;\n            auto p=from(i,s,b);\n            return !p;\n        }\n        if(s[i]=='T'){\n            i++;\n            return 1;\n        }\n        if(s[i]=='F'){\n            i++;\n            return 0;\n        }\n        return b[s[i++]-'a'];\n    }\n}\nint main(){\n    while(1){\n        string s;\n        cin>>s;\n        if(s==\"#\")break;\n        if(solve(s))cout<<\"YES\"<<endl;\n        else cout<<\"NO\"<<endl;\n    }\n}\n"
  },
  {
    "language": "C++",
    "code": "#include<iostream>\n#include<algorithm>\n#include<string>\n#include<map>\n#include<vector>\n#define pb push_back\n#define all(c) c.begin(),c.end()\n#define uni(c) c.erase(unique(all(c)),c.end())\nusing namespace std;\nstring cc(string s,string x,string y){\n\tstring t=\"\";\n\tfor(int i=0;i<s.size();i++){\n\t\tif(s.substr(i,x.size())==x){\n\t\t\tt+=y;\n\t\t\ti+=x.size()-1;\n\t\t}else{\n\t\t\tt+=s[i];\n\t\t}\n\t}\n\treturn t;\n}\nstring cal(string s,vector<char> c,int bit){\n\tmap<char,int> mp;\n\t\n\tfor(int i=0;i<(int)c.size();i++){\n\t\tif((bit>>i&1)){\n\t\t\treplace(all(s),c[i],'1');\n\t\t}else{\n\t\t\treplace(all(s),c[i],'0');\n\t\t}\n\t}\n\tfor(int i=0;i<s.size();i++)\n\tif(s[i]=='T'){\n\t\ts[i]='1';\n\t}else if(s[i]=='F'){\n\t\ts[i]='0';\n\t}\n\ts=cc(s,\"--\",\"\");\n\twhile(s.size()>1){\n\t\ts=cc(s,\"-1\",\"0\");\n\t\ts=cc(s,\"-0\",\"1\");\n\t\tfor(int i=0;i<s.size();i++){\n\t\t\tif(s[i]=='('&&s[i+4]==')'&&(s[i+2]=='*'||s[i+2]=='+')){\n\t\t\t\tif(s[i+2]=='*'){\n\t\t\t\t\tstring z=\"0\";\n\t\t\t\t\tif(s[i+1]=='1'&&s[i+1]==s[i+3])\n\t\t\t\t\t\tz=\"1\";\n\t\t\t\t\ts=cc(s,s.substr(i,5),z);\n\t\t\t\t}else if(s[i+2]=='+'){\n\t\t\t\t\tstring z=\"1\";\n\t\t\t\t\tif(s[i+1]=='0'&&s[i+1]==s[i+3])\n\t\t\t\t\t\tz=\"0\";\n\t\t\t\t\ts=cc(s,s.substr(i,5),z);\n\t\t\t\t}\n\t\t\t\tbreak;\n\t\t\t}else if(s[i]=='('&&s[i+5]==')'&&s[i+2]=='-'&&s[i+2]=='>'){\n\t\t\t\tstring z=\"1\";\n\t\t\t\tif(s[i+1]=='1'&&s[i+1]!=s[i+4])\n\t\t\t\t\tz=\"0\";\n\t\t\t\ts=cc(s,s.substr(i,6),z);\n\t\t\t\tbreak;\n\t\t\t}\n\t\t}\n\t}\n\treturn s;\n}\nint main(){\n\tstring s;\n\twhile(cin>>s,s!=\"#\"){\n\t\tstring a,b;\n\t\tvector<char> t;\n\t\tfor(int i=0;i<s.size();i++){\n\t\t\tif(s[i]=='='){\n\t\t\t\ta=s.substr(0,i),b=s.substr(i+1,s.size()-i-1);\n\t\t\t}\n\t\t\tif(!(s[i]=='T'||s[i]=='F')&&isalpha(s[i]))\n\t\t\t\tt.pb(s[i]);\n\t\t}\n\t\tsort(all(t));\n\t\tuni(t);\n\t\tint n=t.size();\n\t\tbool flag=true;\n\t\tfor(int i=0;i<(1<<n);i++){\n\t\t\tif(cal(a,t,i)!=cal(b,t,i)){\n\t\t\t\tcout<<\"NO\"<<endl;\n\t\t\t\tflag=false;\n\t\t\t\tbreak;\n\t\t\t}\n\t\t}\n\t\tif(flag){\n\t\t\tcout<<\"YES\"<<endl;\n\t\t}\n\t\t\n\t}\n\treturn 0;\n}"
  },
  {
    "language": "C++",
    "code": "/*\n * 2401.cc: Equation\n */\n\n#include<cstdio>\n#include<cstdlib>\n#include<cstring>\n#include<cmath>\n#include<iostream>\n#include<string>\n#include<vector>\n#include<map>\n#include<set>\n#include<stack>\n#include<list>\n#include<queue>\n#include<deque>\n#include<algorithm>\n#include<numeric>\n#include<utility>\n#include<complex>\n#include<functional>\n \nusing namespace std;\n\n/* constant */\n\nconst int MAX_FN = 1000;\nconst int MAX_VN = 11;\n\n/* typedef */\n\nenum { T_CON, T_VAR, T_NOT, T_AND, T_OR, T_IMP };\n\nstruct Formula {\n  int t, v;\n  Formula *f0, *f1;\n  Formula() {}\n};\n\n/* global variables */\n\nint vn, vids[MAX_VN], fn;\nFormula fps[MAX_FN];\n\n/* subroutines */\n\ninline Formula *allocate_f() { return &fps[fn++]; }\ninline int allocate_v(int va) {\n  if (vids[va] < 0) vids[va] = vn++;\n  return vids[va];\n}\n\nFormula *formula(string &s, int &pos) {\n  Formula *f = allocate_f();\n  if (s[pos] == 'T' || s[pos] == 'F') {\n    f->t = T_CON;\n    f->v = (s[pos++] == 'T');\n    return f;\n  }\n  if (s[pos] >= 'a' && s[pos] <= 'k') {\n    f->t = T_VAR;\n    f->v = allocate_v(s[pos++] - 'a');\n    return f;\n  }\n  if (s[pos] == '-') {\n    f->t = T_NOT;\n    pos++; // '-'\n    f->f0 = formula(s, pos);\n    return f;\n  }\n\n  pos++; // '('\n  f->f0 = formula(s, pos);\n  switch (s[pos++]) {\n  case '*': f->t = T_AND; break;\n  case '+': f->t = T_OR; break;\n  case '-': f->t = T_IMP; pos++; break;\n  }\n  f->f1 = formula(s, pos);\n  pos++; // ')'\n  return f;\n}\n\nbool calc(Formula *f, int bits) {\n  bool ret;\n  switch (f->t) {\n  case T_CON: ret = f->v; break;\n  case T_VAR: ret = (bits >> f->v) & 1; break;\n  case T_NOT: ret = ! calc(f->f0, bits); break;\n  case T_AND: ret = calc(f->f0, bits) & calc(f->f1, bits); break;\n  case T_OR:  ret = calc(f->f0, bits) | calc(f->f1, bits); break;\n  case T_IMP: ret = ! calc(f->f0, bits) | calc(f->f1, bits); break;\n  }\n  return ret;\n}\n\n/* main */\n\nint main() {\n  for (;;) {\n    string s;\n    cin >> s;\n    if (s == \"#\") break;\n\n    vn = fn = 0;\n    memset(vids, -1, sizeof(vids));\n\n    int pos = 0;\n    Formula *f0 = formula(s, pos);\n    pos++; // '='\n    Formula *f1 = formula(s, pos);\n    //printf(\"vn=%d\\n\", vn);\n\n    int vbits = 1 << vn;\n    bool ok = true;\n\n    for (int bits = 0; bits < vbits; bits++)\n      if (calc(f0, bits) != calc(f1, bits)) {\n\tok = false;\n\tbreak;\n      }\n\n    cout << (ok ? \"YES\" : \"NO\") << endl;\n  }\n  return 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include <iostream>\n#include <cstdio>\n#include <cstdlib>\n#include <cmath>\n#include <string>\n#include <vector>\n#include <queue>\n#include <map>\n#include <set>\n#include <algorithm>\n\n#define FOR(i,k,n) for (int i=(k); i<(int)(n); ++i)\n#define REP(i,n) FOR(i,0,n)\n#define FORIT(i,c) for(__typeof((c).begin())i=(c).begin();i!=(c).end();++i)\n#define sz size()\n#define pb push_back\n#define mp make_pair\n#define ALL(X) (X).begin(),(X).end()\n\nusing namespace std;\n\nconst int INF = 1000000000;\nconst double eps = 1e-8;\n\npair<bool,int> isT(string eq,int i) {\n  if(eq[i] == 'T' || eq[i] == 'F')\n    return make_pair(eq[i] == 'T', i);\n  else if(eq[i] == '-')  {\n    auto res = isT(eq,i+1);\n    return make_pair(!res.first, res.second);\n  } else if(eq[i] == '(') {\n    auto res1 = isT(eq,i+1);\n    pair<bool,int> res2;\n    switch(eq[res1.second+1]) {\n      case '-':\n        res2 = isT(eq,res1.second+3);\n        return make_pair(!res1.first || res2.first, res2.second+1);\n        break;\n      case '*':\n        res2 = isT(eq,res1.second+2);\n        return make_pair(res1.first && res2.first, res2.second+1);\n        break;\n      case '+':\n        res2 = isT(eq,res1.second+2);\n        return make_pair(res1.first || res2.first, res2.second+1);\n        break;\n      case '=':\n        res2 = isT(eq,res1.second+2);\n        return make_pair(res1.first == res2.first, res2.second+1);\n        break;\n    }\n  }\n}\n\nbool search(string eq) {\n  vector<bool> isExist(11);\n  for(char c : eq)\n    if(c >= 'a' && c <= 'k')\n      isExist[c-'a'] = true;\n  int mx = -1;\n  REP(i,11)\n    if(isExist[i])\n      mx = i;\n  if(mx != -1) {\n    char c = mx+'a';\n    string cpT = eq;\n    string cpF = eq;\n    for(char& d : cpT)\n      if(c == d)\n        d = 'T';\n    for(char& d : cpF)\n      if(c == d)\n        d = 'F';\n    return search(cpT) && search(cpF);\n  } else {\n    return isT('('+eq+')',0).first;\n  }\n}\n\nint main(void) {\n  while(1) {\n    string eq;\n    cin>>eq;\n    if(eq == \"#\")break;\n    bool res = search(eq);\n    if(res)\n      cout<<\"YES\"<<endl;\n    else\n      cout<<\"NO\"<<endl;\n  }\n  return 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include <iostream>\n#include <vector>\n#include <string>\n#include <algorithm>\nusing namespace std;\n\nint c;\nbool a[11];\n\nbool f(const string& s) {\n\tif(s[c] == '(') {\n\t\tc++;\n\t\tbool v1 = f(s);\n\t\tchar op = s[c++];\n\t\tif(op == '-') c++;\n\t\tbool v2 = f(s);\n\t\tc++;\n\t\tif(op == '+') return v1 | v2;\n\t\tif(op == '*') return v1 & v2;\n\t\tif(op == '-') return !(v1 & !v2);\n\t}\n\n\tif(s[c] == 'T') {\n\t\tc++;\n\t\treturn true;\n\t}\n\tif(s[c] == 'F') {\n\t\tc++;\n\t\treturn false;\n\t}\n\tif(s[c] == '-') {\n\t\tc++;\n\t\treturn !f(s);\n\t}\n\tif('a' <= s[c] && s[c] <= 'k') {\n\t\tbool v = a[s[c] - 'a'];\n\t\tc++;\n\t\treturn v;\n\t}\n\tcout << \"error\" << s << \"at \" << c << endl;\n\texit(1);\n}\n\nbool solve(string s1, string s2) {\n\tfor(int i = 0; i < (1 << 11); i++) {\n\t\tfor(int j = 0; j < 11; j++) {\n\t\t\tif(i & (1 << j)) a[j] = true;\n\t\t\telse a[j] = false;\n\t\t}\n\t\t//cout << i << \" \" << s1 + \" \" << s2 << endl;\n\t\tc = 0;\n\t\tbool res1 = f(s1);\n\t\tc = 0;\n\t\tbool res2 = f(s2);\n\n\t\tif(res1 != res2) return false;\n\t}\n\n\treturn true;\n}\n\nint main() {\n\tcin.tie(0);\n\tios::sync_with_stdio(false);\n\tstring s, s1, s2;\n\twhile(cin >> s, s != \"#\") {\n\t\tint idx = s.find('=');\n\t\ts1 = s.substr(0, idx), s2 = s.substr(idx + 1, s.size() - (idx + 1));\n\t\tcout << (solve(s1, s2) ? \"YES\" : \"NO\") << endl;\n\t}\n}"
  },
  {
    "language": "C++",
    "code": "#include <iostream>\n#include <algorithm>\n#include <cstdio>\n#include <string>\n#include <cstring>\n#include <cctype>\n#include <cstdlib>\n#include <cmath>\n#include <vector>\n#include <set>\n#include <queue>\n#include <stack>\n#include <map>\nusing namespace std;\n\n#define REP(i, s, e) for (int i = (s); i < (e); i++)\n#define REPI(i, s, e) for (int i = (s); i <= (e); i++)\n#define rep(i, n) REP(i, 0, n)\n#define repi(i, n) REPI(i, 0, n)\n#define ALL(v) (v).begin(), (v).end()\n\n#define dump(x) (cout << #x << \" = \" << x << endl)\n#define dump2(x, y) (cout << \"(\" << #x << \", \" << #y << \") = (\" << x << \", \" << y << \")\" << endl)\n#define dump3(x, y, z) (cout << \"(\" << #x << \", \" << #y << \", \" << #z << \") = (\" << x << \", \" << y << \", \"<< z << \")\" << endl)\n\ntypedef long long ll;\ntypedef pair<int, int> pii;\n\n#define MAX 11\nstring str;\nint bit;\n\nint iii;\nvoid init() { iii = 0; }\nchar get() { return str[iii++]; }\nvoid unget() { iii--; }\n\nbool formula()\n{\n\tchar ch = get();\n\n\tif ('a' <= ch && ch <= 'k')\n\t\treturn (bit>>(ch-'a'))&1;\n\n\tswitch(ch) {\n\tcase 'T': return true;\n\tcase 'F': return false;\n\tcase '-': return !formula();\n\tcase '(':\n\t\t{\n\t\t\tbool a = formula();\n\t\t\tchar op = get();\n\t\t\tif (op == '-') op = get();\n\t\t\tbool b = formula();\n\t\t\tget();\n\n\t\t\tswitch(op) {\n\t\t\t\tcase '*': return a&b;\n\t\t\t\tcase '+': return a|b;\n\t\t\t\tcase '>': return (!a)|b;\n\t\t\t}\n\t\t}\n\t}\n}\n\nbool check()\n{\n\tinit();\n\tbool a = formula();\n\tget();\n\tbool b = formula();\n\treturn a==b;\n}\n\nint main(void)\n{\n\twhile (cin >> str, str != \"#\") {\n\t\tbool f = true;\n\t\tfor (bit = 0; f && bit < (1<<MAX); bit++)\n\t\t\tf &= check();\n\t\tprintf(\"%s\\n\", f?\"YES\":\"NO\");\n\t}\n\treturn 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\n#define rep(i,n) for(int i = 0; i < n; i++)\n#define pb push_back\n#define fi first\n#define sc second\nusing namespace std;\n\nstring str;\nint pos = 0;\n\nchar cmp(char x, char y, char z){\n\tif(x == ' '){\n\t\tif(z == 'T') return 'F';\n\t\telse return 'T';\n\t}\n\tif(y == '*'){\n\t\tif(x=='T'&&z=='T') return 'T';\n\t\treturn 'F';\n\t}\n\tif(y == '+'){\n\t\tif(x=='F'&&z=='F') return 'F';\n\t\telse return 'T';\n\t}\n\tif(y == '-'){\n\t\tif(x=='T'&&z=='F') return 'F';\n\t\telse return 'T';\n\t}\n\treturn 'T';\n}\n\nchar dfs(string x){\n\tif(x[pos] == '-'){\n\t\tpos++;\n\t\treturn cmp(' ','-',dfs(x));\n\t}\n\tif(x[pos] == 'T' || x[pos] == 'F'){\n\t\tchar ret = x[pos];\n\t\tpos++;\n\t\treturn ret;\n\t}\n\tpos++;\n\tchar R = dfs(x);\n\tchar X = x[pos]; pos++; if(X == '-') pos++;\n\tchar L = dfs(x);\n\tpos++;\n\treturn cmp(R,X,L);\n}\n\nint main(){\n\twhile(cin >> str,str[0]!='#'){\n\t\tbool yes = true;\n\t\tfor(int i = 0; i < (1<<11); i++){\n\t\t\tstring s = str;\n\t\t\trep(j,s.size()){\n\t\t\t\tif('a' <= s[j] && s[j] <= 'a'+10){\n\t\t\t\t\tif((i>>(s[j]-'a'))&1){\n\t\t\t\t\t\ts[j] = 'T';\n\t\t\t\t\t} else{\n\t\t\t\t\t\ts[j] = 'F';\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t}\n\t\t\tstring S[2];\n\t\t\tint cnt = 0;\n\t\t\trep(j,s.size()){\n\t\t\t\tif(s[j] == '='){\n\t\t\t\t\tcnt++;\n\t\t\t\t\tcontinue;\n\t\t\t\t}\n\t\t\t\tS[cnt].pb(s[j]);\n\t\t\t}\n\t\t\tpos = 0;\n\t\t\tchar R = dfs(S[0]);\n\t\t\tpos = 0;\n\t\t\tchar L = dfs(S[1]);\n\t\t\t\n\t\t\tif(R != L){\n\t\t\t\tyes = false;\n\t\t\t\tbreak;\n\t\t\t}\n\t\t}\n\t\tif(yes) puts(\"YES\");\n\t\telse puts(\"NO\");\n\t}\n}"
  },
  {
    "language": "C++",
    "code": "#include <algorithm>\n#include <iostream>\n#include <cstdio>\n#include <map>\n#include <numeric>\n#include <cmath>\n#include <set>\n#include <sstream>\n#include <string>\n#include <vector>\n#include <queue>\n#include <complex>\n#include <string.h>\n#include <iomanip>\nusing namespace std;\n\ntypedef long long ll;\n\nstring s, t;\nint ind, l;\nchar c;\nint BOOL = 10007;\nint type;\nbool val;\n\nchar get() {\n  if (ind < l) \n    return s[ind++];\n  else\n    return -1;\n}\n\nvoid lex() {\n  if (c == 'T' || c == 'F') {\n    type = BOOL;\n    val = (c == 'T');\n  } else if (c == '*' || c == '+' || c == '(' || c == ')' || c == '=') {\n    type = c;\n  } else if (c == '-') {\n    if (ind < l && s[ind] == '>') {\n      c = get();\n    }\n    type = c;\n  }\n  c = get();\n}\n\nbool F() {\n  if (type == BOOL) {\n    lex();\n    return val;\n  }\n  if (type == '(') {\n    lex();\n    bool a = F();\n    char prev =type;\n    lex();\n    bool b = F();\n    if (type != ')') cout << \"F:error\" << endl;\n    bool res;\n    switch(prev) {\n    case '*': res = a && b; break;\n    case '+': res = a || b; break;\n    case '>': res = !(a && !b); break;\n    }\n    lex();\n    return res;\n  }\n  if (type == '-') {\n    lex();\n    bool f = F();\n    return !f;\n  }\n}\n\nbool E() {\n  bool a = F();\n  if (type != '=') {\n    cout << \"E:error\" << endl;\n  }\n  lex();\n  bool b = F();\n  return a == b;\n}\n\nbool alpha[11];\n\nbool rec(int k) {\n  if (k == 11) {\n    s = \"\";\n    l = t.size();\n    for (int i = 0; i < l; i++) {\n      if ('a' <= t[i] && t[i] <= 'k') \n\ts += alpha[t[i]-'a'] ? 'T' : 'F';\n      else\n\ts += t[i];\n    }\n    ind = 0;\n    c = get();\n    lex();\n    return E();\n  } else {\n    alpha[k] = true;\n    if (!rec(k+1)) return false;\n    alpha[k] = false;\n    if (!rec(k+1)) return false;\n    return true;\n  }\n}\n\nint main() {\n  ios::sync_with_stdio(false);\n  cin.tie(0);\n  cout << fixed << setprecision(15);\n\n  while (true) {\n    cin >> t;\n    if(t == \"#\") break;\n    cout << (rec(0) ? \"YES\" : \"NO\") << endl;\n  }\n}"
  },
  {
    "language": "C++",
    "code": "#include \"bits/stdc++.h\"\nusing namespace std;\ntypedef long long ll;\ntypedef pair<int,int> pii;\n#define rep(i,n) for(ll i=0;i<(ll)(n);i++)\n#define all(a)  (a).begin(),(a).end()\n#define pb push_back\n#define INF (1e9+1)\n//#define INF (1LL<<59)\n\ntypedef string::const_iterator State;\n\n\nstring getop(State &begin){\n\tif(*begin=='*'){\n\t\tbegin++;\n\t\treturn \"*\";\n\t}\n\telse if(*begin=='+'){\n\t\tbegin++;\n\t\treturn \"+\";\n\t}else{\n\t\tbegin++;\n\t\tbegin++;\n\t\treturn \"->\";\n\t}\n}\n\n\nbool mul(bool a,bool b){\n\tif(a&&b)return true;\n\telse return false;\n}\n\n\nbool add(bool a,bool b){\n\tif(!a&&!b)return false;\n\telse return true;\n}\n\n\nbool imp(bool a,bool b){\n\tif(a&&!b)return false;\n\telse return true;\n}\n\n\nbool exp(State &begin){\n\tif(isdigit(*begin)){\n\t\tbegin++;\n\t\treturn '0'+*begin;\n\t}\n\telse if(*begin=='-'){\n\t\tbegin++;\n\t\treturn !exp(begin);\n\t}else if(*begin=='('){\n\t\tbegin++;\n\t\tbool ll = exp(begin);\n\t\tstring op = getop(begin);\n\t\tbool rr = exp(begin);\n\t\tbegin++;\n\t\t\n\t\tif(op==\"*\")return mul(ll,rr);\n\t\telse if(op==\"+\")return add(ll,rr);\n\t\telse return imp(ll,rr);\n\t}\n\t\n\tassert(1);\n\treturn 0;\n}\n\n\nbool check(string s){\n\tstring left=\"\",right=\"\";\n\tbool f=false;\n\trep(i,s.size()){\n\t\tif(s[i]=='=')f=true;\n\t\telse if(f)right+=s[i];\n\t\telse left+=s[i];\n\t}\n\t\n\tState bl = left.begin(),br = right.begin();\n\tbool l = exp(bl);\n\tbool r = exp(br);\n\t\n\tif(l==r)return true;\n\telse return false;\n}\n\n\nint main(){\n\tstring s;\n\twhile(cin>>s&&s!=\"#\"){\n\t\tset<char> var;\n\t\tint c=0;\n\t\trep(i,s.size()){\n\t\t\tif(isalpha(s[i])){\n\t\t\t\tvar.insert(s[i]);\n\t\t\t}\n\t\t}\n\t\t\n\t\t\n\t\tbool f = false;\n\t\tint en = 1<<var.size();\n\t\trep(i,en){\n\t\t\tmap<char,int> mp;\n\t\t\tint num = i;\n\t\t\tfor(auto &e:var){\n\t\t\t\tmp[e] = num%2;\n\t\t\t\tnum/=2;\n\t\t\t}\n\t\t\tstring t = s;\n\t\t\trep(j,t.size()){\n\t\t\t\tif( isalpha(t[j]) ){\n\t\t\t\t\tt[j] = '0'+mp[t[j]];\n\t\t\t\t}\n\t\t\t}\n\t\t\tif(check(t)==false)f=true;\n\t\t}\n\t\tif(f)cout<<\"NO\"<<endl;\n\t\telse cout<<\"YES\"<<endl;}\n}"
  },
  {
    "language": "C++",
    "code": "#include \"bits/stdc++.h\"\n#include <sys/timeb.h>\n#include <fstream>\n\nusing namespace std;\n\n#define repl(i,a,b) for(int i=(int)(a);i<(int)(b);i++)\n#define rep(i,n) repl(i,0,n)\n#define replrev(i,a,b) for(int i=(int)(b)-1;i>=(int)(a);i--)\n#define reprev(i,n) replrev(i,0,n)\n#define repi(itr,ds) for(auto itr=ds.begin();itr!=ds.end();itr++)\n#define all(a) a.begin(),a.end()\n#define mp make_pair\n#define mt make_tuple\n#define INF 2000000000\n#define INFL 1000000000000000000LL\n#define EPS (1e-10)\n#define MOD 1000000007\n#define PI 3.1415926536\n#define RMAX 4294967295\n\ntypedef long long ll;\ntypedef pair<int, int> P;\ntypedef vector<int> vi;\ntypedef vector<ll> vll;\ntypedef vector<bool> vb;\ntypedef vector<char> vc;\ntypedef vector<string> vs;\ntypedef vector<double> vd;\ntypedef vector<P> vP;\ntypedef vector<vector<int> > vvi;\ntypedef vector<vector<bool> > vvb;\ntypedef vector<vector<ll> > vvll;\ntypedef vector<vector<char> > vvc;\ntypedef vector<vector<string> > vvs;\ntypedef vector<vector<double> > vvd;\ntypedef vector<vector<P> > vvP;\ntypedef priority_queue<int, vector<int>, greater<int> > pqli;\ntypedef priority_queue<ll, vector<ll>, greater<ll> > pqlll;\ntypedef priority_queue<P, vector<P>, greater<P> > pqlP;\n\ntypedef string::const_iterator State;\nclass ParseError {};\n/*\nstruct Edge {\nint from, to, cost;\nbool operator<(Edge e) {\nreturn cost < e.cost;\n}\n};\ntypedef vector<Edge> Edges;\ntypedef vector<Edges> Graph;\n*/\n\nbool formula(State &begin, map<char, bool> value) {\n\t//cout << *begin << endl;\n\tif (*begin == '-') {\n\t\tbegin++;\n\t\treturn !formula(begin, value);\n\t}\n\telse if (*begin == '(') {\n\t\tbegin++;\n\t\tbool ret = formula(begin, value);\n\t\tif (*begin == '*') {\n\t\t\tbegin++;\n\t\t\tbool right = formula(begin, value);\n\t\t\tret = ret && right;\n\t\t}\n\t\telse if (*begin == '+') {\n\t\t\tbegin++;\n\t\t\tbool right = formula(begin, value);\n\t\t\tret = ret || right;\n\t\t}\n\t\telse {\n\t\t\tbegin += 2;\n\t\t\tbool right = formula(begin, value);\n\t\t\tret = (!ret) || right;\n\t\t}\n\t\tbegin++;\n\t\treturn ret;\n\t}\n\telse {\n\t\tbool ret = value[*begin];\n\t\tbegin++;\n\t\treturn ret;\n\t}\n}\n\nbool equation(State &begin, map<char, bool> value) {\n\tbool lhs = formula(begin, value);\n\tbegin++;\n\tbool rhs = formula(begin, value);\n\t/*\n\tfor (auto p : value) {\n\t\tcout << p.first << \":\" << (p.second ? \"T \" : \"F \");\n\t}\n\tcout << endl << (rhs ? \"T=\" : \"F=\") << (lhs ? \"T\" : \"F\") << endl;\n\t*/\n\treturn (lhs == rhs);\n}\n\nint main(void) {\n\twhile (true) {\n\t\tstring s;\n\t\tgetline(cin, s);\n\t\tif (s[0] == '#')break;\n\n\t\tbool flag = true;\n\t\tmap<char, bool>value;\n\t\tvalue['T'] = true;\n\t\tvalue['F'] = false;\n\t\trep(i, (1 << 3)) {\n\t\t\trep(j, 3) {\n\t\t\t\tvalue['a' + j] = ((i&(1 << j)) != 0 ? true : false);\n\t\t\t}\n\n\t\t\tState begin = s.begin();\n\n\t\t\tif (!equation(begin, value)) {\n\t\t\t\tcout << \"NO\" << endl;\n\t\t\t\tflag = false;\n\t\t\t\tbreak;\n\t\t\t}\n\t\t}\n\t\tif (flag) {\n\t\t\tcout << \"YES\" << endl;\n\t\t}\n\t}\n\n\treturn 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\nusing namespace std;\n\nint pos;\nstring a, b, s;\nint var[128];\n\nbool form() {\n  if(isupper(s[pos])) return s[pos++] == 'T';\n  if(islower(s[pos])) return var[s[pos++]];\n  if(s[pos] == '-') return ++pos, !form();\n  ++pos;\n  bool x = form();\n  char op = s[pos++];\n  if(op == '-') ++pos;\n  bool y = form();\n  ++pos;\n  if(op == '*') return x && y;\n  if(op == '+') return x || y;\n  if(op == '-') return !x || y;\n  assert(false);\n}\n\nvoid rec(char c) {\n  if(c == 'l') {\n    s = a; pos = 0;\n    int va = form();\n    s = b; pos = 0;\n    int vb = form();\n    if(va != vb) throw 0;\n    return;\n  }\n  var[c] = 0; rec(c+1);\n  var[c] = 1; rec(c+1);\n}\n\nint main() {\n  while(cin >> a && a != \"#\") {\n    int k = a.find('=');\n    b = a.substr(k + 1);\n    a = a.substr(0, k);\n    try {\n      rec('a');\n      cout << \"YES\" << endl;\n    } catch(...) {\n      cout << \"NO\" << endl;\n    }\n  }\n  return 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include <stdio.h>\n#include <string.h>\n#include <ctype.h>\n#include <iostream>\n\nusing namespace std;\n\nchar al[12], r[1001], l[1001], tl[1001], tr[1001], f[11];\n\nint calc(int c,char *s){\n\tint ret = 1;\n\tif(s[c] == '('){\n\t\tint i;\n\t\tfor(i = c + 1;!(s[i] == '-' && s[i + 1] == '>') && s[i] != '+' && s[i] != '*';i++);\n\t\tif(s[i] == '-')\n\t\t\treturn !calc(c + 1,s) || calc(i + 2,s);\n\t\telse if(s[i] == '+')\n\t\t\treturn calc(c + 1,s) || calc(i + 1,s);\n\t\telse if(s[i] == '*')\n\t\t\treturn calc(c + 1,s) && calc(i + 1,s);\n\t}\n\telse if(isdigit(s[c]))\n\t\treturn s[c] - '0';\n\telse if(s[c] == '-' && s[c + 1] != '>')\n\t\treturn (calc(c + 1,s) + 1) % 2; \n}\n\nint dfs(int c){\n\tint ret = 1;\n\tunsigned int i, j;\n\tif(c == strlen(al)){\n\t\tstrcpy(tl,l);\n\t\tstrcpy(tr,r);\n\t\tfor(i = 0;i < strlen(al);i++)\n\t\t\tfor(j = 0;j < strlen(tl);j++) if(al[i] == tl[j]) tl[j] = '0' + f[i];\n\t\tfor(i = 0;i < strlen(al);i++)\n\t\t\tfor(j = 0;j < strlen(tr);j++) if(al[i] == tr[j]) tr[j] = '0' + f[i];\n\t\tret = calc(0,tl)==calc(0,tr);\n\t\tprintf(\"%s=%s\",tl,tr);\n\t\tprintf(\" %d\\n\",ret);\n\t\tret = min(1,ret);\n\t\treturn ret;\n\t}\n\tfor(i = 0;i < 2;i++){\n\t\tf[c] = i;\n\t\tret = min(ret,dfs(c + 1));\n\t}\n\treturn ret;\n}\n\n\nint main(void){\n\tunsigned int i, j;\n\tchar  c;\n\twhile(1){\n\t\tfor(i = 0;(c = getchar()) != '=' && c != '\\n';i++)\n\t\t\tl[i] = c;\n\t\tl[i] = '\\0';\n\t\tif(!strcmp(l,\"#\")) break;\n\t\tfor(i = 0;(c = getchar()) != '\\n';i++)\n\t\t\tr[i] = c;\n\t\tr[i] = '\\0';\n\t\tal[0] = '\\0';\n\t\tfor(i = 0;i < strlen(l);i++){\n\t\t\tif(islower(l[i])){\n\t\t\t\tfor(j = 0;j < strlen(al);j++)\n\t\t\t\t\tif(al[j] == l[i]) break;\n\t\t\t\tif(j == strlen(al)){\n\t\t\t\t\tal[j] = l[i];\n\t\t\t\t\tal[j + 1] = '\\0';\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t\tfor(i = 0;i < strlen(r);i++){\n\t\t\tif(islower(r[i])){\n\t\t\t\tfor(j = 0;j < strlen(al);j++)\n\t\t\t\t\tif(al[j] == r[i]) break;\n\t\t\t\tif(j == strlen(al)){\n\t\t\t\t\tal[j] = r[i];\n\t\t\t\t\tal[j + 1] = '\\0';\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t\tfor(i = 0;i < strlen(l);i++){\n\t\t\tif(l[i]=='T') l[i] = '1';\n\t\t\telse if(l[i]=='F') l[i] = '0';\n\t\t}\n\t\tfor(i = 0;i < strlen(r);i++){\n\t\t\tif(r[i]=='T') r[i] = '1';\n\t\t\telse if(r[i]=='F') r[i] = '0';\n\t\t}\n\t\tprintf(dfs(0)?\"YES\\n\":\"NO\\n\");\n\t}\n\treturn 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\nusing namespace std;\n\nint c = 0;\nbool solve(const string& s, int i){\n  c++;\n  switch (s[c-1]){\n    case 'T': return true;\n    case 'F': return false;\n    case '-': return !solve(s,i);\n    case '(':\n      bool l = solve(s,i);\n      c++;\n      switch (s[c-1]){\n        case '*': return l&&solve(s,i);\n        case '+': return l||solve(s,i);\n        case '-': c++; return (!l)||solve(s,i);\n      }\n  }\n  return (i & (1 << (s[c-1] - 'a' - 1))) != 0;\n}\nint main(){\n  string s;\n  while(cin >> s, s != \"#\"){\n    int i;\n    for(i = 0; i <= 0x7ff; i++){\n      int eq = s.find(\"=\");\n      c = 0;\n      bool r = solve(s.substr(0,eq), i);\n      c = 0;\n      bool l = solve(s.substr(eq+1), i);\n      if(r != l) break;\n    }\n    if(i>0x77f) cout << \"YES\" << endl;\n    else cout << \"NO\" << endl;\n  }\n}"
  },
  {
    "language": "C++",
    "code": "#include <cstdio>\n#include <iostream>\n#include <sstream>\n#include <iomanip>\n#include <algorithm>\n#include <cmath>\n#include <string>\n#include <vector>\n#include <list>\n#include <queue>\n#include <stack>\n#include <set>\n#include <map>\n#include <bitset>\n#include <numeric>\n#include <climits>\n#include <cfloat>\nusing namespace std;\n\nbitset<11> bs;\n\nbool solve(string s, int a, int b)\n{\n    if(s[a] == '-')\n        return !solve(s, a+1, b);\n\n    if(a == b){\n        if(s[a] == 'T')\n            return true;\n        else if(s[a] == 'F')\n            return false;\n        else\n            return bs[s[a] - 'a'];\n    }\n\n    int i = a+1;\n    int bracket = 0;\n    while(bracket != 0 || (s[i] != '*' && s[i] != '+' && s.substr(i, 2) != \"->\")){\n        if(s[i] == '(')\n            ++ bracket;\n        else if(s[i] == ')')\n            -- bracket;\n        ++ i;\n    }\n\n    if(s[i] == '*')\n        return solve(s, a+1, i-1) && solve(s, i+1, b-1);\n    else if(s[i] == '+')\n        return solve(s, a+1, i-1) || solve(s, i+1, b-1);\n    else\n        return !solve(s, a+1, i-1) || solve(s, i+2, b-1);\n}\n\nint main()\n{\n    for(;;){\n        string s;\n        cin >> s;\n        if(s == \"#\")\n            return 0;\n\n        int j = s.find('=');\n        bool ret = true;\n        for(int i=0; i<(1<<11); ++i){\n            bs = i;\n            if(solve(s, 0, j-1) != solve(s, j+1, s.size()-1))\n                ret = false;\n        }\n\n        if(ret)\n            cout << \"YES\" << endl;\n        else\n            cout << \"NO\" << endl;\n    }\n}"
  },
  {
    "language": "C++",
    "code": "#include<bits/stdc++.h>\nusing namespace std;\nint bit;\n\nbool famula(string &s, int &i){\n  //std::cout << s[i];\n  i++;\n  if(s[i - 1] == 'T'){\n    return true;\n  }else if(s[i - 1] == 'F'){\n    return false;\n  }else if(s[i - 1] == '-'){\n    return !famula(s, i);\n  }else if('a' <= s[i - 1] && s[i - 1] <= 'k'){\n    return bit&(1 << (s[i - 1] - 'a'));\n  }else{\n    bool a = famula(s, i);\n    char op = s[i++];\n    bool b = famula(s, i);\n    i++;\n    if(op == '*'){\n      return a & b;\n    }else if(op == '+'){\n      return a | b;      \n    }else if(op == '>'){\n      return (!a) | b;\n    }\n  }\n}\n\nbool equation(string &s, int &i){\n  bool val = famula(s, i), val2;\n  while(s[i++] == '='){\n    val2 = famula(s, i);\n  }\n  return val == val2;\n}\n\nint main(int argc, char *argv[]){\n  string s;\n  while(cin >> s){\n    if(s == \"#\")break;\n    for (int i = 0; i < s.length(); i++) {\n      if(s[i] == '-' && s[i + 1] == '>')s.erase(s.begin() + i--);\n    }\n    int ans = true;\n    for (bit = 0; bit < (1 << 12); bit++) {\n      int pos = 0;\n      if(equation(s, pos) == false){\n        ans = false;\n        std::cout << \"NO\" << std::endl;\n        break;\n      }\n    }\n    if(ans)std::cout << \"YES\" << std::endl;\n  }\n  return 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include <iostream>\n#include <map>\n#include <string>\n#include <cstring>\n#include <vector>\n#include <algorithm>\n#include <cstdio>\nusing namespace std;\n\n// C\n\nbool alpha[13];\n\n\n\nbool NOT(bool x){\n    return !x;\n}\n\nbool AND(bool x, bool y){\n    return (x && y);\n}\n\nbool OR(bool x, bool y){\n    return (x || y);\n}\n\nbool IMP(bool x, bool y){\n    if( x == true && y == false ) return false;\n    return true;\n}\n\n\nbool formula(string str){\n    int i;\n\n    //cout << \"debug : \" << str << endl;\n\n    if( str.length() == 1 ){ // alpha or T or F\n        if( str[0] == 'T' ) return true;\n        if( str[0] == 'F' ) return false;\n        return alpha[str[0] - 'a'];\n    }\n\n    // *,+,->\n    int x = 0;\n    for(i=0; i<str.length(); i++){\n        if( str[i] == '(' ) x++;\n        if( str[i] == ')' ) x--;\n        if( x == 0 && (str[i] == '*' || str[i] == '+' ||\n                       (i+1<str.length() && str[i] == '-' && str[i+1] == '>')) ){\n            \n            break;\n        }\n    }\n\n    if( i < str.length() ){ // \"*\" or \"+\" or \"->\"\n        if( str[i] == '*' ){\n            return AND(formula(str.substr(0,i)), formula(str.substr(i+1)));\n        }\n        else if( str[i] == '+' ){\n            return OR(formula(str.substr(0,i)), formula(str.substr(i+1)));\n        }\n        else{\n            return IMP(formula(str.substr(0,i)), formula(str.substr(i+2)));\n        }\n    }\n\n    // NOT\n    if( str[0] == '-' ){\n        //puts(\"NOT\");\n        return NOT(formula(str.substr(1)));\n    }\n\n    // 単純に括弧があるだけ\n    if( str[0] == '(' && str[str.length()-1] == ')' ){\n        //cout << \"debug2 : \" << str << \" , \" << str.substr(1,str.length()-2) << endl;\n        return formula(str.substr(1,str.length()-2));\n    }\n    \n    exit(-1);\n}\n\n\nbool equation(string in){\n    int i,j;\n    int p = in.find(\"=\");\n\n    for(i=0; i<(1<<11); i++){\n        memset(alpha, false, sizeof(alpha));\n        for(j=0; j<11; j++){\n            if( i & (1<<j) ){\n                alpha[j] = true;\n            }\n        }\n        if( formula(in.substr(0, p)) != formula(in.substr(p+1)) ){\n            return false;\n        }\n    }\n    return true;\n}\n\n\nint main(){\n    string in;\n\n    while( cin >> in, in != \"#\" ){\n        cout << (equation(in) ? \"YES\" : \"NO\") << endl;\n    }\n\n    return 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include <iostream>\n#include <sstream>\nusing namespace std;\nstring ls, rs;\nint pos;\nstring s;\nint state;\nchar c;\nvoid next(){\n  c = s[pos++];\n}\nbool formula(){\n  next();\n  if(c == '('){\n    bool f, lf = formula();\n    next();\n    if(c == '*') f = (lf && formula());\n    else if(c == '+') f = ( formula() || lf);\n    else{\n      next();\n      f = (formula() || !lf);\n    }\n    next();\n    return f;\n  }\n  else if(c == 'T') return true;\n  else if(c == 'F') return false;\n  else if(c == '-') return (!formula());\n  else return (1<<(c-'a'))&state;\n}\nbool equation(){\n  for(int i = 0; i < (1 << 11); i++){\n    state = i;\n    pos = 0;\n    bool l = formula();\n    next();\n    bool r = formula();\n    if(l != r)return false;\n  }\n  return true;\n}\nvoid solve(){\n  cout << (equation() ? \"YES\":\"NO\") << endl;  \n}\nint main(){\n  while(cin >> s && s!=\"#\"){\n    solve();\n  }\n  return 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include<iostream>\n#include<string>\nusing namespace std;\n\nstring s;\nint use;\n\nvoid ReplaceAll(string &s,string a, string b){\n  int p = s.find(a);\n  while(p!=string::npos){\n    s.replace(p,a.size(),b);\n    p = s.find(a);\n  }\n}\n\nbool parse(int l,int r){\n  int p = 0;\n  for(int i=l;i<r;i++){\n    if(s[i] == '(')p++;\n    if(s[i] == ')')p--;\n    if(!p){\n      if(s[i] == '*')return parse(l,i) && parse(i+1,r);\n      if(s[i] == '+')return parse(l,i) || parse(i+1,r);\n      if(s[i] == '-' && s[i+1] == '>')return !parse(l,i) || parse(i+2,r);\n    }\n  }\n\n  if(s[l] == '-')return !parse(l+1,r);\n  if(s[l] == '(' && s[r-1] == ')')return parse(l+1,r-1);\n  if(s[l] == 'T')return true;\n  if(s[l] == 'F')return false;\n  return ( ( use >> (s[l]-'a') ) & 1);\n}\n\nint main(){\n  while(cin >> s,s!=\"#\"){\n    ReplaceAll(s,\"--\",\"\");\n    int x = s.find(\"=\"),all = 1<<11;\n    bool f = true;\n    for(use=0;use<all;use++){\n      f &= (parse(0,x) == parse(x+1,s.size()));\n      if(!f)break;\n    }\n    cout << (f?\"YES\\n\":\"NO\\n\");\n  }\n}"
  },
  {
    "language": "C++",
    "code": "#include <iostream>\n#include <string>\n\nusing namespace std;\n\nstring input;\ntypedef string::iterator State;\n\nint m;\n\nbool cons( State &s, char ch ) {\n  if(*s == ch) {\n    s ++;\n    return true;\n  }\n  return false;\n}\n\nint formula( State &s ) {\n  \n  if(cons(s, 'T')) return true;\n  if(cons(s, 'F')) return false;\n  if(isalpha(*s)) { return (m>>(*(s++)-'a')) & 1; }\n  \n  if(cons(s, '-')) return !formula(s);\n  \n  int ret;\n  if(cons(s, '(')) {\n    ret = formula(s);\n    \n    if(cons(s, '*')) {\n      ret &= formula(s);\n    }\n    if(cons(s, '+')) {\n      ret |= formula(s);\n    }\n    if(cons(s, '-')) {\n      cons(s, '>');\n      ret = ret<=formula(s);\n    }\n\n    cons(s, ')');\n  }\n  \n  return ret;\n}\n\nint main() {\n  \n  while( getline(cin, input) ) {\n    if(input == \"#\") break;\n    bool l, r;\n    bool ok = 1;\n    for(m=0; m<(1<<11); m++) {\n      State s = input.begin();\n      l = formula(s);\n      cons(s, '=');\n      r = formula(s);\n        if(l != r) ok = 0;\n    }\n    if(ok) cout << \"YES\" << endl;\n    else cout << \"NO\" << endl;\n  }\n  \n  return 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include <iostream>\n#include <string>\n\n#define N 11\n\nusing namespace std;\n\nclass Solver {\n    private:\n        bool eval(int begin, int end, bool vars[]) {\n            if (s[begin] == 'T') {\n                return true;\n            } else if (s[begin] == 'F') {\n                return false;\n            } else if ('a' <= s[begin] && s[begin] <= 'k') {\n                return vars[s[begin] - 'a'];\n            } else if (s[begin] == '-') {\n                int count = 0;\n                while (s[begin] == '-') {\n                    ++count;\n                    ++begin;\n                }\n                if (count % 2 == 0) {\n                    return eval(begin, end, vars);\n                } else {\n                    return !eval(begin, end, vars);\n                }\n            } else {\n                int nest = 0;\n                for (int i = begin + 1; true; ++i) {\n                    if (s[i] == '(') {\n                        ++nest;\n                    } else if (s[i] == ')') {\n                        --nest;\n                    }\n                    if (nest > 0) {\n                        continue;\n                    }\n                    if (s[i] == '*') {\n                        return eval(begin + 1, i, vars) && eval(i + 1, end - 1, vars);\n                    } else if (s[i] == '+') {\n                        return eval(begin + 1, i, vars) || eval(i + 1, end - 1, vars);\n                    } else if (s[i] == '-' && s[i + 1] == '>') {\n                        return (!eval(begin + 1, i, vars)) || eval(i + 2, end - 1, vars);\n                    }\n                }\n            }\n        }\n    public:\n        string s;\n        bool is_identity() {\n            bool vars[N];\n            for (int i = 0; true; ++i) {\n                if (s[i] == '=') {\n                    for (int j = 0; j < (1 << N); ++j) {\n                        for (int k = 0; k < N; ++k) {\n                            vars[k] = j & (1 << k);\n                        }\n                        if (eval(0, i, vars) != eval(i + 1, s.length(), vars)) {\n                            return false;\n                        }\n                    }\n                    return true;\n                }\n            }\n        }\n};\n\nint main() {\n    Solver s;\n    while (true) {\n        cin >> s.s;\n        if (s.s == \"#\") {\n            return 0;\n        }\n        if (s.is_identity()) {\n            cout << \"YES\" << endl;\n        } else {\n            cout << \"NO\" << endl;\n        }\n    }\n}"
  },
  {
    "language": "C++",
    "code": "#include <iostream>\nusing namespace std;\n\nbool formula(string &s, int &p)\n{\n    if (s[p] == 'T') {\n\t++p;\n\treturn true;\n    } else if (s[p] == 'F') {\n\t++p;\n\treturn false;\n    } else if (s[p] == '-') {\n\t++p;\n\treturn !formula(s, p);\n    } else if (s[p] == '(') {\n\t++p;\n\tbool lhs = formula(s, p);\n\tif (s[p] == '*') {\n\t    ++p;\n\t    bool rhs = formula(s, p);\n\t    ++p;\n\t    return (lhs&&rhs);\n\t} else if (s[p] == '+') {\n\t    ++p;\n\t    bool rhs = formula(s, p);\n\t    ++p;\n\t    return (lhs||rhs);\n\t} else {\n\t    ++p;\n\t    ++p;\n\t    bool rhs = formula(s, p);\n\t    ++p;\n\t    if (lhs && !rhs)\n\t\treturn false;\n\t    else\n\t\treturn true;\n\t}\n    }\n}\n\nbool equation(string& s, int& p)\n{\n    bool lhs = formula(s, p);\n    ++p;\n    bool rhs = formula(s, p);\n\n    //cout << lhs << \" \" << rhs << endl;\n    if (lhs == rhs)\n\treturn true;\n    else\n\treturn false;\n}\n\nint main()\n{\n    const string V = \"abcdefghijk\";\n\n    string s;\n    while (cin >> s) {\n\tif (s == \"#\")\n\t    break;\n\n\tbool ans = true;\n\tfor (int i = 0; i < (1 <<11); ++i) {\n\t    string t = s;\n\t    for (int j = 0; j < t.size(); ++j) {\n\t\tif (binary_search(V.begin(), V.end(), t[j])) {\n\t\t    if (i & (1 << (t[j]-'a')))\n\t\t\tt[j] = 'T';\n\t\t    else\n\t\t\tt[j] = 'F';\n\t\t}\n\t    }\n\n\t    int p = 0;\n\t    if (!equation(t, p))\n\t\tans = false;\n\t}\n\n\tif (ans)\n\t    cout << \"YES\" << endl;\n\telse\n\t    cout << \"NO\" << endl;\n    }\n    return 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include <cstdio>\n#include <cstdlib>\n#include <cmath>\n#include <climits>\n#include <cfloat>\n#include <map>\n#include <utility>\n#include <ctime>\n#include <set>\n#include <iostream>\n#include <memory>\n#include <string>\n#include <vector>\n#include <algorithm>\n#include <functional>\n#include <sstream>\n#include <complex>\n#include <stack>\n#include <queue>\n#include <cstring>\n#include <numeric>\n#include <cassert>\nusing namespace std;\nstatic const double EPS = 1e-10;\ntypedef long long ll;\n#define rep(i,n) for(int i=0;i<n;i++)\n#define rev(i,n) for(int i=n-1;i>=0;i--)\n#define all(a) a.begin(),a.end()\n#define mp(a,b) make_pair(a,b)\n#define pb(a) push_back(a)\n#define SS stringstream\n#define DBG1(a) rep(_X,sz(a)){printf(\"%d \",a[_X]);}puts(\"\");\n#define DBG2(a) rep(_X,sz(a)){rep(_Y,sz(a[_X]))printf(\"%d \",a[_X][_Y]);puts(\"\");}\n#define bitcount(b) __builtin_popcount(b)\n#define EACH(i,c) for(typeof((c).begin()) i=(c).begin(); i!=(c).end(); ++i)\n\n#define delete(a,n) a.erase(remove(all(a),n),a.end())\ntemplate<typename T, typename S> vector<T>& operator<<(vector<T>& a, S b) { a.push_back(b); return a; }\ntemplate<typename T> void operator>>(vector<T>& a, int b) {while(b--)if(!a.empty())a.pop_back();}\nbool isprime(int n){ if(n<2)return false;  for(int i=2;i*i<=n;i++)if(n%i==0)return false;  return true;} \nll b_pow(ll x,ll n){return n ? b_pow(x*x,n/2)*(n%2?x:1) : 1ll;}\nstring itos(int n){stringstream ss;ss << n;return ss.str();}\n\nint val[128];\n\nstring ln;\nint pos;\n\nint fm();\n\nint eq(){\n\tint A = fm();\n\tassert(ln[pos] == '=');\n\tpos++;\n\tint B = fm();\n\treturn A == B;\n}\nint fm(){\n\t//cout << ln[pos] << endl;\n\tif( ln[pos] == 'T'){ pos++; return 1; }\n\tif( ln[pos] == 'F'){ pos++; return 0; }\n\tif( 'a' <= ln[pos] && ln[pos] <= 'k'){ pos++; return val[ln[pos-1]]; }\n\tif( ln[pos] == '-' ){ pos++;return !fm(); }\n\tif( ln[pos] == '('){\n\t\tpos++;\n\t\tint A = fm();\n\t\tif( ln[pos] == '*'){pos++; A = A & fm();}\n\t\telse if(ln[pos] == '+'){pos++; A = A | fm();}\n\t\telse if(ln[pos] == '-'){\n\t\t\tpos += 2;\n\t\t\tA = !A | fm();\n\t\t}else{\n\t\t\tassert(0);\n\t\t}\n\t\tpos++;\n\t\treturn A;\n\t}\n}\n\n\nint main(){\n\twhile(cin >> ln && ln != \"#\" ){\n\t\tint ok = 1;\n\t\tfor(int i = 0 ; i < (1<<11) ; i++){\n\t\t\tfor(int j = 0 ; j < 11 ; j++) val[j+'a'] = i>>j&1;\n\t\t\tpos = 0;\n\t\t\tok &= eq();\n\t\t}\n\t\tcout << (ok?\"YES\":\"NO\") << endl;\n\t}\n}"
  },
  {
    "language": "C++",
    "code": "#include <cassert>\n#include <iostream>\n\nusing namespace std;\n\n#define repi(i,a,b) for(int i=int(a);i<int(b);i++)\n#define rep(i,n) repi(i,0,n)\n\ntypedef pair<bool,int> parsed;\n\nparsed formula(const string& t,int i)\n{\n\tif(isupper(t[i]))\n\t\treturn parsed(t[i]=='T',i+1);\n\t\n\tif(t[i]=='-'){\n\t\tparsed p=formula(t,i+1);\n\t\tp.first^=1;\n\t\treturn p;\n\t}\n\tif(t[i]=='('){\n\t\tparsed p1=formula(t,i+1);\n\t\tint j=p1.second;\n\t\tif(t[j]=='-'){\n\t\t\tparsed p2=formula(t,j+2);\n\t\t\treturn parsed(p1.first<=p2.first,p2.second+1);\n\t\t}\n\t\tparsed p2=formula(t,j+1);\n\t\tif(t[j]=='*')\n\t\t\treturn parsed(p1.first&&p2.first,p2.second+1);\n\t\tif(t[j]=='+')\n\t\t\treturn parsed(p1.first||p2.first,p2.second+1);\n\t}\n\tassert(false);\n}\n\nbool solve(string s)\n{\n\trep(bit,1024){\n\t\tstring t;\n\t\trep(i,s.size()){\n\t\t\tif(isalpha(s[i]))\n\t\t\t\tt+=\"FT\"[bit>>s[i]-'a'&1];\n\t\t\telse\n\t\t\t\tt+=s[i];\n\t\t}\n\t\tparsed p1=formula(t.substr(0,t.find('=')),0);\n\t\tparsed p2=formula(t.substr(t.find('=')+1),0);\n\t\tif(p1.first!=p2.first)\n\t\t\treturn false;\n\t}\n\treturn true;\n}\n\nint main()\n{\n\tfor(string s;cin>>s,s!=\"#\";)\n\t\tcout<<(solve(s)?\"YES\":\"NO\")<<endl;\n\treturn 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include <iostream>\n#include <string>\n#include <map>\nusing namespace std;\n\n#define p_var(var) cout << #var << \" = \" << var << endl\n\nint num_val;\nstring input;\nint idx;\nint variable;\n\nbool formula();\nbool inpar();\nbool equation();\n\nbool formula() {\n\tswitch(input[idx++]) {\n\tcase 'T':\n\t\treturn true;\n\tcase 'F':\n\t\treturn false;\n\tcase '-':\n\t\treturn !formula();\n\tcase '(':\n\t\treturn inpar();\n\tdefault:\n\t\treturn ((variable >> (input[idx-1] - 'a')) & 1);\n\t}\n}\n\nbool inpar() {\n\tbool left = formula();\n\tchar ope = input[idx++];\n\tif(ope == '-')\n\t\t++idx;\n\tbool right = formula();\n\t++idx;\n\tswitch(ope) {\n\tcase '*':\n\t\treturn (left & right);\n\tcase '+':\n\t\treturn (left | right);\n\tdefault:\n\t\treturn ((!left) | right);\n\t}\n}\n\nbool equation() {\n\tfor(variable = 0; variable < (1<<num_val); ++variable) {\n\t\tidx = 0;\n\t\tbool left = formula();\n\t\t++idx;\n\t\tbool right = formula();\n\t\tif(left != right)\n\t\t\treturn false;\n\t}\n\treturn true;\n}\n\nint main() {\n\tcin.tie(false);\n\tios::sync_with_stdio(false);\n\t\n\twhile(cin >> input, input != \"#\") {\n\t\tnum_val = 0;\n\t\tmap<char, char> trans;\n\t\ttrans.clear();\n\t\tfor(int i=0; i<input.size(); i++) {\n\t\t\tif('a' <= input[i] && input[i] <= 'k') {\n\t\t\t\tmap<char, char>::iterator it = trans.find(input[i]);\n\t\t\t\tif(it != trans.end())\n\t\t\t\t\tinput[i] = (*it).second;\n\t\t\t\telse {\n\t\t\t\t\ttrans.insert(pair<char, char>(input[i], 'a'+(num_val)));\n\t\t\t\t\tinput[i] = 'a'+num_val++;\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t\t\t\t\n\t\tif(equation())\n\t\t\tcout << \"YES\" << endl;\n\t\telse\n\t\t\tcout << \"NO\" << endl;\n\t}\n\t\n\treturn 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include <iostream>\n#include <sstream>\n#include <cstdio>\n#include <cstring>\n#include <cstdlib>\n#include <cmath>\n#include <ctime>\n#include <vector>\n#include <string>\n#include <map>\n#include <set>\n#include <deque>\n#include <queue>\n#include <stack>\n#include <functional>\n#include <algorithm>\n\nusing namespace std;\n\n#define rep(i,j) REP((i), 0, (j))\n#define REP(i,j,k) for(int i=(j);(i)<(k);++i)\n#define BW(a,x,b) ((a)<=(x)&&(x)<=(b))\n#define ALL(v) (v).begin(), (v).end()\n#define LENGTHOF(x) (sizeof(x) / sizeof(*(x)))\n#define AFILL(a, b) fill((int*)a, (int*)(a + LENGTHOF(a)), b)\n#define SQ(x) ((x)*(x))\n#define Mod(x, mod) (((x)+(mod)%(mod))\n#define MP make_pair\n#define PB push_back\n#define Fi first\n#define Se second\n#define INF (1<<29)\n#define EPS 1e-10\n#define MOD 1000000007\n\ntypedef pair<int, int> pi;\ntypedef pair<int, pi> pii;\ntypedef vector<int> vi;\ntypedef queue<int> qi;\ntypedef long long ll;\n\nint expr(string& s, int& i);\nint term(string& s, int& i);\nint fact(string& s, int& i);\nint invt(string& s, int& i);\nint bina(string& s, int& i);\n\nint expr1(string &s, int& i){\n  int val = expr(s, i);\n  while(s[i]=='-'&&s[i+1]=='>'){\n    i+=2;\n    int x = expr(s, i);\n    if(val&&!x) val = 0;\n    else val = 1;\n  }\n  return val;\n}\n\nint expr(string &s, int &i){\n  int val = term(s, i);\n  while(s[i]=='+'){\n    i++;\n    val |= term(s, i);\n  }\n  return val;\n}\n\nint term(string& s, int& i){\n  int val = fact(s, i);\n  while(s[i]=='*'){\n    i++;\n    int x = fact(s, i);\n    val &= x;\n  }\n  return val;\n}\n\nint invt(string& s, int& i){\n  if(isdigit(s[i])) return fact(s, i);\n  while(s[i]=='-'){\n    i++;\n    int x = fact(s, i);\n    return !x;\n  }\n}\n\nint fact(string& s, int& i){\n  if(s[i]=='-') return invt(s, i);\n  if(isdigit(s[i])) return bina(s, i);\n  i++;\n  int ret = expr1(s,i);\n  i++;\n  return ret;\n}\n\nint bina(string& s, int& i){\n  return s[i++]-'0';\n}\n\nint C(string S, string T){\n  //  cout << S << \" \" << T << endl;\n  rep(i,(1<<11)-1){\n    string s,t; s = S; t = T;\n    rep(j, s.size()){\n      if(s[j] < 'a' || s[j] > 'k') continue;\n      s[j] = ((i>>(s[j]-'a'))&1)+'0';\n    }\n    rep(j, t.size()){\n      if(t[j] < 'a' || t[j] > 'k') continue;\n      t[j] = ((i>>(t[j]-'a'))&1)+'0';\n    }\n    //    cout << s << \" \" << t << endl;\n    int p = 0, q = 0;\n    if(expr(s, p) != expr(t,q)) return 0;\n  }\n  return 1;\n}\n\nint main(){\n  string S;\n  while(cin >> S, S != \"#\"){\n    int pos;\n    rep(i,S.size()){\n      if(S[i]=='T') S[i] = '1';\n      if(S[i]=='F') S[i] = '0';\n      if(S[i]=='=') pos = i;\n    }\n    cout << (C(S.substr(0,pos), S.substr(pos+1))?\"YES\":\"NO\") << endl;\n  }\n  return 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include<iostream>\n#include<string>\n#include<map>\nusing namespace std;\nbool vars[11];\npair<string, string> equation(string str){\n  int i=0;\n  for(i=0;i<(int)str.length();i++){\n    if(str[i]=='=')break;\n  }\n  return make_pair(str.substr(0, i),str.substr(i+1));\n}\nbool formula(string str){\n  //cout<<str<<endl;\n  bool ret;\n  if(str == \"T\"){\n    ret= true;\n  }else if(str == \"F\"){\n    ret= false;\n  }else if('a'<= str[0] && str[0] <= 'k'){\n    ret= vars[str[0]-'a'];\n  }else if(str[0] == '-'){\n    ret= !formula(str.substr(1));\n  }else if(str[0]=='('){\n    int tcur=1;\n    int opc=-1;\n    int op=-1;\n    int depth=0;\n    while(tcur<(int)str.length()){\n      if(str[tcur]=='('){\n        depth++;\n      } else if(str[tcur]==')'){\n        depth--;\n      }else if(depth==0){\n        if(str[tcur]=='+'){\n          op=1;opc=tcur;\n          break;\n        }else if(str[tcur]=='*'){\n          op=2;opc=tcur;\n          break;\n        }else if(str[tcur]=='-'\n                 &&tcur+1<(int)str.length()\n                 &&str[tcur+1]=='>'){\n          tcur++;\n          op=3;opc=tcur;\n          break;\n        }\n        \n      }\n        tcur++;\n    }\n    switch(op){\n    case -1:\n      return formula(str.substr(1,str.length()-2));\n    case 1:\n      return formula(str.substr(1,opc-1))\n        ||formula(str.substr(opc+1, str.length()-1 - (opc+1)));\n    case 2:\n      return formula(str.substr(1,opc-1))\n        &&formula(str.substr(opc+1, str.length()-1 - (opc+1)));\n    case 3:\n      return !(formula(str.substr(1,opc-2))\n               &&!formula(str.substr(opc+1, str.length()-1 - (opc+1))));\n    default:\n      cout<<\"ERROR!\"<<endl;\n      return false;\n    }\n  }else {\n    cout<<\"ERROR\"<<\" \"<<str<<endl;\n    return false;\n  }\n  return ret;\n}\nbool dfs(int depth, string a, string b){\n  if(depth==11){\n    if(formula(a)==formula(b))return true;\n    return false;\n  }else{\n    vars[depth]=true;\n    if(!dfs(depth+1, a, b))return false;\n    vars[depth]=false;\n    if(!dfs(depth+1, a, b))return false;\n    return true;\n  }\n}\nint main(){\n  string str;\n  pair<string, string> eq;\n  while(cin>>str&&str!=\"#\"){\n    eq=equation(str);\n    if(dfs(0, eq.first, eq.second)){\n      cout<<\"YES\"<<endl;\n    }else {\n      cout<<\"NO\"<<endl;\n    }\n  }\n  return 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include <iostream>\n#include <string>\n#include <vector>\n#include <algorithm>\n#include <utility>\n#include <cstring>\n#include <cmath>\n#include <queue>\n#include <map>\n#include <set>\nusing namespace std;\n\n#define rep(i,n) for(int i=0; i<n; i++)\n#define FOR(i,s,n) for(int i=s; i<n; i++)\n#define ALL(x) x.begin(), x.end()\ntypedef long long ll;\ntypedef unsigned long long ull;\ntypedef pair<int,int> pii;\ntypedef vector<int> vi;\n\nstring solve( string s ) {\n\tif( s == \"0\" || s == \"1\" ) return s;\n\trep(i, s.length()) {\n\t\tif(s[i] == '(') {\n\t\t\tint p = i+1;\n\t\t\twhile(p<s.length() && s[p]!=')') p++;\n\t\t\tstring ss = solve(s.substr(i+1, p-i-1));\n\t\t\ts.replace(i, p-i+1, ss);\n\t\t}\n\t}\n\n\trep(i, s.length()) {\n\t\tif(s[i] == '*') {\n\t\t\tstring sa = solve(s.substr(0, i));\n\t\t\tstring sb = solve(s.substr(i+1));\n\t\t\ts = (sa==\"1\" && sb==\"1\") ? \"1\" : \"0\";\n\t\t}\n\t\telse if(s[i] == '+') {\n\t\t\tstring sa = solve(s.substr(0, i));\n\t\t\tstring sb = solve(s.substr(i+1));\n\t\t\ts = (sa==\"0\" && sb==\"0\") ? \"0\" : \"1\";\n\t\t}\n\t\telse if(s[i] == '-' && i+1<s.length() && s[i+1]=='>') {\n\t\t\tstring sa = solve(s.substr(0, i));\n\t\t\tstring sb = solve(s.substr(i+2));\n\t\t\ts = (sa==\"1\" && sb==\"0\") ? \"0\" : \"1\";\n\t\t}\n\t}\n\trep(i, s.length()) {\n\t\tif(s[i] == '-') {\n\t\t\tstring ss = solve(s.substr(i+1));\n\t\t\ts = (ss==\"0\" ? \"1\" : \"0\");\n\t\t}\n\t}\n\treturn s;\n}\n\nint main() {\n\tstring in;\n\twhile(cin >> in, in!=\"#\") {\n\t\tstring aa, ab;\n\t\trep(i, in.length()) {\n\t\t\tif( in[i] == 'T' ) {\n\t\t\t\tin[i] = '1';\n\t\t\t}\n\t\t\telse if( in[i] == 'F' ) {\n\t\t\t\tin[i] = '0';\n\t\t\t}\n\t\t}\n\t\trep(i, in.length()) {\n\t\t\tif( in[i] == '=' ) {\n\t\t\t\taa = in.substr(0, i);\n\t\t\t\tab = in.substr(i+1);\n\t\t\t\tbreak;\n\t\t\t}\n\t\t}\n\t\tbool ng = false;\n\t\trep(i, (1<<11)) {\n\t\t\tstring a=aa, b=ab;\n\t\t\trep(j, a.length()) {\n\t\t\t\tif('a'<=a[j] && a[j]<='k') {\n\t\t\t\t\ta[j] = '0' + ((i & (1<<a[j]-'a')) ? 1 : 0);\n\t\t\t\t}\n\t\t\t}\n\t\t\trep(j, b.length()) {\n\t\t\t\tif('a'<=b[j] && b[j]<='k') {\n\t\t\t\t\tb[j] = '0' + ((i & (1<<b[j]-'a')) ? 1 : 0);\n\t\t\t\t}\n\t\t\t}\n\t\t\ta = solve(a);\n\t\t\tb = solve(b);\n\t\t\tif( a != b ) {\n\t\t\t\tcout << \"NO\" << endl;\n\t\t\t\tng = true;\n\t\t\t\tbreak;\n\t\t\t}\n\t\t}\n\t\tif( !ng ) {\n\t\t\tcout << \"YES\" << endl;\n\t\t}\n\t}\n\treturn 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include <iostream>\n#include <string>\nusing namespace std;\n \nstring input;\nint m;\ntypedef string::iterator State;\n\nbool cons( State &s, char ch ) {\n  if(*s == ch) {\n    s ++;\n    return true;\n  }\n  return false;\n}\n \nint formula( State &s ) {\n   \n  if(cons(s, 'T')) return true;\n  if(cons(s, 'F')) return false;\n  if(isalpha(*s)) { return (m>>(*(s++)-'a')) & 1; }\n   \n  if(cons(s, '-')) return !formula(s);\n   \n  int ret;\n  if(cons(s, '(')) {\n    ret = formula(s);\n     \n    if(cons(s, '*')) {\n      ret &= formula(s);\n    }\n    if(cons(s, '+')) {\n      ret |= formula(s);\n    }\n    if(cons(s, '-')) {\n      cons(s, '>');\n      ret = ret<=formula(s);\n    }\n \n    cons(s, ')');\n  }\n   \n  return ret;\n}\n \nint main() {\n   \n  while( getline(cin, input) ) {\n    if(input == \"#\") break;\n    bool l, r;\n    bool ok = 1;\n    for(m=0; m<(1<<11); m++) {\n      State s = input.begin();\n      l = formula(s);\n      cons(s, '=');\n      r = formula(s);\n        if(l != r) ok = 0;\n    }\n    if(ok) cout << \"YES\" << endl;\n    else cout << \"NO\" << endl;\n  }\n   \n  return 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include <cstdio>\n#include <cstring>\n#include <string>\n#include <iostream>\n#include <cctype>\n#include <vector>\nusing namespace std;\ntypedef string::const_iterator State;\n\n\nvector<int> term(State &begin);\nvector<int> formula(State &begin);\nvector<int> factor(State &begin);\n\nstring data[2];\nvector<int> g[2];\n\nvector<int> formula(State &begin){\n\tvector<int> del(1<<11,0);\n\tint flag=1;\n\tif(*begin=='-'){\n\t\tflag=0;\n\t\tbegin++;\n\t}\n\tif(*begin>='a' && *begin<='k'){\n\t\tfor(int i=0;i<(1<<11);i++){\n\t\t\tdel[i]=1-flag;\n\t\t\tif(i>>(*begin-'a') & 1)del[i]=flag;\n\t\t}\n\t}\n\tif(*begin=='T'){\n\t\tfor(int i=0;i<(1<<11);i++){\n\t\t\tdel[i]=flag;\n\t\t}\n\t}\n\tif(*begin=='F'){\n\t\tfor(int i=0;i<(1<<11);i++){\n\t\t\tdel[i]=1-flag;\n\t\t}\n\t}\n\tbegin++;\n\treturn del;\n}\n\nvector<int> factor(State &begin){\n\tbool flag=false;\n\tif(*begin=='-'){\n\t\tflag=true;\n\t\tbegin++;\n\t}\n\tif(*begin=='('){\n\t\tbegin++;\n\t\tvector<int> ret=term(begin);\n\t\tif(flag){\n\t\t\tfor(int i=0;i<(1<<11);i++){\n\t\t\t\tret[i]=1-ret[i];\n\t\t\t}\n\t\t}\n\t\tbegin++;\n\t\treturn ret;\n\t}else{\n\t\tvector<int> ret=formula(begin);\n\t\tif(flag){\n\t\t\tfor(int i=0;i<(1<<11);i++){\n\t\t\t\tret[i]=1-ret[i];\n\t\t\t}\t\n\t\t}\n\t\treturn ret;\n\t}\n}\n\nvector<int> term(State &begin){\n\tvector<int> ret=factor(begin);\n\twhile(1){\n\t\tif(*begin=='+'){\n\t\t\tbegin++;\n\t\t\tvector<int> ret2=factor(begin);\n\t\t\tfor(int i=0;i<(1<<11);i++){\n\t\t\t\tret[i]=ret[i]|ret2[i];\n\t\t\t}\n\t\t}\n\t\tif(*begin=='*'){\n\t\t\tbegin++;\n\t\t\tvector<int> ret2=factor(begin);\n\t\t\tfor(int i=0;i<(1<<11);i++){\n\t\t\t\tret[i]=ret[i]&ret2[i];\n\t\t\t}\n\t\t}\n\t\tif(*begin=='-'){\n\t\t\tbegin++;\n\t\t\tif(*begin=='>'){\n\t\t\t\tbegin++;\n\t\t\t\tvector<int> ret2=factor(begin);\n\t\t\t\tfor(int i=0;i<(1<<11);i++){\n\t\t\t\t\tret[i]=(ret[i]==0)|ret2[i];\n\t\t\t\t}\n\t\t\t}else{\n\t\t\t\tprintf(\"error\\n\");\n\t\t\t\treturn ret;\n\t\t\t}\n\t\t}else{\n\t\t\tbreak;\n\t\t}\n\t}\n\treturn ret;\n}\n\nint main(void){\n\twhile(1){\n\t\tstring str;\n\t\tcin >> str;\n\t\tif(str==\"#\")break;\n\t\tdata[0]=data[1]=\"\";\n\t\tint v=0;\n\t\tfor(int i=0;i<str.size();i++){\n\t\t\tif(str[i]=='=')v++;\n\t\t\telse data[v]+=str[i];\n\t\t}\n\t\tfor(int i=0;i<2;i++){\n\t\t\tState begin=data[i].begin();\n\t\t\tg[i]=term(begin);\n\t\t}\n\t\tbool flag=true;\n\t\tfor(int i=0;i<1<<11;i++){\n\t\t\t//if(i<4)printf(\"%d %d\\n\",g[0][i],g[1][i]);\n\t\t\tif(g[0][i]!=g[1][i])flag=false;\n\t\t}\n\t\tprintf(\"%s\\n\",flag?\"YES\":\"NO\");\n\t}\n\treturn 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include<iostream>\n#include<string>\n#define MAX 11\nusing namespace std;\nbool o;\nvoid rec(string s){\n  if(!o) return;\n  //cout << s << endl;\n  bool f;\n  int p;\n\n  \n  if(s.find(\"-0\")!=-1){\n    p=s.find(\"-0\");\n    s[p]='1';s[p+1]=' ';\n    f=true;\n  }\n  if(s.find(\"-1\")!=-1){\n    p=s.find(\"-1\");\n    s[p]='0';s[p+1]=' ';\n    f=true;\n  }\n  \n  /*\n  while(s.find(\"(0*0)\")!=-1){\n    p=s.find(\"(0*0)\");\n    s[p]='0';s[p+1]=' ';s[p+2]=' ';s[p+3]=' ';s[p+4]=' ';\n    f=true;\n  }\n  while(s.find(\"(0*1)\")!=-1){\n    p=s.find(\"(0*1)\");\n    s[p]='0';s[p+1]=' ';s[p+2]=' ';s[p+3]=' ';s[p+4]=' ';\n    f=true;\n  }\n  while(s.find(\"(1*0)\")!=-1){\n    p=s.find(\"(1*0)\");\n    s[p]='0';s[p+1]=' ';s[p+2]=' ';s[p+3]=' ';s[p+4]=' ';\n    f=true;\n  }\n  while(s.find(\"(1*1)\")!=-1){\n    p=s.find(\"(1*1)\");\n    s[p]='1';s[p+1]=' ';s[p+2]=' ';s[p+3]=' ';s[p+4]=' ';\n    f=true;\n  }\n  while(s.find(\"(0+0)\")!=-1){\n    p=s.find(\"(0+0)\");\n    s[p]='0';s[p+1]=' ';s[p+2]=' ';s[p+3]=' ';s[p+4]=' ';\n    f=true;\n  }\n  while(s.find(\"(0+1)\")!=-1){\n    p=s.find(\"(0+1)\");\n    s[p]='1';s[p+1]=' ';s[p+2]=' ';s[p+3]=' ';s[p+4]=' ';\n    f=true;\n  }\n  while(s.find(\"(1+0)\")!=-1){\n    p=s.find(\"(1+0)\");\n    s[p]='1';s[p+1]=' ';s[p+2]=' ';s[p+3]=' ';s[p+4]=' ';\n    f=true;\n  }\n  while(s.find(\"(1+1)\")!=-1){\n    p=s.find(\"(1+1)\");\n    s[p]='1';s[p+1]=' ';s[p+2]=' ';s[p+3]=' ';s[p+4]=' ';\n    f=true;\n  }\n  \n  while(s.find(\"(0->0)\")!=-1){\n    p=s.find(\"(0->0)\");\n    s[p]='1';s[p+1]=' ';s[p+2]=' ';s[p+3]=' ';s[p+4]=' ';s[p+5]=' ';\n    f=true;\n  }\n  while(s.find(\"(0->1)\")!=-1){\n    p=s.find(\"(0->1)\");\n    s[p]='1';s[p+1]=' ';s[p+2]=' ';s[p+3]=' ';s[p+4]=' ';s[p+5]=' ';\n    f=true;\n  }\n  while(s.find(\"(1->0)\")!=-1){\n    p=s.find(\"(1->0)\");\n    s[p]='0';s[p+1]=' ';s[p+2]=' ';s[p+3]=' ';s[p+4]=' ';s[p+5]=' ';\n    f=true;\n  }\n  while(s.find(\"(1->1)\")!=-1){\n    p=s.find(\"(1->1)\");\n    s[p]='1';s[p+1]=' ';s[p+2]=' ';s[p+3]=' ';s[p+4]=' ';s[p+5]=' ';\n    f=true;\n  }\n  */\n  if(f){\n    string b;\n    for(int i=0;i<s.size();i++) if(s[i]!=' ') b+=s[i];\n    rec(b);\n  }else{\n    if(s[0]!=s[2]) o=false;\n    return;\n  }\n}\nvoid init(int n,string s){\n  int i,j;\n  for(i=0;i<s.size();i++){\n    for(j=0;j<=MAX;j++){\n      if(s[i]=='a'+j) s[i]='0'+(n>>j&1);\n      if(s[i]=='T') s[i]='1';\n      if(s[i]=='F') s[i]='0';\n    }\n  }\n  rec(s);\n}\nint main(){\n  string s;\n  while(cin >> s,s!=\"#\"){\n    o=true;\n    int i;\n    for(i=0;i<(1<<MAX);i++)\n      init(i,s);\n    cout << (o?\"YES\":\"NO\") << endl;\n  }\n  return 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include <stdio.h>\n#include <assert.h>\n#include <iostream>\n#include <string>\nusing namespace std;\n#define rep(i, n) for (int i = 0; i < (int)(n); i++)\n\nstring _s;\nunsigned _ix;\n\nchar token() { return _ix < _s.size() ? _s[_ix] : 0; }\nvoid next() { _ix++; }\n\nint vars;\n\nbool expr() {\n    if (token() == 'T') { next(); return true; }\n    if (token() == 'F') { next(); return false; }\n    if (islower(token())) {\n        const int ix =  token() - 'a';\n        next();\n        return vars & (1<<ix);\n    }\n    if (token() == '-') {\n        next();\n        return !expr();\n    }\n    assert(token() == '(');\n    next();\n    const bool a = expr();\n    int op = -1;\n    if (token() == '*') op = 0;\n    if (token() == '+') op = 1;\n    if (token() == '-') op = 2, next();\n    next();\n    const bool b = expr();\n    assert(token() == ')');\n    next();\n    if (op == 0) return a&b;\n    if (op == 1) return a|b;\n    if (op == 2) return (!a)|b;\n    assert(false);\n    return false;\n}\n\nbool parse(const string& s) {\n    _s = s;\n    _ix = 0;\n    return expr();\n}\n\nint main() {\n    for (;;) {\n        string src;\n        getline(cin, src);\n        if (src == \"#\") return 0;\n        const int pos = src.find('=');\n        const string left = src.substr(0, pos), right = src.substr(pos+1);\n        bool ans = true;\n        rep (b, 1<<11) {\n            vars = b;\n            if (parse(left) != parse(right)) { ans = false; break; }\n        }\n        puts(ans ? \"YES\" : \"NO\");\n    }\n}"
  },
  {
    "language": "C++",
    "code": "\n#include <iostream>\n#include <string>\n#include <string.h>\n\nusing namespace std;\n\nstring s;\nint i;\nbool f[256];\n\nbool imp(bool x, bool y){\n\tif ( x &&  y)return true;\n\tif ( x && !y)return false;\n\tif (!x &&  y)return true;\n\tif (!x && !y)return true;\n}\n\nbool form(){\n\t\n\tif (s[i] == 'T'){ i++; return true; }\n\tif (s[i] == 'F'){ i++; return false; }\n\n\tif (s[i] >= 'a' && s[i] <= 'k'){\n\t\ti++; return f[s[i]];\n\t}else\n\tif (s[i] == '-'){\n\t\ti++; return !form();\n\t}else\n\tif (s[i] == '('){\n\t\ti++; bool c = form();\n\n\t\tif (s[i] == '*'){\n\t\t\ti++;  bool tc = form(); i++; return tc && c;\n\t\t}\n\t\tif (s[i] == '+'){\n\t\t\ti++;  bool tc = form(); i++; return tc || c;\n\t\t}\n\t\tif(s[i] == '-' && s[i+1] == '>')\n\t\t{\n\t\t\ti+=2; bool tc = form(); i++; return imp(c,tc);\n\t\t}\n\t}\n}\n\nbool equation(){\n\ti = 0;\n\tbool t = form();i++;\n\treturn t == form();\n}\n\nbool dfs(int n){\n\n\tif (n == 'k' + 1){\n\t\treturn equation();\n\t}\n\tf[n] = true;\n\tbool ret = dfs(n+1);\n\tf[n] = false;\n\treturn ret && dfs(n + 1);\n}\n\n\nint main()\n{\n\n\twhile (cin >> s && s != \"#\"){\n\t\tmemset(f,0,256*sizeof(bool));\n\t\ts += \" \";\n\t\tif (dfs('a'))\n\t\t\tcout << \"YES\" << endl;\n\t\telse\n\t\t\tcout << \"NO\" << endl;\n\t}\n\n\treturn 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include <functional>\n#include <iostream>\n#include <memory>\n#include <string>\n#include <unordered_set>\n#include <vector>\n#define loop(i, a, n) for (int i = (a); i < (n); i++)\n#define rep(i, n) loop(i, 0, n)\ntemplate<typename A> using F = std::function<A>;\nusing namespace std;\n\ntemplate<typename T> struct ParseResult {\n  bool succeeded;\n  T object;\n  size_t pos;\n  ParseResult(const bool succeeded, const T &object, const size_t pos) : succeeded(succeeded), object(object), pos(pos) {}\n  friend std::ostream &operator<<(std::ostream &os, const ParseResult<T> &p) { return os << '{' << (p.succeeded ? \"true\" : \"false\") << ',' << p.object << ',' << p.pos << '}'; }\n};\n\ntemplate<typename T> using Parser = std::function<ParseResult<T>(const std::string &, size_t)>;\n\nParser<std::string> token(std::string s) {\n  const size_t n = s.size();\n  return [n = std::move(n), s = std::move(s)](const std::string &target, const size_t pos) {\n    if (target.size() < n) return ParseResult<std::string>(false, {}, pos);\n    return target.substr(pos, n) == s ? ParseResult<std::string>(true, s, pos + n) : ParseResult<std::string>(false, {}, pos);\n  };\n}\n\ntemplate<typename T> Parser<T> operator||(Parser<T> p1, Parser<T> p2) {\n  return [p1 = std::move(p1), p2 = std::move(p2)](const std::string &target, const size_t pos) {\n    auto r = p1(target, pos);\n    if (r.succeeded) return r;\n    r = p2(target, pos);\n    if (r.succeeded) return r;\n    return ParseResult<T>(false, {}, pos);\n  };\n}\n\ntemplate<typename T1, typename T2> Parser<std::pair<T1, T2>> operator+(Parser<T1> p1, Parser<T2> p2) {\n  return [p1 = std::move(p1), p2 = std::move(p2)](const std::string &target, const size_t pos) {\n    auto r1 = p1(target, pos);\n    if (!r1.succeeded) return ParseResult<std::pair<T1, T2>>(false, {}, pos);\n    auto r2 = p2(target, r1.pos);\n    if (!r2.succeeded) return ParseResult<std::pair<T1, T2>>(false, {}, pos);\n    return ParseResult<std::pair<T1, T2>>(true, {r1.object, r2.object}, r2.pos);\n  };\n}\n\ntemplate<typename T1, typename T2> Parser<T2> operator>>(Parser<T1> p1, Parser<T2> p2) {\n  return [p1 = std::move(p1), p2 = std::move(p2)](const std::string &target, const size_t pos) {\n    auto r1 = p1(target, pos);\n    if (!r1.succeeded) return ParseResult<T2>(false, {}, pos);\n    auto r2 = p2(target, r1.pos);\n    if (!r2.succeeded) return ParseResult<T2>(false, {}, pos);\n    return ParseResult<T2>(true, r2.object, r2.pos);\n  };\n}\n\ntemplate<typename T1, typename T2> Parser<T1> operator<<(Parser<T1> p1, Parser<T2> p2) {\n  return [p1 = std::move(p1), p2 = std::move(p2)](const std::string &target, const size_t pos) {\n    auto r1 = p1(target, pos);\n    if (!r1.succeeded) return ParseResult<T1>(false, {}, pos);\n    auto r2 = p2(target, r1.pos);\n    if (!r2.succeeded) return ParseResult<T1>(false, {}, pos);\n    return ParseResult<T1>(true, r1.object, r2.pos);\n  };\n}\n\nParser<char> oneOf(const std::string &s) {\n  std::unordered_set<char> d;\n  for (auto &c : s) d.insert(c);\n  return [d = std::move(d)](const std::string &target, const size_t pos) {\n    if (target.size() <= pos) return ParseResult<char>(false, {}, pos);\n    char c = target[pos];\n    return d.count(c) ? ParseResult<char>(true, c, pos + 1) : ParseResult<char>(false, {}, pos);\n  };\n}\n\ntemplate<typename T, typename S, typename F> Parser<S> fmap(Parser<T> p, F &&f) {\n  return [p = std::move(p), f = std::forward<F>(f)](const std::string &target, const size_t pos) {\n    auto r = p(target, pos);\n    return r.succeeded ? ParseResult<S>(true, f(r.object), r.pos) : ParseResult<S>(false, {}, r.pos);\n  };\n}\n\ntemplate<typename T, typename F> Parser<T> lazy(const F &f) {\n  bool instantiated = false;\n  Parser<T> p;\n  Parser<T> &&q = [f = std::move(f), p = std::move(p), instantiated = std::move(instantiated)](const std::string &target, const size_t pos) mutable {\n    if (!instantiated) {\n      p = f();\n      instantiated = true;\n    }\n    return p(target, pos);\n  };\n  return [q = std::make_shared<Parser<T>>(std::move(q))](const std::string &target, const size_t pos) { return (*q)(target, pos); };\n}\n\nstruct SyntaxTree {\n  string op;\n  char value;\n  vector<SyntaxTree> children;\n  SyntaxTree() {}\n  SyntaxTree(const string &op, const char value, const vector<SyntaxTree> &children) : op(op), value(value), children(children) {}\n};\n\nint main() {\n  Parser<SyntaxTree> formulaP = lazy<SyntaxTree>([&]() {\n    auto andP = fmap<pair<SyntaxTree, SyntaxTree>, SyntaxTree>((token(\"(\") >> formulaP << token(\"*\")) + (formulaP << token(\")\")), [](auto &o) { return SyntaxTree(\"*\", {}, {o.first, o.second}); });\n    auto orP = fmap<pair<SyntaxTree, SyntaxTree>, SyntaxTree>((token(\"(\") >> formulaP << token(\"+\")) + (formulaP << token(\")\")), [](auto &o) { return SyntaxTree(\"+\", {}, {o.first, o.second}); });\n    auto impP = fmap<pair<SyntaxTree, SyntaxTree>, SyntaxTree>((token(\"(\") >> formulaP << token(\"->\")) + (formulaP << token(\")\")), [](auto &o) { return SyntaxTree(\"->\", {}, {o.first, o.second}); });\n    auto notP = fmap<SyntaxTree, SyntaxTree>(token(\"-\") >> formulaP, [](auto &o) { return SyntaxTree(\"-\", {}, {o}); });\n    auto valP = fmap<char, SyntaxTree>(oneOf(\"abcdefghijkTF\"), [](char x) { return SyntaxTree({}, x, {}); });\n    return andP || orP || impP || notP || valP;\n  });\n  auto equationP = (formulaP << token(\"=\")) + formulaP;\n  string s;\n  while (cin >> s, s != \"#\") {\n    auto r = equationP(s, 0);\n    bool isValid = true;\n    rep(i, 1 << 11) {\n      auto toBool = [&](char c) -> bool {\n        if (c == 'T') return true;\n        if (c == 'F') return false;\n        return i >> (c - 'a') & 1;\n      };\n      F<bool(const SyntaxTree &)> evalF = [&](const SyntaxTree &f) {\n        switch (f.children.size()) {\n          case 0: return toBool(f.value);\n          case 1: return !evalF(f.children[0]);\n          case 2:\n            if (f.op == \"*\") return evalF(f.children[0]) && evalF(f.children[1]);\n            if (f.op == \"+\") return evalF(f.children[0]) || evalF(f.children[1]);\n            if (f.op == \"->\") return !evalF(f.children[0]) || evalF(f.children[1]);\n        }\n      };\n      isValid &= evalF(r.object.first) == evalF(r.object.second);\n    }\n    cout << (isValid ? \"YES\" : \"NO\") << endl;\n  }\n}"
  },
  {
    "language": "C++",
    "code": "#include<iostream>\n#include<string>\nusing namespace std;\n\nint mynot(int a){\n\tif(a==1) return 0;\n\treturn 1;\n}\n\nint myand(int a,int b){\n\tif(a==1 && b==1) return 1;\n\treturn 0;\n}\n\nint myor(int a,int b){\n\tif(a==0 && b==0) return 0;\n\treturn 1;\n}\n\nint naraba(int a,int b){\n\tif(a==0 || (a==1 && b==1)) return 1;\n\treturn 0;\n}\n\nstring s;\nint bit=0;\nint p=0;\n\nint to_int(char a){\n\tif(a=='T') return 1;\n\tif(a=='F') return 0;\n\tint k=a-'a';\n\tif(bit & (1<<k)) return 1;\n\treturn 0;\n}\n\n\nint calc(){\n\tif(isalpha(s[p])) return to_int(s[p++]);\n\tif(s[p]=='-'){\n\t\tp++;\n\t\treturn mynot(calc());\n\t}\n\tif(s[p]=='('){\n\t\tp++;\n\t\tint res1=calc();\n\t\tif(s[p]=='*'){\n\t\t\tp++;\n\t\t\tint res2=calc();\n\t\t\tp++;\n\t\t\treturn myand(res1,res2);\n\t\t}\n\t\telse if(s[p]=='+'){\n\t\t\tp++;\n\t\t\tint res2=calc();\n\t\t\tp++;\n\t\t\treturn myor(res1,res2);\n\t\t}\n\t\telse if(s[p]=='-'){\n\t\t\tp+=2; //>を読み飛ばす\n\t\t\tint res2=calc();\n\t\t\tp++;\n\t\t\treturn naraba(res1,res2);\n\t\t}\n\t}\n\tcout<<\"Error \"<<s[p]<<endl;\n\treturn -1;\n}\n\n\nint main()\n{\n\twhile(cin>>s && s[0]!='#'){\n\n\t\tbool ok=true;\n\t\tfor(bit=0;bit<(1<11);bit++){\n\t\t\tp=0;\n\t\t\tint ans1=calc();\n\t\t\tp++;\n\t\t\tint ans2=calc();\n\t\t\tif(ans1!=ans2){ok=false;break;}\n\t\t}\n\t\tif(ok) cout<<\"YES\"<<endl;\n\t\telse cout<<\"NO\"<<endl;\n\t}\n\treturn 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include <functional>\n#include <iostream>\n#include <string>\n#include <unordered_set>\n#include <vector>\n#define loop(i, a, n) for (int i = (a); i < (n); i++)\n#define rep(i, n) loop(i, 0, n)\ntemplate<typename A> using F = std::function<A>;\nusing namespace std;\n\ntemplate<typename T> struct ParseResult {\n\tbool succeeded;\n\tT object;\n\tint pos;\n\tParseResult(ParseResult&& other) : succeeded(other.succeeded), object(std::move(other.object)), pos(other.pos) {}\n\tParseResult& operator=(ParseResult&& other) { succeeded = (other.succeeded); object = (std::move(other.object)); pos = (other.pos); }\n\tParseResult(const bool succeeded, const T &object, const int pos) : succeeded(succeeded), object(object), pos(pos) {}\n\tfriend std::ostream &operator<<(std::ostream &os, const ParseResult<T> &p) { return os << '{' << (p.succeeded ? \"true\" : \"false\") << ',' << p.object << ',' << p.pos << '}'; }\n};\n\ntemplate<typename T> using Parser = std::function<ParseResult<T>(std::string, int)>;\n\nParser<std::string> token(std::string &&s) {\n\tconst int n = s.size();\n\treturn[n = std::move(n), s = std::move(s)](const std::string &target, const int pos) {\n\t\tif (target.size() < n) return ParseResult<std::string>(false, {}, pos);\n\t\treturn target.substr(pos, n) == s ? ParseResult<std::string>(true, s, pos + n) : ParseResult<std::string>(false, {}, pos);\n\t};\n}\n\ntemplate<typename T> Parser<T> operator||(const Parser<T> &p1, const Parser<T> &p2) {\n\treturn[p1 = std::move(p1), p2 = std::move(p2)](const std::string &target, const int pos) {\n\t\tauto r = p1(target, pos);\n\t\tif (r.succeeded) return r;\n\t\tr = p2(target, pos);\n\t\tif (r.succeeded) return r;\n\t\treturn ParseResult<T>(false, {}, pos);\n\t};\n}\n\ntemplate<typename T1, typename T2> Parser<std::pair<T1, T2>> operator+(const Parser<T1> &p1, const Parser<T2> &p2) {\n\treturn[p1 = std::move(p1), p2 = std::move(p2)](const std::string &target, const int pos) {\n\t\tauto r1 = p1(target, pos);\n\t\tif (!r1.succeeded) return ParseResult<std::pair<T1, T2>>(false, {}, pos);\n\t\tauto r2 = p2(target, r1.pos);\n\t\tif (!r2.succeeded) return ParseResult<std::pair<T1, T2>>(false, {}, pos);\n\t\treturn ParseResult<std::pair<T1, T2>>(true, { r1.object, r2.object }, r2.pos);\n\t};\n}\n\ntemplate<typename T1, typename T2> Parser<T2> operator>>(const Parser<T1> &p1, const Parser<T2> &p2) {\n\treturn[p1 = std::move(p1), p2 = std::move(p2)](const std::string &target, const int pos) {\n\t\tauto r1 = p1(target, pos);\n\t\tif (!r1.succeeded) return ParseResult<T2>(false, {}, pos);\n\t\tauto r2 = p2(target, r1.pos);\n\t\tif (!r2.succeeded) return ParseResult<T2>(false, {}, pos);\n\t\treturn ParseResult<T2>(true, r2.object, r2.pos);\n\t};\n}\n\ntemplate<typename T1, typename T2> Parser<T1> operator<<(const Parser<T1> &p1, const Parser<T2> &p2) {\n\treturn[p1 = std::move(p1), p2 = std::move(p2)](const std::string &target, const int pos) {\n\t\tauto r1 = p1(target, pos);\n\t\tif (!r1.succeeded) return ParseResult<T1>(false, {}, pos);\n\t\tauto r2 = p2(target, r1.pos);\n\t\tif (!r2.succeeded) return ParseResult<T1>(false, {}, pos);\n\t\treturn ParseResult<T1>(true, r1.object, r2.pos);\n\t};\n}\n\nParser<char> oneOf(const std::string &s) {\n\tstd::unordered_set<char> d;\n\tfor (auto &c : s) d.insert(c);\n\treturn[d = std::move(d)](const std::string &target, const int pos) {\n\t\tif (target.size() <= pos) return ParseResult<char>(false, {}, pos);\n\t\tchar c = target[pos];\n\t\treturn d.count(c) ? ParseResult<char>(true, c, pos + 1) : ParseResult<char>(false, {}, pos);\n\t};\n}\n\ntemplate<typename T, typename S, typename F> Parser<S> fmap(const Parser<T> &p, const F &f) {\n\treturn[p = std::move(p), f = std::move(f)](const std::string &target, const int pos) {\n\t\tauto r = p(target, pos);\n\t\treturn r.succeeded ? ParseResult<S>(true, f(r.object), r.pos) : ParseResult<S>(false, {}, r.pos);\n\t};\n}\n\ntemplate<typename T, typename F> Parser<T> lazy(const F &f) {\n\tbool instantiated = false;\n\tParser<T> p;\n\treturn[f = std::move(f), p = std::move(p), instantiated = std::move(instantiated)](const std::string &target, const int pos) mutable {\n\t\tif (!instantiated) {\n\t\t\tp = f();\n\t\t\tinstantiated = true;\n\t\t}\n\t\treturn p(target, pos);\n\t};\n}\n\nstruct SyntaxTree {\n\tstring op;\n\tchar value;\n\tvector<SyntaxTree> children;\n\tSyntaxTree() {}\n\tSyntaxTree(const string &op, const char value, const vector<SyntaxTree> &children) : op(op), value(value), children(children) {}\n};\n\nint main() {\n\tParser<SyntaxTree> formulaP = lazy<SyntaxTree>([&]() {\n\t\tauto andP = fmap<pair<SyntaxTree, SyntaxTree>, SyntaxTree>((token(\"(\") >> formulaP << token(\"*\")) + (formulaP << token(\")\")), [](auto &o) { return SyntaxTree(\"*\", {}, { o.first, o.second }); });\n\t\tauto orP = fmap<pair<SyntaxTree, SyntaxTree>, SyntaxTree>((token(\"(\") >> formulaP << token(\"+\")) + (formulaP << token(\")\")), [](auto &o) { return SyntaxTree(\"+\", {}, { o.first, o.second }); });\n\t\tauto impP = fmap<pair<SyntaxTree, SyntaxTree>, SyntaxTree>((token(\"(\") >> formulaP << token(\"->\")) + (formulaP << token(\")\")), [](auto &o) { return SyntaxTree(\"->\", {}, { o.first, o.second }); });\n\t\tauto notP = fmap<SyntaxTree, SyntaxTree>(token(\"-\") >> formulaP, [](auto &o) { return SyntaxTree(\"-\", {}, { o }); });\n\t\tauto valP = fmap<char, SyntaxTree>(oneOf(\"abcdefghijkTF\"), [](char x) { return SyntaxTree({}, x, {}); });\n\t\treturn andP || orP || impP || notP || valP;\n\t});\n\tauto equationP = (formulaP << token(\"=\")) + formulaP;\n\tstring s;\n\twhile (cin >> s, s != \"#\") {\n\t\tauto r = equationP(s, 0);\n\t\tbool isValid = true;\n\t\trep(i, 1 << 11) {\n\t\t\tauto toBool = [&](char c) -> bool {\n\t\t\t\tif (c == 'T') return true;\n\t\t\t\tif (c == 'F') return false;\n\t\t\t\treturn i >> (c - 'a') & 1;\n\t\t\t};\n\t\t\tF<bool(SyntaxTree)> evalF = [&](const SyntaxTree &f) {\n\t\t\t\tswitch (f.children.size()) {\n\t\t\t\tcase 0: return toBool(f.value);\n\t\t\t\tcase 1: return !evalF(f.children[0]);\n\t\t\t\tcase 2:\n\t\t\t\t\tif (f.op == \"*\") return evalF(f.children[0]) && evalF(f.children[1]);\n\t\t\t\t\tif (f.op == \"+\") return evalF(f.children[0]) || evalF(f.children[1]);\n\t\t\t\t\tif (f.op == \"->\") return !evalF(f.children[0]) || evalF(f.children[1]);\n\t\t\t\t}\n\t\t\t};\n\t\t\tisValid &= evalF(r.object.first) == evalF(r.object.second);\n\t\t}\n\t\tcout << (isValid ? \"YES\" : \"NO\") << endl;\n\t}\n}"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\nusing namespace std;\n\nvector<string> opr{\"->\", \"+\", \"*\", \"-\"};\nvector<string> num{\"1\", \"2\", \"3\", \"4\"};\n\nvoid add_para(string &exp) {\n    auto find_idx = exp.find(\"4\");\n    while (find_idx != string::npos) {\n        if (exp[find_idx + 1] == '(') {\n            int end_idx = find_idx + 2;\n            int count = 1;\n            while (count) {\n                if (exp[end_idx] == '(') count++;\n                else if (exp[end_idx] == ')') count--;\n                end_idx++;\n            }\n            exp.insert(end_idx, \")\");\n            exp[find_idx] = '5';\n            exp.insert(find_idx, \"(\");\n        } else {\n            exp.insert(find_idx + 2, \")\");\n            exp[find_idx] = '5';\n            exp.insert(find_idx, \"(\");\n        }\n\n        find_idx = exp.find(\"4\");\n    }\n}\n\nbool calc(string exp, int bits) {\n    if (exp == \"T\") return true;\n    else if (exp == \"F\") return false;\n    else if (exp.size() == 1) {\n        if (bits & (1 << (exp[0] - 'a'))) return true;\n        else return false;\n    }\n\n    if (exp[1] == '5') return !calc(string(exp.begin() + 2, exp.end() - 1), bits);\n    int idx;\n    for (int i = 1, len = exp.size(), count = 0; i < len - 1; i++) {\n        if (exp[i] == '(') count++;\n        else if (exp[i] == ')') count--;\n        if (count == 0 && '1' <= exp[i] && exp[i] <= '5') idx = i;\n    }\n\n    bool lhs = calc(string(exp.begin() + 1, exp.begin() + idx), bits);\n    bool rhs = calc(string(exp.begin() + idx + 1, exp.end() - 1), bits);\n\n    if (exp[idx] == '1') return !(lhs && !rhs);\n    if (exp[idx] == '2') return (lhs || rhs);\n    if (exp[idx] == '3') return (lhs && rhs);\n}\n\nvoid solve(string str) {\n    for (int i = 0, len = opr.size(); i < len; i++) {\n        auto find_idx = str.find(opr[i]);\n        while (find_idx != string::npos) {\n            str.replace(find_idx, (int)(opr[i].size()), num[i]);\n            find_idx = str.find(opr[i]);\n        }\n    }\n    int eq_idx = str.find(\"=\");\n    string exp1 = string(str.begin(), str.begin() + eq_idx);\n    string exp2 = string(str.begin() + eq_idx + 1, str.end());\n\n    add_para(exp1);\n    add_para(exp2);\n\n    bool flag = true;\n    for (int i = 0; i < (1 << 11); i++) {\n        if (calc(exp1, i) != calc(exp2, i)) {\n            flag = false;\n            break;\n        }\n    }\n\n    if (flag == true) cout << \"YES\" << endl;\n    else cout << \"NO\" << endl;\n}\n\nint main() {\n    string Input;\n    while (cin >> Input, Input != \"#\") solve(Input);\n\n    return 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\nusing namespace std;\n\n#define rep(i,x,y) for(int i=(x);i<(y);++i)\n#define debug(x) #x << \"=\" << (x)\n\n#ifdef DEBUG\n#define _GLIBCXX_DEBUG\n#define print(x) std::cerr << debug(x) << \" (L:\" << __LINE__ << \")\" << std::endl\n#else\n#define print(x)\n#endif\n\nconst int inf=1e9;\nconst int64_t inf64=1e18;\nconst double eps=1e-9;\n\ntemplate <typename T> ostream &operator<<(ostream &os, const vector<T> &vec){\n    os << \"[\";\n    for (const auto &v : vec) {\n    \tos << v << \",\";\n    }\n    os << \"]\";\n    return os;\n}\n\nusing i64=int64_t;\n\nbool eval_formula(string &formula,int &i){\n    if(formula[i]=='T'){\n        ++i;\n        return true;\n    }\n    if(formula[i]=='F'){\n        ++i;\n        return false;\n    }\n    if(formula[i]=='-'){\n        ++i;\n        return !eval_formula(formula,i);\n    }\n    if(formula[i]=='('){\n        ++i;\n        bool left=eval_formula(formula,i);\n        \n        string op;\n        switch(formula[i]){\n            case '*':\n            op='*';\n            ++i;\n            break;\n            \n            case '+':\n            op='+';\n            ++i;\n            break;\n            \n            case '-':\n            op=\"->\";\n            ++i;\n            ++i;\n            break;\n\n            default:\n            assert(false);\n            break;\n        }\n        \n        bool right=eval_formula(formula,i);\n        assert(formula[i]==')');\n        ++i;\n        \n        bool res;\n        if(op==\"*\") res=left and right;\n        if(op==\"+\") res=left or right;\n        if(op==\"->\") res=!left or right;\n        return res;\n    }\n    print(formula);\n    print(i);\n    assert(false);\n}\n\npair<string,string> pair_formula(string& equation){\n    string formula1,formula2;\n    rep(i,0,equation.size()) if(equation[i]=='='){\n        formula1=equation.substr(0,i);\n        formula2=equation.substr(i+1);\n        break;\n    }\n    return make_pair(formula1,formula2);\n}\n\nvoid solve(string equation){\n    map<char,vector<int>> vals;\n    rep(i,0,equation.size()) if('a'<= equation[i] and equation[i]<='z') vals[equation[i]].push_back(i);\n    \n    if(vals.empty()){\n        auto pf=pair_formula(equation);\n        int i1=0,i2=0;\n        if(eval_formula(pf.first,i1)==eval_formula(pf.second,i2)) cout << \"YES\" << endl;\n        else cout << \"NO\" << endl;\n        return;\n    }\n\n    bool equal=true;\n    rep(assign,0,1<<vals.size()){\n        int i=0;\n        for(auto &p:vals){\n            for(int j:p.second){\n                if(1&(assign>>i)) equation[j]='T';\n                else equation[j]='F';\n            }\n            ++i;\n        }\n        auto pf=pair_formula(equation);\n        int i1=0,i2=0;\n        if(eval_formula(pf.first,i1)!=eval_formula(pf.second,i2)){\n            equal=false;\n            break;\n        }\n    }\n\n    if(equal) cout << \"YES\" << endl;\n    else cout << \"NO\" << endl;\n}\n\nint main(){\n    std::cin.tie(0);\n    std::ios::sync_with_stdio(false);\n    cout.setf(ios::fixed);\n    cout.precision(16);\n    for(;;){\n        string equation;\n        cin >> equation;\n        if(equation==\"#\") break;\n        solve(equation);\n    }\n    return 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\n\nusing namespace std;\n\ntypedef long long LL;\ntypedef pair<int, int> PII;\ntypedef long double LD;\ntypedef pair<LD, LD> PLDLD;\n\n#define FOR(i,a,b) for(int i=(a);i<(b);++i)\n#define REP(i,n)  FOR(i,0,n)\n#define CLR(a) memset((a), 0 ,sizeof(a))\nLL MOD = 1e9+7;\nLL INF = 1e9;\n\nstring t;\nint l;\nint v[11];\nint var(int i)\n{\n    return v[i];\n}\n\nint e1()\n{\n    if(t[l]=='(')\n    {\n        l++;\n        int p=e1(),r;\n        l++;\n        switch(t[l-1])\n        {\n            case '*':\n            r=e1();\n            l++;\n            return p*r;\n            \n            case '+':\n            r=e1();\n            l++;\n            return p+r>=1?1:0;\n            \n            case '-':\n            l++;\n            r=e1();\n            l++;\n            return (1-p)+r>=1?1:0;\n        }\n    }\n    \n    if(t[l]=='-')\n    {\n        l++;\n        return 1-e1();\n    }\n    else if(t[l]=='T')\n    {\n        l++;\n        return 1;\n    }\n    else if(t[l]=='F')\n    { \n        l++;\n        return 0;\n    }\n    else return var(t[l++]-'a');    \n}\n\nint main()\n{\n    string s;\n    while(cin>>s,s!=\"#\")\n    {\n        string s1,s2;\n        REP(i,s.size())\n        {\n            if(s[i]=='=')\n            {\n                s1=string(s.substr(0,i));\n                s2=string(s.substr(i+1));\n            }\n        }\n        int r,p;bool flag=true;\n        REP(i,1<<11)\n        {\n            REP(j,11)\n            {\n                v[j]=(i>>j)&1;\n            }\n            \n            t=s1;l=0;\n            p=e1();\n            t=s2;l=0;\n            r=e1();\n            if(r!=p)\n            {\n                flag=false;\n                break;\n            }\n        }\n        \n        if(flag)\n            cout<<\"YES\"<<endl;\n        else\n            cout<<\"NO\"<<endl;\n    }\n}"
  },
  {
    "language": "C++",
    "code": "#include <iostream>\n#include <string>\nusing namespace std;\n\nlong long int h[11];\nstring in;\nlong long int l[4][4] = { { 0, 0, 0, 1 }, { 0, 1, 1, 1 }, { 1, 1, 0, 1 }, { 1, 0, 0, 1 } };\n\npair< long long int, long long int > kansu( long long int n ) {\n\n  long long int hitei = 0;\n  long long int k[2];\n  long long int b = 0;\n  long long int e;\n\n  while( true ) {\n\n    if ( in[n] == '-' && in[n+1] != '>' ) {\n      hitei = 1;\n      n++;\n    }else if ( in[n] == '*' ) {\n      e = 0;\n      n++;\n    }else if ( in[n] == '+' ) {\n      e = 1;\n      n++;\n    }else if ( in[n] == '-' ) {\n      e = 2;\n      n += 2;\n    }else if ( in[n] == '=' ) {\n      e = 3;\n      n++;\n    }else if ( in[n] == ')' ) {\n      if ( hitei == 1 ) k[0] ^= 1;\n      return make_pair( k[0], n );\n    }else {\n      if ( in[n] == '(' ) {\n\tpair< long long int, long long int > p = kansu( n + 1 );\n\tk[b] = p.first;\n\tn = p.second + 1;\n      }else if ( in[n] == 'T' ) {\n\tk[b] = 1;\n\tn++;\n      }else if ( in[n] == 'F' ) {\n\tk[b] = 0;\n\tn++;\n      }else {\n\tk[b] = h[ in[n] - 'a' ];\n\tn++;\n      }\n      if ( hitei == 1 ) k[b] ^= 1;\n      if ( b == 0 ) {\n\tb++;\n\thitei = 0;\n      }else {\n\t//\tcout << k[0] << \" \" << e << \" \" << k[1] << \" = \" << l[e][ k[0] * 2 + k[1] ] << endl;\n\treturn make_pair( l[e][ k[0] * 2 + k[1] ], n );\n      }\n    }\n\n  }\n\n}\n\nint main() {\n\n  while( true ) {\n\n    cin >> in;\n    if ( in == \"#\" ) break;\n\n    bool b = true;\n\n    for ( long long int i = 0; i < (1<<11); i++ ) {\n      long long int k = i;\n      for ( long long int j = 0; j < 11; j++ ) {\n\th[j] = k % 2;\n\tk /= 2;\n      }\n      if ( kansu( 0 ).first == 0 ) {\n\tb = false;\n\tbreak;\n      }\n    }\n    if ( b == true ) {\n      cout << \"YES\" << endl;\n    }else {\n      cout << \"NO\" << endl;\n    }\n\n  }\n\n  return 0;\n\n}"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\nusing namespace std;\nint i, v; string s;\nint P() {\n  i++;\n  if(s[i]=='T') return 1;\n  if(s[i]=='F') return 0;\n  if(isalpha(s[i])) return v>>(s[i]-'a')&1;\n  if(s[i]=='-') return !P();\n  int l=P();\n  i++;char o=s[i];if(o=='-')i++;\n  int r=P();i++;\n  if(o=='*') return l&r;\n  if(o=='+') return l|r;\n  if(o=='-') return l<=r;\n}\n \nint main() {\n  while(cin>>s) {\n    if(s==\"#\") break;\n    bool k=true;\n    for(v=0;v<(1<<11);v++) {\n      i=-1; int l=P();\n      i++;\n      if(l!=P()) { k=false; break; }\n    }\n    cout<<(k ? \"YES\\n\":\"NO\\n\");\n  }\n  return 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\nusing namespace std;\nconst int dx[]={1,0,0,-1,1,-1,-1,1};\nconst int dy[]={0,1,-1,0,1,1,-1,-1};\nconst int INF = 1<<30;\nconst double EPS = 1e-8;\n#define PB push_back\n#define mk make_pair\n#define fr first\n#define sc second\n#define reps(i,j,k) for(int i = (j); i < (k); ++i)\n#define rep(i,j) reps(i,0,j)\n#define MOD 1000000007\n#define lengthof(x) (sizeof(x) / sizeof(*(x)))\ntypedef vector<int> vi;\ntypedef vector<vi> vvi;\ntypedef pair<int,int> Pii;\ntypedef pair<int,vi > P;\ntypedef long long ll;\nbool number(string& ,int& );\nbool rev(string& ,int& );\nbool term(string& ,int& );\nbool number(string &s,int& i){\n    if(s[i++] == 'T'){\n        return true;\n    }\n    else{\n        return false;\n    }\n}\n\nbool rev(string& s,int& i){\n    if(isalpha(s[i]))return number(s,i);\n    if(s[i] == '-'){\n        while(s[i] == '-'){\n            i++;\n            return !rev(s,i);\n        }\n    }\n    i++;\n    bool ret = term(s,i);\n    i++;\n    return ret;\n}\nbool term(string& s ,int& i){\n    bool val = rev(s,i);\n    while(s[i] == '+' || s[i] == '*' || s[i] == '&'){\n        char op = s[i];\n        i++;\n        bool val2 = rev(s,i);\n        if(op == '+'){\n            val |= val2;\n        }\n        else if(op == '*'){\n            val &= val2;\n        }\n        else if(op == '&'){\n            val = !(val & !val2);\n        }\n    }\n    return val;\n}\nmap < string , int > memo;\nbool select(string a,string b,int depth){\n    bool ans = false;\n    if(depth == 11){\n        if(memo[a+b])return (bool)(memo[a+b]-1);\n        //cout << a << \" \" << b << \" \";\n        int idx = 0;\n        bool p = term(a,idx);\n        //cout << \"*\" << idx << \" \";\n        idx = 0;\n        bool q = term(b,idx);\n        //cout << \"*\" << idx << \" \";\n        //cout << p << \" \" << q  << \"\\n\";\n        ans |= !(p==q);\n        memo[a+b] = 1+(int)ans;\n        return ans;\n    }\n    string aT,aF;\n    aT = \"\";\n    aF = \"\";\n    rep(i,a.size()){\n        if(a[i] == depth+'a'){\n            aT += \"T\";\n            aF += \"F\";\n        }\n        else{\n            aT += a[i];\n            aF += a[i];\n        }\n    }\n    string bT,bF;\n    bT = \"\";\n    bF = \"\";\n    rep(i,b.size()){\n        if(b[i] == depth+'a'){\n            bT += \"T\";\n            bF += \"F\";\n        }\n        else{\n            bT += b[i];\n            bF += b[i];\n        }\n    }\n    ans |= select(aT,bT,depth+1);\n    ans |= select(aF,bF,depth+1);\n    return ans;\n}\nint main(){\n    string tmp;\n    while(true){\n        memo.clear();\n        string a;\n        string b;\n        cin >> tmp;\n        if(tmp == \"#\")break;\n         \n        int idx = 0;\n        while(tmp[idx] != '='){\n            if(tmp[idx] == '-' && tmp[idx+1] == '>'){\n                a += \"&\";\n                idx+=2;\n                continue;\n            }\n            a += tmp[idx]; \n            idx++;\n        }\n        reps(i,idx+1,tmp.size()){\n            if(tmp[i] == '-' && tmp[idx+1] == '>'){\n                b += \"&\";\n                i++;\n                continue;\n            }\n            b += tmp[i];\n        }\n        !select(a,b,0) ? puts(\"YES\") : puts(\"NO\");\n    }\n    return 0;\n}"
  },
  {
    "language": "C++",
    "code": "#define TEST_MODE false\n\n#define _CRT_SECURE_NO_WARNINGS\n#define _USE_MATH_DEFINES\n\n#include \"bits/stdc++.h\"\nusing namespace std;\n#define rep(i, n) for (int i = 0; i < (n); ++i)\n#define rep2(i, a, b) for (int i = (a); i < (b); ++i)\n#define rrep(i, n) for (int i = (n)-1; i >= 0; --i)\n#define rrep2(i, a, b) for (int i = (a)-1; i >= b; --i)\n#define range(i, a, b, c) for (int i = a;             \\\n                               c > 0 ? i < b : i > b; \\\n                               i += c)\n#define chmax(a, b) (a = (a) < (b) ? (b) : (a))\n#define chmin(a, b) (a = (a) > (b) ? (b) : (a))\nusing ll = long long;\nusing ull = unsigned long long;\nusing ld = long double;\n#define all(a) begin(a), end(a)\n#define ifnot(a) if (not(a))\n#define int long long\n\n#ifdef LOCAL_ENV\n\n#if TEST_MODE == true\nconst bool test = true;\n#define dump(x) cerr << #x << \" = \" << (x) << endl\n#else\nconst bool test = false;\n#define dump(x) \n#endif\n\n#else\nconst bool test = false;\n#define dump(x) \n#endif\n\nint dx[] = {1, 0, -1, 0};\nint dy[] = {0, 1, 0, -1};\nconst int INF = (int)1 << 60;\nconst ll INFL = (ll)1 << 60;\nll mod_n = (int)1e9 + 7;\nconst double eps = 1e-10;\ntypedef long double Real;\n// return -1, 0, 1\nint sgn(const Real &r) { return (r > eps) - (r < -eps); }\nint sgn(const Real &a, const Real &b) { return sgn(a - b); }\n\n//.....................\nconst int MAX = (int)2e5 + 5;\n\nvector<string> split(const string &str, char sep)\n{\n    vector<string> v;\n    stringstream ss(str);\n    string buffer;\n    while (getline(ss, buffer, sep))\n    {\n        v.push_back(buffer);\n    }\n    return v;\n}\n\ntemplate <class InputIterator>\nint sum(InputIterator begin, InputIterator end)\n{\n    return accumulate(begin, end, 0ll);\n}\n\nvoid solve();\n\nsigned main()\n{\n    cout << fixed << setprecision(20);\n    while (true) {\n        solve();\n    }\n    return 0;\n}\n\n// class Mycin {\n// \tbool flag = true;\n// public:\n// \tMycin& operator >> (int& a) {flag = scanf(\"%lld\", &a) != EOF; return *this;}\n// \tMycin& operator >> (char& a) {flag = scanf(\"%c\", &a) != EOF; return *this;}\n// \tMycin& operator >> (string& s) {flag = (bool)(cin >> s); return *this;}\n// \toperator bool() {return flag;}\n// } mycin;\n \n// class Mycout {\n// public:\n// \tMycout& operator << (const int& a) {printf(\"%lld\", a); return *this;}\n// \tMycout& operator << (const char c) {printf(\"%c\", c); return *this;}\n// \tMycout& operator << (const string& s) {printf(\"%s\", s.c_str()); return *this;}\n// } mycout;\n \n// #define cin mycin\n// #define cout mycout\n// #define endl '\\n'\n\nint equation(const string& s, int& i);\nint formula(const string& s, int& i);\n\nint equation(const string& s, int& i) {\n    int a = formula(s, i);\n    dump(a);\n    i++;\n    int b = formula(s, i);\n    dump(b);\n    if (a == b) return 1;\n    else        return 0;\n}\n\nint formula(const string& s, int& i) {\n    int res = -1;\n    if (isdigit(s[i])) {\n        res = s[i++] - '0';\n    }\n    else if (s[i] == '-') {\n        i++;\n        res = ! formula(s, i);\n    }\n    else if (s[i] == '(') {\n        i++;\n        int a = formula(s, i);\n        string op;\n        op += s[i++];\n        if (op == \"-\") {\n            op += s[i++];\n        }\n        int b = formula(s, i);\n        i++;\n        if (op == \"*\") res = a * b;\n        if (op == \"+\") res = min((int)1, a + b);\n        if (op == \"->\") {\n            if (a == 1 && b == 0) res = 0;\n            else res = 1;\n        }\n    }\n    // dump(res);\n    return res;\n}\n\nint eval(const string& s) {\n    int i = 0;\n    return equation(s, i);\n}\n\nbool ok(string ori_s, int mask) {\n    string s;\n    rep(i, (int)ori_s.size()) {\n        s += ori_s[i];\n        if (isupper(s[i])) {\n            if (s[i] == 'T') s[i] = '1';\n            else             s[i] = '0';\n        }\n        if (islower(s[i])) {\n            s[i] = ((mask >> (s[i] - 'a')) & 1) + '0';\n        }\n    }\n    // dump(s);\n    return eval(s);\n}\n\nvoid solve() {\n    string ori_s;\n    cin >> ori_s;\n    if (ori_s == \"#\") exit(0);\n    bool ok_flag = true;\n    rep(i, 1 << 15) {\n        ok_flag = ok_flag && ok(ori_s, i);\n    }\n    if (ok_flag) cout << \"YES\" << endl;\n    else cout << \"NO\" << endl;\n}"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\nusing namespace std;\n#define int long long\n// #define stoi stoll\nusing ll=long long;\nusing vi=vector<int>;\nusing pii=pair<int,int>;\n#define ALL(c) begin(c),end(c)\n#define RALL(c) rbegin(c),rend(c)\n#define ITR(i,b,e) for(auto i=(b);i!=(e);++i)\n#define FORE(x,c) for(auto &x:c)\n#define REPF(i,a,n) for(int i=a,i##len=(int)(n);i<i##len;++i)\n#define REP(i,n) REPF(i,0,n)\n#define REPR(i,n) for(int i=(int)(n);i>=0;--i)\n#define SZ(c) ((int)c.size())\n#define CONTAIN(c,x) (c.find(x)!=end(c))\n#define OUTOFRANGE(y,x,h,w) (y<0||x<0||y>=h||x>=w)\n#define dump(...)\nconst signed INF_=1001001001; const ll INF=1001001001001001001LL;\nconst int DX[9]={0,1,0,-1,1,1,-1,-1,0},DY[9]={-1,0,1,0,-1,1,1,-1,0};\ntemplate<class T> ostream& operator<<(ostream &os,const vector<T> &v) {\n    ITR(i,begin(v),end(v))os<<*i<<(i==end(v)-1?\"\":\"\\n\");return os;}\ntemplate<class T> istream& operator>>(istream &is,vector<T> &v) {\n    ITR(i,begin(v),end(v)) is>>*i;return is;}\ntemplate<class T,class U> istream& operator>>(istream &is, pair<T,U> &p) {\n    is>>p.first>>p.second;return is;}\ntemplate<class T> bool chmax(T &a,const T &b){if(a<b){a=b;return 1;}return 0;}\ntemplate<class T> bool chmin(T &a,const T &b){if(a>b){a=b;return 1;}return 0;}\ntemplate<class T> using heap=priority_queue<T,vector<T>,greater<T>>;\nstruct{template<class T> operator T(){T x;cin>>x;return x;}} IN;\nstruct before_main_function {\n    before_main_function() {\n        cin.tie(0);ios::sync_with_stdio(false);\n        cout<<setprecision(15)<<fixed;\n        #define endl \"\\n\"\n    }\n} before_main_function;\n//------------------8<------------------------------------8<--------------------\n\n/*\n<equation> ::= <formula> '=' <formula>\n<formula> ::= <constant> | <variable> | <term> | <negative>\n<term> ::= '(' (<formula> '*' <formula> | <formula> '+' <formula> | <formula> \"->\" <formula>) ')'\n<negative> ::= '-' <formula>\n */\nbool equation(string &s,int &i,int var);\nbool formula(string &s,int &i,int var);\nbool constant(string &s,int &i,int var);\nbool variable(string &s,int &i,int var);\nbool term(string &s,int &i,int var);\nbool negative(string &s,int &i,int var);\n\nbool equation(string &s,int &i,int var) {\n    bool left=formula(s,i,var);\n    assert(s[i]=='=');\n    i++;\n    bool right=formula(s,i,var);\n    return left==right;\n}\nbool formula(string &s,int &i,int var) {\n    if(s[i]=='T' || s[i]=='F') {\n        bool c=constant(s,i,var);\n        return c;\n    } else if('a'<=s[i] && s[i]<='k') {\n        bool v=variable(s,i,var);\n        return v;\n    } else if(s[i]=='-') {\n        bool neg=negative(s,i,var);\n        return neg;\n    } else if(s[i]=='(') {\n        bool t=term(s,i,var);\n        return t;\n    }\n}\nbool constant(string &s,int &i,int var) {\n    if(s[i]=='T') {\n        i++;\n        return true;\n    } else {\n        i++;\n        return false;\n    }\n}\nbool variable(string &s,int &i,int var) {\n    int idx=s[i]-'a';\n    i++;\n    return ((var>>idx)&1);\n}\nbool term(string &s,int &i,int var) {\n    i++; // (\n    bool x=formula(s,i,var);\n    int op;\n    if(s[i]=='*') op=0,i++;\n    else if(s[i]=='+') op=1,i++;\n    else if(s[i]=='-') op=2,i+=2;  // ->\n    bool y=formula(s,i,var);\n    i++; // )\n    if(op==0) return x&&y;\n    if(op==1) return x||y;\n    if(op==2) return (!x||y);\n}\nbool negative(string &s,int &i,int var) {\n    i++; // -\n    int f=formula(s,i,var);\n    return !f;\n}\nvoid solve(string s) {\n    int res=-1;\n    for(int bit=0;bit<(1<<11);bit++) {\n        int i=0;\n        if(!equation(s,i,bit)) {\n            cout<<\"NO\"<<endl;\n            return;\n        }\n    }\n    cout<<\"YES\"<<endl;\n    return;\n}\nsigned main() {\n    string s;\n    while(cin>>s) {\n        if(s==\"#\") break;\n        solve(s);\n    }\n    return 0;\n}\n\n"
  },
  {
    "language": "C++",
    "code": "#define _USE_MATH_DEFINES\n#define INF 0x3f3f3f3f\n\n#include <iostream>\n#include <cstdio>\n#include <sstream>\n#include <cmath>\n#include <cstdlib>\n#include <algorithm>\n#include <queue>\n#include <stack>\n#include <limits>\n#include <map>\n#include <string>\n#include <cstring>\n#include <set>\n#include <deque>\n#include <bitset>\n#include <list>\n#include <cctype>\n#include <utility>\n  \nusing namespace std;\n  \ntypedef long long ll;\ntypedef pair <int,int> P;\ntypedef pair <int,P> PP;\n  \nstatic const double EPS = 1e-8;\n  \nstatic const int tx[] = {0,1,0,-1};\nstatic const int ty[] = {-1,0,1,0};\n\nstruct ParseInfo {\n  int pos;\n  bool val;\n};\n\nset<char> char_set;\nbool char_table[256];\n\nParseInfo parse_formula(int pos, const string& str){\n\n  if('a' <= str[pos] && str[pos] <= 'k'){\n    bool val = char_table[str[pos]];\n    ParseInfo pi = {pos+1,val};\n    return pi;\n  }\n\n  else if(str[pos] == 'T'){\n    bool val = true;\n    ParseInfo pi = {pos+1,val};\n    return pi;\n  }\n\n  else if(str[pos] == 'F'){\n    bool val = false;\n    ParseInfo pi = {pos+1,val};\n    return pi;\n  }\n\n  else if(str[pos] == '-'){\n    ParseInfo pi = parse_formula(pos+1,str);\n    pi.val = !pi.val;\n    return pi;\n  }\n\n  else if(str[pos] == '('){\n    ParseInfo pi1 = parse_formula(pos+1,str);\n    if(str[pi1.pos] == '*'){\n      ParseInfo pi2 = parse_formula(pi1.pos+1,str);\n      pi2.val = (pi1.val && pi2.val);\n      \n      //skip ')'\n      pi2.pos++;\n      return pi2;\n    }\n    else if(str[pi1.pos] == '+'){\n      ParseInfo pi2 = parse_formula(pi1.pos+1,str);\n      pi2.val = (pi1.val || pi2.val);\n\n      //skip ')'\n      pi2.pos++;\n      return pi2;\n    }\n    else if(str[pi1.pos] == '-'\n\t    && str[pi1.pos+1] == '>'){\n      ParseInfo pi2 = parse_formula(pi1.pos+2,str);\n      pi2.val = (!pi1.val || pi2.val);\n\n      //skip ')'\n      pi2.pos++;\n      return pi2;\n    }\n  }\n}\n\nParseInfo parse_equation(int pos, const string& str){\n  ParseInfo pi1 = parse_formula(pos,str);\n  \n  //skip '='\n  ParseInfo pi2 = parse_formula(pi1.pos+1,str);\n  pi2.val = (pi1.val == pi2.val ? true : false);\n  return pi2;\n}\n\n\nint main(){\n  string str;\n  while(cin >> str){\n    if(str == \"#\") break;\n\n    char_set.clear();\n    for(int i=0;i<str.size();i++){\n      if('a' <= str[i] && str[i] <= 'k'){\n\tchar_set.insert(str[i]);\n      }\n    }\n\n    bool isok = true;\n    for(int S=0;S<=(1<<char_set.size())-1;S++){\n      int idx = 0;\n      for(set<char>::iterator it = char_set.begin();\n\t  it != char_set.end();\n\t  it++){\n\tchar_table[*it] = (S & (1<<idx));\n\tidx++;\n      }\n      ParseInfo pi = parse_equation(0,str);\n      if(!pi.val) isok = false;\n    }\n    printf(\"%s\\n\",isok ? \"YES\" : \"NO\");\n  }\n}"
  },
  {
    "language": "C++",
    "code": "#include <iostream>\n#include <vector>\n#include <cctype>\n#include <vector>\n#include <cassert>\nusing namespace std;\nconst int MAX_VARI = 11;\nstring S;\nint cur = 0;\nint vari = 0;\nint formula();\nint equation();\nint factor();\nint main(){\n  while(cin >> S, S != \"#\"){\n    //cur = 0;\n    int flag = 0;\n    for(int i = 0;i < 1<<11;i++){\n      vari = i;\n      cur = 0;\n      if(equation() != 1){\n\tflag = 1;\n\tbreak;\n      }\n    }\n    if(flag == 0)cout << \"YES\" << endl;\n    else cout << \"NO\" << endl;\n  \n  }\n  return 0;\n}\nint equation(){\n  int a = formula();\n  assert(S[cur] == '=');\n  cur++;\n  int b = formula();\n  if(a == b)return 1;\n  return 0;\n}\nint formula(){\n  if(S[cur] == 'T'){\n    cur++;\n    return 1;\n  }\n  else if(S[cur] == 'F'){\n    cur++;\n    return 0;\n  }\n  else if(S[cur] >= 'a' && S[cur] <= 'k' ){\n    cur++;\n    if((vari & (1<<(S[cur-1] - 'a'))) == (1<<(S[cur-1] - 'a')))return 1;\n    return 0;\n  }\n  else if(S[cur] == '-'){\n    cur++;\n    return formula()^1;\n  }\n  else if(S[cur] == '('){\n    cur++;\n    return factor();\n  }\n  return 0;\n}\nint factor(){\n  int a,b;\n  a = formula();\n  char op = S[cur++];\n  assert(op == '-' || op == '+' || op == '*');\n  if(op == '-')cur++;\n  b = formula();\n  cur++;\n  if(op == '*')return a&b;\n  else if(op == '+')return a|b;\n  return ((a == 0)? 1:((b == 1)? 1:0));\n}"
  },
  {
    "language": "C++",
    "code": "#include <string>\n#include <iostream>\nusing namespace std;\nstring s, t; char d[20]; int pos, cnt;\nbool calc(int l, int r) {\n\tif (s[l] == 'T') return true;\n\tif (s[l] == 'F') return false;\n\tif (s[l] == '-') return !calc(l + 1, r);\n\tint depth = 0;\n\tfor (int i = l + 1; i < r - 1; i++) {\n\t\tif (s[i] == '(') depth++;\n\t\tif (s[i] == ')') depth--;\n\t\tif (depth == 0) {\n\t\t\tif (s[i] == '*') return calc(l + 1, i) && calc(i + 1, r - 1);\n\t\t\tif (s[i] == '+') return calc(l + 1, i) || calc(i + 1, r - 1);\n\t\t\tif (s[i] == '-' && s[i + 1] == '>') return !calc(l + 1, i) || calc(i + 2, r - 1);\n\t\t}\n\t}\n\treturn true;\n}\nbool solve() {\n\tfor (int i = 0; i < (1 << cnt); i++) {\n\t\tfor (int j = 0; j < cnt; j++) {\n\t\t\tfor (int k = 0; k < s.size(); k++) {\n\t\t\t\tif (d[j] == s[k]) s[k] = (i & (1 << j)) ? 'T' : 'F';\n\t\t\t}\n\t\t}\n\t\tif (calc(0, pos) != calc(pos + 1, s.size())) return false;\n\t\ts = t;\n\t}\n\treturn true;\n}\nint main() {\n\twhile (cin >> s, s != \"#\") {\n\t\tcnt = 0; t = s;\n\t\tpos = s.find('=');\n\t\tfor (int j = 0; j < s.size(); j++) {\n\t\t\tif (islower(s[j])) {\n\t\t\t\tbool found = false;\n\t\t\t\tfor (int k = 0; k < cnt; k++) {\n\t\t\t\t\tif (d[k] == s[j]) {\n\t\t\t\t\t\tfound = true; break;\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t\tif (!found) d[cnt++] = s[j];\n\t\t\t}\n\t\t}\n\t\tcout << (solve() ? \"YES\" : \"NO\") << endl;\n\t}\n}"
  },
  {
    "language": "C++",
    "code": "#include <vector>\n#include <list>\n#include <map>\n#include <set>\n#include <stack>\n#include <queue>\n#include <deque>\n#include <algorithm>\n#include <utility>\n#include <functional>\n#include <sstream>\n#include <iostream>\n#include <cstdio>\n#include <cmath>\n#include <cstdlib>\n#include <cctype>\n#include <string>\n#include <cstring>\n#include <ctime>\n#include <climits>\n#include <cassert>\nusing namespace std;\ninline int toInt(string s) {int v; istringstream sin(s);sin>>v;return v;}\ntemplate<class T> inline string toString(T x) {ostringstream sout;sout<<x;return sout.str();}\ntypedef vector<int> vi;\ntypedef vector<vi> vvi;\ntypedef vector<string> vs;\ntypedef pair<int, int> pii;\ntypedef long long ll;\n#define ALL(a) (a).begin(),(a).end()\n#define RALL(a) (a).rbegin(),(a).rend()\n#define EXIST(s,e) ((s).find(e)!=(s).end())\n#define FOR(i,a,b) for(int i=(a);i<(b);++i)\n#define REP(i,n) FOR(i,0,n)\nconst double EPS = 1e-10;\nconst double PI  = acos(-1.0);\n\n\n//<formula>  ::= \"T\" | \"F\" |\n//\"a\" | \"b\" | \"c\" | \"d\" | \"e\" | \"f\" |\n//\"g\" | \"h\" | \"i\" | \"j\" | \"k\" |\n//\"-\" <formula> |\n//\"(\" <formula> \"*\" <formula> \")\" |\n//\"(\" <formula> \"+\" <formula> \")\" |\n//\"(\" <formula> \"->\" <formula> \")\"\nbool formula(string &s,int &pos,vi vars){\n\tswitch(s[pos]){\n\t\tcase 'T':\n\t\t\tpos++;\n\t\t\treturn true;\n\t\tcase 'F':\n\t\t\tpos++;\n\t\t\treturn false;\n\t\tcase 'a':case 'b':case 'c':case 'd':case 'e':case 'f':case 'g':case 'h':case 'i':case 'j':case 'k':\n\t\t\treturn vars[s[pos++]-'a'];\n\t\tcase '-':\n\t\t\tpos++;\n\t\t\treturn !formula(s,pos,vars);\n\t\tcase '(':\n\t\t\t{\n\t\t\t\tpos++;\n\t\t\t\tbool l=formula(s,pos,vars);\n\t\t\t\tchar op=s[pos];\n\t\t\t\tpos++;\n\t\t\t\tif(op=='-'){\n\t\t\t\t\tassert(s[pos]=='>');\n\t\t\t\t\tpos++;\n\t\t\t\t}\n\t\t\t\tbool r=formula(s,pos,vars);\n\t\t\t\tassert(s[pos]==')');\n\t\t\t\tpos++;\n\t\t\t\tswitch(op){\n\t\t\t\t\tcase '*':\n\t\t\t\t\t\treturn l&r;\n\t\t\t\t\tcase '+':\n\t\t\t\t\t\treturn l|r;\n\t\t\t\t\tcase '-':\n\t\t\t\t\t\treturn r|(!l);\n\t\t\t\t\tdefault:\n\t\t\t\t\t\tassert(0);break;\n\t\t\t\t}\n\t\t\t}\n\t\tdefault:\n\t\t\tassert(0);break;\n\t}\n}\n\n//<equation> ::= <formula> \"=\" <formula>\nbool equation(string &s,int &pos,vi vars){\n\tbool l=formula(s,pos,vars);\n\tassert(s[pos]=='=');\n\tpos++;\n\tbool r=formula(s,pos,vars);\n\tassert(s[pos]=='\\0');\n\treturn l==r;\n}\nint main(){\n\tstring s;\n\twhile(cin>>s,s!=\"#\"){\n\t\tbool flag=true;\n\t\tREP(i,1<<11){\n\t\t\tvi vars(11);\n\t\t\tREP(j,11){\n\t\t\t\tvars[j]=((1<<j)&i);\n\t\t\t}\n\t\t\tint pos=0;\n\t\t\tif(!equation(s,pos,vars)){\n\t\t\t\tflag=false;\n\t\t\t\tbreak;\n\t\t\t}\n\t\t}\n\t\tcout<<(flag?\"YES\":\"NO\")<<endl;\n\t}\n}"
  },
  {
    "language": "C++",
    "code": "#include <string>\n#include <iostream>\nusing namespace std;\nstring s[5];\nbool solve(int l, int r, int e) {\n\tif (s[e][l] == 'T') return true;\n\tif (s[e][l] == 'F') return false;\n\tif (s[e][l] == '-') return !solve(l + 1, r, e);\n\tint d = 0;\n\tfor (int i = l + 1; i < r - 1; i++) {\n\t\tif (s[e][i] == '(') d++;\n\t\tif (s[e][i] == ')') d--;\n\t\tif (!d && s[e][i] == '*') return solve(l + 1, i, e) && solve(i + 1, r - 1, e);\n\t\tif (!d && s[e][i] == '+') return solve(l + 1, i, e) || solve(i + 1, r - 1, e);\n\t\tif (!d && s[e][i] == '-' && s[e][i + 1] == '>') return !solve(l + 1, i, e) || solve(i + 2, r - 1, e);\n\t}\n\treturn true;\n}\nint main() {\n\twhile (cin >> s[0], s[0] != \"#\") {\n\t\tfor (int i = 0; i < s[0].size(); i++) {\n\t\t\tif (s[0][i] == '=') {\n\t\t\t\ts[1] = s[0].substr(0, i);\n\t\t\t\ts[2] = s[0].substr(i + 1, s[0].size() - i - 1);\n\t\t\t}\n\t\t}\n\t\tbool flag = true;\n\t\tfor (int i = 0; i < 2048; i++) {\n\t\t\ts[3] = s[1], s[4] = s[2];\n\t\t\tfor (int j = 0; j < 11; j++) {\n\t\t\t\tfor (int k = 0; k < s[3].size(); k++) {\n\t\t\t\t\tif (s[1][k] == j + 97) s[3][k] = (i & (1 << j)) ? 'T' : 'F';\n\t\t\t\t}\n\t\t\t\tfor (int k = 0; k < s[4].size(); k++) {\n\t\t\t\t\tif (s[2][k] == j + 97) s[4][k] = (i & (1 << j)) ? 'T' : 'F';\n\t\t\t\t}\n\t\t\t}\n\t\t\tif (solve(0, s[3].size(), 3) != solve(0, s[4].size(), 4)) {\n\t\t\t\tflag = false; break;\n\t\t\t}\n\t\t}\n\t\tprintf(\"%s\\n\", flag ? \"YES\" : \"NO\");\n\t}\n\treturn 0;\n}"
  },
  {
    "language": "C++",
    "code": "\n#include<iostream>\n#include<string>\nusing namespace std;\n\nstruct DATA{\n  string ans;\n  int i;\n  DATA(string s,int n){ans=s;i=n;}\n};\n\nstring equation(string s);\nDATA formula(string s, int i);\n\nstring equation(string s){\n  DATA res=formula(s,0);\n  return res.ans;\n}\n\nDATA formula(string s, int i)\n{\n  if(s[i]=='T')return DATA(\"T\",i+1);\n  if(s[i]=='F')return DATA(\"F\",i+1);\n  if(s[i]=='-'){\n    DATA res=formula(s,i+1);\n    if(res.ans==\"T\")return DATA(\"F\",res.i);\n    else return DATA(\"T\",res.i);\n  }\n  if(s[i]=='('){\n    string res,op;\n    DATA res1 = formula(s,i+1);\n    i=res1.i;\n    op=s[i];\n    if(op==\"-\")i++;\n    DATA res2 = formula(s,i+1);\n    i=res2.i;\n\n    if(op==\"*\"){\n      if( (res1.ans==\"T\") & (res2.ans==\"T\") ) res=\"T\";\n      else res=\"F\";\n    }\n    if(op==\"+\"){\n      if( (res1.ans==\"T\") | (res2.ans==\"T\") ) res=\"T\";\n      else res=\"F\";\n    }\n    if(op==\"-\"){\n      if( (res1.ans==\"T\") && (res2.ans==\"F\") ) res=\"F\";\n      else res=\"T\";\n    }\n    return DATA(res,i+1);\n  }\n}\n\nint main()\n{\n  bool ok;\n  string in,s1,s2;\n  while(cin>>in,in!=\"#\"){\n    ok=true;\n    for(int i=0;i<(1<<3);i++){\n      s1=in;\n      for(int j=0;j<3;j++){\n\tif(i>>j&1){\n\t  while(s1.find('a'+j,0)!=string::npos){\n\t    s1.replace(s1.find('a'+j,0),1,\"T\");\n\t  }\n\t}else{\n\t  while(s1.find('a'+j,0)!=string::npos){\n\t    s1.replace(s1.find('a'+j,0),1,\"F\");\n\t  }\n\t}\n      }\n      s2=s1.substr(s1.find(\"=\",0)+1);\n      s1=s1.substr(0,s1.find(\"=\",0));\n      if(equation(s1)!=equation(s2))ok=false;\n    }\n    if(ok)puts(\"YES\");\n    else puts(\"NO\");\n  }\n}"
  },
  {
    "language": "C++",
    "code": "#include <iostream>\n#include <string>\n#include <vector>\n#include <algorithm>\n#include <cmath>\n#include <cstdio>\n#include <functional>\n#include <numeric>\n#include <stack>\n#include <queue>\n#include <map>\n#include <set>\n#include <utility>\n#include <sstream>\n#include <complex>\n#include <fstream>\n#include <bitset>\n#include <time.h>\n\nusing namespace std;\n\ntypedef long long ll;\ntypedef pair<ll, ll> P;\ntypedef vector<ll> V;\ntypedef complex<double> Point;\n\n#define PI acos(-1.0)\n#define EPS 1e-10\nconst ll INF = (1LL << 31) - 1;\nconst ll MOD = 1e9 + 7;\n\n#define FOR(i,a,b) for(int i=(a);i<(b);i++)\n#define rep(i,N) for(int i=0;i<(N);i++)\n#define ALL(s) (s).begin(),(s).end()\n#define EQ(a,b) (abs((a)-(b))<EPS)\n#define EQV(a,b) ( EQ((a).real(), (b).real()) && EQ((a).imag(), (b).imag()) )\n#define fi first\n#define se second\n#define N_SIZE (1LL << 20)\n#define NIL -1\n#define MAX_N 100100 * 3\n\nstring s;\nmap<char, bool> mci;\n\nvector<string> split(string str, char sep)\n{\n\tvector<string> v;\n\tstringstream ss(str);\n\tstring buffer;\n\twhile (getline(ss, buffer, sep)) {\n\t\tv.push_back(buffer);\n\t}\n\treturn v;\n}\n\nstring print(ll num) {\n\tstring res;\n\tint n = (1 << 12);\n\twhile (n) {\n\t\tif (num >= n) {\n\t\t\tnum -= n;\n\t\t\tres += \"1\";\n\t\t}\n\t\telse res += \"0\";\n\t\tn /= 2;\n\t}\n\treturn res;\n}\n\nbool is_op(char c) {\n\treturn (c >= 'a'&&c <= 'k') || (c == 'T') || (c == 'F');\n}\n\nbool operand(string& s, int &pos) {\n\tif (s[pos] == 'T')return true;\n\tif (s[pos] == 'F')return false;\n\tif (s[pos] >= 'a'&&s[pos] <= 'k')return mci[s[pos]];\n}\n\nbool formula(string& s, int &pos) {\n\t//cout << s[pos] << \"!\" << pos << endl;\n\tif (is_op(s[pos]))return operand(s, pos);\n\tbool res;\n\tif (s[pos] == '(') {\n\t\tpos++;\n\t\tres = formula(s, pos);\n\t\tpos++;\n\t\tif (s[pos] == '*') {\n\t\t\t//cout << \"*\" << pos << endl;\n\t\t\tpos++;\n\t\t\tres &= formula(s, pos);\n\t\t}\n\t\telse if (s[pos] == '+') {\n\t\t\t//cout << \"+\" << pos << endl;\n\t\t\tpos++;\n\t\t\tres |= formula(s, pos);\n\t\t}\n\t\telse if (s[pos] == '-') {\n\t\t\t//cout << \"->\" << pos << endl;\n\t\t\tpos += 2;\n\t\t\tbool buf = formula(s, pos);\n\t\t\tif (res == true && buf == false)res = false;\n\t\t\telse res = true;\n\t\t}\n\t\tpos++;\n\t}\n\telse if (s[pos] == '-') {\n\t\tpos++;\n\t\tres = !formula(s, pos);\n\t}\n\t//cout << pos << \" \" << res << endl;\n\treturn res;\n}\n\nbool equation(string &s, int &pos) {\n\tvector<string> vs = split(s, '=');\n\tbool f = formula(vs[0], pos);\n\tpos = 0;\n\t//cout << endl;\n\tbool f2 = formula(vs[1], pos);\n\t//cout << \"!!!!\" << f << \" \" << f2 << endl;\n\t//bool f2 = false;\n\treturn f == f2;\n}\n\nint main() {\n\twhile (cin >> s&&s != \"#\") {\n\t\tmci.clear();\n\t\tbool f = true;\n\t\trep(mask, (1 << 11)) {\n\t\t\t//if (mask == 1)break;\n\t\t\t//cout << mask << endl;\n\t\t\tint pos = 0;\n\t\t\tint num = mask;\n\t\t\tfor (int i = 0; i < 11; i++) {\n\t\t\t\tif ((num >> i) & 1)mci['a' + i] = true;\n\t\t\t\telse mci['a' + i] = false;\n\t\t\t}\n\t\t\tbool g = equation(s, pos);\n\t\t\t//if (!g)cout << mask << \" \" << g << endl;\n\t\t\tf &= g;\n\t\t}\n\t\tif (f)cout << \"YES\" << endl;\n\t\telse cout << \"NO\" << endl;\n\t\t//cout << endl;\n\t}\n}"
  },
  {
    "language": "C++",
    "code": "#include <iostream>\n#include <algorithm>\n#include <string>\n#include <sstream>\n#include <vector>\n\nusing namespace std;\n\n#define rep(i,n) for(int i=0;i<n;++i)\n\n\nbool solve(string s){\n\tstringstream ss;\n\t// cout<<\"before \"<<s<<endl;\n\tbool f=false;\n\trep(i,s.size()){\n\t\tif(i+1<s.size()&&s[i]=='-'&&(s[i+1]=='T'||s[i+1]=='F')){\n\t\t\tif(s[i+1]=='T') ss<<'F';\n\t\t\telse ss<<'T';\n\t\t\ti++;\n\t\t\tf=true;\n\t\t}\n\t\telse if(i+4<s.size()&&s[i]=='('&&(s[i+1]=='T'||s[i+1]=='F')&&s[i+2]=='*'&&(s[i+3]=='T'||s[i+3]=='F')&&s[i+4]==')'){\n\t\t\tf=true;\n\t\t\tif(s[i+1]=='F'||s[i+3]=='F') ss<<'F';\n\t\t\telse ss<<'T';\n\t\t\ti+=4;\n\t\t}\n\t\telse if(i+4<s.size()&&s[i]=='('&&(s[i+1]=='T'||s[i+1]=='F')&&s[i+2]=='+'&&(s[i+3]=='T'||s[i+3]=='F')&&s[i+4]==')'){\n\t\t\tf=true;\n\t\t\tif(s[i+1]=='F'&&s[i+3]=='F') ss<<'F';\n\t\t\telse ss<<'T';\n\t\t\ti+=4;\n\t\t}\n\t\telse if(i+5<s.size()&&s[i]=='('&&(s[i+1]=='T'||s[i+1]=='F')&&s[i+2]=='-'&&s[i+3]=='>'&&(s[i+4]=='T'||s[i+4]=='F')&&s[i+5]==')'){\n\t\t\tf=true;\n\t\t\tif(s[i+1]=='T'&&s[i+4]=='F') ss<<'F';\n\t\t\telse ss<<'T';\n\t\t\ti+=5;\n\t\t}\n\t\telse ss<<s[i];\n\t}\n\t\t\n\tstring t;\n\tss>>t;\n\t// cout<<\"after \"<<t<<endl;\n\tif(f) return solve(t);\n\telse{\n\t\tif(s[0]==s[2]) return true;\n\t}\n\treturn false;\n\t// stringstream ss2;\n\t// s=t;\n\t// rep(i,s.size()-4){\n\t\t// if(s[i]=='('&&(s[i+1]=='T'||s[i+1]=='F')&&s[i+2]=='*'&&(s[i+3]=='T'||s[i+3]=='F')&&s[i+4]==')'){\n\t\t\t// f=true;\n\t\t\t// if(s[i+1]=='F'||s[i+3]=='F') ss2<<'F';\n\t\t\t// else ss2<<'T';\n\t\t\t// i+=4;\n\t\t// }\n\t\t// else{\n\t\t\t// ss2<<s[i];\n\t\t\t// if(i==s.size()-5){\n\t\t\t\t// ss2<<s.substr(i+1);\n\t\t\t// }\n\t\t// }\n\t// }\n\t// string t2;\n\t// ss2>>t2;\n\t// stringstream ss3;\n\t// if(f) return solve(t2);\n\t// rep(i,s.size()-5){\n\t\t// if(s[i]=='('&&(s[i+1]=='T'||s[i+1]=='F')&&s[i+2]=='-'&&s[i+3]=='>'&&(s[i+4]=='T'||s[i+4]=='F')&&s[i+5]==')'){\n\t\t\t// f=true;\n\t\t\t// if(s[i+1]=='T'&&s[i+4]=='F') ss3<<'F';\n\t\t\t// else ss3<<'T';\n\t\t\t// i+=5;\n\t\t// }\n\t\t// else{\n\t\t\t// ss3<<s[i];\n\t\t\t// if(i==s.size()-6){\n\t\t\t\t// ss3<<s.substr(i+1);\n\t\t\t// }\n\t\t// }\n\t// }\n\t// string t3;\n\t// ss3>>t3;\n\t// if(f) return solve(t3);\n\t// s=t3;\n\t// if()\n\n}\n\nint main(){\n\tstring s;\n\twhile(cin>>s,s!=\"#\"){\n\t\tint c=0;\n\t\trep(i,s.size()){\n\t\t\tif(s[i]=='F') s[i]='Z';\n\t\t}\n\t\trep(i,'k'-'a'+1){\n\t\t\tchar t=i+'a';\n\t\t\trep(j,s.size()){\n\t\t\t\tif(s[j]==t){\n\t\t\t\t\trep(k,s.size()){\n\t\t\t\t\t\tif(s[k]==t) s[k]='G'+c;\n\t\t\t\t\t}\n\t\t\t\t\tc++;\n\t\t\t\t\tbreak;\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t\trep(i,s.size()){\n\t\t\tif(s[i]=='Z') s[i]='F';\n\t\t}\n\t\t// cout<<s<<endl;\n\t\t// cout<<(1<<c)<<endl;\n\t\tint lim=(1<<c);\n\t\t// cout<<t<<endl;\n\t\tbool f=true;\n\t\trep(i,lim){\n\t\t\tstring tmp=s;\n\t\t\trep(j,tmp.size()){\n\t\t\t\tif(tmp[j]>='G'&&tmp[j]<='G'+c){\n\t\t\t\t\tif(i&1<<(tmp[j]-'G')){\n\t\t\t\t\t\t// cout<<tmp[j]<<\" = T\"<<endl;\n\t\t\t\t\t\ttmp[j]='T';\n\t\t\t\t\t}\n\t\t\t\t\telse{\n\t\t\t\t\t\t// cout<<tmp[j]<<\" = F\"<<endl;\n\t\t\t\t\t\ttmp[j]='F';\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t}\n\t\t\t// cout<<endl;\n\t\t\t// cout<<tmp<<endl;\n\t\t\tif(!solve(tmp)){\n\t\t\t\tf=false;\n\t\t\t\tbreak;\n\t\t\t}\n\t\t}\n\t\tif(f) cout<<\"YES\\n\";\n\t\telse cout<<\"NO\\n\";\n\t\t// cout<<s<<endl;\n\t}\n}"
  },
  {
    "language": "C++",
    "code": "#include <iostream>\n#include <iomanip>\n#include <sstream>\n#include <cstdio>\n#include <string>\n#include <vector>\n#include <algorithm>\n#include <complex>\n#include <cstring>\n#include <cstdlib>\n#include <cmath>\n#include <cassert>\n#include <climits>\n#include <queue>\n#include <set>\n#include <map>\n#include <valarray>\n#include <bitset>\n#include <stack>\nusing namespace std;\n\n#define REP(i,n) for(int i=0;i<(int)n;++i)\n#define FOR(i,c) for(__typeof((c).begin())i=(c).begin();i!=(c).end();++i)\n#define ALL(c) (c).begin(), (c).end()\ntypedef long long ll;\ntypedef pair<int,int> pii;\nconst int INF = 1<<29;\nconst double PI = acos(-1);\nconst double EPS = 1e-8;\n\nbool x[11];\n\nbool fm(string &s, int &idx) {\n  if (s[idx] == '(') {\n    idx++;\n    bool f1 = fm(s,idx);\n    char c = s[idx++];\n    if (c == '-') idx++;\n    bool f2 = fm(s,idx);\n    assert(s[idx] == ')');\n    idx++;\n    if (c == '*') return f1 & f2;\n    else if (c == '+') return f1 | f2;\n    else if (c == '-') return !(f1 & (!f2));\n  } else if (s[idx] == '-') {\n    idx++;\n    bool f1 = fm(s,idx);\n    return !f1;\n  } else {\n    bool f = x[s[idx++]-'a'];\n    return f;\n  }\n}\n\nbool eq(string &s, int &idx) {\n  bool f1 = fm(s,idx);\n  assert(s[idx++] == '=');\n  bool f2 = fm(s,idx);\n  return f1 == f2;\n}\n\nint main() {\n  string s;\n  while(cin>>s,s!=\"#\") {\n    bool f = 0;\n    REP(S,1<<11) {\n      REP(i,11) x[i] = (S>>i&1);\n      int idx = 0;\n      if (!eq(s,idx)) {\n        f = 1;\n        break;\n      }\n    }\n    if (f) cout << \"NO\" << endl;\n    else cout << \"YES\" << endl;\n  }\n}"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\n#define int long long\n#define main signed main()\nusing namespace std;\n\n// clang-format off\nnamespace PCon {\n  template<typename Obj>\n  struct Parsed {\n    bool success; Obj obj; int pos;\n    Parsed(Obj obj, int pos) : success(true), obj(obj), pos(pos) { }\n    Parsed(int pos) : success(false), pos(pos) { }\n  };\n\n  template<typename Obj>\n  using Parser = function<Parsed<Obj>(string, int)>;\n\n  Parser<string> token(const string &s) {\n    return [&](string target, int pos) {\n      int n = s.size();\n      if (target.size() < n) return Parsed<string>(pos);\n      if (target.substr(pos, n) == s) return Parsed<string>(s, pos + n);\n      return Parsed<string>(pos);\n    };\n  }\n\n  template<typename Obj>\n  Parser<vector<Obj>> many(const Parser<Obj> &p) {\n    return [&](string target, int pos) {\n      vector<Obj> result;\n      for (;;) {\n        Parsed<Obj> parsed = p(target, pos);\n        if (!parsed.success) break;\n        result.push_back(parsed.obj);\n        pos = parsed.pos;\n      }\n      return Parsed<vector<Obj>>(result, pos);\n    };\n  }\n\n  template<typename Obj>\n  Parser<Obj> operator||(const Parser<Obj> &p1, const Parser<Obj> &p2) {\n    return [&](string target, int pos) {\n      Parsed<Obj> r = p1(target, pos);\n      if (r.success) return r;\n      r = p2(target, pos);\n      if (r.success) return r;\n      return Parsed<Obj>(pos);\n    };\n  }\n\n  template<typename Obj1, typename Obj2>\n  Parser<pair<Obj1, Obj2>> operator+(const Parser<Obj1> &p1, const Parser<Obj2> &p2) {\n    return [&](string target, int pos) {\n      pair<Obj1, Obj2> p;\n      Parsed<Obj1> r1 = p1(target, pos);\n      if (!r1.success) return Parsed<pair<Obj1, Obj2>>(pos);\n      Parsed<Obj2> r2 = p2(target, r1.pos);\n      if (!r2.success) return Parsed<pair<Obj1, Obj2>>(pos);\n      return Parsed<pair<Obj1, Obj2>>(make_pair(r1.obj, r2.obj), r2.pos);\n    };\n  }\n\n  template<typename Obj1, typename Obj2>\n  Parser<Obj2> fmap(Parser<Obj1> p, function<Obj2(Obj1)> f) {\n    return [&](string target, int pos) {\n      Parsed<Obj1> r = p(target, pos);\n      if (!r.success) return Parsed<Obj2>(r.pos);\n      return Parsed<Obj2>(f(r.obj), r.pos);\n    };\n  }\n\n  Parser<char> oneOf(string s) {\n    return [&](string target, int pos) {\n      set<char> m;\n      for (char &c : s) m.insert(c);\n      char c = target[pos];\n      return m.count(c) ? Parsed<char>(c, pos + 1) : Parsed<char>(pos);\n    };\n  }\n}\n// clang-format on\n\nusing namespace PCon;\n\nstruct Formula {\n  string op;\n  char val;\n  vector<Formula> fs;\n  Formula() {\n  }\n  Formula(char val)\n    : val(val) {\n  }\n  Formula(string op, vector<Formula> fs)\n    : op(op), fs(fs) {\n  }\n};\n\nstruct Equation {\n  Formula left, right;\n  Equation() {\n  }\n  Equation(Formula left, Formula right)\n    : left(left), right(right) {\n  }\n};\n\ntemplate<typename T, typename X>\nusing P  = pair<T, X>;\nusing PB = P<P<P<P<string, Formula>, string>, Formula>, string>;\n\nmain {\n  Parser<Formula> formulaP;\n  Parser<Formula> andP = fmap<PB, Formula>(token(\"(\") + formulaP + token(\"*\") + formulaP + token(\")\"), [](PB x) {\n    return Formula(\"*\", {x.first.first.first.second, x.first.second});\n  });\n  Parser<Formula> orP = fmap<PB, Formula>(token(\"(\") + formulaP + token(\"+\") + formulaP + token(\")\"), [](PB x) {\n    return Formula(\"+\", {x.first.first.first.second, x.first.second});\n  });\n  Parser<Formula> impP = fmap<PB, Formula>(token(\"(\") + formulaP + token(\"->\") + formulaP + token(\")\"), [](PB x) {\n    return Formula(\"->\", {x.first.first.first.second, x.first.second});\n  });\n  Parser<Formula> notP = fmap<P<string, Formula>, Formula>(token(\"-\") + formulaP, [](P<string, Formula> x) {\n    return Formula(\"-\", {x.second});\n  });\n  Parser<Formula> valP = fmap<char, Formula>(oneOf(\"abcdefghijkTF\"), [](char c) { return Formula(c); });\n\n  formulaP = andP || orP || impP || notP || valP;\n\n  Parser<Equation> equationP = fmap<P<P<Formula, string>, Formula>, Equation>(formulaP + token(\"=\") + formulaP, [](P<P<Formula, string>, Formula> x) {\n    return Equation(x.first.first, x.second);\n  });\n\n  string s;\n  while (cin >> s, s != \"#\") {\n    s                  = regex_replace(s, regex(\"(--)+\"), \"\");\n    Parsed<Equation> r = equationP(s, 0);\n    bool isValid       = true;\n    for (int i = 0; i < (1 << 11); i++) {\n      auto toBool = [&](char c) {\n        if (c == 'T') return true;\n        if (c == 'F') return false;\n        return !!(i >> (c - 'a') & 1);\n      };\n      function<bool(Formula)> eval = [&](Formula f) {\n        switch (f.fs.size()) {\n          case 0: return toBool(f.val);\n          case 1: return !eval(f.fs[0]);\n          case 2:\n            if (f.op == \"*\") return eval(f.fs[0]) && eval(f.fs[1]);\n            if (f.op == \"+\") return eval(f.fs[0]) || eval(f.fs[1]);\n            if (f.op == \"->\") return !eval(f.fs[0]) || eval(f.fs[1]);\n        }\n      };\n      isValid &= eval(r.obj.left) == eval(r.obj.right);\n    }\n    cout << (isValid ? \"YES\" : \"NO\") << endl;\n  }\n}"
  },
  {
    "language": "C++",
    "code": "#include <cstdio>\n\nusing namespace std;\n\nbool equation(char *str, int &p);\nbool formula(char *str, int &p);\n\nbool c[11];\n\nbool equation(char *str, int &p)\n{\n    return formula(str, p) == formula(str, ++p);\n}\n\nbool formula(char *str, int &p)\n{\n    //printf(\"  %d\\n\", p);\n    bool a;\n    if (str[p] == 'T') {\n        a = true;\n        ++p;\n    } else if (str[p] == 'F') {\n        a = false;\n        ++p;\n    } else if ('a' <= str[p] && str[p] <= 'k') {\n        a = c[str[p] - 'a'];\n        ++p;\n    } else if (str[p] == '-' && str[p + 1] != '>') {\n        ++p;\n        a = !formula(str, p);\n    } else {\n        ++p;\n        bool l = formula(str, p);\n        if (str[p] == '*') {\n            ++p;\n            bool r = formula(str, p);\n            a = l && r;\n        } else if (str[p] == '+') {\n            ++p;\n            bool r = formula(str, p);\n            a = l || r;\n        } else if (str[p] == '-' && str[p + 1] == '>') {\n            p += 2;\n            bool r = formula(str, p);\n            a = !l || r;\n        }\n        ++p;\n    }\n    return a;\n}\n\nint main()\n{\n    for (;;) {\n        char str[1001];\n\n        gets(str);\n        if (str[0] == '#')\n            break;\n\n        bool f = true;\n        for (int j = 0; j < 2048; ++j) {\n            c[0] = j & 0x01;\n            c[1] = j & 0x02;\n            c[2] = j & 0x04;\n            c[3] = j & 0x08;\n            c[4] = j & 0x10;\n            c[5] = j & 0x20;\n            c[6] = j & 0x40;\n            c[7] = j & 0x80;\n            c[8] = j & 0x100;\n            c[9] = j & 0x200;\n            c[10] = j & 0x400;\n            //printf(\"%4d: %d%d%d%d%d%d%d%d%d%d%d\\n\", j, c[0], c[1], c[2], c[3], c[4], c[5], c[6], c[7], c[8], c[9], c[10]);\n\n            int i = 0;\n            f = f && equation(str, i);\n            if (!f)\n                break;\n        }\n\n        puts(f ? \"YES\" : \"NO\");\n    }\n\n    return 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include <algorithm>\n#include <cmath>\n#include <climits>\n#include <cstdio>\n#include <cstring>\n#include <fstream>\n#include <iostream>\n#include <list>\n#include <map>\n#include <queue>\n#include <set>\n#include <sstream>\n#include <stack>\n#include <string>\n#include <vector>\n\nusing namespace std;\n\n#define LOG(...) printf(__VA_ARGS__)\n//#define LOG(...)\n#define FOR(i,a,b) for(int i=(a);i<(b);++i)\n#define REP(i,n) for(int i=0;i<(int)(n);++i)\n#define ALL(a) (a).begin(),(a).end()\n#define EXIST(s,e) ((s).find(e)!=(s).end())\n#define SORT(c) sort((c).begin(),(c).end())\n\ntypedef long long ll;\ntypedef unsigned long long ull;\ntypedef vector<bool> vb;\ntypedef vector<int> vi;\ntypedef vector<ll> vll;\ntypedef vector<vb> vvb;\ntypedef vector<vi> vvi;\ntypedef vector<vll> vvll;\ntypedef pair<int, int> pii;\ntypedef pair<ll, ll> pll;\n\nconst int V[] = {\n    1 << 0,\n    1 << 1,\n    1 << 2,\n    1 << 3,\n    1 << 4,\n    1 << 6,\n    1 << 7,\n    1 << 8,\n    1 << 9,\n    1 << 10,\n    1 << 11,\n};\nconst string C[] = {\"a\", \"b\", \"c\", \"d\", \"e\", \"f\", \"g\", \"h\", \"i\", \"j\", \"k\"};\n\nstring replace_all(string &subject, const string &search, const string &replace) {\n    size_t pos = 0;\n    while ((pos = subject.find(search, pos)) != string::npos) {\n        subject.replace(pos, search.length(), replace);\n        pos += replace.length();\n    }\n    return subject;\n}\n\nstring parse(string expr, int var) {\n    replace_all(expr, \"--\", \"\");\n    replace_all(expr, \"->\", \">\");\n    REP(i, 11) {\n        replace_all(expr, C[i], var | V[i] ? \"T\" : \"F\");\n    }\n    while (expr.length() > 1) {\n        replace_all(expr, \"-F\", \"T\");\n        replace_all(expr, \"-T\", \"F\");\n        stack<int> parens;\n        REP(i, expr.length()) {\n            if (expr[i] == '(') {\n                parens.push(i);\n                continue;\n            } else if (expr[i] == ')') {\n                int j = parens.top(); parens.pop();\n                char a = expr[j+1];\n                char b = expr[j+3];\n                string ret;\n                switch (expr[j+2]) {\n                case '+': // OR\n                    if (a == 'F' && b == 'F') ret = \"F\";\n                    else ret = \"T\";\n                    break;\n                case '*': // AND\n                    if (a == 'T' && b == 'T') ret = \"T\";\n                    else ret = \"F\";\n                    break;\n                case '>': // IMP\n                    if (a == 'T' && b == 'F') ret = \"F\";\n                    else ret = \"T\";\n                    break;\n                }\n                replace_all(expr, string(expr.begin() + j, expr.begin() + i + 1), ret);\n                break;\n            }\n        }\n    }\n    return expr;\n}\n\nint main() {\n    string line;\n    while (getline(cin, line), line != \"#\") {\n        int eq = line.find('=');\n        string l(line.begin(), line.begin() + eq);\n        string r(line.begin() + eq + 1, line.end());\n        bool ok = true;\n        REP(var, 2 << 12) {\n            if (parse(l, var) != parse(r, var)) {\n                ok = false;\n                break;\n            }\n        }\n        cout << (ok ? \"YES\" : \"NO\") << endl;\n    }\n}"
  },
  {
    "language": "C++",
    "code": "#include<iostream>\n#include<string>\nusing namespace std;\ntypedef string::const_iterator State;\nbool equation(State&);\nbool formula(State&);\nbool oper(State&);\nbool consume(State& begin,char c){\n  if(*begin != c){\n    cout << \"need:\" << c << \" comes:\" << *begin << endl;\n    return false;\n  }\n  begin++;\n  return true;\n}\n\nint var;\n\nbool equation(State& start){\n  bool left,right;\n  State begin;\n  for(var = 0;var < 1 << 12;var++){\n    begin = start;\n    left = formula(begin);\n    consume(begin,'=');\n    right = formula(begin);\n    if(left != right)return false;\n  }\n  return true;\n}\nbool formula(State& begin){\n  char cur = *begin;\n  begin++;\n  if(cur == 'T')return true;\n  if(cur == 'F')return false;\n  if(cur >= 'a' && 'k' >= cur)return (bool)(var|1 << (cur-'a'));\n  if(cur == '-')return !formula(begin);\n  if(cur == '('){\n    bool ret = oper(begin);\n    consume(begin,')');\n    return ret;\n  }\n}\nbool oper(State& begin){\n  bool left = formula(begin);\n  char cur = *begin;\n  begin++;\n  if(cur == '-')consume(begin,'>');\n  bool right = formula(begin);\n  if(cur == '+'){\n    return right+left;\n  }else if(cur == '*'){\n    return right*left;\n  }else if(cur == '-'){\n    return !left+right;\n  }\n  cout << \"error\" << endl;\n}\nint main(){\n  cin.sync_with_stdio(false);\n  string eq;\n  while(getline(cin,eq) && eq != \"#\"){\n    State begin = eq.begin();\n    cout << (equation(begin) ? \"YES\" : \"NO\") <<endl;\n  }\n  return 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\n#define For(i, a, b) for(int (i)=(int)(a); (i)<(int)(b); ++(i))\n#define rFor(i, a, b) for(int (i)=(int)(a)-1; (i)>=(int)(b); --(i))\n#define rep(i, n) For((i), 0, (n))\n#define rrep(i, n) rFor((i), (n), 0)\n#define fi first\n#define se second\nusing namespace std;\ntypedef long long lint;\ntypedef unsigned long long ulint;\ntypedef pair<int, int> pii;\ntypedef pair<lint, lint> pll;\ntemplate<class T> bool chmax(T &a, const T &b){if(a<b){a=b; return true;} return false;}\ntemplate<class T> bool chmin(T &a, const T &b){if(a>b){a=b; return true;} return false;}\ntemplate<class T> T div_floor(T a, T b){\n    if(b < 0) a *= -1, b *= -1;\n    return a>=0 ? a/b : (a+1)/b-1;\n}\ntemplate<class T> T div_ceil(T a, T b){\n    if(b < 0) a *= -1, b *= -1;\n    return a>0 ? (a-1)/b+1 : a/b;\n}\n\nconstexpr lint mod = 1e9+7;\nconstexpr lint INF = mod * mod;\nconstexpr int MAX = 100010;\n\nint var[11];\nbool flag;\n\nbool formula(string &s, int &i){\n    if(s[i] == 'T'){\n        ++i;\n        return 1;\n    }\n    else if(s[i] == 'F'){\n        ++i;\n        return 0;\n    }\n    else if('a' <= s[i] && s[i] <= 'k'){\n        return var[s[i++]-'a'];\n    }\n    else if(s[i] == '-'){\n        ++i;\n        return !formula(s, i);\n    }\n    ++i;\n    int x = formula(s, i);\n    if(s[i] == '*'){\n        ++i;\n        int y = formula(s, i);\n        ++i;\n        return x & y;\n    }\n    else if(s[i] == '+'){\n        ++i;\n        int y = formula(s, i);\n        ++i;\n        return x | y;\n    }\n    else{\n        i += 2;\n        int y = formula(s, i);\n        ++i;\n        return !x | y;\n    }\n}\n\nvoid solve(int cur, string &s, string &t){\n    if(cur == 11){\n        int idx = 0;\n        int x = formula(s, idx);\n        idx = 0;\n        int y = formula(t, idx);\n        flag &= (x == y);\n        return;\n    }\n    var[cur] = 0;\n    solve(cur+1, s, t);\n    var[cur] = 1;\n    solve(cur+1, s, t);\n}\n\nint main(){\n    string s, t;\n    while(cin >> s && s != \"#\"){\n        rep(i, s.size())if(s[i] == '='){\n            t = s.substr(i+1, s.size()-i-1);\n            s = s.substr(0, i);\n            break;\n        }\n        flag = true;\n        solve(0, s, t);\n        puts(flag ? \"YES\" : \"NO\");\n    }\n}\n"
  },
  {
    "language": "C++",
    "code": "#include <iostream>\n#include <vector>\n#include <string>\n#include <algorithm>\nusing namespace std;\n\nint c;\nbool a[11];\n\nbool f(const string& s) {\n\tif (s[c] == '(') {\n\t\tc++;\n\t\tbool v = f(s);\n\t\tif (s[c] == '+') {\n\t\t\tc++;\n\t\t\tv |= f(s);\n\t\t}\n\t\telse if (s[c] == '*') {\n\t\t\tc++;\n\t\t\tv &= f(s);\n\t\t}\n\t\telse {\n\t\t\tc += 2;\n\t\t\tv = !(v & !f(s));\n\t\t}\n\t\tc++; // s[c] == ')'\n\t\treturn v;\n\t}\n\n\tif (s[c] == 'T') {\n\t\tc++;\n\t\treturn true;\n\t}\n\tif (s[c] == 'F') {\n\t\tc++;\n\t\treturn false;\n\t}\n\tif (s[c] == '-') {\n\t\tc++;\n\t\treturn !f(s);\n\t}\n\tif ('a' <= s[c] && s[c] <= 'k') {\n\t\tbool v = a[s[c] - 'a'];\n\t\tc++;\n\t\treturn v;\n\t}\n\treturn false;\n}\n\nbool solve(string s1, string s2) {\n\tfor (int i = 0; i < (1 << 11); i++) {\n\t\tfor (int j = 0; j < 11; j++) {\n\t\t\ta[i] = (i & (1 << j)) > 0;\n\t\t}\n\t\t//cout << i << \" \" << s1 + \" \" << s2 << endl;\n\t\tc = 0;\n\t\tbool res1 = f(s1);\n\t\tc = 0;\n\t\tbool res2 = f(s2);\n\n\t\tif (res1 == res2) return true;\n\t}\n\n\treturn false;\n}\n\nint main() {\n\tcin.tie(0);\n\tios::sync_with_stdio(false);\n\tstring s, s1, s2;\n\twhile (cin >> s , s != \"#\") {\n\t\tint idx = s.find('=');\n\t\ts1 = s.substr(0, idx) , s2 = s.substr(idx + 1, s.size() - (idx + 1));\n\t\tcout << (solve(s1, s2) ? \"YES\" : \"NO\") << endl;\n\t}\n}"
  },
  {
    "language": "C++",
    "code": "#include<bits/stdc++.h>\nint i,v;string s;\nint P() {\n  i++;\n  if(s[i]=='T')return 1;\n  if(s[i]=='F')return 0;\n  if(isalpha(s[i]))return v>>(s[i]-'a')&1;\n  if(s[i]=='-')return !P();\n  int l=P();\n  i++;int o=s[i];if(o=='-')i++;\n  int r=P();i++;\n  if(o=='*')return l&r;\n  if(o=='+')return l|r;\n  if(o=='-')return l<=r;\n}\nint main() {\n  while(std::cin>>s){\n    if(s==\"#\")break;\n    bool k=true;\n    for(v=0;v<(1<<11);v++) {\n      i=-1;int l=P();\n      i++;\n      if(l!=P()){k=false;break;}\n    }\n    std::cout<<(k?\"YES\\n\":\"NO\\n\");\n  }\n  return 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include <iostream>\n#include <vector>\n#include <string>\n\nusing namespace std;\nstring str;\nint idx;\n\n\nint calc() {\n    char c = str[idx];\n    if (c == '-') {\n        idx++;\n        return 1-calc();\n    }\n    if (c == '(') {\n        idx++;\n        int r1 = calc();\n        char cc = str[idx];\n        idx++;\n        if (cc == '-') {\n            idx++;\n        }\n        int r2 = calc();\n        idx++;\n        if (cc == '*') {\n            return r1*r2;\n        }\n        if (cc == '+') {\n            return min(1, r1+r2);\n        }\n        if (cc == '-') {\n            if (r1 && !r2) {\n                return 0;\n            } else {\n                return 1;\n            }\n        }\n    }\n    idx++;\n    return c == 'T' ? 1 : 0;\n}\n\nint main() {\n    while (true) {\n        string s;\n        cin >> s;\n        if (s == \"#\") break;\n        string s1 = \"\", s2 = \"\";\n        int u = 0;\n        while (s[u] != '=') {\n            s1 += s[u];\n            u++;\n        }\n        u++;\n        while (u < s.size()) {\n            s2 += s[u];\n            u++;\n        }\n        bool f = true;\n        for (int i = 0; i < (1<<11); i++) {\n            str = s1;\n            for (int j = 0; j < str.size(); j++) {\n                if ('a' <= str[j] && str[j] <= 'k') {\n                    str[j] = ((i>>(str[j]-'a')) & 1) ? 'T' : 'F';\n                }\n            }\n            idx = 0;\n            int r1 = calc();\n            str = s2;\n            for (int j = 0; j < str.size(); j++) {\n                if ('a' <= str[j] && str[j] <= 'k') {\n                    str[j] = ((i>>(str[j]-'a')) & 1) ? 'T' : 'F';\n                }\n            }\n            idx = 0;\n            int r2 = calc();\n            if (r1 != r2) {\n                f = false;\n                break;\n            }          \n        }\n        if (f) {\n            cout << \"YES\" << endl;\n        } else {\n            cout << \"NO\" << endl;\n        }  \n    }\n}"
  },
  {
    "language": "C++",
    "code": "#include <string>\n#include <iostream>\nusing namespace std;\nint pos; string t, d1, d2;\nbool solve(string s) {\n\tswitch (s[pos++]) {\n\tcase 'T': return true;\n\tcase 'F': return false;\n\tcase '-': \n\t\tif (s[pos] != '>') return !solve(s); break;\n\tcase '(':\n\t\tbool a = solve(s);\n\t\tswitch (s[pos++]) {\n\t\tcase '+': a = a || solve(s); break;\n\t\tcase '*': a = a && solve(s); break;\n\t\tcase '-': a = a <= solve(s); pos++; break;\n\t\t}\n\t\tpos++;\n\t\treturn a;\n\t}\n\treturn false;\n}\nint main() {\n\twhile (cin >> t) {\n\t\tif (t == \"#\") break;\n\t\tbool flag1 = false; d1 = \"\"; d2 = \"\";\n\t\tfor (int i = 0; i < t.size(); i++) {\n\t\t\tif (t[i] == '=') flag1 = true, i++;\n\t\t\tif (!flag1) d1 += t[i];\n\t\t\telse d2 += t[i];\n\t\t}\n\t\tbool flag = true;\n\t\tfor (int i = 0; i < 2048; i++) {\n\t\t\tstring d3 = d1, d4 = d2;\n\t\t\tfor (int j = 0; j < 11; j++) {\n\t\t\t\tfor (int k = 0; k < d3.size(); k++) {\n\t\t\t\t\tif (d3[k] == j + 97) {\n\t\t\t\t\t\td3[k] = (i & (1 << j) ? 'T' : 'F');\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t\tfor (int k = 0; k < d4.size(); k++) {\n\t\t\t\t\tif (d4[k] == j + 97) {\n\t\t\t\t\t\td4[k] = (i & (1 << j) ? 'T' : 'F');\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t}\n\t\t\tpos = 0; bool p1 = solve(d3); pos = 0; bool p2 = solve(d4);\n\t\t\tif (p1 != p2) {\n\t\t\t\tflag = false;\n\t\t\t}\n\t\t}\n\t\tprintf(\"%s\\n\", flag ? \"YES\" : \"NO\");\n\t}\n\treturn 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include <iostream>\n#include <string>\n#include <vector>\n#include <algorithm>\n#include <cmath>\n#include <cstdio>\n#include <functional>\n#include <numeric>\n#include <stack>\n#include <queue>\n#include <map>\n#include <set>\n#include <utility>\n#include <sstream>\n#include <complex>\n#include <fstream>\n#include <bitset>\n#include <time.h>\n\nusing namespace std;\n\ntypedef long long ll;\ntypedef pair<ll, ll> P;\ntypedef vector<ll> V;\ntypedef complex<double> Point;\n\n#define PI acos(-1.0)\n#define EPS 1e-10\nconst ll INF = (1LL << 31) - 1;\nconst ll MOD = 1e9 + 7;\n\n#define FOR(i,a,b) for(int i=(a);i<(b);i++)\n#define REP(i,N) for(int i=0;i<(N);i++)\n#define ALL(s) (s).begin(),(s).end()\n#define EQ(a,b) (abs((a)-(b))<EPS)\n#define EQV(a,b) ( EQ((a).real(), (b).real()) && EQ((a).imag(), (b).imag()) )\n#define fi first\n#define se second\n#define N_SIZE (1LL << 20)\n#define NIL -1\n#define MAX_N 100100 * 3\n\nstring s;\nmap<char, bool> mci;\n\nvector<string> split(string str, char sep)\n{\n\tvector<string> v;\n\tstringstream ss(str);\n\tstring buffer;\n\twhile (getline(ss, buffer, sep)) {\n\t\tv.push_back(buffer);\n\t}\n\treturn v;\n}\n\nstring print(ll num) {\n\tstring res;\n\tint n = (1 << 12);\n\twhile (n) {\n\t\tif (num >= n) {\n\t\t\tnum -= n;\n\t\t\tres += \"1\";\n\t\t}\n\t\telse res += \"0\";\n\t\tn /= 2;\n\t}\n\treturn res;\n}\n\nbool formula(string s, int &pos) {\n\t//cout << s[pos] << \"!\" << pos << endl;\n\tif (s[pos] == 'T') {\n\t\tpos++;\n\t\treturn true;\n\t}\n\tif (s[pos] == 'F') {\n\t\tpos++;\n\t\treturn false;\n\t}\n\tif (s[pos] >= 'a'&&s[pos] <= 'k') {\n\t\tbool res = mci[s[pos]];\n\t\treturn mci[s[pos]];\n\t}\n\tbool res = false;\n\tif (s[pos] == '-') {\n\t\tif (s[pos + 1] != '>') {\n\t\t\tpos++;\n\t\t\tres = !formula(s, pos);\n\t\t}\n\t}\n\tif (s[pos] == '(') {\n\t\tpos++;\n\t\tres = formula(s, pos);\n\t\tpos++;\n\t}\n\twhile (s[pos] == ')')pos++;\n\tif (s[pos] == '*') {\n\t\tpos++;\n\t\tres &= formula(s, pos);\n\t}\n\telse if (s[pos] == '+') {\n\t\tpos++;\n\t\tres |= formula(s, pos);\n\t}\n\telse if (s[pos] == '-') {\n\t\tpos += 2;\n\t\tif (res == true && formula(s, pos) == false)return false;\n\t\telse return true;\n\t}\n\treturn res;\n}\n\nbool equation(string s, int &pos) {\n\tvector<string> vs = split(s, '=');\n\tbool f = formula(vs[0], pos);\n\tpos = 0;\n\tbool f2 = formula(vs[1], pos);\n\tif (f != f2)cout << f << f2 << endl;\n\treturn f == f2;\n}\n\nint main() {\n\twhile (cin >> s&&s != \"#\") {\n\t\tmci.clear();\n\t\tbool f = true;\n\t\tREP(mask, (1 << 12)) {\n\t\t\t//if (mask == 10)break;\n\t\t\t//cout << mask << endl;\n\t\t\tint pos = 0;\n\t\t\tint num = mask;\n\t\t\tfor (int i = 0; i < 12; i++) {\n\t\t\t\tif ((num >> i) & 1)mci['a' + i] = true;\n\t\t\t\telse mci['a' + i] = false;\n\t\t\t}\n\t\t\tbool g = equation(s, pos);\n\t\t\t//if (!g)cout << mask << \" \" << g << endl;\n\t\t\tf &= g;\n\t\t}\n\t\tif (f)cout << \"YES\" << endl;\n\t\telse cout << \"NO\" << endl;\n\t}\n}"
  },
  {
    "language": "C++",
    "code": "#include <iostream>\n#include <string>\n#include <cctype>\n#include <map>\nusing namespace std;\n\ntypedef string::const_iterator State;\nclass ParseError {};\n\nmap<char, bool> variable;\n\nbool equation(State&);\nbool formula(State&);\nbool boolean(State&);\n\nint main(void) {\n    for (int i = 0; i < 11; i++) {\n        variable['a'+i] = false;\n    }\n\n    string s;\n    while (1) {\n        getline(cin, s);\n        if (s == \"#\") break;\n\n        State begin = s.begin();\n\n        if (equation(begin)) {\n            cout << \"YES\" << endl;\n        } else {\n            cout << \"NO\" << endl;\n        }\n    }\n\n    return 0;\n}\n\nbool equation(State &begin) {\n    bool left = formula(begin);\n    begin++;                    // '='\n    bool right = formula(begin);\n    cout << \"left: \" << left << \", right: \" << right << endl;\n    return (left == right) ? true : false;\n}\n\nbool formula(State &begin) {\n    if (*begin == '(') {\n        begin++;                // '('\n        bool ret = formula(begin);\n        if (*begin == '*') {\n            begin++;\n            ret = formula(begin) && ret;\n        } else if (*begin == '+') {\n            begin++;\n            ret = formula(begin) || ret;\n        } else {\n            begin++;\n            if (*begin == '>') {\n                begin++;\n                if (!ret) {\n                    ret = formula(begin) || true;\n                } else {\n                    ret = formula(begin);\n                }\n            } else {\n                ret = !formula(begin);\n            }\n        }\n        begin++;                // ')'\n        return ret;\n    } else if (*begin == '-') {\n        begin++;\n        return !formula(begin);\n    } else {\n        return boolean(begin);\n    }\n}\n\nbool boolean(State &begin) {\n    if (*begin == 'T') {\n        begin++;\n        return true;\n    } else if (*begin == 'F') {\n        begin++;\n        return false;\n    } else {                // a~k\n        bool ret = variable[*begin];\n        begin++;\n        return ret;\n    }\n}"
  },
  {
    "language": "C++",
    "code": "#include <algorithm>\n#include <cmath>\n#include <climits>\n#include <cstdio>\n#include <cstdlib>\n#include <cstring>\n#include <fstream>\n#include <iostream>\n#include <list>\n#include <map>\n#include <queue>\n#include <set>\n#include <sstream>\n#include <stack>\n#include <string>\n#include <vector>\n\nusing namespace std;\n\n#define LOG(...) printf(__VA_ARGS__)\n//#define LOG(...)\n#define FOR(i,a,b) for(int i=(int)(a);i<(int)(b);++i)\n#define REP(i,n) for(int i=0;i<(int)(n);++i)\n#define ALL(a) (a).begin(),(a).end()\n#define RALL(a) (a).rbegin(),(a).rend()\n#define EXIST(s,e) ((s).find(e)!=(s).end())\n#define SORT(c) sort((c).begin(),(c).end())\n#define RSORT(c) sort((c).rbegin(),(c).rend())\n#define CLR(a) memset((a), 0 ,sizeof(a))\n\ntypedef long long ll;\ntypedef unsigned long long ull;\ntypedef vector<bool> vb;\ntypedef vector<int> vi;\ntypedef vector<ll> vll;\ntypedef vector<vb> vvb;\ntypedef vector<vi> vvi;\ntypedef vector<vll> vvll;\ntypedef pair<int, int> pii;\ntypedef pair<ll, ll> pll;\n\nconst int dx[] = {-1,0,1,0}; const int dy[] = {0,1,0,-1};\n\nchar equation(string form, int vars) {\n    stack<char> st;\n\n    int len = form.length();\n    int i = 0;\n    while (i < len) {\n        char c = form[i];\n        char c1, c2, op;\n        switch (c) {\n        case '-':\n            if (form[i+1] == '>') {\n                // imp\n                st.push('>');\n            } else {\n                // not\n                switch (form[i+1]) {\n                case 'T':\n                    st.push('0');\n                    break;\n                case 'F':\n                    st.push('1');\n                    break;\n                case '-': // not not\n                    break;\n                case '(':\n                    st.push('-');\n                    break;\n                default:\n                    c1 = vars & (1 << (form[i+1] - 'a')) ? '0' : '1';\n                    st.push(c1);\n                }\n            }\n            i++;\n            break;\n        case '*':\n            st.push('*');\n            break;\n        case '+':\n            st.push('+');\n            break;\n        case '(':\n            break;\n        case ')':\n            c2 = st.top(); st.pop();\n            op = st.top(); st.pop();\n            c1 = st.top(); st.pop();\n            switch (op) {\n            case '>':\n                if (c1 == '1' && c2 == '0') {\n                    st.push('0');\n                } else {\n                    st.push('1');\n                }\n                break;\n            case '*':\n                st.push(c1 & c2 | '0');\n                break;\n            case '+':\n                st.push(c1 | c2 | '0');\n                break;\n            }\n            break;\n        case 'T':\n            st.push('1');\n            break;\n        case 'F':\n            st.push('0');\n            break;\n        default:\n            c1 = vars & (1 << (c - 'a')) ? '1' : '0';\n            st.push(c1);\n        }\n        i++;\n    }\n    // not\n    if (st.size() >= 2) {\n        char c1 = st.top(); st.pop();\n        return c1 ^ '1' | '0';\n    } else {\n        return st.top();\n    }\n}\n\nint main() {\n    while (1) {\n        string line;\n        getline(cin, line);\n        if (line == \"#\") break;\n\n        stringstream ss(line);\n        string f1, f2;\n        getline(ss, f1, '=');\n        getline(ss, f2);\n\n        bool eq = true;\n        for (int vars = 0; vars < (1 << 11); vars++) {\n            if (equation(f1, vars) != equation(f2, vars)) {\n                eq = false;\n                break;\n            }\n        }\n        if (eq) {\n            cout << \"YES\" << endl;\n        } else {\n            cout << \"NO\" << endl;\n        }\n    }\n}"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\nusing namespace std;\n#define rep(i, n) for (int i = 0; i < int(n); ++i)\n\nconst int N = 11;\n\nbool eval(const string& expr, int tval) {\n    int p = 0;\n    function<bool()> ll1 = [&]() {\n        if (isalpha(expr[p])) {\n            switch (expr[p]) {\n                case 'T': p++; return true;\n                case 'F': p++; return false;\n                default: return (tval >> (expr[p++] - 'a') & 1) == 1;\n            }\n        }\n        if (expr[p] == '-' and expr[p + 1] != '>') { p++; return not ll1(); }\n        if (expr[p] == '(') {\n            p++;\n            bool x = ll1();\n            char op = expr[p++];\n            if (op == '-') p++;\n            bool y = ll1();\n            p++;\n            return op == '+' ? x or y : op == '*' ? x and y : (not x) or (x and y);\n        }\n        throw;\n    };\n    return ll1();\n}\n\nbool solve(const string& expr) {\n    auto p = expr.find_first_of('=');\n    string lhs = expr.substr(0, p), rhs = expr.substr(p + 1);\n    rep(tval, 1 << N) if (eval(lhs, tval) != eval(rhs, tval)) return false;\n    return true;\n}\n\nint main() {\n    for (string expr; cin >> expr, expr != \"#\";) cout << (solve(expr) ? \"YES\" : \"NO\") << endl;\n}"
  },
  {
    "language": "C++",
    "code": "#include \"bits/stdc++.h\"\nusing namespace std;\ntypedef long long ll;\ntypedef pair<int,int> pii;\n#define rep(i,n) for(ll i=0;i<(ll)(n);i++)\n#define all(a)  (a).begin(),(a).end()\n#define pb push_back\n#define INF (1e9+1)\n//#define INF (1LL<<59)\n\ntypedef string::const_iterator State;\n\n\nstring getop(State &begin){\n\tif(*begin=='*'){\n\t\tbegin++;\n\t\treturn \"*\";\n\t}\n\telse if(*begin=='+'){\n\t\tbegin++;\n\t\treturn \"+\";\n\t}else{\n\t\tbegin++;\n\t\tbegin++;\n\t\treturn \"->\";\n\t}\n}\n\n\nbool mul(bool a,bool b){\n\tif(a&&b)return true;\n\telse return false;\n}\n\n\nbool add(bool a,bool b){\n\tif(!a&&!b)return false;\n\telse return true;\n}\n\n\nbool imp(bool a,bool b){\n\tif(a&&!b)return false;\n\telse return true;\n}\n\n\nbool exp(State &begin){\n\tif(isdigit(*begin)){\n\t\tbegin++;\n\t\treturn *begin-'0';\n\t}\n\telse if(*begin=='-'){\n\t\tbegin++;\n\t\treturn !exp(begin);\n\t}else if(*begin=='('){\n\t\tbegin++;\n\t\tbool ll = exp(begin);\n\t\tstring op = getop(begin);\n\t\tbool rr = exp(begin);\n\t\tbegin++;\n\t\t\n\t\tif(op==\"*\")return mul(ll,rr);\n\t\telse if(op==\"+\")return add(ll,rr);\n\t\telse return imp(ll,rr);\n\t}\n\t\n\tassert(1);\n\treturn 0;\n}\n\n\nbool check(string s){\n\tstring left=\"\",right=\"\";\n\tbool f=false;\n\trep(i,s.size()){\n\t\tif(s[i]=='=')f=true;\n\t\telse if(f)right+=s[i];\n\t\telse left+=s[i];\n\t}\n\t\n\tState bl = left.begin(),br = right.begin();\n\tbool l = exp(bl);\n\tbool r = exp(br);\n\t\n\tif(l==r)return true;\n\telse return false;\n}\n\n\nint main(){\n\tstring s;\n\twhile(cin>>s&&s!=\"#\"){\n\t\tset<char> var;\n\t\tint c=0;\n\t\trep(i,s.size()){\n\t\t\tif(isalpha(s[i])){\n\t\t\t\tvar.insert(s[i]);\n\t\t\t}\n\t\t}\n\t\t\n\t\t\n\t\tbool f = false;\n\t\tint en = 1<<var.size();\n\t\trep(i,en){\n\t\t\tmap<char,int> mp;\n\t\t\tint num = i;\n\t\t\tfor(auto &e:var){\n\t\t\t\tmp[e] = num%2;\n\t\t\t\tnum/=2;\n\t\t\t}\n\t\t\tstring t = s;\n\t\t\trep(j,t.size()){\n\t\t\t\tif( isalpha(t[j]) ){\n\t\t\t\t\tt[j] = '0'+mp[t[j]];\n\t\t\t\t}\n\t\t\t}\n\t\t\tif(check(t)==false)f=true;\n\t\t}\n\t\tif(f)cout<<\"NO\"<<endl;\n\t\telse cout<<\"YES\"<<endl;}\n}"
  },
  {
    "language": "C++",
    "code": "#include<iostream>\n#include<string>\n#define MAX 13\nusing namespace std;\nbool o;\nvoid rec(string s){\n  if(!o) return;\n  //cout << s << endl;\n  bool f;\n  int p;\n  while(s.find(\"-0\")!=-1){\n    p=s.find(\"-0\");\n    s[p]='1';s[p+1]=' ';\n    f=true;\n  }\n  while(s.find(\"-1\")!=-1){\n    p=s.find(\"-1\");\n    s[p]='0';s[p+1]=' ';\n    f=true;\n  }\n  while(s.find(\"(0*0)\")!=-1){\n    p=s.find(\"(0*0)\");\n    s[p]='0';s[p+1]=' ';s[p+2]=' ';s[p+3]=' ';s[p+4]=' ';\n    f=true;\n  }\n  while(s.find(\"(0*1)\")!=-1){\n    p=s.find(\"(0*1)\");\n    s[p]='0';s[p+1]=' ';s[p+2]=' ';s[p+3]=' ';s[p+4]=' ';\n    f=true;\n  }\n  while(s.find(\"(1*0)\")!=-1){\n    p=s.find(\"(1*0)\");\n    s[p]='0';s[p+1]=' ';s[p+2]=' ';s[p+3]=' ';s[p+4]=' ';\n    f=true;\n  }\n  while(s.find(\"(1*1)\")!=-1){\n    p=s.find(\"(1*1)\");\n    s[p]='1';s[p+1]=' ';s[p+2]=' ';s[p+3]=' ';s[p+4]=' ';\n    f=true;\n  }\n  while(s.find(\"(0+0)\")!=-1){\n    p=s.find(\"(0+0)\");\n    s[p]='0';s[p+1]=' ';s[p+2]=' ';s[p+3]=' ';s[p+4]=' ';\n    f=true;\n  }\n  while(s.find(\"(0+1)\")!=-1){\n    p=s.find(\"(0+1)\");\n    s[p]='1';s[p+1]=' ';s[p+2]=' ';s[p+3]=' ';s[p+4]=' ';\n    f=true;\n  }\n  while(s.find(\"(1+0)\")!=-1){\n    p=s.find(\"(1+0)\");\n    s[p]='1';s[p+1]=' ';s[p+2]=' ';s[p+3]=' ';s[p+4]=' ';\n    f=true;\n  }\n  while(s.find(\"(1+1)\")!=-1){\n    p=s.find(\"(1+1)\");\n    s[p]='1';s[p+1]=' ';s[p+2]=' ';s[p+3]=' ';s[p+4]=' ';\n    f=true;\n  }\n  while(s.find(\"(0->0)\")!=-1){\n    p=s.find(\"(0->0)\");\n    s[p]='1';s[p+1]=' ';s[p+2]=' ';s[p+3]=' ';s[p+4]=' ';s[p+5]=' ';\n    f=true;\n  }\n  while(s.find(\"(0->1)\")!=-1){\n    p=s.find(\"(0->1)\");\n    s[p]='1';s[p+1]=' ';s[p+2]=' ';s[p+3]=' ';s[p+4]=' ';s[p+5]=' ';\n    f=true;\n  }\n  while(s.find(\"(1->0)\")!=-1){\n    p=s.find(\"(1->0)\");\n    s[p]='0';s[p+1]=' ';s[p+2]=' ';s[p+3]=' ';s[p+4]=' ';s[p+5]=' ';\n    f=true;\n  }\n  while(s.find(\"(1->1)\")!=-1){\n    p=s.find(\"(1->1)\");\n    s[p]='1';s[p+1]=' ';s[p+2]=' ';s[p+3]=' ';s[p+4]=' ';s[p+5]=' ';\n    f=true;\n  }\n  if(f){\n    string b;\n    for(int i=0;i<s.size();i++) if(s[i]!=' ') b+=s[i];\n    rec(b);\n  }else{\n    if(s[0]!=s[2]) o=false;\n    return;\n  }\n}\nvoid init(int n,string s){\n  int i,j;\n  for(i=0;i<s.size();i++){\n    for(j=0;j<=MAX;j++){\n      if(s[i]=='a'+j) s[i]='0'+(n>>j&1);\n      if(s[i]=='T') s[i]='1';\n      if(s[i]=='F') s[i]='0';\n    }\n  }\n  rec(s);\n}\nint main(){\n  string s;\n  while(cin >> s,s!=\"#\"){\n    o=true;\n    int i;\n    for(i=0;i<(1<<MAX);i++)\n      init(i,s);\n    cout << (o?\"YES\":\"NO\") << endl;\n  }\n  return 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include <iostream>\n#include <algorithm>\n#include <string>\n#include <vector>\nusing namespace std;\n\nconst int INF = 1e+8;\n\n// 変数 'a' - 'k' を value に置き換え\nvoid change(string& s, char x, char value){\n  for(int i=0 ; i < s.size() ; i++ ){\n    if( s[i] == x ) s[i] = value;\n  }\n}\n\n// 式から \"--\" の除去\nvoid minus_erase(string& s){\n  for(int i=1 ; i < s.size() ; i++ ){\n    if( s[i-1] == '-' && s[i] == '-' ){\n      s.erase( i-1 , 2 );\n      i = 0;\n    }\n  }\n}\n\n// 論理否定の計算 (\"-F\" => \"T\", \"-T\" => \"F\" の 文字列置換)\nvoid minus_calc(string& s){\n  for(int i=1 ; i < s.size() ; i++ ){\n    if( s[i-1] == '-' && s[i] == 'F' ){\n      s.replace( i-1 , 2 , \"T\" );\n      i = 0;\n    }else if( s[i-1] == '-' && s[i] == 'T' ){\n      s.replace( i-1 , 2 , \"F\" );\n      i = 0;\n    }\n  }\n}\n\n// 論理和, 論理積, 論理包含の計算 (文字列置換)\nvoid calc(string& s){\n  string ex[12] = {\n    \"(F+F)\", \"(F+T)\", \"(T+F)\", \"(T+T)\",\n    \"(F*F)\", \"(F*T)\", \"(T*F)\", \"(T*T)\",\n    \"(F>F)\", \"(F>T)\", \"(T>F)\", \"(T>T)\"\n  };\n  string result[12] = {\n    \"F\", \"T\", \"T\", \"T\",\n    \"F\", \"F\", \"F\", \"T\",\n    \"T\", \"T\", \"F\", \"T\"\n  };\n  for(int i=0 ; i+4 < s.size() ; i++ ){\n    for(int j=0 ; j < 12 ; j++ ){\n      if( s.substr(i,5) == ex[j] ){\n        s.replace( i , 5 , result[j] );\n        i = -1;\n        break;\n      }\n    }\n  }\n}\n\nint main(){\n  string ex;\n  while( cin >> ex ){\n    if( ex == \"#\" ) break;\n    \n    // \"->\" を \">\" に置き換えておく\n    string s;\n    for(int i=0 ; i < ex.size() ; i++ ){\n      if( i+1 < ex.size() && ex[i] == '-' && ex[i+1] == '>' ){\n        s.push_back( '>' );\n        i++;\n      }else{\n        s.push_back( ex[i] );\n      }\n    }\n    \n    // '=' の左側を ex1, 右側を ex2 とする\n    string ex1, ex2;\n    bool flag = false;\n    for(int i=0 ; i < s.size() ; i++ ){\n      if( s[i] == '=' ){\n        flag = true;\n      }else if( flag ){\n        ex2.push_back( s[i] );\n      }else{\n        ex1.push_back( s[i] );\n      }\n    }\n    \n    // 登場する変数('a' - 'k')をチェック\n    int f[256] = {0};\n    for(int i= 0 ; i < s.size() ; i++ ){\n      f[ s[i] ] = 1;\n    }\n    vector<char> vc;\n    for(char c = 'a' ; c <= 'k' ; c++ ){\n      if( f[c] ){\n        vc.push_back( c );\n      }\n    }\n    // N := 登場する変数の種類.\n    int N = vc.size();\n    \n    // 変数の置き換えを 2^N 通り試し すべての式の評価で右辺と左辺が等しいか調べる.\n    bool ans = true;\n    for(int bits = 0 ; bits < (1<<N) ; bits++ ){\n      string ex1_ = ex1;\n      string ex2_ = ex2;\n      // 変数を \"T\" or \"F\" に置き換えておく\n      for(int i=0 ; i < N ; i++ ){\n        // i 番目の文字を'T' か 'F'にしておく\n        if( bits & (1<<i) ){\n          change( ex1_ , vc[i] , 'T' );\n          change( ex2_ , vc[i] , 'T' );\n        }else{\n          change( ex1_ , vc[i] , 'F' );\n          change( ex2_ , vc[i] , 'F' );\n        }\n      }\n      // \"--\" の除去\n      minus_erase( ex1_ );\n      minus_erase( ex2_ );\n      \n      // 式 ex1 が \"T\" か \"F\" になるまで文字列置換を繰り返す.\n      bool minus_flag = true;\n      while( ex1_.size() > 1 ){\n        minus_calc( ex1_ );\n        calc( ex1_ );\n      }\n      // 式 ex2 が \"T\" か \"F\" になるまで文字列置換を繰り返す.\n      while( ex2_.size() > 1 ){\n        minus_calc( ex2_ );\n        calc( ex2_ );\n      }\n      // 式 ex1 と 式 ex2 が等しいかどうか\n      if( ex1_ != ex2_ ){ ans = false; break;}\n    }\n    // 出力 \n    if( ans ){\n      cout << \"YES\" << endl;\n    }else{\n      cout << \"NO\" << endl;\n    }\n  }\n}"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\n\n#define N 12\n\nusing namespace std;\n\nbool parse(string x, bool vars[N]) {\n    int nest = 0;\n    switch (x[0]) {\n        case 'T':\n            return true;\n        case 'F':\n            return false;\n        case '-':\n            return ~parse(x.substr(1), vars);\n        case '(':\n            break;\n        default:\n            return vars[x[0]-'a'];\n    }\n    x = x.substr(1, x.length()-2);\n    for (int i=0; i<(int)x.length(); i++) {\n        if (x[i] == '(') {\n            nest++;\n            continue;\n        }\n        if (x[i] == ')') {\n            nest--;\n            continue;\n        }\n        if (nest > 0) {\n            continue;\n        }\n        if (x[i] == '+') {\n            return parse(x.substr(0, i), vars) || parse(x.substr(i+1), vars);\n        }\n        if (x[i] == '*') {\n            return parse(x.substr(0, i), vars) && parse(x.substr(i+1), vars);\n        }\n        if (x.substr(i, 2) == \"->\") {\n            return (~parse(x.substr(0, i), vars)) || parse(x.substr(i+2), vars);\n        }\n    }\n    while (true) {\n        cout << \"tsu_ra_i\" << endl;\n    }\n}\n\nbool is_equal(string x, string y) {\n    bool vars[N];\n    for (int i=0; i<(1<<N); i++) {\n        for (int j=0; j<N; j++) {\n            vars[j] = i&(1<<j);\n        }\n        if (parse(x, vars) != parse(y, vars)) {\n            return false;\n        }\n    }\n    return true;\n}\n\nint main() {\n    string line, x, y;\n    while (true) {\n        cin >> line;\n        if (line == \"#\") {\n            return 0;\n        }\n        for (int i=0; i<(int)line.length(); i++) {\n            if (line[i] == '=') {\n                x = line.substr(0, i);\n                y = line.substr(i+1);\n                break;\n            }\n        }\n        if (is_equal(x, y)) {\n            cout << \"YES\" << endl;\n        }\n        else {\n            cout << \"NO\" << endl;\n        }\n    }\n}"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\nusing namespace std;\n\ntypedef ostringstream OSS; typedef istringstream ISS;\ntypedef long long LL;\ntypedef pair<int, int> PII;  typedef pair<LL, LL> PLL;\ntypedef vector<int>    VI;   typedef vector<VI>   VVI;   typedef vector<VVI>   VVVI;\ntypedef vector<LL>     VLL;  typedef vector<VLL>  VVLL;  typedef vector<VVLL>  VVVLL;\ntypedef vector<double> VD;   typedef vector<VD>   VVD;   typedef vector<VVD>   VVVD;\ntypedef vector<string> VS;   typedef vector<VS>   VVS;   typedef vector<VVS>   VVVS;\ntypedef vector<bool>   VB;   typedef vector<VB>   VVB;   typedef vector<VVB>   VVVB;\ntypedef vector<PII>    VPII; typedef vector<VPII> VVPII; typedef vector<VVPII> VVVPII;\ntypedef vector<PLL>    VPLL; typedef vector<VPLL> VVPLL; typedef vector<VVPLL> VVVPLL;\n\ntypedef unsigned int  UI;\ntypedef vector<UI>    VUI;\ntypedef vector<VUI>   VVUI;\n\n#define fst first\n#define snd second\n// #define Y first\n// #define X second\n#define MP make_pair\n#define PB push_back\n#define EB emplace_back \n#define ALL(x)  (x).begin(),(x).end()\n#define RALL(x) (x).rbegin(),(x).rend()\n#define RANGEBOX(x,y,maxX,maxY) (0 <= (x) && 0 <= (y) && (x) < (maxX) && (y) < (maxY))\n#define RANGE(x, l, r) ((l) <= (x) && (x) <= (r))\n#define rep(i, N)  for (int i = 0; i < (int)(N); i++)\n#define rrep(i, N) for (int i = N - 1; i >= 0; i--)\n#define REP(i, init, N)  for (int i = (init); i < (int)(N); i++)\n#define RREP(i, N, last) for (int i = (init - 1); i >= last; i--)\n#define MAXUD(orig, target) orig = max(orig, target)\n#define MINUD(orig, target) orig = min(orig, target)\n#define DUMP( x ) cerr << #x << \" = \" << ( x ) << endl\n\ntemplate < typename T > inline T fromString(const string &s) { T res; ISS iss(s); iss >> res; return res; };\ntemplate < typename T > inline string toString(const T &a)   { OSS oss; oss << a; return oss.str(); };\n\ntemplate<typename T=int> inline void dump(vector<T> vs, bool ent=false) { rep(i, vs.size()) cout << vs[i] << (i+1==vs.size() ? '\\n' : ' '); if (ent) cout << endl; }\ntemplate<typename T = int> inline void dump(vector<vector<T>> vs, bool ent = false) { rep(i, vs.size()) dump<T>(vs[i]); if (ent) cout << endl; }\n\nconst int    INF  = 0x3f3f3f3f;\nconst LL     INFL = 0x3f3f3f3f3f3f3f3fLL;\nconst double DINF = 0x3f3f3f3f;\nconst int    DX[] = {1,  0, -1, 0};\nconst int    DY[] = {0, -1,  0, 1};\nconst double EPS  = 1e-12;\n// const double PI   = acos(-1.0);\n// lambda: [](T1 x)->T2{return y;}\n// simple lambda: [](T x){return x;}\n\nstring alphas(\"abcdefghijk\");\nint alphas_num = alphas.size();\n\ntypedef pair<bool, int> Res;\n\nRes formula(string &s, int pos, int p) {\n    char c = s[pos];\n    \n    if (c == 'T') { return MP(true, pos + 1); }\n    if (c == 'F') { return MP(false, pos + 1); }\n\n    auto cpos = find(ALL(alphas), c);\n    if (cpos != alphas.end()) {\n        int idx = cpos - alphas.begin();\n        return MP(p >> idx & 1, pos + 1);\n    }\n\n    if (c == '(') {\n        Res x = formula(s, pos + 1, p);\n        pos = x.snd;\n\n        string op = \"\";\n        op += s[pos];\n        ++pos;\n        if (op == \"-\") {\n            op += s[pos];\n            assert(op == \"->\");\n            ++pos;\n        }\n\n        Res y = formula(s, pos, p);\n        pos = y.snd;\n\n        assert(s[pos] == ')');\n        ++pos;\n\n        if (op == \"->\") {\n            return MP(!x.fst || y.fst, pos);\n        } else if (op == \"*\") {\n            return MP(x.fst && y.fst, pos);\n        } else if (op == \"+\") {\n            return MP(x.fst || y.fst, pos);\n        } else {\n            assert(false);\n        }\n    }\n\n    if (c == '-') {\n        Res x = formula(s, pos + 1, p);\n        return MP(!x.fst, x.snd);\n    }\n\n    assert(false);\n}\n\nbool solve(string s1, string s2) {\n    rep(p, 1 << alphas_num) {\n        Res res1 = formula(s1, 0, p);\n        Res res2 = formula(s2, 0, p);\n        if (res1.fst != res2.fst) {\n            return false;\n        }\n    }\n    return true;\n}\n\nint main(void) {\n    string s;\n    while (cin >> s, s != \"#\"){\n        auto pos = find(ALL(s), '=') - s.begin();\n        string s1 = s.substr(0, pos);\n        string s2 = s.substr(pos + 1, s.size());\n        cout << (solve(s1, s2) ? \"YES\" : \"NO\") << endl;\n    }\n\n    return 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include <iostream>\n#define T 1\n#define F 0\nusing namespace std;\nint equation();\nint formula();\nint p,a,b,c,d,e,f,g,h,i,j,k;\nstring str;\nint main(){\n  int r;\n  while(1){\n    cin >> str;\n    if(str==\"#\") break;\n    int flag=0;\n    for(int a1=0;a1<2;a1++){\n      a=a1;\n      for(int b1=0;b1<2;b1++){\n\tb=b1;\n\tfor(int c1=0;c1<2;c1++){\n\t  c=c1;\n\t  for(int d1=0;d1<2;d1++){\n\t    d=d1;\n\t    for(int e1=0;e1<2;e1++){\n\t      e=e1;\n\t      for(int f1=0;f1<2;f1++){\n\t\tf=f1;\n\t\tfor(int g1=0;g1<2;g1++){\n\t\t  g=g1;\n\t\t  for(int h1=0;h1<2;h1++){\n\t\t    h=h1;\n\t\t    for(int i1=0;i1<2;i1++){\n\t\t      i=i1;\n\t\t      for(int j1=0;j1<2;j1++){\n\t\t\tj=j1;\n\t\t\tfor(int k1=0;k1<2;k1++){\n\t\t\t  k=k1;\n\t\t\t  p=0;\n\t\t\t  r=equation();\n\t\t\t  if(r==F){\n\t\t\t    flag=1;\n\t\t\t    break;\n\t\t\t  }\n\t\t\t}\n\t\t\tif(flag==1) break;\n\t\t      }\n\t\t      if(flag==1) break;\n\t\t    }\n\t\t    if(flag==1) break;\n\t\t  }\n\t\t  if(flag==1) break;\n\t\t}\n\t\tif(flag==1) break;\n\t      }\n\t      if(flag==1) break;\n\t    }\n\t    if(flag==1) break;\n\t  }\n\t  if(flag==1) break;\n\t}\n\tif(flag==1) break;\n      }\n      if(flag==1) break;\n    }\n    if(flag==0) cout << \"YES\" << endl;\n    else cout << \"NO\" << endl;\n  }\n  return 0;\n}\nint equation(){\n  int val=formula(),val1;\n  if(str[p]=='='){\n    p++;\n    val1=formula();\n    if(val==val1) return T;\n  }\n  return F;\n}\nint formula(){\n  int r,r1;\n  while(1){\n    if(str[p]=='T'){\n      p++;\n      return T;\n    }\n    if(str[p]=='F'){\n      p++;\n      return F;\n    }\n    if(str[p]=='a'){\n      p++;\n      return a;\n    }\n    if(str[p]=='b'){\n      p++;\n      return b;\n    }\n    if(str[p]=='c'){\n      p++;\n      return c;\n    }\n    if(str[p]=='d'){\n      p++;\n      return d;\n    }\n    if(str[p]=='e'){\n      p++;\n      return e;\n    }\n    if(str[p]=='f'){\n      p++;\n      return f;\n    }\n    if(str[p]=='g'){\n      p++;\n      return g;\n    }\n    if(str[p]=='h'){\n      p++;\n      return h;\n    }\n    if(str[p]=='i'){\n      p++;\n      return i;\n    }\n    if(str[p]=='j'){\n      p++;\n      return j;\n    }\n    if(str[p]=='k'){\n      p++;\n      return k;\n    }\n    if(str[p]=='-'&&str[p+1]=='>'){\n      p+=2;\n      r=formula();\n      p++;\n      if(r1==T&&r==F) return F;\n      return T;\n    }\n    if(str[p]=='-'){\n      p++;\n      r=formula();\n      return 1-r;\n    }\n    if(str[p]=='('){\n      p++;\n      r1=formula();\n    }\n    if(str[p]=='*'){\n      p++;\n      r=formula();\n      p++;\n      if(r1==T&&r==T) return T;\n      return F;\n    }\n    if(str[p]=='+'){\n      p++;\n      r=formula();\n      p++;\n      if(r1==F&&r==F) return F;\n      return T;\n    }\n  }\n}"
  },
  {
    "language": "C++",
    "code": "//suhan lee,saitama university\n\n#include <vector>\n#include <list>\n#include <map>\n#include <set>\n#include <stack>\n#include <queue>\n#include <deque>\n#include <algorithm>\n#include <utility>\n#include <functional>\n#include <sstream>\n#include <iostream>\n#include <cstdio>\n#include <cmath>\n#include <cstdlib>\n#include <cctype>\n#include <cstring>\n#include <ctime>\n#include <climits>\n#include <cassert>\n#include <complex>\nusing namespace std;\n\ninline int toInt(string s) {int v; istringstream sin(s);sin>>v;return v;}\ntemplate<class T> inline string toString(T x) {ostringstream sout;sout<<x;return sout.str();}\ntypedef vector<int> vi;\ntypedef vector<vi> vvi;\ntypedef vector<string> vs;\ntypedef pair<int, int> pii;\ntypedef long long ll;\n\n#define ALL(a) (a).begin(),(a).end()\n#define RALL(a) (a).rbegin(),(a).rend()\n#define EXIST(s,e) ((s).find(e)!=(s).end())\n#define rep(i,a,b) for(int i=(a);i<(b);++i)\n#define repn(i,n) for(int i=0;i<n;i++)\n#define EACH(t,i,c) for(t::iterator i=(c).begin(); i!=(c).end(); ++i)\n#define pb push_back \n#define pf push_front\nint alphaset;\nbool equation(string inp,int& i);\nbool formula(string inp,int& i);\nbool alphabet(string inp,int& i);\nbool equation(string inp,int& i){\n  bool right,left;\n  left=formula(inp,i);\n  i++;\n  // cout<<\"i:\"<<i<<endl;\n  right=formula(inp,i);\n  //  cout<<alphaset<<endl<<left<<'='<<right<<endl;\n  return right==left;\n}\nbool formula(string inp,int& i){\n  bool left=alphabet(inp,i);\n  bool right;\n  while(true){\n    if(inp[i]=='+'){\n      right=formula(inp,++i);\n      left=right||left;\n    }\n    else    if(inp[i]=='*'){\n      right=formula(inp,++i);\n      left=right&&left;\n    }\n    else    if(inp[i]=='-'){\n      if(inp[++i]=='>'){\n\tright=formula(inp,++i);\n\tleft=(!left)||right;\n      }\n    }\n    else return left;\n  }\n}\nbool alphabet(string inp,int& i){\n  if(inp[i]=='(')\n    {\n      int out=formula(inp,++i);\n      i++;return out;\n    }\n  else if(inp[i]=='-')\n    return !alphabet(inp,++i);\n  else if(inp[i]=='T'){i++;\n    return true;}\n  else if(inp[i]=='f'){i++;\n    return false;}\n\n  else{\n    return alphaset&(1<<(inp[i++]-'a'))==true;\n  }\n\n}\n\n\nint main(){\n  while(true){\n    string inp;\n    int i=0;\n    cin>>inp;\n    if(inp==\"#\") break;\n    for(alphaset=0;alphaset<(1<<11);alphaset++){\n      i=0;\n      if(equation(inp,i)==false){\n\tcout<<\"NO\"<<endl;\n\tbreak;\n      }\n    }\n    if(alphaset==(1<<11)){\n      cout<<\"YES\"<<endl;\n    }\n  }\n  return 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include <string>\n#include <iostream>\nusing namespace std;\nstring s, t; char d[20]; int pos, cnt;\nbool calc(int l, int r) {\n\tif (s[l] == 'T') return true;\n\tif (s[l] == 'F') return false;\n\tif (s[l] == '-') return !calc(l + 1, r);\n\tint depth = 0;\n\tfor (int i = l + 1; i < r - 1; i++) {\n\t\tif (s[i] == '(') depth++;\n\t\tif (s[i] == ')') depth--;\n\t\tif (depth == 0) {\n\t\t\tif (s[i] == '*') return calc(l + 1, i) && calc(i + 1, r - 1);\n\t\t\tif (s[i] == '+') return calc(l + 1, i) || calc(i + 1, r - 1);\n\t\t\tif (s[i] == '-' && s[i + 1] == '>') return !calc(l + 1, i) || calc(i + 2, r - 1);\n\t\t}\n\t}\n}\nbool solve(int depth) {\n\tif (depth == cnt) return calc(0, pos) == calc(pos + 1, s.size());\n\tbool ret = true;\n\tfor (int j = 0; j < s.size(); j++) if (t[j] == d[depth]) s[j] = 'T'; ret &= solve(depth + 1);\n\tfor (int j = 0; j < s.size(); j++) if (t[j] == d[depth]) s[j] = 'F'; ret &= solve(depth + 1);\n\ts = t;\n\treturn ret;\n}\nint main() {\n\twhile (cin >> s, s != \"#\") {\n\t\tcnt = 0; t = s;\n\t\tpos = s.find('=');\n\t\tfor (int j = 0; j < s.size(); j++) {\n\t\t\tif (islower(s[j])) {\n\t\t\t\tbool found = false;\n\t\t\t\tfor (int k = 0; k < cnt; k++) {\n\t\t\t\t\tif (d[k] == s[j]) {\n\t\t\t\t\t\tfound = true; break;\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t\tif (!found) d[cnt++] = s[j];\n\t\t\t}\n\t\t}\n\t\tcout << (solve(0) ? \"YES\" : \"NO\") << endl;\n\t}\n}"
  },
  {
    "language": "C++",
    "code": "#include<iostream>\n#include<string>\n#define MAX 11\nusing namespace std;\nbool o;\nvoid rec(string s){\n  if(!o) return;\n  //cout << s << endl;\n  bool f;\n  int p;\n\n  \n  while(s.find(\"-0\")!=-1){\n    p=s.find(\"-0\");\n    if(p+1>=s.size()) break;\n    s[p]='1';s[p+1]=' ';\n    f=true;\n  }\n  while(s.find(\"-1\")!=-1){\n    p=s.find(\"-1\");\n    if(p+1>=s.size()) break;\n    s[p]='0';s[p+1]=' ';\n    f=true;\n  }\n  /*\n  while(s.find(\"(0*0)\")!=-1){\n    p=s.find(\"(0*0)\");\n    s[p]='0';s[p+1]=' ';s[p+2]=' ';s[p+3]=' ';s[p+4]=' ';\n    f=true;\n  }\n  while(s.find(\"(0*1)\")!=-1){\n    p=s.find(\"(0*1)\");\n    s[p]='0';s[p+1]=' ';s[p+2]=' ';s[p+3]=' ';s[p+4]=' ';\n    f=true;\n  }\n  while(s.find(\"(1*0)\")!=-1){\n    p=s.find(\"(1*0)\");\n    s[p]='0';s[p+1]=' ';s[p+2]=' ';s[p+3]=' ';s[p+4]=' ';\n    f=true;\n  }\n  while(s.find(\"(1*1)\")!=-1){\n    p=s.find(\"(1*1)\");\n    s[p]='1';s[p+1]=' ';s[p+2]=' ';s[p+3]=' ';s[p+4]=' ';\n    f=true;\n  }\n  while(s.find(\"(0+0)\")!=-1){\n    p=s.find(\"(0+0)\");\n    s[p]='0';s[p+1]=' ';s[p+2]=' ';s[p+3]=' ';s[p+4]=' ';\n    f=true;\n  }\n  while(s.find(\"(0+1)\")!=-1){\n    p=s.find(\"(0+1)\");\n    s[p]='1';s[p+1]=' ';s[p+2]=' ';s[p+3]=' ';s[p+4]=' ';\n    f=true;\n  }\n  while(s.find(\"(1+0)\")!=-1){\n    p=s.find(\"(1+0)\");\n    s[p]='1';s[p+1]=' ';s[p+2]=' ';s[p+3]=' ';s[p+4]=' ';\n    f=true;\n  }\n  while(s.find(\"(1+1)\")!=-1){\n    p=s.find(\"(1+1)\");\n    s[p]='1';s[p+1]=' ';s[p+2]=' ';s[p+3]=' ';s[p+4]=' ';\n    f=true;\n  }\n  /*\n  while(s.find(\"(0->0)\")!=-1){\n    p=s.find(\"(0->0)\");\n    s[p]='1';s[p+1]=' ';s[p+2]=' ';s[p+3]=' ';s[p+4]=' ';s[p+5]=' ';\n    f=true;\n  }\n  while(s.find(\"(0->1)\")!=-1){\n    p=s.find(\"(0->1)\");\n    s[p]='1';s[p+1]=' ';s[p+2]=' ';s[p+3]=' ';s[p+4]=' ';s[p+5]=' ';\n    f=true;\n  }\n  while(s.find(\"(1->0)\")!=-1){\n    p=s.find(\"(1->0)\");\n    s[p]='0';s[p+1]=' ';s[p+2]=' ';s[p+3]=' ';s[p+4]=' ';s[p+5]=' ';\n    f=true;\n  }\n  while(s.find(\"(1->1)\")!=-1){\n    p=s.find(\"(1->1)\");\n    s[p]='1';s[p+1]=' ';s[p+2]=' ';s[p+3]=' ';s[p+4]=' ';s[p+5]=' ';\n    f=true;\n  }\n  */\n  if(f){\n    string b;\n    for(int i=0;i<s.size();i++) if(s[i]!=' ') b+=s[i];\n    rec(b);\n  }else{\n    if(s[0]!=s[2]) o=false;\n    return;\n  }\n}\nvoid init(int n,string s){\n  int i,j;\n  for(i=0;i<s.size();i++){\n    for(j=0;j<=MAX;j++){\n      if(s[i]=='a'+j) s[i]='0'+(n>>j&1);\n      if(s[i]=='T') s[i]='1';\n      if(s[i]=='F') s[i]='0';\n    }\n  }\n  rec(s);\n}\nint main(){\n  string s;\n  while(cin >> s,s!=\"#\"){\n    o=true;\n    int i;\n    for(i=0;i<(1<<MAX);i++)\n      init(i,s);\n    cout << (o?\"YES\":\"NO\") << endl;\n  }\n  return 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include <iostream>\n#include <algorithm>\n#include <numeric>\n#include <vector>\n#include <cassert>\n#include <string>\n#include <memory.h>\n#include <queue>\n#include <cstdio>\n#include <cstdlib>\n#include <set>\n#include <map>\n#include <cctype>\n#include <iomanip>\n#include <sstream>\n#include <cctype>\n#include <fstream>\n#include <cmath>\nusing namespace std;\n\n#define REP2(i, m, n) for(int i = (int)(m); i < (int)(n); i++)\n#define REP(i, n) REP2(i, 0, n)\n#define ALL(c) (c).begin(), (c).end()\n#define ITER(c) __typeof((c).begin())\n#define PB(e) push_back(e)\n#define FOREACH(i, c) for(ITER(c) i = (c).begin(); i != (c).end(); ++i)\n#define MP(a, b) make_pair(a, b)\n#define PARITY(n) ((n) & 1)\n\ntypedef long long ll;\ntypedef pair<ll, ll> P;\nconst int INF = 1000 * 1000 * 1000 + 7;\nconst double EPS = 1e-10;\n\nbool exp(const string &str, size_t &cur, map<char, bool> &J){\n  char ch = str[cur++];\n  if(ch == 'T' || ch == 'F'){\n    return ch == 'T';\n  }\n  \n  if(isalpha(ch)){\n    return J[ch];\n  }\n\n  \n  if(ch == '-'){\n    return !exp(str, cur, J);\n  }\n\n  assert(ch == '(');\n  bool b1 = exp(str, cur, J);\n  char op = str[cur++];\n  if(op == '-') cur++;\n  bool b2 = exp(str, cur, J);\n  if(op == '*') b1 = b1 && b2;\n  if(op == '+') b1 = b1 || b2;\n  if(op == '-') b1 = !b1 || b2;\n  cur++;\n  return b1;\n  return b1;\n}\n\nbool eval(string str, map<char, bool> &J){\n  size_t cur = 0;\n  return exp(str, cur, J);\n}\n\nint main(){\n  string str;\n  while(cin >> str && str != \"#\"){\n    int ind = str.find(\"=\");\n    string str1 = str.substr(0, ind);\n    string str2 = str.substr(ind + 1);\n\n    bool valid = true;\n    REP(mask, 1 << 12){\n      map<char, bool> J;\n      REP(j, 12) J['a' + j] = PARITY(mask >> j);\n      valid &= eval(str1, J) == eval(str2, J);\n    }\n    cout << (valid ? \"YES\" : \"NO\") << endl;\n  }\n  return 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include<bits/stdc++.h>\nusing namespace std;\n\nstring s;\nint p;\n\nint equation();\nint formula();\n\n//1:true 0:false\nint equation(){\n  int a=formula();\n  if(s[p]=='=')p++;//'='\n  int b=formula();\n  //cout<<\"a \"<<a<<\" b \"<<b<<endl;\n  if(a==b && a!=-1)return 1;\n  else return 0;\n}\n\n//1:true 0:false -1:?????°\nint formula(){\n  if(s[p]=='-'){\n    p++;//'-'\n    int a=formula();\n    if(a==1)return 0;\n    else return 1;\n  }\n  else if(s[p]=='('){\n    p++;//'('\n    int a=formula();\n    char tmp=s[p];//?????????\n    p++;//'*', '+', '->'\n    if(s[p]=='>')p++;//'->'\n    int b=formula();\n    p++;//')'\n\n    if(tmp=='*'){\n      if(a==b && a==1)return 1;\n      else return 0;\n    }\n    else if(tmp=='+'){\n      if(a==1 || b==1)return 1;\n      else return 0;\n    }\n    else{\n      if(a==1 && b==0)return 0;\n      else return 1;\n    }\n  }\n  else{\n    if(s[p]=='T'){p++; return 1;}\n    else if(s[p]=='F'){p++; return 0;}\n    else{p++; return -1;}//?????°\n  }\n}\n\n\nint main(){\n  while(cin>>s, s!=\"#\"){\n    p=0;\n    if(equation())cout<<\"YES\"<<endl;\n    else cout<<\"NO\"<<endl;\n  }\n  return 0;\n}"
  },
  {
    "language": "C++",
    "code": "#define _USE_MATH_DEFINES\n#define INF 0x3f3f3f3f\n\n#include <iostream>\n#include <cstdio>\n#include <sstream>\n#include <cmath>\n#include <cstdlib>\n#include <algorithm>\n#include <queue>\n#include <stack>\n#include <limits>\n#include <map>\n#include <string>\n#include <cstring>\n#include <set>\n#include <deque>\n#include <bitset>\n#include <list>\n#include <cctype>\n#include <utility>\n  \nusing namespace std;\n  \ntypedef long long ll;\ntypedef pair <int,int> P;\ntypedef pair <int,P> PP;\n  \nstatic const double EPS = 1e-8;\n  \nstatic const int tx[] = {0,1,0,-1};\nstatic const int ty[] = {-1,0,1,0};\n\nstruct ParseInfo {\n  int pos;\n  bool val;\n};\n\nset<char> char_set;\nbool char_table[256];\n\nParseInfo parse_formula(int pos, const string& str){\n\n  if('a' <= str[pos] && str[pos] <= 'k'){\n    bool val = char_table[str[pos]];\n    ParseInfo pi = {pos+1,val};\n    return pi;\n  }\n\n  else if(str[pos] == 'T'){\n    bool val = true;\n    ParseInfo pi = {pos+1,val};\n    return pi;\n  }\n\n  else if(str[pos] == 'F'){\n    bool val = false;\n    ParseInfo pi = {pos+1,val};\n    return pi;\n  }\n\n  else if(str[pos] == '-'){\n    ParseInfo pi = parse_formula(pos+1,str);\n    pi.val = ~pi.val;\n    return pi;\n  }\n\n  else if(str[pos] == '('){\n    ParseInfo pi1 = parse_formula(pos+1,str);\n    if(str[pi1.pos] == '*'){\n      ParseInfo pi2 = parse_formula(pi1.pos+1,str);\n      pi2.val = (pi1.val && pi2.val);\n      \n      //skip ')'\n      pi2.pos++;\n      return pi2;\n    }\n    else if(str[pi1.pos] == '+'){\n      ParseInfo pi2 = parse_formula(pi1.pos+1,str);\n      pi2.val = (pi1.val || pi2.val);\n\n      //skip ')'\n      pi2.pos++;\n      return pi2;\n    }\n    else if(str[pi1.pos] == '-'\n\t    && str[pi1.pos+1] == '>'){\n      ParseInfo pi2 = parse_formula(pi1.pos+2,str);\n      pi2.val = (~pi1.val || pi2.val);\n\n      //skip ')'\n      pi2.pos++;\n      return pi2;\n    }\n  }\n}\n\nParseInfo parse_equation(int pos, const string& str){\n  ParseInfo pi1 = parse_formula(pos,str);\n  \n  //skip '='\n  ParseInfo pi2 = parse_formula(pi1.pos+1,str);\n  pi2.val = (pi1.val == pi2.val) ? true : false;\n  return pi2;\n}\n\n\nint main(){\n  string str;\n  while(cin >> str){\n    if(str == \"#\") break;\n\n\n    for(int i=0;i<str.size();i++){\n      if('a' <= str[i] && str[i] <= 'k'){\n\tchar_set.insert(str[i]);\n      }\n    }\n\n\n    bool isok = true;\n    for(int S=0;S<=(1<<char_set.size())-1;S++){\n      int idx = 0;\n      for(set<char>::iterator it = char_set.begin();\n\t  it != char_set.end();\n\t  it++){\n\tchar_table[*it] = (S & (1<<idx));\n\tidx++;\n      }\n      ParseInfo pi = parse_equation(0,str);\n      if(!pi.val) isok = false;\n    }\n    printf(\"%s\\n\",isok ? \"YES\" : \"NO\");\n  }\n}"
  },
  {
    "language": "C++",
    "code": "// clang-format off\n#include <bits/stdc++.h>\n#define int long long\n#define main signed main()\n#define loop(i, a, n) for (int i = (a); i < (n); i++)\n#define rep(i, n) loop(i, 0, n)\n#define forever for (;;)\n#define all(v) (v).begin(), (v).end()\n#define rall(v) (v).rbegin(), (v).rend()\n#define prec(n) fixed << setprecision(n)\ntemplate<typename A> using V = std::vector<A>;\ntemplate<typename A> using F = std::function<A>;\ntemplate<typename A, typename B> using P = std::pair<A, B>;\nusing pii = P<int, int>;\nusing vi = V<int>;\nusing vd = V<double>;\nusing vs = V<std::string>;\nusing vpii = V<pii>;\nusing vvi = V<vi>;\nusing vvpii = V<vpii>;\nconstexpr int INF = sizeof(int) == sizeof(long long) ? 1000000000000000000LL : 1000000000;\nconstexpr int MOD = 1000000007;\nconstexpr double PI = acos(-1);\ntemplate<typename A, typename B> bool cmin(A &a, const B &b) { return a > b ? (a = b, true) : false; }\ntemplate<typename A, typename B> bool cmax(A &a, const B &b) { return a < b ? (a = b, true) : false; }\nconstexpr bool odd(const int &n) { return n & 1; }\nconstexpr bool even(const int &n) { return ~n & 1; }\ntemplate<typename T> std::istream &operator>>(std::istream &is, std::vector<T> &v) { for (T &x : v) is >> x; return is; }\ntemplate<typename A, typename B> std::istream &operator>>(std::istream &is, std::pair<A, B> &p) { is >> p.first; is >> p.second; return is; }\nusing namespace std;\n// clang-format on\n\ntemplate<typename T> struct ParseResult {\n  bool succeeded;\n  T object;\n  int pos;\n  ParseResult(const bool succeeded, const T &object, const int pos) : succeeded(succeeded), object(object), pos(pos) {}\n  friend std::ostream &operator<<(std::ostream &os, const ParseResult<T> &p) { return os << '{' << (p.succeeded ? \"true\" : \"false\") << ',' << p.object << ',' << p.pos << '}'; }\n};\n\ntemplate<typename T> using Parser = std::function<ParseResult<T>(std::string, int)>;\n\nParser<std::string> token(const std::string &s) {\n  const int n = s.size();\n  return [n = std::move(n), s = std::move(s)](const std::string &target, const int pos) {\n    if (target.size() < n) return ParseResult<std::string>(false, {}, pos);\n    return target.substr(pos, n) == s ? ParseResult<std::string>(true, s, pos + n) : ParseResult<std::string>(false, {}, pos);\n  };\n}\n\ntemplate<typename T> Parser<T> operator||(const Parser<T> &p1, const Parser<T> &p2) {\n  return [p1 = std::move(p1), p2 = std::move(p2)](const std::string &target, const int pos) {\n    auto r = p1(target, pos);\n    if (r.succeeded) return r;\n    r = p2(target, pos);\n    if (r.succeeded) return r;\n    return ParseResult<T>(false, {}, pos);\n  };\n}\n\ntemplate<typename T1, typename T2> Parser<std::pair<T1, T2>> operator+(const Parser<T1> &p1, const Parser<T2> &p2) {\n  return [p1 = std::move(p1), p2 = std::move(p2)](const std::string &target, const int pos) {\n    auto r1 = p1(target, pos);\n    if (!r1.succeeded) return ParseResult<std::pair<T1, T2>>(false, {}, pos);\n    auto r2 = p2(target, r1.pos);\n    if (!r2.succeeded) return ParseResult<std::pair<T1, T2>>(false, {}, pos);\n    return ParseResult<std::pair<T1, T2>>(true, {r1.object, r2.object}, r2.pos);\n  };\n}\n\ntemplate<typename T1, typename T2> Parser<T2> operator>>(const Parser<T1> &p1, const Parser<T2> &p2) {\n  return [p1 = std::move(p1), p2 = std::move(p2)](const std::string &target, const int pos) {\n    auto r1 = p1(target, pos);\n    if (!r1.succeeded) return ParseResult<T2>(false, {}, pos);\n    auto r2 = p2(target, r1.pos);\n    if (!r2.succeeded) return ParseResult<T2>(false, {}, pos);\n    return ParseResult<T2>(true, r2.object, r2.pos);\n  };\n}\n\ntemplate<typename T1, typename T2> Parser<T1> operator<<(const Parser<T1> &p1, const Parser<T2> &p2) {\n  return [p1 = std::move(p1), p2 = std::move(p2)](const std::string &target, const int pos) {\n    auto r1 = p1(target, pos);\n    if (!r1.succeeded) return ParseResult<T1>(false, {}, pos);\n    auto r2 = p2(target, r1.pos);\n    if (!r2.succeeded) return ParseResult<T1>(false, {}, pos);\n    return ParseResult<T1>(true, r1.object, r2.pos);\n  };\n}\n\nParser<char> oneOf(const std::string &s) {\n  std::unordered_set<char> d;\n  for (auto &c : s) d.insert(c);\n  return [d = std::move(d)](const std::string &target, const int pos) {\n    if (target.size() <= pos) return ParseResult<char>(false, {}, pos);\n    char c = target[pos];\n    return d.count(c) ? ParseResult<char>(true, c, pos + 1) : ParseResult<char>(false, {}, pos);\n  };\n}\n\ntemplate<typename T, typename S, typename F> Parser<S> fmap(const Parser<T> &p, const F &f) {\n  return [p = std::move(p), f = std::move(f)](const std::string &target, const int pos) {\n    auto r = p(target, pos);\n    return r.succeeded ? ParseResult<S>(true, f(r.object), r.pos) : ParseResult<S>(false, {}, r.pos);\n  };\n}\n\ntemplate<typename T, typename F> Parser<T> lazy(const F &f) {\n  bool instantiated = false;\n  Parser<T> p;\n  return [f = std::move(f), p = std::move(p), instantiated = std::move(instantiated)](const std::string &target, const int pos) mutable {\n    if (!instantiated) {\n      p = f();\n      instantiated = true;\n    }\n    return p(target, pos);\n  };\n}\n\nstruct SyntaxTree {\n  string op;\n  char value;\n  vector<SyntaxTree> children;\n  SyntaxTree() {}\n  SyntaxTree(const string &op, const char value, const vector<SyntaxTree> &children) : op(op), value(value), children(children) {}\n};\n\nmain {\n  Parser<SyntaxTree> formulaP = lazy<SyntaxTree>([&]() {\n    auto andP = fmap<pair<SyntaxTree, SyntaxTree>, SyntaxTree>((token(\"(\") >> formulaP << token(\"*\")) + (formulaP << token(\")\")), [](auto &o) { return SyntaxTree(\"*\", {}, {o.first, o.second}); });\n    auto orP = fmap<pair<SyntaxTree, SyntaxTree>, SyntaxTree>((token(\"(\") >> formulaP << token(\"+\")) + (formulaP << token(\")\")), [](auto &o) { return SyntaxTree(\"+\", {}, {o.first, o.second}); });\n    auto impP = fmap<pair<SyntaxTree, SyntaxTree>, SyntaxTree>((token(\"(\") >> formulaP << token(\"->\")) + (formulaP << token(\")\")), [](auto &o) { return SyntaxTree(\"->\", {}, {o.first, o.second}); });\n    auto notP = fmap<SyntaxTree, SyntaxTree>(token(\"-\") >> formulaP, [](auto &o) { return SyntaxTree(\"-\", {}, {o}); });\n    auto valP = fmap<char, SyntaxTree>(oneOf(\"abcdefghijkTF\"), [](char x) { return SyntaxTree({}, x, {}); });\n    return andP || orP || impP || notP || valP;\n  });\n  auto equationP = (formulaP << token(\"=\")) + formulaP;\n  string s;\n  while (cin >> s, s != \"#\") {\n    s = regex_replace(s, regex(\"(--)+\"), \"\");\n    auto r = equationP(s, 0);\n    bool isValid = true;\n    rep(i, 1 << 11) {\n      auto toBool = [&](char c) -> bool {\n        if (c == 'T') return true;\n        if (c == 'F') return false;\n        return i >> (c - 'a') & 1;\n      };\n      F<bool(SyntaxTree)> eval = [&](const SyntaxTree &f) {\n        switch (f.children.size()) {\n          case 0: return toBool(f.value);\n          case 1: return !eval(f.children[0]);\n          case 2:\n            if (f.op == \"*\") return eval(f.children[0]) && eval(f.children[1]);\n            if (f.op == \"+\") return eval(f.children[0]) || eval(f.children[1]);\n            if (f.op == \"->\") return !eval(f.children[0]) || eval(f.children[1]);\n        }\n      };\n      isValid &= eval(r.object.first) == eval(r.object.second);\n    }\n    cout << (isValid ? \"YES\" : \"NO\") << endl;\n  }\n}"
  },
  {
    "language": "C++",
    "code": "#include<cstdio>\n#include<iostream>\n#include<string>\n\nusing namespace std;\n\nstring inp;\nint cnt;\nint val;\n\nbool culc(bool a,char c,bool b){\n\tswitch((char)c){\n\tcase '+':\n\t\treturn a||b;\n\tcase '*':\n\t\treturn a&&b;\n\tcase '>':\n\t\tif(a==false&&b==true) return false;\n\t\telse return true;\n\t}\n}\n\nchar formula2(){\n\tcnt++;\n\tif(inp[cnt]=='>') cnt++;\n\treturn (char)inp[cnt-1];\n}\n\nbool formula(){\n\tbool f;\n\tswitch(inp[cnt]){\n\t  case '-':\n\t\tcnt++;\n\t\tf=formula();\n\t\tif(f==1) f=0;\n\t\telse f=1;\n\t    break;\n\t  case '(':\n\t\tcnt++;\n\t\tf=culc(formula(),formula2(),formula());\n\t\tcnt++;\n\t\tbreak;\n\t  case 'T':\n\t\t  cnt++;\n\t\t  f=true;\n\t\t  break;\n\t  case 'F':\n\t\t  cnt++;\n\t\t  f=false;\n\t\t  break;\n\t  default:\n\t\t  f=(val>>(inp[cnt]-'a'))&&1;\n\t\t  cnt++;\n\t\t  break;\n\t}\n\treturn f;\n}\n\nint main(void){\n\n\tbool left,right;\n\tbool ans;\n\n\twhile(1){\n\t\tcin>>inp;\n\t\tif(inp==\"#\") break;\n\t\tans=true;\n\t\tfor(val=0;val<(1<<11);val++){\n\t\t\tcnt=0;\n\t\t\tleft=formula();\n\t\t\tcnt++;\n\t\t\tright=formula();\n\t\t\tif(left!=right){\n\t\t\t\tans=false;\n\t\t\t\tbreak;\n\t\t\t}\n\t\t}\n\t\tif(ans) cout<<\"YES\"<<endl;\n\t\telse cout<<\"NO\"<<endl;\n\t}\n\n\treturn 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include<iostream>\n#include<algorithm>\n#include<vector>\n#include<string>\nusing namespace std;\ntypedef pair<int,int> pii;\ntypedef pair<int,pii> pip;\n#define pb(i) push_back(i)\n#define fs first\n#define sc second\n#define X first\n#define Y second\n\n#include<algorithm>\n#include<functional>\n#define all(X) X.begin(),X.end()\n#define rep(X,Y) for(int X=0;(X)<(Y);++(X))\n\nusing namespace std;\n\ntypedef vector<vector<int>> vvi;\ntypedef pair<int,int> pii;\n\ntemplate<class T,class S> ostream& operator<<(ostream &os,pair<T,S> &p){\n  cout<<\"(\"<<p.X<<\",\"<<p.Y<<\")\";\n  return os;\n}\n\nint val;\n\nint var(char c){ return val>>(c-'a')&1;}\n\npii eval(string &str,int pos=0){\n  pii re;\n  if(str[pos]=='-'){\n    re=eval(str,pos+1);\n    re.X=1-re.X;\n  }else if(str[pos]=='('){\n    pii l=eval(str,pos+1);\n    if(str[l.Y]=='*'){\n      re=eval(str,l.Y+1);\n      //cout<<l<<re<<endl;\n      re.X&=l.X;\n    }else if(str[l.Y]=='+'){\n      re=eval(str,l.Y+1);\n      re.X|=l.X;\n    }else{\n      re=eval(str,l.Y+2);\n      re.X|=1-l.X;\n    }\n    ++re.Y;\n  }else{\n    re.X=var(str[pos]);\n    re.Y=pos+1;\n  }\n  //cout<<str<<\":\"<<re.X<<\",\"<<re.Y<<endl;\n  return re;\n}\n\nint main(){\n  string str;\n  while(cin>>str,str[0]!='#'){\n    int n=str.size();\n    string s,t;\n    rep(i,n)if(str[i]=='='){\n      s=str.substr(0,i);\n      t=str.substr(i+1);\n    }\n    int m='k'-'a'+1,f=1;\n    rep(i,1<<m){\n      val=i;\n      if(eval(s).X!=eval(t).X){\n\t/*cout<<i<<endl;\n\tcout<<s<<\":\"<<eval(s).X<<endl;\n\tcout<<t<<\":\"<<eval(t).X<<endl;*/\n\tf=0;\n\tbreak;\n      }\n    }\n    cout<<(f?\"YES\":\"NO\")<<endl;\n  }\n}"
  },
  {
    "language": "C++",
    "code": "#include <iostream>\n#include <string>\n#include <vector>\n#include <algorithm>\n#include <utility>\nusing namespace std;\n\n#define rep(i,n) for(int i=0; i<n; i++)\n\nint gFlg = 0;\n\nstring parse( string s ) {\n\tif(s[0] == '-') {\n\t\ts = s.substr(1, s.length()-1);\n\t\ts = parse(s);\n\t\tif(s[0]=='T')      s = 'F';\n\t\telse if(s[0]=='F') s = 'T';\n\t}\n\telse if(s[0] == '(') {\n\t\tint cl = 1, op=1;\n\t\tint cntClos = 0;\n\t\twhile(!(cntClos==0 && s[cl]==')')) {\n\t\t\tif( s[cl] == '(' ) cntClos++;\n\t\t\telse if( s[cl] == ')' ) cntClos--;\n\t\t\tcl++;\n\t\t}\n\t\twhile(!(cntClos==0 && (s[op]=='*' || s[op]=='+' || s[op]=='>'))) {\n\t\t\tif( s[op] == '(' ) cntClos++;\n\t\t\telse if( s[op] == ')' ) cntClos--;\n\t\t\top++;\n\t\t}\n\t\tstring s1=s, s2=s;\n\t\tif( s[op] == '>' )  s1 = s1.substr( 1, op-2 );\n\t\telse                s1 = s1.substr( 1, op-1 );\n\t\ts2 = s2.substr( op+1, cl-op-1 );\n\t\ts1 = parse(s1);\n\t\ts2 = parse(s2);\n\t\tif( s[op] == '+' ) {\n\t\t\tif(s1[0]=='F' && s2[0]=='F') s = 'F';\n\t\t\telse s = 'T';\n\t\t}\n\t\telse if( s[op] == '*' ) {\n\t\t\tif(s1[0]=='T' && s2[0]=='T') s = 'T';\n\t\t\telse s = 'F';\n\t\t}\n\t\telse {\n\t\t\tif(s1[0]=='T' && s2[0]=='F') s = 'F';\n\t\t\telse s = 'T';\n\t\t}\n\t}\n\telse if( 'a'<=s[0] && s[0]<='k' ) {\n\t\tbool tf = gFlg & (1<<(s[0]-'a'));\n\t\ts = tf ? 'T' : 'F';\n\t}\n\treturn s;\n}\n\nint main() {\n\tstring in;\n\twhile( cin >> in, in[0]!='#' ) {\n\t\tbool ok = true;\n\t\tfor(int flg=0; flg<(1<<11); flg++) {\n\t\t\tgFlg = flg;\n\t\t\tstring s1=in, s2=in;\n\t\t\tint posEq = 0;\n\t\t\twhile(in[posEq] != '=') posEq++;\n\t\t\ts1 = s1.substr( 0, posEq );\n\t\t\ts2 = s2.substr( posEq+1, s2.length()-posEq-1 );\n\t\t\ts1 = parse(s1);\n\t\t\ts2 = parse(s2);\n\t\t\tif( s1 != s2 ) {\n\t\t\t\tok = false;\n\t\t\t\tbreak;\n\t\t\t}\n\t\t}\n\t\tif(ok) cout << \"YES\" << endl;\n\t\telse   cout << \"NO\"  << endl;\n\t}\n\treturn 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\nusing namespace std;\n\nint vars;\nint pos;\nbool formula(const string& str) {\n  if(str[pos] == 'T') { pos++; return true; }\n  if(str[pos] == 'F') { pos++; return false; }\n  if(isalpha(str[pos])) {\n    return (vars>>(str[pos++]-'a') & 1);\n  }\n  if(str[pos] == '-') {\n    pos ++;\n    return !formula(str);\n  }\n  if(str[pos] == '(') {\n    pos ++;\n    int f = formula(str);\n    bool ret;\n    if(str[pos] == '*') {\n      pos++;\n      ret = formula(str) && f;\n    }\n    else if(str[pos] == '+') {\n      pos++;\n      ret = f || formula(str);\n    }\n    else if(str[pos] == '>') {\n      pos++;\n      ret = f<=formula(str);\n    }\n    pos ++;\n    return ret;\n  }\n}\n\nint main() {\n  string str;\n  while(cin>>str && str!=\"#\") {\n    \n    int arw = str.find(\"->\");\n    while(arw!=(int)string::npos) {\n      str.replace(arw, 2, \">\");\n      arw = str.find(\"->\", arw+1);\n    }\n    \n    int eq = str.find(\"=\");\n    string s = str.substr(0, eq);\n    string t = str.substr(eq+1);\n    bool ok = true;\n    for(vars=0;vars<(1<<11);vars++) {\n      pos = 0; bool fs = formula(s);\n      pos = 0;\n      if(fs != formula(t)) { ok = false; break; }\n    }\n    if(ok) {\n      cout << \"YES\" << endl;\n    }\n    else {\n      cout << \"NO\" << endl;\n    }\n  }\n  return 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\n  \nusing namespace std;\n  \n#define rep(i,n) REP(i,0,n)\n#define REP(i,s,e) for(int i=(s); i<(int)(e); i++)\n#define pb push_back\n#define all(r) r.begin(),r.end()\n#define rall(r) r.rbegin(),r.rend()\n#define fi first\n#define se second\n  \ntypedef long long ll;\ntypedef vector<int> vi;\ntypedef vector<ll> vl;\ntypedef pair<int, int> pii;\ntypedef pair<ll, ll> pll;\n \nconst int INF = 1e9;\nconst ll MOD = 1e9 + 7;\ndouble EPS = 1e-8;\n//#define DEBUG_MODE\n#ifdef DEBUG_MODE\n#define dump(x) cout << #x << \" : \" << x << endl\n#define LINE cout << \"line : \" << __LINE__ << endl\n#define dumpV(v) cout << #v << \" : [\"; for(auto& t : v) cout << t << \", \"; cout<<\"]\" << endl;\n#define STOP assert(false);\n#else\n#define dump(x) ;\n#define LINE \t;\n#define dumpV(v);\n#define STOP \t;\n#endif\n\nnamespace std{\n  template<class S,class T>\n  ostream &operator <<(ostream& out,const pair<S,T>& a){\n    out<<'('<<a.fi<<\", \"<<a.se<<')';\n    return out;\n  }\n}\n\n\nvector<string> split(const string& s, char c = ' ') {\n\tvector<string> ret;\n\tstringstream ss(s);\n\tstring t;\n\twhile(getline(ss, t, c)) ret.push_back(t);\n\treturn ret;\n}\n\nbool num(char c, int mask) {\n\tif(c == 'T') return true;\n\tif(c == 'F') return false;\n\tif(c < 'a' || c > 'z') dump(c);\n\tassert(c>='a' && c<='k');\n\tint p = c - 'a';\n\treturn ((1<<p) & mask);\n}\nbool fomula(const string& s, int mask, int& pos) {\n\tdump(s);\n\tdump(pos);\n\twhile(s[pos] == '(') pos++;\n\tif(s[pos] == '-' && s[pos+1] == '(') return !fomula(s, mask, ++pos);\n\tbool ret;\n\tif(s[pos] == '-') {\n\t\tLINE;\n\t\tret = !num(s[++pos], mask);\n\t\tdump(s[pos]);\n\t}\n\telse {\n\t\tLINE;\n\t\tret = num(s[pos], mask);\t\t\n\t}\n\tpos++;\n\tif(pos == s.size()|| s[pos] == ')') {\n\t\treturn ret;\n\t}\n\tdump(pos);\n\tdump(s.size());\n\tif(s[pos] == '+') return ret|fomula(s, mask, ++pos);\n\tif(s[pos] == '*') {\n\t\tLINE;\n\t\treturn ret&fomula(s, mask, ++pos);\n\t}\n\tif(s[pos] == '-' && s[pos+1] == '>') {\n\t\tpos += 2;\n\t\treturn !(ret && (!fomula(s, mask, pos)));\n\t}\n\tassert(false);\n}\n\nbool f(const string& s, int mask) {\n\tint pos = 0;\n\tbool ret = fomula(s, mask, pos);\n\twhile(pos < s.size()) {\n\t\twhile(pos < s.size() && s[pos] == ')') pos++;\n\t\tif(s[pos] == '+') ret |= fomula(s, mask, ++pos);\n\t\telse if(s[pos] == '*') ret &= fomula(s, mask, ++pos);\n\t\telse if(s[pos] == '-' && s[pos+1] == '>') {\n\t\t\tpos += 2;\n\t\t\tret = (!(ret && (!fomula(s, mask, pos))));\n\t\t}\n\t\tpos++;\n\t}\n\treturn ret;\n}\n\nint main(){\n\tstring s;\n\twhile(cin >> s) {\n\t\tif(s == \"#\") break;\n\t\tauto v = split(s, '=');\n\t\tbool ans = true;\n\t\trep(mask, 1<<11) {\n\t\t\tif(f(v[1], mask) != f(v[0], mask)) {\n\t\t\t\tdump(mask);\n\t\t\t\tans = false;\n\t\t\t}\n\t\t}\n\t\tcout << (ans ? \"YES\" : \"NO\") << endl;\n\t\tSTOP;\n\t\t// dump(f(v[0], 0));\n\t\t// dump(f(v[1], 0));\n\t}\n\treturn 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include <cstdio>\n#include <cstdlib>\n#include <cstring>\n#include <cmath>\n#include <climits>\n#include <cfloat>\n#include <ctime>\n#include <cassert>\n#include <map>\n#include <utility>\n#include <set>\n#include <iostream>\n#include <memory>\n#include <string>\n#include <vector>\n#include <algorithm>\n#include <functional>\n#include <sstream>\n#include <complex>\n#include <stack>\n#include <queue>\n#include <numeric>\n#include <list>\n#include <iomanip>\n \nusing namespace std;\n \n#if __GNUC__\n#include <tr1/unordered_map>\n#include <tr1/unordered_set>\nusing namespace tr1;\n#else\n#include <unordered_map>\n#include <unordered_set>\n#endif\n \n \n \n#ifdef _MSC_VER\n#define __typeof__ decltype\ntemplate <class T> int popcount(T n) { return n ? 1 + popcount(n & (n - 1)) : 0; }\n#endif\n#ifdef __GNUC__\ntemplate <class T> int popcount(T n);\ntemplate <> int popcount(unsigned int n) { return __builtin_popcount(n); }\ntemplate <> int popcount(int n) { return __builtin_popcount(n); }\ntemplate <> int popcount(unsigned long long n) { return __builtin_popcountll(n); }\ntemplate <> int popcount(long long n) { return __builtin_popcountll(n); }\n#endif\n \n#define rep (i, n) for (int i = 0; i < (int)n; ++i)\n#define foreach(it, c) for (__typeof__((c).begin()) it=(c).begin(); it != (c).end(); ++it)\n#define rforeach(it, c) for (__typeof__((c).rbegin()) it=(c).rbegin(); it != (c).rend(); ++it)\n#define all(c) (c).begin(), (c).end()\n#define rall(c) (c).rbegin(), (c).rend()\n#define CL(arr, val) memset(arr, val, sizeof(arr))\n#define MEMCPY(dest, src) memcpy(dest, src, sizeof(src))\n \n \ntemplate <class T> void max_swap(T& a, const T& b) { a = max(a, b); }\ntemplate <class T> void min_swap(T& a, const T& b) { a = min(a, b); }\n \ntypedef long long ll;\ntypedef pair<int, int> pint;\n \ntemplate <class T> string to_s(const T& a) { ostringstream os; os << a; return os.str(); }\n \nconst double EPS = 1e-8;\nconst double PI = acos(-1.0);\nconst int dx[] = { 0, 1, 0, -1 };\nconst int dy[] = { 1, 0, -1, 0 };\nbool valid_pos(int x, int y, int w, int h) { return 0 <= x && x < w && 0 <= y && y < h; }\n \ntemplate <class T> void print(T a, int n, int br = 1, const string& deli = \", \") { cout << \"{ \"; for (int i = 0; i < n; ++i) { cout << a[i]; if (i + 1 != n) cout << deli; } cout << \" }\"; while (br--) cout << endl; }\ntemplate <class T> void print(const vector<T>& v, int br = 1, const string& deli = \", \") { print(v, v.size(), br, deli); }\ntemplate <class T> void print2d(T a, int w, int h, int width = -1, int br = 1) { for (int i = 0; i < h; ++i) { for (int j = 0; j < w; ++j) {\tif (width != -1) cout.width(width); cout << a[i][j] << ' ';\t} cout << endl; } while (br--) cout << endl; }\n \ntemplate <class T> void input(int n, T& a) { for (int i = 0; i < n; ++i) cin >> a[i]; }\ntemplate <class T, class U> void input(int n, T& a, U& b) { for (int i = 0; i < n; ++i) cin >> a[i] >> b[i]; }\ntemplate <class T> vector<T> input(int n) { vector<T> res(n); for (int i = 0; i < n; ++i) cin >> res[i]; return res; }\n\n\n\n\nvector<string> split(string str, const string& deli_chars)\n{\n\tfor (int i = 0; i < str.size(); ++i)\n\t\tif (deli_chars.find(str[i]) != string::npos)\n\t\t\tstr[i] = ' ';\n\tstringstream ss(str);\n\tvector<string> res;\n\tfor (string s; ss >> s; )\n\t\tres.push_back(s);\n\treturn res;\n}\n\nbool val[256];\nbool formula(const string& s, int& p)\n{\n\tif (s[p] == '-')\n\t\treturn !formula(s, ++p);\n\telse if (isalpha(s[p]))\n\t\treturn val[s[p++]];\n\telse\n\t{\n\t\t++p;\n\n\t\tbool left = formula(s, p);\n\n\n\t\tstatic const char* ops = \"*+-\";\n\t\tint op = strchr(ops, s[p]) - ops;\n\n\t\tp += op == 2 ? 2 : 1;\n\n\n\t\tbool right = formula(s, p);\n\n\t\t++p;\n\n\t\tif (op == 0)\n\t\t\treturn left & right;\n\t\telse if (op == 1)\n\t\t\treturn left | right;\n\t\telse\n\t\t\treturn !(left && !right);\n\t}\n}\nint main()\n{\n\tval['T'] = true;\n\tval['F'] = false;\n\n\tstring line;\n\twhile (cin >> line, line != \"#\")\n\t{\n\t\tvector<string> spl = split(line, \"=\");\n\n\t\tbool yes = true;\n\t\tconst int vals = 11;\n\t\tfor (int i = 0; i < 1 << vals && yes; ++i)\n\t\t{\n\t\t\tfor (int j = 0; j < vals; ++j)\n\t\t\t\tval['a' + j] = (i >> j & 1);\n\n\t\t\tint a = 0, b = 0;\n\t\t\tif (formula(spl[0], a) != formula(spl[1], b))\n\t\t\t\tyes = false;\n\t\t}\n\n\t\tputs(yes ? \"YES\" : \"NO\");\n\t}\n}"
  },
  {
    "language": "C++",
    "code": "#include<iostream>\n#include<string>\n#include<algorithm>\nusing namespace std;\nchar s1(char g1, char g2) { if (g1 == 'T' && g2 == 'T')return 'T'; return 'F'; }\nchar s2(char g1, char g2) { if (g1 == 'F' && g2 == 'F')return 'F'; return 'T'; }\nchar s3(char g1, char g2) { if (g1 == 'T' && g2 == 'F')return 'F'; return 'T'; }\nchar solve(string S) {\n\tint T = 0; string U = \"\";\n\twhile (T < S.size() && S[T] == '-') { T++; U += \"-\"; }\n\tint depth = 0, minx = 99999;\n\tfor (int i = 1; i < S.size() - 1; i++) {\n\t\tif (S[i] == '(')depth++;\n\t\telse if (S[i] == ')')depth--;\n\t\telse { minx = min(minx, depth); }\n\t\tif (depth == 1) {\n\t\t\tstring R1 = S.substr(T + 1, i - 1);\n\t\t\tstring R2 = S.substr(i + 1, S.size() - i - 2);\n\t\t\tif (S[i] == '*')return solve(U + s1(solve(R1), solve(R2)));\n\t\t\tif (S[i] == '+')return solve(U + s2(solve(R1), solve(R2)));\n\t\t\tif (S[i] == '>')return solve(U + s3(solve(R1.substr(0, R1.size() - 1)), solve(R2)));\n\t\t}\n\t}\n\n\tif (T % 2 == 1) { if (S[T] == 'T')S[T] = 'F'; else S[T] = 'T'; }\n\treturn S[T];\n}\nint main() {\n\twhile (true) {\n\t\tbool OK = true;\n\t\tstring U, V1, V2; cin >> U; char R[3] = \"FT\"; if (U == \"#\")break;\n\t\tfor (int i = 0; i < U.size(); i++) {\n\t\t\tif (U[i] == '=') { V1 = U.substr(0, i); V2 = U.substr(i + 1, U.size() - i - 1); }\n\t\t}\n\t\tfor (int i = 0; i < (1 << 11); i++) {\n\t\t\tstring Y1 = V1, Y2 = V2; int bit[11];\n\t\t\tfor (int j = 0; j < 11; j++) { bit[j] = (i / (1 << j)) % 2; }\n\t\t\tfor (int j = 0; j < Y1.size(); j++) {\n\t\t\t\tif (Y1[j] >= 'a' && Y1[j] <= 'k') { Y1[j] = R[bit[Y1[j] - 'a']]; }\n\t\t\t}\n\t\t\tfor (int j = 0; j < Y2.size(); j++) {\n\t\t\t\tif (Y2[j] >= 'a' && Y2[j] <= 'k') { Y2[j] = R[bit[Y2[j] - 'a']]; }\n\t\t\t}\n\t\t\tif (solve(Y1) != solve(Y2)) {\n\t\t\t\tOK = false;\n\t\t\t}\n\t\t}\n\t\tif (OK == true)cout << \"YES\" << endl;\n\t\telse cout << \"NO\" << endl;\n\t}\n\treturn 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include <functional>\n#include <iostream>\n#include <string>\n#include <unordered_set>\n#include <vector>\n#define loop(i, a, n) for (int i = (a); i < (n); i++)\n#define rep(i, n) loop(i, 0, n)\ntemplate<typename A> using F = std::function<A>;\nusing namespace std;\n\ntemplate<typename T> struct ParseResult {\n  bool succeeded;\n  T object;\n  int pos;\n  ParseResult(const bool succeeded, const T &object, const int pos) : succeeded(succeeded), object(object), pos(pos) {}\n  friend std::ostream &operator<<(std::ostream &os, const ParseResult<T> &p) { return os << '{' << (p.succeeded ? \"true\" : \"false\") << ',' << p.object << ',' << p.pos << '}'; }\n};\n\ntemplate<typename T> using Parser = std::function<ParseResult<T>(std::string, int)>;\n\nParser<std::string> token(const std::string &s) {\n  const int n = s.size();\n  return [n = std::move(n), s = std::move(s)](const std::string &target, const int pos) {\n    if (target.size() < n) return ParseResult<std::string>(false, {}, pos);\n    return target.substr(pos, n) == s ? ParseResult<std::string>(true, s, pos + n) : ParseResult<std::string>(false, {}, pos);\n  };\n}\n\ntemplate<typename T> Parser<T> operator||(const Parser<T> &p1, const Parser<T> &p2) {\n  return [p1 = std::move(p1), p2 = std::move(p2)](const std::string &target, const int pos) {\n    auto r = p1(target, pos);\n    if (r.succeeded) return r;\n    r = p2(target, pos);\n    if (r.succeeded) return r;\n    return ParseResult<T>(false, {}, pos);\n  };\n}\n\ntemplate<typename T1, typename T2> Parser<std::pair<T1, T2>> operator+(const Parser<T1> &p1, const Parser<T2> &p2) {\n  return [p1 = std::move(p1), p2 = std::move(p2)](const std::string &target, const int pos) {\n    auto r1 = p1(target, pos);\n    if (!r1.succeeded) return ParseResult<std::pair<T1, T2>>(false, {}, pos);\n    auto r2 = p2(target, r1.pos);\n    if (!r2.succeeded) return ParseResult<std::pair<T1, T2>>(false, {}, pos);\n    return ParseResult<std::pair<T1, T2>>(true, {r1.object, r2.object}, r2.pos);\n  };\n}\n\ntemplate<typename T1, typename T2> Parser<T2> operator>>(const Parser<T1> &p1, const Parser<T2> &p2) {\n  return [p1 = std::move(p1), p2 = std::move(p2)](const std::string &target, const int pos) {\n    auto r1 = p1(target, pos);\n    if (!r1.succeeded) return ParseResult<T2>(false, {}, pos);\n    auto r2 = p2(target, r1.pos);\n    if (!r2.succeeded) return ParseResult<T2>(false, {}, pos);\n    return ParseResult<T2>(true, r2.object, r2.pos);\n  };\n}\n\ntemplate<typename T1, typename T2> Parser<T1> operator<<(const Parser<T1> &p1, const Parser<T2> &p2) {\n  return [p1 = std::move(p1), p2 = std::move(p2)](const std::string &target, const int pos) {\n    auto r1 = p1(target, pos);\n    if (!r1.succeeded) return ParseResult<T1>(false, {}, pos);\n    auto r2 = p2(target, r1.pos);\n    if (!r2.succeeded) return ParseResult<T1>(false, {}, pos);\n    return ParseResult<T1>(true, r1.object, r2.pos);\n  };\n}\n\nParser<char> oneOf(const std::string &s) {\n  std::unordered_set<char> d;\n  for (auto &c : s) d.insert(c);\n  return [d = std::move(d)](const std::string &target, const int pos) {\n    if (target.size() <= pos) return ParseResult<char>(false, {}, pos);\n    char c = target[pos];\n    return d.count(c) ? ParseResult<char>(true, c, pos + 1) : ParseResult<char>(false, {}, pos);\n  };\n}\n\ntemplate<typename T, typename S, typename F> Parser<S> fmap(const Parser<T> &p, const F &f) {\n  return [p = std::move(p), f = std::move(f)](const std::string &target, const int pos) {\n    auto r = p(target, pos);\n    return r.succeeded ? ParseResult<S>(true, f(r.object), r.pos) : ParseResult<S>(false, {}, r.pos);\n  };\n}\n\ntemplate<typename T, typename F> Parser<T> lazy(const F &f) {\n  bool instantiated = false;\n  Parser<T> p;\n  return [f = std::move(f), p = std::move(p), instantiated = std::move(instantiated)](const std::string &target, const int pos) mutable {\n    if (!instantiated) {\n      p = f();\n      instantiated = true;\n    }\n    return p(target, pos);\n  };\n}\n\nstruct SyntaxTree {\n  string op;\n  char value;\n  vector<SyntaxTree> children;\n  SyntaxTree() {}\n  SyntaxTree(const string &op, const char value, const vector<SyntaxTree> &children) : op(op), value(value), children(children) {}\n};\n\nint main() {\n  Parser<SyntaxTree> formulaP = lazy<SyntaxTree>([&]() {\n    auto andP = fmap<pair<SyntaxTree, SyntaxTree>, SyntaxTree>((token(\"(\") >> formulaP << token(\"*\")) + (formulaP << token(\")\")), [](auto &o) { return SyntaxTree(\"*\", {}, {o.first, o.second}); });\n    auto orP = fmap<pair<SyntaxTree, SyntaxTree>, SyntaxTree>((token(\"(\") >> formulaP << token(\"+\")) + (formulaP << token(\")\")), [](auto &o) { return SyntaxTree(\"+\", {}, {o.first, o.second}); });\n    auto impP = fmap<pair<SyntaxTree, SyntaxTree>, SyntaxTree>((token(\"(\") >> formulaP << token(\"->\")) + (formulaP << token(\")\")), [](auto &o) { return SyntaxTree(\"->\", {}, {o.first, o.second}); });\n    auto notP = fmap<SyntaxTree, SyntaxTree>(token(\"-\") >> formulaP, [](auto &o) { return SyntaxTree(\"-\", {}, {o}); });\n    auto valP = fmap<char, SyntaxTree>(oneOf(\"abcdefghijkTF\"), [](char x) { return SyntaxTree({}, x, {}); });\n    return andP || orP || impP || notP || valP;\n  });\n  auto equationP = (formulaP << token(\"=\")) + formulaP;\n  string s;\n  while (cin >> s, s != \"#\") {\n    /*\n    auto r = equationP(s, 0);\n    bool isValid = true;\n    rep(i, 1 << 11) {\n      auto toBool = [&](char c) -> bool {\n        if (c == 'T') return true;\n        if (c == 'F') return false;\n        return i >> (c - 'a') & 1;\n      };\n      F<bool(SyntaxTree)> evalF = [&](const SyntaxTree &f) {\n        switch (f.children.size()) {\n          case 0: return toBool(f.value);\n          case 1: return !evalF(f.children[0]);\n          case 2:\n            if (f.op == \"*\") return evalF(f.children[0]) && evalF(f.children[1]);\n            if (f.op == \"+\") return evalF(f.children[0]) || evalF(f.children[1]);\n            if (f.op == \"->\") return !evalF(f.children[0]) || evalF(f.children[1]);\n        }\n      };\n      isValid &= evalF(r.object.first) == evalF(r.object.second);\n    }\n    cout << (isValid ? \"YES\" : \"NO\") << endl;\n    */\n  }\n}"
  },
  {
    "language": "C++",
    "code": "#include <iostream>\n#include <vector>\n#include <cstdlib>\nusing namespace std;\n\nint n;\nstring str;\n\nbool parser(int ch)\n{\n\tbool a, b;\n\tswitch (str[n]) {\n\tcase 'a':\n\tcase 'b':\n\tcase 'c':\n\tcase 'd':\n\tcase 'e':\n\tcase 'f':\n\tcase 'g':\n\tcase 'h':\n\tcase 'i':\n\tcase 'j':\n\tcase 'k':\n\t\treturn (ch >> (str[n++] - 'a')) & 1;\n\tcase '(':\n\t\tn++;\n\t\ta = parser(ch);\n\t\tif (str[n] == '+') {\n\t\t\tn++;\n\t\t\tb = parser(ch);\n\t\t\tn++;\n\t\t\treturn a||b;\n\t\t}\n\t\telse if(str[n] == '*') {\n\t\t\tn++;\n\t\t\tb = parser(ch);\n\t\t\tn++;\n\t\t\treturn a&&b;\n\t\t}\n\t\telse {\n\t\t\tn++;\n\t\t\tn++;\n\t\t\tb = parser(ch);\n\t\t\tn++;\n\t\t\tif (a == true){\n\t\t\t\tif (b == true)\n\t\t\t\t\treturn true;\n\t\t\t\telse\n\t\t\t\t\treturn false;\n\t\t\t}\n\t\t\telse\n\t\t\t\treturn true;\n\t\t}\n\t\tbreak;\n\tcase '-':\n\t\tn++;\n\t\treturn !parser(ch);\n\t\tbreak;\n\tcase 'T':\n\t\tn++;\n\t\treturn true;\n\tcase 'F':\n\t\tn++;\n\t\treturn false;\n\tdefault :\n\t\texit(EXIT_FAILURE);\n\t}\n}\n\nint main()\n{\n\twhile (cin >> str, str != \"#\") {\n\t\tbool res = true;\n\t\tfor (int i = 0; i < 0x800; i++) {\n\t\t\tn = 0;\n\t\t\tbool p1 = parser(i);\n\t\t\tn++;\n\t\t\tif (p1 != parser(i)) {\n\t\t\t\tres = false;\n\t\t\t\tbreak;\n\t\t\t}\n\t\t}\n\t\tif (res)\n\t\t\tcout << \"YES\" << endl;\n\t\telse\n\t\t\tcout << \"NO\" << endl;\n\t}\n\treturn 0;\n}"
  },
  {
    "language": "C++",
    "code": "// g++ -std=c++11 a.cpp\n#include<iostream>\n#include<vector>\n#include<string>\n#include<algorithm>\t\n#include<map>\n#include<set>\n#include<utility>\n#include<cmath>\n#include<cstring>\n#include<queue>\n#include<stack>\n#include<bitset>\n#include<cstdio>\n#include<sstream>\n#include<iomanip>\n#include<assert.h>\n#include<typeinfo>\n#define loop(i,a,b) for(int i=a;i<b;i++) \n#define rep(i,a) loop(i,0,a)\n#define pb push_back\n#define all(in) in.begin(),in.end()\n#define shosu(x) fixed<<setprecision(x)\nusing namespace std;\n//kaewasuretyuui\ntypedef long long ll;\n//#define int ll\ntypedef int Def;\ntypedef pair<Def,Def> pii;\ntypedef vector<Def> vi;\ntypedef vector<vi> vvi;\ntypedef vector<pii> vp;\ntypedef vector<vp> vvp;\ntypedef vector<string> vs;\ntypedef vector<double> vd;\ntypedef vector<vd> vvd;\ntypedef pair<Def,pii> pip;\ntypedef vector<pip>vip;\n// #define mt make_tuple\n//typedef tuple<pii,int,int> tp;\n//typedef vector<tp> vt;\ntemplate<typename A,typename B>bool cmin(A &a,const B &b){return a>b?(a=b,true):false;}\ntemplate<typename A,typename B>bool cmax(A &a,const B &b){return a<b?(a=b,true):false;}\n//template<class C>constexpr int size(const C &c){return (int)c.size();}\n//template<class T,size_t N> constexpr int size(const T (&xs)[N])noexcept{return (int)N;}\nconst double PI=acos(-1);\nconst double EPS=1e-7;\nDef inf = sizeof(Def) == sizeof(long long) ? 2e18 : 1e9;\nint dx[]={0,1,0,-1};\nint dy[]={1,0,-1,0};\ntypedef string::const_iterator State;\nint q;\nDef formula(State &i,bool h){\n//\tcout<<*i<<\" \"<<h<<endl;\n\tDef out;\n\tif(*i=='('){\n\t\ti++;\n\t\tout=formula(i,0);\n\t}else if(*i=='T')out=1;\n\telse if(*i=='F')out=0;\n\telse if(*i=='-')out=1-formula(++i,1);\n\telse if(isalpha(*i))out=(q>>(*i-'a'))&1;\n\tif(h)return out;\n\ti++;\n\tint op=0;\n\tif(*i=='+')op=1;\n\tif(*i=='-'){op=2;i++;}\n\tif(*i=='*')op=3;\n\tif(op){\n\t\ti++;\n\t\tDef out1=formula(i,0);\n\t\tif(op==1)out|=out1;\n\t\tif(op==2)out=!out||out&&out1;\n\t\tif(op==3)out&=out1;\n\t}\n\treturn out;\n}\nint main(){\n\tstring s,t;\n\twhile(1){\n\t\tgetline(cin,s);\n\t\tif(s==\"#\")break;\n\t\trep(i,s.size())if(s[i]=='='){\n\t\t\tt=s.substr(i+1);\n\t\t\ts=s.substr(0,i);\n\t\t}\n\t\tbool h=true;\n\t\trep(i,1<<11){\n\t\t\tq=i;\n\t\t\tState S=s.begin(),T=t.begin();\n\t\t\tint ss=formula(S,0);\n\t\t\tint tt=formula(T,0);\n//\t\t\tcout<<ss<<\" \"<<tt<<endl;\n\t\t\tif(ss!=tt){\n\t\t\t\th=false;\n\t\t\t\tbreak;\n\t\t\t}\n\t\t}\n\t\tif(h)cout<<\"YES\"<<endl;\n\t\telse cout<<\"NO\"<<endl;\n\t}\n}"
  },
  {
    "language": "C++",
    "code": "#include <cstdio>\n#include <iostream>\n#include <sstream>\n#include <iomanip>\n#include <algorithm>\n#include <cmath>\n#include <string>\n#include <vector>\n#include <list>\n#include <queue>\n#include <stack>\n#include <set>\n#include <map>\n#include <bitset>\n#include <numeric>\n#include <climits>\n#include <cfloat>\nusing namespace std;\n\nbitset<11> bs;\n\nbool solve(const string& s, int a, int b)\n{\n    if(s[a] == '-')\n        return !solve(s, a+1, b);\n    if(s[a] == 'T')\n        return true;\n    else if(s[a] == 'F')\n        return false;\n    else if(isalpha(s[a])) \n        return bs[s[a] - 'a'];\n\n    int i = a+1;\n    int bracket = 0;\n    while(bracket != 0 || (s[i] != '*' && s[i] != '+' && s.substr(i, 2) != \"->\")){\n        if(s[i] == '(')\n            ++ bracket;\n        else if(s[i] == ')')\n            -- bracket;\n        ++ i;\n    }\n\n    if(s[i] == '*')\n        return solve(s, a+1, i-1) && solve(s, i+1, b-1);\n    else if(s[i] == '+')\n        return solve(s, a+1, i-1) || solve(s, i+1, b-1);\n    else\n        return !solve(s, a+1, i-1) || solve(s, i+2, b-1);\n}\n\nint main()\n{\n    for(;;){\n        string s;\n        cin >> s;\n        if(s == \"#\")\n            return 0;\n\n        int j = s.find('=');\n        bool ret = true;\n        for(int i=0; i<(1<<11); ++i){\n            bs = i;\n            if(solve(s, 0, j-1) != solve(s, j+1, s.size()-1))\n                ret = false;\n        }\n\n        if(ret)\n            cout << \"YES\" << endl;\n        else\n            cout << \"NO\" << endl;\n    }\n}"
  },
  {
    "language": "C++",
    "code": "#include <iostream>\n#include <stdio.h>\n#include <algorithm>\n#include <vector>\n#include <queue>\n#include <numeric>\n#include <string>\n#include <string.h>\n#include <map>\n#include <set>\n#include <functional>\n#include <complex>\n#include <stack>\n#include <tuple>\n\n#define ll long long int\n\nusing namespace std;\n\nconst int INF = (1<<30) - 1;\n\nbool formula(string &str, int &vals, int b, int e){\n    char c = str[b];\n    \n    if(c == 'T')\n        return true;\n    else if(c == 'F')\n        return false;\n    \n    if('a'<=c && c<='k')\n        return vals>>(c-'a')&1;\n    \n    if(c == '-')\n        return !formula(str, vals, b+1, e);\n\n    //c == '('\n    int count = 0;\n    for(int i=b+1; i<e; i++){\n        char c = str[i];\n        \n        if(c == '(')\n            count++;\n        if(c == ')')\n            count--;\n        if(count == 0){\n            if(c == '*')\n                return formula(str, vals, b+1, i) & formula(str, vals, i+1, e-1);\n            if(c == '+')\n                return formula(str, vals, b+1, i) | formula(str, vals, i+1, e-1);\n            if(str[i] == '-' && str[i+1] == '>')\n                return !formula(str, vals, b+1, i) | formula(str, vals, i+2, e-1);\n        }\n    }\n    //No Implement\n    return true;\n}\n\nint main(){\n    ios::sync_with_stdio(false);\n    cin.tie(0);\n    \n    string equation;\n    while(cin>>equation, equation!=\"#\"){\n        int s = equation.find(\"=\");\n        \n        bool is_identity = true;\n        for(int i=0; i<1<<11; i++)\n            is_identity &= formula(equation, i, 0, s)==formula(equation, i, s+1, equation.size());\n        \n        cout << (is_identity ? \"YES\" : \"NO\") << endl;\n    }\n    return 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include <list>\n#include <vector>\n#include <map>\n#include <set>\n#include <stack>\n#include <queue>\n#include <deque>\n#include <algorithm>\n#include <utility>\n#include <functional>\n#include <sstream>\n#include <iostream>\n#include <cstdio>\n#include <cmath>\n#include <cstdlib>\n#include <cctype>\n#include <string>\n#include <cstring>\n#include <ctime>\n#include <climits>\nusing namespace std;\ninline int toInt(string s) { int v; istringstream sin(s); sin >> v; return v;}\ntemplate<class T> inline string toString(T x) { ostringstream sout; sout << x; return sout.str();}\ntypedef vector<int> vi;\ntypedef vector<vi>  vvi;\ntypedef vector<string> vs;\ntypedef pair<int, int> pii;\ntypedef long long ll;\n#define ALL(a) (a).begin(),(a).end()\n#define RALL(a) (a).rbegin(),(a).rend()\n#define EACH(t,i,c) for(t::iretator i=(c).begin(); i!=(c).end(); ++i)\n#define EXIST(s,e) ((s).find(e)!=(s).end())\n#define FOR(i,a,b) for(int i=(a);i<=(b);++i)\n#define REP(i,n) FOR(i,0,(n)-1)\nconst double EPS = 1e-12;\nconst double PI = acos(-1.0);\n\nint pos;\n\nbool parse(string s) {\n\tswitch(s[pos]) {\n\tcase 'T':\n\t\t++pos;\n\t\treturn true;\n\tcase 'F':\n\t\t++pos;\n\t\treturn false;\n\tcase '-':\n\t\t++pos;\n\t\treturn !parse(s);\n\tcase '(':\n\t\t++pos;\n\t\tbool a = parse(s);\n\t\tchar op = s[pos];\n\t\t++pos;\n\t\tif(op == '-')\n\t\t\t++pos;\n\t\tbool b = parse(s);\n\t\t++pos;\n\t\tswitch (op) {\n\t\tcase '*':\n\t\t\treturn a&&b;\n\t\tcase '+':\n\t\t\treturn a||b;\n\t\tcase '-':\n\t\t\treturn !a||b;\n\t\t}\n\t}\n}\n\nint main() {\n\tstring str;\n\twhile(cin >> str, str != \"#\") {\n\t\tset<char> cha;\n\t\tREP(i, str.size()) {\n\t\t\tif(islower(str[i]))\n\t\t\t\tcha.insert(str[i]);\n\t\t}\n\t\tint size = cha.size();\n\n\t\tmap<int, char> m;\n\t\tint count = 0;\n\t\tset<char>::iterator it = cha.begin();\n\t\twhile(it != cha.end()) {\n\t\t\tm[count] = *it;\n\t\t\t++count;\n\t\t\t++it;\n\t\t}\n\n\t\tREP(i, 1<<size) {\n\t\t\tstring s = str;\n\t\t\tREP(j, size) {\n\t\t\t\tif(i&(1<<j)) {\n\t\t\t\t\tREP(k, s.size()) {\n\t\t\t\t\t\tif(s[k] == m[j]) {\n\t\t\t\t\t\t\ts[k] = 'T';\n\t\t\t\t\t\t}\n\t\t\t\t\t}\n\t\t\t\t} else {\n\t\t\t\t\tREP(k, s.size()) {\n\t\t\t\t\t\tif(s[k] == m[j]) {\n\t\t\t\t\t\t\ts[k] = 'F';\n\t\t\t\t\t\t}\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t}\n\t\t\t\t\t\n\t\t\tstring left = s.substr(0, s.find(\"=\"));\n\t\t\tstring right = s.substr(s.find(\"=\")+1, s.size()-1);\n\t\t\t\n\t\t\tpos = 0;\n\t\t\tbool l = parse(left);\n\t\t\tpos = 0;\n\t\t\tbool r = parse(right);\n\t\t\tif(l != r) {\n\t\t\t\tcout << \"NO\" << endl;\n\t\t\t\tgoto next;\n\t\t\t}\n\t\t}\n\n\t\tcout << \"YES\" << endl;\nnext:\n\t\t;\n\t}\n\n\treturn 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\n#define rep(i,n) for(int i=0;i<n;i++)\n#define all(x) (x).begin(),(x).end()\nusing namespace std;\nconst int INF=1145141919,MOD=1e9+7;\nconst long long LINF=8931145141919364364,LMOD=998244353;\n// const int dx[]={1,0,-1,0,1,1,-1,-1},dy[]={0,-1,0,1,1,-1,-1,1};\n\nstruct Parser {\n    using itr = string::const_iterator;\n    itr now;\n    int ans;\n    map<char, bool> mp;\n    const struct ex {\n        vector<char> TFabc;\n        ex() {\n            TFabc.resize(28);\n            TFabc[0] = 'T';\n            TFabc[1] = 'F';\n            for(int i = 0; i < 26; ++i) {\n                TFabc[i + 2] = char('a' + i);\n            }\n        }\n    } ex;\n    // <formula> ::= T | F |\n    //               a | b | c | d | e | f | g | h | i | j | k |\n    //               -<formula> |\n    //               (<formula>*<formula>) | (<formula>+<formula>) | (<formula>-><formula>)\n    Parser(const string &s, const map<char, bool> &mp)\n        : mp(mp)\n        {\n            now = s.begin();\n            ans = formula(now);\n        }\n    bool formula(itr &now) {\n        // <formula> ::= -<formula>\n        if(*now == '-') {\n            next(now, '-');\n            return (not formula(now));\n        }\n        // <formula> ::= (<formula>*<formula>) | (<formula>+<formula>) | (<formula>-><formula>)\n        if(*now == '(') {\n            next(now, '(');\n            bool ret = formula(now);\n            // <formula> ::= (<formula>*<formula>)\n            if(*now == '*') {\n                next(now, '*');\n                ret &= formula(now);\n            }\n            // <formula> ::= (<formula>+<formula>)\n            if(*now == '+') {\n                next(now, '+');\n                ret |= formula(now);\n            }\n            // <formula> ::= (<formula>-><formula>)\n            if(*now == '-') {\n                next(now, '-');\n                next(now, '>');\n                ret = (not ret) | formula(now);\n            }\n            next(now, ')');\n            return ret;\n        }\n        // <formula> ::= T | F | a | b | c | d | e | f | g | h | i | j | k\n        bool ret = mp[*now];\n        next(now, ex.TFabc);\n        return ret;\n    }\n    void next(itr &now, const char expected) {\n        vector<char> req = {expected};\n        next(now, req);\n    }\n    void next(itr &now, const vector<char> &expected) {\n        for(char c: expected){\n            if(*now == c){\n                now++;\n                return;\n            }\n        }\n        // デバッグ用\n        fprintf(stderr, \"Expected: \");\n        for(char c: expected) fprintf(stderr, \"%c\", c);\n        fprintf(stderr, \"\\nGot: %c\\n\", *now);\n        fprintf(stderr, \"Rest: \");\n        while(*now) fprintf(stderr, \"%c\", *now++);\n    }\n};\n\nvoid solve(string &s) {\n    map<char, bool> mp;\n    mp['T'] = true;\n    mp['F'] = false;\n    string s1, s2;\n    for(int i = 0; ; ++i) {\n        if(s[i] == '=') {\n            s1 = s.substr(0, i);\n            s2 = s.substr(i + 1);\n            break;\n        }\n    }\n    for(int i = 0; i < (1 << 11); ++i) {\n        for(int j = 0; j < 11; ++j) {\n            mp['a' + j] = (i >> j) & 1;\n        }\n        Parser parse1(s1, mp);\n        Parser parse2(s2, mp);\n        if(parse1.ans != parse2.ans) {\n            cout << \"NO\" << endl;\n            return;\n        }\n    }\n    cout << \"YES\" <<endl;\n}\n\nint main(){\n    string s;\n    while(cin >> s and s != \"#\") {\n        solve(s);\n    }\n    return 0;\n}\n\n"
  },
  {
    "language": "C++",
    "code": "#include <iostream>\n#include <string>\nusing namespace std;\n\nbool formula(string& s, unsigned int& p)\n{\n  if (s[p] == 'T') {\n    ++p;\n    return true;\n  } else if (s[p] == 'F') {\n    ++p;\n    return false;\n  } else if (s[p] == '-') {\n    ++p;\n    return !formula(s, p);\n  } else if (s[p] == '(') {\n    ++p;\n    bool lhs = formula(s, p);\n    if (s[p] == '*') {\n      ++p;\n      bool rhs = formula(s, p);\n      ++p;\n      return lhs && rhs;\n    } else if (s[p] == '+') {\n      ++p;\n      bool rhs = formula(s, p);\n      ++p;\n      return lhs || rhs;\n    } else {\n      p += 2;\n      bool rhs = formula(s, p);\n      ++p;\n      if (lhs && !rhs)\n\treturn false;\n      return true;\n    }\n  }\n}\n\nbool equation(string& s, unsigned int& p)\n{\n  bool lhs = formula(s, p);\n  ++p;\n  bool rhs = formula(s, p);\n  if (lhs == rhs)\n    return true;\n  return false;\n}\n\nint main()\n{\n  string s;\n  while (cin >> s) {\n    if (s == \"#\")\n      break;\n\n    bool ans = true;\n    for (int S = 0; S < (1 << 11); ++S) {\n      string t = s;\n      for (unsigned int j = 0; j < t.size(); ++j) {\n\tif ('a' <= t[j] && t[j] <= 'k') {\n\t  if (S & (1 << (t[j] - 'a')))\n\t    t[j] = 'T';\n\t  else\n\t    t[j] = 'F';\n\t}\n      }\n      \n      unsigned int p = 0;\n      if (!equation(t, p))\n\tans = false;\n    }\n\n    if (ans)\n      cout << \"YES\" << endl;\n    else\n      cout << \"NO\" << endl;\n  }\n  return 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\n#define int long long\n#define range(i,x,y) i=(x);i<(y);i++\n#define all(x) begin(x),end(x)\n#define lim(x,r,l) (r<=x&&x<l)\ntypedef long long ll;\ntypedef long double ld;\nusing namespace std;\n\nint n;\nbool hs(const string& str, const vector<int>& phi){\n  //cout << \"[\" << str[n] <<\"]\" << endl;\n  if(str[n] == '('){\n    n++;\n    bool l = hs(str, phi);\n    bool r;\n    switch(str[n]){\n      case '*':\n        n++;\n        r = hs(str, phi);\n        assert(str[n] == ')'); n++;\n        return l && r;\n      case '+':\n        n++;\n        r = hs(str, phi);\n        assert(str[n] == ')'); n++;\n        return l || r;\n      case '-':\n        n++; assert(str[n]=='>'); n++;\n        r = hs(str, phi);\n        assert(str[n] == ')'); n++;\n        return (!l) || r;\n    }\n    cout << \"(\" << endl;\n    assert(false);\n  }else if(str[n] == '-'){\n    n++;\n    bool p = hs(str, phi);\n    return !p;\n  }else if(str[n] == 'T'){\n    n++; return 1;\n  }else if(str[n] == 'F'){\n    n++; return 0;\n  }else if('a'<=str[n] && str[n]<='k'){\n    //cout << str[n]  << endl;\n    bool p = phi[str[n] - 'a'];\n    n++;\n    return p;\n  }\n  cout << \"hs\" << endl;\n  assert(false);\n}\nbool parse(const string& str, const vector<int>& phi){\n  n = 0;\n  bool pl = hs(str, phi);\n  assert(str[n] == '=');\n  n++;\n  bool pr = hs(str, phi);\n  return pl == pr;\n}\nbool tryp(const string& str, const vector<int>& phi){\n  if(phi.size() == 11){\n    return parse(str, phi);\n  }\n  vector<int> t(phi), f(phi);\n  t.push_back(1);\n  f.push_back(0);\n  bool pt = tryp(str,t);\n  bool pf = tryp(str,f);\n  return pt && pf;\n}\nbool solve(const string& str){\n  return tryp(str, vector<int>());\n}\nsigned main(){\n  string str;\n  while(cin >> str, str != \"#\"){\n    if(solve(str)) cout << \"YES\" << endl;\n    else cout << \"NO\" << endl;\n  }\n}"
  },
  {
    "language": "C++",
    "code": "#include <iostream>\n#include <vector>\nusing namespace std;\n\nstruct node{\n  string exp;\n  int left=-1;\n  int right=-1;\n};\n\nint num;\nbool v[11],result;\nvector<char> s;\n\nint find(char c){\n  int i;\n  for(i=0;i<s.size();i++)\n    if(s[i]==c) break;\n  if(i<s.size()) return i; \n  else return -1;\n}\n\nint prior(char c){\n  if(c=='=') return 0;\n  else if(c=='>') return 1;\n  else if(c=='+') return 2;\n  else if(c=='*') return 3;\n  else if(c=='-') return 4;\n  else if(c=='T'||c=='F') return 5;\n  else{\n    if(find(c)==-1) s.push_back(c);\n    return 5;\n  }\n}\n\nvoid divide(int self,string exp,node nodes[]){\n  int cnt=0,min=5,min_index=-1;\n  bool inter=false;\n  for(int i=0;i<exp.size();i++){\n    if(exp[i]=='('){\n      cnt++;\n      if(i==0) inter=true;\n    } else if(exp[i]==')'){\n      cnt--;\n      if(cnt==0&&i!=exp.size()-1) inter=false;\n    } else if(cnt==0){\n      if(exp[i]=='-')\n\tif(exp[i+1]=='>') i++;\n      int p=prior(exp[i]);\n      if(p<min){\n\tmin=p; min_index=i;\n      }\n    }\n  }\n  if(inter){\n    divide(self,exp.substr(1,exp.size()-2),nodes); return;\n  }\n  if(min_index>=0){\n    if(min==1)\n      divide(nodes[self].left=++num,exp.substr(0,min_index-1),nodes);\n    else if(min<4)\n      divide(nodes[self].left=++num,exp.substr(0,min_index),nodes);\n    divide(nodes[self].right=++num,exp.substr(min_index+1),nodes);\n    nodes[self].exp=exp[min_index];\n  } else nodes[self].exp=exp;\n}\n\nbool solve(int n,node nodes[]){\n  if(nodes[n].exp==\"F\") return false;\n  else if(nodes[n].exp==\"T\") return true;\n  else{\n    if(nodes[n].exp==\"+\")\n      return solve(nodes[n].left,nodes)||solve(nodes[n].right,nodes);\n    else if(nodes[n].exp==\"*\")\n      return solve(nodes[n].left,nodes)&&solve(nodes[n].right,nodes);\n    else if(nodes[n].exp==\">\")\n      return !solve(nodes[n].left,nodes)||solve(nodes[n].right,nodes);\n    else if(nodes[n].exp==\"=\")\n      return solve(nodes[n].left,nodes)==solve(nodes[n].right,nodes);\n    else if(nodes[n].exp==\"-\")\n      return !solve(nodes[n].right,nodes);\n    else return v[find(nodes[n].exp[0])];\n  }\n}\n\nvoid all(node nodes[],int depth){\n  if(!result) return;\n  if(depth==s.size()){\n    if(!solve(0,nodes)) result=false;\n    return;\n  }\n  v[depth]=false; all(nodes,depth+1);\n  v[depth]=true; all(nodes,depth+1);\n}\n\nint main(){\n  string exp;\n\n  for(;;){\n    cin>>exp;\n    if(exp==\"#\") break;\n    num=0; s.clear(); result=true;\n    struct node nodes[1000];\n    divide(0,exp,nodes);\n    all(nodes,0);\n    if(result) cout<<\"YES\"<<endl;\n    else cout<<\"NO\"<<endl;\n  }\n}\n"
  },
  {
    "language": "C++",
    "code": "#include <algorithm>\n#include <bitset>\n#include <cctype>\n#include <complex>\n#include <cmath>\n#include <cstdio>\n#include <cstdlib>\n#include <cstring>\n#include <ctime>\n#include <deque>\n#include <functional>\n#include <iomanip>\n#include <iostream>\n#include <list>\n#include <map>\n#include <numeric>\n#include <queue>\n#include <set>\n#include <sstream>\n#include <stack>\n#include <string>\n#include <utility>\n#include <vector>\n\nusing namespace std;\n\ninline int toInt(string s) {int v; istringstream sin(s);sin>>v;return v;}\ntemplate<class T> inline string toString(T x) {ostringstream sout;sout<<x;return sout.str();}\ntemplate<class T> inline T sqr(T x) {return x*x;}\n\ntypedef vector<int> vi;\ntypedef vector<vi> vvi;\ntypedef vector<string> vs;\ntypedef pair<int, int> pii;\ntypedef long long ll;\n\n#define all(a)  (a).begin(),(a).end()\n#define rall(a) (a).rbegin(), (a).rend()\n#define pb push_back\n#define mp make_pair\n#define each(i,c) for(typeof((c).begin()) i=(c).begin(); i!=(c).end(); ++i)\n#define exist(s,e) ((s).find(e)!=(s).end())\n#define range(i,a,b) for(int i=(a);i<(b);++i)\n#define rep(i,n)  range(i,0,n)\n#define clr(a,b) memset((a), (b) ,sizeof(a))\n#define dump(x)  cerr << #x << \" = \" << (x) << endl;\n#define debug(x) cerr << #x << \" = \" << (x) << \" (L\" << __LINE__ << \")\" << \" \" << __FILE__ << endl;\n\nconst double eps = 1e-10;\nconst double pi  = acos(-1.0);\nconst ll INF =1LL << 62;\nconst int inf =1 << 29;\n\nint pos;\nconst string kVars = \"abcdefghijk\";\nstring formula1, formula2, res;\n\nint mlt(int lhs, int rhs){\n    return lhs && rhs;\n}\n\nint pls(int lhs, int rhs){\n    return lhs || rhs;\n}\n\nint mns(int val){\n    return !val;\n}\n\nint imp(int lhs, int rhs){\n    return !(lhs && !rhs);\n}\n\nint operate(const string& formula, int& pos){\n    int ret;\n\n    if(formula.at(pos) == '('){\n        pos++;\n\n        int lhs = operate(formula, pos);\n        char op = formula.at(pos++); if(op == '-') pos++;\n        int rhs = operate(formula, pos);\n\n        switch(op){\n        case '*': { ret = mlt(lhs, rhs); break; }\n        case '+': { ret = pls(lhs, rhs); break; }\n        case '-': { ret = imp(lhs, rhs); break; }\n        default : break; \n        }\n\n        pos++;\n    }\n\n    else if(formula.at(pos) == '-'){\n        bool isMns = true;\n        while(formula.at(++pos) == '-') isMns = !isMns;\n\n        ret = operate(formula, pos);\n        if(isMns) ret = mns(ret);\n    }\n\n    else {\n        ret = formula.at(pos) - '0';\n\n        pos++;\n    }\n\n    return ret;\n}\n\nvoid dfs(int p){\n    if(p == kVars.size()){\n        if(operate(formula1, pos = 0) != operate(formula2, pos = 0)){\n            res = \"NO\";\n        }\n\n        return;\n    }\n\n    rep(i, 2){\n        string tmp1 = formula1, tmp2 = formula2;\n\n        replace(all(formula1), kVars.at(p), (char)(i + '0'));\n        replace(all(formula2), kVars.at(p), (char)(i + '0'));\n\n        dfs(p + 1);\n\n        formula1 = tmp1, formula2 = tmp2;\n    }\n}\n\nint main(void){\n    for(string in; cin >> in, in != \"#\"; cout << res << endl){\n        res = \"YES\";\n\n        replace(all(in), 'T', '1');\n        replace(all(in), 'F', '0');\n        replace(all(in), '=', ' ');\n\n        stringstream ss(in);\n        ss >> formula1;\n        ss >> formula2;\n\n        dfs(0);\n    }\n\n\treturn 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include <functional>\n#include <iostream>\n#include <string>\n#include <unordered_set>\n#include <vector>\n#include <memory>\n#define loop(i, a, n) for (int i = (a); i < (n); i++)\n#define rep(i, n) loop(i, 0, n)\ntemplate<typename A> using F = std::function<A>;\nusing namespace std;\n \ntemplate<typename T> struct ParseResult {\n  bool succeeded;\n  T object;\n  int pos;\n  ParseResult(const bool succeeded, const T &object, const int pos) : succeeded(succeeded), object(object), pos(pos) {}\n  friend std::ostream &operator<<(std::ostream &os, const ParseResult<T> &p) { return os << '{' << (p.succeeded ? \"true\" : \"false\") << ',' << p.object << ',' << p.pos << '}'; }\n};\n \ntemplate<typename T> using Parser = std::function<ParseResult<T>(const std::string&, int)>;\n \nParser<std::string> token(std::string s) {\n  const auto n = s.size();\n  return [n = std::move(n), s = std::move(s)](const std::string &target, const int pos) {\n    if (target.size() < n) return ParseResult<std::string>(false, {}, pos);\n    return target.substr(pos, n) == s ? ParseResult<std::string>(true, s, pos + n) : ParseResult<std::string>(false, {}, pos);\n  };\n}\n \ntemplate<typename T> Parser<T> operator||(Parser<T> p1, Parser<T> p2) {\n  return [p1 = std::move(p1), p2 = std::move(p2)](const std::string &target, const int pos) {\n    auto r = p1(target, pos);\n    if (r.succeeded) return r;\n    r = p2(target, pos);\n    if (r.succeeded) return r;\n    return ParseResult<T>(false, {}, pos);\n  };\n}\n \ntemplate<typename T1, typename T2> Parser<std::pair<T1, T2>> operator+(Parser<T1> p1, Parser<T2> p2) {\n  return[p1 = std::move(p1), p2 = std::move(p2)](const std::string &target, const int pos) {\n    auto r1 = p1(target, pos);\n    if (!r1.succeeded) return ParseResult<std::pair<T1, T2>>(false, {}, pos);\n    auto r2 = p2(target, r1.pos);\n    if (!r2.succeeded) return ParseResult<std::pair<T1, T2>>(false, {}, pos);\n    return ParseResult<std::pair<T1, T2>>(true, {r1.object, r2.object}, r2.pos);\n  };\n}\n \ntemplate<typename T1, typename T2> Parser<T2> operator>>(Parser<T1> p1, Parser<T2> p2) {\n  return [p1 = std::move(p1), p2 = std::move(p2)](const std::string &target, const int pos) {\n    auto r1 = p1(target, pos);\n    if (!r1.succeeded) return ParseResult<T2>(false, {}, pos);\n    auto r2 = p2(target, r1.pos);\n    if (!r2.succeeded) return ParseResult<T2>(false, {}, pos);\n    return ParseResult<T2>(true, r2.object, r2.pos);\n  };\n}\n \ntemplate<typename T1, typename T2> Parser<T1> operator<<(Parser<T1> p1, Parser<T2> p2) {\n  return [p1 = std::move(p1), p2 = std::move(p2)](const std::string &target, const int pos) {\n    auto r1 = p1(target, pos);\n    if (!r1.succeeded) return ParseResult<T1>(false, {}, pos);\n    auto r2 = p2(target, r1.pos);\n    if (!r2.succeeded) return ParseResult<T1>(false, {}, pos);\n    return ParseResult<T1>(true, r1.object, r2.pos);\n  };\n}\n \nParser<char> oneOf(const std::string &s) {\n  std::unordered_set<char> d;\n  for (auto &c : s) d.insert(c);\n  return [d = std::move(d)](const std::string &target, const int pos) {\n    if (target.size() <= pos) return ParseResult<char>(false, {}, pos);\n    char c = target[pos];\n    return d.count(c) ? ParseResult<char>(true, c, pos + 1) : ParseResult<char>(false, {}, pos);\n  };\n}\n \ntemplate<typename T, typename S, typename F> Parser<S> fmap(Parser<T> p, F &&f) {\n  return [p = std::move(p), f = std::forward<F>(f)](const std::string &target, const int pos) {\n    auto r = p(target, pos);\n    return r.succeeded ? ParseResult<S>(true, f(r.object), r.pos) : ParseResult<S>(false, {}, r.pos);\n  };\n}\n \ntemplate<typename T, typename F> Parser<T> lazy(const F &f) {\n  bool instantiated = false;\n  Parser<T> p;\n  return [f = std::move(f), p = std::move(p), instantiated = std::move(instantiated)](const std::string &target, const int pos) mutable {\n    if (!instantiated) {\n      p = f();\n      instantiated = true;\n    }\n    return p(target, pos);\n  };\n}\ntemplate<typename T> Parser<T> make_view(Parser<T> &&f) {\n  return [f = std::make_shared<Parser<T>>(std::move(f))](const std::string &target, const int pos) {\n    return (*f)(target, pos);\n  };\n}\n \nstruct SyntaxTree {\n  string op;\n  char value;\n  vector<SyntaxTree> children;\n  SyntaxTree() {}\n  SyntaxTree(const string &op, const char value, const vector<SyntaxTree> &children) : op(op), value(value), children(children) {}\n};\n \nint main() {\n  Parser<SyntaxTree> formulaP = make_view<SyntaxTree>([&]() {\n    auto andP = fmap<pair<SyntaxTree, SyntaxTree>, SyntaxTree>((token(\"(\") >> formulaP << token(\"*\")) + (formulaP << token(\")\")), [](auto &o) { return SyntaxTree(\"*\", {}, {o.first, o.second}); });\n    auto orP = fmap<pair<SyntaxTree, SyntaxTree>, SyntaxTree>((token(\"(\") >> formulaP << token(\"+\")) + (formulaP << token(\")\")), [](auto &o) { return SyntaxTree(\"+\", {}, {o.first, o.second}); });\n    auto impP = fmap<pair<SyntaxTree, SyntaxTree>, SyntaxTree>((token(\"(\") >> formulaP << token(\"->\")) + (formulaP << token(\")\")), [](auto &o) { return SyntaxTree(\"->\", {}, {o.first, o.second}); });\n    auto notP = fmap<SyntaxTree, SyntaxTree>(token(\"-\") >> formulaP, [](auto &o) { return SyntaxTree(\"-\", {}, {o}); });\n    auto valP = fmap<char, SyntaxTree>(oneOf(\"abcdefghijkTF\"), [](char x) { return SyntaxTree({}, x, {}); });\n    return andP || orP || impP || notP || valP;\n  }());\n  auto equationP = (formulaP << token(\"=\")) + formulaP;\n  string s;\n  while (cin >> s, s != \"#\") {\n    auto r = equationP(s, 0);\n    bool isValid = true;\n    rep(i, 1 << 11) {\n      auto toBool = [&](char c) -> bool {\n        if (c == 'T') return true;\n        if (c == 'F') return false;\n        return i >> (c - 'a') & 1;\n      };\n      F<bool(const SyntaxTree&)> evalF = [&](const SyntaxTree &f) {\n        switch (f.children.size()) {\n          case 0: return toBool(f.value);\n          case 1: return !evalF(f.children[0]);\n          case 2:\n            if (f.op == \"*\") return evalF(f.children[0]) && evalF(f.children[1]);\n            if (f.op == \"+\") return evalF(f.children[0]) || evalF(f.children[1]);\n            if (f.op == \"->\") return !evalF(f.children[0]) || evalF(f.children[1]);\n        }\n      };\n      isValid &= evalF(r.object.first) == evalF(r.object.second);\n    }\n    cout << (isValid ? \"YES\" : \"NO\") << endl;\n  }\n}"
  },
  {
    "language": "C++",
    "code": "#include<bits/stdc++.h>\nusing namespace std;\ntypedef string::const_iterator state;\n\nstring str;\nstring A,B;\n\nstring conv(string &S,int bit){\n    string ret=S;\n    for(int i=0;i<S.size();i++){\n        if('a'<=S[i]&&'k'>=S[i]){\n            ret[i]=((bit>>(S[i]-'a')&1)?'1':'0');\n        }\n    }\n    return ret;\n}\nint expression(state &);\n\nint number(state &b){\n    int ret=0;\n    while(isdigit(*b)){\n        ret=ret*10+*b-'0';\n        b++;\n    }\n    return ret;\n}\n\nint fact(state &b){\n    int ret;\n    if(*b=='('){\n        b++;\n        ret=expression(b);\n        b++;\n    }\n    else{\n        ret=number(b);\n    }\n    return ret;\n}\n\nint latte(state &b){\n    if(*b=='-'){\n        b++;\n        return 1-fact(b);\n    }\n    else return fact(b);\n}\n\nint expression(state &b){\n    int ret=latte(b);\n    while(true){\n        if(*b=='+'){\n            b++;\n            ret=max(ret,latte(b));\n        }\n        else if(*b=='&'){\n            b++;\n            ret=min(ret,latte(b));\n        }\n        else if(*b=='-'){\n            b++;b++;\n            ret=(ret<=latte(b));\n        }\n        else break;\n    }\n    return ret;\n}\n\nvoid solve(){\n    for(int i=0;i<str.size();i++){\n        if(str[i]=='T')str[i]='1';\n        if(str[i]=='F')str[i]='0';\n    }\n\n    int idx=str.find('=');\n    A=str.substr(0,idx);\n    B=str.substr(idx+1,str.size()-idx-1);\n    A+=\"=\";B+=\"=\";\n\n    for(int i=0;i<(1<<11);i++){\n        string a=conv(A,i),b=conv(B,i);\n        state sa=a.begin(),sb=b.begin();\n        if(expression(sa)!=expression(sb)){\n            cout<<\"NO\"<<endl;\n            return;\n        }\n    }\n    cout<<\"YES\"<<endl;\n}\n\nint main(){\n    while(cin>>str,str!=\"#\")solve();\n    return 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include <iostream>\n#include <string>\n#include <algorithm>\n#include <cstdio>\n#include <cassert>\n#include <vector>\n#include <map>\n\nusing namespace std;\n//map<char,bool> assign;\nint assign;\nbool formula(string &arg, int &pos){\n    if('a' <= arg[pos] && arg[pos] <= 'k'){\n        return assign & (1 << (arg[pos++]-'a'));\n    }else if(arg[pos] == '-'){\n        return !formula(arg, ++pos);\n    }else if(arg[pos] == 'T'){\n        pos++;\n        return true;\n    }else if(arg[pos] == 'F'){\n        pos++;\n        return false;\n    }else{\n        assert(arg[pos] == '(');\n        bool f,b;\n        char op;\n        f = formula(arg, ++pos);\n        op = arg[pos];\n        assert(op == '*' || op == '+' || op == '-');\n        if(op == '-') pos++;\n        b = formula(arg, ++pos);\n        assert(arg[pos] == ')');\n        pos++;\n        if(op == '*'){\n            if(f&&b) return true;\n            return false;\n        }else if(op == '+'){\n            if(!f&&!b) return false;\n            return true;\n        }else{\n            if(f && !b) return false;\n            return true;\n        }\n    }\n}\n\nbool parse(string &arg, int pos){\n    bool f,b;\n\n    f = formula(arg, pos);\n    assert(arg[pos] == '=');\n    b = formula(arg, ++pos);\n    return f == b;\n}\n\n\nint main(){\n    string str;\n    while(cin >> str){\n        if(str == \"#\") break;\n        vector<char> vars;\n        bool res = true;\n\n        for(int i=0;i<(int)str.size();i++){\n            if('a' <= str[i] && str[i] <= 'k'){\n                vars.push_back(str[i]);\n            }\n        }\n\n        for(int i=0;i<(1 << 10);i++){\n            assign = i;\n            res = parse(str, 0);\n            if(!res) break;\n        }\n        if(res){\n            cout << \"YES\" << endl;\n        }else{\n            cout << \"NO\" << endl;\n        }\n    }\n}"
  },
  {
    "language": "C++",
    "code": "#include <iostream>\n#include <algorithm>\n#include <array>\n#include <bitset>\n\nusing namespace std;\n\nconst int N = 11;\nconst int B = 1<<11;\nusing V = bitset<B>;\n\n#ifndef HELLO_HPP_\n#define HELLO_HPP_\n\n// This file was automatically generated by Caper.\n// (http://jonigata.github.io/caper/caper.html)\n\n#include <cstdlib>\n#include <cassert>\n#include <vector>\n\nnamespace calc {\n\nenum Token {\n token_eof,\n token_Add,\n token_Arrow,\n token_Cons,\n token_EQ,\n token_LBranket,\n token_Mul,\n token_Not,\n token_RBranket,\n token_Var,\n};\n\ninline const char* token_label(Token t) {\n static const char* labels[] = {\n \"token_eof\",\n \"token_Add\",\n \"token_Arrow\",\n \"token_Cons\",\n \"token_EQ\",\n \"token_LBranket\",\n \"token_Mul\",\n \"token_Not\",\n \"token_RBranket\",\n \"token_Var\",\n };\n return labels[t];\n}\n\ntemplate <class T, unsigned int StackSize>\nclass Stack {\npublic:\n Stack() { gap_ = 0; }\n\n void rollback_tmp() {\n gap_ = stack_.size();\n tmp_.clear();\n }\n\n void commit_tmp() {\n // may throw\n stack_.reserve(gap_ + tmp_.size());\n \n // expect not to throw\n stack_.erase(stack_.begin()+ gap_, stack_.end());\n stack_.insert(stack_.end(), tmp_.begin(), tmp_.end());\n tmp_.clear();\n }\n bool push(const T& f) {\n if (StackSize != 0 &&\n int(StackSize) <= int(stack_.size() + tmp_.size())) {\n return false;\n }\n tmp_.push_back(f);\n return true;\n }\n \n void pop(size_t n) {\n if (tmp_.size() < n) {\n n -= tmp_.size();\n tmp_.clear();\n gap_ -= n;\n } else {\n tmp_.erase(tmp_.end() - n, tmp_.end());\n }\n }\n\n T& top() {\n assert(0 < depth());\n if (!tmp_.empty()) {\n return tmp_.back();\n } else {\n return stack_[gap_ - 1];\n }\n }\n \n const T& get_arg(size_t base, size_t index) {\n size_t n = tmp_.size();\n if (base - index <= n) {\n return tmp_[n - (base - index)];\n } else {\n return stack_[gap_ - (base - n) + index];\n }\n }\n \n void clear() {\n stack_.clear();\n tmp_.clear();\n gap_ = 0; \n }\n \n bool empty() const {\n if (!tmp_.empty()) {\n return false;\n } else {\n return gap_ == 0;\n }\n }\n \n size_t depth() const {\n return gap_ + tmp_.size();\n }\n \n T& nth(size_t index) {\n if (gap_ <= index) {\n return tmp_[index - gap_];\n } else {\n return stack_[index];\n }\n }\n\n void swap_top_and_second() {\n int d = depth();\n assert(2 <= d);\n T x = nth(d - 1);\n nth(d - 1) = nth(d - 2);\n nth(d - 2) = x;\n }\n\nprivate:\n std::vector<T> stack_;\n std::vector<T> tmp_;\n size_t gap_;\n \n};\n\ntemplate <class _Value, class _SemanticAction,\n unsigned int _StackSize = 0>\nclass Parser {\npublic:\n typedef Token token_type;\n typedef _Value value_type;\n\n enum Nonterminal {\n Nonterminal_Expr,\n Nonterminal_Form,\n };\n\npublic:\n Parser(_SemanticAction& sa) : sa_(sa) { reset(); }\n\n void reset() {\n error_ = false;\n accepted_ = false;\n clear_stack();\n rollback_tmp_stack();\n if (push_stack(0, value_type())) {\n commit_tmp_stack();\n } else {\n sa_.stack_overflow();\n error_ = true;\n }\n }\n\n bool post(token_type token, const value_type& value) {\n rollback_tmp_stack();\n error_ = false;\n while ((this->*(stack_top()->entry->state))(token, value))\n ; // may throw\n if (!error_) {\n commit_tmp_stack();\n } else {\n recover(token, value);\n }\n return accepted_ || error_;\n }\n\n bool accept(value_type& v) {\n assert(accepted_);\n if (error_) { return false; }\n v = accepted_value_;\n return true;\n }\n\n bool error() { return error_; }\n\nprivate:\n typedef Parser<_Value, _SemanticAction, _StackSize> self_type;\n\n typedef bool (self_type::*state_type)(token_type, const value_type&);\n typedef int (self_type::*gotof_type)(Nonterminal);\n\n bool accepted_;\n bool error_;\n value_type accepted_value_;\n _SemanticAction& sa_;\n\n struct table_entry {\n state_type state;\n gotof_type gotof;\n bool handle_error;\n };\n\n struct stack_frame {\n const table_entry* entry;\n value_type value;\n int sequence_length;\n\n stack_frame(const table_entry* e, const value_type& v, int sl)\n : entry(e), value(v), sequence_length(sl) {}\n };\n\n Stack<stack_frame, _StackSize> stack_;\n\n bool push_stack(int state_index, const value_type& v, int sl = 0) {\n bool f = stack_.push(stack_frame(entry(state_index), v, sl));\n assert(!error_);\n if (!f) { \n error_ = true;\n sa_.stack_overflow();\n }\n return f;\n }\n\n void pop_stack(size_t n) {\n stack_.pop(n);\n }\n\n stack_frame* stack_top() {\n return &stack_.top();\n }\n\n const value_type& get_arg(size_t base, size_t index) {\n return stack_.get_arg(base, index).value;\n }\n\n void clear_stack() {\n stack_.clear();\n }\n\n void rollback_tmp_stack() {\n stack_.rollback_tmp();\n }\n\n void commit_tmp_stack() {\n stack_.commit_tmp();\n }\n\n void recover(token_type, const value_type&) {\n }\n\n bool call_nothing(Nonterminal nonterminal, int base) {\n pop_stack(base);\n int dest_index = (this->*(stack_top()->entry->gotof))(nonterminal);\n return push_stack(dest_index, value_type());\n }\n\n bool call_0_Merge(Nonterminal nonterminal, int base, int arg_index0, int arg_index1) {\n V arg0; sa_.downcast(arg0, get_arg(base, arg_index0));\n V arg1; sa_.downcast(arg1, get_arg(base, arg_index1));\n V r = sa_.Merge(arg0, arg1);\n value_type v; sa_.upcast(v, r);\n pop_stack(base);\n int dest_index = (this->*(stack_top()->entry->gotof))(nonterminal);\n return push_stack(dest_index, v);\n }\n\n bool call_0_Identity(Nonterminal nonterminal, int base, int arg_index0) {\n V arg0; sa_.downcast(arg0, get_arg(base, arg_index0));\n V r = sa_.Identity(arg0);\n value_type v; sa_.upcast(v, r);\n pop_stack(base);\n int dest_index = (this->*(stack_top()->entry->gotof))(nonterminal);\n return push_stack(dest_index, v);\n }\n\n bool call_0_MakeAdd(Nonterminal nonterminal, int base, int arg_index0, int arg_index1) {\n V arg0; sa_.downcast(arg0, get_arg(base, arg_index0));\n V arg1; sa_.downcast(arg1, get_arg(base, arg_index1));\n V r = sa_.MakeAdd(arg0, arg1);\n value_type v; sa_.upcast(v, r);\n pop_stack(base);\n int dest_index = (this->*(stack_top()->entry->gotof))(nonterminal);\n return push_stack(dest_index, v);\n }\n\n bool call_0_MakeMul(Nonterminal nonterminal, int base, int arg_index0, int arg_index1) {\n V arg0; sa_.downcast(arg0, get_arg(base, arg_index0));\n V arg1; sa_.downcast(arg1, get_arg(base, arg_index1));\n V r = sa_.MakeMul(arg0, arg1);\n value_type v; sa_.upcast(v, r);\n pop_stack(base);\n int dest_index = (this->*(stack_top()->entry->gotof))(nonterminal);\n return push_stack(dest_index, v);\n }\n\n bool call_0_MakeIMP(Nonterminal nonterminal, int base, int arg_index0, int arg_index1) {\n V arg0; sa_.downcast(arg0, get_arg(base, arg_index0));\n V arg1; sa_.downcast(arg1, get_arg(base, arg_index1));\n V r = sa_.MakeIMP(arg0, arg1);\n value_type v; sa_.upcast(v, r);\n pop_stack(base);\n int dest_index = (this->*(stack_top()->entry->gotof))(nonterminal);\n return push_stack(dest_index, v);\n }\n\n bool call_0_MakeNot(Nonterminal nonterminal, int base, int arg_index0) {\n V arg0; sa_.downcast(arg0, get_arg(base, arg_index0));\n V r = sa_.MakeNot(arg0);\n value_type v; sa_.upcast(v, r);\n pop_stack(base);\n int dest_index = (this->*(stack_top()->entry->gotof))(nonterminal);\n return push_stack(dest_index, v);\n }\n\n bool state_0(token_type token, const value_type& value) {\n switch(token) {\n case token_Cons:\n // shift\n push_stack(/*state*/ 10, value);\n return false;\n case token_LBranket:\n // shift\n push_stack(/*state*/ 6, value);\n return false;\n case token_Not:\n // shift\n push_stack(/*state*/ 5, value);\n return false;\n case token_Var:\n // shift\n push_stack(/*state*/ 11, value);\n return false;\n default:\n sa_.syntax_error();\n error_ = true;\n return false;\n }\n }\n\n int gotof_0(Nonterminal nonterminal) {\n switch(nonterminal) {\n case Nonterminal_Expr: return 1;\n case Nonterminal_Form: return 2;\n default: assert(0); return false;\n }\n }\n\n bool state_1(token_type token, const value_type& value) {\n switch(token) {\n case token_eof:\n // accept\n accepted_ = true;\n accepted_value_ = get_arg(1, 0);\n return false;\n default:\n sa_.syntax_error();\n error_ = true;\n return false;\n }\n }\n\n int gotof_1(Nonterminal nonterminal) {\n assert(0);\n return true;\n }\n\n bool state_2(token_type token, const value_type& value) {\n switch(token) {\n case token_EQ:\n // shift\n push_stack(/*state*/ 3, value);\n return false;\n default:\n sa_.syntax_error();\n error_ = true;\n return false;\n }\n }\n\n int gotof_2(Nonterminal nonterminal) {\n assert(0);\n return true;\n }\n\n bool state_3(token_type token, const value_type& value) {\n switch(token) {\n case token_Cons:\n // shift\n push_stack(/*state*/ 10, value);\n return false;\n case token_LBranket:\n // shift\n push_stack(/*state*/ 6, value);\n return false;\n case token_Not:\n // shift\n push_stack(/*state*/ 5, value);\n return false;\n case token_Var:\n // shift\n push_stack(/*state*/ 11, value);\n return false;\n default:\n sa_.syntax_error();\n error_ = true;\n return false;\n }\n }\n\n int gotof_3(Nonterminal nonterminal) {\n switch(nonterminal) {\n case Nonterminal_Form: return 4;\n default: assert(0); return false;\n }\n }\n\n bool state_4(token_type token, const value_type& value) {\n switch(token) {\n case token_eof:\n // reduce\n return call_0_Merge(Nonterminal_Expr, /*pop*/ 3, 0, 2);\n default:\n sa_.syntax_error();\n error_ = true;\n return false;\n }\n }\n\n int gotof_4(Nonterminal nonterminal) {\n assert(0);\n return true;\n }\n\n bool state_5(token_type token, const value_type& value) {\n switch(token) {\n case token_Cons:\n // shift\n push_stack(/*state*/ 10, value);\n return false;\n case token_LBranket:\n // shift\n push_stack(/*state*/ 6, value);\n return false;\n case token_Not:\n // shift\n push_stack(/*state*/ 5, value);\n return false;\n case token_Var:\n // shift\n push_stack(/*state*/ 11, value);\n return false;\n default:\n sa_.syntax_error();\n error_ = true;\n return false;\n }\n }\n\n int gotof_5(Nonterminal nonterminal) {\n switch(nonterminal) {\n case Nonterminal_Form: return 12;\n default: assert(0); return false;\n }\n }\n\n bool state_6(token_type token, const value_type& value) {\n switch(token) {\n case token_Cons:\n // shift\n push_stack(/*state*/ 10, value);\n return false;\n case token_LBranket:\n // shift\n push_stack(/*state*/ 6, value);\n return false;\n case token_Not:\n // shift\n push_stack(/*state*/ 5, value);\n return false;\n case token_Var:\n // shift\n push_stack(/*state*/ 11, value);\n return false;\n default:\n sa_.syntax_error();\n error_ = true;\n return false;\n }\n }\n\n int gotof_6(Nonterminal nonterminal) {\n switch(nonterminal) {\n case Nonterminal_Form: return 13;\n default: assert(0); return false;\n }\n }\n\n bool state_7(token_type token, const value_type& value) {\n switch(token) {\n case token_Cons:\n // shift\n push_stack(/*state*/ 10, value);\n return false;\n case token_LBranket:\n // shift\n push_stack(/*state*/ 6, value);\n return false;\n case token_Not:\n // shift\n push_stack(/*state*/ 5, value);\n return false;\n case token_Var:\n // shift\n push_stack(/*state*/ 11, value);\n return false;\n default:\n sa_.syntax_error();\n error_ = true;\n return false;\n }\n }\n\n int gotof_7(Nonterminal nonterminal) {\n switch(nonterminal) {\n case Nonterminal_Form: return 14;\n default: assert(0); return false;\n }\n }\n\n bool state_8(token_type token, const value_type& value) {\n switch(token) {\n case token_Cons:\n // shift\n push_stack(/*state*/ 10, value);\n return false;\n case token_LBranket:\n // shift\n push_stack(/*state*/ 6, value);\n return false;\n case token_Not:\n // shift\n push_stack(/*state*/ 5, value);\n return false;\n case token_Var:\n // shift\n push_stack(/*state*/ 11, value);\n return false;\n default:\n sa_.syntax_error();\n error_ = true;\n return false;\n }\n }\n\n int gotof_8(Nonterminal nonterminal) {\n switch(nonterminal) {\n case Nonterminal_Form: return 16;\n default: assert(0); return false;\n }\n }\n\n bool state_9(token_type token, const value_type& value) {\n switch(token) {\n case token_Cons:\n // shift\n push_stack(/*state*/ 10, value);\n return false;\n case token_LBranket:\n // shift\n push_stack(/*state*/ 6, value);\n return false;\n case token_Not:\n // shift\n push_stack(/*state*/ 5, value);\n return false;\n case token_Var:\n // shift\n push_stack(/*state*/ 11, value);\n return false;\n default:\n sa_.syntax_error();\n error_ = true;\n return false;\n }\n }\n\n int gotof_9(Nonterminal nonterminal) {\n switch(nonterminal) {\n case Nonterminal_Form: return 19;\n default: assert(0); return false;\n }\n }\n\n bool state_10(token_type token, const value_type& value) {\n switch(token) {\n case token_eof:\n case token_Add:\n case token_EQ:\n case token_Mul:\n case token_Not:\n case token_RBranket:\n // reduce\n return call_0_Identity(Nonterminal_Form, /*pop*/ 1, 0);\n default:\n sa_.syntax_error();\n error_ = true;\n return false;\n }\n }\n\n int gotof_10(Nonterminal nonterminal) {\n assert(0);\n return true;\n }\n\n bool state_11(token_type token, const value_type& value) {\n switch(token) {\n case token_eof:\n case token_Add:\n case token_EQ:\n case token_Mul:\n case token_Not:\n case token_RBranket:\n // reduce\n return call_0_Identity(Nonterminal_Form, /*pop*/ 1, 0);\n default:\n sa_.syntax_error();\n error_ = true;\n return false;\n }\n }\n\n int gotof_11(Nonterminal nonterminal) {\n assert(0);\n return true;\n }\n\n bool state_12(token_type token, const value_type& value) {\n switch(token) {\n case token_eof:\n case token_Add:\n case token_EQ:\n case token_Mul:\n case token_Not:\n case token_RBranket:\n // reduce\n return call_0_MakeNot(Nonterminal_Form, /*pop*/ 2, 1);\n default:\n sa_.syntax_error();\n error_ = true;\n return false;\n }\n }\n\n int gotof_12(Nonterminal nonterminal) {\n assert(0);\n return true;\n }\n\n bool state_13(token_type token, const value_type& value) {\n switch(token) {\n case token_Add:\n // shift\n push_stack(/*state*/ 8, value);\n return false;\n case token_Mul:\n // shift\n push_stack(/*state*/ 7, value);\n return false;\n case token_Not:\n // shift\n push_stack(/*state*/ 18, value);\n return false;\n default:\n sa_.syntax_error();\n error_ = true;\n return false;\n }\n }\n\n int gotof_13(Nonterminal nonterminal) {\n assert(0);\n return true;\n }\n\n bool state_14(token_type token, const value_type& value) {\n switch(token) {\n case token_RBranket:\n // shift\n push_stack(/*state*/ 15, value);\n return false;\n default:\n sa_.syntax_error();\n error_ = true;\n return false;\n }\n }\n\n int gotof_14(Nonterminal nonterminal) {\n assert(0);\n return true;\n }\n\n bool state_15(token_type token, const value_type& value) {\n switch(token) {\n case token_eof:\n case token_Add:\n case token_EQ:\n case token_Mul:\n case token_Not:\n case token_RBranket:\n // reduce\n return call_0_MakeMul(Nonterminal_Form, /*pop*/ 5, 1, 3);\n default:\n sa_.syntax_error();\n error_ = true;\n return false;\n }\n }\n\n int gotof_15(Nonterminal nonterminal) {\n assert(0);\n return true;\n }\n\n bool state_16(token_type token, const value_type& value) {\n switch(token) {\n case token_RBranket:\n // shift\n push_stack(/*state*/ 17, value);\n return false;\n default:\n sa_.syntax_error();\n error_ = true;\n return false;\n }\n }\n\n int gotof_16(Nonterminal nonterminal) {\n assert(0);\n return true;\n }\n\n bool state_17(token_type token, const value_type& value) {\n switch(token) {\n case token_eof:\n case token_Add:\n case token_EQ:\n case token_Mul:\n case token_Not:\n case token_RBranket:\n // reduce\n return call_0_MakeAdd(Nonterminal_Form, /*pop*/ 5, 1, 3);\n default:\n sa_.syntax_error();\n error_ = true;\n return false;\n }\n }\n\n int gotof_17(Nonterminal nonterminal) {\n assert(0);\n return true;\n }\n\n bool state_18(token_type token, const value_type& value) {\n switch(token) {\n case token_Arrow:\n // shift\n push_stack(/*state*/ 9, value);\n return false;\n default:\n sa_.syntax_error();\n error_ = true;\n return false;\n }\n }\n\n int gotof_18(Nonterminal nonterminal) {\n assert(0);\n return true;\n }\n\n bool state_19(token_type token, const value_type& value) {\n switch(token) {\n case token_RBranket:\n // shift\n push_stack(/*state*/ 20, value);\n return false;\n default:\n sa_.syntax_error();\n error_ = true;\n return false;\n }\n }\n\n int gotof_19(Nonterminal nonterminal) {\n assert(0);\n return true;\n }\n\n bool state_20(token_type token, const value_type& value) {\n switch(token) {\n case token_eof:\n case token_Add:\n case token_EQ:\n case token_Mul:\n case token_Not:\n case token_RBranket:\n // reduce\n return call_0_MakeIMP(Nonterminal_Form, /*pop*/ 6, 1, 4);\n default:\n sa_.syntax_error();\n error_ = true;\n return false;\n }\n }\n\n int gotof_20(Nonterminal nonterminal) {\n assert(0);\n return true;\n }\n\n const table_entry* entry(int n) const {\n static const table_entry entries[] = {\n { &Parser::state_0, &Parser::gotof_0, false },\n { &Parser::state_1, &Parser::gotof_1, false },\n { &Parser::state_2, &Parser::gotof_2, false },\n { &Parser::state_3, &Parser::gotof_3, false },\n { &Parser::state_4, &Parser::gotof_4, false },\n { &Parser::state_5, &Parser::gotof_5, false },\n { &Parser::state_6, &Parser::gotof_6, false },\n { &Parser::state_7, &Parser::gotof_7, false },\n { &Parser::state_8, &Parser::gotof_8, false },\n { &Parser::state_9, &Parser::gotof_9, false },\n { &Parser::state_10, &Parser::gotof_10, false },\n { &Parser::state_11, &Parser::gotof_11, false },\n { &Parser::state_12, &Parser::gotof_12, false },\n { &Parser::state_13, &Parser::gotof_13, false },\n { &Parser::state_14, &Parser::gotof_14, false },\n { &Parser::state_15, &Parser::gotof_15, false },\n { &Parser::state_16, &Parser::gotof_16, false },\n { &Parser::state_17, &Parser::gotof_17, false },\n { &Parser::state_18, &Parser::gotof_18, false },\n { &Parser::state_19, &Parser::gotof_19, false },\n { &Parser::state_20, &Parser::gotof_20, false },\n };\n return &entries[n];\n }\n\n};\n\n} // namespace calc\n\n#endif // #ifndef HELLO_HPP_\n\n\n\nclass unexpected_char : public std::exception {};\n\n\n// %token Cons<V> Var<V> Not Add Mul Arrow EQ LBranket RBranket;\n// %namespace calc;\n\n// Expr<V> : [Merge] Form(0) EQ Form(1)\n// ;\n// Form<V> : [Identity] Cons\n// | [Identity] Var\n// | [MakeNot] Not Form(0)\n// | [MakeMul] LBranket Form(0) Mul Form(1) RBranket\n// | [MakeAdd] LBranket Form(0) Add Form(1) RBranket\n// | [MakeIMP] LBranket Form(0) Not Arrow Form(1) RBranket\n// ;\n\n\nstruct SemanticAction {\n void syntax_error() {}\n void stack_overflow() {}\n void downcast(V& x, V y) { x = y; }\n void upcast(V& x, V y) { x = y; }\n\n V Identity(V n) { return n; }\n V MakeNot(V n) {\n return ~n;\n }\n V MakeMul(V x, V y) {\n return x & y;\n }\n V MakeAdd(V x, V y) {\n return x | y;\n }\n V MakeIMP(V x, V y) {\n return (~x) | y;\n }\n V Merge(V x, V y) {\n return x ^ y;\n }\n};\n\n// %token Cons<V> Var<V> Not Add Mul Arrow EQ LBranket RBranket;\n// %namespace calc;\n\n// Expr<V> : [Merge] Form(0) EQ Form(1)\n// ;\n// Form<V> : [Identity] Cons\n// | [Identity] Var\n// | [MakeNot] Not Form(0)\n// | [MakeMul] LBranket Form(0) Mul Form(1) RBranket\n// | [MakeAdd] LBranket Form(0) Add Form(1) RBranket\n// | [MakeIMP] LBranket Form(0) Not Arrow Form(1) RBranket\n// ;\n\n\nclass scanner {\npublic:\n using char_type = char;\n\nprivate:\n string s;\n int pos;\npublic:\n scanner(string s) : s(s), pos(0) {}\n\n calc::Token get(V& v) {\n char c;\n do {\n c = getc();\n } while (isspace(c));\n if (c == 'T') {\n v.set();\n return calc::token_Cons;\n }\n if (c == 'F') {\n v.reset();\n return calc::token_Cons;\n }\n if ('a' <= c and c <= 'k') {\n int u = c - 'a';\n v.reset();\n for (int i = 0; i < B; i++) {\n if (i & (1<<u)) {\n v.set(i);\n }\n }\n return calc::token_Var;\n }\n switch (c) {\n case '+': return calc::token_Add;\n case '*': return calc::token_Mul;\n case '(': return calc::token_LBranket;\n case ')': return calc::token_RBranket;\n case '-': return calc::token_Not;\n case '>': return calc::token_Arrow;\n case '=': return calc::token_EQ;\n case EOF: return calc::token_eof;\n }\n\n cerr << c << endl;\n throw unexpected_char();\n }\n\nprivate:\n char_type getc() {\n if (pos == s.size()) return EOF;\n return s[pos++];\n }\n};\n\n\n\nint main() {\n while (true) {\n string s;\n getline(cin, s);\n if (s == \"#\") break;\n scanner scn(s);\n SemanticAction sa;\n calc::Parser<V, SemanticAction> parser(sa);\n calc::Token token;\n while (true) {\n V v;\n token = scn.get(v);\n if (parser.post(token, v)) { break; }\n }\n V v;\n if (parser.accept(v)) {\n if (v.any()) {\n cout << \"NO\" << endl;\n } else {\n cout << \"YES\" << endl;\n }\n }\n }\n return 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include \"bits/stdc++.h\"\n#include <sys/timeb.h>\n#include <fstream>\n\nusing namespace std;\n\n#define repl(i,a,b) for(int i=(int)(a);i<(int)(b);i++)\n#define rep(i,n) repl(i,0,n)\n#define replrev(i,a,b) for(int i=(int)(b)-1;i>=(int)(a);i--)\n#define reprev(i,n) replrev(i,0,n)\n#define repi(itr,ds) for(auto itr=ds.begin();itr!=ds.end();itr++)\n#define all(a) a.begin(),a.end()\n#define mp make_pair\n#define mt make_tuple\n#define INF 2000000000\n#define INFL 1000000000000000000LL\n#define EPS (1e-10)\n#define MOD 1000000007\n#define PI 3.1415926536\n#define RMAX 4294967295\n\ntypedef long long ll;\ntypedef pair<int, int> P;\ntypedef vector<int> vi;\ntypedef vector<ll> vll;\ntypedef vector<bool> vb;\ntypedef vector<char> vc;\ntypedef vector<string> vs;\ntypedef vector<double> vd;\ntypedef vector<P> vP;\ntypedef vector<vector<int> > vvi;\ntypedef vector<vector<bool> > vvb;\ntypedef vector<vector<ll> > vvll;\ntypedef vector<vector<char> > vvc;\ntypedef vector<vector<string> > vvs;\ntypedef vector<vector<double> > vvd;\ntypedef vector<vector<P> > vvP;\ntypedef priority_queue<int, vector<int>, greater<int> > pqli;\ntypedef priority_queue<ll, vector<ll>, greater<ll> > pqlll;\ntypedef priority_queue<P, vector<P>, greater<P> > pqlP;\n\ntypedef string::const_iterator State;\nclass ParseError {};\n/*\nstruct Edge {\nint from, to, cost;\nbool operator<(Edge e) {\nreturn cost < e.cost;\n}\n};\ntypedef vector<Edge> Edges;\ntypedef vector<Edges> Graph;\n*/\n\nbool formula(State &begin, map<char, bool> value) {\n\t//cout << *begin << endl;\n\tif (*begin == '-') {\n\t\tbegin++;\n\t\treturn !formula(begin, value);\n\t}\n\telse if (*begin == '(') {\n\t\tbegin++;\n\t\tbool ret = formula(begin, value);\n\t\tif (*begin == '*') {\n\t\t\tbegin++;\n\t\t\tbool right = formula(begin, value);\n\t\t\tret = ret && right;\n\t\t}\n\t\telse if (*begin == '+') {\n\t\t\tbegin++;\n\t\t\tbool right = formula(begin, value);\n\t\t\tret = ret || right;\n\t\t}\n\t\telse {\n\t\t\tbegin += 2;\n\t\t\tbool right = formula(begin, value);\n\t\t\tret = (!ret) || right;\n\t\t}\n\t\tbegin++;\n\t\treturn ret;\n\t}\n\telse {\n\t\tbool ret = value[*begin];\n\t\tbegin++;\n\t\treturn ret;\n\t}\n}\n\nbool equation(State &begin, map<char, bool> value) {\n\tbool lhs = formula(begin, value);\n\tbegin++;\n\tbool rhs = formula(begin, value);\n\t/*\n\tfor (auto p : value) {\n\t\tcout << p.first << \":\" << (p.second ? \"T \" : \"F \");\n\t}\n\tcout << endl << (rhs ? \"T=\" : \"F=\") << (lhs ? \"T\" : \"F\") << endl;\n\t*/\n\treturn (lhs == rhs);\n}\n\nint main(void) {\n\twhile (true) {\n\t\tstring s;\n\t\tgetline(cin, s);\n\t\tif (s[0] == '#')break;\n\n\t\tbool flag = true;\n\t\tmap<char, bool>value;\n\t\tvalue['T'] = true;\n\t\tvalue['F'] = false;\n\t\trep(i, (1 << 11)) {\n\t\t\trep(j, 11) {\n\t\t\t\tvalue['a' + j] = ((i&(1 << j)) != 0 ? true : false);\n\t\t\t}\n\n\t\t\tState begin = s.begin();\n\n\t\t\tif (!equation(begin, value)) {\n\t\t\t\tcout << \"NO\" << endl;\n\t\t\t\tflag = false;\n\t\t\t\tbreak;\n\t\t\t}\n\t\t}\n\t\tif (flag) {\n\t\t\tcout << \"YES\" << endl;\n\t\t}\n\t}\n\n\treturn 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\n\nusing namespace std;\n\nclass ParseError {};\ntypedef string::const_iterator State;\n\nbool expression(State &begin) {\n\tbool ret;\n\tif(*begin == 'T'){begin++; ret = true;}\n\telse if(*begin == 'F'){begin++; ret = false;}\n\telse if(*begin == '-'){begin++; ret = !expression(begin);}\n\telse {\n\t\tbegin++;\n\t\tbool a = expression(begin);\n\t\tif(*begin == '*'){\n\t\t\tbegin++;\n\t\t\tret = a && expression(begin);\n\t\t}\n\t\telse if(*begin == '-' && *(begin+1) == '>'){\n\t\t\tbegin++; begin++;\n\t\t\tret = (a && !expression(begin) ? false : true);\n\t\t}\n\t\telse if (*begin == '+') {\n\t\t\tbegin++;\n\t\t\tret = a || expression(begin);\n\t\t}\n\t\tbegin++;\n\t}\n\treturn ret;\n}\n\nint main(){\n\tstring e;\n\twhile(cin >> e, e != \"#\"){\n\t\tbool possible = true;\n\t\tfor(int i=0; i < 1<<11; i++){\n\t\t\tstring s = e;\n\t\t\tstring t = \"abcdefghijk\";\n\t\t\tfor(int j=0; j < s.size(); j++){\n\t\t\t\tfor(int k=0; k < t.size(); k++){\n\t\t\t\t\tif(s[j] == t[k]) s[j] = ((i >> k) & 1 == 1 ? 'T' : 'F');\n\t\t\t\t}\n\t\t\t}\n\t\t\tstring a, b;\n\t\t\tfor(int i=0; i< s.size(); i++) if(s[i] == '='){a = s.substr(0, i); b = s.substr(i+1);}\n\t\t\tState abegin = a.begin();\n\t\t\tState bbegin = b.begin();\n\n\t\t\tif(!(expression(abegin) == expression(bbegin))){possible = false; break;}\n\t\t}\n\t\tcout << (possible ? \"YES\" : \"NO\") << endl;\n\t}\n}"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\nusing namespace std;\n\nvector<string> opr{\"->\", \"+\", \"*\", \"-\"};\nvector<string> num{\"1\", \"2\", \"3\", \"4\"};\n\nbool calc(string exp, int bits) {\n    // cout << exp << endl;\n    if (exp == \"T\") return true;\n    if (exp == \"F\") return false;\n    if ('a' <= exp[0] && exp[0] <= 'k') return (bits & (1 << (exp[0] - 'a')) ? true : false);\n    if (exp[0] == '4') return !calc(string(exp.begin() + 1, exp.end()), bits);\n\n    int idx = -1;\n    for (int i = (exp[0] == '(' ? 1 : 0), count = 0, len = exp.size() - (exp[0] == '(' ? 1 : 0);\n         i < len;\n         i++\n        ) {\n        if (exp[i] == '(') count++;\n        else if (exp[i] == ')') count--;\n        if (count == 0 && '1' <= exp[i] && exp[i] <= '3') {\n            idx = i;\n            break;\n        }\n    }\n\n    if (exp[0] == '(') {\n        auto exp1 = string(exp.begin() + 1, exp.begin() + idx);\n        auto exp2 = string(exp.begin() + idx + 1, exp.end() - 1);\n        if (exp[idx] == '1') return !(calc(exp1, bits) && !calc(exp2, bits));\n        if (exp[idx] == '2') return calc(exp1, bits) | calc(exp2, bits);\n        if (exp[idx] == '3') return calc(exp1, bits) & calc(exp2, bits);\n    }\n}\n\nvoid solve(string str) {\n    bool flag = true;\n    for (int i = 0, len = opr.size(); i < len; i++) {\n        auto idx = str.find(opr[i]);\n        while (idx != string::npos) {\n            str.replace(idx, (int)opr[i].size(), num[i]);\n            idx = str.find(opr[i]);\n        }\n    }\n    int eq_idx = str.find(\"=\");\n\n    string exp1 = string(str.begin(), str.begin() + eq_idx);\n    string exp2 = string(str.begin() + eq_idx + 1, str.end());\n    for (int i = 0; i < (1 << 11); i++) {\n        if (calc(exp1, i) != calc(exp2, i)) {\n            flag = false;\n            break;\n        }\n    }\n\n    if (flag) cout << \"YES\" << endl;\n    else cout << \"NO\" << endl;\n}\n\nint main() {\n    string str;\n    while (cin >> str, str != \"#\") solve(str);\n\n    return 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include <iostream>\n#include <string>\n#include <sstream>\n#include <cctype>\nusing namespace std;\n\nistringstream iss;\nint a;\n\nbool parse(){\n\tchar ch;\n\tiss >> ch;\n\n\tif( isalpha( ch ) ){\n\t\tif( ch == 'T' ) return true;\n\t\tif( ch == 'F' ) return false;\n\t\treturn ( a >> ( ch - 'a' ) ) == 1;\n\t}\n\t\n\tif( ch == '-' ){\n\t\treturn !parse();\n\t}\n\n\tbool f1 = parse();\n\tiss >> ch;\n\tif( ch == '-' ) iss.ignore();\n\tbool f2 = parse();\n\tiss.ignore();\n\tif( ch == '*' )\treturn f1 && f2;\n\tif( ch == '+' ) return f1 || f2;\n\treturn f1 <= f2;\n}\n\nbool solve(const string &input){\n\tfor( a = 1 << 11; a--; ){\n\t\tiss.clear();\n\t\tiss.str(input);\n\n\t\tbool left = parse();\n\t\tiss.ignore();\n\t\tbool right = parse();\n\t\tif( left != right ) return false;\n\t}\n\treturn true;\n}\n\n\nint main(){\n\tstring s;\n\twhile( cin >> s, s[0] != '#' ){\n\t\tcout << (solve(s) ? \"YES\" : \"NO\") << endl;\n\t}\n}"
  },
  {
    "language": "C++",
    "code": "#include <algorithm>\n#include <cmath>\n#include <climits>\n#include <cstdio>\n#include <cstring>\n#include <fstream>\n#include <iostream>\n#include <list>\n#include <map>\n#include <queue>\n#include <set>\n#include <sstream>\n#include <stack>\n#include <string>\n#include <vector>\n\nusing namespace std;\n\n#define LOG(...) printf(__VA_ARGS__)\n//#define LOG(...)\n#define FOR(i,a,b) for(int i=(a);i<(b);++i)\n#define REP(i,n) for(int i=0;i<(int)(n);++i)\n#define ALL(a) (a).begin(),(a).end()\n#define EXIST(s,e) ((s).find(e)!=(s).end())\n#define SORT(c) sort((c).begin(),(c).end())\n\ntypedef long long ll;\ntypedef unsigned long long ull;\ntypedef vector<bool> vb;\ntypedef vector<int> vi;\ntypedef vector<ll> vll;\ntypedef vector<vb> vvb;\ntypedef vector<vi> vvi;\ntypedef vector<vll> vvll;\ntypedef pair<int, int> pii;\ntypedef pair<ll, ll> pll;\n\nconst int V[] = {\n    1 << 0,\n    1 << 1,\n    1 << 2,\n    1 << 3,\n    1 << 4,\n    1 << 6,\n    1 << 7,\n    1 << 8,\n    1 << 9,\n    1 << 10,\n    1 << 11,\n};\nconst string C[] = {\"a\", \"b\", \"c\", \"d\", \"e\", \"f\", \"g\", \"h\", \"i\", \"j\", \"k\"};\n\nstring replace_all(string &subject, const string &search, const string &replace) {\n    size_t pos = 0;\n    while ((pos = subject.find(search, pos)) != string::npos) {\n        subject.replace(pos, search.length(), replace);\n        pos += replace.length();\n    }\n    return subject;\n}\n\nstring parse(string expr, int var) {\n    replace_all(expr, \"--\", \"\");\n    replace_all(expr, \"->\", \">\");\n    REP(i, 11) {\n        replace_all(expr, C[i], var | V[i] ? \"T\" : \"F\");\n    }\n    while (expr.length() > 1) {\n        replace_all(expr, \"-F\", \"T\");\n        replace_all(expr, \"-T\", \"F\");\n        stack<int> parens;\n        REP(i, expr.length()) {\n            if (expr[i] == '(') {\n                parens.push(i);\n                continue;\n            } else if (expr[i] == ')') {\n                int j = parens.top(); parens.pop();\n                char a = expr[j+1];\n                char b = expr[j+3];\n                string ret;\n                switch (expr[j+2]) {\n                case '+': // OR\n                    if (a == 'F' && b == 'F') ret = \"F\";\n                    else ret = \"T\";\n                    break;\n                case '*': // AND\n                    if (a == 'T' && b == 'T') ret = \"T\";\n                    else ret = \"F\";\n                    break;\n                case '>': // IMP\n                    if (a == 'T' && b == 'F') ret = \"F\";\n                    else ret = \"T\";\n                    break;\n                }\n                replace_all(expr, string(expr.begin() + j, expr.begin() + i + 1), ret);\n                break;\n            }\n        }\n    }\n    return expr;\n}\n\nint main() {\n    string line;\n    while (getline(cin, line), line != \"#\") {\n        int eq = line.find('=');\n        string l(line.begin(), line.begin() + eq);\n        string r(line.begin() + eq + 1, line.end());\n        bool ok = true;\n        REP(var, (2 << 12) - 1) {\n            if (parse(l, var) != parse(r, var)) {\n                ok = false;\n                break;\n            }\n        }\n        cout << (ok ? \"YES\" : \"NO\") << endl;\n    }\n}"
  },
  {
    "language": "C++",
    "code": "#include <string>\n#include <iostream>\n#include <math.h>\n\nusing namespace std;\n\nstring str;\nint charsF[11];\nchar charsC[11];\nint cnt;\n\nvoid replaceAll(string &str, const string &a, const string &b) {\n  int i;\n  i = str.find(a);\n  while (i != -1) {\n    str.replace(i, a.size(), b);\n    i = str.find(a);\n  }\n}\n\nbool input() {\n  int i;\n\n  cin >> str;\n  if (str.at(0) == '#') return false;\n\n  fill(charsF, charsF + 11, -1);\n  fill(charsC, charsC + 11, '\\0');\n  cnt = 0;\n  for  (i = 0;  i < (int)str.size(); ++i ) {\n    if ('a' <=  str.at(i) && 'k' >= str.at(i) && charsF[str.at(i) - 'a'] == -1) {\n      charsF[str.at(i) - 'a'] = cnt;\n      charsC[cnt] = str.at(i);\n      cnt++;\n    }\n  }\n\n  return true;\n}\n\nint main() {\n  int i, j, k;\n  string b;\n  while (input()) {\n    int d = (int)pow((double)2, cnt);\n    //printf(\"%d %d\\n\", d, cnt);\n    for (i = 0; i < d; ++i ) {\n      b = string(str);\n      for (j = 0;  j < cnt; j++) {\n      //printf(\"%s %d\\n\", b.c_str(), 1 << j);\n        if (i & 1 << j) {\n          for (k = 0; (int)k < b.size(); k++) {\n            if (b[k] == charsC[j]) b[k] = 'T';\n          }\n        } else {\n          for (k = 0; (int)k < b.size(); k++) {\n            if (b[k] == charsC[j]) b[k] = 'F';\n          }\n        }\n      //printf(\"%s\\n\", b.c_str());\n      }\n\n      while (b.size() != 3) {\n        replaceAll(b, \"(T+T)\", \"T\");\n        replaceAll(b, \"(T+F)\", \"T\");\n        replaceAll(b, \"(F+T)\", \"T\");\n        replaceAll(b, \"(F+F)\", \"F\");\n        replaceAll(b, \"(T*T)\", \"T\");\n        replaceAll(b, \"(T*F)\", \"F\");\n        replaceAll(b, \"(F*T)\", \"F\");\n        replaceAll(b, \"(F*F)\", \"F\");\n        replaceAll(b, \"(T->T)\", \"T\");\n        replaceAll(b, \"(T->F)\", \"F\");\n        replaceAll(b, \"(F->T)\", \"T\");\n        replaceAll(b, \"(F->F)\", \"T\");\n        replaceAll(b, \"-T\", \"F\");\n        replaceAll(b, \"-F\", \"T\");\n      }\n      if ( b.c_str()[0] != b.c_str()[2] ) {\n        break;\n      }\n\n    }\n\n    if (i == d) printf(\"YES\\n\");\n    else printf(\"NO\\n\");\n\n  }\n\n  return 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include <iostream>\n#include <string>\nusing namespace std;\n\n#define rep(i, n) for(int (i) = 0; (i) < (n); ++(i))\n\nint cur;\nbool val[12];\n\nbool formula(string f)\n{\n    bool b;\n    switch(f[cur])\n    {\n        case 'T': ++cur; return true;\n        case 'F': ++cur; return false;\n        case '-': ++cur; return !formula(f);\n        case '(':\n            ++cur;\n            b = formula(f);\n            switch(f[cur])\n            {\n                case '*':\n                    ++cur;\n                    b &= formula(f);\n                    break;\n                case '+':\n                    ++cur;\n                    b |= formula(f);\n                    break;\n                case '-':\n                    cur += 2;\n                    b = !b | formula(f);\n                    break;\n            }\n            ++cur;\n            return b;\n        default: return val[f[cur++]-'a'];\n    }\n}\n\nint main()\n{\n    string eq;\n    \n    while(cin >> eq && eq != \"#\")\n    {\n        bool equal = false;\n        string lhs, rhs;\n        rep(i, eq.size())\n        {\n            if(eq[i] == '=') equal = true;\n            else if(!equal) lhs += eq[i];\n            else rhs += eq[i];\n        }\n        \n        bool res = true;\n        rep(i, 1 << 11)\n        {\n            rep(j, 11) val[j] = 1 & (i >> j);\n            cur = 0;\n            bool b1 = formula(lhs);\n            cur = 0;\n            bool b2 = formula(rhs);\n            if(b1 != b2) {\n                res = false; break;\n            }\n        }\n        \n        cout << (res ? \"YES\" : \"NO\") << endl;\n    }\n}"
  },
  {
    "language": "C++",
    "code": "#include <iostream>\n#include <string>\nusing namespace std;\n\nlong long int h[11];\nstring in;\nlong long int l[4][4] = { { 0, 0, 0, 1 }, { 0, 1, 1, 1 }, { 1, 1, 0, 1 }, { 1, 0, 0, 1 } };\n\npair< long long int, long long int > kansu( long long int n ) {\n\n  long long int hitei = 0;\n  long long int k[2];\n  long long int b = 0;\n  long long int e;\n\n  while( true ) {\n\n    if ( in[n] == '-' && in[n+1] != '>' ) {\n      hitei = 1;\n      n++;\n    }else if ( in[n] == '*' ) {\n      e = 0;\n      n++;\n    }else if ( in[n] == '+' ) {\n      e = 1;\n      n++;\n    }else if ( in[n] == '-' ) {\n      e = 2;\n      n += 2;\n    }else if ( in[n] == '=' ) {\n      e = 3;\n      n++;\n    }else {\n      if ( in[n] == '(' ) {\n\tpair< long long int, long long int > p = kansu( n + 1 );\n\tk[b] = p.first;\n\tn = p.second + 1;\n      }else if ( in[n] == 'T' ) {\n\tk[b] = 1;\n\tn++;\n      }else if ( in[n] == 'F' ) {\n\tk[b] = 0;\n\tn++;\n      }else {\n\tk[b] = h[ in[n] - 'a' ];\n\tn++;\n      }\n      if ( hitei == 1 ) k[b] ^= 1;\n      if ( b == 0 ) {\n\tb++;\n\thitei = 0;\n      }else {\n\t//\tcout << k[0] << \" \" << e << \" \" << k[1] << \" = \" << l[e][ k[0] * 2 + k[1] ] << endl;\n\treturn make_pair( l[e][ k[0] * 2 + k[1] ], n );\n      }\n    }\n\n  }\n\n}\n\nint main() {\n\n  while( true ) {\n\n    cin >> in;\n    if ( in == \"#\" ) break;\n\n    bool b = true;\n\n    for ( long long int i = 0; i < (1<<11); i++ ) {\n      long long int k = i;\n      for ( long long int j = 0; j < 11; j++ ) {\n\th[j] = k % 2;\n\tk /= 2;\n      }\n      if ( kansu( 0 ).first == 0 ) {\n\tb = false;\n\tbreak;\n      }\n    }\n    if ( b == true ) {\n      cout << \"YES\" << endl;\n    }else {\n      cout << \"NO\" << endl;\n    }\n\n  }\n\n  return 0;\n\n}"
  },
  {
    "language": "C++",
    "code": "#include<iostream>\n#include<algorithm>\n#include<string>\nusing namespace std;\n#define REP(i, b, e) for ( int i = b; i < (int)e; i++ )\n#define rep(i, n) REP(i, 0, n)\nstring leftf, rightf, exp;\nbool T[11], state;\nint pos;\n\nbool formula(){\n  if ( exp[pos] == '-' ){\n    pos++;\n    return !formula();\n  } else if ( exp[pos] == '(' ){\n    pos++;\n    bool x = formula();\n    bool y, v;\n    if ( exp[pos] == '+' ){\n      pos++;\n      y = formula();\n      v = (x || y );\n    } else if ( exp[pos] == '*' ){\n      pos++;\n      y = formula();\n      v = (x && y );\n    } else if ( exp[pos] == '-') {\n      pos+=2;\n      y = formula();\n      v = (x&&!y)?false:true;\n    }\n    pos++; // )\n\n    return v;\n  } else if ( exp[pos] == 'T' ) {\n    pos++;\n    return true;\n  } else if ( exp[pos] == 'F' ) {\n    pos++;\n    return false;\n  } else {\n    char ch = exp[pos];\n    pos++;\n    return T[ch-'a'];\n  }\n}\n\nvoid rec(int p){\n  if ( p == 11 ) {\n    pos = 0;\n    exp = leftf;\n    bool l = formula();\n    pos = 0;\n    exp = rightf;\n    bool r = formula();\n    if ( l != r ) state = false;\n    return;\n  }\n  T[p] = true;\n  rec(p+1);\n  T[p] = false;\n  rec(p+1);\n}\n\nvoid solve(){\n  state = true;\n  rec(0);\n  if ( state ) cout << \"YES\" << endl;\n  else cout << \"NO\" << endl;\n}\n\nmain(){\n  string line;\n  while(1){\n    cin >> line;\n    if ( line == \"#\" ) break;\n    leftf = line.substr(0, line.find(\"=\"));\n    rightf = line.substr(line.find(\"=\")+1, line.size());\n    solve();\n  }\n}"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\nusing namespace std;\n#define int long long   // <-----!!!!!!!!!!!!!!!!!!!\n\n#define rep(i,n) for (int i=0;i<(n);i++)\n#define rep2(i,a,b) for (int i=(a);i<(b);i++)\n#define rrep(i,n) for (int i=(n)-1;i>=0;i--)\n#define rrep2(i,a,b) for (int i=(a)-1;i>=b;i--)\n#define all(a) (a).begin(),(a).end()\n#define rall(a) (a).rbegin(),(a).rend()\n#define printV(_v) for(auto _x:_v){cout<<_x<<\" \";}cout<<endl\n#define printVS(vs) for(auto x : vs){cout << x << endl;}\n#define printVV(_vv) for(auto _v:_vv){for(auto _x:_v){cout<<_x<<\" \";}cout<<endl;}\n#define printP(p) cout << p.first << \" \" << p.second << endl\n#define printVP(vp) for(auto p : vp) printP(p);\n#define readV(_v) rep(j, _v.size()) cin >> _v[j];\n#define readVV(_vv) rep(i, _vv.size()) readV(_vv[i]);\n#define output(_x) cout << _x << endl;\n\ntypedef long long ll;\ntypedef pair<int, int> Pii;\ntypedef tuple<int, int, int> TUPLE;\ntypedef vector<int> vi;\ntypedef vector<vi> vvi;\ntypedef vector<vvi> vvvi;\ntypedef vector<Pii> vp;\nconst int inf = 1e9;\nconst int mod = 1e9 + 7;\n\ntypedef string::const_iterator State;\nconst int K = 11;\n\nstring format(string s) {\n    string t;\n    int i = 0;\n    while (i < s.size()) {\n        if (i + 1 < s.size() && s.substr(i, 2) == \"->\") {\n            t += '@';\n            i += 2;\n        } else {\n            t += s[i];\n            i++;\n        }\n    }\n    return t;\n}\n\nbool atom(State&, int);\nbool term(State&, int);\nbool formula(State&, int);\n\nbool atom(State &begin, int bits) {\n    // cerr << \"atom: \" << *begin << endl;\n\n    if (*begin == 'T') {\n        begin++;\n        return true;\n    } else if (*begin == 'F') {\n        begin++;\n        return false;\n    } else {\n        assert('a' <= *begin && *begin <= 'k');\n        int i = *begin - 'a';\n        begin++;\n        return (bits >> i) & 1;\n    }\n}\n\nbool term(State &begin, int bits) {\n    // cerr << \"term: \" << *begin << endl;\n\n    bool ret = formula(begin, bits);\n\n    if (*begin == '*') {\n        begin++;\n        ret &= formula(begin, bits);\n    } else if (*begin == '+') {\n        begin++;\n        ret |= formula(begin, bits);\n    } else {\n        assert(*begin == '@');\n        begin++;\n        int nxt = formula(begin, bits);\n        ret = (!ret || nxt);\n    }\n\n    return ret;\n}\n\nbool formula(State &begin, int bits) {\n    // cerr << \"formula: \" << *begin << endl;\n    bool ret;\n\n    if (isalpha(*begin)) {\n        ret = atom(begin, bits);\n    } else if (*begin == '-') {\n        begin++;\n        ret = !formula(begin, bits);\n    } else {\n        assert(*begin == '(');\n        begin++;\n        ret = term(begin, bits);\n        assert(*begin == ')');\n        begin++;\n    }\n\n    return ret;\n}\n\nbool solve(string s) {\n    s = format(s); // convert \"->\" to \"@\"\n    // cerr << s << endl;\n\n    string s1, s2;\n    bool reading_s1 = true;\n    rep(i, s.size()) {\n        if (s[i] == '=') {\n            reading_s1 = false;\n        } else {\n            (reading_s1 ? s1 : s2) += s[i];\n        }\n    }\n    // cerr << s1 << \" \" << s2 << endl;\n\n    rep(bits, 1 << K) {\n        State begin1 = s1.begin();\n        State begin2 = s2.begin();\n        if (formula(begin1, bits) ^ formula(begin2, bits)) {\n            return false;\n        }\n    }\n\n    return true;\n}\n\nsigned main() {\n    std::ios::sync_with_stdio(false);\n    std::cin.tie(0);\n\n    string s;\n    while (cin >> s, s[0] - '#') {\n        cout << (solve(s) ? \"YES\" : \"NO\") << endl;\n    }\n}"
  },
  {
    "language": "C++",
    "code": "#include <iostream>\n#include <complex>\n#include <sstream>\n#include <string>\n#include <algorithm>\n#include <deque>\n#include <list>\n#include <map>\n#include <numeric>\n#include <queue>\n#include <vector>\n#include <set>\n#include <limits>\n#include <cstdio>\n#include <cctype>\n#include <cmath>\n#include <cstring>\n#include <cstdlib>\n#include <ctime>\nusing namespace std;\n#define REP(i, j) for(int i = 0; i < (int)(j); ++i)\n#define FOR(i, j, k) for(int i = (int)(j); i < (int)(k); ++i)\n#define P pair<int, int>\n#define SORT(v) sort((v).begin(), (v).end())\n#define REVERSE(v) reverse((v).begin(), (v).end())\n\nstring s;\nint now;\n\nbool check(bool x, char op, bool y){\n  if(op == '*'){\n    if(x && y) return true;\n    else return false;\n  } else if(op == '+'){\n    if(!x && !y) return false;\n    else return true;\n  } else if(op == '>'){\n    if(x && !y) return false;\n    return true;\n  }\n  return false;\n}\n\nbool formula(){\n  //cout <<s <<\", \" <<s[now] <<endl;\n  if(s[now] == 'T'){\n    ++now;\n    return true;\n  } else if(s[now] == 'F'){\n    ++now;\n    return false;\n  } else if(s[now] == '-'){\n    ++now;\n    bool res = formula();\n    return !res;\n  } else if(s[now] == '('){\n    ++now;\n    bool x = formula();\n    char op = s[now];\n    ++now;\n    bool y = formula();\n    //cout <<x <<\" \" <<op <<\" \" <<y <<endl;\n    return check(x, op, y);\n  }\n  return false;\n}\n\nmap<char, char> get_m(int bit){\n  map<char, char> ret;\n  for(int i = 0; i < 11; ++i){\n    if(bit & (1 << i)) ret['a' + i] = 'T';\n    else ret['a' + i] = 'F';\n  }\n  return ret;\n}\n\nbool calc(){\n  stringstream left_ss, right_ss;\n  bool left_end = false;\n  REP(i, s.length()){\n    if(s[i] == '=') left_end = true;\n    else{\n      if(left_end) right_ss << s[i];\n      else left_ss << s[i];\n    }\n  }\n  string left = left_ss.str(), right = right_ss.str();\n  REP(i, s.length())\n  REP(i, (1 << 11)){\n    string tmp_l = left, tmp_r = right;\n    map<char, char> m = get_m(i);\n    REP(i, left.length()) if(isalpha(left[i]) && left[i] != 'T' && left[i] != 'F') left[i] = m[left[i]];\n    REP(i, right.length()) if(isalpha(right[i]) && right[i] != 'T' && right[i] != 'F') right[i] = m[right[i]];\n    s = left; now = 0;\n    bool left_ans = formula();\n    s = right; now = 0;\n    bool right_ans = formula();\n    //debug\n    //cout <<left <<\", \" <<right <<\" | \" <<left_ans <<\", \" <<right_ans <<endl;\n    if(left_ans != right_ans){\n      return false;\n    }\n    left = tmp_l; right = tmp_r;\n  }\n  return true;\n}\n\nint main() {\n  while(cin >>s && s != \"#\"){\n    stringstream ss;\n    REP(i, s.length()){\n      if(i + 1 != s.length() && s[i] == '-' && s[i + 1] == '>'){\n        ss << '>';\n        ++i;\n      } else{\n        ss << s[i];\n      }\n    }\n    s = ss.str();\n    cout <<(calc() ? \"YES\" : \"NO\") <<endl;\n  }\n  return 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include <functional>\n#include <iostream>\n#include <string>\n#include <unordered_set>\n#include <vector>\n#define loop(i, a, n) for (int i = (a); i < (n); i++)\n#define rep(i, n) loop(i, 0, n)\ntemplate<typename A> using F = std::function<A>;\nusing namespace std;\n \ntemplate<typename T> struct ParseResult {\n  bool succeeded;\n  T object;\n  int pos;\n  ParseResult(const bool succeeded, const T &object, const int pos) : succeeded(succeeded), object(object), pos(pos) {}\n  friend std::ostream &operator<<(std::ostream &os, const ParseResult<T> &p) { return os << '{' << (p.succeeded ? \"true\" : \"false\") << ',' << p.object << ',' << p.pos << '}'; }\n};\n \ntemplate<typename T> using Parser = std::function<ParseResult<T>(const std::string&, int)>;\n \nParser<std::string> token(std::string s) {\n  const auto n = s.size();\n  return [n = std::move(n), s = std::move(s)](const std::string &target, const int pos) {\n    if (target.size() < n) return ParseResult<std::string>(false, {}, pos);\n    return target.substr(pos, n) == s ? ParseResult<std::string>(true, s, pos + n) : ParseResult<std::string>(false, {}, pos);\n  };\n}\n \ntemplate<typename T> Parser<T> operator||(Parser<T> p1, Parser<T> p2) {\n  return [p1 = std::move(p1), p2 = std::move(p2)](const std::string &target, const int pos) {\n    auto r = p1(target, pos);\n    if (r.succeeded) return r;\n    r = p2(target, pos);\n    if (r.succeeded) return r;\n    return ParseResult<T>(false, {}, pos);\n  };\n}\n \ntemplate<typename T1, typename T2> Parser<std::pair<T1, T2>> operator+(Parser<T1> p1, Parser<T2> p2) {\n  return[p1 = std::move(p1), p2 = std::move(p2)](const std::string &target, const int pos) {\n    auto r1 = p1(target, pos);\n    if (!r1.succeeded) return ParseResult<std::pair<T1, T2>>(false, {}, pos);\n    auto r2 = p2(target, r1.pos);\n    if (!r2.succeeded) return ParseResult<std::pair<T1, T2>>(false, {}, pos);\n    return ParseResult<std::pair<T1, T2>>(true, {r1.object, r2.object}, r2.pos);\n  };\n}\n \ntemplate<typename T1, typename T2> Parser<T2> operator>>(Parser<T1> p1, Parser<T2> p2) {\n  return [p1 = std::move(p1), p2 = std::move(p2)](const std::string &target, const int pos) {\n    auto r1 = p1(target, pos);\n    if (!r1.succeeded) return ParseResult<T2>(false, {}, pos);\n    auto r2 = p2(target, r1.pos);\n    if (!r2.succeeded) return ParseResult<T2>(false, {}, pos);\n    return ParseResult<T2>(true, r2.object, r2.pos);\n  };\n}\n \ntemplate<typename T1, typename T2> Parser<T1> operator<<(Parser<T1> p1, Parser<T2> p2) {\n  return [p1 = std::move(p1), p2 = std::move(p2)](const std::string &target, const int pos) {\n    auto r1 = p1(target, pos);\n    if (!r1.succeeded) return ParseResult<T1>(false, {}, pos);\n    auto r2 = p2(target, r1.pos);\n    if (!r2.succeeded) return ParseResult<T1>(false, {}, pos);\n    return ParseResult<T1>(true, r1.object, r2.pos);\n  };\n}\n \nParser<char> oneOf(const std::string &s) {\n  std::unordered_set<char> d;\n  for (auto &c : s) d.insert(c);\n  return [d = std::move(d)](const std::string &target, const int pos) {\n    if (target.size() <= pos) return ParseResult<char>(false, {}, pos);\n    char c = target[pos];\n    return d.count(c) ? ParseResult<char>(true, c, pos + 1) : ParseResult<char>(false, {}, pos);\n  };\n}\n \ntemplate<typename T, typename S, typename F> Parser<S> fmap(Parser<T> p, F &&f) {\n  return [p = std::move(p), f = std::forward<F>(f)](const std::string &target, const int pos) {\n    auto r = p(target, pos);\n    return r.succeeded ? ParseResult<S>(true, f(r.object), r.pos) : ParseResult<S>(false, {}, r.pos);\n  };\n}\n \ntemplate<typename T, typename F> Parser<T> lazy(const F &f) {\n  bool instantiated = false;\n  Parser<T> p;\n  return [f = std::move(f), p = std::move(p), instantiated = std::move(instantiated)](const std::string &target, const int pos) mutable {\n    if (!instantiated) {\n      p = f();\n      instantiated = true;\n    }\n    return p(target, pos);\n  };\n}\ntemplate<typename T> Parser<T> make_view(Parser<T> &&f) {\n  return [f = std::make_shared<T>(std::move(f))](const std::string &target, const int pos) {\n    return f(target, pos);\n  };\n}\n \nstruct SyntaxTree {\n  string op;\n  char value;\n  vector<SyntaxTree> children;\n  SyntaxTree() {}\n  SyntaxTree(const string &op, const char value, const vector<SyntaxTree> &children) : op(op), value(value), children(children) {}\n};\n \nint main() {\n  Parser<SyntaxTree> formulaP = make_view<SyntaxTree>([&]() {\n    auto andP = fmap<pair<SyntaxTree, SyntaxTree>, SyntaxTree>((token(\"(\") >> formulaP << token(\"*\")) + (formulaP << token(\")\")), [](auto &o) { return SyntaxTree(\"*\", {}, {o.first, o.second}); });\n    auto orP = fmap<pair<SyntaxTree, SyntaxTree>, SyntaxTree>((token(\"(\") >> formulaP << token(\"+\")) + (formulaP << token(\")\")), [](auto &o) { return SyntaxTree(\"+\", {}, {o.first, o.second}); });\n    auto impP = fmap<pair<SyntaxTree, SyntaxTree>, SyntaxTree>((token(\"(\") >> formulaP << token(\"->\")) + (formulaP << token(\")\")), [](auto &o) { return SyntaxTree(\"->\", {}, {o.first, o.second}); });\n    auto notP = fmap<SyntaxTree, SyntaxTree>(token(\"-\") >> formulaP, [](auto &o) { return SyntaxTree(\"-\", {}, {o}); });\n    auto valP = fmap<char, SyntaxTree>(oneOf(\"abcdefghijkTF\"), [](char x) { return SyntaxTree({}, x, {}); });\n    return andP || orP || impP || notP || valP;\n  }());\n  auto equationP = (formulaP << token(\"=\")) + formulaP;\n  string s;\n  while (cin >> s, s != \"#\") {\n    auto r = equationP(s, 0);\n    bool isValid = true;\n    rep(i, 1 << 11) {\n      auto toBool = [&](char c) -> bool {\n        if (c == 'T') return true;\n        if (c == 'F') return false;\n        return i >> (c - 'a') & 1;\n      };\n      F<bool(const SyntaxTree&)> evalF = [&](const SyntaxTree &f) {\n        switch (f.children.size()) {\n          case 0: return toBool(f.value);\n          case 1: return !evalF(f.children[0]);\n          case 2:\n            if (f.op == \"*\") return evalF(f.children[0]) && evalF(f.children[1]);\n            if (f.op == \"+\") return evalF(f.children[0]) || evalF(f.children[1]);\n            if (f.op == \"->\") return !evalF(f.children[0]) || evalF(f.children[1]);\n        }\n      };\n      isValid &= evalF(r.object.first) == evalF(r.object.second);\n    }\n    cout << (isValid ? \"YES\" : \"NO\") << endl;\n  }\n}"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\n  \nusing namespace std;\n  \n#define rep(i,n) REP(i,0,n)\n#define REP(i,s,e) for(int i=(s); i<(int)(e); i++)\n#define pb push_back\n#define all(r) r.begin(),r.end()\n#define rall(r) r.rbegin(),r.rend()\n#define fi first\n#define se second\n  \ntypedef long long ll;\ntypedef vector<int> vi;\ntypedef vector<ll> vl;\ntypedef pair<int, int> pii;\ntypedef pair<ll, ll> pll;\n \nconst int INF = 1e9;\nconst ll MOD = 1e9 + 7;\ndouble EPS = 1e-8;\n#define DEBUG_MODE\n#ifdef DEBUG_MODE\n#define dump(x) cout << #x << \" : \" << x << endl\n#define LINE cout << \"line : \" << __LINE__ << endl\n#define dumpV(v) cout << #v << \" : [\"; for(auto& t : v) cout << t << \", \"; cout<<\"]\" << endl;\n#define STOP assert(false);\n#else\n#define dump(x) ;\n#define LINE \t;\n#define dumpV(v);\n#define STOP \t;\n#endif\n\nnamespace std{\n  template<class S,class T>\n  ostream &operator <<(ostream& out,const pair<S,T>& a){\n    out<<'('<<a.fi<<\", \"<<a.se<<')';\n    return out;\n  }\n}\n\n\nvector<string> split(const string& s, char c = ' ') {\n\tvector<string> ret;\n\tstringstream ss(s);\n\tstring t;\n\twhile(getline(ss, t, c)) ret.push_back(t);\n\treturn ret;\n}\n\ntypedef string::const_iterator State;\nconst int BITS = 11;\nbool minus(bool a) {return (!a);}\nbool plus_(bool a, bool b) {return (a|b);}\nbool muit(bool a, bool b) {return a&b;}\nbool incl(bool a, bool b) {return plus_(!a, b);}\n\nbool atom(State&, int);\nbool term(State&, int);\nbool formula(State&, int);\n\nbool atom(State& now, int mask) {\n\tif(*now == 'T') {\n\t\tnow++;\n\t\treturn true;\n \t}\n \tif(*now == 'F') {\n \t\tnow++;\n \t\treturn false;\n \t}\n \tassert(*now >= 'a' && *now <= ('a'+BITS));\n \tint k = *now - 'a';\n \tnow++;\n \treturn mask & (1 << k);\n}\nbool term(State& now, int mask) {\n\tbool ret = formula(now, mask);\n\tif(*now == '*') {\n\t\tnow++;\n\t\treturn muit(ret, formula(now, mask));\n\t}\n\tif(*now == '+') {\n\t\tnow++;\n\t\treturn plus_(ret, formula(now, mask));\n\t}\n\tif(*now == '/') {\n\t\tnow++;\n\t\treturn incl(ret, formula(now, mask));\n\t}\n\tassert(false);\n}\nbool formula(State& now, int mask) {\n\tif((*now >= 'a' && *now <= ('a'+BITS)) || *now == 'T' || *now == 'F') {\n\t\treturn atom(now, mask);\n\t}\n\tif(*now == '-') {\n\t\tnow++;\n\t\treturn !formula(now, mask);\n\t}\n\tif(*now == '(') {\n\t\tnow++;\n\t\tbool tmp = term(now, mask);\n\t\tnow++;\n\t\treturn tmp;\n\t}\n\tdump(*now);\n\tassert(false);\n}\n\nint main(){\n\tstring s;\n\twhile(cin >> s) {\n\t\tif(s == \"#\") break;\n\t\tauto _v = split(s, '=');\n\t\tvector<string> v(2);\n\t\trep(i, 2) {\n\t\t\trep(j, _v[i].size()) {\n\t\t\t\tif(j+1 < _v[i].size() && _v[i][j] == '-') {\n\t\t\t\t\tj++;\n\t\t\t\t\tif(_v[i][j] == '>') v[i] += '/';\n\t\t\t\t\telse if(_v[i][j] == '-');\n\t\t\t\t\telse j--, v[i]+='-';\n\t\t\t\t}\n\t\t\t\telse v[i] += _v[i][j];\n\t\t\t}\n\t\t}\n\t\t// dump(v[0]);\n\t\t// dump(v[1]);\n\t\tbool ans = true;\n\t\trep(mask, 1<<BITS) {\n\t\t\tState it0 = v[0].begin();\n\t\t\tState it1 = v[1].begin();\n\t\t\tif(formula(it0, mask) ^ formula(it1, mask)) ans = false;\n\t\t}\n\t\tcout << (ans ? \"YES\" : \"NO\") << endl;\n\t\t\n\t}\n\treturn 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include<iostream>\n#include<vector>\n#include<string>\n#include<algorithm>\n#define all(c) c.begin(),c.end()\n#define uni(c) c.erase(unique(c.begin(),c.end()),c.end())\n#define pb push_back\nusing namespace std;\n\nint expr(string& s, int& i);\nint term(string& s, int& i);\nint factor(string& s, int& i);\nint number(string& s, int& i);\n\n\nint expr(string& s, int& i) {\n  int val = term(s, i);\n  while(s[i] == '+' || s[i] == '-') {\n    char op = s[i];\n    i++;\n  \tif(!isdigit(s[i])){\n  \t\ti++;\n  \t\tint val2 = term(s, i);\n  \t\tif(val==1&&val2==0){\n  \t\t\tval=0;\n  \t\t}else{\n  \t\t\tval=1;\n  \t\t}\n  \t}else{\n  \t  int val2 = term(s, i);\n    \tif (op == '+') val |= val2;\n  \t}\n  }\n  return val;\n}\n\nint term(string& s, int& i) {\n  int val = factor(s, i);\n  while(s[i] == '*') {\n    char op = s[i];\n    i++;\n    int val2 = factor(s, i);\n    if (op == '*') val *= val2;\n  }\n  return val;\n}\n\nint factor(string& s, int& i) {\n\tint flag=0;\n\tif(s[i]=='-'){\n\t\tflag=1;\n\t\ti++;\n\t}\n\tif (isdigit(s[i])){\n\t\tif(flag)\n\t\t\treturn flag^number(s, i);\n\t\t\treturn number(s,i);\n\t}\n\n  // ここで構文が正しければ s[i] == '(' となる\n  i++; // '('を読み飛ばす\n  int ret = expr(s, i);\n  i++; // ')'を読み飛ばす\n\tif(flag)\n\treturn flag^ret;\n\treturn ret;\n}\n\nint number(string& s, int& i) {\n  int n = s[i++] - '0';\n  while(isdigit(s[i])) n = n*10 + s[i++] - '0';\n  return n;\n}\n\nint main(){\n\tstring s;\n\twhile(cin>>s,s!=\"#\"){\n\t\tint eq=0;\n\t\tstring a,b;\n\t\tfor(;s[eq]!='=';eq++);\n\t\ta=s.substr(0,eq),b=s.substr(eq+1,s.size()-eq);\n\t\t//cout<<a<<\" \"<<b<<endl;\n\t\tvector<char> ap;\n\t\tfor(int i=0;i<s.size();i++){\n\t\t\tif(isalpha(s[i]))\n\t\t\t\tap.pb(s[i]);\n\t\t}\n\t\tsort(all(ap));\n\t\tuni(ap);\n\t\tbool flag=true;\n\t\tfor(int i=0;i<(1<<ap.size());i++){\n\t\t\tstring x=a,y=b;\n\t\t\tfor(int j=0;j<ap.size();j++){\n\t\t\t\tchar c=ap[j];\n\t\t\t\tbool wh=false;\n\t\t\t\tif((1<<j)&i)\n\t\t\t\t\twh=true;\n\t\t\t\tfor(int k=0;k<x.size();k++){\n\t\t\t\t\tif(x[k]==c){\n\t\t\t\t\t\tif(wh)\n\t\t\t\t\t\t\tx[k]='1';\n\t\t\t\t\t\telse\n\t\t\t\t\t\t\tx[k]='0';\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t\tfor(int k=0;k<y.size();k++){\n\t\t\t\t\tif(y[k]==c){\n\t\t\t\t\t\tif(wh)\n\t\t\t\t\t\t\ty[k]='1';\n\t\t\t\t\t\telse\n\t\t\t\t\t\t\ty[k]='0';\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t}\n\t\t\t\n\t\t\t\n\t\t\t\\if(expr(x,0)!=expr(y,0)){\n\t\t\t\tcout<<\"NO\"<<endl;\n\t\t\t\tflag=false;\n\t\t\t\tbreak;\n\t\t\t}\n\t\t\t\n\t\t}\n\t\tif(flag)\n\t\t\tcout<<\"YES\"<<endl;\n\t}\n\treturn 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include <vector>\n#include <iostream>\n#include <utility>\n#include <algorithm>\n#include <string>\n#include <deque>\n#include <queue>\n#include <functional>\n#include <cmath>\n#include <iomanip>\n#include <map>\n#include <numeric>\n#include <list>\n#include <assert.h>\n#include <math.h>\n#include <valarray>\n#include <stdio.h>\n#include <algorithm>\n#include <set>\n#include <complex>\n#include <list>\n\nusing namespace std;\ntypedef long long int LL;\ntypedef pair<long long int, long long int> pii;\ntypedef pair<double, double> pdd;\n\n#define SORT(c) sort((c).begin(),(c).end())\n#define BACKSORT(c) sort((c).begin(),(c).end(),std::greater<LL>())\n#define FOR(i,a,b) for(LL i=(a);i<(b);++i)\n#define REP(i,n)  FOR(i,0,n)\n\nbool equation(string& s, int& i,vector<bool>& v);\nbool formula(string& s, int& i, vector<bool>& v);\n\nbool equation(string& s, int& i, vector<bool>& v) {\n\tbool a = formula(s, i,v);\n\ti++;\n\tbool b = formula(s, i, v);\n\treturn a == b;\n}\n\nbool formula(string& s, int& i, vector<bool>& v) {\n\tif (s[i] == 'T') {\n\t\ti++;\n\t\treturn true;\n\t}\n\telse\n\t\tif (s[i] == 'F') {\n\t\t\ti++;\n\t\t\treturn false;\n\n\t\t}else\n\t\t\tif ('a' <= s[i] && s[i] <= 'k') {\n\t\t\t\tint aa = s[i] - 'a';\n\t\t\t\ti++;\n\t\t\t\treturn v[aa];\n\t\t\t}else\n\t\t\t\tif (s[i] == '-') {\n\t\t\t\t\ti++;\n\t\t\t\t\tbool a = formula(s, i, v);\n\t\t\t\t\treturn !a;\n\t\t\t\t}\n\t\t\t\telse {\n\t\t\t\t\ti++;\n\t\t\t\t\tbool a = formula(s, i, v);\n\t\t\t\t\tchar op = s[i];\n\t\t\t\t\tif (op == '-') {\n\t\t\t\t\t\ti++;\n\t\t\t\t\t}\n\t\t\t\t\ti++;\n\t\t\t\t\tbool b = formula(s, i, v);\n\t\t\t\t\ti++;\n\t\t\t\t\tif (op == '*') {\n\t\t\t\t\t\treturn a&&b;\n\t\t\t\t\t}else\n\t\t\t\t\t\tif (op == '+') {\n\t\t\t\t\t\t\treturn a || b;\n\t\t\t\t\t\t}\n\t\t\t\t\t\telse {\n\t\t\t\t\t\t\treturn (!a) || b;\n\t\t\t\t\t\t}\n\t\t\t\t}\n}\n\n\nint main()\n{\n\twhile (true) {\n\t\tstring ss;\n\t\tcin >> ss;\n\t\tif (ss[0] == '#') { break; }\n\t\tbool flag = true;\n\t\tfor (int j = 0; j < 2048; ++j) {\n\t\t\tint bai = 1;\n\t\t\tfor (int k = 0; k < 11; ++k) {\n\t\t\t\tvector<bool> v(9999,false);\n\t\t\t\tif (j%(bai*2)-j%(bai*1)==0) {\n\t\t\t\t\tv[k] = false;\n\t\t\t\t}\n\t\t\t\telse {\n\t\t\t\t\tv[k] = true;\n\t\t\t\t}\n\t\t\t\tint index = 0;\n\t\t\t\tif (!equation(ss, index, v)) {\n\t\t\t\t\tflag = false;\n\t\t\t\t\tbreak;\n\t\t\t\t\t}\n\t\t\t}\n\t\t}\n\t\tif (flag) {\n\t\t\tcout << \"YES\" << endl;\n\t\t}\n\t\telse {\n\t\t\tcout << \"NO\" << endl;\n\t\t}\n\t}\n\n}"
  },
  {
    "language": "C++",
    "code": "#include<iostream>\n#include<string>\n#include<algorithm>\n#include<vector>\n#include<stack>\n#include<queue>\n#include<cstring>\n#include<cstdio>\n#include<cmath>\nusing namespace std;\n\n#define rep(i,n) for(int i=0;i<n;i++)\n#define REP(n) rep(i,n)\n#define onen(i,n) for(int i=1;i<n+1;i++)\n\nint var;\n\nstring ss,rh,lh;\n\nbool solve(string s)\n{\n    //cout << s << endl;\n    if(s.size() == 1)//1 letter\n    {\n        if(s == \"T\") return true;\n        if(s == \"F\") return false;\n        return ( (var>> (s[0]-'a') )&1) ;\n    }\n\n    //2 letter\n    if(s.size() == 2 && s[0] == '-') return !solve(s.substr(1,1));\n\n    int bra = 0;\n    if(s[0] == '-' && s[1] == '(')\n    {\n        bra = 1;\n        for(int i=2;i<s.size() - 1;i++)\n        {\n            if(s[i] == '(') bra++;\n            if(s[i] == ')') bra--;\n        \n            if(bra == 0) break;\n        }\n        if(bra == 1) return !solve(s.substr(1,s.size() -1));\n    }\n    \n    bra = 0;\n    bool inside = true;\n    //2 operand\n    REP(s.size() -1)\n    {\n        if(s[i] == '(') bra++;\n        if(s[i] == ')') bra--;\n        if(bra == 0) inside == false;\n\n        if(s[i] == '+' && bra==0) return solve(s.substr(0,i)) || solve(s.substr(i+1, s.size() - 1 - i));\n\n        if(s[i] == '*' && bra==0) return solve(s.substr(0,i)) && solve(s.substr(i+1, s.size() - 1 - i));\n \n        if(s[i] == '>' && bra==0)\n        {\n            if( (solve(s.substr(0,i-1)) ==true) && (solve(s.substr(i+1,s.size()-i-1)) == false) ) return false;\n            else return true;\n        }\n    }\n\n    if(inside) return solve(s.substr(1, s.size()-2) );\n \n    cout << \"no match\" << endl;\n    return 0;\n}\n\nint main()\n{\n    while(cin >> ss  && ss!=\"#\")\n    {\n        int m2 = 0;\n        while(1)\n        {\n            m2 = ss.find(\"--\");\n            if(m2 == -1) break;\n            ss.replace(m2, 2, \"\");\n        }\n        //cout << ss << endl;\n        \n        REP(ss.size())if(ss[i] == '=')\n        {\n            lh = ss.substr(0,i);\n            rh = ss.substr(i+1,ss.size()-i-1);\n            break;\n        }\n        int ans = true;\n\n        for(var = 0;var<( 1 << 11);var++)if(solve(lh) != solve(rh)) ans = false;\n        //if(solve(lh) != solve(rh)) ans = false;\n        if(ans ) cout << \"YES\" << endl;\n        else cout << \"NO\" << endl;\n    }\n\n    return 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\n\nusing namespace std;\n\nclass ParseError {};\ntypedef string::const_iterator State;\n\nbool expression(State &begin) {\n\tbool ret;\n\tif(*begin == 'T'){begin++; ret = true;}\n\telse if(*begin == 'F'){begin++; ret = false;}\n\telse if(*begin == '-'){begin++; ret = !expression(begin);}\n\telse {\n\t\tbegin++;\n\t\tbool a = expression(begin);\n\t\tif(*begin == '*'){\n\t\t\tbegin++;\n\t\t\tret = a && expression(begin);\n\t\t}\n\t\telse if(*begin == '-' && *(begin+1) == '>'){\n\t\t\tbegin++; begin++;\n\t\t\tret = (a && !expression(begin) ? false : true);\n\t\t}\n\t\telse if (*begin == '+') {\n\t\t\tbegin++;\n\t\t\tret = a || expression(begin);\n\t\t}\n\t\tbegin++;\n\t}\n\treturn ret;\n}\n\nint main(){\n\tstring e;\n\twhile(cin >> e, e != \"#\"){\n\t\tbool possible = true;\n\t\tfor(int i=0; i < 1<<11; i++){\n\t\t\tstring s = e;\n\t\t\tstring t = \"abcdefghijk\";\n\t\t\tfor(int j=0; j < s.size(); j++){\n\t\t\t\tfor(int k=0; k < t.size(); k++){\n\t\t\t\t\tif(s[j] == t[k]) s[j] = ((i >> k) & 1 == 1 ? 'T' : 'F');\n\t\t\t\t}\n\t\t\t}\n\t\t\tstring a, b;\n\t\t\tfor(int i=0; i< s.size(); i++) if(s[i] == '='){a = s.substr(0, i); b = s.substr(i+1);}\n\t\t\tState abegin = a.begin();\n\t\t\tState bbegin = b.begin();\n\n\t\t\tif(!(expression(abegin) == expression(bbegin))){possible = false; break;}\n\t\t}\n\t\tcout << (possible ? \"YES\" : \"NO\") << endl;\n\t}\n}"
  },
  {
    "language": "C++",
    "code": "#include<iostream>\n#include<string>\nusing namespace std;\n\nint mynot(int a){\n\tif(a==1) return 0;\n\treturn 1;\n}\n\nint myand(int a,int b){\n\tif(a==1 && b==1) return 1;\n\treturn 0;\n}\n\nint myor(int a,int b){\n\tif(a==0 && b==0) return 0;\n\treturn 1;\n}\n\nint naraba(int a,int b){\n\tif(a==0 || (a==1 && b==1)) return 1;\n\treturn 0;\n}\n\nstring s;\nint bit=0;\nint p=0;\n\nint to_int(char a){\n\tif(a=='T') return 1;\n\tif(a=='F') return 0;\n\tint k=a-'a';\n\tif(bit & (1<<k)) return 1;\n\treturn 0;\n}\n\n\nint calc(){\n\tif(isalpha(s[p])) return to_int(s[p++]);\n\tif(s[p]=='-'){\n\t\tp++;\n\t\treturn mynot(calc());\n\t}\n\tif(s[p]=='('){\n\t\tp++;\n\t\tint res1=calc();\n\t\tif(s[p]=='*'){\n\t\t\tp++;\n\t\t\tint res2=calc();\n\t\t\tp++;\n\t\t\treturn myand(res1,res2);\n\t\t}\n\t\telse if(s[p]=='+'){\n\t\t\tp++;\n\t\t\tint res2=calc();\n\t\t\tp++;\n\t\t\treturn myor(res1,res2);\n\t\t}\n\t\telse if(s[p]=='-'){\n\t\t\tp+=2; //>を読み飛ばす\n\t\t\tint res2=calc();\n\t\t\tp++;\n\t\t\treturn naraba(res1,res2);\n\t\t}\n\t}\n\tcerr<<\"Error\"<<endl;\n\treturn -1;\n}\n\n\nint main()\n{\n\twhile(cin>>s && s[0]!='#'){\n\n\t\tbool ok=true;\n\t\tfor(bit=0;bit<(1<11);bit++){\n\t\t\tp=0;\n\t\t\tint ans1=calc();\n\t\t\tp++;\n\t\t\tint ans2=calc();\n\t\t\tif(ans1!=ans2){ok=false;break;}\n\t\t}\n\t\tif(ok) cout<<\"YES\"<<endl;\n\t\telse cout<<\"NO\"<<endl;\n\t}\n\treturn 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include<iostream>\n#include<string>\n#define MAX 11\nusing namespace std;\nbool o;\nvoid rec(string ss){\n  if(!o) return;\n  //cout << s << endl;\n  string s =ss;\n  bool f;\n  int p;\n\n  \n  while(s.find(\"-0\")!=-1){\n    p=s.find(\"-0\");\n    s[p]='1';s[p+1]=' ';\n    f=true;\n  }\n  while(s.find(\"-1\")!=-1){\n    p=s.find(\"-1\");\n    s[p]='0';s[p+1]=' ';\n    f=true;\n  }\n  \n  \n  while(s.find(\"(0*0)\")!=-1){\n    p=s.find(\"(0*0)\");\n    s[p]='0';s[p+1]=' ';s[p+2]=' ';s[p+3]=' ';s[p+4]=' ';\n    f=true;\n  }\n  while(s.find(\"(0*1)\")!=-1){\n    p=s.find(\"(0*1)\");\n    s[p]='0';s[p+1]=' ';s[p+2]=' ';s[p+3]=' ';s[p+4]=' ';\n    f=true;\n  }\n  while(s.find(\"(1*0)\")!=-1){\n    p=s.find(\"(1*0)\");\n    s[p]='0';s[p+1]=' ';s[p+2]=' ';s[p+3]=' ';s[p+4]=' ';\n    f=true;\n  }\n  while(s.find(\"(1*1)\")!=-1){\n    p=s.find(\"(1*1)\");\n    s[p]='1';s[p+1]=' ';s[p+2]=' ';s[p+3]=' ';s[p+4]=' ';\n    f=true;\n  }\n  while(s.find(\"(0+0)\")!=-1){\n    p=s.find(\"(0+0)\");\n    s[p]='0';s[p+1]=' ';s[p+2]=' ';s[p+3]=' ';s[p+4]=' ';\n    f=true;\n  }\n  while(s.find(\"(0+1)\")!=-1){\n    p=s.find(\"(0+1)\");\n    s[p]='1';s[p+1]=' ';s[p+2]=' ';s[p+3]=' ';s[p+4]=' ';\n    f=true;\n  }\n  while(s.find(\"(1+0)\")!=-1){\n    p=s.find(\"(1+0)\");\n    s[p]='1';s[p+1]=' ';s[p+2]=' ';s[p+3]=' ';s[p+4]=' ';\n    f=true;\n  }\n  while(s.find(\"(1+1)\")!=-1){\n    p=s.find(\"(1+1)\");\n    s[p]='1';s[p+1]=' ';s[p+2]=' ';s[p+3]=' ';s[p+4]=' ';\n    f=true;\n  }\n  \n  while(s.find(\"(0->0)\")!=-1){\n    p=s.find(\"(0->0)\");\n    s[p]='1';s[p+1]=' ';s[p+2]=' ';s[p+3]=' ';s[p+4]=' ';s[p+5]=' ';\n    f=true;\n  }\n  while(s.find(\"(0->1)\")!=-1){\n    p=s.find(\"(0->1)\");\n    s[p]='1';s[p+1]=' ';s[p+2]=' ';s[p+3]=' ';s[p+4]=' ';s[p+5]=' ';\n    f=true;\n  }\n  while(s.find(\"(1->0)\")!=-1){\n    p=s.find(\"(1->0)\");\n    s[p]='0';s[p+1]=' ';s[p+2]=' ';s[p+3]=' ';s[p+4]=' ';s[p+5]=' ';\n    f=true;\n  }\n  while(s.find(\"(1->1)\")!=-1){\n    p=s.find(\"(1->1)\");\n    s[p]='1';s[p+1]=' ';s[p+2]=' ';s[p+3]=' ';s[p+4]=' ';s[p+5]=' ';\n    f=true;\n  }\n  \n  if(f){\n    string b;\n    for(int i=0;i<s.size();i++) if(s[i]!=' ') b+=s[i];\n    rec(b);\n  }else{\n    if(s[0]!=s[2]) o=false;\n    return;\n  }\n}\nvoid init(int n,string s){\n  int i,j;\n  for(i=0;i<s.size();i++){\n    for(j=0;j<=MAX;j++){\n      if(s[i]=='a'+j) s[i]='0'+(n>>j&1);\n      if(s[i]=='T') s[i]='1';\n      if(s[i]=='F') s[i]='0';\n    }\n  }\n  rec(s);\n  if(!o) return;\n}\nint main(){\n  string s;\n  while(cin >> s,s!=\"#\"){\n    o=true;\n    int i;\n    for(i=0;i<(1<<MAX);i++)\n      if(o) init(i,s);\n      else break;\n    cout << (o?\"YES\":\"NO\") << endl;\n  }\n  return 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include <iostream>\n#include <sstream>\n#include <string>\n#include <algorithm>\n#include <vector>\n#include <stack>\n#include <queue>\n#include <set>\n#include <map>\n#include <cstdio>\n#include <cstdlib>\n#include <cstring>\n#include <cmath>\n#include <cassert>\n\nusing namespace std;\n\n#define FOR(i,k,n) for(int i=(k); i<(int)(n); ++i)\n#define REP(i,n) FOR(i,0,n)\n#define FORIT(i,c) for(__typeof((c).begin())i=(c).begin();i!=(c).end();++i)\n\ntemplate<class T> void debug(T begin, T end){ for(T i = begin; i != end; ++i) cerr<<*i<<\" \"; cerr<<endl; }\ninline bool valid(int x, int y, int W, int H){ return (x >= 0 && y >= 0 && x < W && y < H); }\n\ntypedef long long ll;\nconst int INF = 100000000;\nconst double EPS = 1e-8;\nconst int MOD = 1000000007;\nint dx[8] = {1, 0, -1, 0, 1, -1, -1, 1};\nint dy[8] = {0, 1, 0, -1, 1, 1, -1, -1};\nstruct Result{\n  bool value;\n  int p;\n  Result(bool b, int p) : value(b), p(p) {}\n};\nint S;\nResult expr(const string& s, int p);\nResult factor(const string& s, int p);\nbool is_ope(char c){\n  string s = \"*+-\";\n  REP(i, s.size()) if(c == s[i]) return true;\n  return false;\n}\nResult expr(const string& s, int p){\n  Result r = factor(s, p);\n  while(is_ope(s[r.p])){\n    if(s[r.p] == '-') assert(s[r.p + 1] == '>');\n    Result r_ = factor(s, (s[r.p] == '-') ? r.p + 2 : r.p + 1);\n    if(s[r.p] == '*'){\n      r.value = r.value && r_.value;\n    }else if(s[r.p] == '+'){\n      r.value = r.value || r_.value;\n    }else {\n      r.value = !r.value || r_.value;\n    }\n    r.p = r_.p;\n  }\n  return r;\n}\nResult factor(const string& s, int p){\n  if(s[p] == '('){\n    Result r = expr(s, p + 1);\n    assert(s[r.p] == ')');\n    r.p ++;\n    return r;\n  }else if(islower(s[p])){\n    return Result((S >> (s[p] - 'a')) & 1, p + 1);\n  }else if(s[p] == 'T'){\n    return Result(true, p + 1);\n  }else if(s[p] == 'F'){\n    return Result(false, p + 1);\n  }else if(s[p] == '-'){\n    Result r = factor(s, p + 1);\n    r.value ^= 1;\n    return r;\n  }else {\n    assert(false);\n  }\n}\n\nint main(){\n  string s;\n  while(cin >> s && s != \"#\"){\n    string a, b;\n    REP(i, s.size()) if(s[i] == '='){\n      a = s.substr(0, i);\n      b = s.substr(i + 1);\n    }\n    bool equal = true;\n    for(S = 0; S < 1<<10; S++){\n      if(expr(a, 0).value != expr(b, 0).value) equal = false;\n    }\n    if(equal) cout << \"YES\" << endl;\n    else cout << \"NO\" << endl;\n  }\n  return 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include <iostream>\n#include <iomanip>\n#include <sstream>\n#include <cstdio>\n#include <cstdlib>\n#include <cstring>\n#include <cmath>\n#include <climits>\n#include <cfloat>\n#include <vector>\n#include <string>\n#include <stack>\n#include <queue>\n#include <set>\n#include <map>\n#include <algorithm>\n#include <functional>\n#include <utility>\n#include <numeric>\n#include <iterator>\n\nusing namespace std;\n\ntypedef long long LL;\ntypedef unsigned long long ULL;\ntypedef vector<int> VI;\ntypedef vector<VI> VVI;\ntypedef vector<string> VS;\ntypedef pair<int,int> PII;\ntypedef vector<PII> VPII;\ntypedef istringstream ISS;\ntypedef ostringstream OSS;\n\n#define REP( i, m, n ) for ( int i = (int)( m ); i < (int)( n ); ++i )\n#define FOR( v, c ) for ( auto &v : c )\n#define EACH( it, c ) for ( auto it = c.begin(); it != c.end(); ++it )\n#define ALL( c ) (c).begin(), (c).end()\n#define DRANGE( c, p ) (c).begin(), (c).begin() + p, (c).end()\n\n#define PB( n ) push_back( n )\n#define MP( a, b ) make_pair( ( a ), ( b ) )\n#define EXIST( c, e ) ( (c).find( e ) != (c).end() )\n\n#define fst first\n#define snd second\n\n#define DUMP( x ) cerr << #x << \" = \" << ( x ) << endl\n#define DEBUG( x ) cerr << __FILE__ << \":\" << __LINE__ << \": \" << #x << \" = \" << ( x ) << endl\n\n// <equation> := <fomula>'='<fomula>\n// <fomula> := <constant> | '-'<fomula> | '('<inner>')'\n// <inner> := <fomula>'*'<fomula> | <fomula>'+'<fomula> | <fomula>\"->\"<fomula>\n// <constant> := 'T' | 'F'\n\nPII equation( const string &, int p );\nPII fomula( const string &, int p );\nPII inner( const string &, int p );\nPII constant( const string &, int p );\n\nPII equation( const string &s, int p = 0 )\n{\n\tconst PII r1 = fomula( s, p );\n\tconst PII r2 = fomula( s, r1.snd + 1 );\n\treturn MP( r1.fst == r2.fst, r2.snd );\n}\n\nPII fomula( const string &s, int p = 0 )\n{\n\tif ( s[p] == '-' )\n\t{\n\t\tPII res = fomula( s, p + 1 );\n\t\tres.fst = !res.fst;\n\t\treturn res;\n\t}\n\telse if ( s[p] == '(' )\n\t{\n\t\tPII res = inner( s, p + 1 );\n\t\tres.snd ++;\n\t\treturn res;\n\t}\n\telse\n\t{\n\t\treturn constant( s, p );\n\t}\n}\n\nconst int table_and[][2] = {\n\t0, 0,\n\t0, 1\n};\nconst int table_or[][2] = {\n\t0, 1,\n\t1, 1\n};\nconst int table_imp[][2] = {\n\t1, 1,\n\t0, 1\n};\n\nPII inner( const string &s, int p = 0 )\n{\n\tconst PII r1 = fomula( s, p );\n\tconst char op = s[ r1.snd ];\n\tconst PII r2 = fomula( s, r1.snd + ( op != '-' ? 1 : 2 ) );\n\n\tint res;\n\tswitch ( op )\n\t{\n\t\tcase '*':\n\t\t\tres = table_and[ r1.fst ][ r2.fst ];\n\t\t\tbreak;\n\t\tcase '+':\n\t\t\tres = table_or[ r1.fst ][ r2.fst ];\n\t\t\tbreak;\n\t\tcase '-':\n\t\t\tres = table_imp[ r1.fst ][ r2.fst ];\n\t\t\tbreak;\n\t}\n\treturn MP( res, r2.snd );\n}\n\nPII constant( const string &s, int p = 0 )\n{\n\treturn MP( s[p] == 'T' ? 1 : 0, p + 1 );\n}\n\nint main()\n{\n\tcin.tie( 0 );\n\tios::sync_with_stdio( false );\n\n\tfor ( string line; cin >> line, line != \"#\"; )\n\t{\n\t\tint res = 0;\n\t\tREP( i, 0, 1 << 11 )\n\t\t{\n\t\t\tstring tmp = line;\n\t\t\tREP( j, 0, 11 )\n\t\t\t{\n\t\t\t\treplace( ALL( tmp ), (char)( 'a' + j ), ( i & 1 << j ) ? 'T' : 'F' );\n\t\t\t}\n\t\t\tres += equation( tmp ).fst;\n\t\t}\n\n\t\tcout << ( res == 1 << 11 ? \"YES\" : \"NO\" ) << endl;\n\t}\n\n\treturn 0;\n}"
  },
  {
    "language": "C++",
    "code": "#define TEST_MODE false\n\n#define _CRT_SECURE_NO_WARNINGS\n#define _USE_MATH_DEFINES\n\n#include \"bits/stdc++.h\"\nusing namespace std;\n#define rep(i, n) for (int i = 0; i < (n); ++i)\n#define rep2(i, a, b) for (int i = (a); i < (b); ++i)\n#define rrep(i, n) for (int i = (n)-1; i >= 0; --i)\n#define rrep2(i, a, b) for (int i = (a)-1; i >= b; --i)\n#define range(i, a, b, c) for (int i = a;             \\\n                               c > 0 ? i < b : i > b; \\\n                               i += c)\n#define chmax(a, b) (a = (a) < (b) ? (b) : (a))\n#define chmin(a, b) (a = (a) > (b) ? (b) : (a))\nusing ll = long long;\nusing ull = unsigned long long;\nusing ld = long double;\n#define all(a) begin(a), end(a)\n#define ifnot(a) if (not(a))\n#define int long long\n\n#ifdef LOCAL_ENV\n\n#if TEST_MODE == true\nconst bool test = true;\n#define dump(x) cerr << #x << \" = \" << (x) << endl\n#else\nconst bool test = false;\n#define dump(x) \n#endif\n\n#else\nconst bool test = false;\n#define dump(x) \n#endif\n\nint dx[] = {1, 0, -1, 0};\nint dy[] = {0, 1, 0, -1};\nconst int INF = (int)1 << 60;\nconst ll INFL = (ll)1 << 60;\nll mod_n = (int)1e9 + 7;\nconst double eps = 1e-10;\ntypedef long double Real;\n// return -1, 0, 1\nint sgn(const Real &r) { return (r > eps) - (r < -eps); }\nint sgn(const Real &a, const Real &b) { return sgn(a - b); }\n\n//.....................\nconst int MAX = (int)2e5 + 5;\n\nvector<string> split(const string &str, char sep)\n{\n    vector<string> v;\n    stringstream ss(str);\n    string buffer;\n    while (getline(ss, buffer, sep))\n    {\n        v.push_back(buffer);\n    }\n    return v;\n}\n\ntemplate <class InputIterator>\nint sum(InputIterator begin, InputIterator end)\n{\n    return accumulate(begin, end, 0ll);\n}\n\nvoid solve();\n\nsigned main()\n{\n    cout << fixed << setprecision(20);\n    while (true) {\n        solve();\n    }\n    return 0;\n}\n\n// class Mycin {\n// \tbool flag = true;\n// public:\n// \tMycin& operator >> (int& a) {flag = scanf(\"%lld\", &a) != EOF; return *this;}\n// \tMycin& operator >> (char& a) {flag = scanf(\"%c\", &a) != EOF; return *this;}\n// \tMycin& operator >> (string& s) {flag = (bool)(cin >> s); return *this;}\n// \toperator bool() {return flag;}\n// } mycin;\n \n// class Mycout {\n// public:\n// \tMycout& operator << (const int& a) {printf(\"%lld\", a); return *this;}\n// \tMycout& operator << (const char c) {printf(\"%c\", c); return *this;}\n// \tMycout& operator << (const string& s) {printf(\"%s\", s.c_str()); return *this;}\n// } mycout;\n \n// #define cin mycin\n// #define cout mycout\n// #define endl '\\n'\n\nint equation(const string& s, int& i);\nint formula(const string& s, int& i);\n\nint equation(const string& s, int& i) {\n    int a = formula(s, i);\n    dump(a);\n    i++;\n    int b = formula(s, i);\n    dump(b);\n    if (a == b) return 1;\n    else        return 0;\n}\n\nint formula(const string& s, int& i) {\n    int res = -1;\n    if (isdigit(s[i])) {\n        res = s[i++] - '0';\n    }\n    else if (s[i] == '-') {\n        i++;\n        res = ! formula(s, i);\n    }\n    else if (s[i] == '(') {\n        i++;\n        int a = formula(s, i);\n        string op;\n        op += s[i++];\n        if (op == \"-\") {\n            op += s[i++];\n        }\n        int b = formula(s, i);\n        i++;\n        if (op == \"*\") res = a * b;\n        if (op == \"+\") res = min((int)1, a + b);\n        if (op == \"->\") {\n            if (a == 1 && b == 0) res = 0;\n            else res = 1;\n        }\n    }\n    // dump(res);\n    return res;\n}\n\nint eval(const string& s) {\n    int i = 0;\n    return equation(s, i);\n}\n\nbool ok(string ori_s, int mask) {\n    string s;\n    rep(i, (int)ori_s.size()) {\n        s += ori_s[i];\n        if (isupper(s[i])) {\n            if (s[i] == 'T') s[i] = '1';\n            else             s[i] = '0';\n        }\n        if (islower(s[i])) {\n            s[i] = ((mask >> (s[i] - 'a')) & 1) + '0';\n        }\n    }\n    // dump(s);\n    return eval(s);\n}\n\nvoid solve() {\n    string ori_s;\n    cin >> ori_s;\n    if (ori_s == \"#\") exit(0);\n    bool ok_flag = true;\n    rep(i, 1 << 12) {\n        ok_flag = ok_flag && ok(ori_s, i);\n    }\n    if (ok_flag) cout << \"YES\" << endl;\n    else cout << \"NO\" << endl;\n}"
  },
  {
    "language": "C++",
    "code": "#include <functional>\n#include <iostream>\n#include <string>\n#include <unordered_set>\n#include <vector>\n#include <memory>\n#define loop(i, a, n) for (int i = (a); i < (n); i++)\n#define rep(i, n) loop(i, 0, n)\ntemplate<typename A> using F = std::function<A>;\nusing namespace std;\n \ntemplate<typename T> struct ParseResult {\n  bool succeeded;\n  T object;\n  int pos;\n  ParseResult(const bool succeeded, const T &object, const int pos) : succeeded(succeeded), object(object), pos(pos) {}\n  friend std::ostream &operator<<(std::ostream &os, const ParseResult<T> &p) { return os << '{' << (p.succeeded ? \"true\" : \"false\") << ',' << p.object << ',' << p.pos << '}'; }\n};\n \ntemplate<typename T> using Parser = std::function<ParseResult<T>(const std::string&, int)>;\n \nParser<std::string> token(std::string s) {\n  const auto n = s.size();\n  return [n = std::move(n), s = std::move(s)](const std::string &target, const int pos) {\n    if (target.size() < n) return ParseResult<std::string>(false, {}, pos);\n    return target.substr(pos, n) == s ? ParseResult<std::string>(true, s, pos + n) : ParseResult<std::string>(false, {}, pos);\n  };\n}\n \ntemplate<typename T> Parser<T> operator||(Parser<T> p1, Parser<T> p2) {\n  return [p1 = std::move(p1), p2 = std::move(p2)](const std::string &target, const int pos) {\n    auto r = p1(target, pos);\n    if (r.succeeded) return r;\n    r = p2(target, pos);\n    if (r.succeeded) return r;\n    return ParseResult<T>(false, {}, pos);\n  };\n}\n \ntemplate<typename T1, typename T2> Parser<std::pair<T1, T2>> operator+(Parser<T1> p1, Parser<T2> p2) {\n  return [p1 = std::move(p1), p2 = std::move(p2)](const std::string &target, const int pos) {\n    auto r1 = p1(target, pos);\n    if (!r1.succeeded) return ParseResult<std::pair<T1, T2>>(false, {}, pos);\n    auto r2 = p2(target, r1.pos);\n    if (!r2.succeeded) return ParseResult<std::pair<T1, T2>>(false, {}, pos);\n    return ParseResult<std::pair<T1, T2>>(true, {r1.object, r2.object}, r2.pos);\n  };\n}\n \ntemplate<typename T1, typename T2> Parser<T2> operator>>(Parser<T1> p1, Parser<T2> p2) {\n  return [p1 = std::move(p1), p2 = std::move(p2)](const std::string &target, const int pos) {\n    auto r1 = p1(target, pos);\n    if (!r1.succeeded) return ParseResult<T2>(false, {}, pos);\n    auto r2 = p2(target, r1.pos);\n    if (!r2.succeeded) return ParseResult<T2>(false, {}, pos);\n    return ParseResult<T2>(true, r2.object, r2.pos);\n  };\n}\n \ntemplate<typename T1, typename T2> Parser<T1> operator<<(Parser<T1> p1, Parser<T2> p2) {\n  return [p1 = std::move(p1), p2 = std::move(p2)](const std::string &target, const int pos) {\n    auto r1 = p1(target, pos);\n    if (!r1.succeeded) return ParseResult<T1>(false, {}, pos);\n    auto r2 = p2(target, r1.pos);\n    if (!r2.succeeded) return ParseResult<T1>(false, {}, pos);\n    return ParseResult<T1>(true, r1.object, r2.pos);\n  };\n}\n \nParser<char> oneOf(const std::string &s) {\n  std::unordered_set<char> d;\n  for (auto &c : s) d.insert(c);\n  return [d = std::move(d)](const std::string &target, const int pos) {\n    if (target.size() <= pos) return ParseResult<char>(false, {}, pos);\n    char c = target[pos];\n    return d.count(c) ? ParseResult<char>(true, c, pos + 1) : ParseResult<char>(false, {}, pos);\n  };\n}\n \ntemplate<typename T, typename S, typename F> Parser<S> fmap(Parser<T> p, F &&f) {\n  return [p = std::move(p), f = std::forward<F>(f)](const std::string &target, const int pos) {\n    auto r = p(target, pos);\n    return r.succeeded ? ParseResult<S>(true, f(r.object), r.pos) : ParseResult<S>(false, {}, r.pos);\n  };\n}\n \ntemplate<typename T, typename F> Parser<T> lazy(const F &f) {\n  bool instantiated = false;\n  Parser<T> p;\n  return [f = std::move(f), p = std::move(p), instantiated = std::move(instantiated)](const std::string &target, const int pos) mutable {\n    if (!instantiated) {\n      p = f();\n      instantiated = true;\n    }\n    return p(target, pos);\n  };\n}\n \ntemplate<typename T> Parser<T> make_view(Parser<T> &&f) {\n  return [f = std::make_shared<Parser<T>>(std::move(f))](const std::string &target, const int pos) {\n    return (*f)(target, pos);\n  };\n}\n \nstruct SyntaxTree {\n  string op;\n  char value;\n  vector<SyntaxTree> children;\n  SyntaxTree() {}\n  SyntaxTree(const string &op, const char value, const vector<SyntaxTree> &children) : op(op), value(value), children(children) {}\n};\n \nint main() {\n  Parser<SyntaxTree> formulaP = make_view<SyntaxTree>(lazy<SyntaxTree>([&]() {\n    auto andP = fmap<pair<SyntaxTree, SyntaxTree>, SyntaxTree>((token(\"(\") >> formulaP << token(\"*\")) + (formulaP << token(\")\")), [](auto &o) { return SyntaxTree(\"*\", {}, {o.first, o.second}); });\n    auto orP = fmap<pair<SyntaxTree, SyntaxTree>, SyntaxTree>((token(\"(\") >> formulaP << token(\"+\")) + (formulaP << token(\")\")), [](auto &o) { return SyntaxTree(\"+\", {}, {o.first, o.second}); });\n    auto impP = fmap<pair<SyntaxTree, SyntaxTree>, SyntaxTree>((token(\"(\") >> formulaP << token(\"->\")) + (formulaP << token(\")\")), [](auto &o) { return SyntaxTree(\"->\", {}, {o.first, o.second}); });\n    auto notP = fmap<SyntaxTree, SyntaxTree>(token(\"-\") >> formulaP, [](auto &o) { return SyntaxTree(\"-\", {}, {o}); });\n    auto valP = fmap<char, SyntaxTree>(oneOf(\"abcdefghijkTF\"), [](char x) { return SyntaxTree({}, x, {}); });\n    return andP || orP || impP || notP || valP;\n  }));\n  auto equationP = (formulaP << token(\"=\")) + formulaP;\n  string s;\n  while (cin >> s, s != \"#\") {\n    auto r = equationP(s, 0);\n    bool isValid = true;\n    rep(i, 1 << 11) {\n      auto toBool = [&](char c) -> bool {\n        if (c == 'T') return true;\n        if (c == 'F') return false;\n        return i >> (c - 'a') & 1;\n      };\n      F<bool(const SyntaxTree&)> evalF = [&](const SyntaxTree &f) {\n        switch (f.children.size()) {\n          case 0: return toBool(f.value);\n          case 1: return !evalF(f.children[0]);\n          case 2:\n            if (f.op == \"*\") return evalF(f.children[0]) && evalF(f.children[1]);\n            if (f.op == \"+\") return evalF(f.children[0]) || evalF(f.children[1]);\n            if (f.op == \"->\") return !evalF(f.children[0]) || evalF(f.children[1]);\n        }\n      };\n      isValid &= evalF(r.object.first) == evalF(r.object.second);\n    }\n    cout << (isValid ? \"YES\" : \"NO\") << endl;\n  }\n}"
  },
  {
    "language": "C++",
    "code": "#include<bits/stdc++.h>\nusing namespace std;\ntypedef string::const_iterator state;\n\nstring str;\nstring A,B;\n\nstring conv(string &S,int bit){\n    string ret=S;\n    for(int i=0;i<S.size();i++){\n        if('a'<=S[i]&&'k'>=S[i]){\n            ret[i]=((bit>>(S[i]-'a')&1)?'1':'0');\n        }\n    }\n    return ret;\n}\nint expression(state &);\n\nint number(state &b){\n    int ret=0;\n    while(isdigit(*b)){\n        ret=ret*10+*b-'0';\n        b++;\n    }\n    return ret;\n}\n\nint fact(state &b){\n    int ret;\n    if(*b=='('){\n        b++;\n        ret=expression(b);\n        b++;\n    }\n    else{\n        ret=number(b);\n    }\n    return ret;\n}\n\nint latte(state &b){\n    if(*b=='-'){\n        b++;\n        return 1-fact(b);\n    }\n    else return fact(b);\n}\n\nint expression(state &b){\n    int ret=latte(b);\n    while(true){\n        if(*b=='+'){\n            b++;\n            ret=max(ret,latte(b));\n        }\n        else if(*b=='*'){\n            b++;\n            ret=min(ret,latte(b));\n        }\n        else if(*b=='-'){\n            b++;b++;\n            ret=(ret<=latte(b));\n        }\n        else break;\n    }\n    return ret;\n}\n\nvoid solve(){\n    for(int i=0;i<str.size();i++){\n        if(str[i]=='T')str[i]='1';\n        if(str[i]=='F')str[i]='0';\n    }\n\n    int idx=str.find('=');\n    A=str.substr(0,idx);\n    B=str.substr(idx+1,str.size()-idx-1);\n    A+=\"=\";B+=\"=\";\n\n    for(int i=0;i<(1<<11);i++){\n        string a=conv(A,i),b=conv(B,i);\n        state sa=a.begin(),sb=b.begin();\n        if(expression(sa)!=expression(sb)){\n            cout<<\"NO\"<<endl;\n            return;\n        }\n    }\n    cout<<\"YES\"<<endl;\n    return;\n\n}\n\nint main(){\n    while(cin>>str,str!=\"#\")solve();\n    return 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include <iostream>\n#include <vector>\n#include <stack>\n#include <deque>\n#include <queue>\n#include <algorithm>\n#include <complex>\n#include <cstdio>\n#include <cstdlib>\n#include <cstring>\n#include <cmath>\n#include <climits>\nusing namespace std;\ntypedef long long ll;\n#define REP(i,b,n) for(int i=~b;i<n;i++)\n#define rep(i,n) REP(i,0,n)\n\nint idx;\nstring s;\n\nbool solve(){\n  if(s[idx] == '-'){\n    idx++;\n    bool tmp = solve();\n    return !tmp;\n  }\n  else if(s[idx] == 'T'){\n    idx++;\n    return true;\n  }\n  else if(s[idx] == 'F'){\n    idx++;\n    return false;\n  }\n  else{\n    idx++; // '('のぶん\n\n    bool res;\n    bool flgL = solve();\n\n    if(s[idx] == '*'){\n      idx++;\n      bool flgR = solve();\n      res = flgL && flgR;\n    }\n    else if(s[idx] == '+'){\n      idx++;\n      bool flgR = solve();\n      res = flgL || flgR;\n    }\n    else{\n      idx += 2;\n      bool flgR = solve();\n      if(flgL && !flgR){\n        res = false;\n      }\n      else{\n        res = true;\n      }\n    }\n\n    idx++; // ')'のぶん\n\n    return res;\n  }\n}\n\nstring trans(string ts, int bit){\n  string res = \"\";\n\n  for(int i = 0; i < ts.size(); i++){\n    if(ts[i] == 'a') res += ((bit & (1 << 0)) != 0 ? 'T' : 'F');\n    else if(ts[i] == 'b') res += ((bit & (1 << 1)) != 0 ? 'T' : 'F');\n    else if(ts[i] == 'c') res += ((bit & (1 << 2)) != 0 ? 'T' : 'F');\n    else if(ts[i] == 'd') res += ((bit & (1 << 3)) != 0 ? 'T' : 'F');\n    else if(ts[i] == 'e') res += ((bit & (1 << 4)) != 0 ? 'T' : 'F');\n    else if(ts[i] == 'f') res += ((bit & (1 << 5)) != 0 ? 'T' : 'F');\n    else if(ts[i] == 'g') res += ((bit & (1 << 6)) != 0 ? 'T' : 'F');\n    else if(ts[i] == 'h') res += ((bit & (1 << 7)) != 0 ? 'T' : 'F');\n    else if(ts[i] == 'i') res += ((bit & (1 << 8)) != 0 ? 'T' : 'F');\n    else if(ts[i] == 'j') res += ((bit & (1 << 9)) != 0 ? 'T' : 'F');\n    else if(ts[i] == 'k') res += ((bit & (1 << 10)) != 0 ? 'T' : 'F');\n    else{\n      res += ts[i];\n    }\n  }\n\n  return res;\n}\n\nint main(){\n  while(cin >> s, s != \"#\"){\n    int len = s.length();\n    string l, r;\n\n    for(int i = 0; i < len; i++){\n      if(s[i] == '='){\n        l = s.substr(0, i);\n        r = s.substr(i + 1, len - (i + 1));\n        break;\n      }\n    }\n\n    bool ans = true;\n\n    for(int bit = 0; bit < (1 << 11); bit++){\n      s = trans(l, bit);\n      idx = 0;\n      bool flgL = solve();\n\n      s = trans(r, bit);\n      idx = 0;\n      bool flgR = solve();\n\n      if(flgL != flgR){\n        ans = false;\n        break;\n      }\n    }\n\n    if(ans){\n      cout << \"YES\\n\";\n    }\n    else{\n      cout << \"NO\\n\";\n    }\n  }\n}"
  },
  {
    "language": "C++",
    "code": "#define _CRT_SECURE_NO_WARNINGS\n#include <cstdio>\n#include <stdio.h>\n#include <stdlib.h>\n#include <algorithm>\n#include <vector>\n#include <string>\n#include <iostream>\n\nusing namespace std;\n\nstring& replace(string& str, char moto, char kawaru) {\n\tstd::string::size_type n;\n\t;\n\twhile ((n = str.find(moto)) != std::string::npos) {\n\t\tstr.replace(n, 1, 1, kawaru);\n\t}\n\treturn str;\n}\n\n\nstring& replace(string& str, const string& moto, char kawaru) {\n\tstd::string::size_type n;\n\t;\n\twhile ((n = str.find(moto)) != std::string::npos) {\n\t\tstr.replace(n, moto.length(), 1, kawaru);\n\t}\n\treturn str;\n}\n\nbool calc(int flag, string& str) {\n\tfor (char c = 'a'; c <= 'k'; ++c) {\n\t\tint n = c - 'a';\n\t\treplace(str, c, 1 << n&flag ? 'T' : 'F');\n\t}\n\n\twhile (str.length() != 1) {\n\t\treplace(str, \"-T\", 'F');\n\t\treplace(str, \"-F\", 'T');\n\t\treplace(str, \"(T+T)\", 'T');\n\t\treplace(str, \"(T+F)\", 'T');\n\t\treplace(str, \"(F+T)\", 'T');\n\t\treplace(str, \"(F+F)\", 'F');\n\t\treplace(str, \"(T*T)\", 'T');\n\t\treplace(str, \"(T*F)\", 'F');\n\t\treplace(str, \"(F*T)\", 'F');\n\t\treplace(str, \"(F*F)\", 'F');\n\t\treplace(str, \"(T->T)\", 'T');\n\t\treplace(str, \"(T->F)\", 'F');\n\t\treplace(str, \"(F->T)\", 'T');\n\t\treplace(str, \"(F->F)\", 'T');\n\t}\n\tif (str[0] == 'T')\n\t\treturn true;\n\telse\n\t\treturn false;\n\n\n}\n\n\nint main() {\n\twhile (true) {\n\t\tstring str;\n\t\tcin >> str;\n\n\t\tif (str[0] == '#')\n\t\t\tbreak;\n\n\t\tbool correct = true;\n\t\tfor (int flag = 0; flag <= 0x7ff; ++flag) {\n\t\t\tint equal = str.find(\"=\");\n\t\t\tstring left = str.substr(0, equal);\n\t\t\tstring right = str.substr(equal + 1);\n\t\t\tif (calc(flag, left) != calc(flag, right)) {\n\t\t\t\tcorrect = false;\n\t\t\t\tbreak;\n\t\t\t}\n\t\t}\n\n\t\tif (correct)\n\t\t\tprintf(\"YES\\n\");\n\t\telse\n\t\t\tprintf(\"NO\\n\");\n\t}\n}"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\nusing namespace std;\n#define FOR(i,k,n) for(int i = (k); i < (n); i++)\n#define REP(i,n) FOR(i,0,n)\n#define ALL(a) a.begin(), a.end()\n#define MS(m,v) memset(m,v,sizeof(m))\n#define D10 fixed<<setprecision(10)\ntypedef vector<int> vi;\ntypedef vector<string> vs;\ntypedef pair<int, int> pii;\ntypedef long long ll;\nconst int INF = 114514810;\nconst int MOD = 1000000007;\nconst double EPS = 1e-10;\ntemplate<class T> T &chmin(T &a, const T &b) { return a = min(a, b); }\ntemplate<class T> T &chmax(T &a, const T &b) { return a = max(a, b); }\n\n/*--------------------template--------------------*/\nstring s;\nint p, var[11];\nbool f;\n\nint parse();\n\nint unit()\n{\n\tint res;\n\tif (s[p] == '-'&&s[p + 1] != '>')\n\t{\n\t\tp++;\n\t\tint a = unit();\n\t\tres = 1 - a;\n\t}\n\telse if (s[p] == '(')\n\t{\n\t\tp++;\n\t\tres = parse();\n\t\tp++;\n\t}\n\telse\n\t{\n\t\tp++;\n\t\tif (s[p-1] == 'T') return res = 1;\n\t\telse if (s[p-1] == 'F') return res = 0;\n\t\telse\n\t\t{\n\t\t\tint t = s[p-1] - 'a';\n\t\t\tres = var[t];\n\t\t}\n\t}\n\treturn res;\n}\n\nint parse()\n{\n\tint a = unit();\n\tif (s[p] == '+')\n\t{\n\t\tp++;\n\t\tint b = unit();\n\t\ta = max(a, b);\n\t}\n\telse if (s[p] == '*')\n\t{\n\t\tp++;\n\t\tint b = unit();\n\t\ta = min(a, b);\n\t}\n\telse if(s[p]=='-'&&s[p+1]=='>')\n\t{\n\t\tp+=2;\n\t\tint b = unit();\n\t\tif (a == 1 && b == 0) a = 0;\n\t\telse a = 1;\n\t}\n\treturn a;\n}\n\nvoid solve()\n{\n\tp = 0;\n\tint l = parse();\n\tp++;\n\tint r = parse();\n\tif (l != r) f = false;\n}\n\nint main()\n{\n\twhile (cin >> s&&s != \"#\")\n\t{\n\t\tf = true;\n\t\tREP(i, 1 << 11)\n\t\t{\n\t\t\tREP(j, 11)\n\t\t\t{\n\t\t\t\tvar[j] = (i >> j) & 1;\n\t\t\t\tsolve();\n\t\t\t}\n\t\t}\n\t\tputs(f ? \"YES\" : \"NO\");\n\t}\n\treturn 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include <iostream>\n#include <string>\n#include <vector>\n#include <queue>\n#include <stack>\n#include <map>\n#include <algorithm>\n#include <sstream>\n#include <cmath>\n#include <set>\n#include <cstdio>\n#include <iomanip>\n\nusing namespace std;\n\n#define REP(i,n) for(int (i)=0;(i)<(int)(n);(i)++)\n#define RREP(i,n) for(int (i)=(int)(n)-1;(i)>=0;(i)--)\n#define REMOVE(Itr,n) (Itr).erase(remove((Itr).begin(),(Itr).end(),n),(Itr).end())\n#define PB_VEC(Itr1,Itr2) (Itr1).insert((Itr1).end(),(Itr2).begin(),(Itr2).end())\n#define UNIQUE(Itr) sort((Itr).begin(),(Itr).end()); (Itr).erase(unique((Itr).begin(),(Itr).end()),(Itr).end())\n\ntypedef long long ll;\n\n\nclass Source{\nprivate:\n    string str;\n    int pos;\n    \npublic:\n    int peek(){\n        if(pos<str.size())return str[pos];\n        return -1;\n    }\n    \n    void next(){\n        pos++;\n    }\n    \n    void init(string _str){\n        str=_str;\n        pos=0;\n    }\n    \n};\n\n\nclass ParserLogicalOperation{\nprivate:\n    Source src;\n    \npublic:\n    ParserLogicalOperation(string str){\n        src.init(str);\n    }\n    \n    string token(){\n        string res;\n        res+=(char)src.peek();\n        src.next();\n        if(res==\"-\"){\n            if(src.peek()=='>'){\n                res+=(char)src.peek();\n                src.next();\n            }\n        }\n        return res;\n    }\n    \n    bool toTF(string s){\n        if(s==\"T\")return true;\n        return false;\n    }\n    \n    bool expr(){\n        string x=factor();\n        if(x==\"-\")return !toTF(factor());\n        bool res=toTF(x);\n        while(true){\n            string t=factor();\n            if(t==\"->\"){\n                bool r=toTF(factor());\n                if(res&&!r)res=false;\n                else res=true;\n            }if(t==\"+\"){\n                res|=toTF(factor());\n                continue;\n            }else if(t==\"*\"){\n                res&=toTF(factor());\n                continue;\n            }\n            break;\n        }\n        return res;\n    }\n    \n    string factor(){\n        string t=token();\n        if(t==\"(\"){\n            string res=(expr()?\"T\":\"F\");\n            token();\n            return res;\n        }\n        return t;\n    }\n    \n};\n\n\n\nint main(){\n  \n    while(true){\n        \n        string s;\n        cin>>s;\n        \n        if(s==\"#\")break;\n        \n        int i=0;\n        while(s[i]!='=')i++;\n        string a=s.substr(0,i);\n        string b=s.substr(i+1,s.size());\n    \n        ParserLogicalOperation right(a);\n        ParserLogicalOperation left(b);\n        \n        if(right.expr()==left.expr())cout<<\"YES\"<<endl;\n        else cout<<\"NO\"<<endl;\n        \n    }\n    \n    return 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include<bits/stdc++.h>\nusing namespace std;\n\n#define rep(i, n) for(int i=0; i<n; i++)\n\nstring s;\nmap<char, bool> hm;\n\ntypedef string::const_iterator State;\nclass ParseError{};\n\ntemplate<typename T> class Parsing\n{\npublic:\n  static void consume(State& begin, char expected) {\n    if (*begin == expected) {\n      begin++;\n    } else {\n      cerr << \"Expected '\" << expected << \"' but got '\" << *begin << \"'\"\n           << endl;\n      cerr << \"Rest string is '\";\n      while (*begin) {\n        cerr << *begin++;\n      }\n      cerr << \"'\" << endl;\n      throw ParseError();\n    }\n  }\n\n  static T equation(State& begin){\n    T v = formula(begin);    consume(begin, '=');\n    T w = formula(begin);\n    return v == w;\n  }\n\n  static T formula(State& begin){\n    T ret;\n    if(*begin == '-'){\n      consume(begin, '-');\n      ret = !formula(begin);\n    }\n    else if(isalpha(*begin)){\n      ret = number(begin);\n    }\n    else if(*begin == '('){\n      consume(begin, '(');\n      ret = formula(begin);\n      if(*begin == '+'){\n        consume(begin, '+');\n        ret = formula(begin) || ret;\n      }\n      else if(*begin == '*'){\n        consume(begin, '*');\n        ret = formula(begin) && ret;\n      }\n      else if(*(begin+1) == '>'){\n        consume(begin, '-');\n        consume(begin, '>');\n        T t = formula(begin);\n        ret = (t && ret) || !ret;\n      }\n      consume(begin, ')');\n    }\n    return ret;\n  }\n\n  static T number(State& begin){\n    return hm[*(begin++)];\n  }\n};\n\nint main()\n{\n  while(getline(cin, s), s != \"#\"){\n    bool ok = true;\n    hm['T'] = true;\n    hm['F'] = false;\n    rep(i, 1 << 11){\n      rep(j, 11) hm['a' + j] = i & 1 << j;\n      State begin = s.begin();\n      ok &= Parsing<bool>::equation(begin);\n      if(!ok) break;\n    }\n    puts(ok ? \"YES\" : \"NO\");\n  }\n\n  return 0;\n}"
  },
  {
    "language": "C++",
    "code": "#define _USE_MATH_DEFINES\n#include \"bits/stdc++.h\"\nusing namespace std;\n\n//#define int long long\n#define DBG 1\n#define dump(o) if(DBG){cerr<<#o<<\" \"<<o<<endl;}\n#define dumpc(o) if(DBG){cerr<<#o; for(auto &e:(o))cerr<<\" \"<<e;cerr<<endl;}\n#define rep(i,a,b) for(int i=(a);i<(b);i++)\n#define rrep(i,a,b) for(int i=(b)-1;i>=(a);i--)\n#define each(it,c) for(auto it=(c).begin();it!=(c).end();it++)\n#define all(c) c.begin(),c.end()\nconst int INF = sizeof(int) == sizeof(long long) ? 0x3f3f3f3f3f3f3f3fLL : 0x3f3f3f3f;\nconst int MOD = (int)(1e9 + 7);\n\nvoid change(string &s, char x, char c) {\n\trep(i, 0, s.size()) {\n\t\tif (s[i] == x)s[i] = c;\n\t}\n}\nint eval(string &s, int &k) {\n\tif (s[k] == 'T')return 1;\n\telse if (s[k] == 'F')return 0;\n\telse if (s[k] == '-') {\n\t\tk++;\n\t\tint res = eval(s, k);\n\t\treturn (1 - res);\n\t}\n\telse if (s[k] == '(') {\n\t\tk++;\n\t\tint a = eval(s, k);\n\t\tk++;\n\t\tchar op = s[k];\n\t\tk++;\n\t\tint b = eval(s, k);\n\t\tk++;\n\t\tint r;\n\t\tif (op == '+')r = a | b;\n\t\telse if (op == '*')r = a&b;\n\t\telse if (op == '>')r = (a == 1 && b == 0) ? 0 : 1;\n\t\treturn r;\n\t}\n}\nsigned main() {\n\tstring s;\n\twhile (cin >> s, s != \"#\") {\n\t\tstring str;\n\t\tfor (int i = 0; i < s.size(); i++) {\n\t\t\tif (i == s.size() - 1)str.push_back(s[i]);\n\t\t\telse if (s[i] == '-'&&s[i + 1] == '>') {\n\t\t\t\tstr.push_back('>');\n\t\t\t\ti++;\n\t\t\t}\n\t\t\telse str.push_back(s[i]);\n\t\t}\n\n\t\tstring ex1, ex2; bool f(false);\n\t\tfor (int i = 0; i < str.size(); i++) {\n\t\t\tif (str[i] == '=')f = true;\n\t\t\telse if (f)ex2.push_back(str[i]);\n\t\t\telse ex1.push_back(str[i]);\n\t\t}\n\n\t\tint c[256]; memset(c, 0, sizeof(c));\n\t\trep(i, 0, str.size())c[str[i]] = 1;\n\t\tvector<char>vc;\n\t\tfor (char x = 'a'; x <= 'k'; x++)if (c[x])vc.push_back(x);\n\t\tint N = vc.size();\n\n\t\tbool ans = true;\n\t\tfor (int bits = 0; bits < (1 << N); bits++) {\n\t\t\tstring ex1_(ex1), ex2_(ex2);\n\t\t\trep(i, 0, N) {\n\t\t\t\tif (bits&(1 << i)) {\n\t\t\t\t\tchange(ex1_, vc[i], 'T');\n\t\t\t\t\tchange(ex2_, vc[i], 'T');\n\t\t\t\t}\n\t\t\t\telse {\n\t\t\t\t\tchange(ex1_, vc[i], 'F');\n\t\t\t\t\tchange(ex2_, vc[i], 'F');\n\t\t\t\t}\n\t\t\t}\n\t\t\tint t(0);\n\t\t\tint a = eval(ex1_, t);\n\t\t\tt = 0;\n\t\t\tint b = eval(ex2_, t);\n\t\t\tif (a != b) {\n\t\t\t\tans = false;\n\t\t\t\tbreak;\n\t\t\t}\n\t\t}\n\t\tif (ans)cout << \"YES\" << endl;\n\t\telse cout << \"NO\" << endl;\n\t}\n\treturn 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include <iostream>\n\nusing namespace std;\nstruct node{\n    char type;\n    bool value;\n    node *left, *right;\n    node(){\n        type='\\0';\n        value=false;\n        left=right=NULL;\n    }\n    ~node(){\n        if(left!=NULL) delete left;\n        if(right!=NULL) delete right;\n    }\n};\n\nnode *root;\n\nint rec(node* p, int i, string str){\n    if(i==str.size())return -1;\n    if(p->type=='='){\n        p->left=new node();\n        i=rec(p->left,i,str)+2;\n        p->right=new node();\n        i=rec(p->right,i,str);\n        return -1;\n    }\n    if(str[i]=='F'||str[i]=='T'){\n        p->type='C';\n        p->value=str[i]=='T';\n        return i;\n    }\n    if(str[i]=='-'){\n        p->type='-';\n        p->left=new node();\n        return rec(p->left,i+1,str);\n    }\n    if(str[i]>='a'&&str[i]<='k'){\n        p->type=str[i];\n        return i;\n    }\n    if(str[i]=='('){\n        p->left=new node();\n        i=rec(p->left,i+1,str)+1;\n        if(str[i]=='-'){\n            p->type=str[++i];\n        }else{\n            p->type=str[i];            \n        }\n        p->right=new node();\n        i=rec(p->right,i+1,str)+1;\n        return i;\n    }\n    return i;\n}\nbool b[11];\n\nbool rec2(node*p){\n    if(p->type=='=') return rec2(p->left)==rec2(p->right);\n    if(p->type=='C') return p->value;\n    if(p->type>='a'&&p->type<='k') return b[p->type-'a'];\n    if(p->type=='-') return !rec2(p->left);\n    if(p->type=='*') return rec2(p->left)&&rec2(p->right);\n    if(p->type=='+') return rec2(p->left)||rec2(p->right);\n    if(p->type=='>') return !(rec2(p->left)&&!rec2(p->right));\n    return false;\n}\n\nint main(){\n    string str;\n    node *p;\n    while(cin>>str,str[0]!='#'){\n        if(root!=NULL) delete root;\n        root=new node();\n        root->type='=';\n        rec(root,0,str);\n        bool ans=true;\n        for(int i=0;i<(1<<11);i++){\n            for(int j=0;j<11;j++){\n                b[j]=(bool)(i&(1<<j));\n            }\n            if(!rec2(root)){\n                ans=false;\n                break;\n            }\n        }\n        if(ans){\n            cout<<\"YES\"<<endl;\n        }else{\n            cout<<\"NO\"<<endl;\n        }\n    }\n    return 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include<string>\n#define MAX 11\nusing namespace std;\nbool o;\nvoid rec(string s){\n  if(!o) return;\n  //cout << s << endl;\n  while(1){\n    bool f=false;\n    int p;\n    \n    while(s.find(\"-0\")!=-1){\n      p=s.find(\"-0\");\n      s[p]='1';s[p+1]=' ';\n      f=true;\n    }\n    while(s.find(\"-1\")!=-1){\n      p=s.find(\"-1\");\n      s[p]='0';s[p+1]=' ';\n      f=true;\n    }\n    while(s.find(\"(0*0)\")!=-1){\n      p=s.find(\"(0*0)\");\n      s[p]='0';s[p+1]=' ';s[p+2]=' ';s[p+3]=' ';s[p+4]=' ';\n      f=true;\n    }\n    while(s.find(\"(0*1)\")!=-1){\n      p=s.find(\"(0*1)\");\n      s[p]='0';s[p+1]=' ';s[p+2]=' ';s[p+3]=' ';s[p+4]=' ';\n      f=true;\n    }\n    while(s.find(\"(1*0)\")!=-1){\n      p=s.find(\"(1*0)\");\n      s[p]='0';s[p+1]=' ';s[p+2]=' ';s[p+3]=' ';s[p+4]=' ';\n      f=true;\n    }\n    while(s.find(\"(1*1)\")!=-1){\n      p=s.find(\"(1*1)\");\n      s[p]='1';s[p+1]=' ';s[p+2]=' ';s[p+3]=' ';s[p+4]=' ';\n      f=true;\n    }\n    while(s.find(\"(0+0)\")!=-1){\n      p=s.find(\"(0+0)\");\n      s[p]='0';s[p+1]=' ';s[p+2]=' ';s[p+3]=' ';s[p+4]=' ';\n      f=true;\n    }\n    while(s.find(\"(0+1)\")!=-1){\n      p=s.find(\"(0+1)\");\n      s[p]='1';s[p+1]=' ';s[p+2]=' ';s[p+3]=' ';s[p+4]=' ';\n      f=true;\n    }\n    while(s.find(\"(1+0)\")!=-1){\n      p=s.find(\"(1+0)\");\n      s[p]='1';s[p+1]=' ';s[p+2]=' ';s[p+3]=' ';s[p+4]=' ';\n      f=true;\n    }\n    while(s.find(\"(1+1)\")!=-1){\n      p=s.find(\"(1+1)\");\n      s[p]='1';s[p+1]=' ';s[p+2]=' ';s[p+3]=' ';s[p+4]=' ';\n      f=true;\n    }\n    \n    while(s.find(\"(0->0)\")!=-1){\n      p=s.find(\"(0->0)\");\n      s[p]='1';s[p+1]=' ';s[p+2]=' ';s[p+3]=' ';s[p+4]=' ';s[p+5]=' ';\n      f=true;\n    }\n    while(s.find(\"(0->1)\")!=-1){\n      p=s.find(\"(0->1)\");\n      s[p]='1';s[p+1]=' ';s[p+2]=' ';s[p+3]=' ';s[p+4]=' ';s[p+5]=' ';\n      f=true;\n    }\n    while(s.find(\"(1->0)\")!=-1){\n      p=s.find(\"(1->0)\");\n      s[p]='0';s[p+1]=' ';s[p+2]=' ';s[p+3]=' ';s[p+4]=' ';s[p+5]=' ';\n      f=true;\n    }\n    while(s.find(\"(1->1)\")!=-1){\n      p=s.find(\"(1->1)\");\n      s[p]='1';s[p+1]=' ';s[p+2]=' ';s[p+3]=' ';s[p+4]=' ';s[p+5]=' ';\n      f=true;\n    }\n    \n    if(f){\n      string b;\n      for(int i=0;i<s.size();i++) if(s[i]!=' ') b+=s[i];\n      s=b;\n    }else{\n      if(s[0]!=s[2]) o=false;\n      return;\n    }\n  }\n}\nvoid init(int n,string s){\n  int i,j;\n  for(i=0;i<s.size();i++){\n    for(j=0;j<=MAX;j++){\n      if(s[i]=='a'+j) s[i]='0'+(n>>j&1);\n      if(s[i]=='T') s[i]='1';\n      if(s[i]=='F') s[i]='0';\n    }\n  }\n  rec(s);\n  if(!o) return;\n}\nint main(){\n  string s;\n  while(cin >> s,s!=\"#\"){\n    o=true;\n    int i;\n    for(i=0;i<(1<<MAX);i++)\n      if(o) init(i,s);\n      else break;\n    cout << (o?\"YES\":\"NO\") << endl;\n  }\n  return 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\n\nusing namespace std;\n\nclass ParseError {};\ntypedef string::const_iterator State;\n\nbool expression(State&);\n\nbool expression(State &begin) {\n\tif(*begin == 'T') return true;\n\telse if(*begin == 'F') return false;\n\telse if(*begin == '-' && *(begin+1) != '>'){\n\t\tbegin++;\n\t\treturn !expression(begin);\n\t}\n\telse {\n\t\t begin++;\n\t\t bool a = expression(begin);\n\t\t begin++;\n\t\t if(*begin == '*'){\n\t\t \tbegin++;\n\t\t\treturn a && expression(begin);\n\t\t }\n\t\t else if(*begin == '-' && *(begin+1) == '>'){\n\t\t \tbegin++; begin++;\n\t\t\tbool b = expression(begin);\n\t\t\tif(a && !b) return false;\n\t\t\telse return true;\n\t\t }\n\t\t else if (*begin == '+') {\n\t\t\tbegin++;\n\t\t\treturn a || expression(begin);\n\t\t}\n\t}\n}\n\nint main(){\n\tstring e;\n\twhile(cin >> e, e != \"#\"){\n\t\tbool possible = true;\n\t\tfor(int i=0; i < 1<<11; i++){\n\t\t\tstring s = e;\n\t\t\tstring t = \"abcdefghijk\";\n\t\t\tfor(int j=0; j < s.size(); j++){\n\t\t\t\tfor(int k=0; k < t.size(); k++){\n\t\t\t\t\tif(s[j] == t[k]) s[j] = ((i >> k) & 1 == 1 ? 'T' : 'F');\n\t\t\t\t}\n\t\t\t}\n\t\t\tstring a, b;\n\t\t\tfor(int i=0; i< s.size(); i++) if(s[i] == '='){a = s.substr(0, i); b = s.substr(i+1);}\n\t\t\tState abegin = a.begin();\n\t\t\tState bbegin = b.begin();\n\n\t\t\tif(!(expression(abegin) == expression(bbegin))){possible = false; break;}\n\t\t}\n\t\tcout << (possible ? \"YES\" : \"NO\") << endl;\n\t}\n}"
  },
  {
    "language": "C++",
    "code": "\n#include<iostream>\n#include<string>\nusing namespace std;\n\nstruct DATA{\n  string ans;\n  int i;\n  DATA(string s,int n){ans=s;i=n;}\n};\n\nstring equation(string s);\nDATA formula(string s, int i);\n\nstring equation(string s){\n  DATA res=formula(s,0);\n  return res.ans;\n}\n\nDATA formula(string s, int i)\n{\n  if(s[i]=='T')return DATA(\"T\",i+1);\n  if(s[i]=='F')return DATA(\"F\",i+1);\n  if(s[i]=='-'){\n    DATA res=formula(s,i+1);\n    if(res.ans==\"T\")return DATA(\"F\",res.i);\n    else return DATA(\"T\",res.i);\n  }\n  if(s[i]=='('){\n    string res,op;\n    DATA res1 = formula(s,i+1);\n    i=res1.i;\n    op=s[i];\n    if(op==\"-\")i++;\n    DATA res2 = formula(s,i+1);\n    i=res2.i;\n\n    if(op==\"*\"){\n      if( (res1.ans==\"T\") & (res2.ans==\"T\") ) res=\"T\";\n      else res=\"F\";\n    }\n    if(op==\"+\"){\n      if( (res1.ans==\"T\") | (res2.ans==\"T\") ) res=\"T\";\n      else res=\"F\";\n    }\n    if(op==\"-\"){\n      if( (res1.ans==\"T\") && (res2.ans==\"F\") ) res=\"F\";\n      else res=\"T\";\n    }\n    return DATA(res,i+1);\n  }\n}\n\nint main()\n{\n  bool ok;\n  string in,s1,s2;\n  while(cin>>in,in!=\"#\"){\n    ok=true;\n    for(int i=0;i<(1<<11);i++){\n      s1=in;\n      for(int j=0;j<11;j++){\n\tif(i>>j&1){\n\t  while(s1.find('a'+j,0)!=string::npos){\n\t    s1.replace(s1.find('a'+j,0),1,\"T\");\n\t  }\n\t}else{\n\t  while(s1.find('a'+j,0)!=string::npos){\n\t    s1.replace(s1.find('a'+j,0),1,\"F\");\n\t  }\n\t}\n      }\n      s2=s1.substr(s1.find(\"=\",0)+1);\n      s1=s1.substr(0,s1.find(\"=\",0));\n      if(equation(s1)!=equation(s2))ok=false;\n    }\n    if(ok)puts(\"YES\");\n    else puts(\"NO\");\n  }\n}"
  },
  {
    "language": "C++",
    "code": "#include <functional>\n#include <iostream>\n#include <memory>\n#include <string>\n#include <unordered_set>\n#include <vector>\n#define loop(i, a, n) for (int i = (a); i < (n); i++)\n#define rep(i, n) loop(i, 0, n)\ntemplate<typename A> using F = std::function<A>;\nusing namespace std;\n\ntemplate<typename T> struct ParseResult {\n  bool succeeded;\n  T object;\n  size_t pos;\n  ParseResult(const bool succeeded, const T &object, const size_t pos) : succeeded(succeeded), object(object), pos(pos) {}\n  friend std::ostream &operator<<(std::ostream &os, const ParseResult<T> &p) { return os << '{' << (p.succeeded ? \"true\" : \"false\") << ',' << p.object << ',' << p.pos << '}'; }\n};\n\ntemplate<typename T> using Parser = std::function<ParseResult<T>(const std::string &, size_t)>;\n\nParser<std::string> token(std::string s) {\n  const size_t n = s.size();\n  return [n = std::move(n), s = std::move(s)](const std::string &target, const size_t pos) {\n    if (target.size() < n) return ParseResult<std::string>(false, {}, pos);\n    return target.substr(pos, n) == s ? ParseResult<std::string>(true, s, pos + n) : ParseResult<std::string>(false, {}, pos);\n  };\n}\n\ntemplate<typename T> Parser<T> operator||(Parser<T> p1, Parser<T> p2) {\n  return [p1 = std::move(p1), p2 = std::move(p2)](const std::string &target, const size_t pos) {\n    auto r = p1(target, pos);\n    if (r.succeeded) return r;\n    r = p2(target, pos);\n    if (r.succeeded) return r;\n    return ParseResult<T>(false, {}, pos);\n  };\n}\n\ntemplate<typename T1, typename T2> Parser<std::pair<T1, T2>> operator+(Parser<T1> p1, Parser<T2> p2) {\n  return [p1 = std::move(p1), p2 = std::move(p2)](const std::string &target, const size_t pos) {\n    auto r1 = p1(target, pos);\n    if (!r1.succeeded) return ParseResult<std::pair<T1, T2>>(false, {}, pos);\n    auto r2 = p2(target, r1.pos);\n    if (!r2.succeeded) return ParseResult<std::pair<T1, T2>>(false, {}, pos);\n    return ParseResult<std::pair<T1, T2>>(true, {r1.object, r2.object}, r2.pos);\n  };\n}\n\ntemplate<typename T1, typename T2> Parser<T2> operator>>(Parser<T1> p1, Parser<T2> p2) {\n  return [p1 = std::move(p1), p2 = std::move(p2)](const std::string &target, const size_t pos) {\n    auto r1 = p1(target, pos);\n    if (!r1.succeeded) return ParseResult<T2>(false, {}, pos);\n    auto r2 = p2(target, r1.pos);\n    if (!r2.succeeded) return ParseResult<T2>(false, {}, pos);\n    return ParseResult<T2>(true, r2.object, r2.pos);\n  };\n}\n\ntemplate<typename T1, typename T2> Parser<T1> operator<<(Parser<T1> p1, Parser<T2> p2) {\n  return [p1 = std::move(p1), p2 = std::move(p2)](const std::string &target, const size_t pos) {\n    auto r1 = p1(target, pos);\n    if (!r1.succeeded) return ParseResult<T1>(false, {}, pos);\n    auto r2 = p2(target, r1.pos);\n    if (!r2.succeeded) return ParseResult<T1>(false, {}, pos);\n    return ParseResult<T1>(true, r1.object, r2.pos);\n  };\n}\n\nParser<char> oneOf(const std::string &s) {\n  std::unordered_set<char> d;\n  for (auto &c : s) d.insert(c);\n  return [d = std::move(d)](const std::string &target, const size_t pos) {\n    if (target.size() <= pos) return ParseResult<char>(false, {}, pos);\n    char c = target[pos];\n    return d.count(c) ? ParseResult<char>(true, c, pos + 1) : ParseResult<char>(false, {}, pos);\n  };\n}\n\ntemplate<typename T, typename S, typename F> Parser<S> fmap(Parser<T> p, F &&f) {\n  return [p = std::move(p), f = std::forward<F>(f)](const std::string &target, const size_t pos) {\n    auto r = p(target, pos);\n    return r.succeeded ? ParseResult<S>(true, f(r.object), r.pos) : ParseResult<S>(false, {}, r.pos);\n  };\n}\n\ntemplate<typename T, typename F> Parser<T> lazy(const F &f) {\n  bool instantiated = false;\n  Parser<T> p;\n  return [f = std::move(f), p = std::move(p), instantiated = std::move(instantiated)](const std::string &target, const size_t pos) mutable {\n    if (!instantiated) {\n      p = f();\n      instantiated = true;\n    }\n    return p(target, pos);\n  };\n}\n\ntemplate<typename T> Parser<T> makeView(Parser<T> &&p) {\n  return [p = std::make_shared<Parser<T>>(std::move(p))](const std::string &target, const size_t pos) { return (*p)(target, pos); };\n}\n\nstruct SyntaxTree {\n  string op;\n  char value;\n  vector<SyntaxTree> children;\n  SyntaxTree() {}\n  SyntaxTree(const string &op, const char value, const vector<SyntaxTree> &children) : op(op), value(value), children(children) {}\n};\n\nint main() {\n  Parser<SyntaxTree> formulaP = makeView<SyntaxTree>(lazy<SyntaxTree>([&]() {\n    auto andP = fmap<pair<SyntaxTree, SyntaxTree>, SyntaxTree>((token(\"(\") >> formulaP << token(\"*\")) + (formulaP << token(\")\")), [](auto &o) { return SyntaxTree(\"*\", {}, {o.first, o.second}); });\n    auto orP = fmap<pair<SyntaxTree, SyntaxTree>, SyntaxTree>((token(\"(\") >> formulaP << token(\"+\")) + (formulaP << token(\")\")), [](auto &o) { return SyntaxTree(\"+\", {}, {o.first, o.second}); });\n    auto impP = fmap<pair<SyntaxTree, SyntaxTree>, SyntaxTree>((token(\"(\") >> formulaP << token(\"->\")) + (formulaP << token(\")\")), [](auto &o) { return SyntaxTree(\"->\", {}, {o.first, o.second}); });\n    auto notP = fmap<SyntaxTree, SyntaxTree>(token(\"-\") >> formulaP, [](auto &o) { return SyntaxTree(\"-\", {}, {o}); });\n    auto valP = fmap<char, SyntaxTree>(oneOf(\"abcdefghijkTF\"), [](char x) { return SyntaxTree({}, x, {}); });\n    return andP || orP || impP || notP || valP;\n  }));\n  auto equationP = (formulaP << token(\"=\")) + formulaP;\n  string s;\n  while (cin >> s, s != \"#\") {\n    auto r = equationP(s, 0);\n    bool isValid = true;\n    rep(i, 1 << 11) {\n      auto toBool = [&](char c) -> bool {\n        if (c == 'T') return true;\n        if (c == 'F') return false;\n        return i >> (c - 'a') & 1;\n      };\n      F<bool(const SyntaxTree &)> evalF = [&](const SyntaxTree &f) {\n        switch (f.children.size()) {\n          case 0: return toBool(f.value);\n          case 1: return !evalF(f.children[0]);\n          case 2:\n            if (f.op == \"*\") return evalF(f.children[0]) && evalF(f.children[1]);\n            if (f.op == \"+\") return evalF(f.children[0]) || evalF(f.children[1]);\n            if (f.op == \"->\") return !evalF(f.children[0]) || evalF(f.children[1]);\n        }\n      };\n      isValid &= evalF(r.object.first) == evalF(r.object.second);\n    }\n    cout << (isValid ? \"YES\" : \"NO\") << endl;\n  }\n}"
  },
  {
    "language": "C++",
    "code": "#include<bits/stdc++.h>\nusing namespace std;\n\nstring s;\nint p;\n\nint equation();\nint formula();\n\n//1:true 0:false\nint equation(){\n  int a=formula();\n  if(s[p]=='=')p++;//'='\n  int b=formula();\n  cout<<\"a \"<<a<<\" b \"<<b<<endl;\n  //if(a==b && a!=-1)return 1;\n  else return 0;\n}\n\n//1:true 0:false -1:?????°\nint formula(){\n  if(s[p]=='-'){\n    p++;//'-'\n    int a=formula();\n    if(a==1)return 0;\n    else return 1;\n  }\n  else if(s[p]=='('){\n    p++;//'('\n    int a=formula();\n    char tmp=s[p];//?????????\n    p++;//'*', '+', '->'\n    if(s[p]=='>')p++;//'->'\n    int b=formula();\n    p++;//')'\n\n    if(tmp=='*'){\n      if(a==b && a==1)return 1;\n      else return 0;\n    }\n    else if(tmp=='+'){\n      if(a==1 || b==1)return 1;\n      else return 0;\n    }\n    else{\n      if(a==1 && b==0)return 0;\n      else return 1;\n    }\n  }\n  else{\n    if(s[p]=='T'){p++; return 1;}\n    else if(s[p]=='F'){p++; return 0;}\n    else{p++; return -1;}//?????°\n  }\n}\n\n\nint main(){\n  while(cin>>s, s!=\"#\"){\n    p=0;\n    if(equation())cout<<\"YES\"<<endl;\n    else cout<<\"NO\"<<endl;\n  }\n  return 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\n#include<stdio.h>\nusing namespace std;\n#define FOR(i,k,n) for(int i = (k); i < (n); i++)\n#define REP(i,n) FOR(i,0,n)\n#define ALL(a) begin(a),end(a)\n#define MS(m,v) memset(m,v,sizeof(m))\n#define D10  fixed<<setprecision(10)\ntypedef vector<int> vi;\ntypedef vector<string> vs;\ntypedef pair<int, int> P;\ntypedef long long ll;\nconst ll INF = 114514810;\nconst ll MOD = 1000000007;\nconst double EPS = 1e-8;\nconst double PI = acos(-1.0);\nstruct edge\n{\n\tint to, cost;\n\tbool operator < (const edge& e) const { return cost < e.cost; }\n\tbool operator >(const edge& e) const { return cost > e.cost; }\n};\nint dx[] = { -1, 0, 0, 1 }; int dy[] = { 0, -1, 1, 0 };\ntemplate<class T> T &chmin(T &a, const T &b) { return a = min(a, b); }\ntemplate<class T> T &chmax(T &a, const T &b) { return a = max(a, b); }\nbool valid(int x, int y, int h, int w) { return (x >= 0 && y >= 0 && x < h&&y < w); }\n///*************************************************************************************///\n///*************************************************************************************///\n///*************************************************************************************///\n\nint p;\nmap<char, char> li;\nint solve(const string& s);\n\nint elem(const string &s)\n{\n\tif (s[p] == '(')\n\t{\n\t\tp++;\n\t\tint buf = solve(s);\n\t\tp++;\n\t\treturn buf;\n\t}\n\tif (s[p] == '-'&&s[p + 1] != '>')\n\t{\n\t\tp++;\n\t\treturn solve(s) == 0 ? 1 : 0;\n\t}\n\tint res = li[s[p]] == 'T' ? 1 : 0;\n\treturn res;\n}\n\nint solve(const string& s)\n{\n\tint tmp = elem(s);\n\twhile (s[p] == '*' || s[p] == '+')\n\t{\n\t\tchar c = s[p];\n\t\tp++;\n\t\tif (c == '*') tmp *= elem(s);\n\t\telse if (c == '+')\n\t\t{\n\t\t\ttmp += elem(s);\n\t\t\tif (tmp != 0) tmp = 1;\n\t\t}\n\t\telse\n\t\t{\n\t\t\ttmp = elem(s) == 0 ? 1 : 0;\n\t\t}\n\t}\n\twhile (s[p] == '-'&&s[p + 1] == '>')\n\t{\n\t\tp += 2;\n\t\tif (tmp == 1 && elem(s) == 0) tmp = 0;\n\t\telse tmp = 1;\n\t}\n\treturn tmp;\n}\n\nint main()\n{\n\tstring str, s, t;\n\twhile (cin >> str)\n\t{\n\t\tif (str == \"#\") break;\n\t\tint eq = str.find('=');\n\t\ts = str.substr(0, eq);\n\t\tt = str.substr(eq + 1);\n\t\tp = 0;\n\t\tbool ans = true;\n\t\tREP(i, 1 << 11)\n\t\t{\n\t\t\tli.clear();\n\t\t\tREP(j, 2)\n\t\t\t{\n\t\t\t\tli['a' + j] = ((i >> j) & 1) ? 'T' : 'F';\n\t\t\t}\n\t\t\tp = 0;\n\t\t\tint l = solve(s);\n\t\t\tp = 0;\n\t\t\tint r = solve(t);\n\t\t\tif (l != r) ans = false;\n\t\t}\n\t\tputs(ans ? \"YES\" : \"NO\");\n\t}\n\treturn 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include <string>\n#include <iostream>\nusing namespace std;\nstring s[5];\nbool solve(int l, int r, int e) {\n\tif (s[e][l] == 'T') return true;\n\tif (s[e][l] == 'F') return false;\n\tif (s[e][l] == '-') return !solve(l + 1, r, e);\n\tint d = 0;\n\tfor (int i = l + 1; i < r - 1; i++) {\n\t\tif (s[e][i] == '(') d++;\n\t\tif (s[e][i] == ')') d--;\n\t\tif (s[e][i] == '*') return solve(l + 1, i, e) && solve(i + 1, r - 1, e);\n\t\tif (s[e][i] == '+') return solve(l + 1, i, e) || solve(i + 1, r - 1, e);\n\t\tif (s[e][i] == '-' && s[e][i + 1] == '>') return !solve(l + 1, i, e) || solve(i + 2, r - 1, e);\n\t}\n\treturn true;\n}\nint main() {\n\twhile (cin >> s[0], s[0] != \"#\") {\n\t\tfor (int i = 0; i < s[0].size(); i++) {\n\t\t\tif (s[0][i] == '=') {\n\t\t\t\ts[1] = s[0].substr(0, i);\n\t\t\t\ts[2] = s[0].substr(i + 1, s[0].size() - i - 1);\n\t\t\t}\n\t\t}\n\t\tbool flag = true;\n\t\tfor (int i = 0; i < 2048; i++) {\n\t\t\ts[3] = s[1], s[4] = s[2];\n\t\t\tfor (int j = 0; j < 11; j++) {\n\t\t\t\tfor (int k = 0; k < s[3].size(); k++) {\n\t\t\t\t\tif (s[1][k] == j + 97) s[3][k] = (i & (1 << j)) ? 'T' : 'F';\n\t\t\t\t}\n\t\t\t\tfor (int k = 0; k < s[4].size(); k++) {\n\t\t\t\t\tif (s[2][k] == j + 97) s[4][k] = (i & (1 << j)) ? 'T' : 'F';\n\t\t\t\t}\n\t\t\t}\n\t\t\tif (solve(0, s[3].size(), 3) != solve(0, s[4].size(), 4)) {\n\t\t\t\tflag = false; break;\n\t\t\t}\n\t\t}\n\t\tprintf(\"%s\\n\", flag ? \"YES\" : \"NO\");\n\t}\n\treturn 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include<iostream>\n#include<vector>\n#include<string>\n#include<algorithm>\n#define all(c) c.begin(),c.end()\n#define uni(c) c.erase(unique(c.begin(),c.end()),c.end())\n#define pb push_back\nusing namespace std;\n\nint expr(string& s, int& i);\nint term(string& s, int& i);\nint factor(string& s, int& i);\nint number(string& s, int& i);\n\n\nint expr(string& s, int& i) {\n  int val = factor(s, i);\n  while(s[i] == '+' || s[i] == '-'|| s[i]=='*') {\n    char op = s[i];\n    i++;\n  \tif(s[i]=='>'){\n  \t\ti++;\n  \t\tint val2 = factor(s, i);\n  \t\tif(val==1&&val2==0){\n  \t\t\tval=0;\n  \t\t}else{\n  \t\t\tval=1;\n  \t\t}\n  \t}else{\n  \t\t\n  \t  int val2 = factor(s, i);\n    \tif (op == '+') \n  \t\t\tval |= val2;\n  \t\telse if(op=='*')\n  \t\t\tval *= val2;\n  \t\t//cout<<\"   \"<<val<<\" \"<<val2<<endl;\n  \t}\n  \t\n  }\n  return val;\n}\n\n/*int term(string& s, int& i) {\n  int val = factor(s, i);\n  while(s[i] == '*') {\n    char op = s[i];\n    i++;\n    int val2 = factor(s, i);\n    if (op == '*') val *= val2;\n  }\n  return val;\n}\n*/\nint factor(string& s, int& i) {\n\tint flag=0;\n\tif(s[i]=='-'){\n\t\tflag=1;\n\t\ti++;\n\t}\n\tif (isdigit(s[i])){\n\t\tif(flag)\n\t\t\treturn flag^number(s, i);\n\t\t\treturn number(s,i);\n\t}\n\n  // ここで構文が正しければ s[i] == '(' となる\n  i++; // '('を読み飛ばす\n  int ret = expr(s, i);\n  i++; // ')'を読み飛ばす\n\tif(flag)\n\treturn flag^ret;\n\treturn ret;\n}\n\nint number(string& s, int& i) {\n  int n = s[i++] - '0';\n  while(isdigit(s[i])) n = n*10 + s[i++] - '0';\n  return n;\n}\n\nint main(){\n\tstring s;\n\twhile(cin>>s,s!=\"#\"){\n\t\tint eq=0;\n\t\tstring a,b;\n\t\tfor(int i=0;i<s.size();i++){\n\t\t\tif(s[i]=='T')\n\t\t\ts[i]='1';\n\t\t\telse if(s[i]=='F')\n\t\t\ts[i]='0';\n\t\t}\n\t\tfor(;s[eq]!='=';eq++);\n\t\ta=s.substr(0,eq),b=s.substr(eq+1,s.size()-eq);\n\t\t//cout<<a<<\" \"<<b<<endl;\n\t\tvector<char> ap;\n\t\t\n\t\tfor(int i=0;i<s.size();i++){\n\t\t\tif(isalpha(s[i]))\n\t\t\t\tap.pb(s[i]);\n\t\t}\n\t\tsort(all(ap));\n\t\tuni(ap);\n\t\tbool flag=true;\n\t\tfor(int i=0;i<(1<<ap.size());i++){\n\t\t\tstring x=a,y=b;\n\t\t\tfor(int j=0;j<ap.size();j++){\n\t\t\t\tchar c=ap[j];\n\t\t\t\tbool wh=false;\n\t\t\t\tif((1<<j)&i)\n\t\t\t\t\twh=true;\n\t\t\t\tfor(int k=0;k<x.size();k++){\n\t\t\t\t\tif(x[k]==c){\n\t\t\t\t\t\tif(wh)\n\t\t\t\t\t\t\tx[k]='1';\n\t\t\t\t\t\telse\n\t\t\t\t\t\t\tx[k]='0';\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t\tfor(int k=0;k<y.size();k++){\n\t\t\t\t\tif(y[k]==c){\n\t\t\t\t\t\tif(wh)\n\t\t\t\t\t\t\ty[k]='1';\n\t\t\t\t\t\telse\n\t\t\t\t\t\t\ty[k]='0';\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t}\n\t\t\t\n\t\t\tint i=0,j=0;\n\t\t\t/*cout<<x<<\" \"<<y<<endl;\n\t\t\tcout<<expr(x,i)<<\"--\"<<endl;\n\t\t\tcout<<expr(y,j)<<endl;\n\t\t\ti=0,j=0;*/\n\t\t\tif(expr(x,i)!=expr(y,j)){\n\t\t\t\tcout<<\"NO\"<<endl;\n\t\t\t\tflag=false;\n\t\t\t\tbreak;\n\t\t\t}\n\t\t\t\n\t\t}\n\t\tif(flag)\n\t\t\tcout<<\"YES\"<<endl;\n\t}\n\treturn 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include <iostream>\n#include <cstdio>\n#include <iomanip>\n#include <vector>\n#include <map>\n#include <set>\n#include <queue>\n#include <bitset>\n#include <stack>\n#include <utility>\n#include <numeric>\n#include <algorithm>\n#include <functional>\n#include <cctype>\n#include <complex>\n#include <string>\n#include <sstream>\n\nusing namespace std;\n\n#define all(c) c.begin(),c.end()\n#define rall(c) c.rbegin(),c.rend()\n#define mp(a,b) make_pair((a),(b))\n#define eq ==\n\ntypedef long long ll;\ntypedef complex<double> point;\ntypedef pair<int,int> pii;\n\n// →↑←↓\nconst int dx[] = {1,0,-1,0};\nconst int dy[] = {0,-1,0,1};\n\n\nconst double EPS = 1e-9;\n\n//<equation> ::= <formula> \"=\" <formula>\n//<formula>  ::= \"T\" | \"F\" |\n//\"a\" | \"b\" | \"c\" | \"d\" | \"e\" | \"f\" |\n//\"g\" | \"h\" | \"i\" | \"j\" | \"k\" |\n//\"-\" <formula> |\n//\"(\" <formula> \"*\" <formula> \")\" |\n//\"(\" <formula> \"+\" <formula> \")\" |\n//\"(\" <formula> \"->\" <formula> \")\"\n\ntypedef string::const_iterator Cursor;\n\nbool expression(Cursor&);\nbool formula(Cursor&);\n\nbool expression(Cursor &c){\n    bool left = formula(c);\n    c++;\n    bool right = formula(c);\n    return left == right;\n}\n\nmap<char,bool> vmap;\nbool formula(Cursor &c){\n    if(*c == 'T'){\n        c++;\n        return true;\n    }else if(*c == 'F'){\n        c++;\n        return false;\n    }else if(*c == '-'){\n        c++;\n        return not formula(c);\n    }else if(*c == '('){\n        c++;\n        bool left = formula(c);\n        if(*c == '*'){\n            c++;\n            bool right = formula(c);\n            c++;\n            return left and right;\n        }else if(*c == '+'){\n            c++;\n            bool right = formula(c);\n            c++;\n            return left or right;\n        }else if(*c == '-'){\n            // ->\n            c++;c++;\n            bool right = formula(c);\n            c++;\n            return not (left and (not right));\n        }\n    }else{\n        return vmap[*(c++)];\n    }\n}\n\nint main(){\n    const char c[] = {'a','b','c','d','e','f','g','h','i','j','k'};\n    const int N = 11;\n    while(true){\n        bool ok = true;\n        string st;\n        getline(cin,st);\n        if(st == \"#\") break;\n        for(int s=0;s<(1 << N);s++){\n            for(int i=0;i<N;i++){\n                if(s & (1 << i)){\n                    vmap[c[i]] = true;\n                }else{\n                    vmap[c[i]] = false;;\n                }\n            }\n            Cursor c = st.begin();\n            if(not expression(c)){\n                ok = false;\n            }\n        }\n        if(ok){\n            cout << \"YES\" << endl;\n        }else{\n            cout << \"NO\" << endl;\n        }\n    }\n    return 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include<iostream>\n#include<string>\nusing namespace std;\n\nint mynot(int a){\n\tif(a==1) return 0;\n\treturn 1;\n}\n\nint myand(int a,int b){\n\tif(a==1 && b==1) return 1;\n\treturn 0;\n}\n\nint myor(int a,int b){\n\tif(a==0 && b==0) return 0;\n\treturn 1;\n}\n\nint naraba(int a,int b){\n\tif(a==0 || (a==1 && b==1)) return 1;\n\treturn 0;\n}\n\nstring s;\nint bit=0;\nint p=0;\n\nint to_int(char a){\n\tif(a=='T') return 1;\n\tif(a=='F') return 0;\n\tint k=a-'a';\n\tif(bit & (1<<k)) return 1;\n\treturn 0;\n}\n\n\nint calc(){\n\tif(isalpha(s[p])) return to_int(s[p++]);\n\n\tif(s[p]=='-'){\n\t\tp++;\n\t\treturn mynot(calc());\n\t}\n\n\tif(s[p]=='('){\n\t\tp++;\n\t\tint res1=calc();\n\t\tif(s[p]=='*'){\n\t\t\tp++;\n\t\t\tint res2=calc();\n\t\t\tp++;\n\t\t\treturn myand(res1,res2);\n\t\t}\n\t\telse if(s[p]=='+'){\n\t\t\tp++;\n\t\t\tint res2=calc();\n\t\t\tp++;\n\t\t\treturn myor(res1,res2);\n\t\t}\n\t\telse if(s[p]=='-'){\n\t\t\tp+=2; //>を読み飛ばす\n\t\t\tint res2=calc();\n\t\t\tp++;\n\t\t\treturn naraba(res1,res2);\n\t\t}\n\t}\n\tcerr<<\"Error\"<<endl;\n\treturn -1;\n}\n\n\nint main()\n{\n\twhile(cin>>s && s[0]!='#'){\n\t\tbool ok=true;\n\t\tfor(bit=0;bit<(1<<11);bit++){\n//\t\t\tcout<<bit<<endl;\n\t\t\tp=0;\n\t\t\tint ans1=calc();\n\t\t\tp++; //=読み飛ばし\n\t\t\tint ans2=calc();\n\t\t\tif(ans1!=ans2){ok=false;break;}\n\t\t}\n\t\tif(ok) cout<<\"YES\"<<endl;\n\t\telse cout<<\"NO\"<<endl;\n\t}\n\treturn 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include<iostream>\n#include<string>\n#include<vector>\n#define MAX 11\nusing namespace std;\nbool o;\nvoid rec(string s){\n  if(!o) return;\n  //cout << s << endl;\n  while(1){\n    bool f=false;\n    int p;\n    \n    while(s.find(\"-0\")!=-1){\n      p=s.find(\"-0\");\n      s[p]='1';s[p+1]=' ';\n      f=true;\n    }\n    while(s.find(\"-1\")!=-1){\n      p=s.find(\"-1\");\n      s[p]='0';s[p+1]=' ';\n      f=true;\n    }\n    while(s.find(\"(0*0)\")!=-1){\n      p=s.find(\"(0*0)\");\n      s[p]='0';s[p+1]=' ';s[p+2]=' ';s[p+3]=' ';s[p+4]=' ';\n      f=true;\n    }\n    while(s.find(\"(0*1)\")!=-1){\n      p=s.find(\"(0*1)\");\n      s[p]='0';s[p+1]=' ';s[p+2]=' ';s[p+3]=' ';s[p+4]=' ';\n      f=true;\n    }\n    while(s.find(\"(1*0)\")!=-1){\n      p=s.find(\"(1*0)\");\n      s[p]='0';s[p+1]=' ';s[p+2]=' ';s[p+3]=' ';s[p+4]=' ';\n      f=true;\n    }\n    while(s.find(\"(1*1)\")!=-1){\n      p=s.find(\"(1*1)\");\n      s[p]='1';s[p+1]=' ';s[p+2]=' ';s[p+3]=' ';s[p+4]=' ';\n      f=true;\n    }\n    while(s.find(\"(0+0)\")!=-1){\n      p=s.find(\"(0+0)\");\n      s[p]='0';s[p+1]=' ';s[p+2]=' ';s[p+3]=' ';s[p+4]=' ';\n      f=true;\n    }\n    while(s.find(\"(0+1)\")!=-1){\n      p=s.find(\"(0+1)\");\n      s[p]='1';s[p+1]=' ';s[p+2]=' ';s[p+3]=' ';s[p+4]=' ';\n      f=true;\n    }\n    while(s.find(\"(1+0)\")!=-1){\n      p=s.find(\"(1+0)\");\n      s[p]='1';s[p+1]=' ';s[p+2]=' ';s[p+3]=' ';s[p+4]=' ';\n      f=true;\n    }\n    while(s.find(\"(1+1)\")!=-1){\n      p=s.find(\"(1+1)\");\n      s[p]='1';s[p+1]=' ';s[p+2]=' ';s[p+3]=' ';s[p+4]=' ';\n      f=true;\n    }\n    \n    while(s.find(\"(0->0)\")!=-1){\n      p=s.find(\"(0->0)\");\n      s[p]='1';s[p+1]=' ';s[p+2]=' ';s[p+3]=' ';s[p+4]=' ';s[p+5]=' ';\n      f=true;\n    }\n    while(s.find(\"(0->1)\")!=-1){\n      p=s.find(\"(0->1)\");\n      s[p]='1';s[p+1]=' ';s[p+2]=' ';s[p+3]=' ';s[p+4]=' ';s[p+5]=' ';\n      f=true;\n    }\n    while(s.find(\"(1->0)\")!=-1){\n      p=s.find(\"(1->0)\");\n      s[p]='0';s[p+1]=' ';s[p+2]=' ';s[p+3]=' ';s[p+4]=' ';s[p+5]=' ';\n      f=true;\n    }\n    while(s.find(\"(1->1)\")!=-1){\n      p=s.find(\"(1->1)\");\n      s[p]='1';s[p+1]=' ';s[p+2]=' ';s[p+3]=' ';s[p+4]=' ';s[p+5]=' ';\n      f=true;\n    }\n    \n    if(f){\n      string b;\n      for(int i=0;i<s.size();i++) if(s[i]!=' ') b+=s[i];\n      s=b;\n    }else{\n      if(s[0]!=s[2]) o=false;\n      return;\n    }\n  }\n}\nbool fi;\nvector<int> v[11];\nvoid init(int n,string s){\n  int i,j;\n  if(fi){\n    for(j=0;j<MAX;j++) v[j].clear();\n    for(i=0;i<s.size();i++){\n      for(j=0;j<MAX;j++){\n\tif(s[i]=='a'+j) {\n\t  s[i]='0'+(n>>j&1);\n\t  v[j].push_back(i);\n\t}\n      }\n    }\n    fi=false;\n  }else{\n    for(i=0;i<MAX;i++){\n      for(j=0;j<v[i].size();j++){\n\ts[v[i][j]]='0'+(n>>i&1);\n      }\n    }\n  }\n  //cout << s << endl;\n  rec(s);\n  if(!o) return;\n}\nint main(){\n  string s;\n  while(cin >> s,s!=\"#\"){\n    o=true;\n    int i;\n    fi=true;\n    for(i=0;i<s.size();i++){\n      if(s[i]=='T') s[i]='1';\n      if(s[i]=='F') s[i]='0';\n    }\n    for(i=0;i<(1<<MAX);i++)\n      if(o) init(i,s);\n      else break;\n    cout << (o?\"YES\":\"NO\") << endl;\n  }\n  return 0;\n}"
  },
  {
    "language": "C++",
    "code": "// g++ -std=c++11 a.cpp\n#include<iostream>\n#include<vector>\n#include<string>\n#include<algorithm>\t\n#include<map>\n#include<set>\n#include<utility>\n#include<cmath>\n#include<cstring>\n#include<queue>\n#include<stack>\n#include<bitset>\n#include<cstdio>\n#include<sstream>\n#include<iomanip>\n#include<assert.h>\n#include<typeinfo>\n#define loop(i,a,b) for(int i=a;i<b;i++) \n#define rep(i,a) loop(i,0,a)\n#define pb push_back\n#define all(in) in.begin(),in.end()\n#define shosu(x) fixed<<setprecision(x)\nusing namespace std;\n//kaewasuretyuui\ntypedef long long ll;\n//#define int ll\ntypedef int Def;\ntypedef pair<Def,Def> pii;\ntypedef vector<Def> vi;\ntypedef vector<vi> vvi;\ntypedef vector<pii> vp;\ntypedef vector<vp> vvp;\ntypedef vector<string> vs;\ntypedef vector<double> vd;\ntypedef vector<vd> vvd;\ntypedef pair<Def,pii> pip;\ntypedef vector<pip>vip;\n// #define mt make_tuple\n//typedef tuple<pii,int,int> tp;\n//typedef vector<tp> vt;\ntemplate<typename A,typename B>bool cmin(A &a,const B &b){return a>b?(a=b,true):false;}\ntemplate<typename A,typename B>bool cmax(A &a,const B &b){return a<b?(a=b,true):false;}\n//template<class C>constexpr int size(const C &c){return (int)c.size();}\n//template<class T,size_t N> constexpr int size(const T (&xs)[N])noexcept{return (int)N;}\nconst double PI=acos(-1);\nconst double EPS=1e-7;\nDef inf = sizeof(Def) == sizeof(long long) ? 2e18 : 1e9;\nint dx[]={0,1,0,-1};\nint dy[]={1,0,-1,0};\ntypedef string::const_iterator State;\nint q;\nDef formula(State &i){\n\tDef out;\n\tif(*i=='('){\n\t\ti++;\n\t\tout=formula(i);\n\t}else if(*i=='T')out=1;\n\telse if(*i=='F')out=0;\n\telse if(*i=='-')out=1-formula(++i);\n\telse if(isalpha(*i))out=(q>>(*i-'a'))&1;\n\ti++;\n\tint op=0;\n\tif(*i=='+')op=1;\n\tif(*i=='-'){op=2;i++;}\n\tif(*i=='*')op=3;\n\tif(op){\n\t\ti++;\n\t\tDef out1=formula(i);\n\t\tif(op==1)out|=out1;\n\t\tif(op==2)out=!out||out&&!out1;\n\t\tif(op==3)out&=out1;\n\t\t\n\t}\n\treturn out;\n}\nint main(){\n\tstring s,t;\n\twhile(1){\n\t\tgetline(cin,s);\n\t\tif(s==\"#\")break;\n\t\trep(i,s.size())if(s[i]=='='){\n\t\t\tt=s.substr(i+1);\n\t\t\ts=s.substr(0,i);\n\t\t}\n\t\tbool h=true;\n\t\trep(i,1<<11){\n\t\t\tq=i;\n\t\t\tState S=s.begin(),T=t.begin();\n\t\t\tif(formula(S)==formula(T)){\n\t\t\t\th=false;\n\t\t\t\tbreak;\n\t\t\t}\n\t\t}\n\t\tif(h)cout<<\"YES\"<<endl;\n\t\telse cout<<\"NO\"<<endl;\n\t}\n}"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\nusing namespace std;\n#define rep(i,n) for(int i=0;i<(n);i++)\n\nstring ss;\nint not_[2] = {1,0};\nint and_[2][2] = { {0,0},{0,1}};\nint or_[2][2] = { {0,1},{1,1}};\nint imp_[2][2] = { {1,1},{0,1}};\nint bit;\n\nint dfs(const string& formula,int& pos) {\n    //cout<<formula<<\",\"<<pos<<endl;\n    int ret;\n    if(formula[pos] =='T') ret = 1;\n    else if(formula[pos] =='F') ret = 0;\n\n    else if(formula[pos] == '-') return not_[dfs(formula,++pos)];\n    else if('a' <= formula[pos] && formula[pos] <= 'k') ret = (bit >> (formula[pos]-'a')) &1;\n    else if(formula[pos] == '(') {\n        ret = dfs(formula, ++pos);\n        if(formula[pos] == '+') ret = or_[ret][dfs(formula,++pos)];\n        else if(formula[pos] == '*') ret = and_[ret][dfs(formula,++pos)];\n        else if(formula[pos] == '-') {\n            pos++;\n            ret = imp_[ret][dfs(formula,++pos)];\n        }\n    }\n    pos++;\n    return ret;\n\n}\n\nvoid solve() {\n    string l = ss.substr(0,ss.find(\"=\"));\n    string r = ss.substr(ss.find(\"=\")+1);\n    int pos=0;\n    bool flag = true;\n    for(bit = 0; bit < (1<<11); bit++) {\n        pos = 0;\n        int tmp1 = dfs(l,pos);\n        pos = 0;\n        int tmp2 = dfs(r,pos);\n        if(tmp1!=tmp2) flag = false;\n    }\n    if(flag) cout<<\"YES\"<<endl;\n    else cout<<\"NO\"<<endl;\n}\n\nint main() {\n    while(cin>>ss) {\n        if(ss==\"#\") return 0;\n        solve();\n    }\n\n\n    return 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include<iostream>\n#include<vector>\n#include<string>\n#include<algorithm>\nusing namespace std;\n\n#define MAX_NUM 2\n#define MAX_CH 10\n#define MAX_N 1200\n\nstring S, T;\nchar NUM[MAX_NUM + 1] = \"01\";\nchar CH[MAX_CH + 1] = \"abcdefghij\";\nint TR[MAX_CH];\n\nint calc(string Y) {\n\treturn true;\n}\n\nint power(int a, int b) {\n\tint res2 = 1;\n\tfor (int i = 0; i < b; i++) {\n\t\tres2 *= a;\n\t}\n\treturn res2;\n}\n\nbool solve(string U) {\n\tbool RES = true;\n\tstring V = \"\";\n\tstring V1 = \"\", V2 = \"\";\n\tstring W1 = \"\", W2 = \"\";\n\n\tfor (int i = 0; i < U.size(); i++) {\n\t\tif (U[i] == 'T') {\n\t\t\tV += '1';\n\t\t\tgoto E;\n\t\t}\n\t\tif (U[i] == 'F') {\n\t\t\tV += '0';\n\t\t\tgoto E;\n\t\t}\n\t\tif (i < U.size() - 1) {\n\t\t\tif (U.substr(i, 2) == \"->\") {\n\t\t\t\tV += '&';\n\t\t\t\ti++;\n\t\t\t\tgoto E;\n\t\t\t}\n\t\t}\n\t\tV += U[i];\n\tE:;\n\t}\n\n\tint cnt1 = 0;\n\tfor (int i = 0; i < V.size(); i++) {\n\t\tif (V[i] == '=') {\n\t\t\tcnt1 = 1;\n\t\t}\n\t\telse if (cnt1 == 0) {\n\t\t\tV1 += V[i];\n\t\t}\n\t\telse if (cnt1 == 1) {\n\t\t\tV2 += V[i];\n\t\t}\n\t}\n\n\tint pass1 = 0;\n\twhile (pass1 < V1.size()) {\n\t\tif (V1[pass1] == '-') {\n\t\t\tint cnt2 = 0;\n\t\t\twhile (V1[pass1] == '-') {\n\t\t\t\tcnt2++;\n\t\t\t\tpass1++;\n\t\t\t}\n\t\t\tif (cnt2 % 2 == 1) {\n\t\t\t\tW1 += '(';\n\t\t\t\tW1 += '-';\n\t\t\t\tW1 += V1[pass1];\n\t\t\t\tW1 += ')';\n\t\t\t}\n\t\t\telse {\n\t\t\t\tW1 += V1[pass1];\n\t\t\t}\n\t\t\tpass1++;\n\t\t}\n\t\tif (pass1 < V1.size()) {\n\t\t\tW1 += V1[pass1];\n\t\t\tpass1++;\n\t\t}\n\t}\n\n\tpass1 = 0;\n\twhile (pass1 < V2.size()) {\n\t\tif (V2[pass1] == '-') {\n\t\t\tint cnt2 = 0;\n\t\t\twhile (V2[pass1] == '-') {\n\t\t\t\tcnt2++;\n\t\t\t\tpass1++;\n\t\t\t}\n\t\t\tif (cnt2 % 2 == 1) {\n\t\t\t\tW2 += '(';\n\t\t\t\tW2 += '-';\n\t\t\t\tW2 += V2[pass1];\n\t\t\t\tW2 += ')';\n\t\t\t}\n\t\t\telse {\n\t\t\t\tW2 += V2[pass1];\n\t\t\t}\n\t\t\tpass1++;\n\t\t}\n\t\tif (pass1 < V2.size()) {\n\t\t\tW2 += V2[pass1];\n\t\t\tpass1++;\n\t\t}\n\t}\n\n\tstring X1 = \"\", X2 = \"\";\n\n\tfor (int i = 0; i < power(2, MAX_NUM); i++) {\n\t\tX1 = \"\"; X2 = \"\";\n\t\tfor (int j = 0; j < MAX_NUM; j++) {\n\t\t\tint a1 = (i / power(2, j)) % 2;\n\t\t\tTR[j] = a1;\n\t\t}\n\n\t\tfor (int j = 0; j < V1.size(); j++) {\n\t\t\tfor (int k = 0; k < MAX_NUM; k++) {\n\t\t\t\tif (W1[j] == CH[k]) {\n\t\t\t\t\tX1 += NUM[TR[j]];\n\t\t\t\t\tgoto F;\n\t\t\t\t}\n\t\t\t}\n\t\t\tX1 += W1[j];\n\t\tF:;\n\t\t}\n\n\t\tfor (int j = 0; j < V2.size(); j++) {\n\t\t\tfor (int k = 0; k < MAX_NUM; k++) {\n\t\t\t\tif (W2[j] == CH[k]) {\n\t\t\t\t\tX2 += NUM[TR[j]];\n\t\t\t\t\tgoto G;\n\t\t\t\t}\n\t\t\t}\n\t\t\tX2 += W1[j];\n\t\tG:;\n\t\t}\n\n\t\tint res_1 = calc(X1);\n\t\tint res_2 = calc(X2);\n\t\tif (res_1 != res_2) {\n\t\t\tRES = false;\n\t\t}\n\t}\n\treturn RES;\n}\n\nint main() {\n\twhile (true) {\n\t\tcin >> S;\n\t\tif (S == \"#\") {\n\t\t\tbreak;\n\t\t}\n\t\tbool res = solve(S);\n\t\tif (res == true) {\n\t\t\tcout << \"YES\" << endl;\n\t\t}\n\t\telse {\n\t\t\tcout << \"NO\" << endl;\n\t\t}\n\t}\n\treturn 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include <stdio.h>\n#include <cctype>\n#include <limits.h>\n#include <math.h>\n#include <bitset>\n#include <vector>\n#include <map>\n#include <set>\n#include <stack>\n#include <queue>\n#include <cstring>\n#include <string>\n#include <sstream>\n#include <algorithm>\n#include <iomanip>\n#include <iostream>\n\n#define VARIABLE(x) cerr << #x << \"=\" << x << endl\n#define BINARY(x) static_cast<bitset<16> >(x);\n#define rep(i,n) for(int i=0;i<(int)(n);i++)\n#define REP(i,m,n) for (int i=m;i<(int)(n);i++)\n#define if_range(x, y, w, h) if (0<=(int)(x) && (int)(x)<(int)(w) && 0<=(int)(y) && (int)(y)<(int)(h))\n\nconst int INF = 1000000000;\ntypedef double D;\nconst double EPS = 1e-8;\nconst double PI = 3.14159;\nint dx[4]={-1, 0, 1, 0}, dy[4]={0, -1, 0, 1};\nusing namespace std;\n//typedef pair<int, int> P;\n\n\n/** Problem2401 : Equation **/\n\nstring s;\nint pos, N;\n\nbool formula()\n{\n\tchar c = s[pos++];\n\tif (c == 'T') return true;\n\telse if (c == 'F') return false;\n\telse if (islower(c)) {\n\t\treturn N>>(c-'a')&1;\n\t} else if (c=='-') return !formula();\n\telse if (c=='(') {\n\t\tbool a = formula();\n\t\tchar ope = s[pos++];\n\t\tif (s[pos]=='>')pos++;\n\t\tbool b = formula();\n\t\tpos++;\n\t\t\n\t\tif (ope == '*') return a&b;\n\t\telse if (ope == '+') return a|b;\n\t\telse return (a&b)|(!a&b)|(!a&!b);\n\t}\n\treturn false;\n}\n\n\nint main()\n{\n\twhile (cin>>s, s!=\"#\") {\n\t\tbool ans = true;\n\t\tfor (N=0; N<2048; N++) {\n\t\t\tpos=0;\n\t\t\tbool a, b;\n\t\t\ta = formula();\n\t\t\tpos++;\n\t\t\tb = formula();\n\t\t\tans &= a==b;\n\t\t}\n\n\t\tcout << (ans?\"YES\":\"NO\") << endl;\n\t}\n}"
  },
  {
    "language": "C++",
    "code": "#include<bits/stdc++.h>\nusing namespace std;\n#define rep(i,n) for(int i=0;i<n;i++)\n#define rep2(i,a,b) for(int i=a;i<=b;i++)\n#define pb push_back\n#define eb emplace_back\n\nint in(){int x;cin>>x;return x;}\n\nint pos;\nint a[200];\nchar s[1100];\nint number(){\n    return a[s[pos++]];\n}\nint expr();\nint factor(){\n    bool f=false;\n    if(s[pos]=='-'){\n        f=true;\n        pos++;\n        return 1-factor();\n    }\n    if(s[pos]=='('){\n        pos++;\n        int res = expr();\n        pos++;\n        return res;\n    }\n    else return number();\n}\nint expr(){\n    int ret = factor();\n    for(;;){\n        if(s[pos]=='+'){\n            pos++;ret|=factor();\n        }\n        else if(s[pos]=='*'){\n            pos++;ret&=factor();\n        }\n        else if(s[pos]=='~'){\n            pos++;int r=factor();\n            if(ret == 1 and r==0)ret = 0;\n            else ret = 1;\n        }\n        else break;\n    }\n    return ret;\n}\nmain(){\n    a['T']=1;\n    a['F']=0;\n    bool F = false;\n    while(1){\n        string t;cin>>t;\n        if(t==\"#\")exit(0);\n        pos = 0;\n        rep(i,t.size()){\n            if(i<t.size()-1 and t.substr(i,2)==\"->\"){\n                s[pos++]='~';i++;\n            }\n            else s[pos++]=t[i];\n        }\n        bool flag = true;\n        rep(i,1<<11){\n            rep(j,11)a['a'+j]=(i&(1<<j)?1:0);\n            pos = 0;\n            int l = expr();\n            pos++;\n            int r = expr();\n            flag &= l==r;\n        }\n        cout << (flag ? \"YES\\n\":\"NO\\n\");\n        F = true;\n        for(int i=t.size()-1;i>=0;i--)s[i]=' ';\n    }\n}\n"
  },
  {
    "language": "C++",
    "code": "#include <string>\n#include <iostream>\nusing namespace std;\nstring s[5];\nbool solve(int l, int r, int e) {\n\tif (s[e][l] == 'T') return true;\n\tif (s[e][l] == 'F') return false;\n\tif (s[e][l] == '-') return !solve(l + 1, r, e);\n\tint d = 0;\n\tfor (int i = l + 1; i < r - 1; i++) {\n\t\tif (s[e][i] == '(') d++;\n\t\tif (s[e][i] == ')') d--;\n\t\tif (s[e][i] == '*') return solve(l + 1, i, e) && solve(i + 1, r - 1, e);\n\t\tif (s[e][i] == '+') return solve(l + 1, i, e) || solve(i + 1, r - 1, e);\n\t\tif (s[e][i] == '-') return !solve(l + 1, i, e) || solve(i + 2, r - 1, e);\n\t}\n\treturn true;\n}\nint main() {\n\twhile (cin >> s[0], s[0] != \"#\") {\n\t\tfor (int i = 0; i < s[0].size(); i++) {\n\t\t\tif (s[0][i] == '=') {\n\t\t\t\ts[1] = s[0].substr(0, i - 1);\n\t\t\t\ts[2] = s[0].substr(i + 1, s[0].size() - i - 1);\n\t\t\t}\n\t\t}\n\t\tbool flag = true;\n\t\tfor (int i = 0; i < 2048; i++) {\n\t\t\ts[3] = s[1], s[4] = s[2];\n\t\t\tfor (int j = 0; j < 11; j++) {\n\t\t\t\tfor (int k = 0; k < s[3].size(); k++) {\n\t\t\t\t\tif (s[1][k] == j + 65) s[3][k] = (i & (1 << j)) ? 'T' : 'F';\n\t\t\t\t}\n\t\t\t\tfor (int k = 0; k < s[4].size(); k++) {\n\t\t\t\t\tif (s[2][k] == j + 65) s[4][k] = (i & (1 << j)) ? 'T' : 'F';\n\t\t\t\t}\n\t\t\t}\n\t\t\tif (solve(0, s[3].size(), 3) != solve(0, s[4].size(), 4)) {\n\t\t\t\tflag = false; break;\n\t\t\t}\n\t\t}\n\t\tprintf(\"%s\\n\", flag ? \"YES\" : \"NO\");\n\t}\n\treturn 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include <cstdio>\n#include <iostream>\n#include <cmath>\n#include <ctype.h>\n#include <string> \n#include <sstream>\n#include <iostream>\n#include <algorithm>\n#include <cstdlib>\n#include <map>\n#include <queue>\n#include <utility>\n#include <vector>\n#include <set>\n#include <list>\n#include <cstring>\n#include <stack>\n   \nusing namespace std;\n\nint main()\n{\n    string s;\n    while(1){\n        cin >> s;\n        if(s == \"#\") break;\n        char en[11] = {'a', 'b', 'c', 'd', 'e', 'f', 'g', 'h', 'i', 'j', 'k'};\n        bool ok = true;\n        for(int i = 0; i < (2 << 10); i++){\n            map<char, char> chara;\n            int nowi = i;\n            chara['1'] = '1';\n            chara['0'] = '0';\n            chara['T'] = '1';\n            chara['F'] = '0';\n            for(int j = 10; j >= 0; j--){\n                chara[en[j]] = (nowi / (int)pow(2, j)) + '0';\n                nowi = nowi % (int)pow(2, j);\n                // cout << chara[j];\n            }\n            stack<char> st;\n            for(int j = 0; j < s.length(); j++){\n                if(s[j] == ')'){\n                    char y = st.top();\n                    y = chara[y];\n                    st.pop();\n                    if(st.top() == '-'){\n                        st.pop();\n                        if(y == '0') y = '1';\n                        else y = '0';\n                    }\n                    char op = st.top();\n                    if(op == '>') st.pop();\n                    st.pop();\n                    char x = st.top();\n                    x = chara[x];\n                    st.pop();\n                    if(st.top() == '-'){\n                        st.pop();\n                        if(x == '0') x = '1';\n                        else x = '0';\n                    }\n                    st.pop();\n                    // cout << x << \" \" << op << \" \" << y << endl;\n                    if(op == '*'){\n                        if(x == '1' && y == '1') st.push('1');\n                        else st.push('0');\n                    } else if(op == '+'){\n                        if(x == '0' && y == '0') st.push('0');\n                        else st.push('1');\n                    } else if(op == '>'){\n                        if(x == '1' && y == '0') st.push('0');\n                        else st.push('1');\n                    }\n                } else {\n                    st.push(s[j]);\n                }\n            }\n            char e2 = st.top();\n            e2 = chara[e2];\n            st.pop();\n            if(st.top() == '-'){\n                st.pop();\n                if(e2 == '1') e2 = '0';\n                else e2 = '1';\n            }\n            st.pop();\n            char e1 = st.top();\n            e1 = chara[e1];\n            st.pop();\n            if(!st.empty()){\n                st.pop();\n                if(e1 == '1') e1 = '0';\n                else e1 = '1';\n            }\n            // cout << st.size() << endl;\n            if(e1 != e2){\n                ok = false;\n                break;\n            }\n        }\n        if(ok) cout << \"YES\" << endl;\n        else cout << \"NO\" << endl;\n    }\n    return 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include <iostream>\n#include <vector>\n#include <string>\n#include <algorithm>\nusing namespace std;\n\nint c;\nbool a[11];\n\nbool f(const string& s) {\n\tif (s[c] == '(') {\n\t\tc++;\n\t\tbool v1 = f(s);\n\t\tchar op = s[c++];\n\t\tif (op == '-') c++;\n\t\tbool v2 = f(s);\n\t\tc++;\n\t\tif (op == '+') return v1 | v2;\n\t\tif (op == '*') return v1 & v2;\n\t\tif (op == '-') return !(v1 & !v2);\n\t}\n\n\tif (s[c] == 'T') {\n\t\tc++;\n\t\treturn true;\n\t}\n\tif (s[c] == 'F') {\n\t\tc++;\n\t\treturn false;\n\t}\n\tif (s[c] == '-') {\n\t\tc++;\n\t\treturn !f(s);\n\t}\n\tif ('a' <= s[c] && s[c] <= 'k') {\n\t\tbool v = a[s[c] - 'a'];\n\t\tc++;\n\t\treturn v;\n\t}\n\tcout << \"error\" << s << \"at \" << c << endl;\n\texit(1);\n}\n\nbool solve(string s1, string s2) {\n\tfor (int i = 0; i < (1 << 11); i++) {\n\t\tfor (int j = 0; j < 11; j++) {\n\t\t\ta[i] = (i & (1 << j)) > 0;\n\t\t}\n\t\t//cout << i << \" \" << s1 + \" \" << s2 << endl;\n\t\tc = 0;\n\t\tbool res1 = f(s1);\n\t\tc = 0;\n\t\tbool res2 = f(s2);\n\n\t\tif (res1 == res2) return true;\n\t}\n\n\treturn false;\n}\n\nint main() {\n\tcin.tie(0);\n\tios::sync_with_stdio(false);\n\tstring s, s1, s2;\n\twhile (cin >> s , s != \"#\") {\n\t\tint idx = s.find('=');\n\t\ts1 = s.substr(0, idx) , s2 = s.substr(idx + 1, s.size() - (idx + 1));\n\t\tcout << (solve(s1, s2) ? \"YES\" : \"NO\") << endl;\n\t}\n}"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\n\nusing namespace std;\n\ntypedef string::const_iterator State;\nclass ParseError {};\n\nmap<char, int> mp, mp2;\nState b;\n\nint f(int a, int b) {\n\tif(a == 0) return 1;\n\tif(b == 1) return 1;\n\treturn 0;\n}\n\nint ch(State& begin) {\n\tif(!islower(*begin) && !isupper(*begin)) {cout << *begin; assert(false);}\n\tint ret;\n\tif(*begin == 'T') ret = 1;\n\telse if(*begin == 'F') ret = 0;\n\telse ret = mp2[*begin];\n\tbegin++;\n\treturn ret;\n}\n\nint fomula(State& begin) {\n\t//cout << *begin << endl;\n\tif(islower(*begin) || isupper(*begin)) {return ch(begin);}\n\telse if(*begin == '-') {begin++; return !fomula(begin);}\n\telse if(*begin == '(') {\n\t\tbegin++;\n\t\tint ret1 = fomula(begin);\n\t\tchar op = *begin;\n\t\tbegin++;\n\t\tint ret2 = fomula(begin);\n\t\tbegin++;\n\t\tint ret;\n\t\tif(op == '*') {\n\t\t\tret = (ret1 == 1 && ret2 == 1) ? 1 : 0;\n\t\t} else if(op == '+') {\n\t\t\tret = max(ret1, ret2);\n\t\t} else if(op == '>') {\n\t\t\tret = (ret1 == 1 && ret2 == 0) ? 0 : 1;\n\t\t} \n\t\treturn ret;\n\t}\n}\n\nint equation(State& begin) {\n\tint ret = fomula(begin), ret2;\n\tif(*begin == '=') begin++, ret2 = fomula(begin);\n\t//cout << \"ret:\" << ret << \" ret2:\" << ret2 << endl;\n\tif(ret == ret2) return 1;\n\treturn 0;\n}\n\nint a[20];\nint main() {\n\twhile(true) {\n\t\tstring t;\n\t\tcin >> t;\n\t\tif(t == \"#\") break;\n\t\tstring s;\n\t\tfor(int i=0; i<t.size(); ++i) {\n\t\t\tif(t[i] != '>') s += t[i];\n\t\t\telse s[s.size()-1] = '>';\n\t\t}\n\t\t//cout << s << endl;\n\t\tint idx = 0;\n\t\tmp.clear();\n\t\tmp2.clear();\n\t\tfor(int i=0; i<s.size(); ++i) {\n\t\t\tif(islower(s[i]) && mp.find(s[i]) == mp.end()) {\n\t\t\t\tmp[s[i]] = idx;\n\t\t\t\ta[idx++] = s[i];\n\t\t\t}\n\t\t}\n\t\t/*for(auto i: mp) {\n\t\t\tcout << i.first << \" \" << i.second << endl;\n\t\t}*/\n\t\n\t\tbool flag = true;\n\t\tfor(int i=0; i<(1<<idx); ++i) {\n\t\t\t//cout << \"i:\" << i << endl;\n\t\t\tfor(int j=0; j<idx; ++j) {\n\t\t\t\tif(i >> j & 1) mp2[a[j]] = 1;\n\t\t\t\telse mp2[a[j]] = 0;\n\t\t\t}\n\t\t\t//for(auto j: mp2) cout << j.first << \" \" << j.second << endl;\n\t\t\tState begin = s.begin();\n\t\t\tb = s.begin();\n\t\t\tif(!equation(begin)) flag = false;\n\t\t\t//cout << flag << endl;\n\t\t}\n\t\tif(flag) cout << \"YES\" << endl;\n\t\telse cout << \"NO\" << endl;\n\t}\n\t\n\treturn 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include <algorithm>\n#include <cmath>\n#include <climits>\n#include <cstdio>\n#include <cstdlib>\n#include <cstring>\n#include <fstream>\n#include <iostream>\n#include <list>\n#include <map>\n#include <queue>\n#include <set>\n#include <sstream>\n#include <stack>\n#include <string>\n#include <vector>\n\nusing namespace std;\n\n#define LOG(...) printf(__VA_ARGS__)\n//#define LOG(...)\n#define FOR(i,a,b) for(int i=(a);i<(b);++i)\n#define REP(i,n) for(int i=0;i<(int)(n);++i)\n#define ALL(a) (a).begin(),(a).end()\n#define RALL(a) (a).rbegin(),(a).rend()\n#define EXIST(s,e) ((s).find(e)!=(s).end())\n#define SORT(c) sort((c).begin(),(c).end())\n#define RSORT(c) sort((c).rbegin(),(c).rend())\n#define CLR(a) memset((a), 0 ,sizeof(a))\n\ntypedef long long ll;\ntypedef unsigned long long ull;\ntypedef vector<bool> vb;\ntypedef vector<int> vi;\ntypedef vector<ll> vll;\ntypedef vector<vb> vvb;\ntypedef vector<vi> vvi;\ntypedef vector<vll> vvll;\ntypedef pair<int, int> pii;\ntypedef pair<ll, ll> pll;\n\nconst int V[11] = {\n    1 << 0,\n    1 << 1,\n    1 << 2,\n    1 << 3,\n    1 << 4,\n    1 << 5,\n    1 << 6,\n    1 << 7,\n    1 << 8,\n    1 << 9,\n    1 << 10,\n};\n\nbool parse(string expr, int var) {\n    stack<char> ops;\n    stack<bool> vals;\n    bool update = false;\n    REP(i, expr.length()) {\n        char c = expr[i];\n        switch (c) {\n        case '(':\n            update = false;\n            break;\n        case '-':\n            if (!ops.empty() && update && ops.top() == '-') {\n                ops.pop();\n            } else {\n                ops.push(c);\n            }\n            update = true;\n            break;\n        case '*':\n        case '+':\n            ops.push(c);\n            update = true;\n            break;\n        case '>':\n            ops.pop();\n            ops.push(c);\n            update = true;\n            break;\n        case 'a':\n        case 'b':\n        case 'c':\n        case 'd':\n        case 'e':\n        case 'f':\n        case 'g':\n        case 'h':\n        case 'i':\n        case 'j':\n        case 'k':\n        case 'T':\n        case 'F':\n        case ')':\n            bool b;\n            switch (c) {\n            case ')':\n                update = true;\n                b = vals.top(); vals.pop();\n                break;\n            case 'T':\n                b = true;\n                break;\n            case 'F':\n                b = false;\n                break;\n            default:\n                b = var & V[c - 'a'];\n            }\n            if (update && !ops.empty()) {\n                bool a;\n                char op = ops.top(); ops.pop();\n                switch (op) {\n                case '-':\n                    vals.push(!b);\n                    break;\n                case '*':\n                    a = vals.top(); vals.pop();\n                    vals.push(a && b);\n                    break;\n                case '+':\n                    a = vals.top(); vals.pop();\n                    vals.push(a || b);\n                    break;\n                case '>':\n                    a = vals.top(); vals.pop();\n                    vals.push(!a || b);\n                    break;\n                }\n            } else {\n                vals.push(b);\n            }\n            update = false;\n            break;\n        }\n    }\n    return vals.top();\n}\n\nint main() {\n    string line;\n    while (getline(cin, line), line != \"#\") {\n        int eq = line.find('=');\n        string l(line.begin(), line.begin() + eq);\n        string r(line.begin() + eq + 1, line.end());\n        bool ok = true;\n        REP(var, 2 << 12) {\n            if (parse(l, var) != parse(r, var)) {\n                ok = false;\n                break;\n            }\n        }\n        cout << (ok ? \"YES\" : \"NO\") << endl;\n    }\n}"
  },
  {
    "language": "C++",
    "code": "#include <iostream>\n#include <vector>\n#include <string>\n#define rep(i, n) for(int i = 0; i < n; i++)\nbool Calc(std::string expr);\nvoid DeleteReverse(std::string& expr);\n\nint main()\n{\n\tstd::vector<std::string> results;\n\twhile (1) {\n\t\tstd::string expr;\n\t\tstd::cin >> expr;\n\t\tif (expr == \"#\") break;\n\t\t//?????????????????£?¶??????????????????????\n\t\twhile (1) {\n\t\t\tbool isDelete = false;\n\t\t\trep(i, expr.size() - 1) {\n\t\t\t\tif (expr[i] == '-' && expr[i + 1] == '-') {\n\t\t\t\t\texpr.erase(i, 2);\n\t\t\t\t\tisDelete = true;\n\t\t\t\t\tbreak;\n\t\t\t\t}\n\t\t\t}\n\t\t\tif (!isDelete) break;\n\t\t}\n\t\t//->??? >?????????\n\n\t\trep(i, expr.size() - 1) {\n\t\t\tif (expr[i] == '-' && expr[i + 1] == '>') {\n\t\t\t\texpr.erase(i, 1);\n\t\t\t}\n\t\t}\n\t\tint tfFlugs = -1;\n\t\tbool isCorrect = true;\n\t\twhile (1) {\n\t\t\ttfFlugs++;\n\t\t\tstd::string replaced = expr;\n\t\t\tbool includeFalse = false;\n\t\t\t//????????????\n\t\t\trep(i, 11) {//0a 1b 2c...\n\t\t\t\tif (tfFlugs & 1 << i) {\n\t\t\t\t\tfor (auto& x : replaced) {\n\t\t\t\t\t\tif (x == 'a' + i) {\n\t\t\t\t\t\t\tx = 'T';\n\t\t\t\t\t\t}\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t\telse {\n\t\t\t\t\tincludeFalse = true;\n\t\t\t\t\tfor (auto& x : replaced) {\n\t\t\t\t\t\tif (x == 'a' + i) {\n\t\t\t\t\t\t\tx = 'F';\n\t\t\t\t\t\t}\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t}\n\t\t\t//?????????????????????\n\t\t\tDeleteReverse(replaced);\n\t\t\tisCorrect = Calc(replaced);\n\t\t\tif (!isCorrect) break;\n\t\t\tif (!includeFalse) break;\n\t\t}\n\t\tresults.push_back(isCorrect ? \"YES\" : \"NO\");\n\t}\n\n\tfor (auto& x : results) {\n\t\tstd::cout << x << std::endl;\n\t}\n\n\treturn 0;\n}\n\nbool Calc(std::string expr)\n{\n\t//????????¨???????????????\n\tstd::string e[2];\n\te[0] = expr.substr(0, expr.find_first_of('='));\n\te[1] = expr.substr(expr.find_first_of('=') + 1);\n\twhile (1) {\n\t\trep(i, 2) {\n\t\t\tif (e[i].size() >= 5) { //?¨????????????¨???????????£?????????\n\t\t\t\trep(j, e[i].size() - 4) {\n\t\t\t\t\t// ( TF +*> TF ) ?????????????§????\n\t\t\t\t\tif (e[i][j] == '(' && (e[i][j + 1] == 'T' || e[i][j + 1] == 'F') &&\n\t\t\t\t\t\t(e[i][j + 2] == '+' || e[i][j + 2] == '*' || e[i][j + 2] == '>') &&\n\t\t\t\t\t\t(e[i][j + 3] == 'T' || e[i][j + 3] == 'F') && e[i][j + 4] == ')') {\n\t\t\t\t\t\tchar result;\n\t\t\t\t\t\tswitch (e[i][j + 2])\n\t\t\t\t\t\t{\n\t\t\t\t\t\tcase '+':\n\t\t\t\t\t\t\tif (e[i][j + 1] == 'F' && e[i][j + 3] == 'F') {\n\t\t\t\t\t\t\t\tresult = 'F';\n\t\t\t\t\t\t\t}\n\t\t\t\t\t\t\telse result = 'T';\n\t\t\t\t\t\t\tbreak;\n\t\t\t\t\t\tcase '*':\n\t\t\t\t\t\t\tif (e[i][j + 1] == 'T' && e[i][j + 3] == 'T') {\n\t\t\t\t\t\t\t\tresult = 'T';\n\t\t\t\t\t\t\t}\n\t\t\t\t\t\t\telse result = 'F';\n\t\t\t\t\t\t\tbreak;\n\t\t\t\t\t\tcase '>':\n\t\t\t\t\t\t\tif (e[i][j + 1] == 'T' && e[i][j + 3] == 'F') {\n\t\t\t\t\t\t\t\tresult = 'F';\n\t\t\t\t\t\t\t}\n\t\t\t\t\t\t\telse result = 'T';\n\t\t\t\t\t\t\tbreak;\n\t\t\t\t\t\t}\n\t\t\t\t\t\t//????????????\n\t\t\t\t\t\te[i].erase(j, 4); // ) ????????????\n\t\t\t\t\t\te[i][j] = result; // ) ???TF??????????????????\n\t\t\t\t\t\tDeleteReverse(e[i]);\n\t\t\t\t\t\tbreak;\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t}\n\t\t\t//?¨??????????\n\t\t\tif (e[0].size() == 1 && e[1].size() == 1) {\n\t\t\t\tif (e[0].front() == e[1].front()) {\n\t\t\t\t\treturn true;\n\t\t\t\t}\n\t\t\t\telse return false;\n\t\t\t}\n\t\t}\n\t}\n\treturn false;\n}\n\nvoid DeleteReverse(std::string & expr)\n{\n\trep(i, expr.size() - 1) {\n\t\tif (expr[i] == '-' && expr[i + 1] == 'F') {\n\t\t\texpr.erase(i, 1);\n\t\t\texpr[i] = 'T';\n\t\t}\n\t\telse if (expr[i] == '-' && expr[i + 1] == 'T') {\n\t\t\texpr.erase(i, 1);\n\t\t\texpr[i] = 'F';\n\t\t}\n\t}\n}"
  },
  {
    "language": "C++",
    "code": "#include<bits/stdc++.h>\nusing namespace std;\n \n#define REP(i,s,n) for(int i=s;i<n;++i)\n#define rep(i,n) REP(i,0,n)\n#define SORT(c) sort((c).begin(),(c).end())\n#define IINF INT_MAX\n#define LLINF LLONG_MAX\n#define DEBUG false\n \ntypedef long long ll;\ntypedef pair<int, int> ii;\n\n\nstring target;\nint pos;\n \nstruct Node{\n    string num;\n    Node *left;\n    Node *right;\n    Node(){\n        num = \"\";\n        left = NULL;\n        right = NULL;\n    }\n    Node(string n, Node *l, Node *r){\n        num = n;\n        left = l;\n        right = r;\n    }\n};\n\nNode *rule_formula();\n\nNode *rule_equation(){\n\tNode *ret = new Node;\n\tret->num = \"=\";\n\tret->left = rule_formula();\n\tassert(target[pos] == '=');\n\tpos++;\n\tret->right = rule_formula();\n    return ret;\n}\n\nNode *rule_formula(){\n\tNode* ret = new Node;\n\tif(DEBUG) cout << pos << endl;\n\tswitch (target[pos]){\n\t\tcase '-':\n\t\t\tif(DEBUG) cout << \"- \" << pos << endl;\n\t\t\tret->num = \"-\";\n\t\t\tpos++;\n\t\t\tret->left = rule_formula();\n\t\t\tbreak;\n\t\tcase '(':\n\t\t\tif(DEBUG) cout << \"( \" << pos << endl;\n\t\t\tpos++;\n\t\t\tret->left = rule_formula();\n\t\t\tif(target[pos] == '-'){\n\t\t\t\tret->num = \">\";\n\t\t\t\tpos += 2;\n\t\t\t}\n\t\t\telse{\n\t\t\t\tret-> num = target[pos];\n\t\t\t\tpos++;\n\t\t\t}\n\t\t\tret->right = rule_formula();\n\t\t\tpos++;//')'\n\t\t\tbreak;\n\t\tdefault:\n\t\t\tif(DEBUG) cout << \"num \" << pos << endl;\n\t\t\tret->num = target[pos];\n\t\t\tpos++;\n\t\t\tbreak;\n\t}\n\t\n\treturn ret;\n}\n\nNode *makeTree(string str){\n \n    target = str;\n    pos = 0;\n    Node *ret;\n \n    ret = rule_equation();\n \n    return ret;\n}\n\nvector<bool> b(11);\n\nbool eval(Node *a){\n\tswitch(a->num[0]){\n\t\tcase '=' :\n\t\t\treturn (eval(a->left) == eval(a->right));\n\t\t\tbreak;\n\t\tcase '>':\n\t\t\tbool x, y;\n\t\t\tx = eval(a->left);\n\t\t\ty = eval(a->right);\n\t\t\tif(x == true && y == false) return false;\n\t\t\telse return true;\n\t\t\tbreak;\n\t\tcase '-':\n\t\t\treturn (!eval(a->left));\n\t\t\tbreak;\n\t\t\t\n\t\tcase '+':\n\t\t\treturn (eval(a->left) | eval(a->right));\n\t\t\tbreak;\n\t\t\t\n\t\tcase '*':\n\t\t\treturn (eval(a->left) & eval(a->right));\n\t\t\tbreak;\n\t\t\n\t\tcase 'T':\n\t\t\treturn true;\n\t\t\tbreak;\n\t\tcase 'F':\n\t\t\treturn false;\n\t\t\tbreak;\n\t\t\n\t\tdefault:\n\t\t\treturn (b[(int)(a->num[0] - 'a')]);\n\t\t\tbreak;\n\t}\n}\n\nint main() {\n\t\n\tstring s;\n\twhile(getline(cin, s)){\n\t\tif(s == \"#\") break;\n\t\tpos = 0;\n\t\tNode *a;\n\t\ta = makeTree(s);\n\t\tbool f = true;\n\t\trep(i, 1 << 11){\n\t\t\tint tmp = i;\n\t\t\trep(j, 11){\n\t\t\t\tb[j] = (tmp % 2 == 1);\n\t\t\t\ttmp = tmp >> 1;\n\t\t\t}\n\t\t\tf = f & eval(a);\n\t\t}\n\t\t\n\t\tcout << (f? \"YES\" : \"NO\") << endl;\n\t}\n\t\n\treturn 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include <functional>\n#include <iostream>\n#include <string>\n#include <unordered_set>\n#include <vector>\n#define loop(i, a, n) for (int i = (a); i < (n); i++)\n#define rep(i, n) loop(i, 0, n)\ntemplate<typename A> using F = std::function<A>;\nusing namespace std;\n\ntemplate<typename T> struct ParseResult {\n\tbool succeeded;\n\tT object;\n\tint pos;\n\tParseResult(const ParseResult& other) = default;\n\tParseResult(ParseResult&& other) : succeeded(other.succeeded), object(std::move(other.object)), pos(other.pos) {}\n\tParseResult& operator=(const ParseResult& other) = default;\n\tParseResult& operator=(ParseResult&& other) { succeeded = (other.succeeded); object = (std::move(other.object)); pos = (other.pos); return *this; }\n\tParseResult(const bool succeeded, T object, const int pos) : succeeded(succeeded), object(std::move(object)), pos(pos) {}\n\tfriend std::ostream &operator<<(std::ostream &os, const ParseResult<T> &p) { return os << '{' << (p.succeeded ? \"true\" : \"false\") << ',' << p.object << ',' << p.pos << '}'; }\n};\n\ntemplate<typename T> using Parser = std::function<ParseResult<T>(const std::string&, int)>;\n\nParser<std::string> token(std::string &&s) {\n\tconst auto n = s.size();\n\treturn[n = std::move(n), s = std::move(s)](const std::string &target, const int pos) {\n\t\tif (target.size() < n) return ParseResult<std::string>(false, {}, pos);\n\t\treturn target.substr(pos, n) == s ? ParseResult<std::string>(true, s, pos + n) : ParseResult<std::string>(false, {}, pos);\n\t};\n}\n\ntemplate<typename T> Parser<T> operator||(Parser<T> p1, Parser<T> p2) {\n\treturn[p1 = std::move(p1), p2 = std::move(p2)](const std::string &target, const int pos) {\n\t\tauto r = p1(target, pos);\n\t\tif (r.succeeded) return r;\n\t\tr = p2(target, pos);\n\t\tif (r.succeeded) return r;\n\t\treturn ParseResult<T>(false, {}, pos);\n\t};\n}\n\ntemplate<typename T1, typename T2> Parser<std::pair<T1, T2>> operator+(Parser<T1> p1, Parser<T2> p2) {\n\treturn[p1 = std::move(p1), p2 = std::move(p2)](const std::string &target, const int pos) {\n\t\tauto r1 = p1(target, pos);\n\t\tif (!r1.succeeded) return ParseResult<std::pair<T1, T2>>(false, {}, pos);\n\t\tauto r2 = p2(target, r1.pos);\n\t\tif (!r2.succeeded) return ParseResult<std::pair<T1, T2>>(false, {}, pos);\n\t\treturn ParseResult<std::pair<T1, T2>>(true, { r1.object, r2.object }, r2.pos);\n\t};\n}\n\ntemplate<typename T1, typename T2> Parser<T2> operator>>(Parser<T1> p1, Parser<T2> p2) {\n\treturn[p1 = std::move(p1), p2 = std::move(p2)](const std::string &target, const int pos) {\n\t\tauto r1 = p1(target, pos);\n\t\tif (!r1.succeeded) return ParseResult<T2>(false, {}, pos);\n\t\tauto r2 = p2(target, r1.pos);\n\t\tif (!r2.succeeded) return ParseResult<T2>(false, {}, pos);\n\t\treturn ParseResult<T2>(true, r2.object, r2.pos);\n\t};\n}\n\ntemplate<typename T1, typename T2> Parser<T1> operator<<(Parser<T1> p1, Parser<T2> p2) {\n\treturn[p1 = std::move(p1), p2 = std::move(p2)](const std::string &target, const int pos) {\n\t\tauto r1 = p1(target, pos);\n\t\tif (!r1.succeeded) return ParseResult<T1>(false, {}, pos);\n\t\tauto r2 = p2(target, r1.pos);\n\t\tif (!r2.succeeded) return ParseResult<T1>(false, {}, pos);\n\t\treturn ParseResult<T1>(true, r1.object, r2.pos);\n\t};\n}\n\nParser<char> oneOf(const std::string &s) {\n\tstd::unordered_set<char> d;\n\tfor (auto &c : s) d.insert(c);\n\treturn[d = std::move(d)](const std::string &target, const int pos) {\n\t\tif (target.size() <= pos) return ParseResult<char>(false, {}, pos);\n\t\tchar c = target[pos];\n\t\treturn d.count(c) ? ParseResult<char>(true, c, pos + 1) : ParseResult<char>(false, {}, pos);\n\t};\n}\n\ntemplate<typename T, typename S, typename F> Parser<S> fmap(Parser<T> p, F &&f) {\n\treturn[p = std::move(p), f = std::forward<F>(f)](const std::string &target, const int pos) {\n\t\tauto r = p(target, pos);\n\t\treturn r.succeeded ? ParseResult<S>(true, f(r.object), r.pos) : ParseResult<S>(false, {}, r.pos);\n\t};\n}\n\ntemplate<typename T, typename F> Parser<T> lazy(F &&f) {\n\tstatic bool instantiated = false;\n\tstatic Parser<T> p;\n\treturn[f = std::forward<F>(f)](const std::string &target, const int pos) {\n\t\tif (!instantiated) {\n\t\t\tp = f();\n\t\t\tinstantiated = true;\n\t\t}\n\t\treturn p(target, pos);\n\t};\n}\n\nstruct SyntaxTree {\n\tstring op;\n\tchar value;\n\tvector<SyntaxTree> children;\n\tSyntaxTree() {}\n\tSyntaxTree(const SyntaxTree& other) = default;\n\tSyntaxTree(SyntaxTree&& other) :op(std::move(other.op)), value(other.value), children(std::move(other.children)){}\n\tSyntaxTree& operator=(const SyntaxTree& other) = default;\n\tSyntaxTree& operator=(SyntaxTree&& other) { op = (std::move(other.op)), value = (other.value), children = (std::move(other.children)); return *this; }\n\tSyntaxTree(const string &op, const char value, const vector<SyntaxTree> &children) : op(op), value(value), children(children) {}\n};\n\nint main() {\n\tParser<SyntaxTree> formulaP = lazy<SyntaxTree>([&]() {\n\t\tauto andP = fmap<pair<SyntaxTree, SyntaxTree>, SyntaxTree>((token(\"(\") >> formulaP << token(\"*\")) + (formulaP << token(\")\")), [](auto &o) { return SyntaxTree(\"*\", {}, { o.first, o.second }); });\n\t\tauto orP = fmap<pair<SyntaxTree, SyntaxTree>, SyntaxTree>((token(\"(\") >> formulaP << token(\"+\")) + (formulaP << token(\")\")), [](auto &o) { return SyntaxTree(\"+\", {}, { o.first, o.second }); });\n\t\tauto impP = fmap<pair<SyntaxTree, SyntaxTree>, SyntaxTree>((token(\"(\") >> formulaP << token(\"->\")) + (formulaP << token(\")\")), [](auto &o) { return SyntaxTree(\"->\", {}, { o.first, o.second }); });\n\t\tauto notP = fmap<SyntaxTree, SyntaxTree>(token(\"-\") >> formulaP, [](auto &o) { return SyntaxTree(\"-\", {}, { o }); });\n\t\tauto valP = fmap<char, SyntaxTree>(oneOf(\"abcdefghijkTF\"), [](char x) { return SyntaxTree({}, x, {}); });\n\t\treturn andP || orP || impP || notP || valP;\n\t});\n\tauto equationP = (formulaP << token(\"=\")) + formulaP;\n\tstring s;\n\twhile (cin >> s, s != \"#\") {\n\t\tauto r = equationP(s, 0);\n\t\tbool isValid = true;\n\t\trep(i, 1 << 11) {\n\t\t\tauto toBool = [&](char c) -> bool {\n\t\t\t\tif (c == 'T') return true;\n\t\t\t\tif (c == 'F') return false;\n\t\t\t\treturn i >> (c - 'a') & 1;\n\t\t\t};\n\t\t\tF<bool(const SyntaxTree&)> evalF = [&](const SyntaxTree &f) {\n\t\t\t\tswitch (f.children.size()) {\n\t\t\t\tcase 0: return toBool(f.value);\n\t\t\t\tcase 1: return !evalF(f.children[0]);\n\t\t\t\tcase 2:\n\t\t\t\t\tif (f.op == \"*\") return evalF(f.children[0]) && evalF(f.children[1]);\n\t\t\t\t\tif (f.op == \"+\") return evalF(f.children[0]) || evalF(f.children[1]);\n\t\t\t\t\tif (f.op == \"->\") return !evalF(f.children[0]) || evalF(f.children[1]);\n\t\t\t\t}\n\t\t\t};\n\t\t\tisValid &= evalF(r.object.first) == evalF(r.object.second);\n\t\t}\n\t\tcout << (isValid ? \"YES\" : \"NO\") << endl;\n\t}\n}"
  },
  {
    "language": "C++",
    "code": "#include <iostream>\n#include <vector>\n#include <string>\n#include <cstring>\n#include <algorithm>\n#include <sstream>\n#include <map>\n#include <set>\n\n#define REP(i,k,n) for(int i=k;i<n;i++)\n#define rep(i,n) for(int i=0;i<n;i++)\n#define INF 1<<30\n#define pb push_back\n#define mp make_pair\n\nusing namespace std;\ntypedef long long ll;\ntypedef pair<int,int> P;\n\nvector<string> split(const string &str, char delim) {\n\tvector<string> res;\n\tsize_t current = 0, found;\n\twhile((found = str.find_first_of(delim, current)) != string::npos) {\n\t\tres.push_back(string(str, current, found - current));\n\t\tcurrent = found + 1;\n\t}\n\tres.push_back(string(str, current, str.size() - current));\n\treturn res;\n}\n\nint formula(string& s, int& i) {\n\tif(s[i] == '(') {\n\t\ti++;\n\t\tint val = formula(s, i);\n\n\t\tchar op = s[i];\n\t\tif(s[i] == '-' && s[i+1] == '>') {\n\t\t\ti++;\n\t\t\top = s[i];\n\t\t}\n\n\t\ti++;\n\t\tint val2 = formula(s, i);\n\n\t\tint ret = 0;\n\t\tif(op == '+') {\n\t\t\tif(val || val2) ret = 1;\n\t\t\telse ret = 0;\n\t\t} else if(op == '*') {\n\t\t\tif(val && val2) ret = 1;\n\t\t\telse ret = 0;\n\t\t} else if(op == '>') {\n\t\t\tif(!val) ret = 1;\n\t\t\telse if(val2) ret = 1;\n\t\t\telse ret = 0;\n\t\t}\n\n\t\ti++;\n\t\treturn ret;\n\t} else if(isdigit(s[i])) {\n\t\tint ret = s[i] - '0';\n\t\ti++;\n\t\treturn ret;\n\t} else if(s[i] == '-') {\n\t\ti++;\n\t\tint ret = formula(s, i);\n\n\t\tif(ret == 0) return 1;\n\t\telse return 0;\n\t}\n}\n\nbool used[30];\n\nint main() {\n\tstring s;\n\t// cin >> s;\n\t//\n\t// int i = 0;\n\t// cout << formula(s, i) << endl;\n\t//\n\t// return 0;\n\n\twhile(cin >> s) {\n\t\tif(s == \"#\") break;\n\n\t\tvector<string> ret = split(s, '=');\n\t\tstring s1 = ret[0];\n\t\tstring s2 = ret[1];\n\n\t\tbool flag = true;\n\n\t\trep(i, 1<<11) {\n\t\t\tmemset(used, 0, sizeof(used));\n\t\t\trep(j, 11) {\n\t\t\t\tif(i & (1<<j)) used[j] = true;\n\t\t\t}\n\n\t\t\tstring t1 = s1, t2 = s2;\n\t\t\trep(j, t1.size()) {\n\t\t\t\tif('a' <= t1[j] && t1[j] <= 'k') {\n\t\t\t\t\tif(used[t1[j] - 'a']) t1[j] = 'T';\n\t\t\t\t\telse t1[j] = 'F';\n\t\t\t\t}\n\n\t\t\t\tif(t1[j] == 'T') t1[j] = '1';\n\t\t\t\tif(t1[j] == 'F') t1[j] = '0';\n\t\t\t}\n\n\t\t\trep(j, t2.size()) {\n\t\t\t\tif('a' <= t2[j] && t2[j] <= 'k') {\n\t\t\t\t\tif(used[t2[j] - 'a']) t2[j] = 'T';\n\t\t\t\t\telse t2[j] = 'F';\n\t\t\t\t}\n\n\t\t\t\tif(t2[j] == 'T') t2[j] = '1';\n\t\t\t\tif(t2[j] == 'F') t2[j] = '0';\n\t\t\t}\n\n\t\t\tint j = 0, k = 0;\n\t\t\tint f1 = formula(t1, j);\n\t\t\tint f2 = formula(t2, k);\n\n\t\t\t// cout << t1 << \" -> :: \" << f1 << endl;\n\t\t\t// cout << t2 << \" -> :: \" << f2 << endl;\n\n\t\t\tif(f1 == f2) continue;\n\n\t\t\tflag = false;\n\t\t\tbreak;\n\t\t}\n\n\t\tif(flag) cout << \"YES\" << endl;\n\t\telse cout << \"NO\" << endl;\n\t}\n\n\treturn 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include <iostream>\n#include <sstream>\nusing namespace std;\nvoid replaceAll(string &str,const string from,const string to){\n\tstring::size_type pos = 0;\n\twhile((pos=str.find(from))!= string::npos)\n\t{\n\t\tstr.replace(pos,from.size(),to);\n\t}\n}\nstring ls, rs;\nint pos;\nstring s;\nint state;\nchar next(){\n  return s[pos++];\n}\nbool formula(){\n  char c = next();\n  if(c == '('){\n    bool lf = formula();\n    c = next();\n    bool f;\n    if(c == '*'){//*\n      f = (lf && formula());\n    }else if(c == '+'){//+\n      f = (lf || formula());\n    }else{ //-(>)\n      c = next();\n      f = (!lf || formula());\n    }\n    next();\n    return f;\n  }\n  else if(c == 'T') return true;\n  else if(c == 'F') return false;\n  else if(c == '-') return !formula();\n  else return (1<<(c-'a'))&state;\n}\nbool equation(){\n  bool res = true;\n  for(int i = 0; i < 1 << 11; i++){\n    state = i;\n    pos = 0;\n    s = ls;\n    bool l = formula();\n    pos = 0;\n    s = rs;\n    bool r = formula();\n    res &= (l == r);\n  }\n  return res;\n}\nvoid solve(){\n  cout << (equation() ? \"YES\":\"NO\") << endl;  \n}\nint main(){\n  while(cin >> s && s!=\"#\"){\n    replaceAll(s, \"=\", \" \");\n    stringstream ss;\n    ss << s;\n    ss >> ls >> rs;\n    solve();\n  }\n  return 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include <iostream>\n#include <string>\n#include <cctype>\n#include <algorithm>\n#include <vector>\n#include <cassert>\nusing namespace std;\n\n#define DEBUG(x) cerr << #x << \":\" << x << endl;\n\ntypedef string::const_iterator State;\n\nbool express(State &p);\nbool term(State &p);\nbool elem(State &p);\n\nbool express(State &p) {\n\tbool r = term(p);\n\tfor(;;) {\n\t\tif(*p == '*') {\n\t\t\tp++;\n\t\t\tbool rs = term(p);\n\t\t\tr = r && rs;\n\t\t}\n\t\telse if(*p == '+') {\n\t\t\tp++;\n\t\t\tbool rs = term(p);\n\t\t\tr = r || rs;\n\t\t}\n\t\telse if(*p == '>') {\n\t\t\tp++;\n\t\t\tbool rs = term(p);\n\t\t\tif(r == false) r = true;\n\t\t\telse if(r == true) r = rs;\n\t\t}\n\t\telse {\n\t\t\tbreak;\n\t\t}\n\t}\n\treturn r;\n}\n\nbool term(State &p) {\n\tif(*p == '(') {\n\t\tp++;\n\t\tbool r = express(p);\n\t\tp++;\n\t\treturn r;\n\t}\n\treturn elem(p);\n}\n\nbool elem(State &p) {\n\tif(*p == '-') {\n\t\tp++;\n\t\treturn !term(p);\n\t}\n\n\tbool r = (*p == 'T');\n\tp++;\n\n\treturn r;\n}\n\nvoid replaceAll(string &str, const string &from, const string &to) {\n\tint p = 0;\n\twhile(p = str.find(from, p), p != -1) {\n\t\tstr.replace(p, from.length(), to);\n\t\tp += to.length();\n\t}\n}\n\nint main() {\n#if 0\n\tstring line;\n\tgetline(cin, line);\n\tState p = line.begin();\n\tcout << (int)express(p) << endl;\n#else\n\tstring alpha = \"abcdefghijk\";\n\twhile(true) {\n\t\tstring line;\n\t\tgetline(cin, line);\n\t\tif(line == \"#\") break;\n\t\treplaceAll(line, \"->\", \">\");\n\t\tvector<int> place[11];\n\t\tfor(int i = 0; i < (int)line.size(); i++) {\n\t\t\tchar c = line[i];\n\t\t\tstring::iterator it = find(alpha.begin(),alpha.end(), c);\n\t\t\tif(it != alpha.end()) {\n\t\t\t\tplace[it - alpha.begin()].push_back(i);\n\t\t\t}\n\t\t}\n\n\t\tbool flag = true;\n\t\tint equal = find(line.begin(), line.end(), '=') - line.begin();\n\t\tfor(int i = 0; i < (1 << 11); i++) {\n\t\t\tstring s = line;\n\t\t\tfor(int j = 0; j < 11; j++) {\n\t\t\t\tfor(int k = 0; k < (int)place[j].size(); k++) {\n\t\t\t\t\tchar c = (i & (1 << j)) ? 'T' : 'F';\n\t\t\t\t\ts[place[j][k]] = c;\n\t\t\t\t}\n\t\t\t}\n\t\t\tstring left = s.substr(0, equal);\n\t\t\tstring right = s.substr(equal + 1);\n#if 0\n\t\t\tDEBUG(left)\n\t\t\tDEBUG(right)\n\t\t\tcin >> s;\n#endif\n\t\t\tState lp = left.begin();\n\t\t\tState rp = right.begin();\n\n\t\t\tif(express(lp) != express(rp)) {\n\t\t\t\tflag = false;\n\t\t\t\tbreak;\n\t\t\t}\n\t\t}\n\t\tcout << (flag ? \"YES\" : \"NO\") << endl;\n\t}\n#endif\n\treturn 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include<bits/stdc++.h>\n#define rep(i,n)for(int i=0;i<(n);i++)\nusing namespace std;\n\nint equ(string&, int&);\nint form(string&, int&);\nint q(string&, int&);\n\nint equ(string&s, int&i) {\n\tint v1 = form(s, i); i++;\n\tint v2 = form(s, i);\n\treturn v1 == v2;\n}\nint form(string&s, int&i) {\n\tint v = q(s, i);\n\twhile (s[i] == '-' || s[i] == '>' || s[i] == '*' || s[i] == '+') {\n\t\tchar op = s[i++];\n\t\tint v2 = q(s, i);\n\t\tif (op == '>')v = (!v || v2);\n\t\tif (op == '*')v = (v&&v2);\n\t\tif (op == '+')v = (v || v2);\n\t}\n\treturn v;\n}\nint q(string&s, int&i) {\n\tif (s[i] == 'T' || s[i] == 'F')return s[i++] == 'T';\n\tif (s[i] == '-') {\n\t\ti++; int ret = !q(s, i);\n\t\treturn ret;\n\t}\n\ti++; int ret = form(s, i); i++;\n\treturn ret;\n}\nint main() {\n\tstring buf;\n\twhile (cin >> buf, buf != \"#\") {\n\t\tstring s;\n\t\trep(i, buf.size()) {\n\t\t\tif (buf[i] == '-'&&buf[i + 1] == '>')s += '>', i++;\n\t\t\telse s += buf[i];\n\t\t}\n\t\tmap<char, int>mp;\n\t\tfor (char c : s) {\n\t\t\tif (isalpha(c))mp[c];\n\t\t}\n\t\trep(i, 1 << mp.size()) {\n\t\t\tstring t = s;\n\t\t\tint j = 0;\n\t\t\tfor (auto&p : mp)p.second = ((i >> (j++) & 1) ? 'T' : 'F');\n\t\t\tfor (char&c : t) {\n\t\t\t\tif (isalpha(c))c = mp[c];\n\t\t\t}\n\t\t\tj = 0;\n\t\t\tif (!equ(t, j)) { puts(\"NO\"); goto g; }\n\t\t}\n\t\tputs(\"YES\");\n\tg:;\n\t}\n}"
  },
  {
    "language": "C++",
    "code": "#include<iostream>\n\nusing namespace std;\n\n#define rep(i, n) for (int i = 0; i < int(n); ++i) \n\nstring str;\nint bit;\n\nbool f(string str){\n  if (str.size() == 1) {\n    if (str[0] == 'T') return true;\n    if (str[0] == 'F') return false;\n    else return bit & (1 << (str[0] - 'a'));\n  }\n  int count = 0;\n  rep (i, str.size()) {\n    if (str[i] == '(') ++count;\n    if (str[i] == ')') --count;\n    if (count == 0 && (str[i] == '*' || str[i] == '+' || str.substr(i, 2) == \"->\")) {\n      if (i < int(str.size()) - 1) {\n\tif(str[i] == '*') return f(str.substr(0, i)) && f(str.substr(i + 1));\n\tif (str[i] == '+') return f(str.substr(0, i)) || f(str.substr(i + 1));\n\treturn !f(str.substr(0, i)) || f(str.substr(i + 2));\n      }\n    }\n  }\n  if (str[0] == '-') return !f(str.substr(1));\n  return f(str.substr(1, str.size() - 2));\n}\n\nint main() {\n  for (;;) {\n    cin >> str;\n    if (str == \"#\") break;\n    string s1, s2;\n    rep (i, str.size()) if (str[i] == '=') {\n      s1 = str.substr(0, i);\n      s2 = str.substr(i + 1);\n    }\n    bool ok = true;\n    rep (i, 1 << 11) {\n      bit = i;\n      if (f(s1) != f(s2)) {\n\tok = false;\n\tbreak;\n      }\n    }\n    cout << (ok ? \"YES\" : \"NO\") << endl;\n  }\n}"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\nusing namespace std;\n\ntypedef string::iterator state;\ntypedef map<char, bool> Env;\n\nchar get_oper(state& s) {\n    if (*s == '-') {\n        ++s;\n    }\n\n    return *(s++);\n}\n\n\nbool formula(state& s, Env& env) {\n    if (*s == 'T') {\n        ++s;\n        return true;\n    }\n    if (*s == 'F') {\n        ++s;\n        return false;\n    }\n\n    if ('a' <= *s && *s <= 'k') {\n        return env[*(s++)];\n    }\n\n    if (*s == '-') {\n        return !formula(++s, env);\n    }\n\n    assert(*s == '(');\n\n    ++s; // '('\n    bool lhs = formula(s, env);\n    char oper = get_oper(s);\n    bool rhs = formula(s, env);\n    ++s; // ')'\n\n    if (oper == '*') {\n        return lhs && rhs;\n    } else if (oper == '+') {\n        return lhs || rhs;\n    } else if (oper == '>') {\n        return !lhs || rhs;\n    }\n\n    return NULL;\n}\n\nbool equation(state& s, Env env) {\n    bool left = formula(s, env);\n\n    assert((*s) == '=');\n    ++s;\n\n    bool right = formula(s, env);\n    return left == right;\n}\n\nint main() {\n    Env env;\n    string expr;\n    while (true) {\n        cin >> expr;\n        if (expr == \"#\") {\n            break;\n        }\n\n        bool is_equation = true;\n\n        for (int k = 0; k < (1 << 11) && is_equation; ++k) {\n            for (int l = 0; l < 11; ++l) {\n                env['a' + l] = (k & (1 << l)) != 0;\n            }\n\n            auto iter = begin(expr);\n            bool res = equation(iter, env);\n            is_equation = is_equation && res;\n        }\n\n        cout << (is_equation ? \"YES\" : \"NO\") << endl;\n    }\n    return 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include<iostream>\n#include<string>\nusing namespace std;\n\nint mynot(int a){\n\tif(a==1) return 0;\n\treturn 1;\n}\n\nint myand(int a,int b){\n\tif(a==1 && b==1) return 1;\n\treturn 0;\n}\n\nint myor(int a,int b){\n\tif(a==0 && b==0) return 0;\n\treturn 1;\n}\n\nint naraba(int a,int b){\n\tif(a==0 || (a==1 && b==1)) return 1;\n\treturn 0;\n}\n\nstring s;\nint bit=0;\nint p=0;\n\nint to_int(char a){\n\tif(a=='T') return 1;\n\tif(a=='F') return 0;\n\tint k=a-'a';\n\tif(bit & (1<<k)) return 1;\n\treturn 0;\n}\n\n\nint calc(){\n\tif(isalpha(s[p])) return to_int(s[p++]);\n\tif(s[p]=='-'){\n\t\tp++;\n\t\treturn mynot(calc());\n\t}\n\tif(s[p]=='('){\n\t\tp++;\n\t\tint res1=calc();\n\t\tif(s[p]=='*'){\n\t\t\tp++;\n\t\t\tint res2=calc();\n\t\t\tp++;\n\t\t\treturn myand(res1,res2);\n\t\t}\n\t\telse if(s[p]=='+'){\n\t\t\tp++;\n\t\t\tint res2=calc();\n\t\t\tp++;\n\t\t\treturn myor(res1,res2);\n\t\t}\n\t\telse if(s[p]=='-'){\n\t\t\tp+=2; //>を読み飛ばす\n\t\t\tint res2=calc();\n\t\t\tp++;\n\t\t\treturn naraba(res1,res2);\n\t\t}\n\t}\n\tcout<<\"Error \"<<s[p]<<endl;\n\treturn -1;\n}\n\n\nint main()\n{\n\twhile(cin>>s && s[0]!='#'){\n\n\t\tbool ok=true;\n\t\tfor(bit=0;bit<(1<8);bit++){\n\t\t\tp=0;\n\t\t\tint ans1=calc();\n\t\t\tp++;\n\t\t\tint ans2=calc();\n\t\t\tif(ans1!=ans2){ok=false;break;}\n\t\t}\n\t\tif(ok) cout<<\"YES\"<<endl;\n\t\telse cout<<\"NO\"<<endl;\n\t}\n\treturn 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include <cstdio>\n#include <cstring>\n#include <string>\n#include <iostream>\n#include <cctype>\n#include <vector>\nusing namespace std;\ntypedef string::const_iterator State;\n\n\nvector<int> term(State &begin);\nvector<int> formula(State &begin);\nvector<int> factor(State &begin);\n\nstring data[2];\nvector<int> g[2];\n\nvector<int> formula(State &begin){\n\tvector<int> del(1<<11,0);\n\tint flag=1;\n\tif(*begin=='-'){\n\t\tflag=0;\n\t\tbegin++;\n\t}\n\tif(*begin>='a' && *begin<='k'){\n\t\tfor(int i=0;i<(1<<11);i++){\n\t\t\tdel[i]=1-flag;\n\t\t\tif(i>>(*begin-'a') & 1)del[i]=flag;\n\t\t}\n\t}\n\tif(*begin=='T'){\n\t\tfor(int i=0;i<(1<<11);i++){\n\t\t\tdel[i]=flag;\n\t\t}\n\t}\n\tif(*begin=='F'){\n\t\tfor(int i=0;i<(1<<11);i++){\n\t\t\tdel[i]=1-flag;\n\t\t}\n\t}\n\tbegin++;\n\treturn del;\n}\n\nvector<int> factor(State &begin){\n\tint flag=0;\n\twhile(*begin=='-'){\n\t\tflag=1-flag;\n\t\tbegin++;\n\t}\n\tif(*begin=='('){\n\t\tbegin++;\n\t\tvector<int> ret=term(begin);\n\t\tif(flag){\n\t\t\tfor(int i=0;i<(1<<11);i++){\n\t\t\t\tret[i]=1-ret[i];\n\t\t\t}\n\t\t}\n\t\tbegin++;\n\t\treturn ret;\n\t}else{\n\t\tvector<int> ret=formula(begin);\n\t\tif(flag){\n\t\t\tfor(int i=0;i<(1<<11);i++){\n\t\t\t\tret[i]=1-ret[i];\n\t\t\t}\t\n\t\t}\n\t\treturn ret;\n\t}\n}\n\nvector<int> term(State &begin){\n\tvector<int> ret=factor(begin);\n\twhile(1){\n\t\tif(*begin=='+'){\n\t\t\tbegin++;\n\t\t\tvector<int> ret2=factor(begin);\n\t\t\tfor(int i=0;i<(1<<11);i++){\n\t\t\t\tret[i]=ret[i]|ret2[i];\n\t\t\t}\n\t\t}\n\t\tif(*begin=='*'){\n\t\t\tbegin++;\n\t\t\tvector<int> ret2=factor(begin);\n\t\t\tfor(int i=0;i<(1<<11);i++){\n\t\t\t\tret[i]=ret[i]&ret2[i];\n\t\t\t}\n\t\t}\n\t\tif(*begin=='-'){\n\t\t\tbegin++;\n\t\t\tif(*begin=='>'){\n\t\t\t\tbegin++;\n\t\t\t\tvector<int> ret2=factor(begin);\n\t\t\t\tfor(int i=0;i<(1<<11);i++){\n\t\t\t\t\tret[i]=(ret[i]==0)|ret2[i];\n\t\t\t\t}\n\t\t\t}else{\n\t\t\t\tprintf(\"error\\n\");\n\t\t\t\treturn ret;\n\t\t\t}\n\t\t}else{\n\t\t\tbreak;\n\t\t}\n\t}\n\treturn ret;\n}\n\nint main(void){\n\twhile(1){\n\t\tstring str;\n\t\tcin >> str;\n\t\tif(str==\"#\")break;\n\t\tdata[0]=data[1]=\"\";\n\t\tint v=0;\n\t\tfor(int i=0;i<str.size();i++){\n\t\t\tif(str[i]=='=')v++;\n\t\t\telse data[v]+=str[i];\n\t\t}\n\t\tfor(int i=0;i<2;i++){\n\t\t\tState begin=data[i].begin();\n\t\t\tg[i]=term(begin);\n\t\t}\n\t\tbool flag=true;\n\t\tfor(int i=0;i<1<<11;i++){\n\t\t\tif(g[0][i]!=g[1][i])flag=false;\n\t\t}\n\t\tprintf(\"%s\\n\",flag?\"YES\":\"NO\");\n\t}\n\treturn 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include <iostream>\n#include <algorithm>\n#include <array>\nusing namespace std;\n\nconst int N = 11;\nconst int B = 1<<11;\nusing V = bitset<B>;\n\n#ifndef HELLO_HPP_\n#define HELLO_HPP_\n\n// This file was automatically generated by Caper.\n// (http://jonigata.github.io/caper/caper.html)\n\n#include <cstdlib>\n#include <cassert>\n#include <vector>\n\nnamespace calc {\n\nenum Token {\n token_eof,\n token_Add,\n token_Arrow,\n token_Cons,\n token_EQ,\n token_LBranket,\n token_Mul,\n token_Not,\n token_RBranket,\n token_Var,\n};\n\ninline const char* token_label(Token t) {\n static const char* labels[] = {\n \"token_eof\",\n \"token_Add\",\n \"token_Arrow\",\n \"token_Cons\",\n \"token_EQ\",\n \"token_LBranket\",\n \"token_Mul\",\n \"token_Not\",\n \"token_RBranket\",\n \"token_Var\",\n };\n return labels[t];\n}\n\ntemplate <class T, unsigned int StackSize>\nclass Stack {\npublic:\n Stack() { gap_ = 0; }\n\n void rollback_tmp() {\n gap_ = stack_.size();\n tmp_.clear();\n }\n\n void commit_tmp() {\n // may throw\n stack_.reserve(gap_ + tmp_.size());\n \n // expect not to throw\n stack_.erase(stack_.begin()+ gap_, stack_.end());\n stack_.insert(stack_.end(), tmp_.begin(), tmp_.end());\n tmp_.clear();\n }\n bool push(const T& f) {\n if (StackSize != 0 &&\n int(StackSize) <= int(stack_.size() + tmp_.size())) {\n return false;\n }\n tmp_.push_back(f);\n return true;\n }\n \n void pop(size_t n) {\n if (tmp_.size() < n) {\n n -= tmp_.size();\n tmp_.clear();\n gap_ -= n;\n } else {\n tmp_.erase(tmp_.end() - n, tmp_.end());\n }\n }\n\n T& top() {\n assert(0 < depth());\n if (!tmp_.empty()) {\n return tmp_.back();\n } else {\n return stack_[gap_ - 1];\n }\n }\n \n const T& get_arg(size_t base, size_t index) {\n size_t n = tmp_.size();\n if (base - index <= n) {\n return tmp_[n - (base - index)];\n } else {\n return stack_[gap_ - (base - n) + index];\n }\n }\n \n void clear() {\n stack_.clear();\n tmp_.clear();\n gap_ = 0; \n }\n \n bool empty() const {\n if (!tmp_.empty()) {\n return false;\n } else {\n return gap_ == 0;\n }\n }\n \n size_t depth() const {\n return gap_ + tmp_.size();\n }\n \n T& nth(size_t index) {\n if (gap_ <= index) {\n return tmp_[index - gap_];\n } else {\n return stack_[index];\n }\n }\n\n void swap_top_and_second() {\n int d = depth();\n assert(2 <= d);\n T x = nth(d - 1);\n nth(d - 1) = nth(d - 2);\n nth(d - 2) = x;\n }\n\nprivate:\n std::vector<T> stack_;\n std::vector<T> tmp_;\n size_t gap_;\n \n};\n\ntemplate <class _Value, class _SemanticAction,\n unsigned int _StackSize = 0>\nclass Parser {\npublic:\n typedef Token token_type;\n typedef _Value value_type;\n\n enum Nonterminal {\n Nonterminal_Expr,\n Nonterminal_Form,\n };\n\npublic:\n Parser(_SemanticAction& sa) : sa_(sa) { reset(); }\n\n void reset() {\n error_ = false;\n accepted_ = false;\n clear_stack();\n rollback_tmp_stack();\n if (push_stack(0, value_type())) {\n commit_tmp_stack();\n } else {\n sa_.stack_overflow();\n error_ = true;\n }\n }\n\n bool post(token_type token, const value_type& value) {\n rollback_tmp_stack();\n error_ = false;\n while ((this->*(stack_top()->entry->state))(token, value))\n ; // may throw\n if (!error_) {\n commit_tmp_stack();\n } else {\n recover(token, value);\n }\n return accepted_ || error_;\n }\n\n bool accept(value_type& v) {\n assert(accepted_);\n if (error_) { return false; }\n v = accepted_value_;\n return true;\n }\n\n bool error() { return error_; }\n\nprivate:\n typedef Parser<_Value, _SemanticAction, _StackSize> self_type;\n\n typedef bool (self_type::*state_type)(token_type, const value_type&);\n typedef int (self_type::*gotof_type)(Nonterminal);\n\n bool accepted_;\n bool error_;\n value_type accepted_value_;\n _SemanticAction& sa_;\n\n struct table_entry {\n state_type state;\n gotof_type gotof;\n bool handle_error;\n };\n\n struct stack_frame {\n const table_entry* entry;\n value_type value;\n int sequence_length;\n\n stack_frame(const table_entry* e, const value_type& v, int sl)\n : entry(e), value(v), sequence_length(sl) {}\n };\n\n Stack<stack_frame, _StackSize> stack_;\n\n bool push_stack(int state_index, const value_type& v, int sl = 0) {\n bool f = stack_.push(stack_frame(entry(state_index), v, sl));\n assert(!error_);\n if (!f) { \n error_ = true;\n sa_.stack_overflow();\n }\n return f;\n }\n\n void pop_stack(size_t n) {\n stack_.pop(n);\n }\n\n stack_frame* stack_top() {\n return &stack_.top();\n }\n\n const value_type& get_arg(size_t base, size_t index) {\n return stack_.get_arg(base, index).value;\n }\n\n void clear_stack() {\n stack_.clear();\n }\n\n void rollback_tmp_stack() {\n stack_.rollback_tmp();\n }\n\n void commit_tmp_stack() {\n stack_.commit_tmp();\n }\n\n void recover(token_type, const value_type&) {\n }\n\n bool call_nothing(Nonterminal nonterminal, int base) {\n pop_stack(base);\n int dest_index = (this->*(stack_top()->entry->gotof))(nonterminal);\n return push_stack(dest_index, value_type());\n }\n\n bool call_0_Merge(Nonterminal nonterminal, int base, int arg_index0, int arg_index1) {\n V arg0; sa_.downcast(arg0, get_arg(base, arg_index0));\n V arg1; sa_.downcast(arg1, get_arg(base, arg_index1));\n V r = sa_.Merge(arg0, arg1);\n value_type v; sa_.upcast(v, r);\n pop_stack(base);\n int dest_index = (this->*(stack_top()->entry->gotof))(nonterminal);\n return push_stack(dest_index, v);\n }\n\n bool call_0_Identity(Nonterminal nonterminal, int base, int arg_index0) {\n V arg0; sa_.downcast(arg0, get_arg(base, arg_index0));\n V r = sa_.Identity(arg0);\n value_type v; sa_.upcast(v, r);\n pop_stack(base);\n int dest_index = (this->*(stack_top()->entry->gotof))(nonterminal);\n return push_stack(dest_index, v);\n }\n\n bool call_0_MakeAdd(Nonterminal nonterminal, int base, int arg_index0, int arg_index1) {\n V arg0; sa_.downcast(arg0, get_arg(base, arg_index0));\n V arg1; sa_.downcast(arg1, get_arg(base, arg_index1));\n V r = sa_.MakeAdd(arg0, arg1);\n value_type v; sa_.upcast(v, r);\n pop_stack(base);\n int dest_index = (this->*(stack_top()->entry->gotof))(nonterminal);\n return push_stack(dest_index, v);\n }\n\n bool call_0_MakeMul(Nonterminal nonterminal, int base, int arg_index0, int arg_index1) {\n V arg0; sa_.downcast(arg0, get_arg(base, arg_index0));\n V arg1; sa_.downcast(arg1, get_arg(base, arg_index1));\n V r = sa_.MakeMul(arg0, arg1);\n value_type v; sa_.upcast(v, r);\n pop_stack(base);\n int dest_index = (this->*(stack_top()->entry->gotof))(nonterminal);\n return push_stack(dest_index, v);\n }\n\n bool call_0_MakeIMP(Nonterminal nonterminal, int base, int arg_index0, int arg_index1) {\n V arg0; sa_.downcast(arg0, get_arg(base, arg_index0));\n V arg1; sa_.downcast(arg1, get_arg(base, arg_index1));\n V r = sa_.MakeIMP(arg0, arg1);\n value_type v; sa_.upcast(v, r);\n pop_stack(base);\n int dest_index = (this->*(stack_top()->entry->gotof))(nonterminal);\n return push_stack(dest_index, v);\n }\n\n bool call_0_MakeNot(Nonterminal nonterminal, int base, int arg_index0) {\n V arg0; sa_.downcast(arg0, get_arg(base, arg_index0));\n V r = sa_.MakeNot(arg0);\n value_type v; sa_.upcast(v, r);\n pop_stack(base);\n int dest_index = (this->*(stack_top()->entry->gotof))(nonterminal);\n return push_stack(dest_index, v);\n }\n\n bool state_0(token_type token, const value_type& value) {\n switch(token) {\n case token_Cons:\n // shift\n push_stack(/*state*/ 10, value);\n return false;\n case token_LBranket:\n // shift\n push_stack(/*state*/ 6, value);\n return false;\n case token_Not:\n // shift\n push_stack(/*state*/ 5, value);\n return false;\n case token_Var:\n // shift\n push_stack(/*state*/ 11, value);\n return false;\n default:\n sa_.syntax_error();\n error_ = true;\n return false;\n }\n }\n\n int gotof_0(Nonterminal nonterminal) {\n switch(nonterminal) {\n case Nonterminal_Expr: return 1;\n case Nonterminal_Form: return 2;\n default: assert(0); return false;\n }\n }\n\n bool state_1(token_type token, const value_type& value) {\n switch(token) {\n case token_eof:\n // accept\n accepted_ = true;\n accepted_value_ = get_arg(1, 0);\n return false;\n default:\n sa_.syntax_error();\n error_ = true;\n return false;\n }\n }\n\n int gotof_1(Nonterminal nonterminal) {\n assert(0);\n return true;\n }\n\n bool state_2(token_type token, const value_type& value) {\n switch(token) {\n case token_EQ:\n // shift\n push_stack(/*state*/ 3, value);\n return false;\n default:\n sa_.syntax_error();\n error_ = true;\n return false;\n }\n }\n\n int gotof_2(Nonterminal nonterminal) {\n assert(0);\n return true;\n }\n\n bool state_3(token_type token, const value_type& value) {\n switch(token) {\n case token_Cons:\n // shift\n push_stack(/*state*/ 10, value);\n return false;\n case token_LBranket:\n // shift\n push_stack(/*state*/ 6, value);\n return false;\n case token_Not:\n // shift\n push_stack(/*state*/ 5, value);\n return false;\n case token_Var:\n // shift\n push_stack(/*state*/ 11, value);\n return false;\n default:\n sa_.syntax_error();\n error_ = true;\n return false;\n }\n }\n\n int gotof_3(Nonterminal nonterminal) {\n switch(nonterminal) {\n case Nonterminal_Form: return 4;\n default: assert(0); return false;\n }\n }\n\n bool state_4(token_type token, const value_type& value) {\n switch(token) {\n case token_eof:\n // reduce\n return call_0_Merge(Nonterminal_Expr, /*pop*/ 3, 0, 2);\n default:\n sa_.syntax_error();\n error_ = true;\n return false;\n }\n }\n\n int gotof_4(Nonterminal nonterminal) {\n assert(0);\n return true;\n }\n\n bool state_5(token_type token, const value_type& value) {\n switch(token) {\n case token_Cons:\n // shift\n push_stack(/*state*/ 10, value);\n return false;\n case token_LBranket:\n // shift\n push_stack(/*state*/ 6, value);\n return false;\n case token_Not:\n // shift\n push_stack(/*state*/ 5, value);\n return false;\n case token_Var:\n // shift\n push_stack(/*state*/ 11, value);\n return false;\n default:\n sa_.syntax_error();\n error_ = true;\n return false;\n }\n }\n\n int gotof_5(Nonterminal nonterminal) {\n switch(nonterminal) {\n case Nonterminal_Form: return 12;\n default: assert(0); return false;\n }\n }\n\n bool state_6(token_type token, const value_type& value) {\n switch(token) {\n case token_Cons:\n // shift\n push_stack(/*state*/ 10, value);\n return false;\n case token_LBranket:\n // shift\n push_stack(/*state*/ 6, value);\n return false;\n case token_Not:\n // shift\n push_stack(/*state*/ 5, value);\n return false;\n case token_Var:\n // shift\n push_stack(/*state*/ 11, value);\n return false;\n default:\n sa_.syntax_error();\n error_ = true;\n return false;\n }\n }\n\n int gotof_6(Nonterminal nonterminal) {\n switch(nonterminal) {\n case Nonterminal_Form: return 13;\n default: assert(0); return false;\n }\n }\n\n bool state_7(token_type token, const value_type& value) {\n switch(token) {\n case token_Cons:\n // shift\n push_stack(/*state*/ 10, value);\n return false;\n case token_LBranket:\n // shift\n push_stack(/*state*/ 6, value);\n return false;\n case token_Not:\n // shift\n push_stack(/*state*/ 5, value);\n return false;\n case token_Var:\n // shift\n push_stack(/*state*/ 11, value);\n return false;\n default:\n sa_.syntax_error();\n error_ = true;\n return false;\n }\n }\n\n int gotof_7(Nonterminal nonterminal) {\n switch(nonterminal) {\n case Nonterminal_Form: return 14;\n default: assert(0); return false;\n }\n }\n\n bool state_8(token_type token, const value_type& value) {\n switch(token) {\n case token_Cons:\n // shift\n push_stack(/*state*/ 10, value);\n return false;\n case token_LBranket:\n // shift\n push_stack(/*state*/ 6, value);\n return false;\n case token_Not:\n // shift\n push_stack(/*state*/ 5, value);\n return false;\n case token_Var:\n // shift\n push_stack(/*state*/ 11, value);\n return false;\n default:\n sa_.syntax_error();\n error_ = true;\n return false;\n }\n }\n\n int gotof_8(Nonterminal nonterminal) {\n switch(nonterminal) {\n case Nonterminal_Form: return 16;\n default: assert(0); return false;\n }\n }\n\n bool state_9(token_type token, const value_type& value) {\n switch(token) {\n case token_Cons:\n // shift\n push_stack(/*state*/ 10, value);\n return false;\n case token_LBranket:\n // shift\n push_stack(/*state*/ 6, value);\n return false;\n case token_Not:\n // shift\n push_stack(/*state*/ 5, value);\n return false;\n case token_Var:\n // shift\n push_stack(/*state*/ 11, value);\n return false;\n default:\n sa_.syntax_error();\n error_ = true;\n return false;\n }\n }\n\n int gotof_9(Nonterminal nonterminal) {\n switch(nonterminal) {\n case Nonterminal_Form: return 19;\n default: assert(0); return false;\n }\n }\n\n bool state_10(token_type token, const value_type& value) {\n switch(token) {\n case token_eof:\n case token_Add:\n case token_EQ:\n case token_Mul:\n case token_Not:\n case token_RBranket:\n // reduce\n return call_0_Identity(Nonterminal_Form, /*pop*/ 1, 0);\n default:\n sa_.syntax_error();\n error_ = true;\n return false;\n }\n }\n\n int gotof_10(Nonterminal nonterminal) {\n assert(0);\n return true;\n }\n\n bool state_11(token_type token, const value_type& value) {\n switch(token) {\n case token_eof:\n case token_Add:\n case token_EQ:\n case token_Mul:\n case token_Not:\n case token_RBranket:\n // reduce\n return call_0_Identity(Nonterminal_Form, /*pop*/ 1, 0);\n default:\n sa_.syntax_error();\n error_ = true;\n return false;\n }\n }\n\n int gotof_11(Nonterminal nonterminal) {\n assert(0);\n return true;\n }\n\n bool state_12(token_type token, const value_type& value) {\n switch(token) {\n case token_eof:\n case token_Add:\n case token_EQ:\n case token_Mul:\n case token_Not:\n case token_RBranket:\n // reduce\n return call_0_MakeNot(Nonterminal_Form, /*pop*/ 2, 1);\n default:\n sa_.syntax_error();\n error_ = true;\n return false;\n }\n }\n\n int gotof_12(Nonterminal nonterminal) {\n assert(0);\n return true;\n }\n\n bool state_13(token_type token, const value_type& value) {\n switch(token) {\n case token_Add:\n // shift\n push_stack(/*state*/ 8, value);\n return false;\n case token_Mul:\n // shift\n push_stack(/*state*/ 7, value);\n return false;\n case token_Not:\n // shift\n push_stack(/*state*/ 18, value);\n return false;\n default:\n sa_.syntax_error();\n error_ = true;\n return false;\n }\n }\n\n int gotof_13(Nonterminal nonterminal) {\n assert(0);\n return true;\n }\n\n bool state_14(token_type token, const value_type& value) {\n switch(token) {\n case token_RBranket:\n // shift\n push_stack(/*state*/ 15, value);\n return false;\n default:\n sa_.syntax_error();\n error_ = true;\n return false;\n }\n }\n\n int gotof_14(Nonterminal nonterminal) {\n assert(0);\n return true;\n }\n\n bool state_15(token_type token, const value_type& value) {\n switch(token) {\n case token_eof:\n case token_Add:\n case token_EQ:\n case token_Mul:\n case token_Not:\n case token_RBranket:\n // reduce\n return call_0_MakeMul(Nonterminal_Form, /*pop*/ 5, 1, 3);\n default:\n sa_.syntax_error();\n error_ = true;\n return false;\n }\n }\n\n int gotof_15(Nonterminal nonterminal) {\n assert(0);\n return true;\n }\n\n bool state_16(token_type token, const value_type& value) {\n switch(token) {\n case token_RBranket:\n // shift\n push_stack(/*state*/ 17, value);\n return false;\n default:\n sa_.syntax_error();\n error_ = true;\n return false;\n }\n }\n\n int gotof_16(Nonterminal nonterminal) {\n assert(0);\n return true;\n }\n\n bool state_17(token_type token, const value_type& value) {\n switch(token) {\n case token_eof:\n case token_Add:\n case token_EQ:\n case token_Mul:\n case token_Not:\n case token_RBranket:\n // reduce\n return call_0_MakeAdd(Nonterminal_Form, /*pop*/ 5, 1, 3);\n default:\n sa_.syntax_error();\n error_ = true;\n return false;\n }\n }\n\n int gotof_17(Nonterminal nonterminal) {\n assert(0);\n return true;\n }\n\n bool state_18(token_type token, const value_type& value) {\n switch(token) {\n case token_Arrow:\n // shift\n push_stack(/*state*/ 9, value);\n return false;\n default:\n sa_.syntax_error();\n error_ = true;\n return false;\n }\n }\n\n int gotof_18(Nonterminal nonterminal) {\n assert(0);\n return true;\n }\n\n bool state_19(token_type token, const value_type& value) {\n switch(token) {\n case token_RBranket:\n // shift\n push_stack(/*state*/ 20, value);\n return false;\n default:\n sa_.syntax_error();\n error_ = true;\n return false;\n }\n }\n\n int gotof_19(Nonterminal nonterminal) {\n assert(0);\n return true;\n }\n\n bool state_20(token_type token, const value_type& value) {\n switch(token) {\n case token_eof:\n case token_Add:\n case token_EQ:\n case token_Mul:\n case token_Not:\n case token_RBranket:\n // reduce\n return call_0_MakeIMP(Nonterminal_Form, /*pop*/ 6, 1, 4);\n default:\n sa_.syntax_error();\n error_ = true;\n return false;\n }\n }\n\n int gotof_20(Nonterminal nonterminal) {\n assert(0);\n return true;\n }\n\n const table_entry* entry(int n) const {\n static const table_entry entries[] = {\n { &Parser::state_0, &Parser::gotof_0, false },\n { &Parser::state_1, &Parser::gotof_1, false },\n { &Parser::state_2, &Parser::gotof_2, false },\n { &Parser::state_3, &Parser::gotof_3, false },\n { &Parser::state_4, &Parser::gotof_4, false },\n { &Parser::state_5, &Parser::gotof_5, false },\n { &Parser::state_6, &Parser::gotof_6, false },\n { &Parser::state_7, &Parser::gotof_7, false },\n { &Parser::state_8, &Parser::gotof_8, false },\n { &Parser::state_9, &Parser::gotof_9, false },\n { &Parser::state_10, &Parser::gotof_10, false },\n { &Parser::state_11, &Parser::gotof_11, false },\n { &Parser::state_12, &Parser::gotof_12, false },\n { &Parser::state_13, &Parser::gotof_13, false },\n { &Parser::state_14, &Parser::gotof_14, false },\n { &Parser::state_15, &Parser::gotof_15, false },\n { &Parser::state_16, &Parser::gotof_16, false },\n { &Parser::state_17, &Parser::gotof_17, false },\n { &Parser::state_18, &Parser::gotof_18, false },\n { &Parser::state_19, &Parser::gotof_19, false },\n { &Parser::state_20, &Parser::gotof_20, false },\n };\n return &entries[n];\n }\n\n};\n\n} // namespace calc\n\n#endif // #ifndef HELLO_HPP_\n\n\n\nclass unexpected_char : public std::exception {};\n\n\n// %token Cons<V> Var<V> Not Add Mul Arrow EQ LBranket RBranket;\n// %namespace calc;\n\n// Expr<V> : [Merge] Form(0) EQ Form(1)\n// ;\n// Form<V> : [Identity] Cons\n// | [Identity] Var\n// | [MakeNot] Not Form(0)\n// | [MakeMul] LBranket Form(0) Mul Form(1) RBranket\n// | [MakeAdd] LBranket Form(0) Add Form(1) RBranket\n// | [MakeIMP] LBranket Form(0) Not Arrow Form(1) RBranket\n// ;\n\n\nstruct SemanticAction {\n void syntax_error() {}\n void stack_overflow() {}\n void downcast(V& x, V y) { x = y; }\n void upcast(V& x, V y) { x = y; }\n\n V Identity(V n) { return n; }\n V MakeNot(V n) {\n return ~n;\n }\n V MakeMul(V x, V y) {\n return x & y;\n }\n V MakeAdd(V x, V y) {\n return x | y;\n }\n V MakeIMP(V x, V y) {\n return (~x) | y;\n }\n V Merge(V x, V y) {\n return x ^ y;\n }\n};\n\n// %token Cons<V> Var<V> Not Add Mul Arrow EQ LBranket RBranket;\n// %namespace calc;\n\n// Expr<V> : [Merge] Form(0) EQ Form(1)\n// ;\n// Form<V> : [Identity] Cons\n// | [Identity] Var\n// | [MakeNot] Not Form(0)\n// | [MakeMul] LBranket Form(0) Mul Form(1) RBranket\n// | [MakeAdd] LBranket Form(0) Add Form(1) RBranket\n// | [MakeIMP] LBranket Form(0) Not Arrow Form(1) RBranket\n// ;\n\n\nclass scanner {\npublic:\n using char_type = char;\n\nprivate:\n string s;\n int pos;\npublic:\n scanner(string s) : s(s), pos(0) {}\n\n calc::Token get(V& v) {\n char c;\n do {\n c = getc();\n } while (isspace(c));\n if (c == 'T') {\n v.set();\n return calc::token_Cons;\n }\n if (c == 'F') {\n v.reset();\n return calc::token_Cons;\n }\n if ('a' <= c and c <= 'k') {\n int u = c - 'a';\n v.reset();\n for (int i = 0; i < B; i++) {\n if (i & (1<<u)) {\n v.set(i);\n }\n }\n return calc::token_Var;\n }\n switch (c) {\n case '+': return calc::token_Add;\n case '*': return calc::token_Mul;\n case '(': return calc::token_LBranket;\n case ')': return calc::token_RBranket;\n case '-': return calc::token_Not;\n case '>': return calc::token_Arrow;\n case '=': return calc::token_EQ;\n case EOF: return calc::token_eof;\n }\n\n cerr << c << endl;\n throw unexpected_char();\n }\n\nprivate:\n char_type getc() {\n if (pos == s.size()) return EOF;\n return s[pos++];\n }\n};\n\n\n\nint main() {\n while (true) {\n string s;\n getline(cin, s);\n if (s == \"#\") break;\n scanner scn(s);\n SemanticAction sa;\n calc::Parser<V, SemanticAction> parser(sa);\n calc::Token token;\n while (true) {\n V v;\n token = scn.get(v);\n if (parser.post(token, v)) { break; }\n }\n V v;\n if (parser.accept(v)) {\n if (v.any()) {\n cout << \"NO\" << endl;\n } else {\n cout << \"YES\" << endl;\n }\n }\n }\n return 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\nusing namespace std;\n#define int long long   // <-----!!!!!!!!!!!!!!!!!!!\n\n#define rep(i,n) for (int i=0;i<(n);i++)\n#define rep2(i,a,b) for (int i=(a);i<(b);i++)\n#define rrep(i,n) for (int i=(n)-1;i>=0;i--)\n#define rrep2(i,a,b) for (int i=(a)-1;i>=b;i--)\n#define all(a) (a).begin(),(a).end()\n#define rall(a) (a).rbegin(),(a).rend()\n#define printV(_v) for(auto _x:_v){cout<<_x<<\" \";}cout<<endl\n#define printVS(vs) for(auto x : vs){cout << x << endl;}\n#define printVV(_vv) for(auto _v:_vv){for(auto _x:_v){cout<<_x<<\" \";}cout<<endl;}\n#define printP(p) cout << p.first << \" \" << p.second << endl\n#define printVP(vp) for(auto p : vp) printP(p);\n#define readV(_v) rep(j, _v.size()) cin >> _v[j];\n#define readVV(_vv) rep(i, _vv.size()) readV(_vv[i]);\n#define output(_x) cout << _x << endl;\n\ntypedef long long ll;\ntypedef pair<int, int> Pii;\ntypedef tuple<int, int, int> TUPLE;\ntypedef vector<int> vi;\ntypedef vector<vi> vvi;\ntypedef vector<vvi> vvvi;\ntypedef vector<Pii> vp;\nconst int inf = 1e9;\nconst int mod = 1e9 + 7;\n\ntypedef string::const_iterator State;\nconst int K = 11;\n\nstring format(string s) {\n    string t;\n    int i = 0;\n    while (i < s.size()) {\n        if (i + 1 < s.size() && s.substr(i, 2) == \"->\") {\n            t += '@';\n            i += 2;\n        } else {\n            t += s[i];\n            i++;\n        }\n    }\n    return t;\n}\n\nbool atom(State&, int);\nbool term(State&, int);\nbool formula(State&, int);\n\nbool atom(State &begin, int bits) {\n    if (*begin == 'T') {\n        begin++;\n        return true;\n    } else if (*begin == 'F') {\n        begin++;\n        return false;\n    } else {\n        assert('a' <= *begin && *begin <= 'k');\n        int i = *begin - 'a';\n        begin++;\n        return (bits >> i) & 1;\n    }\n}\n\nbool term(State &begin, int bits) {\n    bool ret = formula(begin, bits);\n\n    if (*begin == '*') {\n        begin++;\n        ret &= formula(begin, bits);\n    } else if (*begin == '+') {\n        begin++;\n        ret |= formula(begin, bits);\n    } else {\n        assert(*begin == '@');\n        begin++;\n        int nxt = formula(begin, bits);\n        ret = (!ret || nxt);\n    }\n\n    return ret;\n}\n\nbool formula(State &begin, int bits) {\n    bool ret;\n\n    if (isalpha(*begin)) {\n        ret = atom(begin, bits);\n    } else if (*begin == '-') {\n        begin++;\n        ret = !formula(begin, bits);\n    } else {\n        assert(*begin == '(');\n        begin++;\n        ret = term(begin, bits);\n        assert(*begin == ')');\n        begin++;\n    }\n\n    return ret;\n}\n\nbool solve(string s) {\n    s = format(s); // convert \"->\" to \"@\"\n    \n    string s1, s2;\n    bool reading_s1 = true;\n    rep(i, s.size()) {\n        if (s[i] == '=') {\n            reading_s1 = false;\n        } else {\n            (reading_s1 ? s1 : s2) += s[i];\n        }\n    }\n\n    rep(bits, 1 << K) {\n        State begin1 = s1.begin();\n        State begin2 = s2.begin();\n        if (formula(begin1, bits) ^ formula(begin2, bits)) {\n            return false;\n        }\n    }\n\n    return true;\n}\n\nsigned main() {\n    std::ios::sync_with_stdio(false);\n    std::cin.tie(0);\n\n    string s;\n    while (cin >> s, s[0] - '#') {\n        cout << (solve(s) ? \"YES\" : \"NO\") << endl;\n    }\n}"
  },
  {
    "language": "C++",
    "code": "#include <iostream>\n#include <vector>\n#include <string>\n\nusing namespace std;\nstring str;\nint idx;\n\n\nint calc() {\n    char c = str[idx];\n    if (c == '-') {\n        idx++;\n        return 1-calc();\n    }\n    if (c == '(') {\n        idx++;\n        int r1 = calc();\n        char cc = str[idx];\n        idx++;\n        if (cc == '-') {\n            idx++;\n        }\n        int r2 = calc();\n        idx++;\n        if (cc == '*') {\n            return r1*r2;\n        }\n        if (cc == '+') {\n            return min(1, r1+r2);\n        }\n        if (cc == '-') {\n            if (r1 && !r2) {\n                return 0;\n            } else {\n                return 1;\n            }\n        }\n    }\n    idx++;\n    return c == 'T' ? 1 : 0;\n}\n\nint main() {\n    while (true) {\n        string s;\n        cin >> s;\n        if (s == \"#\") break;\n        string s1 = \"\", s2 = \"\";\n        int u = 0;\n        while (s[u] != '=') {\n            s1 += s[u];\n            u++;\n        }\n        u++;\n        while (u < s.size()) {\n            s2 += s[u];\n            u++;\n        }\n        bool f = true;\n        for (int i = 0; i < (1<<2); i++) {\n            str = s1;\n            for (int j = 0; j < str.size(); j++) {\n                if ('a' <= str[j] && str[j] <= 'k') {\n                    str[j] = ((i>>(str[j]-'a')) & 1) ? 'T' : 'F';\n                }\n            }\n            idx = 0;\n            int r1 = calc();\n            str = s2;\n            for (int j = 0; j < str.size(); j++) {\n                if ('a' <= str[j] && str[j] <= 'k') {\n                    str[j] = ((i>>(str[j]-'a')) & 1) ? 'T' : 'F';\n                }\n            }\n            idx = 0;\n            int r2 = calc();\n            if (r1 != r2) {\n                f = false;\n                break;\n            }          \n        }\n        if (f) {\n            cout << \"YES\" << endl;\n        } else {\n            cout << \"NO\" << endl;\n        }  \n    }\n}"
  },
  {
    "language": "C++",
    "code": "#include<bits/stdc++.h>\nusing namespace std;\ntypedef string::const_iterator state;\n\nstring str;\nstring A,B;\n\nstring conv(string &S,int bit){\n    string ret=S;\n    for(int i=0;i<S.size();i++){\n        if('a'<=S[i]&&'k'>=S[i]){\n            ret[i]=((bit>>(S[i]-'a')&1)?'1':'0');\n        }\n    }\n    return ret;\n}\nint expression(state &);\n\nint number(state &b){\n    int ret=0;\n    while(isdigit(*b)){\n        ret=ret*10+*b-'0';\n        b++;\n    }\n    return ret;\n}\n\nint fact(state &b){\n    int ret;\n    if(*b=='('){\n        b++;\n        ret=expression(b);\n        b++;\n    }\n    else{\n        ret=number(b);\n    }\n    return ret;\n}\n\nint latte(state &b){\n    if(*b=='-'){\n        b++;\n        return 1-latte(b);\n    }\n    else return fact(b);\n}\n\nint expression(state &b){\n    int ret=latte(b);\n    while(true){\n        if(*b=='+'){\n            b++;\n            ret=max(ret,latte(b));\n        }\n        else if(*b=='*'){\n            b++;\n            ret=min(ret,latte(b));\n        }\n        else if(*b=='-'){\n            b++;b++;\n            ret=(ret<=latte(b)?1:0);\n        }\n        else break;\n    }\n    return ret;\n}\n\nvoid solve(){\n    for(int i=0;i<str.size();i++){\n        if(str[i]=='T')str[i]='1';\n        if(str[i]=='F')str[i]='0';\n    }\n\n    int idx=str.find('=');\n    A=str.substr(0,idx);\n    B=str.substr(idx+1,str.size()-idx-1);\n    A+=\"=\";B+=\"=\";\n\n    for(int i=0;i<(1<<11);i++){\n        string a=conv(A,i),b=conv(B,i);\n        state sa=a.begin(),sb=b.begin();\n        if(expression(sa)!=expression(sb)){\n            cout<<\"NO\"<<endl;\n            return;\n        }\n    }\n    cout<<\"YES\"<<endl;\n}\n\nint main(){\n    while(cin>>str,str!=\"#\")solve();\n    return 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include <string>\n#include <iostream>\nusing namespace std;\nint pos; string t, d1, d2;\nbool solve(string s) {\n\tswitch (s[pos++]) {\n\tcase 'T': return true;\n\tcase 'F': return false;\n\tcase '-': \n\t\tif (s[pos] != '>') return !solve(s); break;\n\tcase '(':\n\t\tbool a = solve(s), b;\n\t\tswitch (s[pos++]) {\n\t\tcase '+': b = a || solve(s); break;\n\t\tcase '*': b = a && solve(s); break;\n\t\tcase '-': pos++; b = !a || solve(s); break;\n\t\t}\n\t\tpos++;\n\t\treturn b;\n\t}\n\treturn false;\n}\nint main() {\n\twhile (cin >> t) {\n\t\tif (t == \"#\") break;\n\t\tbool flag1 = false; d1 = \"\"; d2 = \"\";\n\t\tfor (int i = 0; i < t.size(); i++) {\n\t\t\tif (t[i] == '=') flag1 = true, i++;\n\t\t\tif (!flag1) d1 += t[i];\n\t\t\telse d2 += t[i];\n\t\t}\n\t\tbool flag = true;\n\t\tfor (int i = 0; i < 2048; i++) {\n\t\t\tstring d3 = d1, d4 = d2;\n\t\t\tfor (int j = 0; j < 11; j++) {\n\t\t\t\tfor (int k = 0; k < d3.size(); k++) {\n\t\t\t\t\tif (d3[k] == j + 97) {\n\t\t\t\t\t\td3[k] = (i & (1 << j) ? 'T' : 'F');\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t\tfor (int k = 0; k < d4.size(); k++) {\n\t\t\t\t\tif (d4[k] == j + 97) {\n\t\t\t\t\t\td4[k] = (i & (1 << j) ? 'T' : 'F');\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t}\n\t\t\tpos = 0; bool p1 = solve(d3); pos = 0; bool p2 = solve(d4);\n\t\t\tif (p1 != p2) {\n\t\t\t\tflag = false;\n\t\t\t}\n\t\t}\n\t\tprintf(\"%s\\n\", flag ? \"YES\" : \"NO\");\n\t}\n\treturn 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include <iostream>\n#include <vector>\n#include <string>\n#include <algorithm>\nusing namespace std;\n\nint c;\nbool a[11];\n\nbool f(const string s) {\n\tif (s[c] == '(') {\n\t\tc++;\n\t\tbool v = f(s);\n\t\tif (s[c] == '+') {\n\t\t\tc++;\n\t\t\tv |= f(s);\n\t\t}\n\t\telse if (s[c] == '*') {\n\t\t\tc++;\n\t\t\tv &= f(s);\n\t\t}\n\t\telse {\n\t\t\tc += 2;\n\t\t\tv = !(v && !f(s));\n\t\t}\n\t\tc++; // s[c] == ')'\n\t\treturn v;\n\t}\n\n\tif (s[c] == 'T') {\n\t\tc++;\n\t\treturn true;\n\t}\n\tif (s[c] == 'F') {\n\t\tc++;\n\t\treturn false;\n\t}\n\tif (s[c] == '-') {\n\t\tc++;\n\t\treturn !f(s);\n\t}\n\tif ('a' <= s[c] && s[c] <= 'k') {\n\t\tbool v = a[s[c] - 'a'];\n\t\tc++;\n\t\treturn v;\n\t}\n\texit(1);\n}\n\nbool solve(string s1, string s2) {\n\tfor (int i = 0; i < (1 << 11); i++) {\n\t\tfor (int j = 0; j < 11; j++) {\n\t\t\ta[i] = (i & (1 << j)) > 0;\n\t\t}\n\t\t//cout << i << \" \" << s1 + \" \" << s2 << endl;\n\t\tc = 0;\n\t\tbool res1 = f(s1);\n\t\tc = 0;\n\t\tbool res2 = f(s2);\n\n\t\tif (res1 == res2) return true;\n\t}\n\n\treturn false;\n}\n\nint main() {\n\tcin.tie(0);\n\tios::sync_with_stdio(false);\n\tstring s, s1, s2;\n\twhile (cin >> s , s != \"#\") {\n\t\tint idx = s.find('=');\n\t\ts1 = s.substr(0, idx) , s2 = s.substr(idx + 1, s.size() - (idx + 1));\n\t\tcout << (solve(s1, s2) ? \"YES\" : \"NO\") << endl;\n\t}\n}"
  },
  {
    "language": "C++",
    "code": "#include<iostream>\n#include<string>\n#define MAX 11\nusing namespace std;\nbool o;\nvoid rec(string ss){\n  if(!o) return;\n  //cout << s << endl;\n  string s =ss;\n  bool f;\n  int p;\n\n  \n  if(s.find(\"-0\")!=-1){\n    p=s.find(\"-0\");\n    s[p]='1';s[p+1]=' ';\n    f=true;\n  }\n  if(s.find(\"-1\")!=-1){\n    p=s.find(\"-1\");\n    s[p]='0';s[p+1]=' ';\n    f=true;\n  }\n  \n  \n  while(s.find(\"(0*0)\")!=-1){\n    p=s.find(\"(0*0)\");\n    s[p]='0';s[p+1]=' ';s[p+2]=' ';s[p+3]=' ';s[p+4]=' ';\n    f=true;\n  }\n  while(s.find(\"(0*1)\")!=-1){\n    p=s.find(\"(0*1)\");\n    s[p]='0';s[p+1]=' ';s[p+2]=' ';s[p+3]=' ';s[p+4]=' ';\n    f=true;\n  }\n  while(s.find(\"(1*0)\")!=-1){\n    p=s.find(\"(1*0)\");\n    s[p]='0';s[p+1]=' ';s[p+2]=' ';s[p+3]=' ';s[p+4]=' ';\n    f=true;\n  }\n  while(s.find(\"(1*1)\")!=-1){\n    p=s.find(\"(1*1)\");\n    s[p]='1';s[p+1]=' ';s[p+2]=' ';s[p+3]=' ';s[p+4]=' ';\n    f=true;\n  }\n  while(s.find(\"(0+0)\")!=-1){\n    p=s.find(\"(0+0)\");\n    s[p]='0';s[p+1]=' ';s[p+2]=' ';s[p+3]=' ';s[p+4]=' ';\n    f=true;\n  }\n  while(s.find(\"(0+1)\")!=-1){\n    p=s.find(\"(0+1)\");\n    s[p]='1';s[p+1]=' ';s[p+2]=' ';s[p+3]=' ';s[p+4]=' ';\n    f=true;\n  }\n  while(s.find(\"(1+0)\")!=-1){\n    p=s.find(\"(1+0)\");\n    s[p]='1';s[p+1]=' ';s[p+2]=' ';s[p+3]=' ';s[p+4]=' ';\n    f=true;\n  }\n  while(s.find(\"(1+1)\")!=-1){\n    p=s.find(\"(1+1)\");\n    s[p]='1';s[p+1]=' ';s[p+2]=' ';s[p+3]=' ';s[p+4]=' ';\n    f=true;\n  }\n  \n  while(s.find(\"(0->0)\")!=-1){\n    p=s.find(\"(0->0)\");\n    s[p]='1';s[p+1]=' ';s[p+2]=' ';s[p+3]=' ';s[p+4]=' ';s[p+5]=' ';\n    f=true;\n  }\n  while(s.find(\"(0->1)\")!=-1){\n    p=s.find(\"(0->1)\");\n    s[p]='1';s[p+1]=' ';s[p+2]=' ';s[p+3]=' ';s[p+4]=' ';s[p+5]=' ';\n    f=true;\n  }\n  while(s.find(\"(1->0)\")!=-1){\n    p=s.find(\"(1->0)\");\n    s[p]='0';s[p+1]=' ';s[p+2]=' ';s[p+3]=' ';s[p+4]=' ';s[p+5]=' ';\n    f=true;\n  }\n  while(s.find(\"(1->1)\")!=-1){\n    p=s.find(\"(1->1)\");\n    s[p]='1';s[p+1]=' ';s[p+2]=' ';s[p+3]=' ';s[p+4]=' ';s[p+5]=' ';\n    f=true;\n  }\n  \n  if(f){\n    string b;\n    for(int i=0;i<s.size();i++) if(s[i]!=' ') b+=s[i];\n    rec(b);\n  }else{\n    if(s[0]!=s[2]) o=false;\n    return;\n  }\n}\nvoid init(int n,string s){\n  int i,j;\n  for(i=0;i<s.size();i++){\n    for(j=0;j<=MAX;j++){\n      if(s[i]=='a'+j) s[i]='0'+(n>>j&1);\n      if(s[i]=='T') s[i]='1';\n      if(s[i]=='F') s[i]='0';\n    }\n  }\n  rec(s);\n}\nint main(){\n  string s;\n  while(cin >> s,s!=\"#\"){\n    o=true;\n    int i;\n    for(i=0;i<(1<<MAX);i++)\n      init(i,s);\n    cout << (o?\"YES\":\"NO\") << endl;\n  }\n  return 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include <iostream>\n#include <string>\n#include <sstream>\n#include <cctype>\nusing namespace std;\n\nistringstream iss;\nint a;\n\nbool parse(){\n\tchar ch;\n\tiss >> ch;\n\n\tif( isalpha( ch ) ){\n\t\tif( ch == 'T' ) return true;\n\t\tif( ch == 'F' ) return false;\n\t\treturn ( a >> (ch - 'a') ) & 1;\n\t}\n\t\n\tif( ch == '-' ){\n\t\treturn !parse();\n\t}\n\n\tbool f1 = parse();\n\tiss >> ch;\n\tif( ch == '-' ) iss.ignore();\n\tbool f2 = parse();\n\tiss.ignore();\n\tif( ch == '*' )\treturn f1 && f2;\n\tif( ch == '+' ) return f1 || f2;\n\treturn f1 <= f2;\n}\n\nbool solve(const string &input){\n\tfor( a = 1 << 11; a--; ){\n\t\tiss.clear();\n\t\tiss.str(input);\n\n\t\tbool left = parse();\n\t\tiss.ignore();\n\t\tbool right = parse();\n\t\tif( left != right ){ return false; }\n\t}\n\treturn true;\n}\n\n\nint main(){\n\tstring s;\n\twhile( cin >> s, s[0] != '#' ){\n\t\tcout << (solve(s) ? \"YES\" : \"NO\") << endl;\n\t}\n}"
  },
  {
    "language": "C++",
    "code": "#include <iostream>\n#include <vector>\n#include <string>\n#include <map>\n#include <algorithm>\n#include <bitset>\n\n#define REP(i,n) for(int i=0;i<(int)(n);i++)\n\nusing namespace std;\n\npair<bool,int> ok(string& str,int beg=0){\n  if(str[beg]=='-'){\n    auto res = ok(str,beg+1);\n    return make_pair(!res.first, res.second);\n  } else if(str[beg] == '(') {\n    auto res1 = ok(str, beg+1);\n    if(str[res1.second] == '-') {\n      auto res2 = ok(str, res1.second+2);\n      return make_pair(!res1.first || res2.first, res2.second+1);\n    } else {\n      auto res2 = ok(str, res1.second+1);\n      switch(str[res1.second]) {\n        case '+':\n        return make_pair(res1.first || res2.first, res2.second+1);\n        case '*':\n        return make_pair(res1.first && res2.first, res2.second+1);\n        case '=':\n        return make_pair(res1.first == res2.first, res2.second+1);\n      }\n    }\n  } else {\n    return make_pair(str[beg] == 'T', beg+1);\n  }\n}\n\nint main() {\n  while(1){\n    string str;\n    cin>>str;\n    if(str==\"#\")break;\n    str = '(' + str + ')';\n    bool f=true;\n    REP(i,1<<11){\n      string cp=str;\n      bitset<11> b(i);\n      REP(j,11){\n        for(char& c:cp){\n          if(c=='a'+j){\n            c=b[j]?'T':'F';\n          }\n        }\n      }\n      if(!ok(cp).first)\n        f=false;\n    }\n    if(f)\n      cout<<\"YES\"<<endl;\n    else\n      cout<<\"NO\"<<endl;\n  }\n  return 0;\n}"
  },
  {
    "language": "C++",
    "code": "'use strict';\n\nfunction token(s) {\n  var len = s.length;\n  return function (target, pos) {\n    return target.substr(pos, len) === s ? [true, s, pos + len] : [false, null, pos];\n  };\n}\n\nfunction choice() {\n  var parsers = arguments;\n  return function (target, pos) {\n    var _iteratorNormalCompletion = true;\n    var _didIteratorError = false;\n    var _iteratorError = undefined;\n\n    try {\n      for (var _iterator = parsers[Symbol.iterator](), _step; !(_iteratorNormalCompletion = (_step = _iterator.next()).done); _iteratorNormalCompletion = true) {\n        var parser = _step.value;\n\n        var parsed = parser(target, pos);\n        if (parsed[0]) return parsed;\n      }\n    } catch (err) {\n      _didIteratorError = true;\n      _iteratorError = err;\n    } finally {\n      try {\n        if (!_iteratorNormalCompletion && _iterator.return) {\n          _iterator.return();\n        }\n      } finally {\n        if (_didIteratorError) {\n          throw _iteratorError;\n        }\n      }\n    }\n\n    return [false, null, pos];\n  };\n}\n\nfunction seq() {\n  var parsers = arguments;\n  return function (target, pos) {\n    var result = [];\n    var nextPos = pos;\n    var _iteratorNormalCompletion2 = true;\n    var _didIteratorError2 = false;\n    var _iteratorError2 = undefined;\n\n    try {\n      for (var _iterator2 = parsers[Symbol.iterator](), _step2; !(_iteratorNormalCompletion2 = (_step2 = _iterator2.next()).done); _iteratorNormalCompletion2 = true) {\n        var parser = _step2.value;\n\n        var parsed = parser(target, nextPos);\n        if (!parsed[0]) return [false, null, pos];\n        result.push(parsed[1]);\n        nextPos = parsed[2];\n      }\n    } catch (err) {\n      _didIteratorError2 = true;\n      _iteratorError2 = err;\n    } finally {\n      try {\n        if (!_iteratorNormalCompletion2 && _iterator2.return) {\n          _iterator2.return();\n        }\n      } finally {\n        if (_didIteratorError2) {\n          throw _iteratorError2;\n        }\n      }\n    }\n\n    return [true, result, nextPos];\n  };\n}\n\nfunction lazy(f) {\n  var parser = void 0;\n  return function (target, position) {\n    if (!parser) parser = f();\n    return parser(target, position);\n  };\n}\n\nfunction fmap(parser, f) {\n  return function (target, pos) {\n    var result = parser(target, pos);\n    if (result[0]) {\n      return [result[0], f(result[1]), result[2]];\n    } else {\n      return result;\n    }\n  };\n}\n\nfunction oneOf(s) {\n  var d = {};\n  var _iteratorNormalCompletion3 = true;\n  var _didIteratorError3 = false;\n  var _iteratorError3 = undefined;\n\n  try {\n    for (var _iterator3 = s[Symbol.iterator](), _step3; !(_iteratorNormalCompletion3 = (_step3 = _iterator3.next()).done); _iteratorNormalCompletion3 = true) {\n      var c = _step3.value;\n      d[c] = c;\n    }\n  } catch (err) {\n    _didIteratorError3 = true;\n    _iteratorError3 = err;\n  } finally {\n    try {\n      if (!_iteratorNormalCompletion3 && _iterator3.return) {\n        _iterator3.return();\n      }\n    } finally {\n      if (_didIteratorError3) {\n        throw _iteratorError3;\n      }\n    }\n  }\n\n  return function (target, pos) {\n    var c = target.substr(pos, 1);\n    return d[c] ? [true, c, pos + 1] : [false, null, pos];\n  };\n}\n\n(function (stdin) {\n  var formulaP = lazy(function () {\n    var andP = fmap(seq(token('('), formulaP, token('*'), formulaP, token(')')), function (x) {\n      return { op: '*', fs: [x[1], x[3]] };\n    });\n    var orP = fmap(seq(token('('), formulaP, token('+'), formulaP, token(')')), function (x) {\n      return { op: '+', fs: [x[1], x[3]] };\n    });\n    var impP = fmap(seq(token('('), formulaP, token('->'), formulaP, token(')')), function (x) {\n      return { op: '->', fs: [x[1], x[3]] };\n    });\n    var notP = fmap(seq(token('-'), formulaP), function (x) {\n      return { op: '-', fs: [x[1]] };\n    });\n    var valP = fmap(oneOf('abcdefghijkTF'), function (x) {\n      return { val: x, fs: [] };\n    });\n    return choice(andP, orP, impP, notP, valP);\n  });\n  var equationP = fmap(seq(formulaP, token('='), formulaP), function (x) {\n    return { left: x[0], right: x[2] };\n  });\n\n  var lines = stdin.toString().trim().split('\\n');\n  lines.pop();\n  lines.forEach(function (s) {\n    var r = equationP(s, 0);\n    var isValid = true;\n\n    var _loop = function _loop(i) {\n      isValid &= evalF(r[1].left) == evalF(r[1].right);\n      function toBool(c) {\n        if (c === 'T') return true;\n        if (c === 'F') return false;\n        return !!(i >> c.charCodeAt() - 'a'.charCodeAt() & 1);\n      }\n      function evalF(f) {\n        switch (f.fs.length) {\n          case 0:\n            return toBool(f.val);\n          case 1:\n            return !evalF(f.fs[0]);\n          case 2:\n            switch (f.op) {\n              case '*':\n                return evalF(f.fs[0]) && evalF(f.fs[1]);\n              case '+':\n                return evalF(f.fs[0]) || evalF(f.fs[1]);\n              case '->':\n                return !evalF(f.fs[0]) || evalF(f.fs[1]);\n            }\n        }\n      }\n    };\n\n    for (var i = 0; i < 1 << 11; i++) {\n      _loop(i);\n    }\n    console.log(isValid ? 'YES' : 'NO');\n  });\n})(require('fs').readFileSync('/dev/stdin', 'utf8'));"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\nusing namespace std;\n\nvector<string> opr{\"->\", \"+\", \"*\", \"-\"};\nvector<string> num{\"1\", \"2\", \"3\", \"4\"};\n\nvoid add_para(string &exp) {\n    auto find_idx = exp.find(\"4\");\n    while (find_idx != string::npos) {\n        if (exp[find_idx + 1] == '(') {\n            int end_idx = find_idx + 2;\n            int count = 1;\n            while (count) {\n                if (exp[end_idx] == '(') count++;\n                else if (exp[end_idx] == ')') count--;\n                end_idx++;\n            }\n            exp.insert(end_idx, \")\");\n            exp[find_idx] = '5';\n            exp.insert(find_idx, \"(\");\n        } else {\n            exp.insert(find_idx + 2, \")\");\n            exp[find_idx] = '5';\n            exp.insert(find_idx, \"(\");\n        }\n\n        find_idx = exp.find(\"4\");\n    }\n}\n\nbool calc(string exp, int bits) {\n    if (exp == \"T\") return true;\n    else if (exp == \"F\") return false;\n    else if (exp.size() == 1) {\n        if (bits & (1 << (exp[0] - 'a'))) return true;\n        else return false;\n    }\n\n    if (exp[1] == '5') return !calc(string(exp.begin() + 2, exp.end() - 1), bits);\n    int idx;\n    for (int i = 1, len = exp.size(), count = 0; i < len - 1; i++) {\n        if (exp[i] == '(') count++;\n        else if (exp[i] == ')') count--;\n        if (count == 0 && '1' <= exp[i] && exp[i] <= '5') idx = i;\n    }\n\n    bool lhs = calc(string(exp.begin() + 1, exp.begin() + idx), bits);\n    bool rhs = calc(string(exp.begin() + idx + 1, exp.end() - 1), bits);\n\n    if (exp[idx] == '1') return !(lhs && !rhs);\n    if (exp[idx] == '2') return (lhs || rhs);\n    if (exp[idx] == '3') return (lhs && rhs);\n}\n\nvoid solve(string str) {\n    for (int i = 0, len = opr.size(); i < len; i++) {\n        auto find_idx = str.find(opr[i]);\n        while (find_idx != string::npos) {\n            str.replace(find_idx, (int)(opr[i].size()), num[i]);\n            find_idx = str.find(opr[i]);\n        }\n    }\n    int eq_idx = str.find(\"=\");\n    string exp1 = string(str.begin(), str.begin() + eq_idx);\n    string exp2 = string(str.begin() + eq_idx + 1, str.end());\n\n    add_para(exp1);\n    add_para(exp2);\n\n    bool flag = true;\n    for (int i = 0; i < (1 << 11); i++) {\n        if (calc(exp1, i) != calc(exp2, i)) {\n            flag = false;\n            break;\n        }\n    }\n\n    if (flag == true) cout << \"YES\" << endl;\n    else cout << \"NO\" << endl;\n}\n\nint main() {\n    string Input;\n    while (cin >> Input, Input != \"#\") solve(Input);\n\n    return 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\nusing namespace std;\n\ntypedef string::const_iterator Iterator;\nbool val[256];\nbool table[3][2][2] = {\n\t{0, 0, 0, 1},\n\t{0, 1, 1, 1},\n\t{1, 1, 0, 1}\n};\n\nbool equation(Iterator &);\nbool expr(Iterator &);\nbool number(Iterator &);\nbool term(Iterator &);\n\nbool equation(Iterator &it)\n{\n\tbool lhs = expr(it);\n\t++it;\n\tbool rhs = expr(it);\n\treturn lhs == rhs;\n}\n\nbool expr(Iterator &it)\n{\n\tif (isalpha(*it)){\n\t\treturn number(it);\n\t}\n\t\n\treturn term(it);\n}\n\nbool number(Iterator &it)\n{\n\tbool res = val[*it];\n\t++it;\n\treturn res;\n}\n\nbool term(Iterator &it)\n{\n\tif (*it == '-'){\n\t\t++it;\n\t\treturn !expr(it);\n\t}\n\t\n\t++it;\n\tbool lhs = expr(it);\n\tint op = [&](){\n\t\tint res;\n\t\tif (*it == '*') res = 0;\n\t\tif (*it == '+') res = 1;\n\t\tif (*it == '-') res = 2;\n\t\tit += (res == 2) ? (2) : (1);\n\t\treturn res;\n\t}();\n\tbool rhs = expr(it);\n\t++it;\n\t\n\treturn table[op][lhs][rhs];\n}\n\nint main()\n{\n\tval['T'] = true;\n\t\n\tstring str;\n\twhile (cin >> str, str != \"#\"){\n\t\tbool res = true;\n\t\t\n\t\tfor (int bit = 0; bit < (1 << 11); bit++){\n\t\t\tfor (int i = 0; i < 11; i++){\n\t\t\t\tval['a' + i] = (bit >> i) & 1;\n\t\t\t}\n\t\t\t\n\t\t\tIterator it = str.begin();\n\t\t\tif (!equation(it)){\n\t\t\t\tres = false;\n\t\t\t\tbreak;\n\t\t\t}\n\t\t}\n\t\t\n\t\tputs(res ? \"YES\" : \"NO\");\n\t}\n}"
  },
  {
    "language": "C++",
    "code": "// clang-format off\n#include <bits/stdc++.h>\n#define int long long\n#define main signed main()\n// #define main int main()\n#define loop(i, a, n) for (int i = (a); i < (n); i++)\n#define rep(i, n) loop(i, 0, n)\n#define all(v) (v).begin(), (v).end()\n#define rall(v) (v).rbegin(), (v).rend()\n#define prec(n) fixed << setprecision(n)\n#define stlice(from, to) substr(from, (to) - (from) + 1)\n#define pb push_back\n#define mp make_pair\n#define mt make_tuple\n#define fi first\n#define se second\nusing namespace std;\ntypedef pair<int, int> pii;\ntypedef vector<int> vi;\ntypedef vector<double> vd;\ntypedef vector<char> vc;\ntypedef vector<bool> vb;\ntypedef vector<string> vs;\ntypedef vector<pii> vpii;\ntypedef vector<vi> vvi;\ntypedef vector<vb> vvb;\ntypedef vector<vpii> vvpii;\nconst int INF = sizeof(int) == sizeof(long long) ? 1000000000000000000LL : 1000000000;\nconst int MOD = 1000000007;\nconst double PI = acos(-1);\ntemplate<typename A, typename B> bool cmin(A &a, const B &b) { return a > b ? (a = b, true) : false; }\ntemplate<typename A, typename B> bool cmax(A &a, const B &b) { return a < b ? (a = b, true) : false; }\nbool odd(const int &n) { return n & 1; }\nbool even(const int &n) { return !odd(n); }\nvoid tsurai();\nmain { tsurai(); return 0; }\n// clang-format on\n\nvector<string> split(const string &s, char delim) {\n  vector<string> xs;\n  string item;\n  for (char ch : s) {\n    if (ch == delim) {\n      if (!item.empty()) {\n        xs.push_back(item);\n      }\n      item.clear();\n    } else {\n      item += ch;\n    }\n  }\n  if (!item.empty()) {\n    xs.push_back(item);\n  }\n  return xs;\n}\n\nbool getValue(const char &c, const int &t) {\n  return t >> (c - 'a') & 1;\n}\n\ntemplate<typename L, typename R>\nstruct either {\n  L left;\n  R right;\n  bool isLeft;\n  either(L l)\n    : left(l), isLeft(true) {\n  }\n  either(R r)\n    : right(r), isLeft(false) {\n  }\n};\n\ntypedef either<string, bool> TOKEN;\ntypedef stack<TOKEN> RPN;\n\nRPN parse(const string &s, const int &t) {\n  stack<TOKEN> buf;\n  stack<string> ops;\n  int n = s.size();\n  rep(i, n) {\n    if (s[i] == '-' && s[i + 1] != '>') ops.push(\"-\");\n    if (s[i] == '-' && s[i + 1] == '>') ops.push(\"->\"), i++;\n    if (s[i] == '+') {\n      while (ops.size() && ops.top() != \"(\") {\n        buf.push(TOKEN(ops.top()));\n        ops.pop();\n      }\n      ops.push(\"+\");\n    }\n    if (s[i] == '*') {\n      while (ops.size() && ops.top() != \"(\") {\n        buf.push(TOKEN(ops.top()));\n        ops.pop();\n      }\n      ops.push(\"*\");\n    }\n    if (s[i] == 'T') buf.push(TOKEN(true));\n    if (s[i] == 'F') buf.push(TOKEN(false));\n    if (s[i] == '(') ops.push(\"(\");\n    if (s[i] == ')') {\n      while (ops.size()) {\n        if (ops.top() == \"(\") {\n          ops.pop();\n          break;\n        }\n        buf.push(TOKEN(ops.top())), ops.pop();\n      }\n    }\n    if ('a' <= s[i] && s[i] <= 'k') buf.push(TOKEN(getValue(s[i], t)));\n  }\n  while (ops.size()) buf.push(TOKEN(ops.top())), ops.pop();\n  RPN rpn;\n  while (buf.size()) rpn.push(buf.top()), buf.pop();\n  return rpn;\n}\n\nbool eval(RPN rpn) {\n  stack<bool> s;\n  while (rpn.size()) {\n    TOKEN t = rpn.top();\n    if (t.isLeft) {\n      string op = t.left;\n      if (op == \"-\") {\n        bool a = s.top();\n        s.pop();\n        s.push(!a);\n      }\n      if (op == \"+\") {\n        bool a = s.top();\n        s.pop();\n        bool b = s.top();\n        s.pop();\n        s.push(a || b);\n      }\n      if (op == \"*\") {\n        bool a = s.top();\n        s.pop();\n        bool b = s.top();\n        s.pop();\n        s.push(a && b);\n      }\n      if (op == \"->\") {\n        bool a = s.top();\n        s.pop();\n        bool b = s.top();\n        s.pop();\n        s.push(!b || a);\n      }\n    } else {\n      s.push(t.right);\n    }\n    rpn.pop();\n  }\n  return s.top();\n}\n\nvoid tsurai() {\n  string s;\n  while (cin >> s, s != \"#\") {\n    vs _     = split(s, '=');\n    string l = _[0], r = _[1];\n    bool b = true;\n    rep(i, 1 << 11) b &= eval(parse(l, i)) == eval(parse(r, i));\n    cout << (b ? \"YES\" : \"NO\") << endl;\n  }\n}"
  },
  {
    "language": "C++",
    "code": "#include <iostream>\n#include <complex>\n#include <sstream>\n#include <string>\n#include <algorithm>\n#include <deque>\n#include <list>\n#include <map>\n#include <numeric>\n#include <queue>\n#include <vector>\n#include <set>\n#include <limits>\n#include <cstdio>\n#include <cctype>\n#include <cmath>\n#include <cstring>\n#include <cstdlib>\n#include <ctime>\nusing namespace std;\n#define REP(i, j) for(int i = 0; i < (int)(j); ++i)\n#define FOR(i, j, k) for(int i = (int)(j); i < (int)(k); ++i)\n#define P pair<int, int>\n#define SORT(v) sort((v).begin(), (v).end())\n#define REVERSE(v) reverse((v).begin(), (v).end())\n\nstring s;\nint now;\nvector<char> chars;\n\nbool check(bool x, char op, bool y){\n  if(op == '*'){\n    if(x && y) return true;\n    else return false;\n  } else if(op == '+'){\n    if(!x && !y) return false;\n    else return true;\n  } else if(op == '>'){\n    if(x && !y) return false;\n    return true;\n  }\n  return false;\n}\n\nbool formula(){\n  //cout <<s <<\", \" <<now <<\", \" <<s[now] <<endl;\n  if(s[now] == 'T'){\n    ++now;\n    return true;\n  } else if(s[now] == 'F'){\n    ++now;\n    return false;\n  } else if(s[now] == '-'){\n    ++now;\n    bool res = formula();\n    return !res;\n  } else if(s[now] == '('){\n    ++now;\n    bool x = formula();\n    char op = s[now];\n    ++now;\n    bool y = formula();\n    //cout <<x <<\" \" <<op <<\" \" <<y <<endl;\n    return check(x, op, y);\n  }\n  return false;\n}\n\nmap<char, char> get_m(int bit){\n  map<char, char> ret;\n  int len = (int)(chars.size());\n  for(int i = 0; i < len; ++i){\n    if(bit & (1 << i)) ret[chars[i]] = 'T';\n    else ret[chars[i]] = 'F';\n  }\n  return ret;\n}\n\nbool calc(){\n  stringstream left_ss, right_ss;\n  bool left_end = false;\n  REP(i, s.length()){\n    if(s[i] == '=') left_end = true;\n    else{\n      if(left_end) right_ss << s[i];\n      else left_ss << s[i];\n    }\n  }\n  string left = left_ss.str(), right = right_ss.str();\n  REP(i, s.length())\n  REP(i, (1 << (int)(chars.size()))){\n    string tmp_l = left, tmp_r = right;\n    map<char, char> m = get_m(i);\n    REP(i, left.length()) if(isalpha(left[i]) && left[i] != 'T' && left[i] != 'F') left[i] = m[left[i]];\n    REP(i, right.length()) if(isalpha(right[i]) && right[i] != 'T' && right[i] != 'F') right[i] = m[right[i]];\n    s = left; now = 0;\n    bool left_ans = formula();\n    s = right; now = 0;\n    bool right_ans = formula();\n    //debug\n    //cout <<left <<\", \" <<right <<\" | \" <<left_ans <<\", \" <<right_ans <<endl;\n    if(left_ans != right_ans){\n      return false;\n    }\n    left = tmp_l; right = tmp_r;\n  }\n  return true;\n}\n\nint main() {\n  while(cin >>s && s != \"#\"){\n    set<char> chars_s;\n    stringstream ss;\n    REP(i, s.length()){\n      if(i + 1 != s.length() && s[i] == '-' && s[i + 1] == '>'){\n        ss << '>';\n        ++i;\n      } else{\n        if(isalpha(s[i])) chars_s.insert(s[i]);\n        ss << s[i];\n      }\n    }\n    chars = vector<char>();\n    for(set<char>::iterator it = chars_s.begin(); it != chars_s.end(); ++it) chars.push_back((*it));\n    s = ss.str();\n    cout <<(calc() ? \"YES\" : \"NO\") <<endl;\n  }\n  return 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\nusing namespace std;\n#define REP(i,n) for(int i=0; i<n; i++)\n#define FOR(i,a,b) for(int i=a; i<b; i++)\n\ntemplate<typename T>\nvoid fillall(T& arr, const T& value) {\n    arr = value;\n}\ntemplate<typename T,typename ARR>\nvoid fillall(ARR& arr, const T& value) {\n    for(auto& i:arr) fillall(i,value);\n}\n\nchar buf[1252];\nchar s[1252];\n\nint it;\nbool calc(){\n    if(s[it]=='-'){\n        it++;\n        return !calc();\n    }else if(s[it]=='('){\n        it++;\n        bool a = calc();\n        char c = s[it];\n        it++;\n        if(c=='-')it++;\n        bool b = calc();\n        it++;\n        if(c=='*')return a&&b;\n        if(c=='+')return a||b;\n        return (!a) || b;\n    }else{\n        char c = s[it++];\n        return c=='T';\n    }\n}\n\nint main(){\n    while(true){\n        fill(buf,buf+1252,'\\0');\n        scanf(\"%s\",buf);\n        if(buf[0]=='#')break;\n        int l = strlen(buf);\n        int eq = 0;\n        REP(i,l)if(buf[i]=='=')eq=i;\n        bool ok = true;\n        REP(msk,1<<11){\n            // f\n            REP(i,eq){\n                char c = buf[i];\n                if('a' <= c && c <= 'k'){\n                    int id = c-'a';\n                    if(msk >> id & 1){\n                        c = 'T';\n                    }else{\n                        c = 'F';\n                    }\n                }\n                s[i] = c;\n            }\n            s[eq] = '\\0';\n            it = 0;\n            bool f = calc();\n            // g\n            FOR(i,eq+1,l){\n                char c = buf[i];\n                if('a' <= c && c <= 'k'){\n                    int id = c-'a';\n                    if(msk >> id & 1){\n                        c = 'T';\n                    }else{\n                        c = 'F';\n                    }\n                }\n                s[i-(eq+1)] = c;\n            }\n            s[l-(eq+1)] = '\\0';\n            it = 0;\n            bool g = calc();\n\n            if(f!=g){\n                ok = false; \n                break;\n            }\n        }\n        puts(ok ? \"YES\" : \"NO\");\n    }\n    return 0;\n}\n\n"
  },
  {
    "language": "C++",
    "code": "#include<iostream>\n#include<vector>\n#include<map>\n\nusing namespace std;\n\nconst int LIM = (1<<11);\n\nmap<char,bool> M;\n\n\nbool isalf(string s){\n  return(s.size() == 1 && 'a' <= s[0] && s[0] <= 'k');\n}\n\nbool ispara(string s){\n  int p = 0;\n\n  // if(s[0] != '(' || s[s.length()-1] != ')') return false;\n\n  for(int i = 0; i < s.length()-1; i++){\n    if(s[i] == '(') p++;\n    if(s[i] == ')') p--;\n    if(p == 0) return false;\n  }\n  return true;\n}\n\nbool isdeny(string s){\n\n  if(s.length() < 2) return false;\n\n  return (s[0] == '-' && s[1] != '>');\n}\n\nbool solve(string s){\n  // cout << \"s \" << s << endl;\n  if(isalf(s)) return M[s[0]];\n  else if(s == \"T\") return true;\n  else if(s == \"F\") return false;\n  else if(ispara(s)) return solve(s.substr(1,s.length()-2));\n  else{\n    int p = 0;\n\n    for(int i = 0; i < s.length(); i++){\n      if(s[i] == '(') p++;\n      if(s[i] == ')') p--;\n      if(p == 0 && s[i] == '+') return (solve(s.substr(0,i))||solve(s.substr(i+1)));\n      if(p == 0 && s[i] == '*') return (solve(s.substr(0,i))&&solve(s.substr(i+1)));\n      if(p == 0 && s[i] == '-' && s[i+1] == '>' ) return !(solve(s.substr(0,i))==true\n\t\t\t\t\t\t\t  && solve(s.substr(i+2)) == false);\n    }\n    if(isdeny(s)) return !solve(s.substr(1));\n  }\n}\n\nvoid print(){\n\n  cout << endl;\n  for(char c = 'a'; c <= 'k'; c++)\n    cout << c << \" \" << M[c] << \" \";\n\n  cout  << endl << endl;\n}\nvoid makemap(int n){\n  \n  for(int i = 0; i < 11; i++){\n    if((n&(1<<i)))M['a'+i] = true;\n    else M['a'+i] = false;\n  }\n}\n\nbool check(string s){\n  \n  int pos;\n  \n  for(int i = 0; i < s.length(); i++)\n    if(s[i] == '='){\n      pos = i;\n      break;\n    }\n  \n  for(int i = 0; i < LIM; i++){\n    makemap(i);\n    // print();\n    if(solve(s.substr(0,pos)) != solve(s.substr(pos+1))) return false;\n  }\n  \n  return true;\n}\nint main(){\n\n  string s;\n  while(getline(cin,s) && s != \"#\"){\n    if(check(s)) cout << \"YES\" << endl;\n    else cout << \"NO\" << endl;\n  }\n  return 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include <iostream>\n#include <string>\n\nusing namespace std;\n\nstring input;\ntypedef string::iterator State;\n\nint m;\n\nbool cons( State &s, char ch ) {\n  if(*s == ch) {\n    //cout << *s;\n    s ++;\n    return true;\n  }\n  return false;\n}\n\nint formula( State &s ) {\n  \n  // <formula> ::= \"T\" | \"F\"\n  if(cons(s, 'T')) return true;\n  if(cons(s, 'F')) return false;\n  \n  // <formula>  ::= \"a\" | \"b\" | \"c\" | \"d\" | \"e\" | \"f\" | \"g\" | \"h\" | \"i\" | \"j\" | \"k\"\n  if(isalpha(*s)) { return (m>>(*(s++)-'a')) & 1; }\n\n  // <formula> ::= \"-\" <formula>\n  if(cons(s, '-')) return !formula(s);\n  \n  // <formula> ::= \"(\" <formula> \"*\" <formula> \")\"\n  // <formula> ::= \"(\" <formula> \"+\" <formula> \")\"\n  // <formula> ::= \"(\" <formula> \"->\" <formula> \")\"\n  int ret;\n  if(cons(s, '(')) {\n    ret = formula(s);\n    \n    if(cons(s, '*')) {\n      ret &= formula(s);\n    }\n    if(cons(s, '+')) {\n      ret |= formula(s);\n    }\n    if(cons(s, '-')) {\n      cons(s, '>');\n      ret = ret<=formula(s);\n    }\n\n    cons(s, ')');\n  }\n  \n  return ret;\n}\n\nint main() {\n  \n  while( getline(cin, input) ) {\n    if(input == \"#\") break;\n    bool l, r;\n    bool ok = 1;\n    for(m=0; m<(1<<11); m++) {\n      State s = input.begin();\n      l = formula(s);\n      cons(s, '=');\n      r = formula(s);\n      //cout << endl;\n      if(l != r) ok = 0;\n    }\n    if(ok) cout << \"YES\" << endl;\n    else cout << \"NO\" << endl;\n  }\n  \n  return 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\n#define rep(i,n) for(int i=0;i<n;i++)\n#define all(x) (x).begin(),(x).end()\nusing namespace std;\nconst int INF=1145141919,MOD=1e9+7;\nconst long long LINF=8931145141919364364,LMOD=998244353;\ninline long long mod(long long n,long long m){return(n%m+m)%m;}\n// const int dx[]={1,0,-1,0,1,1,-1,-1},dy[]={0,-1,0,1,1,-1,-1,1};\n\ntemplate<class T>\nstruct Parser{\n    typedef string::const_iterator itr;\n    itr begin;\n    vector<bool> TF;\n    T ans;\n    Parser(const string &s,const vector<bool> &TF):TF(TF){\n        begin=s.begin();\n        ans=expr(begin);\n    }\n    T expr(itr &begin){\n        if(*begin=='-'){\n            consume(begin,'-');\n            return !expr(begin);\n        }\n        else if(*begin=='('){\n            consume(begin,'(');\n            T ret=expr(begin);\n            if(*begin=='*'){\n                consume(begin,'*');\n                ret&=expr(begin);\n            }\n            if(*begin=='+'){\n                consume(begin,'+');\n                ret|=expr(begin);\n            }\n            if(*begin=='-'&&*(begin+1)=='>'){\n                consume(begin,'-');\n                consume(begin,'>');\n                ret=(!ret|expr(begin));\n            }\n            consume(begin,')');\n            return ret;\n        }else{\n            char tmp=*begin;\n            begin++;\n            if(tmp=='T') return true;\n            if(tmp=='F') return false;\n            else return TF[tmp-'a'];\n        }\n    }\n    void consume(itr &begin,char expected){\n        if(*begin==expected){\n            begin++;\n        }else{\n            fprintf(stderr,\"Expected: '%c' Got: '%c'\\n\",expected,*begin);\n            fprintf(stderr,\"Rest string is \");\n            while(*begin){\n                fprintf(stderr,\"%c\",*begin++);\n            }\n        }\n    }\n};\n\nint main(){\n    string s;\n    while(cin>>s&&s!=\"#\"){\n        string s1,s2;\n        for(int i=0;;i++){\n            if(s[i]=='='){\n                s1=s.substr(0,i);\n                s2=s.substr(i+1);\n                break;\n            }\n        }\n        bool flg=1;\n        for(int i=0;i<(1<<11);i++){\n            vector<bool> TF(11);\n            for(int j=0;j<11;j++){\n                TF[j]=(i>>j);\n            }\n            Parser<bool> p1(s1,TF);\n            Parser<bool> p2(s2,TF);\n            if(p1.ans!=p2.ans){\n                cout<<\"NO\"<<endl;\n                flg=0;\n                break;\n            }\n        }\n        if(flg) cout<<\"YES\"<<endl;\n    }\n    return 0;\n}\n\n"
  },
  {
    "language": "C++",
    "code": "#include<iostream>\n#include<string>\n#include<vector>\n#define MAX 11\nusing namespace std;\nbool o;\nvoid rec(string s){\n  if(!o) return;\n  //cout << s << endl;\n  while(1){\n    //cout << s << endl;\n    bool f=false;\n    int p;\n    for(p=0;p<s.size();p++){\n      if(s[p]==' ') continue;\n      if(s[p]=='-'){\n\t\n\tif(s[p+1]=='0'){\n\t  s[p]='1';\n\t  s[p+1]=' ';\n\t  f=true;\n\t}\n\t\n\tif(s[p+1]=='1'){\n\t  s[p]='0';\n\t  s[p+1]=' ';\n\t  f=true;\n\t}\n\tcontinue;\n      }\n      if(s[p]=='('){\n\tif(s[p+1]!='0'&&s[p+1]!='1') continue;\n\tif(s[p+4]==')'){\n\t  if(s[p+2]=='+'){\n\t    if(s[p+1]=='0'&&s[p+3]=='0'){\n\t      s[p]='0';s[p+1]=' ';s[p+2]=' ';s[p+3]=' ';s[p+4]=' ';\n\t    }\n\t    if(s[p+1]=='1'&&s[p+3]=='0'){\n\t      s[p]='1';s[p+1]=' ';s[p+2]=' ';s[p+3]=' ';s[p+4]=' ';\n\t    }\n\t    if(s[p+1]=='0'&&s[p+3]=='1'){\n\t      s[p]='1';s[p+1]=' ';s[p+2]=' ';s[p+3]=' ';s[p+4]=' ';\n\t    }\n\t    if(s[p+1]=='1'&&s[p+3]=='1'){\n\t      s[p]='1';s[p+1]=' ';s[p+2]=' ';s[p+3]=' ';s[p+4]=' ';\n\t    }\n\t  }\n\t  if(s[p+2]=='*'){\n\t    if(s[p+1]=='0'&&s[p+3]=='0'){\n\t      s[p]='0';s[p+1]=' ';s[p+2]=' ';s[p+3]=' ';s[p+4]=' ';\n\t    }\n\t    if(s[p+1]=='1'&&s[p+3]=='0'){\n\t      s[p]='0';s[p+1]=' ';s[p+2]=' ';s[p+3]=' ';s[p+4]=' ';\n\t    }\n\t    if(s[p+1]=='0'&&s[p+3]=='1'){\n\t      s[p]='0';s[p+1]=' ';s[p+2]=' ';s[p+3]=' ';s[p+4]=' ';\n\t    }\n\t    if(s[p+1]=='1'&&s[p+3]=='1'){\n\t      s[p]='1';s[p+1]=' ';s[p+2]=' ';s[p+3]=' ';s[p+4]=' ';\n\t    }\n\t  }\n\t  f=true;\n\t}else if(s[p+5]==')'&&s[p+2]=='-'&&s[p+3]=='>'){\n\t  if(s[p+1]=='0'&&s[p+4]=='0'){\n\t    s[p]='1';s[p+1]=' ';s[p+2]=' ';s[p+3]=' ';s[p+4]=' ';s[p+5]=' ';\n\t  }\n\t  if(s[p+1]=='1'&&s[p+4]=='0'){\n\t    s[p]='0';s[p+1]=' ';s[p+2]=' ';s[p+3]=' ';s[p+4]=' ';s[p+5]=' ';\n\t  }\n\t  if(s[p+1]=='0'&&s[p+4]=='1'){\n\t    s[p]='1';s[p+1]=' ';s[p+2]=' ';s[p+3]=' ';s[p+4]=' ';s[p+5]=' ';\n\t  }\n\t  if(s[p+1]=='1'&&s[p+4]=='1'){\n\t    s[p]='1';s[p+1]=' ';s[p+2]=' ';s[p+3]=' ';s[p+4]=' ';s[p+5]=' ';\n\t  }\n\t  f=true;\n\t}\n      }\n    }\n    if(f){\n      string b;\n      for(int i=0;i<s.size();i++) if(s[i]!=' ') b+=s[i];\n      s=b;\n    }else{\n      if(s[0]!=s[2]) o=false;\n      return;\n    }\n  }\n}\nbool fi;\nvector<int> v[11];\nvoid init(int n,string s){\n  int i,j;\n  if(fi){\n    for(j=0;j<MAX;j++) v[j].clear();\n    for(i=0;i<s.size();i++){\n      for(j=0;j<MAX;j++){\n\tif(s[i]=='a'+j) {\n\t  s[i]='0'+(n>>j&1);\n\t  v[j].push_back(i);\n\t}\n      }\n    }\n    fi=false;\n  }else{\n    for(i=0;i<MAX;i++){\n      for(j=0;j<v[i].size();j++){\n\ts[v[i][j]]='0'+(n>>i&1);\n      }\n    }\n  }\n  //cout << s << endl;\n  //rec(s);\n  if(!o) return;\n}\nint main(){\n  string s;\n  while(cin >> s,s!=\"#\"){\n    o=true;\n    int i;\n    fi=true;\n    for(i=0;i<s.size();i++){\n      if(s[i]=='T') s[i]='1';\n      if(s[i]=='F') s[i]='0';\n    }\n    for(i=0;i<(1<<MAX);i++)\n      if(o) init(i,s);\n      else break;\n    cout << (o?\"YES\":\"NO\") << endl;\n  }\n  return 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\nusing namespace std;\n\nint pos, var;\nstring s;\nint formula() {\n  pos++;\n  if(s==\"T\") return 1;\n  if(s==\"F\") return 0;\n  if(isalpha(s[pos])) return var>>(s[pos]-'a') & 1;\n  if(s[pos]=='-') return !formula();\n  int f1=formula();\n  pos++; char op=s[pos]; if(op=='-') pos++;\n  int f2=formula(); pos++;\n  if(op=='+') return f1||f2;\n  if(op=='*') return f1&&f2;\n  if(op=='-') return f1<=f2;\n}\n\nint main() {\n  while(cin >> s) {\n    if(s==\"#\") break;\n    bool ok=true;\n    for(var=0;var<(1<<11);var++) {\n      pos=-1; int lhs=formula();\n      pos++;\n      if(lhs!=formula()) { ok=false; break; }\n    }\n    cout << (ok ? \"YES\":\"NO\") << endl;\n  }\n  return 0;\n}"
  },
  {
    "language": "C++",
    "code": "//23\n#include<iostream>\n#include<string>\n#include<algorithm>\n#include<cctype>\n\nusing namespace std;\n\nstring s,c;\nint tf;\nint p;\n\nbool form(){\n  if(isupper(s[p])){\n    return s[p++]=='T';\n  }else if(islower(s[p])){\n    return tf>>c.find(s[p++],0)&1;\n  }else if(s[p]=='-'){\n    p++;\n    return !form();\n  }else{\n    p++;\n    bool a=form();\n    char o=s[p];\n    p+=1+(o=='-');\n    bool b=form();\n    p++;\n    if(o=='*'){\n      return a&b;\n    }else if(o=='+'){\n      return a|b;\n    }else{\n      return !a|b;\n    }\n  }\n}\n\nbool equ(){\n  bool a=form();\n  p++;\n  bool b=form();\n  return a==b;\n}\n\nint main(){\n  while(getline(cin,s),s!=\"#\"){\n    s+='=';\n    c.clear();\n    for(int i=0;i<s.size();i++){\n      if(islower(s[i])){\n\tc+=s[i];\n      }\n    }\n    sort(c.begin(),c.end());\n    c.erase(unique(c.begin(),c.end()),c.end());\n    for(tf=0;tf<1<<c.size();tf++){\n      p=0;\n      if(!equ())break;\n    }\n    cout<<((tf<1<<c.size())?\"NO\":\"YES\")<<endl;\n  }\n  return 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include<iostream>\n#include<string>\nusing namespace std;\n\nint not(int a){\n\tif(a==1) return 0;\n\treturn 1;\n}\n\nint and(int a,int b){\n\tif(a==1 && b==1) return 1;\n\treturn 0;\n}\n\nint or(int a,int b){\n\tif(a==0 && b==0) return 0;\n\treturn 1;\n}\n\nint naraba(int a,int b){\n\tif(a==0 || (a==1 && b==1)) return 1;\n\treturn 0;\n}\n\nstring s;\nint bit=0;\nint p=0;\n\nint to_int(char a){\n\tif(a=='T') return 1;\n\tif(a=='F') return 0;\n\tint k=a-'a';\n\tif(bit & (1<<k)) return 1;\n\treturn 0;\n}\n\n\nint calc(){\n\tif(isalpha(s[p])) return to_int(s[p++]);\n\tif(s[p]=='-'){\n\t\tp++;\n\t\treturn not(calc());\n\t}\n\tif(s[p]=='('){\n\t\tp++;\n\t\tint res1=calc();\n\t\tif(s[p]=='*'){\n\t\t\tp++;\n\t\t\tint res2=calc();\n\t\t\tp++;\n\t\t\treturn and(res1,res2);\n\t\t}\n\t\telse if(s[p]=='+'){\n\t\t\tp++;\n\t\t\tint res2=calc();\n\t\t\tp++;\n\t\t\treturn or(res1,res2);\n\t\t}\n\t\telse if(s[p]=='-'){\n\t\t\tp+=2; //>を読み飛ばす\n\t\t\tint res2=calc();\n\t\t\tp++;\n\t\t\treturn naraba(res1,res2);\n\t\t}\n\t}\n\tcout<<\"Error \"<<s[p]<<endl;\n\treturn -1;\n}\n\n\nint main()\n{\n\twhile(cin>>s && s[0]!='#'){\n\n\t\tbool ok=true;\n\t\tfor(bit=0;bit<(1<8);bit++){\n\t\t\tp=0;\n\t\t\tint ans1=calc();\n\t\t\tp++;\n\t\t\tint ans2=calc();\n\t\t\tif(ans1!=ans2){ok=false;break;}\n\t\t}\n\t\tif(ok) cout<<\"YES\"<<endl;\n\t\telse cout<<\"NO\"<<endl;\n\t}\n\treturn 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include <iostream>\n#include <string>\nusing namespace std;\n\nstring S;\nint b;\n\nbool equa(int& p);\nbool form(int& p);\n\n\nbool equa(int& p) {\n    bool b1 = form(p);\n    p++;\n    bool b2 = form(p);\n    return b1 == b2;\n}\n\nbool form(int& p) {\n    if(S[p] == '-' && S[p+1] != '>') {\n        p++;\n        return not form(p);\n    } else if(S[p] == 'T') {\n        p++;\n        return true;\n    } else if(S[p] == 'F') {\n        p++;\n        return false;\n    } else if('a' <= S[p] && S[p] <= 'k') {\n        return (b >> (S[p++]-'a')) & 1;\n    } else if(S[p] == '(') {\n        p++;\n        bool v1 = form(p);\n        if(S[p] == '*') {\n            p++;\n            v1 &= form(p);\n        } else if(S[p] == '+') {\n            p++;\n            v1 |= form(p);\n        } else if(S[p] == '-' && S[p+1] == '>') {\n            p += 2;\n            bool v2 = form(p);\n            v1 = !v1 || v1 && v2;\n        }\n        p++;\n        return v1;\n    }\n}\n\nint main() {\n    while(cin >> S, S != \"#\") {\n        bool f = true;\n        for(int i=0; i<1<<11; ++i) {\n            int p = 0;\n            b = i;\n            f &= equa(p);\n        }\n        cout << (f ? \"YES\" : \"NO\") << endl;\n    }\n}\n"
  },
  {
    "language": "C++",
    "code": "#include <list>\n#include <vector>\n#include <map>\n#include <set>\n#include <stack>\n#include <queue>\n#include <deque>\n#include <algorithm>\n#include <utility>\n#include <functional>\n#include <sstream>\n#include <iostream>\n#include <cstdio>\n#include <cmath>\n#include <cstdlib>\n#include <cctype>\n#include <string>\n#include <cstring>\n#include <ctime>\n#include <climits>\nusing namespace std;\ninline int toInt(string s) { int v; istringstream sin(s); sin >> v; return v;}\ntemplate<class T> inline string toString(T x) { ostringstream sout; sout << x; return sout.str();}\ntypedef vector<int> vi;\ntypedef vector<vi>  vvi;\ntypedef vector<string> vs;\ntypedef pair<int, int> pii;\ntypedef long long ll;\n#define ALL(a) (a).begin(),(a).end()\n#define RALL(a) (a).rbegin(),(a).rend()\n#define EACH(t,i,c) for(t::iretator i=(c).begin(); i!=(c).end(); ++i)\n#define EXIST(s,e) ((s).find(e)!=(s).end())\n#define FOR(i,a,b) for(int i=(a);i<=(b);++i)\n#define REP(i,n) FOR(i,0,(n)-1)\nconst double EPS = 1e-12;\nconst double PI = acos(-1.0);\n\nint pos;\n\nbool parse(string s) {\n\tswitch(s[pos]) {\n\tcase 'T':\n\t\t++pos;\n\t\treturn true;\n\tcase 'F':\n\t\t++pos;\n\t\treturn false;\n\tcase '-':\n\t\t++pos;\n\t\treturn !parse(s);\n\tcase '(':\n\t\t++pos;\n\t\tbool a = parse(s);\n\t\tchar op = s[pos];\n\t\t++pos;\n\t\tif(op == '=')\n\t\t\t++pos;\n\t\tbool b = parse(s);\n\t\tswitch (op) {\n\t\tcase '*':\n\t\t\treturn a&&b;\n\t\tcase '+':\n\t\t\treturn a||b;\n\t\tcase '-':\n\t\t\treturn !a||b;\n\t\t}\n\t}\n}\n\nint main() {\n\tstring s;\n\twhile(cin >> s, s != \"#\") {\n\t\tset<char> cha;\n\t\tREP(i, s.size()) {\n\t\t\tif(islower(s[i]))\n\t\t\t\tcha.insert(s[i]);\n\t\t}\n\t\tint size = cha.size();\n\n\t\tmap<int, char> m;\n\t\tint count = 0;\n\t\tset<char>::iterator it = cha.begin();\n\t\twhile(it != cha.end()) {\n\t\t\tm[count] = *it;\n\t\t\t++count;\n\t\t\t++it;\n\t\t}\n\n\t\tREP(i, 1<<size) {\n\t\t\tREP(j, size) {\n\t\t\t\tif(i&(1<<j)) {\n\t\t\t\t\tREP(k, s.size()) {\n\t\t\t\t\t\tif(s[k] == m[j]) {\n\t\t\t\t\t\t\ts[k] = 'T';\n\t\t\t\t\t\t}\n\t\t\t\t\t}\n\t\t\t\t} else {\n\t\t\t\t\tREP(k, s.size()) {\n\t\t\t\t\t\tif(s[k] == m[j]) {\n\t\t\t\t\t\t\ts[k] = 'F';\n\t\t\t\t\t\t}\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t}\n\t\t\t\t\t\n\t\t\tstring left = s.substr(0, s.find(\"=\"));\n\t\t\tstring right = s.substr(s.find(\"=\")+1, s.size()-1);\n\t\t\t\n\t\t\tpos = 0;\n\t\t\tbool l = parse(right);\n\t\t\tpos = 0;\n\t\t\tbool r = parse(left);\n\t\t\tif(l != r) {\n\t\t\t\tcout << \"NO\" << endl;\n\t\t\t\tgoto next;\n\t\t\t}\n\t\t}\n\n\t\tcout << \"YES\" << endl;\nnext:\n\t\t;\n\t}\n\n\treturn 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include<bits/stdc++.h>\n#define rep(i,n)for(int i=0;i<(n);i++)\nusing namespace std;\n\nint equ(string&, int&);\nint form(string&, int&);\nint q(string&, int&);\n\nint equ(string&s, int&i) {\n\tint v1 = form(s, i); i++;\n\tint v2 = form(s, i);\n\tcout << v1 << \"==\" << v2 << endl;\n\treturn v1 == v2;\n}\nint form(string&s, int&i) {\n\tint v = q(s, i);\n\twhile (s[i] == '-' || s[i] == '>' || s[i] == '*' || s[i] == '+') {\n\t\tchar op = s[i++];\n\t\tint v2 = q(s, i);\n\t\tif (op == '>')v = (!v || v2);\n\t\tif (op == '*')v = (v&&v2);\n\t\tif (op == '+')v = (v || v2);\n\t}\n\treturn v;\n}\nint q(string&s, int&i) {\n\tif (s[i] == 'T' || s[i] == 'F')return s[i++] == 'T';\n\tif (s[i] == '-') {\n\t\ti++; int ret = !q(s, i);\n\t\treturn ret;\n\t}\n\ti++; int ret = form(s, i); i++;\n\treturn ret;\n}\nint main() {\n\tstring buf;\n\twhile (cin >> buf, buf != \"#\") {\n\t\tstring s;\n\t\trep(i, buf.size()) {\n\t\t\tif (buf[i] == '-'&&buf[i + 1] == '>')s += '>', i++;\n\t\t\telse s += buf[i];\n\t\t}\n\t\tmap<char, int>mp;\n\t\tfor (char c : s) {\n\t\t\tif (isalpha(c))mp[c];\n\t\t}\n\t\trep(i, 1 << mp.size()) {\n\t\t\tstring t = s;\n\t\t\tint j = 0;\n\t\t\tfor (auto&p : mp)p.second = ((i >> (j++) & 1) ? 'T' : 'F');\n\t\t\tfor (char&c : t) {\n\t\t\t\tif (isalpha(c))c = mp[c];\n\t\t\t}\n\t\t\tj = 0;\n\t\t\tif (!equ(t, j)) { puts(\"NO\"); goto g; }\n\t\t}\n\t\tputs(\"YES\");\n\tg:;\n\t}\n}"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\n\nusing namespace std;\n\ntypedef string::const_iterator State;\nclass ParseError {};\n\nmap<char, int> mp, mp2;\nState b;\n\nint f(int a, int b) {\n\tif(a == 0) return 1;\n\tif(b == 1) return 1;\n\treturn 0;\n}\n\nint ch(State& begin) {\n\tif(!islower(*begin) && !isupper(*begin)) {cout << *begin; assert(false);}\n\tint ret;\n\tif(*begin == 'T') ret = 1;\n\tif(*begin == 'F') ret = 0;\n\tret = mp2[*begin];\n\tbegin++;\n\treturn ret;\n}\n\nint fomula(State& begin) {\n\t//cout << *begin << endl;\n\tif(islower(*begin) || isupper(*begin)) {return ch(begin);}\n\telse if(*begin == '-') {begin++; return !fomula(begin);}\n\telse if(*begin == '(') {\n\t\tbegin++;\n\t\tint ret1 = fomula(begin);\n\t\tchar op = *begin;\n\t\tbegin++;\n\t\tint ret2 = fomula(begin);\n\t\tbegin++;\n\t\tint ret;\n\t\tif(op == '*') {\n\t\t\tret = ret1&ret2;\n\t\t} else if(op == '+') {\n\t\t\tret = ret1|ret2;\n\t\t} else if(op == '>') {\n\t\t\tret = f(ret1, ret2);\n\t\t} \n\t\treturn ret;\n\t}\n}\n\nint equation(State& begin) {\n\tint ret = fomula(begin), ret2;\n\tif(*begin == '=') begin++, ret2 = fomula(begin);\n\t//cout << \"ret:\" << ret << \" ret2:\" << ret2 << endl;\n\tif(ret == ret2) return 1;\n\treturn 0;\n}\n\nint a[20];\nint main() {\n\twhile(true) {\n\t\tstring t;\n\t\tcin >> t;\n\t\tif(t == \"#\") break;\n\t\tstring s;\n\t\tfor(int i=0; i<t.size(); ++i) {\n\t\t\tif(t[i] != '>') s += t[i];\n\t\t\telse s[s.size()-1] = '>';\n\t\t}\n\t\tint idx = 0;\n\t\tfor(int i=0; i<s.size(); ++i) {\n\t\t\tif(islower(s[i]) && mp.find(s[i]) == mp.end()) {\n\t\t\t\tmp[s[i]] = idx;\n\t\t\t\ta[idx++] = s[i];\n\t\t\t}\n\t\t}\n\t\t/*for(auto i: mp) {\n\t\t\tcout << i.first << \" \" << i.second << endl;\n\t\t}*/\n\t\t\n\t\tbool flag = true;\n\t\tfor(int i=0; i<(1<<idx); ++i) {\n\t\t\t//cout << \"i:\" << i << endl;\n\t\t\tfor(int j=0; j<idx; ++j) {\n\t\t\t\tif(i >> j & 1) mp2[a[j]] = 1;\n\t\t\t\telse mp2[a[j]] = 0;\n\t\t\t}\n\t\t\t//for(auto j: mp2) cout << j.first << \" \" << j.second << endl;\n\t\t\tState begin = s.begin();\n\t\t\tb = s.begin();\n\t\t\tif(!equation(begin)) flag = false;\n\t\t\t//cout << flag << endl;\n\t\t}\n\t\tif(flag) cout << \"YES\" << endl;\n\t\telse cout << \"NO\" << endl;\n\t}\n\t\n\treturn 0;\n}"
  },
  {
    "language": "C++",
    "code": "/*\n *\n * <equation> ::= <formula> \"=\" <formula>\n * <formula>  ::= \"T\" | \"F\" |\n * \"a\" | \"b\" | \"c\" | \"d\" | \"e\" | \"f\" |\n * \"g\" | \"h\" | \"i\" | \"j\" | \"k\" |\n * \"-\" <formula> |\n * \"(\" <formula> \"*\" <formula> \")\" |\n * \"(\" <formula> \"+\" <formula> \")\" |\n * \"(\" <formula> \"->\" <formula> \")\"\n */\n#include<iostream>\n#include<map>\n#include<vector>\n#include<algorithm>\n#include<cmath>\n#include<iomanip>\n#include<numeric>\n#include<climits>\n#include<ctime>\n#include<cstring>\n#include<sstream>\n#define REP(i,p,n) for(int i=p;i<(int)(n);i++)\n#define rep(i,n) REP(i,0,n)\n#define rep_split(tok,a_str,re) for(char *tok = strtok((char *)a_str.c_str(),re); tok != NULL; tok = strtok(NULL,re))\n#define ALL(c) (c).begin(), (c).end()\n#define dump(a) cerr << #a << \"=\" << (a) << endl\n#define DUMP(list) cout << \"{ \"; for(auto nth : list){ cout << nth << \" \"; } cout << \"}\" << endl;\ntemplate<class T> void chmin(T &t, T f) { if (t > f) t = f; } //t=min\ntemplate<class T> void chmax(T &t, T f) { if (t < f) t = f; } //t=max\nusing namespace std;\n\n\nvector<bool> var_pattern;\nbool equation(string& s, int& i);\nbool formula(string& s, int& i);\n\n\nbool equation(string& s, int& i)\n{\n\tbool left = formula(s,i);\n\t//cout << \"左辺 \" << left << endl;\n\ti++; // =\n\tbool right = formula(s,i);\n\t//cout << \"右辺 \" << right << endl;\n\n\t//cout << left << \"=\" << right << endl;\n\n\treturn left == right;\n}\n\n\nbool formula(string& s, int& i)\n{\n\tbool left=false,right=false;\t\n\tchar ope=0;\n\tbool ans = false;\n\n\tswitch(s[i])\n\t{\n\t\tcase 'T':\n\t\t\tans = true;\n\t\t\tbreak;\n\t\tcase 'F':\n\t\t\tans = false;\n\t\t\tbreak;\n\t\tcase '-':\n\t\t\ti++;\n\t\t\treturn !formula(s,i);\n\t\tcase '(':\n\t\t\ti++;\n\t\t\tleft = formula(s,i);\n\t\t\ti++; \n\t\t\tope = s[i];\n\t\t\tif (ope == '-') { i++; ope='>'; } //->\n\t\t\ti++;\n\t\t\tright = formula(s,i);\n\n\t\t\tif (ope == '*') {\n\t\t\t\tans = left * right;\t\n\t\t\t}\n\t\t\telse if (ope == '+') {\n\t\t\t\tans = left + right;\t\n\t\t\t}\n\t\t\telse if (ope == '>') {\n\t\t\t\tans = (!left) + right;\n\t\t\t}\n\t\t\ti++; //')'\n\t\t\ti++; //=\n\t\t\tbreak;\n\n\t\tdefault:\n\t\t\tif ('a' <= s[i] && s[i] <= 'k') {\n\t\t\t\tint var_num = (int)(s[i] - 'a');\n\t\t\t\tans = var_pattern[var_num];\n\t\t\t}\n\t\t\t//cout << \"index=\" << var_num << \" var=\" << s[i] << endl;\n\t\t\t//cout << s[i] << \" = \" << var_pattern[var_num] << endl;\n\t\t\tbreak;\n\t}\n\n\treturn ans;\n}\n\n\n\nint main() {\n\tstring line;\n\t\n\twhile(cin >> line)\n\t{\n\t\tif (line[0] == '#') break;\n\t\tint i=0;\n\n\t\tbool is_yes = true;\n\t\trep(j,20) {\n\t\t\tint num = j;\n\t\t\trep(k,11)\n\t\t\t{\n\t\t\t\tvar_pattern.push_back((num & 1));\n\t\t\t\t//cout << (num & 1) << \" \";\n\t\t\t\tnum >>= 1;\n\t\t\t}\n\t\t\t//cout << endl;\n\t\t\tif (!equation(line,i)) { is_yes = false; break; }\n\t\t\tvar_pattern.clear();\n\t\t}\n\t\tcout << (is_yes ? \"YES\" : \"NO\") << endl;\n\t\t//cout << \"-----------\" << endl;\n\t}\n\n\treturn 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include<iostream>\n#include<string>\nusing namespace std;\ntypedef string::const_iterator State;\nbool equation(State&);\nbool formula(State&);\nbool oper(State&);\nbool consume(State& begin,char c){\n  if(*begin != c){\n    cout << \"need:\" << c << \" comes:\" << *begin << endl;\n    return false;\n  }\n  begin++;\n  return true;\n}\n\nint var;\n\nbool equation(State& start){\n  bool left,right;\n  State begin;\n  for(var = 0;var < 1 << 11;var++){\n    begin = start;\n    left = formula(begin);\n    consume(begin,'=');\n    right = formula(begin);\n    if(left != right)return false;\n  }\n  return true;\n}\nbool formula(State& begin){\n  char cur = *begin;\n  begin++;\n  if(cur == 'T')return true;\n  if(cur == 'F')return false;\n  if(cur >= 'a' && 'k' >= cur)return (bool)(var|1 << (cur-'a'));\n  if(cur == '-')return !formula(begin);\n  if(cur == '('){\n    bool ret = oper(begin);\n    consume(begin,')');\n    return ret;\n  }\n}\nbool oper(State& begin){\n  bool left = formula(begin);\n  char cur = *begin;\n  begin++;\n  if(cur == '-')consume(begin,'>');\n  bool right = formula(begin);\n  if(cur == '+'){\n    return right+left;\n  }else if(cur == '*'){\n    return right*left;\n  }else if(cur == '-'){\n    return !left+right;\n  }\n  cout << \"error\" << endl;\n}\nint main(){\n  cin.sync_with_stdio(false);\n  string eq;\n  while(getline(cin,eq) && eq != \"#\"){\n    State begin = eq.begin();\n    cout << (equation(begin) ? \"YES\" : \"NO\") <<endl;\n  }\n  return 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include<iostream>\n#include<vector>\n#include<string>\n#include<algorithm>\nusing namespace std;\n\n#define MAX_NUM 2\n#define MAX_CH 10\n#define MAX_N 1200\n\nstring S, T;\nchar NUM[MAX_NUM + 1] = \"01\";\nchar CH[MAX_CH + 1] = \"abcdefghij\";\nint TR[MAX_CH];\n\nint calc(string Y) {\n\treturn true;\n}\n\nint power(int a, int b) {\n\tint res2 = 1;\n\tfor (int i = 0; i < b; i++) {\n\t\tres2 *= a;\n\t}\n\treturn res2;\n}\n\nbool solve(string U) {\n\tbool RES = true;\n\tstring V = \"\";\n\tstring V1 = \"\", V2 = \"\";\n\tstring W1 = \"\", W2 = \"\";\n\n\tfor (int i = 0; i < U.size(); i++) {\n\t\tif (U[i] == 'T') {\n\t\t\tV += '1';\n\t\t\tgoto E;\n\t\t}\n\t\telse if (U[i] == '>') {\n\t\t\t//nanimo shinai.\n\t\t}\n\t\telse if (U[i] == 'F') {\n\t\t\tV += '0';\n\t\t\tgoto E;\n\t\t}\n\t\telse if (i < U.size() - 1) {\n\t\t\tif (U.substr(i, 2) == \"->\") {\n\t\t\t\tV += '&';\n\t\t\t\tgoto E;\n\t\t\t}\n\t\t}\n\t\telse {\n\t\t\tV += U[i];\n\t\t}\n\tE:;\n\t}\n\n\tint cnt1 = 0;\n\tfor (int i = 0; i < V.size(); i++) {\n\t\tif (V[i] == '=') {\n\t\t\tcnt1 = 1;\n\t\t}\n\t\telse if (cnt1 == 0) {\n\t\t\tV1 += V[i];\n\t\t}\n\t\telse if (cnt1 == 1) {\n\t\t\tV2 += V[i];\n\t\t}\n\t}\n\n\tint pass1 = 0;\n\twhile (pass1 < V1.size()) {\n\t\tif (V1[pass1] == '-') {\n\t\t\tint cnt2 = 0;\n\t\t\twhile (V1[pass1] == '-') {\n\t\t\t\tcnt2++;\n\t\t\t\tpass1++;\n\t\t\t}\n\t\t\tif (cnt2 % 2 == 1) {\n\t\t\t\tW1 += '(';\n\t\t\t\tW1 += '-';\n\t\t\t\tW1 += V1[pass1];\n\t\t\t\tW1 += ')';\n\t\t\t}\n\t\t\telse {\n\t\t\t\tW1 += V1[pass1];\n\t\t\t}\n\t\t\tpass1++;\n\t\t}\n\t\tif (pass1 < V1.size()) {\n\t\t\tW1 += V1[pass1];\n\t\t\tpass1++;\n\t\t}\n\t}\n\n\tpass1 = 0;\n\twhile (pass1 < V2.size()) {\n\t\tif (V2[pass1] == '-') {\n\t\t\tint cnt2 = 0;\n\t\t\twhile (V2[pass1] == '-') {\n\t\t\t\tcnt2++;\n\t\t\t\tpass1++;\n\t\t\t}\n\t\t\tif (cnt2 % 2 == 1) {\n\t\t\t\tW2 += '(';\n\t\t\t\tW2 += '-';\n\t\t\t\tW2 += V2[pass1];\n\t\t\t\tW2 += ')';\n\t\t\t}\n\t\t\telse {\n\t\t\t\tW2 += V2[pass1];\n\t\t\t}\n\t\t\tpass1++;\n\t\t}\n\t\tif (pass1 < V2.size()) {\n\t\t\tW2 += V2[pass1];\n\t\t\tpass1++;\n\t\t}\n\t}\n\n\tstring X1 = \"\", X2 = \"\";\n\n\tfor (int i = 0; i < power(2, MAX_NUM); i++) {\n\t\tX1 = \"\"; X2 = \"\";\n\t\tfor (int j = 0; j < MAX_NUM; j++) {\n\t\t\tint a1 = (i / power(2, j)) % 2;\n\t\t\tTR[j] = a1;\n\t\t}\n\n\t\tfor (int j = 0; j < V1.size(); j++) {\n\t\t\tfor (int k = 0; k < MAX_NUM; k++) {\n\t\t\t\tif (W1[j] == CH[k]) {\n\t\t\t\t\tX1 += NUM[TR[j]];\n\t\t\t\t\tgoto F;\n\t\t\t\t}\n\t\t\t}\n\t\t\tX1 += W1[j];\n\t\tF:;\n\t\t}\n\n\t\tfor (int j = 0; j < V2.size(); j++) {\n\t\t\tfor (int k = 0; k < MAX_NUM; k++) {\n\t\t\t\tif (W2[j] == CH[k]) {\n\t\t\t\t\tX2 += NUM[TR[j]];\n\t\t\t\t\tgoto G;\n\t\t\t\t}\n\t\t\t}\n\t\t\tX2 += W1[j];\n\t\tG:;\n\t\t}\n\n\t\tint res_1 = calc(X1);\n\t\tint res_2 = calc(X2);\n\t\tif (res_1 != res_2) {\n\t\t\tRES = false;\n\t\t}\n\t}\n\treturn RES;\n}\n\nint main() {\n\twhile (true) {\n\t\tcin >> S;\n\t\tif (S == \"#\") {\n\t\t\tbreak;\n\t\t}\n\t\tbool res = solve(S);\n\t\tif (res == true) {\n\t\t\tcout << \"YES\" << endl;\n\t\t}\n\t\telse {\n\t\t\tcout << \"NO\" << endl;\n\t\t}\n\t}\n\treturn 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include <functional>\n#include <iostream>\n#include <string>\n#include <unordered_set>\n#include <vector>\n#define loop(i, a, n) for (int i = (a); i < (n); i++)\n#define rep(i, n) loop(i, 0, n)\ntemplate<typename A> using F = std::function<A>;\nusing namespace std;\n\ntemplate<typename T> struct ParseResult {\n  bool succeeded;\n  T object;\n  int pos;\n  ParseResult(const bool succeeded, const T &object, const int pos) : succeeded(succeeded), object(object), pos(pos) {}\n  friend std::ostream &operator<<(std::ostream &os, const ParseResult<T> &p) { return os << '{' << (p.succeeded ? \"true\" : \"false\") << ',' << p.object << ',' << p.pos << '}'; }\n};\n\ntemplate<typename T> using Parser = std::function<ParseResult<T>(std::string, int)>;\n\nParser<std::string> token(const std::string &s) {\n  const int n = s.size();\n  return [n = std::move(n), s = std::move(s)](const std::string &target, const int pos) {\n    if (target.size() < n) return ParseResult<std::string>(false, {}, pos);\n    return target.substr(pos, n) == s ? ParseResult<std::string>(true, s, pos + n) : ParseResult<std::string>(false, {}, pos);\n  };\n}\n\ntemplate<typename T> Parser<T> operator||(const Parser<T> &p1, const Parser<T> &p2) {\n  return [p1 = std::move(p1), p2 = std::move(p2)](const std::string &target, const int pos) {\n    auto r = p1(target, pos);\n    if (r.succeeded) return r;\n    r = p2(target, pos);\n    if (r.succeeded) return r;\n    return ParseResult<T>(false, {}, pos);\n  };\n}\n\ntemplate<typename T1, typename T2> Parser<std::pair<T1, T2>> operator+(const Parser<T1> &p1, const Parser<T2> &p2) {\n  return [p1 = std::move(p1), p2 = std::move(p2)](const std::string &target, const int pos) {\n    auto r1 = p1(target, pos);\n    if (!r1.succeeded) return ParseResult<std::pair<T1, T2>>(false, {}, pos);\n    auto r2 = p2(target, r1.pos);\n    if (!r2.succeeded) return ParseResult<std::pair<T1, T2>>(false, {}, pos);\n    return ParseResult<std::pair<T1, T2>>(true, {r1.object, r2.object}, r2.pos);\n  };\n}\n\ntemplate<typename T1, typename T2> Parser<T2> operator>>(const Parser<T1> &p1, const Parser<T2> &p2) {\n  return [p1 = std::move(p1), p2 = std::move(p2)](const std::string &target, const int pos) {\n    auto r1 = p1(target, pos);\n    if (!r1.succeeded) return ParseResult<T2>(false, {}, pos);\n    auto r2 = p2(target, r1.pos);\n    if (!r2.succeeded) return ParseResult<T2>(false, {}, pos);\n    return ParseResult<T2>(true, r2.object, r2.pos);\n  };\n}\n\ntemplate<typename T1, typename T2> Parser<T1> operator<<(const Parser<T1> &p1, const Parser<T2> &p2) {\n  return [p1 = std::move(p1), p2 = std::move(p2)](const std::string &target, const int pos) {\n    auto r1 = p1(target, pos);\n    if (!r1.succeeded) return ParseResult<T1>(false, {}, pos);\n    auto r2 = p2(target, r1.pos);\n    if (!r2.succeeded) return ParseResult<T1>(false, {}, pos);\n    return ParseResult<T1>(true, r1.object, r2.pos);\n  };\n}\n\nParser<char> oneOf(const std::string &s) {\n  std::unordered_set<char> d;\n  for (auto &c : s) d.insert(c);\n  return [d = std::move(d)](const std::string &target, const int pos) {\n    if (target.size() <= pos) return ParseResult<char>(false, {}, pos);\n    char c = target[pos];\n    return d.count(c) ? ParseResult<char>(true, c, pos + 1) : ParseResult<char>(false, {}, pos);\n  };\n}\n\ntemplate<typename T, typename S, typename F> Parser<S> fmap(const Parser<T> &p, const F &f) {\n  return [p = std::move(p), f = std::move(f)](const std::string &target, const int pos) {\n    auto r = p(target, pos);\n    return r.succeeded ? ParseResult<S>(true, f(r.object), r.pos) : ParseResult<S>(false, {}, r.pos);\n  };\n}\n\ntemplate<typename T, typename F> Parser<T> lazy(const F &f) {\n  bool instantiated = false;\n  Parser<T> p;\n  return [f = std::move(f), p = std::move(p), instantiated = std::move(instantiated)](const std::string &target, const int pos) mutable {\n    if (!instantiated) {\n      p = f();\n      instantiated = true;\n    }\n    return p(target, pos);\n  };\n}\n\nstruct SyntaxTree {\n  string op;\n  char value;\n  vector<SyntaxTree> children;\n  SyntaxTree() {}\n  SyntaxTree(const string &op, const char value, const vector<SyntaxTree> &children) : op(op), value(value), children(children) {}\n};\n\nint main() {\n  Parser<SyntaxTree> formulaP = lazy<SyntaxTree>([&]() {\n    auto andP = fmap<pair<SyntaxTree, SyntaxTree>, SyntaxTree>((token(\"(\") >> formulaP << token(\"*\")) + (formulaP << token(\")\")), [](auto &o) { return SyntaxTree(\"*\", {}, {o.first, o.second}); });\n    auto orP = fmap<pair<SyntaxTree, SyntaxTree>, SyntaxTree>((token(\"(\") >> formulaP << token(\"+\")) + (formulaP << token(\")\")), [](auto &o) { return SyntaxTree(\"+\", {}, {o.first, o.second}); });\n    auto impP = fmap<pair<SyntaxTree, SyntaxTree>, SyntaxTree>((token(\"(\") >> formulaP << token(\"->\")) + (formulaP << token(\")\")), [](auto &o) { return SyntaxTree(\"->\", {}, {o.first, o.second}); });\n    auto notP = fmap<SyntaxTree, SyntaxTree>(token(\"-\") >> formulaP, [](auto &o) { return SyntaxTree(\"-\", {}, {o}); });\n    auto valP = fmap<char, SyntaxTree>(oneOf(\"abcdefghijkTF\"), [](char x) { return SyntaxTree({}, x, {}); });\n    return andP || orP || impP || notP || valP;\n  });\n  auto equationP = (formulaP << token(\"=\")) + formulaP;\n  string s;\n  while (cin >> s, s != \"#\") {\n    auto r = equationP(s, 0);\n    /*\n    bool isValid = true;\n    rep(i, 1 << 11) {\n      auto toBool = [&](char c) -> bool {\n        if (c == 'T') return true;\n        if (c == 'F') return false;\n        return i >> (c - 'a') & 1;\n      };\n      F<bool(SyntaxTree)> evalF = [&](const SyntaxTree &f) {\n        switch (f.children.size()) {\n          case 0: return toBool(f.value);\n          case 1: return !evalF(f.children[0]);\n          case 2:\n            if (f.op == \"*\") return evalF(f.children[0]) && evalF(f.children[1]);\n            if (f.op == \"+\") return evalF(f.children[0]) || evalF(f.children[1]);\n            if (f.op == \"->\") return !evalF(f.children[0]) || evalF(f.children[1]);\n        }\n      };\n      isValid &= evalF(r.object.first) == evalF(r.object.second);\n    }\n    cout << (isValid ? \"YES\" : \"NO\") << endl;\n    */\n  }\n}"
  },
  {
    "language": "C++",
    "code": "#include<bits/stdc++.h>\nusing namespace std;\nint used[11];\n\nbool famula(string &s, int &i){\n  //std::cout << s[i];\n  if(s[i] == 'T'){\n    i++;\n    return true;\n  }else if(s[i] == 'F'){\n    i++;\n    return false;\n  }else if(s[i] == '-'){\n    i++;\n    return !famula(s, i);\n  }else if('a' <= s[i] && s[i] <= 'z'){\n    return used[s[i++] - 'a'];\n  }else{\n    i++;\n    bool a = famula(s, i);\n    char op = s[i++];\n    bool b = famula(s, i);\n    i++;\n    if(op == '*'){\n      return a & b;\n    }else if(op == '+'){\n      return a | b;      \n    }else if(op == '>'){\n      return (!a) | b;\n    }\n  }\n}\n\nbool equation(string &s, int &i){\n  bool val = famula(s, i), val2;\n  while(s[i] == '='){\n    i++;\n    val2 = famula(s, i);\n  }\n  return val == val2;\n}\n\nint main(int argc, char *argv[]){\n  string s;\n  while(cin >> s){\n    if(s == \"#\")break;\n    for (int i = 0; i < s.length(); i++) {\n      if(s[i] == '-' && s[i + 1] == '>')s.erase(s.begin() + i--);\n    }\n    int ans = true;\n    for (int i = 0; i < (1 << 12); i++) {\n      int pos = 0;\n      for (int j = 0; j < s.length(); j++) {\n        if('a' <= s[j] && s[j] <= 'z')\n          used[s[j] - 'a'] = i&(1 << (s[j] - 'a'));\n      }\n      if(equation(s, pos) == false){\n        ans = false;\n        std::cout << \"no\" << std::endl;\n        break;\n      }\n    }\n    if(ans)std::cout << \"yes\" << std::endl;\n  }\n  return 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include <functional>\n#include <iostream>\n#include <string>\n#include <unordered_set>\n#include <vector>\n#define loop(i, a, n) for (int i = (a); i < (n); i++)\n#define rep(i, n) loop(i, 0, n)\ntemplate<typename A> using F = std::function<A>;\nusing namespace std;\n\ntemplate<typename T> struct ParseResult {\n  bool succeeded;\n  T object;\n  int pos;\n  ParseResult(const bool succeeded, const T &object, const int pos) : succeeded(succeeded), object(object), pos(pos) {}\n  friend std::ostream &operator<<(std::ostream &os, const ParseResult<T> &p) { return os << '{' << (p.succeeded ? \"true\" : \"false\") << ',' << p.object << ',' << p.pos << '}'; }\n};\n\ntemplate<typename T> using Parser = std::function<ParseResult<T>(std::string, int)>;\n\nParser<std::string> token(const std::string &s) {\n  const int n = s.size();\n  return [n = std::move(n), s = std::move(s)](const std::string &target, const int pos) {\n    if (target.size() < n) return ParseResult<std::string>(false, {}, pos);\n    return target.substr(pos, n) == s ? ParseResult<std::string>(true, s, pos + n) : ParseResult<std::string>(false, {}, pos);\n  };\n}\n\ntemplate<typename T> Parser<T> operator||(const Parser<T> &p1, const Parser<T> &p2) {\n  return [p1 = std::move(p1), p2 = std::move(p2)](const std::string &target, const int pos) {\n    auto r = p1(target, pos);\n    if (r.succeeded) return r;\n    r = p2(target, pos);\n    if (r.succeeded) return r;\n    return ParseResult<T>(false, {}, pos);\n  };\n}\n\ntemplate<typename T1, typename T2> Parser<std::pair<T1, T2>> operator+(const Parser<T1> &p1, const Parser<T2> &p2) {\n  return [p1 = std::move(p1), p2 = std::move(p2)](const std::string &target, const int pos) {\n    auto r1 = p1(target, pos);\n    if (!r1.succeeded) return ParseResult<std::pair<T1, T2>>(false, {}, pos);\n    auto r2 = p2(target, r1.pos);\n    if (!r2.succeeded) return ParseResult<std::pair<T1, T2>>(false, {}, pos);\n    return ParseResult<std::pair<T1, T2>>(true, {r1.object, r2.object}, r2.pos);\n  };\n}\n\ntemplate<typename T1, typename T2> Parser<T2> operator>>(const Parser<T1> &p1, const Parser<T2> &p2) {\n  return [p1 = std::move(p1), p2 = std::move(p2)](const std::string &target, const int pos) {\n    auto r1 = p1(target, pos);\n    if (!r1.succeeded) return ParseResult<T2>(false, {}, pos);\n    auto r2 = p2(target, r1.pos);\n    if (!r2.succeeded) return ParseResult<T2>(false, {}, pos);\n    return ParseResult<T2>(true, r2.object, r2.pos);\n  };\n}\n\ntemplate<typename T1, typename T2> Parser<T1> operator<<(const Parser<T1> &p1, const Parser<T2> &p2) {\n  return [p1 = std::move(p1), p2 = std::move(p2)](const std::string &target, const int pos) {\n    auto r1 = p1(target, pos);\n    if (!r1.succeeded) return ParseResult<T1>(false, {}, pos);\n    auto r2 = p2(target, r1.pos);\n    if (!r2.succeeded) return ParseResult<T1>(false, {}, pos);\n    return ParseResult<T1>(true, r1.object, r2.pos);\n  };\n}\n\nParser<char> oneOf(const std::string &s) {\n  std::unordered_set<char> d;\n  for (auto &c : s) d.insert(c);\n  return [d = std::move(d)](const std::string &target, const int pos) {\n    if (target.size() <= pos) return ParseResult<char>(false, {}, pos);\n    char c = target[pos];\n    return d.count(c) ? ParseResult<char>(true, c, pos + 1) : ParseResult<char>(false, {}, pos);\n  };\n}\n\ntemplate<typename T, typename S, typename F> Parser<S> fmap(const Parser<T> &p, const F &f) {\n  return [p = std::move(p), f = std::move(f)](const std::string &target, const int pos) {\n    auto r = p(target, pos);\n    return r.succeeded ? ParseResult<S>(true, f(r.object), r.pos) : ParseResult<S>(false, {}, r.pos);\n  };\n}\n\ntemplate<typename T, typename F> Parser<T> lazy(const F &f) {\n  bool instantiated = false;\n  Parser<T> p;\n  return [f = std::move(f), p = std::move(p), instantiated = std::move(instantiated)](const std::string &target, const int pos) mutable {\n    if (!instantiated) {\n      p = f();\n      instantiated = true;\n    }\n    return p(target, pos);\n  };\n}\n\nstruct SyntaxTree {\n  string op;\n  char value;\n  vector<SyntaxTree> children;\n  SyntaxTree() {}\n  SyntaxTree(const string &op, const char value, const vector<SyntaxTree> &children) : op(op), value(value), children(children) {}\n};\n\nint main() {\n  Parser<SyntaxTree> formulaP = lazy<SyntaxTree>([&]() {\n    auto andP = fmap<pair<SyntaxTree, SyntaxTree>, SyntaxTree>((token(\"(\") >> formulaP << token(\"*\")) + (formulaP << token(\")\")), [](auto &o) { return SyntaxTree(\"*\", {}, {o.first, o.second}); });\n    auto orP = fmap<pair<SyntaxTree, SyntaxTree>, SyntaxTree>((token(\"(\") >> formulaP << token(\"+\")) + (formulaP << token(\")\")), [](auto &o) { return SyntaxTree(\"+\", {}, {o.first, o.second}); });\n    auto impP = fmap<pair<SyntaxTree, SyntaxTree>, SyntaxTree>((token(\"(\") >> formulaP << token(\"->\")) + (formulaP << token(\")\")), [](auto &o) { return SyntaxTree(\"->\", {}, {o.first, o.second}); });\n    auto notP = fmap<SyntaxTree, SyntaxTree>(token(\"-\") >> formulaP, [](auto &o) { return SyntaxTree(\"-\", {}, {o}); });\n    auto valP = fmap<char, SyntaxTree>(oneOf(\"abcdefghijkTF\"), [](char x) { return SyntaxTree({}, x, {}); });\n    return andP || orP || impP || notP || valP;\n  });\n  auto equationP = (formulaP << token(\"=\")) + formulaP;\n  string s;\n  while (cin >> s, s != \"#\") {\n    auto r = equationP(s, 0);\n    bool isValid = true;\n    rep(i, 1 << 11) {\n      auto toBool = [&](char c) -> bool {\n        if (c == 'T') return true;\n        if (c == 'F') return false;\n        return i >> (c - 'a') & 1;\n      };\n      F<bool(SyntaxTree)> evalF = [&](const SyntaxTree &f) {\n        switch (f.children.size()) {\n          case 0: return toBool(f.value);\n          case 1: return !evalF(f.children[0]);\n          case 2:\n            if (f.op == \"*\") return evalF(f.children[0]) && evalF(f.children[1]);\n            if (f.op == \"+\") return evalF(f.children[0]) || evalF(f.children[1]);\n            if (f.op == \"->\") return !evalF(f.children[0]) || evalF(f.children[1]);\n        }\n      };\n      isValid &= evalF(r.object.first) == evalF(r.object.second);\n    }\n    cout << (isValid ? \"YES\" : \"NO\") << endl;\n  }\n}"
  },
  {
    "language": "C++",
    "code": "#include <iostream>\n#include <string>\n#include <stack>\n\nusing namespace std;\n\nchar wa(char a, char b);\nchar seki(char a, char b);\nchar naraba(char a, char b);\nchar not(char a);\n\nbool kaiseki(string b) {\n\tstack<char> stk1;\n\tstack<char> stk2;\n\tchar aa, bb;\n\tfor (int i = 0; i < b.size(); i++) {\n\t\tif (b[i] == '=') {\n\t\t\taa = stk2.top();\n\t\t\tstk2.pop();\n\t\t} else {\n\t\t\tif (b[i] == '0' || b[i] == '1') {\n\t\t\t\twhile (!stk1.empty() && stk1.top() == '-') {\n\t\t\t\t\tstk1.pop();\n\t\t\t\t\tb[i] = not(b[i]);\n\t\t\t\t}\n\t\t\t\tstk2.push(b[i]);\n\t\t\t} else if (b[i] == '+' || b[i] == '*' || b[i] == '>' || b[i] == '(') {\n\t\t\t\tstk1.push(b[i]);\n\t\t\t} else if (b[i] == ')') {\n\t\t\t\tchar p = stk2.top();\n\t\t\t\tstk2.pop();\n\t\t\t\tchar q = stk2.top();\n\t\t\t\tstk2.pop();\n\t\t\t\tchar k = stk1.top();\n\t\t\t\tstk1.pop();\n\t\t\t\tif (k == '+') {\n\t\t\t\t\tp = wa(p, q);\n\t\t\t\t} else if (k == '*'){\n\t\t\t\t\tp = seki(p, q);\n\t\t\t\t} else if (k == '>') {\n\t\t\t\t\tp = naraba(q, p);\n\t\t\t\t} else {\n\t\t\t\t\tstk2.push(q);\n\t\t\t\t\tp = not(p);\n\t\t\t\t}\n\t\t\t\tstk1.pop();\n\t\t\t\twhile (!stk1.empty() && stk1.top() == '-') {\n\t\t\t\t\tstk1.pop();\n\t\t\t\t\tp = not(p);\n\t\t\t\t}\n\t\t\t\tstk2.push(p);\n\t\t\t} else if (b[i] == '-') {\n\t\t\t\tif (b[i+1] == '>') {\n\t\t\t\t} else {\n\t\t\t\t\tstk1.push(b[i]);\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t}\n\tbb = stk2.top();\n\tstk2.pop();\n\treturn aa == bb;\n}\n\nchar wa(char a, char b) {\n\tif (a == '0' && b == '0') {\n\t\treturn '0';\n\t} else {\n\t\treturn '1';\n\t}\n}\n\nchar seki(char a, char b) {\n\tif (a == '1' && b == '1') {\n\t\treturn '1';\n\t} else {\n\t\treturn '0';\n\t}\n}\n\nchar naraba(char a, char b) {\n\tif (a == '1' && b == '0') {\n\t\treturn '0';\n\t} else {\n\t\treturn '1';\n\t}\n}\n\nchar not(char a) {\n\tif (a == '0') {\n\t\treturn '1';\n\t} else {\n\t\treturn '0';\n\t}\n}\n\nint main() {\n\tstring a;\n\tstring abc = \"abcdefghijk\";\n\twhile (cin >> a) {\n\t\tif (a == \"#\") {\n\t\t\tbreak;\n\t\t}\n\t\tint counter = 1;\n\t\tcounter <<= 11;\n\t\tstring b;\n\t\tbool hantei = true;\n\t\tfor (int i = 0; i < a.size(); i++) {\n\t\t\tif (a[i] == 'T') {\n\t\t\t\ta[i] = '1';\n\t\t\t} else if (b[i] == 'F') {\n\t\t\t\ta[i] = '0';\n\t\t\t}\n\t\t}\n\t\tfor (int i = 0; i < counter; i++) {\n\t\t\tb = a;\n\t\t\tfor (int j = 0; j < 11; j++) {\n\t\t\t\tif ((i&(1<<j)) != 0) {\n\t\t\t\t\twhile (b.find(abc[j]) != string::npos) {\n\t\t\t\t\t\tb[b.find(abc[j])] = '1';\n\t\t\t\t\t}\n\t\t\t\t} else {\n\t\t\t\t\twhile (b.find(abc[j]) != string::npos) {\n\t\t\t\t\t\tb[b.find(abc[j])] = '0';\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t}\n\t\t\tif (!kaiseki(b)) {\n\t\t\t\thantei = false;\n\t\t\t\tbreak;\n\t\t\t}\n\t\t}\n\t\tif (hantei) {\n\t\t\tcout << \"YES\" << endl;\n\t\t} else {\n\t\t\tcout << \"NO\" << endl;\n\t\t}\n\t}\n\treturn 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include \"bits/stdc++.h\"\nusing namespace std;\ntypedef long long ll;\ntypedef pair<int,int> pii;\n#define rep(i,n) for(ll i=0;i<(ll)(n);i++)\n#define all(a)  (a).begin(),(a).end()\n#define pb push_back\n#define INF (1e9+1)\n//#define INF (1LL<<59)\n\ntypedef string::const_iterator State;\n\n\nstring getop(State &begin){\n\tif(*begin=='*'){\n\t\tbegin++;\n\t\treturn \"*\";\n\t}\n\telse if(*begin=='+'){\n\t\tbegin++;\n\t\treturn \"+\";\n\t}else{\n\t\tbegin++;\n\t\tbegin++;\n\t\treturn \"->\";\n\t}\n}\n\n\nbool mul(bool a,bool b){\n\tif(a&&b)return true;\n\telse return false;\n}\n\n\nbool add(bool a,bool b){\n\tif(!a&&!b)return false;\n\telse return true;\n}\n\n\nbool imp(bool a,bool b){\n\tif(a&&!b)return false;\n\telse return true;\n}\n\n\nbool exp(State &begin){\n\tif(isnumber(*begin)){\n\t\tbegin++;\n\t\treturn '0'+*begin;\n\t}\n\telse if(*begin=='-'){\n\t\tbegin++;\n\t\treturn !exp(begin);\n\t}else if(*begin=='('){\n\t\tbegin++;\n\t\tbool ll = exp(begin);\n\t\tstring op = getop(begin);\n\t\tbool rr = exp(begin);\n\t\tbegin++;\n\t\t\n\t\tif(op==\"*\")return mul(ll,rr);\n\t\telse if(op==\"+\")return add(ll,rr);\n\t\telse return imp(ll,rr);\n\t}\n\t\n\tassert(1);\n\treturn 0;\n}\n\n\nbool check(string s){\n\tstring left=\"\",right=\"\";\n\tbool f=false;\n\trep(i,s.size()){\n\t\tif(s[i]=='=')f=true;\n\t\telse if(f)right+=s[i];\n\t\telse left+=s[i];\n\t}\n\t\n\tState bl = left.begin(),br = right.begin();\n\tbool l = exp(bl);\n\tbool r = exp(br);\n\t\n\tif(l==r)return true;\n\telse return false;\n}\n\n\nint main(){\n\tstring s;\n\twhile(cin>>s&&s!=\"#\"){\n\t\tset<char> var;\n\t\tint c=0;\n\t\trep(i,s.size()){\n\t\t\tif(isalpha(s[i])){\n\t\t\t\tvar.insert(s[i]);\n\t\t\t}\n\t\t}\n\t\t\n\t\t\n\t\tbool f = false;\n\t\tint en = 1<<var.size();\n\t\trep(i,en){\n\t\t\tmap<char,int> mp;\n\t\t\tint num = i;\n\t\t\tfor(auto &e:var){\n\t\t\t\tmp[e] = num%2;\n\t\t\t\tnum/=2;\n\t\t\t}\n\t\t\tstring t = s;\n\t\t\trep(j,t.size()){\n\t\t\t\tif( isalpha(t[j]) ){\n\t\t\t\t\tt[j] = '0'+mp[t[j]];\n\t\t\t\t}\n\t\t\t}\n\t\t\tif(check(t)==false)f=true;\n\t\t}\n\t\tif(f)cout<<\"NO\"<<endl;\n\t\telse cout<<\"YES\"<<endl;}\n}"
  },
  {
    "language": "C++",
    "code": "#include <iostream>\n#include <vector>\n#include <string>\n#include <stack>\n#include <queue>\n#include <deque>\n#include <set>\n#include <map>\n#include <algorithm>\t// require sort next_permutation count __gcd reverse etc.\n#include <cstdlib>\t// require abs exit atof atoi \n#include <cstdio>\t\t// require scanf printf\n#include <functional>\n#include <numeric>\t// require accumulate\n#include <cmath>\t\t// require fabs\n#include <climits>\n#include <limits>\n#include <cfloat>\n#include <iomanip>\t// require setw\n#include <sstream>\t// require stringstream \n#include <cstring>\t// require memset\n#include <cctype>\t\t// require tolower, toupper\n#include <fstream>\t// require freopen\n#include <ctime>\t\t// require srand\n#define rep(i,n) for(int i=0;i<(n);i++)\n#define ALL(A) A.begin(), A.end()\n/*\n\thttp://judge.u-aizu.ac.jp/onlinejudge/description.jsp?id=2401\n\t\n\tACM-ICPC Japan Alumni Group Practice Contest for Japan Domestic 2012, 2012-06-17 \n\n\tEquation\n\n\t構文解析の問題\n\n\t定数: T, F\n\t変数: a, b, c, d, e, f, g, h, i, j, k\n\t論理否定: -X\n\t論理積: (X*Y)\n\t論理和: (X+Y)\n\t論理包含: (X->Y)\n\n\n\tx\ty\t-x\t(x*y)\t(x+y)\t(x->y)\n\tT\tT\tF\tT\tT\tT\n\tT\tF\tF\tF\tT\tF\n\tF\tT\tT\tF\tT\tT\n\tF\tF\tT\tF\tF\tT\n\n\t<equation> ::= <formula> \"=\" <formula>\n\t<formula>  ::= \"T\" | \"F\" |\n\t\"a\" | \"b\" | \"c\" | \"d\" | \"e\" | \"f\" |\n\t\"g\" | \"h\" | \"i\" | \"j\" | \"k\" |\n\t\"-\" <formula> |\n\t\"(\" <formula> \"*\" <formula> \")\" |\n\t\"(\" <formula> \"+\" <formula> \")\" |\n\t\"(\" <formula> \"->\" <formula> \")\"\n\n*/\nusing namespace std;\n\ntypedef long long ll;\ntypedef pair<int, int> P;\n\nint idx = 0;\nstring eq;\nbool formula (void ){\n\n\tbool f1 = false, f2 = false;\n\tif (eq[idx] == '-' ){\n\t\tidx++;\n\t\tf1 = !formula ();\n\t\treturn f1;\n\t}else\n\tif (eq[idx] == '(' ){\n\t\tidx++;\n\t\tf1 = formula ();\n\t\tif (eq[idx] == '*' ){\n\t\t\tidx++;\n\t\t\tf2 = formula ();\n\t\t\tidx++;\t// omit ')'\n\t\t\treturn f1 & f2;\n\t\t}else\n\t\tif (eq[idx] == '+' ){\n\t\t\tidx++;\n\t\t\tf2 = formula ();\n\t\t\tidx++;\t// omit ')'\n\t\t\treturn f1 | f2;\n\t\t}else\n\t\tif (eq[idx] == '-' && idx + 1 < eq.size() && eq[idx+1] == '>' ){\n\t\t\tidx += 2;\n\t\t\tf2 = formula ();\n\t\t\tidx++;\t// omit ')'\n\t\t\treturn !(f1 & !f2 );\n\t\t} // end if\n\t}else{\n\t\tif (eq[idx] == 'T' ){\n\t\t\tf1 = true;\n\t\t}else{\n\t\t\tf1 = false;\n\t\t} // end if\n\t\tidx++;\n\t\treturn f1;\n\t} // end if\n\n\treturn false;\n}\n\nbool equation (void ){\n\tbool f1 = formula ();\n\tif (eq[idx] == '=' ) idx++;\n\tbool f2 = formula ();\n\n\treturn (f1 == f2 );\n}\n\nbool parse (string s ){\n\teq = s;\n\tidx = 0;\n\tbool res = equation ();\n\n\treturn res;\n}\n\nint main()\n{\n\tios_base::sync_with_stdio(0);\n\tstring s = \"\";\n\twhile (cin >> s && s != \"#\" ){\n\t\tint n = s.length();\n\t\tvector<int> val; val.clear();\n\t\trep (i, n ){\n\t\t\tif (s[i] >= 'a' && s[i] <= 'k' ) val.push_back (i );\n\t\t} // end rep\n\t\tsort (ALL (val ) );\n\t\tval.erase (unique (ALL (val ) ), val.end() );\n\n\t\tbool res = true;\n\n\t\tif (val.empty() ){\n\t\t\tres = parse (s );\n\t\t}else{\n\t\t\trep (i, 1<<val.size() ){\n\t\t\t\tstring t = s;\n\t\t\t\trep (j, val.size() ){\n\t\t\t\t\tif (i&(1<<j) ){\n\t\t\t\t\t\trep (k, t.size() ) if (t[k] == val[j] ) t[k] = 'T';\n\t\t\t\t\t} // end if\n\t\t\t\t} // end rep\n\t\t\t\trep (k, t.size() ) if (islower (t[k] ) ) t[k] = 'F';;\n\t\t\t\tres &= parse (t );\n\t\t\t} // end rep\n\t\t} // edn if\n\t\tcout << (res ? \"YES\" : \"NO\" ) << endl;\n\t} // end while\n\t\n\treturn 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include<bits/stdc++.h>\nusing namespace std;\n#define rep(i,n) for(int i=0;i<n;i++)\n#define rep2(i,a,b) for(int i=a;i<=b;i++)\n#define pb push_back\n#define eb emplace_back\n\nint in(){int x;cin>>x;return x;}\n\nint pos;\nint a[200];\nchar s[1100];\nint number(){\n    return a[s[pos++]];\n}\nint expr();\nint factor(){\n    bool f=false;\n    if(s[pos]=='-'){\n        f=true;\n        pos++;\n        return 1-factor();\n    }\n    if(s[pos]=='('){\n        pos++;\n        int res = expr();\n        pos++;\n        return res;\n    }\n    else return number();\n}\nint expr(){\n    int ret = factor();\n    for(;;){\n        if(s[pos]=='+'){\n            pos++;ret|=factor();\n        }\n        else if(s[pos]=='*'){\n            pos++;ret&=factor();\n        }\n        else if(s[pos]=='~'){\n            pos++;int r=factor();\n            if(ret == 1 and r==0)ret = 0;\n            else ret = 1;\n        }\n        else break;\n    }\n    return ret;\n}\nmain(){\n    a['T']=1;\n    a['F']=0;\n    bool F = false;\n    while(1){\n        string t;cin>>t;\n        if(t==\"#\")exit(0);\n        pos = 0;\n        rep(i,t.size()){\n            if(i<t.size()-1 and t.substr(i,2)==\"->\"){\n                s[pos++]='~';i++;\n            }\n            else s[pos++]=t[i];\n        }\n        bool flag = true;\n        rep(i,1<<11){\n            rep(j,11)a['a'+j]=(i&(1<<j)?1:0);\n            pos = 0;\n            int l = expr();\n            pos++;\n            int r = expr();\n            flag &= l==r;\n        }\n        cout << (flag ? \"YES\\n\":\"NO\\n\");\n        F = true;\n        for(int i=t.size()-1;i>=0;i--)s[i]=' ';\n    }\n}\n"
  },
  {
    "language": "C++",
    "code": "#include <cstdio>\n#include <cstdlib>\n#include <cstring>\n#include <cmath>\n#include <ctime>\n#include <iostream>\n#include <algorithm>\n#include <sstream>\n#include <string>\n#include <vector>\n#include <queue>\n#include <stack>\n#include <map>\n#include <set>\n#include <utility>\n#include <cctype>\n#include <numeric>\nusing namespace std;\n\n#define rep(i,n) for(int (i)=0; (i)<(int)(n); ++(i))\n#define foreach(c,i) for(__typeof((c).begin()) i=(c).begin();i!=(c).end();i++)\n\nint N, M, eq;\nchar buf[1010];\nbool alloc[12];\n\nbool OR[2][2] = {\n  {false, true},\n  {true, true}\n};\nbool AND[2][2] = {\n  {false, false},\n  {false, true}\n};\nbool IMP[2][2] = {\n  {true, true},\n  {false, true}\n};\n\nint p;\n\nbool formula() {\n  if (buf[p] == '-') {\n    ++p; return !formula();\n  }\n  if (buf[p] == 'T') {\n    p++; return true;\n  }\n  if (buf[p] == 'F') {\n    p++; return false;\n  }\n  if ('a' <= buf[p] && buf[p] <= 'k') {\n    return alloc[buf[p++] - 'a'];\n  }\n  if (buf[p] == '(') {\n    p++;\n    bool lhs = formula(), rhs, ret;\n    if (buf[p] == '+') {\n      ++p;\n      rhs = formula();\n      ret = OR[lhs][rhs];\n    } else if (buf[p] == '*') {\n      ++p; rhs = formula();\n      ret = AND[lhs][rhs];\n    } else if (buf[p] == '^') {\n      p+=2;\n      rhs = formula();\n      ret = IMP[lhs][rhs];\n    }\n    p++;\n    return ret;\n  }\n}\n\nint main() {\n  while (scanf(\"%s\", buf), buf[0] != '#') {\n    N = strlen(buf);\n    set<char> sc;\n    rep(i,N) if ('a' <= buf[i] && buf[i] <= 'k') {\n      sc.insert(buf[i]);\n    }\n\n    M = sc.size();\n    vector<char> vc;\n    foreach(sc,i) vc.push_back(*i);\n\n    rep(i,N) {\n      if (buf[i] == '=') eq = i;\n      if (buf[i] == '>') buf[i-1] = '^';\n    }\n\n    bool ans = true;\n    for (int S = 0; S < (1 << M); ++S) {\n      fill(alloc, alloc + 12, false);\n      for (int i = 0; i < M; ++i) {\n        if (S >> i & 1) alloc[vc[i] - 'a'] = true;\n      }\n      // lhs\n      p = 0;\n      bool lhs = formula();\n      // rhs\n      p = eq+1;\n      bool rhs = formula();\n      if (lhs != rhs) { ans = false; break; }\n    }\n    printf(\"%s\\n\", ans ? \"YES\": \"NO\");\n  }\n  return 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include<iostream>\n\nusing namespace std;\n\n#define rep(i, n) for (int i = 0; i < int(n); ++i) \n\nstring str;\nint bit;\n\nbool f(string str){\n  if (str.size() == 1) {\n    if (str[0] == 'T') return true;\n    if (str[0] == 'F') return false;\n    else return bit & (1 << (str[0] - 'a'));\n  }\n  int count = 0;\n  rep (i, str.size()) {\n    if (str[i] == '(') ++count;\n    if (str[i] == ')') --count;\n    if (count == 0 && (str[i] == '*' || str[i] == '+' || str.substr(i, 2) == \"->\")) {\n      if (i < int(str.size()) - 1) {\n\tif(str[i] == '*') return f(str.substr(0, i)) && f(str.substr(i + 1));\n\tif (str[i] == '+') return f(str.substr(0, i)) || f(str.substr(i + 1));\n\treturn !f(str.substr(0, i)) || f(str.substr(i + 2));\n      }\n    }\n  }\n  if (str[0] == '-') return !f(str.substr(1));\n  return f(str.substr(1, str.size() - 2));\n}\n\nint main() {\n  for (;;) {\n    cin >> str;\n    if (str == \"#\") break;\n    string s1, s2;\n    int app[12] = {};\n    rep (i, str.size()) if (isalpha(str[i])) ++app[str[i] - 'a'];\n    rep (i, str.size()) if (str[i] == '=') {\n      s1 = str.substr(0, i);\n      s2 = str.substr(i + 1);\n    }\n    bool ok = true;\n    int need = 0;\n    rep (i, 11) if (app[i]) need |= 1 << i;\n    rep (i, 1 << 11) {\n      if (i & ~need) continue;\n      bit = i;\n      if (f(s1) != f(s2)) {\n\tok = false;\n\tbreak;\n      }\n    }\n    cout << (ok ? \"YES\" : \"NO\") << endl;\n  }\n}"
  },
  {
    "language": "C++",
    "code": "#include <algorithm>\n#include <iostream>\n#include <vector>\n#include <string>\n#include <cctype>\nusing namespace std;\n\nint mask;\n\ntemplate<class T> struct Parser {\n    typedef string::const_iterator State;\n\n    T solve(const string &S) {\n        State begin = S.begin();\n        return equation(begin);\n    }\n\n    // <equation> ::= <formula> \"=\" <formula>\n    T equation(State &begin) {\n        T left = formula(begin);\n        begin++;    // skip '='\n        T right = formula(begin);\n        return left == right;\n    }\n\n    // <formula> ::= <boolean> |\n    // \"-\" <formula> |\n    // \"(\" <formula> \"*\" <formula> \")\" |\n    // \"(\" <formula> \"+\" <formula> \")\" |\n    // \"(\" <formula> \"->\" <formula> \")\"\n    T formula(State &begin) {\n        if (*begin == '(') {\n            begin++;                    // skip '('\n            T left = formula(begin);\n            char op = *begin;\n            begin++;                    // skip '*' or '+' or '-'\n            if (op == '-') begin++;     // skip '>'\n            T right = formula(begin);\n            begin++;                    // skip ')'\n            T ret = deduce(left, op, right);\n            return ret;\n        } else if (*begin == '-') {\n            begin++;    // skip '-'\n            return !formula(begin);\n        } else {\n            return boolean(begin);\n        }\n    }\n\n    T deduce(T x, char op, T y) {\n        if (op == '*') {\n            return x and y;\n        } else if (op == '+') {\n            return x or y;\n        } else {    // \"->\"\n            return !x or y;\n        }\n    }\n\n    // <boolean> ::= \"T\" | \"F\" |\n    // \"a\" | \"b\" | \"c\" | \"d\" | \"e\" | \"f\" |\n    // \"g\" | \"h\" | \"i\" | \"j\" | \"k\" |\n    T boolean(State &begin) {\n        T ret;\n        if (*begin == 'T') {\n            ret = 1;\n        } else if (*begin == 'F') {\n            ret = 0;\n        } else {\n            ret = (mask >> (*begin - 'a')) & 1;\n        }\n        begin++;\n        return ret;\n    }\n};\n\nvoid solve(string S) {\n    // 恒等式とは，式に現れる変数がどのような値であっても成立する等式のことである．\n    Parser<bool> ps;\n    for (mask = 0; mask < (1 << 11); mask++) {\n        if (!ps.solve(S)) {\n            cout << \"NO\" << endl;\n            return ;\n        }\n    }\n    cout << \"YES\" << endl;\n}\n\nint main() {\n    string S;\n    while (cin >> S && S != \"#\") {\n        solve(S);\n    }\n    return 0;\n}\n"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\n\n#define N 11\n\nusing namespace std;\n\nbool parse(string x, bool vars[N]) {\n    int nest = 0;\n    switch (x[0]) {\n        case 'T':\n            return true;\n        case 'F':\n            return false;\n        case '-':\n            return !parse(x.substr(1), vars);\n        case '(':\n            break;\n        default:\n            return vars[x[0]-'a'];\n    }\n    x = x.substr(1, x.length()-2);\n    for (int i=0; i<(int)x.length(); i++) {\n        if (x[i] == '(') {\n            nest++;\n            continue;\n        }\n        if (x[i] == ')') {\n            nest--;\n            continue;\n        }\n        if (nest > 0) {\n            continue;\n        }\n        if (x[i] == '+') {\n            return parse(x.substr(0, i), vars) || parse(x.substr(i+1), vars);\n        }\n        if (x[i] == '*') {\n            return parse(x.substr(0, i), vars) && parse(x.substr(i+1), vars);\n        }\n        if (x.substr(i, 2) == \"->\") {\n            return (!parse(x.substr(0, i), vars)) || parse(x.substr(i+2), vars);\n        }\n    }\n    while (true) {\n        cout << \"tsu_ra_i\" << endl;\n    }\n}\n\nbool is_equal(string x, string y) {\n    bool vars[N];\n    for (int i=0; i<(1<<N); i++) {\n        for (int j=0; j<N; j++) {\n            vars[j] = i&(1<<j);\n        }\n        if (parse(x, vars) != parse(y, vars)) {\n            return false;\n        }\n    }\n    return true;\n}\n\nint main() {\n    string line, x, y;\n    while (true) {\n        cin >> line;\n        if (line == \"#\") {\n            return 0;\n        }\n        for (int i=0; i<(int)line.length(); i++) {\n            if (line[i] == '=') {\n                x = line.substr(0, i);\n                y = line.substr(i+1);\n                break;\n            }\n        }\n        if (is_equal(x, y)) {\n            cout << \"YES\" << endl;\n        }\n        else {\n            cout << \"NO\" << endl;\n        }\n    }\n}"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\nusing namespace std;\n\nint vars;\nint pos;\nbool formula(const string& str) {\n  pos++;\n  if(str[pos] == 'T') return true;\n  if(str[pos] == 'F') return false;\n  if(isalpha(str[pos])) {\n    return (vars>>(str[pos]-'a') & 1);\n  }\n  if(str[pos] == '-') {\n    return !formula(str);\n  }\n  if(str[pos] == '(') {\n    int f = formula(str);\n    pos++;\n    bool ret;\n    if(str[pos] == '*') {\n      ret = formula(str) && f;\n    }\n    else if(str[pos] == '+') {\n      ret = f || formula(str);\n    }\n    else if(str[pos] == '>') {\n      pos++;\n      ret = f<=formula(str);\n    }\n    pos ++;\n    return ret;\n  }\n}\n\nint main() {\n  string str;\n  while(cin>>str && str!=\"#\") {\n    \n    int arw = str.find(\"->\");\n    while(arw!=(int)string::npos) {\n      str.replace(arw, 2, \">\");\n      arw = str.find(\"->\", arw+1);\n    }\n    \n    int eq = str.find(\"=\");\n    string s = str.substr(0, eq);\n    string t = str.substr(eq+1);\n    bool ok = true;\n    for(vars=0;vars<(1<<11);vars++) {\n      pos = -1; bool fs = formula(s);\n      pos = -1;\n      if(fs != formula(t)) { ok = false; break; }\n    }\n    if(ok) {\n      cout << \"YES\" << endl;\n    }\n    else {\n      cout << \"NO\" << endl;\n    }\n  }\n  return 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include <iostream>\n#include <string>\n#include <cstring>\n\nusing namespace std;\n\nstruct Parsed {\n  string str;\n  bool res;\n  Parsed(string str, bool res): str(str), res(res) {}\n};\n\nstring str;\nbool table[11];\n\nParsed formula(string str)\n{\n  if (str == \"\") {\n    return Parsed(\"\", true);\n  }\n\n  char c1 = str[0];\n  string rest = str.substr(1);\n  if (c1 == 'T') {\n    return Parsed(rest, true);\n  } else if (c1 == 'F') {\n    return Parsed(rest, false);\n  } else if (c1 >= 'a' && c1 <= 'k') {\n    return Parsed(rest, table[c1 - 'a']);\n  } else if (c1 ==  '-') {\n    Parsed ps = formula(rest);\n    ps.res = !ps.res;\n    return ps;\n  } else if (c1 == '(') {\n    Parsed lhs = formula(rest);\n    char op = lhs.str[0];\n    if (op == '*') {\n      Parsed rhs = formula(lhs.str.substr(1));\n      return Parsed(rhs.str.substr(1), lhs.res & rhs.res);\n    } else if(op == '+') {\n      Parsed rhs = formula(lhs.str.substr(1));\n      return Parsed(rhs.str.substr(1), lhs.res | rhs.res);\n    } else if (op == '-') {\n      Parsed rhs = formula(lhs.str.substr(2));\n      bool res;\n      if (lhs.res && !rhs.res) {\n        res = false;\n      } else {\n        res = true;\n      }\n      return Parsed(rhs.str.substr(1), res);\n    }\n  }\n}\n\nbool equ(string str)\n{\n  Parsed lhs = formula(str);\n  Parsed rhs = formula(lhs.str.substr(1));\n  return (lhs.res == rhs.res);\n}\n\n\nbool rec(int pos)\n{\n  if (pos == 10) {\n    return equ(str);\n  }\n\n  bool ret1, ret2;\n  table[pos] = true;\n  ret1 = rec(pos + 1);\n\n  table[pos] = false;\n  ret2 = rec(pos + 1);\n\n  return (ret1 && ret2);\n}\n\nint main()\n{\n  for (;;) {\n    cin >> str;\n    if (str == \"#\") \n      break;\n\n    memset(table, false, sizeof(table));\n    if (rec(0)) {\n      cout << \"YES\" << endl;\n    } else {\n      cout << \"NO\" << endl;\n    }\n  }\n}"
  },
  {
    "language": "C++",
    "code": "#include <iostream>\n\nusing namespace std;\nstruct node{\n    char type;\n    bool value;\n    node *left, *right;\n    node(){\n        type='\\0';\n        value=false;\n        left=right=NULL;\n    }\n    ~node(){\n        if(left!=NULL) delete left;\n        if(right!=NULL) delete right;\n    }\n};\n\nnode *root;\n\nint rec(node* p, int i, string str){\n    if(i==str.size())return -1;\n    if(p->type=='='){\n        p->left=new node();\n        i=rec(p->left,i,str)+2;\n        p->right=new node();\n        i=rec(p->right,i,str);\n        return -1;\n    }\n    if(str[i]=='F'||str[i]=='T'){\n        p->type='C';\n        p->value=str[i]=='T';\n        return i;\n    }\n    if(str[i]=='-'){\n        p->type='-';\n        p->left=new node();\n        return rec(p->left,i+1,str);\n    }\n    if(str[i]>='a'&&str[i]<='k'){\n        p->type=str[i];\n        return i;\n    }\n    if(str[i]=='('){\n        p->left=new node();\n        i=rec(p->left,i+1,str)+1;\n        if(str[i]=='-'){\n            p->type='>';\n            i++;\n        }else{\n            p->type=str[i];            \n        }\n        p->right=new node();\n        i=rec(p->right,i+1,str)+1;\n        return i;\n    }\n    return i;\n}\nbool b[11];\n\nbool rec2(node*p){\n    if(p==NULL) return -1;\n    if(p->type=='=') return rec2(p->left)==rec2(p->right);\n    if(p->type=='C') return p->value;\n    if(p->type>='a'&&p->type<='k') return b[p->type-'a'];\n    if(p->type=='-') return !rec2(p->left);\n    if(p->type=='*') return rec2(p->left)&&rec2(p->right);\n    if(p->type=='+') return rec2(p->left)||rec2(p->right);\n    if(p->type=='>') return !(rec2(p->left)&&!rec2(p->right));\n    return false;\n}\n\nint main(){\n    string str;\n    node *p;\n    while(cin>>str,str[0]!='#'){\n        root=new node();\n        root->type='=';\n        rec(root,0,str);\n        bool ans=true;\n        for(int i=0;i<(1<<11);i++){\n            for(int i=0;i<11;i++){\n                b[i]=(bool)(i&(1<<i));\n            }\n            if(!rec2(root)){\n                ans=false;\n                break;\n            }\n        }\n        if(ans){\n            cout<<\"YES\"<<endl;\n        }else{\n            cout<<\"NO\"<<endl;\n        }\n    }\n    return 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\nusing namespace std;\nint i, v; string s;\nint () {\n  i++;\n  if(s[i]=='T') return 1;\n  if(s[i]=='F') return 0;\n  if(isalpha(s[i])) return v>>(s[i]-'a')&1;\n  if(s[i]=='-') return !P();\n  int l=P();\n  i++;char o=s[i];if(o=='-')i++;\n  int r=P();i++;\n  if(o=='*') return l&r;\n  if(o=='+') return l|r;\n  if(o=='-') return l<=r;\n}\n \nint main() {\n  while(cin>>s) {\n    if(s==\"#\") break;\n    bool k=true;\n    for(v=0;v<(1<<11);v++) {\n      i=-1; int l=P();\n      i++;\n      if(l!=P()) { k=false; break; }\n    }\n    cout<<(k ? \"YES\\n\":\"NO\\n\");\n  }\n  return 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\n \nusing namespace std;\nusing ll = long long;\n#define int ll\nusing PII = pair<int, int>;\n \n#define FOR(i, a, n) for (ll i = (ll)a; i < (ll)n; ++i)\n#define REP(i, n) FOR(i, 0, n)\n#define ALL(x) x.begin(), x.end()\n \ntemplate<typename T> T &chmin(T &a, const T &b) { return a = min(a, b); }\ntemplate<typename T> T &chmax(T &a, const T &b) { return a = max(a, b); }\ntemplate<typename T> bool IN(T a, T b, T x) { return a<=x&&x<b; }\ntemplate<typename T> T ceil(T a, T b) { return a/b + !!(a%b); }\n\ntemplate<typename T> vector<T> make_v(size_t a) { return vector<T>(a); }\ntemplate<typename T,typename... Ts>\nauto make_v(size_t a,Ts... ts) { \n  return vector<decltype(make_v<T>(ts...))>(a,make_v<T>(ts...));\n}\ntemplate<typename T,typename V> typename enable_if<is_class<T>::value==0>::type\nfill_v(T &t, const V &v) { t=v; }\ntemplate<typename T,typename V> typename enable_if<is_class<T>::value!=0>::type\nfill_v(T &t, const V &v ) { for(auto &e:t) fill_v(e,v); }\n\ntemplate<class S,class T>\nostream &operator <<(ostream& out,const pair<S,T>& a){\n  out<<'('<<a.first<<','<<a.second<<')'; return out;\n}\ntemplate<typename T>\nistream& operator >> (istream& is, vector<T>& vec){\n  for(T& x: vec) {is >> x;} return is;\n}\ntemplate<class T>\nostream &operator <<(ostream& out,const vector<T>& a){\n  out<<'['; for(T i: a) {out<<i<<',';} out<<']'; return out;\n}\n\nint dx[] = {0, 1, 0, -1}, dy[] = {1, 0, -1, 0}; // DRUL\nconst int INF = 1<<30;\nconst ll LLINF = 1LL<<60;\nconst int MOD = 1000000007;\n\nint pos;\nstring s;\n\nchar formula() {\n  if(s[pos] == '-') {\n    pos++;\n    char tmp = formula();\n    // cout << pos << \" \" << tmp << endl;\n    if(tmp == 'F') tmp = 'T';\n    else tmp = 'F';\n    // cout << pos << \" \" << tmp << endl;\n    return tmp;\n  } \n  if(s[pos] == '(') {\n    pos++;\n    char vl = formula();\n    char op = s[pos++];\n    if(op == '-') pos++;\n    char vr = formula();\n    if(s[pos] != ')') assert(false);\n    pos++;\n\n    char ret;\n    // cout << op << endl;\n    if(op == '*') {\n      if(vl == 'T' && vr == 'T') ret = 'T';\n      else ret = 'F';\n    } else if(op == '+') {\n      if(vl == 'F' && vr == 'F') ret = 'F';\n      else ret = 'T';\n    } else if(op == '-') {\n      if(vl == 'T' && vr == 'F') ret = 'F';\n      else ret = 'T';\n    }\n    return ret;\n  }\n  return s[pos++];\n}\n\nsigned main(void)\n{\n  cin.tie(0);\n  ios::sync_with_stdio(false);\n\n  while(1) {\n    string t;\n    cin >> t;\n    if(t == \"#\") break;\n\n    int m = 0;\n    map<char,int> mp;\n    REP(i, t.size()) {\n      if(isalpha(t[i]) && t[i]!='T' && t[i]!='F') {\n        if(mp.find(t[i]) == mp.end()) mp[t[i]] = m++;\n      }\n    }\n    REP(i, t.size()) {\n      if(isalpha(t[i]) && t[i]!='T' && t[i]!='F') {\n        t[i] = (char)(mp[t[i]] + 'a');\n      }\n    }\n\n    bool flag = true;\n    REP(i, 1LL<<m) {\n      string str = t;\n      REP(j, str.size()) {\n        if(isalpha(str[j]) && t[j]!='T' && t[j]!='F') {\n          if(i&(1<<(str[j]-'a'))) str[j] = 'T';\n          else str[j] = 'F';\n        }\n      }\n\n      int idx = str.find('=');\n      pos = 0;\n      s = str.substr(0, idx);\n      // cout << s << endl;\n      char vl = formula();\n      // cout << vl << endl;\n      pos = 0;\n      s = str.substr(idx+1);\n      // cout << s << endl;\n      char vr = formula();\n      // cout << vr << endl;\n\n      if(vl != vr) {\n        flag = false;\n        break;\n      }\n    }\n\n    if(flag) {\n      cout << \"YES\" << endl;\n    } else {\n      cout << \"NO\" << endl;\n    }\n  }\n\n  return 0;\n}\n\n"
  },
  {
    "language": "C++",
    "code": "#include<iostream>\n#include<vector>\n#include<string>\n#include<algorithm>\n#define all(c) c.begin(),c.end()\n#define uni(c) c.erase(unique(c.begin(),c.end()),c.end())\n#define pb push_back\nusing namespace std;\n\nint expr(string& s, int& i);\nint term(string& s, int& i);\nint factor(string& s, int& i);\nint number(string& s, int& i);\n\n\nint expr(string& s, int& i) {\n  int val = factor(s, i);\n  while(s[i] == '+' || s[i] == '-'|| s[i]=='*') {\n    char op = s[i];\n    i++;\n  \tif(!isdigit(s[i])&&s[i]!='-'){\n  \t\ti++;\n  \t\tint val2 = factor(s, i);\n  \t\tif(val==1&&val2==0){\n  \t\t\tval=0;\n  \t\t}else{\n  \t\t\tval=1;\n  \t\t}\n  \t}else{\n  \t\t\n  \t  int val2 = factor(s, i);\n    \tif (op == '+') \n  \t\t\tval |= val2;\n  \t\telse if(op=='*')\n  \t\t\tval *= val2;\n  \t\t//cout<<\"   \"<<val<<\" \"<<val2<<endl;\n  \t}\n  \t\n  }\n  return val;\n}\n\n/*int term(string& s, int& i) {\n  int val = factor(s, i);\n  while(s[i] == '*') {\n    char op = s[i];\n    i++;\n    int val2 = factor(s, i);\n    if (op == '*') val *= val2;\n  }\n  return val;\n}\n*/\nint factor(string& s, int& i) {\n\tint flag=0;\n\tif(s[i]=='-'){\n\t\tflag=1;\n\t\ti++;\n\t}\n\tif (isdigit(s[i])){\n\t\tif(flag)\n\t\t\treturn flag^number(s, i);\n\t\t\treturn number(s,i);\n\t}\n\n  // ここで構文が正しければ s[i] == '(' となる\n  i++; // '('を読み飛ばす\n  int ret = expr(s, i);\n  i++; // ')'を読み飛ばす\n\tif(flag)\n\treturn flag^ret;\n\treturn ret;\n}\n\nint number(string& s, int& i) {\n  int n = s[i++] - '0';\n  while(isdigit(s[i])) n = n*10 + s[i++] - '0';\n  return n;\n}\n\nint main(){\n\tstring s;\n\twhile(cin>>s,s!=\"#\"){\n\t\tint eq=0;\n\t\tstring a,b;\n\t\tfor(int i=0;i<s.size();i++){\n\t\t\tif(s[i]=='T')\n\t\t\ts[i]='1';\n\t\t\telse if(s[i]=='F')\n\t\t\ts[i]='0';\n\t\t}\n\t\tfor(;s[eq]!='=';eq++);\n\t\ta=s.substr(0,eq),b=s.substr(eq+1,s.size()-eq);\n\t\t//cout<<a<<\" \"<<b<<endl;\n\t\tvector<char> ap;\n\t\t\n\t\tfor(int i=0;i<s.size();i++){\n\t\t\tif(isalpha(s[i]))\n\t\t\t\tap.pb(s[i]);\n\t\t}\n\t\tsort(all(ap));\n\t\tuni(ap);\n\t\tbool flag=true;\n\t\tfor(int i=0;i<(1<<ap.size());i++){\n\t\t\tstring x=a,y=b;\n\t\t\tfor(int j=0;j<ap.size();j++){\n\t\t\t\tchar c=ap[j];\n\t\t\t\tbool wh=false;\n\t\t\t\tif((1<<j)&i)\n\t\t\t\t\twh=true;\n\t\t\t\tfor(int k=0;k<x.size();k++){\n\t\t\t\t\tif(x[k]==c){\n\t\t\t\t\t\tif(wh)\n\t\t\t\t\t\t\tx[k]='1';\n\t\t\t\t\t\telse\n\t\t\t\t\t\t\tx[k]='0';\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t\tfor(int k=0;k<y.size();k++){\n\t\t\t\t\tif(y[k]==c){\n\t\t\t\t\t\tif(wh)\n\t\t\t\t\t\t\ty[k]='1';\n\t\t\t\t\t\telse\n\t\t\t\t\t\t\ty[k]='0';\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t}\n\t\t\t\n\t\t\tint i=0,j=0;\n\t\t\t/*cout<<x<<\" \"<<y<<endl;\n\t\t\tcout<<expr(x,i)<<\"--\"<<endl;\n\t\t\tcout<<expr(y,j)<<endl;\n\t\t\ti=0,j=0;*/\n\t\t\tif(expr(x,i)!=expr(y,j)){\n\t\t\t\tcout<<\"NO\"<<endl;\n\t\t\t\tflag=false;\n\t\t\t\tbreak;\n\t\t\t}\n\t\t\t\n\t\t}\n\t\tif(flag)\n\t\t\tcout<<\"YES\"<<endl;\n\t}\n\treturn 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include<iostream>\n#include<string>\nusing namespace std;\n\nstring s;\nint use;\n\nbool parse(int l,int r){\n  for(int i=l;i<r;i++)\n    if(s[i] == '=')return parse(l,i) == parse(i+1,r);\n\n  int p = 0;\n  for(int i=l;i<r;i++){\n    if(s[i] == '(')p++;\n    if(s[i] == ')')p--;\n    if(!p){\n      if(s[i] == '*')return parse(l,i) && parse(i+1,r);\n      if(s[i] == '+')return parse(l,i) || parse(i+1,r);\n      if(s[i] == '-' && s[i+1] == '>')return !parse(l,i) || parse(i+2,r);\n    }\n  }\n\n  if(s[l] == '-')return !parse(l+1,r);\n  if(s[l] == '(' && s[r-1] == ')')return parse(l+1,r-1);\n  if(s[l] == 'T')return true;\n  if(s[l] == 'F')return false;\n  return ( ( use >> (s[l]-'a') ) & 1);\n}\n\nint main(){\n  while(cin >> s,s!=\"#\"){\n    bool f = true;\n    for(use=0;use<(1<<11);use++){\n      f &= parse(0,s.size());\n      if(!f)break;\n    }\n    if(f)cout << \"YES\\n\";\n    else cout << \"NO\\n\";\n  }\n}"
  },
  {
    "language": "C++",
    "code": "#include <cstdio>\n\n#define N ( 'k' - 'a' + 1 )\n\nusing namespace std;\n\nstatic       int  d[ N ];\nstatic       char buf[ 1024 ];\nstatic const char * s;\n\nstatic int\nformula (\n  void\n  )\n{\n  int lt, rt;\n\n  switch ( *s )\n  {\n    case 'T':\n      ++s;\n      return ( 1 );\n    case 'F':\n      ++s;\n      return ( 0 );\n    case 'a':\n    case 'b':\n    case 'c':\n    case 'd':\n    case 'e':\n    case 'f':\n    case 'g':\n    case 'h':\n    case 'i':\n    case 'j':\n    case 'k':\n      ++s;\n      return ( d[ s[ -1 ] - 'a' ] );\n    case '-':\n      ++s;\n      return ( !( formula ( ) ) );\n    case '(':\n      ++s;\n      lt = formula ( );\n      switch ( *s )\n      {\n        case '*':\n          ++s;\n          rt = formula ( );\n          lt = lt && rt;\n          break ;\n        case '+':\n          ++s;\n          rt = formula ( );\n          lt = lt || rt;\n          break ;\n        case '-':\n          s += 2;\n          rt = formula ( );\n          lt = !( lt ) || rt;\n          break ;\n      }\n      ++s;\n      break ;\n  }\n\n  return ( lt );\n}\n\nstatic int\nequation (\n  void\n  )\n{\n  const int lt = formula ( );\n\n  ++s;\n  return ( lt == formula ( ) );\n}\n\nstatic int\ntest (\n  const int r\n  )\n{\n  if ( r == N )\n  {\n    s = buf;\n    return ( equation ( ) );\n  }\n\n  d[ r ] = 0;\n  if ( !test ( r + 1 ) ) return ( 0 );\n  d[ r ] = 1;\n  if ( !test ( r + 1 ) ) return ( 0 );\n\n  return ( 1 );\n}\n\nint\nmain (\n  void\n  )\n{\n  for ( ; ; )\n  {\n    scanf ( \" %s\", buf );\n    if ( *buf == '#' ) break ;\n\n    puts ( test ( 0 ) ? \"YES\" : \"NO\" );\n  }\n}"
  },
  {
    "language": "C++",
    "code": "#include<iostream>\n#include<string>\n#include<map>\n#include<sstream>\n#include<cctype>\n#include<algorithm>\nusing namespace std;\ntypedef string::const_iterator Cursol;\nbool ok;\nint bit;\nbool Formula(Cursol &c){\n  bool ret;\n\n  if(*c == 'T'){\n    ret = true;\n    c++;\n  }else if(*c == 'F'){\n    ret = false;\n    c++;\n  }else if(islower(*c)){\n    ret = bit >> ((*c) - 'a') & 1;\n    c++;\n  }else if(*c == '-'){\n    c++;\n    return !Formula(c);\n  }else if(*c == '('){\n    c++;\n    ret = Formula(c);\n    if(*c == '+'){\n      c++;\n      ret |= Formula(c);\n    }else if(*c == '*'){\n      c++;\n      ret &= Formula(c);\n    }else if(*c == '-'){ //->\n      c += 2;\n      ret = !ret | Formula(c);\n    }\n  }\n  // cout << ret << endl;\n  return ret;\n}\nint main(){\n  string s;\n  Cursol c;\n  while(cin >> s , ok = true, s != \"#\"){\n    string l = s.substr(0,s.find('='));\n    string r = s.substr(s.find('=')+1);\n\n    for(bit = 0 ; bit < (1 << 11) ; bit++ ){\n      c = l.begin();\n      bool java = Formula(c);\n      c = r.begin();\n      if( java != Formula(c) ){\n\tok = false;\n\tbreak;\n      }\n    }\n    if(ok) cout << \"YES\" << endl;\n    else cout << \"NO\" << endl;\n  }\n}"
  },
  {
    "language": "C++",
    "code": "#include <iostream>\n#include <string>\n#include <vector>\n#include <algorithm>\n#include <utility>\n#include <cstring>\n#include <cmath>\n#include <queue>\n#include <map>\n#include <set>\nusing namespace std;\n\n#define rep(i,n) for(int i=0; i<n; i++)\n#define FOR(i,s,n) for(int i=s; i<n; i++)\n#define ALL(x) x.begin(), x.end()\ntypedef long long ll;\ntypedef unsigned long long ull;\ntypedef pair<int,int> pii;\ntypedef vector<int> vi;\n\nstring solve( string s ) {\n\tif( s == \"0\" || s == \"1\" ) return s;\n\trep(i, s.length()) {\n\t\tif(s[i] == '(') {\n\t\t\tint p = i+1;\n\t\t\twhile(p<s.length() && s[p]!=')') p++;\n\t\t\tstring ss = solve(s.substr(i+1, p-i-1));\n\t\t\ts.replace(i, p-i+1, ss);\n\t\t}\n\t}\n\n\trep(i, s.length()) {\n\t\tif(s[i] == '*') {\n\t\t\tstring sa = solve(s.substr(0, i));\n\t\t\tstring sb = solve(s.substr(i+1));\n\t\t\ts = (sa==\"1\" && sb==\"1\") ? \"1\" : \"0\";\n\t\t}\n\t\telse if(s[i] == '+') {\n\t\t\tstring sa = solve(s.substr(0, i));\n\t\t\tstring sb = solve(s.substr(i+1));\n\t\t\ts = (sa==\"0\" && sb==\"0\") ? \"0\" : \"1\";\n\t\t}\n\t\telse if(s[i] == '-' && i+1<s.length() && s[i+1]=='>') {\n\t\t\tstring sa = solve(s.substr(0, i));\n\t\t\tstring sb = solve(s.substr(i+2));\n\t\t\ts = (sa==\"1\" && sb==\"0\") ? \"0\" : \"1\";\n\t\t}\n\t}\n\trep(i, s.length()) {\n\t\tif(s[i] == '-') {\n\t\t\tstring ss = solve(s.substr(i+1));\n\t\t\ts = (ss==\"0\" ? \"1\" : \"0\");\n\t\t}\n\t}\n\treturn s;\n}\n\nint main() {\n\tstring in;\n\twhile(cin >> in, in!=\"#\") {\n\t\tstring aa, ab;\n\t\trep(i, in.length()) {\n\t\t\tif( in[i] == 'T' ) {\n\t\t\t\tin[i] = '1';\n\t\t\t}\n\t\t\telse if( in[i] == 'F' ) {\n\t\t\t\tin[i] = '0';\n\t\t\t}\n\t\t}\n\t\trep(i, in.length()) {\n\t\t\tif( in[i] == '=' ) {\n\t\t\t\taa = in.substr(0, i);\n\t\t\t\tab = in.substr(i+1);\n\t\t\t\tbreak;\n\t\t\t}\n\t\t}\n\t\tbool ng = false;\n\t\trep(i, (1<<11)) {\n\t\t\tstring a=aa, b=ab;\n\t\t\trep(j, a.length()) {\n\t\t\t\tif('a'<=a[j] && a[j]<='k') {\n\t\t\t\t\ta[j] = '0' + ((i & (1<<(a[j]-'a'))) ? 1 : 0);\n\t\t\t\t}\n\t\t\t}\n\t\t\trep(j, b.length()) {\n\t\t\t\tif('a'<=b[j] && b[j]<='k') {\n\t\t\t\t\tb[j] = '0' + ((i & (1<<(b[j]-'a'))) ? 1 : 0);\n\t\t\t\t}\n\t\t\t}\n\t\t\ta = solve(a);\n\t\t\tb = solve(b);\n\t\t\tif( a != b ) {\n\t\t\t\tcout << \"NO\" << endl;\n\t\t\t\tng = true;\n\t\t\t\tbreak;\n\t\t\t}\n\t\t}\n\t\tif( !ng ) {\n\t\t\tcout << \"YES\" << endl;\n\t\t}\n\t}\n\treturn 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include <functional>\n#include <iostream>\n#include <memory>\n#include <string>\n#include <unordered_set>\n#include <vector>\n#define loop(i, a, n) for (int i = (a); i < (n); i++)\n#define rep(i, n) loop(i, 0, n)\ntemplate<typename A> using F = std::function<A>;\nusing namespace std;\n\ntemplate<typename T> struct ParseResult {\n  bool succeeded;\n  T object;\n  size_t pos;\n  ParseResult(const bool succeeded, const T &object, const size_t pos) : succeeded(succeeded), object(object), pos(pos) {}\n  friend std::ostream &operator<<(std::ostream &os, const ParseResult<T> &p) { return os << '{' << (p.succeeded ? \"true\" : \"false\") << ',' << p.object << ',' << p.pos << '}'; }\n};\n\ntemplate<typename T> using Parser = std::function<ParseResult<T>(const std::string &, size_t)>;\n\nParser<std::string> token(std::string s) {\n  const size_t n = s.size();\n  return [n = std::move(n), s = std::move(s)](const std::string &target, const size_t pos) {\n    if (target.size() < n) return ParseResult<std::string>(false, {}, pos);\n    return target.substr(pos, n) == s ? ParseResult<std::string>(true, s, pos + n) : ParseResult<std::string>(false, {}, pos);\n  };\n}\n\ntemplate<typename T> Parser<T> operator||(Parser<T> p1, Parser<T> p2) {\n  return [p1 = std::move(p1), p2 = std::move(p2)](const std::string &target, const size_t pos) {\n    auto r = p1(target, pos);\n    if (r.succeeded) return r;\n    r = p2(target, pos);\n    if (r.succeeded) return r;\n    return ParseResult<T>(false, {}, pos);\n  };\n}\n\ntemplate<typename T1, typename T2> Parser<std::pair<T1, T2>> operator+(Parser<T1> p1, Parser<T2> p2) {\n  return [p1 = std::move(p1), p2 = std::move(p2)](const std::string &target, const size_t pos) {\n    auto r1 = p1(target, pos);\n    if (!r1.succeeded) return ParseResult<std::pair<T1, T2>>(false, {}, pos);\n    auto r2 = p2(target, r1.pos);\n    if (!r2.succeeded) return ParseResult<std::pair<T1, T2>>(false, {}, pos);\n    return ParseResult<std::pair<T1, T2>>(true, {r1.object, r2.object}, r2.pos);\n  };\n}\n\ntemplate<typename T1, typename T2> Parser<T2> operator>>(Parser<T1> p1, Parser<T2> p2) {\n  return [p1 = std::move(p1), p2 = std::move(p2)](const std::string &target, const size_t pos) {\n    auto r1 = p1(target, pos);\n    if (!r1.succeeded) return ParseResult<T2>(false, {}, pos);\n    auto r2 = p2(target, r1.pos);\n    if (!r2.succeeded) return ParseResult<T2>(false, {}, pos);\n    return ParseResult<T2>(true, r2.object, r2.pos);\n  };\n}\n\ntemplate<typename T1, typename T2> Parser<T1> operator<<(Parser<T1> p1, Parser<T2> p2) {\n  return [p1 = std::move(p1), p2 = std::move(p2)](const std::string &target, const size_t pos) {\n    auto r1 = p1(target, pos);\n    if (!r1.succeeded) return ParseResult<T1>(false, {}, pos);\n    auto r2 = p2(target, r1.pos);\n    if (!r2.succeeded) return ParseResult<T1>(false, {}, pos);\n    return ParseResult<T1>(true, r1.object, r2.pos);\n  };\n}\n\nParser<char> oneOf(const std::string &s) {\n  std::unordered_set<char> d;\n  for (auto &c : s) d.insert(c);\n  return [d = std::move(d)](const std::string &target, const size_t pos) {\n    if (target.size() <= pos) return ParseResult<char>(false, {}, pos);\n    char c = target[pos];\n    return d.count(c) ? ParseResult<char>(true, c, pos + 1) : ParseResult<char>(false, {}, pos);\n  };\n}\n\ntemplate<typename T, typename S, typename F> Parser<S> fmap(Parser<T> p, F &&f) {\n  return [p = std::move(p), f = std::forward<F>(f)](const std::string &target, const size_t pos) {\n    auto r = p(target, pos);\n    return r.succeeded ? ParseResult<S>(true, f(r.object), r.pos) : ParseResult<S>(false, {}, r.pos);\n  };\n}\n\ntemplate<typename T, typename F> Parser<T> lazy(const F &f) {\n  bool instantiated = false;\n  Parser<T> p;\n  return [f = std::move(f), p = std::move(p), instantiated = std::move(instantiated)](const std::string &target, const size_t pos) mutable {\n    if (!instantiated) {\n      p = f();\n      instantiated = true;\n    }\n    return p(target, pos);\n  };\n}\n\n// template<typename T> Parser<T> makeView(Parser<T> &&p) {\n//   return [p = std::make_shared<Parser<T>>(std::move(p))](const std::string &target, const size_t pos) { return (*p)(target, pos); };\n// }\n\nstruct SyntaxTree {\n  string op;\n  char value;\n  vector<SyntaxTree> children;\n  SyntaxTree() {}\n  SyntaxTree(const string &op, const char value, const vector<SyntaxTree> &children) : op(op), value(value), children(children) {}\n};\n\nint main() {\n  Parser<SyntaxTree> formulaP = /*makeView<SyntaxTree>(*/ lazy<SyntaxTree>([&]() {\n    auto andP = fmap<pair<SyntaxTree, SyntaxTree>, SyntaxTree>((token(\"(\") >> formulaP << token(\"*\")) + (formulaP << token(\")\")), [](auto &o) { return SyntaxTree(\"*\", {}, {o.first, o.second}); });\n    auto orP = fmap<pair<SyntaxTree, SyntaxTree>, SyntaxTree>((token(\"(\") >> formulaP << token(\"+\")) + (formulaP << token(\")\")), [](auto &o) { return SyntaxTree(\"+\", {}, {o.first, o.second}); });\n    auto impP = fmap<pair<SyntaxTree, SyntaxTree>, SyntaxTree>((token(\"(\") >> formulaP << token(\"->\")) + (formulaP << token(\")\")), [](auto &o) { return SyntaxTree(\"->\", {}, {o.first, o.second}); });\n    auto notP = fmap<SyntaxTree, SyntaxTree>(token(\"-\") >> formulaP, [](auto &o) { return SyntaxTree(\"-\", {}, {o}); });\n    auto valP = fmap<char, SyntaxTree>(oneOf(\"abcdefghijkTF\"), [](char x) { return SyntaxTree({}, x, {}); });\n    return andP || orP || impP || notP || valP;\n  }) /*)*/;\n  auto equationP = (formulaP << token(\"=\")) + formulaP;\n  string s;\n  while (cin >> s, s != \"#\") {\n    auto r = equationP(s, 0);\n    bool isValid = true;\n    rep(i, 1 << 11) {\n      auto toBool = [&](char c) -> bool {\n        if (c == 'T') return true;\n        if (c == 'F') return false;\n        return i >> (c - 'a') & 1;\n      };\n      F<bool(const SyntaxTree &)> evalF = [&](const SyntaxTree &f) {\n        switch (f.children.size()) {\n          case 0: return toBool(f.value);\n          case 1: return !evalF(f.children[0]);\n          case 2:\n            if (f.op == \"*\") return evalF(f.children[0]) && evalF(f.children[1]);\n            if (f.op == \"+\") return evalF(f.children[0]) || evalF(f.children[1]);\n            if (f.op == \"->\") return !evalF(f.children[0]) || evalF(f.children[1]);\n        }\n      };\n      isValid &= evalF(r.object.first) == evalF(r.object.second);\n    }\n    cout << (isValid ? \"YES\" : \"NO\") << endl;\n  }\n}"
  },
  {
    "language": "C++",
    "code": "#include<cstdio>\n#include<cstdlib>\n#include<cstring>\n#include<cmath>\n#include<cctype>\n#include<climits>\n#include<iostream>\n#include<string>\n#include<vector>\n#include<map>\n//#include<list>\n#include<queue>\n#include<deque>\n#include<algorithm>\n//#include<numeric>\n#include<utility>\n#include<complex>\n//#include<memory>\n#include<functional>\n#include<cassert>\n\nconst int dx[] = {1, 0, -1, 0};\nconst int dy[] = {0, 1, 0, -1};\nusing namespace std;\ntypedef long long ll;\ntypedef vector<int> vi;\ntypedef vector<ll> vll;\ntypedef pair<int, int> pii;\ntypedef complex<double> C;\n\ntypedef string::const_iterator State;\n\nbool formula(State& begin, int S);\nbool TF(State& begin, int S);\n\nvoid consume(State& begin, char expected) {\n    if (*begin == expected) {\n        begin++;\n    } else {\n        cerr << \"Expected '\" << expected << \"' but got '\" << *begin << \"'\" << endl;\n        cerr << \"Rest string is '\";\n        while (*begin) {\n            cerr << *begin++;\n        }\n        cerr << \"'\" << endl;\n        exit(1);\n    }\n}\n\nbool formula(State& begin, int S) {\n    if (*begin == '-') {\n        begin++;\n        return !formula(begin, S);\n    } else if (*begin == '(') {\n        consume(begin, '(');\n        bool ret = formula(begin, S);\n        if (*begin == '*') {\n            consume(begin, '*');\n            ret &= formula(begin, S);\n            consume(begin, ')');\n            return ret;\n        } else if (*begin == '+') {\n            consume(begin, '+');\n            ret |= formula(begin, S);\n            consume(begin, ')');\n            return ret;\n        } else {\n            consume(begin, '-');\n            consume(begin, '>');\n            bool tmp = formula(begin, S);\n            if (ret == true && tmp == false) ret = false;\n            else ret = true;\n            consume(begin, ')');\n            return ret;\n        }\n    } else {\n        return TF(begin, S);\n    }\n}\n\nbool TF(State& begin, int S) {\n    if (*begin == 'T') {\n        consume(begin, 'T');\n        return true;\n    }\n    if (*begin == 'F') {\n        consume(begin, 'F');\n        return false;\n    }\n    int tmp = *begin - 'a';\n    begin++;\n    return ((S>>tmp)&1) == 1;\n}\n\nint main() {\n    cin.tie(0);\n    ios::sync_with_stdio(false);\n    while (1) {\n        bool ng = false;\n        string s;\n        cin >> s;\n        if (s == \"#\") break;\n        for (int i = 0; i < 8; i++) {\n            State begin1 = s.begin(), begin2;\n            for (begin2 = s.begin(); ; begin2++) {\n                if (*begin2 == '=') {\n                    begin2++;\n                    break;\n                }\n            }\n            if (formula(begin1, i) != formula(begin2, i)) {\n                ng = true;\n                break;\n            }\n        }\n        if (ng) {\n            cout << \"NO\" << endl;\n        } else {\n            cout << \"YES\" << endl;\n        }\n    }\n    return 0;\n}"
  },
  {
    "language": "C++",
    "code": "'use strict';\n\nfunction token(s) {\n  const len = s.length;\n  return (target, pos) =>\n    target.substr(pos, len) === s ? [true, s, pos + len]\n      : [false, null, pos];\n}\n\nfunction choice() {\n  const parsers = arguments;\n  return (target, pos) => {\n    for (let parser of parsers) {\n      const parsed = parser(target, pos);\n      if (parsed[0]) return parsed;\n    }\n    return [false, null, pos];\n  };\n}\n\nfunction seq() {\n  const parsers = arguments;\n  return (target, pos) => {\n    const result = [];\n    let nextPos = pos;\n    for (let parser of parsers) {\n      const parsed = parser(target, nextPos);\n      if (!parsed[0]) return [false, null, pos];\n      result.push(parsed[1]);\n      nextPos = parsed[2];\n    }\n    return [true, result, nextPos];\n  };\n}\n\nfunction lazy(f) {\n  let parser;\n  return function (target, position) {\n    if (!parser) parser = f();\n    return parser(target, position);\n  };\n}\n\nfunction fmap(parser, f) {\n  return (target, pos) => {\n    const result = parser(target, pos);\n    if (result[0]) {\n      return [result[0], f(result[1]), result[2]];\n    } else {\n      return result;\n    }\n  };\n}\n\nfunction oneOf(s) {\n  let d = {};\n  for (let c of s) d[c] = c;\n  return (target, pos) => {\n    const c = target.substr(pos, 1);\n    return d[c] ? [true, c, pos + 1] : [false, null, pos];\n  };\n}\n\n// (stdin => {\n//   const formulaP = lazy(() => {\n//     const andP = fmap(seq(token('('), formulaP, token('*'), formulaP, token(')')), x => {\n//       return { op: '*', fs: [x[1], x[3]] };\n//     });\n//     const orP = fmap(seq(token('('), formulaP, token('+'), formulaP, token(')')), x => {\n//       return { op: '+', fs: [x[1], x[3]] };\n//     });\n//     const impP = fmap(seq(token('('), formulaP, token('->'), formulaP, token(')')), x => {\n//       return { op: '->', fs: [x[1], x[3]] };\n//     });\n//     const notP = fmap(seq(token('-'), formulaP), x => {\n//       return { op: '-', fs: [x[1]] };\n//     });\n//     const valP = fmap(oneOf('abcdefghijkTF'), x => { return { val: x, fs: [] }; });\n//     return choice(andP, orP, impP, notP, valP);\n//   });\n//   const equationP = fmap(seq(formulaP, token('='), formulaP), x => {\n//     return { left: x[0], right: x[2] };\n//   });\n\n//   stdin.toString().split('\\n').forEach(s => {\n//     if (s == '#') process.exit(0);\n//     // const r = equationP(s, 0);\n//     // let isValid = true;\n//     // for (let i = 0; i < (1 << 11); i++) {\n//     //   isValid &= evalF(r[1].left) === evalF(r[1].right);\n//     //   function toBool(c) {\n//     //     if (c === 'T') return true;\n//     //     if (c === 'F') return false;\n//     //     return !!(i >> (c.charCodeAt() - 'a'.charCodeAt()) & 1);\n//     //   }\n//     //   function evalF(f) {\n//     //     switch (f.fs.length) {\n//     //       case 0: return toBool(f.val);\n//     //       case 1: return !evalF(f.fs[0]);\n//     //       case 2:\n//     //         switch (f.op) {\n//     //           case '*': return evalF(f.fs[0]) && evalF(f.fs[1]);\n//     //           case '+': return evalF(f.fs[0]) || evalF(f.fs[1]);\n//     //           case '->': return !evalF(f.fs[0]) || evalF(f.fs[1]);\n//     //         }\n//     //     }\n//     //   }\n//     // }\n//     // console.log(isValid ? 'YES' : 'NO');\n//   });\n// })(require('fs').readFileSync('/dev/stdin', 'utf8'));"
  },
  {
    "language": "C++",
    "code": "#include<bits/stdc++.h>\n\nusing namespace std;\n\n#define reps(i,f,n ) for(int i=f;i<int(n);i++)\n#define rep(i,n) reps(i,0,n)\n\nstring in;\nstring alp = \"abcdefghijk\";\n//string alp = \"abc\";\nint N = alp.size();\n\nvoid init(){}\n\nbool input(){\n  cin>>in;\n  if(in==\"#\")return false;\n  return true;\n}\n\nbool has(int s,int i){\n  return (s&(1<<i))>0;\n}\n\nvector<string> spstr(string& s, int i){\n  vector<string> ret;\n  ret.push_back(s.substr(1,i-1));\n  if(s[i]!='-')ret.push_back(s.substr(i+1, s.size()-(i+2)));\n  if(s[i]='-')ret.push_back(s.substr(i+2, s.size()-(i+3)));\n  return ret;\n}\n\nbool hogo(bool a, bool b){\n  if(a && !b)return false;\n  return true;\n}\n\nbool calc(string s){\n  // cout<<s<<endl;\n  if(s==\"T\")return true;\n  if(s==\"F\")return false;\n  if(s[0]=='-'){\n    return !calc(s.substr(1,s.size()-1));\n  }\n  int cnt = 0;\n  rep(i,s.size()-1){\n    if(cnt==1){\n      if(s[i]=='*'){\n\tvector<string> sp = spstr(s,i);\n\treturn calc(sp[0])&calc(sp[1]);\n      }\n      if(s[i]=='+'){\n\tvector<string> sp = spstr(s,i);\n\treturn calc(sp[0])|calc(sp[1]);\n      }\n      if(s[i]=='-'&&s[i+1]=='>'){\n\tvector<string> sp = spstr(s,i);\n\treturn hogo(calc(sp[0]), calc(sp[1]));\n      }\n    }\n    if(s[i]=='(')cnt++;\n    if(s[i]==')')cnt--;\n  }\n  return false;\n}\n\nstring solve(){\n  bool ans = true;\n  rep(i,(1<<N)){\n    string s = in;\n    rep(j,s.size()){\n      rep(k,alp.size()){\n\tif(s[j]==alp[k]){\n\t   s[j] = has(i,k) ? 'T' : 'F';\n\t}\n      }\n    }\n\n    rep(i,s.size()){\n      if(s[i]=='='){\n\tans &= (calc(s.substr(0,i))==calc(s.substr(i+1,s.size()-(i+1))));\n      }\n    }\n  }\n  return ans ? \"YES\" : \"NO\";\n}\n\nint main(){\n  while(init(),input())cout<<solve()<<endl;\n}"
  },
  {
    "language": "C++",
    "code": "#include <iostream>\nusing namespace std;\n\nstring str;\nint idx;\nint bitpat;\n\n\nint formula(){\n\tchar c;\n\tint a,b;\n\tc = str[idx++];\n\tif(c >= 'a' && c <= 'k') return (bitpat>>(c-'a'))&1;\n\telse if(c == 'T') return true;\n\telse if(c == 'F') return false;\n\telse if(c == '-') return !formula();\n\n\telse if(c == '('){\n\t\ta = formula();\n\t\tc = str[idx++];\n\t\tif(c == '*') b = a & formula();\n\t\telse if(c == '+') b = a | formula();\n\t\telse if(c == '-'){ idx++; b = !a | formula();}\n\t\tidx++;\n\t\treturn b;\n\t}\n}\n\nbool eq(){\n\tint left,right;\n\tleft = formula();\n\tidx++;\n\tright = formula();\n\treturn left == right;\n}\n\nint main(void){\n\n\twhile(cin >> str, str != \"#\"){\n\t\tfor(bitpat = 0; bitpat < (1<<11); bitpat++){\n\t\t\tidx = 0;\n\t\t\tif(!eq()) break;\n\t\t}\n\t\tif(bitpat == (1<<11)) cout<<\"YES\"<<endl;\n\t\telse cout<<\"NO\"<<endl;\n\t\n\t}\n\treturn 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include <iostream>\n#include <string>\n#include <cctype>\n#include <map>\nusing namespace std;\n\ntypedef string::const_iterator State;\nclass ParseError {};\n\nmap<char, bool> variable;\n\nbool equation(State&);\nbool formula(State&);\nbool boolean(State&);\n\nint main(void) {\n    for (int i = 0; i < 11; i++) {\n        variable['a'+i] = false;\n    }\n\n    string s;\n    while (1) {\n        getline(cin, s);\n        if (s == \"#\") break;\n\n        bool flag = true;\n        for (unsigned int i = 0; i < 2048; i++) {\n            if (!flag) break;\n\n            unsigned int val = i;\n            for (int j = 0; j < 11; j++) {\n                if ((val & 1) == 0) {\n                    variable['a'+j] = true;\n                } else {\n                    variable['a'+j] = false;\n                }\n                val <<= 1;\n            }\n\n            State begin = s.begin();\n            if (!equation(begin)) flag = false;\n        }\n\n        if (flag) {\n            cout << \"YES\" << endl;\n        } else {\n            cout << \"NO\" << endl;\n        }\n    }\n\n    return 0;\n}\n\nbool equation(State &begin) {\n    bool left = formula(begin);\n    begin++;                    // '='\n    bool right = formula(begin);\n    // cout << \"left: \" << left << \", right: \" << right << endl;\n    return (left == right) ? true : false;\n}\n\nbool formula(State &begin) {\n    if (*begin == '(') {\n        begin++;                // '('\n        bool ret = formula(begin);\n        if (*begin == '*') {\n            begin++;\n            ret = formula(begin) && ret;\n        } else if (*begin == '+') {\n            begin++;\n            ret = formula(begin) || ret;\n        } else {\n            begin++;\n            if (*begin == '>') {\n                begin++;\n                if (!ret) {\n                    ret = formula(begin) || true;\n                } else {\n                    ret = formula(begin);\n                }\n            } else {\n                ret = !formula(begin);\n            }\n        }\n        begin++;                // ')'\n        return ret;\n    } else if (*begin == '-') {\n        begin++;\n        return !formula(begin);\n    } else {\n        return boolean(begin);\n    }\n}\n\nbool boolean(State &begin) {\n    if (*begin == 'T') {\n        begin++;\n        return true;\n    } else if (*begin == 'F') {\n        begin++;\n        return false;\n    } else {                // a~k\n        bool ret = variable[*begin];\n        begin++;\n        return ret;\n    }\n}"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\n#define rep(i,n) for(int i=0;i<n;i++)\n#define all(x) (x).begin(),(x).end()\nusing namespace std;\nconst int INF=1145141919,MOD=1e9+7;\nconst long long LINF=8931145141919364364,LMOD=998244353;\ninline long long mod(long long n,long long m){return(n%m+m)%m;}\n// const int dx[]={1,0,-1,0,1,1,-1,-1},dy[]={0,-1,0,1,1,-1,-1,1};\n\ntemplate<class T>\nstruct Parser{\n    typedef string::const_iterator itr;\n    itr begin;\n    vector<bool> TF;\n    T ans;\n    Parser(const string &s,const vector<bool> &TF):TF(TF){\n        begin=s.begin();\n        ans=expr(begin);\n    }\n    T expr(itr &begin){\n        if(*begin=='-'){\n            consume(begin,'-');\n            return !expr(begin);\n        }\n        else if(*begin=='('){\n            consume(begin,'(');\n            T ret=expr(begin);\n            if(*begin=='*'){\n                consume(begin,'*');\n                ret&=expr(begin);\n            }\n            if(*begin=='+'){\n                consume(begin,'+');\n                ret|=expr(begin);\n            }\n            if(*begin=='-'&&*(begin+1)=='>'){\n                consume(begin,'-');\n                consume(begin,'>');\n                ret=(!ret|expr(begin));\n            }\n            return ret;\n        }else{\n            char tmp=*begin;\n            begin++;\n            if(tmp=='T') return true;\n            if(tmp=='F') return false;\n            if('a'<=tmp&&tmp<='k') return TF[tmp-'a'];\n        }\n        return true;\n    }\n    void consume(itr &begin,char expected){\n        if(*begin==expected){\n            begin++;\n        }else{\n            fprintf(stderr,\"Expected: '%c' Got: '%c'\\n\",expected,*begin);\n            fprintf(stderr,\"Rest string is \");\n            while(*begin){\n                fprintf(stderr,\"%c\",*begin++);\n            }\n        }\n    }\n};\n\nint main(){\n    string s;\n    while(cin>>s&&s!=\"#\"){\n        string s1,s2;\n        for(int i=0;;i++){\n            if(s[i]=='='){\n                s1=s.substr(0,i);\n                s2=s.substr(i+1);\n                break;\n            }\n        }\n        bool flg=1;\n        for(int i=0;i<(1<<11);i++){\n            vector<bool> TF(11);\n            for(int j=0;j<11;j++){\n                TF[j]=(i>>j);\n            }\n            Parser<bool> p1(s1,TF);\n            Parser<bool> p2(s2,TF);\n            if(p1.ans!=p2.ans){\n                cout<<\"NO\"<<endl;\n                flg=0;\n                break;\n            }\n        }\n        if(flg) cout<<\"YES\"<<endl;\n    }\n    return 0;\n}\n\n"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\nusing namespace std;\n\nint c = 0;\nbool solve(const string& s, int i){\n  c++;\n  switch (s[c-1]){\n    case 'T': return true;\n    case 'F': return false;\n    case '-': return !solve(s,i);\n    case '(':\n      bool l = solve(s,i);\n      c++;\n      switch (s[c-1]){\n        case '*': return l&&solve(s,i);\n        case '+': return l||solve(s,i);\n        case '-': c++; return (!l)||solve(s,i);\n      }\n  }\n  return (i & (1 << (s[c-1] - 'a' - 1))) != 0;\n}\nint main(){\n  string s;\n  while(cin >> s, s != \"#\"){\n    int i;\n    for(i = 0; i <= 0x7f; i++){\n      int eq = s.find(\"=\");\n      c = 0;\n      bool r = solve(s.substr(0,eq), i);\n      c = 0;\n      bool l = solve(s.substr(eq+1), i);\n      if(r != l) break;\n    }\n    if(i>0x7f) cout << \"YES\" << endl;\n    else cout << \"NO\" << endl;\n  }\n}"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\nusing namespace std;\n#define rep(i, n) for (int i = 0; i < int(n); ++i)\n\nconst int N = 11;\n\nbool eval(const string& expr, int tval) {\n    int p = 0;\n    function<bool()> ll1 = [&]() {\n        if (isalpha(expr[p])) {\n            switch (expr[p]) {\n                case 'T': p++; return true;\n                case 'F': p++; return false;\n                default: return (tval >> (expr[p++] - 'a') & 1) == 1;\n            }\n        }\n        if (expr[p] == '-' and expr[p + 1] != '>') { p++; return not ll1(); }\n        if (expr[p] == '(') {\n            p++;\n            bool x = ll1();\n            char op = expr[p++];\n            if (op == '-') p++;\n            bool y = ll1();\n            p++;\n            return op == '+' ? x or y : op == '*' ? x and y : (not x) or (x and y);\n        }\n    };\n    return ll1();\n}\n\nbool solve(const string& expr) {\n    auto p = expr.find_first_of('=');\n    string lhs = expr.substr(0, p - 1), rhs = expr.substr(p + 1);\n    rep(tval, 1 << N) if (eval(lhs, tval) != eval(rhs, tval)) return false;\n    return true;\n}\n\nint main() {\n    for (string expr; cin >> expr, expr != \"#\";) cout << (solve(expr) ? \"YES\" : \"NO\") << endl;\n}"
  },
  {
    "language": "C++",
    "code": "#include <iostream>\n#include <algorithm>\n#include <string>\n#include <sstream>\n#include <vector>\n\nusing namespace std;\n\n#define rep(i,n) for(int i=0;i<n;++i)\n\n\nbool solve(string s){\n\tstringstream ss;\n\tbool f=false;\n\trep(i,s.size()){\n\t\tif(i+1<s.size()&&s[i]=='-'&&(s[i+1]=='T'||s[i+1]=='F')){\n\t\t\tif(s[i+1]=='T') ss<<'F';\n\t\t\telse ss<<'T';\n\t\t\ti++;\n\t\t\tf=true;\n\t\t}\n\t\telse if(i+4<s.size()&&s[i]=='('&&(s[i+1]=='T'||s[i+1]=='F')&&s[i+2]=='*'&&(s[i+3]=='T'||s[i+3]=='F')&&s[i+4]==')'){\n\t\t\tf=true;\n\t\t\tif(s[i+1]=='F'||s[i+3]=='F') ss<<'F';\n\t\t\telse ss<<'T';\n\t\t\ti+=4;\n\t\t}\n\t\telse if(i+4<s.size()&&s[i]=='('&&(s[i+1]=='T'||s[i+1]=='F')&&s[i+2]=='+'&&(s[i+3]=='T'||s[i+3]=='F')&&s[i+4]==')'){\n\t\t\tf=true;\n\t\t\tif(s[i+1]=='F'&&s[i+3]=='F') ss<<'F';\n\t\t\telse ss<<'T';\n\t\t\ti+=4;\n\t\t}\n\t\telse if(i+5<s.size()&&s[i]=='('&&(s[i+1]=='T'||s[i+1]=='F')&&s[i+2]=='-'&&s[i+3]=='>'&&(s[i+4]=='T'||s[i+4]=='F')&&s[i+5]==')'){\n\t\t\tf=true;\n\t\t\tif(s[i+1]=='T'&&s[i+4]=='F') ss<<'F';\n\t\t\telse ss<<'T';\n\t\t\ti+=5;\n\t\t}\n\t\telse ss<<s[i];\n\t}\n\t\t\n\tstring t;\n\tss>>t;\n\tif(f) return solve(t);\n\telse{\n\t\tif(s[0]==s[2]) return true;\n\t}\n\treturn false;\n\t// stringstream ss2;\n\t// s=t;\n\t// rep(i,s.size()-4){\n\t\t// if(s[i]=='('&&(s[i+1]=='T'||s[i+1]=='F')&&s[i+2]=='*'&&(s[i+3]=='T'||s[i+3]=='F')&&s[i+4]==')'){\n\t\t\t// f=true;\n\t\t\t// if(s[i+1]=='F'||s[i+3]=='F') ss2<<'F';\n\t\t\t// else ss2<<'T';\n\t\t\t// i+=4;\n\t\t// }\n\t\t// else{\n\t\t\t// ss2<<s[i];\n\t\t\t// if(i==s.size()-5){\n\t\t\t\t// ss2<<s.substr(i+1);\n\t\t\t// }\n\t\t// }\n\t// }\n\t// string t2;\n\t// ss2>>t2;\n\t// stringstream ss3;\n\t// if(f) return solve(t2);\n\t// rep(i,s.size()-5){\n\t\t// if(s[i]=='('&&(s[i+1]=='T'||s[i+1]=='F')&&s[i+2]=='-'&&s[i+3]=='>'&&(s[i+4]=='T'||s[i+4]=='F')&&s[i+5]==')'){\n\t\t\t// f=true;\n\t\t\t// if(s[i+1]=='T'&&s[i+4]=='F') ss3<<'F';\n\t\t\t// else ss3<<'T';\n\t\t\t// i+=5;\n\t\t// }\n\t\t// else{\n\t\t\t// ss3<<s[i];\n\t\t\t// if(i==s.size()-6){\n\t\t\t\t// ss3<<s.substr(i+1);\n\t\t\t// }\n\t\t// }\n\t// }\n\t// string t3;\n\t// ss3>>t3;\n\t// if(f) return solve(t3);\n\t// s=t3;\n\t// if()\n\n}\n\nint main(){\n\tstring s;\n\twhile(cin>>s,s!=\"#\"){\n\t\tint c=0;\n\t\trep(i,'k'-'a'+1){\n\t\t\tchar t=i+'a';\n\t\t\trep(j,s.size()){\n\t\t\t\tif(s[j]==t){\n\t\t\t\t\trep(k,s.size()){\n\t\t\t\t\t\tif(s[k]==t) s[k]='A'+c;\n\t\t\t\t\t}\n\t\t\t\t\tc++;\n\t\t\t\t\tbreak;\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t\t// cout<<(1<<c)<<endl;\n\t\tint lim=(1<<c);\n\t\t// cout<<t<<endl;\n\t\tbool f=true;\n\t\trep(i,lim){\n\t\t\tstring tmp=s;\n\t\t\trep(j,tmp.size()){\n\t\t\t\tif(tmp[j]>='A'&&tmp[j]<='A'+c){\n\t\t\t\t\tif(i&1<<(tmp[j]-'A')){\n\t\t\t\t\t\t// cout<<tmp[j]<<\" = T\"<<endl;\n\t\t\t\t\t\ttmp[j]='T';\n\t\t\t\t\t}\n\t\t\t\t\telse{\n\t\t\t\t\t\t// cout<<tmp[j]<<\" = F\"<<endl;\n\t\t\t\t\t\ttmp[j]='F';\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t}\n\t\t\t// cout<<endl;\n\t\t\tif(!solve(tmp)){\n\t\t\t\tf=false;\n\t\t\t\tbreak;\n\t\t\t}\n\t\t}\n\t\tif(f) cout<<\"YES\\n\";\n\t\telse cout<<\"NO\\n\";\n\t\t// cout<<s<<endl;\n\t}\n}"
  },
  {
    "language": "C++",
    "code": "#include <iostream>\n#include <complex>\n#include <sstream>\n#include <string>\n#include <algorithm>\n#include <deque>\n#include <list>\n#include <map>\n#include <numeric>\n#include <queue>\n#include <vector>\n#include <set>\n#include <limits>\n#include <cstdio>\n#include <cctype>\n#include <cmath>\n#include <cstring>\n#include <cstdlib>\n#include <ctime>\nusing namespace std;\n#define REP(i, j) for(int i = 0; i < (int)(j); ++i)\n#define FOR(i, j, k) for(int i = (int)(j); i < (int)(k); ++i)\n#define P pair<int, int>\n#define SORT(v) sort((v).begin(), (v).end())\n#define REVERSE(v) reverse((v).begin(), (v).end())\n\nstring s;\nint now;\nbool is_skip;\nset<char> chars;\n\nbool check(bool x, char op, bool y){\n  if(op == '*'){\n    if(x && y) return true;\n    else return false;\n  } else if(op == '+'){\n    if(!x && !y) return false;\n    else return true;\n  } else if(op == '>'){\n    if(x && !y) return false;\n    return true;\n  }\n  return false;\n}\n\nbool formula(){\n  //cout <<s <<\", \" <<s[now] <<endl;\n  if(s[now] == 'T'){\n    ++now;\n    return true;\n  } else if(s[now] == 'F'){\n    ++now;\n    return false;\n  } else if(s[now] == '-'){\n    ++now;\n    bool res = formula();\n    return !res;\n  } else if(s[now] == '('){\n    ++now;\n    bool x = formula();\n    char op = s[now];\n    ++now;\n    bool y = formula();\n    //cout <<x <<\" \" <<op <<\" \" <<y <<endl;\n    return check(x, op, y);\n  }\n  return false;\n}\n\nmap<char, char> get_m(int bit){\n  map<char, char> ret;\n  for(int i = 0; i < 11; ++i){\n    if(bit & (1 << i)) ret['a' + i] = 'T';\n    else ret['a' + i] = 'F';\n  }\n  is_skip = true;\n  for(set<char>::iterator it = chars.begin(); it != chars.end(); ++it)\n    if(ret[(*it)]) is_skip = false;\n  return ret;\n}\n\nbool calc(){\n  stringstream left_ss, right_ss;\n  bool left_end = false;\n  REP(i, s.length()){\n    if(s[i] == '=') left_end = true;\n    else{\n      if(left_end) right_ss << s[i];\n      else left_ss << s[i];\n    }\n  }\n  string left = left_ss.str(), right = right_ss.str();\n  REP(i, s.length())\n  REP(i, (1 << 11)){\n    string tmp_l = left, tmp_r = right;\n    map<char, char> m = get_m(i);\n    if(is_skip) continue;\n    REP(i, left.length()) if(isalpha(left[i]) && left[i] != 'T' && left[i] != 'F') left[i] = m[left[i]];\n    REP(i, right.length()) if(isalpha(right[i]) && right[i] != 'T' && right[i] != 'F') right[i] = m[right[i]];\n    s = left; now = 0;\n    bool left_ans = formula();\n    s = right; now = 0;\n    bool right_ans = formula();\n    //debug\n    //cout <<left <<\", \" <<right <<\" | \" <<left_ans <<\", \" <<right_ans <<endl;\n    if(left_ans != right_ans){\n      return false;\n    }\n    left = tmp_l; right = tmp_r;\n  }\n  return true;\n}\n\nint main() {\n  while(cin >>s && s != \"#\"){\n    chars = set<char>();\n    stringstream ss;\n    REP(i, s.length()){\n      if(i + 1 != s.length() && s[i] == '-' && s[i + 1] == '>'){\n        ss << '>';\n        ++i;\n      } else{\n        if(isalpha(s[i])) chars.insert(s[i]);\n        ss << s[i];\n      }\n    }\n    s = ss.str();\n    cout <<(calc() ? \"YES\" : \"NO\") <<endl;\n  }\n  return 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include <iostream>\n#include <string>\n#include <algorithm>\n#include <cstdio>\n#include <cassert>\n#include <vector>\n#include <map>\n\nusing namespace std;\nmap<char,bool> assign;\n\nbool formula(string &arg, int &pos){\n    if('a' <= arg[pos] && arg[pos] <= 'k'){\n        return assign[arg[pos++]];\n    }else if(arg[pos] == '-'){\n        return !formula(arg, ++pos);\n    }else if(arg[pos] == 'T'){\n        pos++;\n        return true;\n    }else if(arg[pos] == 'F'){\n        pos++;\n        return false;\n    }else{\n        assert(arg[pos] == '(');\n        bool f,b;\n        char op;\n        f = formula(arg, ++pos);\n        op = arg[pos];\n        assert(op == '*' || op == '+' || op == '-');\n        if(op == '-') pos++;\n        b = formula(arg, ++pos);\n        assert(arg[pos] == ')');\n        pos++;\n        if(op == '*'){\n            if(f&&b) return true;\n            return false;\n        }else if(op == '+'){\n            if(!f&&!b) return false;\n            return true;\n        }else{\n            if(f && !b) return false;\n            return true;\n        }\n    }\n}\n\nbool parse(string &arg, int pos){\n    bool f,b;\n\n    f = formula(arg, pos);\n    assert(arg[pos] == '=');\n    b = formula(arg, ++pos);\n    return f == b;\n}\n\n\nint main(){\n    string str;\n    while(cin >> str){\n        if(str == \"#\") break;\n        int var = 0;    \n        vector<char> vars;\n        bool res = true;\n\n        assign.clear();\n        for(int i=0;i<(int)str.size();i++){\n            if('a' <= str[i] && str[i] <= 'k'){\n                var++;\n                vars.push_back(str[i]);\n            }\n        }\n\n        for(int i=0;i<(1 << var);i++){\n            for(int j=0;j<var;j++){\n                if(i & (1 << j)){\n                    assign[vars[j]] = true;\n                }else{\n                    assign[vars[j]] = false;\n                }\n            }\n            res = parse(str, 0);\n            if(!res) break;\n        }\n        if(res){\n            cout << \"YES\" << endl;\n        }else{\n            cout << \"NO\" << endl;\n        }\n    }\n}"
  },
  {
    "language": "C++",
    "code": "#include <iostream>\n#include <fstream>\n#include <algorithm>\n#include <bitset>\n#include <cassert>\n#include <cctype>\n#include <cmath>\n#include <complex>\n#include <cstdio>\n#include <cstdlib>\n#include <cstring>\n#include <ctime>\n#include <deque>\n#include <iomanip>\n#include <map>\n#include <numeric>\n#include <queue>\n#include <set>\n#include <stack>\n#include <sstream>\n#include <string>\n#include <vector>\nusing namespace std;\n\n#pragma comment(linker, \"/STACK:400000000\")\n\n#define EPS 1e-9\n#define INF MOD\n#define MOD 1000000007LL\n#define fir first\n#define foreach(it,X) for(it=X.begin();it!=X.end();it++)\n#define iss istringstream\n#define ite iterator\n#define ll long long\n#define mp make_pair\n#define rep(i,n) rep2(i,0,n)\n#define rep2(i,m,n) for(int i=m;i<n;i++)\n#define pi pair<int,int>\n#define pb push_back\n#define sec second\n#define sh(i) (1LL<<i)\n#define sst stringstream\n#define sz size()\n#define vi vector<int>\n#define vc vector\n#define vl vector<ll>\n#define vs vector<string>\n\nstring s;\nint cur,val[12];\n\nint formula(){\n\tif(islower(s[cur])){\n\t\tint res=val[s[cur++]-'a'];\n\t\treturn res;\n\t}\n\tif(s[cur]=='T'){\n\t\tcur++;\n\t\treturn 1;\n\t}\n\tif(s[cur]=='F'){\n\t\tcur++;\n\t\treturn 0;\n\t}\n\tif(s[cur]=='-'){\n\t\tcur++;\n\t\treturn !formula();\n\t}\n\tcur++;\n\tint res1=formula();\n\tif(s[cur]=='*'){\n\t\tcur++;\n\t\tint res2=formula();\n\t\tcur++;\n\t\treturn res1&res2;\n\t}\n\tif(s[cur]=='+'){\n\t\tcur++;\n\t\tint res2=formula();\n\t\tcur++;\n\t\treturn res1|res2;\n\t}\n\tcur+=2;\n\tint res2=formula();\n\tcur++;\n\treturn !res1|res2;\n}\n\nint main(){\n\tstring in;\n\twhile(cin>>in && in!=\"#\"){\n\t\tstring s1,s2;\n\t\tint equal=0;\n\t\trep(i,in.sz){\n\t\t\tif(in[i]=='=')equal=1;\n\t\t\telse if(equal==0)s1+=in[i];\n\t\t\telse s2+=in[i];\n\t\t}\n\t\tint ans=1;\n\t\trep(i,1<<11){\n\t\t\trep(j,11)val[j]=i>>j&1;\n\t\t\ts=s1;\n\t\t\tcur=0;\n\t\t\tint res1=formula();\n\t\t\ts=s2;\n\t\t\tcur=0;\n\t\t\tint res2=formula();\n\t\t\tif(res1!=res2){\n\t\t\t\tans=0;break;\n\t\t\t}\n\t\t}\n\t\tcout<<(ans ? \"YES\":\"NO\")<<endl;\n\t}\n}"
  },
  {
    "language": "C++",
    "code": "#include<iostream>\n#include<string>\nusing namespace std;\n\nstring s;\nint use;\n\nstring ReplaceAll(string s,string a, string b){\n  int p = s.find(a);\n  while(p!=string::npos){\n    s.replace(p,a.size(),b);\n    p = s.find(a);\n  }\n  return s;\n}\n\nbool parse(int l,int r){\n  int p = 0;\n  for(int i=l;i<r;i++){\n    if(s[i] == '(')p++;\n    if(s[i] == ')')p--;\n    if(!p){\n      if(s[i] == '*')return parse(l,i) && parse(i+1,r);\n      if(s[i] == '+')return parse(l,i) || parse(i+1,r);\n      if(s[i] == '-' && s[i+1] == '>')return !parse(l,i) || parse(i+2,r);\n    }\n  }\n\n  if(s[l] == '-')return !parse(l+1,r);\n  if(s[l] == '(' && s[r-1] == ')')return parse(l+1,r-1);\n  if(s[l] == 'T')return true;\n  if(s[l] == 'F')return false;\n  return ( ( use >> (s[l]-'a') ) & 1);\n}\n\nint main(){\n  while(cin >> s,s!=\"#\"){\n    s = ReplaceAll(s,\"--\",\"\");\n    int x = s.find(\"=\");\n    bool f = true;\n    for(use=0;use<(1<<11);use++){\n      f &= parse(0,x) == parse(x+1,s.size());\n      if(!f)break;\n    }\n    cout << (f?\"YES\\n\":\"NO\\n\");\n  }\n}"
  },
  {
    "language": "C++",
    "code": "#include <iostream>\n#include <algorithm>\n#include <string>\n#include <vector>\nusing namespace std;\n\nconst int INF = 1e+8;\n\n// 変数 'a' - 'k' を value に置き換え\nvoid change(string& s, char x, char value){\n\tfor(int i=0 ; i < s.size() ; i++ ){\n\t\tif( s[i] == x ) s[i] = value;\n\t}\n}\n\n// 式から \"--\" の除去\nvoid minus_erase(string& s){\n\tfor(int i=1 ; i < s.size() ; i++ ){\n\t\tif( s[i-1] == '-' && s[i] == '-' ){\n\t\t\ts.erase( i-1 , 2 );\n\t\t\ti = 0;\n\t\t}\n\t}\n}\n\nint eval(string s, int& pos){\n\tif( s[pos] == 'F' ){ pos++; return 0; }\n\tif( s[pos] == 'T' ){ pos++; return 1; }\n\tif( s[pos] == '-' ){ pos++; return 1 - eval(s,pos) ; }\n\tif (s[pos] == '(') { \n\t\t++pos; \n\t\tint a = eval(s, pos);\n\t\tchar c = s[pos++];\n\t\tint b = eval(s, pos);\n\t\t++pos;\n\t\tif( c == '*' ){\n\t\t\treturn a & b;\n\t\t}else if( c == '+' ){\n\t\t\treturn a | b;\n\t\t}else if( c == '>' ){\n\t\t\treturn (a == 1 && b == 0)? 0 : 1 ;\n\t\t}\n\t}\n}\n\nint main(){\n\tstring s;\n\twhile( cin >> s ){\n\t\tif( s == \"#\" ) break;\n\t\t\n\t\t// \"->\" を \">\" に置き換えておく\n\t\tstring s_;\n\t\tfor(int i=0 ; i < s.size() ; i++ ){\n\t\t\tif( i+1 < s.size() && s[i] == '-' &&s[i+1] == '>' ){\n\t\t\t\ts_.push_back( '>' );\n\t\t\t\ti++;\n\t\t\t}else{\n\t\t\t\ts_.push_back( s[i] );\n\t\t\t}\n\t\t}\n\t\ts = s_;\n\t\t// '=' の左側を ex1, 右側を ex2 とする\n\t\tstring ex1, ex2;\n\t\tbool flag = false;\n\t\tfor(int i=0 ; i < s.size() ; i++ ){\n\t\t\tif( s[i] == '=' ){\n\t\t\t\tflag = true;\n\t\t\t}else if( flag ){\n\t\t\t\tex2.push_back( s[i] );\n\t\t\t}else{\n\t\t\t\tex1.push_back( s[i] );\n\t\t\t}\n\t\t}\n\t\t// 登場する変数('a' - 'k')をチェック\n\t\tint f[256] = {0};\n\t\tfor(int i = 0 ; i < s.size() ; i++ ){\n\t\t\tf[ s[i] ] = 1;\n\t\t}\n\t\tvector<char> vc;\n\t\tfor(char c = 'a' ; c <= 'k' ; c++ ){\n\t\t\tif( f[c] ){\n\t\t\t\tvc.push_back( c );\n\t\t\t}\n\t\t}\n\t\t// N := 登場する変数の種類.\n\t\tint N = vc.size();\n\t\t// 変数の置き換えを 2^N 通り試し すべての式の評価で右辺と左辺が等しいか調べる.\n\t\tbool ans = true;\n\t\tfor(int bits = 0 ; bits < (1<<N) ; bits++ ){\n\t\t\tstring ex1_ = ex1;\n\t\t\tstring ex2_ = ex2;\n\t\t\t// 変数を \"T\" or \"F\" に置き換えておく\n\t\t\tfor(int i=0 ; i < N ; i++ ){\n\t\t\t\t// i 番目の文字を'T' か 'F'にしておく\n\t\t\t\tif( bits & (1<<i) ){\n\t\t\t\t\tchange( ex1_ , vc[i] , 'T' );\n\t\t\t\t\tchange( ex2_ , vc[i] , 'T' );\n\t\t\t\t}else{\n\t\t\t\t\tchange( ex1_ , vc[i] , 'F' );\n\t\t\t\t\tchange( ex2_ , vc[i] , 'F' );\n\t\t\t\t}\n\t\t\t}\n\t\t\t// \"--\" の除去\n\t\t\tminus_erase( ex1_ );\n\t\t\tminus_erase( ex2_ );\n\t\t\t\n\t\t\t// 式 の評価\n\t\t\tint t=0;\n\t\t\tint val_1 = eval( ex1_ , t );\n\t\t\tt=0;\n\t\t\tint val_2 = eval( ex2_ , t );\n\t\t\t// 式 ex1 と 式 ex2 が等しいかどうか\n\t\t\tif( val_1 != val_2 ){ \n\t\t\t\tans = false;\n\t\t\t\tbreak;\n\t\t\t}\n\t\t}\n\t\t// 出力 \n\t\tif( ans ){\n\t\t\tcout << \"YES\" << endl;\n\t\t}else{\n\t\t\tcout << \"NO\" << endl;\n\t\t}\n\t}\n}"
  },
  {
    "language": "C++",
    "code": "#include<iostream>\n#include<iomanip>\n#include<math.h>\n#include<algorithm>\n#include<string>\n#include<vector>\n#include<queue>\n#include<stack>\n#include<set>\n#include<map>\n#define REP(i, N) for(ll i = 0; i < N; ++i)\n#define FOR(i, a, b) for(ll i = a; i < b; ++i)\n#define ALL(a) (a).begin(),(a).end()\n#define pb push_back\n#define INF (long long)1000000000\n#define MOD 1000000007\nusing namespace std;\ntypedef long long ll;\ntypedef pair<ll, ll> P;\nint dh[4] = {1, 0, -1, 0};\nint dw[4] = {0, 1, 0, -1};\n\nint roc = 0;\nstring s;\nbool formula();\nbool equation();\n\nvector<bool> tf(11);\nbool rec(int n) {\n\tif(n == 11) {\n\t\troc = 0;\n\t\treturn equation();\n\t}\n\telse {\n\t\tbool res = true;\n\t\ttf[n] = true;\n\t\tres = res && rec(n + 1);\n\t\ttf[n] = false;\n\t\tres = res && rec(n + 1);\n\t\treturn res;\n\t}\n}\n\nbool formula() {\n\tif(s[roc] == 'T') {\n\t\t++roc;\n\t\treturn true;\n\t}\n\tif(s[roc] == 'F') {\n\t\t++roc;\n\t\treturn false;\n\t}\n\tif(s[roc] >= 'a' && s[roc] <= 'k') {\n\t\t++roc;\n\t\treturn tf[s[roc - 1] - 'a'];\n\t}\n\tif(s[roc] == '-') {\n\t\t++roc;\n\t\treturn !formula();\n\t}\n\telse {\n\t\t++roc;\n\t\tbool tf1, tf2;\n\t\tchar ope;\n\t\ttf1 = formula();\n\t\tif(s[roc] == '-') {\n\t\t\t++roc;\n\t\t\tope = '-';\n\t\t}\n\t\telse ope = s[roc];\n\t\t++roc;\n\t\ttf2 = formula();\n\t\t++roc;\n\t\tif(ope == '*') return tf1 && tf2;\n\t\tif(ope == '+') return tf1 || tf2;\n\t\telse return (!tf1) || tf2;\n\t}\n}\n\nbool equation() {\n\tbool tf1, tf2;\n\ttf1 = formula();\n\t++roc;\n\ttf2 = formula();\n\tif(tf1 == tf2) return true;\n\telse return false;\n}\n\nint main(void) {\n\twhile(true) {\n\t\tcin>>s;\n\t\tif(s == \"#\") break;\n\t\tif(rec(0)) cout<<\"YES\"<<endl;\n\t\telse cout<<\"NO\"<<endl;\n\t}\n}"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\n\n#define N 11\n\nusing namespace std;\n\nbool parse(string x, bool vars[N]) {\n    int nest = 0;\n    switch (x[0]) {\n        case 'T':\n            return true;\n        case 'F':\n            return false;\n        case '-':\n            return ~parse(x.substr(1), vars);\n        case '(':\n            break;\n        default:\n            if (x[0] < 'a' || 'k' < x[0]) {\n                while (true) {\n                    cout << \"tsu_ra_i\" << endl;\n                }\n            }\n            return vars[x[0]-'a'];\n    }\n    x = x.substr(1, x.length()-2);\n    for (int i=0; i<(int)x.length(); i++) {\n        if (x[i] == '(') {\n            nest++;\n            continue;\n        }\n        if (x[i] == ')') {\n            nest--;\n            continue;\n        }\n        if (nest > 0) {\n            continue;\n        }\n        if (x[i] == '+') {\n            return parse(x.substr(0, i), vars) || parse(x.substr(i+1), vars);\n        }\n        if (x[i] == '*') {\n            return parse(x.substr(0, i), vars) && parse(x.substr(i+1), vars);\n        }\n        if (x.substr(i, 2) == \"->\") {\n            return (~parse(x.substr(0, i), vars)) || parse(x.substr(i+2), vars);\n        }\n    }\n    while (true) {\n        cout << \"tsu_ra_i\" << endl;\n    }\n}\n\nbool is_equal(string x, string y) {\n    bool vars[N];\n    for (int i=0; i<(1<<N); i++) {\n        for (int j=0; j<N; j++) {\n            vars[j] = i&(1<<j);\n        }\n        if (parse(x, vars) != parse(y, vars)) {\n            return false;\n        }\n    }\n    return true;\n}\n\nint main() {\n    string line, x, y;\n    while (true) {\n        cin >> line;\n        if (line == \"#\") {\n            return 0;\n        }\n        for (int i=0; i<(int)line.length(); i++) {\n            if (line[i] == '=') {\n                x = line.substr(0, i);\n                y = line.substr(i+1);\n                break;\n            }\n        }\n        if (is_equal(x, y)) {\n            cout << \"YES\" << endl;\n        }\n        else {\n            cout << \"NO\" << endl;\n        }\n    }\n}"
  },
  {
    "language": "C++",
    "code": "#include<iostream>\nusing namespace std;\n\n#define inRange(x,a,b) (a <= x && x <= b)\ntypedef string::const_iterator State;\n\nint bit;\n\nbool NOT(bool x){\n    return !x;\n}\nbool AND(bool x, bool y){\n    return x&&y;\n}\nbool OR(bool x, bool y){\n    return x||y;\n}\nbool IMP(bool x, bool y){\n    return !x || y;\n}\n\nbool formula(State &begin){\n    if(inRange(*begin, 'a', 'k') || inRange(*begin, 'F', 'T')){\n        char c = *begin;\n        begin++;\n        if(c == 'T')    return true;\n        else if(c == 'F')    return false;\n        return (bit>>(c-'a'))&1;\n    }\n    if(*begin == '-'){\n        begin++;\n        return NOT(formula(begin));\n    }\n    if(*begin == '('){\n        begin++;\n        bool ret = formula(begin);\n        char c = *begin;\n        begin++;\n        if(c == '*')        ret = AND(ret, formula(begin));\n        else if(c == '+')   ret = OR(ret, formula(begin));\n        else if(c == '-')   begin++, ret = IMP(ret, formula(begin));\n        begin++; // ')'\n        return ret;\n    }\n}\n\nint main(){\n    string s;\n    while(cin >> s, s != \"#\"){\n        int eq = 0;\n        while(s[eq] != '=') eq++;\n        string a = s.substr(0, eq), b = s.substr(eq+1);\n        bool valid = true;\n        for(bit = 0; bit < 1<<11; bit++){\n            State ait = a.begin(), bit = b.begin();\n            valid &= formula(ait)==formula(bit);\n        }\n        cout << (valid ? \"YES\" : \"NO\") << endl;\n    }\n    return 0;\n}\n"
  },
  {
    "language": "C++",
    "code": "#include<iostream>\n#include<string>\n#define MAX 11\nusing namespace std;\nbool o;\nvoid rec(string ss){\n  if(!o) return;\n  //cout << s << endl;\n  string s =ss;\n  bool f=false;\n  int p;\n\n  /*\n  while(s.find(\"-0\")!=-1){\n    p=s.find(\"-0\");\n    s[p]='1';s[p+1]=' ';\n    f=true;\n  }\n  while(s.find(\"-1\")!=-1){\n    p=s.find(\"-1\");\n    s[p]='0';s[p+1]=' ';\n    f=true;\n  }\n  while(s.find(\"(0*0)\")!=-1){\n    p=s.find(\"(0*0)\");\n    s[p]='0';s[p+1]=' ';s[p+2]=' ';s[p+3]=' ';s[p+4]=' ';\n    f=true;\n  }\n  while(s.find(\"(0*1)\")!=-1){\n    p=s.find(\"(0*1)\");\n    s[p]='0';s[p+1]=' ';s[p+2]=' ';s[p+3]=' ';s[p+4]=' ';\n    f=true;\n  }\n  while(s.find(\"(1*0)\")!=-1){\n    p=s.find(\"(1*0)\");\n    s[p]='0';s[p+1]=' ';s[p+2]=' ';s[p+3]=' ';s[p+4]=' ';\n    f=true;\n  }\n  while(s.find(\"(1*1)\")!=-1){\n    p=s.find(\"(1*1)\");\n    s[p]='1';s[p+1]=' ';s[p+2]=' ';s[p+3]=' ';s[p+4]=' ';\n    f=true;\n  }\n  while(s.find(\"(0+0)\")!=-1){\n    p=s.find(\"(0+0)\");\n    s[p]='0';s[p+1]=' ';s[p+2]=' ';s[p+3]=' ';s[p+4]=' ';\n    f=true;\n  }\n  while(s.find(\"(0+1)\")!=-1){\n    p=s.find(\"(0+1)\");\n    s[p]='1';s[p+1]=' ';s[p+2]=' ';s[p+3]=' ';s[p+4]=' ';\n    f=true;\n  }\n  while(s.find(\"(1+0)\")!=-1){\n    p=s.find(\"(1+0)\");\n    s[p]='1';s[p+1]=' ';s[p+2]=' ';s[p+3]=' ';s[p+4]=' ';\n    f=true;\n  }\n  while(s.find(\"(1+1)\")!=-1){\n    p=s.find(\"(1+1)\");\n    s[p]='1';s[p+1]=' ';s[p+2]=' ';s[p+3]=' ';s[p+4]=' ';\n    f=true;\n  }\n  \n  while(s.find(\"(0->0)\")!=-1){\n    p=s.find(\"(0->0)\");\n    s[p]='1';s[p+1]=' ';s[p+2]=' ';s[p+3]=' ';s[p+4]=' ';s[p+5]=' ';\n    f=true;\n  }\n  while(s.find(\"(0->1)\")!=-1){\n    p=s.find(\"(0->1)\");\n    s[p]='1';s[p+1]=' ';s[p+2]=' ';s[p+3]=' ';s[p+4]=' ';s[p+5]=' ';\n    f=true;\n  }\n  while(s.find(\"(1->0)\")!=-1){\n    p=s.find(\"(1->0)\");\n    s[p]='0';s[p+1]=' ';s[p+2]=' ';s[p+3]=' ';s[p+4]=' ';s[p+5]=' ';\n    f=true;\n  }\n  while(s.find(\"(1->1)\")!=-1){\n    p=s.find(\"(1->1)\");\n    s[p]='1';s[p+1]=' ';s[p+2]=' ';s[p+3]=' ';s[p+4]=' ';s[p+5]=' ';\n    f=true;\n  }\n  */\n  if(f){\n    string b;\n    for(int i=0;i<s.size();i++) if(s[i]!=' ') b+=s[i];\n    rec(b);\n  }else{\n    if(s[0]!=s[2]) o=false;\n    return;\n  }\n}\nvoid init(int n,string s){\n  int i,j;\n  for(i=0;i<s.size();i++){\n    for(j=0;j<=MAX;j++){\n      if(s[i]=='a'+j) s[i]='0'+(n>>j&1);\n      if(s[i]=='T') s[i]='1';\n      if(s[i]=='F') s[i]='0';\n    }\n  }\n  rec(s);\n  if(!o) return;\n}\nint main(){\n  string s;\n  while(cin >> s,s!=\"#\"){\n    o=true;\n    int i;\n    for(i=0;i<(1<<MAX);i++)\n      if(o) init(i,s);\n      else break;\n    cout << (o?\"YES\":\"NO\") << endl;\n  }\n  return 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include<iostream>\n#include<string>\n#define MAX 11\nusing namespace std;\nbool o;\nvoid rec(string s){\n  if(!o) return;\n  //cout << s << endl;\n  bool f;\n  int p;\n  while(s.find(\"-0\")!=-1){\n    p=s.find(\"-0\");\n    s[p]='1';s[p+1]=' ';\n    f=true;\n  }\n  while(s.find(\"-1\")!=-1){\n    p=s.find(\"-1\");\n    s[p]='0';s[p+1]=' ';\n    f=true;\n  }\n  while(s.find(\"(0*0)\")!=-1){\n    p=s.find(\"(0*0)\");\n    s[p]='0';s[p+1]=' ';s[p+2]=' ';s[p+3]=' ';s[p+4]=' ';\n    f=true;\n  }\n  while(s.find(\"(0*1)\")!=-1){\n    p=s.find(\"(0*1)\");\n    s[p]='0';s[p+1]=' ';s[p+2]=' ';s[p+3]=' ';s[p+4]=' ';\n    f=true;\n  }\n  while(s.find(\"(1*0)\")!=-1){\n    p=s.find(\"(1*0)\");\n    s[p]='0';s[p+1]=' ';s[p+2]=' ';s[p+3]=' ';s[p+4]=' ';\n    f=true;\n  }\n  while(s.find(\"(1*1)\")!=-1){\n    p=s.find(\"(1*1)\");\n    s[p]='1';s[p+1]=' ';s[p+2]=' ';s[p+3]=' ';s[p+4]=' ';\n    f=true;\n  }\n  while(s.find(\"(0+0)\")!=-1){\n    p=s.find(\"(0+0)\");\n    s[p]='0';s[p+1]=' ';s[p+2]=' ';s[p+3]=' ';s[p+4]=' ';\n    f=true;\n  }\n  while(s.find(\"(0+1)\")!=-1){\n    p=s.find(\"(0+1)\");\n    s[p]='1';s[p+1]=' ';s[p+2]=' ';s[p+3]=' ';s[p+4]=' ';\n    f=true;\n  }\n  while(s.find(\"(1+0)\")!=-1){\n    p=s.find(\"(1+0)\");\n    s[p]='1';s[p+1]=' ';s[p+2]=' ';s[p+3]=' ';s[p+4]=' ';\n    f=true;\n  }\n  while(s.find(\"(1+1)\")!=-1){\n    p=s.find(\"(1+1)\");\n    s[p]='1';s[p+1]=' ';s[p+2]=' ';s[p+3]=' ';s[p+4]=' ';\n    f=true;\n  }\n  while(s.find(\"(0->0)\")!=-1){\n    p=s.find(\"(0->0)\");\n    s[p]='1';s[p+1]=' ';s[p+2]=' ';s[p+3]=' ';s[p+4]=' ';s[p+5]=' ';\n    f=true;\n  }\n  while(s.find(\"(0->1)\")!=-1){\n    p=s.find(\"(0->1)\");\n    s[p]='1';s[p+1]=' ';s[p+2]=' ';s[p+3]=' ';s[p+4]=' ';s[p+5]=' ';\n    f=true;\n  }\n  while(s.find(\"(1->0)\")!=-1){\n    p=s.find(\"(1->0)\");\n    s[p]='0';s[p+1]=' ';s[p+2]=' ';s[p+3]=' ';s[p+4]=' ';s[p+5]=' ';\n    f=true;\n  }\n  while(s.find(\"(1->1)\")!=-1){\n    p=s.find(\"(1->1)\");\n    s[p]='1';s[p+1]=' ';s[p+2]=' ';s[p+3]=' ';s[p+4]=' ';s[p+5]=' ';\n    f=true;\n  }\n  if(f){\n    string b;\n    for(int i=0;i<s.size();i++) if(s[i]!=' ') b+=s[i];\n    rec(b);\n  }else{\n    if(s[0]!=s[2]) o=false;\n    return;\n  }\n}\nvoid init(int n,string s){\n  int i,j;\n  for(i=0;i<s.size();i++){\n    for(j=0;j<=MAX;j++){\n      if(s[i]=='a'+j) s[i]='0'+(n>>j&1);\n      if(s[i]=='T') s[i]='1';\n      if(s[i]=='F') s[i]='0';\n    }\n  }\n  //rec(s);\n}\nint main(){\n  string s;\n  while(cin >> s,s!=\"#\"){\n    o=true;\n    int i;\n    for(i=0;i<(1<<MAX);i++)\n      init(i,s);\n    cout << (o?\"YES\":\"NO\") << endl;\n  }\n  return 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include <iostream>\n#include <cstdio>\n#include <cstdlib>\n#include <cmath>\n#include <string>\n#include <vector>\n#include <queue>\n#include <map>\n#include <set>\n#include <algorithm>\n\n#define FOR(i,k,n) for (int i=(k); i<(int)(n); ++i)\n#define REP(i,n) FOR(i,0,n)\n#define FORIT(i,c) for(__typeof((c).begin())i=(c).begin();i!=(c).end();++i)\n#define sz size()\n#define pb push_back\n#define mp make_pair\n#define ALL(X) (X).begin(),(X).end()\n\nusing namespace std;\n\nconst int INF = 1000000000;\nconst double eps = 1e-8;\n\npair<bool,int> isT(string eq,int i) {\n  if(eq[i] == 'T' || eq[i] == 'F')\n    return make_pair(eq[i] == 'T', i);\n  else if(eq[i] == '-')  {\n    auto res = isT(eq,i+1);\n    return make_pair(!res.first, res.second);\n  } else if(eq[i] == '(') {\n    auto res1 = isT(eq,i+1);\n    pair<bool,int> res2;\n    switch(eq[res1.second+1]) {\n      case '-':\n        res2 = isT(eq,res1.second+3);\n        return make_pair(!res1.first || res2.first, res2.second+1);\n        break;\n      case '*':\n        res2 = isT(eq,res1.second+2);\n        return make_pair(res1.first && res2.first, res2.second+1);\n        break;\n      case '+':\n        res2 = isT(eq,res1.second+2);\n        return make_pair(res1.first || res2.first, res2.second+1);\n        break;\n      case '=':\n        res2 = isT(eq,res1.second+2);\n        return make_pair(res1.first == res2.first, res2.second+1);\n        break;\n    }\n  }\n}\n\nbool search(string eq) {\n  vector<bool> isExist(11);\n  for(char c : eq)\n    if(c >= 'a' && c <= 'k')\n      isExist[c-'a'] = true;\n  int mx = -1;\n  REP(i,11)\n    if(isExist[i])\n      mx = i;\n  if(mx != -1) {\n    char c = mx+'a';\n    string cpT = eq;\n    string cpF = eq;\n    for(char& d : cpT)\n      if(c == d)\n        d = 'T';\n    for(char& d : cpF)\n      if(c == d)\n        d = 'F';\n    return search(cpT) && search(cpF);\n  } else {\n    return isT('('+eq+')',0).first;\n  }\n}\n\nint main(void) {\n  while(1) {\n    string eq;\n    cin>>eq;\n    if(eq == \"#\")break;\n    bool res = search(eq);\n    if(res)\n      cout<<\"YES\"<<endl;\n    else\n      cout<<\"NO\"<<endl;\n  }\n  return 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include<bits/stdc++.h>\n#define rep(i,n)for(int i=0;i<(n);i++)\nusing namespace std;\n\nint equ(string&, int&);\nint form(string&, int&);\nint q(string&, int&);\nint num(string&, int&);\n\nint equ(string&s, int&i) {\n\tint v1 = form(s, i); i++;\n\tint v2 = form(s, i);\n\treturn v1 == v2;\n}\nint form(string&s, int&i) {\n\tint mprvc = i;\n\tint v = q(s, i);\n\twhile ((s[i] == '-'&&s[i + 1] == '>') || s[i] == '*' || s[i] == '+') {\n\t\tint prv = i;\n\t\tchar op = s[i++];\n\t\tif (s[i] == '>')op = s[i++];\n\t\tint v2 = q(s, i);\n\t\tif (op == '>') {\n\t\t\tif (!v || v2)v = 1;\n\t\t\telse v = 0;\n\t\t}\n\t\tif (op == '*') {\n\t\t\tif (v&&v2)v = 1;\n\t\t\telse v = 0;\n\t\t}\n\t\tif (op == '+') {\n\t\t\tif (v || v2)v = 1;\n\t\t\telse v = 0;\n\t\t}\n\t}\n\treturn v;\n}\nint q(string&s, int&i) {\n\tif (s[i] == 'T' || s[i] == 'F')return s[i++] == 'T';\n\tif (s[i] == '-') {\n\t\ti++;\n\t\tif (s[i] == 'T' || s[i] == 'F')return s[i] == 'F';\n\t\treturn !form(s, i);\n\t}\n\ti++; int ret = form(s, i); i++;\n\treturn ret;\n}\nint main() {\n\tstring s;\n\twhile (cin >> s, s != \"#\") {\n\t\tmap<char, int>mp;\n\t\tfor (char c : s) {\n\t\t\tif (isalpha(c))mp[c];\n\t\t}\n\t\trep(i, 1 << mp.size()) {\n\t\t\tstring t = s;\n\t\t\tint j = 0;\n\t\t\tfor (auto&p : mp)p.second = ((i >> (j++) & 1) ? 'T' : 'F');\n\t\t\tfor (char&c : t) {\n\t\t\t\tif (isalpha(c))c = mp[c];\n\t\t\t}\n\t\t\tj = 0;\n\t\t\tif (!equ(t, j)) { puts(\"NO\"); goto g; }\n\t\t}\n\t\tputs(\"YES\");\n\tg:;\n\t}\n}"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\n \nusing namespace std;\nusing ll = long long;\n#define int ll\nusing PII = pair<int, int>;\n \n#define FOR(i, a, n) for (ll i = (ll)a; i < (ll)n; ++i)\n#define REP(i, n) FOR(i, 0, n)\n#define ALL(x) x.begin(), x.end()\n \ntemplate<typename T> T &chmin(T &a, const T &b) { return a = min(a, b); }\ntemplate<typename T> T &chmax(T &a, const T &b) { return a = max(a, b); }\ntemplate<typename T> bool IN(T a, T b, T x) { return a<=x&&x<b; }\ntemplate<typename T> T ceil(T a, T b) { return a/b + !!(a%b); }\n\ntemplate<typename T> vector<T> make_v(size_t a) { return vector<T>(a); }\ntemplate<typename T,typename... Ts>\nauto make_v(size_t a,Ts... ts) { \n  return vector<decltype(make_v<T>(ts...))>(a,make_v<T>(ts...));\n}\ntemplate<typename T,typename V> typename enable_if<is_class<T>::value==0>::type\nfill_v(T &t, const V &v) { t=v; }\ntemplate<typename T,typename V> typename enable_if<is_class<T>::value!=0>::type\nfill_v(T &t, const V &v ) { for(auto &e:t) fill_v(e,v); }\n\ntemplate<class S,class T>\nostream &operator <<(ostream& out,const pair<S,T>& a){\n  out<<'('<<a.first<<','<<a.second<<')'; return out;\n}\ntemplate<typename T>\nistream& operator >> (istream& is, vector<T>& vec){\n  for(T& x: vec) {is >> x;} return is;\n}\ntemplate<class T>\nostream &operator <<(ostream& out,const vector<T>& a){\n  out<<'['; for(T i: a) {out<<i<<',';} out<<']'; return out;\n}\n\nint dx[] = {0, 1, 0, -1}, dy[] = {1, 0, -1, 0}; // DRUL\nconst int INF = 1<<30;\nconst ll LLINF = 1LL<<60;\nconst int MOD = 1000000007;\n\nint pos;\nstring s;\n\nchar formula() {\n  if(s[pos] == '-') {\n    pos++;\n    char tmp = formula();\n    // cout << pos << \" \" << tmp << endl;\n    if(tmp == 'F') tmp = 'T';\n    else tmp = 'F';\n    // cout << pos << \" \" << tmp << endl;\n    return tmp;\n  } \n  if(s[pos] == '(') {\n    pos++;\n    char vl = formula();\n    char op = s[pos++];\n    if(op == '-') pos++;\n    char vr = formula();\n    pos++;\n\n    char ret;\n    // cout << op << endl;\n    if(op == '*') {\n      if(vl == 'T' && vr == 'T') ret = 'T';\n      else ret = 'F';\n    } else if(op == '+') {\n      if(vl == 'F' && vr == 'F') ret = 'F';\n      else ret = 'T';\n    } else if(op == '-') {\n      if(vl == 'T' && vr == 'F') ret = 'F';\n      else ret = 'T';\n    }\n    return ret;\n  }\n  return s[pos++];\n}\n\nsigned main(void)\n{\n  cin.tie(0);\n  ios::sync_with_stdio(false);\n\n  while(1) {\n    string t;\n    cin >> t;\n    if(t == \"#\") break;\n\n    int m = 0;\n    map<char,int> mp;\n    REP(i, t.size()) {\n      if(isalpha(t[i]) && t[i]!='T' && t[i]!='F') {\n        if(mp.find(t[i]) == mp.end()) mp[t[i]] = m++;\n      }\n    }\n    REP(i, t.size()) {\n      if(isalpha(t[i]) && t[i]!='T' && t[i]!='F') {\n        t[i] = (char)(mp[t[i]] + 'a');\n      }\n    }\n\n    bool flag = true;\n    REP(i, 1LL<<m) {\n      string str = t;\n      REP(j, str.size()) {\n        if(isalpha(str[j]) && t[i]!='T' && t[i]!='F') {\n          if(i&(1<<(str[j]-'a'))) str[j] = 'T';\n          else str[j] = 'F';\n        }\n      }\n\n      int idx = str.find('=');\n      pos = 0;\n      s = str.substr(0, idx);\n      // cout << s << endl;\n      char vl = formula();\n      // cout << vl << endl;\n      pos = 0;\n      s = str.substr(idx+1);\n      // cout << s << endl;\n      char vr = formula();\n      // cout << vr << endl;\n\n      if(vl != vr) {\n        flag = false;\n        break;\n      }\n    }\n\n    if(flag) {\n      cout << \"YES\" << endl;\n    } else {\n      cout << \"NO\" << endl;\n    }\n  }\n\n  return 0;\n}\n\n"
  },
  {
    "language": "C++",
    "code": "#include <cstdio>\n#include <cassert>\n\nusing namespace std;\nstruct Node{\n  char term;\n  Node *left,*right;\n};\nNode reserved[1000];\n\nchar peek(){\n  char c=getchar();\n  ungetc(c,stdin);\n  return c;\n}\n\nint cnt;\nNode* read(){\n  char c=getchar();\n  int cur=cnt++;\n  switch(c){\n  case '(':\n    reserved[cur].left=read();\n    if(peek()=='-'){\n      getchar();\n      reserved[cur].term=getchar();\n    }else\n      reserved[cur].term=getchar();\n    reserved[cur].right=read();\n    assert(getchar()==')');\n    return reserved+cur;\n  case '-':\n    reserved[cur].term='-';\n    reserved[cur].left=read();\n    return reserved+cur;\n  default:\n    reserved[cur].term=c;\n    return reserved+cur;\n  }\n}\n\nint eval(Node *n,int vars){\n  bool l,r;\n  switch(n->term){\n  case 'T':\n    return 1;\n  case 'F':\n    return 0;\n  case '-':\n    return !(eval(n->left,vars));\n  case '*':\n    l=eval(n->left,vars),r=eval(n->right,vars);\n    return l&&r;\n  case '+':\n    l=eval(n->left,vars),r=eval(n->right,vars);\n    return l||r;\n  case '>':\n    l=eval(n->left,vars),r=eval(n->right,vars);\n    return !l||r;\n  default:\n    int var=n->term-'a';\n    return (vars>>var)&1;\n  }\n}\n\nint main(){\n  Node *l,*r;\n  while(peek()!='#'){\n    cnt=0;\n    l=read(); assert(getchar()=='=');\n    r=read(); assert(getchar()=='\\n');\n    bool flag=true;\n    for(int vars=0; vars<1<<11; vars++){\n      if(eval(l,vars)!=eval(r,vars)){\n\tflag=false;\n      }\n    }\n    if(flag)\n      printf(\"YES\\n\");\n    else\n      printf(\"NO\\n\");\n  }\n}"
  },
  {
    "language": "C++",
    "code": "#include<iostream>\nusing namespace std;\n\nint p;\nchar s[1024];\nint v;\n\nint fomula(){\n\tchar c=s[p++];\n\tswitch(c){\n\t\tcase 'T':\n\t\t\treturn 1;\n\t\tcase 'F':\n\t\t\treturn 0;\n\t\tcase 'a':case 'b':case 'c':case 'd':case 'e':case 'f':\n\t\tcase 'g':case 'h':case 'i':case 'j':case 'k':\n\t\t\treturn v>>c-'a'&1;\n\t\tcase '-':\n\t\t\treturn !fomula();\n\t\tcase '(':\n\t\t\tint a,b;\n\t\t\tchar op;\n\t\t\ta=fomula();\n\t\t\top=s[p++];\n\t\t\tif(op=='-')p++;\n\t\t\tb=fomula();\n\t\t\tp++;\n\t\t\tif(op=='*')return a&&b;\n\t\t\tif(op=='+')return a||b;\n\t\t\treturn !(a&&!b);\n\t\tdefault: cout<<-1<<endl;\n\t}\n}\nint main(){\n\twhile(cin>>s&&s[0]!='#'){\n\t\tint ok=1,a,b;\n\t\tfor(v=0;ok&&v<(1<<11);v++){\n\t\t\tp=0;\n\t\t\ta=fomula();\n\t\t\tp++;\n\t\t\tb=fomula();\n\t\t\tok=(a==b);\n\t\t}\n\t\tcout<<(ok?\"YES\":\"NO\")<<endl;\n\t}\n\treturn 0;\t\n}"
  },
  {
    "language": "C++",
    "code": "#include <iostream>\n#include <sstream>\n#include <string>\n#include <algorithm>\n#include <vector>\n#include <stack>\n#include <queue>\n#include <set>\n#include <map>\n#include <cstdio>\n#include <cstdlib>\n#include <cstring>\n#include <cmath>\n#include <cassert>\n//C++11\n#if __cplusplus == 201103L\n#include <tuple>\n#endif\n\nusing namespace std;\n\n#define FOR(i,k,n) for(int i=(k); i<(int)n; ++i)\n#define REP(i,n) FOR(i,0,n)\n#define FORIT(i,c) for(__typeof((c).begin())i=(c).begin();i!=(c).end();++i)\n\ntemplate<class T> void debug(T begin, T end){ for(T i = begin; i != end; ++i) cout<<*i<<\" \"; cout<<endl; }\n\ntypedef long long ll;\nconst int INF = 100000000;\nconst double EPS = 1e-8;\nconst int MOD = 1000000007;\nint S;\nbool equation(string& s, int& p){\n  if(s[p] == '-'){\n    p++;\n    bool v = equation(s, p);\n    return !v;\n  }else if(s[p] == '('){\n    p++;\n    bool v1 = equation(s, p);\n    char ope = s[p++];\n    if(ope == '-') assert(s[p++] == '>');\n    bool v2 = equation(s, p);\n    assert(s[p++] == ')');\n    if(ope == '*'){\n      return v1 && v2;\n    }else if(ope == '+'){\n      return v1 || v2;\n    }else if(ope == '-'){\n      return !v1 || v2;\n    }\n  }else if(s[p] == 'T'){\n    p++;\n    return true;\n  }else if(s[p] == 'F'){\n    p++;\n    return false;\n  }else if(s[p] >= 'a' && s[p] <= 'k'){\n    bool res = (S & (1<<(s[p++]-'a')));\n    return res;\n  }else{\n    fprintf(stderr, \"%c is not expected\\n\", s[p]);\n    exit(EXIT_FAILURE);\n  }\n}\n\nint main(){\n  string s1, s2, s;\n  while(cin>>s){\n    if(s == \"#\") break;\n    REP(i, s.size()) if(s[i] == '=') s1 = s.substr(0, i), s2 = s.substr(i+1);\n    bool ans = true;\n    for(S = 0; S < 1<<11; S++){\n      int p = 0;\n      bool eq1 = equation(s1, p);\n      p = 0;\n      bool eq2 = equation(s2, p);\n      if(eq1 != eq2) ans = false;\n    }\n    if(ans) cout<<\"YES\"<<endl;\n    else cout<<\"NO\"<<endl;\n  }\n  return 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include<bits/stdc++.h>\nusing namespace std;\n\nint cnt = 0;\nchar S[1024];\nbool at[12];\n\nbool count(char c){\n  if( S[cnt] == c ) cnt++;\n  else return false;\n  return true;\n}\n\nbool get(char c){\n  return at[c-'a'];\n}\n\nbool calc( bool a, bool b, char c ){\n  if( c == '*' ) return a&b;\n  if( c == '+' ) return a|b;\n  return ~(a&(~b));\n}\n\nbool formula(){\n  if( count('-') ){\n    return ~formula();\n  } else if( count('T') ){\n    return true;\n  } else if( count('F') ){\n    return false;\n  } else if( count('(') ){\n    bool a = formula();\n    char c;\n    if( count( '*' ) ) c = '*';\n    else if( count('+') ) c = '+';\n    else if( count('-') && count('>') ) c='>';\n    else assert(false);\n    bool b = formula();\n    bool r = calc( a, b, c );\n    count( ')' );\n    return r;\n  } else {\n    char c = S[cnt];\n    assert( 'a' <= c && c <= 'k' );\n    count(c);\n    return get(c);\n  }  \n}\n\nbool equation(){\n  cnt=0;\n  bool a = formula();\n  count( '=' );\n  bool b = formula();\n  return a==b;\n}\n\nint main(){\n  while( cin >> S ){\n    if( S[0] == '#' ) break;\n    bool ret = true;\n    for(int i=0;i<(1<<11);i++){\n      for(int j=0;j<11;j++) at[j] = i&(1<<j);\n      if( !equation() ){ ret = false; break;}\n    }\n    if( ret ) cout << \"YES\" << endl;\n    else cout << \"NO\" << endl;\n  }\n}"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\nusing namespace std;\n\nint c = 0;\nbool solve(const string& s, int i){\n  c++;\n  switch (s[c-1]){\n    case 'T': return true;\n    case 'F': return false;\n    case '-': return !solve(s,i);\n    case '(':\n      bool l = solve(s,i);\n      char op = s[c];\n      c++;\n      if(op=='-') c++;\n      bool r = solve(s,i);\n      c++;\n      switch (s[c-1]){\n        case '*': return l&r;\n        case '+': return l|r;\n        case '-': return (!l)|r;\n      }\n  }\n  return (i & (1 << (s[c-1] - 'a' - 1))) != 0;\n}\nint main(){\n  string s;\n  while(cin >> s, s != \"#\"){\n    int i;\n    for(i = 0; i <= 0x7ff; i++){\n      int eq = s.find(\"=\");\n      c = 0;\n      bool r = solve(s.substr(0,eq), i);\n      c = 0;\n      bool l = solve(s.substr(eq+1), i);\n      if(r != l) break;\n    }\n    if(i>0x7ff) cout << \"YES\" << endl;\n    else cout << \"NO\" << endl;\n  }\n}"
  },
  {
    "language": "C++",
    "code": "// Equation\nimport java.util.*;\n\npublic class Main {\n\tstatic int pos;\n\tstatic String equation;\n\tstatic int a, b, c, d, e, f, g, h, i, j, k;\n\n\tpublic static void main(String[] args) {\n\t\tScanner scanner = new Scanner(System.in);\n\t\twhile (true) {\n\t\t\tequation = scanner.next();\n\t\t\tif (equation.equals(\"#\"))\n\t\t\t\tbreak;\n\t\t\tboolean result = true;\n\t\t\tout: for (a = 0; a < 2; a++)\n\t\t\t\tfor (b = 0; b < 2; b++)\n\t\t\t\t\tfor (c = 0; c < 2; c++)\n\t\t\t\t\t\tfor (d = 0; d < 2; d++)\n\t\t\t\t\t\t\tfor (e = 0; e < 2; e++)\n\t\t\t\t\t\t\t\tfor (f = 0; f < 2; f++)\n\t\t\t\t\t\t\t\t\tfor (g = 0; g < 2; g++)\n\t\t\t\t\t\t\t\t\t\tfor (h = 0; h < 2; h++)\n\t\t\t\t\t\t\t\t\t\t\tfor (i = 0; i < 2; i++)\n\t\t\t\t\t\t\t\t\t\t\t\tfor (j = 0; j < 2; j++)\n\t\t\t\t\t\t\t\t\t\t\t\t\tfor (k = 0; k < 2; k++) {\n\t\t\t\t\t\t\t\t\t\t\t\t\t\tpos = 0;\n\t\t\t\t\t\t\t\t\t\t\t\t\t\tresult = result\n\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t&& eval();\n\t\t\t\t\t\t\t\t\t\t\t\t\t\tif (!result)\n\t\t\t\t\t\t\t\t\t\t\t\t\t\t\tbreak out;\n\t\t\t\t\t\t\t\t\t\t\t\t\t}\n\t\t\tif (result)\n\t\t\t\tSystem.out.println(\"YES\");\n\t\t\telse\n\t\t\t\tSystem.out.println(\"NO\");\n\t\t}\n\t\tscanner.close();\n\t}\n\n\tstatic boolean eval() {\n\t\tboolean boola = formura();\n\t\tpos++;\n\t\tboolean boolb = formura();\n\t\treturn boola == boolb;\n\t}\n\n\tstatic boolean formura() {\n\t\tchar cha = equation.charAt(pos);\n\t\tpos++;\n\t\tswitch (cha) {\n\t\tcase 'T':\n\t\t\treturn true;\n\t\tcase 'F':\n\t\t\treturn false;\n\t\tcase 'a':\n\t\t\treturn a == 1;\n\t\tcase 'b':\n\t\t\treturn b == 1;\n\t\tcase 'c':\n\t\t\treturn c == 1;\n\t\tcase 'd':\n\t\t\treturn d == 1;\n\t\tcase 'e':\n\t\t\treturn e == 1;\n\t\tcase 'f':\n\t\t\treturn f == 1;\n\t\tcase 'g':\n\t\t\treturn g == 1;\n\t\tcase 'h':\n\t\t\treturn h == 1;\n\t\tcase 'i':\n\t\t\treturn i == 1;\n\t\tcase 'j':\n\t\t\treturn j == 1;\n\t\tcase 'k':\n\t\t\treturn k == 1;\n\t\tcase '-':\n\t\t\treturn !formura();\n\t\tcase '(':\n\t\t\tboolean boola = formura();\n\t\t\tchar chb = equation.charAt(pos);\n\t\t\tpos++;\n\t\t\tboolean boolb;\n\t\t\tswitch (chb) {\n\t\t\tcase '*':\n\t\t\t\tboolb = formura();\n\t\t\t\tpos++;\n\t\t\t\treturn boola && boolb;\n\t\t\tcase '+':\n\t\t\t\tboolb = formura();\n\t\t\t\tpos++;\n\t\t\t\treturn boola || boolb;\n\t\t\tcase '-':\n\t\t\t\tpos++;\n\t\t\t\tboolb = formura();\n\t\t\t\tpos++;\n\t\t\t\treturn !boola || boolb;\n\t\t\t}\n\t\t}\n\t\treturn false;\n\t}\n}"
  },
  {
    "language": "C++",
    "code": "#include <iostream>\n#include <map>\n#include <string>\n#include <cstring>\n#include <vector>\n#include <algorithm>\n#include <cstdio>\nusing namespace std;\n\n// C\n\nbool alpha[13];\n\n\n\nbool NOT(bool x){\n    return !x;\n}\n\nbool AND(bool x, bool y){\n    return (x && y);\n}\n\nbool OR(bool x, bool y){\n    return (x || y);\n}\n\nbool IMP(bool x, bool y){\n    if( x == true && y == false ) return false;\n    return true;\n}\n\n\nbool formula(string str){\n    int i;\n\n    //cout << \"debug : \" << str << endl;\n\n    if( str.length() == 1 ){ // alpha or T or F\n        if( str[0] == 'T' ) return true;\n        if( str[0] == 'F' ) return false;\n        return alpha[str[0] - 'a'];\n    }\n\n    // *,+,->\n    int x = 0;\n    for(i=0; i<str.length(); i++){\n        if( str[i] == '(' ) x++;\n        if( str[i] == ')' ) x--;\n        if( x == 0 && (str[i] == '*' || str[i] == '+' ||\n                       (i+1<str.length() && str[i] == '-' && str[i+1] == '>')) ){\n            \n            break;\n        }\n    }\n\n    if( i < str.length() ){ // \"*\" or \"+\" or \"->\"\n        if( str[i] == '*' ){\n            return AND(formula(str.substr(0,i)), formula(str.substr(i+1)));\n        }\n        else if( str[i] == '+' ){\n            return OR(formula(str.substr(0,i)), formula(str.substr(i+1)));\n        }\n        else{\n            return IMP(formula(str.substr(0,i)), formula(str.substr(i+2)));\n        }\n    }\n\n    // NOT\n    if( str[0] == '-' ){\n        //puts(\"NOT\");\n        return NOT(formula(str.substr(1)));\n    }\n\n    // 単純に括弧があるだけ\n    //cout << \"debug2 : \" << str << \" , \" << str.substr(1,str.length()-2) << endl;\n    return formula(str.substr(1,str.length()-2));\n    \n    exit(-1);\n}\n\n\nbool equation(string in){\n    int i,j;\n    int p = in.find(\"=\");\n\n    for(i=0; i<(1<<11); i++){\n        memset(alpha, false, sizeof(alpha));\n        for(j=0; j<11; j++){\n            if( i & (1<<j) ){\n                alpha[j] = true;\n            }\n        }\n        if( formula(in.substr(0, p)) != formula(in.substr(p+1)) ){\n            return false;\n        }\n    }\n    return true;\n}\n\n\nint main(){\n    string in;\n\n    while( cin >> in, in != \"#\" ){\n        cout << (equation(in) ? \"YES\" : \"NO\") << endl;\n    }\n\n    return 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include <iostream>\n#include <vector>\n#include <string>\n#include <algorithm>\nusing namespace std;\n\nint c;\nbool a[11];\n\nbool f(const string& s) {\n\tif (s[c] == '(') {\n\t\tc++;\n\t\tbool v = f(s);\n\t\tif (s[c] == '+') {\n\t\t\tc++;\n\t\t\tv |= f(s);\n\t\t}\n\t\telse if (s[c] == '*') {\n\t\t\tc++;\n\t\t\tv &= f(s);\n\t\t}\n\t\telse {\n\t\t\tc += 2;\n\t\t\tv = !(v & !f(s));\n\t\t}\n\t\tc++; // s[c] == ')'\n\t\treturn v;\n\t}\n\n\tif (s[c] == 'T') {\n\t\tc++;\n\t\treturn true;\n\t}\n\tif (s[c] == 'F') {\n\t\tc++;\n\t\treturn false;\n\t}\n\tif (s[c] == '-') {\n\t\tc++;\n\t\treturn !f(s);\n\t}\n\tif ('a' <= s[c] && s[c] <= 'k') {\n\t\tbool v = a[s[c] - 'a'];\n\t\tc++;\n\t\treturn v;\n\t}\n\tcout << \"error\" << s << \"at \" << c << endl;\n\texit(1);\n}\n\nbool solve(string s1, string s2) {\n\tfor (int i = 0; i < (1 << 11); i++) {\n\t\tfor (int j = 0; j < 11; j++) {\n\t\t\ta[i] = (i & (1 << j)) > 0;\n\t\t}\n\t\t//cout << i << \" \" << s1 + \" \" << s2 << endl;\n\t\tc = 0;\n\t\tbool res1 = f(s1);\n\t\tc = 0;\n\t\tbool res2 = f(s2);\n\n\t\tif (res1 == res2) return true;\n\t}\n\n\treturn false;\n}\n\nint main() {\n\tcin.tie(0);\n\tios::sync_with_stdio(false);\n\tstring s, s1, s2;\n\twhile (cin >> s , s != \"#\") {\n\t\tint idx = s.find('=');\n\t\ts1 = s.substr(0, idx) , s2 = s.substr(idx + 1, s.size() - (idx + 1));\n\t\tcout << (solve(s1, s2) ? \"YES\" : \"NO\") << endl;\n\t}\n}"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\n \nusing namespace std;\n \nint idx,S;\n \nbool parse(const string &s){\n    if(idx == (int)s.size()) return true;\n    idx++;\n    bool l,r,res;\n    switch(s[idx]){\n    case 'T':\n\treturn true;\n    case 'F':\n\treturn false;\n    case '-':\n\treturn !parse(s);\n    case '(':\n\tl = parse(s);\n\tidx++;\n\tif(s[idx] == '+'){\n\t    r = parse(s);\n\t    res = l | r;\n\t}else if(s[idx] == '*'){\n\t    r = parse(s);\n\t    res = l & r; \n\t}else{\n\t    idx++;\n\t    r = parse(s);\n\t    res = !l || (l && r);\n\t}\n\tidx++;\n\treturn res;\n    default:\n\treturn ((S >> (s[idx]-'a')) & 1);\n    }\n}\n \nbool solve(const string &s){\n    int eq = s.find('=');\n    string l = s.substr(0,eq);\n    string r = s.substr(eq+1);\n    for(S = 0 ; S < (1<<11) ; S++){\n\tidx = -1;\n\tbool ll = parse(l);\n\tidx = -1;\n\tif(ll != parse(r)){\n\t    return false;\n\t}\n    }\n    return true;\n}\n \nint main(){\n    string s;\n    while(cin >> s, s != \"#\"){\n\tcout << (solve(s) ? \"YES\" : \"NO\") << endl;\n    }\n    return 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include<iostream>\n#include<algorithm>\nusing namespace std;\n\nint pat;\nstring eq;\n\nbool value(char x){\n    if(x == 'T')return true;\n    if(x == 'F')return false;\n    return pat & (1 << (x - 'a'));\n}\n\nbool eval(int left, int right){\n    if(left + 1 == right)return value(eq[left]);\n    if(eq[left] == '-')return !eval(left + 1, right);\n    int s = 0;\n    for(int i = left + 1;i < right - 1;i++){\n\tif(eq[i] == '(')s++;\n\tif(eq[i] == ')')s--;\n\tif(s != 0)continue;\n\tif(eq[i] == '*'){\n\t    return eval(left + 1, i) & eval(i + 1, right - 1);\n\t}\n\tif(eq[i] == '+'){\n\t    return eval(left + 1, i) | eval(i + 1, right - 1);\n\t}\n\tif(eq[i] == '-' && eq[i + 1] == '>'){\n\t    return (!eval(left + 1, i)) | eval(i + 2, right - 1);\n\t}\n    }\n}\n\n\nint main(){\n    while(true){\n\tcin >> eq;\n\tif(eq == \"#\")return 0;\n\tint center = 0;\n\tbool equal = true;\n\twhile(eq[center] != '=')center++;\n\tfor(int i = 0;i < (1 << 11);i++){\n\t    pat = i;\n\t    if(eval(0, center) != eval(center + 1, eq.size())){\n\t\tequal = false;\n\t\tbreak;\n\t    }\n\t}\n\tif(equal)\n\t    cout << \"YES\" << endl;\n\telse\n\t    cout << \"NO\" << endl;\n    }\n}"
  },
  {
    "language": "C++",
    "code": "#include<iostream>\n#include<string>\n#include<algorithm>\n\nusing namespace std;\n\nint now,al;\nstring s;\n\nbool formula(void){\n\t\n\tif(isupper(s[now])){\n\t\tnow++;\n\t\treturn s[now-1]=='T';\n\t}\n\t\n\tif(islower(s[now])){\n\t\tnow++;\n\t\treturn (al>>(s[now-1]-'a'))&1;\n\t}\n\t\n\tif(s[now]=='('){\n\t\tnow++;\n\t\tbool res1=formula();\n\t\t\n\t\tif(s[now]=='*'){\n\t\t\tnow++;\n\t\t\tbool res2=formula();\n\t\t\tif(s[now]==')')now++;\n\t\t\treturn res1&res2;\n\t\t}\n\t\tif(s[now]=='+'){\n\t\t\tnow++;\n\t\t\tbool res2=formula();\n\t\t\tif(s[now]==')')now++;\n\t\t\treturn res1|res2;\n\t\t}\n\t\tif(s[now]=='-' && s[now+1]=='>'){\n\t\t\tnow+=2;\n\t\t\tbool res2=formula();\n\t\t\tif(s[now]==')')now++;\n\t\t\tif(res1==true && res2==false)return false;\n\t\t\treturn true;\n\t\t}\n\t}\n\t\n\tif(s[now]=='-'){\n\t\tnow++;\n\t\tbool res=formula();\n\t\treturn !res;\n\t}\n}\n\nbool equation(void){\n\tbool res1=formula();\n\tnow++;\n\tbool res2=formula();\n\treturn (res1==res2);\n}\n\nint main(void){\n\t\n\twhile(cin >> s,s!=\"#\"){\n\t\tbool fg=true;\n\t\tfor(al=0;al<(1<<11);al++)now=0,fg&=equation();\n\t\tif(fg)cout << \"YES\" << endl;\n\t\telse cout << \"NO\" << endl;\n\t}\n\treturn 0;\n}"
  },
  {
    "language": "C++",
    "code": "// Header {{{\n// includes {{{\n#include <algorithm>\n#include <cassert>\n#include <cctype>\n#include <climits>\n#include <cmath>\n#include <complex>\n#include <cstdio>\n#include <cstdlib>\n#include <cstring>\n#include <ctime>\n#include <iostream>\n#include <iterator>\n#include <limits>\n#include <list>\n#include <map>\n#include <numeric>\n#include <queue>\n#include <set>\n#include <sstream>\n#include <stack>\n#include <string>\n#include <sys/time.h>\n#include <unistd.h>\n#include <vector>\n// }}}\nusing namespace std;\n// consts {{{\nstatic const int INF = 1e9;\nstatic const double PI = acos(-1.0);\nstatic const double EPS = 1e-10;\n// }}}\n// typedefs {{{\ntypedef long long int LL;\ntypedef unsigned long long int ULL;\ntypedef vector<int> VI;\ntypedef vector<VI> VVI;\ntypedef vector<LL> VLL;\ntypedef vector<VLL> VVLL;\ntypedef vector<ULL> VULL;\ntypedef vector<VULL> VVULL;\ntypedef vector<double> VD;\ntypedef vector<VD> VVD;\ntypedef vector<bool> VB;\ntypedef vector<VB> VVB;\ntypedef vector<char> VC;\ntypedef vector<VC> VVC;\ntypedef vector<string> VS;\ntypedef vector<VS> VVS;\ntypedef pair<int, int> PII;\ntypedef complex<int> P;\n#define PQ(type) priority_queue<type>\n// priority queue reverse\n#define PQR(type) priority_queue< type, vector<type>, greater<type> >\n// }}}\n// macros & inline functions {{{\n// syntax sugars {{{\n#define FOR(i, b, e) for (typeof(e) i = (b); i < (e); ++i)\n#define FORI(i, b, e) for (typeof(e) i = (b); i <= (e); ++i)\n#define REP(i, n) FOR(i, 0, n)\n#define REPI(i, n) FORI(i, 0, n)\n#define OPOVER(_op, _type) inline bool operator _op (const _type &t) const\n#define ASSIGN_MAX(var, val) ((var) = max((var), (val)))\n#define ASSIGN_MIN(var, val) ((var) = min((var), (val)))\n// }}}\n// conversion {{{\ninline int toInt(string s) { int v; istringstream sin(s); sin>>v; return v; }\ntemplate<class T> inline string toString(T x) { ostringstream sout; sout<<x; return sout.str(); }\n// }}}\n// array and STL {{{\n#define ARRSIZE(a) ( sizeof(a) / sizeof(a[0]) )\n#define ZERO(a, v) ( assert(v == 0 || v == -1), memset(a, v, sizeof(a)) )\n#define F first\n#define S second\n#define MP(a, b) make_pair(a, b)\n#define SIZE(a) ((LL)a.size())\n#define PB(e) push_back(e)\n#define SORT(v) sort((v).begin(), (v).end())\n#define RSORT(v) sort((v).rbegin(), (v).rend())\n#define ALL(a) (a).begin(), (a).end()\n#define RALL(a) (a).rbegin(), (a).rend()\n#define EACH(c, it) for(typeof((c).begin()) it=(c).begin(); it!=(c).end(); ++it)\n#define REACH(c, it) for(typeof((c).rbegin()) it=(c).rbegin(); it!=(c).rend(); ++it)\n#define EXIST(s, e) ((s).find(e) != (s).end())\n// }}}\n// bit manipulation {{{\n// singed integers are not for bitwise operations, specifically arithmetic shifts ('>>', and maybe not good for '<<' too)\n#define IS_UNSIGNED(n) (!numeric_limits<typeof(n)>::is_signed)\n#define BIT(n) (assert(IS_UNSIGNED(n)), assert(n < 64), (1ULL << (n)))\n#define BITOF(n, m) (assert(IS_UNSIGNED(n)), assert(m < 64), ((ULL)(n) >> (m) & 1))\ninline int BITS_COUNT(ULL b) { int c = 0; while(b != 0) { c += (b & 1); b >>= 1; } return c; }\ninline int MSB(ULL b) { int c = 0; while(b != 0) { ++c; b >>= 1; } return c-1; }\ninline int MAKE_MASK(ULL upper, ULL lower) { assert(lower < 64 && upper < 64 && lower <= upper); return (BIT(upper) - 1) ^ (BIT(lower) - 1); }\n// }}}\n// for readable code {{{\n#define EVEN(n) (n % 2 == 0)\n#define ODD(n) (!EVEN(n))\n// }}}\n// debug {{{\n#define arrsz(a) ( sizeof(a) / sizeof(a[0]) )\n#define dprt(fmt, ...) if (opt_debug) { fprintf(stderr, fmt, ##__VA_ARGS__); }\n#define darr(a) if (opt_debug) { copy( (a), (a) + arrsz(a), ostream_iterator<int>(cerr, \" \") ); cerr << endl; }\n#define darr_range(a, f, t) if (opt_debug) { copy( (a) + (f), (a) + (t), ostream_iterator<int>(cerr, \" \") ); cerr << endl; }\n#define dvec(v) if (opt_debug) { copy( ALL(v), ostream_iterator<int>(cerr, \" \") ); cerr << endl; }\n#define darr2(a) if (opt_debug) { FOR(__i, 0, (arrsz(a))){ darr( (a)[__i] ); } }\n#define WAIT() if (opt_debug) { string _wait_; cerr << \"(hit return to continue)\" << endl; getline(cin, _wait_); }\n#define dump(x) if (opt_debug) { cerr << \" [L\" << __LINE__ << \"] \" << #x << \" = \" << (x) << endl; }\n// dump vector elements in [s, e)\n#define dumpv(v, s, e) if (opt_debug) { cerr << \" [L\" << __LINE__ << \"] \" << #v << \" = \"; FOR(__i, s, e) { cerr << v[__i] << \"\\t\"; } cerr << endl; }\n#define dumpl(x) if (opt_debug) { cerr << \" [L\" << __LINE__ << \"] \" << #x << endl << (x) << endl; }\n#define dumpf() if (opt_debug) { cerr << __PRETTY_FUNCTION__ << endl; }\n#define where() if (opt_debug) { cerr << __FILE__ << \": \" << __PRETTY_FUNCTION__ << \" [L: \" << __LINE__ << \"]\" << endl; }\n#define dumpb(bit, digits) if (opt_debug) { cerr << \" [L\" << __LINE__ << \"] \" << #bit << \" = \"; for(int __i = digits - 1; __i >= 0; __i--) { cerr << static_cast<bool>(bit & (1 << __i)); if (__i % 4 == 0) { cerr << \" \"; } } cerr << endl; }\n\n// ostreams {{{\n// complex\ntemplate<typename T> ostream& operator<<(ostream& s, const complex<T>& d) {return s << \"(\" << d.real() << \", \" << d.imag() << \")\";}\n\n// pair\ntemplate<typename T1, typename T2> ostream& operator<<(ostream& s, const pair<T1, T2>& d) {return s << \"(\" << d.first << \", \" << d.second << \")\";}\n\n// vector\ntemplate<typename T> ostream& operator<<(ostream& s, const vector<T>& d) {\n\tint len = d.size();\n\tREP (i, len) {\n\t\ts << d[i]; if (i < len - 1) s << \"\\t\";\n\t}\n\treturn s;\n}\n\n// 2 dimentional vector\ntemplate<typename T> ostream& operator<<(ostream& s, const vector< vector<T> >& d) {\n\tint len = d.size();\n\tREP (i, len) {\n\t\ts << d[i] << endl;\n\t}\n\treturn s;\n}\n\n// map\ntemplate<typename T1, typename T2> ostream& operator<<(ostream& s, const map<T1, T2>& m) {\n\ts << \"{\" << endl;\n\tfor (typeof(m.begin()) itr = m.begin(); itr != m.end(); ++itr) {\n\t\ts << \"\\t\" << (*itr).first << \" : \" << (*itr).second << endl;\n\t}\n\ts << \"}\" << endl;\n\treturn s;\n}\n// }}}\n// }}}\n// }}}\n// time {{{\ninline double now(){ struct timeval tv; gettimeofday(&tv, NULL); return (static_cast<double>(tv.tv_sec) + static_cast<double>(tv.tv_usec) * 1e-6); }\n// }}}\n// string manipulation {{{\ninline VS split(string s, char delimiter) { VS v; string t; REP(i, s.length()) { if(s[i] == delimiter) v.PB(t), t = \"\"; else t += s[i]; } v.PB(t); return v; }\ninline string join(VS s, string j) { string t; REP(i, s.size()) { t += s[i] + j; } return t; }\n// }}}\n// geometry {{{\n#define Y real()\n#define X imag()\n// }}}\n// 2 dimentional array {{{\nenum { UP, RIGHT, DOWN, LEFT, UP_RIGHT, DOWN_RIGHT, DOWN_LEFT, UP_LEFT };\nP dydx4[4] = { P(-1, 0), P(0, 1), P(1, 0), P(0, -1) };\nP dydx8[8] = { P(-1, 0), P(0, 1), P(1, 0), P(0, -1), P(-1, 1), P(1, 1), P(1, -1), P(-1, -1) };\nbool in_field(int H, int W, P p) {\n\treturn (0 <= p.Y && p.Y < H) && (0 <= p.X && p.X < W);\n}\n// }}}\n// input and output {{{\ninline void input(string filename) {\n\tfreopen(filename.c_str(), \"r\", stdin);\n}\ninline void output(string filename) {\n\tfreopen(filename.c_str(), \"w\", stdout);\n}\n// }}}\n// }}}\n\nbool opt_debug = false;\n\nclass Parser {\n\tprivate:\n\t\tint pos;\n\t\tmap<char, bool> binding;\n\tpublic:\n\t\tstring s;\n\t\tParser(string _s) : s(_s) {\n\t\t\tpos = 0;\n\t\t}\n\n\t\tvoid rewind() {\n\t\t\tpos = 0;\n\t\t}\n\n\t\tvoid bind(char c, bool v) {\n\t\t\tbinding[c] = v;\n\t\t}\n\n\t\tbool is_identical() {\n\t\t\tbool lhs = formula();\n\t\t\tassert(s[pos] == '=');\n\t\t\tpos++;\n\t\t\tbool rhs = formula();\n\t\t\treturn lhs == rhs;\n\t\t}\n\n\t\tbool formula() {\n\t\t\tbool lhs, rhs;\n\t\t\tchar op, c;\n\t\t\tswitch (s[pos]) {\n\t\t\t\tcase 'T':\n\t\t\t\t\tpos++;\n\t\t\t\t\treturn true;\n\t\t\t\tcase 'F':\n\t\t\t\t\tpos++;\n\t\t\t\t\treturn false;\n\t\t\t\tcase '-':\n\t\t\t\t\tpos++;\n\t\t\t\t\treturn !formula();\n\t\t\t\tcase '(':\n\t\t\t\t\tpos++;\n\t\t\t\t\tlhs = formula();\n\t\t\t\t\top = s[pos];\n\t\t\t\t\tpos++;\n\t\t\t\t\tif (op == '-') {\n\t\t\t\t\t\tassert(s[pos] == '>');\n\t\t\t\t\t\tpos++;\n\t\t\t\t\t}\n\t\t\t\t\trhs = formula();\n\t\t\t\t\tassert(s[pos] == ')');\n\t\t\t\t\tpos++;\n\t\t\t\t\treturn (op == '*') ? lhs && rhs : (op == '+') ? lhs || rhs : (!lhs || rhs);\n\t\t\t\tdefault:\n\t\t\t\t\tif (!EXIST(binding, s[pos])) { throw; }\n\t\t\t\t\tc = s[pos];\n\t\t\t\t\tpos++;\n\t\t\t\t\treturn binding[c];\n\t\t\t}\n\t\t\tthrow;\n\t\t\treturn false;\n\t\t}\n};\n\nint main(int argc, char** argv) {\n\tstd::ios_base::sync_with_stdio(false);\n\t// set options {{{\n\tint __c;\n\twhile ( (__c = getopt(argc, argv, \"d\")) != -1 ) {\n\t\tswitch (__c) {\n\t\t\tcase 'd':\n\t\t\t\topt_debug = true;\n\t\t\t\tbreak;\n\t\t\tdefault:\n\t\t\t\tabort();\n\t\t}\n\t}\n\t// }}}\n\n\t// opt_debug = true;\n\t// input(\"./inputs/0.txt\");\n\t// output(\"./outputs/0.txt\");\n\n\tstring s;\n\twhile (cin >> s, s != \"#\") {\n\t\tParser p(s);\n\t\tchar vars[] = { 'a', 'b', 'c', 'd', 'e', 'f', 'g', 'h', 'i', 'j', 'k' };\n\t\tbool ok = true;\n\t\tREP (i, 1 << 11) {\n\t\t\tp.rewind();\n\t\t\tREP (j, 11) {\n\t\t\t\tp.bind(vars[j], i & (1 << j));\n\t\t\t}\n\t\t\tif (!p.is_identical()) {\n\t\t\t\tok = false;\n\t\t\t\tbreak;\n\t\t\t}\n\t\t}\n\t\tif (ok) {\n\t\t\tcout << \"YES\" << endl;\n\t\t} else {\n\t\t\tcout << \"NO\" << endl;\n\t\t}\n\t}\n\n\treturn 0;\n}\n\n// vim: foldmethod=marker"
  },
  {
    "language": "C++",
    "code": "#include<iostream>\n#include<algorithm>\n#include<vector>\n#include<string>\nusing namespace std;\ntypedef pair<int,int> pii;\ntypedef pair<int,pii> pip;\n#define pb(i) push_back(i)\n#define fs first\n#define sc second\n#define X first\n#define Y second\n\n#include<algorithm>\n#include<functional>\n#define all(X) X.begin(),X.end()\n#define rep(X,Y) for(int X=0;(X)<(Y);++(X))\n\nusing namespace std;\n\ntypedef vector<vector<int>> vvi;\ntypedef pair<int,int> pii;\n\ntemplate<class T,class S> ostream& operator<<(ostream &os,pair<T,S> &p){\n  cout<<\"(\"<<p.X<<\",\"<<p.Y<<\")\";\n  return os;\n}\n\nint val;\n\nint var(char c){ \n  if(c=='T') return 1;\n  if(c=='F') return 0;\n  return val>>(c-'a')&1;}\n\npii eval(string &str,int pos=0){\n  pii re;\n  if(str[pos]=='-'){\n    re=eval(str,pos+1);\n    re.X=1-re.X;\n  }else if(str[pos]=='('){\n    pii l=eval(str,pos+1);\n    if(str[l.Y]=='*'){\n      re=eval(str,l.Y+1);\n      //cout<<l<<re<<endl;\n      re.X&=l.X;\n    }else if(str[l.Y]=='+'){\n      re=eval(str,l.Y+1);\n      re.X|=l.X;\n    }else{\n      re=eval(str,l.Y+2);\n      re.X|=1-l.X;\n    }\n    ++re.Y;\n  }else{\n    re.X=var(str[pos]);\n    re.Y=pos+1;\n  }\n  //cout<<str<<\":\"<<re.X<<\",\"<<re.Y<<endl;\n  return re;\n}\n\nint main(){\n  string str;\n  while(cin>>str,str[0]!='#'){\n    int n=str.size();\n    string s,t;\n    rep(i,n)if(str[i]=='='){\n      s=str.substr(0,i);\n      t=str.substr(i+1);\n    }\n    int m='k'-'a'+1,f=1;\n    rep(i,1<<m){\n      val=i;\n      if(eval(s).X!=eval(t).X){\n\t/*cout<<i<<endl;\n\tcout<<s<<\":\"<<eval(s).X<<endl;\n\tcout<<t<<\":\"<<eval(t).X<<endl;*/\n\tf=0;\n\tbreak;\n      }\n    }\n    cout<<(f?\"YES\":\"NO\")<<endl;\n  }\n}"
  },
  {
    "language": "C++",
    "code": "#include <iostream>\n#include <string>\nusing namespace std;\n\nint flgs = 0;\nstring s;\n\nbool solve(int & indx) {\n\tbool inv = false;\n\tbool res;\n\tif(s[indx] == '-') {\n\t\tindx++;\n\t\tres = !solve(indx);\n\t}\n\telse if(s[indx] == '(') {\n\t\tbool a, b;\n\t\tint type;\n\t\tindx++;\n\t\ta = solve(indx);\n\t\tif(s[indx] == '*') type = 0;\n\t\telse if(s[indx] == '+') type = 1;\n\t\telse {type = 2; indx++;}\n\t\tindx++;\n\t\tb = solve(indx);\n\t\tindx++;\n\t\tif(type == 0)\n\t\t\tres = a && b;\n\t\telse if(type == 1)\n\t\t\tres = a || b;\n\t\telse\n\t\t\tres = !a || b;\n\t}\n\telse if(s[indx] == 'T') {\n\t\tres = true;\n\t\tindx++;\n\t}\n\telse if(s[indx] == 'F') {\n\t\tres = false;\n\t\tindx++;\n\t}\n\telse {\n\t\tres = flgs & (1 << (s[indx] - 'a'));\n\t\tindx++;\n\t}\n\n\treturn res;\n}\n\nint main() {\n\twhile(1) {\n\t\tcin >> s;\n\t\tif(s == \"#\")\n\t\t\tbreak;\n\t\tbool f = true;\n\t\tfor(flgs = 0; flgs < (1 << 11); flgs++) {\n\t\t\tbool a, b;\n\t\t\tint indx = 0;\n\t\t\ta = solve(indx);\n\t\t\tindx++;\n\t\t\tb = solve(indx);\n\t\t\tif(a != b)\n\t\t\t\tf = false;\n\t\t}\n\t\tif(f)\n\t\t\tcout << \"YES\" << endl;\n\t\telse\n\t\t\tcout << \"NO\" << endl;\n\t}\n}"
  },
  {
    "language": "C++",
    "code": "#include <algorithm>\n#include <cmath>\n#include <climits>\n#include <cstdio>\n#include <cstdlib>\n#include <cstring>\n#include <fstream>\n#include <iostream>\n#include <list>\n#include <map>\n#include <queue>\n#include <set>\n#include <sstream>\n#include <stack>\n#include <string>\n#include <vector>\n#include <cassert>\n#include <functional>\n\nusing namespace std;\n\n#define LOG(...) printf(__VA_ARGS__)\n//#define LOG(...)\n#define FOR(i,a,b) for(int i=(int)(a);i<(int)(b);++i)\n#define REP(i,n) for(int i=0;i<(int)(n);++i)\n#define ALL(a) (a).begin(),(a).end()\n#define RALL(a) (a).rbegin(),(a).rend()\n#define EXIST(s,e) ((s).find(e)!=(s).end())\n#define SORT(c) sort((c).begin(),(c).end())\n#define RSORT(c) sort((c).rbegin(),(c).rend())\n#define CLR(a) memset((a), 0 ,sizeof(a))\n\ntypedef long long ll;\ntypedef unsigned long long ull;\ntypedef vector<bool> vb;\ntypedef vector<int> vi;\ntypedef vector<ll> vll;\ntypedef vector<vb> vvb;\ntypedef vector<vi> vvi;\ntypedef vector<vll> vvll;\ntypedef pair<int, int> pii;\ntypedef pair<ll, ll> pll;\n\nconst int dx[] = { -1, 0, 1, 0 }; const int dy[] = { 0, 1, 0, -1 };\n\nstruct UnionFind {\n\tvector<int> v;\n\tUnionFind(int n) : v(n) { for (int i = 0; i < n; i++) v[i] = i; }\n\tint  find(int x) { return v[x] == x ? x : v[x] = find(v[x]); }\n\tvoid unite(int x, int y) { v[find(x)] = find(y); }\n};\nbool cal(string &s, int &idx) {\n\tbool res = true;\n\tbool sub = false;\n\twhile (idx < (int)s.length()) {\n\t\tif (s[idx] == '(') {\n\t\t\tidx++;\n\t\t\tif (sub)\n\t\t\t\treturn !cal(s, idx);\n\t\t\telse\n\t\t\t\treturn cal(s, idx);\n\t\t}\n\t\tif (s[idx] == '-') {\n\t\t\tsub = !sub;\n\t\t\tidx++;\n\t\t}\n\t\tif (s[idx] == 'T' || s[idx] == 'F') {\n\t\t\tbool st1 = ((s[idx] == 'T' && !sub) || (s[idx] == 'F' && sub));\n\t\t\tidx++;\n\t\t\tsub = false;\n\t\t\tint calc;\n\t\t\tif (s[idx] == '*')\n\t\t\t\tcalc = 0;\n\t\t\tif (s[idx] == '+')\n\t\t\t\tcalc = 1;\n\t\t\tif (s[idx] == '>')\n\t\t\t\tcalc = 2;\n\t\t\tidx++;\n\t\t\tif (s[idx] == '-') {\n\t\t\t\tsub = !sub;\n\t\t\t\tidx++;\n\t\t\t}\n\t\t\tbool st2;\n\t\t\tif (s[idx] == 'T' || s[idx] == 'F') {\n\t\t\t\tst2 = ((s[idx] == 'T' && !sub) || (s[idx] == 'F' && sub));\n\t\t\t}\n\t\t\telse {\n\t\t\t\tidx++;\n\t\t\t\tst2 = cal(s, idx);\n\t\t\t}\n\t\t\tif (calc == 0)\n\t\t\t\tres = (st1&&st2);\n\t\t\tif (calc == 1)\n\t\t\t\tres = (st1 || st2);\n\t\t\tif (calc == 2)\n\t\t\t\tres = !(st1 && !st2);\n\t\t\tidx++;\n\t\t\treturn res;\n\t\t}\n\t\tif (s[idx] == ')') {\n\t\t\tidx++;\n\t\t\treturn res;\n\t\t}\n\t}\n\treturn res;\n}\n\nint main() {\n\tstring s;\n\twhile (cin >> s, s != \"#\") {\n\t\tstring ans = \"YES\";\n\t\tauto pos = s.find(\"->\");\n\t\twhile (pos != string::npos) {\n\t\t\ts.replace(pos, 2, \">\");\n\t\t\tpos = s.find(\"->\", pos + 1);\n\t\t}\n\t\tpos = s.find(\"--\");\n\t\twhile (pos != string::npos) {\n\t\t\ts.replace(pos, 2, \"\");\n\t\t\tpos = s.find(\"--\", pos + 1);\n\t\t}\n\t\tint eq;\n\t\tREP(k, s.length())\n\t\t\tif (s[k] == '=')\n\t\t\t\teq = k;\n\n\t\tREP(i, 2048) {\n\t\t\tstring s2 = s;\n\t\t\tREP(j, 11) {\n\t\t\t\tREP(k, s2.length()) {\n\t\t\t\t\tif (s2[k] == 'a' + j)\n\t\t\t\t\t\tif ((i >> j) & 1) {\n\t\t\t\t\t\t\ts2[k] = 'T';\n\t\t\t\t\t\t}\n\t\t\t\t\t\telse {\n\t\t\t\t\t\t\ts2[k] = 'F';\n\t\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t}\n\t\t\tint idx1 = 0, idx2 = 0;\n\t\t\tif (cal((string)s2.substr(0, eq), idx1) != cal((string)s2.substr(eq + 1, s2.length() - eq - 1), idx2)) {\n\t\t\t\tans = \"NO\";\n\t\t\t\tbreak;\n\t\t\t}\n\t\t}\n\t\tcout << ans << endl;\n\t}\n}"
  },
  {
    "language": "C++",
    "code": "// http://judge.u-aizu.ac.jp/onlinejudge/description.jsp?id=2401\n\n#include <iostream>\n#include <string>\n#include <cassert>\n#include <cctype>\nusing namespace std;\n\nstring S;\nint cur;\n\nbool a[11];\n\nbool formula() {\n  if (islower(S[cur])) {\n    return a[S[cur++] - 'a'];\n  }\n  switch(S[cur]) {\n  case 'T':\n    cur++;\n    return true;\n  case 'F':\n    cur++;\n    return false;\n  case '-':\n    cur++;\n    return !(formula());\n  default:\n    assert(S[cur++] == '(');\n    bool x = formula();\n    char p = S[cur++];\n    if (p == '-') cur++;\n    bool y = formula();\n    assert(S[cur++] == ')');\n    switch (p) {\n    case '*':\n      return x && y;\n    case '+':\n      return x || y;\n    default:\n      assert(p == '-');\n      return !(x && !y);\n    }\n  }\n}\n\nbool equation() {\n  bool l = formula();\n  assert(S[cur++] == '=');\n  bool r = formula();\n  return l == r;\n}\n\nint main() {\n  while (cin >> S && S != \"#\") {\n    for (auto i=0; i < (1 << 11); i++) {\n      cur = 0;\n      for (auto j=0; j<11; j++) {\n\ta[j] = (i >> j) & 1;\n      }\n      if (!equation()) {\n\tcout << \"NO\" << endl;\n\tgoto EXIT;\n      }\n    }\n    cout << \"YES\" << endl;\n  EXIT: continue;\n  }\n}"
  },
  {
    "language": "C++",
    "code": "#include<bits/stdc++.h>\nusing namespace std;\nstring s,t;\nint S,p;\n\nbool change(char ch){\n  if(ch=='T')return true;\n  if(ch=='F')return false;\n  int a=ch-'a';\n  return (S>>a&1);\n}\n\nbool calc(string &);\n\nbool getNum(string &s){\n  char ch=s[p++];\n  if(ch=='('){\n    return calc(s);\n  }else if(ch=='-'){\n    return (!getNum(s));\n  }else{\n    return change(ch);\n  }\n}\n\nchar getOp(string &s){\n  char ch=s[p++];\n  if(ch=='-'){\n    p++;\n    ch='>';\n  }\n  return ch;\n}\n\nbool calc(string &s){\n  bool res=getNum(s);\n  while(1){\n    char ch=getOp(s);\n    if(ch=='='||ch==')')break;\n    bool num=getNum(s);\n    if(ch=='*')res=(res&&num);\n    else if(ch=='+')res=(res||num);\n    else if(ch=='>')res=(res<=num);\n  }\n  return res;\n}\n\nstring solve(){\n  for(S=0;S<(1<<11);S++){\n    p=0;\n    bool a=calc(s);\n    p=0;\n    bool b=calc(t);\n    if(a!=b)return \"NO\";\n  }\n  return \"YES\";\n}\n\nint main(){\n  while(1){\n    cin>>s;\n    if(s==\"#\")break;\n    int x=0;\n    while(s[x]!='=')x++;\n    t=s.substr(x+1);\n    s=s.substr(0,x);\n    t.push_back('=');\n    s.push_back('=');\n    cout<<solve()<<endl;\n  }\n\n  return 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include <functional>\n#include <iostream>\n#include <string>\n#include <unordered_set>\n#include <vector>\n#define loop(i, a, n) for (int i = (a); i < (n); i++)\n#define rep(i, n) loop(i, 0, n)\ntemplate<typename A> using F = std::function<A>;\nusing namespace std;\n \ntemplate<typename T> struct ParseResult {\n  bool succeeded;\n  T object;\n  int pos;\n  ParseResult(const bool succeeded, const T &object, const int pos) : succeeded(succeeded), object(object), pos(pos) {}\n  friend std::ostream &operator<<(std::ostream &os, const ParseResult<T> &p) { return os << '{' << (p.succeeded ? \"true\" : \"false\") << ',' << p.object << ',' << p.pos << '}'; }\n};\n \ntemplate<typename T> using Parser = std::function<ParseResult<T>(const std::string&, int)>;\n \nParser<std::string> token(std::string s) {\n  const auto n = s.size();\n  return [n = std::move(n), s = std::move(s)](const std::string &target, const int pos) {\n    if (target.size() < n) return ParseResult<std::string>(false, {}, pos);\n    return target.substr(pos, n) == s ? ParseResult<std::string>(true, s, pos + n) : ParseResult<std::string>(false, {}, pos);\n  };\n}\n \ntemplate<typename T> Parser<T> operator||(Parser<T> p1, Parser<T> p2) {\n  return [p1 = std::move(p1), p2 = std::move(p2)](const std::string &target, const int pos) {\n    auto r = p1(target, pos);\n    if (r.succeeded) return r;\n    r = p2(target, pos);\n    if (r.succeeded) return r;\n    return ParseResult<T>(false, {}, pos);\n  };\n}\n \ntemplate<typename T1, typename T2> Parser<std::pair<T1, T2>> operator+(Parser<T1> p1, Parser<T2> p2) {\n  return[p1 = std::move(p1), p2 = std::move(p2)](const std::string &target, const int pos) {\n    auto r1 = p1(target, pos);\n    if (!r1.succeeded) return ParseResult<std::pair<T1, T2>>(false, {}, pos);\n    auto r2 = p2(target, r1.pos);\n    if (!r2.succeeded) return ParseResult<std::pair<T1, T2>>(false, {}, pos);\n    return ParseResult<std::pair<T1, T2>>(true, {r1.object, r2.object}, r2.pos);\n  };\n}\n \ntemplate<typename T1, typename T2> Parser<T2> operator>>(Parser<T1> p1, Parser<T2> p2) {\n  return [p1 = std::move(p1), p2 = std::move(p2)](const std::string &target, const int pos) {\n    auto r1 = p1(target, pos);\n    if (!r1.succeeded) return ParseResult<T2>(false, {}, pos);\n    auto r2 = p2(target, r1.pos);\n    if (!r2.succeeded) return ParseResult<T2>(false, {}, pos);\n    return ParseResult<T2>(true, r2.object, r2.pos);\n  };\n}\n \ntemplate<typename T1, typename T2> Parser<T1> operator<<(Parser<T1> p1, Parser<T2> p2) {\n  return [p1 = std::move(p1), p2 = std::move(p2)](const std::string &target, const int pos) {\n    auto r1 = p1(target, pos);\n    if (!r1.succeeded) return ParseResult<T1>(false, {}, pos);\n    auto r2 = p2(target, r1.pos);\n    if (!r2.succeeded) return ParseResult<T1>(false, {}, pos);\n    return ParseResult<T1>(true, r1.object, r2.pos);\n  };\n}\n \nParser<char> oneOf(const std::string &s) {\n  std::unordered_set<char> d;\n  for (auto &c : s) d.insert(c);\n  return [d = std::move(d)](const std::string &target, const int pos) {\n    if (target.size() <= pos) return ParseResult<char>(false, {}, pos);\n    char c = target[pos];\n    return d.count(c) ? ParseResult<char>(true, c, pos + 1) : ParseResult<char>(false, {}, pos);\n  };\n}\n \ntemplate<typename T, typename S, typename F> Parser<S> fmap(Parser<T> p, F &&f) {\n  return [p = std::move(p), f = std::forward<F>(f)](const std::string &target, const int pos) {\n    auto r = p(target, pos);\n    return r.succeeded ? ParseResult<S>(true, f(r.object), r.pos) : ParseResult<S>(false, {}, r.pos);\n  };\n}\n \ntemplate<typename T, typename F> Parser<T> lazy(const F &f) {\n  bool instantiated = false;\n  Parser<T> p;\n  return [f = std::move(f), p = std::move(p), instantiated = std::move(instantiated)](const std::string &target, const int pos) mutable {\n    if (!instantiated) {\n      p = f();\n      instantiated = true;\n    }\n    return p(target, pos);\n  };\n}\ntemplate<typename T> Parser<T> make_view(Parser<T> &&f) {\n  return [f = std::make_shared<Parser<T>>(std::move(f))](const std::string &target, const int pos) {\n    return (*f)(target, pos);\n  };\n}\n \nstruct SyntaxTree {\n  string op;\n  char value;\n  vector<SyntaxTree> children;\n  SyntaxTree() {}\n  SyntaxTree(const string &op, const char value, const vector<SyntaxTree> &children) : op(op), value(value), children(children) {}\n};\n \nint main() {\n  Parser<SyntaxTree> formulaP = make_view<SyntaxTree>([&]() {\n    auto andP = fmap<pair<SyntaxTree, SyntaxTree>, SyntaxTree>((token(\"(\") >> formulaP << token(\"*\")) + (formulaP << token(\")\")), [](auto &o) { return SyntaxTree(\"*\", {}, {o.first, o.second}); });\n    auto orP = fmap<pair<SyntaxTree, SyntaxTree>, SyntaxTree>((token(\"(\") >> formulaP << token(\"+\")) + (formulaP << token(\")\")), [](auto &o) { return SyntaxTree(\"+\", {}, {o.first, o.second}); });\n    auto impP = fmap<pair<SyntaxTree, SyntaxTree>, SyntaxTree>((token(\"(\") >> formulaP << token(\"->\")) + (formulaP << token(\")\")), [](auto &o) { return SyntaxTree(\"->\", {}, {o.first, o.second}); });\n    auto notP = fmap<SyntaxTree, SyntaxTree>(token(\"-\") >> formulaP, [](auto &o) { return SyntaxTree(\"-\", {}, {o}); });\n    auto valP = fmap<char, SyntaxTree>(oneOf(\"abcdefghijkTF\"), [](char x) { return SyntaxTree({}, x, {}); });\n    return andP || orP || impP || notP || valP;\n  }());\n  auto equationP = (formulaP << token(\"=\")) + formulaP;\n  string s;\n  while (cin >> s, s != \"#\") {\n    auto r = equationP(s, 0);\n    bool isValid = true;\n    rep(i, 1 << 11) {\n      auto toBool = [&](char c) -> bool {\n        if (c == 'T') return true;\n        if (c == 'F') return false;\n        return i >> (c - 'a') & 1;\n      };\n      F<bool(const SyntaxTree&)> evalF = [&](const SyntaxTree &f) {\n        switch (f.children.size()) {\n          case 0: return toBool(f.value);\n          case 1: return !evalF(f.children[0]);\n          case 2:\n            if (f.op == \"*\") return evalF(f.children[0]) && evalF(f.children[1]);\n            if (f.op == \"+\") return evalF(f.children[0]) || evalF(f.children[1]);\n            if (f.op == \"->\") return !evalF(f.children[0]) || evalF(f.children[1]);\n        }\n      };\n      isValid &= evalF(r.object.first) == evalF(r.object.second);\n    }\n    cout << (isValid ? \"YES\" : \"NO\") << endl;\n  }\n}"
  },
  {
    "language": "C++",
    "code": "#include <iostream>\n#include <vector>\n#include <string>\n#include <set>\n#include <sstream>\nusing namespace std;\n\n\n\n#define REP(i, s) for (int i = 0; i < s; ++i)\n#define ALL(v) (v.begin(), v.end())\n#define COUT(x) cout << #x << \" = \" << (x) << \" (L\" << __LINE__ << \")\" << endl\n#define EACH(i, s) for (__typeof__((s).begin()) i = (s).begin(); i != (s).end(); ++i)\n\ntemplate<class T> inline bool chmax(T& a, T b) { if (a < b) { a = b; return 1; } return 0; }\ntemplate<class T> inline bool chmin(T& a, T b) { if (a > b) { a = b; return 1; } return 0; }\ntemplate<class T1, class T2> ostream& operator << (ostream &s, pair<T1,T2> P)\n{ return s << '<' << P.first << \", \" << P.second << '>'; }\ntemplate<class T> ostream& operator << (ostream &s, vector<T> P)\n{ for (int i = 0; i < P.size(); ++i) { if (i > 0) { s << \" \"; } s << P[i]; } return s; }\ntemplate<class T> ostream& operator << (ostream &s, vector<vector<T> > P)\n{ for (int i = 0; i < P.size(); ++i) { s << endl << P[i]; } return s << endl; }\n\n\n\n\n\ntemplate<class T> struct Parser {\n    // results\n    int root;                       // vals[root] is the answer\n    vector<T> vals;                 // value of each node\n    vector<string> ops;             // operator of each node ('a' means leaf values)\n    vector<int> left, right;        // the index of left-node, right-node\n    vector<int> ids;                // the node-index of i-th value\n    int id = 0;\n    \n    void init() {\n        vals.clear(); ops.clear(); left.clear(); right.clear(); ids.clear();\n        id = 0;\n    }\n    \n    // generate nodes\n    int newnode(string op, int lp, int rp, T val = 0) {\n        ops.push_back(op); left.push_back(lp); right.push_back(rp);\n        if (op == \"x\") vals.push_back(val), ids.push_back(id++);\n        else {\n            if (op == \"a\") vals.push_back(val);\n            else if (op == \"-\") vals.push_back(!vals[lp]);\n            else if (op == \"+\") vals.push_back(vals[lp] || vals[rp]);\n            else if (op == \"*\") vals.push_back(vals[lp] && vals[rp]);\n            else if (op == \"->\") vals.push_back(!vals[lp] || vals[rp]);\n            ids.push_back(-1);\n        }\n        return (int)vals.size() - 1;\n    }\n    \n    // main solver\n    T solve(const string &S) {\n        init();\n        int p = 0;\n        root = formula(S, p);\n        return vals[root];\n    }\n    \n    // parser\n    int formula(const string &S, int &p) {\n        if (S[p] == '-') {\n            ++p;\n            int lp = formula(S, p);\n            return newnode(\"-\", lp, -1);\n        }\n        else if (S[p] == '(') {\n            ++p;\n            int lp = formula(S, p);\n            string op = \"\";\n            if (S[p] == '+') ++p, op = \"+\";\n            else if (S[p] == '*') ++p, op = \"*\";\n            else if (S[p] == '-') p += 2, op = \"->\";\n            int rp = formula(S, p);\n            ++p;                      // skip ')'\n            return newnode(op, lp, rp);\n        }\n        else if (S[p] == 'T') {\n            ++p;\n            return newnode(\"a\", -1, -1, true);\n        }\n        else if (S[p] == 'F') {\n            ++p;\n            return newnode(\"a\", -1, -1, false);\n        }\n        else {\n            ++p;\n            return newnode(\"x\", -1, -1);\n        }\n    }\n};\n\n\nint main() {\n    string S;\n    Parser<bool> p1, p2;\n    while (cin >> S) {\n        if (S == \"#\") break;\n        for (int i = 0; i < S.size(); ++i) if (S[i] == '=') S[i] = ' ';\n        \n        bool res = true;\n        for (int bit = 0; bit < (1<<11); ++bit) {\n            string SS = S;\n            for (int i = 0; i < SS.size(); ++i) {\n                if (SS[i] >= 'a' && SS[i] <= 'k') {\n                    int id = SS[i] - 'a';\n                    if (bit & (1<<id)) SS[i] = 'T';\n                    else SS[i] = 'F';\n                }\n            }\n            istringstream si(SS);\n            string s1, s2; si >> s1 >> s2;\n            bool r1 = p1.solve(s1), r2 = p2.solve(s2);\n            if (r1 != r2) res = false;\n            \n            /*\n            cout << SS << \": \" << r1 << \", \" << r2 << endl;\n            COUT(p1.ops);\n            COUT(p1.vals);\n            */\n        }\n        if (res) cout << \"YES\" << endl;\n        else cout << \"NO\" << endl;\n    }\n}\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n"
  },
  {
    "language": "C++",
    "code": "#include<iostream>\n#include<vector>\n#include<string>\n#include<algorithm>\n#include<functional>\n#include<numeric>\n#include<queue>\n#include<stack>\nusing namespace std;\n#define all(c) (c).begin(), (c).end()\n#define rep(i,n) for(int i=0; i<(int)(n); i++)\ntypedef long long int ll;\n\nstruct Tree {\n\tTree* l;\n\tint type;\n\tTree* r;\n\t\n\tTree(Tree* l, int type, Tree* r) : l(l), type(type), r(r) {}\n\tTree() : l(NULL), type(0), r(NULL) {}\n};\n\n\nstring s;\nint pos = 0;\nTree trees[2000];\nint numTrees = 0;\n\nTree* form() {\n\tchar c = s[pos++];\n\tTree ret;\n\tTree* l;\n\tchar opr;\n\tswitch(c) {\n\tcase '(':\n\t\tl = form();\n\t\topr = s[pos++];\n\t\tif (opr == '-') { // \"->\"\n\t\t\tpos++;\n\t\t\topr= '$';\n\t\t}\n\t\tret = Tree(l, opr, form());\n\t\tpos++; // )\n\t\tbreak;\n\tcase '-':\n\t\tret = Tree(form(), c, NULL);\n\t\tbreak;\n\tdefault:\n\t\tif (c == 'T') c = 1;\n\t\telse if (c == 'F') c = 0;\n\t\tret = Tree(NULL, c, NULL);\n\t\tbreak;\n\t}\n\ttrees[numTrees] = ret;\n\treturn &trees[numTrees++];\n}\n\nTree* expr() {\n\tpos = 0;\n\tnumTrees = 0;\n\ttrees[numTrees] = Tree(form(), s[pos++], form());\n\t//cout << (char)(trees[numTrees].type) << endl; // assert == '='\n\treturn &trees[numTrees++];\n\t\n}\n\nTree* t;\nvector<char> vars;\nvector<bool> taiou;\n\nint check(Tree* t) {\n\tint l, r;\n\tint ret;\n\t\t//cout << (char)t->type << \" checkbefore \" << endl;\n\tswitch(t->type) {\n\tcase '=':\n\t\tret = check(t->l) == check(t->r);\n\t\tbreak;\n\tcase '+':\n\t\tret = check(t->l) || check(t->r);\n\t\tbreak;\n\tcase '*':\n\t\tret = check(t->l) && check(t->r);\n\t\tbreak;\n\tcase '$':\n\t\tl = check(t->l);\n\t\tr = check(t->r);\n\t\tret = !l || r;\n\t\tbreak;\n\tcase '-':\n\t\tret = !check(t->l);\n\t\tbreak;\n\tcase 1:\n\t\tret = 1;\n\t\tbreak;\n\tcase 0:\n\t\tret = 0;\n\t\tbreak;\n\tdefault:\n\t\tret = taiou[t->type - 'a'];\n\t\tbreak;\n\t}\n\t\t//cout << (char)t->type << \" checkafter \" << ret << endl;\n\treturn ret;\n}\n\n\nbool detect_and_check(int i) {\n\tif (i == vars.size()) {\n\t\tint a = check(t);\n\t\t//cout << \"check\" << a << endl;\n\t\treturn a;\n\t}\n\telse {\n\t\ttaiou[i] = true;\n\t\tif (!detect_and_check(i+1)) return false;\n\t\ttaiou[i] = false;\n\t\tif (!detect_and_check(i+1)) return false;;\n\t}\n\treturn true;\n}\n\nint main() {\n\tfor(char i = 'a'; i <= 'k'; i++) {\n\t\tvars.push_back(i);\n\t}\n\ttaiou = vector<bool>(vars.size());\n\twhile(cin >> s, s != \"#\") {\n\t\ts += \"=\";\n\t\tt = expr();\n\t\tfor(char i = 0; i < taiou.size(); i++) {\n\t\t\ttaiou[i] = false;;\n\t\t}\n\t\tcout << (detect_and_check(0) ? \"YES\" : \"NO\") << endl;\n\t}\n\t\n\treturn 0;\n}"
  },
  {
    "language": "C++",
    "code": "\n#include<iostream>\nusing namespace std;\n\nstruct DATA{\n  string ans;\n  int i;\n  DATA(string s,int n){ans=s;i=n;}\n};\n\nstring equation(string s);\nDATA formula(string s, int i);\n\nstring equation(string s){\n  DATA res=formula(s,0);\n  return res.ans;\n}\n\nDATA formula(string s, int i)\n{\n  if(s[i]=='T')return DATA(\"T\",i+1);\n  if(s[i]=='F')return DATA(\"F\",i+1);\n  if(s[i]=='-'){\n    DATA res=formula(s,i+1);\n    if(res.ans==\"T\")return DATA(\"F\",res.i);\n    else return DATA(\"T\",res.i);\n  }\n  if(s[i]=='('){\n    string res,op;\n    DATA res1 = formula(s,i+1);\n    i=res1.i;\n    op=s[i];\n    if(op==\"-\")i++;\n    DATA res2 = formula(s,i+1);\n    i=res2.i;\n\n    if(op==\"*\"){\n      if( (res1.ans==\"T\") & (res2.ans==\"T\") ) res=\"T\";\n      else res=\"F\";\n    }\n    if(op==\"+\"){\n      if( (res1.ans==\"T\") | (res2.ans==\"T\") ) res=\"T\";\n      else res=\"F\";\n    }\n    if(op==\"-\"){\n      if( (res1.ans==\"T\") && (res2.ans==\"F\") ) res=\"F\";\n      else res=\"T\";\n    }\n    return DATA(res,i+1);\n  }\n}\n\nint main()\n{\n  bool ok;\n  string in,s1,s2;\n  while(cin>>in,in!=\"#\"){\n    ok=true;\n    for(int i=0;i<(1<<3);i++){\n      s1=in;\n      for(int j=0;j<3;j++){\n\tif(i>>j&1){\n\t  while(s1.find('a'+j,0)!=string::npos){\n\t    s1.replace(s1.find('a'+j,0),1,\"T\");\n\t  }\n\t}else{\n\t  while(s1.find('a'+j,0)!=string::npos){\n\t    s1.replace(s1.find('a'+j,0),1,\"F\");\n\t  }\n\t}\n      }\n      s2=s1.substr(s1.find(\"=\",0)+1);\n      s1=s1.substr(0,s1.find(\"=\",0));\n      if(equation(s1)!=equation(s2))ok=false;\n    }\n    if(ok)puts(\"YES\");\n    else puts(\"NO\");\n  }\n}"
  },
  {
    "language": "C++",
    "code": "#include<iostream>\n#include<vector>\n#include<string>\n#include<algorithm>\n\nusing namespace std;\n\nint now,al;\nstring s,str=\"abcdefghijk\";\n\nbool formula(void){\n\t\n\tif(isupper(s[now])){\n\t\tnow++;\n\t\treturn s[now-1]=='T';\n\t}\n\t\n\tif(islower(s[now])){\n\t\tnow++;\n\t\treturn (al>>(s[now-1]-'a'))&1;\n\t}\n\t\n\tif(s[now]=='('){\n\t\tnow++;\n\t\tbool res1=formula();\n\t\t\n\t\tif(s[now]=='*'){\n\t\t\tnow++;\n\t\t\tbool res2=formula();\n\t\t\tif(s[now]==')')now++;\n\t\t\treturn res1&res2;\n\t\t}\n\t\tif(s[now]=='+'){\n\t\t\tnow++;\n\t\t\tbool res2=formula();\n\t\t\tif(s[now]==')')now++;\n\t\t\treturn res1|res2;\n\t\t}\n\t\tif(s[now]=='-' && s[now+1]=='>'){\n\t\t\tnow+=2;\n\t\t\tbool res2=formula();\n\t\t\tif(s[now]==')')now++;\n\t\t\tif(res1==true && res2==false)return false;\n\t\t\treturn true;\n\t\t}\n\t}\n\t\n\tif(s[now]=='-'){\n\t\tnow++;\n\t\tbool res=formula();\n\t\treturn !res;\n\t}\n}\n\nbool equation(void){\n\tbool res1=formula();\n\tnow++;\n\tbool res2=formula();\n\treturn (res1==res2);\n}\n\nint main(void){\n\t\n\twhile(cin >> s,s!=\"#\"){\n\t\tbool fg=true;\n\t\tfor(al=0;al<(1<<11);al++)now=0,fg&=equation();\n\t\tif(fg)cout << \"YES\" << endl;\n\t\telse cout << \"NO\" << endl;\n\t}\n\treturn 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include <iostream>\n#include <vector>\n#include <string>\n#include <cstring>\n#include <algorithm>\n#include <sstream>\n#include <map>\n#include <set>\n\n#define REP(i,k,n) for(int i=k;i<n;i++)\n#define rep(i,n) for(int i=0;i<n;i++)\n#define INF 1<<30\n#define pb push_back\n#define mp make_pair\n\nusing namespace std;\ntypedef long long ll;\ntypedef pair<int,int> P;\n\nvector<string> split(const string &str, char delim) {\n\tvector<string> res;\n\tsize_t current = 0, found;\n\twhile((found = str.find_first_of(delim, current)) != string::npos) {\n\t\tres.push_back(string(str, current, found - current));\n\t\tcurrent = found + 1;\n\t}\n\tres.push_back(string(str, current, str.size() - current));\n\treturn res;\n}\n\nint formula(string& s, int& i) {\n\tif(s[i] == '(') {\n\t\ti++;\n\t\tint val = formula(s, i);\n\t\tchar op = s[i];\n\t\tif(s[i] == '-' && s[i+1] == '>') {\n\t\t\ti++;\n\t\t\top = s[i];\n\t\t}\n\n\t\ti++;\n\t\tint val2 = formula(s, i);\n\n\t\tint ret = 0;\n\t\tif(op == '+') {\n\t\t\tif(val || val2) ret = 1;\n\t\t\telse ret = 0;\n\t\t} else if(op == '*') {\n\t\t\tif(val && val2) ret = 1;\n\t\t\telse ret = 0;\n\t\t} else if(op == '>') {\n\t\t\tif(!val) ret = 1;\n\t\t\telse if(val2) ret = 1;\n\t\t\telse ret = 0;\n\t\t}\n\n\t\ti++;\n\t\treturn ret;\n\t} else if(isdigit(s[i])) {\n\t\tint ret = s[i] - '0';\n\t\ti++;\n\t\treturn ret;\n\t} else if(s[i] == '-') {\n\t\ti++;\n\t\tint ret = formula(s, i);\n\n\t\tif(ret == 0) return 1;\n\t\telse return 0;\n\t}\n}\n\nbool used[30];\n\nint main() {\n\tstring s;\n\twhile(cin >> s) {\n\t\tif(s == \"#\") break;\n\n\t\tvector<string> ret = split(s, '=');\n\t\tstring s1 = ret[0];\n\t\tstring s2 = ret[1];\n\n\t\tbool flag = true;\n\n\t\trep(i, 1<<11) {\n\t\t\tmemset(used, 0, sizeof(used));\n\t\t\trep(j, 11) {\n\t\t\t\tif(i & (1<<j)) used[j] = true;\n\t\t\t}\n\n\t\t\tstring t1 = s1, t2 = s2;\n\t\t\trep(j, t1.size()) {\n\t\t\t\tif('a' <= t1[j] && t1[j] <= 'k') {\n\t\t\t\t\tif(used[t1[j] - '0']) t1[j] = 'T';\n\t\t\t\t\telse t1[j] = 'F';\n\n\t\t\t\t\tif(t1[j] == 'T') t1[j] = '1';\n\t\t\t\t\telse t1[j] = '0';\n\t\t\t\t}\n\t\t\t}\n\n\t\t\trep(j, t2.size()) {\n\t\t\t\tif('a' <= t2[j] && t2[j] <= 'k') {\n\t\t\t\t\tif(used[t2[j] - '0']) t2[j] = 'T';\n\t\t\t\t\telse t2[j] = 'F';\n\n\t\t\t\t\tif(t2[j] == 'T') t2[j] = '1';\n\t\t\t\t\telse t2[j] = '0';\n\t\t\t\t}\n\t\t\t}\n\n\t\t\tint j = 0, k = 0;\n\t\t\tint f1 = formula(t1, j);\n\t\t\tint f2 = formula(t2, k);\n\n\t\t\t// cout << t1 << \" -> :: \" << f1 << endl;\n\t\t\t// cout << t2 << \" -> :: \" << f2 << endl;\n\n\t\t\tif(f1 == f2) continue;\n\n\t\t\tflag = false;\n\t\t\tbreak;\n\t\t}\n\n\t\tif(flag) cout << \"YES\" << endl;\n\t\telse cout << \"NO\" << endl;\n\t}\n\n\treturn 0;\n}"
  },
  {
    "language": "C++",
    "code": "// g++ -std=c++11 a.cpp\n#include<iostream>\n#include<vector>\n#include<string>\n#include<algorithm>\t\n#include<map>\n#include<set>\n#include<utility>\n#include<cmath>\n#include<cstring>\n#include<queue>\n#include<stack>\n#include<bitset>\n#include<cstdio>\n#include<sstream>\n#include<iomanip>\n#include<assert.h>\n#include<typeinfo>\n#define loop(i,a,b) for(int i=a;i<b;i++) \n#define rep(i,a) loop(i,0,a)\n#define pb push_back\n#define all(in) in.begin(),in.end()\n#define shosu(x) fixed<<setprecision(x)\nusing namespace std;\n//kaewasuretyuui\ntypedef long long ll;\n//#define int ll\ntypedef int Def;\ntypedef pair<Def,Def> pii;\ntypedef vector<Def> vi;\ntypedef vector<vi> vvi;\ntypedef vector<pii> vp;\ntypedef vector<vp> vvp;\ntypedef vector<string> vs;\ntypedef vector<double> vd;\ntypedef vector<vd> vvd;\ntypedef pair<Def,pii> pip;\ntypedef vector<pip>vip;\n// #define mt make_tuple\n//typedef tuple<pii,int,int> tp;\n//typedef vector<tp> vt;\ntemplate<typename A,typename B>bool cmin(A &a,const B &b){return a>b?(a=b,true):false;}\ntemplate<typename A,typename B>bool cmax(A &a,const B &b){return a<b?(a=b,true):false;}\n//template<class C>constexpr int size(const C &c){return (int)c.size();}\n//template<class T,size_t N> constexpr int size(const T (&xs)[N])noexcept{return (int)N;}\nconst double PI=acos(-1);\nconst double EPS=1e-7;\nDef inf = sizeof(Def) == sizeof(long long) ? 2e18 : 1e9;\nint dx[]={0,1,0,-1};\nint dy[]={1,0,-1,0};\ntypedef string::const_iterator State;\nint q;\nDef formula(State &i){\n\tDef out;\n\tif(*i=='('){\n\t\ti++;\n\t\tout=formula(i);\n\t}else if(*i=='T')out=1;\n\telse if(*i=='F')out=0;\n\telse if(*i=='-')out=1-formula(++i);\n\telse if(isalpha(*i))out=(q>>(*i-'a'))&1;\n\ti++;\n\tint op=0;\n\tif(*i=='+')op=1;\n\tif(*i=='-'){op=2;i++;}\n\tif(*i=='*')op=3;\n\tif(op){\n\t\ti++;\n\t\tDef out1=formula(i);\n\t\tif(op==1)out|=out1;\n\t\tif(op==2)out=!out||out&&!out1;\n\t\tif(op==3)out&=out1;\n\t\t\n\t}\n\treturn out;\n}\nint main(){\n\tstring s,t;\n\twhile(1){\n\t\tgetline(cin,s);\n\t\tif(s==\"#\")break;\n\t\trep(i,s.size())if(s[i]=='='){\n\t\t\tt=s.substr(i+1);\n\t\t\ts=s.substr(0,i);\n\t\t}\n\t\tbool h=true;\n\t\trep(i,1<<11){\n\t\t\tq=i;\n\t\t\tif(formula(s.begin())==formula(t.begin())){\n\t\t\t\th=false;\n\t\t\t\tbreak;\n\t\t\t}\n\t\t}\n\t\tif(h)cout<<\"YES\"<<endl;\n\t\telse cout<<\"NO\"<<endl;\n\t}\n}"
  },
  {
    "language": "C++",
    "code": "#include<bits/stdc++.h>\n#define rep(i,n)for(int i=0;i<(n);i++)\nusing namespace std;\n\nint equ(string&, int&);\nint form(string&, int&);\nint q(string&, int&);\n\nint equ(string&s, int&i) {\n\tint v1 = form(s, i); i++;\n\tint v2 = form(s, i);\n\treturn v1 == v2;\n}\nint form(string&s, int&i) {\n\tint mprvc = i;\n\tint v = q(s, i);\n\twhile ((s[i] == '-'&&s[i + 1] == '>') || s[i] == '*' || s[i] == '+') {\n\t\tint prv = i;\n\t\tchar op = s[i++];\n\t\tif (s[i] == '>')op = s[i++];\n\t\tint v2 = q(s, i);\n\t\tif (op == '>')v = (!v || v2);\n\t\tif (op == '*')v = (v&&v2);\n\t\tif (op == '+')v = (v || v2);\n\t}\n\treturn v;\n}\nint q(string&s, int&i) {\n\tif (s[i] == 'T' || s[i] == 'F')return s[i++] == 'T';\n\tif (s[i] == '-') {\n\t\ti++;\n\t\tif (s[i] == 'T' || s[i] == 'F')return s[i++] == 'F';\n\t\tint res = !form(s, i); i++;\n\t\treturn res;\n\t}\n\ti++; int ret = form(s, i); i++;\n\treturn ret;\n}\nint main() {\n\tstring s;\n\twhile (cin >> s, s != \"#\") {\n\t\tmap<char, int>mp;\n\t\tfor (char c : s) {\n\t\t\tif (isalpha(c))mp[c];\n\t\t}\n\t\trep(i, 1 << mp.size()) {\n\t\t\tstring t = s;\n\t\t\tint j = 0;\n\t\t\tfor (auto&p : mp)p.second = ((i >> (j++) & 1) ? 'T' : 'F');\n\t\t\tfor (char&c : t) {\n\t\t\t\tif (isalpha(c))c = mp[c];\n\t\t\t}\n\t\t\tj = 0;\n\t\t\tif (!equ(t, j)) { puts(\"NO\"); goto g; }\n\t\t}\n\t\tputs(\"YES\");\n\tg:;\n\t}\n}"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\n\nusing namespace std;\n\ninline int toInt(string s) {int v; istringstream sin(s);sin>>v;return v;}\ntemplate<class T> inline string toString(T x) {ostringstream sout;sout<<x;return sout.str();}\ntemplate<class T> inline T sqr(T x) {return x*x;}\n\ntypedef vector<int> vi;\ntypedef vector<vi> vvi;\ntypedef vector<string> vs;\ntypedef pair<int, int> pii;\ntypedef long long ll;\n\n#define all(a)  (a).begin(),(a).end()\n#define rall(a) (a).rbegin(), (a).rend()\n#define pb push_back\n#define mp make_pair\n#define each(i,c) for(typeof((c).begin()) i=(c).begin(); i!=(c).end(); ++i)\n#define exist(s,e) ((s).find(e)!=(s).end())\n#define range(i,a,b) for(int i=(a);i<(b);++i)\n#define rep(i,n)  range(i,0,n)\n#define clr(a,b) memset((a), (b) ,sizeof(a))\n#define dump(x)  cerr << #x << \" = \" << (x) << endl;\n#define debug(x) cerr << #x << \" = \" << (x) << \" (L\" << __LINE__ << \")\" << \" \" << __FILE__ << endl;\n\nconst double eps = 1e-10;\nconst double pi  = acos(-1.0);\nconst ll INF =1LL << 62;\nconst int inf =1 << 29;\n\nstring in;\nstring l,r;\nsize_t cur;\n\nbool rel[2][2];\n\nbool formula(string &in,int mask){\n\tint n=in.size();\n\twhile(cur<n){\n\t\tif(isupper(in[cur])){\n\t\t\tbool res=(in[cur++]=='T');\n\t\t\treturn res;\n\t\t}\n\t\tif(islower(in[cur])){\n\t\t\tint index=(in[cur++]-'a');\n\t\t\tbool res=((mask&(1<<index))>0);\n\t\t\treturn res;\n\t\t}\n\t\tif(in[cur]=='-'){\n\t\t\tcur++;\n\t\t\tbool res=formula(in,mask)^true;\n\t\t\treturn res;\n\t\t}\n\t\tif(in[cur]=='('){\n\t\t\tcur++;\n\t\t\tbool a=formula(in,mask);\n\t\t\tchar op=in[cur++];\n\t\t\tif(op=='-') cur++;\n\t\t\tbool b=formula(in,mask);\n\t\t\tcur++;\n\t\t\tswitch(op){\n\t\t\t\tcase '+':\n\t\t\t\t\treturn a||b;\n\t\t\t\tcase '*':\n\t\t\t\t\treturn a&&b;\n\t\t\t\tcase '-':\n\t\t\t\t\treturn rel[a][b];\n\t\t\t}\n\t\t}\n\t}\n\treturn true;\n}\n\nbool equation(){\n\tbool res=true;\n\tint n=in.size(),s;\n\tfor(s=0;s<n;++s)if(in[s]=='=')break;\n\tl=in.substr(0,s);\n\tr=in.substr(s+1,n-s-1);\n\trep(mask,1<<11){\n\t\tcur=0;\n\t\tbool resl=formula(l,mask);\n\t\tcur=0;\n\t\tbool resr=formula(r,mask);\n\t\tres&=(resl==resr);\n\t}\n\treturn res;\n}\n\nint main(void){\n\trel[0][0]=rel[0][1]=rel[1][1]=true;\n\trel[1][0]=false;\n\twhile(cin >> in){\n\t\tif(in==\"#\")\n\t\t\tbreak;\n\t\tbool ans=equation();\n\t\tif(ans)\n\t\t\tputs(\"YES\");\n\t\telse\n\t\t\tputs(\"NO\");\n\t}\n\treturn 0;\n}"
  },
  {
    "language": "C++",
    "code": "#define _USE_MATH_DEFINES\n#define INF 0x3f3f3f3f\n\n#include <iostream>\n#include <cstdio>\n#include <sstream>\n#include <cmath>\n#include <cstdlib>\n#include <algorithm>\n#include <queue>\n#include <stack>\n#include <limits>\n#include <map>\n#include <string>\n#include <cstring>\n#include <set>\n#include <deque>\n#include <bitset>\n#include <list>\n#include <cctype>\n#include <utility>\n  \nusing namespace std;\n  \ntypedef long long ll;\ntypedef pair <int,int> P;\ntypedef pair <int,P> PP;\n  \nstatic const double EPS = 1e-8;\n  \nstatic const int tx[] = {0,1,0,-1};\nstatic const int ty[] = {-1,0,1,0};\n\nstruct ParseInfo {\n  int pos;\n  bool val;\n};\n\nset<char> char_set;\nbool char_table[256];\n\nParseInfo parse_formula(int pos, const string& str){\n\n  if('a' <= str[pos] && str[pos] <= 'k'){\n    bool val = false;\n    ParseInfo pi = {pos+1,val};\n    return pi;\n  }\n\n  else if(str[pos] == 'T'){\n    bool val = true;\n    ParseInfo pi = {pos+1,val};\n    return pi;\n  }\n\n  else if(str[pos] == 'F'){\n    bool val = false;\n    ParseInfo pi = {pos+1,val};\n    return pi;\n  }\n\n  else if(str[pos] == '-'){\n    ParseInfo pi = parse_formula(pos+1,str);\n    pi.val = ~pi.val;\n    return pi;\n  }\n\n  else if(str[pos] == '('){\n    ParseInfo pi1 = parse_formula(pos+1,str);\n    if(str[pi1.pos] == '*'){\n      ParseInfo pi2 = parse_formula(pi1.pos+1,str);\n      pi2.val = (pi1.val && pi2.val);\n      \n      //skip ')'\n      pi2.pos++;\n      return pi2;\n    }\n    else if(str[pi1.pos] == '+'){\n      ParseInfo pi2 = parse_formula(pi1.pos+1,str);\n      pi2.val = (pi1.val || pi2.val);\n\n      //skip ')'\n      pi2.pos++;\n      return pi2;\n    }\n    else if(str[pi1.pos] == '-'\n\t    && str[pi1.pos+1] == '>'){\n      ParseInfo pi2 = parse_formula(pi1.pos+2,str);\n      pi2.val = (~pi1.val || pi2.val);\n\n      //skip ')'\n      pi2.pos++;\n      return pi2;\n    }\n  }\n}\n\nParseInfo parse_equation(int pos, const string& str){\n  ParseInfo pi1 = parse_formula(pos,str);\n  \n  //skip '='\n  ParseInfo pi2 = parse_formula(pi1.pos+1,str);\n  pi2.val = (pi1.val == pi2.val) ? true : false;\n  return pi2;\n}\n\n\nint main(){\n  string str;\n  while(cin >> str){\n    if(str == \"#\") break;\n\n\n    for(int i=0;i<str.size();i++){\n      if('a' <= str[i] && str[i] <= 'k'){\n\tchar_set.insert(str[i]);\n      }\n    }\n\n    int idx = 0;\n    bool isok = true;\n    for(int S=0;S<=(1<<char_set.size())-1;S++){\n      for(set<char>::iterator it = char_set.begin();\n\t  it != char_set.end();\n\t  it++){\n\tchar_table[*it] = (S & (1<<idx));\n\tidx++;\n      }\n      ParseInfo pi = parse_equation(0,str);\n      if(!pi.val) isok = false;\n    }\n    printf(\"%s\\n\",isok ? \"YES\" : \"NO\");\n  }\n}"
  },
  {
    "language": "C++",
    "code": "#include <iostream>\n#include <cstring>\n#include <cctype>\n#include <map>\n#include <cmath>\n#include <set>\nusing namespace std;\nstring str, str1, str2;\nint pos;\nmap<char, int> chset;\n\nbool formula(){\n    bool res;\n    if (str[pos] == 'T') {pos++; return true;}\n    if (str[pos] == 'F') {pos++; return false;}\n    if (chset.find(str[pos]) != chset.end()) {return chset[str[pos++]];}\n    if (str[pos] == '-' && str[pos + 1] != '>') {\n        pos++;\n        return !formula();\n    }\n\n    if (str[pos] == '(') {\n        pos++;\n        res = formula();\n        if (str[pos] == '*') {\n            pos++;\n            res &= formula();\n        }\n        else if (str[pos] == '+') {\n            pos++;\n            res |= formula();\n        }\n        else if (str[pos] == '-' && str[pos + 1] == '>') {\n            pos += 2;\n            res = !res | formula();\n        }\n        pos++;\n    }\n    return res;\n}\n\nvoid equation(){\n    set<char> S;\n    string chlist = \"\";\n    for (int i = 0; i < str.size(); i++) {\n        if (islower(str[i])) {\n            S.insert(str[i]);\n        }\n    }\n    set<char>::iterator it = S.begin();\n    while (it != S.end()) {\n        chlist += *it;\n        ++it;\n    }\n    \n    for (int i = 0; i < pow(2, chlist.size()) - 1; i++) {\n        for (int j = 0; j < chlist.size(); j++) {\n            chset[chlist[j]] = (i >> j) & 1;\n        }\n        pos = 0;\n        str = str1;\n        int res1 = formula();\n        pos = 0;\n        str = str2;\n        int res2 = formula();\n        if (res1 != res2) {\n            cout << \"NO\" << endl;\n            return;\n        }\n    }\n    cout << \"YES\" << endl;\n}\n\nint main()\n{\n    while (true) {\n        cin >> str;\n        if (str == \"#\") {\n            break;\n        }\n        str1 = \"\"; str2 = \"\";\n        for (int i = 0; i < str.size(); i++) {\n            if (str[i] == '=') {\n                str2 = str1;\n                str1 = \"\";\n            }\n            else {\n                str1 += str[i];\n            }\n        }\n        equation();\n    }\n    return 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include <iostream>\n#include <string>\n#include <sstream>\n\nusing namespace std;\nint bits;\nchar str[1010];\nchar *sp;\n\nint formula(){\n\tchar c;\n\tc=*sp++;\n\tif('a'<=c&&c<'k') return bits>>(c-'a')&1;\n\tif(c=='T') return 1;\n\tif(c=='F') return 0;\n\tif(c=='-') return !formula();\n\tif(c=='('){\n\t\tint left, right;\n\t\tchar ope;\n\t\tleft = formula();\n\t\tope = *sp++;\n\t\tif(ope=='-') sp++;\n\t\tright = formula();\n\t\tsp++;\n\t\tif(ope=='*') return  left && right;\n\t\tif(ope=='+') return  left || right;\n\t\tif(ope=='-') return !left || right;\n\t}\n\treturn 0;\n}\n\nint equation(){\n\tint left,right;\n\tleft=formula();\n\tsp++;\n\tright=formula();\n\treturn left==right;\n}\n\nint main(){\n\twhile(cin>>str, *str!='#'){\n\t\tfor(bits=0;bits<2<<11;bits++){\n\t\t\tsp = str;\n\t\t\tif(!equation()) break;\n\t\t}\n\t\tcout<<(bits<2<<11?\"NO\":\"YES\")<<endl;\n\t}\n}"
  },
  {
    "language": "C++",
    "code": "\n#include <iostream>\n#include <string>\n\nusing namespace std;\n\nstring s;\nint i;\nbool f[256];\n\nbool imp(bool x, bool y){\n\tif ( x &&  y)return true;\n\tif ( x && !y)return false;\n\tif (!x &&  y)return true;\n\tif (!x && !y)return true;\n}\n\nbool form(){\n\t\n\tif (s[i] == 'T'){ i++; return true; }\n\tif (s[i] == 'F'){ i++; return false; }\n\n\tif (s[i] >= 'a' && s[i] <= 'k'){\n\t\ti++; return f[s[i]];\n\t}else\n\tif (s[i] == '-'){\n\t\ti++; return !form();\n\t}else\n\tif (s[i] == '('){\n\t\ti++; bool c = form();\n\n\t\tif (s[i] == '*'){\n\t\t\ti++;  bool tc = form(); i++; return tc && c;\n\t\t}\n\t\tif (s[i] == '+'){\n\t\t\ti++;  bool tc = form(); i++; return tc || c;\n\t\t}\n\t\tif(s[i] == '-' && s[i+1] == '>')\n\t\t{\n\t\t\ti+=2; bool tc = form(); i++; return imp(c,tc);\n\t\t}\n\t}\n}\n\nbool equation(){\n\ti = 0;\n\tbool t = form();i++;\n\treturn t == form();\n}\n\nbool dfs(int n){\n\n\tif (n == 'k' + 1){\n\t\treturn equation();\n\t}\n\tf[n] = true;\n\tbool ret = dfs(n+1);\n\tf[n] = false;\n\treturn ret && dfs(n + 1);\n}\n\n\nint main()\n{\n\n\twhile (cin >> s && s != \"#\"){\n\t\tmemset(f,0,256*sizeof(bool));\n\t\ts += \" \";\n\t\tif (dfs('a'))\n\t\t\tcout << \"YES\" << endl;\n\t\telse\n\t\t\tcout << \"NO\" << endl;\n\t}\n\n\treturn 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include<iostream>\n#include<string>\n#include<map>\n#include<sstream>\n#include<cctype>\n#include<algorithm>\nusing namespace std;\ntypedef string::const_iterator Cursol;\nbool ok;\nint bit;\nbool Formula(Cursol &c){\n  bool ret;\n\n  if(*c == 'T') ret = true;\n  else if(*c == 'F') ret = false;\n  else if(islower(*c)) ret = bit >> ((*c) - 'a') & 1;\n  else if(*c == '-') return !Formula(++c);\n  else if(*c == '('){\n    ret = Formula(++c);\n    if(*c == '+'){\n      ret |= Formula(++c);\n    }else if(*c == '*'){\n      ret &= Formula(++c);\n    }else if(*c == '-'){ //->\n      c++;\n      ret = !ret | Formula(++c);\n    }\n  }\n  c++;\n  return ret;\n}\nint main(){\n  string s;\n  Cursol c;\n  while(cin >> s , ok = true, s != \"#\"){\n    string l = s.substr(0,s.find('='));\n    string r = s.substr(s.find('=')+1);\n\n    for(bit = 0 ; bit < (1 << 11) ; bit++ ){\n      c = l.begin();\n      bool java = Formula(c);\n      c = r.begin();\n      if( java != Formula(c) ){\n\tok = false;\n\tbreak;\n      }\n    }\n    if(ok) cout << \"YES\" << endl;\n    else cout << \"NO\" << endl;\n  }\n}"
  },
  {
    "language": "C++",
    "code": "#include <cstdio>\n#include <cstring>\n#include <string>\n#include <iostream>\n#include <cctype>\n#include <vector>\nusing namespace std;\ntypedef string::const_iterator State;\n\n\nvector<int> term(State &begin);\nvector<int> formula(State &begin);\nvector<int> factor(State &begin);\n\nstring data[2];\nvector<int> g[2];\n\nvector<int> formula(State &begin){\n\tvector<int> del(11,0);\n\tint flag=1;\n\tif(*begin=='-'){\n\t\tflag=0;\n\t\tbegin++;\n\t}\n\tif(*begin>='a' && *begin<='k'){\n\t\tfor(int i=0;i<11;i++){\n\t\t\tdel[i]=1-flag;\n\t\t\tif(i==*begin-'a')del[i]=flag;\n\t\t}\n\t}\n\tif(*begin=='T'){\n\t\tfor(int i=0;i<11;i++){\n\t\t\tdel[i]=flag;\n\t\t}\n\t}\n\tif(*begin=='F'){\n\t\tfor(int i=0;i<11;i++){\n\t\t\tdel[i]=1-flag;\n\t\t}\n\t}\n\tbegin++;\n\treturn del;\n}\n\nvector<int> factor(State &begin){\n\tif(*begin=='('){\n\t\tbegin++;\n\t\tvector<int> ret=term(begin);\n\t\tbegin++;\n\t\treturn ret;\n\t}else{\n\t\treturn formula(begin);\n\t}\n}\n\nvector<int> term(State &begin){\n\tbool flag=false;\n\tif(*begin=='-'){\n\t\tflag=true;\n\t\tbegin++;\n\t}\n\tvector<int> ret=factor(begin);\n\tif(flag){\n\t\tfor(int i=0;i<11;i++){\n\t\t\tret[i]=1-ret[i];\n\t\t}\n\t}\n\twhile(1){\n\t\tif(*begin=='+'){\n\t\t\tbegin++;\n\t\t\tvector<int> ret2=factor(begin);\n\t\t\tfor(int i=0;i<11;i++){\n\t\t\t\tret[i]=ret[i]|ret2[i];\n\t\t\t}\n\t\t}\n\t\tif(*begin=='*'){\n\t\t\tbegin++;\n\t\t\tvector<int> ret2=factor(begin);\n\t\t\tfor(int i=0;i<11;i++){\n\t\t\t\tret[i]=ret[i]&ret2[i];\n\t\t\t}\n\t\t}\n\t\tif(*begin=='-'){\n\t\t\tbegin++;\n\t\t\tif(*begin=='>'){\n\t\t\t\tvector<int> ret2=factor(begin);\n\t\t\t\tfor(int i=0;i<11;i++){\n\t\t\t\t\tret[i]=!ret[i]|ret2[i];\n\t\t\t\t}\n\t\t\t}else{\n\t\t\t\tprintf(\"error\\n\");\n\t\t\t\treturn ret;\n\t\t\t}\n\t\t}else{\n\t\t\tbreak;\n\t\t}\n\t}\n\treturn ret;\n}\n\nint main(void){\n\twhile(1){\n\t\tstring str;\n\t\tcin >> str;\n\t\tif(str==\"#\")break;\n\t\tdata[0]=data[1]=\"\";\n\t\tint v=0;\n\t\tfor(int i=0;i<str.size();i++){\n\t\t\tif(str[i]=='=')v++;\n\t\t\telse data[v]+=str[i];\n\t\t}\n\t\tfor(int i=0;i<2;i++){\n\t\t\tState begin=data[i].begin();\n\t\t\tg[i]=term(begin);\n\t\t}\n\t\tbool flag=true;\n\t\tfor(int i=0;i<11;i++){\n\t\t\tif(g[0][i]!=g[1][i])flag=false;\n\t\t}\n\t\tprintf(\"%s\\n\",flag?\"YES\":\"NO\");\n\t}\n\treturn 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include <list>\n#include <vector>\n#include <map>\n#include <set>\n#include <stack>\n#include <queue>\n#include <deque>\n#include <algorithm>\n#include <utility>\n#include <functional>\n#include <sstream>\n#include <iostream>\n#include <cstdio>\n#include <cmath>\n#include <cstdlib>\n#include <cctype>\n#include <string>\n#include <cstring>\n#include <ctime>\n#include <climits>\nusing namespace std;\ninline int toInt(string s) { int v; istringstream sin(s); sin >> v; return v;}\ntemplate<class T> inline string toString(T x) { ostringstream sout; sout << x; return sout.str();}\ntypedef vector<int> vi;\ntypedef vector<vi>  vvi;\ntypedef vector<string> vs;\ntypedef pair<int, int> pii;\ntypedef long long ll;\n#define ALL(a) (a).begin(),(a).end()\n#define RALL(a) (a).rbegin(),(a).rend()\n#define EACH(t,i,c) for(t::iretator i=(c).begin(); i!=(c).end(); ++i)\n#define EXIST(s,e) ((s).find(e)!=(s).end())\n#define FOR(i,a,b) for(int i=(a);i<=(b);++i)\n#define REP(i,n) FOR(i,0,(n)-1)\nconst double EPS = 1e-12;\nconst double PI = acos(-1.0);\n\nint pos;\n\nbool parse(string s) {\n\tswitch(s[pos]) {\n\tcase 'T':\n\t\t++pos;\n\t\treturn true;\n\tcase 'F':\n\t\t++pos;\n\t\treturn false;\n\tcase '-':\n\t\t++pos;\n\t\treturn !parse(s);\n\tcase '(':\n\t\t++pos;\n\t\tbool a = parse(s);\n\t\tchar op = s[pos];\n\t\t++pos;\n\t\tif(op == '-')\n\t\t\t++pos;\n\t\tbool b = parse(s);\n\t\tswitch (op) {\n\t\tcase '*':\n\t\t\treturn a&&b;\n\t\tcase '+':\n\t\t\treturn a||b;\n\t\tcase '-':\n\t\t\treturn !a||b;\n\t\t}\n\t}\n}\n\nint main() {\n\tstring str;\n\twhile(cin >> str, str != \"#\") {\n\t\tset<char> cha;\n\t\tREP(i, str.size()) {\n\t\t\tif(islower(str[i]))\n\t\t\t\tcha.insert(str[i]);\n\t\t}\n\t\tint size = cha.size();\n\n\t\tmap<int, char> m;\n\t\tint count = 0;\n\t\tset<char>::iterator it = cha.begin();\n\t\twhile(it != cha.end()) {\n\t\t\tm[count] = *it;\n\t\t\t++count;\n\t\t\t++it;\n\t\t}\n\n\t\tREP(i, 1<<size) {\n\t\t\tstring s = str;\n\t\t\tREP(j, size) {\n\t\t\t\tif(i&(1<<j)) {\n\t\t\t\t\tREP(k, s.size()) {\n\t\t\t\t\t\tif(s[k] == m[j]) {\n\t\t\t\t\t\t\ts[k] = 'T';\n\t\t\t\t\t\t}\n\t\t\t\t\t}\n\t\t\t\t} else {\n\t\t\t\t\tREP(k, s.size()) {\n\t\t\t\t\t\tif(s[k] == m[j]) {\n\t\t\t\t\t\t\ts[k] = 'F';\n\t\t\t\t\t\t}\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t}\n\t\t\t\t\t\n\t\t\tstring left = s.substr(0, s.find(\"=\"));\n\t\t\tstring right = s.substr(s.find(\"=\")+1, s.size()-1);\n\t\t\t\n\t\t\tpos = 0;\n\t\t\tbool l = parse(left);\n\t\t\tpos = 0;\n\t\t\tbool r = parse(right);\n\t\t\tif(l != r) {\n\t\t\t\tcout << \"NO\" << endl;\n\t\t\t\tgoto next;\n\t\t\t}\n\t\t}\n\n\t\tcout << \"YES\" << endl;\nnext:\n\t\t;\n\t}\n\n\treturn 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include <iostream>\n#include <vector>\n#include <algorithm>\n#include <string>\n#include <sstream>\n#include <cstring>\n#include <cstdlib>\n#include <cstdio>\n#include <cmath>\n#include <queue>\n#include <stack>\n#include <map>\n#include <set>\n#include <bitset>\n \n#define rep(i, n) for(int i = 0; i < (n); i++)\n#define FOR(i, a, b) for(int i = (a); i < (b); i++)\n#define all(v) (v).begin(), (v).end()\n#define rev(s) (s).rbegin(), (s).rend()\n#define MP make_pair\n#define X first\n#define Y second\n \nusing namespace std;\n \ntypedef long long ll;\ntypedef pair<int, int> P;\ntypedef vector<int> vi;\n\nvoid fin(){\n\tfreopen(\"test.txt\", \"r\", stdin);\n}\n\nbool formula(const string &s){\n\trep(i,2){\n\t\tif(s[0] == \"FT\"[i]) return i;\n\t}\n\n\tif(s[0] == '-'){\n\t\treturn !formula(s.substr(1));\n\t}\n\n\tint lidx = 1, llen, ridx, rlen;\n\tchar ope;\n\tint nest = 0;\n\trep(i, s.size()){\n\t\tif(s[i] == '(') nest++;\n\t\tif(s[i] == ')') nest--;\n\t\tif(nest != 1) continue;\n\t\trep(j, 3) if(s[i] == \"*+>\"[j]){\n\t\t\tope = s[i];\n\t\t\tllen= i-1-(s[i] == '>');\n\t\t\tridx = i+1;\n\t\t\trlen = s.size()-ridx-1;\n\t\t\tgoto next;\n\t\t}\n\t}\nnext:\n\tbool lhs = formula(s.substr(lidx, llen));\n\tbool rhs = formula(s.substr(ridx, rlen));\n\t\n\tif(ope == '+') return lhs|rhs;\n\tif(ope == '*') return lhs&rhs;\n\tif(lhs&(!rhs)) return false;\n\treturn true;\n}\n\nbool equation(string &s){\n\trep(i, s.size()){\n\t\tif(s[i] != '=') continue;\n\t\treturn formula(s.substr(0, i)) == formula(s.substr(i+1, s.size()));\n\t}\n\treturn false;\n}\n\nstring replace(const string &s, const char from, const char to){\n\tstring res = s;\n\trep(i, res.size()){\n\t\tif(res[i] == from) res[i] = to;\n\t}\n\treturn res;\n}\n\nbool include(const string &s, const char c){\n\trep(i, s.size()){\n\t\tif(s[i] == c) return true;\n\t}\n\treturn false;\n}\n\nstring val = \"abcdefghijk\";\nbool dfs(string &s, int i = 0){\n\tif(i == val.size()) return equation(s);\n\tif(!include(s, val[i])) return dfs(s, i+1);\n\trep(j, 2){\n\t\tif(!dfs(replace(s, val[i], \"TF\"[j]), i+1)) return false;\n\t}\n\treturn true;\n}\n\nint main(){\n//\tfin();\n\tstring s;\n\twhile(cin >> s){\n\t\tif(s[0] == '#') break;\n\t\tcout << (dfs(s)?\"YES\":\"NO\") << endl;\n\t}\n\n\treturn 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include<iostream>\n#include<string>\n#define MAX 11\nusing namespace std;\nbool o;\nvoid rec(string s){\n  if(!o) return;\n  //cout << s << endl;\n  bool f;\n  int p;\n\n  \n  if(s.find(\"-0\")!=-1){\n    p=s.find(\"-0\");\n    //s[p]='1';s[p+1]=' ';\n    //f=true;\n  }\n  if(s.find(\"-1\")!=-1){\n    p=s.find(\"-1\");\n    //s[p]='0';s[p+1]=' ';\n    //f=true;\n  }\n  \n  /*\n  while(s.find(\"(0*0)\")!=-1){\n    p=s.find(\"(0*0)\");\n    s[p]='0';s[p+1]=' ';s[p+2]=' ';s[p+3]=' ';s[p+4]=' ';\n    f=true;\n  }\n  while(s.find(\"(0*1)\")!=-1){\n    p=s.find(\"(0*1)\");\n    s[p]='0';s[p+1]=' ';s[p+2]=' ';s[p+3]=' ';s[p+4]=' ';\n    f=true;\n  }\n  while(s.find(\"(1*0)\")!=-1){\n    p=s.find(\"(1*0)\");\n    s[p]='0';s[p+1]=' ';s[p+2]=' ';s[p+3]=' ';s[p+4]=' ';\n    f=true;\n  }\n  while(s.find(\"(1*1)\")!=-1){\n    p=s.find(\"(1*1)\");\n    s[p]='1';s[p+1]=' ';s[p+2]=' ';s[p+3]=' ';s[p+4]=' ';\n    f=true;\n  }\n  while(s.find(\"(0+0)\")!=-1){\n    p=s.find(\"(0+0)\");\n    s[p]='0';s[p+1]=' ';s[p+2]=' ';s[p+3]=' ';s[p+4]=' ';\n    f=true;\n  }\n  while(s.find(\"(0+1)\")!=-1){\n    p=s.find(\"(0+1)\");\n    s[p]='1';s[p+1]=' ';s[p+2]=' ';s[p+3]=' ';s[p+4]=' ';\n    f=true;\n  }\n  while(s.find(\"(1+0)\")!=-1){\n    p=s.find(\"(1+0)\");\n    s[p]='1';s[p+1]=' ';s[p+2]=' ';s[p+3]=' ';s[p+4]=' ';\n    f=true;\n  }\n  while(s.find(\"(1+1)\")!=-1){\n    p=s.find(\"(1+1)\");\n    s[p]='1';s[p+1]=' ';s[p+2]=' ';s[p+3]=' ';s[p+4]=' ';\n    f=true;\n  }\n  \n  while(s.find(\"(0->0)\")!=-1){\n    p=s.find(\"(0->0)\");\n    s[p]='1';s[p+1]=' ';s[p+2]=' ';s[p+3]=' ';s[p+4]=' ';s[p+5]=' ';\n    f=true;\n  }\n  while(s.find(\"(0->1)\")!=-1){\n    p=s.find(\"(0->1)\");\n    s[p]='1';s[p+1]=' ';s[p+2]=' ';s[p+3]=' ';s[p+4]=' ';s[p+5]=' ';\n    f=true;\n  }\n  while(s.find(\"(1->0)\")!=-1){\n    p=s.find(\"(1->0)\");\n    s[p]='0';s[p+1]=' ';s[p+2]=' ';s[p+3]=' ';s[p+4]=' ';s[p+5]=' ';\n    f=true;\n  }\n  while(s.find(\"(1->1)\")!=-1){\n    p=s.find(\"(1->1)\");\n    s[p]='1';s[p+1]=' ';s[p+2]=' ';s[p+3]=' ';s[p+4]=' ';s[p+5]=' ';\n    f=true;\n  }\n  */\n  if(f){\n    string b;\n    for(int i=0;i<s.size();i++) if(s[i]!=' ') b+=s[i];\n    rec(b);\n  }else{\n    if(s[0]!=s[2]) o=false;\n    return;\n  }\n}\nvoid init(int n,string s){\n  int i,j;\n  for(i=0;i<s.size();i++){\n    for(j=0;j<=MAX;j++){\n      if(s[i]=='a'+j) s[i]='0'+(n>>j&1);\n      if(s[i]=='T') s[i]='1';\n      if(s[i]=='F') s[i]='0';\n    }\n  }\n  rec(s);\n}\nint main(){\n  string s;\n  while(cin >> s,s!=\"#\"){\n    o=true;\n    int i;\n    for(i=0;i<(1<<MAX);i++)\n      init(i,s);\n    cout << (o?\"YES\":\"NO\") << endl;\n  }\n  return 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include<cctype>\n#include<cstdio>\n#include<vector>\n#include<cstring>\n#include<algorithm>\n\n#define rep(i,n) for(int i=0;i<(n);i++)\n\nusing namespace std;\n\nint pos;\nchar s[128];\n\nbool formula(){\n\tif(s[pos]=='T'){\n\t\tpos++;\n\t\treturn true;\n\t}\n\telse if(s[pos]=='F'){\n\t\tpos++;\n\t\treturn false;\n\t}\n\telse if(s[pos]=='-'){\n\t\tpos++;\n\t\treturn !formula();\n\t}\n\telse if(s[pos]=='('){\n\t\tpos++;\n\t\tbool a=formula();\n\t\tchar op=s[pos];\n\t\tif(op=='-') pos+=2;\n\t\telse        pos++;\n\t\tbool b=formula();\n\t\tpos++;\n\t\tswitch(op){\n\t\t\tcase '*': return a&&b;\n\t\t\tcase '+': return a||b;\n\t\t\tcase '-': return !a||b;\n\t\t}\n\t\t// error\n\t}\n}\n\nbool parse(const char *s){\n\tstrcpy(::s,s);\n\tpos=0;\n\treturn formula();\n}\n\nint main(){\n\tfor(char s[128];scanf(\"%s\",s),s[0]!='#';){\n\t\tint n=strlen(s);\n\t\tvector<char> C;\n\t\tint eq;\n\t\trep(i,n){\n\t\t\tif(s[i]=='=') eq=i;\n\t\t\tif(islower(s[i])) C.push_back(s[i]);\n\t\t}\n\t\tsort(C.begin(),C.end());\n\t\tC.erase(unique(C.begin(),C.end()),C.end());\n\n\t\tbool ok=true;\n\t\trep(S,1<<C.size()){\n\t\t\tchar tmp[128];\n\t\t\tstrcpy(tmp,s);\n\n\t\t\t// T or F を代入\n\t\t\trep(i,n) if(islower(s[i])) {\n\t\t\t\tint pos=find(C.begin(),C.end(),s[i])-C.begin();\n\t\t\t\ts[i]=(S&1<<pos?'T':'F');\n\t\t\t}\n\n\t\t\tif(parse(s)!=parse(s+eq+1)) ok=false;\n\n\t\t\tstrcpy(s,tmp);\n\t\t}\n\t\tputs(ok?\"YES\":\"NO\");\n\t}\n\n\treturn 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include <iostream>\n#include <string>\n#include <algorithm>\n\nusing namespace std;\n\nconst char ch[] = {'T', 'F'};\n\n// 入力\nstring s;\n\nint eval(const string &s, int &pos) {\n\tif (s[pos] == 'F') {\n\t\tpos++;\n\t\treturn 0;\n\t}\n\tif (s[pos] == 'T') {\n\t\tpos++;\n\t\treturn 1;\n\t}\n\tif (s[pos] == '-') {\n\t\tpos++;\n\t\tint v = eval(s, pos);\n\t\treturn 1 - v;\n\t}\n\tif (s[pos] == '(') {\n\t\tpos++;\n\t\tint v1 = eval(s, pos);\n\t\tif (s[pos] == '*') {\n\t\t\tpos++;\n\t\t\tint v2 = eval(s, pos);\n\t\t\tpos++;\n\t\t\tint v = min(v1, v2);\n\t\t\treturn v;\n\t\t}\n\t\tif (s[pos] == '+') {\n\t\t\tpos++;\n\t\t\tint v2 = eval(s, pos);\n\t\t\tpos++;\n\t\t\tint v = max(v1, v2);\n\t\t\treturn v;\n\t\t}\n\t\tif (s[pos] == '-') {\n\t\t\t// \"->\"の場合\n\t\t\tpos += 2; // 演算子が2文字なので，その分だけずらす\n\t\t\tint v2 = eval(s, pos);\n\t\t\tpos++;\n\t\t\tint v = (v1 == 1 && v2 == 0) ? 0 : 1;\n\t\t\treturn v;\n\t\t}\n\t}\n}\n\nvoid solve() {\n\tfor (int a = 0; a < 2; a++) {\n\t\tfor (int b = 0; b < 2; b++) {\n\t\t\tfor (int c = 0; c < 2; c++) {\n\t\t\t\tfor (int d = 0; d < 2; d++) {\n\t\t\t\t\tfor (int e = 0; e < 2; e++) {\n\t\t\t\t\t\tfor (int f = 0; f < 2; f++) {\n\t\t\t\t\t\t\tfor (int g = 0; g < 2; g++) {\n\t\t\t\t\t\t\t\tfor (int h = 0; h < 2; h++) {\n\t\t\t\t\t\t\t\t\tfor (int i = 0; i < 2; i++) {\n\t\t\t\t\t\t\t\t\t\tfor (int j = 0; j < 2; j++) {\n\t\t\t\t\t\t\t\t\t\t\tfor (int k = 0; k < 2; k++) {\n\t\t\t\t\t\t\t\t\t\t\t\tstring tmp = s;\n\t\t\t\t\t\t\t\t\t\t\t\tfor (int l = 0; l < (int)tmp.length(); l++) {\n\t\t\t\t\t\t\t\t\t\t\t\t\tif (tmp[l] == 'a') {\n\t\t\t\t\t\t\t\t\t\t\t\t\t\ttmp[l] = ch[a];\n\t\t\t\t\t\t\t\t\t\t\t\t\t} else if (tmp[l] == 'b') {\n\t\t\t\t\t\t\t\t\t\t\t\t\t\ttmp[l] = ch[b];\n\t\t\t\t\t\t\t\t\t\t\t\t\t} else if (tmp[l] == 'c') {\n\t\t\t\t\t\t\t\t\t\t\t\t\t\ttmp[l] = ch[c];\n\t\t\t\t\t\t\t\t\t\t\t\t\t} else if (tmp[l] == 'd') {\n\t\t\t\t\t\t\t\t\t\t\t\t\t\ttmp[l] = ch[d];\n\t\t\t\t\t\t\t\t\t\t\t\t\t} else if (tmp[l] == 'e') {\n\t\t\t\t\t\t\t\t\t\t\t\t\t\ttmp[l] = ch[e];\n\t\t\t\t\t\t\t\t\t\t\t\t\t} else if (tmp[l] == 'f') {\n\t\t\t\t\t\t\t\t\t\t\t\t\t\ttmp[l] = ch[f];\n\t\t\t\t\t\t\t\t\t\t\t\t\t} else if (tmp[l] == 'g') {\n\t\t\t\t\t\t\t\t\t\t\t\t\t\ttmp[l] = ch[g];\n\t\t\t\t\t\t\t\t\t\t\t\t\t} else if (tmp[l] == 'h') {\n\t\t\t\t\t\t\t\t\t\t\t\t\t\ttmp[l] = ch[h];\n\t\t\t\t\t\t\t\t\t\t\t\t\t} else if (tmp[l] == 'i') {\n\t\t\t\t\t\t\t\t\t\t\t\t\t\ttmp[l] = ch[i];\n\t\t\t\t\t\t\t\t\t\t\t\t\t} else if (tmp[l] == 'j') {\n\t\t\t\t\t\t\t\t\t\t\t\t\t\ttmp[l] = ch[j];\n\t\t\t\t\t\t\t\t\t\t\t\t\t} else if (tmp[l] == 'k') {\n\t\t\t\t\t\t\t\t\t\t\t\t\t\ttmp[l] = ch[k];\n\t\t\t\t\t\t\t\t\t\t\t\t\t}\n\t\t\t\t\t\t\t\t\t\t\t\t}\n\t\t\t\t\t\t\t\t\t\t\t\t\n\t\t\t\t\t\t\t\t\t\t\t\tint pos = 0;\n\t\t\t\t\t\t\t\t\t\t\t\tint f1 = eval(tmp, pos);\n\t\t\t\t\t\t\t\t\t\t\t\tpos++;\n\t\t\t\t\t\t\t\t\t\t\t\tint f2 = eval(tmp, pos);\n\t\t\t\t\t\t\t\t\t\t\t\tif (f1 != f2) {\n\t\t\t\t\t\t\t\t\t\t\t\t\tcout << \"NO\" << endl;\n\t\t\t\t\t\t\t\t\t\t\t\t\treturn;\n\t\t\t\t\t\t\t\t\t\t\t\t}\n\t\t\t\t\t\t\t\t\t\t\t}\n\t\t\t\t\t\t\t\t\t\t}\n\t\t\t\t\t\t\t\t\t}\n\t\t\t\t\t\t\t\t}\n\t\t\t\t\t\t\t}\n\t\t\t\t\t\t}\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t}\n\tcout << \"YES\" << endl;\n}\n\nint main() {\n\twhile (true) {\n\t\tgetline(cin, s);\n\t\tif (s[0] == '#') {\n\t\t\tbreak;\n\t\t}\n\t\tsolve();\n\t}\n}"
  },
  {
    "language": "C++",
    "code": "#include<bits/stdc++.h>\nusing namespace std;\nint used[11];\n\nbool famula(string &s, int &i){\n  //std::cout << s[i];\n  if(s[i] == 'T'){\n    i++;\n    return true;\n  }else if(s[i] == 'F'){\n    i++;\n    return false;\n  }else if(s[i] == '-'){\n    i++;\n    return !famula(s, i);\n  }else if('a' <= s[i] && s[i] <= 'z'){\n    return used[s[i++] - 'a'];\n  }else{\n    i++;\n    bool a = famula(s, i);\n    char op = s[i++];\n    bool b = famula(s, i);\n    i++;\n    if(op == '*'){\n      return a & b;\n    }else if(op == '+'){\n      return a | b;      \n    }else if(op == '>'){\n      return (!a) | b;\n    }\n  }\n}\n\nbool equation(string &s, int &i){\n  bool val = famula(s, i), val2;\n  while(s[i] == '='){\n    i++;\n    val2 = famula(s, i);\n  }\n  return val == val2;\n}\n\nint main(int argc, char *argv[]){\n  string s;\n  while(cin >> s){\n    if(s == \"#\")break;\n    for (int i = 0; i < s.length(); i++) {\n      if(s[i] == '-' && s[i + 1] == '>')s.erase(s.begin() + i--);\n    }\n    int ans = true;\n    for (int i = 0; i < (1 << 11); i++) {\n      int pos = 0;\n      for (int j = 0; j < s.length(); j++) {\n        if('a' <= s[j] && s[j] <= 'z')\n          used[s[j] - 'a'] = i&(1 << (s[j] - 'a'));\n      }\n      if(equation(s, pos) == false){\n        ans = false;\n        std::cout << \"no\" << std::endl;\n        break;\n      }\n    }\n    if(ans)std::cout << \"yes\" << std::endl;\n  }\n  return 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include <iostream>\n#include <map>\n#include <string>\n#include <cstring>\n#include <vector>\n#include <algorithm>\n#include <cstdio>\nusing namespace std;\n\n// C\n\nbool alpha[13];\n\nbool NOT(bool x){\n    return !x;\n}\n\nbool AND(bool x, bool y){\n    return (x && y);\n}\n\nbool OR(bool x, bool y){\n    return (x || y);\n}\n\nbool IMP(bool x, bool y){\n    if( x == true && y == false ) return false;\n    return true;\n}\n\n\nbool formula(const string& str, int s, int t){ // [s,t)\n    int i;\n\n    //cout << \"debug : \" << str << \" , \" << s << \" , \" << t << endl;\n    if( s == t ) return false;\n\n    if( t - s == 1 ){ // alpha or T or F\n        if( str[s] == 'T' ) return true;\n        if( str[s] == 'F' ) return false;\n        return alpha[str[s] - 'a'];\n    }\n\n    // *,+,->\n    int x = 0;\n    //string tmp;\n    for(i=s; i<t; i++){\n        //tmp += str[i];\n        if( str[i] == '(' ) x++;\n        if( str[i] == ')' ) x--;\n        if( x == 0 && (str[i] == '*' || str[i] == '+' ||\n                       (i+1<t && str[i] == '-' && str[i+1] == '>')) ){\n            \n            break;\n        }\n    }\n    //cout << \"debug_tmp : \" << tmp << endl;\n\n    if( i < t ){ // \"*\" or \"+\" or \"->\"\n        if( str[i] == '*' ){\n            return AND(formula(str, s, i), formula(str, i+1, t));\n        }\n        else if( str[i] == '+' ){\n            return OR(formula(str, s, i), formula(str, i+1, t));\n        }\n        else{\n            return IMP(formula(str, s, i), formula(str, i+2, t));\n        }\n    }\n\n    // NOT\n    if( str[s] == '-' ){\n        //puts(\"NOT\");\n        return NOT(formula(str, s+1, t));\n    }\n\n    // 単純に括弧があるだけ\n    if( str[s] == '(' && str[t-1] == ')' ){\n        //cout << \"debug2 : \" << str << \" , \" << str.substr(1,str.length()-2) << endl;\n        return formula(str, s + 1, t - 1);\n    }\n    \n    exit(-1);\n}\n\n\nbool equation(const string& in){\n    int i,j;\n    int p = in.find(\"=\");\n\n    for(i=0; i<(1<<11); i++){\n        memset(alpha, false, sizeof(alpha));\n        for(j=0; j<11; j++){\n            if( i & (1<<j) ){\n                alpha[j] = true;\n            }\n        }\n        if( formula(in, 0, p) != formula(in, p + 1, in.length()) ){\n            return false;\n        }\n    }\n    return true;\n}\n\n\nint main(){\n    string in;\n\n    while( cin >> in, in != \"#\" ){\n        cout << (equation(in) ? \"YES\" : \"NO\") << endl;\n    }\n\n    return 0;\n}"
  },
  {
    "language": "C++",
    "code": "\n#include <iostream>\n#include <string>\n#include <string.h>\n\nusing namespace std;\n\nstring s;\nint i;\nbool f[256];\n\nbool imp(bool x, bool y){\n\tif ( x &&  y)return true;\n\tif ( x && !y)return false;\n\tif (!x &&  y)return true;\n\tif (!x && !y)return true;\n}\n\nbool form(){\n\t\n\tif (s[i] == 'T'){ i++; return true; }\n\tif (s[i] == 'F'){ i++; return false; }\n\n\tif (s[i] >= 'a' && s[i] <= 'k'){\n\t\tbool r = f[s[i]]; i++;return r;\n\t}else\n\tif (s[i] == '-'){\n\t\ti++; return !form();\n\t}else\n\tif (s[i] == '('){\n\t\ti++; bool c = form();\n\n\t\tif (s[i] == '*'){\n\t\t\ti++;  bool tc = form(); i++; return tc && c;\n\t\t}\n\t\tif (s[i] == '+'){\n\t\t\ti++;  bool tc = form(); i++; return tc || c;\n\t\t}\n\t\tif(s[i] == '-' && s[i+1] == '>')\n\t\t{\n\t\t\ti+=2; bool tc = form(); i++; return imp(c,tc);\n\t\t}\n\t}\n}\n\nbool equation(){\n\ti = 0;\n\tbool t = form();i++;\n\treturn t == form();\n}\n\nbool dfs(int n){\n\n\tif (n == 'k' + 1){\n\t\treturn equation();\n\t}\n\tf[n] = true;\n\tbool ret = dfs(n+1);\n\tf[n] = false;\n\treturn ret && dfs(n + 1);\n}\n\n\nint main()\n{\n\n\twhile (cin >> s && s != \"#\"){\n\t\tmemset(f,0,256*sizeof(bool));\n\t\ts += \" \";\n\t\tif (dfs('a'))\n\t\t\tcout << \"YES\" << endl;\n\t\telse\n\t\t\tcout << \"NO\" << endl;\n\t}\n\n\treturn 0;\n}"
  },
  {
    "language": "C++",
    "code": "//suhan lee,saitama university\n\n#include <vector>\n#include <list>\n#include <map>\n#include <set>\n#include <stack>\n#include <queue>\n#include <deque>\n#include <algorithm>\n#include <utility>\n#include <functional>\n#include <sstream>\n#include <iostream>\n#include <cstdio>\n#include <cmath>\n#include <cstdlib>\n#include <cctype>\n#include <cstring>\n#include <ctime>\n#include <climits>\n#include <cassert>\n#include <complex>\nusing namespace std;\n\ninline int toInt(string s) {int v; istringstream sin(s);sin>>v;return v;}\ntemplate<class T> inline string toString(T x) {ostringstream sout;sout<<x;return sout.str();}\ntypedef vector<int> vi;\ntypedef vector<vi> vvi;\ntypedef vector<string> vs;\ntypedef pair<int, int> pii;\ntypedef long long ll;\n\n#define ALL(a) (a).begin(),(a).end()\n#define RALL(a) (a).rbegin(),(a).rend()\n#define EXIST(s,e) ((s).find(e)!=(s).end())\n#define rep(i,a,b) for(int i=(a);i<(b);++i)\n#define repn(i,n) for(int i=0;i<n;i++)\n#define EACH(t,i,c) for(t::iterator i=(c).begin(); i!=(c).end(); ++i)\n#define pb push_back \n#define pf push_front\nint alphaset;\nbool equation(string inp,int& i);\nbool formula(string inp,int& i);\nbool alphabet(string inp,int& i);\nbool equation(string inp,int& i){\n  bool right,left;\n  left=formula(inp,i);\n  i++;\n  // cout<<\"i:\"<<i<<endl;\n  right=formula(inp,i);\n  //  cout<<alphaset<<endl<<left<<'='<<right<<endl;\n  return right==left;\n}\nbool formula(string inp,int& i){\n  bool left=alphabet(inp,i);\n  bool right;\n  while(true){\n    if(inp[i]=='+'){\n      right=formula(inp,++i);\n      left=right||left;\n    }\n    else    if(inp[i]=='*'){\n      right=formula(inp,++i);\n      left=right&&left;\n    }\n    else    if(inp[i]=='-'){\n      if(inp[++i]=='>'){\n\tright=formula(inp,++i);\n\tleft=(!left)||right;\n      }\n    }\n    else return left;\n  }\n}\nbool alphabet(string inp,int& i){\n  if(inp[i]=='(')\n    {\n      int out=formula(inp,++i);\n      i++;return out;\n    }\n  else if(inp[i]=='-')\n    return !alphabet(inp,++i);\n  else if(inp[i]=='T'){i++;\n    return true;}\n  else if(inp[i]=='f'){i++;\n    return false;}\n\n  else{\n    //   cout<<inp[i]<<i<<\"  \"<<alphaset<<\"  \"<<\n    //    (alphaset & (1<<(inp[i]-'a'))>0)<<endl;\n    return alphaset & (1<<(inp[i++]-'a'));\n  }\n\n}\n\n\nint main(){\n  while(true){\n    string inp;\n    int i=0;\n    //  cout<<int('a')<<endl<<int('b');\n    cin>>inp;\n    if(inp==\"#\") break;\n    for(alphaset=0;alphaset<(1<<11);alphaset++){\n      i=0;\n      if(equation(inp,i)==false){\n\tcout<<\"NO\"<<endl;\n\tbreak;\n      }\n    }\n    if(alphaset==(1<<11)){\n      cout<<\"YES\"<<endl;\n    }\n  }\n  return 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include<bits/stdc++.h>\nusing namespace std;\n\nint cnt = 0;\nchar S[1024];\nbool at[12];\n\nbool count(char c){\n  if( S[cnt] == c ) cnt++;\n  else return false;\n  return true;\n}\n\nbool get(char c){\n  return at[c-'a'];\n}\n\nbool calc( bool a, bool b, char c ){\n  if( c == '*' ) return a&b;\n  if( c == '+' ) return a|b;\n  return 1-(a&(1-b));\n}\n\nbool formula(){\n  if( count('-') ){\n    return 1-formula();\n  } else if( count('T') ){\n    return true;\n  } else if( count('F') ){\n    return false;\n  } else if( count('(') ){\n    bool a = formula();\n    char c;\n    if( count( '*' ) ) c = '*';\n    else if( count('+') ) c = '+';\n    else if( count('-') && count('>') ) c='>';\n    else assert(false);\n    bool b = formula();\n    bool r = calc( a, b, c );\n    count( ')' );\n    return r;\n  } else {\n    char c = S[cnt];\n    assert( 'a' <= c && c <= 'k' );\n    count(c);\n    return get(c);\n  }  \n}\n\nbool equation(){\n  cnt=0;\n  bool a = formula();\n  count( '=' );\n  bool b = formula();\n  return a==b;\n}\n\nint main(){\n  while( cin >> S ){\n    if( S[0] == '#' ) break;\n    bool ret = true;\n    for(int i=0;i<(1<<11);i++){\n      for(int j=0;j<11;j++) at[j] = i&(1<<j);\n      if( !equation() ){ ret = false; break;}\n    }\n    if( ret ) cout << \"YES\" << endl;\n    else cout << \"NO\" << endl;\n  }\n}"
  },
  {
    "language": "C++",
    "code": "#include <functional>\n#include <iostream>\n#include <string>\n#include <unordered_set>\n#include <vector>\n#define loop(i, a, n) for (int i = (a); i < (n); i++)\n#define rep(i, n) loop(i, 0, n)\ntemplate<typename A> using F = std::function<A>;\nusing namespace std;\n\ntemplate<typename T> struct ParseResult {\n  bool succeeded;\n  T object;\n  int pos;\n  ParseResult(const bool succeeded, T object, const int pos) : succeeded(succeeded), object(std::move(object)), pos(pos) {}\n  friend std::ostream &operator<<(std::ostream &os, const ParseResult<T> &p) { return os << '{' << (p.succeeded ? \"true\" : \"false\") << ',' << p.object << ',' << p.pos << '}'; }\n};\n\ntemplate<typename T> using Parser = std::function<ParseResult<T>(const std::string&, int)>;\n\nParser<std::string> token(std::string &&s) {\n  const auto n = s.size();\n  return[n = std::move(n), s = std::move(s)](const std::string &target, const int pos) {\n    if (target.size() < n) return ParseResult<std::string>(false, {}, pos);\n    return target.substr(pos, n) == s ? ParseResult<std::string>(true, s, pos + n) : ParseResult<std::string>(false, {}, pos);\n  };\n}\n\ntemplate<typename T> Parser<T> operator||(Parser<T> p1, Parser<T> p2) {\n  return[p1 = std::move(p1), p2 = std::move(p2)](const std::string &target, const int pos) {\n    auto r = p1(target, pos);\n    if (r.succeeded) return r;\n    r = p2(target, pos);\n    if (r.succeeded) return r;\n    return ParseResult<T>(false, {}, pos);\n  };\n}\n\ntemplate<typename T1, typename T2> Parser<std::pair<T1, T2>> operator+(Parser<T1> p1, Parser<T2> p2) {\n  return[p1 = std::move(p1), p2 = std::move(p2)](const std::string &target, const int pos) {\n    auto r1 = p1(target, pos);\n    if (!r1.succeeded) return ParseResult<std::pair<T1, T2>>(false, {}, pos);\n    auto r2 = p2(target, r1.pos);\n    if (!r2.succeeded) return ParseResult<std::pair<T1, T2>>(false, {}, pos);\n    return ParseResult<std::pair<T1, T2>>(true, { r1.object, r2.object }, r2.pos);\n  };\n}\n\ntemplate<typename T1, typename T2> Parser<T2> operator>>(Parser<T1> p1, Parser<T2> p2) {\n  return[p1 = std::move(p1), p2 = std::move(p2)](const std::string &target, const int pos) {\n    auto r1 = p1(target, pos);\n    if (!r1.succeeded) return ParseResult<T2>(false, {}, pos);\n    auto r2 = p2(target, r1.pos);\n    if (!r2.succeeded) return ParseResult<T2>(false, {}, pos);\n    return ParseResult<T2>(true, r2.object, r2.pos);\n  };\n}\n\ntemplate<typename T1, typename T2> Parser<T1> operator<<(Parser<T1> p1, Parser<T2> p2) {\n  return[p1 = std::move(p1), p2 = std::move(p2)](const std::string &target, const int pos) {\n    auto r1 = p1(target, pos);\n    if (!r1.succeeded) return ParseResult<T1>(false, {}, pos);\n    auto r2 = p2(target, r1.pos);\n    if (!r2.succeeded) return ParseResult<T1>(false, {}, pos);\n    return ParseResult<T1>(true, r1.object, r2.pos);\n  };\n}\n\nParser<char> oneOf(const std::string &s) {\n  std::unordered_set<char> d;\n  for (auto &c : s) d.insert(c);\n  return[d = std::move(d)](const std::string &target, const int pos) {\n    if (target.size() <= pos) return ParseResult<char>(false, {}, pos);\n    char c = target[pos];\n    return d.count(c) ? ParseResult<char>(true, c, pos + 1) : ParseResult<char>(false, {}, pos);\n  };\n}\n\ntemplate<typename T, typename S, typename F> Parser<S> fmap(Parser<T> p, F &&f) {\n  return[p = std::move(p), f = std::forward<F>(f)](const std::string &target, const int pos) {\n    auto r = p(target, pos);\n    return r.succeeded ? ParseResult<S>(true, f(r.object), r.pos) : ParseResult<S>(false, {}, r.pos);\n  };\n}\n\ntemplate<typename T, typename F> Parser<T> lazy(F &&f) {\n  static bool instantiated = false;\n  static Parser<T> p;\n  return[f = std::forward<F>(f)](const std::string &target, const int pos) {\n    if (!instantiated) {\n      p = f();\n      instantiated = true;\n    }\n    return p(target, pos);\n  };\n}\n\nstruct SyntaxTree {\n  string op;\n  char value;\n  vector<SyntaxTree> children;\n  SyntaxTree() {}\n  SyntaxTree(const string &op, const char value, const vector<SyntaxTree> &children) : op(op), value(value), children(children) {}\n};\n\nint main() {\n  Parser<SyntaxTree> formulaP = lazy<SyntaxTree>([&]() {\n    auto andP = fmap<pair<SyntaxTree, SyntaxTree>, SyntaxTree>((token(\"(\") >> formulaP << token(\"*\")) + (formulaP << token(\")\")), [](auto &o) { return SyntaxTree(\"*\", {}, { o.first, o.second }); });\n    auto orP = fmap<pair<SyntaxTree, SyntaxTree>, SyntaxTree>((token(\"(\") >> formulaP << token(\"+\")) + (formulaP << token(\")\")), [](auto &o) { return SyntaxTree(\"+\", {}, { o.first, o.second }); });\n    auto impP = fmap<pair<SyntaxTree, SyntaxTree>, SyntaxTree>((token(\"(\") >> formulaP << token(\"->\")) + (formulaP << token(\")\")), [](auto &o) { return SyntaxTree(\"->\", {}, { o.first, o.second }); });\n    auto notP = fmap<SyntaxTree, SyntaxTree>(token(\"-\") >> formulaP, [](auto &o) { return SyntaxTree(\"-\", {}, { o }); });\n    auto valP = fmap<char, SyntaxTree>(oneOf(\"abcdefghijkTF\"), [](char x) { return SyntaxTree({}, x, {}); });\n    return andP || orP || impP || notP || valP;\n  });\n  auto equationP = (formulaP << token(\"=\")) + formulaP;\n  string s;\n  while (cin >> s, s != \"#\") {\n    auto r = equationP(s, 0);\n    bool isValid = true;\n    rep(i, 1 << 11) {\n      auto toBool = [&](char c) -> bool {\n        if (c == 'T') return true;\n        if (c == 'F') return false;\n        return i >> (c - 'a') & 1;\n      };\n      F<bool(const SyntaxTree&)> evalF = [&](const SyntaxTree &f) {\n        switch (f.children.size()) {\n        case 0: return toBool(f.value);\n        case 1: return !evalF(f.children[0]);\n        case 2:\n          if (f.op == \"*\") return evalF(f.children[0]) && evalF(f.children[1]);\n          if (f.op == \"+\") return evalF(f.children[0]) || evalF(f.children[1]);\n          if (f.op == \"->\") return !evalF(f.children[0]) || evalF(f.children[1]);\n        }\n      };\n      isValid &= evalF(r.object.first) == evalF(r.object.second);\n    }\n    cout << (isValid ? \"YES\" : \"NO\") << endl;\n  }\n}"
  },
  {
    "language": "C++",
    "code": "#include<bits/stdc++.h>\nusing namespace std;\n\nstring s,f[2];\n\nbool parse(int id, int l, int r){\n  int k = 0;\n  for(int i=r-1;i>=l;i--){\n    if(f[id][i] == '(')k++;\n    if(f[id][i] == ')')k--;\n\n    if(k==0){\n      char op = f[id][i];\n      if(op == '*')return parse(id,l,i) & parse(id,i+1,r);\n      if(op == '+')return parse(id,l,i) | parse(id,i+1,r);\n      if(op == '>')return !parse(id,l,i-1) | parse(id,i+1,r);\n    }\n  }\n\n  if(f[id][l] == '(' && f[id][r-1] == ')')return parse(id,l+1,r-1);\n  if(f[id][l] == '-')return !parse(id,l+1,r);\n  return f[id][l] == 'T';\n}\n\nint main(){\n  while(cin >> s, s!=\"#\"){\n    string t[2];\n    for(int i=0;i<s.size();i++){\n      if(s[i] == '='){\n\tt[0] = s.substr(0,i);\n\tt[1] = s.substr(i+1);\n\tbreak;\n      }\n    }\n\n    bool flag = true;\n    for(int i=0;i<(1<<11);i++){\n      //replace\n      for(int j=0;j<2;j++){\n\tf[j] = t[j];\n\tfor(int k=0;k<f[j].size();k++){\n\t  if(islower(f[j][k])){\n\t    int bit = f[j][k] - 'a';\n\t    if((i>>bit) & 1)f[j][k] = 'T';\n\t    else f[j][k] = 'F';\n\t  }\n\t}\n      }\n      flag &= ( parse(0,0,f[0].size()) == parse(1,0,f[1].size()) );\n      if(!flag)break;\n    }\n\n    if(flag)cout << \"YES\\n\";\n    else cout << \"NO\\n\";\n  }\n}"
  },
  {
    "language": "C++",
    "code": "#include<iostream>\n#include<string>\n#define MAX 11\nusing namespace std;\nbool o;\nvoid rec(string s){\n  if(!o) return;\n  //cout << s << endl;\n  bool f;\n  int p;\n  while(s.find(\"-0\")!=-1){\n    p=s.find(\"-0\");\n    s[p]='1';s[p+1]=' ';\n    f=true;\n  }\n  while(s.find(\"-1\")!=-1){\n    p=s.find(\"-1\");\n    s[p]='0';s[p+1]=' ';\n    f=true;\n  }\n  while(s.find(\"(0*0)\")!=-1){\n    p=s.find(\"(0*0)\");\n    s[p]='0';s[p+1]=' ';s[p+2]=' ';s[p+3]=' ';s[p+4]=' ';\n    f=true;\n  }\n  while(s.find(\"(0*1)\")!=-1){\n    p=s.find(\"(0*1)\");\n    s[p]='0';s[p+1]=' ';s[p+2]=' ';s[p+3]=' ';s[p+4]=' ';\n    f=true;\n  }\n  while(s.find(\"(1*0)\")!=-1){\n    p=s.find(\"(1*0)\");\n    s[p]='0';s[p+1]=' ';s[p+2]=' ';s[p+3]=' ';s[p+4]=' ';\n    f=true;\n  }\n  while(s.find(\"(1*1)\")!=-1){\n    p=s.find(\"(1*1)\");\n    s[p]='1';s[p+1]=' ';s[p+2]=' ';s[p+3]=' ';s[p+4]=' ';\n    f=true;\n  }\n  while(s.find(\"(0+0)\")!=-1){\n    p=s.find(\"(0+0)\");\n    s[p]='0';s[p+1]=' ';s[p+2]=' ';s[p+3]=' ';s[p+4]=' ';\n    f=true;\n  }\n  while(s.find(\"(0+1)\")!=-1){\n    p=s.find(\"(0+1)\");\n    s[p]='1';s[p+1]=' ';s[p+2]=' ';s[p+3]=' ';s[p+4]=' ';\n    f=true;\n  }\n  while(s.find(\"(1+0)\")!=-1){\n    p=s.find(\"(1+0)\");\n    s[p]='1';s[p+1]=' ';s[p+2]=' ';s[p+3]=' ';s[p+4]=' ';\n    f=true;\n  }\n  while(s.find(\"(1+1)\")!=-1){\n    p=s.find(\"(1+1)\");\n    s[p]='1';s[p+1]=' ';s[p+2]=' ';s[p+3]=' ';s[p+4]=' ';\n    f=true;\n  }\n  while(s.find(\"(0->0)\")!=-1){\n    p=s.find(\"(0->0)\");\n    s[p]='1';s[p+1]=' ';s[p+2]=' ';s[p+3]=' ';s[p+4]=' ';s[p+5]=' ';\n    f=true;\n  }\n  while(s.find(\"(0->1)\")!=-1){\n    p=s.find(\"(0->1)\");\n    s[p]='1';s[p+1]=' ';s[p+2]=' ';s[p+3]=' ';s[p+4]=' ';s[p+5]=' ';\n    f=true;\n  }\n  while(s.find(\"(1->0)\")!=-1){\n    p=s.find(\"(1->0)\");\n    s[p]='0';s[p+1]=' ';s[p+2]=' ';s[p+3]=' ';s[p+4]=' ';s[p+5]=' ';\n    f=true;\n  }\n  while(s.find(\"(1->1)\")!=-1){\n    p=s.find(\"(1->1)\");\n    s[p]='1';s[p+1]=' ';s[p+2]=' ';s[p+3]=' ';s[p+4]=' ';s[p+5]=' ';\n    f=true;\n  }\n  if(f){\n    string b;\n    for(int i=0;i<s.size();i++) if(s[i]!=' ') b+=s[i];\n    //rec(b);\n  }else{\n    if(s[0]!=s[2]) o=false;\n    return;\n  }\n}\nvoid init(int n,string s){\n  int i,j;\n  for(i=0;i<s.size();i++){\n    for(j=0;j<=MAX;j++){\n      if(s[i]=='a'+j) s[i]='0'+(n>>j&1);\n      if(s[i]=='T') s[i]='1';\n      if(s[i]=='F') s[i]='0';\n    }\n  }\n  rec(s);\n}\nint main(){\n  string s;\n  while(cin >> s,s!=\"#\"){\n    o=true;\n    int i;\n    for(i=0;i<(1<<MAX);i++)\n      init(i,s);\n    cout << (o?\"YES\":\"NO\") << endl;\n  }\n  return 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\nusing namespace std;\n\ntypedef ostringstream OSS;\ntypedef istringstream ISS;\n\ntypedef long long LL;\ntypedef pair<int, int> PII;\n\ntypedef vector<int> VI;\ntypedef vector<VI> VVI;\ntypedef vector<LL> VLL;\ntypedef vector<VLL> VVLL;\ntypedef vector<string> VS;\ntypedef vector<VS> VVS;\ntypedef vector<bool> VB;\ntypedef vector<VB> VVB;\ntypedef vector<PII> VPII;\n\n#define POS first\n#define VALUE second\n#define MP make_pair\n#define PB push_back\n#define EB emplace_back \n#define ALL(x) (x).begin(),(x).end()\n#define RANGE(x,y,maxX,maxY) (0 <= (x) && 0 <= (y) && (x) < (maxX) && (y) < (maxY))\n#define DUMP( x ) cerr << #x << \" = \" << ( x ) << endl\n\ntemplate < typename T > inline T fromString(const string &s) { T res; ISS iss(s); iss >> res; return res; };\ntemplate < typename T > inline string toString(const T &a) { OSS oss; oss << a; return oss.str(); };\n\nconst int INF = 0x3f3f3f3f;\nconst LL INFL = 0x3f3f3f3f3f3f3f3fLL;\nconst int DX[]={1,0,-1,0},DY[]={0,-1,0,1};\n\nPII formula(string &str, int pos);\n\nstring get_alpha(string str) {\n    set<char> s;\n\n    for (auto a : str) {\n        if (isalpha(a) && islower(a)) {\n            s.insert(a);\n        }\n    }\n\n    string as;\n    for (auto a : s) {\n        as += a;\n    }\n\n    return as;\n}\n\nPII ope(string &str, int pos) {\n    PII l = formula(str, pos);\n\n    PII r;\n    int value;\n    switch (str[l.POS]) {\n        case '+':\n            r = formula(str, l.POS + 1);\n            value = min(1, l.VALUE + r.VALUE);\n            break;\n\n        case '*':\n            r = formula(str, l.POS + 1);\n            value = l.VALUE * r.VALUE;\n            break;\n\n        case '-': // ->\n            r = formula(str, l.POS + 2);\n            value = min(1, (l.VALUE ? 0 : 1) + r.VALUE);\n            break;\n\n        default:\n            cerr << \"ERROR2!!!!!!!!!: \" << pos << endl;\n            exit(1);\n    }\n\n    return MP(r.POS, value);\n}\n\nPII formula(string &str, int pos) {\n    PII res;\n\n    switch (str[pos]) {\n        case '1':\n            return MP(pos + 1, 1);\n\n        case '0':\n            return MP(pos + 1, 0);\n\n        case '-': // minus(not)\n            res = formula(str, pos + 1);\n            return MP(res.POS, res.VALUE ? 0 : 1);\n\n        case '(':\n            res = ope(str, pos + 1);\n            ++res.POS;\n            return res;\n\n        default:\n            cerr << \"ERROR1!!!!!!!!!: \" << pos << \" \" << str[pos] << endl;\n            exit(1);\n    }\n}\n\nbool solve(string str) {\n    // T, F -> 1, 0\n    replace(ALL(str), 'T', '1');\n    replace(ALL(str), 'F', '0');\n\n    string as = get_alpha(str);\n    int n = as.size();\n\n    auto eq_pos = str.find('=');\n\n    // alpha -> 0 or 1\n    for (int p = 0; p < 1 << n; p++) {\n        string str2 = str;\n        for (int i = 0; i < n; i++) {\n            replace(ALL(str2), as[i], (char)('0' + (i >> p & 1)));\n        }\n\n        string left_str = str2.substr(0, eq_pos);\n        string right_str = str2.substr(eq_pos + 1, str2.size());\n        PII left = formula(left_str, 0);\n        PII right = formula(right_str, 0);\n\n        if (left.VALUE != right.VALUE) {\n            return false;\n        }\n    }\n\n    return true;\n}\n\nint main(void) {\n    string str;\n\n    while (cin >> str, str != \"#\") {\n        cout << (solve(str) ? \"YES\" : \"NO\") << endl;;\n    }\n\n\treturn 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include <stdio.h>\n#include <cmath>\n#include <algorithm>\n#include <cfloat>\n#include <stack>\n#include <queue>\n#include <vector>\ntypedef long long int ll;\ntypedef unsigned long long int ull;\n#define BIG_NUM 2000000000\n#define MOD 1000000007\n#define EPS 0.000000001\nusing namespace std;\n\nchar buf[1010],left_line[1010],right_line[1010],tmp_left[1010],tmp_right[1010];\nint loc[128];\nint POW[16] = {1,2,4,8,16,32,64,128,256,512,1024,2048,4096,8192,16384,32768};\nchar table[11];\n\nint keisan(int left,int right,char op){\n\tswitch(op){\n\tcase '-':\n\t\treturn 1 - left;\n\tcase '*':\n\t\treturn left*right;\n\tcase '+':\n\t\treturn max(left,right);\n\tcase ':':\n\t\tif(left == right)return 1;\n\t\telse{\n\t\t\treturn right;\n\t\t}\n\t\tbreak;\n\t}\n\treturn -1; //must not reach here\n}\n\nint calc_line(char line[1010]){\n\n\tint tmp,op1,work,count,work2,value;\n\tchar calc;\n\tstack<int> NUM,work_num;\n\tstack<char> OP,work_op;\n\n\tbool numFLG;\n\n\ttmp = 0;\n\tnumFLG = false;\n\n\tfor(int k = 0; line[k] != '\\0'; k++){\n\t\tif(line[k] >= '0' && line[k] <= '9'){\n\t\t\tnumFLG = true;\n\t\t\ttmp = 10*tmp + (line[k] - '0');\n\n\t\t}else{\n\n\t\t\tif(numFLG == true){\n\n\t\t\t\tif(OP.empty() == false && OP.top() != '('){\n\t\t\t\t\tif(OP.top() == '-'){\n\t\t\t\t\t\tOP.pop();\n\t\t\t\t\t\ttmp = 1 - tmp;\n\t\t\t\t\t\tNUM.push(tmp);\n\t\t\t\t\t}else{\n\t\t\t\t\t\tcalc = OP.top();\n\t\t\t\t\t\tOP.pop();\n\t\t\t\t\t\top1 = NUM.top();\n\t\t\t\t\t\tNUM.pop();\n\n\t\t\t\t\t\tif(calc == '*'){\n\t\t\t\t\t\t\tvalue = keisan(op1,tmp,'*');\n\t\t\t\t\t\t\tNUM.push(value);\n\t\t\t\t\t\t}else if(calc == '+'){\n\t\t\t\t\t\t\tvalue = keisan(op1,tmp,'+');\n\t\t\t\t\t\t\tNUM.push(value);\n\t\t\t\t\t\t}else{ //calc == ':'\n\t\t\t\t\t\t\tvalue = keisan(op1,tmp,':');\n\t\t\t\t\t\t\tNUM.push(value);\n\t\t\t\t\t\t}\n\t\t\t\t\t}\n\t\t\t\t}else{\n\t\t\t\t\tNUM.push(tmp);\n\t\t\t\t}\n\n\t\t\t\tnumFLG = false;\n\t\t\t\ttmp = 0;\n\t\t\t}\n\n\t\t\tif(line[k] == '+' ||line[k] == '*' || line[k] == ':' || line[k] == '-'){\n\t\t\t\tOP.push(line[k]);\n\t\t\t}else if(line[k] == '('){\n\t\t\t\tif(k > 0 && line[k-1] == '('){\n\t\t\t\t\tNUM.push(1);\n\t\t\t\t\tOP.push('*');\n\t\t\t\t\tOP.push('(');\n\t\t\t\t}else{\n\t\t\t\t\tOP.push('(');\n\t\t\t\t}\n\t\t\t}else if(line[k] == ')'){\n\n\t\t\t\twork = NUM.top();\n\t\t\t\tNUM.pop();\n\t\t\t\twork_num.push(work);\n\n\t\t\t\tcount = 0;\n\n\t\t\t\twhile(true){\n\t\t\t\t\tcalc = OP.top();\n\t\t\t\t\tOP.pop();\n\t\t\t\t\tif(calc == '(')break;\n\n\t\t\t\t\tcount++;\n\n\t\t\t\t\twork_op.push(calc);\n\n\t\t\t\t\twork = NUM.top();\n\t\t\t\t\tNUM.pop();\n\t\t\t\t\twork_num.push(work);\n\t\t\t\t}\n\n\t\t\t\tif(count == 0){\n\t\t\t\t\twork = work_num.top();\n\t\t\t\t\twork_num.pop();\n\t\t\t\t}else{\n\n\t\t\t\t\twork = work_num.top();\n\t\t\t\t\twork_num.pop();\n\n\t\t\t\t\twhile(!work_num.empty()){\n\t\t\t\t\t\tcalc = work_op.top();\n\t\t\t\t\t\twork_op.pop();\n\n\t\t\t\t\t\tif(calc == '+'){\n\t\t\t\t\t\t\twork = keisan(work,work_num.top(),'+');\n\t\t\t\t\t\t}else if(calc == '-'){\n\t\t\t\t\t\t\t//work = calc(work_num.top();\n\t\t\t\t\t\t}else if(calc == '*'){\n\t\t\t\t\t\t\twork = keisan(work,work_num.top(),'*');\n\t\t\t\t\t\t}else if(calc == ':'){\n\t\t\t\t\t\t\twork = keisan(work,work_num.top(),':');\n\t\t\t\t\t\t}\n\n\t\t\t\t\t\twork_num.pop();\n\t\t\t\t\t}\n\t\t\t\t}\n\n\t\t\t\twhile(OP.empty() == false && OP.top() != '('){\n\t\t\t\t\tcalc = OP.top();\n\t\t\t\t\tOP.pop();\n\n\t\t\t\t\tswitch(calc){\n\t\t\t\t\tcase '+':\n\t\t\t\t\t\twork2 = NUM.top();\n\t\t\t\t\t\tNUM.pop();\n\t\t\t\t\t\twork = keisan(work2,work,'+');\n\t\t\t\t\t\tbreak;\n\t\t\t\t\tcase '-':\n\t\t\t\t\t\twork = keisan(work,0,'-');\n\t\t\t\t\t\tbreak;\n\t\t\t\t\tcase '*':\n\t\t\t\t\t\twork2 = NUM.top();\n\t\t\t\t\t\tNUM.pop();\n\t\t\t\t\t\twork = keisan(work2,work,'*');\n\t\t\t\t\t\tbreak;\n\t\t\t\t\tcase ':':\n\t\t\t\t\t\twork2 = NUM.top();\n\t\t\t\t\t\tNUM.pop();\n\t\t\t\t\t\twork = keisan(work2,work,':');\n\t\t\t\t\tbreak;\n\t\t\t\t\t}\n\t\t\t\t}\n\n\t\t\t\tNUM.push(work);\n\n\t\t\t}else{\t//line[k] == '='\n\n\t\t\t\twork = NUM.top();\n\t\t\t\tNUM.pop();\n\t\t\t\twork_num.push(work);\n\n\t\t\t\twhile(!NUM.empty()){\n\t\t\t\t\tcalc = OP.top();\n\t\t\t\t\tOP.pop();\n\n\t\t\t\t\twork_op.push(calc);\n\n\t\t\t\t\twork = NUM.top();\n\t\t\t\t\tNUM.pop();\n\t\t\t\t\twork_num.push(work);\n\t\t\t\t}\n\n\t\t\t\twork = work_num.top();\n\t\t\t\twork_num.pop();\n\n\t\t\t\twhile(!work_num.empty()){\n\t\t\t\t\tcalc = work_op.top();\n\t\t\t\t\twork_op.pop();\n\n\t\t\t\t\tif(calc == '+'){\n\t\t\t\t\t\twork = keisan(work,work_num.top(),'+');\n\t\t\t\t\t}else if(calc == '-'){\n\t\t\t\t\t\t//work -= work_num.top();\n\t\t\t\t\t}else if(calc == '*'){\n\t\t\t\t\t\twork = keisan(work,work_num.top(),'*');\n\t\t\t\t\t}else if(calc == ':'){\n\t\t\t\t\t\twork = keisan(work,work_num.top(),':');\n\t\t\t\t\t}\n\n\t\t\t\t\twork_num.pop();\n\t\t\t\t}\n\n\t\t\t\treturn work;\n\t\t\t}\n\t\t}\n\t}\n\treturn -1;\n}\n\nvoid func(){\n\n\tfor(int i = 0; i < 128; i++)loc[i] = -1;\n\n\tint left_index = 0,right_index,loc_index = 0,index;\n\n\tint tmp;\n\n\tfor(int i = 0; buf[i] != '=';){\n\t\tif(buf[i] >= 'a' && buf[i] <= 'k'){\n\t\t\tif(loc[buf[i]] == -1){\n\t\t\t\tloc[buf[i]] = loc_index++;\n\t\t\t}\n\t\t\tleft_line[left_index++] = buf[i];\n\t\t\ti++;\n\t\t}else if(buf[i] == '*' || buf[i] == '+' || buf[i] == '(' || buf[i] == ')'){\n\t\t\tleft_line[left_index++] = buf[i];\n\t\t\ti++;\n\t\t}else if(buf[i] == '-'){\n\t\t\tif(buf[i+1] == '>'){\n\t\t\t\tleft_line[left_index++] = ':';\n\t\t\t\ti += 2;\n\t\t\t}else{\n\n\t\t\t\tfor(tmp = 0; buf[i+tmp] == '-';tmp++);\n\n\t\t\t\tif(tmp%2 == 0){\n\t\t\t\t\ti += tmp;\n\t\t\t\t}else{\n\t\t\t\t\tleft_line[left_index++] = '-';\n\t\t\t\t\ti += tmp;\n\t\t\t\t}\n\t\t\t}\n\t\t}else if(buf[i] == 'T'){\n\t\t\tleft_line[left_index++] = '1';\n\t\t\ti++;\n\t\t}else if(buf[i] == 'F'){\n\t\t\tleft_line[left_index++] = '0';\n\t\t\ti++;\n\t\t}\n\t\tindex = i;\n\t}\n\tleft_line[left_index] = '=';\n\tleft_line[left_index+1] = '\\0';\n\n\n\n\tright_index = 0;\n\n\tfor(int i = index+1; buf[i] != '\\0';){\n\n\t\tif(buf[i] >= 'a' && buf[i] <= 'k'){\n\t\t\tif(loc[buf[i]] == -1){\n\t\t\t\tloc[buf[i]] = loc_index++;\n\t\t\t}\n\t\t\tright_line[right_index++] = buf[i];\n\t\t\ti++;\n\t\t}else if(buf[i] == '*' || buf[i] == '+' || buf[i] == '(' || buf[i] == ')'){\n\t\t\tright_line[right_index++] = buf[i];\n\t\t\ti++;\n\t\t}else if(buf[i] == '-'){\n\t\t\tif(buf[i+1] == '>'){\n\t\t\t\tright_line[right_index++] = ':';\n\t\t\t\ti += 2;\n\t\t\t}else{\n\t\t\t\tfor(tmp = 0; buf[i+tmp] == '-';tmp++);\n\n\t\t\t\tif(tmp%2 == 0){\n\t\t\t\t\ti += tmp;\n\t\t\t\t}else{\n\t\t\t\t\tright_line[right_index++] = '-';\n\t\t\t\t\ti += tmp;\n\t\t\t\t}\n\t\t\t}\n\t\t}else if(buf[i] == 'T'){\n\t\t\tright_line[right_index++] = '1';\n\t\t\ti++;\n\t\t}else if(buf[i] == 'F'){\n\t\t\tright_line[right_index++] = '0';\n\t\t\ti++;\n\t\t}\n\t}\n\tright_line[right_index] = '=';\n\tright_line[right_index+1] = '\\0';\n\n\n\tint limit = POW[loc_index];\n\n\tbool FLG = true;\n\n\tfor(int i = 0; i < limit; i++){\n\t\tfor(int k = 0; k < loc_index;k++){\n\t\t\tif(i & (1 << k)){\n\t\t\t\ttable[k] = '1';\n\t\t\t}else{\n\t\t\t\ttable[k] = '0';\n\t\t\t}\n\t\t}\n\n\n\t\tleft_index = 0;\n\t\tfor(index = 0; left_line[index] != '\\0';){\n\t\t\tif(left_line[index] >= 'a' && left_line[index] <= 'k'){\n\t\t\t\ttmp_left[left_index++] = table[loc[left_line[index]]];\n\t\t\t\tindex++;\n\t\t\t}else if(left_line[index] == '-'){\n\t\t\t\tif(left_line[index+1] == '('){\n\t\t\t\t\ttmp_left[left_index++] = '-';\n\t\t\t\t\tindex++;\n\t\t\t\t}else{\n\t\t\t\t\tif(left_line[index+1] >= 'a' && left_line[index+1] <= 'k'){\n\t\t\t\t\t\ttmp_left[left_index++] = '0'  + (1 - (table[loc[left_line[index+1]]] - '0'));\n\t\t\t\t\t}else{\n\t\t\t\t\t\ttmp_left[left_index++] = '0'  + (1 - (left_line[index+1] - '0'));\n\t\t\t\t\t}\n\t\t\t\t\tindex += 2;\n\t\t\t\t}\n\t\t\t}else{\n\t\t\t\ttmp_left[left_index++] = left_line[index];\n\t\t\t\tindex++;\n\t\t\t}\n\t\t}\n\t\ttmp_left[index] = '\\0';\n\n\t\tright_index = 0;\n\t\tfor(index = 0; right_line[index] != '\\0';){\n\t\t\tif(right_line[index] >= 'a' && right_line[index] <= 'k'){\n\t\t\t\ttmp_right[right_index++] = table[loc[right_line[index]]];\n\t\t\t\tindex++;\n\t\t\t}else if(right_line[index] == '-'){\n\t\t\t\tif(right_line[index+1] == '('){\n\t\t\t\t\ttmp_right[right_index++] = '-';\n\t\t\t\t\tindex++;\n\t\t\t\t}else{\n\t\t\t\t\tif(right_line[index+1] >= 'a' && right_line[index+1] <= 'k'){\n\t\t\t\t\t\ttmp_right[right_index++] = '0'  + (1 - (table[loc[right_line[index+1]]] - '0'));\n\t\t\t\t\t}else{\n\t\t\t\t\t\ttmp_right[right_index++] = '0'  + (1 - (right_line[index+1] - '0'));\n\t\t\t\t\t}\n\t\t\t\t\tindex += 2;\n\t\t\t\t}\n\t\t\t}else{\n\t\t\t\ttmp_right[right_index++] = right_line[index];\n\t\t\t\tindex++;\n\t\t\t}\n\t\t}\n\t\ttmp_right[index] = '\\0';\n\n\t\tif(calc_line(tmp_left) != calc_line(tmp_right)){\n\t\t\tFLG = false;\n\t\t\tbreak;\n\t\t}\n\n\t}\n\n\tif(FLG){\n\t\tprintf(\"YES\\n\");\n\t}else{\n\t\tprintf(\"NO\\n\");\n\t}\n\n}\n\nint main(){\n\n\twhile(true){\n\t\tscanf(\"%s\",buf);\n\t\tif(buf[0] == '#')break;\n\n\t\tfunc();\n\t}\n\n\treturn 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include<bits/stdc++.h>\n#define rep(i,n)for(int i=0;i<(n);i++)\nusing namespace std;\n\nint equ(string&, int&);\nint form(string&, int&);\nint q(string&, int&);\nint num(string&, int&);\n\nint equ(string&s, int&i) {\n\tint v1 = form(s, i); i++;\n\tint v2 = form(s, i);\n\treturn v1 == v2;\n}\nint form(string&s, int&i) {\n\tint mprvc = i;\n\tint v = q(s, i);\n\twhile ((s[i] == '-'&&s[i + 1] == '>') || s[i] == '*' || s[i] == '+') {\n\t\tint prv = i;\n\t\tchar op = s[i++];\n\t\tif (s[i] == '>')op = s[i++];\n\t\tint v2 = q(s, i);\n\t\tif (op == '>') {\n\t\t\tif (!v || v2)v = 1;\n\t\t\telse v = 0;\n\t\t}\n\t\tif (op == '*') {\n\t\t\tif (v&&v2)v = 1;\n\t\t\telse v = 0;\n\t\t}\n\t\tif (op == '+') {\n\t\t\tif (v || v2)v = 1;\n\t\t\telse v = 0;\n\t\t}\n\t}\n\treturn v;\n}\nint q(string&s, int&i) {\n\tif (s[i] == 'T' || s[i] == 'F')return s[i++] == 'T';\n\tif (s[i] == '-') {\n\t\ti++;\n\t\tif (s[i] == 'T' || s[i] == 'F')return s[i++] == 'F';\n\t\treturn !form(s, i);\n\t}\n\ti++; int ret = form(s, i); i++;\n\treturn ret;\n}\nint main() {\n\tstring s;\n\twhile (cin >> s, s != \"#\") {\n\t\tmap<char, int>mp;\n\t\tfor (char c : s) {\n\t\t\tif (isalpha(c))mp[c];\n\t\t}\n\t\trep(i, 1 << mp.size()) {\n\t\t\tstring t = s;\n\t\t\tint j = 0;\n\t\t\tfor (auto&p : mp)p.second = ((i >> (j++) & 1) ? 'T' : 'F');\n\t\t\tfor (char&c : t) {\n\t\t\t\tif (isalpha(c))c = mp[c];\n\t\t\t}\n\t\t\tj = 0;\n\t\t\tif (!equ(t, j)) { puts(\"NO\"); goto g; }\n\t\t}\n\t\tputs(\"YES\");\n\tg:;\n\t}\n}"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\n\nusing namespace std;\n\nclass ParseError {};\ntypedef string::const_iterator State;\n\nbool expression(State &begin) {\n\tbool ret;\n\tif(*begin == 'T'){begin++; ret = true;}\n\telse if(*begin == 'F'){begin++; ret = false;}\n\telse if(*begin == '-'){begin++; ret = !expression(begin);}\n\telse {\n\t\tbegin++;\n\t\tbool a = expression(begin);\n\t\tif(*begin == '*'){\n\t\t\tbegin++;\n\t\t\tret = a & expression(begin);\n\t\t}\n\t\telse if(*begin == '-'){\n\t\t\tbegin++; begin++;\n\t\t\tret = (a & !expression(begin) ? false : true);\n\t\t}\n\t\telse if (*begin == '+') {\n\t\t\tbegin++;\n\t\t\tret = a | expression(begin);\n\t\t}\n\t\tbegin++;\n\t}\n\treturn ret;\n}\n\nint main(){\n\tstring e;\n\twhile(cin >> e, e != \"#\"){\n\t\tbool possible = true;\n\t\tfor(int i=0; i < 1<<11; i++){\n\t\t\tstring s = e;\n\t\t\tstring t = \"abcdefghijk\";\n\t\t\tfor(int j=0; j < s.size(); j++){\n\t\t\t\tfor(int k=0; k < t.size(); k++){\n\t\t\t\t\tif(s[j] == t[k]) s[j] = ((i >> k) & 1 == 1 ? 'T' : 'F');\n\t\t\t\t}\n\t\t\t}\n\t\t\tstring a, b;\n\t\t\tfor(int i=0; i< s.size(); i++) if(s[i] == '='){a = s.substr(0, i); b = s.substr(i+1);}\n\t\t\tState abegin = a.begin();\n\t\t\tState bbegin = b.begin();\n\n\t\t\tif(!(expression(abegin) == expression(bbegin))){possible = false; break;}\n\t\t}\n\t\tcout << (possible ? \"YES\" : \"NO\") << endl;\n\t}\n}"
  },
  {
    "language": "C++",
    "code": "#include<iostream>\n#include<string>\n#include<map>\n#include<sstream>\n#include<cctype>\n#include<algorithm>\nusing namespace std;\ntypedef string::const_iterator Cursol;\nbool ok;\nint bit;\nbool java(Cursol &c){\n  bool ret;\n  if(*c == 'T'){\n    ret = true;\n  }else if(*c == 'F'){\n    ret = false;\n  }else if(islower(*c)){\n    ret = 1 << ((*c) - 'a');\n  }\n  c++;\n}\nbool Formula(Cursol &c){\n  bool ret, bs = false;\n  if(*c == '-'){\n    bs = true;\n    c++;\n  }\n  if(*c == '('){\n    c++;\n    ret = Formula(c);\n    c++;\n  }else{\n    ret = java(c);\n    if(*c == '+'){\n      c++;\n      ret |= Formula(c);\n    }else if(*c == '*'){\n      c++;\n      ret &= Formula(c);\n    }else if(*c == '-'){ //->\n      c+=2;\n      if(ret && !Formula(c)) ret = false;\n      else ret = true;\n    }\n  }\n    // cout << ret << endl;\n  return bs ? !ret : ret;\n}\nint main(){\n  string s;\n  Cursol c;\n  while(cin >> s , ok = true, s != \"#\"){\n    string l = s.substr(0,s.find('='));\n    string r = s.substr(s.find('=')+1);\n\n    for(bit = 0 ; bit < (1 << 11) ; bit++ ){\n      c = l.begin();\n      bool java = Formula(c);\n      c = r.begin();\n      if( java != Formula(c) ){\n\tok = false;\n\tbreak;\n      }\n    }\n    if(ok) cout << \"YES\" << endl;\n    else cout << \"NO\" << endl;\n  }\n}"
  },
  {
    "language": "C++",
    "code": "#include <iostream>\n#include <vector>\n#include <cstdlib>\nusing namespace std;\n\nint n;\nstring str;\n\nbool parser(int ch)\n{\n\tbool a, b;\n\tswitch (str[n]) {\n\tcase 'a':\n\tcase 'b':\n\tcase 'c':\n\tcase 'd':\n\tcase 'e':\n\tcase 'f':\n\tcase 'g':\n\tcase 'h':\n\tcase 'i':\n\tcase 'j':\n\tcase 'k':\n\t\treturn (ch >> (str[n++] - 'a')) & 1;\n\tcase '(':\n\t\tn++;\n\t\ta = parser(ch);\n\t\tif (str[n] == '+') {\n\t\t\tn++;\n\t\t\tb = parser(ch);\n\t\t\tn++;\n\t\t\treturn a||b;\n\t\t}\n\t\telse if(str[n] == '*') {\n\t\t\tn++;\n\t\t\tb = parser(ch);\n\t\t\tn++;\n\t\t\treturn a&&b;\n\t\t}\n\t\telse {\n\t\t\tn++;\n\t\t\tn++;\n\t\t\tb = parser(ch);\n\t\t\tn++;\n\t\t\tif (a == true){\n\t\t\t\tif (b == true)\n\t\t\t\t\treturn true;\n\t\t\t\telse\n\t\t\t\t\treturn false;\n\t\t\t}\n\t\t\telse\n\t\t\t\treturn true;\n\t\t}\n\t\tbreak;\n\tcase '-':\n\t\tn++;\n\t\treturn !parser(ch);\n\t\tbreak;\n\tcase 'T':\n\t\tn++;\n\t\treturn true;\n\tcase 'F':\n\t\tn++;\n\t\treturn false;\n\tdefault :\n\t\texit(EXIT_FAILURE);\n\t}\n}\n\nint main()\n{\n\twhile (cin >> str, str != \"#\") {\n\t\tbool res = true;\n\t\tfor (int i = 0; i < 0x800; i++) {\n\t\t\tn = 0;\n\t\t\tbool p1 = parser(i);\n\t\t\tn++;\n\t\t\tif (p1 != parser(i)) {\n\t\t\t\tres = false;\n\t\t\t\tbreak;\n\t\t\t}\n\t\t}\n\t\tif (res)\n\t\t\tcout << \"YES\" << endl;\n\t\telse\n\t\t\tcout << \"NO\" << endl;\n\t}\n\treturn 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include<iostream>\n#include<vector>\n#include<string>\n#include<algorithm>\n#define all(c) c.begin(),c.end()\n#define uni(c) c.erase(unique(c.begin(),c.end()),c.end())\n#define pb push_back\nusing namespace std;\n\nint expr(string& s, int& i);\nint term(string& s, int& i);\nint factor(string& s, int& i);\nint number(string& s, int& i);\n\n\nint expr(string& s, int& i) {\n  int val = term(s, i);\n  while(s[i] == '+' || s[i] == '-') {\n    char op = s[i];\n    i++;\n  \tif(!isdigit(s[i])){\n  \t\ti++;\n  \t\tint val2 = term(s, i);\n  \t\tif(val==1&&val2==0){\n  \t\t\tval=0;\n  \t\t}else{\n  \t\t\tval=1;\n  \t\t}\n  \t}else{\n  \t  int val2 = term(s, i);\n    \tif (op == '+') val |= val2;\n  \t}\n  }\n  return val;\n}\n\nint term(string& s, int& i) {\n  int val = factor(s, i);\n  while(s[i] == '*') {\n    char op = s[i];\n    i++;\n    int val2 = factor(s, i);\n    if (op == '*') val *= val2;\n  }\n  return val;\n}\n\nint factor(string& s, int& i) {\n\tint flag=0;\n\tif(s[i]=='-'){\n\t\tflag=1;\n\t\ti++;\n\t}\n\tif (isdigit(s[i])){\n\t\tif(flag)\n\t\t\treturn flag^number(s, i);\n\t\t\treturn number(s,i);\n\t}\n\n  // ここで構文が正しければ s[i] == '(' となる\n  i++; // '('を読み飛ばす\n  int ret = expr(s, i);\n  i++; // ')'を読み飛ばす\n\tif(flag)\n\treturn flag^ret;\n\treturn ret;\n}\n\nint number(string& s, int& i) {\n  int n = s[i++] - '0';\n  while(isdigit(s[i])) n = n*10 + s[i++] - '0';\n  return n;\n}\n\nint main(){\n\tstring s;\n\twhile(cin>>s,s!=\"#\"){\n\t\tint eq=0;\n\t\tstring a,b;\n\t\tfor(;s[eq]!='=';eq++);\n\t\ta=s.substr(0,eq),b=s.substr(eq+1,s.size()-eq);\n\t\t//cout<<a<<\" \"<<b<<endl;\n\t\tvector<char> ap;\n\t\tfor(int i=0;i<s.size();i++){\n\t\t\tif(isalpha(s[i]))\n\t\t\t\tap.pb(s[i]);\n\t\t}\n\t\tsort(all(ap));\n\t\tuni(ap);\n\t\tbool flag=true;\n\t\tfor(int i=0;i<(1<<ap.size());i++){\n\t\t\tstring x=a,y=b;\n\t\t\tfor(int j=0;j<ap.size();j++){\n\t\t\t\tchar c=ap[j];\n\t\t\t\tbool wh=false;\n\t\t\t\tif((1<<j)&i)\n\t\t\t\t\twh=true;\n\t\t\t\tfor(int k=0;k<x.size();k++){\n\t\t\t\t\tif(x[k]==c){\n\t\t\t\t\t\tif(wh)\n\t\t\t\t\t\t\tx[k]='1';\n\t\t\t\t\t\telse\n\t\t\t\t\t\t\tx[k]='0';\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t\tfor(int k=0;k<y.size();k++){\n\t\t\t\t\tif(y[k]==c){\n\t\t\t\t\t\tif(wh)\n\t\t\t\t\t\t\ty[k]='1';\n\t\t\t\t\t\telse\n\t\t\t\t\t\t\ty[k]='0';\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t}\n\t\t\t\n\t\t\t\n\t\t\tcout<<x<<\" \"<<y<<endl;\n\t\t\tcout<<expr(x,0)<<\"  \"<<expr(y,0)<<endl;\n\t\t\tif(expr(x,0)!=expr(y,0)){\n\t\t\t\tcout<<\"NO\"<<endl;\n\t\t\t\tflag=false;\n\t\t\t\tbreak;\n\t\t\t}\n\t\t\t\n\t\t}\n\t\tif(flag)\n\t\t\tcout<<\"YES\"<<endl;\n\t}\n\treturn 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include<iostream>\n#include<string>\n#define MAX 6\nusing namespace std;\nbool o;\nvoid rec(string s){\n  if(!o) return;\n  //cout << s << endl;\n  bool f;\n  int p;\n  while(s.find(\"-0\")!=-1){\n    p=s.find(\"-0\");\n    s[p]='1';s[p+1]=' ';\n    f=true;\n  }\n  while(s.find(\"-1\")!=-1){\n    p=s.find(\"-1\");\n    s[p]='0';s[p+1]=' ';\n    f=true;\n  }\n  while(s.find(\"(0*0)\")!=-1){\n    p=s.find(\"(0*0)\");\n    s[p]='0';s[p+1]=' ';s[p+2]=' ';s[p+3]=' ';s[p+4]=' ';\n    f=true;\n  }\n  while(s.find(\"(0*1)\")!=-1){\n    p=s.find(\"(0*1)\");\n    s[p]='0';s[p+1]=' ';s[p+2]=' ';s[p+3]=' ';s[p+4]=' ';\n    f=true;\n  }\n  while(s.find(\"(1*0)\")!=-1){\n    p=s.find(\"(1*0)\");\n    s[p]='0';s[p+1]=' ';s[p+2]=' ';s[p+3]=' ';s[p+4]=' ';\n    f=true;\n  }\n  while(s.find(\"(1*1)\")!=-1){\n    p=s.find(\"(1*1)\");\n    s[p]='1';s[p+1]=' ';s[p+2]=' ';s[p+3]=' ';s[p+4]=' ';\n    f=true;\n  }\n  while(s.find(\"(0+0)\")!=-1){\n    p=s.find(\"(0+0)\");\n    s[p]='0';s[p+1]=' ';s[p+2]=' ';s[p+3]=' ';s[p+4]=' ';\n    f=true;\n  }\n  while(s.find(\"(0+1)\")!=-1){\n    p=s.find(\"(0+1)\");\n    s[p]='1';s[p+1]=' ';s[p+2]=' ';s[p+3]=' ';s[p+4]=' ';\n    f=true;\n  }\n  while(s.find(\"(1+0)\")!=-1){\n    p=s.find(\"(1+0)\");\n    s[p]='1';s[p+1]=' ';s[p+2]=' ';s[p+3]=' ';s[p+4]=' ';\n    f=true;\n  }\n  while(s.find(\"(1+1)\")!=-1){\n    p=s.find(\"(1+1)\");\n    s[p]='1';s[p+1]=' ';s[p+2]=' ';s[p+3]=' ';s[p+4]=' ';\n    f=true;\n  }\n  while(s.find(\"(0->0)\")!=-1){\n    p=s.find(\"(0->0)\");\n    s[p]='1';s[p+1]=' ';s[p+2]=' ';s[p+3]=' ';s[p+4]=' ';s[p+5]=' ';\n    f=true;\n  }\n  while(s.find(\"(0->1)\")!=-1){\n    p=s.find(\"(0->1)\");\n    s[p]='1';s[p+1]=' ';s[p+2]=' ';s[p+3]=' ';s[p+4]=' ';s[p+5]=' ';\n    f=true;\n  }\n  while(s.find(\"(1->0)\")!=-1){\n    p=s.find(\"(1->0)\");\n    s[p]='0';s[p+1]=' ';s[p+2]=' ';s[p+3]=' ';s[p+4]=' ';s[p+5]=' ';\n    f=true;\n  }\n  while(s.find(\"(1->1)\")!=-1){\n    p=s.find(\"(1->1)\");\n    s[p]='1';s[p+1]=' ';s[p+2]=' ';s[p+3]=' ';s[p+4]=' ';s[p+5]=' ';\n    f=true;\n  }\n  if(f){\n    string b;\n    for(int i=0;i<s.size();i++) if(s[i]!=' ') b+=s[i];\n    rec(b);\n  }else{\n    if(s[0]!=s[2]) o=false;\n    return;\n  }\n}\nvoid init(int n,string s){\n  int i,j;\n  for(i=0;i<s.size();i++){\n    for(j=0;j<=MAX;j++){\n      if(s[i]=='a'+j) s[i]='0'+(n>>j&1);\n      if(s[i]=='T') s[i]='1';\n      if(s[i]=='F') s[i]='0';\n    }\n  }\n  rec(s);\n}\nint main(){\n  string s;\n  while(cin >> s,s!=\"#\"){\n    o=true;\n    int i;\n    for(i=0;i<(1<<MAX);i++)\n      init(i,s);\n    cout << (o?\"YES\":\"NO\") << endl;\n  }\n  return 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include<iostream>\n#include<iomanip>\n#include<algorithm>\n#include<bitset>\n#include<cctype>\n#include<climits>\n#include<cmath>\n#include<cstdio>\n#include<cstring>\n#include<deque>\n#include<list>\n#include<map>\n#include<set>\n#include<stack>\n#include<string>\n#include<sstream>\n#include<queue>\n#include<vector>\nusing namespace std;\n\ntypedef string::const_iterator state;\nclass parse_error {};\n\nvoid cmpinc(state &it, char expected) {\n\tif (*it == expected) {\n\t\tit++;\n\t}\n\telse {\n\t\tcerr << \"Expected '\" << expected << \"',\";\n\t\tcerr << \"got '\" << *it << \"'\";\n\n\t\tcout << endl;\n\t\tthrow parse_error();\n\t}\n}\n\n/*\n\nBNF\n\n<equation> ::= <formula> \"=\" <formula>\n<formula>  ::= \"T\" | \"F\" |\n\"a\" | \"b\" | \"c\" | \"d\" | \"e\" | \"f\" | \"g\" | \"h\" | \"i\" | \"j\" | \"k\" |\n\"-\" <formula> |\n\"(\" <formula> \"*\" <formula> \")\" |\n\"(\" <formula> \"+\" <formula> \")\" |\n\"(\" <formula> \"->\" <formula> \")\"\n\n*/\n\nint i; //?????°??¨\n\nbool formula(state &it) {\n\tbool ret, L, R;\n\n\t//while (true) {\n\tswitch (*it) {\n\n\tcase 'T':\n\t\tit++;\n\t\tret = true;\n\t\tbreak;\n\tcase 'F':\n\t\tit++;\n\t\tret = false;\n\t\tbreak;\n\tcase '(':\n\t\tit++;\n\t\tL = formula(it);\n\n\t\tswitch (*it) {\n\t\tcase '*':\n\t\t\tit++;\n\t\t\tR = formula(it);\n\t\t\tret = L&R;\n\t\t\tbreak;\n\t\tcase '+':\n\t\t\tit++;\n\t\t\tR = formula(it);\n\t\t\tret = L | R;\n\t\t\tbreak;\n\t\tdefault: //->\n\t\t\tit++; it++;\n\t\t\tR = formula(it);\n\n\t\t\tif (L && !R)ret = false;\n\t\t\telse ret = true;\n\n\t\t\tbreak;\n\t\t}\n\n\t\tcmpinc(it, ')'); //)\n\t\tbreak;\n\tcase '-':\n\t\tit++;\n\t\tret = !formula(it);\n\t\tbreak;\n\tdefault:\n\t\tif (*it >= 'a'&&*it <= 'k') {\n\t\t\tret = (bool)(i >> (*it - 'a') & 1);\n\t\t\tit++;\n\t\t}\n\t\tbreak;\n\t}\n\t//}\n\n\treturn ret;\n}\n\nint main() {\n\tfor (string s; getline(cin, s), s != \"#\"; ) {\n\n\t\tbool a = false;\n\n\t\tfor (i = 0; i < 2048; i++) {\n\t\t\tstate it = s.begin();\n\n\t\t\tint L, R;\n\t\t\tL = formula(it);\n\t\t\tcmpinc(it, '=');\n\t\t\tR = formula(it);\n\t\t\t\n\t\t\t//cerr << L << \" \" << R << endl;\n\t\t\t\n\t\t\tif (L == R)\n\t\t\t\ta = true;\n\t\t\telse {\n\t\t\t\ta = false;\n\t\t\t\tbreak;\n\t\t\t}\n\t\t}\n\n\t\tif (a)\n\t\t\tcout << \"YES\" << endl;\n\t\telse\n\t\t\tcout << \"NO\" << endl;\n\n\t}\n\treturn 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\nusing namespace std;\n\nint vars;\nint pos;\nbool formula(const string& str) {\n  pos++;\n  if(str[pos] == 'T') return true;\n  if(str[pos] == 'F') return false;\n  if(isalpha(str[pos])) {\n    return (vars>>(str[pos]-'a') & 1);\n  }\n  if(str[pos] == '-') {\n    return !formula(str);\n  }\n  if(str[pos] == '(') {\n    int f = formula(str);\n    pos++;\n    bool ret;\n    if(str[pos] == '*') {\n      ret = formula(str) && f;\n    }\n    else if(str[pos] == '+') {\n      ret = f || formula(str);\n    }\n    else if(str[pos] == '-') {\n      pos++;\n      ret = f<=formula(str);\n    }\n    pos ++;\n    return ret;\n  }\n}\n\nint main() {\n  string str;\n  while(cin>>str && str!=\"#\") {\n    int eq = str.find(\"=\");\n    string s = str.substr(0, eq);\n    string t = str.substr(eq+1);\n    bool ok = true;\n    for(vars=0;vars<(1<<11);vars++) {\n      pos = -1; bool fs = formula(s);\n      pos = -1;\n      if(fs != formula(t)) { ok = false; break; }\n    }\n    if(ok) {\n      cout << \"YES\" << endl;\n    }\n    else {\n      cout << \"NO\" << endl;\n    }\n  }\n  return 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\nusing namespace std;\n\nint vars;\n\nbool formula(const string& str, int pos) {\n  pos++;\n  if(str[pos] == 'T') return true;\n  if(str[pos] == 'F') return false;\n  if(isalpha(str[pos])) {\n    return (vars>>(str[pos]-'a') & 1);\n  }\n  if(str[pos] == '-') {\n    return !formula(str, pos);\n  }\n  if(str[pos] == '(') {\n    int f = formula(str, pos);\n    pos++;\n    if(str[pos] == '*') {\n      return f && formula(str, pos++);\n    }\n    if(str[pos] == '+') {\n      return f || formula(str, pos++);\n    }\n    if(str[pos] == '-') {\n      pos++;\n      return f<=formula(str, pos++);\n    }\n  }\n}\n\nint main() {\n  string s;\n  while(cin>>s && s!=\"#\") {\n    int eq = s.find(\"=\");\n    bool ok = true;\n    for(vars=0;vars<(1<<11);vars++) {\n      string s = s.substr(0, eq);\n      string t = s.substr(eq+1);\n      if(formula(s, -1) != formula(t, -1)) { ok = false; break; }\n    }\n    if(ok) {\n      cout << \"YES\" << endl;\n    }\n    else {\n      cout << \"NO\" << endl;\n    }\n  }\n  return 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include<iostream>\n#include<string>\n#define MAX 12\nusing namespace std;\nbool o;\nvoid rec(string s){\n  if(!o) return;\n  //cout << s << endl;\n  bool f;\n  int p;\n  while(s.find(\"-0\")!=-1){\n    p=s.find(\"-0\");\n    s[p]='1';s[p+1]=' ';\n    f=true;\n  }\n  while(s.find(\"-1\")!=-1){\n    p=s.find(\"-1\");\n    s[p]='0';s[p+1]=' ';\n    f=true;\n  }\n  while(s.find(\"(0*0)\")!=-1){\n    p=s.find(\"(0*0)\");\n    s[p]='0';s[p+1]=' ';s[p+2]=' ';s[p+3]=' ';s[p+4]=' ';\n    f=true;\n  }\n  while(s.find(\"(0*1)\")!=-1){\n    p=s.find(\"(0*1)\");\n    s[p]='0';s[p+1]=' ';s[p+2]=' ';s[p+3]=' ';s[p+4]=' ';\n    f=true;\n  }\n  while(s.find(\"(1*0)\")!=-1){\n    p=s.find(\"(1*0)\");\n    s[p]='0';s[p+1]=' ';s[p+2]=' ';s[p+3]=' ';s[p+4]=' ';\n    f=true;\n  }\n  while(s.find(\"(1*1)\")!=-1){\n    p=s.find(\"(1*1)\");\n    s[p]='1';s[p+1]=' ';s[p+2]=' ';s[p+3]=' ';s[p+4]=' ';\n    f=true;\n  }\n  while(s.find(\"(0+0)\")!=-1){\n    p=s.find(\"(0+0)\");\n    s[p]='0';s[p+1]=' ';s[p+2]=' ';s[p+3]=' ';s[p+4]=' ';\n    f=true;\n  }\n  while(s.find(\"(0+1)\")!=-1){\n    p=s.find(\"(0+1)\");\n    s[p]='1';s[p+1]=' ';s[p+2]=' ';s[p+3]=' ';s[p+4]=' ';\n    f=true;\n  }\n  while(s.find(\"(1+0)\")!=-1){\n    p=s.find(\"(1+0)\");\n    s[p]='1';s[p+1]=' ';s[p+2]=' ';s[p+3]=' ';s[p+4]=' ';\n    f=true;\n  }\n  while(s.find(\"(1+1)\")!=-1){\n    p=s.find(\"(1+1)\");\n    s[p]='1';s[p+1]=' ';s[p+2]=' ';s[p+3]=' ';s[p+4]=' ';\n    f=true;\n  }\n  while(s.find(\"(0->0)\")!=-1){\n    p=s.find(\"(0->0)\");\n    s[p]='1';s[p+1]=' ';s[p+2]=' ';s[p+3]=' ';s[p+4]=' ';s[p+5]=' ';\n    f=true;\n  }\n  while(s.find(\"(0->1)\")!=-1){\n    p=s.find(\"(0->1)\");\n    s[p]='1';s[p+1]=' ';s[p+2]=' ';s[p+3]=' ';s[p+4]=' ';s[p+5]=' ';\n    f=true;\n  }\n  while(s.find(\"(1->0)\")!=-1){\n    p=s.find(\"(1->0)\");\n    s[p]='0';s[p+1]=' ';s[p+2]=' ';s[p+3]=' ';s[p+4]=' ';s[p+5]=' ';\n    f=true;\n  }\n  while(s.find(\"(1->1)\")!=-1){\n    p=s.find(\"(1->1)\");\n    s[p]='1';s[p+1]=' ';s[p+2]=' ';s[p+3]=' ';s[p+4]=' ';s[p+5]=' ';\n    f=true;\n  }\n  if(f){\n    string b;\n    for(int i=0;i<s.size();i++) if(s[i]!=' ') b+=s[i];\n    rec(b);\n  }else{\n    if(s[0]!=s[2]) o=false;\n    return;\n  }\n}\nvoid init(int n,string s){\n  int i,j;\n  for(i=0;i<s.size();i++){\n    for(j=0;j<=MAX;j++){\n      if(s[i]=='a'+j) s[i]='0'+(n>>j&1);\n      if(s[i]=='T') s[i]='1';\n      if(s[i]=='F') s[i]='0';\n    }\n  }\n  rec(s);\n}\nint main(){\n  string s;\n  while(cin >> s,s!=\"#\"){\n    o=true;\n    int i;\n    for(i=0;i<(1<<MAX);i++)\n      init(i,s);\n    cout << (o?\"YES\":\"NO\") << endl;\n  }\n  return 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include<iostream>\n#include<stack>\nusing namespace std;\n\nstring ans;\nchar con[11];\n\nchar NOT(char a){\n  if(a=='T')return 'F';\n  return 'T';\n}\nchar AND(char a,char b){\n  if(a=='T' && b=='T')return 'T';\n  return 'F';\n}\nchar OR(char a,char b){\n  if(a=='F' && b=='F')return 'F';\n  return 'T';\n}\nchar IMP(char a,char b){\n  if(a=='T' && b=='F')return 'F';\n  return 'T';\n}\n\nchar cal(string s)\n{\n  stack<char> S;\n\n  for(int i=0;i<s.length();i++){\n    if(s[i]==')'){\n      while(!S.empty()){\n\tchar a=S.top();S.pop();\n\tchar b=S.top();S.pop();\n\n        if(b=='('){\n\t  S.push(a);\n\t  break;\n\t}\n\tif(b=='-'){\n\t  S.push(NOT(a));\n\t}\n\tif(b=='+'){\n\t  char c=S.top();S.pop();\n\t  while(S.top()=='-'){\n\t    S.pop();\n\t    c=NOT(c);\n\t  }\n          S.push(OR(c,a));\n\t}\n\tif(b=='*'){\n\t  char c=S.top();S.pop();\n\t  while(S.top()=='-'){\n\t    S.pop();\n\t    c=NOT(c);\n\t  }\n\t  S.push(AND(c,a));\n\t}\n\tif(b=='>'){\n\t  S.pop();\n\t  char c=S.top();S.pop();\n\t  while(S.top()=='-'){\n\t    S.pop();\n\t    c=NOT(c);\n\t  }\n          S.push(IMP(c,a));\n\t}\n      }\t  \n    }\n    else {\n      if('a'<=s[i] && s[i]<='k')S.push(con[(s[i]-'a')]);      \n      else S.push(s[i]);\n    }\n  }\n  //cout<<S.top()<<endl;\n  return S.top();\n}\n\nvoid dfs(string l,string r,int n)\n{\n  \n  if(n==11){\n    char a=cal( '('+l+')' ),b=cal( '('+r+')' );\n    if(a!=b)ans=\"NO\";\n  }\n  else {\n    dfs(l,r,n+1);\n    con[n]='T';\n    dfs(l,r,n+1);\n    con[n]='F';\n  }\n}\n\nint main()\n{\n  string s,l,r;\n\n  while(1){\n    cin>>s;\n    if(s[0]=='#')break;\n    for(int i=0;i<11;i++)con[i]='F';\n    for(int i=0;i<s.length();i++){\n      if(s[i]=='='){\n\tl=s.substr(0,i);\n\tr=s.substr(i+1,s.length());\n      }\n    }\n    ans=\"YES\";\n    dfs(l,r,0);\n    cout<<ans<<endl;\n  }\n  return 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include <iostream>\n#include <string>\n#include <cctype>\n#include <map>\n#include <vector>\nusing namespace std;\n\ntypedef string::const_iterator State;\nclass ParseError {};\n\nmap<char, bool> variable;\n\nbool equation(State&);\nbool formula(State&);\nbool boolean(State&);\n\nint main(void) {\n    for (int i = 0; i < 11; i++) {\n        variable['a'+i] = false;\n    }\n\n    string s;\n    while (1) {\n        getline(cin, s);\n        if (s == \"#\") break;\n\n        bool flag = true;\n        for (unsigned int i = 0; i < 2048; i++) {\n            if (!flag) break;\n\n            unsigned int val = i;\n            for (int j = 0; j < 11; j++) {\n                if ((val & 1) == 0) {\n                    variable['a'+j] = true;\n                } else {\n                    variable['a'+j] = false;\n                }\n                val >>= 1;\n            }\n\n            State begin = s.begin();\n            if (!equation(begin)) flag = false;\n        }\n\n        if (flag) {\n            cout << \"YES\" << endl;\n        } else {\n            cout << \"NO\" << endl;\n        }\n    }\n\n    return 0;\n}\n\nbool equation(State &begin) {\n    bool left = formula(begin);\n    begin++;                    // '='\n    bool right = formula(begin);\n    // cout << \"left: \" << left << \", right: \" << right << endl;\n    return (left == right) ? true : false;\n}\n\nbool formula(State &begin) {\n    if (*begin == '(') {\n        begin++;                // '('\n        bool ret = formula(begin);\n        if (*begin == '*') {\n            begin++;\n            ret = formula(begin) && ret;\n        } else if (*begin == '+') {\n            begin++;\n            ret = formula(begin) || ret;\n        } else {\n            begin++;\n            if (*begin == '>') {\n                begin++;\n                if (!ret) {\n                    ret = formula(begin) || true;\n                } else {\n                    ret = formula(begin);\n                }\n            } else {\n                ret = !formula(begin);\n            }\n        }\n        begin++;                // ')'\n        return ret;\n    } else if (*begin == '-') {\n        begin++;\n        return !formula(begin);\n    } else {\n        return boolean(begin);\n    }\n}\n\nbool boolean(State &begin) {\n    if (*begin == 'T') {\n        begin++;\n        return true;\n    } else if (*begin == 'F') {\n        begin++;\n        return false;\n    } else {                // a~k\n        bool ret = variable[*begin];\n        begin++;\n        return ret;\n    }\n}"
  },
  {
    "language": "C++",
    "code": "#include <iostream>\n#include <vector>\n#include <string>\n#include <stack>\n#include <queue>\n#include <deque>\n#include <set>\n#include <map>\n#include <algorithm>\t// require sort next_permutation count __gcd reverse etc.\n#include <cstdlib>\t// require abs exit atof atoi \n#include <cstdio>\t\t// require scanf printf\n#include <functional>\n#include <numeric>\t// require accumulate\n#include <cmath>\t\t// require fabs\n#include <climits>\n#include <limits>\n#include <cfloat>\n#include <iomanip>\t// require setw\n#include <sstream>\t// require stringstream \n#include <cstring>\t// require memset\n#include <cctype>\t\t// require tolower, toupper\n#include <fstream>\t// require freopen\n#include <ctime>\t\t// require srand\n#define rep(i,n) for(int i=0;i<(n);i++)\n#define ALL(A) A.begin(), A.end()\n/*\n\thttp://judge.u-aizu.ac.jp/onlinejudge/description.jsp?id=2401\n\t\n\tACM-ICPC Japan Alumni Group Practice Contest for Japan Domestic 2012, 2012-06-17 \n\n\tEquation\n\n\t構文解析の問題\n\n\t定数: T, F\n\t変数: a, b, c, d, e, f, g, h, i, j, k\n\t論理否定: -X\n\t論理積: (X*Y)\n\t論理和: (X+Y)\n\t論理包含: (X->Y)\n\n\n\tx\ty\t-x\t(x*y)\t(x+y)\t(x->y)\n\tT\tT\tF\tT\tT\tT\n\tT\tF\tF\tF\tT\tF\n\tF\tT\tT\tF\tT\tT\n\tF\tF\tT\tF\tF\tT\n\n\t<equation> ::= <formula> \"=\" <formula>\n\t<formula>  ::= \"T\" | \"F\" |\n\t\"a\" | \"b\" | \"c\" | \"d\" | \"e\" | \"f\" |\n\t\"g\" | \"h\" | \"i\" | \"j\" | \"k\" |\n\t\"-\" <formula> |\n\t\"(\" <formula> \"*\" <formula> \")\" |\n\t\"(\" <formula> \"+\" <formula> \")\" |\n\t\"(\" <formula> \"->\" <formula> \")\"\n\n*/\nusing namespace std;\n\ntypedef long long ll;\ntypedef pair<int, int> P;\n\nint idx = 0;\nstring eq;\nbool formula (void ){\n\n\tbool f1 = false, f2 = false;\n\tif (eq[idx] == '-' ){\n\t\tidx++;\n\t\tf1 = !formula ();\n\t\treturn f1;\n\t}else\n\tif (eq[idx] == '(' ){\n\t\tidx++;\n\t\tf1 = formula ();\n\t\tif (eq[idx] == '*' ){\n\t\t\tidx++;\n\t\t\tf2 = formula ();\n\t\t\tidx++;\t// omit ')'\n\t\t\treturn f1 & f2;\n\t\t}else\n\t\tif (eq[idx] == '+' ){\n\t\t\tidx++;\n\t\t\tf2 = formula ();\n\t\t\tidx++;\t// omit ')'\n\t\t\treturn f1 | f2;\n\t\t}else\n\t\tif (eq[idx] == '-' && idx + 1 < eq.size() && eq[idx+1] == '>' ){\n\t\t\tidx += 2;\n\t\t\tf2 = formula ();\n\t\t\tidx++;\t// omit ')'\n\t\t\treturn !(f1 & !f2 );\n\t\t} // end if\n\t}else{\n\t\tif (eq[idx] == 'T' ){\n\t\t\tf1 = true;\n\t\t}else{\n\t\t\tf1 = false;\n\t\t} // end if\n\t\tidx++;\n\t\treturn f1;\n\t} // end if\n\n\treturn false;\n}\n\nbool equation (void ){\n\tbool f1 = formula ();\n\tif (eq[idx] == '=' ) idx++;\n\tbool f2 = formula ();\n\n\treturn (f1 == f2 );\n}\n\nbool parse (string s ){\n\teq = s;\n\tidx = 0;\n\tbool res = equation ();\n\n\treturn res;\n}\n\nint main()\n{\n\tios_base::sync_with_stdio(0);\n\tstring s = \"\";\n\twhile (cin >> s && s != \"#\" ){\n\t\tint n = s.length();\n\t\tvector<char> val; val.clear();\n\t\trep (i, n ){\n\t\t\tif (s[i] >= 'a' && s[i] <= 'k' ) val.push_back (s[i] );\n\t\t} // end rep\n\t\tsort (ALL (val ) );\n\t\tval.erase (unique (ALL (val ) ), val.end() );\n\n\t\tbool res = true;\n\n\t\tif (val.empty() ){\n\t\t\tres = parse (s );\n\t\t}else{\n\t\t\trep (i, 1<<val.size() ){\n\t\t\t\tstring t = s;\n\t\t\t\trep (j, val.size() ){\n\t\t\t\t\tif (i&(1<<j) ){\n\t\t\t\t\t\trep (k, t.size() ) if (t[k] == val[j] ) t[k] = 'T';\n\t\t\t\t\t} // end if\n\t\t\t\t} // end rep\n\t\t\t\trep (k, t.size() ) if (islower (t[k] ) ) t[k] = 'F';\n\t\t\t\tres &= parse (t );\n\t\t\t} // end rep\n\t\t} // edn if\n\t\tcout << (res ? \"YES\" : \"NO\" ) << endl;\n\t} // end while\n\t\n\treturn 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include <cassert>\n#include <iostream>\n\nusing namespace std;\n\n#define repi(i,a,b) for(int i=int(a);i<int(b);i++)\n#define rep(i,n) repi(i,0,n)\n\ntypedef pair<bool,int> parsed;\n\nparsed formula(const string& t,int i)\n{\n\tif(isupper(t[i]))\n\t\treturn parsed(t[i]=='T',i+1);\n\t\n\tif(t[i]=='-'){\n\t\tparsed p=formula(t,i+1);\n\t\tp.first^=1;\n\t\treturn p;\n\t}\n\tif(t[i]=='('){\n\t\tparsed p1=formula(t,i+1);\n\t\tint j=p1.second;\n\t\tif(t[j]=='-'){\n\t\t\tparsed p2=formula(t,j+2);\n\t\t\treturn parsed(p1.first<=p2.first,p2.second+1);\n\t\t}\n\t\tparsed p2=formula(t,j+1);\n\t\tif(t[j]=='*')\n\t\t\treturn parsed(p1.first&&p2.first,p2.second+1);\n\t\tif(t[j]=='+')\n\t\t\treturn parsed(p1.first||p2.first,p2.second+1);\n\t}\n\tassert(false);\n}\n\nbool solve(string s)\n{\n\trep(bit,1<<11){\n\t\tstring t;\n\t\trep(i,s.size()){\n\t\t\tif(isalpha(s[i]))\n\t\t\t\tt+=\"FT\"[bit>>s[i]-'a'&1];\n\t\t\telse\n\t\t\t\tt+=s[i];\n\t\t}\n\t\tparsed p1=formula(t.substr(0,t.find('=')),0);\n\t\tparsed p2=formula(t.substr(t.find('=')+1),0);\n\t\tif(p1.first!=p2.first)\n\t\t\treturn false;\n\t}\n\treturn true;\n}\n\nint main()\n{\n\tfor(string s;cin>>s,s!=\"#\";)\n\t\tcout<<(solve(s)?\"YES\":\"NO\")<<endl;\n\treturn 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include <iostream>\n#include <string>\n#include <vector>\n#include <algorithm>\n#include <utility>\n#include <cstring>\n#include <cmath>\n#include <queue>\n#include <map>\n#include <set>\nusing namespace std;\n\n#define rep(i,n) for(int i=0; i<n; i++)\n#define FOR(i,s,n) for(int i=s; i<n; i++)\n#define ALL(x) x.begin(), x.end()\ntypedef long long ll;\ntypedef unsigned long long ull;\ntypedef pair<int,int> pii;\ntypedef vector<int> vi;\n\nstring solve( string s ) {\n\tif( s == \"0\" || s == \"1\" ) return s;\n\trep(i, s.length()) {\n\t\tif(s[i] == '(') {\n\t\t\tint p = i+2;\n\t\t\twhile(p<s.length() && s[p]!=')') p++;\n\t\t\tstring ss = solve(s.substr(i+1, p-i-1));\n\t\t\ts.replace(i, p-i+1, ss);\n\t\t}\n\t}\n\n\trep(i, s.length()) {\n\t\tif(s[i] == '*') {\n\t\t\tstring sa = solve(s.substr(0, i));\n\t\t\tstring sb = solve(s.substr(i+1));\n\t\t\ts = (sa==\"1\" && sb==\"1\") ? \"1\" : \"0\";\n\t\t}\n\t\telse if(s[i] == '+') {\n\t\t\tstring sa = solve(s.substr(0, i));\n\t\t\tstring sb = solve(s.substr(i+1));\n\t\t\ts = (sa==\"0\" && sb==\"0\") ? \"0\" : \"1\";\n\t\t}\n\t\telse if(s[i] == '-' && i+1<s.length() && s[i+1]=='>') {\n\t\t\tstring sa = solve(s.substr(0, i));\n\t\t\tstring sb = solve(s.substr(i+2));\n\t\t\ts = (sa==\"1\" && sb==\"0\") ? \"0\" : \"1\";\n\t\t}\n\t}\n\trep(i, s.length()) {\n\t\tif(s[i] == '-') {\n\t\t\tstring ss = solve(s.substr(i+1));\n\t\t\ts = (ss==\"0\" ? \"1\" : \"0\");\n\t\t}\n\t}\n\treturn s;\n}\n\nint main() {\n\tstring in;\n\twhile(cin >> in, in!=\"#\") {\n\t\tstring aa, ab;\n\t\trep(i, in.length()) {\n\t\t\tif( in[i] == 'T' ) {\n\t\t\t\tin[i] = '1';\n\t\t\t}\n\t\t\telse if( in[i] == 'F' ) {\n\t\t\t\tin[i] = '0';\n\t\t\t}\n\t\t}\n\t\trep(i, in.length()) {\n\t\t\tif( in[i] == '=' ) {\n\t\t\t\taa = in.substr(0, i);\n\t\t\t\tab = in.substr(i+1);\n\t\t\t\tbreak;\n\t\t\t}\n\t\t}\n\t\tbool ng = false;\n\t\trep(i, (1<<11)) {\n\t\t\tstring a=aa, b=ab;\n\t\t\trep(j, a.length()) {\n\t\t\t\tif('a'<=a[j] && a[j]<='k') {\n\t\t\t\t\ta[j] = '0' + ((i & (1<<a[j]-'a')) ? 1 : 0);\n\t\t\t\t}\n\t\t\t}\n\t\t\trep(j, b.length()) {\n\t\t\t\tif('a'<=b[j] && b[j]<='k') {\n\t\t\t\t\tb[j] = '0' + ((i & (1<<b[j]-'a')) ? 1 : 0);\n\t\t\t\t}\n\t\t\t}\n\t\t\ta = solve(a);\n\t\t\tb = solve(b);\n\t\t\tif( a != b ) {\n\t\t\t\tcout << \"NO\" << endl;\n\t\t\t\tng = true;\n\t\t\t\tbreak;\n\t\t\t}\n\t\t}\n\t\tif( !ng ) {\n\t\t\tcout << \"YES\" << endl;\n\t\t}\n\t}\n\treturn 0;\n}"
  },
  {
    "language": "C++",
    "code": "// g++ -std=c++11 a.cpp\n#include<iostream>\n#include<vector>\n#include<string>\n#include<algorithm>\t\n#include<map>\n#include<set>\n#include<utility>\n#include<cmath>\n#include<cstring>\n#include<queue>\n#include<stack>\n#include<bitset>\n#include<cstdio>\n#include<sstream>\n#include<iomanip>\n#include<assert.h>\n#include<typeinfo>\n#define loop(i,a,b) for(int i=a;i<b;i++) \n#define rep(i,a) loop(i,0,a)\n#define pb push_back\n#define all(in) in.begin(),in.end()\n#define shosu(x) fixed<<setprecision(x)\nusing namespace std;\n//kaewasuretyuui\ntypedef long long ll;\n//#define int ll\ntypedef int Def;\ntypedef pair<Def,Def> pii;\ntypedef vector<Def> vi;\ntypedef vector<vi> vvi;\ntypedef vector<pii> vp;\ntypedef vector<vp> vvp;\ntypedef vector<string> vs;\ntypedef vector<double> vd;\ntypedef vector<vd> vvd;\ntypedef pair<Def,pii> pip;\ntypedef vector<pip>vip;\n// #define mt make_tuple\n//typedef tuple<pii,int,int> tp;\n//typedef vector<tp> vt;\ntemplate<typename A,typename B>bool cmin(A &a,const B &b){return a>b?(a=b,true):false;}\ntemplate<typename A,typename B>bool cmax(A &a,const B &b){return a<b?(a=b,true):false;}\n//template<class C>constexpr int size(const C &c){return (int)c.size();}\n//template<class T,size_t N> constexpr int size(const T (&xs)[N])noexcept{return (int)N;}\nconst double PI=acos(-1);\nconst double EPS=1e-7;\nDef inf = sizeof(Def) == sizeof(long long) ? 2e18 : 1e9;\nint dx[]={0,1,0,-1};\nint dy[]={1,0,-1,0};\ntypedef string::const_iterator State;\nint q;\nDef formula(State &i,bool h){\n//\tcout<<*i<<\" \"<<h<<endl;\n\tDef out;\n\tif(*i=='('){\n\t\ti++;\n\t\tout=formula(i,0);\n\t}else if(*i=='T')out=1;\n\telse if(*i=='F')out=0;\n\telse if(*i=='-')out=1-formula(++i,1);\n\telse if(isalpha(*i))out=(q>>(*i-'a'))&1;\n\tif(h)return out;\n\ti++;\n\tint op=0;\n\tif(*i=='+')op=1;\n\tif(*i=='-'){op=2;i++;}\n\tif(*i=='*')op=3;\n\tif(op){\n\t\ti++;\n\t\tDef out1=formula(i,0);\n\t\tif(op==1)out|=out1;\n\t\tif(op==2)out=!out||out&&out1;\n\t\tif(op==3)out&=out1;\n\t}\n\treturn out;\n}\nint main(){\n\tstring s,t;\n\twhile(1){\n\t\tgetline(cin,s);\n\t\tif(s==\"#\")break;\n\t\trep(i,s.size())if(s[i]=='='){\n\t\t\tt=s.substr(i+1);\n\t\t\ts=s.substr(0,i);\n\t\t}\n\t\tbool h=true;\n\t\trep(i,1<<3){\n\t\t\tq=i;\n\t\t\tState S=s.begin(),T=t.begin();\n\t\t\tint ss=formula(S,0);\n\t\t\tint tt=formula(T,0);\n//\t\t\tcout<<ss<<\" \"<<tt<<endl;\n\t\t\tif(ss!=tt){\n\t\t\t\th=false;\n\t\t\t\tbreak;\n\t\t\t}\n\t\t}\n\t\tif(h)cout<<\"YES\"<<endl;\n\t\telse cout<<\"NO\"<<endl;\n\t}\n}"
  },
  {
    "language": "C++",
    "code": "#include <iostream>\n#include <iomanip>\n#include <vector>\n#include <string>\n#include <algorithm>\n#include <cctype>\n#include <cmath>\n#include <iomanip>\n\n#define REP(i,n) for(int i=0;i<n;++i)\n#define RREP(i,n) for(int i=n-1;i>=0;--i)\n#define FOR(i,m,n) for(int i=m;i<n;++i)\n#define RFOR(i,m,n) for(int i=m-1;i>=n;--i)\n#define ALL(v) v.begin(),v.end()\n#define PB(a) push_back(a)\n#define INF 1000000001\n#define MOD 1000000007\n\nusing namespace std;\n\nint equation(string &s, int &i);\nint formula(string &s, int &i);\nint ch(string &s, int &i);\n\nint k = 0;\nint bl[2048][11];\n\nint equation(string& s, int &i) {\n\tint val = formula(s, i);\n\t++i;\n\tint val2 = formula(s, i);\n\tif (val == val2) return 1;\n\telse return 0;\n}\n\nint formula(string& s, int& i) {\n\tif (isalpha(s[i])) {\n\t\t return ch(s, i);\n\t}\n\telse if (s[i] == '-') {\n\t\t++i;\n\t\treturn ~formula(s, i);\n\t}\n\telse {\n\t\t++i;\n\t\tint val = formula(s, i);\n\t\tchar c = s[i];\n\t\tif (c == '+') {\n\t\t\t++i;\n\t\t\tint val2 = formula(s, i);\n\t\t\t++i;\n\t\t\treturn val | val2;\n\t\t}\n\t\telse if (c == '*') {\n\t\t\t++i;\n\t\t\tint val2 = formula(s, i);\n\t\t\t++i;\n\t\t\treturn val&val2;\n\t\t}\n\t\telse {\n\t\t\ti += 2;\n\t\t\tint val2 = formula(s, i);\n\t\t\t++i;\n\t\t\treturn ~val | val2;\n\t\t}\n\t}\n}\n\nint ch(string& s, int &i) {\n\tif (s[i] == 'T') {\n\t\t++i;\n\t\treturn 1;\n\t}\n\telse if (s[i] == 'F') {\n\t\t++i;\n\t\treturn 0;\n\t}\n\telse {\n\t\t++i;\n\t\treturn bl[k][int(s[i] - 'a')];\n\t}\n}\n/*\nint expr(string &s, int&i) {\n\tint val = term(s, i);\n\t++i;\n\twhile (s[i] = '+' || s[i] == '*' || s[i] == '-') {\n\t\tchar op = s[i];\n\t\t++i;\n\t\tint val2 = term(s, i);\n\t\tif (s[i] == '+') {\n\t\t\tval |= val2;\n\t\t}\n\t\telse if (s[i] == '*') {\n\t\t\tval &= val2;\n\t\t}\n\t\telse {\n\t\t\tval = ~val | val2;\n\t\t}\n\t}\n}\n\n\nint term(string &s, int &i) {\n\tif (s[i] == '-') {\n\t\t++i;\n\t\treturn ~term(s, i);\n\t}\n\telse if (isalpha(s[i])) {\n\t\treturn ch(s, i);\n\t}\n\telse {\n\t\t++i;\n\t\tint val = term(s, i);\n\t\t++i;\n\t\treturn val;\n\t}\n}\n\nint ch(string &s, int &i) {\n\tif (s[i] == 'T') {\n\t\treturn 1;\n\t}\n\telse if (s[i] == 'F') {\n\t\treturn 0;\n\t}\n\telse {\n\t\tint c = s[i] - 'a';\n\t\treturn bl[k][c];\n\t}\n}\n\n*/\nint main() {\n\tREP(i, 2048) {\n\t\tREP(j, 11) {\n\t\t\tif (i % 2 == 0) {\n\t\t\t\tbl[i][j] = 0;\n\t\t\t}\n\t\t\telse {\n\t\t\t\tbl[i][j] = 1;\n\t\t\t}\n\t\t}\n\t}\n\twhile (1) {\n\t\tstring s;\n\t\tcin >> s;\n\t\tif (s[0] == '#') break;\n\t\tint flag = 1;\n\n\t\tfor (; k < 2048; ++k) {\n\t\t\tint i = 0;\n\t\t\tif (!equation(s, i)) flag = 0;\n\t\t}\n\t\tif (flag) {\n\t\t\tcout << \"YES\" << endl;\n\t\t}\n\t\telse {\n\t\t\tcout << \"NO\" << endl;\n\t\t}\n\t\tk = 0;\n\t}\n\treturn 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\nusing namespace std;\n\nint n;\nstring str;\n\nbool parser(int ch)\n{\n\tbool a, b;\n\tswitch (str[n]) {\n\tcase 'a':\n\tcase 'b':\n\tcase 'c':\n\tcase 'd':\n\tcase 'e':\n\tcase 'f':\n\tcase 'g':\n\tcase 'h':\n\tcase 'i':\n\tcase 'j':\n\tcase 'k':\n\t\treturn (ch >> (str[n++] - 'a')) & 1;\n\tcase '(':\n\t\tn++;\n\t\ta = parser(ch);\n\t\tif (str[n] == '+') {\n\t\t\tn++;\n\t\t\tb = parser(ch);\n\t\t\tn++;\n\t\t\treturn a || b;\n\t\t}\n\t\telse if (str[n] == '*') {\n\t\t\tn++;\n\t\t\tb = parser(ch);\n\t\t\tn++;\n\t\t\treturn a&&b;\n\t\t}\n\t\telse {\n\t\t\tn++;\n\t\t\tn++;\n\t\t\tb = parser(ch);\n\t\t\tn++;\n\t\t\tif (a == true) {\n\t\t\t\tif (b == true)\n\t\t\t\t\treturn true;\n\t\t\t\telse\n\t\t\t\t\treturn false;\n\t\t\t}\n\t\t\telse\n\t\t\t\treturn true;\n\t\t}\n\t\tbreak;\n\tcase '-':\n\t\tn++;\n\t\treturn !parser(ch);\n\t\tbreak;\n\tcase 'T':\n\t\tn++;\n\t\treturn true;\n\tcase 'F':\n\t\tn++;\n\t\treturn false;\n\tdefault:\n\t\texit(EXIT_FAILURE);\n\t}\n}\n\nint main()\n{\n\twhile (cin >> str, str != \"#\") {\n\t\tbool res = true;\n\t\tfor (int i = 0; i < 0x800; i++) {\n\t\t\tn = 0;\n\t\t\tbool p1 = parser(i);\n\t\t\tn++;\n\t\t\tif (p1 != parser(i)) {\n\t\t\t\tres = false;\n\t\t\t\tbreak;\n\t\t\t}\n\t\t}\n\t\tcout << (res ? \"YES\" : \"NO\") << endl;\n\t}\n\treturn 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\nusing namespace std;\ntypedef long long ll;\n//#include <boost/multiprecision/cpp_int.hpp>\n//typedef boost::multiprecision::cpp_int ll;\ntypedef long double dd;\n#define i_7 (ll)(1E9+7)\n//#define i_7 998244353\n#define i_5 i_7-2\nll mod(ll a){\n    ll c=a%i_7;\n    if(c>=0)return c;\n    return c+i_7;\n}\ntypedef pair<ll,ll> l_l;\nll inf=(ll)1E17;\n\n#define rep(i,l,r) for(ll i=l;i<=r;i++)\n#define pb push_back\nll max(ll a,ll b){if(a<b)return b;else return a;}\nll min(ll a,ll b){if(a>b)return b;else return a;}\nvoid Max(ll &pos,ll val){pos=max(pos,val);}//Max(dp[n],dp[n-1]);\nvoid Min(ll &pos,ll val){pos=min(pos,val);}\nvoid Add(ll &pos,ll val){pos=mod(pos+val);}\ndd EPS=1E-9;\n#define fastio ios::sync_with_stdio(false); cin.tie(0); cout.tie(0);\n///////////////////////////////////////\n\ntypedef string::const_iterator State;\nstring s;\nvoid init(){\n    s.clear();\n}\nbool sig[15];\nbool expr(State &begin);\nbool fact(State &begin){\n    if(*begin=='('){\n        begin++;\n        bool a,b;\n        a=expr(begin);\n        string ope;ope+=*begin;\n        begin++;\n        if(ope[0]=='-')begin++;\n        b=expr(begin);\n        begin++;\n        if(ope[0]=='+'){\n            return a|b;\n        }else if(ope[0]=='*'){\n            return a&b;\n        }else{\n            if(a==false)return true;\n            return b;\n        }\n    }else{\n        bool res;\n        if('a'<=*begin&&*begin<='k'){\n            res=sig[*begin-'a'];\n            begin++;\n            return res;\n        }else{\n            if(*begin=='T')res=true;\n            else res=false;\n            begin++;\n            return res;\n        }\n    }\n}\nbool expr(State &begin){\n    if(*begin=='-'){\n        begin++;\n        bool res=expr(begin);\n        return !res;\n    }else{\n        return fact(begin);\n    }\n}\n\n\nint main(){fastio\n    while(1){\n        cin>>s;\n        if(s[0]=='#')break;\n        string x,y;\n        bool whi=true;\n        rep(i,0,s.size()-1){\n            if(s[i]=='='){\n                whi=false;\n            }else{\n                if(whi)x+=s[i];\n                else y+=s[i];\n            }\n        }\n        bool flag=true;\n        rep(i,0,(1<<11)-1){\n            rep(j,0,10){\n                sig[j]=(i>>j)&1;\n            }\n            State bex=x.begin(),bey=y.begin();\n            bool bx=expr(bex),by=expr(bey);\n            if(bx^by){\n                flag=false;\n                break;\n            }\n        }\n        if(flag)cout<<\"YES\"<<endl;\n        else cout<<\"NO\"<<endl;\n        init();\n    }\n    \n    return 0;\n}\n"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\nusing namespace std;\n\nint pos, var;\nstring s;\nint formula() {\n  pos++;\n  if(s[pos]=='T') return 1;\n  if(s[pos]=='F') return 0;\n  if(isalpha(s[pos])) return var>>(s[pos]-'a')&1;\n  if(s[pos]=='-') return !formula();\n  int f1=formula();\n  pos++; char op=s[pos]; if(op=='-') pos++;\n  int f2=formula(); pos++;\n  if(op=='*') return f1&f2;\n  if(op=='+') return f1|f2;\n  if(op=='-') return f1<=f2;\n}\n\nint main() {\n  while(cin >> s) {\n    if(s==\"#\") break;\n    bool ok=true;\n    for(var=0;var<(1<<11);var++) {\n      pos=-1; int lhs=formula();\n      pos++;\n      if(lhs!=formula()) { ok=false; break; }\n    }\n    cout << (ok ? \"YES\":\"NO\") << endl;\n  }\n  return 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include <algorithm>\n#include <cmath>\n#include <climits>\n#include <cstdio>\n#include <cstdlib>\n#include <cstring>\n#include <fstream>\n#include <iostream>\n#include <list>\n#include <map>\n#include <queue>\n#include <set>\n#include <sstream>\n#include <stack>\n#include <string>\n#include <vector>\n\nusing namespace std;\n\n#define LOG(...) printf(__VA_ARGS__)\n//#define LOG(...)\n#define FOR(i,a,b) for(int i=(a);i<(b);++i)\n#define REP(i,n) for(int i=0;i<(int)(n);++i)\n#define ALL(a) (a).begin(),(a).end()\n#define RALL(a) (a).rbegin(),(a).rend()\n#define EXIST(s,e) ((s).find(e)!=(s).end())\n#define SORT(c) sort((c).begin(),(c).end())\n#define RSORT(c) sort((c).rbegin(),(c).rend())\n#define CLR(a) memset((a), 0 ,sizeof(a))\n\ntypedef long long ll;\ntypedef unsigned long long ull;\ntypedef vector<bool> vb;\ntypedef vector<int> vi;\ntypedef vector<ll> vll;\ntypedef vector<vb> vvb;\ntypedef vector<vi> vvi;\ntypedef vector<vll> vvll;\ntypedef pair<int, int> pii;\ntypedef pair<ll, ll> pll;\n\nconst int V[11] = {\n    1 << 0,\n    1 << 1,\n    1 << 2,\n    1 << 3,\n    1 << 4,\n    1 << 5,\n    1 << 6,\n    1 << 7,\n    1 << 8,\n    1 << 9,\n    1 << 10,\n};\n\nbool parse(string expr, int var) {\n    stack<char> ops;\n    stack<bool> vals;\n    bool update = false;\n    REP(i, expr.length()) {\n        char c = expr[i];\n        switch (c) {\n        case '(':\n            update = false;\n            break;\n        case '-':\n        case '*':\n        case '+':\n            ops.push(c);\n            update = true;\n            break;\n        case '>':\n            ops.pop();\n            ops.push(c);\n            break;\n        case 'a':\n        case 'b':\n        case 'c':\n        case 'd':\n        case 'e':\n        case 'f':\n        case 'g':\n        case 'h':\n        case 'i':\n        case 'j':\n        case 'k':\n        case 'T':\n        case 'F':\n        case ')':\n            bool b;\n            switch (c) {\n            case ')':\n                b = vals.top(); vals.pop();\n                break;\n            case 'T':\n                b = true;\n                break;\n            case 'F':\n                b = false;\n                break;\n            default:\n                b = var & V[c - 'a'];\n            }\n            if (update && !ops.empty()) {\n                bool a;\n                char op = ops.top(); ops.pop();\n                switch (op) {\n                case '-':\n                    vals.push(!b);\n                    break;\n                case '*':\n                    a = vals.top(); vals.pop();\n                    vals.push(a && b);\n                    break;\n                case '+':\n                    a = vals.top(); vals.pop();\n                    vals.push(a || b);\n                    break;\n                case '>':\n                    a = vals.top(); vals.pop();\n                    vals.push(!a || b);\n                    break;\n                }\n            } else {\n                vals.push(b);\n            }\n            break;\n        }\n    }\n    return vals.top();\n}\n\nint main() {\n    string line;\n    while (getline(cin, line), line != \"#\") {\n        int eq = line.find('=');\n        string l(line.begin(), line.begin() + eq);\n        string r(line.begin() + eq + 1, line.end());\n        bool ok = true;\n        REP(var, 2 << 10) {\n            if (parse(l, var) != parse(r, var)) {\n                ok = false;\n                break;\n            }\n        }\n        cout << (ok ? \"YES\" : \"NO\") << endl;\n    }\n}"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\nusing namespace std;\n\ntypedef long long ll;\n#define rep(i,n) for(int (i)=0;(i)<(int)(n);++(i))\n#define each(itr,c) for(__typeof(c.begin()) itr=c.begin(); itr!=c.end(); ++itr)\n#define all(x) (x).begin(),(x).end()\n#define mp make_pair\n#define pb push_back\n#define fi first\n#define se second\n\n//arrow\ninline int AR(int x, int y)\n{\n    if(x==1 && y==0) return 0;\n    return 1;\n}\n\nint formula(string s)\n{\n    if(s.size()==1) return s[0]-'0';\n    if(s[0]=='-') return !formula(s.substr(1));\n\n    //bracket\n    string t=s.substr(1,s.size()-2);\n\n    int idx=0;\n    int br=0;\n    while(idx<t.size())\n    {\n        if(t[idx]=='(') ++br;\n        if(t[idx]==')') --br;\n\n        if(br==0)\n        {\n            if(t[idx]=='*')\n            {\n                string x=t.substr(0,idx);\n                string y=t.substr(idx+1);\n                return formula(x)&formula(y);\n            }\n            else if(t[idx]=='+')\n            {\n                string x=t.substr(0,idx);\n                string y=t.substr(idx+1);\n                return formula(x)|formula(y);\n            }\n            else if(idx+1<t.size() && t[idx]=='-' && t[idx+1]=='>')\n            {\n                string x=t.substr(0,idx);\n                string y=t.substr(idx+2);\n                return AR(formula(x),formula(y));\n            }\n        }\n\n        ++idx;\n    }\n\n    return 0;\n}\n\nint main()\n{\n    string eq;\n    while(cin >>eq,(eq!=\"#\"))\n    {\n        //variables\n        set<char> vars;\n        rep(i,eq.size())\n        {\n            if('a'<=eq[i] && eq[i]<='k')\n            {\n                if(vars.find(eq[i])==vars.end()) vars.insert(eq[i]);\n            }\n        }\n\n        //cut equation to 2 formulae\n        int e=0;\n        while(e<eq.size() && eq[e]!='=') ++e;\n        string x=eq.substr(0,e), y=eq.substr(e+1);\n\n        //translate \"T\"(1) and \"F\"(0)\n        rep(i,x.size())\n        {\n            if(x[i]=='T') x[i]='1';\n            if(x[i]=='F') x[i]='0';\n        }\n        rep(i,y.size())\n        {\n            if(y[i]=='T') y[i]='1';\n            if(y[i]=='F') y[i]='0';\n        }\n\n        int n=vars.size();\n        bool ok=true;\n        rep(mask,1<<n)\n        {\n            //image\n            map<char,int> im;\n\n            int ct=0;\n            for(const auto &x : vars)\n            {\n                im[x]=(mask>>ct&1);\n                ++ct;\n            }\n\n            //translation\n            string nx=x,ny=y;\n            rep(i,nx.size())\n            {\n                if('a'<=nx[i] && nx[i]<='k') nx[i]=im[nx[i]]+'0';\n            }\n            rep(i,ny.size())\n            {\n                if('a'<=ny[i] && ny[i]<='k') ny[i]=im[ny[i]]+'0';\n            }\n\n            if(formula(nx)!=formula(ny))\n            {\n                ok=false;\n                break;\n            }\n        }\n\n        string ans=\"NO\";\n        if(ok) ans=\"YES\";\n        cout << ans << endl;\n    }\n    return 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include <iostream>\n#include <stdio.h>\n#include <algorithm>\n#include <vector>\n#include <queue>\n#include <numeric>\n#include <string>\n#include <string.h>\n#include <map>\n#include <set>\n#include <functional>\n#include <complex>\n#include <stack>\n#include <tuple>\n\n#define ll long long int\n\nusing namespace std;\n\nconst int INF = (1<<30) - 1;\n\nbool formula(string str, int &vals){\n    char c = str[0];\n    \n    if(c == 'T')\n        return true;\n    else if(c == 'F')\n        return false;\n    \n    if('a'<=c && c<='k')\n        return vals<<(c-'a')&1;\n    \n    //substr???string &?????¨NG?\n    if(c == '-')\n        return !formula(str.substr(1, str.size()-1), vals);\n\n    //c == '('\n    int count = 0;\n    for(int i=1; i<str.size(); i++){\n        char c = str[i];\n        \n        if(c == '(')\n            count++;\n        if(c == ')')\n            count--;\n        if(count == 0){\n            if(c == '*'){\n                string left = str.substr(1, i-1);\n                string right = str.substr(i+1, str.size()-i-2);\n                return formula(left, vals) & formula(right, vals);\n            }\n            if(c == '+'){\n                string left = str.substr(1, i-1);\n                string right = str.substr(i+1, str.size()-i-2);\n                return formula(left, vals) | formula(right, vals);\n            }\n            if(str[i] == '-' && str[i+1] == '>'){\n                string left = str.substr(1, i-1);\n                string right = str.substr(i+2, str.size()-i-3);\n                return !(formula(left, vals)) | formula(right, vals);\n            }\n        }\n    }\n    //No Implement\n    return true;\n}\n\nint main(){\n    ios::sync_with_stdio(false);\n    cin.tie(0);\n    \n    string equation;\n    while(cin>>equation, equation!=\"#\"){\n        int s = equation.find(\"=\");\n        string left = equation.substr(0, s);\n        string right = equation.substr(s+1, equation.size()-s-1);\n        \n        bool is_identity = true;\n        for(int i=0; i<1<<11; i++){\n            is_identity &= formula(left, i)==formula(right, i);\n        }\n            \n        cout << (is_identity ? \"YES\" : \"NO\") << endl;\n    }\n    return 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include<bits/stdc++.h>\nint i,v;std::string s;\nint P() {\n  i++;\n  if(s[i]=='T')return 1;\n  if(s[i]=='F')return 0;\n  if(isalpha(s[i]))return v>>(s[i]-'a')&1;\n  if(s[i]=='-')return !P();\n  int l=P();\n  i++;int o=s[i];if(o=='-')i++;\n  int r=P();i++;\n  if(o=='*')return l&r;\n  if(o=='+')return l|r;\n  if(o=='-')return l<=r;\n}\nint main() {\n  while(std::cin>>s){\n    if(s==\"#\")break;\n    int k=1;\n    for(v=0;v<(1<<11);v++) {\n      i=-1;int l=P();\n      i++;\n      if(l!=P()){k=0;break;}\n    }\n    std::cout<<(k?\"YES\\n\":\"NO\\n\");\n  }\n  return 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include<iostream>\n#include<sstream>\n#include<vector>\n#include<map>\n#include<queue>\n#include<set>\n#include<algorithm>\n#include<complex>\n#include<cstdio>\n#include<cstdlib>\n#include<cstring>\n#include<cassert>\n\nusing namespace std;\n\n#define rep(i, n) for(int i = 0; i < (int)n; i++)\n#define mp make_pair\n#define pb push_back\n#define all(c) (c).begin(), (c).end()\n#define each(i, c) for(__typeof(c.begin()) i = c.begin(); i != c.end(); i++)\n#define dbg(x) cerr<<__LINE__<<\": \"<<#x<<\" = \"<<(x)<<endl\n\ntypedef pair<int, int> pi;\nstring s, t;\nint p, val, iter;\n\nint parse(){\n\tif(s[p] == '-'){\n\t\tp++;\n\t\treturn !parse();\n\t}\n\tif(s[p] == 'T' || s[p] == 'F'){\n\t\treturn s[p++] == 'T';\n\t}\n\tif(isalpha(s[p])){\n\t\treturn val >> (s[p++] - 'a') & 1;\n\t}\n\tassert(s[p] == '(');\n\tp++;\n\tint a = parse();\n\tchar c = s[p++];\n\tif(c == '-') p++;\n\tint b = parse();\n\tp++;\n\tif(c == '*') return a && b;\n\tif(c == '+') return a || b;\n\treturn (!a) || b;\n}\n\n\nint main(){\n\tstring in;\n\twhile(getline(cin, in), in != \"#\"){\n\t\tint pos = in.find(\"=\");\n\t\ts = in.substr(0, pos);\n\t\tt = in.substr(pos + 1);\n\t\tp = 0;\n\t\t\n\t\tbool ok = 1;\n\t\trep(i, 1 << 12){\n\t\t\tval = i;\n\t\t\tp = 0;\n\t\t\tint a = parse();\n\t\t\tswap(s, t);\n\t\t\tp = 0;\n\t\t\tint b = parse();\n\t\t\tswap(s, t);\n\t\t\t\n\t\t\tif(a != b){\n\t\t\t\tok = 0;\n\t\t\t\tbreak;\n\t\t\t}\n\t\t}\n\t\tcout << (ok ? \"YES\" : \"NO\") << endl;\n\t}\n\treturn 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include <iostream>\n#include <iomanip>\n#include <sstream>\n#include <cstdio>\n#include <string>\n#include <vector>\n#include <algorithm>\n#include <complex>\n#include <cstring>\n#include <cstdlib>\n#include <cmath>\n#include <cassert>\n#include <climits>\n#include <queue>\n#include <set>\n#include <map>\n#include <valarray>\n#include <bitset>\n#include <stack>\nusing namespace std;\n\n#define REP(i,n) for(int i=0;i<(int)n;++i)\n#define FOR(i,c) for(__typeof((c).begin())i=(c).begin();i!=(c).end();++i)\n#define ALL(c) (c).begin(), (c).end()\ntypedef long long ll;\ntypedef pair<int,int> pii;\nconst int INF = 1<<29;\nconst double PI = acos(-1);\nconst double EPS = 1e-8;\n\nbool x[11];\n\nbool fm(string &s, int &idx) {\n  if (s[idx] == '(') {\n    idx++;\n    bool f1 = fm(s,idx);\n    char c = s[idx++];\n    if (c == '-') idx++;\n    bool f2 = fm(s,idx);\n    assert(s[idx] == ')');\n    idx++;\n    if (c == '*') return f1 & f2;\n    else if (c == '+') return f1 | f2;\n    else if (c == '-') return !(f1 & (!f2));\n  } else if (s[idx] == '-') {\n    idx++;\n    bool f1 = fm(s,idx);\n    return !f1;\n  } else if (s[idx] == 'T') {\n    idx++;\n    return 1;\n  } else if (s[idx] == 'F') {\n    idx++;\n    return 0;\n  } else {\n    bool f = x[s[idx++]-'a'];\n    return f;\n  }\n}\n\nbool eq(string &s, int &idx) {\n  bool f1 = fm(s,idx);\n  assert(s[idx++] == '=');\n  bool f2 = fm(s,idx);\n  return f1 == f2;\n}\n\nint main() {\n  string s;\n  while(cin>>s,s!=\"#\") {\n    bool f = 0;\n    REP(S,1<<11) {\n      REP(i,11) x[i] = (S>>i&1);\n      int idx = 0;\n      if (!eq(s,idx)) {\n        f = 1;\n        break;\n      }\n    }\n    if (f) cout << \"NO\" << endl;\n    else cout << \"YES\" << endl;\n  }\n}"
  },
  {
    "language": "C++",
    "code": "#include <iostream>\n#include <string>\n\nusing namespace std;\n\nstruct Scanner {\n    string s;\n    int pos;\n    Scanner(string s) {\n        this->s = s;\n        pos = 0;\n    }\n\n    char head() {\n        if(pos<s.size())\n            return s[pos];\n        else\n            return '\\0';\n    }\n\n    void next() {\n        ++pos;\n    }\n};\n\nbool formula(Scanner& scanner, int in) {\n    char h = scanner.head();\n    scanner.next();\n    switch(h) {\n    case 'T':\n        //cout << \"T\" << endl;\n        return true;\n    case 'F':\n        //cout << \"F\" << endl;\n        return false;\n    case 'a':\n    case 'b':\n    case 'c':\n    case 'd':\n    case 'e':\n    case 'f':\n    case 'g':\n    case 'h':\n    case 'i':\n    case 'j':\n    case 'k':\n        //cout << h << \"=\" << ((in & (1<<(h-'a'))) != 0) << endl;\n        return (in & (1<<(h-'a'))) != 0;\n    case '-':\n    {\n        bool a = formula(scanner, in);\n        //cout << \"Not \" << a << endl;\n        return !a;\n    }\n    case '(':\n    {\n\n        bool a = formula(scanner, in);\n        char op = scanner.head();\n        scanner.next();\n        if(op=='-') scanner.next();\n        bool b = formula(scanner, in);\n        scanner.next(); // for )\n        switch(op) {\n        case '*':\n            //cout << a << \"*\" << b << endl;\n            return a && b;\n        case '+':\n            //cout << a << \"+\" << b << endl;\n            return a || b;\n        case '-':\n            //cout << a << \"->\" << b << endl;\n            return !a || b;\n        }\n    }\n    }\n}\n\nbool check(const string& eq, int in) {\n    Scanner scanner(eq);\n    bool a = formula(scanner, in);\n    scanner.next();\n    bool b = formula(scanner, in);\n    return a==b;\n}\n\nint main() {\n    while(1) {\n        string in;\n        cin >> in;\n        if(in==\"#\") break;\n\n        bool f = true;\n        for(int i=0;i<(1<<11);++i) {\n            f = f && check(in, i);\n        }\n        if(f) {\n            cout << \"YES\" << endl;\n        } else {\n            cout << \"NO\" << endl;\n        }\n    }\n}"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\n\nusing namespace std;\nusing ll=long long;\ntemplate <class T> using vec=vector<T>;\ntemplate <class T> using vvec=vec<vec<T>>;\n#define REP(i,n) for(int (i)=0;(i)<(n);(i)++)\n#define en \"\\n\"\n\nusing result=pair<bool,int>;\n#define value first\n#define p second\n\nll bit=0;\n\nbool equation(const string &s, int p);\nresult formula(const string &s, int p);\nresult term(const string &s, int p);\n\nbool equation(const string& s,int p){\n    result r1=formula(s,p);\n    p=r1.p+1;//skip \"=\"\n    result r2=formula(s,p);\n    return r1.value==r2.value;\n}\n\n\nresult formula(const string &s,int p){\n    if(s[p]=='('){\n        p++;//skip '('\n        result r1=formula(s,p);\n        p=r1.p;\n        ll op=0;\n        if(s[p]=='*'){\n            op=0;\n            p++;\n        }else if(s[p]=='+'){\n            op=1;\n            p++;\n        }else{\n            op=2;\n            p+=2;\n        }\n        result r2=formula(s,p);\n        p=r2.p+1;//skip ')'\n        bool ans=false;\n        if(op==0) ans = r1.value and r2.value;\n        else if(op==1) ans= r1.value or r2.value;\n        else ans = !r1.value or r2.value;\n\n        return {ans,p};\n    }else if(s[p]=='-'){\n        result r = formula(s,p+1);\n        r.value=!r.value;\n        return r;\n    }else{\n        return term(s,p);\n    }\n}\n\nresult term(const string &s, int p){\n    //cout<<\"t:\"<<p<<en;\n    if(s[p]=='T') return {true,p+1};\n    else if(s[p]=='F') return {false,p+1};\n    else{\n        int i=s[p]-'a';\n        if((bit>>i)&1) return {true,p+1};\n        else return {false,p+1};\n    }\n}\n\n\nvoid solve(string s){\n    REP(i,1<<11){\n        bit=i;\n        if(equation(s,0)==false) {\n            //cout<<bitset<11>(bit) <<en;\n            cout<<\"NO\"<<en;\n            return;\n        }\n    }\n    cout<<\"YES\"<<en;\n}\n\nint main(void){\n    string s;\n    while(cin>>s){\n        if(s==\"#\") break;\n        solve(s);\n    }\n    return 0;\n}\n"
  },
  {
    "language": "C++",
    "code": "#include <iostream>\n#include <algorithm>\n#include <string>\n#include <vector>\nusing namespace std;\n\nconst int INF = 1e+8;\n\n// 変数 'a' - 'k' を value に置き換え\nvoid change(string& s, char x, char value){\n\tfor(int i=0 ; i < s.size() ; i++ ){\n\t\tif( s[i] == x ) s[i] = value;\n\t}\n}\n\n// 式の評価\nint eval(const string& s, int& k){\n\tif( s[k] == 'T' ){\n\t\tk++;\n\t\treturn 1;\n\t}else if( s[k] == 'F' ){\n\t\tk++;\n\t\treturn 0;\n\t}else if( s[k] == '-' ){\n\t\tk++;\n\t\tint r = eval(s, k);\n\t\treturn (1 - r);\n\t}else if( s[k] == '(' ){\n\t\t++k;\n\t\tint a = eval(s, k);\n\t\tchar op = s[k++];\n\t\tint b = eval(s, k);\n\t\t++k;\n\t\tint r;\n\t\tif( op == '+' ){\n\t\t\tr = max(a, b);\n\t\t}else if( op == '*' ){\n\t\t\tr = (a == 1 && b == 1)? 1 : 0 ;\n\t\t}else if( op == '>' ){\n\t\t\tr = (a == 1 && b == 0)? 0 : 1 ;\n\t\t}\n\t\treturn r;\n\t}\n}\n\nint main(){\n\tstring str;\n\twhile( cin >> str ){\n\t\tif( str == \"#\" ) break;\n\t\t\n\t\t// \"->\" を \">\" に置き換えておく\n\t\tstring s;\n\t\tfor(int i=0 ; i < str.size() ; i++ ){\n\t\t\tif( i+1 < str.size() && str[i] == '-' && str[i+1] == '>' ){\n\t\t\t\ts.push_back( '>' );\n\t\t\t\ti++;\n\t\t\t}else{\n\t\t\t\ts.push_back( str[i] );\n\t\t\t}\n\t\t}\n\t\t\n\t\t// '=' の左側を ex1, 右側を ex2 とする\n\t\tstring ex1, ex2;\n\t\tbool flag = false;\n\t\tfor(int i=0 ; i < s.size() ; i++ ){\n\t\t\tif( s[i] == '=' ){\n\t\t\t\tflag = true;\n\t\t\t}else if( flag ){\n\t\t\t\tex2.push_back( s[i] );\n\t\t\t}else{\n\t\t\t\tex1.push_back( s[i] );\n\t\t\t}\n\t\t}\n\t\t\n\t\t// 登場する変数('a' - 'k')をチェック\n\t\tint f[256] = {0};\n\t\tfor(int i= 0 ; i < s.size() ; i++ ){\n\t\t\tf[ s[i] ] = 1;\n\t\t}\n\t\tvector<char> vc;\n\t\tfor(char c = 'a' ; c <= 'k' ; c++ ){\n\t\t\tif( f[c] ) vc.push_back( c );\n\t\t}\n\t\t// N := 登場する変数の種類.\n\t\tint N = vc.size();\n\t\t\n\t\t// 変数の置き換えを 2^N 通り試し すべての式の評価で右辺と左辺が等しいか調べる.\n\t\tbool ans = true;\n\t\tfor(int bits = 0 ; bits < (1<<N) ; bits++ ){\n\t\t\tstring ex1_ = ex1;\n\t\t\tstring ex2_ = ex2;\n\t\t\t// 変数を \"T\" or \"F\" に置き換えておく\n\t\t\tfor(int i=0 ; i < N ; i++ ){\n\t\t\t\t// i 番目の文字を'T' か 'F'にしておく\n\t\t\t\tif( bits & (1<<i) ){\n\t\t\t\t\tchange( ex1_ , vc[i] , 'T' );\n\t\t\t\t\tchange( ex2_ , vc[i] , 'T' );\n\t\t\t\t}else{\n\t\t\t\t\tchange( ex1_ , vc[i] , 'F' );\n\t\t\t\t\tchange( ex2_ , vc[i] , 'F' );\n\t\t\t\t}\n\t\t\t}\n\t\t\t// 式の評価\n\t\t\tint t=0;\n\t\t\tint a = eval(ex1_, t);\n\t\t\tt = 0;\n\t\t\tint b = eval(ex2_, t);\n\t\t\tif( a != b ){\n\t\t\t\tans = false;\n\t\t\t\tbreak;\n\t\t\t}\n\t\t}\n\t\t// 出力 \n\t\tif( ans ){\n\t\t\tcout << \"YES\" << endl;\n\t\t}else{\n\t\t\tcout << \"NO\" << endl;\n\t\t}\n\t}\n}"
  },
  {
    "language": "C++",
    "code": "////////////////////////////////////////\n///  tu3 pro-con template            ///\n////////////////////////////////////////\n#include <cassert>\n#include <cstdio>\n#include <cstring>\n#include <cmath>\n#include <iostream>\n#include <sstream>\n#include <algorithm>\n#include <numeric>\n#include <functional>\n#include <vector>\n#include <queue>\n#include <string>\n#include <complex>\n#include <stack>\n#include <set>\n#include <map>\n#include <list>\n#include <unordered_map>\n#include <unordered_set>\n#include <bitset>\n#include <regex>\nusing namespace std;\n\n//// MACRO ////\n#define countof(a) (sizeof(a)/sizeof(a[0]))\n\n#define REP(i,n) for (int i = 0; i < (n); i++)\n#define RREP(i,n) for (int i = (n)-1; i >= 0; i--)\n#define FOR(i,s,n) for (int i = (s); i < (n); i++)\n#define RFOR(i,s,n) for (int i = (n)-1; i >= (s); i--)\n#define pos(c,i) c.being() + (i)\n#define allof(c) c.begin(), c.end()\n#define aallof(a) a, countof(a)\n#define partof(c,i,n) c.begin() + (i), c.begin() + (i) + (n)\n#define apartof(a,i,n) a + (i), a + (i) + (n)\n#define long long long\n\n#define EPS 1e-9\n#define INF (1L << 30)\n#define LINF (1LL << 60)\n\n#define PREDICATE(t,a,exp) [&](const t & a) -> bool { return exp; }\n#define COMPARISON_T(t) bool(*)(const t &, const t &)\n#define COMPARISON(t,a,b,exp) [&](const t & a, const t & b) -> bool { return exp; }\n#define CONVERTER(TSrc,t,TDest,exp) [&](const TSrc &t)->TDest { return exp; }\n\n//// i/o helper ////\n\nstruct _Reader { template <class T> _Reader operator ,(T &rhs) { cin >> rhs; return *this; } };\nstruct _Writer { bool f; _Writer() : f(false) { } template <class T> _Writer operator ,(const T &rhs) { cout << (f ? \" \" : \"\") << rhs; f = true; return *this; } };\n#define READ(t,...) t __VA_ARGS__; _Reader(), __VA_ARGS__\n#define WRITE(...) _Writer(), __VA_ARGS__; cout << endl\ninline int sign(double x) { return (abs(x) < EPS ? 0 : x > 0 ? 1 : -1); }\n\ntemplate <class T> struct vevector : public vector<vector<T>> { vevector(int n = 0, int m = 0, const T &initial = T()) : vector<vector<T>>(n, vector<T>(m, initial)) { } };\ntemplate <class T> struct vevevector : public vector<vevector<T>> { vevevector(int n = 0, int m = 0, int l = 0, const T &initial = T()) : vector<vevector<T>>(n, vevector<T>(m, l, initial)) { } };\ntemplate <class T> struct vevevevector : public vector<vevevector<T>> { vevevevector(int n = 0, int m = 0, int l = 0, int k = 0, const T &initial = T()) : vector<vevevector<T>>(n, vevevector<T>(m, l, k, initial)) { } };\ntemplate <class T> T read() { T t; cin >> t; return t; }\ntemplate <class T> vector<T> read(int n) { vector<T> v; REP(i, n) { v.push_back(read<T>()); } return v; }\ntemplate <class T> vevector<T> read(int n, int m) { vevector<T> v; REP(i, n) v.push_back(read<T>(m)); return v; }\ntemplate <class T> vector<T> readjag() { return read<T>(read<int>()); }\ntemplate <class T> vevector<T> readjag(int n) { vevector<T> v; REP(i, n) v.push_back(readjag<T>()); return v; }\n\ntemplate <class T1, class T2> inline istream & operator >> (istream & in, pair<T1, T2> &p) { in >> p.first >> p.second; return in; }\ntemplate <class T1, class T2> inline ostream & operator << (ostream &out, pair<T1, T2> &p) { out << p.first << p.second; return out; }\ntemplate <class T> inline ostream & operator << (ostream &out, const vector<T> &v)\n{\n\tostringstream ss;\n\tfor (auto x : v) ss << x << ' ';\n\tauto s = ss.str();\n\tout << s.substr(0, s.length() - 1);\n\treturn out;\n}\n\n\n//// algorithm ////\n\n// 文字列の置換\nvoid inplaceReplace(string &target, const string &from, const string &to, bool global = false)\n{\n\tdo\n\t{\n\t\tstring::size_type pos = target.find(from);\n\t\tif (pos == target.npos) { break; }\n\t\ttarget.replace(pos, from.length(), to);\n\t} while (true);\n}\n\n// 文字列の分割\nvector<string> split(const string &str, const string &s, bool removeEmpty = false)\n{\n\tvector<string> ret;\n\tsize_t p = 0, sl = s.size();\n\twhile (true)\n\t{\n\t\tsize_t q = str.find(s, p);\n\t\tif (q == str.npos) break;\n\t\tret.push_back(str.substr(p, q - p));\n\t\tp = q + sl;\n\t}\n\tret.push_back(str.substr(p));\n\tif (removeEmpty) ret.erase(remove(allof(ret), string()), ret.end());\n\treturn ret;\n}\n\n//// start up ////\nvoid solve();\nint main()\n{\n\tsolve();\n\treturn 0;\n}\n\n////////////////////\n/// template end ///\n////////////////////\n\nbool eval(string form, int table, map<string, bool > &memo)\n{\n\tinplaceReplace(form, \"a\", string(1, table >> 0 & 1 ? 'T' : 'F'), true);\n\tinplaceReplace(form, \"b\", string(1, table >> 1 & 1 ? 'T' : 'F'), true);\n\tinplaceReplace(form, \"c\", string(1, table >> 2 & 1 ? 'T' : 'F'), true);\n\tinplaceReplace(form, \"d\", string(1, table >> 3 & 1 ? 'T' : 'F'), true);\n\tinplaceReplace(form, \"e\", string(1, table >> 4 & 1 ? 'T' : 'F'), true);\n\tinplaceReplace(form, \"f\", string(1, table >> 5 & 1 ? 'T' : 'F'), true);\n\tinplaceReplace(form, \"g\", string(1, table >> 6 & 1 ? 'T' : 'F'), true);\n\tinplaceReplace(form, \"h\", string(1, table >> 7 & 1 ? 'T' : 'F'), true);\n\tinplaceReplace(form, \"i\", string(1, table >> 8 & 1 ? 'T' : 'F'), true);\n\tinplaceReplace(form, \"j\", string(1, table >> 9 & 1 ? 'T' : 'F'), true);\n\tinplaceReplace(form, \"k\", string(1, table >> 10 & 1 ? 'T' : 'F'), true);\n\n\tif (memo.count(form)) return memo[form];\n\tstring org = form;\n\twhile (form.size() > 1)\n\t{\n\t\tinplaceReplace(form, \"-T\", \"F\", true);\n\t\tinplaceReplace(form, \"-F\", \"T\", true);\n\t\t\n\t\tinplaceReplace(form, \"(T*T)\", \"T\", true);\n\t\tinplaceReplace(form, \"(T*F)\", \"F\", true);\n\t\tinplaceReplace(form, \"(F*T)\", \"F\", true);\n\t\tinplaceReplace(form, \"(F*F)\", \"F\", true);\n\n\t\tinplaceReplace(form, \"(T+T)\", \"T\", true);\n\t\tinplaceReplace(form, \"(T+F)\", \"T\", true);\n\t\tinplaceReplace(form, \"(F+T)\", \"T\", true);\n\t\tinplaceReplace(form, \"(F+F)\", \"F\", true);\n\n\t\tinplaceReplace(form, \"(T->T)\", \"T\", true);\n\t\tinplaceReplace(form, \"(T->F)\", \"F\", true);\n\t\tinplaceReplace(form, \"(F->T)\", \"T\", true);\n\t\tinplaceReplace(form, \"(F->F)\", \"T\", true);\n\t}\n\n\treturn memo[org] = (form == \"T\");\n}\n\n\nvoid solve()\n{\n\tint testcases = INF;\n\tREP(testcase, testcases)\n\t{\n\t\tREAD(string, eq);\n\t\tif (eq == \"#\") { break; }\n\n\t\tauto forms = split(eq, \"=\");\n\t\tmap<string, bool> memo;\n\t\tbool error = false;\n\t\tREP(i, 1 << 11)\n\t\t{\n\t\t\tif (eval(forms[0], i, memo) != eval(forms[1], i, memo))\n\t\t\t{\n\t\t\t\terror = true;\n\t\t\t\tbreak;\n\t\t\t}\n\t\t}\n\t\tWRITE( error ? \"NO\" : \"YES\");\n\t}\n}"
  },
  {
    "language": "C++",
    "code": "#include <iostream>\n#include <set>\n#include <string>\n#include <vector>\n#include <algorithm>\n\nusing namespace std;\n#define loop(i,a,b) for(int i=(a); i<int(b); i++)\n#define rep(i,b) loop(i,0,b)\n#define iter(it,c) for(auto it=c.begin(); it!=c.end(); ++it)\n#define all(c) (c).begin(), (c).end()\n\ntypedef vector<string> vs;\ntypedef unsigned uint;\n\nstring s;\nint p;\n\n#define cur s[p]\n\nbool equ();\nbool formula();\n\nbool equ(){\n    bool l=formula();\n    p++; // =\n    bool r=formula();\n    // cout << l << \" \" << r << endl;\n    return l==r;\n}\n\nbool formula(){\n    bool res;\n    if(cur=='T'){\n        p++; // T\n        res = true;\n    }\n    else if(cur=='F'){\n        p++; // F\n        res = false;\n    }\n    else if(cur=='-'){\n        p++; // -\n        res = !formula();\n    } else {\n        p++; // (\n        bool l=formula();\n\n        char op=cur;\n\n        p++; // +,*,-\n        if(op=='-') p++; // >\n\n        bool r = formula();\n\n        if(op=='*') res = l&r;\n        if(op=='+') res = l|r;\n        if(op=='-') res = (!l)|r;\n\n        p++; // )\n    }\n    return res;\n}\n\ninline bool solve(vs const& v){\n    bool res = true;\n    rep(i,v.size()){\n        s=v[i];\n        p=0;\n        // cout << s << endl;\n        if(!equ()){\n            res = false;\n            break;\n        }\n    }\n    return res;\n}\n\nint main(){\n    string s;\n    while(cin>>s && s!=\"#\"){\n        vs ss(1<<11);\n        rep(i,1<<11){\n            string t=s;\n            rep(j,t.size()){\n                if(t[j]=='T' || t[j]=='F') continue;\n                if(isalpha(t[j])) t[j] = \"TF\"[(i>>(t[j]-'a')&1)];\n            }\n            ss[i] = t;\n        }\n        sort(all(ss));\n        ss.erase(unique(all(ss)),ss.end());\n        bool id = solve(ss);\n        if(id) cout << \"YES\";\n        else cout << \"NO\";\n        cout << endl;\n    }\n}"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\nusing namespace std;\n#define rep(i,a,b) for(int i=a;i<b;i++)\n\nbool parse(string a, int& i)\n{\n\tswitch (a[i])\n\t{\n\tcase 'T': i++; return true;\n\tcase 'F': i++; return false;\n\tcase '-': i++; return !parse(a, i);\n\t}\n\n\ti++;\n\tbool aa = parse(a, i);\n\n\tint flag = -1;\n\tswitch (a[i])\n\t{\n\tcase '*': i++; flag = 0; break;\n\tcase '+': i++; flag = 1; break;\n\tcase '@': i++; flag = 2; break;\n\t}\n\n\tbool bb = parse(a, i);\n\ti++;\n\n\tswitch (flag)\n\t{\n\tcase 0: return aa && bb;\n\tcase 1: return aa || bb;\n\t}\n\n\tif (aa && !bb) return false;\n\treturn true;\n}\n\nbool eval(string a, string b)\n{\n\tint i = 0;\n\tbool aa = parse(a, i);\n\ti = 0;\n\tbool bb = parse(b, i);\n\n\tif (aa == bb) return true;\n\treturn false;\n}\n\nstring replace(string src, string from, string to)\n{\n\tstring::size_type Pos(src.find(from));\n\twhile (Pos != string::npos)\n\t{\n\t\tsrc.replace(Pos, from.length(), to);\n\t\tPos = src.find(from, Pos + to.length());\n\t}\n\treturn src;\n}\n\nint main()\n{\n\twhile (1)\n\t{\n\t\tstring s; cin >> s;\n\t\tif (s[0] == '#') return 0;\n\n\t\ts = replace(s, \"->\", \"@\");\n\n\t\tint equ = s.find(\"=\");\n\t\tstring left = s.substr(0, equ);\n\t\tstring right = s.substr(equ+1);\n\n\t\tbool ans = true;\n\t\trep(i, 0, 1 << 11)\n\t\t{\n\t\t\tstring a = left;\n\t\t\tstring b = right;\n\t\t\tstring c = \"a\";\n\t\t\trep(j, 0, 11)\n\t\t\t{\n\t\t\t\tc[0] = 'a' + j;\n\t\t\t\tif (i & (1 << j))\n\t\t\t\t{\n\t\t\t\t\ta = replace(a, c, \"T\");\n\t\t\t\t\tb = replace(b, c, \"T\");\n\t\t\t\t}\n\t\t\t\telse\n\t\t\t\t{\n\t\t\t\t\ta = replace(a, c, \"F\");\n\t\t\t\t\tb = replace(b, c, \"F\");\n\t\t\t\t}\n\t\t\t}\n\n\t\t\tif (!eval(a, b)) ans = false;\n\t\t}\n\n\t\tif (ans)\n\t\t\tcout << \"YES\" << endl;\n\t\telse\n\t\t\tcout << \"NO\" << endl;\n\t}\n}"
  },
  {
    "language": "C++",
    "code": "#include <algorithm>\n#include <cmath>\n#include <climits>\n#include <cstdio>\n#include <cstdlib>\n#include <cstring>\n#include <fstream>\n#include <iostream>\n#include <list>\n#include <map>\n#include <queue>\n#include <set>\n#include <sstream>\n#include <stack>\n#include <string>\n#include <vector>\n#include <cassert>\n#include <functional>\n\nusing namespace std;\n\n#define LOG(...) printf(__VA_ARGS__)\n//#define LOG(...)\n#define FOR(i,a,b) for(int i=(int)(a);i<(int)(b);++i)\n#define REP(i,n) for(int i=0;i<(int)(n);++i)\n#define ALL(a) (a).begin(),(a).end()\n#define RALL(a) (a).rbegin(),(a).rend()\n#define EXIST(s,e) ((s).find(e)!=(s).end())\n#define SORT(c) sort((c).begin(),(c).end())\n#define RSORT(c) sort((c).rbegin(),(c).rend())\n#define CLR(a) memset((a), 0 ,sizeof(a))\n\ntypedef long long ll;\ntypedef unsigned long long ull;\ntypedef vector<bool> vb;\ntypedef vector<int> vi;\ntypedef vector<ll> vll;\ntypedef vector<vb> vvb;\ntypedef vector<vi> vvi;\ntypedef vector<vll> vvll;\ntypedef pair<int, int> pii;\ntypedef pair<ll, ll> pll;\n\nconst int dx[] = { -1, 0, 1, 0 }; const int dy[] = { 0, 1, 0, -1 };\n\nstruct UnionFind {\n\tvector<int> v;\n\tUnionFind(int n) : v(n) { for (int i = 0; i < n; i++) v[i] = i; }\n\tint  find(int x) { return v[x] == x ? x : v[x] = find(v[x]); }\n\tvoid unite(int x, int y) { v[find(x)] = find(y); }\n};\nbool cal(string s, int &idx) {\n\tbool res = true;\n\tbool sub = false;\n\twhile (idx < (int)s.length()) {\n\t\tif (s[idx] == '(') {\n\t\t\tidx++;\n\t\t\tif (sub)\n\t\t\t\treturn !cal(s, idx);\n\t\t\telse\n\t\t\t\treturn cal(s, idx);\n\t\t}\n\t\tif (s[idx] == '-') {\n\t\t\tsub = !sub;\n\t\t\tidx++;\n\t\t}\n\t\tif (s[idx] == 'T' || s[idx] == 'F') {\n\t\t\tbool st1 = ((s[idx] == 'T' && !sub) || (s[idx] == 'F' && sub));\n\t\t\tidx++;\n\t\t\tsub = false;\n\t\t\tif (idx >= (int)s.length())\n\t\t\t\treturn st1;\n\t\t\tint calc;\n\t\t\tif (s[idx] == '*')\n\t\t\t\tcalc = 0;\n\t\t\tif (s[idx] == '+')\n\t\t\t\tcalc = 1;\n\t\t\tif (s[idx] == '>')\n\t\t\t\tcalc = 2;\n\t\t\tidx++;\n\t\t\tif (s[idx] == '-') {\n\t\t\t\tsub = !sub;\n\t\t\t\tidx++;\n\t\t\t}\n\t\t\tbool st2;\n\t\t\tif (s[idx] == 'T' || s[idx] == 'F') {\n\t\t\t\tst2 = ((s[idx] == 'T' && !sub) || (s[idx] == 'F' && sub));\n\t\t\t}\n\t\t\telse {\n\t\t\t\tidx++;\n\t\t\t\tst2 = cal(s, idx);\n\t\t\t}\n\t\t\tif (calc == 0)\n\t\t\t\tres = (st1&&st2);\n\t\t\tif (calc == 1)\n\t\t\t\tres = (st1 || st2);\n\t\t\tif (calc == 2)\n\t\t\t\tres = !(st1 && !st2);\n\t\t\tidx++;\n\t\t\treturn res;\n\t\t}\n\t\tif (s[idx] == ')') {\n\t\t\tidx++;\n\t\t\treturn res;\n\t\t}\n\t}\n\treturn res;\n}\n\nint main() {\n\tstring s;\n\twhile (cin >> s, s != \"#\") {\n\t\tstring ans = \"YES\";\n\t\tauto pos = s.find(\"->\");\n\t\twhile (pos != string::npos) {\n\t\t\ts.replace(pos, 2, \">\");\n\t\t\tpos = s.find(\"->\", pos + 1);\n\t\t}\n\t\tpos = s.find(\"--\");\n\t\twhile (pos != string::npos) {\n\t\t\ts.replace(pos, 2, \"\");\n\t\t\tpos = s.find(\"--\", pos + 1);\n\t\t}\n\t\tint eq;\n\t\tREP(k, s.length())\n\t\t\tif (s[k] == '=')\n\t\t\t\teq = k;\n\n\t\tREP(i, 2048) {\n\t\t\tstring s2 = s;\n\t\t\tREP(j, 11) {\n\t\t\t\tREP(k, s2.length()) {\n\t\t\t\t\tif (s2[k] == 'a' + j)\n\t\t\t\t\t\tif ((i >> j) & 1) {\n\t\t\t\t\t\t\ts2[k] = 'T';\n\t\t\t\t\t\t}\n\t\t\t\t\t\telse {\n\t\t\t\t\t\t\ts2[k] = 'F';\n\t\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t}\n\t\t\tint idx1 = 0, idx2 = 0;\n\t\t\tstring s3 = s2.substr(0, eq);\n\t\t\tstring s4= s2.substr(eq + 1, s2.length() - eq - 1);\n\t\t\tif (cal(s3, idx1) != cal(s4, idx2)) {\n\t\t\t\tans = \"NO\";\n\t\t\t\tbreak;\n\t\t\t}\n\t\t}\n\t\tcout << ans << endl;\n\t}\n}"
  },
  {
    "language": "C++",
    "code": "#include <cstdio>\n#include <iostream>\n#include <cmath>\n#include <ctype.h>\n#include <string> \n#include <sstream>\n#include <iostream>\n#include <algorithm>\n#include <cstdlib>\n#include <map>\n#include <queue>\n#include <utility>\n#include <vector>\n#include <set>\n#include <list>\n#include <cstring>\n#include <stack>\n   \nusing namespace std;\n\nint main()\n{\n    string s;\n    while(1){\n        cin >> s;\n        if(s == \"#\") break;\n        char en[12] = {'a', 'b', 'c', 'd', 'e', 'f', 'g', 'h', 'i', 'j', 'k'};\n        bool ok = true;\n        map<char, char> chara;\n        chara['1'] = '1';\n        chara['0'] = '0';\n        chara['T'] = '1';\n        chara['F'] = '0';\n        chara['('] = '(';\n        chara['='] = '=';\n        chara['*'] = '*';\n        chara['+'] = '+';\n        chara['-'] = '-';\n        chara['>'] = '>';\n        for(int i = 0; i < (1 << 11); i++){\n            int nowi = i;\n            for(int j = 10; j >= 0; j--){\n                chara[en[j]] = (nowi / (int)pow(2, j)) + '0';\n                nowi = nowi % (int)pow(2, j);\n                // cout << chara[en[j]];\n            }\n            // cout << endl;\n            stack<char> st;\n            for(int j = 0; j < s.length(); j++){\n                if(s[j] == ')'){\n                    char y = st.top();\n                    // cout <<\"y:\" << y << endl;\n                    st.pop();\n                    while(st.top() == '-'){\n                        st.pop();\n                        if(y == '0') y = '1';\n                        else y = '0';\n                    }\n                    char op = st.top();\n                    // cout << \"op:\" << op << endl;\n                    if(op == '>') st.pop();\n                    st.pop();\n                    char x = st.top();\n                    // cout << \"x:\" << x << endl;\n                    st.pop();\n                    while(st.top() == '-'){\n                        st.pop();\n                        if(x == '0') x = '1';\n                        else x = '0';\n                    }\n                    // cout << \"hey \" << st.top() << endl;\n                    st.pop();\n                    // cout << x << \" \" << op << \" \" << y << endl;\n                    if(op == '*'){\n                        if(x == '1' && y == '1') st.push('1');\n                        else st.push('0');\n                    } else if(op == '+'){\n                        if(x == '0' && y == '0') st.push('0');\n                        else st.push('1');\n                    } else if(op == '>'){\n                        if(x == '1' && y == '0') st.push('0');\n                        else st.push('1');\n                    }\n                } else {\n                    // cout << chara[s[j]] << endl;\n                    st.push(chara[s[j]]);\n                }\n            }\n            char e2 = st.top();\n            st.pop();\n            if(st.top() == '-'){\n                st.pop();\n                if(e2 == '1') e2 = '0';\n                else e2 = '1';\n            }\n            // cout << st.top() << endl;\n            st.pop();\n            char e1 = st.top();\n            st.pop();\n            if(!st.empty()){\n                st.pop();\n                if(e1 == '1') e1 = '0';\n                else e1 = '1';\n            }\n            // cout << st.size() << endl;\n            if(e1 != e2){\n                ok = false;\n                break;\n            }\n        }\n        if(ok) cout << \"YES\" << endl;\n        else cout << \"NO\" << endl;\n    }\n    return 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include<iostream>\n#include<string>\n#include<vector>\n#define MAX 11\nusing namespace std;\nbool o;\nvoid rec(string s){\n  if(!o) return;\n  //cout << s << endl;\n  while(1){\n    bool f=false;\n    int p;\n    for(p=0;p<s.size();p++){\n      f=false;\n      //cout << s << endl;\n      //if(s[p]==' ') continue;\n      if(s[p]=='-'){\n\t\n\tif(s[p+1]=='0'){\n\t  s[p]='1';\n\t  s[p+1]=' ';\n\t  f=true;\n\t}\n\t\n\tif(s[p+1]=='1'){\n\t  s[p]='0';\n\t  s[p+1]=' ';\n\t  f=true;\n\t}\n      }\n      else if(s[p]=='('){\n\tif(s[p+1]!='0'&&s[p+1]!='1') continue;\n\tif(s[p+4]==')'){\n\t  if(s[p+2]=='+'){\n\t    if(s[p+1]=='0'&&s[p+3]=='0'){\n\t      s[p]='0';s[p+1]=' ';s[p+2]=' ';s[p+3]=' ';s[p+4]=' ';\n\t    }\n\t    if(s[p+1]=='1'&&s[p+3]=='0'){\n\t      s[p]='1';s[p+1]=' ';s[p+2]=' ';s[p+3]=' ';s[p+4]=' ';\n\t    }\n\t    if(s[p+1]=='0'&&s[p+3]=='1'){\n\t      s[p]='1';s[p+1]=' ';s[p+2]=' ';s[p+3]=' ';s[p+4]=' ';\n\t    }\n\t    if(s[p+1]=='1'&&s[p+3]=='1'){\n\t      s[p]='1';s[p+1]=' ';s[p+2]=' ';s[p+3]=' ';s[p+4]=' ';\n\t    }\n\t  }\n\t  if(s[p+2]=='*'){\n\t    if(s[p+1]=='0'&&s[p+3]=='0'){\n\t      s[p]='0';s[p+1]=' ';s[p+2]=' ';s[p+3]=' ';s[p+4]=' ';\n\t    }\n\t    if(s[p+1]=='1'&&s[p+3]=='0'){\n\t      s[p]='0';s[p+1]=' ';s[p+2]=' ';s[p+3]=' ';s[p+4]=' ';\n\t    }\n\t    if(s[p+1]=='0'&&s[p+3]=='1'){\n\t      s[p]='0';s[p+1]=' ';s[p+2]=' ';s[p+3]=' ';s[p+4]=' ';\n\t    }\n\t    if(s[p+1]=='1'&&s[p+3]=='1'){\n\t      s[p]='1';s[p+1]=' ';s[p+2]=' ';s[p+3]=' ';s[p+4]=' ';\n\t    }\n\t  }\n\t  f=true;\n\t}else if(s[p+5]==')'&&s[p+2]=='-'&&s[p+3]=='>'){\n\t  if(s[p+1]=='0'&&s[p+4]=='0'){\n\t    s[p]='1';s[p+1]=' ';s[p+2]=' ';s[p+3]=' ';s[p+4]=' ';s[p+5]=' ';\n\t  }\n\t  if(s[p+1]=='1'&&s[p+4]=='0'){\n\t    s[p]='0';s[p+1]=' ';s[p+2]=' ';s[p+3]=' ';s[p+4]=' ';s[p+5]=' ';\n\t  }\n\t  if(s[p+1]=='0'&&s[p+4]=='1'){\n\t    s[p]='1';s[p+1]=' ';s[p+2]=' ';s[p+3]=' ';s[p+4]=' ';s[p+5]=' ';\n\t  }\n\t  if(s[p+1]=='1'&&s[p+4]=='1'){\n\t    s[p]='1';s[p+1]=' ';s[p+2]=' ';s[p+3]=' ';s[p+4]=' ';s[p+5]=' ';\n\t  }\n\t  f=true;\n\t}\n      }\n      if(f){\n\tstring b;\n\tfor(int i=0;i<s.size();i++) if(s[i]!=' ') b+=s[i];\n\ts=b;\n\tp=-1;\n      }\n    }\n    if(s[0]!=s[2]) o=false;\n    return;\n  }\n}\nbool fi;\nvector<int> v[11];\nvoid init(int n,string s){\n  int i,j;\n  if(fi){\n    for(j=0;j<MAX;j++) v[j].clear();\n    for(i=0;i<s.size();i++){\n      for(j=0;j<MAX;j++){\n\tif(s[i]=='a'+j) {\n\t  s[i]='0'+(n>>j&1);\n\t  v[j].push_back(i);\n\t}\n      }\n    }\n    fi=false;\n  }else{\n    for(i=0;i<MAX;i++){\n      for(j=0;j<v[i].size();j++){\n\ts[v[i][j]]='0'+(n>>i&1);\n      }\n    }\n  }\n  //cout << s << endl;\n  rec(s);\n  if(!o) return;\n}\nint main(){\n  string s;\n  while(cin >> s,s!=\"#\"){\n    o=true;\n    int i;\n    fi=true;\n    for(i=0;i<s.size();i++){\n      if(s[i]=='T') s[i]='1';\n      if(s[i]=='F') s[i]='0';\n    }\n    for(i=0;i<(1<<MAX);i++)\n      if(o) init(i,s);\n      else break;\n    cout << (o?\"YES\":\"NO\") << endl;\n  }\n  return 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\nusing namespace std;\n#define FOR(i,k,n) for(int i = (int)(k); i < (int)(n); i++)\n#define REP(i,n) FOR(i,0,n)\n#define ALL(a) a.begin(), a.end()\n#define MS(m,v) memset(m,v,sizeof(m))\n#define D10 fixed<<setprecision(10)\ntypedef long long ll;\ntypedef long double ld;\ntypedef vector<int> vi;\ntypedef vector<string> vs;\ntypedef pair<int, int> pii;\nconst int MOD = 1000000007;\nconst int INF = MOD + 1;\nconst ld EPS = 1e-12;\ntemplate<class T> T &chmin(T &a, const T &b) { return a = min(a, b); }\ntemplate<class T> T &chmax(T &a, const T &b) { return a = max(a, b); }\n\n/*--------------------template--------------------*/\nstring s;\nint p, var;\nbool f;\n\nint parse();\n\nint unit()\n{\n\tint res;\n\tif (s[p] == '-'&&s[p + 1] != '>')\n\t{\n\t\tp++;\n\t\tint a = unit();\n\t\tres = 1 - a;\n\t}\n\telse if (s[p] == '(')\n\t{\n\t\tp++;\n\t\tres = parse();\n\t\tp++;\n\t}\n\telse\n\t{\n\t\tif (s[p] == 'T') res = 1;\n\t\telse if (s[p] == 'F') res = 0;\n\t\telse\n\t\t{\n\t\t\tint t = s[p] - 'a';\n\t\t\tres = (var >> t) & 1;\n\t\t}\n\t\tp++;\n\t}\n\treturn res;\n}\n\nint parse()\n{\n\tint a = unit();\n\tif (s[p] == '+')\n\t{\n\t\tp++;\n\t\tint b = unit();\n\t\ta = max(a, b);\n\t}\n\telse if (s[p] == '*')\n\t{\n\t\tp++;\n\t\tint b = unit();\n\t\ta = min(a, b);\n\t}\n\telse if(s[p] == '-' && s[p+1] == '>')\n\t{\n\t\tp += 2;\n\t\tint b = unit();\n\t\tif (a == 1 && b == 0) a = 0;\n\t\telse a = 1;\n\t}\n\treturn a;\n}\n\nvoid solve()\n{\n\tp = 0;\n\tint l = parse();\n\tp++;\n\tint r = parse();\n\tif (l != r) f = false;\n}\n\nint main()\n{\n\twhile (cin >> s&&s != \"#\")\n\t{\n\t\tf = true;\n\t\tfor (var = 0; var < 1 << 11;var++)\n\t\t{\n\t\t\tsolve();\n\t\t}\n\t\tputs(f ? \"YES\" : \"NO\");\n\t}\n\treturn 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include<iostream>\n#include<string>\nusing namespace std;\n\nint not(int a){\n\tif(a==1) return 0;\n\treturn 1;\n}\n\nint and(int a,int b){\n\tif(a==1 && b==1) return 1;\n\treturn 0;\n}\n\nint or(int a,int b){\n\tif(a==0 && b==0) return 0;\n\treturn 1;\n}\n\nint naraba(int a,int b){\n\tif(a==0 || (a==1 && b==1)) return 1;\n\treturn 0;\n}\n\nstring s;\nint bit=0;\nint p=0;\n\nint to_int(char a){\n\tif(a=='T') return 1;\n\tif(a=='F') return 0;\n\tint k=a-'a';\n\tif(bit & (1<<k)) return 1;\n\treturn 0;\n}\n\n\nint calc(){\n\tif(isalpha(s[p])) return to_int(s[p++]);\n\tif(s[p]=='-'){\n\t\tp++;\n\t\treturn not(calc());\n\t}\n\tif(s[p]=='('){\n\t\tp++;\n\t\tint res1=calc();\n\t\tif(s[p]=='*'){\n\t\t\tp++;\n\t\t\tint res2=calc();\n\t\t\tp++;\n\t\t\treturn and(res1,res2);\n\t\t}\n\t\telse if(s[p]=='+'){\n\t\t\tp++;\n\t\t\tint res2=calc();\n\t\t\tp++;\n\t\t\treturn or(res1,res2);\n\t\t}\n\t\telse if(s[p]=='-'){\n\t\t\tp+=2; //>を読み飛ばす\n\t\t\tint res2=calc();\n\t\t\tp++;\n\t\t\treturn naraba(res1,res2);\n\t\t}\n\t}\n\tcout<<\"Error \"<<s[p]<<endl;\n\treturn -1;\n}\n\n\nint main()\n{\n\twhile(cin>>s && s[0]!='#'){\n\n\t\tbool ok=true;\n\t\tfor(bit=0;bit<(1<8);bit++){\n\t\t\tp=0;\n\t\t\tint ans1=calc();\n\t\t\tp++;\n\t\t\tint ans2=calc();\n\t\t\tif(ans1!=ans2){ok=false;break;}\n\t\t}\n\t\tif(ok) cout<<\"YES\"<<endl;\n\t\telse cout<<\"NO\"<<endl;\n\t}\n\treturn 0;\n}"
  },
  {
    "language": "C++",
    "code": "/*\n *\n * <equation> ::= <formula> \"=\" <formula>\n * <formula>  ::= \"T\" | \"F\" |\n * \"a\" | \"b\" | \"c\" | \"d\" | \"e\" | \"f\" |\n * \"g\" | \"h\" | \"i\" | \"j\" | \"k\" |\n * \"-\" <formula> |\n * \"(\" <formula> \"*\" <formula> \")\" |\n * \"(\" <formula> \"+\" <formula> \")\" |\n * \"(\" <formula> \"->\" <formula> \")\"\n */\n#include<iostream>\n#include<map>\n#include<vector>\n#include<algorithm>\n#include<cmath>\n#include<iomanip>\n#include<numeric>\n#include<climits>\n#include<ctime>\n#include<cstring>\n#include<sstream>\n#define REP(i,p,n) for(int i=p;i<(int)(n);i++)\n#define rep(i,n) REP(i,0,n)\n#define rep_split(tok,a_str,re) for(char *tok = strtok((char *)a_str.c_str(),re); tok != NULL; tok = strtok(NULL,re))\n#define ALL(c) (c).begin(), (c).end()\n#define dump(a) cerr << #a << \"=\" << (a) << endl\n#define DUMP(list) cout << \"{ \"; for(auto nth : list){ cout << nth << \" \"; } cout << \"}\" << endl;\ntemplate<class T> void chmin(T &t, T f) { if (t > f) t = f; } //t=min\ntemplate<class T> void chmax(T &t, T f) { if (t < f) t = f; } //t=max\nusing namespace std;\n\n\nvector<bool> var_pattern;\nbool equation(string& s, int& i);\nbool formula(string& s, int& i);\n\n\nbool equation(string& s, int& i)\n{\n\tbool left = formula(s,i);\n\t//cout << \"左辺 \" << left << endl;\n\ti++; // =\n\tbool right = formula(s,i);\n\t//cout << \"右辺 \" << right << endl;\n\n\t//cout << left << \"=\" << right << endl;\n\n\treturn left == right;\n}\n\n\nbool formula(string& s, int& i)\n{\n\tbool left=false,right=false;\t\n\tchar ope=0;\n\tbool ans = false;\n\n\tswitch(s[i])\n\t{\n\t\tcase 'T':\n\t\t\tans = true;\n\t\t\tbreak;\n\t\tcase 'F':\n\t\t\tans = false;\n\t\t\tbreak;\n\t\tcase '-':\n\t\t\ti++;\n\t\t\treturn !formula(s,i);\n\t\tcase '(':\n\t\t\ti++;\n\t\t\tleft = formula(s,i);\n\t\t\ti++; \n\t\t\tope = s[i];\n\t\t\tif (ope == '-') { i++; ope='>'; } //->\n\t\t\ti++;\n\t\t\tright = formula(s,i);\n\n\t\t\tif (ope == '*') {\n\t\t\t\tans = left * right;\t\n\t\t\t}\n\t\t\telse if (ope == '+') {\n\t\t\t\tans = left + right;\t\n\t\t\t}\n\t\t\telse if (ope == '>') {\n\t\t\t\tans = (!left) + right;\n\t\t\t}\n\t\t\ti++; //')'\n\t\t\ti++; //=\n\t\t\tbreak;\n\n\t\tdefault:\n\t\t\tif ('a' <= s[i] && s[i] <= 'k') {\n\t\t\t\tint var_num = (int)(s[i] - 'a');\n\t\t\t\tans = var_pattern[var_num];\n\t\t\t}\n\t\t\t//cout << \"index=\" << var_num << \" var=\" << s[i] << endl;\n\t\t\t//cout << s[i] << \" = \" << var_pattern[var_num] << endl;\n\t\t\tbreak;\n\t}\n\n\treturn ans;\n}\n\n\n\nint main() {\n\tstring line;\n\t\n\twhile(cin >> line)\n\t{\n\t\tif (line[0] == '#') break;\n\t\tint i=0;\n\n\t\tbool is_yes = true;\n\t\trep(j,20) {\n\t\t\tint num = j;\n\t\t\trep(k,11)\n\t\t\t{\n\t\t\t\tvar_pattern.push_back((num & 1));\n\t\t\t\t//cout << (num & 1) << \" \";\n\t\t\t\tnum >>= 1;\n\t\t\t}\n\t\t\t//cout << endl;\n\t\t\tif (!equation(line,i)) { is_yes = false; break; }\n\t\t\tvar_pattern.clear();\n\t\t}\n\t\tcout << (is_yes ? \"YES\" : \"NO\") << endl;\n\t\t//cout << \"-----------\" << endl;\n\t}\n\n\treturn 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include<iostream>\n#include<string>\n#include<vector>\n#include<queue>\n#include<stack>\n#include<map>\n#include<set>\n#include<algorithm>\n#include<functional>\n#include<cstdio>\n#include<cstdlib>\n#include<cmath>\nusing namespace std;\n\n#define mind(a,b) (a>b?b:a)\n#define maxd(a,b) (a>b?a:b)\n#define absd(x) (x<0?-(x):x)\n#define pow2(x) ((x)*(x))\n#define rep(i,n) for(int i=0; i<n; ++i)\n#define repr(i,n) for(int i=n-1; i>=0; --i)\n#define repl(i,s,n) for(int i=s; i<=n; ++i)\n#define replr(i,s,n) for(int i=n; i>=s; --i)\n#define repf(i,s,n,j) for(int i=s; i<=n; i+=j)\n#define repe(e,obj) for(auto e : obj)\n\n#define SP << \" \" <<\n#define COL << \" : \" <<\n#define COM << \", \" <<\n#define ARR << \" -> \" <<\n#define PNT(STR) cout << STR << endl\n#define POS(X,Y) \"(\" << X << \", \" << Y << \")\"\n#define DEB(A) \" (\" << #A << \") \" << A\n#define DEBREP(i,n,val) for(int i=0; i<n; ++i) cout << val << \" \"; cout << endl\n#define ALL(V) (V).begin(), (V).end()\n#define INF 1000000007\n#define INFLL 10000000000000000007LL\n#define EPS 1e-9\n\ntypedef unsigned int uint;\ntypedef unsigned long ulong;\ntypedef unsigned long long ull;\ntypedef long long ll;\ntypedef long double ld;\ntypedef pair<int, int> P;\n//typedef pair<ll, ll> P;\ntypedef pair<P, int> PI;\ntypedef pair<int, P> IP;\ntypedef pair<P, P> PP;\ntypedef priority_queue<P, vector<P>, greater<P> > pvqueue;\n\n#define N 15\nint cur;\nstring s;\nint p[N];\n\nbool parse();\n\nbool i_parse() {\n    char c = s[cur++];\n    if(c == '-') {\n        return !i_parse();\n    }\n    if(c == '(') {\n        bool res = parse();\n        cur++; // ')'\n        return res;\n    } else if(c == 'T' || c == 'F') {\n        return (c == 'T');\n    } else {\n        return (p[c - 'a'] > 0);\n    }\n}\n\nbool parse() {\n    bool le = i_parse();\n    char c = s[cur++];\n    if(c == '-') cur++; // '>'\n    bool ri = i_parse();\n    switch(c) {\n        case '*':\n            return le && ri;\n        case '+':\n            return le || ri;\n        case '-':\n            return !le || ri;\n    }\n}\n\nbool solve() {\n    cur = 0;\n    bool le = i_parse();\n    cur ++; // '='\n    bool ri = i_parse();\n    return le == ri;\n}\n\nbool p_make(int c) {\n    if(c == 11) {\n        return solve();\n\n    } else {\n        rep(i, 2) {\n            p[c] = i;\n            if(!p_make(c+1)) {\n                return false;\n            }\n        }\n    }\n    return true;\n}\n\nint main() {\n    while(cin >> s && s[0]!='#') {\n        bool ans = p_make(0);\n        cout << (ans ? \"YES\" : \"NO\") << endl;\n    }\n    return 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include <algorithm>\n#include <cmath>\n#include <climits>\n#include <cstdio>\n#include <cstring>\n#include <fstream>\n#include <iostream>\n#include <list>\n#include <map>\n#include <queue>\n#include <set>\n#include <sstream>\n#include <stack>\n#include <string>\n#include <vector>\n \nusing namespace std;\n \n#define LOG(...) printf(__VA_ARGS__)\n//#define LOG(...)\n#define FOR(i,a,b) for(int i=(a);i<=(b);++i)\n#define REP(i,n) for(int i=0;i<(int)(n);++i)\n#define ALL(a) (a).begin(),(a).end()\n#define EXIST(s,e) ((s).find(e)!=(s).end())\n#define SORT(c) sort((c).begin(),(c).end())\n \ntypedef long long ll;\ntypedef unsigned long long ull;\ntypedef vector<bool> vb;\ntypedef vector<int> vi;\ntypedef vector<ll> vll;\ntypedef vector<vb> vvb;\ntypedef vector<vi> vvi;\ntypedef vector<vll> vvll;\ntypedef pair<int, int> pii;\ntypedef pair<ll, ll> pll;\n\nchar f(char x, char y, char z){\n\tswitch(z){\n\t\tcase '*':\n\t\t\treturn (x&y)|'0';\n\t\t\tbreak;\n\t\tcase '+':\n\t\t\treturn (x|y)|'0';\n\t\t\tbreak;\n\t\tcase '>':\n\t\t\tif(x=='1'&&y=='0')\n\t\t\t\treturn '0';\n\t\t\telse\n\t\t\t\treturn '1';\n\t\t\tbreak;\n\t}\n\treturn '0';\n}\n\nchar e(string s, int n){\n\tstack<char> st;\n\tfor(char c:s){\n\t\tswitch(c){\n\t\t\tcase '>':\n\t\t\t\tst.pop();\n\t\t\t\tst.push(c);\n\t\t\t\tbreak;\n\t\t\tcase '-':\n\t\t\t\tif(!st.empty() && st.top() == '-'){\n\t\t\t\t\tst.pop();\n\t\t\t\t\tbreak;\n\t\t\t\t}\n\t\t\tcase '(':\n\t\t\tcase '*':\n\t\t\tcase '+':\n\t\t\t\tst.push(c);\n\t\t\t\tbreak;\n\n\t\t\tcase ')':\n\t\t\t\tchar x,z,y;\n\t\t\t\ty = st.top(); st.pop();\n\t\t\t\tz = st.top(); st.pop();\n\t\t\t\tx = st.top(); st.pop();\n\t\t\t\tst.pop();\n\t\t\t\tst.push(f(x,y,z));\n\t\t\t\tif(st.size() == 1){\n\t\t\t\t\treturn st.top();\n\t\t\t\t}\n\t\t\t\tbreak;\n\n\t\t\tdefault:\n\t\t\t\tchar rev = '0';\n\t\t\t\tif(!st.empty() && st.top() == '-'){\n\t\t\t\t\trev = '1';\n\t\t\t\t\tst.pop();\n\t\t\t\t}\n\t\t\t\tswitch(c){\n\t\t\t\t\tcase 'T':\n\t\t\t\t\t\tst.push(('1' ^ rev) |'0');\n\t\t\t\t\t\tbreak;\n\t\t\t\t\tcase 'F':\n\t\t\t\t\t\tst.push(('0' ^ rev)|'0');\n\t\t\t\t\t\tbreak;\n\t\t\t\t\tdefault:\n\t\t\t\t\t\tchar cc = n & (1 << (c-'a')) > 0 ? '1' : '0';\n\t\t\t\t\t\tst.push((cc ^ rev)|'0');\n\t\t\t\t\t\tbreak;\n\t\t\t\t}\n\t\t\t\tbreak;\n\t\t}\n//\t\tprintf(\"%c %d = %c\\n\", c, st.size(), st.top());\n\t}\n\n\treturn (st.top() ^ '1')|'0';\n}\n\nint main() {\n\tstring line, l, r;\n\n\twhile(true){\n\t\tgetline(cin, line);\n\t\tif(line == \"#\") break;\n\t\tstringstream ss(line);\n\t\tgetline(ss, l, '=');\n\t\tgetline(ss, r);\n\n\t\tbool t = true;\n\t\tfor(int n = 0; n < (1<<11); n++){\n\t\t\tchar rl = e(l, n);\n//\t\t\tcout << \"res   \"<<(int)rl << endl;\n\t\t\tchar rr = e(r, n);\n//\t\t\tcout << \"res   \"<<(int)rr << endl;\n\t\t\tif(rl != rr){\n\t\t\t\tt = false;\n\t\t\t\tbreak;\n\t\t\t}\n\t\t}\n\t\tcout << (t?\"YES\":\"NO\") << endl;\n\t}\n\n\treturn 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include <functional>\n#include <iostream>\n#include <string>\n#include <unordered_set>\n#include <vector>\n#define loop(i, a, n) for (int i = (a); i < (n); i++)\n#define rep(i, n) loop(i, 0, n)\ntemplate<typename A> using F = std::function<A>;\nusing namespace std;\n\ntemplate<typename T> struct ParseResult {\n\tbool succeeded;\n\tT object;\n\tint pos;\n\tParseResult(ParseResult&& other) : succeeded(other.succeeded), object(std::move(other.object)), pos(other.pos) {}\n\tParseResult& operator=(ParseResult&& other) { succeeded = (other.succeeded); object = (std::move(other.object)); pos = (other.pos); }\n\tParseResult(const bool succeeded, const T &object, const int pos) : succeeded(succeeded), object(object), pos(pos) {}\n\tfriend std::ostream &operator<<(std::ostream &os, const ParseResult<T> &p) { return os << '{' << (p.succeeded ? \"true\" : \"false\") << ',' << p.object << ',' << p.pos << '}'; }\n};\n\ntemplate<typename T> using Parser = std::function<ParseResult<T>(std::string, int)>;\n\nParser<std::string> token(std::string &&s) {\n\tconst int n = s.size();\n\treturn[n = std::move(n), s = std::move(s)](const std::string &target, const int pos) {\n\t\tif (target.size() < n) return ParseResult<std::string>(false, {}, pos);\n\t\treturn target.substr(pos, n) == s ? ParseResult<std::string>(true, s, pos + n) : ParseResult<std::string>(false, {}, pos);\n\t};\n}\n\ntemplate<typename T> Parser<T> operator||(const Parser<T> &p1, const Parser<T> &p2) {\n\treturn[p1 = std::move(p1), p2 = std::move(p2)](const std::string &target, const int pos) {\n\t\tauto r = p1(target, pos);\n\t\tif (r.succeeded) return r;\n\t\tr = p2(target, pos);\n\t\tif (r.succeeded) return r;\n\t\treturn ParseResult<T>(false, {}, pos);\n\t};\n}\n\ntemplate<typename T1, typename T2> Parser<std::pair<T1, T2>> operator+(const Parser<T1> &p1, const Parser<T2> &p2) {\n\treturn[p1 = std::move(p1), p2 = std::move(p2)](const std::string &target, const int pos) {\n\t\tauto r1 = p1(target, pos);\n\t\tif (!r1.succeeded) return ParseResult<std::pair<T1, T2>>(false, {}, pos);\n\t\tauto r2 = p2(target, r1.pos);\n\t\tif (!r2.succeeded) return ParseResult<std::pair<T1, T2>>(false, {}, pos);\n\t\treturn ParseResult<std::pair<T1, T2>>(true, { r1.object, r2.object }, r2.pos);\n\t};\n}\n\ntemplate<typename T1, typename T2> Parser<T2> operator>>(const Parser<T1> &p1, const Parser<T2> &p2) {\n\treturn[p1 = std::move(p1), p2 = std::move(p2)](const std::string &target, const int pos) {\n\t\tauto r1 = p1(target, pos);\n\t\tif (!r1.succeeded) return ParseResult<T2>(false, {}, pos);\n\t\tauto r2 = p2(target, r1.pos);\n\t\tif (!r2.succeeded) return ParseResult<T2>(false, {}, pos);\n\t\treturn ParseResult<T2>(true, r2.object, r2.pos);\n\t};\n}\n\ntemplate<typename T1, typename T2> Parser<T1> operator<<(const Parser<T1> &p1, const Parser<T2> &p2) {\n\treturn[p1 = std::move(p1), p2 = std::move(p2)](const std::string &target, const int pos) {\n\t\tauto r1 = p1(target, pos);\n\t\tif (!r1.succeeded) return ParseResult<T1>(false, {}, pos);\n\t\tauto r2 = p2(target, r1.pos);\n\t\tif (!r2.succeeded) return ParseResult<T1>(false, {}, pos);\n\t\treturn ParseResult<T1>(true, r1.object, r2.pos);\n\t};\n}\n\nParser<char> oneOf(const std::string &s) {\n\tstd::unordered_set<char> d;\n\tfor (auto &c : s) d.insert(c);\n\treturn[d = std::move(d)](const std::string &target, const int pos) {\n\t\tif (target.size() <= pos) return ParseResult<char>(false, {}, pos);\n\t\tchar c = target[pos];\n\t\treturn d.count(c) ? ParseResult<char>(true, c, pos + 1) : ParseResult<char>(false, {}, pos);\n\t};\n}\n\ntemplate<typename T, typename S, typename F> Parser<S> fmap(const Parser<T> &p, const F &f) {\n\treturn[p = std::move(p), f = std::move(f)](const std::string &target, const int pos) {\n\t\tauto r = p(target, pos);\n\t\treturn r.succeeded ? ParseResult<S>(true, f(r.object), r.pos) : ParseResult<S>(false, {}, r.pos);\n\t};\n}\n\ntemplate<typename T, typename F> Parser<T> lazy(const F &f) {\n\tstatic bool instantiated = false;\n\tstatic Parser<T> p;\n\treturn[f = std::move(f)](const std::string &target, const int pos) mutable {\n\t\tif (!instantiated) {\n\t\t\tp = f();\n\t\t\tinstantiated = true;\n\t\t}\n\t\treturn p(target, pos);\n\t};\n}\n\nstruct SyntaxTree {\n\tstring op;\n\tchar value;\n\tvector<SyntaxTree> children;\n\tSyntaxTree() {}\n\tSyntaxTree(const string &op, const char value, const vector<SyntaxTree> &children) : op(op), value(value), children(children) {}\n};\n\nint main() {\n\tParser<SyntaxTree> formulaP = lazy<SyntaxTree>([&]() {\n\t\tauto andP = fmap<pair<SyntaxTree, SyntaxTree>, SyntaxTree>((token(\"(\") >> formulaP << token(\"*\")) + (formulaP << token(\")\")), [](auto &o) { return SyntaxTree(\"*\", {}, { o.first, o.second }); });\n\t\tauto orP = fmap<pair<SyntaxTree, SyntaxTree>, SyntaxTree>((token(\"(\") >> formulaP << token(\"+\")) + (formulaP << token(\")\")), [](auto &o) { return SyntaxTree(\"+\", {}, { o.first, o.second }); });\n\t\tauto impP = fmap<pair<SyntaxTree, SyntaxTree>, SyntaxTree>((token(\"(\") >> formulaP << token(\"->\")) + (formulaP << token(\")\")), [](auto &o) { return SyntaxTree(\"->\", {}, { o.first, o.second }); });\n\t\tauto notP = fmap<SyntaxTree, SyntaxTree>(token(\"-\") >> formulaP, [](auto &o) { return SyntaxTree(\"-\", {}, { o }); });\n\t\tauto valP = fmap<char, SyntaxTree>(oneOf(\"abcdefghijkTF\"), [](char x) { return SyntaxTree({}, x, {}); });\n\t\treturn andP || orP || impP || notP || valP;\n\t});\n\tauto equationP = (formulaP << token(\"=\")) + formulaP;\n\tstring s;\n\twhile (cin >> s, s != \"#\") {\n\t\tauto r = equationP(s, 0);\n\t\tbool isValid = true;\n\t\trep(i, 1 << 11) {\n\t\t\tauto toBool = [&i](char c) -> bool {\n\t\t\t\tif (c == 'T') return true;\n\t\t\t\tif (c == 'F') return false;\n\t\t\t\treturn i >> (c - 'a') & 1;\n\t\t\t};\n\t\t\tF<bool(SyntaxTree)> evalF = [&](const SyntaxTree &f) {\n\t\t\t\tswitch (f.children.size()) {\n\t\t\t\tcase 0: return toBool(f.value);\n\t\t\t\tcase 1: return !evalF(f.children[0]);\n\t\t\t\tcase 2:\n\t\t\t\t\tif (f.op == \"*\") return evalF(f.children[0]) && evalF(f.children[1]);\n\t\t\t\t\tif (f.op == \"+\") return evalF(f.children[0]) || evalF(f.children[1]);\n\t\t\t\t\tif (f.op == \"->\") return !evalF(f.children[0]) || evalF(f.children[1]);\n\t\t\t\t}\n\t\t\t};\n\t\t\tisValid &= evalF(r.object.first) == evalF(r.object.second);\n\t\t}\n\t\tcout << (isValid ? \"YES\" : \"NO\") << endl;\n\t}\n}"
  },
  {
    "language": "C++",
    "code": "#include<bits/stdc++.h>\nusing namespace std;\n#define r(i,n) for(int i=0;i<n;i++)\nvector<char>v;\nint flag,p,cnt;\nstring s[2],t[2],q;\nmap<char,int>m;\nint bnf1();\nint num(){\n  int res=0,f=0;\n  while(s[cnt][p]=='-')p++,f++;\n  if(s[cnt][p]=='(')p++,res=(bnf1()+f)%2,p++;\n  else{\n    while(isdigit(s[cnt][p]))res=(s[cnt][p++]-'0'+f)%2;\n  }\n  return res;\n}\nint bnf1(){\n  int res=num();\n  while(s[cnt][p]=='+'||s[cnt][p]=='*'||s[cnt][p]=='>'){\n    int pp=p++;\n    if(s[cnt][pp]=='+')res=res|num();\n    if(s[cnt][pp]=='*')res=res&num();\n    if(s[cnt][pp]=='>'){\n      int pp=num();\n      if(res&&!pp)res=0;\n      else res=1;\n    }\n  }\n  return res;\n}\nvoid dfs(int d){\n  if(d==v.size()){\n    r(i,2)s[i]=t[i];\n    r(i,2)r(j,s[i].size()){\n      if(isalpha(s[i][j])){\n        s[i][j]=m[s[i][j]]+'0';\n      }\n    }\n    cnt=p=0;\n    int ans1=bnf1();\n    cnt=1;p=0;\n    int ans2=bnf1();\n    if(ans1!=ans2)flag++;\n  }\n  else{\n    m[v[d]]=1;\n    dfs(d+1);\n    m[v[d]]=0;\n    dfs(d+1);\n  }\n}\nint main(){\n  while(cin>>q,q!=\"#\"){\n    r(i,2)t[i]=\"\";\n    flag=0;\n    m.clear();\n    v.clear();\n    int c1=0;\n    r(i,(int)q.size()-1){\n      if(q[i]=='T')q[i]='1';\n      if(q[i]=='F')q[i]='0';\n      if(q[i]=='-'&&q[i+1]=='>'){\n        q.erase(q.begin()+i);\n        i--;\n      }\n    }\n    set<char>st;\n    r(i,q.size()){\n      if(isalpha(q[i])&&!st.count(q[i])){\n        v.push_back(q[i]);\n        st.insert(q[i]);\n      }\n    }\n    r(i,q.size()){\n      if(q[i]=='=')c1++;\n      else t[c1]+=q[i];\n    }\n    dfs(0);\n    cout<<(flag?\"NO\":\"YES\")<<endl;\n  }\n}"
  },
  {
    "language": "C++",
    "code": "#include <cstdio>\n#include <iostream>\n#include <cmath>\n#include <ctype.h>\n#include <string> \n#include <sstream>\n#include <iostream>\n#include <algorithm>\n#include <cstdlib>\n#include <map>\n#include <queue>\n#include <utility>\n#include <vector>\n#include <set>\n#include <list>\n#include <cstring>\n#include <stack>\n   \nusing namespace std;\n\nint main()\n{\n    string s;\n    while(1){\n        cin >> s;\n        if(s == \"#\") break;\n        char en[11] = {'a', 'b', 'c', 'd', 'e', 'f', 'g', 'h', 'i', 'j', 'k'};\n        bool ok = true;\n        for(int i = 0; i < (2 << 10); i++){\n            map<char, char> chara;\n            int nowi = i;\n            chara['1'] = '1';\n            chara['0'] = '0';\n            chara['T'] = '1';\n            chara['F'] = '0';\n            for(int j = 10; j >= 0; j--){\n                chara[en[j]] = (nowi / (int)pow(2, j)) + '0';\n                nowi = nowi % (int)pow(2, j);\n                // cout << chara[j];\n            }\n            stack<char> st;\n            for(int i = 0; i < s.length(); i++){\n                if(s[i] == ')'){\n                    char y = st.top();\n                    y = chara[y];\n                    st.pop();\n                    if(st.top() == '-'){\n                        st.pop();\n                        if(y == '0') y = '1';\n                        else y = '0';\n                    }\n                    char op = st.top();\n                    if(op == '>') st.pop();\n                    st.pop();\n                    char x = st.top();\n                    x = chara[x];\n                    st.pop();\n                    if(st.top() == '-'){\n                        st.pop();\n                        if(x == '0') x = '1';\n                        else x = '0';\n                    }\n                    st.pop();\n                    // cout << x << \" \" << op << \" \" << y << endl;\n                    if(op == '*'){\n                        if(x == '1' && y == '1') st.push('1');\n                        else st.push('0');\n                    } else if(op == '+'){\n                        if(x == '0' && y == '0') st.push('0');\n                        else st.push('1');\n                    } else if(op == '>'){\n                        if(x == '1' && y == '0') st.push('0');\n                        else st.push('1');\n                    }\n                } else {\n                    st.push(s[i]);\n                }\n            }\n            char e2 = st.top();\n            e2 = chara[e2];\n            st.pop();\n            if(st.top() == '-'){\n                st.pop();\n                if(e2 == '1') e2 = '0';\n                else e2 = '1';\n            }\n            st.pop();\n            char e1 = st.top();\n            e1 = chara[e1];\n            st.pop();\n            if(!st.empty()){\n                st.pop();\n                if(e1 == '1') e1 = '0';\n                else e1 = '1';\n            }\n            cout << st.size() << endl;\n            if(e1 != e2){\n                ok = false;\n                break;\n            }\n        }\n        if(ok) cout << \"YES\" << endl;\n        else cout << \"NO\" << endl;\n    }\n    return 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include<iostream>\n#include<string>\n#define MAX 11\nusing namespace std;\nbool o;\nvoid rec(string s){\n  if(!o) return;\n  //cout << s << endl;\n  bool f;\n  int p;\n\n  \n  while(s.find(\"-0\")!=-1){\n    p=s.find(\"-0\");\n    if(p==-1) break;\n    s[p]='1';s[p+1]=' ';\n    f=true;\n  }\n  while(s.find(\"-1\")!=-1){\n    p=s.find(\"-1\");\n    if(p==-1) break;\n    s[p]='0';s[p+1]=' ';\n    f=true;\n  }\n  /*\n  while(s.find(\"(0*0)\")!=-1){\n    p=s.find(\"(0*0)\");\n    s[p]='0';s[p+1]=' ';s[p+2]=' ';s[p+3]=' ';s[p+4]=' ';\n    f=true;\n  }\n  while(s.find(\"(0*1)\")!=-1){\n    p=s.find(\"(0*1)\");\n    s[p]='0';s[p+1]=' ';s[p+2]=' ';s[p+3]=' ';s[p+4]=' ';\n    f=true;\n  }\n  while(s.find(\"(1*0)\")!=-1){\n    p=s.find(\"(1*0)\");\n    s[p]='0';s[p+1]=' ';s[p+2]=' ';s[p+3]=' ';s[p+4]=' ';\n    f=true;\n  }\n  while(s.find(\"(1*1)\")!=-1){\n    p=s.find(\"(1*1)\");\n    s[p]='1';s[p+1]=' ';s[p+2]=' ';s[p+3]=' ';s[p+4]=' ';\n    f=true;\n  }\n  while(s.find(\"(0+0)\")!=-1){\n    p=s.find(\"(0+0)\");\n    s[p]='0';s[p+1]=' ';s[p+2]=' ';s[p+3]=' ';s[p+4]=' ';\n    f=true;\n  }\n  while(s.find(\"(0+1)\")!=-1){\n    p=s.find(\"(0+1)\");\n    s[p]='1';s[p+1]=' ';s[p+2]=' ';s[p+3]=' ';s[p+4]=' ';\n    f=true;\n  }\n  while(s.find(\"(1+0)\")!=-1){\n    p=s.find(\"(1+0)\");\n    s[p]='1';s[p+1]=' ';s[p+2]=' ';s[p+3]=' ';s[p+4]=' ';\n    f=true;\n  }\n  while(s.find(\"(1+1)\")!=-1){\n    p=s.find(\"(1+1)\");\n    s[p]='1';s[p+1]=' ';s[p+2]=' ';s[p+3]=' ';s[p+4]=' ';\n    f=true;\n  }\n  /*\n  while(s.find(\"(0->0)\")!=-1){\n    p=s.find(\"(0->0)\");\n    s[p]='1';s[p+1]=' ';s[p+2]=' ';s[p+3]=' ';s[p+4]=' ';s[p+5]=' ';\n    f=true;\n  }\n  while(s.find(\"(0->1)\")!=-1){\n    p=s.find(\"(0->1)\");\n    s[p]='1';s[p+1]=' ';s[p+2]=' ';s[p+3]=' ';s[p+4]=' ';s[p+5]=' ';\n    f=true;\n  }\n  while(s.find(\"(1->0)\")!=-1){\n    p=s.find(\"(1->0)\");\n    s[p]='0';s[p+1]=' ';s[p+2]=' ';s[p+3]=' ';s[p+4]=' ';s[p+5]=' ';\n    f=true;\n  }\n  while(s.find(\"(1->1)\")!=-1){\n    p=s.find(\"(1->1)\");\n    s[p]='1';s[p+1]=' ';s[p+2]=' ';s[p+3]=' ';s[p+4]=' ';s[p+5]=' ';\n    f=true;\n  }\n  */\n  if(f){\n    string b;\n    for(int i=0;i<s.size();i++) if(s[i]!=' ') b+=s[i];\n    rec(b);\n  }else{\n    if(s[0]!=s[2]) o=false;\n    return;\n  }\n}\nvoid init(int n,string s){\n  int i,j;\n  for(i=0;i<s.size();i++){\n    for(j=0;j<=MAX;j++){\n      if(s[i]=='a'+j) s[i]='0'+(n>>j&1);\n      if(s[i]=='T') s[i]='1';\n      if(s[i]=='F') s[i]='0';\n    }\n  }\n  rec(s);\n}\nint main(){\n  string s;\n  while(cin >> s,s!=\"#\"){\n    o=true;\n    int i;\n    for(i=0;i<(1<<MAX);i++)\n      init(i,s);\n    cout << (o?\"YES\":\"NO\") << endl;\n  }\n  return 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include<iostream>\n#include<vector>\n#include<string>\n#include<algorithm>\nusing namespace std;\n\n#define MAX_NUM 2\n#define MAX_CH 10\n#define MAX_N 1200\n\nstring S, T;\nchar NUM[MAX_NUM + 1] = \"01\";\nchar CH[MAX_CH + 1] = \"abcdefghij\";\nint TR[MAX_CH];\nint CNT[MAX_N];\n\nint Plus(int c1, int c2) {\n\treturn max(c1, c2);\n}\nint kake(int c1, int c2) {\n\treturn min(c1, c2);\n}\nint fukumi(int c1, int c2) {\n\tif (c1 == 1 && c2 == 0) {\n\t\treturn 0;\n\t}\n\treturn 1;\n}\n\nint STOI(char V) {\n\tif (V == '0') {\n\t\treturn 0;\n\t}\n\telse {\n\t\treturn 1;\n\t}\n}\n\nint calc2(string A2) {\n\tA2 = A2.substr(1, A2.size() - 1);\n\tif (A2.size() == 3) {\n\t\tint p1, p2;\n\t\tp1 = STOI(A2[0]);\n\t\tp2 = STOI(A2[2]);\n\t\tif (A2[1] == '+') {\n\t\t\treturn Plus(p1, p2);\n\t\t}\n\t\tif (A2[1] == '*') {\n\t\t\treturn kake(p1, p2);\n\t\t}\n\t\tif (A2[1] == '&') {\n\t\t\treturn fukumi(p1, p2);\n\t\t}\n\t}\n\telse if (A2.size() == 4) {\n\t\tif (A2[0] == '-') {\n\t\t\tint p1, p2;\n\t\t\tp1 = STOI(A2[1]);\n\t\t\tp2 = STOI(A2[3]);\n\t\t\tif (A2[1] == '+') {\n\t\t\t\treturn Plus(1 - p1, p2);\n\t\t\t}\n\t\t\tif (A2[1] == '*') {\n\t\t\t\treturn kake(1 - p1, p2);\n\t\t\t}\n\t\t\tif (A2[1] == '&') {\n\t\t\t\treturn fukumi(1 - p1, p2);\n\t\t\t}\n\t\t}\n\t\tif (A2[2] == '-') {\n\t\t\tint p1, p2;\n\t\t\tp1 = STOI(A2[0]);\n\t\t\tp2 = STOI(A2[3]);\n\t\t\tif (A2[1] == '+') {\n\t\t\t\treturn Plus(p1, 1 - p2);\n\t\t\t}\n\t\t\tif (A2[1] == '*') {\n\t\t\t\treturn kake(p1, 1 - p2);\n\t\t\t}\n\t\t\tif (A2[1] == '&') {\n\t\t\t\treturn fukumi(p1, 1 - p2);\n\t\t\t}\n\t\t}\n\t}\n\telse {\n\t\tint p1, p2;\n\t\tp1 = STOI(A2[1]);\n\t\tp2 = STOI(A2[4]);\n\t\tif (A2[1] == '+') {\n\t\t\treturn Plus(1 - p1, 1 - p2);\n\t\t}\n\t\tif (A2[1] == '*') {\n\t\t\treturn kake(1 - p1, 1 - p2);\n\t\t}\n\t\tif (A2[1] == '&') {\n\t\t\treturn fukumi(1 - p1, 1 - p2);\n\t\t}\n\t}\n}\n\nstring TOSTR(int d) {\n\tif (d == 0) {\n\t\treturn \"0\";\n\t}\n\telse {\n\t\treturn \"1\";\n\t}\n}\n\nint calc(string Y) {\n\tfor (int i = 0; i < MAX_N; i++) {\n\t\tCNT[i] = 0;\n\t}\n\tstring Z = \"\", AA = \"\";\n\n\twhile (Z.size() >= 2) {\n\t\tint L = 0, MN = 0;\n\t\tbool ok1 = false;\n\t\tZ = \"\"; AA = \"\";\n\t\tint pass2 = 0;\n\t\tint pass3 = -1;\n\t\twhile (pass2 < Y.size()) {\n\t\t\tif (Y[pass2] == '(') {\n\t\t\t\tL++;\n\t\t\t}\n\t\t\tif (Y[pass2] == ')') {\n\t\t\t\tL++;\n\t\t\t}\n\t\t\tCNT[pass2] = L;\n\t\t\tpass2++;\n\t\t\tMN = max(MN, L);\n\t\t}\n\t\tfor (int i = 0; i < Y.size(); i++) {\n\t\t\tif (CNT[i] == MN) {\n\t\t\t\tif (pass3 == -1) {\n\t\t\t\t\tpass3 = i;\n\t\t\t\t}\n\t\t\t\tAA += Y[i];\n\t\t\t\tif (i < Y.size() - 1) {\n\t\t\t\t\tif (Y[i + 1] == ')') {\n\t\t\t\t\t\tok1 = false;\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t}\n\t\t\telse {\n\t\t\t\tZ += Y[i];\n\t\t\t}\n\t\t}\n\t\tint ZSIZE = Z.size();\n\t\tZ = Z.substr(0, pass3) + TOSTR(calc2(AA)) + Z.substr(pass3, ZSIZE - pass3);\n\t}\n\tif (Z == \"0\") {\n\t\treturn false;\n\t}\n\telse {\n\t\treturn true;\n\t}\n}\n\nint power(int a, int b) {\n\tint res2 = 1;\n\tfor (int i = 0; i < b; i++) {\n\t\tres2 *= a;\n\t}\n\treturn res2;\n}\n\nbool solve(string U) {\n\tbool RES = true;\n\tstring V = \"\";\n\tstring V1 = \"\", V2 = \"\";\n\tstring W1 = \"\", W2 = \"\";\n\n\tfor (int i = 0; i < U.size(); i++) {\n\t\tif (U[i] == 'T') {\n\t\t\tV += '1';\n\t\t\tgoto E;\n\t\t}\n\t\telse if (U[i] == '>') {\n\t\t\t//nanimo shinai.\n\t\t}\n\t\telse if (U[i] == 'F') {\n\t\t\tV += '0';\n\t\t\tgoto E;\n\t\t}\n\t\telse if (i < U.size() - 1) {\n\t\t\tif (U.substr(i, 2) == \"->\") {\n\t\t\t\tV += '&';\n\t\t\t\tgoto E;\n\t\t\t}\n\t\t}\n\t\telse {\n\t\t\tV += U[i];\n\t\t}\n\tE:;\n\t}\n\n\tint cnt1 = 0;\n\tfor (int i = 0; i < V.size(); i++) {\n\t\tif (V[i] == '=') {\n\t\t\tcnt1 = 1;\n\t\t}\n\t\telse if (cnt1 == 0) {\n\t\t\tV1 += V[i];\n\t\t}\n\t\telse if (cnt1 == 1) {\n\t\t\tV2 += V[i];\n\t\t}\n\t}\n\n\tint pass1 = 0;\n\twhile (pass1 < V1.size()) {\n\t\tif (V1[pass1] == '-') {\n\t\t\tint cnt2 = 0;\n\t\t\twhile (V1[pass1] == '-') {\n\t\t\t\tcnt2++;\n\t\t\t\tpass1++;\n\t\t\t}\n\t\t\tif (cnt2 % 2 == 1) {\n\t\t\t\tW1 += '(';\n\t\t\t\tW1 += '-';\n\t\t\t\tW1 += V1[pass1];\n\t\t\t\tW1 += ')';\n\t\t\t}\n\t\t\telse {\n\t\t\t\tW1 += V1[pass1];\n\t\t\t}\n\t\t\tpass1++;\n\t\t}\n\t\tif (pass1 < V1.size()) {\n\t\t\tW1 += V1[pass1];\n\t\t\tpass1++;\n\t\t}\n\t}\n\n\tpass1 = 0;\n\twhile (pass1 < V2.size()) {\n\t\tif (V2[pass1] == '-') {\n\t\t\tint cnt2 = 0;\n\t\t\twhile (V2[pass1] == '-') {\n\t\t\t\tcnt2++;\n\t\t\t\tpass1++;\n\t\t\t}\n\t\t\tif (cnt2 % 2 == 1) {\n\t\t\t\tW2 += '(';\n\t\t\t\tW2 += '-';\n\t\t\t\tW2 += V2[pass1];\n\t\t\t\tW2 += ')';\n\t\t\t}\n\t\t\telse {\n\t\t\t\tW2 += V2[pass1];\n\t\t\t}\n\t\t\tpass1++;\n\t\t}\n\t\tif (pass1 < V2.size()) {\n\t\t\tW2 += V2[pass1];\n\t\t\tpass1++;\n\t\t}\n\t}\n\n\tstring X1 = \"\", X2 = \"\";\n\n\tfor (int i = 0; i < power(2, MAX_NUM); i++) {\n\t\tX1 = \"\"; X2 = \"\";\n\t\tfor (int j = 0; j < MAX_NUM; j++) {\n\t\t\tint a1 = (i / power(2, j)) % 2;\n\t\t\tTR[j] = a1;\n\t\t}\n\n\t\tfor (int j = 0; j < V1.size(); j++) {\n\t\t\tfor (int k = 0; k < MAX_NUM; k++) {\n\t\t\t\tif (W1[j] == CH[k]) {\n\t\t\t\t\tX1 += NUM[TR[j]];\n\t\t\t\t\tgoto F;\n\t\t\t\t}\n\t\t\t}\n\t\t\tX1 += W1[j];\n\t\tF:;\n\t\t}\n\n\t\tfor (int j = 0; j < V2.size(); j++) {\n\t\t\tfor (int k = 0; k < MAX_NUM; k++) {\n\t\t\t\tif (W2[j] == CH[k]) {\n\t\t\t\t\tX2 += NUM[TR[j]];\n\t\t\t\t\tgoto G;\n\t\t\t\t}\n\t\t\t}\n\t\t\tX2 += W1[j];\n\t\tG:;\n\t\t}\n\n\t\tint res_1 = calc(X1);\n\t\tint res_2 = calc(X2);\n\t\tif (res_1 != res_2) {\n\t\t\tRES = false;\n\t\t}\n\t}\n\treturn RES;\n}\n\nint main() {\n\twhile (true) {\n\t\tcin >> S;\n\t\tif (S == \"#\") {\n\t\t\tbreak;\n\t\t}\n\t\tbool res = solve(S);\n\t\tif (res == true) {\n\t\t\tcout << \"YES\" << endl;\n\t\t}\n\t\telse {\n\t\t\tcout << \"NO\" << endl;\n\t\t}\n\t}\n\treturn 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include <algorithm>\n#include <cmath>\n#include <climits>\n#include <cstdio>\n#include <cstdlib>\n#include <cstring>\n#include <fstream>\n#include <iostream>\n#include <list>\n#include <map>\n#include <queue>\n#include <set>\n#include <sstream>\n#include <stack>\n#include <string>\n#include <vector>\n#include <cassert>\n#include <functional>\n\nusing namespace std;\n\n#define LOG(...) printf(__VA_ARGS__)\n//#define LOG(...)\n#define FOR(i,a,b) for(int i=(int)(a);i<(int)(b);++i)\n#define REP(i,n) for(int i=0;i<(int)(n);++i)\n#define ALL(a) (a).begin(),(a).end()\n#define RALL(a) (a).rbegin(),(a).rend()\n#define EXIST(s,e) ((s).find(e)!=(s).end())\n#define SORT(c) sort((c).begin(),(c).end())\n#define RSORT(c) sort((c).rbegin(),(c).rend())\n#define CLR(a) memset((a), 0 ,sizeof(a))\n\ntypedef long long ll;\ntypedef unsigned long long ull;\ntypedef vector<bool> vb;\ntypedef vector<int> vi;\ntypedef vector<ll> vll;\ntypedef vector<vb> vvb;\ntypedef vector<vi> vvi;\ntypedef vector<vll> vvll;\ntypedef pair<int, int> pii;\ntypedef pair<ll, ll> pll;\n\nconst int dx[] = { -1, 0, 1, 0 }; const int dy[] = { 0, 1, 0, -1 };\n\nstruct UnionFind {\n\tvector<int> v;\n\tUnionFind(int n) : v(n) { for (int i = 0; i < n; i++) v[i] = i; }\n\tint  find(int x) { return v[x] == x ? x : v[x] = find(v[x]); }\n\tvoid unite(int x, int y) { v[find(x)] = find(y); }\n};\nbool cal(string s, int &idx) {\n\tbool res = true;\n\tbool sub = false;\n\twhile (idx < (int)s.length()) {\n\t\tif (s[idx] == '(') {\n\t\t\tidx++;\n\t\t\tif (sub)\n\t\t\t\treturn !cal(s, idx);\n\t\t\telse\n\t\t\t\treturn cal(s, idx);\n\t\t}\n\t\tif (s[idx] == '-') {\n\t\t\tsub = !sub;\n\t\t\tidx++;\n\t\t}\n\t\tif (s[idx] == 'T' || s[idx] == 'F') {\n\t\t\tbool st1 = ((s[idx] == 'T' && !sub) || (s[idx] == 'F' && sub));\n\t\t\tidx++;\n\t\t\tsub = false;\n\t\t\tint calc;\n\t\t\tif (s[idx] == '*')\n\t\t\t\tcalc = 0;\n\t\t\tif (s[idx] == '+')\n\t\t\t\tcalc = 1;\n\t\t\tif (s[idx] == '>')\n\t\t\t\tcalc = 2;\n\t\t\tidx++;\n\t\t\tif (s[idx] == '-') {\n\t\t\t\tsub = !sub;\n\t\t\t\tidx++;\n\t\t\t}\n\t\t\tbool st2;\n\t\t\tif (s[idx] == 'T' || s[idx] == 'F') {\n\t\t\t\tst2 = ((s[idx] == 'T' && !sub) || (s[idx] == 'F' && sub));\n\t\t\t}\n\t\t\telse {\n\t\t\t\tidx++;\n\t\t\t\tst2 = cal(s, idx);\n\t\t\t}\n\t\t\tif (calc == 0)\n\t\t\t\tres = (st1&&st2);\n\t\t\tif (calc == 1)\n\t\t\t\tres = (st1 || st2);\n\t\t\tif (calc == 2)\n\t\t\t\tres = !(st1 && !st2);\n\t\t\tidx++;\n\t\t\treturn res;\n\t\t}\n\t\tif (s[idx] == ')') {\n\t\t\tidx++;\n\t\t\treturn res;\n\t\t}\n\t}\n\treturn res;\n}\n\nint main() {\n\tstring s;\n\twhile (cin >> s, s != \"#\") {\n\t\tstring ans = \"YES\";\n\t\tauto pos = s.find(\"->\");\n\t\twhile (pos != string::npos) {\n\t\t\ts.replace(pos, 2, \">\");\n\t\t\tpos = s.find(\"->\", pos + 1);\n\t\t}\n\t\tpos = s.find(\"--\");\n\t\twhile (pos != string::npos) {\n\t\t\ts.replace(pos, 2, \"\");\n\t\t\tpos = s.find(\"--\", pos + 1);\n\t\t}\n\t\tint eq;\n\t\tREP(k, s.length())\n\t\t\tif (s[k] == '=')\n\t\t\t\teq = k;\n\n\t\tREP(i, 2048) {\n\t\t\tstring s2 = s;\n\t\t\tREP(j, 11) {\n\t\t\t\tREP(k, s2.length()) {\n\t\t\t\t\tif (s2[k] == 'a' + j)\n\t\t\t\t\t\tif ((i >> j) & 1) {\n\t\t\t\t\t\t\ts2[k] = 'T';\n\t\t\t\t\t\t}\n\t\t\t\t\t\telse {\n\t\t\t\t\t\t\ts2[k] = 'F';\n\t\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t}\n\t\t\tint idx1 = 0, idx2 = 0;\n\t\t\tstring s3 = s2.substr(0, eq);\n\t\t\tstring s4= s2.substr(eq + 1, s2.length() - eq - 1);\n\t\t\tif (cal(s3, idx1) != cal(s3, idx2)) {\n\t\t\t\tans = \"NO\";\n\t\t\t\tbreak;\n\t\t\t}\n\t\t}\n\t\tcout << ans << endl;\n\t}\n}"
  },
  {
    "language": "C++",
    "code": "#include<iostream>\n#include<string>\nusing namespace std;\n\nstring s;\nint use;\n\nvoid ReplaceAll(string &s,string a, string b){\n  int p = s.find(a);\n  while(p!=string::npos){\n    s.replace(p,a.size(),b);\n    p = s.find(a);\n  }\n}\n\nbool parse(int l,int r){\n  int p = 0;\n  for(int i=l;i<r;i++){\n    if(s[i] == '(')p++;\n    if(s[i] == ')')p--;\n    if(!p){\n      if(s[i] == '*')return parse(l,i) && parse(i+1,r);\n      if(s[i] == '+')return parse(l,i) || parse(i+1,r);\n      if(s[i] == '-' && s[i+1] == '>')return !parse(l,i) || parse(i+2,r);\n    }\n  }\n\n  if(s[l] == '-')return !parse(l+1,r);\n  if(s[l] == '(' && s[r-1] == ')')return parse(l+1,r-1);\n  if(s[l] == 'T')return true;\n  if(s[l] == 'F')return false;\n  return ( ( use >> (s[l]-'a') ) & 1);\n}\n\nint main(){\n  while(cin >> s,s!=\"#\"){\n    ReplaceAll(s,\"--\",\"\");\n    int x = s.find(\"=\");\n    bool f = true;\n    for(use=0;use<(1<<11);use++){\n      f &= (parse(0,x) == parse(x+1,s.size()));\n      if(!f)break;\n    }\n    cout << (f?\"YES\\n\":\"NO\\n\");\n  }\n}"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\nusing namespace std;\n\nvector<string> opr{\"->\", \"+\", \"*\", \"-\"};\nvector<string> num{\"1\", \"2\", \"3\", \"4\"};\n\nbool calc(string exp, int bits) {\n    // cout << exp << endl;\n    if (exp == \"T\") return true;\n    if (exp == \"F\") return false;\n    if ('a' <= exp[0] && exp[0] <= 'k') return (bits & (1 << (exp[0] - 'a')) ? true : false);\n    if (exp[0] == '4') return !calc(string(exp.begin() + 1, exp.end()), bits);\n\n    int idx = -1;\n    for (int i = (exp[0] == '(' ? 1 : 0), count = 0, len = exp.size() - (exp[0] == '(' ? 1 : 0); i < len; i++) {\n        if (exp[i] == '(') count++;\n        else if (exp[i] == ')') count--;\n        if (count == 0 && '1' <= exp[i] && exp[i] <= '3') {\n            idx = i;\n            break;\n        }\n    }\n\n    if (exp[0] == '(') {\n        auto exp1 = string(exp.begin() + 1, exp.begin() + idx);\n        auto exp2 = string(exp.begin() + idx + 1, exp.end() - 1);\n        if (exp[idx] == '1') return !(calc(exp1, bits) && !calc(exp2, bits));\n        if (exp[idx] == '2') return calc(exp1, bits) | calc(exp2, bits);\n        if (exp[idx] == '3') return calc(exp1, bits) & calc(exp2, bits);\n    }\n}\n\nvoid solve(string str) {\n    bool flag = true;\n    for (int i = 0, len = opr.size(); i < len; i++) {\n        auto idx = str.find(opr[i]);\n        while (idx != string::npos) {\n            str.replace(idx, (int)opr[i].size(), num[i]);\n            idx = str.find(opr[i]);\n        }\n    }\n    int eq_idx = str.find(\"=\");\n\n    string exp1 = string(str.begin(), str.begin() + eq_idx);\n    string exp2 = string(str.begin() + eq_idx + 1, str.end());\n    for (int i = 0; i < (1 << 11); i++) {\n        if (calc(exp1, i) != calc(exp2, i)) {\n            flag = false;\n            break;\n        }\n    }\n\n    if (flag) cout << \"YES\" << endl;\n    else cout << \"NO\" << endl;\n}\n\nint main() {\n    string str;\n    while (cin >> str, str != \"#\") solve(str);\n\n    return 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include<bits/stdc++.h>\nusing namespace std;\ntypedef string::const_iterator state;\n\nstring str;\nstring A,B;\n\nstring conv(string &S,int bit){\n    string ret=S;\n    for(int i=0;i<S.size();i++){\n        if('a'<=S[i]&&'k'>=S[i]){\n            ret[i]=((bit>>(S[i]-'a')&1)?'1':'0');\n        }\n    }\n    return ret;\n}\nint expression(state &);\n\nint number(state &b){\n    int ret=0;\n    while(isdigit(*b)){\n        ret=ret*10+*b-'0';\n        b++;\n    }\n    return ret;\n}\n\nint fact(state &b){\n    int ret;\n    if(*b=='('){\n        b++;\n        ret=expression(b);\n        b++;\n    }\n    else{\n        ret=number(b);\n    }\n    return ret;\n}\n\nint latte(state &b){\n    if(*b=='-'){\n        b++;\n        return 1-expression(b);\n    }\n    else return fact(b);\n}\n\nint expression(state &b){\n    int ret=latte(b);\n    while(true){\n        if(*b=='+'){\n            b++;\n            ret=max(ret,latte(b));\n        }\n        else if(*b=='*'){\n            b++;\n            ret=min(ret,latte(b));\n        }\n        else if(*b=='-'){\n            b++;b++;\n            ret=(ret<=latte(b)?1:0);\n        }\n        else break;\n    }\n    return ret;\n}\n\nvoid solve(){\n    for(int i=0;i<str.size();i++){\n        if(str[i]=='T')str[i]='1';\n        if(str[i]=='F')str[i]='0';\n    }\n\n    int idx=str.find('=');\n    A=str.substr(0,idx);\n    B=str.substr(idx+1,str.size()-idx-1);\n    A+=\"=\";B+=\"=\";\n\n    for(int i=0;i<(1<<11);i++){\n        string a=conv(A,i),b=conv(B,i);\n        state sa=a.begin(),sb=b.begin();\n        if(expression(sa)!=expression(sb)){\n            cout<<\"NO\"<<endl;\n            return;\n        }\n    }\n    cout<<\"YES\"<<endl;\n}\n\nint main(){\n    while(cin>>str,str!=\"#\")solve();\n    return 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include <string>\n#include <iostream>\nusing namespace std;\nint pos; string t, d1, d2;\nbool solve(string s) {\n\tswitch (s[pos++]) {\n\tcase 'T': return true;\n\tcase 'F': return false;\n\tcase '-': return !solve(s); break;\n\tcase '(':\n\t\tbool a = solve(s), b;\n\t\tswitch (s[pos++]) {\n\t\tcase '+': b = a || solve(s); break;\n\t\tcase '*': b = a && solve(s); break;\n\t\tcase '-': pos++; b = !a || solve(s); break;\n\t\t}\n\t\tpos++;\n\t\treturn b;\n\t}\n\treturn false;\n}\nint main() {\n\twhile (cin >> t) {\n\t\tif (t == \"#\") break;\n\t\tbool flag1 = false; d1 = \"\"; d2 = \"\";\n\t\tfor (int i = 0; i < t.size(); i++) {\n\t\t\tif (t[i] == '=') flag1 = true, i++;\n\t\t\tif (!flag1) d1 += t[i];\n\t\t\telse d2 += t[i];\n\t\t}\n\t\tbool flag = true;\n\t\tfor (int i = 0; i < 2048; i++) {\n\t\t\tstring d3 = d1, d4 = d2;\n\t\t\tfor (int j = 0; j < 11; j++) {\n\t\t\t\tfor (int k = 0; k < d3.size(); k++) {\n\t\t\t\t\tif (d3[k] == j + 97) {\n\t\t\t\t\t\td3[k] = (i & (1 << j) ? 'T' : 'F');\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t\tfor (int k = 0; k < d4.size(); k++) {\n\t\t\t\t\tif (d4[k] == j + 97) {\n\t\t\t\t\t\td4[k] = (i & (1 << j) ? 'T' : 'F');\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t}\n\t\t\tpos = 0; bool p1 = solve(d3); pos = 0; bool p2 = solve(d4);\n\t\t\tif (p1 != p2) {\n\t\t\t\tflag = false;\n\t\t\t}\n\t\t}\n\t\tprintf(\"%s\\n\", flag ? \"YES\" : \"NO\");\n\t}\n\treturn 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include<iostream>\n#include<string>\n#define MAX 11\nusing namespace std;\nbool o;\nvoid rec(string s){\n  if(!o) return;\n  //cout << s << endl;\n  bool f;\n  int p;\n\n  /*\n  while(s.find(\"-0\")!=-1){\n    p=s.find(\"-0\");\n    s[p]='1';s[p+1]=' ';\n    f=true;\n  }\n  while(s.find(\"-1\")!=-1){\n    p=s.find(\"-1\");\n    s[p]='0';s[p+1]=' ';\n    f=true;\n  }\n  while(s.find(\"(0*0)\")!=-1){\n    p=s.find(\"(0*0)\");\n    s[p]='0';s[p+1]=' ';s[p+2]=' ';s[p+3]=' ';s[p+4]=' ';\n    f=true;\n  }\n  while(s.find(\"(0*1)\")!=-1){\n    p=s.find(\"(0*1)\");\n    s[p]='0';s[p+1]=' ';s[p+2]=' ';s[p+3]=' ';s[p+4]=' ';\n    f=true;\n  }\n  while(s.find(\"(1*0)\")!=-1){\n    p=s.find(\"(1*0)\");\n    s[p]='0';s[p+1]=' ';s[p+2]=' ';s[p+3]=' ';s[p+4]=' ';\n    f=true;\n  }\n  while(s.find(\"(1*1)\")!=-1){\n    p=s.find(\"(1*1)\");\n    s[p]='1';s[p+1]=' ';s[p+2]=' ';s[p+3]=' ';s[p+4]=' ';\n    f=true;\n  }\n  while(s.find(\"(0+0)\")!=-1){\n    p=s.find(\"(0+0)\");\n    s[p]='0';s[p+1]=' ';s[p+2]=' ';s[p+3]=' ';s[p+4]=' ';\n    f=true;\n  }\n  while(s.find(\"(0+1)\")!=-1){\n    p=s.find(\"(0+1)\");\n    s[p]='1';s[p+1]=' ';s[p+2]=' ';s[p+3]=' ';s[p+4]=' ';\n    f=true;\n  }\n  while(s.find(\"(1+0)\")!=-1){\n    p=s.find(\"(1+0)\");\n    s[p]='1';s[p+1]=' ';s[p+2]=' ';s[p+3]=' ';s[p+4]=' ';\n    f=true;\n  }\n  while(s.find(\"(1+1)\")!=-1){\n    p=s.find(\"(1+1)\");\n    s[p]='1';s[p+1]=' ';s[p+2]=' ';s[p+3]=' ';s[p+4]=' ';\n    f=true;\n  }\n  while(s.find(\"(0->0)\")!=-1){\n    p=s.find(\"(0->0)\");\n    s[p]='1';s[p+1]=' ';s[p+2]=' ';s[p+3]=' ';s[p+4]=' ';s[p+5]=' ';\n    f=true;\n  }\n  while(s.find(\"(0->1)\")!=-1){\n    p=s.find(\"(0->1)\");\n    s[p]='1';s[p+1]=' ';s[p+2]=' ';s[p+3]=' ';s[p+4]=' ';s[p+5]=' ';\n    f=true;\n  }\n  while(s.find(\"(1->0)\")!=-1){\n    p=s.find(\"(1->0)\");\n    s[p]='0';s[p+1]=' ';s[p+2]=' ';s[p+3]=' ';s[p+4]=' ';s[p+5]=' ';\n    f=true;\n  }\n  while(s.find(\"(1->1)\")!=-1){\n    p=s.find(\"(1->1)\");\n    s[p]='1';s[p+1]=' ';s[p+2]=' ';s[p+3]=' ';s[p+4]=' ';s[p+5]=' ';\n    f=true;\n  }\n  */\n  if(f){\n    string b;\n    for(int i=0;i<s.size();i++) if(s[i]!=' ') b+=s[i];\n    rec(b);\n  }else{\n    if(s[0]!=s[2]) o=false;\n    return;\n  }\n}\nvoid init(int n,string s){\n  int i,j;\n  for(i=0;i<s.size();i++){\n    for(j=0;j<=MAX;j++){\n      if(s[i]=='a'+j) s[i]='0'+(n>>j&1);\n      if(s[i]=='T') s[i]='1';\n      if(s[i]=='F') s[i]='0';\n    }\n  }\n  rec(s);\n}\nint main(){\n  string s;\n  while(cin >> s,s!=\"#\"){\n    o=true;\n    int i;\n    for(i=0;i<(1<<MAX);i++)\n      init(i,s);\n    cout << (o?\"YES\":\"NO\") << endl;\n  }\n  return 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include <iostream>\n#include <stdio.h>\n#include <algorithm>\n#include <vector>\n#include <queue>\n#include <numeric>\n#include <string>\n#include <string.h>\n#include <map>\n#include <set>\n#include <functional>\n#include <complex>\n#include <stack>\n#include <tuple>\n\n#define ll long long int\n\nusing namespace std;\n\nconst int INF = (1<<30) - 1;\n\nbool formula(string str, int &vals){\n    char c = str[0];\n    \n    if(c == 'T')\n        return true;\n    else if(c == 'F')\n        return false;\n    \n    if('a'<=c && c<='k')\n        return vals<<(c-'a')&1;\n    \n    //substr???string &?????¨NG?\n    if(c == '-')\n        return !formula(str.substr(1, str.size()-1), vals);\n\n    //c == '('\n    int count = 0;\n    for(int i=1; i<str.size(); i++){\n        char c = str[i];\n        \n        if(c == '(')\n            count++;\n        if(c == ')')\n            count--;\n        if(count == 0){\n            if(c == '*'){\n                int s = str.find(\"*\");\n                string left = str.substr(1, s-1);\n                string right = str.substr(s+1, str.size()-s-2);\n                return formula(left, vals) && formula(right, vals);\n            }\n            if(c == '+'){\n                int s = str.find(\"+\");\n                string left = str.substr(1, s-1);\n                string right = str.substr(s+1, str.size()-s-2);\n                return formula(left, vals) || formula(right, vals);\n            }\n            if(str[i] == '-' && str[i+1] == '>'){\n                int s = str.find(\"->\");\n                string left = str.substr(1, s-1);\n                string right = str.substr(s+2, str.size()-s-3);\n                return !(formula(left, vals)) || formula(right, vals);\n            }\n        }\n    }\n    //No Implement\n    return true;\n}\n\nint main(){\n    ios::sync_with_stdio(false);\n    cin.tie(0);\n    \n    string equation;\n    while(cin>>equation, equation!=\"#\"){\n        int s = equation.find(\"=\");\n        string left = equation.substr(0, s);\n        string right = equation.substr(s+1, equation.size()-s-1);\n        \n        bool is_identity = true;\n        for(int i=0; i<1<<11; i++){\n            is_identity &= formula(left, i)==formula(right, i);\n        }\n            \n        cout << (is_identity ? \"YES\" : \"NO\") << endl;\n    }\n    return 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include <iostream>\n#include <string>\n\nusing namespace std;\n\nbool eval(int val, string str, int &i){\n\tif( 'a' <= str[i] && str[i] <= 'k' ){\n\t\treturn val & (1<<(str[i++]-'a'));\n\t}else if( str[i] == 'T' ){\n\t\treturn true;\n\t}else if( str[i] == 'F' ){\n\t\treturn false;\n\t}else if( str[i] == '-' && str[i+1] != '>' ){\n\t\treturn !eval(val, str, ++i);\n\t}else if( str[i] == '(' ){\n\t\tbool ret = eval(val, str, ++i);\n\t\twhile( i<str.length() ){\n\t\t\tif( str[i] == '+' ) ret |= eval(val, str, ++i);\n\t\t\telse if( str[i] == '*' ) ret &= eval(val, str, ++i);\n\t\t\telse if( str[i] == '-' && str[i+1] == '>'){\n\t\t\t\ti++;\n\t\t\t\tret = !ret | eval(val, str, ++i);\n\t\t\t}\n\t\t\telse if( str[i] == ')' ) break;\n\t\t\telse i++;\n\t\t}\n\t\ti++;\n\t\treturn ret;\n\t}\n\treturn false;\n}\n\nint main(){\n\tstring in;\n\twhile(cin>>in, in[0]!='#'){\n\t\tstring str1 = \"(\" + in.substr(0, in.find(\"=\")) + \")\";\n\t\tstring str2 = \"(\" + in.substr(in.find(\"=\")+1) + \")\";\n\t\tbool f = true;\n\t\tfor(int val=0, i=0, j=0; val<(1<<11); val++, i=0, j=0){\n\t\t\tif( eval(val, str1, i) != eval(val, str2, j) )\n\t\t\t\tf = false;\n\t\t}\n\t\tcout << (f?\"YES\":\"NO\") << endl;\n\t}\n\treturn 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include <iostream>\n#include <string>\n#include <algorithm>\nusing namespace std;\n\nbool formula(string &s, int &p)\n{\n    if (s[p] == 'T') {\n\t++p;\n\treturn true;\n    } else if (s[p] == 'F') {\n\t++p;\n\treturn false;\n    } else if (s[p] == '-') {\n\t++p;\n\treturn !formula(s, p);\n    } else if (s[p] == '(') {\n\t++p;\n\tbool lhs = formula(s, p);\n\tif (s[p] == '*') {\n\t    ++p;\n\t    bool rhs = formula(s, p);\n\t    ++p;\n\t    return (lhs&&rhs);\n\t} else if (s[p] == '+') {\n\t    ++p;\n\t    bool rhs = formula(s, p);\n\t    ++p;\n\t    return (lhs||rhs);\n\t} else {\n\t    ++p;\n\t    ++p;\n\t    bool rhs = formula(s, p);\n\t    ++p;\n\t    if (lhs && !rhs)\n\t\treturn false;\n\t    else\n\t\treturn true;\n\t}\n    }\n}\n\nbool equation(string& s, int& p)\n{\n    bool lhs = formula(s, p);\n    ++p;\n    bool rhs = formula(s, p);\n\n    //cout << lhs << \" \" << rhs << endl;\n    if (lhs == rhs)\n\treturn true;\n    else\n\treturn false;\n}\n\nint main()\n{\n    const string V = \"abcdefghijk\";\n\n    string s;\n    while (cin >> s) {\n\tif (s == \"#\")\n\t    break;\n\n\tbool ans = true;\n\tfor (int i = 0; i < (1 <<11); ++i) {\n\t    string t = s;\n\t    for (int j = 0; j < t.size(); ++j) {\n\t\tif (binary_search(V.begin(), V.end(), t[j])) {\n\t\t    if (i & (1 << (t[j]-'a')))\n\t\t\tt[j] = 'T';\n\t\t    else\n\t\t\tt[j] = 'F';\n\t\t}\n\t    }\n\n\t    int p = 0;\n\t    if (!equation(t, p))\n\t\tans = false;\n\t}\n\n\tif (ans)\n\t    cout << \"YES\" << endl;\n\telse\n\t    cout << \"NO\" << endl;\n    }\n    return 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\nusing namespace std;\n\nusing State = string::const_iterator;\n\nconst int n = 11;\nint val[n];\n\nbool equation(State &itr);\nint formula(State &itr);\nint factor(State &itr);\nint variable(State &itr);\n\nvoid next_char(State &itr, char expected){\n    if(*itr == expected){\n        itr++;\n    }\n    else{\n        cout << \"Error: expected \" << expected << \" but \" << *itr << endl;\n        while(*itr){\n            cout << *itr;\n            itr++;\n        }\n        cout << endl;\n    }\n}\n\nbool equation(State &itr){\n    int lhs, rhs;\n    lhs = formula(itr);\n    next_char(itr, '=');\n    rhs = formula(itr);\n    return lhs == rhs;\n}\n\nint formula(State &itr){\n    if(isalpha(*itr)){\n        return variable(itr);\n    }else if(*itr == '-'){\n        next_char(itr, '-');\n        return !formula(itr);\n    }else{\n        next_char(itr, '(');\n        int x = formula(itr);\n        if(*itr == '*'){\n            next_char(itr,'*');\n            x &= formula(itr);\n        }else if(*itr == '+'){\n            next_char(itr,'+');\n             x |= formula(itr);\n        }else if(*itr == '-'){\n            next_char(itr,'-');\n            next_char(itr,'>');\n            x = (!x | (x & formula(itr)));\n        }else{\n            // error\n            return -1;\n        }\n        next_char(itr, ')');\n        return x;\n    }\n}\n\nint variable(State &itr){\n    int res = -1;\n    if(isalpha(*itr)){\n        if(*itr == 'T') res = 1;\n        else if(*itr == 'F') res = 0;\n        else res = val[*itr-'a'];\n    }else{\n        // error\n    }\n    itr++;\n    return res;\n}\n\nint solve(){\n    string s;\n    getline(cin, s);\n    if(s == \"#\") return 1;\n    bool ok = true;\n    for(int S=0;S<1<<n;S++){\n        for(int i=0;i<n;i++){\n            val[i] = (S>>i)&1;\n        }\n        State begin = s.begin();\n        ok &= equation(begin);\n        if(!ok)break;\n    }\n    cout << (ok ? \"YES\" : \"NO\") << endl;\n    return 0;\n}\n\nint main(){\n    while(solve()==0);\n    return 0;\n}\n\n"
  },
  {
    "language": "C++",
    "code": "#include <vector>\n#include <iostream>\n#include <utility>\n#include <algorithm>\n#include <string>\n#include <deque>\n#include <queue>\n#include <functional>\n#include <cmath>\n#include <iomanip>\n#include <map>\n#include <numeric>\n#include <list>\n#include <assert.h>\n#include <math.h>\n#include <valarray>\n#include <stdio.h>\n#include <algorithm>\n#include <set>\n#include <complex>\n#include <list>\n\nusing namespace std;\ntypedef long long int LL;\ntypedef pair<long long int, long long int> pii;\ntypedef pair<double, double> pdd;\n\n#define SORT(c) sort((c).begin(),(c).end())\n#define BACKSORT(c) sort((c).begin(),(c).end(),std::greater<LL>())\n#define FOR(i,a,b) for(LL i=(a);i<(b);++i)\n#define REP(i,n)  FOR(i,0,n)\n\nbool equation(string& s, int& i,vector<bool>& v);\nbool formula(string& s, int& i, vector<bool>& v);\n\nbool equation(string& s, int& i, vector<bool>& v) {\n\tbool a = formula(s, i,v);\n\ti++;\n\tbool b = formula(s, i, v);\n\treturn a == b;\n}\n\nbool formula(string& s, int& i, vector<bool>& v) {\n\tif (s[i] == 'T') {\n\t\ti++;\n\t\treturn true;\n\t}\n\telse\n\t\tif (s[i] == 'F') {\n\t\t\ti++;\n\t\t\treturn false;\n\n\t\t}else\n\t\t\tif ('a' <= s[i] && s[i] <= 'k') {\n\t\t\t\tint aa = s[i] - 'a';\n\t\t\t\ti++;\n\t\t\t\treturn v[aa];\n\t\t\t}else\n\t\t\t\tif (s[i] == '-') {\n\t\t\t\t\ti++;\n\t\t\t\t\tbool a = formula(s, i, v);\n\t\t\t\t\treturn !a;\n\t\t\t\t}\n\t\t\t\telse {\n\t\t\t\t\ti++;\n\t\t\t\t\tbool a = formula(s, i, v);\n\t\t\t\t\tchar op = s[i];\n\t\t\t\t\tif (op == '-') {\n\t\t\t\t\t\ti++;\n\t\t\t\t\t}\n\t\t\t\t\ti++;\n\t\t\t\t\tbool b = formula(s, i, v);\n\t\t\t\t\ti++;\n\t\t\t\t\tif (op == '*') {\n\t\t\t\t\t\treturn a&&b;\n\t\t\t\t\t}else\n\t\t\t\t\t\tif (op == '+') {\n\t\t\t\t\t\t\treturn a || b;\n\t\t\t\t\t\t}\n\t\t\t\t\t\telse {\n\t\t\t\t\t\t\treturn (!a) || b;\n\t\t\t\t\t\t}\n\t\t\t\t}\n}\n\n\nint main()\n{\n\twhile (true) {\n\t\tstring ss;\n\t\tcin >> ss;\n\t\tif (ss[0] == '#') { break; }\n\t\tbool flag = true;\n\t\tfor (int j = 0; j < 2048; ++j) {\n\t\t\tint bai = 1;\n\t\t\tvector<bool> v(9999, false);\n\t\t\tfor (int k = 0; k < 11; ++k) {\n\t\t\t\tif (j % (bai * 2) - j % (bai * 1) == 0) {\n\t\t\t\t\tv[k] = false;\n\t\t\t\t}\n\t\t\t\telse {\n\t\t\t\t\tv[k] = true;\n\t\t\t\t}\n\t\t\t\tbai *= 2;\n\t\t\t}\n\t\t\t\tint index = 0;\n\t\t\t\tif (!equation(ss, index, v)) {\n\t\t\t\t\tflag = false;\n\t\t\t\t\tbreak;\n\t\t\t\t\t}\n\t\t\t\n\t\t}\n\t\tif (flag) {\n\t\t\tcout << \"YES\" << endl;\n\t\t}\n\t\telse {\n\t\t\tcout << \"NO\" << endl;\n\t\t}\n\t}\n\n}"
  },
  {
    "language": "C++",
    "code": "#include <iostream>\n#include <string>\n#include <cmath>\n  \nusing namespace std;\n  \nint var[11];\n  \nint solve();\nint getVal(int &itr, const string &form);\n  \nint main(void) {\n  \n    while (solve()){}\n  \n    return 0;\n}\n  \nint solve() {\n  \n    //  input\n    string eq,exp[2];\n    cin >> eq;\n  \n    //  the end of dataset\n    if (eq == \"#\") { return 0; }\n  \n    int sep = eq.find(\"=\");\n  \n        //  lfs\n        exp[0] = eq.substr(0, sep);\n        //  rhs\n        exp[1] = eq.substr(sep+1, string::npos);\n  \n    //  brute force\n    bool isEqual = true;\n    for (int i = 0; i < (1 << 12); i++) {\n  \n        for (int j = 0; j < 11; j++) {\n            if (i & (1 << j)) {\n                var[j] = 1;\n            }\n            else {\n                var[j] = 0;\n            }\n        }\n  \n        int itr[2] = { -1, -1};\n  \n        int rhs, lhs;\n        lhs = getVal(itr[0], exp[0]);\n        rhs = getVal(itr[1], exp[1]);\n        isEqual &= ( lhs == rhs );\n  \n    }\n  \n    //  output\n  \n    if (isEqual) {\n        cout << \"YES\" << endl;\n    }\n    else {\n        cout << \"NO\" << endl;\n    }\n  \n  \n    return 1;\n}\n  \nint getVal(int &itr, const string &form) {\n  \n    //  formula?????§?£???\n    ++itr;\n    if (form[itr] == 'T') { return 1; }\n    if (form[itr] == 'F') { return 0; }\n    if ('a' <= form[itr] && form[itr] <= 'k') { return var[form[itr]-'a']; }\n  \n    // operator -\n    if (form[itr] == '-' && form[itr+1] != '>' ) {\n        return 1 - getVal(itr, form);\n    }\n  \n    if (form[itr] == '(') {\n  \n        //  binary operator\n        int lhs, rhs;\n        char ope;\n  \n        lhs = getVal(itr, form);\n  \n        itr++;\n        ope = form[itr];\n        if (ope == '-') { itr++; }\n  \n        rhs = getVal(itr, form);\n  \n        //  ')'\n        itr++;\n  \n        if (ope == '+') {\n            return max(lhs, rhs);\n        }\n        else if (ope == '*') {\n            return min(lhs, rhs);\n        }\n        else if (ope == '-') {\n            if (lhs == 1 && rhs == 0) { return 0; }\n            else return 1;\n        }\n  \n    }\n  \n    return 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include <functional>\n#include <iostream>\n#include <string>\n#include <unordered_set>\n#include <vector>\n#include <memory>\n#define loop(i, a, n) for (int i = (a); i < (n); i++)\n#define rep(i, n) loop(i, 0, n)\ntemplate<typename A> using F = std::function<A>;\nusing namespace std;\n \ntemplate<typename T> struct ParseResult {\n  bool succeeded;\n  T object;\n  int pos;\n  ParseResult(const bool succeeded, const T &object, const int pos) : succeeded(succeeded), object(object), pos(pos) {}\n  friend std::ostream &operator<<(std::ostream &os, const ParseResult<T> &p) { return os << '{' << (p.succeeded ? \"true\" : \"false\") << ',' << p.object << ',' << p.pos << '}'; }\n};\n \ntemplate<typename T> using Parser = std::function<ParseResult<T>(const std::string&, int)>;\n \nParser<std::string> token(std::string s) {\n  const auto n = s.size();\n  return [n = std::move(n), s = std::move(s)](const std::string &target, const int pos) {\n    if (target.size() < n) return ParseResult<std::string>(false, {}, pos);\n    return target.substr(pos, n) == s ? ParseResult<std::string>(true, s, pos + n) : ParseResult<std::string>(false, {}, pos);\n  };\n}\n \ntemplate<typename T> Parser<T> operator||(Parser<T> p1, Parser<T> p2) {\n  return [p1 = std::move(p1), p2 = std::move(p2)](const std::string &target, const int pos) {\n    auto r = p1(target, pos);\n    if (r.succeeded) return r;\n    r = p2(target, pos);\n    if (r.succeeded) return r;\n    return ParseResult<T>(false, {}, pos);\n  };\n}\n \ntemplate<typename T1, typename T2> Parser<std::pair<T1, T2>> operator+(Parser<T1> p1, Parser<T2> p2) {\n  return[p1 = std::move(p1), p2 = std::move(p2)](const std::string &target, const int pos) {\n    auto r1 = p1(target, pos);\n    if (!r1.succeeded) return ParseResult<std::pair<T1, T2>>(false, {}, pos);\n    auto r2 = p2(target, r1.pos);\n    if (!r2.succeeded) return ParseResult<std::pair<T1, T2>>(false, {}, pos);\n    return ParseResult<std::pair<T1, T2>>(true, {r1.object, r2.object}, r2.pos);\n  };\n}\n \ntemplate<typename T1, typename T2> Parser<T2> operator>>(Parser<T1> p1, Parser<T2> p2) {\n  return [p1 = std::move(p1), p2 = std::move(p2)](const std::string &target, const int pos) {\n    auto r1 = p1(target, pos);\n    if (!r1.succeeded) return ParseResult<T2>(false, {}, pos);\n    auto r2 = p2(target, r1.pos);\n    if (!r2.succeeded) return ParseResult<T2>(false, {}, pos);\n    return ParseResult<T2>(true, r2.object, r2.pos);\n  };\n}\n \ntemplate<typename T1, typename T2> Parser<T1> operator<<(Parser<T1> p1, Parser<T2> p2) {\n  return [p1 = std::move(p1), p2 = std::move(p2)](const std::string &target, const int pos) {\n    auto r1 = p1(target, pos);\n    if (!r1.succeeded) return ParseResult<T1>(false, {}, pos);\n    auto r2 = p2(target, r1.pos);\n    if (!r2.succeeded) return ParseResult<T1>(false, {}, pos);\n    return ParseResult<T1>(true, r1.object, r2.pos);\n  };\n}\n \nParser<char> oneOf(const std::string &s) {\n  std::unordered_set<char> d;\n  for (auto &c : s) d.insert(c);\n  return [d = std::move(d)](const std::string &target, const int pos) {\n    if (target.size() <= pos) return ParseResult<char>(false, {}, pos);\n    char c = target[pos];\n    return d.count(c) ? ParseResult<char>(true, c, pos + 1) : ParseResult<char>(false, {}, pos);\n  };\n}\n \ntemplate<typename T, typename S, typename F> Parser<S> fmap(Parser<T> p, F &&f) {\n  return [p = std::move(p), f = std::forward<F>(f)](const std::string &target, const int pos) {\n    auto r = p(target, pos);\n    return r.succeeded ? ParseResult<S>(true, f(r.object), r.pos) : ParseResult<S>(false, {}, r.pos);\n  };\n}\n \ntemplate<typename T, typename F> Parser<T> lazy(const F &f) {\n  bool instantiated = false;\n  Parser<T> p;\n  return [f = std::move(f), p = std::move(p), instantiated = std::move(instantiated)](const std::string &target, const int pos) mutable {\n    if (!instantiated) {\n      p = f();\n      instantiated = true;\n    }\n    return p(target, pos);\n  };\n}\ntemplate<typename T> Parser<T> make_view(Parser<T> &&f) {\n  return [f = std::make_shared<Parser<T>>(std::move(f))](const std::string &target, const int pos) {\n    return (*f)(target, pos);\n  };\n}\n \nstruct SyntaxTree {\n  string op;\n  char value;\n  vector<SyntaxTree> children;\n  SyntaxTree() {}\n  SyntaxTree(const string &op, const char value, const vector<SyntaxTree> &children) : op(op), value(value), children(children) {}\n};\n \nint main() {\n  Parser<SyntaxTree> formulaP = make_view<SyntaxTree>(lazy<SyntaxTree>([&]() {\n    auto andP = fmap<pair<SyntaxTree, SyntaxTree>, SyntaxTree>((token(\"(\") >> formulaP << token(\"*\")) + (formulaP << token(\")\")), [](auto &o) { return SyntaxTree(\"*\", {}, {o.first, o.second}); });\n    auto orP = fmap<pair<SyntaxTree, SyntaxTree>, SyntaxTree>((token(\"(\") >> formulaP << token(\"+\")) + (formulaP << token(\")\")), [](auto &o) { return SyntaxTree(\"+\", {}, {o.first, o.second}); });\n    auto impP = fmap<pair<SyntaxTree, SyntaxTree>, SyntaxTree>((token(\"(\") >> formulaP << token(\"->\")) + (formulaP << token(\")\")), [](auto &o) { return SyntaxTree(\"->\", {}, {o.first, o.second}); });\n    auto notP = fmap<SyntaxTree, SyntaxTree>(token(\"-\") >> formulaP, [](auto &o) { return SyntaxTree(\"-\", {}, {o}); });\n    auto valP = fmap<char, SyntaxTree>(oneOf(\"abcdefghijkTF\"), [](char x) { return SyntaxTree({}, x, {}); });\n    return andP || orP || impP || notP || valP;\n  }));\n  auto equationP = (formulaP << token(\"=\")) + formulaP;\n  string s;\n  while (cin >> s, s != \"#\") {\n    auto r = equationP(s, 0);\n    bool isValid = true;\n    rep(i, 1 << 11) {\n      auto toBool = [&](char c) -> bool {\n        if (c == 'T') return true;\n        if (c == 'F') return false;\n        return i >> (c - 'a') & 1;\n      };\n      F<bool(const SyntaxTree&)> evalF = [&](const SyntaxTree &f) {\n        switch (f.children.size()) {\n          case 0: return toBool(f.value);\n          case 1: return !evalF(f.children[0]);\n          case 2:\n            if (f.op == \"*\") return evalF(f.children[0]) && evalF(f.children[1]);\n            if (f.op == \"+\") return evalF(f.children[0]) || evalF(f.children[1]);\n            if (f.op == \"->\") return !evalF(f.children[0]) || evalF(f.children[1]);\n        }\n      };\n      isValid &= evalF(r.object.first) == evalF(r.object.second);\n    }\n    cout << (isValid ? \"YES\" : \"NO\") << endl;\n  }\n}"
  },
  {
    "language": "C++",
    "code": "#include <iostream>\n#include <stdio.h>\n#include <algorithm>\n#include <vector>\n#include <queue>\n#include <numeric>\n#include <string>\n#include <string.h>\n#include <map>\n#include <set>\n#include <functional>\n#include <complex>\n#include <stack>\n#include <tuple>\n\n#define ll long long int\n\nusing namespace std;\n\nconst int INF = (1<<30) - 1;\n\nbool formula(string str, int &vals){\n    char c = str[0];\n    \n    if(c == 'T')\n        return true;\n    else if(c == 'F')\n        return false;\n    \n    if('a'<=c && c<='k')\n        return vals<<(c-'a')&1;\n    \n    //substr???string &?????¨NG?\n    if(c == '-')\n        return ~formula(str.substr(1, str.size()-1), vals);\n\n    //c == '('\n    int count = 0;\n    for(int i=1; i<str.size(); i++){\n        char c = str[i];\n        \n        if(c == '(')\n            count++;\n        if(c == ')')\n            count--;\n        if(count == 0){\n            if(c == '*'){\n                int s = str.find(\"*\");\n                string left = str.substr(1, s-1);\n                string right = str.substr(s+1, str.size()-s-2);\n                return formula(left, vals) & formula(right, vals);\n            }\n            if(c == '+'){\n                int s = str.find(\"+\");\n                string left = str.substr(1, s-1);\n                string right = str.substr(s+1, str.size()-s-2);\n                return formula(left, vals) | formula(right, vals);\n            }\n            if(str[i] == '-' && str[i+1] == '>'){\n                int s = str.find(\"->\");\n                string left = str.substr(1, s-1);\n                string right = str.substr(s+2, str.size()-s-3);\n                return ~(formula(left, vals)) | formula(right, vals);\n            }\n        }\n    }\n    //No Implement\n    return true;\n}\n\nint main(){\n    ios::sync_with_stdio(false);\n    cin.tie(0);\n    \n    string equation;\n    while(cin>>equation, equation!=\"#\"){\n        int s = equation.find(\"=\");\n        string left = equation.substr(0, s);\n        string right = equation.substr(s+1, equation.size()-s-1);\n        \n        bool is_identity = true;\n        for(int i=0; i<1<<11; i++){\n            is_identity &= formula(left, i)==formula(right, i);\n        }\n            \n        cout << (is_identity ? \"YES\" : \"NO\") << endl;\n    }\n    return 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\nusing namespace std;\nstring R(string s,string t,string u){\nint p=s.find(t);\nwhile(p!=string::npos){\ns.replace(p,t.size(),u);\np=s.find(t,p+u.size());\n}\nreturn s;\n}\nstring B[14]={\"-T\",\"-F\",\"(T*T)\",\"(T*F)\",\"(F*T)\",\"(F*F)\",\"(T+T)\",\"(T+F)\",\"(F+T)\",\"(F+F)\",\"(T->T)\",\"(T->F)\",\"(F->T)\",\"(F->F)\"},A[14]={\"F\",\"T\",\"T\",\"F\",\"F\",\"F\",\"T\",\"T\",\"T\",\"F\",\"T\",\"F\",\"T\",\"T\"};\nstring k(string s){\nwhile(s!=\"T\" && s!=\"F\")for(int i=0;i<14;i++)s=R(s,B[i],A[i]);\nreturn s;\n}\nint main(){\nfor(string S,s;cin>>S,S!=\"#\";){\nint f=1;\nmap<string,int>M;\nfor(int b=0;b<2048;b++){\ns=S;\nfor(int i=1,c='a';c<'l';i*=2,c++)replace(s.begin(),s.end(),(char)c,(b&i?'T':'F'));\nif(M[s]==1)continue;\nelse M[s]=1;\nif(k(s.substr(0,s.find(\"=\")))!=k(s.substr(s.find(\"=\")+1)))f=0;\n}\ncout<<(f?\"YES\":\"NO\")<<endl;\n}\n}\n"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\n\nusing namespace std;\n\n#define rep(i, a, b) for (auto i = (a); i < (b); ++i)\n\ntypedef string::const_iterator State;\n\nint factor(State &begin);\n\nint number(State &begin) {\n  int ret = 0;\n  while (isdigit(*begin)) {\n    ret *= 10;\n    ret += *begin - '0';\n    begin++;\n  }\n  return ret;\n}\n\nint term(State &begin) {\n  int ret1 = factor(begin);\n  for (;;) {\n    if (*begin == '*') {\n      begin++;\n      ret1 &= factor(begin);\n    } else if (*begin == '+') {\n      begin++;\n      ret1 |= factor(begin);\n    } else if (*begin == '-' && *(begin + 1) == '>') {\n      begin += 2;\n      int ret2 = factor(begin);\n      ret1 = (ret1 == 1 && ret2 == 0 ? 0 : 1);\n    } else {\n      break;\n    }\n  }\n  return ret1;\n}\n\nbool expression(State &begin) {\n  int ret1 = term(begin);\n  begin++;\n  int ret2 = term(begin);\n  return ret1 == ret2;\n}\n\nint factor(State &begin) {\n  if (isdigit(*begin)) {\n    return number(begin);\n  } else if (*begin == '(') {\n    begin++;\n    int ret = term(begin);\n    begin++;\n    return ret;\n  } else if (*begin == '-') {\n    begin++;\n    int ret = factor(begin);\n    return 1 ^ ret;\n  }\n}\n\nbool solve() {\n  string s; getline(cin, s);\n  if (s == \"#\") return false;\n  vector<char> v;\n  int n = (int)s.size();\n  rep(i, 0, n) {\n    if (s[i] == 'T') s[i] = '1';\n    else if (s[i] == 'F') s[i] = '0';\n  }\n  string t = s;\n  rep(i, 0, (1 << 11)) {\n    rep(j, 0, n) {\n      if ('a' <= t[j] && t[j] <= 'k') {\n        t[j] = ((i & (1 << (t[j] - 'a'))) == 0 ? '0' : '1');\n      }\n    }\n    State begin = t.begin();\n    if (!expression(begin)) {\n      cout << \"NO\" << endl;\n      return true;\n    }\n    t = s;\n  }\n  cout << \"YES\" << endl;\n  return true;\n}\n\nint main()\n{\n  while (solve());\n}\n"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\nusing namespace std;\n\nint pos, var;\nstring s;\nint formula() {\n  pos++;\n  if(s==\"T\") return 1;\n  if(s==\"F\") return 0;\n  if(isalpha(s[pos])) return var>>(s[pos]-'a')&1;\n  if(s[pos]=='-') return !formula();\n  if(s[pos]=='(') {\n    int f1=formula();\n    pos++; char op=s[pos]; if(op=='-') pos++;\n    int f2=formula(); pos++;\n    if(op=='+') return f1||f2;\n    if(op=='*') return f1&&f2;\n    if(op=='-') return f1<=f2;\n  }\n}\n\nint main() {\n  while(cin >> s) {\n    if(s==\"#\") break;\n    bool ok=true;\n    for(var=0;var<(1<<11);var++) {\n      pos=-1; int lhs=formula();\n      pos++;\n      if(lhs!=formula()) { ok=false; break; }\n    }\n    cout << (ok ? \"YES\":\"NO\") << endl;\n  }\n  return 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include<iostream>\n#include<string>\n#define MAX 11\nusing namespace std;\nbool o;\nvoid rec(string s){\n  if(!o) return;\n  //cout << s << endl;\n  bool f;\n  int p;\n\n  \n  while(s.find(\"-0\")!=-1){\n    p=s.find(\"-0\");\n    if(p+1>=s.size()) break;\n    s[p]='1';s[p+1]=' ';\n    f=true;\n  }\n  while(s.find(\"-1\")!=-1){\n    p=s.find(\"-1\");\n    if(p+1>=s.size()) break;\n    s[p]='0';s[p+1]=' ';\n    f=true;\n  }\n  /*\n  while(s.find(\"(0*0)\")!=-1){\n    p=s.find(\"(0*0)\");\n    s[p]='0';s[p+1]=' ';s[p+2]=' ';s[p+3]=' ';s[p+4]=' ';\n    f=true;\n  }\n  while(s.find(\"(0*1)\")!=-1){\n    p=s.find(\"(0*1)\");\n    s[p]='0';s[p+1]=' ';s[p+2]=' ';s[p+3]=' ';s[p+4]=' ';\n    f=true;\n  }\n  while(s.find(\"(1*0)\")!=-1){\n    p=s.find(\"(1*0)\");\n    s[p]='0';s[p+1]=' ';s[p+2]=' ';s[p+3]=' ';s[p+4]=' ';\n    f=true;\n  }\n  while(s.find(\"(1*1)\")!=-1){\n    p=s.find(\"(1*1)\");\n    s[p]='1';s[p+1]=' ';s[p+2]=' ';s[p+3]=' ';s[p+4]=' ';\n    f=true;\n  }\n  while(s.find(\"(0+0)\")!=-1){\n    p=s.find(\"(0+0)\");\n    s[p]='0';s[p+1]=' ';s[p+2]=' ';s[p+3]=' ';s[p+4]=' ';\n    f=true;\n  }\n  while(s.find(\"(0+1)\")!=-1){\n    p=s.find(\"(0+1)\");\n    s[p]='1';s[p+1]=' ';s[p+2]=' ';s[p+3]=' ';s[p+4]=' ';\n    f=true;\n  }\n  while(s.find(\"(1+0)\")!=-1){\n    p=s.find(\"(1+0)\");\n    s[p]='1';s[p+1]=' ';s[p+2]=' ';s[p+3]=' ';s[p+4]=' ';\n    f=true;\n  }\n  while(s.find(\"(1+1)\")!=-1){\n    p=s.find(\"(1+1)\");\n    s[p]='1';s[p+1]=' ';s[p+2]=' ';s[p+3]=' ';s[p+4]=' ';\n    f=true;\n  }\n  /*\n  while(s.find(\"(0->0)\")!=-1){\n    p=s.find(\"(0->0)\");\n    s[p]='1';s[p+1]=' ';s[p+2]=' ';s[p+3]=' ';s[p+4]=' ';s[p+5]=' ';\n    f=true;\n  }\n  while(s.find(\"(0->1)\")!=-1){\n    p=s.find(\"(0->1)\");\n    s[p]='1';s[p+1]=' ';s[p+2]=' ';s[p+3]=' ';s[p+4]=' ';s[p+5]=' ';\n    f=true;\n  }\n  while(s.find(\"(1->0)\")!=-1){\n    p=s.find(\"(1->0)\");\n    s[p]='0';s[p+1]=' ';s[p+2]=' ';s[p+3]=' ';s[p+4]=' ';s[p+5]=' ';\n    f=true;\n  }\n  while(s.find(\"(1->1)\")!=-1){\n    p=s.find(\"(1->1)\");\n    s[p]='1';s[p+1]=' ';s[p+2]=' ';s[p+3]=' ';s[p+4]=' ';s[p+5]=' ';\n    f=true;\n  }\n  */\n  if(f){\n    string b;\n    for(int i=0;i<s.size();i++) if(s[i]!=' ') b+=s[i];\n    rec(b);\n  }else{\n    //if(s[0]!=s[2]) o=false;\n    return;\n  }\n}\nvoid init(int n,string s){\n  int i,j;\n  for(i=0;i<s.size();i++){\n    for(j=0;j<=MAX;j++){\n      if(s[i]=='a'+j) s[i]='0'+(n>>j&1);\n      if(s[i]=='T') s[i]='1';\n      if(s[i]=='F') s[i]='0';\n    }\n  }\n  rec(s);\n}\nint main(){\n  string s;\n  while(cin >> s,s!=\"#\"){\n    o=true;\n    int i;\n    for(i=0;i<(1<<MAX);i++)\n      init(i,s);\n    cout << (o?\"YES\":\"NO\") << endl;\n  }\n  return 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include<iostream>\n#include<vector>\n#include<string>\n#include<algorithm>\nusing namespace std;\n\n#define MAX_NUM 2\n#define MAX_CH 10\n#define MAX_N 1200\n\nstring S, T;\nchar NUM[MAX_NUM + 1] = \"01\";\nchar CH[MAX_CH + 1] = \"abcdefghij\";\nint TR[MAX_CH];\nint CNT[MAX_N];\n\nint Plus(int c1, int c2) {\n\treturn max(c1, c2);\n}\nint kake(int c1, int c2) {\n\treturn min(c1, c2);\n}\nint fukumi(int c1, int c2) {\n\tif (c1 == 1 && c2 == 0) {\n\t\treturn 0;\n\t}\n\treturn 1;\n}\n\nint calc2(string A2) {\n\tA2 = A2.substr(1, A2.size() - 1);\n\tif (A2.size() == 3) {\n\t\tint p1, p2;\n\t\tp1 = STOI(A2[0]);\n\t\tp2 = STOI(A2[2]);\n\t\tif (A2[1] == '+') {\n\t\t\treturn Plus(p1, p2);\n\t\t}\n\t\tif (A2[1] == '*') {\n\t\t\treturn kake(p1, p2);\n\t\t}\n\t\tif (A2[1] == '&') {\n\t\t\treturn fukumi(p1, p2);\n\t\t}\n\t}\n\telse if (A2.size() == 4) {\n\t\tif (A2[0] == '-') {\n\t\t\tint p1, p2;\n\t\t\tp1 = STOI(A2[1]);\n\t\t\tp2 = STOI(A2[3]);\n\t\t\tif (A2[1] == '+') {\n\t\t\t\treturn Plus(1 - p1, p2);\n\t\t\t}\n\t\t\tif (A2[1] == '*') {\n\t\t\t\treturn kake(1 - p1, p2);\n\t\t\t}\n\t\t\tif (A2[1] == '&') {\n\t\t\t\treturn fukumi(1 - p1, p2);\n\t\t\t}\n\t\t}\n\t\tif (A2[2] == '-') {\n\t\t\tint p1, p2;\n\t\t\tp1 = STOI(A2[0]);\n\t\t\tp2 = STOI(A2[3]);\n\t\t\tif (A2[1] == '+') {\n\t\t\t\treturn Plus(p1, 1 - p2);\n\t\t\t}\n\t\t\tif (A2[1] == '*') {\n\t\t\t\treturn kake(p1, 1 - p2);\n\t\t\t}\n\t\t\tif (A2[1] == '&') {\n\t\t\t\treturn fukumi(p1, 1 - p2);\n\t\t\t}\n\t\t}\n\t}\n\telse {\n\t\tint p1, p2;\n\t\tp1 = STOI(A2[1]);\n\t\tp2 = STOI(A2[4]);\n\t\tif (A2[1] == '+') {\n\t\t\treturn Plus(1 - p1, 1 - p2);\n\t\t}\n\t\tif (A2[1] == '*') {\n\t\t\treturn kake(1 - p1, 1 - p2);\n\t\t}\n\t\tif (A2[1] == '&') {\n\t\t\treturn fukumi(1 - p1, 1 - p2);\n\t\t}\n\t}\n}\n\nint STOI(char V) {\n\tif (V == '0') {\n\t\treturn 0;\n\t}\n\telse {\n\t\treturn 1;\n\t}\n}\n\nstring TOSTR(int d) {\n\tif (d == 0) {\n\t\treturn \"0\";\n\t}\n\telse {\n\t\treturn \"1\";\n\t}\n}\n\nint calc(string Y) {\n\tfor (int i = 0; i < MAX_N; i++) {\n\t\tCNT[i] = 0;\n\t}\n\tstring Z = \"\", AA = \"\";\n\n\twhile (Z.size() >= 2) {\n\t\tint L = 0, MN = 0;\n\t\tbool ok1 = false;\n\t\tZ = \"\"; AA = \"\";\n\t\tint pass2 = 0;\n\t\tint pass3 = -1;\n\t\twhile (pass2 < Y.size()) {\n\t\t\tif (Y[pass2] == '(') {\n\t\t\t\tL++;\n\t\t\t}\n\t\t\tif (Y[pass2] == ')') {\n\t\t\t\tL++;\n\t\t\t}\n\t\t\tCNT[pass2] = L;\n\t\t\tpass2++;\n\t\t\tMN = max(MN, L);\n\t\t}\n\t\tfor (int i = 0; i < Y.size(); i++) {\n\t\t\tif (CNT[i] == MN) {\n\t\t\t\tif (pass3 == -1) {\n\t\t\t\t\tpass3 = i;\n\t\t\t\t}\n\t\t\t\tAA += Y[i];\n\t\t\t\tif (i < Y.size() - 1) {\n\t\t\t\t\tif (Y[i + 1] == ')') {\n\t\t\t\t\t\tok1 = false;\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t}\n\t\t\telse {\n\t\t\t\tZ += Y[i];\n\t\t\t}\n\t\t}\n\t\tint ZSIZE = Z.size();\n\t\tZ = Z.substr(0, pass3) + TOSTR(calc2(AA)) + Z.substr(pass3, ZSIZE - pass3);\n\t}\n\tif (Z == \"0\") {\n\t\treturn false;\n\t}\n\telse {\n\t\treturn true;\n\t}\n}\n\nint power(int a, int b) {\n\tint res2 = 1;\n\tfor (int i = 0; i < b; i++) {\n\t\tres2 *= a;\n\t}\n\treturn res2;\n}\n\nbool solve(string U) {\n\tbool RES = true;\n\tstring V = \"\";\n\tstring V1 = \"\", V2 = \"\";\n\tstring W1 = \"\", W2 = \"\";\n\n\tfor (int i = 0; i < U.size(); i++) {\n\t\tif (U[i] == 'T') {\n\t\t\tV += '1';\n\t\t\tgoto E;\n\t\t}\n\t\telse if (U[i] == '>') {\n\t\t\t//nanimo shinai.\n\t\t}\n\t\telse if (U[i] == 'F') {\n\t\t\tV += '0';\n\t\t\tgoto E;\n\t\t}\n\t\telse if (i < U.size() - 1) {\n\t\t\tif (U.substr(i, 2) == \"->\") {\n\t\t\t\tV += '&';\n\t\t\t\tgoto E;\n\t\t\t}\n\t\t}\n\t\telse {\n\t\t\tV += U[i];\n\t\t}\n\tE:;\n\t}\n\n\tint cnt1 = 0;\n\tfor (int i = 0; i < V.size(); i++) {\n\t\tif (V[i] == '=') {\n\t\t\tcnt1 = 1;\n\t\t}\n\t\telse if (cnt1 == 0) {\n\t\t\tV1 += V[i];\n\t\t}\n\t\telse if (cnt1 == 1) {\n\t\t\tV2 += V[i];\n\t\t}\n\t}\n\n\tint pass1 = 0;\n\twhile (pass1 < V1.size()) {\n\t\tif (V1[pass1] == '-') {\n\t\t\tint cnt2 = 0;\n\t\t\twhile (V1[pass1] == '-') {\n\t\t\t\tcnt2++;\n\t\t\t\tpass1++;\n\t\t\t}\n\t\t\tif (cnt2 % 2 == 1) {\n\t\t\t\tW1 += '(';\n\t\t\t\tW1 += '-';\n\t\t\t\tW1 += V1[pass1];\n\t\t\t\tW1 += ')';\n\t\t\t}\n\t\t\telse {\n\t\t\t\tW1 += V1[pass1];\n\t\t\t}\n\t\t\tpass1++;\n\t\t}\n\t\tif (pass1 < V1.size()) {\n\t\t\tW1 += V1[pass1];\n\t\t\tpass1++;\n\t\t}\n\t}\n\n\tpass1 = 0;\n\twhile (pass1 < V2.size()) {\n\t\tif (V2[pass1] == '-') {\n\t\t\tint cnt2 = 0;\n\t\t\twhile (V2[pass1] == '-') {\n\t\t\t\tcnt2++;\n\t\t\t\tpass1++;\n\t\t\t}\n\t\t\tif (cnt2 % 2 == 1) {\n\t\t\t\tW2 += '(';\n\t\t\t\tW2 += '-';\n\t\t\t\tW2 += V2[pass1];\n\t\t\t\tW2 += ')';\n\t\t\t}\n\t\t\telse {\n\t\t\t\tW2 += V2[pass1];\n\t\t\t}\n\t\t\tpass1++;\n\t\t}\n\t\tif (pass1 < V2.size()) {\n\t\t\tW2 += V2[pass1];\n\t\t\tpass1++;\n\t\t}\n\t}\n\n\tstring X1 = \"\", X2 = \"\";\n\n\tfor (int i = 0; i < power(2, MAX_NUM); i++) {\n\t\tX1 = \"\"; X2 = \"\";\n\t\tfor (int j = 0; j < MAX_NUM; j++) {\n\t\t\tint a1 = (i / power(2, j)) % 2;\n\t\t\tTR[j] = a1;\n\t\t}\n\n\t\tfor (int j = 0; j < V1.size(); j++) {\n\t\t\tfor (int k = 0; k < MAX_NUM; k++) {\n\t\t\t\tif (W1[j] == CH[k]) {\n\t\t\t\t\tX1 += NUM[TR[j]];\n\t\t\t\t\tgoto F;\n\t\t\t\t}\n\t\t\t}\n\t\t\tX1 += W1[j];\n\t\tF:;\n\t\t}\n\n\t\tfor (int j = 0; j < V2.size(); j++) {\n\t\t\tfor (int k = 0; k < MAX_NUM; k++) {\n\t\t\t\tif (W2[j] == CH[k]) {\n\t\t\t\t\tX2 += NUM[TR[j]];\n\t\t\t\t\tgoto G;\n\t\t\t\t}\n\t\t\t}\n\t\t\tX2 += W1[j];\n\t\tG:;\n\t\t}\n\n\t\tint res_1 = calc(X1);\n\t\tint res_2 = calc(X2);\n\t\tif (res_1 != res_2) {\n\t\t\tRES = false;\n\t\t}\n\t}\n\treturn RES;\n}\n\nint main() {\n\twhile (true) {\n\t\tcin >> S;\n\t\tif (S == \"#\") {\n\t\t\tbreak;\n\t\t}\n\t\tbool res = solve(S);\n\t\tif (res == true) {\n\t\t\tcout << \"YES\" << endl;\n\t\t}\n\t\telse {\n\t\t\tcout << \"NO\" << endl;\n\t\t}\n\t}\n\treturn 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\nusing namespace std;\n\nvector<string> opr{\"->\", \"+\", \"*\", \"-\"};\nvector<string> num{\"1\", \"2\", \"3\", \"4\"};\n\nvoid add_para(string &exp) {\n    auto find_idx = exp.find(\"4\");\n    while (find_idx != string::npos) {\n        if (exp[find_idx + 1] == '(') {\n            int end_idx = find_idx + 2;\n            int count = 1;\n            while (count) {\n                if (exp[end_idx] == '(') count++;\n                else if (exp[end_idx] == ')') count--;\n                end_idx++;\n            }\n            exp.insert(end_idx, \")\");\n            exp[find_idx] = '5';\n            exp.insert(find_idx, \"(\");\n        } else {\n            exp.insert(find_idx + 2, \")\");\n            exp[find_idx] = '5';\n            exp.insert(find_idx, \"(\");\n        }\n\n        find_idx = exp.find(\"4\");\n    }\n}\n\nbool calc(string exp, int bits) {\n    if (exp == \"T\") return true;\n    else if (exp == \"F\") return false;\n    else if (exp.size() == 1) {\n        if (bits & (1 << (exp[0] - 'a'))) return true;\n        else return false;\n    }\n\n    if (exp.size() < 3) return false;\n    if (exp[1] == '5') return !calc(string(exp.begin() + 2, exp.end() - 1), bits);\n    int idx;\n    for (int i = 1, len = exp.size(), count = 0; i < len - 1; i++) {\n        if (exp[i] == '(') count++;\n        else if (exp[i] == ')') count--;\n        if (count == 0 && '1' <= exp[i] && exp[i] <= '5') idx = i;\n    }\n\n    bool lhs = calc(string(exp.begin() + 1, exp.begin() + idx), bits);\n    bool rhs = calc(string(exp.begin() + idx + 1, exp.end() - 1), bits);\n\n    if (exp[idx] == '1') return !(lhs && !rhs);\n    if (exp[idx] == '2') return (lhs || rhs);\n    if (exp[idx] == '3') return (lhs && rhs);\n}\n\nvoid solve(string str) {\n    for (int i = 0, len = opr.size(); i < len; i++) {\n        auto find_idx = str.find(opr[i]);\n        while (find_idx != string::npos) {\n            str.replace(find_idx, (int)(opr[i].size()), num[i]);\n            find_idx = str.find(opr[i]);\n        }\n    }\n    int eq_idx = str.find(\"=\");\n    string exp1 = string(str.begin(), str.begin() + eq_idx);\n    string exp2 = string(str.begin() + eq_idx + 1, str.end());\n\n    add_para(exp1);\n    add_para(exp2);\n\n    bool flag = true;\n    for (int i = 0; i < (1 << 11); i++) {\n        if (calc(exp1, i) != calc(exp2, i)) {\n            flag = false;\n            break;\n        }\n    }\n\n    if (flag == true) cout << \"YES\" << endl;\n    else cout << \"NO\" << endl;\n}\n\nint main() {\n    string Input;\n    while (cin >> Input, Input != \"#\") solve(Input);\n\n    return 0;\n}"
  },
  {
    "language": "C++",
    "code": "// {{{ include\n#include <cstdio>\n#include <cmath>\n#include <cstring>\n#include <iostream>\n#include <vector>\n#include <string>\n#include <set>\n#include <map>\n#include <queue>\n#include <algorithm>\n// }}}\n#include <cassert>\n#include <cctype>\n\nusing namespace std;\n\nstruct Parser {\n  typedef string::const_iterator cursor_t;\n  inline void consume(cursor_t& cur, char expected){\n    assert(*cur == expected);\n    ++cur;\n  }\n  bool equation(cursor_t& cur){\n    bool r = formula(cur);\n    consume(cur, '=');\n    return r == formula(cur);\n  }\n  bool formula(cursor_t& cur){\n    if (isupper(*cur)){\n      bool r = *cur == 'T';\n      ++cur;\n      return r;\n    }\n    if (islower(*cur)){\n      int x = *cur - 'a';\n      ++cur;\n      return (state >> x) & 1;\n    }\n    if (*cur == '-'){\n      ++cur;\n      return !formula(cur);\n    }\n    if (*cur == '('){\n      ++cur;\n      bool r = formula(cur);\n      if (*cur == '*'){\n        ++cur;\n        r = formula(cur) && r;\n      }\n      else if (*cur == '+'){\n        ++cur;\n        r = formula(cur) || r;\n      }\n      else if (*cur == '-'){\n        ++cur;\n        consume(cur, '>');\n        r = !(!formula(cur) && r);\n      }\n      consume(cur, ')');\n      return r;\n    }\n    assert(0);\n  }\n  bool eval(const string& s){\n    auto b = s.begin();\n    bool r = equation(b);\n    assert(b == s.end());\n    return r;\n  }\n  void setState(int st){\n    state = st;\n  }\n  int state;\n};\n\nint main()\n{\n  Parser parser;\n  string S;\n  while (cin >> S, S != \"#\"){\n    for (int i = 0; i < (1 << 12); i++){\n      parser.setState(i);\n      if (!parser.eval(S)){\n        puts(\"NO\");\n        goto END;\n      }\n    }\n    puts(\"YES\");\nEND:;\n  }\n\n  return 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include <iostream>\n#include <algorithm>\n#include <string>\n#include <vector>\nusing namespace std;\n\nconst int INF = 1e+8;\n\n// 変数 'a' - 'k' を value に置き換え\nvoid change(string& s, char x, char value){\n\tfor(int i=0 ; i < s.size() ; i++ ){\n\t\tif( s[i] == x ) s[i] = value;\n\t}\n}\n\n// 式から \"--\" の除去\nvoid minus_erase(string& s){\n\tfor(int i=1 ; i < s.size() ; i++ ){\n\t\tif( s[i-1] == '-' && s[i] == '-' ){\n\t\t\ts.erase( i-1 , 2 );\n\t\t\ti = 0;\n\t\t}\n\t}\n}\n\n// 論理否定の計算 (\"-F\" => \"T\", \"-T\" => \"F\" の 文字列置換)\nvoid minus_calc(string& s){\n\tfor(int i=1 ; i < s.size() ; i++ ){\n\t\tif( s[i-1] == '-' && s[i] == 'F' ){\n\t\t\ts.replace( i-1 , 2 , \"T\" );\n\t\t\ti = 0;\n\t\t}else if( s[i-1] == '-' && s[i] == 'T' ){\n\t\t\ts.replace( i-1 , 2 , \"F\" );\n\t\t\ti = 0;\n\t\t}\n\t}\n}\n\n// 論理和, 論理積, 論理包含の計算 (文字列置換)\nvoid calc(string& s){\n\tstring ex[12] = {\n\t\t\"(F+F)\", \"(F+T)\", \"(T+F)\", \"(T+T)\",\n\t\t\"(F*F)\", \"(F*T)\", \"(T*F)\", \"(T*T)\",\n\t\t\"(F>F)\", \"(F>T)\", \"(T>F)\", \"(T>T)\"\n\t};\n\tstring result[12] = {\n\t\t\"F\", \"T\", \"T\", \"T\",\n\t\t\"F\", \"F\", \"F\", \"T\",\n\t\t\"T\", \"T\", \"F\", \"T\"\n\t};\n\tfor(int i=0 ; i+4 < s.size() ; i++ ){\n\t\tfor(int j=0 ; j < 12 ; j++ ){\n\t\t\tif( s.substr(i,5) == ex[j] ){\n\t\t\t\ts.replace( i , 5 , result[j] );\n\t\t\t\ti = -1;\n\t\t\t\tbreak;\n\t\t\t}\n\t\t}\n\t}\n}\n\nint main(){\n\tstring ex;\n\twhile( cin >> ex ){\n\t\tif( ex == \"#\" ) break;\n\t\t\n\t\t// \"->\" を \">\" に置き換えておく\n\t\tstring s;\n\t\tfor(int i=0 ; i < ex.size() ; i++ ){\n\t\t\tif( i+1 < ex.size() && ex[i] == '-' && ex[i+1] == '>' ){\n\t\t\t\ts.push_back( '>' );\n\t\t\t\ti++;\n\t\t\t}else{\n\t\t\t\ts.push_back( ex[i] );\n\t\t\t}\n\t\t}\n\t\t\n\t\t// '=' の左側を ex1, 右側を ex2 とする\n\t\tstring ex1, ex2;\n\t\tbool flag = false;\n\t\tfor(int i=0 ; i < s.size() ; i++ ){\n\t\t\tif( s[i] == '=' ){\n\t\t\t\tflag = true;\n\t\t\t}else if( flag ){\n\t\t\t\tex2.push_back( s[i] );\n\t\t\t}else{\n\t\t\t\tex1.push_back( s[i] );\n\t\t\t}\n\t\t}\n\t\t\n\t\t// 登場する変数('a' - 'k')をチェック\n\t\tint f[256] = {0};\n\t\tfor(int i= 0 ; i < s.size() ; i++ ){\n\t\t\tf[ s[i] ] = 1;\n\t\t}\n\t\tvector<char> vc;\n\t\tfor(char c = 'a' ; c <= 'k' ; c++ ){\n\t\t\tif( f[c] ){\n\t\t\t\tvc.push_back( c );\n\t\t\t}\n\t\t}\n\t\t// N := 登場する変数の種類.\n\t\tint N = vc.size();\n\t\t\n\t\t// 変数の置き換えを 2^N 通り試し すべての式の評価で右辺と左辺が等しいか調べる.\n\t\tbool ans = true;\n\t\tfor(int bits = 0 ; bits < (1<<N) ; bits++ ){\n\t\t\tstring ex1_ = ex1;\n\t\t\tstring ex2_ = ex2;\n\t\t\t// 変数を \"T\" or \"F\" に置き換えておく\n\t\t\tfor(int i=0 ; i < N ; i++ ){\n\t\t\t\t// i 番目の文字を'T' か 'F'にしておく\n\t\t\t\tif( bits & (1<<i) ){\n\t\t\t\t\tchange( ex1_ , vc[i] , 'T' );\n\t\t\t\t\tchange( ex2_ , vc[i] , 'T' );\n\t\t\t\t}else{\n\t\t\t\t\tchange( ex1_ , vc[i] , 'F' );\n\t\t\t\t\tchange( ex2_ , vc[i] , 'F' );\n\t\t\t\t}\n\t\t\t}\n\t\t\t// \"--\" の除去\n\t\t\tminus_erase( ex1_ );\n\t\t\tminus_erase( ex2_ );\n\t\t\t\n\t\t\t// 式 ex1 が \"T\" か \"F\" になるまで文字列置換を繰り返す.\n\t\t\twhile( ex1_.size() > 1 ){\n\t\t\t\tminus_calc( ex1_ );\n\t\t\t\tcalc( ex1_ );\n\t\t\t}\n\t\t\t// 式 ex2 が \"T\" か \"F\" になるまで文字列置換を繰り返す.\n\t\t\twhile( ex2_.size() > 1 ){\n\t\t\t\tminus_calc( ex2_ );\n\t\t\t\tcalc( ex2_ );\n\t\t\t}\n\t\t\t// 式 ex1 と 式 ex2 が等しいかどうか\n\t\t\tif( ex1_ != ex2_ ) ans = false;\n\t\t}\n\t\t// 出力 \n\t\tif( ans ){\n\t\t\tcout << \"YES\" << endl;\n\t\t}else{\n\t\t\tcout << \"NO\" << endl;\n\t\t}\n\t}\n}"
  },
  {
    "language": "C++",
    "code": "#include<iostream>\n#include<string>\n#include<map>\n#include<sstream>\n#include<cctype>\n#include<algorithm>\nusing namespace std;\ntypedef string::const_iterator Cursol;\nbool ok;\nint bit;\nbool java(Cursol &c){\n  bool ret;\n  if(*c == 'T'){\n    ret = true;\n  }else if(*c == 'F'){\n    ret = false;\n  }else if(islower(*c)){\n    ret = 1 << ((*c) - 'a');\n  }\n  c++;\n}\nbool Formula(Cursol &c){\n  bool ret, bs = false;\n  if(*c == '-'){\n    bs = true;\n    c++;\n  }\n  if(*c == '('){\n    c++;\n    ret = Formula(c);\n    c++;\n  }else{\n    ret = java(c);\n    if(*c == '+'){\n      c++;\n      ret |= Formula(c);\n    }else if(*c == '*'){\n      c++;\n      ret &= Formula(c);\n    }else if(*c == '-'){ //->\n      c+=2;\n      if(ret && !Formula(c)) ret = false;\n      else ret = true;\n    }\n  }\n    // cout << ret << endl;\n  return bs ? !ret : ret;\n}\nint main(){\n  string s;\n  Cursol c;\n  while(cin >> s , ok = true, s != \"#\"){\n    string l = s.substr(0,s.find('='));\n    string r = s.substr(s.find('=')+1);\n\n    for(bit = 0 ; bit < (1 << 11) - 1; bit++ ){\n      c = l.begin();\n      bool java = Formula(c);\n      c = r.begin();\n      if( java != Formula(c) ){\n\tok = false;\n\tbreak;\n      }\n    }\n    if(ok) cout << \"YES\" << endl;\n    else cout << \"NO\" << endl;\n  }\n}"
  },
  {
    "language": "C++",
    "code": "#include <iostream>\n#include <string>\n#include <algorithm>\n#include <cstdio>\n#include <cassert>\n#include <vector>\n#include <map>\n\nusing namespace std;\n//map<char,bool> assign;\nint assign;\nbool formula(string &arg, int &pos){\n    if('a' <= arg[pos] && arg[pos] <= 'k'){\n        return assign & (1 << (arg[pos++]-'a'));\n    }else if(arg[pos] == '-'){\n        return !formula(arg, ++pos);\n    }else if(arg[pos] == 'T'){\n        pos++;\n        return true;\n    }else if(arg[pos] == 'F'){\n        pos++;\n        return false;\n    }else{\n        assert(arg[pos] == '(');\n        bool f,b;\n        char op;\n        f = formula(arg, ++pos);\n        op = arg[pos];\n        assert(op == '*' || op == '+' || op == '-');\n        if(op == '-') pos++;\n        b = formula(arg, ++pos);\n        assert(arg[pos] == ')');\n        pos++;\n        if(op == '*'){\n            if(f&&b) return true;\n            return false;\n        }else if(op == '+'){\n            if(!f&&!b) return false;\n            return true;\n        }else{\n            if(f && !b) return false;\n            return true;\n        }\n    }\n}\n\nbool parse(string &arg, int pos){\n    bool f,b;\n\n    f = formula(arg, pos);\n    assert(arg[pos] == '=');\n    b = formula(arg, ++pos);\n    return f == b;\n}\n\n\nint main(){\n    string str;\n    while(cin >> str){\n        if(str == \"#\") break;\n        int var = 0;    \n        vector<char> vars;\n        bool res = true;\n\n        for(int i=0;i<(int)str.size();i++){\n            if('a' <= str[i] && str[i] <= 'k'){\n                var++;\n                vars.push_back(str[i]);\n            }\n        }\n\n        for(int i=0;i<(1 << var);i++){\n            assign = i;\n            res = parse(str, 0);\n            if(!res) break;\n        }\n        if(res){\n            cout << \"YES\" << endl;\n        }else{\n            cout << \"NO\" << endl;\n        }\n    }\n}"
  },
  {
    "language": "C++",
    "code": "#include <map>\n#include <set>\n#include <list>\n#include <cmath>\n#include <queue>\n#include <stack>\n#include <cstdio>\n#include <string>\n#include <vector>\n#include <complex>\n#include <cstdlib>\n#include <cstring>\n#include <numeric>\n#include <sstream>\n#include <iostream>\n#include <algorithm>\n#include <functional>\n \n#define mp       make_pair\n#define pb       push_back\n#define all(x)   (x).begin(),(x).end()\n#define rep(i,n) for(int i=0;i<(n);i++)\n#define _D(p) std::cout<<\"L\"<<__LINE__<<\" : \" #p \" = \"<<(p)<<std::endl;\n#define _D2(p,q) std::cout<<\"L\"<<__LINE__<<\" : \" #p \" = \"<<(p) << \", \" #q \" = \"<<(q)<<std::endl;\n#define _DN(v) std::cout<<\"L\"<<__LINE__<<\" : \" #v \" = [\"; rep(i,(v).size()) {std::cout<<v[i]<<(i==v.size()-1?\"\":\", \");}std::cout<<\"]\"<<std::endl;\n#define _DNN(v) std::cout<<\"L\"<<__LINE__<<\" : \" #v \" = [\" << std::endl; rep(i,(v).size()) {std::cout<<\"\t[\";rep(j,(v)[0].size()){std::cout<<v[i][j]<<(j==v[0].size()-1?\"\":\", \");}std::cout<<\"],\"<<std::endl;}std::cout<<\"]\"<<std::endl;\n \nusing namespace std;\n \ntypedef    long long          ll;\ntypedef    unsigned long long ull;\ntypedef    vector<bool>       vb;\ntypedef    vector<int>        vi;\ntypedef    vector<vb>         vvb;\ntypedef    vector<vi>         vvi;\ntypedef    pair<int,int>      pii;\n \nconst int INF=1<<29;\nconst double EPS=1e-9;\n \nconst int dx[]={1,0,-1,0},dy[]={0,-1,0,1};\n\n\npair<char, int> formula(string &s, int pos) {\n\n\tif (s[pos] == 'T') {\n\t\treturn mp('T', pos + 1);\n\t} else if (s[pos] == 'F'){\n\t\treturn mp('F', pos + 1);\n\t}\n\n\tif (s[pos] == '-' && (pos <= s.size() - 2)) {\n\t\tif (s[pos + 1] != '>') {\t\n\t\t\tpair<char, int> r = formula(s, pos + 1);\n\t\t\tchar ret;\n\t\t\tif (r.first == 'T') {\n\t\t\t\tret = 'F';\n\t\t\t} else {\n\t\t\t\tret = 'T';\n\t\t\t}\n\t\t\treturn mp(ret, r.second);\t\n\t\t}\n\t}\n\n\tpos++; // skip '('\n\tchar mode;\n\tpair<char, int> result1 = formula(s, pos);\n\tif (s[result1.second] == '*') {\n\t\tpos = result1.second + 1;\n\t} else if (s[result1.second] == '+') {\n\t\tpos = result1.second + 1;\n\t} else if (s[result1.second] == '-') {\n\t\tpos = result1.second + 2;\n\t}\n\tmode = s[result1.second];\n\tpair<char, int> result2 = formula(s, pos);\n\tpos = result2.second + 1; //skip ')'\n\n\tchar ret;\n\tif (mode == '*') {\n\n\t\tif (result1.first == 'T' && result2.first == 'T') ret = 'T';\n\t\tif (result1.first == 'T' && result2.first == 'F') ret = 'F';\n\t\tif (result1.first == 'F' && result2.first == 'T') ret = 'F';\n\t\tif (result1.first == 'F' && result2.first == 'F') ret = 'F';\n\t} else if (mode == '+') {\n\n\t\tif (result1.first == 'T' && result2.first == 'T') ret = 'T';\n\t\tif (result1.first == 'T' && result2.first == 'F') ret = 'T';\n\t\tif (result1.first == 'F' && result2.first == 'T') ret = 'T';\n\t\tif (result1.first == 'F' && result2.first == 'F') ret = 'F';\n\t} else {\n\t\tif (result1.first == 'T' && result2.first == 'T') ret = 'T';\n\t\tif (result1.first == 'T' && result2.first == 'F') ret = 'F';\n\t\tif (result1.first == 'F' && result2.first == 'T') ret = 'T';\n\t\tif (result1.first == 'F' && result2.first == 'F') ret = 'T';\n\t}\n\treturn mp(ret, pos);\n\t\n\n} \n\n\nbool equation(const string &s) {\n\tint temp;\n\tfor (int i = 0; i < s.size(); ++i) {\n\t\tif (s[i] == '=') {\n\t\t\ttemp = i;\n\t\t\tbreak;\n\t\t}\n\t}\n\tstring sl, sr;\n\tsl = s.substr(0, temp);\n\tsr = s.substr(temp + 1);\n\n\tpair<char, int> resultl = formula(sl, 0);\n\tpair<char, int> resultr = formula(sr, 0);\n\treturn resultl.first == resultr.first;\n}\n\n\nint main(int argc, char const *argv[]) {\n\twhile(1) {\n\t\tstring s;\n\t\tcin >> s;\n\t\tif (s == \"#\") break;\n\n\t\tset<string> sset;\n\n\n\n\n\t\tchar alphabets[11] = {'a', 'b', 'c', 'd', 'e', 'f', 'g', 'h', 'i' ,'j', 'k'};\n\t\tfor (int i = 0; i < 1 << 11; ++i) {\n\t\t\tstring now = s;\n\t\t\tfor(int j = 0; j < 11; j++) { // j bit\n\t\t\t\tfor (int k = 0; k < now.size(); ++k) {\n\t\t\t\t\tif (now[k] == alphabets[j]) {\n\t\t\t\t\t\tnow[k] = (i >> j & 1) ? 'T' : 'F';\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t}\n\t\t\tsset.insert(now);\n\t\t}\n\n\t\tbool flag = true;\n\t\tfor (auto &e : sset) {\n\t\t\tbool result = equation(e);\n\t\t\tif (!result) {\n\t\t\t\tflag = false;\n\t\t\t\tbreak;\n\t\t\t}\n\t\t}\n\n\t\tif (flag) {\n\t\t\tcout << \"YES\" << endl;\n\t\t} else {\n\t\t\tcout << \"NO\" << endl;\n\t\t}\n\n\n\t}\n\treturn 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include <functional>\n#include <iostream>\n#include <memory>\n#include <string>\n#include <unordered_set>\n#include <vector>\n#define loop(i, a, n) for (int i = (a); i < (n); i++)\n#define rep(i, n) loop(i, 0, n)\ntemplate<typename A> using F = std::function<A>;\nusing namespace std;\n\ntemplate<typename T> struct ParseResult {\n  bool succeeded;\n  T object;\n  size_t pos;\n  ParseResult(const bool succeeded, const T &object, const size_t pos) : succeeded(succeeded), object(object), pos(pos) {}\n  friend std::ostream &operator<<(std::ostream &os, const ParseResult<T> &p) { return os << '{' << (p.succeeded ? \"true\" : \"false\") << ',' << p.object << ',' << p.pos << '}'; }\n};\n\ntemplate<typename T> using Parser = std::function<ParseResult<T>(const std::string &, size_t)>;\n\nParser<std::string> token(std::string s) {\n  const size_t n = s.size();\n  return [n = std::move(n), s = std::move(s)](const std::string &target, const size_t pos) {\n    if (target.size() < n) return ParseResult<std::string>(false, {}, pos);\n    return target.substr(pos, n) == s ? ParseResult<std::string>(true, s, pos + n) : ParseResult<std::string>(false, {}, pos);\n  };\n}\n\ntemplate<typename T> Parser<T> operator||(Parser<T> p1, Parser<T> p2) {\n  return [p1 = std::move(p1), p2 = std::move(p2)](const std::string &target, const size_t pos) {\n    auto r = p1(target, pos);\n    if (r.succeeded) return r;\n    r = p2(target, pos);\n    if (r.succeeded) return r;\n    return ParseResult<T>(false, {}, pos);\n  };\n}\n\ntemplate<typename T1, typename T2> Parser<std::pair<T1, T2>> operator+(Parser<T1> p1, Parser<T2> p2) {\n  return [p1 = std::move(p1), p2 = std::move(p2)](const std::string &target, const size_t pos) {\n    auto r1 = p1(target, pos);\n    if (!r1.succeeded) return ParseResult<std::pair<T1, T2>>(false, {}, pos);\n    auto r2 = p2(target, r1.pos);\n    if (!r2.succeeded) return ParseResult<std::pair<T1, T2>>(false, {}, pos);\n    return ParseResult<std::pair<T1, T2>>(true, {r1.object, r2.object}, r2.pos);\n  };\n}\n\ntemplate<typename T1, typename T2> Parser<T2> operator>>(Parser<T1> p1, Parser<T2> p2) {\n  return [p1 = std::move(p1), p2 = std::move(p2)](const std::string &target, const size_t pos) {\n    auto r1 = p1(target, pos);\n    if (!r1.succeeded) return ParseResult<T2>(false, {}, pos);\n    auto r2 = p2(target, r1.pos);\n    if (!r2.succeeded) return ParseResult<T2>(false, {}, pos);\n    return ParseResult<T2>(true, r2.object, r2.pos);\n  };\n}\n\ntemplate<typename T1, typename T2> Parser<T1> operator<<(Parser<T1> p1, Parser<T2> p2) {\n  return [p1 = std::move(p1), p2 = std::move(p2)](const std::string &target, const size_t pos) {\n    auto r1 = p1(target, pos);\n    if (!r1.succeeded) return ParseResult<T1>(false, {}, pos);\n    auto r2 = p2(target, r1.pos);\n    if (!r2.succeeded) return ParseResult<T1>(false, {}, pos);\n    return ParseResult<T1>(true, r1.object, r2.pos);\n  };\n}\n\nParser<char> oneOf(const std::string &s) {\n  std::unordered_set<char> d;\n  for (auto &c : s) d.insert(c);\n  return [d = std::move(d)](const std::string &target, const size_t pos) {\n    if (target.size() <= pos) return ParseResult<char>(false, {}, pos);\n    char c = target[pos];\n    return d.count(c) ? ParseResult<char>(true, c, pos + 1) : ParseResult<char>(false, {}, pos);\n  };\n}\n\ntemplate<typename T, typename S, typename F> Parser<S> fmap(Parser<T> p, F &&f) {\n  return [p = std::move(p), f = std::forward<F>(f)](const std::string &target, const size_t pos) {\n    auto r = p(target, pos);\n    return r.succeeded ? ParseResult<S>(true, f(r.object), r.pos) : ParseResult<S>(false, {}, r.pos);\n  };\n}\n\n// template<typename T, typename F> Parser<T> lazy(const F &f) {\n//   bool instantiated = false;\n//   Parser<T> p;\n//   return [f = std::move(f), p = std::move(p), instantiated = std::move(instantiated)](const std::string &target, const size_t pos) mutable {\n//     if (!instantiated) {\n//       p = f();\n//       instantiated = true;\n//     }\n//     return p(target, pos);\n//   };\n// }\n\n// template<typename T> Parser<T> makeView(Parser<T> &&p) {\n//   return [p = std::make_shared<Parser<T>>(std::move(p))](const std::string &target, const size_t pos) { return (*p)(target, pos); };\n// }\n\ntemplate<typename T, typename F> Parser<T> lazy(const F &f) {\n  bool instantiated = false;\n  Parser<T> p;\n  Parser<T> &&q = [f = std::move(f), p = std::move(p), instantiated = std::move(instantiated)](const std::string &target, const size_t pos) mutable {\n    if (!instantiated) {\n      p = f();\n      instantiated = true;\n    }\n    return p(target, pos);\n  };\n  return [q = std::make_shared<Parser<T>>(std::move(q))](const std::string &target, const size_t pos) { return (*q)(target, pos); };\n}\n\nstruct SyntaxTree {\n  string op;\n  char value;\n  vector<SyntaxTree> children;\n  SyntaxTree() {}\n  SyntaxTree(const string &op, const char value, const vector<SyntaxTree> &children) : op(op), value(value), children(children) {}\n};\n\nint main() {\n  Parser<SyntaxTree> formulaP = /*makeView<SyntaxTree>(*/ lazy<SyntaxTree>([&]() {\n    auto andP = fmap<pair<SyntaxTree, SyntaxTree>, SyntaxTree>((token(\"(\") >> formulaP << token(\"*\")) + (formulaP << token(\")\")), [](auto &o) { return SyntaxTree(\"*\", {}, {o.first, o.second}); });\n    auto orP = fmap<pair<SyntaxTree, SyntaxTree>, SyntaxTree>((token(\"(\") >> formulaP << token(\"+\")) + (formulaP << token(\")\")), [](auto &o) { return SyntaxTree(\"+\", {}, {o.first, o.second}); });\n    auto impP = fmap<pair<SyntaxTree, SyntaxTree>, SyntaxTree>((token(\"(\") >> formulaP << token(\"->\")) + (formulaP << token(\")\")), [](auto &o) { return SyntaxTree(\"->\", {}, {o.first, o.second}); });\n    auto notP = fmap<SyntaxTree, SyntaxTree>(token(\"-\") >> formulaP, [](auto &o) { return SyntaxTree(\"-\", {}, {o}); });\n    auto valP = fmap<char, SyntaxTree>(oneOf(\"abcdefghijkTF\"), [](char x) { return SyntaxTree({}, x, {}); });\n    return andP || orP || impP || notP || valP;\n  }) /*)*/;\n  auto equationP = (formulaP << token(\"=\")) + formulaP;\n  string s;\n  while (cin >> s, s != \"#\") {\n    auto r = equationP(s, 0);\n    bool isValid = true;\n    rep(i, 1 << 11) {\n      auto toBool = [&](char c) -> bool {\n        if (c == 'T') return true;\n        if (c == 'F') return false;\n        return i >> (c - 'a') & 1;\n      };\n      F<bool(const SyntaxTree &)> evalF = [&](const SyntaxTree &f) {\n        switch (f.children.size()) {\n          case 0: return toBool(f.value);\n          case 1: return !evalF(f.children[0]);\n          case 2:\n            if (f.op == \"*\") return evalF(f.children[0]) && evalF(f.children[1]);\n            if (f.op == \"+\") return evalF(f.children[0]) || evalF(f.children[1]);\n            if (f.op == \"->\") return !evalF(f.children[0]) || evalF(f.children[1]);\n        }\n      };\n      isValid &= evalF(r.object.first) == evalF(r.object.second);\n    }\n    cout << (isValid ? \"YES\" : \"NO\") << endl;\n  }\n}"
  },
  {
    "language": "C++",
    "code": "#include <stdio.h>\n#include <string.h>\n#include <stdlib.h>\n#include <ctype.h>\n#include <iostream>\n\nusing namespace std;\n\nchar al[12], r[1001], l[1001], tl[1001], tr[1001], f[11];\n\nint calc(int c,char *s){\n\tint ret = 1;\n\tif(s[c] == '('){\n\t\tint i, j = 0;\n\t\tfor(i = c;(!(s[i] == '-' && s[i + 1] == '>') && s[i] != '+' && s[i] != '*') || j != 1;i++){\n\t\t\tif(s[i] == '(') j++;\n\t\t\telse if(s[i] == ')') j--;\n\t\t}\n\t\tif(s[i] == '-')\n\t\t\treturn !calc(c + 1,s) || calc(i + 2,s);\n\t\telse if(s[i] == '+')\n\t\t\treturn calc(c + 1,s) || calc(i + 1,s);\n\t\telse if(s[i] == '*')\n\t\t\treturn calc(c + 1,s) && calc(i + 1,s);\n\t}\n\telse if(isdigit(s[c]))\n\t\treturn s[c] - '0';\n\telse if(s[c] == '-' && s[c + 1] != '>')\n\t\treturn (calc(c + 1,s) + 1) % 2; \n}\n\nint dfs(int c){\n\tint ret = 1;\n\tunsigned int i, j;\n\tif(c == strlen(al)){\n\t\tstrcpy(tl,l);\n\t\tstrcpy(tr,r);\n\t\tfor(i = 0;i < strlen(al);i++)\n\t\t\tfor(j = 0;j < strlen(tl);j++) if(al[i] == tl[j]) tl[j] = '0' + f[i];\n\t\tfor(i = 0;i < strlen(al);i++)\n\t\t\tfor(j = 0;j < strlen(tr);j++) if(al[i] == tr[j]) tr[j] = '0' + f[i];\n\t\tret = calc(0,tl)==calc(0,tr);\n//\t\tprintf(\"%s=%s\",tl,tr);\n//\t\tprintf(\" %d\\n\",ret);\n\t\tret = min(1,ret);\n\t\treturn ret;\n\t}\n\tfor(i = 0;i < 2;i++){\n\t\tf[c] = i;\n\t\tret = min(ret,dfs(c + 1));\n\t}\n\treturn ret;\n}\n\n\nint main(void){\n\tunsigned int i, j;\n\tchar  c;\n\twhile(1){\n\t\tfor(i = 0;(c = getchar()) != '=' && c != '\\n';i++)\n\t\t\tl[i] = c;\n\t\tl[i] = '\\0';\n\t\tif(!strcmp(l,\"#\")) break;\n\t\tfor(i = 0;(c = getchar()) != '\\n';i++)\n\t\t\tr[i] = c;\n\t\tr[i] = '\\0';\n\t\tal[0] = '\\0';\n\t\tfor(i = 0;i < strlen(l);i++){\n\t\t\tif(islower(l[i])){\n\t\t\t\tfor(j = 0;j < strlen(al);j++)\n\t\t\t\t\tif(al[j] == l[i]) break;\n\t\t\t\tif(j == strlen(al)){\n\t\t\t\t\tal[j] = l[i];\n\t\t\t\t\tal[j + 1] = '\\0';\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t\tfor(i = 0;i < strlen(r);i++){\n\t\t\tif(islower(r[i])){\n\t\t\t\tfor(j = 0;j < strlen(al);j++)\n\t\t\t\t\tif(al[j] == r[i]) break;\n\t\t\t\tif(j == strlen(al)){\n\t\t\t\t\tal[j] = r[i];\n\t\t\t\t\tal[j + 1] = '\\0';\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t\tfor(i = 0;i < strlen(l);i++){\n\t\t\tif(l[i]=='T') l[i] = '1';\n\t\t\telse if(l[i]=='F') l[i] = '0';\n\t\t}\n\t\tfor(i = 0;i < strlen(r);i++){\n\t\t\tif(r[i]=='T') r[i] = '1';\n\t\t\telse if(r[i]=='F') r[i] = '0';\n\t\t}\n\t\tprintf(dfs(0)?\"YES\\n\":\"NO\\n\");\n\t}\n\treturn 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\n\nusing namespace std;\n\nstring lhs, rhs;\nint bit, idx;\n\nbool solve(string formula)\n{\n  bool ret;\n  char c = formula[idx];\n  if(c == '(') {\n    idx++, ret = solve(formula);\n    char op = formula[idx];\n    if(op == '-') idx+=2, ret = !ret | solve(formula);\n    else if(op == '*') idx++, ret &= solve(formula);\n    else if(op == '+') idx++, ret |= solve(formula);\n    idx++;\n  }\n  else if(c == ')') idx++;\n  else if(c == 'T') ret = true, idx++;\n  else if(c == 'F') ret = false, idx++;\n  else if(c == '-') idx++, ret = !solve(formula);\n  else if(isalpha(c)) ret = (bit >> (c-'a')) & 1, idx++;\n  return ret;\n}\n\nint main()\n{\n  string equation;\n  while(cin >> equation, equation != \"#\") {\n    lhs = equation.substr(0, equation.find('='));\n    rhs = equation.substr(equation.find('=') + 1);\n    bool hold = true;\n    for(bit = 0; bit < (1 << 11) && hold; bit++) {\n      string s = lhs, t = rhs;\n      idx = 0; bool judge = solve(lhs);\n      idx = 0; if(judge != solve(rhs)) hold = false;      \n      lhs = s, rhs = t;\n    }\n    cout << (hold ? \"YES\" : \"NO\") << endl;\n  }\n  return 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include <iostream>\n#include <string>\n#include <algorithm>\n#include <stack>\n\n#define rep2(i, b, n) for(int i=b; i < n; ++i)\n#define rep(i, n) rep2(i, 0, n)\n\n#define R(i, n) for(int i=0; i < 2; ++i) { val[n] = i;\n#define START R(a, 0)R(b, 1)R(c, 2)R(d, 3)R(e, 4)R(f, 5)R(g, 6)R(h, 7)R(i, 8)R(j, 9)R(k, 10)\n#define END }}}}}}}}}}}\n\n#define T 'l'\n#define F 'm'\n\nusing namespace std;\n\nstring gp( string str )\n{\n\tint len = str.size();\n\tstack<char> st;\n\tstring res = \"\";\n\trep(i, len) {\n\t\tchar c = str[i];\n\t\tswitch(c) {\n\t\tcase '(': case '+': case '*':\n\t\t\tst.push(c);\n\t\t\tbreak;\n\t\tcase ')':\n\t\t\twhile(1) {\n\t\t\t\tchar cc = st.top(); st.pop();\n\t\t\t\tif(cc == '(') break;\n\t\t\t\tres += cc;\n\t\t\t}\n\t\t\tif(!st.empty() && st.top() == '-') {\n\t\t\t\tres += st.top();\n\t\t\t\tst.pop();\n\t\t\t}\n\t\t\tbreak;\n\t\tcase '-': {\n\t\t\tswitch(str[i+1]) {\n\t\t\tcase '-': {\n\t\t\t\tint ii = 0;\n\t\t\t\tfor(ii=0; str[i+ii] == '-'; ++ii);\n\t\t\t\tif(ii & 1)\ti += ii - 2;\n\t\t\t\telse\t\ti += ii - 1;\n\t\t\t}\tbreak;\n\t\t\tcase '>':\n\t\t\t\tst.push('/');\n\t\t\t\t++i;\n\t\t\t\tbreak;\n\t\t\tcase '(':\n\t\t\t\tst.push(c);\n\t\t\t\tbreak;\n\t\t\tdefault:\n\t\t\t\tres += str[i+1];\n\t\t\t\tres += c;\n\t\t\t\t++i;\n\t\t\t\tbreak;\n\t\t\t}\n\t\t}\tbreak;\n\t\tdefault:\n\t\t\tres += c;\n\t\t\tbreak;\n\t\t}\n\t}\n\twhile(!st.empty()) {\n\t\tres += st.top(); st.pop();\n\t}\n\treturn res;\n}\n\nbool val[13];\n\nbool calc( string str )\n{\n\tint len = str.size();\n\tstack<char> st;\n\trep(i, len) {\n\t\tchar c = str[i];\n\t\tchar a, b;\n\t\tswitch(c) {\n\t\tcase '+':\n\t\t\ta = st.top(); st.pop();\n\t\t\tb = st.top(); st.pop();\n\t\t\tif(val[a-'a'] | val[b-'a'])\tst.push(T);\n\t\t\telse\t\t\t\t\t\tst.push(F);\n\t\t\tbreak;\n\t\tcase '-':\n\t\t\ta = st.top(); st.pop();\n\t\t\tif(val[a-'a'])\tst.push(F);\n\t\t\telse\t\t\tst.push(T);\n\t\t\tbreak;\n\t\tcase '*':\n\t\t\ta = st.top(); st.pop();\n\t\t\tb = st.top(); st.pop();\n\t\t\tif(val[a-'a'] & val[b-'a'])\tst.push(T);\n\t\t\telse\t\t\t\t\t\tst.push(F);\n\t\t\tbreak;\n\t\tcase '/':\n\t\t\tb = st.top(); st.pop();\n\t\t\ta = st.top(); st.pop();\n\t\t\tif(val[a-'a'] & !val[b-'a']) st.push(F);\n\t\t\telse\t\t\t\t\t\t st.push(T);\n\t\t\tbreak;\n\t\tdefault:\n\t\t\tst.push(c);\n\t\t\tbreak;\n\t\t}\n\t}\n\treturn val[st.top()-'a'];\n}\n\nint main( void )\n{\n\tval[11] = true;\n\tval[12] = false;\n\tstring input, sa, sb;\n\twhile(cin >> input, input[0] != '#') {\n\t\tsa = \"\"; sb = \"\";\n\t\tint len = input.size();\n\t\trep(i, len) {\n\t\t\tif\t\t(input[i] == 'T') input[i] = T;\n\t\t\telse if\t(input[i] == 'F') input[i] = F;\n\t\t}\n\t\tbool hit = true;\n\t\trep(i, len) {\n\t\t\tif(input[i] == '=') { hit = !hit; continue; }\n\t\t\tif(hit) sa += input[i];\n\t\t\telse    sb += input[i];\n\t\t}\n\t\tsa = gp(sa);\n\t\tsb = gp(sb);\n\t\tbool ans = true;\n\t\tSTART\n\t\t\tif(calc(sa) != calc(sb)) {\n\t\t\t\tans = false;\n\t\t\t\tgoto ANSWER;\n\t\t\t}\n\t\tEND\nANSWER:;\n\t\tif(ans)\n\t\t\tcout << \"YES\" << endl;\n\t\telse\n\t\t\tcout << \"NO\" << endl;\n\t}\n\treturn 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include <iostream>\n#include <sstream>\n#include <string>\n#include <algorithm>\n#include <vector>\n#include <stack>\n#include <queue>\n#include <set>\n#include <map>\n#include <cstdio>\n#include <cstdlib>\n#include <cstring>\n#include <cmath>\n#include <cassert>\n\nusing namespace std;\n\n#define FOR(i,k,n) for(int i=(k); i<(int)(n); ++i)\n#define REP(i,n) FOR(i,0,n)\n#define FORIT(i,c) for(__typeof((c).begin())i=(c).begin();i!=(c).end();++i)\n\ntemplate<class T> void debug(T begin, T end){ for(T i = begin; i != end; ++i) cerr<<*i<<\" \"; cerr<<endl; }\ninline bool valid(int x, int y, int W, int H){ return (x >= 0 && y >= 0 && x < W && y < H); }\n\ntypedef long long ll;\nconst int INF = 100000000;\nconst double EPS = 1e-8;\nconst int MOD = 1000000007;\nint dx[8] = {1, 0, -1, 0, 1, -1, -1, 1};\nint dy[8] = {0, 1, 0, -1, 1, 1, -1, -1};\nstruct Result{\n  bool value;\n  int p;\n  Result(bool b, int p) : value(b), p(p) {}\n};\nint S;\nResult expr(const string& s, int p);\nResult factor(const string& s, int p);\nbool is_ope(char c){\n  string s = \"*+-\";\n  REP(i, s.size()) if(c == s[i]) return true;\n  return false;\n}\nResult expr(const string& s, int p){\n  Result r = factor(s, p);\n  while(is_ope(s[r.p])){\n    if(s[r.p] == '-') assert(s[r.p + 1] == '>');\n    Result r_ = factor(s, (s[r.p] == '-') ? r.p + 2 : r.p + 1);\n    if(s[r.p] == '*'){\n      r.value = r.value && r_.value;\n    }else if(s[r.p] == '+'){\n      r.value = r.value || r_.value;\n    }else {\n      r.value = !r.value || r_.value;\n    }\n    r.p = r_.p;\n  }\n  return r;\n}\nResult factor(const string& s, int p){\n  if(s[p] == '('){\n    Result r = expr(s, p + 1);\n    assert(s[r.p] == ')');\n    r.p ++;\n    return r;\n  }else if(islower(s[p])){\n    return Result((S >> (s[p] - 'a')) & 1, p + 1);\n  }else if(s[p] == 'T'){\n    return Result(true, p + 1);\n  }else if(s[p] == 'F'){\n    return Result(false, p + 1);\n  }else if(s[p] == '-'){\n    Result r = factor(s, p + 1);\n    r.value ^= 1;\n    return r;\n  }else {\n    assert(false);\n  }\n}\n\nint main(){\n  string s;\n  while(cin >> s && s != \"#\"){\n    string a, b;\n    REP(i, s.size()) if(s[i] == '='){\n      a = s.substr(0, i);\n      b = s.substr(i + 1);\n    }\n    bool equal = true;\n    for(S = 0; S < 1<<10; S++){\n      if(expr(a, 0).value != expr(b, 0).value){\n        equal = false;\n        break;\n      }\n    }\n    if(equal) cout << \"YES\" << endl;\n    else cout << \"NO\" << endl;\n  }\n  return 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include <cstdio>\n#include <cstdlib>\n#include <cmath>\n#include <climits>\n#include <cfloat>\n#include <map>\n#include <utility>\n#include <ctime>\n#include <set>\n#include <iostream>\n#include <memory>\n#include <string>\n#include <vector>\n#include <algorithm>\n#include <functional>\n#include <sstream>\n#include <complex>\n#include <stack>\n#include <queue>\n#include <cstring>\n#include <numeric>\n#include <cassert>\nusing namespace std;\nstatic const double EPS = 1e-10;\ntypedef long long ll;\n#define rep(i,n) for(int i=0;i<n;i++)\n#define rev(i,n) for(int i=n-1;i>=0;i--)\n#define all(a) a.begin(),a.end()\n#define mp(a,b) make_pair(a,b)\n#define pb(a) push_back(a)\n#define SS stringstream\n#define DBG1(a) rep(_X,sz(a)){printf(\"%d \",a[_X]);}puts(\"\");\n#define DBG2(a) rep(_X,sz(a)){rep(_Y,sz(a[_X]))printf(\"%d \",a[_X][_Y]);puts(\"\");}\n#define bitcount(b) __builtin_popcount(b)\n#define EACH(i,c) for(typeof((c).begin()) i=(c).begin(); i!=(c).end(); ++i)\n\n#define delete(a,n) a.erase(remove(all(a),n),a.end())\ntemplate<typename T, typename S> vector<T>& operator<<(vector<T>& a, S b) { a.push_back(b); return a; }\ntemplate<typename T> void operator>>(vector<T>& a, int b) {while(b--)if(!a.empty())a.pop_back();}\nbool isprime(int n){ if(n<2)return false;  for(int i=2;i*i<=n;i++)if(n%i==0)return false;  return true;} \nll b_pow(ll x,ll n){return n ? b_pow(x*x,n/2)*(n%2?x:1) : 1ll;}\nstring itos(int n){stringstream ss;ss << n;return ss.str();}\n\nint val[128];\n\nstring ln;\nint pos;\n\nint fm();\n\nint eq(){\n\tint A = fm();\n\tassert(ln[pos] == '=');\n\tpos++;\n\tint B = fm();\n\treturn A == B;\n}\nint fm(){\n\t//cout << ln[pos] << endl;\n\tif( ln[pos] == 'T'){ pos++; return 1; }\n\tif( ln[pos] == 'F'){ pos++; return 0; }\n\tif( 'a' <= ln[pos] && ln[pos] <= 'k'){ pos++; return val[ln[pos]]; }\n\tif( ln[pos] == '-' ){ pos++;return !fm(); }\n\tif( ln[pos] == '('){\n\t\tpos++;\n\t\tint A = fm();\n\t\tif( ln[pos] == '*'){pos++; A = A & fm();}\n\t\telse if(ln[pos] == '+'){pos++; A = A | fm();}\n\t\telse if(ln[pos] == '-'){\n\t\t\tpos += 2;\n\t\t\tA = !A | fm();\n\t\t}else{\n\t\t\tassert(0);\n\t\t}\n\t\tpos++;\n\t\treturn A;\n\t}\n}\n\n\nint main(){\n\twhile(cin >> ln && ln != \"#\" ){\n\t\tint ok = 1;\n\t\tfor(int i = 0 ; i < (1<<11) ; i++){\n\t\t\tfor(int j = 0 ; j < 11 ; j++) val[j+'a'] = i>>j&1;\n\t\t\tpos = 0;\n\t\t\tok &= eq();\n\t\t}\n\t\tcout << (ok?\"YES\":\"NO\") << endl;\n\t}\n}"
  },
  {
    "language": "C++",
    "code": "#include <functional>\n#include <iostream>\n#include <string>\n#include <unordered_set>\n#include <vector>\n#define loop(i, a, n) for (int i = (a); i < (n); i++)\n#define rep(i, n) loop(i, 0, n)\ntemplate<typename A> using F = std::function<A>;\nusing namespace std;\n\ntemplate<typename T> struct ParseResult {\n  bool succeeded;\n  T object;\n  int pos;\n  ParseResult(const bool succeeded, const T &object, const int pos) : succeeded(succeeded), object(object), pos(pos) {}\n  friend std::ostream &operator<<(std::ostream &os, const ParseResult<T> &p) { return os << '{' << (p.succeeded ? \"true\" : \"false\") << ',' << p.object << ',' << p.pos << '}'; }\n};\n\ntemplate<typename T> using Parser = std::function<ParseResult<T>(const std::string&, int)>;\n\nParser<std::string> token(std::string &&s) {\n  const auto n = s.size();\n  return[n = std::move(n), s = std::move(s)](const std::string &target, const int pos) {\n    if (target.size() < n) return ParseResult<std::string>(false, {}, pos);\n    return target.substr(pos, n) == s ? ParseResult<std::string>(true, s, pos + n) : ParseResult<std::string>(false, {}, pos);\n  };\n}\n\ntemplate<typename T> Parser<T> operator||(Parser<T> p1, Parser<T> p2) {\n  return[p1 = std::move(p1), p2 = std::move(p2)](const std::string &target, const int pos) {\n    auto r = p1(target, pos);\n    if (r.succeeded) return r;\n    r = p2(target, pos);\n    if (r.succeeded) return r;\n    return ParseResult<T>(false, {}, pos);\n  };\n}\n\ntemplate<typename T1, typename T2> Parser<std::pair<T1, T2>> operator+(Parser<T1> p1, Parser<T2> p2) {\n  return[p1 = std::move(p1), p2 = std::move(p2)](const std::string &target, const int pos) {\n    auto r1 = p1(target, pos);\n    if (!r1.succeeded) return ParseResult<std::pair<T1, T2>>(false, {}, pos);\n    auto r2 = p2(target, r1.pos);\n    if (!r2.succeeded) return ParseResult<std::pair<T1, T2>>(false, {}, pos);\n    return ParseResult<std::pair<T1, T2>>(true, { r1.object, r2.object }, r2.pos);\n  };\n}\n\ntemplate<typename T1, typename T2> Parser<T2> operator>>(Parser<T1> p1, Parser<T2> p2) {\n  return[p1 = std::move(p1), p2 = std::move(p2)](const std::string &target, const int pos) {\n    auto r1 = p1(target, pos);\n    if (!r1.succeeded) return ParseResult<T2>(false, {}, pos);\n    auto r2 = p2(target, r1.pos);\n    if (!r2.succeeded) return ParseResult<T2>(false, {}, pos);\n    return ParseResult<T2>(true, r2.object, r2.pos);\n  };\n}\n\ntemplate<typename T1, typename T2> Parser<T1> operator<<(Parser<T1> p1, Parser<T2> p2) {\n  return[p1 = std::move(p1), p2 = std::move(p2)](const std::string &target, const int pos) {\n    auto r1 = p1(target, pos);\n    if (!r1.succeeded) return ParseResult<T1>(false, {}, pos);\n    auto r2 = p2(target, r1.pos);\n    if (!r2.succeeded) return ParseResult<T1>(false, {}, pos);\n    return ParseResult<T1>(true, r1.object, r2.pos);\n  };\n}\n\nParser<char> oneOf(const std::string &s) {\n  std::unordered_set<char> d;\n  for (auto &c : s) d.insert(c);\n  return[d = std::move(d)](const std::string &target, const int pos) {\n    if (target.size() <= pos) return ParseResult<char>(false, {}, pos);\n    char c = target[pos];\n    return d.count(c) ? ParseResult<char>(true, c, pos + 1) : ParseResult<char>(false, {}, pos);\n  };\n}\n\ntemplate<typename T, typename S, typename F> Parser<S> fmap(Parser<T> p, F &&f) {\n  return[p = std::move(p), f = std::forward<F>(f)](const std::string &target, const int pos) {\n    auto r = p(target, pos);\n    return r.succeeded ? ParseResult<S>(true, f(r.object), r.pos) : ParseResult<S>(false, {}, r.pos);\n  };\n}\n\ntemplate<typename T, typename F> Parser<T> lazy(F &&f) {\n  static bool instantiated = false;\n  static Parser<T> p;\n  return[f = std::forward<F>(f)](const std::string &target, const int pos) {\n    if (!instantiated) {\n      p = f();\n      instantiated = true;\n    }\n    return p(target, pos);\n  };\n}\n\nstruct SyntaxTree {\n  string op;\n  char value;\n  vector<SyntaxTree> children;\n  SyntaxTree() {}\n  SyntaxTree(const string &op, const char value, const vector<SyntaxTree> &children) : op(op), value(value), children(children) {}\n};\n\nint main() {\n  Parser<SyntaxTree> formulaP = lazy<SyntaxTree>([&]() {\n    auto andP = fmap<pair<SyntaxTree, SyntaxTree>, SyntaxTree>((token(\"(\") >> formulaP << token(\"*\")) + (formulaP << token(\")\")), [](auto &o) { return SyntaxTree(\"*\", {}, { o.first, o.second }); });\n    auto orP = fmap<pair<SyntaxTree, SyntaxTree>, SyntaxTree>((token(\"(\") >> formulaP << token(\"+\")) + (formulaP << token(\")\")), [](auto &o) { return SyntaxTree(\"+\", {}, { o.first, o.second }); });\n    auto impP = fmap<pair<SyntaxTree, SyntaxTree>, SyntaxTree>((token(\"(\") >> formulaP << token(\"->\")) + (formulaP << token(\")\")), [](auto &o) { return SyntaxTree(\"->\", {}, { o.first, o.second }); });\n    auto notP = fmap<SyntaxTree, SyntaxTree>(token(\"-\") >> formulaP, [](auto &o) { return SyntaxTree(\"-\", {}, { o }); });\n    auto valP = fmap<char, SyntaxTree>(oneOf(\"abcdefghijkTF\"), [](char x) { return SyntaxTree({}, x, {}); });\n    return andP || orP || impP || notP || valP;\n  });\n  auto equationP = (formulaP << token(\"=\")) + formulaP;\n  string s;\n  while (cin >> s, s != \"#\") {\n    auto r = equationP(s, 0);\n    bool isValid = true;\n    rep(i, 1 << 11) {\n      auto toBool = [&](char c) -> bool {\n        if (c == 'T') return true;\n        if (c == 'F') return false;\n        return i >> (c - 'a') & 1;\n      };\n      F<bool(const SyntaxTree&)> evalF = [&](const SyntaxTree &f) {\n        switch (f.children.size()) {\n        case 0: return toBool(f.value);\n        case 1: return !evalF(f.children[0]);\n        case 2:\n          if (f.op == \"*\") return evalF(f.children[0]) && evalF(f.children[1]);\n          if (f.op == \"+\") return evalF(f.children[0]) || evalF(f.children[1]);\n          if (f.op == \"->\") return !evalF(f.children[0]) || evalF(f.children[1]);\n        }\n      };\n      isValid &= evalF(r.object.first) == evalF(r.object.second);\n    }\n    cout << (isValid ? \"YES\" : \"NO\") << endl;\n  }\n}"
  },
  {
    "language": "C++",
    "code": "#include <cstdio>\n#include <iostream>\n#include <cmath>\n#include <ctype.h>\n#include <string> \n#include <sstream>\n#include <iostream>\n#include <algorithm>\n#include <cstdlib>\n#include <map>\n#include <queue>\n#include <utility>\n#include <vector>\n#include <set>\n#include <list>\n#include <cstring>\n#include <stack>\n   \nusing namespace std;\n\nint main()\n{\n    string s;\n    while(1){\n        cin >> s;\n        if(s == \"#\") break;\n        char en[12] = {'a', 'b', 'c', 'd', 'e', 'f', 'g', 'h', 'i', 'j', 'k'};\n        bool ok = true;\n        for(int i = 0; i < (1 << 11); i++){\n            map<char, char> chara;\n            int nowi = i;\n            chara['1'] = '1';\n            chara['0'] = '0';\n            chara['T'] = '1';\n            chara['F'] = '0';\n            chara['('] = '(';\n            chara['='] = '=';\n            chara['*'] = '*';\n            chara['+'] = '+';\n            chara['-'] = '-';\n            chara['>'] = '>';\n            for(int j = 10; j >= 0; j--){\n                chara[en[j]] = (nowi / (int)pow(2, j)) + '0';\n                nowi = nowi % (int)pow(2, j);\n                // cout << chara[en[j]];\n            }\n            // cout << endl;\n            stack<char> st;\n            for(int j = 0; j < s.length(); j++){\n                if(s[j] == ')'){\n                    char y = st.top();\n                    // cout <<\"y:\" << y << endl;\n                    st.pop();\n                    if(st.top() == '-'){\n                        st.pop();\n                        if(y == '0') y = '1';\n                        else y = '0';\n                    }\n                    char op = st.top();\n                    // cout << \"op:\" << op << endl;\n                    if(op == '>') st.pop();\n                    st.pop();\n                    char x = st.top();\n                    // cout << \"x:\" << x << endl;\n                    st.pop();\n                    if(st.top() == '-'){\n                        st.pop();\n                        if(x == '0') x = '1';\n                        else x = '0';\n                    }\n                    // cout << \"hey \" << st.top() << endl;\n                    st.pop();\n                    // cout << x << \" \" << op << \" \" << y << endl;\n                    if(op == '*'){\n                        if(x == '1' && y == '1') st.push('1');\n                        else st.push('0');\n                    } else if(op == '+'){\n                        if(x == '0' && y == '0') st.push('0');\n                        else st.push('1');\n                    } else if(op == '>'){\n                        if(x == '1' && y == '0') st.push('0');\n                        else st.push('1');\n                    }\n                } else {\n                    // cout << chara[s[j]] << endl;\n                    st.push(chara[s[j]]);\n                }\n            }\n            char e2 = st.top();\n            st.pop();\n            if(st.top() == '-'){\n                st.pop();\n                if(e2 == '1') e2 = '0';\n                else e2 = '1';\n            }\n            st.pop();\n            char e1 = st.top();\n            st.pop();\n            if(!st.empty()){\n                st.pop();\n                if(e1 == '1') e1 = '0';\n                else e1 = '1';\n            }\n            // cout << st.size() << endl;\n            if(e1 != e2){\n                ok = false;\n                break;\n            }\n        }\n        if(ok) cout << \"YES\" << endl;\n        else cout << \"NO\" << endl;\n    }\n    return 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include<iostream>\n#include<vector>\n#include<string>\n#include<algorithm>\n#define all(c) c.begin(),c.end()\n#define uni(c) c.erase(unique(c.begin(),c.end()),c.end())\n#define pb push_back\nusing namespace std;\n\nstring cc(string s,string x,string y){\n\tstring t=\"\";\n\tfor(int i=0;i<s.size();i++){\n\t\tif(s.substr(i,x.size())==x){\n\t\t\tt+=y;\n\t\t\ti+=x.size()-1;\n\t\t}else{\n\t\t\tt+=s[i];\n\t\t}\n\t}\n\treturn t;\n}\n\n\nint expr(string& s, int& i);\nint term(string& s, int& i);\nint factor(string& s, int& i);\nint number(string& s, int& i);\n \n \nint expr(string& s, int& i) {\n\tint val = factor(s, i);\n\twhile(s[i] == '+' || s[i] == '-'|| s[i]=='*') {\n\t\tchar op = s[i];\n\t\ti++;\n\t\tif(s[i]=='>'){\n\t\t\ti++;\n\t\t\tint val2 = factor(s, i);\n\t\t\tif(val==1&&val2==0){\n\t\t\t\tval=0;\n\t\t\t}else{\n\t\t\t\tval=1;\n\t\t\t}\n\t\t}else{\n\t\t\tint val2 = factor(s, i);\n\t\t\tif (op == '+') \n\t\t\t\tval |= val2;\n\t\t\telse if(op=='*')\n\t\t\t\tval *= val2;\n\t\t\t//cout<<\"   \"<<val<<\" \"<<val2<<endl;\n\t\t}\n\t}\n\treturn val;\n}\nint factor(string& s, int& i) {\n\tint flag=0;\n\tif(s[i]=='-'){\n\t\tflag=1;\n\t\ti++;\n\t}\n\tif (isdigit(s[i])){\n\t\t\n\t\tint num=(s[i]-'0');\n\t\ti++;\n\t\t\n\t\t//cout<<s[i]<<endl;\n\t\tif(flag)\n\t\t\treturn flag^num;\n\t\treturn num;\n\t}\n\t// ここで構文が正しければ s[i] == '(' となる\n\ti++; // '('を読み飛ばす\n\tint ret = expr(s, i);\n\ti++; // ')'を読み飛ばす\n\tif(flag)\n\t\treturn flag^ret;\n\treturn ret;\n}\n \nint main(){\n    string s;\n    while(cin>>s,s!=\"#\"){\n        int eq=0;\n        string a,b;\n        for(int i=0;i<s.size();i++){\n            if(s[i]=='T')\n            s[i]='1';\n            else if(s[i]=='F')\n            s[i]='0';\n        }\n        for(;s[eq]!='=';eq++);\n        a=s.substr(0,eq),b=s.substr(eq+1,s.size()-eq);\n        //cout<<a<<\" \"<<b<<endl;\n        vector<char> ap;\n         \n        for(int i=0;i<s.size();i++){\n            if(isalpha(s[i]))\n                ap.pb(s[i]);\n        }\n        sort(all(ap));\n        uni(ap);\n        bool flag=true;\n        for(int i=0;i<(1<<ap.size());i++){\n            string x=a,y=b;\n            for(int j=0;j<ap.size();j++){\n                char c=ap[j];\n                bool wh=false;\n                if((1<<j)&i)\n                    wh=true;\n                for(int k=0;k<x.size();k++){\n                    if(x[k]==c){\n                        if(wh)\n                            x[k]='1';\n                        else\n                            x[k]='0';\n                    }\n                }\n                for(int k=0;k<y.size();k++){\n                    if(y[k]==c){\n                        if(wh)\n                            y[k]='1';\n                        else\n                            y[k]='0';\n                    }\n                }\n            }\n             \n            int p=0,q=0;\n        \tx=cc(x,\"--\",\"\");\n        \ty=cc(y,\"--\",\"\");\n            if(expr(x,p)!=expr(y,q)){\n                cout<<\"NO\"<<endl;\n                flag=false;\n                break;\n            }\n             \n        }\n        if(flag)\n            cout<<\"YES\"<<endl;\n    }\n    return 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include<cstdio>\n#include<iostream>\n#include<string>\n\nusing namespace std;\n\nstring inp;\nint cnt;\nint val;\n\nbool culc(bool a,char c,bool b){\n\tswitch((char)c){\n\tcase '+':\n\t\treturn a||b;\n\tcase '*':\n\t\treturn a&&b;\n\tcase '>':\n\t\tif(a==false&&b==true) return false;\n\t\telse return true;\n\t}\n}\n\nchar formula2(){\n\tcnt++;\n\tif(inp[cnt]=='>') cnt++;\n\treturn (char)inp[cnt-1];\n}\n\nbool formula(){\n\tbool f;\n\tswitch(inp[cnt]){\n\t  case '-':\n\t\tcnt++;\n\t\tf=formula();\n\t\tif(f==1) f=0;\n\t\telse f=1;\n\t    break;\n\t  case '(':\n\t\tcnt++;\n\t\tf=culc(formula(),formula2(),formula());\n\t\tcnt++;\n\t\tbreak;\n\t  case 'T':\n\t\t  cnt++;\n\t\t  f=true;\n\t\t  break;\n\t  case 'F':\n\t\t  cnt++;\n\t\t  f=false;\n\t\t  break;\n\t  default:\n\t\t  f=(val>>(inp[cnt]-'a'))&1;\n\t\t  cnt++;\n\t\t  break;\n\t}\n\treturn f;\n}\n\nint main(void){\n\n\tbool left,right;\n\tbool ans;\n\n\twhile(1){\n\t\tcin>>inp;\n\t\tif(inp==\"#\") break;\n\t\tans=true;\n\t\tfor(val=0;val<(1<<11);val++){\n\t\t\tcnt=0;\n\t\t\tleft=formula();\n\t\t\tcnt++;\n\t\t\tright=formula();\n\t\t\tif(left!=right){\n\t\t\t\tans=false;\n\t\t\t\tbreak;\n\t\t\t}\n\t\t}\n\t\tif(ans) cout<<\"YES\"<<endl;\n\t\telse cout<<\"NO\"<<endl;\n\t}\n\n\treturn 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include <iostream>\n#include <string>\n#include <sstream>\n#include <cctype>\n#include <cassert>\nusing namespace std;\n\nistringstream iss;\n\nint m;\n\nvoid consume(char expect) {\n  char ch; iss>>ch;\n  if(expect!=ch) {\n    cerr<<\"Error: expect '\"<<expect<<\"' but got '\"<<ch<<\"'\"<<endl;\n    cerr<<\"Rest string is \";\n    string rest;\n    while(!iss.eof()) { iss>>rest; cerr<<rest; }\n    cerr<<endl;\n    exit(EXIT_FAILURE);\n  }\n}\n\nbool formula() {\n  char ch; iss>>ch;\n  \n  if(isalpha(ch)) {\n    if(ch=='T') return true;\n    if(ch=='F') return false;\n    else {\n      return m >> (ch-'a') & 1;\n    }\n  }\n\n  if(ch=='-') return !formula();\n\n  assert(ch=='(');\n  bool f1 = formula();\n  iss >> ch;\n  if(ch=='-') consume('>');\n  bool f2 = formula();\n  consume(')');\n  if(ch=='*') return f1&&f2;\n  if(ch=='+') return f1||f2;\n  return f1<=f2;\n    \n}\n\nbool solve(const string &input) {\n  for(m = 0; m < (1<<11); m++) {\n    iss.clear(); iss.str(input);\n    bool left=formula();\n    consume('=');\n    bool right=formula();\n    if(left!=right) { return false; }\n  }\n  return true;\n}\n\nint main() {\n  string str;\n  \n  while(getline(cin,str), str!=\"#\") {\n    cout << (solve(str) ? \"YES\" : \"NO\") << endl;\n  }\n\n  return 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include<iostream>\n#include<string>\n#include<map>\n#include<sstream>\n#include<cctype>\n#include<algorithm>\nusing namespace std;\ntypedef string::const_iterator Cursol;\nbool ok;\nint bit;\nbool Formula(Cursol &c){\n  bool ret = false;\n  if(*c == '('){\n    ret = Formula(++c);\n    c++;\n    return ret;\n  }\n  bool bs = false;\n  if(*c == '-'){\n    bs = true;\n    c++;\n  }\n  if(*c == 'T'){\n    ret = true;\n  }else if(*c == 'F'){\n    ret = false;\n    c++;\n  }else if(islower(*c)){\n    ret = 1 << ((*c) - 'a');\n    c++;\n  }\n  if(*c == '+'){\n    ret |= Formula(++c);\n  }else if(*c == '*'){\n    ret &= Formula(++c);\n  }else if(*c == '-'){\n    c++;\n    if(ret && !Formula(++c)) ret = true;\n    else ret = false;\n    c++;\n  }\n  return bs ? !ret : ret;\n}\nint main(){\n  string s;\n  Cursol c;\n  while(cin >> s , ok = true, s != \"#\"){\n    string l = s.substr(0,s.find('='));\n    string r = s.substr(s.find('=')+1);\n\n    for(bit = 0 ; bit < ( 1 << 11 ) - 1 ; bit++ ){\n      c = l.begin();\n      bool java = Formula(c);\n      c = r.begin();\n      if( java != Formula(c) ){\n\tok = false;\n\tbreak;\n      }\n    }\n    if(ok) cout << \"YES\" << endl;\n    else cout << \"NO\" << endl;\n  }\n}"
  },
  {
    "language": "C++",
    "code": "#include<iostream>\n#include<string>\n#include<map>\n#include<sstream>\n#include<cctype>\n#include<algorithm>\nusing namespace std;\ntypedef string::const_iterator Cursol;\nbool ok;\nint bit;\nbool Formula(Cursol &c){\n  if(*c == ')') return true;\n\n  bool ret = false;\n  if(*c == '('){\n    ret = Formula(++c);\n    c++;\n    return ret;\n  }\n  \n  bool bs = false;\n  if(*c == '-'){\n    bs = true;\n    c++;\n  }\n\n  if(*c == 'T'){\n    ret = true;\n  }else if(*c == 'F'){\n    ret = false;\n    c++;\n  }else if(islower(*c)){\n    ret = 1 << ((*c) - 'a');\n    c++;\n  }\n\n  if(*c == '+'){\n    ret |= Formula(++c);\n  }else if(*c == '*'){\n    ret &= Formula(++c);\n  }else if(*c == '-'){\n    c++;\n    if(ret && !Formula(++c)) ret = true;\n    else ret = false;\n  }\n  return bs ? !ret : ret;\n}\nint main(){\n  string s;\n  Cursol c;\n  while(cin >> s , ok = true, s != \"#\"){\n    string l = s.substr(0,s.find('='));\n    string r = s.substr(s.find('=')+1);\n\n    for(bit = 0 ; bit < ( 1 << 11 ) - 1 ; bit++ ){\n      c = l.begin();\n      bool java = Formula(c);\n      c = r.begin();\n      if( java != Formula(c) ){\n\tok = false;\n\tbreak;\n      }\n    }\n    if(ok) cout << \"YES\" << endl;\n    else cout << \"NO\" << endl;\n  }\n}"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\n \nusing namespace std;\nusing ll = long long;\n#define int ll\nusing PII = pair<int, int>;\n \n#define FOR(i, a, n) for (ll i = (ll)a; i < (ll)n; ++i)\n#define REP(i, n) FOR(i, 0, n)\n#define ALL(x) x.begin(), x.end()\n \ntemplate<typename T> T &chmin(T &a, const T &b) { return a = min(a, b); }\ntemplate<typename T> T &chmax(T &a, const T &b) { return a = max(a, b); }\ntemplate<typename T> bool IN(T a, T b, T x) { return a<=x&&x<b; }\ntemplate<typename T> T ceil(T a, T b) { return a/b + !!(a%b); }\n\ntemplate<typename T> vector<T> make_v(size_t a) { return vector<T>(a); }\ntemplate<typename T,typename... Ts>\nauto make_v(size_t a,Ts... ts) { \n  return vector<decltype(make_v<T>(ts...))>(a,make_v<T>(ts...));\n}\ntemplate<typename T,typename V> typename enable_if<is_class<T>::value==0>::type\nfill_v(T &t, const V &v) { t=v; }\ntemplate<typename T,typename V> typename enable_if<is_class<T>::value!=0>::type\nfill_v(T &t, const V &v ) { for(auto &e:t) fill_v(e,v); }\n\ntemplate<class S,class T>\nostream &operator <<(ostream& out,const pair<S,T>& a){\n  out<<'('<<a.first<<','<<a.second<<')'; return out;\n}\ntemplate<typename T>\nistream& operator >> (istream& is, vector<T>& vec){\n  for(T& x: vec) {is >> x;} return is;\n}\ntemplate<class T>\nostream &operator <<(ostream& out,const vector<T>& a){\n  out<<'['; for(T i: a) {out<<i<<',';} out<<']'; return out;\n}\n\nint dx[] = {0, 1, 0, -1}, dy[] = {1, 0, -1, 0}; // DRUL\nconst int INF = 1<<30;\nconst ll LLINF = 1LL<<60;\nconst int MOD = 1000000007;\n\nint pos;\nstring s;\n\nchar formula() {\n  if(s[pos] == '-') {\n    pos++;\n    char tmp = formula();\n    // cout << pos << \" \" << tmp << endl;\n    if(tmp == 'F') tmp = 'T';\n    else tmp = 'F';\n    // cout << pos << \" \" << tmp << endl;\n    return tmp;\n  } \n  if(s[pos] == '(') {\n    pos++;\n    char vl = formula();\n    char op = s[pos++];\n    if(op == '-') pos++;\n    char vr = formula();\n    pos++;\n\n    char ret;\n    // cout << op << endl;\n    if(op == '*') {\n      if(vl == 'T' && vr == 'T') ret = 'T';\n      else ret = 'F';\n    } else if(op == '+') {\n      if(vl == 'F' && vr == 'F') ret = 'F';\n      else ret = 'T';\n    } else if(op == '-') {\n      if(vl == 'T' && vr == 'F') ret = 'F';\n      else ret = 'T';\n    }\n    return ret;\n  }\n  return s[pos++];\n}\n\nsigned main(void)\n{\n  cin.tie(0);\n  ios::sync_with_stdio(false);\n\n  while(1) {\n    string t;\n    cin >> t;\n    if(t == \"#\") break;\n\n    int m = 0;\n    map<char,int> mp;\n    REP(i, t.size()) {\n      if(isalpha(t[i])) {\n        if(mp.find(t[i]) == mp.end()) mp[t[i]] = m++;\n      }\n    }\n    REP(i, t.size()) {\n      if(isalpha(t[i])) {\n        t[i] = (char)(mp[t[i]] + 'a');\n      }\n    }\n\n    bool flag = true;\n    REP(i, 1LL<<m) {\n      string str = t;\n      REP(j, str.size()) {\n        if(isalpha(str[j])) {\n          if(i&(1<<(str[j]-'a'))) str[j] = 'T';\n          else str[j] = 'F';\n        }\n      }\n\n      int idx = str.find('=');\n      pos = 0;\n      s = str.substr(0, idx);\n      // cout << s << endl;\n      char vl = formula();\n      // cout << vl << endl;\n      pos = 0;\n      s = str.substr(idx+1);\n      // cout << s << endl;\n      char vr = formula();\n      // cout << vr << endl;\n\n      if(vl != vr) {\n        flag = false;\n        break;\n      }\n    }\n\n    if(flag) {\n      cout << \"YES\" << endl;\n    } else {\n      cout << \"NO\" << endl;\n    }\n  }\n\n  return 0;\n}\n\n"
  },
  {
    "language": "C++",
    "code": "#include <iostream>\n#include <string>\nusing namespace std;\n\nlong long int h[11];\nstring in;\nlong long int l[4][4] = { { 0, 0, 0, 1 }, { 0, 1, 1, 1 }, { 1, 1, 0, 1 }, { 1, 0, 0, 1 } };\n\npair< long long int, long long int > kansu( long long int n ) {\n\n  long long int hitei = 0;\n  long long int k[2];\n  long long int b = 0;\n  long long int e;\n\n  while( true ) {\n\n    if ( in[n] == '-' && in[n+1] != '>' ) {\n      hitei ^= 1;\n      n++;\n    }else if ( in[n] == '*' ) {\n      e = 0;\n      n++;\n    }else if ( in[n] == '+' ) {\n      e = 1;\n      n++;\n    }else if ( in[n] == '-' ) {\n      e = 2;\n      n += 2;\n    }else if ( in[n] == '=' ) {\n      e = 3;\n      n++;\n    }else if ( in[n] == ')' ) {\n      if ( hitei == 1 ) k[0] ^= 1;\n      return make_pair( k[0], n );\n    }else {\n      if ( in[n] == '(' ) {\n\tpair< long long int, long long int > p = kansu( n + 1 );\n\tk[b] = p.first;\n\tn = p.second + 1;\n      }else if ( in[n] == 'T' ) {\n\tk[b] = 1;\n\tn++;\n      }else if ( in[n] == 'F' ) {\n\tk[b] = 0;\n\tn++;\n      }else {\n\tk[b] = h[ in[n] - 'a' ];\n\tn++;\n      }\n      if ( hitei == 1 ) k[b] ^= 1;\n      if ( b == 0 ) {\n\tb++;\n\thitei = 0;\n      }else {\n\t//\tcout << k[0] << \" \" << e << \" \" << k[1] << \" = \" << l[e][ k[0] * 2 + k[1] ] << endl;\n\treturn make_pair( l[e][ k[0] * 2 + k[1] ], n );\n      }\n    }\n\n  }\n\n}\n\nint main() {\n\n  while( true ) {\n\n    cin >> in;\n    if ( in == \"#\" ) break;\n\n    bool b = true;\n\n    for ( long long int i = 0; i < (1<<11); i++ ) {\n      long long int k = i;\n      for ( long long int j = 0; j < 11; j++ ) {\n\th[j] = k % 2;\n\tk /= 2;\n      }\n      if ( kansu( 0 ).first == 0 ) {\n\tb = false;\n\tbreak;\n      }\n    }\n    if ( b == true ) {\n      cout << \"YES\" << endl;\n    }else {\n      cout << \"NO\" << endl;\n    }\n\n  }\n\n  return 0;\n\n}"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\nusing namespace std;\n\nenum node_type{\n    ND_CONST,\n    ND_IDENT,\n    ND_NOT,\n    ND_AND,\n    ND_OR,\n    ND_IF\n};\n\nstruct node{\n    node_type type;\n    node *lhs, *rhs;\n    int value;\n};\n\nchar *code;\nnode *formula();\n\npair<node *, node *> equation(char *c){\n    code = c;\n    node *n1 = formula();\n    assert(*(code++) == '=');\n    node *n2 = formula();\n    assert(*code == '\\0');\n\n    return {n1, n2};\n}\nnode *formula(){\n    node *n = new node();\n    if(*code == 'T' || *code == 'F'){\n        n->type = ND_CONST;\n        n->value = (*(code++) == 'T');\n        return n;\n    }\n    if('a' <= *code && *code <= 'k'){\n        n->value = *(code++) - 'a';\n        n->type = ND_IDENT;\n        return n;\n    }\n    if(*code == '-'){\n        ++code;\n        n->type = ND_NOT;\n        n->lhs = formula();\n        return n;\n    }\n    if(*code == '('){\n        ++code;\n        n->lhs = formula();\n        if(*code == '+'){\n            ++code;\n            n->type = ND_OR;\n            n->rhs = formula();\n        }else if(*code == '*'){\n            ++code;\n            n->type = ND_AND;\n            n->rhs = formula();\n        }else{\n            assert(strncmp(code, \"->\", 2) == 0);\n            code += 2;\n            n->type = ND_IF;\n            n->rhs = formula();\n        }\n        assert(*(code++) == ')');\n        return n;\n    }\n    assert(false);\n}\nint value(node *n, int ptn){\n    switch(n->type){\n    case ND_CONST:\n        return n->value;\n    case ND_IDENT:\n        return (ptn >> n->value) & 1;\n    case ND_NOT:\n        return value(n->lhs, ptn) ^ 1;\n    case ND_AND:\n        return value(n->lhs, ptn) & value(n->rhs, ptn);\n    case ND_OR:\n        return value(n->lhs, ptn) | value(n->rhs, ptn);\n    default:\n        return (value(n->lhs, ptn) ^ 1) | value(n->rhs, ptn);\n    }\n}\nbool solve(char *code){\n    auto eq = equation(code);\n    for(int ptn=0;ptn<(1<<11);++ptn){\n        if(value(eq.first, ptn) != value(eq.second, ptn)){\n            return false;\n        }\n    }\n    return true;\n}\n\nint main(){\n    char code[1001];\n    while(true){\n        scanf(\"%s\", code);\n        if(*code == '#') break;\n        printf(\"%s\\n\", solve(code) ? \"YES\" : \"NO\");\n    }\n    return 0;\n}\n"
  },
  {
    "language": "C++",
    "code": "#define _CRT_SECURE_NO_WARNINGS\n#include <cstdio>\n#include <stdio.h>\n#include <stdlib.h>\n#include <algorithm>\n#include <vector>\n#include <string>\n#include <iostream>\n\nusing namespace std;\n\nstring& replace(string& str, char moto, char kawaru) {\n\tstd::string::size_type n;\n\t;\n\twhile ((n = str.find(moto)) != std::string::npos) {\n\t\tstr.replace(n, 1, 1, kawaru);\n\t}\n\treturn str;\n}\n\n\nstring& replace(string& str, const string& moto, char kawaru) {\n\tstd::string::size_type n;\n\t;\n\twhile ((n = str.find(moto)) != std::string::npos) {\n\t\tstr.replace(n, moto.length(), 1, kawaru);\n\t}\n\treturn str;\n}\n\nbool calc(int flag, string& str) {\n\n\twhile (str.length() != 1) {\n\t\treplace(str, \"-T\", 'F');\n\t\treplace(str, \"-F\", 'T');\n\t\treplace(str, \"(T+T)\", 'T');\n\t\treplace(str, \"(T+F)\", 'T');\n\t\treplace(str, \"(F+T)\", 'T');\n\t\treplace(str, \"(F+F)\", 'F');\n\t\treplace(str, \"(T*T)\", 'T');\n\t\treplace(str, \"(T*F)\", 'F');\n\t\treplace(str, \"(F*T)\", 'F');\n\t\treplace(str, \"(F*F)\", 'F');\n\t\treplace(str, \"(T->T)\", 'T');\n\t\treplace(str, \"(T->F)\", 'F');\n\t\treplace(str, \"(F->T)\", 'T');\n\t\treplace(str, \"(F->F)\", 'T');\n\t}\n\tif (str[0] == 'T')\n\t\treturn true;\n\telse\n\t\treturn false;\n\n\n}\n\n\nint main() {\n\twhile (true) {\n\t\tstring str;\n\t\tcin >> str;\n\n\t\tif (str[0] == '#')\n\t\t\tbreak;\n\n\t\tbool correct = true;\n\t\tfor (int flag = 0; flag <= 0x7ff; ++flag) {\n\t\t\tint equal = str.find(\"=\");\n\t\t\tstring left = str.substr(0, equal);\n\t\t\tstring right = str.substr(equal + 1);\n\n\n\t\t\tfor (char c = 'a'; c <= 'k'; ++c) {\n\t\t\t\tint n = c - 'a';\n\t\t\t\treplace(left, c, 1 << n&flag ? 'T' : 'F');\n\t\t\t\treplace(right, c, 1 << n&flag ? 'T' : 'F');\n\t\t\t}\n\t\t\tif (calc(flag, left) != calc(flag, right)) {\n\t\t\t\tcorrect = false;\n\t\t\t\tbreak;\n\t\t\t}\n\t\t}\n\n\t\tif (correct)\n\t\t\tprintf(\"YES\\n\");\n\t\telse\n\t\t\tprintf(\"NO\\n\");\n\t}\n}"
  },
  {
    "language": "C++",
    "code": "#include <cstdio>\n#include <iostream>\n#include <vector>\n#include <functional>\n#include <numeric>\n#include <string>\n#include <iterator>\n#include <sstream>\n#include <map>\n#include <set>\n#include <utility>\n#include <algorithm>\n#include <cstring>\n\nusing namespace std;\n\n\nint formula(char **str){\n\tchar t = **str;\n\n\t(*str)++;\n\tif(t == 'T') return 1;\n\tif(t == 'F') return 0;\n\n\tif(t == '-') return (formula(str)!=0 ? 0 : 1);\n\tif(t == '(') {\n\t\tint a = formula(str);\n\n\t\tchar c = **str;\n\t\tswitch(c) {\n\t\tcase '*':\n\t\tcase '+':\n\t\t\tbreak;\n\t\tcase '-':\n\t\t\t(*str)++;\n\t\t\tif(**str != '>') return 0;\n\t\t\tbreak;\n\t\tdefault:\n//\t\t\tcout  << \"failf:\" << endl;\n\t\t\treturn 0;\n\t\t}\n\t\t(*str)++;\n\t\tint b = formula(str);\n\t\t(*str)+=1;\n\n\t\tswitch(c) {\n\t\tcase '*':\n\t\t\treturn a && b;\n\t\tcase '+':\n\t\t\treturn a || b;\n\t\tcase '-':\n\t\t\treturn (!a || b);\n\t\tdefault:\n\t\t//\tcout  << \"failf1\" << endl;\n\t\t\treturn 0;\n\t\t}\n\n\t}\n\t\n\t\t///\tcout  << \"failf2\" << endl;\n\treturn 0;\n}\nint equi(char *str) {\n\tint a = formula(&str);\n\tif(*str != '=') return 0;\n\tstr++;\n\tint b = formula(&str);\n//\tcout << \"ret:\" << (a==b) << endl;\n\treturn (a == b);\n}\n\nint solve(string str) {\n\t\tint N = 0;\n\t\tchar a[11] = {0};\n\n\t\tint e[11] = {0};\n\t\tfor(int i = 0; i < str.length(); i++) {\n\t\t\tif('a' <= str[i] && str[i] <= 'k') {\n\t\t\t\te[str[i] - 'a']++;\n\t\t\t\tif(e[str[i] - 'a'] == 1){\n\t\t\t\t\ta[N] = str[i];\n\t\t\t\t\tN++;\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\n\t\tint result = 1;\n\t\tfor(int i = 0; i < (1 << N); i++) {\n\t\t\tint t = i;\n\t\t\tstring s(str);\n\t\t\tfor(int n = 0; n < N; n++) {\n\t\t\t\tfor(int j = 0; j < s.length(); j++)\n\t\t\t\t\tif(s[j] == a[n])\n\t\t\t\t\t\ts[j] = ((t&1) ? 'T' : 'F');\n\t\t\t\tt >>= 1;\n\t\t\t}\n//\t\t\tcout << s << endl;\n\t\t\tif(!equi(const_cast<char*>(s.c_str()))) result = 0;\n\n\t\t}\n\t\treturn( result );\n}\n\nint main()\n{\n\tstring str;\n\n\twhile(1) {\n\t\tcin >> str;\n\t\tif(str == \"#\") break;\n\n\t\tint result = solve(str);\n\n\t\tcout << (result? \"YES\": \"NO\") << endl;\n\t}\n\treturn 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include <iostream>\n#include <string>\n#define S str[ima]\n#define A a,b,c,d,e,f,g,h,i,j,k\nusing namespace std;\nint ima;\nstring str;\nint cnt = 0;\n//2^11= 2048\n\nint formula(int a,int b,int c,int d,int e,int f,int g,int h,int i,int j,int k){\n  int val,val2;\n  \n  while(S=='T'||S=='F'||('a'<=S && S<='k')||S=='-'||S=='('){\n    if(('a' <= S && S<='k')||S=='T'||S=='F') {\n      if(S=='a') val=a;\n      else if(S=='b') val=b;\n      else if(S=='c') val=c;\n      else if(S=='d') val=d;\n      else if(S=='e') val=e;\n      else if(S=='f') val=f;\n      else if(S=='g') val=g;\n      else if(S=='h') val=h;\n      else if(S=='i') val=i;\n      else if(S=='j') val=j;\n      else if(S=='k') val=k;\n      else if(S=='T') val=1;\n      else if(S=='F') val=0;\n      ima++;\n    }\n    else if(S=='-'&&str[ima+1] != '>'){\n      ima++;\n      val = formula(A);\n      if(val==1) val = 0;\n      else if(val==0) val = 1;\n    }\n    else if(S=='('){\n      ima++;\n      val = formula(A);\n      if(S == '*'){\n\tima++;\n\tval2 = formula(A);\n\tif(val==0||val2==0) val = 0;\n\telse val = 1;\n      }\n      else if(S=='+'){\n\tima++;\n\tval2 = formula(A);\n\tif(val==0 && val2==0) val=0;\n\telse val = 1;\n      }\n      else if(S=='-'&&str[ima+1]=='>'){\n\tima+=2;\n\tval2 = formula(A);\n\tif(val==1 && val2 == 0) val = 0;\n\telse val = 1;\n      }\n      ima++;\n    }\n\n    return val;\n  }\n  \n}\n\nint main() {\n\n  while(1){\n    cin >> str;\n    if(str == \"#\") break;\n\n    int flg = 0;\n    ima = 0;\n    for(int i=0;i<2048;i++){\n      int j=10, n = i, a[11] = {};\n      while(n != 0) a[j] = n%2,n/=2,j--;\n      ima = 0;\n      int val = formula(a[0],a[1],a[2],a[3],a[4],a[5],a[6],a[7],a[8],a[9],a[10]);\n      ima++;\n      int val2 = formula(a[0],a[1],a[2],a[3],a[4],a[5],a[6],a[7],a[8],a[9],a[10]);\n      /*      if(val != val2){\n\tfor(int i=0;i<11;i++) cout << a[i];\n\tcout <<endl;\n\tcout <<val<<\" \" <<val2 << endl;\n\tcout <<str.size()<<\" \"<<ima<<endl;\n\t} */\n      if(val != val2) {\n\tflg = 1;\n\tbreak;\n      } \n    }\n    if(flg == 1) cout <<\"NO\"<<endl;\n    else cout <<\"YES\"<<endl;\n  }\n    \n  \n  return 0;\n}"
  },
  {
    "language": "C++",
    "code": "// clang-format off\n#include <bits/stdc++.h>\n#define int long long\n#define main signed main()\n// #define main int main()\n#define loop(i, a, n) for (int i = (a); i < (n); i++)\n#define rep(i, n) loop(i, 0, n)\n#define all(v) (v).begin(), (v).end()\n#define rall(v) (v).rbegin(), (v).rend()\n#define prec(n) fixed << setprecision(n)\n#define stlice(from, to) substr(from, (to) - (from) + 1)\n#define pb push_back\n#define mp make_pair\n#define mt make_tuple\n#define fi first\n#define se second\nusing namespace std;\ntypedef pair<int, int> pii;\ntypedef vector<int> vi;\ntypedef vector<double> vd;\ntypedef vector<char> vc;\ntypedef vector<bool> vb;\ntypedef vector<string> vs;\ntypedef vector<pii> vpii;\ntypedef vector<vi> vvi;\ntypedef vector<vb> vvb;\ntypedef vector<vpii> vvpii;\nconst int INF = sizeof(int) == sizeof(long long) ? 1000000000000000000LL : 1000000000;\nconst int MOD = 1000000007;\nconst double PI = acos(-1);\ntemplate<typename A, typename B> bool cmin(A &a, const B &b) { return a > b ? (a = b, true) : false; }\ntemplate<typename A, typename B> bool cmax(A &a, const B &b) { return a < b ? (a = b, true) : false; }\nbool odd(const int &n) { return n & 1; }\nbool even(const int &n) { return !odd(n); }\nvoid solve();\nmain { solve(); return 0; }\n// clang-format on\n\nvector<string> split(const string &s, char delim) {\n  vector<string> xs;\n  string item;\n  for (char ch : s) {\n    if (ch == delim) {\n      if (!item.empty()) {\n        xs.push_back(item);\n      }\n      item.clear();\n    } else {\n      item += ch;\n    }\n  }\n  if (!item.empty()) {\n    xs.push_back(item);\n  }\n  return xs;\n}\n\nbool getValue(const char &c, const int &t) {\n  return t >> (c - 'a') & 1;\n}\n\ntemplate<typename L, typename R>\nstruct either {\n  L left;\n  R right;\n  bool isLeft;\n  either(L l)\n    : left(l), isLeft(true) {\n  }\n  either(R r)\n    : right(r), isLeft(false) {\n  }\n};\n\ntypedef either<string, bool> TOKEN;\ntypedef stack<TOKEN> RPN;\n\nRPN parse(const string &s, const int &t) {\n  stack<TOKEN> buf;\n  stack<string> ops;\n  int n = s.size();\n  rep(i, n) {\n    if (s[i] == '-' && s[i + 1] != '>') ops.push(\"-\");\n    if (s[i] == '-' && s[i + 1] == '>') ops.push(\"->\"), i++;\n    if (s[i] == '+') {\n      while (ops.size() && ops.top() != \"(\") {\n        buf.push(TOKEN(ops.top()));\n        ops.pop();\n      }\n      ops.push(\"+\");\n    }\n    if (s[i] == '*') {\n      while (ops.size() && ops.top() != \"(\") {\n        buf.push(TOKEN(ops.top()));\n        ops.pop();\n      }\n      ops.push(\"*\");\n    }\n    if (s[i] == 'T') buf.push(TOKEN(true));\n    if (s[i] == 'F') buf.push(TOKEN(false));\n    if (s[i] == '(') ops.push(\"(\");\n    if (s[i] == ')') {\n      while (ops.size()) {\n        if (ops.top() == \"(\") {\n          ops.pop();\n          break;\n        }\n        buf.push(TOKEN(ops.top())), ops.pop();\n      }\n    }\n    if ('a' <= s[i] && s[i] <= 'k') buf.push(TOKEN(getValue(s[i], t)));\n  }\n  while (ops.size()) buf.push(TOKEN(ops.top())), ops.pop();\n  RPN rpn;\n  while (buf.size()) rpn.push(buf.top()), buf.pop();\n  return rpn;\n}\n\nbool eval(RPN rpn) {\n  stack<bool> s;\n  while (rpn.size()) {\n    TOKEN t = rpn.top();\n    if (t.isLeft) {\n      string op = t.left;\n      if (op == \"-\") {\n        bool a = s.top();\n        s.pop();\n        s.push(!a);\n      }\n      if (op == \"+\") {\n        bool a = s.top();\n        s.pop();\n        bool b = s.top();\n        s.pop();\n        s.push(a || b);\n      }\n      if (op == \"*\") {\n        bool a = s.top();\n        s.pop();\n        bool b = s.top();\n        s.pop();\n        s.push(a && b);\n      }\n      if (op == \"->\") {\n        bool a = s.top();\n        s.pop();\n        bool b = s.top();\n        s.pop();\n        s.push(!b || a);\n      }\n    } else {\n      s.push(t.right);\n    }\n    // cout << setw(4) << (t.isLeft ? t.left : (t.right ? \"1\" : \"0\"));\n    rpn.pop();\n  }\n  // cout << endl;\n  // return 1;\n  return s.top();\n}\n\nvoid solve() {\n  string s;\n  while (cin >> s, s != \"#\") {\n    vs _     = split(s, '=');\n    string l = _[0], r = _[1];\n    bool b = true;\n    rep(i, 1 << 11) b &= eval(parse(l, i)) == eval(parse(r, i));\n    // rep(i, 1 << 11) {\n    //   if (i == 1) {\n    //     cout << eval(parse(l, i)) << ' ' << eval(parse(r, i)) << endl;\n    //   }\n    //   bool x = eval(parse(l, i)) == eval(parse(r, i));\n    //   // if (!x && i < 100) {\n    //   //   cout << i << endl;\n    //   // }\n    //   b &= x;\n    // }\n    // b &= eval(parse(l, 1)) == eval(parse(r, 1));\n    cout << (b ? \"YES\" : \"NO\") << endl;\n  }\n}"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\nusing namespace std;\n\nint c = 0;\nbool solve(const string& s, int i){\n  c++;\n  switch (s[c-1]){\n    case 'T': return true;\n    case 'F': return false;\n    case '-': return !solve(s,i);\n    case '(':\n      bool l = solve(s,i);\n      c++;\n      switch (s[c-1]){\n        case '*': return l&solve(s,i);\n        case '+': return l|solve(s,i);\n        case '-': c++; return (!l)|solve(s,i);\n      }\n  }\n  return (i & (1 << (s[c-1] - 'a' - 1))) != 0;\n}\nint main(){\n  string s;\n  while(cin >> s, s != \"#\"){\n    int i;\n    for(i = 0; i <= 0x7ff; i++){\n      int eq = s.find(\"=\");\n      c = 0;\n      bool r = solve(s.substr(0,eq), i);\n      c = 0;\n      bool l = solve(s.substr(eq+1), i);\n      if(r != l) break;\n    }\n    if(i>0x7ff) cout << \"YES\" << endl;\n    else cout << \"NO\" << endl;\n  }\n}"
  },
  {
    "language": "C++",
    "code": "#include <vector>\n#include <list>\n#include <map>\n#include <set>\n#include <stack>\n#include <queue>\n#include <deque>\n#include <algorithm>\n#include <utility>\n#include <functional>\n#include <sstream>\n#include <iostream>\n#include <cstdio>\n#include <cmath>\n#include <cstdlib>\n#include <cctype>\n#include <string>\n#include <cstring>\n#include <ctime>\n#include <climits>\n#include <cassert>\nusing namespace std;\ninline int toInt(string s) {int v; istringstream sin(s);sin>>v;return v;}\ntemplate<class T> inline string toString(T x) {ostringstream sout;sout<<x;return sout.str();}\ntypedef vector<int> vi;\ntypedef vector<vi> vvi;\ntypedef vector<string> vs;\ntypedef pair<int, int> pii;\ntypedef long long ll;\n#define ALL(a) (a).begin(),(a).end()\n#define RALL(a) (a).rbegin(),(a).rend()\n#define EXIST(s,e) ((s).find(e)!=(s).end())\n#define FOR(i,a,b) for(int i=(a);i<(b);++i)\n#define REP(i,n) FOR(i,0,n)\nconst double EPS = 1e-10;\nconst double PI  = acos(-1.0);\n\n\n//<formula>  ::= \"T\" | \"F\" |\n//\"a\" | \"b\" | \"c\" | \"d\" | \"e\" | \"f\" |\n//\"g\" | \"h\" | \"i\" | \"j\" | \"k\" |\n//\"-\" <formula> |\n//\"(\" <formula> \"*\" <formula> \")\" |\n//\"(\" <formula> \"+\" <formula> \")\" |\n//\"(\" <formula> \"->\" <formula> \")\"\nbool formula(string &s,int &pos,vi vars){\n\tswitch(s[pos]){\n\t\tcase 'T':\n\t\t\tpos++;\n\t\t\treturn true;\n\t\tcase 'F':\n\t\t\tpos++;\n\t\t\treturn false;\n\t\tcase 'a':case 'b':case 'c':case 'd':case 'e':case 'f':case 'g':case 'h':case 'i':case 'j':case 'k':\n\t\t\treturn vars[s[pos++]-'a'];\n\t\tcase '-':\n\t\t\tpos++;\n\t\t\treturn ~formula(s,pos,vars);\n\t\tcase '(':\n\t\t\t{\n\t\t\t\tpos++;\n\t\t\t\tbool l=formula(s,pos,vars);\n\t\t\t\tchar op=s[pos];\n\t\t\t\tpos++;\n\t\t\t\tif(op=='-'){\n\t\t\t\t\tassert(s[pos]=='>');\n\t\t\t\t\tpos++;\n\t\t\t\t}\n\t\t\t\tbool r=formula(s,pos,vars);\n\t\t\t\tassert(s[pos]==')');\n\t\t\t\tpos++;\n\t\t\t\tswitch(op){\n\t\t\t\t\tcase '*':\n\t\t\t\t\t\treturn l&r;\n\t\t\t\t\tcase '+':\n\t\t\t\t\t\treturn l|r;\n\t\t\t\t\tcase '-':\n\t\t\t\t\t\treturn r|(~l);\n\t\t\t\t\tdefault:\n\t\t\t\t\t\tassert(0);break;\n\t\t\t\t}\n\t\t\t}\n\t\tdefault:\n\t\t\tassert(0);break;\n\t}\n}\n\n//<equation> ::= <formula> \"=\" <formula>\nbool equation(string &s,int &pos,vi vars){\n\tbool l=formula(s,pos,vars);\n\tassert(s[pos]=='=');\n\tpos++;\n\tbool r=formula(s,pos,vars);\n\tassert(s[pos]=='\\0');\n\treturn l==r;\n}\nint main(){\n\tstring s;\n\twhile(cin>>s,s!=\"#\"){\n\t\tbool flag=true;\n\t\tREP(i,1<<11){\n\t\t\tvi vars(11);\n\t\t\tREP(j,11){\n\t\t\t\tvars[j]=((1<<j)&i);\n\t\t\t}\n\t\t\tint pos=0;\n\t\t\tif(!equation(s,pos,vars)){\n\t\t\t\tflag=false;\n\t\t\t\tbreak;\n\t\t\t}\n\t\t}\n\t\tcout<<(flag?\"YES\":\"NO\")<<endl;\n\t}\n}"
  },
  {
    "language": "C++",
    "code": "#include <iostream>\n#include <vector>\n#include <string>\n#include <algorithm>\nusing namespace std;\n\nint c;\nbool a[11];\n\nbool f(const string& s) {\n\tif (s[c] == '(') {\n\t\tc++;\n\t\tbool v = f(s);\n\t\tif (s[c] == '+') {\n\t\t\tc++;\n\t\t\tv |= f(s);\n\t\t}\n\t\telse if (s[c] == '*') {\n\t\t\tc++;\n\t\t\tv &= f(s);\n\t\t}\n\t\telse {\n\t\t\tc += 2;\n\t\t\tv = !(v & !f(s));\n\t\t}\n\t\tc++; // s[c] == ')'\n\t\treturn v;\n\t}\n\n\tif (s[c] == 'T') {\n\t\tc++;\n\t\treturn true;\n\t}\n\tif (s[c] == 'F') {\n\t\tc++;\n\t\treturn false;\n\t}\n\tif (s[c] == '-') {\n\t\tc++;\n\t\treturn !f(s);\n\t}\n\tif ('a' <= s[c] && s[c] <= 'k') {\n\t\tbool v = a[s[c] - 'a'];\n\t\tc++;\n\t\treturn v;\n\t}\n\tcout << \"error\" << s << \"at \" << c << endl;\n\texit(1);\n}\n\nbool solve(string s1, string s2) {\n\tfor (int i = 0; i < (1 << 11); i++) {\n\t\tfor (int j = 0; j < 11; j++) {\n\t\t\ta[i] = (i & (1 << j)) > 0;\n\t\t}\n\t\t//cout << i << \" \" << s1 + \" \" << s2 << endl;\n\t\tc = 0;\n\t\tbool res1 = f(s1);\n\t\tc = 0;\n\t\tbool res2 = f(s2);\n\n\t\tif (res1 == res2) return true;\n\t}\n\n\treturn false;\n}\n\nint main() {\n\tcin.tie(0);\n\tios::sync_with_stdio(false);\n\tstring s, s1, s2;\n\twhile (cin >> s , s != \"#\") {\n\t\tint idx = s.find('=');\n\t\ts1 = s.substr(0, idx) , s2 = s.substr(idx + 1, s.size() - (idx + 1));\n\t\tcout << (solve(s1, s2) ? \"YES\" : \"NO\") << endl;\n\t}\n}"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\nusing namespace std;\n#define rep(i,n) for (int (i)=(0);(i)<(int)(n);++(i))\nusing ll = long long;\nusing P = pair<int, int>;\nusing namespace std;\n\n/*\n<四則演算の式> ::= <乗算除算の式> (+ or -) <乗算除算の式> (+ or -) ...\n<乗算除算の式> ::= <括弧か数> (* or /) <括弧か数> (* or /) ...\n<括弧か数>     ::= '(' <四則演算の式> ')' or <数>\n<数>           ::= ...\n*/\n\n// 構文解析\nusing State = string::const_iterator;\nclass ParseError{};\n\nint number(State &begin);\nint term(State &begin);\nint factor(State &begin);\nint expression(State &begin);\n\nstring alp = \"abcdefghijk\";\nint bit;\nstring curstr;\n\n// 数字の列をパースして，その数を返す\nint number(State &begin) {\n    int ret = 0;\n\n    if (*begin == 'T') {\n        ret = 1;\n        ++begin;\n    }\n    else if (*begin == 'F') {\n        ret = 0;\n        ++begin;\n    }\n    else {\n        rep(i, alp.size()) {\n            if (*begin == alp[i]) {\n\n                if ((bit >> i) & 1) {\n                    ret = 1;\n                }\n                else {\n                    ret = 0;\n                }\n\n                ++begin;\n                break;\n            }\n        }\n    }\n\n    return ret;\n}\n\n// 乗算除算の式をパースして，その評価結果を返す\nint term(State &begin) {\n    if (*begin == '-') {\n        begin++;\n        return abs(1 - term(begin));\n    }\n    else {\n        return factor(begin);\n    }\n}\n\nint factor(State &begin) {\n    if (*begin == '(') {\n        begin++; // '('を飛ばす\n        int ret = expression(begin);\n        begin++;\n        return ret;\n    }\n    else {\n        return number(begin);\n    }\n}\n\n\n// 四則演算の式をパースして，その評価結果を返す\nint expression(State &begin) {\n    int ret = term(begin);\n\n    for (;;) {\n        if (*begin == '/') {\n            begin++;\n            int y = term(begin);\n            if (ret and !y) ret = 0;\n            else ret = 1;\n        }\n        else if (*begin == '+') {\n            begin++;\n            ret |= term(begin);\n        }\n        else if (*begin == '*') {\n            begin++;\n            ret &= term(begin);\n        }\n        else {\n            break;\n        }\n    }\n\n    return ret;\n}\n\nint main() {\n    string s;\n    while (getline(cin, s) and s != \"#\") {\n\n        string a = \"\", b = \"\";\n        bool flag = false;\n\n        rep(i, s.size()) {\n            if (s[i] == '=') {\n                flag = true;\n                continue;\n            }\n\n            if (!flag) {\n                if (i+1<s.size() and s[i] == '-' and s[i+1] == '>') {\n                    a += '/';\n                    ++i;\n                }\n                else {\n                    a += s[i];\n                }\n            }\n            else {\n                if (i+1<s.size() and s[i] == '-' and s[i+1] == '>') {\n                    b += '/';\n                    ++i;\n                }\n                else {\n                    b += s[i];\n                }\n            }\n        }\n\n        bool ok = true;\n        for (bit=0; bit<(1<<alp.size()); ++bit) {\n            State A = a.begin();\n            State B = b.begin();\n\n            curstr = a;\n            int tmpa = expression(A);\n\n            curstr = b;\n            int tmpb = expression(B);\n\n            bitset<10> bbb(bit);\n            //cerr << tmpa << \" \" << tmpb << \": \" << bbb << endl;\n\n            if (tmpa != tmpb) {\n                ok = false;\n                break;\n            }\n        }\n\n        cout << (ok ? \"YES\" : \"NO\") << endl;\n    }\n\n    return 0;\n}\n\n"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\n\nusing namespace std;\n\nstring str;\nint var;\nint pos;\n\nbool formula() {\n  pos++;\n  if(str[pos]=='T') return true;\n  if(str[pos]=='F') return false;\n  if(isalpha(str[pos])) return bool(var>>(str[pos]-'a') & 1);\n  if(str[pos]=='-') return !formula();\n  if(str[pos]=='(') {\n    int f1=formula();\n    pos++;\n    char op = str[pos];\n    if(op=='-')pos++;\n    int f2=formula();\n    pos++;\n    if(op=='*') return f1&&f2;\n    if(op=='+') return f1||f2;\n    if(op=='-') return f1<=f2;\n  }\n}\n\n\nint main() {\n  \n  while(cin >> str) {\n    if(str == \"#\") break;\n    bool ok = true;\n    for(var=0; var<(1<<11);var++) {\n      pos = -1; int f=formula();\n      pos++;\n      if(f != formula()) { ok = false; break; }\n    }\n    if(ok) cout << \"YES\" << endl;\n    else cout << \"NO\" << endl;\n  }\n  \n  return 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include \"bits/stdc++.h\"\nusing namespace std;\ntypedef long long ll;\ntypedef pair<int,int> pii;\n#define rep(i,n) for(ll i=0;i<(ll)(n);i++)\n#define all(a)  (a).begin(),(a).end()\n#define pb push_back\n#define INF (1e9+1)\n//#define INF (1LL<<59)\n\ntypedef string::const_iterator State;\n\n\nstring getop(State &begin){\n\tif(*begin=='*'){\n\t\tbegin++;\n\t\treturn \"*\";\n\t}\n\telse if(*begin=='+'){\n\t\tbegin++;\n\t\treturn \"+\";\n\t}else{\n\t\tbegin++;\n\t\tbegin++;\n\t\treturn \"->\";\n\t}\n}\n\n\nbool mul(bool a,bool b){\n\tif(a&&b)return true;\n\telse return false;\n}\n\n\nbool add(bool a,bool b){\n\tif(!a&&!b)return false;\n\telse return true;\n}\n\n\nbool imp(bool a,bool b){\n\tif(a&&!b)return false;\n\telse return true;\n}\n\n\nbool exp(State &begin){\n\tif(isdigit(*begin)){\n\t\tbool num = *begin-'0';\n\t\tbegin++;\n\t\treturn num;\n\t}\n\telse if(*begin=='-'){\n\t\tbegin++;\n\t\treturn !exp(begin);\n\t}else if(*begin=='('){\n\t\tbegin++;\n\t\tbool ll = exp(begin);\n\t\tstring op = getop(begin);\n\t\tbool rr = exp(begin);\n\t\tbegin++;\n\t\t\n\t\tif(op==\"*\")return mul(ll,rr);\n\t\telse if(op==\"+\")return add(ll,rr);\n\t\telse return imp(ll,rr);\n\t}\n\t\n\tassert(1);\n\treturn 0;\n}\n\n\nbool check(string s){\n\tstring left=\"\",right=\"\";\n\tbool f=false;\n\trep(i,s.size()){\n\t\tif(s[i]=='=')f=true;\n\t\telse if(f)right+=s[i];\n\t\telse left+=s[i];\n\t}\n\t\n\tState bl = left.begin(),br = right.begin();\n\tbool l = exp(bl);\n\tbool r = exp(br);\n\t\n\tif(l==r)return true;\n\telse return false;\n}\n\n\nint main(){\n\tstring s;\n\twhile(cin>>s&&s!=\"#\"){\n\t\tset<char> var;\n\t\trep(i,s.size()){\n\t\t\tif(s[i]=='T')s[i]='1';\n\t\t\tif(s[i]=='F')s[i]='0';\n\t\t}\n\t\trep(i,s.size()){\n\t\t\tif(isalpha(s[i])){\n\t\t\t\tvar.insert(s[i]);\n\t\t\t}\n\t\t}\n\t\t\n\t\t\n\t\tbool f = false;\n\t\tint en = 1<<var.size();\n\t\trep(i,en){\n\t\t\tmap<char,int> mp;\n\t\t\tint num = i;\n\t\t\tfor(auto &e:var){\n\t\t\t\tmp[e] = num%2;\n\t\t\t\tnum/=2;\n\t\t\t}\n\t\t\tstring t = s;\n\t\t\trep(j,t.size()){\n\t\t\t\tif( isalpha(t[j]) ){\n\t\t\t\t\tt[j] = '0'+mp[t[j]];\n\t\t\t\t}\n\t\t\t}\n\t\t\tif(check(t)==false)f=true;\n\t\t}\n\t\tif(f)cout<<\"NO\"<<endl;\n\t\telse cout<<\"YES\"<<endl;\n\t}\n}"
  },
  {
    "language": "C++",
    "code": "/*\n *\n * <equation> ::= <formula> \"=\" <formula>\n * <formula>  ::= \"T\" | \"F\" |\n * \"a\" | \"b\" | \"c\" | \"d\" | \"e\" | \"f\" |\n * \"g\" | \"h\" | \"i\" | \"j\" | \"k\" |\n * \"-\" <formula> |\n * \"(\" <formula> \"*\" <formula> \")\" |\n * \"(\" <formula> \"+\" <formula> \")\" |\n * \"(\" <formula> \"->\" <formula> \")\"\n */\n#include<iostream>\n#include<map>\n#include<vector>\n#include<algorithm>\n#include<cmath>\n#include<iomanip>\n#include<numeric>\n#include<climits>\n#include<ctime>\n#include<cstring>\n#include<sstream>\n#define REP(i,p,n) for(int i=p;i<(int)(n);i++)\n#define rep(i,n) REP(i,0,n)\n#define rep_split(tok,a_str,re) for(char *tok = strtok((char *)a_str.c_str(),re); tok != NULL; tok = strtok(NULL,re))\n#define ALL(c) (c).begin(), (c).end()\n#define dump(a) cerr << #a << \"=\" << (a) << endl\n#define DUMP(list) cout << \"{ \"; for(auto nth : list){ cout << nth << \" \"; } cout << \"}\" << endl;\ntemplate<class T> void chmin(T &t, T f) { if (t > f) t = f; } //t=min\ntemplate<class T> void chmax(T &t, T f) { if (t < f) t = f; } //t=max\nusing namespace std;\n\n\nvector<bool> var_pattern;\nbool equation(string& s, int& i);\nbool formula(string& s, int& i);\n\n\nbool equation(string& s, int& i)\n{\n\tbool left = formula(s,i);\n\ti++; // =\n\tbool right = formula(s,i);\n\n\t//cout << left << \"=\" << right << endl;\n\n\treturn left == right;\n}\n\n\nbool formula(string& s, int& i)\n{\n\tbool left=false,right=false;\t\n\tchar ope=0;\n\tbool ans = false;\n\n\tswitch(s[i])\n\t{\n\t\tcase 'T':\n\t\t\tans = true;\n\t\t\tbreak;\n\t\tcase 'F':\n\t\t\tans = false;\n\t\t\tbreak;\n\t\tcase '-':\n\t\t\ti++;\n\t\t\treturn !formula(s,i);\n\t\tcase '(':\n\t\t\ti++;\n\t\t\tleft = formula(s,i);\n\t\t\ti++; \n\t\t\tope = s[i];\n\t\t\tif (ope == '-') { i++; ope='>'; } //->\n\t\t\ti++;\n\t\t\tright = formula(s,i);\n\n\t\t\tif (ope == '*') {\n\t\t\t\tans = left * right;\t\n\t\t\t}\n\t\t\telse if (ope == '+') {\n\t\t\t\tans = left + right;\t\n\t\t\t}\n\t\t\telse if (ope == '>') {\n\t\t\t\tans = (!left) + right;\n\t\t\t}\n\t\t\ti++; //')'\n\t\t\ti++; //=\n\t\t\tbreak;\n\n\t\tdefault:\n\t\t\tif ('a' <= s[i] && s[i] <= 'k') {\n\t\t\t\tint var_num = (int)(s[i] - 'a');\n\t\t\t\tans = var_pattern[var_num];\n\t\t\t}\n\t\t\t//cout << \"index=\" << var_num << \" var=\" << s[i] << endl;\n\t\t\t//cout << s[i] << \" = \" << var_pattern[var_num] << endl;\n\t\t\tbreak;\n\t}\n\n\treturn ans;\n}\n\n\n\nint main() {\n\tstring line;\n\t\n\twhile(cin >> line)\n\t{\n\t\tif (line[0] == '#') break;\n\n\t\tbool is_yes = true;\n\t\trep(j,2048) {\n\t\t\tint i=0;\n\t\t\tint num = j;\n\t\t\trep(k,11)\n\t\t\t{\n\t\t\t\tvar_pattern.push_back((num & 1));\n\t\t\t\t//cout << (num & 1) << \" \";\n\t\t\t\tnum >>= 1;\n\t\t\t}\n\t\t\t//cout << endl;\n\t\t\tif (!equation(line,i)) { is_yes = false; break; }\n\t\t\tvar_pattern.clear();\n\t\t}\n\t\tcout << (is_yes ? \"YES\" : \"NO\") << endl;\n\t\t//cout << \"-----------\" << endl;\n\t}\n\n\treturn 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include<iostream>\n#include<vector>\n#include<string>\n#include<algorithm>\nusing namespace std;\n\n#define MAX_NUM 2\n#define MAX_CH 10\n#define MAX_N 1200\n\nstring S, T;\nchar NUM[MAX_NUM + 1] = \"01\";\nchar CH[MAX_CH + 1] = \"abcdefghij\";\nint TR[MAX_CH];\nint CNT[MAX_N];\n\nint Plus(int c1, int c2) {\n\treturn max(c1, c2);\n}\n\nint kake(int c1, int c2) {\n\treturn min(c1, c2);\n}\n\nint fukumi(int c1, int c2) {\n\tif (c1 == 1 && c2 == 0) {\n\t\treturn 0;\n\t}\n\treturn 1;\n}\n\nint STOI(char V) {\n\tif (V == '0') {\n\t\treturn 0;\n\t}\n\telse {\n\t\treturn 1;\n\t}\n}\n\nint calc2(string A2) {\n\n\tA2 = A2.substr(1, A2.size() - 1);\n\n\tif (A2.size() == 3)\n\t{\n\t\tint p1, p2;\n\t\tp1 = STOI(A2[0]);\n\t\tp2 = STOI(A2[2]);\n\t\tif (A2[1] == '+')\n\t\t{\n\t\t\treturn Plus(p1, p2);\n\t\t}\n\t\tif (A2[1] == '*')\n\t\t{\n\t\t\treturn kake(p1, p2);\n\t\t}\n\t\tif (A2[1] == '&')\n\t\t{\n\t\t\treturn fukumi(p1, p2);\n\t\t}\n\t}\n\n\telse if (A2.size() == 4)\n\t{\n\t\tif (A2[0] == '-')\n\t\t{\n\t\t\tint p1, p2;\n\t\t\tp1 = STOI(A2[1]);\n\t\t\tp2 = STOI(A2[3]);\n\t\t\tif (A2[1] == '+')\n\t\t\t{\n\t\t\t\treturn Plus(1 - p1, p2);\n\t\t\t}\n\t\t\tif (A2[1] == '*')\n\t\t\t{\n\t\t\t\treturn kake(1 - p1, p2);\n\t\t\t}\n\t\t\tif (A2[1] == '&')\n\t\t\t{\n\t\t\t\treturn fukumi(1 - p1, p2);\n\t\t\t}\n\t\t}\n\n\t\tif (A2[2] == '-')\n\t\t{\n\t\t\tint p1, p2;\n\t\t\tp1 = STOI(A2[0]);\n\t\t\tp2 = STOI(A2[3]);\n\t\t\tif (A2[1] == '+')\n\t\t\t{\n\t\t\t\treturn Plus(p1, 1 - p2);\n\t\t\t}\n\t\t\tif (A2[1] == '*')\n\t\t\t{\n\t\t\t\treturn kake(p1, 1 - p2);\n\t\t\t}\n\t\t\tif (A2[1] == '&')\n\t\t\t{\n\t\t\t\treturn fukumi(p1, 1 - p2);\n\t\t\t}\n\t\t}\n\t}\n\n\telse\n\t{\n\t\tint p1, p2;\n\t\tp1 = STOI(A2[1]);\n\t\tp2 = STOI(A2[4]);\n\t\tif (A2[1] == '+')\n\t\t{\n\t\t\treturn Plus(1 - p1, 1 - p2);\n\t\t}\n\t\tif (A2[1] == '*')\n\t\t{\n\t\t\treturn kake(1 - p1, 1 - p2);\n\t\t}\n\t\tif (A2[1] == '&')\n\t\t{\n\t\t\treturn fukumi(1 - p1, 1 - p2);\n\t\t}\n\t}\n}\n\nstring TOSTR(int d) {\n\tif (d == 0) {\n\t\treturn \"0\";\n\t}\n\telse {\n\t\treturn \"1\";\n\t}\n}\n\nint calc(string Y) {\n\tfor (int i = 0; i < MAX_N; i++) {\n\t\tCNT[i] = 0;\n\t}\n\tstring Z = Y, AA = \"\";\n\n\twhile (Z.size() >= 2)\n\t{\n\t\tint L = 0, MN = 0;\n\t\tbool ok1 = false;\n\t\tZ = \"\"; AA = \"\";\n\t\tint pass2 = 0;\n\t\tint pass3 = -1;\n\t\twhile (pass2 < Y.size()) {\n\t\t\tif (Y[pass2] == '(') {\n\t\t\t\tL++;\n\t\t\t}\n\t\t\tif (Y[pass2] == ')') {\n\t\t\t\tL++;\n\t\t\t}\n\t\t\tCNT[pass2] = L;\n\t\t\tpass2++;\n\t\t\tMN = max(MN, L);\n\t\t}\n\t\tfor (int i = 0; i < Y.size(); i++) {\n\t\t\tif (CNT[i] == MN) {\n\t\t\t\tif (pass3 == -1) {\n\t\t\t\t\tpass3 = i;\n\t\t\t\t}\n\t\t\t\tAA += Y[i];\n\t\t\t\tif (i < Y.size() - 1) {\n\t\t\t\t\tif (Y[i + 1] == ')') {\n\t\t\t\t\t\tok1 = false;\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t}\n\t\t\telse {\n\t\t\t\tZ += Y[i];\n\t\t\t}\n\t\t}\n\t\tint ZSIZE = Z.size();\n\t\tZ = Z.substr(0, pass3) + TOSTR(calc2(AA)) + Z.substr(pass3, ZSIZE - pass3);\n\t\tY = Z;\n\t}\n\tif (Y == \"0\") {\n\t\treturn 0;\n\t}\n\telse {\n\t\treturn 1;\n\t}\n}\n\nint power(int a, int b) {\n\tint res2 = 1;\n\tfor (int i = 0; i < b; i++) {\n\t\tres2 *= a;\n\t}\n\treturn res2;\n}\n\nbool solve(string U) {\n\tbool RES = true;\n\tstring V = \"\";\n\tstring V1 = \"\", V2 = \"\";\n\tstring W1 = \"\", W2 = \"\";\n\n\tfor (int i = 0; i < U.size(); i++) {\n\t\tif (U[i] == 'T') {\n\t\t\tV += '1';\n\t\t\tgoto E;\n\t\t}\n\t\telse if (U[i] == '>') {\n\t\t\t//nanimo shinai.\n\t\t\tgoto E;\n\t\t}\n\t\telse if (U[i] == 'F') {\n\t\t\tV += '0';\n\t\t\tgoto E;\n\t\t}\n\t\telse if (i < U.size() - 1) {\n\t\t\tif (U.substr(i, 2) == \"->\") {\n\t\t\t\tV += '&';\n\t\t\t\tgoto E;\n\t\t\t}\n\t\t}\n\t\tV += U[i];\n\tE:;\n\t}\n\n\tint cnt1 = 0;\n\tfor (int i = 0; i < V.size(); i++) {\n\t\tif (V[i] == '=') {\n\t\t\tcnt1 = 1;\n\t\t}\n\t\telse if (cnt1 == 0) {\n\t\t\tV1 += V[i];\n\t\t}\n\t\telse if (cnt1 == 1) {\n\t\t\tV2 += V[i];\n\t\t}\n\t}\n\n\tint pass1 = 0;\n\twhile (pass1 < V1.size()) {\n\t\tif (V1[pass1] == '-') {\n\t\t\tint cnt2 = 0;\n\t\t\twhile (V1[pass1] == '-') {\n\t\t\t\tcnt2++;\n\t\t\t\tpass1++;\n\t\t\t}\n\t\t\tif (cnt2 % 2 == 1) {\n\t\t\t\tW1 += '(';\n\t\t\t\tW1 += '-';\n\t\t\t\tW1 += V1[pass1];\n\t\t\t\tW1 += ')';\n\t\t\t}\n\t\t\telse {\n\t\t\t\tW1 += V1[pass1];\n\t\t\t}\n\t\t\tpass1++;\n\t\t}\n\t\tif (pass1 < V1.size()) {\n\t\t\tW1 += V1[pass1];\n\t\t\tpass1++;\n\t\t}\n\t}\n\n\tpass1 = 0;\n\twhile (pass1 < V2.size()) {\n\t\tif (V2[pass1] == '-') {\n\t\t\tint cnt2 = 0;\n\t\t\twhile (V2[pass1] == '-') {\n\t\t\t\tcnt2++;\n\t\t\t\tpass1++;\n\t\t\t}\n\t\t\tif (cnt2 % 2 == 1) {\n\t\t\t\tW2 += '(';\n\t\t\t\tW2 += '-';\n\t\t\t\tW2 += V2[pass1];\n\t\t\t\tW2 += ')';\n\t\t\t}\n\t\t\telse {\n\t\t\t\tW2 += V2[pass1];\n\t\t\t}\n\t\t\tpass1++;\n\t\t}\n\t\tif (pass1 < V2.size()) {\n\t\t\tW2 += V2[pass1];\n\t\t\tpass1++;\n\t\t}\n\t}\n\n\tstring X1 = \"\", X2 = \"\";\n\n\tfor (int i = 0; i < power(2, MAX_CH); i++) {\n\t\tX1 = \"\"; X2 = \"\";\n\t\tfor (int j = 0; j < MAX_CH; j++) {\n\t\t\tint a1 = (i / power(2, j)) % 2;\n\t\t\tTR[j] = a1;\n\t\t}\n\n\t\tfor (int j = 0; j < W1.size(); j++) {\n\t\t\tfor (int k = 0; k < MAX_CH; k++) {\n\t\t\t\tif (W1[j] == CH[k]) {\n\t\t\t\t\tX1 += NUM[TR[k]];\n\t\t\t\t\tgoto F;\n\t\t\t\t}\n\t\t\t}\n\t\t\tX1 += W1[j];\n\t\tF:;\n\t\t}\n\n\t\tfor (int j = 0; j < W2.size(); j++) {\n\t\t\tfor (int k = 0; k < MAX_CH; k++) {\n\t\t\t\tif (W2[j] == CH[k]) {\n\t\t\t\t\tX2 += NUM[TR[k]];\n\t\t\t\t\tgoto G;\n\t\t\t\t}\n\t\t\t}\n\t\t\tX2 += W2[j];\n\t\tG:;\n\t\t}\n\n\t\tint res_1 = calc(X1);\n\t\tint res_2 = calc(X2);\n\t\tif (res_1 != res_2) {\n\t\t\tRES = false;\n\t\t}\n\t}\n\treturn RES;\n}\n\nint main() {\n\twhile (true) {\n\t\tcin >> S;\n\t\tif (S == \"#\") {\n\t\t\tbreak;\n\t\t}\n\t\tbool res = solve(S);\n\t\tif (res == true) {\n\t\t\tcout << \"YES\" << endl;\n\t\t}\n\t\telse {\n\t\t\tcout << \"NO\" << endl;\n\t\t}\n\t}\n\treturn 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include <iostream>\n#include <vector>\n#include <string>\n#define rep(i, n) for(int i = 0; i < n; i++)\nbool Calc(std::string expr);\nvoid DeleteReverse(std::string& expr);\n\nint main()\n{\n\tstd::vector<std::string> results;\n\twhile (1) {\n\t\tstd::string expr;\n\t\tstd::cin >> expr;\n\t\tif (expr == \"#\") break;\n\t\t//?????????????????£?¶??????????????????????\n\t\twhile (1) {\n\t\t\tbool isDelete = false;\n\t\t\trep(i, expr.size() - 1) {\n\t\t\t\tif (expr[i] == '-' && expr[i + 1] == '-') {\n\t\t\t\t\texpr.erase(i, 2);\n\t\t\t\t\tisDelete = true;\n\t\t\t\t\tbreak;\n\t\t\t\t}\n\t\t\t}\n\t\t\tif (!isDelete) break;\n\t\t}\n\t\t//->??? >?????????\n\t\trep(i, expr.size() - 1) {\n\t\t\tif (expr[i] == '-' && expr[i + 1] == '>') {\n\t\t\t\texpr.erase(i, 1);\n\t\t\t}\n\t\t}\n\t\tint tfFlugs = -1;\n\t\tbool isCorrect = true;\n\t\twhile (tfFlugs++) {\n\t\t\tstd::string replaced = expr;\n\t\t\tbool includeFalse = false;\n\t\t\t//????????????\n\t\t\trep(i, 11) {//0a 1b 2c...\n\t\t\t\tif (tfFlugs & 1 << i) {\n\t\t\t\t\tfor (auto& x : replaced) {\n\t\t\t\t\t\tif (x == 'a' + i) {\n\t\t\t\t\t\t\tx = 'T';\n\t\t\t\t\t\t}\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t\telse {\n\t\t\t\t\tincludeFalse = true;\n\t\t\t\t\tfor (auto& x : replaced) {\n\t\t\t\t\t\tif (x == 'a' + i) {\n\t\t\t\t\t\t\tx = 'F';\n\t\t\t\t\t\t}\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t}\n\t\t\t//?????????????????????\n\t\t\tDeleteReverse(replaced);\n\t\t\tisCorrect = Calc(replaced);\n\t\t\tif (!isCorrect) break;\n\t\t}\n\t\tresults.push_back(isCorrect ? \"YES\" : \"NO\");\n\t}\n\n\tfor (auto& x : results) {\n\t\tstd::cout << x << std::endl;\n\t}\n\treturn 0;\n}\n\nbool Calc(std::string expr)\n{\n\t//????????¨???????????????\n\tstd::string e[2];\n\te[0] = expr.substr(0, expr.find_first_of('='));\n\te[1] = expr.substr(expr.find_first_of('=') + 1);\n\twhile (1) {\n\t\trep(i, 2) {\n\t\t\tif (e[i].size() >= 5) { //?¨????????????¨???????????£?????????\n\t\t\t\trep(j, e[i].size() - 4) {\n\t\t\t\t\t// ( TF +*> TF ) ?????????????§????\n\t\t\t\t\tif (e[i][j] == '(' && (e[i][j + 1] == 'T' || e[i][j + 1] == 'F') &&\n\t\t\t\t\t\t(e[i][j + 2] == '+' || e[i][j + 2] == '*' || e[i][j + 2] == '>') &&\n\t\t\t\t\t\t(e[i][j + 3] == 'T' || e[i][j + 3] == 'F') && e[i][j + 4] == ')') {\n\t\t\t\t\t\tchar result;\n\t\t\t\t\t\tswitch (e[i][j + 2])\n\t\t\t\t\t\t{\n\t\t\t\t\t\tcase '+':\n\t\t\t\t\t\t\tif (e[i][j + 1] == 'F' && e[i][j + 3] == 'F') {\n\t\t\t\t\t\t\t\tresult = 'F';\n\t\t\t\t\t\t\t}\n\t\t\t\t\t\t\telse result = 'T';\n\t\t\t\t\t\t\tbreak;\n\t\t\t\t\t\tcase '*':\n\t\t\t\t\t\t\tif (e[i][j + 1] == 'T' && e[i][j + 3] == 'T') {\n\t\t\t\t\t\t\t\tresult = 'T';\n\t\t\t\t\t\t\t}\n\t\t\t\t\t\t\telse result = 'F';\n\t\t\t\t\t\t\tbreak;\n\t\t\t\t\t\tcase '>':\n\t\t\t\t\t\t\tif (e[i][j + 1] == 'T' && e[i][j + 3] == 'F') {\n\t\t\t\t\t\t\t\tresult = 'F';\n\t\t\t\t\t\t\t}\n\t\t\t\t\t\t\telse result = 'T';\n\t\t\t\t\t\t\tbreak;\n\t\t\t\t\t\t}\n\t\t\t\t\t\t//????????????\n\t\t\t\t\t\te[i].erase(j, 4); // ) ????????????\n\t\t\t\t\t\te[i][j] = result; // ) ???TF??????????????????\n\t\t\t\t\t\tDeleteReverse(e[i]);\n\t\t\t\t\t\tbreak;\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t}\n\t\t\t//?¨??????????\n\t\t\tif (e[0].size() == 1 && e[1].size() == 1) {\n\t\t\t\tif (e[0].front() == e[1].front()) {\n\t\t\t\t\treturn true;\n\t\t\t\t}\n\t\t\t\telse return false;\n\t\t\t}\n\t\t}\n\t}\n\treturn false;\n}\n\nvoid DeleteReverse(std::string & expr)\n{\n\trep(i, expr.size() - 1) {\n\t\tif (expr[i] == '-' && expr[i + 1] == 'F') {\n\t\t\texpr.erase(i, 1);\n\t\t\texpr[i] = 'T';\n\t\t}\n\t\telse if (expr[i] == '-' && expr[i + 1] == 'T') {\n\t\t\texpr.erase(i, 1);\n\t\t\texpr[i] = 'F';\n\t\t}\n\t}\n}"
  },
  {
    "language": "C++",
    "code": "#include<bits/stdc++.h>\nusing namespace std;\n\n#define rep(i,n) for(int i=0; i<n; i++)\n\nstring str;\nint p;\n\nbool equation(string s);\nbool formula(string s);\n\n//1:true 0:false\nbool equation(string s){\n  bool a=formula(s);\n  if(s[p]=='=')p++;//'='\n  bool b=formula(s);\n  if((a && b) || (!a&&!b))return true;\n  else return false;\n}\n\n//1:true 0:false -1:?????°\nbool formula(string s){\n  if(s[p]=='-'){\n    p++;//'-'\n    if(formula(s))return false;\n    else return true;\n  }\n  else if(s[p]=='('){\n    p++;//'('\n    bool a=formula(s);\n    char tmp=s[p];//?????????\n    p++;//'*', '+', '->'\n    if(s[p]=='>')p++;//'->'\n    bool b=formula(s);\n    p++;//')'\n\n    if(tmp=='*'){\n      if(a && b)return true;\n      else return false;\n    }\n    else if(tmp=='+'){\n      if(a || b)return true;\n      else return false;\n    }\n    else{\n      if(a && !b)return false;\n      else return true;\n    }\n  }\n  else{\n    if(s[p]=='T'){p++; return true;}\n    else if(s[p]=='F'){p++; return false;}\n  }\n}\n\nvoid replace2(string *s, string c1, string c2){\n  int pos;\n  while((pos=(*s).find(c1, 0))!=string::npos){\n    (*s).replace(pos, 1, c2);\n  }\n}\n\nint main(){\n  while(cin>>str, str!=\"#\"){\n    bool flag=true;\n    rep(a,2) rep(b,2) rep(c,2) rep(d,2) rep(e,2) rep(f,2) rep(g,2) rep(h,2) rep(i,2) rep(j,2) rep(k,2){\n      string tmp=str;\n      //cout<<a<<b<<c<<d<<e<<f<<g<<h<<i<<j<<k<<endl;\n      if(a==1)replace2(&tmp, \"a\", \"T\");\n      else replace2(&tmp, \"a\", \"F\");\n      if(b==1)replace2(&tmp, \"b\", \"T\");\n      else replace2(&tmp, \"b\", \"F\");\n      if(c==1)replace2(&tmp, \"c\", \"T\");\n      else replace2(&tmp, \"c\", \"F\");\n      if(d==1)replace2(&tmp, \"d\", \"T\");\n      else replace2(&tmp, \"d\", \"F\");\n      if(e==1)replace2(&tmp, \"e\", \"T\");\n      else replace2(&tmp, \"e\", \"F\");\n      if(f==1)replace2(&tmp, \"f\", \"T\");\n      else replace2(&tmp, \"f\", \"F\");\n      if(g==1)replace2(&tmp, \"g\", \"T\");\n      else replace2(&tmp, \"g\", \"F\");\n      if(h==1)replace2(&tmp, \"h\", \"T\");\n      else replace2(&tmp, \"h\", \"F\");\n      if(i==1)replace2(&tmp, \"i\", \"T\");\n      else replace2(&tmp, \"i\", \"F\");\n      if(j==1)replace2(&tmp, \"j\", \"T\");\n      else replace2(&tmp, \"j\", \"F\");\n      if(k==1)replace2(&tmp, \"k\", \"T\");\n      else replace2(&tmp, \"k\", \"F\");\n      //cout<<tmp<<endl;\n      p=0;\n      if(!equation(tmp))flag=false;\n    }\n    if(flag)cout<<\"YES\"<<endl;\n    else cout<<\"NO\"<<endl;\n  }\n  return 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include <iostream>\n#include <cstring>\n#include <cctype>\n#include <map>\n#include <cmath>\nusing namespace std;\nstring str, str1, str2;\nint pos;\nmap<char, int> chset;\n\nint formula(){\n    int res;\n    if (str[pos] == 'T') {pos++; return 1;}\n    if (str[pos] == 'F') {pos++; return 0;}\n    if (chset.find(str[pos]) != chset.end()) {return chset[str[pos++]];}\n    if (str[pos] == '-' && str[pos + 1] != '>') {\n        pos++;\n        return 1 - formula();\n    }\n\n    if (str[pos] == '(') {\n        pos++;\n        res = formula();\n        if (str[pos] == '*') {\n            pos++;\n            res = min(res, formula());\n        }\n        else if (str[pos] == '+') {\n            pos++;\n            res = max(res, formula());\n        }\n        else if (str[pos] == '-' && str[pos + 1] == '>') {\n            pos += 2;\n            if (res == 1 && formula() == 0) {\n                res = 0;\n            }\n            else {\n                res = 1;\n            }\n        }\n        pos++;\n    }\n    return res;\n}\n\nvoid equation(){\n    string chlist = \"\";\n    for (int i = 0; i < str.size(); i++) {\n        if (islower(str[i])) {\n            chlist += str[i];\n        }\n    }\n    for (int i = 0; i < pow(2, chlist.size()) - 1; i++) {\n        for (int j = 0; j < chlist.size(); j++) {\n            chset[chlist[j]] = (i >> j) & 1;\n        }\n        pos = 0;\n        str = str1;\n        int res = formula();\n        pos = 0;\n        str = str2;\n        if (res != formula()) {\n            cout << \"NO\" << endl;\n            return;\n        }\n    }\n    cout << \"YES\" << endl;\n}\n\nint main()\n{\n    while (true) {\n        cin >> str;\n        if (str == \"#\") {\n            break;\n        }\n        str1 = \"\"; str2 = \"\";\n        for (int i = 0; i < str.size(); i++) {\n            if (str[i] == '=') {\n                str2 = str1;\n                str1 = \"\";\n            }\n            else {\n                str1 += str[i];\n            }\n        }\n        equation();\n    }\n    return 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include <algorithm>\n#include <bitset>\n#include <cctype>\n#include <complex>\n#include <cmath>\n#include <cstdio>\n#include <cstdlib>\n#include <cstring>\n#include <ctime>\n#include <deque>\n#include <functional>\n#include <iomanip>\n#include <iostream>\n#include <list>\n#include <map>\n#include <numeric>\n#include <queue>\n#include <set>\n#include <sstream>\n#include <stack>\n#include <string>\n#include <utility>\n#include <vector>\n\nusing namespace std;\n\ninline int toInt(string s) {int v; istringstream sin(s);sin>>v;return v;}\ntemplate<class T> inline string toString(T x) {ostringstream sout;sout<<x;return sout.str();}\ntemplate<class T> inline T sqr(T x) {return x*x;}\n\ntypedef vector<int> vi;\ntypedef vector<vi> vvi;\ntypedef vector<string> vs;\ntypedef pair<int, int> pii;\ntypedef long long ll;\n\n#define all(a)  (a).begin(),(a).end()\n#define rall(a) (a).rbegin(), (a).rend()\n#define pb push_back\n#define mp make_pair\n#define each(i,c) for(typeof((c).begin()) i=(c).begin(); i!=(c).end(); ++i)\n#define exist(s,e) ((s).find(e)!=(s).end())\n#define range(i,a,b) for(int i=(a);i<(b);++i)\n#define rep(i,n)  range(i,0,n)\n#define clr(a,b) memset((a), (b) ,sizeof(a))\n#define dump(x)  cerr << #x << \" = \" << (x) << endl;\n#define debug(x) cerr << #x << \" = \" << (x) << \" (L\" << __LINE__ << \")\" << \" \" << __FILE__ << endl;\n\nconst double eps = 1e-10;\nconst double pi  = acos(-1.0);\nconst ll INF =1LL << 62;\nconst int inf =1 << 29;\n\nint pos;\nconst string kVars = \"abcdefghijk\";\nstring formula1, formula2, res;\n\nint mlt(int lhs, int rhs){\n    return lhs && rhs;\n}\n\nint pls(int lhs, int rhs){\n    return lhs || rhs;\n}\n\nint mns(int val){\n    return !val;\n}\n\nint imp(int lhs, int rhs){\n    return !(lhs && !rhs);\n}\n\nint operate(const string& formula, int& pos){\n    int ret;\n\n    if(formula.at(pos) == '('){\n        pos++;\n\n        int lhs = operate(formula, pos);\n        char op = formula.at(pos++); if(formula.at(pos) == '>') pos++;\n        int rhs = operate(formula, pos);\n\n        switch(op){\n        case '*': { ret = mlt(lhs, rhs); break; }\n        case '+': { ret = pls(lhs, rhs); break; }\n        case '-': { ret = imp(lhs, rhs); break; }\n        default : break;\n        }\n    }\n\n    else if(formula.at(pos) == '-'){\n        bool isMns = false;\n        while(formula.at(pos) == '-') isMns = !isMns, pos++;\n\n        if(isMns) ret = mns(operate(formula, pos));\n    }\n\n    else {\n        ret = formula.at(pos++) - '0';\n    }\n\n    return ret;\n}\n\nvoid dfs(int p){\n    if(p == kVars.size()){\n        if(operate(formula1, pos = 0) != operate(formula2, pos = 0)){\n            res = \"NO\";\n        }\n\n        return;\n    }\n\n    rep(i, 2){\n        string tmp1 = formula1, tmp2 = formula2;\n\n        replace(all(formula1), kVars.at(p), (char)(i + '0'));\n        replace(all(formula2), kVars.at(p), (char)(i + '0'));\n\n        dfs(p + 1);\n\n        formula1 = tmp1, formula2 = tmp2;\n    }\n}\n\nint main(void){\n    for(string in; cin >> in, in != \"#\"; cout << res << endl){\n        res = \"YES\";\n\n        replace(all(in), '=', ' ');\n\n        stringstream ss(in);\n        ss >> formula1;\n        ss >> formula2;\n\n        dfs(0);\n    }\n\n\treturn 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include <cstdio>\n#include <cstdlib>\n#include <cstring>\n#include <cmath>\n#include <climits>\n#include <cfloat>\n#include <ctime>\n#include <cassert>\n#include <map>\n#include <utility>\n#include <set>\n#include <iostream>\n#include <memory>\n#include <string>\n#include <vector>\n#include <algorithm>\n#include <functional>\n#include <sstream>\n#include <complex>\n#include <stack>\n#include <queue>\n#include <numeric>\n#include <list>\n#include <iomanip>\n \nusing namespace std;\n \n#if __GNUC__\n#include <tr1/unordered_map>\n#include <tr1/unordered_set>\nusing namespace tr1;\n#else\n#include <unordered_map>\n#include <unordered_set>\n#endif\n \n \n \n#ifdef _MSC_VER\n#define __typeof__ decltype\ntemplate <class T> int popcount(T n) { return n ? 1 + popcount(n & (n - 1)) : 0; }\n#endif\n#ifdef __GNUC__\ntemplate <class T> int popcount(T n);\ntemplate <> int popcount(unsigned int n) { return __builtin_popcount(n); }\ntemplate <> int popcount(int n) { return __builtin_popcount(n); }\ntemplate <> int popcount(unsigned long long n) { return __builtin_popcountll(n); }\ntemplate <> int popcount(long long n) { return __builtin_popcountll(n); }\n#endif\n \n#define rep (i, n) for (int i = 0; i < (int)n; ++i)\n#define foreach(it, c) for (__typeof__((c).begin()) it=(c).begin(); it != (c).end(); ++it)\n#define rforeach(it, c) for (__typeof__((c).rbegin()) it=(c).rbegin(); it != (c).rend(); ++it)\n#define all(c) (c).begin(), (c).end()\n#define rall(c) (c).rbegin(), (c).rend()\n#define CL(arr, val) memset(arr, val, sizeof(arr))\n#define MEMCPY(dest, src) memcpy(dest, src, sizeof(src))\n \n \ntemplate <class T> void max_swap(T& a, const T& b) { a = max(a, b); }\ntemplate <class T> void min_swap(T& a, const T& b) { a = min(a, b); }\n \ntypedef long long ll;\ntypedef pair<int, int> pint;\n \ntemplate <class T> string to_s(const T& a) { ostringstream os; os << a; return os.str(); }\n \nconst double EPS = 1e-8;\nconst double PI = acos(-1.0);\nconst int dx[] = { 0, 1, 0, -1 };\nconst int dy[] = { 1, 0, -1, 0 };\nbool valid_pos(int x, int y, int w, int h) { return 0 <= x && x < w && 0 <= y && y < h; }\n \ntemplate <class T> void print(T a, int n, int br = 1, const string& deli = \", \") { cout << \"{ \"; for (int i = 0; i < n; ++i) { cout << a[i]; if (i + 1 != n) cout << deli; } cout << \" }\"; while (br--) cout << endl; }\ntemplate <class T> void print(const vector<T>& v, int br = 1, const string& deli = \", \") { print(v, v.size(), br, deli); }\ntemplate <class T> void print2d(T a, int w, int h, int width = -1, int br = 1) { for (int i = 0; i < h; ++i) { for (int j = 0; j < w; ++j) {\tif (width != -1) cout.width(width); cout << a[i][j] << ' ';\t} cout << endl; } while (br--) cout << endl; }\n \ntemplate <class T> void input(int n, T& a) { for (int i = 0; i < n; ++i) cin >> a[i]; }\ntemplate <class T, class U> void input(int n, T& a, U& b) { for (int i = 0; i < n; ++i) cin >> a[i] >> b[i]; }\ntemplate <class T> vector<T> input(int n) { vector<T> res(n); for (int i = 0; i < n; ++i) cin >> res[i]; return res; }\n\n\n\nstruct Team\n{\n\tint ac, pena, id;\n\tTeam(int id)\n\t\t: id(id), ac(0), pena(0) { }\n\tbool operator<(const Team& o) const\n\t{\n\t\tif (ac != o.ac)\n\t\t\treturn ac > o.ac;\n\t\telse if (pena != o.pena)\n\t\t\treturn pena < o.pena;\n\t\telse\n\t\t\treturn id < o.id;\n\t}\n};\nstruct Log\n{\n\tint tid, pid, time;\n\tbool ac;\n\tLog(int tid, int pid, int time, bool ac)\n\t\t: tid(tid), pid(pid), time(time), ac(ac) { }\n\tbool operator<(const Log& o) const\n\t{\n\t\treturn time < o.time;\n\t}\n};\nint main()\n{\n\tint t, p, r;\n\twhile (cin >> t >> p >> r, t | p | r)\n\t{\n\t\tvector<Team> team;\n\t\tfor (int i = 0; i < t; ++i)\n\t\t\tteam.push_back(Team(i));\n\n\t\tvector<Log> log;\n\t\twhile (r--)\n\t\t{\n\t\t\tint tid, pid, time;\n\t\t\tstring mes;\n\t\t\tcin >> tid >> pid >> time >> mes;\n\t\t\t--tid, --pid;\n\t\t\tlog.push_back(Log(tid, pid, time, mes[0] == 'C'));\n\t\t}\n\t\tsort(all(log));\n\n\t\tint wa[55][16];\n\t\tCL(wa, 0);\n\t\tforeach (it, log)\n\t\t{\n\t\t\tif (it->ac)\n\t\t\t{\n\t\t\t\tTeam& a = team[it->tid];\n\t\t\t\t++a.ac;\n\t\t\t\ta.pena += wa[it->tid][it->pid] * 1200 + it->time;\n\t\t\t}\n\t\t\telse\n\t\t\t\t++wa[it->tid][it->pid];\n\t\t}\n\n\t\tsort(all(team));\n\t\tforeach (it, team)\n\t\t\tprintf(\"%d %d %d\\n\", it->id + 1, it->ac, it->pena);\n\t}\n}"
  },
  {
    "language": "C++",
    "code": "#include <functional>\n#include <iostream>\n#include <string>\n#include <unordered_set>\n#include <vector>\n#define loop(i, a, n) for (int i = (a); i < (n); i++)\n#define rep(i, n) loop(i, 0, n)\ntemplate<typename A> using F = std::function<A>;\nusing namespace std;\n\ntemplate<typename T> struct ParseResult {\n\tbool succeeded;\n\tT object;\n\tint pos;\n\tParseResult(const ParseResult& other) = default;\n\tParseResult(ParseResult&& other) : succeeded(other.succeeded), object(std::move(other.object)), pos(other.pos) {}\n\tParseResult& operator=(const ParseResult& other) = default;\n\tParseResult& operator=(ParseResult&& other) { succeeded = (other.succeeded); object = (std::move(other.object)); pos = (other.pos); return *this; }\n\tParseResult(const bool succeeded, T object, const int pos) : succeeded(succeeded), object(std::move(object)), pos(pos) {}\n\tfriend std::ostream &operator<<(std::ostream &os, const ParseResult<T> &p) { return os << '{' << (p.succeeded ? \"true\" : \"false\") << ',' << p.object << ',' << p.pos << '}'; }\n};\n\ntemplate<typename T> using Parser = std::function<ParseResult<T>(const std::string&, int)>;\n\nParser<std::string> token(std::string &&s) {\n\tconst auto n = s.size();\n\treturn[n = std::move(n), s = std::move(s)](const std::string &target, const int pos) {\n\t\tif (target.size() < n) return ParseResult<std::string>(false, {}, pos);\n\t\treturn target.substr(pos, n) == s ? ParseResult<std::string>(true, s, pos + n) : ParseResult<std::string>(false, {}, pos);\n\t};\n}\n\ntemplate<typename T> Parser<T> operator||(Parser<T> p1, Parser<T> p2) {\n\treturn[p1 = std::move(p1), p2 = std::move(p2)](const std::string &target, const int pos) {\n\t\tauto r = p1(target, pos);\n\t\tif (r.succeeded) return r;\n\t\tr = p2(target, pos);\n\t\tif (r.succeeded) return r;\n\t\treturn ParseResult<T>(false, {}, pos);\n\t};\n}\n\ntemplate<typename T1, typename T2> Parser<std::pair<T1, T2>> operator+(Parser<T1> p1, Parser<T2> p2) {\n\treturn[p1 = std::move(p1), p2 = std::move(p2)](const std::string &target, const int pos) {\n\t\tauto r1 = p1(target, pos);\n\t\tif (!r1.succeeded) return ParseResult<std::pair<T1, T2>>(false, {}, pos);\n\t\tauto r2 = p2(target, r1.pos);\n\t\tif (!r2.succeeded) return ParseResult<std::pair<T1, T2>>(false, {}, pos);\n\t\treturn ParseResult<std::pair<T1, T2>>(true, { r1.object, r2.object }, r2.pos);\n\t};\n}\n\ntemplate<typename T1, typename T2> Parser<T2> operator>>(Parser<T1> p1, Parser<T2> p2) {\n\treturn[p1 = std::move(p1), p2 = std::move(p2)](const std::string &target, const int pos) {\n\t\tauto r1 = p1(target, pos);\n\t\tif (!r1.succeeded) return ParseResult<T2>(false, {}, pos);\n\t\tauto r2 = p2(target, r1.pos);\n\t\tif (!r2.succeeded) return ParseResult<T2>(false, {}, pos);\n\t\treturn ParseResult<T2>(true, r2.object, r2.pos);\n\t};\n}\n\ntemplate<typename T1, typename T2> Parser<T1> operator<<(Parser<T1> p1, Parser<T2> p2) {\n\treturn[p1 = std::move(p1), p2 = std::move(p2)](const std::string &target, const int pos) {\n\t\tauto r1 = p1(target, pos);\n\t\tif (!r1.succeeded) return ParseResult<T1>(false, {}, pos);\n\t\tauto r2 = p2(target, r1.pos);\n\t\tif (!r2.succeeded) return ParseResult<T1>(false, {}, pos);\n\t\treturn ParseResult<T1>(true, r1.object, r2.pos);\n\t};\n}\n\nParser<char> oneOf(const std::string &s) {\n\tstd::unordered_set<char> d;\n\tfor (auto &c : s) d.insert(c);\n\treturn[d = std::move(d)](const std::string &target, const int pos) {\n\t\tif (target.size() <= pos) return ParseResult<char>(false, {}, pos);\n\t\tchar c = target[pos];\n\t\treturn d.count(c) ? ParseResult<char>(true, c, pos + 1) : ParseResult<char>(false, {}, pos);\n\t};\n}\n\ntemplate<typename T, typename S, typename F> Parser<S> fmap(Parser<T> p, F &&f) {\n\treturn[p = std::move(p), f = std::forward<F>(f)](const std::string &target, const int pos) {\n\t\tauto r = p(target, pos);\n\t\treturn r.succeeded ? ParseResult<S>(true, f(r.object), r.pos) : ParseResult<S>(false, {}, r.pos);\n\t};\n}\n\ntemplate<typename T, typename F> Parser<T> lazy(F &&f) {\n\tbool instantiated = false;\n\tParser<T> p;\n\treturn[f = std::forward<F>(f), p = std::move(p), instantiated = std::move(instantiated)](const std::string &target, const int pos) mutable {\n\t\tif (!instantiated) {\n\t\t\tp = f();\n\t\t\tinstantiated = true;\n\t\t}\n\t\treturn p(target, pos);\n\t};\n}\n\nstruct SyntaxTree {\n\tstring op;\n\tchar value;\n\tvector<SyntaxTree> children;\n\tSyntaxTree() {}\n\tSyntaxTree(const SyntaxTree& other) = default;\n\tSyntaxTree(SyntaxTree&& other) :op(std::move(other.op)), value(other.value), children(std::move(other.children)){}\n\tSyntaxTree& operator=(const SyntaxTree& other) = default;\n\tSyntaxTree& operator=(SyntaxTree&& other) { op = (std::move(other.op)), value = (other.value), children = (std::move(other.children)); return *this; }\n\tSyntaxTree(const string &op, const char value, const vector<SyntaxTree> &children) : op(op), value(value), children(children) {}\n};\n\nint main() {\n\tParser<SyntaxTree> formulaP = lazy<SyntaxTree>([&]() {\n\t\tauto andP = fmap<pair<SyntaxTree, SyntaxTree>, SyntaxTree>((token(\"(\") >> formulaP << token(\"*\")) + (formulaP << token(\")\")), [](auto &o) { return SyntaxTree(\"*\", {}, { o.first, o.second }); });\n\t\tauto orP = fmap<pair<SyntaxTree, SyntaxTree>, SyntaxTree>((token(\"(\") >> formulaP << token(\"+\")) + (formulaP << token(\")\")), [](auto &o) { return SyntaxTree(\"+\", {}, { o.first, o.second }); });\n\t\tauto impP = fmap<pair<SyntaxTree, SyntaxTree>, SyntaxTree>((token(\"(\") >> formulaP << token(\"->\")) + (formulaP << token(\")\")), [](auto &o) { return SyntaxTree(\"->\", {}, { o.first, o.second }); });\n\t\tauto notP = fmap<SyntaxTree, SyntaxTree>(token(\"-\") >> formulaP, [](auto &o) { return SyntaxTree(\"-\", {}, { o }); });\n\t\tauto valP = fmap<char, SyntaxTree>(oneOf(\"abcdefghijkTF\"), [](char x) { return SyntaxTree({}, x, {}); });\n\t\treturn andP || orP || impP || notP || valP;\n\t});\n\tauto equationP = (formulaP << token(\"=\")) + formulaP;\n\tstring s;\n\twhile (cin >> s, s != \"#\") {\n\t\tauto r = equationP(s, 0);\n\t\tbool isValid = true;\n\t\trep(i, 1 << 11) {\n\t\t\tauto toBool = [&](char c) -> bool {\n\t\t\t\tif (c == 'T') return true;\n\t\t\t\tif (c == 'F') return false;\n\t\t\t\treturn i >> (c - 'a') & 1;\n\t\t\t};\n\t\t\tF<bool(const SyntaxTree&)> evalF = [&](const SyntaxTree &f) {\n\t\t\t\tswitch (f.children.size()) {\n\t\t\t\tcase 0: return toBool(f.value);\n\t\t\t\tcase 1: return !evalF(f.children[0]);\n\t\t\t\tcase 2:\n\t\t\t\t\tif (f.op == \"*\") return evalF(f.children[0]) && evalF(f.children[1]);\n\t\t\t\t\tif (f.op == \"+\") return evalF(f.children[0]) || evalF(f.children[1]);\n\t\t\t\t\tif (f.op == \"->\") return !evalF(f.children[0]) || evalF(f.children[1]);\n\t\t\t\t}\n\t\t\t};\n\t\t\tisValid &= evalF(r.object.first) == evalF(r.object.second);\n\t\t}\n\t\tcout << (isValid ? \"YES\" : \"NO\") << endl;\n\t}\n}"
  },
  {
    "language": "C++",
    "code": "#include<bits/stdc++.h>\nusing namespace std;\n\nbool formula(string s, int& idx){\n  char c = s[idx];\n  idx++;\n  if(c == 'T') return true;\n  if(c == 'F') return false;\n  if(c == '-') return !formula( s, idx);\n  if(c == '('){\n    bool right = formula( s, idx);\n    char op = s[idx];\n    idx += (s.substr(idx,2) == \"->\");\n    bool left = formula( s, idx);\n    idx++;\n\n    if(op == '*') return right & left;\n    if(op == '+') return right | left;\n    if(op == '-') return ~right | left;\n  }\n}\n\n\nint main(){\n  string s;\n  while(cin >> s, s != \"#\"){\n    string left = s.substr( 0, s.find('='));\n    string right = s.substr( s.find('=') + 1);\n    bool flag = true;\n    for(int i = 0; i < (1 << 11); i++){\n      string a[2];\n      a[0] = left, a[1] = right;\n      for(int q = 0; q < 2; q++){\n        for(int j = 0; j < a[q].size(); j++){\n          if('a' <= a[q][j] && a[q][j] <= 'k'){\n            a[q][j] = \"FT\"[(a[q][j] - 'a') >> 1 & 1];\n          }\n        }\n      }\n      int pos ;\n\n      flag &= formula(a[0], pos = 0) == formula(a[1], pos = 0);\n      if(!flag) break;\n    }\n\n    if(flag) cout << \"YES\" << endl;\n    else cout << \"NO\" << endl;\n  }\n  return 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include <stdio.h>\n#include <string.h>\n#define NOT(a) ((a)==1)?0:1\n#define AND(a,b) ((a) && (b))?1:0\n#define OR(a,b) ((a) || (b))?1:0\n#define IMP(a,b) (!((a) && (!(b))))?1:0\n\nint alpha[11];\n\nint formula(char *str){\n\tif(*str == 'T'){\n\t\t//printf(\"T = 1\\n\");\n\t\treturn 1;\n\t}else if(*str == 'F'){\n\t\t//printf(\"F = 0\\n\");\n\t\treturn 0;\n\t}else if('a' <= *str && *str <= 'k'){\n\t\t//printf(\"alpha %c = %d\\n\",*str,alpha[*str - 'a']);\n\t\treturn alpha[*str - 'a'];\n\t}else if(*str == '-'){\n\t\t//printf(\"f = %d\\n\",formula(str + 1));\n\t\t//printf(\"NOT(f) = %d\\n\",NOT(formula(str + 1)));\n\t\treturn NOT(formula(str + 1));\n\t}else{\n\t\tint middle = 0;\n\t\tchar *p;\n\t\tfor(p = (str + 1);(*p != '*' && *p != '+' && !(*p == '-' && *(p + 1) == '>')) || middle != 0;p++){\n\t\t\tif(*p == '('){\n\t\t\t\tmiddle++;\n\t\t\t}else if(*p == ')'){\n\t\t\t\tmiddle--;\n\t\t\t}\n\t\t}\n\t\tif(*p == '*'){\n\t\t\t//printf(\"%d * %d = %d\\n\",formula(str + 1),formula(p + 1),AND(formula(str + 1),formula(p + 1)));\n\t\t\treturn AND(formula(str + 1),formula(p + 1));\n\t\t}else if(*p == '+'){\n\t\t\t//printf(\"%d + %d = %d\\n\",formula(str + 1),formula(p + 1),OR(formula(str + 1),formula(p + 1)));\n\t\t\treturn OR(formula(str + 1),formula(p + 1));\n\t\t}else{\n\t\t\t//printf(\"%d -> %d = %d\\n\",formula(str + 1),formula(p + 1),IMP(formula(str + 1),formula(p + 1)));\n\t\t\treturn IMP(formula(str + 1),formula(p + 2));\n\t\t}\n\t}\n}\n\nint equation(char *str){\n\tint i, f1, f2;\n\tfor(i = 0;str[i] != '=';i++);\n\tif((f1 = formula(str)) == (f2 = formula(str + i + 1))){\n\t\t//printf(\"%d %d\\n\",f1,f2);\n\t\treturn 1;\n\t}else{\n\t\t//printf(\"%d %d\\n\",f1,f2);\n\t\treturn 0;\n\t}\n}\n\n\n\nint main(void){\n\tint i, j;\n\tchar str[1001], ans[4];\n\twhile(1){\n\t\tstrcpy(ans,\"YES\");\n\t\tscanf(\"%s\",&str);\n\t\tif(!strcmp(str,\"#\")){\n\t\t\tbreak;\n\t\t}\n\t\tfor(i = 0;i < 1 << 11;i++){\n\t\t\tfor(j = 0;j < 11;j++){\n\t\t\t\talpha[j] = (i >> j) & 1;\n//\t\t\t\tprintf(\"%d \",(i >> j) & 1);\n\t\t\t}\n//\t\t\tprintf(\"\\n\");\n\t\t\tif(!equation(str)){\n\t\t\t\tstrcpy(ans,\"NO\");\n\t\t\t}\n\t\t}\n\t\tputs(ans);\n\t}\n//\twhile(1);\n\t/*\tfor(i = 1;i >= 0;i--){\n\t\t\tfor(j = 1;j >= 0;j--){\n\t\t\t\tprintf(\"%d \",i);\n\t\t\t\tprintf(\"%d \",j);\n\t\t\t\tprintf(\"%d \",NOT(i));\n\t\t\t\tprintf(\"%d \",AND(i,j));\n\t\t\t\tprintf(\"%d \",OR(i,j));\n\t\t\t\tprintf(\"%d \",IMP(i,j));\n\t\t\t\tprintf(\"\\n\");\n\t\t\t}\n\t\t}\n\t\twhile(1);*/\n\treturn 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include<iostream>\n#include<vector>\n#include<algorithm>\n#define all(c) c.begin(),c.end()\n#define uni(c) c.erase(unique(c.begin(),c.end()),c.end())\n#define pb push_back\nusing namespace std;\n\nint expr(string& s, int& i);\nint term(string& s, int& i);\nint factor(string& s, int& i);\nint number(string& s, int& i);\n\n\nint expr(string& s, int& i) {\n  int val = term(s, i);\n  while(s[i] == '+' || s[i] == '-') {\n    char op = s[i];\n    i++;\n  \tif(!isdigit(s[i])){\n  \t\ti++;\n  \t\tint val2 = term(s, i);\n  \t\tif(val==1&&val2==0){\n  \t\t\tval=0;\n  \t\t}else{\n  \t\t\tval=1;\n  \t\t}\n  \t}else{\n  \t  int val2 = term(s, i);\n    \tif (op == '+') val |= val2;\n  \t}\n  }\n  return val;\n}\n\nint term(string& s, int& i) {\n  int val = factor(s, i);\n  while(s[i] == '*') {\n    char op = s[i];\n    i++;\n    int val2 = factor(s, i);\n    if (op == '*') val *= val2;\n  }\n  return val;\n}\n\nint factor(string& s, int& i) {\n\tint flag=0;\n\tif(s[i]=='-'){\n\t\tflag=1;\n\t\ti++;\n\t}\n\tif (isdigit(s[i])){\n\t\tif(flag)\n\t\t\treturn flag^number(s, i);\n\t\t\treturn number(s,i);\n\t}\n\n  // ここで構文が正しければ s[i] == '(' となる\n  i++; // '('を読み飛ばす\n  int ret = expr(s, i);\n  i++; // ')'を読み飛ばす\n\tif(flag)\n\treturn flag^ret;\n\treturn ret;\n}\n\nint number(string& s, int& i) {\n  int n = s[i++] - '0';\n  while(isdigit(s[i])) n = n*10 + s[i++] - '0';\n  return n;\n}\n\n\n\n\nint main(){\n\tstring s;\n\twhile(cin>>s,s!=\"#\"){\n\t\tint eq=0;\n\t\tstring a,b;\n\t\tfor(;s[eq]!='=';eq++);\n\t\ta=s.substr(0,eq),b=s.substr(eq+1,s.size()-eq);\n\t\t//cout<<a<<\" \"<<b<<endl;\n\t\tvector<char> ap;\n\t\tfor(int i=0;i<s.size();i++){\n\t\t\tif(isalpha(s[i]))\n\t\t\t\tap.pb(s[i]);\n\t\t}\n\t\tsort(all(ap));\n\t\tuni(ap);\n\t\tbool flag=true;\n\t\tfor(int i=0;i<(1<<ap.size());i++){\n\t\t\tstring x=a,y=b;\n\t\t\tfor(int j=0;j<ap.size();j++){\n\t\t\t\tchar c=ap[j];\n\t\t\t\tbool wh=false;\n\t\t\t\tif((1<<j)&i)\n\t\t\t\t\twh=true;\n\t\t\t\tfor(int k=0;k<x.size();k++){\n\t\t\t\t\tif(x[k]==c){\n\t\t\t\t\t\tif(wh)\n\t\t\t\t\t\t\tx[k]='1';\n\t\t\t\t\t\telse\n\t\t\t\t\t\t\tx[k]='0';\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t\tfor(int k=0;k<y.size();k++){\n\t\t\t\t\tif(y[k]==c){\n\t\t\t\t\t\tif(wh)\n\t\t\t\t\t\t\ty[k]='1';\n\t\t\t\t\t\telse\n\t\t\t\t\t\t\ty[k]='0';\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t}\n\t\t\t\n\t\t\t\n\t\t\tcout<<x<<\" \"<<y<<endl;\n\t\t\tcout<<expr(x,0)<<\"  \"<<expr(y,0)<<endl;\n\t\t\tif(expr(x,0)!=expr(y,0)){\n\t\t\t\tcout<<\"NO\"<<endl;\n\t\t\t\tflag=false;\n\t\t\t\tbreak;\n\t\t\t}\n\t\t\t\n\t\t}\n\t\tif(flag)\n\t\t\tcout<<\"YES\"<<endl;\n\t}\n\treturn 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include <iostream>\n#include <vector>\n#include <algorithm>\n#include <string>\n#include <sstream>\n#include <cstring>\n#include <cstdlib>\n#include <cstdio>\n#include <cmath>\n#include <queue>\n#include <stack>\n#include <map>\n#include <set>\n#include <bitset>\n \n#define rep(i, n) for(int i = 0; i < (n); i++)\n#define FOR(i, a, b) for(int i = (a); i < (b); i++)\n#define all(v) (v).begin(), (v).end()\n#define rev(s) (s).rbegin(), (s).rend()\n#define MP make_pair\n#define X first\n#define Y second\n \nusing namespace std;\n \ntypedef long long ll;\ntypedef pair<int, int> P;\ntypedef vector<int> vi;\n\nvoid fin(){\n\tfreopen(\"test.txt\", \"r\", stdin);\n}\n\nbool formula(const string &s){\n\trep(i,2){\n\t\tif(s[0] == \"FT\"[i]) return i;\n\t}\n\n\tif(s[0] == '-'){\n\t\treturn !formula(s.substr(1));\n\t}\n\n\tint lidx = 1, llen, ridx, rlen;\n\tchar ope;\n\tint nest = 0;\n\trep(i, s.size()){\n\t\tif(s[i] == '(') nest++;\n\t\tif(s[i] == ')') nest--;\n\t\tif(nest != 1) continue;\n\t\trep(j, 3) if(s[i] == \"*+>\"[j]){\n\t\t\tope = s[i];\n\t\t\tllen= i-1-(s[i] == '>');\n\t\t\tridx = i+1;\n\t\t\trlen = s.size()-ridx-1;\n\t\t\tgoto next;\n\t\t}\n\t}\nnext:\n\tbool lhs = formula(s.substr(lidx, llen));\n\tbool rhs = formula(s.substr(ridx, rlen));\n\t\n\tif(ope == '+') return lhs|rhs;\n\tif(ope == '*') return lhs&rhs;\n\tif(lhs&(!rhs)) return false;\n\treturn true;\n}\n\nbool equation(string &s){\n\trep(i, s.size()){\n\t\tif(s[i] != '=') continue;\n\t\treturn formula(s.substr(0, i)) == formula(s.substr(i+1, s.size()));\n\t}\n\treturn false;\n}\n\nstring replace(const string &s, const char from, const char to){\n\tstring res = s;\n\trep(i, res.size()){\n\t\tif(res[i] == from) res[i] = to;\n\t}\n\treturn res;\n}\n\nbool include(const string &s, const char c){\n\trep(i, s.size()){\n\t\tif(s[i] == c) return true;\n\t}\n\treturn false;\n}\n\nstring val = \"abcdefghijk\";\nbool dfs(string &s, int i = 0){\n\tif(i == val.size()) return equation(s);\n\tif(!include(s, val[i])) return dfs(s, i+1);\n\trep(j, 2){\n\t\tstring rs = replace(s, val[i], \"TF\"[j]); \n\t\tif(!dfs(rs, i+1)) return false;\n\t}\n\treturn true;\n}\n\nint main(){\n//\tfin();\n\tstring s;\n\twhile(cin >> s){\n\t\tif(s[0] == '#') break;\n\t\tcout << (dfs(s)?\"YES\":\"NO\") << endl;\n\t}\n\n\treturn 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include <map>\n#include <iostream>\n#include <queue>\n#include <sstream>\n#include <memory>\n\n#define REP(i,n) for(int i=0; i<(int)(n); i++)\n\nusing namespace std;\n\nenum{\n  BINARY_OPERATOR = 0,\n  UNARY_OPERATOR  = 1,\n  VALUE           = 2\n};\n\nstruct Tree{\n  int type;\n\n  // Identifier, Value or Operator\n  string s;\n\n  struct Tree *left;\n  struct Tree *right;\n\n  Tree(int t, const string &v, Tree *l = NULL, Tree *r = NULL)\n    : type(t), s(v), left(l), right(r) {}\n\n  Tree(int t, char v, Tree *l = NULL, Tree *r = NULL)\n    : type(t), left(l), right(r) {\n    stringstream ss; ss << v;\n    s = ss.str();\n  }\n\n  ~Tree(){\n    delete left; delete right;\n  }\n\n  void debug(){\n    cout << \"(\";\n    switch(type){\n    case BINARY_OPERATOR:\n      left->debug();\n      cout << s;\n      right->debug();\n      break;\n    case UNARY_OPERATOR:\n      cout << s;\n      left->debug();\n      break;\n    case VALUE:\n      cout << s;\n      break;\n    }\n    cout << \")\";\n  }\n};\n\nstruct Parser{\n  const string bop1;\n  const string bop2;\n  const string uop;\n\n  Parser(const string &b1 = \"+-\",\n\t const string &b2 = \"*/\",\n\t const string &u = \"-\")\n    : bop1(b1), bop2(b2), uop(u) {}\n\n  typedef pair<Tree *, const char *> P;\n\n  P parseExpr(const char *p) const{\n    P r = parseTerm(p);\n    while( *r.second != '\\0' && bop1.find(*r.second) != string::npos ){\n      char op   = *r.second;\n      Tree *tmp = r.first;\n      r = parseTerm(r.second + 1);\n      r.first = new Tree(BINARY_OPERATOR, op, tmp, r.first);\n    }\n    return r;\n  }\n\n  P parseTerm(const char *p) const{\n    P r = parseFact(p);\n    while( *r.second != '\\0' && bop2.find(*r.second) != string::npos ){\n      char op   = *r.second;\n      Tree *tmp = r.first;\n      r = parseFact(r.second + 1);\n      r.first = new Tree(BINARY_OPERATOR, op, tmp, r.first);\n    }\n    return r;\n  }\n\n  P parseFact(const char *p) const{\n    if(uop.find(*p) != string::npos){\n      P r = parseFact(p + 1);\n      return P(new Tree(UNARY_OPERATOR, *p, r.first), r.second);\n    }else if(*p == '('){\n      P r = parseExpr(p + 1);\n      if(*r.second != ')') throw make_pair(\"fact1\", p);\n      return P(r.first, r.second + 1);\n    }else{\n      // identifier or value\n      stringstream ss;\n      while(*p != '\\0' &&\n\t    bop1.find(*p) == string::npos &&\n\t    bop2.find(*p) == string::npos &&\n\t    uop.find(*p)  == string::npos &&\n\t    *p != '(' && *p != ')'){\n\tss << *p++;\n      }\n      if(ss.str().size() == 0) throw make_pair(\"fact2\", p);\n      return P(new Tree(VALUE, ss.str()), p);\n    }\n  }\n\n  Tree *parse(const string &str) const{\n    return parseExpr(str.c_str()).first;\n  }\n};\n\n\ntemplate<typename E>\ntypename E::result eval(Tree *p, const E &e){\n  switch(p->type){\n  case BINARY_OPERATOR:\n    return e(eval(p->left, e), p->s[0], eval(p->right, e));\n  case UNARY_OPERATOR:\n    return e(p->s[0], eval(p->left, e));\n  case VALUE:\n    return e(p->s);\n  default:\n    throw \"Evaluater error\";\n  }\n}\n\nmap<char,vector<vector<int> > > f = {\n  make_pair('*', vector<vector<int> >({{0, 0}, {0, 1}})),\n  make_pair('+', vector<vector<int> >({{0, 1}, {1, 1}})),\n  make_pair('/', vector<vector<int> >({{1, 1}, {0, 1}})),\n  make_pair('=', vector<vector<int> >({{1, 0}, {0, 1}}))\n};\n\ntemplate<typename T>\nstruct Evaluater{\n  typedef T result;\n  const vector<int> var;\n\n  Evaluater(const vector<int> &v) : var(v){}\n\n  // Binary Operator\n  T operator()(const T &lhs, char op, const T &rhs) const{\n    return f[op][lhs][rhs];\n  }\n\n  // Unary Operator\n  T operator()(char op, const T &rhs) const{\n    return !rhs;\n  }\n\n  // Value\n  T operator()(const string &str) const{\n    if(isdigit(str[0])) return atoi(str.c_str());\n    return var[str[0] - 'a'];\n  }\n};\n\nint main(){\n  string s;\n  while(cin >> s, s != \"#\"){\n    while(s.find(\"->\") != string::npos)\n      s.replace(s.find(\"->\"), 2, \"/\");\n    while(s.find(\"T\") != string::npos)\n      s.replace(s.find(\"T\"), 1, \"1\");\n    while(s.find(\"F\") != string::npos)\n      s.replace(s.find(\"F\"), 1, \"0\");\n\n    const Parser p(\"=\", \"+*/\", \"-\");\n    const shared_ptr<Tree> t(p.parse(s));\n\n    vector<int> v(11);\n\n    REP(i,1<<11){\n      REP(j,11) v[j] = ((i & (1 << j)) == 0 ? 0 : 1);\n      int ret = eval(t.get(), Evaluater<int>(v));\n      if(ret == 0) goto bad;\n    }\n    puts(\"YES\");\n    continue;\n  bad:;\n    puts(\"NO\");\n  }\n  return 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include<iostream>\n#include<vector>\n#include<string>\n#include<algorithm>\nusing namespace std;\n\n#define MAX_NUM 2\n#define MAX_CH 10\n#define MAX_N 1200\n\nstring S, T;\nchar NUM[MAX_NUM + 1] = \"01\";\nchar CH[MAX_CH + 1] = \"abcdefghij\";\nint TR[MAX_CH];\nint CNT[MAX_N];\n\nint Plus(int c1, int c2) {\n\treturn max(c1, c2);\n}\nint kake(int c1, int c2) {\n\treturn min(c1, c2);\n}\nint fukumi(int c1, int c2) {\n\tif (c1 == 1 && c2 == 0) {\n\t\treturn 0;\n\t}\n\treturn 1;\n}\n\nint STOI(char V) {\n\tif (V == '0') {\n\t\treturn 0;\n\t}\n\telse {\n\t\treturn 1;\n\t}\n}\n\nint calc2(string A2) {\n\tA2 = A2.substr(1, A2.size() - 1);\n\tif (A2.size() == 3) {\n\t\tint p1, p2;\n\t\tp1 = STOI(A2[0]);\n\t\tp2 = STOI(A2[2]);\n\t\tif (A2[1] == '+') {\n\t\t\treturn Plus(p1, p2);\n\t\t}\n\t\tif (A2[1] == '*') {\n\t\t\treturn kake(p1, p2);\n\t\t}\n\t\tif (A2[1] == '&') {\n\t\t\treturn fukumi(p1, p2);\n\t\t}\n\t}\n\telse if (A2.size() == 4) {\n\t\tif (A2[0] == '-') {\n\t\t\tint p1, p2;\n\t\t\tp1 = STOI(A2[1]);\n\t\t\tp2 = STOI(A2[3]);\n\t\t\tif (A2[1] == '+') {\n\t\t\t\treturn Plus(1 - p1, p2);\n\t\t\t}\n\t\t\tif (A2[1] == '*') {\n\t\t\t\treturn kake(1 - p1, p2);\n\t\t\t}\n\t\t\tif (A2[1] == '&') {\n\t\t\t\treturn fukumi(1 - p1, p2);\n\t\t\t}\n\t\t}\n\t\tif (A2[2] == '-') {\n\t\t\tint p1, p2;\n\t\t\tp1 = STOI(A2[0]);\n\t\t\tp2 = STOI(A2[3]);\n\t\t\tif (A2[1] == '+') {\n\t\t\t\treturn Plus(p1, 1 - p2);\n\t\t\t}\n\t\t\tif (A2[1] == '*') {\n\t\t\t\treturn kake(p1, 1 - p2);\n\t\t\t}\n\t\t\tif (A2[1] == '&') {\n\t\t\t\treturn fukumi(p1, 1 - p2);\n\t\t\t}\n\t\t}\n\t}\n\telse {\n\t\tint p1, p2;\n\t\tp1 = STOI(A2[1]);\n\t\tp2 = STOI(A2[4]);\n\t\tif (A2[1] == '+') {\n\t\t\treturn Plus(1 - p1, 1 - p2);\n\t\t}\n\t\tif (A2[1] == '*') {\n\t\t\treturn kake(1 - p1, 1 - p2);\n\t\t}\n\t\tif (A2[1] == '&') {\n\t\t\treturn fukumi(1 - p1, 1 - p2);\n\t\t}\n\t}\n}\n\nstring TOSTR(int d) {\n\tif (d == 0) {\n\t\treturn \"0\";\n\t}\n\telse {\n\t\treturn \"1\";\n\t}\n}\n\nint calc(string Y) {\n\tfor (int i = 0; i < MAX_N; i++) {\n\t\tCNT[i] = 0;\n\t}\n\tstring Z = Y, AA = \"\";\n\n\twhile (Z.size() >= 2) {\n\t\tint L = 0, MN = 0;\n\t\tbool ok1 = false;\n\t\tZ = \"\"; AA = \"\";\n\t\tint pass2 = 0;\n\t\tint pass3 = -1;\n\t\twhile (pass2 < Y.size()) {\n\t\t\tif (Y[pass2] == '(') {\n\t\t\t\tL++;\n\t\t\t}\n\t\t\tif (Y[pass2] == ')') {\n\t\t\t\tL++;\n\t\t\t}\n\t\t\tCNT[pass2] = L;\n\t\t\tpass2++;\n\t\t\tMN = max(MN, L);\n\t\t}\n\t\tfor (int i = 0; i < Y.size(); i++) {\n\t\t\tif (CNT[i] == MN) {\n\t\t\t\tif (pass3 == -1) {\n\t\t\t\t\tpass3 = i;\n\t\t\t\t}\n\t\t\t\tAA += Y[i];\n\t\t\t\tif (i < Y.size() - 1) {\n\t\t\t\t\tif (Y[i + 1] == ')') {\n\t\t\t\t\t\tok1 = false;\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t}\n\t\t\telse {\n\t\t\t\tZ += Y[i];\n\t\t\t}\n\t\t}\n\t\tint ZSIZE = Z.size();\n\t\tZ = Z.substr(0, pass3) + TOSTR(calc2(AA)) + Z.substr(pass3, ZSIZE - pass3);\n\t}\n\tif (Z == \"0\") {\n\t\treturn 0;\n\t}\n\telse {\n\t\treturn 1;\n\t}\n}\n\nint power(int a, int b) {\n\tint res2 = 1;\n\tfor (int i = 0; i < b; i++) {\n\t\tres2 *= a;\n\t}\n\treturn res2;\n}\n\nbool solve(string U) {\n\tbool RES = true;\n\tstring V = \"\";\n\tstring V1 = \"\", V2 = \"\";\n\tstring W1 = \"\", W2 = \"\";\n\n\tfor (int i = 0; i < U.size(); i++) {\n\t\tif (U[i] == 'T') {\n\t\t\tV += '1';\n\t\t\tgoto E;\n\t\t}\n\t\telse if (U[i] == '>') {\n\t\t\t//nanimo shinai.\n\t\t\tgoto E;\n\t\t}\n\t\telse if (U[i] == 'F') {\n\t\t\tV += '0';\n\t\t\tgoto E;\n\t\t}\n\t\telse if (i < U.size() - 1) {\n\t\t\tif (U.substr(i, 2) == \"->\") {\n\t\t\t\tV += '&';\n\t\t\t\tgoto E;\n\t\t\t}\n\t\t}\n\t\tV += U[i];\n\tE:;\n\t}\n\n\tint cnt1 = 0;\n\tfor (int i = 0; i < V.size(); i++) {\n\t\tif (V[i] == '=') {\n\t\t\tcnt1 = 1;\n\t\t}\n\t\telse if (cnt1 == 0) {\n\t\t\tV1 += V[i];\n\t\t}\n\t\telse if (cnt1 == 1) {\n\t\t\tV2 += V[i];\n\t\t}\n\t}\n\n\tint pass1 = 0;\n\twhile (pass1 < V1.size()) {\n\t\tif (V1[pass1] == '-') {\n\t\t\tint cnt2 = 0;\n\t\t\twhile (V1[pass1] == '-') {\n\t\t\t\tcnt2++;\n\t\t\t\tpass1++;\n\t\t\t}\n\t\t\tif (cnt2 % 2 == 1) {\n\t\t\t\tW1 += '(';\n\t\t\t\tW1 += '-';\n\t\t\t\tW1 += V1[pass1];\n\t\t\t\tW1 += ')';\n\t\t\t}\n\t\t\telse {\n\t\t\t\tW1 += V1[pass1];\n\t\t\t}\n\t\t\tpass1++;\n\t\t}\n\t\tif (pass1 < V1.size()) {\n\t\t\tW1 += V1[pass1];\n\t\t\tpass1++;\n\t\t}\n\t}\n\n\tpass1 = 0;\n\twhile (pass1 < V2.size()) {\n\t\tif (V2[pass1] == '-') {\n\t\t\tint cnt2 = 0;\n\t\t\twhile (V2[pass1] == '-') {\n\t\t\t\tcnt2++;\n\t\t\t\tpass1++;\n\t\t\t}\n\t\t\tif (cnt2 % 2 == 1) {\n\t\t\t\tW2 += '(';\n\t\t\t\tW2 += '-';\n\t\t\t\tW2 += V2[pass1];\n\t\t\t\tW2 += ')';\n\t\t\t}\n\t\t\telse {\n\t\t\t\tW2 += V2[pass1];\n\t\t\t}\n\t\t\tpass1++;\n\t\t}\n\t\tif (pass1 < V2.size()) {\n\t\t\tW2 += V2[pass1];\n\t\t\tpass1++;\n\t\t}\n\t}\n\n\tstring X1 = \"\", X2 = \"\";\n\n\tfor (int i = 0; i < power(2, MAX_CH); i++) {\n\t\tX1 = \"\"; X2 = \"\";\n\t\tfor (int j = 0; j < MAX_CH; j++) {\n\t\t\tint a1 = (i / power(2, j)) % 2;\n\t\t\tTR[j] = a1;\n\t\t}\n\n\t\tfor (int j = 0; j < W1.size(); j++) {\n\t\t\tfor (int k = 0; k < MAX_CH; k++) {\n\t\t\t\tif (W1[j] == CH[k]) {\n\t\t\t\t\tX1 += NUM[TR[k]];\n\t\t\t\t\tgoto F;\n\t\t\t\t}\n\t\t\t}\n\t\t\tX1 += W1[j];\n\t\tF:;\n\t\t}\n\n\t\tfor (int j = 0; j < W2.size(); j++) {\n\t\t\tfor (int k = 0; k < MAX_CH; k++) {\n\t\t\t\tif (W2[j] == CH[k]) {\n\t\t\t\t\tX2 += NUM[TR[k]];\n\t\t\t\t\tgoto G;\n\t\t\t\t}\n\t\t\t}\n\t\t\tX2 += W2[j];\n\t\tG:;\n\t\t}\n\n\t\tint res_1 = calc(X1);\n\t\tint res_2 = calc(X2);\n\t\tif (res_1 != res_2) {\n\t\t\tRES = false;\n\t\t}\n\t}\n\treturn RES;\n}\n\nint main() {\n\twhile (true) {\n\t\tcin >> S;\n\t\tif (S == \"#\") {\n\t\t\tbreak;\n\t\t}\n\t\tbool res = solve(S);\n\t\tif (res == true) {\n\t\t\tcout << \"YES\" << endl;\n\t\t}\n\t\telse {\n\t\t\tcout << \"NO\" << endl;\n\t\t}\n\t}\n\treturn 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\n\nusing namespace std;\n\nint idx,S;\n\nbool parse(const string &s){\n  if(idx == (int)s.size()) return true;\n  idx++;\n  bool l,r,res;\n  switch(s[idx]){\n  case 'T':\n    return true;\n  case 'F':\n    return false;\n  case '-':\n    return !parse(s);\n  case '(':\n    l = parse(s);\n    idx++;\n    if(s[idx] == '+'){\n      r = parse(s);\n      res = l | r;\n    }else if(s[idx] == '*'){\n      r = parse(s);\n      res = l & r; \n    }else{\n      idx++;\n      r = parse(s);\n      res = !l || (l && r);\n    }\n    idx++;\n    return res;\n  default:\n    return ((S >> (s[idx]-'a')) & 1);\n  }\n}\n\nbool solve(const string &s){\n  int eq = s.find('=');\n  string l = s.substr(0,eq);\n  string r = s.substr(eq+1);\n  for(S = 0 ; S < (1<<11) ; S++){\n    idx = -1;\n    bool ll = parse(l);\n    idx = -1;\n    if(ll != parse(r)){\n      return false;\n    }\n  }\n  return true;\n}\n\nint main(){\n  string s;\n  while(cin >> s, s != \"#\"){\n    cout << (solve(s) ? \"YES\" : \"NO\") << endl;\n  }\n  return 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include <cstdio>\n\n#define N ( 'k' - 'a' + 1 )\n\nusing namespace std;\n\nstatic char * e;\nstatic char   s[ 1024 ];\n\nstatic int v[ N ];\n\nstatic int\nformula (\n  void\n  )\n{\n  int lt, rt;\n\n  switch ( *e )\n  {\n    case 'T':\n      ++e;\n      return ( 1 );\n    case 'F':\n      ++e;\n      return ( 0 );\n    case 'a':\n    case 'b':\n    case 'c':\n    case 'd':\n    case 'e':\n    case 'f':\n    case 'g':\n    case 'h':\n    case 'i':\n    case 'j':\n    case 'k':\n      ++e;\n      return ( v[ e[ -1 ] - 'a' ] );\n    case '-':\n      ++e;\n      return ( !formula ( ) );\n    case '(':\n      ++e;\n      lt = formula ( );\n      switch ( *e )\n      {\n        case '*':\n          ++e;\n          rt = formula ( );\n          ++e;\n          return ( lt && rt );\n        case '+':\n          ++e;\n          rt = formula ( );\n          ++e;\n          return ( lt || rt );\n        case '-':\n          e += 2;\n          rt = formula ( );\n          ++e;\n          return ( !lt || rt );\n      }\n  }\n}\n\nstatic int\nequation (\n  void\n  )\n{\n  const int lt = formula ( );\n\n  ++e;\n  return ( lt == formula ( ) );\n}\n\nstatic int\ntest (\n  const int r\n  )\n{\n  if ( r == N )\n  {\n    e = s;\n    return\n    equation ( );\n  }\n\n  v[ r ] = 0;\n  if ( !test ( r + 1 ) ) return ( 0 );\n  v[ r ] = 1;\n  if ( !test ( r + 1 ) ) return ( 0 );\n\n  return ( 1 );\n}\n\n/** Application main entry point. */\nint\nmain (\n  int     argc,\n  char  * argv[ ]\n  )\n{\n  for ( ; ; )\n  {\n    scanf ( \" %s\", s );\n    if ( *s == '#' ) break ;\n\n    puts ( test ( 0 ) ? \"YES\" : \"NO\" );\n  }\n\n  return ( 0 );\n}"
  },
  {
    "language": "C++",
    "code": "#include <iostream>\n#include <vector>\n#include <algorithm>\n#include <stack>\nusing namespace std;\ntypedef long long int ll;\n\nstring p,q;\nint r;\n\nbool cal(string s,int l){\n    bool no=0;\n    stack<bool> st;\n    stack<char> sc;\n    for(int i=l;i<s.size();i++){\n        if(s[i]==')'){\n            r=i;\n            return st.top();\n        }\n        else if(s[i]=='-'&&s[i+1]!='>'){\n            no^=1;\n        }\n        else if(s[i]=='T'||s[i]=='F'||s[i]=='('){\n            int ii=i;\n            if(s[i]=='('){\n                if(cal(s,i+1)){\n                    s[i]='T';\n                }\n                else{\n                    s[i]='F';\n                }\n                ii=r;\n            }\n            if(no){\n                if(s[i]=='T')s[i]='F';\n                else s[i]='T';\n            }\n            no=0;\n            if(st.size()==0){\n                st.push(s[i]=='T');\n            }\n            else{\n                if(sc.top()=='+'){\n                    bool rr=st.top();\n                    st.pop();\n                    if(rr||s[i]=='T'){\n                        st.push(1);\n                    }\n                    else{\n                        st.push(0);\n                    }\n                }\n                else if(sc.top()=='*'){\n                    bool rr=st.top();\n                    st.pop();\n                    if(rr&&(s[i]=='T')){\n                        st.push(1);\n                    }\n                    else{\n                        st.push(0);\n                    }\n                }\n                else{\n                    bool rr=st.top();\n                    st.pop();\n                    if(rr&&(s[i]=='F')){\n                        st.push(0);\n                    }\n                    else{\n                        st.push(1);\n                    }\n                }\n            }\n            i=ii;\n        }\n        else{\n            sc.push(s[i]);\n            if(s[i]=='-')i++;\n        }\n    }\n    return 0;\n}\n\nbool solve(string s){\n    stack<bool> st;\n    bool no=0;\n    for(int i=0;i<s.size();i++){\n        if(s[i]=='('){\n            bool p=cal(s,i+1);\n            if(no){\n                p^=1;\n                no=0;\n            }\n            i=r;\n            st.push(p);\n        }\n        else if(s[i]=='-')no^=1;\n        else{\n            if(no){\n                if(s[i]=='T')s[i]='F';\n                else s[i]='T';\n            }\n            st.push(s[i]=='T');\n        }\n    }\n    return st.top();\n}\n\nint main(){\n    string s,t;\n    while(cin >> s,s!=\"#\"){\n        bool ok=1;\n        for(int i=0;i<s.size();i++){\n            if(s[i]=='='){\n                t=s.substr(i+1);\n                s=s.substr(0,i);\n                break;\n            }\n        }\n        for(int i=0;i<(1<<11);i++){\n            p=s; q=t;\n            for(int j=0;j<p.size();j++){\n                if('a'<=p[j]&&p[j]<='k'){\n                    if((i>>(p[j]-'a'))&1){\n                        p[j]='T';\n                    }\n                    else{\n                        p[j]='F';\n                    }\n                }\n            }\n            for(int j=0;j<q.size();j++){\n                if('a'<=q[j]&&q[j]<='k'){\n                    if((i>>(q[j]-'a'))&1){\n                        q[j]='T';\n                    }\n                    else{\n                        q[j]='F';\n                    }\n                }\n            }\n            if(solve(p)!=solve(q))ok=0;\n        }\n        if(ok)printf(\"YES\\n\");\n        else printf(\"NO\\n\");\n    }\n}\n\n"
  },
  {
    "language": "C++",
    "code": "/*\n<equation> ::= <formula> \"=\" <formula>\n<formula>  ::= \"T\" | \"F\" |\n\"a\" | \"b\" | \"c\" | \"d\" | \"e\" | \"f\" |\n\"g\" | \"h\" | \"i\" | \"j\" | \"k\" |\n\"-\" <formula> |\n\"(\" <formula> \"*\" <formula> \")\" |\n\"(\" <formula> \"+\" <formula> \")\" |\n\"(\" <formula> \"->\" <formula> \")\"\n*/\n\n#include <iostream>\n#include <stdio.h>\n#include <vector>\n#include <string>\n#include <algorithm>\n\nusing namespace std;\n\n#define F 0\n#define T !F\n\nvector <int> a(11);\n\nint equation(string& s, int& i);\nint formula(string& s, int& i);\n\nint main(){\n\twhile(1){\n\t\tstring str;\n\t\tcin >> str;\n\t\tif(str == \"#\")\n\t\t\tbreak;\n\t\t\n\t\tint ans = T;\n\t\tfor(int bit = 0; bit < 2048; bit++){\n\t\t\tfor(int i = 0; i < 11; i++){\n\t\t\t\tif(bit >> i & 1)\n\t\t\t\t\ta[i] = T;\n\t\t\t\telse\n\t\t\t\t\ta[i] = F;\n\t\t\t}\n\t\t\tint j = 0;\n\t\t\tint result = equation(str, j);\n\t\t\tif(result == F)\n\t\t\t\tans = F;\n\t\t}\n\t\t\n\t\tif(ans == T)\n\t\t\tcout << \"YES\" << endl;\n\t\telse\n\t\t\tcout << \"NO\" << endl;\n\t}\n\t\n\t\n\treturn 0;\n}\n\nint equation(string& s, int& i){\n\tint val = formula(s, i);\n\ti++;\n\tint val2 = formula(s, i);\n\t\n\tif(val == T && val2 == T || val == F && val2 == F)\n\t\treturn T;\n\telse\n\t\treturn F;\n}\n\nint formula(string& s, int& i){\n\tif(s[i] == 'a'){\n\t\ti++;\n\t\treturn a[0];\n\t}\n\telse if(s[i] == 'b'){\n\t\ti++;\n\t\treturn a[1];\n\t}\n\telse if(s[i] == 'c'){\n\t\ti++;\n\t\treturn a[2];\n\t}\n\telse if(s[i] == 'd'){\n\t\ti++;\n\t\treturn a[3];\n\t}\n\telse if(s[i] == 'e'){\n\t\ti++;\n\t\treturn a[4];\n\t}\n\telse if(s[i] == 'f'){\n\t\ti++;\n\t\treturn a[5];\n\t}\n\telse if(s[i] == 'g'){\n\t\ti++;\n\t\treturn a[6];\n\t}\n\telse if(s[i] == 'h'){\n\t\ti++;\n\t\treturn a[7];\n\t}\n\telse if(s[i] == 'i'){\n\t\ti++;\n\t\treturn a[8];\n\t}\n\telse if(s[i] == 'j'){\n\t\ti++;\n\t\treturn a[9];\n\t}\n\telse if(s[i] == 'k'){\n\t\ti++;\n\t\treturn a[10];\n\t}\n\telse if(s[i] == 'T'){\n\t\ti++;\n\t\treturn T;\n\t}\n\telse if(s[i] == 'F'){\n\t\ti++;\n\t\treturn F;\n\t}\n\telse if(s[i] == '-'){\n\t\ti++;\n\t\tint val = formula(s, i);\n\t\treturn !val;\n\t}\n\telse{\n\t\ti++;\n\t\tint val = formula(s, i);\n\t\tchar op = s[i];\n\t\tif(op == '-')\n\t\t\ti += 2;\n\t\telse\n\t\t\ti++;\n\t\tint val2 = formula(s, i);\n\t\t\n\t\ti++;\n\t\tif(op == '*')\n\t\t\treturn val && val2;\n\t\telse if(op == '+')\n\t\t\treturn val || val2;\n\t\telse{\n\t\t\tif(val == T && val2 == F)\n\t\t\t\treturn F;\n\t\t\telse\n\t\t\t\treturn T;\n\t\t}\n\t}\n}"
  },
  {
    "language": "C++",
    "code": "#include <cstdio>\n#include <cstdlib>\n#include <cmath>\n#include <climits>\n#include <cfloat>\n#include <map>\n#include <utility>\n#include <ctime>\n#include <set>\n#include <iostream>\n#include <memory>\n#include <string>\n#include <vector>\n#include <algorithm>\n#include <functional>\n#include <sstream>\n#include <complex>\n#include <stack>\n#include <queue>\n#include <cstring>\n#include <numeric>\n#include <cassert>\nusing namespace std;\nstatic const double EPS = 1e-10;\ntypedef long long ll;\n#define rep(i,n) for(int i=0;i<n;i++)\n#define rev(i,n) for(int i=n-1;i>=0;i--)\n#define all(a) a.begin(),a.end()\n#define mp(a,b) make_pair(a,b)\n#define pb(a) push_back(a)\n#define SS stringstream\n#define DBG1(a) rep(_X,sz(a)){printf(\"%d \",a[_X]);}puts(\"\");\n#define DBG2(a) rep(_X,sz(a)){rep(_Y,sz(a[_X]))printf(\"%d \",a[_X][_Y]);puts(\"\");}\n#define bitcount(b) __builtin_popcount(b)\n#define EACH(i,c) for(typeof((c).begin()) i=(c).begin(); i!=(c).end(); ++i)\n\n#define delete(a,n) a.erase(remove(all(a),n),a.end())\ntemplate<typename T, typename S> vector<T>& operator<<(vector<T>& a, S b) { a.push_back(b); return a; }\ntemplate<typename T> void operator>>(vector<T>& a, int b) {while(b--)if(!a.empty())a.pop_back();}\nbool isprime(int n){ if(n<2)return false;  for(int i=2;i*i<=n;i++)if(n%i==0)return false;  return true;} \nll b_pow(ll x,ll n){return n ? b_pow(x*x,n/2)*(n%2?x:1) : 1ll;}\nstring itos(int n){stringstream ss;ss << n;return ss.str();}\n\nint val[128];\n\nstring ln;\nint pos;\n\nint fm();\n\nint eq(){\n\tint A = fm();\n\tpos++;\n\tint B = fm();\n\treturn A == B;\n}\nint fm(){\n\tif( ln[pos] == 'T'){ pos++; return 1; }\n\tif( ln[pos] == 'F'){ pos++; return 0; }\n\tif( 'a' <= ln[pos] && ln[pos] <= 'k'){ pos++; return val[ln[pos]]; }\n\tif( ln[pos] == '-' ){ pos++;return !fm(); }\n\tif( ln[pos] == '('){\n\t\tpos++;\n\t\tint A = fm();\n\t\tif( ln[pos] == '*'){pos++; A = A & fm();}\n\t\telse if(ln[pos] == '+'){pos++; A = A | fm();}\n\t\telse if(ln[pos] == '-'){\n\t\t\tpos += 2;\n\t\t\tA = !A | fm();\n\t\t}\n\t\tpos++;\n\t\treturn A;\n\t}\n}\n\n\nint main(){\n\twhile(cin >> ln && ln != \"#\" ){\n\t\tint ok = 1;\n\t\tfor(int i = 0 ; i < (1<<11) ; i++){\n\t\t\tfor(int j = 0 ; j < 11 ; j++) val[j+'a'] = i>>j&1;\n\t\t\tpos = 0;\n\t\t\tok &= eq();\n\t\t\t\n\t\t}\n\t\tcout << (ok?\"YES\":\"NO\") << endl;\n\t}\n}"
  },
  {
    "language": "C++",
    "code": "#include<iostream>\n#include<vector>\n#include<string>\n#include<algorithm>\nusing namespace std;\n\n#define MAX_NUM 2\n#define MAX_CH 10\n#define MAX_N 1200\n\nstring S, T;\nchar NUM[MAX_NUM + 1] = \"01\";\nchar CH[MAX_CH + 1] = \"abcdefghij\";\nint TR[MAX_CH];\n\nint calc(string Y) {\n\treturn true;\n}\n\nint power(int a, int b) {\n\tint res2 = 1;\n\tfor (int i = 0; i < b; i++) {\n\t\tres2 *= a;\n\t}\n\treturn res2;\n}\n\nbool solve(string U) {\n\tbool RES = true;\n\tstring V = \"\";\n\tstring V1 = \"\", V2 = \"\";\n\tstring W1 = \"\", W2 = \"\";\n\n\tfor (int i = 0; i < U.size(); i++) {\n\t\tif (U[i] == 'T') {\n\t\t\tV += '1';\n\t\t\tgoto E;\n\t\t}\n\t\tif (U[i] == 'F') {\n\t\t\tV += '0';\n\t\t\tgoto E;\n\t\t}\n\t\tif (i < U.size() - 1) {\n\t\t\tif (U.substr(i, 2) == \"->\") {\n\t\t\t\tV += '&';\n\t\t\t\ti++;\n\t\t\t\tgoto E;\n\t\t\t}\n\t\t}\n\t\tV += U[i];\n\tE:;\n\t}\n\n\tint cnt1 = 0;\n\tfor (int i = 0; i < V.size(); i++) {\n\t\tif (V[i] == '=') {\n\t\t\tcnt1 = 1;\n\t\t}\n\t\telse if (cnt1 == 0) {\n\t\t\tV1 += V[i];\n\t\t}\n\t\telse if (cnt1 == 1) {\n\t\t\tV2 += V[i];\n\t\t}\n\t}\n\n\tint pass1 = 0;\n\twhile (pass1 < V1.size()) {\n\t\tif (V1[pass1] == '-') {\n\t\t\tint cnt2 = 0;\n\t\t\twhile (V1[pass1] == '-') {\n\t\t\t\tcnt2++;\n\t\t\t\tpass1++;\n\t\t\t}\n\t\t\tif (cnt2 % 2 == 1) {\n\t\t\t\tW1 += '(';\n\t\t\t\tW1 += '-';\n\t\t\t\tW1 += V1[pass1];\n\t\t\t\tW1 += ')';\n\t\t\t}\n\t\t\telse {\n\t\t\t\tW1 += V1[pass1];\n\t\t\t}\n\t\t\tpass1++;\n\t\t}\n\t\tW1 += V1[pass1];\n\t\tpass1++;\n\t}\n\n\tpass1 = 0;\n\twhile (pass1 < V2.size()) {\n\t\tif (V2[pass1] == '-') {\n\t\t\tint cnt2 = 0;\n\t\t\twhile (V2[pass1] == '-') {\n\t\t\t\tcnt2++;\n\t\t\t\tpass1++;\n\t\t\t}\n\t\t\tif (cnt2 % 2 == 1) {\n\t\t\t\tW2 += '(';\n\t\t\t\tW2 += '-';\n\t\t\t\tW2 += V2[pass1];\n\t\t\t\tW2 += ')';\n\t\t\t}\n\t\t\telse {\n\t\t\t\tW2 += V2[pass1];\n\t\t\t}\n\t\t\tpass1++;\n\t\t}\n\t\tW2 += V2[pass1];\n\t\tpass1++;\n\t}\n\n\tstring X1 = \"\", X2 = \"\";\n\n\tfor (int i = 0; i < power(2, MAX_NUM); i++) {\n\t\tX1 = \"\"; X2 = \"\";\n\t\tfor (int j = 0; j < MAX_NUM; j++) {\n\t\t\tint a1 = (i / power(2, j)) % 2;\n\t\t\tTR[j] = a1;\n\t\t}\n\n\t\tfor (int j = 0; j < V1.size(); j++) {\n\t\t\tfor (int k = 0; k < MAX_NUM; k++) {\n\t\t\t\tif (W1[j] == CH[k]) {\n\t\t\t\t\tX1 += NUM[TR[j]];\n\t\t\t\t\tgoto F;\n\t\t\t\t}\n\t\t\t}\n\t\t\tX1 += W1[j];\n\t\tF:;\n\t\t}\n\n\t\tfor (int j = 0; j < V2.size(); j++) {\n\t\t\tfor (int k = 0; k < MAX_NUM; k++) {\n\t\t\t\tif (W2[j] == CH[k]) {\n\t\t\t\t\tX2 += NUM[TR[j]];\n\t\t\t\t\tgoto G;\n\t\t\t\t}\n\t\t\t}\n\t\t\tX2 += W1[j];\n\t\tG:;\n\t\t}\n\n\t\tint res_1 = calc(X1);\n\t\tint res_2 = calc(X2);\n\t\tif (res_1 != res_2) {\n\t\t\tRES = false;\n\t\t}\n\t}\n\treturn RES;\n}\n\nint main() {\n\twhile (true) {\n\t\tcin >> S;\n\t\tif (S == \"#\") {\n\t\t\tbreak;\n\t\t}\n\t\tbool res = solve(S);\n\t\tif (res == true) {\n\t\t\tcout << \"YES\" << endl;\n\t\t}\n\t\telse {\n\t\t\tcout << \"NO\" << endl;\n\t\t}\n\t}\n\treturn 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include <iostream>\n#include <vector>\n#include <string>\n#include <algorithm>\nusing namespace std;\n\nint c;\nbool a[11];\n\nbool f(const string& s) {\n\tif(s[c] == '(') {\n\t\tc++;\n\t\tbool v1 = f(s);\n\t\tchar op = s[c++];\n\t\tif(op == '-') c++;\n\t\tbool v2 = f(s);\n\t\tc++;\n\t\tif(op == '+') return v1 | v2;\n\t\tif(op == '*') return v1 & v2;\n\t\tif(op == '-') return !(v1 & !v2);\n\t}\n\n\tif(s[c] == 'T') {\n\t\tc++;\n\t\treturn true;\n\t}\n\tif(s[c] == 'F') {\n\t\tc++;\n\t\treturn false;\n\t}\n\tif(s[c] == '-') {\n\t\tc++;\n\t\treturn !f(s);\n\t}\n\tif('a' <= s[c] && s[c] <= 'k') {\n\t\tbool v = a[s[c] - 'a'];\n\t\tc++;\n\t\treturn v;\n\t}\n\tcout << \"error\" << s << \"at \" << c << endl;\n\texit(1);\n}\n\nbool solve(string s1, string s2) {\n\tfor(int i = 0; i < (1 << 11); i++) {\n\t\tfor(int j = 0; j < 11; j++) {\n\t\t\ta[i] = (i & (1 << j)) > 0;\n\t\t}\n\t\t//cout << i << \" \" << s1 + \" \" << s2 << endl;\n\t\tc = 0;\n\t\tbool res1 = f(s1);\n\t\tc = 0;\n\t\tbool res2 = f(s2);\n\n\t\tif(res1 != res2) return false;\n\t}\n\n\treturn true;\n}\n\nint main() {\n\tcin.tie(0);\n\tios::sync_with_stdio(false);\n\tstring s, s1, s2;\n\twhile(cin >> s, s != \"#\") {\n\t\tint idx = s.find('=');\n\t\ts1 = s.substr(0, idx), s2 = s.substr(idx + 1, s.size() - (idx + 1));\n\t\tcout << (solve(s1, s2) ? \"YES\" : \"NO\") << endl;\n\t}\n}"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\nusing namespace std;\n\nint vars;\nint pos;\nstring str;\nbool formula() {\n  if(str[pos] == 'T') { pos++; return true; }\n  if(str[pos] == 'F') { pos++; return false; }\n  if(isalpha(str[pos])) {\n    return (vars>>(str[pos++]-'a') & 1);\n  }\n  if(str[pos] == '-') {\n    pos ++;\n    return !formula();\n  }\n  if(str[pos] == '(') {\n    pos ++;\n    int f = formula();\n    bool ret;\n    if(str[pos] == '*') {\n      pos++;\n      ret = formula() && f;\n    }\n    else if(str[pos] == '+') {\n      pos++;\n      ret = formula() || f;\n    }\n    else if(str[pos] == '>') {\n      pos++;\n      ret = f<=formula();\n    }\n    pos ++;\n    return ret;\n  }\n}\n\nint main() {\n  while(cin>>str && str!=\"#\") {\n    \n    int arw = str.find(\"->\");\n    while(arw!=(int)string::npos) {\n      str.replace(arw, 2, \">\");\n      arw = str.find(\"->\", arw+1);\n    }\n    \n    bool ok = true;\n    for(vars=0;vars<(1<<11);vars++) {\n      pos = 0; bool fs = formula();\n      pos ++;\n      if(fs != formula()) { ok = false; break; }\n    }\n    if(ok) {\n      cout << \"YES\" << endl;\n    }\n    else {\n      cout << \"NO\" << endl;\n    }\n  }\n  return 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include <iostream>\n#include <string>\n#include <algorithm>\nusing namespace std;\n#define rep(i,n) for(int i=0;i<n;i++)\n\nint it;\n\nbool solve(string str)\n{\n\tif (str[it] == '(') {\n\t\tit++;\n\t\tbool flag1 = solve(str);\n\t\t\n\t\tif (str[it] == '*') {\n\t\t\tit++;\n\t\t\tbool flag2 = solve(str);\n\t\t\tit++;\n\t\t\treturn flag1&&flag2;\n\t\t}\n\t\telse if (str[it] == '+') {\n\t\t\tit++;\n\t\t\tbool flag2 = solve(str);\n\t\t\tit++;\n\t\t\treturn flag1 | flag2;\n\t\t}\n\t\telse {\n\t\t\tit++;\n\t\t\tit++;\n\t\t\tbool flag2 = solve(str);\n\t\t\tit++;\n\t\t\treturn (!flag1) | flag2;\n\t\t}\n\t}\n\telse if (str[it] == '-') {\n\t\tit++;\n\t\treturn !solve(str);\n\t}\n\telse if (str[it] == 'T') {\n\t\tit++;\n\t\treturn true;\n\t}\n\telse if (str[it] == 'F') {\n\t\tit++;\n\t\treturn false;\n\t}\n}\n\nint main()\n{\n\twhile (true) {\n\t\tstring str;\n\n\t\tcin >> str;\n\n\t\tif (str == \"#\") {\n\t\t\tbreak;\n\t\t}\n\n\t\tint str_size = str.size();\n\t\tbool flag = true;\n\t\tint equalpos;\n\n\t\trep(i, str.size()) {\n\t\t\tif (str[i] == '=') {\n\t\t\t\tequalpos = i;\n\t\t\t}\n\t\t}\n\n\t\trep(i, 1 << 11) {\n\t\t\tstring temp = str;\n\n\t\t\trep(j, str_size) {\n\t\t\t\tif (temp[j] >= 'a'&&temp[j] <= 'k') {\n\t\t\t\t\tif ((i >> (temp[j] - 'a')) % 2 == 0) {\n\t\t\t\t\t\ttemp[j] = 'F';\n\t\t\t\t\t}\n\t\t\t\t\telse {\n\t\t\t\t\t\ttemp[j] = 'T';\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t}\n\n\t\t\tit = 0;\n\t\t\tstring temp1 = temp.substr(0, equalpos);\n\t\t\tbool flag1 = solve(temp1);\n\t\t\tit = 0;\n\t\t\tstring temp2 = temp.substr(equalpos + 1);\n\t\t\tbool flag2 = solve(temp2);\n\n\t\t\tif (flag1 != flag2) {\n\t\t\t\tflag = false;\n\t\t\t\tbreak;\n\t\t\t}\n\t\t}\n\n\t\tif (flag == true) {\n\t\t\tcout << \"YES\" << endl;\n\t\t}\n\t\telse {\n\t\t\tcout << \"NO\" << endl;\n\t\t}\n\t}\n\n\treturn 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include <iostream>\n#include <stdio.h>\n#include <vector>\n#include <string>\n#include <cmath>\n#include <algorithm>\n#include <queue>\n#include <map>\n#include <stack>\n#include <bitset>\n#include <set>\n \nusing namespace std;\n \nint var[11];\n \nint solve();\nint getVal(int &itr, const string &form);\n \nint main(void) {\n \n\twhile (solve()){}\n \n\treturn 0;\n \n}\n \nint solve() {\n \n\t//\tinput\n\tstring eq,exp[2];\n\tcin >> eq;\n \n\t//\tthe end of dataset\n\tif (eq == \"#\") { return 0; }\n \n\tint sep = eq.find(\"=\");\n \n\t\t//\tlfs\n\t\texp[0] = eq.substr(0, sep);\n\t\t//\trhs\n\t\texp[1] = eq.substr(sep+1, string::npos);\n \n\t//\tbrute force\n\tbool isEqual = true;\n\tfor (int i = 0; i < (1 << 12); i++) {\n \n\t\tfor (int j = 0; j < 11; j++) {\n\t\t\tif (i & (1 << j)) {\n\t\t\t\tvar[j] = 1;\n\t\t\t}\n\t\t\telse {\n\t\t\t\tvar[j] = 0;\n\t\t\t}\n\t\t}\n \n\t\tint itr[2] = { -1, -1};\n \n\t\tint rhs, lhs;\n\t\tlhs = getVal(itr[0], exp[0]);\n\t\trhs = getVal(itr[1], exp[1]);\n\t\t/*\n\t\tbitset<20> b(i);\n\t\tcout << b << endl;\n\t\tcout << lhs << \" \" << rhs << endl;\n\t\tcout << endl;\n\t\t*/\n\t\tisEqual &= ( lhs == rhs );\n \n\t}\n \n\t//\toutput\n \n\tif (isEqual) {\n\t\tcout << \"YES\" << endl;\n\t}\n\telse {\n\t\tcout << \"NO\" << endl;\n\t}\n \n \n\treturn 1;\n}\n \nint getVal(int &itr, const string &form) {\n \n\t//\tformula????§£???\n\t++itr;\n\tif (form[itr] == 'T') { return 1; }\n\tif (form[itr] == 'F') { return 0; }\n\tif ('a' <= form[itr] && form[itr] <= 'k') { return var[form[itr]-'a']; }\n \n\t// operator -\n\tif (form[itr] == '-' && form[itr+1] != '>' ) {\n\t\treturn 1 - getVal(itr, form);\n\t}\n \n\tif (form[itr] == '(') {\n \n\t\t//\tbinary operator\n\t\tint lhs, rhs;\n\t\tchar ope;\n \n\t\tlhs = getVal(itr, form);\n \n\t\titr++;\n\t\tope = form[itr];\n\t\tif (ope == '-') { itr++; }\n \n \n\t\trhs = getVal(itr, form);\n \n\t\t//\t')'\n\t\titr++;\n \n\t\tif (ope == '+') {\n\t\t\treturn max(lhs, rhs);\n\t\t}\n\t\telse if (ope == '*') {\n\t\t\treturn min(lhs, rhs);\n\t\t}\n\t\telse if (ope == '-') {\n\t\t\tif (lhs == 1 && rhs == 0) { return 0; }\n\t\t\telse return 1;\n\t\t}\n \n\t}\n \n\treturn 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include<iostream>\n#include<string>\n#include<stack>\n#include<queue>\n\n#define rep(i) for(int i=0; i < 2; ++i)\n\nusing namespace std;\n\nstring gp( string siki )\n{\n\tstring res = \"\";\n\tstack<char> st;\n\tint len = siki.size();\n\tfor(int i=0; i < len; ++i) {\n\t\tint m = siki[i];\n\t\tswitch(m) {\n\t\tcase '(':\n\t\tcase '+':\n\t\tcase '*':\n\t\t\tst.push(m);\n\t\t\tbreak;\n\t\tcase ')':\n\t\t\twhile(true){\n\t\t\t\tchar cc = st.top(); st.pop();\n\t\t\t\tif(cc =='(') break;\n\t\t\t\tres += cc;\n\t\t\t}\n\t\t\tbreak;\n\t\tcase '-': {\n\t\t\tint j = 0;\n\t\t\tswitch(siki[i+1]) {\n\t\t\tcase '-':\n\t\t\t\tfor(j=0; siki[i+j] == '-'; j++);\n\t\t\t\tif(j & 1) {\n\t\t\t\t\ti += j - 2;\n\t\t\t\t}\n\t\t\t\telse {\n\t\t\t\t\ti += j - 1;\n\t\t\t\t}\n\t\t\t\tbreak;\n\t\t\tcase '(':\n\t\t\t\tst.push('-');\n\t\t\t\tbreak;\n\t\t\tcase '>':\n\t\t\t\tst.push('/');\n\t\t\t\ti++;\n\t\t\t\tbreak;\n\t\t\tdefault:\n\t\t\t\tif(siki[i+1] == 'T') {\n\t\t\t\t\tres += 'y';\n\t\t\t\t}\n\t\t\t\telse if(siki[i+1] == 'F') {\n\t\t\t\t\tres += 'z';\n\t\t\t\t}\n\t\t\t\telse\n\t\t\t\t\tres += siki[i+1];\n\t\t\t\tres += '-';\n\t\t\t\ti++;\n\t\t\t\tbreak;\n\t\t\t}\n\t\t}\n\t\t\tbreak;\n\t\tdefault:\n\t\t\tif(m == 'T') {\n\t\t\t\tres += 'y';\n\t\t\t}\n\t\t\telse if(m == 'F') {\n\t\t\t\tres += 'z';\n\t\t\t}\n\t\t\telse\n\t\t\t\tres += m;\n\t\t\tbreak;\n\t\t}\n\t}\n\t\n\twhile(!st.empty()){\n\t\tres += st.top(); st.pop();\n\t}\n\treturn res;\n}\n\nbool val[26];\n\nbool solve( string siki )\n{\n\tint len = siki.size();\n\tstack<char> st;\n\tfor(int i=0; i < len; ++i) {\n\t\tchar m = siki[i];\n\t\tchar a, b;\n\t\tswitch(m) {\n\t\tcase '+':\n\t\t\ta = st.top(); st.pop();\n\t\t\tb = st.top(); st.pop();\n\t\t\tif(val[a-'a'] | val[b-'a']) {\n\t\t\t\tst.push('y');\n\t\t\t}else\n\t\t\t\tst.push('z');\n\t\t\tbreak;\n\t\tcase '-':\n\t\t\ta = st.top(); st.pop();\n\t\t\tif(val[a-'a']) {\n\t\t\t\tst.push('z');\n\t\t\t}else\n\t\t\t\tst.push('y');\n\t\t\tbreak;\n\t\tcase '*':\n\t\t\ta = st.top(); st.pop();\n\t\t\tb = st.top(); st.pop();\n\t\t\tif(val[a-'a'] & val[b-'a']) {\n\t\t\t\tst.push('y');\n\t\t\t}else\n\t\t\t\tst.push('z');\n\t\t\tbreak;\n\t\tcase '/':\n\t\t\tb = st.top(); st.pop();\n\t\t\ta = st.top(); st.pop();\n\t\t\tif(val[a-'a'] && !val[b-'a']) {\n\t\t\t\tst.push('z');\n\t\t\t}else\n\t\t\t\tst.push('y');\n\t\t\tbreak;\n\t\tdefault:\n\t\t\tst.push(m);\n\t\t\tbreak;\n\t\t}\n\t}\n\treturn val[st.top()-'a'];\n}\n\nint main(){\n\tstring input;\n\twhile(cin >> input, input != \"#\") {\n\t\tstring sa = \"\", sb = \"\";\n\t\tint len = input.size();\n\t\tbool hit = true;\n\t\tfor(int i=0; i < len; ++i) {\n\t\t\tif(input[i] == '='){\n\t\t\t\thit = !hit;\n\t\t\t\tcontinue;\n\t\t\t}\n\t\t\tif(hit) {\n\t\t\t\tsa += input[i];\n\t\t\t}\n\t\t\telse {\n\t\t\t\tsb += input[i];\n\t\t\t}\n\t\t}\n\t\tval[24] = true;\n\t\tval[25] = false;\n\t\tbool ans = true;\n\t\tsa = gp(sa);\n\t\tsb = gp(sb);\n\t\t//cout << sa << endl;\n\t\t//cout << sb << endl;\n\t\trep(a) {\n\t\t\tval[0] = a;\n\t\t\trep(b) {\n\t\t\t\tval[1] = b;\n\t\t\t\trep(c){\n\t\t\t\t\tval[2] = c;\n\t\t\t\t\trep(d){\n\t\t\t\t\t\tval[3] = d;\n\t\t\t\t\t\trep(e){\n\t\t\t\t\t\t\tval[4] = e;\n\t\t\t\t\t\t\trep(f){\n\t\t\t\t\t\t\t\tval[5] = f;\n\t\t\t\t\t\t\t\trep(g){\n\t\t\t\t\t\t\t\t\tval[6] = g;\n\t\t\t\t\t\t\t\t\trep(h){\n\t\t\t\t\t\t\t\t\t\tval[7] = h;\n\t\t\t\t\t\t\t\t\t\trep(i){\n\t\t\t\t\t\t\t\t\t\t\tval[8] = i;\n\t\t\t\t\t\t\t\t\t\t\trep(j){\n\t\t\t\t\t\t\t\t\t\t\t\tval[9] = j;\n\t\t\t\t\t\t\t\t\t\t\t\trep(k){\n\t\t\t\t\t\t\t\t\t\t\t\t\tval[10] = k;\n\t\t\t\t\t\t\t\t\t\t\t\t\tif(solve(sa) != solve(sb)) {\n\t\t\t\t\t\t\t\t\t\t\t\t\t\t//cout << a << \" \" << b << endl;\n\t\t\t\t\t\t\t\t\t\t\t\t\t\t//cout << solve(sa) << \" \" << solve(sb) << endl;\n\t\t\t\t\t\t\t\t\t\t\t\t\t\tans = false;\n\t\t\t\t\t\t\t\t\t\t\t\t\t\tgoto END;\n\t\t\t\t\t\t\t\t\t\t\t\t\t}\n\t\t\t\t\t\t\t\t\t\t\t\t}\n\t\t\t\t\t\t\t\t\t\t\t}\n\t\t\t\t\t\t\t\t\t\t}\n\t\t\t\t\t\t\t\t\t}\n\t\t\t\t\t\t\t\t}\n\t\t\t\t\t\t\t}\n\t\t\t\t\t\t}\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t}\n\t\t}\nEND: ;\n\t\tif(ans)\n\t\t\tcout << \"YES\" << endl;\n\t\telse\n\t\t\tcout << \"NO\" << endl;\n\t}\n\treturn 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\n#define int long long\n#define main signed main()\nusing namespace std;\n\n// clang-format off\nnamespace PCon {\n  template<typename Obj>\n  struct Parsed {\n    bool success; Obj obj; int pos;\n    Parsed(Obj obj, int pos) : success(true), obj(obj), pos(pos) { }\n    Parsed(int pos) : success(false), pos(pos) { }\n  };\n\n  template<typename Obj>\n  using Parser = function<Parsed<Obj>(string, int)>;\n\n  Parser<string> token(const string &s) {\n    return [&](string target, int pos) {\n      int n = s.size();\n      if (target.size() < n) return Parsed<string>(pos);\n      if (target.substr(pos, n) == s) return Parsed<string>(s, pos + n);\n      return Parsed<string>(pos);\n    };\n  }\n\n  template<typename Obj>\n  Parser<vector<Obj>> many(const Parser<Obj> &p) {\n    return [&](string target, int pos) {\n      vector<Obj> result;\n      for (;;) {\n        Parsed<Obj> parsed = p(target, pos);\n        if (!parsed.success) break;\n        result.push_back(parsed.obj);\n        pos = parsed.pos;\n      }\n      return Parsed<vector<Obj>>(result, pos);\n    };\n  }\n\n  template<typename Obj>\n  Parser<Obj> operator||(const Parser<Obj> &p1, const Parser<Obj> &p2) {\n    return [&](string target, int pos) {\n      Parsed<Obj> r = p1(target, pos);\n      if (r.success) return r;\n      r = p2(target, pos);\n      if (r.success) return r;\n      return Parsed<Obj>(pos);\n    };\n  }\n\n  template<typename Obj1, typename Obj2>\n  Parser<pair<Obj1, Obj2>> operator+(const Parser<Obj1> &p1, const Parser<Obj2> &p2) {\n    return [&](string target, int pos) {\n      pair<Obj1, Obj2> p;\n      Parsed<Obj1> r1 = p1(target, pos);\n      if (!r1.success) return Parsed<pair<Obj1, Obj2>>(pos);\n      Parsed<Obj2> r2 = p2(target, r1.pos);\n      if (!r2.success) return Parsed<pair<Obj1, Obj2>>(pos);\n      return Parsed<pair<Obj1, Obj2>>(make_pair(r1.obj, r2.obj), r2.pos);\n    };\n  }\n\n  template<typename Obj1, typename Obj2>\n  Parser<Obj2> fmap(Parser<Obj1> p, function<Obj2(Obj1)> f) {\n    return [&](string target, int pos) {\n      Parsed<Obj1> r = p(target, pos);\n      if (!r.success) return Parsed<Obj2>(r.pos);\n      return Parsed<Obj2>(f(r.obj), r.pos);\n    };\n  }\n\n  Parser<char> oneOf(string s) {\n    return [&](string target, int pos) {\n      set<char> m;\n      for (char &c : s) m.insert(c);\n      char c = target[pos];\n      return m.count(c) ? Parsed<char>(c, pos + 1) : Parsed<char>(pos);\n    };\n  }\n}\n// clang-format on\n\nusing namespace PCon;\n\nstruct Formula {\n  string op;\n  char val;\n  vector<Formula> fs;\n  Formula() {\n  }\n  Formula(char val)\n    : val(val) {\n  }\n  Formula(string op, vector<Formula> fs)\n    : op(op), fs(fs) {\n  }\n};\n\nstruct Equation {\n  Formula left, right;\n  Equation() {\n  }\n  Equation(Formula left, Formula right)\n    : left(left), right(right) {\n  }\n};\n\ntemplate<typename T, typename X>\nusing P  = pair<T, X>;\nusing PB = P<P<P<P<string, Formula>, string>, Formula>, string>;\n\nmain {\n  Parser<Formula> formulaP;\n  Parser<Formula> andP = fmap<PB, Formula>(token(\"(\") + formulaP + token(\"*\") + formulaP + token(\")\"), [](PB x) {\n    return Formula(\"*\", {x.first.first.first.second, x.first.second});\n  });\n  Parser<Formula> orP = fmap<PB, Formula>(token(\"(\") + formulaP + token(\"+\") + formulaP + token(\")\"), [](PB x) {\n    return Formula(\"+\", {x.first.first.first.second, x.first.second});\n  });\n  Parser<Formula> impP = fmap<PB, Formula>(token(\"(\") + formulaP + token(\"->\") + formulaP + token(\")\"), [](PB x) {\n    return Formula(\"->\", {x.first.first.first.second, x.first.second});\n  });\n  Parser<Formula> notP = fmap<P<string, Formula>, Formula>(token(\"-\") + formulaP, [](P<string, Formula> x) {\n    return Formula(\"-\", {x.second});\n  });\n  Parser<Formula> valP = fmap<char, Formula>(oneOf(\"abcdefghijkTF\"), [](char c) { return Formula(c); });\n\n  formulaP = andP || orP || impP || notP || valP;\n\n  Parser<Equation> equationP = fmap<P<P<Formula, string>, Formula>, Equation>(formulaP + token(\"=\") + formulaP, [](P<P<Formula, string>, Formula> x) {\n    return Equation(x.first.first, x.second);\n  });\n\n  string s;\n  while (cin >> s, s != \"#\") {\n    Parsed<Equation> r = equationP(s, 0);\n    bool isValid       = true;\n    for (int i = 0; i < 1 << 11; i++) {\n      auto toBool = [&](char c) -> bool {\n        if (c == 'T') return true;\n        if (c == 'F') return false;\n        return i >> (c - 'a') & 1;\n      };\n      function<bool(Formula)> eval = [&](Formula f) {\n        switch (f.fs.size()) {\n          case 0: return toBool(f.val);\n          case 1: return !eval(f.fs[0]);\n          case 2:\n            if (f.op == \"*\") return eval(f.fs[0]) && eval(f.fs[1]);\n            if (f.op == \"+\") return eval(f.fs[0]) || eval(f.fs[1]);\n            if (f.op == \"->\") return !eval(f.fs[0]) || eval(f.fs[1]);\n        }\n      };\n      isValid &= eval(r.obj.left) == eval(r.obj.right);\n    }\n    cout << (isValid ? \"YES\" : \"NO\") << endl;\n  }\n}"
  },
  {
    "language": "C++",
    "code": "#include<iostream>\n#include<string>\n#include<map>\nusing namespace std;\nint vals;\npair<string, string> equation(string str){\n  int i=0;\n  for(i=0;i<(int)str.length();i++){\n    if(str[i]=='=')break;\n  }\n  return make_pair(str.substr(0, i),str.substr(i+1));\n}\nbool formula(string str){\n  if(str[0]=='-'){\n    return !formula(str.substr(1));\n  }if(isalpha(str[0])){\n    return\n      (str[0] == 'T')?true\n      :(str[0] == 'F')?false\n      :((vals >> (str[0]-'a')) & 1);\n  }else if(str[0]=='('){\n    int tcur=1, opc=-1, op=-1, depth=0;\n\n    while(tcur<(int)str.length()){\n      if(str[tcur]=='('){\n        depth++;\n      }else if(str[tcur]==')'){\n        depth--;\n      }else if(depth==0){\n        if(str[tcur]=='+'){\n          op=1;opc=tcur;\n          break;\n        }else if(str[tcur]=='*'){\n          op=2;opc=tcur;\n          break;\n        }else if(str[tcur]=='-'\n                 &&tcur+1<(int)str.length()\n                 &&str[tcur+1]=='>'){\n          tcur++;\n          op=3;opc=tcur;\n          break;\n        }\n        \n      }\n        tcur++;\n    }\n    switch(op){\n    case -1:\n      return formula(str.substr(1,str.length()-2));\n    case 1:\n      return formula(str.substr(1,opc-1))\n        ||formula(str.substr(opc+1, str.length()-1 - (opc+1)));\n    case 2:\n      return formula(str.substr(1,opc-1))\n        &&formula(str.substr(opc+1, str.length()-1 - (opc+1)));\n    case 3:\n      return !(formula(str.substr(1,opc-2))\n               &&!formula(str.substr(opc+1, str.length()-1 - (opc+1))));\n    default:\n      cout<<\"ERROR!\"<<endl;\n      return false;\n    }\n  }\n}\nint main(){\n  string str;\n  pair<string, string> eq;\n  while(cin>>str&&str!=\"#\"){\n    eq=equation(str);\n    int flg=1;\n    for(vals=0;vals< 1<<10;vals++){\n      if(formula(eq.first) != formula(eq.second)) flg=0;\n    }\n    (flg)?cout<<\"YES\"<<endl:cout<<\"NO\"<<endl;\n  }\n  return 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include<cctype>\n#include<cstdio>\n#include<vector>\n#include<cstring>\n#include<algorithm>\n\n#define rep(i,n) for(int i=0;i<(n);i++)\n\nusing namespace std;\n\nint pos;\nchar s[1024];\n\nbool formula(){\n\tif(s[pos]=='T'){\n\t\tpos++;\n\t\treturn true;\n\t}\n\telse if(s[pos]=='F'){\n\t\tpos++;\n\t\treturn false;\n\t}\n\telse if(s[pos]=='-'){\n\t\tpos++;\n\t\treturn !formula();\n\t}\n\telse if(s[pos]=='('){\n\t\tpos++;\n\t\tbool a=formula();\n\t\tchar op=s[pos];\n\t\tif(op=='-') pos+=2;\n\t\telse        pos++;\n\t\tbool b=formula();\n\t\tpos++;\n\t\tswitch(op){\n\t\t\tcase '*': return a&&b;\n\t\t\tcase '+': return a||b;\n\t\t\tcase '-': return !a||b;\n\t\t}\n\t\t// error\n\t}\n}\n\nbool parse(const char *s){\n\tstrcpy(::s,s);\n\tpos=0;\n\treturn formula();\n}\n\nint main(){\n\tfor(char s[1024];scanf(\"%s\",s),s[0]!='#';){\n\t\tint n=strlen(s);\n\t\tvector<char> C;\n\t\tint eq;\n\t\trep(i,n){\n\t\t\tif(s[i]=='=') eq=i;\n\t\t\tif(islower(s[i])) C.push_back(s[i]);\n\t\t}\n\t\tsort(C.begin(),C.end());\n\t\tC.erase(unique(C.begin(),C.end()),C.end());\n\n\t\tbool ok=true;\n\t\trep(S,1<<C.size()){\n\t\t\tchar tmp[1024];\n\t\t\tstrcpy(tmp,s);\n\n\t\t\t// T or F を代入\n\t\t\trep(i,n) if(islower(s[i])) {\n\t\t\t\tint pos=find(C.begin(),C.end(),s[i])-C.begin();\n\t\t\t\ts[i]=(S&1<<pos?'T':'F');\n\t\t\t}\n\n\t\t\tif(parse(s)!=parse(s+eq+1)) ok=false;\n\n\t\t\tstrcpy(s,tmp);\n\t\t}\n\t\tputs(ok?\"YES\":\"NO\");\n\t}\n\n\treturn 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include <cstdio>\n#include <iostream>\n#include <cmath>\n#include <ctype.h>\n#include <string> \n#include <sstream>\n#include <iostream>\n#include <algorithm>\n#include <cstdlib>\n#include <map>\n#include <queue>\n#include <utility>\n#include <vector>\n#include <set>\n#include <list>\n#include <cstring>\n#include <stack>\n   \nusing namespace std;\n\nint main()\n{\n    string s;\n    while(1){\n        cin >> s;\n        if(s == \"#\") break;\n        char en[12] = {'a', 'b', 'c', 'd', 'e', 'f', 'g', 'h', 'i', 'j', 'k'};\n        bool ok = true;\n        for(int i = 0; i < (2 << 11); i++){\n            map<char, char> chara;\n            int nowi = i;\n            chara['1'] = '1';\n            chara['0'] = '0';\n            chara['T'] = '1';\n            chara['F'] = '0';\n            chara['('] = '(';\n            chara['='] = '=';\n            for(int j = 11; j >= 0; j--){\n                chara[en[j]] = (nowi / (int)pow(2, j)) + '0';\n                nowi = nowi % (int)pow(2, j);\n                // cout << chara[j];\n            }\n            stack<char> st;\n            for(int j = 0; j < s.length(); j++){\n                if(s[j] == ')'){\n                    char y = st.top();\n                    st.pop();\n                    if(st.top() == '-'){\n                        st.pop();\n                        if(y == '0') y = '1';\n                        else y = '0';\n                    }\n                    char op = st.top();\n                    if(op == '>') st.pop();\n                    st.pop();\n                    char x = st.top();\n                    x = chara[x];\n                    if(st.top() == '-'){\n                        st.pop();\n                        if(x == '0') x = '1';\n                        else x = '0';\n                    }\n                    st.pop();\n                    // cout << x << \" \" << op << \" \" << y << endl;\n                    if(op == '*'){\n                        if(x == '1' && y == '1') st.push('1');\n                        else st.push('0');\n                    } else if(op == '+'){\n                        if(x == '0' && y == '0') st.push('0');\n                        else st.push('1');\n                    } else if(op == '>'){\n                        if(x == '1' && y == '0') st.push('0');\n                        else st.push('1');\n                    }\n                } else {\n                    st.push(chara[s[j]]);\n                }\n            }\n            char e2 = st.top();\n            st.pop();\n            if(st.top() == '-'){\n                st.pop();\n                if(e2 == '1') e2 = '0';\n                else e2 = '1';\n            }\n            st.pop();\n            char e1 = st.top();\n            st.pop();\n            if(!st.empty()){\n                st.pop();\n                if(e1 == '1') e1 = '0';\n                else e1 = '1';\n            }\n            // cout << st.size() << endl;\n            if(e1 != e2){\n                ok = false;\n                break;\n            }\n        }\n        if(ok) cout << \"YES\" << endl;\n        else cout << \"NO\" << endl;\n    }\n    return 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include<bits/stdc++.h>\nusing namespace std;\n#define r(i,n) for(int i=0;i<n;i++)\nvector<char>v;\nint flag,p,cnt;\nstring s[2],t[2],q;\nmap<char,int>m;\nbool b[2][100000];\nint bnf1();\nint num(){\n  int res=0;\n  if(s[cnt][p]=='(')p++,res=bnf1(),p++;\n  else if(s[cnt][p]=='-')p++,res=(bnf1()+1)%2;\n  else{\n    if(isdigit(s[cnt][p]))res=s[cnt][p++]-'0';\n  }\n  return res;\n}\nint bnf1(){\n  int res=num();\n  while(s[cnt][p]=='+'||s[cnt][p]=='*'||s[cnt][p]=='>'){\n    int pp=p++;\n    if(s[cnt][pp]=='+')res=res|num();\n    if(s[cnt][pp]=='*')res=res&num();\n    if(s[cnt][pp]=='>'){\n      if(res&&!num())res=0;\n      else res=1;\n    }\n  }\n  return res;\n}\nvoid dfs(int d){\n  if(d==v.size()){\n    r(i,2)\n    r(i,2)s[i]=t[i];\n    r(i,2)r(j,s[i].size()){\n      if(isalpha(s[i][j])){\n        s[i][j]=m[s[i][j]]+'0';\n        if(b[i][j])s[i][j]=((s[i][j]-'0'+1)%2)+'0';\n      }\n    }\n    cnt=p=0;\n   // r(i,2)cout<<s[i]<<endl;\n    int ans1=bnf1();\n    cnt=1;p=0;\n    int ans2=bnf1();\n    if(ans1!=ans2)flag++;\n  }\n  else{\n    m[v[d]]=1;\n    dfs(d+1);\n    m[v[d]]=0;\n    dfs(d+1);\n  }\n}\nint main(){\n  while(cin>>q,q!=\"#\"){\n    r(i,2)t[i]=\"\";\n    flag=0;\n    memset(b,0,sizeof(b));\n    m.clear();\n    v.clear();\n    int c1=0;\n    r(i,(int)q.size()-1){\n      if(q[i]=='T')q[i]='1';\n      if(q[i]=='F')q[i]='0';\n      if(q[i]=='-'&&q[i+1]=='>'){\n        q.erase(q.begin()+i);\n        i--;\n      }\n    }\n    set<char>st;\n    r(i,q.size()){\n      if(isalpha(q[i])&&!st.count(q[i])){\n        v.push_back(q[i]);\n      }\n    }\n    r(i,q.size()){\n      if(q[i]=='=')c1++;\n      else t[c1]+=q[i];\n    }\n    r(i,2)r(j,(int)t[i].size()-1){\n      if(t[i][j]=='-'&&isalpha(t[i][j+1])){\n        t[i].erase(t[i].begin()+j);\n        b[i][j]=1;\n        j--;\n      }\n    }\n    //r(i,2)cout<<t[i]<<endl;\n    dfs(0);\n    cout<<(flag?\"NO\":\"YES\")<<endl;\n  }\n}"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\ntypedef long long LL;\n#define SORT(c) sort((c).begin(),(c).end())\n\n#define FOR(i,a,b) for(int i=(a);i<(b);++i)\n#define REP(i,n)  FOR(i,0,n)\n\nusing namespace std;\nstring s;\nint bits,ind;\nbool cs(void)\n{\n  if(s[ind]=='T'){\n    ++ind;\n    return true;\n  }else if(s[ind]=='F'){\n    ++ind;\n    return false;\n  }else if(s[ind]=='-'){\n    ++ind;\n    return !cs();\n  }else if(s[ind]=='('){\n    ++ind;\n    bool x=cs(),y;\n    if(s[ind]=='*'){\n      ++ind;\n      y=cs();\n      x=x&&y;\n    }else if(s[ind]=='+'){\n      ++ind;\n      y=cs();\n      x=x||y;\n    }else if(s[ind]=='-'){\n      ++ind;\n      ++ind;\n      y=cs();\n      x=!x||y;\n    }\n    ++ind;\n    return x;\n  }else{\n    bool tmp=(bool)(bits&(1<<(s[ind]-'a')));\n    ++ind;\n    return tmp;\n  }\n}\nint main(void)\n{\n  for(;;){\n    cin >> s;\n    if(s==\"#\") return 0;\n    bool flag=false;\n    REP(i,(1<<11)){\n      bits=i,ind=0;\n      bool tmp=cs();\n      ++ind;\n      flag=flag||(tmp^cs());\n    }\n    cout << (flag?\"NO\":\"YES\") << endl;\n  }\n}"
  },
  {
    "language": "C++",
    "code": "#include<iostream>\n#include<vector>\n#include<string>\n#include<algorithm>\n#define all(c) c.begin(),c.end()\n#define uni(c) c.erase(unique(c.begin(),c.end()),c.end())\n#define pb push_back\nusing namespace std;\n \nint expr(string& s, int& i);\nint term(string& s, int& i);\nint factor(string& s, int& i);\nint number(string& s, int& i);\n \n \nint expr(string& s, int& i) {\n  int val = factor(s, i);\n  while(s[i] == '+' || s[i] == '-'|| s[i]=='*') {\n    char op = s[i];\n    i++;\n    if(s[i]=='>'){\n        i++;\n        int val2 = factor(s, i);\n        if(val==1&&val2==0){\n            val=0;\n        }else{\n            val=1;\n        }\n    }else{\n         \n      int val2 = factor(s, i);\n        if (op == '+') \n            val |= val2;\n        else if(op=='*')\n            val *= val2;\n        //cout<<\"   \"<<val<<\" \"<<val2<<endl;\n    }\n     \n  }\n  return val;\n}\nint factor(string& s, int& i) {\n    int flag=0;\n    if(s[i]=='-'){\n        flag=1;\n        i++;\n    }\n    if (isdigit(s[i])){\n        if(flag)\n            return flag^number(s, i);\n            return number(s,i);\n    }\n \n  // ここで構文が正しければ s[i] == '(' となる\n  i++; // '('を読み飛ばす\n  int ret = expr(s, i);\n  i++; // ')'を読み飛ばす\n    if(flag)\n    return flag^ret;\n    return ret;\n}\n \nint number(string& s, int& i) {\n  int n = s[i++] - '0';\n  while(isdigit(s[i])) n = n*10 + s[i++] - '0';\n  return n;\n}\n \nint main(){\n    string s;\n    while(cin>>s,s!=\"#\"){\n        int eq=0;\n        string a,b;\n        for(int i=0;i<s.size();i++){\n            if(s[i]=='T')\n            s[i]='1';\n            else if(s[i]=='F')\n            s[i]='0';\n        }\n        for(;s[eq]!='=';eq++);\n        a=s.substr(0,eq),b=s.substr(eq+1,s.size()-eq);\n        //cout<<a<<\" \"<<b<<endl;\n        vector<char> ap;\n         \n        for(int i=0;i<s.size();i++){\n            if(isalpha(s[i]))\n                ap.pb(s[i]);\n        }\n        sort(all(ap));\n        uni(ap);\n        bool flag=true;\n        for(int i=0;i<(1<<ap.size());i++){\n            string x=a,y=b;\n            for(int j=0;j<ap.size();j++){\n                char c=ap[j];\n                bool wh=false;\n                if((1<<j)&i)\n                    wh=true;\n                for(int k=0;k<x.size();k++){\n                    if(x[k]==c){\n                        if(wh)\n                            x[k]='1';\n                        else\n                            x[k]='0';\n                    }\n                }\n                for(int k=0;k<y.size();k++){\n                    if(y[k]==c){\n                        if(wh)\n                            y[k]='1';\n                        else\n                            y[k]='0';\n                    }\n                }\n            }\n             \n            int p=0,q=0;\n            if(expr(x,p)!=expr(y,q)){\n                cout<<\"NO\"<<endl;\n                flag=false;\n                break;\n            }\n             \n        }\n        if(flag)\n            cout<<\"YES\"<<endl;\n    }\n    return 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include<iostream>\n#include<cstdio>\n#include<cstdlib>\n#include<stdexcept>\n#include<cmath>\n#include<memory>\n#include<algorithm>\n#include<cstring>\n#include<ctime>\n#include<deque>\n#include<sstream>\n#include<iomanip>\n#include<sstream>\n#include<vector>\n#include<queue>\n#include<stack>\n#include<string>\n#include<climits>\n#include<map>\n#include<set>\n#include<list>\n#include<cassert>\n#include<deque>\n#define REP(i,s,n) for(int i=s;i<n;i++)\n#define rep(i,n) REP(i,0,n)\n#define INF 1<<27\n#define all(n) n.begin(),n.end()\n#define insert(a,b,c,d) PP(P(a,b),P(c,d))\n#define F first\n#define S second\n#define pb push_back\n#define pf push_front\n#define LIM 100000\nusing namespace std;\ntypedef pair<int,int> P;\ntypedef pair<P,P> PP;\ntypedef long long ll;\ntypedef unsigned long long ull;\n\n\nclass Parsing{\nprivate:\n  string parse;\n  int pos;\n  map<char,bool> val;\npublic:\n\n  Parsing(string s,bool a,bool b,bool c,bool d,bool e,bool f,bool g,bool h,bool i,bool j,bool k){\n    parse = s;\n    pos = 0;\n    val['a'] = a,val['b'] = b,val['c'] = c,val['d'] = d,val['e'] = e,val['f'] = f,val['g'] = g,val['h'] = h,val['i'] = i,val['j'] = j,val['k'] = k;\n  }\n\n  bool fact(){\n    if(parse[pos] == '('){\n      pos++;\n      bool p = expression();\n      pos++;\n      return p;\n    }else if(parse[pos] == '-'){\n      //cout << \"parse[\" << pos << \"] = \" << parse[pos] << endl;\n      pos++;\n      bool p = fact();\n    \n      //cout << \"- pre = \" << p << endl; \n      return p?false:true;\n    }else{\n      //cout << \"parse[\" << pos << \"] = \" << parse[pos] << \" = \"<< val[parse[pos]] << endl;\n      if('a' <= parse[pos] && parse[pos] <= 'k'){\n\tpos++;\n\treturn val[parse[pos-1]];\n      }      \n      else if(parse[pos] == 'T' || parse[pos] == 'F'){\n\t++pos;\n\treturn parse[pos-1] == 'T'?1:0;\n      }\n      assert(false);\n    }\n  }\n  \n  bool term(){\n    bool p = fact();\n   \n    return p;\n  }\n  \n  bool expression(){\n\n    bool p = term();\n   \n    while(parse[pos] == '+' || parse[pos] == '*' || parse.substr(pos,2) == \"->\" ){\n      //if(parse[pos] == '+'){pos++;p+=term();}\n      //else {pos++;p-=term();}\n      if(parse[pos] == '+'){\n\tpos++;\n\tbool q = term();\n\t//cout << p << \" + \"<< q << \" = \";\n\tp = p|q;\n\t//cout << p << endl;\n      }\n      else if(parse[pos] == '*'){\n\tpos++;\n\tbool q = term();\n\t//cout << p << \" * \" << q << \" = \";\n\tp = p&q;\n\t//cout << p << endl;\n      }\n      else if(parse.substr(pos,2) == \"->\"){\n\tpos+=2;\n\tbool q = term();\n\t//cout << p << \" -> \" << q << \" = \";\n\tif(p && !q)p = false;\n\telse p = true;\n\t//cout << p << endl;\n      }\n     \n\n    }\n    return p;\n  } \n  \n\n};\n\n\n\n\n\n\nint main(){\n\n  while(true){\n    string s1,s2,s;\n    cin >> s;\n    if(s[0] == '#')break;\n    for(int i=0;i<s.length();i++){\n      if(s[i] == '='){\n\ts1 = s.substr(0,i);\n\ts2 = s.substr(i+1,s.length()-i-1);\n\tbreak;\n      }\n    }\n    //cout << \"s1 = \" << s1 << \",s2 = \" << s2 << endl;\n\n    bool yes = true;\n    rep(a,2){    \n      rep(b,2){\n\trep(c,2){\n\t  rep(d,2){\n\t    rep(e,2){\n\t      rep(f,2){\n\t\trep(g,2){\n\t\t  rep(h,2){\n\t\t    rep(i,2){\n\t\t      rep(j,2){\n\t\t\trep(k,2){\n\t\t\t  Parsing par1(s1,a,b,c,d,e,f,g,h,i,j,k);\n\t\t\t  Parsing par2(s2,a,b,c,d,e,f,g,h,i,j,k);\n\t\t\t  if(par1.expression() != par2.expression() ){\n\t\t\t    yes = false;\n\t\t\t    break;\n\t\t\t  }\n\t\t\t}\n\t\t\tif(!yes)break;\n\t\t      }\n\t\t      if(!yes)break;\n\t\t    }\n\t\t    if(!yes)break;\n\t\t  }\n\t\t  if(!yes)break;\n\t\t}\n\t\tif(!yes)break;\n\t      }\n\t      if(!yes)break;\n\t    }\n\t    if(!yes)break;\n\t  }\n\t  if(!yes)break;\n\t}\n\tif(!yes)break;\n      }\n      if(!yes)break;\n    }\n    yes?cout << \"YES\" << endl:cout << \"NO\" << endl;\n  }\nreturn 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include <iostream>\n#include <string>\n#include <sstream>\n#include <cctype>\nusing namespace std;\n\nistringstream iss;\nint a;\n\nbool parse() {\n  char ch;\n  iss >> ch;\n  \n  if( isalpha(ch) ) {\n    if(ch == 'T') return true;\n    if(ch == 'F') return false;\n    return ( a >> (ch-'a') ) & 1;\n  }\n\n  if( ch == '-' ) {\n    return !parse();\n  }\n\n  bool f1 = parse();\n  iss >> ch;\n  if( ch == '-' ) iss.ignore();\n  bool f2 = parse();\n  iss.ignore();\n  if( ch == '*' ) return f1 && f2;\n  if( ch == '+' ) return f1 || f2;\n  return f1 <= f2;\n}\n\nbool solve(const string &input) {\n  for( a = 1 << 11; a--; ) {\n    iss.clear();\n    iss.str(input);\n    \n    bool left = parse();\n    iss.ignore();\n    bool right = parse();\n    if( left != right ) return false;\n  }\n  return true;\n}\n\nint main() {\n  string s;\n  while(cin >> s, s[0] != '#' ) {\n    cout << (solve(s) ? \"YES\" : \"NO\") << endl;\n  }\n  return 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\nusing namespace std;\n\nint pos, var;\nstring s;\nint formula() {\n  pos++;\n  if(s==\"T\") return 1;\n  if(s==\"F\") return 0;\n  if(isalpha(s[pos])) return var>>(s[pos]-'a') & 1;\n  if(s[pos]=='-') return !formula();\n  int f1=formula();\n  pos++; char op=s[pos]; if(op=='-') pos++;\n  int f2=formula();\n  if(op=='+') return f1&&f2;\n  if(op=='*') return f1||f2;\n  if(op=='-') return f1<=f2;\n}\n\nint main() {\n  while(cin >> s) {\n    if(s==\"#\") break;\n    bool ok=true;\n    for(var=0;var<(1<<11);var++) {\n      pos=-1; int lhs=formula();\n      pos++;\n      if(lhs!=formula()) { ok=false; break; }\n    }\n    cout << (ok ? \"YES\":\"NO\") << endl;\n  }\n  return 0;\n}"
  },
  {
    "language": "C++",
    "code": "#define _USE_MATH_DEFINES\n#define INF 0x3f3f3f3f\n\n#include <iostream>\n#include <cstdio>\n#include <sstream>\n#include <cmath>\n#include <cstdlib>\n#include <algorithm>\n#include <queue>\n#include <stack>\n#include <limits>\n#include <map>\n#include <string>\n#include <cstring>\n#include <set>\n#include <deque>\n#include <bitset>\n#include <list>\n#include <cctype>\n#include <utility>\n  \nusing namespace std;\n  \ntypedef long long ll;\ntypedef pair <int,int> P;\ntypedef pair <int,P> PP;\n  \nstatic const double EPS = 1e-8;\n  \nstatic const int tx[] = {0,1,0,-1};\nstatic const int ty[] = {-1,0,1,0};\n\nstruct ParseInfo {\n  int pos;\n  bool val;\n};\n\nset<char> char_set;\nbool char_table[256];\n\nParseInfo parse_formula(int pos, const string& str){\n\n  if('a' <= str[pos] && str[pos] <= 'k'){\n    bool val = false;\n    ParseInfo pi = {pos+1,val};\n    return pi;\n  }\n\n  else if(str[pos] == 'T'){\n    bool val = true;\n    ParseInfo pi = {pos+1,val};\n    return pi;\n  }\n\n  else if(str[pos] == 'F'){\n    bool val = false;\n    ParseInfo pi = {pos+1,val};\n    return pi;\n  }\n\n  else if(str[pos] == '-'){\n    ParseInfo pi = parse_formula(pos+1,str);\n    pi.val = ~pi.val;\n    return pi;\n  }\n\n  else if(str[pos] == '('){\n    ParseInfo pi1 = parse_formula(pos+1,str);\n    if(str[pi1.pos] == '*'){\n      ParseInfo pi2 = parse_formula(pi1.pos+1,str);\n      pi2.val = (pi1.val && pi2.val);\n      \n      //skip ')'\n      pi2.pos++;\n      return pi2;\n    }\n    else if(str[pi1.pos] == '+'){\n      ParseInfo pi2 = parse_formula(pi1.pos+1,str);\n      pi2.val = (pi1.val || pi2.val);\n\n      //skip ')'\n      pi2.pos++;\n      return pi2;\n    }\n    else if(str[pi1.pos] == '-'\n\t    && str[pi1.pos+1] == '>'){\n      ParseInfo pi2 = parse_formula(pi1.pos+2,str);\n      pi2.val = (~pi1.val || pi2.val);\n\n      //skip ')'\n      pi2.pos++;\n      return pi2;\n    }\n  }\n}\n\nParseInfo parse_equation(int pos, const string& str){\n  ParseInfo pi1 = parse_formula(pos,str);\n  \n  //skip '='\n  ParseInfo pi2 = parse_formula(pi1.pos+1,str);\n  pi2.val = (pi1.val == pi2.val) ? true : false;\n  return pi2;\n}\n\n\nint main(){\n  string str;\n  while(cin >> str){\n    if(str == \"#\") break;\n\n\n    for(int i=0;i<str.size();i++){\n      if('a' <= str[i] && str[i] <= 'k'){\n\tchar_set.insert(str[i]);\n      }\n    }\n\n\n    bool isok = true;\n    for(int S=0;S<=(1<<char_set.size())-1;S++){\n      int idx = 0;\n      for(set<char>::iterator it = char_set.begin();\n\t  it != char_set.end();\n\t  it++){\n\tchar_table[*it] = (S & (1<<idx));\n\tidx++;\n      }\n      ParseInfo pi = parse_equation(0,str);\n      if(!pi.val) isok = false;\n    }\n    printf(\"%s\\n\",isok ? \"YES\" : \"NO\");\n  }\n}"
  },
  {
    "language": "C++",
    "code": "#include <vector>\n#include <iostream>\n#include <utility>\n#include <algorithm>\n#include <string>\n#include <deque>\n#include <queue>\n#include <functional>\n#include <cmath>\n#include <iomanip>\n#include <map>\n#include <numeric>\n#include <list>\n#include <assert.h>\n#include <math.h>\n#include <valarray>\n#include <stdio.h>\n#include <algorithm>\n#include <set>\n#include <complex>\n#include <list>\n\nusing namespace std;\ntypedef long long int LL;\ntypedef pair<long long int, long long int> pii;\ntypedef pair<double, double> pdd;\n\n#define SORT(c) sort((c).begin(),(c).end())\n#define BACKSORT(c) sort((c).begin(),(c).end(),std::greater<LL>())\n#define FOR(i,a,b) for(LL i=(a);i<(b);++i)\n#define REP(i,n)  FOR(i,0,n)\n\nbool equation(string& s, int& i,vector<bool>& v);\nbool formula(string& s, int& i, vector<bool>& v);\n\nbool equation(string& s, int& i, vector<bool>& v) {\n\tbool a = formula(s, i,v);\n\ti++;\n\tbool b = formula(s, i, v);\n\treturn a == b;\n}\n\nbool formula(string& s, int& i, vector<bool>& v) {\n\tif (s[i] == 'T') {\n\t\ti++;\n\t\treturn true;\n\t}\n\telse\n\t\tif (s[i] == 'F') {\n\t\t\ti++;\n\t\t\treturn false;\n\n\t\t}else\n\t\t\tif ('a' <= s[i] && s[i] <= 'k') {\n\t\t\t\tint aa = s[i] - 'a';\n\t\t\t\ti++;\n\t\t\t\treturn v[aa];\n\t\t\t}else\n\t\t\t\tif (s[i] == '-') {\n\t\t\t\t\ti++;\n\t\t\t\t\tbool a = formula(s, i, v);\n\t\t\t\t\treturn !a;\n\t\t\t\t}\n\t\t\t\telse {\n\t\t\t\t\ti++;\n\t\t\t\t\tbool a = formula(s, i, v);\n\t\t\t\t\tchar op = s[i];\n\t\t\t\t\tif (op == '-') {\n\t\t\t\t\t\ti++;\n\t\t\t\t\t}\n\t\t\t\t\ti++;\n\t\t\t\t\tbool b = formula(s, i, v);\n\t\t\t\t\ti++;\n\t\t\t\t\tif (op == '*') {\n\t\t\t\t\t\treturn a&&b;\n\t\t\t\t\t}else\n\t\t\t\t\t\tif (op == '+') {\n\t\t\t\t\t\t\treturn a || b;\n\t\t\t\t\t\t}\n\t\t\t\t\t\telse {\n\t\t\t\t\t\t\treturn (!a) || b;\n\t\t\t\t\t\t}\n\t\t\t\t}\n}\n\n\nint main()\n{\n\twhile (true) {\n\t\tstring ss;\n\t\tcin >> ss;\n\t\tif (ss[0] == '#') { break; }\n\t\tbool flag = true;\n\t\tfor (int j = 0; j < 2048; ++j) {\n\t\t\tint bai = 1;\n\t\t\tvector<bool> v(9999, false);\n\t\t\tfor (int k = 0; k < 11; ++k) {\n\t\t\t\tif (j % (bai * 2) - j % (bai * 1) == 0) {\n\t\t\t\t\tv[k] = false;\n\t\t\t\t}\n\t\t\t\telse {\n\t\t\t\t\tv[k] = true;\n\t\t\t\t}\n\t\t\t}\n\t\t\t\tint index = 0;\n\t\t\t\tif (!equation(ss, index, v)) {\n\t\t\t\t\tflag = false;\n\t\t\t\t\tbreak;\n\t\t\t\t\t}\n\t\t\t\n\t\t}\n\t\tif (flag) {\n\t\t\tcout << \"YES\" << endl;\n\t\t}\n\t\telse {\n\t\t\tcout << \"NO\" << endl;\n\t\t}\n\t}\n\n}"
  },
  {
    "language": "C++",
    "code": "//suhan lee,saitama university\n\n#include <vector>\n#include <list>\n#include <map>\n#include <set>\n#include <stack>\n#include <queue>\n#include <deque>\n#include <algorithm>\n#include <utility>\n#include <functional>\n#include <sstream>\n#include <iostream>\n#include <cstdio>\n#include <cmath>\n#include <cstdlib>\n#include <cctype>\n#include <cstring>\n#include <ctime>\n#include <climits>\n#include <cassert>\n#include <complex>\nusing namespace std;\n\ninline int toInt(string s) {int v; istringstream sin(s);sin>>v;return v;}\ntemplate<class T> inline string toString(T x) {ostringstream sout;sout<<x;return sout.str();}\ntypedef vector<int> vi;\ntypedef vector<vi> vvi;\ntypedef vector<string> vs;\ntypedef pair<int, int> pii;\ntypedef long long ll;\n\n#define ALL(a) (a).begin(),(a).end()\n#define RALL(a) (a).rbegin(),(a).rend()\n#define EXIST(s,e) ((s).find(e)!=(s).end())\n#define rep(i,a,b) for(int i=(a);i<(b);++i)\n#define repn(i,n) for(int i=0;i<n;i++)\n#define EACH(t,i,c) for(t::iterator i=(c).begin(); i!=(c).end(); ++i)\n#define pb push_back \n#define pf push_front\nint alphaset;\nbool equation(string inp,int& i);\nbool formula(string inp,int& i);\nbool alphabet(string inp,int& i);\nbool equation(string inp,int& i){\n  bool right,left;\n  left=formula(inp,i);\n  i++;\n  // cout<<\"i:\"<<i<<endl;\n  right=formula(inp,i);\n  //  cout<<alphaset<<endl<<left<<'='<<right<<endl;\n  return right==left;\n}\nbool formula(string inp,int& i){\n  bool left=alphabet(inp,i);\n  bool right;\n  while(true){\n    if(inp[i]=='+'){\n      right=formula(inp,++i);\n      left=right||left;\n    }\n    else    if(inp[i]=='*'){\n      right=formula(inp,++i);\n      left=right&&left;\n    }\n    else    if(inp[i]=='-'){\n      if(inp[++i]=='>'){\n\tright=formula(inp,++i);\n\tleft=(!left)||right;\n      }\n    }\n    else return left;\n  }\n}\nbool alphabet(string inp,int& i){\n  if(inp[i]=='(')\n    {\n      int out=formula(inp,++i);\n      i++;return out;\n    }\n  else if(inp[i]=='-')\n    return !alphabet(inp,++i);\n  else if(inp[i]=='T'){i++;\n    return true;}\n  else if(inp[i]=='F'){i++;\n    return false;}\n\n  else{\n    //   cout<<inp[i]<<i<<\"  \"<<alphaset<<\"  \"<<\n    //    (alphaset & (1<<(inp[i]-'a'))>0)<<endl;\n    return alphaset & (1<<(inp[i++]-'a'));\n  }\n\n}\n\n\nint main(){\n  while(true){\n    string inp;\n    int i=0;\n    //  cout<<int('a')<<endl<<int('b');\n    cin>>inp;\n    if(inp==\"#\") break;\n    for(alphaset=0;alphaset<(1<<11);alphaset++){\n      i=0;\n      if(equation(inp,i)==false){\n\tcout<<\"NO\"<<endl;\n\tbreak;\n      }\n    }\n    if(alphaset==(1<<11)){\n      cout<<\"YES\"<<endl;\n    }\n  }\n  return 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\n\nusing namespace std;\n\ntypedef string::const_iterator State;\nclass ParseError {};\n\nmap<char, int> mp, mp2;\nState b;\n\nint f(int a, int b) {\n\tif(a == 0) return 1;\n\tif(b == 1) return 1;\n\treturn 0;\n}\n\nint ch(State& begin) {\n\tif(!islower(*begin) && !isupper(*begin)) {cout << *begin; assert(false);}\n\tint ret;\n\tif(*begin == 'T') ret = 1;\n\tif(*begin == 'F') ret = 0;\n\tret = mp2[*begin];\n\tbegin++;\n\treturn ret;\n}\n\nint fomula(State& begin) {\n\t//cout << *begin << endl;\n\tif(islower(*begin) || isupper(*begin)) {return ch(begin);}\n\telse if(*begin == '-') {begin++; return !fomula(begin);}\n\telse if(*begin == '(') {\n\t\tbegin++;\n\t\tint ret1 = fomula(begin);\n\t\tchar op = *begin;\n\t\tbegin++;\n\t\tint ret2 = fomula(begin);\n\t\tbegin++;\n\t\tint ret;\n\t\tif(op == '*') {\n\t\t\tret = ret1&ret2;\n\t\t} else if(op == '+') {\n\t\t\tret = ret1|ret2;\n\t\t} else if(op == '>') {\n\t\t\tret = f(ret1, ret2);\n\t\t} \n\t\treturn ret;\n\t}\n}\n\nint equation(State& begin) {\n\tint ret = fomula(begin), ret2;\n\tif(*begin == '=') begin++, ret2 = fomula(begin);\n\t//cout << \"ret:\" << ret << \" ret2:\" << ret2 << endl;\n\tif(ret == ret2) return 1;\n\treturn 0;\n}\n\nint a[20];\nint main() {\n\twhile(true) {\n\t\tstring t;\n\t\tcin >> t;\n\t\tif(t == \"#\") break;\n\t\tstring s;\n\t\tfor(int i=0; i<t.size(); ++i) {\n\t\t\tif(t[i] != '>') s += t[i];\n\t\t\telse s[s.size()-1] = '>';\n\t\t}\n\t\tint idx = 0;\n\t\tmp.clear();\n\t\tmp2.clear();\n\t\tfor(int i=0; i<s.size(); ++i) {\n\t\t\tif(islower(s[i]) && mp.find(s[i]) == mp.end()) {\n\t\t\t\tmp[s[i]] = idx;\n\t\t\t\ta[idx++] = s[i];\n\t\t\t}\n\t\t}\n\t\t/*for(auto i: mp) {\n\t\t\tcout << i.first << \" \" << i.second << endl;\n\t\t}*/\n\t\t\n\t\tbool flag = true;\n\t\tfor(int i=0; i<(1<<idx); ++i) {\n\t\t\t//cout << \"i:\" << i << endl;\n\t\t\tfor(int j=0; j<idx; ++j) {\n\t\t\t\tif(i >> j & 1) mp2[a[j]] = 1;\n\t\t\t\telse mp2[a[j]] = 0;\n\t\t\t}\n\t\t\t//for(auto j: mp2) cout << j.first << \" \" << j.second << endl;\n\t\t\tState begin = s.begin();\n\t\t\tb = s.begin();\n\t\t\tif(!equation(begin)) flag = false;\n\t\t\t//cout << flag << endl;\n\t\t}\n\t\tif(flag) cout << \"YES\" << endl;\n\t\telse cout << \"NO\" << endl;\n\t}\n\t\n\treturn 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include <iostream>\nusing namespace std;\ntypedef string::const_iterator State;\nstring s;\nbool assign[11];\nbool fom(State& be){\n\tif(*be=='T'){\n\t\tbe++;\n\t\treturn 1;\n\t}\n\tif(*be=='F'){\n\t\tbe++;\n\t\treturn 0;\n\t}\n\tif('a'<= *be && *be <= 'k'){\n\t\tbool x=assign[*be-'a'];\n\t\tbe++;\n\t\treturn x;\n\t}\n\tif(*be=='-'){\n\t\tbe++;\n\t\treturn !fom(be);\n\t}\n\tif(*be=='('){\n\t\tbe++;\n\t\tbool x=fom(be);\n\t\tif(*be=='+'){\n\t\t\tbe++;\n\t\t\tbool y=fom(be);\n\t\t\tbe++;\n\t\t\treturn x || y;\n\t\t}else if(*be=='*'){\n\t\t\tbe++;\n\t\t\tbool y=fom(be);\n\t\t\tbe++;\n\t\t\treturn x && y;\n\t\t}else{\n\t\t\tbe+=2;\n\t\t\tbool y=fom(be);\n\t\t\tbe++;\n\t\t\treturn (!x) || y;\n\t\t}\n\t}\n}\nint main(){\n\twhile(true){\n\t\tcin >> s;\n\t\tif(s[0]=='#') break;\n\t\tbool ok=true;\n\t\tfor(int i=0;i<2048;i++){\n\t\t\tfor(int j=0;j<11;j++) assign[j]=(i>>j)&1;\n\t\t\tState be=s.begin();\n\t\t\tbool x=fom(be);\n\t\t\tbe++;\n\t\t\tbool y=fom(be);\n\t\t\tif(x!=y){\n\t\t\t\tok=false;\n\t\t\t\tbreak;\n\t\t\t}\n\t\t}\n\t\tcout << (ok ? \"YES\\n\" : \"NO\\n\");\n\t}\n}"
  },
  {
    "language": "C++",
    "code": "#include <iostream>\n#include <sstream>\nusing namespace std;\nstring ls, rs;\nint pos;\nstring s;\nint state;\nchar c;\nvoid next(){\n  c = s[pos++];\n}\nbool formula(){\n  next();\n  if(c == '('){\n    bool f, lf = formula();\n    next();\n    if(c == '*') f = (formula() && lf);\n    else if(c == '+') f = ( formula() || lf);\n    else{\n      next();\n      f = (formula() || !lf);\n    }\n    next();\n    return f;\n  }\n  else if(c == 'T') return true;\n  else if(c == 'F') return false;\n  else if(c == '-') return (!formula());\n  else return (1<<(c-'a'))&state;\n}\nbool equation(){\n  for(int i = 0; i < (1 << 11); i++){\n    state = i;\n    pos = 0;\n    bool l = formula();\n    next();\n    bool r = formula();\n    if(l != r)return false;\n  }\n  return true;\n}\nvoid solve(){\n  cout << (equation() ? \"YES\":\"NO\") << endl;  \n}\nint main(){\n  while(cin >> s && s!=\"#\"){\n    solve();\n  }\n  return 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\nusing namespace std;\n\nint pos, var;\nstring s;\nint formula() {\n  pos++;\n  if(s==\"T\") return 1;\n  if(s==\"F\") return 0;\n  if(isalpha(s[pos])) return var>>(s[pos]-'a')&1;\n  if(s[pos]=='-') return !formula();\n  int f1=formula();\n  pos++; char op=s[pos]; if(op=='-') pos++;\n  int f2=formula(); pos++;\n  if(op=='*') return f1&f2;\n  if(op=='+') return f1|f2;\n  if(op=='-') return f1<=f2;\n}\n\nint main() {\n  while(cin >> s) {\n    if(s==\"#\") break;\n    bool ok=true;\n    for(var=0;var<(1<<11);var++) {\n      pos=-1; int lhs=formula();\n      pos++;\n      if(lhs!=formula()) { ok=false; break; }\n    }\n    cout << (ok ? \"YES\":\"NO\") << endl;\n  }\n  return 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include<iostream>\n#include<string>\n#define MAX 11\nusing namespace std;\nbool o;\nvoid rec(string ss){\n  if(!o) return;\n  //cout << s << endl;\n  string s =ss;\n  bool f;\n  int p;\n\n  \n  if(s.find(\"-0\")!=-1){\n    p=s.find(\"-0\");\n    s[p]='1';s[p+1]=' ';\n    f=true;\n  }\n  if(s.find(\"-1\")!=-1){\n    p=s.find(\"-1\");\n    s[p]='0';s[p+1]=' ';\n    f=true;\n  }\n  \n  \n  while(s.find(\"(0*0)\")!=-1){\n    p=s.find(\"(0*0)\");\n    s[p]='0';s[p+1]=' ';s[p+2]=' ';s[p+3]=' ';s[p+4]=' ';\n    f=true;\n  }\n  while(s.find(\"(0*1)\")!=-1){\n    p=s.find(\"(0*1)\");\n    s[p]='0';s[p+1]=' ';s[p+2]=' ';s[p+3]=' ';s[p+4]=' ';\n    f=true;\n  }\n  while(s.find(\"(1*0)\")!=-1){\n    p=s.find(\"(1*0)\");\n    s[p]='0';s[p+1]=' ';s[p+2]=' ';s[p+3]=' ';s[p+4]=' ';\n    f=true;\n  }\n  while(s.find(\"(1*1)\")!=-1){\n    p=s.find(\"(1*1)\");\n    s[p]='1';s[p+1]=' ';s[p+2]=' ';s[p+3]=' ';s[p+4]=' ';\n    f=true;\n  }\n  while(s.find(\"(0+0)\")!=-1){\n    p=s.find(\"(0+0)\");\n    s[p]='0';s[p+1]=' ';s[p+2]=' ';s[p+3]=' ';s[p+4]=' ';\n    f=true;\n  }\n  while(s.find(\"(0+1)\")!=-1){\n    p=s.find(\"(0+1)\");\n    s[p]='1';s[p+1]=' ';s[p+2]=' ';s[p+3]=' ';s[p+4]=' ';\n    f=true;\n  }\n  while(s.find(\"(1+0)\")!=-1){\n    p=s.find(\"(1+0)\");\n    s[p]='1';s[p+1]=' ';s[p+2]=' ';s[p+3]=' ';s[p+4]=' ';\n    f=true;\n  }\n  while(s.find(\"(1+1)\")!=-1){\n    p=s.find(\"(1+1)\");\n    s[p]='1';s[p+1]=' ';s[p+2]=' ';s[p+3]=' ';s[p+4]=' ';\n    f=true;\n  }\n  \n  while(s.find(\"(0->0)\")!=-1){\n    p=s.find(\"(0->0)\");\n    s[p]='1';s[p+1]=' ';s[p+2]=' ';s[p+3]=' ';s[p+4]=' ';s[p+5]=' ';\n    f=true;\n  }\n  while(s.find(\"(0->1)\")!=-1){\n    p=s.find(\"(0->1)\");\n    s[p]='1';s[p+1]=' ';s[p+2]=' ';s[p+3]=' ';s[p+4]=' ';s[p+5]=' ';\n    f=true;\n  }\n  while(s.find(\"(1->0)\")!=-1){\n    p=s.find(\"(1->0)\");\n    s[p]='0';s[p+1]=' ';s[p+2]=' ';s[p+3]=' ';s[p+4]=' ';s[p+5]=' ';\n    f=true;\n  }\n  while(s.find(\"(1->1)\")!=-1){\n    p=s.find(\"(1->1)\");\n    s[p]='1';s[p+1]=' ';s[p+2]=' ';s[p+3]=' ';s[p+4]=' ';s[p+5]=' ';\n    f=true;\n  }\n  \n  if(f){\n    string b;\n    for(int i=0;i<s.size();i++) if(s[i]!=' ') b+=s[i];\n    rec(b);\n  }else{\n    if(s[0]!=s[2]) o=false;\n    return;\n  }\n}\nvoid init(int n,string s){\n  int i,j;\n  for(i=0;i<s.size();i++){\n    for(j=0;j<=MAX;j++){\n      if(s[i]=='a'+j) s[i]='0'+(n>>j&1);\n      if(s[i]=='T') s[i]='1';\n      if(s[i]=='F') s[i]='0';\n    }\n  }\n  rec(s);\n  if(!o) return;\n}\nint main(){\n  string s;\n  while(cin >> s,s!=\"#\"){\n    o=true;\n    int i;\n    for(i=0;i<(1<<MAX);i++)\n      if(o) init(i,s);\n      else break;\n    cout << (o?\"YES\":\"NO\") << endl;\n  }\n  return 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include <iostream>\n#include <vector>\n#include <string>\n#include <algorithm>\nusing namespace std;\n\nint c;\nbool a[11];\n\nbool f(const string& s) {\n\tif (s[c] == '(') {\n\t\tc++;\n\t\tbool v = f(s);\n\t\tif (s[c] == '+') {\n\t\t\tc++;\n\t\t\tv |= f(s);\n\t\t}\n\t\telse if (s[c] == '*') {\n\t\t\tc++;\n\t\t\tv &= f(s);\n\t\t}\n\t\telse {\n\t\t\tc += 2;\n\t\t\tv = !(v & !f(s));\n\t\t}\n\t\tc++; // s[c] == ')'\n\t\treturn v;\n\t}\n\n\tif (s[c] == 'T') {\n\t\tc++;\n\t\treturn true;\n\t}\n\tif (s[c] == 'F') {\n\t\tc++;\n\t\treturn false;\n\t}\n\tif (s[c] == '-') {\n\t\tc++;\n\t\treturn !f(s);\n\t}\n\tif ('a' <= s[c] && s[c] <= 'k') {\n\t\tbool v = a[s[c] - 'a'];\n\t\tc++;\n\t\treturn v;\n\t}\n\tcout << \"error\" << s << \"at \" << c << endl;\n\texit(1);\n}\n\nbool solve(string s1, string s2) {\n\tfor (int i = 0; i < (1 << 11); i++) {\n\t\tfor (int j = 0; j < 11; j++) {\n\t\t\ta[i] = (i & (1 << j)) > 0;\n\t\t}\n\t\t//cout << i << \" \" << s1 + \" \" << s2 << endl;\n\t\tc = 0;\n\t\tbool res1 = f(s1);\n\t\tc = 0;\n\t\tbool res2 = f(s2);\n\n\t\tif (res1 == res2) return true;\n\t}\n\n\treturn false;\n}\n\nint main() {\n\tcin.tie(0);\n\tios::sync_with_stdio(false);\n\tstring s, s1, s2;\n\twhile (cin >> s , s != \"#\") {\n\t\tint idx = s.find('=');\n\t\ts1 = s.substr(0, idx) , s2 = s.substr(idx + 1, s.size() - (idx + 1));\n\t\tcout << (solve(s1, s2) ? \"YES\" : \"NO\") << endl;\n\t}\n}"
  },
  {
    "language": "C++",
    "code": "#include<iostream>\n#include<stack>\nusing namespace std;\n\nstring ans;\nchar con[11];\n\nchar NOT(char a){\n  if(a=='T')return 'F';\n  return 'T';\n}\nchar AND(char a,char b){\n  if(a=='T' && b=='T')return 'T';\n  return 'F';\n}\nchar OR(char a,char b){\n  if(a=='F' && b=='F')return 'F';\n  return 'T';\n}\nchar IMP(char a,char b){\n  if(a=='T' && b=='F')return 'F';\n  return 'T';\n}\n\nchar cal(string s)\n{\n  stack<char> S;\n\n  for(int i=0;i<s.length();i++){\n    if(s[i]==')'){\n      while(!S.empty()){\n\tchar a=S.top();S.pop();\n\tchar b=S.top();S.pop();\n\n        if(b=='('){\n\t  S.push(a);\n\t  break;\n\t}\n\tif(b=='-'){\n\t  S.push(NOT(a));\n\t}\n\tif(b=='+'){\n\t  char c=S.top();S.pop();\n\t  if(S.top()=='-'){\n\t    S.pop();\n\t    c=NOT(c);\n\t  }\n          S.push(OR(c,a));\n\t}\n\tif(b=='*'){\n\t  char c=S.top();S.pop();\n\t  if(S.top()=='-'){\n\t    S.pop();\n\t    c=NOT(c);\n\t  }\n\t  S.push(AND(c,a));\n\t}\n\tif(b=='>'){\n\t  S.pop();\n\t  char c=S.top();S.pop();\n\t  if(S.top()=='-'){\n\t    S.pop();\n\t    c=NOT(c);\n\t  }\n          S.push(IMP(c,a));\n\t}\n      }\t  \n    }\n    else {\n      if('a'<=s[i] && s[i]<='k')S.push(con[(s[i]-'a')]);      \n      else S.push(s[i]);\n    }\n  }\n  //cout<<S.top()<<endl;\n  return S.top();\n}\n\nvoid dfs(string l,string r,int n)\n{\n  \n  if(n==11){\n    char a=cal( '('+l+')' ),b=cal( '('+r+')' );\n    if(a!=b)ans=\"NO\";\n  }\n  else {\n    dfs(l,r,n+1);\n    con[n]='T';\n    dfs(l,r,n+1);\n    con[n]='F';\n  }\n}\n\nint main()\n{\n  string s,l,r;\n\n  while(1){\n    cin>>s;\n    if(s[0]=='#')break;\n    for(int i=0;i<11;i++)con[i]='F';\n    for(int i=0;i<s.length();i++){\n      if(s[i]=='='){\n\tl=s.substr(0,i);\n\tr=s.substr(i+1,s.length());\n      }\n    }\n    ans=\"YES\";\n    dfs(l,r,0);\n    cout<<ans<<endl;\n  }\n  return 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include<iostream>\n#include<vector>\n#include<string>\n#include<algorithm>\n\nusing namespace std;\n\nint now,al;\nstring s;\n\nbool formula(void){\n\t\n\tif(isupper(s[now])){\n\t\tnow++;\n\t\treturn s[now-1]=='T';\n\t}\n\t\n\tif(islower(s[now])){\n\t\tnow++;\n\t\treturn (al>>(s[now-1]-'a'))&1;\n\t}\n\t\n\tif(s[now]=='('){\n\t\tnow++;\n\t\tbool res1=formula();\n\t\t\n\t\tif(s[now]=='*'){\n\t\t\tnow++;\n\t\t\tbool res2=formula();\n\t\t\tif(s[now]==')')now++;\n\t\t\treturn res1&res2;\n\t\t}\n\t\tif(s[now]=='+'){\n\t\t\tnow++;\n\t\t\tbool res2=formula();\n\t\t\tif(s[now]==')')now++;\n\t\t\treturn res1|res2;\n\t\t}\n\t\tif(s[now]=='-' && s[now+1]=='>'){\n\t\t\tnow+=2;\n\t\t\tbool res2=formula();\n\t\t\tif(s[now]==')')now++;\n\t\t\tif(res1==true && res2==false)return false;\n\t\t\treturn true;\n\t\t}\n\t}\n\t\n\tif(s[now]=='-'){\n\t\tnow++;\n\t\tbool res=formula();\n\t\treturn !res;\n\t}\n}\n\nbool equation(void){\n\tbool res1=formula();\n\tnow++;\n\tbool res2=formula();\n\treturn (res1==res2);\n}\n\nint main(void){\n\t\n\twhile(cin >> s,s!=\"#\"){\n\t\tbool fg=true;\n\t\tfor(al=0;al<(1<<11);al++)now=0,fg&=equation();\n\t\tif(fg)cout << \"YES\" << endl;\n\t\telse cout << \"NO\" << endl;\n\t}\n\treturn 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include <string>\n#include <iostream>\nusing namespace std;\nstring s[5];\nbool solve(int l, int r, int e) {\n\tif (s[e][l] == 'T') return true;\n\tif (s[e][l] == 'F') return false;\n\tif (s[e][l] == '-') return !solve(l + 1, r, e);\n\tint d = 0;\n\tfor (int i = l + 1; i < r - 1; i++) {\n\t\tif (s[e][i] == '(') d++;\n\t\tif (s[e][i] == ')') d--;\n\t\tif (s[e][i] == '*') return solve(l + 1, i, e) && solve(i + 1, r - 1, e);\n\t\tif (s[e][i] == '+') return solve(l + 1, i, e) || solve(i + 1, r - 1, e);\n\t\tif (s[e][i] == '-') return !solve(l + 1, i, e) || solve(i + 2, r - 1, e);\n\t}\n\treturn true;\n}\nint main() {\n\twhile (cin >> s[0], s[0] != \"#\") {\n\t\tfor (int i = 0; i < s[0].size(); i++) {\n\t\t\tif (s[0][i] == '=') {\n\t\t\t\ts[1] = s[0].substr(0, i);\n\t\t\t\ts[2] = s[0].substr(i + 1, s[0].size() - i - 1);\n\t\t\t}\n\t\t}\n\t\tbool flag = true;\n\t\tfor (int i = 0; i < 2048; i++) {\n\t\t\ts[3] = s[1], s[4] = s[2];\n\t\t\tfor (int j = 0; j < 11; j++) {\n\t\t\t\tfor (int k = 0; k < s[3].size(); k++) {\n\t\t\t\t\tif (s[1][k] == j + 97) s[3][k] = (i & (1 << j)) ? 'T' : 'F';\n\t\t\t\t}\n\t\t\t\tfor (int k = 0; k < s[4].size(); k++) {\n\t\t\t\t\tif (s[2][k] == j + 97) s[4][k] = (i & (1 << j)) ? 'T' : 'F';\n\t\t\t\t}\n\t\t\t}\n\t\t\tif (solve(0, s[3].size(), 3) != solve(0, s[4].size(), 4)) {\n\t\t\t\tflag = false; break;\n\t\t\t}\n\t\t}\n\t\tprintf(\"%s\\n\", flag ? \"YES\" : \"NO\");\n\t}\n\treturn 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include\"bits/stdc++.h\"\nusing namespace std;\n\n//define\n#define ALL(a) a.begin(),a.end()\n#define REP(i,n) for(int i=0;i<n;i++)\n#define RREP(i,n) for(int i=n-1;i>=0;i--)\n#define debug(x) if(1)cout<<#x<<\":\"<<x<<endl;\n#define DEBUG(x) if(1)cout<<#x<<\":\"<<x<<endl;\n#define ll long long\n\n//typedef\ntypedef vector<int> vi;\ntypedef vector<vector<int>> vvi;\n\nbool equation(const string &s, int &i, const int set);\nbool formula(const string &s, int &i, const int set);\n\nint main() {\n\tstring s;\n\twhile (cin >> s, s[0] != '#') {\n\t\ts += '#';\n\t\tbool isok = true;\n\t\tfor (int i = 0; i < (1 << ('k' - 'a' + 1)); i++) {\n\t\t\tint num=0;\n\t\t\tisok&=equation(s,num,i);\n\t\t}\n\t\tstring res;\n\t\tif (isok) {\n\t\t\tres=\"YES\";\n\t\t}\n\t\telse {\n\t\t\tres=\"NO\";\n\t\t}\n\t\tcout << res << endl;\n\t}\n\treturn 0;\n}\n\nbool equation(const string &s, int &i, int set) {\n\tbool lhs = formula(s, i, set);\n\ti++;\n\tbool rhs = formula(s, i, set);\n\treturn (lhs == rhs);\n}\n\nbool formula(const string &s, int &i, int set) {\n\tif (s[i] == '-') {\n\t\ti++;\n\t\treturn !formula(s, i, set);\n\t}\n\tif (s[i] == '(') {\n\t\ti++;\n\t\tbool lhs = formula(s, i, set);\n\t\tchar op = s[i];\n\t\ti++;\n\t\tif (op == '-') {\n\t\t\ti++;\n\t\t}\n\t\tbool rhs = formula(s, i, set);\n\t\ti++;\n\t\tif (op == '*') {\n\t\t\treturn lhs&rhs;\n\t\t}\n\t\tif (op == '+') {\n\t\t\treturn lhs | rhs;\n\t\t}\n\t\tif (op == '-') {\n\t\t\tif (lhs && !(rhs)) {\n\t\t\t\treturn false;\n\t\t\t}\n\t\t\telse {\n\t\t\t\treturn true;\n\t\t\t}\n\t\t}\n\t}\n\tchar val = s[i];\n\ti++;\n\tif (val == 'T') {\n\t\treturn true;\n\t}\n\tif (val == 'F') {\n\t\treturn false;\n\t}\n\treturn (set & 1 << (val - 'a'));\n}"
  },
  {
    "language": "C++",
    "code": "#include <iostream>\n#include <string>\n#include <vector>\n#include <algorithm>\n#include <utility>\n#include <cstring>\n#include <cmath>\n#include <queue>\n#include <map>\n#include <set>\nusing namespace std;\n\n#define rep(i,n) for(int i=0; i<n; i++)\n#define FOR(i,s,n) for(int i=s; i<n; i++)\n#define ALL(x) x.begin(), x.end()\ntypedef long long ll;\ntypedef unsigned long long ull;\ntypedef pair<int,int> pii;\ntypedef vector<int> vi;\n\nstring solve( string s ) {\n\tif( s == \"0\" || s == \"1\" ) return s;\n\trep(i, s.length()) {\n\t\tif(s[i] == '(') {\n\t\t\tint p = i+1;\n\t\t\tint shell = 0;\n\t\t\twhile(p<s.length()) {\n\t\t\t\tif(s[p]==')') {\n\t\t\t\t\tshell--;\n\t\t\t\t\tif(shell==-1) break;\n\t\t\t\t}\n\t\t\t\telse if(s[p]=='(') {\n\t\t\t\t\tshell++;\n\t\t\t\t}\n\t\t\t\tp++;\n\t\t\t}\n\t\t\tstring ss = solve(s.substr(i+1, p-i-1));\n\t\t\ts.replace(i, p-i+1, ss);\n\t\t}\n\t}\n\n\trep(i, s.length()) {\n\t\tif(s[i] == '*') {\n\t\t\tstring sa = solve(s.substr(0, i));\n\t\t\tstring sb = solve(s.substr(i+1));\n\t\t\ts = (sa==\"1\" && sb==\"1\") ? \"1\" : \"0\";\n\t\t}\n\t\telse if(s[i] == '+') {\n\t\t\tstring sa = solve(s.substr(0, i));\n\t\t\tstring sb = solve(s.substr(i+1));\n\t\t\ts = (sa==\"0\" && sb==\"0\") ? \"0\" : \"1\";\n\t\t}\n\t\telse if(s[i] == '-' && i+1<s.length() && s[i+1]=='>') {\n\t\t\tstring sa = solve(s.substr(0, i));\n\t\t\tstring sb = solve(s.substr(i+2));\n\t\t\ts = (sa==\"1\" && sb==\"0\") ? \"0\" : \"1\";\n\t\t}\n\t}\n\trep(i, s.length()) {\n\t\tif(s[i] == '-') {\n\t\t\tstring ss = solve(s.substr(i+1));\n\t\t\ts = (ss==\"0\" ? \"1\" : \"0\");\n\t\t}\n\t}\n\treturn s;\n}\n\nint main() {\n\tstring in;\n\twhile(cin >> in, in!=\"#\") {\n\t\tstring aa, ab;\n\t\trep(i, in.length()) {\n\t\t\tif( in[i] == 'T' ) {\n\t\t\t\tin[i] = '1';\n\t\t\t}\n\t\t\telse if( in[i] == 'F' ) {\n\t\t\t\tin[i] = '0';\n\t\t\t}\n\t\t}\n\t\trep(i, in.length()) {\n\t\t\tif( in[i] == '=' ) {\n\t\t\t\taa = in.substr(0, i);\n\t\t\t\tab = in.substr(i+1);\n\t\t\t\tbreak;\n\t\t\t}\n\t\t}\n\t\tbool ng = false;\n\t\trep(i, (1<<11)) {\n\t\t\tstring a=aa, b=ab;\n\t\t\trep(j, a.length()) {\n\t\t\t\tif('a'<=a[j] && a[j]<='k') {\n\t\t\t\t\ta[j] = '0' + ((i & (1<<(a[j]-'a'))) ? 1 : 0);\n\t\t\t\t}\n\t\t\t}\n\t\t\trep(j, b.length()) {\n\t\t\t\tif('a'<=b[j] && b[j]<='k') {\n\t\t\t\t\tb[j] = '0' + ((i & (1<<(b[j]-'a'))) ? 1 : 0);\n\t\t\t\t}\n\t\t\t}\n\t\t\ta = solve(a);\n\t\t\tb = solve(b);\n\t\t\tif( a != b ) {\n\t\t\t\tcout << \"NO\" << endl;\n\t\t\t\tng = true;\n\t\t\t\tbreak;\n\t\t\t}\n\t\t}\n\t\tif( !ng ) {\n\t\t\tcout << \"YES\" << endl;\n\t\t}\n\t}\n\treturn 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include <iostream>\n#include <string>\n#include <vector>\n#include <algorithm>\n#include <cmath>\n#include <cstdio>\n#include <functional>\n#include <numeric>\n#include <stack>\n#include <queue>\n#include <map>\n#include <set>\n#include <utility>\n#include <sstream>\n#include <complex>\n#include <fstream>\n#include <bitset>\n#include <time.h>\n\nusing namespace std;\n\ntypedef long long ll;\ntypedef pair<ll, ll> P;\ntypedef vector<ll> V;\ntypedef complex<double> Point;\n\n#define PI acos(-1.0)\n#define EPS 1e-10\nconst ll INF = (1LL << 31) - 1;\nconst ll MOD = 1e9 + 7;\n\n#define FOR(i,a,b) for(int i=(a);i<(b);i++)\n#define REP(i,N) for(int i=0;i<(N);i++)\n#define ALL(s) (s).begin(),(s).end()\n#define EQ(a,b) (abs((a)-(b))<EPS)\n#define EQV(a,b) ( EQ((a).real(), (b).real()) && EQ((a).imag(), (b).imag()) )\n#define fi first\n#define se second\n#define N_SIZE (1LL << 20)\n#define NIL -1\n#define MAX_N 100100 * 3\n\nstring s;\nmap<char, bool> mci;\n\nvector<string> split(string str, char sep)\n{\n\tvector<string> v;\n\tstringstream ss(str);\n\tstring buffer;\n\twhile (getline(ss, buffer, sep)) {\n\t\tv.push_back(buffer);\n\t}\n\treturn v;\n}\n\nstring print(ll num) {\n\tstring res;\n\tint n = (1 << 11);\n\twhile (n) {\n\t\tif (num >= n) {\n\t\t\tnum -= n;\n\t\t\tres += \"1\";\n\t\t}\n\t\telse res += \"0\";\n\t\tn /= 2;\n\t}\n\treturn res;\n}\n\nbool formula(string s, int &pos) {\n\t//cout << s[pos] << \"!\" << pos << endl;\n\tif (s[pos] == 'T') {\n\t\tpos++;\n\t\treturn true;\n\t}\n\tif (s[pos] == 'F') {\n\t\tpos++;\n\t\treturn false;\n\t}\n\tif (s[pos] >= 'a'&&s[pos] <= 'k') {\n\t\t//cout << s[pos] << \"!\" << pos << endl;\n\t\tpos++;\n\t\treturn mci[s[pos]];\n\t}\n\tbool res = false;\n\tif (s[pos] == '-') {\n\t\tif (s[pos + 1] != '>') {\n\t\t\tpos++;\n\t\t\tres = !formula(s, pos);\n\t\t}\n\t}\n\tif (s[pos] == '(') {\n\t\tpos++;\n\t\tres = formula(s, pos);\n\t}\n\tif (s[pos] == '*') {\n\t\tpos++;\n\t\tres &= formula(s, pos);\n\t}\n\telse if (s[pos] == '+') {\n\t\tpos++;\n\t\tres |= formula(s, pos);\n\t}\n\telse if (s[pos] == '-') {\n\t\tpos += 2;\n\t\tif (res == true && formula(s, pos) == false)return false;\n\t\telse return true;\n\t}\n\treturn res;\n}\n\nbool equation(string s, int &pos) {\n\tvector<string> vs = split(s, '=');\n\tbool f = formula(vs[0], pos);\n\tpos = 0;\n\tbool f2 = formula(vs[1], pos);\n\t//if (f != f2)cout << f << f2 << endl;\n\treturn f == f2;\n}\n\nint main() {\n\twhile (cin >> s&&s != \"#\") {\n\t\tbool f = true;\n\t\tREP(mask, (1 << 11) + 1) {\n\t\t\t//if (mask == 340)break;\n\t\t\tint pos = 0;\n\t\t\tint num = mask;\n\t\t\tint i = 0;\n\t\t\twhile (i < 11) {\n\t\t\t\tif ((num >> i) & 1)mci['a' + i] = 1;\n\t\t\t\telse mci['a' + i] = 0;\n\t\t\t\ti++;\n\t\t\t}\n\t\t\tbool g = equation(s, pos);\n\t\t\t//if (!g)cout << mask << \" \" << g << endl;\n\t\t\tf &= g;\n\t\t}\n\t\tif (f)cout << \"YES\" << endl;\n\t\telse cout << \"NO\" << endl;\n\t}\n}"
  },
  {
    "language": "C++",
    "code": "#include <iostream>\n#include <string>\n#include <stack>\n\nusing namespace std;\n\nchar wa(char a, char b);\nchar seki(char a, char b);\nchar naraba(char a, char b);\nchar not_k(char a);\n\nbool kaiseki(string b) {\n\tstack<char> stk1;\n\tstack<char> stk2;\n\tchar aa, bb;\n\tfor (int i = 0; i < b.size(); i++) {\n\t\tif (b[i] == '=') {\n\t\t\taa = stk2.top();\n\t\t\tstk2.pop();\n\t\t} else {\n\t\t\tif (b[i] == '0' || b[i] == '1') {\n\t\t\t\twhile (!stk1.empty() && stk1.top() == '-') {\n\t\t\t\t\tstk1.pop();\n\t\t\t\t\tb[i] = not_k(b[i]);\n\t\t\t\t}\n\t\t\t\tstk2.push(b[i]);\n\t\t\t} else if (b[i] == '+' || b[i] == '*' || b[i] == '>' || b[i] == '(') {\n\t\t\t\tstk1.push(b[i]);\n\t\t\t} else if (b[i] == ')') {\n\t\t\t\tchar p = stk2.top();\n\t\t\t\tstk2.pop();\n\t\t\t\tchar q = stk2.top();\n\t\t\t\tstk2.pop();\n\t\t\t\tchar k = stk1.top();\n\t\t\t\tstk1.pop();\n\t\t\t\tif (k == '+') {\n\t\t\t\t\tp = wa(p, q);\n\t\t\t\t} else if (k == '*'){\n\t\t\t\t\tp = seki(p, q);\n\t\t\t\t} else if (k == '>') {\n\t\t\t\t\tp = naraba(q, p);\n\t\t\t\t} else {\n\t\t\t\t\tstk2.push(q);\n\t\t\t\t\tp = not_k(p);\n\t\t\t\t}\n\t\t\t\tstk1.pop();\n\t\t\t\twhile (!stk1.empty() && stk1.top() == '-') {\n\t\t\t\t\tstk1.pop();\n\t\t\t\t\tp = not_k(p);\n\t\t\t\t}\n\t\t\t\tstk2.push(p);\n\t\t\t} else if (b[i] == '-') {\n\t\t\t\tif (b[i+1] == '>') {\n\t\t\t\t} else {\n\t\t\t\t\tstk1.push(b[i]);\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t}\n\tbb = stk2.top();\n\tstk2.pop();\n\treturn aa == bb;\n}\n\nchar wa(char a, char b) {\n\tif (a == '0' && b == '0') {\n\t\treturn '0';\n\t} else {\n\t\treturn '1';\n\t}\n}\n\nchar seki(char a, char b) {\n\tif (a == '1' && b == '1') {\n\t\treturn '1';\n\t} else {\n\t\treturn '0';\n\t}\n}\n\nchar naraba(char a, char b) {\n\tif (a == '1' && b == '0') {\n\t\treturn '0';\n\t} else {\n\t\treturn '1';\n\t}\n}\n\nchar not_k(char a) {\n\tif (a == '0') {\n\t\treturn '1';\n\t} else {\n\t\treturn '0';\n\t}\n}\n\nint main() {\n\tstring a;\n\tstring abc = \"abcdefghijk\";\n\twhile (cin >> a) {\n\t\tif (a == \"#\") {\n\t\t\tbreak;\n\t\t}\n\t\tint counter = 1;\n\t\tcounter <<= 11;\n\t\tstring b;\n\t\tbool hantei = true;\n\t\tfor (int i = 0; i < a.size(); i++) {\n\t\t\tif (a[i] == 'T') {\n\t\t\t\ta[i] = '1';\n\t\t\t} else if (b[i] == 'F') {\n\t\t\t\ta[i] = '0';\n\t\t\t}\n\t\t}\n\t\tfor (int i = 0; i < counter; i++) {\n\t\t\tb = a;\n\t\t\tfor (int j = 0; j < 11; j++) {\n\t\t\t\tif ((i&(1<<j)) != 0) {\n\t\t\t\t\twhile (b.find(abc[j]) != string::npos) {\n\t\t\t\t\t\tb[b.find(abc[j])] = '1';\n\t\t\t\t\t}\n\t\t\t\t} else {\n\t\t\t\t\twhile (b.find(abc[j]) != string::npos) {\n\t\t\t\t\t\tb[b.find(abc[j])] = '0';\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t}\n\t\t\tif (!kaiseki(b)) {\n\t\t\t\thantei = false;\n\t\t\t\tbreak;\n\t\t\t}\n\t\t}\n\t\tif (hantei) {\n\t\t\tcout << \"YES\" << endl;\n\t\t} else {\n\t\t\tcout << \"NO\" << endl;\n\t\t}\n\t}\n\treturn 0;\n}"
  },
  {
    "language": "C++",
    "code": "\n#include <cstdio>\n#include <iostream>\n#include <vector>\n#include <list>\n#include <cmath>\n#include <fstream>\n#include <algorithm>\n#include <string>\n#include <queue>\n#include <set>\n#include <map>\n#include <complex>\n#include <iterator>\n#include <cstdlib>\n#include <cstring>\n#include <sstream>\n#include <stack>\n#include <climits>\n\nusing namespace std;\ntypedef long long ll;\ntypedef pair<int,int> pii;\ndouble EPS=1e-10;\ndouble EQ(double a,double b){\n\treturn abs(a-b)<EPS;\n}\nmap<char,int> m;\nint idx=0;\nint Mask;\n\nbool analize(string s){\n\tif(s.size()==1){\n\t\tif(s[0]=='T')return true;\n\t\telse if(s[0]=='F')return false;\n\t\telse{\n\t\t\tint pos=m[s[0]];\n\t\t\tif((Mask>>pos)&1){\n\t\t\t\treturn true;\n\t\t\t}\n\t\t\treturn false;\n\t\t}\n\t}\n\tif(s[0]=='('&&s[s.size()-1]==')'){\n\t\tint cnt=1;\n\t\tbool ok=true;\n\t\tfor(int i=1;i<s.size()-1;i++){\n\t\t\tif(s[i]=='(')cnt++;\n\t\t\telse if(s[i]==')')cnt--;\n\t\t\tif(cnt==0){\n\t\t\t\tok=false;\n\t\t\t\tbreak;\n\t\t\t}\n\t\t}\n\t\tif(ok)return analize(s.substr(1,s.size()-2));\n\t}\n\tint cnt=0;\n\tfor(int i=0;i<s.size();i++){\n\t\tif(s[i]=='(')cnt++;\n\t\telse if(s[i]==')')cnt--;\n\t\tif(cnt==0&&s[i]=='*'){\n\t\t\treturn analize(s.substr(0,i))&analize(s.substr(i+1));\n\t\t}\n\t}\n\tcnt=0;\n\tfor(int i=0;i<s.size();i++){\n\t\tif(s[i]=='(')cnt++;\n\t\telse if(s[i]==')')cnt--;\n\t\tif(cnt==0&&s[i]=='+'){\n\t\t\treturn analize(s.substr(0,i))|analize(s.substr(i+1));\n\t\t}\n\t}\n\tcnt=0;\n\tfor(int i=0;i<s.size()-1;i++){\n\t\tif(s[i]=='(')cnt++;\n\t\telse if(s[i]==')')cnt--;\n\t\tif(cnt==0&&s[i]=='-'){\n\t\t\tif(s[i+1]=='>'){\n\t\t\t\tif(analize(s.substr(0,i))&&!analize(s.substr(i+2)))\n\t\t\t\t\treturn false;\n\t\t\t\telse return true;\n\t\t\t}\n\t\t}\n\t}\n\tif(s[0]=='-'){\n\t\treturn !analize(s.substr(1));\n\t}\n\treturn false;\n}\n\nvoid solve(){\n\tstring s;\n\twhile(getline(cin,s)&&s!=\"#\"){\n\t\tidx=0;\n\t\tm.clear();\n\t\tstring s1,s2;\n\t\tfor(int i=0;i<s.size();i++){\n\t\t\tif(s[i]=='='){\n\t\t\t\ts1=s.substr(0,i);\n\t\t\t\ts2=s.substr(i+1);\n\t\t\t}\n\t\t}\n\t\tfor(int i=0;i<s.size();i++){\n\t\t\tif(s[i]>='a'&&s[i]<='k'&&m.count(s[i])==0){\n\t\t\t\tm[s[i]]=idx++;\n\t\t\t}\n\t\t}\n\t\tbool ok=true;\n\t\tfor(int mask=0;mask<(1<<idx);mask++){\n\t\t\tMask=mask;\n\t\t\tif(analize(s1)!=analize(s2)){\n\t\t\t\tok=false;\n\t\t\t\tbreak;\n\t\t\t}\n\t\t}\n\t\tif(ok)cout<<\"YES\"<<endl;\n\t\telse cout<<\"NO\"<<endl;\n\t}\n}int main(){\n\n\tsolve();\n\n\treturn 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include <iostream>\n#include <string>\n#include <stack>\n\nusing namespace std;\n\nchar wa(char a, char b);\nchar seki(char a, char b);\nchar naraba(char a, char b);\nchar not_k(char a);\n\nbool kaiseki(string b) {\n\tstack<char> stk1;\n\tstack<char> stk2;\n\tchar aa, bb;\n\tfor (int i = 0; i < b.size(); i++) {\n\t\tif (b[i] == '=') {\n\t\t\taa = stk2.top();\n\t\t\tstk2.pop();\n\t\t} else {\n\t\t\tif (b[i] == '0' || b[i] == '1') {\n\t\t\t\twhile (!stk1.empty() && stk1.top() == '-') {\n\t\t\t\t\tstk1.pop();\n\t\t\t\t\tb[i] = not_k(b[i]);\n\t\t\t\t}\n\t\t\t\tstk2.push(b[i]);\n\t\t\t} else if (b[i] == '+' || b[i] == '*' || b[i] == '>' || b[i] == '(') {\n\t\t\t\tstk1.push(b[i]);\n\t\t\t} else if (b[i] == ')') {\n\t\t\t\tchar p = stk2.top();\n\t\t\t\tstk2.pop();\n\t\t\t\tchar q = stk2.top();\n\t\t\t\tstk2.pop();\n\t\t\t\tchar k = stk1.top();\n\t\t\t\tstk1.pop();\n\t\t\t\tif (k == '+') {\n\t\t\t\t\tp = wa(p, q);\n\t\t\t\t} else if (k == '*'){\n\t\t\t\t\tp = seki(p, q);\n\t\t\t\t} else if (k == '>') {\n\t\t\t\t\tp = naraba(q, p);\n\t\t\t\t} else {\n\t\t\t\t\tstk2.push(q);\n\t\t\t\t\tp = not_k(p);\n\t\t\t\t}\n\t\t\t\tstk1.pop();\n\t\t\t\twhile (!stk1.empty() && stk1.top() == '-') {\n\t\t\t\t\tstk1.pop();\n\t\t\t\t\tp = not_k(p);\n\t\t\t\t}\n\t\t\t\tstk2.push(p);\n\t\t\t} else if (b[i] == '-') {\n\t\t\t\tif (b[i+1] == '>') {\n\t\t\t\t} else {\n\t\t\t\t\tif (!stk1.empty() && stk1.top() == '-') {\n\t\t\t\t\t\tstk1.pop();\n\t\t\t\t\t} else {\n\t\t\t\t\t\tstk1.push(b[i]);\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t}\n\tbb = stk2.top();\n\tstk2.pop();\n\treturn aa == bb;\n}\n\nchar wa(char a, char b) {\n\tif (a == '0' && b == '0') {\n\t\treturn '0';\n\t} else {\n\t\treturn '1';\n\t}\n}\n\nchar seki(char a, char b) {\n\tif (a == '1' && b == '1') {\n\t\treturn '1';\n\t} else {\n\t\treturn '0';\n\t}\n}\n\nchar naraba(char a, char b) {\n\tif (a == '1' && b == '0') {\n\t\treturn '0';\n\t} else {\n\t\treturn '1';\n\t}\n}\n\nchar not_k(char a) {\n\tif (a == '0') {\n\t\treturn '1';\n\t} else {\n\t\treturn '0';\n\t}\n}\n\nint main() {\n\tstring a;\n\tstring abc = \"abcdefghijk\";\n\twhile (cin >> a) {\n\t\tif (a == \"#\") {\n\t\t\tbreak;\n\t\t}\n\t\tint counter = 1;\n\t\tcounter <<= 11;\n\t\tstring b;\n\t\tbool hantei = true;\n\t\tfor (int i = 0; i < a.size(); i++) {\n\t\t\tif (a[i] == 'T') {\n\t\t\t\ta[i] = '1';\n\t\t\t} else if (a[i] == 'F') {\n\t\t\t\ta[i] = '0';\n\t\t\t}\n\t\t}\n\t\tfor (int i = 0; i < counter; i++) {\n\t\t\tb = a;\n\t\t\tfor (int j = 0; j < 11; j++) {\n\t\t\t\tif ((i&(1<<j)) != 0) {\n\t\t\t\t\twhile (b.find(abc[j]) != string::npos) {\n\t\t\t\t\t\tb[b.find(abc[j])] = '1';\n\t\t\t\t\t}\n\t\t\t\t} else {\n\t\t\t\t\twhile (b.find(abc[j]) != string::npos) {\n\t\t\t\t\t\tb[b.find(abc[j])] = '0';\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t}\n\t\t\tif (!kaiseki(b)) {\n\t\t\t\thantei = false;\n\t\t\t\tbreak;\n\t\t\t}\n\t\t}\n\t\tif (hantei) {\n\t\t\tcout << \"YES\" << endl;\n\t\t} else {\n\t\t\tcout << \"NO\" << endl;\n\t\t}\n\t}\n\treturn 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include <iostream>\n#include <vector>\n#include <string>\n#include <cstring>\n#include <algorithm>\n#include <sstream>\n#include <map>\n#include <set>\n\n#define REP(i,k,n) for(int i=k;i<n;i++)\n#define rep(i,n) for(int i=0;i<n;i++)\n#define INF 1<<30\n#define pb push_back\n#define mp make_pair\n\nusing namespace std;\ntypedef long long ll;\ntypedef pair<int,int> P;\n\nvector<string> split(const string &str, char delim) {\n\tvector<string> res;\n\tsize_t current = 0, found;\n\twhile((found = str.find_first_of(delim, current)) != string::npos) {\n\t\tres.push_back(string(str, current, found - current));\n\t\tcurrent = found + 1;\n\t}\n\tres.push_back(string(str, current, str.size() - current));\n\treturn res;\n}\n\nint formula(string& s, int& i) {\n\tif(s[i] == '(') {\n\t\ti++;\n\t\tint val = formula(s, i);\n\n\t\tchar op = s[i];\n\t\tif(s[i] == '-' && s[i+1] == '>') {\n\t\t\ti++;\n\t\t\top = s[i];\n\t\t}\n\n\t\ti++;\n\t\tint val2 = formula(s, i);\n\n\t\tint ret = 0;\n\t\tif(op == '+') {\n\t\t\tif(val || val2) ret = 1;\n\t\t\telse ret = 0;\n\t\t} else if(op == '*') {\n\t\t\tif(val && val2) ret = 1;\n\t\t\telse ret = 0;\n\t\t} else if(op == '>') {\n\t\t\tif(!val) ret = 1;\n\t\t\telse if(val2) ret = 1;\n\t\t\telse ret = 0;\n\t\t}\n\n\t\ti++;\n\t\treturn ret;\n\t} else if(isdigit(s[i])) {\n\t\tint ret = s[i] - '0';\n\t\ti++;\n\t\treturn ret;\n\t} else if(s[i] == '-') {\n\t\ti++;\n\t\tint ret = formula(s, i);\n\n\t\tif(ret == 0) return 1;\n\t\telse return 0;\n\t}\n}\n\nbool used[30];\n\nint main() {\n\tstring s;\n\n\twhile(cin >> s) {\n\t\tif(s == \"#\") break;\n\n\t\tvector<string> ret = split(s, '=');\n\t\tstring s1 = ret[0];\n\t\tstring s2 = ret[1];\n\n\t\tbool flag = true;\n\n\t\trep(i, 1<<11) {\n\t\t\tmemset(used, 0, sizeof(used));\n\t\t\trep(j, 11) {\n\t\t\t\tif(i & (1<<j)) used[j] = true;\n\t\t\t}\n\n\t\t\tstring t1 = s1, t2 = s2;\n\t\t\trep(j, t1.size()) {\n\t\t\t\tif('a' <= t1[j] && t1[j] <= 'k') {\n\t\t\t\t\tif(used[t1[j] - 'a']) t1[j] = 'T';\n\t\t\t\t\telse t1[j] = 'F';\n\t\t\t\t}\n\n\t\t\t\tif(t1[j] == 'T') t1[j] = '1';\n\t\t\t\tif(t1[j] == 'F') t1[j] = '0';\n\t\t\t}\n\n\t\t\trep(j, t2.size()) {\n\t\t\t\tif('a' <= t2[j] && t2[j] <= 'k') {\n\t\t\t\t\tif(used[t2[j] - 'a']) t2[j] = 'T';\n\t\t\t\t\telse t2[j] = 'F';\n\t\t\t\t}\n\n\t\t\t\tif(t2[j] == 'T') t2[j] = '1';\n\t\t\t\tif(t2[j] == 'F') t2[j] = '0';\n\t\t\t}\n\n\t\t\tint j = 0, k = 0;\n\t\t\tint f1 = formula(t1, j);\n\t\t\tint f2 = formula(t2, k);\n\n\t\t\tif(f1 == f2) continue;\n\n\t\t\tflag = false;\n\t\t\tbreak;\n\t\t}\n\n\t\tif(flag) cout << \"YES\" << endl;\n\t\telse cout << \"NO\" << endl;\n\t}\n\n\treturn 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include<iostream>\n#include<vector>\n#include<string>\n#include<algorithm>\n#define all(c) c.begin(),c.end()\n#define uni(c) c.erase(unique(c.begin(),c.end()),c.end())\n#define pb push_back\nusing namespace std;\n\nint expr(string& s, int& i);\nint term(string& s, int& i);\nint factor(string& s, int& i);\nint number(string& s, int& i);\n\n\nint expr(string& s, int& i) {\n  int val = term(s, i);\n  while(s[i] == '+' || s[i] == '-') {\n    char op = s[i];\n    i++;\n  \tif(!isdigit(s[i])){\n  \t\ti++;\n  \t\tint val2 = term(s, i);\n  \t\tif(val==1&&val2==0){\n  \t\t\tval=0;\n  \t\t}else{\n  \t\t\tval=1;\n  \t\t}\n  \t}else{\n  \t  int val2 = term(s, i);\n    \tif (op == '+') val |= val2;\n  \t}\n  }\n  return val;\n}\n\nint term(string& s, int& i) {\n  int val = factor(s, i);\n  while(s[i] == '*') {\n    char op = s[i];\n    i++;\n    int val2 = factor(s, i);\n    if (op == '*') val *= val2;\n  }\n  return val;\n}\n\nint factor(string& s, int& i) {\n\tint flag=0;\n\tif(s[i]=='-'){\n\t\tflag=1;\n\t\ti++;\n\t}\n\tif (isdigit(s[i])){\n\t\tif(flag)\n\t\t\treturn flag^number(s, i);\n\t\t\treturn number(s,i);\n\t}\n\n  // ここで構文が正しければ s[i] == '(' となる\n  i++; // '('を読み飛ばす\n  int ret = expr(s, i);\n  i++; // ')'を読み飛ばす\n\tif(flag)\n\treturn flag^ret;\n\treturn ret;\n}\n\nint number(string& s, int& i) {\n  int n = s[i++] - '0';\n  while(isdigit(s[i])) n = n*10 + s[i++] - '0';\n  return n;\n}\n\nint main(){\n\tstring s;\n\twhile(cin>>s,s!=\"#\"){\n\t\tint eq=0;\n\t\tstring a,b;\n\t\tfor(int i=0;i<s.size();i++){\n\t\t\tif(s[i]=='T')\n\t\t\ts[i]='1';\n\t\t\telse if(s[i]=='F')\n\t\t\ts[i]='0';\n\t\t}\n\t\tfor(;s[eq]!='=';eq++);\n\t\ta=s.substr(0,eq),b=s.substr(eq+1,s.size()-eq);\n\t\t//cout<<a<<\" \"<<b<<endl;\n\t\tvector<char> ap;\n\t\t\n\t\tfor(int i=0;i<s.size();i++){\n\t\t\tif(isalpha(s[i]))\n\t\t\t\tap.pb(s[i]);\n\t\t}\n\t\tsort(all(ap));\n\t\tuni(ap);\n\t\tbool flag=true;\n\t\tfor(int i=0;i<(1<<ap.size());i++){\n\t\t\tstring x=a,y=b;\n\t\t\tfor(int j=0;j<ap.size();j++){\n\t\t\t\tchar c=ap[j];\n\t\t\t\tbool wh=false;\n\t\t\t\tif((1<<j)&i)\n\t\t\t\t\twh=true;\n\t\t\t\tfor(int k=0;k<x.size();k++){\n\t\t\t\t\tif(x[k]==c){\n\t\t\t\t\t\tif(wh)\n\t\t\t\t\t\t\tx[k]='1';\n\t\t\t\t\t\telse\n\t\t\t\t\t\t\tx[k]='0';\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t\tfor(int k=0;k<y.size();k++){\n\t\t\t\t\tif(y[k]==c){\n\t\t\t\t\t\tif(wh)\n\t\t\t\t\t\t\ty[k]='1';\n\t\t\t\t\t\telse\n\t\t\t\t\t\t\ty[k]='0';\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t}\n\t\t\t\n\t\t\tint i=0,j=0;\n\t\t\tif(expr(x,i)!=expr(y,j)){\n\t\t\t\tcout<<\"NO\"<<endl;\n\t\t\t\tflag=false;\n\t\t\t\tbreak;\n\t\t\t}\n\t\t\t\n\t\t}\n\t\tif(flag)\n\t\t\tcout<<\"YES\"<<endl;\n\t}\n\treturn 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\nusing namespace std;\n\nint c = 0;\nbool solve(const string& s, int i){\n  c++;\n  switch (s[c-1]){\n    case 'T': return true;\n    case 'F': return false;\n    case '-': return !solve(s,i);\n    case '(':\n      bool l = solve(s,i);\n      char op = s[c];\n      c++;\n      if(op=='-') c++;\n      bool r = solve(s,i);\n      c++;\n      switch (op){\n        case '*': return (l&r)==1;\n        case '+': return (l|r)==1;\n        case '-': return ((!l)|r)==1;\n      }\n  }\n  return (i & (1 << (s[c-1] - 'a' - 1))) != 0 ;\n}\nint main(){\n  string s;\n  while(cin >> s, s != \"#\"){\n    int i;\n    for(i = 0; i <= 0x7ff; i++){\n      int eq = s.find(\"=\");\n      c = 0;\n      bool r = solve(s.substr(0,eq), i);\n      c = 0;\n      bool l = solve(s.substr(eq+1), i);\n      if(r != l) break;\n    }\n    if(i>0x7ff) cout << \"YES\" << endl;\n    else cout << \"NO\" << endl;\n  }\n}"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\nusing namespace std;\n\nint c = 0;\nbool solve(const string& s, int i){\n  c++;\n  switch (s[c-1]){\n    case 'T': return true;\n    case 'F': return false;\n    case '-': return !solve(s,i);\n    case '(':\n      bool l = solve(s,i);\n      c++;\n      switch (s[c-1]){\n        case '*': return l&&solve(s,i);\n        case '+': return l||solve(s,i);\n        case '-': c++; return (!l)||solve(s,i);\n      }\n  }\n  return (i & (1 << (s[c-1] - 'a' - 1))) != 0;\n}\nint main(){\n  string s;\n  while(cin >> s, s != \"#\"){\n    int i;\n    for(i = 0; i <= 0x7f; i++){\n      int eq = s.find(\"=\");\n      c = 0;\n      bool r = solve(s.substr(0,eq), i);\n      c = 0;\n      bool l = solve(s.substr(eq+1), i);\n      if(r != l) break;\n    }\n    if(i>0x7f) cout << \"YES\" << endl;\n    else cout << \"NO\" << endl;\n  }\n}"
  },
  {
    "language": "C++",
    "code": "#include <algorithm>\n#include <cmath>\n#include <climits>\n#include <cstdio>\n#include <cstdlib>\n#include <cstring>\n#include <fstream>\n#include <iostream>\n#include <list>\n#include <map>\n#include <queue>\n#include <set>\n#include <sstream>\n#include <stack>\n#include <string>\n#include <vector>\n#include <cassert>\n\nusing namespace std;\n\n#define LOG(...) printf(__VA_ARGS__)\n//#define LOG(...)\n#define FOR(i,a,b) for(int i=(int)(a);i<(int)(b);++i)\n#define REP(i,n) for(int i=0;i<(int)(n);++i)\n#define ALL(a) (a).begin(),(a).end()\n#define RALL(a) (a).rbegin(),(a).rend()\n#define EXIST(s,e) ((s).find(e)!=(s).end())\n#define SORT(c) sort((c).begin(),(c).end())\n#define RSORT(c) sort((c).rbegin(),(c).rend())\n#define CLR(a) memset((a), 0 ,sizeof(a))\n\ntypedef long long ll;\ntypedef unsigned long long ull;\ntypedef vector<bool> vb;\ntypedef vector<int> vi;\ntypedef vector<ll> vll;\ntypedef vector<vb> vvb;\ntypedef vector<vi> vvi;\ntypedef vector<vll> vvll;\ntypedef pair<int, int> pii;\ntypedef pair<ll, ll> pll;\n\nbool check(char op, bool f1, bool f2) {\n    switch (op) {\n    case '*':\n        return f1 && f2;\n    case '+':\n        return f1 || f2;\n    case '>':\n        return !(f1 && !f2);\n    }\n    assert(0);\n}\n\nbool formula(string& form, int& idx) {\n    for (; idx < (int)form.length(); idx++) {\n        switch (form[idx]) {\n        case 'T':\n            return true;\n        case 'F':\n            return false;\n        case '-':\n            return !formula(form, ++idx);\n        case '(':\n            bool f1 = formula(form, ++idx);\n            char op = form[++idx];\n            bool f2 = formula(form, ++idx);\n            ++idx;\n            return check(op, f1, f2);\n        }\n    }\n    assert(0);\n}\n\nbool equation(string form, int vars) {\n    REP(i, form.length()) {\n        char c = form[i];\n        if (isalpha(c) && c != 'T' && c != 'F') {\n            if (vars & (1 << (c - 'a'))) {\n                form[i] = 'T';\n            } else {\n                form[i] = 'F';\n            }\n        }\n    }\n    int idx = 0;\n    return formula(form, idx);\n}\n\nint main() {\n    while (1) {\n        string line;\n        getline(cin, line);\n        if (line == \"#\") break;\n\n        stringstream f1, f2;\n        bool next = false;\n        REP(i, line.length()) {\n            char c = line[i];\n            if (c == '-' && line[i+1] == '>') {\n                c = '>';\n                i++;\n            }\n            if (c == '=') {\n                next = true;\n            } else if (!next) {\n                f1 << c;\n            } else {\n                f2 << c;\n            }\n        }\n\n        bool eq = true;\n        REP(vars, 1 << 11) {\n            if (equation(f1.str(), vars) != equation(f2.str(), vars)) {\n                eq = false;\n                break;\n            }\n        }\n        cout << (eq ? \"YES\" : \"NO\") << endl;\n    }\n}"
  },
  {
    "language": "C++",
    "code": "#include<iostream>\n#include<string>\n#define MAX 13\nusing namespace std;\nbool o;\nvoid rec(string s){\n  if(!o) return;\n  //cout << s << endl;\n  bool f;\n  int p;\n  while(s.find(\"-0\")!=-1){\n    p=s.find(\"-0\");\n    s[p]='1';s[p+1]=' ';\n    f=true;\n  }\n  while(s.find(\"-1\")!=-1){\n    p=s.find(\"-1\");\n    s[p]='0';s[p+1]=' ';\n    f=true;\n  }\n  while(s.find(\"(0*0)\")!=-1){\n    p=s.find(\"(0*0)\");\n    s[p]='0';s[p+1]=' ';s[p+2]=' ';s[p+3]=' ';s[p+4]=' ';\n    f=true;\n  }\n  while(s.find(\"(0*1)\")!=-1){\n    p=s.find(\"(0*1)\");\n    s[p]='0';s[p+1]=' ';s[p+2]=' ';s[p+3]=' ';s[p+4]=' ';\n    f=true;\n  }\n  while(s.find(\"(1*0)\")!=-1){\n    p=s.find(\"(1*0)\");\n    s[p]='0';s[p+1]=' ';s[p+2]=' ';s[p+3]=' ';s[p+4]=' ';\n    f=true;\n  }\n  while(s.find(\"(1*1)\")!=-1){\n    p=s.find(\"(1*1)\");\n    s[p]='1';s[p+1]=' ';s[p+2]=' ';s[p+3]=' ';s[p+4]=' ';\n    f=true;\n  }\n  while(s.find(\"(0+0)\")!=-1){\n    p=s.find(\"(0+0)\");\n    s[p]='0';s[p+1]=' ';s[p+2]=' ';s[p+3]=' ';s[p+4]=' ';\n    f=true;\n  }\n  while(s.find(\"(0+1)\")!=-1){\n    p=s.find(\"(0+1)\");\n    s[p]='1';s[p+1]=' ';s[p+2]=' ';s[p+3]=' ';s[p+4]=' ';\n    f=true;\n  }\n  while(s.find(\"(1+0)\")!=-1){\n    p=s.find(\"(1+0)\");\n    s[p]='1';s[p+1]=' ';s[p+2]=' ';s[p+3]=' ';s[p+4]=' ';\n    f=true;\n  }\n  while(s.find(\"(1+1)\")!=-1){\n    p=s.find(\"(1+1)\");\n    s[p]='1';s[p+1]=' ';s[p+2]=' ';s[p+3]=' ';s[p+4]=' ';\n    f=true;\n  }\n  while(s.find(\"(0->0)\")!=-1){\n    p=s.find(\"(0->0)\");\n    s[p]='1';s[p+1]=' ';s[p+2]=' ';s[p+3]=' ';s[p+4]=' ';s[p+5]=' ';\n    f=true;\n  }\n  while(s.find(\"(0->1)\")!=-1){\n    p=s.find(\"(0->1)\");\n    s[p]='1';s[p+1]=' ';s[p+2]=' ';s[p+3]=' ';s[p+4]=' ';s[p+5]=' ';\n    f=true;\n  }\n  while(s.find(\"(1->0)\")!=-1){\n    p=s.find(\"(1->0)\");\n    s[p]='0';s[p+1]=' ';s[p+2]=' ';s[p+3]=' ';s[p+4]=' ';s[p+5]=' ';\n    f=true;\n  }\n  while(s.find(\"(1->1)\")!=-1){\n    p=s.find(\"(1->1)\");\n    s[p]='1';s[p+1]=' ';s[p+2]=' ';s[p+3]=' ';s[p+4]=' ';s[p+5]=' ';\n    f=true;\n  }\n  if(f){\n    string b;\n    for(int i=0;i<s.size();i++) if(s[i]!=' ') b+=s[i];\n    rec(b);\n  }else{\n    //if(s[0]!=s[2]) o=false;\n    return;\n  }\n}\nvoid init(int n,string s){\n  int i,j;\n  for(i=0;i<s.size();i++){\n    for(j=0;j<=MAX;j++){\n      if(s[i]=='a'+j) s[i]='0'+(n>>j&1);\n      if(s[i]=='T') s[i]='1';\n      if(s[i]=='F') s[i]='0';\n    }\n  }\n  rec(s);\n}\nint main(){\n  string s;\n  while(cin >> s,s!=\"#\"){\n    o=true;\n    int i;\n    for(i=0;i<(1<<MAX);i++)\n      init(i,s);\n    cout << (o?\"YES\":\"NO\") << endl;\n  }\n  return 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include <vector>\n#include <iostream>\n#include <utility>\n#include <algorithm>\n#include <string>\n#include <deque>\n#include <tuple>\n#include <queue>\n#include <functional>\n#include <cmath>\n#include <iomanip>\n#include <map>\n#include <numeric>\n//cin.sync_with_stdio(false);\n//streambuf\nusing namespace std;\ntypedef long long ll;\ntypedef pair<int, int> pii;\ntypedef pair<double, double> pdd;\nstring buf;\nint v;\nbool perse(int a, int b) {\n\tswitch (buf[a]) {\n\tcase '-':\n\t\treturn !perse(a + 1, b);\n\tcase '(':\n\t\t{\n\t\t\tint c = a+1;\n\t\t\tint n = 0;\n\t\t\tfor (;; c++) {\n\t\t\t\tif (buf[c] == '(')n++;\n\t\t\t\telse if (buf[c] == ')') {\n\t\t\t\t\tn--;\n\t\t\t\t}\n\t\t\t\telse {\n\t\t\t\t\tif (!n&&(buf[c]=='+'||buf[c]=='*'||buf[c]=='-'&&buf[c+1]=='>'))break;\n\t\t\t\t}\n\t\t\t}\n\t\t\tswitch (buf[c]) {\n\t\t\tcase '+':\n\t\t\t\treturn perse(a + 1, c - 1) || perse(c + 1, b - 1);\n\t\t\tcase '*':\n\t\t\t\treturn perse(a + 1, c - 1) && perse(c + 1, b - 1);\n\t\t\tdefault:\n\t\t\t\treturn !perse(a + 1, c - 1) || perse(c + 2, b - 1);\n\t\t\t}\n\t\t}\n\tcase 'T':\n\t\treturn 1;\n\tcase 'F':\n\t\treturn 0;\n\t}\n\treturn v & 1 << (buf[a] - 'a');\n}\nint main() {\n\twhile (cin>>buf,buf != \"#\") {\n\t\tint e = buf.find('=');\n\t\tbool yes = true;\n\t\tfor (v = 0; v < 1 << 11; v++) {\n\t\t\tif (perse(0, e - 1) != perse(e + 1, buf.size() - 1)) {\n\t\t\t\tyes = 0;\n\t\t\t\tbreak;\n\t\t\t}\n\t\t}\n\t\tcout << (yes ? \"YES\" : \"NO\") << endl;\n\t}\n}"
  },
  {
    "language": "C++",
    "code": "#include <cassert>\n#include <iostream>\n\nusing namespace std;\n\n#define repi(i,a,b) for(int i=int(a);i<int(b);i++)\n#define rep(i,n) repi(i,0,n)\n\ntypedef pair<bool,int> parsed;\n\nparsed formula(const string& t,int i)\n{\n\tif(isupper(t[i]))\n\t\treturn parsed(t[i]=='T',i+1);\n\t\n\tif(t[i]=='-'){\n\t\tparsed p=formula(t,i+1);\n\t\tp.first^=1;\n\t\treturn p;\n\t}\n\tif(t[i]=='('){\n\t\tparsed p1=formula(t,i+1);\n\t\tint j=p1.second;\n\t\tif(t[j]=='-'){\n\t\t\tparsed p2=formula(t,j+2);\n\t\t\treturn parsed(p1.first<=p2.first,p2.second+1);\n\t\t}\n\t\tparsed p2=formula(t,j+1);\n\t\tif(t[j]=='*')\n\t\t\treturn parsed(p1.first&&p2.first,p2.second+1);\n\t\tif(t[j]=='+')\n\t\t\treturn parsed(p1.first||p2.first,p2.second+1);\n\t}\n\tassert(false);\n}\n\nbool solve(string s)\n{\n\trep(bit,1<<11){\n\t\tstring t;\n\t\trep(i,s.size()){\n\t\t\tif(islower(s[i]))\n\t\t\t\tt+=\"FT\"[bit>>s[i]-'a'&1];\n\t\t\telse\n\t\t\t\tt+=s[i];\n\t\t}\n\t\tparsed p1=formula(t.substr(0,t.find('=')),0);\n\t\tparsed p2=formula(t.substr(t.find('=')+1),0);\n\t\tif(p1.first!=p2.first){\n\t\t\treturn false;\n\t\t}\n\t}\n\treturn true;\n}\n\nint main()\n{\n\tfor(string s;cin>>s,s!=\"#\";)\n\t\tcout<<(solve(s)?\"YES\":\"NO\")<<endl;\n\treturn 0;\n}"
  },
  {
    "language": "C++",
    "code": "/*\n *\n * <equation> ::= <formula> \"=\" <formula>\n * <formula>  ::= \"T\" | \"F\" |\n * \"a\" | \"b\" | \"c\" | \"d\" | \"e\" | \"f\" |\n * \"g\" | \"h\" | \"i\" | \"j\" | \"k\" |\n * \"-\" <formula> |\n * \"(\" <formula> \"*\" <formula> \")\" |\n * \"(\" <formula> \"+\" <formula> \")\" |\n * \"(\" <formula> \"->\" <formula> \")\"\n */\n#include<iostream>\n#include<map>\n#include<vector>\n#include<algorithm>\n#include<cmath>\n#include<iomanip>\n#include<numeric>\n#include<climits>\n#include<ctime>\n#include<cstring>\n#include<sstream>\n#define REP(i,p,n) for(int i=p;i<(int)(n);i++)\n#define rep(i,n) REP(i,0,n)\n#define rep_split(tok,a_str,re) for(char *tok = strtok((char *)a_str.c_str(),re); tok != NULL; tok = strtok(NULL,re))\n#define ALL(c) (c).begin(), (c).end()\n#define dump(a) cerr << #a << \"=\" << (a) << endl\n#define DUMP(list) cout << \"{ \"; for(auto nth : list){ cout << nth << \" \"; } cout << \"}\" << endl;\ntemplate<class T> void chmin(T &t, T f) { if (t > f) t = f; } //t=min\ntemplate<class T> void chmax(T &t, T f) { if (t < f) t = f; } //t=max\nusing namespace std;\n\n\nvector<bool> var_pattern;\nbool equation(string& s, int& i);\nbool formula(string& s, int& i);\n\n\nbool equation(string& s, int& i)\n{\n\tbool left = formula(s,i);\n\ti++; //=\n\ti++; //formula\n\tbool right = formula(s,i);\n\n\t//cout << left << \"=\" << right << endl;\n\n\treturn left == right;\n}\n\n\nbool formula(string& s, int& i)\n{\n\tbool left=false,right=false;\t\n\tchar ope=0;\n\tbool ans = false;\n\n\tswitch(s[i])\n\t{\n\t\tcase 'T':\n\t\t\tans = true;\n\t\t\tbreak;\n\t\tcase 'F':\n\t\t\tans = false;\n\t\t\tbreak;\n\t\tcase '-':\n\t\t\ti++;\n\t\t\treturn !formula(s,i);\n\t\tcase '(':\n\t\t\ti++;\n\t\t\tleft = formula(s,i);\n\t\t\ti++; \n\t\t\tope = s[i];\n\t\t\tif (ope == '-') { i++; ope='>'; } //->\n\t\t\ti++;\n\t\t\tright = formula(s,i);\n\n\t\t\tif (ope == '*') {\n\t\t\t\tans = left * right;\t\n\t\t\t}\n\t\t\telse if (ope == '+') {\n\t\t\t\tans = left + right;\t\n\t\t\t}\n\t\t\telse if (ope == '>') {\n\t\t\t\tans = (!left) + right;\n\t\t\t}\n\t\t\ti++; //')'\n\t\t\tbreak;\n\n\t\tdefault:\n\t\t\tif ('a' <= s[i] && s[i] <= 'k') {\n\t\t\t\tint var_num = (int)(s[i] - 'a');\n\t\t\t\tans = var_pattern[var_num];\n\t\t\t}\n\t\t\t//cout << \"index=\" << var_num << \" var=\" << s[i] << endl;\n\t\t\t//cout << s[i] << \" = \" << var_pattern[var_num] << endl;\n\t\t\tbreak;\n\t}\n\n\treturn ans;\n}\n\n\n\nint main() {\n\tstring line;\n\t\n\twhile(cin >> line)\n\t{\n\t\tif (line[0] == '#') break;\n\n\t\tbool is_yes = true;\n\t\trep(j,2048) {\n\t\t\tint i=0;\n\t\t\tint num = j;\n\t\t\trep(k,11)\n\t\t\t{\n\t\t\t\tvar_pattern.push_back((num & 1));\n\t\t\t\t//cout << (num & 1) << \" \";\n\t\t\t\tnum >>= 1;\n\t\t\t}\n\t\t\t//cout << endl;\n\t\t\tif (!equation(line,i)) { is_yes = false; break; }\n\t\t\tvar_pattern.clear();\n\t\t}\n\t\tcout << (is_yes ? \"YES\" : \"NO\") << endl;\n\t\t//cout << \"-----------\" << endl;\n\t}\n\n\treturn 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include <iostream>\n#include <stdio.h>\n#include <algorithm>\n#include <vector>\n#include <queue>\n#include <numeric>\n#include <string>\n#include <string.h>\n#include <map>\n#include <set>\n#include <functional>\n#include <complex>\n#include <stack>\n#include <tuple>\n\n#define ll long long int\n\nusing namespace std;\n\nconst int INF = (1<<30) - 1;\n\nbool formula(string str, int &vals){\n    char c = str[0];\n    \n    if(c == 'T')\n        return true;\n    else if(c == 'F')\n        return false;\n    \n    if('a'<=c && c<='k')\n        return vals<<(c-'a')&1;\n    \n    //substr???string &?????¨NG?\n    if(c == '-')\n        return !formula(str.substr(1, str.size()-1), vals);\n\n    //c == '('\n    int count = 0;\n    for(int i=1; i<str.size(); i++){\n        char c = str[i];\n        \n        if(c == '(')\n            count++;\n        if(c == ')')\n            count--;\n        if(count == 0){\n            if(c == '*'){\n                int s = str.find(\"*\");\n                string left = str.substr(1, s-1);\n                string right = str.substr(s+1, str.size()-s-2);\n                return formula(left, vals) & formula(right, vals);\n            }\n            if(c == '+'){\n                int s = str.find(\"+\");\n                string left = str.substr(1, s-1);\n                string right = str.substr(s+1, str.size()-s-2);\n                return formula(left, vals) | formula(right, vals);\n            }\n            if(str[i] == '-' && str[i+1] == '>'){\n                int s = str.find(\"->\");\n                string left = str.substr(1, s-1);\n                string right = str.substr(s+2, str.size()-s-3);\n                return !(formula(left, vals)) | formula(right, vals);\n            }\n        }\n    }\n    //No Implement\n    return true;\n}\n\nint main(){\n    ios::sync_with_stdio(false);\n    cin.tie(0);\n    \n    string equation;\n    while(cin>>equation, equation!=\"#\"){\n        int s = equation.find(\"=\");\n        string left = equation.substr(0, s);\n        string right = equation.substr(s+1, equation.size()-s-1);\n        \n        bool is_identity = true;\n        for(int i=0; i<1<<11; i++){\n            is_identity &= formula(left, i)==formula(right, i);\n        }\n            \n        cout << (is_identity ? \"YES\" : \"NO\") << endl;\n    }\n    return 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include <iostream>\nusing namespace std;\ntypedef string::const_iterator State;\nstring s;\nbool assign[11];\nbool fom(State& be){\n\tif(*be=='T'){\n\t\tbe++;\n\t\treturn 1;\n\t}\n\tif(*be=='F'){\n\t\tbe++;\n\t\treturn 0;\n\t}\n\tif('a'<= *be && *be <= 'k'){\n\t\tbe++;\n\t\treturn assign[*be-'a'];\n\t}\n\tif(*be=='-'){\n\t\tbe++;\n\t\treturn !fom(be);\n\t}\n\tif(*be=='('){\n\t\tbe++;\n\t\tbool x=fom(be);\n\t\tif(*be=='+'){\n\t\t\tbe++;\n\t\t\tbool y=fom(be);\n\t\t\tbe++;\n\t\t\treturn x || y;\n\t\t}else if(*be=='*'){\n\t\t\tbe++;\n\t\t\tbool y=fom(be);\n\t\t\tbe++;\n\t\t\treturn x && y;\n\t\t}else{\n\t\t\tbe+=2;\n\t\t\tbool y=fom(be);\n\t\t\tbe++;\n\t\t\treturn ~x || y;\n\t\t}\n\t}\n}\nint main(){\n\twhile(true){\n\t\tcin >> s;\n\t\tif(s[0]=='#') break;\n\t\tbool ok=true;\n\t\tfor(int i=0;i<2048;i++){\n\t\t\tfor(int j=0;j<11;j++) assign[j]=(i>>j)&1;\n\t\t\tState be=s.begin();\n\t\t\tbool x=fom(be);\n\t\t\tbe++;\n\t\t\tbool y=fom(be);\n\t\t\tif(x!=y){\n\t\t\t\tok=false;\n\t\t\t\tbreak;\n\t\t\t}\n\t\t}\n\t\tcout << (ok ? \"YES\\n\" : \"NO\\n\");\n\t}\n}"
  },
  {
    "language": "C++",
    "code": "#include <algorithm>\n#include <cmath>\n#include <climits>\n#include <cstdio>\n#include <cstdlib>\n#include <cstring>\n#include <fstream>\n#include <iostream>\n#include <list>\n#include <map>\n#include <queue>\n#include <set>\n#include <sstream>\n#include <stack>\n#include <string>\n#include <vector>\n\nusing namespace std;\n\n#define LOG(...) printf(__VA_ARGS__)\n//#define LOG(...)\n#define FOR(i,a,b) for(int i=(a);i<(b);++i)\n#define REP(i,n) for(int i=0;i<(int)(n);++i)\n#define ALL(a) (a).begin(),(a).end()\n#define RALL(a) (a).rbegin(),(a).rend()\n#define EXIST(s,e) ((s).find(e)!=(s).end())\n#define SORT(c) sort((c).begin(),(c).end())\n#define RSORT(c) sort((c).rbegin(),(c).rend())\n#define CLR(a) memset((a), 0 ,sizeof(a))\n\ntypedef long long ll;\ntypedef unsigned long long ull;\ntypedef vector<bool> vb;\ntypedef vector<int> vi;\ntypedef vector<ll> vll;\ntypedef vector<vb> vvb;\ntypedef vector<vi> vvi;\ntypedef vector<vll> vvll;\ntypedef pair<int, int> pii;\ntypedef pair<ll, ll> pll;\n\nconst int V[11] = {\n    1 << 0,\n    1 << 1,\n    1 << 2,\n    1 << 3,\n    1 << 4,\n    1 << 5,\n    1 << 6,\n    1 << 7,\n    1 << 8,\n    1 << 9,\n    1 << 10,\n};\n\nbool parse(string expr, int var) {\n    stack<char> ops;\n    stack<bool> vals;\n    bool update = false;\n    REP(i, expr.length()) {\n        char c = expr[i];\n        switch (c) {\n        case '(':\n            update = false;\n            break;\n        case '-':\n            if (!ops.empty() && update && ops.top() == '-') {\n                ops.pop();\n            } else {\n                ops.push(c);\n            }\n            update = true;\n            break;\n        case '*':\n        case '+':\n            ops.push(c);\n            update = true;\n            break;\n        case '>':\n            ops.pop();\n            ops.push(c);\n            update = true;\n            break;\n        case 'a':\n        case 'b':\n        case 'c':\n        case 'd':\n        case 'e':\n        case 'f':\n        case 'g':\n        case 'h':\n        case 'i':\n        case 'j':\n        case 'k':\n        case 'T':\n        case 'F':\n        case ')':\n            bool b;\n            switch (c) {\n            case ')':\n                b = vals.top(); vals.pop();\n                break;\n            case 'T':\n                b = true;\n                break;\n            case 'F':\n                b = false;\n                break;\n            default:\n                b = var & V[c - 'a'];\n            }\n            if (update && !ops.empty()) {\n                bool a;\n                char op = ops.top(); ops.pop();\n                switch (op) {\n                case '-':\n                    vals.push(!b);\n                    break;\n                case '*':\n                    a = vals.top(); vals.pop();\n                    vals.push(a && b);\n                    break;\n                case '+':\n                    a = vals.top(); vals.pop();\n                    vals.push(a || b);\n                    break;\n                case '>':\n                    a = vals.top(); vals.pop();\n                    vals.push(!a || b);\n                    break;\n                }\n            } else {\n                vals.push(b);\n            }\n            break;\n        }\n    }\n    return vals.top();\n}\n\nint main() {\n    string line;\n    while (getline(cin, line), line != \"#\") {\n        int eq = line.find('=');\n        string l(line.begin(), line.begin() + eq);\n        string r(line.begin() + eq + 1, line.end());\n        bool ok = true;\n        REP(var, 2 << 12) {\n            if (parse(l, var) != parse(r, var)) {\n                ok = false;\n                break;\n            }\n        }\n        cout << (ok ? \"YES\" : \"NO\") << endl;\n    }\n}"
  },
  {
    "language": "C++",
    "code": "#include <iostream>\n#include <sstream>\n#include <algorithm>\nusing namespace std;\n\ntypedef string::const_iterator Iterator;\n\nint formula(int s, Iterator& it, const Iterator& last)\n{\n  switch (*it) {\n    case 'T':\n      ++it;\n      return 1;\n    case 'F':\n      ++it;\n      return 0;\n    case '-':\n      ++it;\n      return !formula(s, it, last);\n    case '(':\n      {\n        ++it;\n        const int l = formula(s, it, last);\n        const char op = *it;\n        ++it;\n        if (op == '-') {\n          if (*it != '>') {\n            throw \">\";\n          }\n          ++it;\n        }\n        const int r = formula(s, it, last);\n        if (*it != ')') {\n          throw \")\";\n        }\n        ++it;\n        switch (op) {\n          case '*':\n            return l && r;\n          case '+':\n            return l || r;\n          case '-':\n            return !l || r;\n          default:\n            throw \"op\";\n        }\n      }\n    default:\n      if ('a' <= *it && *it <= 'k') {\n        const char c = *it;\n        ++it;\n        return !!(s & (1<<(c-'a')));\n      } else {\n        throw \"l\";\n      }\n  }\n  throw \"eof\";\n}\n\nbool solve(const string& lhs, const string& rhs)\n{\n  for (int s = 0; s < (1<<11); s++) {\n    Iterator it = lhs.begin(), ilast = lhs.end();\n    Iterator jt = rhs.begin(), jlast = rhs.end();\n    int l = formula(s, it, ilast);\n    int r = formula(s, jt, jlast);\n    if (it != ilast) {\n      throw \"ilast\";\n    }\n    if (jt != jlast) {\n      throw \"jlast\";\n    }\n    if (l != r) {\n      return false;\n    }\n  }\n  return true;\n}\n\nint main()\n{\n  string s;\n  while (getline(cin, s) && s != \"#\") {\n    replace(s.begin(), s.end(), '=', ' ');\n    istringstream iss(s);\n    string lhs, rhs;\n    iss >> lhs >> rhs;\n    cout << (solve(lhs, rhs) ? \"YES\" : \"NO\") << endl;\n  }\n  return 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include <iostream>\n#include <algorithm>\n#include <string>\n#include <vector>\nusing namespace std;\n\nconst int INF = 1e+8;\n\n// 変数 'a' - 'k' を value に置き換え\nvoid change(string& s, char x, char value){\n\tfor(int i=0 ; i < s.size() ; i++ ){\n\t\tif( s[i] == x ) s[i] = value;\n\t}\n}\n\n// 式から \"--\" の除去\nvoid minus_erase(string& s){\n\tfor(int i=1 ; i < s.size() ; i++ ){\n\t\tif( s[i-1] == '-' && s[i] == '-' ){\n\t\t\ts.erase( i-1 , 2 );\n\t\t\ti = 0;\n\t\t}\n\t}\n}\n\n// 論理否定の計算 (\"-F\" => \"T\", \"-T\" => \"F\" の 文字列置換)\nvoid minus_calc(string& s, bool& minus_flag ){\n\tbool flag = false;\n\tif( s[0] == '-' ) flag = true;\n\t\n\tfor(int i=1 ; i < s.size() ; i++ ){\n\t\tif( s[i] == '-' ) flag = true;\n\t\t\n\t\tif( s[i-1] == '-' && s[i] == 'F' ){\n\t\t\ts.replace( i-1 , 2 , \"T\" );\n\t\t\ti = 0;\n\t\t}else if( s[i-1] == '-' && s[i] == 'T' ){\n\t\t\ts.replace( i-1 , 2 , \"F\" );\n\t\t\ti = 0;\n\t\t}\n\t}\n\tminus_flag = flag;\n}\n\n// 論理和, 論理積, 論理包含の計算 (文字列置換)\nvoid calc(string& s){\n\tstring ex[12] = {\n\t\t\"(F+F)\", \"(F+T)\", \"(T+F)\", \"(T+T)\",\n\t\t\"(F*F)\", \"(F*T)\", \"(T*F)\", \"(T*T)\",\n\t\t\"(F>F)\", \"(F>T)\", \"(T>F)\", \"(T>T)\"\n\t};\n\tstring result[12] = {\n\t\t\"F\", \"T\", \"T\", \"T\",\n\t\t\"F\", \"F\", \"F\", \"T\",\n\t\t\"T\", \"T\", \"F\", \"T\"\n\t};\n\tfor(int i=0 ; i+4 < s.size() ; i++ ){\n\t\tfor(int j=0 ; j < 12 ; j++ ){\n\t\t\tif( s.substr(i,5) == ex[j] ){\n\t\t\t\ts.replace( i , 5 , result[j] );\n\t\t\t\ti = -1;\n\t\t\t\tbreak;\n\t\t\t}\n\t\t}\n\t}\n}\n\nint main(){\n\tstring ex;\n\twhile( cin >> ex ){\n\t\tif( ex == \"#\" ) break;\n\t\t\n\t\t// \"->\" を \">\" に置き換えておく\n\t\tstring s;\n\t\tfor(int i=0 ; i < ex.size() ; i++ ){\n\t\t\tif( i+1 < ex.size() && ex[i] == '-' && ex[i+1] == '>' ){\n\t\t\t\ts.push_back( '>' );\n\t\t\t\ti++;\n\t\t\t}else{\n\t\t\t\ts.push_back( ex[i] );\n\t\t\t}\n\t\t}\n\t\t\n\t\t// '=' の左側を ex1, 右側を ex2 とする\n\t\tstring ex1, ex2;\n\t\tbool flag = false;\n\t\tfor(int i=0 ; i < s.size() ; i++ ){\n\t\t\tif( s[i] == '=' ){\n\t\t\t\tflag = true;\n\t\t\t}else if( flag ){\n\t\t\t\tex2.push_back( s[i] );\n\t\t\t}else{\n\t\t\t\tex1.push_back( s[i] );\n\t\t\t}\n\t\t}\n\t\t\n\t\t// 登場する変数('a' - 'k')をチェック\n\t\tint f[256] = {0};\n\t\tfor(int i= 0 ; i < s.size() ; i++ ){\n\t\t\tf[ s[i] ] = 1;\n\t\t}\n\t\tvector<char> vc;\n\t\tfor(char c = 'a' ; c <= 'k' ; c++ ){\n\t\t\tif( f[c] ){\n\t\t\t\tvc.push_back( c );\n\t\t\t}\n\t\t}\n\t\t// N := 登場する変数の種類.\n\t\tint N = vc.size();\n\t\t\n\t\t// 変数の置き換えを 2^N 通り試し すべての式の評価で右辺と左辺が等しいか調べる.\n\t\tbool ans = true;\n\t\tfor(int bits = 0 ; bits < (1<<N) ; bits++ ){\n\t\t\tstring ex1_ = ex1;\n\t\t\tstring ex2_ = ex2;\n\t\t\t// 変数を \"T\" or \"F\" に置き換えておく\n\t\t\tfor(int i=0 ; i < N ; i++ ){\n\t\t\t\t// i 番目の文字を'T' か 'F'にしておく\n\t\t\t\tif( bits & (1<<i) ){\n\t\t\t\t\tchange( ex1_ , vc[i] , 'T' );\n\t\t\t\t\tchange( ex2_ , vc[i] , 'T' );\n\t\t\t\t}else{\n\t\t\t\t\tchange( ex1_ , vc[i] , 'F' );\n\t\t\t\t\tchange( ex2_ , vc[i] , 'F' );\n\t\t\t\t}\n\t\t\t}\n\t\t\t// \"--\" の除去\n\t\t\tminus_erase( ex1_ );\n\t\t\tminus_erase( ex2_ );\n\t\t\t\n\t\t\t// 式 ex1 が \"T\" か \"F\" になるまで文字列置換を繰り返す.\n\t\t\tbool minus_flag = true;\n\t\t\twhile( ex1_.size() > 1 ){\n\t\t\t\tif( minus_flag ) minus_calc( ex1_ , minus_flag );\n\t\t\t\tcalc( ex1_ );\n\t\t\t}\n\t\t\t// 式 ex2 が \"T\" か \"F\" になるまで文字列置換を繰り返す.\n\t\t\tminus_flag = true;\n\t\t\twhile( ex2_.size() > 1 ){\n\t\t\t\tif( minus_flag ) minus_calc( ex2_ , minus_flag );\n\t\t\t\tcalc( ex2_ );\n\t\t\t}\n\t\t\t// 式 ex1 と 式 ex2 が等しいかどうか\n\t\t\tif( ex1_ != ex2_ ) ans = false;\n\t\t}\n\t\t// 出力 \n\t\tif( ans ){\n\t\t\tcout << \"YES\" << endl;\n\t\t}else{\n\t\t\tcout << \"NO\" << endl;\n\t\t}\n\t}\n}"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\nusing namespace std;\n\n#define INF_LL (int64)1e18\n#define INF (int32)1e9\n#define REP(i, n) for(int64 i = 0;i < (n);i++)\n#define FOR(i, a, b) for(int64 i = (a);i < (b);i++)\n#define all(x) x.begin(),x.end()\n#define fs first\n#define sc second\n\nusing int32 = int_fast32_t;\nusing uint32 = uint_fast32_t;\nusing int64 = int_fast64_t;\nusing uint64 = uint_fast64_t;\nusing PII = pair<int32, int32>;\nusing PLL = pair<int64, int64>;\n\nconst double eps = 1e-10;\n\ntemplate<typename A, typename B>inline void chmin(A &a, B b){if(a > b) a = b;}\ntemplate<typename A, typename B>inline void chmax(A &a, B b){if(a < b) a = b;}\n\nbool equation(string& s, int32& p, int32& v);\nbool formula(string& s, int32& p, int32& v);\n\nbool equation(string& s, int32& p, int32& v){\n\tbool l = formula(s, p, v);\n\tassert(s[p] == '=');\n\tp++;\n\tbool r = formula(s, p, v);\n\treturn l==r;\n}\n\nbool formula(string& s, int32& p, int32& v){\n\tbool ret = 0;\n\tif(s[p] == '-'){\n\t\tp++;\n\t\tret = !formula(s, p, v);\n\t}else if(s[p] == '('){\n\t\tp++;\n\t\tbool l = formula(s, p, v);\n\t\tchar op = s[p++];\n\t\tif(op == '-') p++;\n\t\tbool r = formula(s, p, v);\n\t\tp++;\n\t\tif(op == '*')\n\t\t\tret = l&r;\n\t\telse if(op == '+')\n\t\t\tret = l|r;\n\t\telse\n\t\t\tret = (!l || l&r);\n\t}else{\n\t\tchar c = s[p++];\n\t\tif(c == 'T') return 1;\n\t\tif(c == 'F') return 0;\n\t\treturn (v >> (c-'a'))&1;\n\t}\n\treturn ret;\n}\n\nint main(void){\n\tstring s;\n\twhile(cin >> s && s != \"#\"){\n\t\tint32 p = 0;\n\t\tint32 mask = 0;\n\t\tREP(i, s.size()){\n\t\t\tif(isalpha(s[i]))\n\t\t\t\tmask |= 1 << (s[i]-'a');\n\t\t}\n\t\tbool res = 1;\n\t\tfor(int32 i = mask;i >= 0;i--){\n\t\t\ti &= mask;\n\t\t\tp = 0;\n\t\t\tres = res&equation(s, p, i);\n\t\t}\n\t\tif(res)\n\t\t\tcout << \"YES\" << endl;\n\t\telse\n\t\t\tcout << \"NO\" << endl;\n\t}\n}\n"
  },
  {
    "language": "C++",
    "code": "#include <iostream>\n#include <string>\n#include <sstream>\n\nusing namespace std;\nint bits;\nchar str[100];\nchar *sp;\n\nint formula(){\n\tchar c;\n\tc=*sp++;\n\tif('a'<=c&&c<'k') return bits>>(c-'a')&1;\n\tif(c=='T') return 1;\n\tif(c=='F') return 0;\n\tif(c=='-') return !formula();\n\tif(c=='('){\n\t\tint left, right;\n\t\tchar ope;\n\t\tleft = formula();\n\t\tope = *sp++;\n\t\tif(ope=='-') sp++;\n\t\tright = formula();\n\t\tsp++;\n\t\tif(ope=='*') return  left && right;\n\t\tif(ope=='+') return  left || right;\n\t\tif(ope=='-') return !left || right;\n\t}\n\treturn 0;\n}\n\nint equation(){\n\tint left,right;\n\tleft=formula();\n\tsp++;\n\tright=formula();\n\treturn left==right;\n}\n\nint main(){\n\twhile(cin>>str, *str!='#'){\n\t\tfor(bits=0;bits<2<<11;bits++){\n\t\t\tsp = str;\n\t\t\tif(!equation()) break;\n\t\t}\n\t\tcout<<(bits<2<<11?\"NO\":\"YES\")<<endl;\n\t}\n}"
  },
  {
    "language": "C++",
    "code": "#include<bits/stdc++.h>\n#define rep(i,n)for(int i=0;i<(n);i++)\nusing namespace std;\n\nint equ(string&, int&);\nint form(string&, int&);\nint q(string&, int&);\n\nint equ(string&s, int&i) {\n\tint v1 = form(s, i); i++;\n\tint v2 = form(s, i);\n\treturn v1 == v2;\n}\nint form(string&s, int&i) {\n\tint v = q(s, i);\n\twhile (s[i] == '>' || s[i] == '*' || s[i] == '+') {\n\t\tchar op = s[i++];\n\t\tint v2 = q(s, i);\n\t\tif (op == '>')v = (!v || v2);\n\t\tif (op == '*')v = (v&&v2);\n\t\tif (op == '+')v = (v || v2);\n\t}\n\treturn v;\n}\nint q(string&s, int&i) {\n\tif (s[i] == 'T' || s[i] == 'F')return s[i++] == 'T';\n\tif (s[i] == '-') {\n\t\ti++; return !q(s, i);\n\t}\n\ti++; int ret = form(s, i); i++;\n\treturn ret;\n}\nint main() {\n\tstring buf;\n\twhile (cin >> buf, buf != \"#\") {\n\t\tstring s;\n\t\trep(i, buf.size()) {\n\t\t\tif (buf[i] == '-'&&buf[i + 1] == '>')s += '>', i++;\n\t\t\telse s += buf[i];\n\t\t}\n\t\tmap<char, char>mp;\n\t\tfor (char c : s) {\n\t\t\tif (islower(c))mp[c];\n\t\t}\n\t\trep(i, 1 << mp.size()) {\n\t\t\tstring t = s;\n\t\t\tint j = 0;\n\t\t\tfor (auto&p : mp)p.second = ((i >> (j++) & 1) ? 'T' : 'F');\n\t\t\tfor (char&c : t) {\n\t\t\t\tif (islower(c))c = mp[c];\n\t\t\t}\n\t\t\tj = 0;\n\t\t\tif (!equ(t, j)) { puts(\"NO\"); goto g; }\n\t\t}\n\t\tputs(\"YES\");\n\tg:;\n\t}\n}"
  },
  {
    "language": "C++",
    "code": "#include <algorithm>\n#include <cmath>\n#include <climits>\n#include <cstdio>\n#include <cstdlib>\n#include <cstring>\n#include <fstream>\n#include <iostream>\n#include <list>\n#include <map>\n#include <queue>\n#include <set>\n#include <sstream>\n#include <stack>\n#include <string>\n#include <vector>\n#include <cassert>\n#include <functional>\n\nusing namespace std;\n\n#define LOG(...) printf(__VA_ARGS__)\n//#define LOG(...)\n#define FOR(i,a,b) for(int i=(int)(a);i<(int)(b);++i)\n#define REP(i,n) for(int i=0;i<(int)(n);++i)\n#define ALL(a) (a).begin(),(a).end()\n#define RALL(a) (a).rbegin(),(a).rend()\n#define EXIST(s,e) ((s).find(e)!=(s).end())\n#define SORT(c) sort((c).begin(),(c).end())\n#define RSORT(c) sort((c).rbegin(),(c).rend())\n#define CLR(a) memset((a), 0 ,sizeof(a))\n\ntypedef long long ll;\ntypedef unsigned long long ull;\ntypedef vector<bool> vb;\ntypedef vector<int> vi;\ntypedef vector<ll> vll;\ntypedef vector<vb> vvb;\ntypedef vector<vi> vvi;\ntypedef vector<vll> vvll;\ntypedef pair<int, int> pii;\ntypedef pair<ll, ll> pll;\n\nconst int dx[] = { -1, 0, 1, 0 }; const int dy[] = { 0, 1, 0, -1 };\n\nstruct UnionFind {\n\tvector<int> v;\n\tUnionFind(int n) : v(n) { for (int i = 0; i < n; i++) v[i] = i; }\n\tint  find(int x) { return v[x] == x ? x : v[x] = find(v[x]); }\n\tvoid unite(int x, int y) { v[find(x)] = find(y); }\n};\nbool cal(string &s, int &idx) {\n\tbool res = true;\n\tbool sub = false;\n\twhile (idx < (int)s.length()) {\n\t\tif (s[idx] == '(') {\n\t\t\tidx++;\n\t\t\tif (sub)\n\t\t\t\treturn !cal(s, idx);\n\t\t\telse\n\t\t\t\treturn cal(s, idx);\n\t\t}\n\t\tif (s[idx] == '-') {\n\t\t\tsub = !sub;\n\t\t\tidx++;\n\t\t}\n\t\tif (s[idx] == 'T' || s[idx] == 'F') {\n\t\t\tbool st1 = (s[idx] == 'T' && !sub) || (s[idx] == 'F' && sub);\n\t\t\tidx++;\n\t\t\tsub = false;\n\t\t\tint calc;\n\t\t\tif (s[idx] == '*')\n\t\t\t\tcalc = 0;\n\t\t\tif (s[idx] == '+')\n\t\t\t\tcalc = 1;\n\t\t\tif (s[idx] == '>')\n\t\t\t\tcalc = 2;\n\t\t\tidx++;\n\t\t\tif (s[idx] == '-') {\n\t\t\t\tsub = !sub;\n\t\t\t\tidx++;\n\t\t\t}\n\t\t\tbool st2;\n\t\t\tif (s[idx] == 'T' || s[idx] == 'F') {\n\t\t\t\tst2 = (s[idx] == 'T' && !sub) || (s[idx] == 'F' && sub);\n\t\t\t}\n\t\t\telse {\n\t\t\t\tidx++;\n\t\t\t\tst2 = cal(s, idx);\n\t\t\t}\n\t\t\tif (calc == 0)\n\t\t\t\tres = st1&&st2;\n\t\t\tif (calc == 1)\n\t\t\t\tres = st1 || st2;\n\t\t\tif (calc == 2)\n\t\t\t\tres = !(st1 && !st2);\n\t\t\tidx++;\n\t\t\treturn res;\n\t\t}\n\t\tif (s[idx] == ')') {\n\t\t\tidx++;\n\t\t\treturn res;\n\t\t}\n\t}\n\treturn res;\n}\n\n\nint main() {\n\tstring s;\n\twhile (cin >> s, s != \"#\") {\n\t\tstring ans = \"YES\";\n\t\tauto pos = s.find(\"->\");\n\t\twhile (pos != string::npos) {\n\t\t\ts.replace(pos, 2, \">\");\n\t\t\tpos = s.find(\"->\", pos + 1);\n\t\t}\n\t\tpos = s.find(\"--\");\n\t\twhile (pos != string::npos) {\n\t\t\ts.replace(pos, 2, \"\");\n\t\t\tpos = s.find(\"--\", pos + 1);\n\t\t}\n\t\tint eq;\n\t\tREP(k, s.length())\n\t\t\tif (s[k] == '=')\n\t\t\t\teq = k;\n\n\t\tREP(i, 2048) {\n\t\t\tstring s2 = s;\n\t\t\tREP(j, 11) {\n\t\t\t\tREP(k, s2.length()) {\n\t\t\t\t\tif (s2[k] == 'a' + j)\n\t\t\t\t\t\tif ((i >> j) & 1) {\n\t\t\t\t\t\t\ts2[k] = 'T';\n\t\t\t\t\t\t}\n\t\t\t\t\t\telse {\n\t\t\t\t\t\t\ts2[k] = 'F';\n\t\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t}\n\t\t\tint idx1 = 0, idx2 = 0;\n\t\t\tif (cal(s2.substr(0, eq), idx1) != cal(s2.substr(eq + 1, s2.length() - eq - 1), idx2)) {\n\t\t\t\tans = \"NO\";\n\t\t\t\tbreak;\n\t\t\t}\n\t\t}\n\t\tcout << ans << endl;\n\t}\n}"
  },
  {
    "language": "C++",
    "code": "#include <iostream>\n#include <algorithm>\n#include <cmath>\n#include <cstdio>\n#include <vector>\n#include <set>\n#include <map>\n#include <string>\n#include <complex>\n#include <sstream>\n\nusing namespace std;\n\ntypedef long long lli;\n\nint data;\n\nbool formula(string str){\n  if(str.size() == 1){\n    if(str[0] == 'T') return true;\n    if(str[0] == 'F') return false;\n    int p = str[0] - 'a';\n    return (1 << p) & data;\n  }\n  if(str[0] == '-') return formula(str.substr(1)) ? false : true;\n  int l = 1;\n  for(int i=1;i<(int)str.size()-1;i++){\n    if(str[i] == '(') l++;\n    if(str[i] == ')') l--;\n    if(l == 1){\n      if(str[i] == '*'){\n        bool a = formula(str.substr(1, i-1));\n        bool b = formula(str.substr(i+1, (int)str.size() - (i+2)));\n        if(a && b) return true;\n        else return false;\n      }\n      if(str[i] == '+'){\n        bool a = formula(str.substr(1, i-1));\n        bool b = formula(str.substr(i+1, (int)str.size() - (i+2)));\n        if(a || b) return true;\n        else return false;\n      }\n      if(str[i] == '-' && str[i+1] == '>'){\n        bool a = formula(str.substr(1, i-1));\n        bool b = formula(str.substr(i+2, (int)str.size() - (i+3)));\n        if(a) return b;\n        else return true;\n      }\n    }\n  }\n}\n\nbool solve(string a, string b){\n  for(int i=0;i<(1<<11);i++){\n    data = i;\n    if(formula(a) != formula(b)) return false;\n  }\n  return true;\n}\n\nmain(){\n  string str;\n  while(cin >> str){\n    if(str == \"#\") break;\n    string a, b;\n    for(int i=0;i<str.size();i++){\n      if(str[i] == '='){\n        a = str.substr(0, i);\n        b = str.substr(i+1);\n        break;\n      }\n    }\n    cout << (solve(a, b) ? \"YES\" : \"NO\") << endl;\n  }\n}"
  },
  {
    "language": "C++",
    "code": "#include <vector>\n#include <iostream>\n#include <utility>\n#include <algorithm>\n#include <string>\n#include <deque>\n#include <queue>\n#include <functional>\n#include <cmath>\n#include <iomanip>\n#include <map>\n#include <numeric>\n#include <list>\n#include <assert.h>\n#include <math.h>\n#include <valarray>\n#include <stdio.h>\n#include <algorithm>\n#include <set>\n#include <complex>\n#include <list>\n\nusing namespace std;\ntypedef long long int LL;\ntypedef pair<long long int, long long int> pii;\ntypedef pair<double, double> pdd;\n\n#define SORT(c) sort((c).begin(),(c).end())\n#define BACKSORT(c) sort((c).begin(),(c).end(),std::greater<LL>())\n#define FOR(i,a,b) for(LL i=(a);i<(b);++i)\n#define REP(i,n)  FOR(i,0,n)\n\nbool equation(string& s, int& i,vector<bool>& v);\nbool formula(string& s, int& i, vector<bool>& v);\n\nbool equation(string& s, int& i, vector<bool>& v) {\n\tbool a = formula(s, i,v);\n\ti++;\n\tbool b = formula(s, i, v);\n\treturn a == b;\n}\n\nbool formula(string& s, int& i, vector<bool>& v) {\n\tif (s[i] == 'T') {\n\t\ti++;\n\t\treturn true;\n\t}\n\telse\n\t\tif (s[i] == 'F') {\n\t\t\ti++;\n\t\t\treturn false;\n\n\t\t}else\n\t\t\tif ('a' <= s[i] && s[i] <= 'k') {\n\t\t\t\tint aa = s[i] - 'a';\n\t\t\t\ti++;\n\t\t\t\treturn v[aa];\n\t\t\t}else\n\t\t\t\tif (s[i] == '-') {\n\t\t\t\t\ti++;\n\t\t\t\t\tbool a = formula(s, i, v);\n\t\t\t\t\treturn !a;\n\t\t\t\t}\n\t\t\t\telse {\n\t\t\t\t\ti++;\n\t\t\t\t\tbool a = formula(s, i, v);\n\t\t\t\t\tchar op = s[i];\n\t\t\t\t\tif (op == '-') {\n\t\t\t\t\t\ti++;\n\t\t\t\t\t}\n\t\t\t\t\ti++;\n\t\t\t\t\tbool b = formula(s, i, v);\n\t\t\t\t\ti++;\n\t\t\t\t\tif (op == '*') {\n\t\t\t\t\t\treturn a&&b;\n\t\t\t\t\t}else\n\t\t\t\t\t\tif (op == '+') {\n\t\t\t\t\t\t\treturn a || b;\n\t\t\t\t\t\t}\n\t\t\t\t\t\telse {\n\t\t\t\t\t\t\treturn (!a) || b;\n\t\t\t\t\t\t}\n\t\t\t\t}\n}\n\n\nint main()\n{\n\twhile (true) {\n\t\tstring ss;\n\t\tcin >> ss;\n\t\tif (ss[0] == '#') { break; }\n\t\tbool flag = true;\n\t\tfor (int j = 0; j < 2048; ++j) {\n\t\t\tint bai = 1;\n\t\t\tfor (int k = 0; k < 11; ++k) {\n\t\t\t\tvector<bool> v(9999,false);\n\t\t\t\tif (j%(bai*2)-j%(bai*1)==0) {\n\t\t\t\t\tv[k] = false;\n\t\t\t\t}\n\t\t\t\telse {\n\t\t\t\t\tv[k] = true;\n\t\t\t\t}\n\t\t\t\tint index = 0;\n\t\t\t\tif (!equation(ss, index, v)) {\n\t\t\t\t\tflag = false;\n\t\t\t\t\tbreak;\n\t\t\t\t\t}\n\t\t\t}\n\t\t}\n\t\tif (flag) {\n\t\t\tcout << \"YES\" << endl;\n\t\t}\n\t\telse {\n\t\t\tcout << \"NO\" << endl;\n\t\t}\n\t}\n\n}"
  },
  {
    "language": "C++",
    "code": "#include \"bits/stdc++.h\"\nusing namespace std;\ntypedef long long ll;\ntypedef pair<int,int> pii;\n#define rep(i,n) for(ll i=0;i<(ll)(n);i++)\n#define all(a)  (a).begin(),(a).end()\n#define pb push_back\n#define INF (1e9+1)\n//#define INF (1LL<<59)\n\ntypedef string::const_iterator State;\n\n\nstring getop(State &begin){\n\tif(*begin=='*'){\n\t\tbegin++;\n\t\treturn \"*\";\n\t}\n\telse if(*begin=='+'){\n\t\tbegin++;\n\t\treturn \"+\";\n\t}else{\n\t\tbegin++;\n\t\tbegin++;\n\t\treturn \"->\";\n\t}\n}\n\n\nbool mul(bool a,bool b){\n\tif(a&&b)return true;\n\telse return false;\n}\n\n\nbool add(bool a,bool b){\n\tif(!a&&!b)return false;\n\telse return true;\n}\n\n\nbool imp(bool a,bool b){\n\tif(a&&!b)return false;\n\telse return true;\n}\n\n\nbool exp(State &begin){\n\tif(isdigit(*begin)){\n\t\tint num = *begin-'0';\n\t\tbegin++;\n\t\treturn num;\n\t}\n\telse if(*begin=='-'){\n\t\tbegin++;\n\t\treturn !exp(begin);\n\t}else if(*begin=='('){\n\t\tbegin++;\n\t\tbool ll = exp(begin);\n\t\tstring op = getop(begin);\n\t\tbool rr = exp(begin);\n\t\tbegin++;\n\t\t\n\t\tif(op==\"*\")return mul(ll,rr);\n\t\telse if(op==\"+\")return add(ll,rr);\n\t\telse return imp(ll,rr);\n\t}\n\t\n\tassert(1);\n\treturn 0;\n}\n\n\nbool check(string s){\n\tstring left=\"\",right=\"\";\n\tbool f=false;\n\trep(i,s.size()){\n\t\tif(s[i]=='=')f=true;\n\t\telse if(f)right+=s[i];\n\t\telse left+=s[i];\n\t}\n\t\n\tState bl = left.begin(),br = right.begin();\n\tbool l = exp(bl);\n\tbool r = exp(br);\n\t\n\tif(l==r)return true;\n\telse return false;\n}\n\n\nint main(){\n\tstring s;\n\twhile(cin>>s&&s!=\"#\"){\n\t\tset<char> var;\n\t\tint c=0;\n\t\trep(i,s.size()){\n\t\t\tif(isalpha(s[i])){\n\t\t\t\tvar.insert(s[i]);\n\t\t\t}\n\t\t}\n\t\t\n\t\t\n\t\tbool f = false;\n\t\tint en = 1<<var.size();\n\t\trep(i,en){\n\t\t\tmap<char,int> mp;\n\t\t\tint num = i;\n\t\t\tfor(auto &e:var){\n\t\t\t\tmp[e] = num%2;\n\t\t\t\tnum/=2;\n\t\t\t}\n\t\t\tstring t = s;\n\t\t\trep(j,t.size()){\n\t\t\t\tif( isalpha(t[j]) ){\n\t\t\t\t\tt[j] = '0'+mp[t[j]];\n\t\t\t\t}\n\t\t\t}\n\t\t\tif(check(t)==false)f=true;\n\t\t}\n\t\tif(f)cout<<\"NO\"<<endl;\n\t\telse cout<<\"YES\"<<endl;}\n}"
  },
  {
    "language": "C++",
    "code": "#include<cstdio>\n#include<cstdlib>\n#include<cstring>\n#include<cmath>\n#include<cctype>\n#include<climits>\n#include<iostream>\n#include<string>\n#include<vector>\n#include<map>\n//#include<list>\n#include<queue>\n#include<deque>\n#include<algorithm>\n//#include<numeric>\n#include<utility>\n#include<complex>\n//#include<memory>\n#include<functional>\n#include<cassert>\n\nconst int dx[] = {1, 0, -1, 0};\nconst int dy[] = {0, 1, 0, -1};\nusing namespace std;\ntypedef long long ll;\ntypedef vector<int> vi;\ntypedef vector<ll> vll;\ntypedef pair<int, int> pii;\ntypedef complex<double> C;\n\ntypedef string::const_iterator State;\n\nbool formula(State& begin, int S);\nbool TF(State& begin, int S);\n\nvoid consume(State& begin, char expected) {\n    if (*begin == expected) {\n        begin++;\n    } else {\n        cerr << \"Expected '\" << expected << \"' but got '\" << *begin << \"'\" << endl;\n        cerr << \"Rest string is '\";\n        while (*begin) {\n            cerr << *begin++;\n        }\n        cerr << \"'\" << endl;\n        exit(1);\n    }\n}\n\nbool formula(State& begin, int S) {\n    if (*begin == '-') {\n        begin++;\n        return !formula(begin, S);\n    } else if (*begin == '(') {\n        consume(begin, '(');\n        bool ret = formula(begin, S);\n        if (*begin == '*') {\n            consume(begin, '*');\n            ret &= formula(begin, S);\n            consume(begin, ')');\n            return ret;\n        } else if (*begin == '+') {\n            consume(begin, '+');\n            ret |= formula(begin, S);\n            consume(begin, ')');\n            return ret;\n        } else {\n            consume(begin, '-');\n            consume(begin, '>');\n            bool tmp = formula(begin, S);\n            if (ret == true && tmp == false) ret = false;\n            else ret = true;\n            consume(begin, ')');\n            return ret;\n        }\n    } else {\n        return TF(begin, S);\n    }\n}\n\nbool TF(State& begin, int S) {\n    if (*begin == 'T') {\n        consume(begin, 'T');\n        return true;\n    }\n    if (*begin == 'F') {\n        consume(begin, 'F');\n        return false;\n    }\n    int tmp = *begin - 'a';\n    begin++;\n    return ((S>>tmp)&1) == 1;\n}\n\nint main() {\n    cin.tie(0);\n    ios::sync_with_stdio(false);\n    while (1) {\n        bool ng = false;\n        string s;\n        cin >> s;\n        if (s == \"#\") break;\n        for (int i = 0; i < 2048; i++) {\n            State begin1 = s.begin(), begin2;\n            for (begin2 = s.begin(); ; begin2++) {\n                if (*begin2 == '=') {\n                    begin2++;\n                    break;\n                }\n            }\n            if (formula(begin1, i) != formula(begin2, i)) {\n                ng = true;\n                break;\n            }\n        }\n        if (ng) {\n            cout << \"NO\" << endl;\n        } else {\n            cout << \"YES\" << endl;\n        }\n    }\n    return 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\n\nusing namespace std;\n\nint f = 0;\n\nstring str;\nint pos;\n\nbool formula() {\n\tbool res;\n\tif (str[pos] == '-') {\n\t\t++pos;\n\t\tres = !formula();\n\t}\n\telse if (str[pos] == '(') {\n\t\t++pos;\n\t\tbool left = formula();\n\t\tchar c = str[pos]; if (c == '-') ++pos;\n\t\t++pos;\n\t\tbool right = formula();\n\t\t++pos;\n\n\t\tif (c == '*') res = left && right;\n\t\telse if (c == '+') res = left || right;\n\t\telse if (c == '-') res = !left || right;\n\t\telse assert(false);\n\t}\n\telse if (str[pos] == 'T') {\n\t\t++pos;\n\t\tres = true;\n\t}\n\telse if (str[pos] == 'F') {\n\t\t++pos;\n\t\tres = false;\n\t}\n\telse if ('a' <= str[pos] && str[pos] <= 'k') {\n\t\tint id = (int)(str[pos] - 'a');\n\t\tres = (f & (1 << id)) != 0;\n\t\t++pos;\n\t}\n\telse {\n\t\tassert(false);\n\t}\n\treturn res;\n}\n\nbool parse() {\n\tpos = 0;\n\tbool left = formula();\n\tassert(str[pos] == '=');\n\t++pos;\n\tbool right = formula();\n\treturn left == right;\n}\n\nint main() {\n\twhile ( cin >> str, str != \"#\" ) {\n\t\tbool ans = true;\n\t\tfor (int i = 0; i < (1 << 11); ++i) {\n\t\t\tf = i;\n\t\t\tif ( !parse() ) {\n\t\t\t\tans = false;\n\t\t\t\tbreak;\n\t\t\t}\n\t\t}\n\t\tif (ans) cout << \"YES\" << endl;\n\t\telse cout << \"NO\" << endl;\n\t}\n}"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\n#define rep(i,n) for(int i=0;i<n;i++)\n#define all(x) (x).begin(),(x).end()\nusing namespace std;\nconst int INF=1145141919,MOD=1e9+7;\nconst long long LINF=8931145141919364364,LMOD=998244353;\ninline long long mod(long long n,long long m){return(n%m+m)%m;}\n// const int dx[]={1,0,-1,0,1,1,-1,-1},dy[]={0,-1,0,1,1,-1,-1,1};\n\ntemplate<class T>\nstruct Parser{\n    typedef string::const_iterator itr;\n    itr begin;\n    vector<bool> TF;\n    T ans;\n    Parser(const string &s,const vector<bool> &TF):TF(TF){\n        begin=s.begin();\n        ans=expr(begin);\n    }\n    T expr(itr &begin){\n        if(*begin=='-'){\n            consume(begin,'-');\n            return !expr(begin);\n        }\n        else if(*begin=='('){\n            consume(begin,'(');\n            T ret=expr(begin);\n            if(*begin=='*'){\n                consume(begin,'*');\n                ret&=expr(begin);\n            }\n            if(*begin=='+'){\n                consume(begin,'+');\n                ret|=expr(begin);\n            }\n            if(*begin=='-'&&*(begin+1)=='>'){\n                consume(begin,'-');\n                consume(begin,'>');\n                ret=(!ret|expr(begin));\n            }\n            consume(begin,')');\n            return ret;\n        }else{\n            if(*begin=='T'){\n                consume(begin,'T');\n                return true;\n            }\n            if(*begin=='F'){\n                consume(begin,'F');\n                return false;\n            }\n            char tmp=*begin;\n            begin++;\n            return TF[tmp-'a'];\n        }\n    }\n    void consume(itr &begin,char expected){\n        if(*begin==expected){\n            begin++;\n        }else{\n            fprintf(stderr,\"Expected: '%c' Got: '%c'\\n\",expected,*begin);\n            fprintf(stderr,\"Rest string is \");\n            while(*begin){\n                fprintf(stderr,\"%c\",*begin++);\n            }\n        }\n    }\n};\n\nint main(){\n    string s;\n    while(cin>>s&&s!=\"#\"){\n        string s1,s2;\n        for(int i=0;;i++){\n            if(s[i]=='='){\n                s1=s.substr(0,i);\n                s2=s.substr(i+1);\n                break;\n            }\n        }\n        bool flg=1;\n        for(int i=0;i<(1<<11);i++){\n            vector<bool> TF(11);\n            for(int j=0;j<11;j++){\n                TF[j]=(i>>j&1);\n            }\n            Parser<bool> p1(s1,TF);\n            Parser<bool> p2(s2,TF);\n            if(p1.ans!=p2.ans){\n                cout<<\"NO\"<<endl;\n                flg=0;\n                break;\n            }\n        }\n        if(flg) cout<<\"YES\"<<endl;\n    }\n    return 0;\n}\n\n"
  },
  {
    "language": "C++",
    "code": "#include<iostream>\n#include<string>\n#define MAX 11\nusing namespace std;\nbool o;\nvoid rec(string s){\n  if(!o) return;\n  //cout << s << endl;\n  bool f;\n  int p;\n\n  \n  if(s.find(\"-0\")!=-1){\n    p=s.find(\"-0\");\n    //s[p]='1';s[p+1]=' ';\n    f=true;\n  }\n  if(s.find(\"-1\")!=-1){\n    p=s.find(\"-1\");\n    //s[p]='0';s[p+1]=' ';\n    f=true;\n  }\n  \n  /*\n  while(s.find(\"(0*0)\")!=-1){\n    p=s.find(\"(0*0)\");\n    s[p]='0';s[p+1]=' ';s[p+2]=' ';s[p+3]=' ';s[p+4]=' ';\n    f=true;\n  }\n  while(s.find(\"(0*1)\")!=-1){\n    p=s.find(\"(0*1)\");\n    s[p]='0';s[p+1]=' ';s[p+2]=' ';s[p+3]=' ';s[p+4]=' ';\n    f=true;\n  }\n  while(s.find(\"(1*0)\")!=-1){\n    p=s.find(\"(1*0)\");\n    s[p]='0';s[p+1]=' ';s[p+2]=' ';s[p+3]=' ';s[p+4]=' ';\n    f=true;\n  }\n  while(s.find(\"(1*1)\")!=-1){\n    p=s.find(\"(1*1)\");\n    s[p]='1';s[p+1]=' ';s[p+2]=' ';s[p+3]=' ';s[p+4]=' ';\n    f=true;\n  }\n  while(s.find(\"(0+0)\")!=-1){\n    p=s.find(\"(0+0)\");\n    s[p]='0';s[p+1]=' ';s[p+2]=' ';s[p+3]=' ';s[p+4]=' ';\n    f=true;\n  }\n  while(s.find(\"(0+1)\")!=-1){\n    p=s.find(\"(0+1)\");\n    s[p]='1';s[p+1]=' ';s[p+2]=' ';s[p+3]=' ';s[p+4]=' ';\n    f=true;\n  }\n  while(s.find(\"(1+0)\")!=-1){\n    p=s.find(\"(1+0)\");\n    s[p]='1';s[p+1]=' ';s[p+2]=' ';s[p+3]=' ';s[p+4]=' ';\n    f=true;\n  }\n  while(s.find(\"(1+1)\")!=-1){\n    p=s.find(\"(1+1)\");\n    s[p]='1';s[p+1]=' ';s[p+2]=' ';s[p+3]=' ';s[p+4]=' ';\n    f=true;\n  }\n  \n  while(s.find(\"(0->0)\")!=-1){\n    p=s.find(\"(0->0)\");\n    s[p]='1';s[p+1]=' ';s[p+2]=' ';s[p+3]=' ';s[p+4]=' ';s[p+5]=' ';\n    f=true;\n  }\n  while(s.find(\"(0->1)\")!=-1){\n    p=s.find(\"(0->1)\");\n    s[p]='1';s[p+1]=' ';s[p+2]=' ';s[p+3]=' ';s[p+4]=' ';s[p+5]=' ';\n    f=true;\n  }\n  while(s.find(\"(1->0)\")!=-1){\n    p=s.find(\"(1->0)\");\n    s[p]='0';s[p+1]=' ';s[p+2]=' ';s[p+3]=' ';s[p+4]=' ';s[p+5]=' ';\n    f=true;\n  }\n  while(s.find(\"(1->1)\")!=-1){\n    p=s.find(\"(1->1)\");\n    s[p]='1';s[p+1]=' ';s[p+2]=' ';s[p+3]=' ';s[p+4]=' ';s[p+5]=' ';\n    f=true;\n  }\n  */\n  if(f){\n    string b;\n    for(int i=0;i<s.size();i++) if(s[i]!=' ') b+=s[i];\n    rec(b);\n  }else{\n    if(s[0]!=s[2]) o=false;\n    return;\n  }\n}\nvoid init(int n,string s){\n  int i,j;\n  for(i=0;i<s.size();i++){\n    for(j=0;j<=MAX;j++){\n      if(s[i]=='a'+j) s[i]='0'+(n>>j&1);\n      if(s[i]=='T') s[i]='1';\n      if(s[i]=='F') s[i]='0';\n    }\n  }\n  rec(s);\n}\nint main(){\n  string s;\n  while(cin >> s,s!=\"#\"){\n    o=true;\n    int i;\n    for(i=0;i<(1<<MAX);i++)\n      init(i,s);\n    cout << (o?\"YES\":\"NO\") << endl;\n  }\n  return 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include <cstdio>\n\nusing namespace std;\n\nbool c[11];\nchar str[1001];\nint p;\n\nbool formula()\n{\n    bool a;\n    if (str[p] == 'T') {\n        a = true;\n        ++p;\n    } else if (str[p] == 'F') {\n        a = false;\n        ++p;\n    } else if ('a' <= str[p] && str[p] <= 'k') {\n        a = c[str[p] - 'a'];\n        ++p;\n    } else if (str[p] == '-' && str[p + 1] != '>') {\n        ++p;\n        a = !formula();\n    } else {\n        ++p;\n        bool l = formula();\n        if (str[p] == '*') {\n            ++p;\n            bool r = formula();\n            a = l && r;\n        } else if (str[p] == '+') {\n            ++p;\n            bool r = formula();\n            a = l || r;\n        } else if (str[p] == '-' && str[p + 1] == '>') {\n            p += 2;\n            bool r = formula();\n            a = !l || r;\n        }\n        ++p;\n    }\n    return a;\n}\n\nbool equation()\n{\n    bool l = formula();\n    ++p;\n    bool r = formula();\n    return l == r;\n}\n\nint main()\n{\n    for (;;) {\n        gets(str);\n        if (str[0] == '#')\n            break;\n\n        bool f = true;\n        for (int i = 0; i < 2048; ++i) {\n            for (int j = 0; j < 11; ++j)\n                c[j] = i & (1 << j);\n\n            p = 0;\n            f = f && equation();\n        }\n        puts(f ? \"YES\" : \"NO\");\n    }\n\n    return 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include<iostream>\n#include<string>\n#define MAX 11\nusing namespace std;\nbool o;\nvoid rec(string ss){\n  if(!o) return;\n  //cout << s << endl;\n  string s =ss;\n  bool f=false;\n  int p;\n\n  f=true;\n  /*\n  while(s.find(\"-0\")!=-1){\n    p=s.find(\"-0\");\n    s[p]='1';s[p+1]=' ';\n    f=true;\n  }\n  while(s.find(\"-1\")!=-1){\n    p=s.find(\"-1\");\n    s[p]='0';s[p+1]=' ';\n    f=true;\n  }\n  while(s.find(\"(0*0)\")!=-1){\n    p=s.find(\"(0*0)\");\n    s[p]='0';s[p+1]=' ';s[p+2]=' ';s[p+3]=' ';s[p+4]=' ';\n    f=true;\n  }\n  while(s.find(\"(0*1)\")!=-1){\n    p=s.find(\"(0*1)\");\n    s[p]='0';s[p+1]=' ';s[p+2]=' ';s[p+3]=' ';s[p+4]=' ';\n    f=true;\n  }\n  while(s.find(\"(1*0)\")!=-1){\n    p=s.find(\"(1*0)\");\n    s[p]='0';s[p+1]=' ';s[p+2]=' ';s[p+3]=' ';s[p+4]=' ';\n    f=true;\n  }\n  while(s.find(\"(1*1)\")!=-1){\n    p=s.find(\"(1*1)\");\n    s[p]='1';s[p+1]=' ';s[p+2]=' ';s[p+3]=' ';s[p+4]=' ';\n    f=true;\n  }\n  while(s.find(\"(0+0)\")!=-1){\n    p=s.find(\"(0+0)\");\n    s[p]='0';s[p+1]=' ';s[p+2]=' ';s[p+3]=' ';s[p+4]=' ';\n    f=true;\n  }\n  while(s.find(\"(0+1)\")!=-1){\n    p=s.find(\"(0+1)\");\n    s[p]='1';s[p+1]=' ';s[p+2]=' ';s[p+3]=' ';s[p+4]=' ';\n    f=true;\n  }\n  while(s.find(\"(1+0)\")!=-1){\n    p=s.find(\"(1+0)\");\n    s[p]='1';s[p+1]=' ';s[p+2]=' ';s[p+3]=' ';s[p+4]=' ';\n    f=true;\n  }\n  while(s.find(\"(1+1)\")!=-1){\n    p=s.find(\"(1+1)\");\n    s[p]='1';s[p+1]=' ';s[p+2]=' ';s[p+3]=' ';s[p+4]=' ';\n    f=true;\n  }\n  \n  while(s.find(\"(0->0)\")!=-1){\n    p=s.find(\"(0->0)\");\n    s[p]='1';s[p+1]=' ';s[p+2]=' ';s[p+3]=' ';s[p+4]=' ';s[p+5]=' ';\n    f=true;\n  }\n  while(s.find(\"(0->1)\")!=-1){\n    p=s.find(\"(0->1)\");\n    s[p]='1';s[p+1]=' ';s[p+2]=' ';s[p+3]=' ';s[p+4]=' ';s[p+5]=' ';\n    f=true;\n  }\n  while(s.find(\"(1->0)\")!=-1){\n    p=s.find(\"(1->0)\");\n    s[p]='0';s[p+1]=' ';s[p+2]=' ';s[p+3]=' ';s[p+4]=' ';s[p+5]=' ';\n    f=true;\n  }\n  while(s.find(\"(1->1)\")!=-1){\n    p=s.find(\"(1->1)\");\n    s[p]='1';s[p+1]=' ';s[p+2]=' ';s[p+3]=' ';s[p+4]=' ';s[p+5]=' ';\n    f=true;\n  }\n  */\n  if(f){\n    string b;\n    for(int i=0;i<s.size();i++) if(s[i]!=' ') b+=s[i];\n    rec(b);\n  }else{\n    if(s[0]!=s[2]) o=false;\n    return;\n  }\n}\nvoid init(int n,string s){\n  int i,j;\n  for(i=0;i<s.size();i++){\n    for(j=0;j<=MAX;j++){\n      if(s[i]=='a'+j) s[i]='0'+(n>>j&1);\n      if(s[i]=='T') s[i]='1';\n      if(s[i]=='F') s[i]='0';\n    }\n  }\n  rec(s);\n  if(!o) return;\n}\nint main(){\n  string s;\n  while(cin >> s,s!=\"#\"){\n    o=true;\n    int i;\n    for(i=0;i<(1<<MAX);i++)\n      if(o) init(i,s);\n      else break;\n    cout << (o?\"YES\":\"NO\") << endl;\n  }\n  return 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include<stdio.h>\n#include<algorithm>\nusing namespace std;\nchar str[1024];\nint var[20];\nint cur=0;\nint form(){\n\tif(str[cur]=='T'){cur++;return 1;}\n\tif(str[cur]=='F'){cur++;return 0;}\n\tif(str[cur]>='a'&&str[cur]<='z'){cur++;return var[str[cur-1]-'a'];}\n\t\n\tif(str[cur]=='-'){\n\t\tcur++;\n\t\tint tmp=form();\n\t\treturn !tmp;\n\t}\n\tif(str[cur]=='('){\n\t\tcur++;\n\t\tint L=form();\n\t\tint R;\n\t\tif(str[cur]=='+'){\n\t\t\tcur++;\n\t\t\tR=form();\n\t\t\tcur++;\n\t\t\treturn L||R;\n\t\t}else if(str[cur]=='*'){\n\t\t\tcur++;R=form();\n\t\t\tcur++;\n\t\t\treturn L&&R;\n\t\t}else{\n\t\t\tcur+=2;R=form();\n\t\t\tcur++;\n\t\t\treturn (!L)||(L&&R);\n\t\t}\n\t}\n}\nint main(){\n\twhile(1){\n\t\tscanf(\"%s\",str);\n\t\tif(str[0]=='#')return 0;\n\t\tbool ok=true;\n\t\tfor(int i=0;i<(1<<11);i++){\n\t\t\tcur=0;\n\t\t\tfor(int j=0;j<11;j++){\n\t\t\t\tif(i&(1<<j))var[j]=1;\n\t\t\t\telse var[j]=0;\n\t\t\t}\n\t\t\tint L=form();\n\t\t\tcur++;\n\t\t\tint R=form();\n\t\t\tif(L!=R){ok=false;break;}\n\t\t}\n\t\tif(ok)printf(\"YES\\n\");\n\t\telse printf(\"NO\\n\");\n\t}\n}"
  },
  {
    "language": "C++",
    "code": "#include<bits/stdc++.h>\nusing namespace std;\n\nint cnt = 0;\nchar S[1024];\nbool at[12];\n\nbool count(char c){\n  if( S[cnt] == c ) cnt++;\n  else return false;\n  return true;\n}\n\nbool get(char c){\n  return at[c-'a'];\n}\n\nbool calc( bool a, bool b, char c ){\n  if( c == '*' ) return a&b;\n  if( c == '+' ) return a|b;\n  return ~(a&(~b));\n}\n\nbool formula(){\n  if( count('-') ){\n    return ~formula();\n  } else if( count('T') ){\n    return true;\n  } else if( count('F') ){\n    return false;\n  } else if( count('(') ){\n    bool a = formula();\n    char c;\n    if( count( '*' ) ) c = '*';\n    else if( count('+') ) c = '+';\n    else if( count('-') && count('>') ) c='>';\n    else assert(false);\n    bool b = formula();\n    bool r = calc( a, b, c );\n    count( ')' );\n    return r;\n  } else {\n    char c = S[cnt];\n    count(c);\n    return get(c);\n  }  \n}\n\nbool equation(){\n  cnt=0;\n  bool a = formula();\n  count( '=' );\n  bool b = formula();\n  return a==b;\n}\n\nint main(){\n  while( cin >> S ){\n    if( S[0] == '#' ) break;\n    bool ret = true;\n    for(int i=0;i<(1<<11);i++){\n      for(int j=0;j<11;j++) at[j] = i&(1<<j);\n      if( !equation() ){ ret = false; break;}\n    }\n    if( ret ) cout << \"YES\" << endl;\n    else cout << \"NO\" << endl;\n  }\n}"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\n#include<stdio.h>\nusing namespace std;\n#define FOR(i,k,n) for(int i = (k); i < (n); i++)\n#define REP(i,n) FOR(i,0,n)\n#define ALL(a) begin(a),end(a)\n#define MS(m,v) memset(m,v,sizeof(m))\n#define D10  fixed<<setprecision(10)\ntypedef vector<int> vi;\ntypedef vector<string> vs;\ntypedef pair<int, int> P;\ntypedef long long ll;\nconst ll INF = 114514810;\nconst ll MOD = 1000000007;\nconst double EPS = 1e-8;\nconst double PI = acos(-1.0);\nstruct edge\n{\n\tint to, cost;\n\tbool operator < (const edge& e) const { return cost < e.cost; }\n\tbool operator >(const edge& e) const { return cost > e.cost; }\n};\nint dx[] = { -1, 0, 0, 1 }; int dy[] = { 0, -1, 1, 0 };\ntemplate<class T> T &chmin(T &a, const T &b) { return a = min(a, b); }\ntemplate<class T> T &chmax(T &a, const T &b) { return a = max(a, b); }\nbool valid(int x, int y, int h, int w) { return (x >= 0 && y >= 0 && x < h&&y < w); }\n///*************************************************************************************///\n///*************************************************************************************///\n///*************************************************************************************///\n\nint p;\nmap<char, char> li;\nint solve(const string& s);\n\nint elem(const string &s)\n{\n\tif (s[p] == '(')\n\t{\n\t\tp++;\n\t\tint buf = solve(s);\n\t\tp++;\n\t\treturn buf;\n\t}\n\tif (s[p] == '-'&&s[p + 1] != '>')\n\t{\n\t\tp++;\n\t\treturn solve(s) == 0 ? 1 : 0;\n\t}\n\tint res = li[s[p]] == 'T' ? 1 : 0;\n\treturn res;\n}\n\nint solve(const string& s)\n{\n\tint tmp = elem(s);\n\twhile (s[p] == '*' || s[p] == '+')\n\t{\n\t\tchar c = s[p];\n\t\tp++;\n\t\tif (c == '*') tmp *= elem(s);\n\t\telse if (c == '+')\n\t\t{\n\t\t\ttmp += elem(s);\n\t\t\tif (tmp != 0) tmp = 1;\n\t\t}\n\t\telse\n\t\t{\n\t\t\ttmp = elem(s) == 0 ? 1 : 0;\n\t\t}\n\t}\n\twhile (s[p] == '-'&&s[p + 1] == '>')\n\t{\n\t\tp += 2;\n\t\tif (tmp == 1 && elem(s) == 0) tmp = 0;\n\t\telse tmp = 1;\n\t}\n\treturn tmp;\n}\n\nint main()\n{\n\tstring str, s, t;\n\twhile (cin >> str)\n\t{\n\t\tif (str == \"#\") break;\n\t\tint eq = str.find('=');\n\t\ts = str.substr(0, eq);\n\t\tt = str.substr(eq + 1);\n\t\tp = 0;\n\t\tbool ans = true;\n\t\tREP(i, 1 << 11)\n\t\t{\n\t\t\tli.clear();\n\t\t\tREP(j, 11)\n\t\t\t{\n\t\t\t\tli['a' + j] = ((i >> j) & 1) ? 'T' : 'F';\n\t\t\t}\n\t\t\tp = 0;\n\t\t\tint l = solve(s);\n\t\t\tp = 0;\n\t\t\tint r = solve(t);\n\t\t\tif (l != r) ans = false;\n\t\t}\n\t\tputs(ans ? \"YES\" : \"NO\");\n\t}\n\treturn 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\nusing namespace std;\n\ntypedef ostringstream OSS;\ntypedef istringstream ISS;\n\ntypedef long long LL;\ntypedef pair<int, int> PII;\n\ntypedef vector<int> VI;\ntypedef vector<VI> VVI;\ntypedef vector<LL> VLL;\ntypedef vector<VLL> VVLL;\ntypedef vector<string> VS;\ntypedef vector<VS> VVS;\ntypedef vector<bool> VB;\ntypedef vector<VB> VVB;\ntypedef vector<PII> VPII;\n\n#define POS first\n#define VALUE second\n#define MP make_pair\n#define PB push_back\n#define EB emplace_back \n#define ALL(x) (x).begin(),(x).end()\n#define RANGE(x,y,maxX,maxY) (0 <= (x) && 0 <= (y) && (x) < (maxX) && (y) < (maxY))\n#define DUMP( x ) cerr << #x << \" = \" << ( x ) << endl\n\ntemplate < typename T > inline T fromString(const string &s) { T res; ISS iss(s); iss >> res; return res; };\ntemplate < typename T > inline string toString(const T &a) { OSS oss; oss << a; return oss.str(); };\n\nconst int INF = 0x3f3f3f3f;\nconst LL INFL = 0x3f3f3f3f3f3f3f3fLL;\nconst int DX[]={1,0,-1,0},DY[]={0,-1,0,1};\n\nPII formula(string &str, int pos);\n\nstring get_alpha(string str) {\n    set<char> s;\n\n    for (auto a : str) {\n        if (isalpha(a) && islower(a)) {\n            s.insert(a);\n        }\n    }\n\n    string as;\n    for (auto a : s) {\n        as += a;\n    }\n\n    return as;\n}\n\nPII ope(string &str, int pos) {\n    PII l = formula(str, pos);\n\n    PII r;\n    int value;\n    switch (str[l.POS]) {\n        case '+':\n            r = formula(str, l.POS + 1);\n            value = min(1, l.VALUE + r.VALUE);\n            break;\n\n        case '*':\n            r = formula(str, l.POS + 1);\n            value = l.VALUE * r.VALUE;\n            break;\n\n        case '-': // ->\n            r = formula(str, l.POS + 2);\n            value = min(1, (l.VALUE ? 0 : 1) + r.VALUE);\n            break;\n\n        default:\n            cerr << \"ERROR2!!!!!!!!!: \" << pos << endl;\n            exit(1);\n    }\n\n    return MP(r.POS, value);\n}\n\nPII formula(string &str, int pos) {\n    PII res;\n\n    switch (str[pos]) {\n        case '1':\n            return MP(pos + 1, 1);\n\n        case '0':\n            return MP(pos + 1, 0);\n\n        case '-': // minus(not)\n            res = formula(str, pos + 1);\n            return MP(res.POS, res.VALUE ? 0 : 1);\n\n        case '(':\n            res = ope(str, pos + 1);\n            ++res.POS;\n            return res;\n\n        default:\n            cerr << \"ERROR1!!!!!!!!!: \" << pos << \" \" << str[pos] << endl;\n            exit(1);\n    }\n}\n\nbool solve(string str) {\n    // T, F -> 1, 0\n    replace(ALL(str), 'T', '1');\n    replace(ALL(str), 'F', '0');\n\n    string as = get_alpha(str);\n    int n = as.size();\n\n    auto eq_pos = str.find('=');\n\n    // alpha -> 0 or 1\n    for (int p = 0; p < 1 << n; p++) {\n        string str2 = str;\n        for (int i = 0; i < n; i++) {\n            char c = (char)('0' + (p >> i & 1));\n            replace(ALL(str2), as[i], c);\n        }\n\n        string left_str = str2.substr(0, eq_pos);\n        string right_str = str2.substr(eq_pos + 1, str2.size());\n        PII left = formula(left_str, 0);\n        PII right = formula(right_str, 0);\n\n        if (left.VALUE != right.VALUE) {\n            return false;\n        }\n    }\n\n    return true;\n}\n\nint main(void) {\n    string str;\n\n    while (cin >> str, str != \"#\") {\n        cout << (solve(str) ? \"YES\" : \"NO\") << endl;;\n    }\n\n\treturn 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include<iostream>\n#include<string>\n#include<algorithm>\nusing namespace std;\nchar s1(char g1, char g2) { if (g1 == 'T' && g2 == 'T')return 'T'; return 'F'; }\nchar s2(char g1, char g2) { if (g1 == 'F' && g2 == 'F')return 'F'; return 'T'; }\nchar s3(char g1, char g2) { if (g1 == 'T' && g2 == 'F')return 'F'; return 'T'; }\nchar solve(string S) {\n\tint T = 0; string U = \"\";\n\twhile (T < S.size() && S[T] == '-') { T++; U += \"-\"; }\n\tint depth = 0, minx = 99999;\n\tfor (int i = 0; i < S.size(); i++) {\n\t\tif (S[i] == '(')depth++;\n\t\telse if (S[i] == ')')depth--;\n\t\telse { minx = min(minx, depth); }\n\t\tif (depth == 1 && i >= T + 1 && i <= (int)S.size() - 2) {\n\t\t\tstring R1 = S.substr(T + 1, i - T - 1);\n\t\t\tstring R2 = S.substr(i + 1, S.size() - i - 2);\n\t\t\tif (S[i] == '*')return solve(U + s1(solve(R1), solve(R2)));\n\t\t\tif (S[i] == '+')return solve(U + s2(solve(R1), solve(R2)));\n\t\t\tif (S[i] == '>')return solve(U + s3(solve(R1.substr(0, R1.size() - 1)), solve(R2)));\n\t\t}\n\t}\n\n\tif (T % 2 == 1) { if (S[T] == 'T')S[T] = 'F'; else S[T] = 'T'; }\n\treturn S[T];\n}\nint main() {\n\twhile (true) {\n\t\tbool OK = true;\n\t\tstring U, V1, V2; cin >> U; char R[3] = \"FT\"; if (U == \"#\")break;\n\t\tfor (int i = 0; i < U.size(); i++) {\n\t\t\tif (U[i] == '=') { V1 = U.substr(0, i); V2 = U.substr(i + 1, U.size() - i - 1); }\n\t\t}\n\t\tfor (int i = 0; i < (1 << 11); i++) {\n\t\t\tstring Y1 = V1, Y2 = V2; int bit[11];\n\t\t\tfor (int j = 0; j < 11; j++) { bit[j] = (i / (1 << j)) % 2; }\n\t\t\tfor (int j = 0; j < Y1.size(); j++) {\n\t\t\t\tif (Y1[j] >= 'a' && Y1[j] <= 'k') { Y1[j] = R[bit[Y1[j] - 'a']]; }\n\t\t\t}\n\t\t\tfor (int j = 0; j < Y2.size(); j++) {\n\t\t\t\tif (Y2[j] >= 'a' && Y2[j] <= 'k') { Y2[j] = R[bit[Y2[j] - 'a']]; }\n\t\t\t}\n\t\t\tif (solve(Y1) != solve(Y2)) {\n\t\t\t\tOK = false;\n\t\t\t}\n\t\t}\n\t\tif (OK == true)cout << \"YES\" << endl;\n\t\telse cout << \"NO\" << endl;\n\t}\n\treturn 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include <algorithm>\n#include <iostream>\n#include <vector>\n#include <string>\n#include <cctype>\nusing namespace std;\n\nint mask;\n\ntemplate<class T> struct Parser {\n    typedef string::const_iterator State;\n\n    T solve(const string &S) {\n        State begin = S.begin();\n        return equation(begin);\n    }\n\n    // <equation> ::= <formula> \"=\" <formula>\n    T equation(State &begin) {\n        T left = formula(begin);\n        begin++;    // skip '='\n        T right = formula(begin);\n        return left == right;\n    }\n\n    // <formula> ::= <boolean> |\n    // \"-\" <formula> |\n    // \"(\" <formula> \"*\" <formula> \")\" |\n    // \"(\" <formula> \"+\" <formula> \")\" |\n    // \"(\" <formula> \"->\" <formula> \")\"\n    T formula(State &begin) {\n        if (*begin == '(') {\n            begin++;                    // skip '('\n            T left = formula(begin);\n            char op = *begin;\n            begin++;                    // skip '*' or '+' or '-'\n            if (op == '-') begin++;     // skip '>'\n            T right = formula(begin);\n            begin++;                    // skip ')'\n            T ret = deduce(left, op, right);\n            return ret;\n        } else if (*begin == '-') {\n            begin++;    // skip '-'\n            return !formula(begin);\n        } else {\n            return boolean(begin);\n        }\n    }\n\n    T deduce(T x, char op, T y) {\n        if (op == '*') {\n            return x and y;\n        } else if (op == '+') {\n            return x or y;\n        } else {    // \"->\"\n            return !x or y;\n        }\n    }\n\n    // <boolean> ::= \"T\" | \"F\" |\n    // \"a\" | \"b\" | \"c\" | \"d\" | \"e\" | \"f\" |\n    // \"g\" | \"h\" | \"i\" | \"j\" | \"k\" |\n    T boolean(State &begin) {\n        T ret;\n        if (*begin == 'T') ret = 1;\n        if (*begin == 'F') ret = 0;\n        ret = (mask >> (*begin - 'a')) & 1;\n        begin++;\n        return ret;\n    }\n};\n\nvoid solve(string S) {\n    // 恒等式とは，式に現れる変数がどのような値であっても成立する等式のことである．\n    Parser<bool> ps;\n    for (mask = 0; mask < (1 << 11); mask++) {\n        if (!ps.solve(S)) {\n            cout << \"NO\" << endl;\n            return ;\n        }\n    }\n    cout << \"YES\" << endl;\n}\n\nint main() {\n    string S;\n    while (cin >> S && S != \"#\") {\n        solve(S);\n    }\n    return 0;\n}\n"
  },
  {
    "language": "C++",
    "code": "#include \"bits/stdc++.h\"\n#include<unordered_map>\n#include<unordered_set>\n#pragma warning(disable:4996)\nusing namespace std;\nusing ld = long double;\ntemplate<class T>\nusing Table = vector<vector<T>>;\nconst ld eps=1e-9;\n\n//22m\n//// < \"D:\\D_Download\\Visual Studio 2015\\Projects\\programing_contest_c++\\Debug\\a.txt\"\n\n\nint a; string st;\nbitset<11>bs;\n\nbool getalpha() {\n\tif (st[a] == 'T')return true;\n\telse if (st[a] == 'F')return false;\n\telse {\n\t\treturn bs[st[a] -'a'];\n\t}\n}\nbool getexpr();\nbool getform() {\n\tif (st[a] == '-') {\n\t\ta++;\n\t\treturn !getform();\n\t}\n\telse if (st[a] == '(') {\n\t\ta++;\n\t\tbool aok = getexpr();\n\t\ta++;\n\t\treturn aok;\n\t}\n\telse {\n\t\tbool aa=getalpha();\n\t\ta++; return aa;\n\t}\n}\nbool getexpr() {\n\tbool aok = getform();\n\twhile (1) {\n\t\tif (a == st.size() || st[a] == '='||st[a]==')')return aok;\n\t\telse if (st[a] == '*') {\n\t\t\ta++;\n\t\t\taok &= getform();\n\t\t}\n\t\telse if (st[a] == '+') {\n\t\t\ta++;\n\t\t\taok |= getform();\n\t\t}\n\t\telse if (st[a] == '-') {\n\t\t\ta += 2;\n\t\t\tif (!getform()&&aok)aok = false;\n\t\t\telse aok = true;\n\t\t}\n\t\telse {\n\t\t\tassert(false);\n\t\t}\n\t}\n\treturn aok;\n}\nint main() {\n\twhile (1) { cin >> st;\n\tif (st == \"#\")break;\n\t\tbool ok = true;\n\t\tfor (int i = 0; i < (1 << 11); ++i) {\n\t\t\ta = 0;\n\t\t\tbs = i;\n\n\t\t\tbool from = getexpr();\n\t\t\ta++;\n\t\t\tbool to = getexpr();\n\t\t\tif (from != to)ok = false;\n\t\t}\n\t\tif (ok)cout << \"YES\" << endl;\n\t\telse cout << \"NO\" << endl;\n\t}\n\n\treturn 0;\n}"
  },
  {
    "language": "C++",
    "code": "#define _USE_MATH_DEFINES\n#include <algorithm>\n#include <cstdio>\n#include <functional>\n#include <iostream>\n#include <cfloat>\n#include <climits>\n#include <cstring>\n#include <cmath>\n#include <map>\n#include <queue>\n#include <set>\n#include <sstream>\n#include <stack>\n#include <string>\n#include <time.h>\n#include <vector>\nusing namespace std;\n\ntypedef long long ll;\ntypedef unsigned long long ull;\ntypedef pair<int, int> i_i;\ntypedef pair<ll, int> ll_i;\ntypedef pair<double, int> d_i;\ntypedef pair<ll, ll> ll_ll;\ntypedef pair<double, double> d_d;\nstruct edge { int u, v; ll w; };\n\nll MOD = 1000000007;\nll _MOD = 1000000009;\ndouble EPS = 1e-10;\n\nbool foo(string& s, int& i, int S) {\n\tchar c = s[i];\n\ti++;\n\tif (c == 'T') return true;\n\tif (c == 'F') return false;\n\tif (c >= 'a' && c <= 'k') return S & (1 << (c - 'a'));\n\tif (c == '-') return !foo(s, i, S);\n\tbool x = foo(s, i, S);\n\tc = s[i];\n\ti++;\n\tif (c == '-') i++;\n\tbool y = foo(s, i, S);\n\ti++;\n\tif (c == '*') return x && y;\n\tif (c == '+') return x || y;\n\tif (c == '-') return !x || y;\n}\n\nint main() {\n\tfor (;;) {\n\t\tstring s; cin >> s;\n\t\tif (s == \"#\") break;\n\t\tint i = s.find('=');\n\t\tstring s1 = s.substr(0, i), s2 = s.substr(i + 1);\n\t\tcout << s1 << ' ' << s2 << endl;\n\t\tbool flag = true;\n\t\tfor (int S = 0; S < (1 << 11); S++) {\n\t\t\tint i1 = 0, i2 = 0;\n\t\t\tbool x1 = foo(s1, i1, S), x2 = foo(s2, i2, S);\n\t\t\tif ((x1 && !x2) || (!x1 && x2)) flag = false;\n\t\t}\n\t\tcout << (flag ? \"YES\" : \"NO\") << endl;\n\t}\n}"
  },
  {
    "language": "C++",
    "code": "#include<iostream>\n#include<vector>\n#include<string>\n#include<algorithm>\nusing namespace std;\n\n#define MAX_NUM 2\n#define MAX_CH 10\n#define MAX_N 1200\n\nstring S, T;\nchar NUM[MAX_NUM + 1] = \"01\";\nchar CH[MAX_CH + 1] = \"abcdefghij\";\nint TR[MAX_CH];\nint CNT[MAX_N];\n\nint Plus(int c1, int c2) {\n\treturn max(c1, c2);\n}\nint kake(int c1, int c2) {\n\treturn min(c1, c2);\n}\nint fukumi(int c1, int c2) {\n\tif (c1 == 1 && c2 == 0) {\n\t\treturn 0;\n\t}\n\treturn 1;\n}\n\nint STOI(char V) {\n\tif (V == '0') {\n\t\treturn 0;\n\t}\n\telse {\n\t\treturn 1;\n\t}\n}\n\nint calc2(string A2) {\n\tA2 = A2.substr(1, A2.size() - 1);\n\tif (A2.size() == 3) {\n\t\tint p1, p2;\n\t\tp1 = STOI(A2[0]);\n\t\tp2 = STOI(A2[2]);\n\t\tif (A2[1] == '+') {\n\t\t\treturn Plus(p1, p2);\n\t\t}\n\t\tif (A2[1] == '*') {\n\t\t\treturn kake(p1, p2);\n\t\t}\n\t\tif (A2[1] == '&') {\n\t\t\treturn fukumi(p1, p2);\n\t\t}\n\t}\n\telse if (A2.size() == 4) {\n\t\tif (A2[0] == '-') {\n\t\t\tint p1, p2;\n\t\t\tp1 = STOI(A2[1]);\n\t\t\tp2 = STOI(A2[3]);\n\t\t\tif (A2[1] == '+') {\n\t\t\t\treturn Plus(1 - p1, p2);\n\t\t\t}\n\t\t\tif (A2[1] == '*') {\n\t\t\t\treturn kake(1 - p1, p2);\n\t\t\t}\n\t\t\tif (A2[1] == '&') {\n\t\t\t\treturn fukumi(1 - p1, p2);\n\t\t\t}\n\t\t}\n\t\tif (A2[2] == '-') {\n\t\t\tint p1, p2;\n\t\t\tp1 = STOI(A2[0]);\n\t\t\tp2 = STOI(A2[3]);\n\t\t\tif (A2[1] == '+') {\n\t\t\t\treturn Plus(p1, 1 - p2);\n\t\t\t}\n\t\t\tif (A2[1] == '*') {\n\t\t\t\treturn kake(p1, 1 - p2);\n\t\t\t}\n\t\t\tif (A2[1] == '&') {\n\t\t\t\treturn fukumi(p1, 1 - p2);\n\t\t\t}\n\t\t}\n\t}\n\telse {\n\t\tint p1, p2;\n\t\tp1 = STOI(A2[1]);\n\t\tp2 = STOI(A2[4]);\n\t\tif (A2[1] == '+') {\n\t\t\treturn Plus(1 - p1, 1 - p2);\n\t\t}\n\t\tif (A2[1] == '*') {\n\t\t\treturn kake(1 - p1, 1 - p2);\n\t\t}\n\t\tif (A2[1] == '&') {\n\t\t\treturn fukumi(1 - p1, 1 - p2);\n\t\t}\n\t}\n}\n\nstring TOSTR(int d) {\n\tif (d == 0) {\n\t\treturn \"0\";\n\t}\n\telse {\n\t\treturn \"1\";\n\t}\n}\n\nint calc(string Y) {\n\tfor (int i = 0; i < MAX_N; i++) {\n\t\tCNT[i] = 0;\n\t}\n\tstring Z = \"\", AA = \"\";\n\n\twhile (Z.size() >= 2) {\n\t\tint L = 0, MN = 0;\n\t\tbool ok1 = false;\n\t\tZ = \"\"; AA = \"\";\n\t\tint pass2 = 0;\n\t\tint pass3 = -1;\n\t\twhile (pass2 < Y.size()) {\n\t\t\tif (Y[pass2] == '(') {\n\t\t\t\tL++;\n\t\t\t}\n\t\t\tif (Y[pass2] == ')') {\n\t\t\t\tL++;\n\t\t\t}\n\t\t\tCNT[pass2] = L;\n\t\t\tpass2++;\n\t\t\tMN = max(MN, L);\n\t\t}\n\t\tfor (int i = 0; i < Y.size(); i++) {\n\t\t\tif (CNT[i] == MN) {\n\t\t\t\tif (pass3 == -1) {\n\t\t\t\t\tpass3 = i;\n\t\t\t\t}\n\t\t\t\tAA += Y[i];\n\t\t\t\tif (i < Y.size() - 1) {\n\t\t\t\t\tif (Y[i + 1] == ')') {\n\t\t\t\t\t\tok1 = false;\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t}\n\t\t\telse {\n\t\t\t\tZ += Y[i];\n\t\t\t}\n\t\t}\n\t\tint ZSIZE = Z.size();\n\t\tZ = Z.substr(0, pass3) + TOSTR(calc2(AA)) + Z.substr(pass3, ZSIZE - pass3);\n\t}\n\tif (Z == \"0\") {\n\t\treturn false;\n\t}\n\telse {\n\t\treturn true;\n\t}\n}\n\nint power(int a, int b) {\n\tint res2 = 1;\n\tfor (int i = 0; i < b; i++) {\n\t\tres2 *= a;\n\t}\n\treturn res2;\n}\n\nbool solve(string U) {\n\tbool RES = true;\n\tstring V = \"\";\n\tstring V1 = \"\", V2 = \"\";\n\tstring W1 = \"\", W2 = \"\";\n\n\tfor (int i = 0; i < U.size(); i++) {\n\t\tif (U[i] == 'T') {\n\t\t\tV += '1';\n\t\t\tgoto E;\n\t\t}\n\t\telse if (U[i] == '>') {\n\t\t\t//nanimo shinai.\n\t\t}\n\t\telse if (U[i] == 'F') {\n\t\t\tV += '0';\n\t\t\tgoto E;\n\t\t}\n\t\telse if (i < U.size() - 1) {\n\t\t\tif (U.substr(i, 2) == \"->\") {\n\t\t\t\tV += '&';\n\t\t\t\tgoto E;\n\t\t\t}\n\t\t}\n\t\telse {\n\t\t\tV += U[i];\n\t\t}\n\tE:;\n\t}\n\n\tint cnt1 = 0;\n\tfor (int i = 0; i < V.size(); i++) {\n\t\tif (V[i] == '=') {\n\t\t\tcnt1 = 1;\n\t\t}\n\t\telse if (cnt1 == 0) {\n\t\t\tV1 += V[i];\n\t\t}\n\t\telse if (cnt1 == 1) {\n\t\t\tV2 += V[i];\n\t\t}\n\t}\n\n\tint pass1 = 0;\n\twhile (pass1 < V1.size()) {\n\t\tif (V1[pass1] == '-') {\n\t\t\tint cnt2 = 0;\n\t\t\twhile (V1[pass1] == '-') {\n\t\t\t\tcnt2++;\n\t\t\t\tpass1++;\n\t\t\t}\n\t\t\tif (cnt2 % 2 == 1) {\n\t\t\t\tW1 += '(';\n\t\t\t\tW1 += '-';\n\t\t\t\tW1 += V1[pass1];\n\t\t\t\tW1 += ')';\n\t\t\t}\n\t\t\telse {\n\t\t\t\tW1 += V1[pass1];\n\t\t\t}\n\t\t\tpass1++;\n\t\t}\n\t\tif (pass1 < V1.size()) {\n\t\t\tW1 += V1[pass1];\n\t\t\tpass1++;\n\t\t}\n\t}\n\n\tpass1 = 0;\n\twhile (pass1 < V2.size()) {\n\t\tif (V2[pass1] == '-') {\n\t\t\tint cnt2 = 0;\n\t\t\twhile (V2[pass1] == '-') {\n\t\t\t\tcnt2++;\n\t\t\t\tpass1++;\n\t\t\t}\n\t\t\tif (cnt2 % 2 == 1) {\n\t\t\t\tW2 += '(';\n\t\t\t\tW2 += '-';\n\t\t\t\tW2 += V2[pass1];\n\t\t\t\tW2 += ')';\n\t\t\t}\n\t\t\telse {\n\t\t\t\tW2 += V2[pass1];\n\t\t\t}\n\t\t\tpass1++;\n\t\t}\n\t\tif (pass1 < V2.size()) {\n\t\t\tW2 += V2[pass1];\n\t\t\tpass1++;\n\t\t}\n\t}\n\n\tstring X1 = \"\", X2 = \"\";\n\n\tfor (int i = 0; i < power(2, MAX_CH); i++) {\n\t\tX1 = \"\"; X2 = \"\";\n\t\tfor (int j = 0; j < MAX_CH; j++) {\n\t\t\tint a1 = (i / power(2, j)) % 2;\n\t\t\tTR[j] = a1;\n\t\t}\n\n\t\tfor (int j = 0; j < V1.size(); j++) {\n\t\t\tfor (int k = 0; k < MAX_CH; k++) {\n\t\t\t\tif (W1[j] == CH[k]) {\n\t\t\t\t\tX1 += NUM[TR[j]];\n\t\t\t\t\tgoto F;\n\t\t\t\t}\n\t\t\t}\n\t\t\tX1 += W1[j];\n\t\tF:;\n\t\t}\n\n\t\tfor (int j = 0; j < V2.size(); j++) {\n\t\t\tfor (int k = 0; k < MAX_CH; k++) {\n\t\t\t\tif (W2[j] == CH[k]) {\n\t\t\t\t\tX2 += NUM[TR[j]];\n\t\t\t\t\tgoto G;\n\t\t\t\t}\n\t\t\t}\n\t\t\tX2 += W1[j];\n\t\tG:;\n\t\t}\n\n\t\tint res_1 = calc(X1);\n\t\tint res_2 = calc(X2);\n\t\tif (res_1 != res_2) {\n\t\t\tRES = false;\n\t\t}\n\t}\n\treturn RES;\n}\n\nint main() {\n\twhile (true) {\n\t\tcin >> S;\n\t\tif (S == \"#\") {\n\t\t\tbreak;\n\t\t}\n\t\tbool res = solve(S);\n\t\tif (res == true) {\n\t\t\tcout << \"YES\" << endl;\n\t\t}\n\t\telse {\n\t\t\tcout << \"NO\" << endl;\n\t\t}\n\t}\n\treturn 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\nusing namespace std;\n\n#define fi first\n#define se second\n#define repl(i,a,b) for(int i=(int)(a);i<(int)(b);i++)\n#define rep(i,n) repl(i,0,n)\n#define each(itr,v) for(auto itr:v)\n#define pb(s) push_back(s)\n#define mp(a,b) make_pair(a,b)\n#define all(x) (x).begin(),(x).end()\n#define dbg(x) cout<<#x\"=\"<<x<<endl\n#define maxch(x,y) x=max(x,y)\n#define minch(x,y) x=min(x,y)\n#define uni(x) x.erase(unique(all(x)),x.end())\n#define exist(x,y) (find(all(x),y)!=x.end())\n#define bcnt(x) bitset<32>(x).count()\n\ntypedef long long ll;\ntypedef unsigned long long ull;\ntypedef pair<int, int> P;\ntypedef pair<P, int> PPI;\ntypedef pair<ll, ll> PL;\ntypedef pair<P, ll> PPL;\n\n#define INF INT_MAX/3\n\n#define MAX_N 1000\n\nchar s[1111],ins[1111];\n\nbool formula(int l,int r){\n\tif(s[l]=='T')return true;\n\telse if(s[l]=='F') return false;\n\telse if(s[l]=='-'){\n\t\tif(formula(l+1,r))return false;\n\t\telse return true;\n\t}\n\tstring op=\"\";\n\tint k,level=0;\n\tfor(k=l+1;k<r-1;k++){\n\t\tif(s[k]=='(')level++;\n\t\tif(s[k]==')')level--;\n\t\tif(level==0){\n\t\t\tif(s[k]=='*')op=\"*\";\n\t\t\telse if(s[k]=='+')op=\"+\";\n\t\t\telse if(s[k]=='-'&&s[k+1]=='>')op=\"->\";\n\t\t}\n\t\tif(op!=\"\")break;\n\t}\n\tbool resa=formula(l+1,k),resb=formula(op==\"->\"?k+2:k+1,r-1);\n\tif(op==\"*\")return resa&resb;\n\telse if(op==\"+\")return resa|resb;\n\telse{\n\t\tif(resa==false)return true;\n\t\telse return resb;\n\t}\n}\n\nbool equation(int l,int r){\n\tint k=0;\n\tfor(k=l;k<r;k++){\n\t\tif(s[k]=='=')break;\n\t}\n\treturn formula(l,k)==formula(k+1,r);\n}\n\nint main(){\n\tcin.sync_with_stdio(false);\n\twhile(1){\n\t\tcin>>ins;\n\t\tif(ins[0]=='#')break;\n\t\tvector<char> cnt;\n\t\tint n=strlen(ins);\n\t\trep(i,n){\n\t\t\tif(ins[i]>='a'&&ins[i]<='k'){\n\t\t\t\tif(!exist(cnt,ins[i]))cnt.pb(ins[i]);\n\t\t\t}\n\t\t}\n\t\tbool ok=true;\n\t\trep(i,1<<cnt.size()){\n\t\t\tmap<char,bool> maps;\n\t\t\tmemcpy(s,ins,sizeof(ins));\n\t\t\trep(j,cnt.size()){\n\t\t\t\tif((i>>j)&1){\n\t\t\t\t\tmaps[cnt[j]]=true;\n\t\t\t\t}else{\n\t\t\t\t\tmaps[cnt[j]]=false;\n\t\t\t\t}\n\t\t\t}\n\t\t\trep(j,n){\n\t\t\t\tif(exist(cnt,s[j])){\n\t\t\t\t\tif(maps[s[j]])s[j]='T';\n\t\t\t\t\telse s[j]='F';\n\t\t\t\t}\n\t\t\t}\n\t\t\tif(!equation(0,n)){\n\t\t\t\tok=false;\n\t\t\t\tbreak;\n\t\t\t}\n\t\t}\n\t\tif(ok)cout<<\"YES\"<<endl;\n\t\telse cout<<\"NO\"<<endl;\n\t}\n\treturn 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include <iostream>\n#include <string>\n#include <cassert>\n\nusing namespace std;\n\ntypedef string::iterator Iterator;\n\nvoid skip(Iterator &it, char c) {\n    if(*it != c) {\n        cerr << \"Expected \" << c << \" but \" << *it << endl;\n        assert(false);\n    }\n    ++it;\n}\n\nbool formula(Iterator &it, int vars) {\n    if(*it == 'T') {\n        ++it;\n        return true;\n    }\n    else if(*it == 'F') {\n        ++it;\n        return false;\n    }\n    else if('a' <= *it && *it <= 'k') {\n        int idx = *it - 'a';\n        ++it;\n        return (vars & (1<<idx)) != 0;\n    }\n    else if(*it == '-') {\n        ++it;\n        bool operand = formula(it, vars);\n        return !operand;\n    }\n    else if(*it == '(') {\n        ++it;\n        bool lhs = formula(it, vars);\n        int op = -1;\n        if(*it == '*') {\n            ++it;\n            op = 1;\n        }\n        else if(*it == '+') {\n            ++it;\n            op = 2;\n        }\n        else if(*it == '-') {\n            ++it;\n            if(*it == '>') {\n                ++it;\n                op = 3;\n            }\n        }\n        bool rhs = formula(it, vars);\n        skip(it, ')');\n        switch(op) {\n            case 1:\n                return lhs && rhs;\n                break;\n            case 2:\n                return lhs || rhs;\n                break;\n            case 3:\n                return !(lhs && !rhs);\n                break;\n            default:\n                assert(false);\n        }\n    }\n    assert(false);\n}\n\nint main() {\n    while(true) {\n        string str;\n        getline(cin, str);\n        if(str == \"#\") break;\n\n        bool ok = true;\n        for(int pat = 0; pat < (1<<11); ++pat) {\n            Iterator it = str.begin();\n            bool lhs = formula(it, pat);\n            skip(it, '=');\n            bool rhs = formula(it, pat);\n            if(lhs != rhs) {\n                ok = false;\n                break;\n            }\n        }\n\n        cout << (ok?\"YES\":\"NO\") << endl;\n    }\n\n    return 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\nusing namespace std;\n\nint pos, var;\nstring s;\nint formula() {\n  pos++;\n  if(s==\"T\") return 1;\n  if(s==\"F\") return 0;\n  if(isalpha(s[pos])) return (var>>(s[pos]-'a')&1)==1;\n  if(s[pos]=='-') return !formula();\n  int f1=formula();\n  pos++; char op=s[pos]; if(op=='-') pos++;\n  int f2=formula(); pos++;\n  if(op=='+') return f1||f2;\n  if(op=='*') return f1&&f2;\n  if(op=='-') return f1<=f2;\n}\n\nint main() {\n  while(cin >> s) {\n    if(s==\"#\") break;\n    bool ok=true;\n    for(var=0;var<(1<<11);var++) {\n      pos=-1; int lhs=formula();\n      pos++;\n      if(lhs!=formula()) { ok=false; break; }\n    }\n    cout << (ok ? \"YES\":\"NO\") << endl;\n  }\n  return 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include <algorithm>\n#include <cmath>\n#include <climits>\n#include <cstdio>\n#include <cstring>\n#include <fstream>\n#include <iostream>\n#include <list>\n#include <map>\n#include <queue>\n#include <set>\n#include <sstream>\n#include <stack>\n#include <string>\n#include <vector>\n\nusing namespace std;\n\n#define LOG(...) printf(__VA_ARGS__)\n//#define LOG(...)\n#define FOR(i,a,b) for(int i=(a);i<(b);++i)\n#define REP(i,n) for(int i=0;i<(int)(n);++i)\n#define ALL(a) (a).begin(),(a).end()\n#define EXIST(s,e) ((s).find(e)!=(s).end())\n#define SORT(c) sort((c).begin(),(c).end())\n\ntypedef long long ll;\ntypedef unsigned long long ull;\ntypedef vector<bool> vb;\ntypedef vector<int> vi;\ntypedef vector<ll> vll;\ntypedef vector<vb> vvb;\ntypedef vector<vi> vvi;\ntypedef vector<vll> vvll;\ntypedef pair<int, int> pii;\ntypedef pair<ll, ll> pll;\n\nconst int V[] = {\n    1 << 0,\n    1 << 1,\n    1 << 2,\n    1 << 3,\n    1 << 4,\n    1 << 6,\n    1 << 7,\n    1 << 8,\n    1 << 9,\n    1 << 10,\n    1 << 11,\n};\nconst string C[] = {\"a\", \"b\", \"c\", \"d\", \"e\", \"f\", \"g\", \"h\", \"i\", \"j\", \"k\"};\n\nstring replace_all(string &subject, const string &search, const string &replace) {\n    size_t pos = 0;\n    while ((pos = subject.find(search, pos)) != string::npos) {\n        subject.replace(pos, search.length(), replace);\n        pos += replace.length();\n    }\n    return subject;\n}\n\nstring parse(string expr, int var) {\n    replace_all(expr, \"--\", \"\");\n    replace_all(expr, \"->\", \">\");\n    REP(i, 11) {\n        replace_all(expr, C[i], var | V[i] ? \"T\" : \"F\");\n    }\n    while (expr.length() > 1) {\n        replace_all(expr, \"-F\", \"T\");\n        replace_all(expr, \"-T\", \"F\");\n        stack<int> parens;\n        REP(i, expr.length()) {\n            if (expr[i] == '(') {\n                parens.push(i);\n                continue;\n            } else if (expr[i] == ')') {\n                int j = parens.top(); parens.pop();\n                char a = expr[j+1];\n                char b = expr[j+3];\n                string ret;\n                switch (expr[j+2]) {\n                case '+': // OR\n                    if (a == 'F' && b == 'F') ret = \"F\";\n                    else ret = \"T\";\n                    break;\n                case '*': // AND\n                    if (a == 'T' && b == 'T') ret = \"T\";\n                    else ret = \"F\";\n                    break;\n                case '>': // IMP\n                    if (a == 'T' && b == 'F') ret = \"F\";\n                    else ret = \"T\";\n                    break;\n                }\n                replace_all(expr, string(expr.begin() + j, expr.begin() + i + 1), ret);\n                break;\n            }\n        }\n    }\n    return expr;\n}\n\nint main() {\n    string line;\n    while (getline(cin, line), line != \"#\") {\n        int eq = line.find('=');\n        string l(line.begin(), line.begin() + eq);\n        string r(line.begin() + eq + 1, line.end());\n        bool ok = true;\n        REP(var, 2 << 12) {\n            if (parse(l, var) != parse(r, var)) {\n                ok = false;\n                break;\n            }\n        }\n        cout << (ok ? \"YES\" : \"NO\") << endl;\n    }\n}"
  },
  {
    "language": "C++",
    "code": "#include<iostream>\n#include<string>\n#include<vector>\n#define MAX 11\nusing namespace std;\nbool o;\nvoid rec(string s){\n  if(!o) return;\n  //cout << s << endl;\n  while(1){\n    //cout << s << endl;\n    bool f=false;\n    int p;\n    for(p=0;p<s.size();p++){\n      if(s[p]==' ') continue;\n      if(s[p]=='-'){\n\t\n\tif(s[p+1]=='0'){\n\t  s[p]='1';\n\t  s[p+1]=' ';\n\t  f=true;\n\t}\n\t\n\tif(s[p+1]=='1'){\n\t  s[p]='0';\n\t  s[p+1]=' ';\n\t  f=true;\n\t}\n\tcontinue;\n      }\n      if(s[p]=='('){\n\tif(s[p+1]!='0'&&s[p+1]!='1') continue;\n\tif(s[p+4]==')'){\n\t  if(s[p+2]=='+'){\n\t    if(s[p+1]=='0'&&s[p+3]=='0'){\n\t      s[p]='0';s[p+1]=' ';s[p+2]=' ';s[p+3]=' ';s[p+4]=' ';\n\t    }\n\t    if(s[p+1]=='1'&&s[p+3]=='0'){\n\t      s[p]='1';s[p+1]=' ';s[p+2]=' ';s[p+3]=' ';s[p+4]=' ';\n\t    }\n\t    if(s[p+1]=='0'&&s[p+3]=='1'){\n\t      s[p]='1';s[p+1]=' ';s[p+2]=' ';s[p+3]=' ';s[p+4]=' ';\n\t    }\n\t    if(s[p+1]=='1'&&s[p+3]=='1'){\n\t      s[p]='1';s[p+1]=' ';s[p+2]=' ';s[p+3]=' ';s[p+4]=' ';\n\t    }\n\t  }\n\t  if(s[p+2]=='*'){\n\t    if(s[p+1]=='0'&&s[p+3]=='0'){\n\t      s[p]='0';s[p+1]=' ';s[p+2]=' ';s[p+3]=' ';s[p+4]=' ';\n\t    }\n\t    if(s[p+1]=='1'&&s[p+3]=='0'){\n\t      s[p]='0';s[p+1]=' ';s[p+2]=' ';s[p+3]=' ';s[p+4]=' ';\n\t    }\n\t    if(s[p+1]=='0'&&s[p+3]=='1'){\n\t      s[p]='0';s[p+1]=' ';s[p+2]=' ';s[p+3]=' ';s[p+4]=' ';\n\t    }\n\t    if(s[p+1]=='1'&&s[p+3]=='1'){\n\t      s[p]='1';s[p+1]=' ';s[p+2]=' ';s[p+3]=' ';s[p+4]=' ';\n\t    }\n\t  }\n\t  f=true;\n\t}else if(s[p+5]==')'&&s[p+2]=='-'&&s[p+3]=='>'){\n\t  if(s[p+1]=='0'&&s[p+4]=='0'){\n\t    s[p]='1';s[p+1]=' ';s[p+2]=' ';s[p+3]=' ';s[p+4]=' ';s[p+5]=' ';\n\t  }\n\t  if(s[p+1]=='1'&&s[p+4]=='0'){\n\t    s[p]='0';s[p+1]=' ';s[p+2]=' ';s[p+3]=' ';s[p+4]=' ';s[p+5]=' ';\n\t  }\n\t  if(s[p+1]=='0'&&s[p+4]=='1'){\n\t    s[p]='1';s[p+1]=' ';s[p+2]=' ';s[p+3]=' ';s[p+4]=' ';s[p+5]=' ';\n\t  }\n\t  if(s[p+1]=='1'&&s[p+4]=='1'){\n\t    s[p]='1';s[p+1]=' ';s[p+2]=' ';s[p+3]=' ';s[p+4]=' ';s[p+5]=' ';\n\t  }\n\t  f=true;\n\t}\n      }\n    }\n    if(f){\n      string b;\n      for(int i=0;i<s.size();i++) if(s[i]!=' ') b+=s[i];\n      s=b;\n    }else{\n      if(s[0]!=s[2]) o=false;\n      return;\n    }\n  }\n}\nbool fi;\nvector<int> v[11];\nvoid init(int n,string s){\n  int i,j;\n  if(fi){\n    for(j=0;j<MAX;j++) v[j].clear();\n    for(i=0;i<s.size();i++){\n      for(j=0;j<MAX;j++){\n\tif(s[i]=='a'+j) {\n\t  s[i]='0'+(n>>j&1);\n\t  v[j].push_back(i);\n\t}\n      }\n    }\n    fi=false;\n  }else{\n    for(i=0;i<MAX;i++){\n      for(j=0;j<v[i].size();j++){\n\ts[v[i][j]]='0'+(n>>i&1);\n      }\n    }\n  }\n  //cout << s << endl;\n  rec(s);\n  if(!o) return;\n}\nint main(){\n  string s;\n  while(cin >> s,s!=\"#\"){\n    o=true;\n    int i;\n    fi=true;\n    for(i=0;i<s.size();i++){\n      if(s[i]=='T') s[i]='1';\n      if(s[i]=='F') s[i]='0';\n    }\n    for(i=0;i<(1<<MAX);i++)\n      if(o) init(i,s);\n      else break;\n    cout << (o?\"YES\":\"NO\") << endl;\n  }\n  return 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include<iostream>\n#include<string>\n#define MAX 11\nusing namespace std;\nbool o;\nvoid rec(string s){\n  if(!o) return;\n  //cout << s << endl;\n  while(1){\n    bool f=false;\n    int p;\n    \n    while(s.find(\"-0\")!=-1){\n      p=s.find(\"-0\");\n      s[p]='1';s[p+1]=' ';\n      f=true;\n    }\n    while(s.find(\"-1\")!=-1){\n      p=s.find(\"-1\");\n      s[p]='0';s[p+1]=' ';\n      f=true;\n    }\n    while(s.find(\"(0*0)\")!=-1){\n      p=s.find(\"(0*0)\");\n      s[p]='0';s[p+1]=' ';s[p+2]=' ';s[p+3]=' ';s[p+4]=' ';\n      f=true;\n    }\n    while(s.find(\"(0*1)\")!=-1){\n      p=s.find(\"(0*1)\");\n      s[p]='0';s[p+1]=' ';s[p+2]=' ';s[p+3]=' ';s[p+4]=' ';\n      f=true;\n    }\n    while(s.find(\"(1*0)\")!=-1){\n      p=s.find(\"(1*0)\");\n      s[p]='0';s[p+1]=' ';s[p+2]=' ';s[p+3]=' ';s[p+4]=' ';\n      f=true;\n    }\n    while(s.find(\"(1*1)\")!=-1){\n      p=s.find(\"(1*1)\");\n      s[p]='1';s[p+1]=' ';s[p+2]=' ';s[p+3]=' ';s[p+4]=' ';\n      f=true;\n    }\n    while(s.find(\"(0+0)\")!=-1){\n      p=s.find(\"(0+0)\");\n      s[p]='0';s[p+1]=' ';s[p+2]=' ';s[p+3]=' ';s[p+4]=' ';\n      f=true;\n    }\n    while(s.find(\"(0+1)\")!=-1){\n      p=s.find(\"(0+1)\");\n      s[p]='1';s[p+1]=' ';s[p+2]=' ';s[p+3]=' ';s[p+4]=' ';\n      f=true;\n    }\n    while(s.find(\"(1+0)\")!=-1){\n      p=s.find(\"(1+0)\");\n      s[p]='1';s[p+1]=' ';s[p+2]=' ';s[p+3]=' ';s[p+4]=' ';\n      f=true;\n    }\n    while(s.find(\"(1+1)\")!=-1){\n      p=s.find(\"(1+1)\");\n      s[p]='1';s[p+1]=' ';s[p+2]=' ';s[p+3]=' ';s[p+4]=' ';\n      f=true;\n    }\n    \n    while(s.find(\"(0->0)\")!=-1){\n      p=s.find(\"(0->0)\");\n      s[p]='1';s[p+1]=' ';s[p+2]=' ';s[p+3]=' ';s[p+4]=' ';s[p+5]=' ';\n      f=true;\n    }\n    while(s.find(\"(0->1)\")!=-1){\n      p=s.find(\"(0->1)\");\n      s[p]='1';s[p+1]=' ';s[p+2]=' ';s[p+3]=' ';s[p+4]=' ';s[p+5]=' ';\n      f=true;\n    }\n    while(s.find(\"(1->0)\")!=-1){\n      p=s.find(\"(1->0)\");\n      s[p]='0';s[p+1]=' ';s[p+2]=' ';s[p+3]=' ';s[p+4]=' ';s[p+5]=' ';\n      f=true;\n    }\n    while(s.find(\"(1->1)\")!=-1){\n      p=s.find(\"(1->1)\");\n      s[p]='1';s[p+1]=' ';s[p+2]=' ';s[p+3]=' ';s[p+4]=' ';s[p+5]=' ';\n      f=true;\n    }\n    \n    if(f){\n      string b;\n      for(int i=0;i<s.size();i++) if(s[i]!=' ') b+=s[i];\n      s=b;\n    }else{\n      if(s[0]!=s[2]) o=false;\n      return;\n    }\n  }\n}\nvoid init(int n,string s){\n  int i,j;\n  for(i=0;i<s.size();i++){\n    for(j=0;j<=MAX;j++){\n      if(s[i]=='a'+j) s[i]='0'+(n>>j&1);\n      if(s[i]=='T') s[i]='1';\n      if(s[i]=='F') s[i]='0';\n    }\n  }\n  rec(s);\n  if(!o) return;\n}\nint main(){\n  string s;\n  while(cin >> s,s!=\"#\"){\n    o=true;\n    int i;\n    for(i=0;i<(1<<MAX);i++)\n      if(o) init(i,s);\n      else break;\n    cout << (o?\"YES\":\"NO\") << endl;\n  }\n  return 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\n\nusing namespace std;\n\nstring str;\nint var;\nint pos;\n\nbool formula() {\n  pos++;\n  if(str[pos]=='T') return true;\n  if(str[pos]=='F') return false;\n  if(isalpha(str[pos])) return var>>(str[pos]-'a') & 1;\n  if(str[pos]=='-') return !formula();\n  if(str[pos]=='(') {\n    int f1=formula();\n    if(str[pos]=='-')pos++;\n    pos++;\n    int f2=formula();\n    pos++;\n    if(str[pos]=='*') return f1&&f2;\n    if(str[pos]=='+') return f1||f2;\n    if(str[pos]=='-') return f1<=f2;\n  }\n}\n\n\nint main() {\n  \n  while(cin >> str) {\n    if(str == \"#\") break;\n    bool ok = true;\n    for(var=0; var<(1<<11);var++) {\n      pos = -1; int f=formula();\n      pos++;\n      if(f != formula()) { ok = false; break; }\n    }\n    if(ok) cout << \"YES\" << endl;\n    else cout << \"NO\" << endl;\n  }\n  \n  return 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include <algorithm>\n#include <cmath>\n#include <climits>\n#include <cstdio>\n#include <cstring>\n#include <fstream>\n#include <iostream>\n#include <list>\n#include <map>\n#include <queue>\n#include <set>\n#include <sstream>\n#include <stack>\n#include <string>\n#include <vector>\n\nusing namespace std;\n\n#define LOG(...) printf(__VA_ARGS__)\n//#define LOG(...)\n#define FOR(i,a,b) for(int i=(a);i<(b);++i)\n#define REP(i,n) for(int i=0;i<(int)(n);++i)\n#define ALL(a) (a).begin(),(a).end()\n#define EXIST(s,e) ((s).find(e)!=(s).end())\n#define SORT(c) sort((c).begin(),(c).end())\n\ntypedef long long ll;\ntypedef unsigned long long ull;\ntypedef vector<bool> vb;\ntypedef vector<int> vi;\ntypedef vector<ll> vll;\ntypedef vector<vb> vvb;\ntypedef vector<vi> vvi;\ntypedef vector<vll> vvll;\ntypedef pair<int, int> pii;\ntypedef pair<ll, ll> pll;\n\nconst int V[] = {\n    1 << 0,\n    1 << 1,\n    1 << 2,\n    1 << 3,\n    1 << 4,\n    1 << 6,\n    1 << 7,\n    1 << 8,\n    1 << 9,\n    1 << 10,\n    1 << 11,\n};\nconst string C[] = {\"a\", \"b\", \"c\", \"d\", \"e\", \"f\", \"g\", \"h\", \"i\", \"j\", \"k\"};\n\nstring replace_all(string &subject, const string &search, const string &replace) {\n    size_t pos = 0;\n    while ((pos = subject.find(search, pos)) != string::npos) {\n        subject.replace(pos, search.length(), replace);\n        pos += replace.length();\n    }\n    return subject;\n}\n\nstring parse(string expr, int var) {\n    replace_all(expr, \"--\", \"\");\n    replace_all(expr, \"->\", \">\");\n    REP(i, 11) {\n        replace_all(expr, C[i], var | V[i] ? \"T\" : \"F\");\n    }\n    while (expr.length() > 1) {\n        replace_all(expr, \"-F\", \"T\");\n        replace_all(expr, \"-T\", \"F\");\n        stack<int> parens;\n        REP(i, expr.length()) {\n            if (expr[i] == '(') {\n                parens.push(i);\n                continue;\n            } else if (expr[i] == ')') {\n                int j = parens.top(); parens.pop();\n                char a = expr[j+1];\n                char b = expr[j+3];\n                string ret;\n                switch (expr[j+2]) {\n                case '+': // OR\n                    if (a == 'F' && b == 'F') ret = \"F\";\n                    else ret = \"T\";\n                    break;\n                case '*': // AND\n                    if (a == 'T' && b == 'T') ret = \"T\";\n                    else ret = \"F\";\n                    break;\n                case '>': // IMP\n                    if (a == 'T' && b == 'F') ret = \"F\";\n                    else ret = \"T\";\n                    break;\n                }\n                replace_all(expr, string(expr.begin() + j, expr.begin() + i + 1), ret);\n                break;\n            }\n        }\n    }\n    return expr;\n}\n\nint main() {\n    string line;\n    while (getline(cin, line), line != \"#\") {\n        int eq = line.find('=');\n        string l(line.begin(), line.begin() + eq);\n        string r(line.begin() + eq + 1, line.end());\n        bool ok = false;\n        REP(var, (2 << 12) - 1) {\n            if (parse(l, var) == parse(r, var)) {\n                ok = true;\n                break;\n            }\n        }\n        cout << (ok ? \"YES\" : \"NO\") << endl;\n    }\n}"
  },
  {
    "language": "C++",
    "code": "#include<iostream>\n#include<vector>\n#include<string>\n#include<algorithm>\n\nusing namespace std;\n\nint now,al;\nstring s,str=\"abcdefghijk\";\n\nbool formula(void){\n\t\n\tif(s[now]=='T'){\n\t\tnow++;\t\n\t\treturn true;\n\t}\n\t\n\tif(s[now]=='F'){\n\t\tnow++;\t\n\t\treturn false;\n\t}\n\t\n\tfor(int i=0;i<str.size();i++){\n\t\tif(s[now]==str[i]){\n\t\t\tnow++;\n\t\t\treturn (al>>i)&1;\n\t\t}\n\t}\n\t\n\tif(s[now]=='('){\n\t\tnow++;\n\t\tbool res1=formula();\n\t\t\n\t\tif(s[now]=='*'){\n\t\t\tnow++;\n\t\t\tbool res2=formula();\n\t\t\tif(s[now]==')')now++;\n\t\t\treturn res1&res2;\n\t\t}\n\t\tif(s[now]=='+'){\n\t\t\tnow++;\n\t\t\tbool res2=formula();\n\t\t\tif(s[now]==')')now++;\n\t\t\treturn res1|res2;\n\t\t}\n\t\tif(s[now]=='-' && s[now+1]=='>'){\n\t\t\tnow+=2;\n\t\t\tbool res2=formula();\n\t\t\tif(s[now]==')')now++;\n\t\t\tif(res1==true && res2==false)return false;\n\t\t\treturn true;\n\t\t}\n\t}\n\t\n\tif(s[now]=='-'){\n\t\tnow++;\n\t\tbool res=formula();\n\t\treturn !res;\n\t}\n}\n\nbool equation(void){\n\tbool res1=formula();\n\tnow++;\n\tbool res2=formula();\n\treturn (res1==res2);\n}\n\nint main(void){\n\t\n\twhile(cin >> s,s!=\"#\"){\n\t\tbool fg=true;\n\t\tfor(al=0;al<(1<<11);al++)now=0,fg&=equation();\n\t\tif(fg)cout << \"YES\" << endl;\n\t\telse cout << \"NO\" << endl;\n\t}\n\treturn 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include<cstdio>\n#include<cstdlib>\n#include<cstring>\n#include<cmath>\n#include<cctype>\n#include<climits>\n#include<iostream>\n#include<string>\n#include<vector>\n#include<map>\n//#include<list>\n#include<queue>\n#include<deque>\n#include<algorithm>\n//#include<numeric>\n#include<utility>\n#include<complex>\n//#include<memory>\n#include<functional>\n#include<cassert>\n\nconst int dx[] = {1, 0, -1, 0};\nconst int dy[] = {0, 1, 0, -1};\nusing namespace std;\ntypedef long long ll;\ntypedef vector<int> vi;\ntypedef vector<ll> vll;\ntypedef pair<int, int> pii;\ntypedef complex<double> C;\n\ntypedef string::const_iterator State;\n\nbool formula(State& begin, int S);\nbool TF(State& begin, int S);\n\nvoid consume(State& begin, char expected) {\n    if (*begin == expected) {\n        begin++;\n    } else {\n        cerr << \"Expected '\" << expected << \"' but got '\" << *begin << \"'\" << endl;\n        cerr << \"Rest string is '\";\n        while (*begin) {\n            cerr << *begin++;\n        }\n        cerr << \"'\" << endl;\n        exit(1);\n    }\n}\n\nbool formula(State& begin, int S) {\n    if (*begin == '-') {\n        begin++;\n        return !formula(begin, S);\n    } else if (*begin == '(') {\n        consume(begin, '(');\n        bool ret = formula(begin, S);\n        if (*begin == '*') {\n            consume(begin, '*');\n            ret &= formula(begin, S);\n            consume(begin, ')');\n            return ret;\n        } else if (*begin == '+') {\n            consume(begin, '+');\n            ret |= formula(begin, S);\n            consume(begin, ')');\n            return ret;\n        } else {\n            consume(begin, '-');\n            consume(begin, '>');\n            bool tmp = formula(begin, S);\n            if (ret == true && tmp == false) ret = false;\n            else ret = true;\n            consume(begin, ')');\n            return ret;\n        }\n    } else {\n        return TF(begin, S);\n    }\n}\n\nbool TF(State& begin, int S) {\n    if (*begin == 'T') {\n        consume(begin, 'T');\n        return true;\n    }\n    if (*begin == 'F') {\n        consume(begin, 'F');\n        return false;\n    }\n    int tmp = *begin - 'a';\n    begin++;\n    return ((S>>tmp)&1) == 1;\n}\n\nint main() {\n    cin.tie(0);\n    ios::sync_with_stdio(false);\n    while (1) {\n        bool ng = false;\n        string s;\n        cin >> s;\n        if (s == \"#\") break;\n        for (int i = 0; i < 8; i++) {\n            State begin1 = s.begin(), begin2;\n            for (begin2 = s.begin(); ; begin2++) {\n                if (*begin2 == '=') {\n                    begin2++;\n                    break;\n                }\n            }\n            if (formula(begin1, i) != formula(begin2, i)) {\n                ng = true;\n                break;\n            }\n        }\n        if (ng) {\n            cout << \"NO\" << endl;\n        } else {\n            cout << \"YES\" << endl;\n        }\n    }\n    return 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include <cstdio>\n\nusing namespace std;\n\nbool equation(char *str, int &p);\nbool formula(char *str, int &p);\n\nbool c[11];\n\nbool equation(char *str, int &p)\n{\n    return formula(str, p) == formula(str, ++p);\n}\n\nbool formula(char *str, int &p)\n{\n    bool a;\n    if (str[p] == 'T') {\n        a = true;\n        ++p;\n    } else if (str[p] == 'F') {\n        a = false;\n        ++p;\n    } else if ('a' <= str[p] && str[p] <= 'k') {\n        a = c[str[p] - 'a'];\n        ++p;\n    } else if (str[p] == '-' && str[p + 1] != '>') {\n        ++p;\n        a = !formula(str, p);\n    } else {\n        ++p;\n        bool l = formula(str, p);\n        if (str[p] == '*') {\n            ++p;\n            a = l && formula(str, p);\n        } else if (str[p] == '+') {\n            ++p;\n            a = l || formula(str, p);\n        } else if (str[p] == '-' && str[++p] == '>') {\n            ++p;\n            a = !l || formula(str, p);\n        }\n        ++p;\n    }\n    return a;\n}\n\nint main()\n{\n    for (;;) {\n        char str[1001];\n\n        gets(str);\n        if (str[0] == '#')\n            break;\n\n        bool f = true;\n        for (int j = 0; j < 2048; ++j) {\n            c[0] = j & 0x01;\n            c[1] = j & 0x02;\n            c[2] = j & 0x04;\n            c[3] = j & 0x08;\n            c[4] = j & 0x10;\n            c[5] = j & 0x20;\n            c[6] = j & 0x40;\n            c[7] = j & 0x80;\n            c[8] = j & 0x100;\n            c[9] = j & 0x200;\n            c[10] = j & 0x400;\n            //printf(\"%4d: %d%d%d%d%d%d%d%d%d%d%d\\n\", j, c[0], c[1], c[2], c[3], c[4], c[5], c[6], c[7], c[8], c[9], c[10]);\n\n            int i = 0;\n            f = f && equation(str, i);\n            if (!f)\n                break;\n        }\n\n        puts(f ? \"YES\" : \"NO\");\n    }\n\n    return 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\n\n#define N 11\n\nusing namespace std;\n\nbool parse(string x, bool vars[N]) {\n    int nest = 0;\n    switch (x[0]) {\n        case 'T':\n            return true;\n        case 'F':\n            return false;\n        case '-':\n            return ~parse(x.substr(1), vars);\n        case '(':\n            break;\n        default:\n            return vars[x[0]-'a'];\n    }\n    x = x.substr(1, x.length()-2);\n    for (int i=0; i<(int)x.length(); i++) {\n        if (x[i] == '(') {\n            nest++;\n            continue;\n        }\n        if (x[i] == ')') {\n            nest--;\n            continue;\n        }\n        if (nest > 0) {\n            continue;\n        }\n        if (x[i] == '+') {\n            return parse(x.substr(0, i), vars) || parse(x.substr(i+1), vars);\n        }\n        if (x[i] == '*') {\n            return parse(x.substr(0, i), vars) && parse(x.substr(i+1), vars);\n        }\n        if (x.substr(i, 2) == \"->\") {\n            return (~parse(x.substr(0, i), vars)) || parse(x.substr(i+2), vars);\n        }\n    }\n    while (true) {\n        //cout << \"tsu_ra_i\" << endl;\n    }\n}\n\nbool is_equal(string x, string y) {\n    bool vars[N];\n    for (int i=0; i<(1<<N); i++) {\n        for (int j=0; j<N; j++) {\n            vars[j] = i&(1<<j);\n        }\n        if (parse(x, vars) != parse(y, vars)) {\n            return false;\n        }\n    }\n    return true;\n}\n\nint main() {\n    string line, x, y;\n    while (true) {\n        cin >> line;\n        if (line == \"#\") {\n            return 0;\n        }\n        for (int i=0; i<(int)line.length(); i++) {\n            if (line[i] == '=') {\n                x = line.substr(0, i);\n                y = line.substr(i+1);\n                break;\n            }\n        }\n        if (is_equal(x, y)) {\n            cout << \"YES\" << endl;\n        }\n        else {\n            cout << \"NO\" << endl;\n        }\n    }\n}"
  },
  {
    "language": "C++",
    "code": "#include <cstdio>\n#include <iostream>\n#include <cmath>\n#include <ctype.h>\n#include <string> \n#include <sstream>\n#include <iostream>\n#include <algorithm>\n#include <cstdlib>\n#include <map>\n#include <queue>\n#include <utility>\n#include <vector>\n#include <set>\n#include <list>\n#include <cstring>\n#include <stack>\n   \nusing namespace std;\n\nint main()\n{\n    string s;\n    while(1){\n        cin >> s;\n        if(s == \"#\") break;\n        char en[12] = {'a', 'b', 'c', 'd', 'e', 'f', 'g', 'h', 'i', 'j', 'k'};\n        bool ok = true;\n        map<char, char> chara;\n        chara['1'] = '1';\n        chara['0'] = '0';\n        chara['T'] = '1';\n        chara['F'] = '0';\n        chara['('] = '(';\n        chara['='] = '=';\n        chara['*'] = '*';\n        chara['+'] = '+';\n        chara['-'] = '-';\n        chara['>'] = '>';\n        for(int i = 0; i < (1 << 11); i++){\n            int nowi = i;\n            for(int j = 10; j >= 0; j--){\n                chara[en[j]] = (nowi / (int)pow(2, j)) + '0';\n                nowi = nowi % (int)pow(2, j);\n                // cout << chara[en[j]];\n            }\n            // cout << endl;\n            stack<char> st;\n            for(int j = 0; j < s.length(); j++){\n                if(s[j] == ')'){\n                    char y = st.top();\n                    // cout <<\"y:\" << y << endl;\n                    st.pop();\n                    while(st.top() == '-'){\n                        st.pop();\n                        if(y == '0') y = '1';\n                        else y = '0';\n                    }\n                    char op = st.top();\n                    // cout << \"op:\" << op << endl;\n                    if(op == '>') st.pop();\n                    st.pop();\n                    char x = st.top();\n                    // cout << \"x:\" << x << endl;\n                    st.pop();\n                    while(st.top() == '-'){\n                        st.pop();\n                        if(x == '0') x = '1';\n                        else x = '0';\n                    }\n                    // cout << \"hey \" << st.top() << endl;\n                    st.pop();\n                    // cout << x << \" \" << op << \" \" << y << endl;\n                    if(op == '*'){\n                        if(x == '1' && y == '1') st.push('1');\n                        else st.push('0');\n                    } else if(op == '+'){\n                        if(x == '0' && y == '0') st.push('0');\n                        else st.push('1');\n                    } else if(op == '>'){\n                        if(x == '1' && y == '0') st.push('0');\n                        else st.push('1');\n                    }\n                } else {\n                    // cout << chara[s[j]] << endl;\n                    st.push(chara[s[j]]);\n                }\n            }\n            char e2 = st.top();\n            st.pop();\n            while(st.top() == '-'){\n                st.pop();\n                if(e2 == '1') e2 = '0';\n                else e2 = '1';\n            }\n            // cout << st.top() << endl;\n            st.pop();\n            char e1 = st.top();\n            st.pop();\n            while(!st.empty()){\n                st.pop();\n                if(e1 == '1') e1 = '0';\n                else e1 = '1';\n            }\n            // cout << st.size() << endl;\n            if(e1 != e2){\n                ok = false;\n                break;\n            }\n        }\n        if(ok) cout << \"YES\" << endl;\n        else cout << \"NO\" << endl;\n    }\n    return 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\nusing namespace std;\nconst int dx[]={1,0,0,-1,1,-1,-1,1};\nconst int dy[]={0,1,-1,0,1,1,-1,-1};\nconst int INF = 1<<30;\nconst double EPS = 1e-8;\n#define PB push_back\n#define mk make_pair\n#define fr first\n#define sc second\n#define reps(i,j,k) for(int i = (j); i < (k); ++i)\n#define rep(i,j) reps(i,0,j)\n#define MOD 1000000007\n#define lengthof(x) (sizeof(x) / sizeof(*(x)))\ntypedef vector<int> vi;\ntypedef vector<vi> vvi;\ntypedef pair<int,int> Pii;\ntypedef pair<int,vi > P;\ntypedef long long ll;\nbool number(string& ,int& );\nbool rev(string& ,int& );\nbool term(string& ,int& );\nbool number(string &s,int& i){\n    if(s[i++] == 'T'){\n        return true;\n    }\n    else{\n        return false;\n    }\n}\n\nbool rev(string& s,int& i){\n    if(isalpha(s[i]))return number(s,i);\n    if(s[i] == '-'){\n        while(s[i] == '-'){\n            i++;\n            return !rev(s,i);\n        }\n    }\n    i++;\n    bool ret = term(s,i);\n    i++;\n    return ret;\n}\nbool term(string& s ,int& i){\n    bool val = rev(s,i);\n    while(s[i] == '+' || s[i] == '*' || s[i] == '&'){\n        char op = s[i];\n        i++;\n        bool val2 = rev(s,i);\n        if(op == '+'){\n            val |= val2;\n        }\n        else if(op == '*'){\n            val &= val2;\n        }\n        else if(op == '&'){\n            val = !(val & !val2);\n        }\n    }\n    return val;\n}\nmap < string , int > memo;\nbool select(string a,string b,int depth){\n    bool ans = true;\n    if(memo[a+b])return (bool)(memo[a+b]-1);\n    if(depth == 11){\n        \n        int idx = 0;\n        bool p = term(a,idx);\n        //cout << \"*\" << idx << \" \";\n        idx = 0;\n        bool q = term(b,idx);\n        //cout << \"*\" << idx << \" \";\n        /*if(false){\n            cout << a << \" \" << b << \" \";\n            cout << p << \" \" << q  << \"\\n\";\n        }*/\n        ans &= (p==q);\n        memo[a+b] = 1+(int)ans;\n        return ans;\n    }\n    string aT,aF;\n    aT = \"\";\n    aF = \"\";\n    rep(i,a.size()){\n        if(a[i] == depth+'a'){\n            aT += \"T\";\n            aF += \"F\";\n        }\n        else{\n            aT += a[i];\n            aF += a[i];\n        }\n    }\n    string bT,bF;\n    bT = \"\";\n    bF = \"\";\n    rep(i,b.size()){\n        if(b[i] == depth+'a'){\n            bT += \"T\";\n            bF += \"F\";\n        }\n        else{\n            bT += b[i];\n            bF += b[i];\n        }\n    }\n    ans &= select(aT,bT,depth+1);\n    ans &= select(aF,bF,depth+1);\n    memo[a+b] = 1+(int)ans;\n    return ans;\n}\nint main(){\n    string tmp;\n    while(true){\n        memo.clear();\n        string a;\n        string b;\n        cin >> tmp;\n        if(tmp == \"#\")break;\n         \n        int idx = 0;\n        while(tmp[idx] != '='){\n            if(tmp[idx] == '-' && tmp[idx+1] == '>'){\n                a += \"&\";\n                idx+=2;\n                continue;\n            }\n            a += tmp[idx]; \n            idx++;\n        }\n        reps(i,idx+1,tmp.size()){\n            if(tmp[i] == '-' && tmp[i+1] == '>'){\n                b += \"&\";\n                i++;\n                continue;\n            }\n            b += tmp[i];\n        }\n        select(a,b,0) ? puts(\"YES\") : puts(\"NO\");\n    }\n    return 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include <iostream>\n#include <string>\n#include <vector>\n#include <algorithm>\n#include <utility>\n#include <cstring>\n#include <cmath>\n#include <queue>\n#include <map>\n#include <set>\nusing namespace std;\n\n#define rep(i,n) for(int i=0; i<n; i++)\n#define FOR(i,s,n) for(int i=s; i<n; i++)\n#define ALL(x) x.begin(), x.end()\ntypedef long long ll;\ntypedef unsigned long long ull;\ntypedef pair<int,int> pii;\ntypedef vector<int> vi;\n\nstring solve( string s ) {\n\tif( s == \"0\" || s == \"1\" ) return s;\n\trep(i, s.length()) {\n\t\tif(s[i] == '(') {\n\t\t\tint p = i+2;\n\t\t\twhile(s[p]!=')') p++;\n\t\t\tstring ss = solve(s.substr(i+1, p-i-1));\n\t\t\ts.replace(i, p-i+1, ss);\n\t\t}\n\t}\n\n\trep(i, s.length()) {\n\t\tif(s[i] == '*') {\n\t\t\tstring sa = solve(s.substr(0, i));\n\t\t\tstring sb = solve(s.substr(i+1, s.length()));\n\t\t\ts = (sa==\"1\" && sb==\"1\") ? \"1\" : \"0\";\n\t\t}\n\t\telse if(s[i] == '+') {\n\t\t\tstring sa = solve(s.substr(0, i));\n\t\t\tstring sb = solve(s.substr(i+1, s.length()));\n\t\t\ts = (sa==\"0\" && sb==\"0\") ? \"0\" : \"1\";\n\t\t}\n\t\telse if(s[i] == '-' && i+1<s.length() && s[i+1]=='>') {\n\t\t\tstring sa = solve(s.substr(0, i));\n\t\t\tstring sb = solve(s.substr(i+2, s.length()));\n\t\t\ts = (sa==\"1\" && sb==\"0\") ? \"0\" : \"1\";\n\t\t}\n\t}\n\trep(i, s.length()) {\n\t\tif(s[i] == '-') {\n\t\t\tstring ss = solve(s.substr(i+1, s.length()));\n\t\t\ts = (ss==\"0\" ? \"1\" : \"0\");\n\t\t}\n\t}\n\treturn s;\n}\n\nint main() {\n\tstring in;\n\twhile(cin >> in, in!=\"#\") {\n\t\tstring aa, ab;\n\t\trep(i, in.length()) {\n\t\t\tif( in[i] == 'T' ) {\n\t\t\t\tin[i] = '1';\n\t\t\t}\n\t\t\telse if( in[i] == 'F' ) {\n\t\t\t\tin[i] = '0';\n\t\t\t}\n\t\t}\n\t\trep(i, in.length()) {\n\t\t\tif( in[i] == '=' ) {\n\t\t\t\taa = in.substr(0, i);\n\t\t\t\tab = in.substr(i+1, in.length());\n\t\t\t\tbreak;\n\t\t\t}\n\t\t}\n\t\tbool ng = false;\n\t\trep(i, (1<<11)) {\n\t\t\tstring a=aa, b=ab;\n\t\t\trep(j, a.length()) {\n\t\t\t\tif('a'<=a[j] && a[j]<='k') {\n\t\t\t\t\ta[j] = '0' + ((i & (1<<a[j]-'a')) ? 1 : 0);\n\t\t\t\t}\n\t\t\t}\n\t\t\trep(j, b.length()) {\n\t\t\t\tif('a'<=b[j] && b[j]<='k') {\n\t\t\t\t\tb[j] = '0' + ((i & (1<<b[j]-'a')) ? 1 : 0);\n\t\t\t\t}\n\t\t\t}\n\t\t\ta = solve(a);\n\t\t\tb = solve(b);\n\t\t\tif( a != b ) {\n\t\t\t\tcout << \"NO\" << endl;\n\t\t\t\tng = true;\n\t\t\t\tbreak;\n\t\t\t}\n\t\t}\n\t\tif( !ng ) {\n\t\t\tcout << \"YES\" << endl;\n\t\t}\n\t}\n\treturn 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include<bits/stdc++.h>\nint i,v;std::string s;\nint P() {\n  i++;\n  if(s[i]=='T')return 1;\n  if(s[i]=='F')return 0;\n  if(isalpha(s[i]))return v>>(s[i]-'a')&1;\n  if(s[i]=='-')return !P();\n  int l=P();\n  i++;int o=s[i];if(o=='-')i++;\n  int r=P();i++;\n  if(o=='*')return l&r;\n  if(o=='+')return l|r;\n  if(o=='-')return l<=r;\n}\nint main() {\n  while(std::cin>>s){\n    if(s==\"#\")break;\n    bool k=true;\n    for(v=0;v<(1<<11);v++) {\n      i=-1;int l=P();\n      i++;\n      if(l!=P()){k=false;break;}\n    }\n    std::cout<<(k?\"YES\\n\":\"NO\\n\");\n  }\n  return 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\n#define rep(i,n) for(int i=0;i<n;i++)\n#define all(x) (x).begin(),(x).end()\nusing namespace std;\nconst int INF=1145141919,MOD=1e9+7;\nconst long long LINF=8931145141919364364,LMOD=998244353;\ninline long long mod(long long n,long long m){return(n%m+m)%m;}\n// const int dx[]={1,0,-1,0,1,1,-1,-1},dy[]={0,-1,0,1,1,-1,-1,1};\n\ntemplate<class T>\nstruct Parser{\n    typedef string::const_iterator itr;\n    itr begin;\n    vector<bool> TF;\n    T ans;\n    Parser(const string &s,const vector<bool> &TF):TF(TF){\n        begin=s.begin();\n        ans=expr(begin);\n    }\n    T expr(itr &begin){\n        if(*begin=='-'){\n            consume(begin,'-');\n            return !expr(begin);\n        }\n        else if(*begin=='('){\n            consume(begin,'(');\n            T ret=expr(begin);\n            if(*begin=='*'){\n                consume(begin,'*');\n                ret&=expr(begin);\n            }\n            if(*begin=='+'){\n                consume(begin,'+');\n                ret|=expr(begin);\n            }\n            if(*begin=='-'&&*(begin+1)=='>'){\n                consume(begin,'-');\n                consume(begin,'>');\n                ret=(!ret|expr(begin));\n            }\n            return ret;\n        }else{\n            char tmp=*begin;\n            begin++;\n            if(tmp=='T') return true;\n            if(tmp=='F') return false;\n            if('a'<=tmp&&tmp<='k') return TF[tmp-'a'];\n        }\n        return true;\n    }\n    void consume(itr &begin,char expected){\n        if(*begin==expected){\n            begin++;\n        }else{\n            fprintf(stderr,\"Expected: '%c' Got: '%c'\\n\",expected,*begin);\n            fprintf(stderr,\"Rest string is \");\n            while(*begin){\n                fprintf(stderr,\"%c\",*begin++);\n            }\n        }\n    }\n};\n\nint main(){\n    string s;\n    while(cin>>s&&s!=\"#\"){\n        string s1,s2;\n        for(int i=0;;i++){\n            if(s[i]=='='){\n                s1=s.substr(0,i);\n                s2=s.substr(i+1);\n                break;\n            }\n        }\n        bool flg=1;\n        for(int i=0;i<(1<<11);i++){\n            vector<bool> TF(11);\n            for(int j=0;j<11;j++){\n                TF[j]=(i>>j);\n            }\n            Parser<bool> p1(s1,TF);\n            Parser<bool> p2(s2,TF);\n            if(p1.ans!=p2.ans){\n                cout<<\"NO\"<<endl;\n                flg=0;\n                break;\n            }\n        }\n        if(flg) cout<<\"YES\"<<endl;\n    }\n    return 0;\n}\n\n"
  },
  {
    "language": "C++",
    "code": "#define _USE_MATH_DEFINES\n#include <algorithm>\n#include <cstdio>\n#include <functional>\n#include <iostream>\n#include <cfloat>\n#include <climits>\n#include <cstring>\n#include <cmath>\n#include <map>\n#include <queue>\n#include <set>\n#include <sstream>\n#include <stack>\n#include <string>\n#include <time.h>\n#include <vector>\nusing namespace std;\n\ntypedef long long ll;\ntypedef unsigned long long ull;\ntypedef pair<int, int> i_i;\ntypedef pair<ll, int> ll_i;\ntypedef pair<double, int> d_i;\ntypedef pair<ll, ll> ll_ll;\ntypedef pair<double, double> d_d;\nstruct edge { int u, v; ll w; };\n\nll MOD = 1000000007;\nll _MOD = 1000000009;\ndouble EPS = 1e-10;\n\nbool foo(string& s, int& i, int S) {\n\tchar c = s[i];\n\ti++;\n\tif (c == 'T') return true;\n\tif (c == 'F') return false;\n\tif (c >= 'a' && c <= 'k') return S & (1 << (c - 'a'));\n\tif (c == '-') return !foo(s, i, S);\n\tbool x = foo(s, i, S);\n\tc = s[i];\n\ti++;\n\tif (c == '-') i++;\n\tbool y = foo(s, i, S);\n\ti++;\n\tif (c == '*') return x && y;\n\tif (c == '+') return x || y;\n\tif (c == '-') return !x || y;\n}\n\nint main() {\n\tfor (;;) {\n\t\tstring s; cin >> s;\n\t\tif (s == \"#\") break;\n\t\tint i = s.find('=');\n\t\tstring s1 = s.substr(0, i), s2 = s.substr(i + 1);\n\t\tbool flag = true;\n\t\tfor (int S = 0; S < (1 << 11); S++) {\n\t\t\tint i1 = 0, i2 = 0;\n\t\t\tbool x1 = foo(s1, i1, S), x2 = foo(s2, i2, S);\n\t\t\tif ((x1 && !x2) || (!x1 && x2)) flag = false;\n\t\t}\n\t\tcout << (flag ? \"YES\" : \"NO\") << endl;\n\t}\n}"
  },
  {
    "language": "C++",
    "code": "#include<iostream>\n#include<string>\nusing namespace std;\n\nstring s;\nint use;\n\nbool parse(int l,int r){\n  int p = 0;\n  for(int i=l;i<r;i++){\n    if(s[i] == '(')p++;\n    if(s[i] == ')')p--;\n    if(!p){\n      if(s[i] == '*')return parse(l,i) && parse(i+1,r);\n      if(s[i] == '+')return parse(l,i) || parse(i+1,r);\n      if(s[i] == '-' && s[i+1] == '>')return !parse(l,i) || parse(i+2,r);\n    }\n  }\n\n  if(s[l] == '-')return !parse(l+1,r);\n  if(s[l] == '(' && s[r-1] == ')')return parse(l+1,r-1);\n  if(s[l] == 'T')return true;\n  if(s[l] == 'F')return false;\n  return ( ( use >> (s[l]-'a') ) & 1);\n}\n\nint main(){\n  while(cin >> s,s!=\"#\"){\n    int x = s.find(\"=\");\n    bool f = true;\n    for(use=0;use<(1<<11);use++){\n      f &= parse(0,x) == parse(x+1,s.size());\n      if(!f)break;\n    }\n    cout << (f?\"YES\\n\":\"NO\\n\");\n  }\n}"
  },
  {
    "language": "C++",
    "code": "#include <algorithm>\n#include <cmath>\n#include <climits>\n#include <cstdio>\n#include <cstdlib>\n#include <cstring>\n#include <fstream>\n#include <iostream>\n#include <list>\n#include <map>\n#include <queue>\n#include <set>\n#include <sstream>\n#include <stack>\n#include <string>\n#include <vector>\n#include <cassert>\n#include <functional>\n\nusing namespace std;\n\n#define LOG(...) printf(__VA_ARGS__)\n//#define LOG(...)\n#define FOR(i,a,b) for(int i=(int)(a);i<(int)(b);++i)\n#define REP(i,n) for(int i=0;i<(int)(n);++i)\n#define ALL(a) (a).begin(),(a).end()\n#define RALL(a) (a).rbegin(),(a).rend()\n#define EXIST(s,e) ((s).find(e)!=(s).end())\n#define SORT(c) sort((c).begin(),(c).end())\n#define RSORT(c) sort((c).rbegin(),(c).rend())\n#define CLR(a) memset((a), 0 ,sizeof(a))\n\ntypedef long long ll;\ntypedef unsigned long long ull;\ntypedef vector<bool> vb;\ntypedef vector<int> vi;\ntypedef vector<ll> vll;\ntypedef vector<vb> vvb;\ntypedef vector<vi> vvi;\ntypedef vector<vll> vvll;\ntypedef pair<int, int> pii;\ntypedef pair<ll, ll> pll;\n\nconst int dx[] = { -1, 0, 1, 0 }; const int dy[] = { 0, 1, 0, -1 };\n\nstruct UnionFind {\n\tvector<int> v;\n\tUnionFind(int n) : v(n) { for (int i = 0; i < n; i++) v[i] = i; }\n\tint  find(int x) { return v[x] == x ? x : v[x] = find(v[x]); }\n\tvoid unite(int x, int y) { v[find(x)] = find(y); }\n};\nbool cal(string s, int &idx) {\n\tif (s[idx] == 'T') {\n\t\tidx++;\n\t\treturn true;\n\t}\n\tif (s[idx] == 'F') {\n\t\tidx++;\n\t\treturn false;\n\t}\n\tif (s[idx] == '-') {\n\t\tidx++;\n\t\treturn !cal(s,idx);\n\t}\n\n\tif (s[idx] == '(') {\n\t\tbool val1=cal(s, ++idx);\n\t\tint how;\n\t\tif (s[idx] == '*')\n\t\t\thow = 0;\n\t\tif (s[idx] == '+')\n\t\t\thow = 1;\n\t\tif (s[idx] == '>')\n\t\t\thow = 2;\n\t\tbool val2 = cal(s, ++idx);\n\t\tidx++;\n\t\tif (how == 0) {\n\t\t\treturn val1&&val2;\n\t\t}\n\t\tif (how == 1) {\n\t\t\treturn val1||val2;\n\t\t}\n\t\tif (how == 2) {\n\t\t\treturn !(val1 && !val2);\n\t\t}\n\t\t//??\\??????\n\t\treturn true;\n\t}\n\t//??\\??????\n\treturn true;\n}\n\nint main() {\n\tstring s;\n\twhile (cin >> s, s != \"#\") {\n\t\tstring ans = \"YES\";\n\t\tauto pos = s.find(\"->\");\n\t\twhile (pos != string::npos) {\n\t\t\ts.replace(pos, 2, \">\");\n\t\t\tpos = s.find(\"->\", pos + 1);\n\t\t}\n\t\tpos = s.find(\"--\");\n\t\twhile (pos != string::npos) {\n\t\t\ts.replace(pos, 2, \"\");\n\t\t\tpos = s.find(\"--\", pos);\n\t\t}\n\t\tint eq;\n\t\tREP(k, s.length())\n\t\t\tif (s[k] == '=')\n\t\t\t\teq = k;\n\n\t\tREP(i, 2048) {\n\t\t\tstring s2 = s;\n\t\t\tREP(j, 11) {\n\t\t\t\tREP(k, s2.length()) {\n\t\t\t\t\tif (s2[k] == 'a' + j)\n\t\t\t\t\t\tif ((i >> j) & 1) {\n\t\t\t\t\t\t\ts2[k] = 'T';\n\t\t\t\t\t\t}\n\t\t\t\t\t\telse {\n\t\t\t\t\t\t\ts2[k] = 'F';\n\t\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t}\n\t\t\tint idx1 = 0, idx2 = 0;\n\t\t\tstring s3 = s2.substr(0, eq);\n\t\t\tstring s4 = s2.substr(eq + 1, s2.length() - eq - 1);\n\t\t\tif (cal(s3, idx1) != cal(s4, idx2)) {\n\t\t\t\tans = \"NO\";\n\t\t\t\tbreak;\n\t\t\t}\n\t\t}\n\t\tcout << ans << endl;\n\t}\n}"
  },
  {
    "language": "C",
    "code": "/*\nAizuOnline A2401\nTitle Equation\n*/\n#include <stdio.h>\n// Select Below\n//#include <stdlib.h>\n#include <string.h>\n//#include <float.h>\n//#include <math.h>\n//#include <limits.h>\n//Global data section\n#define MAXLEN 1001\n#define NVARS 10\nchar expr[MAXLEN];\n\n//\nvoid strreplace(char * s,int len,char from,char to)\n{\n  int i;\n  for(i=0;i<len;i++)\n    if(s[i]==from)\n      s[i]=to;\n}\nchar * find_binary_operator2(char * s,int len,char op1,char op2)\n{\n  int i,d;\n  char *p;\n  \n  d=0;\n  for(i=len-1;i>=0;i--)\n    { \n      if(s[i]==')')\n\td++;\n      else if (s[i]=='(')\n\td--;\n      else\n\t{\n\t  if((op1==s[i]) && (op2==s[i+1]) && d==0)\n\t    return(&s[i]);\n\t}\n    }\n  return(NULL);\n}\n\nchar * find_binary_operator(char * s,int len,char op)\n{\n  int i,d;\n  char *p;\n  \n  d=0;\n  for(i=len-1;i>=0;i--)\n    { \n      if(s[i]==')')\n\td++;\n      else if (s[i]=='(')\n\td--;\n      else\n\t{\n\t  if((op==s[i]) && d==0)\n\t    return(&s[i]);\n\t}\n    }\n  return(NULL);\n}\nint logical_equal(int e1,int e2)\n{\n#ifdef DEBUG\n  printf(\"EQ:%d %d\\n\",e1,e2);\n#endif\n  return((e1==e2)?1:0);\n}\nint logical_and(int e1,int e2)\n{\n  return((e1 && e2)?1:0);\n}\nint logical_or(int e1,int e2)\n{\n  return((e1 || e2)?1:0);\n}\nint logical_naraba(int e1,int e2)\n{\n  return((e1<=e2)?1:0);\n}\nint logical_cpl(int e1)\n{\n  return((!e1)?1:0);\n}\nint logical_eval(char * exp,int len)\n{\n  char * r;\n  \n  if(len==1)\n    {\n      if(exp[0]=='T')\n\treturn(1);\n      else\n\treturn(0);\n    }\n  if(r=find_binary_operator(exp,len,'='))\n    {\n      return(logical_equal(logical_eval(exp,r-exp),\n\t\t\t   logical_eval(r+1,len-(r-exp+1))));\n    }\n  if(r=find_binary_operator(exp,len,'*'))\n    {\n      return(logical_and(logical_eval(exp,r-exp),\n\t\t\t   logical_eval(r+1,len-(r-exp+1))));\n    }\n  if(r=find_binary_operator(exp,len,'+'))\n    {\n      return(logical_or(logical_eval(exp,r-exp),\n\t\t\t   logical_eval(r+1,len-(r-exp+1))));\n    }\n  if(r=find_binary_operator2(exp,len,'-','>'))\n    {\n      return(logical_naraba(logical_eval(exp,r-exp),\n\t\t\t   logical_eval(r+2,len-(r-exp+2))));\n    }\n  if(exp[0]=='-')\n     return(logical_cpl(logical_eval(exp+1,len-1)));\n  else   if(exp[0]=='(' && exp[len-1]==')')\n    return(logical_eval(exp+1,len-2));\n  return(0);\n}\nint check_log_equation(char * exp,int len)\n{\n  int i,j;\n  char wk[MAXLEN];\n  memset(wk,0,MAXLEN);\n\n    for(i=0;i<1024;i++)   // 2^NVARS\n    {\n      memcpy(wk,exp,len);\n      for(j=0;j<10;j++)\n\t  {\n\t    strreplace(wk,len,'a'+j,(i & (1<<j)?'T':'F'));\n\t  }\n#ifdef DEBUG\n      printf(\"%*s\\n\",len+1,wk);\n#endif\n      \n      if(!logical_eval(wk,len))\n\treturn(0);\n    }\n    return(1);\n\n}\nmain()\n{\n  char *p;\n  int ret;\n\n  while(EOF!=scanf(\"%s\",expr))\n    {\n      ret=check_log_equation(expr,strlen(expr));\n\n      printf(\"%s\\n\",ret?\"YES\":\"NO\");\n    }\n  return(0);\n}"
  },
  {
    "language": "C",
    "code": "//2008dC\nI;int parse(char *p){switch(*p){\n\tcase 'F':return 0;\n\tcase 'T':return 1;\n\tcase '-':return !parse(p+1);\n\tcase '(':{\n\t\tint x=0;\n\t\tp++;\n\t\tchar *q=p;\n\t\tfor(;x!=0||*p=='-';p++){\n\t\t\tif(*p=='(')x++;\n\t\t\tif(*p==')')x--;\n\t\t}\n\t\tp++;\n\t\tswitch(*p){\n\t\t\tcase '*':return parse(q)&parse(p+1);\n\t\t\tcase '+':return parse(q)|parse(p+1);\n\t\t\tcase '-':return !parse(q)|parse(p+2);\n\t\t}\n\t}\n}return (I>>(*p-97))&1;}\nchar p[1001],*q;main(){for(;scanf(\"%s\",p),*p-'#';puts(I==2048?\"YES\":\"NO\")){\nfor(q=strchr(p,'=')+1,I=0;I<2048;I++)if(parse(p)!=parse(q))break;\n}exit(0);}"
  },
  {
    "language": "C",
    "code": "#include <stdio.h>\n\nchar str[1001];\nchar *p;\nint values;\n\nint formula() {\n\tchar ch = *p++;\n\tswitch (ch) {\n\t\tint l;\n\tcase 'T':\n\t\treturn 1;\n\tcase 'F':\n\t\treturn 0;\n\tcase '-':\n\t\treturn !formula();\n\tcase '(':\n\t\tl = formula();\n\t\tswitch (*p++) {\n\t\t\tint r;\n\t\tcase '*':\n\t\t\tr = formula();\n\t\t\tp++;\n\t\t\treturn l & r;\n\t\tcase '+':\n\t\t\tr = formula();\n\t\t\tp++;\n\t\t\treturn l | r;\n\t\tcase '-':\n\t\t\tp++;\n\t\t\tr = formula();\n\t\t\tp++;\n\t\t\treturn l == r | !l;\n\t\t}\n\tdefault:\n\t\treturn values >> ch - 'a' & 1;\n\t}\n}\n\nint equation(void) {\n\tint l, r;\n\n\tp = str;\n\tl = formula();\n\tp++;\n\tr = formula();\n\n\treturn l == r;\n}\n\nint main(void) {\n\twhile (scanf(\"%s\", str), str[0] != '#') {\n\t\tfor (values = 0; values < 2048; values++)\n\t\t\tif (!equation())\n\t\t\t\tbreak;\n\t\tif (values == 2048)\n\t\t\tputs(\"YES\");\n\t\telse\n\t\t\tputs(\"NO\");\n\t}\n\n\treturn 0;\n}"
  },
  {
    "language": "C",
    "code": "//2008dC\nI;int parse(char *p){switch(*p){\n\tcase 'F':return 0;\n\tcase 'T':return 1;\n\tcase '-':return !parse(p+1);\n\tcase '(':{\n\t\tint x=0;\n\t\tchar *q=++p;\n\t\tfor(;;p++){\n\t\t\tif(*p=='(')x++;\n\t\t\tif(*p==')')x--;\n\t\t\tif(x==0&&*p!='-')break;\n\t\t}\n\t\tp++;\n\t\tswitch(*p){\n\t\t\tcase '*':return parse(q)&parse(p+1);\n\t\t\tcase '+':return parse(q)|parse(p+1);\n\t\t\tcase '-':return !parse(q)|parse(p+2);\n\t\t}\n\t}\n}return (I>>(*p-97))&1;}\nchar p[1001],*q;main(){for(;scanf(\"%s\",p),*p-'#';puts(I==2048?\"YES\":\"NO\")){\nfor(q=strchr(p,'=')+1,I=0;I<2048;I++)if(parse(p)!=parse(q))break;\n}exit(0);}"
  },
  {
    "language": "C",
    "code": "// Aizu 2401: Equation\n// 2017.9.27 bal4u@uu\n\n#include <stdio.h>\n#include <stdlib.h>\n#include <ctype.h>\n\ntypedef struct { int id, ord; char f; } T;\nT var[12]; int n;\n\nchar buf[1002], *exp[2], *p;\n\nchar val[2050]; int assign;\n\nint cmp1(T *a, T *b) { if (b->f - a->f) return b->f - a->f; return a->id - b->id; }\nint cmp2(T *a, T *b) { return a->id - b->id; }\nint expr();\n\nint factor()\n{\n\tint x, id, f = 0;\n\n\tif (*p == '-') { f = 0; while (*p == '-') p++, f = !f; }\n\tif      (*p == 'T') p++, x = 1;\n\telse if (*p == 'F') p++, x = 0;\n\telse if (*p == '(') p++, x = expr(), p++;\n\telse {\t\t\t// a-k\n\t\tid = *p++ - 'a';\n\t\tx = (assign & (1 << var[id].ord)) != 0;\n\t}\n\tif (f) x = !x;\n\treturn x;\n}\n\nint expr()\n{\n\tint x, y, op;\n\t\n\tx = factor();\n\twhile (1) {\n\t\tif      (*p == '*') p++,  op = 0;\n\t\telse if (*p == '+') p++,  op = 1;\n\t\telse if (*p == '-') p+=2, op = 2;\n\t\telse break;\n\t\ty = factor();\n\t\tif      (op == 0) x &= y;\n\t\telse if (op == 1) x |= y;\n\t\telse { if (x == 1 && y == 0) x = 0; else x = 1; }\n\t}\n\treturn x;\n}\n\nint main()\n{\n\tint i, lim, x;\n\n\twhile (scanf(\"%s\", buf) && *buf != '#') {\n\t\texp[0] = p = buf;\n\t\twhile (*p && *p != '=') p++;\n\t\tif (!*p) goto NO;\n\t\t*p++ = 0; exp[1] = p;\n\n\t\tfor (i = 0; i < 12; i++) var[i].id = i, var[i].f = 0;\n\t\tfor (i = 0; i < 2; i++) {\n\t\t\tfor (p = exp[i]; *p; p++) if (isalpha(*p)) var[*p - 'a'].f = 1;\n\t\t}\n\t\tqsort(var, 11, sizeof(T), cmp1);\n\t\tfor (n = 0; n < 11; n++) {\n\t\t\tif (!var[n].f) break;\n\t\t\tvar[n].ord = n;\n\t\t}\n\t\tqsort(var, n, sizeof(T), cmp2);\n\n\t\tlim = 1 << n;\n\t\tfor (i = 0; i < 2; i++) for (assign = 0; assign < lim; assign++) {\n\t\t\tp = exp[i],\tx = expr();\n\t\t\tif (i == 0) val[assign] = x;\n\t\t\telse if (val[assign] != x) goto NO;\n\t\t}\n\t\tputs(\"YES\"); continue;\nNO:\t\tputs(\"NO\");\n\t}\n\treturn 0;\n}"
  },
  {
    "language": "C",
    "code": "//2008dC\nI;int parse(char *p){switch(*p){\n\tcase 'F':return 0;\n\tcase 'T':return 1;\n\tcase '-':return !parse(p+1);\n\tcase '(':{\n\t\tint x=0;\n\t\tp++;\n\t\tchar *q=p;\n\t\tfor(;x!=0||*(p-1)=='-';p++){\n\t\t\tif(*p=='(')x++;\n\t\t\tif(*p==')')x--;\n\t\t}\n\t\tswitch(*p){\n\t\t\tcase '*':return parse(q)&parse(p+1);\n\t\t\tcase '+':return parse(q)|parse(p+1);\n\t\t\tcase '-':return !parse(q)|parse(p+2);\n\t\t}\n\t}\n}return (I>>(*p-97))&1;}\nchar p[1001],*q;main(){for(;scanf(\"%s\",p),*p-'#';puts(I==2048?\"YES\":\"NO\")){\nfor(q=strchr(p,'=')+1,I=0;I<2048;I++)if(parse(p)!=parse(q))break;\n}exit(0);}"
  },
  {
    "language": "C",
    "code": "#include<stdio.h>\nint p;\nchar s[110],c[10];\nint g[][3]={\n  {0,0,1},\n  {0,1,1},\n  {0,1,0},\n  {1,1,1}\n};\nint f(int v){\n  int i,a,o;\n  if('a'<=s[p]&&s[p]<='k'){\n    for(i=0;s[p]-c[i];i++);//printf(\"%d %d %d\\n\",v,i,(v>>i)%2);\n    return (v>>i)%2;\n  }\n  if(s[p]=='T')return 1;\n  if(s[p]=='F')return 0;\n  if(s[p]=='-'){\n    p++;\n    return 1-f(v);\n  }\n  if(s[p]=='('){\n    p++;//printf(\"%s\\n\",s+p);\n    a=f(v);\n    if(s[p+1]=='*')o=0;\n    if(s[p+1]=='+')o=1;\n    if(s[p+1]=='-'){\n      o=2;\n      p++;\n    }\n    p+=2;//printf(\"%d %d %s\\n\",a,o,s+p);printf(\"\\n\");\n    a=g[a*2+f(v)][o];\n    p++;\n    return a;\n  }\n}      \nint main(){\n  int i,j,r;\n  /*while(scanf(\"%s\",s),s[0]-'#'){\n    p=0;\n    printf(\"%d\\n\",f(0));\n  }\n  return 0;//*/\n  while(scanf(\"%s\",s),s[0]-'#'){\n    for(i=r=0;s[i];i++){\n      if('a'<=s[i]&&s[i]<='k'){\n\tc[r]=s[i];\n\tfor(j=0;c[j]-s[i];j++);\n\tif(j==r)r++;\n      }\n    }\n    //for(i=0;i<r;i++)printf(\"%c \",c[i]);printf(\"\\n\");\n    //for(l=0;s[l]-'=';l++);\n    //s[l++]=0;\n    for(i=0;i<(1<<r);i++){\n      p=0;\n      j=f(i);\n      p+=2;//printf(\"%d %d %s\\n\",i,j,s+p);\n      if(j-f(i))break;\n    }//printf(\"%d\\n\",i);\n    printf(\"%s\\n\",i-(1<<r)?\"NO\":\"YES\");\n  }\n  return 0;\n}"
  },
  {
    "language": "C",
    "code": "int _a,_b,_c,_d,_e,_f,_g,_h,_i,_j,_k;\n\nint parse(char *p){\n  switch(*p){\n    case 'F': return 0;\n    case 'T': return 1;\n    case 'a': return _a;\n    case 'b': return _b;\n    case 'c': return _c;\n    case 'd': return _d;\n    case 'e': return _e;\n    case 'f': return _f;\n    case 'g': return _g;\n    case 'h': return _h;\n    case 'i': return _i;\n    case 'j': return _j;\n    case 'k': return _k;\n    case '-': return !parse(p+1);\n    case '(': {\n                int x=0;\n                p++;\n                char *q=p;\n                for(;;p++){\n                  if(*p=='(')x++;\n                  if(*p==')')x--;\n                  if(x==0&&*p!='-')break;\n                }\n                p++;\n                switch(*p){\n                  case '*': return parse(q)&parse(p+1);\n                  case '+': return parse(q)|parse(p+1);\n                  case '-': return !parse(q)|parse(p+2);\n                }\n              }\n  }\n}\n\nint main(){\n  char p[81],*q;\n  while(1){\n    scanf(\"%s\",p);\n    if(*p=='#')return 0;\n\tq=strchr(p,'=')+1;\n    for(_a=0;_a<2;_a++)\n      for(_b=0;_b<2;_b++)\n        for(_c=0;_c<2;_c++)\n          for(_d=0;_d<2;_d++)\n            for(_e=0;_e<2;_e++)\n              for(_f=0;_f<2;_f++)\n                for(_g=0;_g<2;_g++)\n                  for(_h=0;_h<2;_h++)\n                    for(_i=0;_i<2;_i++)\n                      for(_j=0;_j<2;_j++)\n                        for(_k=0;_k<2;_k++)\n                          if(parse(p)!=parse(q))goto fail;\n    puts(\"YES\");continue;\n\tfail:puts(\"NO\");\n  }\n}"
  },
  {
    "language": "C",
    "code": "#include <stdio.h>\n#include <string.h>\n\nenum {\n\tTYPE_CONST,\n\tTYPE_VALUE,\n\tTYPE_OPERATOR\n};\n\n#define OPERATOR_MUL\t0\n#define OPERATOR_ADD\t1\n#define OPERATOR_ARROW\t2\n#define OPERATOR_NOT\t3\n#define OPERATOR_KAKKO\t4\n\n/* l->r l*2+r */\nint result[3][4]={\n\t{0,0,0,1}, /* mul   */\n\t{0,1,1,1}, /* add   */\n\t{1,1,0,1}  /* arrow */\n};\n\ntypedef struct {\n\tint type;\n\tint value;\n} calc_t;\n\nint left_num;\ncalc_t calc_left[1000];\nint right_num;\ncalc_t calc_right[1000];\n\nint stack_num;\nint calc_stack[1000];\n\nvoid build_reverse_porland(const char* siki,calc_t* calc,int* num) {\n\tconst char* now;\n\t*num=0;\n\tstack_num=0;\n\tfor(now=siki;*now;now++) {\n\t\tswitch(*now) {\n\t\t\tcase 'T':\n\t\t\t\tcalc[*num].type=TYPE_CONST;\n\t\t\t\tcalc[*num].value=1;\n\t\t\t\t(*num)++;\n\t\t\t\tbreak;\n\t\t\tcase 'F':\n\t\t\t\tcalc[*num].type=TYPE_CONST;\n\t\t\t\tcalc[*num].value=0;\n\t\t\t\t(*num)++;\n\t\t\t\tbreak;\n\t\t\tcase 'a': case 'b': case 'c': case 'd': case 'e':\n\t\t\tcase 'f': case 'g': case 'h': case 'i': case 'j':\n\t\t\t\tcalc[*num].type=TYPE_VALUE;\n\t\t\t\tcalc[*num].value=(*now)-'a';\n\t\t\t\t(*num)++;\n\t\t\t\tbreak;\n\t\t\tcase '-':\n\t\t\t\tif(*(now+1)=='>') {\n\t\t\t\t\twhile(stack_num>0 &&\n\t\t\t\t\t\t\tcalc_stack[stack_num-1]!=OPERATOR_KAKKO) {\n\t\t\t\t\t\tcalc[*num].type=TYPE_OPERATOR;\n\t\t\t\t\t\tcalc[*num].value=calc_stack[--stack_num];\n\t\t\t\t\t\t(*num)++;\n\t\t\t\t\t}\n\t\t\t\t\tcalc_stack[stack_num++]=OPERATOR_ARROW;\n\t\t\t\t\tnow++;\n\t\t\t\t} else {\n\t\t\t\t\tcalc_stack[stack_num++]=OPERATOR_NOT;\n\t\t\t\t}\n\t\t\t\tbreak;\n\t\t\tcase '*':\n\t\t\t\twhile(stack_num>0 &&\n\t\t\t\t\t\tcalc_stack[stack_num-1]!=OPERATOR_KAKKO) {\n\t\t\t\t\tcalc[*num].type=TYPE_OPERATOR;\n\t\t\t\t\tcalc[*num].value=calc_stack[--stack_num];\n\t\t\t\t\t(*num)++;\n\t\t\t\t}\n\t\t\t\tcalc_stack[stack_num++]=OPERATOR_MUL;\n\t\t\t\tbreak;\n\t\t\tcase '+':\n\t\t\t\twhile(stack_num>0 &&\n\t\t\t\t\t\tcalc_stack[stack_num-1]!=OPERATOR_KAKKO) {\n\t\t\t\t\tcalc[*num].type=TYPE_OPERATOR;\n\t\t\t\t\tcalc[*num].value=calc_stack[--stack_num];\n\t\t\t\t\t(*num)++;\n\t\t\t\t}\n\t\t\t\tcalc_stack[stack_num++]=OPERATOR_ADD;\n\t\t\t\tbreak;\n\t\t\tcase '(':\n\t\t\t\tcalc_stack[stack_num++]=OPERATOR_KAKKO;\n\t\t\t\tbreak;\n\t\t\tcase ')':\n\t\t\t\twhile(stack_num>0 &&\n\t\t\t\t\t\tcalc_stack[stack_num-1]!=OPERATOR_KAKKO) {\n\t\t\t\t\tcalc[*num].type=TYPE_OPERATOR;\n\t\t\t\t\tcalc[*num].value=calc_stack[--stack_num];\n\t\t\t\t\t(*num)++;\n\t\t\t\t}\n\t\t\t\tif(stack_num>0)stack_num--;\n\t\t\t\tbreak;\n\t\t}\n\t}\n\twhile(stack_num>0) {\n\t\tcalc[*num].type=TYPE_OPERATOR;\n\t\tcalc[*num].value=calc_stack[--stack_num];\n\t\t(*num)++;\n\t}\n}\n\nint calc_reverse_porland(const calc_t* siki,int num,int value) {\n\tint i;\n\tstack_num=0;\n\tfor(i=0;i<num;i++) {\n\t\tswitch(siki[i].type) {\n\t\t\tcase TYPE_CONST:\n\t\t\t\tcalc_stack[stack_num++]=siki[i].value;\n\t\t\t\tbreak;\n\t\t\tcase TYPE_VALUE:\n\t\t\t\tcalc_stack[stack_num++]=(value>>siki[i].value)&1;\n\t\t\t\tbreak;\n\t\t\tcase TYPE_OPERATOR:\n\t\t\t\tif(siki[i].value==OPERATOR_NOT) {\n\t\t\t\t\tif(stack_num<1)return -1;\n\t\t\t\t\tcalc_stack[stack_num-1]=(calc_stack[stack_num-1]?0:1);\n\t\t\t\t} else {\n\t\t\t\t\tif(stack_num<2)return 2;\n\t\t\t\t\tcalc_stack[stack_num-2]=result[siki[i].value]\n\t\t\t\t\t\t[calc_stack[stack_num-2]*2+calc_stack[stack_num-1]];\n\t\t\t\t\tstack_num--;\n\t\t\t\t}\n\t\t\t\tbreak;\n\t\t}\n\t}\n\tif(stack_num!=1)return -1;\n\treturn calc_stack[0];\n}\n\nint main(void) {\n\tchar input[1004];\n\tchar* second;\n\tint i;\n\tint a,b;\n\tint ok;\n\twhile(1) {\n\t\tscanf(\"%s\",input);\n\t\tif(strcmp(input,\"#\")==0)break;\n\t\tsecond=strchr(input,'=');\n\t\tif(second==NULL)return 1;\n\t\t*second=0;\n\t\tsecond++;\n\t\tbuild_reverse_porland(input,calc_left,&left_num);\n\t\tbuild_reverse_porland(second,calc_right,&right_num);\n\t\tok=1;\n\t\tfor(i=0;i<1024;i++) {\n\t\t\ta=calc_reverse_porland(calc_left,left_num,i);\n\t\t\tb=calc_reverse_porland(calc_right,right_num,i);\n\t\t\tif(a<0 || b<0)return 2;\n\t\t\tif(a!=b){ok=0;break;}\n\t\t}\n\t\tputs(ok?\"YES\":\"NO\");\n\t}\n\treturn 0;\n}"
  },
  {
    "language": "C",
    "code": "//2008dC\nI;int parse(char *p){switch(*p){\n\tcase 'F':return 0;\n\tcase 'T':return 1;\n\tcase '-':return !parse(p+1);\n\tcase '(':{\n\t\tint x=0;\n\t\tp++;\n\t\tchar *q=p;\n\t\tfor(;x!=0||*p=='-';p++){\n\t\t\tif(*p=='(')x++;\n\t\t\tif(*p==')')x--;\n\t\t}\n\t\tswitch(*p){\n\t\t\tcase '*':return parse(q)&parse(p+1);\n\t\t\tcase '+':return parse(q)|parse(p+1);\n\t\t\tcase '-':return !parse(q)|parse(p+2);\n\t\t}\n\t}\n}return (I>>(*p-97))&1;}\nchar p[1001],*q;main(){for(;scanf(\"%s\",p),*p-'#';puts(I==2048?\"YES\":\"NO\")){\nfor(q=strchr(p,'=')+1,I=0;I<2048;I++)if(parse(p)!=parse(q))break;\n}exit(0);}"
  },
  {
    "language": "C",
    "code": "//2008dC\nI;int parse(char *p){switch(*p){\n\tcase'F':return 0;\n\tcase'T':return 1;\n\tcase'-':return!parse(p+1);\n\tcase'(':{\n\t\tint x=0;\n\t\tchar*q=++p;\n\t\tfor(;;p++){\n\t\t\tif(*p=='(')x++;\n\t\t\tif(*p==')')x--;\n\t\t\tif(x==0&&*p!='-')break;\n\t\t}\n\t\tswitch(*(++p)){\n\t\t\tcase'*':return parse(q)&parse(p+1);\n\t\t\tcase'+':return parse(q)|parse(p+1);\n\t\t\tcase'-':return!parse(q)|parse(p+2);\n\t\t}\n\t}\n}return(I>>(*p-97))&1;}\nchar p[1001],*q;main(){for(;scanf(\"%s\",p),*p-'#';puts(I==2048?\"YES\":\"NO\")){for(q=strchr(p,'=')+1,I=0;I<2048;I++)if(parse(p)!=parse(q))break;}exit(0);}"
  },
  {
    "language": "C",
    "code": "//2008dC\nI;int parse(char *p){switch(*p){\n\tcase'F':return 0;\n\tcase 'T':return 1;\n\tcase '-':return !parse(p+1);\n\tcase '(':{\n\t\tint x=0;\n\t\tchar *q=++p;\n\t\tfor(;;p++){\n\t\t\tif(*p=='(')x++;\n\t\t\tif(*p==')')x--;\n\t\t\tif(x==0&&*p!='-')break;\n\t\t}\n\t\tswitch(*(++p)){\n\t\t\tcase '*':return parse(q)&parse(p+1);\n\t\t\tcase '+':return parse(q)|parse(p+1);\n\t\t\tcase '-':return !parse(q)|parse(p+2);\n\t\t}\n\t}\n}return (I>>(*p-97))&1;}\nchar p[1001],*q;main(){for(;scanf(\"%s\",p),*p-'#';puts(I==2048?\"YES\":\"NO\")){\nfor(q=strchr(p,'=')+1,I=0;I<2048;I++)if(parse(p)!=parse(q))break;\n}exit(0);}"
  },
  {
    "language": "C",
    "code": "#include<stdio.h>\nint p;\nchar s[1010],c[10];\nint g[][3]={\n  {0,0,1},\n  {0,1,1},\n  {0,1,0},\n  {1,1,1}\n};\nint f(int v){\n  int i,a,o;\n  if('a'<=s[p]&&s[p]<='k'){\n    for(i=0;s[p]-c[i];i++);//printf(\"%d %d %d\\n\",v,i,(v>>i)%2);\n    return (v>>i)%2;\n  }\n  if(s[p]=='T')return 1;\n  if(s[p]=='F')return 0;\n  if(s[p]=='-'){\n    p++;\n    return 1-f(v);\n  }\n  if(s[p]=='('){\n    p++;//printf(\"%s\\n\",s+p);\n    a=f(v);\n    if(s[p+1]=='*')o=0;\n    if(s[p+1]=='+')o=1;\n    if(s[p+1]=='-'){\n      o=2;\n      p++;\n    }\n    p+=2;//printf(\"%d %d %s\\n\",a,o,s+p);printf(\"\\n\");\n    a=g[a*2+f(v)][o];\n    p++;\n    return a;\n  }\n}      \nint main(){\n  int i,j,r;\n  /*while(scanf(\"%s\",s),s[0]-'#'){\n    p=0;\n    printf(\"%d\\n\",f(0));\n  }\n  return 0;//*/\n  while(scanf(\"%s\",s),s[0]-'#'){\n    for(i=r=0;s[i];i++){\n      if('a'<=s[i]&&s[i]<='k'){\n\tc[r]=s[i];\n\tfor(j=0;c[j]-s[i];j++);\n\tif(j==r)r++;\n      }\n    }\n    //for(i=0;i<r;i++)printf(\"%c \",c[i]);printf(\"\\n\");\n    //for(l=0;s[l]-'=';l++);\n    //s[l++]=0;\n    for(i=0;i<(1<<r);i++){\n      p=0;\n      j=f(i);\n      p+=2;//printf(\"%d %d %s\\n\",i,j,s+p);\n      if(j-f(i))break;\n    }//printf(\"%d\\n\",i);\n    printf(\"%s\\n\",i-(1<<r)?\"NO\":\"YES\");\n  }\n  return 0;\n}"
  },
  {
    "language": "C",
    "code": "#include <stdio.h>\n#include <string.h>\n\nenum {\n\tTYPE_CONST,\n\tTYPE_VALUE,\n\tTYPE_OPERATOR\n};\n\n#define OPERATOR_MUL\t0\n#define OPERATOR_ADD\t1\n#define OPERATOR_ARROW\t2\n#define OPERATOR_NOT\t3\n#define OPERATOR_KAKKO\t4\n\n/* l->r l*2+r */\nint result[3][4]={\n\t{0,0,0,1}, /* mul   */\n\t{0,1,1,1}, /* add   */\n\t{1,1,0,1}  /* arrow */\n};\n\ntypedef struct {\n\tint type;\n\tint value;\n} calc_t;\n\nint left_num;\ncalc_t calc_left[1000];\nint right_num;\ncalc_t calc_right[1000];\n\nint stack_num;\nint calc_stack[1000];\n\nvoid build_reverse_porland(const char* siki,calc_t* calc,int* num) {\n\tconst char* now;\n\t*num=0;\n\tstack_num=0;\n\tfor(now=siki;*now;now++) {\n\t\tswitch(*now) {\n\t\t\tcase 'T':\n\t\t\t\tcalc[*num].type=TYPE_CONST;\n\t\t\t\tcalc[*num].value=1;\n\t\t\t\t(*num)++;\n\t\t\t\tbreak;\n\t\t\tcase 'F':\n\t\t\t\tcalc[*num].type=TYPE_CONST;\n\t\t\t\tcalc[*num].value=0;\n\t\t\t\t(*num)++;\n\t\t\t\tbreak;\n\t\t\tcase 'a': case 'b': case 'c': case 'd': case 'e':\n\t\t\tcase 'f': case 'g': case 'h': case 'i': case 'j':\n\t\t\t\tcalc[*num].type=TYPE_VALUE;\n\t\t\t\tcalc[*num].value=(*now)-'a';\n\t\t\t\t(*num)++;\n\t\t\t\tbreak;\n\t\t\tcase '-':\n\t\t\t\tif(*(now+1)=='>') {\n\t\t\t\t\twhile(stack_num>0 &&\n\t\t\t\t\t\t\tcalc_stack[stack_num-1]!=OPERATOR_KAKKO) {\n\t\t\t\t\t\tcalc[*num].type=TYPE_OPERATOR;\n\t\t\t\t\t\tcalc[*num].value=calc_stack[--stack_num];\n\t\t\t\t\t\t(*num)++;\n\t\t\t\t\t}\n\t\t\t\t\tcalc_stack[stack_num++]=OPERATOR_ARROW;\n\t\t\t\t\tnow++;\n\t\t\t\t} else {\n\t\t\t\t\tcalc_stack[stack_num++]=OPERATOR_NOT;\n\t\t\t\t}\n\t\t\t\tbreak;\n\t\t\tcase '*':\n\t\t\t\twhile(stack_num>0 &&\n\t\t\t\t\t\tcalc_stack[stack_num-1]!=OPERATOR_KAKKO) {\n\t\t\t\t\tcalc[*num].type=TYPE_OPERATOR;\n\t\t\t\t\tcalc[*num].value=calc_stack[--stack_num];\n\t\t\t\t\t(*num)++;\n\t\t\t\t}\n\t\t\t\tcalc_stack[stack_num++]=OPERATOR_MUL;\n\t\t\t\tbreak;\n\t\t\tcase '+':\n\t\t\t\twhile(stack_num>0 &&\n\t\t\t\t\t\tcalc_stack[stack_num-1]!=OPERATOR_KAKKO) {\n\t\t\t\t\tcalc[*num].type=TYPE_OPERATOR;\n\t\t\t\t\tcalc[*num].value=calc_stack[--stack_num];\n\t\t\t\t\t(*num)++;\n\t\t\t\t}\n\t\t\t\tcalc_stack[stack_num++]=OPERATOR_ADD;\n\t\t\t\tbreak;\n\t\t\tcase '(':\n\t\t\t\tcalc_stack[stack_num++]=OPERATOR_KAKKO;\n\t\t\t\tbreak;\n\t\t\tcase ')':\n\t\t\t\twhile(stack_num>0 &&\n\t\t\t\t\t\tcalc_stack[stack_num-1]!=OPERATOR_KAKKO) {\n\t\t\t\t\tcalc[*num].type=TYPE_OPERATOR;\n\t\t\t\t\tcalc[*num].value=calc_stack[--stack_num];\n\t\t\t\t\t(*num)++;\n\t\t\t\t}\n\t\t\t\tif(stack_num>0)stack_num--;\n\t\t\t\tbreak;\n\t\t}\n\t}\n\twhile(stack_num>0) {\n\t\tcalc[*num].type=TYPE_OPERATOR;\n\t\tcalc[*num].value=calc_stack[--stack_num];\n\t\t(*num)++;\n\t}\n}\n\nint calc_reverse_porland(const calc_t* siki,int num,int value) {\n\tint i;\n\tstack_num=0;\n\tfor(i=0;i<num;i++) {\n\t\tswitch(siki[i].type) {\n\t\t\tcase TYPE_CONST:\n\t\t\t\tcalc_stack[stack_num++]=siki[i].value;\n\t\t\t\tbreak;\n\t\t\tcase TYPE_VALUE:\n\t\t\t\tcalc_stack[stack_num++]=(value>>siki[i].value)&1;\n\t\t\t\tbreak;\n\t\t\tcase TYPE_OPERATOR:\n\t\t\t\tif(siki[i].value==OPERATOR_NOT) {\n\t\t\t\t\tif(stack_num<1)return 2;\n\t\t\t\t\tcalc_stack[stack_num-1]=(calc_stack[stack_num-1]?0:1);\n\t\t\t\t} else {\n\t\t\t\t\tif(stack_num<2)return 2;\n\t\t\t\t\tcalc_stack[stack_num-2]=result[siki[i].value]\n\t\t\t\t\t\t[calc_stack[stack_num-2]*2+calc_stack[stack_num-1]];\n\t\t\t\t\tstack_num--;\n\t\t\t\t}\n\t\t\t\tbreak;\n\t\t}\n\t}\n\tif(stack_num!=1)return -1;\n\treturn calc_stack[0];\n}\n\nint main(void) {\n\tchar input[1004];\n\tchar* second;\n\tint i;\n\tint a,b;\n\tint ok;\n\twhile(1) {\n\t\tscanf(\"%s\",input);\n\t\tif(strcmp(input,\"#\")==0)break;\n\t\tsecond=strchr(input,'=');\n\t\tif(second==NULL)return 1;\n\t\t*second=0;\n\t\tsecond++;\n\t\tbuild_reverse_porland(input,calc_left,&left_num);\n\t\tbuild_reverse_porland(second,calc_right,&right_num);\n\t\tok=1;\n\t\tfor(i=0;i<1024;i++) {\n\t\t\ta=calc_reverse_porland(calc_left,left_num,i);\n\t\t\tb=calc_reverse_porland(calc_right,right_num,i);\n\t\t\tif(a<0 || b<0)return 2;\n\t\t\tif(a!=b){ok=0;break;}\n\t\t}\n\t\tputs(ok?\"YES\":\"NO\");\n\t}\n\treturn 0;\n}"
  },
  {
    "language": "C",
    "code": "#include <stdio.h>\n#include <string.h>\n\nenum {\n\tTYPE_CONST,\n\tTYPE_VALUE,\n\tTYPE_OPERATOR\n};\n\n#define OPERATOR_MUL\t0\n#define OPERATOR_ADD\t1\n#define OPERATOR_ARROW\t2\n#define OPERATOR_NOT\t3\n#define OPERATOR_KAKKO\t4\n\n/* l->r l*2+r */\nint result[3][4]={\n\t{0,0,0,1}, /* mul   */\n\t{0,1,1,1}, /* add   */\n\t{1,1,0,1}  /* arrow */\n};\n\ntypedef struct {\n\tint type;\n\tint value;\n} calc_t;\n\nint left_num;\ncalc_t calc_left[1000];\nint right_num;\ncalc_t calc_right[1000];\n\nint stack_num;\nint calc_stack[1000];\n\nvoid build_reverse_porland(const char* siki,calc_t* calc,int* num) {\n\tconst char* now;\n\t*num=0;\n\tstack_num=0;\n\tfor(now=siki;*now;now++) {\n\t\tswitch(*now) {\n\t\t\tcase 'T':\n\t\t\t\tcalc[*num].type=TYPE_CONST;\n\t\t\t\tcalc[*num].value=1;\n\t\t\t\t(*num)++;\n\t\t\t\tbreak;\n\t\t\tcase 'F':\n\t\t\t\tcalc[*num].type=TYPE_CONST;\n\t\t\t\tcalc[*num].value=0;\n\t\t\t\t(*num)++;\n\t\t\t\tbreak;\n\t\t\tcase 'a': case 'b': case 'c': case 'd': case 'e':\n\t\t\tcase 'f': case 'g': case 'h': case 'i': case 'j':\n\t\t\t\tcalc[*num].type=TYPE_VALUE;\n\t\t\t\tcalc[*num].value=(*now)-'a';\n\t\t\t\t(*num)++;\n\t\t\t\tbreak;\n\t\t\tcase '-':\n\t\t\t\tif(*(now+1)=='>') {\n\t\t\t\t\twhile(stack_num>0 &&\n\t\t\t\t\t\t\tcalc_stack[stack_num-1]!=OPERATOR_KAKKO) {\n\t\t\t\t\t\tcalc[*num].type=TYPE_OPERATOR;\n\t\t\t\t\t\tcalc[*num].value=calc_stack[--stack_num];\n\t\t\t\t\t\t(*num)++;\n\t\t\t\t\t}\n\t\t\t\t\tcalc_stack[stack_num++]=OPERATOR_ARROW;\n\t\t\t\t\tnow++;\n\t\t\t\t} else {\n\t\t\t\t\tcalc_stack[stack_num++]=OPERATOR_NOT;\n\t\t\t\t}\n\t\t\t\tbreak;\n\t\t\tcase '*':\n\t\t\t\twhile(stack_num>0 &&\n\t\t\t\t\t\tcalc_stack[stack_num-1]!=OPERATOR_KAKKO) {\n\t\t\t\t\tcalc[*num].type=TYPE_OPERATOR;\n\t\t\t\t\tcalc[*num].value=calc_stack[--stack_num];\n\t\t\t\t\t(*num)++;\n\t\t\t\t}\n\t\t\t\tcalc_stack[stack_num++]=OPERATOR_MUL;\n\t\t\t\tbreak;\n\t\t\tcase '+':\n\t\t\t\twhile(stack_num>0 &&\n\t\t\t\t\t\tcalc_stack[stack_num-1]!=OPERATOR_KAKKO) {\n\t\t\t\t\tcalc[*num].type=TYPE_OPERATOR;\n\t\t\t\t\tcalc[*num].value=calc_stack[--stack_num];\n\t\t\t\t\t(*num)++;\n\t\t\t\t}\n\t\t\t\tcalc_stack[stack_num++]=OPERATOR_ADD;\n\t\t\t\tbreak;\n\t\t\tcase '(':\n\t\t\t\tcalc_stack[stack_num++]=OPERATOR_KAKKO;\n\t\t\t\tbreak;\n\t\t\tcase ')':\n\t\t\t\twhile(stack_num>0 &&\n\t\t\t\t\t\tcalc_stack[stack_num-1]!=OPERATOR_KAKKO) {\n\t\t\t\t\tcalc[*num].type=TYPE_OPERATOR;\n\t\t\t\t\tcalc[*num].value=calc_stack[--stack_num];\n\t\t\t\t\t(*num)++;\n\t\t\t\t}\n\t\t\t\tif(stack_num>0)stack_num--;\n\t\t\t\tbreak;\n\t\t}\n\t}\n\twhile(stack_num>0) {\n\t\tcalc[*num].type=TYPE_OPERATOR;\n\t\tcalc[*num].value=calc_stack[--stack_num];\n\t\t(*num)++;\n\t}\n}\n\nint calc_reverse_porland(const calc_t* siki,int num,int value) {\n\tint i;\n\tstack_num=0;\n\tfor(i=0;i<num;i++) {\n\t\tswitch(siki[i].type) {\n\t\t\tcase TYPE_CONST:\n\t\t\t\tcalc_stack[stack_num++]=siki[i].value;\n\t\t\t\tbreak;\n\t\t\tcase TYPE_VALUE:\n\t\t\t\tcalc_stack[stack_num++]=(value>>siki[i].value)&1;\n\t\t\t\tbreak;\n\t\t\tcase TYPE_OPERATOR:\n\t\t\t\tif(siki[i].value==OPERATOR_NOT) {\n\t\t\t\t\tif(stack_num<1)return -1;\n\t\t\t\t\tcalc_stack[stack_num-1]=(calc_stack[stack_num-1]?0:1);\n\t\t\t\t} else {\n\t\t\t\t\tif(stack_num<2)return -1;\n\t\t\t\t\tcalc_stack[stack_num-2]=result[siki[i].value]\n\t\t\t\t\t\t[calc_stack[stack_num-2]*2+calc_stack[stack_num-1]];\n\t\t\t\t\tstack_num--;\n\t\t\t\t}\n\t\t\t\tbreak;\n\t\t}\n\t}\n\tif(stack_num!=1)return 2;\n\treturn calc_stack[0];\n}\n\nint main(void) {\n\tchar input[1004];\n\tchar* second;\n\tint i;\n\tint a,b;\n\tint ok;\n\twhile(1) {\n\t\tscanf(\"%s\",input);\n\t\tif(strcmp(input,\"#\")==0)break;\n\t\tsecond=strchr(input,'=');\n\t\tif(second==NULL)return 1;\n\t\t*second=0;\n\t\tsecond++;\n\t\tbuild_reverse_porland(input,calc_left,&left_num);\n\t\tbuild_reverse_porland(second,calc_right,&right_num);\n\t\tok=1;\n\t\tfor(i=0;i<1024;i++) {\n\t\t\ta=calc_reverse_porland(calc_left,left_num,i);\n\t\t\tb=calc_reverse_porland(calc_right,right_num,i);\n\t\t\tif(a<0 || b<0)return 2;\n\t\t\tif(a!=b){ok=0;break;}\n\t\t}\n\t\tputs(ok?\"YES\":\"NO\");\n\t}\n\treturn 0;\n}"
  },
  {
    "language": "C",
    "code": "//2008dC\nI;int parse(char *p){switch(*p){\n\tcase 'F':return 0;\n\tcase 'T':return 1;\n\tcase '-':return !parse(p+1);\n\tcase '(':{\n\t\tint x=0;\n\t\tp++;\n\t\tchar *q=p;\n\t\tfor(;;p++){\n\t\t\tif(*p=='(')x++;\n\t\t\tif(*p==')')x--;\n\t\t\tif(x==0&&*p!='-')break;\n\t\t}\n\t\tp++;\n\t\tswitch(*p){\n\t\t\tcase '*': return parse(q)&parse(p+1);\n\t\t\tcase '+': return parse(q)|parse(p+1);\n\t\t\tcase '-': return !parse(q)|parse(p+2);\n\t\t}\n\t}\n}return (I>>(*p-97))&1;}\nchar p[1001],*q;main(){for(;scanf(\"%s\",p),*p-'#';puts(I==2048?\"YES\":\"NO\")){\nfor(q=strchr(p,'=')+1,I=0;I<2048;I++)if(parse(p)!=parse(q))break;\n}exit(0);}"
  },
  {
    "language": "C",
    "code": "#include <stdio.h>\n#include <string.h>\n\nenum {\n\tTYPE_CONST,\n\tTYPE_VALUE,\n\tTYPE_OPERATOR\n};\n\n#define OPERATOR_MUL\t0\n#define OPERATOR_ADD\t1\n#define OPERATOR_ARROW\t2\n#define OPERATOR_NOT\t3\n#define OPERATOR_KAKKO\t4\n\n/* l->r l*2+r */\nint result[3][4]={\n\t{0,0,0,1}, /* mul   */\n\t{0,1,1,1}, /* add   */\n\t{1,1,0,1}  /* arrow */\n};\n\ntypedef struct {\n\tint type;\n\tint value;\n} calc_t;\n\nint left_num;\ncalc_t calc_left[1000];\nint right_num;\ncalc_t calc_right[1000];\n\nint stack_num;\nint calc_stack[1000];\n\nvoid build_reverse_porland(const char* siki,calc_t* calc,int* num) {\n\tconst char* now;\n\t*num=0;\n\tstack_num=0;\n\tfor(now=siki;*now;now++) {\n\t\tswitch(*now) {\n\t\t\tcase 'T':\n\t\t\t\tcalc[*num].type=TYPE_CONST;\n\t\t\t\tcalc[*num].value=1;\n\t\t\t\t(*num)++;\n\t\t\t\tbreak;\n\t\t\tcase 'F':\n\t\t\t\tcalc[*num].type=TYPE_CONST;\n\t\t\t\tcalc[*num].value=0;\n\t\t\t\t(*num)++;\n\t\t\t\tbreak;\n\t\t\tcase 'a': case 'b': case 'c': case 'd': case 'e':\n\t\t\tcase 'f': case 'g': case 'h': case 'i': case 'j':\n\t\t\t\tcalc[*num].type=TYPE_VALUE;\n\t\t\t\tcalc[*num].value=(*now)-'a';\n\t\t\t\t(*num)++;\n\t\t\t\tbreak;\n\t\t\tcase '-':\n\t\t\t\tif(*(now+1)=='>') {\n\t\t\t\t\twhile(stack_num>0 &&\n\t\t\t\t\t\t\tcalc_stack[stack_num-1]!=OPERATOR_KAKKO) {\n\t\t\t\t\t\tcalc[*num].type=TYPE_OPERATOR;\n\t\t\t\t\t\tcalc[*num].value=calc_stack[--stack_num];\n\t\t\t\t\t\t(*num)++;\n\t\t\t\t\t}\n\t\t\t\t\tcalc_stack[stack_num++]=OPERATOR_ARROW;\n\t\t\t\t\tnow++;\n\t\t\t\t} else {\n\t\t\t\t\tcalc_stack[stack_num++]=OPERATOR_NOT;\n\t\t\t\t}\n\t\t\t\tbreak;\n\t\t\tcase '*':\n\t\t\t\twhile(stack_num>0 &&\n\t\t\t\t\t\tcalc_stack[stack_num-1]!=OPERATOR_KAKKO) {\n\t\t\t\t\tcalc[*num].type=TYPE_OPERATOR;\n\t\t\t\t\tcalc[*num].value=calc_stack[--stack_num];\n\t\t\t\t\t(*num)++;\n\t\t\t\t}\n\t\t\t\tcalc_stack[stack_num++]=OPERATOR_MUL;\n\t\t\t\tbreak;\n\t\t\tcase '+':\n\t\t\t\twhile(stack_num>0 &&\n\t\t\t\t\t\tcalc_stack[stack_num-1]!=OPERATOR_KAKKO) {\n\t\t\t\t\tcalc[*num].type=TYPE_OPERATOR;\n\t\t\t\t\tcalc[*num].value=calc_stack[--stack_num];\n\t\t\t\t\t(*num)++;\n\t\t\t\t}\n\t\t\t\tcalc_stack[stack_num++]=OPERATOR_ADD;\n\t\t\t\tbreak;\n\t\t\tcase '(':\n\t\t\t\tcalc_stack[stack_num++]=OPERATOR_KAKKO;\n\t\t\t\tbreak;\n\t\t\tcase ')':\n\t\t\t\twhile(stack_num>0 &&\n\t\t\t\t\t\tcalc_stack[stack_num-1]!=OPERATOR_KAKKO) {\n\t\t\t\t\tcalc[*num].type=TYPE_OPERATOR;\n\t\t\t\t\tcalc[*num].value=calc_stack[--stack_num];\n\t\t\t\t\t(*num)++;\n\t\t\t\t}\n\t\t\t\tif(stack_num>0)stack_num--;\n\t\t\t\tbreak;\n\t\t}\n\t}\n\twhile(stack_num>0) {\n\t\tcalc[*num].type=TYPE_OPERATOR;\n\t\tcalc[*num].value=calc_stack[--stack_num];\n\t\t(*num)++;\n\t}\n}\n\nint calc_reverse_porland(const calc_t* siki,int num,int value) {\n\tint i;\n\tstack_num=0;\n\tfor(i=0;i<num;i++) {\n\t\tswitch(siki[i].type) {\n\t\t\tcase TYPE_CONST:\n\t\t\t\tcalc_stack[stack_num++]=siki[i].value;\n\t\t\t\tbreak;\n\t\t\tcase TYPE_VALUE:\n\t\t\t\tcalc_stack[stack_num++]=(value>>siki[i].value)&1;\n\t\t\t\tbreak;\n\t\t\tcase TYPE_OPERATOR:\n\t\t\t\tif(siki[i].value==OPERATOR_NOT) {\n\t\t\t\t\tif(stack_num<1)return -1;\n\t\t\t\t\tcalc_stack[stack_num-1]=(calc_stack[stack_num-1]?0:1);\n\t\t\t\t} else {\n\t\t\t\t\tif(stack_num<2)return -1;\n\t\t\t\t\tcalc_stack[stack_num-2]=result[siki[i].value]\n\t\t\t\t\t\t[calc_stack[stack_num-2]*2+calc_stack[stack_num-1]];\n\t\t\t\t\tstack_num--;\n\t\t\t\t}\n\t\t\t\tbreak;\n\t\t}\n\t}\n\tif(stack_num!=1)return -1;\n\treturn calc_stack[0];\n}\n\nint main(void) {\n\tchar input[1004];\n\tchar* second;\n\tint i;\n\tint a,b;\n\tint ok;\n\twhile(1) {\n\t\tscanf(\"%s\",input);\n\t\tif(strcmp(input,\"#\")==0)break;\n\t\tsecond=strchr(input,'=');\n\t\tif(second==NULL)return 1;\n\t\t*second=0;\n\t\tsecond++;\n\t\tbuild_reverse_porland(input,calc_left,&left_num);\n\t\tbuild_reverse_porland(second,calc_right,&right_num);\n\t\tok=1;\n\t\tfor(i=0;i<1024;i++) {\n\t\t\ta=calc_reverse_porland(calc_left,left_num,i);\n\t\t\tb=calc_reverse_porland(calc_right,right_num,i);\n\t\t\tif(a<0 || b<0)return 0;\n\t\t\tif(a!=b){ok=0;break;}\n\t\t}\n\t\tputs(ok?\"YES\":\"NO\");\n\t}\n\treturn 0;\n}"
  },
  {
    "language": "C",
    "code": "#include<stdio.h>\nchar str[1024];\nint var[20];\nint cur=0;\nint form(){\n    if(str[cur]=='T'){cur++;return 1;}\n    if(str[cur]=='F'){cur++;return 0;}\n    if(str[cur]>='a'&&str[cur]<='z'){cur++;return var[str[cur-1]-'a'];}\n    \n    if(str[cur]=='-'){\n        cur++;\n        int tmp=form();\n        return !tmp;\n    }\n    if(str[cur]=='('){\n        cur++;\n        int L=form();\n        int R;\n        if(str[cur]=='+'){\n            cur++;\n            R=form();\n            cur++;\n            return L||R;\n        }else if(str[cur]=='*'){\n            cur++;R=form();\n            cur++;\n            return L&&R;\n        }else{\n            cur+=2;R=form();\n            cur++;\n            return (!L)||(L&&R);\n        }\n    }\n    return 0;\n}\nint main(){\n    while(1){\n        scanf(\"%s\",str);\n        if(str[0]=='#')return 0;\n        int ok=1;\n        for(int i=0;i<(1<<11);i++){\n            cur=0;\n            for(int j=0;j<11;j++){\n                if(i&(1<<j))var[j]=1;\n                else var[j]=0;\n            }\n            int L=form();\n            cur++;\n            int R=form();\n            if(L!=R){ok=0;break;}\n        }\n        if(ok)printf(\"YES\\n\");\n        else printf(\"NO\\n\");\n    }\n}\n\n"
  },
  {
    "language": "C",
    "code": "int _a,_b,_c,_d,_e,_f,_g,_h,_i,_j,_k;\n\nint parse(char *p){\n  switch(*p){\n    case 'F': return 0;\n    case 'T': return 1;\n    case 'a': return _a;\n    case 'b': return _b;\n    case 'c': return _c;\n    case 'd': return _d;\n    case 'e': return _e;\n    case 'f': return _f;\n    case 'g': return _g;\n    case 'h': return _h;\n    case 'i': return _i;\n    case 'j': return _j;\n    case 'k': return _k;\n    case '-': return !parse(p+1);\n    case '(': {\n                int x=0;\n                p++;\n                char *q=p;\n                for(;;p++){\n                  if(*p=='(')x++;\n                  if(*p==')')x--;\n                  if(x==0&&*p!='-')break;\n                }\n                p++;\n                switch(*p){\n                  case '*': return parse(q)&parse(p+1);\n                  case '+': return parse(q)|parse(p+1);\n                  case '-': return !parse(q)|parse(p+2);\n                }\n              }\n  }\n}\n\nint main(){\n  char p[1001],*q;\n  while(1){\n    scanf(\"%s\",p);\n    if(*p=='#')return 0;\n\tq=strchr(p,'=')+1;\n    for(_a=0;_a<2;_a++)\n      for(_b=0;_b<2;_b++)\n        for(_c=0;_c<2;_c++)\n          for(_d=0;_d<2;_d++)\n            for(_e=0;_e<2;_e++)\n              for(_f=0;_f<2;_f++)\n                for(_g=0;_g<2;_g++)\n                  for(_h=0;_h<2;_h++)\n                    for(_i=0;_i<2;_i++)\n                      for(_j=0;_j<2;_j++)\n                        for(_k=0;_k<2;_k++)\n                          if(parse(p)!=parse(q))goto fail;\n    puts(\"YES\");continue;\n\tfail:puts(\"NO\");\n  }\n}"
  },
  {
    "language": "C",
    "code": "#include<stdio.h>\n#include<string.h>\nchar S[1005],R[1005],L[1005],ST[1500],tmp[1005],V[128];\nint sp,rp,np,LP,i;\nchar pop(){return ST[--sp];}\nvoid push(char c){ST[sp++]=c;}\nvoid NotPOP(){for(;ST[sp-1]=='-';tmp[rp++]=ST[--sp]);}\nvoid p(char *s)\n{\n\tmemset(tmp,0,sizeof(tmp));\n\tfor(np=sp=rp=0;s[np];np++)\n\t{\n\t\tchar t=s[np];\n\t\tif(t=='-'&&s[np+1]=='>'){push('>');np++;}\n\t\telse if(t=='*'||t=='+'||t=='-'||t=='(')push(t);\n\t\telse if((t=='T'||t=='F')||('a'<=t&&t<='k')){tmp[rp++]=s[np];NotPOP();}\n\t\telse{tmp[rp++]=pop();sp--;NotPOP();}\n\t}\n\tstrcpy(s,tmp);\n}\n\nchar c(char *s)\n{\n\tmemset(ST,0,sizeof(ST));\n\tfor(np=sp=rp=0;s[np];np++)\n\t{\n\t\tchar t=s[np];\n\t\tif(t=='T')push(1);\n\t\telse if(t=='F')push(0);\n\t\telse if('a'<=t&&t<='k')push((LP>>V[t])&1);\n\t\telse if(t=='*')push(pop()&pop());\n\t\telse if(t=='+')push(pop()|pop());\n\t\telse if(t=='-')push(!pop());\n\t\telse if(t=='>')\n\t\t{\n\t\t\tchar a=pop(),b=pop();\n\t\t\tpush(!b|a);\n\t\t}\n\t}\n\treturn ST[0];\n}\n\nint main()\n{\n\tfor(i=0;i<=11;i++)V[i+'a']=i;\n\tfor(;gets(S),S[0]!='#';)\n\t{\n\t\tsscanf(S,\"%[^=]=%s\",R,L);\n\t\tp(R);p(L);\n\t\tfor(LP=0;LP<1<<12;LP++)\n\t\t\tif(c(R)!=c(L))\n\t\t\t\tbreak;\n\t\tputs(LP==1<<12?\"YES\":\"NO\");\n\t}\n\treturn 0;\n}"
  },
  {
    "language": "C",
    "code": "int _a,_b,_c,_d,_e,_f,_g,_h,_i,_j,_k;\n\nint parse(char *p){\n  switch(*p){\n    case 'F': return 0;\n    case 'T': return 1;\n    case 'a': return _a;\n    case 'b': return _b;\n    case 'c': return _c;\n    case 'd': return _d;\n    case 'e': return _e;\n    case 'f': return _f;\n    case 'g': return _g;\n    case 'h': return _h;\n    case 'i': return _i;\n    case 'j': return _j;\n    case 'k': return _k;\n    case '-': return !parse(p+1);\n    case '(': {\n                int x=0;\n                p++;\n                char *q=p;\n                for(;;p++){\n                  if(*p=='(')x++;\n                  if(*p==')')x--;\n                  if(x==0&&(*p!='-'||p[1]=='>'))break;\n                }\n                p++;\n                switch(*p){\n                  case '*': return parse(q)&parse(p+1);\n                  case '+': return parse(q)|parse(p+1);\n                  case '-': return !parse(q)|parse(p+2);\n                }\n              }\n  }\n}\n\nint main(){\n  char p[81],*q;\n  while(1){\n    scanf(\"%s\",p);\n    if(*p=='#')return 0;\n\tq=strchr(p,'=')+1;\n    for(_a=0;_a<2;_a++)\n      for(_b=0;_b<2;_b++)\n        for(_c=0;_c<2;_c++)\n          for(_d=0;_d<2;_d++)\n            for(_e=0;_e<2;_e++)\n              for(_f=0;_f<2;_f++)\n                for(_g=0;_g<2;_g++)\n                  for(_h=0;_h<2;_h++)\n                    for(_i=0;_i<2;_i++)\n                      for(_j=0;_j<2;_j++)\n                        for(_k=0;_k<2;_k++)\n                          if(parse(p)!=parse(q))goto fail;\n    puts(\"YES\");continue;\n\tfail:puts(\"NO\");\n  }\n}"
  },
  {
    "language": "C",
    "code": "/*\nAizuOnline A2401\nTitle Equation\n*/\n#include <stdio.h>\n// Select Below\n//#include <stdlib.h>\n#include <string.h>\n//#include <float.h>\n//#include <math.h>\n//#include <limits.h>\n//Global data section\n#define MAXLEN 101\n#define NVARS 10\nchar expr[MAXLEN];\n\n//\nvoid strreplace(char * s,int len,char from,char to)\n{\n  int i;\n  for(i=0;i<len;i++)\n    if(s[i]==from)\n      s[i]=to;\n}\nchar * find_binary_operator2(char * s,int len,char op1,char op2)\n{\n  int i,d;\n  char *p;\n  \n  d=0;\n  for(i=len-1;i>=0;i--)\n    { \n      if(s[i]==')')\n\td++;\n      else if (s[i]=='(')\n\td--;\n      else\n\t{\n\t  if((op1==s[i]) && (op2==s[i+1]) && d==0)\n\t    return(&s[i]);\n\t}\n    }\n  return(NULL);\n}\n\nchar * find_binary_operator(char * s,int len,char op)\n{\n  int i,d;\n  char *p;\n  \n  d=0;\n  for(i=len-1;i>=0;i--)\n    { \n      if(s[i]==')')\n\td++;\n      else if (s[i]=='(')\n\td--;\n      else\n\t{\n\t  if((op==s[i]) && d==0)\n\t    return(&s[i]);\n\t}\n    }\n  return(NULL);\n}\nint logical_equal(int e1,int e2)\n{\n#ifdef DEBUG\n  printf(\"EQ:%d %d\\n\",e1,e2);\n#endif\n  return((e1==e2)?1:0);\n}\nint logical_and(int e1,int e2)\n{\n  return((e1 && e2)?1:0);\n}\nint logical_or(int e1,int e2)\n{\n  return((e1 || e2)?1:0);\n}\nint logical_naraba(int e1,int e2)\n{\n  return((e1<=e2)?1:0);\n}\nint logical_cpl(int e1)\n{\n  return((!e1)?1:0);\n}\nint logical_eval(char * exp,int len)\n{\n  char * r;\n  \n  if(len==1)\n    {\n      if(exp[0]=='T')\n\treturn(1);\n      else\n\treturn(0);\n    }\n  if(r=find_binary_operator(exp,len,'='))\n    {\n      return(logical_equal(logical_eval(exp,r-exp),\n\t\t\t   logical_eval(r+1,len-(r-exp+1))));\n    }\n  if(r=find_binary_operator(exp,len,'*'))\n    {\n      return(logical_and(logical_eval(exp,r-exp),\n\t\t\t   logical_eval(r+1,len-(r-exp+1))));\n    }\n  if(r=find_binary_operator(exp,len,'+'))\n    {\n      return(logical_or(logical_eval(exp,r-exp),\n\t\t\t   logical_eval(r+1,len-(r-exp+1))));\n    }\n  if(r=find_binary_operator2(exp,len,'-','>'))\n    {\n      return(logical_naraba(logical_eval(exp,r-exp),\n\t\t\t   logical_eval(r+2,len-(r-exp+2))));\n    }\n  if(exp[0]=='-')\n     return(logical_cpl(logical_eval(exp+1,len-1)));\n  else   if(exp[0]=='(' && exp[len-1]==')')\n    return(logical_eval(exp+1,len-2));\n  return(0);\n}\nint check_log_equation(char * exp,int len)\n{\n  int i,j;\n  char wk[MAXLEN];\n  memset(wk,0,MAXLEN);\n\n    for(i=0;i<1024;i++)   // 2^NVARS\n    {\n      memcpy(wk,exp,len);\n      for(j=0;j<10;j++)\n\t  {\n\t    strreplace(wk,len,'a'+j,(i & (1<<j)?'T':'F'));\n\t  }\n#ifdef DEBUG\n      printf(\"%*s\\n\",len+1,wk);\n#endif\n      \n      if(!logical_eval(wk,len))\n\treturn(0);\n    }\n    return(1);\n\n}\nmain()\n{\n  char *p;\n  int ret;\n\n  while(EOF!=scanf(\"%s\",expr))\n    {\n      ret=check_log_equation(expr,strlen(expr));\n\n      printf(\"%s\\n\",ret?\"YES\":\"NO\");\n    }\n  return(0);\n}"
  },
  {
    "language": "C",
    "code": "int _a,_b,_c,_d,_e,_f,_g,_h,_i,_j,_k;\n\nint parse(char *p){\n  switch(*p){\n    case 'F': return 0;\n    case 'T': return 1;\n    case 'a': return _a;\n    case 'b': return _b;\n    case 'c': return _c;\n    case 'd': return _d;\n    case 'e': return _e;\n    case 'f': return _f;\n    case 'g': return _g;\n    case 'h': return _h;\n    case 'i': return _i;\n    case 'j': return _j;\n    case 'k': return _k;\n    case '-': return !parse(p+1);\n    case '(': {\n                int x=0;\n                p++;\n                char *q=p;\n                for(;;p++){\n                  if(*p=='(')x++;\n                  if(*p==')')x--;\n                  if(x==0&&(*p!='-'||p[1]=='>'))break;\n                }\n                p++;\n                switch(*p){\n                  case '*': return parse(q)&parse(p+1);\n                  case '+': return parse(q)|parse(p+1);\n                  case '-': return !parse(q)|parse(p+2);\n                }\n              }\n  }\n}\n\nint main(){\n  char p[1001],*q;\n  while(1){\n    scanf(\"%s\",p);\n    if(*p=='#')return 0;\n\tq=strchr(p,'=')+1;\n    for(_a=0;_a<2;_a++)\n      for(_b=0;_b<2;_b++)\n        for(_c=0;_c<2;_c++)\n          for(_d=0;_d<2;_d++)\n            for(_e=0;_e<2;_e++)\n              for(_f=0;_f<2;_f++)\n                for(_g=0;_g<2;_g++)\n                  for(_h=0;_h<2;_h++)\n                    for(_i=0;_i<2;_i++)\n                      for(_j=0;_j<2;_j++)\n                        for(_k=0;_k<2;_k++)\n                          if(parse(p)!=parse(q))goto fail;\n    puts(\"YES\");continue;\n\tfail:puts(\"NO\");\n  }\n}"
  },
  {
    "language": "C",
    "code": "//2008dC\nI;int parse(char *p){switch(*p){\n\tcase 'F':return 0;\n\tcase 'T':return 1;\n\tcase '-':return !parse(p+1);\n\tcase '(':{\n\t\tint x=0;\n\t\tp++;\n\t\tchar *q=p;\n\t\tfor(;;p++){\n\t\t\tif(*p=='(')x++;\n\t\t\tif(*p==')')x--;\n\t\t\tif(x==0&&*p!='-')break;\n\t\t}\n\t\tp++;\n\t\tswitch(*p){\n\t\t\tcase '*':return parse(q)&parse(p+1);\n\t\t\tcase '+':return parse(q)|parse(p+1);\n\t\t\tcase '-':return !parse(q)|parse(p+2);\n\t\t}\n\t}\n}return (I>>(*p-97))&1;}\nchar p[1001],*q;main(){for(;scanf(\"%s\",p),*p-'#';puts(I==2048?\"YES\":\"NO\")){\nfor(q=strchr(p,'=')+1,I=0;I<2048;I++)if(parse(p)!=parse(q))break;\n}exit(0);}"
  },
  {
    "language": "C",
    "code": "#include <stdio.h>\n#include <string.h>\n\nenum {\n\tTYPE_CONST,\n\tTYPE_VALUE,\n\tTYPE_OPERATOR\n};\n\n#define OPERATOR_MUL\t0\n#define OPERATOR_ADD\t1\n#define OPERATOR_ARROW\t2\n#define OPERATOR_NOT\t3\n#define OPERATOR_KAKKO\t4\n\n/* l->r l*2+r */\nint result[3][4]={\n\t{0,0,0,1}, /* mul   */\n\t{0,1,1,1}, /* add   */\n\t{1,1,0,1}  /* arrow */\n};\n\ntypedef struct {\n\tint type;\n\tint value;\n} calc_t;\n\nint left_num;\ncalc_t calc_left[1000];\nint right_num;\ncalc_t calc_right[1000];\n\nint stack_num;\nint calc_stack[1000];\n\nvoid build_reverse_porland(const char* siki,calc_t* calc,int* num) {\n\tconst char* now;\n\t*num=0;\n\tstack_num=0;\n\tfor(now=siki;*now;now++) {\n\t\tswitch(*now) {\n\t\t\tcase 'T':\n\t\t\t\tcalc[*num].type=TYPE_CONST;\n\t\t\t\tcalc[*num].value=1;\n\t\t\t\t(*num)++;\n\t\t\t\tbreak;\n\t\t\tcase 'F':\n\t\t\t\tcalc[*num].type=TYPE_CONST;\n\t\t\t\tcalc[*num].value=0;\n\t\t\t\t(*num)++;\n\t\t\t\tbreak;\n\t\t\tcase 'a': case 'b': case 'c': case 'd': case 'e':\n\t\t\tcase 'f': case 'g': case 'h': case 'i': case 'j':\n\t\t\t\tcalc[*num].type=TYPE_VALUE;\n\t\t\t\tcalc[*num].value=(*now)-'a';\n\t\t\t\t(*num)++;\n\t\t\t\tbreak;\n\t\t\tcase '-':\n\t\t\t\tif(*(now+1)=='>') {\n\t\t\t\t\twhile(stack_num>0 &&\n\t\t\t\t\t\t\tcalc_stack[stack_num-1]!=OPERATOR_KAKKO) {\n\t\t\t\t\t\tcalc[*num].type=TYPE_OPERATOR;\n\t\t\t\t\t\tcalc[*num].value=calc_stack[--stack_num];\n\t\t\t\t\t\t(*num)++;\n\t\t\t\t\t}\n\t\t\t\t\tcalc_stack[stack_num++]=OPERATOR_ARROW;\n\t\t\t\t\tnow++;\n\t\t\t\t} else {\n\t\t\t\t\tcalc_stack[stack_num++]=OPERATOR_NOT;\n\t\t\t\t}\n\t\t\t\tbreak;\n\t\t\tcase '*':\n\t\t\t\twhile(stack_num>0 &&\n\t\t\t\t\t\tcalc_stack[stack_num-1]!=OPERATOR_KAKKO) {\n\t\t\t\t\tcalc[*num].type=TYPE_OPERATOR;\n\t\t\t\t\tcalc[*num].value=calc_stack[--stack_num];\n\t\t\t\t\t(*num)++;\n\t\t\t\t}\n\t\t\t\tcalc_stack[stack_num++]=OPERATOR_MUL;\n\t\t\t\tbreak;\n\t\t\tcase '+':\n\t\t\t\twhile(stack_num>0 &&\n\t\t\t\t\t\tcalc_stack[stack_num-1]!=OPERATOR_KAKKO) {\n\t\t\t\t\tcalc[*num].type=TYPE_OPERATOR;\n\t\t\t\t\tcalc[*num].value=calc_stack[--stack_num];\n\t\t\t\t\t(*num)++;\n\t\t\t\t}\n\t\t\t\tcalc_stack[stack_num++]=OPERATOR_ADD;\n\t\t\t\tbreak;\n\t\t\tcase '(':\n\t\t\t\tcalc_stack[stack_num++]=OPERATOR_KAKKO;\n\t\t\t\tbreak;\n\t\t\tcase ')':\n\t\t\t\twhile(stack_num>0 &&\n\t\t\t\t\t\tcalc_stack[stack_num-1]!=OPERATOR_KAKKO) {\n\t\t\t\t\tcalc[*num].type=TYPE_OPERATOR;\n\t\t\t\t\tcalc[*num].value=calc_stack[--stack_num];\n\t\t\t\t\t(*num)++;\n\t\t\t\t}\n\t\t\t\tif(stack_num>0)stack_num--;\n\t\t\t\tbreak;\n\t\t}\n\t}\n\twhile(stack_num>0) {\n\t\tcalc[*num].type=TYPE_OPERATOR;\n\t\tcalc[*num].value=calc_stack[--stack_num];\n\t\t(*num)++;\n\t}\n}\n\nint calc_reverse_porland(const calc_t* siki,int num,int value) {\n\tint i;\n\tstack_num=0;\n\tfor(i=0;i<num;i++) {\n\t\tswitch(siki[i].type) {\n\t\t\tcase TYPE_CONST:\n\t\t\t\tcalc_stack[stack_num++]=siki[i].value;\n\t\t\t\tbreak;\n\t\t\tcase TYPE_VALUE:\n\t\t\t\tcalc_stack[stack_num++]=(value>>siki[i].value)&1;\n\t\t\t\tbreak;\n\t\t\tcase TYPE_OPERATOR:\n\t\t\t\tif(siki[i].value==OPERATOR_NOT) {\n\t\t\t\t\tif(stack_num<1)return 2;\n\t\t\t\t\tcalc_stack[stack_num-1]=(calc_stack[stack_num-1]?0:1);\n\t\t\t\t} else {\n\t\t\t\t\tif(stack_num<2)return -1;\n\t\t\t\t\tcalc_stack[stack_num-2]=result[siki[i].value]\n\t\t\t\t\t\t[calc_stack[stack_num-2]*2+calc_stack[stack_num-1]];\n\t\t\t\t\tstack_num--;\n\t\t\t\t}\n\t\t\t\tbreak;\n\t\t}\n\t}\n\tif(stack_num!=1)return -1;\n\treturn calc_stack[0];\n}\n\nint main(void) {\n\tchar input[1004];\n\tchar* second;\n\tint i;\n\tint a,b;\n\tint ok;\n\twhile(1) {\n\t\tscanf(\"%s\",input);\n\t\tif(strcmp(input,\"#\")==0)break;\n\t\tsecond=strchr(input,'=');\n\t\tif(second==NULL)return 1;\n\t\t*second=0;\n\t\tsecond++;\n\t\tbuild_reverse_porland(input,calc_left,&left_num);\n\t\tbuild_reverse_porland(second,calc_right,&right_num);\n\t\tok=1;\n\t\tfor(i=0;i<1024;i++) {\n\t\t\ta=calc_reverse_porland(calc_left,left_num,i);\n\t\t\tb=calc_reverse_porland(calc_right,right_num,i);\n\t\t\tif(a<0 || b<0)return 2;\n\t\t\tif(a!=b){ok=0;break;}\n\t\t}\n\t\tputs(ok?\"YES\":\"NO\");\n\t}\n\treturn 0;\n}"
  },
  {
    "language": "C",
    "code": "#include <stdio.h>\n#include <string.h>\n\nenum {\n\tTYPE_CONST,\n\tTYPE_VALUE,\n\tTYPE_OPERATOR\n};\n\n#define OPERATOR_MUL\t0\n#define OPERATOR_ADD\t1\n#define OPERATOR_ARROW\t2\n#define OPERATOR_NOT\t3\n#define OPERATOR_KAKKO\t4\n\n/* l->r l*2+r */\nint result[3][4]={\n\t{0,0,0,1}, /* mul   */\n\t{0,1,1,1}, /* add   */\n\t{1,1,0,1}  /* arrow */\n};\n\ntypedef struct {\n\tint type;\n\tint value;\n} calc_t;\n\nint left_num;\ncalc_t calc_left[1000];\nint right_num;\ncalc_t calc_right[1000];\n\nint stack_num;\nint calc_stack[1000];\n\nvoid build_reverse_porland(const char* siki,calc_t* calc,int* num) {\n\tconst char* now;\n\t*num=0;\n\tstack_num=0;\n\tfor(now=siki;*now;now++) {\n\t\tswitch(*now) {\n\t\t\tcase 'T':\n\t\t\t\tcalc[*num].type=TYPE_CONST;\n\t\t\t\tcalc[*num].value=1;\n\t\t\t\t(*num)++;\n\t\t\t\tbreak;\n\t\t\tcase 'F':\n\t\t\t\tcalc[*num].type=TYPE_CONST;\n\t\t\t\tcalc[*num].value=0;\n\t\t\t\t(*num)++;\n\t\t\t\tbreak;\n\t\t\tcase 'a': case 'b': case 'c': case 'd': case 'e':\n\t\t\tcase 'f': case 'g': case 'h': case 'i': case 'j':\n\t\t\t\tcalc[*num].type=TYPE_VALUE;\n\t\t\t\tcalc[*num].value=(*now)-'a';\n\t\t\t\t(*num)++;\n\t\t\t\tbreak;\n\t\t\tcase '-':\n\t\t\t\tif(*(now+1)=='>') {\n\t\t\t\t\twhile(stack_num>0 &&\n\t\t\t\t\t\t\tcalc_stack[stack_num-1]!=OPERATOR_KAKKO) {\n\t\t\t\t\t\tcalc[*num].type=TYPE_OPERATOR;\n\t\t\t\t\t\tcalc[*num].value=calc_stack[--stack_num];\n\t\t\t\t\t\t(*num)++;\n\t\t\t\t\t}\n\t\t\t\t\tcalc_stack[stack_num++]=OPERATOR_ARROW;\n\t\t\t\t\tnow++;\n\t\t\t\t} else {\n\t\t\t\t\tcalc_stack[stack_num++]=OPERATOR_NOT;\n\t\t\t\t}\n\t\t\t\tbreak;\n\t\t\tcase '*':\n\t\t\t\twhile(stack_num>0 &&\n\t\t\t\t\t\tcalc_stack[stack_num-1]!=OPERATOR_KAKKO) {\n\t\t\t\t\tcalc[*num].type=TYPE_OPERATOR;\n\t\t\t\t\tcalc[*num].value=calc_stack[--stack_num];\n\t\t\t\t\t(*num)++;\n\t\t\t\t}\n\t\t\t\tcalc_stack[stack_num++]=OPERATOR_MUL;\n\t\t\t\tbreak;\n\t\t\tcase '+':\n\t\t\t\twhile(stack_num>0 &&\n\t\t\t\t\t\tcalc_stack[stack_num-1]!=OPERATOR_KAKKO) {\n\t\t\t\t\tcalc[*num].type=TYPE_OPERATOR;\n\t\t\t\t\tcalc[*num].value=calc_stack[--stack_num];\n\t\t\t\t\t(*num)++;\n\t\t\t\t}\n\t\t\t\tcalc_stack[stack_num++]=OPERATOR_ADD;\n\t\t\t\tbreak;\n\t\t\tcase '(':\n\t\t\t\tcalc_stack[stack_num++]=OPERATOR_KAKKO;\n\t\t\t\tbreak;\n\t\t\tcase ')':\n\t\t\t\twhile(stack_num>0 &&\n\t\t\t\t\t\tcalc_stack[stack_num-1]!=OPERATOR_KAKKO) {\n\t\t\t\t\tcalc[*num].type=TYPE_OPERATOR;\n\t\t\t\t\tcalc[*num].value=calc_stack[--stack_num];\n\t\t\t\t\t(*num)++;\n\t\t\t\t}\n\t\t\t\tif(stack_num>0)stack_num--;\n\t\t\t\tbreak;\n\t\t}\n\t}\n\twhile(stack_num>0) {\n\t\tcalc[*num].type=TYPE_OPERATOR;\n\t\tcalc[*num].value=calc_stack[--stack_num];\n\t\t(*num)++;\n\t}\n}\n\nint calc_reverse_porland(const calc_t* siki,int num,int value) {\n\tint i;\n\tstack_num=0;\n\tfor(i=0;i<num;i++) {\n\t\tswitch(siki[i].type) {\n\t\t\tcase TYPE_CONST:\n\t\t\t\tcalc_stack[stack_num++]=siki[i].value;\n\t\t\t\tbreak;\n\t\t\tcase TYPE_VALUE:\n\t\t\t\tcalc_stack[stack_num++]=(value>>siki[i].value)&1;\n\t\t\t\tbreak;\n\t\t\tcase TYPE_OPERATOR:\n\t\t\t\tif(siki[i].value==OPERATOR_NOT) {\n\t\t\t\t\tif(stack_num<1)return -1;\n\t\t\t\t\tcalc_stack[stack_num-1]=(calc_stack[stack_num-1]?0:1);\n\t\t\t\t} else {\n\t\t\t\t\tif(stack_num<2)return -1;\n\t\t\t\t\tcalc_stack[stack_num-2]=result[siki[i].value]\n\t\t\t\t\t\t[calc_stack[stack_num-2]*2+calc_stack[stack_num-1]];\n\t\t\t\t\tstack_num--;\n\t\t\t\t}\n\t\t}\n\t}\n\tif(stack_num!=1)return -1;\n\treturn calc_stack[0];\n}\n\nint main(void) {\n\tchar input[1004];\n\tchar* second;\n\tint i;\n\tint a,b;\n\tint ok;\n\twhile(1) {\n\t\tscanf(\"%s\",input);\n\t\tif(strcmp(input,\"#\")==0)break;\n\t\tsecond=strchr(input,'=');\n\t\tif(second==NULL)return 1;\n\t\t*second=0;\n\t\tsecond++;\n\t\tbuild_reverse_porland(input,calc_left,&left_num);\n\t\tbuild_reverse_porland(second,calc_right,&right_num);\n\t\tok=1;\n\t\tfor(i=0;i<1024;i++) {\n\t\t\ta=calc_reverse_porland(calc_left,left_num,i);\n\t\t\tb=calc_reverse_porland(calc_right,right_num,i);\n\t\t\tif(a<0 || b<0)return 2;\n\t\t\tif(a!=b){ok=0;break;}\n\t\t}\n\t\tputs(ok?\"YES\":\"NO\");\n\t}\n\treturn 0;\n}"
  },
  {
    "language": "C",
    "code": "//2008dC\nI;int parse(char *p){switch(*p){\n\tcase'F':return 0;\n\tcase'T':return 1;\n\tcase'-':return !parse(p+1);\n\tcase'(':{\n\t\tint x=0;\n\t\tchar*q=++p;\n\t\tfor(;;p++){\n\t\t\tif(*p=='(')x++;\n\t\t\tif(*p==')')x--;\n\t\t\tif(x==0&&*p!='-')break;\n\t\t}\n\t\tswitch(*(++p)){\n\t\t\tcase'*':return parse(q)&parse(p+1);\n\t\t\tcase'+':return parse(q)|parse(p+1);\n\t\t\tcase'-':return !parse(q)|parse(p+2);\n\t\t}\n\t}\n}return(I>>(*p-97))&1;}\nchar p[1001],*q;main(){for(;scanf(\"%s\",p),*p-'#';puts(I==2048?\"YES\":\"NO\")){for(q=strchr(p,'=')+1,I=0;I<2048;I++)if(parse(p)!=parse(q))break;}exit(0);}"
  },
  {
    "language": "C",
    "code": "//2008dC\nI;int parse(char *p){\n  switch(*p){\n    case 'F': return 0;\n    case 'T': return 1;\n    case 'a': return (I>>0)&1;\n    case 'b': return (I>>1)&1;\n    case 'c': return (I>>2)&1;\n    case 'd': return (I>>3)&1;\n    case 'e': return (I>>4)&1;\n    case 'f': return (I>>5)&1;\n    case 'g': return (I>>6)&1;\n    case 'h': return (I>>7)&1;\n    case 'i': return (I>>8)&1;\n    case 'j': return (I>>9)&1;\n    case 'k': return (I>>10)&1;\n    case '-': return !parse(p+1);\n    case '(': {\n                int x=0;\n                p++;\n                char *q=p;\n                for(;;p++){\n                  if(*p=='(')x++;\n                  if(*p==')')x--;\n                  if(x==0&&*p!='-')break;\n                }\n                p++;\n                switch(*p){\n                  case '*': return parse(q)&parse(p+1);\n                  case '+': return parse(q)|parse(p+1);\n                  case '-': return !parse(q)|parse(p+2);\n                }\n              }\n  }\n}\n\nint main(){\n  char p[1001],*q;\n  while(1){\n    scanf(\"%s\",p);\n    if(*p=='#')return 0;\n\tq=strchr(p,'=')+1;\nfor(I=0;I<2048;I++)if(parse(p)!=parse(q))goto fail;\n    puts(\"YES\");continue;\n\tfail:puts(\"NO\");\n  }\n}"
  },
  {
    "language": "C",
    "code": "// Aizu 2401: Equation\n// 2017.9.27 bal4u@uu\n\n#include <stdio.h>\n#include <ctype.h>\n\ntypedef struct { int id, ord; char f; } T;\nT var[12]; int n;\n\nchar buf[1002], *exp[2], *p;\nchar val[2050]; int assign;\n\nint expr();\nint factor()\n{\n\tint x, id, f = 0;\n\n\twhile (*p == '-') p++, f = !f;\n\tif      (*p == 'T') p++, x = 1;\n\telse if (*p == 'F') p++, x = 0;\n\telse if (*p == '(') p++, x = expr(), p++;\n\telse {\t\t\t// a-k\n\t\tid = *p++ - 'a';\n\t\tx = (assign & (1 << var[id].ord)) != 0;\n\t}\n\tif (f) x = !x;\n\treturn x;\n}\n\nint expr()\n{\n\tint x, y, op;\n\t\n\tx = factor();\n\twhile (1) {\n\t\tif      (*p == '*') p++,  op = 0;\n\t\telse if (*p == '+') p++,  op = 1;\n\t\telse if (*p == '-') p+=2, op = 2;\n\t\telse break;\n\t\ty = factor();\n\t\tif      (op == 0) x &= y;\n\t\telse if (op == 1) x |= y;\n\t\telse { if (x && !y) x = 0; else x = 1; }\n\t}\n\treturn x;\n}\n\nint main()\n{\n\tint i, lim, x, f; int y;\n\n\twhile (scanf(\"%s\", buf) && *buf != '#') {\n\t\texp[0] = p = buf;\n\t\twhile (*p && *p != '=') p++;\n\t\tif (!*p) { puts(\"NO\"); continue; }\n\t\t*p++ = 0, exp[1] = p;\n\n\t\tfor (i = 0; i < 11; i++) var[i].id = i, var[i].f = 0;\n\t\tfor (i = 0; i < 2; i++) {\n\t\t\tfor (p = exp[i]; *p; p++) if (isalpha(*p)) var[*p - 'a'].f = 1;\n\t\t}\n\t\tfor (n = 0, i = 0; i < 11; i++) if (var[i].f) var[i].ord = n++;\n\n\t\tlim = 1 << n;\n\t\tfor (f = 0, assign = 0; assign < lim; assign++) {\n\t\t\tp = exp[0];\n\t\t\tx = expr();\n\t\t\tp = exp[1];\n\t\t\ty = expr();\n\t\t\tif (y != x) { f = 1; break; }\n\t\t}\n\t\tputs(f ? \"NO\" : \"YES\");\n\t}\n\treturn 0;\n}"
  },
  {
    "language": "C",
    "code": "#include<stdio.h>\n#include<string.h>\nchar S[1005],R[1005],L[1005],ST[1500],tmp[1005],V[128];\nint sp,rp,np,LP,i;\nchar pop(){return ST[--sp];}\nvoid push(char c){ST[sp++]=c;}\nvoid NotPOP(){for(;ST[sp-1]=='-';tmp[rp++]=ST[--sp]);}\nvoid p(char *s)\n{\n\tmemset(tmp,0,sizeof(tmp));\n\tfor(np=sp=rp=0;s[np];np++)\n\t{\n\t\tchar t=s[np];\n\t\tif(t=='-'&&s[np+1]=='>'){push('>');np++;}\n\t\telse if(t=='*'||t=='+'||t=='-'||t=='(')push(t);\n\t\telse if((t=='T'||t=='F')||('a'<=t&&t<='k')){tmp[rp++]=s[np];NotPOP();}\n\t\telse{tmp[rp++]=pop();sp--;NotPOP();}\n\t}\n\tstrcpy(s,tmp);\n}\n\nchar c(char *s)\n{\n\tfor(np=sp=rp=0;s[np];np++)\n\t{\n\t\tchar t=s[np];\n\t\tif(t=='T')push(1);\n\t\tif(t=='F')push(0);\n\t\tif('a'<=t&&t<='k')push(LP&(1<<V[t]));\n\t\tif(t=='*')push(pop()&&pop());\n\t\tif(t=='+')push(pop()||pop());\n\t\tif(t=='-')push(!pop());\n\t\tif(t=='>')\n\t\t{\n\t\t\tchar a=pop(),b=pop();\n\t\t\tpush((a&&b)||!a);\n\t\t}\n\t}\n\treturn ST[0];\n}\n\nint main()\n{\n\tfor(i=0;i<=11;i++)V[i+'a']=i;\n\tfor(;gets(S),S[0]!='#';)\n\t{\n\t\tsscanf(S,\"%[^=]=%s\",R,L);\n\t\tp(R);p(L);\n\t\tfor(i=0;i<1<<12;i++)\n\t\t\tif(c(R)!=c(L))\n\t\t\t\tbreak;\n\t\tputs(i==1<<12?\"YES\":\"NO\");\n\t}\n\treturn 0;\n}"
  },
  {
    "language": "C",
    "code": "/*\nAizuOnline A2401\nTitle Equation\n13/3/24 WA\n*/\n#include <stdio.h>\n// Select Below\n//#include <stdlib.h>\n#include <string.h>\n//#include <float.h>\n//#include <math.h>\n//#include <limits.h>\n//Global data section\n#define MAXLEN 1001\n#define NVARS 10\nchar expr[MAXLEN];\n\n//\nvoid strreplace(char * s,int len,char from,char to)\n{\n  int i;\n  for(i=0;i<len;i++)\n    if(s[i]==from)\n      s[i]=to;\n}\nchar * find_binary_operator2(char * s,int len,char op1,char op2)\n{\n  int i,d;\n  char *p;\n  \n  d=0;\n  for(i=len-1;i>=0;i--)\n    { \n      if(s[i]==')')\n\td++;\n      else if (s[i]=='(')\n\td--;\n      else\n\t{\n\t  if((op1==s[i]) && (op2==s[i+1]) && d==0)\n\t    return(&s[i]);\n\t}\n    }\n  return(NULL);\n}\n\nchar * find_binary_operator(char * s,int len,char op)\n{\n  int i,d;\n  char *p;\n  \n  d=0;\n  for(i=len-1;i>=0;i--)\n    { \n      if(s[i]==')')\n\td++;\n      else if (s[i]=='(')\n\td--;\n      else\n\t{\n\t  if((op==s[i]) && d==0)\n\t    return(&s[i]);\n\t}\n    }\n  return(NULL);\n}\nint logical_equal(int e1,int e2)\n{\n#ifdef DEBUG\n  printf(\"EQ:%d %d\\n\",e1,e2);\n#endif\n  return((e1==e2)?1:0);\n}\nint logical_and(int e1,int e2)\n{\n  return((e1 && e2)?1:0);\n}\nint logical_or(int e1,int e2)\n{\n  return((e1 || e2)?1:0);\n}\nint logical_naraba(int e1,int e2)\n{\n  return((e1<=e2)?1:0);\n}\nint logical_cpl(int e1)\n{\n  return((!e1)?1:0);\n}\nint logical_eval(char * exp,int len)\n{\n  char * r;\n  \n  if(len==1)\n    {\n      if(exp[0]=='T')\n\treturn(1);\n      else\n\treturn(0);\n    }\n  if(r=find_binary_operator(exp,len,'='))\n    {\n      return(logical_equal(logical_eval(exp,r-exp),\n\t\t\t   logical_eval(r+1,len-(r-exp+1))));\n    }\n  if(r=find_binary_operator(exp,len,'*'))\n    {\n      return(logical_and(logical_eval(exp,r-exp),\n\t\t\t   logical_eval(r+1,len-(r-exp+1))));\n    }\n  if(r=find_binary_operator(exp,len,'+'))\n    {\n      return(logical_or(logical_eval(exp,r-exp),\n\t\t\t   logical_eval(r+1,len-(r-exp+1))));\n    }\n  if(r=find_binary_operator2(exp,len,'-','>'))\n    {\n      return(logical_naraba(logical_eval(exp,r-exp),\n\t\t\t   logical_eval(r+2,len-(r-exp+2))));\n    }\n  if(exp[0]=='-')\n     return(logical_cpl(logical_eval(exp+1,len-1)));\n  else   if(exp[0]=='(' && exp[len-1]==')')\n    return(logical_eval(exp+1,len-2));\n  return(0);\n}\nint check_log_equation(char * exp,int len)\n{\n  int i,j;\n  char wk[MAXLEN];\n  memset(wk,0,MAXLEN);\n\n    for(i=0;i<1024;i++)   // 2^NVARS\n    {\n      memcpy(wk,exp,len);\n      for(j=0;j<10;j++)\n\t  {\n\t    strreplace(wk,len,'a'+j,(i & (1<<j)?'T':'F'));\n\t  }\n#ifdef DEBUG\n      printf(\"%*s\\n\",len+1,wk);\n#endif\n      \n      if(!logical_eval(wk,len))\n\treturn(0);\n    }\n    return(1);\n\n}\nmain()\n{\n  char *p;\n  int ret;\n\n  while(EOF!=scanf(\"%s\",expr) && s[0]!='#')\n    {\n      ret=check_log_equation(expr,strlen(expr));\n\n      printf(\"%s\\n\",ret?\"YES\":\"NO\");\n    }\n  return(0);\n}"
  },
  {
    "language": "C",
    "code": "/*\nAizuOnline A2401\nTitle Equation\n13/3/24 WA\n*/\n#include <stdio.h>\n// Select Below\n//#include <stdlib.h>\n#include <string.h>\n//#include <float.h>\n//#include <math.h>\n//#include <limits.h>\n//Global data section\n#define MAXLEN 1001\n#define NVARS 10\nchar expr[MAXLEN];\n\n//\nvoid strreplace(char * s,int len,char from,char to)\n{\n  int i;\n  for(i=0;i<len;i++)\n    if(s[i]==from)\n      s[i]=to;\n}\nchar * find_binary_operator2(char * s,int len,char op1,char op2)\n{\n  int i,d;\n  char *p;\n  \n  d=0;\n  for(i=len-1;i>=0;i--)\n    { \n      if(s[i]==')')\n\td++;\n      else if (s[i]=='(')\n\td--;\n      else\n\t{\n\t  if((op1==s[i]) && (op2==s[i+1]) && d==0)\n\t    return(&s[i]);\n\t}\n    }\n  return(NULL);\n}\n\nchar * find_binary_operator(char * s,int len,char op)\n{\n  int i,d;\n  char *p;\n  \n  d=0;\n  for(i=len-1;i>=0;i--)\n    { \n      if(s[i]==')')\n\td++;\n      else if (s[i]=='(')\n\td--;\n      else\n\t{\n\t  if((op==s[i]) && d==0)\n\t    return(&s[i]);\n\t}\n    }\n  return(NULL);\n}\nint logical_equal(int e1,int e2)\n{\n#ifdef DEBUG\n  printf(\"EQ:%d %d\\n\",e1,e2);\n#endif\n  return((e1==e2)?1:0);\n}\nint logical_and(int e1,int e2)\n{\n  return((e1 && e2)?1:0);\n}\nint logical_or(int e1,int e2)\n{\n  return((e1 || e2)?1:0);\n}\nint logical_naraba(int e1,int e2)\n{\n  return((e1<=e2)?1:0);\n}\nint logical_cpl(int e1)\n{\n  return((!e1)?1:0);\n}\nint logical_eval(char * exp,int len)\n{\n  char * r;\n  \n  if(len==1)\n    {\n      if(exp[0]=='T')\n\treturn(1);\n      else\n\treturn(0);\n    }\n  if(r=find_binary_operator(exp,len,'='))\n    {\n      return(logical_equal(logical_eval(exp,r-exp),\n\t\t\t   logical_eval(r+1,len-(r-exp+1))));\n    }\n  if(r=find_binary_operator(exp,len,'*'))\n    {\n      return(logical_and(logical_eval(exp,r-exp),\n\t\t\t   logical_eval(r+1,len-(r-exp+1))));\n    }\n  if(r=find_binary_operator(exp,len,'+'))\n    {\n      return(logical_or(logical_eval(exp,r-exp),\n\t\t\t   logical_eval(r+1,len-(r-exp+1))));\n    }\n  if(r=find_binary_operator2(exp,len,'-','>'))\n    {\n      return(logical_naraba(logical_eval(exp,r-exp),\n\t\t\t   logical_eval(r+2,len-(r-exp+2))));\n    }\n  if(exp[0]=='-')\n     return(logical_cpl(logical_eval(exp+1,len-1)));\n  else   if(exp[0]=='(' && exp[len-1]==')')\n    return(logical_eval(exp+1,len-2));\n  return(0);\n}\nint check_log_equation(char * exp,int len)\n{\n  int i,j;\n  char wk[MAXLEN];\n  memset(wk,0,MAXLEN);\n\n    for(i=0;i<1024;i++)   // 2^NVARS\n    {\n      memcpy(wk,exp,len);\n      for(j=0;j<10;j++)\n\t  {\n\t    strreplace(wk,len,'a'+j,(i & (1<<j)?'T':'F'));\n\t  }\n#ifdef DEBUG\n      printf(\"%*s\\n\",len+1,wk);\n#endif\n      \n      if(!logical_eval(wk,len))\n\treturn(0);\n    }\n    return(1);\n\n}\nmain()\n{\n  char *p;\n  int ret;\n\n  while(EOF!=scanf(\"%s\",expr) && expr[0]!='#')\n    {\n      ret=check_log_equation(expr,strlen(expr));\n\n      printf(\"%s\\n\",ret?\"YES\":\"NO\");\n    }\n  return(0);\n}"
  },
  {
    "language": "C",
    "code": "//2008dC\nI;int parse(char *p){switch(*p){\n\tcase 'F':return 0;\n\tcase 'T':return 1;\n\tcase '-':return !parse(p+1);\n\tcase '(':{\n\t\tint x=0;\n\t\tchar *q=++p;\n\t\tfor(;;p++){\n\t\t\tif(*p=='(')x++;\n\t\t\tif(*p==')')x--;\n\t\t\tif(x==0&&*p!='-')break;\n\t\t}\n\t\tswitch(*(++p)){\n\t\t\tcase '*':return parse(q)&parse(p+1);\n\t\t\tcase '+':return parse(q)|parse(p+1);\n\t\t\tcase '-':return !parse(q)|parse(p+2);\n\t\t}\n\t}\n}return (I>>(*p-97))&1;}\nchar p[1001],*q;main(){for(;scanf(\"%s\",p),*p-'#';puts(I==2048?\"YES\":\"NO\")){\nfor(q=strchr(p,'=')+1,I=0;I<2048;I++)if(parse(p)!=parse(q))break;\n}exit(0);}"
  },
  {
    "language": "C",
    "code": "//2008dC\nI;int parse(char *p){\n  switch(*p){\n    case 'F': return 0;\n    case 'T': return 1;\n    case '-': return !parse(p+1);\n    case '(': {\n                int x=0;\n                p++;\n                char *q=p;\n                for(;;p++){\n                  if(*p=='(')x++;\n                  if(*p==')')x--;\n                  if(x==0&&*p!='-')break;\n                }\n                p++;\n                switch(*p){\n                  case '*': return parse(q)&parse(p+1);\n                  case '+': return parse(q)|parse(p+1);\n                  case '-': return !parse(q)|parse(p+2);\n                }\n              }\n  }\n  return (I>>(*p-97))&1;\n}\n\nchar p[1001],*q;main(){for(;scanf(\"%s\",p),*p-'#';puts(I==2048?\"YES\":\"NO\")){\n\tq=strchr(p,'=')+1;\n\tfor(I=0;I<2048;I++)if(parse(p)!=parse(q))break;\n}exit(0);}"
  },
  {
    "language": "C",
    "code": "//2008dC\nI;int parse(char *p){switch(*p){\n\tcase'F':return 0;\n\tcase'T':return 1;\n\tcase'-':return!parse(p+1);\n\tcase'(':{\n\t\tint x=0;\n\t\tchar*q=++p;\n\t\tfor(;;p++){\n\t\t\tif(*p=='(')x++;\n\t\t\tif(*p==')')x--;\n\t\t\tif(x==0&&*p!='-')break;\n\t\t}\n\t\tswitch(*(++p)){\n\t\t\tcase'*':return parse(q)&parse(p+1);\n\t\t\tcase'+':return parse(q)|parse(p+1);\n\t\t\tcase'-':return!parse(q)|parse(p+2);\n\t\t}\n\t}\n}return(I>>(*p-97))&1;}\nchar p[1001],*q;main(){for(;scanf(\"%s\",p),*p-'#';puts(I==2048?\"YES\":\"NO\"))for(q=strchr(p,'=')+1,I=0;I<2048;I++)if(parse(p)!=parse(q))break;exit(0);}"
  },
  {
    "language": "C",
    "code": "#include <stdio.h>\n#include <string.h>\n\nenum {\n\tTYPE_CONST,\n\tTYPE_VALUE,\n\tTYPE_OPERATOR\n};\n\n#define OPERATOR_MUL\t0\n#define OPERATOR_ADD\t1\n#define OPERATOR_ARROW\t2\n#define OPERATOR_NOT\t3\n#define OPERATOR_KAKKO\t4\n\n/* l->r l*2+r */\nint result[3][4]={\n\t{0,0,0,1}, /* mul   */\n\t{0,1,1,1}, /* add   */\n\t{1,1,0,1}  /* arrow */\n};\n\ntypedef struct {\n\tint type;\n\tint value;\n} calc_t;\n\nint left_num;\ncalc_t calc_left[1000];\nint right_num;\ncalc_t calc_right[1000];\n\nint stack_num;\nint calc_stack[1000];\n\nint build_reverse_porland(const char* siki,calc_t* calc,int* num) {\n\tconst char* now;\n\t*num=0;\n\tstack_num=0;\n\tfor(now=siki;*now;now++) {\n\t\tswitch(*now) {\n\t\t\tcase 'T':\n\t\t\t\tcalc[*num].type=TYPE_CONST;\n\t\t\t\tcalc[*num].value=1;\n\t\t\t\t(*num)++;\n\t\t\t\tbreak;\n\t\t\tcase 'F':\n\t\t\t\tcalc[*num].type=TYPE_CONST;\n\t\t\t\tcalc[*num].value=0;\n\t\t\t\t(*num)++;\n\t\t\t\tbreak;\n\t\t\tcase 'a': case 'b': case 'c': case 'd': case 'e':\n\t\t\tcase 'f': case 'g': case 'h': case 'i': case 'j':\n\t\t\tcase 'k':\n\t\t\t\tcalc[*num].type=TYPE_VALUE;\n\t\t\t\tcalc[*num].value=(*now)-'a';\n\t\t\t\t(*num)++;\n\t\t\t\tbreak;\n\t\t\tcase '-':\n\t\t\t\tif(*(now+1)=='>') {\n\t\t\t\t\twhile(stack_num>0 &&\n\t\t\t\t\t\t\tcalc_stack[stack_num-1]!=OPERATOR_KAKKO) {\n\t\t\t\t\t\tcalc[*num].type=TYPE_OPERATOR;\n\t\t\t\t\t\tcalc[*num].value=calc_stack[--stack_num];\n\t\t\t\t\t\t(*num)++;\n\t\t\t\t\t}\n\t\t\t\t\tcalc_stack[stack_num++]=OPERATOR_ARROW;\n\t\t\t\t\tnow++;\n\t\t\t\t} else {\n\t\t\t\t\tcalc_stack[stack_num++]=OPERATOR_NOT;\n\t\t\t\t}\n\t\t\t\tbreak;\n\t\t\tcase '*':\n\t\t\t\twhile(stack_num>0 &&\n\t\t\t\t\t\tcalc_stack[stack_num-1]!=OPERATOR_KAKKO) {\n\t\t\t\t\tcalc[*num].type=TYPE_OPERATOR;\n\t\t\t\t\tcalc[*num].value=calc_stack[--stack_num];\n\t\t\t\t\t(*num)++;\n\t\t\t\t}\n\t\t\t\tcalc_stack[stack_num++]=OPERATOR_MUL;\n\t\t\t\tbreak;\n\t\t\tcase '+':\n\t\t\t\twhile(stack_num>0 &&\n\t\t\t\t\t\tcalc_stack[stack_num-1]!=OPERATOR_KAKKO) {\n\t\t\t\t\tcalc[*num].type=TYPE_OPERATOR;\n\t\t\t\t\tcalc[*num].value=calc_stack[--stack_num];\n\t\t\t\t\t(*num)++;\n\t\t\t\t}\n\t\t\t\tcalc_stack[stack_num++]=OPERATOR_ADD;\n\t\t\t\tbreak;\n\t\t\tcase '(':\n\t\t\t\tcalc_stack[stack_num++]=OPERATOR_KAKKO;\n\t\t\t\tbreak;\n\t\t\tcase ')':\n\t\t\t\twhile(stack_num>0 &&\n\t\t\t\t\t\tcalc_stack[stack_num-1]!=OPERATOR_KAKKO) {\n\t\t\t\t\tcalc[*num].type=TYPE_OPERATOR;\n\t\t\t\t\tcalc[*num].value=calc_stack[--stack_num];\n\t\t\t\t\t(*num)++;\n\t\t\t\t}\n\t\t\t\tif(stack_num>0)stack_num--;\n\t\t\t\tbreak;\n\t\t\tdefault:\n\t\t\t\treturn 0;\n\t\t}\n\t}\n\twhile(stack_num>0) {\n\t\tcalc[*num].type=TYPE_OPERATOR;\n\t\tcalc[*num].value=calc_stack[--stack_num];\n\t\t(*num)++;\n\t}\n\treturn 1;\n}\n\nint calc_reverse_porland(const calc_t* siki,int num,int value) {\n\tint i;\n\tstack_num=0;\n\tfor(i=0;i<num;i++) {\n\t\tswitch(siki[i].type) {\n\t\t\tcase TYPE_CONST:\n\t\t\t\tcalc_stack[stack_num++]=siki[i].value;\n\t\t\t\tbreak;\n\t\t\tcase TYPE_VALUE:\n\t\t\t\tcalc_stack[stack_num++]=(value>>siki[i].value)&1;\n\t\t\t\tbreak;\n\t\t\tcase TYPE_OPERATOR:\n\t\t\t\tif(siki[i].value==OPERATOR_NOT) {\n\t\t\t\t\tif(stack_num<1)return -1;\n\t\t\t\t\tcalc_stack[stack_num-1]=(calc_stack[stack_num-1]?0:1);\n\t\t\t\t} else {\n\t\t\t\t\tif(stack_num<2)return -1;\n\t\t\t\t\tcalc_stack[stack_num-2]=result[siki[i].value]\n\t\t\t\t\t\t[calc_stack[stack_num-2]*2+calc_stack[stack_num-1]];\n\t\t\t\t\tstack_num--;\n\t\t\t\t}\n\t\t\t\tbreak;\n\t\t\tdefault:\n\t\t\t\treturn -1;\n\t\t}\n\t}\n\tif(stack_num!=1)return -1;\n\treturn calc_stack[0];\n}\n\nint main(void) {\n\tchar input[1004];\n\tchar* second;\n\tint i;\n\tint a,b;\n\tint ok;\n\twhile(1) {\n\t\tscanf(\"%s\",input);\n\t\tif(strcmp(input,\"#\")==0)break;\n\t\tsecond=strchr(input,'=');\n\t\tif(second==NULL)return 1;\n\t\t*second=0;\n\t\tsecond++;\n\t\tif(!build_reverse_porland(input,calc_left,&left_num))return 2;\n\t\tif(!build_reverse_porland(second,calc_right,&right_num))return 3;\n\t\tok=1;\n\t\tfor(i=0;i<2048;i++) {\n\t\t\ta=calc_reverse_porland(calc_left,left_num,i);\n\t\t\tb=calc_reverse_porland(calc_right,right_num,i);\n\t\t\tif(a<0 || b<0)return 4;\n\t\t\tif(a!=b){ok=0;break;}\n\t\t}\n\t\tputs(ok?\"YES\":\"NO\");\n\t}\n\treturn 0;\n}"
  },
  {
    "language": "C",
    "code": "//2008dC\nI;int parse(char *p){\n  switch(*p){\n    case 'F': return 0;\n    case 'T': return 1;\n    case 'a': return (I>>0)&1;\n    case 'b': return (I>>1)&1;\n    case 'c': return (I>>2)&1;\n    case 'd': return (I>>3)&1;\n    case 'e': return (I>>4)&1;\n    case 'f': return (I>>5)&1;\n    case 'g': return (I>>6)&1;\n    case 'h': return (I>>7)&1;\n    case 'i': return (I>>8)&1;\n    case 'j': return (I>>9)&1;\n    case 'k': return (I>>10)&1;\n    case '-': return !parse(p+1);\n    case '(': {\n                int x=0;\n                p++;\n                char *q=p;\n                for(;;p++){\n                  if(*p=='(')x++;\n                  if(*p==')')x--;\n                  if(x==0&&*p!='-')break;\n                }\n                p++;\n                switch(*p){\n                  case '*': return parse(q)&parse(p+1);\n                  case '+': return parse(q)|parse(p+1);\n                  case '-': return !parse(q)|parse(p+2);\n                }\n              }\n  }\n}\n\nchar p[1001],*q;main(){for(;scanf(\"%s\",p),*p-'#';puts(I==2048?\"YES\":\"NO\")){\n\tq=strchr(p,'=')+1;\n\tfor(I=0;I<2048;I++)if(parse(p)!=parse(q))break;\n}exit(0);}"
  },
  {
    "language": "C",
    "code": "//2008dC\nI;int parse(char *p){\n  switch(*p){\n    case 'F': return 0;\n    case 'T': return 1;\n    case 'a': return (I>>0)&1;\n    case 'b': return (I>>1)&1;\n    case 'c': return (I>>2)&1;\n    case 'd': return (I>>3)&1;\n    case 'e': return (I>>4)&1;\n    case 'f': return (I>>5)&1;\n    case 'g': return (I>>6)&1;\n    case 'h': return (I>>7)&1;\n    case 'i': return (I>>8)&1;\n    case 'j': return (I>>9)&1;\n    case 'k': return (I>>10)&1;\n    case '-': return !parse(p+1);\n    case '(': {\n                int x=0;\n                p++;\n                char *q=p;\n                for(;;p++){\n                  if(*p=='(')x++;\n                  if(*p==')')x--;\n                  if(x==0&&*p!='-')break;\n                }\n                p++;\n                switch(*p){\n                  case '*': return parse(q)&parse(p+1);\n                  case '+': return parse(q)|parse(p+1);\n                  case '-': return !parse(q)|parse(p+2);\n                }\n              }\n  }\n}\n\nint main(){\n  char p[1001],*q;\n  while(1){\n    scanf(\"%s\",p);\n    if(*p=='#')return 0;\n\tq=strchr(p,'=')+1;\nfor(I=0;I<2048;I++)if(parse(p)!=parse(q))goto fail;\n    puts(\"YES\");continue;\n\tfail:puts(\"NO\");\n  }\n}"
  },
  {
    "language": "Java",
    "code": "\nimport java.util.Scanner;\n\npublic class Main {\n\tpublic static String input;\n\tpublic static int p;\n\tpublic static int len;\n\tpublic static boolean[] alpha = new boolean[11];\n\tpublic static void main(String[] args){\n\t\tdoIt();\n\t\t//test();\n\t}\n\t\n//\tpublic static void test(){\n//\t\tint a = 0;\n//\t\tSystem.out.println(Character.getNumericValue('a'));\n//\t\tSystem.out.println(Character.getNumericValue('b'));\n//\t}\n\t\n\n\tpublic static void doIt(){\n\t\tScanner sc = new Scanner(System.in);\n\t\tinput = sc.next();\n\t\twhile(input.equals(\"#\") == false){\n\t\t\tlen = input.length();\n\t\t\tp = 0;\n\t\t\tboolean left;\n\t\t\tboolean right;\n\t\t\tboolean bOK = true;\n\t\t\t//int c = 0;\n\t\t\tint bit = 0;\n\t\t\t\n\t\t\t//2^(11) - 1までやる\n\t\t\tfor(int i = 0; i < 0x800; i++){\n\t\t\t\t//c++;\n\t\t\t\tfor(int j = 0; j < 11; j++){\n\t\t\t\t\talpha[j] = bit2Bool(bit, j);\n\t\t\t\t}\n\t\t\t\tp = 0;\n\t\t\t\tleft = getNext();\n\t\t\t\tp++;\n\t\t\t\t//System.out.println(\"right\");\n\t\t\t\tright = getNext();\n\t\t\t\t\n\t\t\t\tif(left != right){\n\t\t\t\t\t//System.out.println(\"a = \" + alpha[alpha2Int('a')] + \", b = \" + alpha[alpha2Int('b')] + \", left = \" + left + \", right = \"  + right);;\n\t\t\t\t\t//System.out.println(\"bad\");\n\t\t\t\t\tbOK = false;\n\t\t\t\t}\n\t\t\t\tbit++;\n\t\t\t}\n\t\t\t//System.out.println(c);\n\t\t\t\n\t\t\tif(bOK){\n\t\t\t\tSystem.out.println(\"YES\");\n\t\t\t}\n\t\t\telse{\n\t\t\t\tSystem.out.println(\"NO\");\n\t\t\t}\n\t\t\tinput = sc.next();\n\t\t}\n\t}\n\t\n\t//bit目のビットが立っていればtrue\n\tpublic static boolean bit2Bool(int num, int bit){\n\t\tint tmp = num >> bit;\n\t\tif(tmp == 1){\n\t\t\treturn true;\n\t\t}\n\t\telse{\n\t\t\treturn false;\n\t\t}\n\t}\n\n\tpublic static boolean getNext(){\n\t\tboolean bRet = false;\n\t\tchar c = input.charAt(p);\n\t\t//System.out.println(\"getNext : p = \" + p + \", c = \" + c);\n\t\tswitch(c){\n\t\tcase 'T':\n\t\t\tp++;\n\t\t\tbRet = true;\n\t\t\tbreak;\n\t\tcase 'F':\n\t\t\tbRet = false;\n\t\t\tp++;\n\t\t\tbreak;\n\t\tcase 'a':\n\t\tcase 'b':\n\t\tcase 'c':\n\t\tcase 'd':\n\t\tcase 'e':\n\t\tcase 'f':\n\t\tcase 'g':\n\t\tcase 'h':\n\t\tcase 'i':\n\t\tcase 'j':\n\t\tcase 'k':\n\t\t\tbRet = alpha2Bool(c);\n\t\t\tp++;\n\t\t\tbreak;\n\t\tcase '(':\n\t\t\tp++;\n\t\t\tboolean left = getNext();\n\t\t\tboolean right;\n\t\t\tc = input.charAt(p);\n\t\t\tif(c == '*'){\n\t\t\t\tp++;\n\t\t\t\tright = getNext();\n\t\t\t\tbRet = left & right;\n\t\t\t}\n\t\t\telse if(c == '+'){\n\t\t\t\tp++;\n\t\t\t\tright = getNext();\n\t\t\t\tbRet = left | right;\n\t\t\t}\n\t\t\t//case c = ->\n\t\t\telse{\n\t\t\t\tp += 2;\n\t\t\t\tright = getNext();\n\t\t\t\tbRet = Imp(left , right);\n\t\t\t}\n\t\t\tp++;\n\t\t\tbreak;\n\n\t\tcase '-':\n\t\t\tp++;\n\t\t\tbRet = getNext();\n\t\t\tbRet = !bRet;\n\t\t\tbreak;\n\t\t}\n\n\t\treturn bRet;\n\t}\n\n\tpublic static boolean alpha2Bool(char ch){\n\t\tint num = Character.getNumericValue(ch) - Character.getNumericValue('a');\n\t\treturn alpha[num];\n\t}\n\n\tpublic static boolean Imp(boolean b1, boolean b2){\n\t\tif(b1 == true && b2 == false){\n\t\t\treturn false;\n\t\t}\n\t\telse{\n\t\t\treturn true;\n\t\t}\n\t}\n}"
  },
  {
    "language": "Java",
    "code": "\nimport java.util.Scanner;\n\npublic class Main {\n\tpublic static void main(String[] args) {\n\t\tMain p = new Main();\n\t}\n\n\tpublic Main() {\n\t\tScanner sc = new Scanner(System.in);\n\t\talphav = new boolean[11];\n\t\twhile(true){\n\t\t\tString s = sc.next();\n\t\t\tif(s.equals(\"#\"))\n\t\t\t\tbreak;\n\t\t\tsolve(s);\n\t\t}\n\t\t\n\t}\n\n\tpublic void solve(String s) {\n\t\tString[] fs = s.split(\"=\");\n\t\tboolean res = true;\n\t\tfor(int i=0;i<(1<<11);i++){\n\t\t\tfor(int j=0;j<alphav.length;j++)\n\t\t\t\talphav[j] = (i&(1<<j)) > 0;\n\t\t\t\t\n\t\t\tcur = 0;\n\t\t\tf = fs[0];\n\t\t\tboolean r0 = fomula();\n\t\t\tcur = 0;\n\t\t\tf = fs[1];\n\t\t\tboolean r1 = fomula();\n\t\t\tif(r0 != r1){\n\t\t\t\tres = false;\n\t\t\t\tbreak;\n\t\t\t}\n\t\t}\n\t\tSystem.out.println(res? \"YES\" : \"NO\");\n\t}\n\n\tboolean[] alphav;\n\tString f;\n\tint cur = 0;\n\tprivate boolean fomula() {\n\t\tboolean ret = false;\n\t\tchar nc = nextc();\n\t\t\n\t\tif('a' <= nc && nc <= 'k')\n\t\t\treturn alphav[nc-'a'];\n\t\t\n\t\tswitch(nc){\n\t\tcase 'T':\n\t\t\tret = true;\n\t\t\tbreak;\n\t\t\n\t\tcase 'F':\n\t\t\tret = false;\n\t\t\tbreak;\n\t\t\t\n\t\tcase '-':\n\t\t\tret = !fomula();\n\t\t\tbreak;\n\t\t\t\n\t\tcase '(':\n\t\t\tret = fomula();\n\t\t\tnc = nextc();\n\t\t\tswitch(nc){\n\t\t\tcase '*':\n\t\t\t\tret &= fomula();\n\t\t\t\tbreak;\n\t\t\tcase '+':\n\t\t\t\tret |= fomula();\n\t\t\t\tbreak;\n\t\t\tcase '-':\n\t\t\t\tnextc();\n\t\t\t\t// fomulaを評価する必要がある\n\t\t\t\t// 逆にしたらだめ・・・\n\t\t\t\tret = !(!fomula() && ret);\n\t\t\t\tbreak;\n\t\t\t\t\n\t\t\t}\n\t\t\tnextc();\n\t\t\tbreak;\n\t\t}\n\t\t\n\t\treturn ret;\n\t}\n\t\n\tprivate char nextc(){\n\t\tchar c = f.charAt(cur);\n\t\tcur++;\n\t\treturn c;\n\t}\n}"
  },
  {
    "language": "Java",
    "code": "\nimport java.util.Scanner;\n\npublic class Main {\n\tpublic static void main(String[] args) {\n\t\tMain p = new Main();\n\t}\n\n\tpublic Main() {\n\t\tScanner sc = new Scanner(System.in);\n\t\talphav = new boolean[11];\n\t\twhile(true){\n\t\t\tString s = sc.next();\n\t\t\tif(s.equals(\"#\"))\n\t\t\t\tbreak;\n\t\t\tsolve(s);\n\t\t}\n\t\t\n\t}\n\n\tpublic void solve(String s) {\n\t\tString[] fs = s.split(\"=\");\n\t\tboolean res = true;\n\t\tfor(int i=0;i<(1<<11);i++){\n\t\t\tfor(int j=0;j<alphav.length;j++)\n\t\t\t\talphav[j] = (i&(1<<j)) > 0; \n\t\t\tcur = 0;\n\t\t\tf = fs[0];\n\t\t\tboolean r0 = fomula();\n\t\t\tcur = 0;\n\t\t\tf = fs[1];\n\t\t\tboolean r1 = fomula();\n\t\t\tif(r0 != r1){\n\t\t\t\tres = false;\n\t\t\t\tbreak;\n\t\t\t}\n\t\t}\n\t\tSystem.out.println(res? \"YES\" : \"NO\");\n\t}\n\n\tboolean[] alphav;\n\tString f;\n\tint cur = 0;\n\tprivate boolean fomula() {\n\t\tboolean ret = false;\n\t\tchar nc = nextc();\n\t\t\n\t\tif('a' <= nc && nc <= 'k')\n\t\t\treturn alphav[nc-'a'];\n\t\t\n\t\tswitch(nc){\n\t\tcase 'T':\n\t\t\tret = true;\n\t\t\tbreak;\n\t\t\n\t\tcase 'F':\n\t\t\tret = false;\n\t\t\tbreak;\n\t\t\t\n\t\tcase '-':\n\t\t\tret = !fomula();\n\t\t\tbreak;\n\t\t\t\n\t\tcase '(':\n\t\t\tret = fomula();\n\t\t\tnc = nextc();\n\t\t\tswitch(nc){\n\t\t\tcase '*':\n\t\t\t\tret &= fomula();\n\t\t\t\tbreak;\n\t\t\tcase '+':\n\t\t\t\tret |= fomula();\n\t\t\t\tbreak;\n\t\t\tcase '-':\n\t\t\t\tnextc();\n\t\t\t\tret = !(ret && !fomula());\n\t\t\t\tbreak;\n\t\t\t}\n\t\t\tnextc();\n\t\t\tbreak;\n\t\t}\n\t\t\n\t\treturn ret;\n\t}\n\t\n\tprivate char nextc(){\n\t\tchar c = f.charAt(cur);\n\t\tcur++;\n\t\treturn c;\n\t}\n}"
  },
  {
    "language": "Java",
    "code": "\nimport java.util.*;\nimport static java.lang.Math.*;\nimport static java.util.Arrays.*;\n\npublic class Main {\n\n\tint INF = 1 << 28;\n\tboolean val[];\n\tString eq;\n\tint p;\n\tint MAX = 11;\n\n\tvoid run() {\n\t\tScanner sc = new Scanner(System.in);\n\t\tfor(;;) {\n\t\t\teq = sc.next();\n\t\t\tif( eq.equals(\"#\") )break;\n\t\t\tval = new boolean[MAX];\n\t\t\tboolean yn = true;\n\t\t\tfor(int i=0;i<(1<<MAX);i++) {\n\t\t\t\tp = 0;\n\t\t\t\tfor(int j=0;j<MAX;j++) val[j] = ((i>>j)&1) == 1;\n\t\t\t\tif( !equation() ) {\n\t\t\t\t\tyn = false;\n\t\t\t\t\tbreak;\n\t\t\t\t}\n\t\t\t}\n\t\t\tSystem.out.println( (yn? \"YES\": \"NO\") );\n\t\t\t\n\t\t}\n\t}\n\t\n\tboolean equation() {\n\t\tboolean l = formula();\n\t\tp++;\n\t\tboolean r = formula();\n\t\tdebug(l, r);\n\t\treturn !(l^r);\n\t}\n\t\n\tboolean formula() {\n\t\tswitch (eq.charAt(p)) {\n\t\tcase 'T': p++; return true;\n\t\tcase 'F': p++; return false;\n\t\tcase '(':\n\t\t\tp++;\n\t\t\tboolean l = formula();\n\t\t\tint tmp = p++;\n\t\t\tif( eq.charAt(p) == '>' ) { p++; tmp++;}\n\t\t\tboolean r = formula();\n\t\t\tp++;\n\t\t\tif( eq.charAt(tmp) == '*' ) return mlt(l, r);\n\t\t\telse if( eq.charAt(tmp) == '+' ) return add(l, r);\n\t\t\telse return inc(l, r);\n\t\tcase '-': p++; return inv(formula());\n\t\tdefault : p++; return val(eq.charAt(p-1));\n\t\t}\n\t}\n\t\n\tboolean val(char x) {\n\t\tdebug(x);\n\t\treturn val[x-'a'];\n\t}\n\t\n\tboolean inv(boolean x) {\n\t\treturn !x;\n\t}\n\t\n\tboolean add(boolean x, boolean y) {\n\t\treturn x|y;\n\t}\n\t\n\tboolean mlt(boolean x, boolean y) {\n\t\treturn x&y;\n\t}\n\t\n\tboolean inc(boolean x, boolean y) {\n\t\treturn inv( mlt( x, inv(y) ) );\n\t}\n\n\tpublic static void main(String[] args) {\n\t\tnew Main().run();\n\t}\n\n\tvoid debug(Object... os) {\n\t\t//System.err.println(Arrays.deepToString(os));\n\t}\n}"
  },
  {
    "language": "Java",
    "code": "import java.util.Scanner;\n\npublic class Main {\n public static void main(String[] args) {\n\tScanner in = new Scanner(System.in);\n\twhile (in.hasNext()) {\n\t String str = in.next().trim();\n\t if (str.equals(\"#\")) {\n\t\tbreak;\n\t }\n\t String[] lr = str.split(\"=\");\n\t Formula left = Formula.of(lr[0]);\n\t Formula right = Formula.of(lr[1]);\n\t int max = Integer.parseInt(\"11111111111\", 2);\n\t boolean isYes = true;\n\t for (int i = 0; i <= max && isYes; i++) {\n\t\tisYes = left.getAns(i) == right.getAns(i);\n\t }\n\t System.out.println(isYes ? \"YES\" : \"NO\");\n\t}\n }\n\n abstract static class Formula {\n\tabstract boolean getAns(int bools);\n\n\tpublic static Formula of(String string) {\n\t if (\"T\".equals(string)) { return Teisu.T; }\n\t if (\"F\".equals(string)) { return Teisu.F; }\n\t if (\"a\".equals(string)) { return Var.a; }\n\t if (\"b\".equals(string)) { return Var.b; }\n\t if (\"c\".equals(string)) { return Var.c; }\n\t if (\"d\".equals(string)) { return Var.d; }\n\t if (\"e\".equals(string)) { return Var.e; }\n\t if (\"f\".equals(string)) { return Var.f; }\n\t if (\"g\".equals(string)) { return Var.g; }\n\t if (\"h\".equals(string)) { return Var.h; }\n\t if (\"i\".equals(string)) { return Var.i; }\n\t if (string.startsWith(\"-\")) {\n\t\tNot n = new Not(of(string.substring(1)));\n\t\treturn n;\n\t }\n\t String f1 = null;\n\t String f2 = null;\n\t String op = null;\n\t StringBuilder sb = new StringBuilder();\n\t int kakko = 0;\n\t int posi = 1;\n\t while (posi < string.length() - 1) {\n\t\tchar c = string.charAt(posi++);\n\t\tif (c == '(') {\n\t\t kakko++;\n\t\t} else if (c == ')') {\n\t\t kakko--;\n\t\t}\n\t\tif (kakko == 0) {\n\t\t if (c == '+' || c == '*') {\n\t\t\top = (c == '+') ? \"+\" : \"*\";\n\t\t\tf1 = sb.toString();\n\t\t\tsb.setLength(0);\n\t\t } else if (c == '-' && string.charAt(posi) == '>') {\n\t\t\tposi++;\n\t\t\top = \"->\";\n\t\t\tf1 = sb.toString();\n\t\t\tsb.setLength(0);\n\t\t } else {\n\t\t\tsb.append(c);\n\t\t }\n\t\t} else {\n\t\t sb.append(c);\n\t\t}\n\t }\n\t f2 = sb.toString();\n\t return new Ope(of(f1), op, of(f2));\n\n\t}\n\n }\n\n static class Teisu extends Formula {\n\tfinal boolean      bool;\n\tstatic final Teisu T = new Teisu(true);\n\tstatic final Teisu F = new Teisu(false);\n\n\tTeisu(boolean bool) {\n\t this.bool = bool;\n\t}\n\n\t@Override\n\tboolean getAns(int bools) {\n\t return bool;\n\t}\n }\n\n static class Var extends Formula {\n\tstatic final Var a = new Var(1);\n\tstatic final Var b = new Var(2);\n\tstatic final Var c = new Var(4);\n\tstatic final Var d = new Var(8);\n\tstatic final Var e = new Var(16);\n\tstatic final Var f = new Var(32);\n\tstatic final Var g = new Var(64);\n\tstatic final Var h = new Var(128);\n\tstatic final Var i = new Var(256);\n\tfinal int        var;\n\n\tVar(int var) {\n\t this.var = var;\n\t}\n\n\t@Override\n\tboolean getAns(int bools) {\n\t return var == (var & bools);\n\t}\n }\n\n static class Not extends Formula {\n\tfinal Formula f;\n\n\tNot(Formula f) {\n\t this.f = f;\n\t}\n\n\t@Override\n\tboolean getAns(int bools) {\n\t return !f.getAns(bools);\n\t}\n }\n\n static class Ope extends Formula {\n\tfinal Formula f1;\n\tfinal Formula f2;\n\tfinal String  op;\n\n\tOpe(Formula f1, String op, Formula f2) {\n\t this.f1 = f1;\n\t this.f2 = f2;\n\t this.op = op;\n\t}\n\n\t@Override\n\tboolean getAns(int bools) {\n\t boolean result;\n\t if (\"*\".equals(op)) {\n\t\tresult = f1.getAns(bools) && f2.getAns(bools);\n\t } else if (\"+\".equals(op)) {\n\t\tresult = f1.getAns(bools) || f2.getAns(bools);\n\t } else {\n\t\tresult = f1.getAns(bools) == false || f2.getAns(bools) == true;\n\t }\n\t return result;\n\t}\n\n }\n}"
  },
  {
    "language": "Java",
    "code": "import java.util.ArrayList;\nimport java.util.Scanner;\n\npublic class Main {\n\tprivate static final String[] vars_check = { \"a\", \"b\", \"c\", \"d\", \"e\", \"f\", \"g\", \"h\", \"i\", \"j\", \"k\" };\n\n\tpublic static void main(String[] args) {\n\t\tScanner sc = new Scanner(System.in);\n\t\twhile (true) {\n\t\t\tString line = sc.next();\n\t\t\tif (line.equals(\"#\")) {\n\t\t\t\tsc.close();\n\t\t\t\tbreak;\n\t\t\t}\n\n\t\t\tArrayList<String> varsList = new ArrayList<String>();\n\t\t\tfor (int i = 0; i < vars_check.length; i++) {\n\t\t\t\tif (line.indexOf(vars_check[i]) != -1) {\n\t\t\t\t\tvarsList.add(vars_check[i]);\n\t\t\t\t}\n\t\t\t}\n\t\t\tString[] vars = varsList.toArray(new String[0]);\n\n\t\t\tboolean yes = true;\n\t\t\tfor (int bit = 0; bit < (1 << vars.length); bit++) {\n\t\t\t\tString check = line;\n\t\t\t\tfor (int j = 0; j < vars.length; j++) {\n\t\t\t\t\tString replace = \"F\";\n\t\t\t\t\tif ((bit & (1 << j)) != 0) {\n\t\t\t\t\t\treplace = \"T\";\n\t\t\t\t\t}\n\t\t\t\t\tcheck = check.replaceAll(vars[j], replace);\n\t\t\t\t}\n\t\t\t\tint length = check.length();\n\t\t\t\twhile (true) {\n\t\t\t\t\tcheck = check.replaceAll(\"\\\\-T\", \"F\");\n\t\t\t\t\tcheck = check.replaceAll(\"\\\\-F\", \"T\");\n\t\t\t\t\tcheck = check.replaceAll(\"\\\\(T\\\\*T\\\\)\", \"T\");\n\t\t\t\t\tcheck = check.replaceAll(\"\\\\(F\\\\*[TF]\\\\)\", \"F\");\n\t\t\t\t\tcheck = check.replaceAll(\"\\\\([TF]\\\\*F\\\\)\", \"F\");\n\t\t\t\t\tcheck = check.replaceAll(\"\\\\(F\\\\+F\\\\)\", \"F\");\n\t\t\t\t\tcheck = check.replaceAll(\"\\\\([TF]\\\\+T\\\\)\", \"T\");\n\t\t\t\t\tcheck = check.replaceAll(\"\\\\(T\\\\+[TF]\\\\)\", \"T\");\n\t\t\t\t\tcheck = check.replaceAll(\"\\\\(T\\\\-\\\\>F\\\\)\", \"F\");\n\t\t\t\t\tcheck = check.replaceAll(\"\\\\(T\\\\-\\\\>T\\\\)\", \"T\");\n\t\t\t\t\tcheck = check.replaceAll(\"\\\\(F\\\\-\\\\>[TF]\\\\)\", \"T\");\n\t\t\t\t\tif (check.length() == length) {\n\t\t\t\t\t\tbreak;\n\t\t\t\t\t}\n\t\t\t\t\tlength = check.length();\n\t\t\t\t}\n\t\t\t\tif (check.equals(\"F=T\") || check.equals(\"T=F\")) {\n\t\t\t\t\tSystem.out.println(\"NO\");\n\t\t\t\t\tyes = false;\n\t\t\t\t\tbreak;\n\t\t\t\t}\n\t\t\t}\n\t\t\tif (yes) {\n\t\t\t\tSystem.out.println(\"YES\");\n\t\t\t}\n\t\t}\n\n\t}\n}"
  },
  {
    "language": "Java",
    "code": "import java.util.Scanner;\n\npublic class Main {\n\n\tstatic Scanner sc = new Scanner(System.in);\n\tstatic int var;\n\tstatic char[] str;\n\tstatic int pos;\n\n\tpublic static void main(String[] arg) {\n\t\twhile (true) {\n\t\t\tstr = sc.next().toCharArray();\n\t\t\tif (str[0] == '#') break;\n\t\t\tpos = 0;\n\t\t\tFormula l = parse();\n\t\t\t++pos;\n\t\t\tFormula r = parse();\n\t\t\tboolean res = true;\n\t\t\tfor (int i = 0; i < (1 << 11); ++i) {\n\t\t\t\tif (l.eval() != r.eval()) {\n\t\t\t\t\tres = false;\n\t\t\t\t\tbreak;\n\t\t\t\t}\n\t\t\t}\n\t\t\tSystem.out.println(res ? \"YES\" : \"NO\");\n\t\t}\n\t}\n\n\tstatic Formula parse() {\n\t\tchar c = str[pos++];\n\t\tif (c == 'T') return new Constant(true);\n\t\tif (c == 'F') return new Constant(false);\n\t\tif ('a' <= c && c <= 'z') return new Var(c - 'a');\n\t\tif (c == '-') return new Not(parse());\n\t\tFormula l = parse();\n\t\tchar op = str[pos++];\n\t\tif (op == '*') {\n\t\t\tFormula r = parse();\n\t\t\t++pos;\n\t\t\treturn new And(l, r);\n\t\t} else if (op == '+') {\n\t\t\tFormula r = parse();\n\t\t\t++pos;\n\t\t\treturn new Or(l, r);\n\t\t} else {\n\t\t\t++pos;\n\t\t\tFormula r = parse();\n\t\t\t++pos;\n\t\t\treturn new Inc(l, r);\n\t\t}\n\t}\n\n\tstatic abstract class Formula {\n\t\tabstract boolean eval();\n\t}\n\n\tstatic class Constant extends Formula {\n\t\tboolean v;\n\n\t\tConstant(boolean v) {\n\t\t\tthis.v = v;\n\t\t}\n\n\t\tboolean eval() {\n\t\t\treturn this.v;\n\t\t}\n\t}\n\n\tstatic class Var extends Formula {\n\t\tint p;\n\n\t\tVar(int p) {\n\t\t\tthis.p = p;\n\t\t}\n\n\t\tboolean eval() {\n\t\t\treturn (var & (1 << p)) != 0;\n\t\t}\n\t}\n\n\tstatic class Not extends Formula {\n\t\tFormula f;\n\n\t\tNot(Formula f) {\n\t\t\tthis.f = f;\n\t\t}\n\n\t\tboolean eval() {\n\t\t\treturn !f.eval();\n\t\t}\n\t}\n\n\tstatic class And extends Formula {\n\t\tFormula left, right;\n\n\t\tAnd(Formula l, Formula r) {\n\t\t\tthis.left = l;\n\t\t\tthis.right = r;\n\t\t}\n\n\t\tboolean eval() {\n\t\t\treturn left.eval() && right.eval();\n\t\t}\n\t}\n\n\tstatic class Or extends Formula {\n\t\tFormula left, right;\n\n\t\tOr(Formula l, Formula r) {\n\t\t\tthis.left = l;\n\t\t\tthis.right = r;\n\t\t}\n\n\t\tboolean eval() {\n\t\t\treturn left.eval() || right.eval();\n\t\t}\n\t}\n\n\tstatic class Inc extends Formula {\n\t\tFormula left, right;\n\n\t\tInc(Formula l, Formula r) {\n\t\t\tthis.left = l;\n\t\t\tthis.right = r;\n\t\t}\n\n\t\tboolean eval() {\n\t\t\tboolean lv = left.eval();\n\t\t\tif (!lv) return true;\n\t\t\treturn right.eval();\n\t\t}\n\t}\n\n}"
  },
  {
    "language": "Java",
    "code": "import java.util.Scanner;\n\npublic class Main {\n\n\tabstract class P {\n\t\tabstract boolean getValue();\n\t}\n\n\tclass AND extends P {\n\t\tP left;\n\t\tP right;\n\n\t\tpublic AND(P l, P r) {\n\t\t\tleft = l;\n\t\t\tright = r;\n\t\t}\n\n\t\tboolean getValue() {\n\t\t\treturn left.getValue() && right.getValue();\n\t\t}\n\n\t\tpublic String toString(){\n\t\t\treturn \"(\"+left+\"∧\"+right+\")\";\n\t\t}\n\t}\n\n\tclass OR extends P {\n\t\tP left;\n\t\tP right;\n\n\t\tpublic OR(P l, P r) {\n\t\t\tleft = l;\n\t\t\tright = r;\n\t\t}\n\n\t\tboolean getValue() {\n\t\t\treturn left.getValue() || right.getValue();\n\t\t}\n\t\tpublic String toString(){\n\t\t\treturn \"(\"+left+\"∨\"+right+\")\";\n\t\t}\n\t}\n\n\tclass ARROW extends P {\n\t\tP left;\n\t\tP right;\n\n\t\tpublic ARROW(P l, P r) {\n\t\t\tleft = l;\n\t\t\tright = r;\n\t\t}\n\n\t\tboolean getValue() {\n\t\t\treturn !left.getValue() || right.getValue();\n\t\t}\n\t\tpublic String toString(){\n\t\t\treturn \"(\"+left+\"→\"+right+\")\";\n\t\t}\n\t}\n\n\tclass NOT extends P {\n\t\tP exp;\n\n\t\tpublic NOT(P e) {\n\t\t\tthis.exp = e;\n\t\t}\n\n\t\tboolean getValue() {\n\t\t\treturn !exp.getValue();\n\t\t}\n\t\tpublic String toString(){\n\t\t\treturn \"¬\"+exp;\n\t\t}\n\t}\n\n\tclass PARAM extends P {\n\t\tint hensuu;\n\n\t\tpublic PARAM(int val) {\n\t\t\thensuu = val;\n\t\t}\n\n\t\tboolean getValue() {\n\t\t\treturn bmap[hensuu];\n\t\t}\n\t\tpublic String toString(){\n\t\t\treturn hensuu+\"\";\n\t\t}\n\t}\n\n\tclass TF extends P {\n\t\tboolean b;\n\n\t\tpublic TF(boolean val) {\n\t\t\tb = val;\n\t\t}\n\n\t\tboolean getValue() {\n\t\t\treturn b;\n\t\t}\n\t\tpublic String toString(){\n\t\t\treturn b?\"T\":\"F\";\n\t\t}\n\t}\n\n\tclass EQUAL extends P {\n\t\tP l;\n\t\tP r;\n\n\t\tpublic EQUAL(P le, P ri) {\n\t\t\tl = le;\n\t\t\tr = ri;\n\t\t}\n\n\t\tboolean getValue() {\n\t\t\treturn l.getValue() == r.getValue();\n\t\t}\n\t\tpublic String toString(){\n\t\t\treturn l+\"=\"+r;\n\t\t}\n\t}\n\n\tboolean[] bmap;\n\n\tP l;\n\tboolean isleft;\n\n\tpublic EQUAL eq(String str) {\n\t\tint eq = str.indexOf(\"=\");\n\t\treturn new EQUAL(formula(str.substring(0, eq)), formula(str.substring(\n\t\t\t\teq + 1, str.length())));\n\t}\n\n\tpublic P formula(String str) {\n\t\tif (str.length() == 1) {\n\t\t\tchar c = str.charAt(0);\n\t\t\tif (c == 'T') {\n\t\t\t\treturn new TF(true);\n\t\t\t}\n\t\t\tif (c == 'F') {\n\t\t\t\treturn new TF(false);\n\t\t\t}\n\t\t\tif ('a' <= c && c <= 'k') {\n\t\t\t\treturn new PARAM(c - 'a');\n\t\t\t}\n\t\t}\n\t\t// 区切り点を捜索\n\t\tif (str.charAt(0) == '-') {\n\t\t\tP node = formula(str.substring(1));\n\t\t\treturn new NOT(node);\n\t\t}\n\t\tif (str.charAt(0) == '(') {\n\t\t\tint ca = 0;\n\t\t\tfor (int i = 1;; i++) {\n\t\t\t\tchar c = str.charAt(i);\n\t\t\t\tswitch (c) {\n\t\t\t\tcase '(':\n\t\t\t\t\tca++;\n\t\t\t\t\tbreak;\n\t\t\t\tcase ')':\n\t\t\t\t\tca--;\n\t\t\t\t\tbreak;\n\t\t\t\t}\n\t\t\t\tif (ca > 0) {\n\t\t\t\t\tcontinue;\n\t\t\t\t}\n\t\t\t\tswitch (c) {\n\t\t\t\tcase '+':\n\t\t\t\t\tP l1 = formula(str.substring(1, i));\n\t\t\t\t\tP r1 = formula(str.substring(i + 1, str.length() - 1));\n\t\t\t\t\treturn new OR(l1, r1);\n\t\t\t\tcase '*':\n\t\t\t\t\tP l2 = formula(str.substring(1, i));\n\t\t\t\t\tP r2 = formula(str.substring(i + 1, str.length() - 1));\n\t\t\t\t\treturn new AND(l2, r2);\n\t\t\t\tcase '-':\n\t\t\t\t\tif (str.charAt(i + 1) != '>') {\n\t\t\t\t\t\tbreak;\n\t\t\t\t\t}\n\t\t\t\t\tP l3 = formula(str.substring(1, i));\n\t\t\t\t\tP r3 = formula(str.substring(i + 2, str.length() - 1));\n\t\t\t\t\treturn new ARROW(l3, r3);\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t\treturn null;\n\t}\n\n\tpublic void run() throws Exception {\n\t\tScanner sc = new Scanner(System.in);\n\n\t\twhile (true) {\n\t\t\tString str = sc.next();\n\t\t\tif (str.equals(\"#\")) {\n\t\t\t\tbreak;\n\t\t\t}\n\t\t\tEQUAL eq = eq(str);\n\n\t\t\tboolean res = true;\n\t\t\tbmap = new boolean[11];\n\t\t\tfor (int p = 0; p < (1 << 11); p++) {\n\t\t\t\tfor (int i = 0; i < 11; i++) {\n\t\t\t\t\tbmap[i] = (p / (1 << i)) % 2 == 1;\n\t\t\t\t}\n\t\t\t\tif (!eq.getValue()) {\n\t\t\t\t\tres = false;\n\t\t\t\t\tbreak;\n\t\t\t\t}\n\t\t\t}\n\t\t\tpr(res ? \"YES\" : \"NO\");\n\t\t\t/*\n\t\t\t * if('#'==st.nextToken()){ break; }\n\t\t\t */\n\t\t\t// isleft=true;\n\t\t\t// st.pushBack();\n\t\t\tformula(str);\n\t\t}\n\t}\n\n\tpublic static void main(String[] _) throws Exception {\n\t\tnew Main().run();\n\t}\n\n\tpublic static void pr(Object o) {\n\t\tSystem.out.println(o);\n\t}\n}"
  },
  {
    "language": "Java",
    "code": "import java.util.Scanner;\nimport java.util.regex.Pattern;\n\npublic class Main {\n public static void main(String[] args) {\n\tScanner in = new Scanner(System.in);\n\twhile (in.hasNext()) {\n\t String str = in.next();\n\t if (!\"#\".equals(str)) {\n\t\tString[] lr = str.split(\"=\");\n\t\tFormula left = Formula.of(lr[0]);\n\t\tFormula right = Formula.of(lr[1]);\n\t\tint max = Integer.parseInt(\"11111111111\", 2);\n\t\tboolean isYes = true;\n\t\tfor (int i = 0; i <= max && isYes; i++) {\n\t\t isYes = left.getAns(i) == right.getAns(i);\n\t\t}\n\t\tSystem.out.println(isYes ? \"YES\" : \"NO\");\n\t\tstr = in.next();\n\t }\n\t}\n }\n}\n\nabstract class Formula {\n static final Pattern PATTERN =\n\t                              Pattern\n\t                                .compile(\"^\\\\((.+)\\\\)$\");\n\n abstract boolean getAns(int bools);\n\n public static Formula of(String string) {\n\tif (\"T\".equals(string)) { return Teisu.T; }\n\tif (\"F\".equals(string)) { return Teisu.F; }\n\tif (\"a\".equals(string)) { return Var.a; }\n\tif (\"b\".equals(string)) { return Var.b; }\n\tif (\"c\".equals(string)) { return Var.c; }\n\tif (\"d\".equals(string)) { return Var.d; }\n\tif (\"e\".equals(string)) { return Var.e; }\n\tif (\"f\".equals(string)) { return Var.f; }\n\tif (\"g\".equals(string)) { return Var.g; }\n\tif (\"h\".equals(string)) { return Var.h; }\n\tif (\"i\".equals(string)) { return Var.i; }\n\tif (string.startsWith(\"-\")) {\n\t Not n = new Not(of(string.substring(1)));\n\t return n;\n\t}\n\tString f1 = null;\n\tString f2 = null;\n\tString op = null;\n\tStringBuilder sb = new StringBuilder();\n\tint kakko = 0;\n\tint posi = 1;\n\twhile (posi < string.length() - 1) {\n\t char c = string.charAt(posi++);\n\t if (c == '(') {\n\t\tkakko++;\n\t } else if (c == ')') {\n\t\tkakko--;\n\t }\n\t if (kakko == 0) {\n\t\tif (c == '+' || c == '*') {\n\t\t op = (c == '+') ? \"+\" : \"*\";\n\t\t f1 = sb.toString();\n\t\t sb.setLength(0);\n\t\t} else if (c == '-' && string.charAt(posi) == '>') {\n\t\t posi++;\n\t\t op = \"->\";\n\t\t f1 = sb.toString();\n\t\t sb.setLength(0);\n\t\t} else {\n\t\t sb.append(c);\n\t\t}\n\t } else {\n\t\tsb.append(c);\n\t }\n\t}\n\tf2 = sb.toString();\n\treturn new Ope(of(f1), op, of(f2));\n\n }\n\n}\n\nclass Teisu extends Formula {\n final boolean      bool;\n static final Teisu T = new Teisu(true);\n static final Teisu F = new Teisu(false);\n\n Teisu(boolean bool) {\n\tthis.bool = bool;\n }\n\n @Override\n boolean getAns(int bools) {\n\treturn bool;\n }\n}\n\nclass Var extends Formula {\n static final Var a = new Var(1);\n static final Var b = new Var(2);\n static final Var c = new Var(4);\n static final Var d = new Var(8);\n static final Var e = new Var(16);\n static final Var f = new Var(32);\n static final Var g = new Var(64);\n static final Var h = new Var(128);\n static final Var i = new Var(256);\n final int        var;\n\n Var(int var) {\n\tthis.var = var;\n }\n\n @Override\n boolean getAns(int bools) {\n\treturn var == (var & bools);\n }\n}\n\nclass Not extends Formula {\n final Formula f;\n\n Not(Formula f) {\n\tthis.f = f;\n }\n\n @Override\n boolean getAns(int bools) {\n\treturn !f.getAns(bools);\n }\n}\n\nclass Ope extends Formula {\n final Formula f1;\n final Formula f2;\n final String  op;\n\n Ope(Formula f1, String op, Formula f2) {\n\tthis.f1 = f1;\n\tthis.f2 = f2;\n\tthis.op = op;\n }\n\n @Override\n boolean getAns(int bools) {\n\tboolean result;\n\tif (\"*\".equals(op)) {\n\t result = f1.getAns(bools) && f2.getAns(bools);\n\t} else if (\"+\".equals(op)) {\n\t result = f1.getAns(bools) || f2.getAns(bools);\n\t} else {\n\t result = f1.getAns(bools) == false || f2.getAns(bools) == true;\n\t}\n\treturn result;\n }\n\n}"
  },
  {
    "language": "Java",
    "code": "package vol24.no2401;\n\nimport java.util.Scanner;\nimport java.util.regex.Pattern;\n\npublic class Main {\n public static void main(String[] args) {\n\tScanner in = new Scanner(System.in);\n\twhile (in.hasNext()) {\n\t String str = in.next();\n\t if (!\"#\".equals(str)) {\n\t\tString[] lr = str.split(\"=\");\n\t\tFormula left = Formula.of(lr[0]);\n\t\tFormula right = Formula.of(lr[1]);\n\t\tint max = Integer.parseInt(\"11111111111\", 2);\n\t\tboolean isYes = true;\n\t\tfor (int i = 0; i <= max && isYes; i++) {\n\t\t isYes = left.getAns(i) == right.getAns(i);\n\t\t}\n\t\tSystem.out.println(isYes ? \"YES\" : \"NO\");\n\t\tstr = in.next();\n\t }\n\t}\n }\n\n abstract static class Formula {\n\tstatic final Pattern PATTERN =\n\t                               Pattern\n\t                                 .compile(\"^\\\\((.+)\\\\)$\");\n\n\tabstract boolean getAns(int bools);\n\n\tpublic static Formula of(String string) {\n\t if (\"T\".equals(string)) { return Teisu.T; }\n\t if (\"F\".equals(string)) { return Teisu.F; }\n\t if (\"a\".equals(string)) { return Var.a; }\n\t if (\"b\".equals(string)) { return Var.b; }\n\t if (\"c\".equals(string)) { return Var.c; }\n\t if (\"d\".equals(string)) { return Var.d; }\n\t if (\"e\".equals(string)) { return Var.e; }\n\t if (\"f\".equals(string)) { return Var.f; }\n\t if (\"g\".equals(string)) { return Var.g; }\n\t if (\"h\".equals(string)) { return Var.h; }\n\t if (\"i\".equals(string)) { return Var.i; }\n\t if (string.startsWith(\"-\")) {\n\t\tNot n = new Not(of(string.substring(1)));\n\t\treturn n;\n\t }\n\t String f1 = null;\n\t String f2 = null;\n\t String op = null;\n\t StringBuilder sb = new StringBuilder();\n\t int kakko = 0;\n\t int posi = 1;\n\t while (posi < string.length() - 1) {\n\t\tchar c = string.charAt(posi++);\n\t\tif (c == '(') {\n\t\t kakko++;\n\t\t} else if (c == ')') {\n\t\t kakko--;\n\t\t}\n\t\tif (kakko == 0) {\n\t\t if (c == '+' || c == '*') {\n\t\t\top = (c == '+') ? \"+\" : \"*\";\n\t\t\tf1 = sb.toString();\n\t\t\tsb.setLength(0);\n\t\t } else if (c == '-' && string.charAt(posi) == '>') {\n\t\t\tposi++;\n\t\t\top = \"->\";\n\t\t\tf1 = sb.toString();\n\t\t\tsb.setLength(0);\n\t\t } else {\n\t\t\tsb.append(c);\n\t\t }\n\t\t} else {\n\t\t sb.append(c);\n\t\t}\n\t }\n\t f2 = sb.toString();\n\t return new Ope(of(f1), op, of(f2));\n\n\t}\n\n }\n\nstatic class Teisu extends Formula {\n\tfinal boolean      bool;\n\tstatic final Teisu T = new Teisu(true);\n\tstatic final Teisu F = new Teisu(false);\n\n\tTeisu(boolean bool) {\n\t this.bool = bool;\n\t}\n\n\t@Override\n\tboolean getAns(int bools) {\n\t return bool;\n\t}\n }\n\nstatic class Var extends Formula {\n\tstatic final Var a = new Var(1);\n\tstatic final Var b = new Var(2);\n\tstatic final Var c = new Var(4);\n\tstatic final Var d = new Var(8);\n\tstatic final Var e = new Var(16);\n\tstatic final Var f = new Var(32);\n\tstatic final Var g = new Var(64);\n\tstatic final Var h = new Var(128);\n\tstatic final Var i = new Var(256);\n\tfinal int        var;\n\n\tVar(int var) {\n\t this.var = var;\n\t}\n\n\t@Override\n\tboolean getAns(int bools) {\n\t return var == (var & bools);\n\t}\n }\n\n class Not extends Formula {\n\tfinal Formula f;\n\n\tNot(Formula f) {\n\t this.f = f;\n\t}\n\n\t@Override\n\tboolean getAns(int bools) {\n\t return !f.getAns(bools);\n\t}\n }\n\n static class Ope extends Formula {\n\tfinal Formula f1;\n\tfinal Formula f2;\n\tfinal String  op;\n\n\tOpe(Formula f1, String op, Formula f2) {\n\t this.f1 = f1;\n\t this.f2 = f2;\n\t this.op = op;\n\t}\n\n\t@Override\n\tboolean getAns(int bools) {\n\t boolean result;\n\t if (\"*\".equals(op)) {\n\t\tresult = f1.getAns(bools) && f2.getAns(bools);\n\t } else if (\"+\".equals(op)) {\n\t\tresult = f1.getAns(bools) || f2.getAns(bools);\n\t } else {\n\t\tresult = f1.getAns(bools) == false || f2.getAns(bools) == true;\n\t }\n\t return result;\n\t}\n\n }\n}"
  },
  {
    "language": "Java",
    "code": "import java.io.IOException;\nimport java.util.InputMismatchException;\n\npublic class Main {\n\tString[] s;\n\tchar[] c;\n\tint id;\n\tboolean[] var;\n\tboolean ans;\n\n\tboolean exp() {\n\t\tboolean res;\n\n\t\tif (c[id] == '-') {\n\t\t\tid++;\n\t\t\tres = !exp();\n\t\t} else if (c[id] == '(') {\n\t\t\tid++;\n\t\t\tres = exp();\n\t\t\tif (c[id] == '*') {\n\t\t\t\tid++;\n\t\t\t\tres &= exp();\n\t\t\t} else if (c[id] == '+') {\n\t\t\t\tid++;\n\t\t\t\tres |= exp();\n\t\t\t} else {\n\t\t\t\tid++;\n\t\t\t\tid++;\n\t\t\t\tres = !res | exp();\n\t\t\t}\n\t\t\tid++;\n\t\t} else {\n\t\t\tres = var();\n\t\t}\n\n\t\treturn res;\n\t}\n\n\tboolean var() {\n\t\tif (c[id] == 'T') {\n\t\t\tid++;\n\t\t\treturn true;\n\t\t} else if (c[id] == 'F') {\n\t\t\tid++;\n\t\t\treturn false;\n\t\t} else {\n\t\t\tboolean res = var[c[id] - 'a'];\n\t\t\tid++;\n\t\t\treturn res;\n\t\t}\n\t}\n\n\tvoid bt(int k) {\n\t\tint n = var.length;\n\t\tif (n <= k) {\n\t\t\tc = s[0].toCharArray();\n\t\t\tid = 0;\n\t\t\tboolean f1 = exp();\n\n\t\t\tc = s[1].toCharArray();\n\t\t\tid = 0;\n\t\t\tboolean f2 = exp();\n\n\t\t\tans &= (f1 == f2);\n\t\t} else {\n\t\t\tvar[k] = true;\n\t\t\tbt(k + 1);\n\t\t\tvar[k] = false;\n\t\t\tbt(k + 1);\n\t\t}\n\t}\n\n\tvoid run() {\n\t\tMyScanner sc = new MyScanner();\n\n\t\twhile (true) {\n\t\t\tString in = sc.next();\n\t\t\tif (in.equals(\"#\")) {\n\t\t\t\tbreak;\n\t\t\t}\n\t\t\ts = in.split(\"=\");\n\t\t\tans = true;\n\n\t\t\tvar = new boolean['k' - 'a' + 1];\n\t\t\tbt(0);\n\n\t\t\tSystem.out.println(ans ? \"YES\" : \"NO\");\n\t\t}\n\t}\n\n\tpublic static void main(String[] args) {\n\t\tnew Main().run();\n\t}\n\n\tpublic void mapDebug(int[][] a) {\n\t\tSystem.out.println(\"--------map display---------\");\n\t\tfor (int i = 0; i < a.length; i++) {\n\t\t\tfor (int j = 0; j < a[i].length; j++) {\n\t\t\t\tSystem.out.printf(\"%3d \", a[i][j]);\n\t\t\t}\n\t\t\tSystem.out.println();\n\t\t}\n\t\tSystem.out.println(\"----------------------------\" + '\\n');\n\t}\n\n\tclass MyScanner {\n\t\tint read() {\n\t\t\ttry {\n\t\t\t\treturn System.in.read();\n\t\t\t} catch (IOException e) {\n\t\t\t\tthrow new InputMismatchException();\n\t\t\t}\n\t\t}\n\n\t\tboolean isSpaceChar(int c) {\n\t\t\treturn c == ' ' || c == '\\n' || c == '\\r' || c == '\\t' || c == -1;\n\t\t}\n\n\t\tboolean isEndline(int c) {\n\t\t\treturn c == '\\n' || c == '\\r' || c == -1;\n\t\t}\n\n\t\tint nextInt() {\n\t\t\treturn Integer.parseInt(next());\n\t\t}\n\n\t\tint[] nextIntArray(int n) {\n\t\t\tint[] array = new int[n];\n\t\t\tfor (int i = 0; i < n; i++)\n\t\t\t\tarray[i] = nextInt();\n\t\t\treturn array;\n\t\t}\n\n\t\tlong nextLong() {\n\t\t\treturn Long.parseLong(next());\n\t\t}\n\n\t\tlong[] nextLongArray(int n) {\n\t\t\tlong[] array = new long[n];\n\t\t\tfor (int i = 0; i < n; i++)\n\t\t\t\tarray[i] = nextLong();\n\t\t\treturn array;\n\t\t}\n\n\t\tdouble nextDouble() {\n\t\t\treturn Double.parseDouble(next());\n\t\t}\n\n\t\tdouble[] nextDoubleArray(int n) {\n\t\t\tdouble[] array = new double[n];\n\t\t\tfor (int i = 0; i < n; i++)\n\t\t\t\tarray[i] = nextDouble();\n\t\t\treturn array;\n\t\t}\n\n\t\tString next() {\n\t\t\tint c = read();\n\t\t\twhile (isSpaceChar(c))\n\t\t\t\tc = read();\n\t\t\tStringBuilder res = new StringBuilder();\n\t\t\tdo {\n\t\t\t\tres.appendCodePoint(c);\n\t\t\t\tc = read();\n\t\t\t} while (!isSpaceChar(c));\n\t\t\treturn res.toString();\n\t\t}\n\n\t\tString[] nextStringArray(int n) {\n\t\t\tString[] array = new String[n];\n\t\t\tfor (int i = 0; i < n; i++)\n\t\t\t\tarray[i] = next();\n\n\t\t\treturn array;\n\t\t}\n\n\t\tString nextLine() {\n\t\t\tint c = read();\n\t\t\twhile (isEndline(c))\n\t\t\t\tc = read();\n\t\t\tStringBuilder res = new StringBuilder();\n\t\t\tdo {\n\t\t\t\tres.appendCodePoint(c);\n\t\t\t\tc = read();\n\t\t\t} while (!isEndline(c));\n\t\t\treturn res.toString();\n\t\t}\n\t}\n}"
  },
  {
    "language": "Java",
    "code": "import java.util.Scanner;\n\npublic class Main {\n\n\tpublic static void main(String[] args) {\n\t\tScanner sc = new Scanner(System.in);\n\t\twhile(true) {\n\t\t\tString s = sc.next();\n\t\t\tif (s.equals(\"#\")) {\n\t\t\t\tbreak;\n\t\t\t}\n\t\t\tif (isEquation(s)) {\n\t\t\t\tSystem.out.println(\"YES\");\n\t\t\t}else{\n\t\t\t\tSystem.out.println(\"NO\");\n\t\t\t}\n\t\t}\n\t}\n\n\tpublic static boolean isEquation(String s) {\n\t\tfor(int i=0;i<(1<<10);i++) {\n\t\t\tString s2 = String.valueOf(s);\n\t\t\tfor(int j=0;j<10;j++) {\n\t\t\t\tif ((i&(1<<j))>0) {\n\t\t\t\t\ts2 = s2.replaceAll(String.valueOf((char) ('a'+j)), \"T\");\n\t\t\t\t}else{\n\t\t\t\t\ts2 = s2.replaceAll(String.valueOf((char) ('a'+j)), \"F\");\n\t\t\t\t}\n\t\t\t}\n\t\t\tString[] exp = s2.split(\"=\");\n\t\t\tif (evaluate(exp[0])!=evaluate(exp[1])) {\n\t\t\t\treturn false;\n\t\t\t}\n\t\t}\n\t\treturn true;\n\t}\n\n\tpublic static int index = 0;\n\tpublic static boolean evaluate(String s) {\n\t\tindex = 0;\n\t\tboolean ret = expression(s);\n\t\treturn ret;\n\t}\n\n\tpublic static boolean expression(String s) {\n\t\tchar c = s.charAt(index);\n\t\tif (c == 'T' || c == 'F') {\n\t\t\tindex++;\n\t\t\treturn c == 'T';\n\t\t}\n\t\tif (c == '-') {\n\t\t\tindex++;\n\t\t\treturn !expression(s);\n\t\t}\n\t\tif (c == '(') {\n\t\t\tindex++;\n\t\t\tboolean temp = term(s);\n\t\t\tindex++;\n\t\t\treturn temp;\n\t\t}\n\t\treturn false;\n\t}\n\n\tpublic static boolean term(String s) {\n\t\tboolean first = expression(s);\n\t\tchar c = s.charAt(index);\n\t\tindex += c == '-' ? 2 : 1;\n\t\tboolean second = expression(s);\n\t\tif (c == '*') {\n\t\t\treturn first && second;\n\t\t}else if(c == '+') {\n\t\t\treturn first || second;\n\t\t}else{\n\t\t\treturn !(first && !second);\n\t\t}\n\t}\n\n}"
  },
  {
    "language": "Java",
    "code": "import java.util.*;\nimport java.math.*;\nimport java.awt.geom.*;\nimport java.io.*;\n      \n      \npublic class Main {\n\tstatic int id;\n\tstatic String S;\n\tstatic int V;\n\tpublic static void main(String[] args) {\n\t\tScanner sc = new Scanner(System.in);\n\t\twhile(true) {\n\t\t\tS = sc.next();\n\t\t\tif(S.equals(\"#\")) break;\n\t\t\tboolean ans = true;\n\t\t\tfor(V = 0; V < (1 << 12); V++) {\n\t\t\t\tid = 0;\n\t\t\t\tans &= equation();\n\t\t\t\tif(!ans) break;\n\t\t\t}\n\t\t\tSystem.out.println(ans?\"YES\":\"NO\");\n\t\t}\n\t}\n\tstatic boolean equation() {\n\t\tboolean a = formula();\n\t\tid++;\n\t\tboolean b = formula();\n\t\treturn a == b;\n\t}\n\tstatic boolean formula() {\n\t\tif(S.charAt(id) == 'T') {\n\t\t\tid++;\n\t\t\treturn true;\n\t\t}\n\t\tif(S.charAt(id) == 'F') {\n\t\t\tid++;\n\t\t\treturn false;\n\t\t}\n\t\tfor(int i = 0; i < 12; i++) {\n\t\t\t\n\t\t\tif(S.charAt(id) == (char)('a' + i)) {\n\t\t\t\tid++;\n\t\t\t\treturn (V & (1 << i)) != 0;\n\t\t\t}\n\t\t\t\n\t\t}\n\t\tif(S.charAt(id) == '-') {\n\t\t\tid++;\n\t\t\treturn !formula();\n\t\t}\n\t\tif(S.charAt(id) == '(') {\n\t\t\tid++;\n\t\t\tboolean A = formula();\n\t\t\tchar B = S.charAt(id);\n\t\t\tif(B == '-') {\n\t\t\t\tid++;\n\t\t\t}\n\t\t\tid++;\n\t\t\tboolean C = formula();\n\t\t\tid++;\n\t\t\tif(B == '-') {\n\t\t\t\tif(A && !C) return false;\n\t\t\t\treturn true;\n\t\t\t}\n\t\t\tif(B == '+') {\n\t\t\t\treturn A | C;\n\t\t\t}\n\t\t\tif(B == '*') {\n\t\t\t\treturn A & C;\n\t\t\t}\n\t\t}\n\t\treturn true;\n\t\t\n\t\t\n\t}\n }"
  },
  {
    "language": "Java",
    "code": "import java.util.*;\nimport static java.lang.System.*;\n\npublic class Main {\n\n\tScanner sc = new Scanner(in);\n\t\n\tchar[] eq;\n\tchar[] eq1, eq2;\n\tboolean[] as = new boolean[11];\n\tboolean[] check = new boolean[11];\n\t\n\tboolean flag;\n\tvoid calc(int depth) {\n\t\tif (depth == 11) {\n\t\t\tboolean a, b;\n\t\t\teq = eq1;\n\t\t\tindex = 0;\n\t\t\ta = F();\n\t\t\teq = eq2;\n\t\t\tindex = 0;\n\t\t\tb = F();\n//\t\t\tout.println(a);\n//\t\t\tout.println(b);\n//\t\t\tout.println();\n\t\t\tif (a != b)\n\t\t\t\tflag = false;\n\t\t} else {\n\t\t\tif (flag) {\n\t\t\t\tas[depth] = false;\n\t\t\t\tcalc(depth+1);\n\t\t\t\tas[depth] = true;\n\t\t\t\tcalc(depth+1);\n\t\t\t}\n\t\t}\n\t}\n\t\n\tint index;\n\tint token;\n\tfinal int VAL = '%';\n\tboolean value;\n\tvoid gettoken() {\n\t\tint ch = eq[index++];\n\t\tif (ch == '+' || ch == '*' || ch == '(' || ch == ')') {\n\t\t\ttoken = ch;\n\t\t\treturn;\n\t\t} else if (ch == '-') {\n\t\t\tif (eq[index] == '>') {\n\t\t\t\tindex++;\n\t\t\t\ttoken = '>';\n\t\t\t\treturn;\n\t\t\t} else {\n\t\t\t\ttoken = ch;\n\t\t\t\treturn;\n\t\t\t}\n\t\t} else {\n\t\t\ttoken = VAL;\n\t\t\tswitch(ch) {\n\t\t\tcase 'T':\n\t\t\t\tvalue = true; break;\n\t\t\tcase 'F':\n\t\t\t\tvalue = false; break;\n\t\t\tcase 'a':\n\t\t\t\tvalue = as[0]; break;\n\t\t\tcase 'b':\n\t\t\t\tvalue = as[1]; break;\n\t\t\tcase 'c':\n\t\t\t\tvalue = as[2]; break;\n\t\t\tcase 'd':\n\t\t\t\tvalue = as[3]; break;\n\t\t\tcase 'e':\n\t\t\t\tvalue = as[4]; break;\n\t\t\tcase 'f':\n\t\t\t\tvalue = as[5]; break;\n\t\t\tcase 'g':\n\t\t\t\tvalue = as[6]; break;\n\t\t\tcase 'h':\n\t\t\t\tvalue = as[7]; break;\n\t\t\tcase 'i':\n\t\t\t\tvalue = as[8]; break;\n\t\t\tcase 'j':\n\t\t\t\tvalue = as[9]; break;\n\t\t\tcase 'k':\n\t\t\t\tvalue = as[10]; break;\n\t\t\t}\n\t\t}\n\t}\n\t\n\tboolean F() {\n\t\tboolean v, vnext;\n\t\tint savetoken;\n\t\tgettoken();\n\t\tif (token == VAL) {\n\t\t\treturn value;\n\t\t} else if (token == '-') {\n\t\t\treturn !F();\n\t\t} else if (token == '(') {\n\t\t\tv = F();\n\t\t\tgettoken();\n\t\t\tsavetoken = token;\n\t\t\tvnext = F();\n\t\t\tgettoken();\n\t\t\tif (token != ')') out.println(\"err\");\n\t\t\tif (savetoken == '+') {\n\t\t\t\treturn v || vnext;\n\t\t\t} else if (savetoken == '*') {\n\t\t\t\treturn v && vnext;\n\t\t\t} else if (savetoken == '>') {\n\t\t\t\tif (!v) return true;\n\t\t\t\telse return vnext;\n\t\t\t}\n\t\t\t\n\t\t}\n\t\tout.println(\"err\");\n\t\treturn false;\n\t}\n\t\n\tvoid run() {\n\t\tString s;\n\t\tStringTokenizer st;\n\t\twhile (true) {\n\t\t\ts = sc.nextLine();\n\t\t\tif (s.equals(\"#\"))\n\t\t\t\tbreak;\n\t\t\tst = new StringTokenizer(s,\"=\");\n\t\t\teq1 = st.nextToken().toCharArray();\n\t\t\teq2 = st.nextToken().toCharArray();\n\t\t\tflag = true;\n\t\t\tcalc(0);\n\t\t\tif (flag)\n\t\t\t\tout.println(\"YES\");\n\t\t\telse\n\t\t\t\tout.println(\"NO\");\n//\t\t\tout.println();\n\t\t}\n\t}\n\t\n\tpublic static void main(String[] args) {\n\t\tnew Main().run();\n\t}\n}"
  },
  {
    "language": "Java",
    "code": "import java.util.Scanner;\nimport java.util.regex.Pattern;\n \npublic class Main {\n public static void main(String[] args) {\n    Scanner in = new Scanner(System.in);\n    String str=in.nextLine();\n    do {\n     String[] lr = str.split(\"=\");\n     Formula left = Formula.of(lr[0]);\n     Formula right = Formula.of(lr[1]);\n     int max = Integer.parseInt(\"11111111111\", 2);\n     boolean isYes = true;\n     for (int i = 0; i <= max && isYes; i++) {\n        isYes = left.getAns(i) == right.getAns(i);\n     }\n     System.out.println(isYes ? \"YES\" : \"NO\");\n     str = in.nextLine();\n    } while (!\"#\".equals(str));\n }\n}\n \nabstract class Formula {\n static final Pattern PATTERN =\n                                  Pattern\n                                    .compile(\"^\\\\((.+)\\\\)$\");\n \n abstract boolean getAns(int bools);\n \n public static Formula of(String string) {\n    if (\"T\".equals(string)) { return Teisu.T; }\n    if (\"F\".equals(string)) { return Teisu.F; }\n    if (\"a\".equals(string)) { return Var.a; }\n    if (\"b\".equals(string)) { return Var.b; }\n    if (\"c\".equals(string)) { return Var.c; }\n    if (\"d\".equals(string)) { return Var.d; }\n    if (\"e\".equals(string)) { return Var.e; }\n    if (\"f\".equals(string)) { return Var.f; }\n    if (\"g\".equals(string)) { return Var.g; }\n    if (\"h\".equals(string)) { return Var.h; }\n    if (\"i\".equals(string)) { return Var.i; }\n    if (string.startsWith(\"-\")) {\n     Not n = new Not(of(string.substring(1)));\n     return n;\n    }\n    String f1 = null;\n    String f2 = null;\n    String op = null;\n    StringBuilder sb = new StringBuilder();\n    int kakko = 0;\n    int posi = 1;\n    while (posi < string.length() - 1) {\n     char c = string.charAt(posi++);\n     if (c == '(') {\n        kakko++;\n     } else if (c == ')') {\n        kakko--;\n     }\n     if (kakko == 0) {\n        if (c == '+' || c == '*') {\n         op = (c == '+') ? \"+\" : \"*\";\n         f1 = sb.toString();\n         sb.setLength(0);\n        } else if (c == '-' && string.charAt(posi) == '>') {\n         posi++;\n         op = \"->\";\n         f1 = sb.toString();\n         sb.setLength(0);\n        }else{\n         sb.append(c);\n        }\n     } else {\n        sb.append(c);\n     }\n    }\n    f2 = sb.toString();\n    return new Ope(of(f1), op, of(f2));\n \n }\n \n}\n \nclass Teisu extends Formula {\n final boolean      bool;\n static final Teisu T = new Teisu(true);\n static final Teisu F = new Teisu(false);\n \n Teisu(boolean bool) {\n    this.bool = bool;\n }\n \n @Override\n boolean getAns(int bools) {\n    return bool;\n }\n}\n \nclass Var extends Formula {\n static final Var a = new Var(1);\n static final Var b = new Var(2);\n static final Var c = new Var(4);\n static final Var d = new Var(8);\n static final Var e = new Var(16);\n static final Var f = new Var(32);\n static final Var g = new Var(64);\n static final Var h = new Var(128);\n static final Var i = new Var(256);\n final int        var;\n \n Var(int var) {\n    this.var = var;\n }\n \n @Override\n boolean getAns(int bools) {\n    return var == (var & bools);\n }\n}\n \nclass Not extends Formula {\n final Formula f;\n \n Not(Formula f) {\n    this.f = f;\n }\n \n @Override\n boolean getAns(int bools) {\n    return !f.getAns(bools);\n }\n}\n \nclass Ope extends Formula {\n final Formula f1;\n final Formula f2;\n final String  op;\n \n Ope(Formula f1, String op, Formula f2) {\n    this.f1 = f1;\n    this.f2 = f2;\n    this.op = op;\n }\n \n @Override\n boolean getAns(int bools) {\n    boolean result;\n    if (\"*\".equals(op)) {\n     result = f1.getAns(bools) && f2.getAns(bools);\n    } else if (\"+\".equals(op)) {\n     result = f1.getAns(bools) || f2.getAns(bools);\n    } else {\n     result = f1.getAns(bools) == false || f2.getAns(bools) == true;\n    }\n    return result;\n }\n \n}"
  },
  {
    "language": "Java",
    "code": "import java.util.*;\nclass Main {\n  public static void main(String args[]){\n    new Main().run();\n  }\n \n  int idx;\n  String s;\n \n  Scanner sc = new Scanner(System.in);\n  void run(){\n    while(true){\n      s = sc.nextLine();\n      if(s.equals(\"#\"))break;\n      idx=0;\n      Expr e = equation();\n      boolean ans = true;\n      for(int i = 0 ; i < 1 << 11; i++){\n        Map<Character,Boolean> env = new HashMap<Character, Boolean>();\n        for(int j = 0 ; j < 11; j++){\n          env.put((char)('a' + j), ((i >> j) & 1) == 1);\n        }\n        ans = ans && e.eval(env);\n      }\n      System.out.println(ans ? \"YES\" : \"NO\");\n    }\n  }\n \n  Expr equation(){\n    Expr e1 = formula();\n    idx++;\n    Expr e2 = formula();\n    return new Eq(e1,e2);\n  }\n \n  Expr formula(){\n    char c;\n    switch(c = s.charAt(idx++)){\n      case 'T': \n        return new True();\n      case 'F':\n        return new False();\n      case '-': \n        return new Not(formula());\n      case '(':\n        Expr e1 = formula();\n        Expr e3 = null;\n        if(s.charAt(idx) == '*'){\n          idx++;\n          Expr e2 = formula();\n          e3= new And(e1,e2);\n        }else if(s.charAt(idx)=='+'){\n          idx++;\n          Expr e2 = formula();\n          e3= new Or(e1,e2);\n        } else{\n          idx++;\n          idx++;\n          Expr e2 = formula();\n          e3 = new Imp(e1,e2);\n        }\n        idx++;\n        return e3;\n      default:\n        return new Var(c);\n    }\n  }\n}\n \nabstract class Expr {\n  abstract boolean eval(Map<Character, Boolean> env);\n}\n \nclass Eq extends Expr{\n  Expr e1,e2;\n  Eq(Expr a, Expr b){\n    e1=a;\n    e2=b;\n  }\n \n  public boolean eval(Map<Character, Boolean> env){\n    return e1.eval(env) == e2.eval(env);\n  }\n \n  public String toString(){\n    return e1 + \"=\" + e2;\n  }\n}\n \nclass Not extends Expr{\n  Expr e;\n  Not(Expr expr){\n    this.e = expr;\n  }\n \n  public boolean eval(Map<Character, Boolean> env){\n    return !(e.eval(env));\n  }\n \n  public String toString(){\n    return \"-\" + e;\n  }\n}\n \nclass False extends Expr {\n  False(){\n  }\n \n  public boolean eval(Map<Character, Boolean> env){\n    return false;\n  }\n \n  public String toString(){\n    return \"F\";\n  }\n}\n \nclass True extends Expr {\n  True(){\n  }\n \n  public boolean eval(Map<Character, Boolean> env){\n    return true;\n  }\n \n  public String toString(){\n    return \"T\";\n  }\n}\n \nclass And extends Expr {\n  Expr e1;\n  Expr e2;\n  And(Expr a, Expr b){\n    e1 = a;\n    e2 = b;\n  }\n \n  public boolean eval(Map<Character, Boolean> env){\n    return e1.eval(env) && e2.eval(env);\n  }\n \n  public String toString(){\n    return \"(\" + e1 + \"*\" + e2 +\")\";\n  }\n}\n \nclass Or extends Expr {\n  Expr e1;\n  Expr e2;\n  Or(Expr a, Expr b){\n    e1 = a;\n    e2 = b;\n  }\n \n  public boolean eval(Map<Character, Boolean> env){\n    return e1.eval(env) || e2.eval(env);\n  }\n \n  public String toString(){\n    return \"(\" + e1 + \"+\" + e2 +\")\";\n  }\n}\n \nclass Imp extends Expr {\n  Expr e1;\n  Expr e2;\n  Imp(Expr a, Expr b){\n    e1 = a;\n    e2 = b;\n  }\n  public boolean eval(Map<Character, Boolean> env){\n    return !(e1.eval(env)) || e2.eval(env);\n  }\n \n  public String toString(){\n    return \"(\" + e1 + \"->\" + e2 +\")\";\n  }\n}\n \nclass Var extends Expr {\n  public char name;\n  Var(char c){\n    name =c;\n  }\n \n  public boolean equals (Var v){\n    return name == v.name;\n  }\n \n  public boolean eval(Map<Character, Boolean> env){\n    return env.get(name);\n  }\n \n  public String toString(){\n    return name+\"\";\n  }\n}"
  },
  {
    "language": "Java",
    "code": "\nimport java.util.*;\nimport java.awt.*;\nimport java.awt.geom.*;\n\nimport static java.lang.Math.*;\nimport static java.lang.System.out;\n\npublic class Main {\n\tfinal Scanner sc=new Scanner(System.in);\n\tfinal int INF=1<<24;\n\tdouble EPS = 1.0e-08;\n\tfinal int[] vx={0,1,0,-1},vy={1,0,-1,0};\n\tpublic static void main(String[] args) {\n\t\tnew Main().C();\n\t}\n\t\n\tvoid A(){\n\t\twhile(true){\n\t\t\tint n = sc.nextInt();\n\t\t\tif(n == 0)break;\n\t\t\tArrayList<TreeSet<Integer>> data = new ArrayList<TreeSet<Integer>>();\n\t\t\tfor(int i =0; i < n; i++){\n\t\t\t\tdata.add(new TreeSet<Integer>());\n\t\t\t\tint m = sc.nextInt();\n\t\t\t\tfor(int j = 0 ; j < m; j++){\n\t\t\t\t\tdata.get(i).add(sc.nextInt());\n\t\t\t\t}\n\t\t\t}\n\t\t\tTreeSet<Integer> data2 = new TreeSet<Integer>();\n\t\t\tint m = sc.nextInt();\n\t\t\tfor(int i=0; i < m; i++){\n\t\t\t\tdata2.add(sc.nextInt());\n\t\t\t}\n\t\t\t//boolean flg2 = false;\n\t\t\tint ind = -1;\n\t\t\tfor(int i=0; i < n; i++){\n\t\t\t\tboolean flg = true;\n\t\t\t\tfor(int result: data2){\n\t\t\t\t\tif(! data.get(i).contains(result)){\n\t\t\t\t\t\tflg = false;\n\t\t\t\t\t\tbreak;\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t\tif(flg){\n\t\t\t\t\tif(ind == -1){\n\t\t\t\t\t\tind = i + 1;\n\t\t\t\t\t}\n\t\t\t\t\telse{\n\t\t\t\t\t\t//flg2 = true;\n\t\t\t\t\t\tind = -1;\n\t\t\t\t\t\tbreak;\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t}\n\t\t\tSystem.out.println(ind);\n\t\t\t\n\t\t}\n\t}\n\t\n\t\n\tint BT,BP,BR;\n\tvoid B(){\n\t\twhile(sc.hasNext()){\n\t\t\tBT=sc.nextInt();\tBP=sc.nextInt();\tBR=sc.nextInt();\n\t\t\tif(BT==0)\tbreak;\n\t\t\tClassB[] rec=new ClassB[BT];\n\t\t\tfor(int i=0; i<BT; i++){\n\t\t\t\trec[i]=new ClassB(i);\n\t\t\t}\n\t\t\tfor(int i=0; i<BR; i++){\n\t\t\t\tint t=sc.nextInt()-1,p=sc.nextInt()-1,time=sc.nextInt();\n\t\t\t\tString mes=sc.next();\n\t\t\t\tif(mes.equals(\"CORRECT\")){\n\t\t\t\t\trec[t].num++;\n\t\t\t\t\trec[t].time+=time+(rec[t].p[p]*1200);\n\t\t\t\t}else if(mes.equals(\"WRONG\")){\n\t\t\t\t\trec[t].p[p]++;\n\t\t\t\t}\n\t\t\t}\n\t\t\tArrays.sort(rec);\n\t\t\tfor(ClassB i:rec)\tout.println((i.team+1)+\" \"+i.num+\" \"+i.time);\n\t\t}\n\t\t\n\t}\n\tclass ClassB implements Comparable<ClassB>{\n\t\tint team,num,time;\n\t\tint[] p=new int[BP];\n\t\tClassB(int t){this.team=t;}\n\t\t@Override public int compareTo(ClassB o) {\n\t\t\tif(this.num<o.num)\treturn 1;\n\t\t\tif(this.num>o.num)\treturn -1;\n\t\t\tif(this.time<o.time)\treturn -1;\n\t\t\tif(this.time>o.time)\treturn 1;\n\t\t\tif(this.team<o.team)\treturn -1;\n\t\t\tif(this.team>o.team)\treturn 1;\n\t\t\treturn 0;\n\t\t}\n\t}\n\t\n\tpublic class parsed{\n\t\tString line;\n\t\tint pos=0;\n\t\tboolean ans;\n\t\tparsed(String line){\n\t\t\tthis.line=line;\n\t\t\tans=term();\n\t\t}\n\t\tprivate boolean term(){\n\t\t\tboolean res=fact();\n\t\t\twhile(true){\n\t\t\t\tchar op=line.charAt(pos);\n\t\t\t\tif(op=='*'||op=='+'){\n\t\t\t\t\tboolean old=res;\n\t\t\t\t\tpos++;\n\t\t\t\t\tres=fact();\n\t\t\t\t\tswitch(op){\n\t\t\t\t\tcase '*':\tres=old&&res;\tbreak;\n\t\t\t\t\tcase '+':\tres=old||res;\tbreak;\n\t\t\t\t\t}\n\t\t\t\t}else if(op=='-' && line.charAt(pos+1)=='>'){\n\t\t\t\t\tboolean old=res;\n\t\t\t\t\tpos+=2;\n\t\t\t\t\tres=fact();\n\t\t\t\t\tres= !old?true:res?true:false;\n\t\t\t\t}else\tbreak;\n\t\t\t}\n\t\t\treturn res;\n\t\t}\n\t\tprivate boolean fact(){\n\t\t\tif(line.charAt(pos)=='-' && line.charAt(pos+1)!='>'){\n\t\t\t\tpos++;\n\t\t\t\treturn !fact();\n\t\t\t}\n\t\t\tif(line.charAt(pos)=='T'){\n\t\t\t\tpos++;\n\t\t\t\treturn true;\n\t\t\t}else if(line.charAt(pos)=='F'){\n\t\t\t\tpos++;\n\t\t\t\treturn false;\n\t\t\t}else if(line.charAt(pos)=='('){\n\t\t\t\tpos++;\n\t\t\t\tboolean res=term();\n\t\t\t\tpos++;\n\t\t\t\treturn res;\n\t\t\t}\n\t\t\treturn false;\n\t\t}\n\t\tpublic boolean res(){return ans;}\n\t}\n\t\n\tvoid C(){\n\t\twhile(sc.hasNext()){\n\t\t\tString str=sc.next();\n\t\t\tif(str.equals(\"#\"))\tbreak;\n\t\t\tstr=str.replaceAll(\"--\", \"\");\n\t\t\tint idx=str.indexOf(\"=\");\n\t\t\tString l=str.substring(0, idx),r=str.substring(idx+1);\n\t\t\tchar[] temp=str.replaceAll(\"[+-=*>()TF]\", \"\").toCharArray();\n\t\t\tHashSet<Character> set=new HashSet<Character>();\n\t\t\tfor(char c:temp)\tset.add(c);\n\t\t\tchar[] list=new char[set.size()];\n\t\t\tIterator<Character> it=set.iterator();\n\t\t\tint ii=0;\n\t\t\twhile(it.hasNext())\tlist[ii++]=it.next();\n\t\t\t//out.println(set);\n\t\t\tboolean flag=true;\n\t\t\tfor(int i=0; i<(1<<(set.size())); i++){\n\t\t\t\tString ll=l,rr=r;\n\t\t\t\tfor(int j=0; j<set.size(); j++){\n\t\t\t\t\tif( (i&(1<<j)) >0){\n\t\t\t\t\t\t//out.println((i&(1<<j))+\" J\"+j+\" I\"+i);\n\t\t\t\t\t\tll=ll.replaceAll(\"\"+list[j], \"T\");\n\t\t\t\t\t\t//ll=ll.replaceAll(\"-T\", \"F\");\n\t\t\t\t\t\t//ll=ll.replaceAll(\"-F\", \"T\");\n\t\t\t\t\t\trr=rr.replaceAll(\"\"+list[j], \"T\");\n\t\t\t\t\t\t//rr=rr.replaceAll(\"-T\", \"F\");\n\t\t\t\t\t\t//rr=rr.replaceAll(\"-F\", \"T\");\n\t\t\t\t\t}else{\n\t\t\t\t\t\tll=ll.replaceAll(\"\"+list[j], \"F\");\n\t\t\t\t\t\t//ll=ll.replaceAll(\"-T\", \"F\");\n\t\t\t\t\t\t//ll=ll.replaceAll(\"-F\", \"T\");\n\t\t\t\t\t\trr=rr.replaceAll(\"\"+list[j], \"F\");\n\t\t\t\t\t\t//rr=rr.replaceAll(\"-T\", \"F\");\n\t\t\t\t\t\t//rr=rr.replaceAll(\"-F\", \"T\");\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t\t//out.println(ll+\"=\"+new parsed(ll+\"#\").res()+\" \"+rr+\"=\"+new parsed(rr+\"#\").res());\n\t\t\t\tif(new parsed(ll+\"#\").res() != new parsed(rr+\"#\").res()){\n\t\t\t\t\tout.println(\"NO\");\n\t\t\t\t\tflag=false;\n\t\t\t\t\tbreak;\n\t\t\t\t}\n\t\t\t}\n\t\t\tif(flag)\tout.println(\"YES\");\n\t\t}\n\t}\n\t\n\tdouble getD1(Line2D a, Line2D b){\n\t\tPoint2D a1 = a.getP1();\n\t\tPoint2D a2 = a.getP2();\n\t\tPoint2D b1 = b.getP1();\n\t\tPoint2D b2 = b.getP2();\n\t\tdouble res = INF;\n\t\tres = min(res, getD(a1,a2, b1));\n\t\tres = min(res, getD(a1,a2, b2));\n\t\tres = min(res, getD(b1,b2, a1));\n\t\tres = min(res, getD(b1,b2, a2));\n\t\treturn res;\n\t}\n\t\n\tprivate double getD(Point2D a, Point2D b, Point2D c) {\n\t\tPoint2D ba = getV(b, a);\n\t\tPoint2D ca = getV(c, a);\n\t\tPoint2D ab = getV(a, b);\n\t\tPoint2D cb = getV(c, b);\n\t\tdouble result;\n\t\tif(getDot(ba,ca) < EPS){\n\t\t\tresult = a.distance(c);\n\t\t}\n\t\telse if(getDot(ab, cb) < EPS){\n\t\t\tresult = c.distance(b);\n\t\t}\n\t\telse{\n\t\t\tresult = Math.abs(getCross(ba,ca)) / b.distance(a);\n\t\t}\n\t\treturn result;\n\t}\n\t\n\tPoint2D getV(Point2D a, Point2D b){\n\t\tPoint2D ab = new Point2D.Double(a.getX() - b.getX() , a.getY() - b.getY());\n\t\treturn ab;\n\t}\n\t\n\tdouble getDot(Point2D a, Point2D b){\n\t\treturn (a.getX() * b.getX() + a.getY() * b.getY());\n\t}\n\t\n\tdouble getCross(Point2D a, Point2D b){\n\t\treturn (a.getX() * b.getY() - a.getY() * b.getX());\n\t}\n\n\tvoid D(){\n\t\twhile(sc.hasNext()){\n\t\t\tint N=sc.nextInt(),M=sc.nextInt()-1,L=sc.nextInt()-1;\n\t\t\tif(N==0)\tbreak;\n\t\t\tPoint2D [][] plist = new Point2D.Double[100][5];\n\t\t\tLine2D [][] llist = new Line2D.Double[100][5];\n\t\t\t\n\t\t\tfor(int i=0; i<N; i++){\n\t\t\t\tint x=sc.nextInt(),y=sc.nextInt(),a=sc.nextInt(),r=sc.nextInt();\n\t\t\t\tfor(int j = 0; j < 5; j++){\n\t\t\t\t\tdouble rad = Math.toRadians((a + 72 * j));\n\t\t\t\t\tdouble xx = x +  r * Math.sin(rad);\n\t\t\t\t\tdouble yy = y +  r * Math.cos(rad);\n\t\t\t\t\tplist[i][j] = new Point2D.Double(xx, yy);\n\t\t\t\t\t//System.out.println( x + \" \" + y + \" \" + a + \" \" + \" r=\" + r +\" xx ,yy = \" +plist[i][j].toString());\n\t\t\t\t}\n\t\t\t\t\n\t\t\t\tfor(int j = 0 ; j < 5; j++){\n\t\t\t\t\tllist[i][j] = new Line2D.Double(plist[i][j] , plist[i][(j+1)%5]);\n\t\t\t\t\t//System.out.println(llist[i][j].getP1().toString() + \" \" + llist[i][j].getP2().toString());\n\t\t\t\t}\n\t\t\t\t\n\t\t\t\t\n\t\t\t\t// 入力\n\t\t\t}\n\t\t\tdouble[][] d=new double[N][N];\n\t\t\tfor(int i = 0; i < N; i++){\n\t\t\t\td[i][i] = 0.0;\n\t\t\t\tfor(int j = i+1; j < N; j++){\n\t\t\t\t\tdouble ans = 1 << 24;\n\t\t\t\t\tfor(int k = 0 ; k < 5; k++){\n\t\t\t\t\t\tfor(int l = 0; l < 5; l++){\n\t\t\t\t\t\t\tLine2D nowi = llist[i][k];\n\t\t\t\t\t\t\tLine2D nowj = llist[j][l];\n\t\t\t\t\t\t\tif(nowi.intersectsLine(nowj)){\n\t\t\t\t\t\t\t\tans =0.0;\n\t\t\t\t\t\t\t\tcontinue;\n\t\t\t\t\t\t\t}\n\t\t\t\t\t\t\tdouble res = getD1(nowi , nowj);\n\t\t\t\t\t\t\t//System.out.print(\"res = \");\n\t\t\t\t\t\t\t//System.out.println(res);\n\t\t\t\t\t\t\tans = Math.min(ans, res);\n\t\t\t\t\t\t}\n\t\t\t\t\t}\n\t\t\t\t\td[i][j] = ans;\n\t\t\t\t\td[j][i] = ans;\n\t\t\t\t}\n\t\t\t}\n\t\t\t\n\t\t\t//debug\n\t\t\tSystem.out.println(\"debug = \");\n\t\t\tfor(int i=0; i < N; i++){\n\t\t\t\tfor(int j=0; j < N; j++){\n\t\t\t\t\tSystem.out.print(d[i][j] +\" \");\n\t\t\t\t}\n\t\t\t\tSystem.out.println();\n\t\t\t}\n\t\t\tSystem.out.println();\n\t\t\t\n\t\t\tfor(int j = 0; j < N; j++){\n\t\t\t\tfor(int i =0; i < N; i++){\n\t\t\t\t\tfor(int k=0; k < N; k++){\n\t\t\t\t\t\td[i][k] = Math.min(d[i][k], d[i][j] + d[j][k]);\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t}\n\t\t\n\t\t\tdouble ans= d[M][L];\n\t\t\t\n\t\t\tout.println(ans);\n\t\t}\n\t}\n\tclass CD{\n\t\tint n;\tdouble d;\n\t\tCD(int n,double d){this.n=n; this.d=d;}\n\t}\n}"
  },
  {
    "language": "Java",
    "code": "// Equation\nimport java.util.*;\n\npublic class Main {\n\tstatic int pos;\n\tstatic String equation;\n\tstatic int a, b, c, d, e, f, g, h, i, j, k;\n\n\tpublic static void main(String[] args) {\n\t\tScanner scanner = new Scanner(System.in);\n\t\twhile (true) {\n\t\t\tequation = scanner.next();\n\t\t\tif (equation.equals(\"#\"))\n\t\t\t\tbreak;\n\t\t\tboolean result = true;\n\t\t\tout: for (a = 0; a < 2; a++)\n\t\t\t\tfor (b = 0; b < 2; b++)\n\t\t\t\t\tfor (c = 0; c < 2; c++)\n\t\t\t\t\t\tfor (d = 0; d < 2; d++)\n\t\t\t\t\t\t\tfor (e = 0; e < 2; e++)\n\t\t\t\t\t\t\t\tfor (f = 0; f < 2; f++)\n\t\t\t\t\t\t\t\t\tfor (g = 0; g < 2; g++)\n\t\t\t\t\t\t\t\t\t\tfor (h = 0; h < 2; h++)\n\t\t\t\t\t\t\t\t\t\t\tfor (i = 0; i < 2; i++)\n\t\t\t\t\t\t\t\t\t\t\t\tfor (j = 0; j < 2; j++)\n\t\t\t\t\t\t\t\t\t\t\t\t\tfor (k = 0; k < 2; k++) {\n\t\t\t\t\t\t\t\t\t\t\t\t\t\tpos = 0;\n\t\t\t\t\t\t\t\t\t\t\t\t\t\tresult = result\n\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t&& eval();\n\t\t\t\t\t\t\t\t\t\t\t\t\t\tif (!result)\n\t\t\t\t\t\t\t\t\t\t\t\t\t\t\tbreak out;\n\t\t\t\t\t\t\t\t\t\t\t\t\t}\n\t\t\tif (result)\n\t\t\t\tSystem.out.println(\"YES\");\n\t\t\telse\n\t\t\t\tSystem.out.println(\"NO\");\n\t\t}\n\t\tscanner.close();\n\t}\n\n\tstatic boolean eval() {\n\t\tboolean boola = formura();\n\t\tpos++;\n\t\tboolean boolb = formura();\n\t\treturn boola == boolb;\n\t}\n\n\tstatic boolean formura() {\n\t\tchar cha = equation.charAt(pos);\n\t\tpos++;\n\t\tswitch (cha) {\n\t\tcase 'T':\n\t\t\treturn true;\n\t\tcase 'F':\n\t\t\treturn false;\n\t\tcase 'a':\n\t\t\treturn a == 1;\n\t\tcase 'b':\n\t\t\treturn b == 1;\n\t\tcase 'c':\n\t\t\treturn c == 1;\n\t\tcase 'd':\n\t\t\treturn d == 1;\n\t\tcase 'e':\n\t\t\treturn e == 1;\n\t\tcase 'f':\n\t\t\treturn f == 1;\n\t\tcase 'g':\n\t\t\treturn g == 1;\n\t\tcase 'h':\n\t\t\treturn h == 1;\n\t\tcase 'i':\n\t\t\treturn i == 1;\n\t\tcase 'j':\n\t\t\treturn j == 1;\n\t\tcase 'k':\n\t\t\treturn k == 1;\n\t\tcase '-':\n\t\t\treturn !formura();\n\t\tcase '(':\n\t\t\tboolean boola = formura();\n\t\t\tchar chb = equation.charAt(pos);\n\t\t\tpos++;\n\t\t\tboolean boolb;\n\t\t\tswitch (chb) {\n\t\t\tcase '*':\n\t\t\t\tboolb = formura();\n\t\t\t\tpos++;\n\t\t\t\treturn boola && boolb;\n\t\t\tcase '+':\n\t\t\t\tboolb = formura();\n\t\t\t\tpos++;\n\t\t\t\treturn boola || boolb;\n\t\t\tcase '-':\n\t\t\t\tpos++;\n\t\t\t\tboolb = formura();\n\t\t\t\tpos++;\n\t\t\t\treturn !boola || boolb;\n\t\t\t}\n\t\t}\n\t\treturn false;\n\t}\n}"
  },
  {
    "language": "Java",
    "code": "import java.util.*;\n\npublic class Main {\n\tString line ;\n\tint pos;\n\t\n\tprivate void doit(){\n\t\tScanner sc = new Scanner(System.in);\n\t\twhile(true){\n\t\t\tString str = sc.next() + \"#\";\n\t\t\tif(str.equals(\"##\")) break;\n\t\t\tstr = str.replaceAll(\"--\", \"\");\n\t\t\tArrayList<Character> list = new ArrayList<Character>();\n\t\t\tfor(int i=0; i < str.length();i++){\n\t\t\t\tchar temp = str.charAt(i);\n\t\t\t\tif('a' <= temp && temp <= 'k'){\n\t\t\t\t\tif(! list.contains(temp)){\n\t\t\t\t\t\tlist.add(temp);\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t}\n\t\t\tint len = list.size();\n\t\t\tboolean flg = true;\n\t\t\tfor(int i=0; i < (1 << len); i++){\n\t\t\t\tline = new String(str);\n\t\t\t\tpos = 0;\n\t\t\t\tfor(int j = 0; j < len; j++){\n\t\t\t\t\tString temp = \"\"+list.get(j);\n\t\t\t\t\t\n\t\t\t\t\tif((i & (1 << j)) != 0){\n\t\t\t\t\t\tline = line.replaceAll(temp, \"T\");\n\t\t\t\t\t}\n\t\t\t\t\telse{\n\t\t\t\t\t\tline = line.replaceAll(temp, \"F\");\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t\tboolean res = eval();\n\t\t\t\tif(! res){\n\t\t\t\t\tflg = false;\n\t\t\t\t\tbreak;\n\t\t\t\t}\n\t\t\t}\n\t\t\tif(flg) System.out.println(\"Yes\");\n\t\t\telse System.out.println(\"No\");\n\t\t}\n\t}\n\t\n\tprivate boolean eval() {\n\t\tboolean left = exp();\n\t\tchar op = line.charAt(pos++);\n\t\tboolean right = exp();\n\t\treturn left == right;\n\t}\n\n\tprivate boolean exp() {\n\t\tchar temp = line.charAt(pos++);\n\t\tswitch(temp){\n\t\tcase 'T':\n\t\t\treturn true;\n\t\tcase 'F':\n\t\t\treturn false;\n\t\tcase '-':\n\t\t\treturn (! exp());\n\t\tcase '(':\n\t\t\tboolean left = exp();\n\t\t\tchar op = line.charAt(pos++);\n\t\t\tboolean right;\n\t\t\tswitch(op){\n\t\t\tcase '*':\n\t\t\t\tright = exp();\n\t\t\t\tpos++;\n\t\t\t\treturn (left && right);\n\t\t\tcase '+':\n\t\t\t\tright = exp();\n\t\t\t\tpos++;\n\t\t\t\treturn (left || right);\n\t\t\tcase '-':\n\t\t\t\tpos++;\n\t\t\t\tright = exp();\n\t\t\t\tpos++;\n\t\t\t\tboolean res = getA(left, right);\n\t\t\t\treturn res;\n\t\t\t}\n\t\t}\n\t\treturn false;\n\t}\n\n\tprivate boolean getA(boolean left, boolean right) {\n\t\tif(left && ! right){\n\t\t\treturn false;\n\t\t}\n\t\treturn true;\n\t}\n\n\tpublic static void main(String[] args) {\n\t\tMain obj = new Main();\n\t\tobj.doit();\n\t}\n}"
  },
  {
    "language": "Java",
    "code": "import java.util.*;\nimport java.math.*;\nimport java.awt.geom.*;\nimport java.io.*;\n      \n      \npublic class Main {\n\tstatic int id;\n\tstatic String S;\n\tstatic int V;\n\tpublic static void main(String[] args) {\n\t\tScanner sc = new Scanner(System.in);\n\t\twhile(true) {\n\t\t\tS = sc.next();\n\t\t\tif(S.equals(\"#\")) break;\n\t\t\tboolean ans = true;\n\t\t\tfor(V = 0; V < (1 << 11); V++) {\n\t\t\t\tid = 0;\n\t\t\t\tans &= equation();\n\t\t\t\tif(!ans) break;\n\t\t\t}\n\t\t\tSystem.out.println(ans?\"YES\":\"NO\");\n\t\t}\n\t}\n\tstatic boolean equation() {\n\t\tboolean a = formula();\n\t\tid++;\n\t\tboolean b = formula();\n\t\treturn a == b;\n\t}\n\tstatic boolean formula() {\n\t\tif(S.charAt(id) == 'T') {\n\t\t\tid++;\n\t\t\treturn true;\n\t\t}\n\t\tif(S.charAt(id) == 'F') {\n\t\t\tid++;\n\t\t\treturn false;\n\t\t}\n\t\tfor(int i = 0; i < 11; i++) {\n\t\t\t\n\t\t\tif(S.charAt(id) == (char)('a' + i)) {\n\t\t\t\tid++;\n\t\t\t\treturn (V & (1 << i)) == 1;\n\t\t\t}\n\t\t\t\n\t\t}\n\t\tif(S.charAt(id) == '-') {\n\t\t\tid++;\n\t\t\treturn !formula();\n\t\t}\n\t\tif(S.charAt(id) == '(') {\n\t\t\tid++;\n\t\t\tboolean A = formula();\n\t\t\tchar B = S.charAt(id);\n\t\t\tif(B == '-') {\n\t\t\t\tid++;\n\t\t\t}\n\t\t\tid++;\n\t\t\tboolean C = formula();\n\t\t\tid++;\n\t\t\tif(B == '-') {\n\t\t\t\tif(A && !C) return false;\n\t\t\t\treturn true;\n\t\t\t}\n\t\t\tif(B == '+') {\n\t\t\t\treturn A | C;\n\t\t\t}\n\t\t\tif(B == '*') {\n\t\t\t\treturn A & C;\n\t\t\t}\n\t\t}\n\t\treturn true;\n\t\t\n\t\t\n\t}\n }"
  },
  {
    "language": "Java",
    "code": "import java.util.ArrayList;\nimport java.util.Collections;\nimport java.util.Scanner;\n\npublic class Main{\n\tstatic int p,t,r;\n\t\n\t\n\tpublic static void main(String[] args) {\n\t\tScanner sc=new Scanner(System.in);\n\t\twhile(true){\n\t\t\tt=sc.nextInt();\n\t\t\tp=sc.nextInt();\n\t\t\tr=sc.nextInt();\n\t\t\tif(t+p+r==0)break;\n\t\t\n\t\t\t\n\t\t\tArrayList<Data>list=new ArrayList<Data>();//listに入れる処理をしなきゃね\t\t\t\n\t\t\tfor(int i=0;i<t;i++){\n\t\t\t\tlist.add(new Data(i+1));\n\t\t\t}\n\t\t\tfor(int i=0;i<r;i++){\n\t\t\t\tint teams=sc.nextInt()-1;\n\t\t\t\tint number=sc.nextInt();\n\t\t\t\tint pena=sc.nextInt();\n\t\t\t\tString mes=sc.next();\n\t\t\t\tlist.get(teams).solve(number, pena, mes);\n\t\t\t}\n\t\t\tCollections.sort(list);\n\t\t\tfor(int i=0;i<list.size();i++){\n\t\t\t\tSystem.out.println(list.get(i));\n\t\t\t}\n\t\t}\n\t}\n\tstatic class Data implements Comparable<Data>{\n\t\tint team,ans,pena;\n\t\tint wrong[];boolean t[];\n\t\tpublic Data(int id){\n\t\t\tthis.team=id;\n\t\t\tthis.ans=0;\n\t\t\tthis.pena=0;\n\t\t\twrong=new int[p+1];\n\t\t\tt=new boolean[p+1];\n\t\t}\n\t\tvoid solve(int problem,int time,String message){//提出したときの処理\n\t\t\tif(message.equals(\"CORRECT\")){\n\t\t\t\tif(t[problem])return;\n\t\t\t\tans++;\n\t\t\t\tpena+=time+wrong[problem]*1200;\n\t\t\t\tt[problem]=true;\n\t\t\t}else{\n\t\t\t\twrong[problem]++;\n\t\t\t}\n\t\t}\n\t\t@Override\n\t\tpublic int compareTo(Data o) {\n\t\t\tif(this.ans<o.ans){\n\t\t\t\treturn 1;\n\t\t\t}else if(this.ans>o.ans){\n\t\t\t\treturn -1;\n\t\t\t}else if(this.pena>o.pena){\n\t\t\t\treturn 1;\n\t\t\t}else if(this.pena<o.pena){\n\t\t\t\treturn -1;\n\t\t\t}else if(this.team>o.team){\n\t\t\t\treturn 1;\n\t\t\t}else if(this.team<o.team){\n\t\t\t\treturn-1;\n\t\t\t}return 0;\n\t\t}\n\t\tpublic String toString(){\n\t\t\treturn this.team+\" \"+this.ans+\" \"+this.pena;\n\t\t}\n\t}\n}"
  },
  {
    "language": "Java",
    "code": "import java.util.Scanner;\nimport java.util.ArrayList;\n\npublic class Main {\n\tScanner sc;\n\tpublic void run(){\n\t\tsc = new Scanner(System.in);\n\t\twhile(sc.hasNext()){\n\t\t\tString n = sc.next();\n\t\t\tif(n.equals(\"#\")){\n\t\t\t\tbreak;\n\t\t\t}\n\t\t\telse{\n\t\t\t\tcalc(n);\n\t\t\t}\n\t\t}\n\t}\n\tString s;\n\tpublic void calc(String line){\n\t\ts = line;\n\t\tEquation tree = makeEquation();\n\t\t\n\t\tboolean ans = true;\n\t\t\n\t\tfor(int a = 0; a < 2; a++){\n\t\t\tfor(int b = 0; b < 2; b++){\n\t\t\t\tfor(int c = 0; c < 2; c++){\n\t\t\t\t\tfor(int d = 0; d < 2; d++){\n\t\t\t\t\t\tfor(int e = 0; e < 2; e++){\n\t\t\t\t\t\t\tfor(int f = 0; f < 2; f++){\n\t\t\t\t\t\t\t\tfor(int g = 0; g < 2; g++){\n\t\t\t\t\t\t\t\t\tfor(int h = 0; h < 2; h++){\n\t\t\t\t\t\t\t\t\t\tfor(int i = 0; i < 2; i++){\n\t\t\t\t\t\t\t\t\t\t\tfor(int j = 0; j < 2; j++){\n\t\t\t\t\t\t\t\t\t\t\t\tfor(int k = 0; k < 2; k++){\n\t\t\t\t\t\t\t\t\t\t\t\t\tboolean t = tree.calc(a, b, c, d, e, f, g, h, i, j, k);\n\t\t\t\t\t\t\t\t\t\t\t\t\tif(!t) ans = false;\n\t\t\t\t\t\t\t\t\t\t\t\t}\n\t\t\t\t\t\t\t\t\t\t\t}\n\t\t\t\t\t\t\t\t\t\t}\n\t\t\t\t\t\t\t\t\t}\n\t\t\t\t\t\t\t\t}\n\t\t\t\t\t\t\t}\n\t\t\t\t\t\t}\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t\tif(ans) System.out.println(\"YES\");\n\t\telse System.out.println(\"NO\");\n\t}\n\tpublic Equation makeEquation(){\n\t\tFormula f1 = makeFormula();\n\t\tif(s.substring(0,1).equals(\"=\")){\n\t\t\ts = s.substring(1);\n\t\t}\n\t\telse return null;\n\t\tFormula f2 = makeFormula();\n\t\treturn new Equation(f1, f2);\n\t}\n\tpublic Formula makeFormula(){\n\t\tString now = s.substring(0,1);\n\t\ts = s.substring(1);\n\t\t\n\t\tif(now.equals(\"T\")) return new BoolFormula(1);\n\t\telse if(now.equals(\"F\")) return new BoolFormula(0);\n\t\telse if(now.equals(\"-\")){\n\t\t\tFormula f1 = makeFormula();\n\t\t\treturn new NotFormula(f1);\n\t\t}\n\t\telse if(now.equals(\"(\")){\n\t\t\tFormula f1 = makeFormula();\n\t\t\tString now2 = s.substring(0,1);\n\t\t\ts = s.substring(1);\n\t\t\tif(now2.equals(\"*\")){\n\t\t\t\tFormula f2 = makeFormula();\n\t\t\t\ts = s.substring(1);\n\t\t\t\treturn new AndFormula(f1, f2);\n\t\t\t}\n\t\t\telse if(now2.equals(\"+\")){\n\t\t\t\tFormula f2 = makeFormula();\n\t\t\t\ts = s.substring(1);\n\t\t\t\treturn new OrFormula(f1, f2);\n\t\t\t}\n\t\t\telse{\n\t\t\t\ts = s.substring(1);\n\t\t\t\tFormula f2 = makeFormula();\n\t\t\t\ts = s.substring(1);\n\t\t\t\treturn new ImpFormula(f1, f2);\n\t\t\t}\n\t\t}\n\t\telse return new StringFormula(s);\n\t}\n\tpublic static void main(String[] args){\n\t\tnew Main().run();\n\t}\n}\n\nclass Equation{\n\tFormula value1;\n\tFormula value2;\n\tEquation(Formula v1, Formula v2){\n\t\tthis.value1 = v1;\n\t\tthis.value2 = v2;\n\t}\n\tboolean calc(int a, int b, int c, int d, int e, int f, int g, int h,\n\t\t\tint i, int j, int k){\n\t\tint v1 = value1.calc(a, b, c, d, e, f, g, h, i, j, k);\n\t\tint v2 = value2.calc(a, b, c, d, e, f, g, h, i, j, k);\n\t\tif(v1 == v2) return true;\n\t\telse return false;\n\t}\n}\n\nclass Formula{\n\tint calc(int a, int b, int c, int d, int e, int f, int g, int h,\n\t\t\tint i, int j, int k) {\n\t\treturn 0;\n\t}\n\t\n}\nclass BoolFormula extends Formula{\n\tint value;\n\tBoolFormula(int b){\n\t\tthis.value = b;\n\t}\n\tint calc(int a, int b, int c, int d, int e, int f, int g, int h, int i, int j, int k){\n\t\treturn value;\n\t}\n}\nclass StringFormula extends Formula{\n\tString value;\n\tStringFormula(String c){\n\t\tthis.value = c;\n\t}\n\tint calc(int a, int b, int c, int d, int e, int f, int g, int h, int i, int j, int k){\n\t\tif(value.equals(\"a\")) return a;\n\t\telse if(value.equals(\"b\")) return b;\n\t\telse if(value.equals(\"c\")) return c;\n\t\telse if(value.equals(\"d\")) return d;\n\t\telse if(value.equals(\"e\")) return e;\n\t\telse if(value.equals(\"f\")) return f;\n\t\telse if(value.equals(\"g\")) return g;\n\t\telse if(value.equals(\"h\")) return h;\n\t\telse if(value.equals(\"i\")) return i;\n\t\telse if(value.equals(\"j\")) return j;\n\t\telse  return k;\n\t}\n}\nclass NotFormula extends Formula{\n\tFormula value;\n\tNotFormula(Formula v){\n\t\tthis.value = v;\n\t}\n\tint calc(int a, int b, int c, int d, int e, int f, int g, int h, int i, int j, int k){\n\t\tint v = value.calc(a,b,c,d,e,f,g,h,i,j,k);\n\t\tif(v == 1) return 0;\n\t\telse return 1;\n\t}\n}\n\nclass AndFormula extends Formula{\n\tFormula value1;\n\tFormula value2;\n\tint[][] ans;\n\tAndFormula(Formula v1, Formula v2){\n\t\tthis.value1 = v1;\n\t\tthis.value2 = v2;\n\t\tans = new int[2][2];\n\t\tans[1][1] = 1;\n\t\tans[1][0] = 0;\n\t\tans[0][1] = 0;\n\t\tans[0][0] = 0;\n\t}\n\tint calc(int a, int b, int c, int d, int e, int f, int g, int h, int i, int j, int k){\n\t\tint v1 = value1.calc(a,b,c,d,e,f,g,h,i,j,k);\n\t\tint v2 = value2.calc(a,b,c,d,e,f,g,h,i,j,k);\n\t\treturn ans[v1][v2];\n\t}\n}\nclass OrFormula extends Formula{\n\tFormula value1;\n\tFormula value2;\n\tint[][] ans;\n\tOrFormula(Formula v1, Formula v2){\n\t\tthis.value1 = v1;\n\t\tthis.value2 = v2;\n\t\tans = new int[2][2];\n\t\tans[1][1] = 1;\n\t\tans[1][0] = 1;\n\t\tans[0][1] = 1;\n\t\tans[0][0] = 0;\n\t}\n\tint calc(int a, int b, int c, int d, int e, int f, int g, int h, int i, int j, int k){\n\t\tint v1 = value1.calc(a,b,c,d,e,f,g,h,i,j,k);\n\t\tint v2 = value2.calc(a,b,c,d,e,f,g,h,i,j,k);\n\t\treturn ans[v1][v2];\n\t}\n}\nclass ImpFormula extends Formula{\n\tFormula value1;\n\tFormula value2;\n\tint[][] ans;\n\tImpFormula(Formula v1, Formula v2){\n\t\tthis.value1 = v1;\n\t\tthis.value2 = v2;\n\t\tans = new int[2][2];\n\t\tans[1][1] = 1;\n\t\tans[1][0] = 0;\n\t\tans[0][1] = 1;\n\t\tans[0][0] = 1;\n\t}\n\tint calc(int a, int b, int c, int d, int e, int f, int g, int h, int i, int j, int k){\n\t\tint v1 = value1.calc(a,b,c,d,e,f,g,h,i,j,k);\n\t\tint v2 = value2.calc(a,b,c,d,e,f,g,h,i,j,k);\n\t\treturn ans[v1][v2];\n\t}\n}"
  },
  {
    "language": "Java",
    "code": "import java.util.Scanner;\n\npublic class Main {\n\n\tstatic Scanner sc = new Scanner(System.in);\n\tstatic int var;\n\tstatic char[] str;\n\tstatic int pos;\n\n\tpublic static void main(String[] arg) {\n\t\twhile (true) {\n\t\t\tstr = sc.next().toCharArray();\n\t\t\tif (str[0] == '#') break;\n\t\t\tpos = 0;\n\t\t\tFormula l = parse();\n\t\t\t++pos;\n\t\t\tFormula r = parse();\n\t\t\tboolean res = true;\n\t\t\tfor (var = 0; var < (1 << 11); ++var) {\n\t\t\t\tif (l.eval() != r.eval()) {\n\t\t\t\t\tres = false;\n\t\t\t\t\tbreak;\n\t\t\t\t}\n\t\t\t}\n\t\t\tSystem.out.println(res ? \"YES\" : \"NO\");\n\t\t}\n\t}\n\n\tstatic Formula parse() {\n\t\tchar c = str[pos++];\n\t\tif (c == 'T') return new Constant(true);\n\t\tif (c == 'F') return new Constant(false);\n\t\tif ('a' <= c && c <= 'z') return new Var(c - 'a');\n\t\tif (c == '-') return new Not(parse());\n\t\tFormula l = parse();\n\t\tchar op = str[pos++];\n\t\tif (op == '*') {\n\t\t\tFormula r = parse();\n\t\t\t++pos;\n\t\t\treturn new And(l, r);\n\t\t} else if (op == '+') {\n\t\t\tFormula r = parse();\n\t\t\t++pos;\n\t\t\treturn new Or(l, r);\n\t\t} else {\n\t\t\t++pos;\n\t\t\tFormula r = parse();\n\t\t\t++pos;\n\t\t\treturn new Imp(l, r);\n\t\t}\n\t}\n\n\tstatic abstract class Formula {\n\t\tabstract boolean eval();\n\t}\n\n\tstatic class Constant extends Formula {\n\t\tboolean v;\n\n\t\tConstant(boolean v) {\n\t\t\tthis.v = v;\n\t\t}\n\n\t\tboolean eval() {\n\t\t\treturn this.v;\n\t\t}\n\t}\n\n\tstatic class Var extends Formula {\n\t\tint p;\n\n\t\tVar(int p) {\n\t\t\tthis.p = p;\n\t\t}\n\n\t\tboolean eval() {\n\t\t\treturn (var & (1 << p)) != 0;\n\t\t}\n\t}\n\n\tstatic class Not extends Formula {\n\t\tFormula f;\n\n\t\tNot(Formula f) {\n\t\t\tthis.f = f;\n\t\t}\n\n\t\tboolean eval() {\n\t\t\treturn !f.eval();\n\t\t}\n\t}\n\n\tstatic class And extends Formula {\n\t\tFormula left, right;\n\n\t\tAnd(Formula l, Formula r) {\n\t\t\tthis.left = l;\n\t\t\tthis.right = r;\n\t\t}\n\n\t\tboolean eval() {\n\t\t\treturn left.eval() && right.eval();\n\t\t}\n\t}\n\n\tstatic class Or extends Formula {\n\t\tFormula left, right;\n\n\t\tOr(Formula l, Formula r) {\n\t\t\tthis.left = l;\n\t\t\tthis.right = r;\n\t\t}\n\n\t\tboolean eval() {\n\t\t\treturn left.eval() || right.eval();\n\t\t}\n\t}\n\n\tstatic class Imp extends Formula {\n\t\tFormula left, right;\n\n\t\tImp(Formula l, Formula r) {\n\t\t\tthis.left = l;\n\t\t\tthis.right = r;\n\t\t}\n\n\t\tboolean eval() {\n\t\t\treturn !left.eval() || right.eval();\n\t\t}\n\t}\n\n}"
  },
  {
    "language": "Java",
    "code": "import java.io.BufferedReader;\nimport java.io.IOException;\nimport java.io.InputStreamReader;\nimport java.util.Arrays;\nimport java.util.Scanner;\nimport java.util.TreeSet;\n\nimport javax.xml.bind.ParseConversionEvent;\n\npublic class Main {\n\n\tpublic static interface Expr{\n\t\tpublic boolean eval(boolean a, boolean b, boolean c, boolean d, boolean e, boolean f, boolean g, boolean h, boolean i, boolean j, boolean k);\n\t}\n\t\n\tpublic static class T implements Expr{\n\t\t\n\t\tpublic String toString(){\n\t\t\treturn \"T\";\n\t\t}\n\t\t\n\t\t@Override\n\t\tpublic boolean eval(boolean a, boolean b, boolean c, boolean d,\n\t\t\t\tboolean e, boolean f, boolean g, boolean h, boolean i,\n\t\t\t\tboolean j, boolean k) {\n\t\t\treturn true;\n\t\t}\n\t}\n\n\tpublic static class F implements Expr{\n\t\t\n\t\tpublic String toString(){\n\t\t\treturn \"F\";\n\t\t}\n\t\t\n\t\t@Override\n\t\tpublic boolean eval(boolean a, boolean b, boolean c, boolean d,\n\t\t\t\tboolean e, boolean f, boolean g, boolean h, boolean i,\n\t\t\t\tboolean j, boolean k) {\n\t\t\treturn false;\n\t\t}\n\t}\n\t\n\tpublic static class Var implements Expr{\n\t\tint num;\n\t\t\n\t\tpublic Var(int a){\n\t\t\tnum = a;\n\t\t}\n\t\t\n\t\tpublic String toString(){\n\t\t\treturn Character.toString((char) ('a' + num));\n\t\t}\n\t\t\n\t\t@Override\n\t\tpublic boolean eval(boolean a, boolean b, boolean c, boolean d,\n\t\t\t\tboolean e, boolean f, boolean g, boolean h, boolean i,\n\t\t\t\tboolean j, boolean k) {\n\t\t\tswitch(num){\n\t\t\tcase 0:\n\t\t\t\treturn a;\n\t\t\tcase 1:\n\t\t\t\treturn b;\n\t\t\tcase 2:\n\t\t\t\treturn c;\n\t\t\tcase 3:\n\t\t\t\treturn d;\n\t\t\tcase 4:\n\t\t\t\treturn e;\n\t\t\tcase 5:\n\t\t\t\treturn f;\n\t\t\tcase 6:\n\t\t\t\treturn g;\n\t\t\tcase 7:\n\t\t\t\treturn h;\n\t\t\tcase 8:\n\t\t\t\treturn i;\n\t\t\tcase 9:\n\t\t\t\treturn j;\n\t\t\tcase 10:\n\t\t\t\treturn k;\n\t\t\tdefault: \n\t\t\t\treturn false;\n\t\t\t}\n\t\t}\n\t}\n\t\n\tpublic static class Not implements Expr{\n\t\tprivate Expr inner;\n\t\t\n\t\tpublic Not(Expr e){\n\t\t\tinner = e;\n\t\t}\n\t\t\n\t\tpublic String toString(){\n\t\t\treturn \"~\" + inner.toString();\n\t\t}\n\t\t\n\t\t@Override\n\t\tpublic boolean eval(boolean a, boolean b, boolean c, boolean d,\n\t\t\t\tboolean e, boolean f, boolean g, boolean h, boolean i,\n\t\t\t\tboolean j, boolean k) {\n\t\t\treturn !inner.eval(a, b, c, d, e, f, g, h, i, j, k);\n\t\t}\n\t}\n\t\n\tpublic static class And implements Expr{\n\t\tprivate Expr inner_l, inner_r;\n\t\t\n\t\t\n\t\tpublic And(Expr e_l, Expr e_r){\n\t\t\tinner_l = e_l;\n\t\t\tinner_r = e_r;\n\t\t}\n\t\t\n\t\tpublic String toString(){\n\t\t\treturn \"(\" + inner_l.toString() + \" * \" + inner_r.toString() + \")\";\n\t\t}\n\t\t\n\t\t@Override\n\t\tpublic boolean eval(boolean a, boolean b, boolean c, boolean d,\n\t\t\t\tboolean e, boolean f, boolean g, boolean h, boolean i,\n\t\t\t\tboolean j, boolean k) {\n\t\t\treturn inner_l.eval(a, b, c, d, e, f, g, h, i, j, k) && inner_r.eval(a, b, c, d, e, f, g, h, i, j, k);\n\t\t}\n\t}\n\t\n\tpublic static class Or implements Expr{\n\t\tprivate Expr inner_l, inner_r;\n\t\t\n\t\t\n\t\tpublic Or(Expr e_l, Expr e_r){\n\t\t\tinner_l = e_l;\n\t\t\tinner_r = e_r;\n\t\t}\n\t\t\n\t\tpublic String toString(){\n\t\t\treturn \"(\" + inner_l.toString() + \" + \" + inner_r.toString() + \")\";\n\t\t}\n\t\t\n\t\t@Override\n\t\tpublic boolean eval(boolean a, boolean b, boolean c, boolean d,\n\t\t\t\tboolean e, boolean f, boolean g, boolean h, boolean i,\n\t\t\t\tboolean j, boolean k) {\n\t\t\treturn inner_l.eval(a, b, c, d, e, f, g, h, i, j, k) || inner_r.eval(a, b, c, d, e, f, g, h, i, j, k);\n\t\t}\n\t}\n\t\n\tpublic static class Conj implements Expr{\n\t\tprivate Expr inner_l, inner_r;\n\t\t\n\t\t\n\t\tpublic Conj(Expr e_l, Expr e_r){\n\t\t\tinner_l = e_l;\n\t\t\tinner_r = e_r;\n\t\t}\n\t\t\n\t\tpublic String toString(){\n\t\t\treturn \"(\" + inner_l.toString() + \" -> \" + inner_r.toString() + \")\";\n\t\t}\n\t\t\n\t\t@Override\n\t\tpublic boolean eval(boolean a, boolean b, boolean c, boolean d,\n\t\t\t\tboolean e, boolean f, boolean g, boolean h, boolean i,\n\t\t\t\tboolean j, boolean k) {\n\t\t\treturn !inner_l.eval(a, b, c, d, e, f, g, h, i, j, k) || inner_r.eval(a, b, c, d, e, f, g, h, i, j, k);\n\t\t}\n\t}\n\t\n\tpublic static Expr parse(char[] input, int start, int end){\n\t\tint s_level = 0;\n\t\tint s_start = start, s_end = end;\n\t\tint op_num = -1, op_pre = -1, op_post = -1;\n\t\t\n\t\tfor(int i = start; i <= end; i++){\n\t\t\tif(input[i] == '('){\n\t\t\t\tif(s_level == 0){\n\t\t\t\t\ts_start = i+1;\n\t\t\t\t}\n\t\t\t\t\n\t\t\t\ts_level++;\n\t\t\t\t\n\t\t\t}else if(input[i] == ')'){\n\t\t\t\ts_level--;\n\t\t\t\t\n\t\t\t\tif(s_level == 0){\n\t\t\t\t\ts_end = i-1;\n\t\t\t\t}\n\t\t\t}else if(op_num == -1 && s_level == 1 && input[i] == '+'){\n\t\t\t\top_num = 0;\n\t\t\t\top_pre = i - 1;\n\t\t\t\top_post = i + 1;\n\t\t\t}else if(op_num == -1 && s_level == 1 && input[i] == '*'){\n\t\t\t\top_num = 1;\n\t\t\t\top_pre = i - 1;\n\t\t\t\top_post = i + 1;\n\t\t\t}else if(op_num == -1 && s_level == 0 && input[i] == '-'){\n\t\t\t\top_num = 2;\n\t\t\t\top_pre = i - 1;\n\t\t\t\top_post = i + 1;\n\t\t\t}else if(op_num == -1 && s_level == 1 && input[i] == '-' && input[i+1] == '>'){\n\t\t\t\top_num = 3;\n\t\t\t\top_pre = i - 1;\n\t\t\t\top_post = i + 2;\n\t\t\t}\n\t\t}\n\t\t\n\t\tif(op_num == 0){\n\t\t\treturn new Or(parse(input, s_start, op_pre), parse(input, op_post, s_end));\n\t\t}else if(op_num == 1){\n\t\t\treturn new And(parse(input, s_start, op_pre), parse(input, op_post, s_end));\n\t\t}else if(op_num == 2){\n\t\t\treturn new Not(parse(input, op_post, s_end));\n\t\t}else if(op_num == 3){\n\t\t\treturn new Conj(parse(input, s_start, op_pre), parse(input, op_post, s_end));\n\t\t}else{\n\t\t\tif(input[start] == 'T'){\n\t\t\t\treturn new T();\n\t\t\t}else if(input[start] == 'F'){\n\t\t\t\treturn new F();\n\t\t\t}else{\n\t\t\t\treturn new Var(input[start] - 'a');\n\t\t\t}\n\t\t}\n\t\t\n\t}\n\t\n\tpublic static void main(String[] args) throws IOException {\n\t\tScanner sc = new Scanner(System.in);\n\n\t\twhile (true) {\n\t\t\tString input = sc.next();\n\t\t\t\n\t\t\tif(\"#\".equals(input)){\n\t\t\t\tbreak;\n\t\t\t}\n\t\t\t\n\t\t\tString[] inputs = input.split(\"=\");\n\t\t\t\n\t\t\tboolean flag = true;\n\t\t\t\n\t\t\tExpr right = parse(inputs[0].toCharArray(), 0, inputs[0].length()-1);\n\t\t\tExpr left = parse(inputs[1].toCharArray(), 0, inputs[1].length()-1);\n\t\t\t\n\t\t\t//System.out.println(right);\n\t\t\t//System.out.println(left);\n\t\t\t\n\t\t\tEND:\n\t\t\tfor(int a = 0; a < 2; a++){\n\t\t\t\tfor(int b = 0; b < 2; b++){\n\t\t\t\t\tfor(int c = 0; c < 2; c++){\n\t\t\t\t\t\tfor(int d = 0; d < 2; d++){\n\t\t\t\t\t\t\tfor(int e = 0; e < 2; e++){\n\t\t\t\t\t\t\t\tfor(int f = 0; f < 2; f++){\n\t\t\t\t\t\t\t\t\tfor(int g = 0; g < 2; g++){\n\t\t\t\t\t\t\t\t\t\tfor(int h = 0; h < 2; h++){\n\t\t\t\t\t\t\t\t\t\t\tfor(int i = 0; i < 2; i++){\n\t\t\t\t\t\t\t\t\t\t\t\tfor(int j = 0; j < 2; j++){\n\t\t\t\t\t\t\t\t\t\t\t\t\tfor(int k = 0; k < 2; k++){\n\t\t\t\t\t\t\t\t\t\t\t\t\t\tif(right.eval(a == 1, b == 1, c == 1, d == 1, e == 1, f == 1, g == 1, h == 1, i == 1, j == 1, k == 1)\n\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t!=\n\t\t\t\t\t\t\t\t\t\t\t\t\t\t\tleft.eval(a == 1, b == 1, c == 1, d == 1, e == 1, f == 1, g == 1, h == 1, i == 1, j == 1, k == 1)){\n\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\n\t\t\t\t\t\t\t\t\t\t\t\t\t\t\tflag = false;\n\t\t\t\t\t\t\t\t\t\t\t\t\t\t\tbreak END;\n\t\t\t\t\t\t\t\t\t\t\t\t\t\t}\n\t\t\t\t\t\t\t\t\t\t\t\t\t}\n\t\t\t\t\t\t\t\t\t\t\t\t}\n\t\t\t\t\t\t\t\t\t\t\t}\n\t\t\t\t\t\t\t\t\t\t}\n\t\t\t\t\t\t\t\t\t}\n\t\t\t\t\t\t\t\t}\n\t\t\t\t\t\t\t}\n\t\t\t\t\t\t}\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t}\n\t\t\t\n\t\t\tSystem.out.println(flag ? \"YES\" : \"NO\");\n\t\t}\n\n\t}\n\n}"
  },
  {
    "language": "Java",
    "code": "\nimport java.util.Scanner;\n\npublic class Main {\n\tpublic static void main(String[] args) {\n\t\tMain p = new Main();\n\t}\n\n\tpublic Main() {\n\t\tScanner sc = new Scanner(System.in);\n\t\talphav = new boolean[11];\n\t\twhile(true){\n\t\t\tString s = sc.next();\n\t\t\tif(s.equals(\"#\"))\n\t\t\t\tbreak;\n\t\t\tsolve(s);\n\t\t}\n\t\t\n\t}\n\n\tpublic void solve(String s) {\n\t\tString[] fs = s.split(\"=\");\n\t\tboolean res = true;\n\t\tfor(int i=0;i<(1<<11);i++){\n\t\t\tfor(int j=0;j<alphav.length;j++)\n\t\t\t\talphav[j] = (i&(1<<j)) > 0; \n\t\t\tcur = 0;\n\t\t\tf = fs[0];\n\t\t\tboolean r0 = fomula();\n\t\t\tcur = 0;\n\t\t\tf = fs[1];\n\t\t\tboolean r1 = fomula();\n\t\t\tif(r0 != r1){\n\t\t\t\tres = false;\n\t\t\t\tbreak;\n\t\t\t}\n\t\t}\n\t\tSystem.out.println(res? \"YES\" : \"NO\");\n\t}\n\n\tboolean[] alphav;\n\tString f;\n\tint cur = 0;\n\tprivate boolean fomula() {\n\t\tboolean ret = false;\n\t\tchar nc = nextc();\n\t\t\n\t\tif('a' <= nc && nc <= 'k')\n\t\t\treturn alphav[nc-'a'];\n\t\t\n\t\tswitch(nc){\n\t\tcase 'T':\n\t\t\tret = true;\n\t\t\tbreak;\n\t\t\n\t\tcase 'F':\n\t\t\tret = false;\n\t\t\tbreak;\n\t\t\t\n\t\tcase '-':\n\t\t\tret = !fomula();\n\t\t\tbreak;\n\t\t\t\n\t\tcase '(':\n\t\t\tret = fomula();\n\t\t\tnc = nextc();\n\t\t\tswitch(nc){\n\t\t\tcase '*':\n\t\t\t\tret &= fomula();\n\t\t\t\tbreak;\n\t\t\tcase '+':\n\t\t\t\tret |= fomula();\n\t\t\t\tbreak;\n\t\t\tcase '-':\n\t\t\t\tnextc();\n\t\t\t\tret = !(ret && !fomula());\n\t\t\t\tnextc();\n\t\t\t\tbreak;\n\t\t\t}\n\t\t\tbreak;\n\t\t}\n\t\t\n\t\treturn ret;\n\t}\n\t\n\tprivate char nextc(){\n\t\tchar c = f.charAt(cur);\n\t\tcur++;\n\t\treturn c;\n\t}\n}"
  },
  {
    "language": "Java",
    "code": "import java.util.Scanner;\n\npublic class Main {\n\tpublic static String input;\n\tpublic static int p;\n\tpublic static int len;\n\tpublic static boolean[] alpha = new boolean[11];\n\tpublic static void main(String[] args){\n\t\tnew Main().run();\n\t\t//test();\n\t}\n\t\n\tpublic static void test(){\n\t\tboolean b;\n\t\tSystem.out.println(Character.getNumericValue('a'));\n\t\tSystem.out.println(Character.getNumericValue('b'));\n\t}\n\t\n\n\tpublic void run(){\n\t\tScanner sc = new Scanner(System.in);\n\t\tinput = sc.next();\n\t\twhile(input.equals(\"#\") == false){\n\t\t\tlen = input.length();\n\t\t\tp = 0;\n\t\t\tboolean left;\n\t\t\tboolean right;\n\t\t\tboolean bOK = true;\n\t\t\tint c = 0;\n\t\t\t//a~k&#199;?&#199;&#9674;&#199;&#402;&#199;&#63743;&#233;&#233;&#199;?\n\t\t\tfor(int i1 = 0; i1 < 2; i1++){\n\t\t\t\talpha[alpha2Int('a')] = int2Bool(i1);\n\t\t\t\tfor(int i2 = 0; i2 < 2; i2++){\n\t\t\t\t\talpha[alpha2Int('b')] = int2Bool(i2);\n\t\t\t\t\tfor(int i3 = 0; i3 < 2; i3++){\n\t\t\t\t\t\talpha[alpha2Int('c')] = int2Bool(i3);\n\t\t\t\t\t\tfor(int i4 = 0; i4 < 2; i4++){\n\t\t\t\t\t\t\talpha[alpha2Int('d')] = int2Bool(i4);\n\t\t\t\t\t\t\tfor(int i5 = 0; i5 < 2; i5++){\n\t\t\t\t\t\t\t\talpha[alpha2Int('e')] = int2Bool(i5);\n\t\t\t\t\t\t\t\tfor(int i6 = 0; i6 < 2; i6++){\n\t\t\t\t\t\t\t\t\talpha[alpha2Int('f')] = int2Bool(i6);\n\t\t\t\t\t\t\t\t\tfor(int i7 = 0; i7 < 2; i7++){\n\t\t\t\t\t\t\t\t\t\talpha[alpha2Int('g')] = int2Bool(i7);\n\t\t\t\t\t\t\t\t\t\tfor(int i8 = 0; i8 < 2; i8++){\n\t\t\t\t\t\t\t\t\t\t\talpha[alpha2Int('h')] = int2Bool(i8);\n\t\t\t\t\t\t\t\t\t\t\tfor(int i9 = 0; i9 < 2; i9++){\n\t\t\t\t\t\t\t\t\t\t\t\talpha[alpha2Int('i')] = int2Bool(i9);\n\t\t\t\t\t\t\t\t\t\t\t\tfor(int i10 = 0; i10 < 2; i10++){\n\t\t\t\t\t\t\t\t\t\t\t\t\talpha[alpha2Int('j')] = int2Bool(i10);\n\t\t\t\t\t\t\t\t\t\t\t\t\tfor(int i11 = 0; i11 < 2; i11++){\n\t\t\t\t\t\t\t\t\t\t\t\t\t\talpha[alpha2Int('k')] = int2Bool(i11);\n\t\t\t\t\t\t\t\t\t\t\t\t\t\t//System.out.println(\"count = \" + c);\n\t\t\t\t\t\t\t\t\t\t\t\t\t\tc++;\n\t\t\t\t\t\t\t\t\t\t\t\t\t\tp = 0;\n\t\t\t\t\t\t\t\t\t\t\t\t\t\tleft = getNext();\n\t\t\t\t\t\t\t\t\t\t\t\t\t\t//\"=\"&#239;&#8482;&#234;i&#199;&#64258;&#199;&#200;\n\t\t\t\t\t\t\t\t\t\t\t\t\t\tp++;\n\t\t\t\t\t\t\t\t\t\t\t\t\t\t//System.out.println(\"right\");\n\t\t\t\t\t\t\t\t\t\t\t\t\t\tright = getNext();\n\t\t\t\t\t\t\t\t\t\t\t\t\t\t\n\t\t\t\t\t\t\t\t\t\t\t\t\t\tif(left != right){\n\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t//System.out.println(\"a = \" + alpha[alpha2Int('a')] + \", b = \" + alpha[alpha2Int('b')] + \", left = \" + left + \", right = \"  + right);;\n\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t//System.out.println(\"bad\");\n\t\t\t\t\t\t\t\t\t\t\t\t\t\t\tbOK = false;\n\t\t\t\t\t\t\t\t\t\t\t\t\t\t}\n\t\t\t\t\t\t\t\t\t\t\t\t\t\t\n\t\t\t\t\t\t\t\t\t\t\t\t\t}\n\t\t\t\t\t\t\t\t\t\t\t\t}\n\t\t\t\t\t\t\t\t\t\t\t}\n\t\t\t\t\t\t\t\t\t\t}\n\t\t\t\t\t\t\t\t\t}\n\t\t\t\t\t\t\t\t}\n\t\t\t\t\t\t\t}\t\t\t\t\t\n\t\t\t\t\t\t}\t\t\t\t\t\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t}\n\t\t\t\n\t\t\tif(bOK){\n\t\t\t\tSystem.out.println(\"YES\");\n\t\t\t}\n\t\t\telse{\n\t\t\t\tSystem.out.println(\"NO\");\n\t\t\t}\n\t\t\tinput = sc.next();\n\t\t}\n\t}\n\t\n\tpublic static boolean int2Bool(int n){\n\t\tif(n == 0){\n\t\t\treturn false;\n\t\t}\n\t\telse{\n\t\t\treturn true;\n\t\t}\n\t}\n\t\n\tpublic static int alpha2Int(char ch){\n\t\tint num = Character.getNumericValue(ch) - Character.getNumericValue('a');\n\t\treturn num;\n\t}\n\t\n\n\t//1&#199;&#172;&#199;&#195;formula&#199;&#63743;&#232;&#224;&#243;&#249;\n\tpublic static boolean getNext(){\n\t\tboolean bRet = false;\n\t\tchar c = input.charAt(p);\n\t\t//System.out.println(\"getNext : p = \" + p + \", c = \" + c);\n\t\tswitch(c){\n\t\tcase 'T':\n\t\t\tp++;\n\t\t\tbRet = true;\n\t\t\tbreak;\n\t\tcase 'F':\n\t\t\tbRet = false;\n\t\t\tp++;\n\t\t\tbreak;\n\t\tcase 'a':\n\t\tcase 'b':\n\t\tcase 'c':\n\t\tcase 'd':\n\t\tcase 'e':\n\t\tcase 'f':\n\t\tcase 'g':\n\t\tcase 'h':\n\t\tcase 'i':\n\t\tcase 'j':\n\t\tcase 'k':\n\t\t\tbRet = alpha2Bool(c);\n\t\t\tp++;\n\t\t\tbreak;\n\t\tcase '(':\n\t\t\tp++;\n\t\t\tboolean left = getNext();\n\t\t\tboolean right;\n\t\t\tc = input.charAt(p);\n\t\t\tif(c == '*'){\n\t\t\t\tp++;\n\t\t\t\tright = getNext();\n\t\t\t\tbRet = left & right;\n\t\t\t}\n\t\t\telse if(c == '+'){\n\t\t\t\tp++;\n\t\t\t\tright = getNext();\n\t\t\t\tbRet = left | right;\n\t\t\t}\n\t\t\t//case c = ->\n\t\t\telse{\n\t\t\t\tp += 2;\n\t\t\t\tright = getNext();\n\t\t\t\tbRet = Imp(left , right);\n\t\t\t}\n\t\t\t//\")\"&#199;&#8482;&#199;卒&#199;&#402;&#199;&#162;&#199;&#200;&#199;&#213;&#199;&#8719;&#197;I\n\t\t\tp++;\n\t\t\tbreak;\n\n\t\tcase '-':\n\t\t\tp++;\n\t\t\tbRet = getNext();\n\t\t\tbRet = !bRet;\n\t\t\tbreak;\n\t\t}\n\n\t\treturn bRet;\n\t}\n\n\tpublic static boolean alpha2Bool(char ch){\n\t\tint num = Character.getNumericValue(ch) - Character.getNumericValue('a');\n\t\treturn alpha[num];\n\t}\n\n\tpublic static boolean Imp(boolean b1, boolean b2){\n\t\tif(b1 == true && b2 == false){\n\t\t\treturn false;\n\t\t}\n\t\telse{\n\t\t\treturn true;\n\t\t}\n\t}\n}"
  },
  {
    "language": "Java",
    "code": "import java.io.BufferedReader;\nimport java.io.InputStreamReader;\nimport java.io.StreamTokenizer;\nimport java.util.Scanner;\n\npublic class Main {\n\n\tStreamTokenizer parser;\n\n\tabstract class P {\n\t\tabstract boolean getValue();\n\t}\n\n\tclass AND extends P {\n\t\tP left;\n\t\tP right;\n\n\t\tpublic AND(P l, P r) {\n\t\t\tleft = l;\n\t\t\tright = r;\n\t\t}\n\n\t\tboolean getValue() {\n\t\t\treturn left.getValue() && right.getValue();\n\t\t}\n\n\t\tpublic String toString(){\n\t\t\treturn \"(\"+left+\"∧\"+right+\")\";\n\t\t}\n\t}\n\n\tclass OR extends P {\n\t\tP left;\n\t\tP right;\n\n\t\tpublic OR(P l, P r) {\n\t\t\tleft = l;\n\t\t\tright = r;\n\t\t}\n\n\t\tboolean getValue() {\n\t\t\treturn left.getValue() || right.getValue();\n\t\t}\n\t\tpublic String toString(){\n\t\t\treturn \"(\"+left+\"∨\"+right+\")\";\n\t\t}\n\t}\n\n\tclass ARROW extends P {\n\t\tP left;\n\t\tP right;\n\n\t\tpublic ARROW(P l, P r) {\n\t\t\tleft = l;\n\t\t\tright = r;\n\t\t}\n\n\t\tboolean getValue() {\n\t\t\treturn !left.getValue() || right.getValue();\n\t\t}\n\t\tpublic String toString(){\n\t\t\treturn \"(\"+left+\"→\"+right+\")\";\n\t\t}\n\t}\n\n\tclass NOT extends P {\n\t\tP exp;\n\n\t\tpublic NOT(P e) {\n\t\t\tthis.exp = e;\n\t\t}\n\n\t\tboolean getValue() {\n\t\t\treturn !exp.getValue();\n\t\t}\n\t\tpublic String toString(){\n\t\t\treturn \"¬\"+exp;\n\t\t}\n\t}\n\n\tclass PARAM extends P {\n\t\tint hensuu;\n\n\t\tpublic PARAM(int val) {\n\t\t\thensuu = val;\n\t\t}\n\n\t\tboolean getValue() {\n\t\t\treturn bmap[hensuu];\n\t\t}\n\t\tpublic String toString(){\n\t\t\treturn hensuu+\"\";\n\t\t}\n\t}\n\n\tclass TF extends P {\n\t\tboolean b;\n\n\t\tpublic TF(boolean val) {\n\t\t\tb = val;\n\t\t}\n\n\t\tboolean getValue() {\n\t\t\treturn b;\n\t\t}\n\t\tpublic String toString(){\n\t\t\treturn b?\"T\":\"F\";\n\t\t}\n\t}\n\n\tclass EQUAL extends P {\n\t\tP l;\n\t\tP r;\n\n\t\tpublic EQUAL(P le, P ri) {\n\t\t\tl = le;\n\t\t\tr = ri;\n\t\t}\n\n\t\tboolean getValue() {\n\t\t\treturn l.getValue() == r.getValue();\n\t\t}\n\t\tpublic String toString(){\n\t\t\treturn l+\"=\"+r;\n\t\t}\n\t}\n\n\tboolean[] bmap;\n\n\tP l;\n\tboolean isleft;\n\n\tpublic EQUAL eq(String str) {\n\t\tint eq = str.indexOf(\"=\");\n\t\treturn new EQUAL(formula(str.substring(0, eq)), formula(str.substring(\n\t\t\t\teq + 1, str.length())));\n\t}\n\n\tpublic P formula(String str) {\n\t\tif (str.length() == 1) {\n\t\t\tchar c = str.charAt(0);\n\t\t\tif (c == 'T') {\n\t\t\t\treturn new TF(true);\n\t\t\t}\n\t\t\tif (c == 'F') {\n\t\t\t\treturn new TF(false);\n\t\t\t}\n\t\t\tif ('a' <= c && c <= 'k') {\n\t\t\t\treturn new PARAM(c - 'a');\n\t\t\t}\n\t\t}\n\t\t// 区切り点を捜索\n\t\tif (str.charAt(0) == '-') {\n\t\t\tP node = formula(str.substring(1));\n\t\t\treturn new NOT(node);\n\t\t}\n\t\tif (str.charAt(0) == '(') {\n\t\t\tint ca = 0;\n\t\t\tfor (int i = 1;; i++) {\n\t\t\t\tchar c = str.charAt(i);\n\t\t\t\tswitch (c) {\n\t\t\t\tcase '(':\n\t\t\t\t\tca++;\n\t\t\t\t\tbreak;\n\t\t\t\tcase ')':\n\t\t\t\t\tca--;\n\t\t\t\t\tbreak;\n\t\t\t\t}\n\t\t\t\tif (ca > 0) {\n\t\t\t\t\tcontinue;\n\t\t\t\t}\n\t\t\t\tswitch (c) {\n\t\t\t\tcase '+':\n\t\t\t\t\tP l1 = formula(str.substring(1, i));\n\t\t\t\t\tP r1 = formula(str.substring(i + 1, str.length() - 1));\n\t\t\t\t\treturn new OR(l1, r1);\n\t\t\t\tcase '*':\n\t\t\t\t\tP l2 = formula(str.substring(1, i));\n\t\t\t\t\tP r2 = formula(str.substring(i + 1, str.length() - 1));\n\t\t\t\t\treturn new AND(l2, r2);\n\t\t\t\tcase '-':\n\t\t\t\t\tif (str.charAt(i + 1) != '>') {\n\t\t\t\t\t\tbreak;\n\t\t\t\t\t}\n\t\t\t\t\tP l3 = formula(str.substring(1, i));\n\t\t\t\t\tP r3 = formula(str.substring(i + 2, str.length() - 1));\n\t\t\t\t\treturn new ARROW(l3, r3);\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t\treturn null;\n\t}\n\n\tpublic void run() throws Exception {\n\t\tScanner sc = new Scanner(System.in);\n\t\tst = new StreamTokenizer(new BufferedReader(new InputStreamReader(\n\t\t\t\tSystem.in)));\n\n\t\twhile (true) {\n\t\t\tString str = sc.next();\n\t\t\tif (str == \"#\") {\n\t\t\t\tbreak;\n\t\t\t}\n\t\t\tEQUAL eq = eq(str);\n\n\t\t\tboolean res = true;\n\t\t\tbmap = new boolean[11];\n\t\t\tfor (int p = 0; p < (1 << 11); p++) {\n\t\t\t\tfor (int i = 0; i < 11; i++) {\n\t\t\t\t\tbmap[i] = (p / (1 << i)) % 2 == 1;\n\t\t\t\t}\n\t\t\t\tif (!eq.getValue()) {\n\t\t\t\t\tres = false;\n\t\t\t\t\tbreak;\n\t\t\t\t}\n\t\t\t}\n\t\t\tpr(res ? \"YES\" : \"NO\");\n\t\t\t/*\n\t\t\t * if('#'==st.nextToken()){ break; }\n\t\t\t */\n\t\t\t// isleft=true;\n\t\t\t// st.pushBack();\n\t\t\tformula(str);\n\t\t}\n\t}\n\n\tpublic static void main(String[] _) throws Exception {\n\t\tnew Main().run();\n\t}\n\n\tpublic static void pr(Object o) {\n\t\tSystem.out.println(o);\n\t}\n\n\tStreamTokenizer st;\n}"
  },
  {
    "language": "Java",
    "code": "import java.util.*;\n\npublic class Main{\n    static String solve(String s){\n        while(s.length() != 1){\n            s = s.replaceAll(\"\\\\(F\\\\+F\\\\)\", \"F\");\n            s = s.replaceAll(\"\\\\(F\\\\+T\\\\)\", \"T\");\n            s = s.replaceAll(\"\\\\(T\\\\+F\\\\)\", \"T\");\n            s = s.replaceAll(\"\\\\(T\\\\+T\\\\)\", \"T\");\n\n            s = s.replaceAll(\"\\\\(F\\\\*F\\\\)\", \"F\");\n            s = s.replaceAll(\"\\\\(F\\\\*T\\\\)\", \"F\");\n            s = s.replaceAll(\"\\\\(T\\\\*F\\\\)\", \"F\");\n            s = s.replaceAll(\"\\\\(T\\\\*T\\\\)\", \"T\");\n\n            s = s.replaceAll(\"\\\\(F\\\\->F\\\\)\", \"T\");\n            s = s.replaceAll(\"\\\\(F\\\\->T\\\\)\", \"T\");\n            s = s.replaceAll(\"\\\\(T\\\\->F\\\\)\", \"F\");\n            s = s.replaceAll(\"\\\\(T\\\\->T\\\\)\", \"T\");\n\n            s = s.replaceAll(\"\\\\-T\", \"F\");\n            s = s.replaceAll(\"\\\\-F\", \"T\");\n        }\n        return s;\n    }\n\n    public static void main(String[] args){\n        Scanner sc = new Scanner(System.in);\n\n        while(true){\n            String ts = sc.next();\n            if(ts.equals(\"#\")) break;\n\n            String[] s = ts.split(\"=\");\n            boolean flg = true;\n\n            for(int bit = 0; bit < (1 << 11); bit++){\n                String L = s[0];\n                String R = s[1];\n\n                for(int j = 0; j < 11; j++){\n                    String tmp = \"\" + (char)('a' + j);\n\n                    if((bit & (1 << j)) != 0){\n                        L = L.replaceAll(tmp, \"T\");\n                        R = R.replaceAll(tmp, \"T\");\n                    }\n                    else{\n                        L = L.replaceAll(tmp, \"F\");\n                        R = R.replaceAll(tmp, \"F\");\n                    }\n                }\n\n                String ansL = solve(L);\n                String ansR = solve(R);\n\n                if(!ansL.equals(ansR)){\n                    flg = false;\n                    break;\n                }\n            }\n\n            if(flg){\n                System.out.println(\"YES\");\n            }\n            else{\n                System.out.println(\"NO\");\n            }\n        }\n    }\n}"
  },
  {
    "language": "Java",
    "code": "import java.io.PrintWriter;\nimport java.util.*;\n\npublic class Main {\n    public static void main(String[] args) {\n        Scanner in = new Scanner(System.in);\n        PrintWriter out = new PrintWriter(System.out);\n\n        String token = in.next();\n        while (!\"#\".equals(token)) {\n            String[] tokens = token.replace(\"->\", \">\").split(\"=\");\n            AST left = AST.parse(tokens[0]), right = AST.parse(tokens[1]);\n            boolean eq = true;\n            for (int i = 0; i < (1 << 11); i++) {\n                if (left.eval(i) != right.eval(i)) {\n                    eq = false;\n                }\n            }\n            out.println(eq ? \"YES\" : \"NO\");\n\n            token = in.next();\n        }\n\n        out.flush();\n    }\n\n    static abstract class AST {\n        abstract boolean eval(int var);\n\n        static AST parse(String token) {\n            int start = 0;\n            while (token.charAt(start) == '-') start++;\n            boolean neg = start % 2 == 1;\n\n            if (token.length() - start == 1) {\n                AST res;\n                char c = token.charAt(token.length() - 1);\n                if (Character.isUpperCase(c)) {\n                    res = new ConstantToken(c == 'T');\n                } else {\n                    res = new VariableToken(c - 'a');\n                }\n                if (neg) {\n                    return new NegativeToken(res);\n                }\n                return res;\n            }\n\n            if (token.charAt(start) != '(' || token.charAt(token.length() - 1) != ')') {\n                throw new RuntimeException(\"Assertion Failed: \" + token);\n            }\n            start++;\n\n\n            int depth = 0, center = -1;\n            for (int i = start; i < token.length() - 1; i++) {\n                char c = token.charAt(i);\n                if (c == '(') {\n                    depth++;\n                } else if (c == ')') {\n                    depth--;\n                } else if (depth == 0 && (c == '+' || c == '*' || c == '>')) {\n                    center = i;\n                }\n            }\n\n            AST left = AST.parse(token.substring(start, center));\n            AST right = AST.parse(token.substring(center + 1, token.length() - 1));\n            AST res;\n            switch (token.charAt(center)) {\n                case '*':\n                    res = new AndToken(left, right);\n                    break;\n                case '>':\n                    res = new RightarrowToken(left, right);\n                    break;\n                case '+':\n                    res = new OrToken(left, right);\n                    break;\n                default:\n                    throw new RuntimeException();\n            }\n            if (neg) {\n                return new NegativeToken(res);\n            }\n            return res;\n        }\n    }\n\n    static class ConstantToken extends AST {\n        boolean value;\n\n        ConstantToken(boolean value) {\n            this.value = value;\n        }\n\n        @Override\n        boolean eval(int var) {\n            return value;\n        }\n    }\n\n    static class VariableToken extends AST {\n        int index;\n\n        VariableToken(int index) {\n            this.index = index;\n        }\n\n        @Override\n        boolean eval(int var) {\n            return ((var >> index) & 1) == 1;\n        }\n    }\n\n    static class NegativeToken extends AST {\n        AST content;\n\n        NegativeToken(AST content) {\n            this.content = content;\n        }\n\n        @Override\n        boolean eval(int var) {\n            return !content.eval(var);\n        }\n    }\n\n    static class AndToken extends AST {\n        AST left, right;\n\n        AndToken(AST left, AST right) {\n            this.left = left;\n            this.right = right;\n        }\n\n        @Override\n        boolean eval(int var) {\n            return left.eval(var) && right.eval(var);\n        }\n    }\n\n    static class OrToken extends AST {\n        AST left, right;\n\n        OrToken(AST left, AST right) {\n            this.left = left;\n            this.right = right;\n        }\n\n        @Override\n        boolean eval(int var) {\n            return left.eval(var) || right.eval(var);\n        }\n    }\n\n    static class RightarrowToken extends AST {\n        AST left, right;\n\n        RightarrowToken(AST left, AST right) {\n            this.left = left;\n            this.right = right;\n        }\n\n        @Override\n        boolean eval(int var) {\n            return !left.eval(var) || right.eval(var);\n        }\n    }\n}\n\n"
  },
  {
    "language": "Java",
    "code": "import java.util.Scanner;\n\n//Equation\npublic class Main{\n\n\tboolean[] assign;\n\tchar[] s;\n\tint idx;\n\tchar get(){\n\t\treturn s[idx++];\n\t}\n\t\n\tString s1, s2;\n\t\n\tboolean f(int k){\n\t\tif(k==11){\n\t\t\ts = s1.toCharArray();\n\t\t\tidx = 0;\n\t\t\tboolean f1 = formula();\n\t\t\ts = s2.toCharArray();\n\t\t\tidx = 0;\n\t\t\treturn f1==formula();\n\t\t}\n\t\tassign[k] = false;\n\t\tif(!f(k+1))return false;\n\t\tassign[k] = true;\n\t\treturn f(k+1);\n\t}\n\t\n\tboolean formula(){\n\t\tchar ch = get();\n\t\tif(ch=='('){\n\t\t\tboolean f1 = formula();\n\t\t\tch = get();\n\t\t\tif(ch=='*'){\n\t\t\t\tboolean f2 = formula();\n\t\t\t\tget();\n\t\t\t\treturn f1&&f2;\n\t\t\t}\n\t\t\telse if(ch=='+'){\n\t\t\t\tboolean f2 = formula();\n\t\t\t\tget();\n\t\t\t\treturn f1||f2;\n\t\t\t}\n\t\t\telse{\n\t\t\t\tget();\n\t\t\t\tboolean f2 = formula();\n\t\t\t\tget();\n\t\t\t\treturn !f1||f2;\n\t\t\t}\n\t\t}\n\t\telse if(ch=='-'){\n\t\t\treturn !formula();\n\t\t}\n\t\telse if(ch=='T'){\n\t\t\treturn true;\n\t\t}\n\t\telse if(ch=='F'){\n\t\t\treturn false;\n\t\t}\n\t\telse return assign[ch-'a'];\n\t}\n\t\n\tvoid run(){\n\t\tScanner sc = new Scanner(System.in);\n\t\tassign = new boolean[11];\n\t\tfor(;;){\n\t\t\tString t = sc.next();\n\t\t\tif(\"#\".equals(t))break;\n\t\t\tString[] tt = t.split(\"=\");\n\t\t\ts1 = tt[0]+\"$\"; s2 = tt[1]+\"$\";\n\t\t\tSystem.out.println(f(0)?\"YES\":\"NO\");\n\t\t}\n\t}\n\t\n\tpublic static void main(String[] args) {\n\t\tnew Main().run();\n\t}\n}"
  },
  {
    "language": "Java",
    "code": "import java.util.Scanner;\n\npublic class Main {\n\tprivate static final String[] vars = { \"a\", \"b\", \"c\", \"d\", \"e\", \"f\", \"g\", \"h\", \"i\", \"j\", \"k\" };\n\n\tpublic static void main(String[] args) {\n\t\tScanner sc = new Scanner(System.in);\n\t\twhile (true) {\n\t\t\tString line = sc.next();\n\t\t\tif (line.equals(\"#\")) {\n\t\t\t\tsc.close();\n\t\t\t\tbreak;\n\t\t\t}\n\n\t\t\tboolean yes = true;\n\t\t\tfor (int bit = 0; bit < (1 << vars.length); bit++) {\n\t\t\t\tString check = line;\n\t\t\t\tfor (int j = 0; j < vars.length; j++) {\n\t\t\t\t\tString replace = \"F\";\n\t\t\t\t\tif ((bit & (1 << j)) != 0) {\n\t\t\t\t\t\treplace = \"T\";\n\t\t\t\t\t}\n\t\t\t\t\tcheck = check.replaceAll(vars[j], replace);\n\t\t\t\t}\n\t\t\t\tint length = check.length();\n\t\t\t\twhile (true) {\n\t\t\t\t\tcheck = check.replaceAll(\"\\\\-T\", \"F\");\n\t\t\t\t\tcheck = check.replaceAll(\"\\\\-F\", \"T\");\n\t\t\t\t\tcheck = check.replaceAll(\"\\\\(T\\\\*T\\\\)\", \"T\");\n\t\t\t\t\tcheck = check.replaceAll(\"\\\\(F\\\\*[TF]\\\\)\", \"F\");\n\t\t\t\t\tcheck = check.replaceAll(\"\\\\([TF]\\\\*F\\\\)\", \"F\");\n\t\t\t\t\tcheck = check.replaceAll(\"\\\\(F\\\\+F\\\\)\", \"F\");\n\t\t\t\t\tcheck = check.replaceAll(\"\\\\([TF]\\\\+T\\\\)\", \"T\");\n\t\t\t\t\tcheck = check.replaceAll(\"\\\\(T\\\\+[TF]\\\\)\", \"T\");\n\t\t\t\t\tcheck = check.replaceAll(\"\\\\(T\\\\-\\\\>F\\\\)\", \"F\");\n\t\t\t\t\tcheck = check.replaceAll(\"\\\\(T\\\\-\\\\>T\\\\)\", \"T\");\n\t\t\t\t\tcheck = check.replaceAll(\"\\\\(F\\\\-\\\\>[TF]\\\\)\", \"T\");\n\t\t\t\t\tif (check.length() == length) {\n\t\t\t\t\t\tbreak;\n\t\t\t\t\t}\n\t\t\t\t\tlength = check.length();\n\t\t\t\t}\n\t\t\t\tif (check.equals(\"F=T\") || check.equals(\"T=F\")) {\n\t\t\t\t\tSystem.out.println(\"NO\");\n\t\t\t\t\tyes = false;\n\t\t\t\t\tbreak;\n\t\t\t\t}\n\t\t\t}\n\t\t\tif (yes) {\n\t\t\t\tSystem.out.println(\"YES\");\n\t\t\t}\n\n\t\t}\n\n\t}\n}"
  },
  {
    "language": "Java",
    "code": "import java.util.Scanner;\n\npublic class Main {\n\tprivate static final String[] vars = { \"a\", \"b\", \"c\", \"d\", \"e\", \"f\", \"g\", \"h\", \"i\", \"j\", \"k\" };\n\n\tpublic static void main(String[] args) {\n\t\tScanner sc = new Scanner(System.in);\n\t\twhile (true) {\n\t\t\tString line = sc.next();\n\t\t\tif (line.equals(\"#\")) {\n\t\t\t\tsc.close();\n\t\t\t\tbreak;\n\t\t\t}\n\n\t\t\tboolean yes = true;\n\t\t\tfor (int bit = 0; bit < (1 << vars.length); bit++) {\n\t\t\t\tString check = line;\n\t\t\t\tfor (int j = 0; j < vars.length; j++) {\n\t\t\t\t\tString replace = \"F\";\n\t\t\t\t\tif ((bit & (1 << j)) != 0) {\n\t\t\t\t\t\treplace = \"T\";\n\t\t\t\t\t}\n\t\t\t\t\tcheck = check.replaceAll(vars[j], replace);\n\t\t\t\t}\n\t\t\t\tint length = check.length();\n\t\t\t\twhile (true) {\n\t\t\t\t\tcheck = check.replaceAll(\"\\\\-T\", \"F\");\n\t\t\t\t\tcheck = check.replaceAll(\"\\\\-F\", \"T\");\n\t\t\t\t\tcheck = check.replaceAll(\"\\\\(T\\\\*T\\\\)\", \"T\");\n\t\t\t\t\tcheck = check.replaceAll(\"\\\\(F\\\\*[TF]\\\\)\", \"F\");\n\t\t\t\t\tcheck = check.replaceAll(\"\\\\([TF]\\\\*F\\\\)\", \"F\");\n\t\t\t\t\tcheck = check.replaceAll(\"\\\\(F\\\\+F\\\\)\", \"F\");\n\t\t\t\t\tcheck = check.replaceAll(\"\\\\([TF]\\\\+T\\\\)\", \"T\");\n\t\t\t\t\tcheck = check.replaceAll(\"\\\\(T\\\\+[TF]\\\\)\", \"T\");\n\t\t\t\t\tcheck = check.replaceAll(\"\\\\(T\\\\-\\\\>F\\\\)\", \"F\");\n\t\t\t\t\tcheck = check.replaceAll(\"\\\\(T\\\\-\\\\>T\\\\)\", \"T\");\n\t\t\t\t\tcheck = check.replaceAll(\"\\\\(F\\\\-\\\\>[TF]\\\\)\", \"T\");\n\t\t\t\t\tif (check.length() == length) {\n\t\t\t\t\t\tbreak;\n\t\t\t\t\t}\n\t\t\t\t\tlength = check.length();\n\t\t\t\t}\n\t\t\t\tif (check.equals(\"F=T\") || check.equals(\"T=F\")) {\n\t\t\t\t\tSystem.out.println(\"NO\");\n\t\t\t\t\tyes = false;\n\t\t\t\t\tbreak;\n\t\t\t\t}\n\t\t\t}\n\t\t\tif (yes) {\n\t\t\t\tSystem.out.println(\"YES\");\n\t\t\t}\n\t\t\tSystem.gc();\n\t\t}\n\n\t}\n}"
  },
  {
    "language": "Java",
    "code": "import java.util.Scanner;\n\npublic class Main {\n\n\tpublic static void main(String[] args) {\n\t\tScanner sc = new Scanner(System.in);\n\t\twhile(true) {\n\t\t\tString s = sc.next();\n\t\t\tif (s.equals(\"#\")) {\n\t\t\t\tbreak;\n\t\t\t}\n\t\t\tif (isEquation(s)) {\n\t\t\t\tSystem.out.println(\"YES\");\n\t\t\t}else{\n\t\t\t\tSystem.out.println(\"NO\");\n\t\t\t}\n\t\t}\n\t}\n\n\tpublic static boolean isEquation(String s) {\n\t\tfor(int i=0;i<(1<<11);i++) {\n\t\t\tString s2 = String.valueOf(s);\n\t\t\tfor(int j=0;j<11;j++) {\n\t\t\t\tif ((i&(1<<j))>0) {\n\t\t\t\t\ts2 = s2.replaceAll(String.valueOf((char) ('a'+j)), \"T\");\n\t\t\t\t}else{\n\t\t\t\t\ts2 = s2.replaceAll(String.valueOf((char) ('a'+j)), \"F\");\n\t\t\t\t}\n\t\t\t}\n\t\t\tString[] exp = s2.split(\"=\");\n\t\t\tif (evaluate(exp[0])!=evaluate(exp[1])) {\n\t\t\t\treturn false;\n\t\t\t}\n\t\t}\n\t\treturn true;\n\t}\n\n\tpublic static int index = 0;\n\tpublic static boolean evaluate(String s) {\n\t\tindex = 0;\n\t\tboolean ret = expression(s);\n\t\treturn ret;\n\t}\n\n\tpublic static boolean expression(String s) {\n\t\tchar c = s.charAt(index);\n\t\tif (c == 'T' || c == 'F') {\n\t\t\tindex++;\n\t\t\treturn c == 'T';\n\t\t}\n\t\tif (c == '-') {\n\t\t\tindex++;\n\t\t\treturn !expression(s);\n\t\t}\n\t\tif (c == '(') {\n\t\t\tindex++;\n\t\t\tboolean temp = term(s);\n\t\t\tindex++;\n\t\t\treturn temp;\n\t\t}\n\t\treturn false;\n\t}\n\n\tpublic static boolean term(String s) {\n\t\tboolean first = expression(s);\n\t\tchar c = s.charAt(index);\n\t\tindex += c == '-' ? 2 : 1;\n\t\tboolean second = expression(s);\n\t\tif (c == '*') {\n\t\t\treturn first && second;\n\t\t}else if(c == '+') {\n\t\t\treturn first || second;\n\t\t}else{\n\t\t\treturn !(first && !second);\n\t\t}\n\t}\n\n}"
  },
  {
    "language": "Java",
    "code": "import java.util.Scanner;\nimport java.util.regex.Pattern;\n\npublic class Main {\n public static void main(String[] args) {\n\tScanner in = new Scanner(System.in);\n\tString str=in.nextLine();\n\tdo {\n\t String[] lr = str.split(\"=\");\n\t Formula left = Formula.of(lr[0]);\n\t Formula right = Formula.of(lr[1]);\n\t int max = Integer.parseInt(\"11111111111\", 2);\n\t boolean isYes = true;\n\t for (int i = 0; i <= max && isYes; i++) {\n\t\tisYes = left.getAns(i) == right.getAns(i);\n\t }\n\t System.out.println(isYes ? \"YES\" : \"NO\");\n\t str = in.nextLine();\n\t} while (!\"#\".equals(str));\n }\n}\n\nabstract class Formula {\n static final Pattern PATTERN =\n\t                              Pattern\n\t                                .compile(\"^\\\\((.+)\\\\)$\");\n\n abstract boolean getAns(int bools);\n\n public static Formula of(String string) {\n\tif (\"T\".equals(string)) { return Teisu.T; }\n\tif (\"F\".equals(string)) { return Teisu.F; }\n\tif (\"a\".equals(string)) { return Var.a; }\n\tif (\"b\".equals(string)) { return Var.b; }\n\tif (\"c\".equals(string)) { return Var.c; }\n\tif (\"d\".equals(string)) { return Var.d; }\n\tif (\"e\".equals(string)) { return Var.e; }\n\tif (\"f\".equals(string)) { return Var.f; }\n\tif (\"g\".equals(string)) { return Var.g; }\n\tif (\"h\".equals(string)) { return Var.h; }\n\tif (\"i\".equals(string)) { return Var.i; }\n\tif (string.startsWith(\"-\")) {\n\t Not n = new Not(of(string.substring(1)));\n\t return n;\n\t}\n\tString f1 = null;\n\tString f2 = null;\n\tString op = null;\n\tStringBuilder sb = new StringBuilder();\n\tint kakko = 0;\n\tint posi = 1;\n\twhile (posi < string.length() - 1) {\n\t char c = string.charAt(posi++);\n\t if (c == '(') {\n\t\tkakko++;\n\t } else if (c == ')') {\n\t\tkakko--;\n\t }\n\t if (kakko == 0) {\n\t\tif (c == '+' || c == '*') {\n\t\t op = (c == '+') ? \"+\" : \"*\";\n\t\t f1 = sb.toString();\n\t\t sb.setLength(0);\n\t\t} else if (c == '-' && string.charAt(posi) == '>') {\n\t\t posi++;\n\t\t op = \"->\";\n\t\t f1 = sb.toString();\n\t\t sb.setLength(0);\n\t\t}else{\n\t\t sb.append(c);\n\t\t}\n\t } else {\n\t\tsb.append(c);\n\t }\n\t}\n\tf2 = sb.toString();\n\treturn new Ope(of(f1), op, of(f2));\n\n }\n\n}\n\nclass Teisu extends Formula {\n final boolean      bool;\n static final Teisu T = new Teisu(true);\n static final Teisu F = new Teisu(false);\n\n Teisu(boolean bool) {\n\tthis.bool = bool;\n }\n\n @Override\n boolean getAns(int bools) {\n\treturn bool;\n }\n}\n\nclass Var extends Formula {\n static final Var a = new Var(1);\n static final Var b = new Var(2);\n static final Var c = new Var(4);\n static final Var d = new Var(8);\n static final Var e = new Var(16);\n static final Var f = new Var(32);\n static final Var g = new Var(64);\n static final Var h = new Var(128);\n static final Var i = new Var(256);\n final int        var;\n\n Var(int var) {\n\tthis.var = var;\n }\n\n @Override\n boolean getAns(int bools) {\n\treturn var == (var & bools);\n }\n}\n\nclass Not extends Formula {\n final Formula f;\n\n Not(Formula f) {\n\tthis.f = f;\n }\n\n @Override\n boolean getAns(int bools) {\n\treturn !f.getAns(bools);\n }\n}\n\nclass Ope extends Formula {\n final Formula f1;\n final Formula f2;\n final String  op;\n\n Ope(Formula f1, String op, Formula f2) {\n\tthis.f1 = f1;\n\tthis.f2 = f2;\n\tthis.op = op;\n }\n\n @Override\n boolean getAns(int bools) {\n\tboolean result;\n\tif (\"*\".equals(op)) {\n\t result = f1.getAns(bools) && f2.getAns(bools);\n\t} else if (\"+\".equals(op)) {\n\t result = f1.getAns(bools) || f2.getAns(bools);\n\t} else {\n\t result = f1.getAns(bools) == false || f2.getAns(bools) == true;\n\t}\n\treturn result;\n }\n\n}"
  },
  {
    "language": "Java",
    "code": "\nimport java.io.*;\nimport java.util.*;\n\npublic class Main {\n\tFastScanner in = new FastScanner(System.in);\n\tPrintWriter out = new PrintWriter(System.out);\n\n\tString s;\n\tint idx;\n\t\n\tboolean parse(int next) {\n\t\tchar c = s.charAt(idx++);\n\t\tswitch (c) {\n\t\tcase 'T': return true;\n\t\tcase 'F': return false;\n\t\tcase '-':\n\t\t\treturn !parse(next);\n\t\tcase '(':\n\t\t\tboolean b1 = parse(next);\n\t\t\tchar c2 = s.charAt(idx++);\n\t\t\tboolean b2;\n\t\t\tswitch (c2) {\n\t\t\tcase '*':\n\t\t\t\tb2 = parse(next);\n\t\t\t\tidx++;\n\t\t\t\treturn b1 && b2;\n\t\t\tcase '+':\n\t\t\t\tb2 = parse(next);\n\t\t\t\tidx++;\n\t\t\t\treturn b1 || b2;\n\t\t\tcase '-':\n\t\t\t\tidx++;\n\t\t\t\tb2 = parse(next);\n\t\t\t\tidx++;\n\t\t\t\treturn !b1 || b2;\n\t\t\t}\n\t\tdefault:\n\t\t\tif ((next >> (c - 'a') & 1) == 0) \n\t\t\t\treturn true;\n\t\t\telse\n\t\t\t\treturn false;\n\t\t}\n\t}\n\t\n\tpublic void run() {\n\t\tloop : while (true) {\n\t\t\ts = in.next();\n\t\t\tidx = 0;\n\t\t\tif (s.matches(\"#\")) break;\n\t\t\t\n\t\t\tfor (int i = 0; i < (1 << 10); i++) {\n\t\t\t\tidx = 0;\n\t\t\t\tboolean b1 = parse(i);\n\t\t\t\tidx++;\n\t\t\t\tboolean b2 = parse(i);\n\t\t\t\tif (b1 != b2) {\n\t\t\t\t\tSystem.out.println(\"NO\");\n\t\t\t\t\tcontinue loop;\n\t\t\t\t}\n\t\t\t}\n\t\t\tSystem.out.println(\"YES\");\n\t\t}\n\t\tout.close();\n\t}\n\n\tpublic static void main(String[] args) {\n\t\tnew Main().run();\n\t}\n\n\tpublic void mapDebug(int[][] a) {\n\t\tSystem.out.println(\"--------map display---------\");\n\n\t\tfor (int i = 0; i < a.length; i++) {\n\t\t\tfor (int j = 0; j < a[i].length; j++) {\n\t\t\t\tSystem.out.printf(\"%3d \", a[i][j]);\n\t\t\t}\n\t\t\tSystem.out.println();\n\t\t}\n\n\t\tSystem.out.println(\"----------------------------\");\n\t\tSystem.out.println();\n\t}\n\n\tpublic void debug(Object... obj) {\n\t\tSystem.out.println(Arrays.deepToString(obj));\n\t}\n\n\tclass FastScanner {\n\t\tprivate InputStream stream;\n\t\tprivate byte[] buf = new byte[1024];\n\t\tprivate int curChar;\n\t\tprivate int numChars;\n\n\t\tpublic FastScanner(InputStream stream) {\n\t\t\tthis.stream = stream;\n\t\t\t//stream = new FileInputStream(new File(\"dec.in\"));\n\n\t\t}\n\n\t\tint read() {\n\t\t\tif (numChars == -1)\n\t\t\t\tthrow new InputMismatchException();\n\t\t\tif (curChar >= numChars) {\n\t\t\t\tcurChar = 0;\n\t\t\t\ttry {\n\t\t\t\t\tnumChars = stream.read(buf);\n\t\t\t\t} catch (IOException e) {\n\t\t\t\t\tthrow new InputMismatchException();\n\t\t\t\t}\n\t\t\t\tif (numChars <= 0)\n\t\t\t\t\treturn -1;\n\t\t\t}\n\t\t\treturn buf[curChar++];\n\t\t}\n\n\t\tboolean isSpaceChar(int c) {\n\t\t\treturn c == ' ' || c == '\\n' || c == '\\r' || c == '\\t' || c == -1;\n\t\t}\n\n\t\tboolean isEndline(int c) {\n\t\t\treturn c == '\\n' || c == '\\r' || c == -1;\n\t\t}\n\n\t\tint nextInt() {\n\t\t\treturn Integer.parseInt(next());\n\t\t}\n\n\t\tlong nextLong() {\n\t\t\treturn Long.parseLong(next());\n\t\t}\n\n\t\tdouble nextDouble() {\n\t\t\treturn Double.parseDouble(next());\n\t\t}\n\n\t\tString next() {\n\t\t\tint c = read();\n\t\t\twhile (isSpaceChar(c))\n\t\t\t\tc = read();\n\t\t\tStringBuilder res = new StringBuilder();\n\t\t\tdo {\n\t\t\t\tres.appendCodePoint(c);\n\t\t\t\tc = read();\n\t\t\t} while (!isSpaceChar(c));\n\t\t\treturn res.toString();\n\t\t}\n\n\t\tString nextLine() {\n\t\t\tint c = read();\n\t\t\twhile (isEndline(c))\n\t\t\t\tc = read();\n\t\t\tStringBuilder res = new StringBuilder();\n\t\t\tdo {\n\t\t\t\tres.appendCodePoint(c);\n\t\t\t\tc = read();\n\t\t\t} while (!isEndline(c));\n\t\t\treturn res.toString();\n\t\t}\n\t}\n}"
  },
  {
    "language": "Java",
    "code": "import java.util.Scanner;\n\npublic class Main {\n\tpublic static String input;\n\tpublic static int p;\n\tpublic static int len;\n\tpublic static boolean[] alpha = new boolean[11];\n\tpublic static void main(String[] args){\n\t\tdoIt();\n\t\t//test();\n\t}\n\t\n//\tpublic static void test(){\n//\t\tint a = 0;\n//\t\tSystem.out.println(Character.getNumericValue('a'));\n//\t\tSystem.out.println(Character.getNumericValue('b'));\n//\t}\n\t\n\n//\tpublic static void print(int bit){\n//\t\tfor(int i = 0; i < 11; i++){\n//\t\t\tint t = bit >> i;\n//\t\t\tt &= 1;\n//\t\t\tSystem.out.print(t);\n//\t\t}\n//\t\tSystem.out.println(\"\");\n//\t}\n\t\n\tpublic static void doIt(){\n\t\tScanner sc = new Scanner(System.in);\n\t\tinput = sc.next();\n\t\twhile(input.equals(\"#\") == false){\n\t\t\tlen = input.length();\n\t\t\tp = 0;\n\t\t\tboolean left;\n\t\t\tboolean right;\n\t\t\tboolean bOK = true;\n\t\t\t//int c = 0;\n\t\t\tint bit = 0;\n\t\t\t\n\t\t\t//2^(11) - 1までやる\n\t\t\tfor(int i = 0; i < 0x800; i++){\n\t\t\t\t//print(bit);\n\t\t\t\t//c++;\n\t\t\t\tfor(int j = 0; j < 11; j++){\n\t\t\t\t\talpha[j] = bit2Bool(bit, j);\n\t\t\t\t}\n\t\t\t\tp = 0;\n\t\t\t\tleft = getNext();\n\t\t\t\tp++;\n\t\t\t\t//System.out.println(\"right\");\n\t\t\t\tright = getNext();\n\t\t\t\t\n\t\t\t\tif(left != right){\n\t\t\t\t\t//System.out.println(\"a = \" + alpha[alpha2Int('a')] + \", b = \" + alpha[alpha2Int('b')] + \", left = \" + left + \", right = \"  + right);;\n\t\t\t\t\t//System.out.println(\"bad\");\n\t\t\t\t\tbOK = false;\n\t\t\t\t}\n\t\t\t\tbit++;\n\t\t\t}\n\t\t\t//System.out.println(c);\n\t\t\t\n\t\t\tif(bOK){\n\t\t\t\tSystem.out.println(\"YES\");\n\t\t\t}\n\t\t\telse{\n\t\t\t\tSystem.out.println(\"NO\");\n\t\t\t}\n\t\t\tinput = sc.next();\n\t\t}\n\t}\n\t\n\t//numのbit目のビットが立っていればtrue\n\tpublic static boolean bit2Bool(int num, int bit){\n\t\tint tmp = num >> bit;\n\t\ttmp &= 1;\n\t\tif(tmp == 1){\n\t\t\treturn true;\n\t\t}\n\t\telse{\n\t\t\treturn false;\n\t\t}\n\t}\n\n\tpublic static boolean getNext(){\n\t\tboolean bRet = false;\n\t\tchar c = input.charAt(p);\n\t\t//System.out.println(\"getNext : p = \" + p + \", c = \" + c);\n\t\tswitch(c){\n\t\tcase 'T':\n\t\t\tp++;\n\t\t\tbRet = true;\n\t\t\tbreak;\n\t\tcase 'F':\n\t\t\tbRet = false;\n\t\t\tp++;\n\t\t\tbreak;\n\t\tcase 'a':\n\t\tcase 'b':\n\t\tcase 'c':\n\t\tcase 'd':\n\t\tcase 'e':\n\t\tcase 'f':\n\t\tcase 'g':\n\t\tcase 'h':\n\t\tcase 'i':\n\t\tcase 'j':\n\t\tcase 'k':\n\t\t\tbRet = alpha2Bool(c);\n\t\t\tp++;\n\t\t\tbreak;\n\t\tcase '(':\n\t\t\tp++;\n\t\t\tboolean left = getNext();\n\t\t\tboolean right;\n\t\t\tc = input.charAt(p);\n\t\t\tif(c == '*'){\n\t\t\t\tp++;\n\t\t\t\tright = getNext();\n\t\t\t\tbRet = left & right;\n\t\t\t}\n\t\t\telse if(c == '+'){\n\t\t\t\tp++;\n\t\t\t\tright = getNext();\n\t\t\t\tbRet = left | right;\n\t\t\t}\n\t\t\t//case c = ->\n\t\t\telse{\n\t\t\t\tp += 2;\n\t\t\t\tright = getNext();\n\t\t\t\tbRet = Imp(left , right);\n\t\t\t}\n\t\t\tp++;\n\t\t\tbreak;\n\n\t\tcase '-':\n\t\t\tp++;\n\t\t\tbRet = getNext();\n\t\t\tbRet = !bRet;\n\t\t\tbreak;\n\t\t}\n\n\t\treturn bRet;\n\t}\n\n\tpublic static boolean alpha2Bool(char ch){\n\t\tint num = Character.getNumericValue(ch) - Character.getNumericValue('a');\n\t\treturn alpha[num];\n\t}\n\n\tpublic static boolean Imp(boolean b1, boolean b2){\n\t\tif(b1 == true && b2 == false){\n\t\t\treturn false;\n\t\t}\n\t\telse{\n\t\t\treturn true;\n\t\t}\n\t}\n}"
  },
  {
    "language": "Java",
    "code": "import java.util.*;\nimport static java.lang.System.*;\n\npublic class Main {\n\n\tScanner sc = new Scanner(in);\n\t\n\tchar[] eq;\n\tchar[] eq1, eq2;\n\tboolean[] as = new boolean[11];\n\tboolean[] check = new boolean[11];\n\t\n\tboolean flag;\n\tvoid calc(int depth) {\n\t\tif (depth == 11) {\n\t\t\tboolean a, b;\n\t\t\teq = eq1;\n\t\t\tindex = 0;\n\t\t\ta = F();\n\t\t\teq = eq2;\n\t\t\tindex = 0;\n\t\t\tb = F();\n\t\t\tif (a != b)\n\t\t\t\tflag = false;\n\t\t} else {\n\t\t\tif (flag) {\n\t\t\t\tas[depth] = false;\n\t\t\t\tcalc(depth+1);\n\t\t\t\tas[depth] = true;\n\t\t\t\tcalc(depth+1);\n\t\t\t}\n\t\t}\n\t}\n\t\n\tint index;\n\tint token;\n\tfinal int VAL = -1;\n\tboolean value;\n\tvoid gettoken() {\n\t\tchar ch = eq[index++];\n\t\tif (ch == '+' || ch == '*' || ch == '(' || ch == ')') {\n\t\t\ttoken = ch;\n\t\t\treturn;\n\t\t} else if (ch == '-') {\n\t\t\tif (eq[index] == '>') {\n\t\t\t\tindex++;\n\t\t\t\ttoken = '>';\n\t\t\t\treturn;\n\t\t\t} else {\n\t\t\t\ttoken = ch;\n\t\t\t\treturn;\n\t\t\t}\n\t\t} else {\n\t\t\ttoken = VAL;\n\t\t\tswitch(ch) {\n\t\t\tcase 'T':\n\t\t\t\tvalue = true; break;\n\t\t\tcase 'F':\n\t\t\t\tvalue = false; break;\n\t\t\tcase 'a':\n\t\t\t\tvalue = as[0]; break;\n\t\t\tcase 'b':\n\t\t\t\tvalue = as[1]; break;\n\t\t\tcase 'c':\n\t\t\t\tvalue = as[2]; break;\n\t\t\tcase 'd':\n\t\t\t\tvalue = as[3]; break;\n\t\t\tcase 'e':\n\t\t\t\tvalue = as[4]; break;\n\t\t\tcase 'f':\n\t\t\t\tvalue = as[5]; break;\n\t\t\tcase 'g':\n\t\t\t\tvalue = as[6]; break;\n\t\t\tcase 'h':\n\t\t\t\tvalue = as[7]; break;\n\t\t\tcase 'i':\n\t\t\t\tvalue = as[8]; break;\n\t\t\tcase 'j':\n\t\t\t\tvalue = as[9]; break;\n\t\t\tcase 'k':\n\t\t\t\tvalue = as[10]; break;\n\t\t\t}\n\t\t}\n\t}\n\t\n\tboolean F() {\n\t\tboolean v, vnext;\n\t\tint savetoken;\n\t\tgettoken();\n\t\tif (token == VAL) {\n\t\t\treturn value;\n\t\t} else if (token == '-') {\n\t\t\treturn !F();\n\t\t} else if (token == '(') {\n\t\t\tv = F();\n\t\t\tgettoken();\n\t\t\tsavetoken = token;\n\t\t\tvnext = F();\n\t\t\tgettoken();\n\t\t\tif (token != ')') out.println(\"err\");\n\t\t\tif (savetoken == '+') {\n\t\t\t\treturn v || vnext;\n\t\t\t} else if (savetoken == '*') {\n\t\t\t\treturn v && vnext;\n\t\t\t} else if (savetoken == '>') {\n\t\t\t\tif (!v) return true;\n\t\t\t\telse return vnext;\n\t\t\t}\n\t\t\t\n\t\t}\n\t\treturn false;\n\t}\n\t\n\tvoid run() {\n\t\tString s;\n\t\tStringTokenizer st;\n\t\twhile (true) {\n\t\t\ts = sc.nextLine();\n\t\t\tif (s.equals(\"#\"))\n\t\t\t\tbreak;\n\t\t\tst = new StringTokenizer(s,\"=\");\n\t\t\teq1 = st.nextToken().toCharArray();\n\t\t\teq2 = st.nextToken().toCharArray();\n\t\t\tflag = true;\n\t\t\tcalc(0);\n\t\t\tif (flag)\n\t\t\t\tout.println(\"YES\");\n\t\t\telse\n\t\t\t\tout.println(\"N0\");\n\t\t}\n\t}\n\t\n\tpublic static void main(String[] args) {\n\t\tnew Main().run();\n\t}\n}"
  },
  {
    "language": "Java",
    "code": "import java.util.Scanner;\n\npublic class Main {\n\tchar[] s1;//原文1\n\tchar[] s2;//原文2\n\tint index;//今なん文字目か\n\tint[] table;//PQRの値\n\tpublic static void main(String[] args) {\n\t\tnew Main().run();\n\t}\n\tvoid run(){\n\t\tScanner sc=new Scanner(System.in);\n\t\twhile(true){\n\t\t\tString str[]=sc.nextLine().split(\"=\");\n\t\t\tif(str[0].equals(\"#\")) break;\n\t\t\t//なぜこの番兵みたいな$を先輩はつけたのか？\n\t\t\t//必要性を考えたい。これがないとダメな場合がある？\n\t\t\t//s=(str+\"$\").toCharArray();\n\t\t\ts1=str[0].toCharArray();\n\t\t\ts2=str[1].toCharArray();\n\t\t\ttable=new int[11];\n\t\t\t//int ans=0;\n\t\t\tboolean flag=true;\n\t\t\tequation :\n\t\t\t\tfor(int a=0; a<2; a++){\n\t\t\t\t\ttable[0]=a;\n\t\t\t\t\tfor(int b=0; b<2; b++){\n\t\t\t\t\t\ttable[1]=b;\n\t\t\t\t\t\tfor(int c=0; c<2; c++){\n\t\t\t\t\t\t\ttable[2]=c;\n\t\t\t\t\t\t\tfor(int d=0; d<2; d++){\n\t\t\t\t\t\t\t\ttable[3]=d;\n\t\t\t\t\t\t\t\tfor(int e=0; e<2; e++){\n\t\t\t\t\t\t\t\t\ttable[4]=e;\n\t\t\t\t\t\t\t\t\tfor(int f=0; f<2; f++){\n\t\t\t\t\t\t\t\t\t\ttable[5]=f;\n\t\t\t\t\t\t\t\t\t\tfor(int g=0; g<2; g++){\n\t\t\t\t\t\t\t\t\t\t\ttable[6]=g;\n\t\t\t\t\t\t\t\t\t\t\tfor(int h=0; h<2; h++){\n\t\t\t\t\t\t\t\t\t\t\t\ttable[7]=h;\n\t\t\t\t\t\t\t\t\t\t\t\tfor(int i=0; i<2; i++){\n\t\t\t\t\t\t\t\t\t\t\t\t\ttable[8]=i;\n\t\t\t\t\t\t\t\t\t\t\t\t\tfor(int j=0; j<2; j++){\n\t\t\t\t\t\t\t\t\t\t\t\t\t\ttable[9]=j;\n\t\t\t\t\t\t\t\t\t\t\t\t\t\tfor(int k=0; k<2; k++){\n\t\t\t\t\t\t\t\t\t\t\t\t\t\t\ttable[10]=k;\n\t\t\t\t\t\t\t\t\t\t\t\t\t\t\tindex=0;\n\t\t\t\t\t\t\t\t\t\t\t\t\t\t\tint ans1=formura(s1);\n\t\t\t\t\t\t\t\t\t\t\t\t\t\t\tindex=0;\n\t\t\t\t\t\t\t\t\t\t\t\t\t\t\tint ans2=formura(s2);\n\t\t\t\t\t\t\t\t\t\t\t\t\t\t\tif(ans1 != ans2){\n\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t//not equation\n\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\tflag=false;\n\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\tbreak equation;\n\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t}\n\t\t\t\t\t\t\t\t\t\t\t\t\t\t}\n\t\t\t\t\t\t\t\t\t\t\t\t\t}\n\t\t\t\t\t\t\t\t\t\t\t\t}\n\t\t\t\t\t\t\t\t\t\t\t}\n\t\t\t\t\t\t\t\t\t\t}\n\t\t\t\t\t\t\t\t\t}\n\t\t\t\t\t\t\t\t}\n\t\t\t\t\t\t\t}\n\t\t\t\t\t\t}\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\tif(flag) System.out.println(\"YES\");\n\t\t\telse System.out.println(\"NO\");\n\t\t}\n\t}\n\tint formura(char s[]){\n\t\tchar c=c(s);\n\t\t\n\t\tif(c=='('){\n\t\t\tint a = formura(s);\n\t\t\tchar c2 = c(s);\n\t\t\tif(c2 == '*'){\n\t\t\t\tint b = formura(s);\n\t\t\t\tc(s);\n\t\t\t\treturn Math.min(a, b);\n\t\t\t}\n\t\t\telse if(c2 == '+'){\n\t\t\t\tint b = formura(s);\n\t\t\t\tc(s);\n\t\t\t\treturn Math.max(a, b);\n\t\t\t}\n\t\t\telse{\n\t\t\t\tc(s);\n\t\t\t\tint b = formura(s);\n\t\t\t\tc(s);\n\t\t\t\tif(a==1 && b==0){\n\t\t\t\t\treturn 0;\n\t\t\t\t}\n\t\t\t\treturn 1;\n\t\t\t}\n\t\t}\n\t\telse if(c=='-'){\n\t\t\tint r=formura(s);\n\t\t\tif(r==0){\n\t\t\t\treturn 1;\n\t\t\t}\n\t\t\telse if(r==0){\n\t\t\t\treturn 1;\n\t\t\t}\n\t\t}\n\t\telse if(c=='T'){\n\t\t\treturn 1;\n\t\t}\n\t\telse if(c=='F'){\n\t\t\treturn 0;\n\t\t}\n\t\telse{\n\t\t\treturn table[c-'a'];\n\t\t}\n\t\t\n\t\treturn -1;\n\t}\n\n\tchar c(char s[]){\n\t\treturn s[index++];\n\t}\n}"
  },
  {
    "language": "Java",
    "code": "import java.util.Scanner;\n\npublic class Main {\n public static void main(String[] args) {\n\tScanner in = new Scanner(System.in);\n\twhile (in.hasNext()) {\n\t String str = in.next().trim();\n\t if (str.equals(\"#\")) {\n\t\tbreak;\n\t }\n\t String[] lr = str.split(\"=\");\n\t Formula left = Formula.of(lr[0]);\n\t Formula right = Formula.of(lr[1]);\n\t int max = Integer.parseInt(\"11111111111\", 2);\n\t boolean isYes = true;\n\t for (int i = 0; i <= max && isYes; i++) {\n\t\tisYes = left.getAns(i) == right.getAns(i);\n\t }\n\t System.out.println(isYes ? \"YES\" : \"NO\");\n\t}\n }\n\n abstract static class Formula {\n\tabstract boolean getAns(int bools);\n\n\tpublic static Formula of(String string) {\n\t if (\"T\".equals(string)) { return Teisu.T; }\n\t if (\"F\".equals(string)) { return Teisu.F; }\n\t if (\"a\".equals(string)) { return Var.a; }\n\t if (\"b\".equals(string)) { return Var.b; }\n\t if (\"c\".equals(string)) { return Var.c; }\n\t if (\"d\".equals(string)) { return Var.d; }\n\t if (\"e\".equals(string)) { return Var.e; }\n\t if (\"f\".equals(string)) { return Var.f; }\n\t if (\"g\".equals(string)) { return Var.g; }\n\t if (\"h\".equals(string)) { return Var.h; }\n\t if (\"i\".equals(string)) { return Var.i; }\n\t if (\"j\".equals(string)) { return Var.j; }\n\t if (\"k\".equals(string)) { return Var.k; }\n\t if (string.startsWith(\"-\")) {\n\t\tNot n = new Not(of(string.substring(1)));\n\t\treturn n;\n\t }\n\t String f1 = null;\n\t String f2 = null;\n\t String op = null;\n\t StringBuilder sb = new StringBuilder();\n\t int kakko = 0;\n\t int posi = 1;\n\t while (posi < string.length() - 1) {\n\t\tchar c = string.charAt(posi++);\n\t\tif (c == '(') {\n\t\t kakko++;\n\t\t} else if (c == ')') {\n\t\t kakko--;\n\t\t}\n\t\tif (kakko == 0) {\n\t\t if (c == '+' || c == '*') {\n\t\t\top = (c == '+') ? \"+\" : \"*\";\n\t\t\tf1 = sb.toString();\n\t\t\tsb.setLength(0);\n\t\t } else if (c == '-' && string.charAt(posi) == '>') {\n\t\t\tposi++;\n\t\t\top = \"->\";\n\t\t\tf1 = sb.toString();\n\t\t\tsb.setLength(0);\n\t\t } else {\n\t\t\tsb.append(c);\n\t\t }\n\t\t} else {\n\t\t sb.append(c);\n\t\t}\n\t }\n\t f2 = sb.toString();\n\t return new Ope(of(f1), op, of(f2));\n\t}\n }\n\n static class Teisu extends Formula {\n\tfinal boolean      bool;\n\tstatic final Teisu T = new Teisu(true);\n\tstatic final Teisu F = new Teisu(false);\n\n\tTeisu(boolean bool) {\n\t this.bool = bool;\n\t}\n\n\t@Override\n\tboolean getAns(int bools) {\n\t return bool;\n\t}\n }\n\n static class Var extends Formula {\n\tstatic final Var a = new Var(1);\n\tstatic final Var b = new Var(2);\n\tstatic final Var c = new Var(4);\n\tstatic final Var d = new Var(8);\n\tstatic final Var e = new Var(16);\n\tstatic final Var f = new Var(32);\n\tstatic final Var g = new Var(64);\n\tstatic final Var h = new Var(128);\n\tstatic final Var i = new Var(256);\n\tstatic final Var j = new Var(512);\n\tstatic final Var k = new Var(1024);\n\tfinal int        var;\n\n\tVar(int var) {\n\t this.var = var;\n\t}\n\n\t@Override\n\tboolean getAns(int bools) {\n\t return var == (var & bools);\n\t}\n }\n\n static class Not extends Formula {\n\tfinal Formula f;\n\n\tNot(Formula f) {\n\t this.f = f;\n\t}\n\n\t@Override\n\tboolean getAns(int bools) {\n\t return !f.getAns(bools);\n\t}\n }\n\n static class Ope extends Formula {\n\tfinal Formula f1;\n\tfinal Formula f2;\n\tfinal String  op;\n\n\tOpe(Formula f1, String op, Formula f2) {\n\t this.f1 = f1;\n\t this.f2 = f2;\n\t this.op = op;\n\t}\n\n\t@Override\n\tboolean getAns(int bools) {\n\t boolean result;\n\t if (\"*\".equals(op)) {\n\t\tresult = f1.getAns(bools) && f2.getAns(bools);\n\t } else if (\"+\".equals(op)) {\n\t\tresult = f1.getAns(bools) || f2.getAns(bools);\n\t } else {\n\t\tresult = f1.getAns(bools) == false || f2.getAns(bools) == true;\n\t }\n\t return result;\n\t}\n\n }\n}"
  },
  {
    "language": "Java",
    "code": "\nimport java.io.*;\nimport java.util.*;\n\npublic class Main {\n\tFastScanner in = new FastScanner(System.in);\n\tPrintWriter out = new PrintWriter(System.out);\n\n\tString s;\n\tint idx;\n\t\n\tboolean parse(int next) {\n\t\tchar c = s.charAt(idx++);\n\t\tswitch (c) {\n\t\tcase 'T': return true;\n\t\tcase 'F': return false;\n\t\tcase '-':\n\t\t\treturn !parse(next);\n\t\tcase '(':\n\t\t\tboolean b1 = parse(next);\n\t\t\tchar c2 = s.charAt(idx++);\n\t\t\tboolean b2;\n\t\t\tswitch (c2) {\n\t\t\tcase '*':\n\t\t\t\tb2 = parse(next);\n\t\t\t\tidx++;\n\t\t\t\treturn b1 && b2;\n\t\t\tcase '+':\n\t\t\t\tb2 = parse(next);\n\t\t\t\tidx++;\n\t\t\t\treturn b1 || b2;\n\t\t\tcase '-':\n\t\t\t\tidx++;\n\t\t\t\tb2 = parse(next);\n\t\t\t\tidx++;\n\t\t\t\treturn !b1 || b2;\n\t\t\t}\n\t\tdefault:\n\t\t\tif ((next >> (c - 'a') & 1) == 0) \n\t\t\t\treturn true;\n\t\t\telse\n\t\t\t\treturn false;\n\t\t}\n\t}\n\t\n\tpublic void run() {\n\t\tloop : while (true) {\n\t\t\ts = in.next();\n\t\t\tidx = 0;\n\t\t\tif (s.matches(\"#\")) break;\n\t\t\t\n\t\t\tfor (int i = 0; i < (1 << 11); i++) {\n\t\t\t\tidx = 0;\n\t\t\t\tboolean b1 = parse(i);\n\t\t\t\tidx++;\n\t\t\t\tboolean b2 = parse(i);\n\t\t\t\tif (b1 != b2) {\n\t\t\t\t\tSystem.out.println(\"NO\");\n\t\t\t\t\tcontinue loop;\n\t\t\t\t}\n\t\t\t}\n\t\t\tSystem.out.println(\"YES\");\n\t\t}\n\t\tout.close();\n\t}\n\n\tpublic static void main(String[] args) {\n\t\tnew Main().run();\n\t}\n\n\tpublic void mapDebug(int[][] a) {\n\t\tSystem.out.println(\"--------map display---------\");\n\n\t\tfor (int i = 0; i < a.length; i++) {\n\t\t\tfor (int j = 0; j < a[i].length; j++) {\n\t\t\t\tSystem.out.printf(\"%3d \", a[i][j]);\n\t\t\t}\n\t\t\tSystem.out.println();\n\t\t}\n\n\t\tSystem.out.println(\"----------------------------\");\n\t\tSystem.out.println();\n\t}\n\n\tpublic void debug(Object... obj) {\n\t\tSystem.out.println(Arrays.deepToString(obj));\n\t}\n\n\tclass FastScanner {\n\t\tprivate InputStream stream;\n\t\tprivate byte[] buf = new byte[1024];\n\t\tprivate int curChar;\n\t\tprivate int numChars;\n\n\t\tpublic FastScanner(InputStream stream) {\n\t\t\tthis.stream = stream;\n\t\t\t//stream = new FileInputStream(new File(\"dec.in\"));\n\n\t\t}\n\n\t\tint read() {\n\t\t\tif (numChars == -1)\n\t\t\t\tthrow new InputMismatchException();\n\t\t\tif (curChar >= numChars) {\n\t\t\t\tcurChar = 0;\n\t\t\t\ttry {\n\t\t\t\t\tnumChars = stream.read(buf);\n\t\t\t\t} catch (IOException e) {\n\t\t\t\t\tthrow new InputMismatchException();\n\t\t\t\t}\n\t\t\t\tif (numChars <= 0)\n\t\t\t\t\treturn -1;\n\t\t\t}\n\t\t\treturn buf[curChar++];\n\t\t}\n\n\t\tboolean isSpaceChar(int c) {\n\t\t\treturn c == ' ' || c == '\\n' || c == '\\r' || c == '\\t' || c == -1;\n\t\t}\n\n\t\tboolean isEndline(int c) {\n\t\t\treturn c == '\\n' || c == '\\r' || c == -1;\n\t\t}\n\n\t\tint nextInt() {\n\t\t\treturn Integer.parseInt(next());\n\t\t}\n\n\t\tlong nextLong() {\n\t\t\treturn Long.parseLong(next());\n\t\t}\n\n\t\tdouble nextDouble() {\n\t\t\treturn Double.parseDouble(next());\n\t\t}\n\n\t\tString next() {\n\t\t\tint c = read();\n\t\t\twhile (isSpaceChar(c))\n\t\t\t\tc = read();\n\t\t\tStringBuilder res = new StringBuilder();\n\t\t\tdo {\n\t\t\t\tres.appendCodePoint(c);\n\t\t\t\tc = read();\n\t\t\t} while (!isSpaceChar(c));\n\t\t\treturn res.toString();\n\t\t}\n\n\t\tString nextLine() {\n\t\t\tint c = read();\n\t\t\twhile (isEndline(c))\n\t\t\t\tc = read();\n\t\t\tStringBuilder res = new StringBuilder();\n\t\t\tdo {\n\t\t\t\tres.appendCodePoint(c);\n\t\t\t\tc = read();\n\t\t\t} while (!isEndline(c));\n\t\t\treturn res.toString();\n\t\t}\n\t}\n}"
  },
  {
    "language": "Java",
    "code": "import java.util.Scanner;\nimport java.util.regex.Pattern;\n\npublic class Main {\n public static void main(String[] args) {\n\tScanner in = new Scanner(System.in);\n\twhile (in.hasNext()) {\n\t String str = in.next();\n\t if (!\"#\".equals(str)) {\n\t\tString[] lr = str.split(\"=\");\n\t\tFormula left = Formula.of(lr[0]);\n\t\tFormula right = Formula.of(lr[1]);\n\t\tint max = Integer.parseInt(\"11111111111\", 2);\n\t\tboolean isYes = true;\n\t\tfor (int i = 0; i <= max && isYes; i++) {\n\t\t isYes = left.getAns(i) == right.getAns(i);\n\t\t}\n\t\tSystem.out.println(isYes ? \"YES\" : \"NO\");\n\t\tstr = in.next();\n\t }\n\t}\n }\n\n abstract static class Formula {\n\tstatic final Pattern PATTERN =\n\t                               Pattern\n\t                                 .compile(\"^\\\\((.+)\\\\)$\");\n\n\tabstract boolean getAns(int bools);\n\n\tpublic static Formula of(String string) {\n\t if (\"T\".equals(string)) { return Teisu.T; }\n\t if (\"F\".equals(string)) { return Teisu.F; }\n\t if (\"a\".equals(string)) { return Var.a; }\n\t if (\"b\".equals(string)) { return Var.b; }\n\t if (\"c\".equals(string)) { return Var.c; }\n\t if (\"d\".equals(string)) { return Var.d; }\n\t if (\"e\".equals(string)) { return Var.e; }\n\t if (\"f\".equals(string)) { return Var.f; }\n\t if (\"g\".equals(string)) { return Var.g; }\n\t if (\"h\".equals(string)) { return Var.h; }\n\t if (\"i\".equals(string)) { return Var.i; }\n\t if (string.startsWith(\"-\")) {\n\t\tNot n = new Not(of(string.substring(1)));\n\t\treturn n;\n\t }\n\t String f1 = null;\n\t String f2 = null;\n\t String op = null;\n\t StringBuilder sb = new StringBuilder();\n\t int kakko = 0;\n\t int posi = 1;\n\t while (posi < string.length() - 1) {\n\t\tchar c = string.charAt(posi++);\n\t\tif (c == '(') {\n\t\t kakko++;\n\t\t} else if (c == ')') {\n\t\t kakko--;\n\t\t}\n\t\tif (kakko == 0) {\n\t\t if (c == '+' || c == '*') {\n\t\t\top = (c == '+') ? \"+\" : \"*\";\n\t\t\tf1 = sb.toString();\n\t\t\tsb.setLength(0);\n\t\t } else if (c == '-' && string.charAt(posi) == '>') {\n\t\t\tposi++;\n\t\t\top = \"->\";\n\t\t\tf1 = sb.toString();\n\t\t\tsb.setLength(0);\n\t\t } else {\n\t\t\tsb.append(c);\n\t\t }\n\t\t} else {\n\t\t sb.append(c);\n\t\t}\n\t }\n\t f2 = sb.toString();\n\t return new Ope(of(f1), op, of(f2));\n\n\t}\n\n }\n\nstatic class Teisu extends Formula {\n\tfinal boolean      bool;\n\tstatic final Teisu T = new Teisu(true);\n\tstatic final Teisu F = new Teisu(false);\n\n\tTeisu(boolean bool) {\n\t this.bool = bool;\n\t}\n\n\t@Override\n\tboolean getAns(int bools) {\n\t return bool;\n\t}\n }\n\nstatic class Var extends Formula {\n\tstatic final Var a = new Var(1);\n\tstatic final Var b = new Var(2);\n\tstatic final Var c = new Var(4);\n\tstatic final Var d = new Var(8);\n\tstatic final Var e = new Var(16);\n\tstatic final Var f = new Var(32);\n\tstatic final Var g = new Var(64);\n\tstatic final Var h = new Var(128);\n\tstatic final Var i = new Var(256);\n\tfinal int        var;\n\n\tVar(int var) {\n\t this.var = var;\n\t}\n\n\t@Override\n\tboolean getAns(int bools) {\n\t return var == (var & bools);\n\t}\n }\n\nstatic class Not extends Formula {\n\tfinal Formula f;\n\n\tNot(Formula f) {\n\t this.f = f;\n\t}\n\n\t@Override\n\tboolean getAns(int bools) {\n\t return !f.getAns(bools);\n\t}\n }\n\n static class Ope extends Formula {\n\tfinal Formula f1;\n\tfinal Formula f2;\n\tfinal String  op;\n\n\tOpe(Formula f1, String op, Formula f2) {\n\t this.f1 = f1;\n\t this.f2 = f2;\n\t this.op = op;\n\t}\n\n\t@Override\n\tboolean getAns(int bools) {\n\t boolean result;\n\t if (\"*\".equals(op)) {\n\t\tresult = f1.getAns(bools) && f2.getAns(bools);\n\t } else if (\"+\".equals(op)) {\n\t\tresult = f1.getAns(bools) || f2.getAns(bools);\n\t } else {\n\t\tresult = f1.getAns(bools) == false || f2.getAns(bools) == true;\n\t }\n\t return result;\n\t}\n\n }\n}"
  },
  {
    "language": "Java",
    "code": "import java.util.*;\n\npublic class Main {\n\tchar[][] c;\n\tboolean[] r = new boolean[11];\n\tboolean flag;\n\tint id;\n\t\n\tvoid loop(int n){\n\t\tif(flag==false) return;\n\t\tif(n==11){\n\t\t\tid = 0;\n\t\t\tboolean t0 = exp(0);\n\t\t\tid = 0;\n\t\t\tboolean t1 = exp(1);\n\t\t\tif(t0!=t1) flag = false;\n\t\t}else{\n\t\t\tr[n] = true;\n\t\t\tloop(n+1);\n\t\t\tr[n] = false;\n\t\t\tloop(n+1);\n\t\t}\n\t}\n\t\n\tboolean exp(int m){\n\t\tboolean q = fact(m);\n\t\tid++;\n\t\tif(id<c[m].length){\n\t\t\tchar p = c[m][id];\n\t\t\tif(p=='+'){\n\t\t\t\tid++;\n\t\t\t\tq = q|exp(m);\n\t\t\t}else if(p=='*'){\n\t\t\t\tid++;\n\t\t\t\tq = q&exp(m);\n\t\t\t}else if(p=='/'){\n\t\t\t\tid++;\n\t\t\t\tboolean v = exp(m);\n\t\t\t\tif(q==true && v==false) q = false;\n\t\t\t\telse q = true;\n\t\t\t}\n\t\t}\n\t\treturn q;\n\t}\n\t\n\tboolean fact(int m){\n\t\tchar p = c[m][id];\n\t\tboolean q = false;\n\t\tif(p=='('){\n\t\t\tid++;\n\t\t\tq = exp(m);\n\t\t}else if(p=='-'){\n\t\t\tid++;\n\t\t\tq = !fact(m);\n\t\t}else{\n\t\t\tif(97<=(int)p && (int)p<=107) q = r[(int)p-97];\n\t\t\telse if(p=='T') q = true;\n\t\t\telse if(p=='F') q = false;\n\t\t}\n\t\treturn q;\n\t}\n\t\n\tvoid solve(){\n\t\tScanner sc = new Scanner(System.in);\n\t\t\n\t\twhile(true){\n\t\t\tString s = sc.next();\n\t\t\tif(s.compareTo(\"#\")==0) break;\n\t\t\tString[] t = s.replace(\"->\", \"/\").split(\"=\");\n\t\t\tc = new char[2][];\n\t\t\tc[0] = t[0].toCharArray();\n\t\t\tc[1] = t[1].toCharArray();\n\t\t\tflag = true;\n\t\t\tloop(0);\n\t\t\tif(flag==true) System.out.println(\"YES\");\n\t\t\telse System.out.println(\"NO\");\n\t\t}\t\n\t}\n\t\n\tpublic static void main(String[] args) {\n\t\tnew Main().solve();\n\t}\t\n}"
  },
  {
    "language": "Java",
    "code": "import java.util.Scanner;\n\npublic class Main {\n\n\tstatic Scanner sc = new Scanner(System.in);\n\tstatic int var;\n\tstatic char[] str;\n\tstatic int pos;\n\n\tpublic static void main(String[] arg) {\n\t\twhile (true) {\n\t\t\tstr = sc.next().toCharArray();\n\t\t\tif (str[0] == '#') break;\n\t\t\tpos = 0;\n\t\t\tFormula l = parse();\n\t\t\t++pos;\n\t\t\tFormula r = parse();\n\t\t\tboolean res = true;\n\t\t\tfor (int i = 0; i < (1 << 11); ++i) {\n\t\t\t\tif (l.eval() != r.eval()) {\n\t\t\t\t\tres = false;\n\t\t\t\t\tbreak;\n\t\t\t\t}\n\t\t\t}\n\t\t\tSystem.out.println(res ? \"YES\" : \"NO\");\n\t\t}\n\t}\n\n\tstatic Formula parse() {\n\t\tchar c = str[pos++];\n\t\tif (c == 'T') return new Constant(true);\n\t\tif (c == 'F') return new Constant(false);\n\t\tif ('a' <= c && c <= 'z') return new Var(c - 'a');\n\t\tif (c == '-') return new Not(parse());\n\t\tFormula l = parse();\n\t\tchar op = str[pos++];\n\t\tif (op == '*') {\n\t\t\tFormula r = parse();\n\t\t\t++pos;\n\t\t\treturn new And(l, r);\n\t\t} else if (op == '+') {\n\t\t\tFormula r = parse();\n\t\t\t++pos;\n\t\t\treturn new Or(l, r);\n\t\t} else {\n\t\t\t++pos;\n\t\t\tFormula r = parse();\n\t\t\t++pos;\n\t\t\treturn new Inc(l, r);\n\t\t}\n\t}\n\n\tstatic abstract class Formula {\n\t\tabstract boolean eval();\n\t}\n\n\tstatic class Constant extends Formula {\n\t\tboolean v;\n\n\t\tConstant(boolean v) {\n\t\t\tthis.v = v;\n\t\t}\n\n\t\tboolean eval() {\n\t\t\treturn this.v;\n\t\t}\n\t}\n\n\tstatic class Var extends Formula {\n\t\tint p;\n\n\t\tVar(int p) {\n\t\t\tthis.p = p;\n\t\t}\n\n\t\tboolean eval() {\n\t\t\treturn (var & (1 << p)) != 0;\n\t\t}\n\t}\n\n\tstatic class Not extends Formula {\n\t\tFormula f;\n\n\t\tNot(Formula f) {\n\t\t\tthis.f = f;\n\t\t}\n\n\t\tboolean eval() {\n\t\t\treturn !f.eval();\n\t\t}\n\t}\n\n\tstatic class And extends Formula {\n\t\tFormula left, right;\n\n\t\tAnd(Formula l, Formula r) {\n\t\t\tthis.left = l;\n\t\t\tthis.right = r;\n\t\t}\n\n\t\tboolean eval() {\n\t\t\treturn left.eval() && right.eval();\n\t\t}\n\t}\n\n\tstatic class Or extends Formula {\n\t\tFormula left, right;\n\n\t\tOr(Formula l, Formula r) {\n\t\t\tthis.left = l;\n\t\t\tthis.right = r;\n\t\t}\n\n\t\tboolean eval() {\n\t\t\treturn left.eval() || right.eval();\n\t\t}\n\t}\n\n\tstatic class Inc extends Formula {\n\t\tFormula left, right;\n\n\t\tInc(Formula l, Formula r) {\n\t\t\tthis.left = l;\n\t\t\tthis.right = r;\n\t\t}\n\n\t\tboolean eval() {\n\t\t\treturn !left.eval() || right.eval();\n\t\t}\n\t}\n\n}"
  },
  {
    "language": "Java",
    "code": "import java.util.Scanner;\nimport java.util.ArrayList;\n\npublic class Main {\n\tScanner sc;\n\tpublic void run(){\n\t\tsc = new Scanner(System.in);\n\t\twhile(sc.hasNext()){\n\t\t\tString n = sc.next();\n\t\t\tif(n.equals(\"#\")){\n\t\t\t\tbreak;\n\t\t\t}\n\t\t\telse{\n\t\t\t\tcalc(n);\n\t\t\t}\n\t\t}\n\t}\n\tString s;\n\tpublic void calc(String line){\n\t\ts = line;\n\t\tEquation tree = makeEquation();\n\t\t\n\t\tboolean ans = true;\n\t\t\n\t\tfor(int a = 0; a < 2; a++){\n\t\t\tfor(int b = 0; b < 2; b++){\n\t\t\t\tfor(int c = 0; c < 2; c++){\n\t\t\t\t\tfor(int d = 0; d < 2; d++){\n\t\t\t\t\t\tfor(int e = 0; e < 2; e++){\n\t\t\t\t\t\t\tfor(int f = 0; f < 2; f++){\n\t\t\t\t\t\t\t\tfor(int g = 0; g < 2; g++){\n\t\t\t\t\t\t\t\t\tfor(int h = 0; h < 2; h++){\n\t\t\t\t\t\t\t\t\t\tfor(int i = 0; i < 2; i++){\n\t\t\t\t\t\t\t\t\t\t\tfor(int j = 0; j < 2; j++){\n\t\t\t\t\t\t\t\t\t\t\t\tfor(int k = 0; k < 2; k++){\n\t\t\t\t\t\t\t\t\t\t\t\t\tboolean t = tree.calc(a, b, c, d, e, f, g, h, i, j, k);\n\t\t\t\t\t\t\t\t\t\t\t\t\tif(!t) ans = false;\n\t\t\t\t\t\t\t\t\t\t\t\t}\n\t\t\t\t\t\t\t\t\t\t\t}\n\t\t\t\t\t\t\t\t\t\t}\n\t\t\t\t\t\t\t\t\t}\n\t\t\t\t\t\t\t\t}\n\t\t\t\t\t\t\t}\n\t\t\t\t\t\t}\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t\tif(ans) System.out.println(\"YES\");\n\t\telse System.out.println(\"NO\");\n\t}\n\tpublic Equation makeEquation(){\n\t\tFormula f1 = makeFormula();\n\t\tif(s.substring(0,1).equals(\"=\")){\n\t\t\ts = s.substring(1);\n\t\t}\n\t\telse return null;\n\t\tFormula f2 = makeFormula();\n\t\treturn new Equation(f1, f2);\n\t}\n\tpublic Formula makeFormula(){\n\t\tString now = s.substring(0,1);\n\t\ts = s.substring(1);\n\t\t\n\t\tif(now.equals(\"T\")) return new BoolFormula(1);\n\t\telse if(now.equals(\"F\")) return new BoolFormula(0);\n\t\telse if(now.equals(\"-\")){\n\t\t\tFormula f1 = makeFormula();\n\t\t\treturn new NotFormula(f1);\n\t\t}\n\t\telse if(now.equals(\"(\")){\n\t\t\tFormula f1 = makeFormula();\n\t\t\tString now2 = s.substring(0,1);\n\t\t\ts = s.substring(1);\n\t\t\tif(now2.equals(\"*\")){\n\t\t\t\tFormula f2 = makeFormula();\n\t\t\t\ts = s.substring(1);\n\t\t\t\treturn new AndFormula(f1, f2);\n\t\t\t}\n\t\t\telse if(now2.equals(\"+\")){\n\t\t\t\tFormula f2 = makeFormula();\n\t\t\t\ts = s.substring(1);\n\t\t\t\treturn new OrFormula(f1, f2);\n\t\t\t}\n\t\t\telse{\n\t\t\t\ts = s.substring(1);\n\t\t\t\tFormula f2 = makeFormula();\n\t\t\t\ts = s.substring(1);\n\t\t\t\treturn new ImpFormula(f1, f2);\n\t\t\t}\n\t\t}\n\t\telse return new StringFormula(s);\n\t}\n\tpublic static void main(String[] args){\n\t\tnew Main().run();\n\t}\n}\n\nclass Equation{\n\tFormula value1;\n\tFormula value2;\n\tEquation(Formula v1, Formula v2){\n\t\tthis.value1 = v1;\n\t\tthis.value2 = v2;\n\t}\n\tboolean calc(int a, int b, int c, int d, int e, int f, int g, int h,\n\t\t\tint i, int j, int k){\n\t\tint v1 = value1.calc(a, b, c, d, e, f, g, h, i, j, k);\n\t\tint v2 = value2.calc(a, b, c, d, e, f, g, h, i, j, k);\n\t\tif(v1 == v2) return true;\n\t\telse return false;\n\t}\n}\n\nclass Formula{\n\tint calc(int a, int b, int c, int d, int e, int f, int g, int h,\n\t\t\tint i, int j, int k) {\n\t\treturn 0;\n\t}\n\t\n}\nclass BoolFormula extends Formula{\n\tint value;\n\tBoolFormula(int b){\n\t\tthis.value = b;\n\t}\n\tint calc(int a, int b, int c, int d, int e, int f, int g, int h, int i, int j, int k){\n\t\treturn value;\n\t}\n}\nclass StringFormula extends Formula{\n\tString value;\n\tStringFormula(String c){\n\t\tthis.value = c;\n\t}\n\tint calc(int a, int b, int c, int d, int e, int f, int g, int h, int i, int j, int k){\n\t\tif(value.equals(\"a\")) return a;\n\t\telse if(value.equals(\"b\")) return b;\n\t\telse if(value.equals(\"c\")) return c;\n\t\telse if(value.equals(\"d\")) return d;\n\t\telse if(value.equals(\"e\")) return e;\n\t\telse if(value.equals(\"f\")) return f;\n\t\telse if(value.equals(\"g\")) return g;\n\t\telse if(value.equals(\"h\")) return h;\n\t\telse if(value.equals(\"i\")) return i;\n\t\telse if(value.equals(\"j\")) return j;\n\t\telse  return k;\n\t}\n}\nclass NotFormula extends Formula{\n\tFormula value;\n\tNotFormula(Formula v){\n\t\tthis.value = v;\n\t}\n\tint calc(int a, int b, int c, int d, int e, int f, int g, int h, int i, int j, int k){\n\t\tint v = value.calc(a,b,c,d,e,f,g,h,i,j,k);\n\t\tif(v == 1) return 0;\n\t\telse return 1;\n\t}\n}\n\nclass AndFormula extends Formula{\n\tFormula value1;\n\tFormula value2;\n\tint[][] ans;\n\tAndFormula(Formula v1, Formula v2){\n\t\tthis.value1 = v1;\n\t\tthis.value2 = v2;\n\t\tans = new int[2][2];\n\t\tans[1][1] = 1;\n\t\tans[1][0] = 0;\n\t\tans[0][1] = 0;\n\t\tans[0][0] = 0;\n\t}\n\tint calc(int a, int b, int c, int d, int e, int f, int g, int h, int i, int j, int k){\n\t\tint v1 = value1.calc(a,b,c,d,e,f,g,h,i,j,k);\n\t\tint v2 = value2.calc(a,b,c,d,e,f,g,h,i,j,k);\n\t\treturn ans[v1][v2];\n\t}\n}\nclass OrFormula extends Formula{\n\tFormula value1;\n\tFormula value2;\n\tint[][] ans;\n\tOrFormula(Formula v1, Formula v2){\n\t\tthis.value1 = v1;\n\t\tthis.value2 = v2;\n\t\tans = new int[2][2];\n\t\tans[1][1] = 1;\n\t\tans[1][0] = 1;\n\t\tans[0][1] = 1;\n\t\tans[0][0] = 0;\n\t}\n\tint calc(int a, int b, int c, int d, int e, int f, int g, int h, int i, int j, int k){\n\t\tint v1 = value1.calc(a,b,c,d,e,f,g,h,i,j,k);\n\t\tint v2 = value2.calc(a,b,c,d,e,f,g,h,i,j,k);\n\t\treturn ans[v1][v2];\n\t}\n}\nclass ImpFormula extends Formula{\n\tFormula value1;\n\tFormula value2;\n\tint[][] ans;\n\tImpFormula(Formula v1, Formula v2){\n\t\tthis.value1 = v1;\n\t\tthis.value2 = v2;\n\t\tans = new int[2][2];\n\t\tans[1][1] = 1;\n\t\tans[1][0] = 0;\n\t\tans[0][1] = 1;\n\t\tans[0][0] = 1;\n\t}\n\tint calc(int a, int b, int c, int d, int e, int f, int g, int h, int i, int j, int k){\n\t\tint v1 = value1.calc(a,b,c,d,e,f,g,h,i,j,k);\n\t\tint v2 = value2.calc(a,b,c,d,e,f,g,h,i,j,k);\n\t\treturn ans[v1][v2];\n\t}\n}"
  },
  {
    "language": "Java",
    "code": "import java.util.ArrayList;\nimport java.util.BitSet;\nimport java.util.PriorityQueue;\nimport java.util.Queue;\nimport java.util.Scanner;\n\npublic class Main{\n\tpublic static char[] s;\n\tpublic static int[] table;\n\tpublic static int n;\n\tpublic static void main(String[] args){\n\t\tScanner in = new Scanner(System.in);\n\t\twhile(true){\n\t\t\ts = in.next().toCharArray();\n\t\t\tif(s[0] == '#') break;\n\t\t\tint alps = 0;\n\t\t\tfor(int i=0; i<s.length; i++){\n\t\t\t\tif(s[i] < 'a' || 'z' < s[i]) continue;\n\t\t\t\talps |= 1<<s[i]-'a';\n\t\t\t}\n\t\t\tn = Integer.bitCount(alps);\n\t\t\ttable = new int[n];\n\t\t\tint idx = 0;\n\t\t\tfor(int i=0; i<15; i++){\n\t\t\t\tif((alps&1<<i)==0) continue;\n\t\t\t\ttable[idx++] = i;\n\t\t\t}\n\t\t\tSystem.out.println(dfs(0, 0) ? \"YES\" : \"NO\");\n\t\t}\n\t}\n\t\n\tpublic static boolean dfs(int idx, int state){\n\t\tif(idx == n){\n\t\t\tif(!check(state))\n\t\t\t\treturn false;\n\t\t\treturn true;\n\t\t}\n\t\tif(!dfs(idx+1, state|1<<table[idx]) || !dfs(idx+1, state))\n\t\t\treturn false;\n\t\treturn true;\n\t}\n\tpublic static int idx;\n\tpublic static boolean check(int state){\n\t\tidx = 0;\n\t\tst = state;\n\t\tboolean val = formula();\n\t\tidx++;\n\t\treturn val==formula();\n\t}\n\tpublic static int st;\n\tpublic static boolean[][] arr = {\n\t\t{true, true},\n\t\t{false,true}\n\t};\n\tpublic static boolean formula(){\n\t\tif(s[idx] == '-'){\n\t\t\tidx++;\n\t\t\treturn !formula();\n\t\t}else if(s[idx] == '('){\n\t\t\tidx++;\n\t\t\tboolean val = formula();\n\t\t\tif(s[idx] == '*'){\n\t\t\t\tidx++;\n\t\t\t\tval = val&formula();\n\t\t\t}else if(s[idx] == '+'){\n\t\t\t\tidx++;\n\t\t\t\tval = val|formula();\n\t\t\t}else{\n\t\t\t\tidx+=2;\n\t\t\t\tval = arr[val?1:0][formula()?1:0];\n\t\t\t}\n\t\t\tidx++;\n\t\t\treturn val;\n\t\t}else if(s[idx] == 'T'){\n\t\t\tidx++;\n\t\t\treturn true;\n\t\t}\n\t\telse if(s[idx] == 'F'){\n\t\t\tidx++;\n\t\t\treturn false;\n\t\t}\n\t\treturn (st&1<<s[idx++]-'a')>0;\n\t}\n\t\n}"
  },
  {
    "language": "Java",
    "code": "import java.util.*;\nimport static java.lang.System.*;\n\npublic class Main {\n\n\tScanner sc = new Scanner(in);\n\t\n\tchar[] eq;\n\tchar[] eq1, eq2;\n\tboolean[] as = new boolean[11];\n\tboolean[] check = new boolean[11];\n\t\n\tboolean flag;\n\tvoid calc(int depth) {\n\t\tif (depth == 11) {\n\t\t\tboolean a, b;\n\t\t\teq = eq1;\n\t\t\tindex = 0;\n\t\t\ta = F();\n\t\t\teq = eq2;\n\t\t\tindex = 0;\n\t\t\tb = F();\n//\t\t\tout.println(a);\n//\t\t\tout.println(b);\n//\t\t\tout.println();\n\t\t\tif (a != b)\n\t\t\t\tflag = false;\n\t\t} else {\n\t\t\tif (flag) {\n\t\t\t\tas[depth] = false;\n\t\t\t\tcalc(depth+1);\n\t\t\t\tas[depth] = true;\n\t\t\t\tcalc(depth+1);\n\t\t\t}\n\t\t}\n\t}\n\t\n\tint index;\n\tint token;\n\tfinal int VAL = '%';\n\tboolean value;\n\tvoid gettoken() {\n\t\tint ch = eq[index++];\n\t\tif (ch == '+' || ch == '*' || ch == '(' || ch == ')') {\n\t\t\ttoken = ch;\n\t\t\treturn;\n\t\t} else if (ch == '-') {\n\t\t\tif (eq[index] == '>') {\n\t\t\t\tindex++;\n\t\t\t\ttoken = '>';\n\t\t\t\treturn;\n\t\t\t} else {\n\t\t\t\ttoken = ch;\n\t\t\t\treturn;\n\t\t\t}\n\t\t} else {\n\t\t\ttoken = VAL;\n\t\t\tswitch(ch) {\n\t\t\tcase 'T':\n\t\t\t\tvalue = true; break;\n\t\t\tcase 'F':\n\t\t\t\tvalue = false; break;\n\t\t\tcase 'a':\n\t\t\t\tvalue = as[0]; break;\n\t\t\tcase 'b':\n\t\t\t\tvalue = as[1]; break;\n\t\t\tcase 'c':\n\t\t\t\tvalue = as[2]; break;\n\t\t\tcase 'd':\n\t\t\t\tvalue = as[3]; break;\n\t\t\tcase 'e':\n\t\t\t\tvalue = as[4]; break;\n\t\t\tcase 'f':\n\t\t\t\tvalue = as[5]; break;\n\t\t\tcase 'g':\n\t\t\t\tvalue = as[6]; break;\n\t\t\tcase 'h':\n\t\t\t\tvalue = as[7]; break;\n\t\t\tcase 'i':\n\t\t\t\tvalue = as[8]; break;\n\t\t\tcase 'j':\n\t\t\t\tvalue = as[9]; break;\n\t\t\tcase 'k':\n\t\t\t\tvalue = as[10]; break;\n\t\t\t}\n\t\t}\n\t}\n\t\n\tboolean F() {\n\t\tboolean v, vnext;\n\t\tint savetoken;\n\t\tgettoken();\n\t\tif (token == VAL) {\n\t\t\treturn value;\n\t\t} else if (token == '-') {\n\t\t\treturn !F();\n\t\t} else if (token == '(') {\n\t\t\tv = F();\n\t\t\tgettoken();\n\t\t\tsavetoken = token;\n\t\t\tvnext = F();\n\t\t\tgettoken();\n\t\t\tif (token != ')') out.println(\"err\");\n\t\t\tif (savetoken == '+') {\n\t\t\t\treturn v || vnext;\n\t\t\t} else if (savetoken == '*') {\n\t\t\t\treturn v && vnext;\n\t\t\t} else if (savetoken == '>') {\n\t\t\t\tif (!v) return true;\n\t\t\t\telse return vnext;\n\t\t\t}\n\t\t\t\n\t\t}\n\t\tout.println(\"err\");\n\t\treturn false;\n\t}\n\t\n\tvoid run() {\n\t\tString s;\n\t\tStringTokenizer st;\n\t\twhile (true) {\n\t\t\ts = sc.nextLine();\n\t\t\tif (s.equals(\"#\"))\n\t\t\t\tbreak;\n\t\t\tst = new StringTokenizer(s,\"=\");\n\t\t\teq1 = st.nextToken().toCharArray();\n\t\t\teq2 = st.nextToken().toCharArray();\n\t\t\tflag = true;\n\t\t\tcalc(0);\n\t\t\tif (flag)\n\t\t\t\tout.println(\"YES\");\n\t\t\telse\n\t\t\t\tout.println(\"N0\");\n//\t\t\tout.println();\n\t\t}\n\t}\n\t\n\tpublic static void main(String[] args) {\n\t\tnew Main().run();\n\t}\n}"
  },
  {
    "language": "Java",
    "code": "import java.util.Scanner;\n\npublic class Main {\n\tchar[] s1;//原文1\n\tchar[] s2;//原文2\n\tint index;//今なん文字目か\n\tint[] table;//PQRの値\n\tpublic static void main(String[] args) {\n\t\tnew Main().run();\n\t}\n\tvoid run(){\n\t\tScanner sc=new Scanner(System.in);\n\t\twhile(true){\n\t\t\tString str[]=sc.nextLine().split(\"=\");\n\t\t\tif(str[0].equals(\"#\")) break;\n\t\t\t//なぜこの番兵みたいな$を先輩はつけたのか？\n\t\t\t//必要性を考えたい。これがないとダメな場合がある？\n\t\t\t//s=(str+\"$\").toCharArray();\n\t\t\ts1=str[0].toCharArray();\n\t\t\ts2=str[1].toCharArray();\n\t\t\ttable=new int[11];\n\t\t\t//int ans=0;\n\t\t\tboolean flag=true;\n\t\t\tequation :\n\t\t\t\tfor(int a=0; a<2; a++){\n\t\t\t\t\ttable[0]=a;\n\t\t\t\t\tfor(int b=0; b<2; b++){\n\t\t\t\t\t\ttable[1]=b;\n\t\t\t\t\t\tfor(int c=0; c<2; c++){\n\t\t\t\t\t\t\ttable[2]=c;\n\t\t\t\t\t\t\tfor(int d=0; d<2; d++){\n\t\t\t\t\t\t\t\ttable[3]=d;\n\t\t\t\t\t\t\t\tfor(int e=0; e<2; e++){\n\t\t\t\t\t\t\t\t\ttable[4]=e;\n\t\t\t\t\t\t\t\t\tfor(int f=0; f<2; f++){\n\t\t\t\t\t\t\t\t\t\ttable[5]=f;\n\t\t\t\t\t\t\t\t\t\tfor(int g=0; g<2; g++){\n\t\t\t\t\t\t\t\t\t\t\ttable[6]=g;\n\t\t\t\t\t\t\t\t\t\t\tfor(int h=0; h<2; h++){\n\t\t\t\t\t\t\t\t\t\t\t\ttable[7]=h;\n\t\t\t\t\t\t\t\t\t\t\t\tfor(int i=0; i<2; i++){\n\t\t\t\t\t\t\t\t\t\t\t\t\ttable[8]=i;\n\t\t\t\t\t\t\t\t\t\t\t\t\tfor(int j=0; j<2; j++){\n\t\t\t\t\t\t\t\t\t\t\t\t\t\ttable[9]=j;\n\t\t\t\t\t\t\t\t\t\t\t\t\t\tfor(int k=0; k<2; k++){\n\t\t\t\t\t\t\t\t\t\t\t\t\t\t\ttable[10]=k;\n\t\t\t\t\t\t\t\t\t\t\t\t\t\t\tindex=0;\n\t\t\t\t\t\t\t\t\t\t\t\t\t\t\tint ans1=formura(s1);\n\t\t\t\t\t\t\t\t\t\t\t\t\t\t\tindex=0;\n\t\t\t\t\t\t\t\t\t\t\t\t\t\t\tint ans2=formura(s2);\n\t\t\t\t\t\t\t\t\t\t\t\t\t\t\tif(ans1 != ans2){\n\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t//not equation\n\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\tflag=false;\n\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\tbreak equation;\n\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t}\n\t\t\t\t\t\t\t\t\t\t\t\t\t\t}\n\t\t\t\t\t\t\t\t\t\t\t\t\t}\n\t\t\t\t\t\t\t\t\t\t\t\t}\n\t\t\t\t\t\t\t\t\t\t\t}\n\t\t\t\t\t\t\t\t\t\t}\n\t\t\t\t\t\t\t\t\t}\n\t\t\t\t\t\t\t\t}\n\t\t\t\t\t\t\t}\n\t\t\t\t\t\t}\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\tif(flag) System.out.println(\"YES\");\n\t\t\telse System.out.println(\"NO\");\n\t\t}\n\t}\n\tint formura(char s[]){\n\t\tchar c=c(s);\n\t\t\n\t\tif(c=='('){\n\t\t\tint a = formura(s);\n\t\t\tchar c2 = c(s);\n\t\t\tif(c2 == '*'){\n\t\t\t\tint b = formura(s);\n\t\t\t\tc(s);\n\t\t\t\treturn Math.min(a, b);\n\t\t\t}\n\t\t\telse if(c2 == '+'){\n\t\t\t\tint b = formura(s);\n\t\t\t\tc(s);\n\t\t\t\treturn Math.max(a, b);\n\t\t\t}\n\t\t\telse{\n\t\t\t\tc(s);\n\t\t\t\tint b = formura(s);\n\t\t\t\tc(s);\n\t\t\t\tif(a==1 && b==0){\n\t\t\t\t\treturn 0;\n\t\t\t\t}\n\t\t\t\treturn 1;\n\t\t\t}\n\t\t}\n\t\telse if(c=='-'){\n\t\t\tint r=formura(s);\n\t\t\tif(r==0){\n\t\t\t\treturn 1;\n\t\t\t}\n\t\t\telse if(r==1){\n\t\t\t\treturn 0;\n\t\t\t}\n\t\t}\n\t\telse if(c=='T'){\n\t\t\treturn 1;\n\t\t}\n\t\telse if(c=='F'){\n\t\t\treturn 0;\n\t\t}\n\t\telse{\n\t\t\treturn table[c-'a'];\n\t\t}\n\t\t\n\t\treturn -1;\n\t}\n\n\tchar c(char s[]){\n\t\treturn s[index++];\n\t}\n}"
  },
  {
    "language": "Java",
    "code": "import java.util.Scanner;\nimport java.util.regex.Pattern;\n\npublic class Main {\n public static void main(String[] args) {\n\tScanner in = new Scanner(System.in);\n\tString str=in.next();\n\tdo {\n\t String[] lr = str.split(\"=\");\n\t Formula left = Formula.of(lr[0]);\n\t Formula right = Formula.of(lr[1]);\n\t int max = Integer.parseInt(\"11111111111\", 2);\n\t boolean isYes = true;\n\t for (int i = 0; i <= max && isYes; i++) {\n\t\tisYes = left.getAns(i) == right.getAns(i);\n\t }\n\t System.out.println(isYes ? \"YES\" : \"NO\");\n\t str = in.next();\n\t} while (!\"#\".equals(str));\n }\n}\n\nabstract class Formula {\n static final Pattern PATTERN =\n\t                              Pattern\n\t                                .compile(\"^\\\\((.+)\\\\)$\");\n\n abstract boolean getAns(int bools);\n\n public static Formula of(String string) {\n\tif (\"T\".equals(string)) { return Teisu.T; }\n\tif (\"F\".equals(string)) { return Teisu.F; }\n\tif (\"a\".equals(string)) { return Var.a; }\n\tif (\"b\".equals(string)) { return Var.b; }\n\tif (\"c\".equals(string)) { return Var.c; }\n\tif (\"d\".equals(string)) { return Var.d; }\n\tif (\"e\".equals(string)) { return Var.e; }\n\tif (\"f\".equals(string)) { return Var.f; }\n\tif (\"g\".equals(string)) { return Var.g; }\n\tif (\"h\".equals(string)) { return Var.h; }\n\tif (\"i\".equals(string)) { return Var.i; }\n\tif (string.startsWith(\"-\")) {\n\t Not n = new Not(of(string.substring(1)));\n\t return n;\n\t}\n\tString f1 = null;\n\tString f2 = null;\n\tString op = null;\n\tStringBuilder sb = new StringBuilder();\n\tint kakko = 0;\n\tint posi = 1;\n\twhile (posi < string.length() - 1) {\n\t char c = string.charAt(posi++);\n\t if (c == '(') {\n\t\tkakko++;\n\t } else if (c == ')') {\n\t\tkakko--;\n\t }\n\t if (kakko == 0) {\n\t\tif (c == '+' || c == '*') {\n\t\t op = (c == '+') ? \"+\" : \"*\";\n\t\t f1 = sb.toString();\n\t\t sb.setLength(0);\n\t\t} else if (c == '-' && string.charAt(posi) == '>') {\n\t\t posi++;\n\t\t op = \"->\";\n\t\t f1 = sb.toString();\n\t\t sb.setLength(0);\n\t\t}else{\n\t\t sb.append(c);\n\t\t}\n\t } else {\n\t\tsb.append(c);\n\t }\n\t}\n\tf2 = sb.toString();\n\treturn new Ope(of(f1), op, of(f2));\n\n }\n\n}\n\nclass Teisu extends Formula {\n final boolean      bool;\n static final Teisu T = new Teisu(true);\n static final Teisu F = new Teisu(false);\n\n Teisu(boolean bool) {\n\tthis.bool = bool;\n }\n\n @Override\n boolean getAns(int bools) {\n\treturn bool;\n }\n}\n\nclass Var extends Formula {\n static final Var a = new Var(1);\n static final Var b = new Var(2);\n static final Var c = new Var(4);\n static final Var d = new Var(8);\n static final Var e = new Var(16);\n static final Var f = new Var(32);\n static final Var g = new Var(64);\n static final Var h = new Var(128);\n static final Var i = new Var(256);\n final int        var;\n\n Var(int var) {\n\tthis.var = var;\n }\n\n @Override\n boolean getAns(int bools) {\n\treturn var == (var & bools);\n }\n}\n\nclass Not extends Formula {\n final Formula f;\n\n Not(Formula f) {\n\tthis.f = f;\n }\n\n @Override\n boolean getAns(int bools) {\n\treturn !f.getAns(bools);\n }\n}\n\nclass Ope extends Formula {\n final Formula f1;\n final Formula f2;\n final String  op;\n\n Ope(Formula f1, String op, Formula f2) {\n\tthis.f1 = f1;\n\tthis.f2 = f2;\n\tthis.op = op;\n }\n\n @Override\n boolean getAns(int bools) {\n\tboolean result;\n\tif (\"*\".equals(op)) {\n\t result = f1.getAns(bools) && f2.getAns(bools);\n\t} else if (\"+\".equals(op)) {\n\t result = f1.getAns(bools) || f2.getAns(bools);\n\t} else {\n\t result = f1.getAns(bools) == false || f2.getAns(bools) == true;\n\t}\n\treturn result;\n }\n\n}"
  },
  {
    "language": "Java",
    "code": "import java.io.BufferedReader;\nimport java.io.IOException;\nimport java.io.InputStreamReader;\nimport java.util.ArrayDeque;\nimport java.util.Deque;\n\nimport static java.lang.Integer.parseInt;\n\n/**\n * Equation\n */\npublic class Main {\n\n\tstatic enum OP {NOT, AND, OR, IMP}\n\n\tpublic static void main(String[] args) throws IOException {\n\t\tBufferedReader br = new BufferedReader(new InputStreamReader(System.in));\n\t\tString line;\n\n\t\tMain main = new Main();\n\n\t\twhile ((line = br.readLine()) != null && !line.isEmpty()) {\n\n\t\t\tif (line.equals(\"#\")) break;\n\n\t\t\t//parse\n\t\t\tVar var = main.new Var();\n\t\t\tint max = -1;\n\t\t\tExp lside = null;\n\t\t\tExp rside = null;\n\n\t\t\tfor (String side : line.split(\"=\")) {\n\n\t\t\t\tDeque<OP> ops = new ArrayDeque<>();\n\t\t\t\tDeque<Exp> exps = new ArrayDeque<>();\n\t\t\t\tDeque<Character> signs = new ArrayDeque<>();\n\n\t\t\t\tfor (int i = 0; i < side.length(); i++) {\n\n\t\t\t\t\tchar c = side.charAt(i);\n\t\t\t\t\tboolean mono = false;\n\n\t\t\t\t\tswitch (c) {\n\t\t\t\t\t\tcase '(':\n\t\t\t\t\t\t\tsigns.add(c);\n\t\t\t\t\t\t\tbreak;\n\t\t\t\t\t\tcase ')': {\n\t\t\t\t\t\t\tOP op = ops.pollLast();\n\t\t\t\t\t\t\tExp s = exps.pollLast();\n\t\t\t\t\t\t\tExp f = exps.pollLast();\n\t\t\t\t\t\t\texps.add(main.new Exp(op, f, s));\n\t\t\t\t\t\t\tsigns.pollLast();\n\t\t\t\t\t\t\tmono = true;\n\t\t\t\t\t\t}\n\t\t\t\t\t\tbreak;\n\t\t\t\t\t\tcase '*':\n\t\t\t\t\t\t\tops.add(OP.AND);\n\t\t\t\t\t\t\tbreak;\n\t\t\t\t\t\tcase '+':\n\t\t\t\t\t\t\tops.add(OP.OR);\n\t\t\t\t\t\t\tbreak;\n\t\t\t\t\t\tcase '-':\n\t\t\t\t\t\t\tif (side.charAt(i + 1) == '>') {\n\t\t\t\t\t\t\t\tops.add(OP.IMP);\n\t\t\t\t\t\t\t\ti++;//skip '>'\n\t\t\t\t\t\t\t} else {\n\t\t\t\t\t\t\t\tops.add(OP.NOT);\n\t\t\t\t\t\t\t\tsigns.add(c);\n\t\t\t\t\t\t\t}\n\t\t\t\t\t\t\tbreak;\n\t\t\t\t\t\tdefault: {\n\t\t\t\t\t\t\texps.add(main.new Exp(c, var));\n\t\t\t\t\t\t\tmono = true;\n\t\t\t\t\t\t\tif (c != 'T' | c != 'F') {\n\t\t\t\t\t\t\t\tmax = Math.max(max, c - 'a' + 1);\n\t\t\t\t\t\t\t}\n\t\t\t\t\t\t}\n\t\t\t\t\t\tbreak;\n\t\t\t\t\t}\n\t\t\t\t\t//monominal?\n\t\t\t\t\tif (signs.peekLast() != null && mono) {\n\t\t\t\t\t\twhile (signs.peekLast() != null && signs.peekLast() == '-') {\n\t\t\t\t\t\t\tOP op = ops.pollLast();\n\t\t\t\t\t\t\tExp f = exps.pollLast();\n\t\t\t\t\t\t\texps.add(main.new Exp(op, f));\n\t\t\t\t\t\t\tsigns.pollLast();\n\t\t\t\t\t\t}\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t\tif (lside == null) {\n\t\t\t\t\tlside = exps.poll();\n\t\t\t\t\texps.clear();\n\t\t\t\t} else {\n\t\t\t\t\trside = exps.poll();\n\t\t\t\t\texps.clear();\n\t\t\t\t}\n\t\t\t}\n\n\t\t\t//debug\n//\t\t\tif (line.equals(lside.toString() + \"=\" + rside.toString())) {\n//\t\t\t\tSystem.out.println(line);\n//\t\t\t\tSystem.out.println(lside.toString() + \"=\" + rside.toString());\n//\t\t\t}\n\n\t\t\t//solve\n\t\t\tboolean ans = true;\n\t\t\tfor (int i = 0; i < 1 << max; i++) {\n\t\t\t\tvar.substitution(i);\n\t\t\t\tans &= (lside.value() == rside.value());\n\t\t\t}\n\t\t\tSystem.out.println(ans ? \"YES\" : \"NO\");\n\n\t\t}//end while\n\t} //end main\n\n\tclass Var {\n\n\t\t//a..k\n\t\tboolean[] values = new boolean[11];\n\n\t\tvoid substitution(int values) {\n\t\t\tfor (int i = 0; i < this.values.length; i++) {\n\t\t\t\tif ((values & 1 << i) != 0) {\n\t\t\t\t\tthis.values[i] = true;\n\t\t\t\t} else {\n\t\t\t\t\tthis.values[i] = false;\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\n\t\tboolean value(char name) {\n\t\t\tboolean ret = false;\n\t\t\tswitch (name) {\n\t\t\t\tcase 'T':\n\t\t\t\t\tret = true;\n\t\t\t\t\tbreak;\n\t\t\t\tcase 'F':\n\t\t\t\t\tret = false;\n\t\t\t\t\tbreak;\n\t\t\t\tdefault:\n\t\t\t\t\tret = values[name - 'a'];\n\t\t\t\t\tbreak;\n\t\t\t}\n\t\t\treturn ret;\n\t\t}\n\t}\n\n\tclass Exp {\n\n\t\tOP op;\n\t\tExp f, s;\n\t\tchar name;\n\t\tVar var;\n\n\t\tExp(OP op, Exp f, Exp s) {\n\t\t\tthis.op = op;\n\t\t\tthis.f = f;//first term\n\t\t\tthis.s = s;//second term\n\t\t}\n\n\t\tExp(OP op, Exp F) {\n\t\t\tthis.op = op;\n\t\t\tthis.f = F;\n\t\t}\n\n\t\tExp(char name, Var var) {\n\t\t\tthis.name = name;\n\t\t\tthis.var = var;\n\t\t}\n\n\t\tboolean value() {\n\t\t\tboolean ret = false;\n\t\t\tif (var != null) {\n\t\t\t\tret = var.value(name);\n\t\t\t} else {\n\t\t\t\tswitch (op) {\n\t\t\t\t\tcase NOT:\n\t\t\t\t\t\tret = !f.value();\n\t\t\t\t\t\tbreak;\n\t\t\t\t\tcase AND:\n\t\t\t\t\t\tret = f.value() && s.value();\n\t\t\t\t\t\tbreak;\n\t\t\t\t\tcase OR:\n\t\t\t\t\t\tret = f.value() || s.value();\n\t\t\t\t\t\tbreak;\n\t\t\t\t\tcase IMP:\n\t\t\t\t\t\tif (!f.value() | s.value()) ret = true;\n\t\t\t\t\t\tbreak;\n\t\t\t\t}\n\t\t\t}\n\t\t\treturn ret;\n\t\t}\n\n\t\tpublic String toString() {\n\t\t\tString ret = \"\";\n\t\t\tif (var != null) {\n\t\t\t\tret += name;\n\t\t\t} else {\n\t\t\t\tif (op == OP.NOT) {\n\t\t\t\t\tret = \"-\" + f.toString();\n\t\t\t\t} else {\n\t\t\t\t\tString _op = \"\";\n\t\t\t\t\tswitch (op) {\n\t\t\t\t\t\tcase AND:\n\t\t\t\t\t\t\t_op = \"*\";\n\t\t\t\t\t\t\tbreak;\n\t\t\t\t\t\tcase OR:\n\t\t\t\t\t\t\t_op = \"+\";\n\t\t\t\t\t\t\tbreak;\n\t\t\t\t\t\tcase IMP:\n\t\t\t\t\t\t\t_op = \"->\";\n\t\t\t\t\t\t\tbreak;\n\t\t\t\t\t}\n\t\t\t\t\tret = \"(\" + f.toString() + _op + s.toString() + \")\";\n\t\t\t\t}\n\t\t\t}\n\t\t\treturn ret;\n\t\t}\n\t}\n}"
  },
  {
    "language": "Java",
    "code": "import java.util.Scanner;\n\npublic class Main {\n\tpublic static String input;\n\tpublic static int p;\n\tpublic static int len;\n\tpublic static boolean[] alpha = new boolean[11];\n\tpublic static void main(String[] args){\n\t\tnew Main().run();\n\t\t//test();\n\t}\n\t\n//\tpublic static void test(){\n//\t\tint a = 0;\n//\t\tSystem.out.println(Character.getNumericValue('a'));\n//\t\tSystem.out.println(Character.getNumericValue('b'));\n//\t}\n\t\n\n\tpublic void run(){\n\t\tScanner sc = new Scanner(System.in);\n\t\tinput = sc.next();\n\t\twhile(input.equals(\"#\") == false){\n\t\t\tlen = input.length();\n\t\t\tp = 0;\n\t\t\tboolean left;\n\t\t\tboolean right;\n\t\t\tboolean bOK = true;\n\t\t\t//int c = 0;\n\t\t\tint bit = 0;\n\t\t\t\n\t\t\t//2^(11) - 1までやる\n\t\t\tfor(int i = 0; i < 0x800; i++){\n\t\t\t\t//c++;\n\t\t\t\tfor(int j = 0; j < 11; j++){\n\t\t\t\t\talpha[j] = bit2Bool(bit, j);\n\t\t\t\t}\n\t\t\t\tp = 0;\n\t\t\t\tleft = getNext();\n\t\t\t\t//\"=\"&#65533;&#65533;&#65533;i&#65533;&#1986;&#65533;\n\t\t\t\tp++;\n\t\t\t\t//System.out.println(\"right\");\n\t\t\t\tright = getNext();\n\t\t\t\t\n\t\t\t\tif(left != right){\n\t\t\t\t\t//System.out.println(\"a = \" + alpha[alpha2Int('a')] + \", b = \" + alpha[alpha2Int('b')] + \", left = \" + left + \", right = \"  + right);;\n\t\t\t\t\t//System.out.println(\"bad\");\n\t\t\t\t\tbOK = false;\n\t\t\t\t}\n\t\t\t\tbit++;\n\t\t\t}\n\t\t\t\n\t\t\tif(bOK){\n\t\t\t\tSystem.out.println(\"YES\");\n\t\t\t}\n\t\t\telse{\n\t\t\t\tSystem.out.println(\"NO\");\n\t\t\t}\n\t\t\tinput = sc.next();\n\t\t}\n\t}\n\t\n\t//bit目のビットが立っていればtrue\n\tpublic static boolean bit2Bool(int num, int bit){\n\t\tint tmp = num >> bit;\n\t\tif(tmp == 1){\n\t\t\treturn true;\n\t\t}\n\t\telse{\n\t\t\treturn false;\n\t\t}\n\t}\n\t\n//\tpublic static boolean int2Bool(int n){\n//\t\tif(n == 0){\n//\t\t\treturn false;\n//\t\t}\n//\t\telse{\n//\t\t\treturn true;\n//\t\t}\n//\t}\n\t\n//\tpublic static int alpha2Int(char ch){\n//\t\tint num = Character.getNumericValue(ch) - Character.getNumericValue('a');\n//\t\treturn num;\n//\t}\n\t\n\n\t//1&#65533;&#130;&#65533;formula&#65533;&#65533;&#65533;&#65533;&#65533;&#65533;\n\tpublic static boolean getNext(){\n\t\tboolean bRet = false;\n\t\tchar c = input.charAt(p);\n\t\t//System.out.println(\"getNext : p = \" + p + \", c = \" + c);\n\t\tswitch(c){\n\t\tcase 'T':\n\t\t\tp++;\n\t\t\tbRet = true;\n\t\t\tbreak;\n\t\tcase 'F':\n\t\t\tbRet = false;\n\t\t\tp++;\n\t\t\tbreak;\n\t\tcase 'a':\n\t\tcase 'b':\n\t\tcase 'c':\n\t\tcase 'd':\n\t\tcase 'e':\n\t\tcase 'f':\n\t\tcase 'g':\n\t\tcase 'h':\n\t\tcase 'i':\n\t\tcase 'j':\n\t\tcase 'k':\n\t\t\tbRet = alpha2Bool(c);\n\t\t\tp++;\n\t\t\tbreak;\n\t\tcase '(':\n\t\t\tp++;\n\t\t\tboolean left = getNext();\n\t\t\tboolean right;\n\t\t\tc = input.charAt(p);\n\t\t\tif(c == '*'){\n\t\t\t\tp++;\n\t\t\t\tright = getNext();\n\t\t\t\tbRet = left & right;\n\t\t\t}\n\t\t\telse if(c == '+'){\n\t\t\t\tp++;\n\t\t\t\tright = getNext();\n\t\t\t\tbRet = left | right;\n\t\t\t}\n\t\t\t//case c = ->\n\t\t\telse{\n\t\t\t\tp += 2;\n\t\t\t\tright = getNext();\n\t\t\t\tbRet = Imp(left , right);\n\t\t\t}\n\t\t\t//\")\"&#65533;&#65533;&#65533;&#65533;&#65533;&#258;&#65533;&#65533;&#65533;&#834;&#65533;&#65533;I\n\t\t\tp++;\n\t\t\tbreak;\n\n\t\tcase '-':\n\t\t\tp++;\n\t\t\tbRet = getNext();\n\t\t\tbRet = !bRet;\n\t\t\tbreak;\n\t\t}\n\n\t\treturn bRet;\n\t}\n\n\tpublic static boolean alpha2Bool(char ch){\n\t\tint num = Character.getNumericValue(ch) - Character.getNumericValue('a');\n\t\treturn alpha[num];\n\t}\n\n\tpublic static boolean Imp(boolean b1, boolean b2){\n\t\tif(b1 == true && b2 == false){\n\t\t\treturn false;\n\t\t}\n\t\telse{\n\t\t\treturn true;\n\t\t}\n\t}\n}"
  },
  {
    "language": "Java",
    "code": "import java.util.ArrayList;\nimport java.util.BitSet;\nimport java.util.PriorityQueue;\nimport java.util.Queue;\nimport java.util.Scanner;\n\npublic class Main{\n\tpublic static char[] s;\n\tpublic static int[] table;\n\tpublic static int n;\n\tpublic static void main(String[] args){\n\t\tScanner in = new Scanner(System.in);\n\t\twhile(true){\n\t\t\ts = in.next().toCharArray();\n\t\t\tif(s[0] == '#') break;\n\t\t\tint alps = 0;\n\t\t\tfor(int i=0; i<s.length; i++){\n\t\t\t\tif(s[i] < 'a' || 'z' < s[i]) continue;\n\t\t\t\talps |= 1<<s[i]-'a';\n\t\t\t}\n\t\t\tn = Integer.bitCount(alps);\n\t\t\ttable = new int[n];\n\t\t\tint idx = 0;\n\t\t\tfor(int i=0; i<15; i++){\n\t\t\t\tif((alps&1<<i)==0) continue;\n\t\t\t\ttable[idx++] = i;\n\t\t\t}\n\t\t\tSystem.out.println(dfs(0, 0) ? \"YES\" : \"NO\");\n\t\t}\n\t}\n\t\n\tpublic static boolean dfs(int idx, int state){\n\t\tif(idx == n){\n\t\t\tif(!check(state))\n\t\t\t\treturn false;\n\t\t\treturn true;\n\t\t}\n\t\tif(!dfs(idx+1, state|1<<table[idx]) || !dfs(idx+1, state))\n\t\t\treturn false;\n\t\treturn true;\n\t}\n\tpublic static int idx;\n\tpublic static boolean check(int state){\n\t\tidx = 0;\n\t\tst = state;\n\t\tboolean val = formula();\n\t\tidx++;\n\t\treturn val==formula();\n\t}\n\tpublic static int st;\n\tpublic static boolean[][] arr = {\n\t\t{true, true},\n\t\t{false,true}\n\t};\n\tpublic static boolean formula(){\n\t\tif(s[idx] == '-'){\n\t\t\tidx++;\n\t\t\treturn !formula();\n\t\t}else if(s[idx] == '('){\n\t\t\tidx++;\n\t\t\tboolean val = formula();\n\t\t\tif(s[idx] == '*'){\n\t\t\t\tidx++;\n\t\t\t\tval = val&formula();\n\t\t\t}else if(s[idx] == '+'){\n\t\t\t\tidx++;\n\t\t\t\tval = val|formula();\n\t\t\t}else{\n\t\t\t\tidx+=2;\n\t\t\t\tval = arr[val?1:0][formula()?1:0];\n\t\t\t}\n\t\t\tidx++;\n\t\t\treturn val;\n\t\t}else if(s[idx] == 'T'){\n\t\t\tidx++;\n\t\t\treturn true;\n\t\t}\n\t\telse if(s[idx] == 'F'){\n\t\t\tidx++;\n\t\t\treturn false;\n\t\t}\n\t\treturn (st&1<<s[idx++])>0;\n\t}\n\t\n}"
  },
  {
    "language": "Java",
    "code": "import java.util.*;\n\npublic class Main {\n\tString line ;\n\tint pos;\n\t\n\tprivate void doit(){\n\t\tScanner sc = new Scanner(System.in);\n\t\twhile(true){\n\t\t\tString str = sc.next() + \"#\";\n\t\t\tif(str.equals(\"##\")) break;\n\t\t\tstr = str.replaceAll(\"--\", \"\");\n\t\t\tArrayList<Character> list = new ArrayList<Character>();\n\t\t\tfor(int i=0; i < str.length();i++){\n\t\t\t\tchar temp = str.charAt(i);\n\t\t\t\tif('a' <= temp && temp <= 'k'){\n\t\t\t\t\tif(! list.contains(temp)){\n\t\t\t\t\t\tlist.add(temp);\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t}\n\t\t\tint len = list.size();\n\t\t\tboolean flg = true;\n\t\t\tfor(int i=0; i < (1 << len); i++){\n\t\t\t\tline = new String(str);\n\t\t\t\tpos = 0;\n\t\t\t\tfor(int j = 0; j < len; j++){\n\t\t\t\t\tString temp = \"\"+list.get(j);\n\t\t\t\t\t\n\t\t\t\t\tif((i & (1 << j)) != 0){\n\t\t\t\t\t\tline = line.replaceAll(temp, \"T\");\n\t\t\t\t\t}\n\t\t\t\t\telse{\n\t\t\t\t\t\tline = line.replaceAll(temp, \"F\");\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t\tboolean res = eval();\n\t\t\t\tif(! res){\n\t\t\t\t\tflg = false;\n\t\t\t\t\tbreak;\n\t\t\t\t}\n\t\t\t}\n\t\t\tif(flg) System.out.println(\"YES\");\n\t\t\telse System.out.println(\"NO\");\n\t\t}\n\t}\n\t\n\tprivate boolean eval() {\n\t\tboolean left = exp();\n\t\tchar op = line.charAt(pos++);\n\t\tboolean right = exp();\n\t\treturn left == right;\n\t}\n\n\tprivate boolean exp() {\n\t\tchar temp = line.charAt(pos++);\n\t\tswitch(temp){\n\t\tcase 'T':\n\t\t\treturn true;\n\t\tcase 'F':\n\t\t\treturn false;\n\t\tcase '-':\n\t\t\treturn (! exp());\n\t\tcase '(':\n\t\t\tboolean left = exp();\n\t\t\tchar op = line.charAt(pos++);\n\t\t\tboolean right;\n\t\t\tswitch(op){\n\t\t\tcase '*':\n\t\t\t\tright = exp();\n\t\t\t\tpos++;\n\t\t\t\treturn (left && right);\n\t\t\tcase '+':\n\t\t\t\tright = exp();\n\t\t\t\tpos++;\n\t\t\t\treturn (left || right);\n\t\t\tcase '-':\n\t\t\t\tpos++;\n\t\t\t\tright = exp();\n\t\t\t\tpos++;\n\t\t\t\tboolean res = getA(left, right);\n\t\t\t\treturn res;\n\t\t\t}\n\t\t}\n\t\treturn false;\n\t}\n\n\tprivate boolean getA(boolean left, boolean right) {\n\t\tif(left && ! right){\n\t\t\treturn false;\n\t\t}\n\t\treturn true;\n\t}\n\n\tpublic static void main(String[] args) {\n\t\tMain obj = new Main();\n\t\tobj.doit();\n\t}\n}"
  },
  {
    "language": "Java",
    "code": "import java.util.ArrayList;\nimport java.util.BitSet;\nimport java.util.PriorityQueue;\nimport java.util.Queue;\nimport java.util.Scanner;\n\npublic class Main{\n\tpublic static char[] s;\n\tpublic static int[] table;\n\tpublic static int n;\n\tpublic static void main(String[] args){\n\t\tScanner in = new Scanner(System.in);\n\t\twhile(true){\n\t\t\ts = in.next().toCharArray();\n\t\t\tif(s[0] == '#') break;\n\t\t\tint alps = 0;\n\t\t\tfor(int i=0; i<s.length; i++){\n\t\t\t\tif(s[i] < 'a' || 'z' < s[i]) continue;\n\t\t\t\talps |= 1<<s[i]-'a';\n\t\t\t}\n\t\t\tn = Integer.bitCount(alps);\n\t\t\ttable = new int[n];\n\t\t\tint idx = 0;\n\t\t\tfor(int i=0; i<15; i++){\n\t\t\t\tif((alps&1<<i)==0) continue;\n\t\t\t\ttable[idx++] = i;\n\t\t\t}\n//\t\t\tstate.clear();\n\t\t\tSystem.out.println(dfs(0, 0) ? \"YES\" : \"NO\");\n\t\t}\n\t}\n\t\n//\tpublic static BitSet state = new BitSet(15);\n\tpublic static boolean dfs(int idx, int state){\n\t\tif(idx == n){\n\t\t\tif(state == 3)\n\t\t\t\tSystem.err.println();\n\t\t\tif(!check(state))\n\t\t\t\treturn false;\n\t\t\treturn true;\n\t\t}\n\t\tif(!dfs(idx+1, state|1<<table[idx]) || !dfs(idx+1, state))\n\t\t\treturn false;\n\t\treturn true;\n\t}\n\tpublic static int idx;\n\tpublic static boolean check(int state){\n\t\tidx = 0;\n\t\tst = state;\n\t\tboolean val = formula();\n\t\tidx++;\n\t\treturn val==formula();\n\t}\n\tpublic static int st;\n\tpublic static boolean[][] arr = {\n\t\t{true, true},\n\t\t{false,true}\n\t};\n\tpublic static boolean formula(){\n\t\tif(s[idx] == '-'){\n\t\t\tidx++;\n\t\t\treturn !formula();\n\t\t}else if(s[idx] == '('){\n\t\t\tidx++;\n\t\t\tboolean val = formula();\n\t\t\tif(s[idx] == '*'){\n\t\t\t\tidx++;\n\t\t\t\tval = val&formula();\n\t\t\t}else if(s[idx] == '+'){\n\t\t\t\tidx++;\n\t\t\t\tval = val|formula();\n\t\t\t}else{\n\t\t\t\tidx+=2;\n\t\t\t\tval = arr[val?1:0][formula()?1:0];\n\t\t\t}\n\t\t\tidx++;\n\t\t\treturn val;\n\t\t}else if(s[idx] == 'T'){\n\t\t\tidx++;\n\t\t\treturn true;\n\t\t}\n\t\telse if(s[idx] == 'F'){\n\t\t\tidx++;\n\t\t\treturn false;\n\t\t}\n\t\treturn (st&1<<s[idx++])>0;\n\t}\n\t\n}"
  },
  {
    "language": "Java",
    "code": "import java.io.BufferedReader;\nimport java.io.IOException;\nimport java.io.InputStreamReader;\nimport java.util.ArrayDeque;\nimport java.util.Deque;\n\nimport static java.lang.Integer.parseInt;\n\n/**\n * Equation\n */\npublic class Main {\n\n\tstatic enum OP {NOT, AND, OR, IMP}\n\n\tpublic static void main(String[] args) throws IOException {\n\t\tBufferedReader br = new BufferedReader(new InputStreamReader(System.in));\n\t\tString line;\n\n\t\tMain main = new Main();\n\n\t\twhile ((line = br.readLine()) != null && !line.isEmpty()) {\n\n\t\t\tif (line.equals(\"#\")) break;\n\n\t\t\t//parse\n\t\t\tVar var = main.new Var();\n\t\t\tint max = -1;\n\t\t\tExp lside = null;\n\t\t\tExp rside = null;\n\n\t\t\tfor (String side : line.split(\"=\")) {\n\n\t\t\t\tDeque<OP> ops = new ArrayDeque<>();\n\t\t\t\tDeque<Exp> exps = new ArrayDeque<>();\n\t\t\t\tDeque<Character> signs = new ArrayDeque<>();\n\n\t\t\t\tfor (int i = 0; i < side.length(); i++) {\n\n\t\t\t\t\tchar c = side.charAt(i);\n\t\t\t\t\tboolean mono = false;\n\n\t\t\t\t\tswitch (c) {\n\t\t\t\t\t\tcase '(':\n\t\t\t\t\t\t\tsigns.add(c);\n\t\t\t\t\t\t\tbreak;\n\t\t\t\t\t\tcase ')': {\n\t\t\t\t\t\t\tOP op = ops.pollLast();\n\t\t\t\t\t\t\tExp s = exps.pollLast();\n\t\t\t\t\t\t\tExp f = exps.pollLast();\n\t\t\t\t\t\t\texps.add(main.new Exp(op, f, s));\n\t\t\t\t\t\t\tsigns.pollLast();\n\t\t\t\t\t\t\tmono = true;\n\t\t\t\t\t\t}\n\t\t\t\t\t\tbreak;\n\t\t\t\t\t\tcase '*':\n\t\t\t\t\t\t\tops.add(OP.AND);\n\t\t\t\t\t\t\tbreak;\n\t\t\t\t\t\tcase '+':\n\t\t\t\t\t\t\tops.add(OP.OR);\n\t\t\t\t\t\t\tbreak;\n\t\t\t\t\t\tcase '-':\n\t\t\t\t\t\t\tif (side.charAt(i + 1) == '>') {\n\t\t\t\t\t\t\t\tops.add(OP.IMP);\n\t\t\t\t\t\t\t\ti++;//skip '>'\n\t\t\t\t\t\t\t} else {\n\t\t\t\t\t\t\t\tops.add(OP.NOT);\n\t\t\t\t\t\t\t\tsigns.add(c);\n\t\t\t\t\t\t\t}\n\t\t\t\t\t\t\tbreak;\n\t\t\t\t\t\tdefault: {\n\t\t\t\t\t\t\texps.add(main.new Exp(c, var));\n\t\t\t\t\t\t\tmono = true;\n\t\t\t\t\t\t\tif (c != 'T' | c != 'F') {\n\t\t\t\t\t\t\t\tmax = Math.max(max, c - 'a');\n\t\t\t\t\t\t\t}\n\t\t\t\t\t\t}\n\t\t\t\t\t}\n\t\t\t\t\t//monominal?\n\t\t\t\t\tif (signs.peekLast() != null && mono) {\n\t\t\t\t\t\twhile (signs.peekLast() != null && signs.peekLast() == '-') {\n\t\t\t\t\t\t\tOP op = ops.pollLast();\n\t\t\t\t\t\t\tExp f = exps.pollLast();\n\t\t\t\t\t\t\texps.add(main.new Exp(op, f));\n\t\t\t\t\t\t\tsigns.pollLast();\n\t\t\t\t\t\t}\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t\tif (lside == null) {\n\t\t\t\t\tlside = exps.poll();\n\t\t\t\t\texps.clear();\n\t\t\t\t} else {\n\t\t\t\t\trside = exps.poll();\n\t\t\t\t\texps.clear();\n\t\t\t\t}\n\t\t\t}\n\n\t\t\t//debug\n\t\t\t//System.out.println(lside.toString() + \"=\" + rside.toString());\n\n\t\t\t//solve\n\t\t\tboolean ans = true;\n\t\t\tfor (int i = 0; i < 1 << (max + 1); i++) {\n\t\t\t\tvar.substitution(i);\n\t\t\t\tans &= (lside.value() == rside.value());\n\t\t\t}\n\t\t\tSystem.out.println(ans ? \"YES\" : \"NO\");\n\n\t\t}//end while\n\t} //end main\n\n\tclass Var {\n\n\t\t//a..k\n\t\tboolean[] values = new boolean[11];\n\n\t\tvoid substitution(int values) {\n\t\t\tfor (int i = 0; i < this.values.length; i++) {\n\t\t\t\tif ((values & 1 << i) == 1) {\n\t\t\t\t\tthis.values[i] = true;\n\t\t\t\t} else {\n\t\t\t\t\tthis.values[i] = false;\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\n\t\tboolean value(char name) {\n\t\t\tboolean ret = false;\n\t\t\tswitch (name) {\n\t\t\t\tcase 'T':\n\t\t\t\t\tret = true;\n\t\t\t\t\tbreak;\n\t\t\t\tcase 'F':\n\t\t\t\t\tret = false;\n\t\t\t\t\tbreak;\n\t\t\t\tdefault:\n\t\t\t\t\tret = values[name - 'a'];\n\t\t\t}\n\t\t\treturn ret;\n\t\t}\n\t}\n\n\tclass Exp {\n\n\t\tOP op;\n\t\tExp f, s;\n\t\tchar name;\n\t\tVar var;\n\n\t\tExp(OP op, Exp f, Exp s) {\n\t\t\tthis.op = op;\n\t\t\tthis.f = f;//first term\n\t\t\tthis.s = s;//second term\n\t\t}\n\n\t\tExp(OP op, Exp F) {\n\t\t\tthis.op = op;\n\t\t\tthis.f = F;\n\t\t}\n\n\t\tExp(char name, Var var) {\n\t\t\tthis.name = name;\n\t\t\tthis.var = var;\n\t\t}\n\n\t\tboolean value() {\n\t\t\tboolean ret = false;\n\t\t\tif (var != null) {\n\t\t\t\tret = var.value(name);\n\t\t\t} else {\n\t\t\t\tswitch (op) {\n\t\t\t\t\tcase NOT:\n\t\t\t\t\t\tret = !f.value();\n\t\t\t\t\t\tbreak;\n\t\t\t\t\tcase AND:\n\t\t\t\t\t\tret = f.value() && s.value();\n\t\t\t\t\t\tbreak;\n\t\t\t\t\tcase OR:\n\t\t\t\t\t\tret = f.value() || s.value();\n\t\t\t\t\t\tbreak;\n\t\t\t\t\tcase IMP:\n\t\t\t\t\t\tif (!f.value() | s.value()) ret = true;\n\t\t\t\t}\n\t\t\t}\n\t\t\treturn ret;\n\t\t}\n\n\t\tpublic String toString() {\n\t\t\tString ret = \"\";\n\t\t\tif (var != null) {\n\t\t\t\tret += name;\n\t\t\t} else {\n\t\t\t\tif (op == OP.NOT) {\n\t\t\t\t\tret = \"-\" + f.toString();\n\t\t\t\t} else {\n\t\t\t\t\tString _op = \"\";\n\t\t\t\t\tswitch (op) {\n\t\t\t\t\t\tcase AND:\n\t\t\t\t\t\t\t_op = \"*\";\n\t\t\t\t\t\t\tbreak;\n\t\t\t\t\t\tcase OR:\n\t\t\t\t\t\t\t_op = \"+\";\n\t\t\t\t\t\t\tbreak;\n\t\t\t\t\t\tcase IMP:\n\t\t\t\t\t\t\t_op = \"->\";\n\t\t\t\t\t\t\tbreak;\n\t\t\t\t\t}\n\t\t\t\t\tret = \"(\" + f.toString() + _op + s.toString() + \")\";\n\t\t\t\t}\n\t\t\t}\n\t\t\treturn ret;\n\t\t}\n\t}\n}"
  },
  {
    "language": "Java",
    "code": "public class Main {\n\n\tabstract class P {\n\t\tabstract boolean getValue();\n\t}\n\n\tclass AND extends P {\n\t\tP left;\n\t\tP right;\n\n\t\tpublic AND(P l, P r) {\n\t\t\tleft = l;\n\t\t\tright = r;\n\t\t}\n\n\t\tboolean getValue() {\n\t\t\treturn left.getValue() && right.getValue();\n\t\t}\n\n\t\tpublic String toString(){\n\t\t\treturn \"(\"+left+\"∧\"+right+\")\";\n\t\t}\n\t}\n\n\tclass OR extends P {\n\t\tP left;\n\t\tP right;\n\n\t\tpublic OR(P l, P r) {\n\t\t\tleft = l;\n\t\t\tright = r;\n\t\t}\n\n\t\tboolean getValue() {\n\t\t\treturn left.getValue() || right.getValue();\n\t\t}\n\t\tpublic String toString(){\n\t\t\treturn \"(\"+left+\"∨\"+right+\")\";\n\t\t}\n\t}\n\n\tclass ARROW extends P {\n\t\tP left;\n\t\tP right;\n\n\t\tpublic ARROW(P l, P r) {\n\t\t\tleft = l;\n\t\t\tright = r;\n\t\t}\n\n\t\tboolean getValue() {\n\t\t\treturn !left.getValue() || right.getValue();\n\t\t}\n\t\tpublic String toString(){\n\t\t\treturn \"(\"+left+\"→\"+right+\")\";\n\t\t}\n\t}\n\n\tclass NOT extends P {\n\t\tP exp;\n\n\t\tpublic NOT(P e) {\n\t\t\tthis.exp = e;\n\t\t}\n\n\t\tboolean getValue() {\n\t\t\treturn !exp.getValue();\n\t\t}\n\t\tpublic String toString(){\n\t\t\treturn \"¬\"+exp;\n\t\t}\n\t}\n\n\tclass PARAM extends P {\n\t\tint hensuu;\n\n\t\tpublic PARAM(int val) {\n\t\t\thensuu = val;\n\t\t}\n\n\t\tboolean getValue() {\n\t\t\treturn bmap[hensuu];\n\t\t}\n\t\tpublic String toString(){\n\t\t\treturn hensuu+\"\";\n\t\t}\n\t}\n\n\tclass TF extends P {\n\t\tboolean b;\n\n\t\tpublic TF(boolean val) {\n\t\t\tb = val;\n\t\t}\n\n\t\tboolean getValue() {\n\t\t\treturn b;\n\t\t}\n\t\tpublic String toString(){\n\t\t\treturn b?\"T\":\"F\";\n\t\t}\n\t}\n\n\tclass EQUAL extends P {\n\t\tP l;\n\t\tP r;\n\n\t\tpublic EQUAL(P le, P ri) {\n\t\t\tl = le;\n\t\t\tr = ri;\n\t\t}\n\n\t\tboolean getValue() {\n\t\t\treturn l.getValue() == r.getValue();\n\t\t}\n\t\tpublic String toString(){\n\t\t\treturn l+\"=\"+r;\n\t\t}\n\t}\n\n\tboolean[] bmap;\n\n\tP l;\n\tboolean isleft;\n\n\tpublic EQUAL eq(String str) {\n\t\tint eq = str.indexOf(\"=\");\n\t\treturn new EQUAL(formula(str.substring(0, eq)), formula(str.substring(\n\t\t\t\teq + 1, str.length())));\n\t}\n\n\tpublic P formula(String str) {\n\t\tif (str.length() == 1) {\n\t\t\tchar c = str.charAt(0);\n\t\t\tif (c == 'T') {\n\t\t\t\treturn new TF(true);\n\t\t\t}\n\t\t\tif (c == 'F') {\n\t\t\t\treturn new TF(false);\n\t\t\t}\n\t\t\tif ('a' <= c && c <= 'k') {\n\t\t\t\treturn new PARAM(c - 'a');\n\t\t\t}\n\t\t}\n\t\t// 区切り点を捜索\n\t\tif (str.charAt(0) == '-') {\n\t\t\tP node = formula(str.substring(1));\n\t\t\treturn new NOT(node);\n\t\t}\n\t\tif (str.charAt(0) == '(') {\n\t\t\tint ca = 0;\n\t\t\tfor (int i = 1;; i++) {\n\t\t\t\tchar c = str.charAt(i);\n\t\t\t\tswitch (c) {\n\t\t\t\tcase '(':\n\t\t\t\t\tca++;\n\t\t\t\t\tbreak;\n\t\t\t\tcase ')':\n\t\t\t\t\tca--;\n\t\t\t\t\tbreak;\n\t\t\t\t}\n\t\t\t\tif (ca > 0) {\n\t\t\t\t\tcontinue;\n\t\t\t\t}\n\t\t\t\tswitch (c) {\n\t\t\t\tcase '+':\n\t\t\t\t\tP l1 = formula(str.substring(1, i));\n\t\t\t\t\tP r1 = formula(str.substring(i + 1, str.length() - 1));\n\t\t\t\t\treturn new OR(l1, r1);\n\t\t\t\tcase '*':\n\t\t\t\t\tP l2 = formula(str.substring(1, i));\n\t\t\t\t\tP r2 = formula(str.substring(i + 1, str.length() - 1));\n\t\t\t\t\treturn new AND(l2, r2);\n\t\t\t\tcase '-':\n\t\t\t\t\tif (str.charAt(i + 1) != '>') {\n\t\t\t\t\t\tbreak;\n\t\t\t\t\t}\n\t\t\t\t\tP l3 = formula(str.substring(1, i));\n\t\t\t\t\tP r3 = formula(str.substring(i + 2, str.length() - 1));\n\t\t\t\t\treturn new ARROW(l3, r3);\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t\treturn null;\n\t}\n\n\tpublic void run() throws Exception {\n\t\tScanner sc = new Scanner(System.in);\n\n\t\twhile (true) {\n\t\t\tString str = sc.next();\n\t\t\tif (str.equals(\"#\")) {\n\t\t\t\tbreak;\n\t\t\t}\n\t\t\tEQUAL eq = eq(str);\n\n\t\t\tboolean res = true;\n\t\t\tbmap = new boolean[11];\n\t\t\tfor (int p = 0; p < (1 << 11); p++) {\n\t\t\t\tfor (int i = 0; i < 11; i++) {\n\t\t\t\t\tbmap[i] = (p / (1 << i)) % 2 == 1;\n\t\t\t\t}\n\t\t\t\tif (!eq.getValue()) {\n\t\t\t\t\tres = false;\n\t\t\t\t\tbreak;\n\t\t\t\t}\n\t\t\t}\n\t\t\tpr(res ? \"YES\" : \"NO\");\n\t\t\t/*\n\t\t\t * if('#'==st.nextToken()){ break; }\n\t\t\t */\n\t\t\t// isleft=true;\n\t\t\t// st.pushBack();\n\t\t\tformula(str);\n\t\t}\n\t}\n\n\tpublic static void main(String[] _) throws Exception {\n\t\tnew Main().run();\n\t}\n\n\tpublic static void pr(Object o) {\n\t\tSystem.out.println(o);\n\t}\n}"
  },
  {
    "language": "Java",
    "code": "import java.util.*;\nimport static java.lang.System.*;\n\npublic class Main {\n\n\tScanner sc = new Scanner(in);\n\t\n\tchar[] eq;\n\tchar[] eq1, eq2;\n\tboolean[] as = new boolean[11];\n\tboolean[] check = new boolean[11];\n\t\n\tboolean flag;\n\tvoid calc(int depth) {\n\t\tif (depth == 11) {\n\t\t\tboolean a, b;\n\t\t\teq = eq1;\n\t\t\tindex = 0;\n\t\t\ta = F();\n\t\t\teq = eq2;\n\t\t\tindex = 0;\n\t\t\tb = F();\n\t\t\tif (a != b)\n\t\t\t\tflag = false;\n\t\t} else {\n\t\t\tif (flag) {\n\t\t\t\tas[depth] = false;\n\t\t\t\tcalc(depth+1);\n\t\t\t\tas[depth] = true;\n\t\t\t\tcalc(depth+1);\n\t\t\t}\n\t\t}\n\t}\n\t\n\tint index;\n\tint token;\n\tfinal int VAL = -1;\n\tboolean value;\n\tvoid gettoken() {\n\t\tchar ch = eq[index++];\n\t\tif (ch == '+' || ch == '*' || ch == '(' || ch == ')') {\n\t\t\ttoken = ch;\n\t\t\treturn;\n\t\t} else if (ch == '-') {\n\t\t\tif (eq[index] == '>') {\n\t\t\t\tindex++;\n\t\t\t\ttoken = '>';\n\t\t\t\treturn;\n\t\t\t} else {\n\t\t\t\ttoken = ch;\n\t\t\t\treturn;\n\t\t\t}\n\t\t} else {\n\t\t\ttoken = VAL;\n\t\t\tswitch(ch) {\n\t\t\tcase 'T':\n\t\t\t\tvalue = true; break;\n\t\t\tcase 'F':\n\t\t\t\tvalue = false; break;\n\t\t\tcase 'a':\n\t\t\t\tvalue = as[0]; break;\n\t\t\tcase 'b':\n\t\t\t\tvalue = as[1]; break;\n\t\t\tcase 'c':\n\t\t\t\tvalue = as[2]; break;\n\t\t\tcase 'd':\n\t\t\t\tvalue = as[3]; break;\n\t\t\tcase 'e':\n\t\t\t\tvalue = as[4]; break;\n\t\t\tcase 'f':\n\t\t\t\tvalue = as[5]; break;\n\t\t\tcase 'g':\n\t\t\t\tvalue = as[6]; break;\n\t\t\tcase 'h':\n\t\t\t\tvalue = as[7]; break;\n\t\t\tcase 'i':\n\t\t\t\tvalue = as[8]; break;\n\t\t\tcase 'j':\n\t\t\t\tvalue = as[9]; break;\n\t\t\tcase 'k':\n\t\t\t\tvalue = as[10]; break;\n\t\t\t}\n\t\t}\n\t}\n\t\n\tboolean F() {\n\t\tboolean v, vnext;\n\t\tint savetoken;\n\t\tgettoken();\n\t\tif (token == VAL) {\n\t\t\treturn value;\n\t\t} else if (token == '-') {\n\t\t\treturn !F();\n\t\t} else if (token == '(') {\n\t\t\tv = F();\n\t\t\tgettoken();\n\t\t\tsavetoken = token;\n\t\t\tvnext = F();\n\t\t\tgettoken();\n\t\t\tif (token != ')') out.println(\"err\");\n\t\t\tif (savetoken == '+') {\n\t\t\t\treturn v || vnext;\n\t\t\t} else if (savetoken == '*') {\n\t\t\t\treturn v && vnext;\n\t\t\t} else if (savetoken == '>') {\n\t\t\t\tif (!v) return true;\n\t\t\t\telse return vnext;\n\t\t\t}\n\t\t\t\n\t\t}\n\t\treturn false;\n\t}\n\t\n\tvoid run() {\n\t\tString s;\n\t\tStringTokenizer st;\n\t\twhile (true) {\n\t\t\ts = sc.nextLine();\n\t\t\tif (s.equals(\"#\"))\n\t\t\t\tbreak;\n\t\t\tst = new StringTokenizer(s,\"=\");\n\t\t\teq1 = st.nextToken().toCharArray();\n\t\t\teq2 = st.nextToken().toCharArray();\n\t\t\tflag = true;\n\t\t\tcalc(0);\n\t\t\tif (flag)\n\t\t\t\tout.println(\"YES\");\n\t\t\telse\n\t\t\t\tout.println(\"N0\");\n\t\t}\n\t}\n\t\n\tpublic static void main(String[] args) {\n\t\tnew Main().run();\n\t}\n}"
  },
  {
    "language": "Java",
    "code": "import java.io.BufferedReader;\nimport java.io.IOException;\nimport java.io.InputStreamReader;\nimport java.util.ArrayDeque;\nimport java.util.Deque;\n\nimport static java.lang.Integer.parseInt;\n\n/**\n * Equation\n */\npublic class Main {\n\n\tstatic enum OP {NOT, AND, OR, IMP}\n\n\tpublic static void main(String[] args) throws IOException {\n\t\tBufferedReader br = new BufferedReader(new InputStreamReader(System.in));\n\t\tString line;\n\n\t\tMain main = new Main();\n\n\t\twhile ((line = br.readLine()) != null && !line.isEmpty()) {\n\n\t\t\tif (line.equals(\"#\")) break;\n\n\t\t\t//parse\n\t\t\tVar var = main.new Var();\n\t\t\tint max = -1;\n\t\t\tExp lside = null;\n\t\t\tExp rside = null;\n\n\t\t\tfor (String side : line.split(\"=\")) {\n\t\t\t\t\n\t\t\t\tDeque<OP> ops = new ArrayDeque<>();\n\t\t\t\tDeque<Exp> exps = new ArrayDeque<>();\n\t\t\t\tDeque<Character> signs = new ArrayDeque<>();\n\n\t\t\t\tfor (int i = 0; i < side.length(); i++) {\n\n\t\t\t\t\tchar c = side.charAt(i);\n\t\t\t\t\tboolean mono = false;\n\n\t\t\t\t\tswitch (c) {\n\t\t\t\t\t\tcase '(':\n\t\t\t\t\t\t\tsigns.add(c);\n\t\t\t\t\t\t\tbreak;\n\t\t\t\t\t\tcase ')': {\n\t\t\t\t\t\t\tOP op = ops.pollLast();\n\t\t\t\t\t\t\tExp s = exps.pollLast();\n\t\t\t\t\t\t\tExp f = exps.pollLast();\n\t\t\t\t\t\t\texps.add(main.new Exp(op, f, s));\n\t\t\t\t\t\t\tsigns.pollLast();\n\t\t\t\t\t\t\tmono = true;\n\t\t\t\t\t\t}\n\t\t\t\t\t\tbreak;\n\t\t\t\t\t\tcase '*':\n\t\t\t\t\t\t\tops.add(OP.AND);\n\t\t\t\t\t\t\tbreak;\n\t\t\t\t\t\tcase '+':\n\t\t\t\t\t\t\tops.add(OP.OR);\n\t\t\t\t\t\t\tbreak;\n\t\t\t\t\t\tcase '-':\n\t\t\t\t\t\t\tif (side.charAt(i + 1) == '>') {\n\t\t\t\t\t\t\t\tops.add(OP.IMP);\n\t\t\t\t\t\t\t\ti++;//skip '>'\n\t\t\t\t\t\t\t} else {\n\t\t\t\t\t\t\t\tops.add(OP.NOT);\n\t\t\t\t\t\t\t\tsigns.add(c);\n\t\t\t\t\t\t\t}\n\t\t\t\t\t\t\tbreak;\n\t\t\t\t\t\tdefault: {\n\t\t\t\t\t\t\texps.add(main.new Exp(c, var));\n\t\t\t\t\t\t\tmono = true;\n\t\t\t\t\t\t\tif (c != 'T' | c != 'F') {\n\t\t\t\t\t\t\t\tmax = Math.max(max, c - 'a');\n\t\t\t\t\t\t\t}\n\t\t\t\t\t\t}\n\t\t\t\t\t}\n\t\t\t\t\t//monominal?\n\t\t\t\t\tif (mono) {\n\t\t\t\t\t\tif (signs.peekLast() != null && signs.peekLast() == '-') {\n\t\t\t\t\t\t\tOP op = ops.pollLast();\n\t\t\t\t\t\t\tExp f = exps.pollLast();\n\t\t\t\t\t\t\texps.add(main.new Exp(op, f));\n\t\t\t\t\t\t\tsigns.pollLast();\n\t\t\t\t\t\t}\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t\tif (lside == null) {\n\t\t\t\t\tlside = exps.poll();\n\t\t\t\t\texps.clear();\n\t\t\t\t} else {\n\t\t\t\t\trside = exps.poll();\n\t\t\t\t\texps.clear();\n\t\t\t\t}\n\t\t\t}\n\n\t\t\t//solve\n\t\t\tboolean ans = true;\n\t\t\tfor (int i = 0; i < 1 << (max + 1); i++) {\n\t\t\t\tvar.substitution(i);\n\t\t\t\tans &= (lside.value() == rside.value());\n\t\t\t}\n\t\t\tSystem.out.println(ans ? \"YES\" : \"NO\");\n\n\t\t}//end while\n\t} //end main\n\n\tclass Var {\n\n\t\t//a..k\n\t\tboolean[] values = new boolean[11];\n\n\t\tvoid substitution(int values) {\n\t\t\tfor (int i = 0; i < this.values.length; i++) {\n\t\t\t\tif ((values & 1 << i) == 1) {\n\t\t\t\t\tthis.values[i] = true;\n\t\t\t\t} else {\n\t\t\t\t\tthis.values[i] = false;\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\n\t\tboolean value(char name) {\n\t\t\tboolean ret = false;\n\t\t\tswitch (name) {\n\t\t\t\tcase 'T':\n\t\t\t\t\tret = true;\n\t\t\t\t\tbreak;\n\t\t\t\tcase 'F':\n\t\t\t\t\tret = false;\n\t\t\t\t\tbreak;\n\t\t\t\tdefault:\n\t\t\t\t\tret = values[name - 'a'];\n\t\t\t}\n\t\t\treturn ret;\n\t\t}\n\t}\n\n\tclass Exp {\n\n\t\tOP op;\n\t\tExp f, s;\n\t\tchar name;\n\t\tVar var;\n\n\t\tExp(OP op, Exp f, Exp s) {\n\t\t\tthis.op = op;\n\t\t\tthis.f = f;//first term\n\t\t\tthis.s = s;//second term\n\t\t}\n\n\t\tExp(OP op, Exp F) {\n\t\t\tthis.op = op;\n\t\t\tthis.f = F;\n\t\t}\n\n\t\tExp(char name, Var var) {\n\t\t\tthis.name = name;\n\t\t\tthis.var = var;\n\t\t}\n\n\t\tboolean value() {\n\t\t\tboolean ret = false;\n\t\t\tif (var != null) {\n\t\t\t\tret = var.value(name);\n\t\t\t} else {\n\t\t\t\tswitch (op) {\n\t\t\t\t\tcase NOT:\n\t\t\t\t\t\tret = !f.value();\n\t\t\t\t\t\tbreak;\n\t\t\t\t\tcase AND:\n\t\t\t\t\t\tret = f.value() && s.value();\n\t\t\t\t\t\tbreak;\n\t\t\t\t\tcase OR:\n\t\t\t\t\t\tret = f.value() || s.value();\n\t\t\t\t\t\tbreak;\n\t\t\t\t\tcase IMP:\n\t\t\t\t\t\tif (!f.value() | s.value()) ret = true;\n\t\t\t\t}\n\t\t\t}\n\t\t\treturn ret;\n\t\t}\n\t}\n}"
  },
  {
    "language": "Java",
    "code": "import java.io.BufferedReader;\nimport java.io.IOException;\nimport java.io.InputStreamReader;\nimport java.util.ArrayDeque;\nimport java.util.Deque;\n\nimport static java.lang.Integer.parseInt;\n\n/**\n * Equation\n */\npublic class Main {\n\n\tstatic enum OP {NOT, AND, OR, IMP}\n\n\tpublic static void main(String[] args) throws IOException {\n\t\tBufferedReader br = new BufferedReader(new InputStreamReader(System.in));\n\t\tString line;\n\n\t\tMain main = new Main();\n\n\t\twhile ((line = br.readLine()) != null && !line.isEmpty()) {\n\n\t\t\tif (line.equals(\"#\")) break;\n\n\t\t\t//parse\n\t\t\tVar var = main.new Var();\n\t\t\tint max = -1;\n\t\t\tExp lside = null;\n\t\t\tExp rside = null;\n\n\t\t\tfor (String side : line.split(\"=\")) {\n\n\t\t\t\tDeque<OP> ops = new ArrayDeque<>();\n\t\t\t\tDeque<Exp> exps = new ArrayDeque<>();\n\t\t\t\tDeque<Character> signs = new ArrayDeque<>();\n\n\t\t\t\tfor (int i = 0; i < side.length(); i++) {\n\n\t\t\t\t\tchar c = side.charAt(i);\n\t\t\t\t\tboolean mono = false;\n\n\t\t\t\t\tswitch (c) {\n\t\t\t\t\t\tcase '(':\n\t\t\t\t\t\t\tsigns.add(c);\n\t\t\t\t\t\t\tbreak;\n\t\t\t\t\t\tcase ')': {\n\t\t\t\t\t\t\tOP op = ops.pollLast();\n\t\t\t\t\t\t\tExp s = exps.pollLast();\n\t\t\t\t\t\t\tExp f = exps.pollLast();\n\t\t\t\t\t\t\texps.add(main.new Exp(op, f, s));\n\t\t\t\t\t\t\tsigns.pollLast();\n\t\t\t\t\t\t\tmono = true;\n\t\t\t\t\t\t}\n\t\t\t\t\t\tbreak;\n\t\t\t\t\t\tcase '*':\n\t\t\t\t\t\t\tops.add(OP.AND);\n\t\t\t\t\t\t\tbreak;\n\t\t\t\t\t\tcase '+':\n\t\t\t\t\t\t\tops.add(OP.OR);\n\t\t\t\t\t\t\tbreak;\n\t\t\t\t\t\tcase '-':\n\t\t\t\t\t\t\tif (side.charAt(i + 1) == '>') {\n\t\t\t\t\t\t\t\tops.add(OP.IMP);\n\t\t\t\t\t\t\t\ti++;//skip '>'\n\t\t\t\t\t\t\t} else {\n\t\t\t\t\t\t\t\tops.add(OP.NOT);\n\t\t\t\t\t\t\t\tsigns.add(c);\n\t\t\t\t\t\t\t}\n\t\t\t\t\t\t\tbreak;\n\t\t\t\t\t\tdefault: {\n\t\t\t\t\t\t\texps.add(main.new Exp(c, var));\n\t\t\t\t\t\t\tmono = true;\n\t\t\t\t\t\t\tif (c != 'T' | c != 'F') {\n\t\t\t\t\t\t\t\tmax = Math.max(max, c - 'a' + 1);\n\t\t\t\t\t\t\t}\n\t\t\t\t\t\t}\n\t\t\t\t\t\tbreak;\n\t\t\t\t\t}\n\t\t\t\t\t//monominal?\n\t\t\t\t\tif (signs.peekLast() != null && mono) {\n\t\t\t\t\t\twhile (signs.peekLast() != null && signs.peekLast() == '-') {\n\t\t\t\t\t\t\tOP op = ops.pollLast();\n\t\t\t\t\t\t\tExp f = exps.pollLast();\n\t\t\t\t\t\t\texps.add(main.new Exp(op, f));\n\t\t\t\t\t\t\tsigns.pollLast();\n\t\t\t\t\t\t}\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t\tif (lside == null) {\n\t\t\t\t\tlside = exps.poll();\n\t\t\t\t\texps.clear();\n\t\t\t\t} else {\n\t\t\t\t\trside = exps.poll();\n\t\t\t\t\texps.clear();\n\t\t\t\t}\n\t\t\t}\n\n\t\t\t//debug\n//\t\t\tif (line.equals(lside.toString() + \"=\" + rside.toString())) {\n//\t\t\t\tSystem.out.println(line);\n//\t\t\t\tSystem.out.println(lside.toString() + \"=\" + rside.toString());\n//\t\t\t}\n\n\t\t\t//solve\n\t\t\tboolean ans = true;\n\t\t\tfor (int i = 0; i < 1 << max; i++) {\n\t\t\t\tvar.substitution(i);\n\t\t\t\tif (lside.value() != rside.value()) {\n\t\t\t\t\tans = false;\n\t\t\t\t\tbreak;\n\t\t\t\t}\n\t\t\t}\n\t\t\tSystem.out.println(ans ? \"YES\" : \"NO\");\n\n\t\t}//end while\n\t} //end main\n\n\tclass Var {\n\n\t\t//a..k\n\t\tboolean[] values = new boolean[11];\n\n\t\tvoid substitution(int values) {\n\t\t\tfor (int i = 0; i < this.values.length; i++) {\n\t\t\t\tif ((values & 1 << i) != 0) {\n\t\t\t\t\tthis.values[i] = true;\n\t\t\t\t} else {\n\t\t\t\t\tthis.values[i] = false;\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\n\t\tboolean value(char name) {\n\t\t\tboolean ret = false;\n\t\t\tswitch (name) {\n\t\t\t\tcase 'T':\n\t\t\t\t\tret = true;\n\t\t\t\t\tbreak;\n\t\t\t\tcase 'F':\n\t\t\t\t\tret = false;\n\t\t\t\t\tbreak;\n\t\t\t\tdefault:\n\t\t\t\t\tret = values[name - 'a'];\n\t\t\t\t\tbreak;\n\t\t\t}\n\t\t\treturn ret;\n\t\t}\n\t}\n\n\tclass Exp {\n\n\t\tOP op;\n\t\tExp f, s;\n\t\tchar name;\n\t\tVar var;\n\n\t\tExp(OP op, Exp f, Exp s) {\n\t\t\tthis.op = op;\n\t\t\tthis.f = f;//first term\n\t\t\tthis.s = s;//second term\n\t\t}\n\n\t\tExp(OP op, Exp F) {\n\t\t\tthis.op = op;\n\t\t\tthis.f = F;\n\t\t}\n\n\t\tExp(char name, Var var) {\n\t\t\tthis.name = name;\n\t\t\tthis.var = var;\n\t\t}\n\n\t\tboolean value() {\n\t\t\tboolean ret = false;\n\t\t\tif (var != null) {\n\t\t\t\tret = var.value(name);\n\t\t\t} else {\n\t\t\t\tswitch (op) {\n\t\t\t\t\tcase NOT:\n\t\t\t\t\t\tret = !f.value();\n\t\t\t\t\t\tbreak;\n\t\t\t\t\tcase AND:\n\t\t\t\t\t\tret = f.value() && s.value();\n\t\t\t\t\t\tbreak;\n\t\t\t\t\tcase OR:\n\t\t\t\t\t\tret = f.value() || s.value();\n\t\t\t\t\t\tbreak;\n\t\t\t\t\tcase IMP:\n\t\t\t\t\t\tif (!f.value() | s.value()) ret = true;\n\t\t\t\t\t\tbreak;\n\t\t\t\t}\n\t\t\t}\n\t\t\treturn ret;\n\t\t}\n\n\t\tpublic String toString() {\n\t\t\tString ret = \"\";\n\t\t\tif (var != null) {\n\t\t\t\tret += name;\n\t\t\t} else {\n\t\t\t\tif (op == OP.NOT) {\n\t\t\t\t\tret = \"-\" + f.toString();\n\t\t\t\t} else {\n\t\t\t\t\tString _op = \"\";\n\t\t\t\t\tswitch (op) {\n\t\t\t\t\t\tcase AND:\n\t\t\t\t\t\t\t_op = \"*\";\n\t\t\t\t\t\t\tbreak;\n\t\t\t\t\t\tcase OR:\n\t\t\t\t\t\t\t_op = \"+\";\n\t\t\t\t\t\t\tbreak;\n\t\t\t\t\t\tcase IMP:\n\t\t\t\t\t\t\t_op = \"->\";\n\t\t\t\t\t\t\tbreak;\n\t\t\t\t\t}\n\t\t\t\t\tret = \"(\" + f.toString() + _op + s.toString() + \")\";\n\t\t\t\t}\n\t\t\t}\n\t\t\treturn ret;\n\t\t}\n\t}\n}"
  },
  {
    "language": "Java",
    "code": "import java.util.*;\nclass Main {\n  public static void main(String args[]){\n    new Main().run();\n  }\n\n  int idx;\n  String s;\n\n  Scanner sc = new Scanner(System.in);\n  void run(){\n    while(true){\n      s = sc.nextLine();\n      if(s.equals(\"#\"))break;\n      idx=0;\n      Expr e = equation();\n      boolean ans = true;\n      for(int i = 0 ; i < 1 << 11; i++){\n        Map<Character,Boolean> env = new HashMap<Character, Boolean>();\n        for(int j = 0 ; j < 11; j++){\n          env.put((char)('a' + j), ((i >> j) & 1) == 1);\n        }\n        ans = ans && e.eval(env);\n      }\n      System.out.println(ans ? \"YES\" : \"NO\");\n    }\n  }\n\n  Expr equation(){\n    Expr e1 = formula();\n    idx++;\n    Expr e2 = formula();\n    return new Eq(e1,e2);\n  }\n\n  Expr formula(){\n    char c;\n    switch(c = s.charAt(idx++)){\n      case 'T': \n        return new True();\n      case 'F':\n        return new False();\n      case '-': \n        return new Not(formula());\n      case '(':\n        Expr e1 = formula();\n        Expr e3 = null;\n        if(s.charAt(idx) == '*'){\n          idx++;\n          Expr e2 = formula();\n          e3= new And(e1,e2);\n        }else if(s.charAt(idx)=='+'){\n          idx++;\n          Expr e2 = formula();\n          e3= new Or(e1,e2);\n        } else{\n          idx++;\n          idx++;\n          Expr e2 = formula();\n          e3 = new Imp(e1,e2);\n        }\n        idx++;\n        return e3;\n      default:\n        return new Var(c);\n    }\n  }\n}\n\nabstract class Expr {\n  abstract boolean eval(Map<Character, Boolean> env);\n}\n\nclass Eq extends Expr{\n  Expr e1,e2;\n  Eq(Expr a, Expr b){\n    e1=a;\n    e2=b;\n  }\n\n  public boolean eval(Map<Character, Boolean> env){\n    return e1.eval(env) == e2.eval(env);\n  }\n\n  public String toString(){\n    return e1 + \"=\" + e2;\n  }\n}\n\nclass Not extends Expr{\n  Expr e;\n  Not(Expr expr){\n    this.e = expr;\n  }\n\n  public boolean eval(Map<Character, Boolean> env){\n    return !(e.eval(env));\n  }\n\n  public String toString(){\n    return \"-\" + e;\n  }\n}\n\nclass False extends Expr {\n  False(){\n  }\n\n  public boolean eval(Map<Character, Boolean> env){\n    return false;\n  }\n\n  public String toString(){\n    return \"F\";\n  }\n}\n\nclass True extends Expr {\n  True(){\n  }\n\n  public boolean eval(Map<Character, Boolean> env){\n    return true;\n  }\n\n  public String toString(){\n    return \"T\";\n  }\n}\n\nclass And extends Expr {\n  Expr e1;\n  Expr e2;\n  And(Expr a, Expr b){\n    e1 = a;\n    e2 = b;\n  }\n\n  public boolean eval(Map<Character, Boolean> env){\n    return e1.eval(env) && e2.eval(env);\n  }\n\n  public String toString(){\n    return \"(\" + e1 + \"*\" + e2 +\")\";\n  }\n}\n\nclass Or extends Expr {\n  Expr e1;\n  Expr e2;\n  Or(Expr a, Expr b){\n    e1 = a;\n    e2 = b;\n  }\n\n  public boolean eval(Map<Character, Boolean> env){\n    return e1.eval(env) || e2.eval(env);\n  }\n\n  public String toString(){\n    return \"(\" + e1 + \"+\" + e2 +\")\";\n  }\n}\n\nclass Imp extends Expr {\n  Expr e1;\n  Expr e2;\n  Imp(Expr a, Expr b){\n    e1 = a;\n    e2 = b;\n  }\n  public boolean eval(Map<Character, Boolean> env){\n    return !(e1.eval(env)) || e2.eval(env);\n  }\n\n  public String toString(){\n    return \"(\" + e1 + \"->\" + e2 +\")\";\n  }\n}\n\nclass Var extends Expr {\n  public char name;\n  Var(char c){\n    name =c;\n  }\n\n  public boolean equals (Var v){\n    return name == v.name;\n  }\n\n  public boolean eval(Map<Character, Boolean> env){\n    return env.get(name);\n  }\n\n  public String toString(){\n    return name+\"\";\n  }\n}"
  },
  {
    "language": "Java",
    "code": "\nimport java.util.*;\nimport static java.lang.System.*;\n\npublic class Main {\n\n\tScanner sc = new Scanner(in);\n\t\n\tchar[] eq;\n\tchar[] eq1, eq2;\n\tboolean[] as = new boolean[11];\n\tboolean[] check = new boolean[11];\n\t\n\tboolean flag;\n\tvoid calc(int depth) {\n\t\tif (depth == 11) {\n\t\t\tboolean a, b;\n\t\t\teq = eq1;\n\t\t\tindex = 0;\n\t\t\ta = F();\n\t\t\teq = eq2;\n\t\t\tindex = 0;\n\t\t\tb = F();\n//\t\t\tout.println(a);\n//\t\t\tout.println(b);\n//\t\t\tout.println();\n\t\t\tif (a != b)\n\t\t\t\tflag = false;\n\t\t} else {\n\t\t\tif (flag) {\n\t\t\t\tas[depth] = false;\n\t\t\t\tcalc(depth+1);\n\t\t\t\tas[depth] = true;\n\t\t\t\tcalc(depth+1);\n\t\t\t}\n\t\t}\n\t}\n\t\n\tint index;\n\tint token;\n\tfinal int VAL = '%';\n\tboolean value;\n\tvoid gettoken() {\n\t\tint ch = eq[index++];\n\t\tif (ch == '+' || ch == '*' || ch == '(' || ch == ')') {\n\t\t\ttoken = ch;\n\t\t\treturn;\n\t\t} else if (ch == '-') {\n\t\t\tif (eq[index] == '>') {\n\t\t\t\tindex++;\n\t\t\t\ttoken = '>';\n\t\t\t\treturn;\n\t\t\t} else {\n\t\t\t\ttoken = ch;\n\t\t\t\treturn;\n\t\t\t}\n\t\t} else {\n\t\t\ttoken = VAL;\n\t\t\tswitch(ch) {\n\t\t\tcase 'T':\n\t\t\t\tvalue = true; break;\n\t\t\tcase 'F':\n\t\t\t\tvalue = false; break;\n\t\t\tcase 'a':\n\t\t\t\tvalue = as[0]; break;\n\t\t\tcase 'b':\n\t\t\t\tvalue = as[1]; break;\n\t\t\tcase 'c':\n\t\t\t\tvalue = as[2]; break;\n\t\t\tcase 'd':\n\t\t\t\tvalue = as[3]; break;\n\t\t\tcase 'e':\n\t\t\t\tvalue = as[4]; break;\n\t\t\tcase 'f':\n\t\t\t\tvalue = as[5]; break;\n\t\t\tcase 'g':\n\t\t\t\tvalue = as[6]; break;\n\t\t\tcase 'h':\n\t\t\t\tvalue = as[7]; break;\n\t\t\tcase 'i':\n\t\t\t\tvalue = as[8]; break;\n\t\t\tcase 'j':\n\t\t\t\tvalue = as[9]; break;\n\t\t\tcase 'k':\n\t\t\t\tvalue = as[10]; break;\n\t\t\t}\n\t\t}\n\t}\n\t\n\tboolean F() {\n\t\tboolean v, vnext;\n\t\tint savetoken;\n\t\tgettoken();\n\t\tif (token == VAL) {\n\t\t\treturn value;\n\t\t} else if (token == '-') {\n\t\t\treturn !F();\n\t\t} else if (token == '(') {\n\t\t\tv = F();\n\t\t\tgettoken();\n\t\t\tsavetoken = token;\n\t\t\tvnext = F();\n\t\t\tgettoken();\n\t\t\tif (token != ')') out.println(\"err\");\n\t\t\tif (savetoken == '+') {\n\t\t\t\treturn v || vnext;\n\t\t\t} else if (savetoken == '*') {\n\t\t\t\treturn v && vnext;\n\t\t\t} else if (savetoken == '>') {\n\t\t\t\tif (!v) return true;\n\t\t\t\telse return vnext;\n\t\t\t}\n\t\t\t\n\t\t}\n\t\tout.println(\"err\");\n\t\treturn false;\n\t}\n\t\n\tvoid run() {\n\t\tString s;\n\t\tStringTokenizer st;\n\t\twhile (true) {\n\t\t\ts = sc.nextLine();\n\t\t\tif (s.equals(\"#\"))\n\t\t\t\tbreak;\n\t\t\tst = new StringTokenizer(s,\"=\");\n\t\t\teq1 = st.nextToken().toCharArray();\n\t\t\teq2 = st.nextToken().toCharArray();\n\t\t\tflag = true;\n\t\t\tcalc(0);\n\t\t\tif (flag)\n\t\t\t\tout.println(\"YES\");\n\t\t\telse\n\t\t\t\tout.println(\"N0\");\n//\t\t\tout.println();\n\t\t}\n\t}\n\t\n\tpublic static void main(String[] args) {\n\t\tnew Main().run();\n\t}\n}"
  },
  {
    "language": "Java",
    "code": "import java.util.ArrayList;\nimport java.util.Scanner;\n\npublic class Main {\n\n\tScanner sc = new Scanner(System.in);\n\tpublic void run() {\n\t\twhile(sc.hasNext()){\n\t\t\tString n = sc.next();\n\t\t\tif(n.equals(\"#\"))break;\n\t\t\telse calc(n);\n\t\t\t\n\t\t}\n\t}\n\tString line;\n\tpublic void calc(String n){\n\t\tthis.line = n;\n\t\tEqNode tree = makeNode();\n\t\tboolean ans = true;\n\t\tfor(int a = 0; a < 2; a++){\n\t\t\tfor(int b = 0; b < 2; b++){\n\t\t\t\tfor(int c = 0; c < 2; c++){\n\t\t\t\t\tfor(int d = 0; d < 2; d++){\n\t\t\t\t\t\tfor(int e = 0; e < 2; e++){\n\t\t\t\t\t\t\tfor(int f = 0; f < 2; f++){\n\t\t\t\t\t\t\t\tfor(int g = 0; g < 2; g++){\n\t\t\t\t\t\t\t\t\tfor(int h = 0; h < 2; h++){\n\t\t\t\t\t\t\t\t\t\tfor(int i = 0; i < 2; i++){\n\t\t\t\t\t\t\t\t\t\t\tfor(int j = 0; j < 2; j++){\n\t\t\t\t\t\t\t\t\t\t\t\tfor(int k = 0; k < 2; k++){\n\t\t\t\t\t\t\t\t\t\t\t\t\tint val = tree.eval(a, b, c, d, e, f, g, h, i, j, k);\n\t\t\t\t\t\t\t\t\t\t\t\t\tif(val == 0) {\n\t\t\t\t\t\t\t\t\t\t\t\t\t\tans = false;\n\t\t\t\t\t\t\t\t\t\t\t\t\t\tbreak;\n\t\t\t\t\t\t\t\t\t\t\t\t\t}\n\t\t\t\t\t\t\t\t\t\t\t\t}\n\t\t\t\t\t\t\t\t\t\t\t\tif(!ans) break;\n\t\t\t\t\t\t\t\t\t\t\t}\n\t\t\t\t\t\t\t\t\t\t\tif(!ans) break;\n\t\t\t\t\t\t\t\t\t\t}\n\t\t\t\t\t\t\t\t\t\tif(!ans) break;\n\t\t\t\t\t\t\t\t\t}\n\t\t\t\t\t\t\t\t\tif(!ans) break;\n\t\t\t\t\t\t\t\t}\n\t\t\t\t\t\t\t\tif(!ans) break;\n\t\t\t\t\t\t\t}\n\t\t\t\t\t\t\tif(!ans) break;\n\t\t\t\t\t\t}\n\t\t\t\t\t\tif(!ans) break;\n\t\t\t\t\t}\n\t\t\t\t\tif(!ans) break;\n\t\t\t\t}\n\t\t\t\tif(!ans) break;\n\t\t\t}\n\t\t\tif(!ans) break;\n\t\t}\n\t\tif(ans) System.out.println(\"YES\");\n\t\telse System.out.println(\"NO\");\n\t}\n\n\tpublic EqNode makeNode(){\n\t\tNode n1 = makeNode2();\n\t\tString s = line.substring(0,1);\n\t\tline = line.substring(1);\n\t\tif(!s.equals(\"=\")){\n\t\t\treturn null;\n\t\t}\n\t\tNode n2 = makeNode2();\n\t\treturn new EqNode(n1, n2);\n\t}\n\tpublic Node makeNode2(){\n\t\tString s = line.substring(0,1);\n\t\tline = line.substring(1);\n\t\t\n\t\tif(s.equals(\"T\")) return new BoolNode(1);\n\t\telse if(s.equals(\"F\")) return new BoolNode(0);\n\t\telse if(s.equals(\"a\") || s.equals(\"b\") || s.equals(\"c\") || s.equals(\"d\") || s.equals(\"e\")\n\t\t\t\t|| s.equals(\"f\") || s.equals(\"g\") || s.equals(\"h\") || s.equals(\"i\") || s.equals(\"j\") || s.equals(\"k\")) \n\t\t\treturn new StringNode(s);\n\t\telse if(s.equals(\"-\")){\n\t\t\tNode n = makeNode2();\n\t\t\treturn new NotNode(n);\n\t\t}\n\t\telse if(s.equals(\"(\")){\n\t\t\tNode n1 = makeNode2();\n\t\t\tString s2 = line.substring(0,1);\n\t\t\tline = line.substring(1);\n\t\t\tif(s2.equals(\"*\")){\n\t\t\t\tNode n2 = makeNode2();\n\t\t\t\tString s4 = line.substring(0,1);\n\t\t\t\tline = line.substring(1);\n\t\t\t\tif(s4.equals(\")\")) return new AndNode(n1, n2);\n\t\t\t}\n\t\t\telse if(s2.equals(\"+\")){\n\t\t\t\tNode n2 = makeNode2();\n\t\t\t\tString s4 = line.substring(0,1);\n\t\t\t\tline = line.substring(1);\n\t\t\t\tif(s4.equals(\")\")) return new OrNode(n1, n2);\n\t\t\t}\n\t\t\telse if(s2.equals(\"-\")){\n\t\t\t\tString s3 = line.substring(0,1);\n\t\t\t\tline = line.substring(1);\n\t\t\t\tif(s3.equals(\">\")){\n\t\t\t\t\tNode n2 = makeNode2();\n\t\t\t\t\tString s4 = line.substring(0,1);\n\t\t\t\t\tline = line.substring(1);\n\t\t\t\t\tif(s4.equals(\")\")) return new ImpNode(n1, n2);\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t\treturn null;\n\t}\n\tpublic static void main(String[] args) {\n\t\tnew Main().run();\n\t}\n}\n\ninterface Node{\n\tint eval(int a, int b, int c, int d, int e, int f, int g, int h, int i, int j, int k);\n}\nclass EqNode implements Node{\n\tNode n1;\n\tNode n2;\n\tEqNode(Node n1, Node n2){\n\t\tthis.n1 = n1;\n\t\tthis.n2 = n2;\n\t}\n\tpublic int eval(int a, int b, int c, int d, int e, int f, int g, int h, int i, int j, int k){\n\t\tint t1 = n1.eval(a, b, c, d, e, f, g, h, i, j, k);\n\t\tint t2 = n2.eval(a, b, c, d, e, f, g, h, i, j, k);\n\t\tif(t1 == t2) return 1;\n\t\telse return 0;\n\t}\n}\n\nclass BoolNode implements Node{\n\tint bool;\n\tBoolNode(int t){\n\t\tthis.bool = t;\n\t}\n\tpublic int eval(int a, int b, int c, int d, int e, int f, int g, int h, int i, int j, int k){\n\t\treturn this.bool;\n\t}\n}\nclass StringNode implements Node{\n\tString s;\n\tStringNode(String s){\n\t\tthis.s = s;\n\t}\n\tpublic int eval(int a, int b, int c, int d, int e, int f, int g, int h, int i, int j, int k){\n\t\tif(s.equals(\"a\")) return a;\n\t\telse if(s.equals(\"b\")) return b;\n\t\telse if(s.equals(\"c\")) return c;\n\t\telse if(s.equals(\"d\")) return d;\n\t\telse if(s.equals(\"e\")) return e;\n\t\telse if(s.equals(\"f\")) return f;\n\t\telse if(s.equals(\"g\")) return g;\n\t\telse if(s.equals(\"h\")) return h;\n\t\telse if(s.equals(\"i\")) return i;\n\t\telse if(s.equals(\"j\")) return j;\n\t\telse return k;\n\t}\n}\nclass NotNode implements Node{\n\tNode n;\n\tNotNode(Node n){\n\t\tthis.n = n;\n\t}\n\tpublic int eval(int a, int b, int c, int d, int e, int f, int g, int h, int i, int j, int k){\n\t\tint t = n.eval(a, b, c, d, e, f, g, h, i, j, k);\n\t\tif(t == 0) return 1;\n\t\telse return 0;\n\t}\n}\nclass AndNode implements Node{\n\tNode n1;\n\tNode n2;\n\tAndNode(Node n1, Node n2){\n\t\tthis.n1 = n1;\n\t\tthis.n2 = n2;\n\t}\n\tpublic int eval(int a, int b, int c, int d, int e, int f, int g, int h, int i, int j, int k){\n\t\tint t1 = n1.eval(a, b, c, d, e, f, g, h, i, j, k);\n\t\tint t2 = n2.eval(a, b, c, d, e, f, g, h, i, j, k);\n\t\tif(t1 == 1 && t2 == 1) return 1;\n\t\telse return 0;\n\t}\n}\nclass OrNode implements Node{\n\tNode n1;\n\tNode n2;\n\tOrNode(Node n1, Node n2){\n\t\tthis.n1 = n1;\n\t\tthis.n2 = n2;\n\t}\n\tpublic int eval(int a, int b, int c, int d, int e, int f, int g, int h, int i, int j, int k){\n\t\tint t1 = n1.eval(a, b, c, d, e, f, g, h, i, j, k);\n\t\tint t2 = n2.eval(a, b, c, d, e, f, g, h, i, j, k);\n\t\tif(t1 == 0 && t2 == 0) return 0;\n\t\telse return 1;\n\t}\n}\nclass ImpNode implements Node{\n\tNode n1;\n\tNode n2;\n\tImpNode(Node n1, Node n2){\n\t\tthis.n1 = n1;\n\t\tthis.n2 = n2;\n\t}\n\tpublic int eval(int a, int b, int c, int d, int e, int f, int g, int h, int i, int j, int k){\n\t\tint t1 = n1.eval(a, b, c, d, e, f, g, h, i, j, k);\n\t\tint t2 = n2.eval(a, b, c, d, e, f, g, h, i, j, k);\n\t\tif(t1 == 1 & t2 == 0) return 0;\n\t\telse return 1;\n\t}\n}"
  },
  {
    "language": "Java",
    "code": "import java.io.BufferedReader;\nimport java.io.IOException;\nimport java.io.InputStreamReader;\nimport java.util.ArrayDeque;\nimport java.util.Deque;\n\nimport static java.lang.Integer.parseInt;\n\n/**\n * Equation\n */\npublic class Main {\n\n\tstatic enum OP {NOT, AND, OR, IMP}\n\n\tpublic static void main(String[] args) throws IOException {\n\t\tBufferedReader br = new BufferedReader(new InputStreamReader(System.in));\n\t\tString line;\n\n\t\tMain main = new Main();\n\n\t\twhile ((line = br.readLine()) != null && !line.isEmpty()) {\n\n\t\t\tif (line.equals(\"#\")) break;\n\n\t\t\t//parse\n\t\t\tVar var = main.new Var();\n\t\t\tint max = -1;\n\t\t\tExp lside = null;\n\t\t\tExp rside = null;\n\n\t\t\tfor (String side : line.split(\"=\")) {\n\n\t\t\t\tDeque<OP> ops = new ArrayDeque<>();\n\t\t\t\tDeque<Exp> exps = new ArrayDeque<>();\n\t\t\t\tDeque<Character> signs = new ArrayDeque<>();\n\n\t\t\t\tfor (int i = 0; i < side.length(); i++) {\n\n\t\t\t\t\tchar c = side.charAt(i);\n\t\t\t\t\tboolean mono = false;\n\n\t\t\t\t\tswitch (c) {\n\t\t\t\t\t\tcase '(':\n\t\t\t\t\t\t\tsigns.add(c);\n\t\t\t\t\t\t\tbreak;\n\t\t\t\t\t\tcase ')': {\n\t\t\t\t\t\t\tOP op = ops.pollLast();\n\t\t\t\t\t\t\tExp s = exps.pollLast();\n\t\t\t\t\t\t\tExp f = exps.pollLast();\n\t\t\t\t\t\t\texps.add(main.new Exp(op, f, s));\n\t\t\t\t\t\t\tsigns.pollLast();\n\t\t\t\t\t\t\tmono = true;\n\t\t\t\t\t\t}\n\t\t\t\t\t\tbreak;\n\t\t\t\t\t\tcase '*':\n\t\t\t\t\t\t\tops.add(OP.AND);\n\t\t\t\t\t\t\tbreak;\n\t\t\t\t\t\tcase '+':\n\t\t\t\t\t\t\tops.add(OP.OR);\n\t\t\t\t\t\t\tbreak;\n\t\t\t\t\t\tcase '-':\n\t\t\t\t\t\t\tif (side.charAt(i + 1) == '>') {\n\t\t\t\t\t\t\t\tops.add(OP.IMP);\n\t\t\t\t\t\t\t\ti++;//skip '>'\n\t\t\t\t\t\t\t} else {\n\t\t\t\t\t\t\t\tops.add(OP.NOT);\n\t\t\t\t\t\t\t\tsigns.add(c);\n\t\t\t\t\t\t\t}\n\t\t\t\t\t\t\tbreak;\n\t\t\t\t\t\tdefault: {\n\t\t\t\t\t\t\texps.add(main.new Exp(c, var));\n\t\t\t\t\t\t\tmono = true;\n\t\t\t\t\t\t\tif (c != 'T' | c != 'F') {\n\t\t\t\t\t\t\t\tmax = Math.max(max, c - 'a' + 1);\n\t\t\t\t\t\t\t}\n\t\t\t\t\t\t}\n\t\t\t\t\t\tbreak;\n\t\t\t\t\t}\n\t\t\t\t\t//monominal?\n\t\t\t\t\tif (signs.peekLast() != null && mono) {\n\t\t\t\t\t\twhile (signs.peekLast() != null && signs.peekLast() == '-') {\n\t\t\t\t\t\t\tOP op = ops.pollLast();\n\t\t\t\t\t\t\tExp f = exps.pollLast();\n\t\t\t\t\t\t\texps.add(main.new Exp(op, f));\n\t\t\t\t\t\t\tsigns.pollLast();\n\t\t\t\t\t\t}\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t\tif (lside == null) {\n\t\t\t\t\tlside = exps.poll();\n\t\t\t\t\texps.clear();\n\t\t\t\t} else {\n\t\t\t\t\trside = exps.poll();\n\t\t\t\t\texps.clear();\n\t\t\t\t}\n\t\t\t}\n\n\t\t\t//debug\n//\t\t\tif (!line.equals(lside.toString() + \"=\" + rside.toString())) {\n//\t\t\t\tSystem.out.println(line);\n//\t\t\t\tSystem.out.println(lside.toString() + \"=\" + rside.toString());\n//\t\t\t}\n\n\t\t\t//solve\n\t\t\tboolean ans = true;\n\t\t\tfor (int i = 0; i < 1 << max; i++) {\n\t\t\t\tvar.substitution(i);\n\t\t\t\tans &= (lside.value() == rside.value());\n\t\t\t}\n\t\t\tSystem.out.println(ans ? \"YES\" : \"NO\");\n\n\t\t}//end while\n\t} //end main\n\n\tclass Var {\n\n\t\t//a..k\n\t\tboolean[] values = new boolean[11];\n\n\t\tvoid substitution(int values) {\n\t\t\tfor (int i = 0; i < this.values.length; i++) {\n\t\t\t\tif ((values & 1 << i) == 1) {\n\t\t\t\t\tthis.values[i] = true;\n\t\t\t\t} else {\n\t\t\t\t\tthis.values[i] = false;\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\n\t\tboolean value(char name) {\n\t\t\tboolean ret = false;\n\t\t\tswitch (name) {\n\t\t\t\tcase 'T':\n\t\t\t\t\tret = true;\n\t\t\t\t\tbreak;\n\t\t\t\tcase 'F':\n\t\t\t\t\tret = false;\n\t\t\t\t\tbreak;\n\t\t\t\tdefault:\n\t\t\t\t\tret = values[name - 'a'];\n\t\t\t\t\tbreak;\n\t\t\t}\n\t\t\treturn ret;\n\t\t}\n\t}\n\n\tclass Exp {\n\n\t\tOP op;\n\t\tExp f, s;\n\t\tchar name;\n\t\tVar var;\n\n\t\tExp(OP op, Exp f, Exp s) {\n\t\t\tthis.op = op;\n\t\t\tthis.f = f;//first term\n\t\t\tthis.s = s;//second term\n\t\t}\n\n\t\tExp(OP op, Exp F) {\n\t\t\tthis.op = op;\n\t\t\tthis.f = F;\n\t\t}\n\n\t\tExp(char name, Var var) {\n\t\t\tthis.name = name;\n\t\t\tthis.var = var;\n\t\t}\n\n\t\tboolean value() {\n\t\t\tboolean ret = false;\n\t\t\tif (var != null) {\n\t\t\t\tret = var.value(name);\n\t\t\t} else {\n\t\t\t\tswitch (op) {\n\t\t\t\t\tcase NOT:\n\t\t\t\t\t\tret = !f.value();\n\t\t\t\t\t\tbreak;\n\t\t\t\t\tcase AND:\n\t\t\t\t\t\tret = f.value() && s.value();\n\t\t\t\t\t\tbreak;\n\t\t\t\t\tcase OR:\n\t\t\t\t\t\tret = f.value() || s.value();\n\t\t\t\t\t\tbreak;\n\t\t\t\t\tcase IMP:\n\t\t\t\t\t\tif (!f.value() | s.value()) ret = true;\n\t\t\t\t\t\tbreak;\n\t\t\t\t}\n\t\t\t}\n\t\t\treturn ret;\n\t\t}\n\n\t\tpublic String toString() {\n\t\t\tString ret = \"\";\n\t\t\tif (var != null) {\n\t\t\t\tret += name;\n\t\t\t} else {\n\t\t\t\tif (op == OP.NOT) {\n\t\t\t\t\tret = \"-\" + f.toString();\n\t\t\t\t} else {\n\t\t\t\t\tString _op = \"\";\n\t\t\t\t\tswitch (op) {\n\t\t\t\t\t\tcase AND:\n\t\t\t\t\t\t\t_op = \"*\";\n\t\t\t\t\t\t\tbreak;\n\t\t\t\t\t\tcase OR:\n\t\t\t\t\t\t\t_op = \"+\";\n\t\t\t\t\t\t\tbreak;\n\t\t\t\t\t\tcase IMP:\n\t\t\t\t\t\t\t_op = \"->\";\n\t\t\t\t\t\t\tbreak;\n\t\t\t\t\t}\n\t\t\t\t\tret = \"(\" + f.toString() + _op + s.toString() + \")\";\n\t\t\t\t}\n\t\t\t}\n\t\t\treturn ret;\n\t\t}\n\t}\n}"
  },
  {
    "language": "JavaScript",
    "code": "'use strict';\n\nfunction token(s) {\n  var len = s.length;\n  return function (target, pos) {\n    return target.substr(pos, len) === s ? [true, s, pos + len]\n      : [false, null, pos];\n  }\n}\n\nfunction choice() {\n  var parsers = arguments;\n  return function (target, pos) {\n    for (var i = 0; i < parsers.length; i++) {\n      var parsed = parsers[i](target, pos);\n      if (parsed[0]) return parsed;\n    }\n    return [false, null, pos];\n  };\n}\n\nfunction seq() {\n  var parsers = arguments;\n  return function (target, pos) {\n    var result = [];\n    var nextPos = pos;\n    for (var i = 0; i < parsers.length; i++) {\n      var parsed = parsers[i](target, nextPos);\n      if (!parsed[0]) return [false, null, pos];\n      result.push(parsed[1]);\n      nextPos = parsed[2];\n    }\n    return [true, result, nextPos];\n  };\n}\n\nfunction lazy(f) {\n  var parser;\n  return function (target, position) {\n    if (!parser) parser = f();\n    return parser(target, position);\n  };\n}\n\nfunction fmap(parser, f) {\n  return function (target, pos) {\n    var result = parser(target, pos);\n    return result[0] ? [result[0], f(result[1]), result[2]]\n      : result;\n  };\n}\n\nfunction oneOf(s) {\n  var d = {};\n  for (var i = 0; i < s.length; i++) d[s[i]] = s[i];\n  return function (target, pos) {\n    var c = target.substr(pos, 1);\n    return d[c] ? [true, c, pos + 1] : [false, null, pos];\n  };\n}\n\n(function (stdin) {\n  var formulaP = lazy(function () {\n    var andP = fmap(seq(token('('), formulaP, token('*'), formulaP, token(')')), function (x) {\n      return { op: '*', fs: [x[1], x[3]] };\n    });\n    var orP = fmap(seq(token('('), formulaP, token('+'), formulaP, token(')')), function (x) {\n      return { op: '+', fs: [x[1], x[3]] };\n    });\n    var impP = fmap(seq(token('('), formulaP, token('->'), formulaP, token(')')), function (x) {\n      return { op: '->', fs: [x[1], x[3]] };\n    });\n    var notP = fmap(seq(token('-'), formulaP), function (x) {\n      return { op: '-', fs: [x[1]] };\n    });\n    var valP = fmap(oneOf('abcdefghijkTF'), function (x) { return { val: x, fs: [] }; });\n    return choice(andP, orP, impP, notP, valP);\n  });\n  var equationP = fmap(seq(formulaP, token('='), formulaP), function (x) {\n    return { left: x[0], right: x[2] };\n  });\n\n  stdin.toString().split('\\n').forEach(function (s) {\n    if (s == '#') process.exit(0);\n    var r = equationP(s, 0);\n    var isValid = true;\n    for (var i = 0; i < (1 << 11); i++) {\n      isValid &= evalF(r[1].left) === evalF(r[1].right);\n      function toBool(c) {\n        if (c === 'T') return true;\n        if (c === 'F') return false;\n        return !!(i >> (c.charCodeAt() - 'a'.charCodeAt()) & 1);\n      }\n      function evalF(f) {\n        switch (f.fs.length) {\n          case 0: return toBool(f.val);\n          case 1: return !evalF(f.fs[0]);\n          case 2:\n            switch (f.op) {\n              case '*': return evalF(f.fs[0]) && evalF(f.fs[1]);\n              case '+': return evalF(f.fs[0]) || evalF(f.fs[1]);\n              case '->': return !evalF(f.fs[0]) || evalF(f.fs[1]);\n            }\n        }\n      }\n    }\n    console.log(isValid ? 'YES' : 'NO');\n  });\n})(require('fs').readFileSync('/dev/stdin', 'utf8'));"
  },
  {
    "language": "JavaScript",
    "code": "'use strict';\n\n// function token(s) {\n//   const len = s.length;\n//   return (target, pos) =>\n//     target.substr(pos, len) === s ? [true, s, pos + len]\n//       : [false, null, pos];\n// }\n\n// function choice() {\n//   const parsers = arguments;\n//   return (target, pos) => {\n//     for (let parser of parsers) {\n//       const parsed = parser(target, pos);\n//       if (parsed[0]) return parsed;\n//     }\n//     return [false, null, pos];\n//   };\n// }\n\n// function seq() {\n//   const parsers = arguments;\n//   return (target, pos) => {\n//     const result = [];\n//     let nextPos = pos;\n//     for (let parser of parsers) {\n//       const parsed = parser(target, nextPos);\n//       if (!parsed[0]) return [false, null, pos];\n//       result.push(parsed[1]);\n//       nextPos = parsed[2];\n//     }\n//     return [true, result, nextPos];\n//   };\n// }\n\n// function lazy(f) {\n//   let parser;\n//   return function (target, position) {\n//     if (!parser) parser = f();\n//     return parser(target, position);\n//   };\n// }\n\n// function fmap(parser, f) {\n//   return (target, pos) => {\n//     const result = parser(target, pos);\n//     if (result[0]) {\n//       return [result[0], f(result[1]), result[2]];\n//     } else {\n//       return result;\n//     }\n//   };\n// }\n\n// function oneOf(s) {\n//   let d = {};\n//   for (let c of s) d[c] = c;\n//   return (target, pos) => {\n//     const c = target.substr(pos, 1);\n//     return d[c] ? [true, c, pos + 1] : [false, null, pos];\n//   };\n// }\n\n// (stdin => {\n//   const formulaP = lazy(() => {\n//     const andP = fmap(seq(token('('), formulaP, token('*'), formulaP, token(')')), x => {\n//       return { op: '*', fs: [x[1], x[3]] };\n//     });\n//     const orP = fmap(seq(token('('), formulaP, token('+'), formulaP, token(')')), x => {\n//       return { op: '+', fs: [x[1], x[3]] };\n//     });\n//     const impP = fmap(seq(token('('), formulaP, token('->'), formulaP, token(')')), x => {\n//       return { op: '->', fs: [x[1], x[3]] };\n//     });\n//     const notP = fmap(seq(token('-'), formulaP), x => {\n//       return { op: '-', fs: [x[1]] };\n//     });\n//     const valP = fmap(oneOf('abcdefghijkTF'), x => { return { val: x, fs: [] }; });\n//     return choice(andP, orP, impP, notP, valP);\n//   });\n//   const equationP = fmap(seq(formulaP, token('='), formulaP), x => {\n//     return { left: x[0], right: x[2] };\n//   });\n\n//   stdin.toString().split('\\n').forEach(s => {\n//     if (s == '#') process.exit(0);\n//     // const r = equationP(s, 0);\n//     // let isValid = true;\n//     // for (let i = 0; i < (1 << 11); i++) {\n//     //   isValid &= evalF(r[1].left) === evalF(r[1].right);\n//     //   function toBool(c) {\n//     //     if (c === 'T') return true;\n//     //     if (c === 'F') return false;\n//     //     return !!(i >> (c.charCodeAt() - 'a'.charCodeAt()) & 1);\n//     //   }\n//     //   function evalF(f) {\n//     //     switch (f.fs.length) {\n//     //       case 0: return toBool(f.val);\n//     //       case 1: return !evalF(f.fs[0]);\n//     //       case 2:\n//     //         switch (f.op) {\n//     //           case '*': return evalF(f.fs[0]) && evalF(f.fs[1]);\n//     //           case '+': return evalF(f.fs[0]) || evalF(f.fs[1]);\n//     //           case '->': return !evalF(f.fs[0]) || evalF(f.fs[1]);\n//     //         }\n//     //     }\n//     //   }\n//     // }\n//     // console.log(isValid ? 'YES' : 'NO');\n//   });\n// })(require('fs').readFileSync('/dev/stdin', 'utf8'));"
  },
  {
    "language": "JavaScript",
    "code": "'use strict';\n\nfunction token(s) {\n  const len = s.length;\n  return (target, pos) =>\n    target.substr(pos, len) === s ? [true, s, pos + len]\n      : [false, null, pos];\n}\n\nfunction choice() {\n  const parsers = arguments;\n  return (target, pos) => {\n    for (let parser of parsers) {\n      const parsed = parser(target, pos);\n      if (parsed[0]) return parsed;\n    }\n    return [false, null, pos];\n  };\n}\n\nfunction seq() {\n  const parsers = arguments;\n  return (target, pos) => {\n    const result = [];\n    let nextPos = pos;\n    for (let parser of parsers) {\n      const parsed = parser(target, nextPos);\n      if (!parsed[0]) return [false, null, pos];\n      result.push(parsed[1]);\n      nextPos = parsed[2];\n    }\n    return [true, result, nextPos];\n  };\n}\n\nfunction lazy(f) {\n  let parser;\n  return function (target, position) {\n    if (!parser) parser = f();\n    return parser(target, position);\n  };\n}\n\nfunction fmap(parser, f) {\n  return (target, pos) => {\n    const result = parser(target, pos);\n    if (result[0]) {\n      return [result[0], f(result[1]), result[2]];\n    } else {\n      return result;\n    }\n  };\n}\n\nfunction oneOf(s) {\n  let d = {};\n  for (let c of s) d[c] = c;\n  return (target, pos) => {\n    const c = target.substr(pos, 1);\n    return d[c] ? [true, c, pos + 1] : [false, null, pos];\n  };\n}\n\n(stdin => {\n  const formulaP = lazy(() => {\n    const andP = fmap(seq(token('('), formulaP, token('*'), formulaP, token(')')), x => {\n      return { op: '*', fs: [x[1], x[3]] };\n    });\n    const orP = fmap(seq(token('('), formulaP, token('+'), formulaP, token(')')), x => {\n      return { op: '+', fs: [x[1], x[3]] };\n    });\n    const impP = fmap(seq(token('('), formulaP, token('->'), formulaP, token(')')), x => {\n      return { op: '->', fs: [x[1], x[3]] };\n    });\n    const notP = fmap(seq(token('-'), formulaP), x => {\n      return { op: '-', fs: [x[1]] };\n    });\n    const valP = fmap(oneOf('abcdefghijkTF'), x => { return { val: x, fs: [] }; });\n    return choice(andP, orP, impP, notP, valP);\n  });\n  const equationP = fmap(seq(formulaP, token('='), formulaP), x => {\n    return { left: x[0], right: x[2] };\n  });\n\n  const lines = stdin.toString().split('\\n');\n  lines.forEach(s => {\n    if (s == '#') process.exit(0);\n    const r = equationP(s, 0);\n    let isValid = true;\n    for (let i = 0; i < (1 << 11); i++) {\n      isValid &= evalF(r[1].left) === evalF(r[1].right);\n      function toBool(c) {\n        if (c === 'T') return true;\n        if (c === 'F') return false;\n        return !!(i >> (c.charCodeAt() - 'a'.charCodeAt()) & 1);\n      }\n      function evalF(f) {\n        switch (f.fs.length) {\n          case 0: return toBool(f.val);\n          case 1: return !evalF(f.fs[0]);\n          case 2:\n            switch (f.op) {\n              case '*': return evalF(f.fs[0]) && evalF(f.fs[1]);\n              case '+': return evalF(f.fs[0]) || evalF(f.fs[1]);\n              case '->': return !evalF(f.fs[0]) || evalF(f.fs[1]);\n            }\n        }\n      }\n    }\n    console.log(isValid ? 'YES' : 'NO');\n  });\n})(require('fs').readFileSync('/dev/stdin', 'utf8'));"
  },
  {
    "language": "JavaScript",
    "code": "'use strict';\n\nfunction token(s) {\n  //   const len = s.length;\n  //   return (target, pos) =>\n  //     target.substr(pos, len) === s ? [true, s, pos + len]\n  //       : [false, null, pos];\n}\n\n// function choice() {\n//   const parsers = arguments;\n//   return (target, pos) => {\n//     for (let parser of parsers) {\n//       const parsed = parser(target, pos);\n//       if (parsed[0]) return parsed;\n//     }\n//     return [false, null, pos];\n//   };\n// }\n\n// function seq() {\n//   const parsers = arguments;\n//   return (target, pos) => {\n//     const result = [];\n//     let nextPos = pos;\n//     for (let parser of parsers) {\n//       const parsed = parser(target, nextPos);\n//       if (!parsed[0]) return [false, null, pos];\n//       result.push(parsed[1]);\n//       nextPos = parsed[2];\n//     }\n//     return [true, result, nextPos];\n//   };\n// }\n\n// function lazy(f) {\n//   let parser;\n//   return function (target, position) {\n//     if (!parser) parser = f();\n//     return parser(target, position);\n//   };\n// }\n\n// function fmap(parser, f) {\n//   return (target, pos) => {\n//     const result = parser(target, pos);\n//     if (result[0]) {\n//       return [result[0], f(result[1]), result[2]];\n//     } else {\n//       return result;\n//     }\n//   };\n// }\n\n// function oneOf(s) {\n//   let d = {};\n//   for (let c of s) d[c] = c;\n//   return (target, pos) => {\n//     const c = target.substr(pos, 1);\n//     return d[c] ? [true, c, pos + 1] : [false, null, pos];\n//   };\n// }\n\n// (stdin => {\n//   const formulaP = lazy(() => {\n//     const andP = fmap(seq(token('('), formulaP, token('*'), formulaP, token(')')), x => {\n//       return { op: '*', fs: [x[1], x[3]] };\n//     });\n//     const orP = fmap(seq(token('('), formulaP, token('+'), formulaP, token(')')), x => {\n//       return { op: '+', fs: [x[1], x[3]] };\n//     });\n//     const impP = fmap(seq(token('('), formulaP, token('->'), formulaP, token(')')), x => {\n//       return { op: '->', fs: [x[1], x[3]] };\n//     });\n//     const notP = fmap(seq(token('-'), formulaP), x => {\n//       return { op: '-', fs: [x[1]] };\n//     });\n//     const valP = fmap(oneOf('abcdefghijkTF'), x => { return { val: x, fs: [] }; });\n//     return choice(andP, orP, impP, notP, valP);\n//   });\n//   const equationP = fmap(seq(formulaP, token('='), formulaP), x => {\n//     return { left: x[0], right: x[2] };\n//   });\n\n//   stdin.toString().split('\\n').forEach(s => {\n//     if (s == '#') process.exit(0);\n//     // const r = equationP(s, 0);\n//     // let isValid = true;\n//     // for (let i = 0; i < (1 << 11); i++) {\n//     //   isValid &= evalF(r[1].left) === evalF(r[1].right);\n//     //   function toBool(c) {\n//     //     if (c === 'T') return true;\n//     //     if (c === 'F') return false;\n//     //     return !!(i >> (c.charCodeAt() - 'a'.charCodeAt()) & 1);\n//     //   }\n//     //   function evalF(f) {\n//     //     switch (f.fs.length) {\n//     //       case 0: return toBool(f.val);\n//     //       case 1: return !evalF(f.fs[0]);\n//     //       case 2:\n//     //         switch (f.op) {\n//     //           case '*': return evalF(f.fs[0]) && evalF(f.fs[1]);\n//     //           case '+': return evalF(f.fs[0]) || evalF(f.fs[1]);\n//     //           case '->': return !evalF(f.fs[0]) || evalF(f.fs[1]);\n//     //         }\n//     //     }\n//     //   }\n//     // }\n//     // console.log(isValid ? 'YES' : 'NO');\n//   });\n// })(require('fs').readFileSync('/dev/stdin', 'utf8'));"
  },
  {
    "language": "JavaScript",
    "code": "'use strict';\n\nfunction token(s) {\n  var len = s.length;\n  return function (target, pos) {\n    return target.substr(pos, len) === s ? [true, s, pos + len]\n      : [false, null, pos];\n  }\n}\n\nfunction choice() {\n  var parsers = arguments;\n  return function (target, pos) {\n    for (var i = 0; i < parsers.length; i++) {\n      var parsed = parsers[i](target, pos);\n      if (parsed[0]) return parsed;\n    }\n    return [false, null, pos];\n  };\n}\n\nfunction seq() {\n  var parsers = arguments;\n  return function (target, pos) {\n    var result = [];\n    var nextPos = pos;\n    for (var i = 0; i < parsers.length; i++) {\n      var parsed = parsers[i](target, nextPos);\n      if (!parsed[0]) return [false, null, pos];\n      result.push(parsed[1]);\n      nextPos = parsed[2];\n    }\n    return [true, result, nextPos];\n  };\n}\n\nfunction lazy(f) {\n  var parser;\n  return function (target, position) {\n    if (!parser) parser = f();\n    return parser(target, position);\n  };\n}\n\nfunction fmap(parser, f) {\n  return function (target, pos) {\n    var result = parser(target, pos);\n    return result[0] ? [result[0], f(result[1]), result[2]]\n      : result;\n  };\n}\n\nfunction oneOf(s) {\n  var d = {};\n  for (var i = 0; i < s.length; i++) d[s[i]] = s[i];\n  return function (target, pos) {\n    var c = target.substr(pos, 1);\n    return d[c] ? [true, c, pos + 1] : [false, null, pos];\n  };\n}\n\n(function (stdin) {\n  var formulaP = lazy(function () {\n    var andP = fmap(seq(token('('), formulaP, token('*'), formulaP, token(')')), function (x) {\n      return { op: '*', fs: [x[1], x[3]] };\n    });\n    var orP = fmap(seq(token('('), formulaP, token('+'), formulaP, token(')')), function (x) {\n      return { op: '+', fs: [x[1], x[3]] };\n    });\n    var impP = fmap(seq(token('('), formulaP, token('->'), formulaP, token(')')), function (x) {\n      return { op: '->', fs: [x[1], x[3]] };\n    });\n    var notP = fmap(seq(token('-'), formulaP), function (x) {\n      return { op: '-', fs: [x[1]] };\n    });\n    var valP = fmap(oneOf('abcdefghijkTF'), function (x) { return { val: x, fs: [] }; });\n    return choice(andP, orP, impP, notP, valP);\n  });\n  var equationP = fmap(seq(formulaP, token('='), formulaP), function (x) {\n    return { left: x[0], right: x[2] };\n  });\n\n  stdin.toString().split('\\n').forEach(function (s) {\n    if (s == '#') process.exit(0);\n    var r = equationP(s, 0);\n    var isValid = true;\n    for (var i = 0; i < (1 << 11); i++) {\n      // isValid &= evalF(r[1].left) === evalF(r[1].right);\n      function toBool(c) {\n        if (c === 'T') return true;\n        if (c === 'F') return false;\n        return !!(i >> (c.charCodeAt() - 'a'.charCodeAt()) & 1);\n      }\n      function evalF(f) {\n        switch (f.fs.length) {\n          case 0: return toBool(f.val);\n          case 1: return !evalF(f.fs[0]);\n          case 2:\n            switch (f.op) {\n              case '*': return evalF(f.fs[0]) && evalF(f.fs[1]);\n              case '+': return evalF(f.fs[0]) || evalF(f.fs[1]);\n              case '->': return !evalF(f.fs[0]) || evalF(f.fs[1]);\n            }\n        }\n      }\n    }\n    console.log(isValid ? 'YES' : 'NO');\n  });\n})(require('fs').readFileSync('/dev/stdin', 'utf8'));"
  },
  {
    "language": "JavaScript",
    "code": "'use strict';\n\nfunction token(s) {\n  var len = s.length;\n  return function (target, pos) {\n    return target.substr(pos, len) === s ? [true, s, pos + len]\n      : [false, null, pos];\n  }\n}\n\nfunction choice() {\n  var parsers = arguments;\n  return function (target, pos) {\n    // for (var i = 0; i < parsers.length; i++) {\n    for (let parser of parsers) {\n      var parsed = parser(target, pos);\n      if (parsed[0]) return parsed;\n    }\n    return [false, null, pos];\n  };\n}\n\n// function seq() {\n//   const parsers = arguments;\n//   return (target, pos) => {\n//     const result = [];\n//     let nextPos = pos;\n//     for (let parser of parsers) {\n//       const parsed = parser(target, nextPos);\n//       if (!parsed[0]) return [false, null, pos];\n//       result.push(parsed[1]);\n//       nextPos = parsed[2];\n//     }\n//     return [true, result, nextPos];\n//   };\n// }\n\n// function lazy(f) {\n//   let parser;\n//   return function (target, position) {\n//     if (!parser) parser = f();\n//     return parser(target, position);\n//   };\n// }\n\n// function fmap(parser, f) {\n//   return (target, pos) => {\n//     const result = parser(target, pos);\n//     if (result[0]) {\n//       return [result[0], f(result[1]), result[2]];\n//     } else {\n//       return result;\n//     }\n//   };\n// }\n\n// function oneOf(s) {\n//   let d = {};\n//   for (let c of s) d[c] = c;\n//   return (target, pos) => {\n//     const c = target.substr(pos, 1);\n//     return d[c] ? [true, c, pos + 1] : [false, null, pos];\n//   };\n// }\n\n// (stdin => {\n//   const formulaP = lazy(() => {\n//     const andP = fmap(seq(token('('), formulaP, token('*'), formulaP, token(')')), x => {\n//       return { op: '*', fs: [x[1], x[3]] };\n//     });\n//     const orP = fmap(seq(token('('), formulaP, token('+'), formulaP, token(')')), x => {\n//       return { op: '+', fs: [x[1], x[3]] };\n//     });\n//     const impP = fmap(seq(token('('), formulaP, token('->'), formulaP, token(')')), x => {\n//       return { op: '->', fs: [x[1], x[3]] };\n//     });\n//     const notP = fmap(seq(token('-'), formulaP), x => {\n//       return { op: '-', fs: [x[1]] };\n//     });\n//     const valP = fmap(oneOf('abcdefghijkTF'), x => { return { val: x, fs: [] }; });\n//     return choice(andP, orP, impP, notP, valP);\n//   });\n//   const equationP = fmap(seq(formulaP, token('='), formulaP), x => {\n//     return { left: x[0], right: x[2] };\n//   });\n\n//   stdin.toString().split('\\n').forEach(s => {\n//     if (s == '#') process.exit(0);\n//     // const r = equationP(s, 0);\n//     // let isValid = true;\n//     // for (let i = 0; i < (1 << 11); i++) {\n//     //   isValid &= evalF(r[1].left) === evalF(r[1].right);\n//     //   function toBool(c) {\n//     //     if (c === 'T') return true;\n//     //     if (c === 'F') return false;\n//     //     return !!(i >> (c.charCodeAt() - 'a'.charCodeAt()) & 1);\n//     //   }\n//     //   function evalF(f) {\n//     //     switch (f.fs.length) {\n//     //       case 0: return toBool(f.val);\n//     //       case 1: return !evalF(f.fs[0]);\n//     //       case 2:\n//     //         switch (f.op) {\n//     //           case '*': return evalF(f.fs[0]) && evalF(f.fs[1]);\n//     //           case '+': return evalF(f.fs[0]) || evalF(f.fs[1]);\n//     //           case '->': return !evalF(f.fs[0]) || evalF(f.fs[1]);\n//     //         }\n//     //     }\n//     //   }\n//     // }\n//     // console.log(isValid ? 'YES' : 'NO');\n//   });\n// })(require('fs').readFileSync('/dev/stdin', 'utf8'));"
  },
  {
    "language": "JavaScript",
    "code": "'use strict';\n\nfunction token(s) {\n  var len = s.length;\n  return (target, pos) =>\n    target.substr(pos, len) === s ? [true, s, pos + len]\n      : [false, null, pos];\n}\n\n// function choice() {\n//   const parsers = arguments;\n//   return (target, pos) => {\n//     for (let parser of parsers) {\n//       const parsed = parser(target, pos);\n//       if (parsed[0]) return parsed;\n//     }\n//     return [false, null, pos];\n//   };\n// }\n\n// function seq() {\n//   const parsers = arguments;\n//   return (target, pos) => {\n//     const result = [];\n//     let nextPos = pos;\n//     for (let parser of parsers) {\n//       const parsed = parser(target, nextPos);\n//       if (!parsed[0]) return [false, null, pos];\n//       result.push(parsed[1]);\n//       nextPos = parsed[2];\n//     }\n//     return [true, result, nextPos];\n//   };\n// }\n\n// function lazy(f) {\n//   let parser;\n//   return function (target, position) {\n//     if (!parser) parser = f();\n//     return parser(target, position);\n//   };\n// }\n\n// function fmap(parser, f) {\n//   return (target, pos) => {\n//     const result = parser(target, pos);\n//     if (result[0]) {\n//       return [result[0], f(result[1]), result[2]];\n//     } else {\n//       return result;\n//     }\n//   };\n// }\n\n// function oneOf(s) {\n//   let d = {};\n//   for (let c of s) d[c] = c;\n//   return (target, pos) => {\n//     const c = target.substr(pos, 1);\n//     return d[c] ? [true, c, pos + 1] : [false, null, pos];\n//   };\n// }\n\n// (stdin => {\n//   const formulaP = lazy(() => {\n//     const andP = fmap(seq(token('('), formulaP, token('*'), formulaP, token(')')), x => {\n//       return { op: '*', fs: [x[1], x[3]] };\n//     });\n//     const orP = fmap(seq(token('('), formulaP, token('+'), formulaP, token(')')), x => {\n//       return { op: '+', fs: [x[1], x[3]] };\n//     });\n//     const impP = fmap(seq(token('('), formulaP, token('->'), formulaP, token(')')), x => {\n//       return { op: '->', fs: [x[1], x[3]] };\n//     });\n//     const notP = fmap(seq(token('-'), formulaP), x => {\n//       return { op: '-', fs: [x[1]] };\n//     });\n//     const valP = fmap(oneOf('abcdefghijkTF'), x => { return { val: x, fs: [] }; });\n//     return choice(andP, orP, impP, notP, valP);\n//   });\n//   const equationP = fmap(seq(formulaP, token('='), formulaP), x => {\n//     return { left: x[0], right: x[2] };\n//   });\n\n//   stdin.toString().split('\\n').forEach(s => {\n//     if (s == '#') process.exit(0);\n//     // const r = equationP(s, 0);\n//     // let isValid = true;\n//     // for (let i = 0; i < (1 << 11); i++) {\n//     //   isValid &= evalF(r[1].left) === evalF(r[1].right);\n//     //   function toBool(c) {\n//     //     if (c === 'T') return true;\n//     //     if (c === 'F') return false;\n//     //     return !!(i >> (c.charCodeAt() - 'a'.charCodeAt()) & 1);\n//     //   }\n//     //   function evalF(f) {\n//     //     switch (f.fs.length) {\n//     //       case 0: return toBool(f.val);\n//     //       case 1: return !evalF(f.fs[0]);\n//     //       case 2:\n//     //         switch (f.op) {\n//     //           case '*': return evalF(f.fs[0]) && evalF(f.fs[1]);\n//     //           case '+': return evalF(f.fs[0]) || evalF(f.fs[1]);\n//     //           case '->': return !evalF(f.fs[0]) || evalF(f.fs[1]);\n//     //         }\n//     //     }\n//     //   }\n//     // }\n//     // console.log(isValid ? 'YES' : 'NO');\n//   });\n// })(require('fs').readFileSync('/dev/stdin', 'utf8'));"
  },
  {
    "language": "JavaScript",
    "code": "'use strict';\n\nfunction token(s) {\n  var len = s.length;\n  return function (target, pos) {\n    return target.substr(pos, len) === s ? [true, s, pos + len] : [false, null, pos];\n  };\n}\n\nfunction choice() {\n  var parsers = arguments;\n  return function (target, pos) {\n    var _iteratorNormalCompletion = true;\n    var _didIteratorError = false;\n    var _iteratorError = undefined;\n\n    try {\n      for (var _iterator = parsers[Symbol.iterator](), _step; !(_iteratorNormalCompletion = (_step = _iterator.next()).done); _iteratorNormalCompletion = true) {\n        var parser = _step.value;\n\n        var parsed = parser(target, pos);\n        if (parsed[0]) return parsed;\n      }\n    } catch (err) {\n      _didIteratorError = true;\n      _iteratorError = err;\n    } finally {\n      try {\n        if (!_iteratorNormalCompletion && _iterator.return) {\n          _iterator.return();\n        }\n      } finally {\n        if (_didIteratorError) {\n          throw _iteratorError;\n        }\n      }\n    }\n\n    return [false, null, pos];\n  };\n}\n\nfunction seq() {\n  var parsers = arguments;\n  return function (target, pos) {\n    var result = [];\n    var nextPos = pos;\n    var _iteratorNormalCompletion2 = true;\n    var _didIteratorError2 = false;\n    var _iteratorError2 = undefined;\n\n    try {\n      for (var _iterator2 = parsers[Symbol.iterator](), _step2; !(_iteratorNormalCompletion2 = (_step2 = _iterator2.next()).done); _iteratorNormalCompletion2 = true) {\n        var parser = _step2.value;\n\n        var parsed = parser(target, nextPos);\n        if (!parsed[0]) return [false, null, pos];\n        result.push(parsed[1]);\n        nextPos = parsed[2];\n      }\n    } catch (err) {\n      _didIteratorError2 = true;\n      _iteratorError2 = err;\n    } finally {\n      try {\n        if (!_iteratorNormalCompletion2 && _iterator2.return) {\n          _iterator2.return();\n        }\n      } finally {\n        if (_didIteratorError2) {\n          throw _iteratorError2;\n        }\n      }\n    }\n\n    return [true, result, nextPos];\n  };\n}\n\nfunction lazy(f) {\n  var parser = void 0;\n  return function (target, position) {\n    if (!parser) parser = f();\n    return parser(target, position);\n  };\n}\n\nfunction fmap(parser, f) {\n  return function (target, pos) {\n    var result = parser(target, pos);\n    if (result[0]) {\n      return [result[0], f(result[1]), result[2]];\n    } else {\n      return result;\n    }\n  };\n}\n\nfunction oneOf(s) {\n  var d = {};\n  var _iteratorNormalCompletion3 = true;\n  var _didIteratorError3 = false;\n  var _iteratorError3 = undefined;\n\n  try {\n    for (var _iterator3 = s[Symbol.iterator](), _step3; !(_iteratorNormalCompletion3 = (_step3 = _iterator3.next()).done); _iteratorNormalCompletion3 = true) {\n      var c = _step3.value;\n      d[c] = c;\n    }\n  } catch (err) {\n    _didIteratorError3 = true;\n    _iteratorError3 = err;\n  } finally {\n    try {\n      if (!_iteratorNormalCompletion3 && _iterator3.return) {\n        _iterator3.return();\n      }\n    } finally {\n      if (_didIteratorError3) {\n        throw _iteratorError3;\n      }\n    }\n  }\n\n  return function (target, pos) {\n    var c = target.substr(pos, 1);\n    return d[c] ? [true, c, pos + 1] : [false, null, pos];\n  };\n}\n\n(function (stdin) {\n  var formulaP = lazy(function () {\n    var andP = fmap(seq(token('('), formulaP, token('*'), formulaP, token(')')), function (x) {\n      return { op: '*', fs: [x[1], x[3]] };\n    });\n    var orP = fmap(seq(token('('), formulaP, token('+'), formulaP, token(')')), function (x) {\n      return { op: '+', fs: [x[1], x[3]] };\n    });\n    var impP = fmap(seq(token('('), formulaP, token('->'), formulaP, token(')')), function (x) {\n      return { op: '->', fs: [x[1], x[3]] };\n    });\n    var notP = fmap(seq(token('-'), formulaP), function (x) {\n      return { op: '-', fs: [x[1]] };\n    });\n    var valP = fmap(oneOf('abcdefghijkTF'), function (x) {\n      return { val: x, fs: [] };\n    });\n    return choice(andP, orP, impP, notP, valP);\n  });\n  var equationP = fmap(seq(formulaP, token('='), formulaP), function (x) {\n    return { left: x[0], right: x[2] };\n  });\n\n  var lines = stdin.toString().trim().split('\\n');\n  lines.pop();\n  lines.forEach(function (s) {\n    var r = equationP(s, 0);\n    var isValid = true;\n\n    var _loop = function _loop(i) {\n      isValid &= evalF(r[1].left) == evalF(r[1].right);\n      function toBool(c) {\n        if (c === 'T') return true;\n        if (c === 'F') return false;\n        return !!(i >> c.charCodeAt() - 'a'.charCodeAt() & 1);\n      }\n      function evalF(f) {\n        switch (f.fs.length) {\n          case 0:\n            return toBool(f.val);\n          case 1:\n            return !evalF(f.fs[0]);\n          case 2:\n            switch (f.op) {\n              case '*':\n                return evalF(f.fs[0]) && evalF(f.fs[1]);\n              case '+':\n                return evalF(f.fs[0]) || evalF(f.fs[1]);\n              case '->':\n                return !evalF(f.fs[0]) || evalF(f.fs[1]);\n            }\n        }\n      }\n    };\n\n    for (var i = 0; i < 1 << 11; i++) {\n      _loop(i);\n    }\n    console.log(isValid ? 'YES' : 'NO');\n  });\n})(require('fs').readFileSync('/dev/stdin', 'utf8'));"
  },
  {
    "language": "JavaScript",
    "code": "'use strict';\n\nfunction token(s) {\n  var len = s.length;\n  return function (target, pos) {\n    return target.substr(pos, len) === s ? [true, s, pos + len]\n      : [false, null, pos];\n  }\n}\n\nfunction choice() {\n  var parsers = arguments;\n  return function (target, pos) {\n    for (var i = 0; i < parsers.length; i++) {\n      var parsed = parsers[i](target, pos);\n      if (parsed[0]) return parsed;\n    }\n    return [false, null, pos];\n  };\n}\n\nfunction seq() {\n  var parsers = arguments;\n  return function (target, pos) {\n    var result = [];\n    var nextPos = pos;\n    for (var i = 0; i < parsers.length; i++) {\n      var parsed = parsers[i](target, nextPos);\n      if (!parsed[0]) return [false, null, pos];\n      result.push(parsed[1]);\n      nextPos = parsed[2];\n    }\n    return [true, result, nextPos];\n  };\n}\n\nfunction lazy(f) {\n  var parser;\n  return function (target, position) {\n    if (!parser) parser = f();\n    return parser(target, position);\n  };\n}\n\nfunction fmap(parser, f) {\n  return function (target, pos) {\n    var result = parser(target, pos);\n    return result[0] ? [result[0], f(result[1]), result[2]]\n      : result;\n  };\n}\n\nfunction oneOf(s) {\n  var d = {};\n  for (var i = 0; i < s.length; i++) d[s[i]] = s[i];\n  return function (target, pos) {\n    var c = target.substr(pos, 1);\n    return d[c] ? [true, c, pos + 1] : [false, null, pos];\n  };\n}\n\n(function (stdin) {\n  var formulaP = lazy(function () {\n    var andP = fmap(seq(token('('), formulaP, token('*'), formulaP, token(')')), function (x) {\n      return { op: '*', fs: [x[1], x[3]] };\n    });\n    var orP = fmap(seq(token('('), formulaP, token('+'), formulaP, token(')')), function (x) {\n      return { op: '+', fs: [x[1], x[3]] };\n    });\n    var impP = fmap(seq(token('('), formulaP, token('->'), formulaP, token(')')), function (x) {\n      return { op: '->', fs: [x[1], x[3]] };\n    });\n    var notP = fmap(seq(token('-'), formulaP), function (x) {\n      return { op: '-', fs: [x[1]] };\n    });\n    var valP = fmap(oneOf('abcdefghijkTF'), function (x) { return { val: x, fs: [] }; });\n    return choice(andP, orP, impP, notP, valP);\n  });\n  var equationP = fmap(seq(formulaP, token('='), formulaP), function (x) {\n    return { left: x[0], right: x[2] };\n  });\n\n  stdin.toString().split('\\n').forEach(function (s) {\n    if (s == '#') process.exit(0);\n    var r = equationP(s, 0);\n    var isValid = true;\n    for (var i = 0; i < (1 << 11); i++) {\n      var toBool = function (c) {\n        if (c === 'T') return true;\n        if (c === 'F') return false;\n        return !!(i >> (c.charCodeAt() - 'a'.charCodeAt()) & 1);\n      }\n      var evalF = function (f) {\n        switch (f.fs.length) {\n          case 0: return toBool(f.val);\n          case 1: return !evalF(f.fs[0]);\n          case 2:\n            switch (f.op) {\n              case '*': return evalF(f.fs[0]) && evalF(f.fs[1]);\n              case '+': return evalF(f.fs[0]) || evalF(f.fs[1]);\n              case '->': return !evalF(f.fs[0]) || evalF(f.fs[1]);\n            }\n        }\n      }\n      isValid &= evalF(r[1].left) === evalF(r[1].right);\n    }\n    console.log(isValid ? 'YES' : 'NO');\n  });\n})(require('fs').readFileSync('/dev/stdin', 'utf8'));"
  },
  {
    "language": "JavaScript",
    "code": "'use strict';\n\nfunction token(s) {\n  let len = s.length;\n  // return (target, pos) =>\n  //   target.substr(pos, len) === s ? [true, s, pos + len]\n  //     : [false, null, pos];\n}\n\n// function choice() {\n//   const parsers = arguments;\n//   return (target, pos) => {\n//     for (let parser of parsers) {\n//       const parsed = parser(target, pos);\n//       if (parsed[0]) return parsed;\n//     }\n//     return [false, null, pos];\n//   };\n// }\n\n// function seq() {\n//   const parsers = arguments;\n//   return (target, pos) => {\n//     const result = [];\n//     let nextPos = pos;\n//     for (let parser of parsers) {\n//       const parsed = parser(target, nextPos);\n//       if (!parsed[0]) return [false, null, pos];\n//       result.push(parsed[1]);\n//       nextPos = parsed[2];\n//     }\n//     return [true, result, nextPos];\n//   };\n// }\n\n// function lazy(f) {\n//   let parser;\n//   return function (target, position) {\n//     if (!parser) parser = f();\n//     return parser(target, position);\n//   };\n// }\n\n// function fmap(parser, f) {\n//   return (target, pos) => {\n//     const result = parser(target, pos);\n//     if (result[0]) {\n//       return [result[0], f(result[1]), result[2]];\n//     } else {\n//       return result;\n//     }\n//   };\n// }\n\n// function oneOf(s) {\n//   let d = {};\n//   for (let c of s) d[c] = c;\n//   return (target, pos) => {\n//     const c = target.substr(pos, 1);\n//     return d[c] ? [true, c, pos + 1] : [false, null, pos];\n//   };\n// }\n\n// (stdin => {\n//   const formulaP = lazy(() => {\n//     const andP = fmap(seq(token('('), formulaP, token('*'), formulaP, token(')')), x => {\n//       return { op: '*', fs: [x[1], x[3]] };\n//     });\n//     const orP = fmap(seq(token('('), formulaP, token('+'), formulaP, token(')')), x => {\n//       return { op: '+', fs: [x[1], x[3]] };\n//     });\n//     const impP = fmap(seq(token('('), formulaP, token('->'), formulaP, token(')')), x => {\n//       return { op: '->', fs: [x[1], x[3]] };\n//     });\n//     const notP = fmap(seq(token('-'), formulaP), x => {\n//       return { op: '-', fs: [x[1]] };\n//     });\n//     const valP = fmap(oneOf('abcdefghijkTF'), x => { return { val: x, fs: [] }; });\n//     return choice(andP, orP, impP, notP, valP);\n//   });\n//   const equationP = fmap(seq(formulaP, token('='), formulaP), x => {\n//     return { left: x[0], right: x[2] };\n//   });\n\n//   stdin.toString().split('\\n').forEach(s => {\n//     if (s == '#') process.exit(0);\n//     // const r = equationP(s, 0);\n//     // let isValid = true;\n//     // for (let i = 0; i < (1 << 11); i++) {\n//     //   isValid &= evalF(r[1].left) === evalF(r[1].right);\n//     //   function toBool(c) {\n//     //     if (c === 'T') return true;\n//     //     if (c === 'F') return false;\n//     //     return !!(i >> (c.charCodeAt() - 'a'.charCodeAt()) & 1);\n//     //   }\n//     //   function evalF(f) {\n//     //     switch (f.fs.length) {\n//     //       case 0: return toBool(f.val);\n//     //       case 1: return !evalF(f.fs[0]);\n//     //       case 2:\n//     //         switch (f.op) {\n//     //           case '*': return evalF(f.fs[0]) && evalF(f.fs[1]);\n//     //           case '+': return evalF(f.fs[0]) || evalF(f.fs[1]);\n//     //           case '->': return !evalF(f.fs[0]) || evalF(f.fs[1]);\n//     //         }\n//     //     }\n//     //   }\n//     // }\n//     // console.log(isValid ? 'YES' : 'NO');\n//   });\n// })(require('fs').readFileSync('/dev/stdin', 'utf8'));"
  },
  {
    "language": "JavaScript",
    "code": "'use strict';\n\nfunction token(s) {\n  var len = s.length;\n  return function (target, pos) {\n    return target.substr(pos, len) === s ? [true, s, pos + len] : [false, null, pos];\n  };\n}\n\nfunction choice() {\n  var parsers = arguments;\n  return function (target, pos) {\n    var _iteratorNormalCompletion = true;\n    var _didIteratorError = false;\n    var _iteratorError = undefined;\n\n    try {\n      for (var _iterator = parsers[Symbol.iterator](), _step; !(_iteratorNormalCompletion = (_step = _iterator.next()).done); _iteratorNormalCompletion = true) {\n        var parser = _step.value;\n\n        var parsed = parser(target, pos);\n        if (parsed[0]) return parsed;\n      }\n    } catch (err) {\n      _didIteratorError = true;\n      _iteratorError = err;\n    } finally {\n      try {\n        if (!_iteratorNormalCompletion && _iterator.return) {\n          _iterator.return();\n        }\n      } finally {\n        if (_didIteratorError) {\n          throw _iteratorError;\n        }\n      }\n    }\n\n    return [false, null, pos];\n  };\n}\n\nfunction seq() {\n  var parsers = arguments;\n  return function (target, pos) {\n    var result = [];\n    var nextPos = pos;\n    var _iteratorNormalCompletion2 = true;\n    var _didIteratorError2 = false;\n    var _iteratorError2 = undefined;\n\n    try {\n      for (var _iterator2 = parsers[Symbol.iterator](), _step2; !(_iteratorNormalCompletion2 = (_step2 = _iterator2.next()).done); _iteratorNormalCompletion2 = true) {\n        var parser = _step2.value;\n\n        var parsed = parser(target, nextPos);\n        if (!parsed[0]) return [false, null, pos];\n        result.push(parsed[1]);\n        nextPos = parsed[2];\n      }\n    } catch (err) {\n      _didIteratorError2 = true;\n      _iteratorError2 = err;\n    } finally {\n      try {\n        if (!_iteratorNormalCompletion2 && _iterator2.return) {\n          _iterator2.return();\n        }\n      } finally {\n        if (_didIteratorError2) {\n          throw _iteratorError2;\n        }\n      }\n    }\n\n    return [true, result, nextPos];\n  };\n}\n\nfunction lazy(f) {\n  var parser = void 0;\n  return function (target, position) {\n    if (!parser) parser = f();\n    return parser(target, position);\n  };\n}\n\nfunction fmap(parser, f) {\n  return function (target, pos) {\n    var result = parser(target, pos);\n    if (result[0]) {\n      return [result[0], f(result[1]), result[2]];\n    } else {\n      return result;\n    }\n  };\n}\n\nfunction oneOf(s) {\n  var d = {};\n  var _iteratorNormalCompletion3 = true;\n  var _didIteratorError3 = false;\n  var _iteratorError3 = undefined;\n\n  try {\n    for (var _iterator3 = s[Symbol.iterator](), _step3; !(_iteratorNormalCompletion3 = (_step3 = _iterator3.next()).done); _iteratorNormalCompletion3 = true) {\n      var c = _step3.value;\n      d[c] = c;\n    }\n  } catch (err) {\n    _didIteratorError3 = true;\n    _iteratorError3 = err;\n  } finally {\n    try {\n      if (!_iteratorNormalCompletion3 && _iterator3.return) {\n        _iterator3.return();\n      }\n    } finally {\n      if (_didIteratorError3) {\n        throw _iteratorError3;\n      }\n    }\n  }\n\n  return function (target, pos) {\n    var c = target.substr(pos, 1);\n    return d[c] ? [true, c, pos + 1] : [false, null, pos];\n  };\n}\n\n(function (stdin) {\n  var formulaP = lazy(function () {\n    var andP = fmap(seq(token('('), formulaP, token('*'), formulaP, token(')')), function (x) {\n      return { op: '*', fs: [x[1], x[3]] };\n    });\n    var orP = fmap(seq(token('('), formulaP, token('+'), formulaP, token(')')), function (x) {\n      return { op: '+', fs: [x[1], x[3]] };\n    });\n    var impP = fmap(seq(token('('), formulaP, token('->'), formulaP, token(')')), function (x) {\n      return { op: '->', fs: [x[1], x[3]] };\n    });\n    var notP = fmap(seq(token('-'), formulaP), function (x) {\n      return { op: '-', fs: [x[1]] };\n    });\n    var valP = fmap(oneOf('abcdefghijkTF'), function (x) {\n      return { val: x, fs: [] };\n    });\n    return choice(andP, orP, impP, notP, valP);\n  });\n  var equationP = fmap(seq(formulaP, token('='), formulaP), function (x) {\n    return { left: x[0], right: x[2] };\n  });\n\n  stdin.toString().split('\\n').forEach(function (s) {\n    if (s == '#') process.exit(0);\n    var r = equationP(s, 0);\n    var isValid = true;\n\n    var _loop = function _loop(i) {\n      isValid &= evalF(r[1].left) === evalF(r[1].right);\n      function toBool(c) {\n        if (c === 'T') return true;\n        if (c === 'F') return false;\n        return !!(i >> c.charCodeAt() - 'a'.charCodeAt() & 1);\n      }\n      function evalF(f) {\n        switch (f.fs.length) {\n          case 0:\n            return toBool(f.val);\n          case 1:\n            return !evalF(f.fs[0]);\n          case 2:\n            switch (f.op) {\n              case '*':\n                return evalF(f.fs[0]) && evalF(f.fs[1]);\n              case '+':\n                return evalF(f.fs[0]) || evalF(f.fs[1]);\n              case '->':\n                return !evalF(f.fs[0]) || evalF(f.fs[1]);\n            }\n        }\n      }\n    };\n\n    for (var i = 0; i < 1 << 11; i++) {\n      _loop(i);\n    }\n    console.log(isValid ? 'YES' : 'NO');\n  });\n})(require('fs').readFileSync('/dev/stdin', 'utf8'));"
  },
  {
    "language": "JavaScript",
    "code": "'use strict';\n\nfunction token(s) {\n  var len = s.length;\n  return function (target, pos) {\n    return target.substr(pos, len) === s ? [true, s, pos + len]\n      : [false, null, pos];\n  }\n}\n\nfunction choice() {\n  var parsers = arguments;\n  return function (target, pos) {\n    for (var i = 0; i < parsers.length; i++) {\n      var parsed = parsers[i](target, pos);\n      if (parsed[0]) return parsed;\n    }\n    return [false, null, pos];\n  };\n}\n\nfunction seq() {\n  var parsers = arguments;\n  return function (target, pos) {\n    var result = [];\n    var nextPos = pos;\n    for (var i = 0; i < parsers.length; i++) {\n      var parsed = parsers[i](target, nextPos);\n      if (!parsed[0]) return [false, null, pos];\n      result.push(parsed[1]);\n      nextPos = parsed[2];\n    }\n    return [true, result, nextPos];\n  };\n}\n\nfunction lazy(f) {\n  var parser;\n  return function (target, position) {\n    if (!parser) parser = f();\n    return parser(target, position);\n  };\n}\n\nfunction fmap(parser, f) {\n  return function (target, pos) {\n    var result = parser(target, pos);\n    return result[0] ? [result[0], f(result[1]), result[2]]\n      : result;\n  };\n}\n\nfunction oneOf(s) {\n  var d = {};\n  for (var i = 0; i < s.length; i++) d[s[i]] = s[i];\n  return function (target, pos) {\n    var c = target.substr(pos, 1);\n    return d[c] ? [true, c, pos + 1] : [false, null, pos];\n  };\n}\n\n(function (stdin) {\n  var formulaP = lazy(function () {\n    var andP = fmap(seq(token('('), formulaP, token('*'), formulaP, token(')')), function (x) {\n      return { op: '*', fs: [x[1], x[3]] };\n    });\n    var orP = fmap(seq(token('('), formulaP, token('+'), formulaP, token(')')), function (x) {\n      return { op: '+', fs: [x[1], x[3]] };\n    });\n    var impP = fmap(seq(token('('), formulaP, token('->'), formulaP, token(')')), function (x) {\n      return { op: '->', fs: [x[1], x[3]] };\n    });\n    var notP = fmap(seq(token('-'), formulaP), function (x) {\n      return { op: '-', fs: [x[1]] };\n    });\n    var valP = fmap(oneOf('abcdefghijkTF'), function (x) { return { val: x, fs: [] }; });\n    return choice(andP, orP, impP, notP, valP);\n  });\n  var equationP = fmap(seq(formulaP, token('='), formulaP), function (x) {\n    return { left: x[0], right: x[2] };\n  });\n\n  stdin.toString().split('\\n').forEach(function (s) {\n    if (s == '#') process.exit(0);\n    var r = equationP(s, 0);\n    //   var isValid = true;\n    //   for (var i = 0; i < (1 << 11); i++) {\n    //     isValid &= evalF(r[1].left) === evalF(r[1].right);\n    //     function toBool(c) {\n    //       if (c === 'T') return true;\n    //       if (c === 'F') return false;\n    //       return !!(i >> (c.charCodeAt() - 'a'.charCodeAt()) & 1);\n    //     }\n    //     function evalF(f) {\n    //       switch (f.fs.length) {\n    //         case 0: return toBool(f.val);\n    //         case 1: return !evalF(f.fs[0]);\n    //         case 2:\n    //           switch (f.op) {\n    //             case '*': return evalF(f.fs[0]) && evalF(f.fs[1]);\n    //             case '+': return evalF(f.fs[0]) || evalF(f.fs[1]);\n    //             case '->': return !evalF(f.fs[0]) || evalF(f.fs[1]);\n    //           }\n    //       }\n    //     }\n    //   }\n    //   console.log(isValid ? 'YES' : 'NO');\n  });\n})(require('fs').readFileSync('/dev/stdin', 'utf8'));"
  },
  {
    "language": "JavaScript",
    "code": "'use strict';\n\nfunction token(s) {\n  const len = s.length;\n  return (target, pos) =>\n    target.substr(pos, len) === s ? [true, s, pos + len]\n      : [false, null, pos];\n}\n\n// function choice() {\n//   const parsers = arguments;\n//   return (target, pos) => {\n//     for (let parser of parsers) {\n//       const parsed = parser(target, pos);\n//       if (parsed[0]) return parsed;\n//     }\n//     return [false, null, pos];\n//   };\n// }\n\n// function seq() {\n//   const parsers = arguments;\n//   return (target, pos) => {\n//     const result = [];\n//     let nextPos = pos;\n//     for (let parser of parsers) {\n//       const parsed = parser(target, nextPos);\n//       if (!parsed[0]) return [false, null, pos];\n//       result.push(parsed[1]);\n//       nextPos = parsed[2];\n//     }\n//     return [true, result, nextPos];\n//   };\n// }\n\n// function lazy(f) {\n//   let parser;\n//   return function (target, position) {\n//     if (!parser) parser = f();\n//     return parser(target, position);\n//   };\n// }\n\n// function fmap(parser, f) {\n//   return (target, pos) => {\n//     const result = parser(target, pos);\n//     if (result[0]) {\n//       return [result[0], f(result[1]), result[2]];\n//     } else {\n//       return result;\n//     }\n//   };\n// }\n\n// function oneOf(s) {\n//   let d = {};\n//   for (let c of s) d[c] = c;\n//   return (target, pos) => {\n//     const c = target.substr(pos, 1);\n//     return d[c] ? [true, c, pos + 1] : [false, null, pos];\n//   };\n// }\n\n// (stdin => {\n//   const formulaP = lazy(() => {\n//     const andP = fmap(seq(token('('), formulaP, token('*'), formulaP, token(')')), x => {\n//       return { op: '*', fs: [x[1], x[3]] };\n//     });\n//     const orP = fmap(seq(token('('), formulaP, token('+'), formulaP, token(')')), x => {\n//       return { op: '+', fs: [x[1], x[3]] };\n//     });\n//     const impP = fmap(seq(token('('), formulaP, token('->'), formulaP, token(')')), x => {\n//       return { op: '->', fs: [x[1], x[3]] };\n//     });\n//     const notP = fmap(seq(token('-'), formulaP), x => {\n//       return { op: '-', fs: [x[1]] };\n//     });\n//     const valP = fmap(oneOf('abcdefghijkTF'), x => { return { val: x, fs: [] }; });\n//     return choice(andP, orP, impP, notP, valP);\n//   });\n//   const equationP = fmap(seq(formulaP, token('='), formulaP), x => {\n//     return { left: x[0], right: x[2] };\n//   });\n\n//   stdin.toString().split('\\n').forEach(s => {\n//     if (s == '#') process.exit(0);\n//     // const r = equationP(s, 0);\n//     // let isValid = true;\n//     // for (let i = 0; i < (1 << 11); i++) {\n//     //   isValid &= evalF(r[1].left) === evalF(r[1].right);\n//     //   function toBool(c) {\n//     //     if (c === 'T') return true;\n//     //     if (c === 'F') return false;\n//     //     return !!(i >> (c.charCodeAt() - 'a'.charCodeAt()) & 1);\n//     //   }\n//     //   function evalF(f) {\n//     //     switch (f.fs.length) {\n//     //       case 0: return toBool(f.val);\n//     //       case 1: return !evalF(f.fs[0]);\n//     //       case 2:\n//     //         switch (f.op) {\n//     //           case '*': return evalF(f.fs[0]) && evalF(f.fs[1]);\n//     //           case '+': return evalF(f.fs[0]) || evalF(f.fs[1]);\n//     //           case '->': return !evalF(f.fs[0]) || evalF(f.fs[1]);\n//     //         }\n//     //     }\n//     //   }\n//     // }\n//     // console.log(isValid ? 'YES' : 'NO');\n//   });\n// })(require('fs').readFileSync('/dev/stdin', 'utf8'));"
  },
  {
    "language": "JavaScript",
    "code": "'use strict';\n\nfunction token(s) {\n  var len = s.length;\n  return function (target, pos) {\n    return target.substr(pos, len) === s ? [true, s, pos + len]\n      : [false, null, pos];\n  }\n}\n\nfunction choice() {\n  var parsers = arguments;\n  return function (target, pos) {\n    for (var i = 0; i < parsers.length; i++) {\n      var parsed = parsers[i](target, pos);\n      if (parsed[0]) return parsed;\n    }\n    return [false, null, pos];\n  };\n}\n\nfunction seq() {\n  var parsers = arguments;\n  return function (target, pos) {\n    var result = [];\n    var nextPos = pos;\n    for (var i = 0; i < parsers.length; i++) {\n      var parsed = parsers[i](target, nextPos);\n      if (!parsed[0]) return [false, null, pos];\n      result.push(parsed[1]);\n      nextPos = parsed[2];\n    }\n    return [true, result, nextPos];\n  };\n}\n\nfunction lazy(f) {\n  var parser;\n  return function (target, position) {\n    if (!parser) parser = f();\n    return parser(target, position);\n  };\n}\n\nfunction fmap(parser, f) {\n  return function (target, pos) {\n    var result = parser(target, pos);\n    return result[0] ? [result[0], f(result[1]), result[2]]\n      : result;\n  };\n}\n\nfunction oneOf(s) {\n  var d = {};\n  for (var i = 0; i < s.length; i++) d[s[i]] = s[i];\n  return function (target, pos) {\n    var c = target.substr(pos, 1);\n    return d[c] ? [true, c, pos + 1] : [false, null, pos];\n  };\n}\n\n(function (stdin) {\n  // var formulaP = lazy(function () {\n  //   var andP = fmap(seq(token('('), formulaP, token('*'), formulaP, token(')')), function (x) {\n  //     return { op: '*', fs: [x[1], x[3]] };\n  //   });\n  //   var orP = fmap(seq(token('('), formulaP, token('+'), formulaP, token(')')), function (x) {\n  //     return { op: '+', fs: [x[1], x[3]] };\n  //   });\n  //   var impP = fmap(seq(token('('), formulaP, token('->'), formulaP, token(')')), function (x) {\n  //     return { op: '->', fs: [x[1], x[3]] };\n  //   });\n  //   var notP = fmap(seq(token('-'), formulaP), function (x) {\n  //     return { op: '-', fs: [x[1]] };\n  //   });\n  //   var valP = fmap(oneOf('abcdefghijkTF'), function (x) { return { val: x, fs: [] }; });\n  //   return choice(andP, orP, impP, notP, valP);\n  // });\n  // var equationP = fmap(seq(formulaP, token('='), formulaP), function (x) {\n  //   return { left: x[0], right: x[2] };\n  // });\n\n  // stdin.toString().split('\\n').forEach(function (s) {\n  //   if (s == '#') process.exit(0);\n  //   var r = equationP(s, 0);\n  //   var isValid = true;\n  //   for (var i = 0; i < (1 << 11); i++) {\n  //     isValid &= evalF(r[1].left) === evalF(r[1].right);\n  //     function toBool(c) {\n  //       if (c === 'T') return true;\n  //       if (c === 'F') return false;\n  //       return !!(i >> (c.charCodeAt() - 'a'.charCodeAt()) & 1);\n  //     }\n  //     function evalF(f) {\n  //       switch (f.fs.length) {\n  //         case 0: return toBool(f.val);\n  //         case 1: return !evalF(f.fs[0]);\n  //         case 2:\n  //           switch (f.op) {\n  //             case '*': return evalF(f.fs[0]) && evalF(f.fs[1]);\n  //             case '+': return evalF(f.fs[0]) || evalF(f.fs[1]);\n  //             case '->': return !evalF(f.fs[0]) || evalF(f.fs[1]);\n  //           }\n  //       }\n  //     }\n  //   }\n  //   console.log(isValid ? 'YES' : 'NO');\n  // });\n})(require('fs').readFileSync('/dev/stdin', 'utf8'));"
  },
  {
    "language": "JavaScript",
    "code": "'use strict';\n\nfunction token(s) {\n  var len = s.length;\n  return function (target, pos) {\n    return target.substr(pos, len) === s ? [true, s, pos + len]\n      : [false, null, pos];\n  }\n}\n\nfunction choice() {\n  var parsers = arguments;\n  return function (target, pos) {\n    for (var i = 0; i < parsers.length; i++) {\n      var parsed = parsers[i](target, pos);\n      if (parsed[0]) return parsed;\n    }\n    return [false, null, pos];\n  };\n}\n\nfunction seq() {\n  var parsers = arguments;\n  return function (target, pos) {\n    var result = [];\n    var nextPos = pos;\n    for (var i = 0; i < parsers.length; i++) {\n      var parsed = parser[i](target, nextPos);\n      if (!parsed[0]) return [false, null, pos];\n      result.push(parsed[1]);\n      nextPos = parsed[2];\n    }\n    return [true, result, nextPos];\n  };\n}\n\nfunction lazy(f) {\n  var parser;\n  return function (target, position) {\n    if (!parser) parser = f();\n    return parser(target, position);\n  };\n}\n\nfunction fmap(parser, f) {\n  return function (target, pos) {\n    var result = parser(target, pos);\n    return result[0] ? [result[0], f(result[1]), result[2]]\n      : result;\n  };\n}\n\nfunction oneOf(s) {\n  var d = {};\n  for (var i = 0; i < s.length; i++) d[s[i]] = s[i];\n  return function (target, pos) {\n    var c = target.substr(pos, 1);\n    return d[c] ? [true, c, pos + 1] : [false, null, pos];\n  };\n}\n\n(function (stdin) {\n  var formulaP = lazy(function () {\n    var andP = fmap(seq(token('('), formulaP, token('*'), formulaP, token(')')), function (x) {\n      return { op: '*', fs: [x[1], x[3]] };\n    });\n    var orP = fmap(seq(token('('), formulaP, token('+'), formulaP, token(')')), function (x) {\n      return { op: '+', fs: [x[1], x[3]] };\n    });\n    var impP = fmap(seq(token('('), formulaP, token('->'), formulaP, token(')')), function (x) {\n      return { op: '->', fs: [x[1], x[3]] };\n    });\n    var notP = fmap(seq(token('-'), formulaP), function (x) {\n      return { op: '-', fs: [x[1]] };\n    });\n    var valP = fmap(oneOf('abcdefghijkTF'), function (x) { return { val: x, fs: [] }; });\n    return choice(andP, orP, impP, notP, valP);\n  });\n  var equationP = fmap(seq(formulaP, token('='), formulaP), function (x) {\n    return { left: x[0], right: x[2] };\n  });\n\n  stdin.toString().split('\\n').forEach(function (s) {\n    if (s == '#') process.exit(0);\n    var r = equationP(s, 0);\n    var isValid = true;\n    for (var i = 0; i < (1 << 11); i++) {\n      isValid &= evalF(r[1].left) === evalF(r[1].right);\n      function toBool(c) {\n        if (c === 'T') return true;\n        if (c === 'F') return false;\n        return !!(i >> (c.charCodeAt() - 'a'.charCodeAt()) & 1);\n      }\n      function evalF(f) {\n        switch (f.fs.length) {\n          case 0: return toBool(f.val);\n          case 1: return !evalF(f.fs[0]);\n          case 2:\n            switch (f.op) {\n              case '*': return evalF(f.fs[0]) && evalF(f.fs[1]);\n              case '+': return evalF(f.fs[0]) || evalF(f.fs[1]);\n              case '->': return !evalF(f.fs[0]) || evalF(f.fs[1]);\n            }\n        }\n      }\n    }\n    console.log(isValid ? 'YES' : 'NO');\n  });\n})(require('fs').readFileSync('/dev/stdin', 'utf8'));"
  },
  {
    "language": "JavaScript",
    "code": "'use strict';\n\nfunction token(s) {\n  const len = s.length;\n  return (target, pos) =>\n    target.substr(pos, len) === s ? [true, s, pos + len]\n      : [false, null, pos];\n}\n\nfunction choice() {\n  const parsers = arguments;\n  return (target, pos) => {\n    for (let parser of parsers) {\n      const parsed = parser(target, pos);\n      if (parsed[0]) return parsed;\n    }\n    return [false, null, pos];\n  };\n}\n\nfunction seq() {\n  const parsers = arguments;\n  return (target, pos) => {\n    const result = [];\n    let nextPos = pos;\n    for (let parser of parsers) {\n      const parsed = parser(target, nextPos);\n      if (!parsed[0]) return [false, null, pos];\n      result.push(parsed[1]);\n      nextPos = parsed[2];\n    }\n    return [true, result, nextPos];\n  };\n}\n\nfunction lazy(f) {\n  let parser;\n  return function (target, position) {\n    if (!parser) parser = f();\n    return parser(target, position);\n  };\n}\n\nfunction fmap(parser, f) {\n  return (target, pos) => {\n    const result = parser(target, pos);\n    if (result[0]) {\n      return [result[0], f(result[1]), result[2]];\n    } else {\n      return result;\n    }\n  };\n}\n\nfunction oneOf(s) {\n  let d = {};\n  for (let c of s) d[c] = c;\n  return (target, pos) => {\n    const c = target.substr(pos, 1);\n    return d[c] ? [true, c, pos + 1] : [false, null, pos];\n  };\n}\n\n(stdin => {\n  const formulaP = lazy(() => {\n    const andP = fmap(seq(token('('), formulaP, token('*'), formulaP, token(')')), x => {\n      return { op: '*', fs: [x[1], x[3]] };\n    });\n    const orP = fmap(seq(token('('), formulaP, token('+'), formulaP, token(')')), x => {\n      return { op: '+', fs: [x[1], x[3]] };\n    });\n    const impP = fmap(seq(token('('), formulaP, token('->'), formulaP, token(')')), x => {\n      return { op: '->', fs: [x[1], x[3]] };\n    });\n    const notP = fmap(seq(token('-'), formulaP), x => {\n      return { op: '-', fs: [x[1]] };\n    });\n    const valP = fmap(oneOf('abcdefghijkTF'), x => { return { val: x, fs: [] }; });\n    return choice(andP, orP, impP, notP, valP);\n  });\n  const equationP = fmap(seq(formulaP, token('='), formulaP), x => {\n    return { left: x[0], right: x[2] };\n  });\n\n  const lines = stdin.toString().trim().split('\\n');\n  lines.pop();\n  lines.forEach(s => {\n    const r = equationP(s, 0);\n    let isValid = true;\n    for (let i = 0; i < (1 << 11); i++) {\n      isValid &= evalF(r[1].left) == evalF(r[1].right);\n      function toBool(c) {\n        if (c === 'T') return true;\n        if (c === 'F') return false;\n        return !!(i >> (c.charCodeAt() - 'a'.charCodeAt()) & 1);\n      }\n      function evalF(f) {\n        switch (f.fs.length) {\n          case 0: return toBool(f.val);\n          case 1: return !evalF(f.fs[0]);\n          case 2:\n            switch (f.op) {\n              case '*': return evalF(f.fs[0]) && evalF(f.fs[1]);\n              case '+': return evalF(f.fs[0]) || evalF(f.fs[1]);\n              case '->': return !evalF(f.fs[0]) || evalF(f.fs[1]);\n            }\n        }\n      }\n    }\n    console.log(isValid ? 'YES' : 'NO');\n  });\n})(require('fs').readFileSync('/dev/stdin', 'utf8'));"
  },
  {
    "language": "JavaScript",
    "code": "'use strict';\n\nfunction token(s) {\n  var len = s.length;\n  return function (target, pos) {\n    return target.substr(pos, len) === s ? [true, s, pos + len]\n      : [false, null, pos];\n  }\n}\n\n// function choice() {\n//   const parsers = arguments;\n//   return (target, pos) => {\n//     for (let parser of parsers) {\n//       const parsed = parser(target, pos);\n//       if (parsed[0]) return parsed;\n//     }\n//     return [false, null, pos];\n//   };\n// }\n\n// function seq() {\n//   const parsers = arguments;\n//   return (target, pos) => {\n//     const result = [];\n//     let nextPos = pos;\n//     for (let parser of parsers) {\n//       const parsed = parser(target, nextPos);\n//       if (!parsed[0]) return [false, null, pos];\n//       result.push(parsed[1]);\n//       nextPos = parsed[2];\n//     }\n//     return [true, result, nextPos];\n//   };\n// }\n\n// function lazy(f) {\n//   let parser;\n//   return function (target, position) {\n//     if (!parser) parser = f();\n//     return parser(target, position);\n//   };\n// }\n\n// function fmap(parser, f) {\n//   return (target, pos) => {\n//     const result = parser(target, pos);\n//     if (result[0]) {\n//       return [result[0], f(result[1]), result[2]];\n//     } else {\n//       return result;\n//     }\n//   };\n// }\n\n// function oneOf(s) {\n//   let d = {};\n//   for (let c of s) d[c] = c;\n//   return (target, pos) => {\n//     const c = target.substr(pos, 1);\n//     return d[c] ? [true, c, pos + 1] : [false, null, pos];\n//   };\n// }\n\n// (stdin => {\n//   const formulaP = lazy(() => {\n//     const andP = fmap(seq(token('('), formulaP, token('*'), formulaP, token(')')), x => {\n//       return { op: '*', fs: [x[1], x[3]] };\n//     });\n//     const orP = fmap(seq(token('('), formulaP, token('+'), formulaP, token(')')), x => {\n//       return { op: '+', fs: [x[1], x[3]] };\n//     });\n//     const impP = fmap(seq(token('('), formulaP, token('->'), formulaP, token(')')), x => {\n//       return { op: '->', fs: [x[1], x[3]] };\n//     });\n//     const notP = fmap(seq(token('-'), formulaP), x => {\n//       return { op: '-', fs: [x[1]] };\n//     });\n//     const valP = fmap(oneOf('abcdefghijkTF'), x => { return { val: x, fs: [] }; });\n//     return choice(andP, orP, impP, notP, valP);\n//   });\n//   const equationP = fmap(seq(formulaP, token('='), formulaP), x => {\n//     return { left: x[0], right: x[2] };\n//   });\n\n//   stdin.toString().split('\\n').forEach(s => {\n//     if (s == '#') process.exit(0);\n//     // const r = equationP(s, 0);\n//     // let isValid = true;\n//     // for (let i = 0; i < (1 << 11); i++) {\n//     //   isValid &= evalF(r[1].left) === evalF(r[1].right);\n//     //   function toBool(c) {\n//     //     if (c === 'T') return true;\n//     //     if (c === 'F') return false;\n//     //     return !!(i >> (c.charCodeAt() - 'a'.charCodeAt()) & 1);\n//     //   }\n//     //   function evalF(f) {\n//     //     switch (f.fs.length) {\n//     //       case 0: return toBool(f.val);\n//     //       case 1: return !evalF(f.fs[0]);\n//     //       case 2:\n//     //         switch (f.op) {\n//     //           case '*': return evalF(f.fs[0]) && evalF(f.fs[1]);\n//     //           case '+': return evalF(f.fs[0]) || evalF(f.fs[1]);\n//     //           case '->': return !evalF(f.fs[0]) || evalF(f.fs[1]);\n//     //         }\n//     //     }\n//     //   }\n//     // }\n//     // console.log(isValid ? 'YES' : 'NO');\n//   });\n// })(require('fs').readFileSync('/dev/stdin', 'utf8'));"
  },
  {
    "language": "JavaScript",
    "code": "'use strict';\n\nfunction token(s) {\n  var len = s.length;\n  return function (target, pos) {\n    return target.substr(pos, len) === s ? [true, s, pos + len]\n      : [false, null, pos];\n  }\n}\n\nfunction choice() {\n  var parsers = arguments;\n  return function (target, pos) {\n    for (var i = 0; i < parsers.length; i++) {\n      var parsed = parsers[i](target, pos);\n      if (parsed[0]) return parsed;\n    }\n    return [false, null, pos];\n  };\n}\n\nfunction seq() {\n  var parsers = arguments;\n  return function (target, pos) {\n    var result = [];\n    var nextPos = pos;\n    for (var i = 0; i < parsers.length; i++) {\n      var parsed = parsers[i](target, nextPos);\n      if (!parsed[0]) return [false, null, pos];\n      result.push(parsed[1]);\n      nextPos = parsed[2];\n    }\n    return [true, result, nextPos];\n  };\n}\n\nfunction lazy(f) {\n  var parser;\n  return function (target, position) {\n    if (!parser) parser = f();\n    return parser(target, position);\n  };\n}\n\nfunction fmap(parser, f) {\n  return function (target, pos) {\n    var result = parser(target, pos);\n    return result[0] ? [result[0], f(result[1]), result[2]]\n      : result;\n  };\n}\n\nfunction oneOf(s) {\n  var d = {};\n  for (var i = 0; i < s.length; i++) d[s[i]] = s[i];\n  return function (target, pos) {\n    var c = target.substr(pos, 1);\n    return d[c] ? [true, c, pos + 1] : [false, null, pos];\n  };\n}\n\n(function (stdin) {\n  var formulaP = lazy(function () {\n    var andP = fmap(seq(token('('), formulaP, token('*'), formulaP, token(')')), function (x) {\n      return { op: '*', fs: [x[1], x[3]] };\n    });\n    var orP = fmap(seq(token('('), formulaP, token('+'), formulaP, token(')')), function (x) {\n      return { op: '+', fs: [x[1], x[3]] };\n    });\n    var impP = fmap(seq(token('('), formulaP, token('->'), formulaP, token(')')), function (x) {\n      return { op: '->', fs: [x[1], x[3]] };\n    });\n    var notP = fmap(seq(token('-'), formulaP), function (x) {\n      return { op: '-', fs: [x[1]] };\n    });\n    var valP = fmap(oneOf('abcdefghijkTF'), function (x) { return { val: x, fs: [] }; });\n    return choice(andP, orP, impP, notP, valP);\n  });\n  var equationP = fmap(seq(formulaP, token('='), formulaP), function (x) {\n    return { left: x[0], right: x[2] };\n  });\n\n  stdin.toString().split('\\n').forEach(function (s) {\n    if (s == '#') process.exit(0);\n    var r = equationP(s, 0);\n    var isValid = true;\n    for (var i = 0; i < (1 << 11); i++) {\n      // isValid &= evalF(r[1].left) === evalF(r[1].right);\n      function toBool(c) {\n        if (c === 'T') return true;\n        if (c === 'F') return false;\n        return !!(i >> (c.charCodeAt() - 'a'.charCodeAt()) & 1);\n      }\n      // function evalF(f) {\n      //   switch (f.fs.length) {\n      //     case 0: return toBool(f.val);\n      //     case 1: return !evalF(f.fs[0]);\n      //     case 2:\n      //       switch (f.op) {\n      //         case '*': return evalF(f.fs[0]) && evalF(f.fs[1]);\n      //         case '+': return evalF(f.fs[0]) || evalF(f.fs[1]);\n      //         case '->': return !evalF(f.fs[0]) || evalF(f.fs[1]);\n      //       }\n      //   }\n      // }\n    }\n    console.log(isValid ? 'YES' : 'NO');\n  });\n})(require('fs').readFileSync('/dev/stdin', 'utf8'));"
  },
  {
    "language": "JavaScript",
    "code": "function token(s) {\n  var len = s.length;\n  return function (target, pos) {\n    return target.substr(pos, len) === s ? [true, s, pos + len]\n      : [false, null, pos];\n  };\n}\n\nfunction choice() {\n  var parsers = arguments;\n  return function (target, pos) {\n    for (var i = 0; i < parsers.length; i++) {\n      var parsed = parsers[i](target, pos);\n      if (parsed[0]) return parsed;\n    }\n    return [false, null, pos];\n  };\n}\n\nfunction seq() {\n  var parsers = arguments;\n  return function (target, pos) {\n    var result = [];\n    var nextPos = pos;\n    for (var i = 0; i < parsers.length; i++) {\n      var parsed = parsers[i](target, nextPos);\n      if (!parsed[0]) return [false, null, pos];\n      result.push(parsed[1]);\n      nextPos = parsed[2];\n    }\n    return [true, result, nextPos];\n  };\n}\n\nfunction lazy(f) {\n  var parser;\n  return function (target, position) {\n    if (!parser) parser = f();\n    return parser(target, position);\n  };\n}\n\nfunction fmap(parser, f) {\n  return function (target, pos) {\n    var result = parser(target, pos);\n    return result[0] ? [result[0], f(result[1]), result[2]]\n      : result;\n  };\n}\n\nfunction oneOf(s) {\n  var d = {};\n  for (var i = 0; i < s.length; i++) d[s[i]] = s[i];\n  return function (target, pos) {\n    var c = target.substr(pos, 1);\n    return d[c] ? [true, c, pos + 1] : [false, null, pos];\n  };\n}\n\n(function (stdin) {\n  var formulaP = lazy(function () {\n    var andP = fmap(seq(token('('), formulaP, token('*'), formulaP, token(')')), function (x) {\n      return { op: '*', fs: [x[1], x[3]] };\n    });\n    var orP = fmap(seq(token('('), formulaP, token('+'), formulaP, token(')')), function (x) {\n      return { op: '+', fs: [x[1], x[3]] };\n    });\n    var impP = fmap(seq(token('('), formulaP, token('->'), formulaP, token(')')), function (x) {\n      return { op: '->', fs: [x[1], x[3]] };\n    });\n    var notP = fmap(seq(token('-'), formulaP), function (x) {\n      return { op: '-', fs: [x[1]] };\n    });\n    var valP = fmap(oneOf('abcdefghijkTF'), function (x) { return { val: x, fs: [] }; });\n    return choice(andP, orP, impP, notP, valP);\n  });\n  var equationP = fmap(seq(formulaP, token('='), formulaP), function (x) {\n    return { left: x[0], right: x[2] };\n  });\n\n  stdin.toString().split('\\n').forEach(function (s) {\n    if (s == '#') process.exit(0);\n    var r = equationP(s, 0);\n    var isValid = true;\n    var toBool = function (c) {\n      if (c === 'T') return true;\n      if (c === 'F') return false;\n      return !!(i >> (c.charCodeAt() - 'a'.charCodeAt()) & 1);\n    };\n    var evalF = function (f) {\n      switch (f.fs.length) {\n        case 0: return toBool(f.val);\n        case 1: return !evalF(f.fs[0]);\n        case 2:\n          switch (f.op) {\n            case '*': return evalF(f.fs[0]) && evalF(f.fs[1]);\n            case '+': return evalF(f.fs[0]) || evalF(f.fs[1]);\n            case '->': return !evalF(f.fs[0]) || evalF(f.fs[1]);\n          }\n      }\n    };\n    for (var i = 0; i < (1 << 11); i++) isValid &= evalF(r[1].left) === evalF(r[1].right);\n    console.log(isValid ? 'YES' : 'NO');\n  });\n})(require('fs').readFileSync('/dev/stdin', 'utf8'));"
  },
  {
    "language": "JavaScript",
    "code": "'use strict';\n\nfunction token(s) {\n  var len = s.length;\n  return function (target, pos) {\n    return target.substr(pos, len) === s ? [true, s, pos + len]\n      : [false, null, pos];\n  }\n}\n\nfunction choice() {\n  var parsers = arguments;\n  return function (target, pos) {\n    for (var i = 0; i < parsers.length; i++) {\n      var parsed = parsers[i](target, pos);\n      if (parsed[0]) return parsed;\n    }\n    return [false, null, pos];\n  };\n}\n\nfunction seq() {\n  var parsers = arguments;\n  return function (target, pos) {\n    var result = [];\n    var nextPos = pos;\n    for (var i = 0; i < parsers.length; i++) {\n      var parsed = parsers[i](target, nextPos);\n      if (!parsed[0]) return [false, null, pos];\n      result.push(parsed[1]);\n      nextPos = parsed[2];\n    }\n    return [true, result, nextPos];\n  };\n}\n\nfunction lazy(f) {\n  var parser;\n  return function (target, position) {\n    if (!parser) parser = f();\n    return parser(target, position);\n  };\n}\n\nfunction fmap(parser, f) {\n  return function (target, pos) {\n    var result = parser(target, pos);\n    return result[0] ? [result[0], f(result[1]), result[2]]\n      : result;\n  };\n}\n\nfunction oneOf(s) {\n  var d = {};\n  for (var i = 0; i < s.length; i++) d[s[i]] = s[i];\n  return function (target, pos) {\n    var c = target.substr(pos, 1);\n    return d[c] ? [true, c, pos + 1] : [false, null, pos];\n  };\n}\n\n(function (stdin) {\n  var formulaP = lazy(function () {\n    var andP = fmap(seq(token('('), formulaP, token('*'), formulaP, token(')')), function (x) {\n      return { op: '*', fs: [x[1], x[3]] };\n    });\n    var orP = fmap(seq(token('('), formulaP, token('+'), formulaP, token(')')), function (x) {\n      return { op: '+', fs: [x[1], x[3]] };\n    });\n    var impP = fmap(seq(token('('), formulaP, token('->'), formulaP, token(')')), function (x) {\n      return { op: '->', fs: [x[1], x[3]] };\n    });\n    var notP = fmap(seq(token('-'), formulaP), function (x) {\n      return { op: '-', fs: [x[1]] };\n    });\n    var valP = fmap(oneOf('abcdefghijkTF'), function (x) { return { val: x, fs: [] }; });\n    return choice(andP, orP, impP, notP, valP);\n  });\n  var equationP = fmap(seq(formulaP, token('='), formulaP), function (x) {\n    return { left: x[0], right: x[2] };\n  });\n\n  stdin.toString().split('\\n').forEach(function (s) {\n    if (s == '#') process.exit(0);\n    var r = equationP(s, 0);\n    var isValid = true;\n    for (var i = 0; i < (1 << 11); i++) {\n      var toBool = function (c) {\n        if (c === 'T') return true;\n        if (c === 'F') return false;\n        return !!(i >> (c.charCodeAt() - 'a'.charCodeAt()) & 1);\n      }\n      var evalF = function (f) {\n        switch (f.fs.length) {\n          case 0: return toBool(f.val);\n          case 1: return !evalF(f.fs[0]);\n          case 2:\n            switch (f.op) {\n              case '*': return evalF(f.fs[0]) && evalF(f.fs[1]);\n              case '+': return evalF(f.fs[0]) || evalF(f.fs[1]);\n              case '->': return !evalF(f.fs[0]) || evalF(f.fs[1]);\n            }\n        }\n      }\n      // isValid &= evalF(r[1].left) === evalF(r[1].right);\n    }\n    console.log(isValid ? 'YES' : 'NO');\n  });\n})(require('fs').readFileSync('/dev/stdin', 'utf8'));"
  },
  {
    "language": "JavaScript",
    "code": "'use strict';\n\nfunction token(s) {\n  const len = s.length;\n  return (target, pos) =>\n    target.substr(pos, len) === s ? [true, s, pos + len]\n      : [false, null, pos];\n}\n\nfunction choice() {\n  const parsers = arguments;\n  return (target, pos) => {\n    for (let parser of parsers) {\n      const parsed = parser(target, pos);\n      if (parsed[0]) return parsed;\n    }\n    return [false, null, pos];\n  };\n}\n\nfunction seq() {\n  const parsers = arguments;\n  return (target, pos) => {\n    const result = [];\n    let nextPos = pos;\n    for (let parser of parsers) {\n      const parsed = parser(target, nextPos);\n      if (!parsed[0]) return [false, null, pos];\n      result.push(parsed[1]);\n      nextPos = parsed[2];\n    }\n    return [true, result, nextPos];\n  };\n}\n\nfunction lazy(f) {\n  let parser;\n  return function (target, position) {\n    if (!parser) parser = f();\n    return parser(target, position);\n  };\n}\n\nfunction fmap(parser, f) {\n  return (target, pos) => {\n    const result = parser(target, pos);\n    if (result[0]) {\n      return [result[0], f(result[1]), result[2]];\n    } else {\n      return result;\n    }\n  };\n}\n\nfunction oneOf(s) {\n  let d = {};\n  for (let c of s) d[c] = c;\n  return (target, pos) => {\n    const c = target.substr(pos, 1);\n    return d[c] ? [true, c, pos + 1] : [false, null, pos];\n  };\n}\n\n(stdin => {\n  const formulaP = lazy(() => {\n    const andP = fmap(seq(token('('), formulaP, token('*'), formulaP, token(')')), x => {\n      return { op: '*', fs: [x[1], x[3]] };\n    });\n    const orP = fmap(seq(token('('), formulaP, token('+'), formulaP, token(')')), x => {\n      return { op: '+', fs: [x[1], x[3]] };\n    });\n    const impP = fmap(seq(token('('), formulaP, token('->'), formulaP, token(')')), x => {\n      return { op: '->', fs: [x[1], x[3]] };\n    });\n    const notP = fmap(seq(token('-'), formulaP), x => {\n      return { op: '-', fs: [x[1]] };\n    });\n    const valP = fmap(oneOf('abcdefghijkTF'), x => { return { val: x, fs: [] }; });\n    return choice(andP, orP, impP, notP, valP);\n  });\n  const equationP = fmap(seq(formulaP, token('='), formulaP), x => {\n    return { left: x[0], right: x[2] };\n  });\n\n  stdin.toString().split('\\n').forEach(s => {\n    if (s == '#') process.exit(0);\n    // const r = equationP(s, 0);\n    // let isValid = true;\n    // for (let i = 0; i < (1 << 11); i++) {\n    //   isValid &= evalF(r[1].left) === evalF(r[1].right);\n    //   function toBool(c) {\n    //     if (c === 'T') return true;\n    //     if (c === 'F') return false;\n    //     return !!(i >> (c.charCodeAt() - 'a'.charCodeAt()) & 1);\n    //   }\n    //   function evalF(f) {\n    //     switch (f.fs.length) {\n    //       case 0: return toBool(f.val);\n    //       case 1: return !evalF(f.fs[0]);\n    //       case 2:\n    //         switch (f.op) {\n    //           case '*': return evalF(f.fs[0]) && evalF(f.fs[1]);\n    //           case '+': return evalF(f.fs[0]) || evalF(f.fs[1]);\n    //           case '->': return !evalF(f.fs[0]) || evalF(f.fs[1]);\n    //         }\n    //     }\n    //   }\n    // }\n    // console.log(isValid ? 'YES' : 'NO');\n  });\n})(require('fs').readFileSync('/dev/stdin', 'utf8'));"
  },
  {
    "language": "JavaScript",
    "code": "'use strict';\n\nfunction token(s) {\n  var len = s.length;\n  return function (target, pos) {\n    return target.substr(pos, len) === s ? [true, s, pos + len]\n      : [false, null, pos];\n  }\n}\n\nfunction choice() {\n  var parsers = arguments;\n  return function (target, pos) {\n    for (var i = 0; i < parsers.length; i++) {\n      var parsed = parsers[i](target, pos);\n      if (parsed[0]) return parsed;\n    }\n    return [false, null, pos];\n  };\n}\n\nfunction seq() {\n  var parsers = arguments;\n  return function (target, pos) {\n    var result = [];\n    var nextPos = pos;\n    for (var i = 0; i < parsers.length; i++) {\n      var parsed = parser[i](target, nextPos);\n      if (!parsed[0]) return [false, null, pos];\n      result.push(parsed[1]);\n      nextPos = parsed[2];\n    }\n    return [true, result, nextPos];\n  };\n}\n\nfunction lazy(f) {\n  var parser;\n  return function (target, position) {\n    if (!parser) parser = f();\n    return parser(target, position);\n  };\n}\n\nfunction fmap(parser, f) {\n  return function (target, pos) {\n    var result = parser(target, pos);\n    return result[0] ? [result[0], f(result[1]), result[2]]\n      : result;\n  };\n}\n\nfunction oneOf(s) {\n  var d = {};\n  for (var i = 0; i < s.length; i++) d[s[i]] = s[i];\n  return function (target, pos) {\n    var c = target.substr(pos, 1);\n    return d[c] ? [true, c, pos + 1] : [false, null, pos];\n  };\n}\n\n// (stdin => {\n//   const formulaP = lazy(() => {\n//     const andP = fmap(seq(token('('), formulaP, token('*'), formulaP, token(')')), x => {\n//       return { op: '*', fs: [x[1], x[3]] };\n//     });\n//     const orP = fmap(seq(token('('), formulaP, token('+'), formulaP, token(')')), x => {\n//       return { op: '+', fs: [x[1], x[3]] };\n//     });\n//     const impP = fmap(seq(token('('), formulaP, token('->'), formulaP, token(')')), x => {\n//       return { op: '->', fs: [x[1], x[3]] };\n//     });\n//     const notP = fmap(seq(token('-'), formulaP), x => {\n//       return { op: '-', fs: [x[1]] };\n//     });\n//     const valP = fmap(oneOf('abcdefghijkTF'), x => { return { val: x, fs: [] }; });\n//     return choice(andP, orP, impP, notP, valP);\n//   });\n//   const equationP = fmap(seq(formulaP, token('='), formulaP), x => {\n//     return { left: x[0], right: x[2] };\n//   });\n\n//   stdin.toString().split('\\n').forEach(s => {\n//     if (s == '#') process.exit(0);\n//     // const r = equationP(s, 0);\n//     // let isValid = true;\n//     // for (let i = 0; i < (1 << 11); i++) {\n//     //   isValid &= evalF(r[1].left) === evalF(r[1].right);\n//     //   function toBool(c) {\n//     //     if (c === 'T') return true;\n//     //     if (c === 'F') return false;\n//     //     return !!(i >> (c.charCodeAt() - 'a'.charCodeAt()) & 1);\n//     //   }\n//     //   function evalF(f) {\n//     //     switch (f.fs.length) {\n//     //       case 0: return toBool(f.val);\n//     //       case 1: return !evalF(f.fs[0]);\n//     //       case 2:\n//     //         switch (f.op) {\n//     //           case '*': return evalF(f.fs[0]) && evalF(f.fs[1]);\n//     //           case '+': return evalF(f.fs[0]) || evalF(f.fs[1]);\n//     //           case '->': return !evalF(f.fs[0]) || evalF(f.fs[1]);\n//     //         }\n//     //     }\n//     //   }\n//     // }\n//     // console.log(isValid ? 'YES' : 'NO');\n//   });\n// })(require('fs').readFileSync('/dev/stdin', 'utf8'));"
  },
  {
    "language": "JavaScript",
    "code": "'use strict';\n\nfunction token(s) {\n  var len = s.length;\n  return function (target, pos) {\n    return target.substr(pos, len) === s ? [true, s, pos + len]\n      : [false, null, pos];\n  }\n}\n\nfunction choice() {\n  var parsers = arguments;\n  return function (target, pos) {\n    for (var i = 0; i < parsers.length; i++) {\n      var parsed = parsers[i](target, pos);\n      if (parsed[0]) return parsed;\n    }\n    return [false, null, pos];\n  };\n}\n\nfunction seq() {\n  var parsers = arguments;\n  return function (target, pos) {\n    var result = [];\n    var nextPos = pos;\n    for (var i = 0; i < parsers.length; i++) {\n      var parsed = parsers[i](target, nextPos);\n      if (!parsed[0]) return [false, null, pos];\n      result.push(parsed[1]);\n      nextPos = parsed[2];\n    }\n    return [true, result, nextPos];\n  };\n}\n\nfunction lazy(f) {\n  var parser;\n  return function (target, position) {\n    if (!parser) parser = f();\n    return parser(target, position);\n  };\n}\n\nfunction fmap(parser, f) {\n  return function (target, pos) {\n    var result = parser(target, pos);\n    return result[0] ? [result[0], f(result[1]), result[2]]\n      : result;\n  };\n}\n\nfunction oneOf(s) {\n  var d = {};\n  for (var i = 0; i < s.length; i++) d[s[i]] = s[i];\n  return function (target, pos) {\n    var c = target.substr(pos, 1);\n    return d[c] ? [true, c, pos + 1] : [false, null, pos];\n  };\n}\n\n(function (stdin) {\n  var formulaP = lazy(function () {\n    var andP = fmap(seq(token('('), formulaP, token('*'), formulaP, token(')')), function (x) {\n      return { op: '*', fs: [x[1], x[3]] };\n    });\n    var orP = fmap(seq(token('('), formulaP, token('+'), formulaP, token(')')), function (x) {\n      return { op: '+', fs: [x[1], x[3]] };\n    });\n    var impP = fmap(seq(token('('), formulaP, token('->'), formulaP, token(')')), function (x) {\n      return { op: '->', fs: [x[1], x[3]] };\n    });\n    var notP = fmap(seq(token('-'), formulaP), function (x) {\n      return { op: '-', fs: [x[1]] };\n    });\n    var valP = fmap(oneOf('abcdefghijkTF'), function (x) { return { val: x, fs: [] }; });\n    return choice(andP, orP, impP, notP, valP);\n  });\n  var equationP = fmap(seq(formulaP, token('='), formulaP), function (x) {\n    return { left: x[0], right: x[2] };\n  });\n\n  stdin.toString().split('\\n').forEach(function (s) {\n    if (s == '#') process.exit(0);\n    var r = equationP(s, 0);\n    var isValid = true;\n    for (var i = 0; i < (1 << 11); i++) {\n      isValid &= evalF(r[1].left) === evalF(r[1].right);\n      function toBool(c) {\n        if (c === 'T') return true;\n        if (c === 'F') return false;\n        return !!(i >> (c.charCodeAt() - 'a'.charCodeAt()) & 1);\n      }\n      function evalF(f) {\n        switch (f.fs.length) {\n          case 0: return toBool(f.val);\n          case 1: return !evalF(f.fs[0]);\n          case 2:\n            switch (f.op) {\n              case '*': return evalF(f.fs[0]) && evalF(f.fs[1]);\n              case '+': return evalF(f.fs[0]) || evalF(f.fs[1]);\n              case '->': return !evalF(f.fs[0]) || evalF(f.fs[1]);\n            }\n        }\n      }\n    }\n    console.log(isValid ? 'YES' : 'NO');\n  });\n})(require('fs').readFileSync('/dev/stdin', 'utf8'));"
  },
  {
    "language": "JavaScript",
    "code": "function token(s) {\n  var len = s.length;\n  return function (target, pos) {\n    return target.substr(pos, len) === s ? [true, s, pos + len]\n      : [false, null, pos];\n  };\n}\n\nfunction choice() {\n  var parsers = arguments;\n  return function (target, pos) {\n    for (var i = 0; i < parsers.length; i++) {\n      var parsed = parsers[i](target, pos);\n      if (parsed[0]) return parsed;\n    }\n    return [false, null, pos];\n  };\n}\n\nfunction seq() {\n  var parsers = arguments;\n  return function (target, pos) {\n    var result = [];\n    var nextPos = pos;\n    for (var i = 0; i < parsers.length; i++) {\n      var parsed = parsers[i](target, nextPos);\n      if (!parsed[0]) return [false, null, pos];\n      result.push(parsed[1]);\n      nextPos = parsed[2];\n    }\n    return [true, result, nextPos];\n  };\n}\n\nfunction lazy(f) {\n  var parser;\n  return function (target, position) {\n    if (!parser) parser = f();\n    return parser(target, position);\n  };\n}\n\nfunction fmap(parser, f) {\n  return function (target, pos) {\n    var result = parser(target, pos);\n    return result[0] ? [result[0], f(result[1]), result[2]]\n      : result;\n  };\n}\n\nfunction oneOf(s) {\n  var d = {};\n  for (var i = 0; i < s.length; i++) d[s[i]] = s[i];\n  return function (target, pos) {\n    var c = target.substr(pos, 1);\n    return d[c] ? [true, c, pos + 1] : [false, null, pos];\n  };\n}\n\n(function (stdin) {\n  var formulaP = lazy(function () {\n    var andP = fmap(seq(token('('), formulaP, token('*'), formulaP, token(')')), function (x) {\n      return { op: '*', fs: [x[1], x[3]] };\n    });\n    var orP = fmap(seq(token('('), formulaP, token('+'), formulaP, token(')')), function (x) {\n      return { op: '+', fs: [x[1], x[3]] };\n    });\n    var impP = fmap(seq(token('('), formulaP, token('->'), formulaP, token(')')), function (x) {\n      return { op: '->', fs: [x[1], x[3]] };\n    });\n    var notP = fmap(seq(token('-'), formulaP), function (x) {\n      return { op: '-', fs: [x[1]] };\n    });\n    var valP = fmap(oneOf('abcdefghijkTF'), function (x) { return { val: x, fs: [] }; });\n    return choice(andP, orP, impP, notP, valP);\n  });\n  var equationP = fmap(seq(formulaP, token('='), formulaP), function (x) {\n    return { left: x[0], right: x[2] };\n  });\n\n  stdin.toString().split('\\n').forEach(function (s) {\n    if (s == '#') process.exit(0);\n    var r = equationP(s, 0);\n    var isValid = true;\n    for (var i = 0; i < (1 << 11); i++) {\n      var toBool = function (c) {\n        if (c === 'T') return true;\n        if (c === 'F') return false;\n        return !!(i >> (c.charCodeAt() - 'a'.charCodeAt()) & 1);\n      };\n      var evalF = function (f) {\n        switch (f.fs.length) {\n          case 0: return toBool(f.val);\n          case 1: return !evalF(f.fs[0]);\n          case 2:\n            switch (f.op) {\n              case '*': return evalF(f.fs[0]) && evalF(f.fs[1]);\n              case '+': return evalF(f.fs[0]) || evalF(f.fs[1]);\n              case '->': return !evalF(f.fs[0]) || evalF(f.fs[1]);\n            }\n        }\n      };\n      isValid &= evalF(r[1].left) === evalF(r[1].right);\n    }\n    console.log(isValid ? 'YES' : 'NO');\n  });\n})(require('fs').readFileSync('/dev/stdin', 'utf8'));"
  },
  {
    "language": "JavaScript",
    "code": "'use strict';\n\nfunction token(s) {\n  var len = s.length;\n  return function (target, pos) {\n    return target.substr(pos, len) === s ? [true, s, pos + len]\n      : [false, null, pos];\n  }\n}\n\nfunction choice() {\n  var parsers = arguments;\n  return function (target, pos) {\n    for (var i = 0; i < parsers.length; i++) {\n      var parsed = parsers[i](target, pos);\n      if (parsed[0]) return parsed;\n    }\n    return [false, null, pos];\n  };\n}\n\nfunction seq() {\n  var parsers = arguments;\n  return function (target, pos) {\n    var result = [];\n    var nextPos = pos;\n    for (var i = 0; i < parsers.length; i++) {\n      var parsed = parser[i](target, nextPos);\n      if (!parsed[0]) return [false, null, pos];\n      result.push(parsed[1]);\n      nextPos = parsed[2];\n    }\n    return [true, result, nextPos];\n  };\n}\n\nfunction lazy(f) {\n  var parser;\n  return function (target, position) {\n    if (!parser) parser = f();\n    return parser(target, position);\n  };\n}\n\nfunction fmap(parser, f) {\n  return function (target, pos) {\n    var result = parser(target, pos);\n    return result[0] ? [result[0], f(result[1]), result[2]]\n      : result;\n  };\n}\n\nfunction oneOf(s) {\n  var d = {};\n  for (var i = 0; i < s.length; i++) d[s[i]] = s[i];\n  return function (target, pos) {\n    const c = target.substr(pos, 1);\n    return d[c] ? [true, c, pos + 1] : [false, null, pos];\n  };\n}\n\n// (stdin => {\n//   const formulaP = lazy(() => {\n//     const andP = fmap(seq(token('('), formulaP, token('*'), formulaP, token(')')), x => {\n//       return { op: '*', fs: [x[1], x[3]] };\n//     });\n//     const orP = fmap(seq(token('('), formulaP, token('+'), formulaP, token(')')), x => {\n//       return { op: '+', fs: [x[1], x[3]] };\n//     });\n//     const impP = fmap(seq(token('('), formulaP, token('->'), formulaP, token(')')), x => {\n//       return { op: '->', fs: [x[1], x[3]] };\n//     });\n//     const notP = fmap(seq(token('-'), formulaP), x => {\n//       return { op: '-', fs: [x[1]] };\n//     });\n//     const valP = fmap(oneOf('abcdefghijkTF'), x => { return { val: x, fs: [] }; });\n//     return choice(andP, orP, impP, notP, valP);\n//   });\n//   const equationP = fmap(seq(formulaP, token('='), formulaP), x => {\n//     return { left: x[0], right: x[2] };\n//   });\n\n//   stdin.toString().split('\\n').forEach(s => {\n//     if (s == '#') process.exit(0);\n//     // const r = equationP(s, 0);\n//     // let isValid = true;\n//     // for (let i = 0; i < (1 << 11); i++) {\n//     //   isValid &= evalF(r[1].left) === evalF(r[1].right);\n//     //   function toBool(c) {\n//     //     if (c === 'T') return true;\n//     //     if (c === 'F') return false;\n//     //     return !!(i >> (c.charCodeAt() - 'a'.charCodeAt()) & 1);\n//     //   }\n//     //   function evalF(f) {\n//     //     switch (f.fs.length) {\n//     //       case 0: return toBool(f.val);\n//     //       case 1: return !evalF(f.fs[0]);\n//     //       case 2:\n//     //         switch (f.op) {\n//     //           case '*': return evalF(f.fs[0]) && evalF(f.fs[1]);\n//     //           case '+': return evalF(f.fs[0]) || evalF(f.fs[1]);\n//     //           case '->': return !evalF(f.fs[0]) || evalF(f.fs[1]);\n//     //         }\n//     //     }\n//     //   }\n//     // }\n//     // console.log(isValid ? 'YES' : 'NO');\n//   });\n// })(require('fs').readFileSync('/dev/stdin', 'utf8'));"
  },
  {
    "language": "JavaScript",
    "code": "'use strict';\n\nfunction token(s) {\n  var len = s.length;\n  return function (target, pos) {\n    return target.substr(pos, len) === s ? [true, s, pos + len] : [false, null, pos];\n  };\n}\n\nfunction choice() {\n  var parsers = arguments;\n  return function (target, pos) {\n    var _iteratorNormalCompletion = true;\n    var _didIteratorError = false;\n    var _iteratorError = undefined;\n\n    try {\n      for (var _iterator = parsers[Symbol.iterator](), _step; !(_iteratorNormalCompletion = (_step = _iterator.next()).done); _iteratorNormalCompletion = true) {\n        var parser = _step.value;\n\n        var parsed = parser(target, pos);\n        if (parsed[0]) return parsed;\n      }\n    } catch (err) {\n      _didIteratorError = true;\n      _iteratorError = err;\n    } finally {\n      try {\n        if (!_iteratorNormalCompletion && _iterator.return) {\n          _iterator.return();\n        }\n      } finally {\n        if (_didIteratorError) {\n          throw _iteratorError;\n        }\n      }\n    }\n\n    return [false, null, pos];\n  };\n}\n\nfunction seq() {\n  var parsers = arguments;\n  return function (target, pos) {\n    var result = [];\n    var nextPos = pos;\n    var _iteratorNormalCompletion2 = true;\n    var _didIteratorError2 = false;\n    var _iteratorError2 = undefined;\n\n    try {\n      for (var _iterator2 = parsers[Symbol.iterator](), _step2; !(_iteratorNormalCompletion2 = (_step2 = _iterator2.next()).done); _iteratorNormalCompletion2 = true) {\n        var parser = _step2.value;\n\n        var parsed = parser(target, nextPos);\n        if (!parsed[0]) return [false, null, pos];\n        result.push(parsed[1]);\n        nextPos = parsed[2];\n      }\n    } catch (err) {\n      _didIteratorError2 = true;\n      _iteratorError2 = err;\n    } finally {\n      try {\n        if (!_iteratorNormalCompletion2 && _iterator2.return) {\n          _iterator2.return();\n        }\n      } finally {\n        if (_didIteratorError2) {\n          throw _iteratorError2;\n        }\n      }\n    }\n\n    return [true, result, nextPos];\n  };\n}\n\nfunction lazy(f) {\n  var parser = void 0;\n  return function (target, position) {\n    if (!parser) parser = f();\n    return parser(target, position);\n  };\n}\n\nfunction fmap(parser, f) {\n  return function (target, pos) {\n    var result = parser(target, pos);\n    if (result[0]) {\n      return [result[0], f(result[1]), result[2]];\n    } else {\n      return result;\n    }\n  };\n}\n\nfunction oneOf(s) {\n  var d = {};\n  var _iteratorNormalCompletion3 = true;\n  var _didIteratorError3 = false;\n  var _iteratorError3 = undefined;\n\n  try {\n    for (var _iterator3 = s[Symbol.iterator](), _step3; !(_iteratorNormalCompletion3 = (_step3 = _iterator3.next()).done); _iteratorNormalCompletion3 = true) {\n      var c = _step3.value;\n      d[c] = c;\n    }\n  } catch (err) {\n    _didIteratorError3 = true;\n    _iteratorError3 = err;\n  } finally {\n    try {\n      if (!_iteratorNormalCompletion3 && _iterator3.return) {\n        _iterator3.return();\n      }\n    } finally {\n      if (_didIteratorError3) {\n        throw _iteratorError3;\n      }\n    }\n  }\n\n  return function (target, pos) {\n    var c = target.substr(pos, 1);\n    return d[c] ? [true, c, pos + 1] : [false, null, pos];\n  };\n}\n\n(function (stdin) {\n  var formulaP = lazy(function () {\n    var andP = fmap(seq(token('('), formulaP, token('*'), formulaP, token(')')), function (x) {\n      return { op: '*', fs: [x[1], x[3]] };\n    });\n    var orP = fmap(seq(token('('), formulaP, token('+'), formulaP, token(')')), function (x) {\n      return { op: '+', fs: [x[1], x[3]] };\n    });\n    var impP = fmap(seq(token('('), formulaP, token('->'), formulaP, token(')')), function (x) {\n      return { op: '->', fs: [x[1], x[3]] };\n    });\n    var notP = fmap(seq(token('-'), formulaP), function (x) {\n      return { op: '-', fs: [x[1]] };\n    });\n    var valP = fmap(oneOf('abcdefghijkTF'), function (x) {\n      return { val: x, fs: [] };\n    });\n    return choice(andP, orP, impP, notP, valP);\n  });\n  var equationP = fmap(seq(formulaP, token('='), formulaP), function (x) {\n    return { left: x[0], right: x[2] };\n  });\n\n  var lines = stdin.toString().trim().split('\\n');\n  lines.pop();\n  lines.forEach(function (s) {\n    var r = equationP(s, 0);\n    var isValid = true;\n\n    var _loop = function _loop(i) {\n      isValid &= evalF(r[1].left) === evalF(r[1].right);\n      function toBool(c) {\n        if (c === 'T') return true;\n        if (c === 'F') return false;\n        return !!(i >> c.charCodeAt() - 'a'.charCodeAt() & 1);\n      }\n      function evalF(f) {\n        switch (f.fs.length) {\n          case 0:\n            return toBool(f.val);\n          case 1:\n            return !evalF(f.fs[0]);\n          case 2:\n            switch (f.op) {\n              case '*':\n                return evalF(f.fs[0]) && evalF(f.fs[1]);\n              case '+':\n                return evalF(f.fs[0]) || evalF(f.fs[1]);\n              case '->':\n                return !evalF(f.fs[0]) || evalF(f.fs[1]);\n            }\n        }\n      }\n    };\n\n    for (var i = 0; i < 1 << 11; i++) {\n      _loop(i);\n    }\n    console.log(isValid ? 'YES' : 'NO');\n  });\n})(require('fs').readFileSync('/dev/stdin', 'utf8'));"
  },
  {
    "language": "JavaScript",
    "code": "'use strict';\n\nfunction token(s) {\n  var len = s.length;\n  return function (target, pos) {\n    return target.substr(pos, len) === s ? [true, s, pos + len]\n      : [false, null, pos];\n  }\n}\n\nfunction choice() {\n  var parsers = arguments;\n  return function (target, pos) {\n    for (var i = 0; i < parsers.length; i++) {\n      var parsed = parsers[i](target, pos);\n      if (parsed[0]) return parsed;\n    }\n    return [false, null, pos];\n  };\n}\n\nfunction seq() {\n  var parsers = arguments;\n  return function (target, pos) {\n    var result = [];\n    var nextPos = pos;\n    for (var i = 0; i < parsers.length; i++) {\n      var parsed = parsers[i](target, nextPos);\n      if (!parsed[0]) return [false, null, pos];\n      result.push(parsed[1]);\n      nextPos = parsed[2];\n    }\n    return [true, result, nextPos];\n  };\n}\n\nfunction lazy(f) {\n  var parser;\n  return function (target, position) {\n    if (!parser) parser = f();\n    return parser(target, position);\n  };\n}\n\nfunction fmap(parser, f) {\n  return function (target, pos) {\n    var result = parser(target, pos);\n    return result[0] ? [result[0], f(result[1]), result[2]]\n      : result;\n  };\n}\n\nfunction oneOf(s) {\n  var d = {};\n  for (var i = 0; i < s.length; i++) d[s[i]] = s[i];\n  return function (target, pos) {\n    var c = target.substr(pos, 1);\n    return d[c] ? [true, c, pos + 1] : [false, null, pos];\n  };\n}\n\n(function (stdin) {\n  var formulaP = lazy(function () {\n    var andP = fmap(seq(token('('), formulaP, token('*'), formulaP, token(')')), function (x) {\n      return { op: '*', fs: [x[1], x[3]] };\n    });\n    var orP = fmap(seq(token('('), formulaP, token('+'), formulaP, token(')')), function (x) {\n      return { op: '+', fs: [x[1], x[3]] };\n    });\n    var impP = fmap(seq(token('('), formulaP, token('->'), formulaP, token(')')), function (x) {\n      return { op: '->', fs: [x[1], x[3]] };\n    });\n    var notP = fmap(seq(token('-'), formulaP), function (x) {\n      return { op: '-', fs: [x[1]] };\n    });\n    var valP = fmap(oneOf('abcdefghijkTF'), function (x) { return { val: x, fs: [] }; });\n    return choice(andP, orP, impP, notP, valP);\n  });\n  var equationP = fmap(seq(formulaP, token('='), formulaP), function (x) {\n    return { left: x[0], right: x[2] };\n  });\n\n  stdin.toString().split('\\n').forEach(function (s) {\n    if (s == '#') process.exit(0);\n    var r = equationP(s, 0);\n    var isValid = true;\n    for (var i = 0; i < (1 << 11); i++) {\n      var toBool = function (c) {\n        if (c === 'T') return true;\n        if (c === 'F') return false;\n        return !!(i >> (c.charCodeAt() - 'a'.charCodeAt()) & 1);\n      }\n      var evalF = function (f) {\n        switch (f.fs.length) {\n          case 0: return toBool(f.val);\n          case 1: return !evalF(f.fs[0]);\n          case 2:\n            switch (f.op) {\n              case '*': return evalF(f.fs[0]) && evalF(f.fs[1]);\n              case '+': return evalF(f.fs[0]) || evalF(f.fs[1]);\n              case '->': return !evalF(f.fs[0]) || evalF(f.fs[1]);\n            }\n        }\n      }\n      isValid &= evalF(r[1].left) === evalF(r[1].right);\n    }\n    console.log(isValid ? 'YES' : 'NO');\n  });\n})(require('fs').readFileSync('/dev/stdin', 'utf8'));"
  },
  {
    "language": "JavaScript",
    "code": "'use strict';\n\nfunction token(s) {\n  var len = s.length;\n  return function (target, pos) {\n    return target.substr(pos, len) === s ? [true, s, pos + len]\n      : [false, null, pos];\n  }\n}\n\nfunction choice() {\n  var parsers = arguments;\n  return function (target, pos) {\n    for (var i = 0; i < parsers.length; i++) {\n      var parsed = parsers[i](target, pos);\n      if (parsed[0]) return parsed;\n    }\n    return [false, null, pos];\n  };\n}\n\nfunction seq() {\n  var parsers = arguments;\n  return function (target, pos) {\n    var result = [];\n    var nextPos = pos;\n    for (var i = 0; i < parsers.length; i++) {\n      var parsed = parser[i](target, nextPos);\n      if (!parsed[0]) return [false, null, pos];\n      result.push(parsed[1]);\n      nextPos = parsed[2];\n    }\n    return [true, result, nextPos];\n  };\n}\n\n// function lazy(f) {\n//   let parser;\n//   return function (target, position) {\n//     if (!parser) parser = f();\n//     return parser(target, position);\n//   };\n// }\n\n// function fmap(parser, f) {\n//   return (target, pos) => {\n//     const result = parser(target, pos);\n//     if (result[0]) {\n//       return [result[0], f(result[1]), result[2]];\n//     } else {\n//       return result;\n//     }\n//   };\n// }\n\n// function oneOf(s) {\n//   let d = {};\n//   for (let c of s) d[c] = c;\n//   return (target, pos) => {\n//     const c = target.substr(pos, 1);\n//     return d[c] ? [true, c, pos + 1] : [false, null, pos];\n//   };\n// }\n\n// (stdin => {\n//   const formulaP = lazy(() => {\n//     const andP = fmap(seq(token('('), formulaP, token('*'), formulaP, token(')')), x => {\n//       return { op: '*', fs: [x[1], x[3]] };\n//     });\n//     const orP = fmap(seq(token('('), formulaP, token('+'), formulaP, token(')')), x => {\n//       return { op: '+', fs: [x[1], x[3]] };\n//     });\n//     const impP = fmap(seq(token('('), formulaP, token('->'), formulaP, token(')')), x => {\n//       return { op: '->', fs: [x[1], x[3]] };\n//     });\n//     const notP = fmap(seq(token('-'), formulaP), x => {\n//       return { op: '-', fs: [x[1]] };\n//     });\n//     const valP = fmap(oneOf('abcdefghijkTF'), x => { return { val: x, fs: [] }; });\n//     return choice(andP, orP, impP, notP, valP);\n//   });\n//   const equationP = fmap(seq(formulaP, token('='), formulaP), x => {\n//     return { left: x[0], right: x[2] };\n//   });\n\n//   stdin.toString().split('\\n').forEach(s => {\n//     if (s == '#') process.exit(0);\n//     // const r = equationP(s, 0);\n//     // let isValid = true;\n//     // for (let i = 0; i < (1 << 11); i++) {\n//     //   isValid &= evalF(r[1].left) === evalF(r[1].right);\n//     //   function toBool(c) {\n//     //     if (c === 'T') return true;\n//     //     if (c === 'F') return false;\n//     //     return !!(i >> (c.charCodeAt() - 'a'.charCodeAt()) & 1);\n//     //   }\n//     //   function evalF(f) {\n//     //     switch (f.fs.length) {\n//     //       case 0: return toBool(f.val);\n//     //       case 1: return !evalF(f.fs[0]);\n//     //       case 2:\n//     //         switch (f.op) {\n//     //           case '*': return evalF(f.fs[0]) && evalF(f.fs[1]);\n//     //           case '+': return evalF(f.fs[0]) || evalF(f.fs[1]);\n//     //           case '->': return !evalF(f.fs[0]) || evalF(f.fs[1]);\n//     //         }\n//     //     }\n//     //   }\n//     // }\n//     // console.log(isValid ? 'YES' : 'NO');\n//   });\n// })(require('fs').readFileSync('/dev/stdin', 'utf8'));"
  },
  {
    "language": "JavaScript",
    "code": "// 'use strict';\n\n// function token(s) {\n//   const len = s.length;\n//   return (target, pos) =>\n//     target.substr(pos, len) === s ? [true, s, pos + len]\n//       : [false, null, pos];\n// }\n\n// function choice() {\n//   const parsers = arguments;\n//   return (target, pos) => {\n//     for (let parser of parsers) {\n//       const parsed = parser(target, pos);\n//       if (parsed[0]) return parsed;\n//     }\n//     return [false, null, pos];\n//   };\n// }\n\n// function seq() {\n//   const parsers = arguments;\n//   return (target, pos) => {\n//     const result = [];\n//     let nextPos = pos;\n//     for (let parser of parsers) {\n//       const parsed = parser(target, nextPos);\n//       if (!parsed[0]) return [false, null, pos];\n//       result.push(parsed[1]);\n//       nextPos = parsed[2];\n//     }\n//     return [true, result, nextPos];\n//   };\n// }\n\n// function lazy(f) {\n//   let parser;\n//   return function (target, position) {\n//     if (!parser) parser = f();\n//     return parser(target, position);\n//   };\n// }\n\n// function fmap(parser, f) {\n//   return (target, pos) => {\n//     const result = parser(target, pos);\n//     if (result[0]) {\n//       return [result[0], f(result[1]), result[2]];\n//     } else {\n//       return result;\n//     }\n//   };\n// }\n\n// function oneOf(s) {\n//   let d = {};\n//   for (let c of s) d[c] = c;\n//   return (target, pos) => {\n//     const c = target.substr(pos, 1);\n//     return d[c] ? [true, c, pos + 1] : [false, null, pos];\n//   };\n// }\n\n// (stdin => {\n//   const formulaP = lazy(() => {\n//     const andP = fmap(seq(token('('), formulaP, token('*'), formulaP, token(')')), x => {\n//       return { op: '*', fs: [x[1], x[3]] };\n//     });\n//     const orP = fmap(seq(token('('), formulaP, token('+'), formulaP, token(')')), x => {\n//       return { op: '+', fs: [x[1], x[3]] };\n//     });\n//     const impP = fmap(seq(token('('), formulaP, token('->'), formulaP, token(')')), x => {\n//       return { op: '->', fs: [x[1], x[3]] };\n//     });\n//     const notP = fmap(seq(token('-'), formulaP), x => {\n//       return { op: '-', fs: [x[1]] };\n//     });\n//     const valP = fmap(oneOf('abcdefghijkTF'), x => { return { val: x, fs: [] }; });\n//     return choice(andP, orP, impP, notP, valP);\n//   });\n//   const equationP = fmap(seq(formulaP, token('='), formulaP), x => {\n//     return { left: x[0], right: x[2] };\n//   });\n\n//   stdin.toString().split('\\n').forEach(s => {\n//     if (s == '#') process.exit(0);\n//     // const r = equationP(s, 0);\n//     // let isValid = true;\n//     // for (let i = 0; i < (1 << 11); i++) {\n//     //   isValid &= evalF(r[1].left) === evalF(r[1].right);\n//     //   function toBool(c) {\n//     //     if (c === 'T') return true;\n//     //     if (c === 'F') return false;\n//     //     return !!(i >> (c.charCodeAt() - 'a'.charCodeAt()) & 1);\n//     //   }\n//     //   function evalF(f) {\n//     //     switch (f.fs.length) {\n//     //       case 0: return toBool(f.val);\n//     //       case 1: return !evalF(f.fs[0]);\n//     //       case 2:\n//     //         switch (f.op) {\n//     //           case '*': return evalF(f.fs[0]) && evalF(f.fs[1]);\n//     //           case '+': return evalF(f.fs[0]) || evalF(f.fs[1]);\n//     //           case '->': return !evalF(f.fs[0]) || evalF(f.fs[1]);\n//     //         }\n//     //     }\n//     //   }\n//     // }\n//     // console.log(isValid ? 'YES' : 'NO');\n//   });\n// })(require('fs').readFileSync('/dev/stdin', 'utf8'));"
  },
  {
    "language": "JavaScript",
    "code": "'use strict';\nconsole.log('hey?');\n\n// function token(s) {\n//   const len = s.length;\n//   return (target, pos) =>\n//     target.substr(pos, len) === s ? [true, s, pos + len]\n//       : [false, null, pos];\n// }\n\n// function choice() {\n//   const parsers = arguments;\n//   return (target, pos) => {\n//     for (let parser of parsers) {\n//       const parsed = parser(target, pos);\n//       if (parsed[0]) return parsed;\n//     }\n//     return [false, null, pos];\n//   };\n// }\n\n// function seq() {\n//   const parsers = arguments;\n//   return (target, pos) => {\n//     const result = [];\n//     let nextPos = pos;\n//     for (let parser of parsers) {\n//       const parsed = parser(target, nextPos);\n//       if (!parsed[0]) return [false, null, pos];\n//       result.push(parsed[1]);\n//       nextPos = parsed[2];\n//     }\n//     return [true, result, nextPos];\n//   };\n// }\n\n// function lazy(f) {\n//   let parser;\n//   return function (target, position) {\n//     if (!parser) parser = f();\n//     return parser(target, position);\n//   };\n// }\n\n// function fmap(parser, f) {\n//   return (target, pos) => {\n//     const result = parser(target, pos);\n//     if (result[0]) {\n//       return [result[0], f(result[1]), result[2]];\n//     } else {\n//       return result;\n//     }\n//   };\n// }\n\n// function oneOf(s) {\n//   let d = {};\n//   for (let c of s) d[c] = c;\n//   return (target, pos) => {\n//     const c = target.substr(pos, 1);\n//     return d[c] ? [true, c, pos + 1] : [false, null, pos];\n//   };\n// }\n\n// (stdin => {\n//   const formulaP = lazy(() => {\n//     const andP = fmap(seq(token('('), formulaP, token('*'), formulaP, token(')')), x => {\n//       return { op: '*', fs: [x[1], x[3]] };\n//     });\n//     const orP = fmap(seq(token('('), formulaP, token('+'), formulaP, token(')')), x => {\n//       return { op: '+', fs: [x[1], x[3]] };\n//     });\n//     const impP = fmap(seq(token('('), formulaP, token('->'), formulaP, token(')')), x => {\n//       return { op: '->', fs: [x[1], x[3]] };\n//     });\n//     const notP = fmap(seq(token('-'), formulaP), x => {\n//       return { op: '-', fs: [x[1]] };\n//     });\n//     const valP = fmap(oneOf('abcdefghijkTF'), x => { return { val: x, fs: [] }; });\n//     return choice(andP, orP, impP, notP, valP);\n//   });\n//   const equationP = fmap(seq(formulaP, token('='), formulaP), x => {\n//     return { left: x[0], right: x[2] };\n//   });\n\n//   stdin.toString().split('\\n').forEach(s => {\n//     if (s == '#') process.exit(0);\n//     // const r = equationP(s, 0);\n//     // let isValid = true;\n//     // for (let i = 0; i < (1 << 11); i++) {\n//     //   isValid &= evalF(r[1].left) === evalF(r[1].right);\n//     //   function toBool(c) {\n//     //     if (c === 'T') return true;\n//     //     if (c === 'F') return false;\n//     //     return !!(i >> (c.charCodeAt() - 'a'.charCodeAt()) & 1);\n//     //   }\n//     //   function evalF(f) {\n//     //     switch (f.fs.length) {\n//     //       case 0: return toBool(f.val);\n//     //       case 1: return !evalF(f.fs[0]);\n//     //       case 2:\n//     //         switch (f.op) {\n//     //           case '*': return evalF(f.fs[0]) && evalF(f.fs[1]);\n//     //           case '+': return evalF(f.fs[0]) || evalF(f.fs[1]);\n//     //           case '->': return !evalF(f.fs[0]) || evalF(f.fs[1]);\n//     //         }\n//     //     }\n//     //   }\n//     // }\n//     // console.log(isValid ? 'YES' : 'NO');\n//   });\n// })(require('fs').readFileSync('/dev/stdin', 'utf8'));"
  },
  {
    "language": "JavaScript",
    "code": "'use strict';\n\nfunction token(s) {\n  var len = s.length;\n  return function (target, pos) {\n    return target.substr(pos, len) === s ? [true, s, pos + len]\n      : [false, null, pos];\n  }\n}\n\nfunction choice() {\n  var parsers = arguments;\n  return function (target, pos) {\n    for (var i = 0; i < parsers.length; i++) {\n      var parsed = parsers[i](target, pos);\n      if (parsed[0]) return parsed;\n    }\n    return [false, null, pos];\n  };\n}\n\nfunction seq() {\n  var parsers = arguments;\n  return function (target, pos) {\n    var result = [];\n    var nextPos = pos;\n    for (var i = 0; i < parsers.length; i++) {\n      var parsed = parsers[i](target, nextPos);\n      if (!parsed[0]) return [false, null, pos];\n      result.push(parsed[1]);\n      nextPos = parsed[2];\n    }\n    return [true, result, nextPos];\n  };\n}\n\nfunction lazy(f) {\n  var parser;\n  return function (target, position) {\n    if (!parser) parser = f();\n    return parser(target, position);\n  };\n}\n\nfunction fmap(parser, f) {\n  return function (target, pos) {\n    var result = parser(target, pos);\n    return result[0] ? [result[0], f(result[1]), result[2]]\n      : result;\n  };\n}\n\nfunction oneOf(s) {\n  var d = {};\n  for (var i = 0; i < s.length; i++) d[s[i]] = s[i];\n  return function (target, pos) {\n    var c = target.substr(pos, 1);\n    return d[c] ? [true, c, pos + 1] : [false, null, pos];\n  };\n}\n\n(function (stdin) {\n  var formulaP = lazy(function () {\n    var andP = fmap(seq(token('('), formulaP, token('*'), formulaP, token(')')), function (x) {\n      return { op: '*', fs: [x[1], x[3]] };\n    });\n    var orP = fmap(seq(token('('), formulaP, token('+'), formulaP, token(')')), function (x) {\n      return { op: '+', fs: [x[1], x[3]] };\n    });\n    var impP = fmap(seq(token('('), formulaP, token('->'), formulaP, token(')')), function (x) {\n      return { op: '->', fs: [x[1], x[3]] };\n    });\n    var notP = fmap(seq(token('-'), formulaP), function (x) {\n      return { op: '-', fs: [x[1]] };\n    });\n    var valP = fmap(oneOf('abcdefghijkTF'), function (x) { return { val: x, fs: [] }; });\n    return choice(andP, orP, impP, notP, valP);\n  });\n  var equationP = fmap(seq(formulaP, token('='), formulaP), function (x) {\n    return { left: x[0], right: x[2] };\n  });\n\n  stdin.toString().split('\\n').forEach(function (s) {\n    if (s == '#') process.exit(0);\n    var r = equationP(s, 0);\n    var isValid = true;\n    for (var i = 0; i < (1 << 11); i++) {\n      // isValid &= evalF(r[1].left) === evalF(r[1].right);\n      // function toBool(c) {\n      //   if (c === 'T') return true;\n      //   if (c === 'F') return false;\n      //   return !!(i >> (c.charCodeAt() - 'a'.charCodeAt()) & 1);\n      // }\n      // function evalF(f) {\n      //   switch (f.fs.length) {\n      //     case 0: return toBool(f.val);\n      //     case 1: return !evalF(f.fs[0]);\n      //     case 2:\n      //       switch (f.op) {\n      //         case '*': return evalF(f.fs[0]) && evalF(f.fs[1]);\n      //         case '+': return evalF(f.fs[0]) || evalF(f.fs[1]);\n      //         case '->': return !evalF(f.fs[0]) || evalF(f.fs[1]);\n      //       }\n      //   }\n      // }\n    }\n    console.log(isValid ? 'YES' : 'NO');\n  });\n})(require('fs').readFileSync('/dev/stdin', 'utf8'));"
  },
  {
    "language": "JavaScript",
    "code": "'use strict';\n\nfunction token(s) {\n  const len = s.length;\n  return (target, pos) =>\n    target.substr(pos, len) === s ? [true, s, pos + len]\n      : [false, null, pos];\n}\n\nfunction choice() {\n  const parsers = arguments;\n  return (target, pos) => {\n    for (let parser of parsers) {\n      const parsed = parser(target, pos);\n      if (parsed[0]) return parsed;\n    }\n    return [false, null, pos];\n  };\n}\n\nfunction seq() {\n  const parsers = arguments;\n  return (target, pos) => {\n    const result = [];\n    let nextPos = pos;\n    for (let parser of parsers) {\n      const parsed = parser(target, nextPos);\n      if (!parsed[0]) return [false, null, pos];\n      result.push(parsed[1]);\n      nextPos = parsed[2];\n    }\n    return [true, result, nextPos];\n  };\n}\n\nfunction lazy(f) {\n  let parser;\n  return function (target, position) {\n    if (!parser) parser = f();\n    return parser(target, position);\n  };\n}\n\nfunction fmap(parser, f) {\n  return (target, pos) => {\n    const result = parser(target, pos);\n    if (result[0]) {\n      return [result[0], f(result[1]), result[2]];\n    } else {\n      return result;\n    }\n  };\n}\n\nfunction oneOf(s) {\n  let d = {};\n  for (let c of s) d[c] = c;\n  return (target, pos) => {\n    const c = target.substr(pos, 1);\n    return d[c] ? [true, c, pos + 1] : [false, null, pos];\n  };\n}\n\n// (stdin => {\n//   const formulaP = lazy(() => {\n//     const andP = fmap(seq(token('('), formulaP, token('*'), formulaP, token(')')), x => {\n//       return { op: '*', fs: [x[1], x[3]] };\n//     });\n//     const orP = fmap(seq(token('('), formulaP, token('+'), formulaP, token(')')), x => {\n//       return { op: '+', fs: [x[1], x[3]] };\n//     });\n//     const impP = fmap(seq(token('('), formulaP, token('->'), formulaP, token(')')), x => {\n//       return { op: '->', fs: [x[1], x[3]] };\n//     });\n//     const notP = fmap(seq(token('-'), formulaP), x => {\n//       return { op: '-', fs: [x[1]] };\n//     });\n//     const valP = fmap(oneOf('abcdefghijkTF'), x => { return { val: x, fs: [] }; });\n//     return choice(andP, orP, impP, notP, valP);\n//   });\n//   const equationP = fmap(seq(formulaP, token('='), formulaP), x => {\n//     return { left: x[0], right: x[2] };\n//   });\n\n//   stdin.toString().split('\\n').forEach(s => {\n//     if (s == '#') process.exit(0);\n//     // const r = equationP(s, 0);\n//     // let isValid = true;\n//     // for (let i = 0; i < (1 << 11); i++) {\n//     //   isValid &= evalF(r[1].left) === evalF(r[1].right);\n//     //   function toBool(c) {\n//     //     if (c === 'T') return true;\n//     //     if (c === 'F') return false;\n//     //     return !!(i >> (c.charCodeAt() - 'a'.charCodeAt()) & 1);\n//     //   }\n//     //   function evalF(f) {\n//     //     switch (f.fs.length) {\n//     //       case 0: return toBool(f.val);\n//     //       case 1: return !evalF(f.fs[0]);\n//     //       case 2:\n//     //         switch (f.op) {\n//     //           case '*': return evalF(f.fs[0]) && evalF(f.fs[1]);\n//     //           case '+': return evalF(f.fs[0]) || evalF(f.fs[1]);\n//     //           case '->': return !evalF(f.fs[0]) || evalF(f.fs[1]);\n//     //         }\n//     //     }\n//     //   }\n//     // }\n//     // console.log(isValid ? 'YES' : 'NO');\n//   });\n// })(require('fs').readFileSync('/dev/stdin', 'utf8'));"
  },
  {
    "language": "JavaScript",
    "code": "'use strict';\n\nfunction token(s) {\n  var len = s.length;\n  // return (target, pos) =>\n  //   target.substr(pos, len) === s ? [true, s, pos + len]\n  //     : [false, null, pos];\n}\n\n// function choice() {\n//   const parsers = arguments;\n//   return (target, pos) => {\n//     for (let parser of parsers) {\n//       const parsed = parser(target, pos);\n//       if (parsed[0]) return parsed;\n//     }\n//     return [false, null, pos];\n//   };\n// }\n\n// function seq() {\n//   const parsers = arguments;\n//   return (target, pos) => {\n//     const result = [];\n//     let nextPos = pos;\n//     for (let parser of parsers) {\n//       const parsed = parser(target, nextPos);\n//       if (!parsed[0]) return [false, null, pos];\n//       result.push(parsed[1]);\n//       nextPos = parsed[2];\n//     }\n//     return [true, result, nextPos];\n//   };\n// }\n\n// function lazy(f) {\n//   let parser;\n//   return function (target, position) {\n//     if (!parser) parser = f();\n//     return parser(target, position);\n//   };\n// }\n\n// function fmap(parser, f) {\n//   return (target, pos) => {\n//     const result = parser(target, pos);\n//     if (result[0]) {\n//       return [result[0], f(result[1]), result[2]];\n//     } else {\n//       return result;\n//     }\n//   };\n// }\n\n// function oneOf(s) {\n//   let d = {};\n//   for (let c of s) d[c] = c;\n//   return (target, pos) => {\n//     const c = target.substr(pos, 1);\n//     return d[c] ? [true, c, pos + 1] : [false, null, pos];\n//   };\n// }\n\n// (stdin => {\n//   const formulaP = lazy(() => {\n//     const andP = fmap(seq(token('('), formulaP, token('*'), formulaP, token(')')), x => {\n//       return { op: '*', fs: [x[1], x[3]] };\n//     });\n//     const orP = fmap(seq(token('('), formulaP, token('+'), formulaP, token(')')), x => {\n//       return { op: '+', fs: [x[1], x[3]] };\n//     });\n//     const impP = fmap(seq(token('('), formulaP, token('->'), formulaP, token(')')), x => {\n//       return { op: '->', fs: [x[1], x[3]] };\n//     });\n//     const notP = fmap(seq(token('-'), formulaP), x => {\n//       return { op: '-', fs: [x[1]] };\n//     });\n//     const valP = fmap(oneOf('abcdefghijkTF'), x => { return { val: x, fs: [] }; });\n//     return choice(andP, orP, impP, notP, valP);\n//   });\n//   const equationP = fmap(seq(formulaP, token('='), formulaP), x => {\n//     return { left: x[0], right: x[2] };\n//   });\n\n//   stdin.toString().split('\\n').forEach(s => {\n//     if (s == '#') process.exit(0);\n//     // const r = equationP(s, 0);\n//     // let isValid = true;\n//     // for (let i = 0; i < (1 << 11); i++) {\n//     //   isValid &= evalF(r[1].left) === evalF(r[1].right);\n//     //   function toBool(c) {\n//     //     if (c === 'T') return true;\n//     //     if (c === 'F') return false;\n//     //     return !!(i >> (c.charCodeAt() - 'a'.charCodeAt()) & 1);\n//     //   }\n//     //   function evalF(f) {\n//     //     switch (f.fs.length) {\n//     //       case 0: return toBool(f.val);\n//     //       case 1: return !evalF(f.fs[0]);\n//     //       case 2:\n//     //         switch (f.op) {\n//     //           case '*': return evalF(f.fs[0]) && evalF(f.fs[1]);\n//     //           case '+': return evalF(f.fs[0]) || evalF(f.fs[1]);\n//     //           case '->': return !evalF(f.fs[0]) || evalF(f.fs[1]);\n//     //         }\n//     //     }\n//     //   }\n//     // }\n//     // console.log(isValid ? 'YES' : 'NO');\n//   });\n// })(require('fs').readFileSync('/dev/stdin', 'utf8'));"
  },
  {
    "language": "JavaScript",
    "code": "'use strict';\n\nfunction token(s) {\n  var len = s.length;\n  return function (target, pos) {\n    return target.substr(pos, len) === s ? [true, s, pos + len]\n      : [false, null, pos];\n  }\n}\n\nfunction choice() {\n  var parsers = arguments;\n  return function (target, pos) {\n    for (var i = 0; i < parsers.length; i++) {\n      var parsed = parsers[i](target, pos);\n      if (parsed[0]) return parsed;\n    }\n    return [false, null, pos];\n  };\n}\n\nfunction seq() {\n  var parsers = arguments;\n  return function (target, pos) {\n    var result = [];\n    var nextPos = pos;\n    for (var i = 0; i < parsers.length; i++) {\n      var parsed = parsers[i](target, nextPos);\n      if (!parsed[0]) return [false, null, pos];\n      result.push(parsed[1]);\n      nextPos = parsed[2];\n    }\n    return [true, result, nextPos];\n  };\n}\n\nfunction lazy(f) {\n  var parser;\n  return function (target, position) {\n    if (!parser) parser = f();\n    return parser(target, position);\n  };\n}\n\nfunction fmap(parser, f) {\n  return function (target, pos) {\n    var result = parser(target, pos);\n    return result[0] ? [result[0], f(result[1]), result[2]]\n      : result;\n  };\n}\n\nfunction oneOf(s) {\n  var d = {};\n  for (var i = 0; i < s.length; i++) d[s[i]] = s[i];\n  return function (target, pos) {\n    var c = target.substr(pos, 1);\n    return d[c] ? [true, c, pos + 1] : [false, null, pos];\n  };\n}\n\n(function (stdin) {\n  var formulaP = lazy(function () {\n    var andP = fmap(seq(token('('), formulaP, token('*'), formulaP, token(')')), function (x) {\n      return { op: '*', fs: [x[1], x[3]] };\n    });\n    var orP = fmap(seq(token('('), formulaP, token('+'), formulaP, token(')')), function (x) {\n      return { op: '+', fs: [x[1], x[3]] };\n    });\n    var impP = fmap(seq(token('('), formulaP, token('->'), formulaP, token(')')), function (x) {\n      return { op: '->', fs: [x[1], x[3]] };\n    });\n    var notP = fmap(seq(token('-'), formulaP), function (x) {\n      return { op: '-', fs: [x[1]] };\n    });\n    var valP = fmap(oneOf('abcdefghijkTF'), function (x) { return { val: x, fs: [] }; });\n    return choice(andP, orP, impP, notP, valP);\n  });\n  var equationP = fmap(seq(formulaP, token('='), formulaP), function (x) {\n    return { left: x[0], right: x[2] };\n  });\n\n  stdin.toString().split('\\n').forEach(function (s) {\n    if (s == '#') process.exit(0);\n    var r = equationP(s, 0);\n    var isValid = true;\n    for (var i = 0; i < (1 << 11); i++) {\n      // isValid &= evalF(r[1].left) === evalF(r[1].right);\n      var toBool = function (c) {\n        if (c === 'T') return true;\n        if (c === 'F') return false;\n        return !!(i >> (c.charCodeAt() - 'a'.charCodeAt()) & 1);\n      }\n      // function evalF(f) {\n      //   switch (f.fs.length) {\n      //     case 0: return toBool(f.val);\n      //     case 1: return !evalF(f.fs[0]);\n      //     case 2:\n      //       switch (f.op) {\n      //         case '*': return evalF(f.fs[0]) && evalF(f.fs[1]);\n      //         case '+': return evalF(f.fs[0]) || evalF(f.fs[1]);\n      //         case '->': return !evalF(f.fs[0]) || evalF(f.fs[1]);\n      //       }\n      //   }\n      // }\n    }\n    console.log(isValid ? 'YES' : 'NO');\n  });\n})(require('fs').readFileSync('/dev/stdin', 'utf8'));"
  },
  {
    "language": "JavaScript",
    "code": "'use strict';\n\nfunction token(s) {\n  const len = s.length;\n  // return (target, pos) =>\n  //   target.substr(pos, len) === s ? [true, s, pos + len]\n  //     : [false, null, pos];\n}\n\n// function choice() {\n//   const parsers = arguments;\n//   return (target, pos) => {\n//     for (let parser of parsers) {\n//       const parsed = parser(target, pos);\n//       if (parsed[0]) return parsed;\n//     }\n//     return [false, null, pos];\n//   };\n// }\n\n// function seq() {\n//   const parsers = arguments;\n//   return (target, pos) => {\n//     const result = [];\n//     let nextPos = pos;\n//     for (let parser of parsers) {\n//       const parsed = parser(target, nextPos);\n//       if (!parsed[0]) return [false, null, pos];\n//       result.push(parsed[1]);\n//       nextPos = parsed[2];\n//     }\n//     return [true, result, nextPos];\n//   };\n// }\n\n// function lazy(f) {\n//   let parser;\n//   return function (target, position) {\n//     if (!parser) parser = f();\n//     return parser(target, position);\n//   };\n// }\n\n// function fmap(parser, f) {\n//   return (target, pos) => {\n//     const result = parser(target, pos);\n//     if (result[0]) {\n//       return [result[0], f(result[1]), result[2]];\n//     } else {\n//       return result;\n//     }\n//   };\n// }\n\n// function oneOf(s) {\n//   let d = {};\n//   for (let c of s) d[c] = c;\n//   return (target, pos) => {\n//     const c = target.substr(pos, 1);\n//     return d[c] ? [true, c, pos + 1] : [false, null, pos];\n//   };\n// }\n\n// (stdin => {\n//   const formulaP = lazy(() => {\n//     const andP = fmap(seq(token('('), formulaP, token('*'), formulaP, token(')')), x => {\n//       return { op: '*', fs: [x[1], x[3]] };\n//     });\n//     const orP = fmap(seq(token('('), formulaP, token('+'), formulaP, token(')')), x => {\n//       return { op: '+', fs: [x[1], x[3]] };\n//     });\n//     const impP = fmap(seq(token('('), formulaP, token('->'), formulaP, token(')')), x => {\n//       return { op: '->', fs: [x[1], x[3]] };\n//     });\n//     const notP = fmap(seq(token('-'), formulaP), x => {\n//       return { op: '-', fs: [x[1]] };\n//     });\n//     const valP = fmap(oneOf('abcdefghijkTF'), x => { return { val: x, fs: [] }; });\n//     return choice(andP, orP, impP, notP, valP);\n//   });\n//   const equationP = fmap(seq(formulaP, token('='), formulaP), x => {\n//     return { left: x[0], right: x[2] };\n//   });\n\n//   stdin.toString().split('\\n').forEach(s => {\n//     if (s == '#') process.exit(0);\n//     // const r = equationP(s, 0);\n//     // let isValid = true;\n//     // for (let i = 0; i < (1 << 11); i++) {\n//     //   isValid &= evalF(r[1].left) === evalF(r[1].right);\n//     //   function toBool(c) {\n//     //     if (c === 'T') return true;\n//     //     if (c === 'F') return false;\n//     //     return !!(i >> (c.charCodeAt() - 'a'.charCodeAt()) & 1);\n//     //   }\n//     //   function evalF(f) {\n//     //     switch (f.fs.length) {\n//     //       case 0: return toBool(f.val);\n//     //       case 1: return !evalF(f.fs[0]);\n//     //       case 2:\n//     //         switch (f.op) {\n//     //           case '*': return evalF(f.fs[0]) && evalF(f.fs[1]);\n//     //           case '+': return evalF(f.fs[0]) || evalF(f.fs[1]);\n//     //           case '->': return !evalF(f.fs[0]) || evalF(f.fs[1]);\n//     //         }\n//     //     }\n//     //   }\n//     // }\n//     // console.log(isValid ? 'YES' : 'NO');\n//   });\n// })(require('fs').readFileSync('/dev/stdin', 'utf8'));"
  },
  {
    "language": "JavaScript",
    "code": "'use strict';\n\nfunction token(s) {\n  var len = s.length;\n  return function (target, pos) {\n    return target.substr(pos, len) === s ? [true, s, pos + len]\n      : [false, null, pos];\n  }\n}\n\nfunction choice() {\n  var parsers = arguments;\n  return function (target, pos) {\n    for (var i = 0; i < parsers.length; i++) {\n      var parsed = parsers[i](target, pos);\n      if (parsed[0]) return parsed;\n    }\n    return [false, null, pos];\n  };\n}\n\nfunction seq() {\n  var parsers = arguments;\n  return function (target, pos) {\n    var result = [];\n    var nextPos = pos;\n    for (var i = 0; i < parsers.length; i++) {\n      var parsed = parsers[i](target, nextPos);\n      if (!parsed[0]) return [false, null, pos];\n      result.push(parsed[1]);\n      nextPos = parsed[2];\n    }\n    return [true, result, nextPos];\n  };\n}\n\nfunction lazy(f) {\n  var parser;\n  return function (target, position) {\n    if (!parser) parser = f();\n    return parser(target, position);\n  };\n}\n\nfunction fmap(parser, f) {\n  return function (target, pos) {\n    var result = parser(target, pos);\n    return result[0] ? [result[0], f(result[1]), result[2]]\n      : result;\n  };\n}\n\nfunction oneOf(s) {\n  var d = {};\n  for (var i = 0; i < s.length; i++) d[s[i]] = s[i];\n  return function (target, pos) {\n    var c = target.substr(pos, 1);\n    return d[c] ? [true, c, pos + 1] : [false, null, pos];\n  };\n}\n\n(function (stdin) {\n  var formulaP = lazy(function () {\n    var andP = fmap(seq(token('('), formulaP, token('*'), formulaP, token(')')), function (x) {\n      return { op: '*', fs: [x[1], x[3]] };\n    });\n    var orP = fmap(seq(token('('), formulaP, token('+'), formulaP, token(')')), function (x) {\n      return { op: '+', fs: [x[1], x[3]] };\n    });\n    var impP = fmap(seq(token('('), formulaP, token('->'), formulaP, token(')')), function (x) {\n      return { op: '->', fs: [x[1], x[3]] };\n    });\n    var notP = fmap(seq(token('-'), formulaP), function (x) {\n      return { op: '-', fs: [x[1]] };\n    });\n    var valP = fmap(oneOf('abcdefghijkTF'), function (x) { return { val: x, fs: [] }; });\n    return choice(andP, orP, impP, notP, valP);\n  });\n  var equationP = fmap(seq(formulaP, token('='), formulaP), function (x) {\n    return { left: x[0], right: x[2] };\n  });\n\n  // stdin.toString().split('\\n').forEach(function (s) {\n  //   if (s == '#') process.exit(0);\n  //   var r = equationP(s, 0);\n  //   var isValid = true;\n  //   for (var i = 0; i < (1 << 11); i++) {\n  //     isValid &= evalF(r[1].left) === evalF(r[1].right);\n  //     function toBool(c) {\n  //       if (c === 'T') return true;\n  //       if (c === 'F') return false;\n  //       return !!(i >> (c.charCodeAt() - 'a'.charCodeAt()) & 1);\n  //     }\n  //     function evalF(f) {\n  //       switch (f.fs.length) {\n  //         case 0: return toBool(f.val);\n  //         case 1: return !evalF(f.fs[0]);\n  //         case 2:\n  //           switch (f.op) {\n  //             case '*': return evalF(f.fs[0]) && evalF(f.fs[1]);\n  //             case '+': return evalF(f.fs[0]) || evalF(f.fs[1]);\n  //             case '->': return !evalF(f.fs[0]) || evalF(f.fs[1]);\n  //           }\n  //       }\n  //     }\n  //   }\n  //   console.log(isValid ? 'YES' : 'NO');\n  // });\n})(require('fs').readFileSync('/dev/stdin', 'utf8'));"
  },
  {
    "language": "Ruby",
    "code": "T=!!0\nF=!T\n[T,F].map{|c|\nclass<<c\nalias:%:==\ndef!=x\n!self|x\nend\nend\n}\nuntil/#/=~gets\nputs (0..2047).all?{|x|\neval$_.tr\"-=>*+abcdefghijk\",\"!%=&|\"+(\"%011b\"%x).tr(\"01\",\"TF\")\n}?'YES':'NO'\nend"
  },
  {
    "language": "Ruby",
    "code": "T=!!0\nF=!T\n[T,F].map{|c|\nclass<<c\nalias:%:==\ndef!=x\n!self|x\nend\nend\n}\nuntil/#/=~gets\nputs (0..2047).all?{|x|\neval$_.tr\"-=>*+abcdefghijk\",\"!%=&|\"+(\"%011b\"%x).tr(\"01\",\"TF\")\n}?'YES':'NO'\nend"
  },
  {
    "language": "Ruby",
    "code": "T=!p\nF=!T\nclass Object\nalias:%:==\ndef!=x\n!self|x\nend\nend\nuntil/#/=~gets\nputs (0..2047).all?{|x|\neval$_.tr\"-=>*+abcdefghijk\",\"!%=&|\"+(\"%011b\"%x).tr(\"01\",\"TF\")\n}?'YES':'NO'\nend"
  },
  {
    "language": "Ruby",
    "code": "T=!!0\nF=!T\n[T,F].map{|c|\nclass<<c\nalias:%:==\ndef!=x\n!self|x\nend\nend\n}\nuntil(s=gets.tr\"-=>*+\",\"!%=&|\")=~/#/\nputs (0..2047).all?{|x|\neval s.tr'abcdefghijk',(\"%011b\"%x).tr(\"01\",\"TF\")\n}?'YES':'NO'\nend"
  },
  {
    "language": "Ruby",
    "code": "module Boolean\n\tdef -@\n\t\t!self\n\tend\n\n\tdef *(other)\n\t\tself & other\n\tend\t\n\n\tdef +(other)\n\t\tself | other\n\tend\t\n\n\tdef >(other)\n\t\t!self | other\n\tend\t\nend\n\nclass TrueClass; include Boolean; end\nclass FalseClass; include Boolean; end\n\nT = true\nF = false\n\nloop do\n\ts = gets.chomp\n\tbreak if s == ?#\n\tvars = s.scan(/[a-z]/).uniq\n\n\ts.sub!(?=, '==')\n\ts.gsub!('->', '>')\n\n\tputs [?T, ?F].repeated_permutation(vars.size).all?{|assign|\n\t\teval s.tr(vars.join, assign.join)\t\n\t} ? 'YES' : 'NO'\nend"
  },
  {
    "language": "Ruby",
    "code": "T=!!0\nF=!T\n[T,F].map{|c|\nclass<<c\nalias:%:==\ndef!=x\n!self|x\nend\nend\n}\nuntil gets=~/#/\nputs (0..2047).all?{|x|\neval $_.tr\"-=>*+abcdefghijk\",\"!%=&|\"+(\"%011b\"%x).tr(\"01\",\"TF\")\n}?'YES':'NO'\nend"
  },
  {
    "language": "Ruby",
    "code": "class Fixnum\ndef -@\n1-self\nend\nalias:+:|\ndef >(x)\n-self|x\nend \nend\nT=1\nF=0\nuntil(s=gets.sub(?=,'==').gsub('->',?>))<?(\nv=s.scan(/\\w/).uniq\nputs %w(T F).repeated_permutation(v.size).all?{|a|\neval s.tr v*'',a*''\n}?'YES':'NO'\nend"
  },
  {
    "language": "Ruby",
    "code": "class Fixnum\ndef-@\n1-self\nend\nalias:+:|\ndef>x\n-self|x\nend\nend\nT=1\nF=0\nuntil(s=gets.sub(?=,'==').gsub('->',?>))<?(\nv=s.scan(/[a-z]/).uniq\nputs %w(T F).repeated_permutation(v.size).all?{|a|\neval s.tr(v*'',a*'')\n}?'YES':'NO'\nend"
  },
  {
    "language": "Ruby",
    "code": "T=!!0\nF=!T\n[T,F].map{|c|\nclass<<c\nalias:%:==\ndef!=x\n!self|x\nend\nend\n}\nuntil gets<?#\nputs (0..2047).all?{|x|\neval $_.tr\"-=>*+abcdefghijk\",\"!%=&|\"+(\"%011b\"%x).tr(\"01\",\"TF\")\n}?'YES':'NO'\nend"
  },
  {
    "language": "Ruby",
    "code": "T=!0\nF=!T\n[T,F].map{|c|\nclass<<c\nalias:%:==\ndef!=x\n!self|x\nend\nend\n}\nuntil(s=gets.tr\"-=>*+\",\"!%=&|\")=~/#/\nv=s.scan(/[a-z]/).uniq\nputs %w(T F).repeated_permutation(v.size).all?{|a|\neval s.tr v*'',a*''\n}?'YES':'NO'\nend"
  },
  {
    "language": "Ruby",
    "code": "T=!!0\nF=!T\n[T,F].map{|c|\nclass<<c\nalias:%:==\ndef!=x\n!self|x\nend\nend\n}\nuntil(s=gets.tr\"-=>*+\",\"!%=&|\")=~/#/\nv=s.scan(/[a-z]/).uniq\nputs %w(T F).repeated_permutation(v.size).all?{|a|\neval s.tr v*'',a*''\n}?'YES':'NO'\nend"
  },
  {
    "language": "Ruby",
    "code": "T=!p\nF=p\nclass Object\nalias:%:==\ndef!=x\n!self|x\nend\nend\nuntil/#/=~gets\nputs (0..2047).all?{|x|\neval$_.tr\"-=>*+abcdefghijk\",\"!%=&|\"+(\"%011b\"%x).tr(\"01\",\"TF\")\n}?'YES':'NO'\nend"
  },
  {
    "language": "Ruby",
    "code": "T=!!0\nF=!T\n[T,F].map{|c|\nclass<<c\nalias:%:==\ndef!=x\n!self|x\nend\nend\n}\nuntil gets=~/#/\nputs (0..2047).all?{|x|\neval $_.tr(\"-=>*+abcdefghijk\",\"!%=&|\"+(\"%011b\"%x).tr(\"01\",\"TF\"))\n}?'YES':'NO'\nend"
  },
  {
    "language": "Ruby",
    "code": "T=!!0\nF=!T\n[T,F].map{|c|\nclass<<c\nalias:%:==\ndef!=x\n!self|x\nend\nend\n}\nuntil(s=gets.tr\"-=>*+\",\"!%=&|\")=~/#/\nputs %w(T F).repeated_permutation(11).all?{|a|\neval s.tr (?a..?k).to_a*'',a*''\n}?'YES':'NO'\nend"
  },
  {
    "language": "Ruby",
    "code": "$h = Hash.new\ndef parse(s,env)\n    if $h.has_key?(s)\n        return $h[s]\n    end\n    case s[0]\n    when \"T\"\n        return 1\n    when \"F\"\n        return 0\n    when \"a\"\n        return env[0]\n    when \"b\"\n        return env[1]\n    when \"c\"\n        return env[2]\n    when \"d\"\n        return env[3]\n    when \"e\"\n        return env[4]\n    when \"f\"\n        return env[5]\n    when \"g\"\n        return env[6]\n    when \"h\"\n        return env[7]\n    when \"i\"\n        return env[8]\n    when \"j\"\n        return env[9]\n    when \"k\"\n        return env[10]\n    when \"-\"\n        ret = 1 - parse(s[1...s.length],env)\n        $h[s] = ret\n        return ret\n    when \"(\"\n        index = 1\n        level = 0\n        while index < s.length\n            if s[index] == \"(\"\n                level += 1\n            elsif s[index] == \")\"\n                level -= 1\n            elsif s[index] == \"*\" && level == 0\n                a = parse(s[1...index],env)\n                b = parse(s[(index+1)...s.length],env)\n                if a == 0 || b == 0\n                    $h[s] = 0\n                    return 0\n                else\n                    $h[s] = 1\n                    return 1\n                end\n            elsif s[index] == \"+\" && level == 0\n                a = parse(s[1...index],env)\n                b = parse(s[(index+1)...s.length],env)\n                if a == 0 && b == 0\n                    $h[s] = 0\n                    return 0\n                else\n                    $h[s] = 1\n                    return 1\n                end\n            elsif s[index] == \"-\" && s[index+1] == \">\" && level == 0\n                a = parse(s[1...index],env)\n                b = parse(s[(index+2)...s.length],env)\n                if a == 1 && b == 0\n                    $h[s] = 0\n                    return 0\n                else\n                    $h[s] = 1\n                    return 1\n                end\n            end\n            index += 1\n        end\n        return -1\n    end\nend\nloop do\n    s = gets.chomp.gsub(\"--\",\"\")\n    break if s == \"\\#\"\n    count = 0\n    [0,1].repeated_permutation(11).each do |env|\n        $h = Hash.new\n        a, b = s.split(\"=\")\n        count += 1 if parse(a,env) == parse(b,env)\n    end\n    puts count == 2**11 ? \"YES\" : \"NO\"\nend"
  },
  {
    "language": "Ruby",
    "code": "def parse(s,env)\n    case s[0]\n    when \"T\"\n        return 1\n    when \"F\"\n        return 0\n    when \"a\"\n        return env[0]\n    when \"b\"\n        return env[1]\n    when \"c\"\n        return env[2]\n    when \"d\"\n        return env[3]\n    when \"e\"\n        return env[4]\n    when \"f\"\n        return env[5]\n    when \"g\"\n        return env[6]\n    when \"h\"\n        return env[7]\n    when \"i\"\n        return env[8]\n    when \"j\"\n        return env[9]\n    when \"k\"\n        return env[10]\n    when \"-\"\n        return 1 - parse(s[1...s.length],env)\n    when \"(\"\n        index = 1\n        level = 0\n        while index < s.length\n            if s[index] == \"(\"\n                level += 1\n            elsif s[index] == \")\"\n                level -= 1\n            elsif s[index] == \"*\" && level == 0\n                a = parse(s[1...index],env)\n                b = parse(s[(index+1)...s.length],env)\n                return 0 if a == 0 || b == 0\n                return 1\n            elsif s[index] == \"+\" && level == 0\n                a = parse(s[1...index],env)\n                b = parse(s[(index+1)...s.length],env)\n                return 0 if a == 0 && b == 0\n                return 1\n            elsif s[index] == \"-\" && s[index+1] == \">\" && level == 0\n                a = parse(s[1...index],env)\n                b = parse(s[(index+2)...s.length],env)\n                return 0 if a == 1 && b == 0\n                return 1\n            end\n            index += 1\n        end\n        return -1\n    end\nend\nloop do\n    s = gets.chomp\n    break if s == \"\\#\"\n    count = 0\n    [0,1].repeated_permutation(11).each do |env|\n        a, b = s.split(\"=\")\n        count += 1 if parse(a,env) == parse(b,env)\n    end\n    puts count == 2**11 ? \"YES\" : \"NO\"\nend"
  },
  {
    "language": "Ruby",
    "code": "module Boolean\n\tdef -@\n\t\t!self\n\tend\n\n\tdef *(other)\n\t\tself & other\n\tend\t\n\n\tdef +(other)\n\t\tself | other\n\tend\t\n\n\tdef >(other)\n\t\t!self | other\n\tend\t\nend\n\nclass TrueClass; include Boolean; end\nclass FalseClass; include Boolean; end\n\nT = true\nF = false\n\nloop do\n\ts = gets.chomp\n\tbreak if s == ?#\n\tvars = s.scan(/[a-z]/).uniq\n\n\ts.sub!(?=, '==')\n\ts.sub!('->', '>')\n\n\tputs [?T, ?F].repeated_permutation(vars.size).all?{|assign|\n\t\teval s.tr(vars.join, assign.join)\t\n\t} ? 'YES' : 'NO'\nend"
  },
  {
    "language": "PHP",
    "code": "<?php\n\nfunction check($S){\n        if ($S=='T') {\n                return 'T';\n        } else if($S == 'F') {\n                return 'F';\n        }\n        for ($i=0; $i < strlen($S); $i++) {\n                if ($S[$i]=='(') {\n                        $count=0;\n                        for ($j=$i; $j<strlen($S); $j++) {\n                                if ($S[$j]==')') {\n                                        $count--;\n                                        if ($count==0) {\n                                                $S=substr($S,0,$i).check(substr($S,$i+1,$j-$i-1)).substr($S,$j+1);\n                                        }\n                                        break;\n                                } else if($S[$j]=='('){\n                                        $count++;\n                                }\n                        }\n                }\n        }\n        $Sprev='0';\n        while ($Sprev!==$S) {\n                $Sprev=$S;\n                $S=str_replace(['-T','-F'],['F','T'],$S);\n        }\n        $Sprev='0';\n        while ($Sprev!==$S) {\n                $Sprev=$S;\n                $S=str_replace(['T*T','T*F','F*T','F*F'],['T','F','F','F'],$S);\n        }\n        $Sprev='0';\n        while ($Sprev!==$S) {\n                $Sprev=$S;\n                $S=str_replace(['T+T','T+F','F+T','F+F'],['T','T','T','F'],$S);\n        }\n        $S=str_replace(['T->T','T->F','F->T','F->F'],['T','F','T','T'],$S);\n        $Sprev='0';\n        while ($Sprev!==$S) {\n                $Sprev=$S;\n        }\n        return $S;\n}\n\nwhile(1){\n        $S=trim(fgets(STDIN));\n        if ($S==='#') {\n                break;\n        }\n        $C=[];\n        for ($i=0; $i < strlen($S); $i++) {\n                @$C[$S[$i]]++;\n        }\n        $d=[];\n        foreach ($C as $x => $y) {\n                if ('a' <= $x && $x<='k') {\n                        @               $d[$x]++;\n                }\n        }\n        $e=[];\n        $index=0;\n        foreach ($d as $k => $v) {\n                $e[$index++]=$k;\n        }\n\n        $memo=sizeof($e);\n        $flag=true;\n        for ($i=0; $i < (1<<$memo); $i++) {\n                $j=$i;\n                $index=0;\n                $replace=[];\n                for ($k=0; $k < $memo; $k++) {\n                        $replace[$index++]=(($j%2==1)?'T':'F');\n                        $j>>=1;\n                }\n                $Scopy=$S;\n                $Sreplace=str_replace($e,$replace,$Scopy);\n                list($left,$right)=explode('=',$Sreplace);\n                if (check($left)!==check($right)) {\n                        $flag=false;\n                        break;\n                }\n        }\n        if ($flag) {\n                echo 'YES'.PHP_EOL;\n        }else{\n                echo 'NO'.PHP_EOL;\n        }\n}"
  },
  {
    "language": "PHP",
    "code": "<?php\n\nfunction check($S){\n        if ($S=='T') {\n                return 'T';\n        } else if($S == 'F') {\n                return 'F';\n        }\n        for ($i=0; $i < strlen($S); $i++) {\n                if ($S[$i]=='(') {\n                        $count=0;\n                        for ($j=$i; $j<strlen($S); $j++) {\n                                if ($S[$j]==')') {\n                                        $count--;\n                                        if ($count==0) {\n                                                $S=substr($S,0,$i).check(substr($S,$i+1,$j-$i-1)).substr($S,$j+1);\n                                        }\n                                        break;\n                                } else if($S[$j]=='('){\n                                        $count++;\n                                }\n                        }\n                }\n        }\n        $S=str_replace(['-T','-F'],['F','T'],$S);\n        $S=str_replace(['T*T','T*F','F*T','F*F'],['T','F','F','F'],$S);\n        $S=str_replace(['T+T','T+F','F+T','F+F'],['T','T','T','F'],$S);\n        $S=str_replace(['T->T','T->F','F->T','F->F'],['T','F','T','T'],$S);\n        return $S;\n}\n\nwhile(1){\n        $S=trim(fgets(STDIN));\n        if ($S==='#') {\n                break;\n        }\n        $C=[];\n        for ($i=0; $i < strlen($S); $i++) {\n                $C[$S[$i]]++;\n        }\n        $d=[];\n        foreach ($C as $x => $y) {\n                if ('a' <= $x && $x<='k') {\n                        $d[$x]++;\n                }\n        }\n        $e=[];\n        $index=0;\n        foreach ($d as $k => $v) {\n                $e[$index++]=$k;\n        }\n\n        $memo=sizeof($e);\n        $flag=true;\n        for ($i=0; $i < (1<<$memo); $i++) {\n                $j=$i;\n                $index=0;\n                $replace=[];\n                for ($k=0; $k < $memo; $k++) {\n                        $replace[$index++]=(($j%2==1)?'T':'F');\n                        $j>>=1;\n                }\n                $Scopy=$S;\n                $Sreplace=str_replace($e,$replace,$Scopy);\n                list($left,$right)=explode('=',$Sreplace);\n                if (check($left)!==check($right)) {\n                        $flag=false;\n                        break;\n                }\n        }\n        if ($flag) {\n                echo 'YES'.PHP_EOL;\n        }else{\n                echo 'NO'.PHP_EOL;\n        }\n}"
  },
  {
    "language": "PHP",
    "code": "<?php\n\nfunction check($S){\n        if ($S=='T') {\n                return 'T';\n        } else if($S == 'F') {\n                return 'F';\n        }\n        for ($i=0; $i < strlen($S); $i++) {\n                if ($S[$i]==='(') {\n                        $count=1;\n                        for ($j=$i+1; $j<strlen($S); $j++) {\n                                if ($S[$j]===')') {\n                                        $count--;\n                                        if ($count==0) {\n                                                $S=substr($S,0,$i).check(substr($S,$i+1,$j-$i-1)).substr($S,$j+1);\n                                                $i=0;\n                                                break;\n                                        }\n                                } else if($S[$j]==='('){\n                                        $count++;\n                                }\n                        }\n                }\n        }\n        $Sprev='0';\n        while ($Sprev!==$S) {\n                $Sprev=$S;\n                $S=str_replace(['-T','-F'],['F','T'],$S);\n        }\n        $Sprev='0';\n        while ($Sprev!==$S) {\n                $Sprev=$S;\n                $S=str_replace(['T*T','T*F','F*T','F*F'],['T','F','F','F'],$S);\n        }\n        $Sprev='0';\n        while ($Sprev!==$S) {\n                $Sprev=$S;\n                $S=str_replace(['T+T','T+F','F+T','F+F'],['T','T','T','F'],$S);\n        }\n        $S=str_replace(['T->T','T->F','F->T','F->F'],['T','F','T','T'],$S);\n        $Sprev='0';\n        while ($Sprev!==$S) {\n                $Sprev=$S;\n        }\n        return $S;\n}\n\nwhile(1){\n        $S=trim(fgets(STDIN));\n        if ($S==='#') {\n                break;\n        }\n        $C=[];\n        for ($i=0; $i < strlen($S); $i++) {\n                @$C[$S[$i]]++;\n        }\n        $d=[];\n        foreach ($C as $x => $y) {\n                if ('a' <= $x && $x<='k') {\n                        @               $d[$x]++;\n                }\n        }\n        $e=[];\n        $index=0;\n        foreach ($d as $k => $v) {\n                $e[$index++]=$k;\n        }\n\n        $memo=sizeof($e);\n        $flag=true;\n        for ($i=0; $i < (1<<$memo); $i++) {\n                $j=$i;\n                $index=0;\n                $replace=[];\n                for ($k=0; $k < $memo; $k++) {\n                        $replace[$index++]=(($j%2==1)?'T':'F');\n                        $j>>=1;\n                }\n                $Scopy=$S;\n                $Sreplace=str_replace($e,$replace,$Scopy);\n                list($left,$right)=explode('=',$Sreplace);\n                if (check($left)!==check($right)) {\n                        $flag=false;\n                        break;\n                }\n        }\n        if ($flag) {\n                echo 'YES'.PHP_EOL;\n        }else{\n                echo 'NO'.PHP_EOL;\n        }\n}"
  },
  {
    "language": "D",
    "code": "import std.stdio;\nimport std.range;\nimport std.array;\nimport std.functional;\nimport std.algorithm;\nimport std.conv;\nimport std.container;\nimport std.math;\nimport std.numeric;\nimport std.string;\n\nbool[11] vars;\nstring input;\n\nbool check() {\n    string[] eq = input.split(\"=\");\n    bool val(string s) {\n        int index = 0;\n        bool parse() {\n            if (s[index] == 'T') {\n                index++;\n                return true;\n            }\n            if (s[index] == 'F') {\n                index++;\n                return false;\n            }\n            if ('a' <= s[index] && s[index] <= 'k') {\n                bool x = vars[s[index] - 'a'];\n                index++;\n                return x;\n            }\n            if (s[index] == '-') {\n                index++;\n                return (!parse);\n            }\n            if (s[index] == '(') {\n                index++;\n                bool x = parse;\n                if (s[index] == '*') {\n                    index++;\n                    bool y = parse;\n                    assert(s[index] == ')');\n                    index++;\n                    return (x & y);\n                } else if (s[index] == '+') {\n                    index++;\n                    bool y = parse;\n                    assert(s[index] == ')');\n                    index++;\n                    return (x | y);\n                } else { // \n                    assert(s[index] == '-' && s[index+1] == '>');\n                    index += 2;\n                    bool y = parse;\n                    assert(s[index] == ')');\n                    index++;\n                    return (y | (!x));\n                }\n            }\n            assert(0);\n        }\n        return parse;\n    }\n    return val(eq[0]) == val(eq[1]);\n}\n\nvoid main() {\n    while (true) {\n        input = readln.chomp;\n        if (input == \"#\") break;\n        for (int i = 0; i < (1 << 11); i++) {\n            for (int j = 0; j < 11; j++) {\n                vars[j] = (i & (1 << j)) ? true : false;\n            }\n        }\n        (check ? \"YES\" : \"NO\").writeln;\n    }\n}"
  },
  {
    "language": "D",
    "code": "import std.stdio;\nimport std.range;\nimport std.array;\nimport std.functional;\nimport std.algorithm;\nimport std.conv;\nimport std.container;\nimport std.math;\nimport std.numeric;\nimport std.string;\n\nbool[11] vars;\nstring input;\n\nbool check() {\n    string[] eq = input.split(\"=\");\n    bool val(string s) {\n        int index = 0;\n        bool parse() {\n            if (s[index] == 'T') {\n                index++;\n                return true;\n            }\n            if (s[index] == 'F') {\n                index++;\n                return false;\n            }\n            if ('a' <= s[index] && s[index] <= 'k') {\n                bool x = vars[s[index] - 'a'];\n                index++;\n                return x;\n            }\n            if (s[index] == '-') {\n                index++;\n                return (!parse);\n            }\n            if (s[index] == '(') {\n                index++;\n                bool x = parse;\n                if (s[index] == '*') {\n                    index++;\n                    bool y = parse;\n                    assert(s[index] == ')');\n                    index++;\n                    return (x & y);\n                } else if (s[index] == '+') {\n                    index++;\n                    bool y = parse;\n                    assert(s[index] == ')');\n                    index++;\n                    return (x | y);\n                } else { // \n                    assert(s[index] == '-' && s[index+1] == '>');\n                    index += 2;\n                    bool y = parse;\n                    assert(s[index] == ')');\n                    index++;\n                    return (y | (!x));\n                }\n            }\n            assert(0);\n        }\n        return parse;\n    }\n    return val(eq[0]) == val(eq[1]);\n}\n\nvoid main() {\ntest: while (true) {\n        input = readln.chomp;\n        if (input == \"#\") break;\n        for (int i = 0; i < (1 << 11); i++) {\n            for (int j = 0; j < 11; j++) {\n                vars[j] = (i & (1 << j)) ? true : false;\n            }\n            if (!check) {\n                \"NO\".writeln;\n                continue test;\n            }\n        }\n        \"YES\".writeln;\n    }\n}"
  },
  {
    "language": "Python",
    "code": "# -*- coding: utf-8 -*-\nfrom itertools import product\n\"\"\"\n-> は @と表記する\n\"\"\"\n\ndef parse(S):\n    \"\"\"\n    構文木を返す\n    Sは普通の記法の式\n    opは優先順序　通常は(*/: 1, +-: 2)\n    \"\"\"\n    S = \"{}\".format(S)\n    V = []\n    op = {\"-\": 1,\n          \"+\": 2,\n          \"*\": 2,\n          \"@\": 2}\n    variables = list(\"abcdefghijk\")\n\n    for x in list(\"()+-*@\"):\n        S = S.replace(x, \" {} \".format(x))\n    i = 0\n    rank = 0\n    O = []\n    for s in S.split():\n        if s == \"(\":\n            rank += 1\n        elif s == \")\":\n            rank -= 1\n        elif s in variables + [\"T\", \"F\"]:\n            V.append(s)\n            i += 1\n        else:\n            V.append(s)\n            O.append([-rank, op[s], i])\n            i += 1\n \n    G = [[] for _ in range(len(V))]\n    P = [-1]*len(V)\n    O = sorted(O)\n     \n    def get_pair(i):\n        while P[i] != -1:\n            i = P[i]\n        return i\n    \n    if len(O):\n        for _, _, i in O:\n            if V[i] == \"-\": # 単項演算子\n                r = get_pair(i+1)\n                G[i].append(r)\n                P[r] = i\n            else: # 二項演算子\n                l, r = get_pair(i-1), get_pair(i+1)\n                G[i].extend([l, r])\n                P[l], P[r] = i, i\n        p = P.index(-1)\n    else:\n        assert len(V) == 1\n        p = 0\n    return G, V, p\n \n\ndef calculate(G, V, p, X):\n    variables = set(list(\"abcdefghijk\"))\n    def call(i):\n        if V[i] in variables:\n            return X[V[i]]\n        elif V[i] == \"T\":\n            return True\n        elif V[i] == \"F\":\n            return False\n        elif V[i] == \"-\":\n            return not call(G[i][0])\n        elif V[i] == \"@\":\n            x = call(G[i][0])\n            y = call(G[i][1])\n            return not (x==True and y==False)\n        elif V[i] == \"*\":\n            x = call(G[i][0])\n            y = call(G[i][1])\n            return x & y\n        elif V[i] == \"+\":\n            x = call(G[i][0])\n            y = call(G[i][1])\n            return x | y\n        else:\n            raise\n    return call(p)\n\n\nS = input()\nwhile S != \"#\":\n    L, R = S.replace(\"->\", \"@\").split(\"=\")\n    abc = list(\"abcdefghijk\")\n    for Y in product([True, False], repeat=11):\n        X = dict()\n        for i in range(11):\n            X[abc[i]] = Y[i]\n        G, V, p = parse(L)\n        l = calculate(G, V, p, X)\n        G, V, p = parse(R)\n        r = calculate(G, V, p, X)\n        if l != r:\n            print(\"NO\")\n            break\n    else:\n        print(\"YES\")\n    S = input()\n\n"
  },
  {
    "language": "Python",
    "code": "# -*- coding: utf-8 -*-\nfrom itertools import product\n\"\"\"\n-> は @と表記する\n\"\"\"\n\ndef parse(S):\n    \"\"\"\n    構文木を返す\n    Sは普通の記法の式\n    opは優先順序　通常は(*/: 1, +-: 2)\n    \"\"\"\n    S = \"{}\".format(S)\n    V = []\n    op = {\"-\": 1,\n          \"+\": 2,\n          \"*\": 2,\n          \"@\": 2}\n    variables = list(\"abcdefghijk\")\n\n    for x in list(\"()+-*@\"):\n        S = S.replace(x, \" {} \".format(x))\n    i = 0\n    rank = 0\n    O = []\n    for s in S.split():\n        if s == \"(\":\n            rank += 1\n        elif s == \")\":\n            rank -= 1\n        elif s in variables + [\"T\", \"F\"]:\n            V.append(s)\n            i += 1\n        else:\n            V.append(s)\n            O.append([-rank, op[s], i])\n            i += 1\n \n    G = [[] for _ in range(len(V))]\n    P = [-1]*len(V)\n    O = sorted(O)\n     \n    def get_pair(i):\n        while P[i] != -1:\n            i = P[i]\n        return i\n    \n    if len(O):\n        for _, _, i in O:\n            if V[i] == \"-\": # 単項演算子\n                r = get_pair(i+1)\n                G[i].append(r)\n                P[r] = i\n            else: # 二項演算子\n                l, r = get_pair(i-1), get_pair(i+1)\n                G[i].extend([l, r])\n                P[l], P[r] = i, i\n        p = O[-1][2]\n    else:\n        assert len(V) == 1\n        p = 0\n    return G, V, p\n \n\ndef calculate(G, V, p, X):\n    variables = set(list(\"abcdefghijk\"))\n    def call(i):\n        if V[i] in variables:\n            return X[V[i]]\n        elif V[i] == \"T\":\n            return True\n        elif V[i] == \"F\":\n            return False\n        elif V[i] == \"-\":\n            return not call(G[i][0])\n        elif V[i] == \"@\":\n            x = call(G[i][0])\n            y = call(G[i][1])\n            return not (x==True and y==False)\n        elif V[i] == \"*\":\n            x = call(G[i][0])\n            y = call(G[i][1])\n            return x & y\n        elif V[i] == \"+\":\n            x = call(G[i][0])\n            y = call(G[i][1])\n            return x | y\n        else:\n            raise\n    return call(p)\n\n\nS = input()\nwhile S != \"#\":\n    L, R = S.replace(\"->\", \"@\").split(\"=\")\n    abc = list(\"abcdefghijk\")\n    for Y in product([True, False], repeat=11):\n        X = dict()\n        for i in range(11):\n            X[abc[i]] = Y[i]\n        G, V, p = parse(L)\n        l = calculate(G, V, p, X)\n        G, V, p = parse(R)\n        r = calculate(G, V, p, X)\n        if l != r:\n            print(\"N0\")\n            break\n    else:\n        print(\"YES\")\n    S = input()\n\n"
  },
  {
    "language": "Python",
    "code": "# -*- coding: utf-8 -*-\nfrom itertools import product\n\"\"\"\n-> は @と表記する\n\"\"\"\n\nvariables = set(list(\"abcdefghijk\"))\n\ndef formula(S, X, i):\n    if S[i] == \"T\":\n        return 1, i+1\n    elif S[i] == \"F\":\n        return 0, i+1\n    elif S[i] in variables:\n        return X[S[i]], i+1\n    elif S[i] == \"-\":\n        i += 1\n        that, i = formula(S, X, i)\n        return (not that), i\n    else:\n        i += 1\n        this, i = formula(S, X, i)\n        op = S[i]\n        i += 1\n        that, i = formula(S, X, i)\n        i += 1\n\n\n        if op == \"*\":\n            return this&that, i\n        elif op == \"+\":\n            return this|that, i\n        elif op ==  \"@\":\n            return (not this)|that, i\n        else:\n            raise\n\nS = input()\nT, F = 1, 0\nwhile S != \"#\":\n    S = S.replace(\"->\", \"@\")\n    while \"--\" in S:\n        S = S.replace(\"--\", \"\")\n    L, R = S.split(\"=\")\n    for v in range(2**11):\n        X = {}\n        for a, x in zip(list(\"abcdefghijk\"), format(v, \"b\").zfill(11)):\n            X[a] = int(x)\n        l, _ = formula(L, X, 0)\n        r, _ = formula(R, X, 0)\n        if int(l) != int(r):\n            print(\"NO\")\n            break\n    else:\n        print(\"YES\")\n    S = input()\n\n"
  },
  {
    "language": "Python",
    "code": "import itertools as it\nT,F = True,False\n\nwhile 1:\n    s = raw_input()\n    if s == \"#\": break\n    for b,a in zip([\"=\",\"->\",\"*\",\"+\",\"-\"],[\" == \",\" <= \",\" and \",\" or \",\" not \"]):\n        s = s.replace(b,a)\n    \n    for v in xrange(2**11):\n        a,b,c,d,e,f,g,h,i,j,k = map(int,list(format(v,\"b\").zfill(11)))\n        if not eval(s):\n            print \"NO\"\n            break\n    else:\n        print \"YES\""
  },
  {
    "language": "Python",
    "code": "#!/usr/bin/env python\n#-*- coding:utf-8 -*-\nimport sys\nsys.setrecursionlimit(10000)\n\nclass TerminalNode(object):\n\tdef __init__(self, value):\n\t\tself.index = int(value)\n\t\tself.value = value\n\tdef __call__(self, assign):\n\t\treturn self.value\n\tdef printTree(self, visited=set(),  indent=0):\n\t\tprint \"\\t\" * indent, self\n\tdef _getNextThen(self, index):\n\t\treturn self\n\tdef _getNextElse(self, index):\n\t\treturn self\n\tdef ITE(self, thenNode, elseNode):\n\t\tif self.value:\n\t\t\treturn thenNode\n\t\telse:\n\t\t\treturn elseNode\n\tdef __eq__(self, other):\n\t\treturn isinstance(other, TerminalNode) and self.value == other.value\n\tdef __neq__(self, other):\n\t\treturn not self.__eq__(other)\n\tdef __repr__(self):\n\t\treturn \"<TerminalNode: %s>\" % self.value\n\nclass DiagramNode(object):\n\tdef __init__(self, label, bdd, thenNode, elseNode):\n\t\tself.index = bdd.variable_counter\n\t\tbdd.variable_counter += 1\n\t\tself.label = label\n\t\tself.thenNode = thenNode\n\t\tself.elseNode = elseNode\n\t\tself.bdd = bdd\n\tdef __call__(self, assign):\n\t\tif assign[self.label]:\n\t\t\treturn self.thenNode(assign)\n\t\telse:\n\t\t\treturn self.elseNode(assign)\n\tdef printTree(self, visited=set(),  indent=0):\n\t\tprint \"\\t\" * indent, self\n#\t\tif self.index not in visited:\n#\t\t\tvisited.add(self.index)\n\t\tself.thenNode.printTree(visited, indent + 1)\n\t\tself.elseNode.printTree(visited, indent + 1)\n\tdef _getNextThen(self, label):\n\t\tif label == self.label:\n\t\t\treturn self.thenNode\n\t\treturn self\n\tdef _getNextElse(self, label):\n\t\tif label == self.label:\n\t\t\treturn self.elseNode\n\t\treturn self\n\tdef ITE(self, thenNode, elseNode):\n\t\t# 計算済みなら計算したサブグラフを返す\n\t\tcompute_key = (self.label, thenNode.index, elseNode.index)\n\t\tif compute_key in self.bdd.compute_table:\n\t\t\treturn self.bdd.compute_table[compute_key]\n\t\t# 最も計算順序の早い変数\n\t\tv = max([x for x in [self, thenNode, elseNode] if isinstance(x, DiagramNode)],\n\t\t\t\tkey=lambda x: x.label)\n\t\t# 1枝側のサブグラフ\n\t\tT = self._getNextThen(v.label).ITE(thenNode._getNextThen(v.label),\n\t\t\t\t\t\t\t\t\t\t   elseNode._getNextThen(v.label))\n\t\t# 0枝側のサブグラフ\n\t\tE = self._getNextElse(v.label).ITE(thenNode._getNextElse(v.label),\n\t\t\t\t\t\t\t\t\t\t   elseNode._getNextElse(v.label))\n\t\tif T == E: return T\n\t\tunique_key = (v.label, T.index, E.index)\n\t\tif unique_key in self.bdd.unique_table:\n\t\t\tR = self.bdd.unique_table[unique_key]\n\t\telse:\n\t\t\tR = DiagramNode(v.label, self.bdd, T, E)\n\t\t\tself.bdd.unique_table[unique_key] = R\n\t\tself.bdd.compute_table[compute_key] = R\n\t\treturn R\n\tdef noneGC(self, visited):\n\t\tvisited.add(self.index)\n\t\tfor v in (self.thenNode, self.elseNode):\n\t\t\tif isinstance(v, DiagramNode) and v.index not in visited:\n\t\t\t\tv.noneGC(visited)\n\tdef __eq__(self, other):\n\t\treturn isinstance(other, DiagramNode) and\\\n\t\t\tself.label == other.label and\\\n\t\t\tself.thenNode is other.thenNode and\\\n\t\t\tself.elseNode is other.elseNode\n\tdef __neq__(self, other):\n\t\treturn not self.__eq__(other)\n\tdef __repr__(self):\n\t\treturn \"<DiagramNode: %s(%d)>\" % (self.label, self.index)\n\nclass BinaryDecisionDiagram(object):\n\ttermTrue = TerminalNode(True)\n\ttermFalse = TerminalNode(False)\n\tdef __init__(self):\n\t\tself.unique_table = {}\n\t\tself.variable_counter = 2\n\t\tself.last = None\n\tdef newVariable(self, label):\n\t\tunique_key = (label, 1, 0)\n\t\tif unique_key in self.unique_table:\n\t\t\tself.last = self.unique_table[unique_key]\n\t\t\treturn self.last\n\t\tself.last = DiagramNode(label, self, self.termTrue, self.termFalse)\n\t\tself.unique_table[unique_key] = self.last\n\t\treturn self.last\n\tdef apply_not(self, a):\n\t\tself.compute_table = {}\n\t\tres = a.ITE(self.termFalse, self.termTrue)\n\t\tself.last = res\n\t\treturn res\n\tdef apply_and(self, a, b):\n\t\tself.compute_table = {}\n\t\tres = a.ITE(b, self.termFalse)\n\t\tself.last = res\n\t\treturn res\n\tdef apply_nand(self, a, b):\n\t\tself.compute_table = {}\n\t\tres = a.ITE(self.apply_not(b), self.termTrue)\n\t\tself.last = res\n\t\treturn res\n\tdef apply_or(self, a, b):\n\t\tself.compute_table = {}\n\t\tres = a.ITE(self.termTrue, b)\n\t\tself.last = res\n\t\treturn res\n\tdef apply_nor(self, a, b):\n\t\tself.compute_table = {}\n\t\tres = a.ITE(self.termFalse, self.apply_not(b))\n\t\tself.last = res\n\t\treturn res\n\tdef apply_xor(self, a, b):\n\t\tself.compute_table = {}\n\t\tres = a.ITE(self.apply_not(b), b)\n\t\tself.last = res\n\t\treturn res\n\tdef apply_xnor(self, a, b):\n\t\tself.compute_table = {}\n\t\tres = a.ITE(b, self.apply_not(b))\n\t\tself.last = res\n\t\treturn res\n\tdef gc(self, active=[]):\n\t\tif self.last is not None:\n\t\t\tvisited = set()\n\t\t\tfor v in [self.last] + active:\n\t\t\t\tv.noneGC(visited)\n\t\t\tfor key, value in self.unique_table.items():\n\t\t\t\tif value.index not in visited:\n\t\t\t\t\tdel self.unique_table[key]\n\tdef apply_imp(self, a, b):\n\t\tself.compute_table = {}\n\t\tres = a.ITE(b, self.termTrue)\n\t\tself.last = res\n\t\treturn res\nclass Parser(object):\n\tdef __init__(self, bdd):\n\t\tself.bdd = bdd\n\tdef parse(self, expr):\n\t\tself.expr = expr\n\t\tself.index = 0\n\t\treturn self.formula()\n\tdef formula(self):\n\t\tif self.expr[self.index] == 'T':\n\t\t\tself.index += 1\n\t\t\treturn self.bdd.termTrue\n\t\tif self.expr[self.index] == 'F':\n\t\t\tself.index += 1\n\t\t\treturn self.bdd.termFalse\n\t\tif self.expr[self.index].isalpha():\n\t\t\tc = self.expr[self.index]\n\t\t\tself.index += 1\n\t\t\treturn self.bdd.newVariable(c)\n\t\tif self.expr[self.index] == \"-\":\n\t\t\tself.index += 1\n\t\t\treturn self.bdd.apply_not(self.formula())\n\t\tif self.expr[self.index] == \"(\":\n\t\t\tself.index += 1\n\t\t\tf = self.formula()\n\t\t\top = self.expr[self.index]\n\t\t\tif op == \"*\":\n\t\t\t\tself.index += 1\n\t\t\t\tf = self.bdd.apply_and(f, self.formula())\n\t\t\t\tself.index += 1\n\t\t\t\treturn f\n\t\t\tif op == \"+\":\n\t\t\t\tself.index += 1\n\t\t\t\tf = self.bdd.apply_or(f, self.formula())\n\t\t\t\tself.index += 1\n\t\t\t\treturn f\n\t\t\tif op == \"-\":\n\t\t\t\tself.index += 2\n\t\t\t\tf = self.bdd.apply_imp(f, self.formula())\n\t\t\t\tself.index += 1\n\t\t\t\treturn f\nwhile True:\n\tline = raw_input()\n\tif line == \"#\": break\n\tbdd = BinaryDecisionDiagram()\n\tparser = Parser(bdd)\n\ta, b = line.split(\"=\")\n\ta = parser.parse(a + \";\")\n\tb = parser.parse(b + \";\")\n\tif a == b:\n\t\tprint \"YES\"\n\telse:\n\t\tprint \"NO\""
  },
  {
    "language": "Python",
    "code": "m=24*60*60\nwhile True:\n\tn=int(input())\n\tif n==0:break\n\tdp=[0]*(m+1)\n\tfor _ in range(n):\n\t\ta,d=input().split()\n\t\ta,b,c=map(int,a.split(':'));\n\t\td,e,f=map(int,d.split(':'));\n\t\tdp[a*3600+b*60+c]+=1\n\t\tdp[d*3600+e*60+f]-=1\n\tfor i in range(m):\n\t\tdp[i+1]+=dp[i]\n\tprint(max(dp))"
  },
  {
    "language": "Python",
    "code": "import itertools as it\nT,F = True,False\n\nwhile 1:\n    s = raw_input()\n    if s == \"#\": break\n    while \"--\" in s: s = s.replace(\"--\",\"\")\n    for b,a in zip([\"=\",\"->\",\"-\",\"*\",\"+\"],[\") == (\",\" != 1 or \",\" not \",\" and \",\" or \"]):\n        s = s.replace(b,a)\n    s = \"(\"+s+\")\"\n    for v in xrange(2**11):\n        a,b,c,d,e,f,g,h,i,j,k = map(int,list(format(v,\"b\").zfill(11)))\n        if not eval(s):\n            print \"NO\"\n            break\n    else:\n        print \"YES\""
  },
  {
    "language": "Python",
    "code": "while True:\n\n    s = input()\n\n    if s == \"#\":\n        break\n\n    index = -1\n\n    bits = []\n\n    for i in range(2<<11):\n        bit = []\n        for j in range(11):\n            bit.append(i >> j & 1 == 1)\n        bits.append(bit)\n        \n\n    def formula(string):\n        global index\n        index += 1\n        if string[index] == \"T\":\n            return True\n        elif string[index] == \"F\":\n            return False\n        elif string[index] == \"-\":\n            return not formula(string)\n        elif string[index] == \"(\":\n            left = formula(string)\n            index += 1\n            ope = string[index]\n            if ope == \"-\":\n                index += 1\n            right = formula(string)\n            index += 1\n            if ope == \"+\":\n                return left or right\n            elif ope == \"*\":\n                return left and right\n            else:\n\n                return False if left and not right else True\n        else:\n            return bit[ord(string[index]) - ord(\"a\")]\n    \n    f = True\n    for bit in bits:\n        l,r = s.split(\"=\")\n\n        index = -1 \n        l_b = formula(l)\n        index = -1\n        r_b = formula(r)\n\n        if l_b != r_b:\n            f = False\n    \n    if f:\n        print(\"YES\")\n    else:\n        print(\"NO\")\n\n    # l,r = s.split(\"=\")\n    # l_b = formula()\n"
  },
  {
    "language": "Python",
    "code": "#!/usr/bin/env python\n#-*- coding:utf-8 -*-\nimport sys\nsys.setrecursionlimit(10000)\n\nclass TerminalNode(object):\n\tdef __init__(self, value):\n\t\tself.index = int(value)\n\t\tself.value = value\n\tdef __call__(self, assign):\n\t\treturn self.value\n\tdef printTree(self, visited=set(),  indent=0):\n\t\tprint \"\\t\" * indent, self\n\tdef _getNextThen(self, index):\n\t\treturn self\n\tdef _getNextElse(self, index):\n\t\treturn self\n\tdef ITE(self, thenNode, elseNode):\n\t\tif self.value:\n\t\t\treturn thenNode\n\t\telse:\n\t\t\treturn elseNode\n\tdef __eq__(self, other):\n\t\treturn isinstance(other, TerminalNode) and self.value == other.value\n\tdef __neq__(self, other):\n\t\treturn not self.__eq__(other)\n\tdef __repr__(self):\n\t\treturn \"<TerminalNode: %s>\" % self.value\n\nclass DiagramNode(object):\n\tdef __init__(self, label, bdd, thenNode, elseNode):\n\t\tself.index = bdd.variable_counter\n\t\tbdd.variable_counter += 1\n\t\tself.label = label\n\t\tself.thenNode = thenNode\n\t\tself.elseNode = elseNode\n\t\tself.bdd = bdd\n\tdef __call__(self, assign):\n\t\tif assign[self.label]:\n\t\t\treturn self.thenNode(assign)\n\t\telse:\n\t\t\treturn self.elseNode(assign)\n\tdef printTree(self, visited=set(),  indent=0):\n\t\tprint \"\\t\" * indent, self\n#\t\tif self.index not in visited:\n#\t\t\tvisited.add(self.index)\n\t\tself.thenNode.printTree(visited, indent + 1)\n\t\tself.elseNode.printTree(visited, indent + 1)\n\tdef _getNextThen(self, label):\n\t\tif label == self.label:\n\t\t\treturn self.thenNode\n\t\treturn self\n\tdef _getNextElse(self, label):\n\t\tif label == self.label:\n\t\t\treturn self.elseNode\n\t\treturn self\n\tdef ITE(self, thenNode, elseNode):\n\t\t# 計算済みなら計算したサブグラフを返す\n\t\tcompute_key = (self.index, thenNode.index, elseNode.index)\n\t\tif compute_key in self.bdd.compute_table:\n\t\t\treturn self.bdd.compute_table[compute_key]\n\t\t# 最も計算順序の早い変数\n\t\tv = max([x for x in [self, thenNode, elseNode] if isinstance(x, DiagramNode)],\n\t\t\t\tkey=lambda x: x.label)\n\t\t# 1枝側のサブグラフ\n\t\tT = self._getNextThen(v.label).ITE(thenNode._getNextThen(v.label),\n\t\t\t\t\t\t\t\t\t\t\telseNode._getNextThen(v.label))\n\t\t# 0枝側のサブグラフ\n\t\tE = self._getNextElse(v.label).ITE(thenNode._getNextElse(v.label),\n\t\t\t\t\t\t\t\t\t\t\telseNode._getNextElse(v.label))\n\t\tif T == E: return T\n\t\tunique_key = (v.label, T.index, E.index)\n\t\tif unique_key in self.bdd.unique_table:\n\t\t\tR = self.bdd.unique_table[unique_key]\n\t\telse:\n\t\t\tR = DiagramNode(v.label, self.bdd, T, E)\n\t\t\tself.bdd.unique_table[unique_key] = R\n\t\tself.bdd.compute_table[compute_key] = R\n\t\treturn R\n\tdef noneGC(self, visited):\n\t\tvisited.add(self.index)\n\t\tfor v in (self.thenNode, self.elseNode):\n\t\t\tif isinstance(v, DiagramNode) and v.index not in visited:\n\t\t\t\tv.noneGC(visited)\n\tdef __eq__(self, other):\n\t\treturn isinstance(other, DiagramNode) and\\\n\t\t\tself.label == other.label and\\\n\t\t\tself.thenNode is other.thenNode and\\\n\t\t\tself.elseNode is other.elseNode\n\tdef __neq__(self, other):\n\t\treturn not self.__eq__(other)\n\tdef __repr__(self):\n\t\treturn \"<DiagramNode: %s(%d)>\" % (self.label, self.index)\n\nclass BinaryDecisionDiagram(object):\n\ttermTrue = TerminalNode(True)\n\ttermFalse = TerminalNode(False)\n\tdef __init__(self):\n\t\tself.unique_table = {}\n\t\tself.compute_table = {}\n\t\tself.variable_counter = 2\n\t\tself.last = None\n\tdef newVariable(self, label):\n\t\tunique_key = (label, 1, 0)\n\t\tif unique_key in self.unique_table:\n\t\t\tself.last = self.unique_table[unique_key]\n\t\t\treturn self.last\n\t\tself.last = DiagramNode(label, self, self.termTrue, self.termFalse)\n\t\tself.unique_table[unique_key] = self.last\n\t\treturn self.last\n\tdef apply_not(self, a):\n\t\tres = a.ITE(self.termFalse, self.termTrue)\n\t\tself.last = res\n\t\treturn res\n\tdef apply_and(self, a, b):\n\t\tres = a.ITE(b, self.termFalse)\n\t\tself.last = res\n\t\treturn res\n\tdef apply_or(self, a, b):\n\t\tres = a.ITE(self.termTrue, b)\n\t\tself.last = res\n\t\treturn res\n\tdef gc(self, active=[]):\n\t\tif self.last is not None:\n\t\t\tvisited = set()\n\t\t\tfor v in [self.last] + active:\n\t\t\t\tv.noneGC(visited)\n\t\t\tfor key, value in self.unique_table.items():\n\t\t\t\tif value.index not in visited:\n\t\t\t\t\tdel self.unique_table[key]\n\tdef apply_imp(self, a, b):\n\t\tres = a.ITE(b, self.termTrue)\n\t\tself.last = res\n\t\treturn res\nclass Parser(object):\n\tdef __init__(self, bdd):\n\t\tself.bdd = bdd\n\tdef parse(self, expr):\n\t\tself.expr = expr\n\t\tself.index = 0\n\t\treturn self.formula()\n\tdef formula(self):\n\t\tif self.expr[self.index] == 'T':\n\t\t\tself.index += 1\n\t\t\treturn self.bdd.termTrue\n\t\tif self.expr[self.index] == 'F':\n\t\t\tself.index += 1\n\t\t\treturn self.bdd.termFalse\n\t\tif self.expr[self.index].isalpha():\n\t\t\tc = self.expr[self.index]\n\t\t\tself.index += 1\n\t\t\treturn self.bdd.newVariable(c)\n\t\tif self.expr[self.index] == \"-\":\n\t\t\tself.index += 1\n\t\t\treturn self.bdd.apply_not(self.formula())\n\t\tif self.expr[self.index] == \"(\":\n\t\t\tself.index += 1\n\t\t\tf = self.formula()\n\t\t\top = self.expr[self.index]\n\t\t\tif op == \"*\":\n\t\t\t\tself.index += 1\n\t\t\t\tf = self.bdd.apply_and(f, self.formula())\n\t\t\t\tself.index += 1\n\t\t\t\treturn f\n\t\t\tif op == \"+\":\n\t\t\t\tself.index += 1\n\t\t\t\tf = self.bdd.apply_or(f, self.formula())\n\t\t\t\tself.index += 1\n\t\t\t\treturn f\n\t\t\tif op == \"-\":\n\t\t\t\tself.index += 2\n\t\t\t\tf = self.bdd.apply_imp(f, self.formula())\n\t\t\t\tself.index += 1\n\t\t\t\treturn f\nwhile True:\n\tline = raw_input()\n\tif line == \"#\": break\n\tbdd = BinaryDecisionDiagram()\n\tparser = Parser(bdd)\n\ta, b = line.split(\"=\")\n\ta = parser.parse(a + \";\")\n\tb = parser.parse(b + \";\")\n\tif a == b:\n\t\tprint \"YES\"\n\telse:\n\t\tprint \"NO\""
  },
  {
    "language": "Python",
    "code": "import sys\nsys.setrecursionlimit(10000)\n\nclass TerminalNode(object):\n\tdef __init__(self, value):\n\t\tself.index = int(value)\n\t\tself.value = value\n\tdef __call__(self, assign):\n\t\treturn self.value\n\tdef printTree(self, visited=set(),  indent=0):\n\t\tprint(\"\\t\" * indent, self)\n\tdef _getNextThen(self, index):\n\t\treturn self\n\tdef _getNextElse(self, index):\n\t\treturn self\n\tdef ITE(self, thenNode, elseNode):\n\t\tif self.value:\n\t\t\treturn thenNode\n\t\telse:\n\t\t\treturn elseNode\n\tdef __eq__(self, other):\n\t\treturn isinstance(other, TerminalNode) and self.value == other.value\n\tdef __neq__(self, other):\n\t\treturn not self.__eq__(other)\nclass DiagramNode(object):\n\tdef __init__(self, label, bdd, thenNode, elseNode):\n\t\tself.index = bdd.variable_counter\n\t\tbdd.variable_counter += 1\n\t\tself.label = label\n\t\tself.thenNode = thenNode\n\t\tself.elseNode = elseNode\n\t\tself.bdd = bdd\n\tdef _getNextThen(self, label):\n\t\tif label == self.label:\n\t\t\treturn self.thenNode\n\t\treturn self\n\tdef _getNextElse(self, label):\n\t\tif label == self.label:\n\t\t\treturn self.elseNode\n\t\treturn self\n\tdef ITE(self, thenNode, elseNode):\n\t\tcompute_key = (self.label, thenNode.index, elseNode.index)\n\t\tif compute_key in self.bdd.compute_table:\n\t\t\treturn self.bdd.compute_table[compute_key]\n\t\tv = max([x for x in [self, thenNode, elseNode] if isinstance(x, DiagramNode)],\n\t\t\t\tkey=lambda x: x.label)\n\t\tT = self._getNextThen(v.label).ITE(thenNode._getNextThen(v.label),\n\t\t\t\t\t\t\t\t\t\t   elseNode._getNextThen(v.label))\n\t\tE = self._getNextElse(v.label).ITE(thenNode._getNextElse(v.label),\n\t\t\t\t\t\t\t\t\t\t   elseNode._getNextElse(v.label))\n\t\tif T == E: return T\n\t\tunique_key = (v.label, T.index, E.index)\n\t\tif unique_key in self.bdd.unique_table:\n\t\t\tR = self.bdd.unique_table[unique_key]\n\t\telse:\n\t\t\tR = DiagramNode(v.label, self.bdd, T, E)\n\t\t\tself.bdd.unique_table[unique_key] = R\n\t\tself.bdd.compute_table[compute_key] = R\n\t\treturn R\n\tdef __eq__(self, other):\n\t\treturn isinstance(other, DiagramNode) and\\\n\t\t\tself.label == other.label and\\\n\t\t\tself.thenNode is other.thenNode and\\\n\t\t\tself.elseNode is other.elseNode\n\tdef __neq__(self, other):\n\t\treturn not self.__eq__(other)\nclass BinaryDecisionDiagram(object):\n\ttermTrue = TerminalNode(True)\n\ttermFalse = TerminalNode(False)\n\tdef __init__(self):\n\t\tself.unique_table = {}\n\t\tself.variable_counter = 2\n\t\tself.last = None\n\tdef newVariable(self, label):\n\t\tunique_key = (label, 1, 0)\n\t\tif unique_key in self.unique_table:\n\t\t\tself.last = self.unique_table[unique_key]\n\t\t\treturn self.last\n\t\tself.last = DiagramNode(label, self, self.termTrue, self.termFalse)\n\t\tself.unique_table[unique_key] = self.last\n\t\treturn self.last\n\tdef apply_not(self, a):\n\t\tself.compute_table = {}\n\t\tres = a.ITE(self.termFalse, self.termTrue)\n\t\tself.last = res\n\t\treturn res\n\tdef apply_and(self, a, b):\n\t\tself.compute_table = {}\n\t\tres = a.ITE(b, self.termFalse)\n\t\tself.last = res\n\t\treturn res\n\tdef apply_or(self, a, b):\n\t\tself.compute_table = {}\n\t\tres = a.ITE(self.termTrue, b)\n\t\tself.last = res\n\t\treturn res\n\tdef apply_imp(self, a, b):\n\t\tself.compute_table = {}\n\t\tres = a.ITE(b, self.termTrue)\n\t\tself.last = res\n\t\treturn res\nclass Parser(object):\n\tdef __init__(self, bdd):\n\t\tself.bdd = bdd\n\tdef parse(self, expr):\n\t\tself.expr = expr\n\t\tself.index = 0\n\t\treturn self.formula()\n\tdef formula(self):\n\t\tif self.expr[self.index] == 'T':\n\t\t\tself.index += 1\n\t\t\treturn self.bdd.termTrue\n\t\tif self.expr[self.index] == 'F':\n\t\t\tself.index += 1\n\t\t\treturn self.bdd.termFalse\n\t\tif self.expr[self.index].isalpha():\n\t\t\tself.index += 1\n\t\t\treturn self.bdd.newVariable(self.expr[self.index - 1])\n\t\tif self.expr[self.index] == \"-\":\n\t\t\tself.index += 1\n\t\t\treturn self.bdd.apply_not(self.formula())\n\t\tif self.expr[self.index] == \"(\":\n\t\t\tself.index += 1\n\t\t\tf = self.formula()\n\t\t\top = self.expr[self.index]\n\t\t\tif op == \"*\":\n\t\t\t\tself.index += 1\n\t\t\t\tf = self.bdd.apply_and(f, self.formula())\n\t\t\t\tself.index += 1\n\t\t\t\treturn f\n\t\t\tif op == \"+\":\n\t\t\t\tself.index += 1\n\t\t\t\tf = self.bdd.apply_or(f, self.formula())\n\t\t\t\tself.index += 1\n\t\t\t\treturn f\n\t\t\tif op == \"-\":\n\t\t\t\tself.index += 2\n\t\t\t\tf = self.bdd.apply_imp(f, self.formula())\n\t\t\t\tself.index += 1\n\t\t\t\treturn f\n\t\tprint \"error: \" + self.expr[self.index:]\nwhile True:\n\tline = raw_input()\n\tif line == \"#\": break\n\tbdd = BinaryDecisionDiagram()\n\tparser = Parser(bdd)\n\ta, b = line.split(\"=\")\n\tif parser.parse(a + \";\") == parser.parse(b + \";\"):\n\t\tprint \"YES\"\n\telse:\n\t\tprint \"NO\""
  },
  {
    "language": "Python",
    "code": "class TerminalNode(object):\n\tdef __init__(self, value):\n\t\tself.index = int(value)\n\t\tself.value = value\n\tdef __call__(self, assign):\n\t\treturn self.value\n\tdef printTree(self, visited=set(),  indent=0):\n\t\tprint(\"\\t\" * indent, self)\n\tdef _getNextThen(self, index):\n\t\treturn self\n\tdef _getNextElse(self, index):\n\t\treturn self\n\tdef ITE(self, thenNode, elseNode):\n\t\tif self.value:\n\t\t\treturn thenNode\n\t\telse:\n\t\t\treturn elseNode\n\tdef __eq__(self, other):\n\t\treturn isinstance(other, TerminalNode) and self.value == other.value\n\tdef __neq__(self, other):\n\t\treturn not self.__eq__(other)\n\nclass DiagramNode(object):\n\tdef __init__(self, label, bdd, thenNode, elseNode):\n\t\tself.index = bdd.variable_counter\n\t\tbdd.variable_counter += 1\n\t\tself.label = label\n\t\tself.thenNode = thenNode\n\t\tself.elseNode = elseNode\n\t\tself.bdd = bdd\n\tdef _getNextThen(self, label):\n\t\tif label == self.label:\n\t\t\treturn self.thenNode\n\t\treturn self\n\tdef _getNextElse(self, label):\n\t\tif label == self.label:\n\t\t\treturn self.elseNode\n\t\treturn self\n\tdef ITE(self, thenNode, elseNode):\n\t\tcompute_key = (self.label, thenNode.index, elseNode.index)\n\t\tif compute_key in self.bdd.compute_table:\n\t\t\treturn self.bdd.compute_table[compute_key]\n\t\tv = max([x for x in [self, thenNode, elseNode] if isinstance(x, DiagramNode)],\n\t\t\t\tkey=lambda x: x.label)\n\t\tT = self._getNextThen(v.label).ITE(thenNode._getNextThen(v.label),\n\t\t\t\t\t\t\t\t\t\t   elseNode._getNextThen(v.label))\n\t\tE = self._getNextElse(v.label).ITE(thenNode._getNextElse(v.label),\n\t\t\t\t\t\t\t\t\t\t   elseNode._getNextElse(v.label))\n\t\tif T == E: return T\n\t\tunique_key = (v.label, T.index, E.index)\n\t\tif unique_key in self.bdd.unique_table:\n\t\t\tR = self.bdd.unique_table[unique_key]\n\t\telse:\n\t\t\tR = DiagramNode(v.label, self.bdd, T, E)\n\t\t\tself.bdd.unique_table[unique_key] = R\n\t\tself.bdd.compute_table[compute_key] = R\n\t\treturn R\n\tdef __eq__(self, other):\n\t\treturn isinstance(other, DiagramNode) and\\\n\t\t\tself.label == other.label and\\\n\t\t\tself.thenNode is other.thenNode and\\\n\t\t\tself.elseNode is other.elseNode\n\tdef __neq__(self, other):\n\t\treturn not self.__eq__(other)\n\nclass BinaryDecisionDiagram(object):\n\ttermTrue = TerminalNode(True)\n\ttermFalse = TerminalNode(False)\n\tdef __init__(self):\n\t\tself.unique_table = {}\n\t\tself.variable_counter = 2\n\t\tself.last = None\n\tdef newVariable(self, label):\n\t\tunique_key = (label, 1, 0)\n\t\tif unique_key in self.unique_table:\n\t\t\tself.last = self.unique_table[unique_key]\n\t\t\treturn self.last\n\t\tself.last = DiagramNode(label, self, self.termTrue, self.termFalse)\n\t\tself.unique_table[unique_key] = self.last\n\t\treturn self.last\n\tdef apply_not(self, a):\n\t\tself.compute_table = {}\n\t\tres = a.ITE(self.termFalse, self.termTrue)\n\t\tself.last = res\n\t\treturn res\n\tdef apply_and(self, a, b):\n\t\tself.compute_table = {}\n\t\tres = a.ITE(b, self.termFalse)\n\t\tself.last = res\n\t\treturn res\n\tdef apply_or(self, a, b):\n\t\tself.compute_table = {}\n\t\tres = a.ITE(self.termTrue, b)\n\t\tself.last = res\n\t\treturn res\n\tdef apply_imp(self, a, b):\n\t\tself.compute_table = {}\n\t\tres = a.ITE(b, self.termTrue)\n\t\tself.last = res\n\t\treturn res\n\nclass Parser(object):\n\tdef __init__(self, bdd):\n\t\tself.bdd = bdd\n\tdef parse(self, expr):\n\t\tself.expr = expr\n\t\tself.index = 0\n\t\treturn self.formula()\n\tdef formula(self):\n\t\tif self.expr[self.index] == 'T':\n\t\t\tself.index += 1\n\t\t\treturn self.bdd.termTrue\n\t\tif self.expr[self.index] == 'F':\n\t\t\tself.index += 1\n\t\t\treturn self.bdd.termFalse\n\t\tif self.expr[self.index].isalpha():\n\t\t\tself.index += 1\n\t\t\treturn self.bdd.newVariable(self.expr[self.index - 1])\n\t\tif self.expr[self.index] == \"-\":\n\t\t\tself.index += 1\n\t\t\treturn self.bdd.apply_not(self.formula())\n\t\tif self.expr[self.index] == \"(\":\n\t\t\tself.index += 1\n\t\t\tf = self.formula()\n\t\t\top = self.expr[self.index]\n\t\t\tif op == \"*\":\n\t\t\t\tself.index += 1\n\t\t\t\tf = self.bdd.apply_and(f, self.formula())\n\t\t\t\tself.index += 1\n\t\t\t\treturn f\n\t\t\tif op == \"+\":\n\t\t\t\tself.index += 1\n\t\t\t\tf = self.bdd.apply_or(f, self.formula())\n\t\t\t\tself.index += 1\n\t\t\t\treturn f\n\t\t\tif op == \"-\":\n\t\t\t\tself.index += 2\n\t\t\t\tf = self.bdd.apply_imp(f, self.formula())\n\t\t\t\tself.index += 1\n\t\t\t\treturn f\n\t\tprint \"error: \" + self.expr[self.index:]\n\nwhile True:\n\tline = raw_input()\n\tif line == \"#\": break\n\tbdd = BinaryDecisionDiagram()\n\tparser = Parser(bdd)\n\ta, b = line.split(\"=\")\n\tif parser.parse(a + \";\") == parser.parse(b + \";\"):\n\t\tprint \"YES\"\n\telse:\n\t\tprint \"NO\""
  },
  {
    "language": "Python",
    "code": "T,F = True,False\nwhile 1:\n    s = raw_input()\n    if s == \"#\": break\n    for i in xrange(100): s = s.replace(\"--\",\"\")\n    for b,a in zip([\"=\",\"->\",\"-\",\"*\",\"+\"],[\") == (\",\" != 1 or \",\" not \",\" and \",\" or \"]):\n        s = s.replace(b,a)\n    s = \"(\"+s+\")\"\n    for v in xrange(2**11):\n        a,b,c,d,e,f,g,h,i,j,k = map(int,list(format(v,\"b\").zfill(11)))\n        if not eval(s):\n            print \"NO\"\n            break\n    else:\n        print \"YES\""
  },
  {
    "language": "Python",
    "code": "#!/usr/bin/env python\n#-*- coding:utf-8 -*-\nimport sys\nsys.setrecursionlimit(10000)\n\nclass TerminalNode(object):\n\tdef __init__(self, value):\n\t\tself.index = int(value)\n\t\tself.value = value\n\tdef __call__(self, assign):\n\t\treturn self.value\n\tdef printTree(self, visited=set(),  indent=0):\n\t\tprint \"\\t\" * indent, self\n\tdef _getNextThen(self, index):\n\t\treturn self\n\tdef _getNextElse(self, index):\n\t\treturn self\n\tdef ITE(self, thenNode, elseNode):\n\t\tif self.value:\n\t\t\treturn thenNode\n\t\telse:\n\t\t\treturn elseNode\n\tdef __eq__(self, other):\n\t\treturn isinstance(other, TerminalNode) and self.value == other.value\n\tdef __neq__(self, other):\n\t\treturn not self.__eq__(other)\n\tdef __repr__(self):\n\t\treturn \"<TerminalNode: %s>\" % self.value\n\nclass DiagramNode(object):\n\tdef __init__(self, label, bdd, thenNode, elseNode):\n\t\tself.index = bdd.variable_counter\n\t\tbdd.variable_counter += 1\n\t\tself.label = label\n\t\tself.thenNode = thenNode\n\t\tself.elseNode = elseNode\n\t\tself.bdd = bdd\n\tdef __call__(self, assign):\n\t\tif assign[self.label]:\n\t\t\treturn self.thenNode(assign)\n\t\telse:\n\t\t\treturn self.elseNode(assign)\n\tdef printTree(self, visited=set(),  indent=0):\n\t\tprint \"\\t\" * indent, self\n#\t\tif self.index not in visited:\n#\t\t\tvisited.add(self.index)\n\t\tself.thenNode.printTree(visited, indent + 1)\n\t\tself.elseNode.printTree(visited, indent + 1)\n\tdef _getNextThen(self, label):\n\t\tif label == self.label:\n\t\t\treturn self.thenNode\n\t\treturn self\n\tdef _getNextElse(self, label):\n\t\tif label == self.label:\n\t\t\treturn self.elseNode\n\t\treturn self\n\tdef ITE(self, thenNode, elseNode):\n\t\t# 計算済みなら計算したサブグラフを返す\n\t\tcompute_key = (self.label, thenNode.index, elseNode.index)\n\t\tif compute_key in self.bdd.compute_table:\n\t\t\treturn self.bdd.compute_table[compute_key]\n\t\t# 最も計算順序の早い変数\n\t\tv = max([x for x in [self, thenNode, elseNode] if isinstance(x, DiagramNode)],\n\t\t\t\tkey=lambda x: x.label)\n\t\t# 1枝側のサブグラフ\n\t\tT = self._getNextThen(v.label).ITE(thenNode._getNextThen(v.label),\n\t\t\t\t\t\t\t\t\t\t   elseNode._getNextThen(v.label))\n\t\t# 0枝側のサブグラフ\n\t\tE = self._getNextElse(v.label).ITE(thenNode._getNextElse(v.label),\n\t\t\t\t\t\t\t\t\t\t   elseNode._getNextElse(v.label))\n\t\tif T == E: return T\n\t\tunique_key = (v.label, T.index, E.index)\n\t\tif unique_key in self.bdd.unique_table:\n\t\t\tR = self.bdd.unique_table[unique_key]\n\t\telse:\n\t\t\tR = DiagramNode(v.label, self.bdd, T, E)\n\t\t\tself.bdd.unique_table[unique_key] = R\n\t\tself.bdd.compute_table[compute_key] = R\n\t\treturn R\n\tdef noneGC(self, visited):\n\t\tvisited.add(self.index)\n\t\tfor v in (self.thenNode, self.elseNode):\n\t\t\tif isinstance(v, DiagramNode) and v.index not in visited:\n\t\t\t\tv.noneGC(visited)\n\tdef __eq__(self, other):\n\t\treturn isinstance(other, DiagramNode) and\\\n\t\t\tself.label == other.label and\\\n\t\t\tself.thenNode is other.thenNode and\\\n\t\t\tself.elseNode is other.elseNode\n\tdef __neq__(self, other):\n\t\treturn not self.__eq__(other)\n\tdef __repr__(self):\n\t\treturn \"<DiagramNode: %s(%d)>\" % (self.label, self.index)\n\nclass BinaryDecisionDiagram(object):\n\ttermTrue = TerminalNode(True)\n\ttermFalse = TerminalNode(False)\n\tdef __init__(self):\n\t\tself.unique_table = {}\n\t\tself.variable_counter = 2\n\t\tself.last = None\n\tdef newVariable(self, label):\n\t\tunique_key = (label, 1, 0)\n\t\tif unique_key in self.unique_table:\n\t\t\tself.last = self.unique_table[unique_key]\n\t\t\treturn self.last\n\t\tself.last = DiagramNode(label, self, self.termTrue, self.termFalse)\n\t\tself.unique_table[unique_key] = self.last\n\t\treturn self.last\n\tdef apply_not(self, a):\n\t\tself.compute_table = {}\n\t\tres = a.ITE(self.termFalse, self.termTrue)\n\t\tself.last = res\n\t\treturn res\n\tdef apply_and(self, a, b):\n\t\tself.compute_table = {}\n\t\tres = a.ITE(b, self.termFalse)\n\t\tself.last = res\n\t\treturn res\n\tdef apply_nand(self, a, b):\n\t\tself.compute_table = {}\n\t\tres = a.ITE(self.apply_not(b), self.termTrue)\n\t\tself.last = res\n\t\treturn res\n\tdef apply_or(self, a, b):\n\t\tself.compute_table = {}\n\t\tres = a.ITE(self.termTrue, b)\n\t\tself.last = res\n\t\treturn res\n\tdef apply_nor(self, a, b):\n\t\tself.compute_table = {}\n\t\tres = a.ITE(self.termFalse, self.apply_not(b))\n\t\tself.last = res\n\t\treturn res\n\tdef apply_xor(self, a, b):\n\t\tself.compute_table = {}\n\t\tres = a.ITE(self.apply_not(b), b)\n\t\tself.last = res\n\t\treturn res\n\tdef apply_xnor(self, a, b):\n\t\tself.compute_table = {}\n\t\tres = a.ITE(b, self.apply_not(b))\n\t\tself.last = res\n\t\treturn res\n\tdef gc(self, active=[]):\n\t\tif self.last is not None:\n\t\t\tvisited = set()\n\t\t\tfor v in [self.last] + active:\n\t\t\t\tv.noneGC(visited)\n\t\t\tfor key, value in self.unique_table.items():\n\t\t\t\tif value.index not in visited:\n\t\t\t\t\tdel self.unique_table[key]\n\tdef apply_imp(self, a, b):\n\t\tself.compute_table = {}\n\t\tres = a.ITE(b, self.termTrue)\n\t\tself.last = res\n\t\treturn res\nclass Parser(object):\n\tdef __init__(self, bdd):\n\t\tself.bdd = bdd\n\tdef parse(self, expr):\n\t\tself.expr = expr\n\t\tself.index = 0\n\t\treturn self.formula()\n\tdef formula(self):\n\t\tif self.expr[self.index] == 'T':\n\t\t\tself.index += 1\n\t\t\treturn self.bdd.termTrue\n\t\tif self.expr[self.index] == 'F':\n\t\t\tself.index += 1\n\t\t\treturn self.bdd.termFalse\n\t\tif self.expr[self.index].isalpha():\n\t\t\tc = self.expr[self.index]\n\t\t\tself.index += 1\n\t\t\treturn self.bdd.newVariable(c)\n\t\tif self.expr[self.index] == \"-\":\n\t\t\tself.index += 1\n\t\t\treturn self.bdd.apply_not(self.formula())\n\t\tif self.expr[self.index] == \"(\":\n\t\t\tself.index += 1\n\t\t\tf = self.formula()\n\t\t\top = self.expr[self.index]\n\t\t\tif op == \"*\":\n\t\t\t\tself.index += 1\n\t\t\t\tf = self.bdd.apply_and(f, self.formula())\n\t\t\t\tself.index += 1\n\t\t\t\treturn f\n\t\t\tif op == \"+\":\n\t\t\t\tself.index += 1\n\t\t\t\tf = self.bdd.apply_or(f, self.formula())\n\t\t\t\tself.index += 1\n\t\t\t\treturn f\n\t\t\tif op == \"-\":\n\t\t\t\tself.index += 2\n\t\t\t\tf = self.bdd.apply_imp(f, self.formula())\n\t\t\t\tself.index += 1\n\t\t\t\treturn f\nwhile True:\n\tline = raw_input()\n\tif line == \"#\": break\n\tbdd = BinaryDecisionDiagram()\n\tparser = Parser(bdd)\n\ta, b = line.split(\"=\")\n\ta = parser.parse(a + \";\")\n\tb = parser.parse(b + \";\")\n\ta.printTree()\n\tb.printTree()\n\tif a == b:\n\t\tprint \"YES\"\n\telse:\n\t\tprint \"NO\""
  },
  {
    "language": "Python",
    "code": "#!/usr/bin/env python\n#-*- coding:utf-8 -*-\nimport sys\nsys.setrecursionlimit(10000)\n\nclass TerminalNode(object):\n\tdef __init__(self, value):\n\t\tself.index = int(value)\n\t\tself.value = value\n\tdef __call__(self, assign):\n\t\treturn self.value\n\tdef printTree(self, visited=set(),  indent=0):\n\t\tprint \"\\t\" * indent, self\n\tdef _getNextThen(self, index):\n\t\treturn self\n\tdef _getNextElse(self, index):\n\t\treturn self\n\tdef ITE(self, thenNode, elseNode):\n\t\tif self.value:\n\t\t\treturn thenNode\n\t\telse:\n\t\t\treturn elseNode\n\tdef __eq__(self, other):\n\t\treturn isinstance(other, TerminalNode) and self.value == other.value\n\tdef __neq__(self, other):\n\t\treturn not self.__eq__(other)\n\tdef __repr__(self):\n\t\treturn \"<TerminalNode: %s>\" % self.value\n\nclass DiagramNode(object):\n\tdef __init__(self, label, bdd, thenNode, elseNode):\n\t\tself.index = bdd.variable_counter\n\t\tbdd.variable_counter += 1\n\t\tself.label = label\n\t\tself.thenNode = thenNode\n\t\tself.elseNode = elseNode\n\t\tself.bdd = bdd\n\tdef __call__(self, assign):\n\t\tif assign[self.label]:\n\t\t\treturn self.thenNode(assign)\n\t\telse:\n\t\t\treturn self.elseNode(assign)\n\tdef printTree(self, visited=set(),  indent=0):\n\t\tprint \"\\t\" * indent, self\n#\t\tif self.index not in visited:\n#\t\t\tvisited.add(self.index)\n\t\tself.thenNode.printTree(visited, indent + 1)\n\t\tself.elseNode.printTree(visited, indent + 1)\n\tdef _getNextThen(self, label):\n\t\tif label == self.label:\n\t\t\treturn self.thenNode\n\t\treturn self\n\tdef _getNextElse(self, label):\n\t\tif label == self.label:\n\t\t\treturn self.elseNode\n\t\treturn self\n\tdef ITE(self, thenNode, elseNode):\n\t\t# 計算済みなら計算したサブグラフを返す\n\t\tcompute_key = (self.index, thenNode.index, elseNode.index)\n\t\tif compute_key in self.bdd.compute_table:\n\t\t\treturn self.bdd.compute_table[compute_key]\n\t\t# 最も計算順序の早い変数\n\t\tv = max([x for x in [self, thenNode, elseNode] if isinstance(x, DiagramNode)],\n\t\t\t\tkey=lambda x: x.label)\n\t\t# 1枝側のサブグラフ\n\t\tT = self._getNextThen(v.label).ITE(thenNode._getNextThen(v.label),\n\t\t\t\t\t\t\t\t\t\t\telseNode._getNextThen(v.label))\n\t\t# 0枝側のサブグラフ\n\t\tE = self._getNextElse(v.label).ITE(thenNode._getNextElse(v.label),\n\t\t\t\t\t\t\t\t\t\t\telseNode._getNextElse(v.label))\n\t\tif T == E: return T\n\t\tunique_key = (v.label, T.index, E.index)\n\t\tif unique_key in self.bdd.unique_table:\n\t\t\tR = self.bdd.unique_table[unique_key]\n\t\telse:\n\t\t\tR = DiagramNode(v.label, self.bdd, T, E)\n\t\t\tself.bdd.unique_table[unique_key] = R\n\t\tself.bdd.compute_table[compute_key] = R\n\t\treturn R\n\tdef noneGC(self, visited):\n\t\tvisited.add(self.index)\n\t\tfor v in (self.thenNode, self.elseNode):\n\t\t\tif isinstance(v, DiagramNode) and v.index not in visited:\n\t\t\t\tv.noneGC(visited)\n\tdef __eq__(self, other):\n\t\treturn isinstance(other, DiagramNode) and\\\n\t\t\tself.label == other.label and\\\n\t\t\tself.thenNode is other.thenNode and\\\n\t\t\tself.elseNode is other.elseNode\n\tdef __neq__(self, other):\n\t\treturn not self.__eq__(other)\n\tdef __repr__(self):\n\t\treturn \"<DiagramNode: %s(%d)>\" % (self.label, self.index)\n\nclass BinaryDecisionDiagram(object):\n\ttermTrue = TerminalNode(True)\n\ttermFalse = TerminalNode(False)\n\tdef __init__(self):\n\t\tself.unique_table = {}\n\t\tself.variable_counter = 2\n\t\tself.last = None\n\tdef newVariable(self, label):\n\t\tunique_key = (label, 1, 0)\n\t\tif unique_key in self.unique_table:\n\t\t\tself.last = self.unique_table[unique_key]\n\t\t\treturn self.last\n\t\tself.last = DiagramNode(label, self, self.termTrue, self.termFalse)\n\t\tself.unique_table[unique_key] = self.last\n\t\treturn self.last\n\tdef apply_not(self, a):\n\t\tres = a.ITE(self.termFalse, self.termTrue)\n\t\tself.last = res\n\t\treturn res\n\tdef apply_and(self, a, b):\n\t\tres = a.ITE(b, self.termFalse)\n\t\tself.last = res\n\t\treturn res\n\tdef apply_or(self, a, b):\n\t\tres = a.ITE(self.termTrue, b)\n\t\tself.last = res\n\t\treturn res\n\tdef gc(self, active=[]):\n\t\tif self.last is not None:\n\t\t\tvisited = set()\n\t\t\tfor v in [self.last] + active:\n\t\t\t\tv.noneGC(visited)\n\t\t\tfor key, value in self.unique_table.items():\n\t\t\t\tif value.index not in visited:\n\t\t\t\t\tdel self.unique_table[key]\n\tdef apply_imp(self, a, b):\n\t\tself.compute_table = {}\n\t\tres = a.ITE(b, self.termTrue)\n\t\tself.last = res\n\t\treturn res\nclass Parser(object):\n\tdef __init__(self, bdd):\n\t\tself.bdd = bdd\n\tdef parse(self, expr):\n\t\tself.expr = expr\n\t\tself.index = 0\n\t\treturn self.formula()\n\tdef formula(self):\n\t\tif self.expr[self.index] == 'T':\n\t\t\tself.index += 1\n\t\t\treturn self.bdd.termTrue\n\t\tif self.expr[self.index] == 'F':\n\t\t\tself.index += 1\n\t\t\treturn self.bdd.termFalse\n\t\tif self.expr[self.index].isalpha():\n\t\t\tc = self.expr[self.index]\n\t\t\tself.index += 1\n\t\t\treturn self.bdd.newVariable(c)\n\t\tif self.expr[self.index] == \"-\":\n\t\t\tself.index += 1\n\t\t\treturn self.bdd.apply_not(self.formula())\n\t\tif self.expr[self.index] == \"(\":\n\t\t\tself.index += 1\n\t\t\tf = self.formula()\n\t\t\top = self.expr[self.index]\n\t\t\tif op == \"*\":\n\t\t\t\tself.index += 1\n\t\t\t\tf = self.bdd.apply_and(f, self.formula())\n\t\t\t\tself.index += 1\n\t\t\t\treturn f\n\t\t\tif op == \"+\":\n\t\t\t\tself.index += 1\n\t\t\t\tf = self.bdd.apply_or(f, self.formula())\n\t\t\t\tself.index += 1\n\t\t\t\treturn f\n\t\t\tif op == \"-\":\n\t\t\t\tself.index += 2\n\t\t\t\tf = self.bdd.apply_imp(f, self.formula())\n\t\t\t\tself.index += 1\n\t\t\t\treturn f\nwhile True:\n\tline = raw_input()\n\tif line == \"#\": break\n\tbdd = BinaryDecisionDiagram()\n\tparser = Parser(bdd)\n\ta, b = line.split(\"=\")\n\ta = parser.parse(a + \";\")\n\tb = parser.parse(b + \";\")\n\tif a == b:\n\t\tprint \"YES\"\n\telse:\n\t\tprint \"NO\""
  },
  {
    "language": "Python",
    "code": "# -*- coding: utf-8 -*-\nfrom itertools import product\n\"\"\"\n-> は @と表記する\n\"\"\"\n\ndef parse(S):\n    \"\"\"\n    構文木を返す\n    Sは普通の記法の式\n    opは優先順序　通常は(*/: 1, +-: 2)\n    \"\"\"\n    S = \"{}\".format(S)\n    V = []\n    op = {\"-\": 1,\n          \"+\": 2,\n          \"*\": 2,\n          \"@\": 2}\n    variables = list(\"abcdefghijk\")\n\n    for x in list(\"()+-*@\"):\n        S = S.replace(x, \" {} \".format(x))\n    i = 0\n    rank = 0\n    O = []\n    for s in S.split():\n        if s == \"(\":\n            rank += 1\n        elif s == \")\":\n            rank -= 1\n        elif s in variables + [\"T\", \"F\"]:\n            V.append(s)\n            i += 1\n        else:\n            V.append(s)\n            O.append([-rank, op[s], i])\n            i += 1\n \n    G = [[] for _ in range(len(V))]\n    P = [-1]*len(V)\n    O = sorted(O)\n     \n    def get_pair(i):\n        while P[i] != -1:\n            i = P[i]\n        return i\n    \n    if len(O):\n        for _, _, i in O:\n            if V[i] == \"-\": # 単項演算子\n                r = get_pair(i+1)\n                G[i].append(r)\n                P[r] = i\n            else: # 二項演算子\n                l, r = get_pair(i-1), get_pair(i+1)\n                G[i].extend([l, r])\n                P[l], P[r] = i, i\n        p = P.index(-1)\n    else:\n        assert len(V) == 1\n        p = 0\n    return G, V, p\n \n\ndef calculate(G, V, p, X):\n    variables = set(list(\"abcdefghijk\"))\n    def call(i):\n        if V[i] in variables:\n            return X[V[i]]\n        elif V[i] == \"T\":\n            return True\n        elif V[i] == \"F\":\n            return False\n        elif V[i] == \"-\":\n            return not call(G[i][0])\n        elif V[i] == \"@\":\n            x = call(G[i][0])\n            y = call(G[i][1])\n            return not (x==True and y==False)\n        elif V[i] == \"*\":\n            x = call(G[i][0])\n            y = call(G[i][1])\n            return x & y\n        elif V[i] == \"+\":\n            x = call(G[i][0])\n            y = call(G[i][1])\n            return x | y\n        else:\n            raise\n    return call(p)\n\n\nS = input()\nwhile S != \"#\":\n    L, R = S.replace(\"->\", \"@\").split(\"=\")\n    abc = list(\"abcdefghijk\")\n    for Y in product([True, False], repeat=11):\n        X = dict()\n        for i in range(11):\n            X[abc[i]] = Y[i]\n        G, V, p = parse(L)\n        l = calculate(G, V, p, X)\n        G, V, p = parse(R)\n        r = calculate(G, V, p, X)\n        if l != r:\n            print(\"N0\")\n            break\n    else:\n        print(\"YES\")\n    S = input()\n\n"
  }
]