[
  {
    "model": "deepseek-v3",
    "prompt_type": "zero_shot",
    "language": "C",
    "code": "#include <stdio.h>\n#include <string.h>\n#include <stdbool.h>\n\nbool evaluate(char *expr, bool vars[11]) {\n    bool stack[1000];\n    int top = -1;\n    for (int i = 0; expr[i] != '\\0'; i++) {\n        if (expr[i] == 'T') {\n            stack[++top] = true;\n        } else if (expr[i] == 'F') {\n            stack[++top] = false;\n        } else if (expr[i] >= 'a' && expr[i] <= 'k') {\n            stack[++top] = vars[expr[i] - 'a'];\n        } else if (expr[i] == 'N') {\n            bool a = stack[top--];\n            stack[++top] = !a;\n        } else if (expr[i] == 'A') {\n            bool b = stack[top--];\n            bool a = stack[top--];\n            stack[++top] = a && b;\n        } else if (expr[i] == 'O') {\n            bool b = stack[top--];\n            bool a = stack[top--];\n            stack[++top] = a || b;\n        } else if (expr[i] == 'I') {\n            bool b = stack[top--];\n            bool a = stack[top--];\n            stack[++top] = !a || b;\n        }\n    }\n    return stack[top];\n}\n\nbool is_identity(char *expr) {\n    int vars_present = 0;\n    for (int i = 0; expr[i] != '\\0'; i++) {\n        if (expr[i] >= 'a' && expr[i] <= 'k') {\n            vars_present |= (1 << (expr[i] - 'a'));\n        }\n    }\n    int var_count = 0;\n    for (int i = 0; i < 11; i++) {\n        if (vars_present & (1 << i)) var_count++;\n    }\n    for (int mask = 0; mask < (1 << var_count); mask++) {\n        bool vars[11] = {false};\n        int var_idx = 0;\n        for (int i = 0; i < 11; i++) {\n            if (vars_present & (1 << i)) {\n                vars[i] = (mask >> var_idx) & 1;\n                var_idx++;\n            }\n        }\n        if (!evaluate(expr, vars)) {\n            return false;\n        }\n    }\n    return true;\n}\n\nint main() {\n    char expr[1000];\n    while (scanf(\"%s\", expr) != EOF) {\n        if (is_identity(expr)) {\n            printf(\"YES\\n\");\n        } else {\n            printf(\"NO\\n\");\n        }\n    }\n    return 0;\n}",
    "timestamp": "2025-08-05 21:29:12"
  },
  {
    "model": "deepseek-v3",
    "prompt_type": "zero_shot",
    "language": "C++",
    "code": "#include <iostream>\n#include <string>\n#include <vector>\n#include <map>\n#include <algorithm>\nusing namespace std;\n\nbool evaluate(const string& expr, const map<char, bool>& vars) {\n    vector<bool> stack;\n    for (char c : expr) {\n        if (c == 'T') stack.push_back(true);\n        else if (c == 'F') stack.push_back(false);\n        else if (vars.count(c)) stack.push_back(vars.at(c));\n        else if (c == 'N') {\n            bool a = stack.back(); stack.pop_back();\n            stack.push_back(!a);\n        } else if (c == 'A') {\n            bool a = stack.back(); stack.pop_back();\n            bool b = stack.back(); stack.pop_back();\n            stack.push_back(a && b);\n        } else if (c == 'O') {\n            bool a = stack.back(); stack.pop_back();\n            bool b = stack.back(); stack.pop_back();\n            stack.push_back(a || b);\n        } else if (c == 'I') {\n            bool a = stack.back(); stack.pop_back();\n            bool b = stack.back(); stack.pop_back();\n            stack.push_back(!a || b);\n        }\n    }\n    return stack.back();\n}\n\nbool is_identity(const string& eq) {\n    size_t eq_pos = eq.find('=');\n    string left_expr = eq.substr(0, eq_pos);\n    string right_expr = eq.substr(eq_pos + 1);\n\n    vector<char> variables;\n    for (char c : left_expr + right_expr) {\n        if (c >= 'a' && c <= 'k') {\n            if (find(variables.begin(), variables.end(), c) == variables.end()) {\n                variables.push_back(c);\n            }\n        }\n    }\n\n    int n = variables.size();\n    for (int mask = 0; mask < (1 << n); ++mask) {\n        map<char, bool> vars;\n        for (int i = 0; i < n; ++i) {\n            vars[variables[i]] = (mask & (1 << i)) != 0;\n        }\n        bool left_val = evaluate(left_expr, vars);\n        bool right_val = evaluate(right_expr, vars);\n        if (left_val != right_val) {\n            return false;\n        }\n    }\n    return true;\n}\n\nint main() {\n    string eq;\n    while (getline(cin, eq)) {\n        if (eq.empty()) continue;\n        cout << (is_identity(eq) ? \"YES\" : \"NO\") << endl;\n    }\n    return 0;\n}",
    "timestamp": "2025-08-05 21:29:36"
  },
  {
    "model": "deepseek-v3",
    "prompt_type": "zero_shot",
    "language": "Java",
    "code": "import java.util.*;\n\npublic class IdentityChecker {\n    private static boolean evaluate(String expr, boolean[] vars) {\n        Stack<Boolean> stack = new Stack<>();\n        for (int i = expr.length() - 1; i >= 0; i--) {\n            char c = expr.charAt(i);\n            if (c == ' ') continue;\n            if (c == 'T') stack.push(true);\n            else if (c == 'F') stack.push(false);\n            else if (c >= 'a' && c <= 'k') stack.push(vars[c - 'a']);\n            else if (c == 'N') {\n                boolean a = stack.pop();\n                stack.push(!a);\n            } else {\n                boolean a = stack.pop();\n                boolean b = stack.pop();\n                switch (c) {\n                    case 'A': stack.push(a && b); break;\n                    case 'R': stack.push(a || b); break;\n                    case 'I': stack.push(!a || b); break;\n                }\n            }\n        }\n        return stack.pop();\n    }\n\n    private static boolean isIdentity(String expr) {\n        int varCount = 0;\n        Set<Character> vars = new HashSet<>();\n        for (char c : expr.toCharArray()) {\n            if (c >= 'a' && c <= 'k') vars.add(c);\n        }\n        varCount = vars.size();\n        int totalCombinations = 1 << varCount;\n        List<Character> varList = new ArrayList<>(vars);\n        for (int i = 0; i < totalCombinations; i++) {\n            boolean[] values = new boolean[11]; // a-k\n            for (int j = 0; j < varCount; j++) {\n                values[varList.get(j) - 'a'] = (i & (1 << j)) != 0;\n            }\n            if (!evaluate(expr, values)) {\n                return false;\n            }\n        }\n        return true;\n    }\n\n    public static void main(String[] args) {\n        Scanner scanner = new Scanner(System.in);\n        while (scanner.hasNextLine()) {\n            String line = scanner.nextLine().trim();\n            if (line.isEmpty()) continue;\n            System.out.println(isIdentity(line) ? \"YES\" : \"NO\");\n        }\n    }\n}",
    "timestamp": "2025-08-05 21:29:55"
  },
  {
    "model": "claude-3-5-haiku-20241022",
    "prompt_type": "zero_shot",
    "language": "Java",
    "code": "import java.util.*;\n\npublic class LogicalIdentity {\n    public static void main(String[] args) {\n        Scanner scanner = new Scanner(System.in);\n        \n        while (scanner.hasNextLine()) {\n            String equation = scanner.nextLine().trim();\n            if (equation.isEmpty()) break;\n            \n            System.out.println(isIdentity(equation) ? \"YES\" : \"NO\");\n        }\n        \n        scanner.close();\n    }\n    \n    static boolean isIdentity(String equation) {\n        List<String> variables = extractVariables(equation);\n        \n        for (int config = 0; config < (1 << variables.size()); config++) {\n            Map<String, Boolean> assignment = generateAssignment(variables, config);\n            if (!evaluateExpression(equation, assignment)) {\n                return false;\n            }\n        }\n        \n        return true;\n    }\n    \n    static List<String> extractVariables(String equation) {\n        Set<String> variables = new HashSet<>();\n        for (char c : equation.toCharArray()) {\n            if (c >= 'a' && c <= 'k') {\n                variables.add(String.valueOf(c));\n            }\n        }\n        return new ArrayList<>(variables);\n    }\n    \n    static Map<String, Boolean> generateAssignment(List<String> variables, int config) {\n        Map<String, Boolean> assignment = new HashMap<>();\n        for (int i = 0; i < variables.size(); i++) {\n            assignment.put(variables.get(i), (config & (1 << i)) != 0);\n        }\n        return assignment;\n    }\n    \n    static boolean evaluateExpression(String equation, Map<String, Boolean> assignment) {\n        return evaluate(parseExpression(equation), assignment);\n    }\n    \n    static Node parseExpression(String equation) {\n        return parseImp(equation);\n    }\n    \n    static Node parseImp(String equation) {\n        Node left = parseOr(equation);\n        if (equation.contains(\"->\")) {\n            String[] parts = equation.split(\"->\", 2);\n            Node right = parseImp(parts[1]);\n            return new ImpNode(left, right);\n        }\n        return left;\n    }\n    \n    static Node parseOr(String equation) {\n        Node left = parseAnd(equation);\n        if (equation.contains(\"|\")) {\n            String[] parts = equation.split(\"\\\\|\", 2);\n            Node right = parseOr(parts[1]);\n            return new OrNode(left, right);\n        }\n        return left;\n    }\n    \n    static Node parseAnd(String equation) {\n        Node left = parseNot(equation);\n        if (equation.contains(\"&\")) {\n            String[] parts = equation.split(\"&\", 2);\n            Node right = parseAnd(parts[1]);\n            return new AndNode(left, right);\n        }\n        return left;\n    }\n    \n    static Node parseNot(String equation) {\n        if (equation.startsWith(\"!\")) {\n            return new NotNode(parseNot(equation.substring(1)));\n        }\n        return parsePrimary(equation);\n    }\n    \n    static Node parsePrimary(String equation) {\n        equation = equation.trim();\n        if (equation.equals(\"T\")) return new ConstantNode(true);\n        if (equation.equals(\"F\")) return new ConstantNode(false);\n        if (equation.length() == 1 && equation.charAt(0) >= 'a' && equation.charAt(0) <= 'k') {\n            return new VariableNode(equation);\n        }\n        \n        if (equation.startsWith(\"(\") && equation.endsWith(\")\")) {\n            return parseExpression(equation.substring(1, equation.length() - 1));\n        }\n        \n        throw new IllegalArgumentException(\"Invalid expression: \" + equation);\n    }\n    \n    static boolean evaluate(Node node, Map<String, Boolean> assignment) {\n        return node.evaluate(assignment);\n    }\n    \n    interface Node {\n        boolean evaluate(Map<String, Boolean> assignment);\n    }\n    \n    static class ConstantNode implements Node {\n        private final boolean value;\n        \n        ConstantNode(boolean value) {\n            this.value = value;\n        }\n        \n        public boolean evaluate(Map<String, Boolean> assignment) {\n            return value;\n        }\n    }\n    \n    static class VariableNode implements Node {\n        private final String name;\n        \n        VariableNode(String name) {\n            this.name = name;\n        }\n        \n        public boolean evaluate(Map<String, Boolean> assignment) {\n            return assignment.get(name);\n        }\n    }\n    \n    static class NotNode implements Node {\n        private final Node child;\n        \n        NotNode(Node child) {\n            this.child = child;\n        }\n        \n        public boolean evaluate(Map<String, Boolean> assignment) {\n            return !child.evaluate(assignment);\n        }\n    }\n    \n    static class AndNode implements Node {\n        private final Node left;\n        private final Node right;\n        \n        AndNode(Node left, Node right) {\n            this.left = left;\n            this.right = right;\n        }\n        \n        public boolean evaluate(Map<String, Boolean> assignment) {\n            return left.evaluate(assignment) && right.evaluate(assignment);\n        }\n    }\n    \n    static class OrNode implements Node {\n        private final Node left;\n        private final Node right;\n        \n        OrNode(Node left, Node right) {\n            this.left = left;\n            this.right = right;\n        }\n        \n        public boolean evaluate(Map<String, Boolean> assignment) {\n            return left.evaluate(assignment) || right.evaluate(assignment);\n        }\n    }\n    \n    static class ImpNode implements Node {\n        private final Node left;\n        private final Node right;\n        \n        ImpNode(Node left, Node right) {\n            this.left = left;\n            this.right = right;\n        }\n        \n        public boolean evaluate(Map<String, Boolean> assignment) {\n            return !left.evaluate(assignment) || right.evaluate(assignment);\n        }\n    }\n}",
    "timestamp": "2025-08-05 21:30:13"
  },
  {
    "model": "claude-3-5-haiku-20241022",
    "prompt_type": "zero_shot",
    "language": "C",
    "code": "#include <stdio.h>\n#include <string.h>\n#include <stdbool.h>\n\nbool evaluate(char* expr, bool values[11]) {\n    int len = strlen(expr);\n    bool stack[100];\n    int top = -1;\n\n    for (int i = 0; i < len; i++) {\n        if (expr[i] >= 'a' && expr[i] <= 'k') {\n            stack[++top] = values[expr[i] - 'a'];\n        } else if (expr[i] == 'T') {\n            stack[++top] = true;\n        } else if (expr[i] == 'F') {\n            stack[++top] = false;\n        } else if (expr[i] == '!') {\n            bool a = stack[top--];\n            stack[++top] = !a;\n        } else if (expr[i] == '&') {\n            bool b = stack[top--];\n            bool a = stack[top--];\n            stack[++top] = a && b;\n        } else if (expr[i] == '|') {\n            bool b = stack[top--];\n            bool a = stack[top--];\n            stack[++top] = a || b;\n        } else if (expr[i] == '>') {\n            bool b = stack[top--];\n            bool a = stack[top--];\n            stack[++top] = !a || b;\n        }\n    }\n    return stack[top];\n}\n\nint main() {\n    char expr[1000];\n    \n    while (scanf(\"%s\", expr) != EOF) {\n        bool isIdentity = true;\n        \n        for (int i = 0; i < (1 << 11); i++) {\n            bool values[11];\n            for (int j = 0; j < 11; j++) {\n                values[j] = (i & (1 << j)) != 0;\n            }\n            \n            if (!evaluate(expr, values)) {\n                isIdentity = false;\n                break;\n            }\n        }\n        \n        printf(\"%s\\n\", isIdentity ? \"YES\" : \"NO\");\n    }\n    \n    return 0;\n}",
    "timestamp": "2025-08-05 21:30:20"
  },
  {
    "model": "claude-3-5-haiku-20241022",
    "prompt_type": "zero_shot",
    "language": "C++",
    "code": "#include <iostream>\n#include <string>\n#include <vector>\n#include <cmath>\n\nusing namespace std;\n\nbool evalLogic(char op, bool a, bool b = true) {\n    switch (op) {\n        case '!': return !a;\n        case '&': return a && b;\n        case '|': return a || b;\n        case '>': return !a || b;\n        default: return a;\n    }\n}\n\nbool evaluate(string& expr, vector<bool>& values) {\n    int varIndex[256] = {0};\n    for (char c = 'a'; c <= 'k'; c++) \n        varIndex[c] = -1;\n    \n    int idx = 0;\n    for (char c = 'a'; c <= 'k'; c++) {\n        if (expr.find(c) != string::npos) {\n            varIndex[c] = idx++;\n        }\n    }\n    \n    bool result = false;\n    int vars = idx;\n    \n    for (int i = 0; i < (1 << vars); i++) {\n        vector<bool> current(vars);\n        for (int j = 0; j < vars; j++) \n            current[j] = (i & (1 << j)) > 0;\n        \n        bool localResult = true;\n        string temp = expr;\n        \n        // Replace variables\n        for (char c = 'a'; c <= 'k'; c++) {\n            if (varIndex[c] != -1) {\n                string var(1, c);\n                size_t pos = temp.find(var);\n                while (pos != string::npos) {\n                    temp.replace(pos, 1, current[varIndex[c]] ? \"T\" : \"F\");\n                    pos = temp.find(var);\n                }\n            }\n        }\n        \n        // Evaluate NOT first\n        for (size_t j = 0; j < temp.length(); j++) {\n            if (temp[j] == '!') {\n                bool val = (temp[j+1] == 'T');\n                temp.replace(j, 2, val ? \"F\" : \"T\");\n            }\n        }\n        \n        // Evaluate AND\n        for (size_t j = 0; j < temp.length(); j++) {\n            if (temp[j] == '&') {\n                bool left = (temp[j-1] == 'T');\n                bool right = (temp[j+1] == 'T');\n                temp.replace(j-1, 3, (left && right) ? \"T\" : \"F\");\n                j -= 2;\n            }\n        }\n        \n        // Evaluate OR\n        for (size_t j = 0; j < temp.length(); j++) {\n            if (temp[j] == '|') {\n                bool left = (temp[j-1] == 'T');\n                bool right = (temp[j+1] == 'T');\n                temp.replace(j-1, 3, (left || right) ? \"T\" : \"F\");\n                j -= 2;\n            }\n        }\n        \n        // Evaluate IMP\n        for (size_t j = 0; j < temp.length(); j++) {\n            if (temp[j] == '>') {\n                bool left = (temp[j-1] == 'T');\n                bool right = (temp[j+1] == 'T');\n                temp.replace(j-1, 3, (!left || right) ? \"T\" : \"F\");\n                j -= 2;\n            }\n        }\n        \n        localResult = (temp == \"T\");\n        \n        if (!localResult) \n            return false;\n    }\n    \n    return true;\n}\n\nint main() {\n    int datasets;\n    cin >> datasets;\n    cin.ignore();\n    \n    while (datasets--) {\n        string expr;\n        getline(cin, expr);\n        \n        vector<bool> values;\n        cout << (evaluate(expr, values) ? \"YES\" : \"NO\") << endl;\n    }\n    \n    return 0;\n}",
    "timestamp": "2025-08-05 21:30:34"
  },
  {
    "model": "gpt-4o",
    "prompt_type": "zero_shot",
    "language": "python",
    "code": "import itertools\n\ndef eval_imp(a, b):\n    return not a or b\n\ndef eval_equation(eqn, variables):\n    for var_combination in itertools.product([False, True], repeat=len(variables)):\n        var_map = dict(zip(variables, var_combination))\n        eval_eqn = []\n        for token in eqn:\n            if token in 'TF':\n                eval_eqn.append(token == 'T')\n            elif token in variables:\n                eval_eqn.append(var_map[token])\n            elif token == 'NOT':\n                eval_eqn.append(not eval_eqn.pop())\n            elif token == 'AND':\n                b = eval_eqn.pop()\n                a = eval_eqn.pop()\n                eval_eqn.append(a and b)\n            elif token == 'OR':\n                b = eval_eqn.pop()\n                a = eval_eqn.pop()\n                eval_eqn.append(a or b)\n            elif token == 'IMP':\n                b = eval_eqn.pop()\n                a = eval_eqn.pop()\n                eval_eqn.append(eval_imp(a, b))\n        if not eval_eqn[0]:\n            return False\n    return True\n\ndef is_identity(equation):\n    variables = set(c for c in equation if c.isalpha() and c != 'T' and c != 'F')\n    eqn_list = equation.split()\n    return eval_equation(eqn_list, variables)\n\ndef process_datasets(equations):\n    results = []\n    for eqn in equations:\n        results.append('YES' if is_identity(eqn) else 'NO')\n    return results\n\nequations = [\n    \"a IMP a\",\n    \"a AND NOT a\",\n    \"a OR NOT a\",\n    \"T IMP F\"\n]\n\nresults = process_datasets(equations)\nprint(\"\\n\".join(results))",
    "timestamp": "2025-08-13 06:41:38"
  },
  {
    "model": "gpt-4o",
    "prompt_type": "zero_shot",
    "language": "java",
    "code": "import java.util.Scanner;\n\npublic class LogicalIdentityChecker {\n\n    public static void main(String[] args) {\n        Scanner scanner = new Scanner(System.in);\n        while (scanner.hasNextLine()) {\n            String equation = scanner.nextLine().trim();\n            if (isIdentity(equation)) {\n                System.out.println(\"YES\");\n            } else {\n                System.out.println(\"NO\");\n            }\n        }\n        scanner.close();\n    }\n\n    private static boolean isIdentity(String equation) {\n        for (int i = 0; i < (1 << 11); i++) {\n            if (!evaluate(equation, i)) {\n                return false;\n            }\n        }\n        return true;\n    }\n\n    private static boolean evaluate(String equation, int valueSet) {\n        return evaluateExpression(equation, valueSet);\n    }\n\n    private static boolean evaluateExpression(String expression, int valueSet) {\n        expression = expression.replace(\" \", \"\");\n        if (expression.equals(\"T\")) return true;\n        if (expression.equals(\"F\")) return false;\n\n        char variable = expression.charAt(0);\n        if ('a' <= variable && variable <= 'k') {\n            return ((valueSet & (1 << (variable - 'a'))) != 0);\n        }\n\n        if (expression.startsWith(\"NOT\")) {\n            return !evaluateExpression(expression.substring(3), valueSet);\n        }\n\n        int pos = findMainOperator(expression);\n        String left = expression.substring(1, pos);\n        String right = expression.substring(pos + 1, expression.length() - 1);\n\n        switch (expression.charAt(pos)) {\n            case '&':\n                return evaluateExpression(left, valueSet) && evaluateExpression(right, valueSet);\n            case '|':\n                return evaluateExpression(left, valueSet) || evaluateExpression(right, valueSet);\n            case '>':\n                return !evaluateExpression(left, valueSet) || evaluateExpression(right, valueSet);\n        }\n        return false;\n    }\n\n    private static int findMainOperator(String expression) {\n        int level = 0;\n        for (int i = 0; i < expression.length(); i++) {\n            char c = expression.charAt(i);\n            if (c == '(') level++;\n            else if (c == ')') level--;\n            else if (level == 1 && (c == '&' || c == '|' || c == '>')) return i;\n        }\n        return -1;\n    }\n}",
    "timestamp": "2025-08-13 06:41:42"
  },
  {
    "model": "gpt-4o",
    "prompt_type": "zero_shot",
    "language": "c",
    "code": "#include <stdio.h>\n#include <string.h>\n#include <stdbool.h>\n\n#define VAR_COUNT 11\n#define TRUE 1\n#define FALSE 0\n\nint var_vals[VAR_COUNT];\n\n// Define operation functions\nint NOT(int a) { return !a; }\nint AND(int a, int b) { return a && b; }\nint OR(int a, int b) { return a || b; }\nint IMP(int a, int b) { return !a || b; }\n\nint evaluate(char *eq, int len) {\n    int stack[256], top = -1;\n\n    for (int i = 0; i < len; i++) {\n        char c = eq[i];\n        if (c >= 'a' && c <= 'k') {\n            stack[++top] = var_vals[c - 'a'];\n        } else if (c == 'T') {\n            stack[++top] = TRUE;\n        } else if (c == 'F') {\n            stack[++top] = FALSE;\n        } else if (c == '~') {\n            stack[top] = NOT(stack[top]);\n        } else if (strchr(\"&|->\", c)) {\n            int b = stack[top--];\n            int a = stack[top--];\n            if (c == '&') stack[++top] = AND(a, b);\n            if (c == '|') stack[++top] = OR(a, b);\n            if (c == '-') { // '->' implication\n                if (i + 1 < len && eq[i + 1] == '>') {\n                    stack[++top] = IMP(a, b);\n                    i++; // skip '>'\n                }\n            }\n        }\n    }\n    return stack[top];\n}\n\nbool is_identity(char *eq) {\n    int len = strlen(eq);\n    int limit = 1 << VAR_COUNT;\n\n    for (int mask = 0; mask < limit; mask++) {\n        for (int v = 0; v < VAR_COUNT; v++) {\n            var_vals[v] = (mask >> v) & 1;\n        }\n        if (!evaluate(eq, len)) return false;\n    }\n    return true;\n}\n\nint main() {\n    char equation[1024];\n    while (scanf(\"%s\", equation) != EOF) {\n        if (is_identity(equation)) {\n            printf(\"YES\\n\");\n        } else {\n            printf(\"NO\\n\");\n        }\n    }\n    return 0;\n}",
    "timestamp": "2025-08-13 06:41:48"
  },
  {
    "model": "claude-3-5-haiku-20241022",
    "prompt_type": "zero_shot",
    "language": "python",
    "code": "def evaluate_expr(expr, var_values):\n    def eval_term(term):\n        if term in ['T', 'F']:\n            return term == 'T'\n        if term.startswith('!'):\n            return not eval_term(term[1:])\n        if term in var_values:\n            return var_values[term]\n        return None\n\n    def eval_binary(left, op, right):\n        if op == '&':\n            return left and right\n        if op == '|':\n            return left or right\n        if op == '->':\n            return (not left) or right\n\n    def parse_expr(expr):\n        stack = []\n        i = 0\n        while i < len(expr):\n            if expr[i] in ['T', 'F'] or (expr[i] >= 'a' and expr[i] <= 'k'):\n                stack.append(expr[i])\n            elif expr[i] == '!':\n                top = stack.pop()\n                stack.append(f'!{top}')\n            elif expr[i] in ['&', '|', '->']:\n                right = stack.pop()\n                left = stack.pop()\n                stack.append(f'({left} {expr[i]} {right})')\n            i += 1\n        return stack[0]\n\n    def generate_vars():\n        vars_in_expr = set(c for c in expr if c >= 'a' and c <= 'k')\n        return vars_in_expr\n\n    vars = generate_vars()\n    \n    for i in range(1 << len(vars)):\n        var_values = {}\n        for j, var in enumerate(sorted(vars)):\n            var_values[var] = bool((i >> j) & 1)\n        \n        def eval_full(expr):\n            try:\n                result = eval(parse_expr(expr), {}, {**var_values, 'T': True, 'F': False})\n                return result\n            except:\n                return None\n\n        if eval_full(expr) is False:\n            return 'NO'\n    \n    return 'YES'\n\ndef main():\n    while True:\n        try:\n            equation = input().strip()\n            if not equation:\n                break\n            print(evaluate_expr(equation))\n        except EOFError:\n            break\n\nif __name__ == \"__main__\":\n    main()",
    "timestamp": "2025-08-13 06:42:00"
  },
  {
    "model": "deepseek-v3",
    "prompt_type": "zero_shot",
    "language": "python",
    "code": "import sys\n\ndef evaluate(expr, values):\n    stack = []\n    for token in expr.split():\n        if token in values:\n            stack.append(values[token])\n        elif token == 'T':\n            stack.append(True)\n        elif token == 'F':\n            stack.append(False)\n        elif token == 'NOT':\n            a = stack.pop()\n            stack.append(not a)\n        elif token == 'AND':\n            a = stack.pop()\n            b = stack.pop()\n            stack.append(a and b)\n        elif token == 'OR':\n            a = stack.pop()\n            b = stack.pop()\n            stack.append(a or b)\n        elif token == 'IMP':\n            a = stack.pop()\n            b = stack.pop()\n            stack.append((not b) or a)\n    return stack[0]\n\ndef is_identity(equation):\n    parts = equation.split('=')\n    left_expr = parts[0].strip()\n    right_expr = parts[1].strip()\n    \n    variables = set()\n    for token in left_expr.split() + right_expr.split():\n        if token.islower() and token >= 'a' and token <= 'k':\n            variables.add(token)\n    variables = sorted(variables)\n    \n    n = len(variables)\n    for mask in range(1 << n):\n        values = {}\n        for i in range(n):\n            values[variables[i]] = bool(mask & (1 << i))\n        left_val = evaluate(left_expr, values)\n        right_val = evaluate(right_expr, values)\n        if left_val != right_val:\n            return False\n    return True\n\ndef main():\n    for line in sys.stdin:\n        line = line.strip()\n        if not line:\n            continue\n        if is_identity(line):\n            print(\"YES\")\n        else:\n            print(\"NO\")\n\nif __name__ == \"__main__\":\n    main()",
    "timestamp": "2025-08-13 06:42:18"
  },
  {
    "model": "gpt-4o",
    "prompt_type": "zero_shot",
    "language": "c++",
    "code": "#include <iostream>\n#include <string>\n#include <vector>\n#include <unordered_map>\n#include <functional>\n\nusing namespace std;\n\n// Evaluate the expression depending on the operators\nbool solve(const string& expr, const vector<bool>& values) {\n    vector<bool> stack;\n    for (char c : expr) {\n        if (c >= 'a' && c <= 'k') {\n            stack.push_back(values[c - 'a']);\n        } else if (c == 'T') {\n            stack.push_back(true);\n        } else if (c == 'F') {\n            stack.push_back(false);\n        } else if (c == 'N') { // NOT operation\n            bool v = stack.back(); stack.pop_back();\n            stack.push_back(!v);\n        } else if (c == 'A') { // AND operation\n            bool v1 = stack.back(); stack.pop_back();\n            bool v2 = stack.back(); stack.pop_back();\n            stack.push_back(v1 && v2);\n        } else if (c == 'O') { // OR operation\n            bool v1 = stack.back(); stack.pop_back();\n            bool v2 = stack.back(); stack.pop_back();\n            stack.push_back(v1 || v2);\n        } else if (c == 'I') { // IMP operation\n            bool v1 = stack.back(); stack.pop_back();\n            bool v2 = stack.back(); stack.pop_back();\n            stack.push_back(!v2 || v1);\n        }\n    }\n    return stack.back();\n}\n\n// Check if the given expression is an identity\nbool isIdentity(const string& expr) {\n    int numVariables = 11; // a to k\n    int totalCombinations = 1 << numVariables; // 2^11 combinations\n\n    for (int mask = 0; mask < totalCombinations; ++mask) {\n        vector<bool> values(numVariables);\n        for (int i = 0; i < numVariables; ++i) {\n            values[i] = (mask >> i) & 1;\n        }\n        if (!solve(expr, values)) {\n            return false; // If any evaluation is false, it's not an identity\n        }\n    }\n    return true;\n}\n\nint main() {\n    string equation;\n    while (cin >> equation) {\n        if (isIdentity(equation)) {\n            cout << \"YES\" << endl;\n        } else {\n            cout << \"NO\" << endl;\n        }\n    }\n    return 0;\n}",
    "timestamp": "2025-08-13 11:33:40"
  }
]