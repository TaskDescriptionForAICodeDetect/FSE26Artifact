[
  {
    "model": "claude-3-5-haiku-20241022",
    "prompt_type": "zero_shot",
    "language": "C",
    "code": "#include <stdio.h>\n#include <string.h>\n#include <limits.h>\n\n#define MAX_N 100\n#define MAX_M 100\n\nint solve(int N, int M, char* S, int* moves) {\n    int dp[MAX_N + 1];\n    int prev[MAX_N + 1];\n    \n    for (int i = 0; i <= N; i++) {\n        dp[i] = INT_MAX;\n        prev[i] = -1;\n    }\n    \n    dp[0] = 0;\n    \n    for (int s = 0; s < N; s++) {\n        if (dp[s] == INT_MAX) continue;\n        \n        for (int x = 1; x <= M; x++) {\n            int next = s + x;\n            \n            if (next > N) break;\n            \n            if (S[next] == '1') continue;\n            \n            if (dp[next] > dp[s] + 1) {\n                dp[next] = dp[s] + 1;\n                prev[next] = x;\n            }\n            else if (dp[next] == dp[s] + 1 && x < prev[next]) {\n                prev[next] = x;\n            }\n        }\n    }\n    \n    if (dp[N] == INT_MAX) return -1;\n    \n    int steps = dp[N];\n    int current = N;\n    int idx = steps - 1;\n    \n    while (current > 0) {\n        moves[idx--] = prev[current];\n        current -= prev[current];\n    }\n    \n    return steps;\n}\n\nint main() {\n    int N, M;\n    char S[MAX_N + 1];\n    int moves[MAX_N];\n    \n    scanf(\"%d %d %s\", &N, &M, S);\n    \n    int result = solve(N, M, S, moves);\n    \n    if (result == -1) {\n        printf(\"-1\\n\");\n    }\n    else {\n        printf(\"%d\\n\", result);\n        for (int i = 0; i < result; i++) {\n            printf(\"%d \", moves[i]);\n        }\n        printf(\"\\n\");\n    }\n    \n    return 0;\n}",
    "timestamp": "2025-08-05 22:40:49"
  },
  {
    "model": "deepseek-v3",
    "prompt_type": "zero_shot",
    "language": "C",
    "code": "#include <stdio.h>\n#include <stdlib.h>\n#include <string.h>\n#include <limits.h>\n\ntypedef struct {\n    int pos;\n    int steps;\n    int prev;\n} State;\n\nint main() {\n    int N, M;\n    scanf(\"%d %d\", &N, &M);\n    char S[N + 2];\n    scanf(\"%s\", S);\n\n    int *dist = (int *)malloc((N + 1) * sizeof(int));\n    int *prev = (int *)malloc((N + 1) * sizeof(int));\n    for (int i = 0; i <= N; i++) {\n        dist[i] = -1;\n        prev[i] = -1;\n    }\n\n    State *queue = (State *)malloc((N + 1) * sizeof(State));\n    int front = 0, rear = 0;\n    queue[rear++] = (State){0, 0, -1};\n    dist[0] = 0;\n\n    int found = 0;\n    while (front < rear && !found) {\n        State current = queue[front++];\n        int s = current.pos;\n        if (s == N) {\n            found = 1;\n            break;\n        }\n        for (int x = M; x >= 1; x--) {\n            int next = s + x;\n            if (next <= N && dist[next] == -1 && S[next] != '1') {\n                dist[next] = dist[s] + 1;\n                prev[next] = s;\n                queue[rear++] = (State){next, dist[next], s};\n                if (next == N) {\n                    found = 1;\n                    break;\n                }\n            }\n        }\n    }\n\n    if (dist[N] == -1) {\n        printf(\"-1\\n\");\n    } else {\n        int *path = (int *)malloc((dist[N] + 1) * sizeof(int));\n        int current = N;\n        int idx = dist[N];\n        while (current != -1) {\n            path[idx--] = current;\n            current = prev[current];\n        }\n        for (int i = 0; i < dist[N]; i++) {\n            printf(\"%d \", path[i + 1] - path[i]);\n        }\n        printf(\"\\n\");\n        free(path);\n    }\n\n    free(dist);\n    free(prev);\n    free(queue);\n    return 0;\n}",
    "timestamp": "2025-08-05 22:41:09"
  },
  {
    "model": "deepseek-v3",
    "prompt_type": "zero_shot",
    "language": "C++",
    "code": "#include <iostream>\n#include <vector>\n#include <queue>\n#include <algorithm>\n#include <climits>\nusing namespace std;\n\nint main() {\n    int N, M;\n    cin >> N >> M;\n    string S;\n    cin >> S;\n\n    vector<int> dp(N + 1, INT_MAX);\n    dp[N] = 0;\n    queue<int> q;\n    q.push(N);\n    vector<int> next(N + 1, -1);\n\n    while (!q.empty()) {\n        int u = q.front();\n        q.pop();\n        for (int x = 1; x <= M; ++x) {\n            int v = u - x;\n            if (v >= 0 && S[v] == '0' && dp[v] > dp[u] + 1) {\n                dp[v] = dp[u] + 1;\n                next[v] = u;\n                q.push(v);\n            }\n        }\n    }\n\n    if (dp[0] == INT_MAX) {\n        cout << -1 << endl;\n        return 0;\n    }\n\n    vector<int> path;\n    int current = 0;\n    while (current != N) {\n        int prev = next[current];\n        path.push_back(prev - current);\n        current = prev;\n    }\n\n    for (int i = 0; i < path.size(); ++i) {\n        if (i > 0) cout << \" \";\n        cout << path[i];\n    }\n    cout << endl;\n\n    return 0;\n}",
    "timestamp": "2025-08-05 22:41:24"
  },
  {
    "model": "deepseek-v3",
    "prompt_type": "zero_shot",
    "language": "Java",
    "code": "import java.util.*;\n\npublic class Main {\n    public static void main(String[] args) {\n        Scanner scanner = new Scanner(System.in);\n        int N = scanner.nextInt();\n        int M = scanner.nextInt();\n        String S = scanner.next();\n        scanner.close();\n\n        List<Integer> safe = new ArrayList<>();\n        safe.add(N);\n        for (int i = N - 1; i >= 0; i--) {\n            if (S.charAt(i) == '0') {\n                safe.add(i);\n            }\n        }\n        Collections.reverse(safe);\n\n        List<Integer> result = new ArrayList<>();\n        int current = 0;\n        int lastSafe = 0;\n        boolean possible = true;\n\n        while (current < N) {\n            int next = -1;\n            for (int m = Math.min(M, N - current); m >= 1; m--) {\n                int candidate = current + m;\n                if (candidate <= N && S.charAt(candidate) == '0') {\n                    next = candidate;\n                    break;\n                }\n            }\n            if (next == -1) {\n                possible = false;\n                break;\n            }\n            result.add(next - current);\n            current = next;\n        }\n\n        if (!possible) {\n            System.out.println(-1);\n        } else {\n            StringBuilder sb = new StringBuilder();\n            for (int num : result) {\n                sb.append(num).append(\" \");\n            }\n            System.out.println(sb.toString().trim());\n        }\n    }\n}",
    "timestamp": "2025-08-05 22:41:40"
  },
  {
    "model": "claude-3-5-haiku-20241022",
    "prompt_type": "zero_shot",
    "language": "Java",
    "code": "import java.util.*;\nimport java.io.*;\n\npublic class Sugoroku {\n    public static void main(String[] args) throws IOException {\n        BufferedReader br = new BufferedReader(new InputStreamReader(System.in));\n        StringTokenizer st = new StringTokenizer(br.readLine());\n        \n        int N = Integer.parseInt(st.nextToken());\n        int M = Integer.parseInt(st.nextToken());\n        String S = br.readLine();\n        \n        int[] gameOverSquares = new int[N + 1];\n        for (int i = 0; i < N + 1; i++) {\n            gameOverSquares[i] = S.charAt(i) - '0';\n        }\n        \n        int[] dp = new int[N + 1];\n        Arrays.fill(dp, Integer.MAX_VALUE);\n        dp[0] = 0;\n        \n        for (int i = 0; i < N; i++) {\n            if (dp[i] == Integer.MAX_VALUE) continue;\n            \n            for (int j = 1; j <= M; j++) {\n                int nextSquare = i + j;\n                \n                if (nextSquare > N) break;\n                \n                if (gameOverSquares[nextSquare] == 1) continue;\n                \n                dp[nextSquare] = Math.min(dp[nextSquare], dp[i] + 1);\n            }\n        }\n        \n        int result = dp[N] == Integer.MAX_VALUE ? -1 : dp[N];\n        System.out.println(result);\n    }\n}",
    "timestamp": "2025-08-05 22:41:46"
  },
  {
    "model": "claude-3-5-haiku-20241022",
    "prompt_type": "zero_shot",
    "language": "C++",
    "code": "#include <iostream>\n#include <vector>\n#include <queue>\n#include <string>\n#include <algorithm>\n#include <climits>\n\nusing namespace std;\n\nint main() {\n    int N, M;\n    string S;\n    cin >> N >> M >> S;\n\n    vector<int> dp(N + 1, INT_MAX);\n    vector<int> prev(N + 1, -1);\n    dp[0] = 0;\n\n    for (int s = 0; s < N; s++) {\n        if (dp[s] == INT_MAX) continue;\n\n        for (int x = 1; x <= M; x++) {\n            int next = s + x;\n            if (next > N) break;\n\n            if (S[next] == '0' && dp[next] > dp[s] + 1) {\n                dp[next] = dp[s] + 1;\n                prev[next] = x;\n            }\n        }\n    }\n\n    if (dp[N] == INT_MAX) {\n        cout << -1 << endl;\n        return 0;\n    }\n\n    vector<int> moves;\n    int curr = N;\n    while (curr > 0) {\n        moves.push_back(prev[curr]);\n        curr -= prev[curr];\n    }\n    reverse(moves.begin(), moves.end());\n\n    cout << moves.size() << endl;\n    for (int move : moves) {\n        cout << move << \" \";\n    }\n    cout << endl;\n\n    return 0;\n}",
    "timestamp": "2025-08-05 22:41:52"
  },
  {
    "model": "gpt-4o",
    "prompt_type": "zero_shot",
    "language": "python",
    "code": "def sugoroku(n, m, s):\n    from collections import deque\n\n    # Initialize\n    GOAL = n\n    game_over = set(i for i, char in enumerate(s) if char == '1')\n    moves = []\n    \n    # BFS with early exit on first solution found\n    q = deque([(0, [])])  # start at 0 with an empty path\n    visited = set([0])\n\n    while q:\n        current_square, path = q.popleft()\n\n        if current_square == GOAL:\n            return path\n\n        # Explore moves\n        for move in range(1, m + 1):\n            next_square = current_square + move\n            if next_square <= GOAL and next_square not in visited and next_square not in game_over:\n                visited.add(next_square)\n                q.append((next_square, path + [move]))\n\n    return -1\n\n# Example Usage\nn, m = 4, 6\ns = \"01011\"  # string S of length N+1\nprint(sugoroku(n, m, s))  # Output: [1, 1, 2]",
    "timestamp": "2025-08-13 12:07:51"
  },
  {
    "model": "gpt-4o",
    "prompt_type": "zero_shot",
    "language": "java",
    "code": "import java.util.*;\n\npublic class Sugoroku {\n    public static void main(String[] args) {\n        Scanner sc = new Scanner(System.in);\n        int N = sc.nextInt();\n        int M = sc.nextInt();\n        sc.nextLine(); // Consume the newline left-over\n        String S = sc.nextLine();\n        \n        // Edge case: Start or end is a Game Over Square\n        if (S.charAt(0) == '1' || S.charAt(N) == '1') {\n            System.out.println(-1);\n            return;\n        }\n\n        int[] dp = new int[N + 1];\n        int[] prev = new int[N + 1];\n        Arrays.fill(dp, Integer.MAX_VALUE);\n        Arrays.fill(prev, -1);\n        \n        dp[0] = 0;\n        \n        for (int i = 0; i <= N; i++) {\n            if (dp[i] == Integer.MAX_VALUE || S.charAt(i) == '1') continue;\n            for (int roll = 1; roll <= M; roll++) {\n                int nextSquare = i + roll;\n                if (nextSquare > N || S.charAt(nextSquare) == '1') continue;\n                if (dp[i] + 1 < dp[nextSquare]) {\n                    dp[nextSquare] = dp[i] + 1;\n                    prev[nextSquare] = i;\n                }\n            }\n        }\n        \n        // If we can't even reach the last square\n        if (dp[N] == Integer.MAX_VALUE) {\n            System.out.println(-1);\n            return;\n        }\n        \n        // Backtrack to find the solution path\n        List<Integer> path = new ArrayList<>();\n        for (int i = N; i != 0; i = prev[i]) {\n            path.add(i - prev[i]);\n        }\n        Collections.reverse(path);\n        \n        // Print the result as space separated moves\n        for (int i = 0; i < path.size(); i++) {\n            System.out.print(path.get(i));\n            if (i != path.size() - 1) {\n                System.out.print(\" \");\n            }\n        }\n    }\n}",
    "timestamp": "2025-08-13 12:08:01"
  },
  {
    "model": "gpt-4o",
    "prompt_type": "zero_shot",
    "language": "c",
    "code": "#include <stdio.h>\n#include <string.h>\n\n#define MAXN 1000\n#define MAXM 1000\n\nint main() {\n    int N, M;\n    char S[MAXN + 1];\n    int dp[MAXN + 1], move[MAXN + 1];\n\n    scanf(\"%d %d\", &N, &M);\n    scanf(\"%s\", S);\n\n    memset(dp, -1, sizeof(dp));\n    dp[0] = 0;\n    \n    for (int i = 1; i <= N; i++) {\n        if (S[i] == '1') continue;\n        for (int j = 1; j <= M; j++) {\n            if (i - j >= 0 && dp[i - j] != -1) {\n                if (dp[i] == -1 || dp[i - j] + 1 < dp[i] || (dp[i - j] + 1 == dp[i] && j < move[i])) {\n                    dp[i] = dp[i - j] + 1;\n                    move[i] = j;\n                }\n            }\n        }\n    }\n\n    if (dp[N] == -1) {\n        printf(\"-1\\n\");\n        return 0;\n    }\n\n    int sequence[MAXN], idx = 0;\n    int current = N;\n    while (current > 0) {\n        sequence[idx++] = move[current];\n        current -= move[current];\n    }\n\n    for (int i = idx - 1; i >= 0; i--) {\n        printf(\"%d \", sequence[i]);\n    }\n    printf(\"\\n\");\n\n    return 0;\n}",
    "timestamp": "2025-08-13 12:08:05"
  },
  {
    "model": "gpt-4o",
    "prompt_type": "zero_shot",
    "language": "js",
    "code": "function findShortestPath(N, M, S) {\n    const dp = Array(N + 1).fill(Number.MAX_SAFE_INTEGER);\n    dp[0] = 0;\n    \n    for (let i = 0; i <= N; i++) {\n        if (S[i] === '1') continue;\n        for (let x = 1; x <= M; x++) {\n            if (i + x <= N && S[i + x] === '0') {\n                dp[i + x] = Math.min(dp[i + x], dp[i] + 1);\n            }\n        }\n    }\n\n    if (dp[N] === Number.MAX_SAFE_INTEGER) return -1;\n\n    const path = [];\n    let current = N;\n    while (current > 0) {\n        for (let x = 1; x <= M; x++) {\n            if (current - x >= 0 && S[current - x] === '0' && dp[current] === dp[current - x] + 1) {\n                path.push(x);\n                current -= x;\n                break;\n            }\n        }\n    }\n    \n    return path.reverse();\n}\n\n// Example usage:\nconsole.log(findShortestPath(5, 3, '000000')); // Output might vary based on the actual board configuration",
    "timestamp": "2025-08-13 12:08:08"
  },
  {
    "model": "claude-3-5-haiku-20241022",
    "prompt_type": "zero_shot",
    "language": "python",
    "code": "def solve_sugoroku(N, M, S):\n    # Initialize DP table and path tracking\n    dp = [float('inf')] * (N + 1)\n    next_move = [None] * (N + 1)\n    dp[0] = 0\n\n    # Dynamic programming to find minimum turns\n    for s in range(N):\n        if dp[s] == float('inf'):\n            continue\n        \n        for x in range(1, M + 1):\n            next_pos = s + x\n            \n            # Check if move is valid\n            if next_pos > N or S[next_pos] == '1':\n                continue\n            \n            # Update minimum turns and track best move\n            if dp[next_pos] > dp[s] + 1:\n                dp[next_pos] = dp[s] + 1\n                next_move[next_pos] = x\n\n    # Check if target reached\n    if dp[N] == float('inf'):\n        return -1\n\n    # Reconstruct winning path\n    path = []\n    curr = N\n    while curr > 0:\n        path.append(next_move[curr])\n        curr -= next_move[curr]\n    \n    path.reverse()\n    return path\n\n# Input parsing and function call\ndef main():\n    N, M = map(int, input().split())\n    S = input()\n    result = solve_sugoroku(N, M, S)\n    \n    if result == -1:\n        print(-1)\n    else:\n        print(len(result))\n        print(*result)\n\nif __name__ == \"__main__\":\n    main()",
    "timestamp": "2025-08-13 12:08:14"
  },
  {
    "model": "claude-3-5-haiku-20241022",
    "prompt_type": "zero_shot",
    "language": "js",
    "code": "function sugorokuGame(N, M, S) {\n    const dp = new Array(N + 1).fill(Infinity);\n    const prev = new Array(N + 1).fill(-1);\n    dp[0] = 0;\n\n    for (let s = 0; s < N; s++) {\n        if (dp[s] === Infinity) continue;\n        \n        for (let x = 1; x <= M; x++) {\n            const next = s + x;\n            if (next > N) break;\n            \n            if (S[next] === '0' && dp[s] + 1 <= dp[next]) {\n                if (dp[s] + 1 < dp[next] || x < prev[next]) {\n                    dp[next] = dp[s] + 1;\n                    prev[next] = x;\n                }\n            }\n        }\n    }\n\n    if (dp[N] === Infinity) return -1;\n\n    const path = [];\n    let current = N;\n    while (current > 0) {\n        path.unshift(prev[current]);\n        current -= prev[current];\n    }\n\n    return path;\n}",
    "timestamp": "2025-08-13 12:08:20"
  },
  {
    "model": "deepseek-v3",
    "prompt_type": "zero_shot",
    "language": "python",
    "code": "import sys\nfrom collections import deque\n\ndef solve():\n    N, M = map(int, sys.stdin.readline().split())\n    S = sys.stdin.readline().strip()\n    \n    # Preprocess the nearest non-1 positions to the right\n    nearest_non_1 = [N+1] * (N + 2)\n    for i in range(N, -1, -1):\n        if i == N:\n            nearest_non_1[i] = i\n        else:\n            if S[i] == '0':\n                nearest_non_1[i] = i\n            else:\n                nearest_non_1[i] = nearest_non_1[i + 1]\n    \n    # BFS setup\n    dist = [-1] * (N + 1)\n    prev = [-1] * (N + 1)\n    q = deque()\n    q.append(0)\n    dist[0] = 0\n    \n    found = False\n    while q:\n        s = q.popleft()\n        if s == N:\n            found = True\n            break\n        # The range is from min(M, N - s) down to 1 to prioritize lex order\n        max_step = min(M, N - s)\n        # Find the furthest reachable non-1 square within s+1 to s+max_step\n        furthest = nearest_non_1[s + 1]\n        furthest = min(s + max_step, furthest)\n        if furthest > s:\n            if dist[furthest] == -1:\n                dist[furthest] = dist[s] + 1\n                prev[furthest] = s\n                q.append(furthest)\n        # Also check steps from max_step down to 1 to cover all possibilities\n        # But BFS with deque and processing steps in order ensures minimal steps\n        # So we can break after the first valid step (since we process in order)\n    \n    if not found:\n        print(-1)\n        return\n    \n    # Reconstruct the path\n    path = []\n    current = N\n    while current != 0:\n        path.append(current - prev[current])\n        current = prev[current]\n    path.reverse()\n    print(' '.join(map(str, path)))\n\nsolve()",
    "timestamp": "2025-08-13 12:08:38"
  },
  {
    "model": "deepseek-v3",
    "prompt_type": "zero_shot",
    "language": "js",
    "code": "const solve = () => {\n    const fs = require('fs');\n    const input = fs.readFileSync('/dev/stdin', 'utf8').trim().split('\\n');\n    const [N, M] = input[0].split(' ').map(Number);\n    const S = input[1].trim();\n    \n    const gameOver = Array(N + 1).fill(false);\n    for (let i = 0; i <= N; i++) {\n        if (S[i] === '1') gameOver[i] = true;\n    }\n    \n    const dp = Array(N + 1).fill(Infinity);\n    dp[N] = 0;\n    const nextPos = Array(N + 1).fill(-1);\n    let left = N;\n    const q = [];\n    q.push(N);\n    \n    for (let i = N - 1; i >= 0; i--) {\n        if (gameOver[i]) continue;\n        while (left > i + M) {\n            left--;\n            if (!gameOver[left] && dp[left] !== Infinity) {\n                while (q.length > 0 && dp[q[q.length - 1]] >= dp[left]) {\n                    q.pop();\n                }\n                q.push(left);\n            }\n        }\n        while (q.length > 0 && q[0] > i + M) {\n            q.shift();\n        }\n        if (q.length === 0) {\n            dp[i] = Infinity;\n        } else {\n            dp[i] = dp[q[0]] + 1;\n            nextPos[i] = q[0];\n        }\n    }\n    \n    if (dp[0] === Infinity) {\n        console.log(-1);\n        return;\n    }\n    \n    const res = [];\n    let current = 0;\n    while (current < N) {\n        const next = nextPos[current];\n        res.push(next - current);\n        current = next;\n    }\n    console.log(res.join(' '));\n};\n\nsolve();",
    "timestamp": "2025-08-13 12:08:48"
  },
  {
    "model": "gpt-4o",
    "prompt_type": "zero_shot",
    "language": "c++",
    "code": "#include <iostream>\n#include <vector>\n#include <queue>\n#include <string>\n#include <tuple>\n\nusing namespace std;\n\nint main() {\n    int N, M;\n    cin >> N >> M;\n    string S;\n    cin >> S;\n\n    vector<int> dp(N + 1, -1);\n    vector<int> prev(N + 1, -1);\n    dp[0] = 0;\n\n    queue<int> q;\n    q.push(0);\n\n    while (!q.empty()) {\n        int current = q.front();\n        q.pop();\n\n        for (int step = 1; step <= M; ++step) {\n            int next = current + step;\n            if (next <= N && dp[next] == -1 && S[next] == '0') {\n                dp[next] = dp[current] + 1;\n                prev[next] = current;\n                q.push(next);\n            }\n        }\n    }\n\n    if (dp[N] == -1) {\n        cout << -1 << endl;\n        return 0;\n    }\n\n    vector<int> path;\n    int pos = N;\n    while (pos != 0) {\n        path.push_back(pos);\n        pos = prev[pos];\n    }\n    reverse(path.begin(), path.end());\n\n    for (size_t i = 1; i < path.size(); ++i) {\n        cout << path[i] - path[i - 1];\n        if (i != path.size() - 1) cout << \" \";\n    }\n    cout << endl;\n\n    return 0;\n}",
    "timestamp": "2025-08-13 14:33:16"
  }
]