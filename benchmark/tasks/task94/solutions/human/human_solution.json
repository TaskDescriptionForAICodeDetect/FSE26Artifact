[
  {
    "language": "C++",
    "code": "#include <iostream>\n#include <algorithm>\n#include <vector>\n#include <queue>\n#include <map>\nusing namespace std;\n#define rep(i,n) for(int i=0;i<n;i++)\nclass NODE{\npublic:\n\tvector<int> data;\n\tint depth;\n\tint e[2];\n\tNODE(int a[13],int d,int E[2]){\n\t\tdata.resize(13);\n\t\trep(i,13)data[i] = a[i];\n\t\tdepth = d;\n\t\trep(i,2)e[i] = E[i];\n\t}\n\tNODE(){\n\t\tdepth = 0;\n\t\tdata.resize(13);\n\t}\n};\n\nint di[13][10] = {\n\t{2,-1},\n\t{2,5,-1},\n\t{0,1,3,6,-1},\n\t{2,7,-1},\n\t{5,-1},\n\t{1,4,6,9,-1},\n\t{2,5,7,10,-1},\n\t{3,6,7,11,-1},\n\t{7},\n\t{5,10,-1},\n\t{6,9,11,12,-1},\n\t{7,10,-1},\n\t{10,-1}\n};\nint rx[] = {3,2,3,4,1,2,3,4,5,2,3,4,3};\nint ry[] = {1,2,2,2,3,3,3,3,3,4,4,4,5};\n\nint main(){\n\twhile(1){\n\t\tint ret = 21;\n\t\tNODE fst; int cnt = 0;\n\t\trep(i,13){\n\t\t\tif(cin >>fst.data[i] , fst.data[i] != -1){\n\t\t\t\tif(fst.data[i] == 0){\n\t\t\t\t\tfst.e[cnt] = i;\n\t\t\t\t\tcnt++;\n\t\t\t\t}\n\t\t\t}else{\n\t\t\t\treturn 0;\n\t\t\t}\n\t\t}\n\t\tmap< vector<int> , int > done;\n\t\t\n\t\tqueue<NODE> Q;\n\t\tQ.push(fst);\n\t\tdone[Q.front().data] = 0;\n\t\t\n\t\twhile(Q.size()){\n\t\t\tNODE q = Q.front(); Q.pop();\n\n\t\t\tint mndist = 0;\n\t\t\trep(i,13)mndist += abs(rx[q.data[i]]-rx[i]) + abs(ry[q.data[i]]-ry[i]);\n\t\t\t\n\t\t\tif(mndist + q.depth > 23)continue;\n\t\t\t\n\t\t\tif( q.data[0] == 0 && q.data[1] == 1 && q.data[2] == 2 && q.data[3] == 3 && q.data[4] == 4 && q.data[5] == 5 && q.data[6] == 6 && q.data[7] == 7 &&\n\t\t\t\t\tq.data[8] == 8 && q.data[9] == 9 && q.data[10]==10 && q.data[11]==11 && q.data[12]==0\n\t\t\t){\n\t\t\t\tcout << q.depth << endl;\n\t\t\t\tgoto jmp;\n\t\t\t}\n\n\t\t\trep(o,2){\n\t\t\t\tfor(int i=0;di[q.e[o]][i] != -1;i++){\n\t\t\t\t\tNODE next = q;\n\t\t\t\t\tnext.e[o] = next.data[di[q.e[o]][i]];\n\t\t\t\t\tswap(next.data[q.e[o]] , next.data[di[q.e[o]][i]]);\n\t\t\t\t\tnext.depth = q.depth + 1;\n\t\t\t\t\t\n\t\t\t\t\tif( done.find(next.data) == done.end() ){\n\t\t\t\t\t\tdone[next.data] = next.depth;\n\t\t\t\t\t\tif( q.depth < 20)Q.push(next);\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t\tcout << \"NA\" << endl;\n\t\tjmp:;\n\t}\n}"
  },
  {
    "language": "C++",
    "code": "#include<iostream>\n#include<vector>\n#include<queue>\n#include<map>\n#include<cmath>\nusing namespace std;\n\nstring ans;\n\nclass board{\npublic:\n  int h,c;\n  string s;\n  board(int x,int y,string z){ h=x; c=y; s=z;}\n  const bool operator<(const board x)const{return (h+c>x.h+x.c) || (h+c==x.h+x.c && c>x.c); }\n};\n\nint score(string s){\n  int res=0;\n  for(int i=0;i<25;i++){\n    if(s[i]!='x'){\n      int m=20;\n      for(int j=0;j<25;j++){\n\tif(s[i]==ans[j]){\n\t  int a = abs(i-j);\n\t  int tmp = a/5 + a%5;\n\t  m = min(m,tmp);\n\t  if(s[i]!='o')break;\n\t}\n      }\n      res += m;\n    }\n  }\n  return res;\n}\n\nchar trans(int x){\n  if(!x)return 'o';\n  else return 'a'+x-1;\n}\n\nint main(){\n  string s;\n  ans = \"xxoxxxabcxdefghxijkxxxoxx\";\n  int tmp,cost;\n\n  for(;;){\n    cin >> tmp;\n    if(tmp<0)break;\n\n    s = \"xx\";\n    s += trans(tmp);\n    s += \"xxx\";\n    for(int i=0;i<3;i++){\n      cin >> tmp;\n      s += trans(tmp);\n    }\n    s += \"x\";\n    for(int i=0;i<5;i++){\n      cin >> tmp;\n      s += trans(tmp);\n    }\n    s += \"x\";\n    for(int i=0;i<3;i++){\n      cin >> tmp;\n      s+= trans(tmp);\n    }\n    s += \"xxx\";\n    cin >> tmp;\n    s += trans(tmp);\n    s += \"xx\";\n\n    priority_queue<board> q1;\n    q1.push(board(score(s),0,s));\n\n    map<string,bool> m1;\n    m1[s] = 0;\n    while(q1.size()){\n      board p = q1.top();q1.pop();\n      int dx[] = {-5,1,5,-1};\n      //cout << p.h << \" \" << p.c << \" \" << p.s << endl;\n      cost = p.c;\n      if(p.s == ans)break;\n      if(cost>20)break;\n      if(p.h/2+p.c > 20){\n\tcost = 21;\n\tbreak;\n      }\n      for(int i=0;i<25;i++){\n\tif(p.s[i]=='o'){\n\t  for(int j=0;j<4;j++){\n\t    int sx = i + dx[j];\n\t    string str = p.s;\n\t    if(sx<0 || 25<=sx)continue;\n\t    if(str[sx] == 'x' || str[sx] == 'o')continue;\n\t    swap(str[i],str[sx]);\n\t    if(!m1[str]){\n\t      q1.push(board(score(str),cost+1,str));\n\t      m1[str] = cost+1;\n\t    }\n\t  }\n\t}\n      }\n    }\n\n\n\n    if(cost>20)cout << \"NA\\n\";\n    else cout << cost << endl;\n  }\n}"
  },
  {
    "language": "C++",
    "code": "#include<iostream>\n#include<algorithm>\n#include<vector>\n#include<queue>\n#include<unordered_map>\n#define lol(i,n) for(int i=0;i<n;i++)\n#define mod 1000000007\ntypedef long long ll;\nusing namespace std;\nint dx[13][4]={\n  {3,0,0,0},\n  {3,6,0,0},\n  {1,2,4,7},\n  {3,8,0,0},\n  {6,0,0,0},\n  {2,5,7,10},\n  {3,6,8,11},\n  {4,7,9,12},\n  {8,0,0,0},\n  {6,11,0,0},\n  {7,10,12,13},\n  {8,11,0,0},\n  {11,0,0,0}\n};\nunordered_map<ll,int> mp;\nll Compress(int p[]){\n  ll ans=0;\n  for(int i=0;i<13;i++){\n    ans*=13;\n    ans+=p[i];\n  }\n  return ans;\n}\n\nint unzip[13];\nvoid Unzip(ll x){\n  for(int i=0;i<13;i++){\n    unzip[12-i]=x%13;\n    x/=13;\n  }\n}\n\nint beflen=0;\nqueue<pair<ll,int> >Q;\nvoid BFS(int p[],int len){\n  //if(len!=beflen){cout<<len<<endl;beflen=len;}\n  ll tmp=Compress(p);\n  mp[tmp]=len;\n  if(len==13)return;\n  lol(i,13){\n    if(p[i]==0){\n      lol(j,4){\n\tint t=dx[i][j];\n\tif(t==0)break;\n\tt--;\n\tif(p[t]!=0){\n\t  swap(p[i],p[t]);\n\t  tmp=Compress(p);\n\t  if(mp[tmp]!=0)continue;\n\t  mp[tmp]=-1;\n\t  Q.push(make_pair(tmp,len+1));\n\t  swap(p[i],p[t]);\n\t}\n      }\n    }\n  }\n}\n\nint ans;\nvoid EFS(int p[],int len){\n  //if(len!=beflen){cout<<len<<endl;beflen=len;}\n  ll tmp=Compress(p);\n  if(mp[tmp]>0){\n    ans=min(ans,len+mp[tmp]-1);\n    return;\n  }\n  if(len==9)return;\n  lol(i,13){\n    if(p[i]==0){\n      lol(j,4){\n\tint t=dx[i][j];\n\tif(t==0)break;\n\tt--;\n\tif(p[t]!=0){\n\t  swap(p[i],p[t]);\n\t  tmp=Compress(p);\n\t  Q.push(make_pair(tmp,len+1));\n\t  swap(p[i],p[t]);\n\t}\n      }\n    }\n  }\n}\nint main(){\n  int p[13];\n  lol(i,13)p[i]=i;p[12]=0;\n  Q.push(make_pair(Compress(p),1));\n  while(!Q.empty()){\n    ll data=Q.front().first;\n    int len=Q.front().second;\n    Q.pop();\n    if(mp[data]>0)continue;\n    Unzip(data);\n    BFS(unzip,len);\n  }\n  //cout<<\"#\"<<mp.size()<<endl;\n  while(cin>>p[0]&&p[0]!=-1){\n    for(int i=1;i<13;i++)cin>>p[i];\n    ans=mod;\n    Q.push(make_pair(Compress(p),0));\n    while(!Q.empty()){\n      ll data=Q.front().first;\n      int len=Q.front().second;\n      Q.pop();\n      Unzip(data);\n      EFS(unzip,len);\n    }\n    if(ans>20)cout<<\"NA\"<<endl;\n    else cout<<ans<<endl;\n  }\n  return 0;\n}"
  },
  {
    "language": "C++",
    "code": "#import<iostream>\n#import<map>\n#import<queue>\n#import<cstdlib>\n#import<cstring>\nusing namespace std;struct B{int z[2];char s[14];bool operator<(const B&r)const{return strcmp(s,r.s)<0;}};main(){int a[13][5]={{2,-1},{2,5,-1},{0,1,3,6,-1},{2,7,-1},{5,-1},{1,4,6,9,-1},{2,5,7,10,-1},{3,6,8,11,-1},{7,-1},{5,10,-1},{6,9,11,12,-1},{7,10,-1},{10,-1}},X[]={2,1,2,3,0,1,2,3,4,1,2,3,2},Y[]={0,1,1,1,2,2,2,2,2,3,3,3,4},v,d,s,i,j,t,u;B g={0,0,\"0123456789:;0\"};for(;;){map<B,int>m;queue<B>q;B b={i=-1,-1};for(;++i<13;!v?b.z[*b.z>=0]=i:0){cin>>v;if(v<0)return 0;b.s[i]=48+v;}b.s[13]=0;m[b]=1;for(q.push(b);!q.empty();q.pop()){B&b=q.front();if(!strcmp(b.s,g.s))break;d=0;for(i=13;i--;v?d+=abs(X[v]-X[i])+abs(Y[v]-Y[i]):0)v=b.s[i]-48;s=m[b];if(s+d<22)for(j=2;j--;)for(i=0;~a[u=b.z[j]][i];i++){B n=b;t=n.z[j]=a[u][i];if(t-n.z[1-j]){swap(n.s[u],n.s[t]);int&r=m[n];if(!r)r=s+1,q.push(n);}}}printf(m[g]?\"%d\\n\":\"NA\\n\",m[g]-1);}}"
  },
  {
    "language": "C++",
    "code": "#include<iostream>\n#include<map>\n#include<deque>\n#include<cstring>\n#include<cstdlib>\nusing namespace std;\nstruct board{\n\tchar s[14];\n\tint z1,z2;\n\tbool operator<(const board& rhs)const{return strcmp(s,rhs.s)<0;}\n};\nint main(){\n\tint d[13][5]={\n\t\t{2,-1},\t\t\t//0\n\t\t{2,5,-1},\t\t//1\n\t\t{0,1,3,6,-1},\t//2\n\t\t{2,7,-1},\t\t//3\n\t\t{5,-1},\t\t\t//4\n\t\t{1,4,6,9,-1},\t//5\n\t\t{2,5,7,10,-1},\t//6\n\t\t{3,6,8,11,-1},\t//7\n\t\t{7,-1},\t\t\t//8\n\t\t{5,10,-1},\t\t//9\n\t\t{6,9,11,12,-1},\t//10\n\t\t{7,10,-1},\t\t//11\n\t\t{10,-1},\t\t//12\n\t};\n\tint gx[]={2,1,2,3,0,1,2,3,4,1,2,3,2};\n\tint gy[]={0,1,1,1,2,2,2,2,2,3,3,3,4};\n\tboard goal;\n\tstrcpy(goal.s,\"0123456789:;0\");\n\tfor(;;){\n\t\ttypedef map<board,int>SM;\n\t\tSM stepmap;\n\t\tdeque<board> que;\n\t\tboard b0;\n\t\tb0.z1=b0.z2=-1;\n\t\tfor(int i=0;i<13;i++){\n\t\t\tint v;\n\t\t\tcin>>v;\n\t\t\tif(v==-1)\n\t\t\t\treturn 0;\n\t\t\tb0.s[i]='0'+v;\n\t\t\tif(v==0){\n\t\t\t\tif(b0.z1==-1)\n\t\t\t\t\tb0.z1=i;\n\t\t\t\telse\n\t\t\t\t\tb0.z2=i;\n\t\t\t}\n\t\t}\n\t\tb0.s[13]=0;\n\t\tque.push_back(b0);\n\t\tstepmap[b0]=1;\n\t\twhile(!que.empty()){\n\t\t\tboard b=que.front();\n\t\t\tif(strcmp(b.s,goal.s)==0){\n\t\t\t\tbreak;\n\t\t\t}\n\t\t\tque.pop_front();\n\t\t\tint dist=0;\n\t\t\tfor(int i=0;i<13;i++){\n\t\t\t\tint v=b.s[i]-'0';\n\t\t\t\tif(v){\n\t\t\t\t\tdist+=abs(gx[v]-gx[i])+abs(gy[v]-gy[i]);\n\t\t\t\t}\n\t\t\t}\n\t\t\tint step=stepmap[b];\n\t\t\tif(dist+step<=20){\n\t\t\t\tfor(int i=0;d[b.z1][i]!=-1;i++){\n\t\t\t\t\tboard bn=b;\n\t\t\t\t\tbn.z1=d[b.z1][i];\n\t\t\t\t\tif(bn.z1!=bn.z2){\n\t\t\t\t\t\tswap(bn.s[b.z1],bn.s[bn.z1]);\n\t\t\t\t\t\tint&ns=stepmap[bn];\n\t\t\t\t\t\tif(!ns){\n\t\t\t\t\t\t\tns=step+1;\n\t\t\t\t\t\t\tque.push_back(bn);\n\t\t\t\t\t\t}\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t\tfor(int i=0;d[b.z2][i]!=-1;i++){\n\t\t\t\t\tboard bn=b;\n\t\t\t\t\tbn.z2=d[b.z2][i];\n\t\t\t\t\tif(bn.z2!=bn.z1){\n\t\t\t\t\t\tswap(bn.s[b.z2],bn.s[bn.z2]);\n\t\t\t\t\t\tint&ns=stepmap[bn];\n\t\t\t\t\t\tif(!ns){\n\t\t\t\t\t\t\tns=step+1;\n\t\t\t\t\t\t\tque.push_back(bn);\n\t\t\t\t\t\t}\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t\tif(stepmap[goal]==0)\n\t\t\tcout<<\"NA \"<<endl;\n\t\telse\n\t\t\tcout<<stepmap[goal]-1<<endl;\n\t}\n}"
  },
  {
    "language": "C++",
    "code": "#include <iostream>\n#include <string>\n#include <vector>\n#include <queue>\n#include <map>\nusing namespace std;\n\nstring s = \"0123456789AB\";\nvector<vector<int>> adj = {\n    {2},\n    {2,5},\n    {0,1,3,6},\n    {2,7},\n    {5},\n    {1,4,6,9},\n    {2,5,7,10},\n    {3,6,8,11},\n    {7},\n    {5,10},\n    {6,9,11,12},\n    {7,10},\n    {10}\n};\nmap<string, int> term, dist;\n\nint solve(string stat, string goal, map<string,int> &dist, bool useterm) {\n    dist[stat] = 0;\n    queue<string> q;\n    q.push(stat);\n    while ( ! q.empty()) {\n        string s = q.front();\n        q.pop();\n        if (useterm && term.find(s) != term.end()) {\n            return dist[s] + term[s];\n        }\n        int diff = 0;\n        for (int k=0; k<13; ++k) {\n            if (s[k] != '0') {\n                diff += s[k] != goal[k];\n            }\n        }\n        if ( ! diff) {\n            return dist[s];\n        }\n        if (10 < dist[s] || 20 < dist[s] + diff) {\n            continue;\n        }\n        for (int i=0; i<13; ++i) {\n            if (s[i] != '0') continue;\n            for (int j : adj[i]) {\n                string next = s;\n                next[i] = s[j];\n                next[j] = s[i];\n                if (dist.find(next) == dist.end()) {\n                    dist[next] = dist[s] + 1;\n                    q.push(next);\n                }\n            }\n        }\n    }\n    return 11;\n}\n\nint main() {\n    while (1) {\n        string stat = \"\";\n        int k;\n        for (int i=0; i<13; ++i) {\n            if (cin >> k && !~k) return 0;\n            stat += s[k];\n        }\n        int ans = solve(\"0123456789AB0\", stat, term, false);\n        if (ans == 11) {\n            ans += solve(stat, \"0123456789AB0\", dist, true);\n        }\n        if (ans <= 20) {\n            cout << ans << endl;\n            continue;\n        }\n        cout << \"NA\" << endl;\n    }\n    return 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include <cstdio>\n#include <cstdlib>\n#include <cmath>\n#include <climits>\n#include <cfloat>\n#include <map>\n#include <utility>\n#include <set>\n#include <iostream>\n#include <memory>\n#include <string>\n#include <vector>\n#include <algorithm>\n#include <functional>\n#include <sstream>\n#include <complex>\n#include <stack>\n#include <queue>\n#include <cstring>\n#include <sstream>\n#include <cassert>\n#include <list>\nusing namespace std;\nstatic const double EPS = 1e-10;\ntypedef long long ll;\ntypedef pair<int,int> PI;\ntypedef vector<int> vi;\n#ifndef M_PI\n#define M_PI 3.14159265358979323846\n#endif\n#define rep(i,n) for(int i=0;i<(int)n;++i)\n#define FOR(i,c) for(__typeof((c).begin())i=(c).begin();i!=(c).end();++i)\n#define ALL(c) (c).begin(), (c).end()\n#define mp(a,b) make_pair(a,b)\n#define pb(a) push_back(a)\n#define F first\n#define S second\ntemplate <typename T> string print_array(const vector<T> &V) { ostringstream os; os << \"{ \"; for (typename vector<T>::const_iterator iter = V.begin(); iter != V.end(); ++iter) os << '\\\"' << *iter << \"\\\",\"; os << \" }\"; return os.str(); }\n\nint dx[]={0,1,0,-1},dy[]={1,0,-1,0};\n\nvector<int> se[13];\nint x[]={0,-1,0,1,-2,-1,0,1,2,-1,0,1,0};\nint y[]={2,1,1,1,0,0,0,0,0,-1,-1,-1,-2};\n\nvoid pr(ll in){\n\n  printf(\"      %3lld\\n\",in&15);\n  printf(\"   %3lld%3lld%3lld\\n\",(in>>4)&15,(in>>8)&15,(in>>12)&15);\n  printf(\"%3lld%3lld%3lld%3lld%3lld\\n\",(in>>16)&15,(in>>20)&15,(in>>24)&15,(in>>28)&15,(in>>32)&15);\n  printf(\"   %3lld%3lld%3lld\\n\",(in>>36)&15,(in>>40)&15,(in>>44)&15);\n  printf(\"      %3lld\\n\",(in>>48)&15);\n  puts(\"\");\n}\n\nint manh(ll in){\n  int ret=0;\n  rep(i,13){\n    int t=(in>>(i*4))&15;\n\n    if(!t){\n      int nx=x[t]-x[i],ny=y[t]-y[i];\n      int co=abs(nx)+abs(ny);\n      nx=x[12]-x[i],ny=y[12]-y[i];\n      int k=abs(nx)+abs(ny);\n      ret+=min(co,k);\n      continue;\n    }\n    int nx=(x[t]-x[i]),ny=y[t]-y[i];\n    ret+=abs(nx)+abs(ny);\n  }\n  return ret;\n}\n\nmain(){\n  ll p;\n\n  ll goal=0;\n  rep(i,11){\n    goal|=(i+1LL)<<(4*(i+1));\n    //cout<<goal<<endl;\n    //pr(goal);\n  }\n  //pr(goal);\n\n  se[0].pb(2);\n  se[1].pb(2);\n  se[1].pb(5);\n  se[2].pb(0);\n  se[2].pb(1);\n  se[2].pb(3);\n  se[2].pb(6);\n  se[3].pb(2);\n  se[3].pb(7);\n  se[4].pb(5);\n  se[5].pb(1);\n  se[5].pb(4);\n  se[5].pb(6);\n  se[5].pb(9);\n  se[6].pb(2);\n  se[6].pb(5);\n  se[6].pb(7);\n  se[6].pb(10);\n  se[7].pb(3);\n  se[7].pb(6);\n  se[7].pb(8);\n  se[7].pb(11);\n  se[8].pb(7);\n  se[9].pb(5);\n  se[9].pb(10);\n  se[10].pb(6);\n  se[10].pb(9);\n  se[10].pb(11);\n  se[10].pb(12);\n  se[11].pb(7);\n  se[11].pb(10);\n  se[12].pb(10);\n  \n  while(cin>>p){\n    if(p==-1)break;\n    ll in=p;\n\n    rep(i,12){\n      cin>>p;\n      in|=p<<(4*(i+1));\n    }\n\n    set<ll> app;\n\n    queue<pair<int,ll> > Q;\n    app.insert(in);\n    Q.push(mp(0,in));\n    int ans=21;\n    int mans=0;\n\n    while(!Q.empty()){\n      ll cvec=Q.front().S;\n      int ccost=Q.front().F;\n      Q.pop();\n    \n      //pr(cvec);\n\n      //if(ccost>3)break;\n     if(ccost>20)break;\n     \n      if(cvec==goal){\n\tans=ccost;\n\tbreak;\n      }\n      if(ccost+manh(cvec)>30)continue;\n      rep(i,13){\n\tll t=cvec>>(i<<2);\n\tt=t&15;\n\tif(!t){\n\t  rep(j,se[i].size()){\n\t    t=cvec>>(se[i][j]<<2);\n\t    t=t&15;\n\t    if(t){\n\t      ll nvec=cvec;\n\t      t=t<<(i<<2);\n\t      nvec|=t;\n\t      nvec&=~(15LL<<se[i][j]*4);\n\t      \n\t      if(!app.count(nvec)){\n\t\tapp.insert(nvec);\n\t\tQ.push(mp(ccost+1,nvec));\n\t      }\n\t    }\n\t  }\n\t}\n      }\n    }\n    if(ans==21)cout<<\"NA\"<<endl;\n    else cout<<ans<<endl;\n  }\n}"
  },
  {
    "language": "C++",
    "code": "#include <iostream>\n#include <sstream>\n#include <string>\n#include <algorithm>\n#include <vector>\n#include <stack>\n#include <queue>\n#include <set>\n#include <map>\n#include <cstdio>\n#include <cstdlib>\n#include <cstring>\n#include <cmath>\n\nusing namespace std;\n\n#define FOR(i,k,n) for(int i=(k); i<(int)n; ++i)\n#define REP(i,n) FOR(i,0,n)\n#define FORIT(i,c) for(__typeof((c).begin())i=(c).begin();i!=(c).end();++i)\n\nstruct S{\n  vector<int> p;\n  int t;\n  S(vector<int> p, int t) : p(p),t(t) {}\n};\n\nbool operator<(const S& s, const S& t){\n  return s.t > t.t;\n}\n\nvoid print_s(S s){\n  vector<int> v = s.p;\n  printf(\"time:%d\\n\",s.t);\n  printf(\"    %2d    \\n\",v[0]);\n  printf(\"  %2d%2d%2d  \\n\",v[1],v[2],v[3]);\n  printf(\"%2d%2d%2d%2d%2d\\n\",v[4],v[5],v[6],v[7],v[8]);\n  printf(\"  %2d%2d%2d  \\n\",v[9],v[10],v[11]);\n  printf(\"    %2d    \\n\",v[12]);\n}\n\nset<vector<int> > memo;\nvector<int> goal(13);\nint bfs(S start){\n  priority_queue<S> que;\n  que.push(start);\n  while(!que.empty()){\n    S s = que.top(); que.pop();\n    //print_s(s);\n    if(s.t > 20) return -1;\n    if(s.p == goal) return s.t;\n    if(memo.find(s.p)!=memo.end()) continue;\n    memo.insert(s.p);\n    REP(i,13){\n      vector<int> tmp = s.p;\n      if(s.p[i]==0){\n        switch(i){\n          case 0:\n          case 2:\n            swap(tmp[0],tmp[2]);\n            que.push(S(tmp,s.t+1));\n            break;\n          case 12:\n          case 10:\n            swap(tmp[12],tmp[10]);\n            que.push(S(tmp,s.t+1));\n            break;\n          case 4:\n          case 5:\n            swap(tmp[4],tmp[5]);\n            que.push(S(tmp,s.t+1));\n            break;\n          case 8:\n          case 7:\n            swap(tmp[8],tmp[7]);\n            que.push(S(tmp,s.t+1));\n            break;\n        }\n        if(i % 4 == 2 || i % 4 == 3){\n          tmp = s.p;\n          swap(tmp[i],tmp[i-1]);\n          que.push(S(tmp,s.t+1));\n        }\n        if(i % 4 == 1 || i % 4 == 2){\n          tmp = s.p;\n          swap(tmp[i],tmp[i+1]);\n          que.push(S(tmp,s.t+1));\n        }\n        if(i % 4 != 0 && i < 8){\n          tmp = s.p;\n          swap(tmp[i],tmp[i+4]);\n          que.push(S(tmp,s.t+1));\n        }\n        if(i % 4 != 0 && i > 4){\n          tmp = s.p;\n          swap(tmp[i],tmp[i-4]);\n          que.push(S(tmp,s.t+1));\n        }\n      }\n    }\n  }\n}\nint main(){\n  int n;\n  vector<int> p(13);\n\n  REP(i,11) goal[i+1] = i+1;\n\n  while(cin>>p[0], p[0]!=-1){\n    for(int i = 1; i < 13; i++){\n      cin>>p[i];\n    }\n    S start(p,0);\n    memo.clear();\n    int ans = bfs(start);\n    if(ans == -1)cout<<\"NA\"<<endl;\n    else cout<< ans << endl;\n  }\n  return 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include <cstdio>\n#include <cstdlib>\n#include <cmath>\n#include <climits>\n#include <cfloat>\n#include <map>\n#include <utility>\n#include <set>\n#include <iostream>\n#include <memory>\n#include <string>\n#include <vector>\n#include <algorithm>\n#include <functional>\n#include <sstream>\n#include <complex>\n#include <stack>\n#include <queue>\n#include <cstring>\n#include <sstream>\n#include <cassert>\n#include <list>\nusing namespace std;\nstatic const double EPS = 1e-10;\ntypedef long long ll;\ntypedef pair<int,int> PI;\ntypedef vector<int> vi;\n#ifndef M_PI\n#define M_PI 3.14159265358979323846\n#endif\n#define rep(i,n) for(int i=0;i<(int)n;++i)\n#define FOR(i,c) for(__typeof((c).begin())i=(c).begin();i!=(c).end();++i)\n#define ALL(c) (c).begin(), (c).end()\n#define mp(a,b) make_pair(a,b)\n#define pb(a) push_back(a)\n#define F first\n#define S second\ntemplate <typename T> string print_array(const vector<T> &V) { ostringstream os; os << \"{ \"; for (typename vector<T>::const_iterator iter = V.begin(); iter != V.end(); ++iter) os << '\\\"' << *iter << \"\\\",\"; os << \" }\"; return os.str(); }\n\nint dx[]={0,1,0,-1},dy[]={1,0,-1,0};\n\nvector<int> se[13];\nint x[]={0,-1,0,1,-2,-1,0,1,2,-1,0,1,0};\nint y[]={2,1,1,1,0,0,0,0,0,-1,-1,-1,-2};\n\nvoid pr(ll in){\n\n  printf(\"      %3lld\\n\",in&15);\n  printf(\"   %3lld%3lld%3lld\\n\",(in>>4)&15,(in>>8)&15,(in>>12)&15);\n  printf(\"%3lld%3lld%3lld%3lld%3lld\\n\",(in>>16)&15,(in>>20)&15,(in>>24)&15,(in>>28)&15,(in>>32)&15);\n  printf(\"   %3lld%3lld%3lld\\n\",(in>>36)&15,(in>>40)&15,(in>>44)&15);\n  printf(\"      %3lld\\n\",(in>>48)&15);\n  puts(\"\");\n}\n\nint manh(ll in){\n  int ret=0;\n  rep(i,13){\n    int t=(in>>(i*4))&15;\n\n    if(!t){\n      int nx=x[t]-x[i],ny=y[t]-y[i];\n      int co=abs(nx)+abs(ny);\n      nx=x[12]-x[i],ny=y[12]-y[i];\n      int k=abs(nx)+abs(ny);\n      ret+=min(co,k);\n      continue;\n    }\n    int nx=(x[t]-x[i]),ny=y[t]-y[i];\n    ret+=abs(nx)+abs(ny);\n  }\n  return ret;\n}\n\nmain(){\n  ll p;\n\n  ll goal=0;\n  rep(i,11){\n    goal|=(i+1LL)<<(4*(i+1));\n    //cout<<goal<<endl;\n    //pr(goal);\n  }\n  //pr(goal);\n\n  se[0].pb(2);\n  se[1].pb(2);\n  se[1].pb(5);\n  se[2].pb(0);\n  se[2].pb(1);\n  se[2].pb(3);\n  se[2].pb(6);\n  se[3].pb(2);\n  se[3].pb(7);\n  se[4].pb(5);\n  se[5].pb(1);\n  se[5].pb(4);\n  se[5].pb(6);\n  se[5].pb(9);\n  se[6].pb(2);\n  se[6].pb(5);\n  se[6].pb(7);\n  se[6].pb(10);\n  se[7].pb(3);\n  se[7].pb(6);\n  se[7].pb(8);\n  se[7].pb(11);\n  se[8].pb(7);\n  se[9].pb(5);\n  se[9].pb(10);\n  se[10].pb(6);\n  se[10].pb(9);\n  se[10].pb(11);\n  se[10].pb(12);\n  se[11].pb(7);\n  se[11].pb(10);\n  se[12].pb(10);\n  \n  while(cin>>p){\n    if(p==-1)break;\n    ll in=p;\n\n    rep(i,12){\n      cin>>p;\n      in|=p<<(4*(i+1));\n    }\n\n    set<ll> app;\n\n    queue<pair<int,ll> > Q;\n    app.insert(in);\n    Q.push(mp(0,in));\n    int ans=21;\n    int mans=0;\n\n    while(!Q.empty()){\n      ll cvec=Q.front().S;\n      int ccost=Q.front().F;\n      Q.pop();\n    \n      //pr(cvec);\n\n      //if(ccost>3)break;\n      if(ccost+manh(cvec)>33)continue;\n      if(cvec==goal){\n\tans=ccost;\n\tbreak;\n      }\n      rep(i,13){\n\tll t=cvec>>(i<<2);\n\tt=t&15;\n\tif(!t){\n\t  rep(j,se[i].size()){\n\t    t=cvec>>(se[i][j]<<2);\n\t    t=t&15;\n\t    if(t){\n\t      ll nvec=cvec;\n\t      t=t<<(i<<2);\n\t      nvec|=t;\n\t      nvec&=~(15LL<<se[i][j]*4);\n\t      \n\t      if(!app.count(nvec)){\n\t\tapp.insert(nvec);\n\t\tQ.push(mp(ccost+1,nvec));\n\t      }\n\t    }\n\t  }\n\t}\n      }\n    }\n    if(ans==21)cout<<\"NA\"<<endl;\n    else cout<<ans<<endl;\n  }\n}"
  },
  {
    "language": "C++",
    "code": "#include<iostream>\n#include<algorithm>\n#include<vector>\n#include<queue>\n#include<unordered_map>\n#define lol(i,n) for(int i=0;i<n;i++)\n#define mod 1000000007\ntypedef long long ll;\nusing namespace std;\nint dx[13][4]={\n  {3,0,0,0},\n  {3,6,0,0},\n  {1,2,4,7},\n  {3,8,0,0},\n  {6,0,0,0},\n  {2,5,7,10},\n  {3,6,8,11},\n  {4,7,9,12},\n  {8,0,0,0},\n  {6,11,0,0},\n  {7,10,12,13},\n  {8,11,0,0},\n  {11,0,0,0}\n};\nunordered_map<ll,int> mp;\nll Compress(int p[]){\n  ll ans=0;\n  for(int i=0;i<13;i++){\n    ans*=13;\n    ans+=p[i];\n  }\n  return ans;\n}\n\nint unzip[13];\nvoid Unzip(ll x){\n  for(int i=0;i<13;i++){\n    unzip[12-i]=x%13;\n    x/=13;\n  }\n}\n\nint beflen=0;\nqueue<pair<ll,int> >Q;\nvoid BFS(int p[],int len){\n  //if(len!=beflen){cout<<len<<endl;beflen=len;}\n  ll tmp=Compress(p);\n  mp[tmp]=len;\n  if(len==15)return;\n  lol(i,13){\n    if(p[i]==0){\n      lol(j,4){\n\tint t=dx[i][j];\n\tif(t==0)break;\n\tt--;\n\tif(p[t]!=0){\n\t  swap(p[i],p[t]);\n\t  tmp=Compress(p);\n\t  if(mp[tmp]!=0)continue;\n\t  mp[tmp]=-1;\n\t  Q.push(make_pair(tmp,len+1));\n\t  swap(p[i],p[t]);\n\t}\n      }\n    }\n  }\n}\n\nint ans;\nvoid EFS(int p[],int len){\n  //if(len!=beflen){cout<<len<<endl;beflen=len;}\n  ll tmp=Compress(p);\n  if(mp[tmp]>0){\n    ans=min(ans,len+mp[tmp]-1);\n    return;\n  }\n  if(len==7)return;\n  lol(i,13){\n    if(p[i]==0){\n      lol(j,4){\n\tint t=dx[i][j];\n\tif(t==0)break;\n\tt--;\n\tif(p[t]!=0){\n\t  swap(p[i],p[t]);\n\t  tmp=Compress(p);\n\t  Q.push(make_pair(tmp,len+1));\n\t  swap(p[i],p[t]);\n\t}\n      }\n    }\n  }\n}\nint main(){\n  int p[13];\n  lol(i,13)p[i]=i;p[12]=0;\n  Q.push(make_pair(Compress(p),1));\n  while(!Q.empty()){\n    ll data=Q.front().first;\n    int len=Q.front().second;\n    Q.pop();\n    if(mp[data]>0)continue;\n    Unzip(data);\n    BFS(unzip,len);\n  }\n  while(cin>>p[0]&&p[0]!=-1){\n    for(int i=1;i<13;i++)cin>>p[i];\n    ans=mod;\n    Q.push(make_pair(Compress(p),0));\n    while(!Q.empty()){\n      ll data=Q.front().first;\n      int len=Q.front().second;\n      Q.pop();\n      Unzip(data);\n      EFS(unzip,len);\n    }\n    if(ans>20)cout<<\"NA\"<<endl;\n    else cout<<ans<<endl;\n  }\n  return 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include <iostream>\n#include <vector>\n\nusing namespace std;\n \nstruct P {\n    int x, y;\n    P(int x, int y) : x{x}, y{y} {}\n};\n \nint limit;\nvector<int> v;\n\nconstexpr int X[] = {2, 1, 2, 3, 0, 1, 2, 3, 4, 1, 2, 3, 2};\nconstexpr int Y[] = {0, 1, 1, 1, 2, 2, 2, 2, 2, 3, 3, 3, 4};\n \nint getPos(P p)\n{\n    switch (p.y) {\n        case 0:\n            return (p.x == 2 ? 0 : -1);\n        case 1:\n            return (1 <= p.x && p.x <= 3 ? p.x : -1);\n        case 2:\n            return (p.x <= 4 ? p.x + 4 : -1); \n        case 3:\n            return (1 <= p.x && p.x <= 3 ? p.x + 8 : -1);\n        case 4:\n            return (p.x == 2 ? 12 : -1);\n    }\n    return -1;\n}\n \nint getMD()\n{\n    int sum = 0;\n    for (int i = 0; i < 13; i++) {\n        if (v[i] == 0) continue;\n        P np{X[i], Y[i]};\n        P tp{X[v[i]], Y[v[i]]};\n        sum += abs(np.x - tp.x) + abs(np.y - tp.y);\n    }\n    return sum;\n}\n \nconstexpr int dx[] = {-1, 0, 1, 0};\nconstexpr int dy[] = {0, -1, 0, 1};\n \nbool dfs(const int* sp, int step)\n{\n    int md = getMD();\n    if (md == 0) return 1;\n    if (md + step > limit) {\n        return 0;\n    }\n    \n    for (int i = 0; i < 2; i++) {\n        int x = X[sp[i]], y = Y[sp[i]];\n        for (int j = 0; j < 4; j++) {\n            int nx = x + dx[j], ny = y + dy[j];\n            P np{nx, ny};\n            \n            int next = getPos(np);\n            if (next == -1) continue;\n            \n            int nsp1[] = {next, sp[1]}, nsp2[] = {sp[0], next};\n            \n            swap(v[sp[i]], v[next]);\n            if (i == 0 && dfs(nsp1, step + 1)) {\n                return 1;\n            }\n            if (i == 1 && dfs(nsp2, step + 1)) {\n                return 1;\n            }\n            swap(v[sp[i]], v[next]);\n        }\n    }\n    return 0;\n}\n \nint main()\n{\n    int x;\n    while (cin >> x, x != -1) {\n        int sp[2];\n        v.resize(13); v[0] = x;\n        for (int i = 1; i < 13; i++) {\n            cin >> v[i];\n        }\n\n        for (int i = 0, j = 0; i < 13; i++) {\n            if (v[i] == 0) {\n                sp[j++] = i;\n            }\n        }\n\n        bool found = 0;\n        constexpr int LIMIT = 20;\n        for (limit = 0; limit <= LIMIT; limit++) {\n            if (dfs(sp, 0)) {\n                cout << limit << endl;\n                found = 1;\n                break;\n            }\n        }\n        if (!found) {\n            cout << \"NA\" << endl;\n        }\n    }\n    return 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include <vector>\n#include <list>\n#include <map>\n#include <set>\n#include <deque>\n#include <queue>\n#include <stack>\n#include <bitset>\n#include <algorithm>\n#include <functional>\n#include <numeric>\n#include <utility>\n#include <sstream>\n#include <iostream>\n#include <iomanip>\n#include <cstdio>\n#include <cmath>\n#include <cstdlib>\n#include <cctype>\n#include <string>\n#include <cstring>\n#include <ctime>\n\nusing namespace std;\n\ninline int toInt(string s) {int v; istringstream sin(s);sin>>v;return v;}\ntemplate<class T> inline string toString(T x) {ostringstream sout;sout<<x;return sout.str();}\ntemplate<class T> inline T sqr(T x) {return x*x;}\n\ntypedef vector<int> vi;\ntypedef vector<vi> vvi;\ntypedef vector<string> vs;\ntypedef pair<int, int> pii;\ntypedef long long ll;\n\n#define all(a)  (a).begin(),(a).end()\n#define rall(a) (a).rbegin(), (a).rend()\n#define pb push_back\n#define mp make_pair\n#define each(i,c) for(typeof((c).begin()) i=(c).begin(); i!=(c).end(); ++i)\n#define exist(s,e) ((s).find(e)!=(s).end())\n#define range(i,a,b) for(int i=(a);i<(b);++i)\n#define rep(i,n)  range(i,0,n)\n#define clr(a,b) memset((a), (b) ,sizeof(a))\n#define dump(x)  cerr << #x << \" = \" << (x) << endl;\n#define debug(x) cerr << #x << \" = \" << (x) << \" (L\" << __LINE__ << \")\" << \" \" << __FILE__ << endl;\n\nconst double eps = 1e-10;\nconst double pi  = acos(-1.0);\nconst ll inf =1LL << 62;\n\ntypedef  pair<string,int> P;\n\nmap <string,int> ans;\n\nvoid bfs(void){\n\tstring ini=\"0123456789ab0\";\n\tP init;\n\tinit.first=ini;\n\tinit.second=0;\n\tqueue<P> q;\n\tq.push(init);\n\twhile(!q.empty()){\n\t\tP cur;\n\t\tcur=q.front();q.pop();\n\t//\tcout << cur.first << endl;\n\t\tif(cur.second>=11)\n\t\t\tcontinue;\n\t\t\n\t\tif(ans.find(cur.first)==ans.end())\n\t\t\tans[cur.first]=cur.second;\n\t\telse\n\t\t\tcontinue;\n\t\tint zero[2]={-1,-1};\n\t\trep(i,13){\n\t\t\tif(zero[0]==-1&&cur.first[i]=='0')\n\t\t\t\tzero[0]=i;\n\t\t\telse if(zero[1]==-1&&cur.first[i]=='0')\n\t\t\t\tzero[1]=i;\n\t\t}\n\t\trep(i,2){\n\t\t\tstring tar;\n\t\t\tP next;\n\t\t\tint check=zero[i];\n\t\t\tif(check%4){\n\t\t\t\tint d[4]={-4,-1,1,4};\n\t\t\t\trep(j,4){\n\t\t\t\t\tif(j==0&&(check==1||check==3))\n\t\t\t\t\t\tcontinue;\n\t\t\t\t\tif(j==1&&(check==1||check==9))\n\t\t\t\t\t\tcontinue;\n\t\t\t\t\tif(j==2&&(check==9||check==11))\n\t\t\t\t\t\tcontinue;\n\t\t\t\t\tif(j==3&&(check==3||check==11))\n\t\t\t\t\t\tcontinue;\n\t\t\t\t\ttar=cur.first;\n\t\t\t\t\tint index=check+d[j];\n\t\t\t\t\tindex=max(index,0);\n\t\t\t\t\tindex=min(index,12);\n\t\t\t\t\tswap(tar[check],tar[index]);\n\t\t\t\t\tnext.first=tar;\n\t\t\t\t\tnext.second=cur.second+1;\n\t\t\t\t\tq.push(next);\n\t\t\t\t}\n\t\t\t}else{\n\t\t\t\tint d[4]={2,1,-1,-2};\n\t\t\t\ttar=cur.first;\n\t\t\t\tint index=check/4;\n\t\t\t\tswap(tar[check],tar[check+d[index]]);\n\t\t\t\tnext.first=tar;\n\t\t\t\tnext.second=cur.second+1;\n\t\t\t\tq.push(next);\n\t\t\t}\n\t\t}\n\t}\n\treturn ;\n}\n\nint bfs2(string query){\n\tmap <string,int> ans2;\n\tP init;\n\tinit.first=query;\n\tinit.second=0;\n\tqueue<P> q;\n\tq.push(init);\n\twhile(!q.empty()){\n\t\tP cur;\n\t\tcur=q.front();q.pop();\n\t//\tcout << cur.first << endl;\n\t\tif(cur.second>=11)\n\t\t\tcontinue;\n\t\tif(ans.find(cur.first)!=ans.end())\n\t\t\treturn cur.second+ans[cur.first];\n\n\t\tif(ans2.find(cur.first)==ans2.end())\n\t\t\tans2[cur.first]=cur.second;\n\t\telse\n\t\t\tcontinue;\n\t\tint zero[2]={-1,-1};\n\t\trep(i,13){\n\t\t\tif(zero[0]==-1&&cur.first[i]=='0')\n\t\t\t\tzero[0]=i;\n\t\t\telse if(zero[1]==-1&&cur.first[i]=='0')\n\t\t\t\tzero[1]=i;\n\t\t}\n\t\trep(i,2){\n\t\t\tstring tar;\n\t\t\tP next;\n\t\t\tint check=zero[i];\n\t\t\tif(check%4){\n\t\t\t\tint d[4]={-4,-1,1,4};\n\t\t\t\trep(j,4){\n\t\t\t\t\tif(j==0&&(check==1||check==3))\n\t\t\t\t\t\tcontinue;\n\t\t\t\t\tif(j==1&&(check==1||check==9))\n\t\t\t\t\t\tcontinue;\n\t\t\t\t\tif(j==2&&(check==9||check==11))\n\t\t\t\t\t\tcontinue;\n\t\t\t\t\tif(j==3&&(check==3||check==11))\n\t\t\t\t\t\tcontinue;\n\t\t\t\t\ttar=cur.first;\n\t\t\t\t\tint index=check+d[j];\n\t\t\t\t\tindex=max(index,0);\n\t\t\t\t\tindex=min(index,12);\n\t\t\t\t\tswap(tar[check],tar[index]);\n\t\t\t\t\tnext.first=tar;\n\t\t\t\t\tnext.second=cur.second+1;\n\t\t\t\t\tq.push(next);\n\t\t\t\t}\n\t\t\t}else{\n\t\t\t\tint d[4]={2,1,-1,-2};\n\t\t\t\ttar=cur.first;\n\t\t\t\tint index=check/4;\n\t\t\t\tswap(tar[check],tar[check+d[index]]);\n\t\t\t\tnext.first=tar;\n\t\t\t\tnext.second=cur.second+1;\n\t\t\t\tq.push(next);\n\t\t\t}\n\t\t}\n\t}\n\treturn -1;\n}\n\nint main(void){\n\tbfs();\n\tint input[13];\n\twhile(cin >> input[0],input[0]!=-1){\n\t\tfor(int i=1;i<13;i++)\n\t\t\tcin >> input[i];\n\t\tstring query=\"\";\n\t\trep(i,13){\n\t\t\tif(input[i]>=10)\n\t\t\t\tquery+=((input[i]-10)+'a');\n\t\t\telse\n\t\t\t\tquery+=(input[i]+'0');\n\t\t}\n\t\tint answer=bfs2(query);\n\t\tif(answer==-1)\n\t\t\tcout << \"NA\" << endl;\n\t\telse\n\t\t\tcout << answer << endl;\n\t}\n\treturn 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include<iostream>\n#include<vector>\n#include<map>\n#include<cstdio>\n#include<deque>\n#include<cmath>\n#include<algorithm>\n#define F first\n#define S second\n#define pb push_back\nusing namespace std;\ntypedef pair<int,int> P;\ntypedef pair<P,P> PP;\ntypedef vector<int> VI;\ntypedef vector<VI> VVI;\ntypedef vector<P> VP;\ntypedef pair<VVI,VP> VVIVP;\n\n\nmap<VVI,int> memo,bidirectional;\nVVI final;\nVP ini;\nint dx[4] = {0,1,0,-1};\nint dy[4] = {1,0,-1,0};\n\nP Fpos[] = {P(0,0),P(1,1),P(2,1),P(3,1),P(0,2),P(1,2),P(2,2),P(3,2),P(4,2),P(1,3),P(2,3),P(3,3)};\n\n\nclass Puzzle\n{\npublic:\n  VVI state;\n  int Manhattan;\n  VP vp;\n\n  Puzzle():Manhattan(0){}\n  Puzzle(VVI s)\n  {\n    vp.clear();\n    state = s;\n    Manhattan_calc(false);\n  }\n\n  void Manhattan_calc(bool b)\n  {\n    Manhattan = 0; \n    for(int i=0;i<5;i++)\n      for(int j=0;j<state[i].size();j++)\n\tif(state[i][j] != 0 && state[i][j] != -1)\n\t  Manhattan += abs(j-Fpos[state[i][j]].F) + abs(i-Fpos[state[i][j]].S);\n\telse if(state[i][j] == 0 && !b)// bがfalseなら初期化\n\t  vp.push_back(P(j,i)); \n  }\n\n  void print()\n  {\n  \n    for(int i=0;i<state.size();i++)\n      {\n\tfor(int j=0;j<state[i].size();j++)\n\t  {\n\t    if(state[i][j] == -1)\n\t      cout << \"  \";\n\t    else \n\t      cout << state[i][j] << \" \";\n\t  }\n\tcout << endl;\n      }\n    cout << endl;\n  }\n};\n\nbool Input(VVI& puzzle)\n{\n  puzzle.clear();\n  puzzle.resize(5);\n  puzzle[0].resize(3),puzzle[1].resize(4),puzzle[2].resize(5),puzzle[3].resize(4),puzzle[4].resize(3);\n  puzzle[0][0] = puzzle[0][1] = puzzle[1][0] = puzzle[3][0] = puzzle[4][0] = puzzle[4][1] = -1;\n \n  scanf(\"%d\",&puzzle[0][2]);\n  if(puzzle[0][2] == -1)\n    return false; \n  scanf(\"%d %d %d\",&puzzle[1][1],&puzzle[1][2],&puzzle[1][3]);\n  scanf(\"%d %d %d %d %d\",&puzzle[2][0],&puzzle[2][1],&puzzle[2][2],&puzzle[2][3],&puzzle[2][4]);\n  scanf(\"%d %d %d\",&puzzle[3][1],&puzzle[3][2],&puzzle[3][3]);\n  scanf(\"%d\",&puzzle[4][2]);\n\t    \n    return true;\n}\n\nvoid print(VVI vvi)\n{\n  cout << \"--- print ---\" << endl;\n  for(int i=0;i<vvi.size();i++)\n    {\n      for(int j=0;j<vvi[i].size();j++)\n\t{\n\t  cout << vvi[i][j] << \" \";\n\t}\n      cout << endl;\n    }\n  cout << endl;\n}\n\nVVI change(VVI vec,P p1,P p11)\n{\n  int tmp = vec[p1.S][p1.F];\n  vec[p1.S][p1.F] = vec[p11.S][p11.F];\n  vec[p11.S][p11.F] = tmp;\n\n  return vec;\n}\n\nvoid Init()\n{\n  final.resize(5);\n  final[0].pb(-1),final[0].pb(-1),final[0].pb(0);\n  final[1].pb(-1),final[1].pb(1),final[1].pb(2),final[1].pb(3);\n  final[2].pb(4),final[2].pb(5),final[2].pb(6),final[2].pb(7),final[2].pb(8);\n  final[3].pb(-1),final[3].pb(9),final[3].pb(10),final[3].pb(11);\n  final[4].pb(-1),final[4].pb(-1),final[4].pb(0);\n\n  Puzzle puz(final); \n  deque<Puzzle> deq;\n  deq.push_back(puz);\n  bidirectional[final] = 0;\n  \n  while(!deq.empty())\n    {\n      Puzzle p = deq.front(); deq.pop_front();\n      int cost = bidirectional[p.state];\n    \n      if(cost >= 12)\n\tcontinue;\n\n      for(int i=0;i<2;i++)\n\t{\n\t  for(int j=0;j<4;j++)\n\t    {\n\t      int nx = p.vp[i].F + dx[j];\n\t      int ny = p.vp[i].S + dy[j];\n\t      if(!(0<=ny && ny<p.state.size() && 0<=nx && nx<p.state[ny].size() && p.state[ny][nx] != -1))\n\t\tcontinue;\n\t      VVI next = change(p.state,p.vp[i],P(nx,ny));\n\t      map<VVI,int>::iterator it = bidirectional.find(next);\n\t      if(it == bidirectional.end() || (it != bidirectional.end() && bidirectional[next] > cost + 1))\n\t\t{\n\t\t  bidirectional[next] = cost + 1;\n\t\t  deq.push_back(Puzzle(next));\n\t\t}\n\n\t    }\n\n\t}      \n\n    }\n  \n  \n}\n\n\nint main()\n{\n  VVI puzzle;\n  Init();\n  //cout << \"here\" << endl;\n  while(Input(puzzle))\n    {\n \n      Puzzle puz(puzzle);\n      int men = (1<<28);\n      deque<Puzzle> deq;\n      deq.push_back(puz);\n      memo.clear();\n      memo[puzzle] = 0;\n\n      while(!deq.empty())\n\t{\n\t  Puzzle p = deq.front(); deq.pop_front();\n\t  int cost = memo[p.state];\n\t  //cout << \"cost : \" << cost << endl;\n\t  //p.print();\n\t  if(cost + p.Manhattan > min(20,men))\n\t    continue;\n\n\t  if(p.state == final)\n\t    {\n\t      men = min(men,cost);\n\t      continue;\n\t    }\n\t  else if(bidirectional.find(p.state) != bidirectional.end() && cost + bidirectional[p.state] <= 20)\n\t    {\n\t      men = min(men,cost+bidirectional[p.state]);\n\t      continue;\n\t    }\n       \n\t  for(int i=0;i<2;i++)\n\t    {\n\t      for(int j=0;j<4;j++)\n\t\t{\n  \n\t\t  int nx = p.vp[i].F + dx[j];\n\t\t  int ny = p.vp[i].S + dy[j];\n\t\t  if(!(0<=ny && ny<p.state.size() && 0<=nx && nx<p.state[ny].size() && p.state[ny][nx] != -1))\n\t\t    continue;\n\n\t\t  VVI next = change(p.state,p.vp[i],P(nx,ny));\n\t\t  map<VVI,int>::iterator it = memo.find(next);\n\t\t  if(it == memo.end() || (it != memo.end() &&  memo[next] > cost + 1) )\n\t\t    {\n\t\t      memo[next] = cost + 1;\n\t\t      deq.push_back(Puzzle(next));\n\t\t    }\n\n\t\t}\n\t    }\n\n\n\t}\n      if(men == (1<<28))\n\tcout << \"NA\" << endl;\n      else \n\tcout << men << endl;\n    }  \n\n    \n  return 0;\n}\n\n\n  /*  \n  deque<VVIVP> deq;\n  VP vec;\n  vec.push_back(P(0,0));\n  vec.push_back(P(0,4)); \n  deq.push_back(VVIVP(final,vec));\n  bidirectional[final] = 0;\n  while(!deq.empty())\n    {\n      VVIVP vvivp = deq.front(); deq.pop_front();\n      VVI vvi = vvivp.F;\n      VP vp = vvivp.S;\n      P p1,p2;\n      int cost = bidirectional[vvi];\n      if(cost >= 5)\n\tcontinue;\n      p1 = vp[0];\n      p2 = vp[1];\n      \n      for(int i=0;i<5;i++)\n\t{\n\t  int nx1 = p1.F + dx[i];\n\t  int ny1 = p1.S + dy[i];\n\n\t  if(!(0 <= ny1 && ny1 < vvi.size() && 0 <= nx1 && nx1 < vvi[ny1].size()))\n\t    continue;\n\n\t  for(int j=0;j<5;j++)\n\t    {\n\t      if(i == 4 && j == 4)\n\t\tcontinue;\n\t      int nx2 = p2.F + dx[j];\n\t      int ny2 = p2.S + dy[j];\n\n\t      if(!(0 <= ny2 && ny2 < vvi.size() && 0 <= nx2 && nx2 < vvi[ny2].size()))\n\t\tcontinue;\n\t      VVI new_vvi = change(vvi,p1,P(nx1,ny1),p2,P(nx2,ny2));\n\t      if(bidirectional.count(new_vvi) == 0 || (bidirectional.count(new_vvi) != 0 && bidirectional[new_vvi] > cost + 1))\n\t\t{\n\t\t  VP vip;\n\t\t  vip.push_back(P(nx1,ny1));\n\t\t  vip.push_back(P(nx2,ny2));\n\t\t  bidirectional[new_vvi] = cost+1;\n\t\t  deq.push_back(VVIVP(new_vvi,vip));\n\t\t}\n\n\t     \n\n\t    }\n\t}\n\n    }\n*/\n\n/*\n int men = (1<<28);\n      deque<VVIVP> deq;\n      bool fin = false;\n      deq.push_back(VVIVP(puzzle,ini));\n      memo[puzzle] = 0;\n      while(!deq.empty() && !fin)\n\t{\n\t  VVIVP vvivp = deq.front(); deq.pop_front();\n\t  VVI vvi = vvivp.F;\n\t  VP vp = vvivp.S;\n\t  P p1,p2;\n\t  p1 = vp[0], p2 = vp[1];\n\t \n\t  if((vvi == final || bidirectional.count(vvi) != 0) && memo[vvi] + bidirectional[vvi] <= min(20,men))\n\t    {\n\t      men = min(men,memo[vvi]+bidirectional[vvi]);\n\t      continue;\n\t    }\n\t  \n\t  int cost = memo[vvi];\n\n\t  if(men <= cost) \n\t    continue;\n\n\t  for(int i=0;i<5;i++)\n\t    {\n\t      int nx1 = p1.F + dx[i];\n\t      int ny1 = p1.S + dy[i];\n\n\t      if(!(0 <= ny1 && ny1 < vvi.size() && 0 <= nx1 && nx1 < vvi[ny1].size()))\n\t\tcontinue;\n\n\t      for(int j=0;j<5;j++)\n\t\t{\n\t\t  if(i = 4 && j == 4)\n\t\t    continue;\n\t\t  int nx2 = p2.F + dx[j];\n\t\t  int ny2 = p2.S + dy[j];\n\t\t  \n\t\t  if(!(0 <= ny2 && ny2 < vvi.size() && 0 <= nx2 && nx2 < vvi[ny2].size()))\n\t\t    continue;\n\n\t\t  //cout << \"change! \" << i << \" - \" << j << endl;\n\n\t\t  //cout <<\"cost = \" << cost << endl;\n\t\t   //print(change(vvi,p1,P(nx1,ny1),p2,P(nx2,ny2)));\n\t\t  VVI new_vvi = change(vvi,p1,P(nx1,ny1),p2,P(nx2,ny2));\n\t\t  if(memo.count(new_vvi) == 0 || (memo.count(new_vvi) != 0 && memo[new_vvi] > cost+1))\n\t\t    {\n\t\t \n\t\t      memo[new_vvi] = cost+1;\n\t\t      VP vip;\n\t\t      vip.push_back(P(nx1,ny1));\n\t\t      vip.push_back(P(nx2,ny2));\n\t\t      deq.push_back(VVIVP(new_vvi,vip));\n\t\t    }\n\n\n\t\t}\n\n\t    }\n\n\t}\n\n      if(men != (1<<28))\n\tcout << men << endl;\n      else \n\tcout << \"NA\" << endl;\n */\n\n\n/*\nwhile(Input(puzzle)){\n      int men = (1<<28);\n      deque<VVIVP> deq;\n      bool fin = false;\n      deq.push_back(VVIVP(puzzle,ini));\n      memo[puzzle] = 0;\n      while(!deq.empty())\n\t{\n\t  VVIVP vvivp = deq.front(); deq.pop_front();\n\t  VVI vvi = vvivp.F;\n\t  VP vp = vvivp.S;\n\t \n\t  if(vvi == final)\n\t    {\n\t      men = min(men,memo[vvi]);\n\t      fin = true;\n\t    }\n\t  else if(bidirectional.count(vvi) != 0 && memo[vvi] + bidirectional[vvi] <= 20)\n\t    {\n\t      fin = true;\n\t      men = min(men,memo[vvi]+bidirectional[vvi]);\n\t      break;\n\t    }\n\t \n\t  int cost = memo[vvi];\n\t  if(cost >= men)\n\t    continue;\n\n\t  //cout << \"cost = \" << cost << endl;\n\t  P p1,p2;\n\t  p1 = vp[0];\n\t  p2 = vp[1];\n\t  for(int k=0;k<5;k++)\n\t    {\n\t      int nx1,ny1;\n\t      nx1 = vp[0].F + dx[k];\n\t      ny1 = vp[0].S + dy[k];\n\t      if(!(0 <= ny1 && vvi.size() > ny1 && 0 <= nx1 && vvi[ny1].size() > nx1))\n\t\tcontinue;\n\n\t      for(int l=0;l<5;l++)\n\t\t{\n\t\t  int nx2,ny2;\n\t\n\t\t  nx2 = vp[1].F + dx[l];\n\t\t  ny2 = vp[1].S + dy[l];\n\n\t\t  if(!(0 <= ny2 && vvi.size() > ny2 && 0 <= nx2 && vvi[ny2].size() > nx2))\n\t\t    continue;\n\t\n\t\n\t\t  int tmp = vvi[p1.S][p1.F];\n\t\t  vvi[p1.S][p1.F] = vvi[ny1][nx1];\n\t\t  vvi[ny1][nx1] = tmp;\n\n\t\t  tmp = vvi[p2.S][p2.F];\n\t\t  vvi[p2.S][p2.F] = vvi[ny2][nx2];\n\t\t  vvi[ny2][nx2] = tmp;\n\t\n\n\t\t  if(cost+1 >= 20 && vvi != final)\n\t\t    continue;\n\n\t\t  if(cost+1 >= 20 && vvi == final)\n\t\t    {\n\t\t      fin = true;\n\t\t      printf(\"20\\n\");\n\t\t      break;\n\t\t    }\n\n\t\t  if((memo.count(vvi) != 0 && memo[vvi] > cost + 1) || memo.count(vvi) == 0)\n\t\t    {\n\t\t      VP vip;\n\t\t      vip.push_back(P(nx1,ny1));\n\t\t      vip.push_back(P(nx2,ny2));\n\t\t      memo[vvi] = cost + 1;\n\t\t      deq.push_back(VVIVP(vvi,vip)); \n\t\t    }\n\n\t\n\t\t  tmp = vvi[p1.S][p1.F];\n\t\t  vvi[p1.S][p1.F] = vvi[ny1][nx1];\n\t\t  vvi[ny1][nx1] = tmp;\n\n\t\t  tmp = vvi[p2.S][p2.F];\n\t\t  vvi[p2.S][p2.F] = vvi[ny2][nx2];\n\t\t  vvi[ny2][nx2] = tmp;\n\t\n\t\t}\n\t      if(fin)\n\t\tbreak;\n\t    }\n\t  if(fin)\n\t    break;\n\t}\n      if(!fin)\n\tprintf(\"NA\\n\");\n      else\n\tprintf(\"%d\\n\",men);\n    }\n\n */"
  },
  {
    "language": "C++",
    "code": "#include<bits/stdc++.h>\nusing namespace std;\n \ntypedef long long int64;\nconst int INF = 1 << 30;\n \nvector< int > edge[13];\nmap< string, int > memo;\n\nbool back(string str, int cnt){\n  static int dist[] = { 0, 2, 1, 2, 4, 3, 2, 3, 4, 2, 1, 2, 0};\n\n  if(cnt > 20) return true;\n  int foo = 0;\n  for(int i = 0; i < 13; i++){\n    if(str[i] == '0') foo += dist[i];\n  }\n  return cnt + foo > 20;\n}\n\n\nint bfs(string mas){\n\n  queue< string > que;\n  map< string , int > used;\n  que.push( mas );\n  memo[mas] = 0;\n  while(!que.empty()){\n\n    string p = que.front(); que.pop();\n    if(back( p, memo[p])) break;\n    if(p == \"0123456789AB0\") return memo[p];\n\n    for(int i = 0; i < 13; i++){\n      if(p[i] == '0') {\n        for(int j = 0; j < edge[i].size(); j++){\n          string next = p;\n          swap( next[i], next[edge[i][j]]);\n          if(memo.find(next) != memo.end()) continue;\n          que.push( next );\n          memo[next] = memo[p] + 1;\n        }\n      }\n    }\n  }\n  return -1;\n}\n\nint main(){\n  vector< int > mas(13);\n\n  edge[0].push_back(2);\n  edge[1].push_back(2); edge[1].push_back(4);\n  edge[2].push_back(0); edge[2].push_back(1); edge[2].push_back(3); edge[2].push_back(6);\n  edge[3].push_back(2); edge[3].push_back(7);\n  edge[4].push_back(5);\n  edge[5].push_back(1); edge[5].push_back(4); edge[5].push_back(6); edge[5].push_back(9);\n  edge[6].push_back(2); edge[6].push_back(5); edge[6].push_back(7); edge[6].push_back(10);\n  edge[7].push_back(3); edge[7].push_back(6); edge[7].push_back(8); edge[7].push_back(11);\n  edge[8].push_back(7);\n  edge[9].push_back(5); edge[9].push_back(10);\n  edge[10].push_back(6); edge[10].push_back(9); edge[10].push_back(11); edge[10].push_back(12);\n  edge[11].push_back(7); edge[11].push_back(10);\n  edge[12].push_back(10);\n\n  while(cin >> mas[0], mas[0] != -1){\n    for(int i = 1; i < 13; i++){\n      cin >> mas[i];\n    }\n\n    string start = \"\";\n    for(int i = 0; i < 13; i++){\n      if(mas[i] >= 10) start += (char)(mas[i] - 10 + 'A');\n      else start += mas[i] + '0';\n    }\n    int ret = bfs(start);\n    if(~ret) cout << ret << endl;\n    else cout << \"NA\" << endl;\n\n    memo.clear();\n  }\n}"
  },
  {
    "language": "C++",
    "code": "#include <cstdio>\n#include <cstdlib>\n#include <cmath>\n#include <climits>\n#include <cfloat>\n#include <map>\n#include <utility>\n#include <set>\n#include <iostream>\n#include <memory>\n#include <string>\n#include <vector>\n#include <algorithm>\n#include <functional>\n#include <sstream>\n#include <complex>\n#include <stack>\n#include <queue>\n#include <cstring>\n#include <sstream>\n#include <cassert>\n#include <list>\nusing namespace std;\nstatic const double EPS = 1e-10;\ntypedef long long ll;\ntypedef pair<int,int> PI;\ntypedef vector<int> vi;\n#ifndef M_PI\n#define M_PI 3.14159265358979323846\n#endif\n#define rep(i,n) for(int i=0;i<(int)n;++i)\n#define FOR(i,c) for(__typeof((c).begin())i=(c).begin();i!=(c).end();++i)\n#define ALL(c) (c).begin(), (c).end()\n#define mp(a,b) make_pair(a,b)\n#define pb(a) push_back(a)\n#define F first\n#define S second\ntemplate <typename T> string print_array(const vector<T> &V) { ostringstream os; os << \"{ \"; for (typename vector<T>::const_iterator iter = V.begin(); iter != V.end(); ++iter) os << '\\\"' << *iter << \"\\\",\"; os << \" }\"; return os.str(); }\n\nint dx[]={0,1,0,-1},dy[]={1,0,-1,0};\n\nvector<int> se[13];\nint x[]={0,-1,0,1,-2,-1,0,1,2,-1,0,1,0};\nint y[]={2,1,1,1,0,0,0,0,0,-1,-1,-1,-2};\n\nvoid pr(ll in){\n\n  printf(\"      %3lld\\n\",in&15);\n  printf(\"   %3lld%3lld%3lld\\n\",(in>>4)&15,(in>>8)&15,(in>>12)&15);\n  printf(\"%3lld%3lld%3lld%3lld%3lld\\n\",(in>>16)&15,(in>>20)&15,(in>>24)&15,(in>>28)&15,(in>>32)&15);\n  printf(\"   %3lld%3lld%3lld\\n\",(in>>36)&15,(in>>40)&15,(in>>44)&15);\n  printf(\"      %3lld\\n\",(in>>48)&15);\n  puts(\"\");\n}\n\nint manh(ll in){\n  int ret=0;\n  rep(i,13){\n    int t=(in>>(i*4))&15;\n\n    if(!t){\n      int nx=x[t]-x[i],ny=y[t]-y[i];\n      int co=abs(nx)+abs(ny);\n      nx=x[12]-x[i],ny=y[12]-y[i];\n      int k=abs(nx)+abs(ny);\n      ret+=min(co,k);\n      continue;\n    }\n    int nx=(x[t]-x[i]),ny=y[t]-y[i];\n    ret+=abs(nx)+abs(ny);\n  }\n  return ret;\n}\n\nmain(){\n  ll p;\n\n  ll goal=0;\n  rep(i,11){\n    goal|=(i+1LL)<<(4*(i+1));\n    //cout<<goal<<endl;\n    //pr(goal);\n  }\n  //pr(goal);\n\n  se[0].pb(2);\n  se[1].pb(2);\n  se[1].pb(5);\n  se[2].pb(0);\n  se[2].pb(1);\n  se[2].pb(3);\n  se[2].pb(6);\n  se[3].pb(2);\n  se[3].pb(7);\n  se[4].pb(5);\n  se[5].pb(1);\n  se[5].pb(4);\n  se[5].pb(6);\n  se[5].pb(9);\n  se[6].pb(2);\n  se[6].pb(5);\n  se[6].pb(7);\n  se[6].pb(10);\n  se[7].pb(3);\n  se[7].pb(6);\n  se[7].pb(8);\n  se[7].pb(11);\n  se[8].pb(7);\n  se[9].pb(5);\n  se[9].pb(10);\n  se[10].pb(6);\n  se[10].pb(9);\n  se[10].pb(11);\n  se[10].pb(12);\n  se[11].pb(7);\n  se[11].pb(10);\n  se[12].pb(10);\n  \n  while(cin>>p){\n    if(p==-1)break;\n    ll in=p;\n\n    rep(i,12){\n      cin>>p;\n      in|=p<<(4*(i+1));\n    }\n\n    set<ll> app;\n\n    queue<pair<int,ll> > Q;\n    app.insert(in);\n    Q.push(mp(0,in));\n    int ans=21;\n    int mans=0;\n\n    while(!Q.empty()){\n      ll cvec=Q.front().S;\n      int ccost=Q.front().F;\n      Q.pop();\n    \n      //pr(cvec);\n\n      //if(ccost>3)break;\n     \n      if(cvec==goal){\n\tans=ccost;\n\tbreak;\n      }\n      if(ccost+manh(cvec)>33)continue;\n      rep(i,13){\n\tll t=cvec>>(i<<2);\n\tt=t&15;\n\tif(!t){\n\t  rep(j,se[i].size()){\n\t    t=cvec>>(se[i][j]<<2);\n\t    t=t&15;\n\t    if(t){\n\t      ll nvec=cvec;\n\t      t=t<<(i<<2);\n\t      nvec|=t;\n\t      nvec&=~(15LL<<se[i][j]*4);\n\t      \n\t      if(!app.count(nvec)){\n\t\tapp.insert(nvec);\n\t\tQ.push(mp(ccost+1,nvec));\n\t      }\n\t    }\n\t  }\n\t}\n      }\n    }\n    if(ans==21)cout<<\"NA\"<<endl;\n    else cout<<ans<<endl;\n  }\n}"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\n\nusing namespace std;\n\n#define FOR(i,a,b) for(int i=(a);i<(b);i++)\n#define REP(i,n) FOR(i,0,n)\n#define ALL(v) (v).begin(),(v).end()\n#define fi first\n#define se second\n\ntemplate<typename A, typename B> inline bool chmax(A &a, B b) { if (a<b) { a=b; return 1; } return 0; }\ntemplate<typename A, typename B> inline bool chmin(A &a, B b) { if (a>b) { a=b; return 1; } return 0; }\n\ntypedef long long ll;\ntypedef pair<int, int> pii;\ntypedef pair<ll, ll> pll;\ntypedef pair<int, pll> pip;\nconst ll INF = 1ll<<29;\nconst ll MOD = 1000000007;\nconst double EPS  = 1e-9;\n\nint dd[13][4] = {\n\t{2,-1,-1,-1},\n\t{2,5,-1,-1},\n\t{0,1,3,6},\n\t{2,7,-1,-1},\n\t{5,-1,-1,-1},\n\t{1,4,6,9},\n\t{2,5,7,10},\n\t{3,6,8,11},\n\t{7,-1,-1,-1},\n\t{5,10,-1,-1},\n\t{6,9,11,12},\n\t{7,10,-1,-1},\n\t{10,-1,-1,-1}\n};\n\nint main() {\n\tqueue<string> que;\n\tmap<string, int> d;\n\t\n\tque.push(\"abcdefghijkla\");\n\td[\"abcdefghijkla\"] = 0;\n\t\n\twhile (!que.empty()) {\n\t\tstring now = que.front(); que.pop();\n\t\tint cost = d[now];\n\t\t\n\t\tif (cost > 10) break;\n\t\t\n\t\tREP(i, 13) if (now[i] == 'a') {\n\t\t\tREP(j, 4) {\n\t\t\t\tif (dd[i][j] == -1) break;\n\t\t\t\t\n\t\t\t\tswap(now[i], now[dd[i][j]]);\n\t\t\t\tif (d.find(now) == d.end()) {\n\t\t\t\t\td[now] = cost + 1;\n\t\t\t\t\tque.push(now);\n\t\t\t\t}\n\t\t\t\tswap(now[i], now[dd[i][j]]);\n\t\t\t}\n\t\t}\n\t}\n\twhile (!que.empty()) que.pop();\n\t\n\tint p[13];\n\twhile (cin >> p[0], ~p[0]) {\n\t\tFOR(i, 1, 13) cin >> p[i];\n\t\tstring st = \"\";\n\t\tREP(i, 13) st += p[i] + 'a';\n\t\t\n\t\tmap<string, int> d2;\n\t\tque.push(st);\n\t\td2[st] = 0;\n\t\t\n\t\tint ans = INF;\n\t\t\n\t\twhile (!que.empty()) {\n\t\t\tstring now = que.front(); que.pop();\n\t\t\tint cost = d2[now];\n\t\t\t\n\t\t\tif (cost > 10) break;\n\t\t\tif (d.find(now) != d.end()) chmin(ans, d[now] + d2[now]);\n\t\t\t\n\t\t\tREP(i, 13) if (now[i] == 'a') {\n\t\t\t\tREP(j, 4) {\n\t\t\t\t\tif (dd[i][j] == -1) break;\n\t\t\t\t\t\n\t\t\t\t\tswap(now[i], now[dd[i][j]]);\n\t\t\t\t\tif (d2.find(now) == d2.end()) {\n\t\t\t\t\t\td2[now] = cost + 1;\n\t\t\t\t\t\tque.push(now);\n\t\t\t\t\t}\n\t\t\t\t\tswap(now[i], now[dd[i][j]]);\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t\twhile (!que.empty()) que.pop();\n\t\t\n\t\tif (ans <= 20) cout << ans << endl;\n\t\telse puts(\"NA\");\n\t}\n\treturn 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include <cstdio>\n#include <cstdlib>\n#include <cmath>\n#include <climits>\n#include <cfloat>\n#include <map>\n#include <utility>\n#include <set>\n#include <iostream>\n#include <memory>\n#include <string>\n#include <vector>\n#include <algorithm>\n#include <functional>\n#include <sstream>\n#include <complex>\n#include <stack>\n#include <queue>\n#include <cstring>\n#include <sstream>\n#include <cassert>\n#include <list>\nusing namespace std;\nstatic const double EPS = 1e-10;\ntypedef long long ll;\ntypedef pair<int,int> PI;\ntypedef vector<int> vi;\n#ifndef M_PI\n#define M_PI 3.14159265358979323846\n#endif\n#define rep(i,n) for(int i=0;i<(int)n;++i)\n#define FOR(i,c) for(__typeof((c).begin())i=(c).begin();i!=(c).end();++i)\n#define ALL(c) (c).begin(), (c).end()\n#define mp(a,b) make_pair(a,b)\n#define pb(a) push_back(a)\n#define F first\n#define S second\ntemplate <typename T> string print_array(const vector<T> &V) { ostringstream os; os << \"{ \"; for (typename vector<T>::const_iterator iter = V.begin(); iter != V.end(); ++iter) os << '\\\"' << *iter << \"\\\",\"; os << \" }\"; return os.str(); }\n\nint dx[]={0,1,0,-1},dy[]={1,0,-1,0};\n\nvector<int> se[13];\nint x[]={0,-1,0,1,-2,-1,0,1,2,-1,0,1,0};\nint y[]={2,1,1,1,0,0,0,0,0,-1,-1,-1,-2};\n\nvoid pr(ll in){\n\n  printf(\"      %3lld\\n\",in&15);\n  printf(\"   %3lld%3lld%3lld\\n\",(in>>4)&15,(in>>8)&15,(in>>12)&15);\n  printf(\"%3lld%3lld%3lld%3lld%3lld\\n\",(in>>16)&15,(in>>20)&15,(in>>24)&15,(in>>28)&15,(in>>32)&15);\n  printf(\"   %3lld%3lld%3lld\\n\",(in>>36)&15,(in>>40)&15,(in>>44)&15);\n  printf(\"      %3lld\\n\",(in>>48)&15);\n  puts(\"\");\n}\n\nint manh(ll in){\n  int ret=0;\n  rep(i,13){\n    int t=(in>>(i*4))&15;\n\n    if(!t)continue;\n    int nx=(x[t]-x[i]),ny=y[t]-y[i];\n    ret+=abs(nx)+abs(ny);\n  }\n  return ret;\n}\n\nmain(){\n  ll p;\n\n  ll goal=0;\n  rep(i,11){\n    goal|=(i+1LL)<<(4*(i+1));\n    //cout<<goal<<endl;\n    //pr(goal);\n  }\n  //pr(goal);\n\n  se[0].pb(2);\n  se[1].pb(2);\n  se[1].pb(5);\n  se[2].pb(0);\n  se[2].pb(1);\n  se[2].pb(3);\n  se[2].pb(6);\n  se[3].pb(2);\n  se[3].pb(7);\n  se[4].pb(5);\n  se[5].pb(1);\n  se[5].pb(4);\n  se[5].pb(6);\n  se[5].pb(9);\n  se[6].pb(2);\n  se[6].pb(5);\n  se[6].pb(7);\n  se[6].pb(10);\n  se[7].pb(3);\n  se[7].pb(6);\n  se[7].pb(8);\n  se[7].pb(11);\n  se[8].pb(7);\n  se[9].pb(5);\n  se[9].pb(10);\n  se[10].pb(6);\n  se[10].pb(9);\n  se[10].pb(11);\n  se[10].pb(12);\n  se[11].pb(7);\n  se[11].pb(10);\n  se[12].pb(10);\n  \n  while(cin>>p){\n    if(p==-1)break;\n    ll in=p;\n\n    rep(i,12){\n      cin>>p;\n      in|=p<<(4*(i+1));\n    }\n\n    set<ll> app;\n\n    queue<pair<int,ll> > Q;\n    app.insert(in);\n    Q.push(mp(0,in));\n    int ans=21;\n    int mans=0;\n\n    while(!Q.empty()){\n      ll cvec=Q.front().S;\n      int ccost=Q.front().F;\n      Q.pop();\n    \n      //pr(cvec);\n\n      //if(ccost>3)break;\n      if(ccost+manh(cvec)>26)continue;\n      if(cvec==goal){\n\tans=ccost;\n\tbreak;\n      }\n      rep(i,13){\n\tll t=cvec>>(i<<2);\n\tt=t&15;\n\tif(!t){\n\t  rep(j,se[i].size()){\n\t    t=cvec>>(se[i][j]<<2);\n\t    t=t&15;\n\t    if(t){\n\t      ll nvec=cvec;\n\t      t=t<<(i<<2);\n\t      nvec|=t;\n\t      nvec&=~(15LL<<se[i][j]*4);\n\t      \n\t      if(!app.count(nvec)){\n\t\tapp.insert(nvec);\n\t\tQ.push(mp(ccost+1,nvec));\n\t      }\n\t    }\n\t  }\n\t}\n      }\n    }\n    if(ans==21)cout<<\"NA\"<<endl;\n    else cout<<ans<<endl;\n  }\n}"
  },
  {
    "language": "C++",
    "code": "#include <iostream>\n#include <map>\n#include <queue>\n#include <cstdlib>\n#include <vector>\nusing namespace std;\n#define rep(i,n) for(int i=0;i<n;i++)\n\nint to[13][5] = {\n\t{2,-1},\n\t{2,5,-1},\n\t{0,1,3,6,-1},\n\t{2,7,-1},\n\t{5,-1},\n\t{1,4,6,9,-1},\n\t{2,5,7,10,-1},\n\t{3,6,8,11,-1},\n\t{7,-1},\n\t{5,10,-1},\n\t{6,9,11,12},\n\t{7,10,-1},\n\t{10,-1}\n};\nint solve(vector<int> data){\n\tqueue< vector<int> > Q;\n\tmap<vector<int>,int> done;\n\tQ.push(data);\n\tdone[Q.front()] = 0;\n\t\n\twhile(Q.size()){\n\t\tvector<int> q = Q.front(); Q.pop();\n\t\tint dif = 0;\n\t\trep(i,13)if(q[i])dif += abs(i-q[i]);\n\t\tif(dif==0)return done[q];\n\t\tif(dif/4+done[q]>=20)continue;\n\t\tint curcost = done[q];\n\t\trep(x,13){\n\t\t\tif(q[x] == 0){\n\t\t\t\trep(i,5){\n\t\t\t\t\tif(!~to[x][i])break;\n\t\t\t\t\tswap(q[x],q[to[x][i]]);\n\t\t\t\t\tif(done.find(q) == done.end() ){\n\t\t\t\t\t\tdone[q] = curcost+1;\n\t\t\t\t\t\tQ.push(q);\n\t\t\t\t\t}\n\t\t\t\t\tswap(q[x],q[to[x][i]]);\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t}\n\treturn 21;\n}\nint main(){\n\tvector<int> data(13);\n\twhile(1){\n\t\trep(i,13)if(!(cin >> data[i]))return 0;\n\t\tint ans = solve(data);\n\t\tif(ans > 20)cout << \"NA\" << endl;\n\t\telse cout << ans << endl;\n\t}\n}"
  },
  {
    "language": "C++",
    "code": "#include <iostream>\n#include <map>\n#include <queue>\n#include <cstdlib>\n#include <vector>\nusing namespace std;\n#define rep(i,n) for(int i=0;i<n;i++)\n\nint to[13][5] = {\n\t{2,-1},\n\t{2,5,-1},\n\t{0,1,3,6,-1},\n\t{2,7,-1},\n\t{5,-1},\n\t{1,4,6,9,-1},\n\t{2,5,7,10,-1},\n\t{3,6,8,11,-1},\n\t{7,-1},\n\t{5,10,-1},\n\t{6,9,11,12},\n\t{7,10,-1},\n\t{10,-1}\n};\nint X[]={2,1,2,3,0,1,2,3,4,1,2,3,2};\nint Y[]={0,1,1,1,2,2,2,2,2,3,3,3,4};\n\nint solve(vector<int> data){\n\tqueue< vector<int> > Q;\n\tmap<vector<int>,int> done;\n\tQ.push(data);\n\tdone[Q.front()] = 0;\n\t\n\twhile(Q.size()){\n\t\tvector<int> q = Q.front(); Q.pop();\n\t\tint dif = 0;\n\t\trep(i,13)if(q[i])dif += abs(X[q[i]]-X[i])+abs(Y[q[i]]-Y[i]);\n\t\tif(dif==0)return done[q];;\n\t\tif(dif+done[q]>20)continue;\n\t\tint curcost = done[q];\n\t\trep(x,13){\n\t\t\tif(q[x] == 0){\n\t\t\t\trep(i,5){\n\t\t\t\t\tif(!~to[x][i])break;\n\t\t\t\t\tswap(q[x],q[to[x][i]]);\n\t\t\t\t\tif(done.find(q) == done.end() ){\n\t\t\t\t\t\tdone[q] = curcost+1;\n\t\t\t\t\t\tQ.push(q);\n\t\t\t\t\t}\n\t\t\t\t\tswap(q[x],q[to[x][i]]);\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t}\n\treturn 21;\n}\nint main(){\n\tvector<int> data(13);\n\twhile(1){\n\t\trep(i,13)if(!(cin >> data[i]))return 0;\n\t\tint ans = solve(data);\n\t\tif(ans > 20)cout << \"NA\" << endl;\n\t\telse cout << ans << endl;\n\t}\n}"
  },
  {
    "language": "C++",
    "code": "#include <iostream>\n#include <vector>\n#include <algorithm>\n#include <string>\n#include <sstream>\n#include <cstring>\n#include <cstdio>\n#include <cstdlib>\n#include <cmath>\n#include <queue>\n#include <stack>\n#include <map>\n#include <set>\n#include <numeric>\n#include <cctype>\n#include <tuple>\n\n#ifdef _MSC_VER\n#include <agents.h>\n#endif\n\n#define FOR(i, a, b) for(int i = (a); i < (int)(b); ++i)\n#define rep(i, n) FOR(i, 0, n)\n#define ALL(v) v.begin(), v.end()\n#define REV(v) v.rbegin(), v.rend()\n#define MEMSET(v, s) memset(v, s, sizeof(v))\n#define X first\n#define Y second\n\nusing namespace std;\n\ntypedef long long ll;\ntypedef pair<int, int> P;\n\nconst int N = 0;\n\ninline int dist(int x1, int y1, int x2, int y2){\n\treturn abs(x1 - x2) + abs(y1 - y2);\n}\n\ninline bool valid(int x, int y){\n\treturn abs(x - 2) + abs(y - 2) <= 2;\n}\n\nvoid decode(ll x);\n\nll mov(ll state, int zero, int to){\n\tll mask = 15ll << to*4;\n\tmask &= state;\n\tstate ^= mask;\n\tint d = to - zero;\n\tif (d < 0) state |= mask << -d*4;\n\telse state |= mask >> d*4;\n\treturn state;\n}\n\nvoid decode(ll x){\n\tvector<string> vs;\n\trep(i, 5){\n\t\tstring s;\n\t\trep(j, 5){\n\t\t\tif (valid(j, i)){\n\t\t\t\tint tmp = x & 15;\n\t\t\t\ts += \" \";\n\t\t\t\ts += '0' + tmp % 10;\n\t\t\t\ts += '0' + tmp / 10;\n\t\t\t\tx >>= 4;\n\t\t\t}\n\t\t\telse{\n\t\t\t\ts += \" ..\";\n\t\t\t}\n\t\t}\n\t\tvs.push_back(string(REV(s)));\n\t}\n\treverse(ALL(vs));\n\tfor (auto &s : vs){\n\t\tcout << s << endl;\n\t}\n}\n\nint mat[5][5];\n\nstruct state{\n\tll enc;\n\tint d;\n\tint pos[2];\n\tstate(ll e, int p0, int p1, int d) :enc(e), d(d){ pos[0] = p0, pos[1] = p1; };\n};\n\nint main(){\n\n\tint pos = 0;\n\tvector<vector<int>> adj;\n\t{\n\t\tint tmp = 0;\n\t\trep(i, 5) rep(j, 5) if (valid(j, i)) mat[i][j] = tmp++;\n\t}\n\trep(i, 5) rep(j, 5){\n\t\tvector<int> v;\n\t\tif (!valid(j, i)) continue;\n\t\trep(k, 5) rep(l, 5){\n\t\t\tif (!valid(l, k)) continue;\n\t\t\tif (dist(j, i, l, k) != 1) continue;\n\t\t\tv.push_back(mat[k][l]);\n\t\t}\n\t\tadj.push_back(v);\n\t}\n\n\tll init = 0;\n\tint tmp = 0;\n\trep(i, 5) rep(j, 5){\n\t\tif (!valid(j, i)) continue;\n\t\tinit <<= 4;\n\t\tinit |= (tmp++) % 12;\n\t}\n\n\tmap<ll, int> d;\n\td[init] = 0;\n\tqueue<state> q;\n\tq.push({ init, 0, 12, 0 });\n\twhile (!q.empty()){\n\t\tstate s = q.front();\n\t\tq.pop();\n\n\t\trep(i, 2){\n\t\t\tfor (auto to : adj[s.pos[i]]){\n\t\t\t\tll nxt = mov(s.enc, s.pos[i], to);\n\t\t\t\tif (d.count(nxt)) continue;\n\t\t\t\td[nxt] = s.d + 1;\n\t\t\t\tif (s.d + 1 < 20) q.push({ nxt, s.pos[!i], to, s.d + 1 });\n\t\t\t}\n\t\t}\n\t}\n\n\tll x;\n\twhile (cin >> x, ~x){\n\t\tint in;\n\t\trep(i, 12){\n\t\t\tcin >> in;\n\t\t\tx = (x << 4) + in;\n\t\t}\n\t\t//decode(x);\n\t\tif (d.count(x)) cout << d[x] << endl;\n\t\telse cout << \"NA\" << endl;\n\t}\n\n\n\treturn 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include<iostream>\n#include<vector>\n#include<map>\n#include<queue>\n#include<algorithm>\nusing namespace std;\n\nconst int N = 13;\nconst vector<vector<int>> NEXT = {\n    {2},\n    {2, 5},\n    {0, 1, 3, 6},\n    {2, 7},\n    {5},\n    {1, 4, 6, 9},\n    {2, 5, 7, 10},\n    {3, 6, 8, 11},\n    {7},\n    {5, 10},\n    {6, 9, 11, 12},\n    {7, 10},\n    {10},\n};\n\nclass Node {\npublic:\n    vector<int> puzzle;\n    int depth;\n    Node(const vector<int>& p, int d) :puzzle(p), depth(d) {}\n};\n\nmap<vector<int>, int> memo1;\nmap<vector<int>, int> memo2;\n\nvoid bfs(const vector<int>& puzzle, map<vector<int>, int>& memo) {\n    queue<Node> q;\n    q.push(Node(puzzle, 0));\n    while(!q.empty()) {\n        Node current(q.front()); q.pop();\n        if(current.depth > 10) continue;\n        if(memo.count(current.puzzle)) continue;\n        memo[current.puzzle] = current.depth;\n        for(int i = 0; i < N; ++i) {\n            if(current.puzzle[i] != 0) continue;\n            for(const auto& j: NEXT[i]) {\n                vector<int> next(current.puzzle);\n                swap(next[i], next[j]);\n                q.push(Node(next, current.depth + 1));\n            }\n        }\n    }\n}\n\nint main() {\n    vector<int> complete = {0, 1, 2, 3, 4, 5, 6, 7, 8, 9, 10, 11, 0};\n    vector<int> puzzle(N);\n    bfs(complete, memo1);\n    while(cin >> puzzle[0], puzzle[0] != -1) {\n        for(int i = 1; i < N; ++i) cin >> puzzle[i];\n        memo2.clear();\n        bfs(puzzle, memo2);\n        int answer = 21;\n        for(auto& i: memo1) if(memo2.count(get<0>(i))) answer = min(answer, get<1>(i) + memo2[get<0>(i)]);\n        if(answer > 20) cout << \"NA\" << endl;\n        else cout << answer << endl;\n    }\n}"
  },
  {
    "language": "C++",
    "code": "#include <stdio.h>\n#include <cmath>\n#include <algorithm>\n#include <cfloat>\n#include <stack>\n#include <queue>\n#include <vector>\n#include <string>\n#include <iostream>\n#include <set>\n#include <map>\ntypedef long long int ll;\ntypedef unsigned long long int ull;\n#define BIG_NUM 2000000000\n#define MOD 1000000007\n#define EPS 0.000000001\nusing namespace std;\n\nstruct Info{\n\tshort table[5][5];\n\tint space_row1,space_col1,space_row2,space_col2;\n};\n\nmap<string,bool> MAP;\n\nbool rangeCheck(int row,int col){\n\tif(row < 0 || row >= 5)return false;\n\n\tswitch(row){\n\tcase 0:\n\t\tif(col == 2)return true;\n\t\tbreak;\n\tcase 1:\n\t\tif(col >= 1 && col <= 3)return true;\n\t\tbreak;\n\tcase 2:\n\t\tif(col >= 0 && col <= 4)return true;\n\t\tbreak;\n\tcase 3:\n\t\tif(col >= 1 && col <= 3)return true;\n\t\tbreak;\n\tcase 4:\n\t\tif(col == 2)return true;\n\t\tbreak;\n\t}\n\treturn false;\n}\n\nbool clearFLG;\nint ans;\nint p[13];\nint diff_row[4] = {-1,0,0,1},diff_col[4] = {0,-1,1,0};\n\n\nvoid copyInfo(Info& to,Info from){\n\n\tfor(int row = 0; row <= 4; row++){\n\t\tfor(int col = 0; col <= 4; col++){\n\t\t\tto.table[row][col] = from.table[row][col];\n\t\t}\n\t}\n}\n\nint calc_manhattan_sum(Info info){\n\n\tint sum = 0;\n\tfor(int row = 0; row <= 4; row++){\n\t\tfor(int col = 0; col <= 4; col++){\n\t\t\tif(rangeCheck(row,col) == true && info.table[row][col] != 0){\n\t\t\t\tswitch(info.table[row][col]){\n\t\t\t\tcase 1:\n\t\t\t\t\tsum += abs(row-1)+abs(col-1);\n\t\t\t\t\tbreak;\n\t\t\t\tcase 2:\n\t\t\t\t\tsum += abs(row-1)+abs(col-2);\n\t\t\t\t\tbreak;\n\t\t\t\tcase 3:\n\t\t\t\t\tsum += abs(row-1)+abs(col-3);\n\t\t\t\t\tbreak;\n\t\t\t\tcase 4:\n\t\t\t\t\tsum += abs(row-2)+abs(col-0);\n\t\t\t\t\tbreak;\n\t\t\t\tcase 5:\n\t\t\t\t\tsum += abs(row-2)+abs(col-1);\n\t\t\t\t\tbreak;\n\t\t\t\tcase 6:\n\t\t\t\t\tsum += abs(row-2)+abs(col-2);\n\t\t\t\t\tbreak;\n\t\t\t\tcase 7:\n\t\t\t\t\tsum += abs(row-2)+abs(col-3);\n\t\t\t\t\tbreak;\n\t\t\t\tcase 8:\n\t\t\t\t\tsum += abs(row-2)+abs(col-4);\n\t\t\t\t\tbreak;\n\t\t\t\tcase 9:\n\t\t\t\t\tsum += abs(row-3)+abs(col-1);\n\t\t\t\t\tbreak;\n\t\t\t\tcase 10:\n\t\t\t\t\tsum += abs(row-3)+abs(col-2);\n\t\t\t\t\tbreak;\n\t\t\t\tcase 11:\n\t\t\t\t\tsum += abs(row-3)+abs(col-3);\n\t\t\t\t\tbreak;\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t}\n\treturn sum;\n}\n\n\nvoid recursive(Info info,int depth,int max_depth){\n\n\tif(clearFLG)return;\n\n\tif(depth == max_depth){\n\t\tif(info.table[1][1] == 1 && info.table[1][2] == 2 && info.table[1][3] == 3 &&\n\t\t\t\tinfo.table[2][0] == 4 && info.table[2][1] == 5 && info.table[2][2] == 6 && info.table[2][3] == 7 && info.table[2][4] == 8 &&\n\t\t\t\tinfo.table[3][1] == 9 && info.table[3][2] == 10 && info.table[3][3] == 11){\n\t\t\tclearFLG = true;\n\t\t}\n\t\treturn;\n\t}\n\n\tint adj_row,adj_col;\n\n\tfor(int i = 0; i < 4; i++){\n\t\tadj_row = info.space_row1+diff_row[i];\n\t\tadj_col = info.space_col1+diff_col[i];\n\n\t\tif(rangeCheck(adj_row,adj_col) == false || info.table[adj_row][adj_col] == 0)continue;\n\n\t\tInfo next_info;\n\t\tcopyInfo(next_info,info);\n\n\t\tswap(next_info.table[info.space_row1][info.space_col1],next_info.table[adj_row][adj_col]);\n\n\t\tstring tmp;\n\t\tfor(int row = 0; row <= 4; row++){\n\t\t\tfor(int col = 0; col <= 4; col++){\n\t\t\t\tif(rangeCheck(row,col)){\n\t\t\t\t\ttmp.append(to_string(next_info.table[row][col])).append(to_string('*'));\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\n\t\tauto at = MAP.find(tmp);\n\t\tif(at != MAP.end())continue;\n\n\t\tMAP[tmp] = true;\n\n\t\tnext_info.space_row1 = adj_row;\n\t\tnext_info.space_col1 = adj_col;\n\t\tnext_info.space_row2 = info.space_row2;\n\t\tnext_info.space_col2 = info.space_col2;\n\n\t\tif(max_depth-(depth+1) < calc_manhattan_sum(next_info))continue;\n\n\t\trecursive(next_info,depth+1,max_depth);\n\t}\n\n\tfor(int i = 0; i < 4; i++){\n\t\tadj_row = info.space_row2+diff_row[i];\n\t\tadj_col = info.space_col2+diff_col[i];\n\n\t\tif(rangeCheck(adj_row,adj_col) == false || info.table[adj_row][adj_col] == 0)continue;\n\n\t\tInfo next_info;\n\t\tcopyInfo(next_info,info);\n\n\t\tswap(next_info.table[info.space_row2][info.space_col2],next_info.table[adj_row][adj_col]);\n\n\t\tstring tmp;\n\t\tfor(int row = 0; row <= 4; row++){\n\t\t\tfor(int col = 0; col <= 4; col++){\n\t\t\t\tif(rangeCheck(row,col)){\n\t\t\t\t\ttmp.append(to_string(next_info.table[row][col])).append(to_string('*'));\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\n\t\tauto at = MAP.find(tmp);\n\t\tif(at != MAP.end())continue;\n\n\t\tMAP[tmp] = true;\n\n\t\tnext_info.space_row1 = info.space_row1;\n\t\tnext_info.space_col1 = info.space_col1;\n\t\tnext_info.space_row2 = adj_row;\n\t\tnext_info.space_col2 = adj_col;\n\n\t\tif(max_depth-(depth+1) < calc_manhattan_sum(next_info))continue;\n\n\t\trecursive(next_info,depth+1,max_depth);\n\t}\n}\n\nvoid func(){\n\n\tfor(int i = 1; i < 13; i++)scanf(\"%d\",&p[i]);\n\n\tInfo first;\n\tfirst.table[0][2] = p[0];\n\tfor(int i = 1; i <= 3; i++)first.table[1][i] = p[i];\n\tfor(int i = 0; i <= 4; i++)first.table[2][i] = p[4+i];\n\tfor(int i = 1; i <= 3; i++)first.table[3][i] = p[8+i];\n\tfirst.table[4][2] = p[12];\n\n\tint count = 0;\n\n\tfor(int row = 0; row <= 4; row++){\n\t\tfor(int col = 0; col <= 4; col++){\n\t\t\tif(rangeCheck(row,col) == true && first.table[row][col] == 0){\n\t\t\t\tif(count == 0){\n\t\t\t\t\tfirst.space_row1 = row;\n\t\t\t\t\tfirst.space_col1 = col;\n\t\t\t\t\tcount++;\n\t\t\t\t}else{\n\t\t\t\t\tfirst.space_row2 = row;\n\t\t\t\t\tfirst.space_col2 = col;\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t}\n\n\tclearFLG = false;\n\n\tfor(int max_depth = 0; max_depth <= 20; max_depth++){\n\t\tMAP.clear();\n\n\t\tstring tmp;\n\t\tfor(int row = 0; row <= 4; row++){\n\t\t\tfor(int col = 0; col <= 4; col++){\n\t\t\t\tif(rangeCheck(row,col)){\n\t\t\t\t\ttmp.append(to_string(first.table[row][col])).append(to_string('*'));\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\n\t\tMAP[tmp] = true;\n\n\t\trecursive(first,0,max_depth);\n\t\tif(clearFLG){\n\t\t\tans = max_depth;\n\t\t\tbreak;\n\t\t}\n\t}\n\n\tif(clearFLG){\n\t\tprintf(\"%d\\n\",ans);\n\t}else{\n\t\tprintf(\"NA\\n\");\n\t}\n}\n\nint main(){\n\n\twhile(true){\n\t\tscanf(\"%d\",&p[0]);\n\t\tif(p[0] == -1)break;\n\n\t\tfunc();\n\t}\n\n\treturn 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\nusing namespace std;\nconst int pos_x[] = {0, 1, 1, 1, 2, 2, 2, 2, 2, 3, 3, 3, 4};\nconst int pos_y[] = {2, 1, 2, 3, 0, 1, 2, 3, 4, 1, 2, 3, 2};\nconst int table[][5] = {\n\t{2, -1},\n\t{2, 5, -1},\n\t{0, 1, 3, 6, -1},\n\t{2, 7, -1},\n\t{5, -1},\n\t{1, 4, 6, 9, -1},\n\t{2, 5, 7, 10, -1},\n\t{3, 6, 8, 11, -1},\n\t{7, -1},\n\t{5, 10, -1},\n\t{6, 9, 11, 12, -1},\n\t{7, 10, -1},\n\t{10, -1},\n};\n\nstruct Puzzle {\n\tvector<int> val;\n\tPuzzle(): val(13){}\n\tint score(){\n\t\tint res = 0;\n\t\tfor (int i = 0; i < 13; i++){\n\t\t\tif (!val[i]) continue;\n\t\t\tint v = val[i];\n\t\t\tres += abs(pos_x[v] - pos_x[i]);\n\t\t\tres += abs(pos_y[v] - pos_y[i]);\n\t\t}\n\t\treturn res;\n\t}\n\tvoid show(){\n\t\tfor (int i = 0; i < 13; i++){\n\t\t\tprintf(\"%d \", val[i]);\n\t\t\tif (i == 0 || i == 3 || i == 8 || i == 11 || i == 12){\n\t\t\t\tputs(\"\");\n\t\t\t}\n\t\t}\n\t}\n};\n\n/*inline bool check(Puzzle &p)\n{\n\tfor (int i = 1; i <= 11; i++){\n\t\tif (p.val[i] != i) return false;\n\t}\n\treturn true;\n}*/\n\nbool search(int d, Puzzle &p)\n{\n\tif (p.score() == 0) return true;\n\tif (d == 0) return false;\n\t\n\tfor (int i = 0; i < 13; i++){\n\t\tif (p.val[i]) continue;\n\t\tfor (const int *to = &table[i][0]; ~(*to); to++){\n\t\t\tswap(p.val[i], p.val[*to]);\n\t\t\t//printf(\"%d %d\\n\", i, *to);\n\t\t\t//printf(\"%d\\n\", p.score());\n\t\t\tif (d - 1 - p.score() >= 0){\n\t\t\t\tif (search(d - 1, p)) return true;\n\t\t\t}\n\t\t\tswap(p.val[i], p.val[*to]);\n\t\t}\n\t}\n\treturn false;\n}\n\nvoid solve(Puzzle &p)\n{\n\tfor (int d = 0; d <= 20; d++){\n\t\tif (search(d, p)){\n\t\t\tprintf(\"%d\\n\", d);\n\t\t\treturn;\n\t\t}\n\t}\n\tputs(\"NA\");\n}\n\nint main()\n{\t\n\tPuzzle p;\n\twhile (true){\n\t\tfor (int i = 0; i < 13; i++){\n\t\t\tscanf(\"%d\", &p.val[i]);\n\t\t\tif (p.val[i] == -1) return 0;\n\t\t}\n\t\tsolve(p);\n\t}\n}"
  },
  {
    "language": "C++",
    "code": "#include <iostream>\n#include <algorithm>\n#include <vector>\n#include <cstring>\n#include <cstdio>\n#include <climits>\n\nusing namespace std;\n\n#define REP(i,a,n) for(int i=(a); i<(int)(n); i++)\n#define rep(i,n) REP(i,0,n)\n#define DEB 0\n\n/*\n  1 = [2][2]\n  2 = [2][3]\n  3 = [2][4]\n  4 = [3][1]\n  5 = [3][2]\n  6 = [3][3]\n  7 = [3][4]\n  8 = [3][5]\n  9 = [4][2]\n  10= [4][3]\n  11= [4][4]\n*/\nint board[7][7]; //1base\nint sx[2], sy[2];\nstatic const int dx[] = {0,0,1,-1};\nstatic const int dy[] = {1,-1,0,0};\n\n/*\n(y,x)\n */\nint calc(int y, int x){\n    switch(board[y][x]){\n    case 1: return abs(2-y)+abs(2-x);\n    case 2: return abs(2-y)+abs(3-x);\n    case 3: return abs(2-y)+abs(4-x);\n    case 4: return abs(3-y)+abs(1-x);\n    case 5: return abs(3-y)+abs(2-x);\n    case 6: return abs(3-y)+abs(3-x);\n    case 7: return abs(3-y)+abs(4-x);\n    case 8: return abs(3-y)+abs(5-x);\n    case 9: return abs(4-y)+abs(2-x);\n    case 10: return abs(4-y)+abs(3-x);\n    case 11: return abs(4-y)+abs(4-x);\n    }\n    return -1;\n}\nint dist(void){\n    int ret = 0;\n    if( board[1][3] ) ret += calc(1,3);\n    rep(i,3) if( board[2][2+i] ) ret += calc(2,2+i);\n    rep(i,5) if( board[3][1+i] ) ret += calc(3,1+i);\n    rep(i,3) if( board[4][2+i] ) ret += calc(4,2+i);\n    if( board[5][3] ) ret += calc(5,3);\n    return ret;\n}\nbool isgoal(void){\n    if( board[1][3]!=0 ) return false;\n    rep(i,3) if( board[2][2+i]!=i+1 ) return false;\n    rep(i,5) if( board[3][1+i]!=i+4 ) return false;\n    rep(i,3) if( board[4][2+i]!=i+9 ) return false;\n    if( board[5][3]!=0 ) return false;\n    return true;\n}\n\nbool dfs(int cnt, int LIM, int py, int px){\n    if( LIM<cnt ) return false;\n    if( isgoal() ) return true;\n    if( cnt+dist()>20 ) return false;\n#if DEB\n    //printf(\"cnt:%d  (%d,%d),(%d,%d)\\n\",cnt, sx[0], sy[0], sx[1], sy[1]);\n#endif\n    rep(i,2){\n        rep(k,4){\n            int tx = sx[i] + dx[k];\n            int ty = sy[i] + dy[k];\n            if( board[ty][tx]==-1 || ty==py&&tx==px ) continue;\n            swap(board[sy[i]][sx[i]], board[ty][tx]);\n            swap(sx[i], tx); swap(sy[i],ty);\n            if( dfs(cnt+1, LIM, ty, tx) ) return true; // ツ個ウツづ個スツペツーツスツ暗環置\n            swap(sx[i], tx); swap(sy[i],ty);\n            swap(board[sy[i]][sx[i]] ,board[ty][tx]);\n        }\n    }\n}\nint solve(void){\n    int ttx[2], tty[2];\n    rep(i,2) ttx[i]=sx[i], tty[i]=sy[i];\n\n    for(int lim = 0; lim < 21; lim++){\n        rep(i,2) sx[i]=ttx[i], sy[i]=tty[i];\n        if( dfs(0,lim,-1,-1) ) return lim;\n    }\n    return -1;\n}\nint main(){\n    for(;;){\n        memset(board, -1, sizeof(board));\n        int sz = 0;\n\n        scanf(\"%d\",&board[1][3]); if( board[1][3]==-1 ) break;\n        rep(i,3) scanf(\"%d\",&board[2][2+i]);\n        rep(i,5) scanf(\"%d\",&board[3][1+i]);\n        rep(i,3) scanf(\"%d\",&board[4][2+i]);\n        scanf(\"%d\",&board[5][3]);\n\n        // find space\n        if( board[1][3]==0 ){ sx[sz]=3; sy[sz]=1; sz++; }\n        rep(i,3) if( board[2][2+i]==0 ) { sx[sz]=2+i; sy[sz]=2; sz++; }\n        rep(i,5) if( board[3][1+i]==0 ) { sx[sz]=1+i; sy[sz]=3; sz++; }\n        rep(i,3) if( board[4][2+i]==0 ) { sx[sz]=2+i; sy[sz]=4; sz++; }\n        if( board[5][3]==0 ){ sx[sz]=3; sy[sz]=5; sz++; }\n\n#if DEB\n        rep(i,7){\n            rep(j,7){\n                printf(\"%2d \",board[i][j]);\n            }\n            puts(\"\");\n        }\n        rep(i,2){\n            printf(\"(%d,%d),\",sx[i], sy[i]);\n        }puts(\"\");\n        printf(\"%d\\n\",dist());\n#endif\n        int ans = solve();\n        if( ans!=-1 ) printf(\"%d\\n\",ans); else puts(\"NA\");\n    }\n    return 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\n\n#ifndef INCLUDE_ZOBRIST_HASH_HPP\n#define INCLUDE_ZOBRIST_HASH_HPP\n\n#include <random>\n#include <iostream>\n#include <typeinfo>\n\nnamespace orislib {\n\ntemplate <typename T, int W, int H, int STATE>\nstruct ZobristHash {\n  typedef T hash_t;\n  ZobristHash() {\n    std::random_device rd;\n    std::mt19937 mt(rd());\n    std::uniform_int_distribution<T> dist;\n    for (int h = 0; h < H; h++) {\n      for (int w = 0; w < W; w++) {\n        for (int s = 0; s < STATE; s++) {\n          rands[h][w][s] = dist(mt);\n        }\n      }\n    }\n  }\n  template <typename TT>\n  hash_t hash(TT data[H][W]) {\n    hash_t r = 0;\n    for (int h = 0; h < H; h++) {\n      for (int w = 0; w < W; w++) {\n        r ^= rands[h][w][data[h][w]];\n      }\n    }\n    return r;\n  }\n  hash_t rands[H][W][STATE];\n};\n}\n\n#endif\nusing namespace std;\nusing namespace orislib;\n\ntypedef long long ll;\ntypedef long double ld;\ntypedef tuple<int, int> duo;\nconst int dx[] = {0, 0, 1, -1, 1, 1, -1, -1};\nconst int dy[] = {1, -1, 0, 0, 1, -1, 1, -1};\nconst int Mod = 1000000000 + 0;\n//{{{ templates\n#define TT_             \\\n  template <typename T> \\\n  inline\n#define TTF_                        \\\n  template <typename T, typename F> \\\n  inline\nTT_ T sq(T x) { return x * x; }\nTT_ T In() {\n  T x;\n  cin >> x;\n  return x;\n}\nTT_ void Out(T& x) { cout << x; }\nTT_ void sort(T& v) { sort(begin(v), end(v)); }\nTT_ void revs(T& v) { reverse(begin(v), end(v)); }\nTT_ void uniq(T& v) {\n  sort(v);\n  v.erase(unique(begin(v), end(v)), end(v));\n}\nTT_ int ubnd(T& v, typename T::value_type& x) {\n  return upper_bound(begin(v), end(v), x) - begin(v);\n}\nTT_ int lbnd(T& v, typename T::value_type& x) {\n  return lower_bound(begin(v), end(v), x) - begin(v);\n}\nTTF_ void inpt(T& v, int n, F f) {\n  for (v.reserve(n); n--; v.emplace_back(f()))\n    ;\n}\nTTF_ void show(T& v, F f, string d = \" \", string e = \"\\n\") {\n  int i = 0;\n  for (auto& x : v) i++&&(cout << d), f(x);\n  cout << e;\n}\nTT_ typename T::iterator minel(T& v) { return min_element(begin(v), end(v)); }\nTT_ typename T::iterator maxel(T& v) { return max_element(begin(v), end(v)); }\n\ninline void fast_io() {\n  ios::sync_with_stdio(0);\n  cin.tie(0);\n}\ninline int in() {\n  int x;\n  scanf(\"%d\", &x);\n  return x;\n}\ninline ll pow_mod(ll a, ll k, ll m) {\n  ll r = 1;\n  for (; k > 0; a = a * a % m, k >>= 1)\n    if (k & 1) r = r * a % m;\n  return r;\n}\ninline ll mod_inv(ll a, ll p) { return pow_mod(a, p - 2, p); }\n//}}} priority_queue queue deque front stringstream max_element min_element\n// insert count make_tuple\n\nstruct Board {\n  Board() {}\n  Board(const vector<vector<int>>& v) {\n    memset(b, '#', sizeof(b));\n    for (int i = 0; i < 5; i++) b[i][5] = 0;\n    for (int i = 0; i < v[0].size(); i++) b[0][2 + i] = conv_hex(v[0][i]);\n    for (int i = 0; i < v[1].size(); i++) b[1][1 + i] = conv_hex(v[1][i]);\n    for (int i = 0; i < v[2].size(); i++) b[2][0 + i] = conv_hex(v[2][i]);\n    for (int i = 0; i < v[3].size(); i++) b[3][1 + i] = conv_hex(v[3][i]);\n    for (int i = 0; i < v[4].size(); i++) b[4][2 + i] = conv_hex(v[4][i]);\n    int it = 0;\n    for (int i = 0; i < 5; i++) {\n      for (int j = 0; j < 5; j++) {\n        if (b[i][j] == '0') {\n          cx[it] = j;\n          cy[it] = i;\n          it++;\n        }\n      }\n    }\n    turn = 0;\n  }\n  char conv_hex(int a) { return \"0123456789ABCDEF\"[a]; }\n  bool slide(int index, int dir) {\n    int px = cx[index], py = cy[index];\n    int nx = px + dx[dir], ny = py + dy[dir];\n    if (invalid(nx, ny)) return false;\n    if (b[ny][nx] == '#') return false;\n    if (b[ny][nx] == '0') return false;\n    swap(b[py][px], b[ny][nx]);\n    cx[index] = nx;\n    cy[index] = ny;\n    turn++;\n    return true;\n  }\n  bool is_ok() {\n    static const char cb[5][6] = {\n        \"##0##\", \"#123#\", \"45678\", \"#9AB#\", \"##0##\", };\n    return memcmp(cb, b, sizeof(cb)) == 0;\n  }\n  bool invalid(int x, int y) { return x < 0 || x >= 5 || y < 0 || y >= 5; }\n  char b[5][6];\n  int cx[2], cy[2];\n  int turn;\n};\n\nint main() {\n  ZobristHash<int, 6, 5, 256> zh;\n  int h;\n  while (h = in(), h != -1) {\n    vector<vector<int>> vs(5);\n    vs[0].emplace_back(h);\n    inpt(vs[1], 3, in);\n    inpt(vs[2], 5, in);\n    inpt(vs[3], 3, in);\n    inpt(vs[4], 1, in);\n    Board b(vs);\n    queue<Board> Q;\n    set<int> vis;\n    Q.push(b);\n\n    while (!Q.empty()) {\n      Board bi = Q.front();\n      Q.pop();\n      if (bi.turn > 12) break;\n      if (bi.is_ok()) {\n        cout << bi.turn << endl;\n        goto END;\n      }\n      for (int i = 0; i < 2; i++) {\n        for (int d = 0; d < 4; d++) {\n          Board bii = bi;\n          if (!bii.slide(i, d)) continue;\n          int hv = zh.hash(bii.b);\n          if (vis.count(hv)) continue;\n          vis.insert(hv);\n          Q.push(bii);\n        }\n      }\n    }\n  cout << \"NA\" << endl;\nEND:;\n  }\n  return 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include<bits/stdc++.h>\nusing namespace std;\n   \ntypedef long long int64;\nconst int INF = 1 << 30;\n   \nvector< int > edge[13];\n  \nbool back(string str, int cnt){ //枝刈り大事だな\n  static int dist[] = { 0, 2, 1, 2, 4, 3, 2, 3, 4, 2, 1, 2, 0};\n  static int fuee[] = { 2, 0, 1, 2, 2, 1, 2, 3, 4, 2, 3, 4, 4};\n  static int fuga[] = { 1, 1, 0, 1, 3, 2, 1, 2, 3, 3, 2, 3, 3};\n  static int haaa[] = { 2, 2, 1, 0, 4, 3, 2, 1, 2, 4, 3, 2, 4};\n  static int kira[] = { 3, 3, 2, 3, 3, 2, 1, 2, 3, 1, 0, 1, 1};\n  \n  if(cnt > 20) return true;\n  int foo1 = 0, foo2 = 0, foo3 = 0, foo4 = 0, foo5 = 0;\n  for(int i = 0; i < 13; i++){\n    if(str[i] == '0') foo1 += dist[i];\n    else if(str[i] == '1') foo2 += fuee[i];\n    else if(str[i] == '2') foo3 += fuga[i];\n    else if(str[i] == '3') foo4 += haaa[i];\n    else if(str[i] == 'A') foo5 += kira[i];\n  }\n  return cnt + foo1 + foo2 + foo3 + foo4 + foo5 > 27;\n}\n  \n  \nint bfs(string mas){\n  \n  queue< string > que;\n  map< string , int > memo;\n  que.push( mas );\n  memo[mas] = 0;\n  while(!que.empty()){\n  \n    string p = que.front(); que.pop();\n    if(back( p, memo[p])) continue;\n    if(p == \"0123456789AB0\") return memo[p];\n  \n    for(int i = 0; i < 13; i++){\n      if(p[i] == '0') {\n        for(int j = 0; j < edge[i].size(); j++){\n          string next = p;\n          swap( next[i], next[edge[i][j]]);\n          if(memo.find(next) != memo.end()) continue;\n          que.push( next );\n          memo[next] = memo[p] + 1;\n        }\n      }\n    }\n  }\n  return -1;\n}\n  \nint main(){\n  vector< int > mas(13);\n  \n  edge[0].push_back(2);\n  edge[1].push_back(2); edge[1].push_back(5);\n  edge[2].push_back(0); edge[2].push_back(1); edge[2].push_back(3); edge[2].push_back(6);\n  edge[3].push_back(2); edge[3].push_back(7);\n  edge[4].push_back(5);\n  edge[5].push_back(1); edge[5].push_back(4); edge[5].push_back(6); edge[5].push_back(9);\n  edge[6].push_back(2); edge[6].push_back(5); edge[6].push_back(7); edge[6].push_back(10);\n  edge[7].push_back(3); edge[7].push_back(6); edge[7].push_back(8); edge[7].push_back(11);\n  edge[8].push_back(7);\n  edge[9].push_back(5); edge[9].push_back(10);\n  edge[10].push_back(6); edge[10].push_back(9); edge[10].push_back(11); edge[10].push_back(12);\n  edge[11].push_back(7); edge[11].push_back(10);\n  edge[12].push_back(10);\n  \n  while(cin >> mas[0], mas[0] != -1){\n    for(int i = 1; i < 13; i++){\n      cin >> mas[i];\n    }\n  \n    string start = \"\";\n    for(int i = 0; i < 13; i++){\n      if(mas[i] >= 10) start += (char)(mas[i] - 10 + 'A');\n      else start += mas[i] + '0';\n    }\n    int ret = bfs(start);\n    if(~ret) cout << ret << endl;\n    else cout << \"NA\" << endl;\n  }\n}"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\n \nusing namespace std;\n \n#define LIMIT 20\n \nstruct P{\n    int y,x;\n    P(int y,int x) : y(y),x(x) {}\n};\n \nint limit;\nvector<int> v;\n \nP getPos(int x)\n{\n    if(x == 0) return P(0,2);\n    if(1 <= x && x <= 3) return P(1,x);\n    if(4 <= x && x <= 8) return P(2,x-4);\n    if(9 <= x && x <= 11) return P(3,x-8);\n    return P(4,2);\n}\n \nint getPos(P p)\n{\n    if(p.y == 0){\n\tif(p.x == 2) return 0;\n\telse return -1;\n    }\n    if(p.y == 1){\n\tif(1 <= p.x && p.x <= 3){\n\t    return p.x;\n\t}else{\n\t    return -1;\n\t}\n    }\n    if(p.y == 2){\n\tif(0 <= p.x && p.x <= 4){\n\t    return p.x+4;\n\t}else{\n\t    return -1;\n\t}\n    }\n    if(p.y == 3){\n\tif(1 <= p.x && p.x <= 3){\n\t    return p.x+8;\n\t}else{\n\t    return -1;\n\t}\n    }\n    if(p.y == 4){\n\tif(p.x == 2){\n\t    return 12;\n\t}else{\n\t    return -1;\n\t}\n    }\n    return -1;\n}\n \nint getMD()\n{\n    int sum = 0;\n    for(int i = 0 ; i < 13 ; i++){\n\tif(v[i] == 0) continue;\n\tP np = getPos(i);\n\tP tp = getPos(v[i]);\n\tsum += abs(np.x-tp.x) + abs(np.y-tp.y);\n    }\n    return sum;\n}\n \nconst int dx[] = {-1,0,1,0};\nconst int dy[] = {0,-1,0,1};\n \nbool dfs(int sp1,int sp2,int step)\n{\n    int md = getMD();\n    if(md == 0) return true;\n    if(md + step > limit){\n\treturn false;\n    }\n    P p[2] = {getPos(sp1),getPos(sp2)};\n    for(int i = 0 ; i < 2 ; i++){\n\tint x = p[i].x, y = p[i].y;\n\tfor(int j = 0 ; j < 4 ; j++){\n\t    int nx = x + dx[j], ny = y + dy[j];\n\t    P np(ny,nx);\n\t    int next = getPos(np);\n\t    if(next == -1) continue;\n\t    if(i == 0){\n\t\tswap(v[sp1],v[next]);\n\t\tif(dfs(next,sp2,step+1)){\n\t\t    return true;\n\t\t}\n\t\tswap(v[sp1],v[next]);\n\t    }else{\n\t\tswap(v[sp2],v[next]);\n\t\tif(dfs(sp1,next,step+1)){\n\t\t    return true;\n\t\t}\n\t\tswap(v[sp2],v[next]);\n\t    }\n\t}\n    }\n    return false;\n}\n \nint main()\n{\n    int x;\n    while(cin >> x, x != -1){\n\tint sp[2];\n\tv.resize(13); v[0] = x;\n\tfor(int i = 1 ; i < 13 ; i++){\n\t    cin >> v[i];\n\t}\n\tfor(int i = 0, j = 0 ; i < 13 ; i++){\n\t    if(v[i] == 0){\n\t\tsp[j++] = i;\n\t    }\n\t}\n\tbool found = false;\n\tfor(limit = 0 ; limit <= LIMIT ; limit++){\n\t    if(dfs(sp[0],sp[1],0)){\n\t\tcout << limit << endl;\n\t\tfound = true;\n\t\tbreak;\n\t    }\n\t}\n\tif(!found){\n\t    cout << \"NA\" << endl;\n\t}\n    }\n    return 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include <iostream>\n#include <cstdio>\n#include <cstring>\n#include <algorithm>\n#include <vector>\n#include <queue>\n#include <map>\nusing namespace std;\n\ntypedef vector<int> VI;\n\nint size[13] = {1, 2, 4, 2, 1, 4, 4, 4, 1, 2, 4, 2, 1};\nint move[13][4] = {\n  {2},\n  {2, 5},\n  {0, 1, 6, 3},\n  {2, 7},\n  {5},\n  {1, 4, 6, 9},\n  {2, 5, 7, 10},\n  {3, 6, 8, 11},\n  {7},\n  {5, 10},\n  {6, 9, 11, 12},\n  {7, 10},\n  {10}\n};\n\nVI v;\nmap<VI, int> mp;\nmap<VI, int> mp2;\n\nvoid make(){\n  VI goal;\n  for(int i = 0 ; i < 13 ; i++){\n    if(i == 0 || i == 12) goal.push_back(0);\n    else goal.push_back(i);    \n  }\n  \n  queue<VI> que;\n  que.push(goal);\n  mp2[goal] = 0;\n  \n  while(!que.empty()){\n    VI q = que.front(); que.pop();    \n    if(mp2[q] > 13) continue;\n    for(int i = 0 ; i < 13 ; i++){\n      if(q[i] != 0) continue;\n      for(int j = 0 ; j < size[i] ; j++){\n\tVI t = q;\n\tswap(t[i], t[ move[i][j] ]);\n\tif(mp2.find(t) != mp2.end()) continue;\t\n\tmp2[t] = mp2[q] + 1;\t\n\tque.push(t);\n      }\n    }\n  }\n}\n    \n\n\nint bfs(){\n  queue<VI> que;\n  que.push(v);\n  mp[v] = 0;  \n  while(!que.empty()){\n    VI q = que.front(); que.pop();    \n    if(mp2.find(q) != mp2.end()){\n      return mp2[q] + mp[q];\n    }\n    \n    if(mp[q] > 8) continue;\n    for(int i = 0 ; i < 13 ; i++){\n      if(q[i] != 0) continue;      \n      for(int j = 0 ; j < size[i] ; j++){\n\tVI t = q;\n\tswap(t[i], t[ move[i][j] ]);\n\tif(mp.find(t) != mp.end()) continue;\n\tmp[t] = mp[q] + 1;\n\tque.push(t);\n      }\n    }\n  }\n  return -1;\n}\n\nvoid init(){\n  v.clear();\n  mp.clear();  \n}\n\nint main(){\n  make();\n  int n;\n  while(cin >> n){\n    if(n == -1) break;\n    \n    init();\n    \n    v.push_back(n);\n    for(int i = 0 ; i < 12 ; i++){ cin >> n; v.push_back(n); }\n    \n    int ans = bfs();\n    if(ans == -1) cout << \"NA\" << endl;\n    else cout << ans << endl;\n  }\n  \n\n  return 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include<bits/stdc++.h>\n#define r(i,n) for(int i=0;i<n;i++)\nusing namespace std;\ntypedef pair<vector<int>,int>P;\nvector<int>v[13],s(13),t(13);\nmap<vector<int>,int>m;\nvoid init(){\n\n    v[0].push_back(2);\n\n    v[1].push_back(2);\n    v[1].push_back(5);\n\n    v[2].push_back(0);\n    v[2].push_back(1);\n    v[2].push_back(3);\n    v[2].push_back(6);\n\n    v[3].push_back(2);\n    v[3].push_back(7);\n\n    v[4].push_back(5);\n\n    v[5].push_back(1);\n    v[5].push_back(4);\n    v[5].push_back(6);\n    v[5].push_back(9);\n\n    v[6].push_back(2);\n    v[6].push_back(5);\n    v[6].push_back(7);\n    v[6].push_back(10);\n\n    v[7].push_back(3);\n    v[7].push_back(6);\n    v[7].push_back(8);\n    v[7].push_back(11);\n\n    v[8].push_back(7);\n\n    v[9].push_back(5);\n    v[9].push_back(10);\n\n    v[10].push_back(6);\n    v[10].push_back(9);\n    v[10].push_back(11);\n    v[10].push_back(12);\n\n    v[11].push_back(7);\n    v[11].push_back(10);\n\n    v[12].push_back(10);\n}\nvoid BFS1(){\n    s[0]=0;\n    s[12]=0;\n    r(i,11)s[i+1]=i+1;\n    set<vector<int> >st;\n    st.insert(s);\n    m[s]=0;\n    queue<P>q;\n    q.push(P(s,0));\n    while(1){\n        vector<int>now=q.front().first;\n        int cost=q.front().second;\n        q.pop();\n        if(cost==8)break;\n        r(i,13)if(now[i]!=0){\n            r(j,v[i].size()){\n                swap(now[i],now[v[i][j]]);\n                if(!st.count(now)){\n                    st.insert(now);\n                    m[now]=cost+1;\n                    q.push(P(now,cost+1));\n                }\n                swap(now[i],now[v[i][j]]);\n            }\n        }\n    }\n}\n\nvoid BFS2(){\n    set<vector<int> >st;\n    st.insert(t);\n    queue<P>q;\n    q.push(P(t,0));\n    while(1){\n        vector<int>now=q.front().first;\n        int cost=q.front().second;\n        if(m.count(now)){\n            cout<<m[now]+cost<<endl;\n            return ;\n        }\n        q.pop();\n        if(cost==8)break;\n        r(i,13)if(now[i]!=0){\n            r(j,v[i].size()){\n                swap(now[i],now[v[i][j]]);\n                if(!st.count(now)){\n                    st.insert(now);\n                    q.push(P(now,cost+1));\n                }\n                swap(now[i],now[v[i][j]]);\n            }\n        }\n    }\n    cout<<\"NA\"<<endl;\n}\n\n\nint main(){\n    init();\n    BFS1();\n    while(cin>>t[0],t[0]!=-1){\n        r(i,12)cin>>t[i+1];\n        BFS2();\n    }\n}\n"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\n\nusing namespace std;\n\n#define FOR(i,a,b) for(int i=(a);i<(b);i++)\n#define REP(i,n) FOR(i,0,n)\n#define ALL(v) (v).begin(),(v).end()\n#define fi first\n#define se second\n\ntemplate<typename A, typename B> inline bool chmax(A &a, B b) { if (a<b) { a=b; return 1; } return 0; }\ntemplate<typename A, typename B> inline bool chmin(A &a, B b) { if (a>b) { a=b; return 1; } return 0; }\n\ntypedef long long ll;\ntypedef pair<int, int> pii;\ntypedef pair<ll, ll> pll;\ntypedef pair<int, pll> pip;\nconst ll INF = 1ll<<29;\nconst ll MOD = 1000000007;\nconst double EPS  = 1e-9;\n\nint dd[13][4] = {\n\t{2,-1,-1,-1},\n\t{2,5,-1,-1},\n\t{0,1,3,6},\n\t{2,7,-1,-1},\n\t{5,-1,-1,-1},\n\t{1,4,6,9},\n\t{2,5,7,10},\n\t{3,6,8,11},\n\t{7,-1,-1,-1},\n\t{5,10,-1,-1},\n\t{6,9,11,12},\n\t{7,10,-1,-1},\n\t{10,-1,-1,-1}\n};\n\nint main() {\n\tqueue<string> que;\n\tmap<string, int> d;\n\t\n\tque.push(\"abcdefghijkla\");\n\td[ans] = 0;\n\t\n\twhile (!que.empty()) {\n\t\tstring now = que.front(); que.pop();\n\t\tint cost = d[now];\n\t\t\n\t\tif (cost > 10) break;\n\t\t\n\t\tREP(i, 13) if (now[i] == 'a') {\n\t\t\tREP(j, 4) {\n\t\t\t\tif (dd[i][j] == -1) break;\n\t\t\t\t\n\t\t\t\tswap(now[i], now[dd[i][j]]);\n\t\t\t\tif (d.find(now) == d.end()) {\n\t\t\t\t\td[now] = cost + 1;\n\t\t\t\t\tque.push(now);\n\t\t\t}\n\t\t\t\tswap(now[i], now[dd[i][j]]);\n\t\t\t}\n\t\t}\n\t}\n\twhile (!que.empty()) que.pop();\n\n\tint p[13];\n\twhile (cin >> p[0], ~p[0]) {\n\t\tFOR(i, 1, 13) cin >> p[i];\n\t\tstring st = \"\";\n\t\tREP(i, 13) st += p[i] + 'a';\n\t\t\n\t\tmap<string, int> d2;\n\t\tque.push(st);\n\t\td2[st] = 0;\n\t\t\n\t\tint ans = INF;\n\t\t\n\t\twhile (!que.empty()) {\n\t\t\tstring now = que.front(); que.pop();\n\t\t\tint cost = d2[now];\n\t\t\t\n\t\t\tif (cost > 11) break;\n\t\t\tif (d.find(now) != d.end()) {\n\t\t\t\tans = d[now] + d2[now];\n\t\t\t\tbreak;\n\t\t\t}\n\t\t\t\n\t\t\tREP(i, 13) if (now[i] == 'a') {\n\t\t\t\tREP(j, 4) {\n\t\t\t\t\tif (dd[i][j] == -1) break;\n\t\t\t\t\t\n\t\t\t\t\tswap(now[i], now[dd[i][j]]);\n\t\t\t\t\tif (d2.find(now) == d2.end()) {\n\t\t\t\t\t\td2[now] = cost + 1;\n\t\t\t\t\t\tque.push(now);\n\t\t\t\t}\n\t\t\t\t\tswap(now[i], now[dd[i][j]]);\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t\twhile (!que.empty()) que.pop();\n\t\t\n\t\tif (ans != INF) cout << ans << endl;\n\t\telse puts(\"NA\");\n\t}\n\treturn 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include<iostream>\n#include<algorithm>\n#include<vector>\n#include<queue>\n#include<map>\n#define lol(i,n) for(int i=0;i<n;i++)\n#define mod 1000000007\ntypedef long long ll;\nusing namespace std;\nint dx[13][4]={\n  {3,0,0,0},\n  {3,6,0,0},\n  {1,2,4,6},\n  {3,8,0,0},\n  {6,0,0,0},\n  {2,5,7,10},\n  {3,6,8,11},\n  {4,7,9,12},\n  {8,0,0,0},\n  {6,11,0,0},\n  {6,10,12,13},\n  {8,11,0,0},\n  {11,0,0,0}\n};\nmap<ll,int> mp;\nll Compress(int p[]){\n  ll ans=0;\n  for(int i=0;i<13;i++){\n    ans*=13;\n    ans+=p[i];\n  }\n  return ans;\n}\n\nint unzip[13];\nvoid Unzip(ll x){\n  for(int i=0;i<13;i++){\n    unzip[12-i]=x%13;\n    x/=13;\n  }\n}\n\nqueue<pair<ll,int> >Q;\nvoid BFS(int p[],int len){\n  ll tmp=Compress(p);\n  mp[tmp]=len;\n  if(len==21)return;\n  lol(i,13){\n    if(p[i]==0){\n      lol(j,4){\n\tint t=dx[i][j];\n\tif(t==0)break;\n\tt--;\n\tif(p[t]!=0){\n\t  swap(p[i],p[t]);\n\t  Q.push(make_pair(Compress(p),len+1));\n\t  swap(p[i],p[t]);\n\t}\n      }\n    }\n  }\n}\nint main(){\n  int p[13];\n  lol(i,13)p[i]=i;p[12]=0;\n  Q.push(make_pair(Compress(p),1));\n  while(!Q.empty()){\n    ll data=Q.front().first;\n    int len=Q.front().second;\n    Q.pop();\n    if(mp[data]>0)continue;\n    Unzip(data);\n    BFS(unzip,len);\n  }\n  while(cin>>p[0]&&p[0]!=-1){\n    for(int i=1;i<13;i++)cin>>p[i];\n    ll tmp=Compress(p);\n    int cost=mp[tmp];\n    if(cost==0)cout<<\"NA\"<<endl;\n    else cout<<cost-1<<endl;\n  }\n  return 0;\n}"
  },
  {
    "language": "C++",
    "code": "//35\n#include<iostream>\n#include<vector>\n#include<set>\n#include<algorithm>\n#include<queue>\n\nusing namespace std;\n\nstruct S{\n  vector<int> v;\n  int t;\n};\n\nint main(){\n  for(;;){\n    vector<int> v(13);\n    cin>>v[2]>>v[1]>>v[4]>>v[7]>>v[0]>>v[3]>>v[6]>>v[9]>>v[12]>>v[5]>>v[8]>>v[11]>>v[10];\n    if(v[2]==-1)return 0;\n    queue<S> que;\n    S is={v,0};\n    que.push(is);\n    set<vector<int> > p;\n    while(!que.empty()&&que.front().t<=20){\n      S  c=que.front();\n      int g[]={4,1,0,5,2,9,6,3,10,7,0,11,8};\n      if(c.v==vector<int>(g,g+13))break;\n      que.pop();\n      if(p.count(c.v))continue;\n      p.insert(c.v);\n      for(int i=0;i<13;i++){\n\tif(v[i]==0){\n\t  for(int j=0;j<4;j++){\n\t    int d[]={-2,3,2,-3};\n\t    int b[][5]={{0,1,2,7,12},{2,7,12,11,10},{12,11,10,5,0},{10,5,0,1,2}};\n\t    int k;\n\t    for(k=0;k<5;k++){\n\t      if(i==b[j][k])break;\n\t    }\n\t    if(k==5){\n\t      vector<int> n=c.v;\n\t      swap(n[i],n[i+d[j]]);\n\t      S ns={n,c.t+1};\n\t      que.push(ns);\n\t    }\n\t  }\n\t}\n      }\n    }\n    if(que.empty()||que.front().t>20){\n      cout<<\"NA\"<<endl;\n    }else{\n      cout<<que.front().t<<endl;\n    }\n  }\n  return 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include <iostream>\n#include <algorithm>\n#include <vector>\n#include <queue>\n#include <map>\nusing namespace std;\n#define rep(i,n) for(int i=0;i<n;i++)\nclass NODE{\npublic:\n\tvector<int> data;\n\tint depth;\n\tint e[2];\n\tNODE(int a[13],int d,int E[2]){\n\t\tdata.resize(13);\n\t\trep(i,13)data[i] = a[i];\n\t\tdepth = d;\n\t\trep(i,2)e[i] = E[i];\n\t}\n\tNODE(){\n\t\tdepth = 0;\n\t\tdata.resize(13);\n\t}\n};\n\nint di[13][10] = {\n\t{2,-1},\n\t{2,5,-1},\n\t{0,1,3,6,-1},\n\t{2,7,-1},\n\t{5,-1},\n\t{1,4,6,9,-1},\n\t{2,5,7,10,-1},\n\t{3,6,7,11,-1},\n\t{7},\n\t{5,10,-1},\n\t{6,9,11,12,-1},\n\t{7,10,-1},\n\t{10,-1}\n};\n\nint main(){\n\twhile(1){\n\t\tint ret = 21;\n\t\tNODE fst; int cnt = 0;\n\t\trep(i,13){\n\t\t\tif(cin >>fst.data[i] , fst.data[i] != -1){\n\t\t\t\tif(fst.data[i] == 0){\n\t\t\t\t\tfst.e[cnt] = i;\n\t\t\t\t\tcnt++;\n\t\t\t\t}\n\t\t\t}else{\n\t\t\t\treturn 0;\n\t\t\t}\n\t\t}\n\t\tmap< vector<int> , int > done[2];\n\t\t\n\t\trep(x,2){\n\t\t\tqueue<NODE> Q;\n\t\t\tif(x==0){\n\t\t\t\tQ.push(fst);\n\t\t\t}else{\n\t\t\t\tNODE a;\n\t\t\t\trep(i,11)a.data[i+1] = i+1;\n\t\t\t\ta.e[0] = 0;\n\t\t\t\ta.e[1] = 12;\n\t\t\t\tQ.push(a);\n\t\t\t}\n\t\t\tdone[x][Q.front().data] = 0;\n\t\t\twhile(Q.size()){\n\t\t\t\tNODE q = Q.front(); Q.pop();\n\t\t\t\tif(x == 1){\n\t\t\t\t\tif( done[0].find(q.data) != done[0].end() ){\n\t\t\t\t\t\tret = q.depth + done[0][q.data] ;\n\t\t\t\t\t\tbreak;\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t\tif(q.depth >= 10)continue;\n\n\t\t\t\trep(o,2){\n\t\t\t\t\tfor(int i=0;di[q.e[o]][i] != -1;i++){\n\t\t\t\t\t\tNODE next = q;\n\t\t\t\t\t\tnext.e[o] = next.data[di[q.e[o]][i]];\n\t\t\t\t\t\tswap(next.data[q.e[o]] , next.data[di[q.e[o]][i]]);\n\t\t\t\t\t\tnext.depth = q.depth + 1;\n\t\t\t\t\t\t\n\t\t\t\t\t\tif( done[x].find(next.data) == done[x].end() ){\n\t\t\t\t\t\t\tdone[x][next.data] = next.depth;\n\t\t\t\t\t\t\tQ.push(next);\n\t\t\t\t\t\t}\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t\t\n\t\tif(ret > 20){\n\t\t\tcout << \"NA\" << endl;\n\t\t}else{\n\t\t\tcout << ret << endl;\n\t\t}\n\t}\n}"
  },
  {
    "language": "C++",
    "code": "#include<iostream>\n#include<queue>\n#include<algorithm>\n#include<map>\n\nusing namespace std;\n\nconst int SIZE = 13;\n\nstruct Puzzle{\n  short c[SIZE];\n  \n  void move(int d, int n){\n    if(d == 0) moveUp(n);\n    if(d == 1) moveDown(n);\n    if(d == 2) moveLeft(n);\n    if(d == 3) moveRight(n);\n  }\n  // n = choosed blank number 0(first one) or 1(second one)\n  void moveUp(int n){\n    int pos = findBlankPosition(n);\n    int tmp[] = {-1,-1,0,-1,-1,1,2,3,-1,5,6,7,10};\n     \n    int npos = tmp[pos];\n    if(npos != -1) swap(c[pos],c[npos]);\n  }\n  \n  void moveDown(int n){\n    int pos = findBlankPosition(n);\n    int tmp[] = {2,5,6,7,-1,9,10,11,-1,-1,12,-1,-1};\n    \n    int npos = tmp[pos];\n    if(npos != -1) swap(c[pos],c[npos]);\n  }\n  \n  void moveLeft(int n){\n    int pos = findBlankPosition(n);\n    int tmp[] = {-1,-1,1,2,-1,4,5,6,7,-1,9,10,-1};\n    \n    int npos = tmp[pos];\n    if(npos != -1) swap(c[pos],c[npos]);\n  }\n  \n  void moveRight(int n){\n    int pos = findBlankPosition(n);\n    int tmp[] = {-1,2,3,-1,5,6,7,8,-1,10,11,-1,-1};\n     \n    int npos = tmp[pos];\n    if(npos != -1) swap(c[pos],c[npos]);\n  }\n  \n  int findBlankPosition(int n){\n    for(int i = 0; i < SIZE; i++){\n      if(c[i] == 0) n--;\n      if(n < 0) return i;\n    }\n    return -1;\n  }\n  \n  bool operator < (const Puzzle& p) const {\n    for(int i = 0; i < SIZE; i++)\n      if(c[i] != p.c[i]) return c[i] < p.c[i];\n    return false;\n  }\n  \n  bool operator == (const Puzzle& p) const {\n    for(int i = 0; i < SIZE; i++)\n      if(c[i] != p.c[i]) return false;\n    return true;\n  }\n};\n\nPuzzle puz;\n \nbool input(){\n  cin >> puz.c[0];\n  if(puz.c[0] == -1) return false;\n  for(int i = 1; i < SIZE; i++) cin >> puz.c[i];\n  return true;\n}\n \nvoid solve(){\n  map<Puzzle, int> M;\n  M[puz] = 1;\n  \n  Puzzle ans_case;\n  for(int i = 0; i < SIZE; i++) ans_case.c[i] = i%(SIZE-1);\n\n  queue<Puzzle> Q;\n  Q.push(puz);\n\n  while(!Q.empty()){\n    Puzzle now = Q.front(); Q.pop();\n    if(now == ans_case){\n      cout << M[now]-1 << endl;\n      return;\n    }\n    for(int i = 0; i < 4; i++)\n      for(int j = 0; j < 2; j++){\n\tPuzzle nex = now;\n\tnex.move(i,j);\n\tif(M[nex] > M[now]+1|| M[nex] == 0){\n\t  M[nex] = M[now]+1;\n\t  if(M[nex] < 11) Q.push(nex);\n\t}\n      }\n  }\n \n  \n  Puzzle tmp = ans_case;\n  Q.push(tmp);\n  map<Puzzle,int> MG;\n  MG[tmp] = 1;\n \n  while(!Q.empty()){\n    Puzzle now = Q.front(); Q.pop();\n    if(M[now] != 0){\n      cout << M[now]+MG[now]-2 << endl;\n      return;\n    }\n\n    for(int i = 0; i < 4; i++)\n      for(int j = 0; j < 2; j++){\n\tPuzzle nex = now;\n\tnex.move(i,j);\n\t\n        if(MG[nex] > MG[now]+1 || MG[nex] == 0){\n\t  MG[nex] = MG[now]+1;\n\t  if(MG[nex] <= 11) Q.push(nex);\n\t}\n      }\n  }\n  cout << \"NA\" << endl;\n}\n \nint main(){\n  while(input()) solve();\n  return 0;\n}"
  },
  {
    "language": "C++",
    "code": "#define _USE_MATH_DEFINES\n#define INF 10000000\n#include <iostream>\n#include <sstream>\n#include <cstdio>\n#include <cmath>\n#include <algorithm>\n#include <queue>\n#include <stack>\n#include <limits>\n#include <map>\n#include <string>\n#include <cstring>\n#include <set>\n#include <deque>\n#include <bitset>\n#include <list>\n\nusing namespace std;\n\ntypedef long long ll;\ntypedef pair<int,string> P;\n\nstatic const double eps = 1e-8;\n\nint main(){\n  int a,b;\n  while(~scanf(\"%d %d\",&a,&b)){\n    printf(\"%d\\n\",a-b);\n  }\n}"
  },
  {
    "language": "C++",
    "code": "#include <iostream>\n#include <vector>\nusing namespace std;\n\ntypedef vector <int> VI;\ntypedef vector <VI> VVI;\n\nVVI goal;\nVVI init;\n\nint limit;\n\nconst int di[4] = { 0, -1, 0, 1 };\nconst int dj[4] = { 1, 0, -1,  };\n\nconst int T[12][2] = {\n\t{ 0, 0 },\n\t{ 2, 2 },\n\t{ 2, 3 },\n\t{ 2, 4 },\n\t{ 3, 1 },\n\t{ 3, 2 },\n\t{ 3, 3 },\n\t{ 3, 4 },\n\t{ 3, 5 },\n\t{ 4, 2 },\n\t{ 4, 3 },\n\t{ 4, 4 }\n};\n\nint getMD( VVI P )\n{\n\tint sum = 0;\n\tint ti, tj;\n\tfor ( int i = 0; i < 7; i++ ) for ( int j = 0; j < 7; j++ )\n\t{\n\t\tif ( P[j][i] <= 0 )\n\t\t\tcontinue;\n\n\t\tti = T[P[j][i]][0];\n\t\ttj = T[P[j][i]][1];\n\t\tsum += ( max( ti, i ) - min( ti, i ) + max( tj, j ) - min( tj, j ) );\n\t}\n\treturn sum;\n}\n\nbool is_goal( VVI puzzle )\n{\n\tbool ok = true;\n\tfor ( int i = 0; ok && i < 7; i++ ) for ( int j = 0; ok && j < 7; j++ )\n\t{\n\t\tif ( puzzle[j][i] != goal[j][i] )\n\t\t\tok = false;\n\t}\n\treturn ok;\n}\n\nbool dfs( int depth, VVI now )\n{\n\tif ( depth <= limit && is_goal( now ) )\n\t\treturn true;\n\n\tif ( depth + getMD( now ) > limit )\n\t\treturn false;\n\n\tfor ( int i = 0; i < 7; i++ ) for ( int j = 0; j < 7; j++ )\n\t{\n\t\tif ( now[j][i] != 0 )\n\t\t\tcontinue;\n\n\t\tfor ( int k = 0; k < 4; k++ )\n\t\t{\n\t\t\tVVI v = now;\n\t\t\tint ni = i + di[k];\n\t\t\tint nj = j + dj[k];\n\n\t\t\tif ( v[nj][ni] <= 0 )\n\t\t\t\tcontinue;\n\n\t\t\tswap( v[j][i], v[nj][ni] );\n\n\t\t\tif ( dfs( depth+1, v ) )\n\t\t\t\treturn true;\n\n\t\t}\n\t}\n\n}\n\nint idfs( VVI src )\n{\n\tfor ( limit = 0; limit <= 20; limit++ )\n\t{\n\t\tif ( dfs( 0, src ) )\n\t\t\treturn limit;\n\t}\n\treturn -1;\n}\n\nint main( void )\n{\n\t// S[ÌóÔðìé\n\tgoal = VVI( 7, VI( 7, -1 ) );\n\tgoal[3][1] = 0;\n\tgoal[3][5] = 0;\n\tfor ( int i = 0; i < 3; i++ )\n\t{\n\t\tgoal[2+i][2] = 1+i;\n\t\tgoal[2+i][4] = 9+i;\n\t}\n\tfor ( int i = 0; i < 5; i++ )\n\t{\n\t\tgoal[1+i][3] = 4+i;\n\t}\n\n\twhile ( 1 )\n\t{\n\t\t// úóÔÌüÍ\n\t\tinit = VVI( 7, VI( 7, -1 ) );\n\t\tcin >> init[3][1];\n\t\tif ( init[3][1] == -1 )\n\t\t\tbreak;\n\t\tfor ( int i = 0; i < 3; i++ )\n\t\t\tcin >> init[2+i][2];\n\t\tfor ( int i = 0; i < 5; i++ )\n\t\t\tcin >> init[1+i][3];\n\t\tfor ( int i = 0; i < 3; i++ )\n\t\t\tcin >> init[2+i][4];\n\t\tcin >> init[3][5];\n\n\t\tint cost = idfs( init );\n\n\t\tif ( cost == -1 )\n\t\t\tcout << \"NA\" << endl;\n\t\telse\n\t\t\tcout << cost << endl;\n\n\t}\n\n\treturn 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include <iostream>\n#include <vector>\n#include <set>\n#include <map>\n#include <queue>\n#include <sstream>\n#include <algorithm>\n#include <numeric>\n#include <cmath>\n#include <complex>\n#include <cstdio>\n#include <cstring>\n#include <cstdlib>\n#include <cassert>\n\n#define rep(i,n) for(int i=0;i<n;i++)\n#define rp(i,c) rep(i,(c).size())\n#define fr(i,c) for(__typeof((c).begin()) i=(c).begin();i!=(c).end();i++)\n#define mp make_pair\n#define pb push_back\n#define all(c) (c).begin(),(c).end()\n#define dbg(x) cerr<<#x<<\" = \"<<(x)<<endl\n\nusing namespace std;\n\ntypedef long long ll;\ntypedef vector<int> vi;\ntypedef pair<int,int> pi;\nconst int inf=1<<28;\nconst double INF=1e10,EPS=1e-9;\n\nint dx[]={-1,0,1,0},dy[]={0,-1,0,1};\nint gx[]={0,1,2,3,0,1,2,3,4,1,2,3},gy[]={0,1,1,1,2,2,2,2,2,3,3,3};\n\nstruct S{\n\tint p[5][5];\n\tint zx[2],zy[2];\n\tint md;\n\tS(){}\n\tS(int a[5][5])\n\t{\n\t\tmd=0;\n\t\tzx[0]=-1;\n\t\trep(i,5)rep(j,5)\n\t\t{\n\t\t\tp[i][j]=a[i][j];\n\t\t\tif(a[i][j]==0)\n\t\t\t{\n\t\t\t\tif(zx[0]==-1)zy[0]=i,zx[0]=j;\n\t\t\t\telse zy[1]=i,zx[1]=j;\n\t\t\t}\n\t\t\tif(abs(i-2)+abs(j-2)<=2&&p[i][j])\n\t\t\tmd+=abs(gy[p[i][j]]-i)+abs(gx[p[i][j]]-j);\n\t\t}\n\t}\n\tbool swp(int z,int d)\n\t{\n\t\tint y=zy[z],x=zx[z],nx=x+dx[d],ny=y+dy[d];\n\t\tif(abs(nx-2)+abs(ny-2)>2||p[y][x]==p[ny][nx])return 0;\n\t\t\n\t\tmd+=abs(gy[p[ny][nx]]-y)+abs(gx[p[ny][nx]]-x);\n\t\tmd-=abs(gy[p[ny][nx]]-ny)+abs(gx[p[ny][nx]]-nx);\n\t\tswap(p[y][x],p[ny][nx]);\n\t\tzy[z]+=dy[d]; zx[z]+=dx[d];\n\t\treturn 1;\n\t}\n};\nS pz; int lim;\nbool dfs(int c)\n{\n\tif(pz.md==0)return 1;\n\trep(i,2)rep(d,4)\n\t{\n\t\tif(!pz.swp(i,d))continue;\n\t\tif(pz.md+c+1<=lim&&dfs(c+1))return 1;\n\t\tpz.swp(i,d+2&3);\n\t}\n\treturn 0;\n}\nint main()\n{\n\tint t;\n\twhile(scanf(\"%d\",&t),~t)\n\t{\n\t\tint p[5][5];\n\t\trep(i,5)rep(j,5)p[i][j]=-1;\n\t\tp[0][2]=t;\n\t\trep(i,3)scanf(\"%d\",p[1]+i+1);\n\t\trep(i,5)scanf(\"%d\",p[2]+i);\n\t\trep(i,3)scanf(\"%d\",p[3]+i+1);\n\t\tscanf(\"%d\",p[4]+2);\n\t\t\n\t\tfor(lim=0;lim<=20;lim++)\n\t\t{\n\t\t\tpz=S(p);\n\t\t\tif(!dfs(0))continue;\n\t\t\tprintf(\"%d\\n\",lim); goto END;\n\t\t}\n\t\tputs(\"NA\"); END:;\n\t}\n\treturn 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include <iostream>\n#include <cstdio>\n#include <vector>\n#include <map>\n#include <string>\n#include <queue>\n#include <algorithm>\nusing namespace std;\n\ntypedef pair<int,int> P;\nconst int INF = 1e+8;\nconst int f1[25] = {\n\t-1,-1, 0,-1,-1,\n\t-1, 1, 2, 3,-1,\n\t 4, 5, 6, 7, 8,\n\t-1, 9,10,11,-1,\n\t-1,-1,12,-1,-1,\n};\nconst int f2[13] = {2,6,7,8,10,11,12,13,14,16,17,18,22};\nconst int dx[4] = { 0,-1,+1, 0};\nconst int dy[4] = {-1, 0, 0,+1};\n\n// パズル\nstruct Pazzle{\n\tstring v;\n\tPazzle(){v = \"*************\"; }\n\tvoid at(int i, int p){\n\t\tv[i] = p;\n\t}\n\t// 空白の位置を返す. (k は 0 or 1)\n\tint search(int k){\n\t\tint a = 0;\n\t\tfor(int i=0 ; i < 13 ; i++ ){\n\t\t\tif( v[i] == 0 ){\n\t\t\t\tif( k == 0 ){\n\t\t\t\t\treturn i;\n\t\t\t\t}else{\n\t\t\t\t\tif( a == 0 ) a++;\n\t\t\t\t\telse return i;\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t\treturn -1;\n\t}\n\t// 合っている数\n\tint to_g(){\n\t\tint res = 13;\n\t\tfor(int i=0 ; i < 12 ; i++ ){\n\t\t\tif( i != v[i] ) res--;\n\t\t}\n\t\tif( v[12] != 0 ) res--;\n\t\treturn res;\n\t}\n\t// 空白 k (0 or 1) を 方向 dir に動かす.\n\t// 動かせる時は true, 動かせなかったときは false を返す.\n\tbool move(int dir, int k){\n\t\tif( dir < 0 || 4 <= dir || k < 0 || 2 <= k ) return false;\n\t\tint pos1 = search(k);\n\t\tint x = f2[pos1] % 5;\n\t\tint y = f2[pos1] / 5;\n\t\tint mx = x + dx[dir];\n\t\tint my = y + dy[dir];\n\t\tif( mx < 0 || my < 0 || 5 <= mx || 5 <= my ) return false;\n\t\tint pos2 = f1[my*5+mx];\n\t\tif( pos2 == -1 ) return false;\n\t\tif( v[pos1] == v[pos2] ) return false;\n\t\tswap( v[pos1] , v[pos2] );\n\t\treturn true;\n\t}\n\t// 完成しているかどうか\n\tbool is_goal(){\n\t\tfor(int i=0 ; i < 12 ; i++ ){\n\t\t\tif( v[i] != i ) return false;\n\t\t}\n\t\treturn v[12] == 0;\n\t}\n\tvoid debug(){\n\t\tprintf(\"[debug]\\n\");\n\t\tfor(int y=0 ; y < 5 ; y++ ){\n\t\t\tfor(int x=0 ; x < 5 ; x++ ){\n\t\t\t\tif( f1[y*5+x] == -1 ){\n\t\t\t\t\tprintf(\"##\");\n\t\t\t\t}else{\n\t\t\t\t\tprintf(\"%2d\", (int)v[f1[y*5+x]] );\n\t\t\t\t}\n\t\t\t}\n\t\t\tprintf(\"\\n\");\n\t\t}\n\t\tprintf(\"\\n\");\n\t}\n};\n\n// (コスト,スタートからの距離,パズルの状態)\n// コスト は (合っている数,-スタートからの距離)\nstruct State{\n\tPazzle p;\n\tint cnt;\n\tP cost;\n\tState(int cost_, int cnt_, const Pazzle& p_){\n\t\tcost = P(cost_,-cnt_); cnt = cnt_; p = p_;\n\t}\n};\nbool operator<(const State& a, const State& b){\n\treturn a.cost < b.cost;\n}\n\nint solve(Pazzle p){\n\t// (コスト,スタートからの距離,パズルの状態) を優先度つきキューへ\n\tpriority_queue<State> q;\n\tq.push( State(p.to_g(),0,p) );\n\t\n\tint res = 21;\n\tint foo=0;\n\twhile( !q.empty() ){\n\t\tPazzle p = q.top().p;\n\t\tint cnt = q.top().cnt;\n\t\tq.pop();\n\t\t\n\t\tif( res <= cnt + (13-p.is_goal()) ) continue;\n\t\t\n\t\tif( p.is_goal() ){\n\t\t\tres = min( res , cnt );\n\t\t\tcontinue;\n\t\t\t//break;\n\t\t}\n\t\t\n\t\tfor(int k=0 ; k <= 1 ; k++ ){\n\t\t\tfor(int i=0 ; i < 4 ; i++ ){\n\t\t\t\tPazzle p_ = p;\n\t\t\t\tif( p_.move(i,k) ){\n\t\t\t\t\tq.push( State(p_.to_g(),cnt+1,p_) );\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t}\n\treturn res;\n}\n\nint main(){\n\tint p1;\n\twhile( cin >> p1 , p1 != -1 ){\n\t\tPazzle p;\n\t\tp.at(0,p1);\n\t\tfor(int i=1 ; i < 13 ; i++ ){\n\t\t\tcin >> p1;\n\t\t\tp.at(i,p1);\n\t\t}\n\t\tint ans = solve(p);\n\t\tif( ans == 21 ){\n\t\t\tcout << \"NA\" << endl;\n\t\t}else{\n\t\t\tcout << ans << endl;\n\t\t}\n\t}\n}"
  },
  {
    "language": "C++",
    "code": "#include<iostream>\n#include<algorithm>\n#include<iomanip>\n\n#define N 7\n#define INV (-1)\n\n#define UP 0\n#define RIGHT 1\n#define DOWN 2\n#define LEFT 3\n#define DIRMAX 4\n\n#define NA 20\n\nusing namespace std;\n\nstruct State\n{\n  int map[N][N];\n  State(){\n    //fill(&map[0][0],&map[N-1][N-1],-1);\n  }\n  State(int tmap[][N]){\n    for(int i = 0; i < N; ++i){\n      for(int j = 0; j < N; ++j){\n\tmap[i][j] = tmap[i][j];\n      }\n    }\n  }\n  bool move(int which, int dir){\n    // which = 0, upper,left\n    // which != 0, bottom,right\n    for(int i = (which==0?0:N-2); which==0?(i<N-1):(i>=1); which==0?++i:--i){\n      for(int j = (which==0?0:N-2); which==0?(j<N-1):(j>=1); which==0?++j:--j){\n\tif( map[i][j] == 0 ){\n\t  switch(dir){\n\t  case UP:   if( map[i-1][j] > 0 ){swap( map[i][j], map[i-1][j] );return true;}break;\n\t  case RIGHT:if( map[i][j+1] > 0 ){swap( map[i][j], map[i][j+1] );return true;}break;\n\t  case DOWN: if( map[i+1][j] > 0 ){swap( map[i][j], map[i+1][j] );return true;}break;\n\t  case LEFT: if( map[i][j-1] > 0 ){swap( map[i][j], map[i][j-1] );return true;}break;\n\t  }\n\t  return false;\n\t}\n      }\n    }\n  }\n  int getHeuristic()const{\n    const int ti[] = {0,2,2,2,3,3,3,3,3,4,4,4};\n    const int tj[] = {0,2,3,4,1,2,3,4,5,2,3,4};\n    int ret = 0;\n    int max1=0,max2=0;\n    for(int i = 1; i < N-1; ++i){\n      for(int j = 1; j < N-1; ++j){\n\tif( map[i][j] > 0 ){\n\t  int x = abs(i-ti[map[i][j]] )+ abs(j-tj[map[i][j]]);\n\t  ret += x;\n\t  if( max1 < x ){\n\t    max2 = max1;\n\t    max1 = x;\n\t  }\n\t}\n      }\n    }\n    return ret;\n  }\n  bool isComplete()const{\n    return getHeuristic() == 0;\n  }\n};\n\nint IterativeDeepning(int depth, const State &now, int &ans)\n{\n\n  if( now.isComplete() ){\n    ans = min( ans , depth );\n    return ans;\n  }\n  int least = depth+now.getHeuristic();\n  if( least > ans ){\n    return NA;\n  }\n  // ans = min( ans, least );\n  for(int w = 0; w < 2; ++w){\n    for(int dir = 0; dir < DIRMAX; ++dir){\n      State next = now;\n      if( next.move( w, dir ) ){\n\tans = min( ans, IterativeDeepning( depth + 1, next, ans ) );\n      }\n    }\n  }\n  return NA;\n}\n\nint main()\n{\n  while(true){\n    int map[N][N];\n    int ans;\n    fill(&map[0][0],&map[N-1][N],-1);\n    \n    const int imax[] = {1,3,5,3,1};\n    const int dj[] = {2,1,0,1,2};\n    for(int i = 0; i < 5; ++i){\n      for(int j = 0; j < imax[i]; ++j){\n\tint t;\n\tcin >> t;\n\tif( t < 0 ) return 0;\n\tmap[i+1][j+dj[i]+1]=t;\n      }\n    }\n\n    /*\n    for(int i = 0; i < N; ++i){\n      for(int j = 0; j < N; ++j){\n\tcout << setw(3) << map[i][j] << ' ';\n      }\n      cout << endl;\n    }\n    cout << endl;\n    */\n\n    ans = NA;\n    IterativeDeepning( 0, State(map), ans );\n    if( ans > NA ){\n      cout << \"NA\" << endl;\n    }else{\n      cout << ans << endl;\n    }\n      \n  }\n  return 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include<iostream>\n#include<algorithm>\n#include<vector>\n#include<queue>\n#include<map>\n#define lol(i,n) for(int i=0;i<n;i++)\n#define mod 1000000007\ntypedef long long ll;\nusing namespace std;\nint dx[13][4]={\n  {3,0,0,0},\n  {3,6,0,0},\n  {1,2,4,6},\n  {3,8,0,0},\n  {6,0,0,0},\n  {2,5,7,10},\n  {3,6,8,11},\n  {4,7,9,12},\n  {8,0,0,0},\n  {6,11,0,0},\n  {6,10,12,13},\n  {8,11,0,0},\n  {11,0,0,0}\n};\nmap<ll,int> mp;\nll Compress(int p[]){\n  ll ans=0;\n  for(int i=0;i<13;i++){\n    ans*=13;\n    ans+=p[i];\n  }\n  return ans;\n}\n\nint unzip[13];\nvoid Unzip(ll x){\n  for(int i=0;i<13;i++){\n    unzip[12-i]=x%13;\n    x/=13;\n  }\n}\n\nint beflen=0;\nqueue<pair<ll,int> >Q;\nvoid BFS(int p[],int len){\n  //if(len!=beflen){cout<<len<<endl;beflen=len;}\n  ll tmp=Compress(p);\n  mp[tmp]=len;\n  if(len==21)return;\n  lol(i,13){\n    if(p[i]==0){\n      lol(j,4){\n\tint t=dx[i][j];\n\tif(t==0)break;\n\tt--;\n\tif(p[t]!=0){\n\t  swap(p[i],p[t]);\n\t  tmp=Compress(p);\n\t  if(mp[tmp]>0)continue;\n\t  Q.push(make_pair(tmp,len+1));\n\t  swap(p[i],p[t]);\n\t}\n      }\n    }\n  }\n}\nint main(){\n  int p[13];\n  lol(i,13)p[i]=i;p[12]=0;\n  Q.push(make_pair(Compress(p),1));\n  while(!Q.empty()){\n    ll data=Q.front().first;\n    int len=Q.front().second;\n    Q.pop();\n    if(mp[data]>0)continue;\n    Unzip(data);\n    BFS(unzip,len);\n  }\n  while(cin>>p[0]&&p[0]!=-1){\n    for(int i=1;i<13;i++)cin>>p[i];\n    ll tmp=Compress(p);\n    int cost=mp[tmp];\n    if(cost==0)cout<<\"NA\"<<endl;\n    else cout<<cost-1<<endl;\n  }\n  return 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include <iostream>\n#include <vector>\nusing namespace std;\n\ntypedef vector <int> VI;\ntypedef vector <VI> VVI;\n\nVVI goal;\nVVI init;\n\nint limit;\n\nconst int di[4] = { 0, -1, 0, 1 };\nconst int dj[4] = { 1, 0, -1,  };\n\nconst int T[12][2] = {\n\t{ 0, 0 },\n\t{ 2, 2 },\n\t{ 2, 3 },\n\t{ 2, 4 },\n\t{ 3, 1 },\n\t{ 3, 2 },\n\t{ 3, 3 },\n\t{ 3, 4 },\n\t{ 3, 5 },\n\t{ 4, 2 },\n\t{ 4, 3 },\n\t{ 4, 4 }\n};\n\nint getMD( VVI P )\n{\n\tint sum = 0;\n\tint ti, tj;\n\n\tfor ( int i = 0; i < 7; i++ ) for ( int j = 0; j < 7; j++ )\n\t{\n\t\tif ( P[j][i] <= 0 )\n\t\t\tcontinue;\n\n\t\tti = T[P[j][i]][0];\n\t\ttj = T[P[j][i]][1];\n\t\tsum += ( max( ti, i ) - min( ti, i ) + max( tj, j ) - min( tj, j ) );\n\t}\n\n\treturn sum;\n}\n\nbool is_goal( VVI puzzle )\n{\n\tbool ok = true;\n\tfor ( int i = 0; ok && i < 7; i++ ) for ( int j = 0; ok && j < 7; j++ )\n\t{\n\t\tif ( puzzle[j][i] != goal[j][i] )\n\t\t\tok = false;\n\t}\n\treturn ok;\n}\n\nbool dfs( int depth, VVI now )\n{\n\tif ( is_goal( now ) )\n\t\treturn true;\n\n\tif ( depth + getMD( now ) > limit )\n\t\treturn false;\n\n\tfor ( int i = 0; i < 7; i++ ) for ( int j = 0; j < 7; j++ )\n\t{\n\t\tif ( now[j][i] != 0 )\n\t\t\tcontinue;\n\n\t\tfor ( int k = 0; k < 4; k++ )\n\t\t{\n\t\t\tVVI v = now;\n\t\t\tint ni = i + di[k];\n\t\t\tint nj = j + dj[k];\n\n\t\t\tif ( v[nj][ni] <= 0 )\n\t\t\t\tcontinue;\n\n\t\t\tswap( v[j][i], v[nj][ni] );\n\n\t\t\tif ( dfs( depth+1, v ) )\n\t\t\t\treturn true;\n\n\t\t}\n\t}\n\n\treturn false;\n}\n\nint idfs( VVI src )\n{\n\tfor ( limit = 0; limit <= 20; limit++ )\n\t{\n\t\tif ( dfs( 0, src ) )\n\t\t\treturn limit;\n\t}\n\treturn -1;\n}\n\nint main( void )\n{\n\t// S[ÌóÔðìé\n\tgoal = VVI( 7, VI( 7, -1 ) );\n\tgoal[3][1] = 0;\n\tgoal[3][5] = 0;\n\tfor ( int i = 0; i < 3; i++ )\n\t{\n\t\tgoal[2+i][2] = 1+i;\n\t\tgoal[2+i][4] = 9+i;\n\t}\n\tfor ( int i = 0; i < 5; i++ )\n\t{\n\t\tgoal[1+i][3] = 4+i;\n\t}\n\n\twhile ( 1 )\n\t{\n\t\t// úóÔÌüÍ\n\t\tinit = VVI( 7, VI( 7, -1 ) );\n\t\tcin >> init[3][1];\n\t\tif ( init[3][1] == -1 )\n\t\t\tbreak;\n\t\tfor ( int i = 0; i < 3; i++ )\n\t\t\tcin >> init[2+i][2];\n\t\tfor ( int i = 0; i < 5; i++ )\n\t\t\tcin >> init[1+i][3];\n\t\tfor ( int i = 0; i < 3; i++ )\n\t\t\tcin >> init[2+i][4];\n\t\tcin >> init[3][5];\n\n\t\tint cost = idfs( init );\n\n\t\tif ( cost == -1 )\n\t\t\tcout << \"NA\" << endl;\n\t\telse\n\t\t\tcout << cost << endl;\n\n\t}\n\n\treturn 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include<iostream>\n#include<vector>\n#include<map>\n#include<cstdio>\n#include<deque>\n#include<cmath>\n#include<algorithm>\n#define F first\n#define S second\n#define pb push_back\nusing namespace std;\ntypedef pair<int,int> P;\ntypedef pair<P,P> PP;\ntypedef vector<int> VI;\ntypedef vector<VI> VVI;\ntypedef vector<P> VP;\ntypedef pair<VVI,VP> VVIVP;\n\n\nmap<VVI,int> memo,bidirectional;\nVVI final;\nVP ini;\nint dx[4] = {0,1,0,-1};\nint dy[4] = {1,0,-1,0};\n\nP Fpos[] = {P(0,0),P(1,1),P(2,1),P(3,1),P(0,2),P(1,2),P(2,2),P(3,2),P(4,2),P(1,3),P(2,3),P(3,3)};\n\n\nclass Puzzle\n{\npublic:\n  VVI state;\n  int Manhattan;\n  VP vp;\n\n  Puzzle():Manhattan(0){}\n  Puzzle(VVI s)\n  {\n    vp.clear();\n    state = s;\n    Manhattan_calc(false);\n  }\n\n  void Manhattan_calc(bool b)\n  {\n    Manhattan = 0; \n    for(int i=0;i<5;i++)\n      for(int j=0;j<state[i].size();j++)\n\tif(state[i][j] != 0 && state[i][j] != -1)\n\t  Manhattan += abs(j-Fpos[state[i][j]].F) + abs(i-Fpos[state[i][j]].S);\n\telse if(state[i][j] == 0 && !b)// bがfalseなら初期化\n\t  vp.push_back(P(j,i)); \n  }\n\n  void print()\n  {\n  \n    for(int i=0;i<state.size();i++)\n      {\n\tfor(int j=0;j<state[i].size();j++)\n\t  {\n\t    if(state[i][j] == -1)\n\t      cout << \"  \";\n\t    else \n\t      cout << state[i][j] << \" \";\n\t  }\n\tcout << endl;\n      }\n    cout << endl;\n  }\n};\n\nbool Input(VVI& puzzle)\n{\n  puzzle.clear();\n  puzzle.resize(5);\n  puzzle[0].resize(3),puzzle[1].resize(4),puzzle[2].resize(5),puzzle[3].resize(4),puzzle[4].resize(3);\n  puzzle[0][0] = puzzle[0][1] = puzzle[1][0] = puzzle[3][0] = puzzle[4][0] = puzzle[4][1] = -1;\n \n  scanf(\"%d\",&puzzle[0][2]);\n  if(puzzle[0][2] == -1)\n    return false; \n  scanf(\"%d %d %d\",&puzzle[1][1],&puzzle[1][2],&puzzle[1][3]);\n  scanf(\"%d %d %d %d %d\",&puzzle[2][0],&puzzle[2][1],&puzzle[2][2],&puzzle[2][3],&puzzle[2][4]);\n  scanf(\"%d %d %d\",&puzzle[3][1],&puzzle[3][2],&puzzle[3][3]);\n  scanf(\"%d\",&puzzle[4][2]);\n\t    \n    return true;\n}\n\nvoid print(VVI vvi)\n{\n  cout << \"--- print ---\" << endl;\n  for(int i=0;i<vvi.size();i++)\n    {\n      for(int j=0;j<vvi[i].size();j++)\n\t{\n\t  cout << vvi[i][j] << \" \";\n\t}\n      cout << endl;\n    }\n  cout << endl;\n}\n\nVVI change(VVI vec,P p1,P p11)\n{\n  int tmp = vec[p1.S][p1.F];\n  vec[p1.S][p1.F] = vec[p11.S][p11.F];\n  vec[p11.S][p11.F] = tmp;\n\n  return vec;\n}\n\nvoid Init()\n{\n  final.resize(5);\n  final[0].pb(-1),final[0].pb(-1),final[0].pb(0);\n  final[1].pb(-1),final[1].pb(1),final[1].pb(2),final[1].pb(3);\n  final[2].pb(4),final[2].pb(5),final[2].pb(6),final[2].pb(7),final[2].pb(8);\n  final[3].pb(-1),final[3].pb(9),final[3].pb(10),final[3].pb(11);\n  final[4].pb(-1),final[4].pb(-1),final[4].pb(0);\n\n  Puzzle puz(final); \n  deque<Puzzle> deq;\n  deq.push_back(puz);\n  bidirectional[final] = 0;\n  \n  while(!deq.empty())\n    {\n      Puzzle p = deq.front(); deq.pop_front();\n      int cost = bidirectional[p.state];\n    \n      if(cost >= 11)\n\tcontinue;\n\n      for(int i=0;i<2;i++)\n\t{\n\t  for(int j=0;j<4;j++)\n\t    {\n\t      int nx = p.vp[i].F + dx[j];\n\t      int ny = p.vp[i].S + dy[j];\n\t      if(!(0<=ny && ny<p.state.size() && 0<=nx && nx<p.state[ny].size() && p.state[ny][nx] != -1))\n\t\tcontinue;\n\t      VVI next = change(p.state,p.vp[i],P(nx,ny));\n\t      map<VVI,int>::iterator it = bidirectional.find(next);\n\t      if(it == bidirectional.end() || (it != bidirectional.end() && bidirectional[next] > cost + 1))\n\t\t{\n\t\t  bidirectional[next] = cost + 1;\n\t\t  deq.push_back(Puzzle(next));\n\t\t}\n\n\t    }\n\n\t}      \n\n    }\n  \n  \n}\n\n\nint main()\n{\n  VVI puzzle;\n  Init();\n  //cout << \"here\" << endl;\n  while(Input(puzzle))\n    {\n \n      Puzzle puz(puzzle);\n      int men = (1<<28);\n      deque<Puzzle> deq;\n      deq.push_back(puz);\n      memo.clear();\n      memo[puzzle] = 0;\n\n      while(!deq.empty())\n\t{\n\t  Puzzle p = deq.front(); deq.pop_front();\n\t  int cost = memo[p.state];\n\t  //cout << \"cost : \" << cost << endl;\n\t  //p.print();\n\t  if(cost + p.Manhattan > min(20,men))\n\t    continue;\n\n\t  if(p.state == final)\n\t    {\n\t      men = min(men,cost);\n\t      continue;\n\t    }\n\t  else if(bidirectional.find(p.state) != bidirectional.end() && cost + bidirectional[p.state] <= 20)\n\t    {\n\t      men = min(men,cost+bidirectional[p.state]);\n\t      continue;\n\t    }\n       \n\t  for(int i=0;i<2;i++)\n\t    {\n\t      for(int j=0;j<4;j++)\n\t\t{\n  \n\t\t  int nx = p.vp[i].F + dx[j];\n\t\t  int ny = p.vp[i].S + dy[j];\n\t\t  if(!(0<=ny && ny<p.state.size() && 0<=nx && nx<p.state[ny].size() && p.state[ny][nx] != -1))\n\t\t    continue;\n\n\t\t  VVI next = change(p.state,p.vp[i],P(nx,ny));\n\t\t  map<VVI,int>::iterator it = memo.find(next);\n\t\t  if(it == memo.end() || (it != memo.end() &&  memo[next] > cost + 1) )\n\t\t    {\n\t\t      memo[next] = cost + 1;\n\t\t      deq.push_back(Puzzle(next));\n\t\t    }\n\n\t\t}\n\t    }\n\n\n\t}\n      if(men == (1<<28))\n\tcout << \"NA\" << endl;\n      else \n\tcout << men << endl;\n    }  \n\n    \n  return 0;\n}\n\n\n  /*  \n  deque<VVIVP> deq;\n  VP vec;\n  vec.push_back(P(0,0));\n  vec.push_back(P(0,4)); \n  deq.push_back(VVIVP(final,vec));\n  bidirectional[final] = 0;\n  while(!deq.empty())\n    {\n      VVIVP vvivp = deq.front(); deq.pop_front();\n      VVI vvi = vvivp.F;\n      VP vp = vvivp.S;\n      P p1,p2;\n      int cost = bidirectional[vvi];\n      if(cost >= 5)\n\tcontinue;\n      p1 = vp[0];\n      p2 = vp[1];\n      \n      for(int i=0;i<5;i++)\n\t{\n\t  int nx1 = p1.F + dx[i];\n\t  int ny1 = p1.S + dy[i];\n\n\t  if(!(0 <= ny1 && ny1 < vvi.size() && 0 <= nx1 && nx1 < vvi[ny1].size()))\n\t    continue;\n\n\t  for(int j=0;j<5;j++)\n\t    {\n\t      if(i == 4 && j == 4)\n\t\tcontinue;\n\t      int nx2 = p2.F + dx[j];\n\t      int ny2 = p2.S + dy[j];\n\n\t      if(!(0 <= ny2 && ny2 < vvi.size() && 0 <= nx2 && nx2 < vvi[ny2].size()))\n\t\tcontinue;\n\t      VVI new_vvi = change(vvi,p1,P(nx1,ny1),p2,P(nx2,ny2));\n\t      if(bidirectional.count(new_vvi) == 0 || (bidirectional.count(new_vvi) != 0 && bidirectional[new_vvi] > cost + 1))\n\t\t{\n\t\t  VP vip;\n\t\t  vip.push_back(P(nx1,ny1));\n\t\t  vip.push_back(P(nx2,ny2));\n\t\t  bidirectional[new_vvi] = cost+1;\n\t\t  deq.push_back(VVIVP(new_vvi,vip));\n\t\t}\n\n\t     \n\n\t    }\n\t}\n\n    }\n*/\n\n/*\n int men = (1<<28);\n      deque<VVIVP> deq;\n      bool fin = false;\n      deq.push_back(VVIVP(puzzle,ini));\n      memo[puzzle] = 0;\n      while(!deq.empty() && !fin)\n\t{\n\t  VVIVP vvivp = deq.front(); deq.pop_front();\n\t  VVI vvi = vvivp.F;\n\t  VP vp = vvivp.S;\n\t  P p1,p2;\n\t  p1 = vp[0], p2 = vp[1];\n\t \n\t  if((vvi == final || bidirectional.count(vvi) != 0) && memo[vvi] + bidirectional[vvi] <= min(20,men))\n\t    {\n\t      men = min(men,memo[vvi]+bidirectional[vvi]);\n\t      continue;\n\t    }\n\t  \n\t  int cost = memo[vvi];\n\n\t  if(men <= cost) \n\t    continue;\n\n\t  for(int i=0;i<5;i++)\n\t    {\n\t      int nx1 = p1.F + dx[i];\n\t      int ny1 = p1.S + dy[i];\n\n\t      if(!(0 <= ny1 && ny1 < vvi.size() && 0 <= nx1 && nx1 < vvi[ny1].size()))\n\t\tcontinue;\n\n\t      for(int j=0;j<5;j++)\n\t\t{\n\t\t  if(i = 4 && j == 4)\n\t\t    continue;\n\t\t  int nx2 = p2.F + dx[j];\n\t\t  int ny2 = p2.S + dy[j];\n\t\t  \n\t\t  if(!(0 <= ny2 && ny2 < vvi.size() && 0 <= nx2 && nx2 < vvi[ny2].size()))\n\t\t    continue;\n\n\t\t  //cout << \"change! \" << i << \" - \" << j << endl;\n\n\t\t  //cout <<\"cost = \" << cost << endl;\n\t\t   //print(change(vvi,p1,P(nx1,ny1),p2,P(nx2,ny2)));\n\t\t  VVI new_vvi = change(vvi,p1,P(nx1,ny1),p2,P(nx2,ny2));\n\t\t  if(memo.count(new_vvi) == 0 || (memo.count(new_vvi) != 0 && memo[new_vvi] > cost+1))\n\t\t    {\n\t\t \n\t\t      memo[new_vvi] = cost+1;\n\t\t      VP vip;\n\t\t      vip.push_back(P(nx1,ny1));\n\t\t      vip.push_back(P(nx2,ny2));\n\t\t      deq.push_back(VVIVP(new_vvi,vip));\n\t\t    }\n\n\n\t\t}\n\n\t    }\n\n\t}\n\n      if(men != (1<<28))\n\tcout << men << endl;\n      else \n\tcout << \"NA\" << endl;\n */\n\n\n/*\nwhile(Input(puzzle)){\n      int men = (1<<28);\n      deque<VVIVP> deq;\n      bool fin = false;\n      deq.push_back(VVIVP(puzzle,ini));\n      memo[puzzle] = 0;\n      while(!deq.empty())\n\t{\n\t  VVIVP vvivp = deq.front(); deq.pop_front();\n\t  VVI vvi = vvivp.F;\n\t  VP vp = vvivp.S;\n\t \n\t  if(vvi == final)\n\t    {\n\t      men = min(men,memo[vvi]);\n\t      fin = true;\n\t    }\n\t  else if(bidirectional.count(vvi) != 0 && memo[vvi] + bidirectional[vvi] <= 20)\n\t    {\n\t      fin = true;\n\t      men = min(men,memo[vvi]+bidirectional[vvi]);\n\t      break;\n\t    }\n\t \n\t  int cost = memo[vvi];\n\t  if(cost >= men)\n\t    continue;\n\n\t  //cout << \"cost = \" << cost << endl;\n\t  P p1,p2;\n\t  p1 = vp[0];\n\t  p2 = vp[1];\n\t  for(int k=0;k<5;k++)\n\t    {\n\t      int nx1,ny1;\n\t      nx1 = vp[0].F + dx[k];\n\t      ny1 = vp[0].S + dy[k];\n\t      if(!(0 <= ny1 && vvi.size() > ny1 && 0 <= nx1 && vvi[ny1].size() > nx1))\n\t\tcontinue;\n\n\t      for(int l=0;l<5;l++)\n\t\t{\n\t\t  int nx2,ny2;\n\t\n\t\t  nx2 = vp[1].F + dx[l];\n\t\t  ny2 = vp[1].S + dy[l];\n\n\t\t  if(!(0 <= ny2 && vvi.size() > ny2 && 0 <= nx2 && vvi[ny2].size() > nx2))\n\t\t    continue;\n\t\n\t\n\t\t  int tmp = vvi[p1.S][p1.F];\n\t\t  vvi[p1.S][p1.F] = vvi[ny1][nx1];\n\t\t  vvi[ny1][nx1] = tmp;\n\n\t\t  tmp = vvi[p2.S][p2.F];\n\t\t  vvi[p2.S][p2.F] = vvi[ny2][nx2];\n\t\t  vvi[ny2][nx2] = tmp;\n\t\n\n\t\t  if(cost+1 >= 20 && vvi != final)\n\t\t    continue;\n\n\t\t  if(cost+1 >= 20 && vvi == final)\n\t\t    {\n\t\t      fin = true;\n\t\t      printf(\"20\\n\");\n\t\t      break;\n\t\t    }\n\n\t\t  if((memo.count(vvi) != 0 && memo[vvi] > cost + 1) || memo.count(vvi) == 0)\n\t\t    {\n\t\t      VP vip;\n\t\t      vip.push_back(P(nx1,ny1));\n\t\t      vip.push_back(P(nx2,ny2));\n\t\t      memo[vvi] = cost + 1;\n\t\t      deq.push_back(VVIVP(vvi,vip)); \n\t\t    }\n\n\t\n\t\t  tmp = vvi[p1.S][p1.F];\n\t\t  vvi[p1.S][p1.F] = vvi[ny1][nx1];\n\t\t  vvi[ny1][nx1] = tmp;\n\n\t\t  tmp = vvi[p2.S][p2.F];\n\t\t  vvi[p2.S][p2.F] = vvi[ny2][nx2];\n\t\t  vvi[ny2][nx2] = tmp;\n\t\n\t\t}\n\t      if(fin)\n\t\tbreak;\n\t    }\n\t  if(fin)\n\t    break;\n\t}\n      if(!fin)\n\tprintf(\"NA\\n\");\n      else\n\tprintf(\"%d\\n\",men);\n    }\n\n */"
  },
  {
    "language": "C++",
    "code": "#include <stdio.h>\n#include <cmath>\n#include <algorithm>\n#include <cfloat>\n#include <stack>\n#include <queue>\n#include <vector>\n#include <string>\n#include <iostream>\n#include <set>\n#include <map>\ntypedef long long int ll;\ntypedef unsigned long long int ull;\n#define BIG_NUM 2000000000\n#define MOD 1000000007\n#define EPS 0.000000001\nusing namespace std;\n\nstruct Info{\n\tshort table[5][5];\n\tint space_row1,space_col1,space_row2,space_col2;\n};\n\nmap<string,bool> MAP;\n\nbool rangeCheck(int row,int col){\n\tif(row < 0 || row >= 5)return false;\n\n\tswitch(row){\n\tcase 0:\n\t\tif(col == 2)return true;\n\t\tbreak;\n\tcase 1:\n\t\tif(col >= 1 && col <= 3)return true;\n\t\tbreak;\n\tcase 2:\n\t\tif(col >= 0 && col <= 4)return true;\n\t\tbreak;\n\tcase 3:\n\t\tif(col >= 1 && col <= 3)return true;\n\t\tbreak;\n\tcase 4:\n\t\tif(col == 2)return true;\n\t\tbreak;\n\t}\n\treturn false;\n}\n\nbool clearFLG;\nint ans;\nint p[13];\nint diff_row[4] = {-1,0,0,1},diff_col[4] = {0,-1,1,0};\n\n\nvoid copyInfo(Info& to,Info from){\n\n\tfor(int row = 0; row <= 4; row++){\n\t\tfor(int col = 0; col <= 4; col++){\n\t\t\tto.table[row][col] = from.table[row][col];\n\t\t}\n\t}\n}\n\n\nvoid recursive(Info info,int depth,int max_depth){\n\n\tif(clearFLG)return;\n\n\tif(depth == max_depth){\n\t\tif(info.table[1][1] == 1 && info.table[1][2] == 2 && info.table[1][3] == 3 &&\n\t\t\t\tinfo.table[2][0] == 4 && info.table[2][1] == 5 && info.table[2][2] == 6 && info.table[2][3] == 7 && info.table[2][4] == 8 &&\n\t\t\t\tinfo.table[3][1] == 9 && info.table[3][2] == 10 && info.table[3][3] == 11){\n\t\t\tclearFLG = true;\n\t\t}\n\t\treturn;\n\t}\n\n\tint adj_row,adj_col;\n\n\tfor(int i = 0; i < 4; i++){\n\t\tadj_row = info.space_row1+diff_row[i];\n\t\tadj_col = info.space_col1+diff_col[i];\n\n\t\tif(rangeCheck(adj_row,adj_col) == false || info.table[adj_row][adj_col] == 0)continue;\n\n\t\tInfo next_info;\n\t\tcopyInfo(next_info,info);\n\n\t\tswap(next_info.table[info.space_row1][info.space_col1],next_info.table[adj_row][adj_col]);\n\n\t\tstring tmp;\n\t\tfor(int row = 0; row <= 4; row++){\n\t\t\tfor(int col = 0; col <= 4; col++){\n\t\t\t\tif(rangeCheck(row,col)){\n\t\t\t\t\ttmp.append(to_string(next_info.table[row][col])).append(to_string('*'));\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\n\t\tauto at = MAP.find(tmp);\n\t\tif(at != MAP.end())continue;\n\n\t\tMAP[tmp] = true;\n\n\t\tnext_info.space_row1 = adj_row;\n\t\tnext_info.space_col1 = adj_col;\n\t\tnext_info.space_row2 = info.space_row2;\n\t\tnext_info.space_col2 = info.space_col2;\n\n\t\trecursive(next_info,depth+1,max_depth);\n\t}\n\n\tfor(int i = 0; i < 4; i++){\n\t\tadj_row = info.space_row2+diff_row[i];\n\t\tadj_col = info.space_col2+diff_col[i];\n\n\t\tif(rangeCheck(adj_row,adj_col) == false || info.table[adj_row][adj_col] == 0)continue;\n\n\t\tInfo next_info;\n\t\tcopyInfo(next_info,info);\n\n\t\tswap(next_info.table[info.space_row2][info.space_col2],next_info.table[adj_row][adj_col]);\n\n\t\tstring tmp;\n\t\tfor(int row = 0; row <= 4; row++){\n\t\t\tfor(int col = 0; col <= 4; col++){\n\t\t\t\tif(rangeCheck(row,col)){\n\t\t\t\t\ttmp.append(to_string(next_info.table[row][col])).append(to_string('*'));\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\n\t\tauto at = MAP.find(tmp);\n\t\tif(at != MAP.end())continue;\n\n\t\tMAP[tmp] = true;\n\n\t\tnext_info.space_row1 = info.space_row1;\n\t\tnext_info.space_col1 = info.space_col1;\n\t\tnext_info.space_row2 = adj_row;\n\t\tnext_info.space_col2 = adj_col;\n\n\t\trecursive(next_info,depth+1,max_depth);\n\t}\n}\n\nvoid func(){\n\n\tfor(int i = 1; i < 13; i++)scanf(\"%d\",&p[i]);\n\n\tInfo first;\n\tfirst.table[0][2] = p[0];\n\tfor(int i = 1; i <= 3; i++)first.table[1][i] = p[i];\n\tfor(int i = 0; i <= 4; i++)first.table[2][i] = p[4+i];\n\tfor(int i = 1; i <= 3; i++)first.table[3][i] = p[8+i];\n\tfirst.table[4][2] = p[12];\n\n\tint count = 0;\n\n\tfor(int row = 0; row <= 4; row++){\n\t\tfor(int col = 0; col <= 4; col++){\n\t\t\tif(rangeCheck(row,col) == true && first.table[row][col] == 0){\n\t\t\t\tif(count == 0){\n\t\t\t\t\tfirst.space_row1 = row;\n\t\t\t\t\tfirst.space_col1 = col;\n\t\t\t\t\tcount++;\n\t\t\t\t}else{\n\t\t\t\t\tfirst.space_row2 = row;\n\t\t\t\t\tfirst.space_col2 = col;\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t}\n\n\tclearFLG = false;\n\n\tfor(int max_depth = 0; max_depth <= 20; max_depth++){\n\t\tMAP.clear();\n\n\t\tstring tmp;\n\t\tfor(int row = 0; row <= 4; row++){\n\t\t\tfor(int col = 0; col <= 4; col++){\n\t\t\t\tif(rangeCheck(row,col)){\n\t\t\t\t\ttmp.append(to_string(first.table[row][col])).append(to_string('*'));\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\n\t\tMAP[tmp] = true;\n\n\t\trecursive(first,0,max_depth);\n\t\tif(clearFLG){\n\t\t\tans = max_depth;\n\t\t\tbreak;\n\t\t}\n\t}\n\n\tif(clearFLG){\n\t\tprintf(\"%d\\n\",ans);\n\t}else{\n\t\tprintf(\"NA\\n\");\n\t}\n}\n\nint main(){\n\n\twhile(true){\n\t\tscanf(\"%d\",&p[0]);\n\t\tif(p[0] == -1)break;\n\n\t\tfunc();\n\t}\n\n\treturn 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\nusing namespace std;\n\nconst int H = 5;\nconst int W = 5;\n\nstruct State {\n  int g[H][W];\n  int x[2], y[2];\n  bool operator < (const State &s) const {\n    for(int i = 0, k = 0; i < H; ++i) {\n      for(int j = abs(2-i); j < W-abs(2-i); ++j) {\n        if(g[i][j] != s.g[i][j]) return g[i][j] < s.g[i][j];\n      }\n    }\n    return false;\n  }\n  bool operator == (const State &s) const {\n    return !(*this < s) && !(s < *this);\n  }\n};\n\nmap<State,int> bfs1(State src) {\n  const static int dx[4] = {1,0,-1,0};\n  const static int dy[4] = {0,1,0,-1};\n  map<State,int> cost;\n  queue<State> que;\n  cost[src] = 0;\n  que.push(src);\n  while(que.size()) {\n    const State s = que.front();\n    que.pop();\n    if(cost[s] == 10) continue;\n    for(int k = 0; k < 2; ++k) {\n      for(int i = 0; i < 4; ++i) {\n        int nx = s.x[k] + dx[i];\n        int ny = s.y[k] + dy[i];\n        if(nx < 0 || nx >= W) continue;\n        if(ny < 0 || ny >= H) continue;\n        if(s.g[ny][nx] <= 0) continue;\n        State t = s;\n        swap(t.g[t.y[k]][t.x[k]], t.g[ny][nx]);\n        t.x[k] = nx;\n        t.y[k] = ny;\n        if(cost.count(t)) continue;\n        cost[t] = cost[s] + 1;\n        que.push(t);\n      }\n    }\n  }\n  return cost;\n}\n\nint bfs2(State src, map<State,int> rcost) {\n  const static int dx[4] = {1,0,-1,0};\n  const static int dy[4] = {0,1,0,-1};\n  if(rcost.count(src)) return rcost[src];\n  map<State,int> cost;\n  queue<State> que;\n  cost[src] = 0;\n  que.push(src);\n  while(que.size()) {\n    const State s = que.front();\n    que.pop();\n    if(cost[s] == 10) continue;\n    for(int k = 0; k < 2; ++k) {\n      for(int i = 0; i < 4; ++i) {\n        int nx = s.x[k] + dx[i];\n        int ny = s.y[k] + dy[i];\n        if(nx < 0 || nx >= W) continue;\n        if(ny < 0 || ny >= H) continue;\n        if(s.g[ny][nx] <= 0) continue;\n        State t = s;\n        swap(t.g[t.y[k]][t.x[k]], t.g[ny][nx]);\n        t.x[k] = nx;\n        t.y[k] = ny;\n        if(cost.count(t)) continue;\n        cost[t] = cost[s] + 1;\n        que.push(t);\n        if(rcost.count(t)) {\n          return cost[t] + rcost[t];\n        }\n      }\n    }\n  }\n  return -1;\n}\n\nint main() {\n  State src, dst;\n  fill(src.g[0], src.g[H], -1);\n  fill(dst.g[0], dst.g[H], -1);\n  for(int i = 0, k = 0, t = 0; i < H; ++i) {\n    for(int j = abs(2-i); j < W-abs(2-i); ++j) {\n      dst.g[i][j] = t % 12;\n      ++t;\n      if(dst.g[i][j] == 0) {\n        dst.x[k] = j;\n        dst.y[k] = j;\n        ++k;\n      }\n    }\n  }\n  while(1) {\n    for(int i = 0, k = 0; i < H; ++i) {\n      for(int j = abs(2-i); j < W-abs(2-i); ++j) {\n        cin >> src.g[i][j];\n        if(src.g[i][j] == -1) return 0;\n        if(src.g[i][j] == 0) {\n          src.x[k] = j;\n          src.y[k] = i;\n          ++k;\n        }\n      }\n    }\n    int res = bfs2(src, bfs1(dst));\n    if(res == -1 || res > 20) cout << \"NA\" << endl;\n    else cout << res << endl;\n  }\n  return 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include<iostream>\n#include<vector>\n#include<algorithm>\n#include<map>\n#include<queue>\n\nusing namespace std;\n\nmap<vector<int>,int>mp,used;\n\nstruct State{\n  vector<int>v;\n  int t;\n  State(vector<int>v,int t):v(v),t(t){}\n};\n\nvector<vector<int> > generate(vector<int> v){\n  vector<vector<int> >res;\n\n  for(int i=0;i<13;i++){\n    if(v[i]==0){\n      vector<int>tmp=v;\n      switch(i){\n      case 0:\n\tswap(tmp[0],tmp[2]);\n\tres.push_back(tmp);\n\tbreak;\n      case 1:\n\tswap(tmp[1],tmp[2]);\n\tres.push_back(tmp);\n\tswap(tmp[1],tmp[2]);\n\tswap(tmp[1],tmp[5]);\n\tres.push_back(tmp);\n\tbreak;\n      case 2:\n\tswap(tmp[2],tmp[0]);\n\tres.push_back(tmp);\n\tswap(tmp[2],tmp[0]);\n\n\tswap(tmp[2],tmp[1]);\n\tres.push_back(tmp);\n\tswap(tmp[2],tmp[1]);\n\n\tswap(tmp[2],tmp[3]);\n\tres.push_back(tmp);\n\tswap(tmp[2],tmp[3]);\n\n\tswap(tmp[2],tmp[6]);\n\tres.push_back(tmp);\n\tbreak;\n      case 3:\n\tswap(tmp[3],tmp[2]);\n\tres.push_back(tmp);\n\tswap(tmp[3],tmp[2]);\n\n\tswap(tmp[3],tmp[7]);\n\tres.push_back(tmp);\n\tbreak;\n      case 4:\n\tswap(tmp[4],tmp[5]);\n\tres.push_back(tmp);\n\tbreak;\n      case 5:\n\tswap(tmp[5],tmp[1]);\n\tres.push_back(tmp);\n\tswap(tmp[5],tmp[1]);\n\n\tswap(tmp[5],tmp[4]);\n\tres.push_back(tmp);\n\tswap(tmp[5],tmp[4]);\n\n\tswap(tmp[5],tmp[6]);\n\tres.push_back(tmp);\n\tswap(tmp[5],tmp[6]);\n\n\tswap(tmp[5],tmp[9]);\n\tres.push_back(tmp);\n\tbreak;\n      case 6:\n\tswap(tmp[6],tmp[2]);\n\tres.push_back(tmp);\n\tswap(tmp[6],tmp[2]);\n\n\tswap(tmp[6],tmp[5]);\n\tres.push_back(tmp);\n\tswap(tmp[6],tmp[5]);\n\n\tswap(tmp[6],tmp[7]);\n\tres.push_back(tmp);\n\tswap(tmp[6],tmp[7]);\n\n\tswap(tmp[6],tmp[10]);\n\tres.push_back(tmp);\n\tbreak;\n      case 7:\n\tswap(tmp[7],tmp[3]);\n\tres.push_back(tmp);\n\tswap(tmp[7],tmp[3]);\n\n\tswap(tmp[7],tmp[6]);\n\tres.push_back(tmp);\n\tswap(tmp[7],tmp[6]);\n\n\tswap(tmp[7],tmp[8]);\n\tres.push_back(tmp);\n\tswap(tmp[7],tmp[8]);\n\n\tswap(tmp[7],tmp[11]);\n\tres.push_back(tmp);\n\tbreak;\n      case 8:\n\tswap(tmp[8],tmp[7]);\n\tres.push_back(tmp);\n\tbreak;\n      case 9: \n\tswap(tmp[9],tmp[5]);\n\tres.push_back(tmp);\n\tswap(tmp[9],tmp[5]);\n\n\tswap(tmp[9],tmp[10]);\n\tres.push_back(tmp);\n\tbreak;\n      case 10:\n\tswap(tmp[10],tmp[6]);\n\tres.push_back(tmp);\n\tswap(tmp[10],tmp[6]);\n\n\tswap(tmp[10],tmp[9]);\n\tres.push_back(tmp);\n\tswap(tmp[10],tmp[9]);\n\n\tswap(tmp[10],tmp[11]);\n\tres.push_back(tmp);\n\tswap(tmp[10],tmp[11]);\n\n\tswap(tmp[10],tmp[12]);\n\tres.push_back(tmp);\n\tbreak;\n      case 11:\n\tswap(tmp[11],tmp[7]);\n\tres.push_back(tmp);\n\tswap(tmp[11],tmp[7]);\n\n\tswap(tmp[11],tmp[10]);\n\tres.push_back(tmp);\n\tbreak;\n      case 12:\n\tswap(tmp[12],tmp[10]);\n\tres.push_back(tmp);\n\tbreak;\n      }\n    }\n  }\n  return res;\n}\n\nvoid bfs(void){\n\n  queue<State>que;\n  vector<int>s;\n  for(int i=0;i<12;i++)s.push_back(i);\n  s.push_back(0);\n  que.push(State(s,0));\n\n  while(!que.empty()){\n    State now=que.front();\n    que.pop();\n    \n    if(mp.count(now.v) && now.t>=mp[now.v])continue;\n    if(now.t>=12)continue;\n\n    mp[now.v]=now.t;\n\n    vector<vector<int> >res=generate(now.v);\n    for(int i=0;i<res.size();i++){\n      que.push(State(res[i],now.t+1));\n    }\n  }\n}\n\nint bfs(vector<int> s){\n  \n  used.clear();\n  \n  queue<State>que;\n  que.push(State(s,0));\n  \n  while(!que.empty()){\n    State now=que.front();\n    que.pop();\n    \n    if(now.t>=11)continue;\n    if(used.count(now.v))continue;\n    if(mp.count(now.v))return now.t+mp[now.v];\n    used[now.v]=1;\n    \n    vector<vector<int> >res=generate(now.v);\n    for(int i=0;i<res.size();i++){\n      que.push(State(res[i],now.t+1));\n    }\n  }\n  return -1;\n}\n\nint main(void){\n\n  bfs();\n\n  while(true){\n    vector<int>s(13);\n    for(int i=0;i<13;i++){\n      cin >> s[i];\n      if(s[i]<0)return 0;\n    }\n    int res=bfs(s);\n    if(res<0)cout << \"NA\" << endl;\n    else cout << res << endl;\n  }\n\n  return 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include<iostream>\n#include<cstdio>\nusing namespace std;\nint field[5][5];\nint log[5][5];\nint num[13];\nvoid SETING();\nint main(){\n  while(cin >>num[0]){\n    if(num[0] == -1){break;}\n    int a;\n    for(int i=1; i<13; i++){\n      cin >>a;\n      num[i] = a;\n    }\n    SETING();\n    int cost = 0;\n    for(int k=1; k<12; k++){\n      int x,y,s,t;\n      for(int i=0; i<5; i++){\n\tfor(int j=0; j<5; j++){\n\t  if(field[i][j] == k){x = i; y = j;}\n\t}\n      }\n      for(int i=0; i<5; i++){\n\tfor(int j=0; j<5; j++){\n\t  if(log[i][j] == k){s = i; t = j;}\n\t}\n      }\n      if(x>s){cost+=x-s;}\n      if(x<s){cost+=s-x;}\n      if(y>t){cost+=y-t;}\n      if(y<t){cost+=t-y;}\n    }\n    if(cost<21){cout <<cost<<endl;}\n    else{cout <<\"NA\"<<endl;}\n  }\n  return 0;\n}\nvoid SETING(){\n  for(int i=0; i<5; i++){\n    for(int j=0; j<5; j++){\n      field[i][j] = -1;\n      log[i][j] = -1;\n    }\n  }\n  field[2][0] = num[0];\n  field[1][1] = num[1];\n  field[2][1] = num[2];\n  field[3][1] = num[3];\n  field[1][2] = num[4];\n  field[1][2] = num[5];\n  field[2][2] = num[6];\n  field[3][2] = num[7];\n  field[4][2] = num[8];\n  field[1][3] = num[9];\n  field[2][3] = num[10];\n  field[3][3] = num[11];\n  field[2][4] = num[12];\n  log[2][0] = 0;\n  log[1][1] = 1;\n  log[2][1] = 2;\n  log[3][1] = 3;\n  log[1][2] = 4;\n  log[1][2] = 5;\n  log[2][2] = 6;\n  log[3][2] = 7;\n  log[4][2] = 8;\n  log[1][3] = 9;\n  log[2][3] = 10;\n  log[3][3] = 11;\n  log[2][4] = 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include <iostream>\n#include <string>\n#include <vector>\n#include <queue>\n#include <map>\nusing namespace std;\n\nstring s = \"0123456789AB\";\nstring goal = \"0123456789AB0\";\n\nvector<vector<int>> adj = {\n    {2},\n    {2,5},\n    {0,1,3,6},\n    {2,7},\n    {5},\n    {1,4,6,9},\n    {2,5,7,10},\n    {3,6,8,11},\n    {7},\n    {5,10},\n    {6,9,11,12},\n    {7,10},\n    {10}\n};\n\nint solve(string stat) {\n    map<string, int> dist;\n    dist[stat] = 0;\n    queue<string> q;\n    q.push(stat);\n    while ( ! q.empty()) {\n        string s = q.front();\n        q.pop();\n        int diff = 0;\n        for (int k=0; k<13; ++k) {\n            if (s[k] != '0') {\n                diff += s[k] != goal[k];\n            }\n        }\n        if ( ! diff) {\n            return dist[s];\n        }\n        if (20 < dist[s] + diff) {\n            continue;\n        }\n        for (int i=0; i<13; ++i) {\n            if (s[i] != '0') continue;\n            for (int j : adj[i]) {\n                string next = s;\n                next[i] = s[j];\n                next[j] = s[i];\n                if (dist.find(next) == dist.end()) {\n                    dist[next] = dist[s] + 1;\n                    q.push(next);\n                }\n            }\n        }\n    }\n    return 21;\n}\n\nint main() {\n    ios::sync_with_stdio(false);\n    while (1) {\n        string stat = \"\";\n        int k;\n        for (int i=0; i<13; ++i) {\n            if (cin >> k && !~k) return 0;\n            stat += s[k];\n        }\n        int ans = solve(stat);\n        if (ans <= 20) {\n            cout << ans << endl;\n            continue;\n        }\n        cout << \"NA\" << endl;\n    }\n    return 0;\n}"
  },
  {
    "language": "C++",
    "code": "#define _USE_MATH_DEFINES\n#define INF 10000000\n#include <iostream>\n#include <sstream>\n#include <cmath>\n#include <algorithm>\n#include <queue>\n#include <stack>\n#include <limits>\n#include <map>\n#include <string>\n#include <cstring>\n#include <set>\n#include <deque>\n#include <bitset>\n\nusing namespace std;\n\ntypedef long long ll;\ntypedef pair<int,string> P;\n\nstatic const double eps = 1e-8;\n\nstatic const int t[][2] = {{1,0},{0,1},{-1,0},{0,-1}};\nstatic const int s[][2] = {{0,2},{1,1},{1,2},{1,3},\n{2,0},{2,1},{2,2},{2,3},{2,4},{3,1},{3,2},{3,3},{4,2}};\n\nvoid bfsRoot(map<vector< vector<int> >,int>& cost,vector< vector<int> >& rv){\n\tcost[rv] = 0;\n\tqueue<vector< vector<int> > > que;\n\tque.push(rv);\n\n\twhile(!que.empty()){\n\t\tvector< vector<int> > now = que.front();\n\t\tque.pop();\n\n\t\tfor(int i=0;i<13;i++){\n\t\t\tint x = s[i][1];\n\t\t\tint y = s[i][0];\n\t\t\tif(now[y][x] != 0) continue;\n\n\t\t\tfor(int j=0;j<4;j++){\n\t\t\t\tint dx = x + t[j][0];\n\t\t\t\tint dy = y + t[j][1];\n\n\t\t\t\tif(dy < 0 || dy >= 5 || dx < 0 || dx >= 5) continue;\n\t\t\t\tif(now[dy][dx] == -1) continue;\n\t\t\t\tif(now[dy][dx] == 0) continue;\n\n\t\t\t\tvector< vector<int> > tmp = now;\n\t\t\t\tswap(tmp[y][x],tmp[dy][dx]);\n\n\t\t\t\tif(cost.find(tmp) != cost.end()) continue;\n\t\t\t\tcost[tmp] = cost[now] + 1;\n\t\t\t\tif(cost[tmp] >= 10) continue;\n\t\t\t\tque.push(tmp);\n\t\t\t}\n\t\t}\n\t}\n}\n\nint bfs(map<vector< vector<int> >,int>& cost,vector< vector<int> >& rv,\n\tmap<vector< vector<int> >,int>& costR){\n\tcost[rv] = 0;\n\tqueue<vector< vector<int> > > que;\n\tque.push(rv);\n\n\tif(costR.find(rv) != costR.end()) return costR[rv];\n\n\twhile(!que.empty()){\n\t\tvector< vector<int> > now = que.front();\n\t\tque.pop();\n\n\t\tfor(int i=0;i<13;i++){\n\t\t\tint x = s[i][1];\n\t\t\tint y = s[i][0];\n\t\t\tif(now[y][x] != 0) continue;\n\n\t\t\tfor(int j=0;j<4;j++){\n\t\t\t\tint dx = x + t[j][0];\n\t\t\t\tint dy = y + t[j][1];\n\n\t\t\t\tif(dy < 0 || dy >= 5 || dx < 0 || dx >= 5) continue;\n\t\t\t\tif(now[dy][dx] == -1) continue;\n\t\t\t\tif(now[dy][dx] == 0) continue;\n\n\t\t\t\tvector< vector<int> > tmp = now;\n\t\t\t\tswap(tmp[y][x],tmp[dy][dx]);\n\n\t\t\t\tif(cost.find(tmp) != cost.end()) continue;\n\n\t\t\t\tcost[tmp] = cost[now] + 1;\n\t\t\t\tif(costR.find(tmp) != costR.end()) return costR[tmp] + cost[tmp]; \n\n\t\t\t\tif(cost[tmp] >= 10) continue;\n\t\t\t\tque.push(tmp);\n\t\t\t}\n\t\t}\n\t}\n\n\treturn -1;\n}\n\nint main(){\n\tint table[5][5];\n\tint root[5][5];\n\tmemset(table,-1,sizeof(table));\n\tmemset(root,-1,sizeof(root));\n\troot[0][2] = 0;\n\troot[1][1]=1; root[1][2]=2; root[1][3]=3;\n\troot[2][0]=4; root[2][1]=5; root[2][2]=6; root[2][3]=7; root[2][4]=8;\n\troot[3][1]=9; root[3][2]=10; root[3][3]=11;\n\troot[4][2] = 0;\n\n\tvector< vector<int> > rv(5,vector<int>(5));\n\tmap<vector< vector<int> >,int> costR;\n\t\n\n\tfor(int y=0;y<5;y++){\n\t\tfor(int x=0;x<5;x++){\n\t\t\trv[y][x] = root[y][x];\n\t\t}\n\t}\n\tbfsRoot(costR,rv);\n\n\twhile(~scanf(\"%d\",&table[0][2])){\n\t\tif(table[0][2] == -1) break;\n\t\tscanf(\"%d %d %d\",&table[1][1],&table[1][2],&table[1][3]);\n\t\tscanf(\"%d %d %d %d %d\",&table[2][0],&table[2][1],&table[2][2],&table[2][3],&table[2][4]);\n\t\tscanf(\"%d %d %d\",&table[3][1],&table[3][2],&table[3][3]);\n\t\tscanf(\"%d\",&table[4][2]);\n\t\tvector< vector<int> > tv(5,vector<int>(5));\n\n\t\tfor(int y=0;y<5;y++){\n\t\t\tfor(int x=0;x<5;x++){\n\t\t\t\ttv[y][x] = table[y][x];\n\t\t\t}\n\t\t}\n\t\tmap<vector< vector<int> >,int> cost;\n\t\tint res = bfs(cost,tv,costR);\n\n\t\tif(res != -1) printf(\"%d\\n\",res);\n\t\telse printf(\"NA\\n\");\n\t}\n}"
  },
  {
    "language": "C++",
    "code": "//35\n#include<iostream>\n#include<vector>\n#include<set>\n#include<algorithm>\n#include<queue>\n\nusing namespace std;\n\nstruct S{\n  vector<int> v;\n  int t;\n};\n\nint main(){\n  for(;;){\n    vector<int> v(13);\n    cin>>v[2]>>v[1]>>v[4]>>v[7]>>v[0]>>v[3]>>v[6]>>v[9]>>v[12]>>v[5]>>v[8]>>v[11]>>v[10];\n    if(v[2]==-1)return 0;\n    queue<S> que;\n    S is={v,0};\n    que.push(is);\n    set<vector<int> > p;\n    while(!que.empty()&&que.front().t<=20){\n      S  c=que.front();\n      int g[]={4,1,0,5,2,9,6,3,10,7,0,11,8};\n      if(c.v==vector<int>(g,g+13))break;\n      que.pop();\n      if(p.count(c.v))continue;\n      int nr=0;\n      for(int i=0;i<13;i++){\n\tnr+=g[i]&&c.v[i]==g[i];\n      }\n      if(20-c.t<11-nr)continue;\n      p.insert(c.v);\n      for(int i=0;i<13;i++){\n\tif(c.v[i]==0){\n\t  for(int j=0;j<4;j++){\n\t    static int d[]={-2,3,2,-3};\n\t    static int b[][5]={{0,1,2,7,12},{2,7,12,11,10},{12,11,10,5,0},{10,5,0,1,2}};\n\t    int k;\n\t    for(k=0;k<5;k++){\n\t      if(i==b[j][k])break;\n\t    }\n\t    if(k==5){\n\t      vector<int> n=c.v;\n\t      swap(n[i],n[i+d[j]]);\n\t      S ns={n,c.t+1};\n\t      if(!p.count(n)){\n\t\tque.push(ns);\n\t      }\n\t    }\n\t  }\n\t}\n      }\n    }\n    if(que.empty()||que.front().t>20){\n      cout<<\"NA\"<<endl;\n    }else{\n      cout<<que.front().t<<endl;\n    }\n  }\n  return 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include <iostream>\n#include <algorithm>\n#include <vector>\n#include <queue>\n#include <map>\nusing namespace std;\n#define rep(i,n) for(int i=0;i<n;i++)\nclass NODE{\npublic:\n\tvector<int> data;\n\tint depth;\n\tint e[2];\n\tNODE(int a[13],int d,int E[2]){\n\t\tdata.resize(13);\n\t\trep(i,13)data[i] = a[i];\n\t\tdepth = d;\n\t\trep(i,2)e[i] = E[i];\n\t}\n\tNODE(){\n\t\tdepth = 0;\n\t\tdata.resize(13);\n\t}\n};\n\nint di[13][10] = {\n\t{2,-1},\n\t{2,5,-1},\n\t{0,1,3,6,-1},\n\t{2,7,-1},\n\t{5,-1},\n\t{1,4,6,9,-1},\n\t{2,5,7,10,-1},\n\t{3,6,7,11,-1},\n\t{7},\n\t{5,10,-1},\n\t{6,9,11,12,-1},\n\t{7,10,-1},\n\t{10,-1}\n};\nint rx[] = {3,2,3,4,1,2,3,4,5,2,3,4,3};\nint ry[] = {1,2,2,2,3,3,3,3,3,4,4,4,5};\n\nint main(){\n\twhile(1){\n\t\tint ret = 21;\n\t\tNODE fst; int cnt = 0;\n\t\trep(i,13){\n\t\t\tif(cin >>fst.data[i] , fst.data[i] != -1){\n\t\t\t\tif(fst.data[i] == 0){\n\t\t\t\t\tfst.e[cnt] = i;\n\t\t\t\t\tcnt++;\n\t\t\t\t}\n\t\t\t}else{\n\t\t\t\treturn 0;\n\t\t\t}\n\t\t}\n\t\tmap< vector<int> , int > done;\n\t\t\n\t\tqueue<NODE> Q;\n\t\tQ.push(fst);\n\t\tdone[Q.front().data] = 0;\n\t\t\n\t\twhile(Q.size()){\n\t\t\tNODE q = Q.front(); Q.pop();\n\n\t\t\tint mndist = 0;\n\t\t\trep(i,13)mndist += abs(rx[q.data[i]]-rx[i]) + abs(ry[q.data[i]]-ry[i]);\n\t\t\t\n\t\t\tif(mndist + q.depth > 30)continue;\n\t\t\t\n\t\t\tif( q.data[0] == 0 && q.data[1] == 1 && q.data[2] == 2 && q.data[3] == 3 && q.data[4] == 4 && q.data[5] == 5 && q.data[6] == 6 && q.data[7] == 7 &&\n\t\t\t\t\tq.data[8] == 8 && q.data[9] == 9 && q.data[10]==10 && q.data[11]==11 && q.data[12]==0\n\t\t\t){\n\t\t\t\tcout << q.depth << endl;\n\t\t\t\tgoto jmp;\n\t\t\t}\n\n\t\t\trep(o,2){\n\t\t\t\tfor(int i=0;di[q.e[o]][i] != -1;i++){\n\t\t\t\t\tNODE next = q;\n\t\t\t\t\tnext.e[o] = next.data[di[q.e[o]][i]];\n\t\t\t\t\tswap(next.data[q.e[o]] , next.data[di[q.e[o]][i]]);\n\t\t\t\t\tnext.depth = q.depth + 1;\n\t\t\t\t\t\n\t\t\t\t\tif( done.find(next.data) == done.end() ){\n\t\t\t\t\t\tdone[next.data] = next.depth;\n\t\t\t\t\t\tif( q.depth < 20)Q.push(next);\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t\tcout << \"NA\" << endl;\n\t\tjmp:;\n\t}\n}"
  },
  {
    "language": "C++",
    "code": "#include <cstdio>\n#include <cstdlib>\n#include <cmath>\n#include <climits>\n#include <cfloat>\n#include <map>\n#include <utility>\n#include <set>\n#include <iostream>\n#include <memory>\n#include <string>\n#include <vector>\n#include <algorithm>\n#include <functional>\n#include <sstream>\n#include <complex>\n#include <stack>\n#include <queue>\n#include <cstring>\n#include <sstream>\n#include <cassert>\n#include <list>\nusing namespace std;\nstatic const double EPS = 1e-10;\ntypedef long long ll;\ntypedef pair<int,int> PI;\ntypedef vector<int> vi;\n#ifndef M_PI\n#define M_PI 3.14159265358979323846\n#endif\n#define rep(i,n) for(int i=0;i<(int)n;++i)\n#define FOR(i,c) for(__typeof((c).begin())i=(c).begin();i!=(c).end();++i)\n#define ALL(c) (c).begin(), (c).end()\n#define mp(a,b) make_pair(a,b)\n#define pb(a) push_back(a)\n#define F first\n#define S second\ntemplate <typename T> string print_array(const vector<T> &V) { ostringstream os; os << \"{ \"; for (typename vector<T>::const_iterator iter = V.begin(); iter != V.end(); ++iter) os << '\\\"' << *iter << \"\\\",\"; os << \" }\"; return os.str(); }\n\nint dx[]={0,1,0,-1},dy[]={1,0,-1,0};\n\nvector<int> se[13];\nint x[]={0,-1,0,1,-2,-1,0,1,2,-1,0,1,0};\nint y[]={2,1,1,1,0,0,0,0,0,-1,-1,-1,-2};\n\nvoid pr(ll in){\n\n  printf(\"      %3lld\\n\",in&15);\n  printf(\"   %3lld%3lld%3lld\\n\",(in>>4)&15,(in>>8)&15,(in>>12)&15);\n  printf(\"%3lld%3lld%3lld%3lld%3lld\\n\",(in>>16)&15,(in>>20)&15,(in>>24)&15,(in>>28)&15,(in>>32)&15);\n  printf(\"   %3lld%3lld%3lld\\n\",(in>>36)&15,(in>>40)&15,(in>>44)&15);\n  printf(\"      %3lld\\n\",(in>>48)&15);\n  puts(\"\");\n}\n\nint manh(ll in){\n  int ret=0;\n  rep(i,13){\n    int t=(in>>(i*4))&15;\n\n    if(!t)continue;\n    int nx=(x[t]-x[i]),ny=y[t]-y[i];\n    ret+=abs(nx)+abs(ny);\n  }\n  return ret;\n}\n\nmain(){\n  ll p;\n\n  ll goal=0;\n  rep(i,11){\n    goal|=(i+1LL)<<(4*(i+1));\n    //cout<<goal<<endl;\n    //pr(goal);\n  }\n  //pr(goal);\n\n  se[0].pb(2);\n  se[1].pb(2);\n  se[1].pb(5);\n  se[2].pb(0);\n  se[2].pb(1);\n  se[2].pb(3);\n  se[2].pb(6);\n  se[3].pb(2);\n  se[3].pb(7);\n  se[4].pb(5);\n  se[5].pb(1);\n  se[5].pb(4);\n  se[5].pb(6);\n  se[5].pb(9);\n  se[6].pb(2);\n  se[6].pb(5);\n  se[6].pb(7);\n  se[6].pb(10);\n  se[7].pb(3);\n  se[7].pb(6);\n  se[7].pb(8);\n  se[7].pb(11);\n  se[8].pb(7);\n  se[9].pb(5);\n  se[9].pb(10);\n  se[10].pb(6);\n  se[10].pb(9);\n  se[10].pb(11);\n  se[10].pb(12);\n  se[11].pb(7);\n  se[11].pb(10);\n  se[12].pb(10);\n  \n  while(cin>>p){\n    if(p==-1)break;\n    ll in=p;\n\n    rep(i,12){\n      cin>>p;\n      in|=p<<(4*(i+1));\n    }\n\n    set<ll> app;\n\n    queue<pair<int,ll> > Q;\n    app.insert(in);\n    Q.push(mp(0,in));\n    int ans=21;\n    int mans=0;\n\n    while(!Q.empty()){\n      ll cvec=Q.front().S;\n      int ccost=Q.front().F;\n      Q.pop();\n    \n      //pr(cvec);\n\n      //if(ccost>3)break;\n      if(ccost+manh(cvec)+3>20)break;\n      if(cvec==goal){\n\tans=ccost;\n\tbreak;\n      }\n      rep(i,13){\n\tll t=cvec>>(i<<2);\n\tt=t&15;\n\tif(!t){\n\t  rep(j,se[i].size()){\n\t    t=cvec>>(se[i][j]<<2);\n\t    t=t&15;\n\t    if(t){\n\t      ll nvec=cvec;\n\t      t=t<<(i<<2);\n\t      nvec|=t;\n\t      nvec&=~(15LL<<se[i][j]*4);\n\t      \n\t      if(!app.count(nvec)){\n\t\tapp.insert(nvec);\n\t\tQ.push(mp(ccost+1,nvec));\n\t      }\n\t    }\n\t  }\n\t}\n      }\n    }\n    if(ans==21)cout<<\"NA\"<<endl;\n    else cout<<ans<<endl;\n  }\n}"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\n\nusing namespace std;\n\ntypedef long long ll;\ntypedef long double ld;\ntypedef tuple<int, int> duo;\nconst int dx[] = {0, 0, 1, -1, 1, 1, -1, -1};\nconst int dy[] = {1, -1, 0, 0, 1, -1, 1, -1};\nconst int Mod = 1000000000 + 0;\n//{{{ templates\n#define TT_             \\\n  template <typename T> \\\n  inline\n#define TTF_                        \\\n  template <typename T, typename F> \\\n  inline\nTT_ T sq(T x) { return x * x; }\nTT_ T In() {\n  T x;\n  cin >> x;\n  return x;\n}\nTT_ void Out(T& x) { cout << x; }\nTT_ void sort(T& v) { sort(begin(v), end(v)); }\nTT_ void revs(T& v) { reverse(begin(v), end(v)); }\nTT_ void uniq(T& v) {\n  sort(v);\n  v.erase(unique(begin(v), end(v)), end(v));\n}\nTT_ int ubnd(T& v, typename T::value_type& x) {\n  return upper_bound(begin(v), end(v), x) - begin(v);\n}\nTT_ int lbnd(T& v, typename T::value_type& x) {\n  return lower_bound(begin(v), end(v), x) - begin(v);\n}\nTTF_ void inpt(T& v, int n, F f) {\n  for (v.reserve(n); n--; v.emplace_back(f()))\n    ;\n}\nTTF_ void show(T& v, F f, string d = \" \", string e = \"\\n\") {\n  int i = 0;\n  for (auto& x : v) i++&&(cout << d), f(x);\n  cout << e;\n}\nTT_ typename T::iterator minel(T& v) { return min_element(begin(v), end(v)); }\nTT_ typename T::iterator maxel(T& v) { return max_element(begin(v), end(v)); }\n\ninline void fast_io() {\n  ios::sync_with_stdio(0);\n  cin.tie(0);\n}\ninline int in() {\n  int x;\n  scanf(\"%d\", &x);\n  return x;\n}\ninline ll pow_mod(ll a, ll k, ll m) {\n  ll r = 1;\n  for (; k > 0; a = a * a % m, k >>= 1)\n    if (k & 1) r = r * a % m;\n  return r;\n}\ninline ll mod_inv(ll a, ll p) { return pow_mod(a, p - 2, p); }\n//}}} priority_queue queue deque front stringstream max_element min_element\n// insert count make_tuple\n\nstruct Board {\n  Board() {\n    memcpy(b, \"0123456789AB0\", sizeof(b));\n    find_zero();\n    turn = 0;\n  }\n  Board(const vector<int>& v) {\n    for (int i = 0; i < 13; i++) b[i] = conv_hex(v[i]);\n    b[13] = 0;\n    find_zero();\n    turn = 0;\n  }\n  void find_zero(){\n    int it = 0;\n    for (int i = 0; i < 13; i++){\n      if (b[i] == '0'){\n        cur[it] = i;\n        it++;\n      }\n    }\n  }\n  char conv_hex(int a) { return \"0123456789ABCDEF\"[a]; }\n  bool slide(int index, int dir) {\n    static const char mov[][4] = {\n      {-1, -1, 2, -1},\n      {-1, 2, 5, -1},\n      {0, 3, 6, 1},\n      {-1, -1, 7, 2},\n      {-1, 5, -1, -1},\n      {1, 6, 9, 4},\n      {2, 7, 10, 5},\n      {3, 8, 11, 6},\n      {-1, -1, -1, 7},\n      {5, 10, -1, -1},\n      {6, 11, 12, 9},\n      {7, -1, -1, 10},\n      {10, -1, -1, -1},\n    };\n    char cu = cur[index];\n    char nu = mov[cu][dir];\n    if (nu == -1) return false;\n    if (b[nu] == '0') return false;\n    swap(b[cu], b[nu]);\n    cur[index] = nu;\n    turn++;\n    return true;\n  }\n  char b[14];\n  char cur[2];\n  char turn;\n};\n\nvoid build_table(unordered_map<ll, char>& ans){\n  Board b;\n  queue<Board> Q;\n  Q.push(b);\n  while (!Q.empty()){\n    Board bi = Q.front();\n    Q.pop();\n    ll hv = strtoll(bi.b, 0, 16);\n    if (ans.count(hv)) continue;\n    ans[hv] = bi.turn;\n    if (bi.turn >= 10) continue;\n    for (int i = 0; i < 2; i++){\n      for (int d = 0; d < 4; d++){\n        auto bii = bi;\n        if (!bii.slide(i, d)) continue;\n        Q.push(bii);\n      }\n    }\n  }\n}\n\nint main() {\n  unordered_map<ll, char> ans;\n  build_table(ans);\n  int h;\n  while (h = in(), h != -1) {\n    vector<int> vs;\n    vs.push_back(h);\n    for (int i = 0; i < 12; i++) vs.push_back(in());\n    Board b(vs);\n    unordered_set<ll> vis;\n    queue<Board> Q;\n    Q.push(b);\n    while (!Q.empty()){\n      Board bi = Q.front();\n      Q.pop();\n      ll hv = strtoll(bi.b, 0, 16);\n      if (vis.count(hv)) continue;\n      vis.insert(hv);\n      if (ans.count(hv)){\n        cout << (int)ans[hv] + (int)bi.turn << endl;\n        goto END;\n      }\n      if (bi.turn >= 10) continue;\n      for (int i = 0; i < 2; i++){\n        for (int d = 0; d < 4; d++){\n          Board bii = bi;\n          if (!bii.slide(i, d)) continue;\n          Q.push(bii);\n        }\n      }\n    }\n    cout << \"NA\\n\";\nEND:;\n  }\n  return 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include<map>\n#include<queue>\n#include<cstdio>\n#include<vector>\n\n#define\tpb\tpush_back\n\nusing namespace std;\n\ntypedef\tvector<int>\tvi;\n\nvi mv[13];\nlong long pow12[13];\n\nvoid findEmptyPos(long long stat,int *z){\n\tfor(int i=0,j=0;i<13;i++){\n\t\tif(stat%12==0)\tz[j++]=12-i;\n\t\tstat/=12;\n\t}\n}\n\nlong long sw(long long stat,int i,int j){\n\tlong long powi=pow12[12-i],powj=pow12[12-j];\n\tint pi=(stat/powi)%12,pj=(stat/powj)%12;\n\treturn stat+(pj-pi)*powi+(pi-pj)*powj;\n}\n\nvoid bfs(map<long long,int> &f,long long inistat,int stop){\n\tf[inistat]=0;\n\tqueue<long long> qu;\tqu.push(inistat);\n\twhile(!qu.empty()){\n\t\tlong long stat=qu.front();\tqu.pop();\n\t\tint cnt=f[stat];\n\t\tif(cnt==stop)\tbreak;\n\n\t\tint z[2];\tfindEmptyPos(stat,z);\n\t\tfor(int i=0;i<2;i++){\n\t\t\tfor(int j=0;j<mv[z[i]].size();j++){\n\t\t\t\tlong long nextstat=sw(stat,z[i],mv[z[i]][j]);\n\t\t\t\tif(f.count(nextstat)==0){\n\t\t\t\t\tqu.push(nextstat);\n\t\t\t\t\tf[nextstat]=cnt+1;\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t}\n}\n\nint main(){\n\tlong long a=1;\n\tfor(int i=0;i<13;i++)\tpow12[i]=a,a*=12;\n\n\tmv[0].pb(2);\n\tmv[1].pb(2);\tmv[1].pb(5);\n\tmv[2].pb(0);\tmv[2].pb(1);\tmv[2].pb(3);\tmv[2].pb(6);\n\tmv[3].pb(2);\tmv[3].pb(7);\n\tmv[4].pb(5);\n\tmv[5].pb(1);\tmv[5].pb(4);\tmv[5].pb(6);\tmv[5].pb(9);\n\tmv[6].pb(2);\tmv[6].pb(5);\tmv[6].pb(7);\tmv[6].pb(10);\n\tmv[7].pb(3);\tmv[7].pb(6);\tmv[7].pb(8);\tmv[7].pb(11);\n\tmv[8].pb(7);\n\tmv[9].pb(5);\tmv[9].pb(10);\n\tmv[10].pb(6);\tmv[10].pb(9);\tmv[10].pb(11);\tmv[10].pb(12);\n\tmv[11].pb(7);\tmv[11].pb(10);\n\tmv[12].pb(10);\n\n\tint ans[]={0,1,2,3,4,5,6,7,8,9,10,11,0};\n\tlong long ansstat=0;\n\tfor(int i=0;i<13;i++)\tansstat=ansstat*12+ans[i];\n\n\tmap<long long,int> f;\n\tbfs(f,ansstat,12);\n\n\tfor(long long inistat;scanf(\"%lld\",&inistat),~inistat;){\n\t\tfor(int i=1,p;i<13;i++)\tscanf(\"%d\",&p),inistat=inistat*12+p;\n\t\tmap<long long,int> g;\n\t\tbfs(g,inistat,8);\n\n\t\tint cmin=21;\n\t\tmap<long long,int>::iterator it;\n\t\tfor(it=g.begin();it!=g.end();it++){\n\t\t\tlong long stat=it->first;\n\t\t\tint cnt=it->second;\n\t\t\tif(f.count(stat))\tcmin=min(cmin,cnt+f[stat]);\n\t\t}\n\t\tif(cmin<=20)\tprintf(\"%d\\n\",cmin);\n\t\telse\tputs(\"NA\");\n\t}\n\n\treturn 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include<map>\n#include<queue>\n#include<cstdio>\n#include<vector>\n\n#define\tpb\tpush_back\n\nusing namespace std;\n\ntypedef\tvector<int>\tvi;\n\nvi mv[13];\nlong long pow12[13];\n\nvoid findEmptyPos(long long stat,int *z){\n\tfor(int i=0,j=0;i<13;i++){\n\t\tif(stat%12==0)\tz[j++]=12-i;\n\t\tstat/=12;\n\t}\n}\n\nlong long sw(long long stat,int i,int j){\n\tlong long powi=pow12[12-i],powj=pow12[12-j];\n\tint pi=(stat/powi)%12,pj=(stat/powj)%12;\n\treturn stat+(pj-pi)*powi+(pi-pj)*powj;\n}\n\nvoid bfs(map<long long,int> &f,long long inistat){\n\tf[inistat]=0;\n\tqueue<long long> qu;\tqu.push(inistat);\n\twhile(!qu.empty()){\n\t\tlong long stat=qu.front();\tqu.pop();\n\t\tint cnt=f[stat];\n\t\tif(cnt==10)\tbreak;\n\n\t\tint z[2];\tfindEmptyPos(stat,z);\n\t\tfor(int i=0;i<2;i++){\n\t\t\tfor(int j=0;j<mv[z[i]].size();j++){\n\t\t\t\tlong long nextstat=sw(stat,z[i],mv[z[i]][j]);\n\t\t\t\tif(f.count(nextstat)==0){\n\t\t\t\t\tqu.push(nextstat);\n\t\t\t\t\tf[nextstat]=cnt+1;\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t}\n}\n\nint main(){\n\tlong long a=1;\n\tfor(int i=0;i<13;i++)\tpow12[i]=a,a*=12;\n\n\tmv[0].pb(2);\n\tmv[1].pb(2);\tmv[1].pb(5);\n\tmv[2].pb(0);\tmv[2].pb(1);\tmv[2].pb(3);\tmv[2].pb(6);\n\tmv[3].pb(2);\tmv[3].pb(7);\n\tmv[4].pb(5);\n\tmv[5].pb(1);\tmv[5].pb(4);\tmv[5].pb(6);\tmv[5].pb(9);\n\tmv[6].pb(2);\tmv[6].pb(5);\tmv[6].pb(7);\tmv[6].pb(10);\n\tmv[7].pb(3);\tmv[7].pb(6);\tmv[7].pb(8);\tmv[7].pb(11);\n\tmv[8].pb(7);\n\tmv[9].pb(5);\tmv[9].pb(10);\n\tmv[10].pb(6);\tmv[10].pb(9);\tmv[10].pb(11);\tmv[10].pb(12);\n\tmv[11].pb(7);\tmv[11].pb(10);\n\tmv[12].pb(10);\n\n\tint ans[]={0,1,2,3,4,5,6,7,8,9,10,11,0};\n\tlong long ansstat=0;\n\tfor(int i=0;i<13;i++)\tansstat=ansstat*12+ans[i];\n\n\tmap<long long,int> f;\n\tbfs(f,ansstat);\n\n\tfor(long long inistat;scanf(\"%lld\",&inistat),~inistat;){\n\t\tfor(int i=1,p;i<13;i++)\tscanf(\"%d\",&p),inistat=inistat*12+p;\n\t\tmap<long long,int> g;\n\t\tbfs(g,inistat);\n\n\t\tint cmin=21;\n\t\tmap<long long,int>::iterator it;\n\t\tfor(it=g.begin();it!=g.end();it++){\n\t\t\tlong long stat=it->first;\n\t\t\tint cnt=it->second;\n\t\t\tif(f.count(stat))\tcmin=min(cmin,cnt+f[stat]);\n\t\t}\n\t\tif(cmin<=20)\tprintf(\"%d\\n\",cmin);\n\t\telse\tputs(\"NA\");\n\t}\n\n\treturn 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include<iostream>\n#include<vector>\n#include<algorithm>\n#include<map>\n#include<queue>\n\nusing namespace std;\n\nmap<vector<int>,int>mp,used;\n\nstruct State{\n  vector<int>v;\n  int t;\n  State(vector<int>v,int t):v(v),t(t){}\n};\n\nvector<vector<int> > generate(vector<int> v){\n  vector<vector<int> >res;\n\n  for(int i=0;i<13;i++){\n    if(v[i]==0){\n      vector<int>tmp=v;\n      switch(i){\n      case 0:\n\tswap(tmp[0],tmp[2]);\n\tres.push_back(tmp);\n\tbreak;\n      case 1:\n\tswap(tmp[1],tmp[2]);\n\tres.push_back(tmp);\n\tswap(tmp[1],tmp[2]);\n\tswap(tmp[1],tmp[5]);\n\tres.push_back(tmp);\n\tbreak;\n      case 2:\n\tswap(tmp[2],tmp[0]);\n\tres.push_back(tmp);\n\tswap(tmp[2],tmp[0]);\n\n\tswap(tmp[2],tmp[1]);\n\tres.push_back(tmp);\n\tswap(tmp[2],tmp[1]);\n\n\tswap(tmp[2],tmp[3]);\n\tres.push_back(tmp);\n\tswap(tmp[2],tmp[3]);\n\n\tswap(tmp[2],tmp[6]);\n\tres.push_back(tmp);\n\tbreak;\n      case 3:\n\tswap(tmp[3],tmp[2]);\n\tres.push_back(tmp);\n\tswap(tmp[3],tmp[2]);\n\n\tswap(tmp[3],tmp[7]);\n\tres.push_back(tmp);\n\tbreak;\n      case 4:\n\tswap(tmp[4],tmp[5]);\n\tres.push_back(tmp);\n\tbreak;\n      case 5:\n\tswap(tmp[5],tmp[1]);\n\tres.push_back(tmp);\n\tswap(tmp[5],tmp[1]);\n\n\tswap(tmp[5],tmp[4]);\n\tres.push_back(tmp);\n\tswap(tmp[5],tmp[4]);\n\n\tswap(tmp[5],tmp[6]);\n\tres.push_back(tmp);\n\tswap(tmp[5],tmp[6]);\n\n\tswap(tmp[5],tmp[9]);\n\tres.push_back(tmp);\n\tbreak;\n      case 6:\n\tswap(tmp[6],tmp[2]);\n\tres.push_back(tmp);\n\tswap(tmp[6],tmp[2]);\n\n\tswap(tmp[6],tmp[5]);\n\tres.push_back(tmp);\n\tswap(tmp[6],tmp[5]);\n\n\tswap(tmp[6],tmp[7]);\n\tres.push_back(tmp);\n\tswap(tmp[6],tmp[7]);\n\n\tswap(tmp[6],tmp[10]);\n\tres.push_back(tmp);\n\tbreak;\n      case 7:\n\tswap(tmp[7],tmp[3]);\n\tres.push_back(tmp);\n\tswap(tmp[7],tmp[3]);\n\n\tswap(tmp[7],tmp[6]);\n\tres.push_back(tmp);\n\tswap(tmp[7],tmp[6]);\n\n\tswap(tmp[7],tmp[8]);\n\tres.push_back(tmp);\n\tswap(tmp[7],tmp[8]);\n\n\tswap(tmp[7],tmp[11]);\n\tres.push_back(tmp);\n\tbreak;\n      case 8:\n\tswap(tmp[8],tmp[7]);\n\tres.push_back(tmp);\n\tbreak;\n      case 9: \n\tswap(tmp[9],tmp[5]);\n\tres.push_back(tmp);\n\tswap(tmp[9],tmp[5]);\n\n\tswap(tmp[9],tmp[10]);\n\tres.push_back(tmp);\n\tbreak;\n      case 10:\n\tswap(tmp[10],tmp[6]);\n\tres.push_back(tmp);\n\tswap(tmp[10],tmp[6]);\n\n\tswap(tmp[10],tmp[9]);\n\tres.push_back(tmp);\n\tswap(tmp[10],tmp[9]);\n\n\tswap(tmp[10],tmp[11]);\n\tres.push_back(tmp);\n\tswap(tmp[10],tmp[11]);\n\n\tswap(tmp[10],tmp[12]);\n\tres.push_back(tmp);\n\tbreak;\n      case 11:\n\tswap(tmp[11],tmp[7]);\n\tres.push_back(tmp);\n\tswap(tmp[11],tmp[7]);\n\n\tswap(tmp[11],tmp[10]);\n\tres.push_back(tmp);\n\tbreak;\n      case 12:\n\tswap(tmp[12],tmp[10]);\n\tres.push_back(tmp);\n\tbreak;\n      }\n    }\n  }\n  return res;\n}\n\nvoid bfs(void){\n\n  queue<State>que;\n  vector<int>s;\n  for(int i=0;i<12;i++)s.push_back(i);\n  s.push_back(0);\n  que.push(State(s,0));\n\n  while(!que.empty()){\n    State now=que.front();\n    que.pop();\n    \n    if(mp.count(now.v) && now.t>=mp[now.v])continue;\n    if(now.t>=12)continue;\n\n    mp[now.v]=now.t;\n\n    vector<vector<int> >res=generate(now.v);\n    for(int i=0;i<res.size();i++){\n      que.push(State(res[i],now.t+1));\n    }\n  }\n}\n\nint bfs(vector<int> s){\n  \n  used.clear();\n  \n  queue<State>que;\n  que.push(State(s,0));\n  \n  while(!que.empty()){\n    State now=que.front();\n    que.pop();\n    \n    if(now.t>=11)continue;\n    if(used.count(now.v))continue;\n    if(mp.count(now.v))return now.t+mp[now.v];\n    used[now.v]=1;\n    \n    vector<vector<int> >res=generate(now.v);\n    for(int i=0;i<res.size();i++){\n      que.push(State(res[i],now.t+1));\n    }\n  }\n  return -1;\n}\n\nint main(void){\n\n  bfs();\n\n  while(true){\n    vector<int>s(13);\n    for(int i=0;i<13;i++){\n      cin >> s[i];\n      if(s[i]<0)return 0;\n    }\n    int res=bfs(s);\n    if(res<0 || res>20)cout << \"NA\" << endl;\n    else cout << res << endl;\n  }\n\n  return 0;\n}"
  },
  {
    "language": "C++",
    "code": "#import<iostream>\n#import<map>\n#import<queue>\n#import<cstdlib>\n#import<cstring>\nusing namespace std;struct B{int z[2];char s[14];bool operator<(const B&r)const{return strcmp(s,r.s)<0;}};main(){int a[13][5]={{2,-1},{2,5,-1},{0,1,3,6,-1},{2,7,-1},{5,-1},{1,4,6,9,-1},{2,5,7,10,-1},{3,6,8,11,-1},{7,-1},{5,10,-1},{6,9,11,12,-1},{7,10,-1},{10,-1},},gx[]={2,1,2,3,0,1,2,3,4,1,2,3,2},gy[]={0,1,1,1,2,2,2,2,2,3,3,3,4},v,d,s,i,j,t,u;B g={0,0,\"0123456789:;0\"};for(;;){map<B,int>m;queue<B>q;B b={-1,-1};for(i=0;i<13;i++){cin>>v;if(v<0)return 0;b.s[i]=48+v;if(!v)b.z[b.z[0]!=-1]=i;}b.s[13]=0;m[b]=1;for(q.push(b);!q.empty();q.pop()){B&b=q.front();if(!strcmp(b.s,g.s))break;d=0;for(i=13;i--;){v=b.s[i]-48;if(v)d+=abs(gx[v]-gx[i])+abs(gy[v]-gy[i]);}s=m[b];if(s+d<22)for(j=2;j--;)for(i=0;~a[u=b.z[j]][i];i++){B n=b;t=n.z[j]=a[u][i];if(t-n.z[1-j]){swap(n.s[u],n.s[t]);int&r=m[n];if(!r)r=s+1,q.push(n);}}}printf(m[g]?\"%d\\n\":\"NA\\n\",m[g]-1);}}"
  },
  {
    "language": "C++",
    "code": "#include<iostream>\n#include<cmath>\n#include<stdio.h>\nusing namespace std;\n\n#define LIMIT 20\n\nstruct Puzzle {\n  int cont[25];\n  int space[2];\n};\n\nint limit;\n\nPuzzle puzzle;\n\nint tx[12]={0,1,2,3,0,1,2,3,4,1,2,3};\nint ty[12]={0,1,1,1,2,2,2,2,2,3,3,3};\nint dx[4]={0,1,0,-1};\nint dy[4]={-1,0,1,0};\n\nint heuris[12][25];\n\nint getHeuristic(){\n  int res=0;\n  for(int i=0;i<25;i++){\n    if(puzzle.cont[i]==-1||puzzle.cont[i]==0)continue;\n    res+=heuris[puzzle.cont[i]][i];\n  }\n  return res;\n}\n\nbool dfs(int depth,int prev0,int prev1){\n  \n  int heuri;\n  heuri=getHeuristic();\n  /*\n  cout<<depth<<' '<<heuri<<endl;\n  for(int i=0;i<5;i++){\n    for(int j=0;j<5;j++){\n      if(puzzle.cont[i*5+j]!=-1)printf(\"%3d\",puzzle.cont[i*5+j]);\n      else cout<<\"???\";\n    }\n    cout<<endl;\n  }\n  */\n  if(heuri==0){\n    cout<<depth<<endl;\n    return true;\n  }\n  if(depth + heuri>limit)return false;\n\n  int px,py,nx,ny;\n  Puzzle tmp=puzzle;\n\n  py=puzzle.space[0]/5;\n  px=puzzle.space[0]%5;\n  for(int i=0;i<4;i++){\n    if(max(prev0,i)-min(prev0,i)==2)continue;\n    ny=py+dy[i];nx=px+dx[i];\n    if(ny<0||ny>=5||nx<0||nx>=5)continue;\n    if(puzzle.cont[ny*5+nx]==-1)continue;\n    if(puzzle.cont[ny*5+nx]==0)continue;\n    puzzle.cont[py*5+px]=puzzle.cont[ny*5+nx];\n    puzzle.cont[ny*5+nx]=0;\n    puzzle.space[0]=ny*5+nx;\n    if(dfs(depth+1,i,-100))return true;\n    puzzle=tmp;\n  }\n\n  py=puzzle.space[1]/5;\n  px=puzzle.space[1]%5;\n  for(int i=0;i<4;i++){\n    if(max(prev1,i)-min(prev1,i)==2)continue;\n    ny=py+dy[i];nx=px+dx[i];\n    if(ny<0||ny>=5||nx<0||nx>=5)continue;\n    if(puzzle.cont[ny*5+nx]==-1)continue;\n    if(puzzle.cont[ny*5+nx]==0)continue;\n    puzzle.cont[py*5+px]=puzzle.cont[ny*5+nx];\n    puzzle.cont[ny*5+nx]=0;\n    puzzle.space[1]=ny*5+nx;\n    if(dfs(depth+1,-100,i))return true;\n    puzzle=tmp;\n  }\n  return false;\n}\n\nvoid solve(){\n  Puzzle tmp=puzzle;\n  for(limit=getHeuristic();limit<=LIMIT;limit++){\n    puzzle=tmp;\n    if(dfs(0,-100,-100))return;\n  }\n  cout<<\"NA\"<<endl;\n}\n\nint main(){\n  int x,y,c=0;\n\n  for(int i=1;i<=11;i++){\n    for(int j=0;j<25;j++){\n      y=j/5;\n      x=j%5;\n      heuris[i][j]=abs(tx[i]-x)+abs(ty[i]-y);\n    }\n  }\n  /*\n  for(int i=1;i<=11;i++){\n    for(int j=0;j<5;j++){\n      for(int k=0;k<5;k++){\n\tcout<<heuris[i][j*5+k]<<' ';\n      }\n      cout<<endl;\n    }\n    cout<<endl;\n  }\n  */\n\n\n  while(1){\n    c=0;\n    for(int i=0;i<25;i++)puzzle.cont[i]=-1;\n\n    cin>>puzzle.cont[2];\n    if(puzzle.cont[2]==-1)break;\n    if(puzzle.cont[2]==0)puzzle.space[c++]=2;\n    \n    \n    for(int i=6;i<=8;i++){\n      cin>>puzzle.cont[i];\n      if(puzzle.cont[i]==0)puzzle.space[c++]=i;\n    }\n    for(int i=10;i<=14;i++){\n      cin>>puzzle.cont[i];\n      if(puzzle.cont[i]==0)puzzle.space[c++]=i;\n    }\n    \n    for(int i=16;i<=18;i++){\n      cin>>puzzle.cont[i];\n      if(puzzle.cont[i]==0)puzzle.space[c++]=i;\n    }\n    \n    cin>>puzzle.cont[22];\n    if(puzzle.cont[22]==0)puzzle.space[c++]=22;\n    solve();\n  }\n\n  return 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include <iostream>\n#include <string>\n#include <vector>\n#include <queue>\n#include <map>\nusing namespace std;\n\nstring s = \"0123456789AB\";\nvector<vector<int>> adj = {\n    {2},\n    {2,5},\n    {0,1,3,6},\n    {2,7},\n    {5},\n    {1,4,6,9},\n    {2,5,7,10},\n    {3,6,8,11},\n    {7},\n    {5,10},\n    {6,9,11,12},\n    {7,10},\n    {10}\n};\n\nint solve(string stat, string goal, map<string,int> &dist, bool useterm, map<string,int> &term) {\n    dist[stat] = 0;\n    queue<string> q;\n    q.push(stat);\n    while ( ! q.empty()) {\n        string s = q.front();\n        q.pop();\n        if (useterm && term.find(s) != term.end()) {\n            return dist[s] + term[s];\n        }\n        int diff = 0;\n        for (int k=0; k<13; ++k) {\n            if (s[k] != '0') {\n                diff += s[k] != goal[k];\n            }\n        }\n        if ( ! diff) {\n            return dist[s];\n        }\n        if (10 <= dist[s] || 20 < dist[s] + diff) {\n            continue;\n        }\n        for (int i=0; i<13; ++i) {\n            if (s[i] != '0') continue;\n            for (int j : adj[i]) {\n                string next = s;\n                next[i] = s[j];\n                next[j] = s[i];\n                if (dist.find(next) == dist.end()) {\n                    dist[next] = dist[s] + 1;\n                    q.push(next);\n                }\n            }\n        }\n    }\n    return 21;\n}\n\nint main() {\n    map<string, int> term;\n    int dummy = solve(\"0123456789AB0\", \"0BA9876543210\", term, false, term);\n    while (1) {\n        map<string, int> dist;\n        string stat = \"\";\n        int k;\n        for (int i=0; i<13; ++i) {\n            if (cin >> k && !~k) return 0;\n            stat += s[k];\n        }\n        int ans = solve(stat, \"0123456789AB0\", dist, true, term);\n        if (ans <= 20) {\n            cout << ans << endl;\n            continue;\n        }\n        cout << \"NA\" << endl;\n    }\n    return 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include<iostream>\n#include<map>\n#include<deque>\n#include<cstring>\n#include<cstdlib>\nusing namespace std;\nstruct board{\n\tchar s[14];\n\tint z1,z2;\n\tbool operator<(const board& rhs)const{return strcmp(s,rhs.s)<0;}\n};\nint main(){\n\tint d[13][5]={\n\t\t{2,-1},\t\t\t//0\n\t\t{2,5,-1},\t\t//1\n\t\t{0,1,3,6,-1},\t//2\n\t\t{2,7,-1},\t\t//3\n\t\t{5,-1},\t\t\t//4\n\t\t{1,4,6,9,-1},\t//5\n\t\t{2,5,7,10,-1},\t//6\n\t\t{3,6,8,11,-1},\t//7\n\t\t{7,-1},\t\t\t//8\n\t\t{5,10,-1},\t\t//9\n\t\t{6,9,11,12,-1},\t//10\n\t\t{7,10,-1},\t\t//11\n\t\t{10,-1},\t\t//12\n\t};\n\tboard goal;\n\tstrcpy(goal.s,\"0123456789AB0\");\n\tfor(;;){\n\t\ttypedef map<board,int>SM;\n\t\tSM stepmap;\n\t\tdeque<board> que;\n\t\tboard b0;\n\t\tb0.z1=b0.z2=-1;\n\t\tint dist=0;\n\t\tfor(int i=0;i<13;i++){\n\t\t\tint v;\n\t\t\tcin>>v;\n\t\t\tif(v==-1)\n\t\t\t\treturn 0;\n\t\t\tb0.s[i]=\"0123456789AB\"[v];\n\t\t\tif(v==0){\n\t\t\t\tif(b0.z1==-1)\n\t\t\t\t\tb0.z1=i;\n\t\t\t\telse\n\t\t\t\t\tb0.z2=i;\n\t\t\t}else{\n\t\t\t\tstatic int x[]={2,1,2,3,0,1,2,3,4,1,2,3,2};\n\t\t\t\tstatic int y[]={0,1,1,1,2,2,2,2,2,3,3,3,4};\n\t\t\t\tdist+=abs(x[v]-x[i])+abs(y[v]-y[i]);\n\t\t\t}\n\t\t}\n\t\tb0.s[13]=0;\n\t\tque.push_back(b0);\n\t\tstepmap[b0]=1;\n\t\tif(dist<=20){\n\t\t\twhile(!que.empty()){\n\t\t\t\tboard b=que.front();\n\t\t\t\tif(strcmp(b.s,goal.s)==0){\n\t\t\t\t\tbreak;\n\t\t\t\t}\n\t\t\t\tque.pop_front();\n\t\t\t\tint step=stepmap[b];\n\t\t\t\tif(step<=20){\n\t\t\t\t\tfor(int i=0;d[b.z1][i]!=-1;i++){\n\t\t\t\t\t\tboard bn=b;\n\t\t\t\t\t\tbn.z1=d[b.z1][i];\n\t\t\t\t\t\tif(bn.z1!=bn.z2){\n\t\t\t\t\t\t\tswap(bn.s[b.z1],bn.s[bn.z1]);\n\t\t\t\t\t\t\tint&ns=stepmap[bn];\n\t\t\t\t\t\t\tif(!ns){\n\t\t\t\t\t\t\t\tns=step+1;\n\t\t\t\t\t\t\t\tque.push_back(bn);\n\t\t\t\t\t\t\t}\n\t\t\t\t\t\t}\n\t\t\t\t\t}\n\t\t\t\t\tfor(int i=0;d[b.z2][i]!=-1;i++){\n\t\t\t\t\t\tboard bn=b;\n\t\t\t\t\t\tbn.z2=d[b.z2][i];\n\t\t\t\t\t\tif(bn.z2!=bn.z1){\n\t\t\t\t\t\t\tswap(bn.s[b.z2],bn.s[bn.z2]);\n\t\t\t\t\t\t\tint&ns=stepmap[bn];\n\t\t\t\t\t\t\tif(!ns){\n\t\t\t\t\t\t\t\tns=step+1;\n\t\t\t\t\t\t\t\tque.push_back(bn);\n\t\t\t\t\t\t\t}\n\t\t\t\t\t\t}\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t\tif(stepmap[goal]==0)\n\t\t\tcout<<\"NA \"<<endl;\n\t\telse\n\t\t\tcout<<stepmap[goal]-1<<endl;\n\t}\n}"
  },
  {
    "language": "C++",
    "code": "#include <iostream>\n#include <algorithm>\n#include <vector>\n#include <queue>\n#include <map>\nusing namespace std;\n#define rep(i,n) for(int i=0;i<n;i++)\nclass NODE{\npublic:\n\tvector<int> data;\n\tint depth;\n\tint e[2];\n\tNODE(int a[13],int d,int E[2]){\n\t\tdata.resize(13);\n\t\trep(i,13)data[i] = a[i];\n\t\tdepth = d;\n\t\trep(i,2)e[i] = E[i];\n\t}\n\tNODE(){\n\t\tdepth = 0;\n\t\tdata.resize(13);\n\t}\n};\n\nint di[13][10] = {\n\t{2,-1},\n\t{2,5,-1},\n\t{0,1,3,6,-1},\n\t{2,7,-1},\n\t{5,-1},\n\t{1,4,6,9,-1},\n\t{2,5,7,10,-1},\n\t{3,6,7,11,-1},\n\t{7},\n\t{5,10,-1},\n\t{6,9,11,12,-1},\n\t{7,10,-1},\n\t{10,-1}\n};\nint rx[] = {3,2,3,4,1,2,3,4,5,2,3,4,3};\nint ry[] = {1,2,2,2,3,3,3,3,3,4,4,4,5};\n\nint main(){\n\twhile(1){\n\t\tint ret = 21;\n\t\tNODE fst; int cnt = 0;\n\t\trep(i,13){\n\t\t\tif(cin >>fst.data[i] , fst.data[i] != -1){\n\t\t\t\tif(fst.data[i] == 0){\n\t\t\t\t\tfst.e[cnt] = i;\n\t\t\t\t\tcnt++;\n\t\t\t\t}\n\t\t\t}else{\n\t\t\t\treturn 0;\n\t\t\t}\n\t\t}\n\t\tmap< vector<int> , int > done[2];\n\t\t\n\t\trep(x,2){\n\t\t\tqueue<NODE> Q;\n\t\t\tif(x==0){\n\t\t\t\tQ.push(fst);\n\t\t\t}else{\n\t\t\t\tNODE a;\n\t\t\t\trep(i,11)a.data[i+1] = i+1;\n\t\t\t\ta.e[0] = 0;\n\t\t\t\ta.e[1] = 12;\n\t\t\t\tQ.push(a);\n\t\t\t}\t\n\t\t\tdone[x][Q.front().data] = 0;\n\t\t\twhile(Q.size()){\n\t\t\t\tNODE q = Q.front(); Q.pop();\n\t\t\t\tint mndist = 0;\n\t\t\t\trep(i,13)mndist += abs(rx[q.data[i]]-rx[i]) + abs(ry[q.data[i]]-ry[i]);\n\t\t\t\t\n\t\t\t\tif(mndist > 20)continue;\n\t\t\t\t\n\t\t\t\tif(x == 1){\n\t\t\t\t\tif( done[0].find(q.data) != done[0].end() ){\n\t\t\t\t\t\tret = q.depth + done[0][q.data] ;\n\t\t\t\t\t\tbreak;\n\t\t\t\t\t}\n\t\t\t\t}else{\n\t\t\t\t\tif( q.data[0] == 0 && q.data[1] == 1 && q.data[2] == 2 && q.data[3] == 3 && q.data[4] == 4 && q.data[5] == 5 && q.data[6] == 6 && q.data[7] == 7 &&\n\t\t\t\t\t\t\tq.data[8] == 8 && q.data[9] == 9 && q.data[10]==10 && q.data[11]==11 && q.data[12]==0\n\t\t\t\t\t){\n\t\t\t\t\t\tret = q.depth;\n\t\t\t\t\t\tbreak;\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t\tif(q.depth >= 10)continue;\n\n\t\t\t\trep(o,2){\n\t\t\t\t\tfor(int i=0;di[q.e[o]][i] != -1;i++){\n\t\t\t\t\t\tNODE next = q;\n\t\t\t\t\t\tnext.e[o] = next.data[di[q.e[o]][i]];\n\t\t\t\t\t\tswap(next.data[q.e[o]] , next.data[di[q.e[o]][i]]);\n\t\t\t\t\t\tnext.depth = q.depth + 1;\n\t\t\t\t\t\t\n\t\t\t\t\t\tif( done[x].find(next.data) == done[x].end() ){\n\t\t\t\t\t\t\tdone[x][next.data] = next.depth;\n\t\t\t\t\t\t\tQ.push(next);\n\t\t\t\t\t\t}\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t\tif(ret > 20){\n\t\t\tcout << \"NA\" << endl;\n\t\t}else{\n\t\t\tcout << ret << endl;\n\t\t}\n\t}\n}"
  },
  {
    "language": "C++",
    "code": "#include <iostream>\n#include <stdlib.h>\nusing namespace std;\n\nint p[5][5],x[11]={1,2,3,0,1,2,3,4,1,2,3},y[11]={1,1,1,2,2,2,2,2,3,3,3},s,sx[2],sy[2]\n    ,mx[4]={1,0,-1,0},my[4]={0,-1,0,1},lt;\nint search(int t,int mx2,int my2,int mc) {\n\tint a,i,j,x2,y2,s2;\n\tif (s==0) { lt=t-1; return 1;}\n\t  for (i=0;i<2;i++) for (j=0;j<4;j++) {\n\t  x2=sx[i]+mx[j]; y2=sy[i]+my[j];\n\t  if (x2<0 || x2>4 || y2<0 || y2>4) continue;\n\t  if (p[y2][x2]<1 || ( mc==i  && mx2==-mx[j] && my2==-my[j])) continue;\n\t  s2=abs(x2-x[p[y2][x2]-1])+abs(y2-y[p[y2][x2]-1])-abs(sx[i]-x[p[y2][x2]-1])-abs(sy[i]-y[p[y2][x2]-1]);\n\t  if (s+s2>lt-t) continue;\n\t  p[sy[i]][sx[i]]=p[y2][x2]; p[y2][x2]=0;  s+=s2; \n\t  sx[i]=x2; sy[i]=y2;\n\t  a=search(t+1,mx[j],my[j],i);\n\t  sx[i]=x2-mx[j]; sy[i]=y2-my[j];\n\t  p[y2][x2]=p[sy[i]][sx[i]]; p[sy[i]][sx[i]]=0; s-=s2;\n\t  if (a==1) return 0;\n  }\n  return 0;\n}\n\nint main() {\n  int i,j,k;\n  for (i=0;i<5;i++) for (j=0;j<5;j++) p[i][j]=-1;\n  while (cin >> p[0][2] && p[0][2]!=-1) {\n\t  cin >> p[1][1] >> p[1][2] >> p[1][3];\n\t  cin >> p[2][0] >> p[2][1] >> p[2][2] >> p[2][3] >> p[2][4];\n\t  cin >> p[3][1] >> p[3][2] >> p[3][3];\n\t  cin >> p[4][2]; k=0; s=0;\n\t  for (i=0;i<5;i++) for (j=0;j<5;j++) {\n\t\t  if (p[i][j]==0) { sx[k++]=j; sy[k++]=i;}\n\t\t  if (p[i][j]>0) s+=abs(j-x[p[i][j]-1])+abs(i-y[p[i][j]-1]);\n\t\t   }\n\t  lt=21;\t   \n\t  search(1,0,0,0);\n\t  if (lt==21) cout << \"NA\" << endl; else cout << lt << endl;\n  } \n return 0;\n}\t\t"
  },
  {
    "language": "C++",
    "code": "#include <cstdio>\n#include <cstdlib>\n#include <cmath>\n#include <climits>\n#include <cfloat>\n#include <map>\n#include <utility>\n#include <set>\n#include <iostream>\n#include <memory>\n#include <string>\n#include <vector>\n#include <algorithm>\n#include <functional>\n#include <sstream>\n#include <complex>\n#include <stack>\n#include <queue>\n#include <cstring>\n#include <sstream>\n#include <cassert>\n#include <list>\nusing namespace std;\nstatic const double EPS = 1e-10;\ntypedef long long ll;\ntypedef pair<int,int> PI;\ntypedef vector<int> vi;\n#ifndef M_PI\n#define M_PI 3.14159265358979323846\n#endif\n#define rep(i,n) for(int i=0;i<(int)n;++i)\n#define FOR(i,c) for(__typeof((c).begin())i=(c).begin();i!=(c).end();++i)\n#define ALL(c) (c).begin(), (c).end()\n#define mp(a,b) make_pair(a,b)\n#define pb(a) push_back(a)\n#define F first\n#define S second\ntemplate <typename T> string print_array(const vector<T> &V) { ostringstream os; os << \"{ \"; for (typename vector<T>::const_iterator iter = V.begin(); iter != V.end(); ++iter) os << '\\\"' << *iter << \"\\\",\"; os << \" }\"; return os.str(); }\n\nint dx[]={0,1,0,-1},dy[]={1,0,-1,0};\n\nvector<int> se[13];\nint x[]={0,-1,0,1,-2,-1,0,1,2,-1,0,1,0};\nint y[]={2,1,1,1,0,0,0,0,0,-1,-1,-1,-2};\n\nvoid pr(ll in){\n\n  printf(\"      %3lld\\n\",in&15);\n  printf(\"   %3lld%3lld%3lld\\n\",(in>>4)&15,(in>>8)&15,(in>>12)&15);\n  printf(\"%3lld%3lld%3lld%3lld%3lld\\n\",(in>>16)&15,(in>>20)&15,(in>>24)&15,(in>>28)&15,(in>>32)&15);\n  printf(\"   %3lld%3lld%3lld\\n\",(in>>36)&15,(in>>40)&15,(in>>44)&15);\n  printf(\"      %3lld\\n\",(in>>48)&15);\n  puts(\"\");\n}\n\nint manh(ll in){\n  int ret=0;\n  rep(i,13){\n    int t=(in>>(i*4))&15;\n\n    if(!t){\n      int nx=x[t]-x[i],ny=y[t]-y[i];\n      int co=abs(nx)+abs(ny);\n      nx=x[12]-x[i],ny=y[12]-y[i];\n      int k=abs(nx)+abs(ny);\n      ret+=min(co,k);\n      continue;\n    }\n    int nx=(x[t]-x[i]),ny=y[t]-y[i];\n    ret+=abs(nx)+abs(ny);\n  }\n  return ret;\n}\n\nmain(){\n  ll p;\n\n  ll goal=0;\n  rep(i,11){\n    goal|=(i+1LL)<<(4*(i+1));\n    //cout<<goal<<endl;\n    //pr(goal);\n  }\n  //pr(goal);\n\n  se[0].pb(2);\n  se[1].pb(2);\n  se[1].pb(5);\n  se[2].pb(0);\n  se[2].pb(1);\n  se[2].pb(3);\n  se[2].pb(6);\n  se[3].pb(2);\n  se[3].pb(7);\n  se[4].pb(5);\n  se[5].pb(1);\n  se[5].pb(4);\n  se[5].pb(6);\n  se[5].pb(9);\n  se[6].pb(2);\n  se[6].pb(5);\n  se[6].pb(7);\n  se[6].pb(10);\n  se[7].pb(3);\n  se[7].pb(6);\n  se[7].pb(8);\n  se[7].pb(11);\n  se[8].pb(7);\n  se[9].pb(5);\n  se[9].pb(10);\n  se[10].pb(6);\n  se[10].pb(9);\n  se[10].pb(11);\n  se[10].pb(12);\n  se[11].pb(7);\n  se[11].pb(10);\n  se[12].pb(10);\n  \n  while(cin>>p){\n    if(p==-1)break;\n    ll in=p;\n\n    rep(i,12){\n      cin>>p;\n      in|=p<<(4*(i+1));\n    }\n\n    set<ll> app;\n\n    queue<pair<int,ll> > Q;\n    app.insert(in);\n    Q.push(mp(0,in));\n    int ans=21;\n    int mans=0;\n\n    while(!Q.empty()){\n      ll cvec=Q.front().S;\n      int ccost=Q.front().F;\n      Q.pop();\n    \n      //pr(cvec);\n\n      //if(ccost>3)break;\n     if(ccost>20)break;\n     \n      if(cvec==goal){\n\tans=ccost;\n\tbreak;\n      }\n      if(ccost+manh(cvec)>27)continue;\n      rep(i,13){\n\tll t=cvec>>(i<<2);\n\tt=t&15;\n\tif(!t){\n\t  rep(j,se[i].size()){\n\t    t=cvec>>(se[i][j]<<2);\n\t    t=t&15;\n\t    if(t){\n\t      ll nvec=cvec;\n\t      t=t<<(i<<2);\n\t      nvec|=t;\n\t      nvec&=~(15LL<<se[i][j]*4);\n\t      \n\t      if(!app.count(nvec)){\n\t\tapp.insert(nvec);\n\t\tQ.push(mp(ccost+1,nvec));\n\t      }\n\t    }\n\t  }\n\t}\n      }\n    }\n    if(ans==21)cout<<\"NA\"<<endl;\n    else cout<<ans<<endl;\n  }\n}"
  },
  {
    "language": "C++",
    "code": "#include<iostream>\n#include<vector>\n#include<map>\n#include<cstdio>\n#include<deque>\n#include<cmath>\n#include<algorithm>\n#define F first\n#define S second\n#define pb push_back\nusing namespace std;\ntypedef pair<int,int> P;\ntypedef pair<P,P> PP;\ntypedef vector<int> VI;\ntypedef vector<VI> VVI;\ntypedef vector<P> VP;\ntypedef pair<VVI,VP> VVIVP;\n  \n  \nmap<VVI,int> memo,bidirectional;\nVVI final;\nVP ini;\nint dx[4] = {0,1,0,-1};\nint dy[4] = {1,0,-1,0};\n  \nP Fpos[] = {P(0,0),P(1,1),P(2,1),P(3,1),P(0,2),P(1,2),P(2,2),P(3,2),P(4,2),P(1,3),P(2,3),P(3,3)};\n  \n  \nclass Puzzle\n{\npublic:\n  VVI state;\n  int Manhattan;\n  VP vp;\n  \n  Puzzle():Manhattan(0){}\n  Puzzle(VVI s)\n  {\n    vp.clear();\n    state = s;\n    Manhattan_calc(false);\n  }\n  \n  void Manhattan_calc(bool b)\n  {\n    Manhattan = 0; \n    for(int i=0;i<5;i++)\n      for(int j=0;j<state[i].size();j++)\n    if(state[i][j] != 0 && state[i][j] != -1)\n      Manhattan += abs(j-Fpos[state[i][j]].F) + abs(i-Fpos[state[i][j]].S);\n    else if(state[i][j] == 0 && !b)// bがfalseなら初期化\n      vp.push_back(P(j,i)); \n  }  \n  \n};\n  \nbool Input(VVI& puzzle)\n{\n  puzzle.clear();\n  puzzle.resize(5);\n  puzzle[0].resize(3),puzzle[1].resize(4),puzzle[2].resize(5),puzzle[3].resize(4),puzzle[4].resize(3);\n  puzzle[0][0] = puzzle[0][1] = puzzle[1][0] = puzzle[3][0] = puzzle[4][0] = puzzle[4][1] = -1;\n   \n  scanf(\"%d\",&puzzle[0][2]);\n  if(puzzle[0][2] == -1)\n    return false; \n  scanf(\"%d %d %d\",&puzzle[1][1],&puzzle[1][2],&puzzle[1][3]);\n  scanf(\"%d %d %d %d %d\",&puzzle[2][0],&puzzle[2][1],&puzzle[2][2],&puzzle[2][3],&puzzle[2][4]);\n  scanf(\"%d %d %d\",&puzzle[3][1],&puzzle[3][2],&puzzle[3][3]);\n  scanf(\"%d\",&puzzle[4][2]);\n          \n    return true;\n}\n   \nVVI change(VVI vec,P p1,P p11)\n{\n  int tmp = vec[p1.S][p1.F];\n  vec[p1.S][p1.F] = vec[p11.S][p11.F];\n  vec[p11.S][p11.F] = tmp;\n  \n  return vec;\n}\n  \nvoid Init()\n{\n  final.resize(5);\n  final[0].pb(-1),final[0].pb(-1),final[0].pb(0);\n  final[1].pb(-1),final[1].pb(1),final[1].pb(2),final[1].pb(3);\n  final[2].pb(4),final[2].pb(5),final[2].pb(6),final[2].pb(7),final[2].pb(8);\n  final[3].pb(-1),final[3].pb(9),final[3].pb(10),final[3].pb(11);\n  final[4].pb(-1),final[4].pb(-1),final[4].pb(0);\n  \n  Puzzle puz(final); \n  deque<Puzzle> deq;\n  deq.push_back(puz);\n  bidirectional[final] = 0;\n    \n  while(!deq.empty())\n    {\n      Puzzle p = deq.front(); deq.pop_front();\n      int cost = bidirectional[p.state];\n      \n      if(cost >= 8)\n    continue;\n  \n      for(int i=0;i<2;i++)\n    {\n      for(int j=0;j<4;j++)\n        {\n          int nx = p.vp[i].F + dx[j];\n          int ny = p.vp[i].S + dy[j];\n          if(!(0<=ny && ny<p.state.size() && 0<=nx && nx<p.state[ny].size() && p.state[ny][nx] != -1))\n        continue;\n          VVI next = change(p.state,p.vp[i],P(nx,ny));\n          map<VVI,int>::iterator it = bidirectional.find(next);\n          if(it == bidirectional.end() || (it != bidirectional.end() && bidirectional[next] > cost + 1))\n        {\n          bidirectional[next] = cost + 1;\n          deq.push_back(Puzzle(next));\n        }\n  \n        }\n  \n    }      \n  \n    }\n    \n    \n}\n  \n  \nint main()\n{\n  VVI puzzle;\n  Init();\n  \n  while(Input(puzzle))\n    {\n   \n      Puzzle puz(puzzle);\n      int men = (1<<28);\n      deque<Puzzle> deq;\n      deq.push_back(puz);\n      memo.clear();\n      memo[puzzle] = 0;\n  \n      while(!deq.empty())\n    {\n      Puzzle p = deq.front(); deq.pop_front();\n      int cost = memo[p.state];\n    \n      if(cost + p.Manhattan > min(20,men))\n        continue;\n  \n      if(p.state == final)\n        {\n          men = min(men,cost);\n          continue;\n        }\n      else if(bidirectional.find(p.state) != bidirectional.end() && cost + bidirectional[p.state] <= 20)\n        {\n          men = min(men,cost+bidirectional[p.state]);\n          continue;\n        }\n         \n      for(int i=0;i<2;i++)\n        {\n          for(int j=0;j<4;j++)\n        {\n    \n          int nx = p.vp[i].F + dx[j];\n          int ny = p.vp[i].S + dy[j];\n          if(!(0<=ny && ny<p.state.size() && 0<=nx && nx<p.state[ny].size() && p.state[ny][nx] != -1))\n            continue;\n  \n          VVI next = change(p.state,p.vp[i],P(nx,ny));\n          map<VVI,int>::iterator it = memo.find(next);\n          if(it == memo.end() || (it != memo.end() &&  memo[next] > cost + 1) )\n            {\n              memo[next] = cost + 1;\n              deq.push_back(Puzzle(next));\n            }\n  \n        }\n        }\n  \n  \n    }\n      if(men == (1<<28))\n    cout << \"NA\" << endl;\n      else\n    cout << men << endl;\n    }  \n  \n      \n  return 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include<iostream>\n#include<algorithm>\n#include<vector>\n#include<queue>\n#include<unordered_map>\n#include<unordered_set>\n#define lol(i,n) for(int i=0;i<n;i++)\n#define mod 1000000007\ntypedef long long ll;\nusing namespace std;\nint dx[13][4]={\n  {3,0,0,0},\n  {3,6,0,0},\n  {1,2,4,7},\n  {3,8,0,0},\n  {6,0,0,0},\n  {2,5,7,10},\n  {3,6,8,11},\n  {4,7,9,12},\n  {8,0,0,0},\n  {6,11,0,0},\n  {7,10,12,13},\n  {8,11,0,0},\n  {11,0,0,0}\n};\nunordered_map<ll,int> mp;\nll Compress(int p[]){\n  ll ans=0;\n  for(int i=0;i<13;i++){\n    ans*=13;\n    ans+=p[i];\n  }\n  return ans;\n}\n\nint unzip[13];\nvoid Unzip(ll x){\n  for(int i=0;i<13;i++){\n    unzip[12-i]=x%13;\n    x/=13;\n  }\n}\n\nint beflen=0;\nqueue<pair<ll,int> >Q;\nvoid BFS(int p[],int len){\n  //if(len!=beflen){cout<<len<<endl;beflen=len;}\n  ll tmp=Compress(p);\n  mp[tmp]=len;\n  if(len==13)return;\n  lol(i,13){\n    if(p[i]==0){\n      lol(j,4){\n\tint t=dx[i][j];\n\tif(t==0)break;\n\tt--;\n\tif(p[t]!=0){\n\t  swap(p[i],p[t]);\n\t  tmp=Compress(p);\n\t  if(mp[tmp]!=0)continue;\n\t  mp[tmp]=-1;\n\t  Q.push(make_pair(tmp,len+1));\n\t  swap(p[i],p[t]);\n\t}\n      }\n    }\n  }\n}\n\nunordered_set<ll> st;\nint ans;\nvoid EFS(int p[],int len){\n  //if(len!=beflen){cout<<len<<endl;beflen=len;}\n  ll tmp=Compress(p);\n  if(mp[tmp]>0){\n    ans=min(ans,len+mp[tmp]-1);\n    return;\n  }\n  if(len==9)return;\n  lol(i,13){\n    if(p[i]==0){\n      lol(j,4){\n\tint t=dx[i][j];\n\tif(t==0)break;\n\tt--;\n\tif(p[t]!=0){\n\t  swap(p[i],p[t]);\n\t  tmp=Compress(p);\n\t  Q.push(make_pair(tmp,len+1));\n\t  swap(p[i],p[t]);\n\t}\n      }\n    }\n  }\n}\nint main(){\n  int p[13];\n  lol(i,13)p[i]=i;p[12]=0;\n  Q.push(make_pair(Compress(p),1));\n  while(!Q.empty()){\n    ll data=Q.front().first;\n    int len=Q.front().second;\n    Q.pop();\n    if(mp[data]>0)continue;\n    Unzip(data);\n    BFS(unzip,len);\n  }\n  //cout<<\"#\"<<mp.size()<<endl;\n  while(cin>>p[0]&&p[0]!=-1){\n    for(int i=1;i<13;i++)cin>>p[i];\n    ans=mod;\n    Q.push(make_pair(Compress(p),0));\n    while(!Q.empty()){\n      ll data=Q.front().first;\n      int len=Q.front().second;\n      Q.pop();\n      if(st.find(data)!=st.end())continue;\n      st.insert(data);\n      Unzip(data);\n      EFS(unzip,len);\n    }\n    st.clear();\n    if(ans>20)cout<<\"NA\"<<endl;\n    else cout<<ans<<endl;\n  }\n  return 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include<iostream>\n#include<algorithm>\n\nusing namespace std;\n\n#define N 5\n#define REP(i, n) for ( int i = 0; i < (int)n; i++ )\n#define LIMIT 20\n\nstatic const int T[12][2] = {{-1, -1}, {1, 1}, {1, 2}, {1, 3}, {2, 0}, {2, 1},\n\t\t\t     {2, 2}, {2, 3}, {2, 4}, {3, 1}, {3, 2}, {3, 3}};\nstatic const int g[N][N] = {{-1, -1, 0, -1, -1}, {-1, 1, 2, 3, -1},\n\t\t\t    {4, 5, 6, 7, 8}, {-1, 9, 10, 11, -1}, {-1, -1, 0, -1, -1}};\n\nclass Puzzle{\n    public:\n    int C[N][N], mdist; //manhatta distance\n    Puzzle(){}\n\n    bool swapAdj( int si, int sj, int ti, int tj ){\n\tif ( ti < 0 || tj < 0 || ti >= N || tj >= N ) return false;\n\tif ( C[ti][tj] <= 0 ) return false;\n\tswap(C[ti][tj], C[si][sj]);\n\tint tti = T[C[si][sj]][0];\n\tint ttj = T[C[si][sj]][1];\n\tmdist -= max(tti, ti)-min(tti, ti) + max(ttj, tj)-min(ttj, tj);\n\tmdist += max(tti, si)-min(tti, si) + max(ttj, sj)-min(ttj, sj);\n\treturn true;\n    }\n\n    bool isGoal(){\n\tREP(i, N) REP(j, N) if ( g[i][j] != C[i][j] ) return false;\n\treturn true;\n    }\n\n    int getMD(){ // get initial manhattan distance\n\tint sum = 0;\n\tint ti, tj;\n\tREP(i, 5) REP(j, 5){\n\t    if ( C[i][j] <= 0 ) continue;\n\t    ti = T[C[i][j]][0];\n\t    tj = T[C[i][j]][1];\n\t    sum += (max(ti, i)-min(ti, i) + max(tj, j) - min(tj, j));\n\t}\n\treturn sum;\n    }\n};\n\nint limit;\n\nbool dfs( int depth, Puzzle P ){\n    if ( P.isGoal() ) return true;\n    if ( depth + P.getMD() > limit ) return false;\n\n    static const int di[4] = {0, -1, 0, 1};\n    static const int dj[4] = {1, 0, -1, 0};\n\n    REP(i, N) REP(j, N){\n\tif ( P.C[i][j] != 0 ) continue;\n\tREP(r, 4){\n\t    Puzzle v = P;\n\t    if ( !v.swapAdj(i, j, i+di[r], j+dj[r]) ) continue;\n\t    if ( dfs( depth + 1, v ) ) return true;\n\t}\n    }\n\n    return false;\n}\n\nint idp(Puzzle source){\n    for ( limit = 0; limit <= LIMIT; limit++ ){\n\tsource.mdist = source.getMD();\n\tif ( dfs(0, source) ) return limit;\n    }\n    return INT_MAX;\n}\n\nint main(){\n    Puzzle P;\n    int top;\n\n    while(1){\n\tcin >> top;\n\tif ( top == -1 ) break;\n\tREP(j, N) P.C[0][j] = -1;\n\tP.C[0][2] = top;\n\tfor(int i = 1; i < N; i++) REP(j, N){\n\t    if ( (i == 1 || i == 3) && (j == 0 || j == 4 ) ) P.C[i][j] = -1;\n\t    else if ( i == 4 && j != 2 ) P.C[i][j] = -1;\n\t    else cin >> P.C[i][j];\n\t}\n\n\tint cost = idp(P);\n\tif ( cost == INT_MAX ) cout << \"NA\" << endl;\n\telse cout << cost << endl;\t\n    }\n\n    return 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include <iostream>\n#include <string>\n#include <vector>\n#include <queue>\n#include <map>\nusing namespace std;\n\nstring s = \"0123456789AB\";\nstring goal = \"0123456789AB0\";\n\nvector<vector<int>> adj = {\n    {2},\n    {2,5},\n    {0,1,3,6},\n    {2,7},\n    {5},\n    {1,4,6,9},\n    {2,5,7,10},\n    {3,6,8,11},\n    {7},\n    {5,10},\n    {6,9,11,12},\n    {7,10},\n    {10}\n};\n\nint solve(string stat) {\n    map<string, int> dist;\n    dist[stat] = 0;\n    queue<string> q;\n    q.push(stat);\n    while ( ! q.empty()) {\n        string s = q.front();\n        q.pop();\n        int diff = 0;\n        for (int i=0; i<13; ++i) {\n            diff += s[i] != goal[i];\n        }\n        if ( ! diff) {\n            return dist[s];\n        } else if (20 < dist[s] + diff - 1) {\n            continue;\n        }\n        for (int i=0; i<13; ++i) {\n            if (s[i] != '0') continue;\n            for (int j : adj[i]) {\n                string next = s;\n                next[i] = s[j];\n                next[j] = s[i];\n                if (dist.find(next) == dist.end()) {\n                    q.push(next);\n                    dist[next] = dist[s] + 1;\n                }\n            }\n        }\n    }\n    return 21;\n}\n\nint main() {\n    while (1) {\n        string stat = \"\";\n        int k;\n        for (int i=0; i<13; ++i) {\n            if (cin >> k && !~k) return 0;\n            stat += s[k];\n        }\n        int ans = solve(stat);\n        if (ans <= 20) {\n            cout << ans << endl;\n            continue;\n        }\n        cout << \"NA\" << endl;\n    }\n    return 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include <iostream>\n#include <cmath>\n#include <queue>\n#include <set>\nusing namespace std;\n\nint a[13];\nbool m[13][13];\nint pr[] = {1, 2, 2, 2, 3, 3, 3, 3, 3, 4, 4, 4, 5};\nint pc[] = {3, 2, 3, 4, 1, 2, 3, 4, 5, 2, 3, 4, 3};\nlong long int g;\n\ntypedef pair<int, long long int> P;\n\nlong long int encode(int *x) {\n  long long int t = 0;\n  for (int i=0; i<13; ++i) {\n    t <<= 4;\n    t |= x[i];\n  }\n  return t;\n}\n\nvoid decode(long long int s, int *x) {\n  for (int i=12; i>=0; --i) {\n    x[i] = (int)(s & 0xf);\n    s >>= 4;\n  }\n}\n\nint manhattan(int *x) {\n  int y = 0;\n  for (int i=0; i<13; ++i) {\n    if (!x[i]) {\n      continue;\n    }\n    y += abs(pr[x[i]] - pr[i]);\n    y += abs(pc[x[i]] - pc[i]);\n  }\n  return y;\n}\n\nvoid init() {\n  a[0] = a[12] = 0;\n  for (int i=1; i<12; ++i) {\n    a[i] = i;\n  }\n  g = encode(a);\n\n  for (int i=0; i<13; ++i) {\n    int r1 = pr[i];\n    int c1 = pc[i];\n    m[i][i] = false;\n    for (int j=i+1; j<13; ++j) {\n      int r2 = pr[j];\n      int c2 = pc[j];\n      if (((r1 == r2) && (c1 == c2 + 1 || c1 == c2 - 1))\n          || ((c1 == c2) && (r1 == r2 + 1 || r1 == r2 - 1))) {\n        m[i][j] = m[j][i] = true;\n      } else {\n        m[i][j] = m[j][i] = false;\n      }\n    }\n  }\n}\n\nbool input() {\n  int t;\n  for (int i=0; i<13; ++i) {\n    cin >> t;\n    if (!i && t == -1) {\n      return false;\n    }\n    a[i] = t;\n  }\n  return true;\n}\n\nstruct Comparator {\n  bool operator()(const P l, const P r) const {\n    return l > r;\n  }\n};\n\nint solve() {\n  priority_queue<P, vector<P>, Comparator> q;\n  set<long long int> u;\n\n  long long int t;\n  t = encode(a);\n  q.push(make_pair(manhattan(a), t));\n\n  while (!q.empty()) {\n    P p = q.top();\n    q.pop();\n\n    if (u.find(p.second) != u.end()) {\n      continue;\n    }\n    u.insert(p.second);\n\n    if (p.second == g) {\n      return p.first;\n    }\n\n    decode(p.second, a);\n    int x = manhattan(a);\n    int y = p.first - x;\n    if (y >= 20) {\n      break;\n    }\n    for (int i=0; i<13; ++i) {\n      if (a[i]) {\n        continue;\n      }\n      for (int j=0; j<13; ++j) {\n        if (!m[i][j]) {\n          continue;\n        }\n        a[i] = a[j];\n        a[j] = 0;\n        int z = manhattan(a);\n        q.push(make_pair(y + 1 + z, encode(a)));\n        a[j] = a[i];\n        a[i] = 0;\n      }\n    }\n  }\n  return -1;\n}\n\nint main() {\n  int ans;\n  init();\n  while (1) {\n    if (!input()) {\n      break;\n    }\n    ans = solve();\n    if (ans >= 0) {\n      cout << ans << endl;\n    } else {\n      cout << \"NA\" << endl;\n    }\n  }\n  return 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include <iostream>\n#include <stdlib.h>\nusing namespace std;\n\nint p[5][5],x[11]={1,2,3,0,1,2,3,4,1,2,3},y[11]={1,1,1,2,2,2,2,2,3,3,3},s,sx[2],sy[2]\n    ,mx[4]={1,0,-1,0},my[4]={0,-1,0,1},lt;\nint search(int t,int mx2,int my2,int mc) {\n\tint a,i,j,x2,y2,s2;\n\tif (t-1>=lt) return 0;\n\tif (s==0) { lt=t-1; return 1;}\n\t  for (i=0;i<2;i++) for (j=0;j<4;j++) {\n\t  x2=sx[i]+mx[j]; y2=sy[i]+my[j];\n\t  if (x2<0 || x2>4 || y2<0 || y2>4) continue;\n\t  if (p[y2][x2]<1 || ( mc==i  && mx2==-mx[j] && my2==-my[j])) continue;\n\t  s2=abs(x2-x[p[y2][x2]-1])+abs(y2-y[p[y2][x2]-1])-abs(sx[i]-x[p[y2][x2]-1])-abs(sy[i]-y[p[y2][x2]-1]);\n\t  if (s-s2>lt) continue;\n\t  p[sy[i]][sx[i]]=p[y2][x2]; p[y2][x2]=0;  s+=s2; \n\t  sx[i]=x2; sy[i]=y2;\n\t  a=search(t+1,mx[j],my[j],i);\n\t  sx[i]=x2-mx[j]; sy[i]=y2-my[j];\n\t  p[y2][x2]=p[sy[i]][sx[i]]; p[sy[i]][sx[i]]=0; s-=s2;\n\t  if (a==1) return 0;\n  }\n  return 0;\n}\n\nint main() {\n  int i,j,k;\n  for (i=0;i<5;i++) for (j=0;j<5;j++) p[i][j]=-1;\n  while (cin >> p[0][2] && p[0][2]!=-1) {\n\t  cin >> p[1][1] >> p[1][2] >> p[1][3];\n\t  cin >> p[2][0] >> p[2][1] >> p[2][2] >> p[2][3] >> p[2][4];\n\t  cin >> p[3][1] >> p[3][2] >> p[3][3];\n\t  cin >> p[4][2]; k=0; s=0;\n\t  for (i=0;i<5;i++) for (j=0;j<5;j++) {\n\t\t  if (p[i][j]==0) { sx[k++]=j; sy[k++]=i;}\n\t\t  if (p[i][j]>0) s+=abs(j-x[p[i][j]-1])+abs(i-y[p[i][j]-1]);\n\t\t   }\n\t  lt=21;\t   \n\t  search(1,0,0,0);\n\t  if (lt==21) cout << \"NA\" << endl; else cout << lt << endl;\n  } \n return 0;\n}\t\t "
  },
  {
    "language": "C++",
    "code": "#include <iostream> \n#include <sstream> \n#include <iomanip> \n#include <algorithm> \n#include <cmath> \n#include <string> \n#include <vector> \n#include <list> \n#include <queue> \n#include <stack> \n#include <set> \n#include <map> \n#include <bitset> \n#include <numeric> \n#include <climits> \n#include <cfloat> \nusing namespace std;\n\nint main()\n{\n    string goal = \"##.##\"\n                  \"#abc#\"\n                  \"defgh\"\n                  \"#ijk#\"\n                  \"##.##\";\n\n    vector<int> pos(256);\n    for(int i=0; i<25; ++i){\n        if(goal[i] != '#' && goal[i] != '.')\n            pos[goal[i]] = i;\n    }\n\n    int d[] = {5, -5, 1, -1};\n\n    for(;;){\n        string s(25, '#');\n        for(int i=0; i<25; ++i){\n            if(goal[i] == '#')\n                continue;\n            int a;\n            cin >> a;\n            if(a == -1)\n                return 0;\n            if(a == 0)\n                s[i] = '.';\n            else\n                s[i] = 'a' + a - 1;\n        }\n\n        if(s == goal){\n            cout << 0 << endl;\n            continue;\n        }\n\n        set<string> history;\n        history.insert(s);\n        vector<string> curr(1, s);\n\n        int ret = -1;\n        for(int i=0; i<20; ++i){\n            vector<string> next;\n            for(unsigned j=0; j<curr.size(); ++j){\n                int len = 0;\n                for(int k=0; k<25; ++k){\n                    if(curr[j][k] != '#' && curr[j][k] != '.')\n                        len += abs(k/5 - pos[curr[j][k]]/5) + abs(k%5 - pos[curr[j][k]]%5);\n                }\n                if(len > 20 - i)\n                    continue;\n\n                for(int k=0; k<25; ++k){\n                    if(curr[j][k] != '.')\n                        continue;\n                    for(int l=0; l<4; ++l){\n                        if(l < 2 && (k+d[l] < 0 || k+d[l] >= 25))\n                            continue;\n                        if(l >= 2 && (k+5) / 5 != (k+d[l]+5) / 5)\n                            continue;\n                        if(curr[j][k+d[l]] == '#')\n                            continue;\n                        swap(curr[j][k], curr[j][k+d[l]]);\n                        if(history.find(curr[j]) == history.end()){\n                            if(curr[j] == goal)\n                                ret = i + 1;\n                            history.insert(curr[j]);\n                            next.push_back(curr[j]);\n                        }\n                        swap(curr[j][k], curr[j][k+d[l]]);\n                    }\n                }\n            }\n            curr.swap(next);\n            if(ret != -1)\n                break;\n        }\n\n        if(ret == -1)\n            cout << \"NA\" << endl;\n        else\n            cout << ret << endl;\n    }\n}"
  },
  {
    "language": "C++",
    "code": "#include<iostream>\n#include<queue>\n#include<map>\n#include<cstring>\nusing namespace std;\n\nstruct puz{\n\tint a[5][5];\n\tint tim;\n};\n\nmap<string,bool> memo;\nqueue<struct puz> que;\nstruct puz def;\nstruct puz tmp;\nstring z;\n\nvoid erase(){\n\tfor(int i=0; i<5; i++)\n\t\tfor(int k=0; k<5; k++)\n\t\t\tdef.a[i][k] = 20;\n\tdef.tim = 0;\n\twhile(!que.empty())\n\t\tque.pop();\n\tmemo.clear();\n}\n\nbool clear(){\n\tfor(int i=1; i<4; i++)\n\t\tif(def.a[1][i] != i || def.a[3][i] != i+8)\n\t\t\treturn false;\n\tfor(int i=0; i<5; i++){\n\t\tif(def.a[2][i] != i+4)\n\t\t\treturn false;\n\t}\n\treturn true;\n}\n\nvoid int2str(){\n\tz.erase();\n\tfor(int i=0; i<5; i++){\n\t\tfor(int k=0; k<5; k++){\n\t\t\tchar t[2];\n\t\t\tt[0] = (char)(def.a[i][k]+48);\n\t\t\tt[1] = '\\0';\n\t\t\tz.append(t);\n\t\t}\n\t}\n}\n\nvoid solve(){\n\tque.push(def);\n\twhile(true){\n\t\tif(que.empty()){\n\t\t\tcout << \"NA\" << endl;\n\t\t\tbreak;\n\t\t}\n\t\tdef = que.front();\n\t\tque.pop();\n\t\t\n\t\tif(def.tim > 15){\n\t\t\tcout << \"NA\" << endl;\n\t\t\tbreak;\n\t\t}\n\n\t\tint2str();\n\n\t\tif(memo[z])\n\t\t\tcontinue;\n\t\telse\n\t\t\tmemo[z] = true;\n\n\t\tif(clear()){\n\t\t\tcout << def.tim << endl;\n\t\t\tbreak;\n\t\t}\n\n\t\ttmp = def;\n\t\tfor(int i=0; i<5; i++){\n\t\t\tfor(int k=0; k<5; k++){\n\t\t\t\tif(def.a[i][k] == 0){\n\t\t\t\t\tif(i != 0){\n\t\t\t\t\t\tif(tmp.a[i-1][k] != 20){\n\t\t\t\t\t\t\ttmp.a[i-1][k] = 0;\n\t\t\t\t\t\t\ttmp.a[i][k] = def.a[i-1][k];\n\t\t\t\t\t\t\ttmp.tim = def.tim+1;\n\t\t\t\t\t\t\tque.push(tmp);\n\t\t\t\t\t\t\ttmp = def;\n\t\t\t\t\t\t}\n\t\t\t\t\t}\n\t\t\t\t\tif(i != 4){\n\t\t\t\t\t\tif(tmp.a[i+1][k] != 20){\n\t\t\t\t\t\t\ttmp.a[i+1][k] = 0;\n\t\t\t\t\t\t\ttmp.a[i][k] = def.a[i+1][k];\n\t\t\t\t\t\t\ttmp.tim = def.tim+1;\n\t\t\t\t\t\t\tque.push(tmp);\n\t\t\t\t\t\t\ttmp = def;\n\t\t\t\t\t\t}\n\t\t\t\t\t}\n\t\t\t\t\tif(k != 0){\n\t\t\t\t\t\tif(tmp.a[i][k-1] != 20){\n\t\t\t\t\t\t\ttmp.a[i][k-1] = 0;\n\t\t\t\t\t\t\ttmp.a[i][k] = def.a[i][k-1];\n\t\t\t\t\t\t\ttmp.tim = def.tim+1;\n\t\t\t\t\t\t\tque.push(tmp);\n\t\t\t\t\t\t\ttmp = def;\n\t\t\t\t\t\t}\n\t\t\t\t\t}\n\t\t\t\t\tif(k != 4){\n\t\t\t\t\t\tif(tmp.a[i][k+1] != 20){\n\t\t\t\t\t\t\ttmp.a[i][k+1] = 0;\n\t\t\t\t\t\t\ttmp.a[i][k] = def.a[i][k+1];\n\t\t\t\t\t\t\ttmp.tim = def.tim+1;\n\t\t\t\t\t\t\tque.push(tmp);\n\t\t\t\t\t\t\ttmp = def;\n\t\t\t\t\t\t}\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t\t\n\t}\n}\n\nint main(){\n\twhile(true){\n\t\terase();\n\t\tcin >> def.a[0][2];\n\t\tif(!(def.a[0][2]+1))\n\t\t\treturn 0;\n\t\tcin >> def.a[1][1];\n\t\tcin >> def.a[1][2];\n\t\tcin >> def.a[1][3];\n\t\tcin >> def.a[2][0];\n\t\tcin >> def.a[2][1];\n\t\tcin >> def.a[2][2];\n\t\tcin >> def.a[2][3];\n\t\tcin >> def.a[2][4];\n\t\tcin >> def.a[3][1];\n\t\tcin >> def.a[3][2];\n\t\tcin >> def.a[3][3];\n\t\tcin >> def.a[4][2];\n\t\tsolve();\n\t}\n}"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\n\nusing namespace std;\n\n#define int long long\n#define FR first\n#define SC second\n#define all(v) (v).begin(), (v).end()\n#define rep(i, n) for(int i = 0; i < (int)(n); i++)\n#define reps(i, f, n) for(int i = (int)(f); i < (int)(n); i++)\n#define each(a, b) for(auto& a : b)\n\ntypedef pair<int, int> P;\n\nconst int inf = 1LL << 55;\n\nvector< vector<int> > to = {\n  {2},\n  {2, 5},\n  {0, 1, 3, 6},\n  {2, 7},\n  {5},\n  {1, 4, 6, 9},\n  {2, 5, 7, 10},\n  {3, 6, 8, 11},\n  {7},\n  {5, 10},\n  {6, 9, 11, 12},\n  {7, 10},\n  {10}\n};\n\nvector<int> ans = {0,1,2,3,4,5,6,7,8,9,10,11,0};\n\nsigned main()\n{\n  cin.tie(0);\n  ios_base::sync_with_stdio(0);\n  cout << fixed << setprecision(12);\n\n  map<vector<int>, int> D;  \n  queue< vector<int> > que;\n  que.push(ans);\n  D[ans] = 0;\n  while(!que.empty()) {\n    auto v = que.front(); que.pop();\n    if(D[v] >= 10) break;\n    rep(i, v.size()) {\n      if(v[i]) continue;\n      rep(j, to[i].size()) {\n\tint c = D[v];\n\tswap(v[i], v[to[i][j]]);\n\tif(!D.count(v)) {\n\t  que.push(v);\n\t  D[v] = c + 1;\n\t}\n\tswap(v[i], v[to[i][j]]);\t\n      }\n    }\n  }\n  \n  int p;\n  while(cin >> p, ~p) {\n    vector<int> pzl; pzl.push_back(p);\n    rep(i, 12) cin >> p, pzl.push_back(p);\n    map<vector<int>, int> d;\n    queue< vector<int> > que;\n    que.push(pzl);\n    d[pzl] = 0;\n    bool flag = false;\n    while(!que.empty() && !flag) {\n      auto v = que.front(); que.pop();\n      if(v == ans) {\n\tcout << d[v] << endl;\n\tflag = true;\n\tbreak;\n      }\n      if(d[v] >= 10) break;\n      rep(i, v.size()) {\n\tif(v[i]) continue;\n\trep(j, to[i].size()) {\n\t  int c = d[v];\n\t  swap(v[i], v[to[i][j]]);\n\t  if(D.count(v)) {\n\t    cout << D[v] + c + 1 << endl;\n\t    flag = true;\n\t    break;\n\t  } else if(!d.count(v)) {\n\t    que.push(v);\n\t    d[v] = c + 1;\n\t  }\n\t  swap(v[i], v[to[i][j]]);\n\t}\n\tif(flag) break;\n      }\n    }\n    if(!flag) cout << \"NA\" << endl;\n  }\n  return 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include<bits/stdc++.h>\n#define r(i,n) for(int i=0;i<n;i++)\nusing namespace std;\ntypedef pair<vector<int>,int>P;\nvector<int>v[13],s(13),t(13);\nmap<vector<int>,int>m;\n \nint has[14];\n \n \nvoid init(){\n \n    v[0].push_back(2);\n \n    v[1].push_back(2);\n    v[1].push_back(5);\n \n    v[2].push_back(0);\n    v[2].push_back(1);\n    v[2].push_back(3);\n    v[2].push_back(6);\n \n    v[3].push_back(2);\n    v[3].push_back(7);\n \n    v[4].push_back(5);\n \n    v[5].push_back(1);\n    v[5].push_back(4);\n    v[5].push_back(6);\n    v[5].push_back(9);\n \n    v[6].push_back(2);\n    v[6].push_back(5);\n    v[6].push_back(7);\n    v[6].push_back(10);\n \n    v[7].push_back(3);\n    v[7].push_back(6);\n    v[7].push_back(8);\n    v[7].push_back(11);\n \n    v[8].push_back(7);\n \n    v[9].push_back(5);\n    v[9].push_back(10);\n \n    v[10].push_back(6);\n    v[10].push_back(9);\n    v[10].push_back(11);\n    v[10].push_back(12);\n \n    v[11].push_back(7);\n    v[11].push_back(10);\n \n    v[12].push_back(10);\n \n    int a=20;\n    int p=1;\n \n    r(i,13){\n        has[i]=p;\n        p*=a;\n    }\n}\n \nint ha(vector<int> &x){\n \n    int re=0;\n \n    r(i,13){\n        re+=x[i]*has[i];\n    }\n \n    return re;\n}\n \nvector<int> ah(int x){\n    vector<int>y(13);\n    r(i,13){\n        y[i]=x%20;\n        x/=20;\n    }\n    return y;\n}\n \nvoid BFS1(){\n    s[0]=0;\n    s[12]=0;\n    r(i,11)s[i+1]=i+1;\n    set<vector<int> >st;\n    st.insert(s);\n    m[s]=0;\n    queue<P>q;\n    q.push(P(s,0));\n    while(1){\n        vector<int> now=q.front().first;\n        int cost=q.front().second;\n        q.pop();\n        if(cost==11)break;\n        //cout<<m.size()<<' '<<cost<<endl;\n        r(i,13)if(now[i]==0){\n            r(j,v[i].size()){\n                swap(now[i],now[v[i][j]]);\n                if(!st.count(now)){\n                    st.insert(now);\n                    m[now]=cost+1;\n                    q.push(P(now,cost+1));\n                }\n                swap(now[i],now[v[i][j]]);\n            }\n        }\n    }\n}\n \nvoid BFS2(){\n    set<vector<int> >st;\n    st.insert(t);\n    queue<P>q;\n    q.push(P(t,0));\n    while(1){\n        vector<int>now=q.front().first;\n        int cost=q.front().second;\n        q.pop();\n        if(m.count(now)){\n            cout<<m[now]+cost<<endl;\n            return ;\n        }\n        if(cost==9)break;\n        r(i,13)if(now[i]==0){\n            r(j,v[i].size()){\n                swap(now[i],now[v[i][j]]);\n                if(!st.count(now)){\n                    st.insert(now);\n                    if(m.count(now)){\n                        cout<<m[now]+cost+1<<endl;\n                        return ;\n                    }\n                    q.push(P(now,cost+1));\n                }\n                swap(now[i],now[v[i][j]]);\n            }\n        }\n    }\n    cout<<\"NA\"<<endl;\n}\n \n \nsigned main(){\n    init();\n    BFS1();\n    while(cin>>t[0],t[0]!=-1){\n        r(i,12)cin>>t[i+1];\n        BFS2();\n    }\n}\n"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\nusing namespace std;\nconst int pos_x[] = {0, 1, 1, 1, 2, 2, 2, 2, 2, 3, 3, 3, 4};\nconst int pos_y[] = {2, 1, 2, 3, 0, 1, 2, 3, 4, 1, 2, 3, 2};\nconst int table[][5] = {\n\t{2, -1},\n\t{2, 5, -1},\n\t{0, 1, 3, 6, -1},\n\t{2, 7, -1},\n\t{5, -1},\n\t{1, 4, 6, 9, -1},\n\t{2, 5, 7, 10, -1},\n\t{3, 6, 8, 11, -1},\n\t{7, -1},\n\t{5, 10, -1},\n\t{6, 9, 11, 12, -1},\n\t{7, 10, -1},\n\t{10, -1},\n};\n\nstruct Puzzle {\n\tvector<int> val;\n\tPuzzle(): val(13){}\n\tint score(){\n\t\tint res = 0;\n\t\tfor (int i = 0; i < 13; i++){\n\t\t\tif (!val[i]) continue;\n\t\t\tint v = val[i];\n\t\t\tres += abs(pos_x[v] - pos_x[i]);\n\t\t\tres += abs(pos_y[v] - pos_y[i]);\n\t\t}\n\t\treturn res;\n\t}\n\tvoid show(){\n\t\tfor (int i = 0; i < 13; i++){\n\t\t\tprintf(\"%d \", val[i]);\n\t\t\tif (i == 0 || i == 3 || i == 8 || i == 11 || i == 12){\n\t\t\t\tputs(\"\");\n\t\t\t}\n\t\t}\n\t}\n};\n\n/*inline bool check(Puzzle &p)\n{\n\tfor (int i = 1; i <= 11; i++){\n\t\tif (p.val[i] != i) return false;\n\t}\n\treturn true;\n}*/\n\nbool search(int d, Puzzle &p)\n{\n\tif (p.score() == 0) return true;\n\tif (d == 0) return false;\n\t\n\tfor (int i = 0; i < 13; i++){\n\t\tif (p.val[i]) continue;\n\t\tfor (const int *to = &table[i][0]; ~(*to); to++){\n\t\t\tswap(p.val[i], p.val[*to]);\n\t\t\t//printf(\"%d %d\\n\", i, *to);\n\t\t\t//printf(\"%d\\n\", p.score());\n\t\t\tif (d - 1 - p.score() >= 0){\n\t\t\t\tif (search(d - 1, p)) return true;\n\t\t\t}\n\t\t\tswap(p.val[i], p.val[*to]);\n\t\t}\n\t}\n\treturn false;\n}\n\nvoid solve(Puzzle &p)\n{\n\tfor (int d = 0; d <= 20; d++){\n\t\tif (search(d, p)){\n\t\t\tprintf(\"%d\\n\", d);\n\t\t\treturn;\n\t\t}\n\t}\n\tputs(\"NA\");\n}\n\nint main()\n{\t\n\tPuzzle p;\n\twhile (true){\n\t\tfor (int i = 0; i < 13; i++){\n\t\t\tscanf(\"%d\", &p.val[i]);\n\t\t\tif (p.val[i] == -1) return 0;\n\t\t}\n\t\tsolve(p);\n\t}\n}"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\n\nusing namespace std;\n\ntypedef long long ll;\ntypedef long double ld;\ntypedef tuple<int, int> duo;\nconst int dx[] = {0, 0, 1, -1, 1, 1, -1, -1};\nconst int dy[] = {1, -1, 0, 0, 1, -1, 1, -1};\nconst int Mod = 1000000000 + 0;\n//{{{ templates\n#define TT_             \\\n  template <typename T> \\\n  inline\n#define TTF_                        \\\n  template <typename T, typename F> \\\n  inline\nTT_ T sq(T x) { return x * x; }\nTT_ T In() {\n  T x;\n  cin >> x;\n  return x;\n}\nTT_ void Out(T& x) { cout << x; }\nTT_ void sort(T& v) { sort(begin(v), end(v)); }\nTT_ void revs(T& v) { reverse(begin(v), end(v)); }\nTT_ void uniq(T& v) {\n  sort(v);\n  v.erase(unique(begin(v), end(v)), end(v));\n}\nTT_ int ubnd(T& v, typename T::value_type& x) {\n  return upper_bound(begin(v), end(v), x) - begin(v);\n}\nTT_ int lbnd(T& v, typename T::value_type& x) {\n  return lower_bound(begin(v), end(v), x) - begin(v);\n}\nTTF_ void inpt(T& v, int n, F f) {\n  for (v.reserve(n); n--; v.emplace_back(f()))\n    ;\n}\nTTF_ void show(T& v, F f, string d = \" \", string e = \"\\n\") {\n  int i = 0;\n  for (auto& x : v) i++&&(cout << d), f(x);\n  cout << e;\n}\nTT_ typename T::iterator minel(T& v) { return min_element(begin(v), end(v)); }\nTT_ typename T::iterator maxel(T& v) { return max_element(begin(v), end(v)); }\n\ninline void fast_io() {\n  ios::sync_with_stdio(0);\n  cin.tie(0);\n}\ninline int in() {\n  int x;\n  scanf(\"%d\", &x);\n  return x;\n}\ninline ll pow_mod(ll a, ll k, ll m) {\n  ll r = 1;\n  for (; k > 0; a = a * a % m, k >>= 1)\n    if (k & 1) r = r * a % m;\n  return r;\n}\ninline ll mod_inv(ll a, ll p) { return pow_mod(a, p - 2, p); }\n//}}} priority_queue queue deque front stringstream max_element min_element\n// insert count make_tuple\n\nstruct Board {\n  Board() {\n    memcpy(b, \"0123456789AB0\", sizeof(b));\n    find_zero();\n  }\n  Board(const vector<int>& v) {\n    for (int i = 0; i < 13; i++) b[i] = conv_hex(v[i]);\n    b[13] = 0;\n    find_zero();\n  }\n  void find_zero(){\n    int it = 0;\n    for (int i = 0; i < 13; i++){\n      if (b[i] == '0'){\n        cur[it] = i;\n        it++;\n      }\n    }\n  }\n  char conv_hex(int a) { return \"0123456789ABCDEF\"[a]; }\n  bool slide(int index, int dir) {\n    static const char mov[][4] = {\n      {-1, -1, 2, -1},\n      {-1, 2, 5, -1},\n      {0, 3, 6, 1},\n      {-1, -1, 7, 2},\n      {-1, 5, -1, -1},\n      {1, 6, 9, 4},\n      {2, 7, 10, 5},\n      {3, 8, 11, 6},\n      {-1, -1, -1, 7},\n      {5, 10, -1, -1},\n      {6, 11, 12, 9},\n      {7, -1, -1, 10},\n      {10, -1, -1, -1},\n    };\n    char cu = cur[index];\n    char nu = mov[cu][dir];\n    if (nu == -1) return false;\n    if (b[nu] == '0') return false;\n    swap(b[cu], b[nu]);\n    cur[index] = nu;\n    turn++;\n    return true;\n  }\n  char b[14];\n  char cur[2];\n  char turn;\n};\n\nvoid build_table(unordered_map<ll, char>& ans){\n  Board b;\n  queue<Board> Q;\n  Q.push(b);\n  while (!Q.empty()){\n    Board bi = Q.front();\n    Q.pop();\n    ll hv = strtoll(bi.b, 0, 16);\n    if (ans.count(hv)) continue;\n    ans[hv] = bi.turn;\n    if (bi.turn >= 10) continue;\n    for (int i = 0; i < 2; i++){\n      for (int d = 0; d < 4; d++){\n        auto bii = bi;\n        if (!bii.slide(i, d)) continue;\n        Q.push(bii);\n      }\n    }\n  }\n}\n\nint main() {\n  unordered_map<ll, char> ans;\n  build_table(ans);\n  int h;\n  while (h = in(), h != -1) {\n    vector<int> vs;\n    vs.push_back(h);\n    for (int i = 0; i < 12; i++) vs.push_back(in());\n    Board b(vs);\n    unordered_set<ll> vis;\n    queue<Board> Q;\n    Q.push(b);\n    while (!Q.empty()){\n      Board bi = Q.front();\n      Q.pop();\n      ll hv = strtoll(bi.b, 0, 16);\n      if (vis.count(hv)) continue;\n      vis.insert(hv);\n      if (ans.count(hv)){\n        cout << (int)ans[hv] + (int)bi.turn << endl;\n        goto END;\n      }\n      if (bi.turn >= 11) continue;\n      for (int i = 0; i < 2; i++){\n        for (int d = 0; d < 4; d++){\n          Board bii = bi;\n          if (!bii.slide(i, d)) continue;\n          Q.push(bii);\n        }\n      }\n    }\n    cout << \"NA\\n\";\nEND:;\n  }\n  return 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include <cstdio>\n#include <cstdlib>\n#include <cmath>\n#include <climits>\n#include <cfloat>\n#include <map>\n#include <utility>\n#include <set>\n#include <iostream>\n#include <memory>\n#include <string>\n#include <vector>\n#include <algorithm>\n#include <functional>\n#include <sstream>\n#include <complex>\n#include <stack>\n#include <queue>\n#include <cstring>\n#include <sstream>\n#include <cassert>\n#include <list>\nusing namespace std;\nstatic const double EPS = 1e-10;\ntypedef long long ll;\ntypedef pair<int,int> PI;\ntypedef vector<int> vi;\n#ifndef M_PI\n#define M_PI 3.14159265358979323846\n#endif\n#define rep(i,n) for(int i=0;i<(int)n;++i)\n#define FOR(i,c) for(__typeof((c).begin())i=(c).begin();i!=(c).end();++i)\n#define ALL(c) (c).begin(), (c).end()\n#define mp(a,b) make_pair(a,b)\n#define pb(a) push_back(a)\n#define F first\n#define S second\ntemplate <typename T> string print_array(const vector<T> &V) { ostringstream os; os << \"{ \"; for (typename vector<T>::const_iterator iter = V.begin(); iter != V.end(); ++iter) os << '\\\"' << *iter << \"\\\",\"; os << \" }\"; return os.str(); }\n\nint dx[]={0,1,0,-1},dy[]={1,0,-1,0};\n\nvector<int> se[13];\nint x[]={0,-1,0,1,-2,-1,0,1,2,-1,0,1,0};\nint y[]={2,1,1,1,0,0,0,0,0,-1,-1,-1,-2};\n\nvoid pr(ll in){\n\n  printf(\"      %3lld\\n\",in&15);\n  printf(\"   %3lld%3lld%3lld\\n\",(in>>4)&15,(in>>8)&15,(in>>12)&15);\n  printf(\"%3lld%3lld%3lld%3lld%3lld\\n\",(in>>16)&15,(in>>20)&15,(in>>24)&15,(in>>28)&15,(in>>32)&15);\n  printf(\"   %3lld%3lld%3lld\\n\",(in>>36)&15,(in>>40)&15,(in>>44)&15);\n  printf(\"      %3lld\\n\",(in>>48)&15);\n  puts(\"\");\n}\n\nint manh(ll in){\n  int ret=0;\n  rep(i,13){\n    int t=(in>>(i*4))&15;\n\n    if(!t)continue;\n    int nx=(x[t]-x[i]),ny=y[t]-y[i];\n    ret+=abs(nx)+abs(ny);\n  }\n  return ret;\n}\n\nmain(){\n  ll p;\n\n  ll goal=0;\n  rep(i,11){\n    goal|=(i+1LL)<<(4*(i+1));\n    //cout<<goal<<endl;\n    //pr(goal);\n  }\n  //pr(goal);\n\n  se[0].pb(2);\n  se[1].pb(2);\n  se[1].pb(5);\n  se[2].pb(0);\n  se[2].pb(1);\n  se[2].pb(3);\n  se[2].pb(6);\n  se[3].pb(2);\n  se[3].pb(7);\n  se[4].pb(5);\n  se[5].pb(1);\n  se[5].pb(4);\n  se[5].pb(6);\n  se[5].pb(9);\n  se[6].pb(2);\n  se[6].pb(5);\n  se[6].pb(7);\n  se[6].pb(10);\n  se[7].pb(3);\n  se[7].pb(6);\n  se[7].pb(8);\n  se[7].pb(11);\n  se[8].pb(7);\n  se[9].pb(5);\n  se[9].pb(10);\n  se[10].pb(6);\n  se[10].pb(9);\n  se[10].pb(11);\n  se[10].pb(12);\n  se[11].pb(7);\n  se[11].pb(10);\n  se[12].pb(10);\n  \n  while(cin>>p){\n    if(p==-1)break;\n    ll in=p;\n\n    rep(i,12){\n      cin>>p;\n      in|=p<<(4*(i+1));\n    }\n\n    set<ll> app;\n\n    queue<pair<int,ll> > Q;\n    app.insert(in);\n    Q.push(mp(0,in));\n    int ans=21;\n    int mans=0;\n\n    while(!Q.empty()){\n      ll cvec=Q.front().S;\n      int ccost=Q.front().F;\n      Q.pop();\n    \n      //pr(cvec);\n\n      //if(ccost>3)break;\n      if(ccost+manh(cvec)>22)continue;\n      if(cvec==goal){\n\tans=ccost;\n\tbreak;\n      }\n      rep(i,13){\n\tll t=cvec>>(i<<2);\n\tt=t&15;\n\tif(!t){\n\t  rep(j,se[i].size()){\n\t    t=cvec>>(se[i][j]<<2);\n\t    t=t&15;\n\t    if(t){\n\t      ll nvec=cvec;\n\t      t=t<<(i<<2);\n\t      nvec|=t;\n\t      nvec&=~(15LL<<se[i][j]*4);\n\t      \n\t      if(!app.count(nvec)){\n\t\tapp.insert(nvec);\n\t\tQ.push(mp(ccost+1,nvec));\n\t      }\n\t    }\n\t  }\n\t}\n      }\n    }\n    if(ans==21)cout<<\"NA\"<<endl;\n    else cout<<ans<<endl;\n  }\n}"
  },
  {
    "language": "C++",
    "code": "#include <iostream>\n#include <vector>\nusing namespace std;\n\ntypedef vector <int> VI;\ntypedef vector <VI> VVI;\n\nVVI goal;\nVVI init;\n\nint limit;\n\nconst int di[4] = { 0, 0, 1, -1 };\nconst int dj[4] = { 1, -1, 0, 0 };\n\nconst int T[12][2] = {\n\t{ 0, 0 },\n\t{ 1+1, 1+1 },\n\t{ 1+1, 2+1 },\n\t{ 1+1, 3+1 },\n\t{ 2+1, 0+1 },\n\t{ 2+1, 1+1 },\n\t{ 2+1, 2+1 },\n\t{ 2+1, 3+1 },\n\t{ 2+1, 4+1 },\n\t{ 3+1, 1+1 },\n\t{ 3+1, 2+1 },\n\t{ 3+1, 3+1 }\n};\n\nint getMD( VVI P )\n{\n\tint sum = 0;\n\tint ti, tj;\n\tfor ( int i = 0; i < 7; i++ )\n\t{\n\t\tfor ( int j = 0; j < 7; j++ )\n\t\t{\n\t\t\tif ( P[j][i] <= 0 )\n\t\t\t\tcontinue;\n\n\t\t\tti = T[P[j][i]][0];\n\t\t\ttj = T[P[j][i]][1];\n\t\t\tsum += ( max( ti, i ) - min( ti, i ) + max( tj, j ) - min( tj, j ) );\n\t\t}\n\t}\n\treturn sum;\n}\n\nbool is_goal( VVI puzzle )\n{\n\tbool ok = true;\n\tfor ( int i = 0; ok && i < 7; i++ ) for ( int j = 0; ok && j < 7; j++ )\n\t{\n\t\tif ( puzzle[j][i] != goal[j][i] )\n\t\t\tok = false;\n\t}\n\treturn ok;\n}\n\nbool dfs( int depth, VVI now )\n{\n\tif ( is_goal( now ) )\n\t\treturn true;\n\n\tif ( depth + getMD( now ) > limit )\n\t\treturn false;\n\n\tfor ( int i = 0; i < 7; i++ )\n\t{\n\t\tfor ( int j = 0; j < 7; j++ )\n\t\t{\n\t\t\tif ( now[j][i] != 0 )\n\t\t\t\tcontinue;\n\n\t\t\tfor ( int k = 0; k < 4; k++ )\n\t\t\t{\n\t\t\t\tVVI v = now;\n\t\t\t\tint ni = i + di[k];\n\t\t\t\tint nj = j + dj[k];\n\n\t\t\t\tif ( v[nj][ni] <= 0 )\n\t\t\t\t\tcontinue;\n\n\t\t\t\tswap( v[j][i], v[nj][ni] );\n\n\t\t\t\tif ( dfs( depth+1, v ) )\n\t\t\t\t\treturn true;\n\n\t\t\t}\n\t\t}\n\t}\n\n}\n\nint idfs( VVI src )\n{\n\tfor ( limit = 0; limit <= 20; limit++ )\n\t{\n\t\tif ( dfs( 0, src ) )\n\t\t\treturn limit;\n\t}\n\treturn -1;\n}\n\nint main( void )\n{\n\t// S[ÌóÔðìé\n\tgoal = VVI( 7, VI( 7, -1 ) );\n\tgoal[3][1] = 0;\n\tgoal[3][5] = 0;\n\tfor ( int i = 0; i < 3; i++ )\n\t{\n\t\tgoal[2+i][2] = 1+i;\n\t\tgoal[2+i][4] = 9+i;\n\t}\n\tfor ( int i = 0; i < 5; i++ )\n\t{\n\t\tgoal[1+i][3] = 4+i;\n\t}\n\n\twhile ( 1 )\n\t{\n\t\t// úóÔÌüÍ\n\t\tinit = VVI( 7, VI( 7, -1 ) );\n\t\tcin >> init[3][1];\n\t\tif ( init[3][1] == -1 )\n\t\t\tbreak;\n\t\tfor ( int i = 0; i < 3; i++ )\n\t\t\tcin >> init[2+i][2];\n\t\tfor ( int i = 0; i < 5; i++ )\n\t\t\tcin >> init[1+i][3];\n\t\tfor ( int i = 0; i < 3; i++ )\n\t\t\tcin >> init[2+i][4];\n\t\tcin >> init[3][5];\n\n\t\tint cost = idfs( init );\n\n\t\tif ( cost == -1 )\n\t\t\tcout << \"NA\" << endl;\n\t\telse\n\t\t\tcout << cost << endl;\n\n\t}\n\n\treturn 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include <stdio.h>\n#include <cmath>\n#include <algorithm>\n#include <cfloat>\n#include <stack>\n#include <queue>\n#include <vector>\n#include <string>\n#include <iostream>\n#include <set>\n#include <map>\ntypedef long long int ll;\ntypedef unsigned long long int ull;\n#define BIG_NUM 2000000000\n#define MOD 1000000007\n#define EPS 0.000000001\nusing namespace std;\n\nstruct Info{\n\tshort table[5][5];\n\tint space_row1,space_col1,space_row2,space_col2;\n};\n\nmap<string,bool> MAP;\n\nbool rangeCheck(int row,int col){\n\tif(row < 0 || row >= 5)return false;\n\n\tswitch(row){\n\tcase 0:\n\t\tif(col == 2)return true;\n\t\tbreak;\n\tcase 1:\n\t\tif(col >= 1 && col <= 3)return true;\n\t\tbreak;\n\tcase 2:\n\t\tif(col >= 0 && col <= 4)return true;\n\t\tbreak;\n\tcase 3:\n\t\tif(col >= 1 && col <= 3)return true;\n\t\tbreak;\n\tcase 4:\n\t\tif(col == 2)return true;\n\t\tbreak;\n\t}\n\treturn false;\n}\n\nbool clearFLG;\nint ans;\nint p[13];\nint diff_row[4] = {-1,0,0,1},diff_col[4] = {0,-1,1,0};\n\n\nvoid copyInfo(Info& to,Info from){\n\n\tfor(int row = 0; row <= 4; row++){\n\t\tfor(int col = 0; col <= 4; col++){\n\t\t\tto.table[row][col] = from.table[row][col];\n\t\t}\n\t}\n}\n\n\nvoid recursive(Info info,int depth,int max_depth){\n\n\tif(clearFLG)return;\n\n\tif(depth == max_depth){\n\t\tif(info.table[1][1] == 1 && info.table[1][2] == 2 && info.table[1][3] == 3 &&\n\t\t\t\tinfo.table[2][0] == 4 && info.table[2][1] == 5 && info.table[2][2] == 6 && info.table[2][3] == 7 && info.table[2][4] == 8 &&\n\t\t\t\tinfo.table[3][1] == 9 && info.table[3][2] == 10 && info.table[3][3] == 11){\n\t\t\tclearFLG = true;\n\t\t}\n\t\treturn;\n\t}\n\n\tint adj_row,adj_col;\n\n\tfor(int i = 0; i < 4; i++){\n\t\tadj_row = info.space_row1+diff_row[i];\n\t\tadj_col = info.space_col1+diff_col[i];\n\n\t\tif(rangeCheck(adj_row,adj_col) == false || info.table[adj_row][adj_col] == 0)continue;\n\n\t\tInfo next_info;\n\t\tcopyInfo(next_info,info);\n\n\t\tswap(next_info.table[info.space_row1][info.space_col1],next_info.table[adj_row][adj_col]);\n\n\t\tstring tmp;\n\t\tfor(int row = 0; row <= 4; row++){\n\t\t\tfor(int col = 0; col <= 4; col++){\n\t\t\t\tif(rangeCheck(row,col)){\n\t\t\t\t\ttmp.append(to_string(next_info.table[row][col])).append(to_string('*'));\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\n\t\tauto at = MAP.find(tmp);\n\t\tif(at != MAP.end())continue;\n\n\t\tMAP[tmp] = true;\n\n\t\tnext_info.space_row1 = adj_row;\n\t\tnext_info.space_col1 = adj_col;\n\t\tnext_info.space_row2 = info.space_row2;\n\t\tnext_info.space_col2 = info.space_col2;\n\n\t\trecursive(next_info,depth+1,max_depth);\n\t}\n\n\tfor(int i = 0; i < 4; i++){\n\t\tadj_row = info.space_row2+diff_row[i];\n\t\tadj_col = info.space_col2+diff_col[i];\n\n\t\tif(rangeCheck(adj_row,adj_col) == false || info.table[adj_row][adj_col] == 0)continue;\n\n\t\tInfo next_info;\n\t\tcopyInfo(next_info,info);\n\n\t\tswap(next_info.table[info.space_row2][info.space_col2],next_info.table[adj_row][adj_col]);\n\n\t\tstring tmp;\n\t\tfor(int row = 0; row <= 4; row++){\n\t\t\tfor(int col = 0; col <= 4; col++){\n\t\t\t\tif(rangeCheck(row,col)){\n\t\t\t\t\ttmp.append(to_string(next_info.table[row][col])).append(to_string('*'));\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\n\t\tauto at = MAP.find(tmp);\n\t\tif(at != MAP.end())continue;\n\n\t\tMAP[tmp] = true;\n\n\t\tnext_info.space_row1 = info.space_row1;\n\t\tnext_info.space_col1 = info.space_col1;\n\t\tnext_info.space_row2 = adj_row;\n\t\tnext_info.space_col2 = adj_col;\n\n\t\trecursive(next_info,depth+1,max_depth);\n\t}\n}\n\nvoid func(){\n\n\tfor(int i = 1; i < 13; i++)scanf(\"%d\",&p[i]);\n\n\tInfo first;\n\tfirst.table[0][2] = p[0];\n\tfor(int i = 1; i <= 3; i++)first.table[1][i] = p[i];\n\tfor(int i = 0; i <= 4; i++)first.table[2][i] = p[4+i];\n\tfor(int i = 1; i <= 3; i++)first.table[3][i] = p[8+i];\n\tfirst.table[4][2] = p[12];\n\n\tint count = 0;\n\n\tfor(int row = 0; row <= 4; row++){\n\t\tfor(int col = 0; col <= 4; col++){\n\t\t\tif(rangeCheck(row,col) == true && first.table[row][col] == 0){\n\t\t\t\tif(count == 0){\n\t\t\t\t\tfirst.space_row1 = row;\n\t\t\t\t\tfirst.space_col1 = col;\n\t\t\t\t\tcount++;\n\t\t\t\t}else{\n\t\t\t\t\tfirst.space_row2 = row;\n\t\t\t\t\tfirst.space_col2 = col;\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t}\n\n\tclearFLG = false;\n\n\tfor(int max_depth = 0; max_depth <= 20; max_depth++){\n\t\tMAP.clear();\n\n\t\tstring tmp;\n\t\tfor(int row = 0; row <= 4; row++){\n\t\t\tfor(int col = 0; col <= 4; col++){\n\t\t\t\tif(rangeCheck(row,col)){\n\t\t\t\t\ttmp.append(to_string(first.table[row][col])).append(to_string('*'));\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\n\t\tMAP[tmp] = true;\n\n\t\trecursive(first,0,max_depth);\n\t\tif(clearFLG){\n\t\t\tans = max_depth;\n\t\t\tbreak;\n\t\t}\n\t}\n\n\tif(clearFLG){\n\t\tprintf(\"%d\\n\",ans);\n\t}else{\n\t\tprintf(\"NA\\n\");\n\t}\n}\n\nint main(){\n\n\twhile(true){\n\t\tscanf(\"%d\",&p[0]);\n\t\tif(p[0] == -1)break;\n\n\t\tfunc();\n\t}\n\n\treturn 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include <iostream>\n#include <stdlib.h>\nusing namespace std;\n\nint p[5][5],x[11]={1,2,3,0,1,2,3,4,1,2,3},y[11]={1,1,1,2,2,2,2,2,3,3,3},s,sx[2],sy[2]\n    ,mx[4]={1,0,-1,0},my[4]={0,-1,0,1},lt;\nint search(int t,int mx2,int my2,int mc) {\n\tint a,i,j,x2,y2,s2;\n\tif (s==0) { if (lt>t) lt=t; return 1;}\n\t  for (i=0;i<2;i++) for (j=0;j<4;j++) {\n\t  x2=sx[i]+mx[j]; y2=sy[i]+my[j];\n\t  if (x2<0 || x2>4 || y2<0 || y2>4) continue;\n\t  if (p[y2][x2]<1 || ( mc==i  && mx2==-mx[j] && my2==-my[j])) continue;\n\t  s2=abs(sx[i]-x[p[y2][x2]-1])+abs(sy[i]-y[p[y2][x2]-1])-(abs(x2-x[p[y2][x2]-1])+abs(y2-y[p[y2][x2]-1]));\n\t  if (s+s2>lt-t) continue;\n\t  p[sy[i]][sx[i]]=p[y2][x2]; p[y2][x2]=0;  s+=s2; \n\t  sx[i]=x2; sy[i]=y2;\n\t  a=search(t+1,mx[j],my[j],i);\n\t  sx[i]=x2-mx[j]; sy[i]=y2-my[j]; \n\t  p[y2][x2]=p[sy[i]][sx[i]]; p[sy[i]][sx[i]]=0; s-=s2;\n\t  if (a==1) return 0;\n  }\n  return 0;\n}\n\nint main() {\n  int i,j,k;\n  for (i=0;i<5;i++) for (j=0;j<5;j++) p[i][j]=-1;\n  while (cin >> p[0][2] && p[0][2]!=-1) {\n\t  cin >> p[1][1] >> p[1][2] >> p[1][3];\n\t  cin >> p[2][0] >> p[2][1] >> p[2][2] >> p[2][3] >> p[2][4];\n\t  cin >> p[3][1] >> p[3][2] >> p[3][3];\n\t  cin >> p[4][2]; k=0; s=0;\n\t  for (i=0;i<5;i++) for (j=0;j<5;j++) {\n\t\t  if (p[i][j]==0) { sx[k]=j; sy[k]=i; k++;}\n\t\t  if (p[i][j]>0) s+=abs(j-x[p[i][j]-1])+abs(i-y[p[i][j]-1]);\n\t\t   }\n\t  lt=21;\n\t  search(0,0,0,0);\n\t  if (lt==21) cout << \"NA\" << endl; else cout << lt << endl;\n  } \n return 0;\n}\t"
  },
  {
    "language": "C++",
    "code": "#import<iostream>\n#import<map>\n#import<queue>\n#import<cstdlib>\n#import<cstring>\nusing namespace std;struct B{int z[2];char s[14];bool operator<(const B&r)const{return strcmp(s,r.s)<0;}};main(){int a[13][5]={{2,-1},{2,5,-1},{0,1,3,6,-1},{2,7,-1},{5,-1},{1,4,6,9,-1},{2,5,7,10,-1},{3,6,8,11,-1},{7,-1},{5,10,-1},{6,9,11,12,-1},{7,10,-1},{10,-1}},X[]={2,1,2,3,0,1,2,3,4,1,2,3,2},Y[]={0,1,1,1,2,2,2,2,2,3,3,3,4},v,d,s,i,j,t,u;B g={0,0,\"0123456789:;0\"};for(;;){map<B,int>m;queue<B>q;B b={i=-1,-1};for(;++i<13;!v?b.z[*b.z>=0]=i:0){cin>>v;if(v<0)return 0;b.s[i]=48+v;}b.s[13]=0;m[b]=1;for(q.push(b);!q.empty();q.pop()){B&b=q.front();if(!strcmp(b.s,g.s))break;for(d=i=0;i<13;v?d+=abs(X[v]-X[i])+abs(Y[v]-Y[i]):0,i++)v=b.s[i]-48;s=m[b];if(s+d<22)for(j=0;j<2;j++)for(i=0;~a[u=b.z[j]][i];i++){B n=b;t=n.z[j]=a[u][i];if(t-n.z[1-j]){swap(n.s[u],n.s[t]);int&r=m[n];if(!r)r=s+1,q.push(n);}}}printf(m[g]?\"%d\\n\":\"NA\\n\",m[g]-1);}}"
  },
  {
    "language": "C++",
    "code": "#include<iostream>\n#include<algorithm>\n#include<vector>\n#include<queue>\n#include<unordered_map>\n#define lol(i,n) for(int i=0;i<n;i++)\n#define mod 1000000007\ntypedef long long ll;\nusing namespace std;\nint dx[13][4]={\n  {3,0,0,0},\n  {3,6,0,0},\n  {1,2,4,6},\n  {3,8,0,0},\n  {6,0,0,0},\n  {2,5,7,10},\n  {3,6,8,11},\n  {4,7,9,12},\n  {8,0,0,0},\n  {6,11,0,0},\n  {6,10,12,13},\n  {8,11,0,0},\n  {11,0,0,0}\n};\nunordered_map<ll,int> mp;\nll Compress(int p[]){\n  ll ans=0;\n  for(int i=0;i<13;i++){\n    ans*=13;\n    ans+=p[i];\n  }\n  return ans;\n}\n\nint unzip[13];\nvoid Unzip(ll x){\n  for(int i=0;i<13;i++){\n    unzip[12-i]=x%13;\n    x/=13;\n  }\n}\n\nint beflen=0;\nqueue<pair<ll,int> >Q;\nvoid BFS(int p[],int len){\n  //if(len!=beflen){cout<<len<<endl;beflen=len;}\n  ll tmp=Compress(p);\n  mp[tmp]=len;\n  if(len==15)return;\n  lol(i,13){\n    if(p[i]==0){\n      lol(j,4){\n\tint t=dx[i][j];\n\tif(t==0)break;\n\tt--;\n\tif(p[t]!=0){\n\t  swap(p[i],p[t]);\n\t  tmp=Compress(p);\n\t  if(mp[tmp]!=0)continue;\n\t  mp[tmp]=-1;\n\t  Q.push(make_pair(tmp,len+1));\n\t  swap(p[i],p[t]);\n\t}\n      }\n    }\n  }\n}\n\nint ans;\nvoid EFS(int p[],int len){\n  //if(len!=beflen){cout<<len<<endl;beflen=len;}\n  ll tmp=Compress(p);\n  if(mp[tmp]>0){\n    ans=min(ans,len+mp[tmp]);\n    return;\n  }\n  if(len==7)return;\n  lol(i,13){\n    if(p[i]==0){\n      lol(j,4){\n\tint t=dx[i][j];\n\tif(t==0)break;\n\tt--;\n\tif(p[t]!=0){\n\t  swap(p[i],p[t]);\n\t  tmp=Compress(p);\n\t  Q.push(make_pair(tmp,len+1));\n\t  swap(p[i],p[t]);\n\t}\n      }\n    }\n  }\n}\nint main(){\n  int p[13];\n  lol(i,13)p[i]=i;p[12]=0;\n  Q.push(make_pair(Compress(p),1));\n  while(!Q.empty()){\n    ll data=Q.front().first;\n    int len=Q.front().second;\n    Q.pop();\n    if(mp[data]>0)continue;\n    Unzip(data);\n    BFS(unzip,len);\n  }\n  while(cin>>p[0]&&p[0]!=-1){\n    for(int i=1;i<13;i++)cin>>p[i];\n    ans=mod;\n    Q.push(make_pair(Compress(p),0));\n    while(!Q.empty()){\n      ll data=Q.front().first;\n      int len=Q.front().second;\n      Q.pop();\n      Unzip(data);\n      EFS(unzip,len);\n    }\n    if(ans==mod)cout<<\"NA\"<<endl;\n    else cout<<ans-1<<endl;\n  }\n  return 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include <cstdio>\n#include <cstdlib>\n#include <cmath>\n#include <climits>\n#include <cfloat>\n#include <map>\n#include <utility>\n#include <set>\n#include <iostream>\n#include <memory>\n#include <string>\n#include <vector>\n#include <algorithm>\n#include <functional>\n#include <sstream>\n#include <complex>\n#include <stack>\n#include <queue>\n#include <cstring>\n#include <sstream>\n#include <cassert>\n#include <list>\nusing namespace std;\nstatic const double EPS = 1e-10;\ntypedef long long ll;\ntypedef pair<int,int> PI;\ntypedef vector<int> vi;\n#ifndef M_PI\n#define M_PI 3.14159265358979323846\n#endif\n#define rep(i,n) for(int i=0;i<(int)n;++i)\n#define FOR(i,c) for(__typeof((c).begin())i=(c).begin();i!=(c).end();++i)\n#define ALL(c) (c).begin(), (c).end()\n#define mp(a,b) make_pair(a,b)\n#define pb(a) push_back(a)\n#define F first\n#define S second\ntemplate <typename T> string print_array(const vector<T> &V) { ostringstream os; os << \"{ \"; for (typename vector<T>::const_iterator iter = V.begin(); iter != V.end(); ++iter) os << '\\\"' << *iter << \"\\\",\"; os << \" }\"; return os.str(); }\n\nint dx[]={0,1,0,-1},dy[]={1,0,-1,0};\n\nvector<int> se[13];\nint x[]={0,-1,0,1,-2,-1,0,1,2,-1,0,1,0};\nint y[]={2,1,1,1,0,0,0,0,0,-1,-1,-1,-2};\n\nvoid pr(ll in){\n\n  printf(\"      %3lld\\n\",in&15);\n  printf(\"   %3lld%3lld%3lld\\n\",(in>>4)&15,(in>>8)&15,(in>>12)&15);\n  printf(\"%3lld%3lld%3lld%3lld%3lld\\n\",(in>>16)&15,(in>>20)&15,(in>>24)&15,(in>>28)&15,(in>>32)&15);\n  printf(\"   %3lld%3lld%3lld\\n\",(in>>36)&15,(in>>40)&15,(in>>44)&15);\n  printf(\"      %3lld\\n\",(in>>48)&15);\n  puts(\"\");\n}\n\nint manh(ll in){\n  int ret=0;\n  rep(i,13){\n    int t=(in>>(i*4))&15;\n\n    if(!t){\n      int nx=x[t]-x[i],ny=y[t]-y[i];\n      int co=abs(nx)+abs(ny);\n      nx=x[12]-x[i],ny=y[12]-y[i];\n      int k=abs(nx)+abs(ny);\n      ret+=min(co,k);\n      continue;\n    }\n    int nx=(x[t]-x[i]),ny=y[t]-y[i];\n    ret+=abs(nx)+abs(ny);\n  }\n  return ret;\n}\n\nmain(){\n  ll p;\n\n  ll goal=0;\n  rep(i,11){\n    goal|=(i+1LL)<<(4*(i+1));\n    //cout<<goal<<endl;\n    //pr(goal);\n  }\n  //pr(goal);\n\n  se[0].pb(2);\n  se[1].pb(2);\n  se[1].pb(5);\n  se[2].pb(0);\n  se[2].pb(1);\n  se[2].pb(3);\n  se[2].pb(6);\n  se[3].pb(2);\n  se[3].pb(7);\n  se[4].pb(5);\n  se[5].pb(1);\n  se[5].pb(4);\n  se[5].pb(6);\n  se[5].pb(9);\n  se[6].pb(2);\n  se[6].pb(5);\n  se[6].pb(7);\n  se[6].pb(10);\n  se[7].pb(3);\n  se[7].pb(6);\n  se[7].pb(8);\n  se[7].pb(11);\n  se[8].pb(7);\n  se[9].pb(5);\n  se[9].pb(10);\n  se[10].pb(6);\n  se[10].pb(9);\n  se[10].pb(11);\n  se[10].pb(12);\n  se[11].pb(7);\n  se[11].pb(10);\n  se[12].pb(10);\n  \n  while(cin>>p){\n    if(p==-1)break;\n    ll in=p;\n\n    rep(i,12){\n      cin>>p;\n      in|=p<<(4*(i+1));\n    }\n\n    set<ll> app;\n\n    queue<pair<int,ll> > Q;\n    app.insert(in);\n    Q.push(mp(0,in));\n    int ans=21;\n    int mans=0;\n\n    while(!Q.empty()){\n      ll cvec=Q.front().S;\n      int ccost=Q.front().F;\n      Q.pop();\n    \n      //pr(cvec);\n\n      //if(ccost>3)break;\n     if(ccost>20)break;\n     \n      if(cvec==goal){\n\tans=ccost;\n\tbreak;\n      }\n      if(ccost+manh(cvec)>24)continue;\n      rep(i,13){\n\tll t=cvec>>(i<<2);\n\tt=t&15;\n\tif(!t){\n\t  rep(j,se[i].size()){\n\t    t=cvec>>(se[i][j]<<2);\n\t    t=t&15;\n\t    if(t){\n\t      ll nvec=cvec;\n\t      t=t<<(i<<2);\n\t      nvec|=t;\n\t      nvec&=~(15LL<<se[i][j]*4);\n\t      \n\t      if(!app.count(nvec)){\n\t\tapp.insert(nvec);\n\t\tQ.push(mp(ccost+1,nvec));\n\t      }\n\t    }\n\t  }\n\t}\n      }\n    }\n    if(ans==21)cout<<\"NA\"<<endl;\n    else cout<<ans<<endl;\n  }\n}"
  },
  {
    "language": "C++",
    "code": "#include<iostream>\n#include<vector>\n#include<queue>\n#include<map>\n#include<cmath>\n#include<cstdlib>\n#include<algorithm>\nusing namespace std;\n\nstring ans = \"xxoxxxabcxdefghxijkxxxoxx\";\n\nclass board{\npublic:\n  int h,c;\n  string s;\n  board(int x,int y,string z){ h=x; c=y; s=z;}\n  const bool operator<(const board x)const{return h+c>x.h+x.c; }\n};\n\nint score(string s){\n  int res=0,m;\n  for(int i=0;i<25;i++){\n    if(s[i]!='x' && s[i]!='o'){\n      for(int j=0;j<25;j++){\n\tif(s[i]==ans[j]){\n\t  m = abs(i/5-j/5) + abs(i%5-j%5);\n\t  break;\n\t}\n      }\n      res += m;\n    }\n  }\n  return res;\n}\n\nchar trans(int x){\n  if(!x)return 'o';\n  else return 'a'+x-1;\n}\n\nint main(){\n  string s = \"xxxxxxxxxxxxxxxxxxxxxxxxx\";\n  int tmp,cost;\n\n  for(;;){\n    cin >> tmp;\n    if(tmp<0)break;\n\n    s[2] = trans(tmp);\n    for(int i=0;i<3;i++){\n      cin >> tmp;\n      s[6+i] = trans(tmp);\n    }\n    for(int i=0;i<5;i++){\n      cin >> tmp;\n      s[10+i] = trans(tmp);\n    }\n    for(int i=0;i<3;i++){\n      cin >> tmp;\n      s[16+i] = trans(tmp);\n    }\n    cin >> tmp;\n    s[22] = trans(tmp);\n\n    priority_queue<board> q;\n    q.push(board(score(s),0,s));\n\n    //map<string,bool> m;\n    //m[s] = true;\n    while(q.size()){\n      board p = q.top();q.pop();\n      int dx[] = {-5,1,5,-1};\n\n      cost = p.c;\n      if(p.s == ans)break;\n      if(p.h+cost>20){\n\tcost = 21;\n\tbreak;\n      }\n\n      //m[p.s] = true;\n      for(int i=0;i<25;i++){\n\tif(p.s[i]=='o'){\n\t  for(int j=0;j<4;j++){\n\t    int sx = i + dx[j];\n\t    string str = p.s;\n\t    if(sx<0 || 25<=sx)continue;\n\t    if(str[sx] == 'x' || str[sx] == 'o')continue;\n\t    swap(str[i],str[sx]);\n\t    /*if(!m[str])*/q.push(board(score(str),cost+1,str));\n\t  }\n\t}\n      }\n    }\n\n    if(cost>20)cout << \"NA\\n\";\n    else cout << cost << endl;\n  }\n}"
  },
  {
    "language": "C++",
    "code": "#include<iostream>\n#include<vector>\n#include<queue>\n#include<map>\n#include<cmath>\n#include<cstdlib>\n#include<algorithm>\nusing namespace std;\n\nstring ans;\n\nclass board{\npublic:\n  int h,c;\n  string s;\n  board(int x,int y,string z){ h=x; c=y; s=z;}\n  const bool operator<(const board x)const{return h+c>x.h+x.c; }\n};\n\nint score(string s){\n  int res=0,m;\n  for(int i=0;i<25;i++){\n    if(s[i]!='x' && s[i]!='o'){\n      for(int j=0;j<25;j++){\n\tif(s[i]==ans[j]){\n\t  int a = abs(i-j);\n\t  int tmp = a/5 + a%5;\n\t  m = tmp;\n\t  break;\n\t}\n      }\n      res += m;\n    }\n  }\n  return res;\n}\n\nchar trans(int x){\n  if(!x)return 'o';\n  else return 'a'+x-1;\n}\n\nint main(){\n  string s;\n  ans = \"xxoxxxabcxdefghxijkxxxoxx\";\n  int tmp,cost;\n\n  for(;;){\n    cin >> tmp;\n    if(tmp<0)break;\n\n    s = \"xx\";\n    s += trans(tmp);\n    s += \"xxx\";\n    for(int i=0;i<3;i++){\n      cin >> tmp;\n      s += trans(tmp);\n    }\n    s += \"x\";\n    for(int i=0;i<5;i++){\n      cin >> tmp;\n      s += trans(tmp);\n    }\n    s += \"x\";\n    for(int i=0;i<3;i++){\n      cin >> tmp;\n      s+= trans(tmp);\n    }\n    s += \"xxx\";\n    cin >> tmp;\n    s += trans(tmp);\n    s += \"xx\";\n\n    priority_queue<board> q;\n    q.push(board(score(s),0,s));\n\n    map<string,bool> m;\n    m[s] = 0;\n    while(q.size()){\n      board p = q.top();q.pop();\n      int dx[] = {-5,1,5,-1};\n      //cout << p.h << \" \" << p.c << \" \" << p.s << endl;\n      cost = p.c;\n      if(p.s == ans)break;\n      if(p.h+cost>20){\n\tcost = 21;\n\tbreak;\n      }\n      m[p.s] = true;\n      for(int i=0;i<25;i++){\n\tif(p.s[i]=='o'){\n\t  for(int j=0;j<4;j++){\n\t    int sx = i + dx[j];\n\t    string str = p.s;\n\t    if(sx<0 || 25<=sx)continue;\n\t    if(str[sx] == 'x' || str[sx] == 'o')continue;\n\t    swap(str[i],str[sx]);\n\t    if(!m[str])q.push(board(score(str),cost+1,str));\n\t  }\n\t}\n      }\n    }\n\n\n\n    if(cost>20)cout << \"NA\\n\";\n    else cout << cost << endl;\n  }\n}"
  },
  {
    "language": "C++",
    "code": "#include<iostream>\n#include<algorithm>\n#include<iomanip>\n\n#define N 7\n#define INV (-1)\n\n#define UP 0\n#define RIGHT 1\n#define DOWN 2\n#define LEFT 3\n#define DIRMAX 4\n\n#define NA 20\n\nusing namespace std;\n\nstruct State\n{\n  int map[N][N];\n  State(){\n    //fill(&map[0][0],&map[N-1][N-1],-1);\n  }\n  State(int tmap[][N]){\n    for(int i = 0; i < N; ++i){\n      for(int j = 0; j < N; ++j){\n\tmap[i][j] = tmap[i][j];\n      }\n    }\n  }\n  bool move(int which, int dir){\n    // which = 0, upper,left\n    // which != 0, bottom,right\n    for(int i = (which==0?0:N-2); which==0?(i<N-1):(i>=1); which==0?++i:--i){\n      for(int j = (which==0?0:N-2); which==0?(j<N-1):(j>=1); which==0?++j:--j){\n\tif( map[i][j] == 0 ){\n\t  switch(dir){\n\t  case UP:   if( map[i-1][j] > 0 ){swap( map[i][j], map[i-1][j] );return true;}break;\n\t  case RIGHT:if( map[i][j+1] > 0 ){swap( map[i][j], map[i][j+1] );return true;}break;\n\t  case DOWN: if( map[i+1][j] > 0 ){swap( map[i][j], map[i+1][j] );return true;}break;\n\t  case LEFT: if( map[i][j-1] > 0 ){swap( map[i][j], map[i][j-1] );return true;}break;\n\t  }\n\t  return false;\n\t}\n      }\n    }\n  }\n  int getHeuristic()const{\n    const int ti[] = {0,2,2,2,3,3,3,3,3,4,4,4};\n    const int tj[] = {0,2,3,4,1,2,3,4,5,2,3,4};\n    int ret = 0;\n    for(int i = 1; i < N-1; ++i){\n      for(int j = 1; j < N-1; ++j){\n\tif( map[i][j] > 0 ){\n\t  int x = abs(i-ti[map[i][j]] )+ abs(j-tj[map[i][j]]);\n\t  ret += x;//max( ret, x );\n\t}\n      }\n    }\n    return ret;\n  }\n  bool isComplete()const{\n    return getHeuristic() == 0;\n  }\n};\n\nint IterativeDeepning(int depth, const State &now, int &ans)\n{\n\n  if( now.isComplete() ){\n    ans = min( ans , depth );\n    return ans;\n  }\n  int least = depth+now.getHeuristic();\n  if( least >= ans ){\n    return NA;\n  }\n  // ans = min( ans, least );\n  for(int w = 0; w < 2; ++w){\n    for(int dir = 0; dir < DIRMAX; ++dir){\n      State next = now;\n      if( next.move( w, dir ) ){\n\tans = min( ans, IterativeDeepning( depth + 1, next, ans ) );\n      }\n    }\n  }\n  return NA;\n}\n\nint main()\n{\n  while(true){\n    int map[N][N];\n    int ans;\n    fill(&map[0][0],&map[N-1][N],-1);\n    \n    const int imax[] = {1,3,5,3,1};\n    const int dj[] = {2,1,0,1,2};\n    for(int i = 0; i < 5; ++i){\n      for(int j = 0; j < imax[i]; ++j){\n\tint t;\n\tcin >> t;\n\tif( t < 0 ) return 0;\n\tmap[i+1][j+dj[i]+1]=t;\n      }\n    }\n\n    /*\n    for(int i = 0; i < N; ++i){\n      for(int j = 0; j < N; ++j){\n\tcout << setw(3) << map[i][j] << ' ';\n      }\n      cout << endl;\n    }\n    cout << endl;\n    */\n\n    ans = NA;\n    IterativeDeepning( 0, State(map), ans );\n    if( ans >= NA ){\n      cout << \"NA\" << endl;\n    }else{\n      cout << ans << endl;\n    }\n      \n  }\n  return 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include <cstdio>\n#include <cstdlib>\n#include <cmath>\n#include <climits>\n#include <cfloat>\n#include <map>\n#include <utility>\n#include <set>\n#include <iostream>\n#include <memory>\n#include <string>\n#include <vector>\n#include <algorithm>\n#include <functional>\n#include <sstream>\n#include <complex>\n#include <stack>\n#include <queue>\n#include <cstring>\n#include <sstream>\n#include <cassert>\n#include <list>\nusing namespace std;\nstatic const double EPS = 1e-10;\ntypedef long long ll;\ntypedef pair<int,int> PI;\ntypedef vector<int> vi;\n#ifndef M_PI\n#define M_PI 3.14159265358979323846\n#endif\n#define rep(i,n) for(int i=0;i<(int)n;++i)\n#define FOR(i,c) for(__typeof((c).begin())i=(c).begin();i!=(c).end();++i)\n#define ALL(c) (c).begin(), (c).end()\n#define mp(a,b) make_pair(a,b)\n#define pb(a) push_back(a)\n#define F first\n#define S second\ntemplate <typename T> string print_array(const vector<T> &V) { ostringstream os; os << \"{ \"; for (typename vector<T>::const_iterator iter = V.begin(); iter != V.end(); ++iter) os << '\\\"' << *iter << \"\\\",\"; os << \" }\"; return os.str(); }\n\nint dx[]={0,1,0,-1},dy[]={1,0,-1,0};\n\nvector<int> se[13];\nint x[]={0,-1,0,1,-2,-1,0,1,2,-1,0,1,0};\nint y[]={2,1,1,1,0,0,0,0,0,-1,-1,-1,-2};\n\nvoid pr(ll in){\n\n  printf(\"      %3lld\\n\",in&15);\n  printf(\"   %3lld%3lld%3lld\\n\",(in>>4)&15,(in>>8)&15,(in>>12)&15);\n  printf(\"%3lld%3lld%3lld%3lld%3lld\\n\",(in>>16)&15,(in>>20)&15,(in>>24)&15,(in>>28)&15,(in>>32)&15);\n  printf(\"   %3lld%3lld%3lld\\n\",(in>>36)&15,(in>>40)&15,(in>>44)&15);\n  printf(\"      %3lld\\n\",(in>>48)&15);\n  puts(\"\");\n}\n\nint manh(ll in){\n  int ret=0;\n  rep(i,13){\n    int t=(in>>(i*4))&15;\n\n    if(!t){\n      int nx=x[t]-x[i],ny=y[t]-y[i];\n      int co=abs(nx)+abs(ny);\n      nx=x[12]-x[i],ny=y[12]-y[i];\n      int k=abs(nx)+abs(ny);\n      ret+=min(co,k);\n      continue;\n    }\n    int nx=(x[t]-x[i]),ny=y[t]-y[i];\n    ret+=abs(nx)+abs(ny);\n  }\n  return ret;\n}\n\nmain(){\n  ll p;\n\n  ll goal=0;\n  rep(i,11){\n    goal|=(i+1LL)<<(4*(i+1));\n    //cout<<goal<<endl;\n    //pr(goal);\n  }\n  //pr(goal);\n\n  se[0].pb(2);\n  se[1].pb(2);\n  se[1].pb(5);\n  se[2].pb(0);\n  se[2].pb(1);\n  se[2].pb(3);\n  se[2].pb(6);\n  se[3].pb(2);\n  se[3].pb(7);\n  se[4].pb(5);\n  se[5].pb(1);\n  se[5].pb(4);\n  se[5].pb(6);\n  se[5].pb(9);\n  se[6].pb(2);\n  se[6].pb(5);\n  se[6].pb(7);\n  se[6].pb(10);\n  se[7].pb(3);\n  se[7].pb(6);\n  se[7].pb(8);\n  se[7].pb(11);\n  se[8].pb(7);\n  se[9].pb(5);\n  se[9].pb(10);\n  se[10].pb(6);\n  se[10].pb(9);\n  se[10].pb(11);\n  se[10].pb(12);\n  se[11].pb(7);\n  se[11].pb(10);\n  se[12].pb(10);\n  \n  while(cin>>p){\n    if(p==-1)break;\n    ll in=p;\n\n    rep(i,12){\n      cin>>p;\n      in|=p<<(4*(i+1));\n    }\n\n    set<ll> app;\n\n    queue<pair<int,ll> > Q;\n    app.insert(in);\n    Q.push(mp(0,in));\n    int ans=21;\n    int mans=0;\n\n    while(!Q.empty()){\n      ll cvec=Q.front().S;\n      int ccost=Q.front().F;\n      Q.pop();\n    \n      //pr(cvec);\n\n      //if(ccost>3)break;\n      if(ccost+manh(cvec)>29)continue;\n      if(cvec==goal){\n\tans=ccost;\n\tbreak;\n      }\n      rep(i,13){\n\tll t=cvec>>(i<<2);\n\tt=t&15;\n\tif(!t){\n\t  rep(j,se[i].size()){\n\t    t=cvec>>(se[i][j]<<2);\n\t    t=t&15;\n\t    if(t){\n\t      ll nvec=cvec;\n\t      t=t<<(i<<2);\n\t      nvec|=t;\n\t      nvec&=~(15LL<<se[i][j]*4);\n\t      \n\t      if(!app.count(nvec)){\n\t\tapp.insert(nvec);\n\t\tQ.push(mp(ccost+1,nvec));\n\t      }\n\t    }\n\t  }\n\t}\n      }\n    }\n    if(ans==21)cout<<\"NA\"<<endl;\n    else cout<<ans<<endl;\n  }\n}"
  },
  {
    "language": "C++",
    "code": "#include <iostream>\n#include <queue>\n#include <set>\nusing namespace std;\ntypedef long long ll;\n\nll mov[13][4] = {\n\t{2,-1,-1,-1},\n\t{2,5,-1,-1},\n\t{0,1,3,6},\n\t{2,7,-1,-1},\n\t{5,-1,-1,-1},\n\t{1,4,6,9},\n\t{2,5,7,10},\n\t{3,6,8,11},\n\t{7,-1,-1,-1},\n\t{5,10,-1,-1},\n\t{6,9,11,12},\n\t{7,10,-1,-1},\n\t{10,-1,-1,-1},\n};\n\nll sw(ll l, int i, int j) {\n\tint a, b;\n\ta = (l >> (4 * i)) & 0xfL;\n\tb = (l >> (4 * j)) & 0xfL;\n\n\tl &= ~(0xfL << (4*i));\n\tl &= ~(0xfL << (4*j));\n\n\tl |= (ll)b << (4 * i);\n\tl |= (ll)a << (4 * j);\n\n\treturn l;\n}\n\nint main() {\n\twhile(1) {\n\t\tll in = 0;\n\t\tfor(int i = 0; i < 13; i++) {\n\t\t\tint tmpin;\n\t\t\tcin >> tmpin;\n\t\t\tif(tmpin < 0)\n\t\t\t\treturn 0;\n\t\t\tin |= ((ll)tmpin << (4*i));\n\t\t}\n\n\t\tqueue<ll> q;\n\t\tset<ll> s;\n\t\tq.push(in);\n\t\ts.insert(in);\n\t\tint ans = -1;\n\t\t// debug\n\t\tint failcount = 0;\n\t\tfor(int i = 0; i <= 20; i++) {\n\t\t\tqueue<ll> next;\n\t\t\twhile(!q.empty()) {\n\t\t\t\tll l = q.front(); q.pop();\n\t\t\t\tif(l == 0xba9876543210) {\n\t\t\t\t\tans = i;\n\t\t\t\t\tgoto OUTPUT_ANSWER;\n\t\t\t\t}\n\t\t\t\telse {\n\t\t\t\t\tint cnt = 0;\n\t\t\t\t\tfor(int j = 0; j < 13; j++) {\n\t\t\t\t\t\tll t = 0xba9876543210;\n\t\t\t\t\t\tif(((l >> 4*j) & 0xfL) != ((t >> 4*j) & 0xfL)) {\n\t\t\t\t\t\t\tcnt++;\n\t\t\t\t\t\t}\n\t\t\t\t\t}\n\t\t\t\t\tif(cnt > 20 - i + 3)\n\t\t\t\t\t\tcontinue;\n\t\t\t\t}\n\n\t\t\t\tfor(int j = 0; j < 13; j++) {\n\t\t\t\t\tif(((l >> (4*j)) & 0xfL) == 0) {\n\t\t\t\t\t\tfor(int k = 0; k < 4; k++) {\n\t\t\t\t\t\t\tll p;\n\t\t\t\t\t\t\tif(mov[j][k] < 0)\n\t\t\t\t\t\t\t\tbreak;\n\t\t\t\t\t\t\tp = sw(l, j, mov[j][k]);\n\t\t\t\t\t\t\tif(s.find(p) == s.end()) {\n\t\t\t\t\t\t\t\ts.insert(p);\n\t\t\t\t\t\t\t\tnext.push(p);\n\t\t\t\t\t\t\t}\n\t\t\t\t\t\t\telse {\n\t\t\t\t\t\t\t\tfailcount++;\n\t\t\t\t\t\t\t}\n\t\t\t\t\t\t}\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t}\n\t\t\tq = next;\n\t\t}\n\nOUTPUT_ANSWER:;\n\t\tif(ans < 0)\n\t\t\tcout << \"NA\" << endl;\n\t\telse\n\t\t\tcout << ans << endl;\n//\t\tcout << failcount << endl;\n\t}\n}"
  },
  {
    "language": "C++",
    "code": "#include <iostream>\n#include <cstdio>\n#include <queue>\n#include <set>\n#include <cmath>\nusing namespace std;\ntypedef unsigned long long ull;\null B = 1000000007ull;\nint a[5]={2,1,0,1,2};\nint b[5]={2,3,4,3,2};\nint dx[5]={0,1,0,-1};\nint dy[5]={1,0,-1,0};\nint px[12]={0,1,1,1,2,2,2,2,2,3,3,3};\nint py[12]={0,1,2,3,0,1,2,3,4,0,1,2};\n\nstruct State\n{\n\tint f[5][5];\n\tint t;\n};\null hash(State x)\n{\n\tull t = 1ull;\n\tull res = 0;\n\tfor(int i=0;i<5;i++)\n\t{\n\t\tfor(int j=a[i];j<=b[i];j++)\n\t\t{\n\t\t\tres += x.f[i][j]*t;\n\t\t\tt *= B;\n\t\t}\n\t}\n\treturn res;\n}\nset<ull> s;\nbool check(State x)\n{\n\tint cnt = 1;\n\tfor(int i=1;i<=3;i++)\n\t{\n\t\tfor(int j=a[i];j<=b[i];j++)\n\t\t{\n\t\t\tif(x.f[i][j]!=cnt)return false;\n\t\t\tcnt++;\n\t\t}\n\t}\n\treturn true;\n}\nbool cc(State x)\n{\n\tint res = 0;\n\tfor(int i=0;i<5;i++)\n\t{\n\t\tfor(int j=a[i];j<=b[i];j++)\n\t\t{\n\t\t\tif(x.f[i][j])\n\t\t\t{\n\t\t\t\tint k = x.f[i][j];\n\t\t\t\tres += (abs(px[k]-i)+abs(py[k]-j));\n\t\t\t}\n\t\t}\n\t}\n\treturn (res>20);\n}\nint bfs(State st)\n{\n\tif(check(st))return 0;\n\tqueue<State> q;\n\tq.push(st);\n\twhile(!q.empty())\n\t{\n\t\tState A = q.front();\n\t\tq.pop();\n\t\tif(A.t>20)return 21;\n\t\tfor(int i=0;i<5;i++)\n\t\t{\n\t\t\tfor(int j=0;j<5;j++)\n\t\t\t{\n\t\t\t\tif(j<a[i]||b[i]<j)continue;\n\t\t\t\tif(A.f[i][j]==0)continue;\n\t\t\t\tfor(int k=0;k<4;k++)\n\t\t\t\t{\n\t\t\t\t\tint nx=i+dx[k],ny=j+dy[k];\n\t\t\t\t\tif(nx<0||nx>=5||ny<0||ny>=5)continue;\n\t\t\t\t\tif(ny<a[nx]||b[nx]<ny)continue;\n\t\t\t\t\tif(A.f[nx][ny]!=0)continue;\n\t\t\t\t\tState B = A;\n\t\t\t\t\tswap(B.f[nx][ny],B.f[i][j]);\n\t\t\t\t\tB.t++;\n\t\t\t\t\tif(cc(B))continue;\n\t\t\t\t\tull p = hash(B);\n\t\t\t\t\tif(s.find(p)!=s.end())continue;\n\t\t\t\t\ts.insert(p);\n\t\t\t\t\tif(check(B))return B.t;\n\t\t\t\t\tq.push(B);\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t}\n\treturn 21;\n}\nint main()\n{\n\twhile(1)\n\t{\n\t\tState st;\n\t\ts.clear();\n\t\tfor(int i=0;i<5;i++)for(int j=0;j<5;j++)st.f[i][j]=-1;\n\t\tfor(int i=0;i<5;i++)\n\t\t{\n\t\t\tfor(int j=a[i];j<=b[i];j++)\n\t\t\t{\n\t\t\t\tcin >> st.f[i][j];\n\t\t\t\tif(st.f[i][j]==-1)goto end;\n\t\t\t}\n\t\t}\n\t\tst.t=0;\n\t\tint ans = bfs(st);\n\t\tif(ans>20)printf(\"NA\\n\");\n\t\telse printf(\"%d\\n\",ans);\n\t}\n\tend:;\n\treturn 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include <iostream>\n#include <set>\n#include <queue>\n#include <map>\n\nusing namespace std;\n\nclass State{\npublic:\n   string s;\n   int cost;\n};\n\nint input;\nset<string> visited;\nmap<string, int> memo;\nint distx[] = {};\nint disty[] = {};\n\nvoid swap(string &str, int a, int b){\n   char tmp = str[a];\n   str[a] = str[b];\n   str[b] = tmp;\n}\n\nvoid pre_bfs(){\n   State u, v;\n   u.s = \"ABCDEFGHIJKLA\";\n   u.cost = 0;\n   memo[u.s] = u.cost;\n   queue<State>Q;\n   Q.push(u);\n   while(!Q.empty()){\n      u = Q.front(); Q.pop();\n      if(u.cost >= 10) continue;\n      for(int i=0;i<13;i++){\n         if(u.s[i] == 'A'){\n            v.cost = u.cost + 1;\n            switch(i){\n               case 0:\n                  v.s = u.s;\n                  swap(v.s, 0, 2);\n                  if(memo.find(v.s) == memo.end()){\n                     memo[v.s] = v.cost;\n                     Q.push(v);\n                  }\n                  break;\n               case 1:\n                  v.s = u.s;\n                  swap(v.s, i, 2);\n                  if(memo.find(v.s) == memo.end()){\n                     memo[v.s] = v.cost;\n                     Q.push(v);\n                  }\n                  v.s = u.s;\n                  swap(v.s, i, 5);\n                  if(memo.find(v.s) == memo.end()){\n                     memo[v.s] = v.cost;\n                     Q.push(v);\n                  }\n                  break;\n               case 3:\n                  v.s = u.s;\n                  swap(v.s, i, 2);\n                  if(memo.find(v.s) == memo.end()){\n                     memo[v.s] = v.cost;\n                     Q.push(v);\n                  }\n                  v.s = u.s;\n                  swap(v.s, i, 7);\n                  if(memo.find(v.s) == memo.end()){\n                     memo[v.s] = v.cost;\n                     Q.push(v);\n                  }\n                  break;\n               case 4:\n                  v.s = u.s;\n                  swap(v.s, i, 5);\n                  if(memo.find(v.s) == memo.end()){\n                     memo[v.s] = v.cost;\n                     Q.push(v);\n                  }\n                  break;\n               case 8:\n                  v.s = u.s;\n                  swap(v.s, i, 7);\n                  if(memo.find(v.s) == memo.end()){\n                     memo[v.s] = v.cost;\n                     Q.push(v);\n                  }\n                  break;\n               case 9:\n                  v.s = u.s;\n                  swap(v.s, i, 5);\n                  if(memo.find(v.s) == memo.end()){\n                     memo[v.s] = v.cost;\n                     Q.push(v);\n                  }\n                  v.s = u.s;\n                  swap(v.s, i, 10);\n                  if(memo.find(v.s) == memo.end()){\n                     memo[v.s] = v.cost;\n                     Q.push(v);\n                  }\n\n                  break;\n               case 11:\n                  v.s = u.s;\n                  swap(v.s, i, 7);\n                  if(memo.find(v.s) == memo.end()){\n                     memo[v.s] = v.cost;\n                     Q.push(v);\n                  }\n                  v.s = u.s;\n                  swap(v.s, i, 10);\n                  if(memo.find(v.s) == memo.end()){\n                     memo[v.s] = v.cost;\n                     Q.push(v);\n                  }\n                  break;\n               case 12:\n                  v.s = u.s;\n                  swap(v.s, i, 10);\n                  if(memo.find(v.s) == memo.end()){\n                     memo[v.s] = v.cost;\n                     Q.push(v);\n                  }\n                  break;\n               default:\n                  int ue = 4;\n                  int sita = 4;\n                  if(i == 2) ue = 2;\n                  if(i == 10) sita = 2;\n                  v.s = u.s;\n                  swap(v.s, i, i-ue);\n                  if(memo.find(v.s) == memo.end()){\n                     memo[v.s] = v.cost;\n                     Q.push(v);\n                  }\n                  v.s = u.s;\n                  swap(v.s, i, i+sita);\n                  if(memo.find(v.s) == memo.end()){\n                     memo[v.s] = v.cost;\n                     Q.push(v);\n                  }\n                  v.s = u.s;\n                  swap(v.s, i, i+1);\n                  if(memo.find(v.s) == memo.end()){\n                     memo[v.s] = v.cost;\n                     Q.push(v);\n                  }\n                  v.s = u.s;\n                  swap(v.s, i, i-1);\n                  if(memo.find(v.s) == memo.end()){\n                     memo[v.s] = v.cost;\n                     Q.push(v);\n                  }\n                  break;\n            }\n         }\n      }\n   }\n}\n\nint bfs(string str){\n   State u, v;\n   u.s = str;\n   u.cost = 0;\n   queue<State> Q;\n   Q.push(u);\n   while(!Q.empty()){\n      u = Q.front(); Q.pop();\n      if(memo.find(u.s) != memo.end()){\n         return u.cost + memo[u.s];\n      }\n      if(u.cost >= 10) continue;\n      for(int i=0;i<13;i++){\n         if(u.s[i] == 'A'){\n            v.cost = u.cost + 1;\n            switch(i){\n               case 0:\n                  v.s = u.s;\n                  swap(v.s, 0, 2);\n                  if(visited.find(v.s) == visited.end()){\n                     visited.insert(v.s);\n                     Q.push(v);\n                  }\n                  break;\n               case 1:\n                  v.s = u.s;\n                  swap(v.s, i, 2);\n                  if(visited.find(v.s) == visited.end()){\n                     visited.insert(v.s);\n                     Q.push(v);\n                  }\n                  v.s = u.s;\n                  swap(v.s, i, 5);\n                  if(visited.find(v.s) == visited.end()){\n                     visited.insert(v.s);\n                     Q.push(v);\n                  }\n                  break;\n               case 3:\n                  v.s = u.s;\n                  swap(v.s, i, 2);\n                  if(visited.find(v.s) == visited.end()){\n                     visited.insert(v.s);\n                     Q.push(v);\n                  }\n                  v.s = u.s;\n                  swap(v.s, i, 7);\n                  if(visited.find(v.s) == visited.end()){\n                     visited.insert(v.s);\n                     Q.push(v);\n                  }\n                  break;\n               case 4:\n                  v.s = u.s;\n                  swap(v.s, i, 5);\n                  if(visited.find(v.s) == visited.end()){\n                     visited.insert(v.s);\n                     Q.push(v);\n                  }\n                  break;\n               case 8:\n                  v.s = u.s;\n                  swap(v.s, i, 7);\n                  if(visited.find(v.s) == visited.end()){\n                     visited.insert(v.s);\n                     Q.push(v);\n                  }\n                  break;\n               case 9:\n                  v.s = u.s;\n                  swap(v.s, i, 5);\n                  if(visited.find(v.s) == visited.end()){\n                     visited.insert(v.s);\n                     Q.push(v);\n                  }\n                  v.s = u.s;\n                  swap(v.s, i, 10);\n                  if(visited.find(v.s) == visited.end()){\n                     visited.insert(v.s);\n                     Q.push(v);\n                  }\n\n                  break;\n               case 11:\n                  v.s = u.s;\n                  swap(v.s, i, 7);\n                  if(visited.find(v.s) == visited.end()){\n                     visited.insert(v.s);\n                     Q.push(v);\n                  }\n                  v.s = u.s;\n                  swap(v.s, i, 10);\n                  if(visited.find(v.s) == visited.end()){\n                     visited.insert(v.s);\n                     Q.push(v);\n                  }\n                  break;\n               case 12:\n                  v.s = u.s;\n                  swap(v.s, i, 10);\n                  if(visited.find(v.s) == visited.end()){\n                     visited.insert(v.s);\n                     Q.push(v);\n                  }\n                  break;\n               default:\n                  int ue = 4;\n                  int sita = 4;\n                  if(i == 2) ue = 2;\n                  if(i == 10) sita = 2;\n                  v.s = u.s;\n                  swap(v.s, i, i-ue);\n                  if(visited.find(v.s) == visited.end()){\n                     visited.insert(v.s);\n                     Q.push(v);\n                  }\n                  v.s = u.s;\n                  swap(v.s, i, i+sita);\n                  if(visited.find(v.s) == visited.end()){\n                     visited.insert(v.s);\n                     Q.push(v);\n                  }\n                  v.s = u.s;\n                  swap(v.s, i, i+1);\n                  if(visited.find(v.s) == visited.end()){\n                     visited.insert(v.s);\n                     Q.push(v);\n                  }\n                  v.s = u.s;\n                  swap(v.s, i, i-1);\n                  if(visited.find(v.s) == visited.end()){\n                     visited.insert(v.s);\n                     Q.push(v);\n                  }\n                  break;\n            }\n         }\n      }\n   }\n   return -1;\n}\n\nmain(){\n   pre_bfs();\n   while(cin >> input){\n      if(input == -1) break;\n      string str = \"\";\n      str += ((char)input + 'A');\n      for(int i=1;i<13;i++){\n         cin >> input;\n         str += ((char)input + 'A');\n      }\n      int ans = bfs(str);\n      if(ans == -1) cout << \"NA\" << endl;\n      else{\n         cout << ans << endl;\n      }\n   }\n   return 0;\n\n}"
  },
  {
    "language": "C++",
    "code": "#include<map>\n#include<queue>\n#include<cstdio>\n#include<vector>\n\n#define\tpb\tpush_back\n\nusing namespace std;\n\ntypedef\tvector<int>\tvi;\n\nvi mv[13];\nlong long pow12[13];\n\nvoid findEmptyPos(long long stat,int *z){\n\tfor(int i=0,j=0;i<13;i++){\n\t\tif(stat%12==0)\tz[j++]=12-i;\n\t\tstat/=12;\n\t}\n}\n\nlong long sw(long long stat,int i,int j){\n\tlong long powi=pow12[12-i],powj=pow12[12-j];\n\tint pi=(stat/powi)%12,pj=(stat/powj)%12;\n\treturn stat+(pj-pi)*powi+(pi-pj)*powj;\n}\n\nvoid bfs(map<long long,int> &f,long long inistat,int stop){\n\tf[inistat]=0;\n\tqueue<long long> qu;\tqu.push(inistat);\n\twhile(!qu.empty()){\n\t\tlong long stat=qu.front();\tqu.pop();\n\t\tint cnt=f[stat];\n\t\tif(cnt==stop)\tbreak;\n\n\t\tint z[2];\tfindEmptyPos(stat,z);\n\t\tfor(int i=0;i<2;i++){\n\t\t\tfor(int j=0;j<mv[z[i]].size();j++){\n\t\t\t\tlong long nextstat=sw(stat,z[i],mv[z[i]][j]);\n\t\t\t\tif(f.count(nextstat)==0){\n\t\t\t\t\tqu.push(nextstat);\n\t\t\t\t\tf[nextstat]=cnt+1;\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t}\n}\n\nint main(){\n\tlong long a=1;\n\tfor(int i=0;i<13;i++)\tpow12[i]=a,a*=12;\n\n\tmv[0].pb(2);\n\tmv[1].pb(2);\tmv[1].pb(5);\n\tmv[2].pb(0);\tmv[2].pb(1);\tmv[2].pb(3);\tmv[2].pb(6);\n\tmv[3].pb(2);\tmv[3].pb(7);\n\tmv[4].pb(5);\n\tmv[5].pb(1);\tmv[5].pb(4);\tmv[5].pb(6);\tmv[5].pb(9);\n\tmv[6].pb(2);\tmv[6].pb(5);\tmv[6].pb(7);\tmv[6].pb(10);\n\tmv[7].pb(3);\tmv[7].pb(6);\tmv[7].pb(8);\tmv[7].pb(11);\n\tmv[8].pb(7);\n\tmv[9].pb(5);\tmv[9].pb(10);\n\tmv[10].pb(6);\tmv[10].pb(9);\tmv[10].pb(11);\tmv[10].pb(12);\n\tmv[11].pb(7);\tmv[11].pb(10);\n\tmv[12].pb(10);\n\n\tint ans[]={0,1,2,3,4,5,6,7,8,9,10,11,0};\n\tlong long ansstat=0;\n\tfor(int i=0;i<13;i++)\tansstat=ansstat*12+ans[i];\n\n\tmap<long long,int> f;\n\tbfs(f,ansstat,14);\n\n\tfor(long long inistat;scanf(\"%lld\",&inistat),~inistat;){\n\t\tfor(int i=1,p;i<13;i++)\tscanf(\"%d\",&p),inistat=inistat*12+p;\n\t\tmap<long long,int> g;\n\t\tbfs(g,inistat,6);\n\n\t\tint cmin=21;\n\t\tmap<long long,int>::iterator it;\n\t\tfor(it=g.begin();it!=g.end();it++){\n\t\t\tlong long stat=it->first;\n\t\t\tint cnt=it->second;\n\t\t\tif(f.count(stat))\tcmin=min(cmin,cnt+f[stat]);\n\t\t}\n\t\tif(cmin<=20)\tprintf(\"%d\\n\",cmin);\n\t\telse\tputs(\"NA\");\n\t}\n\n\treturn 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include <iostream>\n#include <algorithm>\n#include <vector>\n#include <cstring>\n#include <cstdio>\n#include <climits>\n\nusing namespace std;\n\n#define REP(i,a,n) for(int i=(a); i<(int)(n); i++)\n#define rep(i,n) REP(i,0,n)\n#define LIM 30\n#define DEB 0\n\n/*\n  1 = [2][2]\n  2 = [2][3]\n  3 = [2][4]\n  4 = [3][1]\n  5 = [3][2]\n  6 = [3][3]\n  7 = [3][4]\n  8 = [3][5]\n  9 = [4][2]\n  10= [4][3]\n  11= [4][4]\n*/\nint board[7][7]; //1base\nint ans;\nint sx[2], sy[2];\nstatic const int dx[] = {0,0,1,-1};\nstatic const int dy[] = {1,-1,0,0};\n\n/*\n(y,x)\n */\nint calc(int y, int x){\n    switch(board[y][x]){\n    case 1: return abs(2-y)+abs(2-x);\n    case 2: return abs(2-y)+abs(3-x);\n    case 3: return abs(2-y)+abs(4-x);\n    case 4: return abs(3-y)+abs(1-x);\n    case 5: return abs(3-y)+abs(2-x);\n    case 6: return abs(3-y)+abs(3-x);\n    case 7: return abs(3-y)+abs(4-x);\n    case 8: return abs(3-y)+abs(5-x);\n    case 9: return abs(4-y)+abs(2-x);\n    case 10: return abs(4-y)+abs(3-x);\n    case 11: return abs(4-y)+abs(4-x);\n    }\n    puts(\"eee\");\n    return -1;\n}\nint dist(void){\n    int ret = 0;\n    if( board[1][3] ) ret += calc(1,3);\n    rep(i,3) if( board[2][2+i] ) ret += calc(2,2+i);\n    rep(i,5) if( board[3][1+i] ) ret += calc(3,1+i);\n    rep(i,3) if( board[4][2+i] ) ret += calc(4,2+i);\n    if( board[5][3] ) ret += calc(5,3);\n    return ret;\n}\nbool isgoal(void){\n    if( board[1][3]!=0 ) return false;\n    rep(i,3) if( board[2][2+i]!=i+1 ) return false;\n    rep(i,5) if( board[3][1+i]!=i+4 ) return false;\n    rep(i,3) if( board[4][2+i]!=i+9 ) return false;\n    if( board[5][3]!=0 ) return false;\n    return true;\n}\n\nvoid dfs(int cnt, int py, int px){\n    if( ans<=cnt ) return;\n    if( isgoal() ){\n        ans = cnt;\n        return;\n    }\n    if( cnt+dist()>LIM ) return;\n#if DEB\n    //printf(\"cnt:%d  (%d,%d),(%d,%d)\\n\",cnt, sx[0], sy[0], sx[1], sy[1]);\n#endif\n    rep(i,2){\n        rep(k,4){\n            int tx = sx[i] + dx[k];\n            int ty = sy[i] + dy[k];\n            if( board[ty][tx]==-1 || ty==py&&tx==px ) continue;\n            swap(board[sy[i]][sx[i]], board[ty][tx]);\n            swap(sx[i], tx); swap(sy[i],ty);\n            dfs(cnt+1, ty, tx); // ツ個ウツづ個スツペツーツスツ暗環置\n            swap(sx[i], tx); swap(sy[i],ty);\n            swap(board[sy[i]][sx[i]] ,board[ty][tx]);\n        }\n    }\n}\n\nint main(){\n    for(;;){\n        memset(board, -1, sizeof(board));\n        ans = 21;\n        int sz = 0;\n\n        scanf(\"%d\",&board[1][3]); if( board[1][3]==-1 ) break;\n        rep(i,3) scanf(\"%d\",&board[2][2+i]);\n        rep(i,5) scanf(\"%d\",&board[3][1+i]);\n        rep(i,3) scanf(\"%d\",&board[4][2+i]);\n        scanf(\"%d\",&board[5][3]);\n\n        // find space\n        if( board[1][3]==0 ){ sx[sz]=3; sy[sz]=1; sz++; }\n        rep(i,3) if( board[2][2+i]==0 ) { sx[sz]=2+i; sy[sz]=2; sz++; }\n        rep(i,5) if( board[3][1+i]==0 ) { sx[sz]=1+i; sy[sz]=3; sz++; }\n        rep(i,3) if( board[4][2+i]==0 ) { sx[sz]=2+i; sy[sz]=4; sz++; }\n        if( board[5][3]==0 ){ sx[sz]=3; sy[sz]=5; sz++; }\n\n#if DEB\n        rep(i,7){\n            rep(j,7){\n                printf(\"%2d \",board[i][j]);\n            }\n            puts(\"\");\n        }\n        rep(i,2){\n            printf(\"(%d,%d),\",sx[i], sy[i]);\n        }puts(\"\");\n        printf(\"%d\\n\",dist());\n#endif\n        \n        dfs(0,-1,-1);\n        if( ans==21 ) puts(\"NA\"); else printf(\"%d\\n\",ans);\n    }\n    return 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include<iostream>\n#include<map>\n#include<deque>\n#include<cstdlib>\n#include<cstring>\nusing namespace std;struct B{int z[2];char s[14];bool operator<(const B&r)const{return strcmp(s,r.s)<0;}};int main(){int a[13][5]={{2,-1},{2,5,-1},{0,1,3,6,-1},{2,7,-1},{5,-1},{1,4,6,9,-1},{2,5,7,10,-1},{3,6,8,11,-1},{7,-1},{5,10,-1},{6,9,11,12,-1},{7,10,-1},{10,-1},},gx[]={2,1,2,3,0,1,2,3,4,1,2,3,2},gy[]={0,1,1,1,2,2,2,2,2,3,3,3,4},v,d,s,i,j;B g={0,0,\"0123456789:;0\"};for(;;){map<B,int>m;deque<B>q;B b={-1,-1};for(i=0;i<13;i++){cin>>v;if(v==-1)return 0;b.s[i]='0'+v;if(!v)b.z[b.z[0]!=-1]=i;}b.s[13]=0;m[b]=1;for(q.push_back(b);!q.empty();q.pop_front()){B&b=q.front();if(!strcmp(b.s,g.s))break;d=0;for(i=13;i--;){v=b.s[i]-'0';if(v)d+=abs(gx[v]-gx[i])+abs(gy[v]-gy[i]);}s=m[b];if(s+d<22)for(j=2;j--;)for(i=0;~a[b.z[j]][i];i++){B n=b;n.z[j]=a[b.z[j]][i];if(n.z[j]-n.z[1-j]){swap(n.s[b.z[j]],n.s[n.z[j]]);int&t=m[n];if(!t){t=s+1;q.push_back(n);}}}}m[g]?cout<<m[g]-1<<endl:cout<<\"NA\\n\";}}"
  },
  {
    "language": "C++",
    "code": "#include <cstdio>\n#include <cstring>\n#include <algorithm>\n#include <string>\n#include <cmath>\n#include <stack>\n#include <vector>\n#include <map>\n#include <set>\n#include <queue>\n#include <list>\n#include <iostream>\n#include <sstream>\n#include <climits>\n#include <cfloat>\n#include <complex>\n\nusing namespace std;\n\ntypedef long long ll;\n\nll encode(int* state)\n{\n\tll res = 0;\n\tfor (int i = 0; i < 13; ++i)\n\t\tres = res << 4 | state[i];\n\treturn res;\n}\nvoid decode(int* d, ll e)\n{\n\tfor (int i = 12; i >= 0; --i, e >>= 4)\n\t\td[i] = e & 15;\n}\nvoid p(ll s)\n{\n\tint d[13];\n\tdecode(d, s);\n\tfor (int i = 0; i < 13; ++i)\n\t\tprintf(\"%d \", d[i]);\n\tprintf(\"\\n\");\n}\n\nint main()\n{\n\tmap<ll, int> minSteps;\n\tint dir[] = { -1, 1, -2, 2, -4, 4 };\n\tmap<int, bool> ok[3];\n\n\tint o[][9] = {\n\t\t{ 1, 2, 4, 5, 6, 7, 9, 10, -1 },\n\t\t{ 0, 10, -1 },\n\t\t{ 1, 2, 3, 5, 6, 7, -1 }\n\t};\n\tfor (int i = 0; i < 3; ++i)\n\t\tfor (int j = 0; o[i][j] != -1; ++j)\n\t\t\tok[i][o[i][j]] = true;\n\n\tint initial[] = { 0, 1, 2, 3, 4, 5, 6, 7, 8, 9, 10, 11, 0 };\n\tll t = encode(initial);\n\tminSteps[t] = 0;\n\tqueue<ll> q;\n\tq.push(t);\n\n\twhile (!q.empty())\n\t{\n\t\tll e = q.front();\n\t\tq.pop();\n\t\tint d[13];\n\t\tdecode(d, e);\n\n\t\tint zero_pos[2];\n\t\tfor (int i = 0, j = 0; j < 2; ++i)\n\t\t\tif (!d[i])\n\t\t\t\tzero_pos[j++] = i;\n\n\t\tfor (int i = 0; i < 2; ++i)\n\t\t{\n\t\t\tfor (int j = 0; j < 6; ++j)\n\t\t\t{\n\t\t\t\tint a = zero_pos[i];\n\t\t\t\tint b = a + dir[j];\n\t\t\t\tif (a > b)\n\t\t\t\t\tswap(a, b);\n\t\t\t\tif (a < 0 || b > 12 || !d[a] && !d[b] || !ok[j/2][a])\n\t\t\t\t\tcontinue;\n\n\t\t\t\tint copy[13];\n\t\t\t\tmemcpy(copy, d, sizeof(copy));\n\t\t\t\tswap(copy[a], copy[b]);\n\t\t\t\tll next = encode(copy);\n\n\t\t\t\tif (!minSteps.count(next) && minSteps[e] < 10)\n\t\t\t\t{\n\t\t\t\t\tminSteps[next] = minSteps[e] + 1;\n\t\t\t\t\tq.push(next);\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t}\n\n\twhile (true)\n\t{\n\t\tint d[13];\n\t\tfor (int i = 0; i < 13; ++i)\n\t\t\tscanf(\"%d\", d + i);\n\t\tif (d[0] == -1)\n\t\t\tbreak;\n\n\t\tint ans = -1;\n\t\tll s = encode(d);\n\t\tif (minSteps.count(s))\n\t\t\tans = minSteps[s];\n\t\telse\n\t\t{\n\t\t\tmap<ll, int> c;\n\t\t\tc[s] = 0;\n\t\t\tq.push(s);\n\t\t\twhile (!q.empty())\n\t\t\t{\n\t\t\t\tll e = q.front();\n\t\t\t\tq.pop();\n\t\t\t\tint d[13];\n\t\t\t\tdecode(d, e);\n\n\t\t\t\tint zero_pos[2];\n\t\t\t\tfor (int i = 0, j = 0; j < 2; ++i)\n\t\t\t\t\tif (!d[i])\n\t\t\t\t\t\tzero_pos[j++] = i;\n\n\t\t\t\tfor (int i = 0; i < 2; ++i)\n\t\t\t\t{\n\t\t\t\t\tfor (int j = 0; j < 6; ++j)\n\t\t\t\t\t{\n\t\t\t\t\t\tint a = zero_pos[i];\n\t\t\t\t\t\tint b = a + dir[j];\n\t\t\t\t\t\tif (a > b)\n\t\t\t\t\t\t\tswap(a, b);\n\t\t\t\t\t\tif (a < 0 || b > 12 || !d[a] && !d[b] || !ok[j/2][a])\n\t\t\t\t\t\t\tcontinue;\n\n\t\t\t\t\t\tint copy[13];\n\t\t\t\t\t\tmemcpy(copy, d, sizeof(copy));\n\t\t\t\t\t\tswap(copy[a], copy[b]);\n\t\t\t\t\t\tll next = encode(copy);\n\n\t\t\t\t\t\tif (minSteps.count(next))\n\t\t\t\t\t\t{\n\t\t\t\t\t\t\tans = 10 + c[e] + 1;\n\t\t\t\t\t\t\tgoto End;\n\t\t\t\t\t\t}\n\t\t\t\t\t\tif (!c.count(next) && c[e] < 10)\n\t\t\t\t\t\t{\n\t\t\t\t\t\t\tc[next] = c[e] + 1;\n\t\t\t\t\t\t\tq.push(next);\n\t\t\t\t\t\t}\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t}\n\t\t}\nEnd:\n\t\tif (ans != -1)\n\t\t\tprintf(\"%d\\n\", ans);\n\t\telse\n\t\t\tputs(\"NA\");\n\t}\n\n\treturn 0;\n}"
  },
  {
    "language": "C++",
    "code": "#define _USE_MATH_DEFINES\n#define INF 10000000\n#include <iostream>\n#include <sstream>\n#include <cmath>\n#include <algorithm>\n#include <queue>\n#include <stack>\n#include <limits>\n#include <map>\n#include <string>\n#include <cstring>\n#include <set>\n#include <deque>\n#include <bitset>\n\nusing namespace std;\n\ntypedef long long ll;\ntypedef pair<int,string> P;\n\nstatic const double eps = 1e-8;\n\nstatic const int t[][2] = {{1,0},{0,1},{-1,0},{0,-1}};\nstatic const int s[][2] = {{0,2},{1,1},{1,2},{1,3},\n{2,0},{2,1},{2,2},{2,3},{2,4},{3,1},{3,2},{3,3},{4,2}};\n\nvoid bfsRoot(map<vector< vector<int> >,int>& cost,vector< vector<int> >& rv){\n\tcost[rv] = 0;\n\tqueue<vector< vector<int> > > que;\n\tque.push(rv);\n\n\twhile(!que.empty()){\n\t\tvector< vector<int> > now = que.front();\n\t\tque.pop();\n\n\t\tfor(int i=0;i<13;i++){\n\t\t\tint x = s[i][1];\n\t\t\tint y = s[i][0];\n\t\t\tif(now[y][x] != 0) continue;\n\n\t\t\tfor(int j=0;j<4;j++){\n\t\t\t\tint dx = x + t[j][0];\n\t\t\t\tint dy = y + t[j][1];\n\n\t\t\t\tif(dy < 0 || dy >= 5 || dx < 0 || dx >= 5) continue;\n\t\t\t\tif(now[dy][dx] == -1) continue;\n\t\t\t\tif(now[dy][dx] == 0) continue;\n\n\t\t\t\tvector< vector<int> > tmp = now;\n\t\t\t\tswap(tmp[y][x],tmp[dy][dx]);\n\n\t\t\t\tif(cost.find(tmp) != cost.end()) continue;\n\t\t\t\tcost[tmp] = cost[now] + 1;\n\t\t\t\tif(cost[tmp] >= 10) continue;\n\t\t\t\tque.push(tmp);\n\t\t\t}\n\t\t}\n\t}\n}\n\nint bfs(map<vector< vector<int> >,int>& cost,vector< vector<int> >& rv,\n\tmap<vector< vector<int> >,int>& costR){\n\tcost[rv] = 0;\n\tqueue<vector< vector<int> > > que;\n\tque.push(rv);\n\n\tif(costR.find(rv) != costR.end()) return costR[rv];\n\n\twhile(!que.empty()){\n\t\tvector< vector<int> > now = que.front();\n\t\tque.pop();\n\n\t\tfor(int i=0;i<13;i++){\n\t\t\tint x = s[i][1];\n\t\t\tint y = s[i][0];\n\t\t\tif(now[y][x] != 0) continue;\n\n\t\t\tfor(int j=0;j<4;j++){\n\t\t\t\tint dx = x + t[j][0];\n\t\t\t\tint dy = y + t[j][1];\n\n\t\t\t\tif(dy < 0 || dy >= 5 || dx < 0 || dx >= 5) continue;\n\t\t\t\tif(now[dy][dx] == -1) continue;\n\t\t\t\tif(now[dy][dx] == 0) continue;\n\n\t\t\t\tvector< vector<int> > tmp = now;\n\t\t\t\tswap(tmp[y][x],tmp[dy][dx]);\n\n\t\t\t\tif(cost.find(tmp) != cost.end()) continue;\n\n\t\t\t\tcost[tmp] = cost[now] + 1;\n\t\t\t\tif(costR.find(tmp) != costR.end()) return costR[tmp]; \n\n\t\t\t\tif(cost[tmp] >= 10) continue;\n\t\t\t\tque.push(tmp);\n\t\t\t}\n\t\t}\n\t}\n\n\treturn -1;\n}\n\nint main(){\n\tint table[5][5];\n\tint root[5][5];\n\tmemset(table,-1,sizeof(table));\n\tmemset(root,-1,sizeof(root));\n\troot[0][2] = 0;\n\troot[1][1]=1; root[1][2]=2; root[1][3]=3;\n\troot[2][0]=4; root[2][1]=5; root[2][2]=6; root[2][3]=7; root[2][4]=8;\n\troot[3][1]=9; root[3][2]=10; root[3][3]=11;\n\troot[4][2] = 0;\n\n\tvector< vector<int> > rv(5,vector<int>(5));\n\tmap<vector< vector<int> >,int> costR;\n\t\n\n\tfor(int y=0;y<5;y++){\n\t\tfor(int x=0;x<5;x++){\n\t\t\trv[y][x] = root[y][x];\n\t\t}\n\t}\n\tbfsRoot(costR,rv);\n\n\twhile(~scanf(\"%d\",&table[0][2])){\n\t\tif(table[0][2] == -1) break;\n\t\tscanf(\"%d %d %d\",&table[1][1],&table[1][2],&table[1][3]);\n\t\tscanf(\"%d %d %d %d %d\",&table[2][0],&table[2][1],&table[2][2],&table[2][3],&table[2][4]);\n\t\tscanf(\"%d %d %d\",&table[3][1],&table[3][2],&table[3][3]);\n\t\tscanf(\"%d\",&table[4][2]);\n\t\tvector< vector<int> > tv(5,vector<int>(5));\n\n\t\tfor(int y=0;y<5;y++){\n\t\t\tfor(int x=0;x<5;x++){\n\t\t\t\ttv[y][x] = table[y][x];\n\t\t\t}\n\t\t}\n\t\tmap<vector< vector<int> >,int> cost;\n\t\tint res = bfs(cost,tv,costR);\n\n\t\tif(res != -1) printf(\"%d\\n\",res);\n\t\telse printf(\"NA\\n\");\n\t}\n}"
  },
  {
    "language": "C++",
    "code": "#include <iostream>\n#include <cstdio>\n#include <cstring>\n#include <algorithm>\n#include <vector>\n#include <queue>\n#include <map>\nusing namespace std;\n\ntypedef vector<int> VI;\n\nint size[13] = {1, 2, 4, 2, 1, 4, 4, 4, 1, 2, 4, 2, 1};\nint move[13][4] = {\n  {2},\n  {2, 5},\n  {0, 1, 6, 3},\n  {2, 7},\n  {5},\n  {1, 4, 6, 9},\n  {2, 5, 7, 10},\n  {3, 6, 8, 11},\n  {7},\n  {5, 10},\n  {6, 9, 11, 12},\n  {7, 10},\n  {10}\n};\n\nVI v;\nmap<VI, int> mp;\nmap<VI, int> mp2;\n\nvoid make(){\n  VI goal;\n  for(int i = 0 ; i < 13 ; i++){\n    if(i == 0 || i == 12) goal.push_back(0);\n    else goal.push_back(i);    \n  }\n  \n  queue<VI> que;\n  que.push(goal);\n  mp2[goal] = 0;\n  \n  while(!que.empty()){\n    VI q = que.front(); que.pop();    \n    if(mp2[q] > 10) continue;\n    \n    for(int i = 0 ; i < 13 ; i++){\n      if(q[i] != 0) continue;\n      for(int j = 0 ; j < size[i] ; j++){\n\tVI t = q;\n\tswap(t[i], t[ move[i][j] ]);\n\tif(mp2.find(t) != mp2.end()) continue;\t\n\tmp2[t] = mp2[q] + 1;\t\n\tque.push(t);\n      }\n    }\n  }\n}\n    \n\n\nint bfs(){\n  queue<VI> que;\n  que.push(v);\n  mp[v] = 0;\n  \n  while(!que.empty()){\n    VI q = que.front(); que.pop();    \n\n    if(mp2.find(q) != mp2.end()){\n      return mp2[q] + mp[q];\n    }\n    \n    if(mp[q] > 10) continue;\n    for(int i = 0 ; i < 13 ; i++){\n      if(q[i] != 0) continue;      \n      VI t = q;\n      for(int j = 0 ; j < size[i] ; j++){\n\tswap(t[i], t[ move[i][j] ]);\n\tif(mp.find(t) != mp.end()) continue;\n\tmp[t] = mp[q] + 1;\n\tque.push(t);\n      }\n    }\n  }\n  return -1;\n}\n\nvoid init(){\n  v.clear();\n  mp.clear();  \n}\n\nint main(){\n  make();\n  int n;\n  while(cin >> n){\n    if(n == -1) break;\n    \n    init();\n    \n    v.push_back(n);\n    for(int i = 0 ; i < 12 ; i++){ cin >> n; v.push_back(n); }\n    \n    int ans = bfs();\n    if(ans == -1) cout << \"NA\" << endl;\n    else cout << ans << endl;\n  }\n  \n\n  return 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\nusing namespace std;\n\nconst int INF = 1<<28;\nconst int H = 5;\nconst int W = 5;\n\nstruct State {\n  int g[H][W];\n  int x[2], y[2];\n  bool operator < (const State &s) const {\n    for(int i = 0, k = 0; i < H; ++i) {\n      for(int j = abs(2-i); j < W-abs(2-i); ++j) {\n        if(g[i][j] != s.g[i][j]) return g[i][j] < s.g[i][j];\n      }\n    }\n    return false;\n  }\n  bool operator == (const State &s) const {\n    return !(*this < s) && !(s < *this);\n  }\n};\n\nmap<State,int> bfs1(State src) {\n  const static int dx[4] = {1,0,-1,0};\n  const static int dy[4] = {0,1,0,-1};\n  map<State,int> cost;\n  queue<State> que;\n  cost[src] = 0;\n  que.push(src);\n  while(que.size()) {\n    const State s = que.front();\n    que.pop();\n    if(cost[s] == 10) continue;\n    for(int k = 0; k < 2; ++k) {\n      for(int i = 0; i < 4; ++i) {\n        int nx = s.x[k] + dx[i];\n        int ny = s.y[k] + dy[i];\n        if(nx < 0 || nx >= W) continue;\n        if(ny < 0 || ny >= H) continue;\n        if(s.g[ny][nx] <= 0) continue;\n        State t = s;\n        swap(t.g[t.y[k]][t.x[k]], t.g[ny][nx]);\n        t.x[k] = nx;\n        t.y[k] = ny;\n        if(cost.count(t)) continue;\n        cost[t] = cost[s] + 1;\n        que.push(t);\n      }\n    }\n  }\n  return cost;\n}\n\nint bfs2(State src, map<State,int> rcost) {\n  const static int dx[4] = {1,0,-1,0};\n  const static int dy[4] = {0,1,0,-1};\n  if(rcost.count(src)) return rcost[src];\n  map<State,int> cost;\n  queue<State> que;\n  cost[src] = 0;\n  que.push(src);\n  int res = INF;\n  while(que.size()) {\n    const State s = que.front();\n    que.pop();\n    if(cost[s] == 10) continue;\n    for(int k = 0; k < 2; ++k) {\n      for(int i = 0; i < 4; ++i) {\n        int nx = s.x[k] + dx[i];\n        int ny = s.y[k] + dy[i];\n        if(nx < 0 || nx >= W) continue;\n        if(ny < 0 || ny >= H) continue;\n        if(s.g[ny][nx] <= 0) continue;\n        State t = s;\n        swap(t.g[t.y[k]][t.x[k]], t.g[ny][nx]);\n        t.x[k] = nx;\n        t.y[k] = ny;\n        if(cost.count(t)) continue;\n        cost[t] = cost[s] + 1;\n        que.push(t);\n        if(rcost.count(t)) {\n          res = min(res, cost[t] + rcost[t]);\n        }\n      }\n    }\n  }\n  return res;\n}\n\nint main() {\n  State src, dst;\n  fill(src.g[0], src.g[H], -1);\n  fill(dst.g[0], dst.g[H], -1);\n  for(int i = 0, k = 0, t = 0; i < H; ++i) {\n    for(int j = abs(2-i); j < W-abs(2-i); ++j) {\n      dst.g[i][j] = t % 12;\n      ++t;\n      if(dst.g[i][j] == 0) {\n        dst.x[k] = j;\n        dst.y[k] = j;\n        ++k;\n      }\n    }\n  }\n  while(1) {\n    for(int i = 0, k = 0; i < H; ++i) {\n      for(int j = abs(2-i); j < W-abs(2-i); ++j) {\n        cin >> src.g[i][j];\n        if(src.g[i][j] == -1) return 0;\n        if(src.g[i][j] == 0) {\n          src.x[k] = j;\n          src.y[k] = i;\n          ++k;\n        }\n      }\n    }\n    int res = bfs2(src, bfs1(dst));\n    if(res == INF) cout << \"NA\" << endl;\n    else cout << res << endl;\n  }\n  return 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include<iostream>\n#include<cmath>\n#include<stdio.h>\nusing namespace std;\n\n#define LIMIT 20\n\nstruct Puzzle {\n  int cont[25];\n  int space[2];\n};\n\nint limit;\n\nPuzzle puzzle;\n\nint tx[12]={0,1,2,3,0,1,2,3,4,1,2,3};\nint ty[12]={0,1,1,1,2,2,2,2,2,3,3,3};\nint dx[4]={0,1,0,-1};\nint dy[4]={-1,0,1,0};\n\nint heuris[12][25];\n\nint getHeuristic(){\n  int res=0;\n  for(int i=0;i<25;i++){\n    if(puzzle.cont[i]==-1||puzzle.cont[i]==0)continue;\n    res+=heuris[puzzle.cont[i]][i];\n  }\n  return res;\n}\n\nbool dfs(int depth,int prev0,int prev1){\n  /*\n  cout<<depth<<endl;\n  for(int i=0;i<5;i++){\n    for(int j=0;j<5;j++){\n      if(puzzle.cont[i*5+j]!=-1)printf(\"%3d\",puzzle.cont[i*5+j]);\n      else cout<<\"???\";\n    }\n    cout<<endl;\n  }\n  */\n  int heuri;\n  heuri=getHeuristic();\n  if(heuri==0){\n    cout<<depth<<endl;\n    return true;\n  }\n  if(depth + heuri>limit)return false;\n\n  int px,py,nx,ny;\n  Puzzle tmp=puzzle;\n\n  py=puzzle.space[0]/5;px=puzzle.space[0]%5;\n\n  for(int i=0;i<4;i++){\n    if(max(prev0,i)-min(prev0,i)==2)continue;\n    ny=py+dy[i];nx=px+dx[i];\n    if(ny<0||ny>=5||nx<0||nx>=5)continue;\n    if(puzzle.cont[ny*5+nx]==-1)continue;\n    if(puzzle.cont[ny*5+nx]==0)continue;\n    puzzle.cont[py*5+px]=puzzle.cont[ny*5+nx];\n    puzzle.cont[ny*5+nx]=0;\n    puzzle.space[0]=ny*5+nx;\n    if(dfs(depth+1,i,prev1))return true;\n    puzzle=tmp;\n  }\n  py=puzzle.space[1]/5;px=puzzle.space[1]%5;\n  for(int i=0;i<4;i++){\n    if(max(prev1,i)-min(prev1,i)==2)continue;\n    ny=py+dy[i];nx=px+dx[i];\n    if(ny<0||ny>=5||nx<0||nx>=5)continue;\n    if(puzzle.cont[ny*5+nx]==-1)continue;\n    if(puzzle.cont[ny*5+nx]==0)continue;\n    puzzle.cont[py*5+px]=puzzle.cont[ny*5+nx];\n    puzzle.cont[ny*5+nx]=0;\n    puzzle.space[1]=ny*5+nx;\n    if(dfs(depth+1,prev0,i))return true;\n    puzzle=tmp;\n  }\n  return false;\n}\n\nvoid solve(){\n  Puzzle tmp=puzzle;\n  for(limit=getHeuristic();limit<=LIMIT;limit+=2){\n    puzzle=tmp;\n    if(dfs(0,-100,-100))return;\n  }\n  cout<<\"NA\"<<endl;\n}\n\nint main(){\n  int x,y,c=0;\n\n  for(int i=1;i<=11;i++){\n    for(int j=0;j<25;j++){\n      y=j/5;\n      x=j%5;\n      heuris[i][j]=abs(tx[i]-x)+abs(ty[i]-y);\n    }\n  }\n\n\n  for(int i=0;i<25;i++)puzzle.cont[i]=-1;\n\n  while(1){\n\n    cin>>puzzle.cont[2];\n    if(puzzle.cont[2]==-1)break;\n    if(puzzle.cont[2]==0)puzzle.space[c++]=2;\n    \n    \n    for(int i=6;i<=8;i++){\n      cin>>puzzle.cont[i];\n      if(puzzle.cont[i]==0)puzzle.space[c++]=i;\n    }\n    for(int i=10;i<=14;i++){\n      cin>>puzzle.cont[i];\n      if(puzzle.cont[i]==0)puzzle.space[c++]=i;\n    }\n    \n    for(int i=16;i<=18;i++){\n      cin>>puzzle.cont[i];\n      if(puzzle.cont[i]==0)puzzle.space[c++]=i;\n    }\n    \n    cin>>puzzle.cont[22];\n    if(puzzle.cont[22]==0)puzzle.space[c++]=22;\n    solve();\n  }\n\n  return 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include<stdio.h>\n#include<queue>\n#include<algorithm>\n#include<set>\nusing namespace std;\nint p[15];\nstruct wolf{\n\tint m[13];\n};\ninline bool operator <(const wolf &a,const wolf &b){\n\tfor(int i=0;i<13;i++)if(a.m[i]!=b.m[i])return a.m[i]<b.m[i];\n\treturn false;\n}\nint g[13][4]={\n{2,-1,-1,-1},\n{2,5,-1,-1},{0,1,3,6},{2,7,-1,-1},\n{5,-1,-1,-1},{1,4,6,9},{2,5,7,10},{3,6,8,11},{7,-1,-1,-1},\n{5,10,-1,-1},{6,9,11,12},{7,10,-1,-1},\n{10,-1,-1,-1}\n};\nint row[]={0,1,1,1,2,2,2,2,2,3,3,3,4};\nint col[]={2,1,2,3,0,1,2,3,4,1,2,3,2};\nint ABS(int a){return max(a,-a);}\nint main(){\n\twhile(scanf(\"%d\",p),~p[0]){\n\t\tfor(int i=1;i<13;i++)scanf(\"%d\",p+i);\n\t\tset<wolf>S;\n\t\twolf st;\n\t\tfor(int i=0;i<13;i++)st.m[i]=p[i];\n\t\tqueue<pair<wolf,int> > Q;\n\t\tS.insert(st);\n\t\tQ.push(make_pair(st,0));\n\t\tbool yet=true;\n\t\twhile(Q.size()){\n\t\t\twolf at=Q.front().first;\n\t\t\tint cost=Q.front().second;\n\t\t\tQ.pop();\n\t\t\tbool ok=true;\n\t\t\tfor(int i=1;i<12;i++)if(at.m[i]!=i)ok=false;\n\t\t\tif(ok){\n\t\t\t\tyet=false;\n\t\t\t\tprintf(\"%d\\n\",cost);\n\t\t\t\tbreak;\n\t\t\t}\n\t\t\tint now=cost;\n\t\t\tfor(int i=0;i<13;i++)if(at.m[i]){\n\t\t\t\tnow+=ABS(row[i]-row[at.m[i]])+ABS(col[i]-col[at.m[i]]);\n\t\t\t}\n\t\t\tif(now>=20)continue;\n\t\t\tfor(int i=0;i<13;i++)if(!at.m[i]){\n\t\t\t\tfor(int j=0;j<4;j++)if(~g[i][j]){\n\t\t\t\t\tswap(at.m[i],at.m[g[i][j]]);\n\t\t\t\t\tif(!S.count(at)){\n\t\t\t\t\t\tS.insert(at);\n\t\t\t\t\t\tQ.push(make_pair(at,cost+1));\n\t\t\t\t\t}\n\t\t\t\t\tswap(at.m[i],at.m[g[i][j]]);\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t\tif(yet)printf(\"NA\\n\");\n\t}\n}"
  },
  {
    "language": "C++",
    "code": "#include <iostream>\n#include <vector>\n\nusing namespace std;\n \nstruct P {\n    int y, x;\n    P(int y, int x) : y{y}, x{x} {}\n};\n \nint limit;\nvector<int> v;\n\nconstexpr int X[] = {0, 1, 1, 1, 2, 2, 2, 2, 2, 3, 3, 3, 4};\nconstexpr int Y[] = {2, 1, 2, 3, 0, 1, 2, 3, 4, 1, 2, 3, 2};\n \nint getPos(P p)\n{\n    switch (p.y) {\n        case 0:\n            return (p.x == 2 ? 0 : -1);\n        case 1:\n            return (1 <= p.x && p.x <= 3 ? p.x : -1);\n        case 2:\n            return (p.x <= 4 ? p.x + 4 : -1); \n        case 3:\n            return (1 <= p.x && p.x <= 3 ? p.x + 8 : -1);\n        case 4:\n            return (p.x == 2 ? 12 : -1);\n    }\n    return -1;\n}\n \nint getMD()\n{\n    int sum = 0;\n    for (int i = 0; i < 13; i++) {\n        if (v[i] == 0) continue;\n        P np{X[i], Y[i]};\n        P tp{X[v[i]], Y[v[i]]};\n        sum += abs(np.x - tp.x) + abs(np.y - tp.y);\n    }\n    return sum;\n}\n \nconstexpr int dx[] = {-1, 0, 1, 0};\nconstexpr int dy[] = {0, -1, 0, 1};\n \nbool dfs(int* sp, int step)\n{\n    int md = getMD();\n    if (md == 0) return 1;\n    if (md + step > limit) {\n        return 0;\n    }\n    \n    for (int i = 0; i < 2; i++) {\n        int x = X[sp[i]], y = Y[sp[i]];\n        for (int j = 0; j < 4; j++) {\n            int nx = x + dx[j], ny = y + dy[j];\n            P np{nx, ny};\n            \n            int next = getPos(np);\n            if (next == -1) continue;\n            \n            int nsp1[] = {next, sp[1]}, nsp2[] = {sp[0], next};\n            \n            swap(v[sp[i]], v[next]);\n            if (i == 0 && dfs(nsp1, step + 1)) {\n                return 1;\n            }\n            if (i == 1 && dfs(nsp2, step + 1)) {\n                return 1;\n            }\n            swap(v[sp[i]], v[next]);\n        }\n    }\n    return 0;\n}\n \nint main()\n{\n    int x;\n    while (cin >> x, x != -1) {\n        int sp[2];\n        v.resize(13); v[0] = x;\n        for (int i = 1, j = 0; i < 13; i++) {\n            cin >> v[i];\n            if (v[i] == 0) {\n                sp[j++] = i;\n            }\n        }\n\n        bool found = 0;\n        constexpr int LIMIT = 20;\n        for (limit = 0; limit <= LIMIT; limit++) {\n            if (dfs(sp, 0)) {\n                cout << limit << endl;\n                found = 1;\n                break;\n            }\n        }\n        if (!found) {\n            cout << \"NA\" << endl;\n        }\n    }\n    return 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\n\nusing namespace std;\n\n#define LIMIT 20\n\nstruct P{\n  int y,x;\n  P(int y,int x) : y(y),x(x) {}\n};\n\nint limit;\nvector<int> v;\n\nP getPos(int x){\n  if(x == 0){ return P(0,2); }\n  if(1 <= x && x <= 3){ return P(1,x); }\n  if(4 <= x && x <= 8){ return P(2,x-4); }\n  if(9 <= x && x <= 11){ return P(3,x-8); }\n  return P(4,2);\n}\n\nint getPos(P p){\n  if(p.y == 0){\n    if(p.x == 2){ return 0; }\n    else{ return -1; }\n  }\n  if(p.y == 1){\n    if(1 <= p.x && p.x <= 3){\n      return p.x;\n    }else{\n      return -1;\n    }\n  }\n  if(p.y == 2){\n    if(0 <= p.x && p.x <= 4){\n      return p.x+4;\n    }else{\n      return -1;\n    }\n  }\n  if(p.y == 3){\n    if(1 <= p.x && p.x <= 3){\n      return p.x+8;\n    }else{\n      return -1;\n    }\n  }\n  if(p.y == 4){\n    if(p.x == 2){\n      return 12;\n    }else{\n      return -1;\n    }\n  }\n  return -1;\n}\n\nint getMD(){\n  int sum = 0;\n  for(int i = 0 ; i < 13 ; i++){\n    if(v[i] == 0){ continue; }\n    P np = getPos(i);\n    P tp = getPos(v[i]);\n    sum += abs(np.x-tp.x) + abs(np.y-tp.y);\n  }\n  return sum;\n}\n\nconst int dx[] = {-1,0,1,0};\nconst int dy[] = {0,-1,0,1};\n\nbool dfs(int sp1,int sp2,int step){\n  int md = getMD();\n  if(md == 0){ return true; }\n  if(md + step > limit){\n    return false;\n  }\n  P p[2] = {getPos(sp1),getPos(sp2)};\n  for(int i = 0 ; i < 2 ; i++){\n    int x = p[i].x, y = p[i].y;\n    for(int j = 0 ; j < 4 ; j++){\n      int nx = x + dx[j], ny = y + dy[j];\n      P np(ny,nx);\n      int next = getPos(np);\n      if(next == -1){ continue; }\n      if(i == 0){\n        swap(v[sp1],v[next]);\n        if(dfs(next,sp2,step+1)){\n          return true;\n        }\n        swap(v[sp1],v[next]);\n      }else{\n        swap(v[sp2],v[next]);\n        if(dfs(sp1,next,step+1)){\n          return true;\n        }\n        swap(v[sp2],v[next]);\n      }\n    }\n  }\n  return false;\n}\n\nint main(){\n  int x;\n  while(cin >> x, x != -1){\n    int sp[2];\n    v.resize(13); v[0] = x;\n    for(int i = 1 ; i < 13 ; i++){\n      cin >> v[i];\n    }\n    for(int i = 0, j = 0 ; i < 13 ; i++){\n      if(v[i] == 0){\n        sp[j++] = i;\n      }\n    }\n    bool found = false;\n    for(limit = 0 ; limit <= LIMIT ; limit++){\n      if(dfs(sp[0],sp[1],0)){\n        cout << limit << endl;\n        found = true;\n        break;\n      }\n    }\n    if(!found){\n      cout << \"NA\" << endl;\n    }\n  }\n  return 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include <iostream>\n#include <cstdio>\n#include <cstring>\n#include <algorithm>\n#include <vector>\n#include <queue>\n#include <map>\nusing namespace std;\n\ntypedef vector<int> VI;\n\nint size[13] = {1, 2, 4, 2, 1, 4, 4, 4, 1, 2, 4, 2, 1};\nint move[13][4] = {\n  {2},\n  {2, 5},\n  {0, 1, 6, 3},\n  {2, 7},\n  {5},\n  {1, 4, 6, 9},\n  {2, 5, 7, 10},\n  {3, 6, 8, 11},\n  {7},\n  {5, 10},\n  {6, 9, 11, 12},\n  {7, 10},\n  {10}\n};\n\nVI v;\nmap<VI, int> mp;\nmap<VI, int> mp2;\n\nvoid make(){\n  VI goal;\n  for(int i = 0 ; i < 13 ; i++){\n    if(i == 0 || i == 12) goal.push_back(0);\n    else goal.push_back(i);    \n  }\n  \n  queue<VI> que;\n  que.push(goal);\n  mp2[goal] = 0;\n  \n  while(!que.empty()){\n    VI q = que.front(); que.pop();    \n    if(mp2[q] > 11) continue;\n    for(int i = 0 ; i < 13 ; i++){\n      if(q[i] != 0) continue;\n      for(int j = 0 ; j < size[i] ; j++){\n\tVI t = q;\n\tswap(t[i], t[ move[i][j] ]);\n\tif(mp2.find(t) != mp2.end()) continue;\t\n\tmp2[t] = mp2[q] + 1;\t\n\tque.push(t);\n      }\n    }\n  }\n}\n    \n\n\nint bfs(){\n  queue<VI> que;\n  que.push(v);\n  mp[v] = 0;  \n  while(!que.empty()){\n    VI q = que.front(); que.pop();    \n    if(mp2.find(q) != mp2.end()){\n      return mp2[q] + mp[q];\n    }\n    \n    if(mp[q] > 9) continue;\n    for(int i = 0 ; i < 13 ; i++){\n      if(q[i] != 0) continue;      \n      for(int j = 0 ; j < size[i] ; j++){\n\tVI t = q;\n\tswap(t[i], t[ move[i][j] ]);\n\tif(mp.find(t) != mp.end()) continue;\n\tmp[t] = mp[q] + 1;\n\tque.push(t);\n      }\n    }\n  }\n  return -1;\n}\n\nvoid init(){\n  v.clear();\n  mp.clear();  \n}\n\nint main(){\n  make();\n  int n;\n  while(cin >> n){\n    if(n == -1) break;\n    \n    init();\n    \n    v.push_back(n);\n    for(int i = 0 ; i < 12 ; i++){ cin >> n; v.push_back(n); }\n    int ans = bfs();\n    if(ans == -1) cout << \"NA\" << endl;\n    else cout << ans << endl;\n  }\n  \n\n  return 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include<iostream>\n#include<algorithm>\n#include<vector>\n#include<queue>\n#include<unordered_map>\n#include<unordered_set>\n#define lol(i,n) for(int i=0;i<n;i++)\n#define mod 1000000007\ntypedef long long ll;\nusing namespace std;\nint dx[13][4]={\n  {3,0,0,0},\n  {3,6,0,0},\n  {1,2,4,7},\n  {3,8,0,0},\n  {6,0,0,0},\n  {2,5,7,10},\n  {3,6,8,11},\n  {4,7,9,12},\n  {8,0,0,0},\n  {6,11,0,0},\n  {7,10,12,13},\n  {8,11,0,0},\n  {11,0,0,0}\n};\nunordered_map<ll,int> mp;\nll Compress(int p[]){\n  ll ans=0;\n  for(int i=0;i<13;i++){\n    ans*=13;\n    ans+=p[i];\n  }\n  return ans;\n}\n\nint unzip[13];\nvoid Unzip(ll x){\n  for(int i=0;i<13;i++){\n    unzip[12-i]=x%13;\n    x/=13;\n  }\n}\n\nint beflen=0;\nqueue<pair<ll,int> >Q;\nvoid BFS(int p[],int len){\n  //if(len!=beflen){cout<<len<<endl;beflen=len;}\n  ll tmp=Compress(p);\n  mp[tmp]=len;\n  if(len==14)return;\n  lol(i,13){\n    if(p[i]==0){\n      lol(j,4){\n\tint t=dx[i][j];\n\tif(t==0)break;\n\tt--;\n\tif(p[t]!=0){\n\t  swap(p[i],p[t]);\n\t  tmp=Compress(p);\n\t  if(mp[tmp]!=0)continue;\n\t  mp[tmp]=-1;\n\t  Q.push(make_pair(tmp,len+1));\n\t  swap(p[i],p[t]);\n\t}\n      }\n    }\n  }\n}\n\nunordered_set<ll> st;\nint ans;\nvoid EFS(int p[],int len){\n  //if(len!=beflen){cout<<len<<endl;beflen=len;}\n  ll tmp=Compress(p);\n  if(mp[tmp]>0){\n    ans=min(ans,len+mp[tmp]-1);\n    return;\n  }\n  if(len==10)return;\n  lol(i,13){\n    if(p[i]==0){\n      lol(j,4){\n\tint t=dx[i][j];\n\tif(t==0)break;\n\tt--;\n\tif(p[t]!=0){\n\t  swap(p[i],p[t]);\n\t  tmp=Compress(p);\n\t  Q.push(make_pair(tmp,len+1));\n\t  swap(p[i],p[t]);\n\t}\n      }\n    }\n  }\n}\nint main(){\n  int p[13];\n  lol(i,13)p[i]=i;p[12]=0;\n  Q.push(make_pair(Compress(p),1));\n  while(!Q.empty()){\n    ll data=Q.front().first;\n    int len=Q.front().second;\n    Q.pop();\n    if(mp[data]>0)continue;\n    Unzip(data);\n    BFS(unzip,len);\n  }\n  //cout<<\"#\"<<mp.size()<<endl;\n  while(cin>>p[0]&&p[0]!=-1){\n    for(int i=1;i<13;i++)cin>>p[i];\n    ans=mod;\n    Q.push(make_pair(Compress(p),0));\n    while(!Q.empty()){\n      ll data=Q.front().first;\n      int len=Q.front().second;\n      Q.pop();\n      if(st.find(data)!=st.end())continue;\n      st.insert(data);\n      Unzip(data);\n      EFS(unzip,len);\n    }\n    st.clear();\n    if(ans>20)cout<<\"NA\"<<endl;\n    else cout<<ans<<endl;\n  }\n  return 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include <cstdio>\n#include <cstdlib>\n#include <cmath>\n#include <climits>\n#include <cfloat>\n#include <map>\n#include <utility>\n#include <set>\n#include <iostream>\n#include <memory>\n#include <string>\n#include <vector>\n#include <algorithm>\n#include <functional>\n#include <sstream>\n#include <complex>\n#include <stack>\n#include <queue>\n#include <cstring>\n#include <sstream>\n#include <cassert>\n#include <list>\nusing namespace std;\nstatic const double EPS = 1e-10;\ntypedef long long ll;\ntypedef pair<int,int> PI;\ntypedef vector<int> vi;\n#ifndef M_PI\n#define M_PI 3.14159265358979323846\n#endif\n#define rep(i,n) for(int i=0;i<(int)n;++i)\n#define FOR(i,c) for(__typeof((c).begin())i=(c).begin();i!=(c).end();++i)\n#define ALL(c) (c).begin(), (c).end()\n#define mp(a,b) make_pair(a,b)\n#define pb(a) push_back(a)\n#define F first\n#define S second\ntemplate <typename T> string print_array(const vector<T> &V) { ostringstream os; os << \"{ \"; for (typename vector<T>::const_iterator iter = V.begin(); iter != V.end(); ++iter) os << '\\\"' << *iter << \"\\\",\"; os << \" }\"; return os.str(); }\n\nint dx[]={0,1,0,-1},dy[]={1,0,-1,0};\n\nvector<int> se[13];\nint x[]={0,-1,0,1,-2,-1,0,1,2,-1,0,1,0};\nint y[]={2,1,1,1,0,0,0,0,0,-1,-1,-1,-2};\n\nvoid pr(ll in){\n\n  printf(\"      %3lld\\n\",in&15);\n  printf(\"   %3lld%3lld%3lld\\n\",(in>>4)&15,(in>>8)&15,(in>>12)&15);\n  printf(\"%3lld%3lld%3lld%3lld%3lld\\n\",(in>>16)&15,(in>>20)&15,(in>>24)&15,(in>>28)&15,(in>>32)&15);\n  printf(\"   %3lld%3lld%3lld\\n\",(in>>36)&15,(in>>40)&15,(in>>44)&15);\n  printf(\"      %3lld\\n\",(in>>48)&15);\n  puts(\"\");\n}\n\nint manh(ll in){\n  int ret=0;\n  rep(i,13){\n    int t=(in>>(i*4))&15;\n\n    if(!t){\n      int nx=x[t]-x[i],ny=y[t]-y[i];\n      int co=abs(nx)+abs(ny);\n      nx=x[12]-x[i],ny=y[12]-y[i];\n      int k=abs(nx)+abs(ny);\n      ret+=min(co,k);\n      continue;\n    }\n    int nx=(x[t]-x[i]),ny=y[t]-y[i];\n    ret+=abs(nx)+abs(ny);\n  }\n  return ret;\n}\n\nmain(){\n  ll p;\n\n  ll goal=0;\n  rep(i,11){\n    goal|=(i+1LL)<<(4*(i+1));\n    //cout<<goal<<endl;\n    //pr(goal);\n  }\n  //pr(goal);\n\n  se[0].pb(2);\n  se[1].pb(2);\n  se[1].pb(5);\n  se[2].pb(0);\n  se[2].pb(1);\n  se[2].pb(3);\n  se[2].pb(6);\n  se[3].pb(2);\n  se[3].pb(7);\n  se[4].pb(5);\n  se[5].pb(1);\n  se[5].pb(4);\n  se[5].pb(6);\n  se[5].pb(9);\n  se[6].pb(2);\n  se[6].pb(5);\n  se[6].pb(7);\n  se[6].pb(10);\n  se[7].pb(3);\n  se[7].pb(6);\n  se[7].pb(8);\n  se[7].pb(11);\n  se[8].pb(7);\n  se[9].pb(5);\n  se[9].pb(10);\n  se[10].pb(6);\n  se[10].pb(9);\n  se[10].pb(11);\n  se[10].pb(12);\n  se[11].pb(7);\n  se[11].pb(10);\n  se[12].pb(10);\n  \n  while(cin>>p){\n    if(p==-1)break;\n    ll in=p;\n\n    rep(i,12){\n      cin>>p;\n      in|=p<<(4*(i+1));\n    }\n\n    set<ll> app;\n\n    queue<pair<int,ll> > Q;\n    app.insert(in);\n    Q.push(mp(0,in));\n    int ans=21;\n    int mans=0;\n\n    while(!Q.empty()){\n      ll cvec=Q.front().S;\n      int ccost=Q.front().F;\n      Q.pop();\n    \n      //pr(cvec);\n\n      //if(ccost>3)break;\n     if(ccost>20)break;\n     \n      if(cvec==goal){\n\tans=ccost;\n\tbreak;\n      }\n      if(ccost+manh(cvec)>29)continue;\n      rep(i,13){\n\tll t=cvec>>(i<<2);\n\tt=t&15;\n\tif(!t){\n\t  rep(j,se[i].size()){\n\t    t=cvec>>(se[i][j]<<2);\n\t    t=t&15;\n\t    if(t){\n\t      ll nvec=cvec;\n\t      t=t<<(i<<2);\n\t      nvec|=t;\n\t      nvec&=~(15LL<<se[i][j]*4);\n\t      \n\t      if(!app.count(nvec)){\n\t\tapp.insert(nvec);\n\t\tQ.push(mp(ccost+1,nvec));\n\t      }\n\t    }\n\t  }\n\t}\n      }\n    }\n    if(ans==21)cout<<\"NA\"<<endl;\n    else cout<<ans<<endl;\n  }\n}"
  },
  {
    "language": "C++",
    "code": "#include <iostream>\n#include <algorithm>\n#include <vector>\n#include <cstring>\n#include <cstdio>\n#include <climits>\n\nusing namespace std;\n\n\n#define REP(i,a,n) for(int i=(a); i<(int)(n); i++)\n#define rep(i,n) REP(i,0,n)\n#define DEB 0\n\nint board[7][7]; //1base\nint sx[2], sy[2];\nstatic const int dx[] = {0,0,1,-1};\nstatic const int dy[] = {1,-1,0,0};\n\nint calc(int y, int x){\n    switch(board[y][x]){\n    case 1: return abs(2-y)+abs(2-x);\n    case 2: return abs(2-y)+abs(3-x);\n    case 3: return abs(2-y)+abs(4-x);\n    case 4: return abs(3-y)+abs(1-x);\n    case 5: return abs(3-y)+abs(2-x);\n    case 6: return abs(3-y)+abs(3-x);\n    case 7: return abs(3-y)+abs(4-x);\n    case 8: return abs(3-y)+abs(5-x);\n    case 9: return abs(4-y)+abs(2-x);\n    case 10: return abs(4-y)+abs(3-x);\n    case 11: return abs(4-y)+abs(4-x);\n    }\n    return -1;\n}\nint dist(void){\n    int ret = 0;\n    if( board[1][3] ) ret += calc(1,3);\n    rep(i,3) if( board[2][2+i] ) ret += calc(2,2+i);\n    rep(i,5) if( board[3][1+i] ) ret += calc(3,1+i);\n    rep(i,3) if( board[4][2+i] ) ret += calc(4,2+i);\n    if( board[5][3] ) ret += calc(5,3);\n    return ret;\n}\nbool isgoal(void){\n    if( board[1][3]!=0 ) return false;\n    rep(i,3) if( board[2][2+i]!=i+1 ) return false;\n    rep(i,5) if( board[3][1+i]!=i+4 ) return false;\n    rep(i,3) if( board[4][2+i]!=i+9 ) return false;\n    if( board[5][3]!=0 ) return false;\n    return true;\n}\n\nbool dfs(int cnt, int LIM, int py, int px, vector<pair<int,int> > sp){\n    if( isgoal() ) return true;\n    if( cnt+dist()>LIM ) return false;\n\n    rep(i,2){\n        if( board[sp[i].second][sp[i].first]!=0 ) exit(-1);\n        rep(k,4){\n            int tx = sp[i].first + dx[k];\n            int ty = sp[i].second + dy[k];\n            if( board[ty][tx]==-1 || tx==px&&ty==py ) continue;\n\n            swap(board[sp[i].second][sp[i].first], board[ty][tx]);\n\n            vector<pair<int,int> > v = sp;\n            pair<int,int> tmp(tx,ty);\n            swap(v[i], tmp);\n            if( dfs(cnt+1, LIM, ty, tx, v) ) return true;\n\n            swap(board[sp[i].second][sp[i].first] ,board[ty][tx]);\n        }\n    }\n    return false;\n}\nint solve(void){\n    int ttx[2], tty[2];\n    //int tb[7][7];\n    vector<pair<int,int> > sp;\n    rep(i,2) sp.push_back(make_pair(sx[i],sy[i]));\n    //rep(i,7)rep(j,7) tb[i][j] = board[i][j];\n\n    for(int lim = 0; lim < 21; lim++){\n        if( dfs(0,lim,-1,-1,sp) ) return lim;\n    }\n    return -1;\n}\nint main(){\n    for(;;){\n        memset(board, -1, sizeof(board));\n        int sz = 0;\n\n        scanf(\"%d\",&board[1][3]); if( board[1][3]==-1 ) break;\n        rep(i,3) scanf(\"%d\",&board[2][2+i]);\n        rep(i,5) scanf(\"%d\",&board[3][1+i]);\n        rep(i,3) scanf(\"%d\",&board[4][2+i]);\n        scanf(\"%d\",&board[5][3]);\n\n        // find space\n        if( board[1][3]==0 ){ sx[sz]=3; sy[sz]=1; sz++; }\n        rep(i,3) if( board[2][2+i]==0 ) { sx[sz]=2+i; sy[sz]=2; sz++; }\n        rep(i,5) if( board[3][1+i]==0 ) { sx[sz]=1+i; sy[sz]=3; sz++; }\n        rep(i,3) if( board[4][2+i]==0 ) { sx[sz]=2+i; sy[sz]=4; sz++; }\n        if( board[5][3]==0 ){ sx[sz]=3; sy[sz]=5; sz++; }\n\n        //printf(\"hoge:%d\\n\",dist());\n        int ans = solve();\n        if( ans!=-1 ) printf(\"%d\\n\",ans); else puts(\"NA\");\n    }\n    return 0;\n}\n\n/*\n\n//-------------------------------------------------------\n\n#define N 5\n#define REP(i, n) for ( int i = 0; i < (int)n; i++ )\n#define LIMIT 20\n\nstatic const int T[12][2] = {\n    {-1, -1},\n    {1, 1}, \n    {1, 2}, \n    {1, 3},\n    {2, 0},\n    {2, 1},\n    {2, 2},\n    {2, 3},\n    {2, 4},\n    {3, 1}, \n    {3, 2},\n    {3, 3}\n};\nstatic const int g[N][N] = {\n    {-1,-1, 0,-1,-1},\n    {-1, 1, 2, 3,-1},\n    { 4, 5, 6, 7, 8},\n    {-1, 9,10,11,-1}, \n    {-1,-1, 0,-1,-1}\n};\n\nclass Puzzle{\npublic:\n    int C[N][N], mdist; //manhatta distance\n    Puzzle(){}\n\n    bool swapAdj( int si, int sj, int ti, int tj ){\n        if ( ti < 0 || tj < 0 || ti >= N || tj >= N ) return false;\n        if ( C[ti][tj] <= 0 ) return false;\n        swap(C[ti][tj], C[si][sj]);\n        int tti = T[C[si][sj]][0];\n        int ttj = T[C[si][sj]][1];\n        //mdist -= max(tti, ti)-min(tti, ti) + max(ttj, tj)-min(ttj, tj);\n        //mdist += max(tti, si)-min(tti, si) + max(ttj, sj)-min(ttj, sj);\n        //mdist -= abs(tti-ti)+abs(ttj-tj);\n        //mdist += abs(tti-si)+abs(ttj-sj);\n        return true;\n    }\n\n    bool isGoal(){\n        REP(i, N) REP(j, N) if ( g[i][j] != C[i][j] ) return false;\n        return true;\n    }\n\n    int getMD(){ // get initial manhattan distance\n        int sum = 0;\n        int ti, tj;\n        REP(i, 5) REP(j, 5){\n            if ( C[i][j] <= 0 ) continue;\n            ti = T[C[i][j]][0];\n            tj = T[C[i][j]][1];\n            //sum += (max(ti, i)-min(ti, i) + max(tj, j) - min(tj, j));\n            sum += abs(ti-i) + abs(tj-j);\n        }\n        return sum;\n    }\n};\n\nint limit;\n\nbool dfs( int depth, Puzzle P ){\n    if ( P.isGoal() ) return true;\n    if ( depth + P.getMD() > limit ) return false;\n\n    static const int di[4] = {0, -1, 0, 1};\n    static const int dj[4] = {1, 0, -1, 0};\n\n    REP(i, N) REP(j, N){\n        if ( P.C[i][j] != 0 ) continue;\n        REP(r, 4){\n            Puzzle v = P;\n            if ( !v.swapAdj(i, j, i+di[r], j+dj[r]) ) continue;\n            if ( dfs( depth + 1, v ) ) return true;\n        }\n    }\n\n    return false;\n}\n\nint idp(Puzzle source){\n    for ( limit = 0; limit <= LIMIT; limit++ ){\n        //source.mdist = source.getMD();\n        if ( dfs(0, source) ) return limit;\n    }\n    return INT_MAX;\n}\n\nint main(){\n    Puzzle P;\n    int top;\n\n    while(1){\n        cin >> top;\n        if ( top == -1 ) break;\n        REP(j, N) P.C[0][j] = -1;\n        P.C[0][2] = top;\n        for(int i = 1; i < N; i++) REP(j, N){\n                if ( (i == 1 || i == 3) && (j == 0 || j == 4 ) ) P.C[i][j] = -1;\n                else if ( i == 4 && j != 2 ) P.C[i][j] = -1;\n                else cin >> P.C[i][j];\n            }\n\n        int cost = idp(P);\n        if ( cost == INT_MAX ) cout << \"NA\" << endl;\n        else cout << cost << endl;\t\n    }\n\n    return 0;\n}\n\n*/"
  },
  {
    "language": "C++",
    "code": "#include <iostream>\n#include <algorithm>\n#include <vector>\n#include <cstring>\n#include <cstdio>\n#include <climits>\n\nusing namespace std;\n\n#define REP(i,a,n) for(int i=(a); i<(int)(n); i++)\n#define rep(i,n) REP(i,0,n)\n#define LIM 23\n#define DEB 0\n\n/*\n  1 = [2][2]\n  2 = [2][3]\n  3 = [2][4]\n  4 = [3][1]\n  5 = [3][2]\n  6 = [3][3]\n  7 = [3][4]\n  8 = [3][5]\n  9 = [4][2]\n  10= [4][3]\n  11= [4][4]\n*/\nint board[7][7]; //1base\nint ans;\nint sx[2], sy[2];\nstatic const int dx[] = {0,0,1,-1};\nstatic const int dy[] = {1,-1,0,0};\n\n/*\n(y,x)\n */\nint calc(int y, int x){\n    switch(board[y][x]){\n    case 1: return abs(2-y)+abs(2-x);\n    case 2: return abs(2-y)+abs(3-x);\n    case 3: return abs(2-y)+abs(4-x);\n    case 4: return abs(3-y)+abs(1-x);\n    case 5: return abs(3-y)+abs(2-x);\n    case 6: return abs(3-y)+abs(3-x);\n    case 7: return abs(3-y)+abs(4-x);\n    case 8: return abs(3-y)+abs(5-x);\n    case 9: return abs(4-y)+abs(2-x);\n    case 10: return abs(4-y)+abs(3-x);\n    case 11: return abs(4-y)+abs(4-x);\n    }\n    return -1;\n}\nint dist(void){\n    int ret = 0;\n    if( board[1][3] ) ret += calc(1,3);\n    rep(i,3) if( board[2][2+i] ) ret += calc(2,2+i);\n    rep(i,5) if( board[3][1+i] ) ret += calc(3,1+i);\n    rep(i,3) if( board[4][2+i] ) ret += calc(4,2+i);\n    if( board[5][3] ) ret += calc(5,3);\n    return ret;\n}\nbool isgoal(void){\n    if( board[1][3]!=0 ) return false;\n    rep(i,3) if( board[2][2+i]!=i+1 ) return false;\n    rep(i,5) if( board[3][1+i]!=i+4 ) return false;\n    rep(i,3) if( board[4][2+i]!=i+9 ) return false;\n    if( board[5][3]!=0 ) return false;\n    return true;\n}\n\nvoid dfs(int cnt, int py, int px){\n    if( ans<=cnt ) return;\n    if( isgoal() ){\n        ans = cnt;\n        return;\n    }\n    if( cnt+dist()>LIM ) return;\n#if DEB\n    //printf(\"cnt:%d  (%d,%d),(%d,%d)\\n\",cnt, sx[0], sy[0], sx[1], sy[1]);\n#endif\n    rep(i,2){\n        rep(k,4){\n            int tx = sx[i] + dx[k];\n            int ty = sy[i] + dy[k];\n            if( board[ty][tx]==-1 || ty==py&&tx==px ) continue;\n            swap(board[sy[i]][sx[i]], board[ty][tx]);\n            swap(sx[i], tx); swap(sy[i],ty);\n            dfs(cnt+1, ty, tx); // ツ個ウツづ個スツペツーツスツ暗環置\n            swap(sx[i], tx); swap(sy[i],ty);\n            swap(board[sy[i]][sx[i]] ,board[ty][tx]);\n        }\n    }\n}\n\nint main(){\n    for(;;){\n        memset(board, -1, sizeof(board));\n        ans = 21;\n        int sz = 0;\n\n        scanf(\"%d\",&board[1][3]); if( board[1][3]==-1 ) break;\n        rep(i,3) scanf(\"%d\",&board[2][2+i]);\n        rep(i,5) scanf(\"%d\",&board[3][1+i]);\n        rep(i,3) scanf(\"%d\",&board[4][2+i]);\n        scanf(\"%d\",&board[5][3]);\n\n        // find space\n        if( board[1][3]==0 ){ sx[sz]=3; sy[sz]=1; sz++; }\n        rep(i,3) if( board[2][2+i]==0 ) { sx[sz]=2+i; sy[sz]=2; sz++; }\n        rep(i,5) if( board[3][1+i]==0 ) { sx[sz]=1+i; sy[sz]=3; sz++; }\n        rep(i,3) if( board[4][2+i]==0 ) { sx[sz]=2+i; sy[sz]=4; sz++; }\n        if( board[5][3]==0 ){ sx[sz]=3; sy[sz]=5; sz++; }\n\n#if DEB\n        rep(i,7){\n            rep(j,7){\n                printf(\"%2d \",board[i][j]);\n            }\n            puts(\"\");\n        }\n        rep(i,2){\n            printf(\"(%d,%d),\",sx[i], sy[i]);\n        }puts(\"\");\n        printf(\"%d\\n\",dist());\n#endif\n        \n        dfs(0,-1,-1);\n        if( ans==21 ) puts(\"NA\"); else printf(\"%d\\n\",ans);\n    }\n    return 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include <iostream>\n#include <vector>\n#include <string>\n#include <queue>\n#include <set>\nusing namespace std;\n\nconst int INF = 1 << 28;\n\nint main()\n{\n  vector<vector<int> > table(13);\n  table[0].push_back(2);\n  table[1].push_back(2);\n  table[1].push_back(5);\n  table[2].push_back(0);\n  table[2].push_back(1);\n  table[2].push_back(3);\n  table[2].push_back(6);\n  table[3].push_back(2);\n  table[3].push_back(7);\n  table[4].push_back(5);\n  table[5].push_back(1);\n  table[5].push_back(4);\n  table[5].push_back(6);\n  table[5].push_back(9);\n  table[6].push_back(2);\n  table[6].push_back(5);\n  table[6].push_back(7);\n  table[6].push_back(10);\n  table[7].push_back(3);\n  table[7].push_back(6);\n  table[7].push_back(8);\n  table[7].push_back(11);\n  table[8].push_back(7);\n  table[9].push_back(5);\n  table[9].push_back(10);\n  table[10].push_back(6);\n  table[10].push_back(9);\n  table[10].push_back(11);\n  table[10].push_back(12);\n  table[11].push_back(7);\n  table[11].push_back(10);\n  table[12].push_back(10);\n\n  vector<vector<int> > MH(13, vector<int>(13, INF));\n  for (unsigned int i = 0; i < table.size(); ++i) {\n    for (unsigned int j = 0; j < table[i].size(); ++j)\n      MH[i][table[i][j]] = 1;\n  }\n\n  for (int i = 0; i < 13; ++i)\n    MH[i][i] = 0;\n\n  for (int k = 0; k < 13; ++k) {\n    for (int i = 0; i < 13; ++i) {\n      for (int j = 0; j < 13; ++j)\n\tMH[i][j] = min(MH[i][j], MH[i][k]+MH[k][j]);\n    }\n  }\n\n  vector<int> p(13);\n  while (cin >> p[0]) {\n    if (p[0] == -1)\n      break;\n\n    for (unsigned int i = 1; i < p.size(); ++i)\n      cin >> p[i];\n\n    string s;\n    const string g = \"0123456789AB0\";\n    for (unsigned int i = 0; i < p.size(); ++i) {\n      if (p[i] == 10)\n\ts += \"A\";\n      else if (p[i] == 11)\n\ts += \"B\";\n      else\n\ts += ('0' + p[i]);\n    }\n\n    int ans = -1;\n    queue<pair<int, string> > que;\n    que.push(make_pair(0, s));\n    set<string> visited;\n    while (!que.empty()) {\n      const pair<int, string> st = que.front();\n      que.pop();\n\n      if (st.first > 20)\n\tcontinue;\n\n      if (st.second == g) {\n\tans = st.first;\n\tbreak;\n      }\n\n      visited.insert(st.second);\n      vector<int> zero;\n      for (unsigned int i = 0; i < st.second.size(); ++i) {\n\tif (st.second[i] == '0')\n\t  zero.push_back(i);\n      }\n\n      for (unsigned int i = 0; i < zero.size(); ++i) {\n\tfor (unsigned int j = 0; j < table[zero[i]].size(); ++j) {\n\t  s = st.second;\n\t  swap(s[zero[i]], s[table[zero[i]][j]]);\n\n\t  int cost = 0;\n\t  for (unsigned int k = 0; k < s.size(); ++k) {\n\t    if (s[k] == '0')\n\t      cost += min(MH[0][k], MH[12][k]);\n\t    else if (s[k] == 'A')\n\t      cost += MH[10][k];\n\t    else if (s[k] == 'B')\n\t      cost += MH[11][k];\n\t    else\n\t      cost += MH[s[k]-'0'][k];\n\t  }\n\t  cost /= 2;\n\t  if (cost + st.first > 20)\n\t    continue;\n\n\t  if (visited.find(s) == visited.end()) {\n\t    visited.insert(s);\n\t    que.push(make_pair(st.first+1, s));\n\t  }\n\t}\n      }\n    }\n\n    if (ans == -1)\n      cout << \"NA\" << endl;\n    else\n      cout << ans << endl;\n  }\n  return 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include<bits/stdc++.h>\n#define lol(i,n) for(int i=0;i<n;i++)\n#define mod 1000000007\ntypedef long long ll;\nusing namespace std;\nint dx[13][4]={\n  {3,0,0,0},\n  {3,6,0,0},\n  {1,2,4,6},\n  {3,8,0,0},\n  {6,0,0,0},\n  {2,5,7,10},\n  {3,6,8,11},\n  {4,7,9,12},\n  {8,0,0,0},\n  {6,11,0,0},\n  {6,10,12,13},\n  {8,11,0,0},\n  {11,0,0,0}\n};\nunordered_map<ll,int> mp;\nll Compress(int p[]){\n  ll ans=0;\n  for(int i=0;i<13;i++){\n    ans*=13;\n    ans+=p[i];\n  }\n  return ans;\n}\n\nint unzip[13];\nvoid Unzip(ll x){\n  for(int i=0;i<13;i++){\n    unzip[12-i]=x%13;\n    x/=13;\n  }\n}\n\nqueue<pair<ll,int> >Q;\nvoid BFS(int p[],int len){\n  ll tmp=Compress(p);\n  mp[tmp]=len;\n  if(len==21)return;\n  lol(i,13){\n    if(p[i]==0){\n      lol(j,4){\n\tint t=dx[i][j];\n\tif(t==0)break;\n\tt--;\n\tif(p[t]!=0){\n\t  swap(p[i],p[t]);\n\t  Q.push(make_pair(Compress(p),len+1));\n\t  swap(p[i],p[t]);\n\t}\n      }\n    }\n  }\n}\nint main(){\n  int p[13];\n  lol(i,13)p[i]=i;p[12]=0;\n  Q.push(make_pair(Compress(p),1));\n  while(!Q.empty()){\n    ll data=Q.front().first;\n    int len=Q.front().second;\n    Q.pop();\n    if(mp[data]>0)continue;\n    Unzip(data);\n    BFS(unzip,len);\n  }\n  while(cin>>p[0]&&p[0]!=-1){\n    for(int i=1;i<13;i++)cin>>p[i];\n    ll tmp=Compress(p);\n    int cost=mp[tmp];\n    if(cost==0)cout<<\"NA\"<<endl;\n    else cout<<cost-1<<endl;\n  }\n  return 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include<bits/stdc++.h>\n#define int long long\n#define r(i,n) for(int i=0;i<n;i++)\nusing namespace std;\ntypedef pair<int,int>P;\nvector<int>v[13],s(13),t(13);\nunordered_map<int,int>m;\n\nint has[14];\n\n\nvoid init(){\n\n    v[0].push_back(2);\n\n    v[1].push_back(2);\n    v[1].push_back(5);\n\n    v[2].push_back(0);\n    v[2].push_back(1);\n    v[2].push_back(3);\n    v[2].push_back(6);\n\n    v[3].push_back(2);\n    v[3].push_back(7);\n\n    v[4].push_back(5);\n\n    v[5].push_back(1);\n    v[5].push_back(4);\n    v[5].push_back(6);\n    v[5].push_back(9);\n\n    v[6].push_back(2);\n    v[6].push_back(5);\n    v[6].push_back(7);\n    v[6].push_back(10);\n\n    v[7].push_back(3);\n    v[7].push_back(6);\n    v[7].push_back(8);\n    v[7].push_back(11);\n\n    v[8].push_back(7);\n\n    v[9].push_back(5);\n    v[9].push_back(10);\n\n    v[10].push_back(6);\n    v[10].push_back(9);\n    v[10].push_back(11);\n    v[10].push_back(12);\n\n    v[11].push_back(7);\n    v[11].push_back(10);\n\n    v[12].push_back(10);\n\n    int a=20;\n    int p=1;\n\n    r(i,13){\n        has[i]=p;\n        p*=a;\n    }\n}\n\nint ha(vector<int> &x){\n\n    int re=0;\n\n    r(i,13){\n        re+=x[i]*has[i];\n    }\n\n    return re;\n}\n\nvector<int> ah(int x){\n    vector<int>y(13);\n    r(i,13){\n        y[i]=x%20;\n        x/=20;\n    }\n    return y;\n}\n\nvoid BFS1(){\n    s[0]=0;\n    s[12]=0;\n    r(i,11)s[i+1]=i+1;\n    unordered_set<int>st;\n    st.insert(ha(s));\n    m[ha(s)]=0;\n    queue<P>q;\n    q.push(P(ha(s),0));\n    while(1){\n        vector<int> now=ah(q.front().first);\n        int cost=q.front().second;\n        q.pop();\n        if(cost==7)break;\n        //cout<<m.size()<<' '<<cost<<endl;\n        r(i,13)if(now[i]!=0){\n            r(j,v[i].size()){\n                swap(now[i],now[v[i][j]]);\n                int yy=ha(now);\n                if(!st.count(yy)){\n                    st.insert(yy);\n                    m[yy]=cost+1;\n                    q.push(P(yy,cost+1));\n                }\n                swap(now[i],now[v[i][j]]);\n            }\n        }\n    }\n}\n\nvoid BFS2(){\n    unordered_set<int>st;\n    st.insert(ha(t));\n    queue<P>q;\n    q.push(P(ha(t),0));\n    while(1){\n        vector<int>now=ah(q.front().first);\n        int cost=q.front().second;\n        int y=ha(now);\n        if(m.count(y)){\n            cout<<m[y]+cost<<endl;\n            return ;\n        }\n        q.pop();\n        if(cost==6)break;\n        r(i,13)if(now[i]!=0){\n            r(j,v[i].size()){\n                swap(now[i],now[v[i][j]]);\n                int yy=ha(now);\n                if(!st.count(yy)){\n                    st.insert(yy);\n                    q.push(P(yy,cost+1));\n                }\n                swap(now[i],now[v[i][j]]);\n            }\n        }\n    }\n    cout<<\"NA\"<<endl;\n}\n\n\nsigned main(){\n    init();\n    BFS1();\n    while(cin>>t[0],t[0]!=-1){\n        r(i,12)cin>>t[i+1];\n        BFS2();\n    }\n}\n"
  },
  {
    "language": "C++",
    "code": "#include <iostream>\n#include <vector>\n#include <algorithm>\n#include <string>\n#include <sstream>\n#include <cstring>\n#include <cstdio>\n#include <cstdlib>\n#include <cmath>\n#include <queue>\n#include <stack>\n#include <map>\n#include <set>\n#include <numeric>\n#include <cctype>\n#include <tuple>\n\n#ifdef _MSC_VER\n#include <agents.h>\n#endif\n\n#define FOR(i, a, b) for(int i = (a); i < (int)(b); ++i)\n#define rep(i, n) FOR(i, 0, n)\n#define ALL(v) v.begin(), v.end()\n#define REV(v) v.rbegin(), v.rend()\n#define MEMSET(v, s) memset(v, s, sizeof(v))\n#define X first\n#define Y second\n\nusing namespace std;\n\ntypedef long long ll;\ntypedef pair<int, int> P;\n\nconst int N = 0;\n\ninline int dist(int x1, int y1, int x2, int y2){\n\treturn abs(x1 - x2) + abs(y1 - y2);\n}\n\ninline bool valid(int x, int y){\n\treturn abs(x - 2) + abs(y - 2) <= 2;\n}\n\nvoid decode(ll x);\n\nll mov(ll state, int zero, int to){\n\tll mask = 15ll << to*4;\n\tmask &= state;\n\tstate ^= mask;\n\tint d = to - zero;\n\tif (d < 0) state |= mask << -d*4;\n\telse state |= mask >> d*4;\n\treturn state;\n}\n\nvoid decode(ll x){\n\tvector<string> vs;\n\trep(i, 5){\n\t\tstring s;\n\t\trep(j, 5){\n\t\t\tif (valid(j, i)){\n\t\t\t\tint tmp = x & 15;\n\t\t\t\ts += \" \";\n\t\t\t\ts += '0' + tmp % 10;\n\t\t\t\ts += '0' + tmp / 10;\n\t\t\t\tx >>= 4;\n\t\t\t}\n\t\t\telse{\n\t\t\t\ts += \" ..\";\n\t\t\t}\n\t\t}\n\t\tvs.push_back(string(REV(s)));\n\t}\n\treverse(ALL(vs));\n\tfor (auto &s : vs){\n\t\tcout << s << endl;\n\t}\n}\n\nint mat[5][5];\n\nstruct state{\n\tll enc;\n\tint d;\n\tint pos[2];\n\tstate(ll e, int p0, int p1, int d) :enc(e), d(d){ pos[0] = p0, pos[1] = p1; };\n};\n\nint main(){\n\n\tint pos = 0;\n\tvector<vector<int>> adj;\n\t{\n\t\tint tmp = 0;\n\t\trep(i, 5) rep(j, 5) if (valid(j, i)) mat[i][j] = tmp++;\n\t}\n\trep(i, 5) rep(j, 5){\n\t\tvector<int> v;\n\t\tif (!valid(j, i)) continue;\n\t\trep(k, 5) rep(l, 5){\n\t\t\tif (!valid(l, k)) continue;\n\t\t\tif (dist(j, i, l, k) != 1) continue;\n\t\t\tv.push_back(mat[k][l]);\n\t\t}\n\t\tadj.push_back(v);\n\t}\n\n\tll init = 0;\n\tint tmp = 0;\n\trep(i, 5) rep(j, 5){\n\t\tif (!valid(j, i)) continue;\n\t\tinit <<= 4;\n\t\tinit |= (tmp++) % 12;\n\t}\n\n\tmap<ll, int> m;\n\tm[init] = 0;\n\tqueue<state> q;\n\tq.push({ init, 0, 12, 0 });\n\twhile (!q.empty()){\n\t\tstate s = q.front();\n\t\tq.pop();\n\n\t\trep(i, 2){\n\t\t\tfor (auto to : adj[s.pos[i]]){\n\t\t\t\tll nxt = mov(s.enc, s.pos[i], to);\n\t\t\t\tif (m.count(nxt)) continue;\n\t\t\t\tm[nxt] = s.d + 1;\n\t\t\t\tif (s.d + 1 < 10) q.push({ nxt, s.pos[!i], to, s.d + 1 });\n\t\t\t}\n\t\t}\n\t}\n\n\tll x;\n\twhile (cin >> x, ~x){\n\t\tvector<int> zero;\n\t\tint in;\n\t\trep(i, 12){\n\t\t\tcin >> in;\n\t\t\tx = (x << 4) + in;\n\t\t\tif (!in) zero.push_back(i + 1);\n\t\t}\n\t\tif (zero.size() <= 1) zero.push_back(0);\n\t\t//decode(x);\n\n\t\tset<ll> vis;\n\t\tqueue<state> q;\n\t\tq.push({ x, zero[0], zero[1], 0 });\n\t\tint ans = 1000;\n\t\tif (m.count(x)){\n\t\t\tans = m[x];\n\t\t}\n\t\telse\n\t\twhile (!q.empty()){\n\t\t\tstate s = q.front();\n\t\t\tq.pop();\n\n\t\t\trep(i, 2){\n\t\t\t\tfor (auto to : adj[s.pos[i]]){\n\t\t\t\t\tll nxt = mov(s.enc, s.pos[i], to);\n\t\t\t\t\tif (vis.count(nxt)) continue;\n\t\t\t\t\tvis.insert(nxt);\n\t\t\t\t\tif (m.count(nxt)){\n\t\t\t\t\t\tans = min(ans, s.d + m[nxt] + 1);\n\t\t\t\t\t\tgoto end;\n\t\t\t\t\t}\n\t\t\t\t\tif (s.d + 1 < 12) q.push({ nxt, s.pos[!i], to, s.d + 1 });\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\tend:\n\t\tif (ans <= 20) cout << ans << endl;\n\t\telse cout << \"NA\" << endl;\n\t}\n\n\n\treturn 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include <iostream>\n#include <algorithm>\n#include <vector>\n#include <queue>\n#include <map>\nusing namespace std;\n#define rep(i,n) for(int i=0;i<n;i++)\nclass NODE{\npublic:\n\tvector<int> data;\n\tint depth;\n\tint e[2];\n\tNODE(int a[13],int d,int E[2]){\n\t\tdata.resize(13);\n\t\trep(i,13)data[i] = a[i];\n\t\tdepth = d;\n\t\trep(i,2)e[i] = E[i];\n\t}\n\tNODE(){\n\t\tdepth = 0;\n\t\tdata.resize(13);\n\t}\n};\n\nint di[13][10] = {\n\t{2,-1},\n\t{2,5,-1},\n\t{0,1,3,6,-1},\n\t{2,7,-1},\n\t{5,-1},\n\t{1,4,6,9,-1},\n\t{2,5,7,10,-1},\n\t{3,6,7,11,-1},\n\t{7},\n\t{5,10,-1},\n\t{6,9,11,12,-1},\n\t{7,10,-1},\n\t{10,-1}\n};\nint rx[] = {3,2,3,4,1,2,3,4,5,2,3,4,3};\nint ry[] = {1,2,2,2,3,3,3,3,3,4,4,4,5};\n\nint main(){\n\twhile(1){\n\t\tint ret = 21;\n\t\tNODE fst; int cnt = 0;\n\t\trep(i,13){\n\t\t\tif(cin >>fst.data[i] , fst.data[i] != -1){\n\t\t\t\tif(fst.data[i] == 0){\n\t\t\t\t\tfst.e[cnt] = i;\n\t\t\t\t\tcnt++;\n\t\t\t\t}\n\t\t\t}else{\n\t\t\t\treturn 0;\n\t\t\t}\n\t\t}\n\t\tmap< vector<int> , int > done;\n\t\t\n\t\tqueue<NODE> Q;\n\t\tQ.push(fst);\n\t\tdone[Q.front().data] = 0;\n\t\t\n\t\twhile(Q.size()){\n\t\t\tNODE q = Q.front(); Q.pop();\n\n\t\t\tint mndist = 0;\n\t\t\trep(i,13)mndist += abs(rx[q.data[i]]-rx[i]) + abs(ry[q.data[i]]-ry[i]);\n\t\t\t\n\t\t\tif(mndist + q.depth > 20)continue;\n\t\t\t\n\t\t\tif( q.data[0] == 0 && q.data[1] == 1 && q.data[2] == 2 && q.data[3] == 3 && q.data[4] == 4 && q.data[5] == 5 && q.data[6] == 6 && q.data[7] == 7 &&\n\t\t\t\t\tq.data[8] == 8 && q.data[9] == 9 && q.data[10]==10 && q.data[11]==11 && q.data[12]==0\n\t\t\t){\n\t\t\t\tcout << q.depth << endl;\n\t\t\t\tgoto jmp;\n\t\t\t}\n\n\t\t\trep(o,2){\n\t\t\t\tfor(int i=0;di[q.e[o]][i] != -1;i++){\n\t\t\t\t\tNODE next = q;\n\t\t\t\t\tnext.e[o] = next.data[di[q.e[o]][i]];\n\t\t\t\t\tswap(next.data[q.e[o]] , next.data[di[q.e[o]][i]]);\n\t\t\t\t\tnext.depth = q.depth + 1;\n\t\t\t\t\t\n\t\t\t\t\tif( done.find(next.data) == done.end() ){\n\t\t\t\t\t\tdone[next.data] = next.depth;\n\t\t\t\t\t\tif( q.depth < 20)Q.push(next);\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t\tcout << \"NA\" << endl;\n\t\tjmp:;\n\t}\n}"
  },
  {
    "language": "C++",
    "code": "#include<stdio.h>\n#include<map>\n#include<queue>\ntypedef long long L;\nL S(L l,int a,int b)\n{\n\tL c=(l>>(a*4))&15;\n\tl&=~(15LL<<(a*4));\n\tL d=(l>>(b*4))&15;\n\tl&=~(15LL<<(b*4));\n\treturn l|(c<<(b*4))|(d<<(a*4));\n}\nint main()\n{\n\tconst int di[13][4]={\n\t\t{3},\n\t\t{3,6},\n\t\t{1,2,4,7},\n\t\t{3,8},\n\t\t{6},\n\t\t{2,5,7,10},\n\t\t{3,6,8,11},\n\t\t{4,7,9,12},\n\t\t{8},\n\t\t{6,11},\n\t\t{7,10,12,13},\n\t\t{8,11},\n\t\t{11}};\n\ttypedef std::map<L,int>M;\n\tM m;\n\tM::iterator ite;\n\tstd::queue<L>q;\n\tq.push(0xBA9876543210);\n\tq.push(-1);\n\tint i,j,k;\n\tfor(int x=0;x<=20;)\n\t{\n\t\tL l=q.front();\n\t\tq.pop();\n\t\tif(l<0)\n\t\t{\n\t\t\tq.push(l);\n\t\t\t++x;\n\t\t\tcontinue;\n\t\t}\n\t\tite=m.find(l);\n\t\tif(ite!=m.end())continue;\n\t\tm[l]=x;\n\t\tint a[2];\n\t\tfor(i=j=0;i<13;++i)\n\t\t\tif( !(l&(15LL<<(i*4))) )\n\t\t\t\ta[j++]=i;\n\t\tfor(k=0;k<2;++k)\n\t\t\tfor(i=0;i<4;++i)\n\t\t\t{\n\t\t\t\tint c=di[a[k]][i];\n\t\t\t\tif(c)\n\t\t\t\t{\n\t\t\t\t\tL t=S(l,a[k],c-1);\n\t\t\t\t\tq.push(t);\n\t\t\t\t}\n\t\t\t\telse break;\n\t\t\t}\n\t}\n\tfor(;;)\n\t{\n\t\tL l=0,x;\n\t\tfor(i=0;i<13;++i)\n\t\t{\n\t\t\tif(scanf(\"%lld\",&x),x<0)return 0;\n\t\t\tl|=(x<<(i*4));\n\t\t}\n\t\tite=m.find(l);\n\t\tite==m.end()?puts(\"NA\"):printf(\"%d\\n\",ite->second);\n\t}\n}"
  },
  {
    "language": "C++",
    "code": "#include <cstdio>\n#include <cstring>\n#include <algorithm>\n#include <string>\n#include <cmath>\n#include <stack>\n#include <vector>\n#include <map>\n#include <set>\n#include <queue>\n#include <list>\n#include <iostream>\n#include <sstream>\n#include <climits>\n#include <cfloat>\n#include <complex>\n\nusing namespace std;\n\ntypedef long long ll;\n\nll encode(int* state)\n{\n\tll res = 0;\n\tfor (int i = 0; i < 13; ++i)\n\t\tres = res << 4 | state[i];\n\treturn res;\n}\nvoid decode(int* d, ll e)\n{\n\tfor (int i = 12; i >= 0; --i, e >>= 4)\n\t\td[i] = e & 15;\n}\nvoid p(ll s)\n{\n\tint d[13];\n\tdecode(d, s);\n\tfor (int i = 0; i < 13; ++i)\n\t\tprintf(\"%d \", d[i]);\n\tprintf(\"\\n\");\n}\n\nint main()\n{\n\tmap<ll, int> minSteps;\n\tint dir[] = { -1, 1, -2, 2, -4, 4 };\n\tmap<int, bool> ok[3];\n\n\tint o[][9] = {\n\t\t{ 1, 2, 4, 5, 6, 7, 9, 10, -1 },\n\t\t{ 0, 10, -1 },\n\t\t{ 1, 2, 3, 5, 6, 7, -1 }\n\t};\n\tfor (int i = 0; i < 3; ++i)\n\t\tfor (int j = 0; o[i][j] != -1; ++j)\n\t\t\tok[i][o[i][j]] = true;\n\n\tint initial[] = { 0, 1, 2, 3, 4, 5, 6, 7, 8, 9, 10, 11, 0 };\n\tll t = encode(initial);\n\tminSteps[t] = 0;\n\tqueue<ll> q;\n\tq.push(t);\n\n\twhile (!q.empty())\n\t{\n\t\tll e = q.front();\n\t\tq.pop();\n\t\tint d[13];\n\t\tdecode(d, e);\n\n\t\tint zero_pos[2];\n\t\tfor (int i = 0, j = 0; j < 2; ++i)\n\t\t\tif (!d[i])\n\t\t\t\tzero_pos[j++] = i;\n\n\t\tfor (int i = 0; i < 2; ++i)\n\t\t{\n\t\t\tfor (int j = 0; j < 6; ++j)\n\t\t\t{\n\t\t\t\tint a = zero_pos[i];\n\t\t\t\tint b = a + dir[j];\n\t\t\t\tif (a > b)\n\t\t\t\t\tswap(a, b);\n\t\t\t\tif (a < 0 || b > 12 || !d[a] && !d[b] || !ok[j/2][a])\n\t\t\t\t\tcontinue;\n\n\t\t\t\tint copy[13];\n\t\t\t\tmemcpy(copy, d, sizeof(copy));\n\t\t\t\tswap(copy[a], copy[b]);\n\t\t\t\tll next = encode(copy);\n\n\t\t\t\tif (!minSteps.count(next))\n\t\t\t\t{\n\t\t\t\t\tminSteps[next] = minSteps[e] + 1;\n\t\t\t\t\tif (minSteps[next] < 10)\n\t\t\t\t\t\tq.push(next);\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t}\n\n\twhile (true)\n\t{\n\t\tint d[13];\n\t\tfor (int i = 0; i < 13; ++i)\n\t\t\tscanf(\"%d\", d + i);\n\t\tif (d[0] == -1)\n\t\t\tbreak;\n\n\t\tint ans = -1;\n\t\tll s = encode(d);\n\t\tif (minSteps.count(s))\n\t\t\tans = minSteps[s];\n\t\telse\n\t\t{\n\t\t\tmap<ll, int> c;\n\t\t\tc[s] = 0;\n\t\t\tq.push(s);\n\t\t\twhile (!q.empty())\n\t\t\t{\n\t\t\t\tll e = q.front();\n\t\t\t\tq.pop();\n\t\t\t\tint d[13];\n\t\t\t\tdecode(d, e);\n\n\t\t\t\tint zero_pos[2];\n\t\t\t\tfor (int i = 0, j = 0; j < 2; ++i)\n\t\t\t\t\tif (!d[i])\n\t\t\t\t\t\tzero_pos[j++] = i;\n\n\t\t\t\tfor (int i = 0; i < 2; ++i)\n\t\t\t\t{\n\t\t\t\t\tfor (int j = 0; j < 6; ++j)\n\t\t\t\t\t{\n\t\t\t\t\t\tint a = zero_pos[i];\n\t\t\t\t\t\tint b = a + dir[j];\n\t\t\t\t\t\tif (a > b)\n\t\t\t\t\t\t\tswap(a, b);\n\t\t\t\t\t\tif (a < 0 || b > 12 || !d[a] && !d[b] || !ok[j/2][a])\n\t\t\t\t\t\t\tcontinue;\n\n\t\t\t\t\t\tint copy[13];\n\t\t\t\t\t\tmemcpy(copy, d, sizeof(copy));\n\t\t\t\t\t\tswap(copy[a], copy[b]);\n\t\t\t\t\t\tll next = encode(copy);\n\n\t\t\t\t\t\tif (minSteps.count(next))\n\t\t\t\t\t\t{\n\t\t\t\t\t\t\tans = 10 + c[e] + 1;\n\t\t\t\t\t\t\tgoto End;\n\t\t\t\t\t\t}\n\t\t\t\t\t\tif (!c.count(next) && c[e] < 10)\n\t\t\t\t\t\t{\n\t\t\t\t\t\t\tc[next] = c[e] + 1;\n\t\t\t\t\t\t\tq.push(next);\n\t\t\t\t\t\t}\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t}\n\t\t}\nEnd:\n\t\tif (ans != -1)\n\t\t\tprintf(\"%d\\n\", ans);\n\t\telse\n\t\t\tputs(\"NA\");\n\t}\n\n\treturn 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include<iostream>\n#include<cmath>\n#include<stdio.h>\nusing namespace std;\n \n#define LIMIT 20\n \nstruct Puzzle {\n  int cont[25];\n  int space[2];\n};\n \nint limit;\n \nPuzzle puzzle;\n \nint tx[12]={0,1,2,3,0,1,2,3,4,1,2,3};\nint ty[12]={0,1,1,1,2,2,2,2,2,3,3,3};\nint dx[4]={0,1,0,-1};\nint dy[4]={-1,0,1,0};\n \nint heuris[12][25];\n \nint getHeuristic(){\n  int res=0;\n  for(int i=0;i<25;i++){\n    if(puzzle.cont[i]==-1||puzzle.cont[i]==0)continue;\n    res+=heuris[puzzle.cont[i]][i];\n  }\n  return res;\n}\n \nbool dfs(int depth,int prev0,int prev1){\n   \n  int heuri;\n  heuri=getHeuristic();\n  /*\n  cout<<depth<<' '<<heuri<<endl;\n  for(int i=0;i<5;i++){\n    for(int j=0;j<5;j++){\n      if(puzzle.cont[i*5+j]!=-1)printf(\"%3d\",puzzle.cont[i*5+j]);\n      else cout<<\"???\";\n    }\n    cout<<endl;\n  }\n  */\n  if(heuri==0){\n    cout<<depth<<endl;\n    return true;\n  }\n  if(depth + heuri>limit)return false;\n \n  int px,py,nx,ny;\n  Puzzle tmp=puzzle;\n \n  py=puzzle.space[0]/5;\n  px=puzzle.space[0]%5;\n  for(int i=0;i<4;i++){\n    if(max(prev0,i)-min(prev0,i)==2)continue;\n    ny=py+dy[i];nx=px+dx[i];\n    if(ny<0||ny>=5||nx<0||nx>=5)continue;\n    if(puzzle.cont[ny*5+nx]==-1)continue;\n    if(puzzle.cont[ny*5+nx]==0)continue;\n    puzzle.cont[py*5+px]=puzzle.cont[ny*5+nx];\n    puzzle.cont[ny*5+nx]=0;\n    puzzle.space[0]=ny*5+nx;\n    if(dfs(depth+1,i,-100))return true;\n    puzzle=tmp;\n  }\n \n  py=puzzle.space[1]/5;\n  px=puzzle.space[1]%5;\n  for(int i=0;i<4;i++){\n    if(max(prev1,i)-min(prev1,i)==2)continue;\n    ny=py+dy[i];nx=px+dx[i];\n    if(ny<0||ny>=5||nx<0||nx>=5)continue;\n    if(puzzle.cont[ny*5+nx]==-1)continue;\n    if(puzzle.cont[ny*5+nx]==0)continue;\n    puzzle.cont[py*5+px]=puzzle.cont[ny*5+nx];\n    puzzle.cont[ny*5+nx]=0;\n    puzzle.space[1]=ny*5+nx;\n    if(dfs(depth+1,-100,i))return true;\n    puzzle=tmp;\n  }\n  return false;\n}\n \nvoid solve(){\n  Puzzle tmp=puzzle;\n  for(limit=getHeuristic();limit<=LIMIT;limit+=2){\n    puzzle=tmp;\n    if(dfs(0,-100,-100))return;\n  }\n  cout<<\"NA\"<<endl;\n}\n \nint main(){\n  int x,y,c=0;\n \n  for(int i=1;i<=11;i++){\n    for(int j=0;j<25;j++){\n      y=j/5;\n      x=j%5;\n      heuris[i][j]=abs(tx[i]-x)+abs(ty[i]-y);\n    }\n  }\n  /*\n  for(int i=1;i<=11;i++){\n    for(int j=0;j<5;j++){\n      for(int k=0;k<5;k++){\n    cout<<heuris[i][j*5+k]<<' ';\n      }\n      cout<<endl;\n    }\n    cout<<endl;\n  }\n  */\n \n \n  while(1){\n    c=0;\n    for(int i=0;i<25;i++)puzzle.cont[i]=-1;\n \n    cin>>puzzle.cont[2];\n    if(puzzle.cont[2]==-1)break;\n    if(puzzle.cont[2]==0)puzzle.space[c++]=2;\n     \n     \n    for(int i=6;i<=8;i++){\n      cin>>puzzle.cont[i];\n      if(puzzle.cont[i]==0)puzzle.space[c++]=i;\n    }\n    for(int i=10;i<=14;i++){\n      cin>>puzzle.cont[i];\n      if(puzzle.cont[i]==0)puzzle.space[c++]=i;\n    }\n     \n    for(int i=16;i<=18;i++){\n      cin>>puzzle.cont[i];\n      if(puzzle.cont[i]==0)puzzle.space[c++]=i;\n    }\n     \n    cin>>puzzle.cont[22];\n    if(puzzle.cont[22]==0)puzzle.space[c++]=22;\n    solve();\n  }\n \n  return 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include <iostream>\n#include <algorithm>\n#include <vector>\n#include <cstring>\n#include <cstdio>\n#include <climits>\n\nusing namespace std;\n\n/*\n#define REP(i,a,n) for(int i=(a); i<(int)(n); i++)\n#define rep(i,n) REP(i,0,n)\n#define DEB 0\n\nint board[7][7]; //1base\nint sx[2], sy[2];\nstatic const int dx[] = {0,0,1,-1};\nstatic const int dy[] = {1,-1,0,0};\n\nint calc(int y, int x){\n    switch(board[y][x]){\n    case 1: return abs(2-y)+abs(2-x);\n    case 2: return abs(2-y)+abs(3-x);\n    case 3: return abs(2-y)+abs(4-x);\n    case 4: return abs(3-y)+abs(1-x);\n    case 5: return abs(3-y)+abs(2-x);\n    case 6: return abs(3-y)+abs(3-x);\n    case 7: return abs(3-y)+abs(4-x);\n    case 8: return abs(3-y)+abs(5-x);\n    case 9: return abs(4-y)+abs(2-x);\n    case 10: return abs(4-y)+abs(3-x);\n    case 11: return abs(4-y)+abs(4-x);\n    }\n    return -1;\n}\nint dist(void){\n    int ret = 0;\n    if( board[1][3] ) ret += calc(1,3);\n    rep(i,3) if( board[2][2+i] ) ret += calc(2,2+i);\n    rep(i,5) if( board[3][1+i] ) ret += calc(3,1+i);\n    rep(i,3) if( board[4][2+i] ) ret += calc(4,2+i);\n    if( board[5][3] ) ret += calc(5,3);\n    return ret;\n}\nbool isgoal(void){\n    if( board[1][3]!=0 ) return false;\n    rep(i,3) if( board[2][2+i]!=i+1 ) return false;\n    rep(i,5) if( board[3][1+i]!=i+4 ) return false;\n    rep(i,3) if( board[4][2+i]!=i+9 ) return false;\n    if( board[5][3]!=0 ) return false;\n    return true;\n}\n\nbool dfs(int cnt, int LIM, int py, int px){\n    if( isgoal() ) return true;\n    if( cnt+dist()>LIM ) return false;\n\n    rep(i,2){\n        rep(k,4){\n            int tx = sx[i] + dx[k];\n            int ty = sy[i] + dy[k];\n            if( board[ty][tx]==-1 || ty==py&&tx==px ) continue;\n            swap(board[sy[i]][sx[i]], board[ty][tx]);\n            swap(sx[i], tx); swap(sy[i],ty);\n            if( dfs(cnt+1, LIM, ty, tx) ) return true;\n            swap(sx[i], tx); swap(sy[i],ty);\n            swap(board[sy[i]][sx[i]] ,board[ty][tx]);\n        }\n    }\n    return false;\n}\nint solve(void){\n    int ttx[2], tty[2];\n    int tb[7][7];\n    rep(i,2) ttx[i]=sx[i], tty[i]=sy[i];\n    rep(i,7)rep(j,7) tb[i][j] = board[i][j];\n\n    for(int lim = 0; lim < 21; lim++){\n        rep(i,2) sx[i]=ttx[i], sy[i]=tty[i];\n        rep(i,7) rep(j,7) board[i][j] = tb[i][j];\n        if( dfs(0,lim,-1,-1) ) return lim;\n    }\n    return -1;\n}\nint main(){\n    for(;;){\n        memset(board, -1, sizeof(board));\n        int sz = 0;\n\n        scanf(\"%d\",&board[1][3]); if( board[1][3]==-1 ) break;\n        rep(i,3) scanf(\"%d\",&board[2][2+i]);\n        rep(i,5) scanf(\"%d\",&board[3][1+i]);\n        rep(i,3) scanf(\"%d\",&board[4][2+i]);\n        scanf(\"%d\",&board[5][3]);\n\n        // find space\n        if( board[1][3]==0 ){ sx[sz]=3; sy[sz]=1; sz++; }\n        rep(i,3) if( board[2][2+i]==0 ) { sx[sz]=2+i; sy[sz]=2; sz++; }\n        rep(i,5) if( board[3][1+i]==0 ) { sx[sz]=1+i; sy[sz]=3; sz++; }\n        rep(i,3) if( board[4][2+i]==0 ) { sx[sz]=2+i; sy[sz]=4; sz++; }\n        if( board[5][3]==0 ){ sx[sz]=3; sy[sz]=5; sz++; }\n\n        //printf(\"hoge:%d\\n\",dist());\n        int ans = solve();\n        if( ans!=-1 ) printf(\"%d\\n\",ans); else puts(\"NA\");\n    }\n    return 0;\n}\n*/\n\n\n//-------------------------------------------------------\n\n#define N 5\n#define REP(i, n) for ( int i = 0; i < (int)n; i++ )\n#define LIMIT 20\n\nstatic const int T[12][2] = {\n    {-1, -1},\n    {1, 1}, \n    {1, 2}, \n    {1, 3},\n    {2, 0},\n    {2, 1},\n    {2, 2},\n    {2, 3},\n    {2, 4},\n    {3, 1}, \n    {3, 2},\n    {3, 3}\n};\nstatic const int g[N][N] = {\n    {-1,-1, 0,-1,-1},\n    {-1, 1, 2, 3,-1},\n    { 4, 5, 6, 7, 8},\n    {-1, 9,10,11,-1}, \n    {-1,-1, 0,-1,-1}\n};\n\nclass Puzzle{\npublic:\n    int C[N][N], mdist; //manhatta distance\n    Puzzle(){}\n\n    bool swapAdj( int si, int sj, int ti, int tj ){\n        if ( ti < 0 || tj < 0 || ti >= N || tj >= N ) return false;\n        if ( C[ti][tj] <= 0 ) return false;\n        swap(C[ti][tj], C[si][sj]);\n        int tti = T[C[si][sj]][0];\n        int ttj = T[C[si][sj]][1];\n        //mdist -= max(tti, ti)-min(tti, ti) + max(ttj, tj)-min(ttj, tj);\n        //mdist += max(tti, si)-min(tti, si) + max(ttj, sj)-min(ttj, sj);\n        //mdist -= abs(tti-ti)+abs(ttj-tj);\n        //mdist += abs(tti-si)+abs(ttj-sj);\n        return true;\n    }\n\n    bool isGoal(){\n        REP(i, N) REP(j, N) if ( g[i][j] != C[i][j] ) return false;\n        return true;\n    }\n\n    int getMD(){ // get initial manhattan distance\n        int sum = 0;\n        int ti, tj;\n        REP(i, 5) REP(j, 5){\n            if ( C[i][j] <= 0 ) continue;\n            ti = T[C[i][j]][0];\n            tj = T[C[i][j]][1];\n            //sum += (max(ti, i)-min(ti, i) + max(tj, j) - min(tj, j));\n            sum += abs(ti-i) + abs(tj-j);\n        }\n        return sum;\n    }\n};\n\nint limit;\n\nbool dfs( int depth, Puzzle P ){\n    if ( P.isGoal() ) return true;\n    if ( depth + P.getMD() > limit ) return false;\n\n    static const int di[4] = {0, -1, 0, 1};\n    static const int dj[4] = {1, 0, -1, 0};\n\n    REP(i, N) REP(j, N){\n        if ( P.C[i][j] != 0 ) continue;\n        REP(r, 4){\n            Puzzle v = P;\n            if ( !v.swapAdj(i, j, i+di[r], j+dj[r]) ) continue;\n            if ( dfs( depth + 1, v ) ) return true;\n        }\n    }\n\n    return false;\n}\n\nint idp(Puzzle source){\n    for ( limit = 0; limit <= LIMIT; limit++ ){\n        //source.mdist = source.getMD();\n        if ( dfs(0, source) ) return limit;\n    }\n    return INT_MAX;\n}\n\nint main(){\n    Puzzle P;\n    int top;\n\n    while(1){\n        cin >> top;\n        if ( top == -1 ) break;\n        REP(j, N) P.C[0][j] = -1;\n        P.C[0][2] = top;\n        for(int i = 1; i < N; i++) REP(j, N){\n                if ( (i == 1 || i == 3) && (j == 0 || j == 4 ) ) P.C[i][j] = -1;\n                else if ( i == 4 && j != 2 ) P.C[i][j] = -1;\n                else cin >> P.C[i][j];\n            }\n\n        int cost = idp(P);\n        if ( cost == INT_MAX ) cout << \"NA\" << endl;\n        else cout << cost << endl;\t\n    }\n\n    return 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include <queue>\n#include <vector>\n#include <iostream>\n#include <algorithm>\nusing namespace std;\nconst int lim = 20;\nconst vector<int> bx = { 0, 4, 1, 1, 1, 2, 2, 2, 2, 2, 3, 3, 3 };\nconst vector<int> by = { 2, 2, 1, 2, 3, 0, 1, 2, 3, 4, 1, 2, 3 };\nstruct state {\n\tvector<int> px, py;\n\tint cost, rem, last1, last2;\n};\nbool operator<(const state& s1, const state& s2) {\n\treturn s1.cost + s1.rem != s2.cost + s2.rem ? s1.cost + s1.rem > s2.cost + s2.rem : s1.rem > s2.rem;\n}\nint eval(vector<int> px, vector<int> py) {\n\tint ret = 0;\n\tfor (int i = 2; i < 13; ++i) {\n\t\tret += abs(px[i] - bx[i]) + abs(py[i] - by[i]);\n\t}\n\treturn ret;\n}\nint main() {\n\tint x;\n\twhile (cin >> x, x != -1) {\n\t\tvector<int> vx(13), vy(13);\n\t\tint zc = 0;\n\t\tvx[x == 0 ? zc : x + 1] = bx[0];\n\t\tvy[x == 0 ? zc : x + 1] = by[0];\n\t\tif (x == 0) ++zc;\n\t\tfor (int i = 1; i < 13; ++i) {\n\t\t\tcin >> x;\n\t\t\tvx[x == 0 ? zc : x + 1] = bx[i == 12 ? 1 : i + 1];\n\t\t\tvy[x == 0 ? zc : x + 1] = by[i == 12 ? 1 : i + 1];\n\t\t\tif (x == 0) ++zc;\n\t\t}\n\t\tpriority_queue<state> que;\n\t\tque.push(state{ vx, vy, 0, eval(vx, vy), -1, -1 });\n\t\tint ans = -1;\n\t\twhile (!que.empty()) {\n\t\t\tstate u = que.top();\n\t\t\tque.pop();\n\t\t\tif (u.rem == 0) {\n\t\t\t\tans = u.cost;\n\t\t\t\tbreak;\n\t\t\t}\n\t\t\tfor (int i = 0; i < 2; ++i) {\n\t\t\t\tfor (int j = 2; j < 13; ++j) {\n\t\t\t\t\tif (i == u.last1 && j == u.last2) continue;\n\t\t\t\t\tif (abs(u.px[i] - u.px[j]) + abs(u.py[i] - u.py[j]) == 1) {\n\t\t\t\t\t\tswap(u.px[i], u.px[j]);\n\t\t\t\t\t\tswap(u.py[i], u.py[j]);\n\t\t\t\t\t\tint ev = eval(u.px, u.py);\n\t\t\t\t\t\tif (u.cost + ev + 1 <= lim) {\n\t\t\t\t\t\t\tque.push(state{ u.px, u.py, u.cost + 1, eval(u.px, u.py), i, j });\n\t\t\t\t\t\t}\n\t\t\t\t\t\tswap(u.px[i], u.px[j]);\n\t\t\t\t\t\tswap(u.py[i], u.py[j]);\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t\tif (ans != -1) cout << ans << endl;\n\t\telse cout << \"NA\" << endl;\n\t}\n\treturn 0;\n}\n"
  },
  {
    "language": "C++",
    "code": "#include \"bits/stdc++.h\"\n#include<unordered_map>\n#include<unordered_set>\n#pragma warning(disable:4996)\nusing namespace std;\nusing ld = long double;\ntemplate<class T>\nusing Table = vector<vector<T>>;\nconst ld eps=1e-9;\n\n//// < \"D:\\D_Download\\Visual Studio 2015\\Projects\\programing_contest_c++\\Debug\\a.txt\" > \"D:\\D_Download\\Visual Studio 2015\\Projects\\programing_contest_c++\\Debug\\b.answer\"\n\nvector<vector<int>>ans = vector<vector<int>>{\n\tvector<int>{-1,-1,-1,-1,-1,-1,-1},\n\tvector<int>{-1,-1,-1,0,-1,-1,-1},\n\tvector<int>{-1,-1,1,2,3,-1,-1},\n\tvector<int>{-1,4,5,6,7,8,-1},\n\tvector<int>{-1,-1,9,10,11,-1,-1},\n\tvector<int>{-1,-1,-1,0,-1,-1,-1},\n\tvector<int>{-1,-1,-1,-1,-1,-1,-1},\n};\n\n#include<unordered_map>\nclass HashVI {  // ???????????\\??¢??°???????????§??????\npublic:\n\tsize_t operator()(const vector<int> &x) const {\n\t\tconst int C = 997;      // ?´???°\n\t\tsize_t t = 0;\n\t\tfor (int i = 0; i != x.size(); ++i) {\n\t\t\tt = t * C + x[i];\n\t\t}\n\t\treturn t;\n\t}\n\tsize_t operator()(const vector<vector<int>> &x) const {\n\t\tconst int C = 997;      // ?´???°\n\t\tsize_t t = 0;\n\t\tfor (int i = 0; i != x.size(); ++i) {\n\t\t\tfor (int j = 0; j < x[i].size(); ++j) {\n\t\t\t\tt = t * C + x[i][j];\n\t\t\t}\n\t\t}\n\t\treturn t;\n\t}\n};\nint dx[] = { -1,0,1,0 };\nint dy[] = { 0,1,0,-1 };\nint solve(const vector<vector<int>>&start) {\n\tif (start == ans)return 0;\n\tset<vector<vector<int>>>mp;\n\tmp.emplace(start);\n\tfor (int t = 0; t < 20; ++t) {\n\t\tset<vector<vector<int>>>nextmp;\n\t\tfor (auto m : mp) {\n\t\t\tfor (int i = 1; i < 6; ++i) {\n\t\t\t\tfor (int j = 1; j < 6; ++j) {\n\t\t\t\t\tif (m[i][j] == 0) {\n\t\t\t\t\t\tfor (int way = 0; way < 4; ++way) {\n\t\t\t\t\t\t\tif (m[i + dy[way]][j + dx[way]]>0) {\n\t\t\t\t\t\t\t\tswap(m[i][j], m[i + dy[way]][j + dx[way]]);\n\t\t\t\t\t\t\t\tif (m == ans)return t + 1;\n\t\t\t\t\t\t\t\tnextmp.emplace(m);\n\t\t\t\t\t\t\t\tswap(m[i][j], m[i + dy[way]][j + dx[way]]);\n\t\t\t\t\t\t\t}\n\t\t\t\t\t\t}\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t\tmp = nextmp;\n\t}\n\treturn -1;\n}\n\nint main() {\n\twhile (1) {\n\t\tint a; cin >> a;\n\t\tif (a == -1)break;\n\t\tvector<vector<int>>puzzle(7, vector<int>(7,-1));\n\t\tpuzzle[1][3] = a;\n\t\tfor (int i = 2; i <= 5; ++i) {\n\t\t\tfor (int j = 3 - (2-(abs(i - 3))); j <= 3 + (2-abs(i - 3)); ++j) {\n\t\t\t\tcin >> puzzle[i][j];\n\t\t\t}\n\t\t}\n\t\tint ans = solve(puzzle);\n\t\tif (ans == -1)cout << \"NA\" << endl;\n\t\telse cout << ans << endl;\n\t}\n\treturn 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include<iostream>\n#include<algorithm>\n#include<vector>\n#include<cmath>\nusing namespace std;\n#define MAX_N 20\n#define WIDTH 100\nint OK[5][5] = { {0,0,1,0,0},{0,1,1,1,0},{1,1,1,1,1},{0,1,1,1,0},{0,0,1,0,0} };\nint dx[4] = { 1,0,-1,0 }, dy[4] = { 0,1,0,-1 };\npair<int, vector<vector<int>>> dp[MAX_N + 2][WIDTH], E[WIDTH * 10];\n\nint score(vector<vector<int>>p) {\n\tint sum = 0; pair<int, int>a[12], b[12]; int CNT = 0;\n\tfor (int i = 0; i < 25; i++) {\n\t\tif (p[i / 5][i % 5] >= 1)a[p[i / 5][i % 5]] = make_pair(i / 5, i % 5);\n\t}\n\tfor (int i = 5; i < 20; i++) {\n\t\tif (OK[i / 5][i % 5] == 1) { CNT++; b[CNT] = make_pair(i / 5, i % 5); }\n\t}\n\tfor (int i = 1; i <= 11; i++) { sum += abs(a[i].first - b[i].first) + abs(a[i].second - b[i].second); }\n\treturn sum;\n}\nvector<vector<int>> Move(vector<vector<int>>p, int x, int y,int dir) {\n\tswap(p[x + dx[dir]][y + dy[dir]], p[x][y]); return p;\n}\nint BeemSearch(vector<vector<int>>Z) {\n\tvector<vector<int>>GOAL; int CNT = 0;\n\tfor (int i = 0; i < 5; i++) { vector<int>GOAL2(5, -1); GOAL.push_back(GOAL2); }\n\tfor (int i = 5; i < 20; i++) {\n\t\tif (OK[i / 5][i % 5] == 1) { CNT++; GOAL[i / 5][i % 5] = CNT; }\n\t}\n\tGOAL[0][2] = 0; GOAL[4][2] = 0;\n\tif (Z == GOAL)return 0;\n\tdp[0][0] = make_pair(score(Z), Z);\n\tfor (int i = 0; i < MAX_N; i++) {\n\t\tint CNTS = 0;\n\t\tfor (int j = 0; j < WIDTH; j++) {\n\t\t\tif (dp[i][j].second.size() == 0)continue;\n\t\t\tvector<vector<int>>D = dp[i][j].second;\n\t\t\tfor (int k = 0; k < 25; k++) {\n\t\t\t\tif (D[k / 5][k % 5] != 0)continue;\n\t\t\t\tfor (int l = 0; l < 4; l++) {\n\t\t\t\t\tint cx = (k / 5) + dx[l], cy = (k % 5) + dy[l];\n\t\t\t\t\tif (cx < 0 || cx >= 5 || cy < 0 || cy >= 5)continue;\n\t\t\t\t\tif (D[cx][cy] <= 0)continue;\n\t\t\t\t\tvector<vector<int>>D2 = Move(D, k / 5, k % 5, l);\n\t\t\t\t\tE[CNTS] = make_pair(score(D2), D2); CNTS++;\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t\tsort(E, E + CNTS); dp[i + 1][0] = E[0]; int CNT2 = 1;\n\t\tif (E[0].first == 0)return i + 1;\n\t\tfor (int j = 1; j < CNTS; j++) {\n\t\t\tif (E[j - 1] != E[j]) { dp[i + 1][CNT2] = E[j]; CNT2++; }\n\t\t\tif (CNT2 == WIDTH)break;\n\t\t}\n\t}\n\treturn -1;\n}\nint main() {\n\twhile (true) {\n\t\tfor (int i = 0; i < MAX_N + 2; i++) {\n\t\t\tfor (int j = 0; j < WIDTH; j++) {\n\t\t\t\tvector<vector<int>>ZERO; dp[i][j] = make_pair(0, ZERO);\n\t\t\t}\n\t\t}\n\t\tfor (int i = 0; i < WIDTH * 10; i++) { vector<vector<int>>ZERO; E[i] = make_pair(0, ZERO); }\n\t\tvector<vector<int>>C;\n\t\tfor (int i = 0; i < 5; i++) { vector<int>C2(5, -1); C.push_back(C2); }\n\t\tcin >> C[0][2]; if (C[0][2] == -1)break;\n\t\tfor (int i = 1; i < 4; i++)cin >> C[1][i];\n\t\tfor (int i = 0; i < 5; i++)cin >> C[2][i];\n\t\tfor (int i = 1; i < 4; i++)cin >> C[3][i]; cin >> C[4][2];\n\t\tint ret = BeemSearch(C);\n\t\tif (ret == -1)cout << \"NA\" << endl; else cout << ret << endl;\n\t}\n\treturn 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include <iostream>\n#include <iomanip>\n#include <vector>\n#include <map>\n#include <set>\n#include <queue>\nusing namespace std;\n\n#define NONE -1\n\n// »ÝÌóÔ\nvector < vector <int> > F( 5, vector <int>(5,NONE) );\n// S[\nvector < vector <int> > GOAL( 5, vector <int>(5,NONE) );\n// KâÏÝ\nset < vector < vector <int> > > V;\n// ó«Ìê\nint empty_x[2];\nint empty_y[2];\nint now;\n\nint abs( int n )\n{\n\tif ( n < 0 )\n\t\treturn -n;\n\treturn n;\n}\n\nint getMD()\n{\n\tint md = 0;\n\tfor ( int i = 0; i < 5; i++ ) for ( int j = 0; j < 5; j++ )\n\t{\n\t\tif ( F[i][j] != GOAL[i][j] )\n\t\t{\n\t\t\t// T·\n\t\t\tbool found = false;\n\t\t\tfor ( int k = 0; k < 5; k++ )\n\t\t\t{\n\t\t\t\tfor ( int m = 0; m < 5; m++ )\n\t\t\t\t{\n\t\t\t\t\t//  Á½\n\t\t\t\t\tif ( F[i][j] == GOAL[k][m] )\n\t\t\t\t\t{\n\t\t\t\t\t\tmd += abs(k-i) + abs(m-j);\n\t\t\t\t\t\tfound = true;\n\t\t\t\t\t\tbreak;\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t\tif ( found ) break;\n\t\t\t}\n\t\t}\n\t}\n\treturn md;\n}\n\nbool search( int depth )\n{\n\tif ( F == GOAL )\n\t\treturn true;\n\tif ( now + getMD() > depth )\n\t\treturn false;\n\n\tnow++;\n\tfor ( int e = 0; e < 2; e++ ) for ( int i = -1; i < 2; i++ ) for ( int j = -1; j < 2; j++ )\n\t{\n\t\tif ( i+j == 1 || i+j == -1 )\n\t\t{\n\t\t\tint ox = empty_x[e];\n\t\t\tint oy = empty_y[e];\n\t\t\tint tx = empty_x[e] + i;\n\t\t\tint ty = empty_y[e] + j;\n\n\t\t\tif ( ( tx >= 0 && tx <= 4 ) && ( ty >= 0 && ty <= 4 ) )\n\t\t\t{\n\t\t\t\tif ( F[ty][tx] != 0 && F[ty][tx] != NONE )\n\t\t\t\t{\n\t\t\t\t\t// ®©·\n\t\t\t\t\tswap( F[oy][ox], F[ty][tx] );\n\n\t\t\t\t\t// ¢JÌnÅ éÈçÎ\n\t\t\t\t\tif ( V.find( F ) == V.end() )\n\t\t\t\t\t{\n\t\t\t\t\t\tif ( search( depth ) )\n\t\t\t\t\t\t\treturn true;\n\t\t\t\t\t}\n\n\t\t\t\t\t// ß·\n\t\t\t\t\tswap( F[oy][ox], F[ty][tx] );\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t}\n\tnow--;\n\n}\n\nint main( void )\n{\n\twhile ( 1 )\n\t{\n\t\t// S[ðìé\n\t\tGOAL[0][2] = 0;\n\t\tfor ( int i = 0; i < 3; i++ )\n\t\t\tGOAL[1][1+i] = i+1;\n\t\tfor ( int i = 0; i < 5; i++ )\n\t\t\tGOAL[2][i] = 4 + i;\n\t\tfor ( int i = 0; i < 3; i++ )\n\t\t\tGOAL[3][1+i] = 9 + i;\n\t\tGOAL[4][2] = 0;\n\n\t\t// üÍ\n\t\tcin >> F[0][2];\n\t\tif ( F[0][2] == -1 )\n\t\t\tbreak;\n\t\tfor ( int i = 0; i < 3; i++ )\n\t\t\tcin >> F[1][1+i];\n\t\tfor ( int i = 0; i < 5; i++ )\n\t\t\tcin >> F[2][i];\n\t\tfor ( int i = 0; i < 3; i++ )\n\t\t\tcin >> F[3][1+i];\n\t\tcin >> F[4][2];\n\n\t\t// óðT·\n\t\tint empty_count = 0;\n\t\tfor ( int i = 0; i < 5; i++ )\n\t\t{\n\t\t\tfor ( int j = 0; j < 5; j++ )\n\t\t\t{\n\t\t\t\tif ( F[i][j] == 0 )\n\t\t\t\t{\n\t\t\t\t\tempty_x[empty_count] = j;\n\t\t\t\t\tempty_y[empty_count] = i;\n\t\t\t\t\tempty_count++;\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\n\t\t// ½[»[³DæTõ\n\t\tV.insert( F );\n\t\tnow = 0;\n\t\tbool goal_flag = false;\n\t\tfor ( int i = 0; i < 20; i++ )\n\t\t{\n\t\t\tif ( search( i ) )\n\t\t\t{\n\t\t\t\tgoal_flag = true;\n\t\t\t\tbreak;\n\t\t\t}\n\t\t}\n\n\t\tif ( goal_flag )\n\t\t\tcout << now << endl;\n\t\telse\n\t\t\tcout << \"NA\" << endl;\n\n\t}\n\treturn 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\n\nusing namespace std;\n\ntypedef long long ll;\ntypedef long double ld;\ntypedef tuple<int, int> duo;\nconst int dx[] = {0, 0, 1, -1, 1, 1, -1, -1};\nconst int dy[] = {1, -1, 0, 0, 1, -1, 1, -1};\nconst int Mod = 1000000000 + 0;\n//{{{ templates\n#define TT_             \\\n  template <typename T> \\\n  inline\n#define TTF_                        \\\n  template <typename T, typename F> \\\n  inline\nTT_ T sq(T x) { return x * x; }\nTT_ T In() {\n  T x;\n  cin >> x;\n  return x;\n}\nTT_ void Out(T& x) { cout << x; }\nTT_ void sort(T& v) { sort(begin(v), end(v)); }\nTT_ void revs(T& v) { reverse(begin(v), end(v)); }\nTT_ void uniq(T& v) {\n  sort(v);\n  v.erase(unique(begin(v), end(v)), end(v));\n}\nTT_ int ubnd(T& v, typename T::value_type& x) {\n  return upper_bound(begin(v), end(v), x) - begin(v);\n}\nTT_ int lbnd(T& v, typename T::value_type& x) {\n  return lower_bound(begin(v), end(v), x) - begin(v);\n}\nTTF_ void inpt(T& v, int n, F f) {\n  for (v.reserve(n); n--; v.emplace_back(f()))\n    ;\n}\nTTF_ void show(T& v, F f, string d = \" \", string e = \"\\n\") {\n  int i = 0;\n  for (auto& x : v) i++&&(cout << d), f(x);\n  cout << e;\n}\nTT_ typename T::iterator minel(T& v) { return min_element(begin(v), end(v)); }\nTT_ typename T::iterator maxel(T& v) { return max_element(begin(v), end(v)); }\n\ninline void fast_io() {\n  ios::sync_with_stdio(0);\n  cin.tie(0);\n}\ninline int in() {\n  int x;\n  scanf(\"%d\", &x);\n  return x;\n}\ninline ll pow_mod(ll a, ll k, ll m) {\n  ll r = 1;\n  for (; k > 0; a = a * a % m, k >>= 1)\n    if (k & 1) r = r * a % m;\n  return r;\n}\ninline ll mod_inv(ll a, ll p) { return pow_mod(a, p - 2, p); }\n//}}} priority_queue queue deque front stringstream max_element min_element\n// insert count make_tuple\n\nstruct Board {\n  Board() {\n    memcpy(b, \"0123456789AB0\", sizeof(b));\n    find_zero();\n  }\n  Board(const vector<int>& v) {\n    for (int i = 0; i < 13; i++) b[i] = conv_hex(v[i]);\n    b[13] = 0;\n    find_zero();\n  }\n  void find_zero(){\n    int it = 0;\n    for (int i = 0; i < 13; i++){\n      if (b[i] == '0'){\n        cur[it] = i;\n        it++;\n      }\n    }\n  }\n  char conv_hex(int a) { return \"0123456789ABCDEF\"[a]; }\n  bool slide(int index, int dir) {\n    static const char mov[][4] = {\n      {-1, -1, 2, -1},\n      {-1, 2, 5, -1},\n      {0, 3, 6, 1},\n      {-1, -1, 7, 2},\n      {-1, 5, -1, -1},\n      {1, 6, 9, 4},\n      {2, 7, 10, 5},\n      {3, 8, 11, 6},\n      {-1, -1, -1, 7},\n      {5, 10, -1, -1},\n      {6, 11, 12, 9},\n      {7, -1, -1, 10},\n      {10, -1, -1, -1},\n    };\n    char cu = cur[index];\n    char nu = mov[cu][dir];\n    if (nu == -1) return false;\n    if (b[nu] == '0') return false;\n    swap(b[cu], b[nu]);\n    cur[index] = nu;\n    turn++;\n    return true;\n  }\n  char b[14];\n  char cur[2];\n  char turn;\n};\n\nvoid build_table(unordered_map<ll, char>& ans){\n  Board b;\n  queue<Board> Q;\n  Q.push(b);\n  while (!Q.empty()){\n    Board bi = Q.front();\n    Q.pop();\n    ll hv = strtoll(bi.b, 0, 16);\n    if (ans.count(hv)) continue;\n    ans[hv] = bi.turn;\n    if (bi.turn >= 10) continue;\n    for (int i = 0; i < 2; i++){\n      for (int d = 0; d < 4; d++){\n        auto bii = bi;\n        if (!bii.slide(i, d)) continue;\n        Q.push(bii);\n      }\n    }\n  }\n}\n\nint main() {\n  unordered_map<ll, char> ans;\n  build_table(ans);\n  int h;\n  while (h = in(), h != -1) {\n    vector<int> vs;\n    vs.push_back(h);\n    for (int i = 0; i < 12; i++) vs.push_back(in());\n    Board b(vs);\n    unordered_set<ll> vis;\n    queue<Board> Q;\n    Q.push(b);\n    while (!Q.empty()){\n      Board bi = Q.front();\n      Q.pop();\n      ll hv = strtoll(bi.b, 0, 16);\n      if (vis.count(hv)) continue;\n      vis.insert(hv);\n      if (ans.count(hv)){\n        cout << (int)ans[hv] + (int)bi.turn << endl;\n        goto END;\n      }\n      if (bi.turn >= 9) continue;\n      for (int i = 0; i < 2; i++){\n        for (int d = 0; d < 4; d++){\n          Board bii = bi;\n          if (!bii.slide(i, d)) continue;\n          Q.push(bii);\n        }\n      }\n    }\n    cout << \"NA\\n\";\nEND:;\n  }\n  return 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include<bits/stdc++.h>\nusing namespace std;\n   \ntypedef long long int64;\nconst int INF = 1 << 30;\n   \nvector< int > edge[13];\nmap< string, int > memo;\n  \nbool back(string str, int cnt){ //枝刈り大事だな\n  int X[]={ 2, 1, 2, 3, 0, 1, 2, 3, 4, 1, 2, 3, 2};\n  int Y[]={ 0, 1, 1, 1, 2, 2, 2, 2, 2, 3, 3, 3, 4};\n \n  int diff = 0;\n  for(int i = 0; i < 13; i++){\n    \n    if(str[i] != '0'){\n      int pos = (str[i] >= 'A' ? str[i] - 'A' + 10 : str[i] - '0');\n      diff += abs( X[pos] - X[i]) + abs( Y[pos] - Y[i]);\n    }\n  }\n  return diff + cnt > 20;\n}\n  \n  \nint bfs(string mas){\n  \n  queue< string > que;\n  map< string , int > used;\n  que.push( mas );\n  memo[mas] = 0;\n  while(!que.empty()){\n  \n    string p = que.front(); que.pop();\n    if(back( p, memo[p])) continue;\n    if(p == \"0123456789AB0\") return memo[p];\n  \n    for(int i = 0; i < 13; i++){\n      if(p[i] == '0') {\n        for(int j = 0; j < edge[i].size(); j++){\n          string next = p;\n          swap( next[i], next[edge[i][j]]);\n          if(memo.find(next) != memo.end()) continue;\n          que.push( next );\n          memo[next] = memo[p] + 1;\n        }\n      }\n    }\n  }\n  return -1;\n}\n  \nint main(){\n  vector< int > mas(13);\n  \n  edge[0].push_back(2);\n  edge[1].push_back(2); edge[1].push_back(4);\n  edge[2].push_back(0); edge[2].push_back(1); edge[2].push_back(3); edge[2].push_back(6);\n  edge[3].push_back(2); edge[3].push_back(7);\n  edge[4].push_back(5);\n  edge[5].push_back(1); edge[5].push_back(4); edge[5].push_back(6); edge[5].push_back(9);\n  edge[6].push_back(2); edge[6].push_back(5); edge[6].push_back(7); edge[6].push_back(10);\n  edge[7].push_back(3); edge[7].push_back(6); edge[7].push_back(8); edge[7].push_back(11);\n  edge[8].push_back(7);\n  edge[9].push_back(5); edge[9].push_back(10);\n  edge[10].push_back(6); edge[10].push_back(9); edge[10].push_back(11); edge[10].push_back(12);\n  edge[11].push_back(7); edge[11].push_back(10);\n  edge[12].push_back(10);\n  \n  while(cin >> mas[0], mas[0] != -1){\n    for(int i = 1; i < 13; i++){\n      cin >> mas[i];\n    }\n  \n    string start = \"\";\n    for(int i = 0; i < 13; i++){\n      if(mas[i] >= 10) start += (char)(mas[i] - 10 + 'A');\n      else start += mas[i] + '0';\n    }\n    int ret = bfs(start);\n    if(~ret) cout << ret << endl;\n    else cout << \"NA\" << endl;\n  \n    memo.clear();\n  }\n}"
  },
  {
    "language": "C++",
    "code": "#include<iostream>\n#include<vector>\n#include<queue>\n#include<map>\n#include<cmath>\n#include<cstdlib>\n#include<algorithm>\nusing namespace std;\n\nstring ans;\n\nclass board{\npublic:\n  int h,c;\n  string s;\n  board(int x,int y,string z){ h=x; c=y; s=z;}\n  const bool operator<(const board x)const{return (h+c>x.h+x.c) || (h+c==x.h+x.c && c>x.c); }\n};\n\nint score(string s){\n  int res=0;\n  int o[2];\n  o[0] = -1;\n  o[1] = -1;\n  for(int i=0;i<25;i++){\n    if(s[i]!='x'){\n      int m;\n      if(s[i]!='o'){\n\tfor(int j=0;j<25;j++){\n\t  if(s[i]==ans[j]){\n\t    int a = abs(i-j);\n\t    int tmp = a/5 + a%5;\n\t    m = tmp;\n\t    break;\n\t  }\n\t}\n      }else{\n\tif(o[0]<0){\n\t  for(int j=0;j<25;j++){\n\t    if(s[i]==ans[j]){\n\t      int a =abs(i-j);\n\t      if(o[0]<0)o[0] = a/5+a%5;\n\t      else o[1] = a/5+a%5;\n\t    }\n\t  }\n\t}else{\n\t  m = -1;\n\t  for(int j=0;j<25;j++){\n\t    if(s[i]==ans[j]){\n\t      int a = abs(i-j);\n\t      int tmp = a/5+a%5;\n\t      if(m<0)m = tmp + o[1];\n\t      else m = min(m,tmp+o[0]);\n\t    }\n\t  }\n\t}\n      }\n      res += m;\n    }\n  }\n  return res/2;\n}\n\nchar trans(int x){\n  if(!x)return 'o';\n  else return 'a'+x-1;\n}\n\nint main(){\n  string s;\n  ans = \"xxoxxxabcxdefghxijkxxxoxx\";\n  int tmp,cost;\n\n  for(;;){\n    cin >> tmp;\n    if(tmp<0)break;\n\n    s = \"xx\";\n    s += trans(tmp);\n    s += \"xxx\";\n    for(int i=0;i<3;i++){\n      cin >> tmp;\n      s += trans(tmp);\n    }\n    s += \"x\";\n    for(int i=0;i<5;i++){\n      cin >> tmp;\n      s += trans(tmp);\n    }\n    s += \"x\";\n    for(int i=0;i<3;i++){\n      cin >> tmp;\n      s+= trans(tmp);\n    }\n    s += \"xxx\";\n    cin >> tmp;\n    s += trans(tmp);\n    s += \"xx\";\n\n    priority_queue<board> q1;\n    q1.push(board(score(s),0,s));\n\n    map<string,bool> m1;\n    m1[s] = 0;\n    while(q1.size()){\n      board p = q1.top();q1.pop();\n      int dx[] = {-5,1,5,-1};\n      //cout << p.h << \" \" << p.c << \" \" << p.s << endl;\n      cost = p.c;\n      if(p.s == ans)break;\n      if(cost>20)break;\n\n      for(int i=0;i<25;i++){\n\tif(p.s[i]=='o'){\n\t  for(int j=0;j<4;j++){\n\t    int sx = i + dx[j];\n\t    string str = p.s;\n\t    if(sx<0 || 25<=sx)continue;\n\t    if(str[sx] == 'x' || str[sx] == 'o')continue;\n\t    swap(str[i],str[sx]);\n\t    if(!m1[str]){\n\t      q1.push(board(score(str),cost+1,str));\n\t      m1[str] = cost+1;\n\t    }\n\t  }\n\t}\n      }\n    }\n\n\n\n    if(cost>20)cout << \"NA\\n\";\n    else cout << cost << endl;\n  }\n}"
  },
  {
    "language": "C++",
    "code": "#include <iostream>\n#include <algorithm>\n#include <vector>\n#include <cstring>\n#include <cstdio>\n#include <climits>\n\nusing namespace std;\n\n\n#define REP(i,a,n) for(int i=(a); i<(int)(n); i++)\n#define rep(i,n) REP(i,0,n)\n#define DEB 0\n\nint board[7][7]; //1base\nint sx[2], sy[2];\nstatic const int dx[] = {0,0,1,-1};\nstatic const int dy[] = {1,-1,0,0};\n\nint calc(int y, int x){\n    switch(board[y][x]){\n    case 1: return abs(2-y)+abs(2-x);\n    case 2: return abs(2-y)+abs(3-x);\n    case 3: return abs(2-y)+abs(4-x);\n    case 4: return abs(3-y)+abs(1-x);\n    case 5: return abs(3-y)+abs(2-x);\n    case 6: return abs(3-y)+abs(3-x);\n    case 7: return abs(3-y)+abs(4-x);\n    case 8: return abs(3-y)+abs(5-x);\n    case 9: return abs(4-y)+abs(2-x);\n    case 10: return abs(4-y)+abs(3-x);\n    case 11: return abs(4-y)+abs(4-x);\n    }\n    return -1;\n}\nint dist(void){\n    int ret = 0;\n    if( board[1][3] ) ret += calc(1,3);\n    rep(i,3) if( board[2][2+i] ) ret += calc(2,2+i);\n    rep(i,5) if( board[3][1+i] ) ret += calc(3,1+i);\n    rep(i,3) if( board[4][2+i] ) ret += calc(4,2+i);\n    if( board[5][3] ) ret += calc(5,3);\n    return ret;\n}\nbool isgoal(void){\n    if( board[1][3]!=0 ) return false;\n    rep(i,3) if( board[2][2+i]!=i+1 ) return false;\n    rep(i,5) if( board[3][1+i]!=i+4 ) return false;\n    rep(i,3) if( board[4][2+i]!=i+9 ) return false;\n    if( board[5][3]!=0 ) return false;\n    return true;\n}\n\nbool dfs(int cnt, int LIM, int py, int px){\n    if( isgoal() ) return true;\n    if( cnt+dist()>LIM ) return false;\n\n    rep(i,2){\n        rep(k,4){\n            int tx = sx[i] + dx[k];\n            int ty = sy[i] + dy[k];\n            if( board[ty][tx]==-1 || ty==py&&tx==px ) continue;\n            swap(board[sy[i]][sx[i]], board[ty][tx]);\n            swap(sx[i], tx); swap(sy[i],ty);\n            if( dfs(cnt+1, LIM, ty, tx) ) return true;\n            swap(sx[i], tx); swap(sy[i],ty);\n            swap(board[sy[i]][sx[i]] ,board[ty][tx]);\n        }\n    }\n    return false;\n}\nint solve(void){\n    int ttx[2], tty[2];\n    int tb[7][7];\n    rep(i,2) ttx[i]=sx[i], tty[i]=sy[i];\n    rep(i,7)rep(j,7) tb[i][j] = board[i][j];\n\n    for(int lim = 0; lim < 21; lim++){\n        rep(i,2) sx[i]=ttx[i], sy[i]=tty[i];\n        rep(i,7) rep(j,7) board[i][j] = tb[i][j];\n        if( dfs(0,lim,-1,-1) ) return lim;\n    }\n    return -1;\n}\nint main(){\n    for(;;){\n        memset(board, -1, sizeof(board));\n        int sz = 0;\n\n        scanf(\"%d\",&board[1][3]); if( board[1][3]==-1 ) break;\n        rep(i,3) scanf(\"%d\",&board[2][2+i]);\n        rep(i,5) scanf(\"%d\",&board[3][1+i]);\n        rep(i,3) scanf(\"%d\",&board[4][2+i]);\n        scanf(\"%d\",&board[5][3]);\n\n        // find space\n        if( board[1][3]==0 ){ sx[sz]=3; sy[sz]=1; sz++; }\n        rep(i,3) if( board[2][2+i]==0 ) { sx[sz]=2+i; sy[sz]=2; sz++; }\n        rep(i,5) if( board[3][1+i]==0 ) { sx[sz]=1+i; sy[sz]=3; sz++; }\n        rep(i,3) if( board[4][2+i]==0 ) { sx[sz]=2+i; sy[sz]=4; sz++; }\n        if( board[5][3]==0 ){ sx[sz]=3; sy[sz]=5; sz++; }\n\n        //printf(\"hoge:%d\\n\",dist());\n        int ans = solve();\n        if( ans!=-1 ) printf(\"%d\\n\",ans); else puts(\"NA\");\n    }\n    return 0;\n}\n\n\n\n//-------------------------------------------------------\n/*\n#define N 5\n#define REP(i, n) for ( int i = 0; i < (int)n; i++ )\n#define LIMIT 20\n\nstatic const int T[12][2] = {\n    {-1, -1},\n    {1, 1}, \n    {1, 2}, \n    {1, 3},\n    {2, 0},\n    {2, 1},\n    {2, 2},\n    {2, 3},\n    {2, 4},\n    {3, 1}, \n    {3, 2},\n    {3, 3}\n};\nstatic const int g[N][N] = {\n    {-1,-1, 0,-1,-1},\n    {-1, 1, 2, 3,-1},\n    { 4, 5, 6, 7, 8},\n    {-1, 9,10,11,-1}, \n    {-1,-1, 0,-1,-1}\n};\n\nclass Puzzle{\npublic:\n    int C[N][N], mdist; //manhatta distance\n    Puzzle(){}\n\n    bool swapAdj( int si, int sj, int ti, int tj ){\n        if ( ti < 0 || tj < 0 || ti >= N || tj >= N ) return false;\n        if ( C[ti][tj] <= 0 ) return false;\n        swap(C[ti][tj], C[si][sj]);\n        int tti = T[C[si][sj]][0];\n        int ttj = T[C[si][sj]][1];\n        //mdist -= max(tti, ti)-min(tti, ti) + max(ttj, tj)-min(ttj, tj);\n        //mdist += max(tti, si)-min(tti, si) + max(ttj, sj)-min(ttj, sj);\n        //mdist -= abs(tti-ti)+abs(ttj-tj);\n        //mdist += abs(tti-si)+abs(ttj-sj);\n        return true;\n    }\n\n    bool isGoal(){\n        REP(i, N) REP(j, N) if ( g[i][j] != C[i][j] ) return false;\n        return true;\n    }\n\n    int getMD(){ // get initial manhattan distance\n        int sum = 0;\n        int ti, tj;\n        REP(i, 5) REP(j, 5){\n            if ( C[i][j] <= 0 ) continue;\n            ti = T[C[i][j]][0];\n            tj = T[C[i][j]][1];\n            //sum += (max(ti, i)-min(ti, i) + max(tj, j) - min(tj, j));\n            sum += abs(ti-i) + abs(tj-j);\n        }\n        return sum;\n    }\n};\n\nint limit;\n\nbool dfs( int depth, Puzzle P ){\n    if ( P.isGoal() ) return true;\n    if ( depth + P.getMD() > limit ) return false;\n\n    static const int di[4] = {0, -1, 0, 1};\n    static const int dj[4] = {1, 0, -1, 0};\n\n    REP(i, N) REP(j, N){\n        if ( P.C[i][j] != 0 ) continue;\n        REP(r, 4){\n            Puzzle v = P;\n            if ( !v.swapAdj(i, j, i+di[r], j+dj[r]) ) continue;\n            if ( dfs( depth + 1, v ) ) return true;\n        }\n    }\n\n    return false;\n}\n\nint idp(Puzzle source){\n    printf(\"test:%d\\n\",source.getMD());\n    for ( limit = 0; limit <= LIMIT; limit++ ){\n        //source.mdist = source.getMD();\n        if ( dfs(0, source) ) return limit;\n    }\n    return INT_MAX;\n}\n\nint main(){\n    Puzzle P;\n    int top;\n\n    while(1){\n        cin >> top;\n        if ( top == -1 ) break;\n        REP(j, N) P.C[0][j] = -1;\n        P.C[0][2] = top;\n        for(int i = 1; i < N; i++) REP(j, N){\n                if ( (i == 1 || i == 3) && (j == 0 || j == 4 ) ) P.C[i][j] = -1;\n                else if ( i == 4 && j != 2 ) P.C[i][j] = -1;\n                else cin >> P.C[i][j];\n            }\n\n        int cost = idp(P);\n        if ( cost == INT_MAX ) cout << \"NA\" << endl;\n        else cout << cost << endl;\t\n    }\n\n    return 0;\n}\n*/"
  },
  {
    "language": "C++",
    "code": "#include <iostream>\n#include <queue>\n#include <map>\nusing namespace std;\n\nunsigned long long int makeID( int (&p)[ 13 ] )\n{\n\tunsigned long long int ret = 0;\n\tfor( int i = 0; i < 13; ++i ){\n\t\tret *= 13;\n\t\tret += p[ i ];\n\t}\n\treturn ret;\n}\n\nunsigned long long int slide( unsigned long long int s, int a, int b )\n{\n\tint p[ 13 ];\n\tfor( int i = 0; i < 13; ++i ){\n\t\tp[ 12 - i ] = s % 13;\n\t\ts /= 13;\n\t}\n\tint t = p[ a ];\n\tp[ a ] = p[ b ];\n\tp[ b ] = t;\n\treturn makeID( p );\n}\n\nint side[][ 4 ] = {\n\t{ -1, -1,  2, -1 },\n\t{ -1,  2,  5, -1 },\n\t{  0,  3,  6,  1 },\n\t{ -1, -1,  7,  2 },\n\t{ -1,  5, -1, -1 },\n\t{  1,  6,  9,  4 },\n\t{  2,  7, 10,  5 },\n\t{  3,  8, 11,  6 },\n\t{ -1, -1, -1,  7 },\n\t{  5, 10, -1, -1,},\n\t{  6, 11, 12,  9 },\n\t{  7, -1, -1, 10 },\n\t{ 10, -1, -1, -1 }\n};\n\nint solve( map< unsigned long long int, int >& ans, queue< unsigned long long int >& q, int* p, map< unsigned long long int, int >* sub )\n{\n\tint cnt = 1;\n\twhile( cnt <= 10 ){\n\t\tint size = q.size();\n\t\tfor( int i = 0; i < size; ++i ){\n\t\t\tunsigned long long int s = q.front();\n\t\t\tq.pop();\n\t\t\tint pos[ 2 ], a = 0;\n\t\t\tunsigned long long int t = s;\n\t\t\tfor( int j = 0; j < 13; ++j ){\n\t\t\t\tint b = t % 13;\n\t\t\t\tif( b == 0 ) pos[ a++ ] = 12 - j;\n\t\t\t\tt /= 13;\n\t\t\t}\n\t\t\tfor( int j = 0; j < 2; ++j ){\n\t\t\t\tint b = pos[ j ];\n\t\t\t\tfor( int k = 0; k < 4; ++k ){\n\t\t\t\t\tint c = side[ b ][ k ];\n\t\t\t\t\tif( c == -1 ) continue;\n\t\t\t\t\tt = slide( s, b, c );\n\t\t\t\t\tbool e = ans.find( t ) == ans.end();\n\t\t\t\t\tif( sub == NULL ){\n\t\t\t\t\t\tif( e ){\n\t\t\t\t\t\t\tans[ t ] = cnt;\n\t\t\t\t\t\t\tq.push( t );\n\t\t\t\t\t\t}\n\t\t\t\t\t}else{\n\t\t\t\t\t\tif( !e ){\n\t\t\t\t\t\t\treturn ans[ t ] + cnt;\n\t\t\t\t\t\t}else if( sub->find( t ) == sub->end() ){\n\t\t\t\t\t\t\t(*sub)[ t ] = cnt;\n\t\t\t\t\t\t\tq.push( t );\n\t\t\t\t\t\t}\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t\t++cnt;\n\t}\n\treturn -1;\n}\n\nint main()\n{\n\tmap< unsigned long long int, int > ans;\n\tqueue< unsigned long long int > q;\n\n\n\tint p[ 13 ];\n\tfor( int i = 0; i < 13; ++i ){\n\t\tp[ i ] = i;\n\t}\n\tp[ 12 ] = 0;\n\tunsigned long long int s = makeID( p );\n\tans[ s ] = 0;\n\tq.push( s );\n\n\tsolve( ans, q, p, NULL );\n\n\twhile( !q.empty() )q.pop();\n\n\twhile( cin >> p[ 0 ] && p [ 0 ] != -1 ){\n\t\tfor( int i = 1; i < 13; ++i ){\n\t\t\tcin >> p[ i ];\n\t\t}\n\t\tqueue< unsigned long long int > qq;\n\t\ts = makeID( p );\n\t\tqq.push( s );\n\t\tint r;\n\t\tmap< unsigned long long int, int > u;\n\t\tif( ans.find( s ) != ans.end() ){\n\t\t\tr = ans[ s ];\n\t\t}else{\n\t\t\tr = solve( ans, qq, p, &u );\n\t\t}\n\t\tif( r >= 0 ){\n\t\t\tcout << r << endl;\n\t\t}else{\n\t\t\tcout << \"NA\" << endl;\n\t\t}\n\t}\n\n\treturn 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include<iostream>\n#include<cmath>\n#include<stdio.h>\nusing namespace std;\n\n#define LIMIT 20\n\nstruct Puzzle {\n  int cont[25];\n  int space[2];\n};\n\nint limit;\n\nPuzzle puzzle;\n\nint tx[12]={0,1,2,3,0,1,2,3,4,1,2,3};\nint ty[12]={0,1,1,1,2,2,2,2,2,3,3,3};\nint dx[4]={0,1,0,-1};\nint dy[4]={-1,0,1,0};\n\nint heuris[12][25];\n\nint getHeuristic(){\n  int res=0;\n  for(int i=0;i<25;i++){\n    if(puzzle.cont[i]==-1||puzzle.cont[i]==0)continue;\n    res+=heuris[puzzle.cont[i]][i];\n  }\n  return res;\n}\n\nbool dfs(int depth,int prev0,int prev1){\n  \n  int heuri;\n  heuri=getHeuristic();\n  /*\n  cout<<depth<<' '<<heuri<<endl;\n  for(int i=0;i<5;i++){\n    for(int j=0;j<5;j++){\n      if(puzzle.cont[i*5+j]!=-1)printf(\"%3d\",puzzle.cont[i*5+j]);\n      else cout<<\"???\";\n    }\n    cout<<endl;\n  }\n  */\n  if(heuri==0){\n    cout<<depth<<endl;\n    return true;\n  }\n  if(depth + heuri-1>limit)return false;\n\n  int px,py,nx,ny;\n  Puzzle tmp=puzzle;\n\n  py=puzzle.space[0]/5;px=puzzle.space[0]%5;\n\n  for(int i=0;i<4;i++){\n    if(max(prev0,i)-min(prev0,i)==2)continue;\n    ny=py+dy[i];nx=px+dx[i];\n    if(ny<0||ny>=5||nx<0||nx>=5)continue;\n    if(puzzle.cont[ny*5+nx]==-1)continue;\n    if(puzzle.cont[ny*5+nx]==0)continue;\n    puzzle.cont[py*5+px]=puzzle.cont[ny*5+nx];\n    puzzle.cont[ny*5+nx]=0;\n    puzzle.space[0]=ny*5+nx;\n    if(dfs(depth+1,i,-100))return true;\n    puzzle=tmp;\n  }\n  py=puzzle.space[1]/5;px=puzzle.space[1]%5;\n  for(int i=0;i<4;i++){\n    if(max(prev1,i)-min(prev1,i)==2)continue;\n    ny=py+dy[i];nx=px+dx[i];\n    if(ny<0||ny>=5||nx<0||nx>=5)continue;\n    if(puzzle.cont[ny*5+nx]==-1)continue;\n    if(puzzle.cont[ny*5+nx]==0)continue;\n    puzzle.cont[py*5+px]=puzzle.cont[ny*5+nx];\n    puzzle.cont[ny*5+nx]=0;\n    puzzle.space[1]=ny*5+nx;\n    if(dfs(depth+1,-100,i))return true;\n    puzzle=tmp;\n  }\n  return false;\n}\n\nvoid solve(){\n  Puzzle tmp=puzzle;\n  for(limit=getHeuristic();limit<=LIMIT;limit++){\n    puzzle=tmp;\n    if(dfs(0,-100,-100))return;\n  }\n  cout<<\"NA\"<<endl;\n}\n\nint main(){\n  int x,y,c=0;\n\n  for(int i=1;i<=11;i++){\n    for(int j=0;j<25;j++){\n      y=j/5;\n      x=j%5;\n      heuris[i][j]=abs(tx[i]-x)+abs(ty[i]-y);\n    }\n  }\n  /*\n  for(int i=1;i<=11;i++){\n    for(int j=0;j<5;j++){\n      for(int k=0;k<5;k++){\n\tcout<<heuris[i][j*5+k]<<' ';\n      }\n      cout<<endl;\n    }\n    cout<<endl;\n  }\n  */\n\n\n  while(1){\n    c=0;\n    for(int i=0;i<25;i++)puzzle.cont[i]=-1;\n\n    cin>>puzzle.cont[2];\n    if(puzzle.cont[2]==-1)break;\n    if(puzzle.cont[2]==0)puzzle.space[c++]=2;\n    \n    \n    for(int i=6;i<=8;i++){\n      cin>>puzzle.cont[i];\n      if(puzzle.cont[i]==0)puzzle.space[c++]=i;\n    }\n    for(int i=10;i<=14;i++){\n      cin>>puzzle.cont[i];\n      if(puzzle.cont[i]==0)puzzle.space[c++]=i;\n    }\n    \n    for(int i=16;i<=18;i++){\n      cin>>puzzle.cont[i];\n      if(puzzle.cont[i]==0)puzzle.space[c++]=i;\n    }\n    \n    cin>>puzzle.cont[22];\n    if(puzzle.cont[22]==0)puzzle.space[c++]=22;\n    solve();\n  }\n\n  return 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include<iostream>\n#include<algorithm>\n#include<vector>\n#include<queue>\n#include<unordered_map>\n#define lol(i,n) for(int i=0;i<n;i++)\n#define mod 1000000007\ntypedef long long ll;\nusing namespace std;\nint dx[13][4]={\n  {3,0,0,0},\n  {3,6,0,0},\n  {1,2,4,6},\n  {3,8,0,0},\n  {6,0,0,0},\n  {2,5,7,10},\n  {3,6,8,11},\n  {4,7,9,12},\n  {8,0,0,0},\n  {6,11,0,0},\n  {6,10,12,13},\n  {8,11,0,0},\n  {11,0,0,0}\n};\nunordered_map<ll,int> mp;\nll Compress(int p[]){\n  ll ans=0;\n  for(int i=0;i<13;i++){\n    ans*=13;\n    ans+=p[i];\n  }\n  return ans;\n}\n\nint unzip[13];\nvoid Unzip(ll x){\n  for(int i=0;i<13;i++){\n    unzip[12-i]=x%13;\n    x/=13;\n  }\n}\n\nqueue<pair<ll,int> >Q;\nvoid BFS(int p[],int len){\n  ll tmp=Compress(p);\n  mp[tmp]=len;\n  if(len==21)return;\n  lol(i,13){\n    if(p[i]==0){\n      lol(j,4){\n\tint t=dx[i][j];\n\tif(t==0)break;\n\tt--;\n\tif(p[t]!=0){\n\t  swap(p[i],p[t]);\n\t  Q.push(make_pair(Compress(p),len+1));\n\t  swap(p[i],p[t]);\n\t}\n      }\n    }\n  }\n}\nint main(){\n  int p[13];\n  lol(i,13)p[i]=i;p[12]=0;\n  Q.push(make_pair(Compress(p),1));\n  while(!Q.empty()){\n    ll data=Q.front().first;\n    int len=Q.front().second;\n    Q.pop();\n    if(mp[data]>0)continue;\n    Unzip(data);\n    BFS(unzip,len);\n  }\n  while(cin>>p[0]&&p[0]!=-1){\n    for(int i=1;i<13;i++)cin>>p[i];\n    ll tmp=Compress(p);\n    int cost=mp[tmp];\n    if(cost==0)cout<<\"NA\"<<endl;\n    else cout<<cost-1<<endl;\n  }\n  return 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include <iostream>\n#include <sstream>\n#include <cstdio>\n#include <cstdlib>\n#include <cmath>\n#include <ctime>\n#include <cstring>\n#include <climits>\n#include <algorithm>\n#include <map>\n#include <set>\n#include <stack>\n#include <vector>\n#include <queue>\n#include <bitset>\n#include <string>\nusing namespace std;\n \n#define rep(i,n) for(int i=0; i<n; i++)\n#define repa(i,s,e) for(int i=s; i<=e; i++)\n#define repd(i,s,e) for(int i=s; i>=e; i--)\n#define PB(a) push_back(a)\n#define MP(i,s) make_pair(i,s)\n \ntypedef long long ll;\n\nconst int dx[4] = {-1, 0, 0, 1};\nconst int dy[4] = {0, -1, 1, 0};\nconst int field[5][5] = {\n\t{0, 0, 1, 0, 0}, \n\t{0, 1, 1, 1, 0},\n\t{1, 1, 1, 1, 1},\n\t{0, 1, 1, 1, 0},\n\t{0, 0, 1, 0, 0}, \n};\n\nconst int ans[5][5] = {\n\t{0, 0, 0, 0, 0},\n\t{0, 1, 2, 3, 0},\n\t{4, 5, 6, 7, 8},\n\t{0, 9, 10, 11, 0},\n\t{0, 0, 0, 0, 0}\n};\n\nconst int px[13] = {2, 1, 2, 3, 0, 1, 2, 3, 4, 1, 2, 3, 2};\nconst int py[13] = {0, 1, 1, 1, 2, 2, 2, 2, 2, 3, 3, 3, 4};\n\nll H;\nint P[5][5];\nset<ll> used;\n\nll hash_val() {\n\tll h = 0;\n\trep(i,13) {\n\t\th *= 14;\n\t\th += P[py[i]][px[i]];\n\t}\n\treturn h;\n}\n\nbool dfs(int m, int d) {\n\tll h = hash_val();\n\tif(h == H) \treturn true;\n\tif(m == d) return false;\n\tif(used.find(h) != used.end()) return false;\n\n\tused.insert(h);\n\trep(i,13) {\n\t\tint x = px[i];\n\t\tint y = py[i];\n\t\tif(P[y][x] == 0) {\n\t\t\trep(k,4) {\n\t\t\t\tint xx = x + dx[k];\n\t\t\t\tint yy = y + dy[k];\n\t\t\t\tif(xx>=0 && yy>=0 && xx<5 && yy<5 && field[yy][xx] == 1) {\n\t\t\t\t\tswap(P[y][x], P[yy][xx]);\n\t\t\t\t\tif(dfs(m+1, d)) return true;\n\t\t\t\t\tswap(P[y][x], P[yy][xx]);\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t}\n\treturn false;\n}\n\nvoid solve() {\n\trep(d,20) {\n\t\tused.clear();\n\t\tif(dfs(0, d)) {\n\t\t\tprintf(\"%d\\n\", d);\n\t\t\treturn;\n\t\t}\n\t}\n\tprintf(\"NA\\n\");\n}\n\nint main() {\n\tmemcpy(P, ans, sizeof(P));\n\tH = hash_val();\n\tfor(;;) {\n\t\trep(i,13) {\n\t\t\tscanf(\"%d\", &P[py[i]][px[i]]);\n\t\t\tif(P[py[i]][px[i]] < 0) return 0;\n\t\t}\n\t\tsolve();\n\t}\n}"
  },
  {
    "language": "C++",
    "code": "#include<bits/stdc++.h>\n#define r(i,n) for(int i=0;i<n;i++)\nusing namespace std;\ntypedef pair<vector<int>,int>P;\nvector<int>v[13],s(13),t(13);\nmap<vector<int>,int>m;\nvoid init(){\n\n    v[0].push_back(2);\n\n    v[1].push_back(2);\n    v[1].push_back(5);\n\n    v[2].push_back(0);\n    v[2].push_back(1);\n    v[2].push_back(3);\n    v[2].push_back(6);\n\n    v[3].push_back(2);\n    v[3].push_back(7);\n\n    v[4].push_back(5);\n\n    v[5].push_back(1);\n    v[5].push_back(4);\n    v[5].push_back(6);\n    v[5].push_back(9);\n\n    v[6].push_back(2);\n    v[6].push_back(5);\n    v[6].push_back(7);\n    v[6].push_back(10);\n\n    v[7].push_back(3);\n    v[7].push_back(6);\n    v[7].push_back(8);\n    v[7].push_back(11);\n\n    v[8].push_back(7);\n\n    v[9].push_back(5);\n    v[9].push_back(10);\n\n    v[10].push_back(6);\n    v[10].push_back(9);\n    v[10].push_back(11);\n    v[10].push_back(12);\n\n    v[11].push_back(7);\n    v[11].push_back(10);\n\n    v[12].push_back(10);\n}\nvoid BFS1(){\n    s[0]=0;\n    s[12]=0;\n    r(i,11)s[i+1]=i+1;\n    set<vector<int> >st;\n    st.insert(s);\n    m[s]=0;\n    queue<P>q;\n    q.push(P(s,0));\n    while(1){\n        vector<int>now=q.front().first;\n        int cost=q.front().second;\n        q.pop();\n        if(cost==6)break;\n        r(i,13)if(now[i]!=0){\n            r(j,v[i].size()){\n                swap(now[i],now[v[i][j]]);\n                if(!st.count(now)){\n                    st.insert(now);\n                    m[now]=cost+1;\n                    q.push(P(now,cost+1));\n                }\n                swap(now[i],now[v[i][j]]);\n            }\n        }\n    }\n}\n\nvoid BFS2(){\n    set<vector<int> >st;\n    st.insert(t);\n    queue<P>q;\n    q.push(P(t,0));\n    while(1){\n        vector<int>now=q.front().first;\n        int cost=q.front().second;\n        if(m.count(now)){\n            cout<<m[now]+cost<<endl;\n            return ;\n        }\n        q.pop();\n        if(cost==6)break;\n        r(i,13)if(now[i]!=0){\n            r(j,v[i].size()){\n                swap(now[i],now[v[i][j]]);\n                if(!st.count(now)){\n                    st.insert(now);\n                    q.push(P(now,cost+1));\n                }\n                swap(now[i],now[v[i][j]]);\n            }\n        }\n    }\n    cout<<\"NA\"<<endl;\n}\n\n\nint main(){\n    init();\n    BFS1();\n    while(cin>>t[0],t[0]!=-1){\n        r(i,12)cin>>t[i+1];\n        BFS2();\n    }\n}\n"
  },
  {
    "language": "C++",
    "code": "#include<bits/stdc++.h>\n#define int long long\n#define r(i,n) for(int i=0;i<n;i++)\nusing namespace std;\ntypedef pair<int,int>P;\nvector<int>v[13],s(13),t(13);\nmap<int,int>m;\n\nint has[14];\n\n\nvoid init(){\n\n    v[0].push_back(2);\n\n    v[1].push_back(2);\n    v[1].push_back(5);\n\n    v[2].push_back(0);\n    v[2].push_back(1);\n    v[2].push_back(3);\n    v[2].push_back(6);\n\n    v[3].push_back(2);\n    v[3].push_back(7);\n\n    v[4].push_back(5);\n\n    v[5].push_back(1);\n    v[5].push_back(4);\n    v[5].push_back(6);\n    v[5].push_back(9);\n\n    v[6].push_back(2);\n    v[6].push_back(5);\n    v[6].push_back(7);\n    v[6].push_back(10);\n\n    v[7].push_back(3);\n    v[7].push_back(6);\n    v[7].push_back(8);\n    v[7].push_back(11);\n\n    v[8].push_back(7);\n\n    v[9].push_back(5);\n    v[9].push_back(10);\n\n    v[10].push_back(6);\n    v[10].push_back(9);\n    v[10].push_back(11);\n    v[10].push_back(12);\n\n    v[11].push_back(7);\n    v[11].push_back(10);\n\n    v[12].push_back(10);\n\n    int a=20;\n    int p=1;\n\n    r(i,13){\n        has[i]=p;\n        p*=a;\n    }\n}\n\nint ha(vector<int> &x){\n\n    int re=0;\n\n    r(i,13){\n        re+=x[i]*has[i];\n    }\n\n    return re;\n}\n\nvector<int> ah(int x){\n    vector<int>y(13);\n    r(i,13){\n        y[i]=x%20;\n        x/=20;\n    }\n    return y;\n}\n\nvoid BFS1(){\n    s[0]=0;\n    s[12]=0;\n    r(i,11)s[i+1]=i+1;\n    set<int>st;\n    st.insert(ha(s));\n    m[ha(s)]=0;\n    queue<P>q;\n    q.push(P(ha(s),0));\n    while(1){\n        vector<int> now=ah(q.front().first);\n        int cost=q.front().second;\n        q.pop();\n        if(cost==8)break;\n        //cout<<m.size()<<' '<<cost<<endl;\n        r(i,13)if(now[i]!=0){\n            r(j,v[i].size()){\n                swap(now[i],now[v[i][j]]);\n                int yy=ha(now);\n                if(!st.count(yy)){\n                    st.insert(yy);\n                    m[yy]=cost+1;\n                    q.push(P(yy,cost+1));\n                }\n                swap(now[i],now[v[i][j]]);\n            }\n        }\n    }\n}\n\nvoid BFS2(){\n    set<int>st;\n    st.insert(ha(t));\n    queue<P>q;\n    q.push(P(ha(t),0));\n    while(1){\n        vector<int>now=ah(q.front().first);\n        int cost=q.front().second;\n        int y=ha(now);\n        if(m.count(y)){\n            cout<<m[y]+cost<<endl;\n            return ;\n        }\n        q.pop();\n        if(cost==5)break;\n        r(i,13)if(now[i]!=0){\n            r(j,v[i].size()){\n                swap(now[i],now[v[i][j]]);\n                int yy=ha(now);\n                if(!st.count(yy)){\n                    st.insert(yy);\n                    q.push(P(yy,cost+1));\n                }\n                swap(now[i],now[v[i][j]]);\n            }\n        }\n    }\n    cout<<\"NA\"<<endl;\n}\n\n\nsigned main(){\n    init();\n    BFS1();\n    while(cin>>t[0],t[0]!=-1){\n        r(i,12)cin>>t[i+1];\n        BFS2();\n    }\n}\n"
  },
  {
    "language": "C++",
    "code": "#include<iostream>\n#include<map>\n#include<vector>\n#include<queue>\n#include<algorithm>\n\nusing namespace std;\n\n#define rep(i, n) for (int i = 0; i < int(n); ++i)\n\nmap<vector<int>, int> mp;\n\nint main() {\n  vector<int> v;\n  v.push_back(0);\n  v.push_back(1);\n  v.push_back(2);\n  v.push_back(3);\n  v.push_back(4);\n  v.push_back(5);\n  v.push_back(6);\n  v.push_back(7);\n  v.push_back(8);\n  v.push_back(9);\n  v.push_back(10);\n  v.push_back(11);\n  v.push_back(0);\n  queue<pair<int, vector<int> > > que;\n  que.push(make_pair(0, v));\n  while (!que.empty()) {\n    pair<int, vector<int> > now = que.front();\n    que.pop();\n    if (mp.count(now.second) != 0) continue;\n    mp[now.second] = now.first;\n    if (now.first == 15) continue;\n    rep (i, 13) {\n      if (now.second[i] != 0) continue;\n      if (i == 0) {\n\tv = now.second;\n\tswap(v[0], v[2]);\n\tque.push(make_pair(now.first + 1, v));\n      }\n      if (i == 1) {\n\tv = now.second;\n\tswap(v[1], v[2]);\n\tque.push(make_pair(now.first + 1, v));\n\tv = now.second;\n\tswap(v[1], v[5]);\n\tque.push(make_pair(now.first + 1, v));\n      }\n      if (i == 2) {\n\tv = now.second;\n\tswap(v[2], v[0]);\n\tque.push(make_pair(now.first + 1, v));\n\tv = now.second;\n\tswap(v[2], v[1]);\n\tque.push(make_pair(now.first + 1, v));\n\tv = now.second;\n\tswap(v[2], v[3]);\n\tque.push(make_pair(now.first + 1, v));\n\tv = now.second;\n\tswap(v[2], v[6]);\n\tque.push(make_pair(now.first + 1, v));\n      }\n      if (i == 3) {\n\tv = now.second;\n\tswap(v[3], v[2]);\n\tque.push(make_pair(now.first + 1, v));\n\tv = now.second;\n\tswap(v[3], v[7]);\n\tque.push(make_pair(now.first + 1, v));\n      }\n      if (i == 4) {\n\tv = now.second;\n\tswap(v[4], v[5]);\n\tque.push(make_pair(now.first + 1, v));\n      }\n      if (i == 5) {\n\tv = now.second;\n\tswap(v[5], v[1]);\n\tque.push(make_pair(now.first + 1, v));\n\tv = now.second;\n\tswap(v[5], v[4]);\n\tque.push(make_pair(now.first + 1, v));\n\tv = now.second;\n\tswap(v[5], v[6]);\n\tque.push(make_pair(now.first + 1, v));\n\tv = now.second;\n\tswap(v[5], v[9]);\n\tque.push(make_pair(now.first + 1, v));\n      }\n      if (i == 6) {\n\tv = now.second;\n\tswap(v[6], v[2]);\n\tque.push(make_pair(now.first + 1, v));\n\tv = now.second;\n\tswap(v[6], v[5]);\n\tque.push(make_pair(now.first + 1, v));\n\tv = now.second;\n\tswap(v[6], v[7]);\n\tque.push(make_pair(now.first + 1, v));\n\tv = now.second;\n\tswap(v[6], v[10]);\n\tque.push(make_pair(now.first + 1, v));\n      }\n      if (i == 7) {\n\tv = now.second;\n\tswap(v[7], v[3]);\n\tque.push(make_pair(now.first + 1, v));\n\tv = now.second;\n\tswap(v[7], v[6]);\n\tque.push(make_pair(now.first + 1, v));\n\tv = now.second;\n\tswap(v[7], v[8]);\n\tque.push(make_pair(now.first + 1, v));\n\tv = now.second;\n\tswap(v[7], v[11]);\n\tque.push(make_pair(now.first + 1, v));\n      }\n      if (i == 8) {\n\tv = now.second;\n\tswap(v[8], v[7]);\n\tque.push(make_pair(now.first + 1, v));\n      }\n      if (i == 9) {\n\tv = now.second;\n\tswap(v[9], v[5]);\n\tque.push(make_pair(now.first + 1, v));\n\tv = now.second;\n\tswap(v[9], v[10]);\n\tque.push(make_pair(now.first + 1, v));\n      }\n      if (i == 10) {\n\tv = now.second;\n\tswap(v[10], v[6]);\n\tque.push(make_pair(now.first + 1, v));\n\tv = now.second;\n\tswap(v[10], v[9]);\n\tque.push(make_pair(now.first + 1, v));\n\tv = now.second;\n\tswap(v[10], v[11]);\n\tque.push(make_pair(now.first + 1, v));\n\tv = now.second;\n\tswap(v[10], v[12]);\n\tque.push(make_pair(now.first + 1, v));\n      }\n      if (i == 11) {\n\tv = now.second;\n\tswap(v[11], v[7]);\n\tque.push(make_pair(now.first + 1, v));\n\tv = now.second;\n\tswap(v[11], v[10]);\n\tque.push(make_pair(now.first + 1, v));\n      }\n      if (i == 12) {\n\tv = now.second;\n\tswap(v[12], v[10]);\n\tque.push(make_pair(now.first + 1, v));\n      }\n    }\n  }\n  vector<int> p(13);\n  for (;;) {\n    cin >> p[0];\n    if (p[0] == -1) break;\n    rep (i, 12) cin >> p[i + 1];\n    while (!que.empty()) que.pop();\n    que.push(make_pair(0, p));\n    bool find = false;\n    while (!que.empty()) {\n      pair<int, vector<int> > now = que.front();\n      que.pop();\n      if (mp.count(now.second) != 0) {\n\tcout << now.first + mp[now.second] << endl;\n\tfind = true;\n\tbreak;\n      } \n      if (now.first == 5) continue;\n      rep (i, 13) {\n\tif (now.second[i] != 0) continue;\n\tif (i == 0) {\n\t  v = now.second;\n\t  swap(v[0], v[2]);\n\t  que.push(make_pair(now.first + 1, v));\n\t}\n\tif (i == 1) {\n\t  v = now.second;\n\t  swap(v[1], v[2]);\n\t  que.push(make_pair(now.first + 1, v));\n\t  v = now.second;\n\t  swap(v[1], v[5]);\n\t  que.push(make_pair(now.first + 1, v));\n\t}\n\tif (i == 2) {\n\t  v = now.second;\n\t  swap(v[2], v[0]);\n\t  que.push(make_pair(now.first + 1, v));\n\t  v = now.second;\n\t  swap(v[2], v[1]);\n\t  que.push(make_pair(now.first + 1, v));\n\t  v = now.second;\n\t  swap(v[2], v[3]);\n\t  que.push(make_pair(now.first + 1, v));\n\t  v = now.second;\n\t  swap(v[2], v[6]);\n\t  que.push(make_pair(now.first + 1, v));\n\t}\n\tif (i == 3) {\n\t  v = now.second;\n\t  swap(v[3], v[2]);\n\t  que.push(make_pair(now.first + 1, v));\n\t  v = now.second;\n\t  swap(v[3], v[7]);\n\t  que.push(make_pair(now.first + 1, v));\n\t}\n\tif (i == 4) {\n\t  v = now.second;\n\t  swap(v[4], v[5]);\n\t  que.push(make_pair(now.first + 1, v));\n\t}\n\tif (i == 5) {\n\t  v = now.second;\n\t  swap(v[5], v[1]);\n\t  que.push(make_pair(now.first + 1, v));\n\t  v = now.second;\n\t  swap(v[5], v[4]);\n\t  que.push(make_pair(now.first + 1, v));\n\t  v = now.second;\n\t  swap(v[5], v[6]);\n\t  que.push(make_pair(now.first + 1, v));\n\t  v = now.second;\n\t  swap(v[5], v[9]);\n\t  que.push(make_pair(now.first + 1, v));\n\t}\n\tif (i == 6) {\n\t  v = now.second;\n\t  swap(v[6], v[2]);\n\t  que.push(make_pair(now.first + 1, v));\n\t  v = now.second;\n\t  swap(v[6], v[5]);\n\t  que.push(make_pair(now.first + 1, v));\n\t  v = now.second;\n\t  swap(v[6], v[7]);\n\t  que.push(make_pair(now.first + 1, v));\n\t  v = now.second;\n\t  swap(v[6], v[10]);\n\t  que.push(make_pair(now.first + 1, v));\n\t}\n\tif (i == 7) {\n\t  v = now.second;\n\t  swap(v[7], v[3]);\n\t  que.push(make_pair(now.first + 1, v));\n\t  v = now.second;\n\t  swap(v[7], v[6]);\n\t  que.push(make_pair(now.first + 1, v));\n\t  v = now.second;\n\t  swap(v[7], v[8]);\n\t  que.push(make_pair(now.first + 1, v));\n\t  v = now.second;\n\t  swap(v[7], v[11]);\n\t  que.push(make_pair(now.first + 1, v));\n\t}\n\tif (i == 8) {\n\t  v = now.second;\n\t  swap(v[8], v[7]);\n\t  que.push(make_pair(now.first + 1, v));\n\t}\n\tif (i == 9) {\n\t  v = now.second;\n\t  swap(v[9], v[5]);\n\t  que.push(make_pair(now.first + 1, v));\n\t  v = now.second;\n\t  swap(v[9], v[10]);\n\t  que.push(make_pair(now.first + 1, v));\n\t}\n\tif (i == 10) {\n\t  v = now.second;\n\t  swap(v[10], v[6]);\n\t  que.push(make_pair(now.first + 1, v));\n\t  v = now.second;\n\t  swap(v[10], v[9]);\n\t  que.push(make_pair(now.first + 1, v));\n\t  v = now.second;\n\t  swap(v[10], v[11]);\n\t  que.push(make_pair(now.first + 1, v));\n\t  v = now.second;\n\t  swap(v[10], v[12]);\n\t  que.push(make_pair(now.first + 1, v));\n\t}\n\tif (i == 11) {\n\t  v = now.second;\n\t  swap(v[11], v[7]);\n\t  que.push(make_pair(now.first + 1, v));\n\t  v = now.second;\n\t  swap(v[11], v[10]);\n\t  que.push(make_pair(now.first + 1, v));\n\t}\n\tif (i == 12) {\n\t  v = now.second;\n\t  swap(v[12], v[10]);\n\t  que.push(make_pair(now.first + 1, v));\n\t}\n      }\n    }\n    if (!find) {\n      cout << \"NA\" << endl;\n    }\n  }\n  return 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include <algorithm>\n#include <cctype>\n#include <climits>\n#include <cmath>\n#include <cstdio>\n#include <cstdlib>\n#include <cstring>\n#include <functional>\n#include <map>\n#include <numeric>\n#include <queue>\n#include <set>\n#include <sstream>\n#include <string>\n#include <vector>\n\nusing namespace std;\n\n#define reps(i,f,n) for(int i=f; i<int(n); ++i)\n#define rep(i,n) reps(i,0,n)\n\ntypedef long long ll;\ntypedef vector<int> vi;\ntypedef vector<vi> vvi;\ntypedef pair<int, int> pii;\n\nconst int INF = 1001001001;\nconst ll FINAL = 0x0ba9876543210ll;\n\nstruct Data\n{\n\tll s;\n\tint d;\n\tbool f;\n\tData(ll s, int d, bool f) : s(s), d(d), f(f) {}\n};\n\nint bfs(ll init)\n{\n\tif(init == FINAL)\n\t\treturn 0;\n\t\n\tconst int move[13][5] = {\n\t\t{2, -1},\n\t\t{2, 5, -1},\n\t\t{0, 1, 3, 6, -1},\n\t\t{2, 7, -1},\n\t\t{5, -1},\n\t\t{1, 4, 6, 9, -1},\n\t\t{2, 5, 7, 10, -1},\n\t\t{3, 6, 8, 11, -1},\n\t\t{7, -1},\n\t\t{5, 10, -1},\n\t\t{6, 9, 11, 12, -1},\n\t\t{7, 10, -1},\n\t\t{10, -1}\n\t};\n\t\n\tset<ll> visited[2];\n\tqueue<Data> Q;\n\tQ.push(Data(init, 0, false));\n\tQ.push(Data(FINAL, 0, true));\n\tvisited[0].insert(init);\n\tvisited[1].insert(FINAL);\n\tint now[2] = {0};\n\t\n\twhile(!Q.empty()){\n\t\tData data = Q.front();\n\t\tQ.pop();\n\t\tnow[data.f] = data.d + 1;\n\n\t\tfor(int i=0, cnt=2; cnt; ++i){\n\t\t\tif(((data.s>>(i*4)) & 0xfll) == 0){\n\t\t\t\tfor(int j=0; move[i][j]!=-1; ++j){\n\t\t\t\t\tll next = data.s;\n\t\t\t\t\tnext &= ~((0xfll << (i*4)) | (0xfll << (move[i][j]*4)));\n\t\t\t\t\tnext |= ((data.s >> (move[i][j]*4)) & 0xfll) << (i*4);\n\t\t\t\t\t\n\t\t\t\t\tif(visited[!data.f].find(next) != visited[!data.f].end())\n\t\t\t\t\t\treturn now[0] + now[1];\n\n\t\t\t\t\tif(visited[data.f].find(next) == visited[data.f].end()){\n\t\t\t\t\t\tvisited[data.f].insert(next);\n\t\t\t\t\t\tif(now[0]+now[1] < 20)\n\t\t\t\t\t\t\tQ.push(Data(next, data.d+1, data.f));\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t\t--cnt;\n\t\t\t}\n\t\t}\n\t}\n\treturn -1;\n}\n\nint main()\n{\n\tfor(;;){\n\t\tint input[13];\n\t\trep(i, 13){\n\t\t\tscanf(\"%d\", &input[i]);\n\t\t\tif(input[i] == -1)\n\t\t\t\treturn 0;\n\t\t}\n\n\t\tll init = 0;\n\t\trep(i, 13)\n\t\t\tinit = (init << 4) | input[12-i];\n\n\t\tint ans = bfs(init);\n\t\tif(ans == -1 || ans > 20)\n\t\t\tputs(\"NA\");\n\t\telse\n\t\t\tprintf(\"%d\\n\", ans);\n\t}\n}"
  },
  {
    "language": "C++",
    "code": "#include<iostream>\n#include<vector>\n#include<queue>\n#include<map>\n#include<cmath>\nusing namespace std;\n\nstring ans;\n\nclass board{\npublic:\n  int h,c;\n  string s;\n  board(int x,int y,string z){ h=x; c=y; s=z;}\n  const bool operator<(const board x)const{return (h+c>x.h+x.c) || (h+c==x.h+x.c && c>x.c); }\n};\n\nint score(string s){\n  int res=0;\n  for(int i=0;i<25;i++){\n    if(s[i]!='x'){\n      int m=20;\n      for(int j=0;j<25;j++){\n\tif(s[i]==ans[j]){\n\t  int a = abs(i-j);\n\t  int tmp = a/5 + a%5;\n\t  m = min(m,tmp);\n\t  if(s[i]!='o')break;\n\t}\n      }\n      res += m;\n    }\n  }\n  return res;\n}\n\nchar trans(int x){\n  if(!x)return 'o';\n  else return 'a'+x-1;\n}\n\nint main(){\n  string s;\n  ans = \"xxoxxxabcxdefghxijkxxxoxx\";\n  int tmp,cost;\n\n  for(;;){\n    cin >> tmp;\n    if(tmp<0)break;\n\n    s = \"xx\";\n    s += trans(tmp);\n    s += \"xxx\";\n    for(int i=0;i<3;i++){\n      cin >> tmp;\n      s += trans(tmp);\n    }\n    s += \"x\";\n    for(int i=0;i<5;i++){\n      cin >> tmp;\n      s += trans(tmp);\n    }\n    s += \"x\";\n    for(int i=0;i<3;i++){\n      cin >> tmp;\n      s+= trans(tmp);\n    }\n    s += \"xxx\";\n    cin >> tmp;\n    s += trans(tmp);\n    s += \"xx\";\n\n    priority_queue<board> q1;\n    q1.push(board(score(s),0,s));\n\n    map<string,bool> m1;\n    m1[s] = 0;\n    while(q1.size()){\n      board p = q1.top();q1.pop();\n      int dx[] = {-5,1,5,-1};\n      //cout << p.h << \" \" << p.c << \" \" << p.s << endl;\n      cost = p.c;\n      if(p.s == ans)break;\n      if(cost>20)break;\n      if(p.h/2+p.c > 20){\n\tcost = 21;\n\tbreak;\n      }\n      for(int i=0;i<25;i++){\n\tif(p.s[i]=='o'){\n\t  for(int j=0;j<4;j++){\n\t    int sx = i + dx[j];\n\t    string str = p.s;\n\t    if(sx<0 || 25<=sx)continue;\n\t    if(str[sx] == 'x' || str[sx] == 'o')continue;\n\t    swap(str[i],str[sx]);\n\t    if(!m1[str]){\n\t      q1.push(board(score(str),cost+1,str));\n\t      m1[str] = cost+1;\n\t    }\n\t  }\n\t}\n      }\n    }\n\n\n\n    if(cost>20)cout << \"NA\\n\";\n    else cout << cost << endl;\n  }\n}"
  },
  {
    "language": "C++",
    "code": "#include<iostream>\n#include<algorithm>\n#include<vector>\n#include<queue>\n#include<map>\n#define lol(i,n) for(int i=0;i<n;i++)\n#define mod 1000000007\ntypedef long long ll;\nusing namespace std;\nint dx[13][4]={\n  {3,0,0,0},\n  {3,6,0,0},\n  {1,2,4,6},\n  {3,8,0,0},\n  {6,0,0,0},\n  {2,5,7,10},\n  {3,6,8,11},\n  {4,7,9,12},\n  {8,0,0,0},\n  {6,11,0,0},\n  {6,10,12,13},\n  {8,11,0,0},\n  {11,0,0,0}\n};\nmap<ll,int> mp;\nll Compress(int p[]){\n  ll ans=0;\n  for(int i=0;i<13;i++){\n    ans*=13;\n    ans+=p[i];\n  }\n  return ans;\n}\n\nint unzip[13];\nvoid Unzip(ll x){\n  for(int i=0;i<13;i++){\n    unzip[12-i]=x%13;\n    x/=13;\n  }\n}\n\nint beflen=0;\nqueue<pair<ll,int> >Q;\nvoid BFS(int p[],int len){\n  //if(len!=beflen){cout<<len<<endl;beflen=len;}\n  ll tmp=Compress(p);\n  mp[tmp]=len;\n  if(len==21)return;\n  lol(i,13){\n    if(p[i]==0){\n      lol(j,4){\n\tint t=dx[i][j];\n\tif(t==0)break;\n\tt--;\n\tif(p[t]!=0){\n\t  swap(p[i],p[t]);\n\t  tmp=Compress(p);\n\t  if(mp[tmp]!=0)continue;\n\t  mp[tmp]=-1;\n\t  Q.push(make_pair(tmp,len+1));\n\t  swap(p[i],p[t]);\n\t}\n      }\n    }\n  }\n}\nint main(){\n  int p[13];\n  lol(i,13)p[i]=i;p[12]=0;\n  Q.push(make_pair(Compress(p),1));\n  while(!Q.empty()){\n    ll data=Q.front().first;\n    int len=Q.front().second;\n    Q.pop();\n    if(mp[data]>0)continue;\n    Unzip(data);\n    BFS(unzip,len);\n  }\n  while(cin>>p[0]&&p[0]!=-1){\n    for(int i=1;i<13;i++)cin>>p[i];\n    ll tmp=Compress(p);\n    int cost=mp[tmp];\n    if(cost==0)cout<<\"NA\"<<endl;\n    else cout<<cost-1<<endl;\n  }\n  return 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include<bits/stdc++.h>\nusing namespace std;\n  \ntypedef long long int64;\nconst int INF = 1 << 30;\n  \nvector< int > edge[13];\nmap< string, int > memo;\n \nbool back(string str, int cnt){ //枝刈り大事だな\n  int X[]={ 2, 1, 2, 3, 0, 1, 2, 3, 4, 1, 2, 3, 2};\n  int Y[]={ 0, 1, 1, 1, 2, 2, 2, 2, 2, 3, 3, 3, 4};\n\n  int diff = 0;\n  for(int i = 0; i < 13; i++){\n   \n    if(str[i] != '0'){\n      int pos = (str[i] > 'A' ? str[i] - 'A' : str[i] - '0');\n      diff += abs( X[pos] - X[i]) + abs( Y[pos] - Y[i]);\n    }\n  }\n  return diff + cnt > 20;\n}\n \n \nint bfs(string mas){\n \n  queue< string > que;\n  map< string , int > used;\n  que.push( mas );\n  memo[mas] = 0;\n  while(!que.empty()){\n \n    string p = que.front(); que.pop();\n    if(back( p, memo[p])) break;\n    if(p == \"0123456789AB0\") return memo[p];\n \n    for(int i = 0; i < 13; i++){\n      if(p[i] == '0') {\n        for(int j = 0; j < edge[i].size(); j++){\n          string next = p;\n          swap( next[i], next[edge[i][j]]);\n          if(memo.find(next) != memo.end()) continue;\n          que.push( next );\n          memo[next] = memo[p] + 1;\n        }\n      }\n    }\n  }\n  return -1;\n}\n \nint main(){\n  vector< int > mas(13);\n \n  edge[0].push_back(2);\n  edge[1].push_back(2); edge[1].push_back(4);\n  edge[2].push_back(0); edge[2].push_back(1); edge[2].push_back(3); edge[2].push_back(6);\n  edge[3].push_back(2); edge[3].push_back(7);\n  edge[4].push_back(5);\n  edge[5].push_back(1); edge[5].push_back(4); edge[5].push_back(6); edge[5].push_back(9);\n  edge[6].push_back(2); edge[6].push_back(5); edge[6].push_back(7); edge[6].push_back(10);\n  edge[7].push_back(3); edge[7].push_back(6); edge[7].push_back(8); edge[7].push_back(11);\n  edge[8].push_back(7);\n  edge[9].push_back(5); edge[9].push_back(10);\n  edge[10].push_back(6); edge[10].push_back(9); edge[10].push_back(11); edge[10].push_back(12);\n  edge[11].push_back(7); edge[11].push_back(10);\n  edge[12].push_back(10);\n \n  while(cin >> mas[0], mas[0] != -1){\n    for(int i = 1; i < 13; i++){\n      cin >> mas[i];\n    }\n \n    string start = \"\";\n    for(int i = 0; i < 13; i++){\n      if(mas[i] >= 10) start += (char)(mas[i] - 10 + 'A');\n      else start += mas[i] + '0';\n    }\n    int ret = bfs(start);\n    if(~ret) cout << ret << endl;\n    else cout << \"NA\" << endl;\n \n    memo.clear();\n  }\n}"
  },
  {
    "language": "C++",
    "code": "#include <iostream>\n#include <cstdio>\n#include <vector>\n#include <map>\n#include <string>\n#include <queue>\n#include <algorithm>\nusing namespace std;\n\ntypedef pair<int,int> P;\nconst int INF = 1e+8;\nconst int f1[25] = {\n\t-1,-1, 0,-1,-1,\n\t-1, 1, 2, 3,-1,\n\t 4, 5, 6, 7, 8,\n\t-1, 9,10,11,-1,\n\t-1,-1,12,-1,-1,\n};\nconst int f2[13] = {2,6,7,8,10,11,12,13,14,16,17,18,22};\nconst int dx[4] = { 0,-1,+1, 0};\nconst int dy[4] = {-1, 0, 0,+1};\n\n// パズル\nstruct Pazzle{\n\tstring v;\n\tPazzle(){v = \"*************\"; }\n\tvoid at(int i, int p){\n\t\tv[i] = p;\n\t}\n\t// 空白の位置を返す. (k は 0 or 1)\n\tint search(int k){\n\t\tint a = 0;\n\t\tfor(int i=0 ; i < 13 ; i++ ){\n\t\t\tif( v[i] == 0 ){\n\t\t\t\tif( k == 0 ){\n\t\t\t\t\treturn i;\n\t\t\t\t}else{\n\t\t\t\t\tif( a == 0 ) a++;\n\t\t\t\t\telse return i;\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t\treturn -1;\n\t}\n\t// 合っている数\n\tint to_g(){\n\t\tint res = 13;\n\t\tfor(int i=0 ; i < 12 ; i++ ){\n\t\t\tif( i != v[i] ) res--;\n\t\t}\n\t\tif( v[12] != 0 ) res--;\n\t\treturn res;\n\t}\n\t// 空白 k (0 or 1) を 方向 dir に動かす.\n\t// 動かせる時は true, 動かせなかったときは false を返す.\n\tbool move(int dir, int k){\n\t\tif( dir < 0 || 4 <= dir || k < 0 || 2 <= k ) return false;\n\t\tint pos1 = search(k);\n\t\tint x = f2[pos1] % 5;\n\t\tint y = f2[pos1] / 5;\n\t\tint mx = x + dx[dir];\n\t\tint my = y + dy[dir];\n\t\tif( mx < 0 || my < 0 || 5 <= mx || 5 <= my ) return false;\n\t\tint pos2 = f1[my*5+mx];\n\t\tif( pos2 == -1 ) return false;\n\t\tif( v[pos1] == v[pos2] ) return false;\n\t\tswap( v[pos1] , v[pos2] );\n\t\treturn true;\n\t}\n\t// 完成しているかどうか\n\tbool is_goal(){\n\t\tfor(int i=0 ; i < 12 ; i++ ){\n\t\t\tif( v[i] != i ) return false;\n\t\t}\n\t\treturn v[12] == 0;\n\t}\n\tvoid debug(){\n\t\tprintf(\"[debug]\\n\");\n\t\tfor(int y=0 ; y < 5 ; y++ ){\n\t\t\tfor(int x=0 ; x < 5 ; x++ ){\n\t\t\t\tif( f1[y*5+x] == -1 ){\n\t\t\t\t\tprintf(\"##\");\n\t\t\t\t}else{\n\t\t\t\t\tprintf(\"%2d\", (int)v[f1[y*5+x]] );\n\t\t\t\t}\n\t\t\t}\n\t\t\tprintf(\"\\n\");\n\t\t}\n\t\tprintf(\"\\n\");\n\t}\n};\n\n// (コスト,スタートからの距離,パズルの状態)\n// コスト は (合っている数,-スタートからの距離)\nstruct State{\n\tPazzle p;\n\tint cnt;\n\tP cost;\n\tState(int cost_, int cnt_, const Pazzle& p_){\n\t\tcost = P(cost_,-cnt_); cnt = cnt_; p = p_;\n\t}\n};\nbool operator<(const State& a, const State& b){\n\treturn a.cost < b.cost;\n}\n\nint solve(Pazzle p){\n\t// (コスト,スタートからの距離,パズルの状態) を優先度つきキューへ\n\tpriority_queue<State> q;\n\tq.push( State(p.to_g(),0,p) );\n\t\n\tint res = 21;\n\tint low = p.to_g() - 3;\n\tif( low < 0 ) low = 0;\n\tint foo=0;\n\twhile( !q.empty() ){\n\t\tPazzle p = q.top().p;\n\t\tint cnt = q.top().cnt;\n\t\tq.pop();\n\t\t\n\t\tif( p.is_goal() ){\n\t\t\tres = min( res , cnt );\n\t\t\tcontinue;\n\t\t}\n\t\tfoo++;\n\t\tif( 150000 < foo ) break;\n\t\tif( low < p.is_goal() ) continue;\n\t\tif( res <= cnt + (13-p.is_goal()) ) continue;\n\t\t\n\t\tfor(int k=0 ; k <= 1 ; k++ ){\n\t\t\tfor(int i=0 ; i < 4 ; i++ ){\n\t\t\t\tPazzle p_ = p;\n\t\t\t\tif( p_.move(i,k) ){\n\t\t\t\t\tq.push( State(p_.to_g(),cnt+1,p_) );\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t}\n\treturn res;\n}\n\nint main(){\n\tint p1;\n\twhile( cin >> p1 , p1 != -1 ){\n\t\tPazzle p;\n\t\tp.at(0,p1);\n\t\tfor(int i=1 ; i < 13 ; i++ ){\n\t\t\tcin >> p1;\n\t\t\tp.at(i,p1);\n\t\t}\n\t\tint ans = solve(p);\n\t\tif( ans == 21 ){\n\t\t\tcout << \"NA\" << endl;\n\t\t}else{\n\t\t\tcout << ans << endl;\n\t\t}\n\t}\n}"
  },
  {
    "language": "C++",
    "code": "#include <iostream>\n#include <sstream>\n#include <cstdio>\n#include <cstdlib>\n#include <cmath>\n#include <ctime>\n#include <cstring>\n#include <climits>\n#include <algorithm>\n#include <map>\n#include <set>\n#include <stack>\n#include <vector>\n#include <queue>\n#include <bitset>\n#include <string>\nusing namespace std;\n \n#define rep(i,n) for(int i=0; i<n; i++)\n#define repa(i,s,e) for(int i=s; i<=e; i++)\n#define repd(i,s,e) for(int i=s; i>=e; i--)\n#define PB(a) push_back(a)\n#define MP(i,s) make_pair(i,s)\n \ntypedef long long ll;\n\nconst int dx[4] = {-1, 0, 0, 1};\nconst int dy[4] = {0, -1, 1, 0};\nconst int field[5][5] = {\n\t{0, 0, 1, 0, 0}, \n\t{0, 1, 1, 1, 0},\n\t{1, 1, 1, 1, 1},\n\t{0, 1, 1, 1, 0},\n\t{0, 0, 1, 0, 0}, \n};\n\nconst int ans[5][5] = {\n\t{0, 0, 0, 0, 0},\n\t{0, 1, 2, 3, 0},\n\t{4, 5, 6, 7, 8},\n\t{0, 9, 10, 11, 0},\n\t{0, 0, 0, 0, 0}\n};\n\nconst int px[13] = {2, 1, 2, 3, 0, 1, 2, 3, 4, 1, 2, 3, 2};\nconst int py[13] = {0, 1, 1, 1, 2, 2, 2, 2, 2, 3, 3, 3, 4};\n\nint P[5][5];\nmap<ll,int> used;\nmap<ll,int> H;\n\nll hash_val() {\n\tll h = 0;\n\trep(i,13) {\n\t\th *= 13;\n\t\th += P[py[i]][px[i]];\n\t}\n\treturn h;\n}\n\nvoid make_ans(int m, int d) {\n\tll h = hash_val();\n\tif(m == d) return;\n\tmap<ll,int>::iterator it = H.find(h);\n\t\n\tif(it == H.end()) {\n\t\tH.insert(MP(h,m));\n\t} else if((*it).second > m) {\n\t\t(*it).second = m;\n\t} else {\n\t\treturn;\n\t}\n\n\tH.insert(MP(h,m));\n\trep(i,13) {\n\t\tint x = px[i];\n\t\tint y = py[i];\n\t\tif(P[y][x] == 0) {\n\t\t\trep(k,4) {\n\t\t\t\tint xx = x + dx[k];\n\t\t\t\tint yy = y + dy[k];\n\t\t\t\tif(xx>=0 && yy>=0 && xx<5 && yy<5 && field[yy][xx] == 1 && P[yy][xx] != 0) {\n\t\t\t\t\tswap(P[y][x], P[yy][xx]);\n\t\t\t\t\tmake_ans(m+1, d);\n\t\t\t\t\tswap(P[y][x], P[yy][xx]);\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t}\n}\n\nint dfs(int m, int d) {\n\tmap<ll,int>::iterator it;\n\tll h = hash_val();\n\n\tit = H.find(h);\n\tif(it != H.end()) return m + (*it).second;\n\n\tif(m == d) return -1;\n\t\n\tit = used.find(h);\n\tif(it == used.end()) {\n\t\tused.insert(MP(h,m));\n\t} else if((*it).second > m) {\n\t\t(*it).second = m;\n\t} else {\n\t\treturn -1;\n\t}\n\n\trep(i,13) {\n\t\tint x = px[i];\n\t\tint y = py[i];\n\t\tif(P[y][x] == 0) {\n\t\t\trep(k,4) {\n\t\t\t\tint xx = x + dx[k];\n\t\t\t\tint yy = y + dy[k];\n\t\t\t\tif(xx>=0 && yy>=0 && xx<5 && yy<5 && field[yy][xx] == 1 && P[yy][xx] != 0) {\n\t\t\t\t\tswap(P[y][x], P[yy][xx]);\n\t\t\t\t\tint a = dfs(m+1, d);\n\t\t\t\t\tif(a >= 0) return a;\n\t\t\t\t\tswap(P[y][x], P[yy][xx]);\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t}\n\treturn -1;\n}\n\nvoid solve() {\n\trepa(d,0,10) {\n\t\tused.clear();\n\t\tint a = dfs(0, d);\n\t\tif(a >= 0 && a <= 20) {\n\t\t\tprintf(\"%d\\n\", a);\n\t\t\treturn;\n\t\t}\n\t}\n\tprintf(\"NA\\n\");\n}\n\nint main() {\n\tmemcpy(P, ans, sizeof(P));\n\tmake_ans(0, 10);\n\tfor(;;) {\n\t\trep(i,13) {\n\t\t\tscanf(\"%d\", &P[py[i]][px[i]]);\n\t\t\tif(P[py[i]][px[i]] < 0) return 0;\n\t\t}\n\t\tsolve();\n\t}\n}"
  },
  {
    "language": "C++",
    "code": "#include <iostream>\n#include <cstdio>\n#include <cstdlib>\n#include <string>\n#include <vector>\n#include <deque>\n#include <list>\n#include <algorithm>\n#include <numeric>\n#include <functional>\n#include <cmath>\n#include <cstring>\n#include <cctype>\n#include <sstream>\n#include <set>\n#include <map>\n#include <queue>\n#include <complex>\nusing namespace std;\n#define REP(i,n) for(int i = 0; i < (int)n; i++)\n#define FOR(i,a,b) for(int i = a; i < (int)b; i++)\nconst int INF = 1<<28;\nint pnt[11][2] = {\n\t{1,1}, {1,2}, {1,3}, {2,0},\n\t{2,1}, {2,2}, {2,3}, {2,4},\n\t{3,1}, {3,2}, {3,3}\n};\nint ans = -1;\nstruct F {\n\tint p[5][5];\n\tint cnt;\n};\nset<string> s;\nqueue<F> q;\n\nbool cost(int p[5][5], int cnt) {\n\tint c = cnt;\n\tREP(i, 5) REP(j, 5) {\n\t\tif(p[i][j] > 0) {\n\t\t\tc += abs(i - pnt[p[i][j]-1][0]);\n\t\t\tc += abs(j - pnt[p[i][j]-1][1]);\n//\t\t\tcout << abs(i - pnt[p[i][j]-1][0]) << ' ' << abs(j - pnt[p[i][j]-1][1]) << \"  \";\n\t\t}\n\t}\n//\tcout << c << endl;\n\tif(c == cnt) ans = cnt;\n\treturn (c > 20) ? true : false;\n}\n\nvoid bfs() {\n\twhile(q.size()) {\n\t\tF f = q.front();\n\t\tq.pop();\n//\t\tcout << cost(f.p, f.cnt) << endl;\n\t\tif(cost(f.p, f.cnt)) continue;\n\t\tif(ans != -1) break;\n\t\tstring str = \"\";\n\t\tREP(i, 5) REP(j, 5) str += to_string(f.p[i][j]) + ',';\n\t\tif(s.count(str) > 0) continue;\n//\t\tcout << str << endl;\n\t\ts.insert(str);\n\t\tREP(i, 5) REP(j, 5) {\n\t\t\tif(f.p[i][j] == 0) {\n\t\t\t\tif(j < 4 && f.p[i][j+1] != -1) {\n\t\t\t\t\tF f2 = f;\n\t\t\t\t\tswap(f2.p[i][j], f2.p[i][j+1]);\n\t\t\t\t\tf2.cnt++;\n\t\t\t\t\tq.push(f2);\n\t\t\t\t}\n\t\t\t\tif(0 < j && f.p[i][j-1] != -1) {\n\t\t\t\t\tF f2 = f;\n\t\t\t\t\tswap(f2.p[i][j], f2.p[i][j-1]);\n\t\t\t\t\tf2.cnt++;\n\t\t\t\t\tq.push(f2);\n\t\t\t\t}\n\t\t\t\tif(i < 4 && f.p[i+1][j] != -1) {\n\t\t\t\t\tF f2 = f;\n\t\t\t\t\tswap(f2.p[i][j], f2.p[i+1][j]);\n\t\t\t\t\tf2.cnt++;\n\t\t\t\t\tq.push(f2);\n\t\t\t\t}\n\t\t\t\tif(0 < i && f.p[i-1][j] != -1) {\n\t\t\t\t\tF f2 = f;\n\t\t\t\t\tswap(f2.p[i][j], f2.p[i-1][j]);\n\t\t\t\t\tf2.cnt++;\n\t\t\t\t\tq.push(f2);\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t}\n\treturn;\n}\n\nint main() {\n\twhile(true) {\n\t\tq = queue<F>();\n\t\ts.clear();\n\t\tans = -1;\n\t\tF f;\n\t\tint p[5][5] = {\n\t\t\t{-1, -1, 0, -1, -1},\n\t\t\t{-1, 0, 0, 0, -1},\n\t\t\t{0, 0, 0, 0, 0},\n\t\t\t{-1, 0, 0, 0, -1},\n\t\t\t{-1, -1, 0, -1, -1},\n\t\t};\n\t\tREP(i, 5) REP(j, 5) {\n\t\t\tif(p[i][j] == -1) {\n\t\t\t\tf.p[i][j] = -1;\n\t\t\t\tcontinue;\n\t\t\t}\n\t\t\telse\n\t\t\t\tcin >> f.p[i][j];\n\t\t\tif(f.p[i][j] == -1) return 0;\n\t\t}\n\t\tf.cnt = 0;\n\t\tq.push(f);\n\t\tbfs();\n\t\tif(ans < 0) cout << \"NA\" << endl;\n\t\telse cout << ans << endl;\n\t}\n\treturn 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include<iostream>\n#include<algorithm>\n#include<vector>\n#include<queue>\n#include<unordered_map>\n#include<unordered_set>\n#define lol(i,n) for(int i=0;i<n;i++)\n#define mod 1000000007\ntypedef long long ll;\nusing namespace std;\nint dx[13][4]={\n  {3,0,0,0},\n  {3,6,0,0},\n  {1,2,4,7},\n  {3,8,0,0},\n  {6,0,0,0},\n  {2,5,7,10},\n  {3,6,8,11},\n  {4,7,9,12},\n  {8,0,0,0},\n  {6,11,0,0},\n  {7,10,12,13},\n  {8,11,0,0},\n  {11,0,0,0}\n};\nunordered_map<ll,int> mp;\nll Compress(int p[]){\n  ll ans=0;\n  for(int i=0;i<13;i++){\n    ans*=13;\n    ans+=p[i];\n  }\n  return ans;\n}\n \nint unzip[13];\nvoid Unzip(ll x){\n  for(int i=0;i<13;i++){\n    unzip[12-i]=x%13;\n    x/=13;\n  }\n}\n \nint beflen=0;\nunordered_set<ll> vist;\nqueue<pair<ll,int> >Q;\nvoid BFS(int p[],int len){\n  //if(len!=beflen){cout<<len<<endl;beflen=len;}\n  ll tmp=Compress(p);\n  mp[tmp]=len;\n  if(len==13)return;\n  lol(i,13){\n    if(p[i]==0){\n      lol(j,4){\n    int t=dx[i][j];\n    if(t==0)break;\n    t--;\n    if(p[t]!=0){\n      swap(p[i],p[t]);\n      tmp=Compress(p);\n      if(vist.find(tmp)!=vist.end())continue;\n      vist.insert(tmp);\n      Q.push(make_pair(tmp,len+1));\n      swap(p[i],p[t]);\n    }\n      }\n    }\n  }\n}\n \nunordered_set<ll> st;\nint ans;\nvoid EFS(int p[],int len){\n  //if(len!=beflen){cout<<len<<endl;beflen=len;}\n  ll tmp=Compress(p);\n  if(vist.find(tmp)!=vist.end()){\n    ans=len+mp[tmp];\n    return;\n  }\n  if(len==9)return;\n  lol(i,13){\n    if(p[i]==0){\n      lol(j,4){\n    int t=dx[i][j];\n    if(t==0)break;\n    t--;\n    if(p[t]!=0){\n      swap(p[i],p[t]);\n      tmp=Compress(p);\n      if(st.find(tmp)!=st.end())continue;\n      st.insert(tmp);\n      Q.push(make_pair(tmp,len+1));\n      swap(p[i],p[t]);\n    }\n      }\n    }\n  }\n}\nint main(){\n  int p[13];\n  lol(i,13)p[i]=i;p[12]=0;\n  Q.push(make_pair(Compress(p),0));\n  while(!Q.empty()){\n    ll data=Q.front().first;\n    int len=Q.front().second;\n    Q.pop();\n    if(mp[data]>0)continue;\n    Unzip(data);\n    BFS(unzip,len);\n  }\n  //cout<<\"#\"<<mp.size()<<endl;\n  while(cin>>p[0]&&p[0]!=-1){\n    for(int i=1;i<13;i++)cin>>p[i];\n    ans=mod;\n    Q.push(make_pair(Compress(p),0));\n    while(!Q.empty()){\n      ll data=Q.front().first;\n      int len=Q.front().second;\n      Q.pop();\n      if(ans!=mod)continue;\n      if(st.find(data)!=st.end())continue;\n      st.insert(data);\n      Unzip(data);\n      EFS(unzip,len);\n    }\n    st.clear();\n    if(ans>20)cout<<\"NA\"<<endl;\n    else cout<<ans<<endl;\n  }\n  return 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include <iostream>\n#include <stdlib.h>\nusing namespace std;\n\nint p[5][5],x[11]={1,2,3,0,1,2,3,4,1,2,3},y[11]={1,1,1,2,2,2,2,2,3,3,3},s,sx[2],sy[2]\n    ,mx[4]={1,0,-1,0},my[4]={0,-1,0,1},lt;\nint search(int t,int mx2,int my2,int mc) {\n\tint a,i,j,x2,y2,s2;\n\tif (t-1>=lt) return 0;\n\tif (s==0) { lt=t-1; return 1;}\n\t  for (i=0;i<2;i++) for (j=0;j<4;j++) {\n\t  x2=sx[i]+mx[j]; y2=sy[i]+my[j];\n\t  if (x2<0 || x2>4 || y2<0 || y2>4) continue;\n\t  if (p[y2][x2]<1 || ( mc==i  && mx2==-mx[j] && my2==-my[j])) continue;\n\t  s2=abs(x2-x[p[y2][x2]-1])+abs(y2-y[p[y2][x2]-1])-abs(sx[i]-x[p[y2][x2]-1])-abs(sy[i]-y[p[y2][x2]-1]);\n\t  if (s-s2>lt-t) continue;\n\t  p[sy[i]][sx[i]]=p[y2][x2]; p[y2][x2]=0;  s+=s2; \n\t  sx[i]=x2; sy[i]=y2;\n\t  a=search(t+1,mx[j],my[j],i);\n\t  sx[i]=x2-mx[j]; sy[i]=y2-my[j];\n\t  p[y2][x2]=p[sy[i]][sx[i]]; p[sy[i]][sx[i]]=0; s-=s2;\n\t  if (a==1) return 0;\n  }\n  return 0;\n}\n\nint main() {\n  int i,j,k;\n  for (i=0;i<5;i++) for (j=0;j<5;j++) p[i][j]=-1;\n  while (cin >> p[0][2] && p[0][2]!=-1) {\n\t  cin >> p[1][1] >> p[1][2] >> p[1][3];\n\t  cin >> p[2][0] >> p[2][1] >> p[2][2] >> p[2][3] >> p[2][4];\n\t  cin >> p[3][1] >> p[3][2] >> p[3][3];\n\t  cin >> p[4][2]; k=0; s=0;\n\t  for (i=0;i<5;i++) for (j=0;j<5;j++) {\n\t\t  if (p[i][j]==0) { sx[k++]=j; sy[k++]=i;}\n\t\t  if (p[i][j]>0) s+=abs(j-x[p[i][j]-1])+abs(i-y[p[i][j]-1]);\n\t\t   }\n\t  lt=21;\t   \n\t  search(1,0,0,0);\n\t  if (lt==21) cout << \"NA\" << endl; else cout << lt << endl;\n  } \n return 0;\n}\t"
  },
  {
    "language": "C++",
    "code": "#include<map>\n#include<queue>\n#include<cstdio>\n#include<vector>\n\n#define\tpb\tpush_back\n\nusing namespace std;\n\ntypedef\tvector<int>\tvi;\n\nvi mv[13];\nlong long pow12[13];\n\nvoid findEmptyPos(long long stat,int *z){\n\tfor(int i=0,j=0;i<13;i++){\n\t\tif(stat%12==0)\tz[j++]=12-i;\n\t\tstat/=12;\n\t}\n}\n\nlong long sw(long long stat,int i,int j){\n\tlong long powi=pow12[12-i],powj=pow12[12-j];\n\tint pi=(stat/powi)%12,pj=(stat/powj)%12;\n\treturn stat+(pj-pi)*powi+(pi-pj)*powj;\n}\n\nvoid bfs(map<long long,int> &f,long long inistat,int stop){\n\tf[inistat]=0;\n\tqueue<long long> qu;\tqu.push(inistat);\n\twhile(!qu.empty()){\n\t\tlong long stat=qu.front();\tqu.pop();\n\t\tint cnt=f[stat];\n\t\tif(cnt==stop)\tbreak;\n\n\t\tint z[2];\tfindEmptyPos(stat,z);\n\t\tfor(int i=0;i<2;i++){\n\t\t\tfor(int j=0;j<mv[z[i]].size();j++){\n\t\t\t\tlong long nextstat=sw(stat,z[i],mv[z[i]][j]);\n\t\t\t\tif(f.count(nextstat)==0){\n\t\t\t\t\tqu.push(nextstat);\n\t\t\t\t\tf[nextstat]=cnt+1;\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t}\n}\n\nint main(){\n\tlong long a=1;\n\tfor(int i=0;i<13;i++)\tpow12[i]=a,a*=12;\n\n\tmv[0].pb(2);\n\tmv[1].pb(2);\tmv[1].pb(5);\n\tmv[2].pb(0);\tmv[2].pb(1);\tmv[2].pb(3);\tmv[2].pb(6);\n\tmv[3].pb(2);\tmv[3].pb(7);\n\tmv[4].pb(5);\n\tmv[5].pb(1);\tmv[5].pb(4);\tmv[5].pb(6);\tmv[5].pb(9);\n\tmv[6].pb(2);\tmv[6].pb(5);\tmv[6].pb(7);\tmv[6].pb(10);\n\tmv[7].pb(3);\tmv[7].pb(6);\tmv[7].pb(8);\tmv[7].pb(11);\n\tmv[8].pb(7);\n\tmv[9].pb(5);\tmv[9].pb(10);\n\tmv[10].pb(6);\tmv[10].pb(9);\tmv[10].pb(11);\tmv[10].pb(12);\n\tmv[11].pb(7);\tmv[11].pb(10);\n\tmv[12].pb(10);\n\n\tint ans[]={0,1,2,3,4,5,6,7,8,9,10,11,0};\n\tlong long ansstat=0;\n\tfor(int i=0;i<13;i++)\tansstat=ansstat*12+ans[i];\n\n\tmap<long long,int> f;\n\tbfs(f,ansstat,11);\n\n\tfor(long long inistat;scanf(\"%lld\",&inistat),~inistat;){\n\t\tfor(int i=1,p;i<13;i++)\tscanf(\"%d\",&p),inistat=inistat*12+p;\n\t\tmap<long long,int> g;\n\t\tbfs(g,inistat,9);\n\n\t\tint cmin=21;\n\t\tmap<long long,int>::iterator it;\n\t\tfor(it=g.begin();it!=g.end();it++){\n\t\t\tlong long stat=it->first;\n\t\t\tint cnt=it->second;\n\t\t\tif(f.count(stat))\tcmin=min(cmin,cnt+f[stat]);\n\t\t}\n\t\tif(cmin<=20)\tprintf(\"%d\\n\",cmin);\n\t\telse\tputs(\"NA\");\n\t}\n\n\treturn 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include<bits/stdc++.h>\nusing namespace std;\n  \ntypedef long long int64;\nconst int INF = 1 << 30;\n  \nvector< int > edge[13];\nmap< string, int > memo;\n \nbool back(string str, int cnt){ //枝刈り大事だな\n  static int dist[] = { 0, 2, 1, 2, 4, 3, 2, 3, 4, 2, 1, 2, 0};\n  static int fuee[] = { 2, 0, 1, 2, 2, 1, 2, 3, 4, 2, 3, 4, 4};\n  static int fuga[] = { 1, 1, 0, 1, 3, 2, 1, 2, 3, 3, 2, 3, 3};\n  static int haaa[] = { 2, 2, 1, 0, 4, 3, 2, 1, 2, 4, 3, 2, 4};\n  static int kira[] = { 3, 3, 2, 3, 3, 2, 1, 2, 3, 1, 0, 1, 1};\n \n  if(cnt > 20) return true;\n  int foo1 = 0, foo2 = 0, foo3 = 0, foo4 = 0, foo5 = 0;\n  for(int i = 0; i < 13; i++){\n    if(str[i] == '0') foo1 += dist[i];\n    else if(str[i] == '1') foo2 += fuee[i];\n    else if(str[i] == '2') foo3 += fuga[i];\n    else if(str[i] == '3') foo4 += haaa[i];\n    else if(str[i] == 'A') foo5 += kira[i];\n  }\n  return cnt + foo1 + foo2 + foo3 + foo4 + foo5 > 27;\n}\n \n \nint bfs(string mas){\n \n  queue< string > que;\n  map< string , int > used;\n  que.push( mas );\n  memo[mas] = 0;\n  while(!que.empty()){\n \n    string p = que.front(); que.pop();\n    if(back( p, memo[p])) break;\n    if(p == \"0123456789AB0\") return memo[p];\n \n    for(int i = 0; i < 13; i++){\n      if(p[i] == '0') {\n        for(int j = 0; j < edge[i].size(); j++){\n          string next = p;\n          swap( next[i], next[edge[i][j]]);\n          if(memo.find(next) != memo.end()) continue;\n          que.push( next );\n          memo[next] = memo[p] + 1;\n        }\n      }\n    }\n  }\n  return -1;\n}\n \nint main(){\n  vector< int > mas(13);\n \n  edge[0].push_back(2);\n  edge[1].push_back(2); edge[1].push_back(4);\n  edge[2].push_back(0); edge[2].push_back(1); edge[2].push_back(3); edge[2].push_back(6);\n  edge[3].push_back(2); edge[3].push_back(7);\n  edge[4].push_back(5);\n  edge[5].push_back(1); edge[5].push_back(4); edge[5].push_back(6); edge[5].push_back(9);\n  edge[6].push_back(2); edge[6].push_back(5); edge[6].push_back(7); edge[6].push_back(10);\n  edge[7].push_back(3); edge[7].push_back(6); edge[7].push_back(8); edge[7].push_back(11);\n  edge[8].push_back(7);\n  edge[9].push_back(5); edge[9].push_back(10);\n  edge[10].push_back(6); edge[10].push_back(9); edge[10].push_back(11); edge[10].push_back(12);\n  edge[11].push_back(7); edge[11].push_back(10);\n  edge[12].push_back(10);\n \n  while(cin >> mas[0], mas[0] != -1){\n    for(int i = 1; i < 13; i++){\n      cin >> mas[i];\n    }\n \n    string start = \"\";\n    for(int i = 0; i < 13; i++){\n      if(mas[i] >= 10) start += (char)(mas[i] - 10 + 'A');\n      else start += mas[i] + '0';\n    }\n    int ret = bfs(start);\n    if(~ret) cout << ret << endl;\n    else cout << \"NA\" << endl;\n \n    memo.clear();\n  }\n}"
  },
  {
    "language": "C++",
    "code": "#define _USE_MATH_DEFINES\n#define INF 10000000\n#include <iostream>\n#include <sstream>\n#include <cmath>\n#include <algorithm>\n#include <queue>\n#include <stack>\n#include <limits>\n#include <map>\n#include <string>\n#include <cstring>\n#include <set>\n#include <deque>\n#include <bitset>\n\nusing namespace std;\n\ntypedef long long ll;\ntypedef pair<int,string> P;\n\nstatic const double eps = 1e-8;\n\nstatic const int t[][2] = {{1,0},{0,1},{-1,0},{0,-1}};\nstatic const int s[][2] = {{0,2},{1,1},{1,2},{1,3},\n{2,0},{2,1},{2,2},{2,3},{2,4},{3,1},{3,2},{3,3},{4,2}};\n\nvoid bfs(map<vector< vector<int> >,int>& cost,vector< vector<int> >& rv){\n\tcost[rv] = 0;\n\tqueue<vector< vector<int> > > que;\n\tque.push(rv);\n\n\twhile(!que.empty()){\n\t\tvector< vector<int> > now = que.front();\n\t\tque.pop();\n\n\t\tfor(int i=0;i<13;i++){\n\t\t\tint x = s[i][1];\n\t\t\tint y = s[i][0];\n\t\t\tif(now[y][x] != 0) continue;\n\n\t\t\tfor(int j=0;j<4;j++){\n\t\t\t\tint dx = x + t[j][0];\n\t\t\t\tint dy = y + t[j][1];\n\n\t\t\t\tif(dy < 0 || dy >= 5 || dx < 0 || dx >= 5) continue;\n\t\t\t\tif(now[dy][dx] == -1) continue;\n\t\t\t\tif(now[dy][dx] == 0) continue;\n\n\t\t\t\tvector< vector<int> > tmp = now;\n\t\t\t\tswap(tmp[y][x],tmp[dy][dx]);\n\n\t\t\t\tif(cost.find(tmp) != cost.end()) continue;\n\t\t\t\tcost[tmp] = cost[now] + 1;\n\t\t\t\tif(cost[tmp] > 20) continue;\n\t\t\t\tque.push(tmp);\n\t\t\t}\n\t\t}\n\t}\n}\n\nint main(){\n\tint table[5][5];\n\tint root[5][5];\n\tmemset(table,-1,sizeof(table));\n\tmemset(root,-1,sizeof(root));\n\troot[0][2] = 0;\n\troot[1][1]=1; root[1][2]=2; root[1][3]=3;\n\troot[2][0]=4; root[2][1]=5; root[2][2]=6; root[2][3]=7; root[2][4]=8;\n\troot[3][1]=9; root[3][2]=10; root[3][3]=11;\n\troot[4][2] = 0;\n\n\tvector< vector<int> > rv(5,vector<int>(5));\n\tmap<vector< vector<int> >,int> cost;\n\n\tfor(int y=0;y<5;y++){\n\t\tfor(int x=0;x<5;x++){\n\t\t\trv[y][x] = root[y][x];\n\t\t}\n\t}\n\tbfs(cost,rv);\n\n\twhile(~scanf(\"%d\",&table[0][2])){\n\t\tif(table[0][2] == -1) break;\n\t\tscanf(\"%d %d %d\",&table[1][1],&table[1][2],&table[1][3]);\n\t\tscanf(\"%d %d %d %d %d\",&table[2][0],&table[2][1],&table[2][2],&table[2][3],&table[2][4]);\n\t\tscanf(\"%d %d %d\",&table[3][1],&table[3][2],&table[3][3]);\n\t\tscanf(\"%d\",&table[4][2]);\n\t\tvector< vector<int> > tv(5,vector<int>(5));\n\n\t\tfor(int y=0;y<5;y++){\n\t\t\tfor(int x=0;x<5;x++){\n\t\t\t\ttv[y][x] = table[y][x];\n\t\t\t}\n\t\t}\n\n\t\tif(cost.find(tv) != cost.end()) printf(\"%d\\n\",cost[tv]);\n\t\telse printf(\"NA\\n\");\n\t}\n}"
  },
  {
    "language": "C++",
    "code": "#include<iostream>\n#include<algorithm>\n#include<vector>\n#include<queue>\n#include<unordered_map>\n#include<unordered_set>\n#define lol(i,n) for(int i=0;i<n;i++)\n#define mod 1000000007\ntypedef long long ll;\nusing namespace std;\nint dx[13][4]={\n  {3,0,0,0},\n  {3,6,0,0},\n  {1,2,4,7},\n  {3,8,0,0},\n  {6,0,0,0},\n  {2,5,7,10},\n  {3,6,8,11},\n  {4,7,9,12},\n  {8,0,0,0},\n  {6,11,0,0},\n  {7,10,12,13},\n  {8,11,0,0},\n  {11,0,0,0}\n};\nunordered_map<ll,int> mp;\nll Compress(int p[]){\n  ll ans=0;\n  for(int i=0;i<13;i++){\n    ans*=13;\n    ans+=p[i];\n  }\n  return ans;\n}\n \nint unzip[13];\nvoid Unzip(ll x){\n  for(int i=0;i<13;i++){\n    unzip[12-i]=x%13;\n    x/=13;\n  }\n}\n \nint beflen=0;\nunordered_set<ll> vist;\nqueue<pair<ll,int> >Q;\nvoid BFS(int p[],int len){\n  //if(len!=beflen){cout<<len<<endl;beflen=len;}\n  ll tmp=Compress(p);\n  mp[tmp]=len;\n  if(len==13)return;\n  lol(i,13){\n    if(p[i]==0){\n      lol(j,4){\n    int t=dx[i][j];\n    if(t==0)break;\n    t--;\n    if(p[t]!=0){\n      swap(p[i],p[t]);\n      tmp=Compress(p);\n      if(vist.find(tmp)!=vist.end())continue;\n      vist.insert(tmp);\n      Q.push(make_pair(tmp,len+1));\n      swap(p[i],p[t]);\n    }\n      }\n    }\n  }\n}\n \nunordered_set<ll> st;\nint ans;\nvoid EFS(int p[],int len){\n  //if(len!=beflen){cout<<len<<endl;beflen=len;}\n  ll tmp=Compress(p);\n  if(vist.find(tmp)!=vist.end()){\n    ans=len+mp[tmp];\n    return;\n  }\n  if(len==9)return;\n  lol(i,13){\n    if(p[i]==0){\n      lol(j,4){\n    int t=dx[i][j];\n    if(t==0)break;\n    t--;\n    if(p[t]!=0){\n      swap(p[i],p[t]);\n      tmp=Compress(p);\n      if(st.find(tmp)!=st.end())continue;\n      st.insert(tmp);\n      Q.push(make_pair(tmp,len+1));\n      swap(p[i],p[t]);\n    }\n      }\n    }\n  }\n}\nint main(){\n  int p[13];\n  lol(i,13)p[i]=i;p[12]=0;\n  Q.push(make_pair(Compress(p),0));\n  while(!Q.empty()){\n    ll data=Q.front().first;\n    int len=Q.front().second;\n    Q.pop();\n    if(mp[data]>0)continue;\n    Unzip(data);\n    BFS(unzip,len);\n  }\n  //cout<<\"#\"<<mp.size()<<endl;\n  while(cin>>p[0]&&p[0]!=-1){\n    for(int i=1;i<13;i++)cin>>p[i];\n    ans=mod;\n    Q.push(make_pair(Compress(p),0));\n    while(!Q.empty()){\n      ll data=Q.front().first;\n      int len=Q.front().second;\n      Q.pop();\n      if(ans!=mod)continue;\n      if(st.find(data)!=st.end())continue;\n      st.insert(data);\n      Unzip(data);\n      EFS(unzip,len);\n    }\n    st.clear();\n    if(ans>20)cout<<\"NA\"<<endl;\n    else cout<<ans<<endl;\n  }\n  return 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include <cstdio>\n#include <cstring>\n#include <algorithm>\n#include <string>\n#include <cmath>\n#include <stack>\n#include <vector>\n#include <map>\n#include <set>\n#include <queue>\n#include <list>\n#include <iostream>\n#include <sstream>\n#include <climits>\n#include <cfloat>\n#include <complex>\n\nusing namespace std;\n\ntypedef long long ll;\n\nll encode(int* state)\n{\n\tll res = 0;\n\tfor (int i = 0; i < 13; ++i)\n\t\tres = res << 4 | state[i];\n\treturn res;\n}\nvoid decode(int* d, ll e)\n{\n\tfor (int i = 12; i >= 0; --i, e >>= 4)\n\t\td[i] = e & 15;\n}\nvoid p(ll s)\n{\n\tint d[13];\n\tdecode(d, s);\n\tfor (int i = 0; i < 13; ++i)\n\t\tprintf(\"%d \", d[i]);\n\tprintf(\"\\n\");\n}\n\nint main()\n{\n\tmap<ll, int> minSteps;\n\tint dir[] = { -1, 1, -2, 2, -4, 4 };\n\tmap<int, bool> ok[3];\n\n\tint o[][9] = {\n\t\t{ 1, 2, 4, 5, 6, 7, 9, 10, -1 },\n\t\t{ 0, 10, -1 },\n\t\t{ 1, 2, 3, 5, 6, 7, -1 }\n\t};\n\tfor (int i = 0; i < 3; ++i)\n\t\tfor (int j = 0; o[i][j] != -1; ++j)\n\t\t\tok[i][o[i][j]] = true;\n\n\tint initial[] = { 0, 1, 2, 3, 4, 5, 6, 7, 8, 9, 10, 11, 0 };\n\tll t = encode(initial);\n\tminSteps[t] = 0;\n\tqueue<ll> q;\n\tq.push(t);\n\n\twhile (!q.empty())\n\t{\n\t\tll e = q.front();\n\t\tq.pop();\n\t\tint d[13];\n\t\tdecode(d, e);\n\n\t\tint zero_pos[2];\n\t\tfor (int i = 0, j = 0; j < 2; ++i)\n\t\t\tif (!d[i])\n\t\t\t\tzero_pos[j++] = i;\n\n\t\tfor (int i = 0; i < 2; ++i)\n\t\t{\n\t\t\tfor (int j = 0; j < 6; ++j)\n\t\t\t{\n\t\t\t\tint a = zero_pos[i];\n\t\t\t\tint b = a + dir[j];\n\t\t\t\tif (a > b)\n\t\t\t\t\tswap(a, b);\n\t\t\t\tif (a < 0 || b > 12 || !d[a] && !d[b] || !ok[j/2][a])\n\t\t\t\t\tcontinue;\n\n\t\t\t\tint copy[13];\n\t\t\t\tmemcpy(copy, d, sizeof(copy));\n\t\t\t\tswap(copy[a], copy[b]);\n\t\t\t\tll next = encode(copy);\n\n\t\t\t\tif (!minSteps.count(next))\n\t\t\t\t{\n\t\t\t\t\tminSteps[next] = minSteps[e] + 1;\n\t\t\t\t\tif (minSteps[next] < 10)\n\t\t\t\t\t\tq.push(next);\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t}\n\n\twhile (true)\n\t{\n\t\tint d[13];\n\t\tfor (int i = 0; i < 13; ++i)\n\t\t\tscanf(\"%d\", d + i);\n\t\tif (d[0] == -1)\n\t\t\tbreak;\n\n\t\tint ans = -1;\n\t\tll s = encode(d);\n\t\tif (minSteps.count(s))\n\t\t\tans = minSteps[s];\n\t\telse\n\t\t{\n\t\t\tmap<ll, int> c;\n\t\t\tc[s] = 0;\n\t\t\tq = queue<ll>();\n\t\t\tq.push(s);\n\t\t\twhile (!q.empty())\n\t\t\t{\n\t\t\t\tll e = q.front();\n\t\t\t\tq.pop();\n\t\t\t\tint d[13];\n\t\t\t\tdecode(d, e);\n\n\t\t\t\tint zero_pos[2];\n\t\t\t\tfor (int i = 0, j = 0; j < 2; ++i)\n\t\t\t\t\tif (!d[i])\n\t\t\t\t\t\tzero_pos[j++] = i;\n\n\t\t\t\tfor (int i = 0; i < 2; ++i)\n\t\t\t\t{\n\t\t\t\t\tfor (int j = 0; j < 6; ++j)\n\t\t\t\t\t{\n\t\t\t\t\t\tint a = zero_pos[i];\n\t\t\t\t\t\tint b = a + dir[j];\n\t\t\t\t\t\tif (a > b)\n\t\t\t\t\t\t\tswap(a, b);\n\t\t\t\t\t\tif (a < 0 || b > 12 || !d[a] && !d[b] || !ok[j/2][a])\n\t\t\t\t\t\t\tcontinue;\n\n\t\t\t\t\t\tint copy[13];\n\t\t\t\t\t\tmemcpy(copy, d, sizeof(copy));\n\t\t\t\t\t\tswap(copy[a], copy[b]);\n\t\t\t\t\t\tll next = encode(copy);\n\n\t\t\t\t\t\tif (minSteps.count(next))\n\t\t\t\t\t\t{\n\t\t\t\t\t\t\tans = 10 + c[e] + 1;\n\t\t\t\t\t\t\tgoto End;\n\t\t\t\t\t\t}\n\t\t\t\t\t\tif (!c.count(next) && c[e] < 9)\n\t\t\t\t\t\t{\n\t\t\t\t\t\t\tc[next] = c[e] + 1;\n\t\t\t\t\t\t\tq.push(next);\n\t\t\t\t\t\t}\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t}\n\t\t}\nEnd:\n\t\tif (ans != -1)\n\t\t\tprintf(\"%d\\n\", ans);\n\t\telse\n\t\t\tputs(\"NA\");\n\t}\n\n\treturn 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include <iostream>\n#include <sstream>\n#include <cstdio>\n#include <cstdlib>\n#include <cmath>\n#include <ctime>\n#include <cstring>\n#include <climits>\n#include <algorithm>\n#include <map>\n#include <set>\n#include <stack>\n#include <vector>\n#include <queue>\n#include <bitset>\n#include <string>\nusing namespace std;\n \n#define rep(i,n) for(int i=0; i<n; i++)\n#define repa(i,s,e) for(int i=s; i<=e; i++)\n#define repd(i,s,e) for(int i=s; i>=e; i--)\n#define PB(a) push_back(a)\n#define MP(i,s) make_pair(i,s)\n \ntypedef long long ll;\n\nconst int dx[4] = {-1, 0, 0, 1};\nconst int dy[4] = {0, -1, 1, 0};\nconst int field[5][5] = {\n\t{0, 0, 1, 0, 0}, \n\t{0, 1, 1, 1, 0},\n\t{1, 1, 1, 1, 1},\n\t{0, 1, 1, 1, 0},\n\t{0, 0, 1, 0, 0}, \n};\n\nconst int ans[5][5] = {\n\t{0, 0, 0, 0, 0},\n\t{0, 1, 2, 3, 0},\n\t{4, 5, 6, 7, 8},\n\t{0, 9, 10, 11, 0},\n\t{0, 0, 0, 0, 0}\n};\n\nconst int px[13] = {2, 1, 2, 3, 0, 1, 2, 3, 4, 1, 2, 3, 2};\nconst int py[13] = {0, 1, 1, 1, 2, 2, 2, 2, 2, 3, 3, 3, 4};\n\nll H;\nint P[5][5];\nset<ll> used;\n\nll hash_val() {\n\tll h = 0;\n\trep(i,13) {\n\t\th *= 13;\n\t\th += P[py[i]][px[i]];\n\t}\n\treturn h;\n}\n\nbool dfs(int m, int d) {\n\tll h = hash_val();\n\tif(h == H) \treturn true;\n\t\n\tif(m == d) return false;\n\n\tif(used.find(h) != used.end()) return false;\n\n\tused.insert(h);\n\trep(i,13) {\n\t\tint x = px[i];\n\t\tint y = py[i];\n\t\tif(P[y][x] == 0) {\n\t\t\trep(k,4) {\n\t\t\t\tint xx = x + dx[k];\n\t\t\t\tint yy = y + dy[k];\n\t\t\t\tif(xx>=0 && yy>=0 && xx<5 && yy<5 && field[yy][xx] == 1 && P[yy][xx] != 0) {\n\t\t\t\t\tswap(P[y][x], P[yy][xx]);\n\t\t\t\t\tif(dfs(m+1, d)) return true;\n\t\t\t\t\tswap(P[y][x], P[yy][xx]);\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t}\n\treturn false;\n}\n\nvoid solve() {\n\trep(d,20) {\n\t\tused.clear();\n\t\tif(dfs(0, d)) {\n\t\t\tprintf(\"%d\\n\", d);\n\t\t\treturn;\n\t\t}\n\t}\n\tprintf(\"NA\\n\");\n}\n\nint main() {\n\tmemcpy(P, ans, sizeof(P));\n\tH = hash_val();\n\tfor(;;) {\n\t\trep(i,13) {\n\t\t\tscanf(\"%d\", &P[py[i]][px[i]]);\n\t\t\tif(P[py[i]][px[i]] < 0) return 0;\n\t\t}\n\t\tsolve();\n\t}\n}"
  },
  {
    "language": "C++",
    "code": "#include <cstdio>\n#include <cstring>\n#include <algorithm>\n#include <string>\n#include <cmath>\n#include <stack>\n#include <vector>\n#include <map>\n#include <set>\n#include <queue>\n#include <list>\n#include <iostream>\n#include <sstream>\n#include <climits>\n#include <cfloat>\n#include <complex>\n\nusing namespace std;\n\ntypedef long long ll;\n\nll encode(int* state)\n{\n\tll res = 0;\n\tfor (int i = 0; i < 13; ++i)\n\t\tres = res << 4 | state[i];\n\treturn res;\n}\nvoid decode(int* d, ll e)\n{\n\tfor (int i = 12; i >= 0; --i, e >>= 4)\n\t\td[i] = e & 15;\n}\n\nmap<ll, int> minSteps;\nint dir[] = { -1, 1, -2, 2, -4, 4 };\nmap<int, bool> ok[3];\n\nconst int InitialDepth = 14;\nmap<ll, int> problemSteps;\n\nint start_from_initial(ll current, ll next)\n{\n\tbool newState = minSteps.count(next) == 0;\n\tif (newState)\n\t\tminSteps[next] = minSteps[current] + 1;\n\n\treturn newState && minSteps[next] < InitialDepth ? 0 : -1;\n}\nint start_from_problem(ll current, ll next)\n{\n\tbool newState = problemSteps.count(next) == 0;\n\tif (newState)\n\t\tproblemSteps[next] = problemSteps[current] + 1;\n\n\tif (minSteps.count(next))\n\t\treturn problemSteps[next] + minSteps[next];\n\n\treturn newState && problemSteps[next] < 20 - InitialDepth ? 0 : -1;\n}\nint bfs(ll initial, int (*f)(ll, ll))\n{\n\tqueue<ll> q;\n\tq.push(initial);\n\n\twhile (!q.empty())\n\t{\n\t\tll e = q.front();\n\t\tq.pop();\n\t\tint d[13];\n\t\tdecode(d, e);\n\n\t\tint zero_pos[2];\n\t\tfor (int i = 0, j = 0; j < 2; ++i)\n\t\t\tif (!d[i])\n\t\t\t\tzero_pos[j++] = i;\n\n\t\tfor (int i = 0; i < 2; ++i)\n\t\t{\n\t\t\tfor (int j = 0; j < 6; ++j)\n\t\t\t{\n\t\t\t\tint a = zero_pos[i];\n\t\t\t\tint b = a + dir[j];\n\t\t\t\tif (a > b)\n\t\t\t\t\tswap(a, b);\n\t\t\t\tif (a < 0 || b > 12 || !d[a] && !d[b] || !ok[j/2][a])\n\t\t\t\t\tcontinue;\n\n\t\t\t\tint copy[13];\n\t\t\t\tmemcpy(copy, d, sizeof(copy));\n\t\t\t\tswap(copy[a], copy[b]);\n\t\t\t\tll next = encode(copy);\n\n\t\t\t\tint r = f(e, next);\n\t\t\t\tif (r == 0)\n\t\t\t\t\tq.push(next);\n\t\t\t\telse if (r > 0)\n\t\t\t\t\treturn r;\n\t\t\t}\n\t\t}\n\t}\n\n\treturn -1;\n}\n\nint main()\n{\n\tint o[][9] = {\n\t\t{ 1, 2, 4, 5, 6, 7, 9, 10, -1 },\n\t\t{ 0, 10, -1 },\n\t\t{ 1, 2, 3, 5, 6, 7, -1 }\n\t};\n\tfor (int i = 0; i < 3; ++i)\n\t\tfor (int j = 0; o[i][j] != -1; ++j)\n\t\t\tok[i][o[i][j]] = true;\n\n\tint initial[] = { 0, 1, 2, 3, 4, 5, 6, 7, 8, 9, 10, 11, 0 };\n\tll t = encode(initial);\n\tminSteps[t] = 0;\n\n\tbfs(t, start_from_initial);\n\n\twhile (true)\n\t{\n\t\tint d[13];\n\t\tfor (int i = 0; i < 13; ++i)\n\t\t\tscanf(\"%d\", d + i);\n\t\tif (d[0] == -1)\n\t\t\tbreak;\n\n\t\tint ans = -1;\n\t\tll s = encode(d);\n\t\tif (minSteps.count(s))\n\t\t\tans = minSteps[s];\n\t\telse\n\t\t{\n\t\t\tproblemSteps.clear();\n\t\t\tans = bfs(s, start_from_problem);\n\t\t}\n\n\t\tif (ans != -1)\n\t\t\tprintf(\"%d\\n\", ans);\n\t\telse\n\t\t\tputs(\"NA\");\n\t}\n\n\treturn 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include <cstdio>\n#include <cstdlib>\n#include <cmath>\n#include <climits>\n#include <cfloat>\n#include <map>\n#include <utility>\n#include <set>\n#include <iostream>\n#include <memory>\n#include <string>\n#include <vector>\n#include <algorithm>\n#include <functional>\n#include <sstream>\n#include <complex>\n#include <stack>\n#include <queue>\n#include <cstring>\n#include <sstream>\n#include <cassert>\n#include <list>\nusing namespace std;\nstatic const double EPS = 1e-10;\ntypedef long long ll;\ntypedef pair<int,int> PI;\ntypedef vector<int> vi;\n#ifndef M_PI\n#define M_PI 3.14159265358979323846\n#endif\n#define rep(i,n) for(int i=0;i<(int)n;++i)\n#define FOR(i,c) for(__typeof((c).begin())i=(c).begin();i!=(c).end();++i)\n#define ALL(c) (c).begin(), (c).end()\n#define mp(a,b) make_pair(a,b)\n#define pb(a) push_back(a)\n#define F first\n#define S second\ntemplate <typename T> string print_array(const vector<T> &V) { ostringstream os; os << \"{ \"; for (typename vector<T>::const_iterator iter = V.begin(); iter != V.end(); ++iter) os << '\\\"' << *iter << \"\\\",\"; os << \" }\"; return os.str(); }\n\nint dx[]={0,1,0,-1},dy[]={1,0,-1,0};\n\ntypedef struct{\n  vector<int> in;\n  int s1,s2;\n}state;\n\nvector<int> se[13];\n\nvoid pr(vector<int> in){\n  if(in.size()!=13)return;\n\n  printf(\"      %3d\\n\",in[0]);\n  printf(\"   %3d%3d%3d\\n\",in[1],in[2],in[3]);\n  printf(\"%3d%3d%3d%3d%3d\\n\",in[4],in[5],in[6],in[7],in[8]);\n  printf(\"   %3d%3d%3d\\n\",in[9],in[10],in[11]);\n  printf(\"      %3d\\n\",in[12]);\n  puts(\"\");\n}\n\nmain(){\n  int p;\n  vector<int> goal(13);\n  rep(i,11)goal[i+1]=i+1;\n  //cout<<print_array(goal)<<endl;\n\n  se[0].pb(2);\n  se[1].pb(2);\n  se[1].pb(5);\n  se[2].pb(0);\n  se[2].pb(1);\n  se[2].pb(3);\n  se[2].pb(6);\n  se[3].pb(2);\n  se[3].pb(7);\n  se[4].pb(5);\n  se[5].pb(1);\n  se[5].pb(4);\n  se[5].pb(6);\n  se[5].pb(9);\n  se[6].pb(2);\n  se[6].pb(5);\n  se[6].pb(7);\n  se[6].pb(10);\n  se[7].pb(3);\n  se[7].pb(6);\n  se[7].pb(8);\n  se[7].pb(11);\n  se[8].pb(7);\n  se[9].pb(5);\n  se[9].pb(10);\n  se[10].pb(6);\n  se[10].pb(9);\n  se[10].pb(11);\n  se[10].pb(12);\n  se[11].pb(7);\n  se[11].pb(10);\n  se[12].pb(10);\n  \n  while(cin>>p){\n    if(p==-1)break;\n    vector<int> in;\n    in.pb(p);\n    rep(i,12){\n      cin>>p;\n      in.pb(p);\n    }\n\n    set<vector<int> > app;\n\n    queue<pair<int,vector<int> > > Q;\n    app.insert(in);\n    Q.push(mp(0,in));\n    int ans=21;\n\n    while(!Q.empty()){\n      vector<int> cvec=Q.front().S;\n      int ccost=Q.front().F;\n      Q.pop();\n      //cout<<print_array(cvec)<<endl;\n      //pr(cvec);\n      //if(ccost>3)break;\n      if(ccost>20)break;\n      if(cvec==goal){\n\tans=ccost;\n\tbreak;\n      }\n      rep(i,cvec.size()){\n\tif(!cvec[i]){\n\t  rep(j,se[i].size()){\n\t    if(cvec[se[i][j]]){\n\t      swap(cvec[se[i][j]],cvec[i]);\n\t      if(!app.count(cvec)){\n\t\tapp.insert(cvec);\n\t\tQ.push(mp(ccost+1,cvec));\n\t      }\n\t      swap(cvec[se[i][j]],cvec[i]);\n\t    }\n\t  }\n\t}\n      }\n    }\n    if(ans==21)cout<<\"NA\"<<endl;\n    else cout<<ans<<endl;\n  }\n}"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\n\n#ifndef INCLUDE_ZOBRIST_HASH_HPP\n#define INCLUDE_ZOBRIST_HASH_HPP\n\n#include <random>\n#include <iostream>\n#include <typeinfo>\n\nnamespace orislib {\n\ntemplate <typename T, int W, int H, int STATE>\nstruct ZobristHash {\n  typedef T hash_t;\n  ZobristHash() {\n    std::random_device rd;\n    std::mt19937 mt(rd());\n    std::uniform_int_distribution<T> dist;\n    for (int h = 0; h < H; h++) {\n      for (int w = 0; w < W; w++) {\n        for (int s = 0; s < STATE; s++) {\n          rands[h][w][s] = dist(mt);\n        }\n      }\n    }\n  }\n  template <typename TT>\n  hash_t hash(TT data[H][W]) {\n    hash_t r = 0;\n    for (int h = 0; h < H; h++) {\n      for (int w = 0; w < W; w++) {\n        r ^= rands[h][w][data[h][w]];\n      }\n    }\n    return r;\n  }\n  hash_t rands[H][W][STATE];\n};\n}\n\n#endif\nusing namespace std;\nusing namespace orislib;\n\ntypedef long long ll;\ntypedef long double ld;\ntypedef tuple<int, int> duo;\nconst int dx[] = {0, 0, 1, -1, 1, 1, -1, -1};\nconst int dy[] = {1, -1, 0, 0, 1, -1, 1, -1};\nconst int Mod = 1000000000 + 0;\n//{{{ templates\n#define TT_             \\\n  template <typename T> \\\n  inline\n#define TTF_                        \\\n  template <typename T, typename F> \\\n  inline\nTT_ T sq(T x) { return x * x; }\nTT_ T In() {\n  T x;\n  cin >> x;\n  return x;\n}\nTT_ void Out(T& x) { cout << x; }\nTT_ void sort(T& v) { sort(begin(v), end(v)); }\nTT_ void revs(T& v) { reverse(begin(v), end(v)); }\nTT_ void uniq(T& v) {\n  sort(v);\n  v.erase(unique(begin(v), end(v)), end(v));\n}\nTT_ int ubnd(T& v, typename T::value_type& x) {\n  return upper_bound(begin(v), end(v), x) - begin(v);\n}\nTT_ int lbnd(T& v, typename T::value_type& x) {\n  return lower_bound(begin(v), end(v), x) - begin(v);\n}\nTTF_ void inpt(T& v, int n, F f) {\n  for (v.reserve(n); n--; v.emplace_back(f()))\n    ;\n}\nTTF_ void show(T& v, F f, string d = \" \", string e = \"\\n\") {\n  int i = 0;\n  for (auto& x : v) i++&&(cout << d), f(x);\n  cout << e;\n}\nTT_ typename T::iterator minel(T& v) { return min_element(begin(v), end(v)); }\nTT_ typename T::iterator maxel(T& v) { return max_element(begin(v), end(v)); }\n\ninline void fast_io() {\n  ios::sync_with_stdio(0);\n  cin.tie(0);\n}\ninline int in() {\n  int x;\n  scanf(\"%d\", &x);\n  return x;\n}\ninline ll pow_mod(ll a, ll k, ll m) {\n  ll r = 1;\n  for (; k > 0; a = a * a % m, k >>= 1)\n    if (k & 1) r = r * a % m;\n  return r;\n}\ninline ll mod_inv(ll a, ll p) { return pow_mod(a, p - 2, p); }\n//}}} priority_queue queue deque front stringstream max_element min_element\n//insert count make_tuple\n\nstruct Board {\n  Board() {}\n  Board(const vector<vector<int>>& v) {\n    memset(b, '#', sizeof(b));\n    for (int i = 0; i < 5; i++) b[i][5] = 0;\n    for (int i = 0; i < v[0].size(); i++) b[0][2 + i] = conv_hex(v[0][i]);\n    for (int i = 0; i < v[1].size(); i++) b[1][1 + i] = conv_hex(v[1][i]);\n    for (int i = 0; i < v[2].size(); i++) b[2][0 + i] = conv_hex(v[2][i]);\n    for (int i = 0; i < v[3].size(); i++) b[3][1 + i] = conv_hex(v[3][i]);\n    for (int i = 0; i < v[4].size(); i++) b[4][2 + i] = conv_hex(v[4][i]);\n    int it = 0;\n    for (int i = 0; i < 5; i++) {\n      for (int j = 0; j < 5; j++) {\n        if (b[i][j] == '0') {\n          cx[it] = j;\n          cy[it] = i;\n          it++;\n        }\n      }\n    }\n    turn = 0;\n  }\n  char conv_hex(int a) { return \"0123456789ABCDEF\"[a]; }\n  bool slide(int index, int dir) {\n    int px = cx[index], py = cy[index];\n    int nx = px + dx[dir], ny = py + dy[dir];\n    if (invalid(nx, ny)) return false;\n    if (b[ny][nx] == '#') return false;\n    if (b[ny][nx] == '0') return false;\n    swap(b[py][px], b[ny][nx]);\n    cx[index] = nx;\n    cy[index] = ny;\n    turn++;\n    return true;\n  }\n  bool is_ok() {\n    static const char cb[5][6] = {\n        \"##0##\", \"#123#\", \"45678\", \"#9AB#\", \"##0##\", };\n    return memcmp(cb, b, sizeof(cb)) == 0;\n  }\n  bool invalid(int x, int y) { return x < 0 || x >= 5 || y < 0 || y >= 5; }\n  char b[5][6];\n  int cx[2], cy[2];\n  int turn;\n};\n\nint main() {\n  ZobristHash<int, 6, 5, 256> zh;\n  int h;\n  while (h = in(), h != -1) {\n    vector<vector<int>> vs(5);\n    vs[0].emplace_back(h);\n    inpt(vs[1], 3, in);\n    inpt(vs[2], 5, in);\n    inpt(vs[3], 3, in);\n    inpt(vs[4], 1, in);\n    Board b(vs);\n    queue<Board> Q;\n    set<int> vis;\n    Q.push(b);\n    vis.insert(zh.hash(b.b));\n\n    while (!Q.empty()) {\n      Board bi = Q.front();\n      Q.pop();\n      if (bi.turn > 15) break;\n      if (bi.is_ok()) {\n        cout << bi.turn << endl;\n        goto END;\n      }\n      for (int i = 0; i < 2; i++) {\n        for (int d = 0; d < 4; d++) {\n          Board bii = bi;\n          if (!bii.slide(i, d)) continue;\n          int hv = zh.hash(bii.b);\n          if (vis.count(hv)) continue;\n          vis.insert(hv);\n          Q.push(bii);\n        }\n      }\n    }\n  }\n  cout << \"NA\" << endl;\nEND:\n  ;\n}\nreturn 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include <cstdio>\n#include <cstring>\n#include <algorithm>\n#include <string>\n#include <cmath>\n#include <stack>\n#include <vector>\n#include <map>\n#include <set>\n#include <queue>\n#include <list>\n#include <iostream>\n#include <sstream>\n#include <climits>\n#include <cfloat>\n#include <complex>\n\nusing namespace std;\n\ntypedef long long ll;\n\nll encode(int* state)\n{\n\tll res = 0;\n\tfor (int i = 0; i < 13; ++i)\n\t\tres = res << 4 | state[i];\n\treturn res;\n}\nvoid decode(int* d, ll e)\n{\n\tfor (int i = 12; i >= 0; --i, e >>= 4)\n\t\td[i] = e & 15;\n}\n\nmap<ll, int> minSteps;\nint dir[] = { -1, 1, -2, 2, -4, 4 };\nmap<int, bool> ok[3];\n\nconst int InitialDepth = 12;\nmap<ll, int> problemSteps;\n\nint start_from_initial(ll current, ll next)\n{\n\tbool newState = minSteps.count(next) == 0;\n\tif (newState)\n\t\tminSteps[next] = minSteps[current] + 1;\n\n\treturn newState && minSteps[next] < InitialDepth ? 0 : -1;\n}\nint start_from_problem(ll current, ll next)\n{\n\tbool newState = problemSteps.count(next) == 0;\n\tif (newState)\n\t\tproblemSteps[next] = problemSteps[current] + 1;\n\n\tif (minSteps.count(next))\n\t\treturn problemSteps[next] + minSteps[next];\n\n\treturn newState && problemSteps[next] < 20 - InitialDepth ? 0 : -1;\n}\nint bfs(ll initial, int (*f)(ll, ll))\n{\n\tqueue<ll> q;\n\tq.push(initial);\n\n\twhile (!q.empty())\n\t{\n\t\tll e = q.front();\n\t\tq.pop();\n\t\tint d[13];\n\t\tdecode(d, e);\n\n\t\tint zero_pos[2];\n\t\tfor (int i = 0, j = 0; j < 2; ++i)\n\t\t\tif (!d[i])\n\t\t\t\tzero_pos[j++] = i;\n\n\t\tfor (int i = 0; i < 2; ++i)\n\t\t{\n\t\t\tfor (int j = 0; j < 6; ++j)\n\t\t\t{\n\t\t\t\tint a = zero_pos[i];\n\t\t\t\tint b = a + dir[j];\n\t\t\t\tif (a > b)\n\t\t\t\t\tswap(a, b);\n\t\t\t\tif (a < 0 || b > 12 || !d[a] && !d[b] || !ok[j/2][a])\n\t\t\t\t\tcontinue;\n\n\t\t\t\tint copy[13];\n\t\t\t\tmemcpy(copy, d, sizeof(copy));\n\t\t\t\tswap(copy[a], copy[b]);\n\t\t\t\tll next = encode(copy);\n\n\t\t\t\tint r = f(e, next);\n\t\t\t\tif (r == 0)\n\t\t\t\t\tq.push(next);\n\t\t\t\telse if (r > 0)\n\t\t\t\t\treturn r;\n\t\t\t}\n\t\t}\n\t}\n\n\treturn -1;\n}\n\nint main()\n{\n\tint o[][9] = {\n\t\t{ 1, 2, 4, 5, 6, 7, 9, 10, -1 },\n\t\t{ 0, 10, -1 },\n\t\t{ 1, 2, 3, 5, 6, 7, -1 }\n\t};\n\tfor (int i = 0; i < 3; ++i)\n\t\tfor (int j = 0; o[i][j] != -1; ++j)\n\t\t\tok[i][o[i][j]] = true;\n\n\tint initial[] = { 0, 1, 2, 3, 4, 5, 6, 7, 8, 9, 10, 11, 0 };\n\tll t = encode(initial);\n\tminSteps[t] = 0;\n\n\tbfs(t, start_from_initial);\n\n\twhile (true)\n\t{\n\t\tint d[13];\n\t\tfor (int i = 0; i < 13; ++i)\n\t\t\tscanf(\"%d\", d + i);\n\t\tif (d[0] == -1)\n\t\t\tbreak;\n\n\t\tint ans = -1;\n\t\tll s = encode(d);\n\t\tif (minSteps.count(s))\n\t\t\tans = minSteps[s];\n\t\telse\n\t\t{\n\t\t\tproblemSteps.clear();\n\t\t\tans = bfs(s, start_from_problem);\n\t\t}\n\n\t\tif (ans != -1)\n\t\t\tprintf(\"%d\\n\", ans);\n\t\telse\n\t\t\tputs(\"NA\");\n\t}\n\n\treturn 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include <iostream>\n#include <vector>\n \nusing namespace std;\n \nstruct P {\n    int y, x;\n    P(int y, int x) : y{y}, x{x} {}\n};\n \nint limit;\nvector<int> v;\n \nP getPos(int x)\n{\n    if (x == 0) return P(0, 2);\n    if (1 <= x && x <= 3) return P(1, x);\n    if (4 <= x && x <= 8) return P(2, x - 4);\n    if (9 <= x && x <= 11) return P(3, x - 8);\n    return P(4, 2);\n}\n \nint getPos(P p)\n{\n    switch (p.y) {\n        case 0:\n            return (p.x == 2 ? 0 : -1);\n        case 1:\n            return (1 <= p.x && p.x <= 3 ? p.x : -1);\n        case 2:\n            return (0 <= p.x && p.x <= 4 ? p.x + 4 : -1); \n        case 3:\n            return (1 <= p.x && p.x <= 3 ? p.x + 8 : -1);\n        case 4:\n            return (p.x == 2 ? 12 : -1);\n    }\n    return -1;\n}\n \nint getMD()\n{\n    int sum = 0;\n    for (int i = 0; i < 13; i++) {\n        if (v[i] == 0) continue;\n        P np = getPos(i);\n        P tp = getPos(v[i]);\n        sum += abs(np.x - tp.x) + abs(np.y - tp.y);\n    }\n    return sum;\n}\n \nconstexpr int dx[] = {-1, 0, 1, 0};\nconstexpr int dy[] = {0, -1, 0, 1};\n \nbool dfs(int sp1, int sp2, int step)\n{\n    int md = getMD();\n    if (md == 0) return 1;\n    if (md + step > limit) {\n        return 0;\n    }\n    P p[2] = {getPos(sp1), getPos(sp2)};\n    for (int i = 0; i < 2; i++) {\n        int x = p[i].x, y = p[i].y;\n        for (int j = 0; j < 4; j++) {\n            int nx = x + dx[j], ny = y + dy[j];\n            P np(ny, nx);\n            int next = getPos(np);\n            if (next == -1) continue;\n            if (i == 0) {\n                swap(v[sp1], v[next]);\n                if (dfs(next, sp2, step + 1)) {\n                    return 1;\n                }\n                swap(v[sp1], v[next]);\n            } else {\n                swap(v[sp2], v[next]);\n                if (dfs(sp1, next, step + 1)) {\n                    return 1;\n                }\n                swap(v[sp2], v[next]);\n            }\n        }\n    }\n    return 0;\n}\n \nint main()\n{\n    int x;\n    while (cin >> x, x != -1) {\n        int sp[2];\n        v.resize(13); v[0] = x;\n        for (int i = 1; i < 13; i++) {\n            cin >> v[i];\n        }\n        for (int i = 0, j = 0; i < 13; i++) {\n            if (v[i] == 0) {\n                sp[j++] = i;\n            }\n        }\n        bool found = 0;\n        constexpr int LIMIT = 20;\n        for (limit = 0; limit <= LIMIT; limit++) {\n            if (dfs(sp[0], sp[1], 0)) {\n                cout << limit << endl;\n                found = 1;\n                break;\n            }\n        }\n        if (!found) {\n            cout << \"NA\" << endl;\n        }\n    }\n    return 0;\n}"
  },
  {
    "language": "C++",
    "code": "#import<iostream>\n#import<map>\n#import<queue>\n#import<cstdlib>\n#import<cstring>\nusing namespace std;struct B{int z[2];char s[14];bool operator<(const B&r)const{return strcmp(s,r.s)<0;}};main(){int a[13][5]={{2,-1},{2,5,-1},{0,1,3,6,-1},{2,7,-1},{5,-1},{1,4,6,9,-1},{2,5,7,10,-1},{3,6,8,11,-1},{7,-1},{5,10,-1},{6,9,11,12,-1},{7,10,-1},{10,-1}},X[]={2,1,2,3,0,1,2,3,4,1,2,3,2},Y[]={0,1,1,1,2,2,2,2,2,3,3,3,4},v,d,s,i,j,t,u;B g={0,0,\"0123456789:;0\"};for(;;){map<B,int>m;deque<B>q;B b={i=-1,-1};for(;++i<13;!v?b.z[*b.z>=0]=i:0){cin>>v;if(v<0)return 0;b.s[i]=48+v;}b.s[13]=0;m[b]=1;for(q.push_back(b);!q.empty();q.pop_front()){B&b=q.front();if(!strcmp(b.s,g.s))break;d=0;for(i=13;i--;v?d+=abs(X[v]-X[i])+abs(Y[v]-Y[i]):0)v=b.s[i]-48;s=m[b];if(s+d<22)for(j=2;j--;)for(i=0;~a[u=b.z[j]][i];i++){B n=b;t=n.z[j]=a[u][i];if(t-n.z[1-j]){swap(n.s[u],n.s[t]);int&r=m[n];if(!r)r=s+1,q.push_back(n);}}}printf(m[g]?\"%d\\n\":\"NA\\n\",m[g]-1);}}"
  },
  {
    "language": "C++",
    "code": "#include <cmath>\n#include <iostream>\n#include <string>\n#include <vector>\n#include <queue>\n#include <map>\n#include <set>\n#include <array>\n#include <sstream>\nusing namespace std;\n#ifdef _MSC_VER\n#include \"_lib_msc.h\"\n#endif\n#define ITER(c)             __typeof__((c).begin())\n#define REP(i, n)           for(int(i)=0;(i)<(n);++(i))\ntemplate<class _T> _T MAX(_T p1,_T p2){return (p2<p1)?p1:p2;} \ntemplate<class _T> _T MIN(_T p1,_T p2){return (p1<p2)?p1:p2;} \ntypedef vector<int> VI;\ntypedef vector<VI> VVI;\n#define mp                  make_pair\n#define pb                  push_back\n\nconst int inf = 1<<29;\n\ntypedef array<char,13> obj;\nobj final  = {{0,1,2,3,4,5,6,7,8,9,10,11,0}};\nobj final1 = {{2,1,0,3,4,5,6,7,8,9,0,11,10}};\nobj final2 = {{2,1,0,3,4,5,6,7,8,9,10,11,0}};\nobj final3 = {{0,1,2,3,4,5,6,7,8,9,0,11,10}};\nint mov[][5] = {\n    {2,-1},         // 0\n    {2,5,-1},       // 1\n    {0,1,3,6,-1},   // 2\n    {2,7,-1},       // 3\n    {5,-1},         // 4\n    {1,4,6,9,-1},   // 5\n    {2,5,7,10,-1},  // 6\n    {3,6,8,11,-1},  // 7\n    {7,-1},         // 8\n    {5,10,-1},      // 9\n    {6,9,11,12,-1}, // 10\n    {7,10,-1},      // 11\n    {10,-1},        // 12\n};\nint dtblm[5][5] = {\n    {-1, -1,  0, -1, -1},\n    {-1,  1,  2,  3, -1},\n    { 4,  5,  6,  7,  8},\n    {-1,  9, 10, 11, -1},\n    {-1, -1, 12, -1, -1},\n};\nint dtbl[13][13];\n\nvoid mktbl(){\n    REP(y1,5) REP(x1,5){\n        if(dtblm[y1][x1] == -1) continue;\n        int k1 = dtblm[y1][x1];\n        REP(y2,5) REP(x2,5){\n            if(dtblm[y2][x2] == -1) continue;\n            int k2 = dtblm[y2][x2];\n            dtbl[k1][k2] = abs(x1-x2) + abs(y1-y2);\n        }\n    }\n}\n\nstruct QOBJ{\n    obj p;\n    int sp[2];\n    QOBJ(obj p, int sp1, int sp2) : p(p){sp[0]=sp1,sp[1]=sp2;}\n};\n\nint distance(const obj &p){\n    int total = 0;\n    REP(i,13){\n        if(p[i] == 0) continue;\n        total += dtbl[i][(int)(p[i])];\n    }\n    return total;\n}\n\nstring solve(const obj &o){\n    if(o == final) return \"0\";\n\n    map<obj, int> memo;\n    queue<QOBJ> q;\n    int sp1 = -1, sp2 = -1;\n    REP(i,13) if(o[i] == 0){\n        if(sp1 == -1) sp1 = i; else sp2 = i;\n    }\n    q.push(QOBJ(o,sp1,sp2));\n    memo[o] = 0;\n    int maxstep = 20;\n\n    while(!q.empty()){\n        QOBJ &p = q.front();\n        obj &pp = p.p;\n        int step = memo[pp];\n        if(step + distance(pp) < maxstep){\n            REP(sp,2){\n                int sps = p.sp[sp];\n                REP(mi, 4){\n                    int spd = mov[sps][mi];\n                    if(spd == -1) break;\n                    swap(pp[sps],pp[spd]);\n                    ITER(memo) it = memo.find(pp);\n                    if(it == memo.end() || it->second > step+1){\n                        if(it == memo.end()){\n                            memo[pp] = step+1;\n                        } else {\n                            it->second = step+1;\n                        }\n                        if(pp == final){\n                            maxstep = step;\n                        }\n                            if(sp == 0){\n                                q.push(QOBJ(pp,spd,p.sp[1]));\n                            } else {\n                                q.push(QOBJ(pp,p.sp[0],spd));\n                            }\n                    }\n                    swap(pp[sps],pp[spd]);\n                }\n            }\n        }\n        q.pop();\n    }\n    if(memo.count(final) == 0) return \"NA\";\n    if(memo[final] >= 21) return \"NA\";\n\n    stringstream ss;\n    ss << memo[final];\n\n    return ss.str();\n}\n\nint main(void){\n    mktbl();\n    int n,m;\n    while(cin >> n && n != -1){\n        obj o;\n        o[0] = n;\n        REP(i,3){ cin >> m; o[i+1] = m; }\n        REP(i,5){ cin >> m; o[i+4] = m; }\n        REP(i,3){ cin >> m; o[i+9] = m; }\n        cin >> m; o[12] = m;\n        cout << solve(o) << endl;\n    }\n    return 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include <iostream>\n#include <string>\n#include <vector>\n#include <queue>\n#include <map>\nusing namespace std;\n\nstring s = \"0123456789AB\";\nstring goal = \"0123456789AB0\";\n\nvector<vector<int>> adj = {\n    {2},\n    {2,5},\n    {0,1,3,6},\n    {2,7},\n    {5},\n    {1,4,6,9},\n    {2,5,7,10},\n    {3,6,8,11},\n    {7},\n    {5,10},\n    {6,9,11,12},\n    {7,10},\n    {10}\n};\n\nint solve(string stat) {\n    if (stat == goal) return 0;\n    map<string, int> dist;\n    dist[stat] = 0;\n    queue<string> q;\n    q.push(stat);\n    while ( ! q.empty()) {\n        string s = q.front();\n        q.pop();\n        for (int i=0; i<13; ++i) {\n            if (s[i] != '0') continue;\n            for (int j : adj[i]) {\n                string next = s;\n                next[i] = s[j];\n                next[j] = s[i];\n                int diff = 0;\n                for (int k=0; k<13; ++k) {\n                    if (next[k] != '0') {\n                        diff += next[k] != goal[k];\n                    }\n                }\n                if ( ! diff) {\n                    return dist[s] + 1;\n                }\n                if (dist.find(next) == dist.end()) {\n                    dist[next] = dist[s] + 1;\n                    if (dist[next] + diff <= 20) {\n                        q.push(next);\n                    }\n                }\n            }\n        }\n    }\n    return 21;\n}\n\nint main() {\n    while (1) {\n        string stat = \"\";\n        int k;\n        for (int i=0; i<13; ++i) {\n            if (cin >> k && !~k) return 0;\n            stat += s[k];\n        }\n        int ans = solve(stat);\n        if (ans <= 20) {\n            cout << ans << endl;\n            continue;\n        }\n        cout << \"NA\" << endl;\n    }\n    return 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\n\nusing namespace std;\n\ntypedef long long ll;\ntypedef long double ld;\ntypedef tuple<int, int> duo;\nconst int dx[] = {0, 0, 1, -1, 1, 1, -1, -1};\nconst int dy[] = {1, -1, 0, 0, 1, -1, 1, -1};\nconst int Mod = 1000000000 + 0;\n//{{{ templates\n#define TT_             \\\n  template <typename T> \\\n  inline\n#define TTF_                        \\\n  template <typename T, typename F> \\\n  inline\nTT_ T sq(T x) { return x * x; }\nTT_ T In() {\n  T x;\n  cin >> x;\n  return x;\n}\nTT_ void Out(T& x) { cout << x; }\nTT_ void sort(T& v) { sort(begin(v), end(v)); }\nTT_ void revs(T& v) { reverse(begin(v), end(v)); }\nTT_ void uniq(T& v) {\n  sort(v);\n  v.erase(unique(begin(v), end(v)), end(v));\n}\nTT_ int ubnd(T& v, typename T::value_type& x) {\n  return upper_bound(begin(v), end(v), x) - begin(v);\n}\nTT_ int lbnd(T& v, typename T::value_type& x) {\n  return lower_bound(begin(v), end(v), x) - begin(v);\n}\nTTF_ void inpt(T& v, int n, F f) {\n  for (v.reserve(n); n--; v.emplace_back(f()))\n    ;\n}\nTTF_ void show(T& v, F f, string d = \" \", string e = \"\\n\") {\n  int i = 0;\n  for (auto& x : v) i++&&(cout << d), f(x);\n  cout << e;\n}\nTT_ typename T::iterator minel(T& v) { return min_element(begin(v), end(v)); }\nTT_ typename T::iterator maxel(T& v) { return max_element(begin(v), end(v)); }\n\ninline void fast_io() {\n  ios::sync_with_stdio(0);\n  cin.tie(0);\n}\ninline int in() {\n  int x;\n  scanf(\"%d\", &x);\n  return x;\n}\ninline ll pow_mod(ll a, ll k, ll m) {\n  ll r = 1;\n  for (; k > 0; a = a * a % m, k >>= 1)\n    if (k & 1) r = r * a % m;\n  return r;\n}\ninline ll mod_inv(ll a, ll p) { return pow_mod(a, p - 2, p); }\n//}}} priority_queue queue deque front stringstream max_element min_element\n// insert count make_tuple\n\nstruct Board {\n  Board() {\n    memcpy(b, \"0123456789AB0\", sizeof(b));\n    find_zero();\n  }\n  Board(const vector<int>& v) {\n    for (int i = 0; i < 13; i++) b[i] = conv_hex(v[i]);\n    b[13] = 0;\n    find_zero();\n  }\n  void find_zero(){\n    int it = 0;\n    for (int i = 0; i < 13; i++){\n      if (b[i] == '0'){\n        cur[it] = i;\n        it++;\n      }\n    }\n  }\n  char conv_hex(int a) { return \"0123456789ABCDEF\"[a]; }\n  bool slide(int index, int dir) {\n    static const char mov[][4] = {\n      {-1, -1, 2, -1},\n      {-1, 2, 5, -1},\n      {0, 3, 6, 1},\n      {-1, -1, 7, 2},\n      {-1, 5, -1, -1},\n      {1, 6, 9, 4},\n      {2, 7, 10, 5},\n      {3, 8, 11, 6},\n      {-1, -1, -1, 7},\n      {5, 10, -1, -1},\n      {6, 11, 12, 9},\n      {7, -1, -1, 10},\n      {10, -1, -1, -1},\n    };\n    char cu = cur[index];\n    char nu = mov[cu][dir];\n    if (nu == -1) return false;\n    if (b[nu] == '0') return false;\n    swap(b[cu], b[nu]);\n    cur[index] = nu;\n    turn++;\n    return true;\n  }\n  char b[14];\n  char cur[2];\n  char turn;\n};\n\nint main() {\n  int h;\n  while (h = in(), h != -1) {\n    vector<int> vs;\n    vs.push_back(h);\n    for (int i = 0; i < 12; i++) vs.push_back(in());\n    Board b(vs);\n    unordered_set<ll> vis;\n    queue<Board> Q;\n    Q.push(b);\n    while (!Q.empty()){\n      Board bi = Q.front();\n      Q.pop();\n      ll hv = strtoll(bi.b, 0, 16);\n      if (vis.count(hv)) continue;\n      vis.insert(hv);\n      if (hv == 0x0123456789AB0ll){\n        cout << (int)bi.turn << endl;\n        goto END;\n      }\n      if (bi.turn >= 20) continue;\n      for (int i = 0; i < 2; i++){\n        for (int d = 0; d < 4; d++){\n          Board bii = bi;\n          if (!bii.slide(i, d)) continue;\n          Q.emplace(move(bii));\n        }\n      }\n    }\n    cout << \"NA\\n\";\nEND:;\n  }\n  return 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\n\n#ifndef INCLUDE_ZOBRIST_HASH_HPP\n#define INCLUDE_ZOBRIST_HASH_HPP\n\n#include <random>\n#include <iostream>\n#include <typeinfo>\n\nnamespace orislib {\n\ntemplate <typename T, int W, int H, int STATE>\nstruct ZobristHash {\n  typedef T hash_t;\n  ZobristHash() {\n    std::random_device rd;\n    std::mt19937 mt(rd());\n    std::uniform_int_distribution<T> dist;\n    for (int h = 0; h < H; h++) {\n      for (int w = 0; w < W; w++) {\n        for (int s = 0; s < STATE; s++) {\n          rands[h][w][s] = dist(mt);\n        }\n      }\n    }\n  }\n  template <typename TT>\n  hash_t hash(TT data[H][W]) {\n    hash_t r = 0;\n    for (int h = 0; h < H; h++) {\n      for (int w = 0; w < W; w++) {\n        r ^= rands[h][w][data[h][w]];\n      }\n    }\n    return r;\n  }\n  hash_t rands[H][W][STATE];\n};\n}\n\n#endif\nusing namespace std;\nusing namespace orislib;\n\ntypedef long long ll;\ntypedef long double ld;\ntypedef tuple<int, int> duo;\nconst int dx[] = {0, 0, 1, -1, 1, 1, -1, -1};\nconst int dy[] = {1, -1, 0, 0, 1, -1, 1, -1};\nconst int Mod = 1000000000 + 0;\n//{{{ templates\n#define TT_             \\\n  template <typename T> \\\n  inline\n#define TTF_                        \\\n  template <typename T, typename F> \\\n  inline\nTT_ T sq(T x) { return x * x; }\nTT_ T In() {\n  T x;\n  cin >> x;\n  return x;\n}\nTT_ void Out(T& x) { cout << x; }\nTT_ void sort(T& v) { sort(begin(v), end(v)); }\nTT_ void revs(T& v) { reverse(begin(v), end(v)); }\nTT_ void uniq(T& v) {\n  sort(v);\n  v.erase(unique(begin(v), end(v)), end(v));\n}\nTT_ int ubnd(T& v, typename T::value_type& x) {\n  return upper_bound(begin(v), end(v), x) - begin(v);\n}\nTT_ int lbnd(T& v, typename T::value_type& x) {\n  return lower_bound(begin(v), end(v), x) - begin(v);\n}\nTTF_ void inpt(T& v, int n, F f) {\n  for (v.reserve(n); n--; v.emplace_back(f()))\n    ;\n}\nTTF_ void show(T& v, F f, string d = \" \", string e = \"\\n\") {\n  int i = 0;\n  for (auto& x : v) i++&&(cout << d), f(x);\n  cout << e;\n}\nTT_ typename T::iterator minel(T& v) { return min_element(begin(v), end(v)); }\nTT_ typename T::iterator maxel(T& v) { return max_element(begin(v), end(v)); }\n\ninline void fast_io() {\n  ios::sync_with_stdio(0);\n  cin.tie(0);\n}\ninline int in() {\n  int x;\n  scanf(\"%d\", &x);\n  return x;\n}\ninline ll pow_mod(ll a, ll k, ll m) {\n  ll r = 1;\n  for (; k > 0; a = a * a % m, k >>= 1)\n    if (k & 1) r = r * a % m;\n  return r;\n}\ninline ll mod_inv(ll a, ll p) { return pow_mod(a, p - 2, p); }\n//}}} priority_queue queue deque front stringstream max_element min_element\n// insert count make_tuple\n\nstruct Board {\n  Board() {}\n  Board(const vector<vector<int>>& v) {\n    memset(b, '#', sizeof(b));\n    for (int i = 0; i < 5; i++) b[i][5] = 0;\n    for (int i = 0; i < v[0].size(); i++) b[0][2 + i] = conv_hex(v[0][i]);\n    for (int i = 0; i < v[1].size(); i++) b[1][1 + i] = conv_hex(v[1][i]);\n    for (int i = 0; i < v[2].size(); i++) b[2][0 + i] = conv_hex(v[2][i]);\n    for (int i = 0; i < v[3].size(); i++) b[3][1 + i] = conv_hex(v[3][i]);\n    for (int i = 0; i < v[4].size(); i++) b[4][2 + i] = conv_hex(v[4][i]);\n    int it = 0;\n    for (int i = 0; i < 5; i++) {\n      for (int j = 0; j < 5; j++) {\n        if (b[i][j] == '0') {\n          cx[it] = j;\n          cy[it] = i;\n          it++;\n        }\n      }\n    }\n    turn = 0;\n  }\n  char conv_hex(int a) { return \"0123456789ABCDEF\"[a]; }\n  bool slide(int index, int dir) {\n    int px = cx[index], py = cy[index];\n    int nx = px + dx[dir], ny = py + dy[dir];\n    if (invalid(nx, ny)) return false;\n    if (b[ny][nx] == '#') return false;\n    if (b[ny][nx] == '0') return false;\n    swap(b[py][px], b[ny][nx]);\n    cx[index] = nx;\n    cy[index] = ny;\n    turn++;\n    return true;\n  }\n  bool invalid(int x, int y) { return x < 0 || x >= 5 || y < 0 || y >= 5; }\n  char b[5][6];\n  int cx[2], cy[2];\n  int turn;\n};\n\nint main() {\n  ZobristHash<int, 6, 5, 256> zh;\n  static const char cb[5][6] = {\"##0##\", \"#123#\", \"45678\", \"#9AB#\", \"##0##\", };\n  unordered_map<int, int> ans;\n  Board b;\n  memcpy(b.b, cb, sizeof(cb));\n  b.turn = 0;\n  b.cx[0] = 2;\n  b.cy[0] = 0;\n  b.cx[1] = 2;\n  b.cy[1] = 4;\n  queue<Board> Q;\n  Q.push(b);\n  while (!Q.empty()){\n    Board bi = Q.front();\n    Q.pop();\n    int hv = zh.hash(bi.b);\n    if (ans.count(hv)) continue;\n    ans[hv] = bi.turn;\n    if (bi.turn >= 21) continue;\n    for (int i = 0; i < 2; i++){\n      for (int d = 0; d < 4; d++){\n        Board bii = bi;\n        if (!bii.slide(i, d)) continue;\n        Q.push(bii);\n      }\n    }\n  }\n  int h;\n  while (h = in(), h != -1) {\n    vector<vector<int>> vs(5);\n    vs[0].emplace_back(h);\n    inpt(vs[1], 3, in);\n    inpt(vs[2], 5, in);\n    inpt(vs[3], 3, in);\n    inpt(vs[4], 1, in);\n    Board b(vs);\n    int hv = zh.hash(b.b);\n    if (ans.count(hv)) cout << ans[hv] << endl;\n    else cout << \"NA\\n\";\n  }\n  return 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include <iostream>\n#include <sstream>\n#include <cstdio>\n#include <cstdlib>\n#include <cmath>\n#include <ctime>\n#include <cstring>\n#include <climits>\n#include <algorithm>\n#include <map>\n#include <set>\n#include <stack>\n#include <vector>\n#include <queue>\n#include <bitset>\n#include <string>\nusing namespace std;\n \n#define rep(i,n) for(int i=0; i<n; i++)\n#define repa(i,s,e) for(int i=s; i<=e; i++)\n#define repd(i,s,e) for(int i=s; i>=e; i--)\n#define PB(a) push_back(a)\n#define MP(i,s) make_pair(i,s)\n \ntypedef long long ll;\n\nconst int dx[4] = {-1, 0, 0, 1};\nconst int dy[4] = {0, -1, 1, 0};\n\nconst int field[5][5] = {\n\t{0, 0, 1, 0, 0}, \n\t{0, 1, 1, 1, 0},\n\t{1, 1, 1, 1, 1},\n\t{0, 1, 1, 1, 0},\n\t{0, 0, 1, 0, 0}, \n};\n\nconst int ans[5][5] = {\n\t{0, 0, 0, 0, 0},\n\t{0, 1, 2, 3, 0},\n\t{4, 5, 6, 7, 8},\n\t{0, 9, 10, 11, 0},\n\t{0, 0, 0, 0, 0}\n};\n\nconst int px[13] = {2, 1, 2, 3, 0, 1, 2, 3, 4, 1, 2, 3, 2};\nconst int py[13] = {0, 1, 1, 1, 2, 2, 2, 2, 2, 3, 3, 3, 4};\n\nint P[5][5];\nmap<ll,int> used;\nmap<ll,int> H;\n\nll hash_val() {\n\tll h = 0;\n\trep(i,13) {\n\t\th *= 13;\n\t\th += P[py[i]][px[i]];\n\t}\n\treturn h;\n}\n\nvoid make_ans(int m, int d) {\n\tll h = hash_val();\n\tmap<ll,int>::iterator it = H.find(h);\n\t\n\tif(it == H.end()) {\n\t\tH.insert(MP(h,m));\n\t} else if((*it).second > m) {\n\t\t(*it).second = m;\n\t} else {\n\t\treturn;\n\t}\n\n\tif(m == d) return;\n\n\n\trep(i,13) {\n\t\tint x = px[i];\n\t\tint y = py[i];\n\t\tif(P[y][x] == 0) {\n\t\t\trep(k,4) {\n\t\t\t\tint xx = x + dx[k];\n\t\t\t\tint yy = y + dy[k];\n\t\t\t\tif(xx>=0 && yy>=0 && xx<5 && yy<5 && field[yy][xx] == 1 && P[yy][xx] != 0) {\n\t\t\t\t\tswap(P[y][x], P[yy][xx]);\n\t\t\t\t\tmake_ans(m+1, d);\n\t\t\t\t\tswap(P[y][x], P[yy][xx]);\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t}\n}\n\nint dfs(int m, int d) {\n\tmap<ll,int>::iterator it;\n\tll h = hash_val();\n\n\tit = H.find(h);\n\tif(it != H.end()) return m + (*it).second;\n\n\tif(m == d) return -1;\n\t\n\tit = used.find(h);\n\tif(it == used.end()) {\n\t\tused.insert(MP(h,m));\n\t} else if((*it).second > m) {\n\t\t(*it).second = m;\n\t} else {\n\t\treturn -1;\n\t}\n\n\trep(i,13) {\n\t\tint x = px[i];\n\t\tint y = py[i];\n\t\tif(P[y][x] == 0) {\n\t\t\trep(k,4) {\n\t\t\t\tint xx = x + dx[k];\n\t\t\t\tint yy = y + dy[k];\n\t\t\t\tif(xx>=0 && yy>=0 && xx<5 && yy<5 && field[yy][xx] == 1 && P[yy][xx] != 0) {\n\t\t\t\t\tswap(P[y][x], P[yy][xx]);\n\t\t\t\t\tint a = dfs(m+1, d);\n\t\t\t\t\tif(a >= 0) return a;\n\t\t\t\t\tswap(P[y][x], P[yy][xx]);\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t}\n\treturn -1;\n}\n\nvoid solve() {\n\trepa(d,0,10) {\n\t\tused.clear();\n\t\tint a = dfs(0, d);\n\t\tif(a >= 0) {\n\t\t\tprintf(\"%d\\n\", a);\n\t\t\treturn;\n\t\t}\n\t}\n\tprintf(\"NA\\n\");\n}\n\nint main() {\n\tmemcpy(P, ans, sizeof(P));\n\tmake_ans(0, 10);\n\tfor(;;) {\n\t\trep(i,13) {\n\t\t\tscanf(\"%d\", &P[py[i]][px[i]]);\n\t\t\tif(P[py[i]][px[i]] < 0) return 0;\n\t\t}\n\t\tsolve();\n\t}\n}"
  },
  {
    "language": "C++",
    "code": "#include <algorithm>\n#include <cctype>\n#include <climits>\n#include <cmath>\n#include <cstdio>\n#include <cstdlib>\n#include <cstring>\n#include <functional>\n#include <map>\n#include <numeric>\n#include <queue>\n#include <set>\n#include <sstream>\n#include <string>\n#include <vector>\n\nusing namespace std;\n\n#define reps(i,f,n) for(int i=f; i<int(n); ++i)\n#define rep(i,n) reps(i,0,n)\n\ntypedef long long ll;\ntypedef vector<int> vi;\ntypedef vector<vi> vvi;\ntypedef pair<int, int> pii;\n\nconst int INF = 1001001001;\nconst ll FINAL = 0x0ba9876543210ll;\n\nstruct Data\n{\n\tll s;\n\tint d;\n\tbool f;\n\tData(ll s, int d, bool f) : s(s), d(d), f(f) {}\n};\n\nint bfs(ll init)\n{\n\tif(init == FINAL)\n\t\treturn 0;\n\t\n\tconst int move[13][5] = {\n\t\t{2, -1},\n\t\t{2, 5, -1},\n\t\t{0, 1, 3, 6, -1},\n\t\t{2, 7, -1},\n\t\t{5, -1},\n\t\t{1, 4, 6, 9, -1},\n\t\t{2, 5, 7, 10, -1},\n\t\t{3, 6, 8, 11, -1},\n\t\t{7, -1},\n\t\t{5, 10, -1},\n\t\t{6, 9, 11, 12, -1},\n\t\t{7, 10, -1},\n\t\t{10, -1}\n\t};\n\t\n\tset<ll> visited[2];\n\tqueue<Data> Q;\n\tQ.push(Data(init, 0, false));\n\tQ.push(Data(FINAL, 0, true));\n\tvisited[0].insert(init);\n\tvisited[1].insert(FINAL);\n\tint now[2] = {0};\n\t\n\twhile(!Q.empty()){\n\t\tData data = Q.front();\n\t\tQ.pop();\n\t\tnow[data.f] = data.d + 1;\n\n\t\tfor(int i=0, cnt=2; cnt; ++i){\n\t\t\tif(((data.s>>(i*4)) & 0xfll) == 0){\n\t\t\t\tfor(int j=0; move[i][j]!=-1; ++j){\n\t\t\t\t\tll next = data.s;\n\t\t\t\t\tnext &= ~((0xfll << (i*4)) | (0xfll << (move[i][j]*4)));\n\t\t\t\t\tnext |= ((data.s >> (move[i][j]*4)) & 0xfll) << (i*4);\n\t\t\t\t\t\n\t\t\t\t\tif(visited[!data.f].find(next) != visited[!data.f].end())\n\t\t\t\t\t\treturn now[0] + now[1];\n\n\t\t\t\t\tif(visited[data.f].find(next) == visited[data.f].end()){\n\t\t\t\t\t\tvisited[data.f].insert(next);\n\t\t\t\t\t\tif(data.d < 9)\n\t\t\t\t\t\t\tQ.push(Data(next, data.d+1, data.f));\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t\t--cnt;\n\t\t\t}\n\t\t}\n\t}\n\treturn -1;\n}\n\nint main()\n{\n\tfor(;;){\n\t\tint input[13];\n\t\trep(i, 13){\n\t\t\tscanf(\"%d\", &input[i]);\n\t\t\tif(input[i] == -1)\n\t\t\t\treturn 0;\n\t\t}\n\n\t\tll init = 0;\n\t\trep(i, 13)\n\t\t\tinit = (init << 4) | input[12-i];\n\n\t\tint ans = bfs(init);\n\t\tif(ans == -1 || ans > 20)\n\t\t\tputs(\"NA\");\n\t\telse\n\t\t\tprintf(\"%d\\n\", ans);\n\t}\n}"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\n\n#ifndef INCLUDE_ZOBRIST_HASH_HPP\n#define INCLUDE_ZOBRIST_HASH_HPP\n\n#include <random>\n#include <iostream>\n#include <typeinfo>\n\nnamespace orislib {\n\ntemplate<typename T, int W, int H, int STATE>\nstruct ZobristHash {\n  typedef T hash_t;\n  ZobristHash(){\n    std::random_device rd;\n    std::mt19937 mt(rd());\n    std::uniform_int_distribution<T> dist;\n    for (int h = 0; h < H; h++){\n      for (int w = 0; w < W; w++){\n        for (int s = 0; s < STATE; s++){\n          rands[h][w][s] = dist(mt);\n        }\n      }\n    }\n  }\n  template<typename TT>\n  hash_t hash(TT data[H][W]){\n    hash_t r = 0;\n    for (int h = 0; h < H; h++){\n      for (int w = 0; w < W; w++){\n        r ^= rands[h][w][data[h][w]];\n      }\n    }\n    return r;\n  }\n  hash_t rands[H][W][STATE];\n};\n}\n\n#endif\nusing namespace std;\nusing namespace orislib;\n\ntypedef long long ll;\ntypedef long double ld;\ntypedef tuple<int, int> duo;\nconst int dx[] = {0, 0, 1, -1, 1, 1, -1, -1};\nconst int dy[] = {1, -1, 0, 0, 1, -1, 1, -1};\nconst int Mod = 1000000000 + 0;\n//{{{ templates\n#define TT_ template<typename T>inline\n#define TTF_ template<typename T,typename F>inline\nTT_ T sq(T x){return x*x;}\nTT_ T In(){T x;cin>>x;return x;}\nTT_ void Out(T&x){cout<<x;}\nTT_ void sort(T&v){sort(begin(v),end(v));}\nTT_ void revs(T&v){reverse(begin(v),end(v));}\nTT_ void uniq(T&v){sort(v);v.erase(unique(begin(v),end(v)),end(v));}\nTT_ int ubnd(T&v,typename T::value_type&x){return upper_bound(begin(v),end(v),x)-begin(v);}\nTT_ int lbnd(T&v,typename T::value_type&x){return lower_bound(begin(v),end(v),x)-begin(v);}\nTTF_ void inpt(T&v,int n,F f){for(v.reserve(n);n--;v.emplace_back(f()));}\nTTF_ void show(T&v,F f,string d=\" \",string e=\"\\n\"){int i=0;for(auto&x:v)i++&&(cout<<d),f(x);cout<<e;}\nTT_ typename T::iterator minel(T&v){return min_element(begin(v),end(v));}\nTT_ typename T::iterator maxel(T&v){return max_element(begin(v),end(v));}\n\ninline void fast_io(){ios::sync_with_stdio(0);cin.tie(0);}\ninline int in(){int x;scanf(\"%d\",&x);return x;}\ninline ll pow_mod(ll a,ll k,ll m){ll r=1;for(;k>0;a=a*a%m,k>>=1)if(k&1)r=r*a%m;return r;}\ninline ll mod_inv(ll a,ll p){return pow_mod(a,p-2,p);}\n//}}} priority_queue queue deque front stringstream max_element min_element insert count make_tuple\n\nstruct Board {\n  Board(){}\n  Board(const vector<vector<int>>& v){\n    memset(b, '#', sizeof(b));\n    for (int i = 0; i < 5; i++) b[i][5] = 0;\n    for (int i = 0; i < v[0].size(); i++) b[0][2 + i] = conv_hex(v[0][i]);\n    for (int i = 0; i < v[1].size(); i++) b[1][1 + i] = conv_hex(v[1][i]);\n    for (int i = 0; i < v[2].size(); i++) b[2][0 + i] = conv_hex(v[2][i]);\n    for (int i = 0; i < v[3].size(); i++) b[3][1 + i] = conv_hex(v[3][i]);\n    for (int i = 0; i < v[4].size(); i++) b[4][2 + i] = conv_hex(v[4][i]);\n    int it = 0;\n    for (int i = 0; i < 5; i++){\n      for (int j = 0; j < 5; j++){\n        if (b[i][j] == '0'){\n          cx[it] = j;\n          cy[it] = i;\n          it++;\n        }\n      }\n    }\n  }\n  char conv_hex(int a){\n    return \"0123456789ABCDEF\"[a];\n  }\n  bool slide(int index, int dir){\n    int px = cx[index], py = cy[index];\n    int nx = px + dx[dir], ny = py + dy[dir];\n    if (invalid(nx, ny)) return false;\n    if (b[ny][nx] == '#') return false;\n    if (b[ny][nx] == '0') return false;\n    swap(b[py][px], b[ny][nx]);\n    cx[index] = nx;\n    cy[index] = ny;\n    return true;\n  }\n  bool is_ok(){\n    static const char cb[5][6] = {\n      \"##0##\",\n      \"#123#\",\n      \"45678\",\n      \"#9AB#\",\n      \"##0##\",\n    };\n    return memcmp(cb, b, sizeof(cb)) == 0;\n  }\n  bool invalid(int x, int y){\n    return x < 0 || x >= 5 || y < 0 || y >= 5;\n  }\n  char b[5][6];\n  int cx[2], cy[2];\n};\n\nint main()\n{\n  ZobristHash<int, 6, 5, 256> zh;\n  int h;\n  while (h = in(), h != -1){\n    vector<vector<int>> vs(5);\n    vs[0].emplace_back(h);\n    inpt(vs[1], 3, in);\n    inpt(vs[2], 5, in);\n    inpt(vs[3], 3, in);\n    inpt(vs[4], 1, in);\n    Board b(vs);\n    queue<Board> Q;\n    set<int> vis;\n    Q.push(b);\n    vis.insert(zh.hash(b.b));\n\n    int turn = 0;\n    while (!Q.empty()){\n      if (turn > 10) break;\n      queue<Board> nQ;\n      while (!Q.empty()){\n        Board bi = Q.front();\n        Q.pop();\n        if (bi.is_ok()){\n          cout << turn << endl;\n          goto END;\n        }\n        for (int i = 0; i < 2; i++){\n          for (int d = 0; d < 4; d++){\n            Board bii = bi;\n            if (!bii.slide(i, d)) continue;\n            int hv = zh.hash(bii.b);\n            if (vis.count(hv)) continue;\n            vis.insert(hv);\n            nQ.push(bii);\n          }\n        }\n      }\n      swap(Q, nQ);\n      turn++;\n    }\n    cout << \"NA\" << endl;\nEND:;\n  }\n  return 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include <iostream>\n#include <vector>\n\nusing namespace std;\n \nstruct P {\n    int x, y;\n    P(int x, int y) : x{x}, y{y} {}\n};\n \nint limit;\nvector<int> v;\n\nconstexpr int X[] = {2, 1, 2, 3, 0, 1, 2, 3, 4, 1, 2, 3, 2};\nconstexpr int Y[] = {0, 1, 1, 1, 2, 2, 2, 2, 2, 3, 3, 3, 4};\n \nint next_pos(int x, int y)\n{\n    for (int i = 0; i < 13; i++) {\n        if (x == X[i] && y == Y[i]) {\n            return i;\n        }\n    }        \n    return -1;\n}\n \nint getMD()\n{\n    int sum = 0;\n    for (int i = 0; i < 13; i++) {\n        if (v[i] == 0) continue;\n        sum += abs(X[i] - X[v[i]]) + abs(Y[i] - Y[v[i]]);\n    }\n    return sum;\n}\n \nconstexpr int dx[] = {-1, 0, 1, 0};\nconstexpr int dy[] = {0, -1, 0, 1};\n \nbool dfs(const int* sp, int step)\n{\n    int md = getMD();\n    if (md == 0) return 1;\n    if (md + step > limit) {\n        return 0;\n    }\n    \n    for (int i = 0; i < 2; i++) {\n        int x = X[sp[i]], y = Y[sp[i]];\n        for (int j = 0; j < 4; j++) {\n            int nx = x + dx[j], ny = y + dy[j];\n            int next = next_pos(nx, ny);\n            if (next == -1) continue;\n            \n            const int nsp1[] = {next, sp[1]}, nsp2[] = {sp[0], next};\n            \n            swap(v[sp[i]], v[next]);\n            if (i == 0 && dfs(nsp1, step + 1)) {\n                return 1;\n            }\n            if (i == 1 && dfs(nsp2, step + 1)) {\n                return 1;\n            }\n            swap(v[sp[i]], v[next]);\n        }\n    }\n    return 0;\n}\n \nint main()\n{\n    int x;\n    while (cin >> x, x != -1) {\n        int sp[2];\n        v.resize(13); v[0] = x;\n        for (int i = 1; i < 13; i++) {\n            cin >> v[i];\n        }\n\n        for (int i = 0, j = 0; i < 13; i++) {\n            if (v[i] == 0) {\n                sp[j++] = i;\n            }\n        }\n\n        bool found = 0;\n        constexpr int LIMIT = 20;\n        for (limit = 0; limit <= LIMIT; limit++) {\n            if (dfs(sp, 0)) {\n                cout << limit << endl;\n                found = 1;\n                break;\n            }\n        }\n        if (!found) {\n            cout << \"NA\" << endl;\n        }\n    }\n    return 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include <cstdio>\n#include <cstdlib>\n#include <cmath>\n#include <climits>\n#include <cfloat>\n#include <map>\n#include <utility>\n#include <set>\n#include <iostream>\n#include <memory>\n#include <string>\n#include <vector>\n#include <algorithm>\n#include <functional>\n#include <sstream>\n#include <complex>\n#include <stack>\n#include <queue>\n#include <cstring>\n#include <sstream>\n#include <cassert>\n#include <list>\nusing namespace std;\nstatic const double EPS = 1e-10;\ntypedef long long ll;\ntypedef pair<int,int> PI;\ntypedef vector<int> vi;\n#ifndef M_PI\n#define M_PI 3.14159265358979323846\n#endif\n#define rep(i,n) for(int i=0;i<(int)n;++i)\n#define FOR(i,c) for(__typeof((c).begin())i=(c).begin();i!=(c).end();++i)\n#define ALL(c) (c).begin(), (c).end()\n#define mp(a,b) make_pair(a,b)\n#define pb(a) push_back(a)\n#define F first\n#define S second\ntemplate <typename T> string print_array(const vector<T> &V) { ostringstream os; os << \"{ \"; for (typename vector<T>::const_iterator iter = V.begin(); iter != V.end(); ++iter) os << '\\\"' << *iter << \"\\\",\"; os << \" }\"; return os.str(); }\n\nint dx[]={0,1,0,-1},dy[]={1,0,-1,0};\n\nvector<int> se[13];\nint x[]={0,-1,0,1,-2,-1,0,1,2,-1,0,1,0};\nint y[]={2,1,1,1,0,0,0,0,0,-1,-1,-1,-2};\n\nvoid pr(ll in){\n\n  printf(\"      %3lld\\n\",in&15);\n  printf(\"   %3lld%3lld%3lld\\n\",(in>>4)&15,(in>>8)&15,(in>>12)&15);\n  printf(\"%3lld%3lld%3lld%3lld%3lld\\n\",(in>>16)&15,(in>>20)&15,(in>>24)&15,(in>>28)&15,(in>>32)&15);\n  printf(\"   %3lld%3lld%3lld\\n\",(in>>36)&15,(in>>40)&15,(in>>44)&15);\n  printf(\"      %3lld\\n\",(in>>48)&15);\n  puts(\"\");\n}\n\nint manh(ll in){\n  int ret=0;\n  rep(i,13){\n    int t=(in>>(i*4))&15;\n\n    if(!t){\n      int nx=x[t]-x[i],ny=y[t]-y[i];\n      int co=abs(nx)+abs(ny);\n      nx=x[12]-x[i],ny=y[12]-y[i];\n      int k=abs(nx)+abs(ny);\n      ret+=min(co,k);\n      continue;\n    }\n    int nx=(x[t]-x[i]),ny=y[t]-y[i];\n    ret+=abs(nx)+abs(ny);\n  }\n  return ret;\n}\n\nmain(){\n  ll p;\n\n  ll goal=0;\n  rep(i,11){\n    goal|=(i+1LL)<<(4*(i+1));\n    //cout<<goal<<endl;\n    //pr(goal);\n  }\n  //pr(goal);\n\n  se[0].pb(2);\n  se[1].pb(2);\n  se[1].pb(5);\n  se[2].pb(0);\n  se[2].pb(1);\n  se[2].pb(3);\n  se[2].pb(6);\n  se[3].pb(2);\n  se[3].pb(7);\n  se[4].pb(5);\n  se[5].pb(1);\n  se[5].pb(4);\n  se[5].pb(6);\n  se[5].pb(9);\n  se[6].pb(2);\n  se[6].pb(5);\n  se[6].pb(7);\n  se[6].pb(10);\n  se[7].pb(3);\n  se[7].pb(6);\n  se[7].pb(8);\n  se[7].pb(11);\n  se[8].pb(7);\n  se[9].pb(5);\n  se[9].pb(10);\n  se[10].pb(6);\n  se[10].pb(9);\n  se[10].pb(11);\n  se[10].pb(12);\n  se[11].pb(7);\n  se[11].pb(10);\n  se[12].pb(10);\n  \n  while(cin>>p){\n    if(p==-1)break;\n    ll in=p;\n\n    rep(i,12){\n      cin>>p;\n      in|=p<<(4*(i+1));\n    }\n\n    set<ll> app;\n\n    queue<pair<int,ll> > Q;\n    app.insert(in);\n    Q.push(mp(0,in));\n    int ans=21;\n    int mans=0;\n\n    while(!Q.empty()){\n      ll cvec=Q.front().S;\n      int ccost=Q.front().F;\n      Q.pop();\n    \n      //pr(cvec);\n\n      //if(ccost>3)break;\n     if(ccost>20)break;\n     \n      if(cvec==goal){\n\tans=ccost;\n\tbreak;\n      }\n      if(ccost+manh(cvec)>32)continue;\n      rep(i,13){\n\tll t=cvec>>(i<<2);\n\tt=t&15;\n\tif(!t){\n\t  rep(j,se[i].size()){\n\t    t=cvec>>(se[i][j]<<2);\n\t    t=t&15;\n\t    if(t){\n\t      ll nvec=cvec;\n\t      t=t<<(i<<2);\n\t      nvec|=t;\n\t      nvec&=~(15LL<<se[i][j]*4);\n\t      \n\t      if(!app.count(nvec)){\n\t\tapp.insert(nvec);\n\t\tQ.push(mp(ccost+1,nvec));\n\t      }\n\t    }\n\t  }\n\t}\n      }\n    }\n    if(ans==21)cout<<\"NA\"<<endl;\n    else cout<<ans<<endl;\n  }\n}"
  },
  {
    "language": "C++",
    "code": "#include <iostream>\n#include <set>\n#include <queue>\n#include <map>\n#include <algorithm>\n\nusing namespace std;\n\nclass State{\npublic:\n   string s;\n   int cost;\n};\n\nchar tmp;\nint input;\nset<string> visited;\nmap<string, int> memo;\nState u, v;\n\nvoid swap(string &str, int a, int b){\n   tmp = str[a];\n   str[a] = str[b];\n   str[b] = tmp;\n}\n\nvoid pre_bfs(){\n   u.s = \"ABCDEFGHIJKLA\";\n   u.cost = 0;\n   memo[u.s] = u.cost;\n   queue<State>Q;\n   Q.push(u);\n   while(!Q.empty()){\n      u = Q.front(); Q.pop();\n      if(u.cost >= 10) continue;\n      for(int i=0;i<13;i++){\n         if(u.s[i] == 'A'){\n            v.cost = u.cost + 1;\n            switch(i){\n               case 0:\n                  v.s = u.s;\n                  swap(v.s, 0, 2);\n                  if(memo.find(v.s) == memo.end()){\n                     memo[v.s] = v.cost;\n                     Q.push(v);\n                  }\n                  break;\n               case 1:\n                  v.s = u.s;\n                  swap(v.s, i, 2);\n                  if(memo.find(v.s) == memo.end()){\n                     memo[v.s] = v.cost;\n                     Q.push(v);\n                  }\n                  v.s = u.s;\n                  swap(v.s, i, 5);\n                  if(memo.find(v.s) == memo.end()){\n                     memo[v.s] = v.cost;\n                     Q.push(v);\n                  }\n                  break;\n               case 3:\n                  v.s = u.s;\n                  swap(v.s, i, 2);\n                  if(memo.find(v.s) == memo.end()){\n                     memo[v.s] = v.cost;\n                     Q.push(v);\n                  }\n                  v.s = u.s;\n                  swap(v.s, i, 7);\n                  if(memo.find(v.s) == memo.end()){\n                     memo[v.s] = v.cost;\n                     Q.push(v);\n                  }\n                  break;\n               case 4:\n                  v.s = u.s;\n                  swap(v.s, i, 5);\n                  if(memo.find(v.s) == memo.end()){\n                     memo[v.s] = v.cost;\n                     Q.push(v);\n                  }\n                  break;\n               case 8:\n                  v.s = u.s;\n                  swap(v.s, i, 7);\n                  if(memo.find(v.s) == memo.end()){\n                     memo[v.s] = v.cost;\n                     Q.push(v);\n                  }\n                  break;\n               case 9:\n                  v.s = u.s;\n                  swap(v.s, i, 5);\n                  if(memo.find(v.s) == memo.end()){\n                     memo[v.s] = v.cost;\n                     Q.push(v);\n                  }\n                  v.s = u.s;\n                  swap(v.s, i, 10);\n                  if(memo.find(v.s) == memo.end()){\n                     memo[v.s] = v.cost;\n                     Q.push(v);\n                  }\n\n                  break;\n               case 11:\n                  v.s = u.s;\n                  swap(v.s, i, 7);\n                  if(memo.find(v.s) == memo.end()){\n                     memo[v.s] = v.cost;\n                     Q.push(v);\n                  }\n                  v.s = u.s;\n                  swap(v.s, i, 10);\n                  if(memo.find(v.s) == memo.end()){\n                     memo[v.s] = v.cost;\n                     Q.push(v);\n                  }\n                  break;\n               case 12:\n                  v.s = u.s;\n                  swap(v.s, i, 10);\n                  if(memo.find(v.s) == memo.end()){\n                     memo[v.s] = v.cost;\n                     Q.push(v);\n                  }\n                  break;\n               default:\n                  int ue = 4;\n                  int sita = 4;\n                  if(i == 2) ue = 2;\n                  if(i == 10) sita = 2;\n                  v.s = u.s;\n                  swap(v.s, i, i-ue);\n                  if(memo.find(v.s) == memo.end()){\n                     memo[v.s] = v.cost;\n                     Q.push(v);\n                  }\n                  v.s = u.s;\n                  swap(v.s, i, i+sita);\n                  if(memo.find(v.s) == memo.end()){\n                     memo[v.s] = v.cost;\n                     Q.push(v);\n                  }\n                  v.s = u.s;\n                  swap(v.s, i, i+1);\n                  if(memo.find(v.s) == memo.end()){\n                     memo[v.s] = v.cost;\n                     Q.push(v);\n                  }\n                  v.s = u.s;\n                  swap(v.s, i, i-1);\n                  if(memo.find(v.s) == memo.end()){\n                     memo[v.s] = v.cost;\n                     Q.push(v);\n                  }\n                  break;\n            }\n         }\n      }\n   }\n}\n\nint bfs(string str){\n   u.s = str;\n   u.cost = 0;\n   queue<State> Q;\n   Q.push(u);\n   visited.clear();\n   while(!Q.empty()){\n      u = Q.front(); Q.pop();\n      if(memo.find(u.s) != memo.end()){\n         return u.cost + memo[u.s];\n      }\n      if(u.cost >= 10) continue;\n      for(int i=0;i<13;i++){\n         if(u.s[i] == 'A'){\n            v.cost = u.cost + 1;\n            switch(i){\n               case 0:\n                  v.s = u.s;\n                  swap(v.s, 0, 2);\n                  if(visited.find(v.s) == visited.end()){\n                     visited.insert(v.s);\n                     Q.push(v);\n                  }\n                  break;\n               case 1:\n                  v.s = u.s;\n                  swap(v.s, i, 2);\n                  if(visited.find(v.s) == visited.end()){\n                     visited.insert(v.s);\n                     Q.push(v);\n                  }\n                  v.s = u.s;\n                  swap(v.s, i, 5);\n                  if(visited.find(v.s) == visited.end()){\n                     visited.insert(v.s);\n                     Q.push(v);\n                  }\n                  break;\n               case 3:\n                  v.s = u.s;\n                  swap(v.s, i, 2);\n                  if(visited.find(v.s) == visited.end()){\n                     visited.insert(v.s);\n                     Q.push(v);\n                  }\n                  v.s = u.s;\n                  swap(v.s, i, 7);\n                  if(visited.find(v.s) == visited.end()){\n                     visited.insert(v.s);\n                     Q.push(v);\n                  }\n                  break;\n               case 4:\n                  v.s = u.s;\n                  swap(v.s, i, 5);\n                  if(visited.find(v.s) == visited.end()){\n                     visited.insert(v.s);\n                     Q.push(v);\n                  }\n                  break;\n               case 8:\n                  v.s = u.s;\n                  swap(v.s, i, 7);\n                  if(visited.find(v.s) == visited.end()){\n                     visited.insert(v.s);\n                     Q.push(v);\n                  }\n                  break;\n               case 9:\n                  v.s = u.s;\n                  swap(v.s, i, 5);\n                  if(visited.find(v.s) == visited.end()){\n                     visited.insert(v.s);\n                     Q.push(v);\n                  }\n                  v.s = u.s;\n                  swap(v.s, i, 10);\n                  if(visited.find(v.s) == visited.end()){\n                     visited.insert(v.s);\n                     Q.push(v);\n                  }\n\n                  break;\n               case 11:\n                  v.s = u.s;\n                  swap(v.s, i, 7);\n                  if(visited.find(v.s) == visited.end()){\n                     visited.insert(v.s);\n                     Q.push(v);\n                  }\n                  v.s = u.s;\n                  swap(v.s, i, 10);\n                  if(visited.find(v.s) == visited.end()){\n                     visited.insert(v.s);\n                     Q.push(v);\n                  }\n                  break;\n               case 12:\n                  v.s = u.s;\n                  swap(v.s, i, 10);\n                  if(visited.find(v.s) == visited.end()){\n                     visited.insert(v.s);\n                     Q.push(v);\n                  }\n                  break;\n               default:\n                  int ue = 4;\n                  int sita = 4;\n                  if(i == 2) ue = 2;\n                  if(i == 10) sita = 2;\n                  v.s = u.s;\n                  swap(v.s, i, i-ue);\n                  if(visited.find(v.s) == visited.end()){\n                     visited.insert(v.s);\n                     Q.push(v);\n                  }\n                  v.s = u.s;\n                  swap(v.s, i, i+sita);\n                  if(visited.find(v.s) == visited.end()){\n                     visited.insert(v.s);\n                     Q.push(v);\n                  }\n                  v.s = u.s;\n                  swap(v.s, i, i+1);\n                  if(visited.find(v.s) == visited.end()){\n                     visited.insert(v.s);\n                     Q.push(v);\n                  }\n                  v.s = u.s;\n                  swap(v.s, i, i-1);\n                  if(visited.find(v.s) == visited.end()){\n                     visited.insert(v.s);\n                     Q.push(v);\n                  }\n                  break;\n            }\n         }\n      }\n   }\n   return -1;\n}\n\nmain(){\n   pre_bfs();\n   while(cin >> input){\n      if(input == -1) break;\n      string str = \"\";\n      str += ((char)input + 'A');\n      for(int i=1;i<13;i++){\n         cin >> input;\n         str += ((char)input + 'A');\n      }\n      int ans = bfs(str);\n      if(ans == -1) cout << \"NA\" << endl;\n      else{\n         cout << ans << endl;\n      }\n   }\n   return 0;\n\n}"
  },
  {
    "language": "C++",
    "code": "#include <iostream>\n#include <map>\n#include <queue>\n#include <cstdlib>\n#include <vector>\nusing namespace std;\n#define rep(i,n) for(int i=0;i<n;i++)\n\nint to[13][5] = {\n\t{2,-1},\n\t{2,5,-1},\n\t{0,1,3,6,-1},\n\t{2,7,-1},\n\t{5,-1},\n\t{1,4,6,9,-1},\n\t{2,5,7,10,-1},\n\t{3,6,8,11,-1},\n\t{7,-1},\n\t{5,10,-1},\n\t{6,9,11,12},\n\t{7,10,-1},\n\t{10,-1}\n};\nint solve(vector<int> data){\n\tqueue< vector<int> > Q;\n\tmap<vector<int>,int> done;\n\tQ.push(data);\n\tdone[Q.front()] = 0;\n\t\n\twhile(Q.size()){\n\t\tvector<int> q = Q.front(); Q.pop();\n\t\tint dif = 0;\n\t\trep(i,13)if(q[i])dif += abs(i-q[i]);\n\t\tif(dif==0)return done[q];\n\t\tif(dif+done[q]>=20)continue;\n\t\tint curcost = done[q];\n\t\trep(x,13){\n\t\t\tif(q[x] == 0){\n\t\t\t\trep(i,5){\n\t\t\t\t\tif(!~to[x][i])break;\n\t\t\t\t\tswap(q[x],q[to[x][i]]);\n\t\t\t\t\tif(done.find(q) == done.end() ){\n\t\t\t\t\t\tdone[q] = curcost+1;\n\t\t\t\t\t\tQ.push(q);\n\t\t\t\t\t}\n\t\t\t\t\tswap(q[x],q[to[x][i]]);\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t}\n\treturn 21;\n}\nint main(){\n\tvector<int> data(13);\n\twhile(1){\n\t\trep(i,13)if(!(cin >> data[i]))return 0;\n\t\tint ans = solve(data);\n\t\tif(ans > 20)cout << \"NA\" << endl;\n\t\telse cout << ans << endl;\n\t}\n}"
  },
  {
    "language": "C++",
    "code": "#include<iostream>\n#include<algorithm>\n#include<vector>\n#include<queue>\n#include<unordered_map>\n#include<unordered_set>\n#define lol(i,n) for(int i=0;i<n;i++)\n#define mod 1000000007\ntypedef long long ll;\nusing namespace std;\nint dx[13][4]={\n  {3,0,0,0},\n  {3,6,0,0},\n  {1,2,4,7},\n  {3,8,0,0},\n  {6,0,0,0},\n  {2,5,7,10},\n  {3,6,8,11},\n  {4,7,9,12},\n  {8,0,0,0},\n  {6,11,0,0},\n  {7,10,12,13},\n  {8,11,0,0},\n  {11,0,0,0}\n};\nunordered_map<ll,int> mp;\nll Compress(int p[]){\n  ll ans=0;\n  for(int i=0;i<13;i++){\n    ans*=13;\n    ans+=p[i];\n  }\n  return ans;\n}\n\nint unzip[13];\nvoid Unzip(ll x){\n  for(int i=0;i<13;i++){\n    unzip[12-i]=x%13;\n    x/=13;\n  }\n}\n\nint beflen=0;\nqueue<pair<ll,int> >Q;\nvoid BFS(int p[],int len){\n  //if(len!=beflen){cout<<len<<endl;beflen=len;}\n  ll tmp=Compress(p);\n  mp[tmp]=len;\n  if(len==13)return;\n  lol(i,13){\n    if(p[i]==0){\n      lol(j,4){\n\tint t=dx[i][j];\n\tif(t==0)break;\n\tt--;\n\tif(p[t]!=0){\n\t  swap(p[i],p[t]);\n\t  tmp=Compress(p);\n\t  if(mp[tmp]!=0)continue;\n\t  mp[tmp]=-1;\n\t  Q.push(make_pair(tmp,len+1));\n\t  swap(p[i],p[t]);\n\t}\n      }\n    }\n  }\n}\n\nunordered_set<ll> st;\nint ans;\nvoid EFS(int p[],int len){\n  //if(len!=beflen){cout<<len<<endl;beflen=len;}\n  ll tmp=Compress(p);\n  if(mp[tmp]>0){\n    ans=min(ans,len+mp[tmp]-1);\n    return;\n  }\n  if(len==9)return;\n  lol(i,13){\n    if(p[i]==0){\n      lol(j,4){\n\tint t=dx[i][j];\n\tif(t==0)break;\n\tt--;\n\tif(p[t]!=0){\n\t  swap(p[i],p[t]);\n\t  tmp=Compress(p);\n\t  Q.push(make_pair(tmp,len+1));\n\t  swap(p[i],p[t]);\n\t}\n      }\n    }\n  }\n}\nint main(){\n  int p[13];\n  lol(i,13)p[i]=i;p[12]=0;\n  Q.push(make_pair(Compress(p),1));\n  while(!Q.empty()){\n    ll data=Q.front().first;\n    int len=Q.front().second;\n    Q.pop();\n    if(mp[data]>0)continue;\n    Unzip(data);\n    BFS(unzip,len);\n  }\n  //cout<<\"#\"<<mp.size()<<endl;\n  while(cin>>p[0]&&p[0]!=-1){\n    for(int i=1;i<13;i++)cin>>p[i];\n    ans=mod;\n    Q.push(make_pair(Compress(p),0));\n    while(!Q.empty()){\n      ll data=Q.front().first;\n      int len=Q.front().second;\n      Q.pop();\n      if(st.find(data)!=st.end())continue;\n      st.insert(data);\n      Unzip(data);\n      EFS(unzip,len);\n    }\n    st.clear();\n    if(ans>20)cout<<\"NA\"<<endl;\n    else cout<<ans<<endl;\n  }\n  return 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\n\nusing namespace std;\n\ntypedef long long ll;\ntypedef long double ld;\ntypedef tuple<int, int> duo;\nconst int dx[] = {0, 0, 1, -1, 1, 1, -1, -1};\nconst int dy[] = {1, -1, 0, 0, 1, -1, 1, -1};\nconst int Mod = 1000000000 + 0;\n//{{{ templates\n#define TT_             \\\n  template <typename T> \\\n  inline\n#define TTF_                        \\\n  template <typename T, typename F> \\\n  inline\nTT_ T sq(T x) { return x * x; }\nTT_ T In() {\n  T x;\n  cin >> x;\n  return x;\n}\nTT_ void Out(T& x) { cout << x; }\nTT_ void sort(T& v) { sort(begin(v), end(v)); }\nTT_ void revs(T& v) { reverse(begin(v), end(v)); }\nTT_ void uniq(T& v) {\n  sort(v);\n  v.erase(unique(begin(v), end(v)), end(v));\n}\nTT_ int ubnd(T& v, typename T::value_type& x) {\n  return upper_bound(begin(v), end(v), x) - begin(v);\n}\nTT_ int lbnd(T& v, typename T::value_type& x) {\n  return lower_bound(begin(v), end(v), x) - begin(v);\n}\nTTF_ void inpt(T& v, int n, F f) {\n  for (v.reserve(n); n--; v.emplace_back(f()))\n    ;\n}\nTTF_ void show(T& v, F f, string d = \" \", string e = \"\\n\") {\n  int i = 0;\n  for (auto& x : v) i++&&(cout << d), f(x);\n  cout << e;\n}\nTT_ typename T::iterator minel(T& v) { return min_element(begin(v), end(v)); }\nTT_ typename T::iterator maxel(T& v) { return max_element(begin(v), end(v)); }\n\ninline void fast_io() {\n  ios::sync_with_stdio(0);\n  cin.tie(0);\n}\ninline int in() {\n  int x;\n  scanf(\"%d\", &x);\n  return x;\n}\ninline ll pow_mod(ll a, ll k, ll m) {\n  ll r = 1;\n  for (; k > 0; a = a * a % m, k >>= 1)\n    if (k & 1) r = r * a % m;\n  return r;\n}\ninline ll mod_inv(ll a, ll p) { return pow_mod(a, p - 2, p); }\n//}}} priority_queue queue deque front stringstream max_element min_element\n// insert count make_tuple\n\nstruct Board {\n  Board() {\n    memcpy(b, \"0123456789AB0\", sizeof(b));\n    find_zero();\n  }\n  Board(const vector<int>& v) {\n    for (int i = 0; i < 13; i++) b[i] = conv_hex(v[i]);\n    b[13] = 0;\n    find_zero();\n  }\n  void find_zero(){\n    int it = 0;\n    for (int i = 0; i < 13; i++){\n      if (b[i] == '0'){\n        cur[it] = i;\n        it++;\n      }\n    }\n  }\n  char conv_hex(int a) { return \"0123456789ABCDEF\"[a]; }\n  bool slide(int index, int dir) {\n    static const char mov[][4] = {\n      {-1, -1, 2, -1},\n      {-1, 2, 5, -1},\n      {0, 3, 6, 1},\n      {-1, -1, 7, 2},\n      {-1, 5, -1, -1},\n      {1, 6, 9, 4},\n      {2, 7, 10, 5},\n      {3, 8, 11, 6},\n      {-1, -1, -1, 7},\n      {5, 10, -1, -1},\n      {6, 11, 12, 9},\n      {7, -1, -1, 10},\n      {10, -1, -1, -1},\n    };\n    char cu = cur[index];\n    char nu = mov[cu][dir];\n    if (nu == -1) return false;\n    if (b[nu] == '0') return false;\n    swap(b[cu], b[nu]);\n    cur[index] = nu;\n    turn++;\n    return true;\n  }\n  char b[14];\n  char cur[2];\n  char turn;\n};\n\nvoid build_table(unordered_map<ll, char>& ans){\n  Board b;\n  queue<Board> Q;\n  Q.push(b);\n  while (!Q.empty()){\n    Board bi = Q.front();\n    Q.pop();\n    ll hv = strtoll(bi.b, 0, 16);\n    if (ans.count(hv)) continue;\n    ans[hv] = bi.turn;\n    if (bi.turn >= 10) continue;\n    for (int i = 0; i < 2; i++){\n      for (int d = 0; d < 4; d++){\n        auto bii = bi;\n        if (!bii.slide(i, d)) continue;\n        Q.push(bii);\n      }\n    }\n  }\n}\n\nint main() {\n  unordered_map<ll, char> ans;\n  build_table(ans);\n  int h;\n  while (h = in(), h != -1) {\n    vector<int> vs;\n    vs.push_back(h);\n    for (int i = 0; i < 12; i++) vs.push_back(in());\n    Board b(vs);\n    unordered_set<ll> vis;\n    queue<Board> Q;\n    Q.push(b);\n    while (!Q.empty()){\n      Board bi = Q.front();\n      Q.pop();\n      ll hv = strtoll(bi.b, 0, 16);\n      if (vis.count(hv)) continue;\n      vis.insert(hv);\n      if (ans.count(hv)){\n        cout << ans[hv] + bi.turn << endl;\n        goto END;\n      }\n      if (bi.turn >= 10) continue;\n      for (int i = 0; i < 2; i++){\n        for (int d = 0; d < 4; d++){\n          Board bii = bi;\n          if (!bii.slide(i, d)) continue;\n          Q.emplace(move(bii));\n        }\n      }\n    }\n    cout << \"NA\\n\";\nEND:;\n  }\n  return 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include<stdio.h>\n#include<queue>\n#include<algorithm>\n#include<set>\nusing namespace std;\nint p[15];\nstruct wolf{\n\tint m[13];\n};\ninline bool operator <(const wolf &a,const wolf &b){\n\tfor(int i=0;i<13;i++)if(a.m[i]!=b.m[i])return a.m[i]<b.m[i];\n\treturn false;\n}\nint g[13][4]={\n{2,-1,-1,-1},\n{2,5,-1,-1},{0,1,3,6},{2,7,-1,-1},\n{5,-1,-1,-1},{1,4,6,9},{2,5,7,10},{3,6,8,11},{7,-1,-1,-1},\n{5,10,-1,-1},{6,9,11,12},{7,10,-1,-1},\n{10,-1,-1,-1}\n};\nint row[]={0,1,1,1,2,2,2,2,2,3,3,3,4};\nint col[]={2,1,2,3,0,1,2,3,4,1,2,3,2};\nint ABS(int a){return max(a,-a);}\nint main(){\n\twhile(scanf(\"%d\",p),~p[0]){\n\t\tfor(int i=1;i<13;i++)scanf(\"%d\",p+i);\n\t\tset<wolf>S;\n\t\twolf st;\n\t\tfor(int i=0;i<13;i++)st.m[i]=p[i];\n\t\tqueue<pair<wolf,int> > Q;\n\t\tS.insert(st);\n\t\tQ.push(make_pair(st,0));\n\t\tbool yet=true;\n\t\twhile(Q.size()){\n\t\t\twolf at=Q.front().first;\n\t\t\tint cost=Q.front().second;\n\t\t\tQ.pop();\n\t\t\tbool ok=true;\n\t\t\tfor(int i=1;i<12;i++)if(at.m[i]!=i)ok=false;\n\t\t\tif(ok){\n\t\t\t\tyet=false;\n\t\t\t\tprintf(\"%d\\n\",cost);\n\t\t\t\tbreak;\n\t\t\t}\n\t\t\tint now=cost;\n\t\t\tfor(int i=0;i<13;i++)if(at.m[i]){\n\t\t\t\tnow+=ABS(row[i]-row[at.m[i]])+ABS(col[i]-col[at.m[i]]);\n\t\t\t}\n\t\t\tif(now>20)continue;\n\t\t\tfor(int i=0;i<13;i++)if(!at.m[i]){\n\t\t\t\tfor(int j=0;j<4;j++)if(~g[i][j]){\n\t\t\t\t\tswap(at.m[i],at.m[g[i][j]]);\n\t\t\t\t\tif(!S.count(at)){\n\t\t\t\t\t\tS.insert(at);\n\t\t\t\t\t\tQ.push(make_pair(at,cost+1));\n\t\t\t\t\t}\n\t\t\t\t\tswap(at.m[i],at.m[g[i][j]]);\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t\tif(yet)printf(\"NA\\n\");\n\t}\n}"
  },
  {
    "language": "C++",
    "code": "#include<iostream>\n#include<algorithm>\n#include<vector>\n#include<cmath>\nusing namespace std;\n#define MAX_N 20\n#define WIDTH 100\nint OK[5][5] = { {0,0,1,0,0},{0,1,1,1,0},{1,1,1,1,1},{0,1,1,1,0},{0,0,1,0,0} };\nint dx[4] = { 1,0,-1,0 }, dy[4] = { 0,1,0,-1 };\npair<int, vector<vector<int>>> dp[MAX_N + 2][WIDTH], E[WIDTH * 10];\n\nint score(vector<vector<int>>p) {\n\tint sum = 0; pair<int, int>a[12], b[12]; int CNT = 0;\n\tfor (int i = 0; i < 25; i++) {\n\t\tif (p[i / 5][i % 5] >= 1)a[p[i / 5][i % 5]] = make_pair(i / 5, i % 5);\n\t}\n\tfor (int i = 5; i < 20; i++) {\n\t\tif (OK[i / 5][i % 5] == 1) { CNT++; b[CNT] = make_pair(i / 5, i % 5); }\n\t}\n\tfor (int i = 1; i <= 11; i++) { sum += abs(a[i].first - b[i].first) + abs(a[i].second - b[i].second); }\n\treturn sum;\n}\nvector<vector<int>> Move(vector<vector<int>>p, int x, int y,int dir) {\n\tswap(p[x + dx[dir]][y + dy[dir]], p[x][y]); return p;\n}\nint BeemSearch(vector<vector<int>>Z) {\n\tvector<vector<int>>GOAL; int CNT = 0;\n\tfor (int i = 0; i < 5; i++) { vector<int>GOAL2(5, -1); GOAL.push_back(GOAL2); }\n\tfor (int i = 5; i < 20; i++) {\n\t\tif (OK[i / 5][i % 5] == 1) { CNT++; GOAL[i / 5][i % 5] = CNT; }\n\t}\n\tGOAL[0][2] = 0; GOAL[4][2] = 0;\n\tif (Z == GOAL)return 0;\n\tdp[0][0] = make_pair(score(Z), Z);\n\tfor (int i = 0; i < MAX_N; i++) {\n\t\tint CNTS = 0;\n\t\tfor (int j = 0; j < WIDTH; j++) {\n\t\t\tif (dp[i][j].second.size() == 0)continue;\n\t\t\tvector<vector<int>>D = dp[i][j].second;\n\t\t\tfor (int k = 0; k < 25; k++) {\n\t\t\t\tif (D[k / 5][k % 5] != 0)continue;\n\t\t\t\tfor (int l = 0; l < 4; l++) {\n\t\t\t\t\tint cx = (k / 5) + dx[l], cy = (k % 5) + dy[l];\n\t\t\t\t\tif (cx < 0 || cx >= 5 || cy < 0 || cy >= 5)continue;\n\t\t\t\t\tif (D[cx][cy] <= 0)continue;\n\t\t\t\t\tvector<vector<int>>D2 = Move(D, k / 5, k % 5, l);\n\t\t\t\t\tE[CNTS] = make_pair(score(D2), D2); CNTS++;\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t\tsort(E, E + CNTS); dp[i + 1][0] = E[0]; int CNT2 = 1;\n\t\tif (E[0].first == 0)return i + 1;\n\t\tfor (int i = 1; i < CNTS; i++) {\n\t\t\tif (E[i - 1] != E[i]) { dp[i + 1][CNT2] = E[i]; CNT2++; }\n\t\t}\n\t}\n\treturn -1;\n}\nint main() {\n\twhile (true) {\n\t\tfor (int i = 0; i < MAX_N + 2; i++) {\n\t\t\tfor (int j = 0; j < WIDTH; j++) {\n\t\t\t\tvector<vector<int>>ZERO; dp[i][j] = make_pair(0, ZERO);\n\t\t\t}\n\t\t}\n\t\tfor (int i = 0; i < WIDTH * 10; i++) { vector<vector<int>>ZERO; E[i] = make_pair(0, ZERO); }\n\t\tvector<vector<int>>C;\n\t\tfor (int i = 0; i < 5; i++) { vector<int>C2(5, -1); C.push_back(C2); }\n\t\tcin >> C[0][2]; if (C[0][2] == -1)break;\n\t\tfor (int i = 1; i < 4; i++)cin >> C[1][i];\n\t\tfor (int i = 0; i < 5; i++)cin >> C[2][i];\n\t\tfor (int i = 1; i < 4; i++)cin >> C[3][i]; cin >> C[4][2];\n\t\tint ret = BeemSearch(C);\n\t\tif (ret == -1)cout << \"NA\" << endl; else cout << ret << endl;\n\t}\n\treturn 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include<bits/stdc++.h>\n#define rep(i,n)for(int i=0;i<(n);i++)\nusing namespace std;\n\nint cx[]{ 0,1,1,1,2,2,2,2,2,3,3,3,4 }, cy[]{ 2,1,2,3,0,1,2,3,4,1,2,3,2 };\nint dx[]{ 1,-1,0,0 }, dy[]{ 0,0,1,-1 };\nint d[5][5], lim, D, x[2], y[2];\nbool dfs(int p) {\n\tif (D == 0)return true;\n\tif (p + D > lim)return false;\n\trep(j, 2)rep(i, 4) {\n\t\tint nx = x[j] + dx[i], ny = y[j] + dy[i];\n\t\tif (nx < 0 || 5 <= nx || ny < 0 || 5 <= ny || !d[nx][ny])continue;\n\t\tint a = abs(cx[d[nx][ny]] - nx) + abs(cy[d[nx][ny]] - ny);\n\t\tint b = abs(cx[d[nx][ny]] - x[j]) + abs(cy[d[nx][ny]] - y[j]);\n\t\tD += b - a; swap(d[x[j]][y[j]], d[nx][ny]); swap(x[j], nx); swap(y[j], ny);\n\t\tif (dfs(p + 1))return true;\n\t\tD -= b - a; swap(d[x[j]][y[j]], d[nx][ny]); swap(x[j], nx); swap(y[j], ny);\n\t}\n\treturn false;\n}\nint main() {\n\twhile (1) {\n\t\tD = 0; int p = 0;\n\t\trep(i, 13) {\n\t\t\tscanf(\"%d\", &d[cx[i]][cy[i]]);\n\t\t\tif (d[cx[i]][cy[i]] == -1)return 0;\n\t\t\tif (d[cx[i]][cy[i]] == 0) {\n\t\t\t\tx[p] = cx[i]; y[p++] = cy[i];\n\t\t\t}\n\t\t\telse D += abs(cx[i] - cx[d[cx[i]][cy[i]]]) + abs(cy[i] - cy[d[cx[i]][cy[i]]]);\n\t\t}\n\t\tfor (lim = 0; lim <= 20; lim++) {\n\t\t\tif (dfs(0)) {\n\t\t\t\tprintf(\"%d\\n\", lim); break;\n\t\t\t}\n\t\t}\n\t\tif (lim == 21)puts(\"NA\");\n\t}\n}"
  },
  {
    "language": "C++",
    "code": "#include <iostream>\n#include <sstream>\n#include <string>\n#include <algorithm>\n#include <vector>\n#include <stack>\n#include <queue>\n#include <set>\n#include <map>\n#include <cstdio>\n#include <cstdlib>\n#include <cstring>\n#include <cmath>\n\nusing namespace std;\n\n#define FOR(i,k,n) for(int i=(k); i<(int)n; ++i)\n#define REP(i,n) FOR(i,0,n)\n#define FORIT(i,c) for(__typeof((c).begin())i=(c).begin();i!=(c).end();++i)\n\nstruct S{\n  vector<int> p;\n  int t;\n  S(vector<int> p, int t) : p(p),t(t) {}\n};\n\nbool operator<(const S& s, const S& t){\n  return s.t > t.t;\n}\nint x[13] = {2,1,2,3,0,1,2,3,4,1,2,3,2};\nint y[13] = {4,3,3,3,2,2,2,2,2,1,1,1,0};\nint distance(S s){\n  int ret = 0;\n  REP(i,13){\n    if(s.p[i]){\n      ret = max(ret, abs(x[i]-x[s.p[i]]) + abs(y[i]-y[s.p[i]]));\n    }\n  }\n  return ret + s.t;\n}\nvoid print_s(S s){\n  vector<int> v = s.p;\n  printf(\"time:%d\\n\",s.t);\n  printf(\"    %2d    \\n\",v[0]);\n  printf(\"  %2d%2d%2d  \\n\",v[1],v[2],v[3]);\n  printf(\"%2d%2d%2d%2d%2d\\n\",v[4],v[5],v[6],v[7],v[8]);\n  printf(\"  %2d%2d%2d  \\n\",v[9],v[10],v[11]);\n  printf(\"    %2d    \\n\",v[12]);\n}\n\nset<vector<int> > memo;\nvector<int> goal(13);\nint bfs(S start){\n  priority_queue<S> que;\n  que.push(start);\n  while(!que.empty()){\n    S s = que.top(); que.pop();\n    //print_s(s);\n    if(s.t > 20) return -1;\n    if(s.p == goal) return s.t;\n    if(memo.find(s.p)!=memo.end()) continue;\n    memo.insert(s.p);\n    if(distance(s) > 20) continue;\n    REP(i,13){\n      vector<int> tmp = s.p;\n      if(s.p[i]==0){\n        switch(i){\n          case 0:\n          case 2:\n            swap(tmp[0],tmp[2]);\n            que.push(S(tmp,s.t+1));\n            break;\n          case 12:\n          case 10:\n            swap(tmp[12],tmp[10]);\n            que.push(S(tmp,s.t+1));\n            break;\n          case 4:\n          case 5:\n            swap(tmp[4],tmp[5]);\n            que.push(S(tmp,s.t+1));\n            break;\n          case 8:\n          case 7:\n            swap(tmp[8],tmp[7]);\n            que.push(S(tmp,s.t+1));\n            break;\n        }\n        if(i % 4 == 2 || i % 4 == 3){\n          tmp = s.p;\n          swap(tmp[i],tmp[i-1]);\n          que.push(S(tmp,s.t+1));\n        }\n        if(i % 4 == 1 || i % 4 == 2){\n          tmp = s.p;\n          swap(tmp[i],tmp[i+1]);\n          que.push(S(tmp,s.t+1));\n        }\n        if(i % 4 != 0 && i < 8){\n          tmp = s.p;\n          swap(tmp[i],tmp[i+4]);\n          que.push(S(tmp,s.t+1));\n        }\n        if(i % 4 != 0 && i > 4){\n          tmp = s.p;\n          swap(tmp[i],tmp[i-4]);\n          que.push(S(tmp,s.t+1));\n        }\n      }\n    }\n  }\n}\nint main(){\n  int n;\n  vector<int> p(13);\n\n  REP(i,11) goal[i+1] = i+1;\n\n  while(cin>>p[0], p[0]!=-1){\n    for(int i = 1; i < 13; i++){\n      cin>>p[i];\n    }\n    S start(p,0);\n    memo.clear();\n    int ans = bfs(start);\n    if(ans == -1)cout<<\"NA\"<<endl;\n    else cout<< ans << endl;\n  }\n  return 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include<iostream>\n#include<vector>\n#include<set>\n#include<queue>\nusing namespace std;\n\nint main()\n{\n  vector<int> ans;\n  for(int i=0;i<12;i++)\n    ans.push_back(i);\n  ans.push_back(0);\n  int n;\n  for(;cin>>n,n!=-1;)\n    {\n      vector<int> p;\n      p.push_back(n);\n      for(int i=0;i<12;i++)\n\t{\n\t  int tmp;\n\t  cin>>tmp;\n\t  p.push_back(tmp);\n\t}\n      set<vector<int> >hash;\n      queue<pair<vector<int>,int> >qu;\n      qu.push(make_pair(p,0));\n      int anscnt=-1;\n      int dx[]={0,1,1,2,2,3,4,5,5,6,6 ,7,7 ,9 ,10,10};\n      int dy[]={2,2,5,3,6,7,5,6,9,7,10,8,11,10,11,12};\n      set< vector<int> >t1;\n      while(!qu.empty())\n\t{\n\t  vector<int > data=qu.front().first;\n\t  int cnt=qu.front().second;\n\t  qu.pop();\n\t  // cout<<\"qu: \"<<cnt<<endl;\n\t  if(data==ans)\n\t    {\n\t      anscnt=cnt;\n\t      break;\n\t    }\n\t  if(hash.find(data)!=hash.end())\n\t    continue;\n\t  hash.insert(data);\n\t  if(cnt>=10)\n\t    {\n\t      t1.insert(data);\n\t      continue;\n\t    }\n\t  for(int i=0;i<16;i++)\n\t    {\n\t      int x=dx[i];\n\t      int y=dy[i];\n\t      if(data[x]==0 || data[y]==0)\n\t\t{\n\t\t  swap(data[x],data[y]);\n\t\t  if(hash.find(data)==hash.end())\n\t\t    qu.push(make_pair(data,cnt+1));\n\t\t  swap(data[x],data[y]);\n\t\t}\n\t    }\n\t}\n      if(anscnt==-1)\n\t{\n\t  set<vector<int> >hash;\n\t  queue<pair<vector<int>,int> >qu;\n\t  qu.push(make_pair(ans,0));\n\t  while(!qu.empty())\n\t    {\n\t      vector<int > data=qu.front().first;\n\t      int cnt=qu.front().second;\n\t      qu.pop();\n\t      // cout<<\"qu: \"<<cnt<<endl;\n\t      if(t1.find(data)!=t1.end())\n\t\t{\n\t\t  anscnt=10+cnt;\n\t\t  break;\n\t\t}\n\t      if(hash.find(data)!=hash.end())\n\t\tcontinue;\n\t      hash.insert(data);\n\t      if(cnt>=10)\n\t\tcontinue;\n\t      for(int i=0;i<16;i++)\n\t\t{\n\t\t  int x=dx[i];\n\t\t  int y=dy[i];\n\t\t  if(data[x]==0 || data[y]==0)\n\t\t    {\n\t\t      swap(data[x],data[y]);\n\t\t      if(hash.find(data)==hash.end())\n\t\t\tqu.push(make_pair(data,cnt+1));\n\t\t      swap(data[x],data[y]);\n\t\t    }\n\t\t}\n\t    }\n\t}\n\n      if(anscnt==-1)\n\tcout<<\"NA\"<<endl;\n      else\n\tcout<<anscnt<<endl;\n    }\n}"
  },
  {
    "language": "C++",
    "code": "// 18:30~\n\n#include <cstdio>\n#include <iostream>\n#include <string>\n#include <queue>\n#include <map>\n\nusing namespace std;\n\n#define dump(n) cerr<<\"# \"<<#n<<'='<<(n)<<endl\n\nmap<string,int> getstates(string board,int maxturn)\n{\n\tmap<string,int> m;\n\tqueue<pair<string,int>> q;\n\tq.emplace(board,0);\n\twhile(q.size()){\n\t\tstring cb=q.front().first;\n\t\tint cc=q.front().second;\n\t\tq.pop();\n\t\tif(m.count(cb))\n\t\t\tcontinue;\n\t\tm.insert(make_pair(cb,cc));\n\t\t\n\t\tif(cc==maxturn)\n\t\t\tcontinue;\n\t\tfor(int i=0;i<5;i++)\n\t\t\tfor(int j=abs(i-2);j<5-abs(i-2);j++){\n\t\t\t\tif(cb[i*5+j]!='.')\n\t\t\t\t\tcontinue;\n\t\t\t\tfor(int k=0;k<4;k++){\n\t\t\t\t\tint ni=i+\"\\xff\\x1\\0\\0\"[k],nj=j+\"\\0\\0\\xff\\x1\"[k];\n\t\t\t\t\tif(ni<0 || 5<=ni || nj<abs(ni-2) || 5-abs(ni-2)<=nj || cb[ni*5+nj]=='.')\n\t\t\t\t\t\tcontinue;\n\t\t\t\t\tswap(cb[i*5+j],cb[ni*5+nj]);\n\t\t\t\t\tq.emplace(cb,cc+1);\n\t\t\t\t\tswap(cb[i*5+j],cb[ni*5+nj]);\n\t\t\t\t}\n\t\t\t}\n\t}\n\treturn m;\n}\n\nint main()\n{\n\tfor(;;){\n\t\tstring board(25,'#');\n\t\tfor(int i=0;i<5;i++)\n\t\t\tfor(int j=abs(i-2);j<5-abs(i-2);j++){\n\t\t\t\tint x; scanf(\"%d\",&x);\n\t\t\t\tboard[i*5+j]=x?x-1+'a':'.';\n\t\t\t}\n\t\tif(feof(stdin)) break;\n\t\t\n\t\tmap<string,int> m1=getstates(board,10);\n\t\tmap<string,int> m2=getstates(\"##.###abc#defgh#ijk###.##\",10);\n\t\t\n\t\tint res=999;\n\t\tfor(auto kv:m1)\n\t\t\tif(m2.count(kv.first))\n\t\t\t\tres=min(res,kv.second+m2[kv.first]);\n\t\t\n\t\tif(res==999)\n\t\t\tcout<<\"NA\"<<endl;\n\t\telse\n\t\t\tcout<<res<<endl;\n\t}\n\t\n\treturn 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include <iostream>\n#include <algorithm>\n#include <vector>\n#include <queue>\n#include <map>\nusing namespace std;\n#define rep(i,n) for(int i=0;i<n;i++)\nclass NODE{\npublic:\n\tvector<int> data;\n\tint depth;\n\tint e[2];\n\tNODE(int a[13],int d,int E[2]){\n\t\tdata.resize(13);\n\t\trep(i,13)data[i] = a[i];\n\t\tdepth = d;\n\t\trep(i,2)e[i] = E[i];\n\t}\n\tNODE(){\n\t\tdepth = 0;\n\t\tdata.resize(13);\n\t}\n};\n\nint di[13][10] = {\n\t{2,-1},\n\t{2,5,-1},\n\t{0,1,3,6,-1},\n\t{2,7,-1},\n\t{5,-1},\n\t{1,4,6,9,-1},\n\t{2,5,7,10,-1},\n\t{3,6,7,11,-1},\n\t{7},\n\t{5,10,-1},\n\t{6,9,11,12,-1},\n\t{7,10,-1},\n\t{10,-1}\n};\nint rx[] = {3,2,3,4,1,2,3,4,5,2,3,4,3};\nint ry[] = {1,2,2,2,3,3,3,3,3,4,4,4,5};\n\nint main(){\n\twhile(1){\n\t\tint ret = 21;\n\t\tNODE fst; int cnt = 0;\n\t\trep(i,13){\n\t\t\tif(cin >>fst.data[i] , fst.data[i] != -1){\n\t\t\t\tif(fst.data[i] == 0){\n\t\t\t\t\tfst.e[cnt] = i;\n\t\t\t\t\tcnt++;\n\t\t\t\t}\n\t\t\t}else{\n\t\t\t\treturn 0;\n\t\t\t}\n\t\t}\n\t\tmap< vector<int> , int > done[2];\n\t\t\n\t\trep(x,2){\n\t\t\tqueue<NODE> Q;\n\t\t\tif(x==0){\n\t\t\t\tQ.push(fst);\n\t\t\t}else{\n\t\t\t\tNODE a;\n\t\t\t\trep(i,11)a.data[i+1] = i+1;\n\t\t\t\ta.e[0] = 0;\n\t\t\t\ta.e[1] = 12;\n\t\t\t\tQ.push(a);\n\t\t\t}\t\n\t\t\tdone[x][Q.front().data] = 0;\n\t\t\twhile(Q.size()){\n\t\t\t\tNODE q = Q.front(); Q.pop();\n\t\t\t\tint mndist = 0;\n\t\t\t\trep(i,13)mndist += abs(rx[q.data[i]]-rx[i]) + abs(ry[q.data[i]]-ry[i]);\n\t\t\t\t\n\t\t\t\tif(mndist + q.depth > 30)continue;\n\t\t\t\t\n\t\t\t\tif(x == 1){\n\t\t\t\t\tif( done[0].find(q.data) != done[0].end() ){\n\t\t\t\t\t\tret = q.depth + done[0][q.data] ;\n\t\t\t\t\t\tbreak;\n\t\t\t\t\t}\n\t\t\t\t}else{\n\t\t\t\t\tif( q.data[0] == 0 && q.data[1] == 1 && q.data[2] == 2 && q.data[3] == 3 && q.data[4] == 4 && q.data[5] == 5 && q.data[6] == 6 && q.data[7] == 7 &&\n\t\t\t\t\t\t\tq.data[8] == 8 && q.data[9] == 9 && q.data[10]==10 && q.data[11]==11 && q.data[12]==0\n\t\t\t\t\t){\n\t\t\t\t\t\tret = q.depth;\n\t\t\t\t\t\tbreak;\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t\tif(q.depth >= 10)continue;\n\n\t\t\t\trep(o,2){\n\t\t\t\t\tfor(int i=0;di[q.e[o]][i] != -1;i++){\n\t\t\t\t\t\tNODE next = q;\n\t\t\t\t\t\tnext.e[o] = next.data[di[q.e[o]][i]];\n\t\t\t\t\t\tswap(next.data[q.e[o]] , next.data[di[q.e[o]][i]]);\n\t\t\t\t\t\tnext.depth = q.depth + 1;\n\t\t\t\t\t\t\n\t\t\t\t\t\tif( done[x].find(next.data) == done[x].end() ){\n\t\t\t\t\t\t\tdone[x][next.data] = next.depth;\n\t\t\t\t\t\t\tQ.push(next);\n\t\t\t\t\t\t}\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t\tif(ret > 20){\n\t\t\tcout << \"NA\" << endl;\n\t\t}else{\n\t\t\tcout << ret << endl;\n\t\t}\n\t}\n}"
  },
  {
    "language": "C++",
    "code": "#include <iostream>\n#include <cstdio>\n#include <vector>\n#include <map>\n#include <string>\n#include <queue>\n#include <algorithm>\nusing namespace std;\n\ntypedef pair<int,int> P;\nconst int INF = 1e+8;\nconst int f1[25] = {\n\t-1,-1, 0,-1,-1,\n\t-1, 1, 2, 3,-1,\n\t 4, 5, 6, 7, 8,\n\t-1, 9,10,11,-1,\n\t-1,-1,12,-1,-1,\n};\nconst int f2[13] = {2,6,7,8,10,11,12,13,14,16,17,18,22};\nconst int dx[4] = { 0,-1,+1, 0};\nconst int dy[4] = {-1, 0, 0,+1};\n\n// パズル\nstruct Pazzle{\n\tstring v;\n\tPazzle(){v = \"*************\"; }\n\tvoid at(int i, int p){\n\t\tv[i] = p;\n\t}\n\t// 空白の位置を返す. (k は 0 or 1)\n\tint search(int k){\n\t\tint a = 0;\n\t\tfor(int i=0 ; i < 13 ; i++ ){\n\t\t\tif( v[i] == 0 ){\n\t\t\t\tif( k == 0 ){\n\t\t\t\t\treturn i;\n\t\t\t\t}else{\n\t\t\t\t\tif( a == 0 ) a++;\n\t\t\t\t\telse return i;\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t\treturn -1;\n\t}\n\t// 合っている数\n\tint to_g(){\n\t\tint res = 13;\n\t\tfor(int i=0 ; i < 12 ; i++ ){\n\t\t\tif( i != v[i] ) res--;\n\t\t}\n\t\tif( v[12] != 0 ) res--;\n\t\treturn res;\n\t}\n\t// 空白 k (0 or 1) を 方向 dir に動かす.\n\t// 動かせる時は true, 動かせなかったときは false を返す.\n\tbool move(int dir, int k){\n\t\tif( dir < 0 || 4 <= dir || k < 0 || 2 <= k ) return false;\n\t\tint pos1 = search(k);\n\t\tint x = f2[pos1] % 5;\n\t\tint y = f2[pos1] / 5;\n\t\tint mx = x + dx[dir];\n\t\tint my = y + dy[dir];\n\t\tif( mx < 0 || my < 0 || 5 <= mx || 5 <= my ) return false;\n\t\tint pos2 = f1[my*5+mx];\n\t\tif( pos2 == -1 ) return false;\n\t\tif( v[pos1] == v[pos2] ) return false;\n\t\tswap( v[pos1] , v[pos2] );\n\t\treturn true;\n\t}\n\t// 完成しているかどうか\n\tbool is_goal(){\n\t\tfor(int i=0 ; i < 12 ; i++ ){\n\t\t\tif( v[i] != i ) return false;\n\t\t}\n\t\treturn v[12] == 0;\n\t}\n\tvoid debug(){\n\t\tprintf(\"[debug]\\n\");\n\t\tfor(int y=0 ; y < 5 ; y++ ){\n\t\t\tfor(int x=0 ; x < 5 ; x++ ){\n\t\t\t\tif( f1[y*5+x] == -1 ){\n\t\t\t\t\tprintf(\"##\");\n\t\t\t\t}else{\n\t\t\t\t\tprintf(\"%2d\", (int)v[f1[y*5+x]] );\n\t\t\t\t}\n\t\t\t}\n\t\t\tprintf(\"\\n\");\n\t\t}\n\t\tprintf(\"\\n\");\n\t}\n};\n\n// (コスト,スタートからの距離,パズルの状態)\n// コスト は (合っている数,-スタートからの距離)\nstruct State{\n\tPazzle p;\n\tint cnt;\n\tP cost;\n\tState(int cost_, int cnt_, const Pazzle& p_){\n\t\tcost = P(cost_,-cnt_); cnt = cnt_; p = p_;\n\t}\n};\nbool operator<(const State& a, const State& b){\n\treturn a.cost < b.cost;\n}\n\nint solve(Pazzle p){\n\t// (コスト,スタートからの距離,パズルの状態) を優先度つきキューへ\n\tpriority_queue<State> q;\n\tq.push( State(p.to_g(),0,p) );\n\t\n\tint res = 21;\n\tint low = p.to_g() - 5;\n\tif( low < 0 ) low = 0;\n\tint foo=0;\n\twhile( !q.empty() ){\n\t\tPazzle p = q.top().p;\n\t\tint cnt = q.top().cnt;\n\t\tq.pop();\n\t\t\n\t\tif( low < p.is_goal() ) continue;\n\t\tif( res <= cnt + (13-p.is_goal()) ) continue;\n\t\t\n\t\tif( p.is_goal() ){\n\t\t\tres = min( res , cnt );\n\t\t\tcontinue;\n\t\t\t//break;\n\t\t}\n\t\t\n\t\tfor(int k=0 ; k <= 1 ; k++ ){\n\t\t\tfor(int i=0 ; i < 4 ; i++ ){\n\t\t\t\tPazzle p_ = p;\n\t\t\t\tif( p_.move(i,k) ){\n\t\t\t\t\tq.push( State(p_.to_g(),cnt+1,p_) );\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t}\n\treturn res;\n}\n\nint main(){\n\tint p1;\n\twhile( cin >> p1 , p1 != -1 ){\n\t\tPazzle p;\n\t\tp.at(0,p1);\n\t\tfor(int i=1 ; i < 13 ; i++ ){\n\t\t\tcin >> p1;\n\t\t\tp.at(i,p1);\n\t\t}\n\t\tint ans = solve(p);\n\t\tif( ans == 21 ){\n\t\t\tcout << \"NA\" << endl;\n\t\t}else{\n\t\t\tcout << ans << endl;\n\t\t}\n\t}\n}"
  },
  {
    "language": "C++",
    "code": "#include<bits/stdc++.h>\nusing namespace std;\n   \ntypedef long long int64;\nconst int INF = 1 << 30;\n   \nvector< int > edge[13];\n  \nbool back(string str, int cnt){ //枝刈り大事だな\n  int X[]={ 2, 1, 2, 3, 0, 1, 2, 3, 4, 1, 2, 3, 2};\n  int Y[]={ 0, 1, 1, 1, 2, 2, 2, 2, 2, 3, 3, 3, 4};\n \n  int diff = 0;\n  for(int i = 0; i < 13; i++){\n    if(str[i] != '0'){\n      int pos = (str[i] >= 'A' ? str[i] - 'A' + 10 : str[i] - '0');\n      cout << pos << endl;\n      diff += abs( X[pos] - X[i]) + abs( Y[pos] - Y[i]);\n    }\n  }\n  return diff + cnt > 20;\n}\n  \n  \nint bfs(string mas){\n  \n  queue< string > que;\n  map< string , int > memo;\n  que.push( mas );\n  memo[mas] = 0;\n  while(!que.empty()){\n  \n    string p = que.front(); que.pop();\n    if(back( p, memo[p])) continue;\n    if(p == \"0123456789AB0\") return memo[p];\n  \n    for(int i = 0; i < 13; i++){\n      if(p[i] == '0') {\n        for(int j = 0; j < edge[i].size(); j++){\n          string next = p;\n          swap( next[i], next[edge[i][j]]);\n          if(memo.find(next) != memo.end()) continue;\n          que.push( next );\n          memo[next] = memo[p] + 1;\n        }\n      }\n    }\n  }\n  return -1;\n}\n  \nint main(){\n  vector< int > mas(13);\n  \n  edge[0].push_back(2);\n  edge[1].push_back(2); edge[1].push_back(4);\n  edge[2].push_back(0); edge[2].push_back(1); edge[2].push_back(3); edge[2].push_back(6);\n  edge[3].push_back(2); edge[3].push_back(7);\n  edge[4].push_back(5);\n  edge[5].push_back(1); edge[5].push_back(4); edge[5].push_back(6); edge[5].push_back(9);\n  edge[6].push_back(2); edge[6].push_back(5); edge[6].push_back(7); edge[6].push_back(10);\n  edge[7].push_back(3); edge[7].push_back(6); edge[7].push_back(8); edge[7].push_back(11);\n  edge[8].push_back(7);\n  edge[9].push_back(5); edge[9].push_back(10);\n  edge[10].push_back(6); edge[10].push_back(9); edge[10].push_back(11); edge[10].push_back(12);\n  edge[11].push_back(7); edge[11].push_back(10);\n  edge[12].push_back(10);\n  \n  while(cin >> mas[0], mas[0] != -1){\n    for(int i = 1; i < 13; i++){\n      cin >> mas[i];\n    }\n  \n    string start = \"\";\n    for(int i = 0; i < 13; i++){\n      if(mas[i] >= 10) start += (char)(mas[i] - 10 + 'A');\n      else start += mas[i] + '0';\n    }\n    int ret = bfs(start);\n    if(~ret) cout << ret << endl;\n    else cout << \"NA\" << endl;\n  }\n}"
  },
  {
    "language": "C++",
    "code": "#include \"bits/stdc++.h\"\n#include<unordered_map>\n#include<unordered_set>\n#pragma warning(disable:4996)\nusing namespace std;\nusing ld = long double;\ntemplate<class T>\nusing Table = vector<vector<T>>;\nconst ld eps=1e-9;\n\n//// < \"D:\\D_Download\\Visual Studio 2015\\Projects\\programing_contest_c++\\Debug\\a.txt\" > \"D:\\D_Download\\Visual Studio 2015\\Projects\\programing_contest_c++\\Debug\\b.answer\"\n\nvector<vector<int>>ans = vector<vector<int>>{\n\tvector<int>{-1,-1,-1,-1,-1,-1,-1},\n\tvector<int>{-1,-1,-1,0,-1,-1,-1},\n\tvector<int>{-1,-1,1,2,3,-1,-1},\n\tvector<int>{-1,4,5,6,7,8,-1},\n\tvector<int>{-1,-1,9,10,11,-1,-1},\n\tvector<int>{-1,-1,-1,0,-1,-1,-1},\n\tvector<int>{-1,-1,-1,-1,-1,-1,-1},\n};\n\n#include<unordered_map>\nclass HashVI {  // ???????????\\??¢??°???????????§??????\npublic:\n\tsize_t operator()(const vector<int> &x) const {\n\t\tconst int C = 997;      // ?´???°\n\t\tsize_t t = 0;\n\t\tfor (int i = 0; i != x.size(); ++i) {\n\t\t\tt = t * C + x[i];\n\t\t}\n\t\treturn t;\n\t}\n\tsize_t operator()(const vector<vector<int>> &x) const {\n\t\tconst int C = 997;      // ?´???°\n\t\tsize_t t = 0;\n\t\tfor (int i = 0; i != x.size(); ++i) {\n\t\t\tfor (int j = 0; j < x[i].size(); ++j) {\n\t\t\t\tt = t * C + x[i][j];\n\t\t\t}\n\t\t}\n\t\treturn t;\n\t}\n};\nint dx[] = { -1,0,1,0 };\nint dy[] = { 0,1,0,-1 };\nint aaa=21;\nvoid solve(vector<vector<int>>&start,const int turn ) {\n\tif (aaa <= turn)return;\n\tif (start == ans) {\n\t\taaa = min(aaa, turn);\n\t}\n\telse {\n\t\tfor (int i = 1; i < 6; ++i) {\n\t\t\tfor (int j = 1; j < 6; ++j) {\n\t\t\t\tif (start[i][j] == 0) {\n\t\t\t\t\tfor (int way = 0; way < 4; ++way) {\n\t\t\t\t\t\tif (start[i + dy[way]][j + dx[way]]>0) {\n\t\t\t\t\t\t\tswap(start[i][j],start[i + dy[way]][j + dx[way]]);\n\t\t\t\t\t\t\tif (start == ans) {\n\t\t\t\t\t\t\t\taaa = min(aaa, turn);\n\t\t\t\t\t\t\t}\n\t\t\t\t\t\t\telse {\n\n\t\t\t\t\t\t\t\tsolve(start, turn+1);\n\t\t\t\t\t\t\t}\n\t\t\t\t\t\t\tswap(start[i][j], start[i + dy[way]][j + dx[way]]);\n\t\t\t\t\t\t}\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t}\n\t\n}\n\nint main() {\n\twhile (1) {\n\t\tint a; cin >> a;\n\t\taaa = 21;\n\t\tif (a == -1)break;\n\t\tvector<vector<int>>puzzle(7, vector<int>(7,-1));\n\t\tpuzzle[1][3] = a;\n\t\tfor (int i = 2; i <= 5; ++i) {\n\t\t\tfor (int j = 3 - (2-(abs(i - 3))); j <= 3 + (2-abs(i - 3)); ++j) {\n\t\t\t\tcin >> puzzle[i][j];\n\t\t\t}\n\t\t}\n\t\tif (puzzle == ans) {\n\t\t\tcout << 0 << endl;\n\t\t}\n\t\telse {\n\n\t\t\tsolve(puzzle, 1);\n\t\t\tif (aaa == 21)cout << \"NA\" << endl;\n\t\t\telse cout << aaa << endl;\n\t\t}\n\t}\n\treturn 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include <cstdio>\n#include <cstring>\n#include <algorithm>\n\nusing namespace std;\n\nint fie[5][5];\nint o_fie[5][5]={\n\t-1,-1,0,-1,-1,\n\t-1,1,2,3,-1,\n\t4,5,6,7,8,\n\t-1,9,10,11,-1\n\t-1,-1,0,-1,-1,\n};\n\nint ox[12],oy[12],zx[2],zy[2],zcnt;\nint res;\nbool flag;\n\nint dx[4]={1,0,-1,0};\nint dy[4]={0,1,0,-1};\n\nvoid dfs(int v,int dist,int pd,int pu){\n\tif(dist==0){\n\t\tflag=true;\n\t\tres=min(res,v);\n\t\treturn;\n\t}\n\tfor(int i=0;i<4;i++){\n\t\tfor(int j=0;j<2;j++){\n\t\t\t//if(pu==j && (pd+2)%4==i)continue;\n\t\t\tint nx=zx[j]+dx[i],ny=zy[j]+dy[i];\n\t\t\tif(nx>=0 && nx<5 && ny>=0 && ny<5){\n\t\t\t\tif(fie[nx][ny]<=0)continue;\n\t\t\t\tint ch=fie[nx][ny];\n\t\t\t\tint ndist=dist;\n\t\t\t\tndist-=abs(ox[ch]-nx)+abs(oy[ch]-ny);\n\t\t\t\tswap(fie[nx][ny],fie[zx[j]][zy[j]]);\n\t\t\t\tndist+=abs(ox[ch]-zx[j])+abs(oy[ch]-zy[j]);\n\t\t\t\tzx[j]+=dx[i];\n\t\t\t\tzy[j]+=dy[i];\n\t\t\t\tif(v+1+ndist<=res)dfs(v+1,ndist,i,j);\n\t\t\t\tswap(fie[nx][ny],fie[zx[j]][zy[j]]);\n\t\t\t\tzx[j]-=dx[i];\n\t\t\t\tzy[j]-=dy[i];\n\t\t\t}\n\t\t}\n\t}\n}\nint dist;\n\nint main(void){\n\tfor(int i=0;i<5;i++){\n\t\tfor(int j=abs(2-i);j<=4-abs(2-i);j++){\n\t\t\tox[o_fie[i][j]]=j;\n\t\t\toy[o_fie[i][j]]=i;\n\t\t}\n\t}\n\twhile(1){\n\t\tmemset(fie,-1,sizeof(fie));\n\t\tdist=0;\n\t\tzcnt=0;\n\t\tfor(int i=0;i<5;i++){\n\t\t\tfor(int j=abs(2-i);j<=4-abs(2-i);j++){\n\t\t\t\tscanf(\"%d\",&fie[j][i]);\n\t\t\t\tif(fie[j][i]==-1)return 0;\n\t\t\t}\n\t\t}\n\t\tfor(int i=0;i<5;i++){\n\t\t\tfor(int j=abs(2-i);j<=4-abs(2-i);j++){\n\t\t\t\tint v=fie[j][i];\n\t\t\t\tif(v==0){\n\t\t\t\t\tzx[zcnt]=j;\n\t\t\t\t\tzy[zcnt++]=i;\n\t\t\t\t}else dist+=abs(ox[v]-j)+abs(oy[v]-i);\n\t\t\t}\n\t\t}\n\t\tif(dist>20){\n\t\t\tprintf(\"NA\\n\");\n\t\t}else{\n\t\t\tint i=0;\n\t\t\tflag=false;\n\t\t\tres=20;\n\t\t\tdfs(0,dist,-1,-1);\n\t\t\tif(flag){\n\t\t\t\tprintf(\"%d\\n\",res);\n\t\t\t}\n\t\t\tif(!flag)printf(\"NA\\n\");\n\t\t}\n\t}\n\treturn 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include <iostream>\n#include <vector>\nusing namespace std;\n\ntypedef vector <int> VI;\ntypedef vector <VI> VVI;\n\nVVI goal;\nVVI init;\n\nint limit;\n\nconst int di[4] = { 0, 0, 1, -1 };\nconst int dj[4] = { 1, -1, 0, 0 };\n\nconst int T[12][2] = {\n\t{ 0+1, 0+1 },\n\t{ 1+1, 1+1 },\n\t{ 1+1, 2+1 },\n\t{ 1+1, 3+1 },\n\t{ 2+1, 0+1 },\n\t{ 2+1, 1+1 },\n\t{ 2+1, 2+1 },\n\t{ 2+1, 3+1 },\n\t{ 2+1, 4+1 },\n\t{ 3+1, 1+1 },\n\t{ 3+1, 2+1 },\n\t{ 3+1, 3+1 }\n};\n\nint getMD( VVI P )\n{\n\tint sum = 0;\n\tint ti, tj;\n\tfor ( int i = 0; i < 7; i++ )\n\t{\n\t\tfor ( int j = 0; j < 7; j++ )\n\t\t{\n\t\t\tif ( P[j][i] <= 0 )\n\t\t\t\tcontinue;\n\t\t\tti = T[P[j][i]][0];\n\t\t\ttj = T[P[j][i]][1];\n\t\t\tsum += max( ti, i ) - min( ti, i ) + max( tj, j ) - min( tj, j );\n\t\t}\n\t}\n\treturn sum;\n}\n\nbool is_goal( VVI puzzle )\n{\n\tbool ok = true;\n\tfor ( int i = 0; ok && i < 5; i++ ) for ( int j = 0; ok && j < 5; j++ )\n\t{\n\t\tif ( puzzle[j+1][i+1] != goal[j+1][i+1] )\n\t\t\tok = false;\n\t}\n\treturn ok;\n}\n\nbool dfs( int depth, VVI now )\n{\n\tif ( is_goal( now ) )\n\t\treturn true;\n\n\tif ( depth + getMD( now ) > limit )\n\t\treturn false;\n\n\tfor ( int i = 0; i < 7; i++ )\n\t{\n\t\tfor ( int j = 0; j < 7; j++ )\n\t\t{\n\t\t\tif ( now[j][i] != 0 )\n\t\t\t\tcontinue;\n\n\t\t\tfor ( int k = 0; k < 4; k++ )\n\t\t\t{\n\t\t\t\tVVI v = now;\n\t\t\t\tint ni = i + di[k];\n\t\t\t\tint nj = j + dj[k];\n\n\t\t\t\tif ( v[nj][ni] <= 0 )\n\t\t\t\t\tcontinue;\n\n\t\t\t\tswap( v[j][i], v[nj][ni] );\n\n\t\t\t\tif ( dfs( depth+1, v ) )\n\t\t\t\t\treturn true;\n\n\t\t\t}\n\t\t}\n\t}\n\n}\n\nint idfs( VVI src )\n{\n\tfor ( limit = 0; limit <= 20; limit++ )\n\t{\n\t\tif ( dfs( 0, src ) )\n\t\t\treturn limit;\n\t}\n\treturn -1;\n}\n\nint main( void )\n{\n\t// S[ÌóÔðìé\n\tgoal = VVI( 7, VI( 7, -1 ) );\n\tgoal[3][1] = 0;\n\tgoal[3][5] = 0;\n\tfor ( int i = 0; i < 3; i++ )\n\t{\n\t\tgoal[2+i][2] = 1+i;\n\t\tgoal[2+i][4] = 9+i;\n\t}\n\tfor ( int i = 0; i < 5; i++ )\n\t{\n\t\tgoal[1+i][3] = 4+i;\n\t}\n\n\t/*\n\tfor ( int i = 0; i < 5; i++ )\n\t{\n\t\tfor ( int j = 0; j < 5; j++ )\n\t\t{\n\t\t\tif ( goal[j+1][i+1] == -1 )\n\t\t\t\tcout << \"  \";\n\t\t\telse\n\t\t\t\tcout << goal[j+1][i+1] << \" \";\n\t\t}\n\t\tcout << endl;\n\t}\n\t*/\n\n\twhile ( 1 )\n\t{\n\t\t// úóÔÌüÍ\n\t\tinit = VVI( 7, VI( 7, -1 ) );\n\t\tcin >> init[3][1];\n\t\tif ( init[3][1] == -1 )\n\t\t\tbreak;\n\t\tfor ( int i = 0; i < 3; i++ )\n\t\t\tcin >> init[2+i][2];\n\t\tfor ( int i = 0; i < 5; i++ )\n\t\t\tcin >> init[1+i][3];\n\t\tfor ( int i = 0; i < 3; i++ )\n\t\t\tcin >> init[2+i][4];\n\t\tcin >> init[3][5];\n\n\t\tint cost = idfs( init );\n\n\t\tif ( cost == -1 )\n\t\t\tcout << \"NA\" << endl;\n\t\telse\n\t\t\tcout << cost << endl;\n\n\t}\n\n\treturn 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\n\n#ifndef INCLUDE_ZOBRIST_HASH_HPP\n#define INCLUDE_ZOBRIST_HASH_HPP\n\n#include <random>\n#include <iostream>\n#include <typeinfo>\n\nnamespace orislib {\n\ntemplate <typename T, int W, int H, int STATE>\nstruct ZobristHash {\n  typedef T hash_t;\n  ZobristHash() {\n    std::random_device rd;\n    std::mt19937 mt(rd());\n    std::uniform_int_distribution<T> dist;\n    for (int h = 0; h < H; h++) {\n      for (int w = 0; w < W; w++) {\n        for (int s = 0; s < STATE; s++) {\n          rands[h][w][s] = dist(mt);\n        }\n      }\n    }\n  }\n  template <typename TT>\n  hash_t hash(TT data[H][W]) {\n    hash_t r = 0;\n    for (int h = 0; h < H; h++) {\n      for (int w = 0; w < W; w++) {\n        r ^= rands[h][w][data[h][w]];\n      }\n    }\n    return r;\n  }\n  hash_t rands[H][W][STATE];\n};\n}\n\n#endif\nusing namespace std;\nusing namespace orislib;\n\ntypedef long long ll;\ntypedef long double ld;\ntypedef tuple<int, int> duo;\nconst int dx[] = {0, 0, 1, -1, 1, 1, -1, -1};\nconst int dy[] = {1, -1, 0, 0, 1, -1, 1, -1};\nconst int Mod = 1000000000 + 0;\n//{{{ templates\n#define TT_             \\\n  template <typename T> \\\n  inline\n#define TTF_                        \\\n  template <typename T, typename F> \\\n  inline\nTT_ T sq(T x) { return x * x; }\nTT_ T In() {\n  T x;\n  cin >> x;\n  return x;\n}\nTT_ void Out(T& x) { cout << x; }\nTT_ void sort(T& v) { sort(begin(v), end(v)); }\nTT_ void revs(T& v) { reverse(begin(v), end(v)); }\nTT_ void uniq(T& v) {\n  sort(v);\n  v.erase(unique(begin(v), end(v)), end(v));\n}\nTT_ int ubnd(T& v, typename T::value_type& x) {\n  return upper_bound(begin(v), end(v), x) - begin(v);\n}\nTT_ int lbnd(T& v, typename T::value_type& x) {\n  return lower_bound(begin(v), end(v), x) - begin(v);\n}\nTTF_ void inpt(T& v, int n, F f) {\n  for (v.reserve(n); n--; v.emplace_back(f()))\n    ;\n}\nTTF_ void show(T& v, F f, string d = \" \", string e = \"\\n\") {\n  int i = 0;\n  for (auto& x : v) i++&&(cout << d), f(x);\n  cout << e;\n}\nTT_ typename T::iterator minel(T& v) { return min_element(begin(v), end(v)); }\nTT_ typename T::iterator maxel(T& v) { return max_element(begin(v), end(v)); }\n\ninline void fast_io() {\n  ios::sync_with_stdio(0);\n  cin.tie(0);\n}\ninline int in() {\n  int x;\n  scanf(\"%d\", &x);\n  return x;\n}\ninline ll pow_mod(ll a, ll k, ll m) {\n  ll r = 1;\n  for (; k > 0; a = a * a % m, k >>= 1)\n    if (k & 1) r = r * a % m;\n  return r;\n}\ninline ll mod_inv(ll a, ll p) { return pow_mod(a, p - 2, p); }\n//}}} priority_queue queue deque front stringstream max_element min_element\n// insert count make_tuple\n\nstruct Board {\n  Board() {}\n  Board(const vector<vector<int>>& v) {\n    memset(b, '#', sizeof(b));\n    for (int i = 0; i < 5; i++) b[i][5] = 0;\n    for (int i = 0; i < v[0].size(); i++) b[0][2 + i] = conv_hex(v[0][i]);\n    for (int i = 0; i < v[1].size(); i++) b[1][1 + i] = conv_hex(v[1][i]);\n    for (int i = 0; i < v[2].size(); i++) b[2][0 + i] = conv_hex(v[2][i]);\n    for (int i = 0; i < v[3].size(); i++) b[3][1 + i] = conv_hex(v[3][i]);\n    for (int i = 0; i < v[4].size(); i++) b[4][2 + i] = conv_hex(v[4][i]);\n    int it = 0;\n    for (int i = 0; i < 5; i++) {\n      for (int j = 0; j < 5; j++) {\n        if (b[i][j] == '0') {\n          cx[it] = j;\n          cy[it] = i;\n          it++;\n        }\n      }\n    }\n    turn = 0;\n  }\n  char conv_hex(int a) { return \"0123456789ABCDEF\"[a]; }\n  bool slide(int index, int dir) {\n    int px = cx[index], py = cy[index];\n    int nx = px + dx[dir], ny = py + dy[dir];\n    if (invalid(nx, ny)) return false;\n    if (b[ny][nx] == '#') return false;\n    if (b[ny][nx] == '0') return false;\n    swap(b[py][px], b[ny][nx]);\n    cx[index] = nx;\n    cy[index] = ny;\n    turn++;\n    return true;\n  }\n  bool invalid(int x, int y) { return x < 0 || x >= 5 || y < 0 || y >= 5; }\n  char b[5][6];\n  int cx[2], cy[2];\n  int turn;\n};\n\nint main() {\n  ZobristHash<int, 6, 5, 256> zh;\n  static const char cb[5][6] = {\"##0##\", \"#123#\", \"45678\", \"#9AB#\", \"##0##\", };\n  unordered_map<int, int> ans;\n  Board b;\n  memcpy(b.b, cb, sizeof(cb));\n  b.turn = 0;\n  b.cx[0] = 2;\n  b.cy[0] = 0;\n  b.cx[1] = 2;\n  b.cy[1] = 4;\n  queue<Board> Q;\n  Q.push(b);\n  while (!Q.empty()){\n    Board bi = Q.front();\n    Q.pop();\n    if (bi.turn >= 22) break;\n    int hv = zh.hash(bi.b);\n    if (ans.count(hv)) continue;\n    ans[hv] = bi.turn;\n    for (int i = 0; i < 2; i++){\n      for (int d = 0; d < 4; d++){\n        Board bii = bi;\n        if (!bii.slide(i, d)) continue;\n        Q.push(bii);\n      }\n    }\n  }\n  int h;\n  while (h = in(), h != -1) {\n    vector<vector<int>> vs(5);\n    vs[0].emplace_back(h);\n    inpt(vs[1], 3, in);\n    inpt(vs[2], 5, in);\n    inpt(vs[3], 3, in);\n    inpt(vs[4], 1, in);\n    Board b(vs);\n    int hv = zh.hash(b.b);\n    if (ans.count(hv)) cout << ans[hv] << endl;\n    else cout << \"NA\\n\";\n  }\n  return 0;\n}"
  },
  {
    "language": "C++",
    "code": "#define _USE_MATH_DEFINES\n#define INF 10000000\n#include <iostream>\n#include <sstream>\n#include <cmath>\n#include <algorithm>\n#include <queue>\n#include <stack>\n#include <limits>\n#include <map>\n#include <string>\n#include <cstring>\n#include <set>\n#include <deque>\n#include <bitset>\n\nusing namespace std;\n\ntypedef long long ll;\ntypedef pair<int,string> P;\n\nstatic const double eps = 1e-8;\n\nstatic const int t[][2] = {{1,0},{0,1},{-1,0},{0,-1}};\nstatic const int s[][2] = {{0,2},{1,1},{1,2},{1,3},\n{2,0},{2,1},{2,2},{2,3},{2,4},{3,1},{3,2},{3,3},{4,2}};\n\nvoid bfs(map<vector< vector<int>>,int>& cost,vector< vector<int>>& rv){\n\tcost[rv] = 0;\n\tqueue<vector< vector<int>> > que;\n\tque.push(rv);\n\n\twhile(!que.empty()){\n\t\tvector< vector<int>> now = que.front();\n\t\tque.pop();\n\n\t\tfor(int i=0;i<13;i++){\n\t\t\tint x = s[i][1];\n\t\t\tint y = s[i][0];\n\t\t\tif(now[y][x] != 0) continue;\n\n\t\t\tfor(int j=0;j<4;j++){\n\t\t\t\tint dx = x + t[j][0];\n\t\t\t\tint dy = y + t[j][1];\n\n\t\t\t\tif(dy < 0 || dy >= 5 || dx < 0 || dx >= 5) continue;\n\t\t\t\tif(now[dy][dx] == -1) continue;\n\t\t\t\tif(now[dy][dx] == 0) continue;\n\n\t\t\t\tvector< vector<int>> tmp = now;\n\t\t\t\tswap(tmp[y][x],tmp[dy][dx]);\n\n\t\t\t\tif(cost.find(tmp) != cost.end()) continue;\n\t\t\t\tcost[tmp] = cost[now] + 1;\n\t\t\t\tif(cost[tmp] > 20) continue;\n\t\t\t\tque.push(tmp);\n\t\t\t}\n\t\t}\n\t}\n}\n\nint main(){\n\tint table[5][5];\n\tint root[5][5];\n\tmemset(table,-1,sizeof(table));\n\tmemset(root,-1,sizeof(root));\n\troot[0][2] = 0;\n\troot[1][1]=1; root[1][2]=2; root[1][3]=3;\n\troot[2][0]=4; root[2][1]=5; root[2][2]=6; root[2][3]=7; root[2][4]=8;\n\troot[3][1]=9; root[3][2]=10; root[3][3]=11;\n\troot[4][2] = 0;\n\n\tvector< vector<int>> rv(5,vector<int>(5));\n\tmap<vector< vector<int>>,int> cost;\n\n\tfor(int y=0;y<5;y++){\n\t\tfor(int x=0;x<5;x++){\n\t\t\trv[y][x] = root[y][x];\n\t\t}\n\t}\n\tbfs(cost,rv);\n\n\twhile(~scanf(\"%d\",&table[0][2])){\n\t\tif(table[0][2] == -1) break;\n\t\tscanf(\"%d %d %d\",&table[1][1],&table[1][2],&table[1][3]);\n\t\tscanf(\"%d %d %d %d %d\",&table[2][0],&table[2][1],&table[2][2],&table[2][3],&table[2][4]);\n\t\tscanf(\"%d %d %d\",&table[3][1],&table[3][2],&table[3][3]);\n\t\tscanf(\"%d\",&table[4][2]);\n\t\tvector< vector<int>> tv(5,vector<int>(5));\n\n\t\tfor(int y=0;y<5;y++){\n\t\t\tfor(int x=0;x<5;x++){\n\t\t\t\ttv[y][x] = table[y][x];\n\t\t\t}\n\t\t}\n\n\t\tif(cost.find(tv) != cost.end()) printf(\"%d\\n\",cost[tv]);\n\t\telse printf(\"NA\\n\");\n\t}\n}"
  },
  {
    "language": "C++",
    "code": "#include<cstdio>\n#include<algorithm>\n#include<iostream>\n#include<queue>\n#include<functional>\n#include<map>\n#include<vector>\nusing namespace std;\nclass P{\n\tpublic:\n\tint state[15];\n\tint cnt;\n\tP(){}\n\tP(int a[15],int cnt):cnt(cnt){\n\t\tfor(int i = 0; i < 15; i++){\n\t\t\tstate[i] = a[i];\n\t\t}\n\t}\n};\nint rules[13][6]={\n\t{1,2},{2,2,5},{4,0,1,2,3,6},{2,2,7},{1,5},\n\t{4,1,4,6,9},{4,2,5,7,10},{4,3,6,8,11},{1,7},{3,5,10},\n\t{4,6,9,11,12},{2,7,10},{1,10},\n};\nmap< string , int >memo;\n\nstring getIndex(int *a){\n\tstring tmp=\"\";\n\tfor(int i = 0; i < 12; i++){\n\t\ttmp += a[i];\n\t}\n\treturn tmp;\n}\n\nvoid bfs(){\n\tint F[] = {0,1,2,3,4,5,6,7,8,9,10,11,0};\n\tqueue < P > Q;\n\tQ.push(P(F,0));\n\twhile( true ){\n\t\tif(Q.size() == 0)break;\n\t\tP p = Q.front();Q.pop();\n\t\tif(p.cnt > 20)break;\n\t\tstring index = getIndex(p.state);\n\t\tif(memo[index])continue;\n\t\tmemo[index] = p.cnt;\n\t\tfor(int i = 0; i < 13; i++){\n\t\t\tif(p.state[i] == 0){\n\t\t\t\tint zero = p.state[i];\n\t\t\t\tfor(int j = 0; j < rules[zero][0]; j++){\n\t\t\t\t\tswap(p.state[i],p.state[rules[i][j+1]]);\n\t\t\t\t\tQ.push(P(p.state,p.cnt+1));\n\t\t\t\t\tswap(p.state[i],p.state[rules[i][j+1]]);\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t}\n}\nint main(){\n\tbfs();\n\tint input[15];\n\twhile(true){\n\t    scanf(\"%d\",&input[0]);\n\t    if(input[0] == -1)break;\n\t\tfor(int i = 1; i < 13; i++){\n\t\t\tscanf(\"%d\",&input[i]);\n\t\t}\n\t\tstring index = getIndex(input);\n\t\tif(memo[index])printf(\"%d\\n\",memo[index]);\n\t\telse puts(\"NA\");\n\t}\n\treturn 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include <iostream>\n#include <cstdio>\n#include <vector>\n#include <map>\n#include <string>\n#include <queue>\n#include <algorithm>\nusing namespace std;\n\ntypedef pair<int,int> P;\nconst int INF = 1e+8;\nconst int f1[25] = {\n\t-1,-1, 0,-1,-1,\n\t-1, 1, 2, 3,-1,\n\t 4, 5, 6, 7, 8,\n\t-1, 9,10,11,-1,\n\t-1,-1,12,-1,-1,\n};\nconst int f2[13] = {2,6,7,8,10,11,12,13,14,16,17,18,22};\nconst int dx[4] = { 0,-1,+1, 0};\nconst int dy[4] = {-1, 0, 0,+1};\n\n// パズル\nstruct Pazzle{\n\tstring v;\n\tPazzle(){v = \"*************\"; }\n\tvoid at(int i, int p){\n\t\tv[i] = p;\n\t}\n\t// 空白の位置を返す. (k は 0 or 1)\n\tint search(int k){\n\t\tint a = 0;\n\t\tfor(int i=0 ; i < 13 ; i++ ){\n\t\t\tif( v[i] == 0 ){\n\t\t\t\tif( k == 0 ){\n\t\t\t\t\treturn i;\n\t\t\t\t}else{\n\t\t\t\t\tif( a == 0 ) a++;\n\t\t\t\t\telse return i;\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t\treturn -1;\n\t}\n\t// 合っている数\n\tint to_g(){\n\t\tint res = 13;\n\t\tfor(int i=0 ; i < 12 ; i++ ){\n\t\t\tif( i != v[i] ) res--;\n\t\t}\n\t\tif( v[12] != 0 ) res--;\n\t\treturn res;\n\t}\n\t// 空白 k (0 or 1) を 方向 dir に動かす.\n\t// 動かせる時は true, 動かせなかったときは false を返す.\n\tbool move(int dir, int k){\n\t\tif( dir < 0 || 4 <= dir || k < 0 || 2 <= k ) return false;\n\t\tint pos1 = search(k);\n\t\tint x = f2[pos1] % 5;\n\t\tint y = f2[pos1] / 5;\n\t\tint mx = x + dx[dir];\n\t\tint my = y + dy[dir];\n\t\tif( mx < 0 || my < 0 || 5 <= mx || 5 <= my ) return false;\n\t\tint pos2 = f1[my*5+mx];\n\t\tif( pos2 == -1 ) return false;\n\t\tif( v[pos1] == v[pos2] ) return false;\n\t\tswap( v[pos1] , v[pos2] );\n\t\treturn true;\n\t}\n\t// 完成しているかどうか\n\tbool is_goal(){\n\t\tfor(int i=0 ; i < 12 ; i++ ){\n\t\t\tif( v[i] != i ) return false;\n\t\t}\n\t\treturn v[12] == 0;\n\t}\n\tvoid debug(){\n\t\tprintf(\"[debug]\\n\");\n\t\tfor(int y=0 ; y < 5 ; y++ ){\n\t\t\tfor(int x=0 ; x < 5 ; x++ ){\n\t\t\t\tif( f1[y*5+x] == -1 ){\n\t\t\t\t\tprintf(\"##\");\n\t\t\t\t}else{\n\t\t\t\t\tprintf(\"%2d\", (int)v[f1[y*5+x]] );\n\t\t\t\t}\n\t\t\t}\n\t\t\tprintf(\"\\n\");\n\t\t}\n\t\tprintf(\"\\n\");\n\t}\n};\n\n// (コスト,スタートからの距離,パズルの状態)\n// コスト は (合っている数,-スタートからの距離)\nstruct State{\n\tPazzle p;\n\tint cnt;\n\tP cost;\n\tState(int cost_, int cnt_, const Pazzle& p_){\n\t\tcost = P(cost_,-cnt_); cnt = cnt_; p = p_;\n\t}\n};\nbool operator<(const State& a, const State& b){\n\treturn a.cost < b.cost;\n}\n\nint solve(Pazzle p){\n\t// (コスト,スタートからの距離,パズルの状態) を優先度つきキューへ\n\tpriority_queue<State> q;\n\tq.push( State(p.to_g(),0,p) );\n\t\n\tint res = 21;\n\tint low = p.to_g() - 3;\n\tif( low < 0 ) low = 0;\n\tint foo=0;\n\twhile( !q.empty() ){\n\t\tPazzle p = q.top().p;\n\t\tint cnt = q.top().cnt;\n\t\tq.pop();\n\t\t\n\t\tif( p.is_goal() ){\n\t\t\tres = min( res , cnt );\n\t\t\tcontinue;\n\t\t\t//break;\n\t\t}\n\t\tfoo++;\n\t\tif( 10000 < foo ) break;\n\t\tif( low < p.is_goal() ) continue;\n\t\tif( res <= cnt + (13-p.is_goal()) ) continue;\n\t\t\n\t\tfor(int k=0 ; k <= 1 ; k++ ){\n\t\t\tfor(int i=0 ; i < 4 ; i++ ){\n\t\t\t\tPazzle p_ = p;\n\t\t\t\tif( p_.move(i,k) ){\n\t\t\t\t\tq.push( State(p_.to_g(),cnt+1,p_) );\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t}\n\treturn res;\n}\n\nint main(){\n\tint p1;\n\twhile( cin >> p1 , p1 != -1 ){\n\t\tPazzle p;\n\t\tp.at(0,p1);\n\t\tfor(int i=1 ; i < 13 ; i++ ){\n\t\t\tcin >> p1;\n\t\t\tp.at(i,p1);\n\t\t}\n\t\tint ans = solve(p);\n\t\tif( ans == 21 ){\n\t\t\tcout << \"NA\" << endl;\n\t\t}else{\n\t\t\tcout << ans << endl;\n\t\t}\n\t}\n}"
  },
  {
    "language": "C++",
    "code": "#include <algorithm>\n#include <cctype>\n#include <climits>\n#include <cmath>\n#include <cstdio>\n#include <cstdlib>\n#include <cstring>\n#include <functional>\n#include <map>\n#include <numeric>\n#include <queue>\n#include <set>\n#include <sstream>\n#include <string>\n#include <vector>\n\nusing namespace std;\n\n#define reps(i,f,n) for(int i=f; i<int(n); ++i)\n#define rep(i,n) reps(i,0,n)\n\ntypedef long long ll;\ntypedef vector<int> vi;\ntypedef vector<vi> vvi;\ntypedef pair<int, int> pii;\n\nconst int INF = 1001001001;\nconst ll FINAL = 0x0ba9876543210ll;\n\nstruct Data\n{\n\tll s;\n\tint d;\n\tbool f;\n\tData(ll s, int d, bool f) : s(s), d(d), f(f) {}\n};\n\nint bfs(ll init)\n{\n\tif(init == FINAL)\n\t\treturn 0;\n\t\n\tconst int move[13][5] = {\n\t\t{2, -1},\n\t\t{2, 5, -1},\n\t\t{0, 1, 3, 6, -1},\n\t\t{2, 7, -1},\n\t\t{5, -1},\n\t\t{1, 4, 6, 9, -1},\n\t\t{2, 5, 7, 10, -1},\n\t\t{3, 6, 8, 11, -1},\n\t\t{7, -1},\n\t\t{5, 10, -1},\n\t\t{6, 9, 11, 12, -1},\n\t\t{7, 10, -1},\n\t\t{10, -1}\n\t};\n\t\n\tset<ll> visited[2];\n\tqueue<Data> Q;\n\tQ.push(Data(init, 0, false));\n\tQ.push(Data(FINAL, 0, true));\n\tvisited[0].insert(init);\n\tvisited[1].insert(FINAL);\n\tint now[2] = {0};\n\t\n\twhile(!Q.empty()){\n\t\tData data = Q.front();\n\t\tQ.pop();\n\t\tnow[data.f] = data.d + 1;\n\n\t\tfor(int i=0, cnt=2; cnt; ++i){\n\t\t\tif(((data.s>>(i*4)) & 0xfll) == 0){\n\t\t\t\tfor(int j=0; move[i][j]!=-1; ++j){\n\t\t\t\t\tll next = data.s;\n\t\t\t\t\tnext &= ~((0xfll << (i*4)) | (0xfll << (move[i][j]*4)));\n\t\t\t\t\tnext |= ((data.s >> (move[i][j]*4)) & 0xfll) << (i*4);\n\t\t\t\t\t\n\t\t\t\t\tif(visited[!data.f].find(next) != visited[!data.f].end())\n\t\t\t\t\t\treturn now[0] + now[1];\n\n\t\t\t\t\tif(visited[data.f].find(next) == visited[data.f].end()){\n\t\t\t\t\t\tvisited[data.f].insert(next);\n\t\t\t\t\t\tif(data.d <= 8)\n\t\t\t\t\t\t\tQ.push(Data(next, data.d+1, data.f));\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t\t--cnt;\n\t\t\t}\n\t\t}\n\t}\n\treturn -1;\n}\n\nint main()\n{\n\tfor(;;){\n\t\tint input[13];\n\t\trep(i, 13){\n\t\t\tscanf(\"%d\", &input[i]);\n\t\t\tif(input[i] == -1)\n\t\t\t\treturn 0;\n\t\t}\n\n\t\tll init = 0;\n\t\trep(i, 13)\n\t\t\tinit = (init << 4) | input[12-i];\n\n\t\tint ans = bfs(init);\n\t\tif(ans == -1)\n\t\t\tputs(\"NA\");\n\t\telse\n\t\t\tprintf(\"%d\\n\", ans);\n\t}\n}"
  },
  {
    "language": "C++",
    "code": "#include<bits/stdc++.h>\n#define int long long\n#define r(i,n) for(int i=0;i<n;i++)\nusing namespace std;\ntypedef pair<int,int>P;\nvector<int>v[13],s(13),t(13);\nmap<int,int>m;\n\nint has[14];\n\n\nvoid init(){\n\n    v[0].push_back(2);\n\n    v[1].push_back(2);\n    v[1].push_back(5);\n\n    v[2].push_back(0);\n    v[2].push_back(1);\n    v[2].push_back(3);\n    v[2].push_back(6);\n\n    v[3].push_back(2);\n    v[3].push_back(7);\n\n    v[4].push_back(5);\n\n    v[5].push_back(1);\n    v[5].push_back(4);\n    v[5].push_back(6);\n    v[5].push_back(9);\n\n    v[6].push_back(2);\n    v[6].push_back(5);\n    v[6].push_back(7);\n    v[6].push_back(10);\n\n    v[7].push_back(3);\n    v[7].push_back(6);\n    v[7].push_back(8);\n    v[7].push_back(11);\n\n    v[8].push_back(7);\n\n    v[9].push_back(5);\n    v[9].push_back(10);\n\n    v[10].push_back(6);\n    v[10].push_back(9);\n    v[10].push_back(11);\n    v[10].push_back(12);\n\n    v[11].push_back(7);\n    v[11].push_back(10);\n\n    v[12].push_back(10);\n\n    int a=20;\n    int p=1;\n\n    r(i,13){\n        has[i]=p;\n        p*=a;\n    }\n}\n\nint ha(vector<int> &x){\n\n    int re=0;\n\n    r(i,13){\n        re+=x[i]*has[i];\n    }\n\n    return re;\n}\n\nvector<int> ah(int x){\n    vector<int>y(13);\n    r(i,13){\n        y[i]=x%20;\n        x/=20;\n    }\n    return y;\n}\n\nvoid BFS1(){\n    s[0]=0;\n    s[12]=0;\n    r(i,11)s[i+1]=i+1;\n    set<int>st;\n    st.insert(ha(s));\n    m[ha(s)]=0;\n    queue<P>q;\n    q.push(P(ha(s),0));\n    while(1){\n        vector<int> now=ah(q.front().first);\n        int cost=q.front().second;\n        q.pop();\n        if(cost==7)break;\n        //cout<<m.size()<<' '<<cost<<endl;\n        r(i,13)if(now[i]!=0){\n            r(j,v[i].size()){\n                swap(now[i],now[v[i][j]]);\n                int yy=ha(now);\n                if(!st.count(yy)){\n                    st.insert(yy);\n                    m[yy]=cost+1;\n                    q.push(P(yy,cost+1));\n                }\n                swap(now[i],now[v[i][j]]);\n            }\n        }\n    }\n}\n\nvoid BFS2(){\n    set<int>st;\n    st.insert(ha(t));\n    queue<P>q;\n    q.push(P(ha(t),0));\n    while(1){\n        vector<int>now=ah(q.front().first);\n        int cost=q.front().second;\n        int y=ha(now);\n        if(m.count(y)){\n            cout<<m[y]+cost<<endl;\n            return ;\n        }\n        q.pop();\n        if(cost==5)break;\n        r(i,13)if(now[i]!=0){\n            r(j,v[i].size()){\n                swap(now[i],now[v[i][j]]);\n                int yy=ha(now);\n                if(!st.count(yy)){\n                    st.insert(yy);\n                    q.push(P(yy,cost+1));\n                }\n                swap(now[i],now[v[i][j]]);\n            }\n        }\n    }\n    cout<<\"NA\"<<endl;\n}\n\n\nsigned main(){\n    init();\n    BFS1();\n    while(cin>>t[0],t[0]!=-1){\n        r(i,12)cin>>t[i+1];\n        BFS2();\n    }\n}\n"
  },
  {
    "language": "C++",
    "code": "#include <cstdio>\n#include <cstdlib>\n#include <cmath>\n#include <climits>\n#include <cfloat>\n#include <map>\n#include <utility>\n#include <set>\n#include <iostream>\n#include <memory>\n#include <string>\n#include <vector>\n#include <algorithm>\n#include <functional>\n#include <sstream>\n#include <complex>\n#include <stack>\n#include <queue>\n#include <cstring>\n#include <sstream>\n#include <cassert>\n#include <list>\nusing namespace std;\nstatic const double EPS = 1e-10;\ntypedef long long ll;\ntypedef pair<int,int> PI;\ntypedef vector<int> vi;\n#ifndef M_PI\n#define M_PI 3.14159265358979323846\n#endif\n#define rep(i,n) for(int i=0;i<(int)n;++i)\n#define FOR(i,c) for(__typeof((c).begin())i=(c).begin();i!=(c).end();++i)\n#define ALL(c) (c).begin(), (c).end()\n#define mp(a,b) make_pair(a,b)\n#define pb(a) push_back(a)\n#define F first\n#define S second\ntemplate <typename T> string print_array(const vector<T> &V) { ostringstream os; os << \"{ \"; for (typename vector<T>::const_iterator iter = V.begin(); iter != V.end(); ++iter) os << '\\\"' << *iter << \"\\\",\"; os << \" }\"; return os.str(); }\n\nint dx[]={0,1,0,-1},dy[]={1,0,-1,0};\n\nvector<int> se[13];\nint x[]={0,-1,0,1,-2,-1,0,1,2,-1,0,1,0};\nint y[]={2,1,1,1,0,0,0,0,0,-1,-1,-1,-2};\n\nvoid pr(ll in){\n\n  printf(\"      %3lld\\n\",in&15);\n  printf(\"   %3lld%3lld%3lld\\n\",(in>>4)&15,(in>>8)&15,(in>>12)&15);\n  printf(\"%3lld%3lld%3lld%3lld%3lld\\n\",(in>>16)&15,(in>>20)&15,(in>>24)&15,(in>>28)&15,(in>>32)&15);\n  printf(\"   %3lld%3lld%3lld\\n\",(in>>36)&15,(in>>40)&15,(in>>44)&15);\n  printf(\"      %3lld\\n\",(in>>48)&15);\n  puts(\"\");\n}\n\nint manh(ll in){\n  int ret=0;\n  rep(i,13){\n    int t=(in>>(i*4))&15;\n\n    if(!t){\n      int nx=x[t]-x[i],ny=y[t]-y[i];\n      int co=abs(nx)+abs(ny);\n      nx=x[12]-x[i],ny=y[12]-y[i];\n      int k=abs(nx)+abs(ny);\n      ret+=min(co,k);\n      continue;\n    }\n    int nx=(x[t]-x[i]),ny=y[t]-y[i];\n    ret+=abs(nx)+abs(ny);\n  }\n  return ret;\n}\n\nmain(){\n  ll p;\n\n  ll goal=0;\n  rep(i,11){\n    goal|=(i+1LL)<<(4*(i+1));\n    //cout<<goal<<endl;\n    //pr(goal);\n  }\n  //pr(goal);\n\n  se[0].pb(2);\n  se[1].pb(2);\n  se[1].pb(5);\n  se[2].pb(0);\n  se[2].pb(1);\n  se[2].pb(3);\n  se[2].pb(6);\n  se[3].pb(2);\n  se[3].pb(7);\n  se[4].pb(5);\n  se[5].pb(1);\n  se[5].pb(4);\n  se[5].pb(6);\n  se[5].pb(9);\n  se[6].pb(2);\n  se[6].pb(5);\n  se[6].pb(7);\n  se[6].pb(10);\n  se[7].pb(3);\n  se[7].pb(6);\n  se[7].pb(8);\n  se[7].pb(11);\n  se[8].pb(7);\n  se[9].pb(5);\n  se[9].pb(10);\n  se[10].pb(6);\n  se[10].pb(9);\n  se[10].pb(11);\n  se[10].pb(12);\n  se[11].pb(7);\n  se[11].pb(10);\n  se[12].pb(10);\n  \n  while(cin>>p){\n    if(p==-1)break;\n    ll in=p;\n\n    rep(i,12){\n      cin>>p;\n      in|=p<<(4*(i+1));\n    }\n\n    set<ll> app;\n\n    queue<pair<int,ll> > Q;\n    app.insert(in);\n    Q.push(mp(0,in));\n    int ans=21;\n    int mans=0;\n\n    while(!Q.empty()){\n      ll cvec=Q.front().S;\n      int ccost=Q.front().F;\n      Q.pop();\n    \n      //pr(cvec);\n\n      //if(ccost>3)break;\n      if(ccost+manh(cvec)>32)continue;\n      if(cvec==goal){\n\tans=ccost;\n\tbreak;\n      }\n      rep(i,13){\n\tll t=cvec>>(i<<2);\n\tt=t&15;\n\tif(!t){\n\t  rep(j,se[i].size()){\n\t    t=cvec>>(se[i][j]<<2);\n\t    t=t&15;\n\t    if(t){\n\t      ll nvec=cvec;\n\t      t=t<<(i<<2);\n\t      nvec|=t;\n\t      nvec&=~(15LL<<se[i][j]*4);\n\t      \n\t      if(!app.count(nvec)){\n\t\tapp.insert(nvec);\n\t\tQ.push(mp(ccost+1,nvec));\n\t      }\n\t    }\n\t  }\n\t}\n      }\n    }\n    if(ans==21)cout<<\"NA\"<<endl;\n    else cout<<ans<<endl;\n  }\n}"
  },
  {
    "language": "C++",
    "code": "#include <iostream>\n#include <vector>\n#include <algorithm>\n#include <string>\n#include <sstream>\n#include <cstring>\n#include <cstdio>\n#include <cstdlib>\n#include <cmath>\n#include <queue>\n#include <stack>\n#include <map>\n#include <set>\n#include <numeric>\n#include <cctype>\n#include <tuple>\n\n#ifdef _MSC_VER\n#include <agents.h>\n#endif\n\n#define FOR(i, a, b) for(int i = (a); i < (int)(b); ++i)\n#define rep(i, n) FOR(i, 0, n)\n#define ALL(v) v.begin(), v.end()\n#define REV(v) v.rbegin(), v.rend()\n#define MEMSET(v, s) memset(v, s, sizeof(v))\n#define X first\n#define Y second\n\nusing namespace std;\n\ntypedef long long ll;\ntypedef pair<int, int> P;\n\nconst int N = 0;\n\ninline int dist(int x1, int y1, int x2, int y2){\n\treturn abs(x1 - x2) + abs(y1 - y2);\n}\n\ninline bool valid(int x, int y){\n\treturn abs(x - 2) + abs(y - 2) <= 2;\n}\n\nvoid decode(ll x);\n\nll mov(ll state, int zero, int to){\n\tll mask = 15ll << to*4;\n\tmask &= state;\n\tstate ^= mask;\n\tint d = to - zero;\n\tif (d < 0) state |= mask << -d*4;\n\telse state |= mask >> d*4;\n\treturn state;\n}\n\nvoid decode(ll x){\n\tvector<string> vs;\n\trep(i, 5){\n\t\tstring s;\n\t\trep(j, 5){\n\t\t\tif (valid(j, i)){\n\t\t\t\tint tmp = x & 15;\n\t\t\t\ts += \" \";\n\t\t\t\ts += '0' + tmp % 10;\n\t\t\t\ts += '0' + tmp / 10;\n\t\t\t\tx >>= 4;\n\t\t\t}\n\t\t\telse{\n\t\t\t\ts += \" ..\";\n\t\t\t}\n\t\t}\n\t\tvs.push_back(string(REV(s)));\n\t}\n\treverse(ALL(vs));\n\tfor (auto &s : vs){\n\t\tcout << s << endl;\n\t}\n}\n\nint mat[5][5];\n\nstruct state{\n\tll enc;\n\tint d;\n\tint pos[2];\n\tstate(ll e, int p0, int p1, int d) :enc(e), d(d){ pos[0] = p0, pos[1] = p1; };\n};\n\nint main(){\n\n\tint pos = 0;\n\tvector<vector<int>> adj;\n\t{\n\t\tint tmp = 0;\n\t\trep(i, 5) rep(j, 5) if (valid(j, i)) mat[i][j] = tmp++;\n\t}\n\trep(i, 5) rep(j, 5){\n\t\tvector<int> v;\n\t\tif (!valid(j, i)) continue;\n\t\trep(k, 5) rep(l, 5){\n\t\t\tif (!valid(l, k)) continue;\n\t\t\tif (dist(j, i, l, k) != 1) continue;\n\t\t\tv.push_back(mat[k][l]);\n\t\t}\n\t\tadj.push_back(v);\n\t}\n\n\tll init = 0;\n\tint tmp = 0;\n\trep(i, 5) rep(j, 5){\n\t\tif (!valid(j, i)) continue;\n\t\tinit <<= 4;\n\t\tinit |= (tmp++) % 12;\n\t}\n\n\tmap<ll, int> m;\n\tm[init] = 0;\n\tqueue<state> q;\n\tq.push({ init, 0, 12, 0 });\n\twhile (!q.empty()){\n\t\tstate s = q.front();\n\t\tq.pop();\n\n\t\trep(i, 2){\n\t\t\tfor (auto to : adj[s.pos[i]]){\n\t\t\t\tll nxt = mov(s.enc, s.pos[i], to);\n\t\t\t\tif (m.count(nxt)) continue;\n\t\t\t\tm[nxt] = s.d + 1;\n\t\t\t\tif (s.d + 1 < 10) q.push({ nxt, s.pos[!i], to, s.d + 1 });\n\t\t\t}\n\t\t}\n\t}\n\n\tll x;\n\twhile (cin >> x, ~x){\n\t\tvector<int> zero;\n\t\tint in;\n\t\trep(i, 12){\n\t\t\tcin >> in;\n\t\t\tx = (x << 4) + in;\n\t\t\tif (!in) zero.push_back(i + 1);\n\t\t}\n\t\tif (zero.size() <= 1) zero.push_back(0);\n\t\t//decode(x);\n\n\t\tset<ll> vis;\n\t\tqueue<state> q;\n\t\tq.push({ x, zero[0], zero[1], 0 });\n\t\tint ans = -1;\n\t\tif (m.count(x)){\n\t\t\tans = m[x];\n\t\t}\n\t\telse\n\t\twhile (!q.empty()){\n\t\t\tstate s = q.front();\n\t\t\tq.pop();\n\n\t\t\trep(i, 2){\n\t\t\t\tfor (auto to : adj[s.pos[i]]){\n\t\t\t\t\tll nxt = mov(s.enc, s.pos[i], to);\n\t\t\t\t\tif (vis.count(nxt)) continue;\n\t\t\t\t\tvis.insert(nxt);\n\t\t\t\t\tif (m.count(nxt)){\n\t\t\t\t\t\tans = s.d + m[nxt] + 1;\n\t\t\t\t\t\tgoto end;\n\t\t\t\t\t}\n\t\t\t\t\tif (s.d + 1 < 12) q.push({ nxt, s.pos[!i], to, s.d + 1 });\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\tend:\n\t\tif (0 <= ans && ans <= 20) cout << ans << endl;\n\t\telse cout << \"NA\" << endl;\n\t}\n\n\n\treturn 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include <cstdio>\n#include <cstdlib>\n#include <cmath>\n#include <climits>\n#include <cfloat>\n#include <map>\n#include <utility>\n#include <set>\n#include <iostream>\n#include <memory>\n#include <string>\n#include <vector>\n#include <algorithm>\n#include <functional>\n#include <sstream>\n#include <complex>\n#include <stack>\n#include <queue>\n#include <cstring>\n#include <sstream>\n#include <cassert>\n#include <list>\nusing namespace std;\nstatic const double EPS = 1e-10;\ntypedef long long ll;\ntypedef pair<int,int> PI;\ntypedef vector<int> vi;\n#ifndef M_PI\n#define M_PI 3.14159265358979323846\n#endif\n#define rep(i,n) for(int i=0;i<(int)n;++i)\n#define FOR(i,c) for(__typeof((c).begin())i=(c).begin();i!=(c).end();++i)\n#define ALL(c) (c).begin(), (c).end()\n#define mp(a,b) make_pair(a,b)\n#define pb(a) push_back(a)\n#define F first\n#define S second\ntemplate <typename T> string print_array(const vector<T> &V) { ostringstream os; os << \"{ \"; for (typename vector<T>::const_iterator iter = V.begin(); iter != V.end(); ++iter) os << '\\\"' << *iter << \"\\\",\"; os << \" }\"; return os.str(); }\n\nint dx[]={0,1,0,-1},dy[]={1,0,-1,0};\n\nvector<int> se[13];\nint x[]={0,-1,0,1,-2,-1,0,1,2,-1,0,1,0};\nint y[]={2,1,1,1,0,0,0,0,0,-1,-1,-1,-2};\n\nvoid pr(ll in){\n\n  printf(\"      %3lld\\n\",in&15);\n  printf(\"   %3lld%3lld%3lld\\n\",(in>>4)&15,(in>>8)&15,(in>>12)&15);\n  printf(\"%3lld%3lld%3lld%3lld%3lld\\n\",(in>>16)&15,(in>>20)&15,(in>>24)&15,(in>>28)&15,(in>>32)&15);\n  printf(\"   %3lld%3lld%3lld\\n\",(in>>36)&15,(in>>40)&15,(in>>44)&15);\n  printf(\"      %3lld\\n\",(in>>48)&15);\n  puts(\"\");\n}\n\nint manh(ll in){\n  int ret=0;\n  rep(i,13){\n    int t=(in>>(i*4))&15;\n\n    if(!t){\n      int nx=x[t]-x[i],ny=y[t]-y[i];\n      int co=abs(nx)+abs(ny);\n      nx=x[12]-x[i],ny=y[12]-y[i];\n      int k=abs(nx)+abs(ny);\n      ret+=min(co,k);\n      continue;\n    }\n    int nx=(x[t]-x[i]),ny=y[t]-y[i];\n    ret+=abs(nx)+abs(ny);\n  }\n  return ret;\n}\n\nmain(){\n  ll p;\n\n  ll goal=0;\n  rep(i,11){\n    goal|=(i+1LL)<<(4*(i+1));\n    //cout<<goal<<endl;\n    //pr(goal);\n  }\n  //pr(goal);\n\n  se[0].pb(2);\n  se[1].pb(2);\n  se[1].pb(5);\n  se[2].pb(0);\n  se[2].pb(1);\n  se[2].pb(3);\n  se[2].pb(6);\n  se[3].pb(2);\n  se[3].pb(7);\n  se[4].pb(5);\n  se[5].pb(1);\n  se[5].pb(4);\n  se[5].pb(6);\n  se[5].pb(9);\n  se[6].pb(2);\n  se[6].pb(5);\n  se[6].pb(7);\n  se[6].pb(10);\n  se[7].pb(3);\n  se[7].pb(6);\n  se[7].pb(8);\n  se[7].pb(11);\n  se[8].pb(7);\n  se[9].pb(5);\n  se[9].pb(10);\n  se[10].pb(6);\n  se[10].pb(9);\n  se[10].pb(11);\n  se[10].pb(12);\n  se[11].pb(7);\n  se[11].pb(10);\n  se[12].pb(10);\n  \n  while(cin>>p){\n    if(p==-1)break;\n    ll in=p;\n\n    rep(i,12){\n      cin>>p;\n      in|=p<<(4*(i+1));\n    }\n\n    set<ll> app;\n\n    queue<pair<int,ll> > Q;\n    app.insert(in);\n    Q.push(mp(0,in));\n    int ans=21;\n    int mans=0;\n\n    while(!Q.empty()){\n      ll cvec=Q.front().S;\n      int ccost=Q.front().F;\n      Q.pop();\n    \n      //pr(cvec);\n\n      //if(ccost>3)break;\n      if(ccost+manh(cvec)>35)continue;\n      if(cvec==goal){\n\tans=ccost;\n\tbreak;\n      }\n      rep(i,13){\n\tll t=cvec>>(i<<2);\n\tt=t&15;\n\tif(!t){\n\t  rep(j,se[i].size()){\n\t    t=cvec>>(se[i][j]<<2);\n\t    t=t&15;\n\t    if(t){\n\t      ll nvec=cvec;\n\t      t=t<<(i<<2);\n\t      nvec|=t;\n\t      nvec&=~(15LL<<se[i][j]*4);\n\t      \n\t      if(!app.count(nvec)){\n\t\tapp.insert(nvec);\n\t\tQ.push(mp(ccost+1,nvec));\n\t      }\n\t    }\n\t  }\n\t}\n      }\n    }\n    if(ans==21)cout<<\"NA\"<<endl;\n    else cout<<ans<<endl;\n  }\n}"
  },
  {
    "language": "C++",
    "code": "#include <iostream>\n#include <vector>\n#include <string>\n#include <queue>\n#include <set>\nusing namespace std;\n\nconst int INF = 1 << 28;\n\nint main()\n{\n  vector<vector<int> > table(13);\n  table[0].push_back(2);\n  table[1].push_back(2);\n  table[1].push_back(5);\n  table[2].push_back(0);\n  table[2].push_back(1);\n  table[2].push_back(3);\n  table[2].push_back(6);\n  table[3].push_back(2);\n  table[3].push_back(7);\n  table[4].push_back(5);\n  table[5].push_back(1);\n  table[5].push_back(4);\n  table[5].push_back(6);\n  table[5].push_back(9);\n  table[6].push_back(2);\n  table[6].push_back(5);\n  table[6].push_back(7);\n  table[6].push_back(10);\n  table[7].push_back(3);\n  table[7].push_back(6);\n  table[7].push_back(8);\n  table[7].push_back(11);\n  table[8].push_back(7);\n  table[9].push_back(5);\n  table[9].push_back(10);\n  table[10].push_back(6);\n  table[10].push_back(9);\n  table[10].push_back(11);\n  table[10].push_back(12);\n  table[11].push_back(7);\n  table[11].push_back(10);\n  table[12].push_back(10);\n\n  vector<vector<int> > MH(13, vector<int>(13, INF));\n  for (unsigned int i = 0; i < table.size(); ++i) {\n    for (unsigned int j = 0; j < table[i].size(); ++j)\n      MH[i][table[i][j]] = 1;\n  }\n\n  for (int i = 0; i < 13; ++i)\n    MH[i][i] = 0;\n\n  for (int k = 0; k < 13; ++k) {\n    for (int i = 0; i < 13; ++i) {\n      for (int j = 0; j < 13; ++j)\n\tMH[i][j] = min(MH[i][j], MH[i][k]+MH[k][j]);\n    }\n  }\n\n  vector<int> p(13);\n  while (cin >> p[0]) {\n    if (p[0] == -1)\n      break;\n\n    for (unsigned int i = 1; i < p.size(); ++i)\n      cin >> p[i];\n\n    string s;\n    const string g = \"0123456789AB0\";\n    for (unsigned int i = 0; i < p.size(); ++i) {\n      if (p[i] == 10)\n\ts += \"A\";\n      else if (p[i] == 11)\n\ts += \"B\";\n      else\n\ts += ('0' + p[i]);\n    }\n\n    int ans = -1;\n    queue<pair<int, string> > que;\n    que.push(make_pair(0, s));\n    set<string> visited;\n    while (!que.empty()) {\n      const pair<int, string> st = que.front();\n      que.pop();\n\n      if (st.first > 20)\n\tcontinue;\n\n      if (st.second == g) {\n\tans = st.first;\n\tbreak;\n      }\n\n      visited.insert(st.second);\n      vector<int> zero;\n      for (unsigned int i = 0; i < st.second.size(); ++i) {\n\tif (st.second[i] == '0')\n\t  zero.push_back(i);\n      }\n\n      for (unsigned int i = 0; i < zero.size(); ++i) {\n\tfor (unsigned int j = 0; j < table[zero[i]].size(); ++j) {\n\t  s = st.second;\n\t  swap(s[zero[i]], s[table[zero[i]][j]]);\n\n\t  int cost = 0;\n\t  for (unsigned int k = 0; k < s.size(); ++k) {\n\t    if (s[k] == '0')\n\t      cost += min(MH[0][k], MH[12][k]);\n\t    else if (s[k] == 'A')\n\t      cost += MH[10][k];\n\t    else if (s[k] == 'B')\n\t      cost += MH[11][k];\n\t    else\n\t      cost += MH[s[k]-'0'][k];\n\t  }\n\t  if (cost + st.first > 20)\n\t    continue;\n\n\t  if (visited.find(s) == visited.end()) {\n\t    visited.insert(s);\n\t    que.push(make_pair(st.first+1, s));\n\t  }\n\t}\n      }\n    }\n\n    if (ans == -1)\n      cout << \"NA\" << endl;\n    else\n      cout << ans << endl;\n  }\n  return 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\nusing namespace std;\n\nconst int INF = 1<<28;\nconst int H = 5;\nconst int W = 5;\n\nstruct State {\n  int g[H][W];\n  int x[2], y[2];\n  bool operator < (const State &s) const {\n    for(int i = 0; i < H; ++i) {\n      for(int j = abs(2-i); j < W-abs(2-i); ++j) {\n        if(g[i][j] != s.g[i][j]) return g[i][j] < s.g[i][j];\n      }\n    }\n    return false;\n  }\n  bool operator == (const State &s) const {\n    return !(*this < s) && !(s < *this);\n  }\n};\n\nmap<State,int> bfs1(State src) {\n  const static int dx[4] = {1,0,-1,0};\n  const static int dy[4] = {0,1,0,-1};\n  map<State,int> cost;\n  queue<State> que;\n  cost[src] = 0;\n  que.push(src);\n  while(que.size()) {\n    const State s = que.front();\n    que.pop();\n    if(cost[s] == 10) continue;\n    for(int k = 0; k < 2; ++k) {\n      for(int i = 0; i < 4; ++i) {\n        int nx = s.x[k] + dx[i];\n        int ny = s.y[k] + dy[i];\n        if(nx < 0 || nx >= W) continue;\n        if(ny < 0 || ny >= H) continue;\n        if(s.g[ny][nx] <= 0) continue;\n        State t = s;\n        swap(t.g[t.y[k]][t.x[k]], t.g[ny][nx]);\n        t.x[k] = nx;\n        t.y[k] = ny;\n        if(cost.count(t)) continue;\n        cost[t] = cost[s] + 1;\n        que.push(t);\n      }\n    }\n  }\n  return cost;\n}\n\nint bfs2(State src, map<State,int> rcost) {\n  const static int dx[4] = {1,0,-1,0};\n  const static int dy[4] = {0,1,0,-1};\n  if(rcost.count(src)) return rcost[src];\n  map<State,int> cost;\n  queue<State> que;\n  cost[src] = 0;\n  que.push(src);\n  int res = INF;\n  while(que.size()) {\n    const State s = que.front();\n    que.pop();\n    if(cost[s] == 10) continue;\n    for(int k = 0; k < 2; ++k) {\n      for(int i = 0; i < 4; ++i) {\n        int nx = s.x[k] + dx[i];\n        int ny = s.y[k] + dy[i];\n        if(nx < 0 || nx >= W) continue;\n        if(ny < 0 || ny >= H) continue;\n        if(s.g[ny][nx] <= 0) continue;\n        State t = s;\n        swap(t.g[t.y[k]][t.x[k]], t.g[ny][nx]);\n        t.x[k] = nx;\n        t.y[k] = ny;\n        if(cost.count(t)) continue;\n        cost[t] = cost[s] + 1;\n        que.push(t);\n        if(rcost.count(t)) {\n          res = min(res, cost[t] + rcost[t]);\n        }\n      }\n    }\n  }\n  return res;\n}\n\nint main() {\n  State src, dst;\n  fill(dst.g[0], dst.g[H], -1);\n  for(int i = 0, k = 0, t = 0; i < H; ++i) {\n    for(int j = abs(2-i); j < W-abs(2-i); ++j) {\n      dst.g[i][j] = t++ % 12;\n      if(dst.g[i][j] == 0) {\n        dst.x[k] = j;\n        dst.y[k] = i;\n        ++k;\n      }\n    }\n  }\n  const map<State,int> rcost = bfs1(dst);\n  while(1) {\n    fill(src.g[0], src.g[H], -1);\n    for(int i = 0, k = 0; i < H; ++i) {\n      for(int j = abs(2-i); j < W-abs(2-i); ++j) {\n        cin >> src.g[i][j];\n        if(src.g[i][j] == -1) return 0;\n        if(src.g[i][j] == 0) {\n          src.x[k] = j;\n          src.y[k] = i;\n          ++k;\n        }\n      }\n    }\n    int res = bfs2(src, rcost);\n    if(res > 20) cout << \"NA\" << endl;\n    else cout << res << endl;\n  }\n  return 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include <iostream>\n#include <algorithm>\n#include <vector>\n#include <queue>\n#include <map>\nusing namespace std;\n#define rep(i,n) for(int i=0;i<n;i++)\nclass NODE{\npublic:\n\tvector<int> data;\n\tint depth;\n\tint e[2];\n\tNODE(int a[13],int d,int E[2]){\n\t\tdata.resize(13);\n\t\trep(i,13)data[i] = a[i];\n\t\tdepth = d;\n\t\trep(i,2)e[i] = E[i];\n\t}\n\tNODE(){\n\t\tdepth = 0;\n\t\tdata.resize(13);\n\t}\n};\n\nint di[13][10] = {\n\t{2,-1},\n\t{2,5,-1},\n\t{0,1,3,6,-1},\n\t{2,7,-1},\n\t{5,-1},\n\t{1,4,6,9,-1},\n\t{2,5,7,10,-1},\n\t{3,6,7,11,-1},\n\t{7},\n\t{5,10,-1},\n\t{6,9,11,12,-1},\n\t{7,10,-1},\n\t{10,-1}\n};\n\nint main(){\n\twhile(1){\n\t\tint ret = 21;\n\t\tNODE fst; int cnt = 0;\n\t\trep(i,13){\n\t\t\tif(cin >>fst.data[i] , fst.data[i] != -1){\n\t\t\t\tif(fst.data[i] == 0){\n\t\t\t\t\tfst.e[cnt] = i;\n\t\t\t\t\tcnt++;\n\t\t\t\t}\n\t\t\t}else{\n\t\t\t\treturn 0;\n\t\t\t}\n\t\t}\n\t\tmap< vector<int> , int > done[2];\n\t\t\n\t\trep(x,2){\n\t\t\tqueue<NODE> Q;\n\t\t\tif(x==0){\n\t\t\t\tQ.push(fst);\n\t\t\t}else{\n\t\t\t\tNODE a;\n\t\t\t\trep(i,11)a.data[i+1] = i+1;\n\t\t\t\ta.e[0] = 0;\n\t\t\t\ta.e[1] = 12;\n\t\t\t\tQ.push(a);\n\t\t\t}\n\t\t\tdone[x][Q.front().data] = 0;\n\t\t\twhile(Q.size()){\n\t\t\t\tNODE q = Q.front(); Q.pop();\n\t\t\t\t//rep(i,13)cout << q.data[i] << \" \";cout << q.depth << endl;\n\t\t\t\trep(o,2){\n\t\t\t\t\tfor(int i=0;di[q.e[o]][i] != -1;i++){\n\t\t\t\t\t\tNODE next = q;\n\t\t\t\t\t\tnext.e[o] = next.data[di[q.e[o]][i]];\n\t\t\t\t\t\tswap(next.data[q.e[o]] , next.data[di[q.e[o]][i]]);\n\t\t\t\t\t\tnext.depth = q.depth + 1;\n\t\t\t\t\t\t\n\t\t\t\t\t\tif( done[x].find(next.data) == done[x].end() ){\n\t\t\t\t\t\t\tdone[x][next.data] = next.depth;\n\t\t\t\t\t\t\tif(next.depth < 10){\n\t\t\t\t\t\t\t\tQ.push(next);\n\t\t\t\t\t\t\t}\n\t\t\t\t\t\t}\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t\tfor( map< vector<int> , int >::iterator it = done[0].begin() ; it != done[0].end() ; ++it){\n\t\t\tvector<int> get = (*it).first;\n\t\t\tif( done[1].find(get) != done[1].end() ){\n\t\t\t\tint sum = (*it).second + done[1][get];\n\t\t\t\tret = min(ret,sum);\n\t\t\t}\n\t\t}\n\t\tif(ret > 20){\n\t\t\tcout << \"NA\" << endl;\n\t\t}else{\n\t\t\tcout << ret << endl;\n\t\t}\n\t}\n}"
  },
  {
    "language": "C++",
    "code": "#include <iostream>\n#include <queue>\n#include <map>\nusing namespace std;\n\nunsigned long long int makeID( int (&p)[ 13 ] )\n{\n\tunsigned long long int ret = 0;\n\tfor( int i = 0; i < 13; ++i ){\n\t\tret *= 13;\n\t\tret += p[ i ];\n\t}\n\treturn ret;\n}\n\nunsigned long long int slide( unsigned long long int s, int a, int b )\n{\n\tint p[ 13 ];\n\tfor( int i = 0; i < 13; ++i ){\n\t\tp[ 12 - i ] = s % 13;\n\t\ts /= 13;\n\t}\n\tint t = p[ a ];\n\tp[ a ] = p[ b ];\n\tp[ b ] = t;\n\treturn makeID( p );\n}\n\nint main()\n{\n\tmap< unsigned long long int, int > ans;\n\tqueue< unsigned long long int > q;\n\n\tint side[][ 4 ] = {\n\t\t{ -1, -1,  2, -1 },\n\t\t{ -1,  2,  5, -1 },\n\t\t{  0,  3,  6,  1 },\n\t\t{ -1, -1,  7,  2 },\n\t\t{ -1,  5, -1, -1 },\n\t\t{  1,  6,  9,  4 },\n\t\t{  2,  7, 10,  5 },\n\t\t{  3,  8, 11,  6 },\n\t\t{ -1, -1, -1,  7 },\n\t\t{  5, 10, -1, -1,},\n\t\t{  6, 11, 12,  9 },\n\t\t{  7, -1, -1, 10 },\n\t\t{ 10, -1, -1, -1 }\n\t};\n\n\tint p[ 13 ];\n\tfor( int i = 0; i < 13; ++i ){\n\t\tp[ i ] = i;\n\t}\n\tp[ 12 ] = 0;\n\tunsigned long long int s = makeID( p );\n\tans[ s ] = 0;\n\tq.push( s );\n\n\tint cnt = 1;\n\twhile( cnt <= 20 ){\n\t\tint size = q.size();\n\t\tfor( int i = 0; i < size; ++i ){\n\t\t\ts = q.front();\n\t\t\tq.pop();\n\t\t\tint pos[ 2 ], a = 0;\n\t\t\tunsigned long long int t = s;\n\t\t\tfor( int j = 0; j < 13; ++j ){\n\t\t\t\tint b = t % 13;\n\t\t\t\tif( b == 0 ) pos[ a++ ] = 12 - j;\n\t\t\t\tt /= 13;\n\t\t\t}\n\t\t\tfor( int j = 0; j < 2; ++j ){\n\t\t\t\tint b = pos[ j ];\n\t\t\t\tfor( int k = 0; k < 4; ++k ){\n\t\t\t\t\tint c = side[ b ][ k ];\n\t\t\t\t\tif( c == -1 ) continue;\n\t\t\t\t\tt = slide( s, b, c );\n\t\t\t\t\tif( ans.find( t ) == ans.end() ){\n\t\t\t\t\t\tans[ t ] = cnt;\n\t\t\t\t\t\tq.push( t );\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t\t++cnt;\n\t}\n\n\twhile( cin >> p[ 0 ] && p [ 0 ] != -1 ){\n\t\tfor( int i = 1; i < 13; ++i ){\n\t\t\tcin >> p[ i ];\n\t\t}\n\t\ts = makeID( p );\n\t\tif( ans.find( s ) != ans.end() ){\n\t\t\tcout << ans[ s ] << endl;\n\t\t}else{\n\t\t\tcout << \"NA\" << endl;\n\t\t}\n\t}\n\n\treturn 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include<iostream>\n#include<algorithm>\n#include<vector>\n#include<queue>\n#include<unordered_map>\n#include<unordered_set>\n#define lol(i,n) for(int i=0;i<n;i++)\n#define mod 1000000007\ntypedef long long ll;\nusing namespace std;\nint dx[13][4]={\n  {3,0,0,0},\n  {3,6,0,0},\n  {1,2,4,7},\n  {3,8,0,0},\n  {6,0,0,0},\n  {2,5,7,10},\n  {3,6,8,11},\n  {4,7,9,12},\n  {8,0,0,0},\n  {6,11,0,0},\n  {7,10,12,13},\n  {8,11,0,0},\n  {11,0,0,0}\n};\nunordered_map<ll,int> mp;\nll Compress(int p[]){\n  ll ans=0;\n  for(int i=0;i<13;i++){\n    ans*=13;\n    ans+=p[i];\n  }\n  return ans;\n}\n \nint unzip[13];\nvoid Unzip(ll x){\n  for(int i=0;i<13;i++){\n    unzip[12-i]=x%13;\n    x/=13;\n  }\n}\n \nint beflen=0;\nunordered_set<ll> vist;\nqueue<pair<ll,int> >Q;\nvoid BFS(int p[],int len){\n  //if(len!=beflen){cout<<len<<endl;beflen=len;}\n  ll tmp=Compress(p);\n  mp[tmp]=len;\n  if(len==13)return;\n  lol(i,13){\n    if(p[i]==0){\n      lol(j,4){\n    int t=dx[i][j];\n    if(t==0)break;\n    t--;\n    if(p[t]!=0){\n      swap(p[i],p[t]);\n      tmp=Compress(p);\n      if(vist.find(tmp)!=vist.end())continue;\n      vist.insert(tmp);\n      Q.push(make_pair(tmp,len+1));\n      swap(p[i],p[t]);\n    }\n      }\n    }\n  }\n}\n \nunordered_set<ll> st;\nint ans;\nvoid EFS(int p[],int len){\n  //if(len!=beflen){cout<<len<<endl;beflen=len;}\n  ll tmp=Compress(p);\n  if(vist.find(tmp)!=vist.end()){\n    ans=len+mp[tmp];\n    return;\n  }\n  if(len==9)return;\n  lol(i,13){\n    if(p[i]==0){\n      lol(j,4){\n    int t=dx[i][j];\n    if(t==0)break;\n    t--;\n    if(p[t]!=0){\n      swap(p[i],p[t]);\n      tmp=Compress(p);\n      if(st.find(tmp)!=st.end())continue;\n      st.insert(tmp);\n      Q.push(make_pair(tmp,len+1));\n      swap(p[i],p[t]);\n    }\n      }\n    }\n  }\n}\nint main(){\n  int p[13];\n  lol(i,13)p[i]=i;p[12]=0;\n  Q.push(make_pair(Compress(p),0));\n  while(!Q.empty()){\n    ll data=Q.front().first;\n    int len=Q.front().second;\n    Q.pop();\n    if(mp[data]>0)continue;\n    Unzip(data);\n    BFS(unzip,len);\n  }\n  //cout<<\"#\"<<mp.size()<<endl;\n  while(cin>>p[0]&&p[0]!=-1){\n    for(int i=1;i<13;i++)cin>>p[i];\n    ans=mod;\n    Q.push(make_pair(Compress(p),0));\n    while(!Q.empty()){\n      ll data=Q.front().first;\n      int len=Q.front().second;\n      Q.pop();\n      if(ans!=mod)continue;\n      if(st.find(data)!=st.end())continue;\n      st.insert(data);\n      Unzip(data);\n      EFS(unzip,len);\n    }\n    st.clear();\n    if(ans>20)cout<<\"NA\"<<endl;\n    else cout<<ans<<endl;\n  }\n  return 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include <vector>\n#include <list>\n#include <map>\n#include <set>\n#include <deque>\n#include <queue>\n#include <stack>\n#include <bitset>\n#include <algorithm>\n#include <functional>\n#include <numeric>\n#include <utility>\n#include <sstream>\n#include <iostream>\n#include <iomanip>\n#include <cstdio>\n#include <cmath>\n#include <cstdlib>\n#include <cctype>\n#include <string>\n#include <cstring>\n#include <ctime>\n\nusing namespace std;\n\ninline int toInt(string s) {int v; istringstream sin(s);sin>>v;return v;}\ntemplate<class T> inline string toString(T x) {ostringstream sout;sout<<x;return sout.str();}\ntemplate<class T> inline T sqr(T x) {return x*x;}\n\ntypedef vector<int> vi;\ntypedef vector<vi> vvi;\ntypedef vector<string> vs;\ntypedef pair<int, int> pii;\ntypedef long long ll;\n\n#define all(a)  (a).begin(),(a).end()\n#define rall(a) (a).rbegin(), (a).rend()\n#define pb push_back\n#define mp make_pair\n#define each(i,c) for(typeof((c).begin()) i=(c).begin(); i!=(c).end(); ++i)\n#define exist(s,e) ((s).find(e)!=(s).end())\n#define range(i,a,b) for(int i=(a);i<(b);++i)\n#define rep(i,n)  range(i,0,n)\n#define clr(a,b) memset((a), (b) ,sizeof(a))\n#define dump(x)  cerr << #x << \" = \" << (x) << endl;\n#define debug(x) cerr << #x << \" = \" << (x) << \" (L\" << __LINE__ << \")\" << \" \" << __FILE__ << endl;\n\nconst double eps = 1e-10;\nconst double pi  = acos(-1.0);\nconst ll inf =1LL << 62;\n\ntypedef  pair<string,int> P;\n\nmap <string,int> ans;\n \nvoid bfs(void){\n\tstring ini=\"0123456789ab0\";\n\tP init;\n\tinit.first=ini;\n\tinit.second=0;\n\tqueue<P> q;\n\tq.push(init);\n\twhile(!q.empty()){\n\t\tP cur;\n\t\tcur=q.front();q.pop();\n\t//\tcout << cur.first << endl;\n\t\tif(cur.second>=21)\n\t\t\tcontinue;\n\t\t\n\t\tif(ans.find(cur.first)==ans.end())\n\t\t\tans[cur.first]=cur.second;\n\t\telse\n\t\t\tcontinue;\n\t\tint zero[2]={-1,-1};\n\t\trep(i,13){\n\t\t\tif(zero[0]==-1&&cur.first[i]=='0')\n\t\t\t\tzero[0]=i;\n\t\t\telse if(zero[1]==-1&&cur.first[i]=='0')\n\t\t\t\tzero[1]=i;\n\t\t}\n\t\trep(i,2){\n\t\t\tstring tar;\n\t\t\tP next;\n\t\t\tint check=zero[i];\n\t\t\tif(check%4){\n\t\t\t\tint d[4]={-4,-1,1,4};\n\t\t\t\trep(j,4){\n\t\t\t\t\tif(j==0&&(check==1||check==3))\n\t\t\t\t\t\tcontinue;\n\t\t\t\t\tif(j==1&&(check==1||check==9))\n\t\t\t\t\t\tcontinue;\n\t\t\t\t\tif(j==2&&(check==9||check==11))\n\t\t\t\t\t\tcontinue;\n\t\t\t\t\tif(j==3&&(check==3||check==11))\n\t\t\t\t\t\tcontinue;\n\t\t\t\t\ttar=cur.first;\n\t\t\t\t\tint index=check+d[j];\n\t\t\t\t\tindex=max(index,0);\n\t\t\t\t\tindex=min(index,12);\n\t\t\t\t\tswap(tar[check],tar[index]);\n\t\t\t\t\tnext.first=tar;\n\t\t\t\t\tnext.second=cur.second+1;\n\t\t\t\t\tq.push(next);\n\t\t\t\t}\n\t\t\t}else{\n\t\t\t\tint d[4]={2,1,-1,-2};\n\t\t\t\ttar=cur.first;\n\t\t\t\tint index=check/4;\n\t\t\t\tswap(tar[check],tar[check+d[index]]);\n\t\t\t\tnext.first=tar;\n\t\t\t\tnext.second=cur.second+1;\n\t\t\t\tq.push(next);\n\t\t\t}\n\t\t}\n\t}\n\treturn ;\n}\n\nint main(void){\n\tbfs();\n\tint input[13];\n\twhile(cin >> input[0],input[0]!=-1){\n\t\tfor(int i=1;i<13;i++)\n\t\t\tcin >> input[i];\n\t\tstring query=\"\";\n\t\trep(i,13){\n\t\t\tif(input[i]>=10)\n\t\t\t\tquery+=((input[i]-10)+'a');\n\t\t\telse\n\t\t\t\tquery+=(input[i]+'0');\n\t\t}\n\t\tif(ans.find(query)==ans.end())\n\t\t\tcout << \"NA\" << endl;\n\t\telse\n\t\t\tcout << ans[query] << endl;\n\t}\n\treturn 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include <iostream>\n#include <vector>\n#include <algorithm>\n#include <queue>\n#include <set>\n#include <cstring>\n#include <cstdlib>\nusing namespace std;\n\n\nconst int INF=100000000;\n// ®©¹éêði[·éXg\nvector<int> d[13];\n\n// »ê¼êÌê©çá¤êÖÚ®·éÌÉKvÈ}nb^£\nint mhd[13][13];\nconst int V=13;\n\nvoid warshall_floyd(){\n    for(int k = 0; k < V; k++)\n        for(int i = 0; i < V; i++)\n            for(int j = 0; j < V; j++)\n                mhd[i][j]=min(mhd[i][j],mhd[i][k]+mhd[k][j]);\n}\n\nint main(){\n\n    d[0].push_back(2);\n\n    d[1].push_back(2);\n    d[1].push_back(5);\n\n    d[2].push_back(0);\n    d[2].push_back(1);\n    d[2].push_back(3);\n    d[2].push_back(6);\n\n    d[3].push_back(2);\n    d[3].push_back(7);\n\n    d[4].push_back(5);\n\n    d[5].push_back(1);\n    d[5].push_back(4);\n    d[5].push_back(6);\n    d[5].push_back(9);\n\n    d[6].push_back(2);\n    d[6].push_back(5);\n    d[6].push_back(7);\n    d[6].push_back(10);\n\n    d[7].push_back(3);\n    d[7].push_back(6);\n    d[7].push_back(8);\n    d[7].push_back(11);\n\n    d[8].push_back(7);\n\n    d[9].push_back(5);\n    d[9].push_back(10);\n\n    d[10].push_back(6);\n    d[10].push_back(9);\n    d[10].push_back(11);\n    d[10].push_back(12);\n\n    d[11].push_back(10);\n    d[11].push_back(7);\n\n    d[12].push_back(10);\n\n    for(int i = 0; i < 13; i++)\n        for(int j = 0; j < 13; j++)\n            mhd[i][j]=INF;\n    \n    for(int i = 0; i < 13; i++){\n        mhd[i][i]=0;\n        // ¼Ú¹ª éÆ±ëÉRXg1ðãü\n        for(int j = 0; j < d[i].size(); j++){\n            int to=d[i][j];\n            mhd[i][to]=1;\n        }\n    }\n\n    warshall_floyd();\n\n    while(1){\n        set<vector<int> > no;\n        vector<int> v;\n        int cost=0;\n        for(int j = 0; j < 13; j++){\n            int t;\n            cin>>t;\n            if(t==-1)\n                return 0;\n            v.push_back(t);\n            if(t!=0)\n                cost+=mhd[t][j];\n        }\n        // Å©ç»ëÁÄ¢éê\n        if(cost==0){\n            cout<<0<<endl;\n            continue;\n        }\n        queue<pair<int,vector<int> > > *prv=new queue<pair<int,vector<int> > >();\n        queue<pair<int,vector<int> > > *nxt=new queue<pair<int,vector<int> > >();\n        prv->push(make_pair(cost,v));\n        int cnt=0;\n        bool isGoal=false;\n        // 20èÜÅTõð©¯é\n        while(prv->size()){\n            while(prv->size()){\n                vector<int> b=prv->front().second;\n                int cos=prv->front().first;    \n                prv->pop();\n                vector<int> emp;\n                for(int i = 0; i < b.size(); i++)\n                    if(b[i]==0)\n                        emp.push_back(i);\n                // óÌêðêÂIÑAJÚ·é\n                for(int i = 0; i < emp.size(); i++){\n                    int num=emp[i];\n                    for(int j = 0; j < d[num].size(); j++){\n                        // ¡ñg¤board\n                        vector<int> bt=b;\n                        // Ú®æ\n                        int to=d[num][j];\n                        if(bt[to]==0)\n                            continue;\n                        swap(bt[to],bt[num]);\n                        if(no.find(bt)!=no.end())\n                            continue;\n                        no.insert(bt);\n                        // Ú®æÌ]¿l(0ÉÈÁ½çI¹)\n                        int toCost=cos-mhd[to][b[to]]+mhd[b[to]][num];\n                        // goal\n                        if(toCost==0){\n                            isGoal=true;\n                            break;\n                        }\n                        // »Ýn_©çS[É½Çè¯é©Ç¤©\n                        // ³Èç}ëè\n                        if(!(toCost>(19-cnt)))\n                            nxt->push(make_pair(toCost,bt));\n                    }\n                    if(isGoal)\n                        break;\n                }\n                if(isGoal)\n                    break;\n            }\n            if(isGoal)\n                break;\n            swap(prv,nxt);\n            cnt++;\n            // 20èðz¦Ä¢é\n            if(cnt>=20){\n                break;\n            }\n        }\n        if(isGoal){\n            cout<<cnt+1<<endl;\n        }\n        else{\n            cout<<\"NA\"<<endl;\n        }\n        delete prv,nxt;\n    }\n\n    return 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include<iostream>\n#include<queue>\n#include<map>\n#include<vector>\nusing namespace std;\nint px[13]={0,1,1,1,2,2,2,2,2,3,3,3,4},py[13]={2,1,2,3,0,1,2,3,4,1,2,3,2};\nint xx[12]={0,1,1,1,2,2,2,2,2,3,3,3},yy[12]={0,1,2,3,0,1,2,3,4,1,2,3};\nstruct board{\n\tint p[13],a,b;\n\tbool operator<(const board&a)const\n\t{\n\t\tfor(int i=0;i<13;i++)\n\t\t{\n\t\t\tif(p[i]!=a.p[i])return p[i]<a.p[i];\n\t\t}\n\t\treturn false;\n\t}\n\tint distance()const\n\t{\n\t\tint ret=0;\n\t\tfor(int i=0;i<13;i++)\n\t\t{\n\t\t\tif(p[i]==0)continue;\n\t\t\tret+=abs(px[i]-xx[p[i]])+abs(py[i]-yy[p[i]]);\n\t\t}\n\t\treturn ret;\n\t}\n};\nvector<int>D[13];\nmain()\n{\n\tD[0].push_back(2);\n\tD[1].push_back(2);\n\tD[1].push_back(5);\n\tD[2].push_back(0);\n\tD[2].push_back(1);\n\tD[2].push_back(3);\n\tD[2].push_back(6);\n\tD[3].push_back(2);\n\tD[3].push_back(7);\n\tD[4].push_back(5);\n\tD[5].push_back(1);\n\tD[5].push_back(4);\n\tD[5].push_back(6);\n\tD[5].push_back(9);\n\tD[6].push_back(2);\n\tD[6].push_back(5);\n\tD[6].push_back(7);\n\tD[6].push_back(10);\n\tD[7].push_back(3);\n\tD[7].push_back(6);\n\tD[7].push_back(8);\n\tD[7].push_back(11);\n\tD[8].push_back(7);\n\tD[9].push_back(5);\n\tD[9].push_back(10);\n\tD[10].push_back(6);\n\tD[10].push_back(9);\n\tD[10].push_back(11);\n\tD[10].push_back(12);\n\tD[11].push_back(7);\n\tD[11].push_back(10);\n\tD[12].push_back(10);\n\twhile(true)\n\t{\n\t\tboard start;\n\t\tcin>>start.p[0];\n\t\tif(start.p[0]<0)break;\n\t\tfor(int i=1;i<13;i++)cin>>start.p[i];\n\t\tstart.a=start.b=-1;\n\t\tfor(int i=0;i<13;i++)\n\t\t{\n\t\t\tif(start.p[i]==0)\n\t\t\t{\n\t\t\t\tif(start.a<0)start.a=i;\n\t\t\t\telse start.b=i;\n\t\t\t}\n\t\t}\n\t\tboard goal;\n\t\tfor(int i=0;i<12;i++)goal.p[i]=i;\n\t\tgoal.p[12]=0;\n\t\tqueue<board>P;\n\t\tP.push(start);\n\t\tmap<board,int>M;\n\t\tM[start]=0;\n\t\tint ans=-1;\n\t\twhile(!P.empty())\n\t\t{\n\t\t\tboard now=P.front();P.pop();\n\t\t\tint c=M[now];\n\t\t\tif(c+now.distance()>20)continue;\n\t\t\tif(!(now<goal||goal<now))\n\t\t\t{\n\t\t\t\tans=c;\n\t\t\t\tbreak;\n\t\t\t}\n\t\t\tfor(int v:D[now.a])\n\t\t\t{\n\t\t\t\tint x=now.a,y=v;\n\t\t\t\tswap(now.p[x],now.p[y]);\n\t\t\t\tnow.a=y;\n\t\t\t\tif(M.find(now)==M.end())\n\t\t\t\t{\n\t\t\t\t\tM[now]=c+1;\n\t\t\t\t\tP.push(now);\n\t\t\t\t}\n\t\t\t\tswap(now.p[x],now.p[y]);\n\t\t\t\tnow.a=x;\n\t\t\t}\n\t\t\tfor(int v:D[now.b])\n\t\t\t{\n\t\t\t\tint x=now.b,y=v;\n\t\t\t\tswap(now.p[x],now.p[y]);\n\t\t\t\tnow.b=y;\n\t\t\t\tif(M.find(now)==M.end())\n\t\t\t\t{\n\t\t\t\t\tM[now]=c+1;\n\t\t\t\t\tP.push(now);\n\t\t\t\t}\n\t\t\t\tswap(now.p[x],now.p[y]);\n\t\t\t\tnow.b=x;\n\t\t\t}\n\t\t}\n\t\tif(ans<0)cout<<\"NA\"<<endl;\n\t\telse cout<<ans<<endl;\n\t}\n}\n\n"
  },
  {
    "language": "C++",
    "code": "#include<bits/stdc++.h>\n#define r(i,n) for(int i=0;i<n;i++)\nusing namespace std;\ntypedef pair<vector<int>,int>P;\nvector<int>v[13],s(13),t(13);\nmap<vector<int>,int>m;\nvoid init(){\n\n    v[0].push_back(2);\n\n    v[1].push_back(2);\n    v[1].push_back(5);\n\n    v[2].push_back(0);\n    v[2].push_back(1);\n    v[2].push_back(3);\n    v[2].push_back(6);\n\n    v[3].push_back(2);\n    v[3].push_back(7);\n\n    v[4].push_back(5);\n\n    v[5].push_back(1);\n    v[5].push_back(4);\n    v[5].push_back(6);\n    v[5].push_back(9);\n\n    v[6].push_back(2);\n    v[6].push_back(5);\n    v[6].push_back(7);\n    v[6].push_back(10);\n\n    v[7].push_back(3);\n    v[7].push_back(6);\n    v[7].push_back(8);\n    v[7].push_back(11);\n\n    v[8].push_back(7);\n\n    v[9].push_back(5);\n    v[9].push_back(10);\n\n    v[10].push_back(6);\n    v[10].push_back(9);\n    v[10].push_back(11);\n    v[10].push_back(12);\n\n    v[11].push_back(7);\n    v[11].push_back(10);\n\n    v[12].push_back(10);\n}\nvoid BFS1(){\n    s[0]=0;\n    s[12]=0;\n    r(i,11)s[i+1]=i+1;\n    set<vector<int> >st;\n    st.insert(s);\n    m[s]=0;\n    queue<P>q;\n    q.push(P(s,0));\n    while(1){\n        vector<int>now=q.front().first;\n        int cost=q.front().second;\n        q.pop();\n        if(cost==7)break;\n        r(i,13)if(now[i]!=0){\n            r(j,v[i].size()){\n                swap(now[i],now[v[i][j]]);\n                if(!st.count(now)){\n                    st.insert(now);\n                    m[now]=cost+1;\n                    q.push(P(now,cost+1));\n                }\n                swap(now[i],now[v[i][j]]);\n            }\n        }\n    }\n}\n\nvoid BFS2(){\n    set<vector<int> >st;\n    st.insert(t);\n    queue<P>q;\n    q.push(P(t,0));\n    while(1){\n        vector<int>now=q.front().first;\n        int cost=q.front().second;\n        if(m.count(now)){\n            cout<<m[now]+cost<<endl;\n            return ;\n        }\n        q.pop();\n        if(cost==5)break;\n        r(i,13)if(now[i]!=0){\n            r(j,v[i].size()){\n                swap(now[i],now[v[i][j]]);\n                if(!st.count(now)){\n                    st.insert(now);\n                    q.push(P(now,cost+1));\n                }\n                swap(now[i],now[v[i][j]]);\n            }\n        }\n    }\n    cout<<\"NA\"<<endl;\n}\n\n\nint main(){\n    init();\n    BFS1();\n    while(cin>>t[0],t[0]!=-1){\n        r(i,12)cin>>t[i+1];\n        BFS2();\n    }\n}\n"
  },
  {
    "language": "C++",
    "code": "#include <iostream>\n#include <cstdio>\n#include <queue>\n#include <set>\n#include <map>\n#include <cmath>\nusing namespace std;\ntypedef unsigned long long ull;\null B = 1000000003ull;\nint a[5]={2,1,0,1,2};\nint b[5]={2,3,4,3,2};\nint dx[5]={0,1,0,-1};\nint dy[5]={1,0,-1,0};\nint px[13]={0,1,1,1,2,2,2,2,2,3,3,3,0};\nint py[13]={0,1,2,3,0,1,2,3,4,0,1,2,0};\n\nstruct State\n{\n\tint f[5][5];\n\tint t;\n};\null hash(State x)\n{\n\tull t = 1ull;\n\tull res = 0;\n\tfor(int i=0;i<5;i++)\n\t{\n\t\tfor(int j=a[i];j<=b[i];j++)\n\t\t{\n\t\t\tres += x.f[i][j]*t;\n\t\t\tt *= B;\n\t\t}\n\t}\n\treturn res;\n}\nmap<ull,int> mp;\nset<ull> used;\nbool check(State x)\n{\n\tint cnt=1;\n\tfor(int i=1;i<=3;i++)\n\t{\n\t\tfor(int j=a[i];j<=b[i];j++)\n\t\t{\n\t\t\tif(x.f[i][j]!=cnt)return false;\n\t\t\tcnt++;\n\t\t}\n\t}\n\treturn true;\n}\nbool cc(State x)\n{\n\tint res = 0;\n\tfor(int i=0;i<5;i++)\n\t{\n\t\tfor(int j=a[i];j<=b[i];j++)\n\t\t{\n\t\t\tif(x.f[i][j])\n\t\t\t{\n\t\t\t\tint k = x.f[i][j];\n\t\t\t\tres += (abs(px[k]-i)+abs(py[k]-j));\n\t\t\t}\n\t\t}\n\t}\n\treturn (res>20-x.t);\n}\nint ans = 21;\nvoid bfs(State st)\n{\n\tqueue<State> q;\n\tmp[hash(st)]=0;\n\tq.push(st);\n\twhile(!q.empty())\n\t{\n\t\tState A = q.front();\n\t\tq.pop();\n\t\t//cout << \"koko\" << endl;\n\t\tfor(int i=0;i<5;i++)\n\t\t{\n\t\t\tfor(int j=0;j<5;j++)\n\t\t\t{\n\t\t\t\tif(j<a[i]||b[i]<j)continue;\n\t\t\t\tif(A.f[i][j]==0)continue;\n\t\t\t\tfor(int k=0;k<4;k++)\n\t\t\t\t{\n\t\t\t\t\tint nx=i+dx[k],ny=j+dy[k];\n\t\t\t\t\tif(nx<0||nx>=5||ny<0||ny>=5)continue;\n\t\t\t\t\tif(ny<a[nx]||b[nx]<ny)continue;\n\t\t\t\t\tif(A.f[nx][ny]!=0)continue;\n\t\t\t\t\tState B = A;\n\t\t\t\t\tswap(B.f[nx][ny],B.f[i][j]);\n\t\t\t\t\tB.t++;\n\t\t\t\t\t//cout << \"a\" << endl;\n\t\t\t\t\tif(B.t>8)continue;\n\t\t\t\t\tull hb = hash(B);\n\t\t\t\t\tif(mp.find(hb)!=mp.end())continue;\n\t\t\t\t\t//cout << hb << endl;\n\t\t\t\t\tmp[hb]=B.t;\n\t\t\t\t\tq.push(B);\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t}\n\t//cout << \"owari\" << endl;\n}\nvoid bfs2(State st)\n{\n\tqueue<State> q;\n\tif(check(st)){ans=0;return;}\n\tq.push(st);\n\twhile(!q.empty())\n\t{\n\t\tState A = q.front();\n\t\tq.pop();\n\t\tull ha=hash(A); \n\t\tif(mp.find(hash(A))!=mp.end()){ans = min(ans,A.t+mp[ha]);continue;}\n\t\tfor(int i=0;i<5;i++)\n\t\t{\n\t\t\tfor(int j=0;j<5;j++)\n\t\t\t{\n\t\t\t\tif(j<a[i]||b[i]<j)continue;\n\t\t\t\tif(A.f[i][j]==0)continue;\n\t\t\t\tfor(int k=0;k<4;k++)\n\t\t\t\t{\n\t\t\t\t\tint nx=i+dx[k],ny=j+dy[k];\n\t\t\t\t\tif(nx<0||nx>=5||ny<0||ny>=5)continue;\n\t\t\t\t\tif(ny<a[nx]||b[nx]<ny)continue;\n\t\t\t\t\tif(A.f[nx][ny]!=0)continue;\n\t\t\t\t\tState B = A;\n\t\t\t\t\tswap(B.f[nx][ny],B.f[i][j]);\n\t\t\t\t\tB.t++;\n\t\t\t\t\tif(cc(B))continue;\n\t\t\t\t\tull hb = hash(B);\n\t\t\t\t\tif(used.find(hb)!=used.end())continue;\n\t\t\t\t\tused.insert(hb);\n\t\t\t\t\tq.push(B);\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t}\n}\nint main()\n{\n\tState end;\n\tint cnt=1;\n\tend.t=0;\n\tfor(int i=0;i<5;i++)for(int j=0;j<5;j++)end.f[i][j]=-1;\n\tend.f[0][2]=0;\n\tend.f[4][2]=0;\n\tfor(int i=1;i<=3;i++)for(int j=a[i];j<=b[i];j++)end.f[i][j]=cnt++;\n\t/*for(int i=0;i<5;i++)\n\t{\n\t\tfor(int j=a[i];j<=b[i];j++)cout << end.f[i][j] << ' ';\n\t\tcout << endl;\n\t}*/\n\tbfs(end);\n\twhile(1)\n\t{\n\t\tState st;\n\t\tused.clear();\n\t\tans = 21;\n\t\tfor(int i=0;i<5;i++)for(int j=0;j<5;j++)st.f[i][j]=-1;\n\t\tfor(int i=0;i<5;i++)\n\t\t{\n\t\t\tfor(int j=a[i];j<=b[i];j++)\n\t\t\t{\n\t\t\t\tcin >> st.f[i][j];\n\t\t\t\tif(st.f[i][j]==-1)goto end;\n\t\t\t}\n\t\t}\n\t\tst.t=0;\n\t\tbfs2(st);\n\t\tif(ans>20)printf(\"NA\\n\");\n\t\telse printf(\"%d\\n\",ans);\n\t}\n\tend:;\n\treturn 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include <iostream>\n#include <string>\n#include <vector>\n#include <queue>\n#include <map>\nusing namespace std;\n\nstring s = \"0123456789AB\";\nstring goal = \"0123456789AB0\";\n\nvector<vector<int>> adj = {\n    {2},\n    {2,5},\n    {0,1,3,6},\n    {2,7},\n    {5},\n    {1,4,6,9},\n    {2,5,7,10},\n    {3,6,8,11},\n    {7},\n    {5,10},\n    {6,9,11,12},\n    {7,10},\n    {10}\n};\n\nint solve(string stat) {\n    map<string, int> dist;\n    dist[stat] = 0;\n    queue<string> q;\n    q.push(stat);\n    while ( ! q.empty()) {\n        string s = q.front();\n        q.pop();\n        for (int i=0; i<13; ++i) {\n            if (s[i] != '0') continue;\n            for (int j=0; j<(int)adj[i].size(); ++j) {\n                string next = s;\n                next[i] = s[adj[i][j]];\n                next[adj[i][j]] = s[i];\n                int diff = 0;\n                for (int k=0; k<13; ++k) {\n                    diff += next[k] != goal[k];\n                }\n                if ( ! diff) {\n                    return dist[s] + 1;\n                }\n                if (dist.find(next) == dist.end() && dist[s] + 1 + diff <= 20) {\n                    q.push(next);\n                    dist[next] = dist[s] + 1;\n                }\n            }\n        }\n    }\n    return 21;\n}\n\nint main() {\n    while (1) {\n        string stat = \"\";\n        int k;\n        for (int i=0; i<13; ++i) {\n            if (cin >> k && !~k) return 0;\n            stat += s[k];\n        }\n        int ans = solve(stat);\n        if (ans <= 20) {\n            cout << ans << endl;\n            continue;\n        }\n        cout << \"NA\" << endl;\n    }\n    return 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include <iostream>\n#include <queue>\n#include <set>\nusing namespace std;\ntypedef long long ll;\n\nll mov[13][4] = {\n\t{2,-1,-1,-1},\n\t{2,5,-1,-1},\n\t{0,1,3,6},\n\t{2,7,-1,-1},\n\t{5,-1,-1,-1},\n\t{1,4,6,9},\n\t{2,5,7,10},\n\t{3,6,8,11},\n\t{7,-1,-1,-1},\n\t{5,10,-1,-1},\n\t{6,9,11,12},\n\t{7,10,-1,-1},\n\t{10,-1,-1,-1},\n};\n\nll sw(ll l, int i, int j) {\n\tint a, b;\n\ta = (l >> (4 * i)) & 0xfL;\n\tb = (l >> (4 * j)) & 0xfL;\n\n\tl &= ~(0xfL << (4*i));\n\tl &= ~(0xfL << (4*j));\n\n\tl |= (ll)b << (4 * i);\n\tl |= (ll)a << (4 * j);\n\n\treturn l;\n}\n\nint main() {\n\twhile(1) {\n\t\tll in = 0;\n\t\tfor(int i = 0; i < 13; i++) {\n\t\t\tint tmpin;\n\t\t\tcin >> tmpin;\n\t\t\tif(tmpin < 0)\n\t\t\t\treturn 0;\n\t\t\tin |= ((ll)tmpin << (4*i));\n\t\t}\n\n\t\tqueue<ll> q;\n\t\tset<ll> s;\n\t\tq.push(in);\n\t\ts.insert(in);\n\t\tint ans = -1;\n\t\t// debug\n\t\tint failcount = 0;\n\t\tfor(int i = 0; i <= 20; i++) {\n\t\t\tqueue<ll> next;\n\t\t\twhile(!q.empty()) {\n\t\t\t\tll l = q.front(); q.pop();\n\t\t\t\tif(l == 0xba9876543210) {\n\t\t\t\t\tans = i;\n\t\t\t\t\tgoto OUTPUT_ANSWER;\n\t\t\t\t}\n\t\t\t\telse {\n\t\t\t\t\tint cnt = 0;\n\t\t\t\t\tfor(int j = 0; j < 13; j++) {\n\t\t\t\t\t\tll t = 0xba9876543210;\n\t\t\t\t\t\tif(((l >> 4*j) & 0xfL) != ((t >> 4*j) & 0xfL)) {\n\t\t\t\t\t\t\tcnt++;\n\t\t\t\t\t\t}\n\t\t\t\t\t}\n\t\t\t\t\tif(cnt > 20 - i + 1)\n\t\t\t\t\t\tcontinue;\n\t\t\t\t}\n\n\t\t\t\tfor(int j = 0; j < 13; j++) {\n\t\t\t\t\tif(((l >> (4*j)) & 0xfL) == 0) {\n\t\t\t\t\t\tfor(int k = 0; k < 4; k++) {\n\t\t\t\t\t\t\tll p;\n\t\t\t\t\t\t\tif(mov[j][k] < 0)\n\t\t\t\t\t\t\t\tbreak;\n\t\t\t\t\t\t\tp = sw(l, j, mov[j][k]);\n\t\t\t\t\t\t\tif(s.find(p) == s.end()) {\n\t\t\t\t\t\t\t\ts.insert(p);\n\t\t\t\t\t\t\t\tnext.push(p);\n\t\t\t\t\t\t\t}\n\t\t\t\t\t\t\telse {\n\t\t\t\t\t\t\t\tfailcount++;\n\t\t\t\t\t\t\t}\n\t\t\t\t\t\t}\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t}\n\t\t\tq = next;\n\t\t}\n\nOUTPUT_ANSWER:;\n\t\tif(ans < 0)\n\t\t\tcout << \"NA\" << endl;\n\t\telse\n\t\t\tcout << ans << endl;\n//\t\tcout << failcount << endl;\n\t}\n}"
  },
  {
    "language": "C++",
    "code": "#include<cstdio>\n#include<algorithm>\n#include<iostream>\n#include<queue>\n#include<functional>\n#include<map>\n#include<vector>\nusing namespace std;\nclass P{\n\tpublic:\n\tint state[15];\n\tint cnt;\n\tint p1;\n\tint p2;\n\tP(){}\n\tP(int a[15],int cnt,int p1,int p2):cnt(cnt),p1(p1),p2(p2){\n\t\tfor(int i = 0; i < 15; i++){\n\t\t\tstate[i] = a[i];\n\t\t}\n\t}\n};\nint rules[13][6]={\n\t{1,2},{2,2,5},{4,0,1,3,6},{2,2,7},{1,5},\n\t{4,1,4,6,9},{4,2,5,7,10},{4,3,6,8,11},{1,7},{2,5,10},\n\t{4,6,9,11,12},{2,7,10},{1,10}\n};\n\nmap< string , int >memo;\n\nstring getIndex(int *a){\n\tstring tmp=\"\";\n\tfor(int i = 0; i < 13; i++){\n\t\ttmp += (a[i]+48);\n\t}\n\treturn tmp;\n}\n\nvoid bfs(){\n\tint F[] = {0,1,2,3,4,5,6,7,8,9,10,11,0};\n\tqueue < P > Q;\n\tQ.push(P(F,1,0,12));\n\twhile( true ){\n\t\tif(Q.size() == 0)break;\n\t\tP p = Q.front();Q.pop();\n\t\tif(p.cnt > 21)break;\n\t\tstring index = getIndex(p.state);\n\t\tif( memo[index] )continue;\n\t\tmemo[index] = p.cnt;\n        for(int j = 0; j < rules[p.p1][0]; j++){\n            if(p.state[rules[p.p1][j+1]] == 0)continue;\n            swap(p.state[p.p1],p.state[rules[p.p1][j+1]]);\n            Q.push(P(p.state,p.cnt+1,p.state[p.p1],p.p2));\n            swap(p.state[p.p1],p.state[rules[p.p1][j+1]]);\n        }\n        for(int j = 0; j < rules[p.p2][0]; j++){\n            if(p.state[rules[p.p2][j+1]] == 0)continue;\n            swap(p.state[p.p2],p.state[rules[p.p2][j+1]]);\n            Q.push(P(p.state,p.cnt+1,p.p1,p.state[p.p2]));\n            swap(p.state[p.p2],p.state[rules[p.p2][j+1]]);\n        }\n\t}\n\treturn ;\n}\nint main(){\n\tbfs();\n\tint input[15];\n\twhile(true){\n\t    scanf(\"%d\",&input[0]);\n\t    if(input[0] == -1)break;\n\t\tfor(int i = 1; i < 13; i++){\n\t\t\tscanf(\"%d\",&input[i]);\n\t\t}\n\t\tstring index = getIndex(input);\n\t\tif( memo[index] )printf(\"%d\\n\",memo[index]-1);\n\t\telse puts(\"NA\");\n\t}\n\treturn 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include<iostream>\n#include<algorithm>\n#include<iomanip>\n\n#define N 7\n#define INV (-1)\n\n#define UP 0\n#define RIGHT 1\n#define DOWN 2\n#define LEFT 3\n#define DIRMAX 4\n\n#define NA 20\n\nusing namespace std;\n\nstruct State\n{\n  int map[N][N];\n  State(){\n    //fill(&map[0][0],&map[N-1][N-1],-1);\n  }\n  State(int tmap[][N]){\n    for(int i = 0; i < N; ++i){\n      for(int j = 0; j < N; ++j){\n\tmap[i][j] = tmap[i][j];\n      }\n    }\n  }\n  bool move(int which, int dir){\n    // which = 0, upper,left\n    // which != 0, bottom,right\n    for(int i = (which==0?0:N-2); which==0?(i<N-1):(i>=1); which==0?++i:--i){\n      for(int j = (which==0?0:N-2); which==0?(j<N-1):(j>=1); which==0?++j:--j){\n\tif( map[i][j] == 0 ){\n\t  switch(dir){\n\t  case UP:   if( map[i-1][j] > 0 ){swap( map[i][j], map[i-1][j] );return true;}break;\n\t  case RIGHT:if( map[i][j+1] > 0 ){swap( map[i][j], map[i][j+1] );return true;}break;\n\t  case DOWN: if( map[i+1][j] > 0 ){swap( map[i][j], map[i+1][j] );return true;}break;\n\t  case LEFT: if( map[i][j-1] > 0 ){swap( map[i][j], map[i][j-1] );return true;}break;\n\t  }\n\t  return false;\n\t}\n      }\n    }\n  }\n  int getHeuristic()const{\n    const int ti[] = {0,2,2,2,3,3,3,3,3,4,4,4};\n    const int tj[] = {0,2,3,4,1,2,3,4,5,2,3,4};\n    int ret = 0;\n    int max1=0,max2=0;\n    for(int i = 1; i < N-1; ++i){\n      for(int j = 1; j < N-1; ++j){\n\tif( map[i][j] > 0 ){\n\t  int x = abs(i-ti[map[i][j]] )+ abs(j-tj[map[i][j]]);\n\t  ret += x;\n\t  if( max1 < x ){\n\t    max2 = max1;\n\t    max1 = x;\n\t  }\n\t}\n      }\n    }\n    return ret;\n  }\n  bool isComplete()const{\n    return getHeuristic() == 0;\n  }\n};\n\nint IterativeDeepning(int depth, const State &now, int &ans)\n{\n\n  if( now.isComplete() ){\n    ans = min( ans , depth );\n    return ans;\n  }\n  int least = depth+now.getHeuristic();\n  if( least > ans ){\n    return NA;\n  }\n  // ans = min( ans, least );\n  for(int w = 0; w < 2; ++w){\n    for(int dir = 0; dir < DIRMAX; ++dir){\n      State next = now;\n      if( next.move( w, dir ) ){\n\tans = min( ans, IterativeDeepning( depth + 1, next, ans ) );\n      }\n    }\n  }\n  return NA;\n}\n\nint main()\n{\n  while(true){\n    int map[N][N];\n    int ans;\n    fill(&map[0][0],&map[N-1][N],-1);\n    \n    const int imax[] = {1,3,5,3,1};\n    const int dj[] = {2,1,0,1,2};\n    for(int i = 0; i < 5; ++i){\n      for(int j = 0; j < imax[i]; ++j){\n\tint t;\n\tcin >> t;\n\tif( t < 0 ) return 0;\n\tmap[i+1][j+dj[i]+1]=t;\n      }\n    }\n\n    /*\n    for(int i = 0; i < N; ++i){\n      for(int j = 0; j < N; ++j){\n\tcout << setw(3) << map[i][j] << ' ';\n      }\n      cout << endl;\n    }\n    cout << endl;\n    */\n\n    ans = NA+1;\n    IterativeDeepning( 0, State(map), ans );\n    if( ans > NA ){\n      cout << \"NA\" << endl;\n    }else{\n      cout << ans << endl;\n    }\n      \n  }\n  return 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include <iostream>\n#include <algorithm>\n#include <vector>\n#include <queue>\n#include <map>\nusing namespace std;\n#define rep(i,n) for(int i=0;i<n;i++)\nclass NODE{\npublic:\n\tvector<int> data;\n\tint depth;\n\tint e[2];\n\tNODE(int a[13],int d,int E[2]){\n\t\tdata.resize(13);\n\t\trep(i,13)data[i] = a[i];\n\t\tdepth = d;\n\t\trep(i,2)e[i] = E[i];\n\t}\n\tNODE(){\n\t\tdepth = 0;\n\t\tdata.resize(13);\n\t}\n};\n\nint di[13][10] = {\n\t{2,-1},\n\t{2,5,-1},\n\t{0,1,3,6,-1},\n\t{2,7,-1},\n\t{5,-1},\n\t{1,4,6,9,-1},\n\t{2,5,7,10,-1},\n\t{3,6,7,11,-1},\n\t{7},\n\t{5,10,-1},\n\t{6,9,11,12,-1},\n\t{7,10,-1},\n\t{10,-1}\n};\n\nint main(){\n\twhile(1){\n\t\tint ret = 21;\n\t\tNODE fst; int cnt = 0;\n\t\trep(i,13){\n\t\t\tif(cin >>fst.data[i] , fst.data[i] != -1){\n\t\t\t\tif(fst.data[i] == 0){\n\t\t\t\t\tfst.e[cnt] = i;\n\t\t\t\t\tcnt++;\n\t\t\t\t}\n\t\t\t}else{\n\t\t\t\treturn 0;\n\t\t\t}\n\t\t}\n\t\tmap< vector<int> , int > done[2];\n\t\t\n\t\trep(x,2){\n\t\t\tqueue<NODE> Q;\n\t\t\tif(x==0){\n\t\t\t\tQ.push(fst);\n\t\t\t}else{\n\t\t\t\tNODE a;\n\t\t\t\trep(i,11)a.data[i+1] = i+1;\n\t\t\t\ta.e[0] = 0;\n\t\t\t\ta.e[1] = 12;\n\t\t\t\tQ.push(a);\n\t\t\t}\n\t\t\tdone[x][Q.front().data] = 0;\n\t\t\twhile(Q.size()){\n\t\t\t\tNODE q = Q.front(); Q.pop();\n\t\t\t\tif(x == 1){\n\t\t\t\t\tif( done[0].find(q.data) != done[0].end() ){\n\t\t\t\t\t\tret = q.depth + done[0][q.data] ;\n\t\t\t\t\t\tbreak;\n\t\t\t\t\t}\n\t\t\t\t}else{\n\t\t\t\t\tif( q.data[0] == 0 && q.data[1] == 1 && q.data[2] == 2 && q.data[3] == 3 && q.data[4] == 4 && q.data[5] == 5 && q.data[6] == 6 && q.data[7] == 7 &&\n\t\t\t\t\t\t\tq.data[8] == 8 && q.data[9] == 9 && q.data[10]==10 && q.data[11]==11 && q.data[12]==0\n\t\t\t\t\t){\n\t\t\t\t\t\tret = q.depth;\n\t\t\t\t\t\tbreak;\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t\tif(q.depth >= 10)continue;\n\n\t\t\t\trep(o,2){\n\t\t\t\t\tfor(int i=0;di[q.e[o]][i] != -1;i++){\n\t\t\t\t\t\tNODE next = q;\n\t\t\t\t\t\tnext.e[o] = next.data[di[q.e[o]][i]];\n\t\t\t\t\t\tswap(next.data[q.e[o]] , next.data[di[q.e[o]][i]]);\n\t\t\t\t\t\tnext.depth = q.depth + 1;\n\t\t\t\t\t\t\n\t\t\t\t\t\tif( done[x].find(next.data) == done[x].end() ){\n\t\t\t\t\t\t\tdone[x][next.data] = next.depth;\n\t\t\t\t\t\t\tQ.push(next);\n\t\t\t\t\t\t}\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t\tif(ret > 20){\n\t\t\tcout << \"NA\" << endl;\n\t\t}else{\n\t\t\tcout << ret << endl;\n\t\t}\n\t}\n}"
  },
  {
    "language": "C++",
    "code": "#include <iostream>\n#include <cstdio>\n#include <queue>\n#include <set>\n#include <map>\n#include <cmath>\nusing namespace std;\ntypedef unsigned long long ull;\n#define pb push_back\null B = 1000000007ull;\nint a[5]={2,1,0,1,2};\nint b[5]={2,3,4,3,2};\nint dx[5]={0,1,0,-1};\nint dy[5]={1,0,-1,0};\nint px[13]={0,1,1,1,2,2,2,2,2,3,3,3,0};\nint py[13]={0,1,2,3,0,1,2,3,4,0,1,2,0};\n\nstruct State\n{\n\tint f[5][5];\n\tint t;\n};\nvector<int> hash(State x)\n{\n\tvector<int> res;\n\tfor(int i=0;i<5;i++)\n\t{\n\t\tfor(int j=a[i];j<=b[i];j++)\n\t\t{\n\t\t\tres.pb(x.f[i][j]);\n\t\t}\n\t}\n\treturn res;\n}\nmap<vector<int>,int> mp;\nset<vector<int> > used;\nbool check(State x)\n{\n\tint cnt=1;\n\tfor(int i=1;i<=3;i++)\n\t{\n\t\tfor(int j=a[i];j<=b[i];j++)\n\t\t{\n\t\t\tif(x.f[i][j]!=cnt)return false;\n\t\t\tcnt++;\n\t\t}\n\t}\n\treturn true;\n}\nbool cc(State x)\n{\n\tint res = 0;\n\tfor(int i=0;i<5;i++)\n\t{\n\t\tfor(int j=a[i];j<=b[i];j++)\n\t\t{\n\t\t\tif(x.f[i][j])\n\t\t\t{\n\t\t\t\tint k = x.f[i][j];\n\t\t\t\tres += (abs(px[k]-i)+abs(py[k]-j));\n\t\t\t}\n\t\t}\n\t}\n\treturn (res>20-x.t);\n}\nint ans = 21;\nvoid bfs(State st)\n{\n\tqueue<State> q;\n\tmp[hash(st)]=0;\n\tq.push(st);\n\twhile(!q.empty())\n\t{\n\t\tState A = q.front();\n\t\tq.pop();\n\t\t//cout << \"koko\" << endl;\n\t\tfor(int i=0;i<5;i++)\n\t\t{\n\t\t\tfor(int j=0;j<5;j++)\n\t\t\t{\n\t\t\t\tif(j<a[i]||b[i]<j)continue;\n\t\t\t\tif(A.f[i][j]==0)continue;\n\t\t\t\tfor(int k=0;k<4;k++)\n\t\t\t\t{\n\t\t\t\t\tint nx=i+dx[k],ny=j+dy[k];\n\t\t\t\t\tif(nx<0||nx>=5||ny<0||ny>=5)continue;\n\t\t\t\t\tif(ny<a[nx]||b[nx]<ny)continue;\n\t\t\t\t\tif(A.f[nx][ny]!=0)continue;\n\t\t\t\t\tState B = A;\n\t\t\t\t\tswap(B.f[nx][ny],B.f[i][j]);\n\t\t\t\t\tB.t++;\n\t\t\t\t\t//cout << \"a\" << endl;\n\t\t\t\t\tif(B.t>8)continue;\n\t\t\t\t\tvector<int> hb = hash(B);\n\t\t\t\t\tif(mp.find(hb)!=mp.end())continue;\n\t\t\t\t\t//cout << hb << endl;\n\t\t\t\t\tmp[hb]=B.t;\n\t\t\t\t\tq.push(B);\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t}\n\t//cout << \"owari\" << endl;\n}\nvoid bfs2(State st)\n{\n\tqueue<State> q;\n\tif(check(st)){ans=0;return;}\n\tq.push(st);\n\twhile(!q.empty())\n\t{\n\t\tState A = q.front();\n\t\tq.pop();\n\t\tvector<int> ha=hash(A); \n\t\tif(mp.find(hash(A))!=mp.end()){ans = min(ans,A.t+mp[ha]);continue;}\n\t\tfor(int i=0;i<5;i++)\n\t\t{\n\t\t\tfor(int j=0;j<5;j++)\n\t\t\t{\n\t\t\t\tif(j<a[i]||b[i]<j)continue;\n\t\t\t\tif(A.f[i][j]==0)continue;\n\t\t\t\tfor(int k=0;k<4;k++)\n\t\t\t\t{\n\t\t\t\t\tint nx=i+dx[k],ny=j+dy[k];\n\t\t\t\t\tif(nx<0||nx>=5||ny<0||ny>=5)continue;\n\t\t\t\t\tif(ny<a[nx]||b[nx]<ny)continue;\n\t\t\t\t\tif(A.f[nx][ny]!=0)continue;\n\t\t\t\t\tState B = A;\n\t\t\t\t\tswap(B.f[nx][ny],B.f[i][j]);\n\t\t\t\t\tB.t++;\n\t\t\t\t\tif(cc(B))continue;\n\t\t\t\t\tvector<int> hb = hash(B);\n\t\t\t\t\tif(used.find(hb)!=used.end())continue;\n\t\t\t\t\tused.insert(hb);\n\t\t\t\t\tq.push(B);\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t}\n}\nint main()\n{\n\tState end;\n\tint cnt=1;\n\tend.t=0;\n\tfor(int i=0;i<5;i++)for(int j=0;j<5;j++)end.f[i][j]=-1;\n\tend.f[0][2]=0;\n\tend.f[4][2]=0;\n\tfor(int i=1;i<=3;i++)for(int j=a[i];j<=b[i];j++)end.f[i][j]=cnt++;\n\t/*for(int i=0;i<5;i++)\n\t{\n\t\tfor(int j=a[i];j<=b[i];j++)cout << end.f[i][j] << ' ';\n\t\tcout << endl;\n\t}*/\n\tbfs(end);\n\twhile(1)\n\t{\n\t\tState st;\n\t\tused.clear();\n\t\tans = 21;\n\t\tfor(int i=0;i<5;i++)for(int j=0;j<5;j++)st.f[i][j]=-1;\n\t\tfor(int i=0;i<5;i++)\n\t\t{\n\t\t\tfor(int j=a[i];j<=b[i];j++)\n\t\t\t{\n\t\t\t\tcin >> st.f[i][j];\n\t\t\t\tif(st.f[i][j]==-1)goto end;\n\t\t\t}\n\t\t}\n\t\tst.t=0;\n\t\tbfs2(st);\n\t\tif(ans>20)printf(\"NA\\n\");\n\t\telse printf(\"%d\\n\",ans);\n\t}\n\tend:;\n\treturn 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include <iostream>\n#include <set>\n#include <queue>\n\nusing namespace std;\n\nclass State{\npublic:\n   string s;\n   int cost;\n};\n\nint input;\nset<string> visited;\n\nvoid swap(string &str, int a, int b){\n   char tmp = str[a];\n   str[a] = str[b];\n   str[b] = tmp;\n}\n\nint bfs(string str){\n   State u, v;\n   u.s = str;\n   u.cost = 0;\n   queue<State> Q;\n   Q.push(u);\n   while(!Q.empty()){\n      u = Q.front(); Q.pop();\n      //cout << u.s << ' ' << u.cost << endl;\n      if(u.s == \"ABCDEFGHIJKLA\") return u.cost;\n      if(u.s == \"ALKJIHGFEDCBA\") break;\n      if(u.cost >= 20) continue;\n      for(int i=0;i<13;i++){\n         if(u.s[i] == 'A'){\n            v.cost = u.cost + 1;\n            switch(i){\n               case 0:\n                  v.s = u.s;\n                  swap(v.s, 0, 2);\n                  if(visited.find(v.s) == visited.end()){\n                     visited.insert(v.s);\n                     Q.push(v);\n                  }\n                  break;\n               case 1:\n                  v.s = u.s;\n                  swap(v.s, i, 2);\n                  if(visited.find(v.s) == visited.end()){\n                     visited.insert(v.s);\n                     Q.push(v);\n                  }\n                  v.s = u.s;\n                  swap(v.s, i, 5);\n                  if(visited.find(v.s) == visited.end()){\n                     visited.insert(v.s);\n                     Q.push(v);\n                  }\n                  break;\n               case 3:\n                  v.s = u.s;\n                  swap(v.s, i, 2);\n                  if(visited.find(v.s) == visited.end()){\n                     visited.insert(v.s);\n                     Q.push(v);\n                  }\n                  v.s = u.s;\n                  swap(v.s, i, 7);\n                  if(visited.find(v.s) == visited.end()){\n                     visited.insert(v.s);\n                     Q.push(v);\n                  }\n                  break;\n               case 4:\n                  v.s = u.s;\n                  swap(v.s, i, 5);\n                  if(visited.find(v.s) == visited.end()){\n                     visited.insert(v.s);\n                     Q.push(v);\n                  }\n                  break;\n               case 8:\n                  v.s = u.s;\n                  swap(v.s, i, 7);\n                  if(visited.find(v.s) == visited.end()){\n                     visited.insert(v.s);\n                     Q.push(v);\n                  }\n                  break;\n               case 9:\n                  v.s = u.s;\n                  swap(v.s, i, 5);\n                  if(visited.find(v.s) == visited.end()){\n                     visited.insert(v.s);\n                     Q.push(v);\n                  }\n                  v.s = u.s;\n                  swap(v.s, i, 10);\n                  if(visited.find(v.s) == visited.end()){\n                     visited.insert(v.s);\n                     Q.push(v);\n                  }\n\n                  break;\n               case 11:\n                  v.s = u.s;\n                  swap(v.s, i, 7);\n                  if(visited.find(v.s) == visited.end()){\n                     visited.insert(v.s);\n                     Q.push(v);\n                  }\n                  v.s = u.s;\n                  swap(v.s, i, 10);\n                  if(visited.find(v.s) == visited.end()){\n                     visited.insert(v.s);\n                     Q.push(v);\n                  }\n                  break;\n               case 12:\n                  v.s = u.s;\n                  swap(v.s, i, 10);\n                  if(visited.find(v.s) == visited.end()){\n                     visited.insert(v.s);\n                     Q.push(v);\n                  }\n                  break;\n               default:\n                  int ue = 4;\n                  int sita = 4;\n                  if(i == 2) ue = 2;\n                  if(i == 10) sita = 2;\n                  v.s = u.s;\n                  swap(v.s, i, i-ue);\n                  if(visited.find(v.s) == visited.end()){\n                     visited.insert(v.s);\n                     Q.push(v);\n                  }\n                  v.s = u.s;\n                  swap(v.s, i, i+sita);\n                  if(visited.find(v.s) == visited.end()){\n                     visited.insert(v.s);\n                     Q.push(v);\n                  }\n                  v.s = u.s;\n                  swap(v.s, i, i+1);\n                  if(visited.find(v.s) == visited.end()){\n                     visited.insert(v.s);\n                     Q.push(v);\n                  }\n                  v.s = u.s;\n                  swap(v.s, i, i-1);\n                  if(visited.find(v.s) == visited.end()){\n                     visited.insert(v.s);\n                     Q.push(v);\n                  }\n                  break;\n            }\n         }\n      }\n   }\n   return -1;\n}\n\nmain(){\n   while(cin >> input){\n      if(input == -1) break;\n      string str = \"\";\n      str += ((char)input + 'A');\n      for(int i=1;i<13;i++){\n         cin >> input;\n         str += ((char)input + 'A');\n      }\n      int ans = bfs(str);\n      if(ans == -1){\n         cout << \"NA\" << endl;\n      }else{\n         cout << ans << endl;\n      }\n   }\n   return 0;\n\n}"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\nusing namespace std;\nconst int pos_x[] = {0, 1, 1, 1, 2, 2, 2, 2, 2, 3, 3, 3, 4};\nconst int pos_y[] = {2, 1, 2, 3, 0, 1, 2, 3, 4, 1, 2, 3, 2};\nconst int table[][5] = {\n\t{2, -1},\n\t{2, 5, -1},\n\t{0, 1, 3, 6, -1},\n\t{2, 7, -1},\n\t{5, -1},\n\t{1, 4, 6, 9, -1},\n\t{2, 5, 7, 10, -1},\n\t{3, 6, 8, 11, -1},\n\t{7, -1},\n\t{5, 10, -1},\n\t{6, 9, 11, 12, -1},\n\t{7, 10, -1},\n\t{10, -1},\n};\n\nstruct Puzzle {\n\tvector<int> val;\n\tPuzzle(): val(13){}\n\tint score(){\n\t\tint res = 0;\n\t\tfor (int i = 0; i < 13; i++){\n\t\t\tif (!val[i]) continue;\n\t\t\tint v = val[i];\n\t\t\tres += abs(pos_x[v] - pos_x[i]);\n\t\t\tres += abs(pos_y[v] - pos_y[i]);\n\t\t}\n\t\treturn res;\n\t}\n\tvoid show(){\n\t\tfor (int i = 0; i < 13; i++){\n\t\t\tprintf(\"%d \", val[i]);\n\t\t\tif (i == 0 || i == 3 || i == 8 || i == 11 || i == 12){\n\t\t\t\tputs(\"\");\n\t\t\t}\n\t\t}\n\t}\n};\n\n/*inline bool check(Puzzle &p)\n{\n\tfor (int i = 1; i <= 11; i++){\n\t\tif (p.val[i] != i) return false;\n\t}\n\treturn true;\n}*/\n\nset<vector<int> > st;\n\nbool search(int d, Puzzle &p)\n{\n\tif (p.score() == 0) return true;\n\tif (d == 0) return false;\n\tif (st.count(p.val)) return false;\n\tst.insert(p.val);\n\t\n\tfor (int i = 0; i < 13; i++){\n\t\tif (p.val[i]) continue;\n\t\tfor (const int *to = &table[i][0]; ~(*to); to++){\n\t\t\tswap(p.val[i], p.val[*to]);\n\t\t\t//printf(\"%d %d\\n\", i, *to);\n\t\t\t//printf(\"%d\\n\", p.score());\n\t\t\tif (d - 1 - p.score() >= 0){\n\t\t\t\tif (search(d - 1, p)) return true;\n\t\t\t}\n\t\t\tswap(p.val[i], p.val[*to]);\n\t\t}\n\t}\n\treturn false;\n}\n\nvoid solve(Puzzle &p)\n{\n\tfor (int d = 0; d <= 20; d++){\n\t\tst.clear();\n\t\tif (search(d, p)){\n\t\t\tprintf(\"%d\\n\", d);\n\t\t\treturn;\n\t\t}\n\t}\n\tputs(\"NA\");\n}\n\nint main()\n{\t\n\tPuzzle p;\n\twhile (true){\n\t\tfor (int i = 0; i < 13; i++){\n\t\t\tscanf(\"%d\", &p.val[i]);\n\t\t\tif (p.val[i] == -1) return 0;\n\t\t}\n\t\tsolve(p);\n\t}\n}"
  },
  {
    "language": "C++",
    "code": "#include <iostream>\n#include <cstdio>\n#include <vector>\n#include <map>\n#include <string>\n#include <queue>\n#include <algorithm>\nusing namespace std;\n\nconst int INF = 1e+8;\nconst int f1[25] = {\n\t-1,-1, 0,-1,-1,\n\t-1, 1, 2, 3,-1,\n\t 4, 5, 6, 7, 8,\n\t-1, 9,10,11,-1,\n\t-1,-1,12,-1,-1,\n};\nconst int f2[13] = {2,6,7,8,10,11,12,13,14,16,17,18,22};\nconst int dx[4] = { 0,-1,+1, 0};\nconst int dy[4] = {-1, 0, 0,+1};\n\n// パズル\nstruct Pazzle{\n\tvector<char> v;\n\tPazzle(){v = vector<char>(13); }\n\tvoid at(int i, int p){\n\t\tv[i] = p;\n\t}\n\t// 空白の位置を返す. (k は 0 or 1)\n\tint search(int k){\n\t\tint a = 0;\n\t\tfor(int i=0 ; i < 13 ; i++ ){\n\t\t\tif( v[i] == 0 ){\n\t\t\t\tif( k == 0 ){\n\t\t\t\t\treturn i;\n\t\t\t\t}else{\n\t\t\t\t\tif( a == 0 ) a++;\n\t\t\t\t\telse return i;\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t\treturn -1;\n\t}\n\tint to_g(){\n\t\tint res = 0;\n\t\tint a = 0;\n\t\tfor(int i=0 ; i < 13 ; i++ ){\n\t\t\tint x1 = f2[v[i]] % 5;\n\t\t\tint y1 = f2[v[i]] / 5;\n\t\t\tint x2 = i % 5;\n\t\t\tint y2 = i / 5;\n\t\t\tif( v[i] == 0 ){\n\t\t\t\tif( a == 0 ){\n\t\t\t\t\ta++;\n\t\t\t\t}else{\n\t\t\t\t\tx1 = f2[12] % 5;\n\t\t\t\t\ty1 = f2[12] / 5;\n\t\t\t\t} \n\t\t\t}\n\t\t\tres += abs(x1-x2) + abs(y1-y2);\n\t\t}\n\t\treturn res;\n\t}\n\t// 空白 k (0 or 1) を 方向 dir に動かす.\n\t// 動かせる時は true, 動かせなかったときは false を返す.\n\tbool move(int dir, int k){\n\t\tif( dir < 0 || 4 <= dir || k < 0 || 2 <= k ) return false;\n\t\tint pos1 = search(k);\n\t\tint x = f2[pos1] % 5;\n\t\tint y = f2[pos1] / 5;\n\t\tint mx = x + dx[dir];\n\t\tint my = y + dy[dir];\n\t\tif( mx < 0 || my < 0 || 5 <= mx || 5 <= my ) return false;\n\t\tint pos2 = f1[my*5+mx];\n\t\tif( pos2 == -1 ) return false;\n\t\tif( v[pos1] == v[pos2] ) return false;\n\t\tswap( v[pos1] , v[pos2] );\n\t\treturn true;\n\t}\n\t// 完成しているかどうか\n\tbool is_goal(){\n\t\tfor(int i=0 ; i < 12 ; i++ ){\n\t\t\tif( v[i] != i ) return false;\n\t\t}\n\t\treturn v[12] == 0;\n\t}\n\tvoid debug(){\n\t\tprintf(\"[debug]\\n\");\n\t\tfor(int y=0 ; y < 5 ; y++ ){\n\t\t\tfor(int x=0 ; x < 5 ; x++ ){\n\t\t\t\tif( f1[y*5+x] == -1 ){\n\t\t\t\t\tprintf(\"##\");\n\t\t\t\t}else{\n\t\t\t\t\tprintf(\"%2d\", (int)v[f1[y*5+x]] );\n\t\t\t\t}\n\t\t\t}\n\t\t\tprintf(\"\\n\");\n\t\t}\n\t\tprintf(\"\\n\");\n\t}\n};\n\n// (コスト,スタートからの距離,パズルの状態)\nstruct State{\n\tPazzle p;\n\tint cost, cnt;\n\tState(int cost_, int cnt_, const Pazzle& p_){\n\t\tcost = cost_; cnt = cnt_; p = p_;\n\t}\n};\nbool operator<(const State& a, const State& b){\n\treturn a.cost > b.cost;\n}\n\nint solve(Pazzle p){\n\t// (コスト,スタートからの距離,パズルの状態) を優先度つきキューへ\n\tpriority_queue<State> q;\n\tq.push( State(p.to_g(),0,p) );\n\t\n\tint res = 21;\n\tint foo=0;\n\twhile( !q.empty() ){\n\t\tfoo++;\n\t\tPazzle p = q.top().p; \n\t\tint cost = q.top().cost;\n\t\tint cnt = q.top().cnt;\n\t\tq.pop();\n\t\t\n\t\tif( 1e+5 < foo ) break;\n\t\tif( res < cnt ) continue;\n\t\t\n\t\tif( p.is_goal() ){\n\t\t\tres = min( res , cnt );\n\t\t\tcontinue;\n\t\t}\n\t\t\n\t\tfor(int k=0 ; k <= 1 ; k++ ){\n\t\t\tfor(int i=0 ; i < 4 ; i++ ){\n\t\t\t\tPazzle p_ = p;\n\t\t\t\tif( p_.move(i,k) ){\n\t\t\t\t\tq.push( State(p_.to_g()+cnt+1,cnt+1,p_) );\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t}\n\treturn res;\n}\n\nint main(){\n\tint p1;\n\twhile( cin >> p1 , p1 != -1 ){\n\t\tPazzle p;\n\t\tp.at(0,p1);\n\t\tfor(int i=1 ; i < 13 ; i++ ){\n\t\t\tcin >> p1;\n\t\t\tp.at(i,p1);\n\t\t}\n\t\tint ans = solve(p);\n\t\tif( ans == 21 ){\n\t\t\tcout << \"NA\" << endl;\n\t\t}else{\n\t\t\tcout << ans << endl;\n\t\t}\n\t}\n}"
  },
  {
    "language": "C++",
    "code": "#include<iostream>\n#include<algorithm>\n#include<climits>\nusing namespace std;\n\n#define N 5\n#define REP(i, n) for ( int i = 0; i < (int)n; i++ )\n#define LIMIT 20\n\nstatic const int T[12][2] = {{-1, -1}, {1, 1}, {1, 2}, {1, 3}, {2, 0}, {2, 1},\n\t\t\t     {2, 2}, {2, 3}, {2, 4}, {3, 1}, {3, 2}, {3, 3}};\nstatic const int g[N][N] = {{-1, -1, 0, -1, -1}, {-1, 1, 2, 3, -1},\n\t\t\t    {4, 5, 6, 7, 8}, {-1, 9, 10, 11, -1}, {-1, -1, 0, -1, -1}};\n\nclass Puzzle{\n    public:\n    int C[N][N], mdist; //manhatta distance\n    Puzzle(){}\n\n    bool swapAdj( int si, int sj, int ti, int tj ){\n\tif ( ti < 0 || tj < 0 || ti >= N || tj >= N ) return false;\n\tif ( C[ti][tj] <= 0 ) return false;\n\tswap(C[ti][tj], C[si][sj]);\n\tint tti = T[C[si][sj]][0];\n\tint ttj = T[C[si][sj]][1];\n\tmdist -= max(tti, ti)-min(tti, ti) + max(ttj, tj)-min(ttj, tj);\n\tmdist += max(tti, si)-min(tti, si) + max(ttj, sj)-min(ttj, sj);\n\treturn true;\n    }\n\n    bool isGoal(){\n\tREP(i, N) REP(j, N) if ( g[i][j] != C[i][j] ) return false;\n\treturn true;\n    }\n\n    int getMD(){ // get initial manhattan distance\n\tint sum = 0;\n\tint ti, tj;\n\tREP(i, 5) REP(j, 5){\n\t    if ( C[i][j] <= 0 ) continue;\n\t    ti = T[C[i][j]][0];\n\t    tj = T[C[i][j]][1];\n\t    sum += (max(ti, i)-min(ti, i) + max(tj, j) - min(tj, j));\n\t}\n\treturn sum;\n    }\n};\n\nint limit;\n\nbool dfs( int depth, Puzzle P ){\n    if ( P.isGoal() ) return true;\n    if ( depth + P.getMD() > limit ) return false;\n\n    static const int di[4] = {0, -1, 0, 1};\n    static const int dj[4] = {1, 0, -1, 0};\n\n    REP(i, N) REP(j, N){\n\tif ( P.C[i][j] != 0 ) continue;\n\tREP(r, 4){\n\t    Puzzle v = P;\n\t    if ( !v.swapAdj(i, j, i+di[r], j+dj[r]) ) continue;\n\t    if ( dfs( depth + 1, v ) ) return true;\n\t}\n    }\n\n    return false;\n}\n\nint idp(Puzzle source){\n    for ( limit = 0; limit <= LIMIT; limit++ ){\n\tsource.mdist = source.getMD();\n\tif ( dfs(0, source) ) return limit;\n    }\n    return INT_MAX;\n}\n\nint main(){\n    Puzzle P;\n    int top;\n\n    while(1){\n\tcin >> top;\n\tif ( top == -1 ) break;\n\tREP(j, N) P.C[0][j] = -1;\n\tP.C[0][2] = top;\n\tfor(int i = 1; i < N; i++) REP(j, N){\n\t    if ( (i == 1 || i == 3) && (j == 0 || j == 4 ) ) P.C[i][j] = -1;\n\t    else if ( i == 4 && j != 2 ) P.C[i][j] = -1;\n\t    else cin >> P.C[i][j];\n\t}\n\n\tint cost = idp(P);\n\tif ( cost == INT_MAX ) cout << \"NA\" << endl;\n\telse cout << cost << endl;\t\n    }\n\n    return 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include<bits/stdc++.h>\nusing namespace std;\n  \ntypedef long long int64;\nconst int INF = 1 << 30;\n  \nvector< int > edge[13];\nmap< string, int > memo;\n \nbool back(string str, int cnt){ //枝刈り大事だな\n  static int dist[] = { 0, 2, 1, 2, 4, 3, 2, 3, 4, 2, 1, 2, 0};\n  static int fuee[] = { 2, 0, 1, 2, 2, 1, 2, 3, 4, 2, 3, 4, 4};\n \n  int foo1 = 0, foo2 = 0;\n  for(int i = 0; i < 13; i++){\n    if(str[i] == '0') foo1 += dist[i];\n    if(str[i] == '1') foo2 += fuee[i];\n  }\n  return cnt + foo1 > 20 || cnt + foo2 > 20;\n}\n \n \nint bfs(string mas){\n \n  queue< string > que;\n  map< string , int > used;\n  que.push( mas );\n  memo[mas] = 0;\n  while(!que.empty()){\n \n    string p = que.front(); que.pop();\n    if(back( p, memo[p])) break;\n    if(p == \"0123456789AB0\") return memo[p];\n \n    for(int i = 0; i < 13; i++){\n      if(p[i] == '0') {\n        for(int j = 0; j < edge[i].size(); j++){\n          string next = p;\n          swap( next[i], next[edge[i][j]]);\n          if(memo.find(next) != memo.end()) continue;\n          que.push( next );\n          memo[next] = memo[p] + 1;\n        }\n      }\n    }\n  }\n  return -1;\n}\n \nint main(){\n  vector< int > mas(13);\n \n  edge[0].push_back(2);\n  edge[1].push_back(2); edge[1].push_back(4);\n  edge[2].push_back(0); edge[2].push_back(1); edge[2].push_back(3); edge[2].push_back(6);\n  edge[3].push_back(2); edge[3].push_back(7);\n  edge[4].push_back(5);\n  edge[5].push_back(1); edge[5].push_back(4); edge[5].push_back(6); edge[5].push_back(9);\n  edge[6].push_back(2); edge[6].push_back(5); edge[6].push_back(7); edge[6].push_back(10);\n  edge[7].push_back(3); edge[7].push_back(6); edge[7].push_back(8); edge[7].push_back(11);\n  edge[8].push_back(7);\n  edge[9].push_back(5); edge[9].push_back(10);\n  edge[10].push_back(6); edge[10].push_back(9); edge[10].push_back(11); edge[10].push_back(12);\n  edge[11].push_back(7); edge[11].push_back(10);\n  edge[12].push_back(10);\n \n  while(cin >> mas[0], mas[0] != -1){\n    for(int i = 1; i < 13; i++){\n      cin >> mas[i];\n    }\n \n    string start = \"\";\n    for(int i = 0; i < 13; i++){\n      if(mas[i] >= 10) start += (char)(mas[i] - 10 + 'A');\n      else start += mas[i] + '0';\n    }\n    int ret = bfs(start);\n    if(~ret) cout << ret << endl;\n    else cout << \"NA\" << endl;\n \n    memo.clear();\n  }\n}"
  },
  {
    "language": "C++",
    "code": "#include<iostream>\n#include<map>\n#include<vector>\n#include<queue>\n#include<algorithm>\n\nusing namespace std;\n\n#define rep(i, n) for (int i = 0; i < int(n); ++i)\n\nmap<vector<int>, int> mp;\n\nint main() {\n  vector<int> v;\n  v.push_back(0);\n  v.push_back(1);\n  v.push_back(2);\n  v.push_back(3);\n  v.push_back(4);\n  v.push_back(5);\n  v.push_back(6);\n  v.push_back(7);\n  v.push_back(8);\n  v.push_back(9);\n  v.push_back(10);\n  v.push_back(11);\n  v.push_back(0);\n  queue<pair<int, vector<int> > > que;\n  que.push(make_pair(0, v));\n  while (!que.empty()) {\n    pair<int, vector<int> > now = que.front();\n    que.pop();\n    if (mp.count(now.second) != 0) continue;\n    mp[now.second] = now.first;\n    if (now.first == 10) continue;\n    rep (i, 13) {\n      if (now.second[i] != 0) continue;\n      if (i == 0) {\n\tv = now.second;\n\tswap(v[0], v[2]);\n\tque.push(make_pair(now.first + 1, v));\n      }\n      if (i == 1) {\n\tv = now.second;\n\tswap(v[1], v[2]);\n\tque.push(make_pair(now.first + 1, v));\n\tv = now.second;\n\tswap(v[1], v[5]);\n\tque.push(make_pair(now.first + 1, v));\n      }\n      if (i == 2) {\n\tv = now.second;\n\tswap(v[2], v[0]);\n\tque.push(make_pair(now.first + 1, v));\n\tv = now.second;\n\tswap(v[2], v[1]);\n\tque.push(make_pair(now.first + 1, v));\n\tv = now.second;\n\tswap(v[2], v[3]);\n\tque.push(make_pair(now.first + 1, v));\n\tv = now.second;\n\tswap(v[2], v[6]);\n\tque.push(make_pair(now.first + 1, v));\n      }\n      if (i == 3) {\n\tv = now.second;\n\tswap(v[3], v[2]);\n\tque.push(make_pair(now.first + 1, v));\n\tv = now.second;\n\tswap(v[3], v[7]);\n\tque.push(make_pair(now.first + 1, v));\n      }\n      if (i == 4) {\n\tv = now.second;\n\tswap(v[4], v[5]);\n\tque.push(make_pair(now.first + 1, v));\n      }\n      if (i == 5) {\n\tv = now.second;\n\tswap(v[5], v[1]);\n\tque.push(make_pair(now.first + 1, v));\n\tv = now.second;\n\tswap(v[5], v[4]);\n\tque.push(make_pair(now.first + 1, v));\n\tv = now.second;\n\tswap(v[5], v[6]);\n\tque.push(make_pair(now.first + 1, v));\n\tv = now.second;\n\tswap(v[5], v[9]);\n\tque.push(make_pair(now.first + 1, v));\n      }\n      if (i == 6) {\n\tv = now.second;\n\tswap(v[6], v[2]);\n\tque.push(make_pair(now.first + 1, v));\n\tv = now.second;\n\tswap(v[6], v[5]);\n\tque.push(make_pair(now.first + 1, v));\n\tv = now.second;\n\tswap(v[6], v[7]);\n\tque.push(make_pair(now.first + 1, v));\n\tv = now.second;\n\tswap(v[6], v[10]);\n\tque.push(make_pair(now.first + 1, v));\n      }\n      if (i == 7) {\n\tv = now.second;\n\tswap(v[7], v[3]);\n\tque.push(make_pair(now.first + 1, v));\n\tv = now.second;\n\tswap(v[7], v[6]);\n\tque.push(make_pair(now.first + 1, v));\n\tv = now.second;\n\tswap(v[7], v[8]);\n\tque.push(make_pair(now.first + 1, v));\n\tv = now.second;\n\tswap(v[7], v[11]);\n\tque.push(make_pair(now.first + 1, v));\n      }\n      if (i == 8) {\n\tv = now.second;\n\tswap(v[8], v[7]);\n\tque.push(make_pair(now.first + 1, v));\n      }\n      if (i == 9) {\n\tv = now.second;\n\tswap(v[9], v[5]);\n\tque.push(make_pair(now.first + 1, v));\n\tv = now.second;\n\tswap(v[9], v[10]);\n\tque.push(make_pair(now.first + 1, v));\n      }\n      if (i == 10) {\n\tv = now.second;\n\tswap(v[10], v[6]);\n\tque.push(make_pair(now.first + 1, v));\n\tv = now.second;\n\tswap(v[10], v[9]);\n\tque.push(make_pair(now.first + 1, v));\n\tv = now.second;\n\tswap(v[10], v[11]);\n\tque.push(make_pair(now.first + 1, v));\n\tv = now.second;\n\tswap(v[10], v[12]);\n\tque.push(make_pair(now.first + 1, v));\n      }\n      if (i == 11) {\n\tv = now.second;\n\tswap(v[11], v[7]);\n\tque.push(make_pair(now.first + 1, v));\n\tv = now.second;\n\tswap(v[11], v[10]);\n\tque.push(make_pair(now.first + 1, v));\n      }\n      if (i == 12) {\n\tv = now.second;\n\tswap(v[12], v[10]);\n\tque.push(make_pair(now.first + 1, v));\n      }\n    }\n  }\n  vector<int> p(13);\n  for (;;) {\n    cin >> p[0];\n    if (p[0] == -1) break;\n    rep (i, 12) cin >> p[i + 1];\n    while (!que.empty()) que.pop();\n    map<vector<int>, int> m;\n    que.push(make_pair(0, p));\n    bool find = false;\n    while (!que.empty()) {\n      pair<int, vector<int> > now = que.front();\n      que.pop();\n      if (mp.count(now.second) != 0) {\n\tcout << now.first + mp[now.second] << endl;\n\tfind = true;\n\tbreak;\n      }\n      if (m.count(now.second) != 0) continue;\n      m[now.second] = now.first;\n      if (now.first == 10) continue;\n      rep (i, 13) {\n\tif (now.second[i] != 0) continue;\n\tif (i == 0) {\n\t  v = now.second;\n\t  swap(v[0], v[2]);\n\t  que.push(make_pair(now.first + 1, v));\n\t}\n\tif (i == 1) {\n\t  v = now.second;\n\t  swap(v[1], v[2]);\n\t  que.push(make_pair(now.first + 1, v));\n\t  v = now.second;\n\t  swap(v[1], v[5]);\n\t  que.push(make_pair(now.first + 1, v));\n\t}\n\tif (i == 2) {\n\t  v = now.second;\n\t  swap(v[2], v[0]);\n\t  que.push(make_pair(now.first + 1, v));\n\t  v = now.second;\n\t  swap(v[2], v[1]);\n\t  que.push(make_pair(now.first + 1, v));\n\t  v = now.second;\n\t  swap(v[2], v[3]);\n\t  que.push(make_pair(now.first + 1, v));\n\t  v = now.second;\n\t  swap(v[2], v[6]);\n\t  que.push(make_pair(now.first + 1, v));\n\t}\n\tif (i == 3) {\n\t  v = now.second;\n\t  swap(v[3], v[2]);\n\t  que.push(make_pair(now.first + 1, v));\n\t  v = now.second;\n\t  swap(v[3], v[7]);\n\t  que.push(make_pair(now.first + 1, v));\n\t}\n\tif (i == 4) {\n\t  v = now.second;\n\t  swap(v[4], v[5]);\n\t  que.push(make_pair(now.first + 1, v));\n\t}\n\tif (i == 5) {\n\t  v = now.second;\n\t  swap(v[5], v[1]);\n\t  que.push(make_pair(now.first + 1, v));\n\t  v = now.second;\n\t  swap(v[5], v[4]);\n\t  que.push(make_pair(now.first + 1, v));\n\t  v = now.second;\n\t  swap(v[5], v[6]);\n\t  que.push(make_pair(now.first + 1, v));\n\t  v = now.second;\n\t  swap(v[5], v[9]);\n\t  que.push(make_pair(now.first + 1, v));\n\t}\n\tif (i == 6) {\n\t  v = now.second;\n\t  swap(v[6], v[2]);\n\t  que.push(make_pair(now.first + 1, v));\n\t  v = now.second;\n\t  swap(v[6], v[5]);\n\t  que.push(make_pair(now.first + 1, v));\n\t  v = now.second;\n\t  swap(v[6], v[7]);\n\t  que.push(make_pair(now.first + 1, v));\n\t  v = now.second;\n\t  swap(v[6], v[10]);\n\t  que.push(make_pair(now.first + 1, v));\n\t}\n\tif (i == 7) {\n\t  v = now.second;\n\t  swap(v[7], v[3]);\n\t  que.push(make_pair(now.first + 1, v));\n\t  v = now.second;\n\t  swap(v[7], v[6]);\n\t  que.push(make_pair(now.first + 1, v));\n\t  v = now.second;\n\t  swap(v[7], v[8]);\n\t  que.push(make_pair(now.first + 1, v));\n\t  v = now.second;\n\t  swap(v[7], v[11]);\n\t  que.push(make_pair(now.first + 1, v));\n\t}\n\tif (i == 8) {\n\t  v = now.second;\n\t  swap(v[8], v[7]);\n\t  que.push(make_pair(now.first + 1, v));\n\t}\n\tif (i == 9) {\n\t  v = now.second;\n\t  swap(v[9], v[5]);\n\t  que.push(make_pair(now.first + 1, v));\n\t  v = now.second;\n\t  swap(v[9], v[10]);\n\t  que.push(make_pair(now.first + 1, v));\n\t}\n\tif (i == 10) {\n\t  v = now.second;\n\t  swap(v[10], v[6]);\n\t  que.push(make_pair(now.first + 1, v));\n\t  v = now.second;\n\t  swap(v[10], v[9]);\n\t  que.push(make_pair(now.first + 1, v));\n\t  v = now.second;\n\t  swap(v[10], v[11]);\n\t  que.push(make_pair(now.first + 1, v));\n\t  v = now.second;\n\t  swap(v[10], v[12]);\n\t  que.push(make_pair(now.first + 1, v));\n\t}\n\tif (i == 11) {\n\t  v = now.second;\n\t  swap(v[11], v[7]);\n\t  que.push(make_pair(now.first + 1, v));\n\t  v = now.second;\n\t  swap(v[11], v[10]);\n\t  que.push(make_pair(now.first + 1, v));\n\t}\n\tif (i == 12) {\n\t  v = now.second;\n\t  swap(v[12], v[10]);\n\t  que.push(make_pair(now.first + 1, v));\n\t}\n      }\n    }\n    if (!find) {\n      cout << \"NA\" << endl;\n    }\n  }\n  return 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include<iostream>\n#include<vector>\n#include<algorithm>\n#include<map>\n#include<queue>\n\nusing namespace std;\n\nmap<vector<int>,int>mp,used;\n\nstruct State{\n  vector<int>v;\n  int t;\n  State(vector<int>v,int t):v(v),t(t){}\n};\n\nvector<vector<int> > generate(vector<int> v){\n  vector<vector<int> >res;\n\n  for(int i=0;i<13;i++){\n    if(v[i]==0){\n      vector<int>tmp=v;\n      switch(i){\n      case 0:\n\tswap(tmp[0],tmp[2]);\n\tres.push_back(tmp);\n\tbreak;\n      case 1:\n\tswap(tmp[1],tmp[2]);\n\tres.push_back(tmp);\n\tswap(tmp[1],tmp[2]);\n\tswap(tmp[1],tmp[5]);\n\tres.push_back(tmp);\n\tbreak;\n      case 2:\n\tswap(tmp[2],tmp[0]);\n\tres.push_back(tmp);\n\tswap(tmp[2],tmp[0]);\n\n\tswap(tmp[2],tmp[1]);\n\tres.push_back(tmp);\n\tswap(tmp[2],tmp[1]);\n\n\tswap(tmp[2],tmp[3]);\n\tres.push_back(tmp);\n\tswap(tmp[2],tmp[3]);\n\n\tswap(tmp[2],tmp[6]);\n\tres.push_back(tmp);\n\tbreak;\n      case 3:\n\tswap(tmp[3],tmp[2]);\n\tres.push_back(tmp);\n\tswap(tmp[3],tmp[2]);\n\n\tswap(tmp[3],tmp[7]);\n\tres.push_back(tmp);\n\tbreak;\n      case 4:\n\tswap(tmp[4],tmp[5]);\n\tres.push_back(tmp);\n\tbreak;\n      case 5:\n\tswap(tmp[5],tmp[1]);\n\tres.push_back(tmp);\n\tswap(tmp[5],tmp[1]);\n\n\tswap(tmp[5],tmp[4]);\n\tres.push_back(tmp);\n\tswap(tmp[5],tmp[4]);\n\n\tswap(tmp[5],tmp[6]);\n\tres.push_back(tmp);\n\tswap(tmp[5],tmp[6]);\n\n\tswap(tmp[5],tmp[9]);\n\tres.push_back(tmp);\n\tbreak;\n      case 6:\n\tswap(tmp[6],tmp[2]);\n\tres.push_back(tmp);\n\tswap(tmp[6],tmp[2]);\n\n\tswap(tmp[6],tmp[5]);\n\tres.push_back(tmp);\n\tswap(tmp[6],tmp[5]);\n\n\tswap(tmp[6],tmp[7]);\n\tres.push_back(tmp);\n\tswap(tmp[6],tmp[7]);\n\n\tswap(tmp[6],tmp[10]);\n\tres.push_back(tmp);\n\tbreak;\n      case 7:\n\tswap(tmp[7],tmp[3]);\n\tres.push_back(tmp);\n\tswap(tmp[7],tmp[3]);\n\n\tswap(tmp[7],tmp[6]);\n\tres.push_back(tmp);\n\tswap(tmp[7],tmp[6]);\n\n\tswap(tmp[7],tmp[8]);\n\tres.push_back(tmp);\n\tswap(tmp[7],tmp[8]);\n\n\tswap(tmp[7],tmp[11]);\n\tres.push_back(tmp);\n\tbreak;\n      case 8:\n\tswap(tmp[8],tmp[7]);\n\tres.push_back(tmp);\n\tbreak;\n      case 9: \n\tswap(tmp[9],tmp[5]);\n\tres.push_back(tmp);\n\tswap(tmp[9],tmp[5]);\n\n\tswap(tmp[9],tmp[10]);\n\tres.push_back(tmp);\n\tbreak;\n      case 10:\n\tswap(tmp[10],tmp[6]);\n\tres.push_back(tmp);\n\tswap(tmp[10],tmp[6]);\n\n\tswap(tmp[10],tmp[9]);\n\tres.push_back(tmp);\n\tswap(tmp[10],tmp[9]);\n\n\tswap(tmp[10],tmp[11]);\n\tres.push_back(tmp);\n\tswap(tmp[10],tmp[11]);\n\n\tswap(tmp[10],tmp[12]);\n\tres.push_back(tmp);\n\tbreak;\n      case 11:\n\tswap(tmp[11],tmp[7]);\n\tres.push_back(tmp);\n\tswap(tmp[11],tmp[7]);\n\n\tswap(tmp[11],tmp[10]);\n\tres.push_back(tmp);\n\tbreak;\n      case 12:\n\tswap(tmp[12],tmp[10]);\n\tres.push_back(tmp);\n\tbreak;\n      }\n    }\n  }\n  return res;\n}\n\nvoid bfs(void){\n\n  queue<State>que;\n  vector<int>s;\n  for(int i=0;i<12;i++)s.push_back(i);\n  s.push_back(0);\n  que.push(State(s,0));\n\n  while(!que.empty()){\n    State now=que.front();\n    que.pop();\n    \n    if(mp.count(now.v) && now.t>=mp[now.v])continue;\n    if(now.t>=12)continue;\n\n    mp[now.v]=now.t;\n\n    vector<vector<int> >res=generate(now.v);\n    for(int i=0;i<res.size();i++){\n      que.push(State(res[i],now.t+1));\n    }\n  }\n}\n\nint bfs(vector<int> s){\n  \n  used.clear();\n  \n  queue<State>que;\n  que.push(State(s,0));\n  \n  while(!que.empty()){\n    State now=que.front();\n    que.pop();\n    \n    if(now.t>=12)continue;\n    if(used.count(now.v))continue;\n    if(mp.count(now.v))return now.t+mp[now.v];\n    used[now.v]=1;\n    \n    vector<vector<int> >res=generate(now.v);\n    for(int i=0;i<res.size();i++){\n      que.push(State(res[i],now.t+1));\n    }\n  }\n  return -1;\n}\n\nint main(void){\n\n  bfs();\n\n  while(true){\n    vector<int>s(13);\n    for(int i=0;i<13;i++){\n      cin >> s[i];\n      if(s[i]<0)return 0;\n    }\n    int res=bfs(s);\n    if(res<0)cout << \"NA\" << endl;\n    else cout << res << endl;\n  }\n\n  return 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include <cstdio>\n#include <cstdlib>\n#include <cmath>\n#include <climits>\n#include <cfloat>\n#include <map>\n#include <utility>\n#include <set>\n#include <iostream>\n#include <memory>\n#include <string>\n#include <vector>\n#include <algorithm>\n#include <functional>\n#include <sstream>\n#include <complex>\n#include <stack>\n#include <queue>\n#include <cstring>\n#include <sstream>\n#include <cassert>\n#include <list>\nusing namespace std;\nstatic const double EPS = 1e-10;\ntypedef long long ll;\ntypedef pair<int,int> PI;\ntypedef vector<int> vi;\n#ifndef M_PI\n#define M_PI 3.14159265358979323846\n#endif\n#define rep(i,n) for(int i=0;i<(int)n;++i)\n#define FOR(i,c) for(__typeof((c).begin())i=(c).begin();i!=(c).end();++i)\n#define ALL(c) (c).begin(), (c).end()\n#define mp(a,b) make_pair(a,b)\n#define pb(a) push_back(a)\n#define F first\n#define S second\ntemplate <typename T> string print_array(const vector<T> &V) { ostringstream os; os << \"{ \"; for (typename vector<T>::const_iterator iter = V.begin(); iter != V.end(); ++iter) os << '\\\"' << *iter << \"\\\",\"; os << \" }\"; return os.str(); }\n\nint dx[]={0,1,0,-1},dy[]={1,0,-1,0};\n\nvector<int> se[13];\nint x[]={0,-1,0,1,-2,-1,0,1,2,-1,0,1,0};\nint y[]={2,1,1,1,0,0,0,0,0,-1,-1,-1,-2};\n\nvoid pr(ll in){\n\n  printf(\"      %3lld\\n\",in&15);\n  printf(\"   %3lld%3lld%3lld\\n\",(in>>4)&15,(in>>8)&15,(in>>12)&15);\n  printf(\"%3lld%3lld%3lld%3lld%3lld\\n\",(in>>16)&15,(in>>20)&15,(in>>24)&15,(in>>28)&15,(in>>32)&15);\n  printf(\"   %3lld%3lld%3lld\\n\",(in>>36)&15,(in>>40)&15,(in>>44)&15);\n  printf(\"      %3lld\\n\",(in>>48)&15);\n  puts(\"\");\n}\n\nint manh(ll in){\n  int ret=0;\n  rep(i,13){\n    int t=(in>>(i*4))&15;\n\n    if(!t){\n      int nx=x[t]-x[i],ny=y[t]-y[i];\n      int co=abs(nx)+abs(ny);\n      nx=x[12]-x[i],ny=y[12]-y[i];\n      int k=abs(nx)+abs(ny);\n      ret+=min(co,k);\n      continue;\n    }\n    int nx=(x[t]-x[i]),ny=y[t]-y[i];\n    ret+=abs(nx)+abs(ny);\n  }\n  return ret;\n}\n\nmain(){\n  ll p;\n\n  ll goal=0;\n  rep(i,11){\n    goal|=(i+1LL)<<(4*(i+1));\n    //cout<<goal<<endl;\n    //pr(goal);\n  }\n  //pr(goal);\n\n  se[0].pb(2);\n  se[1].pb(2);\n  se[1].pb(5);\n  se[2].pb(0);\n  se[2].pb(1);\n  se[2].pb(3);\n  se[2].pb(6);\n  se[3].pb(2);\n  se[3].pb(7);\n  se[4].pb(5);\n  se[5].pb(1);\n  se[5].pb(4);\n  se[5].pb(6);\n  se[5].pb(9);\n  se[6].pb(2);\n  se[6].pb(5);\n  se[6].pb(7);\n  se[6].pb(10);\n  se[7].pb(3);\n  se[7].pb(6);\n  se[7].pb(8);\n  se[7].pb(11);\n  se[8].pb(7);\n  se[9].pb(5);\n  se[9].pb(10);\n  se[10].pb(6);\n  se[10].pb(9);\n  se[10].pb(11);\n  se[10].pb(12);\n  se[11].pb(7);\n  se[11].pb(10);\n  se[12].pb(10);\n  \n  while(cin>>p){\n    if(p==-1)break;\n    ll in=p;\n\n    rep(i,12){\n      cin>>p;\n      in|=p<<(4*(i+1));\n    }\n\n    set<ll> app;\n\n    queue<pair<int,ll> > Q;\n    app.insert(in);\n    Q.push(mp(0,in));\n    int ans=21;\n    int mans=0;\n\n    while(!Q.empty()){\n      ll cvec=Q.front().S;\n      int ccost=Q.front().F;\n      Q.pop();\n    \n      //pr(cvec);\n\n      //if(ccost>3)break;\n      if(ccost+manh(cvec)>40)continue;\n      if(cvec==goal){\n\tans=ccost;\n\tbreak;\n      }\n      rep(i,13){\n\tll t=cvec>>(i<<2);\n\tt=t&15;\n\tif(!t){\n\t  rep(j,se[i].size()){\n\t    t=cvec>>(se[i][j]<<2);\n\t    t=t&15;\n\t    if(t){\n\t      ll nvec=cvec;\n\t      t=t<<(i<<2);\n\t      nvec|=t;\n\t      nvec&=~(15LL<<se[i][j]*4);\n\t      \n\t      if(!app.count(nvec)){\n\t\tapp.insert(nvec);\n\t\tQ.push(mp(ccost+1,nvec));\n\t      }\n\t    }\n\t  }\n\t}\n      }\n    }\n    if(ans==21)cout<<\"NA\"<<endl;\n    else cout<<ans<<endl;\n  }\n}"
  },
  {
    "language": "C++",
    "code": "#include <iostream>\n#include <queue>\n#include <unordered_set>\nusing namespace std;\ntypedef long long ll;\n\nll mov[13][4] = {\n\t{2,-1,-1,-1},\n\t{2,5,-1,-1},\n\t{0,1,3,6},\n\t{2,7,-1,-1},\n\t{5,-1,-1,-1},\n\t{1,4,6,9},\n\t{2,5,7,10},\n\t{3,6,8,11},\n\t{7,-1,-1,-1},\n\t{5,10,-1,-1},\n\t{6,9,11,12},\n\t{7,10,-1,-1},\n\t{10,-1,-1,-1},\n};\n\nll sw(ll l, int i, int j) {\n\tint a, b;\n\ta = (l >> (4 * i)) & 0xfL;\n\tb = (l >> (4 * j)) & 0xfL;\n\n\tl &= ~(0xfL << (4*i));\n\tl &= ~(0xfL << (4*j));\n\n\tl |= (ll)b << (4 * i);\n\tl |= (ll)a << (4 * j);\n\n\treturn l;\n}\n\nint main() {\n\twhile(1) {\n\t\tll in = 0;\n\t\tfor(int i = 0; i < 13; i++) {\n\t\t\tint tmpin;\n\t\t\tcin >> tmpin;\n\t\t\tif(tmpin < 0)\n\t\t\t\treturn 0;\n\t\t\tin |= ((ll)tmpin << (4*i));\n\t\t}\n\n\t\tqueue<ll> q;\n\t\tunordered_set<ll> s;\n\t\tq.push(in);\n\t\ts.insert(in);\n\t\tint ans = -1;\n\t\t// debug\n\t\tint failcount = 0;\n\t\tfor(int i = 0; i <= 20; i++) {\n\t\t\tqueue<ll> next;\n\t\t\twhile(!q.empty()) {\n\t\t\t\tll l = q.front(); q.pop();\n\t\t\t\tif(l == 0xba9876543210) {\n\t\t\t\t\tans = i;\n\t\t\t\t\tgoto OUTPUT_ANSWER;\n\t\t\t\t}\n\t\t\t\telse {\n\t\t\t\t\tint cnt = 0;\n\t\t\t\t\tfor(int j = 0; j < 13; j++) {\n\t\t\t\t\t\tll t = 0xba9876543210;\n\t\t\t\t\t\tif(((l >> 4*j) & 0xfL) != ((t >> 4*j) & 0xfL)) {\n\t\t\t\t\t\t\tcnt++;\n\t\t\t\t\t\t}\n\t\t\t\t\t}\n\t\t\t\t\tif(cnt > 20 - i + 2)\n\t\t\t\t\t\tcontinue;\n\t\t\t\t}\n\n\t\t\t\tfor(int j = 0; j < 13; j++) {\n\t\t\t\t\tif(((l >> (4*j)) & 0xfL) == 0) {\n\t\t\t\t\t\tfor(int k = 0; k < 4; k++) {\n\t\t\t\t\t\t\tll p;\n\t\t\t\t\t\t\tif(mov[j][k] < 0)\n\t\t\t\t\t\t\t\tbreak;\n\t\t\t\t\t\t\tp = sw(l, j, mov[j][k]);\n\t\t\t\t\t\t\tif(s.find(p) == s.end()) {\n\t\t\t\t\t\t\t\ts.insert(p);\n\t\t\t\t\t\t\t\tnext.push(p);\n\t\t\t\t\t\t\t}\n\t\t\t\t\t\t\telse {\n\t\t\t\t\t\t\t\tfailcount++;\n\t\t\t\t\t\t\t}\n\t\t\t\t\t\t}\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t}\n\t\t\tq = next;\n\t\t}\n\nOUTPUT_ANSWER:;\n\t\tif(ans < 0)\n\t\t\tcout << \"NA\" << endl;\n\t\telse\n\t\t\tcout << ans << endl;\n//\t\tcout << failcount << endl;\n\t}\n}"
  },
  {
    "language": "C++",
    "code": "#include <iostream>\n#include <vector>\n#include <cmath>\n\nusing namespace std;\n \nstruct P {\n    int x, y;\n    P(int x, int y) : x{x}, y{y} {}\n};\n \nint limit;\nvector<int> v;\n\nconstexpr int X[] = {2, 1, 2, 3, 0, 1, 2, 3, 4, 1, 2, 3, 2};\nconstexpr int Y[] = {0, 1, 1, 1, 2, 2, 2, 2, 2, 3, 3, 3, 4};\n \nint next_pos(int x, int y)\n{\n    for (int i = 0; i < 13; i++) {\n        if (x == X[i] && y == Y[i]) {\n            return i;\n        }\n    }        \n    return -1;\n}\n \nint getMD()\n{\n    int sum = 0;\n    for (int i = 0; i < 13; i++) {\n        if (v[i] == 0) continue;\n        sum += abs(X[i] - X[v[i]]) + abs(Y[i] - Y[v[i]]);\n    }\n    return sum;\n}\n \nconstexpr int dx[] = {-1, 0, 1, 0};\nconstexpr int dy[] = {0, -1, 0, 1};\n \nbool dfs(const int* sp, int step)\n{\n    int md = getMD();\n    if (md == 0) return 1;\n    if (md + step > limit) {\n        return 0;\n    }\n    \n    for (int i = 0; i < 2; i++) {\n        int x = X[sp[i]], y = Y[sp[i]];\n        for (int j = 0; j < 4; j++) {\n            int nx = x + dx[j], ny = y + dy[j];\n            int next = next_pos(nx, ny);\n            if (next == -1) continue;\n            \n            const int nsp1[] = {next, sp[1]}, nsp2[] = {sp[0], next};\n            \n            swap(v[sp[i]], v[next]);\n            if (i == 0 && dfs(nsp1, step + 1)) {\n                return 1;\n            }\n            if (i == 1 && dfs(nsp2, step + 1)) {\n                return 1;\n            }\n            swap(v[sp[i]], v[next]);\n        }\n    }\n    return 0;\n}\n \nint main()\n{\n    int x;\n    while (cin >> x, x != -1) {\n        int sp[2];\n        v.resize(13); v[0] = x;\n        for (int i = 1; i < 13; i++) {\n            cin >> v[i];\n        }\n\n        for (int i = 0, j = 0; i < 13; i++) {\n            if (v[i] == 0) {\n                sp[j++] = i;\n            }\n        }\n\n        bool found = 0;\n        constexpr int LIMIT = 20;\n        for (limit = 0; limit <= LIMIT; limit++) {\n            if (dfs(sp, 0)) {\n                cout << limit << endl;\n                found = 1;\n                break;\n            }\n        }\n        if (!found) {\n            cout << \"NA\" << endl;\n        }\n    }\n    return 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include<iostream>\n#include<vector>\n#include<algorithm>\n#include<map>\n#include<queue>\n\nusing namespace std;\n\nmap<vector<int>,int>mp,used;\n\nstruct State{\n  vector<int>v;\n  int t;\n  State(vector<int>v,int t):v(v),t(t){}\n};\n\nvector<vector<int> > generate(vector<int> v){\n  vector<vector<int> >res;\n\n  for(int i=0;i<13;i++){\n    if(v[i]==0){\n      vector<int>tmp=v;\n      switch(i){\n      case 0:\n\tswap(tmp[0],tmp[2]);\n\tres.push_back(tmp);\n\tbreak;\n      case 1:\n\tswap(tmp[1],tmp[2]);\n\tres.push_back(tmp);\n\tswap(tmp[1],tmp[2]);\n\tswap(tmp[1],tmp[5]);\n\tres.push_back(tmp);\n\tbreak;\n      case 2:\n\tswap(tmp[2],tmp[0]);\n\tres.push_back(tmp);\n\tswap(tmp[2],tmp[0]);\n\n\tswap(tmp[2],tmp[1]);\n\tres.push_back(tmp);\n\tswap(tmp[2],tmp[1]);\n\n\tswap(tmp[2],tmp[3]);\n\tres.push_back(tmp);\n\tswap(tmp[2],tmp[3]);\n\n\tswap(tmp[2],tmp[6]);\n\tres.push_back(tmp);\n\tbreak;\n      case 3:\n\tswap(tmp[3],tmp[2]);\n\tres.push_back(tmp);\n\tswap(tmp[3],tmp[2]);\n\n\tswap(tmp[3],tmp[7]);\n\tres.push_back(tmp);\n\tbreak;\n      case 4:\n\tswap(tmp[4],tmp[5]);\n\tres.push_back(tmp);\n\tbreak;\n      case 5:\n\tswap(tmp[5],tmp[1]);\n\tres.push_back(tmp);\n\tswap(tmp[5],tmp[1]);\n\n\tswap(tmp[5],tmp[4]);\n\tres.push_back(tmp);\n\tswap(tmp[5],tmp[4]);\n\n\tswap(tmp[5],tmp[6]);\n\tres.push_back(tmp);\n\tswap(tmp[5],tmp[6]);\n\n\tswap(tmp[5],tmp[9]);\n\tres.push_back(tmp);\n\tbreak;\n      case 6:\n\tswap(tmp[6],tmp[2]);\n\tres.push_back(tmp);\n\tswap(tmp[6],tmp[2]);\n\n\tswap(tmp[6],tmp[5]);\n\tres.push_back(tmp);\n\tswap(tmp[6],tmp[5]);\n\n\tswap(tmp[6],tmp[7]);\n\tres.push_back(tmp);\n\tswap(tmp[6],tmp[7]);\n\n\tswap(tmp[6],tmp[10]);\n\tres.push_back(tmp);\n\tbreak;\n      case 7:\n\tswap(tmp[7],tmp[3]);\n\tres.push_back(tmp);\n\tswap(tmp[7],tmp[3]);\n\n\tswap(tmp[7],tmp[6]);\n\tres.push_back(tmp);\n\tswap(tmp[7],tmp[6]);\n\n\tswap(tmp[7],tmp[8]);\n\tres.push_back(tmp);\n\tswap(tmp[7],tmp[8]);\n\n\tswap(tmp[7],tmp[11]);\n\tres.push_back(tmp);\n\tbreak;\n      case 8:\n\tswap(tmp[8],tmp[7]);\n\tres.push_back(tmp);\n\tbreak;\n      case 9: \n\tswap(tmp[9],tmp[5]);\n\tres.push_back(tmp);\n\tswap(tmp[9],tmp[5]);\n\n\tswap(tmp[9],tmp[10]);\n\tres.push_back(tmp);\n\tbreak;\n      case 10:\n\tswap(tmp[10],tmp[6]);\n\tres.push_back(tmp);\n\tswap(tmp[10],tmp[6]);\n\n\tswap(tmp[10],tmp[9]);\n\tres.push_back(tmp);\n\tswap(tmp[10],tmp[9]);\n\n\tswap(tmp[10],tmp[11]);\n\tres.push_back(tmp);\n\tswap(tmp[10],tmp[11]);\n\n\tswap(tmp[10],tmp[12]);\n\tres.push_back(tmp);\n\tbreak;\n      case 11:\n\tswap(tmp[11],tmp[7]);\n\tres.push_back(tmp);\n\tswap(tmp[11],tmp[7]);\n\n\tswap(tmp[11],tmp[10]);\n\tres.push_back(tmp);\n\tbreak;\n      case 12:\n\tswap(tmp[12],tmp[10]);\n\tres.push_back(tmp);\n\tbreak;\n      }\n    }\n  }\n  return res;\n}\n\nvoid bfs(void){\n\n  queue<State>que;\n  vector<int>s;\n  for(int i=0;i<12;i++)s.push_back(i);\n  s.push_back(0);\n  que.push(State(s,0));\n\n  while(!que.empty()){\n    State now=que.front();\n    que.pop();\n    \n    if(mp.count(now.v) && now.t>=mp[now.v])continue;\n    if(now.t>=10)continue;\n\n    mp[now.v]=now.t;\n\n    vector<vector<int> >res=generate(now.v);\n    for(int i=0;i<res.size();i++){\n      que.push(State(res[i],now.t+1));\n    }\n  }\n}\n\nint bfs(vector<int> s){\n  \n  used.clear();\n  \n  queue<State>que;\n  que.push(State(s,0));\n  \n  while(!que.empty()){\n    State now=que.front();\n    que.pop();\n    \n    if(now.t>=11)continue;\n    if(used.count(now.v))continue;\n    if(mp.count(now.v))return now.t+mp[now.v];\n    used[now.v]=1;\n    \n    vector<vector<int> >res=generate(now.v);\n    for(int i=0;i<res.size();i++){\n      que.push(State(res[i],now.t+1));\n    }\n  }\n  return -1;\n}\n\nint main(void){\n\n  bfs();\n\n  while(true){\n    vector<int>s(13);\n    for(int i=0;i<13;i++){\n      cin >> s[i];\n      if(s[i]<0)return 0;\n    }\n    int res=bfs(s);\n    if(res<0 || res>20)cout << \"NA\" << endl;\n    else cout << res << endl;\n  }\n\n  return 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\n\n#ifndef INCLUDE_ZOBRIST_HASH_HPP\n#define INCLUDE_ZOBRIST_HASH_HPP\n\n#include <random>\n#include <iostream>\n#include <typeinfo>\n\nnamespace orislib {\n\ntemplate <typename T, int W, int H, int STATE>\nstruct ZobristHash {\n  typedef T hash_t;\n  ZobristHash() {\n    std::random_device rd;\n    std::mt19937 mt(rd());\n    std::uniform_int_distribution<T> dist;\n    for (int h = 0; h < H; h++) {\n      for (int w = 0; w < W; w++) {\n        for (int s = 0; s < STATE; s++) {\n          rands[h][w][s] = dist(mt);\n        }\n      }\n    }\n  }\n  template <typename TT>\n  hash_t hash(TT data[H][W]) {\n    hash_t r = 0;\n    for (int h = 0; h < H; h++) {\n      for (int w = 0; w < W; w++) {\n        r ^= rands[h][w][data[h][w]];\n      }\n    }\n    return r;\n  }\n  hash_t rands[H][W][STATE];\n};\n}\n\n#endif\nusing namespace std;\nusing namespace orislib;\n\ntypedef long long ll;\ntypedef long double ld;\ntypedef tuple<int, int> duo;\nconst int dx[] = {0, 0, 1, -1, 1, 1, -1, -1};\nconst int dy[] = {1, -1, 0, 0, 1, -1, 1, -1};\nconst int Mod = 1000000000 + 0;\n//{{{ templates\n#define TT_             \\\n  template <typename T> \\\n  inline\n#define TTF_                        \\\n  template <typename T, typename F> \\\n  inline\nTT_ T sq(T x) { return x * x; }\nTT_ T In() {\n  T x;\n  cin >> x;\n  return x;\n}\nTT_ void Out(T& x) { cout << x; }\nTT_ void sort(T& v) { sort(begin(v), end(v)); }\nTT_ void revs(T& v) { reverse(begin(v), end(v)); }\nTT_ void uniq(T& v) {\n  sort(v);\n  v.erase(unique(begin(v), end(v)), end(v));\n}\nTT_ int ubnd(T& v, typename T::value_type& x) {\n  return upper_bound(begin(v), end(v), x) - begin(v);\n}\nTT_ int lbnd(T& v, typename T::value_type& x) {\n  return lower_bound(begin(v), end(v), x) - begin(v);\n}\nTTF_ void inpt(T& v, int n, F f) {\n  for (v.reserve(n); n--; v.emplace_back(f()))\n    ;\n}\nTTF_ void show(T& v, F f, string d = \" \", string e = \"\\n\") {\n  int i = 0;\n  for (auto& x : v) i++&&(cout << d), f(x);\n  cout << e;\n}\nTT_ typename T::iterator minel(T& v) { return min_element(begin(v), end(v)); }\nTT_ typename T::iterator maxel(T& v) { return max_element(begin(v), end(v)); }\n\ninline void fast_io() {\n  ios::sync_with_stdio(0);\n  cin.tie(0);\n}\ninline int in() {\n  int x;\n  scanf(\"%d\", &x);\n  return x;\n}\ninline ll pow_mod(ll a, ll k, ll m) {\n  ll r = 1;\n  for (; k > 0; a = a * a % m, k >>= 1)\n    if (k & 1) r = r * a % m;\n  return r;\n}\ninline ll mod_inv(ll a, ll p) { return pow_mod(a, p - 2, p); }\n//}}} priority_queue queue deque front stringstream max_element min_element\n// insert count make_tuple\n\nstruct Board {\n  Board() {}\n  Board(const vector<vector<int>>& v) {\n    memset(b, '#', sizeof(b));\n    for (int i = 0; i < 5; i++) b[i][5] = 0;\n    for (int i = 0; i < v[0].size(); i++) b[0][2 + i] = conv_hex(v[0][i]);\n    for (int i = 0; i < v[1].size(); i++) b[1][1 + i] = conv_hex(v[1][i]);\n    for (int i = 0; i < v[2].size(); i++) b[2][0 + i] = conv_hex(v[2][i]);\n    for (int i = 0; i < v[3].size(); i++) b[3][1 + i] = conv_hex(v[3][i]);\n    for (int i = 0; i < v[4].size(); i++) b[4][2 + i] = conv_hex(v[4][i]);\n    int it = 0;\n    for (int i = 0; i < 5; i++) {\n      for (int j = 0; j < 5; j++) {\n        if (b[i][j] == '0') {\n          cx[it] = j;\n          cy[it] = i;\n          it++;\n        }\n      }\n    }\n    turn = 0;\n  }\n  char conv_hex(int a) { return \"0123456789ABCDEF\"[a]; }\n  bool slide(int index, int dir) {\n    int px = cx[index], py = cy[index];\n    int nx = px + dx[dir], ny = py + dy[dir];\n    if (invalid(nx, ny)) return false;\n    if (b[ny][nx] == '#') return false;\n    if (b[ny][nx] == '0') return false;\n    swap(b[py][px], b[ny][nx]);\n    cx[index] = nx;\n    cy[index] = ny;\n    turn++;\n    return true;\n  }\n  bool is_ok() {\n    static const char cb[5][6] = {\n        \"##0##\", \"#123#\", \"45678\", \"#9AB#\", \"##0##\", };\n    return memcmp(cb, b, sizeof(cb)) == 0;\n  }\n  bool invalid(int x, int y) { return x < 0 || x >= 5 || y < 0 || y >= 5; }\n  char b[5][6];\n  int cx[2], cy[2];\n  int turn;\n};\n\nint main() {\n  ZobristHash<int, 6, 5, 256> zh;\n  int h;\n  while (h = in(), h != -1) {\n    vector<vector<int>> vs(5);\n    vs[0].emplace_back(h);\n    inpt(vs[1], 3, in);\n    inpt(vs[2], 5, in);\n    inpt(vs[3], 3, in);\n    inpt(vs[4], 1, in);\n    Board b(vs);\n    queue<Board> Q;\n    set<int> vis;\n    Q.push(b);\n\n    while (!Q.empty()) {\n      Board bi = Q.front();\n      Q.pop();\n      if (bi.turn > 13) break;\n      if (bi.is_ok()) {\n        cout << bi.turn << endl;\n        goto END;\n      }\n      for (int i = 0; i < 2; i++) {\n        for (int d = 0; d < 4; d++) {\n          Board bii = bi;\n          if (!bii.slide(i, d)) continue;\n          int hv = zh.hash(bii.b);\n          if (vis.count(hv)) continue;\n          vis.insert(hv);\n          Q.push(bii);\n        }\n      }\n    }\n  cout << \"NA\" << endl;\nEND:;\n  }\n  return 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include<iostream>\n#include<vector>\n#include<queue>\n#include<map>\n#include<cmath>\n#include<cstdlib>\n#include<algorithm>\nusing namespace std;\n\nstring ans;\n\nclass board{\npublic:\n  int h,c;\n  string s;\n  board(int x,int y,string z){ h=x; c=y; s=z;}\n  const bool operator<(const board x)const{return (h+c>x.h+x.c) || (h+c==x.h+x.c && c>x.c); }\n};\n\nint score(string s){\n  int res=0;\n  int o[2];\n  o[0] = -1;\n  o[1] = -1;\n  for(int i=0;i<25;i++){\n    if(s[i]!='x'){\n      int m;\n      if(s[i]!='o'){\n\tfor(int j=0;j<25;j++){\n\t  if(s[i]==ans[j]){\n\t    int a = abs(i-j);\n\t    int tmp = a/5 + a%5;\n\t    m = tmp;\n\t    break;\n\t  }\n\t}\n      }else{\n\tif(o[0]<0){\n\t  for(int j=0;j<25;j++){\n\t    if(s[i]==ans[j]){\n\t      int a =abs(i-j);\n\t      if(o[0]<0)o[0] = a/5+a%5;\n\t      else o[1] = a/5+a%5;\n\t    }\n\t  }\n\t}else{\n\t  m = -1;\n\t  for(int j=0;j<25;j++){\n\t    if(s[i]==ans[j]){\n\t      int a = abs(i-j);\n\t      int tmp = a/5+a%5;\n\t      if(m<0)m = tmp + o[1];\n\t      else m = min(m,tmp+o[0]);\n\t    }\n\t  }\n\t}\n      }\n      res += m;\n    }\n  }\n  return res/2;\n}\n\nchar trans(int x){\n  if(!x)return 'o';\n  else return 'a'+x-1;\n}\n\nint main(){\n  string s;\n  ans = \"xxoxxxabcxdefghxijkxxxoxx\";\n  int tmp,cost;\n\n  for(;;){\n    cin >> tmp;\n    if(tmp<0)break;\n\n    s = \"xx\";\n    s += trans(tmp);\n    s += \"xxx\";\n    for(int i=0;i<3;i++){\n      cin >> tmp;\n      s += trans(tmp);\n    }\n    s += \"x\";\n    for(int i=0;i<5;i++){\n      cin >> tmp;\n      s += trans(tmp);\n    }\n    s += \"x\";\n    for(int i=0;i<3;i++){\n      cin >> tmp;\n      s+= trans(tmp);\n    }\n    s += \"xxx\";\n    cin >> tmp;\n    s += trans(tmp);\n    s += \"xx\";\n\n    priority_queue<board> q1;\n    q1.push(board(score(s),0,s));\n\n    map<string,bool> m1;\n    m1[s] = 0;\n    while(q1.size()){\n      board p = q1.top();q1.pop();\n      int dx[] = {-5,1,5,-1};\n      //cout << p.h << \" \" << p.c << \" \" << p.s << endl;\n      cost = p.c;\n      if(p.s == ans)break;\n      if(p.h+cost>20){\n\tcost = 21;\n\tbreak;\n      }\n\n      for(int i=0;i<25;i++){\n\tif(p.s[i]=='o'){\n\t  for(int j=0;j<4;j++){\n\t    int sx = i + dx[j];\n\t    string str = p.s;\n\t    if(sx<0 || 25<=sx)continue;\n\t    if(str[sx] == 'x' || str[sx] == 'o')continue;\n\t    swap(str[i],str[sx]);\n\t    if(!m1[str]){\n\t      q1.push(board(score(str),cost+1,str));\n\t      m1[str] = cost+1;\n\t    }\n\t  }\n\t}\n      }\n    }\n\n\n\n    if(cost>20)cout << \"NA\\n\";\n    else cout << cost << endl;\n  }\n}"
  },
  {
    "language": "C++",
    "code": "#include<iostream>\n#include<queue>\n#include<algorithm>\n#include<map>\n\nusing namespace std;\n\nconst int SIZE = 13;\n\nstruct Puzzle{\n  short c[SIZE];\n  \n  void move(int d, int n){\n    if(d == 0) moveUp(n);\n    if(d == 1) moveDown(n);\n    if(d == 2) moveLeft(n);\n    if(d == 3) moveRight(n);\n  }\n  // n = choosed blank number 0(first one) or 1(second one)\n  void moveUp(int n){\n    int pos = findBlankPosition(n);\n    int tmp[] = {-1,-1,0,-1,-1,1,2,3,-1,5,6,7,10};\n    \n    int npos = tmp[pos];\n    if(npos != -1) swap(c[pos],c[npos]);\n  }\n\n  void moveDown(int n){\n    int pos = findBlankPosition(n);\n    int tmp[] = {2,5,6,7,-1,9,10,11,-1,-1,12,-1,-1};\n    \n    int npos = tmp[pos];\n    if(npos != -1) swap(c[pos],c[npos]);\n  }\n\n  void moveLeft(int n){\n    int pos = findBlankPosition(n);\n    int tmp[] = {-1,-1,1,2,-1,4,5,6,7,-1,9,10,-1};\n    \n    int npos = tmp[pos];\n    if(npos != -1) swap(c[pos],c[npos]);\n  }\n\n  void moveRight(int n){\n    int pos = findBlankPosition(n);\n    int tmp[] = {-1,2,3,-1,5,6,7,8,-1,10,11,-1,-1};\n    \n    int npos = tmp[pos];\n    if(npos != -1) swap(c[pos],c[npos]);\n  }\n\n  int findBlankPosition(int n){\n    for(int i = 0; i < SIZE; i++){\n      if(c[i] == 0) n--;\n      if(n < 0) return i;\n    }\n    return -1;\n  }\n\n  bool operator < (const Puzzle& p) const {\n    for(int i = 0; i < SIZE; i++)\n      if(c[i] != p.c[i]) return c[i] < p.c[i];\n    return false;\n  }\n};\n\nPuzzle puz;\n\nbool input(){\n  cin >> puz.c[0];\n  if(puz.c[0] == -1) return false;\n  for(int i = 1; i < SIZE; i++) cin >> puz.c[i];\n  return true;\n}\n\nvoid solve(){\n  map<Puzzle, int> M;\n  M[puz] = 1;\n \n  queue<Puzzle> Q;\n  Q.push(puz);\n\n  while(!Q.empty()){\n    Puzzle now = Q.front(); Q.pop();\n  \n    for(int i = 0; i < 4; i++)\n      for(int j = 0; j < 2; j++){\n\tPuzzle nex = now;\n\tnex.move(i,j);\n\tif(M[nex] > M[now]+1|| M[nex] == 0){\n\t  M[nex] = M[now]+1;\n\t  if(M[nex] < 11) Q.push(nex);\n\t}\n      }\n  }\n\n  Puzzle tmp;\n  for(int i = 0; i < SIZE; i++) tmp.c[i] = i%(SIZE-1);\n\n \n  int ans = 25;\n  Q.push(tmp);\n  map<Puzzle,int> MG;\n  MG[tmp] = 1;\n\n  while(!Q.empty()){\n    Puzzle now = Q.front(); Q.pop();\n    if(M[now] != 0) ans = min(ans,M[now]+MG[now]-2);\n    for(int i = 0; i < 4; i++)\n      for(int j = 0; j < 2; j++){\n\tPuzzle nex = now;\n\tnex.move(i,j);\n      \n        if(MG[nex] > MG[now]+1 || MG[nex] == 0){\n\t  MG[nex] = MG[now]+1;\n\t  if(MG[nex] <= 11) Q.push(nex);\n\t}\n      }\n    }\n    if(ans <= 20) cout << ans << endl;\n    else cout << \"NA\" << endl;\n}\n\nint main(){\n  while(input()) solve();\n  return 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include <iostream>\n#include <vector>\n#include <algorithm>\n#include <queue>\n#include <set>\n\nusing namespace std;\n\nint d[5][5];\nconst int INF=100000000;\n\nint minDepth=INF;\n\nconst int dx[]={-1,0,0,1};\nconst int dy[]={0,1,-1,0};\n\n\n// ツ閉敖優ツ静ヲツづ探ツ催オ\nint bfs(){\n\tset<vector<vector<int> > > used;\n\n\tqueue<vector<vector<int> > > *prv = new queue<vector<vector<int> > >();\n\tqueue<vector<vector<int> > > *nxt = new queue<vector<vector<int> > >();\n\tvector<vector<int> > v;\n\tfor(int i = 0; i < 5; i++){\n\t\tvector<int> vv;\n\t\tfor(int j = 0; j < 5; j++){\n\t\t\tvv.push_back(d[i][j]);\n\t\t}\n\t\tv.push_back(vv);\n\t}\n\tused.insert(v);\n\n\tprv->push(v);\n\tint cnt=0;\n\twhile(prv->size()){\n\t\tif(cnt==21)\n\t\t\tbreak;\n\t\tcout<<cnt<<endl;\n\t\twhile(prv->size()){\n\t\t\tvector<vector<int> > cv = prv->front();\n\t\t\tprv->pop();\n\t\t\tif(cv[1][1]==1&&cv[1][2]==2&&cv[1][3]==3&&cv[2][0]==4&&cv[2][1]==5&&cv[2][2]==6&&cv[2][3]==7\n\t\t\t\t&&cv[2][4]==8&&cv[3][1]==9&&cv[3][2]==10&&cv[3][3]==11){\n\t\t\t\t\treturn cnt;\n\t\t\t}\n\t\t\t// ツゼツδ債づ個暗環置ツづーツ探ツ催オ\n\t\t\tvector<pair<int,int> > zeroP;\n\t\t\tfor(int i = 0; i < 5; i++){\n\t\t\t\tfor(int j = 0; j < 5; j++){\n\t\t\t\t\tif(cv[i][j]==0)\n\t\t\t\t\t\tzeroP.push_back(make_pair(i,j));\n\t\t\t\t}\n\t\t\t}\n\t\t\t// ツ督ョツつゥツつケツづゥツ督ョツつゥツつオツ陛サツづーツつキツづ猟づ篠篠つキ\n\t\t\tfor(int i = 0; i < zeroP.size(); i++){\n\t\t\t\tint cx=zeroP[i].second;\n\t\t\t\tint cy=zeroP[i].first;\n\t\t\t\t// ツ四ツ陛サツ古シツつキツづ猟づ篠篠つキ\n\t\t\t\tfor(int j = 0; j < 4; j++){\n\t\t\t\t\tint nx=cx+dx[j];\n\t\t\t\t\tint ny=cy+dy[j];\n\t\t\t\t\tif(nx>=0&&ny>=0&&nx<5&&ny<5){\n\t\t\t\t\t\tif(ny==0&&nx==2){\n\t\t\t\t\t\t\tif(cv[ny][nx]!=INF&&cv[ny][nx]!=0){\n\t\t\t\t\t\t\t\tswap(cv[ny][nx],cv[cy][cx]);\n\t\t\t\t\t\t\t\tif(used.find(cv)==used.end()){\n\t\t\t\t\t\t\t\t\tnxt->push(cv);\n\t\t\t\t\t\t\t\t\tused.insert(cv);\n\t\t\t\t\t\t\t\t}\n\t\t\t\t\t\t\t\tswap(cv[ny][nx],cv[cy][cx]);\n\t\t\t\t\t\t\t}\n\t\t\t\t\t\t}\n\t\t\t\t\t\telse if(ny==1&&nx>=1&&nx<=3){\n\t\t\t\t\t\t\tif(cv[ny][nx]!=INF&&cv[ny][nx]!=0){\n\t\t\t\t\t\t\t\tswap(cv[ny][nx],cv[cy][cx]);\n\t\t\t\t\t\t\t\tif(used.find(cv)==used.end()){\n\t\t\t\t\t\t\t\t\tnxt->push(cv);\n\t\t\t\t\t\t\t\t\tused.insert(cv);\n\t\t\t\t\t\t\t\t}\n\t\t\t\t\t\t\t\tswap(cv[ny][nx],cv[cy][cx]);\n\t\t\t\t\t\t\t}\n\t\t\t\t\t\t}\n\t\t\t\t\t\telse if(ny==2&&nx>=0&&nx<=4){\n\t\t\t\t\t\t\tif(cv[ny][nx]!=INF&&cv[ny][nx]!=0){\n\t\t\t\t\t\t\t\tswap(cv[ny][nx],cv[cy][cx]);\n\t\t\t\t\t\t\t\tif(used.find(cv)==used.end()){\n\t\t\t\t\t\t\t\t\tnxt->push(cv);\n\t\t\t\t\t\t\t\t\tused.insert(cv);\n\t\t\t\t\t\t\t\t}\n\t\t\t\t\t\t\t\tswap(cv[ny][nx],cv[cy][cx]);\n\t\t\t\t\t\t\t}\n\t\t\t\t\t\t}\n\t\t\t\t\t\telse if(ny==3&&nx>=1&&nx<=3){\n\t\t\t\t\t\t\tif(cv[ny][nx]!=INF&&cv[ny][nx]!=0){\n\t\t\t\t\t\t\t\tswap(cv[ny][nx],cv[cy][cx]);\n\t\t\t\t\t\t\t\tif(used.find(cv)==used.end()){\n\t\t\t\t\t\t\t\t\tnxt->push(cv);\n\t\t\t\t\t\t\t\t\tused.insert(cv);\n\t\t\t\t\t\t\t\t}\n\t\t\t\t\t\t\t\tswap(cv[ny][nx],cv[cy][cx]);\n\t\t\t\t\t\t\t}\n\t\t\t\t\t\t}\n\t\t\t\t\t\telse if(ny==4&&nx==2){\n\t\t\t\t\t\t\tif(cv[ny][nx]!=INF&&cv[ny][nx]!=0){\n\t\t\t\t\t\t\t\tswap(cv[ny][nx],cv[cy][cx]);\n\t\t\t\t\t\t\t\tif(used.find(cv)==used.end()){\n\t\t\t\t\t\t\t\t\tnxt->push(cv);\n\t\t\t\t\t\t\t\t\tused.insert(cv);\n\t\t\t\t\t\t\t\t}\n\t\t\t\t\t\t\t\tswap(cv[ny][nx],cv[cy][cx]);\n\t\t\t\t\t\t\t}\n\t\t\t\t\t\t}\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t\tswap(prv,nxt);\n\t\tcnt++;\n\t}\n\treturn INF;\n}\n\n// ツ深ツつウツ優ツ静ヲツづ探ツ催オ\nvoid dfs(vector<pair<int,int> > zeroP,int depth){\n\tif(minDepth<depth)\n\t\treturn;\n\tif(d[1][1]==1&&d[1][2]==2&&d[1][3]==3&&d[2][0]==4&&d[2][1]==5&&d[2][2]==6&&d[2][3]==7\n\t\t&&d[2][4]==8&&d[3][1]==9&&d[3][2]==10&&d[3][3]==11){\n\t\t\tminDepth=min(minDepth,depth);\n\t\t\treturn;\n\t}\n\telse if(depth==20)\n\t\treturn;\n\n\t// ツ督ョツつゥツつケツづゥツ督ョツつゥツつオツ陛サツづーツつキツづ猟づ篠篠つキ\n\tfor(int i = 0; i < zeroP.size(); i++){\n\t\tint cx=zeroP[i].second;\n\t\tint cy=zeroP[i].first;\n\t\t// ツ四ツ陛サツ古シツつキツづ猟づ篠篠つキ\n\t\tfor(int j = 0; j < 4; j++){\n\t\t\tint nx=cx+dx[i];\n\t\t\tint ny=cy+dy[i];\n\t\t\tif(nx>=0&&ny>=0&&nx<5&&ny<5){\n\t\t\t\tif(ny==0&&nx==2){\n\t\t\t\t\tif(d[ny][nx]!=INF&&d[ny][nx]!=0){\n\t\t\t\t\t\tswap(d[ny][nx],d[cy][cx]);\n\t\t\t\t\t\tvector<pair<int,int> > nzp;\n\t\t\t\t\t\tif(i==0){\n\t\t\t\t\t\t\tnzp.push_back(zeroP[1]);\n\t\t\t\t\t\t}\n\t\t\t\t\t\telse{\n\t\t\t\t\t\t\tnzp.push_back(zeroP[0]);\n\t\t\t\t\t\t}\n\t\t\t\t\t\tnzp.push_back(make_pair(ny,nx));\n\t\t\t\t\t\tdfs(nzp,depth+1);\n\t\t\t\t\t\tswap(d[ny][nx],d[cy][cx]);\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t\telse if(ny==1&&nx>=1&&nx<=3){\n\t\t\t\t\tif(d[ny][nx]!=INF&&d[ny][nx]!=0){\n\t\t\t\t\t\tswap(d[ny][nx],d[cy][cx]);\n\t\t\t\t\t\tvector<pair<int,int> > nzp;\n\t\t\t\t\t\tif(i==0){\n\t\t\t\t\t\t\tnzp.push_back(zeroP[1]);\n\t\t\t\t\t\t}\n\t\t\t\t\t\telse{\n\t\t\t\t\t\t\tnzp.push_back(zeroP[1]);\n\t\t\t\t\t\t}\n\t\t\t\t\t\tnzp.push_back(make_pair(ny,nx));\n\t\t\t\t\t\tdfs(nzp,depth+1);\n\t\t\t\t\t\tswap(d[ny][nx],d[cy][cx]);\n\t\t\t\t\t}\n\n\t\t\t\t}\n\t\t\t\telse if(ny==2&&nx>=0&&nx<=4){\n\t\t\t\t\tif(d[ny][nx]!=INF&&d[ny][nx]!=0){\n\t\t\t\t\t\tswap(d[ny][nx],d[cy][cx]);\n\t\t\t\t\t\tvector<pair<int,int> > nzp;\n\t\t\t\t\t\tif(i==0){\n\t\t\t\t\t\t\tnzp.push_back(zeroP[1]);\n\t\t\t\t\t\t}\n\t\t\t\t\t\telse{\n\t\t\t\t\t\t\tnzp.push_back(zeroP[1]);\n\t\t\t\t\t\tnzp.push_back(make_pair(ny,nx));\n\t\t\t\t\t\tdfs(nzp,depth+1);\n\t\t\t\t\t\tswap(d[ny][nx],d[cy][cx]);\n\t\t\t\t\t\t}\n\t\t\t\t\t}\n\n\t\t\t\t}\n\t\t\t\telse if(ny==3&&nx>=1&&nx<=3){\n\t\t\t\t\tif(d[ny][nx]!=INF&&d[ny][nx]!=0){\n\t\t\t\t\t\tswap(d[ny][nx],d[cy][cx]);\n\t\t\t\t\t\tvector<pair<int,int> > nzp;\n\t\t\t\t\t\tif(i==0){\n\t\t\t\t\t\t\tnzp.push_back(zeroP[1]);\n\t\t\t\t\t\t}\n\t\t\t\t\t\telse{\n\t\t\t\t\t\t\tnzp.push_back(zeroP[1]);\n\t\t\t\t\t\t}\n\t\t\t\t\t\tnzp.push_back(make_pair(ny,nx));\n\t\t\t\t\t\tdfs(nzp,depth+1);\n\t\t\t\t\t\tswap(d[ny][nx],d[cy][cx]);\n\t\t\t\t\t}\n\n\t\t\t\t}\n\t\t\t\telse if(ny==4&&nx==2){\n\t\t\t\t\tif(d[ny][nx]!=INF&&d[ny][nx]!=0){\n\t\t\t\t\t\tswap(d[ny][nx],d[cy][cx]);\n\t\t\t\t\t\tvector<pair<int,int> > nzp;\n\t\t\t\t\t\tif(i==0){\n\t\t\t\t\t\t\tnzp.push_back(zeroP[1]);\n\t\t\t\t\t\t}\n\t\t\t\t\t\telse{\n\t\t\t\t\t\t\tnzp.push_back(zeroP[1]);\n\t\t\t\t\t\t}\n\t\t\t\t\t\tnzp.push_back(make_pair(ny,nx));\n\t\t\t\t\t\tdfs(nzp,depth+1);\n\t\t\t\t\t\tswap(d[ny][nx],d[cy][cx]);\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t}\n}\n\n\nint main(){\n\n\tfor(int i = 0; i < 5; i++){\n\t\tfor(int j = 0; j < 5; j++){\n\t\t\td[i][j]=INF;\n\t\t}\n\t}\n\twhile(cin>>d[0][2]&&d[0][2]!=-1){\n\t\tminDepth=INF;\n\t\tcin>>d[1][1]>>d[1][2]>>d[1][3];\n\t\tfor(int i = 0; i < 5; i++){\n\t\t\tcin>>d[2][i];\n\t\t}\n\t\tcin>>d[3][1]>>d[3][2]>>d[3][3]>>d[4][2];\n\t\t\n\t\tvector<pair<int,int> > emp;\n\t\tfor(int i = 0; i < 5; i++){\n\t\t\tfor(int j = 0; j < 5; j++){\n\t\t\t\tif(d[i][j]==0)\n\t\t\t\t\temp.push_back(make_pair(i,j));\n\t\t\t}\n\t\t}\n\n\t\t//dfs(emp,1);\n\t\tminDepth=bfs();\n\n\t\tif(minDepth==INF)\n\t\t\tcout<<\"NA\"<<endl;\n\t\telse\n\t\t\tcout<<minDepth<<endl;\n\n\t\t// ツ篠淞づ個渉按猟敖づ個つスツづ淞づ個渉可甘コツ可サ\n\t\tfor(int i = 0; i < 5; i++){\n\t\t\tfor(int j = 0; j < 5; j++){\n\t\t\t\td[i][j]=INF;\n\t\t\t}\n\t\t}\n\t}\n\n\n\n\treturn 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include <cstdio>\n#include <cstdlib>\n#include <cmath>\n#include <climits>\n#include <cfloat>\n#include <map>\n#include <utility>\n#include <set>\n#include <iostream>\n#include <memory>\n#include <string>\n#include <vector>\n#include <algorithm>\n#include <functional>\n#include <sstream>\n#include <complex>\n#include <stack>\n#include <queue>\n#include <cstring>\n#include <sstream>\n#include <cassert>\n#include <list>\nusing namespace std;\nstatic const double EPS = 1e-10;\ntypedef long long ll;\ntypedef pair<int,int> PI;\ntypedef vector<int> vi;\n#ifndef M_PI\n#define M_PI 3.14159265358979323846\n#endif\n#define rep(i,n) for(int i=0;i<(int)n;++i)\n#define FOR(i,c) for(__typeof((c).begin())i=(c).begin();i!=(c).end();++i)\n#define ALL(c) (c).begin(), (c).end()\n#define mp(a,b) make_pair(a,b)\n#define pb(a) push_back(a)\n#define F first\n#define S second\ntemplate <typename T> string print_array(const vector<T> &V) { ostringstream os; os << \"{ \"; for (typename vector<T>::const_iterator iter = V.begin(); iter != V.end(); ++iter) os << '\\\"' << *iter << \"\\\",\"; os << \" }\"; return os.str(); }\n\nint dx[]={0,1,0,-1},dy[]={1,0,-1,0};\n\nvector<int> se[13];\nint x[]={0,-1,0,1,-2,-1,0,1,2,-1,0,1,0};\nint y[]={2,1,1,1,0,0,0,0,0,-1,-1,-1,-2};\n\nvoid pr(ll in){\n\n  printf(\"      %3lld\\n\",in&15);\n  printf(\"   %3lld%3lld%3lld\\n\",(in>>4)&15,(in>>8)&15,(in>>12)&15);\n  printf(\"%3lld%3lld%3lld%3lld%3lld\\n\",(in>>16)&15,(in>>20)&15,(in>>24)&15,(in>>28)&15,(in>>32)&15);\n  printf(\"   %3lld%3lld%3lld\\n\",(in>>36)&15,(in>>40)&15,(in>>44)&15);\n  printf(\"      %3lld\\n\",(in>>48)&15);\n  puts(\"\");\n}\n\nint manh(ll in){\n  int ret=0;\n  rep(i,13){\n    int t=in>>(i*4);\n    t&=15;\n    if(!t)continue;\n    int nx=(x[t]-x[i]),ny=y[t]-y[i];\n    ret+=abs(nx)+abs(ny);\n  }\n  return ret;\n}\n\nmain(){\n  ll p;\n\n  ll goal=0;\n  rep(i,11){\n    goal|=(i+1LL)<<(4*(i+1));\n    //cout<<goal<<endl;\n    //pr(goal);\n  }\n  //pr(goal);\n\n  se[0].pb(2);\n  se[1].pb(2);\n  se[1].pb(5);\n  se[2].pb(0);\n  se[2].pb(1);\n  se[2].pb(3);\n  se[2].pb(6);\n  se[3].pb(2);\n  se[3].pb(7);\n  se[4].pb(5);\n  se[5].pb(1);\n  se[5].pb(4);\n  se[5].pb(6);\n  se[5].pb(9);\n  se[6].pb(2);\n  se[6].pb(5);\n  se[6].pb(7);\n  se[6].pb(10);\n  se[7].pb(3);\n  se[7].pb(6);\n  se[7].pb(8);\n  se[7].pb(11);\n  se[8].pb(7);\n  se[9].pb(5);\n  se[9].pb(10);\n  se[10].pb(6);\n  se[10].pb(9);\n  se[10].pb(11);\n  se[10].pb(12);\n  se[11].pb(7);\n  se[11].pb(10);\n  se[12].pb(10);\n  \n  while(cin>>p){\n    if(p==-1)break;\n    ll in=p;\n\n    rep(i,12){\n      cin>>p;\n      in|=p<<(4*(i+1));\n    }\n\n    set<ll> app;\n\n    queue<pair<int,ll> > Q;\n    app.insert(in);\n    Q.push(mp(0,in));\n    int ans=21;\n    int mans=0;\n\n    while(!Q.empty()){\n      ll cvec=Q.front().S;\n      int ccost=Q.front().F;\n      Q.pop();\n    \n      //pr(cvec);\n\n      //if(ccost>3)break;\n      if(ccost+manh(cvec)>20)break;\n      if(cvec==goal){\n\tans=ccost;\n\tbreak;\n      }\n      rep(i,13){\n\tll t=cvec>>(i<<2);\n\tt=t&15;\n\tif(!t){\n\t  rep(j,se[i].size()){\n\t    t=cvec>>(se[i][j]<<2);\n\t    t=t&15;\n\t    if(t){\n\t      ll nvec=cvec;\n\t      t=t<<(i<<2);\n\t      nvec|=t;\n\t      nvec&=~(15LL<<se[i][j]*4);\n\t      \n\t      if(!app.count(nvec)){\n\t\tapp.insert(nvec);\n\t\tQ.push(mp(ccost+1,nvec));\n\t      }\n\t    }\n\t  }\n\t}\n      }\n    }\n    if(ans==21)cout<<\"NA\"<<endl;\n    else cout<<ans<<endl;\n  }\n}"
  },
  {
    "language": "C++",
    "code": "#include <cstdio>\n#include <cstdlib>\n#include <cmath>\n#include <climits>\n#include <cfloat>\n#include <map>\n#include <utility>\n#include <set>\n#include <iostream>\n#include <memory>\n#include <string>\n#include <vector>\n#include <algorithm>\n#include <functional>\n#include <sstream>\n#include <complex>\n#include <stack>\n#include <queue>\n#include <cstring>\n#include <sstream>\n#include <cassert>\n#include <list>\nusing namespace std;\nstatic const double EPS = 1e-10;\ntypedef long long ll;\ntypedef pair<int,int> PI;\ntypedef vector<int> vi;\n#ifndef M_PI\n#define M_PI 3.14159265358979323846\n#endif\n#define rep(i,n) for(int i=0;i<(int)n;++i)\n#define FOR(i,c) for(__typeof((c).begin())i=(c).begin();i!=(c).end();++i)\n#define ALL(c) (c).begin(), (c).end()\n#define mp(a,b) make_pair(a,b)\n#define pb(a) push_back(a)\n#define F first\n#define S second\ntemplate <typename T> string print_array(const vector<T> &V) { ostringstream os; os << \"{ \"; for (typename vector<T>::const_iterator iter = V.begin(); iter != V.end(); ++iter) os << '\\\"' << *iter << \"\\\",\"; os << \" }\"; return os.str(); }\n\nint dx[]={0,1,0,-1},dy[]={1,0,-1,0};\n\nvector<int> se[13];\nint x[]={0,-1,0,1,-2,-1,0,1,2,-1,0,1,0};\nint y[]={2,1,1,1,0,0,0,0,0,-1,-1,-1,-2};\n\nvoid pr(ll in){\n\n  printf(\"      %3lld\\n\",in&15);\n  printf(\"   %3lld%3lld%3lld\\n\",(in>>4)&15,(in>>8)&15,(in>>12)&15);\n  printf(\"%3lld%3lld%3lld%3lld%3lld\\n\",(in>>16)&15,(in>>20)&15,(in>>24)&15,(in>>28)&15,(in>>32)&15);\n  printf(\"   %3lld%3lld%3lld\\n\",(in>>36)&15,(in>>40)&15,(in>>44)&15);\n  printf(\"      %3lld\\n\",(in>>48)&15);\n  puts(\"\");\n}\n\nint manh(ll in){\n  int ret=0;\n  rep(i,13){\n    int t=(in>>(i*4))&15;\n\n    if(!t){\n      int nx=x[t]-x[i],ny=y[t]-y[i];\n      int co=abs(nx)+abs(ny);\n      nx=x[12]-x[i],ny=y[12]-y[i];\n      int k=abs(nx)+abs(ny);\n      ret+=min(co,k);\n      continue;\n    }\n    int nx=(x[t]-x[i]),ny=y[t]-y[i];\n    ret+=abs(nx)+abs(ny);\n  }\n  return ret;\n}\n\nmain(){\n  ll p;\n\n  ll goal=0;\n  rep(i,11){\n    goal|=(i+1LL)<<(4*(i+1));\n    //cout<<goal<<endl;\n    //pr(goal);\n  }\n  //pr(goal);\n\n  se[0].pb(2);\n  se[1].pb(2);\n  se[1].pb(5);\n  se[2].pb(0);\n  se[2].pb(1);\n  se[2].pb(3);\n  se[2].pb(6);\n  se[3].pb(2);\n  se[3].pb(7);\n  se[4].pb(5);\n  se[5].pb(1);\n  se[5].pb(4);\n  se[5].pb(6);\n  se[5].pb(9);\n  se[6].pb(2);\n  se[6].pb(5);\n  se[6].pb(7);\n  se[6].pb(10);\n  se[7].pb(3);\n  se[7].pb(6);\n  se[7].pb(8);\n  se[7].pb(11);\n  se[8].pb(7);\n  se[9].pb(5);\n  se[9].pb(10);\n  se[10].pb(6);\n  se[10].pb(9);\n  se[10].pb(11);\n  se[10].pb(12);\n  se[11].pb(7);\n  se[11].pb(10);\n  se[12].pb(10);\n  \n  while(cin>>p){\n    if(p==-1)break;\n    ll in=p;\n\n    rep(i,12){\n      cin>>p;\n      in|=p<<(4*(i+1));\n    }\n\n    set<ll> app;\n\n    queue<pair<int,ll> > Q;\n    app.insert(in);\n    Q.push(mp(0,in));\n    int ans=21;\n    int mans=0;\n\n    while(!Q.empty()){\n      ll cvec=Q.front().S;\n      int ccost=Q.front().F;\n      Q.pop();\n    \n      //pr(cvec);\n\n      //if(ccost>3)break;\n     if(ccost>20)break;\n     \n      if(cvec==goal){\n\tans=ccost;\n\tbreak;\n      }\n      if(ccost+manh(cvec)>26)continue;\n      rep(i,13){\n\tll t=cvec>>(i<<2);\n\tt=t&15;\n\tif(!t){\n\t  rep(j,se[i].size()){\n\t    t=cvec>>(se[i][j]<<2);\n\t    t=t&15;\n\t    if(t){\n\t      ll nvec=cvec;\n\t      t=t<<(i<<2);\n\t      nvec|=t;\n\t      nvec&=~(15LL<<se[i][j]*4);\n\t      \n\t      if(!app.count(nvec)){\n\t\tapp.insert(nvec);\n\t\tQ.push(mp(ccost+1,nvec));\n\t      }\n\t    }\n\t  }\n\t}\n      }\n    }\n    if(ans==21)cout<<\"NA\"<<endl;\n    else cout<<ans<<endl;\n  }\n}"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\n\n#ifndef INCLUDE_ZOBRIST_HASH_HPP\n#define INCLUDE_ZOBRIST_HASH_HPP\n\n#include <random>\n#include <iostream>\n#include <typeinfo>\n\nnamespace orislib {\n\ntemplate <typename T, int W, int H, int STATE>\nstruct ZobristHash {\n  typedef T hash_t;\n  ZobristHash() {\n    std::random_device rd;\n    std::mt19937 mt(rd());\n    std::uniform_int_distribution<T> dist;\n    for (int h = 0; h < H; h++) {\n      for (int w = 0; w < W; w++) {\n        for (int s = 0; s < STATE; s++) {\n          rands[h][w][s] = dist(mt);\n        }\n      }\n    }\n  }\n  template <typename TT>\n  hash_t hash(TT data[H][W]) {\n    hash_t r = 0;\n    for (int h = 0; h < H; h++) {\n      for (int w = 0; w < W; w++) {\n        r ^= rands[h][w][data[h][w]];\n      }\n    }\n    return r;\n  }\n  hash_t rands[H][W][STATE];\n};\n}\n\n#endif\nusing namespace std;\nusing namespace orislib;\n\ntypedef long long ll;\ntypedef long double ld;\ntypedef tuple<int, int> duo;\nconst int dx[] = {0, 0, 1, -1, 1, 1, -1, -1};\nconst int dy[] = {1, -1, 0, 0, 1, -1, 1, -1};\nconst int Mod = 1000000000 + 0;\n//{{{ templates\n#define TT_             \\\n  template <typename T> \\\n  inline\n#define TTF_                        \\\n  template <typename T, typename F> \\\n  inline\nTT_ T sq(T x) { return x * x; }\nTT_ T In() {\n  T x;\n  cin >> x;\n  return x;\n}\nTT_ void Out(T& x) { cout << x; }\nTT_ void sort(T& v) { sort(begin(v), end(v)); }\nTT_ void revs(T& v) { reverse(begin(v), end(v)); }\nTT_ void uniq(T& v) {\n  sort(v);\n  v.erase(unique(begin(v), end(v)), end(v));\n}\nTT_ int ubnd(T& v, typename T::value_type& x) {\n  return upper_bound(begin(v), end(v), x) - begin(v);\n}\nTT_ int lbnd(T& v, typename T::value_type& x) {\n  return lower_bound(begin(v), end(v), x) - begin(v);\n}\nTTF_ void inpt(T& v, int n, F f) {\n  for (v.reserve(n); n--; v.emplace_back(f()))\n    ;\n}\nTTF_ void show(T& v, F f, string d = \" \", string e = \"\\n\") {\n  int i = 0;\n  for (auto& x : v) i++&&(cout << d), f(x);\n  cout << e;\n}\nTT_ typename T::iterator minel(T& v) { return min_element(begin(v), end(v)); }\nTT_ typename T::iterator maxel(T& v) { return max_element(begin(v), end(v)); }\n\ninline void fast_io() {\n  ios::sync_with_stdio(0);\n  cin.tie(0);\n}\ninline int in() {\n  int x;\n  scanf(\"%d\", &x);\n  return x;\n}\ninline ll pow_mod(ll a, ll k, ll m) {\n  ll r = 1;\n  for (; k > 0; a = a * a % m, k >>= 1)\n    if (k & 1) r = r * a % m;\n  return r;\n}\ninline ll mod_inv(ll a, ll p) { return pow_mod(a, p - 2, p); }\n//}}} priority_queue queue deque front stringstream max_element min_element\n// insert count make_tuple\n\nstruct Board {\n  Board() {}\n  Board(const vector<vector<int>>& v) {\n    memset(b, '#', sizeof(b));\n    for (int i = 0; i < 5; i++) b[i][5] = 0;\n    for (int i = 0; i < v[0].size(); i++) b[0][2 + i] = conv_hex(v[0][i]);\n    for (int i = 0; i < v[1].size(); i++) b[1][1 + i] = conv_hex(v[1][i]);\n    for (int i = 0; i < v[2].size(); i++) b[2][0 + i] = conv_hex(v[2][i]);\n    for (int i = 0; i < v[3].size(); i++) b[3][1 + i] = conv_hex(v[3][i]);\n    for (int i = 0; i < v[4].size(); i++) b[4][2 + i] = conv_hex(v[4][i]);\n    int it = 0;\n    for (int i = 0; i < 5; i++) {\n      for (int j = 0; j < 5; j++) {\n        if (b[i][j] == '0') {\n          cx[it] = j;\n          cy[it] = i;\n          it++;\n        }\n      }\n    }\n    turn = 0;\n  }\n  char conv_hex(int a) { return \"0123456789ABCDEF\"[a]; }\n  bool slide(int index, int dir) {\n    int px = cx[index], py = cy[index];\n    int nx = px + dx[dir], ny = py + dy[dir];\n    if (invalid(nx, ny)) return false;\n    if (b[ny][nx] == '#') return false;\n    if (b[ny][nx] == '0') return false;\n    swap(b[py][px], b[ny][nx]);\n    cx[index] = nx;\n    cy[index] = ny;\n    turn++;\n    return true;\n  }\n  bool is_ok() {\n    static const char cb[5][6] = {\n        \"##0##\", \"#123#\", \"45678\", \"#9AB#\", \"##0##\", };\n    return memcmp(cb, b, sizeof(cb)) == 0;\n  }\n  bool invalid(int x, int y) { return x < 0 || x >= 5 || y < 0 || y >= 5; }\n  char b[5][6];\n  int cx[2], cy[2];\n  int turn;\n};\n\nint main() {\n  ZobristHash<int, 6, 5, 256> zh;\n  int h;\n  while (h = in(), h != -1) {\n    vector<vector<int>> vs(5);\n    vs[0].emplace_back(h);\n    inpt(vs[1], 3, in);\n    inpt(vs[2], 5, in);\n    inpt(vs[3], 3, in);\n    inpt(vs[4], 1, in);\n    Board b(vs);\n    queue<Board> Q;\n    set<int> vis;\n    Q.push(b);\n    vis.insert(zh.hash(b.b));\n\n    while (!Q.empty()) {\n      Board bi = Q.front();\n      Q.pop();\n      if (bi.turn > 15) break;\n      if (bi.is_ok()) {\n        cout << bi.turn << endl;\n        goto END;\n      }\n      for (int i = 0; i < 2; i++) {\n        for (int d = 0; d < 4; d++) {\n          Board bii = bi;\n          if (!bii.slide(i, d)) continue;\n          int hv = zh.hash(bii.b);\n          if (vis.count(hv)) continue;\n          vis.insert(hv);\n          Q.push(bii);\n        }\n      }\n    }\n  }\n  cout << \"NA\" << endl;\nEND:\n  ;\n  return 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include <cstdio>\n#include <cstring>\n#include <algorithm>\n\nusing namespace std;\n\nint fie[5][5];\nint o_fie[5][5]={\n\t-1,-1,0,-1,-1,\n\t-1,1,2,3,-1,\n\t4,5,6,7,8,\n\t-1,9,10,11,-1\n\t-1,-1,0,-1,-1,\n};\n\nint ox[12],oy[12],zx[2],zy[2],zcnt;\nint res;\nbool flag;\n\nint dx[4]={1,0,-1,0};\nint dy[4]={0,1,0,-1};\n\nvoid dfs(int v,int dist){\n\tif(flag)return;\n\tif(dist==0){\n\t\tflag=true;\n\t\treturn;\n\t}\n\tfor(int i=0;i<4;i++){\n\t\tfor(int j=0;j<2;j++){\n\t\t\tint nx=zx[j]+dx[i],ny=zy[j]+dy[i];\n\t\t\tif(nx>=0 && nx<5 && ny>=0 && ny<5){\n\t\t\t\tif(fie[nx][ny]<=0)continue;\n\t\t\t\tint ch=fie[nx][ny];\n\t\t\t\tint ndist=dist;\n\t\t\t\tndist-=abs(ox[ch]-nx)+abs(oy[ch]-ny);\n\t\t\t\tswap(fie[nx][ny],fie[zx[j]][zy[j]]);\n\t\t\t\tndist+=abs(ox[ch]-zx[j])+abs(oy[ch]-zy[j]);\n\t\t\t\tzx[j]+=dx[i];\n\t\t\t\tzy[j]+=dy[i];\n\t\t\t\tif(v+1+ndist<=res)dfs(v+1,ndist);\n\t\t\t\tswap(fie[nx][ny],fie[zx[j]][zy[j]]);\n\t\t\t\tzx[j]-=dx[i];\n\t\t\t\tzy[j]-=dy[i];\n\t\t\t}\n\t\t}\n\t}\n}\nint dist;\n\nint main(void){\n\tfor(int i=0;i<5;i++){\n\t\tfor(int j=abs(2-i);j<=4-abs(2-i);j++){\n\t\t\tox[o_fie[i][j]]=j;\n\t\t\toy[o_fie[i][j]]=i;\n\t\t}\n\t}\n\twhile(1){\n\t\tmemset(fie,-1,sizeof(fie));\n\t\tdist=0;\n\t\tzcnt=0;\n\t\tfor(int i=0;i<5;i++){\n\t\t\tfor(int j=abs(2-i);j<=4-abs(2-i);j++){\n\t\t\t\tscanf(\"%d\",&fie[j][i]);\n\t\t\t\tif(fie[j][i]==-1)return 0;\n\t\t\t}\n\t\t}\n\t\tfor(int i=0;i<5;i++){\n\t\t\tfor(int j=abs(2-i);j<=4-abs(2-i);j++){\n\t\t\t\tint v=fie[j][i];\n\t\t\t\tif(v==0){\n\t\t\t\t\tzx[zcnt]=j;\n\t\t\t\t\tzy[zcnt++]=i;\n\t\t\t\t}else dist+=abs(ox[v]-j)+abs(oy[v]-i);\n\t\t\t}\n\t\t}\n\t\tif(dist>20){\n\t\t\tprintf(\"NA\\n\");\n\t\t}else{\n\t\t\tint i=0;\n\t\t\tflag=false;\n\t\t\twhile(i+dist<=20){\n\t\t\t\tres=i+dist;\n\t\t\t\tdfs(0,dist);\n\t\t\t\tif(flag){\n\t\t\t\t\tprintf(\"%d\\n\",i+dist);\n\t\t\t\t\tbreak;\n\t\t\t\t}\n\t\t\t}\n\t\t\tif(!flag)printf(\"NA\\n\");\n\t\t}\n\t}\n\treturn 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include <iostream>\n#include <vector>\n#include <algorithm>\n#include <queue>\n#include <set>\n#include <cstring>\n#include <cstdlib>\nusing namespace std;\n\n\nconst int INF=100000000;\n// ®©¹éêði[·éXg\nvector<int> d[13];\n\n// »ê¼êÌê©çá¤êÖÚ®·éÌÉKvÈ}nb^£\nint mhd[13][13];\nconst int V=13;\n\nvoid warshall_floyd(){\n    for(int k = 0; k < V; k++)\n        for(int i = 0; i < V; i++)\n            for(int j = 0; j < V; j++)\n                mhd[i][j]=min(mhd[i][j],mhd[i][k]+mhd[k][j]);\n}\n\nint main(){\n\n    d[0].push_back(2);\n\n    d[1].push_back(2);\n    d[1].push_back(5);\n\n    d[2].push_back(0);\n    d[2].push_back(1);\n    d[2].push_back(3);\n    d[2].push_back(6);\n\n    d[3].push_back(2);\n    d[3].push_back(7);\n\n    d[4].push_back(5);\n\n    d[5].push_back(1);\n    d[5].push_back(4);\n    d[5].push_back(6);\n    d[5].push_back(4);\n\n    d[6].push_back(2);\n    d[6].push_back(5);\n    d[6].push_back(7);\n    d[6].push_back(10);\n\n    d[7].push_back(3);\n    d[7].push_back(6);\n    d[7].push_back(8);\n    d[7].push_back(11);\n\n    d[8].push_back(7);\n\n    d[9].push_back(5);\n    d[9].push_back(10);\n\n    d[10].push_back(6);\n    d[10].push_back(9);\n    d[10].push_back(11);\n    d[10].push_back(12);\n\n    d[11].push_back(10);\n    d[11].push_back(7);\n\n    d[12].push_back(10);\n\n    for(int i = 0; i < 13; i++)\n        for(int j = 0; j < 13; j++)\n            mhd[i][j]=INF;\n    \n    for(int i = 0; i < 13; i++){\n        mhd[i][i]=0;\n        // ¼Ú¹ª éÆ±ëÉRXg1ðãü\n        for(int j = 0; j < d[i].size(); j++){\n            int to=d[i][j];\n            mhd[i][to]=1;\n        }\n    }\n\n    warshall_floyd();\n\n    while(1){\n        set<vector<int> > no;\n        vector<int> v;\n        int cost=0;\n        for(int j = 0; j < 13; j++){\n            int t;\n            cin>>t;\n            if(t==-1)\n                return 0;\n            v.push_back(t);\n            if(t!=0)\n                cost+=mhd[t][j];\n        }\n        // Å©ç»ëÁÄ¢éê\n        if(cost==0){\n            cout<<0<<endl;\n            continue;\n        }\n        queue<pair<int,vector<int> > > *prv=new queue<pair<int,vector<int> > >();\n        queue<pair<int,vector<int> > > *nxt=new queue<pair<int,vector<int> > >();\n        prv->push(make_pair(cost,v));\n        int cnt=0;\n        bool isGoal=false;\n        // 20èÜÅTõð©¯é\n        while(prv->size()){\n            while(prv->size()){\n                vector<int> b=prv->front().second;\n                int cos=prv->front().first;    \n                prv->pop();\n                vector<int> emp;\n                for(int i = 0; i < b.size(); i++)\n                    if(b[i]==0)\n                        emp.push_back(i);\n                // óÌêðêÂIÑAJÚ·é\n                for(int i = 0; i < emp.size(); i++){\n                    int num=emp[i];\n                    for(int j = 0; j < d[num].size(); j++){\n                        // ¡ñg¤board\n                        vector<int> bt=b;\n                        // Ú®æ\n                        int to=d[num][j];\n                        if(bt[to]==0)\n                            continue;\n                        swap(bt[to],bt[num]);\n                        if(no.find(bt)!=no.end())\n                            continue;\n                        no.insert(bt);\n                        // Ú®æÌ]¿l(0ÉÈÁ½çI¹)\n                        int toCost=cos-mhd[to][b[to]]+mhd[b[to]][num];\n                        // goal\n                        if(toCost==0){\n                            isGoal=true;\n                            break;\n                        }\n                        // »Ýn_©çS[É½Çè¯é©Ç¤©\n                        // ³Èç}ëè\n                        if(!(toCost>(19-cnt)))\n                            nxt->push(make_pair(toCost,bt));\n                    }\n                }\n                if(isGoal)\n                    break;\n            }\n            if(isGoal)\n                break;\n            swap(prv,nxt);\n            cnt++;\n            // 20èðz¦Ä¢é\n            if(cnt>=20){\n                break;\n            }\n        }\n        if(isGoal){\n            cout<<cnt+1<<endl;\n        }\n        else{\n            cout<<\"NA\"<<endl;\n        }\n        delete prv,nxt;\n    }\n\n    return 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include <cstdio>\n#include <cstdlib>\n#include <cmath>\n#include <climits>\n#include <cfloat>\n#include <map>\n#include <utility>\n#include <set>\n#include <iostream>\n#include <memory>\n#include <string>\n#include <vector>\n#include <algorithm>\n#include <functional>\n#include <sstream>\n#include <complex>\n#include <stack>\n#include <queue>\n#include <cstring>\n#include <sstream>\n#include <cassert>\n#include <list>\nusing namespace std;\nstatic const double EPS = 1e-10;\ntypedef long long ll;\ntypedef pair<int,int> PI;\ntypedef vector<int> vi;\n#ifndef M_PI\n#define M_PI 3.14159265358979323846\n#endif\n#define rep(i,n) for(int i=0;i<(int)n;++i)\n#define FOR(i,c) for(__typeof((c).begin())i=(c).begin();i!=(c).end();++i)\n#define ALL(c) (c).begin(), (c).end()\n#define mp(a,b) make_pair(a,b)\n#define pb(a) push_back(a)\n#define F first\n#define S second\ntemplate <typename T> string print_array(const vector<T> &V) { ostringstream os; os << \"{ \"; for (typename vector<T>::const_iterator iter = V.begin(); iter != V.end(); ++iter) os << '\\\"' << *iter << \"\\\",\"; os << \" }\"; return os.str(); }\n\nint dx[]={0,1,0,-1},dy[]={1,0,-1,0};\n\nvector<int> se[13];\nint x[]={0,-1,0,1,-2,-1,0,1,2,-1,0,1,0};\nint y[]={2,1,1,1,0,0,0,0,0,-1,-1,-1,-2};\n\nvoid pr(ll in){\n\n  printf(\"      %3lld\\n\",in&15);\n  printf(\"   %3lld%3lld%3lld\\n\",(in>>4)&15,(in>>8)&15,(in>>12)&15);\n  printf(\"%3lld%3lld%3lld%3lld%3lld\\n\",(in>>16)&15,(in>>20)&15,(in>>24)&15,(in>>28)&15,(in>>32)&15);\n  printf(\"   %3lld%3lld%3lld\\n\",(in>>36)&15,(in>>40)&15,(in>>44)&15);\n  printf(\"      %3lld\\n\",(in>>48)&15);\n  puts(\"\");\n}\n\nint manh(ll in){\n  int ret=0;\n  rep(i,13){\n    int t=(in>>(i*4))&15;\n\n    if(!t)continue;\n    int nx=(x[t]-x[i]),ny=y[t]-y[i];\n    ret+=abs(nx)+abs(ny);\n  }\n  return ret;\n}\n\nmain(){\n  ll p;\n\n  ll goal=0;\n  rep(i,11){\n    goal|=(i+1LL)<<(4*(i+1));\n    //cout<<goal<<endl;\n    //pr(goal);\n  }\n  //pr(goal);\n\n  se[0].pb(2);\n  se[1].pb(2);\n  se[1].pb(5);\n  se[2].pb(0);\n  se[2].pb(1);\n  se[2].pb(3);\n  se[2].pb(6);\n  se[3].pb(2);\n  se[3].pb(7);\n  se[4].pb(5);\n  se[5].pb(1);\n  se[5].pb(4);\n  se[5].pb(6);\n  se[5].pb(9);\n  se[6].pb(2);\n  se[6].pb(5);\n  se[6].pb(7);\n  se[6].pb(10);\n  se[7].pb(3);\n  se[7].pb(6);\n  se[7].pb(8);\n  se[7].pb(11);\n  se[8].pb(7);\n  se[9].pb(5);\n  se[9].pb(10);\n  se[10].pb(6);\n  se[10].pb(9);\n  se[10].pb(11);\n  se[10].pb(12);\n  se[11].pb(7);\n  se[11].pb(10);\n  se[12].pb(10);\n  \n  while(cin>>p){\n    if(p==-1)break;\n    ll in=p;\n\n    rep(i,12){\n      cin>>p;\n      in|=p<<(4*(i+1));\n    }\n\n    set<ll> app;\n\n    queue<pair<int,ll> > Q;\n    app.insert(in);\n    Q.push(mp(0,in));\n    int ans=21;\n    int mans=0;\n\n    while(!Q.empty()){\n      ll cvec=Q.front().S;\n      int ccost=Q.front().F;\n      Q.pop();\n    \n      //pr(cvec);\n\n      //if(ccost>3)break;\n      if(ccost+manh(cvec)+18>20)continue;\n      if(cvec==goal){\n\tans=ccost;\n\tbreak;\n      }\n      rep(i,13){\n\tll t=cvec>>(i<<2);\n\tt=t&15;\n\tif(!t){\n\t  rep(j,se[i].size()){\n\t    t=cvec>>(se[i][j]<<2);\n\t    t=t&15;\n\t    if(t){\n\t      ll nvec=cvec;\n\t      t=t<<(i<<2);\n\t      nvec|=t;\n\t      nvec&=~(15LL<<se[i][j]*4);\n\t      \n\t      if(!app.count(nvec)){\n\t\tapp.insert(nvec);\n\t\tQ.push(mp(ccost+1,nvec));\n\t      }\n\t    }\n\t  }\n\t}\n      }\n    }\n    if(ans==21)cout<<\"NA\"<<endl;\n    else cout<<ans<<endl;\n  }\n}"
  },
  {
    "language": "C++",
    "code": "#include <iostream>\n#include <cstdio>\n#include <cstring>\n#include <algorithm>\n#include <vector>\n#include <queue>\n#include <map>\nusing namespace std;\n\ntypedef vector<int> VI;\n\nint size[13] = {1, 2, 4, 2, 1, 4, 4, 4, 1, 2, 4, 2, 1};\nint move[13][4] = {\n  {2},\n  {2, 5},\n  {0, 1, 6, 3},\n  {2, 7},\n  {5},\n  {1, 4, 6, 9},\n  {2, 5, 7, 10},\n  {3, 6, 8, 11},\n  {7},\n  {5, 10},\n  {6, 9, 11, 12},\n  {7, 10},\n  {10}\n};\n\nVI v;\nmap<VI, int> mp;\nmap<VI, int> mp2;\n\nvoid make(){\n  VI goal;\n  for(int i = 0 ; i < 13 ; i++){\n    if(i == 0 || i == 12) goal.push_back(0);\n    else goal.push_back(i);    \n  }\n  \n  queue<VI> que;\n  que.push(goal);\n  mp2[goal] = 0;\n  \n  while(!que.empty()){\n    VI q = que.front(); que.pop();    \n    if(mp2[q] > 11) continue;\n    for(int i = 0 ; i < 13 ; i++){\n      if(q[i] != 0) continue;\n      for(int j = 0 ; j < size[i] ; j++){\n\tVI t = q;\n\tswap(t[i], t[ move[i][j] ]);\n\tif(mp2.find(t) != mp2.end()) continue;\t\n\tmp2[t] = mp2[q] + 1;\t\n\tque.push(t);\n      }\n    }\n  }\n}\n    \n\n\nint bfs(){\n  queue<VI> que;\n  que.push(v);\n  mp[v] = 0;  \n  while(!que.empty()){\n    VI q = que.front(); que.pop();    \n    if(mp2.find(q) != mp2.end()){\n      return mp2[q] + mp[q];\n    }\n    \n    if(mp[q] > 10) continue;\n    for(int i = 0 ; i < 13 ; i++){\n      if(q[i] != 0) continue;      \n      for(int j = 0 ; j < size[i] ; j++){\n\tVI t = q;\n\tswap(t[i], t[ move[i][j] ]);\n\tif(mp.find(t) != mp.end()) continue;\n\tmp[t] = mp[q] + 1;\n\tque.push(t);\n      }\n    }\n  }\n  return -1;\n}\n\nvoid init(){\n  v.clear();\n  mp.clear();  \n}\n\nint main(){\n  make();\n  int n;\n  while(cin >> n){\n    if(n == -1) break;\n    \n    init();\n    \n    v.push_back(n);\n    for(int i = 0 ; i < 12 ; i++){ cin >> n; v.push_back(n); }\n    \n    int ans = bfs();\n    if(ans == -1 || ans > 20) cout << \"NA\" << endl;\n    else cout << ans << endl;\n  }\n  \n\n  return 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include <algorithm>\n#include <cctype>\n#include <climits>\n#include <cmath>\n#include <cstdio>\n#include <cstdlib>\n#include <cstring>\n#include <functional>\n#include <map>\n#include <numeric>\n#include <queue>\n#include <set>\n#include <sstream>\n#include <string>\n#include <vector>\n\nusing namespace std;\n\n#define reps(i,f,n) for(int i=f; i<int(n); ++i)\n#define rep(i,n) reps(i,0,n)\n\ntypedef long long ll;\ntypedef vector<int> vi;\ntypedef vector<vi> vvi;\ntypedef pair<int, int> pii;\n\nconst int INF = 1001001001;\nconst ll FINAL = 0x0ba9876543210ll;\n\nstruct Data\n{\n\tll s;\n\tint d;\n\tbool f;\n\tData(ll s, int d, bool f) : s(s), d(d), f(f) {}\n};\n\nint bfs(ll init)\n{\n\tif(init == FINAL)\n\t\treturn 0;\n\t\n\tconst int move[13][5] = {\n\t\t{2, -1},\n\t\t{2, 5, -1},\n\t\t{0, 1, 3, 6, -1},\n\t\t{2, 7, -1},\n\t\t{5, -1},\n\t\t{1, 4, 6, 9, -1},\n\t\t{2, 5, 7, 10, -1},\n\t\t{3, 6, 8, 11, -1},\n\t\t{7, -1},\n\t\t{5, 10, -1},\n\t\t{6, 9, 11, 12, -1},\n\t\t{7, 10, -1},\n\t\t{10, -1}\n\t};\n\t\n\tset<ll> visited[2];\n\tqueue<Data> Q;\n\tQ.push(Data(init, 0, false));\n\tQ.push(Data(FINAL, 0, true));\n\tvisited[0].insert(init);\n\tvisited[1].insert(FINAL);\n\tint now[2] = {0};\n\t\n\twhile(!Q.empty()){\n\t\tData data = Q.front();\n\t\tQ.pop();\n\n\t\tfor(int i=0, cnt=2; cnt; ++i){\n\t\t\tif(((data.s>>(i*4)) & 0xfll) == 0){\n\t\t\t\tfor(int j=0; move[i][j]!=-1; ++j){\n\t\t\t\t\tll next = data.s;\n\t\t\t\t\tnext &= ~((0xfll << (i*4)) | (0xfll << (move[i][j]*4)));\n\t\t\t\t\tnext |= ((data.s >> (move[i][j]*4)) & 0xfll) << (i*4);\n\t\t\t\t\t\n\t\t\t\t\tif(visited[!data.f].find(next) != visited[!data.f].end())\n\t\t\t\t\t\treturn now[0] + now[1] + 1;\n\n\t\t\t\t\tif(visited[data.f].find(next) == visited[data.f].end()){\n\t\t\t\t\t\tvisited[data.f].insert(next);\n\t\t\t\t\t\tif(now[0]+now[1] < 19){\n\t\t\t\t\t\t\tnow[data.f] = data.d + 1;\n\t\t\t\t\t\t\tQ.push(Data(next, data.d+1, data.f));\n\t\t\t\t\t\t}\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t\t--cnt;\n\t\t\t}\n\t\t}\n\t}\n\treturn -1;\n}\n\nint main()\n{\n\tfor(;;){\n\t\tint input[13];\n\t\trep(i, 13){\n\t\t\tscanf(\"%d\", &input[i]);\n\t\t\tif(input[i] == -1)\n\t\t\t\treturn 0;\n\t\t}\n\n\t\tll init = 0;\n\t\trep(i, 13)\n\t\t\tinit = (init << 4) | input[12-i];\n\n\t\tint ans = bfs(init);\n\t\tif(ans == -1)\n\t\t\tputs(\"NA\");\n\t\telse\n\t\t\tprintf(\"%d\\n\", ans);\n\t}\n}"
  },
  {
    "language": "C++",
    "code": "#include <iostream>\n#include <cstdio>\n#include <vector>\n#include <map>\n#include <string>\n#include <queue>\n#include <algorithm>\nusing namespace std;\n\ntypedef pair<int,int> P;\nconst int INF = 1e+8;\nconst int f1[25] = {\n\t-1,-1, 0,-1,-1,\n\t-1, 1, 2, 3,-1,\n\t 4, 5, 6, 7, 8,\n\t-1, 9,10,11,-1,\n\t-1,-1,12,-1,-1,\n};\nconst int f2[13] = {2,6,7,8,10,11,12,13,14,16,17,18,22};\nconst int dx[4] = { 0,-1,+1, 0};\nconst int dy[4] = {-1, 0, 0,+1};\n\n// パズル\nstruct Pazzle{\n\tstring v;\n\tPazzle(){v = \"*************\"; }\n\tvoid at(int i, int p){\n\t\tv[i] = p;\n\t}\n\t// 空白の位置を返す. (k は 0 or 1)\n\tint search(int k){\n\t\tint a = 0;\n\t\tfor(int i=0 ; i < 13 ; i++ ){\n\t\t\tif( v[i] == 0 ){\n\t\t\t\tif( k == 0 ){\n\t\t\t\t\treturn i;\n\t\t\t\t}else{\n\t\t\t\t\tif( a == 0 ) a++;\n\t\t\t\t\telse return i;\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t\treturn -1;\n\t}\n\t// 合っている数\n\tint to_g(){\n\t\tint res = 13;\n\t\tfor(int i=0 ; i < 12 ; i++ ){\n\t\t\tif( i != v[i] ) res--;\n\t\t}\n\t\tif( v[12] != 0 ) res--;\n\t\treturn res;\n\t}\n\t// 空白 k (0 or 1) を 方向 dir に動かす.\n\t// 動かせる時は true, 動かせなかったときは false を返す.\n\tbool move(int dir, int k){\n\t\tif( dir < 0 || 4 <= dir || k < 0 || 2 <= k ) return false;\n\t\tint pos1 = search(k);\n\t\tint x = f2[pos1] % 5;\n\t\tint y = f2[pos1] / 5;\n\t\tint mx = x + dx[dir];\n\t\tint my = y + dy[dir];\n\t\tif( mx < 0 || my < 0 || 5 <= mx || 5 <= my ) return false;\n\t\tint pos2 = f1[my*5+mx];\n\t\tif( pos2 == -1 ) return false;\n\t\tif( v[pos1] == v[pos2] ) return false;\n\t\tswap( v[pos1] , v[pos2] );\n\t\treturn true;\n\t}\n\t// 完成しているかどうか\n\tbool is_goal(){\n\t\tfor(int i=0 ; i < 12 ; i++ ){\n\t\t\tif( v[i] != i ) return false;\n\t\t}\n\t\treturn v[12] == 0;\n\t}\n\tvoid debug(){\n\t\tprintf(\"[debug]\\n\");\n\t\tfor(int y=0 ; y < 5 ; y++ ){\n\t\t\tfor(int x=0 ; x < 5 ; x++ ){\n\t\t\t\tif( f1[y*5+x] == -1 ){\n\t\t\t\t\tprintf(\"##\");\n\t\t\t\t}else{\n\t\t\t\t\tprintf(\"%2d\", (int)v[f1[y*5+x]] );\n\t\t\t\t}\n\t\t\t}\n\t\t\tprintf(\"\\n\");\n\t\t}\n\t\tprintf(\"\\n\");\n\t}\n};\n\n// (コスト,スタートからの距離,パズルの状態)\n// コスト は (合っている数,-スタートからの距離)\nstruct State{\n\tPazzle p;\n\tint cnt;\n\tP cost;\n\tState(int cost_, int cnt_, const Pazzle& p_){\n\t\tcost = P(cost_,-cnt_); cnt = cnt_; p = p_;\n\t}\n};\nbool operator<(const State& a, const State& b){\n\treturn a.cost < b.cost;\n}\n\nint solve(Pazzle p){\n\t// (コスト,スタートからの距離,パズルの状態) を優先度つきキューへ\n\tpriority_queue<State> q;\n\tq.push( State(p.to_g(),0,p) );\n\t\n\tint res = 21;\n\tint low = p.to_g() - 3;\n\tif( low < 0 ) low = 0;\n\tint foo=0;\n\twhile( !q.empty() ){\n\t\tPazzle p = q.top().p;\n\t\tint cnt = q.top().cnt;\n\t\tq.pop();\n\t\t\n\t\tif( p.is_goal() ){\n\t\t\tres = min( res , cnt );\n\t\t\tcontinue;\n\t\t\t//break;\n\t\t}\n\t\tfoo++;\n\t\tif( 100000 < foo ) break;\n\t\tif( low < p.is_goal() ) continue;\n\t\tif( res <= cnt + (13-p.is_goal()) ) continue;\n\t\t\n\t\tfor(int k=0 ; k <= 1 ; k++ ){\n\t\t\tfor(int i=0 ; i < 4 ; i++ ){\n\t\t\t\tPazzle p_ = p;\n\t\t\t\tif( p_.move(i,k) ){\n\t\t\t\t\tq.push( State(p_.to_g(),cnt+1,p_) );\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t}\n\treturn res;\n}\n\nint main(){\n\tint p1;\n\twhile( cin >> p1 , p1 != -1 ){\n\t\tPazzle p;\n\t\tp.at(0,p1);\n\t\tfor(int i=1 ; i < 13 ; i++ ){\n\t\t\tcin >> p1;\n\t\t\tp.at(i,p1);\n\t\t}\n\t\tint ans = solve(p);\n\t\tif( ans == 21 ){\n\t\t\tcout << \"NA\" << endl;\n\t\t}else{\n\t\t\tcout << ans << endl;\n\t\t}\n\t}\n}"
  },
  {
    "language": "C++",
    "code": "#include <iostream>\n#include <queue>\n#include <set>\nusing namespace std;\ntypedef long long ll;\n\nll mov[13][4] = {\n\t{2,-1,-1,-1},\n\t{2,5,-1,-1},\n\t{0,1,3,6},\n\t{2,7,-1,-1},\n\t{5,-1,-1,-1},\n\t{1,4,6,9},\n\t{2,5,7,10},\n\t{3,6,8,11},\n\t{7,-1,-1,-1},\n\t{5,10,-1,-1},\n\t{6,9,11,12},\n\t{7,10,-1,-1},\n\t{10,-1,-1,-1},\n};\n\nll sw(ll l, int i, int j) {\n\tint a, b;\n\ta = (l >> (4 * i)) & 0xfL;\n\tb = (l >> (4 * j)) & 0xfL;\n\n\tl &= ~(0xfL << (4*i));\n\tl &= ~(0xfL << (4*j));\n\n\tl |= (ll)b << (4 * i);\n\tl |= (ll)a << (4 * j);\n\n\treturn l;\n}\n\nint main() {\n\twhile(1) {\n\t\tll in = 0;\n\t\tfor(int i = 0; i < 13; i++) {\n\t\t\tint tmpin;\n\t\t\tcin >> tmpin;\n\t\t\tif(tmpin < 0)\n\t\t\t\treturn 0;\n\t\t\tin |= ((ll)tmpin << (4*i));\n\t\t}\n\n\t\tqueue<ll> q;\n\t\tset<ll> s;\n\t\tq.push(in);\n\t\ts.insert(in);\n\t\tint ans = -1;\n\t\t// debug\n\t\tint failcount = 0;\n\t\tfor(int i = 0; i <= 20; i++) {\n\t\t\tqueue<ll> next;\n\t\t\twhile(!q.empty()) {\n\t\t\t\tll l = q.front(); q.pop();\n\t\t\t\tif(l == 0xba9876543210) {\n\t\t\t\t\tans = i;\n\t\t\t\t\tgoto OUTPUT_ANSWER;\n\t\t\t\t}\n\t\t\t\telse {\n\t\t\t\t\tint cnt = 0;\n\t\t\t\t\tfor(int j = 0; j < 13; j++) {\n\t\t\t\t\t\tll t = 0xba9876543210;\n\t\t\t\t\t\tif(((l >> 4*j) & 0xfL) != ((t >> 4*j) & 0xfL)) {\n\t\t\t\t\t\t\tcnt++;\n\t\t\t\t\t\t}\n\t\t\t\t\t}\n\t\t\t\t\tif(cnt > 20 - i + 2)\n\t\t\t\t\t\tcontinue;\n\t\t\t\t}\n\n\t\t\t\tfor(int j = 0; j < 13; j++) {\n\t\t\t\t\tif(((l >> (4*j)) & 0xfL) == 0) {\n\t\t\t\t\t\tfor(int k = 0; k < 4; k++) {\n\t\t\t\t\t\t\tll p;\n\t\t\t\t\t\t\tif(mov[j][k] < 0)\n\t\t\t\t\t\t\t\tbreak;\n\t\t\t\t\t\t\tp = sw(l, j, mov[j][k]);\n\t\t\t\t\t\t\tif(s.find(p) == s.end()) {\n\t\t\t\t\t\t\t\ts.insert(p);\n\t\t\t\t\t\t\t\tnext.push(p);\n\t\t\t\t\t\t\t}\n\t\t\t\t\t\t\telse {\n\t\t\t\t\t\t\t\tfailcount++;\n\t\t\t\t\t\t\t}\n\t\t\t\t\t\t}\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t}\n\t\t\tq = next;\n\t\t}\n\nOUTPUT_ANSWER:;\n\t\tif(ans < 0)\n\t\t\tcout << \"NA\" << endl;\n\t\telse\n\t\t\tcout << ans << endl;\n//\t\tcout << failcount << endl;\n\t}\n}"
  },
  {
    "language": "C++",
    "code": "#include <iostream>\n#include <stdlib.h>\nusing namespace std;\n\nint p[5][5],x[11]={1,2,3,0,1,2,3,4,1,2,3},y[11]={1,1,1,2,2,2,2,2,3,3,3},s,sx[2],sy[2]\n    ,mx[4]={1,0,-1,0},my[4]={0,-1,0,1},lt;\nint search(int t,int mx2,int my2,int mc) {\n\tint a,i,j,x2,y2,s2;\n\tif (s==0) { if (lt>t) lt=t; return 1;}\n\t  for (i=0;i<2;i++) for (j=0;j<4;j++) {\n\t  x2=sx[i]+mx[j]; y2=sy[i]+my[j];\n\t  if (x2<0 || x2>4 || y2<0 || y2>4) continue;\n\t  if (p[y2][x2]<1 || ( mc==i  && mx2==-mx[j] && my2==-my[j])) continue;\n\t  s2=abs(x2-x[p[y2][x2]-1])+abs(y2-y[p[y2][x2]-1])-abs(sx[i]-x[p[y2][x2]-1])-abs(sy[i]-y[p[y2][x2]-1]);\n\t  if (s+s2>lt-t+1) continue;\n\t  p[sy[i]][sx[i]]=p[y2][x2]; p[y2][x2]=0;  s+=s2; \n\t  sx[i]=x2; sy[i]=y2;\n\t  a=search(t+1,mx[j],my[j],i);\n\t  sx[i]=x2-mx[j]; sy[i]=y2-my[j];\n\t  p[y2][x2]=p[sy[i]][sx[i]]; p[sy[i]][sx[i]]=0; s-=s2;\n\t  if (a==1) return 0;\n  }\n  return 0;\n}\n\nint main() {\n  int i,j,k;\n  for (i=0;i<5;i++) for (j=0;j<5;j++) p[i][j]=-1;\n  while (cin >> p[0][2] && p[0][2]!=-1) {\n\t  cin >> p[1][1] >> p[1][2] >> p[1][3];\n\t  cin >> p[2][0] >> p[2][1] >> p[2][2] >> p[2][3] >> p[2][4];\n\t  cin >> p[3][1] >> p[3][2] >> p[3][3];\n\t  cin >> p[4][2]; k=0; s=0;\n\t  for (i=0;i<5;i++) for (j=0;j<5;j++) {\n\t\t  if (p[i][j]==0) { sx[k++]=j; sy[k++]=i;}\n\t\t  if (p[i][j]>0) s+=abs(j-x[p[i][j]-1])+abs(i-y[p[i][j]-1]);\n\t\t   }\n\t  lt=21;\t   \n\t  search(0,0,0,0);\n\t  if (lt==21) cout << \"NA\" << endl; else cout << lt << endl;\n  } \n return 0;\n}\t"
  },
  {
    "language": "C++",
    "code": "#include <algorithm>\n#include <cctype>\n#include <climits>\n#include <cmath>\n#include <cstdio>\n#include <cstdlib>\n#include <cstring>\n#include <functional>\n#include <map>\n#include <numeric>\n#include <queue>\n#include <set>\n#include <unordered_set>\n#include <vector>\n\nusing namespace std;\n\n#define reps(i,f,n) for(int i=f; i<int(n); ++i)\n#define rep(i,n) reps(i,0,n)\n\ntypedef long long ll;\ntypedef vector<int> vi;\ntypedef vector<vi> vvi;\ntypedef pair<int, int> pii;\n\nconst int INF = 1001001001;\nconst ll FINAL = 0x0ba9876543210ll;\n\nstruct Data\n{\n\tll s;\n\tint d;\n\tbool f;\n\tData(ll s, int d, bool f) : s(s), d(d), f(f) {}\n};\n\nint bfs(ll init)\n{\n\tif(init == FINAL)\n\t\treturn 0;\n\t\n\tconst int move[13][5] = {\n\t\t{2, -1},\n\t\t{2, 5, -1},\n\t\t{0, 1, 3, 6, -1},\n\t\t{2, 7, -1},\n\t\t{5, -1},\n\t\t{1, 4, 6, 9, -1},\n\t\t{2, 5, 7, 10, -1},\n\t\t{3, 6, 8, 11, -1},\n\t\t{7, -1},\n\t\t{5, 10, -1},\n\t\t{6, 9, 11, 12, -1},\n\t\t{7, 10, -1},\n\t\t{10, -1}\n\t};\n\t\n\tunordered_set<ll> visited[2];\n\tqueue<Data> Q;\n\tQ.push(Data(init, 0, false));\n\tQ.push(Data(FINAL, 0, true));\n\tvisited[0].insert(init);\n\tvisited[1].insert(FINAL);\n\tint now[2] = {0};\n\t\n\twhile(!Q.empty()){\n\t\tData data = Q.front();\n\t\tQ.pop();\n\t\tnow[data.f] = data.d + 1;\n\n\t\tfor(int i=0, cnt=2; cnt; ++i){\n\t\t\tif(((data.s>>(i*4)) & 0xfll) == 0){\n\t\t\t\tfor(int j=0; move[i][j]!=-1; ++j){\n\t\t\t\t\tll next = data.s;\n\t\t\t\t\tnext &= ~((0xfll << (i*4)) | (0xfll << (move[i][j]*4)));\n\t\t\t\t\tnext |= ((data.s >> (move[i][j]*4)) & 0xfll) << (i*4);\n\t\t\t\t\t\n\t\t\t\t\tif(visited[!data.f].find(next) != visited[!data.f].end())\n\t\t\t\t\t\treturn now[0] + now[1];\n\n\t\t\t\t\tif(visited[data.f].find(next) == visited[data.f].end()){\n\t\t\t\t\t\tvisited[data.f].insert(next);\n\t\t\t\t\t\tif(data.d <= 8)\n\t\t\t\t\t\t\tQ.push(Data(next, data.d+1, data.f));\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t\t--cnt;\n\t\t\t}\n\t\t}\n\t}\n\treturn -1;\n}\n\nint main()\n{\n\tfor(;;){\n\t\tint input[13];\n\t\trep(i, 13){\n\t\t\tscanf(\"%d\", &input[i]);\n\t\t\tif(input[i] == -1)\n\t\t\t\treturn 0;\n\t\t}\n\n\t\tll init = 0;\n\t\trep(i, 13)\n\t\t\tinit = (init << 4) | input[12-i];\n\n\t\tint ans = bfs(init);\n\t\tif(ans == -1)\n\t\t\tputs(\"NA\");\n\t\telse\n\t\t\tprintf(\"%d\\n\", ans);\n\t}\n}"
  },
  {
    "language": "C++",
    "code": "#include<iostream>\n#include<cmath>\n#include<stdio.h>\nusing namespace std;\n\n#define LIMIT 20\n\nstruct Puzzle {\n  int cont[25];\n  int space[2];\n};\n\nint limit;\n\nPuzzle puzzle;\n\nint tx[12]={0,1,2,3,0,1,2,3,4,1,2,3};\nint ty[12]={0,1,1,1,2,2,2,2,2,3,3,3};\nint dx[4]={0,1,0,-1};\nint dy[4]={-1,0,1,0};\n\nint heuris[12][25];\n\nint getHeuristic(){\n  int res=0;\n  for(int i=0;i<25;i++){\n    if(puzzle.cont[i]==-1||puzzle.cont[i]==0)continue;\n    res+=heuris[puzzle.cont[i]][i];\n  }\n  return res;\n}\n\nbool dfs(int depth,int prev0,int prev1){\n  /*\n  cout<<depth<<endl;\n  for(int i=0;i<5;i++){\n    for(int j=0;j<5;j++){\n      if(puzzle.cont[i*5+j]!=-1)printf(\"%3d\",puzzle.cont[i*5+j]);\n      else cout<<\"???\";\n    }\n    cout<<endl;\n  }\n  */\n  int heuri;\n  heuri=getHeuristic();\n  if(heuri==0){\n    cout<<depth<<endl;\n    return true;\n  }\n  if(depth + heuri-1>limit)return false;\n\n  int px,py,nx,ny;\n  Puzzle tmp=puzzle;\n\n  py=puzzle.space[0]/5;px=puzzle.space[0]%5;\n\n  for(int i=0;i<4;i++){\n    if(max(prev0,i)-min(prev0,i)==2)continue;\n    ny=py+dy[i];nx=px+dx[i];\n    if(ny<0||ny>=5||nx<0||nx>=5)continue;\n    if(puzzle.cont[ny*5+nx]==-1)continue;\n    if(puzzle.cont[ny*5+nx]==0)continue;\n    puzzle.cont[py*5+px]=puzzle.cont[ny*5+nx];\n    puzzle.cont[ny*5+nx]=0;\n    puzzle.space[0]=ny*5+nx;\n    if(dfs(depth+1,i,prev1))return true;\n    puzzle=tmp;\n  }\n  py=puzzle.space[1]/5;px=puzzle.space[1]%5;\n  for(int i=0;i<4;i++){\n    if(max(prev1,i)-min(prev1,i)==2)continue;\n    ny=py+dy[i];nx=px+dx[i];\n    if(ny<0||ny>=5||nx<0||nx>=5)continue;\n    if(puzzle.cont[ny*5+nx]==-1)continue;\n    if(puzzle.cont[ny*5+nx]==0)continue;\n    puzzle.cont[py*5+px]=puzzle.cont[ny*5+nx];\n    puzzle.cont[ny*5+nx]=0;\n    puzzle.space[1]=ny*5+nx;\n    if(dfs(depth+1,prev0,i))return true;\n    puzzle=tmp;\n  }\n  return false;\n}\n\nvoid solve(){\n  Puzzle tmp=puzzle;\n  for(limit=getHeuristic();limit<=LIMIT;limit++){\n    puzzle=tmp;\n    if(dfs(0,-100,-100))return;\n  }\n  cout<<\"NA\"<<endl;\n}\n\nint main(){\n  int x,y,c=0;\n\n  for(int i=1;i<=11;i++){\n    for(int j=0;j<25;j++){\n      y=j/5;\n      x=j%5;\n      heuris[i][j]=abs(tx[i]-x)+abs(ty[i]-y);\n    }\n  }\n  /*\n  for(int i=1;i<=11;i++){\n    for(int j=0;j<5;j++){\n      for(int k=0;k<5;k++){\n\tcout<<heuris[i][j*5+k]<<' ';\n      }\n      cout<<endl;\n    }\n    cout<<endl;\n  }\n  */\n\n\n  while(1){\n    c=0;\n    for(int i=0;i<25;i++)puzzle.cont[i]=-1;\n\n    cin>>puzzle.cont[2];\n    if(puzzle.cont[2]==-1)break;\n    if(puzzle.cont[2]==0)puzzle.space[c++]=2;\n    \n    \n    for(int i=6;i<=8;i++){\n      cin>>puzzle.cont[i];\n      if(puzzle.cont[i]==0)puzzle.space[c++]=i;\n    }\n    for(int i=10;i<=14;i++){\n      cin>>puzzle.cont[i];\n      if(puzzle.cont[i]==0)puzzle.space[c++]=i;\n    }\n    \n    for(int i=16;i<=18;i++){\n      cin>>puzzle.cont[i];\n      if(puzzle.cont[i]==0)puzzle.space[c++]=i;\n    }\n    \n    cin>>puzzle.cont[22];\n    if(puzzle.cont[22]==0)puzzle.space[c++]=22;\n    solve();\n  }\n\n  return 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include \"bits/stdc++.h\"\n#include<unordered_map>\n#include<unordered_set>\n#pragma warning(disable:4996)\nusing namespace std;\nusing ld = long double;\ntemplate<class T>\nusing Table = vector<vector<T>>;\nconst ld eps=1e-9;\n\n//// < \"D:\\D_Download\\Visual Studio 2015\\Projects\\programing_contest_c++\\Debug\\a.txt\" > \"D:\\D_Download\\Visual Studio 2015\\Projects\\programing_contest_c++\\Debug\\b.answer\"\n\nvector<vector<int>>ans = vector<vector<int>>{\n\tvector<int>{-1,-1,-1,-1,-1,-1,-1},\n\tvector<int>{-1,-1,-1,0,-1,-1,-1},\n\tvector<int>{-1,-1,1,2,3,-1,-1},\n\tvector<int>{-1,4,5,6,7,8,-1},\n\tvector<int>{-1,-1,9,10,11,-1,-1},\n\tvector<int>{-1,-1,-1,0,-1,-1,-1},\n\tvector<int>{-1,-1,-1,-1,-1,-1,-1},\n};\n\n#include<unordered_map>\nclass HashVI {  // ???????????\\??¢??°???????????§??????\npublic:\n\tsize_t operator()(const vector<int> &x) const {\n\t\tconst int C = 997;      // ?´???°\n\t\tsize_t t = 0;\n\t\tfor (int i = 0; i != x.size(); ++i) {\n\t\t\tt = t * C + x[i];\n\t\t}\n\t\treturn t;\n\t}\n\tsize_t operator()(const vector<vector<int>> &x) const {\n\t\tconst int C = 997;      // ?´???°\n\t\tsize_t t = 0;\n\t\tfor (int i = 0; i != x.size(); ++i) {\n\t\t\tfor (int j = 0; j < x[i].size(); ++j) {\n\t\t\t\tt = t * C + x[i][j];\n\t\t\t}\n\t\t}\n\t\treturn t;\n\t}\n};\nint dx[] = { -1,0,1,0 };\nint dy[] = { 0,1,0,-1 };\nint aaa=21;\nvoid solve(vector<vector<int>>&start,const int turn ) {\n\tif (aaa <= turn)return;\n\tif (start == ans) {\n\t\taaa = min(aaa, turn);\n\t}\n\telse {\n\t\tfor (int i = 1; i < 6; ++i) {\n\t\t\tfor (int j = 1; j < 6; ++j) {\n\t\t\t\tif (start[i][j] == 0) {\n\t\t\t\t\tfor (int way = 0; way < 4; ++way) {\n\t\t\t\t\t\tif (start[i + dy[way]][j + dx[way]]>0) {\n\t\t\t\t\t\t\tswap(start[i][j],start[i + dy[way]][j + dx[way]]);\n\t\t\t\t\t\t\tif (start == ans) {\n\t\t\t\t\t\t\t\taaa = min(aaa, turn);\n\t\t\t\t\t\t\t}\n\t\t\t\t\t\t\telse {\n\n\t\t\t\t\t\t\t\tsolve(start, turn+1);\n\t\t\t\t\t\t\t}\n\t\t\t\t\t\t\tswap(start[i][j], start[i + dy[way]][j + dx[way]]);\n\t\t\t\t\t\t}\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t}\n\t\n}\n\nint main() {\n\twhile (1) {\n\t\tint a; cin >> a;\n\t\tif (a == -1)break;\n\t\tvector<vector<int>>puzzle(7, vector<int>(7,-1));\n\t\tpuzzle[1][3] = a;\n\t\tfor (int i = 2; i <= 5; ++i) {\n\t\t\tfor (int j = 3 - (2-(abs(i - 3))); j <= 3 + (2-abs(i - 3)); ++j) {\n\t\t\t\tcin >> puzzle[i][j];\n\t\t\t}\n\t\t}\n\t\tif (puzzle == ans) {\n\t\t\tcout << 0 << endl;\n\t\t}\n\t\telse {\n\n\t\t\tsolve(puzzle, 1);\n\t\t\tif (aaa == 21)cout << \"NA\" << endl;\n\t\t\telse cout << aaa << endl;\n\t\t}\n\t}\n\treturn 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include<bits/stdc++.h>\n#define r(i,n) for(int i=0;i<n;i++)\nusing namespace std;\ntypedef pair<vector<int>,int>P;\nvector<int>v[13],s(13),t(13);\nmap<vector<int>,int>m;\n \nint has[14];\n \n \nvoid init(){\n \n    v[0].push_back(2);\n \n    v[1].push_back(2);\n    v[1].push_back(5);\n \n    v[2].push_back(0);\n    v[2].push_back(1);\n    v[2].push_back(3);\n    v[2].push_back(6);\n \n    v[3].push_back(2);\n    v[3].push_back(7);\n \n    v[4].push_back(5);\n \n    v[5].push_back(1);\n    v[5].push_back(4);\n    v[5].push_back(6);\n    v[5].push_back(9);\n \n    v[6].push_back(2);\n    v[6].push_back(5);\n    v[6].push_back(7);\n    v[6].push_back(10);\n \n    v[7].push_back(3);\n    v[7].push_back(6);\n    v[7].push_back(8);\n    v[7].push_back(11);\n \n    v[8].push_back(7);\n \n    v[9].push_back(5);\n    v[9].push_back(10);\n \n    v[10].push_back(6);\n    v[10].push_back(9);\n    v[10].push_back(11);\n    v[10].push_back(12);\n \n    v[11].push_back(7);\n    v[11].push_back(10);\n \n    v[12].push_back(10);\n \n    int a=20;\n    int p=1;\n \n    r(i,13){\n        has[i]=p;\n        p*=a;\n    }\n}\n \nint ha(vector<int> &x){\n \n    int re=0;\n \n    r(i,13){\n        re+=x[i]*has[i];\n    }\n \n    return re;\n}\n \nvector<int> ah(int x){\n    vector<int>y(13);\n    r(i,13){\n        y[i]=x%20;\n        x/=20;\n    }\n    return y;\n}\n \nvoid BFS1(){\n    s[0]=0;\n    s[12]=0;\n    r(i,11)s[i+1]=i+1;\n    set<vector<int> >st;\n    st.insert(s);\n    m[s]=0;\n    queue<P>q;\n    q.push(P(s,0));\n    while(1){\n        vector<int> now=q.front().first;\n        int cost=q.front().second;\n        q.pop();\n        if(cost==12)break;\n        //cout<<m.size()<<' '<<cost<<endl;\n        r(i,13)if(now[i]==0){\n            r(j,v[i].size()){\n                swap(now[i],now[v[i][j]]);\n                if(!st.count(now)){\n                    st.insert(now);\n                    m[now]=cost+1;\n                    q.push(P(now,cost+1));\n                }\n                swap(now[i],now[v[i][j]]);\n            }\n        }\n    }\n}\n \nvoid BFS2(){\n    set<vector<int> >st;\n    st.insert(t);\n    queue<P>q;\n    q.push(P(t,0));\n    while(1){\n        vector<int>now=q.front().first;\n        int cost=q.front().second;\n        q.pop();\n        if(m.count(now)){\n            cout<<m[now]+cost<<endl;\n            return ;\n        }\n        if(cost==8)break;\n        r(i,13)if(now[i]==0){\n            r(j,v[i].size()){\n                swap(now[i],now[v[i][j]]);\n                if(!st.count(now)){\n                    st.insert(now);\n                    if(m.count(now)){\n                        cout<<m[now]+cost+1<<endl;\n                        return ;\n                    }\n                    q.push(P(now,cost+1));\n                }\n                swap(now[i],now[v[i][j]]);\n            }\n        }\n    }\n    cout<<\"NA\"<<endl;\n}\n \n \nsigned main(){\n    init();\n    BFS1();\n    while(cin>>t[0],t[0]!=-1){\n        r(i,12)cin>>t[i+1];\n        BFS2();\n    }\n}\n"
  },
  {
    "language": "C++",
    "code": "#include<iostream>\n#include<vector>\n#include<queue>\n#include<map>\n#include<cmath>\n#include<cstdlib>\n#include<algorithm>\nusing namespace std;\n\nstring ans;\n\nclass board{\npublic:\n  int h,c;\n  string s;\n  board(int x,int y,string z){ h=x; c=y; s=z;}\n  const bool operator<(const board x)const{return h+c>x.h+x.c; }\n};\n\nint score(string s){\n  int res=0,m;\n  for(int i=0;i<25;i++){\n    if(s[i]!='x' && s[i]!='o'){\n      for(int j=0;j<25;j++){\n\tif(s[i]==ans[j]){\n\t  m = abs(i/5-j/5) + abs(i%5-j%5);\n\t  //cout << s[i] << \" \" << m << endl;\n\t  break;\n\t}\n      }\n      res += m;\n    }\n  }\n  return res;\n}\n\nchar trans(int x){\n  if(!x)return 'o';\n  else return 'a'+x-1;\n}\n\nint main(){\n  string s;\n  ans = \"xxoxxxabcxdefghxijkxxxoxx\";\n  int tmp,cost;\n\n  for(;;){\n    cin >> tmp;\n    if(tmp<0)break;\n\n    s = \"xx\";\n    s += trans(tmp);\n    s += \"xxx\";\n    for(int i=0;i<3;i++){\n      cin >> tmp;\n      s += trans(tmp);\n    }\n    s += \"x\";\n    for(int i=0;i<5;i++){\n      cin >> tmp;\n      s += trans(tmp);\n    }\n    s += \"x\";\n    for(int i=0;i<3;i++){\n      cin >> tmp;\n      s+= trans(tmp);\n    }\n    s += \"xxx\";\n    cin >> tmp;\n    s += trans(tmp);\n    s += \"xx\";\n\n    priority_queue<board> q;\n    q.push(board(score(s),0,s));\n\n    map<string,bool> m;\n    m[s] = 0;\n    while(q.size()){\n      board p = q.top();q.pop();\n      int dx[] = {-5,1,5,-1};\n      /*\n      cout << p.h << \" \" << p.c;\n      for(int i=0;i<25;i++){\n\tif(!(i%5))cout << endl;\n\tcout << p.s[i] << \" \";\n      }\n      cout << endl;\n      */\n      cost = p.c;\n      if(p.s == ans)break;\n      if(p.h+cost>20){\n\tcost = 21;\n\tbreak;\n      }\n      m[p.s] = true;\n      for(int i=0;i<25;i++){\n\tif(p.s[i]=='o'){\n\t  for(int j=0;j<4;j++){\n\t    int sx = i + dx[j];\n\t    string str = p.s;\n\t    if(sx<0 || 25<=sx)continue;\n\t    if(str[sx] == 'x' || str[sx] == 'o')continue;\n\t    swap(str[i],str[sx]);\n\t    if(!m[str])q.push(board(score(str),cost+1,str));\n\t  }\n\t}\n      }\n    }\n\n\n\n    if(cost>20)cout << \"NA\\n\";\n    else cout << cost << endl;\n    //score(s);\n  }\n}"
  },
  {
    "language": "C++",
    "code": "#include<bits/stdc++.h>\nusing namespace std;\n   \ntypedef long long int64;\nconst int INF = 1 << 30;\n   \nvector< int > edge[13];\n  \nbool back(string str, int cnt){ //枝刈り大事だな\n  int X[]={ 2, 1, 2, 3, 0, 1, 2, 3, 4, 1, 2, 3, 2};\n  int Y[]={ 0, 1, 1, 1, 2, 2, 2, 2, 2, 3, 3, 3, 4};\n \n  int diff = 0;\n  for(int i = 0; i < 13; i++){\n    if(str[i] != '0'){\n      int pos = (str[i] >= 'A' ? str[i] - 'A' + 10 : str[i] - '0');\n      diff += abs( X[pos] - X[i]) + abs( Y[pos] - Y[i]);\n    }\n  }\n  return diff + cnt > 20;\n}\n  \n  \nint bfs(string mas){\n  \n  queue< string > que;\n  map< string , int > memo;\n  que.push( mas );\n  memo[mas] = 0;\n  while(!que.empty()){\n  \n    string p = que.front(); que.pop();\n    if(back( p, memo[p])) continue;\n    if(p == \"0123456789AB0\") return memo[p];\n  \n    for(int i = 0; i < 13; i++){\n      if(p[i] == '0') {\n        for(int j = 0; j < edge[i].size(); j++){\n          string next = p;\n          swap( next[i], next[edge[i][j]]);\n          if(memo.find(next) != memo.end()) continue;\n          que.push( next );\n          memo[next] = memo[p] + 1;\n        }\n      }\n    }\n  }\n  return -1;\n}\n  \nint main(){\n  vector< int > mas(13);\n  \n  edge[0].push_back(2);\n  edge[1].push_back(2); edge[1].push_back(4);\n  edge[2].push_back(0); edge[2].push_back(1); edge[2].push_back(3); edge[2].push_back(6);\n  edge[3].push_back(2); edge[3].push_back(7);\n  edge[4].push_back(5);\n  edge[5].push_back(1); edge[5].push_back(4); edge[5].push_back(6); edge[5].push_back(9);\n  edge[6].push_back(2); edge[6].push_back(5); edge[6].push_back(7); edge[6].push_back(10);\n  edge[7].push_back(3); edge[7].push_back(6); edge[7].push_back(8); edge[7].push_back(11);\n  edge[8].push_back(7);\n  edge[9].push_back(5); edge[9].push_back(10);\n  edge[10].push_back(6); edge[10].push_back(9); edge[10].push_back(11); edge[10].push_back(12);\n  edge[11].push_back(7); edge[11].push_back(10);\n  edge[12].push_back(10);\n  \n  while(cin >> mas[0], mas[0] != -1){\n    for(int i = 1; i < 13; i++){\n      cin >> mas[i];\n    }\n  \n    string start = \"\";\n    for(int i = 0; i < 13; i++){\n      if(mas[i] >= 10) start += (char)(mas[i] - 10 + 'A');\n      else start += mas[i] + '0';\n    }\n    int ret = bfs(start);\n    if(~ret) cout << ret << endl;\n    else cout << \"NA\" << endl;\n  }\n}"
  },
  {
    "language": "C++",
    "code": "#include<iostream>\n#include<queue>\n#include<map>\n#include<cstring>\nusing namespace std;\n\nstruct puz{\n\tint a[5][5];\n\tint tim;\n\tchar s;\n};\n\nmap<string,bool> memo;\nqueue<struct puz> que;\nstruct puz def;\nstruct puz tmp;\nstring z;\n\nvoid erase(){\n\tfor(int i=0; i<5; i++)\n\t\tfor(int k=0; k<5; k++)\n\t\t\tdef.a[i][k] = 21;\n\tdef.tim = 0;\n\tdef.s = 'a';\n\twhile(!que.empty())\n\t\tque.pop();\n\tmemo.clear();\n}\n\nbool clear(){\n\tfor(int i=1; i<4; i++)\n\t\tif(def.a[1][i] != i || def.a[3][i] != i+8)\n\t\t\treturn false;\n\tfor(int i=0; i<5; i++){\n\t\tif(def.a[2][i] != i+4)\n\t\t\treturn false;\n\t}\n\treturn true;\n}\n\nvoid int2str(){\n\tz.erase();\n\tfor(int i=0; i<5; i++){\n\t\tfor(int k=0; k<5; k++){\n\t\t\tchar t[2];\n\t\t\tt[0] = (char)(def.a[i][k]+48);\n\t\t\tt[1] = '\\0';\n\t\t\tz.append(t);\n\t\t}\n\t}\n}\n\nvoid solve(){\n\tque.push(def);\n\twhile(true){\n\t\tif(que.empty()){\n\t\t\tcout << \"NA\" << endl;\n\t\t\tbreak;\n\t\t}\n\t\tdef = que.front();\n\t\tque.pop();\n\n\t\tif(def.tim > 20){\n\t\t\tcout << \"NA\" << endl;\n\t\t\tbreak;\n\t\t}\n\n\t\tint2str();\n\n\t\tif(memo[z])\n\t\t\tcontinue;\n\t\telse\n\t\t\tmemo[z] = true;\n\n\t\tif(clear()){\n\t\t\tcout << def.tim << endl;\n\t\t\tbreak;\n\t\t}\n\n\t\ttmp = def;\n\t\tfor(int i=0; i<5; i++){\n\t\t\tfor(int k=0; k<5; k++){\n\t\t\t\tif(def.a[i][k] == 0){\n\t\t\t\t\tif(i != 0){\n\t\t\t\t\t\tif(tmp.a[i-1][k] != 21 && tmp.a[i-1][k] != 0){\n\t\t\t\t\t\t\ttmp.a[i-1][k] = 0;\n\t\t\t\t\t\t\ttmp.a[i][k] = def.a[i-1][k];\n\t\t\t\t\t\t\ttmp.tim++;\n\t\t\t\t\t\t\tque.push(tmp);\n\t\t\t\t\t\t\ttmp = def;\n\t\t\t\t\t\t}\n\t\t\t\t\t}\n\t\t\t\t\tif(i != 4){\n\t\t\t\t\t\tif(tmp.a[i+1][k] != 21 && tmp.a[i+1][k] != 0){\n\t\t\t\t\t\t\ttmp.a[i+1][k] = 0;\n\t\t\t\t\t\t\ttmp.a[i][k] = def.a[i+1][k];\n\t\t\t\t\t\t\ttmp.tim++;\n\t\t\t\t\t\t\tque.push(tmp);\n\t\t\t\t\t\t\ttmp = def;\n\t\t\t\t\t\t}\n\t\t\t\t\t}\n\t\t\t\t\tif(k != 0){\n\t\t\t\t\t\tif(tmp.a[i][k-1] != 21 && tmp.a[i][k-1] != 0){\n\t\t\t\t\t\t\ttmp.a[i][k-1] = 0;\n\t\t\t\t\t\t\ttmp.a[i][k] = def.a[i][k-1];\n\t\t\t\t\t\t\ttmp.tim++;\n\t\t\t\t\t\t\tque.push(tmp);\n\t\t\t\t\t\t\ttmp = def;\n\t\t\t\t\t\t}\n\t\t\t\t\t}\n\t\t\t\t\tif(k != 4){\n\t\t\t\t\t\tif(tmp.a[i][k+1] != 21 && tmp.a[i][k+1] != 0){\n\t\t\t\t\t\t\ttmp.a[i][k+1] = 0;\n\t\t\t\t\t\t\ttmp.a[i][k] = def.a[i][k+1];\n\t\t\t\t\t\t\ttmp.tim++;\n\t\t\t\t\t\t\tque.push(tmp);\n\t\t\t\t\t\t\ttmp = def;\n\t\t\t\t\t\t}\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t\t\n\t}\n}\n\nint main(){\n\twhile(true){\n\t\terase();\n\t\tcin >> def.a[0][2];\n\t\tif(!(def.a[0][2]+1))\n\t\t\treturn 0;\n\t\tcin >> def.a[1][1];\n\t\tcin >> def.a[1][2];\n\t\tcin >> def.a[1][3];\n\t\tcin >> def.a[2][0];\n\t\tcin >> def.a[2][1];\n\t\tcin >> def.a[2][2];\n\t\tcin >> def.a[2][3];\n\t\tcin >> def.a[2][4];\n\t\tcin >> def.a[3][1];\n\t\tcin >> def.a[3][2];\n\t\tcin >> def.a[3][3];\n\t\tcin >> def.a[4][2];\n\t\tsolve();\n\t}\n}"
  },
  {
    "language": "C++",
    "code": "#include <iostream>\n#include <algorithm>\n#include <vector>\n#include <cstring>\n#include <cstdio>\n#include <climits>\n\nusing namespace std;\n\n\n#define REP(i,a,n) for(int i=(a); i<(int)(n); i++)\n#define rep(i,n) REP(i,0,n)\n#define DEB 0\n\nint board[7][7]; //1base\nint sx[2], sy[2];\nstatic const int dx[] = {0,0,1,-1};\nstatic const int dy[] = {1,-1,0,0};\n\nint calc(int y, int x){\n    switch(board[y][x]){\n    case 1: return abs(2-y)+abs(2-x);\n    case 2: return abs(2-y)+abs(3-x);\n    case 3: return abs(2-y)+abs(4-x);\n    case 4: return abs(3-y)+abs(1-x);\n    case 5: return abs(3-y)+abs(2-x);\n    case 6: return abs(3-y)+abs(3-x);\n    case 7: return abs(3-y)+abs(4-x);\n    case 8: return abs(3-y)+abs(5-x);\n    case 9: return abs(4-y)+abs(2-x);\n    case 10: return abs(4-y)+abs(3-x);\n    case 11: return abs(4-y)+abs(4-x);\n    }\n    return -1;\n}\nint dist(void){\n    int ret = 0;\n    if( board[1][3] ) ret += calc(1,3);\n    rep(i,3) if( board[2][2+i] ) ret += calc(2,2+i);\n    rep(i,5) if( board[3][1+i] ) ret += calc(3,1+i);\n    rep(i,3) if( board[4][2+i] ) ret += calc(4,2+i);\n    if( board[5][3] ) ret += calc(5,3);\n    return ret;\n}\nbool isgoal(void){\n    if( board[1][3]!=0 ) return false;\n    rep(i,3) if( board[2][2+i]!=i+1 ) return false;\n    rep(i,5) if( board[3][1+i]!=i+4 ) return false;\n    rep(i,3) if( board[4][2+i]!=i+9 ) return false;\n    if( board[5][3]!=0 ) return false;\n    return true;\n}\n\nbool dfs(int cnt, int LIM, int py, int px){\n    if( isgoal() ) return true;\n    if( cnt+dist()>LIM ) return false;\n\n    rep(i,2){\n        if( board[sy[i]][sx[i]]!=0 ) exit(-1);\n        rep(k,4){\n            int tx = sx[i] + dx[k];\n            int ty = sy[i] + dy[k];\n            if( board[ty][tx]==-1 ) continue;\n            swap(board[sy[i]][sx[i]], board[ty][tx]);\n            swap(sx[i], tx); swap(sy[i],ty);\n            if( dfs(cnt+1, LIM, ty, tx) ) return true;\n            swap(sx[i], tx); swap(sy[i],ty);\n            swap(board[sy[i]][sx[i]] ,board[ty][tx]);\n        }\n    }\n    return false;\n}\nint solve(void){\n    int ttx[2], tty[2];\n    int tb[7][7];\n    rep(i,2) ttx[i]=sx[i], tty[i]=sy[i];\n    rep(i,7)rep(j,7) tb[i][j] = board[i][j];\n\n    for(int lim = 0; lim < 21; lim++){\n        rep(i,2) sx[i]=ttx[i], sy[i]=tty[i];\n        rep(i,7) rep(j,7) board[i][j] = tb[i][j];\n        if( dfs(0,lim,-1,-1) ) return lim;\n    }\n    return -1;\n}\nint main(){\n    for(;;){\n        memset(board, -1, sizeof(board));\n        int sz = 0;\n\n        scanf(\"%d\",&board[1][3]); if( board[1][3]==-1 ) break;\n        rep(i,3) scanf(\"%d\",&board[2][2+i]);\n        rep(i,5) scanf(\"%d\",&board[3][1+i]);\n        rep(i,3) scanf(\"%d\",&board[4][2+i]);\n        scanf(\"%d\",&board[5][3]);\n\n        // find space\n        if( board[1][3]==0 ){ sx[sz]=3; sy[sz]=1; sz++; }\n        rep(i,3) if( board[2][2+i]==0 ) { sx[sz]=2+i; sy[sz]=2; sz++; }\n        rep(i,5) if( board[3][1+i]==0 ) { sx[sz]=1+i; sy[sz]=3; sz++; }\n        rep(i,3) if( board[4][2+i]==0 ) { sx[sz]=2+i; sy[sz]=4; sz++; }\n        if( board[5][3]==0 ){ sx[sz]=3; sy[sz]=5; sz++; }\n\n        //printf(\"hoge:%d\\n\",dist());\n        int ans = solve();\n        if( ans!=-1 ) printf(\"%d\\n\",ans); else puts(\"NA\");\n    }\n    return 0;\n}\n\n/*\n\n//-------------------------------------------------------\n\n#define N 5\n#define REP(i, n) for ( int i = 0; i < (int)n; i++ )\n#define LIMIT 20\n\nstatic const int T[12][2] = {\n    {-1, -1},\n    {1, 1}, \n    {1, 2}, \n    {1, 3},\n    {2, 0},\n    {2, 1},\n    {2, 2},\n    {2, 3},\n    {2, 4},\n    {3, 1}, \n    {3, 2},\n    {3, 3}\n};\nstatic const int g[N][N] = {\n    {-1,-1, 0,-1,-1},\n    {-1, 1, 2, 3,-1},\n    { 4, 5, 6, 7, 8},\n    {-1, 9,10,11,-1}, \n    {-1,-1, 0,-1,-1}\n};\n\nclass Puzzle{\npublic:\n    int C[N][N], mdist; //manhatta distance\n    Puzzle(){}\n\n    bool swapAdj( int si, int sj, int ti, int tj ){\n        if ( ti < 0 || tj < 0 || ti >= N || tj >= N ) return false;\n        if ( C[ti][tj] <= 0 ) return false;\n        swap(C[ti][tj], C[si][sj]);\n        int tti = T[C[si][sj]][0];\n        int ttj = T[C[si][sj]][1];\n        //mdist -= max(tti, ti)-min(tti, ti) + max(ttj, tj)-min(ttj, tj);\n        //mdist += max(tti, si)-min(tti, si) + max(ttj, sj)-min(ttj, sj);\n        //mdist -= abs(tti-ti)+abs(ttj-tj);\n        //mdist += abs(tti-si)+abs(ttj-sj);\n        return true;\n    }\n\n    bool isGoal(){\n        REP(i, N) REP(j, N) if ( g[i][j] != C[i][j] ) return false;\n        return true;\n    }\n\n    int getMD(){ // get initial manhattan distance\n        int sum = 0;\n        int ti, tj;\n        REP(i, 5) REP(j, 5){\n            if ( C[i][j] <= 0 ) continue;\n            ti = T[C[i][j]][0];\n            tj = T[C[i][j]][1];\n            //sum += (max(ti, i)-min(ti, i) + max(tj, j) - min(tj, j));\n            sum += abs(ti-i) + abs(tj-j);\n        }\n        return sum;\n    }\n};\n\nint limit;\n\nbool dfs( int depth, Puzzle P ){\n    if ( P.isGoal() ) return true;\n    if ( depth + P.getMD() > limit ) return false;\n\n    static const int di[4] = {0, -1, 0, 1};\n    static const int dj[4] = {1, 0, -1, 0};\n\n    REP(i, N) REP(j, N){\n        if ( P.C[i][j] != 0 ) continue;\n        REP(r, 4){\n            Puzzle v = P;\n            if ( !v.swapAdj(i, j, i+di[r], j+dj[r]) ) continue;\n            if ( dfs( depth + 1, v ) ) return true;\n        }\n    }\n\n    return false;\n}\n\nint idp(Puzzle source){\n    for ( limit = 0; limit <= LIMIT; limit++ ){\n        //source.mdist = source.getMD();\n        if ( dfs(0, source) ) return limit;\n    }\n    return INT_MAX;\n}\n\nint main(){\n    Puzzle P;\n    int top;\n\n    while(1){\n        cin >> top;\n        if ( top == -1 ) break;\n        REP(j, N) P.C[0][j] = -1;\n        P.C[0][2] = top;\n        for(int i = 1; i < N; i++) REP(j, N){\n                if ( (i == 1 || i == 3) && (j == 0 || j == 4 ) ) P.C[i][j] = -1;\n                else if ( i == 4 && j != 2 ) P.C[i][j] = -1;\n                else cin >> P.C[i][j];\n            }\n\n        int cost = idp(P);\n        if ( cost == INT_MAX ) cout << \"NA\" << endl;\n        else cout << cost << endl;\t\n    }\n\n    return 0;\n}\n\n*/"
  },
  {
    "language": "C++",
    "code": "#include <cstdio>\n#include <cstdlib>\n#include <cmath>\n#include <climits>\n#include <cfloat>\n#include <map>\n#include <utility>\n#include <set>\n#include <iostream>\n#include <memory>\n#include <string>\n#include <vector>\n#include <algorithm>\n#include <functional>\n#include <sstream>\n#include <complex>\n#include <stack>\n#include <queue>\n#include <cstring>\n#include <sstream>\n#include <cassert>\n#include <list>\nusing namespace std;\nstatic const double EPS = 1e-10;\ntypedef long long ll;\ntypedef pair<int,int> PI;\ntypedef vector<int> vi;\n#ifndef M_PI\n#define M_PI 3.14159265358979323846\n#endif\n#define rep(i,n) for(int i=0;i<(int)n;++i)\n#define FOR(i,c) for(__typeof((c).begin())i=(c).begin();i!=(c).end();++i)\n#define ALL(c) (c).begin(), (c).end()\n#define mp(a,b) make_pair(a,b)\n#define pb(a) push_back(a)\n#define F first\n#define S second\ntemplate <typename T> string print_array(const vector<T> &V) { ostringstream os; os << \"{ \"; for (typename vector<T>::const_iterator iter = V.begin(); iter != V.end(); ++iter) os << '\\\"' << *iter << \"\\\",\"; os << \" }\"; return os.str(); }\n\nint dx[]={0,1,0,-1},dy[]={1,0,-1,0};\n\nvector<int> se[13];\nint x[]={0,-1,0,1,-2,-1,0,1,2,-1,0,1,0};\nint y[]={2,1,1,1,0,0,0,0,0,-1,-1,-1,-2};\n\nvoid pr(ll in){\n\n  printf(\"      %3lld\\n\",in&15);\n  printf(\"   %3lld%3lld%3lld\\n\",(in>>4)&15,(in>>8)&15,(in>>12)&15);\n  printf(\"%3lld%3lld%3lld%3lld%3lld\\n\",(in>>16)&15,(in>>20)&15,(in>>24)&15,(in>>28)&15,(in>>32)&15);\n  printf(\"   %3lld%3lld%3lld\\n\",(in>>36)&15,(in>>40)&15,(in>>44)&15);\n  printf(\"      %3lld\\n\",(in>>48)&15);\n  puts(\"\");\n}\n\nint manh(ll in){\n  int ret=0;\n  rep(i,13){\n    int t=(in>>(i*4))&15;\n\n    if(!t)continue;\n    int nx=(x[t]-x[i]),ny=y[t]-y[i];\n    ret+=abs(nx)+abs(ny);\n  }\n  return ret;\n}\n\nmain(){\n  ll p;\n\n  ll goal=0;\n  rep(i,11){\n    goal|=(i+1LL)<<(4*(i+1));\n    //cout<<goal<<endl;\n    //pr(goal);\n  }\n  //pr(goal);\n\n  se[0].pb(2);\n  se[1].pb(2);\n  se[1].pb(5);\n  se[2].pb(0);\n  se[2].pb(1);\n  se[2].pb(3);\n  se[2].pb(6);\n  se[3].pb(2);\n  se[3].pb(7);\n  se[4].pb(5);\n  se[5].pb(1);\n  se[5].pb(4);\n  se[5].pb(6);\n  se[5].pb(9);\n  se[6].pb(2);\n  se[6].pb(5);\n  se[6].pb(7);\n  se[6].pb(10);\n  se[7].pb(3);\n  se[7].pb(6);\n  se[7].pb(8);\n  se[7].pb(11);\n  se[8].pb(7);\n  se[9].pb(5);\n  se[9].pb(10);\n  se[10].pb(6);\n  se[10].pb(9);\n  se[10].pb(11);\n  se[10].pb(12);\n  se[11].pb(7);\n  se[11].pb(10);\n  se[12].pb(10);\n  \n  while(cin>>p){\n    if(p==-1)break;\n    ll in=p;\n\n    rep(i,12){\n      cin>>p;\n      in|=p<<(4*(i+1));\n    }\n\n    set<ll> app;\n\n    queue<pair<int,ll> > Q;\n    app.insert(in);\n    Q.push(mp(0,in));\n    int ans=21;\n    int mans=0;\n\n    while(!Q.empty()){\n      ll cvec=Q.front().S;\n      int ccost=Q.front().F;\n      Q.pop();\n    \n      //pr(cvec);\n\n      //if(ccost>3)break;\n      if(ccost+manh(cvec)>30)continue;\n      if(cvec==goal){\n\tans=ccost;\n\tbreak;\n      }\n      rep(i,13){\n\tll t=cvec>>(i<<2);\n\tt=t&15;\n\tif(!t){\n\t  rep(j,se[i].size()){\n\t    t=cvec>>(se[i][j]<<2);\n\t    t=t&15;\n\t    if(t){\n\t      ll nvec=cvec;\n\t      t=t<<(i<<2);\n\t      nvec|=t;\n\t      nvec&=~(15LL<<se[i][j]*4);\n\t      \n\t      if(!app.count(nvec)){\n\t\tapp.insert(nvec);\n\t\tQ.push(mp(ccost+1,nvec));\n\t      }\n\t    }\n\t  }\n\t}\n      }\n    }\n    if(ans==21)cout<<\"NA\"<<endl;\n    else cout<<ans<<endl;\n  }\n}"
  },
  {
    "language": "C++",
    "code": "#include <cstdio>\n#include <cstdlib>\n#include <cmath>\n#include <climits>\n#include <cfloat>\n#include <map>\n#include <utility>\n#include <set>\n#include <iostream>\n#include <memory>\n#include <string>\n#include <vector>\n#include <algorithm>\n#include <functional>\n#include <sstream>\n#include <complex>\n#include <stack>\n#include <queue>\n#include <cstring>\n#include <sstream>\n#include <cassert>\n#include <list>\nusing namespace std;\nstatic const double EPS = 1e-10;\ntypedef long long ll;\ntypedef pair<int,int> PI;\ntypedef vector<int> vi;\n#ifndef M_PI\n#define M_PI 3.14159265358979323846\n#endif\n#define rep(i,n) for(int i=0;i<(int)n;++i)\n#define FOR(i,c) for(__typeof((c).begin())i=(c).begin();i!=(c).end();++i)\n#define ALL(c) (c).begin(), (c).end()\n#define mp(a,b) make_pair(a,b)\n#define pb(a) push_back(a)\n#define F first\n#define S second\ntemplate <typename T> string print_array(const vector<T> &V) { ostringstream os; os << \"{ \"; for (typename vector<T>::const_iterator iter = V.begin(); iter != V.end(); ++iter) os << '\\\"' << *iter << \"\\\",\"; os << \" }\"; return os.str(); }\n\nint dx[]={0,1,0,-1},dy[]={1,0,-1,0};\n\nvector<int> se[13];\nint x[]={0,-1,0,1,-2,-1,0,1,2,-1,0,1,0};\nint y[]={2,1,1,1,0,0,0,0,0,-1,-1,-1,-2};\n\nvoid pr(ll in){\n\n  printf(\"      %3lld\\n\",in&15);\n  printf(\"   %3lld%3lld%3lld\\n\",(in>>4)&15,(in>>8)&15,(in>>12)&15);\n  printf(\"%3lld%3lld%3lld%3lld%3lld\\n\",(in>>16)&15,(in>>20)&15,(in>>24)&15,(in>>28)&15,(in>>32)&15);\n  printf(\"   %3lld%3lld%3lld\\n\",(in>>36)&15,(in>>40)&15,(in>>44)&15);\n  printf(\"      %3lld\\n\",(in>>48)&15);\n  puts(\"\");\n}\n\nint manh(ll in){\n  int ret=0;\n  rep(i,13){\n    int t=(in>>(i*4))&15;\n\n    if(!t){\n      int nx=x[t]-x[i],ny=y[t]-y[i];\n      int co=abs(nx)+abs(ny);\n      nx=x[12]-x[i],ny=y[12]-y[i];\n      int k=abs(nx)+abs(ny);\n      ret+=min(co,k);\n      continue;\n    }\n    int nx=(x[t]-x[i]),ny=y[t]-y[i];\n    ret+=abs(nx)+abs(ny);\n  }\n  return ret;\n}\n\nmain(){\n  ll p;\n\n  ll goal=0;\n  rep(i,11){\n    goal|=(i+1LL)<<(4*(i+1));\n    //cout<<goal<<endl;\n    //pr(goal);\n  }\n  //pr(goal);\n\n  se[0].pb(2);\n  se[1].pb(2);\n  se[1].pb(5);\n  se[2].pb(0);\n  se[2].pb(1);\n  se[2].pb(3);\n  se[2].pb(6);\n  se[3].pb(2);\n  se[3].pb(7);\n  se[4].pb(5);\n  se[5].pb(1);\n  se[5].pb(4);\n  se[5].pb(6);\n  se[5].pb(9);\n  se[6].pb(2);\n  se[6].pb(5);\n  se[6].pb(7);\n  se[6].pb(10);\n  se[7].pb(3);\n  se[7].pb(6);\n  se[7].pb(8);\n  se[7].pb(11);\n  se[8].pb(7);\n  se[9].pb(5);\n  se[9].pb(10);\n  se[10].pb(6);\n  se[10].pb(9);\n  se[10].pb(11);\n  se[10].pb(12);\n  se[11].pb(7);\n  se[11].pb(10);\n  se[12].pb(10);\n  \n  while(cin>>p){\n    if(p==-1)break;\n    ll in=p;\n\n    rep(i,12){\n      cin>>p;\n      in|=p<<(4*(i+1));\n    }\n\n    set<ll> app;\n\n    queue<pair<int,ll> > Q;\n    app.insert(in);\n    Q.push(mp(0,in));\n    int ans=21;\n    int mans=0;\n\n    while(!Q.empty()){\n      ll cvec=Q.front().S;\n      int ccost=Q.front().F;\n      Q.pop();\n    \n      //pr(cvec);\n\n      //if(ccost>3)break;\n     if(ccost>20)break;\n     \n      if(cvec==goal){\n\tans=ccost;\n\tbreak;\n      }\n      if(ccost+manh(cvec)>28)continue;\n      rep(i,13){\n\tll t=cvec>>(i<<2);\n\tt=t&15;\n\tif(!t){\n\t  rep(j,se[i].size()){\n\t    t=cvec>>(se[i][j]<<2);\n\t    t=t&15;\n\t    if(t){\n\t      ll nvec=cvec;\n\t      t=t<<(i<<2);\n\t      nvec|=t;\n\t      nvec&=~(15LL<<se[i][j]*4);\n\t      \n\t      if(!app.count(nvec)){\n\t\tapp.insert(nvec);\n\t\tQ.push(mp(ccost+1,nvec));\n\t      }\n\t    }\n\t  }\n\t}\n      }\n    }\n    if(ans==21)cout<<\"NA\"<<endl;\n    else cout<<ans<<endl;\n  }\n}"
  },
  {
    "language": "C++",
    "code": "#include <iostream>\n#include <cstdio>\n#include <cstring>\n#include <algorithm>\n#include <vector>\n#include <queue>\n#include <map>\nusing namespace std;\n\ntypedef vector<int> VI;\n\nint size[13] = {1, 2, 4, 2, 1, 4, 4, 4, 1, 2, 4, 2, 1};\nint move[13][4] = {\n  {2},\n  {2, 5},\n  {0, 1, 6, 3},\n  {2, 7},\n  {5},\n  {1, 4, 6, 9},\n  {2, 5, 7, 10},\n  {3, 6, 8, 11},\n  {7},\n  {5, 10},\n  {6, 9, 11, 12},\n  {7, 10},\n  {10}\n};\n\nVI v;\nmap<VI, int> mp;\nmap<VI, int> mp2;\n\nvoid make(){\n  VI goal;\n  for(int i = 0 ; i < 13 ; i++){\n    if(i == 0 || i == 12) goal.push_back(0);\n    else goal.push_back(i);    \n  }\n  \n  queue<VI> que;\n  que.push(goal);\n  mp2[goal] = 0;\n  \n  while(!que.empty()){\n    VI q = que.front(); que.pop();    \n    if(mp2[q] > 14) continue;\n    for(int i = 0 ; i < 13 ; i++){\n      if(q[i] != 0) continue;\n      for(int j = 0 ; j < size[i] ; j++){\n\tVI t = q;\n\tswap(t[i], t[ move[i][j] ]);\n\tif(mp2.find(t) != mp2.end()) continue;\t\n\tmp2[t] = mp2[q] + 1;\t\n\tque.push(t);\n      }\n    }\n  }\n}\n    \n\n\nint bfs(){\n  queue<VI> que;\n  que.push(v);\n  mp[v] = 0;  \n  while(!que.empty()){\n    VI q = que.front(); que.pop();    \n    if(mp2.find(q) != mp2.end()){\n      return mp2[q] + mp[q];\n    }\n    \n    if(mp[q] > 7) continue;\n    for(int i = 0 ; i < 13 ; i++){\n      if(q[i] != 0) continue;      \n      for(int j = 0 ; j < size[i] ; j++){\n\tVI t = q;\n\tswap(t[i], t[ move[i][j] ]);\n\tif(mp.find(t) != mp.end()) continue;\n\tmp[t] = mp[q] + 1;\n\tque.push(t);\n      }\n    }\n  }\n  return -1;\n}\n\nvoid init(){\n  v.clear();\n  mp.clear();  \n}\n\nint main(){\n  make();\n  int n;\n  while(cin >> n){\n    if(n == -1) break;\n    \n    init();\n    \n    v.push_back(n);\n    for(int i = 0 ; i < 12 ; i++){ cin >> n; v.push_back(n); }\n    \n    int ans = bfs();\n    if(ans == -1 || ans > 20) cout << \"NA\" << endl;\n    else cout << ans << endl;\n  }\n  \n\n  return 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include<iostream> \n#include<algorithm>\n#include<climits>\n\nusing namespace std;\n\n#define N 5\n#define REP(i, n) for ( int i = 0; i < (int)n; i++ )\n#define LIMIT 20\n\n// S[ÌÇ±É éÌ©\nstatic const int T[12][2] = {\n\t{-1, -1},\n\t{1, 1},\n\t{1, 2},\n\t{1, 3},\n\t{2, 0},\n\t{2, 1},\n\t{2, 2},\n\t{2, 3},\n\t{2, 4},\n\t{3, 1},\n\t{3, 2},\n\t{3, 3}\n};\n\n// S[Ìzu\nstatic const int g[N][N] = {\n\t{-1, -1,  0, -1, -1},\n\t{-1,  1,  2,  3, -1},\n\t{ 4,  5,  6,  7,  8},\n\t{-1,  9, 10, 11, -1},\n\t{-1, -1,  0, -1, -1}\n};\n\nclass Puzzle\n{\npublic:\n\tint C[N][N], mdist; //manhatta distance\n\tPuzzle(){}\n\t\n\tbool swapAdj( int si, int sj, int ti, int tj )\n\t{\n\t\tif ( ti < 0 || tj < 0 || ti >= N || tj >= N )\n\t\t\treturn false;\n\t\tif ( C[ti][tj] <= 0 )\n\t\t\treturn false;\n\n\t\tswap( C[ti][tj], C[si][sj] );\n\n\t\tint tti = T[C[si][sj]][0];\n\t\tint ttj = T[C[si][sj]][1];\n\t\tmdist -= max(tti, ti)-min(tti, ti) + max(ttj, tj)-min(ttj, tj);\n\t\tmdist += max(tti, si)-min(tti, si) + max(ttj, sj)-min(ttj, sj);\n\t\treturn true;\n\t}\n\t\n\tbool isGoal()\n\t{\n\t\tREP(i, N) REP(j, N)\n\t\t\tif ( g[i][j] != C[i][j] )\n\t\t\t\treturn false;\n\t\treturn true;\n\t}\n\t\n\t// get initial manhattan distance\n\tint getMD()\n\t{\n\t\tint sum = 0;\n\t\tint ti, tj;\n\t\tREP(i, 5) REP(j, 5)\n\t\t{\n\t\t\tif ( C[i][j] <= 0 )\n\t\t\t\tcontinue;\n\t\t\tti = T[C[i][j]][0];\n\t\t\ttj = T[C[i][j]][1];\n\t\t\tsum += (max(ti, i)-min(ti, i) + max(tj, j) - min(tj, j));\n\t\t}\n\t\treturn sum;\n\t}\n};\n \nint limit;\n \nbool dfs( int depth, Puzzle P )\n{\n\tif ( P.isGoal() )\n\t\treturn true;\n\tif ( depth + P.getMD() > limit )\n\t\treturn false;\n\t\n\tstatic const int di[4] = {0, -1, 0, 1};\n\tstatic const int dj[4] = {1, 0, -1, 0};\n\t\n\tREP(i, N) REP(j, N)\n\t{\n\t\tif ( P.C[i][j] != 0 )\n\t\t\tcontinue;\n\n\t\tREP(r, 4)\n\t\t{\n\t\t\tPuzzle v = P;\n\t\t\tif ( !v.swapAdj(i, j, i+di[r], j+dj[r]) )\n\t\t\t\tcontinue;\n\t\t\tif ( dfs( depth + 1, v ) )\n\t\t\t\treturn true;\n\t\t}\n\t}\n\t\n\treturn false;\n}\n\nint idp(Puzzle source)\n{\n\tfor ( limit = 0; limit <= LIMIT; limit++ )\n\t{\n\t\tsource.mdist = source.getMD();\n\t\tif ( dfs(0, source) )\n\t\t\treturn limit;\n\t}\n\treturn INT_MAX;\n}\n\nint main()\n{\n\tPuzzle P;\n\tint top;\n\t\n\twhile(1)\n\t{\n\t\tcin >> top;\n\t\tif ( top == -1 ) break;\n\t\tREP(j, N) P.C[0][j] = -1;\n\t\tP.C[0][2] = top;\n\t\tfor(int i = 1; i < N; i++) REP(j, N)\n\t\t{\n\t\t\tif ( (i == 1 || i == 3) && (j == 0 || j == 4 ) )\n\t\t\t\tP.C[i][j] = -1;\n\t\t\telse if ( i == 4 && j != 2 )\n\t\t\t\tP.C[i][j] = -1;\n\t\t\telse\n\t\t\t\tcin >> P.C[i][j];\n\t\t}\n\t\n\t\tint cost = idp(P);\n\t\t\n\t\tif ( cost == INT_MAX )\n\t\t\tcout << \"NA\" << endl;\n\t\telse\n\t\t\tcout << cost << endl;\t\n\t}\n\t\n\treturn 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include <iostream>\n#include <algorithm>\n#include <vector>\n#include <cstring>\n#include <cstdio>\n#include <climits>\n\nusing namespace std;\n\n#define REP(i,a,n) for(int i=(a); i<(int)(n); i++)\n#define rep(i,n) REP(i,0,n)\n#define DEB 0\n\n/*\n  1 = [2][2]\n  2 = [2][3]\n  3 = [2][4]\n  4 = [3][1]\n  5 = [3][2]\n  6 = [3][3]\n  7 = [3][4]\n  8 = [3][5]\n  9 = [4][2]\n  10= [4][3]\n  11= [4][4]\n*/\nint board[7][7]; //1base\nint sx[2], sy[2];\nstatic const int dx[] = {0,0,1,-1};\nstatic const int dy[] = {1,-1,0,0};\n\n/*\n(y,x)\n */\nint calc(int y, int x){\n    switch(board[y][x]){\n    case 1: return abs(2-y)+abs(2-x);\n    case 2: return abs(2-y)+abs(3-x);\n    case 3: return abs(2-y)+abs(4-x);\n    case 4: return abs(3-y)+abs(1-x);\n    case 5: return abs(3-y)+abs(2-x);\n    case 6: return abs(3-y)+abs(3-x);\n    case 7: return abs(3-y)+abs(4-x);\n    case 8: return abs(3-y)+abs(5-x);\n    case 9: return abs(4-y)+abs(2-x);\n    case 10: return abs(4-y)+abs(3-x);\n    case 11: return abs(4-y)+abs(4-x);\n    }\n    return -1;\n}\nint dist(void){\n    int ret = 0;\n    if( board[1][3] ) ret += calc(1,3);\n    rep(i,3) if( board[2][2+i] ) ret += calc(2,2+i);\n    rep(i,5) if( board[3][1+i] ) ret += calc(3,1+i);\n    rep(i,3) if( board[4][2+i] ) ret += calc(4,2+i);\n    if( board[5][3] ) ret += calc(5,3);\n    return ret;\n}\nbool isgoal(void){\n    if( board[1][3]!=0 ) return false;\n    rep(i,3) if( board[2][2+i]!=i+1 ) return false;\n    rep(i,5) if( board[3][1+i]!=i+4 ) return false;\n    rep(i,3) if( board[4][2+i]!=i+9 ) return false;\n    if( board[5][3]!=0 ) return false;\n    return true;\n}\n\nbool dfs(int cnt, int LIM, int py, int px){\n    if( isgoal() ) return true;\n    if( cnt+dist()>LIM ) return false;\n#if DEB\n    //printf(\"cnt:%d  (%d,%d),(%d,%d)\\n\",cnt, sx[0], sy[0], sx[1], sy[1]);\n#endif\n    rep(i,2){\n        rep(k,4){\n            int tx = sx[i] + dx[k];\n            int ty = sy[i] + dy[k];\n            if( board[ty][tx]==-1 || ty==py&&tx==px ) continue;\n            swap(board[sy[i]][sx[i]], board[ty][tx]);\n            swap(sx[i], tx); swap(sy[i],ty);\n            if( dfs(cnt+1, LIM, ty, tx) ) return true; // ツ個ウツづ個スツペツーツスツ暗環置\n            swap(sx[i], tx); swap(sy[i],ty);\n            swap(board[sy[i]][sx[i]] ,board[ty][tx]);\n        }\n    }\n}\nint solve(void){\n    int ttx[2], tty[2];\n    rep(i,2) ttx[i]=sx[i], tty[i]=sy[i];\n\n    for(int lim = 0; lim < 30; lim++){\n        rep(i,2) sx[i]=ttx[i], sy[i]=tty[i];\n        if( dfs(0,lim,-1,-1) ) return lim;\n    }\n    return -1;\n}\nint main(){\n    for(;;){\n        memset(board, -1, sizeof(board));\n        int sz = 0;\n\n        scanf(\"%d\",&board[1][3]); if( board[1][3]==-1 ) break;\n        rep(i,3) scanf(\"%d\",&board[2][2+i]);\n        rep(i,5) scanf(\"%d\",&board[3][1+i]);\n        rep(i,3) scanf(\"%d\",&board[4][2+i]);\n        scanf(\"%d\",&board[5][3]);\n\n        // find space\n        if( board[1][3]==0 ){ sx[sz]=3; sy[sz]=1; sz++; }\n        rep(i,3) if( board[2][2+i]==0 ) { sx[sz]=2+i; sy[sz]=2; sz++; }\n        rep(i,5) if( board[3][1+i]==0 ) { sx[sz]=1+i; sy[sz]=3; sz++; }\n        rep(i,3) if( board[4][2+i]==0 ) { sx[sz]=2+i; sy[sz]=4; sz++; }\n        if( board[5][3]==0 ){ sx[sz]=3; sy[sz]=5; sz++; }\n\n#if DEB\n        rep(i,7){\n            rep(j,7){\n                printf(\"%2d \",board[i][j]);\n            }\n            puts(\"\");\n        }\n        rep(i,2){\n            printf(\"(%d,%d),\",sx[i], sy[i]);\n        }puts(\"\");\n        printf(\"%d\\n\",dist());\n#endif\n        \n        int ans = solve();\n        if( ans==-1 ) puts(\"NA\"); else printf(\"%d\\n\",ans);\n    }\n    return 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include<iostream>\n#include<queue>\n#include<algorithm>\n#include<map>\n\nusing namespace std;\n\nconst int SIZE = 13;\n\nstruct Puzzle{\n  short c[SIZE];\n  \n  void move(int d, int n){\n    if(d == 0) moveUp(n);\n    if(d == 1) moveDown(n);\n    if(d == 2) moveLeft(n);\n    if(d == 3) moveRight(n);\n  }\n  // n = choosed blank number 0(first one) or 1(second one)\n  void moveUp(int n){\n    int pos = findBlankPosition(n);\n    int tmp[] = {-1,-1,0,-1,-1,1,2,3,-1,5,6,7,10};\n    \n    int npos = tmp[pos];\n    if(npos != -1) swap(c[pos],c[npos]);\n  }\n\n  void moveDown(int n){\n    int pos = findBlankPosition(n);\n    int tmp[] = {2,5,6,7,-1,9,10,11,-1,-1,12,-1,-1};\n    \n    int npos = tmp[pos];\n    if(npos != -1) swap(c[pos],c[npos]);\n  }\n\n  void moveLeft(int n){\n    int pos = findBlankPosition(n);\n    int tmp[] = {-1,-1,1,2,-1,4,5,6,7,-1,9,10,-1};\n    \n    int npos = tmp[pos];\n    if(npos != -1) swap(c[pos],c[npos]);\n  }\n\n  void moveRight(int n){\n    int pos = findBlankPosition(n);\n    int tmp[] = {-1,2,3,-1,5,6,7,8,-1,10,11,-1,-1};\n    \n    int npos = tmp[pos];\n    if(npos != -1) swap(c[pos],c[npos]);\n  }\n\n  int findBlankPosition(int n){\n    for(int i = 0; i < SIZE; i++){\n      if(c[i] == 0) n--;\n      if(n < 0) return i;\n    }\n    return -1;\n  }\n\n  bool operator < (const Puzzle& p) const {\n    for(int i = 0; i < SIZE; i++)\n      if(c[i] != p.c[i]) return c[i] < p.c[i];\n    return false;\n  }\n};\n\nPuzzle puz;\n\nbool input(){\n  cin >> puz.c[0];\n  if(puz.c[0] == -1) return false;\n  for(int i = 1; i < SIZE; i++) cin >> puz.c[i];\n  return true;\n}\n\nvoid solve(){\n  map<Puzzle, int> M;\n  M[puz] = 1;\n \n  queue<Puzzle> Q;\n  Q.push(puz);\n\n  while(!Q.empty()){\n    Puzzle now = Q.front(); Q.pop();\n  \n    for(int i = 0; i < 4; i++)\n      for(int j = 0; j < 2; j++){\n\tPuzzle nex = now;\n\tnex.move(i,j);\n\tif(M[nex] > M[now]+1|| M[nex] == 0){\n\t  M[nex] = M[now]+1;\n\t  if(M[nex] <= 11) Q.push(nex);\n\t}\n      }\n  }\n\n  Puzzle tmp;\n  for(int i = 0; i < SIZE; i++) tmp.c[i] = i%(SIZE-1);\n\n \n  int ans = 25;\n  Q.push(tmp);\n  map<Puzzle,int> MG;\n  MG[tmp] = 1;\n\n  while(!Q.empty()){\n    Puzzle now = Q.front(); Q.pop();\n    if(M[now] != 0) ans = min(ans,M[now]+MG[now]-2);\n    for(int i = 0; i < 4; i++)\n      for(int j = 0; j < 2; j++){\n\tPuzzle nex = now;\n\tnex.move(i,j);\n      \n        if(MG[nex] > MG[now]+1 || MG[nex] == 0){\n\t  MG[nex] = MG[now]+1;\n\t  if(MG[nex] <= 11) Q.push(nex);\n\t}\n      }\n    }\n    if(ans <= 20) cout << ans << endl;\n    else cout << \"NA\" << endl;\n}\n\nint main(){\n  while(input()) solve();\n  return 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\n\nusing namespace std;\n\ntypedef long long ll;\ntypedef long double ld;\ntypedef tuple<int, int> duo;\nconst int dx[] = {0, 0, 1, -1, 1, 1, -1, -1};\nconst int dy[] = {1, -1, 0, 0, 1, -1, 1, -1};\nconst int Mod = 1000000000 + 0;\n//{{{ templates\n#define TT_             \\\n  template <typename T> \\\n  inline\n#define TTF_                        \\\n  template <typename T, typename F> \\\n  inline\nTT_ T sq(T x) { return x * x; }\nTT_ T In() {\n  T x;\n  cin >> x;\n  return x;\n}\nTT_ void Out(T& x) { cout << x; }\nTT_ void sort(T& v) { sort(begin(v), end(v)); }\nTT_ void revs(T& v) { reverse(begin(v), end(v)); }\nTT_ void uniq(T& v) {\n  sort(v);\n  v.erase(unique(begin(v), end(v)), end(v));\n}\nTT_ int ubnd(T& v, typename T::value_type& x) {\n  return upper_bound(begin(v), end(v), x) - begin(v);\n}\nTT_ int lbnd(T& v, typename T::value_type& x) {\n  return lower_bound(begin(v), end(v), x) - begin(v);\n}\nTTF_ void inpt(T& v, int n, F f) {\n  for (v.reserve(n); n--; v.emplace_back(f()))\n    ;\n}\nTTF_ void show(T& v, F f, string d = \" \", string e = \"\\n\") {\n  int i = 0;\n  for (auto& x : v) i++&&(cout << d), f(x);\n  cout << e;\n}\nTT_ typename T::iterator minel(T& v) { return min_element(begin(v), end(v)); }\nTT_ typename T::iterator maxel(T& v) { return max_element(begin(v), end(v)); }\n\ninline void fast_io() {\n  ios::sync_with_stdio(0);\n  cin.tie(0);\n}\ninline int in() {\n  int x;\n  scanf(\"%d\", &x);\n  return x;\n}\ninline ll pow_mod(ll a, ll k, ll m) {\n  ll r = 1;\n  for (; k > 0; a = a * a % m, k >>= 1)\n    if (k & 1) r = r * a % m;\n  return r;\n}\ninline ll mod_inv(ll a, ll p) { return pow_mod(a, p - 2, p); }\n//}}} priority_queue queue deque front stringstream max_element min_element\n// insert count make_tuple\n\nstruct Board {\n  Board() {\n    memcpy(b, \"0123456789AB0\", sizeof(b));\n    find_zero();\n  }\n  Board(const vector<int>& v) {\n    for (int i = 0; i < 13; i++) b[i] = conv_hex(v[i]);\n    b[13] = 0;\n    find_zero();\n  }\n  void find_zero(){\n    int it = 0;\n    for (int i = 0; i < 13; i++){\n      if (b[i] == '0'){\n        cur[it] = i;\n        it++;\n      }\n    }\n  }\n  char conv_hex(int a) { return \"0123456789ABCDEF\"[a]; }\n  bool slide(int index, int dir) {\n    static const char mov[][4] = {\n      {-1, -1, 2, -1},\n      {-1, 2, 5, -1},\n      {0, 3, 6, 1},\n      {-1, -1, 7, 2},\n      {-1, 5, -1, -1},\n      {1, 6, 9, 4},\n      {2, 7, 10, 5},\n      {3, 8, 11, 6},\n      {-1, -1, -1, 7},\n      {5, 10, -1, -1},\n      {6, 11, 12, 9},\n      {7, -1, -1, 10},\n      {10, -1, -1, -1},\n    };\n    char cu = cur[index];\n    char nu = mov[cu][dir];\n    if (nu == -1) return false;\n    if (b[nu] == '0') return false;\n    swap(b[cu], b[nu]);\n    cur[index] = nu;\n    turn++;\n    return true;\n  }\n  char b[14];\n  char cur[2];\n  char turn;\n};\n\nint main() {\n  unordered_map<ll, char> ans;\n  Board b;\n  queue<Board> Q;\n  Q.push(b);\n  while (!Q.empty()){\n    Board bi = Q.front();\n    Q.pop();\n    ll hv = strtoll(bi.b, 0, 16);\n    if (ans.count(hv)) continue;\n    ans[hv] = bi.turn;\n    if (bi.turn >= 20) continue;\n    for (int i = 0; i < 2; i++){\n      for (int d = 0; d < 4; d++){\n        Board bii = bi;\n        if (!bii.slide(i, d)) continue;\n        Q.push(bii);\n      }\n    }\n  }\n  puts(\"END\");\n  int h;\n  while (h = in(), h != -1) {\n    vector<int> vs;\n    vs.push_back(h);\n    for (int i = 0; i < 12; i++) vs.push_back(in());\n    Board b(vs);\n    ll hv = strtoll(b.b, 0, 16);\n    if (ans.count(hv)) cout << (int)ans[hv] << endl;\n    else cout << \"NA\\n\";\n  }\n  return 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include<map>\n#include<queue>\n#include<cstdio>\n#include<vector>\n\n#define\tpb\tpush_back\n\nusing namespace std;\n\ntypedef\tvector<int>\tvi;\n\nvi mv[13];\nlong long pow12[13];\n\nvoid findEmptyPos(long long stat,int *z){\n\tfor(int i=0,j=0;i<13;i++){\n\t\tif(stat%12==0)\tz[j++]=12-i;\n\t\tstat/=12;\n\t}\n}\n\nlong long sw(long long stat,int i,int j){\n\tlong long powi=pow12[12-i],powj=pow12[12-j];\n\tint pi=(stat/powi)%12,pj=(stat/powj)%12;\n\treturn stat+(pj-pi)*powi+(pi-pj)*powj;\n}\n\nvoid bfs(map<long long,int> &f,long long inistat,int stop){\n\tf[inistat]=0;\n\tqueue<long long> qu;\tqu.push(inistat);\n\twhile(!qu.empty()){\n\t\tlong long stat=qu.front();\tqu.pop();\n\t\tint cnt=f[stat];\n\t\tif(cnt==stop)\tbreak;\n\n\t\tint z[2];\tfindEmptyPos(stat,z);\n\t\tfor(int i=0;i<2;i++){\n\t\t\tfor(int j=0;j<mv[z[i]].size();j++){\n\t\t\t\tlong long nextstat=sw(stat,z[i],mv[z[i]][j]);\n\t\t\t\tif(f.count(nextstat)==0){\n\t\t\t\t\tqu.push(nextstat);\n\t\t\t\t\tf[nextstat]=cnt+1;\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t}\n}\n\nint main(){\n\tlong long a=1;\n\tfor(int i=0;i<13;i++)\tpow12[i]=a,a*=12;\n\n\tmv[0].pb(2);\n\tmv[1].pb(2);\tmv[1].pb(5);\n\tmv[2].pb(0);\tmv[2].pb(1);\tmv[2].pb(3);\tmv[2].pb(6);\n\tmv[3].pb(2);\tmv[3].pb(7);\n\tmv[4].pb(5);\n\tmv[5].pb(1);\tmv[5].pb(4);\tmv[5].pb(6);\tmv[5].pb(9);\n\tmv[6].pb(2);\tmv[6].pb(5);\tmv[6].pb(7);\tmv[6].pb(10);\n\tmv[7].pb(3);\tmv[7].pb(6);\tmv[7].pb(8);\tmv[7].pb(11);\n\tmv[8].pb(7);\n\tmv[9].pb(5);\tmv[9].pb(10);\n\tmv[10].pb(6);\tmv[10].pb(9);\tmv[10].pb(11);\tmv[10].pb(12);\n\tmv[11].pb(7);\tmv[11].pb(10);\n\tmv[12].pb(10);\n\n\tint ans[]={0,1,2,3,4,5,6,7,8,9,10,11,0};\n\tlong long ansstat=0;\n\tfor(int i=0;i<13;i++)\tansstat=ansstat*12+ans[i];\n\n\tmap<long long,int> f;\n\tbfs(f,ansstat,13);\n\n\tfor(long long inistat;scanf(\"%lld\",&inistat),~inistat;){\n\t\tfor(int i=1,p;i<13;i++)\tscanf(\"%d\",&p),inistat=inistat*12+p;\n\t\tmap<long long,int> g;\n\t\tbfs(g,inistat,7);\n\n\t\tint cmin=21;\n\t\tmap<long long,int>::iterator it;\n\t\tfor(it=g.begin();it!=g.end();it++){\n\t\t\tlong long stat=it->first;\n\t\t\tint cnt=it->second;\n\t\t\tif(f.count(stat))\tcmin=min(cmin,cnt+f[stat]);\n\t\t}\n\t\tif(cmin<=20)\tprintf(\"%d\\n\",cmin);\n\t\telse\tputs(\"NA\");\n\t}\n\n\treturn 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include<iostream>\n#include<algorithm>\n#include<iomanip>\n\n#define N 7\n#define INV (-1)\n\n#define UP 0\n#define RIGHT 1\n#define DOWN 2\n#define LEFT 3\n#define DIRMAX 4\n\n#define NA 21\n\nusing namespace std;\n\nstruct State\n{\n  int map[N][N];\n  State(){\n    //fill(&map[0][0],&map[N-1][N-1],-1);\n  }\n  State(int tmap[][N]){\n    for(int i = 0; i < N; ++i){\n      for(int j = 0; j < N; ++j){\n\tmap[i][j] = tmap[i][j];\n      }\n    }\n  }\n  bool move(int which, int dir){\n    // which = 0, upper,left\n    // which != 0, bottom,right\n    for(int i = (which==0?0:N-2); which==0?(i<N-1):(i>=1); which==0?++i:--i){\n      for(int j = (which==0?0:N-2); which==0?(j<N-1):(j>=1); which==0?++j:--j){\n\tif( map[i][j] == 0 ){\n\t  switch(dir){\n\t  case UP:   if( map[i-1][j] > 0 ){swap( map[i][j], map[i-1][j] );return true;}break;\n\t  case RIGHT:if( map[i][j+1] > 0 ){swap( map[i][j], map[i][j+1] );return true;}break;\n\t  case DOWN: if( map[i+1][j] > 0 ){swap( map[i][j], map[i+1][j] );return true;}break;\n\t  case LEFT: if( map[i][j-1] > 0 ){swap( map[i][j], map[i][j-1] );return true;}break;\n\t  }\n\t  return false;\n\t}\n      }\n    }\n  }\n  int getHeuristic()const{\n    static const int ti[] = {0,2,2,2,3,3,3,3,3,4,4,4};\n    static const int tj[] = {0,2,3,4,1,2,3,4,5,2,3,4};\n    int ret = 0;\n    int max1=0,max2=0;\n    for(int i = 1; i < N-1; ++i){\n      for(int j = 1; j < N-1; ++j){\n\tif( map[i][j] > 0 ){\n\t  int x = abs(i-ti[map[i][j]] )+ abs(j-tj[map[i][j]]);\n\t  ret += x;\n\t  if( max1 < x ){\n\t    max2 = max1;\n\t    max1 = x;\n\t  }\n\t}\n      }\n    }\n    return ret;\n  }\n  bool isComplete()const{\n    static const int ti[] = {0,2,2,2,3,3,3,3,3,4,4,4};\n    static const int tj[] = {0,2,3,4,1,2,3,4,5,2,3,4};\n    if( map[1][3] == 0 && map[5][3] == 0 ){\n      for(int i = 1; i < N - 1; ++i){\n\tfor(int j = 1; j < N - 1; ++j){\n\t  if( map[i][j] > 0 ){\n\t    if( ti[map[i][j]] != i || tj[map[i][j]] != j ){\n\t      return false;\n\t    }\n\t  }\n\t}\n      }\n      return true;\n    }\n    return false;\n  }\n};\n\nint IterativeDeepning(int depth, const State &now, int &ans)\n{\n\n  if( now.isComplete() ){\n    ans = min( ans , depth );\n    return ans;\n  }\n  int least = depth + now.getHeuristic();\n  if( least >= NA ){\n    return NA;\n  }\n  if( least >= ans ){\n    return ans;\n  }\n  // ans = min( ans, least );\n  for(int w = 0; w < 2; ++w){\n    for(int dir = 0; dir < DIRMAX; ++dir){\n      State next = now;\n      if( next.move( w, dir ) ){\n\tans = min( ans, IterativeDeepning( depth + 1, next, ans ) );\n      }\n    }\n  }\n  return NA;\n}\n\nint main()\n{\n  while(true){\n    int map[N][N];\n    int ans;\n    fill(&map[0][0],&map[N-1][N],-1);\n    \n    const int imax[] = {1,3,5,3,1};\n    const int dj[] = {2,1,0,1,2};\n    for(int i = 0; i < 5; ++i){\n      for(int j = 0; j < imax[i]; ++j){\n\tint t;\n\tcin >> t;\n\tif( t < 0 ) return 0;\n\tmap[i+1][j+dj[i]+1]=t;\n      }\n    }\n\n    /*\n    for(int i = 0; i < N; ++i){\n      for(int j = 0; j < N; ++j){\n\tcout << setw(3) << map[i][j] << ' ';\n      }\n      cout << endl;\n    }\n    cout << endl;\n    */\n\n    ans = NA;\n    IterativeDeepning( 0, State(map), ans );\n    if( ans >= NA ){\n      cout << \"NA\" << endl;\n    }else{\n      cout << ans << endl;\n    }\n      \n  }\n  return 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include<iostream>\n#include<vector>\n#include<queue>\n#include<map>\n#include<cmath>\n#include<cstdlib>\n#include<algorithm>\nusing namespace std;\n\nstring ans;\n\nclass board{\npublic:\n  int h,c;\n  string s;\n  board(int x,int y,string z){ h=x; c=y; s=z;}\n  const bool operator<(const board x)const{return (h+c>x.h+x.c) || (h+c==x.h+x.c && c>x.c); }\n};\n\nint score(string s){\n  int res=0,m;\n  for(int i=0;i<25;i++){\n    if(s[i]!='x' && s[i]!='o'){\n      for(int j=0;j<25;j++){\n\tif(s[i]==ans[j]){\n\t  int a = abs(i-j);\n\t  int tmp = a/5 + a%5;\n\t  m = tmp;\n\t  break;\n\t}\n      }\n      res += m;\n    }\n  }\n  return res;\n}\n\nchar trans(int x){\n  if(!x)return 'o';\n  else return 'a'+x-1;\n}\n\nint main(){\n  string s;\n  ans = \"xxoxxxabcxdefghxijkxxxoxx\";\n  int tmp,cost;\n\n  for(;;){\n    cin >> tmp;\n    if(tmp<0)break;\n\n    s = \"xx\";\n    s += trans(tmp);\n    s += \"xxx\";\n    for(int i=0;i<3;i++){\n      cin >> tmp;\n      s += trans(tmp);\n    }\n    s += \"x\";\n    for(int i=0;i<5;i++){\n      cin >> tmp;\n      s += trans(tmp);\n    }\n    s += \"x\";\n    for(int i=0;i<3;i++){\n      cin >> tmp;\n      s+= trans(tmp);\n    }\n    s += \"xxx\";\n    cin >> tmp;\n    s += trans(tmp);\n    s += \"xx\";\n\n    priority_queue<board> q;\n    q.push(board(score(s),0,s));\n\n    map<string,bool> m;\n    m[s] = 0;\n    while(q.size()){\n      board p = q.top();q.pop();\n      int dx[] = {-5,1,5,-1};\n      //cout << p.h << \" \" << p.c << \" \" << p.s << endl;\n      cost = p.c;\n      if(p.s == ans)break;\n      if(p.h+cost>20){\n\tcost = 21;\n\tbreak;\n      }\n      m[p.s] = true;\n      for(int i=0;i<25;i++){\n\tif(p.s[i]=='o'){\n\t  for(int j=0;j<4;j++){\n\t    int sx = i + dx[j];\n\t    string str = p.s;\n\t    if(sx<0 || 25<=sx)continue;\n\t    if(str[sx] == 'x' || str[sx] == 'o')continue;\n\t    swap(str[i],str[sx]);\n\t    if(!m[str])q.push(board(score(str),cost+1,str));\n\t  }\n\t}\n      }\n    }\n\n\n\n    if(cost>20)cout << \"NA\\n\";\n    else cout << cost << endl;\n  }\n}"
  },
  {
    "language": "C++",
    "code": "#include <iostream>\n#include <string>\n#include <sstream>\n#include <map>\n#include <queue>\nusing namespace std;\n\n#define REP(i,n,m) for(int i=n;i<m;i++)\n#define rep(i,n) REP(i,0,n)\n\nclass State{\npublic:\n\tstring s;\n\tint cost;\n\tint idx[2];\n\n\tState(string ts,int tcost,int tidx[]){\n\t\ts = ts;\n\t\tcost = tcost;\n\t\tidx[0] = tidx[0];\n\t\tidx[1] = tidx[1];\n\t}\n};\n\nint di[13][4] = {\n\t{-1,-1,2,-1},\n\t{-1,2,5,-1},\n\t{0,3,6,1},\n\t{-1,-1,7,2},\n\t{-1,5,-1,-1},\n\t{1,6,9,4},\n\t{2,7,10,5},\n\t{3,8,11,6},\n\t{-1,-1,-1,7},\n\t{5,10,-1,-1},\n\t{6,11,12,9},\n\t{7,-1,-1,10},\n\t{10,-1,-1,-1},\n};\n\nvoid printPuzzle(string s){\n\tcout<<\"  \"<<s.substr(0,1)<<endl;\n\tcout<<\" \"<<s.substr(1,3)<<endl;\n\tcout<<s.substr(4,5)<<endl;\n\tcout<<\" \"<<s.substr(9,3)<<endl;\n\tcout<<\"  \"<<s.substr(12,1)<<endl;\n\tcout<<\"----------------------------\\n\";\n}\n\nqueue<State> open;\nmap<string,int> closed;\n\nint main(void){\n\tstring alpha = \"abcdefghijkl\";\n\tint idx[] = {0,12};\n\n\topen.push(State(\"abcdefghijkla\",0,idx));\n\tclosed.insert(pair<string,int>(\"abcdefghijkla\",0));\n\n\twhile(!open.empty()){\n\t\tState st = open.front(); open.pop();\n\t\tif(st.cost >= 20) continue;\n\n\t\trep(i,2){\n\t\t\trep(j,4){\n\t\t\t\tint to = di[st.idx[i]][j];\n\t\t\t\tif(to == -1) continue;\n\n\t\t\t\tstring res = st.s;\n\t\t\t\tint tmp = res[st.idx[i]];\n\t\t\t\tres[st.idx[i]] = res[to];\n\t\t\t\tres[to] = tmp;\n\n\t\t\t\tif(closed.find(res) == closed.end()){\n\t\t\t\t\tidx[0] = i==0 ? to : st.idx[0];\n\t\t\t\t\tidx[1] = i==1 ? to : st.idx[1];\n\t\t\t\t\topen.push(State(res,st.cost+1,idx));\n\t\t\t\t\tclosed.insert(pair<string,int>(res,st.cost+1));\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t}\n\n\twhile(1){\n\t\tint x;\n\t\tcin>>x;\n\t\tif(x == -1) break;\n\n\t\tstringstream ss;\n\t\tss<<alpha[x];\n\t\trep(i,12){\n\t\t\tcin>>x;\n\t\t\tss<<alpha[x];\n\t\t}\n\n\t\tstring start = ss.str();\n\t\tmap<string,int>::iterator iter = closed.find(start);\n\t\tif(iter == closed.end()) cout<<\"NA\\n\";\n\t\telse cout<<iter->second<<endl;\n\t}\n\n\treturn 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include<iostream>\n#include<vector>\n#include<algorithm>\n#include<map>\n#include<queue>\n\nusing namespace std;\n\nmap<vector<int>,int>mp,used;\n\nstruct State{\n  vector<int>v;\n  int t;\n  State(vector<int>v,int t):v(v),t(t){}\n};\n\nvector<vector<int> > generate(vector<int> v){\n  vector<vector<int> >res;\n\n  for(int i=0;i<13;i++){\n    if(v[i]==0){\n      vector<int>tmp=v;\n      switch(i){\n      case 0:\n\tswap(tmp[0],tmp[2]);\n\tres.push_back(tmp);\n\tbreak;\n      case 1:\n\tswap(tmp[1],tmp[2]);\n\tres.push_back(tmp);\n\tswap(tmp[1],tmp[2]);\n\tswap(tmp[1],tmp[5]);\n\tres.push_back(tmp);\n\tbreak;\n      case 2:\n\tswap(tmp[2],tmp[0]);\n\tres.push_back(tmp);\n\tswap(tmp[2],tmp[0]);\n\n\tswap(tmp[2],tmp[1]);\n\tres.push_back(tmp);\n\tswap(tmp[2],tmp[1]);\n\n\tswap(tmp[2],tmp[3]);\n\tres.push_back(tmp);\n\tswap(tmp[2],tmp[3]);\n\n\tswap(tmp[2],tmp[6]);\n\tres.push_back(tmp);\n\tbreak;\n      case 3:\n\tswap(tmp[3],tmp[2]);\n\tres.push_back(tmp);\n\tswap(tmp[3],tmp[2]);\n\n\tswap(tmp[3],tmp[7]);\n\tres.push_back(tmp);\n\tbreak;\n      case 4:\n\tswap(tmp[4],tmp[5]);\n\tres.push_back(tmp);\n\tbreak;\n      case 5:\n\tswap(tmp[5],tmp[1]);\n\tres.push_back(tmp);\n\tswap(tmp[5],tmp[1]);\n\n\tswap(tmp[5],tmp[4]);\n\tres.push_back(tmp);\n\tswap(tmp[5],tmp[4]);\n\n\tswap(tmp[5],tmp[6]);\n\tres.push_back(tmp);\n\tswap(tmp[5],tmp[6]);\n\n\tswap(tmp[5],tmp[9]);\n\tres.push_back(tmp);\n\tbreak;\n      case 6:\n\tswap(tmp[6],tmp[2]);\n\tres.push_back(tmp);\n\tswap(tmp[6],tmp[2]);\n\n\tswap(tmp[6],tmp[5]);\n\tres.push_back(tmp);\n\tswap(tmp[6],tmp[5]);\n\n\tswap(tmp[6],tmp[7]);\n\tres.push_back(tmp);\n\tswap(tmp[6],tmp[7]);\n\n\tswap(tmp[6],tmp[10]);\n\tres.push_back(tmp);\n\tbreak;\n      case 7:\n\tswap(tmp[7],tmp[3]);\n\tres.push_back(tmp);\n\tswap(tmp[7],tmp[3]);\n\n\tswap(tmp[7],tmp[6]);\n\tres.push_back(tmp);\n\tswap(tmp[7],tmp[6]);\n\n\tswap(tmp[7],tmp[8]);\n\tres.push_back(tmp);\n\tswap(tmp[7],tmp[8]);\n\n\tswap(tmp[7],tmp[11]);\n\tres.push_back(tmp);\n\tbreak;\n      case 8:\n\tswap(tmp[8],tmp[7]);\n\tres.push_back(tmp);\n\tbreak;\n      case 9: \n\tswap(tmp[9],tmp[5]);\n\tres.push_back(tmp);\n\tswap(tmp[9],tmp[5]);\n\n\tswap(tmp[9],tmp[10]);\n\tres.push_back(tmp);\n\tbreak;\n      case 10:\n\tswap(tmp[10],tmp[6]);\n\tres.push_back(tmp);\n\tswap(tmp[10],tmp[6]);\n\n\tswap(tmp[10],tmp[9]);\n\tres.push_back(tmp);\n\tswap(tmp[10],tmp[9]);\n\n\tswap(tmp[10],tmp[11]);\n\tres.push_back(tmp);\n\tswap(tmp[10],tmp[11]);\n\n\tswap(tmp[10],tmp[12]);\n\tres.push_back(tmp);\n\tbreak;\n      case 11:\n\tswap(tmp[11],tmp[7]);\n\tres.push_back(tmp);\n\tswap(tmp[11],tmp[7]);\n\n\tswap(tmp[11],tmp[10]);\n\tres.push_back(tmp);\n\tbreak;\n      case 12:\n\tswap(tmp[12],tmp[10]);\n\tres.push_back(tmp);\n\tbreak;\n      }\n    }\n  }\n  return res;\n}\n\nvoid bfs(void){\n\n  queue<State>que;\n  vector<int>s;\n  for(int i=0;i<12;i++)s.push_back(i);\n  s.push_back(0);\n  que.push(State(s,0));\n\n  while(!que.empty()){\n    State now=que.front();\n    que.pop();\n    \n    if(mp.count(now.v) && now.t>=mp[now.v])continue;\n    if(now.t>=12)continue;\n\n    mp[now.v]=now.t;\n\n    vector<vector<int> >res=generate(now.v);\n    for(int i=0;i<res.size();i++){\n      que.push(State(res[i],now.t+1));\n    }\n  }\n}\n\nint bfs(vector<int> s){\n  \n  used.clear();\n  \n  queue<State>que;\n  que.push(State(s,0));\n  \n  while(!que.empty()){\n    State now=que.front();\n    que.pop();\n    \n    if(now.t>=11)continue;\n    if(used.count(now.v))continue;\n    if(mp.count(now.v))return now.t+mp[now.v];\n    used[now.v]=1;\n    \n    vector<vector<int> >res=generate(now.v);\n    for(int i=0;i<res.size();i++){\n      que.push(State(res[i],now.t+1));\n    }\n  }\n  return -1;\n}\n\nint main(void){\n\n  bfs();\n\n  while(true){\n    vector<int>s(13);\n    for(int i=0;i<13;i++){\n      cin >> s[i];\n      if(s[i]<0)return 0;\n    }\n    int res=bfs(s);\n    if(res<0 || res>20)cout << \"NA\" << endl;\n    else cout << res << endl;\n  }\n\n  return 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include<iostream>\n#include<algorithm>\n#include<vector>\n#include<queue>\n#include<unordered_map>\n#include<unordered_set>\n#define lol(i,n) for(int i=0;i<n;i++)\n#define mod 1000000007\ntypedef long long ll;\nusing namespace std;\nint dx[13][4]={\n  {3,0,0,0},\n  {3,6,0,0},\n  {1,2,4,7},\n  {3,8,0,0},\n  {6,0,0,0},\n  {2,5,7,10},\n  {3,6,8,11},\n  {4,7,9,12},\n  {8,0,0,0},\n  {6,11,0,0},\n  {7,10,12,13},\n  {8,11,0,0},\n  {11,0,0,0}\n};\nunordered_map<ll,int> mp;\nll Compress(int p[]){\n  ll ans=0;\n  for(int i=0;i<13;i++){\n    ans*=13;\n    ans+=p[i];\n  }\n  return ans;\n}\n \nint unzip[13];\nvoid Unzip(ll x){\n  for(int i=0;i<13;i++){\n    unzip[12-i]=x%13;\n    x/=13;\n  }\n}\n \nint beflen=0;\nunordered_set<ll> vist;\nqueue<pair<ll,int> >Q;\nvoid BFS(int p[],int len){\n  //if(len!=beflen){cout<<len<<endl;beflen=len;}\n  ll tmp=Compress(p);\n  mp[tmp]=len;\n  vist.insert(tmp);\n  if(len==12)return;\n  lol(i,13){\n    if(p[i]==0){\n      lol(j,4){\n    int t=dx[i][j];\n    if(t==0)break;\n    t--;\n    if(p[t]!=0){\n      swap(p[i],p[t]);\n      tmp=Compress(p);\n      if(vist.find(tmp)!=vist.end())continue;\n      vist.insert(tmp);\n      Q.push(make_pair(tmp,len+1));\n      swap(p[i],p[t]);\n    }\n      }\n    }\n  }\n}\n \nunordered_set<ll> st;\nint ans;\nvoid EFS(int p[],int len){\n  //if(len!=beflen){cout<<len<<endl;beflen=len;}\n  ll tmp=Compress(p);\n  if(vist.find(tmp)!=vist.end()){\n    ans=len+mp[tmp];\n    return;\n  }\n  if(len==8)return;\n  lol(i,13){\n    if(p[i]==0){\n      lol(j,4){\n    int t=dx[i][j];\n    if(t==0)break;\n    t--;\n    if(p[t]!=0){\n      swap(p[i],p[t]);\n      tmp=Compress(p);\n      if(st.find(tmp)!=st.end())continue;\n      st.insert(tmp);\n      Q.push(make_pair(tmp,len+1));\n      swap(p[i],p[t]);\n    }\n      }\n    }\n  }\n}\nint main(){\n  int p[13];\n  lol(i,13)p[i]=i;p[12]=0;\n  Q.push(make_pair(Compress(p),0));\n  while(!Q.empty()){\n    ll data=Q.front().first;\n    int len=Q.front().second;\n    Q.pop();\n    if(mp[data]>0)continue;\n    Unzip(data);\n    BFS(unzip,len);\n  }\n  //cout<<\"#\"<<mp.size()<<endl;\n  while(cin>>p[0]&&p[0]!=-1){\n    for(int i=1;i<13;i++)cin>>p[i];\n    ans=mod;\n    Q.push(make_pair(Compress(p),0));\n    while(!Q.empty()){\n      ll data=Q.front().first;\n      int len=Q.front().second;\n      Q.pop();\n      if(ans!=mod)continue;\n      if(st.find(data)!=st.end())continue;\n      st.insert(data);\n      Unzip(data);\n      EFS(unzip,len);\n    }\n    st.clear();\n    if(ans>20)cout<<\"NA\"<<endl;\n    else cout<<ans<<endl;\n  }\n  return 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include<bits/stdc++.h>\nusing namespace std;\n  \ntypedef long long int64;\nconst int INF = 1 << 30;\n  \nvector< int > edge[13];\nmap< string, int > memo;\n \nbool back(string str, int cnt){ //枝刈り大事だな\n  static int dist[] = { 0, 2, 1, 2, 4, 3, 2, 3, 4, 2, 1, 2, 0};\n  static int fuee[] = { 2, 0, 1, 2, 2, 1, 2, 3, 4, 2, 3, 4, 4};\n \n  if(cnt > 20) return true;\n  int foo = 0;\n  for(int i = 0; i < 13; i++){\n    if(str[i] == '0') foo += dist[i];\n    if(str[i] == '1') foo += fuee[i];\n  }\n  return cnt + foo > 20;\n}\n \n \nint bfs(string mas){\n \n  queue< string > que;\n  map< string , int > used;\n  que.push( mas );\n  memo[mas] = 0;\n  while(!que.empty()){\n \n    string p = que.front(); que.pop();\n    if(back( p, memo[p])) break;\n    if(p == \"0123456789AB0\") return memo[p];\n \n    for(int i = 0; i < 13; i++){\n      if(p[i] == '0') {\n        for(int j = 0; j < edge[i].size(); j++){\n          string next = p;\n          swap( next[i], next[edge[i][j]]);\n          if(memo.find(next) != memo.end()) continue;\n          que.push( next );\n          memo[next] = memo[p] + 1;\n        }\n      }\n    }\n  }\n  return -1;\n}\n \nint main(){\n  vector< int > mas(13);\n \n  edge[0].push_back(2);\n  edge[1].push_back(2); edge[1].push_back(4);\n  edge[2].push_back(0); edge[2].push_back(1); edge[2].push_back(3); edge[2].push_back(6);\n  edge[3].push_back(2); edge[3].push_back(7);\n  edge[4].push_back(5);\n  edge[5].push_back(1); edge[5].push_back(4); edge[5].push_back(6); edge[5].push_back(9);\n  edge[6].push_back(2); edge[6].push_back(5); edge[6].push_back(7); edge[6].push_back(10);\n  edge[7].push_back(3); edge[7].push_back(6); edge[7].push_back(8); edge[7].push_back(11);\n  edge[8].push_back(7);\n  edge[9].push_back(5); edge[9].push_back(10);\n  edge[10].push_back(6); edge[10].push_back(9); edge[10].push_back(11); edge[10].push_back(12);\n  edge[11].push_back(7); edge[11].push_back(10);\n  edge[12].push_back(10);\n \n  while(cin >> mas[0], mas[0] != -1){\n    for(int i = 1; i < 13; i++){\n      cin >> mas[i];\n    }\n \n    string start = \"\";\n    for(int i = 0; i < 13; i++){\n      if(mas[i] >= 10) start += (char)(mas[i] - 10 + 'A');\n      else start += mas[i] + '0';\n    }\n    int ret = bfs(start);\n    if(~ret) cout << ret << endl;\n    else cout << \"NA\" << endl;\n \n    memo.clear();\n  }\n}"
  },
  {
    "language": "C++",
    "code": "#include<iostream>\n#include<map>\n#include<deque>\n#include<cstdlib>\nusing namespace std;struct B{int z[2];char s[14];bool operator<(const B&r)const{return strcmp(s,r.s)<0;}};int main(){int a[13][5]={{2,-1},{2,5,-1},{0,1,3,6,-1},{2,7,-1},{5,-1},{1,4,6,9,-1},{2,5,7,10,-1},{3,6,8,11,-1},{7,-1},{5,10,-1},{6,9,11,12,-1},{7,10,-1},{10,-1},},gx[]={2,1,2,3,0,1,2,3,4,1,2,3,2},gy[]={0,1,1,1,2,2,2,2,2,3,3,3,4},v,d,s,i,j;B g={0,0,\"0123456789:;0\"};for(;;){map<B,int>m;deque<B>q;B b={-1,-1};for(i=0;i<13;i++){cin>>v;if(v==-1)return 0;b.s[i]='0'+v;if(!v)b.z[b.z[0]!=-1]=i;}b.s[13]=0;m[b]=1;for(q.push_back(b);!q.empty();q.pop_front()){B&b=q.front();if(!strcmp(b.s,g.s))break;d=0;for(i=13;i--;){v=b.s[i]-'0';if(v)d+=abs(gx[v]-gx[i])+abs(gy[v]-gy[i]);}s=m[b];if(s+d<22)for(j=2;j--;)for(i=0;~a[b.z[j]][i];i++){B n=b;n.z[j]=a[b.z[j]][i];if(n.z[j]-n.z[1-j]){swap(n.s[b.z[j]],n.s[n.z[j]]);int&t=m[n];if(!t){t=s+1;q.push_back(n);}}}}m[g]?cout<<m[g]-1<<endl:cout<<\"NA\\n\";}}"
  },
  {
    "language": "C++",
    "code": "#include<iostream>\n#include<algorithm>\n#include<vector>\n#include<queue>\n#include<unordered_map>\n#define lol(i,n) for(int i=0;i<n;i++)\n#define mod 1000000007\ntypedef long long ll;\nusing namespace std;\nint dx[13][4]={\n  {3,0,0,0},\n  {3,6,0,0},\n  {1,2,4,6},\n  {3,8,0,0},\n  {6,0,0,0},\n  {2,5,7,10},\n  {3,6,8,11},\n  {4,7,9,12},\n  {8,0,0,0},\n  {6,11,0,0},\n  {6,10,12,13},\n  {8,11,0,0},\n  {11,0,0,0}\n};\nunordered_map<ll,int> mp;\nll Compress(int p[]){\n  ll ans=0;\n  for(int i=0;i<13;i++){\n    ans*=13;\n    ans+=p[i];\n  }\n  return ans;\n}\n\nint unzip[13];\nvoid Unzip(ll x){\n  for(int i=0;i<13;i++){\n    unzip[12-i]=x%13;\n    x/=13;\n  }\n}\n\nint beflen=0;\nqueue<pair<ll,int> >Q;\nvoid BFS(int p[],int len){\n  //if(len!=beflen){cout<<len<<endl;beflen=len;}\n  ll tmp=Compress(p);\n  mp[tmp]=len;\n  if(len==15)return;\n  lol(i,13){\n    if(p[i]==0){\n      lol(j,4){\n\tint t=dx[i][j];\n\tif(t==0)break;\n\tt--;\n\tif(p[t]!=0){\n\t  swap(p[i],p[t]);\n\t  tmp=Compress(p);\n\t  if(mp[tmp]!=0)continue;\n\t  mp[tmp]=-1;\n\t  Q.push(make_pair(tmp,len+1));\n\t  swap(p[i],p[t]);\n\t}\n      }\n    }\n  }\n}\n\nint ans;\nvoid EFS(int p[],int len){\n  //if(len!=beflen){cout<<len<<endl;beflen=len;}\n  ll tmp=Compress(p);\n  if(mp[tmp]>0){\n    ans=min(ans,len+mp[tmp]-1);\n    return;\n  }\n  if(len==7)return;\n  lol(i,13){\n    if(p[i]==0){\n      lol(j,4){\n\tint t=dx[i][j];\n\tif(t==0)break;\n\tt--;\n\tif(p[t]!=0){\n\t  swap(p[i],p[t]);\n\t  tmp=Compress(p);\n\t  Q.push(make_pair(tmp,len+1));\n\t  swap(p[i],p[t]);\n\t}\n      }\n    }\n  }\n}\nint main(){\n  int p[13];\n  lol(i,13)p[i]=i;p[12]=0;\n  Q.push(make_pair(Compress(p),1));\n  while(!Q.empty()){\n    ll data=Q.front().first;\n    int len=Q.front().second;\n    Q.pop();\n    if(mp[data]>0)continue;\n    Unzip(data);\n    BFS(unzip,len);\n  }\n  while(cin>>p[0]&&p[0]!=-1){\n    for(int i=1;i<13;i++)cin>>p[i];\n    ans=mod;\n    Q.push(make_pair(Compress(p),0));\n    while(!Q.empty()){\n      ll data=Q.front().first;\n      int len=Q.front().second;\n      Q.pop();\n      Unzip(data);\n      EFS(unzip,len);\n    }\n    if(ans>20)cout<<\"NA\"<<endl;\n    else cout<<ans<<endl;\n  }\n  return 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include<iostream>\n#include<vector>\n#include<queue>\n#include<map>\n#include<cmath>\n#include<cstdlib>\n#include<algorithm>\nusing namespace std;\n\nstring ans;\n\nclass board{\npublic:\n  int h,c;\n  string s;\n  board(int x,int y,string z){ h=x; c=y; s=z;}\n  const bool operator<(const board x)const{return (h+c>x.h+x.c) || (h+c==x.h+x.c && c>x.c); }\n};\n\nint score(string s){\n  int res=0;\n  int o[2];\n  o[0] = -1;\n  o[1] = -1;\n  for(int i=0;i<25;i++){\n    if(s[i]!='x'){\n      int m;\n      if(s[i]!='o'){\n\tfor(int j=0;j<25;j++){\n\t  if(s[i]==ans[j]){\n\t    int a = abs(i-j);\n\t    int tmp = a/5 + a%5;\n\t    m = tmp;\n\t    break;\n\t  }\n\t}\n      }else{\n\tif(o[0]<0){\n\t  for(int j=0;j<25;j++){\n\t    if(s[i]==ans[j]){\n\t      int a =abs(i-j);\n\t      if(o[0]<0)o[0] = a/5+a%5;\n\t      else o[1] = a/5+a%5;\n\t    }\n\t  }\n\t}else{\n\t  m = -1;\n\t  for(int j=0;j<25;j++){\n\t    if(s[i]==ans[j]){\n\t      int a = abs(i-j);\n\t      int tmp = a/5+a%5;\n\t      if(m<0)m = tmp + o[1];\n\t      else m = min(m,tmp+o[0]);\n\t    }\n\t  }\n\t}\n      }\n      res += m;\n    }\n  }\n  return res/2;\n}\n\nchar trans(int x){\n  if(!x)return 'o';\n  else return 'a'+x-1;\n}\n\nint main(){\n  string s;\n  ans = \"xxoxxxabcxdefghxijkxxxoxx\";\n  int tmp,cost;\n\n  for(;;){\n    cin >> tmp;\n    if(tmp<0)break;\n\n    s = \"xx\";\n    s += trans(tmp);\n    s += \"xxx\";\n    for(int i=0;i<3;i++){\n      cin >> tmp;\n      s += trans(tmp);\n    }\n    s += \"x\";\n    for(int i=0;i<5;i++){\n      cin >> tmp;\n      s += trans(tmp);\n    }\n    s += \"x\";\n    for(int i=0;i<3;i++){\n      cin >> tmp;\n      s+= trans(tmp);\n    }\n    s += \"xxx\";\n    cin >> tmp;\n    s += trans(tmp);\n    s += \"xx\";\n\n    priority_queue<board> q1;\n    q1.push(board(score(s),0,s));\n\n    map<string,bool> m1;\n    m1[s] = 0;\n    while(q1.size()){\n      board p = q1.top();q1.pop();\n      int dx[] = {-5,1,5,-1};\n      //cout << p.h << \" \" << p.c << \" \" << p.s << endl;\n      cost = p.c;\n      if(p.s == ans)break;\n      if(p.h+cost>20){\n\tcost = 21;\n\tbreak;\n      }\n\n      for(int i=0;i<25;i++){\n\tif(p.s[i]=='o'){\n\t  for(int j=0;j<4;j++){\n\t    int sx = i + dx[j];\n\t    string str = p.s;\n\t    if(sx<0 || 25<=sx)continue;\n\t    if(str[sx] == 'x' || str[sx] == 'o')continue;\n\t    swap(str[i],str[sx]);\n\t    if(!m1[str]){\n\t      q1.push(board(score(str),cost+1,str));\n\t      m1[str] = cost+1;\n\t    }\n\t  }\n\t}\n      }\n    }\n\n\n\n    if(cost>20)cout << \"NA\\n\";\n    else cout << cost << endl;\n  }\n}"
  },
  {
    "language": "C++",
    "code": "#include <iostream>\n#include <string>\n#include <vector>\n#include <queue>\n#include <map>\nusing namespace std;\n\nstring s = \"0123456789AB\";\nstring goal = \"0123456789AB0\";\n\nvector<vector<int>> adj = {\n    {2},\n    {2,5},\n    {0,1,3,6},\n    {2,7},\n    {5},\n    {1,4,6,9},\n    {2,5,7,10},\n    {3,6,8,11},\n    {7},\n    {5,10},\n    {6,9,11,12},\n    {7,10},\n    {10}\n};\n\nint solve(string stat) {\n    if (stat == goal) return 0;\n    map<string, int> dist;\n    dist[stat] = 0;\n    queue<string> q;\n    q.push(stat);\n    while ( ! q.empty()) {\n        string s = q.front();\n        q.pop();\n        for (int i=0; i<13; ++i) {\n            if (s[i] != '0') continue;\n            for (int j : adj[i]) {\n                string next = s;\n                next[i] = s[j];\n                next[j] = s[i];\n                int diff = 0;\n                for (int k=0; k<13; ++k) {\n                    diff += next[k] != goal[k];\n                }\n                if ( ! diff) {\n                    return dist[s] + 1;\n                }\n                if (dist.find(next) == dist.end() && dist[s] + 1 + diff <= 20) {\n                    q.push(next);\n                    dist[next] = dist[s] + 1;\n                }\n            }\n        }\n    }\n    return 21;\n}\n\nint main() {\n    while (1) {\n        string stat = \"\";\n        int k;\n        for (int i=0; i<13; ++i) {\n            if (cin >> k && !~k) return 0;\n            stat += s[k];\n        }\n        int ans = solve(stat);\n        if (ans <= 20) {\n            cout << ans << endl;\n            continue;\n        }\n        cout << \"NA\" << endl;\n    }\n    return 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include <iostream>\n#include <sstream>\n#include <cstdio>\n#include <cstdlib>\n#include <cmath>\n#include <ctime>\n#include <cstring>\n#include <climits>\n#include <algorithm>\n#include <map>\n#include <set>\n#include <stack>\n#include <vector>\n#include <queue>\n#include <bitset>\n#include <string>\nusing namespace std;\n \n#define rep(i,n) for(int i=0; i<n; i++)\n#define repa(i,s,e) for(int i=s; i<=e; i++)\n#define repd(i,s,e) for(int i=s; i>=e; i--)\n#define PB(a) push_back(a)\n#define MP(i,s) make_pair(i,s)\n \ntypedef long long ll;\n\nconst int dx[4] = {-1, 0, 0, 1};\nconst int dy[4] = {0, -1, 1, 0};\nconst int field[5][5] = {\n\t{0, 0, 1, 0, 0}, \n\t{0, 1, 1, 1, 0},\n\t{1, 1, 1, 1, 1},\n\t{0, 1, 1, 1, 0},\n\t{0, 0, 1, 0, 0}, \n};\n\nconst int ans[5][5] = {\n\t{0, 0, 0, 0, 0},\n\t{0, 1, 2, 3, 0},\n\t{4, 5, 6, 7, 8},\n\t{0, 9, 10, 11, 0},\n\t{0, 0, 0, 0, 0}\n};\n\nconst int px[13] = {2, 1, 2, 3, 0, 1, 2, 3, 4, 1, 2, 3, 2};\nconst int py[13] = {0, 1, 1, 1, 2, 2, 2, 2, 2, 3, 3, 3, 4};\n\nll H;\nint P[5][5];\nset<ll> used;\n\nll hash_val() {\n\tll h = 0;\n\trep(i,13) {\n\t\th *= 14;\n\t\th += P[py[i]][px[i]];\n\t}\n\treturn h;\n}\n\nbool dfs(int m, int d) {\n\tll h = hash_val();\n\tif(h == H) \treturn true;\n\tif(m == d) return false;\n\tif(used.find(h) != used.end()) return false;\n\n\tused.insert(h);\n\trep(i,13) {\n\t\tint x = px[i];\n\t\tint y = py[i];\n\t\tif(P[y][x] == 0) {\n\t\t\trep(k,4) {\n\t\t\t\tint xx = x + dx[k];\n\t\t\t\tint yy = y + dy[k];\n\t\t\t\tif(xx>=0 && yy>=0 && xx<5 && yy<5 && field[yy][xx] == 1 && P[yy][xx] != 0) {\n\t\t\t\t\tswap(P[y][x], P[yy][xx]);\n\t\t\t\t\tif(dfs(m+1, d)) return true;\n\t\t\t\t\tswap(P[y][x], P[yy][xx]);\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t}\n\treturn false;\n}\n\nvoid solve() {\n\trep(d,20) {\n\t\tused.clear();\n\t\tif(dfs(0, d)) {\n\t\t\tprintf(\"%d\\n\", d);\n\t\t\treturn;\n\t\t}\n\t}\n\tprintf(\"NA\\n\");\n}\n\nint main() {\n\tmemcpy(P, ans, sizeof(P));\n\tH = hash_val();\n\tfor(;;) {\n\t\trep(i,13) {\n\t\t\tscanf(\"%d\", &P[py[i]][px[i]]);\n\t\t\tif(P[py[i]][px[i]] < 0) return 0;\n\t\t}\n\t\tsolve();\n\t}\n}"
  },
  {
    "language": "C++",
    "code": "#include <cstdio>\n#include <cstring>\n#include <algorithm>\n#include <string>\n#include <cmath>\n#include <stack>\n#include <vector>\n#include <map>\n#include <set>\n#include <queue>\n#include <list>\n#include <iostream>\n#include <sstream>\n#include <climits>\n#include <cfloat>\n#include <complex>\n\nusing namespace std;\n\ntypedef long long ll;\n\nll encode(int* state)\n{\n\tll res = 0;\n\tfor (int i = 0; i < 13; ++i)\n\t\tres = res << 4 | state[i];\n\treturn res;\n}\nvoid decode(int* d, ll e)\n{\n\tfor (int i = 12; i >= 0; --i, e >>= 4)\n\t\td[i] = e & 15;\n}\n\nmap<ll, int> minSteps;\nint dir[] = { -1, 1, -2, 2, -4, 4 };\nmap<int, bool> ok[3];\n\nmap<ll, int> problemSteps;\n\nint start_from_initial(ll current, ll next)\n{\n\tbool newState = minSteps.count(next) == 0;\n\tif (newState)\n\t\tminSteps[next] = minSteps[current] + 1;\n\n\treturn newState && minSteps[next] < 10 ? 0 : -1;\n}\nint start_from_problem(ll current, ll next)\n{\n\tbool newState = problemSteps.count(next) == 0;\n\tif (newState)\n\t\tproblemSteps[next] = problemSteps[current] + 1;\n\n\tif (minSteps.count(next))\n\t\treturn problemSteps[next] + 10;\n\n\treturn newState && problemSteps[next] < 10 ? 0 : -1;\n}\nint bfs(ll initial, int (*f)(ll, ll))\n{\n\tqueue<ll> q;\n\tq.push(initial);\n\n\twhile (!q.empty())\n\t{\n\t\tll e = q.front();\n\t\tq.pop();\n\t\tint d[13];\n\t\tdecode(d, e);\n\n\t\tint zero_pos[2];\n\t\tfor (int i = 0, j = 0; j < 2; ++i)\n\t\t\tif (!d[i])\n\t\t\t\tzero_pos[j++] = i;\n\n\t\tfor (int i = 0; i < 2; ++i)\n\t\t{\n\t\t\tfor (int j = 0; j < 6; ++j)\n\t\t\t{\n\t\t\t\tint a = zero_pos[i];\n\t\t\t\tint b = a + dir[j];\n\t\t\t\tif (a > b)\n\t\t\t\t\tswap(a, b);\n\t\t\t\tif (a < 0 || b > 12 || !d[a] && !d[b] || !ok[j/2][a])\n\t\t\t\t\tcontinue;\n\n\t\t\t\tint copy[13];\n\t\t\t\tmemcpy(copy, d, sizeof(copy));\n\t\t\t\tswap(copy[a], copy[b]);\n\t\t\t\tll next = encode(copy);\n\n\t\t\t\tint r = f(e, next);\n\t\t\t\tif (r == 0)\n\t\t\t\t\tq.push(next);\n\t\t\t\telse if (r > 0)\n\t\t\t\t\treturn r;\n\t\t\t}\n\t\t}\n\t}\n\n\treturn -1;\n}\n\nint main()\n{\n\tint o[][9] = {\n\t\t{ 1, 2, 4, 5, 6, 7, 9, 10, -1 },\n\t\t{ 0, 10, -1 },\n\t\t{ 1, 2, 3, 5, 6, 7, -1 }\n\t};\n\tfor (int i = 0; i < 3; ++i)\n\t\tfor (int j = 0; o[i][j] != -1; ++j)\n\t\t\tok[i][o[i][j]] = true;\n\n\tint initial[] = { 0, 1, 2, 3, 4, 5, 6, 7, 8, 9, 10, 11, 0 };\n\tll t = encode(initial);\n\tminSteps[t] = 0;\n\n\tbfs(t, start_from_initial);\n\n\twhile (true)\n\t{\n\t\tint d[13];\n\t\tfor (int i = 0; i < 13; ++i)\n\t\t\tscanf(\"%d\", d + i);\n\t\tif (d[0] == -1)\n\t\t\tbreak;\n\n\t\tint ans = -1;\n\t\tll s = encode(d);\n\t\tif (minSteps.count(s))\n\t\t\tans = minSteps[s];\n\t\telse\n\t\t{\n\t\t\tproblemSteps.clear();\n\t\t\tans = bfs(s, start_from_problem);\n\t\t}\n\n\t\tif (ans != -1)\n\t\t\tprintf(\"%d\\n\", ans);\n\t\telse\n\t\t\tputs(\"NA\");\n\t}\n\n\treturn 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include <iostream>\n#include <vector>\nusing namespace std;\n\ntypedef vector <int> VI;\ntypedef vector <VI> VVI;\n\nVVI goal;\nVVI init;\n\nint limit;\n\nconst int di[4] = { 0, -1, 0, 1 };\nconst int dj[4] = { 1, 0, -1,  };\n\nconst int T[12][2] = {\n\t{ 0, 0 },\n\t{ 2, 2 },\n\t{ 2, 3 },\n\t{ 2, 4 },\n\t{ 3, 1 },\n\t{ 3, 2 },\n\t{ 3, 3 },\n\t{ 3, 4 },\n\t{ 3, 5 },\n\t{ 4, 2 },\n\t{ 4, 3 },\n\t{ 4, 4 }\n};\n\nint getMD( VVI P )\n{\n\tint sum = 0;\n\tint ti, tj;\n\tfor ( int i = 0; i < 7; i++ ) for ( int j = 0; j < 7; j++ )\n\t{\n\t\tif ( P[j][i] <= 0 )\n\t\t\tcontinue;\n\n\t\tti = T[P[j][i]][0];\n\t\ttj = T[P[j][i]][1];\n\t\tsum += ( max( ti, i ) - min( ti, i ) + max( tj, j ) - min( tj, j ) );\n\t}\n\treturn sum;\n}\n\nbool is_goal( VVI puzzle )\n{\n\tbool ok = true;\n\tfor ( int i = 0; ok && i < 7; i++ ) for ( int j = 0; ok && j < 7; j++ )\n\t{\n\t\tif ( puzzle[j][i] != goal[j][i] )\n\t\t\tok = false;\n\t}\n\treturn ok;\n}\n\nbool dfs( int depth, VVI now )\n{\n\tif ( is_goal( now ) )\n\t\treturn true;\n\n\tif ( depth + getMD( now ) > limit )\n\t\treturn false;\n\n\tfor ( int i = 0; i < 7; i++ ) for ( int j = 0; j < 7; j++ )\n\t{\n\t\tif ( now[j][i] != 0 )\n\t\t\tcontinue;\n\n\t\tfor ( int k = 0; k < 4; k++ )\n\t\t{\n\t\t\tVVI v = now;\n\t\t\tint ni = i + di[k];\n\t\t\tint nj = j + dj[k];\n\n\t\t\tif ( v[nj][ni] <= 0 )\n\t\t\t\tcontinue;\n\n\t\t\tswap( v[j][i], v[nj][ni] );\n\n\t\t\tif ( dfs( depth+1, v ) )\n\t\t\t\treturn true;\n\n\t\t}\n\t}\n\n}\n\nint idfs( VVI src )\n{\n\tfor ( limit = 0; limit < 20; limit++ )\n\t{\n\t\tif ( dfs( 0, src ) )\n\t\t\treturn limit;\n\t}\n\treturn -1;\n}\n\nint main( void )\n{\n\t// S[ÌóÔðìé\n\tgoal = VVI( 7, VI( 7, -1 ) );\n\tgoal[3][1] = 0;\n\tgoal[3][5] = 0;\n\tfor ( int i = 0; i < 3; i++ )\n\t{\n\t\tgoal[2+i][2] = 1+i;\n\t\tgoal[2+i][4] = 9+i;\n\t}\n\tfor ( int i = 0; i < 5; i++ )\n\t{\n\t\tgoal[1+i][3] = 4+i;\n\t}\n\n\twhile ( 1 )\n\t{\n\t\t// úóÔÌüÍ\n\t\tinit = VVI( 7, VI( 7, -1 ) );\n\t\tcin >> init[3][1];\n\t\tif ( init[3][1] == -1 )\n\t\t\tbreak;\n\t\tfor ( int i = 0; i < 3; i++ )\n\t\t\tcin >> init[2+i][2];\n\t\tfor ( int i = 0; i < 5; i++ )\n\t\t\tcin >> init[1+i][3];\n\t\tfor ( int i = 0; i < 3; i++ )\n\t\t\tcin >> init[2+i][4];\n\t\tcin >> init[3][5];\n\n\t\tint cost = idfs( init );\n\n\t\tif ( cost == -1 )\n\t\t\tcout << \"NA\" << endl;\n\t\telse\n\t\t\tcout << cost << endl;\n\n\t}\n\n\treturn 0;\n}"
  },
  {
    "language": "C++",
    "code": "#import<iostream>\n#import<map>\n#import<queue>\n#import<cstdlib>\n#import<cstring>\nusing namespace std;struct B{int z[2];char s[14];bool operator<(const B&r)const{return strcmp(s,r.s)<0;}};main(){int a[13][5]={{2,-1},{2,5,-1},{0,1,3,6,-1},{2,7,-1},{5,-1},{1,4,6,9,-1},{2,5,7,10,-1},{3,6,8,11,-1},{7,-1},{5,10,-1},{6,9,11,12,-1},{7,10,-1},{10,-1}},X[]={2,1,2,3,0,1,2,3,4,1,2,3,2},Y[]={0,1,1,1,2,2,2,2,2,3,3,3,4},v,d,s,i,j,t,u;B g={0,0,\"0123456789:;0\"};for(;;){map<B,int>m;queue<B>q;B b={i=-1,-1};for(;++i<13;!v?b.z[*b.z>=0]=i:0){cin>>v;if(v<0)return 0;b.s[i]=48+v;}b.s[13]=0;m[b]=1;for(q.push(b);!q.empty();q.pop()){B&b=q.front();if(!strcmp(b.s,g.s))break;for(d=i=0;i<13;v?d+=abs(X[v]-X[i])+abs(Y[v]-Y[i]):0,i++)v=b.s[i]-48;s=m[b];if(s+d<22)for(j=2;j--;)for(i=0;~a[u=b.z[j]][i];i++){B n=b;t=n.z[j]=a[u][i];if(t-n.z[1-j]){swap(n.s[u],n.s[t]);int&r=m[n];if(!r)r=s+1,q.push(n);}}}printf(m[g]?\"%d\\n\":\"NA\\n\",m[g]-1);}}"
  },
  {
    "language": "C++",
    "code": "#include <iostream>\n#include <sstream>\n#include <string>\n#include <algorithm>\n#include <vector>\n#include <stack>\n#include <queue>\n#include <set>\n#include <map>\n#include <cstdio>\n#include <cstdlib>\n#include <cstring>\n#include <cmath>\n\nusing namespace std;\n\n#define FOR(i,k,n) for(int i=(k); i<(int)n; ++i)\n#define REP(i,n) FOR(i,0,n)\n#define FORIT(i,c) for(__typeof((c).begin())i=(c).begin();i!=(c).end();++i)\n\nstruct S{\n  vector<int> p;\n  int t;\n  S(vector<int> p, int t) : p(p),t(t) {}\n};\n\nbool operator<(const S& s, const S& t){\n  return s.t > t.t;\n}\n\nint x[13] = {2,1,2,3,0,1,2,3,4,1,2,3,2};\nint y[13] = {4,3,3,3,2,2,2,2,2,1,1,1,0};\nvector<int> goal(13);\nset<vector<int> > memo;\nint distance(S s){\n  int count = 0;\n  REP(i,13){\n    if(s.p[i]){\n      count += abs(x[i]-x[s.p[i]]) + abs(y[i]-y[s.p[i]]);\n    }\n  }\n  return count+s.t;\n}\nvoid print_s(S s){\n  vector<int> v = s.p;\n  printf(\"time:%d\\n\",s.t);\n  printf(\"    %2d    \\n\",v[0]);\n  printf(\"  %2d%2d%2d  \\n\",v[1],v[2],v[3]);\n  printf(\"%2d%2d%2d%2d%2d\\n\",v[4],v[5],v[6],v[7],v[8]);\n  printf(\"  %2d%2d%2d  \\n\",v[9],v[10],v[11]);\n  printf(\"    %2d    \\n\",v[12]);\n}\nint bfs(S start){\n  priority_queue<S> que;\n  que.push(start);\n  while(!que.empty()){\n    S s = que.top(); que.pop();\n    //print_s(s);\n    if(s.t > 20) return -1;\n    if(s.p == goal) return s.t;\n    if(memo.find(s.p)!=memo.end()) continue;\n    memo.insert(s.p);\n    if(distance(s) > 20) continue;\n    REP(i,13){\n      vector<int> tmp = s.p;\n      if(s.p[i]==0){\n        switch(i){\n          case 0:\n          case 2:\n            swap(tmp[0],tmp[2]);\n            que.push(S(tmp,s.t+1));\n            break;\n          case 12:\n          case 10:\n            swap(tmp[12],tmp[10]);\n            que.push(S(tmp,s.t+1));\n            break;\n          case 4:\n          case 5:\n            swap(tmp[4],tmp[5]);\n            que.push(S(tmp,s.t+1));\n            break;\n          case 8:\n          case 7:\n            swap(tmp[8],tmp[7]);\n            que.push(S(tmp,s.t+1));\n            break;\n        }\n        if(i % 4 == 2 || i % 4 == 3){\n          tmp = s.p;\n          swap(tmp[i],tmp[i-1]);\n          que.push(S(tmp,s.t+1));\n        }\n        if(i % 4 == 1 || i % 4 == 2){\n          tmp = s.p;\n          swap(tmp[i],tmp[i+1]);\n          que.push(S(tmp,s.t+1));\n        }\n        if(i % 4 != 0 && i < 8){\n          tmp = s.p;\n          swap(tmp[i],tmp[i+4]);\n          que.push(S(tmp,s.t+1));\n        }\n        if(i % 4 != 0 && i > 4){\n          tmp = s.p;\n          swap(tmp[i],tmp[i-4]);\n          que.push(S(tmp,s.t+1));\n        }\n      }\n    }\n  }\n  return -1;\n}\nint main(){\n  int n;\n  vector<int> p(13);\n\n  REP(i,11) goal[i+1] = i+1;\n\n  while(cin>>p[0], p[0]!=-1){\n    for(int i = 1; i < 13; i++){\n      cin>>p[i];\n    }\n    S start(p,0);\n    memo.clear();\n    int ans = bfs(start);\n    if(ans == -1)cout<<\"NA\"<<endl;\n    else cout<< ans << endl;\n  }\n  return 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include<bits/stdc++.h>\n#define rep(i,n)for(int i=0;i<(n);i++)\nusing namespace std;\n\nint cx[]{ 0,1,1,1,2,2,2,2,2,3,3,3,4 }, cy[]{ 2,1,2,3,0,1,2,3,4,1,2,3,2 };\nint dx[]{ 1,-1,0,0 }, dy[]{ 0,0,1,-1 };\nint d[5][5], lim, D, x[2], y[2];\nbool dfs(int p) {\n\tif (D == 0)return true;\n\tif (p + D > lim)return false;\n\trep(j, 2)rep(i, 4) {\n\t\tint nx = x[j] + dx[i], ny = y[j] + dy[i];\n\t\tif (nx < 0 || 5 <= nx || ny < 0 || 5 <= ny || !d[nx][ny])return false;\n\t\tint a = abs(cx[d[nx][ny]] - nx) + abs(cy[d[nx][ny]] - ny);\n\t\tint b = abs(cx[d[nx][ny]] - x[j]) + abs(cy[d[nx][ny]] - y[j]);\n\t\tD += b - a; swap(d[x[j]][y[j]], d[nx][ny]); swap(x[j], nx); swap(y[j], ny);\n\t\tif (dfs(p + 1))return true;\n\t\tD -= b - a; swap(d[x[j]][y[j]], d[nx][ny]); swap(x[j], nx); swap(y[j], ny);\n\t}\n\treturn false;\n}\nint main() {\n\twhile (1) {\n\t\tD = 0; int p = 0;\n\t\trep(i, 13) {\n\t\t\tscanf(\"%d\", &d[cx[i]][cy[i]]);\n\t\t\tif (d[cx[i]][cy[i]] == -1)return 0;\n\t\t\tif (d[cx[i]][cy[i]] == 0) {\n\t\t\t\tx[p] = cx[i]; y[p++] = cy[i];\n\t\t\t}\n\t\t\telse D += abs(cx[i] - cx[d[cx[i]][cy[i]]]) + abs(cy[i] - cy[d[cx[i]][cy[i]]]);\n\t\t}\n\t\tfor (lim = 0; lim <= 20; lim++) {\n\t\t\tif (dfs(0)) {\n\t\t\t\tprintf(\"%d\\n\", lim); goto g;\n\t\t\t}\n\t\t}\n\t\tputs(\"NA\");\n\tg:;\n\t}\n}"
  },
  {
    "language": "C++",
    "code": "#include <iostream>\n#include <queue>\n#include <set>\nusing namespace std;\ntypedef long long ll;\n\nll mov[13][4] = {\n\t{2,-1,-1,-1},\n\t{2,5,-1,-1},\n\t{0,1,3,6},\n\t{2,7,-1,-1},\n\t{5,-1,-1,-1},\n\t{1,4,6,9},\n\t{2,5,7,10},\n\t{3,6,8,11},\n\t{7,-1,-1,-1},\n\t{5,10,-1,-1},\n\t{6,9,11,12},\n\t{7,10,-1,-1},\n\t{10,-1,-1,-1},\n};\n\nll sw(ll l, int i, int j) {\n\tint a, b;\n\ta = (l >> (4 * i)) & 0xfL;\n\tb = (l >> (4 * j)) & 0xfL;\n\n\tl &= ~(0xfL << (4*i));\n\tl &= ~(0xfL << (4*j));\n\n\tl |= (ll)b << (4 * i);\n\tl |= (ll)a << (4 * j);\n\n\treturn l;\n}\n\nint main() {\n\twhile(1) {\n\t\tll in = 0;\n\t\tfor(int i = 0; i < 13; i++) {\n\t\t\tint tmpin;\n\t\t\tcin >> tmpin;\n\t\t\tif(tmpin < 0)\n\t\t\t\treturn 0;\n\t\t\tin |= ((ll)tmpin << (4*i));\n\t\t}\n\n\t\tqueue<ll> q;\n\t\tset<ll> s;\n\t\tq.push(in);\n\t\ts.insert(in);\n\t\tint ans = -1;\n\t\t// debug\n\t\tint failcount = 0;\n\t\tfor(int i = 0; i <= 20; i++) {\n\t\t\tqueue<ll> next;\n\t\t\twhile(!q.empty()) {\n\t\t\t\tll l = q.front(); q.pop();\n\t\t\t\tif(l == 0xba9876543210) {\n\t\t\t\t\tans = i;\n\t\t\t\t\tgoto OUTPUT_ANSWER;\n\t\t\t\t}\n\t\t\t\telse {\n\t\t\t\t\tint cnt = 0;\n\t\t\t\t\tfor(int j = 0; j < 13; j++) {\n\t\t\t\t\t\tll t = 0xba9876543210;\n\t\t\t\t\t\tif(((l >> 4*j) & 0xfL) != ((t >> 4*j) & 0xfL)) {\n\t\t\t\t\t\t\tcnt++;\n\t\t\t\t\t\t}\n\t\t\t\t\t}\n\t\t\t\t\tif(cnt > 20 - i + 4)\n\t\t\t\t\t\tcontinue;\n\t\t\t\t}\n\n\t\t\t\tfor(int j = 0; j < 13; j++) {\n\t\t\t\t\tif(((l >> (4*j)) & 0xfL) == 0) {\n\t\t\t\t\t\tfor(int k = 0; k < 4; k++) {\n\t\t\t\t\t\t\tll p;\n\t\t\t\t\t\t\tif(mov[j][k] < 0)\n\t\t\t\t\t\t\t\tbreak;\n\t\t\t\t\t\t\tp = sw(l, j, mov[j][k]);\n\t\t\t\t\t\t\tif(s.find(p) == s.end()) {\n\t\t\t\t\t\t\t\ts.insert(p);\n\t\t\t\t\t\t\t\tnext.push(p);\n\t\t\t\t\t\t\t}\n\t\t\t\t\t\t\telse {\n\t\t\t\t\t\t\t\tfailcount++;\n\t\t\t\t\t\t\t}\n\t\t\t\t\t\t}\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t}\n\t\t\tq = next;\n\t\t}\n\nOUTPUT_ANSWER:;\n\t\tif(ans < 0)\n\t\t\tcout << \"NA\" << endl;\n\t\telse\n\t\t\tcout << ans << endl;\n//\t\tcout << failcount << endl;\n\t}\n}"
  },
  {
    "language": "C++",
    "code": "#include <cstdio>\n#include <cstdlib>\n#include <cmath>\n#include <climits>\n#include <cfloat>\n#include <map>\n#include <utility>\n#include <set>\n#include <iostream>\n#include <memory>\n#include <string>\n#include <vector>\n#include <algorithm>\n#include <functional>\n#include <sstream>\n#include <complex>\n#include <stack>\n#include <queue>\n#include <cstring>\n#include <sstream>\n#include <cassert>\n#include <list>\nusing namespace std;\nstatic const double EPS = 1e-10;\ntypedef long long ll;\ntypedef pair<int,int> PI;\ntypedef vector<int> vi;\n#ifndef M_PI\n#define M_PI 3.14159265358979323846\n#endif\n#define rep(i,n) for(int i=0;i<(int)n;++i)\n#define FOR(i,c) for(__typeof((c).begin())i=(c).begin();i!=(c).end();++i)\n#define ALL(c) (c).begin(), (c).end()\n#define mp(a,b) make_pair(a,b)\n#define pb(a) push_back(a)\n#define F first\n#define S second\ntemplate <typename T> string print_array(const vector<T> &V) { ostringstream os; os << \"{ \"; for (typename vector<T>::const_iterator iter = V.begin(); iter != V.end(); ++iter) os << '\\\"' << *iter << \"\\\",\"; os << \" }\"; return os.str(); }\n\nint dx[]={0,1,0,-1},dy[]={1,0,-1,0};\n\nvector<int> se[13];\nint x[]={0,-1,0,1,-2,-1,0,1,2,-1,0,1,0};\nint y[]={2,1,1,1,0,0,0,0,0,-1,-1,-1,-2};\n\nvoid pr(ll in){\n\n  printf(\"      %3lld\\n\",in&15);\n  printf(\"   %3lld%3lld%3lld\\n\",(in>>4)&15,(in>>8)&15,(in>>12)&15);\n  printf(\"%3lld%3lld%3lld%3lld%3lld\\n\",(in>>16)&15,(in>>20)&15,(in>>24)&15,(in>>28)&15,(in>>32)&15);\n  printf(\"   %3lld%3lld%3lld\\n\",(in>>36)&15,(in>>40)&15,(in>>44)&15);\n  printf(\"      %3lld\\n\",(in>>48)&15);\n  puts(\"\");\n}\n\nint manh(ll in){\n  int ret=0;\n  rep(i,13){\n    int t=(in>>(i*4))&15;\n\n    if(!t)continue;\n    int nx=(x[t]-x[i]),ny=y[t]-y[i];\n    ret+=abs(nx)+abs(ny);\n  }\n  return ret;\n}\n\nmain(){\n  ll p;\n\n  ll goal=0;\n  rep(i,11){\n    goal|=(i+1LL)<<(4*(i+1));\n    //cout<<goal<<endl;\n    //pr(goal);\n  }\n  //pr(goal);\n\n  se[0].pb(2);\n  se[1].pb(2);\n  se[1].pb(5);\n  se[2].pb(0);\n  se[2].pb(1);\n  se[2].pb(3);\n  se[2].pb(6);\n  se[3].pb(2);\n  se[3].pb(7);\n  se[4].pb(5);\n  se[5].pb(1);\n  se[5].pb(4);\n  se[5].pb(6);\n  se[5].pb(9);\n  se[6].pb(2);\n  se[6].pb(5);\n  se[6].pb(7);\n  se[6].pb(10);\n  se[7].pb(3);\n  se[7].pb(6);\n  se[7].pb(8);\n  se[7].pb(11);\n  se[8].pb(7);\n  se[9].pb(5);\n  se[9].pb(10);\n  se[10].pb(6);\n  se[10].pb(9);\n  se[10].pb(11);\n  se[10].pb(12);\n  se[11].pb(7);\n  se[11].pb(10);\n  se[12].pb(10);\n  \n  while(cin>>p){\n    if(p==-1)break;\n    ll in=p;\n\n    rep(i,12){\n      cin>>p;\n      in|=p<<(4*(i+1));\n    }\n\n    set<ll> app;\n\n    queue<pair<int,ll> > Q;\n    app.insert(in);\n    Q.push(mp(0,in));\n    int ans=21;\n    int mans=0;\n\n    while(!Q.empty()){\n      ll cvec=Q.front().S;\n      int ccost=Q.front().F;\n      Q.pop();\n    \n      //pr(cvec);\n\n      //if(ccost>3)break;\n      if(ccost+manh(cvec)>24)continue;\n      if(cvec==goal){\n\tans=ccost;\n\tbreak;\n      }\n      rep(i,13){\n\tll t=cvec>>(i<<2);\n\tt=t&15;\n\tif(!t){\n\t  rep(j,se[i].size()){\n\t    t=cvec>>(se[i][j]<<2);\n\t    t=t&15;\n\t    if(t){\n\t      ll nvec=cvec;\n\t      t=t<<(i<<2);\n\t      nvec|=t;\n\t      nvec&=~(15LL<<se[i][j]*4);\n\t      \n\t      if(!app.count(nvec)){\n\t\tapp.insert(nvec);\n\t\tQ.push(mp(ccost+1,nvec));\n\t      }\n\t    }\n\t  }\n\t}\n      }\n    }\n    if(ans==21)cout<<\"NA\"<<endl;\n    else cout<<ans<<endl;\n  }\n}"
  },
  {
    "language": "C++",
    "code": "#include <cmath>\n#include <iostream>\n#include <string>\n#include <vector>\n#include <queue>\n#include <map>\n#include <set>\n#include <array>\n#include <sstream>\nusing namespace std;\n#ifdef _MSC_VER\n#include \"_lib_msc.h\"\n#endif\n#define ITER(c)             __typeof__((c).begin())\n#define REP(i, n)           for(int(i)=0;(i)<(n);++(i))\ntemplate<class _T> _T MAX(_T p1,_T p2){return (p2<p1)?p1:p2;} \ntemplate<class _T> _T MIN(_T p1,_T p2){return (p1<p2)?p1:p2;} \ntypedef vector<int> VI;\ntypedef vector<VI> VVI;\n#define mp                  make_pair\n#define pb                  push_back\n\nconst int inf = 1<<29;\n\ntypedef array<char,13> obj;\nobj final  = {{0,1,2,3,4,5,6,7,8,9,10,11,0}};\nobj final1 = {{2,1,0,3,4,5,6,7,8,9,0,11,10}};\nobj final2 = {{2,1,0,3,4,5,6,7,8,9,10,11,0}};\nobj final3 = {{0,1,2,3,4,5,6,7,8,9,0,11,10}};\nint mov[][5] = {\n    {2,-1},         // 0\n    {2,5,-1},       // 1\n    {0,1,3,6,-1},   // 2\n    {2,7,-1},       // 3\n    {5,-1},         // 4\n    {1,4,6,9,-1},   // 5\n    {2,5,7,10,-1},  // 6\n    {3,6,8,11,-1},  // 7\n    {7,-1},         // 8\n    {5,10,-1},      // 9\n    {6,9,11,12,-1}, // 10\n    {7,10,-1},      // 11\n    {10,-1},        // 12\n};\nint dtblm[5][5] = {\n    {-1, -1,  0, -1, -1},\n    {-1,  1,  2,  3, -1},\n    { 4,  5,  6,  7,  8},\n    {-1,  9, 10, 11, -1},\n    {-1, -1, 12, -1, -1},\n};\nint dtbl[13][13];\n\nvoid mktbl(){\n    REP(y1,5) REP(x1,5){\n        if(dtblm[y1][x1] == -1) continue;\n        int k1 = dtblm[y1][x1];\n        REP(y2,5) REP(x2,5){\n            if(dtblm[y2][x2] == -1) continue;\n            int k2 = dtblm[y2][x2];\n            dtbl[k1][k2] = abs(x1-x2) + abs(y1-y2);\n        }\n    }\n}\n\nstruct QOBJ{\n    obj p;\n    int sp[2];\n    QOBJ(obj p, int sp1, int sp2) : p(p){sp[0]=sp1,sp[1]=sp2;}\n};\n\nint distance(const obj &p){\n    int total = 0;\n    REP(i,13){\n        if(p[i] == 0) continue;\n        total += dtbl[i][(int)(p[i])];\n    }\n    return total;\n}\n\nstring solve(const obj &o){\n    if(o == final) return \"0\";\n\n    map<obj, int> memo;\n    queue<QOBJ> q;\n    int sp1 = -1, sp2 = -1;\n    REP(i,13) if(o[i] == 0){\n        if(sp1 == -1) sp1 = i; else sp2 = i;\n    }\n    q.push(QOBJ(o,sp1,sp2));\n    memo[o] = 0;\n    int maxstep = 20;\n\n    while(!q.empty()){\n        QOBJ &p = q.front();\n        obj &pp = p.p;\n        int step = memo[pp];\n        if(step + distance(pp) < maxstep){\n            REP(sp,2){\n                int sps = p.sp[sp];\n                REP(mi, 4){\n                    int spd = mov[sps][mi];\n                    if(spd == -1) break;\n                    swap(pp[sps],pp[spd]);\n                    ITER(memo) it = memo.find(pp);\n                    if(it == memo.end() || it->second > step+1){\n                        if(it == memo.end()){\n                            memo[pp] = step+1;\n                        } else {\n                            it->second = step+1;\n                        }\n                        if(pp == final){\n                            maxstep = step;\n                        }\n                            if(sp == 0){\n                                q.push(QOBJ(pp,spd,p.sp[1]));\n                            } else {\n                                q.push(QOBJ(pp,p.sp[0],spd));\n                            }\n                    }\n                    swap(pp[sps],pp[spd]);\n                }\n            }\n        }\n        q.pop();\n    }\n    if(memo.count(final) == 0) return \"NA\";\n    if(memo[final] >= 21) return \"NA\";\n\n    stringstream ss;\n    ss << memo[final];\n\n    return ss.str();\n}\n\nint main(void){\n    mktbl();\n    int n,m;\n    while(cin >> n && n != -1){\n        obj o;\n        o[0] = n;\n        REP(i,3){ cin >> m; o[i+1] = m; }\n        REP(i,5){ cin >> m; o[i+4] = m; }\n        REP(i,3){ cin >> m; o[i+9] = m; }\n        cin >> m; o[12] = m;\n        cout << solve(o) << endl;\n    }\n    return 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include<bits/stdc++.h>\n#define r(i,n) for(int i=0;i<n;i++)\nusing namespace std;\ntypedef pair<vector<int>,int>P;\nvector<int>v[13],s(13),t(13);\nmap<vector<int>,int>m;\nvoid init(){\n\n    v[0].push_back(2);\n\n    v[1].push_back(2);\n    v[1].push_back(5);\n\n    v[2].push_back(0);\n    v[2].push_back(1);\n    v[2].push_back(3);\n    v[2].push_back(6);\n\n    v[3].push_back(2);\n    v[3].push_back(7);\n\n    v[4].push_back(5);\n\n    v[5].push_back(1);\n    v[5].push_back(4);\n    v[5].push_back(6);\n    v[5].push_back(9);\n\n    v[6].push_back(2);\n    v[6].push_back(5);\n    v[6].push_back(7);\n    v[6].push_back(10);\n\n    v[7].push_back(3);\n    v[7].push_back(6);\n    v[7].push_back(8);\n    v[7].push_back(11);\n\n    v[8].push_back(7);\n\n    v[9].push_back(5);\n    v[9].push_back(10);\n\n    v[10].push_back(6);\n    v[10].push_back(9);\n    v[10].push_back(11);\n    v[10].push_back(12);\n\n    v[11].push_back(7);\n    v[11].push_back(10);\n\n    v[12].push_back(10);\n}\nvoid BFS1(){\n    s[0]=0;\n    s[12]=0;\n    r(i,11)s[i+1]=i+1;\n    set<vector<int> >st;\n    st.insert(s);\n    m[s]=0;\n    queue<P>q;\n    q.push(P(s,0));\n    while(1){\n        vector<int>now=q.front().first;\n        int cost=q.front().second;\n        q.pop();\n        if(cost==6)break;\n        r(i,13)if(now[i]!=0){\n            r(j,v[i].size()){\n                swap(now[i],now[v[i][j]]);\n                if(!st.count(now)){\n                    st.insert(now);\n                    m[now]=cost+1;\n                    q.push(P(now,cost+1));\n                }\n                swap(now[i],now[v[i][j]]);\n            }\n        }\n    }\n}\n\nvoid BFS2(){\n    set<vector<int> >st;\n    st.insert(t);\n    queue<P>q;\n    q.push(P(t,0));\n    while(1){\n        vector<int>now=q.front().first;\n        int cost=q.front().second;\n        if(m.count(now)){\n            cout<<m[now]+cost<<endl;\n            return ;\n        }\n        q.pop();\n        if(cost==8)break;\n        r(i,13)if(now[i]!=0){\n            r(j,v[i].size()){\n                swap(now[i],now[v[i][j]]);\n                if(!st.count(now)){\n                    st.insert(now);\n                    q.push(P(now,cost+1));\n                }\n                swap(now[i],now[v[i][j]]);\n            }\n        }\n    }\n    cout<<\"NA\"<<endl;\n}\n\n\nint main(){\n    init();\n    BFS1();\n    while(cin>>t[0],t[0]!=-1){\n        r(i,12)cin>>t[i+1];\n        BFS2();\n    }\n}\n"
  },
  {
    "language": "C++",
    "code": "#include <iostream>\n#include <vector>\n#include <string>\n#include <algorithm>\n#include <tr1/unordered_map>\n\nusing namespace std;\n\n#define FOREACH(var,v) for(__typeof(v.begin()) var = v.begin(); var != v.end(); ++var)\n\nconst int NEIGHBOR[13][4] = {\n    {2, -1, -1, -1},\n    {2, 5, -1, -1},\n    {0, 1, 3, 6},\n    {2, 7, -1, -1},\n    {5, -1, -1, -1},\n    {1, 4, 6, 9},\n    {2, 5, 7, 10},\n    {3, 6, 8, 11},\n    {7, -1, -1, -1},\n    {5, 10, -1, -1},\n    {6, 9, 11, 12},\n    {7, 10, -1, -1},\n    {10, -1, -1, -1}\n};\ntypedef tr1::unordered_map<long long,int> CacheType;\nint field[13];\n\nlong long encode() {\n    long long res = 0;\n    for(int i = 0; i < 13; ++i) {\n        res *= 12;\n        res += field[i];\n    }\n    return res;\n}\n\nvoid decode(long long code, int *blank) {\n    int *ptr = blank;\n    for(int i = 12; i >= 0; --i) {\n        field[i] = code % 12;\n        if(field[i] == 0) {\n            *ptr = i;\n            ++ptr;\n        }\n        code /= 12;\n    }\n}\n\nstruct NullCallback {\n    void operator()(long long, int) const {}\n};\nstruct AnsCallback {\n    CacheType *cache;\n    int ans;\n    AnsCallback(CacheType *c) : cache(c), ans(100) {}\n\n    void operator()(long long code, int step) {\n        CacheType::const_iterator it = cache->find(code);\n        if(it != cache->end()) {\n            ans = min(ans, step + it->second);\n        }\n    }\n};\n\ntemplate <class T>\nvoid search(CacheType &cache, T &callback) {\n    vector<long long> q[2];\n    {\n        long long code = encode();\n        q[0].push_back(code);\n        cache[code] = 0;\n        callback(code, 0);\n    }\n    for(int step = 1; step <= 10; ++step) {\n        q[1].clear();\n        int buf[2];\n\n        FOREACH(it, q[0]) {\n            decode(*it, buf);\n            for(int j = 0; j < 2; ++j) {\n                const int blank = buf[j];\n                for(int dir = 0; dir < 4; ++dir) {\n                    if(NEIGHBOR[blank][dir] == -1) break;\n                    swap(field[blank], field[NEIGHBOR[blank][dir]]);\n                    long long code = encode();\n                    CacheType::const_iterator cit = cache.find(code);\n                    if(cit == cache.end()) {\n                        q[1].push_back(code);\n                        cache[code] = step;\n                    }\n                    swap(field[blank], field[NEIGHBOR[blank][dir]]);\n                }\n            }\n        }\n        sort(q[1].begin(), q[1].end());\n        q[1].erase(unique(q[1].begin(), q[1].end()), q[1].end());\n        q[0].swap(q[1]);\n        FOREACH(it, q[0]) {\n            callback(*it, step);\n        }\n    }\n}\n\nint main() {\n    cin.tie(0);\n    ios::sync_with_stdio(0);\n\n    while(true) {\n        for(int i = 0; i < 13; ++i) {\n            cin >> field[i];\n        }\n        if(field[0] == -1) break;\n\n        CacheType c1, c2;\n        NullCallback nc;\n        search(c1, nc);\n\n        for(int i = 1; i <= 11; ++i) {\n            field[i] = i;\n        }\n        field[0] = field[12] = 0;\n        AnsCallback ac(&c1);\n        search(c2, ac);\n        if(ac.ans > 20) cout << \"NA\" << endl;\n        else cout << ac.ans << endl;\n    }\n    return 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include<iostream>\n#include<vector>\n#include<map>\n#include<cstdio>\n#include<deque>\n#include<cmath>\n#include<algorithm>\n#define F first\n#define S second\n#define pb push_back\nusing namespace std;\ntypedef pair<int,int> P;\ntypedef pair<P,P> PP;\ntypedef vector<int> VI;\ntypedef vector<VI> VVI;\ntypedef vector<P> VP;\ntypedef pair<VVI,VP> VVIVP;\n\n\nmap<VVI,int> memo,bidirectional;\nVVI final;\nVP ini;\nint dx[4] = {0,1,0,-1};\nint dy[4] = {1,0,-1,0};\n\nP Fpos[] = {P(0,0),P(1,1),P(2,1),P(3,1),P(0,2),P(1,2),P(2,2),P(3,2),P(4,2),P(1,3),P(2,3),P(3,3)};\n\n\nclass Puzzle\n{\npublic:\n  VVI state;\n  int Manhattan;\n  VP vp;\n\n  Puzzle():Manhattan(0){}\n  Puzzle(VVI s)\n  {\n    vp.clear();\n    state = s;\n    Manhattan_calc(false);\n  }\n\n  void Manhattan_calc(bool b)\n  {\n    Manhattan = 0; \n    for(int i=0;i<5;i++)\n      for(int j=0;j<state[i].size();j++)\n\tif(state[i][j] != 0 && state[i][j] != -1)\n\t  Manhattan += abs(j-Fpos[state[i][j]].F) + abs(i-Fpos[state[i][j]].S);\n\telse if(state[i][j] == 0 && !b)// bがfalseなら初期化\n\t  vp.push_back(P(j,i)); \n  }\n\n  void print()\n  {\n  \n    for(int i=0;i<state.size();i++)\n      {\n\tfor(int j=0;j<state[i].size();j++)\n\t  {\n\t    if(state[i][j] == -1)\n\t      cout << \"  \";\n\t    else \n\t      cout << state[i][j] << \" \";\n\t  }\n\tcout << endl;\n      }\n    cout << endl;\n  }\n};\n\nbool Input(VVI& puzzle)\n{\n  puzzle.clear();\n  puzzle.resize(5);\n  puzzle[0].resize(3),puzzle[1].resize(4),puzzle[2].resize(5),puzzle[3].resize(4),puzzle[4].resize(3);\n  puzzle[0][0] = puzzle[0][1] = puzzle[1][0] = puzzle[3][0] = puzzle[4][0] = puzzle[4][1] = -1;\n \n  scanf(\"%d\",&puzzle[0][2]);\n  if(puzzle[0][2] == -1)\n    return false; \n  scanf(\"%d %d %d\",&puzzle[1][1],&puzzle[1][2],&puzzle[1][3]);\n  scanf(\"%d %d %d %d %d\",&puzzle[2][0],&puzzle[2][1],&puzzle[2][2],&puzzle[2][3],&puzzle[2][4]);\n  scanf(\"%d %d %d\",&puzzle[3][1],&puzzle[3][2],&puzzle[3][3]);\n  scanf(\"%d\",&puzzle[4][2]);\n\t    \n    return true;\n}\n\nvoid print(VVI vvi)\n{\n  cout << \"--- print ---\" << endl;\n  for(int i=0;i<vvi.size();i++)\n    {\n      for(int j=0;j<vvi[i].size();j++)\n\t{\n\t  cout << vvi[i][j] << \" \";\n\t}\n      cout << endl;\n    }\n  cout << endl;\n}\n\nVVI change(VVI vec,P p1,P p11)\n{\n  int tmp = vec[p1.S][p1.F];\n  vec[p1.S][p1.F] = vec[p11.S][p11.F];\n  vec[p11.S][p11.F] = tmp;\n\n  return vec;\n}\n\nvoid Init()\n{\n  final.resize(5);\n  final[0].pb(-1),final[0].pb(-1),final[0].pb(0);\n  final[1].pb(-1),final[1].pb(1),final[1].pb(2),final[1].pb(3);\n  final[2].pb(4),final[2].pb(5),final[2].pb(6),final[2].pb(7),final[2].pb(8);\n  final[3].pb(-1),final[3].pb(9),final[3].pb(10),final[3].pb(11);\n  final[4].pb(-1),final[4].pb(-1),final[4].pb(0);\n\n  Puzzle puz(final); \n  deque<Puzzle> deq;\n  deq.push_back(puz);\n  bidirectional[final] = 0;\n  \n  while(!deq.empty())\n    {\n      Puzzle p = deq.front(); deq.pop_front();\n      int cost = bidirectional[p.state];\n    \n      if(cost >= 4)\n\tcontinue;\n\n      for(int i=0;i<2;i++)\n\t{\n\t  for(int j=0;j<4;j++)\n\t    {\n\t      int nx = p.vp[i].F + dx[j];\n\t      int ny = p.vp[i].S + dy[j];\n\t      if(!(0<=ny && ny<p.state.size() && 0<=nx && nx<p.state[ny].size() && p.state[ny][nx] != -1))\n\t\tcontinue;\n\t      VVI next = change(p.state,p.vp[i],P(nx,ny));\n\t      map<VVI,int>::iterator it = bidirectional.find(next);\n\t      if(it == bidirectional.end() || (it != bidirectional.end() && bidirectional[next] > cost + 1))\n\t\t{\n\t\t  bidirectional[next] = cost + 1;\n\t\t  deq.push_back(Puzzle(next));\n\t\t}\n\n\t    }\n\n\t}      \n\n    }\n  \n  \n}\n\n\nint main()\n{\n  VVI puzzle;\n  Init();\n  //cout << \"here\" << endl;\n  while(Input(puzzle))\n    {\n \n      Puzzle puz(puzzle);\n      int men = (1<<28);\n      deque<Puzzle> deq;\n      deq.push_back(puz);\n      memo.clear();\n      memo[puzzle] = 0;\n\n      while(!deq.empty())\n\t{\n\t  Puzzle p = deq.front(); deq.pop_front();\n\t  int cost = memo[p.state];\n\t  //cout << \"cost : \" << cost << endl;\n\t  //p.print();\n\t  if(cost + p.Manhattan > min(20,men))\n\t    continue;\n\n\t  if(p.state == final)\n\t    {\n\t      men = min(men,cost);\n\t      continue;\n\t    }\n\t  else if(bidirectional.find(p.state) != bidirectional.end() && cost + bidirectional[p.state] <= 20)\n\t    {\n\t      men = min(men,cost+bidirectional[p.state]);\n\t      continue;\n\t    }\n       \n\t  for(int i=0;i<2;i++)\n\t    {\n\t      for(int j=0;j<4;j++)\n\t\t{\n  \n\t\t  int nx = p.vp[i].F + dx[j];\n\t\t  int ny = p.vp[i].S + dy[j];\n\t\t  if(!(0<=ny && ny<p.state.size() && 0<=nx && nx<p.state[ny].size() && p.state[ny][nx] != -1))\n\t\t    continue;\n\n\t\t  VVI next = change(p.state,p.vp[i],P(nx,ny));\n\t\t  map<VVI,int>::iterator it = memo.find(next);\n\t\t  if(it == memo.end() || (it != memo.end() &&  memo[next] > cost + 1) )\n\t\t    {\n\t\t      memo[next] = cost + 1;\n\t\t      deq.push_back(Puzzle(next));\n\t\t    }\n\n\t\t}\n\t    }\n\n\n\t}\n      if(men == (1<<28))\n\tcout << \"NA\" << endl;\n      else \n\tcout << men << endl;\n    }  \n\n    \n  return 0;\n}\n\n\n  /*  \n  deque<VVIVP> deq;\n  VP vec;\n  vec.push_back(P(0,0));\n  vec.push_back(P(0,4)); \n  deq.push_back(VVIVP(final,vec));\n  bidirectional[final] = 0;\n  while(!deq.empty())\n    {\n      VVIVP vvivp = deq.front(); deq.pop_front();\n      VVI vvi = vvivp.F;\n      VP vp = vvivp.S;\n      P p1,p2;\n      int cost = bidirectional[vvi];\n      if(cost >= 5)\n\tcontinue;\n      p1 = vp[0];\n      p2 = vp[1];\n      \n      for(int i=0;i<5;i++)\n\t{\n\t  int nx1 = p1.F + dx[i];\n\t  int ny1 = p1.S + dy[i];\n\n\t  if(!(0 <= ny1 && ny1 < vvi.size() && 0 <= nx1 && nx1 < vvi[ny1].size()))\n\t    continue;\n\n\t  for(int j=0;j<5;j++)\n\t    {\n\t      if(i == 4 && j == 4)\n\t\tcontinue;\n\t      int nx2 = p2.F + dx[j];\n\t      int ny2 = p2.S + dy[j];\n\n\t      if(!(0 <= ny2 && ny2 < vvi.size() && 0 <= nx2 && nx2 < vvi[ny2].size()))\n\t\tcontinue;\n\t      VVI new_vvi = change(vvi,p1,P(nx1,ny1),p2,P(nx2,ny2));\n\t      if(bidirectional.count(new_vvi) == 0 || (bidirectional.count(new_vvi) != 0 && bidirectional[new_vvi] > cost + 1))\n\t\t{\n\t\t  VP vip;\n\t\t  vip.push_back(P(nx1,ny1));\n\t\t  vip.push_back(P(nx2,ny2));\n\t\t  bidirectional[new_vvi] = cost+1;\n\t\t  deq.push_back(VVIVP(new_vvi,vip));\n\t\t}\n\n\t     \n\n\t    }\n\t}\n\n    }\n*/\n\n/*\n int men = (1<<28);\n      deque<VVIVP> deq;\n      bool fin = false;\n      deq.push_back(VVIVP(puzzle,ini));\n      memo[puzzle] = 0;\n      while(!deq.empty() && !fin)\n\t{\n\t  VVIVP vvivp = deq.front(); deq.pop_front();\n\t  VVI vvi = vvivp.F;\n\t  VP vp = vvivp.S;\n\t  P p1,p2;\n\t  p1 = vp[0], p2 = vp[1];\n\t \n\t  if((vvi == final || bidirectional.count(vvi) != 0) && memo[vvi] + bidirectional[vvi] <= min(20,men))\n\t    {\n\t      men = min(men,memo[vvi]+bidirectional[vvi]);\n\t      continue;\n\t    }\n\t  \n\t  int cost = memo[vvi];\n\n\t  if(men <= cost) \n\t    continue;\n\n\t  for(int i=0;i<5;i++)\n\t    {\n\t      int nx1 = p1.F + dx[i];\n\t      int ny1 = p1.S + dy[i];\n\n\t      if(!(0 <= ny1 && ny1 < vvi.size() && 0 <= nx1 && nx1 < vvi[ny1].size()))\n\t\tcontinue;\n\n\t      for(int j=0;j<5;j++)\n\t\t{\n\t\t  if(i = 4 && j == 4)\n\t\t    continue;\n\t\t  int nx2 = p2.F + dx[j];\n\t\t  int ny2 = p2.S + dy[j];\n\t\t  \n\t\t  if(!(0 <= ny2 && ny2 < vvi.size() && 0 <= nx2 && nx2 < vvi[ny2].size()))\n\t\t    continue;\n\n\t\t  //cout << \"change! \" << i << \" - \" << j << endl;\n\n\t\t  //cout <<\"cost = \" << cost << endl;\n\t\t   //print(change(vvi,p1,P(nx1,ny1),p2,P(nx2,ny2)));\n\t\t  VVI new_vvi = change(vvi,p1,P(nx1,ny1),p2,P(nx2,ny2));\n\t\t  if(memo.count(new_vvi) == 0 || (memo.count(new_vvi) != 0 && memo[new_vvi] > cost+1))\n\t\t    {\n\t\t \n\t\t      memo[new_vvi] = cost+1;\n\t\t      VP vip;\n\t\t      vip.push_back(P(nx1,ny1));\n\t\t      vip.push_back(P(nx2,ny2));\n\t\t      deq.push_back(VVIVP(new_vvi,vip));\n\t\t    }\n\n\n\t\t}\n\n\t    }\n\n\t}\n\n      if(men != (1<<28))\n\tcout << men << endl;\n      else \n\tcout << \"NA\" << endl;\n */\n\n\n/*\nwhile(Input(puzzle)){\n      int men = (1<<28);\n      deque<VVIVP> deq;\n      bool fin = false;\n      deq.push_back(VVIVP(puzzle,ini));\n      memo[puzzle] = 0;\n      while(!deq.empty())\n\t{\n\t  VVIVP vvivp = deq.front(); deq.pop_front();\n\t  VVI vvi = vvivp.F;\n\t  VP vp = vvivp.S;\n\t \n\t  if(vvi == final)\n\t    {\n\t      men = min(men,memo[vvi]);\n\t      fin = true;\n\t    }\n\t  else if(bidirectional.count(vvi) != 0 && memo[vvi] + bidirectional[vvi] <= 20)\n\t    {\n\t      fin = true;\n\t      men = min(men,memo[vvi]+bidirectional[vvi]);\n\t      break;\n\t    }\n\t \n\t  int cost = memo[vvi];\n\t  if(cost >= men)\n\t    continue;\n\n\t  //cout << \"cost = \" << cost << endl;\n\t  P p1,p2;\n\t  p1 = vp[0];\n\t  p2 = vp[1];\n\t  for(int k=0;k<5;k++)\n\t    {\n\t      int nx1,ny1;\n\t      nx1 = vp[0].F + dx[k];\n\t      ny1 = vp[0].S + dy[k];\n\t      if(!(0 <= ny1 && vvi.size() > ny1 && 0 <= nx1 && vvi[ny1].size() > nx1))\n\t\tcontinue;\n\n\t      for(int l=0;l<5;l++)\n\t\t{\n\t\t  int nx2,ny2;\n\t\n\t\t  nx2 = vp[1].F + dx[l];\n\t\t  ny2 = vp[1].S + dy[l];\n\n\t\t  if(!(0 <= ny2 && vvi.size() > ny2 && 0 <= nx2 && vvi[ny2].size() > nx2))\n\t\t    continue;\n\t\n\t\n\t\t  int tmp = vvi[p1.S][p1.F];\n\t\t  vvi[p1.S][p1.F] = vvi[ny1][nx1];\n\t\t  vvi[ny1][nx1] = tmp;\n\n\t\t  tmp = vvi[p2.S][p2.F];\n\t\t  vvi[p2.S][p2.F] = vvi[ny2][nx2];\n\t\t  vvi[ny2][nx2] = tmp;\n\t\n\n\t\t  if(cost+1 >= 20 && vvi != final)\n\t\t    continue;\n\n\t\t  if(cost+1 >= 20 && vvi == final)\n\t\t    {\n\t\t      fin = true;\n\t\t      printf(\"20\\n\");\n\t\t      break;\n\t\t    }\n\n\t\t  if((memo.count(vvi) != 0 && memo[vvi] > cost + 1) || memo.count(vvi) == 0)\n\t\t    {\n\t\t      VP vip;\n\t\t      vip.push_back(P(nx1,ny1));\n\t\t      vip.push_back(P(nx2,ny2));\n\t\t      memo[vvi] = cost + 1;\n\t\t      deq.push_back(VVIVP(vvi,vip)); \n\t\t    }\n\n\t\n\t\t  tmp = vvi[p1.S][p1.F];\n\t\t  vvi[p1.S][p1.F] = vvi[ny1][nx1];\n\t\t  vvi[ny1][nx1] = tmp;\n\n\t\t  tmp = vvi[p2.S][p2.F];\n\t\t  vvi[p2.S][p2.F] = vvi[ny2][nx2];\n\t\t  vvi[ny2][nx2] = tmp;\n\t\n\t\t}\n\t      if(fin)\n\t\tbreak;\n\t    }\n\t  if(fin)\n\t    break;\n\t}\n      if(!fin)\n\tprintf(\"NA\\n\");\n      else\n\tprintf(\"%d\\n\",men);\n    }\n\n */"
  },
  {
    "language": "C++",
    "code": "#include <iostream>\n#include <string>\n#include <vector>\n#include <queue>\n#include <map>\nusing namespace std;\n\nstring s = \"0123456789AB\";\nstring goal = \"0123456789AB0\";\n\nvector<vector<int>> adj = {\n    {2},\n    {2,5},\n    {0,1,3,6},\n    {2,7},\n    {5},\n    {1,4,6,9},\n    {2,5,7,10},\n    {3,6,8,11},\n    {7},\n    {5,10},\n    {6,9,11,12},\n    {7,10},\n    {10}\n};\n\nint solve(string stat) {\n    if (stat == goal) return 0;\n    map<string, int> dist;\n    dist[stat] = 0;\n    queue<string> q;\n    q.push(stat);\n    while ( ! q.empty()) {\n        string s = q.front();\n        q.pop();\n        for (int i=0; i<13; ++i) {\n            if (s[i] != '0') continue;\n            for (int j : adj[i]) {\n                string next = s;\n                next[i] = s[j];\n                next[j] = s[i];\n                int diff = 0;\n                for (int k=0; k<13; ++k) {\n                    diff += next[k] != goal[k];\n                }\n                if ( ! diff) {\n                    return dist[s] + 1;\n                }\n                if (dist.find(next) == dist.end()) {\n                    dist[next] = dist[s] + 1;\n                    if (dist[next] + diff <= 20) {\n                        q.push(next);\n                    }\n                }\n            }\n        }\n    }\n    return 21;\n}\n\nint main() {\n    while (1) {\n        string stat = \"\";\n        int k;\n        for (int i=0; i<13; ++i) {\n            if (cin >> k && !~k) return 0;\n            stat += s[k];\n        }\n        int ans = solve(stat);\n        if (ans <= 20) {\n            cout << ans << endl;\n            continue;\n        }\n        cout << \"NA\" << endl;\n    }\n    return 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include <queue>\n#include <vector>\n#include <iostream>\n#include <algorithm>\nusing namespace std;\nconst int lim = 20;\nconst vector<int> bx = { 0, 4, 1, 1, 1, 2, 2, 2, 2, 2, 3, 3, 3 };\nconst vector<int> by = { 2, 2, 1, 2, 3, 0, 1, 2, 3, 4, 1, 2, 3 };\nstruct state {\n\tvector<int> px, py;\n\tint cost, rem;\n};\nbool operator<(const state& s1, const state& s2) {\n\treturn s1.cost + s1.rem != s2.cost + s2.rem ? s1.cost + s1.rem > s2.cost + s2.rem : s1.rem > s2.rem;\n}\nint eval(vector<int> px, vector<int> py) {\n\tint ret = 0;\n\tfor (int i = 2; i < 13; ++i) {\n\t\tret += abs(px[i] - bx[i]) + abs(py[i] - by[i]);\n\t}\n\treturn ret;\n}\nint main() {\n\tint x;\n\twhile (cin >> x, x != -1) {\n\t\tvector<int> vx(13), vy(13);\n\t\tint zc = 0;\n\t\tvx[x == 0 ? zc : x + 1] = bx[0];\n\t\tvy[x == 0 ? zc : x + 1] = by[0];\n\t\tif (x == 0) ++zc;\n\t\tfor (int i = 1; i < 13; ++i) {\n\t\t\tcin >> x;\n\t\t\tvx[x == 0 ? zc : x + 1] = bx[i == 12 ? 1 : i + 1];\n\t\t\tvy[x == 0 ? zc : x + 1] = by[i == 12 ? 1 : i + 1];\n\t\t\tif (x == 0) ++zc;\n\t\t}\n\t\tpriority_queue<state> que;\n\t\tque.push(state{ vx, vy, 0, eval(vx, vy) });\n\t\tint ans = -1;\n\t\twhile (!que.empty()) {\n\t\t\tstate u = que.top();\n\t\t\tque.pop();\n\t\t\tif (u.rem == 0) {\n\t\t\t\tans = u.cost;\n\t\t\t\tbreak;\n\t\t\t}\n\t\t\tfor (int i = 0; i < 2; ++i) {\n\t\t\t\tfor (int j = 2; j < 13; ++j) {\n\t\t\t\t\tif (abs(u.px[i] - u.px[j]) + abs(u.py[i] - u.py[j]) == 1) {\n\t\t\t\t\t\tswap(u.px[i], u.px[j]);\n\t\t\t\t\t\tswap(u.py[i], u.py[j]);\n\t\t\t\t\t\tint ev = eval(u.px, u.py);\n\t\t\t\t\t\tif (u.cost + ev + 1 <= lim) {\n\t\t\t\t\t\t\tque.push(state{ u.px, u.py, u.cost + 1, eval(u.px, u.py) });\n\t\t\t\t\t\t}\n\t\t\t\t\t\tswap(u.px[i], u.px[j]);\n\t\t\t\t\t\tswap(u.py[i], u.py[j]);\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t\tcout << ans << '\\n';\n\t}\n\treturn 0;\n}\n"
  },
  {
    "language": "C++",
    "code": "#include<bits/stdc++.h>\nusing namespace std;\n   \ntypedef long long int64;\nconst int INF = 1 << 30;\n   \nvector< int > edge[13];\n  \nbool back(string str, int cnt){ //枝刈り大事だな\n  static int dist[] = { 0, 2, 1, 2, 4, 3, 2, 3, 4, 2, 1, 2, 0};\n  static int fuee[] = { 2, 0, 1, 2, 2, 1, 2, 3, 4, 2, 3, 4, 4};\n  static int fuga[] = { 1, 1, 0, 1, 3, 2, 1, 2, 3, 3, 2, 3, 3};\n  static int haaa[] = { 2, 2, 1, 0, 4, 3, 2, 1, 2, 4, 3, 2, 4};\n  static int kira[] = { 3, 3, 2, 3, 3, 2, 1, 2, 3, 1, 0, 1, 1};\n  \n  if(cnt > 20) return true;\n  int foo1 = 0, foo2 = 0, foo3 = 0, foo4 = 0, foo5 = 0;\n  for(int i = 0; i < 13; i++){\n    if(str[i] == '1') foo2 += fuee[i];\n    else if(str[i] == '2') foo3 += fuga[i];\n    else if(str[i] == '3') foo4 += haaa[i];\n    else if(str[i] == 'A') foo5 += kira[i];\n  }\n  return cnt + foo2 + foo3 + foo4 + foo5 > 20;\n}\n  \n  \nint bfs(string mas){\n  \n  queue< string > que;\n  map< string , int > memo;\n  que.push( mas );\n  memo[mas] = 0;\n  while(!que.empty()){\n  \n    string p = que.front(); que.pop();\n    if(back( p, memo[p])) continue;\n    if(p == \"0123456789AB0\") return memo[p];\n  \n    for(int i = 0; i < 13; i++){\n      if(p[i] == '0') {\n        for(int j = 0; j < edge[i].size(); j++){\n          string next = p;\n          swap( next[i], next[edge[i][j]]);\n          if(memo.find(next) != memo.end()) continue;\n          que.push( next );\n          memo[next] = memo[p] + 1;\n        }\n      }\n    }\n  }\n  return -1;\n}\n  \nint main(){\n  vector< int > mas(13);\n  \n  edge[0].push_back(2);\n  edge[1].push_back(2); edge[1].push_back(5);\n  edge[2].push_back(0); edge[2].push_back(1); edge[2].push_back(3); edge[2].push_back(6);\n  edge[3].push_back(2); edge[3].push_back(7);\n  edge[4].push_back(5);\n  edge[5].push_back(1); edge[5].push_back(4); edge[5].push_back(6); edge[5].push_back(9);\n  edge[6].push_back(2); edge[6].push_back(5); edge[6].push_back(7); edge[6].push_back(10);\n  edge[7].push_back(3); edge[7].push_back(6); edge[7].push_back(8); edge[7].push_back(11);\n  edge[8].push_back(7);\n  edge[9].push_back(5); edge[9].push_back(10);\n  edge[10].push_back(6); edge[10].push_back(9); edge[10].push_back(11); edge[10].push_back(12);\n  edge[11].push_back(7); edge[11].push_back(10);\n  edge[12].push_back(10);\n  \n  while(cin >> mas[0], mas[0] != -1){\n    for(int i = 1; i < 13; i++){\n      cin >> mas[i];\n    }\n  \n    string start = \"\";\n    for(int i = 0; i < 13; i++){\n      if(mas[i] >= 10) start += (char)(mas[i] - 10 + 'A');\n      else start += mas[i] + '0';\n    }\n    int ret = bfs(start);\n    if(~ret) cout << ret << endl;\n    else cout << \"NA\" << endl;\n  }\n}"
  },
  {
    "language": "C++",
    "code": "#include <iostream>\n#include <cstdio>\n#include <vector>\n#include <map>\n#include <string>\n#include <queue>\n#include <algorithm>\nusing namespace std;\n\nconst int INF = 1e+8;\nconst int f1[25] = {\n\t-1,-1, 0,-1,-1,\n\t-1, 1, 2, 3,-1,\n\t 4, 5, 6, 7, 8,\n\t-1, 9,10,11,-1,\n\t-1,-1,12,-1,-1,\n};\nconst int f2[13] = {2,6,7,8,10,11,12,13,14,16,17,18,22};\nconst int dx[4] = { 0,-1,+1, 0};\nconst int dy[4] = {-1, 0, 0,+1};\n\n// パズル\nstruct Pazzle{\n\tvector<char> v;\n\tPazzle(){v = vector<char>(13); }\n\tvoid at(int i, int p){\n\t\tv[i] = p;\n\t}\n\t// 空白の位置を返す. (k は 0 or 1)\n\tint search(int k){\n\t\tint a = 0;\n\t\tfor(int i=0 ; i < 13 ; i++ ){\n\t\t\tif( v[i] == 0 ){\n\t\t\t\tif( k == 0 ){\n\t\t\t\t\treturn i;\n\t\t\t\t}else{\n\t\t\t\t\tif( a == 0 ) a++;\n\t\t\t\t\telse return i;\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t\treturn -1;\n\t}\n\tint to_g(){\n\t\tint res = 0;\n\t\tint a = 0;\n\t\tfor(int i=0 ; i < 13 ; i++ ){\n\t\t\tint x1 = f2[v[i]] % 5;\n\t\t\tint y1 = f2[v[i]] / 5;\n\t\t\tint x2 = i % 5;\n\t\t\tint y2 = i / 5;\n\t\t\tif( v[i] == 0 ){\n\t\t\t\tif( a == 0 ){\n\t\t\t\t\ta++;\n\t\t\t\t}else{\n\t\t\t\t\tx1 = f2[12] % 5;\n\t\t\t\t\ty1 = f2[12] / 5;\n\t\t\t\t} \n\t\t\t}\n\t\t\tres += abs(x1-x2) + abs(y1-y2);\n\t\t}\n\t\treturn res;\n\t}\n\t// 空白 k (0 or 1) を 方向 dir に動かす.\n\t// 動かせる時は true, 動かせなかったときは false を返す.\n\tbool move(int dir, int k){\n\t\tif( dir < 0 || 4 <= dir || k < 0 || 2 <= k ) return false;\n\t\tint pos1 = search(k);\n\t\tint x = f2[pos1] % 5;\n\t\tint y = f2[pos1] / 5;\n\t\tint mx = x + dx[dir];\n\t\tint my = y + dy[dir];\n\t\tif( mx < 0 || my < 0 || 5 <= mx || 5 <= my ) return false;\n\t\tint pos2 = f1[my*5+mx];\n\t\tif( pos2 == -1 ) return false;\n\t\tif( v[pos1] == v[pos2] ) return false;\n\t\tswap( v[pos1] , v[pos2] );\n\t\treturn true;\n\t}\n\t// 完成しているかどうか\n\tbool is_goal(){\n\t\tfor(int i=0 ; i < 12 ; i++ ){\n\t\t\tif( v[i] != i ) return false;\n\t\t}\n\t\treturn v[12] == 0;\n\t}\n\tvoid debug(){\n\t\tprintf(\"[debug]\\n\");\n\t\tfor(int y=0 ; y < 5 ; y++ ){\n\t\t\tfor(int x=0 ; x < 5 ; x++ ){\n\t\t\t\tif( f1[y*5+x] == -1 ){\n\t\t\t\t\tprintf(\"##\");\n\t\t\t\t}else{\n\t\t\t\t\tprintf(\"%2d\", (int)v[f1[y*5+x]] );\n\t\t\t\t}\n\t\t\t}\n\t\t\tprintf(\"\\n\");\n\t\t}\n\t\tprintf(\"\\n\");\n\t}\n};\n\n// (コスト,スタートからの距離,パズルの状態)\nstruct State{\n\tPazzle p;\n\tint cost, cnt;\n\tState(int cost_, int cnt_, const Pazzle& p_){\n\t\tcost = cost_; cnt = cnt_; p = p_;\n\t}\n};\nbool operator<(const State& a, const State& b){\n\treturn a.cost > b.cost;\n}\n\nint solve(Pazzle p){\n\t// (コスト,スタートからの距離,パズルの状態) を優先度つきキューへ\n\tpriority_queue<State> q;\n\tq.push( State(p.to_g()/4,0,p) );\n\t\n\tint res = 21;\n\tint foo=0;\n\twhile( !q.empty() ){\n\t\tfoo++;\n\t\tPazzle p = q.top().p; \n\t\tint cost = q.top().cost;\n\t\tint cnt = q.top().cnt;\n\t\tq.pop();\n\t\t\n\t\tif( 40000 < foo ) break;\n\t\tif( res < cnt ) continue;\n\t\t\n\t\tif( p.is_goal() ){\n\t\t\tres = min( res , cnt );\n\t\t\tcontinue;\n\t\t}\n\t\t\n\t\tfor(int k=0 ; k <= 1 ; k++ ){\n\t\t\tfor(int i=0 ; i < 4 ; i++ ){\n\t\t\t\tPazzle p_ = p;\n\t\t\t\tif( p_.move(i,k) ){\n\t\t\t\t\tq.push( State(p_.to_g()/4+cnt+1,cnt+1,p_) );\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t}\n\treturn res;\n}\n\nint main(){\n\tint p1;\n\twhile( cin >> p1 , p1 != -1 ){\n\t\tPazzle p;\n\t\tp.at(0,p1);\n\t\tfor(int i=1 ; i < 13 ; i++ ){\n\t\t\tcin >> p1;\n\t\t\tp.at(i,p1);\n\t\t}\n\t\tint ans = solve(p);\n\t\tif( ans == 21 ){\n\t\t\tcout << \"NA\" << endl;\n\t\t}else{\n\t\t\tcout << ans << endl;\n\t\t}\n\t}\n}"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\n\nusing namespace std;\n\n#define FOR(i,a,b) for(int i=(a);i<(b);i++)\n#define REP(i,n) FOR(i,0,n)\n#define ALL(v) (v).begin(),(v).end()\n#define fi first\n#define se second\n\ntemplate<typename A, typename B> inline bool chmax(A &a, B b) { if (a<b) { a=b; return 1; } return 0; }\ntemplate<typename A, typename B> inline bool chmin(A &a, B b) { if (a>b) { a=b; return 1; } return 0; }\n\ntypedef long long ll;\ntypedef pair<int, int> pii;\ntypedef pair<ll, ll> pll;\ntypedef pair<int, pll> pip;\nconst ll INF = 1ll<<29;\nconst ll MOD = 1000000007;\nconst double EPS  = 1e-9;\n\nint dd[13][4] = {\n\t{2,-1,-1,-1},\n\t{2,5,-1,-1},\n\t{0,1,3,6},\n\t{2,7,-1,-1},\n\t{5,-1,-1,-1},\n\t{1,4,6,9},\n\t{2,5,7,10},\n\t{3,6,8,11},\n\t{7,-1,-1,-1},\n\t{5,10,-1,-1},\n\t{6,9,11,12},\n\t{7,10,-1,-1},\n\t{10,-1,-1,-1}\n};\n\nint main() {\n\tqueue<string> que;\n\tmap<string, int> d;\n\t\n\tque.push(\"abcdefghijkla\");\n\td[\"abcdefghijkla\"] = 0;\n\t\n\twhile (!que.empty()) {\n\t\tstring now = que.front(); que.pop();\n\t\tint cost = d[now];\n\t\t\n\t\tif (cost > 10) break;\n\t\t\n\t\tREP(i, 13) if (now[i] == 'a') {\n\t\t\tREP(j, 4) {\n\t\t\t\tif (dd[i][j] == -1) break;\n\t\t\t\t\n\t\t\t\tswap(now[i], now[dd[i][j]]);\n\t\t\t\tif (d.find(now) == d.end()) {\n\t\t\t\t\td[now] = cost + 1;\n\t\t\t\t\tque.push(now);\n\t\t\t}\n\t\t\t\tswap(now[i], now[dd[i][j]]);\n\t\t\t}\n\t\t}\n\t}\n\twhile (!que.empty()) que.pop();\n\n\tint p[13];\n\twhile (cin >> p[0], ~p[0]) {\n\t\tFOR(i, 1, 13) cin >> p[i];\n\t\tstring st = \"\";\n\t\tREP(i, 13) st += p[i] + 'a';\n\t\t\n\t\tmap<string, int> d2;\n\t\tque.push(st);\n\t\td2[st] = 0;\n\t\t\n\t\tint ans = INF;\n\t\t\n\t\twhile (!que.empty()) {\n\t\t\tstring now = que.front(); que.pop();\n\t\t\tint cost = d2[now];\n\t\t\t\n\t\t\tif (cost > 11) break;\n\t\t\tif (d.find(now) != d.end()) {\n\t\t\t\tans = d[now] + d2[now];\n\t\t\t\tbreak;\n\t\t\t}\n\t\t\t\n\t\t\tREP(i, 13) if (now[i] == 'a') {\n\t\t\t\tREP(j, 4) {\n\t\t\t\t\tif (dd[i][j] == -1) break;\n\t\t\t\t\t\n\t\t\t\t\tswap(now[i], now[dd[i][j]]);\n\t\t\t\t\tif (d2.find(now) == d2.end()) {\n\t\t\t\t\t\td2[now] = cost + 1;\n\t\t\t\t\t\tque.push(now);\n\t\t\t\t}\n\t\t\t\t\tswap(now[i], now[dd[i][j]]);\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t\twhile (!que.empty()) que.pop();\n\t\t\n\t\tif (ans != INF) cout << ans << endl;\n\t\telse puts(\"NA\");\n\t}\n\treturn 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\nusing namespace std;\n\nint fie[5][5];\nint o_fie[5][5]={\n    -1,-1,0,-1,-1,\n    -1,1,2,3,-1,\n    4,5,6,7,8,\n    -1,9,10,11,-1\n    -1,-1,0,-1,-1,\n};\n\nint ox[12],oy[12],zx[2],zy[2],zcnt;\nint res;\nbool flag;\n\nint dx[4]={1,0,-1,0};\nint dy[4]={0,1,0,-1};\n\nvoid dfs(int v,int dist,int pd,int pu){\n    if(dist==0){\n        flag=true;\n        res=min(res,v);\n        return;\n    }\n    for(int i=0;i<4;i++){\n        for(int j=0;j<2;j++){\n            if(pu==j && (pd+2)%4==i)continue;\n            int nx=zx[j]+dx[i],ny=zy[j]+dy[i];\n            if(nx>=0 && nx<5 && ny>=0 && ny<5){\n                if(fie[nx][ny]<=0)continue;\n                int ch=fie[nx][ny];\n                int ndist=dist;\n                ndist-=abs(ox[ch]-nx)+abs(oy[ch]-ny);\n                swap(fie[nx][ny],fie[zx[j]][zy[j]]);\n                ndist+=abs(ox[ch]-zx[j])+abs(oy[ch]-zy[j]);\n                zx[j]+=dx[i];\n                zy[j]+=dy[i];\n                if(v+1+ndist<=res)dfs(v+1,ndist,i,j);\n                zx[j]-=dx[i];\n                zy[j]-=dy[i];\n                swap(fie[nx][ny],fie[zx[j]][zy[j]]);\n            }\n        }\n    }\n}\nint dist;\n\nint main(void){\n    for(int i=0;i<5;i++){\n        for(int j=abs(2-i);j<=4-abs(2-i);j++){\n            ox[o_fie[i][j]]=j;\n            oy[o_fie[i][j]]=i;\n        }\n    }\n    while(1){\n        memset(fie,-1,sizeof(fie));\n        dist=0;\n        zcnt=0;\n        for(int i=0;i<5;i++){\n            for(int j=abs(2-i);j<=4-abs(2-i);j++){\n                scanf(\"%d\",&fie[j][i]);\n                if(fie[j][i]==-1)return 0;\n            }\n        }\n        for(int i=0;i<5;i++){\n            for(int j=abs(2-i);j<=4-abs(2-i);j++){\n                int v=fie[j][i];\n                if(v==0){\n                    zx[zcnt]=j;\n                    zy[zcnt++]=i;\n                }else dist+=abs(ox[v]-j)+abs(oy[v]-i);\n            }\n        }\n        if(dist>20){\n            printf(\"NA\\n\");\n        }else{\n            int i=0;\n            flag=false;\n            res=20;\n            dfs(0,dist,-1,-1);\n            if(flag){\n                printf(\"%d\\n\",res);\n            }\n            if(!flag)printf(\"NA\\n\");\n        }\n    }\n    return 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include <iostream>\n#include <cstdio>\n#include <cstring>\n#include <cstdlib>\n#include <cmath>\n#include <vector>\n#include <string>\n#include <map>\n#include <set>\n#include <queue>\n#include <stack>\n#include <algorithm>\n\nusing namespace std;\n\n#define rep(i,j) REP((i), 0, (j))\n#define REP(i,j,k) for(int i=(j);(i)<(k);++i)\n#define BW(a,x,b) ((a)<=(x)&&(x)<=(b))\n#define F first\n#define S second\n#define INF 1 << 30\n\ntypedef pair<int, int> pi;\ntypedef pair<int, pi> pii;\ntypedef vector<int> vi;\ntypedef queue<int> qi;\ntypedef long long ll;\n\nvi p, next, now;\nvector<vector<int> >dir(13);\n\nint main(){\n  rep(i, 13) if(i == 0 || i == 12) p.push_back(0); else p.push_back(i);\n\n  dir[0].push_back(2);\n  dir[1].push_back(2); dir[1].push_back(5);\n  dir[2].push_back(0); dir[2].push_back(1); dir[2].push_back(3); dir[2].push_back(6);\n  dir[3].push_back(2); dir[3].push_back(7);\n  dir[4].push_back(5);\n  dir[5].push_back(1); dir[5].push_back(4); dir[5].push_back(6); dir[5].push_back(9);\n  dir[6].push_back(2); dir[6].push_back(5); dir[6].push_back(7); dir[6].push_back(10);\n  dir[7].push_back(3); dir[7].push_back(6); dir[7].push_back(8); dir[7].push_back(11);\n  dir[8].push_back(7);\n  dir[9].push_back(5); dir[9].push_back(10);\n  dir[10].push_back(6); dir[10].push_back(9); dir[10].push_back(11); dir[10].push_back(13);\n  dir[11].push_back(7); dir[11].push_back(10);\n  dir[12].push_back(10);\n\n  map<vi, int>m;\n  queue<vi>q;\n  q.push(p);\n  m[p] = 0;\n  rep(i, 10){\n    int qsize = q.size();\n    rep(j, qsize){\n      now = q.front(); q.pop();\n      rep(k, 13){\n\tif(now[k] != 0) continue;\n\trep(d, dir[k].size()){\n\t  next = now;\n\t  swap(next[k], next[dir[k][d]]);\n\t  if(m.count(next) != 0) continue;\n\t  m[next] = i+1;\n\t  q.push(next);\n\t}\n      }\n    }\n  }\n\n  p.resize(13);\n  while(scanf(\"%d\", &p[0]) && p[0] != -1){\n    REP(i, 1, 13) scanf(\"%d\", &p[i]);\n\n    map<vi, int>dist;\n    queue<vi>q;\n    q.push(p);\n    dist[p] = 0;\n    if(m.count(p) != 0){\n      printf(\"%d\\n\", m[p]);\n      goto e;\n    }\n\n    rep(i, 10){\n      int qsize = q.size();\n      rep(j, qsize){\n\tnow = q.front(); q.pop();\n\trep(k, 13){\n\t  if(now[k] != 0) continue;\n\t  rep(d, dir[k].size()){\n\t    next = now;\n\t    swap(next[k], next[dir[k][d]]);\n\t    if(m.count(next) != 0){\n\t      printf(\"%d\\n\", m[next]+i+1);\n\t      goto e;\n\t    }\n\t    if(dist.count(next) != 0) continue;\n\t    dist[next] = i+1;\n\t    q.push(next);\n\t  }\n\t}\n      }\n    }\n    puts(\"NA\");\n  e:;\n  }\n  return 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include <iostream>\n#include <string>\n#include <vector>\n#include <queue>\n#include <map>\nusing namespace std;\n\nstring s = \"0123456789AB\";\nstring goal = \"0123456789AB0\";\n\nvector<vector<int>> adj = {\n    {2},\n    {2,5},\n    {0,1,3,6},\n    {2,7},\n    {5},\n    {1,4,6,9},\n    {2,5,7,10},\n    {3,6,8,11},\n    {7},\n    {5,10},\n    {6,9,11,12},\n    {7,10},\n    {10}\n};\n\nint solve(string stat) {\n    map<string, int> dist;\n    dist[stat] = 0;\n    queue<string> q;\n    q.push(stat);\n    while ( ! q.empty()) {\n        string s = q.front();\n        q.pop();\n        int diff = 0;\n        for (int i=0; i<13; ++i) {\n            diff += s[i] != goal[i];\n        }\n        if ( ! diff) {\n            return dist[s];\n        } else if (20 < dist[s] + diff) {\n            continue;\n        }\n        for (int i=0; i<13; ++i) {\n            if (s[i] != '0') continue;\n            for (int j : adj[i]) {\n                string next = s;\n                next[i] = s[j];\n                next[j] = s[i];\n                if (dist.find(next) == dist.end()) {\n                    q.push(next);\n                    dist[next] = dist[s] + 1;\n                }\n            }\n        }\n    }\n    return 21;\n}\n\nint main() {\n    while (1) {\n        string stat = \"\";\n        int k;\n        for (int i=0; i<13; ++i) {\n            if (cin >> k && !~k) return 0;\n            stat += s[k];\n        }\n        int ans = solve(stat);\n        if (ans <= 20) {\n            cout << ans << endl;\n            continue;\n        }\n        cout << \"NA\" << endl;\n    }\n    return 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include<iostream>\n#include<vector>\n#include<map>\n#include<cstdio>\n#include<deque>\n#include<cmath>\n#include<algorithm>\n#define F first\n#define S second\n#define pb push_back\nusing namespace std;\ntypedef pair<int,int> P;\ntypedef pair<P,P> PP;\ntypedef vector<int> VI;\ntypedef vector<VI> VVI;\ntypedef vector<P> VP;\ntypedef pair<VVI,VP> VVIVP;\n\n\nmap<VVI,int> memo,bidirectional;\nVVI final;\nVP ini;\nint dx[4] = {0,1,0,-1};\nint dy[4] = {1,0,-1,0};\n\nP Fpos[] = {P(0,0),P(1,1),P(2,1),P(3,1),P(0,2),P(1,2),P(2,2),P(3,2),P(4,2),P(1,3),P(2,3),P(3,3)};\n\n\nclass Puzzle\n{\npublic:\n  VVI state;\n  int Manhattan;\n  VP vp;\n\n  Puzzle():Manhattan(0){}\n  Puzzle(VVI s)\n  {\n    vp.clear();\n    state = s;\n    Manhattan_calc(false);\n  }\n\n  void Manhattan_calc(bool b)\n  {\n    Manhattan = 0; \n    for(int i=0;i<5;i++)\n      for(int j=0;j<state[i].size();j++)\n\tif(state[i][j] != 0 && state[i][j] != -1)\n\t  Manhattan += abs(j-Fpos[state[i][j]].F) + abs(i-Fpos[state[i][j]].S);\n\telse if(state[i][j] == 0 && !b)// bがfalseなら初期化\n\t  vp.push_back(P(j,i)); \n  }\n\n  void print()\n  {\n  \n    for(int i=0;i<state.size();i++)\n      {\n\tfor(int j=0;j<state[i].size();j++)\n\t  {\n\t    if(state[i][j] == -1)\n\t      cout << \"  \";\n\t    else \n\t      cout << state[i][j] << \" \";\n\t  }\n\tcout << endl;\n      }\n    cout << endl;\n  }\n};\n\nbool Input(VVI& puzzle)\n{\n  puzzle.clear();\n  puzzle.resize(5);\n  puzzle[0].resize(3),puzzle[1].resize(4),puzzle[2].resize(5),puzzle[3].resize(4),puzzle[4].resize(3);\n  puzzle[0][0] = puzzle[0][1] = puzzle[1][0] = puzzle[3][0] = puzzle[4][0] = puzzle[4][1] = -1;\n \n  scanf(\"%d\",&puzzle[0][2]);\n  if(puzzle[0][2] == -1)\n    return false; \n  scanf(\"%d %d %d\",&puzzle[1][1],&puzzle[1][2],&puzzle[1][3]);\n  scanf(\"%d %d %d %d %d\",&puzzle[2][0],&puzzle[2][1],&puzzle[2][2],&puzzle[2][3],&puzzle[2][4]);\n  scanf(\"%d %d %d\",&puzzle[3][1],&puzzle[3][2],&puzzle[3][3]);\n  scanf(\"%d\",&puzzle[4][2]);\n\t    \n    return true;\n}\n\nvoid print(VVI vvi)\n{\n  cout << \"--- print ---\" << endl;\n  for(int i=0;i<vvi.size();i++)\n    {\n      for(int j=0;j<vvi[i].size();j++)\n\t{\n\t  cout << vvi[i][j] << \" \";\n\t}\n      cout << endl;\n    }\n  cout << endl;\n}\n\nVVI change(VVI vec,P p1,P p11)\n{\n  int tmp = vec[p1.S][p1.F];\n  vec[p1.S][p1.F] = vec[p11.S][p11.F];\n  vec[p11.S][p11.F] = tmp;\n\n  return vec;\n}\n\nvoid Init()\n{\n  final.resize(5);\n  final[0].pb(-1),final[0].pb(-1),final[0].pb(0);\n  final[1].pb(-1),final[1].pb(1),final[1].pb(2),final[1].pb(3);\n  final[2].pb(4),final[2].pb(5),final[2].pb(6),final[2].pb(7),final[2].pb(8);\n  final[3].pb(-1),final[3].pb(9),final[3].pb(10),final[3].pb(11);\n  final[4].pb(-1),final[4].pb(-1),final[4].pb(0);\n\n  Puzzle puz(final); \n  deque<Puzzle> deq;\n  deq.push_back(puz);\n  bidirectional[final] = 0;\n  \n  while(!deq.empty())\n    {\n      Puzzle p = deq.front(); deq.pop_front();\n      int cost = bidirectional[p.state];\n    \n      if(cost >= 5)\n\tcontinue;\n\n      for(int i=0;i<2;i++)\n\t{\n\t  for(int j=0;j<4;j++)\n\t    {\n\t      int nx = p.vp[i].F + dx[j];\n\t      int ny = p.vp[i].S + dy[j];\n\t      if(!(0<=ny && ny<p.state.size() && 0<=nx && nx<p.state[ny].size() && p.state[ny][nx] != -1))\n\t\tcontinue;\n\t      VVI next = change(p.state,p.vp[i],P(nx,ny));\n\t      map<VVI,int>::iterator it = bidirectional.find(next);\n\t      if(it == bidirectional.end() || (it != bidirectional.end() && bidirectional[next] > cost + 1))\n\t\t{\n\t\t  bidirectional[next] = cost + 1;\n\t\t  deq.push_back(Puzzle(next));\n\t\t}\n\n\t    }\n\n\t}      \n\n    }\n  \n  \n}\n\n\nint main()\n{\n  VVI puzzle;\n  Init();\n  //cout << \"here\" << endl;\n  while(Input(puzzle))\n    {\n \n      Puzzle puz(puzzle);\n      int men = (1<<28);\n      deque<Puzzle> deq;\n      deq.push_back(puz);\n      memo.clear();\n      memo[puzzle] = 0;\n\n      while(!deq.empty())\n\t{\n\t  Puzzle p = deq.front(); deq.pop_front();\n\t  int cost = memo[p.state];\n\t  //cout << \"cost : \" << cost << endl;\n\t  //p.print();\n\t  if(cost + p.Manhattan > min(20,men))\n\t    continue;\n\n\t  if(p.state == final)\n\t    {\n\t      men = min(men,cost);\n\t      continue;\n\t    }\n\t  else if(bidirectional.find(p.state) != bidirectional.end() && cost + bidirectional[p.state] <= 20)\n\t    {\n\t      men = min(men,cost+bidirectional[p.state]);\n\t      continue;\n\t    }\n       \n\t  for(int i=0;i<2;i++)\n\t    {\n\t      for(int j=0;j<4;j++)\n\t\t{\n  \n\t\t  int nx = p.vp[i].F + dx[j];\n\t\t  int ny = p.vp[i].S + dy[j];\n\t\t  if(!(0<=ny && ny<p.state.size() && 0<=nx && nx<p.state[ny].size() && p.state[ny][nx] != -1))\n\t\t    continue;\n\n\t\t  VVI next = change(p.state,p.vp[i],P(nx,ny));\n\t\t  map<VVI,int>::iterator it = memo.find(next);\n\t\t  if(it == memo.end() || (it != memo.end() &&  memo[next] > cost + 1) )\n\t\t    {\n\t\t      memo[next] = cost + 1;\n\t\t      deq.push_back(Puzzle(next));\n\t\t    }\n\n\t\t}\n\t    }\n\n\n\t}\n      if(men == (1<<28))\n\tcout << \"NA\" << endl;\n      else \n\tcout << men << endl;\n    }  \n\n    \n  return 0;\n}\n\n\n  /*  \n  deque<VVIVP> deq;\n  VP vec;\n  vec.push_back(P(0,0));\n  vec.push_back(P(0,4)); \n  deq.push_back(VVIVP(final,vec));\n  bidirectional[final] = 0;\n  while(!deq.empty())\n    {\n      VVIVP vvivp = deq.front(); deq.pop_front();\n      VVI vvi = vvivp.F;\n      VP vp = vvivp.S;\n      P p1,p2;\n      int cost = bidirectional[vvi];\n      if(cost >= 5)\n\tcontinue;\n      p1 = vp[0];\n      p2 = vp[1];\n      \n      for(int i=0;i<5;i++)\n\t{\n\t  int nx1 = p1.F + dx[i];\n\t  int ny1 = p1.S + dy[i];\n\n\t  if(!(0 <= ny1 && ny1 < vvi.size() && 0 <= nx1 && nx1 < vvi[ny1].size()))\n\t    continue;\n\n\t  for(int j=0;j<5;j++)\n\t    {\n\t      if(i == 4 && j == 4)\n\t\tcontinue;\n\t      int nx2 = p2.F + dx[j];\n\t      int ny2 = p2.S + dy[j];\n\n\t      if(!(0 <= ny2 && ny2 < vvi.size() && 0 <= nx2 && nx2 < vvi[ny2].size()))\n\t\tcontinue;\n\t      VVI new_vvi = change(vvi,p1,P(nx1,ny1),p2,P(nx2,ny2));\n\t      if(bidirectional.count(new_vvi) == 0 || (bidirectional.count(new_vvi) != 0 && bidirectional[new_vvi] > cost + 1))\n\t\t{\n\t\t  VP vip;\n\t\t  vip.push_back(P(nx1,ny1));\n\t\t  vip.push_back(P(nx2,ny2));\n\t\t  bidirectional[new_vvi] = cost+1;\n\t\t  deq.push_back(VVIVP(new_vvi,vip));\n\t\t}\n\n\t     \n\n\t    }\n\t}\n\n    }\n*/\n\n/*\n int men = (1<<28);\n      deque<VVIVP> deq;\n      bool fin = false;\n      deq.push_back(VVIVP(puzzle,ini));\n      memo[puzzle] = 0;\n      while(!deq.empty() && !fin)\n\t{\n\t  VVIVP vvivp = deq.front(); deq.pop_front();\n\t  VVI vvi = vvivp.F;\n\t  VP vp = vvivp.S;\n\t  P p1,p2;\n\t  p1 = vp[0], p2 = vp[1];\n\t \n\t  if((vvi == final || bidirectional.count(vvi) != 0) && memo[vvi] + bidirectional[vvi] <= min(20,men))\n\t    {\n\t      men = min(men,memo[vvi]+bidirectional[vvi]);\n\t      continue;\n\t    }\n\t  \n\t  int cost = memo[vvi];\n\n\t  if(men <= cost) \n\t    continue;\n\n\t  for(int i=0;i<5;i++)\n\t    {\n\t      int nx1 = p1.F + dx[i];\n\t      int ny1 = p1.S + dy[i];\n\n\t      if(!(0 <= ny1 && ny1 < vvi.size() && 0 <= nx1 && nx1 < vvi[ny1].size()))\n\t\tcontinue;\n\n\t      for(int j=0;j<5;j++)\n\t\t{\n\t\t  if(i = 4 && j == 4)\n\t\t    continue;\n\t\t  int nx2 = p2.F + dx[j];\n\t\t  int ny2 = p2.S + dy[j];\n\t\t  \n\t\t  if(!(0 <= ny2 && ny2 < vvi.size() && 0 <= nx2 && nx2 < vvi[ny2].size()))\n\t\t    continue;\n\n\t\t  //cout << \"change! \" << i << \" - \" << j << endl;\n\n\t\t  //cout <<\"cost = \" << cost << endl;\n\t\t   //print(change(vvi,p1,P(nx1,ny1),p2,P(nx2,ny2)));\n\t\t  VVI new_vvi = change(vvi,p1,P(nx1,ny1),p2,P(nx2,ny2));\n\t\t  if(memo.count(new_vvi) == 0 || (memo.count(new_vvi) != 0 && memo[new_vvi] > cost+1))\n\t\t    {\n\t\t \n\t\t      memo[new_vvi] = cost+1;\n\t\t      VP vip;\n\t\t      vip.push_back(P(nx1,ny1));\n\t\t      vip.push_back(P(nx2,ny2));\n\t\t      deq.push_back(VVIVP(new_vvi,vip));\n\t\t    }\n\n\n\t\t}\n\n\t    }\n\n\t}\n\n      if(men != (1<<28))\n\tcout << men << endl;\n      else \n\tcout << \"NA\" << endl;\n */\n\n\n/*\nwhile(Input(puzzle)){\n      int men = (1<<28);\n      deque<VVIVP> deq;\n      bool fin = false;\n      deq.push_back(VVIVP(puzzle,ini));\n      memo[puzzle] = 0;\n      while(!deq.empty())\n\t{\n\t  VVIVP vvivp = deq.front(); deq.pop_front();\n\t  VVI vvi = vvivp.F;\n\t  VP vp = vvivp.S;\n\t \n\t  if(vvi == final)\n\t    {\n\t      men = min(men,memo[vvi]);\n\t      fin = true;\n\t    }\n\t  else if(bidirectional.count(vvi) != 0 && memo[vvi] + bidirectional[vvi] <= 20)\n\t    {\n\t      fin = true;\n\t      men = min(men,memo[vvi]+bidirectional[vvi]);\n\t      break;\n\t    }\n\t \n\t  int cost = memo[vvi];\n\t  if(cost >= men)\n\t    continue;\n\n\t  //cout << \"cost = \" << cost << endl;\n\t  P p1,p2;\n\t  p1 = vp[0];\n\t  p2 = vp[1];\n\t  for(int k=0;k<5;k++)\n\t    {\n\t      int nx1,ny1;\n\t      nx1 = vp[0].F + dx[k];\n\t      ny1 = vp[0].S + dy[k];\n\t      if(!(0 <= ny1 && vvi.size() > ny1 && 0 <= nx1 && vvi[ny1].size() > nx1))\n\t\tcontinue;\n\n\t      for(int l=0;l<5;l++)\n\t\t{\n\t\t  int nx2,ny2;\n\t\n\t\t  nx2 = vp[1].F + dx[l];\n\t\t  ny2 = vp[1].S + dy[l];\n\n\t\t  if(!(0 <= ny2 && vvi.size() > ny2 && 0 <= nx2 && vvi[ny2].size() > nx2))\n\t\t    continue;\n\t\n\t\n\t\t  int tmp = vvi[p1.S][p1.F];\n\t\t  vvi[p1.S][p1.F] = vvi[ny1][nx1];\n\t\t  vvi[ny1][nx1] = tmp;\n\n\t\t  tmp = vvi[p2.S][p2.F];\n\t\t  vvi[p2.S][p2.F] = vvi[ny2][nx2];\n\t\t  vvi[ny2][nx2] = tmp;\n\t\n\n\t\t  if(cost+1 >= 20 && vvi != final)\n\t\t    continue;\n\n\t\t  if(cost+1 >= 20 && vvi == final)\n\t\t    {\n\t\t      fin = true;\n\t\t      printf(\"20\\n\");\n\t\t      break;\n\t\t    }\n\n\t\t  if((memo.count(vvi) != 0 && memo[vvi] > cost + 1) || memo.count(vvi) == 0)\n\t\t    {\n\t\t      VP vip;\n\t\t      vip.push_back(P(nx1,ny1));\n\t\t      vip.push_back(P(nx2,ny2));\n\t\t      memo[vvi] = cost + 1;\n\t\t      deq.push_back(VVIVP(vvi,vip)); \n\t\t    }\n\n\t\n\t\t  tmp = vvi[p1.S][p1.F];\n\t\t  vvi[p1.S][p1.F] = vvi[ny1][nx1];\n\t\t  vvi[ny1][nx1] = tmp;\n\n\t\t  tmp = vvi[p2.S][p2.F];\n\t\t  vvi[p2.S][p2.F] = vvi[ny2][nx2];\n\t\t  vvi[ny2][nx2] = tmp;\n\t\n\t\t}\n\t      if(fin)\n\t\tbreak;\n\t    }\n\t  if(fin)\n\t    break;\n\t}\n      if(!fin)\n\tprintf(\"NA\\n\");\n      else\n\tprintf(\"%d\\n\",men);\n    }\n\n */"
  },
  {
    "language": "C++",
    "code": "#import<iostream>\n#import<map>\n#import<queue>\n#import<cstdlib>\n#import<cstring>\nusing namespace std;struct B{int z[2];char s[14];bool operator<(const B&r)const{return strcmp(s,r.s)<0;}};main(){int a[13][5]={{2,-1},{2,5,-1},{0,1,3,6,-1},{2,7,-1},{5,-1},{1,4,6,9,-1},{2,5,7,10,-1},{3,6,8,11,-1},{7,-1},{5,10,-1},{6,9,11,12,-1},{7,10,-1},{10,-1},},gx[]={2,1,2,3,0,1,2,3,4,1,2,3,2},gy[]={0,1,1,1,2,2,2,2,2,3,3,3,4},v,d,s,i,j;B g={0,0,\"0123456789:;0\"};for(;;){map<B,int>m;queue<B>q;B b={-1,-1};for(i=0;i<13;i++){cin>>v;if(v<0)return 0;b.s[i]=48+v;if(!v)b.z[b.z[0]!=-1]=i;}b.s[13]=0;m[b]=1;for(q.push(b);!q.empty();q.pop()){B&b=q.front();if(!strcmp(b.s,g.s))break;d=0;for(i=13;i--;){v=b.s[i]-48;if(v)d+=abs(gx[v]-gx[i])+abs(gy[v]-gy[i]);}s=m[b];if(s+d<22)for(j=2;j--;)for(i=0;~a[b.z[j]][i];i++){B n=b;n.z[j]=a[b.z[j]][i];if(n.z[j]-n.z[1-j]){swap(n.s[b.z[j]],n.s[n.z[j]]);int&b=m[n];if(!b)b=s+1,q.push(n);}}}printf(m[g]?\"%d\\n\":\"NA\\n\",m[g]-1);}}"
  },
  {
    "language": "C++",
    "code": "#include<bits/stdc++.h>\nusing namespace std;\n   \ntypedef long long int64;\nconst int INF = 1 << 30;\n   \nvector< int > edge[13];\n  \nbool back(string str, int cnt){ //枝刈り大事だな\n  int X[]={ 2, 1, 2, 3, 0, 1, 2, 3, 4, 1, 2, 3, 2};\n  int Y[]={ 0, 1, 1, 1, 2, 2, 2, 2, 2, 3, 3, 3, 4};\n \n  int diff = 0;\n  for(int i = 0; i < 13; i++){\n    if(str[i] != '0'){\n      int pos = (str[i] >= 'A' ? str[i] - 'A' + 10 : str[i] - '0');\n      diff += abs( X[pos] - X[i]) + abs( Y[pos] - Y[i]);\n    }\n  }\n  return diff + cnt > 20;\n}\n  \n  \nint bfs(string mas){\n  \n  queue< string > que;\n  map< string , int > memo;\n  que.push( mas );\n  memo[mas] = 0;\n  while(!que.empty()){\n  \n    string p = que.front(); que.pop();\n    if(back( p, memo[p])) continue;\n    if(p == \"0123456789AB0\") return memo[p];\n  \n    for(int i = 0; i < 13; i++){\n      if(p[i] == '0') {\n        for(int j = 0; j < edge[i].size(); j++){\n          string next = p;\n          swap( next[i], next[edge[i][j]]);\n          if(memo.find(next) != memo.end()) continue;\n          que.push( next );\n          memo[next] = memo[p] + 1;\n        }\n      }\n    }\n  }\n  return -1;\n}\n  \nint main(){\n  vector< int > mas(13);\n  \n  edge[0].push_back(2);\n  edge[1].push_back(2); edge[1].push_back(5);\n  edge[2].push_back(0); edge[2].push_back(1); edge[2].push_back(3); edge[2].push_back(6);\n  edge[3].push_back(2); edge[3].push_back(7);\n  edge[4].push_back(5);\n  edge[5].push_back(1); edge[5].push_back(4); edge[5].push_back(6); edge[5].push_back(9);\n  edge[6].push_back(2); edge[6].push_back(5); edge[6].push_back(7); edge[6].push_back(10);\n  edge[7].push_back(3); edge[7].push_back(6); edge[7].push_back(8); edge[7].push_back(11);\n  edge[8].push_back(7);\n  edge[9].push_back(5); edge[9].push_back(10);\n  edge[10].push_back(6); edge[10].push_back(9); edge[10].push_back(11); edge[10].push_back(12);\n  edge[11].push_back(7); edge[11].push_back(10);\n  edge[12].push_back(10);\n  \n  while(cin >> mas[0], mas[0] != -1){\n    for(int i = 1; i < 13; i++){\n      cin >> mas[i];\n    }\n  \n    string start = \"\";\n    for(int i = 0; i < 13; i++){\n      if(mas[i] >= 10) start += (char)(mas[i] - 10 + 'A');\n      else start += mas[i] + '0';\n    }\n    int ret = bfs(start);\n    if(~ret) cout << ret << endl;\n    else cout << \"NA\" << endl;\n  }\n}"
  },
  {
    "language": "C++",
    "code": "#include<stdio.h>\n#include<map>\n#include<queue>\ntypedef long long L;\nL S(L l,int a,int b)\n{\n\tL c=(l>>(a*4))&15;\n\tl&=~(15LL<<(a*4));\n\tL d=(l>>(b*4))&15;\n\tl&=~(15LL<<(b*4));\n\treturn l|(c<<(b*4))|(d<<(a*4));\n}\nint main()\n{\n\tconst int di[13][4]={\n\t\t{3},\n\t\t{3,6},\n\t\t{1,2,4,7},\n\t\t{3,8},\n\t\t{6},\n\t\t{2,5,7,10},\n\t\t{3,6,8,11},\n\t\t{4,7,9,12},\n\t\t{8},\n\t\t{6,11},\n\t\t{7,10,12,13},\n\t\t{8,11},\n\t\t{11}};\n\ttypedef std::map<L,int>M;\n\tM m;\n\tM::iterator ite;\n\tstd::queue<L>q;\n\tq.push(0xBA9876543210LL);\n\tq.push(-1);\n\tint i,j,k;\n\tfor(int x=0;x<=20;)\n\t{\n\t\tL l=q.front();\n\t\tq.pop();\n\t\tif(l<0)\n\t\t{\n\t\t\tq.push(l);\n\t\t\t++x;\n\t\t\tcontinue;\n\t\t}\n\t\tite=m.find(l);\n\t\tif(ite!=m.end())continue;\n\t\tm[l]=x;\n\t\tint a[2];\n\t\tfor(i=j=0;i<13;++i)\n\t\t\tif( !(l&(15LL<<(i*4))) )\n\t\t\t\ta[j++]=i;\n\t\tfor(k=0;k<2;++k)\n\t\t\tfor(i=0;i<4;++i)\n\t\t\t{\n\t\t\t\tint c=di[a[k]][i];\n\t\t\t\tif(c)\n\t\t\t\t{\n\t\t\t\t\tL t=S(l,a[k],c-1);\n\t\t\t\t\tq.push(t);\n\t\t\t\t}\n\t\t\t\telse break;\n\t\t\t}\n\t}\n\tfor(;;)\n\t{\n\t\tL l=0,x;\n\t\tfor(i=0;i<13;++i)\n\t\t{\n\t\t\tif(scanf(\"%lld\",&x),x<0)return 0;\n\t\t\tl|=(x<<(i*4));\n\t\t}\n\t\tite=m.find(l);\n\t\tite==m.end()?puts(\"NA\"):printf(\"%d\\n\",ite->second);\n\t}\n}"
  },
  {
    "language": "C++",
    "code": "#include <cstdio>\n#include <cstring>\n#include <algorithm>\n#include <string>\n#include <cmath>\n#include <stack>\n#include <vector>\n#include <map>\n#include <set>\n#include <queue>\n#include <list>\n#include <iostream>\n#include <sstream>\n#include <climits>\n#include <cfloat>\n#include <complex>\n\nusing namespace std;\n\ntypedef long long ll;\n\nll encode(int* state)\n{\n\tll res = 0;\n\tfor (int i = 0; i < 13; ++i)\n\t\tres = res << 4 | state[i];\n\treturn res;\n}\nvoid decode(int* d, ll e)\n{\n\tfor (int i = 12; i >= 0; --i, e >>= 4)\n\t\td[i] = e & 15;\n}\nvoid p(ll s)\n{\n\tint d[13];\n\tdecode(d, s);\n\tfor (int i = 0; i < 13; ++i)\n\t\tprintf(\"%d \", d[i]);\n\tprintf(\"\\n\");\n}\n\nint main()\n{\n\tmap<ll, int> minSteps;\n\tint dir[] = { -1, 1, -2, 2, -4, 4 };\n\tmap<int, bool> ok[3];\n\n\tint o[][9] = {\n\t\t{ 1, 2, 4, 5, 6, 7, 9, 10, -1 },\n\t\t{ 0, 10, -1 },\n\t\t{ 1, 2, 3, 5, 6, 7, -1 }\n\t};\n\tfor (int i = 0; i < 3; ++i)\n\t\tfor (int j = 0; o[i][j] != -1; ++j)\n\t\t\tok[i][o[i][j]] = true;\n\n\tint initial[] = { 0, 1, 2, 3, 4, 5, 6, 7, 8, 9, 10, 11, 0 };\n\tll t = encode(initial);\n\tminSteps[t] = 0;\n\tqueue<ll> q;\n\tq.push(t);\n\n\twhile (!q.empty())\n\t{\n\t\tll e = q.front();\n\t\tq.pop();\n\t\tint d[13];\n\t\tdecode(d, e);\n\n\t\tint zero_pos[2];\n\t\tfor (int i = 0, j = 0; j < 2; ++i)\n\t\t\tif (!d[i])\n\t\t\t\tzero_pos[j++] = i;\n\n\t\tfor (int i = 0; i < 2; ++i)\n\t\t{\n\t\t\tfor (int j = 0; j < 6; ++j)\n\t\t\t{\n\t\t\t\tint a = zero_pos[i];\n\t\t\t\tint b = a + dir[j];\n\t\t\t\tif (a > b)\n\t\t\t\t\tswap(a, b);\n\t\t\t\tif (a < 0 || b > 12 || !d[a] && !d[b] || !ok[j/2][a])\n\t\t\t\t\tcontinue;\n\n\t\t\t\tint copy[13];\n\t\t\t\tmemcpy(copy, d, sizeof(copy));\n\t\t\t\tswap(copy[a], copy[b]);\n\t\t\t\tll next = encode(copy);\n\n\t\t\t\tif (!minSteps.count(next) && minSteps[e] < 20)\n\t\t\t\t{\n\t\t\t\t\tminSteps[next] = minSteps[e] + 1;\n\t\t\t\t\tq.push(next);\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t}\n\n\twhile (true)\n\t{\n\t\tint d[13];\n\t\tfor (int i = 0; i < 13; ++i)\n\t\t\tscanf(\"%d\", d + i);\n\t\tif (d[0] == -1)\n\t\t\tbreak;\n\t\tif (minSteps.count(encode(d)))\n\t\t\tprintf(\"%d\\n\", minSteps[encode(d)]);\n\t\telse\n\t\t\tputs(\"NA\");\n\t}\n\n\treturn 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include <cstdio>\n#include <cstdlib>\n#include <cmath>\n#include <climits>\n#include <cfloat>\n#include <map>\n#include <utility>\n#include <set>\n#include <iostream>\n#include <memory>\n#include <string>\n#include <vector>\n#include <algorithm>\n#include <functional>\n#include <sstream>\n#include <complex>\n#include <stack>\n#include <queue>\n#include <cstring>\n#include <sstream>\n#include <cassert>\n#include <list>\nusing namespace std;\nstatic const double EPS = 1e-10;\ntypedef long long ll;\ntypedef pair<int,int> PI;\ntypedef vector<int> vi;\n#ifndef M_PI\n#define M_PI 3.14159265358979323846\n#endif\n#define rep(i,n) for(int i=0;i<(int)n;++i)\n#define FOR(i,c) for(__typeof((c).begin())i=(c).begin();i!=(c).end();++i)\n#define ALL(c) (c).begin(), (c).end()\n#define mp(a,b) make_pair(a,b)\n#define pb(a) push_back(a)\n#define F first\n#define S second\ntemplate <typename T> string print_array(const vector<T> &V) { ostringstream os; os << \"{ \"; for (typename vector<T>::const_iterator iter = V.begin(); iter != V.end(); ++iter) os << '\\\"' << *iter << \"\\\",\"; os << \" }\"; return os.str(); }\n\nint dx[]={0,1,0,-1},dy[]={1,0,-1,0};\n\ntypedef struct{\n  vector<int> in;\n  int s1,s2;\n}state;\n\nvector<int> se[13];\n\nvoid pr(vector<int> in){\n  if(in.size()!=13)return;\n\n  printf(\"      %3d\\n\",in[0]);\n  printf(\"   %3d%3d%3d\\n\",in[1],in[2],in[3]);\n  printf(\"%3d%3d%3d%3d%3d\\n\",in[4],in[5],in[6],in[7],in[8]);\n  printf(\"   %3d%3d%3d\\n\",in[9],in[10],in[11]);\n  printf(\"      %3d\\n\",in[12]);\n  puts(\"\");\n}\n\nmain(){\n  int p;\n  vector<int> goal(13);\n  rep(i,11)goal[i+1]=i+1;\n  //cout<<print_array(goal)<<endl;\n\n  se[0].pb(2);\n  se[1].pb(2);\n  se[1].pb(5);\n  se[2].pb(0);\n  se[2].pb(1);\n  se[2].pb(3);\n  se[2].pb(6);\n  se[3].pb(2);\n  se[3].pb(7);\n  se[4].pb(5);\n  se[5].pb(1);\n  se[5].pb(4);\n  se[5].pb(6);\n  se[5].pb(9);\n  se[6].pb(2);\n  se[6].pb(5);\n  se[6].pb(7);\n  se[6].pb(10);\n  se[7].pb(3);\n  se[7].pb(6);\n  se[7].pb(8);\n  se[7].pb(11);\n  se[8].pb(7);\n  se[9].pb(5);\n  se[9].pb(10);\n  se[10].pb(6);\n  se[10].pb(9);\n  se[10].pb(11);\n  se[10].pb(12);\n  se[11].pb(7);\n  se[11].pb(10);\n  se[12].pb(10);\n  \n  while(cin>>p){\n    if(p==-1)break;\n    vector<int> in;\n    in.pb(p);\n    rep(i,12){\n      cin>>p;\n      in.pb(p);\n    }\n\n    set<vector<int> > app;\n\n    queue<pair<int,vector<int> > > Q;\n    app.insert(in);\n    Q.push(mp(0,in));\n    int ans=21;\n\n    while(!Q.empty()){\n      vector<int> cvec=Q.front().S;\n      int ccost=Q.front().F;\n      Q.pop();\n      //cout<<print_array(cvec)<<endl;\n      //pr(cvec);\n      if(ccost>3)break;\n      if(ccost>20)break;\n      if(cvec==goal){\n\tans=ccost;\n\tbreak;\n      }\n      rep(i,cvec.size()){\n\tif(!cvec[i]){\n\t  rep(j,se[i].size()){\n\t    if(cvec[se[i][j]]){\n\t      swap(cvec[se[i][j]],cvec[i]);\n\t      if(!app.count(cvec)){\n\t\tapp.insert(cvec);\n\t\tQ.push(mp(ccost+1,cvec));\n\t      }\n\t      swap(cvec[se[i][j]],cvec[i]);\n\t    }\n\t  }\n\t}\n      }\n    }\n    if(ans==21)cout<<\"NA\"<<endl;\n    else cout<<ans<<endl;\n  }\n}"
  },
  {
    "language": "C++",
    "code": "#include<iostream>\n#include<algorithm>\n#include<vector>\n#include<queue>\n#include<unordered_map>\n#include<unordered_set>\n#define lol(i,n) for(int i=0;i<n;i++)\n#define mod 1000000007\ntypedef long long ll;\nusing namespace std;\nint dx[13][4]={\n  {3,0,0,0},\n  {3,6,0,0},\n  {1,2,4,7},\n  {3,8,0,0},\n  {6,0,0,0},\n  {2,5,7,10},\n  {3,6,8,11},\n  {4,7,9,12},\n  {8,0,0,0},\n  {6,11,0,0},\n  {7,10,12,13},\n  {8,11,0,0},\n  {11,0,0,0}\n};\nunordered_map<ll,int> mp;\nll Compress(int p[]){\n  ll ans=0;\n  for(int i=0;i<13;i++){\n    ans*=13;\n    ans+=p[i];\n  }\n  return ans;\n}\n \nint unzip[13];\nvoid Unzip(ll x){\n  for(int i=0;i<13;i++){\n    unzip[12-i]=x%13;\n    x/=13;\n  }\n}\n \nint beflen=0;\nunordered_set<ll> vist;\nqueue<pair<ll,int> >Q;\nvoid BFS(int p[],int len){\n  //if(len!=beflen){cout<<len<<endl;beflen=len;}\n  ll tmp=Compress(p);\n  mp[tmp]=len;\n  if(len==12)return;\n  lol(i,13){\n    if(p[i]==0){\n      lol(j,4){\n    int t=dx[i][j];\n    if(t==0)break;\n    t--;\n    if(p[t]!=0){\n      swap(p[i],p[t]);\n      tmp=Compress(p);\n      if(vist.find(tmp)!=vist.end())continue;\n      vist.insert(tmp);\n      Q.push(make_pair(tmp,len+1));\n      swap(p[i],p[t]);\n    }\n      }\n    }\n  }\n}\n \nunordered_set<ll> st;\nint ans;\nvoid EFS(int p[],int len){\n  //if(len!=beflen){cout<<len<<endl;beflen=len;}\n  ll tmp=Compress(p);\n  if(vist.find(tmp)!=vist.end()){\n    ans=len+mp[tmp];\n    return;\n  }\n  if(len==8)return;\n  lol(i,13){\n    if(p[i]==0){\n      lol(j,4){\n    int t=dx[i][j];\n    if(t==0)break;\n    t--;\n    if(p[t]!=0){\n      swap(p[i],p[t]);\n      tmp=Compress(p);\n      if(st.find(tmp)!=st.end())continue;\n      st.insert(tmp);\n      Q.push(make_pair(tmp,len+1));\n      swap(p[i],p[t]);\n    }\n      }\n    }\n  }\n}\nint main(){\n  int p[13];\n  lol(i,13)p[i]=i;p[12]=0;\n  Q.push(make_pair(Compress(p),0));\n  while(!Q.empty()){\n    ll data=Q.front().first;\n    int len=Q.front().second;\n    Q.pop();\n    if(mp[data]>0)continue;\n    Unzip(data);\n    BFS(unzip,len);\n  }\n  //cout<<\"#\"<<mp.size()<<endl;\n  while(cin>>p[0]&&p[0]!=-1){\n    for(int i=1;i<13;i++)cin>>p[i];\n    ans=mod;\n    Q.push(make_pair(Compress(p),0));\n    while(!Q.empty()){\n      ll data=Q.front().first;\n      int len=Q.front().second;\n      Q.pop();\n      if(ans!=mod)continue;\n      if(st.find(data)!=st.end())continue;\n      st.insert(data);\n      Unzip(data);\n      EFS(unzip,len);\n    }\n    st.clear();\n    if(ans>20)cout<<\"NA\"<<endl;\n    else cout<<ans<<endl;\n  }\n  return 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include<iostream>\n#include<vector>\n#include<map>\n#include<cstdio>\n#include<deque>\n#include<cmath>\n#include<algorithm>\n#define F first\n#define S second\n#define pb push_back\nusing namespace std;\ntypedef pair<int,int> P;\ntypedef pair<P,P> PP;\ntypedef vector<int> VI;\ntypedef vector<VI> VVI;\ntypedef vector<P> VP;\ntypedef pair<VVI,VP> VVIVP;\n\n\nmap<VVI,int> memo,bidirectional;\nVVI final;\nVP ini;\nint dx[4] = {0,1,0,-1};\nint dy[4] = {1,0,-1,0};\n\nP Fpos[] = {P(0,0),P(1,1),P(2,1),P(3,1),P(0,2),P(1,2),P(2,2),P(3,2),P(4,2),P(1,3),P(2,3),P(3,3)};\n\n\nclass Puzzle\n{\npublic:\n  VVI state;\n  int Manhattan;\n  VP vp;\n\n  Puzzle():Manhattan(0){}\n  Puzzle(VVI s)\n  {\n    vp.clear();\n    state = s;\n    Manhattan_calc(false);\n  }\n\n  void Manhattan_calc(bool b)\n  {\n    Manhattan = 0; \n    for(int i=0;i<5;i++)\n      for(int j=0;j<state[i].size();j++)\n\tif(state[i][j] != 0 && state[i][j] != -1)\n\t  Manhattan += abs(j-Fpos[state[i][j]].F) + abs(i-Fpos[state[i][j]].S);\n\telse if(state[i][j] == 0 && !b)// bがfalseなら初期化\n\t  vp.push_back(P(j,i)); \n  }\n\n  void print()\n  {\n  \n    for(int i=0;i<state.size();i++)\n      {\n\tfor(int j=0;j<state[i].size();j++)\n\t  {\n\t    if(state[i][j] == -1)\n\t      cout << \"  \";\n\t    else \n\t      cout << state[i][j] << \" \";\n\t  }\n\tcout << endl;\n      }\n    cout << endl;\n  }\n};\n\nbool Input(VVI& puzzle)\n{\n  puzzle.clear();\n  puzzle.resize(5);\n  puzzle[0].resize(3),puzzle[1].resize(4),puzzle[2].resize(5),puzzle[3].resize(4),puzzle[4].resize(3);\n  puzzle[0][0] = puzzle[0][1] = puzzle[1][0] = puzzle[3][0] = puzzle[4][0] = puzzle[4][1] = -1;\n \n  scanf(\"%d\",&puzzle[0][2]);\n  if(puzzle[0][2] == -1)\n    return false; \n  scanf(\"%d %d %d\",&puzzle[1][1],&puzzle[1][2],&puzzle[1][3]);\n  scanf(\"%d %d %d %d %d\",&puzzle[2][0],&puzzle[2][1],&puzzle[2][2],&puzzle[2][3],&puzzle[2][4]);\n  scanf(\"%d %d %d\",&puzzle[3][1],&puzzle[3][2],&puzzle[3][3]);\n  scanf(\"%d\",&puzzle[4][2]);\n\t    \n    return true;\n}\n\nvoid print(VVI vvi)\n{\n  cout << \"--- print ---\" << endl;\n  for(int i=0;i<vvi.size();i++)\n    {\n      for(int j=0;j<vvi[i].size();j++)\n\t{\n\t  cout << vvi[i][j] << \" \";\n\t}\n      cout << endl;\n    }\n  cout << endl;\n}\n\nVVI change(VVI vec,P p1,P p11)\n{\n  int tmp = vec[p1.S][p1.F];\n  vec[p1.S][p1.F] = vec[p11.S][p11.F];\n  vec[p11.S][p11.F] = tmp;\n\n  return vec;\n}\n\nvoid Init()\n{\n  final.resize(5);\n  final[0].pb(-1),final[0].pb(-1),final[0].pb(0);\n  final[1].pb(-1),final[1].pb(1),final[1].pb(2),final[1].pb(3);\n  final[2].pb(4),final[2].pb(5),final[2].pb(6),final[2].pb(7),final[2].pb(8);\n  final[3].pb(-1),final[3].pb(9),final[3].pb(10),final[3].pb(11);\n  final[4].pb(-1),final[4].pb(-1),final[4].pb(0);\n\n  Puzzle puz(final); \n  deque<Puzzle> deq;\n  deq.push_back(puz);\n  bidirectional[final] = 0;\n  \n  while(!deq.empty())\n    {\n      Puzzle p = deq.front(); deq.pop_front();\n      int cost = bidirectional[p.state];\n    \n      if(cost >= 10)\n\tcontinue;\n\n      for(int i=0;i<2;i++)\n\t{\n\t  for(int j=0;j<4;j++)\n\t    {\n\t      int nx = p.vp[i].F + dx[j];\n\t      int ny = p.vp[i].S + dy[j];\n\t      if(!(0<=ny && ny<p.state.size() && 0<=nx && nx<p.state[ny].size() && p.state[ny][nx] != -1))\n\t\tcontinue;\n\t      VVI next = change(p.state,p.vp[i],P(nx,ny));\n\t      map<VVI,int>::iterator it = bidirectional.find(next);\n\t      if(it == bidirectional.end() || (it != bidirectional.end() && bidirectional[next] > cost + 1))\n\t\t{\n\t\t  bidirectional[next] = cost + 1;\n\t\t  deq.push_back(Puzzle(next));\n\t\t}\n\n\t    }\n\n\t}      \n\n    }\n  \n  \n}\n\n\nint main()\n{\n  VVI puzzle;\n  Init();\n  //cout << \"here\" << endl;\n  while(Input(puzzle))\n    {\n \n      Puzzle puz(puzzle);\n      int men = (1<<28);\n      deque<Puzzle> deq;\n      deq.push_back(puz);\n      memo.clear();\n      memo[puzzle] = 0;\n\n      while(!deq.empty())\n\t{\n\t  Puzzle p = deq.front(); deq.pop_front();\n\t  int cost = memo[p.state];\n\t  //cout << \"cost : \" << cost << endl;\n\t  //p.print();\n\t  if(cost + p.Manhattan > min(20,men))\n\t    continue;\n\n\t  if(p.state == final)\n\t    {\n\t      men = min(men,cost);\n\t      continue;\n\t    }\n\t  else if(bidirectional.find(p.state) != bidirectional.end() && cost + bidirectional[p.state] <= 20)\n\t    {\n\t      men = min(men,cost+bidirectional[p.state]);\n\t      continue;\n\t    }\n       \n\t  for(int i=0;i<2;i++)\n\t    {\n\t      for(int j=0;j<4;j++)\n\t\t{\n  \n\t\t  int nx = p.vp[i].F + dx[j];\n\t\t  int ny = p.vp[i].S + dy[j];\n\t\t  if(!(0<=ny && ny<p.state.size() && 0<=nx && nx<p.state[ny].size() && p.state[ny][nx] != -1))\n\t\t    continue;\n\n\t\t  VVI next = change(p.state,p.vp[i],P(nx,ny));\n\t\t  map<VVI,int>::iterator it = memo.find(next);\n\t\t  if(it == memo.end() || (it != memo.end() &&  memo[next] > cost + 1) )\n\t\t    {\n\t\t      memo[next] = cost + 1;\n\t\t      deq.push_back(Puzzle(next));\n\t\t    }\n\n\t\t}\n\t    }\n\n\n\t}\n      if(men == (1<<28))\n\tcout << \"NA\" << endl;\n      else \n\tcout << men << endl;\n    }  \n\n    \n  return 0;\n}\n\n\n  /*  \n  deque<VVIVP> deq;\n  VP vec;\n  vec.push_back(P(0,0));\n  vec.push_back(P(0,4)); \n  deq.push_back(VVIVP(final,vec));\n  bidirectional[final] = 0;\n  while(!deq.empty())\n    {\n      VVIVP vvivp = deq.front(); deq.pop_front();\n      VVI vvi = vvivp.F;\n      VP vp = vvivp.S;\n      P p1,p2;\n      int cost = bidirectional[vvi];\n      if(cost >= 5)\n\tcontinue;\n      p1 = vp[0];\n      p2 = vp[1];\n      \n      for(int i=0;i<5;i++)\n\t{\n\t  int nx1 = p1.F + dx[i];\n\t  int ny1 = p1.S + dy[i];\n\n\t  if(!(0 <= ny1 && ny1 < vvi.size() && 0 <= nx1 && nx1 < vvi[ny1].size()))\n\t    continue;\n\n\t  for(int j=0;j<5;j++)\n\t    {\n\t      if(i == 4 && j == 4)\n\t\tcontinue;\n\t      int nx2 = p2.F + dx[j];\n\t      int ny2 = p2.S + dy[j];\n\n\t      if(!(0 <= ny2 && ny2 < vvi.size() && 0 <= nx2 && nx2 < vvi[ny2].size()))\n\t\tcontinue;\n\t      VVI new_vvi = change(vvi,p1,P(nx1,ny1),p2,P(nx2,ny2));\n\t      if(bidirectional.count(new_vvi) == 0 || (bidirectional.count(new_vvi) != 0 && bidirectional[new_vvi] > cost + 1))\n\t\t{\n\t\t  VP vip;\n\t\t  vip.push_back(P(nx1,ny1));\n\t\t  vip.push_back(P(nx2,ny2));\n\t\t  bidirectional[new_vvi] = cost+1;\n\t\t  deq.push_back(VVIVP(new_vvi,vip));\n\t\t}\n\n\t     \n\n\t    }\n\t}\n\n    }\n*/\n\n/*\n int men = (1<<28);\n      deque<VVIVP> deq;\n      bool fin = false;\n      deq.push_back(VVIVP(puzzle,ini));\n      memo[puzzle] = 0;\n      while(!deq.empty() && !fin)\n\t{\n\t  VVIVP vvivp = deq.front(); deq.pop_front();\n\t  VVI vvi = vvivp.F;\n\t  VP vp = vvivp.S;\n\t  P p1,p2;\n\t  p1 = vp[0], p2 = vp[1];\n\t \n\t  if((vvi == final || bidirectional.count(vvi) != 0) && memo[vvi] + bidirectional[vvi] <= min(20,men))\n\t    {\n\t      men = min(men,memo[vvi]+bidirectional[vvi]);\n\t      continue;\n\t    }\n\t  \n\t  int cost = memo[vvi];\n\n\t  if(men <= cost) \n\t    continue;\n\n\t  for(int i=0;i<5;i++)\n\t    {\n\t      int nx1 = p1.F + dx[i];\n\t      int ny1 = p1.S + dy[i];\n\n\t      if(!(0 <= ny1 && ny1 < vvi.size() && 0 <= nx1 && nx1 < vvi[ny1].size()))\n\t\tcontinue;\n\n\t      for(int j=0;j<5;j++)\n\t\t{\n\t\t  if(i = 4 && j == 4)\n\t\t    continue;\n\t\t  int nx2 = p2.F + dx[j];\n\t\t  int ny2 = p2.S + dy[j];\n\t\t  \n\t\t  if(!(0 <= ny2 && ny2 < vvi.size() && 0 <= nx2 && nx2 < vvi[ny2].size()))\n\t\t    continue;\n\n\t\t  //cout << \"change! \" << i << \" - \" << j << endl;\n\n\t\t  //cout <<\"cost = \" << cost << endl;\n\t\t   //print(change(vvi,p1,P(nx1,ny1),p2,P(nx2,ny2)));\n\t\t  VVI new_vvi = change(vvi,p1,P(nx1,ny1),p2,P(nx2,ny2));\n\t\t  if(memo.count(new_vvi) == 0 || (memo.count(new_vvi) != 0 && memo[new_vvi] > cost+1))\n\t\t    {\n\t\t \n\t\t      memo[new_vvi] = cost+1;\n\t\t      VP vip;\n\t\t      vip.push_back(P(nx1,ny1));\n\t\t      vip.push_back(P(nx2,ny2));\n\t\t      deq.push_back(VVIVP(new_vvi,vip));\n\t\t    }\n\n\n\t\t}\n\n\t    }\n\n\t}\n\n      if(men != (1<<28))\n\tcout << men << endl;\n      else \n\tcout << \"NA\" << endl;\n */\n\n\n/*\nwhile(Input(puzzle)){\n      int men = (1<<28);\n      deque<VVIVP> deq;\n      bool fin = false;\n      deq.push_back(VVIVP(puzzle,ini));\n      memo[puzzle] = 0;\n      while(!deq.empty())\n\t{\n\t  VVIVP vvivp = deq.front(); deq.pop_front();\n\t  VVI vvi = vvivp.F;\n\t  VP vp = vvivp.S;\n\t \n\t  if(vvi == final)\n\t    {\n\t      men = min(men,memo[vvi]);\n\t      fin = true;\n\t    }\n\t  else if(bidirectional.count(vvi) != 0 && memo[vvi] + bidirectional[vvi] <= 20)\n\t    {\n\t      fin = true;\n\t      men = min(men,memo[vvi]+bidirectional[vvi]);\n\t      break;\n\t    }\n\t \n\t  int cost = memo[vvi];\n\t  if(cost >= men)\n\t    continue;\n\n\t  //cout << \"cost = \" << cost << endl;\n\t  P p1,p2;\n\t  p1 = vp[0];\n\t  p2 = vp[1];\n\t  for(int k=0;k<5;k++)\n\t    {\n\t      int nx1,ny1;\n\t      nx1 = vp[0].F + dx[k];\n\t      ny1 = vp[0].S + dy[k];\n\t      if(!(0 <= ny1 && vvi.size() > ny1 && 0 <= nx1 && vvi[ny1].size() > nx1))\n\t\tcontinue;\n\n\t      for(int l=0;l<5;l++)\n\t\t{\n\t\t  int nx2,ny2;\n\t\n\t\t  nx2 = vp[1].F + dx[l];\n\t\t  ny2 = vp[1].S + dy[l];\n\n\t\t  if(!(0 <= ny2 && vvi.size() > ny2 && 0 <= nx2 && vvi[ny2].size() > nx2))\n\t\t    continue;\n\t\n\t\n\t\t  int tmp = vvi[p1.S][p1.F];\n\t\t  vvi[p1.S][p1.F] = vvi[ny1][nx1];\n\t\t  vvi[ny1][nx1] = tmp;\n\n\t\t  tmp = vvi[p2.S][p2.F];\n\t\t  vvi[p2.S][p2.F] = vvi[ny2][nx2];\n\t\t  vvi[ny2][nx2] = tmp;\n\t\n\n\t\t  if(cost+1 >= 20 && vvi != final)\n\t\t    continue;\n\n\t\t  if(cost+1 >= 20 && vvi == final)\n\t\t    {\n\t\t      fin = true;\n\t\t      printf(\"20\\n\");\n\t\t      break;\n\t\t    }\n\n\t\t  if((memo.count(vvi) != 0 && memo[vvi] > cost + 1) || memo.count(vvi) == 0)\n\t\t    {\n\t\t      VP vip;\n\t\t      vip.push_back(P(nx1,ny1));\n\t\t      vip.push_back(P(nx2,ny2));\n\t\t      memo[vvi] = cost + 1;\n\t\t      deq.push_back(VVIVP(vvi,vip)); \n\t\t    }\n\n\t\n\t\t  tmp = vvi[p1.S][p1.F];\n\t\t  vvi[p1.S][p1.F] = vvi[ny1][nx1];\n\t\t  vvi[ny1][nx1] = tmp;\n\n\t\t  tmp = vvi[p2.S][p2.F];\n\t\t  vvi[p2.S][p2.F] = vvi[ny2][nx2];\n\t\t  vvi[ny2][nx2] = tmp;\n\t\n\t\t}\n\t      if(fin)\n\t\tbreak;\n\t    }\n\t  if(fin)\n\t    break;\n\t}\n      if(!fin)\n\tprintf(\"NA\\n\");\n      else\n\tprintf(\"%d\\n\",men);\n    }\n\n */"
  },
  {
    "language": "C++",
    "code": "#include <iostream>\n#include <algorithm>\n#include <vector>\n#include <cstring>\n#include <cstdio>\n#include <climits>\n\nusing namespace std;\n\n\n#define REP(i,a,n) for(int i=(a); i<(int)(n); i++)\n#define rep(i,n) REP(i,0,n)\n#define DEB 0\n\nint board[7][7]; //1base\nint sx[2], sy[2];\nstatic const int dx[] = {0,0,1,-1};\nstatic const int dy[] = {1,-1,0,0};\n\nint calc(int y, int x){\n    switch(board[y][x]){\n    case 1: return abs(2-y)+abs(2-x);\n    case 2: return abs(2-y)+abs(3-x);\n    case 3: return abs(2-y)+abs(4-x);\n    case 4: return abs(3-y)+abs(1-x);\n    case 5: return abs(3-y)+abs(2-x);\n    case 6: return abs(3-y)+abs(3-x);\n    case 7: return abs(3-y)+abs(4-x);\n    case 8: return abs(3-y)+abs(5-x);\n    case 9: return abs(4-y)+abs(2-x);\n    case 10: return abs(4-y)+abs(3-x);\n    case 11: return abs(4-y)+abs(4-x);\n    }\n    return -1;\n}\nint dist(void){\n    int ret = 0;\n    if( board[1][3] ) ret += calc(1,3);\n    rep(i,3) if( board[2][2+i] ) ret += calc(2,2+i);\n    rep(i,5) if( board[3][1+i] ) ret += calc(3,1+i);\n    rep(i,3) if( board[4][2+i] ) ret += calc(4,2+i);\n    if( board[5][3] ) ret += calc(5,3);\n    return ret;\n}\nbool isgoal(void){\n    if( board[1][3]!=0 ) return false;\n    rep(i,3) if( board[2][2+i]!=i+1 ) return false;\n    rep(i,5) if( board[3][1+i]!=i+4 ) return false;\n    rep(i,3) if( board[4][2+i]!=i+9 ) return false;\n    if( board[5][3]!=0 ) return false;\n    return true;\n}\n\nbool dfs(int cnt, int LIM, const vector<pair<int,int> > sp){\n    if( isgoal() ) return true;\n    if( cnt+dist()>LIM ) return false;\n\n    rep(i,2){\n        if( board[sp[i].second][sp[i].first]!=0 ) exit(-1);\n        rep(k,4){\n            int tx = sp[i].first + dx[k];\n            int ty = sp[i].second + dy[k];\n            if( board[ty][tx]<=0 ) continue;\n\n            swap(board[sp[i].second][sp[i].first], board[ty][tx]);\n\n            vector<pair<int,int> > v = sp;\n            pair<int,int> tmp(tx,ty);\n            swap(v[i], tmp);\n            if( dfs(cnt+1, LIM, v) ) return true;\n\n            swap(board[sp[i].second][sp[i].first] ,board[ty][tx]);\n        }\n    }\n    return false;\n}\nint solve(void){\n    int ttx[2], tty[2];\n    int tb[7][7];\n    vector<pair<int,int> > sp;\n    rep(i,2) sp.push_back(make_pair(sx[i],sy[i]));\n    //rep(i,7)rep(j,7) tb[i][j] = board[i][j];\n\n    for(int lim = 0; lim < 21; lim++){\n        if( dfs(0,lim,sp) ) return lim;\n        //rep(i,7)rep(j,7)if( board[i][j]!=tb[i][j] ) puts(\"ugeeeee\");\n    }\n    return -1;\n}\nint main(){\n    for(;;){\n        memset(board, -1, sizeof(board));\n        int sz = 0;\n\n        scanf(\"%d\",&board[1][3]); if( board[1][3]==-1 ) break;\n        rep(i,3) scanf(\"%d\",&board[2][2+i]);\n        rep(i,5) scanf(\"%d\",&board[3][1+i]);\n        rep(i,3) scanf(\"%d\",&board[4][2+i]);\n        scanf(\"%d\",&board[5][3]);\n\n        // find space\n        if( board[1][3]==0 ){ sx[sz]=3; sy[sz]=1; sz++; }\n        rep(i,3) if( board[2][2+i]==0 ) { sx[sz]=2+i; sy[sz]=2; sz++; }\n        rep(i,5) if( board[3][1+i]==0 ) { sx[sz]=1+i; sy[sz]=3; sz++; }\n        rep(i,3) if( board[4][2+i]==0 ) { sx[sz]=2+i; sy[sz]=4; sz++; }\n        if( board[5][3]==0 ){ sx[sz]=3; sy[sz]=5; sz++; }\n\n        //printf(\"hoge:%d\\n\",dist());\n        int ans = solve();\n        if( ans!=-1 ) printf(\"%d\\n\",ans); else puts(\"NA\");\n    }\n    return 0;\n}\n\n/*\n\n//-------------------------------------------------------\n\n#define N 5\n#define REP(i, n) for ( int i = 0; i < (int)n; i++ )\n#define LIMIT 20\n\nstatic const int T[12][2] = {\n    {-1, -1},\n    {1, 1}, \n    {1, 2}, \n    {1, 3},\n    {2, 0},\n    {2, 1},\n    {2, 2},\n    {2, 3},\n    {2, 4},\n    {3, 1}, \n    {3, 2},\n    {3, 3}\n};\nstatic const int g[N][N] = {\n    {-1,-1, 0,-1,-1},\n    {-1, 1, 2, 3,-1},\n    { 4, 5, 6, 7, 8},\n    {-1, 9,10,11,-1}, \n    {-1,-1, 0,-1,-1}\n};\n\nclass Puzzle{\npublic:\n    int C[N][N], mdist; //manhatta distance\n    Puzzle(){}\n\n    bool swapAdj( int si, int sj, int ti, int tj ){\n        if ( ti < 0 || tj < 0 || ti >= N || tj >= N ) return false;\n        if ( C[ti][tj] <= 0 ) return false;\n        swap(C[ti][tj], C[si][sj]);\n        int tti = T[C[si][sj]][0];\n        int ttj = T[C[si][sj]][1];\n        //mdist -= max(tti, ti)-min(tti, ti) + max(ttj, tj)-min(ttj, tj);\n        //mdist += max(tti, si)-min(tti, si) + max(ttj, sj)-min(ttj, sj);\n        //mdist -= abs(tti-ti)+abs(ttj-tj);\n        //mdist += abs(tti-si)+abs(ttj-sj);\n        return true;\n    }\n\n    bool isGoal(){\n        REP(i, N) REP(j, N) if ( g[i][j] != C[i][j] ) return false;\n        return true;\n    }\n\n    int getMD(){ // get initial manhattan distance\n        int sum = 0;\n        int ti, tj;\n        REP(i, 5) REP(j, 5){\n            if ( C[i][j] <= 0 ) continue;\n            ti = T[C[i][j]][0];\n            tj = T[C[i][j]][1];\n            //sum += (max(ti, i)-min(ti, i) + max(tj, j) - min(tj, j));\n            sum += abs(ti-i) + abs(tj-j);\n        }\n        return sum;\n    }\n};\n\nint limit;\n\nbool dfs( int depth, Puzzle P ){\n    if ( P.isGoal() ) return true;\n    if ( depth + P.getMD() > limit ) return false;\n\n    static const int di[4] = {0, -1, 0, 1};\n    static const int dj[4] = {1, 0, -1, 0};\n\n    REP(i, N) REP(j, N){\n        if ( P.C[i][j] != 0 ) continue;\n        REP(r, 4){\n            Puzzle v = P;\n            if ( !v.swapAdj(i, j, i+di[r], j+dj[r]) ) continue;\n            if ( dfs( depth + 1, v ) ) return true;\n        }\n    }\n\n    return false;\n}\n\nint idp(Puzzle source){\n    for ( limit = 0; limit <= LIMIT; limit++ ){\n        //source.mdist = source.getMD();\n        if ( dfs(0, source) ) return limit;\n    }\n    return INT_MAX;\n}\n\nint main(){\n    Puzzle P;\n    int top;\n\n    while(1){\n        cin >> top;\n        if ( top == -1 ) break;\n        REP(j, N) P.C[0][j] = -1;\n        P.C[0][2] = top;\n        for(int i = 1; i < N; i++) REP(j, N){\n                if ( (i == 1 || i == 3) && (j == 0 || j == 4 ) ) P.C[i][j] = -1;\n                else if ( i == 4 && j != 2 ) P.C[i][j] = -1;\n                else cin >> P.C[i][j];\n            }\n\n        int cost = idp(P);\n        if ( cost == INT_MAX ) cout << \"NA\" << endl;\n        else cout << cost << endl;\t\n    }\n\n    return 0;\n}\n\n*/"
  },
  {
    "language": "C++",
    "code": "#include<cstdio>\n#include<algorithm>\n#include<iostream>\n#include<queue>\n#include<functional>\n#include<map>\n#include<vector>\nusing namespace std;\nclass P{\n\tpublic:\n\tint state[15];\n\tint cnt;\n\tint p1;\n\tint p2;\n\tP(){}\n\tP(int a[15],int cnt,int p1,int p2):cnt(cnt),p1(p1),p2(p2){\n\t\tfor(int i = 0; i < 15; i++){\n\t\t\tstate[i] = a[i];\n\t\t}\n\t}\n};\nint rules[13][6]={\n\t{1,2},{2,2,5},{4,0,1,3,6},{2,2,7},{1,5},\n\t{4,1,4,6,9},{4,2,5,7,10},{4,3,6,8,11},{1,7},{2,5,10},\n\t{4,6,9,11,12},{2,7,10},{1,10}};\nmap< string , int >memo;\n\nstring getIndex(int *a){\n\tstring tmp=\"\";\n\tfor(int i = 0; i < 13; i++){\n\t\ttmp += (a[i]+48);\n\t}\n\treturn tmp;\n}\n\nvoid bfs(){\n\tint F[] = {0,1,2,3,4,5,6,7,8,9,10,11,0};\n\tqueue < P > Q;\n\tQ.push(P(F,1,0,12));\n\twhile( true ){\n\t\tif(Q.size() == 0)break;\n\t\tP p = Q.front();Q.pop();\n\t\tif(p.cnt > 21)break;\n\t\tstring index = getIndex(p.state);\n\t\tif( memo[index] )continue;\n\t\tmemo[index] = p.cnt;\n\t\tint zero = p.p1;\n        for(int j = 0; j < rules[zero][0]; j++){\n            if(p.state[rules[zero][j+1]] == 0)continue;\n            swap(p.state[zero],p.state[rules[zero][j+1]]);\n            Q.push(P(p.state,p.cnt+1,p.state[rules[zero][j+1]],p.p2));\n            swap(p.state[zero],p.state[rules[zero][j+1]]);\n        }\n        zero = p.p2;\n        for(int j = 0; j < rules[zero][0]; j++){\n            if(p.state[rules[zero][j+1]] == 0)continue;\n            swap(p.state[zero],p.state[rules[zero][j+1]]);\n            Q.push(P(p.state,p.cnt+1,p.p1,p.state[rules[zero][j+1]]));\n            swap(p.state[zero],p.state[rules[zero][j+1]]);\n        }\n\t}\n\treturn ;\n}\nint main(){\n\tbfs();\n\tint input[15];\n\twhile(true){\n\t    scanf(\"%d\",&input[0]);\n\t    if(input[0] == -1)break;\n\t\tfor(int i = 1; i < 13; i++){\n\t\t\tscanf(\"%d\",&input[i]);\n\t\t}\n\t\tstring index = getIndex(input);\n\t\tif( memo[index] )printf(\"%d\\n\",memo[index]-1);\n\t\telse puts(\"NA\");\n\t}\n\treturn 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include <iostream>\n#include <cstdio>\n#include <vector>\n#include <algorithm>\n#include <complex>\n#include <cstring>\n#include <cstdlib>\n#include <string>\n#include <cmath>\n#include <queue>\n#include <set>\nusing namespace std;\n\n#define REP(i,n) for(int i=0;i<(int)n;++i)\n#define FOR(i,c) for(__typeof((c).begin())i=(c).begin();i!=(c).end();++i)\n#define ALL(c) (c).begin(), (c).end()\nconst int INF = 1<<29;\n\ntypedef vector<vector<int> > mat;\nint dx[] = {0,1,0,-1};\nint dy[] = {1,0,-1,0};\n\nmat goal(5, vector<int>(5,-1));\nset<mat> mp;\n\nint hogex[12] = {0,1,2,3,0,1,2,3,4,1,2,3};\nint hogey[12] = {0,1,1,1,2,2,2,2,2,3,3,3};\nint dist(mat a) {\n  int res = 0;\n  REP(x,5) {\n    REP(y,5) {\n      if (a[x][y] > 0) {\n        res += abs(x-hogex[a[x][y]]) + abs(y-hogey[a[x][y]]);\n      }\n    }\n  }\n  return res;\n}\n\nint main() {\n  goal[2][0] = 0;\n  REP(i,3) goal[i+1][1] = i+1;\n  REP(i,5) goal[i][2] = i+4;\n  REP(i,3) goal[i+1][3] = i+9;\n  goal[2][4] = 0;\n  \n  int a;\n  while(cin >> a, a!=-1) {\n    mp.clear();\n    mat ma(5, vector<int>(5, -1));\n    ma[2][0] = a;\n    REP(i,3) {\n      cin >> a;\n      ma[i+1][1] = a;\n    }\n    REP(i,5) {\n      cin >> a;\n      ma[i][2] = a;\n    }\n    REP(i,3) {\n      cin >> a;\n      ma[i+1][3] = a;\n    }\n    cin >> a;\n    ma[2][4] = a;\n\n    queue<pair<mat, int> > Q;\n    Q.push(pair<mat, int>(ma, 0));\n    mp.insert(ma);\n    bool ff = 0;\n    while(!Q.empty()) {\n      mat ma2 = Q.front().first;\n      int d = Q.front().second;\n      Q.pop();\n//      cout << d << \" \" << mp.size() << endl;\n      if (d > 20) break;\n      if (ma2 == goal) {\n        ff = 1;\n        cout << d << endl;\n        break;\n      }\n      if (d + dist(ma2) > 20) continue;\n      \n      vector<int> zx,zy;\n      REP(x,5) REP(y,5) {\n        if (ma2[x][y] == 0) {\n          zx.push_back(x);\n          zy.push_back(y);\n        }\n      }\n      REP(i,2) {\n        int x = zx[i], y = zy[i];\n        REP(k,4) {\n          int xx = x + dx[k];\n          int yy = y + dy[k];\n\n          if (xx<0 || xx>=5 || yy<0 || yy>=5) continue;\n          if (ma2[xx][yy] == -1) continue;\n\n          mat tmp = ma2;\n          swap(tmp[x][y], tmp[xx][yy]);\n          if (mp.count(tmp)) continue;\n          mp.insert(tmp);\n          Q.push(make_pair(tmp, d+1));\n        }\n      }\n    }\n    if (!ff)\n      cout << \"NA\" << endl;\n  }\n}"
  },
  {
    "language": "C++",
    "code": "#include<bits/stdc++.h>\n#define int long long\n#define r(i,n) for(int i=0;i<n;i++)\nusing namespace std;\ntypedef pair<int,int>P;\nvector<int>v[13],s(13),t(13);\nmap<int,int>m;\n\nint has[14];\n\n\nvoid init(){\n\n    v[0].push_back(2);\n\n    v[1].push_back(2);\n    v[1].push_back(5);\n\n    v[2].push_back(0);\n    v[2].push_back(1);\n    v[2].push_back(3);\n    v[2].push_back(6);\n\n    v[3].push_back(2);\n    v[3].push_back(7);\n\n    v[4].push_back(5);\n\n    v[5].push_back(1);\n    v[5].push_back(4);\n    v[5].push_back(6);\n    v[5].push_back(9);\n\n    v[6].push_back(2);\n    v[6].push_back(5);\n    v[6].push_back(7);\n    v[6].push_back(10);\n\n    v[7].push_back(3);\n    v[7].push_back(6);\n    v[7].push_back(8);\n    v[7].push_back(11);\n\n    v[8].push_back(7);\n\n    v[9].push_back(5);\n    v[9].push_back(10);\n\n    v[10].push_back(6);\n    v[10].push_back(9);\n    v[10].push_back(11);\n    v[10].push_back(12);\n\n    v[11].push_back(7);\n    v[11].push_back(10);\n\n    v[12].push_back(10);\n\n    int a=20;\n    int p=1;\n\n    r(i,13){\n        has[i]=p;\n        p*=a;\n    }\n}\n\nint ha(vector<int> &x){\n\n    int re=0;\n\n    r(i,13){\n        re+=x[i]*has[i];\n    }\n\n    return re;\n}\n\nvector<int> ah(int x){\n    vector<int>y(13);\n    r(i,13){\n        y[i]=x%20;\n        x/=20;\n    }\n    return y;\n}\n\nvoid BFS1(){\n    s[0]=0;\n    s[12]=0;\n    r(i,11)s[i+1]=i+1;\n    set<int>st;\n    st.insert(ha(s));\n    m[ha(s)]=0;\n    queue<P>q;\n    q.push(P(ha(s),0));\n    while(1){\n        vector<int> now=ah(q.front().first);\n        int cost=q.front().second;\n        q.pop();\n        if(cost==7)break;\n        r(i,13)if(now[i]!=0){\n            r(j,v[i].size()){\n                swap(now[i],now[v[i][j]]);\n                if(!st.count(ha(now))){\n                    st.insert(ha(now));\n                    m[ha(now)]=cost+1;\n                    q.push(P(ha(now),cost+1));\n                }\n                swap(now[i],now[v[i][j]]);\n            }\n        }\n    }\n}\n\nvoid BFS2(){\n    set<int>st;\n    st.insert(ha(t));\n    queue<P>q;\n    q.push(P(ha(t),0));\n    while(1){\n        vector<int>now=ah(q.front().first);\n        int cost=q.front().second;\n        if(m.count(ha(now))){\n            cout<<m[ha(now)]+cost<<endl;\n            return ;\n        }\n        q.pop();\n        if(cost==5)break;\n        r(i,13)if(now[i]!=0){\n            r(j,v[i].size()){\n                swap(now[i],now[v[i][j]]);\n                if(!st.count(ha(now))){\n                    st.insert(ha(now));\n                    q.push(P(ha(now),cost+1));\n                }\n                swap(now[i],now[v[i][j]]);\n            }\n        }\n    }\n    cout<<\"NA\"<<endl;\n}\n\n\nsigned main(){\n    init();\n    BFS1();\n    while(cin>>t[0],t[0]!=-1){\n        r(i,12)cin>>t[i+1];\n        BFS2();\n    }\n}\n"
  },
  {
    "language": "C++",
    "code": "#include <iostream>\n#include <cstdio>\n#include <queue>\n#include <set>\n#include <map>\n#include <cmath>\nusing namespace std;\ntypedef unsigned long long ull;\n#define pb push_back\null B = 1000000007ull;\nint a[5]={2,1,0,1,2};\nint b[5]={2,3,4,3,2};\nint dx[5]={0,1,0,-1};\nint dy[5]={1,0,-1,0};\nint px[13]={0,1,1,1,2,2,2,2,2,3,3,3,0};\nint py[13]={0,1,2,3,0,1,2,3,4,1,2,3,0};\n\nstruct State\n{\n\tint f[5][5];\n\tint t;\n};\nvector<int> hash(State x)\n{\n\tvector<int> res;\n\tfor(int i=0;i<5;i++)\n\t{\n\t\tfor(int j=a[i];j<=b[i];j++)\n\t\t{\n\t\t\tres.pb(x.f[i][j]);\n\t\t}\n\t}\n\treturn res;\n}\nmap<vector<int>,int> mp;\nset<vector<int> > used;\nbool check(State x)\n{\n\tint cnt=1;\n\tfor(int i=1;i<=3;i++)\n\t{\n\t\tfor(int j=a[i];j<=b[i];j++)\n\t\t{\n\t\t\tif(x.f[i][j]!=cnt)return false;\n\t\t\tcnt++;\n\t\t}\n\t}\n\treturn true;\n}\nbool cc(State x)\n{\n\tint res = 0;\n\tfor(int i=0;i<5;i++)\n\t{\n\t\tfor(int j=a[i];j<=b[i];j++)\n\t\t{\n\t\t\tif(x.f[i][j]>0)\n\t\t\t{\n\t\t\t\tint k = x.f[i][j];\n\t\t\t\tres += (abs(px[k]-i)+abs(py[k]-j));\n\t\t\t}\n\t\t}\n\t}\n\treturn (res>20-x.t);\n}\nint ans = 21;\nvoid bfs(State st)\n{\n\tqueue<State> q;\n\tmp[hash(st)]=0;\n\tq.push(st);\n\twhile(!q.empty())\n\t{\n\t\tState A = q.front();\n\t\tq.pop();\n\t\t//cout << \"koko\" << endl;\n\t\tfor(int i=0;i<5;i++)\n\t\t{\n\t\t\tfor(int j=0;j<5;j++)\n\t\t\t{\n\t\t\t\tif(j<a[i]||b[i]<j)continue;\n\t\t\t\tif(A.f[i][j]!=0)continue;\n\t\t\t\tfor(int k=0;k<4;k++)\n\t\t\t\t{\n\t\t\t\t\tint nx=i+dx[k],ny=j+dy[k];\n\t\t\t\t\tif(nx<0||nx>=5||ny<0||ny>=5)continue;\n\t\t\t\t\tif(ny<a[nx]||b[nx]<ny)continue;\n\t\t\t\t\tif(A.f[nx][ny]==0)continue;\n\t\t\t\t\tState B = A;\n\t\t\t\t\tswap(B.f[nx][ny],B.f[i][j]);\n\t\t\t\t\tB.t++;\n\t\t\t\t\t//cout << \"a\" << endl;\n\t\t\t\t\tif(B.t>8)continue;\n\t\t\t\t\tvector<int> hb = hash(B);\n\t\t\t\t\tif(mp.find(hb)!=mp.end())continue;\n\t\t\t\t\t//cout << hb << endl;\n\t\t\t\t\tmp[hb]=B.t;\n\t\t\t\t\t//cout << B.t << ' ';\n\t\t\t\t\tq.push(B);\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t}\n\t//cout << \"owari\" << endl;\n}\nvoid bfs2(State st)\n{\n\tqueue<State> q;\n\tif(check(st)){ans=0;return;}\n\tq.push(st);\n\twhile(!q.empty())\n\t{\n\t\tState A = q.front();\n\t\tq.pop();\n\t\tvector<int> ha=hash(A); \n\t\tif(mp.find(ha)!=mp.end()){ans = min(ans,A.t+mp[ha]);continue;}\n\t\tfor(int i=0;i<5;i++)\n\t\t{\n\t\t\tfor(int j=0;j<5;j++)\n\t\t\t{\n\t\t\t\tif(j<a[i]||b[i]<j)continue;\n\t\t\t\tif(A.f[i][j]!=0)continue;\n\t\t\t\tfor(int k=0;k<4;k++)\n\t\t\t\t{\n\t\t\t\t\tint nx=i+dx[k],ny=j+dy[k];\n\t\t\t\t\tif(nx<0||nx>=5||ny<0||ny>=5)continue;\n\t\t\t\t\tif(ny<a[nx]||b[nx]<ny)continue;\n\t\t\t\t\tif(A.f[nx][ny]==0)continue;\n\t\t\t\t\tState B = A;\n\t\t\t\t\tswap(B.f[nx][ny],B.f[i][j]);\n\t\t\t\t\tB.t++;\n\t\t\t\t\tif(cc(B))continue;\n\t\t\t\t\tvector<int> hb = hash(B);\n\t\t\t\t\tif(used.find(hb)!=used.end())continue;\n\t\t\t\t\tused.insert(hb);\n\t\t\t\t\tq.push(B);\n\t\t\t\t\t//cout << B.t << endl;\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t}\n}\nint main()\n{\n\tState end;\n\tint cnt=1;\n\tend.t=0;\n\tfor(int i=0;i<5;i++)for(int j=0;j<5;j++)end.f[i][j]=-1;\n\tend.f[0][2]=0;\n\tend.f[4][2]=0;\n\tfor(int i=1;i<=3;i++)for(int j=a[i];j<=b[i];j++)end.f[i][j]=cnt++;\n\t/*for(int i=0;i<5;i++)\n\t{\n\t\tfor(int j=a[i];j<=b[i];j++)cout << end.f[i][j] << ' ';\n\t\tcout << endl;\n\t}*/\n\tbfs(end);\n\twhile(1)\n\t{\n\t\tState st;\n\t\tused.clear();\n\t\tans = 21;\n\t\tfor(int i=0;i<5;i++)for(int j=0;j<5;j++)st.f[i][j]=-1;\n\t\tfor(int i=0;i<5;i++)\n\t\t{\n\t\t\tfor(int j=a[i];j<=b[i];j++)\n\t\t\t{\n\t\t\t\tcin >> st.f[i][j];\n\t\t\t\tif(st.f[i][j]==-1)goto end;\n\t\t\t}\n\t\t}\n\t\tst.t=0;\n\t\tbfs2(st);\n\t\tif(ans>20)printf(\"NA\\n\");\n\t\telse printf(\"%d\\n\",ans);\n\t}\n\tend:;\n\treturn 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include <iostream>\n#include <sstream>\n#include <string>\n#include <algorithm>\n#include <vector>\n#include <stack>\n#include <queue>\n#include <set>\n#include <map>\n#include <cstdio>\n#include <cstdlib>\n#include <cstring>\n#include <cmath>\n\nusing namespace std;\n\n#define FOR(i,k,n) for(int i=(k); i<(int)n; ++i)\n#define REP(i,n) FOR(i,0,n)\n#define FORIT(i,c) for(__typeof((c).begin())i=(c).begin();i!=(c).end();++i)\n\nstruct S{\n  vector<int> p;\n  int t;\n  S(vector<int> p, int t) : p(p),t(t) {}\n};\n\nbool operator<(const S& s, const S& t){\n  return s.t > t.t;\n}\n\nint x[13] = {2,1,2,3,0,1,2,3,4,1,2,3,2};\nint y[13] = {4,3,3,3,2,2,2,2,2,1,1,1,0};\nvector<int> goal(13);\nset<vector<int> > memo;\nint distance(S s){\n  int count = 0;\n  REP(i,13){\n    if(goal[i] != s.p[i]) count++;\n  }\n  return count + s.t;\n}\nvoid print_s(S s){\n  vector<int> v = s.p;\n  printf(\"time:%d\\n\",s.t);\n  printf(\"    %2d    \\n\",v[0]);\n  printf(\"  %2d%2d%2d  \\n\",v[1],v[2],v[3]);\n  printf(\"%2d%2d%2d%2d%2d\\n\",v[4],v[5],v[6],v[7],v[8]);\n  printf(\"  %2d%2d%2d  \\n\",v[9],v[10],v[11]);\n  printf(\"    %2d    \\n\",v[12]);\n}\nint bfs(S start){\n  priority_queue<S> que;\n  que.push(start);\n  while(!que.empty()){\n    S s = que.top(); que.pop();\n    //print_s(s);\n    if(s.t > 20) return -1;\n    if(s.p == goal) return s.t;\n    if(memo.find(s.p)!=memo.end()) continue;\n    memo.insert(s.p);\n    if(distance(s) > 20) continue;\n    REP(i,13){\n      vector<int> tmp = s.p;\n      if(s.p[i]==0){\n        switch(i){\n          case 0:\n          case 2:\n            swap(tmp[0],tmp[2]);\n            que.push(S(tmp,s.t+1));\n            break;\n          case 12:\n          case 10:\n            swap(tmp[12],tmp[10]);\n            que.push(S(tmp,s.t+1));\n            break;\n          case 4:\n          case 5:\n            swap(tmp[4],tmp[5]);\n            que.push(S(tmp,s.t+1));\n            break;\n          case 8:\n          case 7:\n            swap(tmp[8],tmp[7]);\n            que.push(S(tmp,s.t+1));\n            break;\n        }\n        if(i % 4 == 2 || i % 4 == 3){\n          tmp = s.p;\n          swap(tmp[i],tmp[i-1]);\n          que.push(S(tmp,s.t+1));\n        }\n        if(i % 4 == 1 || i % 4 == 2){\n          tmp = s.p;\n          swap(tmp[i],tmp[i+1]);\n          que.push(S(tmp,s.t+1));\n        }\n        if(i % 4 != 0 && i < 8){\n          tmp = s.p;\n          swap(tmp[i],tmp[i+4]);\n          que.push(S(tmp,s.t+1));\n        }\n        if(i % 4 != 0 && i > 4){\n          tmp = s.p;\n          swap(tmp[i],tmp[i-4]);\n          que.push(S(tmp,s.t+1));\n        }\n      }\n    }\n  }\n  return -1;\n}\nint main(){\n  int n;\n  vector<int> p(13);\n\n  REP(i,11) goal[i+1] = i+1;\n\n  while(cin>>p[0], p[0]!=-1){\n    for(int i = 1; i < 13; i++){\n      cin>>p[i];\n    }\n    S start(p,0);\n    memo.clear();\n    int ans = bfs(start);\n    if(ans == -1)cout<<\"NA\"<<endl;\n    else cout<< ans << endl;\n  }\n  return 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include<iostream>\n#include<vector>\n#include<map>\n#include<cstdio>\n#include<deque>\n#include<cmath>\n#include<algorithm>\n#define F first\n#define S second\n#define pb push_back\nusing namespace std;\ntypedef pair<int,int> P;\ntypedef pair<P,P> PP;\ntypedef vector<int> VI;\ntypedef vector<VI> VVI;\ntypedef vector<P> VP;\ntypedef pair<VVI,VP> VVIVP;\n\n\nmap<VVI,int> memo,bidirectional;\nVVI final;\nVP ini;\nint dx[4] = {0,1,0,-1};\nint dy[4] = {1,0,-1,0};\n\nP Fpos[] = {P(0,0),P(1,1),P(2,1),P(3,1),P(0,2),P(1,2),P(2,2),P(3,2),P(4,2),P(1,3),P(2,3),P(3,3)};\n\n\nclass Puzzle\n{\npublic:\n  VVI state;\n  int Manhattan;\n  VP vp;\n\n  Puzzle():Manhattan(0){}\n  Puzzle(VVI s)\n  {\n    vp.clear();\n    state = s;\n    Manhattan_calc(false);\n  }\n\n  void Manhattan_calc(bool b)\n  {\n    Manhattan = 0; \n    for(int i=0;i<5;i++)\n      for(int j=0;j<state[i].size();j++)\n\tif(state[i][j] != 0 && state[i][j] != -1)\n\t  Manhattan += abs(j-Fpos[state[i][j]].F) + abs(i-Fpos[state[i][j]].S);\n\telse if(state[i][j] == 0 && !b)// bがfalseなら初期化\n\t  vp.push_back(P(j,i)); \n  }\n\n  void print()\n  {\n  \n    for(int i=0;i<state.size();i++)\n      {\n\tfor(int j=0;j<state[i].size();j++)\n\t  {\n\t    if(state[i][j] == -1)\n\t      cout << \"  \";\n\t    else \n\t      cout << state[i][j] << \" \";\n\t  }\n\tcout << endl;\n      }\n    cout << endl;\n  }\n};\n\nbool Input(VVI& puzzle)\n{\n  puzzle.clear();\n  puzzle.resize(5);\n  puzzle[0].resize(3),puzzle[1].resize(4),puzzle[2].resize(5),puzzle[3].resize(4),puzzle[4].resize(3);\n  puzzle[0][0] = puzzle[0][1] = puzzle[1][0] = puzzle[3][0] = puzzle[4][0] = puzzle[4][1] = -1;\n \n  scanf(\"%d\",&puzzle[0][2]);\n  if(puzzle[0][2] == -1)\n    return false; \n  scanf(\"%d %d %d\",&puzzle[1][1],&puzzle[1][2],&puzzle[1][3]);\n  scanf(\"%d %d %d %d %d\",&puzzle[2][0],&puzzle[2][1],&puzzle[2][2],&puzzle[2][3],&puzzle[2][4]);\n  scanf(\"%d %d %d\",&puzzle[3][1],&puzzle[3][2],&puzzle[3][3]);\n  scanf(\"%d\",&puzzle[4][2]);\n\t    \n    return true;\n}\n\nvoid print(VVI vvi)\n{\n  cout << \"--- print ---\" << endl;\n  for(int i=0;i<vvi.size();i++)\n    {\n      for(int j=0;j<vvi[i].size();j++)\n\t{\n\t  cout << vvi[i][j] << \" \";\n\t}\n      cout << endl;\n    }\n  cout << endl;\n}\n\nVVI change(VVI vec,P p1,P p11)\n{\n  int tmp = vec[p1.S][p1.F];\n  vec[p1.S][p1.F] = vec[p11.S][p11.F];\n  vec[p11.S][p11.F] = tmp;\n\n  return vec;\n}\n\nvoid Init()\n{\n  final.resize(5);\n  final[0].pb(-1),final[0].pb(-1),final[0].pb(0);\n  final[1].pb(-1),final[1].pb(1),final[1].pb(2),final[1].pb(3);\n  final[2].pb(4),final[2].pb(5),final[2].pb(6),final[2].pb(7),final[2].pb(8);\n  final[3].pb(-1),final[3].pb(9),final[3].pb(10),final[3].pb(11);\n  final[4].pb(-1),final[4].pb(-1),final[4].pb(0);\n\n  Puzzle puz(final); \n  deque<Puzzle> deq;\n  deq.push_back(puz);\n  bidirectional[final] = 0;\n  \n  while(!deq.empty())\n    {\n      Puzzle p = deq.front(); deq.pop_front();\n      int cost = bidirectional[p.state];\n    \n      if(cost >= 9)\n\tcontinue;\n\n      for(int i=0;i<2;i++)\n\t{\n\t  for(int j=0;j<4;j++)\n\t    {\n\t      int nx = p.vp[i].F + dx[j];\n\t      int ny = p.vp[i].S + dy[j];\n\t      if(!(0<=ny && ny<p.state.size() && 0<=nx && nx<p.state[ny].size() && p.state[ny][nx] != -1))\n\t\tcontinue;\n\t      VVI next = change(p.state,p.vp[i],P(nx,ny));\n\t      map<VVI,int>::iterator it = bidirectional.find(next);\n\t      if(it == bidirectional.end() || (it != bidirectional.end() && bidirectional[next] > cost + 1))\n\t\t{\n\t\t  bidirectional[next] = cost + 1;\n\t\t  deq.push_back(Puzzle(next));\n\t\t}\n\n\t    }\n\n\t}      \n\n    }\n  \n  \n}\n\n\nint main()\n{\n  VVI puzzle;\n  Init();\n  //cout << \"here\" << endl;\n  while(Input(puzzle))\n    {\n \n      Puzzle puz(puzzle);\n      int men = (1<<28);\n      deque<Puzzle> deq;\n      deq.push_back(puz);\n      memo.clear();\n      memo[puzzle] = 0;\n\n      while(!deq.empty())\n\t{\n\t  Puzzle p = deq.front(); deq.pop_front();\n\t  int cost = memo[p.state];\n\t  //cout << \"cost : \" << cost << endl;\n\t  //p.print();\n\t  if(cost + p.Manhattan > min(20,men))\n\t    continue;\n\n\t  if(p.state == final)\n\t    {\n\t      men = min(men,cost);\n\t      continue;\n\t    }\n\t  else if(bidirectional.find(p.state) != bidirectional.end() && cost + bidirectional[p.state] <= 20)\n\t    {\n\t      men = min(men,cost+bidirectional[p.state]);\n\t      continue;\n\t    }\n       \n\t  for(int i=0;i<2;i++)\n\t    {\n\t      for(int j=0;j<4;j++)\n\t\t{\n  \n\t\t  int nx = p.vp[i].F + dx[j];\n\t\t  int ny = p.vp[i].S + dy[j];\n\t\t  if(!(0<=ny && ny<p.state.size() && 0<=nx && nx<p.state[ny].size() && p.state[ny][nx] != -1))\n\t\t    continue;\n\n\t\t  VVI next = change(p.state,p.vp[i],P(nx,ny));\n\t\t  map<VVI,int>::iterator it = memo.find(next);\n\t\t  if(it == memo.end() || (it != memo.end() &&  memo[next] > cost + 1) )\n\t\t    {\n\t\t      memo[next] = cost + 1;\n\t\t      deq.push_back(Puzzle(next));\n\t\t    }\n\n\t\t}\n\t    }\n\n\n\t}\n      if(men == (1<<28))\n\tcout << \"NA\" << endl;\n      else \n\tcout << men << endl;\n    }  \n\n    \n  return 0;\n}\n\n\n  /*  \n  deque<VVIVP> deq;\n  VP vec;\n  vec.push_back(P(0,0));\n  vec.push_back(P(0,4)); \n  deq.push_back(VVIVP(final,vec));\n  bidirectional[final] = 0;\n  while(!deq.empty())\n    {\n      VVIVP vvivp = deq.front(); deq.pop_front();\n      VVI vvi = vvivp.F;\n      VP vp = vvivp.S;\n      P p1,p2;\n      int cost = bidirectional[vvi];\n      if(cost >= 5)\n\tcontinue;\n      p1 = vp[0];\n      p2 = vp[1];\n      \n      for(int i=0;i<5;i++)\n\t{\n\t  int nx1 = p1.F + dx[i];\n\t  int ny1 = p1.S + dy[i];\n\n\t  if(!(0 <= ny1 && ny1 < vvi.size() && 0 <= nx1 && nx1 < vvi[ny1].size()))\n\t    continue;\n\n\t  for(int j=0;j<5;j++)\n\t    {\n\t      if(i == 4 && j == 4)\n\t\tcontinue;\n\t      int nx2 = p2.F + dx[j];\n\t      int ny2 = p2.S + dy[j];\n\n\t      if(!(0 <= ny2 && ny2 < vvi.size() && 0 <= nx2 && nx2 < vvi[ny2].size()))\n\t\tcontinue;\n\t      VVI new_vvi = change(vvi,p1,P(nx1,ny1),p2,P(nx2,ny2));\n\t      if(bidirectional.count(new_vvi) == 0 || (bidirectional.count(new_vvi) != 0 && bidirectional[new_vvi] > cost + 1))\n\t\t{\n\t\t  VP vip;\n\t\t  vip.push_back(P(nx1,ny1));\n\t\t  vip.push_back(P(nx2,ny2));\n\t\t  bidirectional[new_vvi] = cost+1;\n\t\t  deq.push_back(VVIVP(new_vvi,vip));\n\t\t}\n\n\t     \n\n\t    }\n\t}\n\n    }\n*/\n\n/*\n int men = (1<<28);\n      deque<VVIVP> deq;\n      bool fin = false;\n      deq.push_back(VVIVP(puzzle,ini));\n      memo[puzzle] = 0;\n      while(!deq.empty() && !fin)\n\t{\n\t  VVIVP vvivp = deq.front(); deq.pop_front();\n\t  VVI vvi = vvivp.F;\n\t  VP vp = vvivp.S;\n\t  P p1,p2;\n\t  p1 = vp[0], p2 = vp[1];\n\t \n\t  if((vvi == final || bidirectional.count(vvi) != 0) && memo[vvi] + bidirectional[vvi] <= min(20,men))\n\t    {\n\t      men = min(men,memo[vvi]+bidirectional[vvi]);\n\t      continue;\n\t    }\n\t  \n\t  int cost = memo[vvi];\n\n\t  if(men <= cost) \n\t    continue;\n\n\t  for(int i=0;i<5;i++)\n\t    {\n\t      int nx1 = p1.F + dx[i];\n\t      int ny1 = p1.S + dy[i];\n\n\t      if(!(0 <= ny1 && ny1 < vvi.size() && 0 <= nx1 && nx1 < vvi[ny1].size()))\n\t\tcontinue;\n\n\t      for(int j=0;j<5;j++)\n\t\t{\n\t\t  if(i = 4 && j == 4)\n\t\t    continue;\n\t\t  int nx2 = p2.F + dx[j];\n\t\t  int ny2 = p2.S + dy[j];\n\t\t  \n\t\t  if(!(0 <= ny2 && ny2 < vvi.size() && 0 <= nx2 && nx2 < vvi[ny2].size()))\n\t\t    continue;\n\n\t\t  //cout << \"change! \" << i << \" - \" << j << endl;\n\n\t\t  //cout <<\"cost = \" << cost << endl;\n\t\t   //print(change(vvi,p1,P(nx1,ny1),p2,P(nx2,ny2)));\n\t\t  VVI new_vvi = change(vvi,p1,P(nx1,ny1),p2,P(nx2,ny2));\n\t\t  if(memo.count(new_vvi) == 0 || (memo.count(new_vvi) != 0 && memo[new_vvi] > cost+1))\n\t\t    {\n\t\t \n\t\t      memo[new_vvi] = cost+1;\n\t\t      VP vip;\n\t\t      vip.push_back(P(nx1,ny1));\n\t\t      vip.push_back(P(nx2,ny2));\n\t\t      deq.push_back(VVIVP(new_vvi,vip));\n\t\t    }\n\n\n\t\t}\n\n\t    }\n\n\t}\n\n      if(men != (1<<28))\n\tcout << men << endl;\n      else \n\tcout << \"NA\" << endl;\n */\n\n\n/*\nwhile(Input(puzzle)){\n      int men = (1<<28);\n      deque<VVIVP> deq;\n      bool fin = false;\n      deq.push_back(VVIVP(puzzle,ini));\n      memo[puzzle] = 0;\n      while(!deq.empty())\n\t{\n\t  VVIVP vvivp = deq.front(); deq.pop_front();\n\t  VVI vvi = vvivp.F;\n\t  VP vp = vvivp.S;\n\t \n\t  if(vvi == final)\n\t    {\n\t      men = min(men,memo[vvi]);\n\t      fin = true;\n\t    }\n\t  else if(bidirectional.count(vvi) != 0 && memo[vvi] + bidirectional[vvi] <= 20)\n\t    {\n\t      fin = true;\n\t      men = min(men,memo[vvi]+bidirectional[vvi]);\n\t      break;\n\t    }\n\t \n\t  int cost = memo[vvi];\n\t  if(cost >= men)\n\t    continue;\n\n\t  //cout << \"cost = \" << cost << endl;\n\t  P p1,p2;\n\t  p1 = vp[0];\n\t  p2 = vp[1];\n\t  for(int k=0;k<5;k++)\n\t    {\n\t      int nx1,ny1;\n\t      nx1 = vp[0].F + dx[k];\n\t      ny1 = vp[0].S + dy[k];\n\t      if(!(0 <= ny1 && vvi.size() > ny1 && 0 <= nx1 && vvi[ny1].size() > nx1))\n\t\tcontinue;\n\n\t      for(int l=0;l<5;l++)\n\t\t{\n\t\t  int nx2,ny2;\n\t\n\t\t  nx2 = vp[1].F + dx[l];\n\t\t  ny2 = vp[1].S + dy[l];\n\n\t\t  if(!(0 <= ny2 && vvi.size() > ny2 && 0 <= nx2 && vvi[ny2].size() > nx2))\n\t\t    continue;\n\t\n\t\n\t\t  int tmp = vvi[p1.S][p1.F];\n\t\t  vvi[p1.S][p1.F] = vvi[ny1][nx1];\n\t\t  vvi[ny1][nx1] = tmp;\n\n\t\t  tmp = vvi[p2.S][p2.F];\n\t\t  vvi[p2.S][p2.F] = vvi[ny2][nx2];\n\t\t  vvi[ny2][nx2] = tmp;\n\t\n\n\t\t  if(cost+1 >= 20 && vvi != final)\n\t\t    continue;\n\n\t\t  if(cost+1 >= 20 && vvi == final)\n\t\t    {\n\t\t      fin = true;\n\t\t      printf(\"20\\n\");\n\t\t      break;\n\t\t    }\n\n\t\t  if((memo.count(vvi) != 0 && memo[vvi] > cost + 1) || memo.count(vvi) == 0)\n\t\t    {\n\t\t      VP vip;\n\t\t      vip.push_back(P(nx1,ny1));\n\t\t      vip.push_back(P(nx2,ny2));\n\t\t      memo[vvi] = cost + 1;\n\t\t      deq.push_back(VVIVP(vvi,vip)); \n\t\t    }\n\n\t\n\t\t  tmp = vvi[p1.S][p1.F];\n\t\t  vvi[p1.S][p1.F] = vvi[ny1][nx1];\n\t\t  vvi[ny1][nx1] = tmp;\n\n\t\t  tmp = vvi[p2.S][p2.F];\n\t\t  vvi[p2.S][p2.F] = vvi[ny2][nx2];\n\t\t  vvi[ny2][nx2] = tmp;\n\t\n\t\t}\n\t      if(fin)\n\t\tbreak;\n\t    }\n\t  if(fin)\n\t    break;\n\t}\n      if(!fin)\n\tprintf(\"NA\\n\");\n      else\n\tprintf(\"%d\\n\",men);\n    }\n\n */"
  },
  {
    "language": "C++",
    "code": "#include <iostream>\n#include <sstream>\n#include <cstdio>\n#include <cstdlib>\n#include <cmath>\n#include <ctime>\n#include <cstring>\n#include <climits>\n#include <algorithm>\n#include <map>\n#include <set>\n#include <stack>\n#include <vector>\n#include <queue>\n#include <bitset>\n#include <string>\nusing namespace std;\n \n#define rep(i,n) for(int i=0; i<n; i++)\n#define repa(i,s,e) for(int i=s; i<=e; i++)\n#define repd(i,s,e) for(int i=s; i>=e; i--)\n#define PB(a) push_back(a)\n#define MP(i,s) make_pair(i,s)\n \ntypedef long long ll;\n\nconst int dx[4] = {-1, 0, 0, 1};\nconst int dy[4] = {0, -1, 1, 0};\nconst int field[5][5] = {\n\t{0, 0, 1, 0, 0}, \n\t{0, 1, 1, 1, 0},\n\t{1, 1, 1, 1, 1},\n\t{0, 1, 1, 1, 0},\n\t{0, 0, 1, 0, 0}, \n};\n\nconst int ans[5][5] = {\n\t{0, 0, 0, 0, 0},\n\t{0, 1, 2, 3, 0},\n\t{4, 5, 6, 7, 8},\n\t{0, 9, 10, 11, 0},\n\t{0, 0, 0, 0, 0}\n};\n\nconst int px[13] = {2, 1, 2, 3, 0, 1, 2, 3, 4, 1, 2, 3, 2};\nconst int py[13] = {0, 1, 1, 1, 2, 2, 2, 2, 2, 3, 3, 3, 4};\n\nint P[5][5];\nmap<ll,int> used;\nmap<ll,int> H;\n\nll hash_val() {\n\tll h = 0;\n\trep(i,13) {\n\t\th *= 13;\n\t\th += P[py[i]][px[i]];\n\t}\n\treturn h;\n}\n\nvoid make_ans(int m, int d) {\n\tll h = hash_val();\n\tif(m == d) return;\n\tmap<ll,int>::iterator it = H.find(h);\n\t\n\tif(it == H.end()) {\n\t\tH.insert(MP(h,m));\n\t} else if((*it).second > m) {\n\t\t(*it).second = m;\n\t} else {\n\t\treturn;\n\t}\n\n\trep(i,13) {\n\t\tint x = px[i];\n\t\tint y = py[i];\n\t\tif(P[y][x] == 0) {\n\t\t\trep(k,4) {\n\t\t\t\tint xx = x + dx[k];\n\t\t\t\tint yy = y + dy[k];\n\t\t\t\tif(xx>=0 && yy>=0 && xx<5 && yy<5 && field[yy][xx] == 1 && P[yy][xx] != 0) {\n\t\t\t\t\tswap(P[y][x], P[yy][xx]);\n\t\t\t\t\tmake_ans(m+1, d);\n\t\t\t\t\tswap(P[y][x], P[yy][xx]);\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t}\n}\n\nint dfs(int m, int d) {\n\tmap<ll,int>::iterator it;\n\tll h = hash_val();\n\n\tit = H.find(h);\n\tif(it != H.end()) return m + (*it).second;\n\n\tif(m == d) return -1;\n\t\n\tit = used.find(h);\n\tif(it == used.end()) {\n\t\tused.insert(MP(h,m));\n\t} else if((*it).second > m) {\n\t\t(*it).second = m;\n\t} else {\n\t\treturn -1;\n\t}\n\n\trep(i,13) {\n\t\tint x = px[i];\n\t\tint y = py[i];\n\t\tif(P[y][x] == 0) {\n\t\t\trep(k,4) {\n\t\t\t\tint xx = x + dx[k];\n\t\t\t\tint yy = y + dy[k];\n\t\t\t\tif(xx>=0 && yy>=0 && xx<5 && yy<5 && field[yy][xx] == 1 && P[yy][xx] != 0) {\n\t\t\t\t\tswap(P[y][x], P[yy][xx]);\n\t\t\t\t\tint a = dfs(m+1, d);\n\t\t\t\t\tif(a >= 0) return a;\n\t\t\t\t\tswap(P[y][x], P[yy][xx]);\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t}\n\treturn -1;\n}\n\nvoid solve() {\n\trepa(d,0,10) {\n\t\tused.clear();\n\t\tint a = dfs(0, d);\n\t\tif(a >= 0 && a <= 20) {\n\t\t\tprintf(\"%d\\n\", a);\n\t\t\treturn;\n\t\t}\n\t}\n\tprintf(\"NA\\n\");\n}\n\nint main() {\n\tmemcpy(P, ans, sizeof(P));\n\tmake_ans(0, 10);\n\tfor(;;) {\n\t\trep(i,13) {\n\t\t\tscanf(\"%d\", &P[py[i]][px[i]]);\n\t\t\tif(P[py[i]][px[i]] < 0) return 0;\n\t\t}\n\t\tsolve();\n\t}\n}"
  },
  {
    "language": "C++",
    "code": "#include <iostream>\n#include <cstdio>\n#include <cstring>\n#include <algorithm>\n#include <vector>\n#include <queue>\n#include <map>\nusing namespace std;\n\ntypedef vector<int> VI;\n\nint size[13] = {1, 2, 4, 2, 1, 4, 4, 4, 1, 2, 4, 2, 1};\nint move[13][4] = {\n  {2},\n  {2, 5},\n  {0, 1, 6, 3},\n  {2, 7},\n  {5},\n  {1, 4, 6, 9},\n  {2, 5, 7, 10},\n  {3, 6, 8, 11},\n  {7},\n  {5, 10},\n  {6, 9, 11, 12},\n  {7, 10},\n  {10}\n};\n\nVI v;\nmap<VI, int> mp;\nmap<VI, int> mp2;\n\nvoid make(){\n  VI goal;\n  for(int i = 0 ; i < 13 ; i++){\n    if(i == 0 || i == 12) goal.push_back(0);\n    else goal.push_back(i);    \n  }\n  \n  queue<VI> que;\n  que.push(goal);\n  mp2[goal] = 0;\n  \n  while(!que.empty()){\n    VI q = que.front(); que.pop();    \n    if(mp2[q] > 13) continue;\n    for(int i = 0 ; i < 13 ; i++){\n      if(q[i] != 0) continue;\n      for(int j = 0 ; j < size[i] ; j++){\n\tVI t = q;\n\tswap(t[i], t[ move[i][j] ]);\n\tif(mp2.find(t) != mp2.end()) continue;\t\n\tmp2[t] = mp2[q] + 1;\t\n\tque.push(t);\n      }\n    }\n  }\n}\n    \n\n\nint bfs(){\n  queue<VI> que;\n  que.push(v);\n  mp[v] = 0;  \n  while(!que.empty()){\n    VI q = que.front(); que.pop();    \n    if(mp2.find(q) != mp2.end()){\n      return mp2[q] + mp[q];\n    }\n    \n    if(mp[q] > 8) continue;\n    for(int i = 0 ; i < 13 ; i++){\n      if(q[i] != 0) continue;      \n      for(int j = 0 ; j < size[i] ; j++){\n\tVI t = q;\n\tswap(t[i], t[ move[i][j] ]);\n\tif(mp.find(t) != mp.end()) continue;\n\tmp[t] = mp[q] + 1;\n\tque.push(t);\n      }\n    }\n  }\n  return -1;\n}\n\nvoid init(){\n  v.clear();\n  mp.clear();  \n}\n\nint main(){\n  make();\n  int n;\n  while(cin >> n){\n    if(n == -1) break;\n    \n    init();\n    \n    v.push_back(n);\n    for(int i = 0 ; i < 12 ; i++){ cin >> n; v.push_back(n); }\n    \n    int ans = bfs();\n    if(ans == -1 || ans > 20) cout << \"NA\" << endl;\n    else cout << ans << endl;\n  }\n  \n\n  return 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include<iostream>\n#include<queue>\n#include<map>\n#include<cstring>\nusing namespace std;\n\nstruct puz{\n\tint a[5][5];\n\tint tim;\n};\n\nmap<string,bool> memo;\nqueue<struct puz> que;\nstruct puz def;\nstruct puz tmp;\nstring z;\n\nvoid erase(){\n\tfor(int i=0; i<5; i++)\n\t\tfor(int k=0; k<5; k++)\n\t\t\tdef.a[i][k] = 20;\n\tdef.tim = 0;\n\twhile(!que.empty())\n\t\tque.pop();\n\tmemo.clear();\n}\n\nbool clear(){\n\tfor(int i=1; i<4; i++)\n\t\tif(def.a[1][i] != i || def.a[3][i] != i+8)\n\t\t\treturn false;\n\tfor(int i=0; i<5; i++){\n\t\tif(def.a[2][i] != i+4)\n\t\t\treturn false;\n\t}\n\treturn true;\n}\n\nvoid int2str(){\n\tz.erase();\n\tfor(int i=0; i<5; i++){\n\t\tfor(int k=0; k<5; k++){\n\t\t\tchar t[2];\n\t\t\tt[0] = (char)(def.a[i][k]+48);\n\t\t\tt[1] = '\\0';\n\t\t\tz.append(t);\n\t\t}\n\t}\n}\n\nvoid solve(){\n\tque.push(def);\n\twhile(true){\n\t\tif(que.empty()){\n\t\t\tcout << \"NA\" << endl;\n\t\t\tbreak;\n\t\t}\n\t\tdef = que.front();\n\t\tque.pop();\n\t\t\n\t\tif(def.tim > 20){\n\t\t\tcout << \"NA\" << endl;\n\t\t\tbreak;\n\t\t}\n\n\t\tint2str();\n\n\t\tif(memo[z])\n\t\t\tcontinue;\n\t\telse\n\t\t\tmemo[z] = true;\n\n\t\tif(clear()){\n\t\t\tcout << def.tim << endl;\n\t\t\tbreak;\n\t\t}\n\n\t\ttmp = def;\n\t\tfor(int i=0; i<5; i++){\n\t\t\tfor(int k=0; k<5; k++){\n\t\t\t\tif(def.a[i][k] == 0){\n\t\t\t\t\tif(i != 0){\n\t\t\t\t\t\tif(tmp.a[i-1][k] != 20){\n\t\t\t\t\t\t\ttmp.a[i-1][k] = 0;\n\t\t\t\t\t\t\ttmp.a[i][k] = def.a[i-1][k];\n\t\t\t\t\t\t\ttmp.tim = def.tim+1;\n\t\t\t\t\t\t\tque.push(tmp);\n\t\t\t\t\t\t\ttmp = def;\n\t\t\t\t\t\t}\n\t\t\t\t\t}\n\t\t\t\t\tif(i != 4){\n\t\t\t\t\t\tif(tmp.a[i+1][k] != 20){\n\t\t\t\t\t\t\ttmp.a[i+1][k] = 0;\n\t\t\t\t\t\t\ttmp.a[i][k] = def.a[i+1][k];\n\t\t\t\t\t\t\ttmp.tim = def.tim+1;\n\t\t\t\t\t\t\tque.push(tmp);\n\t\t\t\t\t\t\ttmp = def;\n\t\t\t\t\t\t}\n\t\t\t\t\t}\n\t\t\t\t\tif(k != 0){\n\t\t\t\t\t\tif(tmp.a[i][k-1] != 20){\n\t\t\t\t\t\t\ttmp.a[i][k-1] = 0;\n\t\t\t\t\t\t\ttmp.a[i][k] = def.a[i][k-1];\n\t\t\t\t\t\t\ttmp.tim = def.tim+1;\n\t\t\t\t\t\t\tque.push(tmp);\n\t\t\t\t\t\t\ttmp = def;\n\t\t\t\t\t\t}\n\t\t\t\t\t}\n\t\t\t\t\tif(k != 4){\n\t\t\t\t\t\tif(tmp.a[i][k+1] != 20){\n\t\t\t\t\t\t\ttmp.a[i][k+1] = 0;\n\t\t\t\t\t\t\ttmp.a[i][k] = def.a[i][k+1];\n\t\t\t\t\t\t\ttmp.tim = def.tim+1;\n\t\t\t\t\t\t\tque.push(tmp);\n\t\t\t\t\t\t\ttmp = def;\n\t\t\t\t\t\t}\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t\t\n\t}\n}\n\nint main(){\n\twhile(true){\n\t\terase();\n\t\tcin >> def.a[0][2];\n\t\tif(!(def.a[0][2]+1))\n\t\t\treturn 0;\n\t\tcin >> def.a[1][1];\n\t\tcin >> def.a[1][2];\n\t\tcin >> def.a[1][3];\n\t\tcin >> def.a[2][0];\n\t\tcin >> def.a[2][1];\n\t\tcin >> def.a[2][2];\n\t\tcin >> def.a[2][3];\n\t\tcin >> def.a[2][4];\n\t\tcin >> def.a[3][1];\n\t\tcin >> def.a[3][2];\n\t\tcin >> def.a[3][3];\n\t\tcin >> def.a[4][2];\n\t\tsolve();\n\t}\n}"
  },
  {
    "language": "C++",
    "code": "#include <iostream>\n#include <sstream>\n#include <cstdio>\n#include <cstdlib>\n#include <cmath>\n#include <ctime>\n#include <cstring>\n#include <climits>\n#include <algorithm>\n#include <map>\n#include <set>\n#include <stack>\n#include <vector>\n#include <queue>\n#include <bitset>\n#include <string>\nusing namespace std;\n \n#define rep(i,n) for(int i=0; i<n; i++)\n#define repa(i,s,e) for(int i=s; i<=e; i++)\n#define repd(i,s,e) for(int i=s; i>=e; i--)\n#define PB(a) push_back(a)\n#define MP(i,s) make_pair(i,s)\n \ntypedef long long ll;\n\nconst int dx[4] = {-1, 0, 0, 1};\nconst int dy[4] = {0, -1, 1, 0};\nconst int field[5][5] = {\n\t{0, 0, 1, 0, 0}, \n\t{0, 1, 1, 1, 0},\n\t{1, 1, 1, 1, 1},\n\t{0, 1, 1, 1, 0},\n\t{0, 0, 1, 0, 0}, \n};\n\nconst int ans[5][5] = {\n\t{0, 0, 0, 0, 0},\n\t{0, 1, 2, 3, 0},\n\t{4, 5, 6, 7, 8},\n\t{0, 9, 10, 11, 0},\n\t{0, 0, 0, 0, 0}\n};\n\nconst int px[13] = {2, 1, 2, 3, 0, 1, 2, 3, 4, 1, 2, 3, 2};\nconst int py[13] = {0, 1, 1, 1, 2, 2, 2, 2, 2, 3, 3, 3, 4};\n\nint P[5][5];\nmap<ll,int> used;\nmap<ll,int> H;\n\nll hash_val() {\n\tll h = 0;\n\trep(i,13) {\n\t\th *= 13;\n\t\th += P[py[i]][px[i]];\n\t}\n\treturn h;\n}\n\nvoid make_ans(int m, int d) {\n\tll h = hash_val();\n\tif(m == d) return;\n\tmap<ll,int>::iterator it = H.find(h);\n\t\n\tif(it == H.end()) {\n\t\tused.insert(MP(h,m));\n\t} else if((*it).second > m) {\n\t\t(*it).second = m;\n\t} else {\n\t\treturn;\n\t}\n\n\tH.insert(MP(h,m));\n\trep(i,13) {\n\t\tint x = px[i];\n\t\tint y = py[i];\n\t\tif(P[y][x] == 0) {\n\t\t\trep(k,4) {\n\t\t\t\tint xx = x + dx[k];\n\t\t\t\tint yy = y + dy[k];\n\t\t\t\tif(xx>=0 && yy>=0 && xx<5 && yy<5 && field[yy][xx] == 1 && P[yy][xx] != 0) {\n\t\t\t\t\tswap(P[y][x], P[yy][xx]);\n\t\t\t\t\tmake_ans(m+1, d);\n\t\t\t\t\tswap(P[y][x], P[yy][xx]);\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t}\n}\n\nint dfs(int m, int d) {\n\tmap<ll,int>::iterator it;\n\tll h = hash_val();\n\n\tit = H.find(h);\n\tif(it != H.end()) return m + (*it).second;\n\n\tif(m == d) return -1;\n\t\n\tit = used.find(h);\n\tif(it == used.end()) {\n\t\tused.insert(MP(h,m));\n\t} else if((*it).second > m) {\n\t\t(*it).second = m;\n\t} else {\n\t\treturn -1;\n\t}\n\n\trep(i,13) {\n\t\tint x = px[i];\n\t\tint y = py[i];\n\t\tif(P[y][x] == 0) {\n\t\t\trep(k,4) {\n\t\t\t\tint xx = x + dx[k];\n\t\t\t\tint yy = y + dy[k];\n\t\t\t\tif(xx>=0 && yy>=0 && xx<5 && yy<5 && field[yy][xx] == 1 && P[yy][xx] != 0) {\n\t\t\t\t\tswap(P[y][x], P[yy][xx]);\n\t\t\t\t\tint a = dfs(m+1, d);\n\t\t\t\t\tif(a >= 0) return a;\n\t\t\t\t\tswap(P[y][x], P[yy][xx]);\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t}\n\treturn -1;\n}\n\nvoid solve() {\n\trepa(d,0,10) {\n\t\tused.clear();\n\t\tint a = dfs(0, d);\n\t\tif(a >= 0) {\n\t\t\tprintf(\"%d\\n\", a);\n\t\t\treturn;\n\t\t}\n\t}\n\tprintf(\"NA\\n\");\n}\n\nint main() {\n\tmemcpy(P, ans, sizeof(P));\n\tmake_ans(0, 10);\n\tfor(;;) {\n\t\trep(i,13) {\n\t\t\tscanf(\"%d\", &P[py[i]][px[i]]);\n\t\t\tif(P[py[i]][px[i]] < 0) return 0;\n\t\t}\n\t\tsolve();\n\t}\n}"
  },
  {
    "language": "C++",
    "code": "#include<bits/stdc++.h>\nusing namespace std;\n\n//#define int long long\n\ntypedef pair<int,int>pint;\ntypedef vector<int>vint;\ntypedef vector<pint>vpint;\ntypedef vector<vint>vvint;\n#define pb push_back\n#define mp make_pair\n#define fi first\n#define se second\n#define all(v) (v).begin(),(v).end()\n#define rep(i,n) for(int i=0;i<(n);i++)\n#define reps(i,f,n) for(int i=(f);i<(n);i++)\n#define each(it,v) for(__typeof((v).begin()) it=(v).begin();it!=(v).end();it++)\ntemplate<class T,class U>void chmin(T &t,U f){if(t>f)t=f;}\ntemplate<class T,class U>void chmax(T &t,U f){if(t<f)t=f;}\n\nconst int dy[]={-1,0,1,0};\nconst int dx[]={0,-1,0,1};\n\nint p[5][5]={{-1,-1,0,-1,-1},{-1,1,2,3,-1},{4,5,6,7,8},{-1,9,10,11,-1},{-1,-1,0,-1,-1}};\nvoid bfs(vvint &a,map<vvint,int>&s){\n    queue<vvint>que[2];\n    que[0].push(a);\n    s[a]=0;\n    rep(i,10){\n        while(que[i&1].size()){\n            vvint a=que[i&1].front();\n            que[i&1].pop();\n            rep(y,5)rep(x,5){\n                if(a[y][x]!=0)continue;\n                rep(d,4){\n                    int ny=y+dy[d],nx=x+dx[d];\n                    if(ny<0||ny>=5||nx<0||nx>=5||a[ny][nx]<=0)continue;\n                    swap(a[ny][nx],a[y][x]);\n                    if(s.find(a)==s.end()){\n                        s[a]=i+1;\n                        que[(i+1)&1].push(a);\n                    }\n                    swap(a[ny][nx],a[y][x]);\n                }\n            }\n        }\n    }\n}\n\nsigned main(){\n    vvint a(5,vint(5,-1));\n    while(cin>>a[0][2],a[0][2]!=-1){\n        rep(i,3)cin>>a[1][i+1];\n        rep(i,5)cin>>a[2][i];\n        rep(i,3)cin>>a[3][i+1];\n        cin>>a[4][2];\n\n        vvint b(5,vint(5));\n        rep(i,5)rep(j,5)b[i][j]=p[i][j];\n\n        map<vvint,int>m1,m2;\n        bfs(a,m1);\n        bfs(b,m2);\n\n        int ans=21;\n        each(it,m1){\n            if(m2.find(it->fi)==m2.end())continue;\n            chmin(ans,it->se+m2[it->fi]);\n        }\n        if(ans<=20)cout<<ans<<endl;\n        else cout<<\"NA\"<<endl;\n    }\n    return 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\n\nusing namespace std;\n\n#define int long long\n#define FR first\n#define SC second\n#define all(v) (v).begin(), (v).end()\n#define rep(i, n) for(int i = 0; i < (int)(n); i++)\n#define reps(i, f, n) for(int i = (int)(f); i < (int)(n); i++)\n#define each(a, b) for(auto& a : b)\n\ntypedef pair<int, int> P;\n\nconst int inf = 1LL << 55;\n\nvector< vector<int> > to = {\n  {2},\n  {2, 5},\n  {0, 1, 3, 6},\n  {2, 7},\n  {5},\n  {1, 4, 6, 9},\n  {2, 5, 7, 10},\n  {3, 6, 8, 11},\n  {7},\n  {5, 10},\n  {6, 9, 11, 12},\n  {7, 10},\n  {10}\n};\n\nvector<int> ans = {0,1,2,3,4,5,6,7,8,9,10,11,0};\n\nsigned main()\n{\n  cin.tie(0);\n  ios_base::sync_with_stdio(0);\n  cout << fixed << setprecision(12);\n\n  map<vector<int>, int> D;  \n  queue< vector<int> > que;\n  que.push(ans);\n  D[ans] = 0;\n  while(!que.empty()) {\n    auto v = que.front(); que.pop();\n    if(D[v] >= 10) break;\n    rep(i, v.size()) {\n      if(v[i]) continue;\n      rep(j, to[i].size()) {\n\tint c = D[v];\n\tswap(v[i], v[to[i][j]]);\n\tif(!D.count(v)) {\n\t  que.push(v);\n\t  D[v] = c + 1;\n\t}\n\tswap(v[i], v[to[i][j]]);\n      }\n    }\n  }\n  \n  int p;\n  while(cin >> p, ~p) {\n    vector<int> pzl; pzl.push_back(p);\n    rep(i, 12) cin >> p, pzl.push_back(p);\n    if(D.count(pzl)) {\n      cout << D[pzl] << endl;\n      continue;\n    }\n    map<vector<int>, int> d;\n    queue< vector<int> > que;\n    que.push(pzl);\n    d[pzl] = 0;\n    bool flag = false;\n    while(!que.empty() && !flag) {\n      auto v = que.front(); que.pop();\n      if(d[v] >= 10) break;      \n      rep(i, v.size()) {\n\tif(v[i]) continue;\n\trep(j, to[i].size()) {\n\t  int c = d[v];\n\t  swap(v[i], v[to[i][j]]);\n\t  if(D.count(v)) {\n\t    cout << D[v] + c + 1 << endl;\n\t    flag = true;\n\t    break;\n\t  } else if(!d.count(v)) {\n\t    que.push(v);\n\t    d[v] = c + 1;\n\t  }\n\t  swap(v[i], v[to[i][j]]);\n\t}\n\tif(flag) break;\n      }\n    }\n    if(!flag) cout << \"NA\" << endl;\n  }\n  return 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include <iostream>\n#include <cstdio>\n#include <cstring>\n#include <algorithm>\n#include <vector>\n#include <queue>\n#include <map>\nusing namespace std;\n\ntypedef vector<int> VI;\n\nint size[13] = {1, 2, 4, 2, 1, 4, 4, 4, 1, 2, 4, 2, 1};\nint move[13][4] = {\n  {2},\n  {2, 5},\n  {0, 1, 6, 3},\n  {2, 7},\n  {5},\n  {1, 4, 6, 9},\n  {2, 5, 7, 10},\n  {3, 6, 8, 11},\n  {7},\n  {5, 10},\n  {6, 9, 11, 12},\n  {7, 10},\n  {10}\n};\n\nVI v;\nmap<VI, int> mp;\nmap<VI, int> mp2;\n\nvoid make(){\n  VI goal;\n  for(int i = 0 ; i < 13 ; i++){\n    if(i == 0 || i == 12) goal.push_back(0);\n    else goal.push_back(i);    \n  }\n  \n  queue<VI> que;\n  que.push(goal);\n  mp2[goal] = 0;\n  \n  while(!que.empty()){\n    VI q = que.front(); que.pop();    \n    if(mp2[q] > 12) continue;\n    for(int i = 0 ; i < 13 ; i++){\n      if(q[i] != 0) continue;\n      for(int j = 0 ; j < size[i] ; j++){\n\tVI t = q;\n\tswap(t[i], t[ move[i][j] ]);\n\tif(mp2.find(t) != mp2.end()) continue;\t\n\tmp2[t] = mp2[q] + 1;\t\n\tque.push(t);\n      }\n    }\n  }\n}\n    \n\n\nint bfs(){\n  queue<VI> que;\n  que.push(v);\n  mp[v] = 0;  \n  while(!que.empty()){\n    VI q = que.front(); que.pop();    \n    if(mp2.find(q) != mp2.end()){\n      return mp2[q] + mp[q];\n    }\n    \n    if(mp[q] > 9) continue;\n    for(int i = 0 ; i < 13 ; i++){\n      if(q[i] != 0) continue;      \n      for(int j = 0 ; j < size[i] ; j++){\n\tVI t = q;\n\tswap(t[i], t[ move[i][j] ]);\n\tif(mp.find(t) != mp.end()) continue;\n\tmp[t] = mp[q] + 1;\n\tque.push(t);\n      }\n    }\n  }\n  return -1;\n}\n\nvoid init(){\n  v.clear();\n  mp.clear();  \n}\n\nint main(){\n  make();\n  int n;\n  while(cin >> n){\n    if(n == -1) break;\n    \n    init();\n    \n    v.push_back(n);\n    for(int i = 0 ; i < 12 ; i++){ cin >> n; v.push_back(n); }\n    \n    int ans = bfs();\n    if(ans == -1 || ans > 20) cout << \"NA\" << endl;\n    else cout << ans << endl;\n  }\n  \n\n  return 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include<iostream>\n#include<vector>\n#include<map>\n#include<cstdio>\n#include<deque>\n#include<cmath>\n#include<algorithm>\n#define F first\n#define S second\n#define pb push_back\nusing namespace std;\ntypedef pair<int,int> P;\ntypedef pair<P,P> PP;\ntypedef vector<int> VI;\ntypedef vector<VI> VVI;\ntypedef vector<P> VP;\ntypedef pair<VVI,VP> VVIVP;\n \n \nmap<VVI,int> memo,bidirectional;\nVVI final;\nVP ini;\nint dx[4] = {0,1,0,-1};\nint dy[4] = {1,0,-1,0};\n \nP Fpos[] = {P(0,0),P(1,1),P(2,1),P(3,1),P(0,2),P(1,2),P(2,2),P(3,2),P(4,2),P(1,3),P(2,3),P(3,3)};\n \n \nclass Puzzle\n{\npublic:\n  VVI state;\n  int Manhattan;\n  VP vp;\n \n  Puzzle():Manhattan(0){}\n  Puzzle(VVI s)\n  {\n    vp.clear();\n    state = s;\n    Manhattan_calc(false);\n  }\n \n  void Manhattan_calc(bool b)\n  {\n    Manhattan = 0; \n    for(int i=0;i<5;i++)\n      for(int j=0;j<state[i].size();j++)\n    if(state[i][j] != 0 && state[i][j] != -1)\n      Manhattan += abs(j-Fpos[state[i][j]].F) + abs(i-Fpos[state[i][j]].S);\n    else if(state[i][j] == 0 && !b)// bがfalseなら初期化\n      vp.push_back(P(j,i)); \n  }\n \n  void print()\n  {\n   \n    for(int i=0;i<state.size();i++)\n      {\n    for(int j=0;j<state[i].size();j++)\n      {\n        if(state[i][j] == -1)\n          cout << \"  \";\n        else\n          cout << state[i][j] << \" \";\n      }\n    cout << endl;\n      }\n    cout << endl;\n  }\n};\n \nbool Input(VVI& puzzle)\n{\n  puzzle.clear();\n  puzzle.resize(5);\n  puzzle[0].resize(3),puzzle[1].resize(4),puzzle[2].resize(5),puzzle[3].resize(4),puzzle[4].resize(3);\n  puzzle[0][0] = puzzle[0][1] = puzzle[1][0] = puzzle[3][0] = puzzle[4][0] = puzzle[4][1] = -1;\n  \n  scanf(\"%d\",&puzzle[0][2]);\n  if(puzzle[0][2] == -1)\n    return false; \n  scanf(\"%d %d %d\",&puzzle[1][1],&puzzle[1][2],&puzzle[1][3]);\n  scanf(\"%d %d %d %d %d\",&puzzle[2][0],&puzzle[2][1],&puzzle[2][2],&puzzle[2][3],&puzzle[2][4]);\n  scanf(\"%d %d %d\",&puzzle[3][1],&puzzle[3][2],&puzzle[3][3]);\n  scanf(\"%d\",&puzzle[4][2]);\n         \n    return true;\n}\n \nvoid print(VVI vvi)\n{\n  cout << \"--- print ---\" << endl;\n  for(int i=0;i<vvi.size();i++)\n    {\n      for(int j=0;j<vvi[i].size();j++)\n    {\n      cout << vvi[i][j] << \" \";\n    }\n      cout << endl;\n    }\n  cout << endl;\n}\n \nVVI change(VVI vec,P p1,P p11)\n{\n  int tmp = vec[p1.S][p1.F];\n  vec[p1.S][p1.F] = vec[p11.S][p11.F];\n  vec[p11.S][p11.F] = tmp;\n \n  return vec;\n}\n \nvoid Init()\n{\n  final.resize(5);\n  final[0].pb(-1),final[0].pb(-1),final[0].pb(0);\n  final[1].pb(-1),final[1].pb(1),final[1].pb(2),final[1].pb(3);\n  final[2].pb(4),final[2].pb(5),final[2].pb(6),final[2].pb(7),final[2].pb(8);\n  final[3].pb(-1),final[3].pb(9),final[3].pb(10),final[3].pb(11);\n  final[4].pb(-1),final[4].pb(-1),final[4].pb(0);\n \n  Puzzle puz(final); \n  deque<Puzzle> deq;\n  deq.push_back(puz);\n  bidirectional[final] = 0;\n   \n  while(!deq.empty())\n    {\n      Puzzle p = deq.front(); deq.pop_front();\n      int cost = bidirectional[p.state];\n     \n      if(cost >= 8)\n    continue;\n \n      for(int i=0;i<2;i++)\n    {\n      for(int j=0;j<4;j++)\n        {\n          int nx = p.vp[i].F + dx[j];\n          int ny = p.vp[i].S + dy[j];\n          if(!(0<=ny && ny<p.state.size() && 0<=nx && nx<p.state[ny].size() && p.state[ny][nx] != -1))\n        continue;\n          VVI next = change(p.state,p.vp[i],P(nx,ny));\n          map<VVI,int>::iterator it = bidirectional.find(next);\n          if(it == bidirectional.end() || (it != bidirectional.end() && bidirectional[next] > cost + 1))\n        {\n          bidirectional[next] = cost + 1;\n          deq.push_back(Puzzle(next));\n        }\n \n        }\n \n    }      \n \n    }\n   \n   \n}\n \n \nint main()\n{\n  VVI puzzle;\n  Init();\n  //cout << \"here\" << endl;\n  while(Input(puzzle))\n    {\n  \n      Puzzle puz(puzzle);\n      int men = (1<<28);\n      deque<Puzzle> deq;\n      deq.push_back(puz);\n      memo.clear();\n      memo[puzzle] = 0;\n \n      while(!deq.empty())\n    {\n      Puzzle p = deq.front(); deq.pop_front();\n      int cost = memo[p.state];\n      //cout << \"cost : \" << cost << endl;\n      //p.print();\n      if(cost + p.Manhattan > min(20,men))\n        continue;\n \n      if(p.state == final)\n        {\n          men = min(men,cost);\n          continue;\n        }\n      else if(bidirectional.find(p.state) != bidirectional.end() && cost + bidirectional[p.state] <= 20)\n        {\n          men = min(men,cost+bidirectional[p.state]);\n          continue;\n        }\n        \n      for(int i=0;i<2;i++)\n        {\n          for(int j=0;j<4;j++)\n        {\n   \n          int nx = p.vp[i].F + dx[j];\n          int ny = p.vp[i].S + dy[j];\n          if(!(0<=ny && ny<p.state.size() && 0<=nx && nx<p.state[ny].size() && p.state[ny][nx] != -1))\n            continue;\n \n          VVI next = change(p.state,p.vp[i],P(nx,ny));\n          map<VVI,int>::iterator it = memo.find(next);\n          if(it == memo.end() || (it != memo.end() &&  memo[next] > cost + 1) )\n            {\n              memo[next] = cost + 1;\n              deq.push_back(Puzzle(next));\n            }\n \n        }\n        }\n \n \n    }\n      if(men == (1<<28))\n    cout << \"NA\" << endl;\n      else\n    cout << men << endl;\n    }  \n \n     \n  return 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include<iostream>\n#include<vector>\n#include<map>\n#include<cstdio>\n#include<deque>\n#include<cmath>\n#include<algorithm>\n#define F first\n#define S second\n#define pb push_back\nusing namespace std;\ntypedef pair<int,int> P;\ntypedef pair<P,P> PP;\ntypedef vector<int> VI;\ntypedef vector<VI> VVI;\ntypedef vector<P> VP;\ntypedef pair<VVI,VP> VVIVP;\n\n\nmap<VVI,int> memo,bidirectional;\nVVI final;\nVP ini;\nint dx[4] = {0,1,0,-1};\nint dy[4] = {1,0,-1,0};\n\nP Fpos[] = {P(0,0),P(1,1),P(2,1),P(3,1),P(0,2),P(1,2),P(2,2),P(3,2),P(4,2),P(1,3),P(2,3),P(3,3)};\n\n\nclass Puzzle\n{\npublic:\n  VVI state;\n  int Manhattan;\n  VP vp;\n\n  Puzzle():Manhattan(0){}\n  Puzzle(VVI s)\n  {\n    vp.clear();\n    state = s;\n    Manhattan_calc(false);\n  }\n\n  void Manhattan_calc(bool b)\n  {\n    Manhattan = 0; \n    for(int i=0;i<5;i++)\n      for(int j=0;j<state[i].size();j++)\n\tif(state[i][j] != 0 && state[i][j] != -1)\n\t  Manhattan += abs(j-Fpos[state[i][j]].F) + abs(i-Fpos[state[i][j]].S);\n\telse if(state[i][j] == 0 && !b)// bがfalseなら初期化\n\t  vp.push_back(P(j,i)); \n  }\n\n  void print()\n  {\n  \n    for(int i=0;i<state.size();i++)\n      {\n\tfor(int j=0;j<state[i].size();j++)\n\t  {\n\t    if(state[i][j] == -1)\n\t      cout << \"  \";\n\t    else \n\t      cout << state[i][j] << \" \";\n\t  }\n\tcout << endl;\n      }\n    cout << endl;\n  }\n};\n\nbool Input(VVI& puzzle)\n{\n  puzzle.clear();\n  puzzle.resize(5);\n  puzzle[0].resize(3),puzzle[1].resize(4),puzzle[2].resize(5),puzzle[3].resize(4),puzzle[4].resize(3);\n  puzzle[0][0] = puzzle[0][1] = puzzle[1][0] = puzzle[3][0] = puzzle[4][0] = puzzle[4][1] = -1;\n \n  scanf(\"%d\",&puzzle[0][2]);\n  if(puzzle[0][2] == -1)\n    return false; \n  scanf(\"%d %d %d\",&puzzle[1][1],&puzzle[1][2],&puzzle[1][3]);\n  scanf(\"%d %d %d %d %d\",&puzzle[2][0],&puzzle[2][1],&puzzle[2][2],&puzzle[2][3],&puzzle[2][4]);\n  scanf(\"%d %d %d\",&puzzle[3][1],&puzzle[3][2],&puzzle[3][3]);\n  scanf(\"%d\",&puzzle[4][2]);\n\t    \n    return true;\n}\n\nvoid print(VVI vvi)\n{\n  cout << \"--- print ---\" << endl;\n  for(int i=0;i<vvi.size();i++)\n    {\n      for(int j=0;j<vvi[i].size();j++)\n\t{\n\t  cout << vvi[i][j] << \" \";\n\t}\n      cout << endl;\n    }\n  cout << endl;\n}\n\nVVI change(VVI vec,P p1,P p11)\n{\n  int tmp = vec[p1.S][p1.F];\n  vec[p1.S][p1.F] = vec[p11.S][p11.F];\n  vec[p11.S][p11.F] = tmp;\n\n  return vec;\n}\n\nvoid Init()\n{\n  final.resize(5);\n  final[0].pb(-1),final[0].pb(-1),final[0].pb(0);\n  final[1].pb(-1),final[1].pb(1),final[1].pb(2),final[1].pb(3);\n  final[2].pb(4),final[2].pb(5),final[2].pb(6),final[2].pb(7),final[2].pb(8);\n  final[3].pb(-1),final[3].pb(9),final[3].pb(10),final[3].pb(11);\n  final[4].pb(-1),final[4].pb(-1),final[4].pb(0);\n\n  Puzzle puz(final); \n  deque<Puzzle> deq;\n  deq.push_back(puz);\n  bidirectional[final] = 0;\n  \n  while(!deq.empty())\n    {\n      Puzzle p = deq.front(); deq.pop_front();\n      int cost = bidirectional[p.state];\n    \n      if(cost >= 7)\n\tcontinue;\n\n      for(int i=0;i<2;i++)\n\t{\n\t  for(int j=0;j<4;j++)\n\t    {\n\t      int nx = p.vp[i].F + dx[j];\n\t      int ny = p.vp[i].S + dy[j];\n\t      if(!(0<=ny && ny<p.state.size() && 0<=nx && nx<p.state[ny].size() && p.state[ny][nx] != -1))\n\t\tcontinue;\n\t      VVI next = change(p.state,p.vp[i],P(nx,ny));\n\t      map<VVI,int>::iterator it = bidirectional.find(next);\n\t      if(it == bidirectional.end() || (it != bidirectional.end() && bidirectional[next] > cost + 1))\n\t\t{\n\t\t  bidirectional[next] = cost + 1;\n\t\t  deq.push_back(Puzzle(next));\n\t\t}\n\n\t    }\n\n\t}      \n\n    }\n  \n  \n}\n\n\nint main()\n{\n  VVI puzzle;\n  Init();\n  //cout << \"here\" << endl;\n  while(Input(puzzle))\n    {\n \n      Puzzle puz(puzzle);\n      int men = (1<<28);\n      deque<Puzzle> deq;\n      deq.push_back(puz);\n      memo.clear();\n      memo[puzzle] = 0;\n\n      while(!deq.empty())\n\t{\n\t  Puzzle p = deq.front(); deq.pop_front();\n\t  int cost = memo[p.state];\n\t  //cout << \"cost : \" << cost << endl;\n\t  //p.print();\n\t  if(cost + p.Manhattan > min(20,men))\n\t    continue;\n\n\t  if(p.state == final)\n\t    {\n\t      men = min(men,cost);\n\t      continue;\n\t    }\n\t  else if(bidirectional.find(p.state) != bidirectional.end() && cost + bidirectional[p.state] <= 20)\n\t    {\n\t      men = min(men,cost+bidirectional[p.state]);\n\t      continue;\n\t    }\n       \n\t  for(int i=0;i<2;i++)\n\t    {\n\t      for(int j=0;j<4;j++)\n\t\t{\n  \n\t\t  int nx = p.vp[i].F + dx[j];\n\t\t  int ny = p.vp[i].S + dy[j];\n\t\t  if(!(0<=ny && ny<p.state.size() && 0<=nx && nx<p.state[ny].size() && p.state[ny][nx] != -1))\n\t\t    continue;\n\n\t\t  VVI next = change(p.state,p.vp[i],P(nx,ny));\n\t\t  map<VVI,int>::iterator it = memo.find(next);\n\t\t  if(it == memo.end() || (it != memo.end() &&  memo[next] > cost + 1) )\n\t\t    {\n\t\t      memo[next] = cost + 1;\n\t\t      deq.push_back(Puzzle(next));\n\t\t    }\n\n\t\t}\n\t    }\n\n\n\t}\n      if(men == (1<<28))\n\tcout << \"NA\" << endl;\n      else \n\tcout << men << endl;\n    }  \n\n    \n  return 0;\n}\n\n\n  /*  \n  deque<VVIVP> deq;\n  VP vec;\n  vec.push_back(P(0,0));\n  vec.push_back(P(0,4)); \n  deq.push_back(VVIVP(final,vec));\n  bidirectional[final] = 0;\n  while(!deq.empty())\n    {\n      VVIVP vvivp = deq.front(); deq.pop_front();\n      VVI vvi = vvivp.F;\n      VP vp = vvivp.S;\n      P p1,p2;\n      int cost = bidirectional[vvi];\n      if(cost >= 5)\n\tcontinue;\n      p1 = vp[0];\n      p2 = vp[1];\n      \n      for(int i=0;i<5;i++)\n\t{\n\t  int nx1 = p1.F + dx[i];\n\t  int ny1 = p1.S + dy[i];\n\n\t  if(!(0 <= ny1 && ny1 < vvi.size() && 0 <= nx1 && nx1 < vvi[ny1].size()))\n\t    continue;\n\n\t  for(int j=0;j<5;j++)\n\t    {\n\t      if(i == 4 && j == 4)\n\t\tcontinue;\n\t      int nx2 = p2.F + dx[j];\n\t      int ny2 = p2.S + dy[j];\n\n\t      if(!(0 <= ny2 && ny2 < vvi.size() && 0 <= nx2 && nx2 < vvi[ny2].size()))\n\t\tcontinue;\n\t      VVI new_vvi = change(vvi,p1,P(nx1,ny1),p2,P(nx2,ny2));\n\t      if(bidirectional.count(new_vvi) == 0 || (bidirectional.count(new_vvi) != 0 && bidirectional[new_vvi] > cost + 1))\n\t\t{\n\t\t  VP vip;\n\t\t  vip.push_back(P(nx1,ny1));\n\t\t  vip.push_back(P(nx2,ny2));\n\t\t  bidirectional[new_vvi] = cost+1;\n\t\t  deq.push_back(VVIVP(new_vvi,vip));\n\t\t}\n\n\t     \n\n\t    }\n\t}\n\n    }\n*/\n\n/*\n int men = (1<<28);\n      deque<VVIVP> deq;\n      bool fin = false;\n      deq.push_back(VVIVP(puzzle,ini));\n      memo[puzzle] = 0;\n      while(!deq.empty() && !fin)\n\t{\n\t  VVIVP vvivp = deq.front(); deq.pop_front();\n\t  VVI vvi = vvivp.F;\n\t  VP vp = vvivp.S;\n\t  P p1,p2;\n\t  p1 = vp[0], p2 = vp[1];\n\t \n\t  if((vvi == final || bidirectional.count(vvi) != 0) && memo[vvi] + bidirectional[vvi] <= min(20,men))\n\t    {\n\t      men = min(men,memo[vvi]+bidirectional[vvi]);\n\t      continue;\n\t    }\n\t  \n\t  int cost = memo[vvi];\n\n\t  if(men <= cost) \n\t    continue;\n\n\t  for(int i=0;i<5;i++)\n\t    {\n\t      int nx1 = p1.F + dx[i];\n\t      int ny1 = p1.S + dy[i];\n\n\t      if(!(0 <= ny1 && ny1 < vvi.size() && 0 <= nx1 && nx1 < vvi[ny1].size()))\n\t\tcontinue;\n\n\t      for(int j=0;j<5;j++)\n\t\t{\n\t\t  if(i = 4 && j == 4)\n\t\t    continue;\n\t\t  int nx2 = p2.F + dx[j];\n\t\t  int ny2 = p2.S + dy[j];\n\t\t  \n\t\t  if(!(0 <= ny2 && ny2 < vvi.size() && 0 <= nx2 && nx2 < vvi[ny2].size()))\n\t\t    continue;\n\n\t\t  //cout << \"change! \" << i << \" - \" << j << endl;\n\n\t\t  //cout <<\"cost = \" << cost << endl;\n\t\t   //print(change(vvi,p1,P(nx1,ny1),p2,P(nx2,ny2)));\n\t\t  VVI new_vvi = change(vvi,p1,P(nx1,ny1),p2,P(nx2,ny2));\n\t\t  if(memo.count(new_vvi) == 0 || (memo.count(new_vvi) != 0 && memo[new_vvi] > cost+1))\n\t\t    {\n\t\t \n\t\t      memo[new_vvi] = cost+1;\n\t\t      VP vip;\n\t\t      vip.push_back(P(nx1,ny1));\n\t\t      vip.push_back(P(nx2,ny2));\n\t\t      deq.push_back(VVIVP(new_vvi,vip));\n\t\t    }\n\n\n\t\t}\n\n\t    }\n\n\t}\n\n      if(men != (1<<28))\n\tcout << men << endl;\n      else \n\tcout << \"NA\" << endl;\n */\n\n\n/*\nwhile(Input(puzzle)){\n      int men = (1<<28);\n      deque<VVIVP> deq;\n      bool fin = false;\n      deq.push_back(VVIVP(puzzle,ini));\n      memo[puzzle] = 0;\n      while(!deq.empty())\n\t{\n\t  VVIVP vvivp = deq.front(); deq.pop_front();\n\t  VVI vvi = vvivp.F;\n\t  VP vp = vvivp.S;\n\t \n\t  if(vvi == final)\n\t    {\n\t      men = min(men,memo[vvi]);\n\t      fin = true;\n\t    }\n\t  else if(bidirectional.count(vvi) != 0 && memo[vvi] + bidirectional[vvi] <= 20)\n\t    {\n\t      fin = true;\n\t      men = min(men,memo[vvi]+bidirectional[vvi]);\n\t      break;\n\t    }\n\t \n\t  int cost = memo[vvi];\n\t  if(cost >= men)\n\t    continue;\n\n\t  //cout << \"cost = \" << cost << endl;\n\t  P p1,p2;\n\t  p1 = vp[0];\n\t  p2 = vp[1];\n\t  for(int k=0;k<5;k++)\n\t    {\n\t      int nx1,ny1;\n\t      nx1 = vp[0].F + dx[k];\n\t      ny1 = vp[0].S + dy[k];\n\t      if(!(0 <= ny1 && vvi.size() > ny1 && 0 <= nx1 && vvi[ny1].size() > nx1))\n\t\tcontinue;\n\n\t      for(int l=0;l<5;l++)\n\t\t{\n\t\t  int nx2,ny2;\n\t\n\t\t  nx2 = vp[1].F + dx[l];\n\t\t  ny2 = vp[1].S + dy[l];\n\n\t\t  if(!(0 <= ny2 && vvi.size() > ny2 && 0 <= nx2 && vvi[ny2].size() > nx2))\n\t\t    continue;\n\t\n\t\n\t\t  int tmp = vvi[p1.S][p1.F];\n\t\t  vvi[p1.S][p1.F] = vvi[ny1][nx1];\n\t\t  vvi[ny1][nx1] = tmp;\n\n\t\t  tmp = vvi[p2.S][p2.F];\n\t\t  vvi[p2.S][p2.F] = vvi[ny2][nx2];\n\t\t  vvi[ny2][nx2] = tmp;\n\t\n\n\t\t  if(cost+1 >= 20 && vvi != final)\n\t\t    continue;\n\n\t\t  if(cost+1 >= 20 && vvi == final)\n\t\t    {\n\t\t      fin = true;\n\t\t      printf(\"20\\n\");\n\t\t      break;\n\t\t    }\n\n\t\t  if((memo.count(vvi) != 0 && memo[vvi] > cost + 1) || memo.count(vvi) == 0)\n\t\t    {\n\t\t      VP vip;\n\t\t      vip.push_back(P(nx1,ny1));\n\t\t      vip.push_back(P(nx2,ny2));\n\t\t      memo[vvi] = cost + 1;\n\t\t      deq.push_back(VVIVP(vvi,vip)); \n\t\t    }\n\n\t\n\t\t  tmp = vvi[p1.S][p1.F];\n\t\t  vvi[p1.S][p1.F] = vvi[ny1][nx1];\n\t\t  vvi[ny1][nx1] = tmp;\n\n\t\t  tmp = vvi[p2.S][p2.F];\n\t\t  vvi[p2.S][p2.F] = vvi[ny2][nx2];\n\t\t  vvi[ny2][nx2] = tmp;\n\t\n\t\t}\n\t      if(fin)\n\t\tbreak;\n\t    }\n\t  if(fin)\n\t    break;\n\t}\n      if(!fin)\n\tprintf(\"NA\\n\");\n      else\n\tprintf(\"%d\\n\",men);\n    }\n\n */"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\n\n#define fst(t) std::get<0>(t)\n#define snd(t) std::get<1>(t)\n#define thd(t) std::get<2>(t)\n#define unless(p) if(!(p))\n#define until(p) while(!(p))\n\nusing ll = std::int64_t;\nusing P = std::tuple<int,int>;\n\nconst int dx[4] = {-1, 1, 0, 0}, dy[4] = {0, 0, -1, 1};\n\ninline int dist(int y1, int x1, int y2, int x2){\n    return std::abs(y1 - y2) + std::abs(x1 - x2);\n}\n\nint gX[12], gY[12];\n\ninline int f(int y, int x, int p){\n    if(p > 0){\n        return dist(y, x, gY[p], gX[p]);\n    }\n    return 0;\n}\n\nstruct Puzzle{\n    std::vector<char> board;\n    std::vector<P> spaces;\n    int estimatedDist;\n    ll id;\n\n    Puzzle() : board(25, 0), spaces(2), estimatedDist(0), id(0) { \n        for(int i=1;i<=11;++i){\n            if(i <= 3){\n                at(1, i) = i;\n            }else if(i <= 8){\n                at(2, i - 4) = i;\n            }else{\n                at(3, i - 8) = i;\n            }\n        }\n\n        for(int i=0;i<5;++i){\n            for(int j=0;j<5;++j){\n                estimatedDist += f(i, j, at(i, j));\n                if(at(i, j) > 0){\n                    id |= ((5ll * i + j) << (5 * at(i, j)));\n                }\n            }\n        }\n\n        spaces[0] = std::make_tuple(0, 2);\n        spaces[1] = std::make_tuple(4, 2);\n    }\n\n    void move(int spaceId, int y, int x){        \n        int sX, sY;\n        std::tie(sY, sX) = spaces[spaceId];\n\n        estimatedDist += - f(y, x, at(y, x)) + f(sY, sX, at(y, x));\n        id ^= ((5ll * y + x) ^ (5ll * sY + sX)) << (5 * at(y, x));\n        at(sY, sX) = at(y, x);\n        at(y, x) = 0;\n        spaces[spaceId] = std::make_tuple(y, x);\n    }\n\n    char& at(int y, int x){\n        return board[y * 5 + x];\n    }\n};\n\nstruct State{\n    int turn;\n    Puzzle puzzle;\n\n    State(int t, Puzzle p) : turn(t), puzzle(std::move(p)) {}\n\n    friend bool operator>(const State &lhs, const State &rhs){\n        return lhs.turn + lhs.puzzle.estimatedDist > rhs.turn + rhs.puzzle.estimatedDist;\n    }\n};\n\nstd::map<ll, int> minDist;\nstd::priority_queue<State, std::vector<State>, std::greater<State>> pq;\n\nint solve(){\n    minDist.clear();\n    until(pq.empty()){\n        pq.pop();\n    }\n\n    Puzzle initialPuzzle;\n    pq.emplace(0, initialPuzzle);\n    minDist[initialPuzzle.id] = 0;\n\n    until(pq.empty()){\n        State s = pq.top();\n        pq.pop();\n\n        if(s.puzzle.estimatedDist == 0){\n            return s.turn;\n        }\n\n        if(s.turn + s.puzzle.estimatedDist > 20 ||\n           s.turn > minDist[s.puzzle.id]){\n            continue;\n        }\n\n        for(int i=0;i<2;++i){\n            for(int j=0;j<4;++j){\n                int x, y;\n                std::tie(y, x) = s.puzzle.spaces[i];\n\n                y += dy[j];\n                x += dx[j];\n\n                if(dist(y, x, 2, 2) > 2 || s.puzzle.at(y, x) == 0){\n                    continue;\n                }\n\n                Puzzle p = s.puzzle;\n                p.move(i, y, x);\n\n                if(minDist.count(p.id) == 0 || minDist[p.id] > s.turn + 1){\n                    minDist[p.id] = s.turn + 1;\n                    pq.emplace(s.turn + 1, p);\n                }\n            }\n        }\n    }\n\n    return -1;\n}\n\nint main(){\n    std::cin.tie(nullptr);\n    std::ios::sync_with_stdio(false);\n\n    while(true){\n        for(int i=0;i<5;++i){\n            for(int j=0;j<5;++j){\n                if(dist(i, j, 2, 2) > 2){\n                    continue;\n                }\n\n                int p;\n                std::cin >> p;\n\n                if(p == -1){\n                    return 0;\n                }\n\n                gY[p] = i;\n                gX[p] = j;\n            }\n        }\n\n        int mn = solve();\n        if(mn >= 0){\n            std::cout << mn << std::endl;\n        }else{\n            std::cout << \"NA\" << std::endl;\n        }\n    }\n}\n"
  },
  {
    "language": "C++",
    "code": "#include<iostream>\n#include<vector>\n#include<map>\n#include<cstdio>\n#include<deque>\n#include<cmath>\n#include<algorithm>\n#define F first\n#define S second\n#define pb push_back\nusing namespace std;\ntypedef pair<int,int> P;\ntypedef pair<P,P> PP;\ntypedef vector<int> VI;\ntypedef vector<VI> VVI;\ntypedef vector<P> VP;\ntypedef pair<VVI,VP> VVIVP;\n\n\nmap<VVI,int> memo,bidirectional;\nVVI final;\nVP ini;\nint dx[4] = {0,1,0,-1};\nint dy[4] = {1,0,-1,0};\n\nP Fpos[] = {P(0,0),P(1,1),P(2,1),P(3,1),P(0,2),P(1,2),P(2,2),P(3,2),P(4,2),P(1,3),P(2,3),P(3,3)};\n\n\nclass Puzzle\n{\npublic:\n  VVI state;\n  int Manhattan;\n  VP vp;\n\n  Puzzle():Manhattan(0){}\n  Puzzle(VVI s)\n  {\n    vp.clear();\n    state = s;\n    Manhattan_calc(false);\n  }\n\n  void Manhattan_calc(bool b)\n  {\n    Manhattan = 0; \n    for(int i=0;i<5;i++)\n      for(int j=0;j<state[i].size();j++)\n\tif(state[i][j] != 0 && state[i][j] != -1)\n\t  Manhattan += abs(j-Fpos[state[i][j]].F) + abs(i-Fpos[state[i][j]].S);\n\telse if(state[i][j] == 0 && !b)// bがfalseなら初期化\n\t  vp.push_back(P(j,i)); \n  }\n\n  void print()\n  {\n  \n    for(int i=0;i<state.size();i++)\n      {\n\tfor(int j=0;j<state[i].size();j++)\n\t  {\n\t    if(state[i][j] == -1)\n\t      cout << \"  \";\n\t    else \n\t      cout << state[i][j] << \" \";\n\t  }\n\tcout << endl;\n      }\n    cout << endl;\n  }\n};\n\nbool Input(VVI& puzzle)\n{\n  puzzle.clear();\n  puzzle.resize(5);\n  puzzle[0].resize(3),puzzle[1].resize(4),puzzle[2].resize(5),puzzle[3].resize(4),puzzle[4].resize(3);\n  puzzle[0][0] = puzzle[0][1] = puzzle[1][0] = puzzle[3][0] = puzzle[4][0] = puzzle[4][1] = -1;\n \n  scanf(\"%d\",&puzzle[0][2]);\n  if(puzzle[0][2] == -1)\n    return false; \n  scanf(\"%d %d %d\",&puzzle[1][1],&puzzle[1][2],&puzzle[1][3]);\n  scanf(\"%d %d %d %d %d\",&puzzle[2][0],&puzzle[2][1],&puzzle[2][2],&puzzle[2][3],&puzzle[2][4]);\n  scanf(\"%d %d %d\",&puzzle[3][1],&puzzle[3][2],&puzzle[3][3]);\n  scanf(\"%d\",&puzzle[4][2]);\n\t    \n    return true;\n}\n\nvoid print(VVI vvi)\n{\n  cout << \"--- print ---\" << endl;\n  for(int i=0;i<vvi.size();i++)\n    {\n      for(int j=0;j<vvi[i].size();j++)\n\t{\n\t  cout << vvi[i][j] << \" \";\n\t}\n      cout << endl;\n    }\n  cout << endl;\n}\n\nVVI change(VVI vec,P p1,P p11)\n{\n  int tmp = vec[p1.S][p1.F];\n  vec[p1.S][p1.F] = vec[p11.S][p11.F];\n  vec[p11.S][p11.F] = tmp;\n\n  return vec;\n}\n\nvoid Init()\n{\n  final.resize(5);\n  final[0].pb(-1),final[0].pb(-1),final[0].pb(0);\n  final[1].pb(-1),final[1].pb(1),final[1].pb(2),final[1].pb(3);\n  final[2].pb(4),final[2].pb(5),final[2].pb(6),final[2].pb(7),final[2].pb(8);\n  final[3].pb(-1),final[3].pb(9),final[3].pb(10),final[3].pb(11);\n  final[4].pb(-1),final[4].pb(-1),final[4].pb(0);\n\n  Puzzle puz(final); \n  deque<Puzzle> deq;\n  deq.push_back(puz);\n  bidirectional[final] = 0;\n  \n  while(!deq.empty())\n    {\n      Puzzle p = deq.front(); deq.pop_front();\n      int cost = bidirectional[p.state];\n    \n      if(cost >= 8)\n\tcontinue;\n\n      for(int i=0;i<2;i++)\n\t{\n\t  for(int j=0;j<4;j++)\n\t    {\n\t      int nx = p.vp[i].F + dx[j];\n\t      int ny = p.vp[i].S + dy[j];\n\t      if(!(0<=ny && ny<p.state.size() && 0<=nx && nx<p.state[ny].size() && p.state[ny][nx] != -1))\n\t\tcontinue;\n\t      VVI next = change(p.state,p.vp[i],P(nx,ny));\n\t      map<VVI,int>::iterator it = bidirectional.find(next);\n\t      if(it == bidirectional.end() || (it != bidirectional.end() && bidirectional[next] > cost + 1))\n\t\t{\n\t\t  bidirectional[next] = cost + 1;\n\t\t  deq.push_back(Puzzle(next));\n\t\t}\n\n\t    }\n\n\t}      \n\n    }\n  \n  \n}\n\n\nint main()\n{\n  VVI puzzle;\n  Init();\n  //cout << \"here\" << endl;\n  while(Input(puzzle))\n    {\n \n      Puzzle puz(puzzle);\n      int men = (1<<28);\n      deque<Puzzle> deq;\n      deq.push_back(puz);\n      memo.clear();\n      memo[puzzle] = 0;\n\n      while(!deq.empty())\n\t{\n\t  Puzzle p = deq.front(); deq.pop_front();\n\t  int cost = memo[p.state];\n\t  //cout << \"cost : \" << cost << endl;\n\t  //p.print();\n\t  if(cost + p.Manhattan > min(20,men))\n\t    continue;\n\n\t  if(p.state == final)\n\t    {\n\t      men = min(men,cost);\n\t      continue;\n\t    }\n\t  else if(bidirectional.find(p.state) != bidirectional.end() && cost + bidirectional[p.state] <= 20)\n\t    {\n\t      men = min(men,cost+bidirectional[p.state]);\n\t      continue;\n\t    }\n       \n\t  for(int i=0;i<2;i++)\n\t    {\n\t      for(int j=0;j<4;j++)\n\t\t{\n  \n\t\t  int nx = p.vp[i].F + dx[j];\n\t\t  int ny = p.vp[i].S + dy[j];\n\t\t  if(!(0<=ny && ny<p.state.size() && 0<=nx && nx<p.state[ny].size() && p.state[ny][nx] != -1))\n\t\t    continue;\n\n\t\t  VVI next = change(p.state,p.vp[i],P(nx,ny));\n\t\t  map<VVI,int>::iterator it = memo.find(next);\n\t\t  if(it == memo.end() || (it != memo.end() &&  memo[next] > cost + 1) )\n\t\t    {\n\t\t      memo[next] = cost + 1;\n\t\t      deq.push_back(Puzzle(next));\n\t\t    }\n\n\t\t}\n\t    }\n\n\n\t}\n      if(men == (1<<28))\n\tcout << \"NA\" << endl;\n      else \n\tcout << men << endl;\n    }  \n\n    \n  return 0;\n}\n\n\n  /*  \n  deque<VVIVP> deq;\n  VP vec;\n  vec.push_back(P(0,0));\n  vec.push_back(P(0,4)); \n  deq.push_back(VVIVP(final,vec));\n  bidirectional[final] = 0;\n  while(!deq.empty())\n    {\n      VVIVP vvivp = deq.front(); deq.pop_front();\n      VVI vvi = vvivp.F;\n      VP vp = vvivp.S;\n      P p1,p2;\n      int cost = bidirectional[vvi];\n      if(cost >= 5)\n\tcontinue;\n      p1 = vp[0];\n      p2 = vp[1];\n      \n      for(int i=0;i<5;i++)\n\t{\n\t  int nx1 = p1.F + dx[i];\n\t  int ny1 = p1.S + dy[i];\n\n\t  if(!(0 <= ny1 && ny1 < vvi.size() && 0 <= nx1 && nx1 < vvi[ny1].size()))\n\t    continue;\n\n\t  for(int j=0;j<5;j++)\n\t    {\n\t      if(i == 4 && j == 4)\n\t\tcontinue;\n\t      int nx2 = p2.F + dx[j];\n\t      int ny2 = p2.S + dy[j];\n\n\t      if(!(0 <= ny2 && ny2 < vvi.size() && 0 <= nx2 && nx2 < vvi[ny2].size()))\n\t\tcontinue;\n\t      VVI new_vvi = change(vvi,p1,P(nx1,ny1),p2,P(nx2,ny2));\n\t      if(bidirectional.count(new_vvi) == 0 || (bidirectional.count(new_vvi) != 0 && bidirectional[new_vvi] > cost + 1))\n\t\t{\n\t\t  VP vip;\n\t\t  vip.push_back(P(nx1,ny1));\n\t\t  vip.push_back(P(nx2,ny2));\n\t\t  bidirectional[new_vvi] = cost+1;\n\t\t  deq.push_back(VVIVP(new_vvi,vip));\n\t\t}\n\n\t     \n\n\t    }\n\t}\n\n    }\n*/\n\n/*\n int men = (1<<28);\n      deque<VVIVP> deq;\n      bool fin = false;\n      deq.push_back(VVIVP(puzzle,ini));\n      memo[puzzle] = 0;\n      while(!deq.empty() && !fin)\n\t{\n\t  VVIVP vvivp = deq.front(); deq.pop_front();\n\t  VVI vvi = vvivp.F;\n\t  VP vp = vvivp.S;\n\t  P p1,p2;\n\t  p1 = vp[0], p2 = vp[1];\n\t \n\t  if((vvi == final || bidirectional.count(vvi) != 0) && memo[vvi] + bidirectional[vvi] <= min(20,men))\n\t    {\n\t      men = min(men,memo[vvi]+bidirectional[vvi]);\n\t      continue;\n\t    }\n\t  \n\t  int cost = memo[vvi];\n\n\t  if(men <= cost) \n\t    continue;\n\n\t  for(int i=0;i<5;i++)\n\t    {\n\t      int nx1 = p1.F + dx[i];\n\t      int ny1 = p1.S + dy[i];\n\n\t      if(!(0 <= ny1 && ny1 < vvi.size() && 0 <= nx1 && nx1 < vvi[ny1].size()))\n\t\tcontinue;\n\n\t      for(int j=0;j<5;j++)\n\t\t{\n\t\t  if(i = 4 && j == 4)\n\t\t    continue;\n\t\t  int nx2 = p2.F + dx[j];\n\t\t  int ny2 = p2.S + dy[j];\n\t\t  \n\t\t  if(!(0 <= ny2 && ny2 < vvi.size() && 0 <= nx2 && nx2 < vvi[ny2].size()))\n\t\t    continue;\n\n\t\t  //cout << \"change! \" << i << \" - \" << j << endl;\n\n\t\t  //cout <<\"cost = \" << cost << endl;\n\t\t   //print(change(vvi,p1,P(nx1,ny1),p2,P(nx2,ny2)));\n\t\t  VVI new_vvi = change(vvi,p1,P(nx1,ny1),p2,P(nx2,ny2));\n\t\t  if(memo.count(new_vvi) == 0 || (memo.count(new_vvi) != 0 && memo[new_vvi] > cost+1))\n\t\t    {\n\t\t \n\t\t      memo[new_vvi] = cost+1;\n\t\t      VP vip;\n\t\t      vip.push_back(P(nx1,ny1));\n\t\t      vip.push_back(P(nx2,ny2));\n\t\t      deq.push_back(VVIVP(new_vvi,vip));\n\t\t    }\n\n\n\t\t}\n\n\t    }\n\n\t}\n\n      if(men != (1<<28))\n\tcout << men << endl;\n      else \n\tcout << \"NA\" << endl;\n */\n\n\n/*\nwhile(Input(puzzle)){\n      int men = (1<<28);\n      deque<VVIVP> deq;\n      bool fin = false;\n      deq.push_back(VVIVP(puzzle,ini));\n      memo[puzzle] = 0;\n      while(!deq.empty())\n\t{\n\t  VVIVP vvivp = deq.front(); deq.pop_front();\n\t  VVI vvi = vvivp.F;\n\t  VP vp = vvivp.S;\n\t \n\t  if(vvi == final)\n\t    {\n\t      men = min(men,memo[vvi]);\n\t      fin = true;\n\t    }\n\t  else if(bidirectional.count(vvi) != 0 && memo[vvi] + bidirectional[vvi] <= 20)\n\t    {\n\t      fin = true;\n\t      men = min(men,memo[vvi]+bidirectional[vvi]);\n\t      break;\n\t    }\n\t \n\t  int cost = memo[vvi];\n\t  if(cost >= men)\n\t    continue;\n\n\t  //cout << \"cost = \" << cost << endl;\n\t  P p1,p2;\n\t  p1 = vp[0];\n\t  p2 = vp[1];\n\t  for(int k=0;k<5;k++)\n\t    {\n\t      int nx1,ny1;\n\t      nx1 = vp[0].F + dx[k];\n\t      ny1 = vp[0].S + dy[k];\n\t      if(!(0 <= ny1 && vvi.size() > ny1 && 0 <= nx1 && vvi[ny1].size() > nx1))\n\t\tcontinue;\n\n\t      for(int l=0;l<5;l++)\n\t\t{\n\t\t  int nx2,ny2;\n\t\n\t\t  nx2 = vp[1].F + dx[l];\n\t\t  ny2 = vp[1].S + dy[l];\n\n\t\t  if(!(0 <= ny2 && vvi.size() > ny2 && 0 <= nx2 && vvi[ny2].size() > nx2))\n\t\t    continue;\n\t\n\t\n\t\t  int tmp = vvi[p1.S][p1.F];\n\t\t  vvi[p1.S][p1.F] = vvi[ny1][nx1];\n\t\t  vvi[ny1][nx1] = tmp;\n\n\t\t  tmp = vvi[p2.S][p2.F];\n\t\t  vvi[p2.S][p2.F] = vvi[ny2][nx2];\n\t\t  vvi[ny2][nx2] = tmp;\n\t\n\n\t\t  if(cost+1 >= 20 && vvi != final)\n\t\t    continue;\n\n\t\t  if(cost+1 >= 20 && vvi == final)\n\t\t    {\n\t\t      fin = true;\n\t\t      printf(\"20\\n\");\n\t\t      break;\n\t\t    }\n\n\t\t  if((memo.count(vvi) != 0 && memo[vvi] > cost + 1) || memo.count(vvi) == 0)\n\t\t    {\n\t\t      VP vip;\n\t\t      vip.push_back(P(nx1,ny1));\n\t\t      vip.push_back(P(nx2,ny2));\n\t\t      memo[vvi] = cost + 1;\n\t\t      deq.push_back(VVIVP(vvi,vip)); \n\t\t    }\n\n\t\n\t\t  tmp = vvi[p1.S][p1.F];\n\t\t  vvi[p1.S][p1.F] = vvi[ny1][nx1];\n\t\t  vvi[ny1][nx1] = tmp;\n\n\t\t  tmp = vvi[p2.S][p2.F];\n\t\t  vvi[p2.S][p2.F] = vvi[ny2][nx2];\n\t\t  vvi[ny2][nx2] = tmp;\n\t\n\t\t}\n\t      if(fin)\n\t\tbreak;\n\t    }\n\t  if(fin)\n\t    break;\n\t}\n      if(!fin)\n\tprintf(\"NA\\n\");\n      else\n\tprintf(\"%d\\n\",men);\n    }\n\n */"
  },
  {
    "language": "C++",
    "code": "#include <iostream>\n#include <cstdio>\n#include <cstring>\n#include <algorithm>\n#include <vector>\n#include <queue>\n#include <map>\nusing namespace std;\n\ntypedef vector<int> VI;\n\nint size[13] = {1, 2, 4, 2, 1, 4, 4, 4, 1, 2, 4, 2, 1};\nint move[13][4] = {\n  {2},\n  {2, 5},\n  {0, 1, 6, 3},\n  {2, 7},\n  {5},\n  {1, 4, 6, 9},\n  {2, 5, 7, 10},\n  {3, 6, 8, 11},\n  {7},\n  {5, 10},\n  {6, 9, 11, 12},\n  {7, 10},\n  {10}\n};\n\nVI v;\nmap<VI, int> mp;\nmap<VI, int> mp2;\n\nvoid make(){\n  VI goal;\n  for(int i = 0 ; i < 13 ; i++){\n    if(i == 0 || i == 12) goal.push_back(0);\n    else goal.push_back(i);    \n  }\n  \n  queue<VI> que;\n  que.push(goal);\n  mp2[goal] = 0;\n  \n  while(!que.empty()){\n    VI q = que.front(); que.pop();    \n    if(mp2[q] > 11) continue;\n    for(int i = 0 ; i < 13 ; i++){\n      if(q[i] != 0) continue;\n      for(int j = 0 ; j < size[i] ; j++){\n\tVI t = q;\n\tswap(t[i], t[ move[i][j] ]);\n\tif(mp2.find(t) != mp2.end()) continue;\t\n\tmp2[t] = mp2[q] + 1;\t\n\tque.push(t);\n      }\n    }\n  }\n}\n    \n\n\nint bfs(){\n  queue<VI> que;\n  que.push(v);\n  mp[v] = 0;  \n  while(!que.empty()){\n    VI q = que.front(); que.pop();    \n    if(mp2.find(q) != mp2.end()){\n      return mp2[q] + mp[q];\n    }\n    \n    if(mp[q] > 9) continue;\n    for(int i = 0 ; i < 13 ; i++){\n      if(q[i] != 0) continue;      \n      VI t = q;\n      for(int j = 0 ; j < size[i] ; j++){\n\tswap(t[i], t[ move[i][j] ]);\n\tif(mp.find(t) != mp.end()) continue;\n\tmp[t] = mp[q] + 1;\n\tque.push(t);\n      }\n    }\n  }\n  return -1;\n}\n\nvoid init(){\n  v.clear();\n  mp.clear();  \n}\n\nint main(){\n  make();\n  int n;\n  while(cin >> n){\n    if(n == -1) break;\n    \n    init();\n    \n    v.push_back(n);\n    for(int i = 0 ; i < 12 ; i++){ cin >> n; v.push_back(n); }\n    \n    int ans = bfs();\n    if(ans == -1) cout << \"NA\" << endl;\n    else cout << ans << endl;\n  }\n  \n\n  return 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include <iostream>\n#include <string>\n#include <vector>\n#include <queue>\n#include <map>\nusing namespace std;\n\nstring s = \"0123456789AB\";\nstring goal = \"0123456789AB0\";\n\nvector<vector<int>> adj = {\n    {2},\n    {2,5},\n    {0,1,3,6},\n    {2,7},\n    {5},\n    {1,4,6,9},\n    {2,5,7,10},\n    {3,6,8,11},\n    {7},\n    {5,10},\n    {6,9,11,12},\n    {7,10},\n    {10}\n};\n\nint solve(string stat) {\n    if (stat == goal) return 0;\n    map<string, int> dist;\n    dist[stat] = 0;\n    queue<string> q;\n    q.push(stat);\n    while ( ! q.empty()) {\n        string s = q.front();\n        q.pop();\n        for (int i=0; i<13; ++i) {\n            if (s[i] != '0') continue;\n            for (int j : adj[i]) {\n                string next = s;\n                next[i] = s[j];\n                next[j] = s[i];\n                int diff = 0;\n                for (int k=0; k<13; ++k) {\n                    diff += next[k] != goal[k];\n                }\n                if ( ! diff) {\n                    return dist[s] + 1;\n                }\n                if (dist.find(next) == dist.end()) {\n                    dist[next] = dist[s] + 1;\n                    if (dist[next] + diff - 1 <= 20) {\n                        q.push(next);\n                    }\n                }\n            }\n        }\n    }\n    return 21;\n}\n\nint main() {\n    while (1) {\n        string stat = \"\";\n        int k;\n        for (int i=0; i<13; ++i) {\n            if (cin >> k && !~k) return 0;\n            stat += s[k];\n        }\n        int ans = solve(stat);\n        if (ans <= 20) {\n            cout << ans << endl;\n            continue;\n        }\n        cout << \"NA\" << endl;\n    }\n    return 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\n\n#ifndef INCLUDE_ZOBRIST_HASH_HPP\n#define INCLUDE_ZOBRIST_HASH_HPP\n\n#include <random>\n#include <iostream>\n#include <typeinfo>\n\nnamespace orislib {\n\ntemplate <typename T, int W, int H, int STATE>\nstruct ZobristHash {\n  typedef T hash_t;\n  ZobristHash() {\n    std::random_device rd;\n    std::mt19937 mt(rd());\n    std::uniform_int_distribution<T> dist;\n    for (int h = 0; h < H; h++) {\n      for (int w = 0; w < W; w++) {\n        for (int s = 0; s < STATE; s++) {\n          rands[h][w][s] = dist(mt);\n        }\n      }\n    }\n  }\n  template <typename TT>\n  hash_t hash(TT data[H][W]) {\n    hash_t r = 0;\n    for (int h = 0; h < H; h++) {\n      for (int w = 0; w < W; w++) {\n        r ^= rands[h][w][data[h][w]];\n      }\n    }\n    return r;\n  }\n  hash_t rands[H][W][STATE];\n};\n}\n\n#endif\nusing namespace std;\nusing namespace orislib;\n\ntypedef long long ll;\ntypedef long double ld;\ntypedef tuple<int, int> duo;\nconst int dx[] = {0, 0, 1, -1, 1, 1, -1, -1};\nconst int dy[] = {1, -1, 0, 0, 1, -1, 1, -1};\nconst int Mod = 1000000000 + 0;\n//{{{ templates\n#define TT_             \\\n  template <typename T> \\\n  inline\n#define TTF_                        \\\n  template <typename T, typename F> \\\n  inline\nTT_ T sq(T x) { return x * x; }\nTT_ T In() {\n  T x;\n  cin >> x;\n  return x;\n}\nTT_ void Out(T& x) { cout << x; }\nTT_ void sort(T& v) { sort(begin(v), end(v)); }\nTT_ void revs(T& v) { reverse(begin(v), end(v)); }\nTT_ void uniq(T& v) {\n  sort(v);\n  v.erase(unique(begin(v), end(v)), end(v));\n}\nTT_ int ubnd(T& v, typename T::value_type& x) {\n  return upper_bound(begin(v), end(v), x) - begin(v);\n}\nTT_ int lbnd(T& v, typename T::value_type& x) {\n  return lower_bound(begin(v), end(v), x) - begin(v);\n}\nTTF_ void inpt(T& v, int n, F f) {\n  for (v.reserve(n); n--; v.emplace_back(f()))\n    ;\n}\nTTF_ void show(T& v, F f, string d = \" \", string e = \"\\n\") {\n  int i = 0;\n  for (auto& x : v) i++&&(cout << d), f(x);\n  cout << e;\n}\nTT_ typename T::iterator minel(T& v) { return min_element(begin(v), end(v)); }\nTT_ typename T::iterator maxel(T& v) { return max_element(begin(v), end(v)); }\n\ninline void fast_io() {\n  ios::sync_with_stdio(0);\n  cin.tie(0);\n}\ninline int in() {\n  int x;\n  scanf(\"%d\", &x);\n  return x;\n}\ninline ll pow_mod(ll a, ll k, ll m) {\n  ll r = 1;\n  for (; k > 0; a = a * a % m, k >>= 1)\n    if (k & 1) r = r * a % m;\n  return r;\n}\ninline ll mod_inv(ll a, ll p) { return pow_mod(a, p - 2, p); }\n//}}} priority_queue queue deque front stringstream max_element min_element\n// insert count make_tuple\n\nstruct Board {\n  Board() {}\n  Board(const vector<vector<int>>& v) {\n    memset(b, '#', sizeof(b));\n    for (int i = 0; i < 5; i++) b[i][5] = 0;\n    for (int i = 0; i < v[0].size(); i++) b[0][2 + i] = conv_hex(v[0][i]);\n    for (int i = 0; i < v[1].size(); i++) b[1][1 + i] = conv_hex(v[1][i]);\n    for (int i = 0; i < v[2].size(); i++) b[2][0 + i] = conv_hex(v[2][i]);\n    for (int i = 0; i < v[3].size(); i++) b[3][1 + i] = conv_hex(v[3][i]);\n    for (int i = 0; i < v[4].size(); i++) b[4][2 + i] = conv_hex(v[4][i]);\n    int it = 0;\n    for (int i = 0; i < 5; i++) {\n      for (int j = 0; j < 5; j++) {\n        if (b[i][j] == '0') {\n          cx[it] = j;\n          cy[it] = i;\n          it++;\n        }\n      }\n    }\n    turn = 0;\n  }\n  char conv_hex(int a) { return \"0123456789ABCDEF\"[a]; }\n  bool slide(int index, int dir) {\n/*\n    static const int mov[][5] = {\n      {2, -1},\n      {2, 5, -1},\n      {0, 1, 6, 3, -1},\n      {2, 7, -1},\n      {5, -1},\n      {1, 4, 9, 6, -1},\n      {2, 5, 10, 7, -1},\n      {3, 6, 11, 8, -1},\n      {7, -1},\n      {5, 10, -1},\n      {6, 9, 12, 11, -1},\n      {7, 10, -1},\n      {10, -1},\n    };\n*/\n    int px = cx[index], py = cy[index];\n    int nx = px + dx[dir], ny = py + dy[dir];\n    if (invalid(nx, ny)) return false;\n    if (b[ny][nx] == '#') return false;\n    if (b[ny][nx] == '0') return false;\n    swap(b[py][px], b[ny][nx]);\n    cx[index] = nx;\n    cy[index] = ny;\n    turn++;\n    return true;\n  }\n  bool invalid(int x, int y) { return x < 0 || x >= 5 || y < 0 || y >= 5; }\n  char b[5][6];\n  char cx[2], cy[2];\n  char turn;\n};\n\nint main() {\n  ZobristHash<int, 6, 5, 256> zh;\n  unordered_map<int, char> ans;\n  static const char cb[5][6] = {\"##0##\", \"#123#\", \"45678\", \"#9AB#\", \"##0##\", };\n  Board b;\n  memcpy(b.b, cb, sizeof(cb));\n  b.turn = 0;\n  b.cx[0] = 2;\n  b.cy[0] = 0;\n  b.cx[1] = 2;\n  b.cy[1] = 4;\n  queue<Board> Q;\n  Q.push(b);\n  while (!Q.empty()){\n    Board bi = Q.front();\n    Q.pop();\n    int hv = zh.hash(bi.b);\n    if (ans.count(hv)) continue;\n    ans[hv] = bi.turn;\n    if (bi.turn >= 20) continue;\n    for (int i = 0; i < 2; i++){\n      for (int d = 0; d < 4; d++){\n        Board bii = bi;\n        if (!bii.slide(i, d)) continue;\n        Q.push(bii);\n      }\n    }\n  }\n  puts(\"END\");\n  int h;\n  while (h = in(), h != -1) {\n    vector<vector<int>> vs(5);\n    vs[0].emplace_back(h);\n    inpt(vs[1], 3, in);\n    inpt(vs[2], 5, in);\n    inpt(vs[3], 3, in);\n    inpt(vs[4], 1, in);\n    Board b(vs);\n    int hv = zh.hash(b.b);\n    if (ans.count(hv)) cout << (int)ans[hv] << endl;\n    else cout << \"NA\\n\";\n  }\n  return 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include <cstdio>\n#include <cstring>\n#include <algorithm>\n#include <string>\n#include <cmath>\n#include <stack>\n#include <vector>\n#include <map>\n#include <set>\n#include <queue>\n#include <list>\n#include <iostream>\n#include <sstream>\n#include <climits>\n#include <cfloat>\n#include <complex>\n\nusing namespace std;\n\ntypedef long long ll;\n\nll encode(int* state)\n{\n\tll res = 0;\n\tfor (int i = 0; i < 13; ++i)\n\t\tres = res << 4 | state[i];\n\treturn res;\n}\nvoid decode(int* d, ll e)\n{\n\tfor (int i = 12; i >= 0; --i, e >>= 4)\n\t\td[i] = e & 15;\n}\nvoid p(ll s)\n{\n\tint d[13];\n\tdecode(d, s);\n\tfor (int i = 0; i < 13; ++i)\n\t\tprintf(\"%d \", d[i]);\n\tprintf(\"\\n\");\n}\nint main()\n{\n\tmap<ll, int> minSteps;\n\tint initial[] = { 0, 1, 2, 3, 4, 5, 6, 7, 8, 9, 10, 11, 0 };\n\tll t = encode(initial);\n\tminSteps[t] = 0;\n\tqueue<ll> q;\n\tq.push(t);\n\n\tint dir[] = { -1, 1, -2, 2, -4, 4 };\n\tint o[][9] = {\n\t\t{ 1, 2, 4, 5, 6, 7, 9, 10, -1 },\n\t\t{ 0, 10, -1 },\n\t\t{ 1, 2, 3, 5, 6, 7, -1 }\n\t};\n\tmap<int, bool> ok[3];\n\tfor (int i = 0; i < 3; ++i)\n\t\tfor (int j = 0; o[i][j] != -1; ++j)\n\t\t\tok[i][o[i][j]] = true;\n\n\twhile (!q.empty())\n\t{\n\t\tll e = q.front();\n\t\tq.pop();\n\t\tint d[13];\n\t\tdecode(d, e);\n\n\t\tint zero_pos[2];\n\t\tfor (int i = 0, j = 0; j < 2; ++i)\n\t\t\tif (!d[i])\n\t\t\t\tzero_pos[j++] = i;\n\n\t\tfor (int i = 0; i < 2; ++i)\n\t\t{\n\t\t\tfor (int j = 0; j < 6; ++j)\n\t\t\t{\n\t\t\t\tint a = zero_pos[i];\n\t\t\t\tint b = a + dir[j];\n\t\t\t\tif (a > b)\n\t\t\t\t\tswap(a, b);\n\t\t\t\tif (a < 0 || b > 12 || !d[a] && !d[b] || !ok[j/2][a])\n\t\t\t\t\tcontinue;\n\n\t\t\t\tint copy[13];\n\t\t\t\tmemcpy(copy, d, sizeof(copy));\n\t\t\t\tswap(copy[a], copy[b]);\n\t\t\t\tll next = encode(copy);\n\n\t\t\t\tif (!minSteps.count(next) && minSteps[e] < 20)\n\t\t\t\t{\n\t\t\t\t\tminSteps[next] = minSteps[e] + 1;\n\t\t\t\t\tq.push(next);\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t}\n\n\twhile (true)\n\t{\n\t\tint d[13];\n\t\tfor (int i = 0; i < 13; ++i)\n\t\t\tscanf(\"%d\", d + i);\n\t\tif (d[0] == -1)\n\t\t\tbreak;\n\t\tif (minSteps.count(encode(d)))\n\t\t\tprintf(\"%d\\n\", minSteps[encode(d)]);\n\t\telse\n\t\t\tputs(\"NA\");\n\t}\n\n\treturn 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include <iostream>\n#include <stdlib.h>\nusing namespace std;\n\nint p[5][5],x[11]={1,2,3,0,1,2,3,4,1,2,3},y[11]={1,1,1,2,2,2,2,2,3,3,3},s,sx[2],sy[2]\n    ,mx[4]={1,0,-1,0},my[4]={0,-1,0,1},lt;\nint search(int t,int mx2,int my2,int mc) {\n\tint a,i,j,x2,y2,s2;\n\tif (s==0) { if (lt>t) lt=t; return 1;}\n\t  for (i=0;i<2;i++) for (j=0;j<4;j++) {\n\t  x2=sx[i]+mx[j]; y2=sy[i]+my[j];\n\t  if (x2<0 || x2>4 || y2<0 || y2>4) continue;\n\t  if (p[y2][x2]<1 || ( mc==i  && mx2==-mx[j] && my2==-my[j])) continue;\n\t  s2=abs(x2-x[p[y2][x2]-1])+abs(y2-y[p[y2][x2]-1])-abs(sx[i]-x[p[y2][x2]-1])-abs(sy[i]-y[p[y2][x2]-1]);\n\t  if (s+s2>lt-t) continue;\n\t  p[sy[i]][sx[i]]=p[y2][x2]; p[y2][x2]=0;  s+=s2; \n\t  sx[i]=x2; sy[i]=y2;\n\t  a=search(t+1,mx[j],my[j],i);\n\t  sx[i]=x2-mx[j]; sy[i]=y2-my[j];\n\t  p[y2][x2]=p[sy[i]][sx[i]]; p[sy[i]][sx[i]]=0; s-=s2;\n\t  if (a==1) return 0;\n  }\n  return 0;\n}\n\nint main() {\n  int i,j,k;\n  for (i=0;i<5;i++) for (j=0;j<5;j++) p[i][j]=-1;\n  while (cin >> p[0][2] && p[0][2]!=-1) {\n\t  cin >> p[1][1] >> p[1][2] >> p[1][3];\n\t  cin >> p[2][0] >> p[2][1] >> p[2][2] >> p[2][3] >> p[2][4];\n\t  cin >> p[3][1] >> p[3][2] >> p[3][3];\n\t  cin >> p[4][2]; k=0; s=0;\n\t  for (i=0;i<5;i++) for (j=0;j<5;j++) {\n\t\t  if (p[i][j]==0) { sx[k++]=j; sy[k++]=i;}\n\t\t  if (p[i][j]>0) s+=abs(j-x[p[i][j]-1])+abs(i-y[p[i][j]-1]);\n\t\t   }\n\t  lt=21;\t   \n\t  search(0,0,0,0);\n\t  if (lt==21) cout << \"NA\" << endl; else cout << lt << endl;\n  } \n return 0;\n}\t\t"
  },
  {
    "language": "C++",
    "code": "#include <iostream>\n#include <cstdio>\n#include <vector>\n#include <map>\n#include <string>\n#include <queue>\n#include <algorithm>\nusing namespace std;\n\nconst int INF = 1e+8;\nconst int f1[25] = {\n\t-1,-1, 0,-1,-1,\n\t-1, 1, 2, 3,-1,\n\t 4, 5, 6, 7, 8,\n\t-1, 9,10,11,-1,\n\t-1,-1,12,-1,-1,\n};\nconst int f2[13] = {2,6,7,8,10,11,12,13,14,16,17,18,22};\nconst int dx[4] = { 0,-1,+1, 0};\nconst int dy[4] = {-1, 0, 0,+1};\n\n// パズル\nstruct Pazzle{\n\tvector<char> v;\n\tPazzle(){v = vector<char>(13); }\n\tvoid at(int i, int p){\n\t\tv[i] = p;\n\t}\n\t// 空白の位置を返す. (k は 0 or 1)\n\tint search(int k){\n\t\tint a = 0;\n\t\tfor(int i=0 ; i < 13 ; i++ ){\n\t\t\tif( v[i] == 0 ){\n\t\t\t\tif( k == 0 ){\n\t\t\t\t\treturn i;\n\t\t\t\t}else{\n\t\t\t\t\tif( a == 0 ) a++;\n\t\t\t\t\telse return i;\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t\treturn -1;\n\t}\n\tint to_g(){\n\t\tint res = 0;\n\t\tint a = 0;\n\t\tfor(int i=0 ; i < 13 ; i++ ){\n\t\t\tint x1 = f2[v[i]] % 5;\n\t\t\tint y1 = f2[v[i]] / 5;\n\t\t\tint x2 = i % 5;\n\t\t\tint y2 = i / 5;\n\t\t\tif( v[i] == 0 ){\n\t\t\t\tif( a == 0 ){\n\t\t\t\t\ta++;\n\t\t\t\t}else{\n\t\t\t\t\tx1 = f2[12] % 5;\n\t\t\t\t\ty1 = f2[12] / 5;\n\t\t\t\t} \n\t\t\t}\n\t\t\tres += abs(x1-x2) + abs(y1-y2);\n\t\t}\n\t\treturn res;\n\t}\n\t// 空白 k (0 or 1) を 方向 dir に動かす.\n\t// 動かせる時は true, 動かせなかったときは false を返す.\n\tbool move(int dir, int k){\n\t\tif( dir < 0 || 4 <= dir || k < 0 || 2 <= k ) return false;\n\t\tint pos1 = search(k);\n\t\tint x = f2[pos1] % 5;\n\t\tint y = f2[pos1] / 5;\n\t\tint mx = x + dx[dir];\n\t\tint my = y + dy[dir];\n\t\tif( mx < 0 || my < 0 || 5 <= mx || 5 <= my ) return false;\n\t\tint pos2 = f1[my*5+mx];\n\t\tif( pos2 == -1 ) return false;\n\t\tif( v[pos1] == v[pos2] ) return false;\n\t\tswap( v[pos1] , v[pos2] );\n\t\treturn true;\n\t}\n\t// 完成しているかどうか\n\tbool is_goal(){\n\t\tfor(int i=0 ; i < 12 ; i++ ){\n\t\t\tif( v[i] != i ) return false;\n\t\t}\n\t\treturn v[12] == 0;\n\t}\n\tvoid debug(){\n\t\tprintf(\"[debug]\\n\");\n\t\tfor(int y=0 ; y < 5 ; y++ ){\n\t\t\tfor(int x=0 ; x < 5 ; x++ ){\n\t\t\t\tif( f1[y*5+x] == -1 ){\n\t\t\t\t\tprintf(\"##\");\n\t\t\t\t}else{\n\t\t\t\t\tprintf(\"%2d\", (int)v[f1[y*5+x]] );\n\t\t\t\t}\n\t\t\t}\n\t\t\tprintf(\"\\n\");\n\t\t}\n\t\tprintf(\"\\n\");\n\t}\n};\n\n// (コスト,スタートからの距離,パズルの状態)\nstruct State{\n\tPazzle p;\n\tint cost, cnt;\n\tState(int cost_, int cnt_, const Pazzle& p_){\n\t\tcost = cost_; cnt = cnt_; p = p_;\n\t}\n};\nbool operator<(const State& a, const State& b){\n\treturn a.cost > b.cost;\n}\n\nint solve(Pazzle p){\n\t// (コスト,スタートからの距離,パズルの状態) を優先度つきキューへ\n\tpriority_queue<State> q;\n\tq.push( State(p.to_g(),0,p) );\n\t\n\tint res = 21;\n\tint foo=0;\n\twhile( !q.empty() ){\n\t\tfoo++;\n\t\tPazzle p = q.top().p; \n\t\tint cost = q.top().cost;\n\t\tint cnt = q.top().cnt;\n\t\tq.pop();\n\t\t\n\t\tif( 3000 < foo ) break;\n\t\tif( res < cnt ) continue;\n\t\t\n\t\tif( p.is_goal() ){\n\t\t\tres = min( res , cnt );\n\t\t\tcontinue;\n\t\t}\n\t\t\n\t\tfor(int k=0 ; k <= 1 ; k++ ){\n\t\t\tfor(int i=0 ; i < 4 ; i++ ){\n\t\t\t\tPazzle p_ = p;\n\t\t\t\tif( p_.move(i,k) ){\n\t\t\t\t\tq.push( State(p_.to_g()+cnt+1,cnt+1,p_) );\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t}\n\treturn res;\n}\n\nint main(){\n\tint p1;\n\twhile( cin >> p1 , p1 != -1 ){\n\t\tPazzle p;\n\t\tp.at(0,p1);\n\t\tfor(int i=1 ; i < 13 ; i++ ){\n\t\t\tcin >> p1;\n\t\t\tp.at(i,p1);\n\t\t}\n\t\tint ans = solve(p);\n\t\tif( ans == 21 ){\n\t\t\tcout << \"NA\" << endl;\n\t\t}else{\n\t\t\tcout << ans << endl;\n\t\t}\n\t}\n}"
  },
  {
    "language": "C++",
    "code": "\n#include <iostream>\n#include <algorithm>\n#include <vector>\n#include <cstring>\n#include <cstdio>\n#include <climits>\n\nusing namespace std;\n\n#define REP(i,a,n) for(int i=(a); i<(int)(n); i++)\n#define rep(i,n) REP(i,0,n)\n#define DEB 0\n\n/*\n  1 = [2][2]\n  2 = [2][3]\n  3 = [2][4]\n  4 = [3][1]\n  5 = [3][2]\n  6 = [3][3]\n  7 = [3][4]\n  8 = [3][5]\n  9 = [4][2]\n  10= [4][3]\n  11= [4][4]\n*/\nint board[7][7]; //1base\nint sx[2], sy[2];\nint ans;\nstatic const int dx[] = {0,0,1,-1};\nstatic const int dy[] = {1,-1,0,0};\n\n/*\n(y,x)\n */\nint calc(int y, int x){\n    switch(board[y][x]){\n    case 1: return abs(2-y)+abs(2-x);\n    case 2: return abs(2-y)+abs(3-x);\n    case 3: return abs(2-y)+abs(4-x);\n    case 4: return abs(3-y)+abs(1-x);\n    case 5: return abs(3-y)+abs(2-x);\n    case 6: return abs(3-y)+abs(3-x);\n    case 7: return abs(3-y)+abs(4-x);\n    case 8: return abs(3-y)+abs(5-x);\n    case 9: return abs(4-y)+abs(2-x);\n    case 10: return abs(4-y)+abs(3-x);\n    case 11: return abs(4-y)+abs(4-x);\n    }\n    return -1;\n}\nint dist(void){\n    int ret = 0;\n    if( board[1][3] ) ret += calc(1,3);\n    rep(i,3) if( board[2][2+i] ) ret += calc(2,2+i);\n    rep(i,5) if( board[3][1+i] ) ret += calc(3,1+i);\n    rep(i,3) if( board[4][2+i] ) ret += calc(4,2+i);\n    if( board[5][3] ) ret += calc(5,3);\n    return ret;\n}\nbool isgoal(void){\n    if( board[1][3]!=0 ) return false;\n    rep(i,3) if( board[2][2+i]!=i+1 ) return false;\n    rep(i,5) if( board[3][1+i]!=i+4 ) return false;\n    rep(i,3) if( board[4][2+i]!=i+9 ) return false;\n    if( board[5][3]!=0 ) return false;\n    return true;\n}\n\nbool dfs(int cnt, int LIM, int py, int px){\n    if( ans<=cnt ) return false;\n    if( isgoal() ){ ans = cnt; return true; }\n    if( cnt+dist()>LIM ) return false;\n#if DEB\n    //printf(\"cnt:%d  (%d,%d),(%d,%d)\\n\",cnt, sx[0], sy[0], sx[1], sy[1]);\n#endif\n    rep(i,2){\n        rep(k,4){\n            int tx = sx[i] + dx[k];\n            int ty = sy[i] + dy[k];\n            if( board[ty][tx]==-1 || ty==py&&tx==px ) continue;\n            swap(board[sy[i]][sx[i]], board[ty][tx]);\n            swap(sx[i], tx); swap(sy[i],ty);\n            if( dfs(cnt+1, LIM, ty, tx) ) return true; // ツ個ウツづ個スツペツーツスツ暗環置\n            swap(sx[i], tx); swap(sy[i],ty);\n            swap(board[sy[i]][sx[i]] ,board[ty][tx]);\n        }\n    }\n}\nbool solve(void){\n    int ttx[2], tty[2];\n    rep(i,2) ttx[i]=sx[i], tty[i]=sy[i];\n\n    for(int lim = 0; lim < 30; lim++){\n        rep(i,2) sx[i]=ttx[i], sy[i]=tty[i];\n        if( dfs(0,lim,-1,-1) ) return true;;\n    }\n    return false;\n}\nint main(){\n    for(;;){\n        memset(board, -1, sizeof(board));\n        ans = 21;\n        int sz = 0;\n\n        scanf(\"%d\",&board[1][3]); if( board[1][3]==-1 ) break;\n        rep(i,3) scanf(\"%d\",&board[2][2+i]);\n        rep(i,5) scanf(\"%d\",&board[3][1+i]);\n        rep(i,3) scanf(\"%d\",&board[4][2+i]);\n        scanf(\"%d\",&board[5][3]);\n\n        // find space\n        if( board[1][3]==0 ){ sx[sz]=3; sy[sz]=1; sz++; }\n        rep(i,3) if( board[2][2+i]==0 ) { sx[sz]=2+i; sy[sz]=2; sz++; }\n        rep(i,5) if( board[3][1+i]==0 ) { sx[sz]=1+i; sy[sz]=3; sz++; }\n        rep(i,3) if( board[4][2+i]==0 ) { sx[sz]=2+i; sy[sz]=4; sz++; }\n        if( board[5][3]==0 ){ sx[sz]=3; sy[sz]=5; sz++; }\n\n#if DEB\n        rep(i,7){\n            rep(j,7){\n                printf(\"%2d \",board[i][j]);\n            }\n            puts(\"\");\n        }\n        rep(i,2){\n            printf(\"(%d,%d),\",sx[i], sy[i]);\n        }puts(\"\");\n        printf(\"%d\\n\",dist());\n#endif\n        \n        if( solve() ) printf(\"%d\\n\",ans); else puts(\"NA\");\n    }\n    return 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include <iostream>\n#include <sstream>\n#include <cstdio>\n#include <cstdlib>\n#include <cmath>\n#include <ctime>\n#include <cstring>\n#include <climits>\n#include <algorithm>\n#include <map>\n#include <set>\n#include <stack>\n#include <vector>\n#include <queue>\n#include <bitset>\n#include <string>\nusing namespace std;\n \n#define rep(i,n) for(int i=0; i<n; i++)\n#define repa(i,s,e) for(int i=s; i<=e; i++)\n#define repd(i,s,e) for(int i=s; i>=e; i--)\n#define PB(a) push_back(a)\n#define MP(i,s) make_pair(i,s)\n \ntypedef long long ll;\n\nconst int dx[4] = {-1, 0, 0, 1};\nconst int dy[4] = {0, -1, 1, 0};\nconst int field[5][5] = {\n\t{0, 0, 1, 0, 0}, \n\t{0, 1, 1, 1, 0},\n\t{1, 1, 1, 1, 1},\n\t{0, 1, 1, 1, 0},\n\t{0, 0, 1, 0, 0}, \n};\n\nconst int ans[5][5] = {\n\t{0, 0, 0, 0, 0},\n\t{0, 1, 2, 3, 0},\n\t{4, 5, 6, 7, 8},\n\t{0, 9, 10, 11, 0},\n\t{0, 0, 0, 0, 0}\n};\n\nconst int px[13] = {2, 1, 2, 3, 0, 1, 2, 3, 4, 1, 2, 3, 2};\nconst int py[13] = {0, 1, 1, 1, 2, 2, 2, 2, 2, 3, 3, 3, 4};\n\nll H;\nint P[5][5];\nset<ll> used;\n\nll hash_val() {\n\tll h = 0;\n\trep(i,13) {\n\t\th *= 13;\n\t\th += P[py[i]][px[i]];\n\t}\n\treturn h;\n}\n\nbool dfs(int m, int d) {\n\tll h = hash_val();\n\tif(h == H) \treturn true;\n\tif(m == d) return false;\n\tif(used.find(h) != used.end()) return false;\n\n\tused.insert(h);\n\trep(i,13) {\n\t\tint x = px[i];\n\t\tint y = py[i];\n\t\tif(P[y][x] == 0) {\n\t\t\trep(k,4) {\n\t\t\t\tint xx = x + dx[k];\n\t\t\t\tint yy = y + dy[k];\n\t\t\t\tif(xx>=0 && yy>=0 && xx<5 && yy<5 && field[yy][xx] == 1) {\n\t\t\t\t\tswap(P[y][x], P[yy][xx]);\n\t\t\t\t\tif(dfs(m+1, d)) return true;\n\t\t\t\t\tswap(P[y][x], P[yy][xx]);\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t}\n\treturn false;\n}\n\nvoid solve() {\n\trepa(d,0,20) {\n\t\tused.clear();\n\t\tif(dfs(0, d)) {\n\t\t\tprintf(\"%d\\n\", d);\n\t\t\treturn;\n\t\t}\n\t}\n\tprintf(\"NA\\n\");\n}\n\nint main() {\n\tmemcpy(P, ans, sizeof(P));\n\tH = hash_val();\n\tfor(;;) {\n\t\trep(i,13) {\n\t\t\tscanf(\"%d\", &P[py[i]][px[i]]);\n\t\t\tif(P[py[i]][px[i]] < 0) return 0;\n\t\t}\n\t\tsolve();\n\t}\n}"
  },
  {
    "language": "C++",
    "code": "#include<bits/stdc++.h>\nusing namespace std;\n  \ntypedef long long int64;\nconst int INF = 1 << 30;\n  \nvector< int > edge[13];\nmap< string, int > memo;\n \nbool back(string str, int cnt){ //枝刈り大事だな\n  static int dist[] = { 0, 2, 1, 2, 4, 3, 2, 3, 4, 2, 1, 2, 0};\n  static int fuee[] = { 2, 0, 1, 2, 2, 1, 2, 3, 4, 2, 3, 4, 4};\n  static int fuga[] = { 1, 1, 0, 1, 3, 2, 1, 2, 3, 3, 2, 3, 3};\n  static int haaa[] = { 2, 2, 1, 0, 4, 3, 2, 1, 2, 4, 3, 2, 4};\n  static int kira[] = { 3, 3, 2, 3, 3, 2, 1, 2, 3, 1, 0, 1, 1};\n \n  int foo1 = 0, foo2 = 0, foo3 = 0, foo4 = 0, foo5 = 0;\n  for(int i = 0; i < 13; i++){\n    if(str[i] == '0') foo1 += dist[i];\n    else if(str[i] == '1') foo2 += fuee[i];\n    else if(str[i] == '2') foo3 += fuga[i];\n    else if(str[i] == '3') foo4 += haaa[i];\n    else if(str[i] == 'A') foo5 += kira[i];\n  }\n  return cnt + foo1 > 20 || cnt + foo2 > 20 || cnt + foo3 > 20 || cnt + foo4 > 20 || cnt + foo5 > 20;\n}\n \n \nint bfs(string mas){\n \n  queue< string > que;\n  map< string , int > used;\n  que.push( mas );\n  memo[mas] = 0;\n  while(!que.empty()){\n \n    string p = que.front(); que.pop();\n    if(back( p, memo[p])) break;\n    if(p == \"0123456789AB0\") return memo[p];\n \n    for(int i = 0; i < 13; i++){\n      if(p[i] == '0') {\n        for(int j = 0; j < edge[i].size(); j++){\n          string next = p;\n          swap( next[i], next[edge[i][j]]);\n          if(memo.find(next) != memo.end()) continue;\n          que.push( next );\n          memo[next] = memo[p] + 1;\n        }\n      }\n    }\n  }\n  return -1;\n}\n \nint main(){\n  vector< int > mas(13);\n \n  edge[0].push_back(2);\n  edge[1].push_back(2); edge[1].push_back(4);\n  edge[2].push_back(0); edge[2].push_back(1); edge[2].push_back(3); edge[2].push_back(6);\n  edge[3].push_back(2); edge[3].push_back(7);\n  edge[4].push_back(5);\n  edge[5].push_back(1); edge[5].push_back(4); edge[5].push_back(6); edge[5].push_back(9);\n  edge[6].push_back(2); edge[6].push_back(5); edge[6].push_back(7); edge[6].push_back(10);\n  edge[7].push_back(3); edge[7].push_back(6); edge[7].push_back(8); edge[7].push_back(11);\n  edge[8].push_back(7);\n  edge[9].push_back(5); edge[9].push_back(10);\n  edge[10].push_back(6); edge[10].push_back(9); edge[10].push_back(11); edge[10].push_back(12);\n  edge[11].push_back(7); edge[11].push_back(10);\n  edge[12].push_back(10);\n \n  while(cin >> mas[0], mas[0] != -1){\n    for(int i = 1; i < 13; i++){\n      cin >> mas[i];\n    }\n \n    string start = \"\";\n    for(int i = 0; i < 13; i++){\n      if(mas[i] >= 10) start += (char)(mas[i] - 10 + 'A');\n      else start += mas[i] + '0';\n    }\n    int ret = bfs(start);\n    if(~ret) cout << ret << endl;\n    else cout << \"NA\" << endl;\n \n    memo.clear();\n  }\n}"
  },
  {
    "language": "C++",
    "code": "#include <iostream>\n#include <algorithm>\n#include <vector>\n#include <cstring>\n#include <cstdio>\n#include <climits>\n\nusing namespace std;\n\n#define REP(i,a,n) for(int i=(a); i<(int)(n); i++)\n#define rep(i,n) REP(i,0,n)\n#define LIM 20\n#define DEB 0\n\n/*\n  1 = [2][2]\n  2 = [2][3]\n  3 = [2][4]\n  4 = [3][1]\n  5 = [3][2]\n  6 = [3][3]\n  7 = [3][4]\n  8 = [3][5]\n  9 = [4][2]\n  10= [4][3]\n  11= [4][4]\n*/\nint board[7][7]; //1base\nint ans;\nint sx[2], sy[2];\nstatic const int dx[] = {0,0,1,-1};\nstatic const int dy[] = {1,-1,0,0};\n\n/*\n(y,x)\n */\nint calc(int y, int x){\n    switch(board[y][x]){\n    case 1: return abs(2-y)+abs(2-x);\n    case 2: return abs(2-y)+abs(3-x);\n    case 3: return abs(2-y)+abs(4-x);\n    case 4: return abs(3-y)+abs(1-x);\n    case 5: return abs(3-y)+abs(2-x);\n    case 6: return abs(3-y)+abs(3-x);\n    case 7: return abs(3-y)+abs(4-x);\n    case 8: return abs(3-y)+abs(5-x);\n    case 9: return abs(4-y)+abs(2-x);\n    case 10: return abs(4-y)+abs(3-x);\n    case 11: return abs(4-y)+abs(4-x);\n    }\n    return -1;\n}\nint dist(void){\n    int ret = 0;\n    if( board[1][3] ) ret += calc(1,3);\n    rep(i,3) if( board[2][2+i] ) ret += calc(2,2+i);\n    rep(i,5) if( board[3][1+i] ) ret += calc(3,1+i);\n    rep(i,3) if( board[4][2+i] ) ret += calc(4,2+i);\n    if( board[5][3] ) ret += calc(5,3);\n    return ret;\n}\nbool isgoal(void){\n    if( board[1][3]!=0 ) return false;\n    rep(i,3) if( board[2][2+i]!=i+1 ) return false;\n    rep(i,5) if( board[3][1+i]!=i+4 ) return false;\n    rep(i,3) if( board[4][2+i]!=i+9 ) return false;\n    if( board[5][3]!=0 ) return false;\n    return true;\n}\n\nvoid dfs(int cnt, int py, int px){\n    if( ans<=cnt ) return;\n    if( isgoal() ){\n        ans = cnt;\n        return;\n    }\n    if( cnt+dist()>LIM ) return;\n#if DEB\n    //printf(\"cnt:%d  (%d,%d),(%d,%d)\\n\",cnt, sx[0], sy[0], sx[1], sy[1]);\n#endif\n    rep(i,2){\n        rep(k,4){\n            int tx = sx[i] + dx[k];\n            int ty = sy[i] + dy[k];\n            if( board[ty][tx]==-1 || ty==py&&tx==px ) continue;\n            swap(board[sy[i]][sx[i]], board[ty][tx]);\n            swap(sx[i], tx); swap(sy[i],ty);\n            dfs(cnt+1, ty, tx); // ツ個ウツづ個スツペツーツスツ暗環置\n            swap(sx[i], tx); swap(sy[i],ty);\n            swap(board[sy[i]][sx[i]] ,board[ty][tx]);\n        }\n    }\n}\n\nint main(){\n    for(;;){\n        memset(board, -1, sizeof(board));\n        ans = 21;\n        int sz = 0;\n\n        scanf(\"%d\",&board[1][3]); if( board[1][3]==-1 ) break;\n        rep(i,3) scanf(\"%d\",&board[2][2+i]);\n        rep(i,5) scanf(\"%d\",&board[3][1+i]);\n        rep(i,3) scanf(\"%d\",&board[4][2+i]);\n        scanf(\"%d\",&board[5][3]);\n\n        // find space\n        if( board[1][3]==0 ){ sx[sz]=3; sy[sz]=1; sz++; }\n        rep(i,3) if( board[2][2+i]==0 ) { sx[sz]=2+i; sy[sz]=2; sz++; }\n        rep(i,5) if( board[3][1+i]==0 ) { sx[sz]=1+i; sy[sz]=3; sz++; }\n        rep(i,3) if( board[4][2+i]==0 ) { sx[sz]=2+i; sy[sz]=4; sz++; }\n        if( board[5][3]==0 ){ sx[sz]=3; sy[sz]=5; sz++; }\n\n#if DEB\n        rep(i,7){\n            rep(j,7){\n                printf(\"%2d \",board[i][j]);\n            }\n            puts(\"\");\n        }\n        rep(i,2){\n            printf(\"(%d,%d),\",sx[i], sy[i]);\n        }puts(\"\");\n        printf(\"%d\\n\",dist());\n#endif\n        \n        dfs(0,-1,-1);\n        if( ans==21 ) puts(\"NA\"); else printf(\"%d\\n\",ans);\n    }\n    return 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\nusing namespace std;\n\nconst int H = 5;\nconst int W = 5;\n\nstruct State {\n  int g[H][W];\n  int x[2], y[2];\n  bool operator < (const State &s) const {\n    for(int i = 0, k = 0; i < H; ++i) {\n      for(int j = abs(2-i); j < W-abs(2-i); ++j) {\n        if(g[i][j] != s.g[i][j]) return g[i][j] < s.g[i][j];\n      }\n    }\n    return false;\n  }\n  bool operator == (const State &s) const {\n    return !(*this < s) && !(s < *this);\n  }\n};\n\nmap<State,int> bfs1(State src) {\n  const static int dx[4] = {1,0,-1,0};\n  const static int dy[4] = {0,1,0,-1};\n  map<State,int> cost;\n  queue<State> que;\n  cost[src] = 0;\n  que.push(src);\n  while(que.size()) {\n    const State s = que.front();\n    que.pop();\n    if(cost[s] == 10) continue;\n    for(int k = 0; k < 2; ++k) {\n      for(int i = 0; i < 4; ++i) {\n        int nx = s.x[k] + dx[i];\n        int ny = s.y[k] + dy[i];\n        if(nx < 0 || nx >= W) continue;\n        if(ny < 0 || ny >= H) continue;\n        if(s.g[ny][nx] <= 0) continue;\n        State t = s;\n        swap(t.g[t.y[k]][t.x[k]], t.g[ny][nx]);\n        t.x[k] = nx;\n        t.y[k] = ny;\n        if(cost.count(t)) continue;\n        cost[t] = cost[s] + 1;\n        que.push(t);\n      }\n    }\n  }\n  return cost;\n}\n\nint bfs2(State src, map<State,int> rcost) {\n  const static int dx[4] = {1,0,-1,0};\n  const static int dy[4] = {0,1,0,-1};\n  if(rcost.count(src)) return rcost[src];\n  map<State,int> cost;\n  queue<State> que;\n  cost[src] = 0;\n  que.push(src);\n  while(que.size()) {\n    const State s = que.front();\n    que.pop();\n    if(cost[s] == 10) continue;\n    for(int k = 0; k < 2; ++k) {\n      for(int i = 0; i < 4; ++i) {\n        int nx = s.x[k] + dx[i];\n        int ny = s.y[k] + dy[i];\n        if(nx < 0 || nx >= W) continue;\n        if(ny < 0 || ny >= H) continue;\n        if(s.g[ny][nx] <= 0) continue;\n        State t = s;\n        swap(t.g[t.y[k]][t.x[k]], t.g[ny][nx]);\n        t.x[k] = nx;\n        t.y[k] = ny;\n        if(cost.count(t)) continue;\n        cost[t] = cost[s] + 1;\n        que.push(t);\n        if(rcost.count(t)) {\n          return cost[t] + rcost[t];\n        }\n      }\n    }\n  }\n  return -1;\n}\n\nint main() {\n  State src, dst;\n  fill(src.g[0], src.g[H], -1);\n  fill(dst.g[0], dst.g[H], -1);\n  for(int i = 0, k = 0, t = 0; i < H; ++i) {\n    for(int j = abs(2-i); j < W-abs(2-i); ++j) {\n      dst.g[i][j] = t % 12;\n      ++t;\n      if(dst.g[i][j] == 0) {\n        dst.x[k] = j;\n        dst.y[k] = j;\n        ++k;\n      }\n    }\n  }\n  while(1) {\n    for(int i = 0, k = 0; i < H; ++i) {\n      for(int j = abs(2-i); j < W-abs(2-i); ++j) {\n        cin >> src.g[i][j];\n        if(src.g[i][j] == -1) return 0;\n        if(src.g[i][j] == 0) {\n          src.x[k] = j;\n          src.y[k] = i;\n          ++k;\n        }\n      }\n    }\n    int res = bfs2(src, bfs1(dst));\n    if(res == -1) cout << \"NA\" << endl;\n    else cout << res << endl;\n  }\n  return 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include <iostream>\n#include <algorithm>\n#include <map>\n#include <set>\n#include <queue>\n#include <stack>\n#include <numeric>\n#include <bitset>\n#include <cmath>\n\nstatic const int MOD = 1000000007;\nusing ll = long long;\nusing u32 = unsigned;\nusing u64 = unsigned long long;\nusing namespace std;\n\ntemplate<class T> constexpr T INF = ::numeric_limits<T>::max()/32*15+208;\n\ntemplate <class T, class U>\nvector<T> make_v(U size, const T& init){ return vector<T>(static_cast<size_t>(size), init); }\n\ntemplate<class... Ts, class U>\nauto make_v(U size, Ts... rest) { return vector<decltype(make_v(rest...))>(static_cast<size_t>(size), make_v(rest...)); }\n\ntemplate<class T> void chmin(T &a, const T &b){ a = (a < b ? a : b); }\ntemplate<class T> void chmax(T &a, const T &b){ a = (a > b ? a : b); }\n\nint main() {\n    vector<vector<int>> G{{2},{2, 5},{0, 1, 3, 6},{2, 7},{5},{1, 4, 6, 9},{2, 5, 7, 10},{3, 6, 8, 11},{7},{5, 10},{6, 9, 11, 12},{7, 10},{10}};\n    vector<int> y{0, 1, 1, 1, 2, 2, 2, 2, 2, 3, 3, 3, 4}, x{2, 1, 2, 3, 0, 1, 2, 3, 4, 1, 2, 3, 2};\n    using P = array<int, 13>;\n    P v{};\n    iota(v.begin(), v.end(), 0);\n    v.back() = 0;\n    map<P, int> A;\n    auto dfs1 = [&](int a, int b, int cur, auto &&f) -> void {\n        if(!A.count(v)) A[v] = cur;\n        else chmin(A[v], cur);\n        if(cur >= 5) return;\n        for (auto &&j : G[a]) {\n            if(j != b){\n                swap(v[a], v[j]);\n                f(j, b, cur+1, f);\n                swap(v[a], v[j]);\n            }\n        }\n        for (auto &&j : G[b]) {\n            if(j != a){\n                swap(v[b], v[j]);\n                f(a, j, cur+1, f);\n                swap(v[b], v[j]);\n            }\n        }\n        return;\n    };\n    dfs1(0, 12, 0, dfs1);\n    while(cin >> v[0], ~v[0]){\n        for (int i = 1; i < 13; ++i) cin >> v[i];\n        int ans = 21;\n        auto dfs = [&](int cur, auto &&f) -> void {\n            if(cur+5 >= ans) return;\n            if(A.count(v)) {\n                chmin(ans, A[v]+cur);\n                return;\n            }\n            int d = 0, a = -1, b = -1;\n            for (int i = 0; i < 13; ++i) {\n                if(v[i]) d += abs(y[i]-y[v[i]])+abs(x[i]-x[v[i]]);\n                else if(!~a) a = i;\n                else b = i;\n            }\n            if(d+cur >= ans) return;\n            for (auto &&j : G[a]) {\n                if(j != b){\n                    swap(v[a], v[j]);\n                    f(cur+1, f);\n                    swap(v[a], v[j]);\n                }\n            }\n            for (auto &&j : G[b]) {\n                if(j != a){\n                    swap(v[b], v[j]);\n                    f(cur+1, f);\n                    swap(v[b], v[j]);\n                }\n            }\n\n        };\n        dfs(0, dfs);\n        if(ans == 21) puts(\"NA\");\n        else cout << ans << \"\\n\";\n    }\n    return 0;\n}\n"
  },
  {
    "language": "C++",
    "code": "#include <iostream>\n#include <string>\n#include <vector>\n#include <queue>\n#include <map>\nusing namespace std;\n\nstring s = \"0123456789AB\";\nstring goal = \"0123456789AB0\";\n\nvector<vector<int>> adj = {\n    {2},\n    {2,5},\n    {0,1,3,6},\n    {2,7},\n    {5},\n    {1,4,6,9},\n    {2,5,7,10},\n    {3,6,8,11},\n    {7},\n    {5,10},\n    {6,9,11,12},\n    {7,10},\n    {10}\n};\n\nint solve(string stat) {\n    if (stat == goal) return 0;\n    map<string, int> dist;\n    dist[stat] = 0;\n    queue<string> q;\n    q.push(stat);\n    while ( ! q.empty()) {\n        string s = q.front();\n        q.pop();\n        for (int i=0; i<13; ++i) {\n            if (s[i] != '0') continue;\n            for (int j : adj[i]) {\n                string next = s;\n                next[i] = s[j];\n                next[j] = s[i];\n                int diff = 0;\n                for (int k=0; k<13; ++k) {\n                    diff += next[k] != goal[k];\n                }\n                if ( ! diff) {\n                    return dist[s] + 1;\n                }\n                if (dist.find(next) == dist.end() && dist[s] + diff - 1 <= 20) {\n                    q.push(next);\n                    dist[next] = dist[s] + 1;\n                }\n            }\n        }\n    }\n    return 21;\n}\n\nint main() {\n    while (1) {\n        string stat = \"\";\n        int k;\n        for (int i=0; i<13; ++i) {\n            if (cin >> k && !~k) return 0;\n            stat += s[k];\n        }\n        int ans = solve(stat);\n        if (ans <= 20) {\n            cout << ans << endl;\n            continue;\n        }\n        cout << \"NA\" << endl;\n    }\n    return 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include <vector>\n#include <list>\n#include <map>\n#include <set>\n#include <deque>\n#include <queue>\n#include <stack>\n#include <bitset>\n#include <algorithm>\n#include <functional>\n#include <numeric>\n#include <utility>\n#include <sstream>\n#include <iostream>\n#include <iomanip>\n#include <cstdio>\n#include <cmath>\n#include <cstdlib>\n#include <cctype>\n#include <string>\n#include <cstring>\n#include <ctime>\n\nusing namespace std;\n\ninline int toInt(string s) {int v; istringstream sin(s);sin>>v;return v;}\ntemplate<class T> inline string toString(T x) {ostringstream sout;sout<<x;return sout.str();}\ntemplate<class T> inline T sqr(T x) {return x*x;}\n\ntypedef vector<int> vi;\ntypedef vector<vi> vvi;\ntypedef vector<string> vs;\ntypedef pair<int, int> pii;\ntypedef long long ll;\n\n#define all(a)  (a).begin(),(a).end()\n#define rall(a) (a).rbegin(), (a).rend()\n#define pb push_back\n#define mp make_pair\n#define each(i,c) for(typeof((c).begin()) i=(c).begin(); i!=(c).end(); ++i)\n#define exist(s,e) ((s).find(e)!=(s).end())\n#define range(i,a,b) for(int i=(a);i<(b);++i)\n#define rep(i,n)  range(i,0,n)\n#define clr(a,b) memset((a), (b) ,sizeof(a))\n#define dump(x)  cerr << #x << \" = \" << (x) << endl;\n#define debug(x) cerr << #x << \" = \" << (x) << \" (L\" << __LINE__ << \")\" << \" \" << __FILE__ << endl;\n\nconst double eps = 1e-10;\nconst double pi  = acos(-1.0);\nconst ll inf =1LL << 62;\n\ntypedef  pair<string,int> P;\n\nmap <string,int> ans;\n\nvoid bfs(void){\n\tstring ini=\"0123456789ab0\";\n\tP init;\n\tinit.first=ini;\n\tinit.second=0;\n\tqueue<P> q;\n\tq.push(init);\n\twhile(!q.empty()){\n\t\tP cur;\n\t\tcur=q.front();q.pop();\n\t//\tcout << cur.first << endl;\n\t\tif(cur.second>=11)\n\t\t\tcontinue;\n\t\t\n\t\tif(ans.find(cur.first)==ans.end())\n\t\t\tans[cur.first]=cur.second;\n\t\telse\n\t\t\tcontinue;\n\t\tint zero[2]={-1,-1};\n\t\trep(i,13){\n\t\t\tif(zero[0]==-1&&cur.first[i]=='0')\n\t\t\t\tzero[0]=i;\n\t\t\telse if(zero[1]==-1&&cur.first[i]=='0')\n\t\t\t\tzero[1]=i;\n\t\t}\n\t\trep(i,2){\n\t\t\tstring tar;\n\t\t\tP next;\n\t\t\tint check=zero[i];\n\t\t\tif(check%4){\n\t\t\t\tint d[4]={-4,-1,4,1};\n\t\t\t\trep(j,4){\n\t\t\t\t\tif(j==0&&(check==1||check==3))\n\t\t\t\t\t\tcontinue;\n\t\t\t\t\tif(j==1&&(check==1||check==9))\n\t\t\t\t\t\tcontinue;\n\t\t\t\t\tif(j==2&&(check==9||check==11))\n\t\t\t\t\t\tcontinue;\n\t\t\t\t\tif(j==3&&(check==3||check==11))\n\t\t\t\t\t\tcontinue;\n\t\t\t\t\ttar=cur.first;\n\t\t\t\t\tint index=check+d[j];\n\t\t\t\t\tindex=max(index,0);\n\t\t\t\t\tindex=min(index,12);\n\t\t\t\t\tswap(tar[check],tar[index]);\n\t\t\t\t\tnext.first=tar;\n\t\t\t\t\tnext.second=cur.second+1;\n\t\t\t\t\tq.push(next);\n\t\t\t\t}\n\t\t\t}else{\n\t\t\t\tint d[4]={2,1,-1,-2};\n\t\t\t\ttar=cur.first;\n\t\t\t\tint index=check/4;\n\t\t\t\tswap(tar[check],tar[check+d[index]]);\n\t\t\t\tnext.first=tar;\n\t\t\t\tnext.second=cur.second+1;\n\t\t\t\tq.push(next);\n\t\t\t}\n\t\t}\n\t}\n\treturn ;\n}\n\nint bfs2(string query){\n\tmap <string,int> ans2;\n\tP init;\n\tinit.first=query;\n\tinit.second=0;\n\tqueue<P> q;\n\tq.push(init);\n\twhile(!q.empty()){\n\t\tP cur;\n\t\tcur=q.front();q.pop();\n\t//\tcout << cur.first << endl;\n\t\tif(cur.second>=11)\n\t\t\tcontinue;\n\t\tif(ans.find(cur.first)!=ans.end())\n\t\t\treturn cur.second+ans[cur.first];\n\n\t\tif(ans2.find(cur.first)==ans2.end())\n\t\t\tans2[cur.first]=cur.second;\n\t\telse\n\t\t\tcontinue;\n\t\tint zero[2]={-1,-1};\n\t\trep(i,13){\n\t\t\tif(zero[0]==-1&&cur.first[i]=='0')\n\t\t\t\tzero[0]=i;\n\t\t\telse if(zero[1]==-1&&cur.first[i]=='0')\n\t\t\t\tzero[1]=i;\n\t\t}\n\t\trep(i,2){\n\t\t\tstring tar;\n\t\t\tP next;\n\t\t\tint check=zero[i];\n\t\t\tif(check%4){\n\t\t\t\tint d[4]={-4,-1,4,1};\n\t\t\t\trep(j,4){\n\t\t\t\t\tif(j==0&&(check==1||check==3))\n\t\t\t\t\t\tcontinue;\n\t\t\t\t\tif(j==1&&(check==1||check==9))\n\t\t\t\t\t\tcontinue;\n\t\t\t\t\tif(j==2&&(check==9||check==11))\n\t\t\t\t\t\tcontinue;\n\t\t\t\t\tif(j==3&&(check==3||check==11))\n\t\t\t\t\t\tcontinue;\n\t\t\t\t\ttar=cur.first;\n\t\t\t\t\tint index=check+d[j];\n\t\t\t\t\tindex=max(index,0);\n\t\t\t\t\tindex=min(index,12);\n\t\t\t\t\tswap(tar[check],tar[index]);\n\t\t\t\t\tnext.first=tar;\n\t\t\t\t\tnext.second=cur.second+1;\n\t\t\t\t\tq.push(next);\n\t\t\t\t}\n\t\t\t}else{\n\t\t\t\tint d[4]={2,1,-1,-2};\n\t\t\t\ttar=cur.first;\n\t\t\t\tint index=check/4;\n\t\t\t\tswap(tar[check],tar[check+d[index]]);\n\t\t\t\tnext.first=tar;\n\t\t\t\tnext.second=cur.second+1;\n\t\t\t\tq.push(next);\n\t\t\t}\n\t\t}\n\t}\n\treturn -1;\n}\n\nint main(void){\n\tbfs();\n\tint input[13];\n\twhile(cin >> input[0],input[0]!=-1){\n\t\tfor(int i=1;i<13;i++)\n\t\t\tcin >> input[i];\n\t\tstring query=\"\";\n\t\trep(i,13){\n\t\t\tif(input[i]>=10)\n\t\t\t\tquery+=((input[i]-10)+'a');\n\t\t\telse\n\t\t\t\tquery+=(input[i]+'0');\n\t\t}\n\t\tint answer=bfs2(query);\n\t\tif(answer==-1)\n\t\t\tcout << \"NA\" << endl;\n\t\telse\n\t\t\tcout << answer << endl;\n\t}\n\treturn 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include <queue>\n#include <vector>\n#include <iostream>\n#include <algorithm>\nusing namespace std;\nconst int lim = 20;\nconst vector<int> bx = { 0, 4, 1, 1, 1, 2, 2, 2, 2, 2, 3, 3, 3 };\nconst vector<int> by = { 2, 2, 1, 2, 3, 0, 1, 2, 3, 4, 1, 2, 3 };\nstruct state {\n\tvector<int> px, py;\n\tint cost, rem, last1, last2;\n};\nbool operator<(const state& s1, const state& s2) {\n\treturn s1.cost + s1.rem != s2.cost + s2.rem ? s1.cost + s1.rem > s2.cost + s2.rem : s1.rem > s2.rem;\n}\nint eval(vector<int> px, vector<int> py) {\n\tint ret = 0;\n\tfor (int i = 2; i < 13; ++i) {\n\t\tret += abs(px[i] - bx[i]) + abs(py[i] - by[i]);\n\t}\n\treturn ret;\n}\nint main() {\n\tint x;\n\twhile (cin >> x, x != -1) {\n\t\tvector<int> vx(13), vy(13);\n\t\tint zc = 0;\n\t\tvx[x == 0 ? zc : x + 1] = bx[0];\n\t\tvy[x == 0 ? zc : x + 1] = by[0];\n\t\tif (x == 0) ++zc;\n\t\tfor (int i = 1; i < 13; ++i) {\n\t\t\tcin >> x;\n\t\t\tvx[x == 0 ? zc : x + 1] = bx[i == 12 ? 1 : i + 1];\n\t\t\tvy[x == 0 ? zc : x + 1] = by[i == 12 ? 1 : i + 1];\n\t\t\tif (x == 0) ++zc;\n\t\t}\n\t\tpriority_queue<state> que;\n\t\tque.push(state{ vx, vy, 0, eval(vx, vy), -1, -1 });\n\t\tint ans = -1;\n\t\twhile (!que.empty()) {\n\t\t\tstate u = que.top();\n\t\t\tque.pop();\n\t\t\tif (u.rem == 0) {\n\t\t\t\tans = u.cost;\n\t\t\t\tbreak;\n\t\t\t}\n\t\t\tcout << u.cost + u.rem << ' ' << u.rem << '\\n';\n\t\t\tfor (int i = 0; i < 2; ++i) {\n\t\t\t\tfor (int j = 2; j < 13; ++j) {\n\t\t\t\t\tif (i == u.last1 && j == u.last2) continue;\n\t\t\t\t\tif (abs(u.px[i] - u.px[j]) + abs(u.py[i] - u.py[j]) == 1) {\n\t\t\t\t\t\tswap(u.px[i], u.px[j]);\n\t\t\t\t\t\tswap(u.py[i], u.py[j]);\n\t\t\t\t\t\tint ev = eval(u.px, u.py);\n\t\t\t\t\t\tif (u.cost + ev + 1 <= lim) {\n\t\t\t\t\t\t\tque.push(state{ u.px, u.py, u.cost + 1, eval(u.px, u.py), i, j });\n\t\t\t\t\t\t}\n\t\t\t\t\t\tswap(u.px[i], u.px[j]);\n\t\t\t\t\t\tswap(u.py[i], u.py[j]);\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t\tif (ans != -1) cout << ans << endl;\n\t\telse cout << \"NA\" << endl;\n\t}\n\treturn 0;\n}\n"
  },
  {
    "language": "C++",
    "code": "#include<cstdio>\n#include<algorithm>\n#include<iostream>\n#include<queue>\n#include<functional>\n#include<map>\n#include<vector>\nusing namespace std;\nclass P{\n    public:\n    int state[13];\n    int cnt;\n    int p1;\n    int p2;\n    P(){}\n    P(int a[13],int cnt,int p1,int p2):cnt(cnt),p1(p1),p2(p2){\n        for(int i = 0; i < 13; i++){\n            state[i] = a[i];\n        }\n    }\n};\nint rules[13][6]={\n    {1,2},{2,2,5},{4,0,1,3,6},{2,2,7},{1,5},\n    {4,1,4,6,9},{4,2,5,7,10},{4,3,6,8,11},{1,7},{2,5,10},\n    {4,6,9,11,12},{2,7,10},{1,10}\n};\n \nmap< string , int >memo;\n \nstring getIndex(int *a){\n    string tmp=\"\";\n    for(int i = 0; i < 13; i++){\n        tmp += (a[i]+48);\n    }\n    return tmp;\n}\n \nvoid bfs(){\n    int F[] = {0,1,2,3,4,5,6,7,8,9,10,11,0};\n    queue < P > Q;\n    Q.push(P(F,1,0,12));\n    while( true ){\n        if(Q.size() == 0)break;\n        P p = Q.front();Q.pop();\n        if(p.cnt > 21)break;\n        string index = getIndex(p.state);\n        if( memo[index] )continue;\n        memo[index] = p.cnt;\n        for(int j = 0; j < rules[p.p1][0]; j++){\n            if(p.state[rules[p.p1][j+1]] == 0)continue;\n            swap(p.state[p.p1],p.state[rules[p.p1][j+1]]);\n            Q.push(P(p.state,p.cnt+1,p.state[p.p1],p.p2));\n            swap(p.state[p.p1],p.state[rules[p.p1][j+1]]);\n        }\n        for(int j = 0; j < rules[p.p2][0]; j++){\n            if(p.state[rules[p.p2][j+1]] == 0)continue;\n            swap(p.state[p.p2],p.state[rules[p.p2][j+1]]);\n            Q.push(P(p.state,p.cnt+1,p.p1,p.state[p.p2]));\n            swap(p.state[p.p2],p.state[rules[p.p2][j+1]]);\n        }\n    }\n    return ;\n}\nint main(){\n    bfs();\n    int input[13];\n    while(true){\n        scanf(\"%d\",&input[0]);\n        if(input[0] == -1)break;\n        for(int i = 1; i < 13; i++){\n            scanf(\"%d\",&input[i]);\n        }\n        string index = getIndex(input);\n        if( memo[index] )printf(\"%d\\n\",memo[index]-1);\n        else puts(\"NA\");\n    }\n    return 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include <iostream>\n#include <vector>\n#include <algorithm>\n#include <string>\n#include <sstream>\n#include <cstring>\n#include <cstdio>\n#include <cstdlib>\n#include <cmath>\n#include <queue>\n#include <stack>\n#include <map>\n#include <set>\n#include <numeric>\n#include <cctype>\n#include <tuple>\n\n#ifdef _MSC_VER\n#include <agents.h>\n#endif\n\n#define FOR(i, a, b) for(int i = (a); i < (int)(b); ++i)\n#define rep(i, n) FOR(i, 0, n)\n#define ALL(v) v.begin(), v.end()\n#define REV(v) v.rbegin(), v.rend()\n#define MEMSET(v, s) memset(v, s, sizeof(v))\n#define X first\n#define Y second\n\nusing namespace std;\n\ntypedef long long ll;\ntypedef pair<int, int> P;\n\nconst int N = 0;\n\ninline int dist(int x1, int y1, int x2, int y2){\n\treturn abs(x1 - x2) + abs(y1 - y2);\n}\n\ninline bool valid(int x, int y){\n\treturn abs(x - 2) + abs(y - 2) <= 2;\n}\n\nvoid decode(ll x);\n\nll mov(ll state, int zero, int to){\n\tll mask = 15ll << to*4;\n\tmask &= state;\n\tstate ^= mask;\n\tint d = to - zero;\n\tif (d < 0) state |= mask << -d*4;\n\telse state |= mask >> d*4;\n\treturn state;\n}\n\nvoid decode(ll x){\n\tvector<string> vs;\n\trep(i, 5){\n\t\tstring s;\n\t\trep(j, 5){\n\t\t\tif (valid(j, i)){\n\t\t\t\tint tmp = x & 15;\n\t\t\t\ts += \" \";\n\t\t\t\ts += '0' + tmp % 10;\n\t\t\t\ts += '0' + tmp / 10;\n\t\t\t\tx >>= 4;\n\t\t\t}\n\t\t\telse{\n\t\t\t\ts += \" ..\";\n\t\t\t}\n\t\t}\n\t\tvs.push_back(string(REV(s)));\n\t}\n\treverse(ALL(vs));\n\tfor (auto &s : vs){\n\t\tcout << s << endl;\n\t}\n}\n\nint mat[5][5];\n\nstruct state{\n\tll enc;\n\tint d;\n\tint pos[2];\n\tstate(ll e, int p0, int p1, int d) :enc(e), d(d){ pos[0] = p0, pos[1] = p1; };\n};\n\nint main(){\n\n\tint pos = 0;\n\tvector<vector<int>> adj;\n\t{\n\t\tint tmp = 0;\n\t\trep(i, 5) rep(j, 5) if (valid(j, i)) mat[i][j] = tmp++;\n\t}\n\trep(i, 5) rep(j, 5){\n\t\tvector<int> v;\n\t\tif (!valid(j, i)) continue;\n\t\trep(k, 5) rep(l, 5){\n\t\t\tif (!valid(l, k)) continue;\n\t\t\tif (dist(j, i, l, k) != 1) continue;\n\t\t\tv.push_back(mat[k][l]);\n\t\t}\n\t\tadj.push_back(v);\n\t}\n\n\tll init = 0;\n\tint tmp = 0;\n\trep(i, 5) rep(j, 5){\n\t\tif (!valid(j, i)) continue;\n\t\tinit <<= 4;\n\t\tinit |= (tmp++) % 12;\n\t}\n\n\tmap<ll, int> m;\n\tm[init] = 0;\n\tqueue<state> q;\n\tq.push({ init, 0, 12, 0 });\n\twhile (!q.empty()){\n\t\tstate s = q.front();\n\t\tq.pop();\n\n\t\trep(i, 2){\n\t\t\tfor (auto to : adj[s.pos[i]]){\n\t\t\t\tll nxt = mov(s.enc, s.pos[i], to);\n\t\t\t\tif (m.count(nxt)) continue;\n\t\t\t\tm[nxt] = s.d + 1;\n\t\t\t\tif (s.d + 1 < 10) q.push({ nxt, s.pos[!i], to, s.d + 1 });\n\t\t\t}\n\t\t}\n\t}\n\n\tll x;\n\twhile (cin >> x, ~x){\n\t\tvector<int> zero;\n\t\tint in;\n\t\trep(i, 12){\n\t\t\tcin >> in;\n\t\t\tx = (x << 4) + in;\n\t\t\tif (!in) zero.push_back(i + 1);\n\t\t}\n\t\tif (zero.size() <= 1) zero.push_back(0);\n\t\t//decode(x);\n\n\t\tset<ll> vis;\n\t\tqueue<state> q;\n\t\tq.push({ x, zero[0], zero[1], 0 });\n\t\tint ans = -1;\n\t\tif (m.count(x)){\n\t\t\tans = m[x];\n\t\t}\n\t\telse\n\t\twhile (!q.empty()){\n\t\t\tstate s = q.front();\n\t\t\tq.pop();\n\n\t\t\trep(i, 2){\n\t\t\t\tfor (auto to : adj[s.pos[i]]){\n\t\t\t\t\tll nxt = mov(s.enc, s.pos[i], to);\n\t\t\t\t\tif (vis.count(nxt)) continue;\n\t\t\t\t\tvis.insert(nxt);\n\t\t\t\t\tif (m.count(nxt)){\n\t\t\t\t\t\tans = s.d + m[nxt] + 1;\n\t\t\t\t\t\tgoto end;\n\t\t\t\t\t}\n\t\t\t\t\tif (s.d + 1 < 10) q.push({ nxt, s.pos[!i], to, s.d + 1 });\n\t\t\t\t}\n\t\t\t}\n\t\t}\nend:\n\t\tif (ans >= 0) cout << ans << endl;\n\t\telse cout << \"NA\" << endl;\n\t}\n\n\n\treturn 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include<bits/stdc++.h>\n#define int long long\n#define r(i,n) for(int i=0;i<n;i++)\nusing namespace std;\ntypedef pair<int,int>P;\nvector<int>v[13],s(13),t(13);\nmap<int,int>m;\n\nint has[14];\n\n\nvoid init(){\n\n    v[0].push_back(2);\n\n    v[1].push_back(2);\n    v[1].push_back(5);\n\n    v[2].push_back(0);\n    v[2].push_back(1);\n    v[2].push_back(3);\n    v[2].push_back(6);\n\n    v[3].push_back(2);\n    v[3].push_back(7);\n\n    v[4].push_back(5);\n\n    v[5].push_back(1);\n    v[5].push_back(4);\n    v[5].push_back(6);\n    v[5].push_back(9);\n\n    v[6].push_back(2);\n    v[6].push_back(5);\n    v[6].push_back(7);\n    v[6].push_back(10);\n\n    v[7].push_back(3);\n    v[7].push_back(6);\n    v[7].push_back(8);\n    v[7].push_back(11);\n\n    v[8].push_back(7);\n\n    v[9].push_back(5);\n    v[9].push_back(10);\n\n    v[10].push_back(6);\n    v[10].push_back(9);\n    v[10].push_back(11);\n    v[10].push_back(12);\n\n    v[11].push_back(7);\n    v[11].push_back(10);\n\n    v[12].push_back(10);\n\n    int a=20;\n    int p=1;\n\n    r(i,13){\n        has[i]=p;\n        p*=a;\n    }\n}\n\nint ha(vector<int> &x){\n\n    int re=0;\n\n    r(i,13){\n        re+=x[i]*has[i];\n    }\n\n    return re;\n}\n\nvector<int> ah(int x){\n    vector<int>y(13);\n    r(i,13){\n        y[i]=x%20;\n        x/=20;\n    }\n    return y;\n}\n\nvoid BFS1(){\n    s[0]=0;\n    s[12]=0;\n    r(i,11)s[i+1]=i+1;\n    set<int>st;\n    st.insert(ha(s));\n    m[ha(s)]=0;\n    queue<P>q;\n    q.push(P(ha(s),0));\n    while(1){\n        vector<int> now=ah(q.front().first);\n        int cost=q.front().second;\n        q.pop();\n        if(cost==6)break;\n        r(i,13)if(now[i]!=0){\n            r(j,v[i].size()){\n                swap(now[i],now[v[i][j]]);\n                if(!st.count(ha(now))){\n                    st.insert(ha(now));\n                    m[ha(now)]=cost+1;\n                    q.push(P(ha(now),cost+1));\n                }\n                swap(now[i],now[v[i][j]]);\n            }\n        }\n    }\n}\n\nvoid BFS2(){\n    set<int>st;\n    st.insert(ha(t));\n    queue<P>q;\n    q.push(P(ha(t),0));\n    while(1){\n        vector<int>now=ah(q.front().first);\n        int cost=q.front().second;\n        if(m.count(ha(now))){\n            cout<<m[ha(now)]+cost<<endl;\n            return ;\n        }\n        q.pop();\n        if(cost==6)break;\n        r(i,13)if(now[i]!=0){\n            r(j,v[i].size()){\n                swap(now[i],now[v[i][j]]);\n                if(!st.count(ha(now))){\n                    st.insert(ha(now));\n                    q.push(P(ha(now),cost+1));\n                }\n                swap(now[i],now[v[i][j]]);\n            }\n        }\n    }\n    cout<<\"NA\"<<endl;\n}\n\n\nsigned main(){\n    init();\n    BFS1();\n    while(cin>>t[0],t[0]!=-1){\n        r(i,12)cin>>t[i+1];\n        BFS2();\n    }\n}\n"
  },
  {
    "language": "C++",
    "code": "#include<iostream>\n#include<algorithm>\n#include<vector>\n#include<stack>\n#include<queue>\n#include<cstdio>\n#include<climits>\n#include<cmath>\n#include<cstring>\n#include<set>\n#include<string>\n\n#define f first\n#define s second\n#define mp make_pair\n\n#define REP(i,n) for(int i=0; i<(int)(n); i++)\n#define FOR(i,c) for(__typeof((c).begin()) i=(c).begin(); i!=(c).end(); i++)\n#define ALL(c) (c).begin(), (c).end()\n\nusing namespace std;\n\ntypedef unsigned int uint;\ntypedef long long ll;\ntypedef unsigned long long ull;\n\nstruct pzl{\n  ull l;\n  pzl() : l(0) {}\n  pzl(ull a) : l(a) {}\n  inline int get(int i) const{\n    return (int)((l >> (4*i)) & 0xF);\n  }\n  inline ull mask(int i) const{\n    return l & ((ull)(0xF) << (4*i));\n  }\n  inline void set(int i, int n){\n    l ^= mask(i);\n    l |= ((long long)n << (4*i));\n  }\n  inline void swap(int i, int j){\n    int a = get(i), b = get(j);\n    set(i,b); set(j,a);\n  }\n  inline bool operator < (const pzl &a) const{\n    return l < a.l;\n  }\n  inline bool operator == (const pzl &a) const{\n    return l == a.l;\n  }\n  void print(){\n    REP(i,13) printf(\"%2d \",get(i));\n    puts(\"\");\n  }\n};\n\nint main(){\n  pzl ans;\n  REP(i,12) ans.set(i,i);\n  while(true){\n    pzl init;\n    int a;\n    scanf(\"%d\",&a);\n    if(a == -1) break;\n    init.set(0,a);\n    REP(i,12){ scanf(\"%d\",&a); init.set(i+1,a); }\n    \n    //init.print();\n    queue<pair<int,pzl> > q; q.push(mp(0,init));\n    set<ull> s;   s.insert(init.l);\n    while(q.size()){\n      int cnt = q.front().f;\n      pzl p   = q.front().s;\n      //printf(\"cnt: %d\\n\",cnt);\n      //p.print();\n      if(p == ans){\n\tprintf(\"%d\\n\",cnt);\n\tbreak;\n      }\n\n      q.pop();\n\n      if(cnt >= 20) continue;\n      REP(i,13){\n\tint g = p.get(i);\n\tif(g == 0){\n\t  pzl tmp = p;\n#define SP(s,q,tmp) do{if(s.find(tmp.l) == s.end()){ s.insert(tmp.l); q.push(mp(cnt+1,tmp)); }}while(false)\n\t  switch(i){\n\t  case 0:  tmp.swap(0,2); SP(s,q,tmp); break;\n\t  case 1:  tmp.swap(1,2); SP(s,q,tmp); tmp = p; tmp.swap(1,5); SP(s,q,tmp); break;\n\t  case 2:  tmp.swap(2,0); SP(s,q,tmp); tmp = p; tmp.swap(2,1); SP(s,q,tmp); tmp = p; tmp.swap(2,3); SP(s,q,tmp); tmp = p; tmp.swap(2,6); SP(s,q,tmp); break;\n\t  case 3:  tmp.swap(3,2); SP(s,q,tmp); tmp = p; tmp.swap(3,7); SP(s,q,tmp); break;\n\t  case 4:  tmp.swap(4,5); SP(s,q,tmp); break;\n\t  case 5:  tmp.swap(5,1); SP(s,q,tmp); tmp = p; tmp.swap(5,4); SP(s,q,tmp); tmp = p; tmp.swap(5,6); SP(s,q,tmp); tmp = p; tmp.swap(5,9); SP(s,q,tmp); break;\n\t  case 6:  tmp.swap(6,2); SP(s,q,tmp); tmp = p; tmp.swap(6,5); SP(s,q,tmp); tmp = p; tmp.swap(6,7); SP(s,q,tmp); tmp = p; tmp.swap(6,10);SP(s,q,tmp); break;\n\t  case 7:  tmp.swap(7,3); SP(s,q,tmp); tmp = p; tmp.swap(7,6); SP(s,q,tmp); tmp = p; tmp.swap(7,8); SP(s,q,tmp); tmp = p; tmp.swap(7,11);SP(s,q,tmp); break;\n\t  case 8:  tmp.swap(8,7); SP(s,q,tmp); break; \n\t  case 9:  tmp.swap(9,5); SP(s,q,tmp); tmp = p; tmp.swap(9,10);SP(s,q,tmp); break;\n\t  case 10: tmp.swap(10,6);SP(s,q,tmp); tmp = p; tmp.swap(10,9);SP(s,q,tmp); tmp = p;tmp.swap(10,11);SP(s,q,tmp); tmp = p;tmp.swap(10,12);SP(s,q,tmp); break;\n\t  case 11: tmp.swap(11,7);SP(s,q,tmp); tmp = p;tmp.swap(11,10);SP(s,q,tmp); break;\n\t  case 12: tmp.swap(12,10);SP(s,q,tmp);break;\n\t  }\n\t}\n      }\n    }\n    if(q.empty())\n      printf(\"NA\\n\");\n  }\n  return 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include <stdlib.h>\nusing namespace std;\n\nint p[5][5],x[11]={1,2,3,0,1,2,3,4,1,2,3},y[11]={1,1,1,2,2,2,2,2,3,3,3},s,sx[2],sy[2]\n    ,mx[4]={1,0,-1,0},my[4]={0,-1,0,1},lt;\nint search(int t,int mx2,int my2,int mc) {\n\tint a,i,j,x2,y2,s2;\n\tif (s==0) { if (lt>t) lt=t; return 1;}\n\t  for (i=0;i<2;i++) for (j=0;j<4;j++) {\n\t  x2=sx[i]+mx[j]; y2=sy[i]+my[j];\n\t  if (x2<0 || x2>4 || y2<0 || y2>4) continue;\n\t  if (p[y2][x2]<1 || ( mc==i  && mx2==-mx[j] && my2==-my[j])) continue;\n\t  s2=abs(x2-x[p[y2][x2]-1])+abs(y2-y[p[y2][x2]-1])-abs(sx[i]-x[p[y2][x2]-1])-abs(sy[i]-y[p[y2][x2]-1]);\n\t  if (s+s2>lt-t) continue;\n\t  p[sy[i]][sx[i]]=p[y2][x2]; p[y2][x2]=0;  s+=s2; \n\t  sx[i]=x2; sy[i]=y2;\n\t  a=search(t+1,mx[j],my[j],i);\n\t  sx[i]=x2-mx[j]; sy[i]=y2-my[j];\n\t  p[y2][x2]=p[sy[i]][sx[i]]; p[sy[i]][sx[i]]=0; s-=s2;\n\t  if (a==1) return 0;\n  }\n  return 0;\n}\n\nint main() {\n  int i,j,k;\n  for (i=0;i<5;i++) for (j=0;j<5;j++) p[i][j]=-1;\n  while (cin >> p[0][2] && p[0][2]!=-1) {\n\t  cin >> p[1][1] >> p[1][2] >> p[1][3];\n\t  cin >> p[2][0] >> p[2][1] >> p[2][2] >> p[2][3] >> p[2][4];\n\t  cin >> p[3][1] >> p[3][2] >> p[3][3];\n\t  cin >> p[4][2]; k=0; s=0;\n\t  for (i=0;i<5;i++) for (j=0;j<5;j++) {\n\t\t  if (p[i][j]==0) { sx[k++]=j; sy[k++]=i;}\n\t\t  if (p[i][j]>0) s+=abs(j-x[p[i][j]-1])+abs(i-y[p[i][j]-1]);\n\t\t   }\n\t  lt=21;\t   \n\t  search(0,0,0,0);\n\t  if (lt==21) cout << \"NA\" << endl; else cout << lt << endl;\n  } \n return 0;\n}\t"
  },
  {
    "language": "C++",
    "code": "#include <iostream>\n#include <algorithm>\n#include <vector>\n#include <queue>\n#include <map>\nusing namespace std;\n#define rep(i,n) for(int i=0;i<n;i++)\nclass NODE{\npublic:\n\tvector<int> data;\n\tint depth;\n\tint e[2];\n\tNODE(int a[13],int d,int E[2]){\n\t\tdata.resize(13);\n\t\trep(i,13)data[i] = a[i];\n\t\tdepth = d;\n\t\trep(i,2)e[i] = E[i];\n\t}\n\tNODE(){\n\t\tdepth = 0;\n\t\tdata.resize(13);\n\t}\n};\n\nint di[13][10] = {\n\t{2,-1},\n\t{2,5,-1},\n\t{0,1,3,6,-1},\n\t{2,7,-1},\n\t{5,-1},\n\t{1,4,6,9,-1},\n\t{2,5,7,10,-1},\n\t{3,6,7,11,-1},\n\t{7},\n\t{5,10,-1},\n\t{6,9,11,12,-1},\n\t{7,10,-1},\n\t{10,-1}\n};\nint rx[] = {3,2,3,4,1,2,3,4,5,2,3,4,3};\nint ry[] = {1,2,2,2,3,3,3,3,3,4,4,4,5};\n\nint main(){\n\twhile(1){\n\t\tint ret = 21;\n\t\tNODE fst; int cnt = 0;\n\t\trep(i,13){\n\t\t\tif(cin >>fst.data[i] , fst.data[i] != -1){\n\t\t\t\tif(fst.data[i] == 0){\n\t\t\t\t\tfst.e[cnt] = i;\n\t\t\t\t\tcnt++;\n\t\t\t\t}\n\t\t\t}else{\n\t\t\t\treturn 0;\n\t\t\t}\n\t\t}\n\t\tmap< vector<int> , int > done[2];\n\t\t\n\t\trep(x,2){\n\t\t\tqueue<NODE> Q;\n\t\t\tif(x==0){\n\t\t\t\tQ.push(fst);\n\t\t\t}else{\n\t\t\t\tNODE a;\n\t\t\t\trep(i,11)a.data[i+1] = i+1;\n\t\t\t\ta.e[0] = 0;\n\t\t\t\ta.e[1] = 12;\n\t\t\t\tQ.push(a);\n\t\t\t}\t\n\t\t\tdone[x][Q.front().data] = 0;\n\t\t\twhile(Q.size()){\n\t\t\t\tNODE q = Q.front(); Q.pop();\n\t\t\t\tint mndist = 0;\n\t\t\t\trep(i,13)mndist += abs(rx[q.data[i]]-rx[i]) + abs(ry[q.data[i]]-ry[i]);\n\t\t\t\t\n\t\t\t\tif(mndist > 30)continue;\n\t\t\t\t\n\t\t\t\tif(x == 1){\n\t\t\t\t\tif( done[0].find(q.data) != done[0].end() ){\n\t\t\t\t\t\tret = q.depth + done[0][q.data] ;\n\t\t\t\t\t\tbreak;\n\t\t\t\t\t}\n\t\t\t\t}else{\n\t\t\t\t\tif( q.data[0] == 0 && q.data[1] == 1 && q.data[2] == 2 && q.data[3] == 3 && q.data[4] == 4 && q.data[5] == 5 && q.data[6] == 6 && q.data[7] == 7 &&\n\t\t\t\t\t\t\tq.data[8] == 8 && q.data[9] == 9 && q.data[10]==10 && q.data[11]==11 && q.data[12]==0\n\t\t\t\t\t){\n\t\t\t\t\t\tret = q.depth;\n\t\t\t\t\t\tbreak;\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t\tif(q.depth >= 10)continue;\n\n\t\t\t\trep(o,2){\n\t\t\t\t\tfor(int i=0;di[q.e[o]][i] != -1;i++){\n\t\t\t\t\t\tNODE next = q;\n\t\t\t\t\t\tnext.e[o] = next.data[di[q.e[o]][i]];\n\t\t\t\t\t\tswap(next.data[q.e[o]] , next.data[di[q.e[o]][i]]);\n\t\t\t\t\t\tnext.depth = q.depth + 1;\n\t\t\t\t\t\t\n\t\t\t\t\t\tif( done[x].find(next.data) == done[x].end() ){\n\t\t\t\t\t\t\tdone[x][next.data] = next.depth;\n\t\t\t\t\t\t\tQ.push(next);\n\t\t\t\t\t\t}\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t\tif(ret > 20){\n\t\t\tcout << \"NA\" << endl;\n\t\t}else{\n\t\t\tcout << ret << endl;\n\t\t}\n\t}\n}"
  },
  {
    "language": "C++",
    "code": "#include <cstdio>\n#include <cstdlib>\n#include <cmath>\n#include <climits>\n#include <cfloat>\n#include <map>\n#include <utility>\n#include <set>\n#include <iostream>\n#include <memory>\n#include <string>\n#include <vector>\n#include <algorithm>\n#include <functional>\n#include <sstream>\n#include <complex>\n#include <stack>\n#include <queue>\n#include <cstring>\n#include <sstream>\n#include <cassert>\n#include <list>\nusing namespace std;\nstatic const double EPS = 1e-10;\ntypedef long long ll;\ntypedef pair<int,int> PI;\ntypedef vector<int> vi;\n#ifndef M_PI\n#define M_PI 3.14159265358979323846\n#endif\n#define rep(i,n) for(int i=0;i<(int)n;++i)\n#define FOR(i,c) for(__typeof((c).begin())i=(c).begin();i!=(c).end();++i)\n#define ALL(c) (c).begin(), (c).end()\n#define mp(a,b) make_pair(a,b)\n#define pb(a) push_back(a)\n#define F first\n#define S second\ntemplate <typename T> string print_array(const vector<T> &V) { ostringstream os; os << \"{ \"; for (typename vector<T>::const_iterator iter = V.begin(); iter != V.end(); ++iter) os << '\\\"' << *iter << \"\\\",\"; os << \" }\"; return os.str(); }\n\nint dx[]={0,1,0,-1},dy[]={1,0,-1,0};\n\nvector<int> se[13];\nint x[]={0,-1,0,1,-2,-1,0,1,2,-1,0,1,0};\nint y[]={2,1,1,1,0,0,0,0,0,-1,-1,-1,-2};\n\nvoid pr(ll in){\n\n  printf(\"      %3lld\\n\",in&15);\n  printf(\"   %3lld%3lld%3lld\\n\",(in>>4)&15,(in>>8)&15,(in>>12)&15);\n  printf(\"%3lld%3lld%3lld%3lld%3lld\\n\",(in>>16)&15,(in>>20)&15,(in>>24)&15,(in>>28)&15,(in>>32)&15);\n  printf(\"   %3lld%3lld%3lld\\n\",(in>>36)&15,(in>>40)&15,(in>>44)&15);\n  printf(\"      %3lld\\n\",(in>>48)&15);\n  puts(\"\");\n}\n\nint manh(ll in){\n  int ret=0;\n  rep(i,13){\n    int t=(in>>(i*4))&15;\n\n    if(!t){\n      int nx=x[t]-x[i],ny=y[t]-y[i];\n      int co=abs(nx)+abs(ny);\n      nx=x[12]-x[i],ny=y[12]-y[i];\n      int k=abs(nx)+abs(ny);\n      ret+=min(co,k);\n      continue;\n    }\n    int nx=(x[t]-x[i]),ny=y[t]-y[i];\n    ret+=abs(nx)+abs(ny);\n  }\n  return ret;\n}\n\nmain(){\n  ll p;\n\n  ll goal=0;\n  rep(i,11){\n    goal|=(i+1LL)<<(4*(i+1));\n    //cout<<goal<<endl;\n    //pr(goal);\n  }\n  //pr(goal);\n\n  se[0].pb(2);\n  se[1].pb(2);\n  se[1].pb(5);\n  se[2].pb(0);\n  se[2].pb(1);\n  se[2].pb(3);\n  se[2].pb(6);\n  se[3].pb(2);\n  se[3].pb(7);\n  se[4].pb(5);\n  se[5].pb(1);\n  se[5].pb(4);\n  se[5].pb(6);\n  se[5].pb(9);\n  se[6].pb(2);\n  se[6].pb(5);\n  se[6].pb(7);\n  se[6].pb(10);\n  se[7].pb(3);\n  se[7].pb(6);\n  se[7].pb(8);\n  se[7].pb(11);\n  se[8].pb(7);\n  se[9].pb(5);\n  se[9].pb(10);\n  se[10].pb(6);\n  se[10].pb(9);\n  se[10].pb(11);\n  se[10].pb(12);\n  se[11].pb(7);\n  se[11].pb(10);\n  se[12].pb(10);\n  \n  while(cin>>p){\n    if(p==-1)break;\n    ll in=p;\n\n    rep(i,12){\n      cin>>p;\n      in|=p<<(4*(i+1));\n    }\n\n    set<ll> app;\n\n    queue<pair<int,ll> > Q;\n    app.insert(in);\n    Q.push(mp(0,in));\n    int ans=21;\n    int mans=0;\n\n    while(!Q.empty()){\n      ll cvec=Q.front().S;\n      int ccost=Q.front().F;\n      Q.pop();\n    \n      //pr(cvec);\n\n      //if(ccost>3)break;\n     if(ccost>20)break;\n     \n      if(cvec==goal){\n\tans=ccost;\n\tbreak;\n      }\n      if(ccost+manh(cvec)>33)continue;\n      rep(i,13){\n\tll t=cvec>>(i<<2);\n\tt=t&15;\n\tif(!t){\n\t  rep(j,se[i].size()){\n\t    t=cvec>>(se[i][j]<<2);\n\t    t=t&15;\n\t    if(t){\n\t      ll nvec=cvec;\n\t      t=t<<(i<<2);\n\t      nvec|=t;\n\t      nvec&=~(15LL<<se[i][j]*4);\n\t      \n\t      if(!app.count(nvec)){\n\t\tapp.insert(nvec);\n\t\tQ.push(mp(ccost+1,nvec));\n\t      }\n\t    }\n\t  }\n\t}\n      }\n    }\n    if(ans==21)cout<<\"NA\"<<endl;\n    else cout<<ans<<endl;\n  }\n}"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\n\nusing namespace std;\n\n#define int long long\n#define FR first\n#define SC second\n#define all(v) (v).begin(), (v).end()\n#define rep(i, n) for(int i = 0; i < (int)(n); i++)\n#define reps(i, f, n) for(int i = (int)(f); i < (int)(n); i++)\n#define each(a, b) for(auto& a : b)\n\ntypedef pair<int, int> P;\n\nconst int inf = 1LL << 55;\n\nvector< vector<int> > to = {\n  {2},\n  {2, 5},\n  {0, 1, 3, 6},\n  {2, 7},\n  {5},\n  {1, 4, 6, 9},\n  {2, 5, 7, 10},\n  {3, 6, 8, 11},\n  {7},\n  {5, 10},\n  {6, 9, 11, 12},\n  {7, 10},\n  {10}\n};\n\nvector<int> ans = {0,1,2,3,4,5,6,7,8,9,10,11,0};\n\nsigned main()\n{\n  cin.tie(0);\n  ios_base::sync_with_stdio(0);\n  cout << fixed << setprecision(12);\n\n  map<vector<int>, int> D;  \n  queue< vector<int> > que;\n  que.push(ans);\n  D[ans] = 0;\n  while(!que.empty()) {\n    auto v = que.front(); que.pop();\n    if(D[v] >= 12) break;\n    rep(i, v.size()) {\n      if(v[i]) continue;\n      rep(j, to[i].size()) {\n\tint c = D[v];\n\tswap(v[i], v[to[i][j]]);\n\tif(!D.count(v)) {\n\t  que.push(v);\n\t  D[v] = c + 1;\n\t}\n\tswap(v[i], v[to[i][j]]);\t\n      }\n    }\n  }\n  \n  int p;\n  while(cin >> p, ~p) {\n    vector<int> pzl; pzl.push_back(p);\n    rep(i, 12) cin >> p, pzl.push_back(p);\n    map<vector<int>, int> d;\n    queue< vector<int> > que;\n    que.push(pzl);\n    d[pzl] = 0;\n    bool flag = false;\n    while(!que.empty() && !flag) {\n      auto v = que.front(); que.pop();\n      if(v == ans) {\n\tcout << d[v] << endl;\n\tflag = true;\n\tbreak;\n      }\n      if(d[v] >= 10) break;\n      rep(i, v.size()) {\n\tif(v[i]) continue;\n\trep(j, to[i].size()) {\n\t  int c = d[v];\n\t  swap(v[i], v[to[i][j]]);\n\t  if(d.count(v) == 0 && D.count(v) != 0) {\n\t    cout << D[v] + c + 1 << endl;\n\t    flag = true;\n\t    break;\n\t  } else if(d.count(v) == 0) {\n\t    que.push(v);\n\t    d[v] = c + 1;\n\t  }\n\t  swap(v[i], v[to[i][j]]);\n\t}\n\tif(flag) break;\n      }\n    }\n    if(!flag) cout << \"NA\" << endl;\n  }\n  return 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\n\n#ifndef INCLUDE_ZOBRIST_HASH_HPP\n#define INCLUDE_ZOBRIST_HASH_HPP\n\n#include <random>\n#include <iostream>\n#include <typeinfo>\n\nnamespace orislib {\n\ntemplate<typename T, int W, int H, int STATE>\nstruct ZobristHash {\n  typedef T hash_t;\n  ZobristHash(){\n    std::random_device rd;\n    std::mt19937 mt(rd());\n    std::uniform_int_distribution<T> dist;\n    for (int h = 0; h < H; h++){\n      for (int w = 0; w < W; w++){\n        for (int s = 0; s < STATE; s++){\n          rands[h][w][s] = dist(mt);\n        }\n      }\n    }\n  }\n  template<typename TT>\n  hash_t hash(TT data[H][W]){\n    hash_t r = 0;\n    for (int h = 0; h < H; h++){\n      for (int w = 0; w < W; w++){\n        r ^= rands[h][w][data[h][w]];\n      }\n    }\n    return r;\n  }\n  hash_t rands[H][W][STATE];\n};\n}\n\n#endif\nusing namespace std;\nusing namespace orislib;\n\ntypedef long long ll;\ntypedef long double ld;\ntypedef tuple<int, int> duo;\nconst int dx[] = {0, 0, 1, -1, 1, 1, -1, -1};\nconst int dy[] = {1, -1, 0, 0, 1, -1, 1, -1};\nconst int Mod = 1000000000 + 0;\n//{{{ templates\n#define TT_ template<typename T>inline\n#define TTF_ template<typename T,typename F>inline\nTT_ T sq(T x){return x*x;}\nTT_ T In(){T x;cin>>x;return x;}\nTT_ void Out(T&x){cout<<x;}\nTT_ void sort(T&v){sort(begin(v),end(v));}\nTT_ void revs(T&v){reverse(begin(v),end(v));}\nTT_ void uniq(T&v){sort(v);v.erase(unique(begin(v),end(v)),end(v));}\nTT_ int ubnd(T&v,typename T::value_type&x){return upper_bound(begin(v),end(v),x)-begin(v);}\nTT_ int lbnd(T&v,typename T::value_type&x){return lower_bound(begin(v),end(v),x)-begin(v);}\nTTF_ void inpt(T&v,int n,F f){for(v.reserve(n);n--;v.emplace_back(f()));}\nTTF_ void show(T&v,F f,string d=\" \",string e=\"\\n\"){int i=0;for(auto&x:v)i++&&(cout<<d),f(x);cout<<e;}\nTT_ typename T::iterator minel(T&v){return min_element(begin(v),end(v));}\nTT_ typename T::iterator maxel(T&v){return max_element(begin(v),end(v));}\n\ninline void fast_io(){ios::sync_with_stdio(0);cin.tie(0);}\ninline int in(){int x;scanf(\"%d\",&x);return x;}\ninline ll pow_mod(ll a,ll k,ll m){ll r=1;for(;k>0;a=a*a%m,k>>=1)if(k&1)r=r*a%m;return r;}\ninline ll mod_inv(ll a,ll p){return pow_mod(a,p-2,p);}\n//}}} priority_queue queue deque front stringstream max_element min_element insert count make_tuple\n\nstruct Board {\n  Board(){}\n  Board(const vector<vector<int>>& v){\n    memset(b, '#', sizeof(b));\n    for (int i = 0; i < 5; i++) b[i][5] = 0;\n    for (int i = 0; i < v[0].size(); i++) b[0][2 + i] = conv_hex(v[0][i]);\n    for (int i = 0; i < v[1].size(); i++) b[1][1 + i] = conv_hex(v[1][i]);\n    for (int i = 0; i < v[2].size(); i++) b[2][0 + i] = conv_hex(v[2][i]);\n    for (int i = 0; i < v[3].size(); i++) b[3][1 + i] = conv_hex(v[3][i]);\n    for (int i = 0; i < v[4].size(); i++) b[4][2 + i] = conv_hex(v[4][i]);\n    int it = 0;\n    for (int i = 0; i < 5; i++){\n      for (int j = 0; j < 5; j++){\n        if (b[i][j] == '0'){\n          cx[it] = j;\n          cy[it] = i;\n          it++;\n        }\n      }\n    }\n  }\n  char conv_hex(int a){\n    return \"0123456789ABCDEF\"[a];\n  }\n  bool slide(int index, int dir){\n    int px = cx[index], py = cy[index];\n    int nx = px + dx[dir], ny = py + dy[dir];\n    if (invalid(nx, ny)) return false;\n    if (b[ny][nx] == '#') return false;\n    if (b[ny][nx] == '0') return false;\n    swap(b[py][px], b[ny][nx]);\n    cx[index] = nx;\n    cy[index] = ny;\n    return true;\n  }\n  bool is_ok(){\n    static const char cb[5][6] = {\n      \"##0##\",\n      \"#123#\",\n      \"45678\",\n      \"#9AB#\",\n      \"##0##\",\n    };\n    return memcmp(cb, b, sizeof(cb)) == 0;\n  }\n  bool invalid(int x, int y){\n    return x < 0 || x >= 5 || y < 0 || y >= 5;\n  }\n  char b[5][6];\n  int cx[2], cy[2];\n};\n\nint main()\n{\n  ZobristHash<int, 6, 5, 256> zh;\n  int h;\n  while (h = in(), h != -1){\n    vector<vector<int>> vs(5);\n    vs[0].emplace_back(h);\n    inpt(vs[1], 3, in);\n    inpt(vs[2], 5, in);\n    inpt(vs[3], 3, in);\n    inpt(vs[4], 1, in);\n    Board b(vs);\n    queue<Board> Q;\n    set<int> vis;\n    Q.push(b);\n    vis.insert(zh.hash(b.b));\n\n    int turn = 0;\n    while (!Q.empty()){\n      if (turn > 15) break;\n      queue<Board> nQ;\n      while (!Q.empty()){\n        Board bi = Q.front();\n        Q.pop();\n        if (bi.is_ok()){\n          cout << turn << endl;\n          goto END;\n        }\n        for (int i = 0; i < 2; i++){\n          for (int d = 0; d < 4; d++){\n            Board bii = bi;\n            if (!bii.slide(i, d)) continue;\n            int hv = zh.hash(bii.b);\n            if (vis.count(hv)) continue;\n            vis.insert(hv);\n            nQ.push(bii);\n          }\n        }\n      }\n      swap(Q, nQ);\n      turn++;\n    }\n    cout << \"NA\" << endl;\nEND:;\n  }\n  return 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include <iostream>\n#include <queue>\n#include <set>\nusing namespace std;\ntypedef long long ll;\n\nll mov[13][4] = {\n\t{2,-1,-1,-1},\n\t{2,5,-1,-1},\n\t{0,1,3,6},\n\t{2,7,-1,-1},\n\t{5,-1,-1,-1},\n\t{1,4,6,9},\n\t{2,5,7,10},\n\t{3,6,8,11},\n\t{7,-1,-1,-1},\n\t{5,10,-1,-1},\n\t{6,9,11,12},\n\t{7,10,-1,-1},\n\t{10,-1,-1,-1},\n};\n\nll sw(ll l, int i, int j) {\n\tint a, b;\n\ta = (l >> (4 * i)) & 0xfL;\n\tb = (l >> (4 * j)) & 0xfL;\n\n\tl &= ~(0xfL << (4*i));\n\tl &= ~(0xfL << (4*j));\n\n\tl |= (ll)b << (4 * i);\n\tl |= (ll)a << (4 * j);\n\n\treturn l;\n}\n\nint main() {\n\twhile(1) {\n\t\tll in = 0;\n\t\tfor(int i = 0; i < 13; i++) {\n\t\t\tint tmpin;\n\t\t\tcin >> tmpin;\n\t\t\tif(tmpin < 0)\n\t\t\t\treturn 0;\n\t\t\tin |= ((ll)tmpin << (4*i));\n\t\t}\n\n\t\tqueue<ll> q;\n\t\tset<ll> s;\n\t\tq.push(in);\n\t\ts.insert(in);\n\t\tint ans = -1;\n\t\t// debug\n\t\tint failcount = 0;\n\t\tfor(int i = 0; i <= 20; i++) {\n\t\t\tqueue<ll> next;\n\t\t\twhile(!q.empty()) {\n\t\t\t\tll l = q.front(); q.pop();\n\t\t\t\tif(l == 0xba9876543210) {\n\t\t\t\t\tans = i;\n\t\t\t\t\tgoto OUTPUT_ANSWER;\n\t\t\t\t}\n\t\t\t\telse {\n\t\t\t\t\tint cnt = 0;\n\t\t\t\t\tfor(int j = 0; j < 13; j++) {\n\t\t\t\t\t\tll t = 0xba9876543210;\n\t\t\t\t\t\tif(((l >> 4*j) & 0xfL) != ((t >> 4*j) & 0xfL)) {\n\t\t\t\t\t\t\tcnt++;\n\t\t\t\t\t\t}\n\t\t\t\t\t}\n\t\t\t\t\tif(cnt > 20 - (i + 3))\n\t\t\t\t\t\tcontinue;\n\t\t\t\t}\n\n\t\t\t\tfor(int j = 0; j < 13; j++) {\n\t\t\t\t\tif(((l >> (4*j)) & 0xfL) == 0) {\n\t\t\t\t\t\tfor(int k = 0; k < 4; k++) {\n\t\t\t\t\t\t\tll p;\n\t\t\t\t\t\t\tif(mov[j][k] < 0)\n\t\t\t\t\t\t\t\tbreak;\n\t\t\t\t\t\t\tp = sw(l, j, mov[j][k]);\n\t\t\t\t\t\t\tif(s.find(p) == s.end()) {\n\t\t\t\t\t\t\t\ts.insert(p);\n\t\t\t\t\t\t\t\tnext.push(p);\n\t\t\t\t\t\t\t}\n\t\t\t\t\t\t\telse {\n\t\t\t\t\t\t\t\tfailcount++;\n\t\t\t\t\t\t\t}\n\t\t\t\t\t\t}\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t}\n\t\t\tq = next;\n\t\t}\n\nOUTPUT_ANSWER:;\n\t\tif(ans < 0)\n\t\t\tcout << \"NA\" << endl;\n\t\telse\n\t\t\tcout << ans << endl;\n//\t\tcout << failcount << endl;\n\t}\n}"
  },
  {
    "language": "C++",
    "code": "#include<iostream>\n#include<algorithm>\n#include<vector>\n#include<queue>\n#include<map>\n#define lol(i,n) for(int i=0;i<n;i++)\n#define mod 1000000007\ntypedef long long ll;\nusing namespace std;\nint dx[13][4]={\n  {3,0,0,0},\n  {3,6,0,0},\n  {1,2,4,6},\n  {3,8,0,0},\n  {6,0,0,0},\n  {2,5,7,10},\n  {3,6,8,11},\n  {4,7,9,12},\n  {8,0,0,0},\n  {6,11,0,0},\n  {6,10,12,13},\n  {8,11,0,0},\n  {11,0,0,0}\n};\nmap<ll,int> mp;\nll Compress(int p[]){\n  ll ans=0;\n  for(int i=0;i<13;i++){\n    ans*=13;\n    ans+=p[i];\n  }\n  return ans;\n}\n\nint unzip[13];\nvoid Unzip(ll x){\n  for(int i=0;i<13;i++){\n    unzip[12-i]=x%13;\n    x/=13;\n  }\n}\n\nint beflen=0;\nqueue<pair<ll,int> >Q;\nvoid BFS(int p[],int len){\n  //if(len!=beflen){cout<<len<<endl;beflen=len;}\n  ll tmp=Compress(p);\n  mp[tmp]=len;\n  if(len==21)return;\n  lol(i,13){\n    if(p[i]==0){\n      lol(j,4){\n\tint t=dx[i][j];\n\tif(t==0)break;\n\tt--;\n\tif(p[t]!=0){\n\t  swap(p[i],p[t]);\n\t  tmp=Compress(p);\n\t  if(mp[tmp]>0)continue;\n\t  mp[tmp]=len;\n\t  Q.push(make_pair(tmp,len+1));\n\t  swap(p[i],p[t]);\n\t}\n      }\n    }\n  }\n}\nint main(){\n  int p[13];\n  lol(i,13)p[i]=i;p[12]=0;\n  Q.push(make_pair(Compress(p),1));\n  while(!Q.empty()){\n    ll data=Q.front().first;\n    int len=Q.front().second;\n    Q.pop();\n    if(mp[data]>0)continue;\n    Unzip(data);\n    BFS(unzip,len);\n  }\n  while(cin>>p[0]&&p[0]!=-1){\n    for(int i=1;i<13;i++)cin>>p[i];\n    ll tmp=Compress(p);\n    int cost=mp[tmp];\n    if(cost==0)cout<<\"NA\"<<endl;\n    else cout<<cost-1<<endl;\n  }\n  return 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include <cstdio>\n#include <cstdlib>\n#include <cmath>\n#include <climits>\n#include <cfloat>\n#include <map>\n#include <utility>\n#include <set>\n#include <iostream>\n#include <memory>\n#include <string>\n#include <vector>\n#include <algorithm>\n#include <functional>\n#include <sstream>\n#include <complex>\n#include <stack>\n#include <queue>\n#include <cstring>\n#include <sstream>\n#include <cassert>\n#include <list>\nusing namespace std;\nstatic const double EPS = 1e-10;\ntypedef long long ll;\ntypedef pair<int,int> PI;\ntypedef vector<int> vi;\n#ifndef M_PI\n#define M_PI 3.14159265358979323846\n#endif\n#define rep(i,n) for(int i=0;i<(int)n;++i)\n#define FOR(i,c) for(__typeof((c).begin())i=(c).begin();i!=(c).end();++i)\n#define ALL(c) (c).begin(), (c).end()\n#define mp(a,b) make_pair(a,b)\n#define pb(a) push_back(a)\n#define F first\n#define S second\ntemplate <typename T> string print_array(const vector<T> &V) { ostringstream os; os << \"{ \"; for (typename vector<T>::const_iterator iter = V.begin(); iter != V.end(); ++iter) os << '\\\"' << *iter << \"\\\",\"; os << \" }\"; return os.str(); }\n\nint dx[]={0,1,0,-1},dy[]={1,0,-1,0};\n\nvector<int> se[13];\nint x[]={0,-1,0,1,-2,-1,0,1,2,-1,0,1,0};\nint y[]={2,1,1,1,0,0,0,0,0,-1,-1,-1,-2};\n\nvoid pr(ll in){\n\n  printf(\"      %3lld\\n\",in&15);\n  printf(\"   %3lld%3lld%3lld\\n\",(in>>4)&15,(in>>8)&15,(in>>12)&15);\n  printf(\"%3lld%3lld%3lld%3lld%3lld\\n\",(in>>16)&15,(in>>20)&15,(in>>24)&15,(in>>28)&15,(in>>32)&15);\n  printf(\"   %3lld%3lld%3lld\\n\",(in>>36)&15,(in>>40)&15,(in>>44)&15);\n  printf(\"      %3lld\\n\",(in>>48)&15);\n  puts(\"\");\n}\n\nint manh(ll in){\n  int ret=0;\n  rep(i,13){\n    int t=(in>>(i*4))&15;\n\n    if(!t)continue;\n    int nx=(x[t]-x[i]),ny=y[t]-y[i];\n    ret+=abs(nx)+abs(ny);\n  }\n  return ret;\n}\n\nmain(){\n  ll p;\n\n  ll goal=0;\n  rep(i,11){\n    goal|=(i+1LL)<<(4*(i+1));\n    //cout<<goal<<endl;\n    //pr(goal);\n  }\n  //pr(goal);\n\n  se[0].pb(2);\n  se[1].pb(2);\n  se[1].pb(5);\n  se[2].pb(0);\n  se[2].pb(1);\n  se[2].pb(3);\n  se[2].pb(6);\n  se[3].pb(2);\n  se[3].pb(7);\n  se[4].pb(5);\n  se[5].pb(1);\n  se[5].pb(4);\n  se[5].pb(6);\n  se[5].pb(9);\n  se[6].pb(2);\n  se[6].pb(5);\n  se[6].pb(7);\n  se[6].pb(10);\n  se[7].pb(3);\n  se[7].pb(6);\n  se[7].pb(8);\n  se[7].pb(11);\n  se[8].pb(7);\n  se[9].pb(5);\n  se[9].pb(10);\n  se[10].pb(6);\n  se[10].pb(9);\n  se[10].pb(11);\n  se[10].pb(12);\n  se[11].pb(7);\n  se[11].pb(10);\n  se[12].pb(10);\n  \n  while(cin>>p){\n    if(p==-1)break;\n    ll in=p;\n\n    rep(i,12){\n      cin>>p;\n      in|=p<<(4*(i+1));\n    }\n\n    set<ll> app;\n\n    queue<pair<int,ll> > Q;\n    app.insert(in);\n    Q.push(mp(0,in));\n    int ans=21;\n    int mans=0;\n\n    while(!Q.empty()){\n      ll cvec=Q.front().S;\n      int ccost=Q.front().F;\n      Q.pop();\n    \n      //pr(cvec);\n\n      //if(ccost>3)break;\n      if(ccost+manh(cvec)+3>20)continue;\n      if(cvec==goal){\n\tans=ccost;\n\tbreak;\n      }\n      rep(i,13){\n\tll t=cvec>>(i<<2);\n\tt=t&15;\n\tif(!t){\n\t  rep(j,se[i].size()){\n\t    t=cvec>>(se[i][j]<<2);\n\t    t=t&15;\n\t    if(t){\n\t      ll nvec=cvec;\n\t      t=t<<(i<<2);\n\t      nvec|=t;\n\t      nvec&=~(15LL<<se[i][j]*4);\n\t      \n\t      if(!app.count(nvec)){\n\t\tapp.insert(nvec);\n\t\tQ.push(mp(ccost+1,nvec));\n\t      }\n\t    }\n\t  }\n\t}\n      }\n    }\n    if(ans==21)cout<<\"NA\"<<endl;\n    else cout<<ans<<endl;\n  }\n}"
  },
  {
    "language": "C++",
    "code": "#include <iostream>\n#include <algorithm>\n#include <vector>\n#include <cstring>\n#include <cstdio>\n#include <climits>\n\nusing namespace std;\n\n#define REP(i,a,n) for(int i=(a); i<(int)(n); i++)\n#define rep(i,n) REP(i,0,n)\n#define DEB 0\n\n/*\n  1 = [2][2]\n  2 = [2][3]\n  3 = [2][4]\n  4 = [3][1]\n  5 = [3][2]\n  6 = [3][3]\n  7 = [3][4]\n  8 = [3][5]\n  9 = [4][2]\n  10= [4][3]\n  11= [4][4]\n*/\nint board[7][7]; //1base\nint sx[2], sy[2];\nstatic const int dx[] = {0,0,1,-1};\nstatic const int dy[] = {1,-1,0,0};\n\n/*\n(y,x)\n */\nint calc(int y, int x){\n    switch(board[y][x]){\n    case 1: return abs(2-y)+abs(2-x);\n    case 2: return abs(2-y)+abs(3-x);\n    case 3: return abs(2-y)+abs(4-x);\n    case 4: return abs(3-y)+abs(1-x);\n    case 5: return abs(3-y)+abs(2-x);\n    case 6: return abs(3-y)+abs(3-x);\n    case 7: return abs(3-y)+abs(4-x);\n    case 8: return abs(3-y)+abs(5-x);\n    case 9: return abs(4-y)+abs(2-x);\n    case 10: return abs(4-y)+abs(3-x);\n    case 11: return abs(4-y)+abs(4-x);\n    }\n    return -1;\n}\nint dist(void){\n    int ret = 0;\n    if( board[1][3] ) ret += calc(1,3);\n    rep(i,3) if( board[2][2+i] ) ret += calc(2,2+i);\n    rep(i,5) if( board[3][1+i] ) ret += calc(3,1+i);\n    rep(i,3) if( board[4][2+i] ) ret += calc(4,2+i);\n    if( board[5][3] ) ret += calc(5,3);\n    return ret;\n}\nbool isgoal(void){\n    if( board[1][3]!=0 ) return false;\n    rep(i,3) if( board[2][2+i]!=i+1 ) return false;\n    rep(i,5) if( board[3][1+i]!=i+4 ) return false;\n    rep(i,3) if( board[4][2+i]!=i+9 ) return false;\n    if( board[5][3]!=0 ) return false;\n    return true;\n}\n\nbool dfs(int cnt, int LIM, int py, int px){\n    if( LIM<cnt ) return false;\n    if( isgoal() ) return true;\n    if( cnt+dist()>23 ) return false;\n\n    rep(i,2){\n        rep(k,4){\n            int tx = sx[i] + dx[k];\n            int ty = sy[i] + dy[k];\n            if( board[ty][tx]==-1 || ty==py&&tx==px ) continue;\n            swap(board[sy[i]][sx[i]], board[ty][tx]);\n            swap(sx[i], tx); swap(sy[i],ty);\n            if( dfs(cnt+1, LIM, ty, tx) ) return true;\n            swap(sx[i], tx); swap(sy[i],ty);\n            swap(board[sy[i]][sx[i]] ,board[ty][tx]);\n        }\n    }\n    return false;\n}\nint solve(void){\n    int ttx[2], tty[2];\n    rep(i,2) ttx[i]=sx[i], tty[i]=sy[i];\n\n    for(int lim = 0; lim < 21; lim++){\n        rep(i,2) sx[i]=ttx[i], sy[i]=tty[i];\n        if( dfs(0,lim,-1,-1) ) return lim;\n    }\n    return -1;\n}\nint main(){\n    for(;;){\n        memset(board, -1, sizeof(board));\n        int sz = 0;\n\n        scanf(\"%d\",&board[1][3]); if( board[1][3]==-1 ) break;\n        rep(i,3) scanf(\"%d\",&board[2][2+i]);\n        rep(i,5) scanf(\"%d\",&board[3][1+i]);\n        rep(i,3) scanf(\"%d\",&board[4][2+i]);\n        scanf(\"%d\",&board[5][3]);\n\n        // find space\n        if( board[1][3]==0 ){ sx[sz]=3; sy[sz]=1; sz++; }\n        rep(i,3) if( board[2][2+i]==0 ) { sx[sz]=2+i; sy[sz]=2; sz++; }\n        rep(i,5) if( board[3][1+i]==0 ) { sx[sz]=1+i; sy[sz]=3; sz++; }\n        rep(i,3) if( board[4][2+i]==0 ) { sx[sz]=2+i; sy[sz]=4; sz++; }\n        if( board[5][3]==0 ){ sx[sz]=3; sy[sz]=5; sz++; }\n\n        int ans = solve();\n        if( ans!=-1 ) printf(\"%d\\n\",ans); else puts(\"NA\");\n    }\n    return 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include <algorithm>\n#include <cctype>\n#include <climits>\n#include <cmath>\n#include <cstdio>\n#include <cstdlib>\n#include <cstring>\n#include <functional>\n#include <map>\n#include <numeric>\n#include <queue>\n#include <set>\n#include <sstream>\n#include <string>\n#include <vector>\n\nusing namespace std;\n\n#define reps(i,f,n) for(int i=f; i<int(n); ++i)\n#define rep(i,n) reps(i,0,n)\n\ntypedef long long ll;\ntypedef vector<int> vi;\ntypedef vector<vi> vvi;\ntypedef pair<int, int> pii;\n\nconst int INF = 1001001001;\nconst ll FINAL = 0x0ba9876543210ll;\n\nstruct Data\n{\n\tll s;\n\tint d;\n\tbool f;\n\tData(ll s, int d, bool f) : s(s), d(d), f(f) {}\n};\n\nint bfs(ll init)\n{\n\tif(init == FINAL)\n\t\treturn 0;\n\t\n\tconst int move[13][5] = {\n\t\t{2, -1},\n\t\t{2, 5, -1},\n\t\t{0, 1, 3, 6, -1},\n\t\t{2, 7, -1},\n\t\t{5, -1},\n\t\t{1, 4, 6, 9, -1},\n\t\t{2, 5, 7, 10, -1},\n\t\t{3, 6, 8, 11, -1},\n\t\t{7, -1},\n\t\t{5, 10, -1},\n\t\t{6, 9, 11, 12, -1},\n\t\t{7, 10, -1},\n\t\t{10, -1}\n\t};\n\t\n\tset<ll> visited[2];\n\tqueue<Data> Q;\n\tQ.push(Data(init, 0, false));\n\tQ.push(Data(FINAL, 0, true));\n\tvisited[0].insert(init);\n\tvisited[1].insert(FINAL);\n\tint now[2] = {0};\n\t\n\twhile(!Q.empty()){\n\t\tData data = Q.front();\n\t\tQ.pop();\n\n\t\tfor(int i=0, cnt=2; cnt; ++i){\n\t\t\tif(((data.s>>(i*4)) & 0xfll) == 0){\n\t\t\t\tfor(int j=0; move[i][j]!=-1; ++j){\n\t\t\t\t\tll next = data.s;\n\t\t\t\t\tnext &= ~((0xfll << (i*4)) | (0xfll << (move[i][j]*4)));\n\t\t\t\t\tnext |= ((data.s >> (move[i][j]*4)) & 0xfll) << (i*4);\n\t\t\t\t\t\n\t\t\t\t\tif(visited[!data.f].find(next) != visited[!data.f].end())\n\t\t\t\t\t\treturn now[0] + now[1] + 1;\n\n\t\t\t\t\tif(visited[data.f].find(next) == visited[data.f].end()){\n\t\t\t\t\t\tvisited[data.f].insert(next);\n\t\t\t\t\t\tif(now[0]+now[1] < 20){\n\t\t\t\t\t\t\tnow[data.f] = data.d + 1;\n\t\t\t\t\t\t\tQ.push(Data(next, data.d+1, data.f));\n\t\t\t\t\t\t}\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t\t--cnt;\n\t\t\t}\n\t\t}\n\t}\n\treturn -1;\n}\n\nint main()\n{\n\tfor(;;){\n\t\tint input[13];\n\t\trep(i, 13){\n\t\t\tscanf(\"%d\", &input[i]);\n\t\t\tif(input[i] == -1)\n\t\t\t\treturn 0;\n\t\t}\n\n\t\tll init = 0;\n\t\trep(i, 13)\n\t\t\tinit = (init << 4) | input[12-i];\n\n\t\tint ans = bfs(init);\n\t\tif(ans == -1 || ans > 20)\n\t\t\tputs(\"NA\");\n\t\telse\n\t\t\tprintf(\"%d\\n\", ans);\n\t}\n}"
  },
  {
    "language": "C++",
    "code": "#include <cstdio>\n#include <iostream>\n#include <string>\n#include <queue>\n#include <unordered_map>\n\nusing namespace std;\n\n#define dump(n) cerr<<\"# \"<<#n<<'='<<(n)<<endl\n\nunordered_map<string,int> getstates(string board,int maxturn)\n{\n\tunordered_map<string,int> m;\n\tqueue<pair<string,int>> q;\n\tq.emplace(board,0);\n\twhile(q.size()){\n\t\tstring cb=q.front().first;\n\t\tint cc=q.front().second;\n\t\tq.pop();\n\t\tif(m.count(cb))\n\t\t\tcontinue;\n\t\tm.insert(make_pair(cb,cc));\n\t\t\n\t\tif(cc==maxturn)\n\t\t\tcontinue;\n\t\tfor(int i=0;i<5;i++)\n\t\t\tfor(int j=abs(i-2);j<5-abs(i-2);j++){\n\t\t\t\tif(cb[i*5+j]!='.')\n\t\t\t\t\tcontinue;\n\t\t\t\tfor(int k=0;k<4;k++){\n\t\t\t\t\tint ni=i+\"\\xff\\x1\\0\\0\"[k],nj=j+\"\\0\\0\\xff\\x1\"[k];\n\t\t\t\t\tif(ni<0 || 5<=ni || nj<abs(ni-2) || 5-abs(ni-2)<=nj || cb[ni*5+nj]=='.')\n\t\t\t\t\t\tcontinue;\n\t\t\t\t\tswap(cb[i*5+j],cb[ni*5+nj]);\n\t\t\t\t\tq.emplace(cb,cc+1);\n\t\t\t\t\tswap(cb[i*5+j],cb[ni*5+nj]);\n\t\t\t\t}\n\t\t\t}\n\t}\n\treturn m;\n}\n\nint main()\n{\n\tstring goal=\"##.###abc#defgh#ijk###.##\";\n\tfor(;;){\n\t\tstring start(25,'#');\n\t\tfor(int i=0;i<5;i++)\n\t\t\tfor(int j=abs(i-2);j<5-abs(i-2);j++){\n\t\t\t\tint x; scanf(\"%d\",&x);\n\t\t\t\tstart[i*5+j]=x?x-1+'a':'.';\n\t\t\t}\n\t\tif(feof(stdin)) break;\n\t\t\n\t\tunordered_map<string,int> m1=getstates(start,10);\n\t\tunordered_map<string,int> m2=getstates(goal,10);\n\t\t\n\t\tint res=999;\n\t\tfor(auto kv:m1)\n\t\t\tif(m2.count(kv.first))\n\t\t\t\tres=min(res,kv.second+m2[kv.first]);\n\t\t\n\t\tif(res==999)\n\t\t\tcout<<\"NA\"<<endl;\n\t\telse\n\t\t\tcout<<res<<endl;\n\t}\n\t\n\treturn 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include <iostream>\n#include <string>\n#include <vector>\n#include <queue>\n#include <map>\nusing namespace std;\n\nstring s = \"0123456789AB\";\nvector<vector<int>> adj = {\n    {2},\n    {2,5},\n    {0,1,3,6},\n    {2,7},\n    {5},\n    {1,4,6,9},\n    {2,5,7,10},\n    {3,6,8,11},\n    {7},\n    {5,10},\n    {6,9,11,12},\n    {7,10},\n    {10}\n};\nmap<string, int> term, dist;\n\nint solve(string stat, string goal, int limit, map<string,int> &dist, bool useterm) {\n    dist[stat] = 0;\n    queue<string> q;\n    q.push(stat);\n    while ( ! q.empty()) {\n        string s = q.front();\n        q.pop();\n        if (useterm && term.find(s) != term.end()) {\n            return dist[s] + term[s];\n        }\n        int diff = 0;\n        for (int k=0; k<13; ++k) {\n            if (s[k] != '0') {\n                diff += s[k] != goal[k];\n            }\n        }\n        if ( ! diff) {\n            return dist[s];\n        }\n        if (limit < dist[s] + diff) {\n            continue;\n        }\n        for (int i=0; i<13; ++i) {\n            if (s[i] != '0') continue;\n            for (int j : adj[i]) {\n                string next = s;\n                next[i] = s[j];\n                next[j] = s[i];\n                if (dist.find(next) == dist.end()) {\n                    dist[next] = dist[s] + 1;\n                    q.push(next);\n                }\n            }\n        }\n    }\n    return limit + 1;\n}\n\nint main() {\n    while (1) {\n        string stat = \"\";\n        int k;\n        for (int i=0; i<13; ++i) {\n            if (cin >> k && !~k) return 0;\n            stat += s[k];\n        }\n        int ans = solve(\"0123456789AB0\", stat, 10, term, false);\n        if (ans == 11) {\n            ans += solve(stat, \"0123456789AB0\", 10, dist, true);\n        }\n        if (ans <= 20) {\n            cout << ans << endl;\n            continue;\n        }\n        cout << \"NA\" << endl;\n    }\n    return 0;\n}"
  },
  {
    "language": "C++",
    "code": "#import<iostream>\n#import<map>\n#import<queue>\n#import<cstdlib>\n#import<cstring>\nusing namespace std;struct B{int z[2];char s[14];bool operator<(const B&r)const{return strcmp(s,r.s)<0;}};main(){int a[13][5]={{2,-1},{2,5,-1},{0,1,3,6,-1},{2,7,-1},{5,-1},{1,4,6,9,-1},{2,5,7,10,-1},{3,6,8,11,-1},{7,-1},{5,10,-1},{6,9,11,12,-1},{7,10,-1},{10,-1},},gx[]={2,1,2,3,0,1,2,3,4,1,2,3,2},gy[]={0,1,1,1,2,2,2,2,2,3,3,3,4},v,d,s,i,j;B g={0,0,\"0123456789:;0\"};for(;;){map<B,int>m;queue<B>q;B b={-1,-1};for(i=0;i<13;i++){cin>>v;if(v<0)return 0;b.s[i]=48+v;if(!v)b.z[b.z[0]!=-1]=i;}b.s[13]=0;m[b]=1;for(q.push(b);!q.empty();q.pop()){B&b=q.front();if(!strcmp(b.s,g.s))break;d=0;for(i=13;i--;){v=b.s[i]-48;if(v)d+=abs(gx[v]-gx[i])+abs(gy[v]-gy[i]);}s=m[b];if(s+d<22)for(j=2;j--;)for(i=0;~a[b.z[j]][i];i++){B n=b;n.z[j]=a[b.z[j]][i];if(n.z[j]-n.z[1-j]){swap(n.s[b.z[j]],n.s[n.z[j]]);if(!m[n])m[n]=s+1,q.push(n);}}}printf(m[g]?\"%d\\n\":\"NA\\n\",m[g]-1);}}"
  },
  {
    "language": "C++",
    "code": "#include<cstdio>\n#include<algorithm>\n#include<iostream>\n#include<queue>\n#include<functional>\n#include<map>\n#include<vector>\nusing namespace std;\nclass P{\n\tpublic:\n\tint state[15];\n\tint cnt;\n\tP(){}\n\tP(int a[15],int cnt):cnt(cnt){\n\t\tfor(int i = 0; i < 15; i++){\n\t\t\tstate[i] = a[i];\n\t\t}\n\t}\n};\nint rules[13][6]={\n\t{1,2},{2,2,5},{4,0,1,2,3,6},{2,2,7},{1,5},\n\t{4,1,4,6,9},{4,2,5,7,10},{4,3,6,8,11},{1,7},{3,5,10},\n\t{4,6,9,11,12},{2,7,10},{1,10}\n};\nmap< string , int >memo;\n\nstring getIndex(int *a){\n\tstring tmp=\"\";\n\tfor(int i = 0; i < 13; i++){\n\t\ttmp += a[i]+48;\n\t}\n\treturn tmp;\n}\n\nvoid bfs(){\n\tint F[] = {0,1,2,3,4,5,6,7,8,9,10,11,0};\n\tqueue < P > Q;\n\tQ.push(P(F,0));\n\twhile( true ){\n\t\tif(Q.size() == 0)break;\n\t\tP p = Q.front();Q.pop();\n\t\tif(p.cnt > 20)break;\n\t\tstring index = getIndex(p.state);\n\t\tif( memo[index] )continue;\n\t\tmemo[index] = p.cnt;\n\t\tfor(int i = 0; i < 13; i++){\n\t\t\tif(p.state[i] == 0){\n\t\t\t\tint zero = p.state[i];\n\t\t\t\tfor(int j = 0; j < rules[zero][0]; j++){\n\t\t\t\t    if(p.state[rules[i][j+1]] == 0)continue;\n\t\t\t\t\tswap(p.state[i],p.state[rules[i][j+1]]);\n\t\t\t\t\tQ.push(P(p.state,p.cnt+1));\n\t\t\t\t\tswap(p.state[i],p.state[rules[i][j+1]]);\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t}\n}\nint main(){\n\tbfs();\n\tint input[15];\n\twhile(true){\n\t    scanf(\"%d\",&input[0]);\n\t    if(input[0] == -1)break;\n\t\tfor(int i = 1; i < 13; i++){\n\t\t\tscanf(\"%d\",&input[i]);\n\t\t}\n\t\tstring index = getIndex(input);\n\t\tif(index == \"0123456789:;0\")puts(\"0\");\n\t\telse if( memo[index] )printf(\"%d\\n\",memo[index]);\n\t\telse puts(\"NA\");\n\t}\n\treturn 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include <iostream>\n#include <algorithm>\n#include <vector>\n#include <cstring>\n#include <cstdio>\n#include <climits>\n\nusing namespace std;\n\n#define REP(i,a,n) for(int i=(a); i<(int)(n); i++)\n#define rep(i,n) REP(i,0,n)\n#define DEB 0\n\n/*\n  1 = [2][2]\n  2 = [2][3]\n  3 = [2][4]\n  4 = [3][1]\n  5 = [3][2]\n  6 = [3][3]\n  7 = [3][4]\n  8 = [3][5]\n  9 = [4][2]\n  10= [4][3]\n  11= [4][4]\n*/\nint board[7][7]; //1base\nint sx[2], sy[2];\nstatic const int dx[] = {0,0,1,-1};\nstatic const int dy[] = {1,-1,0,0};\n\n/*\n(y,x)\n */\nint calc(int y, int x){\n    switch(board[y][x]){\n    case 1: return abs(2-y)+abs(2-x);\n    case 2: return abs(2-y)+abs(3-x);\n    case 3: return abs(2-y)+abs(4-x);\n    case 4: return abs(3-y)+abs(1-x);\n    case 5: return abs(3-y)+abs(2-x);\n    case 6: return abs(3-y)+abs(3-x);\n    case 7: return abs(3-y)+abs(4-x);\n    case 8: return abs(3-y)+abs(5-x);\n    case 9: return abs(4-y)+abs(2-x);\n    case 10: return abs(4-y)+abs(3-x);\n    case 11: return abs(4-y)+abs(4-x);\n    }\n    return -1;\n}\nint dist(void){\n    int ret = 0;\n    if( board[1][3] ) ret += calc(1,3);\n    rep(i,3) if( board[2][2+i] ) ret += calc(2,2+i);\n    rep(i,5) if( board[3][1+i] ) ret += calc(3,1+i);\n    rep(i,3) if( board[4][2+i] ) ret += calc(4,2+i);\n    if( board[5][3] ) ret += calc(5,3);\n    return ret;\n}\nbool isgoal(void){\n    if( board[1][3]!=0 ) return false;\n    rep(i,3) if( board[2][2+i]!=i+1 ) return false;\n    rep(i,5) if( board[3][1+i]!=i+4 ) return false;\n    rep(i,3) if( board[4][2+i]!=i+9 ) return false;\n    if( board[5][3]!=0 ) return false;\n    return true;\n}\n\nbool dfs(int cnt, int LIM, int py, int px){\n    if( isgoal() ) return true;\n    if( cnt+dist()>LIM ) return false;\n#if DEB\n    //printf(\"cnt:%d  (%d,%d),(%d,%d)\\n\",cnt, sx[0], sy[0], sx[1], sy[1]);\n#endif\n    rep(i,2){\n        rep(k,4){\n            int tx = sx[i] + dx[k];\n            int ty = sy[i] + dy[k];\n            if( board[ty][tx]==-1 || ty==py&&tx==px ) continue;\n            swap(board[sy[i]][sx[i]], board[ty][tx]);\n            swap(sx[i], tx); swap(sy[i],ty);\n            if( dfs(cnt+1, LIM, ty, tx) ) return true; // ツ個ウツづ個スツペツーツスツ暗環置\n            swap(sx[i], tx); swap(sy[i],ty);\n            swap(board[sy[i]][sx[i]] ,board[ty][tx]);\n        }\n    }\n}\nint solve(void){\n    int ttx[2], tty[2];\n    rep(i,2) ttx[i]=sx[i], tty[i]=sy[i];\n\n    for(int lim = 0; lim < 21; lim++){\n        rep(i,2) sx[i]=ttx[i], sy[i]=tty[i];\n        if( dfs(0,lim,-1,-1) ) return lim;\n    }\n    return -1;\n}\nint main(){\n    for(;;){\n        memset(board, -1, sizeof(board));\n        int sz = 0;\n\n        scanf(\"%d\",&board[1][3]); if( board[1][3]==-1 ) break;\n        rep(i,3) scanf(\"%d\",&board[2][2+i]);\n        rep(i,5) scanf(\"%d\",&board[3][1+i]);\n        rep(i,3) scanf(\"%d\",&board[4][2+i]);\n        scanf(\"%d\",&board[5][3]);\n\n        // find space\n        if( board[1][3]==0 ){ sx[sz]=3; sy[sz]=1; sz++; }\n        rep(i,3) if( board[2][2+i]==0 ) { sx[sz]=2+i; sy[sz]=2; sz++; }\n        rep(i,5) if( board[3][1+i]==0 ) { sx[sz]=1+i; sy[sz]=3; sz++; }\n        rep(i,3) if( board[4][2+i]==0 ) { sx[sz]=2+i; sy[sz]=4; sz++; }\n        if( board[5][3]==0 ){ sx[sz]=3; sy[sz]=5; sz++; }\n\n#if DEB\n        rep(i,7){\n            rep(j,7){\n                printf(\"%2d \",board[i][j]);\n            }\n            puts(\"\");\n        }\n        rep(i,2){\n            printf(\"(%d,%d),\",sx[i], sy[i]);\n        }puts(\"\");\n        printf(\"%d\\n\",dist());\n#endif\n        \n        int ans = solve();\n        if( ans==-1 ) puts(\"NA\"); else printf(\"%d\\n\",ans);\n    }\n    return 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include <iostream>\n#include <vector>\nusing namespace std;\n\ntypedef vector <int> VI;\ntypedef vector <VI> VVI;\n\nVVI goal;\nVVI init;\n\nint limit;\n\nconst int di[4] = { 0, -1, 0, 1 };\nconst int dj[4] = { 1, 0, -1,  };\n\nconst int T[12][2] = {\n\t{ 0, 0 },\n\t{ 2, 2 },\n\t{ 2, 3 },\n\t{ 2, 4 },\n\t{ 3, 1 },\n\t{ 3, 2 },\n\t{ 3, 3 },\n\t{ 3, 4 },\n\t{ 3, 5 },\n\t{ 4, 2 },\n\t{ 4, 3 },\n\t{ 4, 4 }\n};\n\nint getMD( VVI P )\n{\n\tint sum = 0;\n\tint ti, tj;\n\tfor ( int i = 0; i < 7; i++ ) for ( int j = 0; j < 7; j++ )\n\t{\n\t\tif ( P[j][i] <= 0 )\n\t\t\tcontinue;\n\n\t\tti = T[P[j][i]][0];\n\t\ttj = T[P[j][i]][1];\n\t\tsum += ( max( ti, i ) - min( ti, i ) + max( tj, j ) - min( tj, j ) );\n\t}\n\treturn sum;\n}\n\nbool is_goal( VVI puzzle )\n{\n\tbool ok = true;\n\tfor ( int i = 0; ok && i < 7; i++ ) for ( int j = 0; ok && j < 7; j++ )\n\t{\n\t\tif ( puzzle[j][i] != goal[j][i] )\n\t\t\tok = false;\n\t}\n\treturn ok;\n}\n\nbool dfs( int depth, VVI now )\n{\n\tif ( is_goal( now ) )\n\t\treturn true;\n\n\tif ( depth + getMD( now ) > limit )\n\t\treturn false;\n\n\tfor ( int i = 0; i < 7; i++ ) for ( int j = 0; j < 7; j++ )\n\t{\n\t\tif ( now[j][i] != 0 )\n\t\t\tcontinue;\n\n\t\tfor ( int k = 0; k < 4; k++ )\n\t\t{\n\t\t\tVVI v = now;\n\t\t\tint ni = i + di[k];\n\t\t\tint nj = j + dj[k];\n\n\t\t\tif ( v[nj][ni] <= 0 )\n\t\t\t\tcontinue;\n\n\t\t\tswap( v[j][i], v[nj][ni] );\n\n\t\t\tif ( dfs( depth+1, v ) )\n\t\t\t\treturn true;\n\n\t\t}\n\t}\n\n}\n\nint idfs( VVI src )\n{\n\tfor ( limit = 0; limit <= 20; limit++ )\n\t{\n\t\tif ( dfs( 0, src ) )\n\t\t\treturn limit;\n\t}\n\treturn -1;\n}\n\nint main( void )\n{\n\t// S[ÌóÔðìé\n\tgoal = VVI( 7, VI( 7, -1 ) );\n\tgoal[3][1] = 0;\n\tgoal[3][5] = 0;\n\tfor ( int i = 0; i < 3; i++ )\n\t{\n\t\tgoal[2+i][2] = 1+i;\n\t\tgoal[2+i][4] = 9+i;\n\t}\n\tfor ( int i = 0; i < 5; i++ )\n\t{\n\t\tgoal[1+i][3] = 4+i;\n\t}\n\n\twhile ( 1 )\n\t{\n\t\t// úóÔÌüÍ\n\t\tinit = VVI( 7, VI( 7, -1 ) );\n\t\tcin >> init[3][1];\n\t\tif ( init[3][1] == -1 )\n\t\t\tbreak;\n\t\tfor ( int i = 0; i < 3; i++ )\n\t\t\tcin >> init[2+i][2];\n\t\tfor ( int i = 0; i < 5; i++ )\n\t\t\tcin >> init[1+i][3];\n\t\tfor ( int i = 0; i < 3; i++ )\n\t\t\tcin >> init[2+i][4];\n\t\tcin >> init[3][5];\n\n\t\tint cost = idfs( init );\n\n\t\tif ( cost == -1 )\n\t\t\tcout << \"NA\" << endl;\n\t\telse\n\t\t\tcout << cost << endl;\n\n\t}\n\n\treturn 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\n\n#ifndef INCLUDE_ZOBRIST_HASH_HPP\n#define INCLUDE_ZOBRIST_HASH_HPP\n\n#include <random>\n#include <iostream>\n#include <typeinfo>\n\nnamespace orislib {\n\ntemplate <typename T, int W, int H, int STATE>\nstruct ZobristHash {\n  typedef T hash_t;\n  ZobristHash() {\n    std::random_device rd;\n    std::mt19937 mt(rd());\n    std::uniform_int_distribution<T> dist;\n    for (int h = 0; h < H; h++) {\n      for (int w = 0; w < W; w++) {\n        for (int s = 0; s < STATE; s++) {\n          rands[h][w][s] = dist(mt);\n        }\n      }\n    }\n  }\n  template <typename TT>\n  hash_t hash(TT data[H][W]) {\n    hash_t r = 0;\n    for (int h = 0; h < H; h++) {\n      for (int w = 0; w < W; w++) {\n        r ^= rands[h][w][data[h][w]];\n      }\n    }\n    return r;\n  }\n  hash_t rands[H][W][STATE];\n};\n}\n\n#endif\nusing namespace std;\nusing namespace orislib;\n\ntypedef long long ll;\ntypedef long double ld;\ntypedef tuple<int, int> duo;\nconst int dx[] = {0, 0, 1, -1, 1, 1, -1, -1};\nconst int dy[] = {1, -1, 0, 0, 1, -1, 1, -1};\nconst int Mod = 1000000000 + 0;\n//{{{ templates\n#define TT_             \\\n  template <typename T> \\\n  inline\n#define TTF_                        \\\n  template <typename T, typename F> \\\n  inline\nTT_ T sq(T x) { return x * x; }\nTT_ T In() {\n  T x;\n  cin >> x;\n  return x;\n}\nTT_ void Out(T& x) { cout << x; }\nTT_ void sort(T& v) { sort(begin(v), end(v)); }\nTT_ void revs(T& v) { reverse(begin(v), end(v)); }\nTT_ void uniq(T& v) {\n  sort(v);\n  v.erase(unique(begin(v), end(v)), end(v));\n}\nTT_ int ubnd(T& v, typename T::value_type& x) {\n  return upper_bound(begin(v), end(v), x) - begin(v);\n}\nTT_ int lbnd(T& v, typename T::value_type& x) {\n  return lower_bound(begin(v), end(v), x) - begin(v);\n}\nTTF_ void inpt(T& v, int n, F f) {\n  for (v.reserve(n); n--; v.emplace_back(f()))\n    ;\n}\nTTF_ void show(T& v, F f, string d = \" \", string e = \"\\n\") {\n  int i = 0;\n  for (auto& x : v) i++&&(cout << d), f(x);\n  cout << e;\n}\nTT_ typename T::iterator minel(T& v) { return min_element(begin(v), end(v)); }\nTT_ typename T::iterator maxel(T& v) { return max_element(begin(v), end(v)); }\n\ninline void fast_io() {\n  ios::sync_with_stdio(0);\n  cin.tie(0);\n}\ninline int in() {\n  int x;\n  scanf(\"%d\", &x);\n  return x;\n}\ninline ll pow_mod(ll a, ll k, ll m) {\n  ll r = 1;\n  for (; k > 0; a = a * a % m, k >>= 1)\n    if (k & 1) r = r * a % m;\n  return r;\n}\ninline ll mod_inv(ll a, ll p) { return pow_mod(a, p - 2, p); }\n//}}} priority_queue queue deque front stringstream max_element min_element\n// insert count make_tuple\n\nstruct Board {\n  Board() {}\n  Board(const vector<vector<int>>& v) {\n    memset(b, '#', sizeof(b));\n    for (int i = 0; i < 5; i++) b[i][5] = 0;\n    for (int i = 0; i < v[0].size(); i++) b[0][2 + i] = conv_hex(v[0][i]);\n    for (int i = 0; i < v[1].size(); i++) b[1][1 + i] = conv_hex(v[1][i]);\n    for (int i = 0; i < v[2].size(); i++) b[2][0 + i] = conv_hex(v[2][i]);\n    for (int i = 0; i < v[3].size(); i++) b[3][1 + i] = conv_hex(v[3][i]);\n    for (int i = 0; i < v[4].size(); i++) b[4][2 + i] = conv_hex(v[4][i]);\n    int it = 0;\n    for (int i = 0; i < 5; i++) {\n      for (int j = 0; j < 5; j++) {\n        if (b[i][j] == '0') {\n          cx[it] = j;\n          cy[it] = i;\n          it++;\n        }\n      }\n    }\n    turn = 0;\n  }\n  char conv_hex(int a) { return \"0123456789ABCDEF\"[a]; }\n  bool slide(int index, int dir) {\n    int px = cx[index], py = cy[index];\n    int nx = px + dx[dir], ny = py + dy[dir];\n    if (invalid(nx, ny)) return false;\n    if (b[ny][nx] == '#') return false;\n    if (b[ny][nx] == '0') return false;\n    swap(b[py][px], b[ny][nx]);\n    cx[index] = nx;\n    cy[index] = ny;\n    turn++;\n    return true;\n  }\n  bool invalid(int x, int y) { return x < 0 || x >= 5 || y < 0 || y >= 5; }\n  char b[5][6];\n  int cx[2], cy[2];\n  int turn;\n};\n\nint main() {\n  ZobristHash<int, 6, 5, 256> zh;\n  int h;\n  static const char cb[5][6] = {\"##0##\", \"#123#\", \"45678\", \"#9AB#\", \"##0##\", };\n  const int ehv = zh.hash(cb);\n  while (h = in(), h != -1) {\n    vector<vector<int>> vs(5);\n    vs[0].emplace_back(h);\n    inpt(vs[1], 3, in);\n    inpt(vs[2], 5, in);\n    inpt(vs[3], 3, in);\n    inpt(vs[4], 1, in);\n    Board b(vs);\n    queue<Board> Q;\n    set<int> vis;\n    const int ihv = zh.hash(b.b);\n    if (ihv == ehv){\n      cout << 0 << endl;\n      continue;\n    }\n    vis.insert(ihv);\n    Q.push(b);\n\n    while (!Q.empty()) {\n      Board bi = Q.front();\n      Q.pop();\n      if (bi.turn > 13) break;\n      for (int i = 0; i < 2; i++) {\n        for (int d = 0; d < 4; d++) {\n          Board bii = bi;\n          if (!bii.slide(i, d)) continue;\n          int hv = zh.hash(bii.b);\n          if (ehv == hv){\n            cout << bii.turn << endl;\n            goto END;\n          }\n          if (vis.count(hv)) continue;\n          vis.insert(hv);\n          Q.push(bii);\n        }\n      }\n    }\n  cout << \"NA\" << endl;\nEND:;\n  }\n  return 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include <iostream>\n#include <cstdio>\n#include <queue>\n#include <set>\n#include <map>\n#include <cmath>\nusing namespace std;\ntypedef unsigned long long ull;\null B = 1000000007ull;\nint a[5]={2,1,0,1,2};\nint b[5]={2,3,4,3,2};\nint dx[5]={0,1,0,-1};\nint dy[5]={1,0,-1,0};\nint px[13]={0,1,1,1,2,2,2,2,2,3,3,3,0};\nint py[13]={0,1,2,3,0,1,2,3,4,0,1,2,0};\n\nstruct State\n{\n\tint f[5][5];\n\tint t;\n};\null hash(State x)\n{\n\tull t = 1ull;\n\tull res = 0;\n\tfor(int i=0;i<5;i++)\n\t{\n\t\tfor(int j=a[i];j<=b[i];j++)\n\t\t{\n\t\t\tres += x.f[i][j]*t;\n\t\t\tt *= B;\n\t\t}\n\t}\n\treturn res;\n}\nmap<ull,int> mp;\nset<ull> used;\nbool check(State x)\n{\n\tint cnt=1;\n\tfor(int i=1;i<=3;i++)\n\t{\n\t\tfor(int j=a[i];j<=b[i];j++)\n\t\t{\n\t\t\tif(x.f[i][j]!=cnt)return false;\n\t\t\tcnt++;\n\t\t}\n\t}\n\treturn true;\n}\nbool cc(State x)\n{\n\tint res = 0;\n\tfor(int i=0;i<5;i++)\n\t{\n\t\tfor(int j=a[i];j<=b[i];j++)\n\t\t{\n\t\t\tif(x.f[i][j])\n\t\t\t{\n\t\t\t\tint k = x.f[i][j];\n\t\t\t\tres += (abs(px[k]-i)+abs(py[k]-j));\n\t\t\t}\n\t\t}\n\t}\n\treturn (res>20-x.t);\n}\nint ans = 21;\nvoid bfs(State st)\n{\n\tqueue<State> q;\n\tmp[hash(st)]=0;\n\tq.push(st);\n\twhile(!q.empty())\n\t{\n\t\tState A = q.front();\n\t\tq.pop();\n\t\t//cout << \"koko\" << endl;\n\t\tfor(int i=0;i<5;i++)\n\t\t{\n\t\t\tfor(int j=0;j<5;j++)\n\t\t\t{\n\t\t\t\tif(j<a[i]||b[i]<j)continue;\n\t\t\t\tif(A.f[i][j]==0)continue;\n\t\t\t\tfor(int k=0;k<4;k++)\n\t\t\t\t{\n\t\t\t\t\tint nx=i+dx[k],ny=j+dy[k];\n\t\t\t\t\tif(nx<0||nx>=5||ny<0||ny>=5)continue;\n\t\t\t\t\tif(ny<a[nx]||b[nx]<ny)continue;\n\t\t\t\t\tif(A.f[nx][ny]!=0)continue;\n\t\t\t\t\tState B = A;\n\t\t\t\t\tswap(B.f[nx][ny],B.f[i][j]);\n\t\t\t\t\tB.t++;\n\t\t\t\t\t//cout << \"a\" << endl;\n\t\t\t\t\tif(B.t>8)continue;\n\t\t\t\t\tull hb = hash(B);\n\t\t\t\t\tif(mp.find(hb)!=mp.end())continue;\n\t\t\t\t\t//cout << hb << endl;\n\t\t\t\t\tmp[hb]=B.t;\n\t\t\t\t\tq.push(B);\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t}\n\t//cout << \"owari\" << endl;\n}\nvoid bfs2(State st)\n{\n\tqueue<State> q;\n\tif(check(st)){ans=0;return;}\n\tq.push(st);\n\twhile(!q.empty())\n\t{\n\t\tState A = q.front();\n\t\tq.pop();\n\t\tull ha=hash(A); \n\t\tif(mp.find(hash(A))!=mp.end()){ans = min(ans,A.t+mp[ha]);continue;}\n\t\tfor(int i=0;i<5;i++)\n\t\t{\n\t\t\tfor(int j=0;j<5;j++)\n\t\t\t{\n\t\t\t\tif(j<a[i]||b[i]<j)continue;\n\t\t\t\tif(A.f[i][j]==0)continue;\n\t\t\t\tfor(int k=0;k<4;k++)\n\t\t\t\t{\n\t\t\t\t\tint nx=i+dx[k],ny=j+dy[k];\n\t\t\t\t\tif(nx<0||nx>=5||ny<0||ny>=5)continue;\n\t\t\t\t\tif(ny<a[nx]||b[nx]<ny)continue;\n\t\t\t\t\tif(A.f[nx][ny]!=0)continue;\n\t\t\t\t\tState B = A;\n\t\t\t\t\tswap(B.f[nx][ny],B.f[i][j]);\n\t\t\t\t\tB.t++;\n\t\t\t\t\tif(cc(B))continue;\n\t\t\t\t\tull hb = hash(B);\n\t\t\t\t\tif(used.find(hb)!=used.end())continue;\n\t\t\t\t\tused.insert(hb);\n\t\t\t\t\tq.push(B);\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t}\n}\nint main()\n{\n\tState end;\n\tint cnt=1;\n\tend.t=0;\n\tfor(int i=0;i<5;i++)for(int j=0;j<5;j++)end.f[i][j]=-1;\n\tend.f[0][2]=0;\n\tend.f[4][2]=0;\n\tfor(int i=1;i<=3;i++)for(int j=a[i];j<=b[i];j++)end.f[i][j]=cnt++;\n\t/*for(int i=0;i<5;i++)\n\t{\n\t\tfor(int j=a[i];j<=b[i];j++)cout << end.f[i][j] << ' ';\n\t\tcout << endl;\n\t}*/\n\tbfs(end);\n\twhile(1)\n\t{\n\t\tState st;\n\t\tused.clear();\n\t\tans = 21;\n\t\tfor(int i=0;i<5;i++)for(int j=0;j<5;j++)st.f[i][j]=-1;\n\t\tfor(int i=0;i<5;i++)\n\t\t{\n\t\t\tfor(int j=a[i];j<=b[i];j++)\n\t\t\t{\n\t\t\t\tcin >> st.f[i][j];\n\t\t\t\tif(st.f[i][j]==-1)goto end;\n\t\t\t}\n\t\t}\n\t\tst.t=0;\n\t\tbfs2(st);\n\t\tif(ans>20)printf(\"NA\\n\");\n\t\telse printf(\"%d\\n\",ans);\n\t}\n\tend:;\n\treturn 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include<bits/stdc++.h>\nusing namespace std;\n  \ntypedef long long int64;\nconst int INF = 1 << 30;\n  \nvector< int > edge[13];\nmap< string, int > memo;\n \nbool back(string str, int cnt){ //枝刈り大事だな\n  static int dist[] = { 0, 2, 1, 2, 4, 3, 2, 3, 4, 2, 1, 2, 0};\n  static int fuee[] = { 2, 0, 1, 2, 2, 1, 2, 3, 4, 2, 3, 4, 4};\n  static int fuga[] = { 1, 1, 0, 1, 3, 2, 1, 2, 3, 3, 2, 3, 3};\n  static int haaa[] = { 2, 2, 1, 0, 4, 3, 2, 1, 2, 4, 3, 2, 4};\n  static int kira[] = { 3, 3, 2, 3, 3, 2, 1, 2, 3, 1, 0, 1, 1};\n \n  if(cnt > 20) return true;\n  int foo1 = 0, foo2 = 0, foo3 = 0, foo4 = 0, foo5 = 0;\n  for(int i = 0; i < 13; i++){\n    if(str[i] == '0') foo1 += dist[i];\n    else if(str[i] == '1') foo2 += fuee[i];\n    else if(str[i] == '2') foo3 += fuga[i];\n    else if(str[i] == '3') foo4 += haaa[i];\n    else if(str[i] == 'A') foo5 += kira[i];\n  }\n  return cnt + foo1 + foo2 + foo3 + foo4 + foo5 > 30;\n}\n \n \nint bfs(string mas){\n \n  queue< string > que;\n  map< string , int > used;\n  que.push( mas );\n  memo[mas] = 0;\n  while(!que.empty()){\n \n    string p = que.front(); que.pop();\n    if(back( p, memo[p])) break;\n    if(p == \"0123456789AB0\") return memo[p];\n \n    for(int i = 0; i < 13; i++){\n      if(p[i] == '0') {\n        for(int j = 0; j < edge[i].size(); j++){\n          string next = p;\n          swap( next[i], next[edge[i][j]]);\n          if(memo.find(next) != memo.end()) continue;\n          que.push( next );\n          memo[next] = memo[p] + 1;\n        }\n      }\n    }\n  }\n  return -1;\n}\n \nint main(){\n  vector< int > mas(13);\n \n  edge[0].push_back(2);\n  edge[1].push_back(2); edge[1].push_back(4);\n  edge[2].push_back(0); edge[2].push_back(1); edge[2].push_back(3); edge[2].push_back(6);\n  edge[3].push_back(2); edge[3].push_back(7);\n  edge[4].push_back(5);\n  edge[5].push_back(1); edge[5].push_back(4); edge[5].push_back(6); edge[5].push_back(9);\n  edge[6].push_back(2); edge[6].push_back(5); edge[6].push_back(7); edge[6].push_back(10);\n  edge[7].push_back(3); edge[7].push_back(6); edge[7].push_back(8); edge[7].push_back(11);\n  edge[8].push_back(7);\n  edge[9].push_back(5); edge[9].push_back(10);\n  edge[10].push_back(6); edge[10].push_back(9); edge[10].push_back(11); edge[10].push_back(12);\n  edge[11].push_back(7); edge[11].push_back(10);\n  edge[12].push_back(10);\n \n  while(cin >> mas[0], mas[0] != -1){\n    for(int i = 1; i < 13; i++){\n      cin >> mas[i];\n    }\n \n    string start = \"\";\n    for(int i = 0; i < 13; i++){\n      if(mas[i] >= 10) start += (char)(mas[i] - 10 + 'A');\n      else start += mas[i] + '0';\n    }\n    int ret = bfs(start);\n    if(~ret) cout << ret << endl;\n    else cout << \"NA\" << endl;\n \n    memo.clear();\n  }\n}"
  },
  {
    "language": "C++",
    "code": "#include<iostream>\n#include<algorithm>\n#include<vector>\n#include<queue>\n#include<unordered_map>\n#define lol(i,n) for(int i=0;i<n;i++)\n#define mod 1000000007\ntypedef long long ll;\nusing namespace std;\nint dx[13][4]={\n  {3,0,0,0},\n  {3,6,0,0},\n  {1,2,4,6},\n  {3,8,0,0},\n  {6,0,0,0},\n  {2,5,7,10},\n  {3,6,8,11},\n  {4,7,9,12},\n  {8,0,0,0},\n  {6,11,0,0},\n  {6,10,12,13},\n  {8,11,0,0},\n  {11,0,0,0}\n};\nunordered_map<ll,int> mp;\nll Compress(int p[]){\n  ll ans=0;\n  for(int i=0;i<13;i++){\n    ans*=13;\n    ans+=p[i];\n  }\n  return ans;\n}\n\nint unzip[13];\nvoid Unzip(ll x){\n  for(int i=0;i<13;i++){\n    unzip[12-i]=x%13;\n    x/=13;\n  }\n}\n\nint beflen=0;\nqueue<pair<ll,int> >Q;\nvoid BFS(int p[],int len){\n  //if(len!=beflen){cout<<len<<endl;beflen=len;}\n  ll tmp=Compress(p);\n  mp[tmp]=len;\n  if(len==21)return;\n  lol(i,13){\n    if(p[i]==0){\n      lol(j,4){\n\tint t=dx[i][j];\n\tif(t==0)break;\n\tt--;\n\tif(p[t]!=0){\n\t  swap(p[i],p[t]);\n\t  tmp=Compress(p);\n\t  if(mp[tmp]!=0)continue;\n\t  mp[tmp]=-1;\n\t  Q.push(make_pair(tmp,len+1));\n\t  swap(p[i],p[t]);\n\t}\n      }\n    }\n  }\n}\nint main(){\n  int p[13];\n  lol(i,13)p[i]=i;p[12]=0;\n  Q.push(make_pair(Compress(p),1));\n  while(!Q.empty()){\n    ll data=Q.front().first;\n    int len=Q.front().second;\n    Q.pop();\n    if(mp[data]>0)continue;\n    Unzip(data);\n    BFS(unzip,len);\n  }\n  while(cin>>p[0]&&p[0]!=-1){\n    for(int i=1;i<13;i++)cin>>p[i];\n    ll tmp=Compress(p);\n    int cost=mp[tmp];\n    if(cost==0)cout<<\"NA\"<<endl;\n    else cout<<cost-1<<endl;\n  }\n  return 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include<bits/stdc++.h>\n#define r(i,n) for(int i=0;i<n;i++)\nusing namespace std;\ntypedef pair<vector<int>,int>P;\nvector<int>v[13],s(13),t(13);\nmap<vector<int>,int>m;\n \nint has[14];\n \n \nvoid init(){\n \n    v[0].push_back(2);\n \n    v[1].push_back(2);\n    v[1].push_back(5);\n \n    v[2].push_back(0);\n    v[2].push_back(1);\n    v[2].push_back(3);\n    v[2].push_back(6);\n \n    v[3].push_back(2);\n    v[3].push_back(7);\n \n    v[4].push_back(5);\n \n    v[5].push_back(1);\n    v[5].push_back(4);\n    v[5].push_back(6);\n    v[5].push_back(9);\n \n    v[6].push_back(2);\n    v[6].push_back(5);\n    v[6].push_back(7);\n    v[6].push_back(10);\n \n    v[7].push_back(3);\n    v[7].push_back(6);\n    v[7].push_back(8);\n    v[7].push_back(11);\n \n    v[8].push_back(7);\n \n    v[9].push_back(5);\n    v[9].push_back(10);\n \n    v[10].push_back(6);\n    v[10].push_back(9);\n    v[10].push_back(11);\n    v[10].push_back(12);\n \n    v[11].push_back(7);\n    v[11].push_back(10);\n \n    v[12].push_back(10);\n \n    int a=20;\n    int p=1;\n \n    r(i,13){\n        has[i]=p;\n        p*=a;\n    }\n}\n \nint ha(vector<int> &x){\n \n    int re=0;\n \n    r(i,13){\n        re+=x[i]*has[i];\n    }\n \n    return re;\n}\n \nvector<int> ah(int x){\n    vector<int>y(13);\n    r(i,13){\n        y[i]=x%20;\n        x/=20;\n    }\n    return y;\n}\n \nvoid BFS1(){\n    s[0]=0;\n    s[12]=0;\n    r(i,11)s[i+1]=i+1;\n    set<vector<int> >st;\n    st.insert(s);\n    m[s]=0;\n    queue<P>q;\n    q.push(P(s,0));\n    while(1){\n        vector<int> now=q.front().first;\n        int cost=q.front().second;\n        q.pop();\n        if(cost==13)break;\n        //cout<<m.size()<<' '<<cost<<endl;\n        r(i,13)if(now[i]==0){\n            r(j,v[i].size()){\n                swap(now[i],now[v[i][j]]);\n                if(!st.count(now)){\n                    st.insert(now);\n                    m[now]=cost+1;\n                    q.push(P(now,cost+1));\n                }\n                swap(now[i],now[v[i][j]]);\n            }\n        }\n    }\n}\n \nvoid BFS2(){\n    set<vector<int> >st;\n    st.insert(t);\n    queue<P>q;\n    q.push(P(t,0));\n    while(1){\n        vector<int>now=q.front().first;\n        int cost=q.front().second;\n        q.pop();\n        if(m.count(now)){\n            cout<<m[now]+cost<<endl;\n            return ;\n        }\n        if(cost==7)break;\n        r(i,13)if(now[i]==0){\n            r(j,v[i].size()){\n                swap(now[i],now[v[i][j]]);\n                if(!st.count(now)){\n                    st.insert(now);\n                    if(m.count(now)){\n                        cout<<m[now]+cost+1<<endl;\n                        return ;\n                    }\n                    q.push(P(now,cost+1));\n                }\n                swap(now[i],now[v[i][j]]);\n            }\n        }\n    }\n    cout<<\"NA\"<<endl;\n}\n \n \nsigned main(){\n    init();\n    BFS1();\n    while(cin>>t[0],t[0]!=-1){\n        r(i,12)cin>>t[i+1];\n        BFS2();\n    }\n}\n"
  },
  {
    "language": "C++",
    "code": "#include <iostream>\n#include <algorithm>\n#include <vector>\n#include <cstring>\n#include <cstdio>\n#include <climits>\n\nusing namespace std;\n\n\n#define REP(i,a,n) for(int i=(a); i<(int)(n); i++)\n#define rep(i,n) REP(i,0,n)\n#define DEB 0\n\nint board[7][7]; //1base\nint sx[2], sy[2];\nstatic const int dx[] = {0,0,1,-1};\nstatic const int dy[] = {1,-1,0,0};\n\nint calc(int y, int x){\n    switch(board[y][x]){\n    case 1: return abs(2-y)+abs(2-x);\n    case 2: return abs(2-y)+abs(3-x);\n    case 3: return abs(2-y)+abs(4-x);\n    case 4: return abs(3-y)+abs(1-x);\n    case 5: return abs(3-y)+abs(2-x);\n    case 6: return abs(3-y)+abs(3-x);\n    case 7: return abs(3-y)+abs(4-x);\n    case 8: return abs(3-y)+abs(5-x);\n    case 9: return abs(4-y)+abs(2-x);\n    case 10: return abs(4-y)+abs(3-x);\n    case 11: return abs(4-y)+abs(4-x);\n    }\n    return -1;\n}\nint dist(void){\n    int ret = 0;\n    if( board[1][3] ) ret += calc(1,3);\n    rep(i,3) if( board[2][2+i] ) ret += calc(2,2+i);\n    rep(i,5) if( board[3][1+i] ) ret += calc(3,1+i);\n    rep(i,3) if( board[4][2+i] ) ret += calc(4,2+i);\n    if( board[5][3] ) ret += calc(5,3);\n    return ret;\n}\nbool isgoal(void){\n    if( board[1][3]!=0 ) return false;\n    rep(i,3) if( board[2][2+i]!=i+1 ) return false;\n    rep(i,5) if( board[3][1+i]!=i+4 ) return false;\n    rep(i,3) if( board[4][2+i]!=i+9 ) return false;\n    if( board[5][3]!=0 ) return false;\n    return true;\n}\n\nbool dfs(int cnt, int LIM, int py, int px, const vector<pair<int,int> > sp){\n    if( isgoal() ) return true;\n    if( cnt+dist()>LIM ) return false;\n\n    rep(i,2){\n        if( board[sp[i].second][sp[i].first]!=0 ) exit(-1);\n        rep(k,4){\n            int tx = sp[i].first + dx[k];\n            int ty = sp[i].second + dy[k];\n            if( board[ty][tx]<=0 || py==ty&&px==tx ) continue;\n\n            swap(board[sp[i].second][sp[i].first], board[ty][tx]);\n\n            vector<pair<int,int> > v = sp;\n            pair<int,int> tmp(tx,ty);\n            swap(v[i], tmp);\n            if( dfs(cnt+1, LIM, sp[i].second, sp[i].first, v) ) return true;\n\n            swap(board[sp[i].second][sp[i].first] ,board[ty][tx]);\n        }\n    }\n    return false;\n}\nint solve(void){\n    int ttx[2], tty[2];\n    int tb[7][7];\n    vector<pair<int,int> > sp;\n    rep(i,2) sp.push_back(make_pair(sx[i],sy[i]));\n    //rep(i,7)rep(j,7) tb[i][j] = board[i][j];\n\n    for(int lim = 0; lim < 21; lim++){\n        if( dfs(0,lim,-1,-1,sp) ) return lim;\n        //rep(i,7)rep(j,7)if( board[i][j]!=tb[i][j] ) puts(\"ugeeeee\");\n    }\n    return -1;\n}\nint main(){\n    for(;;){\n        memset(board, -1, sizeof(board));\n        int sz = 0;\n\n        scanf(\"%d\",&board[1][3]); if( board[1][3]==-1 ) break;\n        rep(i,3) scanf(\"%d\",&board[2][2+i]);\n        rep(i,5) scanf(\"%d\",&board[3][1+i]);\n        rep(i,3) scanf(\"%d\",&board[4][2+i]);\n        scanf(\"%d\",&board[5][3]);\n\n        // find space\n        if( board[1][3]==0 ){ sx[sz]=3; sy[sz]=1; sz++; }\n        rep(i,3) if( board[2][2+i]==0 ) { sx[sz]=2+i; sy[sz]=2; sz++; }\n        rep(i,5) if( board[3][1+i]==0 ) { sx[sz]=1+i; sy[sz]=3; sz++; }\n        rep(i,3) if( board[4][2+i]==0 ) { sx[sz]=2+i; sy[sz]=4; sz++; }\n        if( board[5][3]==0 ){ sx[sz]=3; sy[sz]=5; sz++; }\n\n        //printf(\"hoge:%d\\n\",dist());\n        int ans = solve();\n        if( ans!=-1 ) printf(\"%d\\n\",ans); else puts(\"NA\");\n    }\n    return 0;\n}\n\n/*\n\n//-------------------------------------------------------\n\n#define N 5\n#define REP(i, n) for ( int i = 0; i < (int)n; i++ )\n#define LIMIT 20\n\nstatic const int T[12][2] = {\n    {-1, -1},\n    {1, 1}, \n    {1, 2}, \n    {1, 3},\n    {2, 0},\n    {2, 1},\n    {2, 2},\n    {2, 3},\n    {2, 4},\n    {3, 1}, \n    {3, 2},\n    {3, 3}\n};\nstatic const int g[N][N] = {\n    {-1,-1, 0,-1,-1},\n    {-1, 1, 2, 3,-1},\n    { 4, 5, 6, 7, 8},\n    {-1, 9,10,11,-1}, \n    {-1,-1, 0,-1,-1}\n};\n\nclass Puzzle{\npublic:\n    int C[N][N], mdist; //manhatta distance\n    Puzzle(){}\n\n    bool swapAdj( int si, int sj, int ti, int tj ){\n        if ( ti < 0 || tj < 0 || ti >= N || tj >= N ) return false;\n        if ( C[ti][tj] <= 0 ) return false;\n        swap(C[ti][tj], C[si][sj]);\n        int tti = T[C[si][sj]][0];\n        int ttj = T[C[si][sj]][1];\n        //mdist -= max(tti, ti)-min(tti, ti) + max(ttj, tj)-min(ttj, tj);\n        //mdist += max(tti, si)-min(tti, si) + max(ttj, sj)-min(ttj, sj);\n        //mdist -= abs(tti-ti)+abs(ttj-tj);\n        //mdist += abs(tti-si)+abs(ttj-sj);\n        return true;\n    }\n\n    bool isGoal(){\n        REP(i, N) REP(j, N) if ( g[i][j] != C[i][j] ) return false;\n        return true;\n    }\n\n    int getMD(){ // get initial manhattan distance\n        int sum = 0;\n        int ti, tj;\n        REP(i, 5) REP(j, 5){\n            if ( C[i][j] <= 0 ) continue;\n            ti = T[C[i][j]][0];\n            tj = T[C[i][j]][1];\n            //sum += (max(ti, i)-min(ti, i) + max(tj, j) - min(tj, j));\n            sum += abs(ti-i) + abs(tj-j);\n        }\n        return sum;\n    }\n};\n\nint limit;\n\nbool dfs( int depth, Puzzle P ){\n    if ( P.isGoal() ) return true;\n    if ( depth + P.getMD() > limit ) return false;\n\n    static const int di[4] = {0, -1, 0, 1};\n    static const int dj[4] = {1, 0, -1, 0};\n\n    REP(i, N) REP(j, N){\n        if ( P.C[i][j] != 0 ) continue;\n        REP(r, 4){\n            Puzzle v = P;\n            if ( !v.swapAdj(i, j, i+di[r], j+dj[r]) ) continue;\n            if ( dfs( depth + 1, v ) ) return true;\n        }\n    }\n\n    return false;\n}\n\nint idp(Puzzle source){\n    for ( limit = 0; limit <= LIMIT; limit++ ){\n        //source.mdist = source.getMD();\n        if ( dfs(0, source) ) return limit;\n    }\n    return INT_MAX;\n}\n\nint main(){\n    Puzzle P;\n    int top;\n\n    while(1){\n        cin >> top;\n        if ( top == -1 ) break;\n        REP(j, N) P.C[0][j] = -1;\n        P.C[0][2] = top;\n        for(int i = 1; i < N; i++) REP(j, N){\n                if ( (i == 1 || i == 3) && (j == 0 || j == 4 ) ) P.C[i][j] = -1;\n                else if ( i == 4 && j != 2 ) P.C[i][j] = -1;\n                else cin >> P.C[i][j];\n            }\n\n        int cost = idp(P);\n        if ( cost == INT_MAX ) cout << \"NA\" << endl;\n        else cout << cost << endl;\t\n    }\n\n    return 0;\n}\n\n*/"
  },
  {
    "language": "C++",
    "code": "#include<iostream>\n#include<vector>\n#include<map>\n#include<queue>\n#include<algorithm>\nusing namespace std;\n\nconst int N = 13;\nconst vector<vector<int>> NEXT = {\n    {2},\n    {2, 5},\n    {0, 1, 3, 6},\n    {2, 7},\n    {5},\n    {1, 4, 6, 9},\n    {2, 5, 7, 10},\n    {3, 6, 8, 11},\n    {7},\n    {5, 10},\n    {6, 9, 11, 12},\n    {7, 10},\n    {10},\n};\n\nclass Node {\npublic:\n    vector<int> puzzle;\n    int depth;\n    Node(const vector<int>& p, int d) :puzzle(p), depth(d) {}\n};\n\nmap<vector<int>, int> memo1;\nmap<vector<int>, int> memo2;\n\nvoid bfs(const vector<int>& puzzle, map<vector<int>, int>& memo) {\n    queue<Node> q;\n    q.push(Node(puzzle, 0));\n    while(!q.empty()) {\n        Node current(q.front()); q.pop();\n        if(current.depth > 1) continue;\n        if(memo.count(current.puzzle)) continue;\n        memo[current.puzzle] = current.depth;\n        for(int i = 0; i < N; ++i) {\n            if(current.puzzle[i] != 0) continue;\n            for(const auto& j: NEXT[i]) {\n                vector<int> next(current.puzzle);\n                swap(next[i], next[j]);\n                q.push(Node(next, current.depth + 1));\n            }\n        }\n    }\n}\n\nint main() {\n    vector<int> complete = {0, 1, 2, 3, 4, 5, 6, 7, 8, 9, 10, 11, 0};\n    vector<int> puzzle(N);\n    bfs(complete, memo1);\n    while(cin >> puzzle[0], puzzle[0] != -1) {\n        for(int i = 1; i < N; ++i) cin >> puzzle[i];\n        memo2.clear();\n        bfs(puzzle, memo2);\n        int answer = 21;\n        for(auto& i: memo1) if(memo2.count(get<0>(i))) answer = min(answer, get<1>(i) + memo2[get<0>(i)]);\n        if(answer > 20) cout << \"NA\" << endl;\n        else cout << answer << endl;\n    }\n}"
  },
  {
    "language": "C++",
    "code": "#include<bits/stdc++.h>\n#define int long long\n#define r(i,n) for(int i=0;i<n;i++)\nusing namespace std;\ntypedef pair<int,int>P;\nvector<int>v[13],s(13),t(13);\nunordered_map<int,int>m;\n\nint has[14];\n\n\nvoid init(){\n\n    v[0].push_back(2);\n\n    v[1].push_back(2);\n    v[1].push_back(5);\n\n    v[2].push_back(0);\n    v[2].push_back(1);\n    v[2].push_back(3);\n    v[2].push_back(6);\n\n    v[3].push_back(2);\n    v[3].push_back(7);\n\n    v[4].push_back(5);\n\n    v[5].push_back(1);\n    v[5].push_back(4);\n    v[5].push_back(6);\n    v[5].push_back(9);\n\n    v[6].push_back(2);\n    v[6].push_back(5);\n    v[6].push_back(7);\n    v[6].push_back(10);\n\n    v[7].push_back(3);\n    v[7].push_back(6);\n    v[7].push_back(8);\n    v[7].push_back(11);\n\n    v[8].push_back(7);\n\n    v[9].push_back(5);\n    v[9].push_back(10);\n\n    v[10].push_back(6);\n    v[10].push_back(9);\n    v[10].push_back(11);\n    v[10].push_back(12);\n\n    v[11].push_back(7);\n    v[11].push_back(10);\n\n    v[12].push_back(10);\n\n    int a=20;\n    int p=1;\n\n    r(i,13){\n        has[i]=p;\n        p*=a;\n    }\n}\n\nint ha(vector<int> &x){\n\n    int re=0;\n\n    r(i,13){\n        re+=x[i]*has[i];\n    }\n\n    return re;\n}\n\nvector<int> ah(int x){\n    vector<int>y(13);\n    r(i,13){\n        y[i]=x%20;\n        x/=20;\n    }\n    return y;\n}\n\nvoid BFS1(){\n    s[0]=0;\n    s[12]=0;\n    r(i,11)s[i+1]=i+1;\n    unordered_set<int>st;\n    st.insert(ha(s));\n    m[ha(s)]=0;\n    queue<P>q;\n    q.push(P(ha(s),0));\n    while(1){\n        vector<int> now=ah(q.front().first);\n        int cost=q.front().second;\n        q.pop();\n        if(cost==8)break;\n        //cout<<m.size()<<' '<<cost<<endl;\n        r(i,13)if(now[i]!=0){\n            r(j,v[i].size()){\n                swap(now[i],now[v[i][j]]);\n                int yy=ha(now);\n                if(!st.count(yy)){\n                    st.insert(yy);\n                    m[yy]=cost+1;\n                    q.push(P(yy,cost+1));\n                }\n                swap(now[i],now[v[i][j]]);\n            }\n        }\n    }\n}\n\nvoid BFS2(){\n    unordered_set<int>st;\n    st.insert(ha(t));\n    queue<P>q;\n    q.push(P(ha(t),0));\n    while(1){\n        vector<int>now=ah(q.front().first);\n        int cost=q.front().second;\n        int y=ha(now);\n        if(m.count(y)){\n            cout<<m[y]+cost<<endl;\n            return ;\n        }\n        q.pop();\n        if(cost==6)break;\n        r(i,13)if(now[i]!=0){\n            r(j,v[i].size()){\n                swap(now[i],now[v[i][j]]);\n                int yy=ha(now);\n                if(!st.count(yy)){\n                    st.insert(yy);\n                    q.push(P(yy,cost+1));\n                }\n                swap(now[i],now[v[i][j]]);\n            }\n        }\n    }\n    cout<<\"NA\"<<endl;\n}\n\n\nsigned main(){\n    init();\n    BFS1();\n    while(cin>>t[0],t[0]!=-1){\n        r(i,12)cin>>t[i+1];\n        BFS2();\n    }\n}\n"
  },
  {
    "language": "C++",
    "code": "#include <iostream>\n#include <string>\n#include <sstream>\n#include <map>\n#include <queue>\nusing namespace std;\n\n#define REP(i,n,m) for(int i=n;i<m;i++)\n#define rep(i,n) REP(i,0,n)\n\nclass State{\npublic:\n\tstring s;\n\tint cost;\n\tint idx[2];\n\n\tState(string ts,int tcost,int tidx[]){\n\t\ts = ts;\n\t\tcost = tcost;\n\t\tidx[0] = tidx[0];\n\t\tidx[1] = tidx[1];\n\t}\n};\n\nint di[13][4] = {\n\t{-1,-1,2,-1},\n\t{-1,2,5,-1},\n\t{0,3,6,1},\n\t{-1,-1,7,2},\n\t{-1,5,-1,-1},\n\t{1,6,9,4},\n\t{2,7,10,5},\n\t{3,8,11,6},\n\t{-1,-1,-1,7},\n\t{5,10,-1,-1},\n\t{6,11,12,9},\n\t{7,-1,-1,10},\n\t{10,-1,-1,-1},\n};\n\nvoid printPuzzle(string s){\n\tcout<<\"  \"<<s.substr(0,1)<<endl;\n\tcout<<\" \"<<s.substr(1,3)<<endl;\n\tcout<<s.substr(4,5)<<endl;\n\tcout<<\" \"<<s.substr(9,3)<<endl;\n\tcout<<\"  \"<<s.substr(12,1)<<endl;\n\tcout<<\"----------------------------\\n\";\n}\n\nqueue<State> open;\nmap<string,int> closed,closed2;\n\nint main(void){\n\tstring alpha = \"abcdefghijkl\";\n\tint idx[] = {0,12};\n\n\topen.push(State(\"abcdefghijkla\",0,idx));\n\tclosed.insert(pair<string,int>(\"abcdefghijkla\",0));\n\n\twhile(!open.empty()){\n\t\tState st = open.front(); open.pop();\n\t\tif(st.cost >= 14) continue;\n\n\t\trep(i,2){\n\t\t\trep(j,4){\n\t\t\t\tint to = di[st.idx[i]][j];\n\t\t\t\tif(to == -1) continue;\n\n\t\t\t\tstring res = st.s;\n\t\t\t\tint tmp = res[st.idx[i]];\n\t\t\t\tres[st.idx[i]] = res[to];\n\t\t\t\tres[to] = tmp;\n\n\t\t\t\tif(closed.find(res) == closed.end()){\n\t\t\t\t\tidx[0] = i==0 ? to : st.idx[0];\n\t\t\t\t\tidx[1] = i==1 ? to : st.idx[1];\n\t\t\t\t\topen.push(State(res,st.cost+1,idx));\n\t\t\t\t\tclosed.insert(pair<string,int>(res,st.cost+1));\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t}\n\n\twhile(1){\n\t\tint x;\n\t\tcin>>x;\n\t\tif(x == -1) break;\n\n\t\tstringstream ss;\n\t\tss<<alpha[x];\n\t\trep(i,12){\n\t\t\tcin>>x;\n\t\t\tss<<alpha[x];\n\t\t}\n\n\t\tstring start = ss.str();\n\n\t\twhile(!open.empty()) open.pop();\n\n\t\tfor(idx[0]=0;start[idx[0]]!='a';idx[0]++);\n\t\tfor(idx[1]=start.length()-1;start[idx[1]]!='a';idx[1]--);\n\t\topen.push(State(start,0,idx));\n\t\tclosed2.insert(pair<string,int>(start,0));\n\n\t\tint ans = -1;\n\n\t\twhile(!open.empty()){\n\t\t\tState st = open.front(); open.pop();\n\t\t\tif(closed.find(st.s) != closed.end() && st.cost + closed[st.s] <= 20){\n\t\t\t\tans = st.cost + closed[st.s];\n\t\t\t\tbreak;\n\t\t\t}\n\t\t\tif(st.cost >= 7) continue;\n\n\t\t\trep(i,2){\n\t\t\t\trep(j,4){\n\t\t\t\t\tint to = di[st.idx[i]][j];\n\t\t\t\t\tif(to == -1) continue;\n\n\t\t\t\t\tstring res = st.s;\n\t\t\t\t\tint tmp = res[st.idx[i]];\n\t\t\t\t\tres[st.idx[i]] = res[to];\n\t\t\t\t\tres[to] = tmp;\n\n\t\t\t\t\tif(closed2.find(res) == closed2.end()){\n\t\t\t\t\t\tidx[0] = i==0 ? to : st.idx[0];\n\t\t\t\t\t\tidx[1] = i==1 ? to : st.idx[1];\n\t\t\t\t\t\topen.push(State(res,st.cost+1,idx));\n\t\t\t\t\t\tclosed2.insert(pair<string,int>(res,st.cost+1));\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\n\t\tif(ans == -1) cout<<\"NA\\n\";\n\t\telse cout<<ans<<endl;\n\t}\n\n\treturn 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\n\n#ifndef INCLUDE_ZOBRIST_HASH_HPP\n#define INCLUDE_ZOBRIST_HASH_HPP\n\n#include <random>\n#include <iostream>\n#include <typeinfo>\n\nnamespace orislib {\n\ntemplate<typename T, int W, int H, int STATE>\nstruct ZobristHash {\n  typedef T hash_t;\n  ZobristHash(){\n    std::random_device rd;\n    std::mt19937 mt(rd());\n    std::uniform_int_distribution<T> dist;\n    for (int h = 0; h < H; h++){\n      for (int w = 0; w < W; w++){\n        for (int s = 0; s < STATE; s++){\n          rands[h][w][s] = dist(mt);\n        }\n      }\n    }\n  }\n  template<typename TT>\n  hash_t hash(TT data[H][W]){\n    hash_t r = 0;\n    for (int h = 0; h < H; h++){\n      for (int w = 0; w < W; w++){\n        r ^= rands[h][w][data[h][w]];\n      }\n    }\n    return r;\n  }\n  hash_t rands[H][W][STATE];\n};\n}\n\n#endif\nusing namespace std;\nusing namespace orislib;\n\ntypedef long long ll;\ntypedef long double ld;\ntypedef tuple<int, int> duo;\nconst int dx[] = {0, 0, 1, -1, 1, 1, -1, -1};\nconst int dy[] = {1, -1, 0, 0, 1, -1, 1, -1};\nconst int Mod = 1000000000 + 0;\n//{{{ templates\n#define TT_ template<typename T>inline\n#define TTF_ template<typename T,typename F>inline\nTT_ T sq(T x){return x*x;}\nTT_ T In(){T x;cin>>x;return x;}\nTT_ void Out(T&x){cout<<x;}\nTT_ void sort(T&v){sort(begin(v),end(v));}\nTT_ void revs(T&v){reverse(begin(v),end(v));}\nTT_ void uniq(T&v){sort(v);v.erase(unique(begin(v),end(v)),end(v));}\nTT_ int ubnd(T&v,typename T::value_type&x){return upper_bound(begin(v),end(v),x)-begin(v);}\nTT_ int lbnd(T&v,typename T::value_type&x){return lower_bound(begin(v),end(v),x)-begin(v);}\nTTF_ void inpt(T&v,int n,F f){for(v.reserve(n);n--;v.emplace_back(f()));}\nTTF_ void show(T&v,F f,string d=\" \",string e=\"\\n\"){int i=0;for(auto&x:v)i++&&(cout<<d),f(x);cout<<e;}\nTT_ typename T::iterator minel(T&v){return min_element(begin(v),end(v));}\nTT_ typename T::iterator maxel(T&v){return max_element(begin(v),end(v));}\n\ninline void fast_io(){ios::sync_with_stdio(0);cin.tie(0);}\ninline int in(){int x;scanf(\"%d\",&x);return x;}\ninline ll pow_mod(ll a,ll k,ll m){ll r=1;for(;k>0;a=a*a%m,k>>=1)if(k&1)r=r*a%m;return r;}\ninline ll mod_inv(ll a,ll p){return pow_mod(a,p-2,p);}\n//}}} priority_queue queue deque front stringstream max_element min_element insert count make_tuple\n\nstruct Board {\n  Board(){}\n  Board(const vector<vector<int>>& v){\n    memset(b, '#', sizeof(b));\n    for (int i = 0; i < 5; i++) b[i][5] = 0;\n    for (int i = 0; i < v[0].size(); i++) b[0][2 + i] = conv_hex(v[0][i]);\n    for (int i = 0; i < v[1].size(); i++) b[1][1 + i] = conv_hex(v[1][i]);\n    for (int i = 0; i < v[2].size(); i++) b[2][0 + i] = conv_hex(v[2][i]);\n    for (int i = 0; i < v[3].size(); i++) b[3][1 + i] = conv_hex(v[3][i]);\n    for (int i = 0; i < v[4].size(); i++) b[4][2 + i] = conv_hex(v[4][i]);\n    int it = 0;\n    for (int i = 0; i < 5; i++){\n      for (int j = 0; j < 5; j++){\n        if (b[i][j] == '0'){\n          cx[it] = j;\n          cy[it] = i;\n          it++;\n        }\n      }\n    }\n  }\n  char conv_hex(int a){\n    return \"0123456789ABCDEF\"[a];\n  }\n  bool slide(int index, int dir){\n    int px = cx[index], py = cy[index];\n    int nx = px + dx[dir], ny = py + dy[dir];\n    if (invalid(nx, ny)) return false;\n    if (b[ny][nx] == '#') return false;\n    if (b[ny][nx] == '0') return false;\n    swap(b[py][px], b[ny][nx]);\n    cx[index] = nx;\n    cy[index] = ny;\n    return true;\n  }\n  bool is_ok(){\n    static const char cb[5][6] = {\n      \"##0##\",\n      \"#123#\",\n      \"45678\",\n      \"#9AB#\",\n      \"##0##\",\n    };\n    return memcmp(cb, b, sizeof(cb)) == 0;\n  }\n  bool invalid(int x, int y){\n    return x < 0 || x >= 5 || y < 0 || y >= 5;\n  }\n  char b[5][6];\n  int cx[2], cy[2];\n};\n\nint main()\n{\n  ZobristHash<int, 6, 5, 256> zh;\n  int h;\n  while (h = in(), h != -1){\n    vector<vector<int>> vs(5);\n    vs[0].emplace_back(h);\n    inpt(vs[1], 3, in);\n    inpt(vs[2], 5, in);\n    inpt(vs[3], 3, in);\n    inpt(vs[4], 1, in);\n    Board b(vs);\n    queue<Board> Q;\n    set<int> vis;\n    Q.push(b);\n    vis.insert(zh.hash(b.b));\n\n    int turn = 0;\n    while (!Q.empty()){\n      if (turn > 20) break;\n      queue<Board> nQ;\n      while (!Q.empty()){\n        Board bi = Q.front();\n        Q.pop();\n        if (bi.is_ok()){\n          cout << turn << endl;\n          goto END;\n        }\n        for (int i = 0; i < 2; i++){\n          for (int d = 0; d < 4; d++){\n            Board bii = bi;\n            if (!bii.slide(i, d)) continue;\n            int hv = zh.hash(bii.b);\n            if (vis.count(hv)) continue;\n            vis.insert(hv);\n            nQ.push(bii);\n          }\n        }\n      }\n      swap(Q, nQ);\n      turn++;\n    }\n    cout << \"NA\" << endl;\nEND:;\n  }\n  return 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include <iostream>\n#include <cstdio>\n#include <vector>\n#include <map>\n#include <string>\n#include <queue>\n#include <algorithm>\nusing namespace std;\n\nconst int INF = 1e+8;\nconst int f1[25] = {\n\t-1,-1, 0,-1,-1,\n\t-1, 1, 2, 3,-1,\n\t 4, 5, 6, 7, 8,\n\t-1, 9,10,11,-1,\n\t-1,-1,12,-1,-1,\n};\nconst int f2[13] = {2,6,7,8,10,11,12,13,14,16,17,18,22};\nconst int dx[4] = { 0,-1,+1, 0};\nconst int dy[4] = {-1, 0, 0,+1};\n\n// パズル\nstruct Pazzle{\n\tvector<char> v;\n\tPazzle(){v = vector<char>(13); }\n\tvoid at(int i, int p){\n\t\tv[i] = p;\n\t}\n\t// 空白の位置を返す. (k は 0 or 1)\n\tint search(int k){\n\t\tint a = 0;\n\t\tfor(int i=0 ; i < 13 ; i++ ){\n\t\t\tif( v[i] == 0 ){\n\t\t\t\tif( k == 0 ){\n\t\t\t\t\treturn i;\n\t\t\t\t}else{\n\t\t\t\t\tif( a == 0 ) a++;\n\t\t\t\t\telse return i;\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t\treturn -1;\n\t}\n\tint to_g(){\n\t\tint res = 0;\n\t\tint a = 0;\n\t\tfor(int i=0 ; i < 13 ; i++ ){\n\t\t\tint x1 = f2[v[i]] % 5;\n\t\t\tint y1 = f2[v[i]] / 5;\n\t\t\tint x2 = i % 5;\n\t\t\tint y2 = i / 5;\n\t\t\tif( v[i] == 0 ){\n\t\t\t\tif( a == 0 ){\n\t\t\t\t\ta++;\n\t\t\t\t}else{\n\t\t\t\t\tx1 = f2[12] % 5;\n\t\t\t\t\ty1 = f2[12] / 5;\n\t\t\t\t} \n\t\t\t}\n\t\t\tres += abs(x1-x2) + abs(y1-y2);\n\t\t}\n\t\treturn res;\n\t}\n\t// 空白 k (0 or 1) を 方向 dir に動かす.\n\t// 動かせる時は true, 動かせなかったときは false を返す.\n\tbool move(int dir, int k){\n\t\tif( dir < 0 || 4 <= dir || k < 0 || 2 <= k ) return false;\n\t\tint pos1 = search(k);\n\t\tint x = f2[pos1] % 5;\n\t\tint y = f2[pos1] / 5;\n\t\tint mx = x + dx[dir];\n\t\tint my = y + dy[dir];\n\t\tif( mx < 0 || my < 0 || 5 <= mx || 5 <= my ) return false;\n\t\tint pos2 = f1[my*5+mx];\n\t\tif( pos2 == -1 ) return false;\n\t\tif( v[pos1] == v[pos2] ) return false;\n\t\tswap( v[pos1] , v[pos2] );\n\t\treturn true;\n\t}\n\t// 完成しているかどうか\n\tbool is_goal(){\n\t\tfor(int i=0 ; i < 12 ; i++ ){\n\t\t\tif( v[i] != i ) return false;\n\t\t}\n\t\treturn v[12] == 0;\n\t}\n\tvoid debug(){\n\t\tprintf(\"[debug]\\n\");\n\t\tfor(int y=0 ; y < 5 ; y++ ){\n\t\t\tfor(int x=0 ; x < 5 ; x++ ){\n\t\t\t\tif( f1[y*5+x] == -1 ){\n\t\t\t\t\tprintf(\"##\");\n\t\t\t\t}else{\n\t\t\t\t\tprintf(\"%2d\", (int)v[f1[y*5+x]] );\n\t\t\t\t}\n\t\t\t}\n\t\t\tprintf(\"\\n\");\n\t\t}\n\t\tprintf(\"\\n\");\n\t}\n};\n\n// (コスト,スタートからの距離,パズルの状態)\nstruct State{\n\tPazzle p;\n\tint cost, cnt;\n\tState(int cost_, int cnt_, const Pazzle& p_){\n\t\tcost = cost_; cnt = cnt_; p = p_;\n\t}\n};\nbool operator<(const State& a, const State& b){\n\treturn a.cost > b.cost;\n}\n\nint solve(Pazzle p){\n\t// (コスト,スタートからの距離,パズルの状態) を優先度つきキューへ\n\tpriority_queue<State> q;\n\tq.push( State(p.to_g(),0,p) );\n\t\n\tint res = 21;\n\tint foo=0;\n\twhile( !q.empty() ){\n\t\tfoo++;\n\t\tPazzle p = q.top().p; \n\t\tint cost = q.top().cost;\n\t\tint cnt = q.top().cnt;\n\t\tq.pop();\n\t\t\n\t\tif( 10000 < foo ) break;\n\t\tif( res < cnt ) continue;\n\t\t\n\t\tif( p.is_goal() ){\n\t\t\tres = min( res , cnt );\n\t\t\tcontinue;\n\t\t}\n\t\t\n\t\tfor(int k=0 ; k <= 1 ; k++ ){\n\t\t\tfor(int i=0 ; i < 4 ; i++ ){\n\t\t\t\tPazzle p_ = p;\n\t\t\t\tif( p_.move(i,k) ){\n\t\t\t\t\tq.push( State(p_.to_g()+cnt+1,cnt+1,p_) );\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t}\n\treturn res;\n}\n\nint main(){\n\tint p1;\n\twhile( cin >> p1 , p1 != -1 ){\n\t\tPazzle p;\n\t\tp.at(0,p1);\n\t\tfor(int i=1 ; i < 13 ; i++ ){\n\t\t\tcin >> p1;\n\t\t\tp.at(i,p1);\n\t\t}\n\t\tint ans = solve(p);\n\t\tif( ans == 21 ){\n\t\t\tcout << \"NA\" << endl;\n\t\t}else{\n\t\t\tcout << ans << endl;\n\t\t}\n\t}\n}"
  },
  {
    "language": "C++",
    "code": "#include<queue>\n#include<map>\n#include<algorithm>\n#include<iostream>\n#include<string>\n#include<cstdlib>\n#include<cstring>\n#include<cmath>\nusing namespace std;\nint p;\nstring s=\"\";\nqueue<pair<string,int> > q;\nvoid f(int a,int b){\n  char c;\n  c=s[a];\n  s[a]=s[b];\n  s[b]=c;\n  q.push(make_pair(s,p+1));\n  c=s[a];\n  s[a]=s[b];\n  s[b]=c;\n  return;\n}\nvoid g(){\n  if(s[0]==0){\n    f(0,2);\n  }\n  if(s[1]==0){\n    f(1,2);\n    f(1,5);\n  }\n  if(s[2]==0){\n    f(2,0);\n    f(2,1);\n    f(2,3);\n    f(2,6);\n  }\n  if(s[3]==0){\n    f(3,2);\n    f(3,7);\n  }\n  if(s[4]==0){\n    f(4,5);\n  }\n  if(s[5]==0){\n    f(5,1);\n    f(5,4);\n    f(5,6);\n    f(5,9);\n  }\n  if(s[6]==0){\n    f(6,2);\n    f(6,5);\n    f(6,7);\n    f(6,10);\n  }\n  if(s[7]==0){\n    f(7,3);\n    f(7,6);\n    f(7,8);\n    f(7,11);\n  }\n  if(s[8]==0){\n    f(8,7);\n  }\n  if(s[9]==0){\n    f(9,5);\n    f(9,10);\n  }\n  if(s[10]==0){\n    f(10,6);\n    f(10,9);\n    f(10,11);\n    f(10,12);\n  }\n  if(s[11]==0){\n    f(11,7);\n    f(11,10);\n  }\n  if(s[12]==0){\n    f(12,10);\n  }\n  return;\n}\nint main(){\n  int i;\n  int a;\n  int mn;\n  map<string,int> m,n;\n  for(i=0;i<12;i++)\n    s+=i;\n  s+=(char)0;\n  q.push(make_pair(s,1));\n  for(;;){\n    s=q.front().first;\n    p=q.front().second;\n    q.pop();\n    if(p>11)\n      break;\n    if(m[s]==0){\n      m[s]=p;\n      g();\n    }\n  }\n  while(cin>>a&&a!=-1){\n    s=\"\";\n    s+=a;\n    for(i=0;i<12;i++){\n      cin>>a;\n      s+=a;\n    }\n    if(m[s])\n      cout<<m[s]-1<<endl;\n    else{\n      mn=21;\n      while(q.empty()==0)\n\tq.pop();\n      q.push(make_pair(s,1));\n      n.clear();\n      for(;;){\n\ts=q.front().first;\n\tp=q.front().second;\n\tq.pop();\n\tif(p>11)\n\t  break;\n\tif(m[s]&&mn>m[s]+p-2)\n\t  mn=m[s]+p-2;\n\tif(n[s]==0){\n\t  n[s]=p;\n\t  g();\n\t}\n      }\n      if(mn==21)\n\tcout<<\"NA\"<<endl;\n      else\n\tcout<<mn<<endl;\n    }\n  }\n  return 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include<stdio.h>\n#include<map>\n#include<queue>\ntypedef long long L;\ntypedef std::map<L,int>M;\nM m;\nL S(L l,int a,int b)\n{\n\tL c=(l>>(a*4))&15;\n\tl&=~(15LL<<(a*4));\n\tL d=(l>>(b*4))&15;\n\tl&=~(15LL<<(b*4));\n\treturn l|(c<<(b*4))|(d<<(a*4));\n}\n\nstruct I{int operator()(L l,int x)\n{\n\tif(m.find(l)!=m.end())return -2;\n\tm[l]=x;\n\treturn -1;\n}};\nstruct E\n{\n\tM inm;\n\tint operator()(L l,int x)\n\t{\n\t\tM::iterator ite=m.find(l);\n\t\tif(ite!=m.end())return ite->second+x;\n\t\telse if(inm.find(l)!=inm.end())return -2;\n\t\tinm[l]=x;\n\t\treturn -1;\n\t}\n};\ntemplate<class T>\nint F(L init,T func)\n{\n\tconst int di[13][4]={\n\t\t{3},\n\t\t{3,6},\n\t\t{1,2,4,7},\n\t\t{3,8},\n\t\t{6},\n\t\t{2,5,7,10},\n\t\t{3,6,8,11},\n\t\t{4,7,9,12},\n\t\t{8},\n\t\t{6,11},\n\t\t{7,10,12,13},\n\t\t{8,11},\n\t\t{11}};\n\tM::iterator ite;\n\tstd::queue<L>q;\n\tq.push(init);\n\tq.push(-1);\n\tint i,j,k;\n\tfor(int x=0;x<=10;)\n\t{\n\t\tL l=q.front();\n\t\tq.pop();\n\t\tif(l<0)\n\t\t{\n\t\t\tq.push(l);\n\t\t\t++x;\n\t\t\tcontinue;\n\t\t}\n\t\tint res=func(l,x);\n\t\tif(res==-2)\n\t\t\tcontinue;\n\t\tif(res>=0)\n\t\t\treturn res;\n\t\tint a[2];\n\t\tfor(i=j=0;i<13;++i)\n\t\t\tif( !(l&(15LL<<(i*4))) )\n\t\t\t\ta[j++]=i;\n\t\tfor(k=0;k<2;++k)\n\t\t\tfor(i=0;i<4;++i)\n\t\t\t{\n\t\t\t\tint c=di[a[k]][i];\n\t\t\t\tif(c)\n\t\t\t\t{\n\t\t\t\t\tL t=S(l,a[k],c-1);\n\t\t\t\t\tq.push(t);\n\t\t\t\t}\n\t\t\t\telse break;\n\t\t\t}\n\t}\n\treturn -1;\n}\nint main()\n{\n\tF(0xBA9876543210LL,I());\n\tfor(;;)\n\t{\n\t\tL l=0,x;\n\t\tfor(int i=0;i<13;++i)\n\t\t{\n\t\t\tif(scanf(\"%lld\",&x),x<0)return 0;\n\t\t\tl|=(x<<(i*4));\n\t\t}\n\t\tx=F(l,E());\n\t\tx<0?puts(\"NA\"):printf(\"%lld\\n\",x);\n\t}\n}"
  },
  {
    "language": "C++",
    "code": "#include <iostream>\n#include <iomanip>\n#include <vector>\n#include <map>\n#include <set>\n#include <queue>\n#include <cmath>\nusing namespace std;\n\n#define NONE -1\n\n// »ÝÌóÔ\nvector < vector <int> > F( 5, vector <int>(5,NONE) );\n// S[\nvector < vector <int> > GOAL( 5, vector <int>(5,NONE) );\n// KâÏÝ\nset < vector < vector <int> > > V;\n// ó«Ìê\nint empty_x[2];\nint empty_y[2];\nint now;\n\nint getMD()\n{\n\tint md = 0;\n\tfor ( int i = 0; i < 5; i++ ) for ( int j = 0; j < 5; j++ )\n\t{\n\t\tif ( F[i][j] != GOAL[i][j] )\n\t\t{\n\t\t\t// T·\n\t\t\tbool found = false;\n\t\t\tfor ( int k = 0; k < 5; k++ )\n\t\t\t{\n\t\t\t\tfor ( int m = 0; m < 5; m++ )\n\t\t\t\t{\n\t\t\t\t\t//  Á½\n\t\t\t\t\tif ( F[i][j] == GOAL[k][m] )\n\t\t\t\t\t{\n\t\t\t\t\t\tmd += abs(k-i) + abs(m-j);\n\t\t\t\t\t\tfound = true;\n\t\t\t\t\t\tbreak;\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t\tif ( found ) break;\n\t\t\t}\n\t\t}\n\t}\n\treturn md;\n}\n\nbool search( int depth )\n{\n\tif ( F == GOAL )\n\t\treturn true;\n\tif ( now + getMD() > depth )\n\t\treturn false;\n\n\tnow++;\n\tfor ( int e = 0; e < 2; e++ ) for ( int i = -1; i < 2; i++ ) for ( int j = -1; j < 2; j++ )\n\t{\n\t\tif ( i+j == 1 || i+j == -1 )\n\t\t{\n\t\t\tint ox = empty_x[e];\n\t\t\tint oy = empty_y[e];\n\t\t\tint tx = empty_x[e] + i;\n\t\t\tint ty = empty_y[e] + j;\n\n\t\t\tif ( ( tx >= 0 && tx <= 4 ) && ( ty >= 0 && ty <= 4 ) )\n\t\t\t{\n\t\t\t\tif ( F[ty][tx] != 0 && F[ty][tx] != NONE )\n\t\t\t\t{\n\t\t\t\t\t// ®©·\n\t\t\t\t\tswap( F[oy][ox], F[ty][tx] );\n\n\t\t\t\t\t// ¢JÌnÅ éÈçÎ\n\t\t\t\t\tif ( V.find( F ) == V.end() )\n\t\t\t\t\t{\n\t\t\t\t\t\tif ( search( depth ) )\n\t\t\t\t\t\t\treturn true;\n\t\t\t\t\t}\n\n\t\t\t\t\t// ß·\n\t\t\t\t\tswap( F[oy][ox], F[ty][tx] );\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t}\n\tnow--;\n\n}\n\nint main( void )\n{\n\twhile ( 1 )\n\t{\n\t\t// S[ðìé\n\t\tGOAL[0][2] = 0;\n\t\tfor ( int i = 0; i < 3; i++ )\n\t\t\tGOAL[1][1+i] = i+1;\n\t\tfor ( int i = 0; i < 5; i++ )\n\t\t\tGOAL[2][i] = 4 + i;\n\t\tfor ( int i = 0; i < 3; i++ )\n\t\t\tGOAL[3][1+i] = 9 + i;\n\t\tGOAL[4][2] = 0;\n\n\t\t// üÍ\n\t\tcin >> F[0][2];\n\t\tif ( F[0][2] == -1 )\n\t\t\tbreak;\n\t\tfor ( int i = 0; i < 3; i++ )\n\t\t\tcin >> F[1][1+i];\n\t\tfor ( int i = 0; i < 5; i++ )\n\t\t\tcin >> F[2][i];\n\t\tfor ( int i = 0; i < 3; i++ )\n\t\t\tcin >> F[3][1+i];\n\t\tcin >> F[4][2];\n\n\t\t// óðT·\n\t\tint empty_count = 0;\n\t\tfor ( int i = 0; i < 5; i++ )\n\t\t{\n\t\t\tfor ( int j = 0; j < 5; j++ )\n\t\t\t{\n\t\t\t\tif ( F[i][j] == 0 )\n\t\t\t\t{\n\t\t\t\t\tempty_x[empty_count] = j;\n\t\t\t\t\tempty_y[empty_count] = i;\n\t\t\t\t\tempty_count++;\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\n\t\t// ½[»[³DæTõ\n\t\tV.insert( F );\n\t\tnow = 0;\n\t\tbool goal_flag = false;\n\t\tfor ( int i = 0; i < 20; i++ )\n\t\t{\n\t\t\tif ( search( i ) )\n\t\t\t{\n\t\t\t\tgoal_flag = true;\n\t\t\t\tbreak;\n\t\t\t}\n\t\t}\n\n\t\tif ( goal_flag )\n\t\t\tcout << now << endl;\n\t\telse\n\t\t\tcout << \"NA\" << endl;\n\n\t}\n\treturn 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include <cstdio>\n#include <cstring>\n#include <algorithm>\n\nusing namespace std;\n\nint fie[5][5];\nint o_fie[5][5]={\n\t-1,-1,0,-1,-1,\n\t-1,1,2,3,-1,\n\t4,5,6,7,8,\n\t-1,9,10,11,-1\n\t-1,-1,0,-1,-1,\n};\n\nint ox[12],oy[12],zx[2],zy[2],zcnt;\nint res;\nbool flag;\n\nint dx[4]={1,0,-1,0};\nint dy[4]={0,1,0,-1};\n\nvoid dfs(int v,int dist,int pd,int pu){\n\tif(flag)return;\n\tif(dist==0){\n\t\tflag=true;\n\t\treturn;\n\t}\n\tfor(int i=0;i<4;i++){\n\t\tfor(int j=0;j<2;j++){\n\t\t\tif(pu==j && (pd+2)%4==i)continue;\n\t\t\tint nx=zx[j]+dx[i],ny=zy[j]+dy[i];\n\t\t\tif(nx>=0 && nx<5 && ny>=0 && ny<5){\n\t\t\t\tif(fie[nx][ny]<=0)continue;\n\t\t\t\tint ch=fie[nx][ny];\n\t\t\t\tint ndist=dist;\n\t\t\t\tndist-=abs(ox[ch]-nx)+abs(oy[ch]-ny);\n\t\t\t\tswap(fie[nx][ny],fie[zx[j]][zy[j]]);\n\t\t\t\tndist+=abs(ox[ch]-zx[j])+abs(oy[ch]-zy[j]);\n\t\t\t\tzx[j]+=dx[i];\n\t\t\t\tzy[j]+=dy[i];\n\t\t\t\tif(v+1+ndist<=res)dfs(v+1,ndist,i,j);\n\t\t\t\tswap(fie[nx][ny],fie[zx[j]][zy[j]]);\n\t\t\t\tzx[j]-=dx[i];\n\t\t\t\tzy[j]-=dy[i];\n\t\t\t}\n\t\t}\n\t}\n}\nint dist;\n\nint main(void){\n\tfor(int i=0;i<5;i++){\n\t\tfor(int j=abs(2-i);j<=4-abs(2-i);j++){\n\t\t\tox[o_fie[i][j]]=j;\n\t\t\toy[o_fie[i][j]]=i;\n\t\t}\n\t}\n\twhile(1){\n\t\tmemset(fie,-1,sizeof(fie));\n\t\tdist=0;\n\t\tzcnt=0;\n\t\tfor(int i=0;i<5;i++){\n\t\t\tfor(int j=abs(2-i);j<=4-abs(2-i);j++){\n\t\t\t\tscanf(\"%d\",&fie[j][i]);\n\t\t\t\tif(fie[j][i]==-1)return 0;\n\t\t\t}\n\t\t}\n\t\tfor(int i=0;i<5;i++){\n\t\t\tfor(int j=abs(2-i);j<=4-abs(2-i);j++){\n\t\t\t\tint v=fie[j][i];\n\t\t\t\tif(v==0){\n\t\t\t\t\tzx[zcnt]=j;\n\t\t\t\t\tzy[zcnt++]=i;\n\t\t\t\t}else dist+=abs(ox[v]-j)+abs(oy[v]-i);\n\t\t\t}\n\t\t}\n\t\tif(dist>20){\n\t\t\tprintf(\"NA\\n\");\n\t\t}else{\n\t\t\tint i=0;\n\t\t\tflag=false;\n\t\t\twhile(i+dist<=20){\n\t\t\t\tres=i+dist;\n\t\t\t\tdfs(0,dist,-1,-1);\n\t\t\t\tif(flag){\n\t\t\t\t\tprintf(\"%d\\n\",i+dist);\n\t\t\t\t\tbreak;\n\t\t\t\t}\n\t\t\t}\n\t\t\tif(!flag)printf(\"NA\\n\");\n\t\t}\n\t}\n\treturn 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include <cstdio>\n#include <cstring>\n#include <algorithm>\n#include <string>\n#include <cmath>\n#include <stack>\n#include <vector>\n#include <map>\n#include <set>\n#include <queue>\n#include <list>\n#include <iostream>\n#include <sstream>\n#include <climits>\n#include <cfloat>\n#include <complex>\n\nusing namespace std;\n\ntypedef long long ll;\n\nll encode(int* state)\n{\n\tll res = 0;\n\tfor (int i = 0; i < 13; ++i)\n\t\tres = res << 4 | state[i];\n\treturn res;\n}\nvoid decode(int* d, ll e)\n{\n\tfor (int i = 12; i >= 0; --i, e >>= 4)\n\t\td[i] = e & 15;\n}\n\nmap<ll, int> minSteps;\nint dir[] = { -1, 1, -2, 2, -4, 4 };\nmap<int, bool> ok[3];\n\nconst int InitialDepth = 13;\nmap<ll, int> problemSteps;\n\nint start_from_initial(ll current, ll next)\n{\n\tbool newState = minSteps.count(next) == 0;\n\tif (newState)\n\t\tminSteps[next] = minSteps[current] + 1;\n\n\treturn newState && minSteps[next] < InitialDepth ? 0 : -1;\n}\nint start_from_problem(ll current, ll next)\n{\n\tbool newState = problemSteps.count(next) == 0;\n\tif (newState)\n\t\tproblemSteps[next] = problemSteps[current] + 1;\n\n\tif (minSteps.count(next))\n\t\treturn problemSteps[next] + minSteps[next];\n\n\treturn newState && problemSteps[next] < 20 - InitialDepth ? 0 : -1;\n}\nint bfs(ll initial, int (*f)(ll, ll))\n{\n\tqueue<ll> q;\n\tq.push(initial);\n\n\twhile (!q.empty())\n\t{\n\t\tll e = q.front();\n\t\tq.pop();\n\t\tint d[13];\n\t\tdecode(d, e);\n\n\t\tint zero_pos[2];\n\t\tfor (int i = 0, j = 0; j < 2; ++i)\n\t\t\tif (!d[i])\n\t\t\t\tzero_pos[j++] = i;\n\n\t\tfor (int i = 0; i < 2; ++i)\n\t\t{\n\t\t\tfor (int j = 0; j < 6; ++j)\n\t\t\t{\n\t\t\t\tint a = zero_pos[i];\n\t\t\t\tint b = a + dir[j];\n\t\t\t\tif (a > b)\n\t\t\t\t\tswap(a, b);\n\t\t\t\tif (a < 0 || b > 12 || !d[a] && !d[b] || !ok[j/2][a])\n\t\t\t\t\tcontinue;\n\n\t\t\t\tint copy[13];\n\t\t\t\tmemcpy(copy, d, sizeof(copy));\n\t\t\t\tswap(copy[a], copy[b]);\n\t\t\t\tll next = encode(copy);\n\n\t\t\t\tint r = f(e, next);\n\t\t\t\tif (r == 0)\n\t\t\t\t\tq.push(next);\n\t\t\t\telse if (r > 0)\n\t\t\t\t\treturn r;\n\t\t\t}\n\t\t}\n\t}\n\n\treturn -1;\n}\n\nint main()\n{\n\tint o[][9] = {\n\t\t{ 1, 2, 4, 5, 6, 7, 9, 10, -1 },\n\t\t{ 0, 10, -1 },\n\t\t{ 1, 2, 3, 5, 6, 7, -1 }\n\t};\n\tfor (int i = 0; i < 3; ++i)\n\t\tfor (int j = 0; o[i][j] != -1; ++j)\n\t\t\tok[i][o[i][j]] = true;\n\n\tint initial[] = { 0, 1, 2, 3, 4, 5, 6, 7, 8, 9, 10, 11, 0 };\n\tll t = encode(initial);\n\tminSteps[t] = 0;\n\n\tbfs(t, start_from_initial);\n\n\twhile (true)\n\t{\n\t\tint d[13];\n\t\tfor (int i = 0; i < 13; ++i)\n\t\t\tscanf(\"%d\", d + i);\n\t\tif (d[0] == -1)\n\t\t\tbreak;\n\n\t\tint ans = -1;\n\t\tll s = encode(d);\n\t\tif (minSteps.count(s))\n\t\t\tans = minSteps[s];\n\t\telse\n\t\t{\n\t\t\tproblemSteps.clear();\n\t\t\tans = bfs(s, start_from_problem);\n\t\t}\n\n\t\tif (ans != -1)\n\t\t\tprintf(\"%d\\n\", ans);\n\t\telse\n\t\t\tputs(\"NA\");\n\t}\n\n\treturn 0;\n}"
  },
  {
    "language": "C++",
    "code": "//35\n#include<iostream>\n#include<vector>\n#include<set>\n#include<algorithm>\n#include<queue>\n\nusing namespace std;\n\nstruct S{\n  vector<int> v;\n  int t;\n};\n\nint main(){\n  for(;;){\n    vector<int> v(13);\n    cin>>v[2]>>v[1]>>v[4]>>v[7]>>v[0]>>v[3]>>v[6]>>v[9]>>v[12]>>v[5]>>v[8]>>v[11]>>v[10];\n    if(v[2]==-1)return 0;\n    queue<S> que;\n    S is={v,0};\n    que.push(is);\n    set<vector<int> > p;\n    while(!que.empty()&&que.front().t<=20){\n      S  c=que.front();\n      int g[]={4,1,0,5,2,9,6,3,10,7,0,11,8};\n      if(c.v==vector<int>(g,g+13))break;\n      que.pop();\n      if(p.count(c.v))continue;\n      p.insert(c.v);\n      for(int i=0;i<15;i++){\n\tif(v[i]==0){\n\t  for(int j=0;j<4;j++){\n\t    int d[]={-2,3,2,-3};\n\t    int b[][5]={{0,1,2,7,12},{2,7,12,11,10},{12,11,10,5,0},{10,5,0,1,2}};\n\t    int k;\n\t    for(k=0;k<5;k++){\n\t      if(i==b[j][k])break;\n\t    }\n\t    if(k==5){\n\t      vector<int> n=c.v;\n\t      swap(n[i],n[i+d[j]]);\n\t      S ns={n,c.t+1};\n\t      que.push(ns);\n\t    }\n\t  }\n\t}\n      }\n    }\n    if(que.empty()||que.front().t>20){\n      cout<<\"NA\"<<endl;\n    }else{\n      cout<<que.front().t<<endl;\n    }\n  }\n  return 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include <cstdio>\n#include <cstdlib>\n#include <cmath>\n#include <climits>\n#include <cfloat>\n#include <map>\n#include <utility>\n#include <set>\n#include <iostream>\n#include <memory>\n#include <string>\n#include <vector>\n#include <algorithm>\n#include <functional>\n#include <sstream>\n#include <complex>\n#include <stack>\n#include <queue>\n#include <cstring>\n#include <sstream>\n#include <cassert>\n#include <list>\nusing namespace std;\nstatic const double EPS = 1e-10;\ntypedef long long ll;\ntypedef pair<int,int> PI;\ntypedef vector<int> vi;\n#ifndef M_PI\n#define M_PI 3.14159265358979323846\n#endif\n#define rep(i,n) for(int i=0;i<(int)n;++i)\n#define FOR(i,c) for(__typeof((c).begin())i=(c).begin();i!=(c).end();++i)\n#define ALL(c) (c).begin(), (c).end()\n#define mp(a,b) make_pair(a,b)\n#define pb(a) push_back(a)\n#define F first\n#define S second\ntemplate <typename T> string print_array(const vector<T> &V) { ostringstream os; os << \"{ \"; for (typename vector<T>::const_iterator iter = V.begin(); iter != V.end(); ++iter) os << '\\\"' << *iter << \"\\\",\"; os << \" }\"; return os.str(); }\n\nint dx[]={0,1,0,-1},dy[]={1,0,-1,0};\n\nvector<int> se[13];\nint x[]={0,-1,0,1,-2,-1,0,1,2,-1,0,1,0};\nint y[]={2,1,1,1,0,0,0,0,0,-1,-1,-1,-2};\n\nvoid pr(ll in){\n\n  printf(\"      %3lld\\n\",in&15);\n  printf(\"   %3lld%3lld%3lld\\n\",(in>>4)&15,(in>>8)&15,(in>>12)&15);\n  printf(\"%3lld%3lld%3lld%3lld%3lld\\n\",(in>>16)&15,(in>>20)&15,(in>>24)&15,(in>>28)&15,(in>>32)&15);\n  printf(\"   %3lld%3lld%3lld\\n\",(in>>36)&15,(in>>40)&15,(in>>44)&15);\n  printf(\"      %3lld\\n\",(in>>48)&15);\n  puts(\"\");\n}\n\nint manh(ll in){\n  int ret=0;\n  rep(i,13){\n    int t=(in>>(i*4))&15;\n\n    if(!t)continue;\n    int nx=(x[t]-x[i]),ny=y[t]-y[i];\n    ret+=abs(nx)+abs(ny);\n  }\n  return ret;\n}\n\nmain(){\n  ll p;\n\n  ll goal=0;\n  rep(i,11){\n    goal|=(i+1LL)<<(4*(i+1));\n    //cout<<goal<<endl;\n    //pr(goal);\n  }\n  //pr(goal);\n\n  se[0].pb(2);\n  se[1].pb(2);\n  se[1].pb(5);\n  se[2].pb(0);\n  se[2].pb(1);\n  se[2].pb(3);\n  se[2].pb(6);\n  se[3].pb(2);\n  se[3].pb(7);\n  se[4].pb(5);\n  se[5].pb(1);\n  se[5].pb(4);\n  se[5].pb(6);\n  se[5].pb(9);\n  se[6].pb(2);\n  se[6].pb(5);\n  se[6].pb(7);\n  se[6].pb(10);\n  se[7].pb(3);\n  se[7].pb(6);\n  se[7].pb(8);\n  se[7].pb(11);\n  se[8].pb(7);\n  se[9].pb(5);\n  se[9].pb(10);\n  se[10].pb(6);\n  se[10].pb(9);\n  se[10].pb(11);\n  se[10].pb(12);\n  se[11].pb(7);\n  se[11].pb(10);\n  se[12].pb(10);\n  \n  while(cin>>p){\n    if(p==-1)break;\n    ll in=p;\n\n    rep(i,12){\n      cin>>p;\n      in|=p<<(4*(i+1));\n    }\n\n    set<ll> app;\n\n    queue<pair<int,ll> > Q;\n    app.insert(in);\n    Q.push(mp(0,in));\n    int ans=21;\n    int mans=0;\n\n    while(!Q.empty()){\n      ll cvec=Q.front().S;\n      int ccost=Q.front().F;\n      Q.pop();\n    \n      //pr(cvec);\n\n      //if(ccost>3)break;\n      if(ccost+manh(cvec)>28)continue;\n      if(cvec==goal){\n\tans=ccost;\n\tbreak;\n      }\n      rep(i,13){\n\tll t=cvec>>(i<<2);\n\tt=t&15;\n\tif(!t){\n\t  rep(j,se[i].size()){\n\t    t=cvec>>(se[i][j]<<2);\n\t    t=t&15;\n\t    if(t){\n\t      ll nvec=cvec;\n\t      t=t<<(i<<2);\n\t      nvec|=t;\n\t      nvec&=~(15LL<<se[i][j]*4);\n\t      \n\t      if(!app.count(nvec)){\n\t\tapp.insert(nvec);\n\t\tQ.push(mp(ccost+1,nvec));\n\t      }\n\t    }\n\t  }\n\t}\n      }\n    }\n    if(ans==21)cout<<\"NA\"<<endl;\n    else cout<<ans<<endl;\n  }\n}"
  },
  {
    "language": "C++",
    "code": "#include <iostream>\n#include <map>\n#include <queue>\n#include <cstdlib>\n#include <vector>\nusing namespace std;\n#define rep(i,n) for(int i=0;i<n;i++)\n\nint to[13][5] = {\n\t{2,-1},\n\t{2,5,-1},\n\t{0,1,3,6,-1},\n\t{2,7,-1},\n\t{5,-1},\n\t{1,4,6,9,-1},\n\t{2,5,7,10,-1},\n\t{3,6,8,11,-1},\n\t{7,-1},\n\t{5,10,-1},\n\t{6,9,11,12},\n\t{7,10,-1},\n\t{10,-1}\n};\nint X[]={2,1,2,3,0,1,2,3,4,1,2,3,2};\nint Y[]={0,1,1,1,2,2,2,2,2,3,3,3,4};\n\nint solve(vector<int> data){\n\tqueue< vector<int> > Q;\n\tmap<vector<int>,int> done;\n\tQ.push(data);\n\tdone[Q.front()] = 0;\n\t\n\twhile(Q.size()){\n\t\tvector<int> q = Q.front(); Q.pop();\n\t\tint dif = 0;\n\t\trep(i,13)if(q[i])dif += abs(X[q[i]]-X[i])+abs(Y[q[i]]-Y[i]);\n\t\tif(dif==0)return done[q];;\n\t\tif(dif/2+done[q]>=20)continue;\n\t\tint curcost = done[q];\n\t\trep(x,13){\n\t\t\tif(q[x] == 0){\n\t\t\t\trep(i,5){\n\t\t\t\t\tif(!~to[x][i])break;\n\t\t\t\t\tswap(q[x],q[to[x][i]]);\n\t\t\t\t\tif(done.find(q) == done.end() ){\n\t\t\t\t\t\tdone[q] = curcost+1;\n\t\t\t\t\t\tQ.push(q);\n\t\t\t\t\t}\n\t\t\t\t\tswap(q[x],q[to[x][i]]);\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t}\n\treturn 21;\n}\nint main(){\n\tvector<int> data(13);\n\twhile(1){\n\t\trep(i,13)if(!(cin >> data[i]))return 0;\n\t\tint ans = solve(data);\n\t\tif(ans > 20)cout << \"NA\" << endl;\n\t\telse cout << ans << endl;\n\t}\n}"
  },
  {
    "language": "C++",
    "code": "#include<bits/stdc++.h>\n#define int long long\n#define r(i,n) for(int i=0;i<n;i++)\nusing namespace std;\ntypedef pair<int,int>P;\nvector<int>v[13],s(13),t(13);\nmap<int,int>m;\n\nint has[14];\n\n\nvoid init(){\n\n    v[0].push_back(2);\n\n    v[1].push_back(2);\n    v[1].push_back(5);\n\n    v[2].push_back(0);\n    v[2].push_back(1);\n    v[2].push_back(3);\n    v[2].push_back(6);\n\n    v[3].push_back(2);\n    v[3].push_back(7);\n\n    v[4].push_back(5);\n\n    v[5].push_back(1);\n    v[5].push_back(4);\n    v[5].push_back(6);\n    v[5].push_back(9);\n\n    v[6].push_back(2);\n    v[6].push_back(5);\n    v[6].push_back(7);\n    v[6].push_back(10);\n\n    v[7].push_back(3);\n    v[7].push_back(6);\n    v[7].push_back(8);\n    v[7].push_back(11);\n\n    v[8].push_back(7);\n\n    v[9].push_back(5);\n    v[9].push_back(10);\n\n    v[10].push_back(6);\n    v[10].push_back(9);\n    v[10].push_back(11);\n    v[10].push_back(12);\n\n    v[11].push_back(7);\n    v[11].push_back(10);\n\n    v[12].push_back(10);\n\n    int a=20;\n    int p=1;\n\n    r(i,13){\n        has[i]=p;\n        p*=a;\n    }\n}\n\nint ha(vector<int> &x){\n\n    int re=0;\n\n    r(i,13){\n        re+=x[i]*has[i];\n    }\n\n    return re;\n}\n\nvector<int> ah(int x){\n    vector<int>y(13);\n    r(i,13){\n        y[i]=x%20;\n        x/=20;\n    }\n    return y;\n}\n\nvoid BFS1(){\n    s[0]=0;\n    s[12]=0;\n    r(i,11)s[i+1]=i+1;\n    set<int>st;\n    st.insert(ha(s));\n    m[ha(s)]=0;\n    queue<P>q;\n    q.push(P(ha(s),0));\n    while(1){\n        vector<int> now=ah(q.front().first);\n        int cost=q.front().second;\n        q.pop();\n        if(cost==7)break;\n        //cout<<m.size()<<' '<<cost<<endl;\n        r(i,13)if(now[i]!=0){\n            r(j,v[i].size()){\n                swap(now[i],now[v[i][j]]);\n                int yy=ha(now);\n                if(!st.count(yy)){\n                    st.insert(yy);\n                    m[yy]=cost+1;\n                    q.push(P(yy,cost+1));\n                }\n                swap(now[i],now[v[i][j]]);\n            }\n        }\n    }\n}\n\nvoid BFS2(){\n    set<int>st;\n    st.insert(ha(t));\n    queue<P>q;\n    q.push(P(ha(t),0));\n    while(1){\n        vector<int>now=ah(q.front().first);\n        int cost=q.front().second;\n        int y=ha(now);\n        if(m.count(y)){\n            cout<<m[y]+cost<<endl;\n            return ;\n        }\n        q.pop();\n        if(cost==6)break;\n        r(i,13)if(now[i]!=0){\n            r(j,v[i].size()){\n                swap(now[i],now[v[i][j]]);\n                int yy=ha(now);\n                if(!st.count(yy)){\n                    st.insert(yy);\n                    q.push(P(yy,cost+1));\n                }\n                swap(now[i],now[v[i][j]]);\n            }\n        }\n    }\n    cout<<\"NA\"<<endl;\n}\n\n\nsigned main(){\n    init();\n    BFS1();\n    while(cin>>t[0],t[0]!=-1){\n        r(i,12)cin>>t[i+1];\n        BFS2();\n    }\n}\n"
  },
  {
    "language": "C++",
    "code": "#include <cstdio>\n#include <cstdlib>\n#include <cmath>\n#include <climits>\n#include <cfloat>\n#include <map>\n#include <utility>\n#include <set>\n#include <iostream>\n#include <memory>\n#include <string>\n#include <vector>\n#include <algorithm>\n#include <functional>\n#include <sstream>\n#include <complex>\n#include <stack>\n#include <queue>\n#include <cstring>\n#include <sstream>\n#include <cassert>\n#include <list>\nusing namespace std;\nstatic const double EPS = 1e-10;\ntypedef long long ll;\ntypedef pair<int,int> PI;\ntypedef vector<int> vi;\n#ifndef M_PI\n#define M_PI 3.14159265358979323846\n#endif\n#define rep(i,n) for(int i=0;i<(int)n;++i)\n#define FOR(i,c) for(__typeof((c).begin())i=(c).begin();i!=(c).end();++i)\n#define ALL(c) (c).begin(), (c).end()\n#define mp(a,b) make_pair(a,b)\n#define pb(a) push_back(a)\n#define F first\n#define S second\ntemplate <typename T> string print_array(const vector<T> &V) { ostringstream os; os << \"{ \"; for (typename vector<T>::const_iterator iter = V.begin(); iter != V.end(); ++iter) os << '\\\"' << *iter << \"\\\",\"; os << \" }\"; return os.str(); }\n\nint dx[]={0,1,0,-1},dy[]={1,0,-1,0};\n\nvector<int> se[13];\nint x[]={0,-1,0,1,-2,-1,0,1,2,-1,0,1,0};\nint y[]={2,1,1,1,0,0,0,0,0,-1,-1,-1,-2};\n\nvoid pr(ll in){\n\n  printf(\"      %3lld\\n\",in&15);\n  printf(\"   %3lld%3lld%3lld\\n\",(in>>4)&15,(in>>8)&15,(in>>12)&15);\n  printf(\"%3lld%3lld%3lld%3lld%3lld\\n\",(in>>16)&15,(in>>20)&15,(in>>24)&15,(in>>28)&15,(in>>32)&15);\n  printf(\"   %3lld%3lld%3lld\\n\",(in>>36)&15,(in>>40)&15,(in>>44)&15);\n  printf(\"      %3lld\\n\",(in>>48)&15);\n  puts(\"\");\n}\n\nint manh(ll in){\n  int ret=0;\n  rep(i,13){\n    int t=(in>>(i*4))&15;\n\n    if(!t)continue;\n    int nx=(x[t]-x[i]),ny=y[t]-y[i];\n    ret+=abs(nx)+abs(ny);\n  }\n  return ret;\n}\n\nmain(){\n  ll p;\n\n  ll goal=0;\n  rep(i,11){\n    goal|=(i+1LL)<<(4*(i+1));\n    //cout<<goal<<endl;\n    //pr(goal);\n  }\n  //pr(goal);\n\n  se[0].pb(2);\n  se[1].pb(2);\n  se[1].pb(5);\n  se[2].pb(0);\n  se[2].pb(1);\n  se[2].pb(3);\n  se[2].pb(6);\n  se[3].pb(2);\n  se[3].pb(7);\n  se[4].pb(5);\n  se[5].pb(1);\n  se[5].pb(4);\n  se[5].pb(6);\n  se[5].pb(9);\n  se[6].pb(2);\n  se[6].pb(5);\n  se[6].pb(7);\n  se[6].pb(10);\n  se[7].pb(3);\n  se[7].pb(6);\n  se[7].pb(8);\n  se[7].pb(11);\n  se[8].pb(7);\n  se[9].pb(5);\n  se[9].pb(10);\n  se[10].pb(6);\n  se[10].pb(9);\n  se[10].pb(11);\n  se[10].pb(12);\n  se[11].pb(7);\n  se[11].pb(10);\n  se[12].pb(10);\n  \n  while(cin>>p){\n    if(p==-1)break;\n    ll in=p;\n\n    rep(i,12){\n      cin>>p;\n      in|=p<<(4*(i+1));\n    }\n\n    set<ll> app;\n\n    queue<pair<int,ll> > Q;\n    app.insert(in);\n    Q.push(mp(0,in));\n    int ans=21;\n    int mans=0;\n\n    while(!Q.empty()){\n      ll cvec=Q.front().S;\n      int ccost=Q.front().F;\n      Q.pop();\n    \n      //pr(cvec);\n\n      //if(ccost>3)break;\n      if(ccost+manh(cvec)>29)continue;\n      if(cvec==goal){\n\tans=ccost;\n\tbreak;\n      }\n      rep(i,13){\n\tll t=cvec>>(i<<2);\n\tt=t&15;\n\tif(!t){\n\t  rep(j,se[i].size()){\n\t    t=cvec>>(se[i][j]<<2);\n\t    t=t&15;\n\t    if(t){\n\t      ll nvec=cvec;\n\t      t=t<<(i<<2);\n\t      nvec|=t;\n\t      nvec&=~(15LL<<se[i][j]*4);\n\t      \n\t      if(!app.count(nvec)){\n\t\tapp.insert(nvec);\n\t\tQ.push(mp(ccost+1,nvec));\n\t      }\n\t    }\n\t  }\n\t}\n      }\n    }\n    if(ans==21)cout<<\"NA\"<<endl;\n    else cout<<ans<<endl;\n  }\n}"
  },
  {
    "language": "C++",
    "code": "#import<iostream>\n#import<map>\n#import<queue>\n#import<cstdlib>\n#import<cstring>\nusing namespace std;struct B{int z[2];char s[14];bool operator<(const B&r)const{return strcmp(s,r.s)<0;}};main(){int a[13][5]={{2,-1},{2,5,-1},{0,1,3,6,-1},{2,7,-1},{5,-1},{1,4,6,9,-1},{2,5,7,10,-1},{3,6,8,11,-1},{7,-1},{5,10,-1},{6,9,11,12,-1},{7,10,-1},{10,-1}},X[]={2,1,2,3,0,1,2,3,4,1,2,3,2},Y[]={0,1,1,1,2,2,2,2,2,3,3,3,4},v,d,s,i,j,t,u;B g={0,0,\"0123456789:;0\"};for(;;){map<B,int>m;queue<B>q;B b={i=-1,-1};for(;++i<13;!v?b.z[*b.z>=0]=i:0){cin>>v;if(v<0)return 0;b.s[i]=48+v;}b.s[13]=0;m[b]=1;for(q.push(b);!q.empty();q.pop()){B&b=q.front();if(!strcmp(b.s,g.s))break;d=0;for(i=13;i--;v?d+=abs(X[v]-X[i])+abs(Y[v]-Y[i]):0)v=b.s[i]-48;s=m[b];if(s+d<22)for(j=0;j<2;j++)for(i=0;~a[u=b.z[j]][i];i++){B n=b;t=n.z[j]=a[u][i];if(t-n.z[1-j]){swap(n.s[u],n.s[t]);int&r=m[n];if(!r)r=s+1,q.push(n);}}}printf(m[g]?\"%d\\n\":\"NA\\n\",m[g]-1);}}"
  },
  {
    "language": "C++",
    "code": "#include <iostream>\n#include <cstdio>\n#include <queue>\n#include <set>\n#include <map>\n#include <cmath>\nusing namespace std;\ntypedef unsigned long long ull;\null B = 1000000003ull;\nint a[5]={2,1,0,1,2};\nint b[5]={2,3,4,3,2};\nint dx[5]={0,1,0,-1};\nint dy[5]={1,0,-1,0};\nint px[13]={0,1,1,1,2,2,2,2,2,3,3,3,0};\nint py[13]={0,1,2,3,0,1,2,3,4,1,2,3,0};\n \nstruct State\n{\n    int f[5][5];\n    int t;\n};\null hash(State x)\n{\n    ull t = 1ull;\n    ull res = 0;\n    for(int i=0;i<5;i++)\n    {\n        for(int j=a[i];j<=b[i];j++)\n        {\n            res += x.f[i][j]*t;\n            t *= B;\n        }\n    }\n    return res;\n}\nmap<ull,int> mp;\nset<ull> used;\nbool check(State x)\n{\n    int cnt=1;\n    for(int i=1;i<=3;i++)\n    {\n        for(int j=a[i];j<=b[i];j++)\n        {\n            if(x.f[i][j]!=cnt)return false;\n            cnt++;\n        }\n    }\n    return true;\n}\nbool cc(State x)\n{\n    int res = 0;\n    for(int i=0;i<5;i++)\n    {\n        for(int j=a[i];j<=b[i];j++)\n        {\n            if(x.f[i][j])\n            {\n                int k = x.f[i][j];\n                res += (abs(px[k]-i)+abs(py[k]-j));\n            }\n        }\n    }\n    return (res>20-x.t);\n}\nint ans = 21;\nvoid bfs(State st)\n{\n    queue<State> q;\n    mp[hash(st)]=0;\n    q.push(st);\n    while(!q.empty())\n    {\n        State A = q.front();\n        q.pop();\n        //cout << \"koko\" << endl;\n        for(int i=0;i<5;i++)\n        {\n            for(int j=0;j<5;j++)\n            {\n                if(j<a[i]||b[i]<j)continue;\n                if(A.f[i][j]==0)continue;\n                for(int k=0;k<4;k++)\n                {\n                    int nx=i+dx[k],ny=j+dy[k];\n                    if(nx<0||nx>=5||ny<0||ny>=5)continue;\n                    if(ny<a[nx]||b[nx]<ny)continue;\n                    if(A.f[nx][ny]!=0)continue;\n                    State B = A;\n                    swap(B.f[nx][ny],B.f[i][j]);\n                    B.t++;\n                    //cout << \"a\" << endl;\n                    if(B.t>8)continue;\n                    ull hb = hash(B);\n                    if(mp.find(hb)!=mp.end())continue;\n                    //cout << hb << endl;\n                    mp[hb]=B.t;\n                    q.push(B);\n                }\n            }\n        }\n    }\n    //cout << \"owari\" << endl;\n}\nvoid bfs2(State st)\n{\n    queue<State> q;\n    if(check(st)){ans=0;return;}\n    q.push(st);\n    while(!q.empty())\n    {\n        State A = q.front();\n        q.pop();\n        ull ha=hash(A); \n        if(mp.find(hash(A))!=mp.end()){ans = min(ans,A.t+mp[ha]);continue;}\n        for(int i=0;i<5;i++)\n        {\n            for(int j=0;j<5;j++)\n            {\n                if(j<a[i]||b[i]<j)continue;\n                if(A.f[i][j]==0)continue;\n                for(int k=0;k<4;k++)\n                {\n                    int nx=i+dx[k],ny=j+dy[k];\n                    if(nx<0||nx>=5||ny<0||ny>=5)continue;\n                    if(ny<a[nx]||b[nx]<ny)continue;\n                    if(A.f[nx][ny]!=0)continue;\n                    State B = A;\n                    swap(B.f[nx][ny],B.f[i][j]);\n                    B.t++;\n                    if(cc(B))continue;\n                    ull hb = hash(B);\n                    if(used.find(hb)!=used.end())continue;\n                    used.insert(hb);\n                    q.push(B);\n                }\n            }\n        }\n    }\n}\nint main()\n{\n    State end;\n    int cnt=1;\n    end.t=0;\n    for(int i=0;i<5;i++)for(int j=0;j<5;j++)end.f[i][j]=-1;\n    end.f[0][2]=0;\n    end.f[4][2]=0;\n    for(int i=1;i<=3;i++)for(int j=a[i];j<=b[i];j++)end.f[i][j]=cnt++;\n    /*for(int i=0;i<5;i++)\n    {\n        for(int j=a[i];j<=b[i];j++)cout << end.f[i][j] << ' ';\n        cout << endl;\n    }*/\n    bfs(end);\n    while(1)\n    {\n        State st;\n        used.clear();\n        ans = 21;\n        for(int i=0;i<5;i++)for(int j=0;j<5;j++)st.f[i][j]=-1;\n        for(int i=0;i<5;i++)\n        {\n            for(int j=a[i];j<=b[i];j++)\n            {\n                cin >> st.f[i][j];\n                if(st.f[i][j]==-1)goto end;\n            }\n        }\n        st.t=0;\n        bfs2(st);\n        if(ans>20)printf(\"NA\\n\");\n        else printf(\"%d\\n\",ans);\n    }\n    end:;\n    return 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include<cstdio>\n#include<algorithm>\n#include<iostream>\n#include<queue>\n#include<functional>\n#include<map>\n#include<vector>\nusing namespace std;\nclass P{\n    public:\n    int state[13];\n    char cnt;\n    int p1;\n    int p2;\n    P(){}\n    P(int a[13],char cnt,int p1,int p2):cnt(cnt),p1(p1),p2(p2){\n        for(int i = 0; i < 13; i++){\n            state[i] = a[i];\n        }\n    }\n};\nint rules[13][6]={\n    {1,2},{2,2,5},{4,0,1,3,6},{2,2,7},{1,5},\n    {4,1,4,6,9},{4,2,5,7,10},{4,3,6,8,11},{1,7},{2,5,10},\n    {4,6,9,11,12},{2,7,10},{1,10}\n};\n \nmap< string , char >memo;\n \nstring getIndex(int *a){\n    string tmp=\"\";\n    for(int i = 0; i < 13; i++){\n        tmp += (a[i]+48);\n    }\n    return tmp;\n}\n \nvoid bfs(){\n    int F[] = {0,1,2,3,4,5,6,7,8,9,10,11,0};\n    queue < P > Q;\n    Q.push(P(F,1,0,12));\n    while( true ){\n        if(Q.size() == 0)break;\n        P p = Q.front();Q.pop();\n        if(p.cnt > 21)break;\n        string index = getIndex(p.state);\n        if( memo[index] )continue;\n        memo[index] = p.cnt;\n        for(int j = 0; j < rules[p.p1][0]; j++){\n            if(p.state[rules[p.p1][j+1]] == 0)continue;\n            swap(p.state[p.p1],p.state[rules[p.p1][j+1]]);\n            Q.push(P(p.state,p.cnt+1,p.state[p.p1],p.p2));\n            swap(p.state[p.p1],p.state[rules[p.p1][j+1]]);\n        }\n        for(int j = 0; j < rules[p.p2][0]; j++){\n            if(p.state[rules[p.p2][j+1]] == 0)continue;\n            swap(p.state[p.p2],p.state[rules[p.p2][j+1]]);\n            Q.push(P(p.state,p.cnt+1,p.p1,p.state[p.p2]));\n            swap(p.state[p.p2],p.state[rules[p.p2][j+1]]);\n        }\n    }\n    return ;\n}\nint main(){\n    bfs();\n    int input[13];\n    while(true){\n        scanf(\"%d\",&input[0]);\n        if(input[0] == -1)break;\n        for(int i = 1; i < 13; i++){\n            scanf(\"%d\",&input[i]);\n        }\n        string index = getIndex(input);\n        if( memo[index] )printf(\"%d\\n\",memo[index]-1);\n        else puts(\"NA\");\n    }\n    return 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include<iostream>\n#include<vector>\n#include<queue>\n#include<map>\n#include<cmath>\n#include<cstdlib>\n#include<algorithm>\nusing namespace std;\n\nstring ans = \"xxoxxxabcxdefghxijkxxxoxx\";\n\nclass board{\npublic:\n  int h,c;\n  string s;\n  board(int x,int y,string z){ h=x; c=y; s=z;}\n  const bool operator<(const board x)const{return h+c>x.h+x.c; }\n};\n\nint score(string s){\n  int res=0,m;\n  for(int i=0;i<25;i++){\n    if(s[i]!='x' && s[i]!='o'){\n      for(int j=0;j<25;j++){\n\tif(s[i]==ans[j]){\n\t  m = abs(i/5-j/5) + abs(i%5-j%5);\n\t  break;\n\t}\n      }\n      res += m;\n    }\n  }\n  return res;\n}\n\nchar trans(int x){\n  if(!x)return 'o';\n  else return 'a'+x-1;\n}\n\nint main(){\n  string s = \"xxxxxxxxxxxxxxxxxxxxxxxxx\";\n  int tmp,cost;\n\n  for(;;){\n    cin >> tmp;\n    if(tmp<0)break;\n\n    s[2] = trans(tmp);\n    for(int i=0;i<3;i++){\n      cin >> tmp;\n      s[6+i] = trans(tmp);\n    }\n    for(int i=0;i<5;i++){\n      cin >> tmp;\n      s[10+i] = trans(tmp);\n    }\n    for(int i=0;i<3;i++){\n      cin >> tmp;\n      s[16+i] = trans(tmp);\n    }\n    cin >> tmp;\n    s[22] = trans(tmp);\n\n    priority_queue<board> q;\n    q.push(board(score(s),0,s));\n\n    map<string,bool> m;\n    while(q.size()){\n      board p = q.top();q.pop();\n      int dx[] = {-5,1,5,-1};\n\n      cost = p.c;\n      if(p.s == ans)break;\n      if(p.h+cost>20){\n\tcost = 21;\n\tbreak;\n      }\n\n      m[p.s] = true;\n      for(int i=0;i<25;i++){\n\tif(p.s[i]=='o'){\n\t  for(int j=0;j<4;j++){\n\t    int sx = i + dx[j];\n\t    if(sx<0 || 25<=sx)continue;\n\t    if(p.s[sx] == 'x' || p.s[sx] == 'o')continue;\n\t    string str = p.s;\n\t    swap(str[i],str[sx]);\n\t    if(!m[str])q.push(board(score(str),cost+1,str));\n\t  }\n\t}\n      }\n    }\n\n    if(cost>20)cout << \"NA\\n\";\n    else cout << cost << endl;\n  }\n}"
  },
  {
    "language": "C++",
    "code": "#include<bits/stdc++.h>\n#define r(i,n) for(int i=0;i<n;i++)\nusing namespace std;\ntypedef pair<vector<int>,int>P;\nvector<int>v[13],s(13),t(13);\nmap<vector<int>,int>m;\n\nint has[14];\n\n\nvoid init(){\n\n    v[0].push_back(2);\n\n    v[1].push_back(2);\n    v[1].push_back(5);\n\n    v[2].push_back(0);\n    v[2].push_back(1);\n    v[2].push_back(3);\n    v[2].push_back(6);\n\n    v[3].push_back(2);\n    v[3].push_back(7);\n\n    v[4].push_back(5);\n\n    v[5].push_back(1);\n    v[5].push_back(4);\n    v[5].push_back(6);\n    v[5].push_back(9);\n\n    v[6].push_back(2);\n    v[6].push_back(5);\n    v[6].push_back(7);\n    v[6].push_back(10);\n\n    v[7].push_back(3);\n    v[7].push_back(6);\n    v[7].push_back(8);\n    v[7].push_back(11);\n\n    v[8].push_back(7);\n\n    v[9].push_back(5);\n    v[9].push_back(10);\n\n    v[10].push_back(6);\n    v[10].push_back(9);\n    v[10].push_back(11);\n    v[10].push_back(12);\n\n    v[11].push_back(7);\n    v[11].push_back(10);\n\n    v[12].push_back(10);\n\n    int a=20;\n    int p=1;\n\n    r(i,13){\n        has[i]=p;\n        p*=a;\n    }\n}\n\nint ha(vector<int> &x){\n\n    int re=0;\n\n    r(i,13){\n        re+=x[i]*has[i];\n    }\n\n    return re;\n}\n\nvector<int> ah(int x){\n    vector<int>y(13);\n    r(i,13){\n        y[i]=x%20;\n        x/=20;\n    }\n    return y;\n}\n\nvoid BFS1(){\n    s[0]=0;\n    s[12]=0;\n    r(i,11)s[i+1]=i+1;\n    set<vector<int> >st;\n    st.insert(s);\n    m[s]=0;\n    queue<P>q;\n    q.push(P(s,0));\n    while(1){\n        vector<int> now=q.front().first;\n        int cost=q.front().second;\n        q.pop();\n        if(cost==10)break;\n        //cout<<m.size()<<' '<<cost<<endl;\n        r(i,13)if(now[i]==0){\n            r(j,v[i].size()){\n                swap(now[i],now[v[i][j]]);\n                if(!st.count(now)){\n                    st.insert(now);\n                    m[now]=cost+1;\n                    q.push(P(now,cost+1));\n                }\n                swap(now[i],now[v[i][j]]);\n            }\n        }\n    }\n}\n\nvoid BFS2(){\n    set<vector<int> >st;\n    st.insert(t);\n    queue<P>q;\n    q.push(P(t,0));\n    while(1){\n        vector<int>now=q.front().first;\n        int cost=q.front().second;\n        q.pop();\n        if(m.count(now)){\n            cout<<m[now]+cost<<endl;\n            return ;\n        }\n        if(cost==10)break;\n        r(i,13)if(now[i]==0){\n            r(j,v[i].size()){\n                swap(now[i],now[v[i][j]]);\n                if(!st.count(now)){\n                    st.insert(now);\n                    if(m.count(now)){\n                        cout<<m[now]+cost+1<<endl;\n                        return ;\n                    }\n                    q.push(P(now,cost+1));\n                }\n                swap(now[i],now[v[i][j]]);\n            }\n        }\n    }\n    cout<<\"NA\"<<endl;\n}\n\n\nsigned main(){\n    init();\n    BFS1();\n    while(cin>>t[0],t[0]!=-1){\n        r(i,12)cin>>t[i+1];\n        BFS2();\n    }\n}\n"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\n\nusing namespace std;\n\ntypedef long long ll;\ntypedef long double ld;\ntypedef tuple<int, int> duo;\nconst int dx[] = {0, 0, 1, -1, 1, 1, -1, -1};\nconst int dy[] = {1, -1, 0, 0, 1, -1, 1, -1};\nconst int Mod = 1000000000 + 0;\n//{{{ templates\n#define TT_             \\\n  template <typename T> \\\n  inline\n#define TTF_                        \\\n  template <typename T, typename F> \\\n  inline\nTT_ T sq(T x) { return x * x; }\nTT_ T In() {\n  T x;\n  cin >> x;\n  return x;\n}\nTT_ void Out(T& x) { cout << x; }\nTT_ void sort(T& v) { sort(begin(v), end(v)); }\nTT_ void revs(T& v) { reverse(begin(v), end(v)); }\nTT_ void uniq(T& v) {\n  sort(v);\n  v.erase(unique(begin(v), end(v)), end(v));\n}\nTT_ int ubnd(T& v, typename T::value_type& x) {\n  return upper_bound(begin(v), end(v), x) - begin(v);\n}\nTT_ int lbnd(T& v, typename T::value_type& x) {\n  return lower_bound(begin(v), end(v), x) - begin(v);\n}\nTTF_ void inpt(T& v, int n, F f) {\n  for (v.reserve(n); n--; v.emplace_back(f()))\n    ;\n}\nTTF_ void show(T& v, F f, string d = \" \", string e = \"\\n\") {\n  int i = 0;\n  for (auto& x : v) i++&&(cout << d), f(x);\n  cout << e;\n}\nTT_ typename T::iterator minel(T& v) { return min_element(begin(v), end(v)); }\nTT_ typename T::iterator maxel(T& v) { return max_element(begin(v), end(v)); }\n\ninline void fast_io() {\n  ios::sync_with_stdio(0);\n  cin.tie(0);\n}\ninline int in() {\n  int x;\n  scanf(\"%d\", &x);\n  return x;\n}\ninline ll pow_mod(ll a, ll k, ll m) {\n  ll r = 1;\n  for (; k > 0; a = a * a % m, k >>= 1)\n    if (k & 1) r = r * a % m;\n  return r;\n}\ninline ll mod_inv(ll a, ll p) { return pow_mod(a, p - 2, p); }\n//}}} priority_queue queue deque front stringstream max_element min_element\n// insert count make_tuple\n\nstruct Board {\n  Board() {\n    memcpy(b, \"0123456789AB0\", sizeof(b));\n    find_zero();\n  }\n  Board(const vector<int>& v) {\n    for (int i = 0; i < 13; i++) b[i] = conv_hex(v[i]);\n    b[13] = 0;\n    find_zero();\n  }\n  void find_zero(){\n    int it = 0;\n    for (int i = 0; i < 13; i++){\n      if (b[i] == '0'){\n        cur[it] = i;\n        it++;\n      }\n    }\n  }\n  char conv_hex(int a) { return \"0123456789ABCDEF\"[a]; }\n  bool slide(int index, int dir) {\n    static const char mov[][4] = {\n      {-1, -1, 2, -1},\n      {-1, 2, 5, -1},\n      {0, 3, 6, 1},\n      {-1, -1, 7, 2},\n      {-1, 5, -1, -1},\n      {1, 6, 9, 4},\n      {2, 7, 10, 5},\n      {3, 8, 11, 6},\n      {-1, -1, -1, 7},\n      {5, 10, -1, -1},\n      {6, 11, 12, 9},\n      {7, -1, -1, 10},\n      {10, -1, -1, -1},\n    };\n    char cu = cur[index];\n    char nu = mov[cu][dir];\n    if (nu == -1) return false;\n    if (b[nu] == '0') return false;\n    swap(b[cu], b[nu]);\n    cur[index] = nu;\n    turn++;\n    return true;\n  }\n  char b[14];\n  char cur[2];\n  char turn;\n};\n\nvoid build_table(unordered_map<ll, char>& ans){\n  Board b;\n  queue<Board> Q;\n  Q.push(b);\n  while (!Q.empty()){\n    Board bi = Q.front();\n    Q.pop();\n    ll hv = strtoll(bi.b, 0, 16);\n    if (ans.count(hv)) continue;\n    ans[hv] = bi.turn;\n    if (bi.turn >= 10) continue;\n    for (int i = 0; i < 2; i++){\n      for (int d = 0; d < 4; d++){\n        auto bii = bi;\n        if (!bii.slide(i, d)) continue;\n        Q.push(bii);\n      }\n    }\n  }\n}\n\nint main() {\n  unordered_map<ll, char> ans;\n  build_table(ans);\n  int h;\n  while (h = in(), h != -1) {\n    vector<int> vs;\n    vs.push_back(h);\n    for (int i = 0; i < 12; i++) vs.push_back(in());\n    Board b(vs);\n    unordered_set<ll> vis;\n    queue<Board> Q;\n    Q.push(b);\n    while (!Q.empty()){\n      Board bi = Q.front();\n      Q.pop();\n      ll hv = strtoll(bi.b, 0, 16);\n      if (vis.count(hv)) continue;\n      vis.insert(hv);\n      if (ans.count(hv)){\n        cout << (int)ans[hv] + (int)bi.turn << endl;\n        goto END;\n      }\n      if (bi.turn >= 10) continue;\n      for (int i = 0; i < 2; i++){\n        for (int d = 0; d < 4; d++){\n          Board bii = bi;\n          if (!bii.slide(i, d)) continue;\n          Q.push(bii);\n        }\n      }\n    }\n    cout << \"NA\\n\";\nEND:;\n  }\n  return 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include <iostream>\n#include <algorithm>\n#include <vector>\n#include <queue>\n#include <map>\nusing namespace std;\n#define rep(i,n) for(int i=0;i<n;i++)\nclass NODE{\npublic:\n\tvector<int> data;\n\tint depth;\n\tint e[2];\n\tNODE(int a[13],int d,int E[2]){\n\t\tdata.resize(13);\n\t\trep(i,13)data[i] = a[i];\n\t\tdepth = d;\n\t\trep(i,2)e[i] = E[i];\n\t}\n\tNODE(){\n\t\tdepth = 0;\n\t\tdata.resize(13);\n\t}\n};\n\nint di[13][10] = {\n\t{2,-1},\n\t{2,5,-1},\n\t{0,1,3,6,-1},\n\t{2,7,-1},\n\t{5,-1},\n\t{1,4,6,9,-1},\n\t{2,5,7,10,-1},\n\t{3,6,7,11,-1},\n\t{7-1},\n\t{5,10,-1},\n\t{6,9,11,12,-1},\n\t{7,10,-1},\n\t{10,-1}\n};\nint rx[] = {3,2,3,4,1,2,3,4,5,2,3,4,3};\nint ry[] = {1,2,2,2,3,3,3,3,3,4,4,4,5};\n\nint main(){\n\twhile(1){\n\t\tint ret = 21;\n\t\tNODE fst; int cnt = 0;\n\t\trep(i,13){\n\t\t\tif(cin >>fst.data[i] , fst.data[i] != -1){\n\t\t\t\tif(fst.data[i] == 0){\n\t\t\t\t\tfst.e[cnt] = i;\n\t\t\t\t\tcnt++;\n\t\t\t\t}\n\t\t\t}else{\n\t\t\t\treturn 0;\n\t\t\t}\n\t\t}\n\t\tmap< vector<int> , int > done;\n\t\t\n\t\tqueue<NODE> Q;\n\t\tQ.push(fst);\n\t\tdone[Q.front().data] = 0;\n\t\t\n\t\twhile(Q.size()){\n\t\t\tNODE q = Q.front(); Q.pop();\n\n\t\t\tint mndist = 0;\n\t\t\trep(i,13)mndist += abs(rx[q.data[i]]-rx[i]) + abs(ry[q.data[i]]-ry[i]);\n\t\t\tif(mndist + q.depth > 23)continue;\n\t\t\t\n\t\t\t\n\t\t\tif( q.data[0] == 0 && q.data[1] == 1 && q.data[2] == 2 && q.data[3] == 3 && q.data[4] == 4 && q.data[5] == 5 && q.data[6] == 6 && q.data[7] == 7 &&\n\t\t\t\t\tq.data[8] == 8 && q.data[9] == 9 && q.data[10]==10 && q.data[11]==11 && q.data[12]==0\n\t\t\t){\n\t\t\t\tcout << q.depth << endl;\n\t\t\t\tgoto jmp;\n\t\t\t}\n\n\t\t\trep(o,2){\n\t\t\t\tfor(int i=0;di[q.e[o]][i] != -1;i++){\n\t\t\t\t\tNODE next = q;\n\t\t\t\t\tnext.e[o] = next.data[di[q.e[o]][i]];\n\t\t\t\t\tswap(next.data[q.e[o]] , next.data[di[q.e[o]][i]]);\n\t\t\t\t\tnext.depth = q.depth + 1;\n\t\t\t\t\t\n\t\t\t\t\tif( done.find(next.data) == done.end() ){\n\t\t\t\t\t\tdone[next.data] = next.depth;\n\t\t\t\t\t\tif( q.depth < 21)Q.push(next);\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t\tcout << \"NA\" << endl;\n\t\tjmp:;\n\t}\n}"
  },
  {
    "language": "C++",
    "code": "#include<iostream>\n#include<vector>\n#include<queue>\n#include<map>\n#include<cmath>\n#include<cstdlib>\n#include<algorithm>\nusing namespace std;\n\nstring ans;\n\nclass board{\npublic:\n  int h,c;\n  string s;\n  board(int x,int y,string z){ h=x; c=y; s=z;}\n  const bool operator<(const board x)const{return (h+c>x.h+x.c) || (h+c==x.h+x.c && c>x.c); }\n};\n\nint score(string s){\n  int res=0;\n  for(int i=0;i<25;i++){\n    if(s[i]!='x'){\n      int m=20;\n      for(int j=0;j<25;j++){\n\tif(s[i]==ans[j]){\n\t  int a = abs(i-j);\n\t  int tmp = a/5 + a%5;\n\t  m = min(m,tmp);\n\t  if(s[i]!='o')break;\n\t}\n      }\n      res += m;\n    }\n  }\n  return res;\n}\n\nchar trans(int x){\n  if(!x)return 'o';\n  else return 'a'+x-1;\n}\n\nint main(){\n  string s;\n  ans = \"xxoxxxabcxdefghxijkxxxoxx\";\n  int tmp,cost;\n\n  for(;;){\n    cin >> tmp;\n    if(tmp<0)break;\n\n    s = \"xx\";\n    s += trans(tmp);\n    s += \"xxx\";\n    for(int i=0;i<3;i++){\n      cin >> tmp;\n      s += trans(tmp);\n    }\n    s += \"x\";\n    for(int i=0;i<5;i++){\n      cin >> tmp;\n      s += trans(tmp);\n    }\n    s += \"x\";\n    for(int i=0;i<3;i++){\n      cin >> tmp;\n      s+= trans(tmp);\n    }\n    s += \"xxx\";\n    cin >> tmp;\n    s += trans(tmp);\n    s += \"xx\";\n\n    priority_queue<board> q1;\n    q1.push(board(score(s),0,s));\n\n    map<string,bool> m1;\n    m1[s] = 0;\n    while(q1.size()){\n      board p = q1.top();q1.pop();\n      int dx[] = {-5,1,5,-1};\n      //cout << p.h << \" \" << p.c << \" \" << p.s << endl;\n      cost = p.c;\n      if(p.s == ans)break;\n      if(cost>20)break;\n      if(p.h/2+p.c > 20){\n\tcost = 21;\n\tbreak;\n      }\n      for(int i=0;i<25;i++){\n\tif(p.s[i]=='o'){\n\t  for(int j=0;j<4;j++){\n\t    int sx = i + dx[j];\n\t    string str = p.s;\n\t    if(sx<0 || 25<=sx)continue;\n\t    if(str[sx] == 'x' || str[sx] == 'o')continue;\n\t    swap(str[i],str[sx]);\n\t    if(!m1[str]){\n\t      q1.push(board(score(str),cost+1,str));\n\t      m1[str] = cost+1;\n\t    }\n\t  }\n\t}\n      }\n    }\n\n\n\n    if(cost>20)cout << \"NA\\n\";\n    else cout << cost << endl;\n  }\n}"
  },
  {
    "language": "C++",
    "code": "#include <iostream>\n#include <string>\n#include <vector>\n#include <queue>\n#include <map>\nusing namespace std;\n\nstring s = \"0123456789AB\";\nstring goal = \"0123456789AB0\";\n\nvector<vector<int>> adj = {\n    {2},\n    {2,5},\n    {0,1,3,6},\n    {2,7},\n    {5},\n    {1,4,6,9},\n    {2,5,7,10},\n    {3,6,8,11},\n    {7},\n    {5,10},\n    {6,9,11,12},\n    {7,10},\n    {10}\n};\n\nint solve(string stat) {\n    if (stat == goal) return 0;\n    map<string, int> dist;\n    dist[stat] = 0;\n    queue<string> q;\n    q.push(stat);\n    while ( ! q.empty()) {\n        string s = q.front();\n        q.pop();\n        for (int i=0; i<13; ++i) {\n            if (s[i] != '0') continue;\n            for (int j : adj[i]) {\n                string next = s;\n                next[i] = s[j];\n                next[j] = s[i];\n                int diff = 0;\n                for (int k=0; k<13; ++k) {\n                    diff += next[k] != goal[k];\n                }\n                if ( ! diff) {\n                    return dist[s] + 1;\n                }\n                if (dist.find(next) == dist.end()) {\n                    dist[next] = dist[s] + 1;\n                    if (dist[next] + diff - 2 <= 20) {\n                        q.push(next);\n                    }\n                }\n            }\n        }\n    }\n    return 21;\n}\n\nint main() {\n    while (1) {\n        string stat = \"\";\n        int k;\n        for (int i=0; i<13; ++i) {\n            if (cin >> k && !~k) return 0;\n            stat += s[k];\n        }\n        int ans = solve(stat);\n        if (ans <= 20) {\n            cout << ans << endl;\n            continue;\n        }\n        cout << \"NA\" << endl;\n    }\n    return 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include<bits/stdc++.h>\n#define int long long\n#define r(i,n) for(int i=0;i<n;i++)\nusing namespace std;\ntypedef pair<int,int>P;\nvector<int>v[13],s(13),t(13);\nmap<int,int>m;\n\nint has[14];\n\n\nvoid init(){\n\n    v[0].push_back(2);\n\n    v[1].push_back(2);\n    v[1].push_back(5);\n\n    v[2].push_back(0);\n    v[2].push_back(1);\n    v[2].push_back(3);\n    v[2].push_back(6);\n\n    v[3].push_back(2);\n    v[3].push_back(7);\n\n    v[4].push_back(5);\n\n    v[5].push_back(1);\n    v[5].push_back(4);\n    v[5].push_back(6);\n    v[5].push_back(9);\n\n    v[6].push_back(2);\n    v[6].push_back(5);\n    v[6].push_back(7);\n    v[6].push_back(10);\n\n    v[7].push_back(3);\n    v[7].push_back(6);\n    v[7].push_back(8);\n    v[7].push_back(11);\n\n    v[8].push_back(7);\n\n    v[9].push_back(5);\n    v[9].push_back(10);\n\n    v[10].push_back(6);\n    v[10].push_back(9);\n    v[10].push_back(11);\n    v[10].push_back(12);\n\n    v[11].push_back(7);\n    v[11].push_back(10);\n\n    v[12].push_back(10);\n\n    int a=20;\n    int p=1;\n\n    r(i,13){\n        has[i]=p;\n        p*=a;\n    }\n}\n\nint ha(vector<int> &x){\n\n    int re=0;\n\n    r(i,13){\n        re+=x[i]*has[i];\n    }\n\n    return re;\n}\n\nvector<int> ah(int x){\n    vector<int>y(13);\n    r(i,13){\n        y[i]=x%20;\n        x/=20;\n    }\n    return y;\n}\n\nvoid BFS1(){\n    s[0]=0;\n    s[12]=0;\n    r(i,11)s[i+1]=i+1;\n    set<int>st;\n    st.insert(ha(s));\n    m[ha(s)]=0;\n    queue<P>q;\n    q.push(P(ha(s),0));\n    while(1){\n        vector<int> now=ah(q.front().first);\n        int cost=q.front().second;\n        q.pop();\n        if(cost==8)break;\n        r(i,13)if(now[i]!=0){\n            r(j,v[i].size()){\n                swap(now[i],now[v[i][j]]);\n                if(!st.count(ha(now))){\n                    st.insert(ha(now));\n                    m[ha(now)]=cost+1;\n                    q.push(P(ha(now),cost+1));\n                }\n                swap(now[i],now[v[i][j]]);\n            }\n        }\n    }\n}\n\nvoid BFS2(){\n    set<int>st;\n    st.insert(ha(t));\n    queue<P>q;\n    q.push(P(ha(t),0));\n    while(1){\n        vector<int>now=ah(q.front().first);\n        int cost=q.front().second;\n        if(m.count(ha(now))){\n            cout<<m[ha(now)]+cost<<endl;\n            return ;\n        }\n        q.pop();\n        if(cost==5)break;\n        r(i,13)if(now[i]!=0){\n            r(j,v[i].size()){\n                swap(now[i],now[v[i][j]]);\n                if(!st.count(ha(now))){\n                    st.insert(ha(now));\n                    q.push(P(ha(now),cost+1));\n                }\n                swap(now[i],now[v[i][j]]);\n            }\n        }\n    }\n    cout<<\"NA\"<<endl;\n}\n\n\nsigned main(){\n    init();\n    BFS1();\n    while(cin>>t[0],t[0]!=-1){\n        r(i,12)cin>>t[i+1];\n        BFS2();\n    }\n}\n"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\n\nusing namespace std;\n\ntypedef long long ll;\ntypedef long double ld;\ntypedef tuple<int, int> duo;\nconst int dx[] = {0, 0, 1, -1, 1, 1, -1, -1};\nconst int dy[] = {1, -1, 0, 0, 1, -1, 1, -1};\nconst int Mod = 1000000000 + 0;\n//{{{ templates\n#define TT_ template<typename T>inline\n#define TTF_ template<typename T,typename F>inline\nTT_ T sq(T x){return x*x;}\nTT_ T In(){T x;cin>>x;return x;}\nTT_ void Out(T&x){cout<<x;}\nTT_ void sort(T&v){sort(begin(v),end(v));}\nTT_ void revs(T&v){reverse(begin(v),end(v));}\nTT_ void uniq(T&v){sort(v);v.erase(unique(begin(v),end(v)),end(v));}\nTT_ int ubnd(T&v,typename T::value_type&x){return upper_bound(begin(v),end(v),x)-begin(v);}\nTT_ int lbnd(T&v,typename T::value_type&x){return lower_bound(begin(v),end(v),x)-begin(v);}\nTTF_ void inpt(T&v,int n,F f){for(v.reserve(n);n--;v.emplace_back(f()));}\nTTF_ void show(T&v,F f,string d=\" \",string e=\"\\n\"){int i=0;for(auto&x:v)i++&&(cout<<d),f(x);cout<<e;}\nTT_ typename T::iterator minel(T&v){return min_element(begin(v),end(v));}\nTT_ typename T::iterator maxel(T&v){return max_element(begin(v),end(v));}\n\ninline void fast_io(){ios::sync_with_stdio(0);cin.tie(0);}\ninline int in(){int x;scanf(\"%d\",&x);return x;}\ninline ll pow_mod(ll a,ll k,ll m){ll r=1;for(;k>0;a=a*a%m,k>>=1)if(k&1)r=r*a%m;return r;}\ninline ll mod_inv(ll a,ll p){return pow_mod(a,p-2,p);}\n//}}} priority_queue queue deque front stringstream max_element min_element insert count make_tuple\n\nstruct Board {\n  Board() {\n    memcpy(b, \"0123456789AB0\", sizeof(b));\n    find_zero();\n    turn = 0;\n  }\n  Board(const vector<int>& v) {\n    for (int i = 0; i < 13; i++) b[i] = conv_hex(v[i]);\n    b[13] = 0;\n    find_zero();\n    turn = 0;\n  }\n  void find_zero(){\n    int it = 0;\n    for (int i = 0; i < 13; i++){\n      if (b[i] == '0'){\n        cur[it] = i;\n        it++;\n      }\n    }\n  }\n  char conv_hex(int a) { return \"0123456789ABCDEF\"[a]; }\n  ll hash(){ return strtoll(b, 0, 16); }\n  bool slide(int index, int dir) {\n    static const char mov[][4] = {\n      {-1, -1, 2, -1},\n      {-1, 2, 5, -1},\n      {0, 3, 6, 1},\n      {-1, -1, 7, 2},\n      {-1, 5, -1, -1},\n      {1, 6, 9, 4},\n      {2, 7, 10, 5},\n      {3, 8, 11, 6},\n      {-1, -1, -1, 7},\n      {5, 10, -1, -1},\n      {6, 11, 12, 9},\n      {7, -1, -1, 10},\n      {10, -1, -1, -1},\n    };\n    char cu = cur[index];\n    char nu = mov[cu][dir];\n    if (nu == -1) return false;\n    if (b[nu] == '0') return false;\n    swap(b[cu], b[nu]);\n    cur[index] = nu;\n    turn++;\n    return true;\n  }\n  char b[14];\n  char cur[2];\n  char turn;\n};\n\nvoid build_table(unordered_map<ll, char>& ans){\n  Board b;\n  queue<Board> Q;\n  Q.push(b);\n  while (!Q.empty()){\n    Board bi = Q.front();\n    Q.pop();\n    ll hv = bi.hash();\n    if (ans.count(hv)) continue;\n    ans[hv] = bi.turn;\n    if (bi.turn >= 10) continue;\n    for (int i = 0; i < 2; i++){\n      for (int d = 0; d < 4; d++){\n        auto bii = bi;\n        if (!bii.slide(i, d)) continue;\n        Q.push(bii);\n      }\n    }\n  }\n}\n\nint main() {\n  unordered_map<ll, char> ans;\n  build_table(ans);\n  int h;\n  while (h = in(), h != -1) {\n    vector<int> vs;\n    vs.push_back(h);\n    for (int i = 0; i < 12; i++) vs.push_back(in());\n    Board b(vs);\n    unordered_set<ll> vis;\n    queue<Board> Q;\n    Q.push(b);\n    while (!Q.empty()){\n      Board bi = Q.front();\n      Q.pop();\n      ll hv = bi.hash();\n      if (vis.count(hv)) continue;\n      vis.insert(hv);\n      if (ans.count(hv)){\n        cout << (int)ans[hv] + (int)bi.turn << endl;\n        goto END;\n      }\n      if (bi.turn >= 10) continue;\n      for (int i = 0; i < 2; i++){\n        for (int d = 0; d < 4; d++){\n          Board bii = bi;\n          if (!bii.slide(i, d)) continue;\n          Q.push(bii);\n        }\n      }\n    }\n    cout << \"NA\\n\";\nEND:;\n  }\n  return 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include <algorithm>\n#include <cctype>\n#include <climits>\n#include <cmath>\n#include <cstdio>\n#include <cstdlib>\n#include <cstring>\n#include <functional>\n#include <map>\n#include <numeric>\n#include <queue>\n#include <set>\n#include <sstream>\n#include <string>\n#include <vector>\n\nusing namespace std;\n\n#define reps(i,f,n) for(int i=f; i<int(n); ++i)\n#define rep(i,n) reps(i,0,n)\n\ntypedef long long ll;\ntypedef vector<int> vi;\ntypedef vector<vi> vvi;\ntypedef pair<int, int> pii;\n\nconst int INF = 1001001001;\nconst ll FINAL = 0x0ba9876543210ll;\n\nstruct Data\n{\n\tll s;\n\tint d;\n\tbool f;\n\tData(ll s, int d, bool f) : s(s), d(d), f(f) {}\n};\n\nint bfs(ll init)\n{\n\tif(init == FINAL)\n\t\treturn 0;\n\t\n\tconst int move[13][5] = {\n\t\t{2, -1},\n\t\t{2, 5, -1},\n\t\t{0, 1, 3, 6, -1},\n\t\t{2, 7, -1},\n\t\t{5, -1},\n\t\t{1, 4, 6, 9, -1},\n\t\t{2, 5, 7, 10, -1},\n\t\t{3, 6, 8, 11, -1},\n\t\t{7, -1},\n\t\t{5, 10, -1},\n\t\t{6, 9, 11, 12, -1},\n\t\t{7, 10, -1},\n\t\t{10, -1}\n\t};\n\t\n\tset<ll> visited[2];\n\tqueue<Data> Q;\n\tQ.push(Data(init, 0, false));\n\tQ.push(Data(FINAL, 0, true));\n\tvisited[0].insert(init);\n\tvisited[1].insert(FINAL);\n\tint now[2] = {0};\n\t\n\twhile(!Q.empty()){\n\t\tData data = Q.front();\n\t\tQ.pop();\n\t\tnow[data.f] = data.d + 1;\n\n\t\tfor(int i=0, cnt=2; cnt; ++i){\n\t\t\tif(((data.s>>(i*4)) & 0xfll) == 0){\n\t\t\t\tfor(int j=0; move[i][j]!=-1; ++j){\n\t\t\t\t\tll next = data.s;\n\t\t\t\t\tnext &= ~((0xfll << (i*4)) | (0xfll << (move[i][j]*4)));\n\t\t\t\t\tnext |= ((data.s >> (move[i][j]*4)) & 0xfll) << (i*4);\n\t\t\t\t\t\n\t\t\t\t\tif(visited[!data.f].find(next) != visited[!data.f].end())\n\t\t\t\t\t\treturn now[0] + now[1];\n\n\t\t\t\t\tif(visited[data.f].find(next) == visited[data.f].end()){\n\t\t\t\t\t\tvisited[data.f].insert(next);\n\t\t\t\t\t\tif(data.d < 10)\n\t\t\t\t\t\t\tQ.push(Data(next, data.d+1, data.f));\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t\t--cnt;\n\t\t\t}\n\t\t}\n\t}\n\treturn -1;\n}\n\nint main()\n{\n\tfor(;;){\n\t\tint input[13];\n\t\trep(i, 13){\n\t\t\tscanf(\"%d\", &input[i]);\n\t\t\tif(input[i] == -1)\n\t\t\t\treturn 0;\n\t\t}\n\n\t\tll init = 0;\n\t\trep(i, 13)\n\t\t\tinit = (init << 4) | input[12-i];\n\n\t\tint ans = bfs(init);\n\t\tif(ans == -1 || ans > 20)\n\t\t\tputs(\"NA\");\n\t\telse\n\t\t\tprintf(\"%d\\n\", ans);\n\t}\n}"
  },
  {
    "language": "C++",
    "code": "#include<iostream>\n#include<vector>\n#include<queue>\n#include<map>\n#include<cmath>\n#include<cstdlib>\n#include<algorithm>\nusing namespace std;\n\nstring ans;\n\nclass board{\npublic:\n  int h,c;\n  string s;\n  board(int x,int y,string z){ h=x; c=y; s=z;}\n  const bool operator<(const board x)const{return (h+c>x.h+x.c) || (h+c==x.h+x.c && c>x.c); }\n};\n\nint score(string s){\n  int res=0;\n  for(int i=0;i<25;i++){\n    if(s[i]!='x'){\n      int m=20;\n      for(int j=0;j<25;j++){\n\tif(s[i]==ans[j]){\n\t  int a = abs(i-j);\n\t  int tmp = a/5 + a%5;\n\t  m = min(m,tmp);\n\t  if(s[i]!='o')break;\n\t}\n      }\n      res += m;\n    }\n  }\n  return res;\n}\n\nchar trans(int x){\n  if(!x)return 'o';\n  else return 'a'+x-1;\n}\n\nint main(){\n  string s;\n  ans = \"xxoxxxabcxdefghxijkxxxoxx\";\n  int tmp,cost;\n\n  for(;;){\n    cin >> tmp;\n    if(tmp<0)break;\n\n    s = \"xx\";\n    s += trans(tmp);\n    s += \"xxx\";\n    for(int i=0;i<3;i++){\n      cin >> tmp;\n      s += trans(tmp);\n    }\n    s += \"x\";\n    for(int i=0;i<5;i++){\n      cin >> tmp;\n      s += trans(tmp);\n    }\n    s += \"x\";\n    for(int i=0;i<3;i++){\n      cin >> tmp;\n      s+= trans(tmp);\n    }\n    s += \"xxx\";\n    cin >> tmp;\n    s += trans(tmp);\n    s += \"xx\";\n\n    priority_queue<board> q1;\n    q1.push(board(score(s),0,s));\n\n    map<string,bool> m1;\n    m1[s] = 0;\n    while(q1.size()){\n      board p = q1.top();q1.pop();\n      int dx[] = {-5,1,5,-1};\n      //cout << p.h << \" \" << p.c << \" \" << p.s << endl;\n      cost = p.c;\n      if(p.s == ans)break;\n      if(cost>20)break;\n\n      for(int i=0;i<25;i++){\n\tif(p.s[i]=='o'){\n\t  for(int j=0;j<4;j++){\n\t    int sx = i + dx[j];\n\t    string str = p.s;\n\t    if(sx<0 || 25<=sx)continue;\n\t    if(str[sx] == 'x' || str[sx] == 'o')continue;\n\t    swap(str[i],str[sx]);\n\t    if(!m1[str]){\n\t      q1.push(board(score(str),cost+1,str));\n\t      m1[str] = cost+1;\n\t    }\n\t  }\n\t}\n      }\n    }\n\n\n\n    if(cost>20)cout << \"NA\\n\";\n    else cout << cost << endl;\n  }\n}"
  },
  {
    "language": "C++",
    "code": "#include<bits/stdc++.h>\nusing namespace std;\n  \ntypedef long long int64;\nconst int INF = 1 << 30;\n  \nvector< int > edge[13];\nmap< string, int > memo;\n \nbool back(string str, int cnt){ //枝刈り大事だな\n  static int dist[] = { 0, 2, 1, 2, 4, 3, 2, 3, 4, 2, 1, 2, 0};\n  static int fuee[] = { 2, 0, 1, 2, 2, 1, 2, 3, 4, 2, 3, 4, 4};\n  static int fuga[] = { 1, 1, 0, 1, 3, 2, 1, 2, 3, 3, 2, 3, 3};\n \n  int foo1 = 0, foo2 = 0, foo3;\n  for(int i = 0; i < 13; i++){\n    if(str[i] == '0') foo1 += dist[i];\n    else if(str[i] == '1') foo2 += fuee[i];\n    else if(str[i] == '2') foo3 += fuga[i];\n  }\n  return cnt + foo1 > 20 || cnt + foo2 > 20 || cnt + foo3 > 20;\n}\n \n \nint bfs(string mas){\n \n  queue< string > que;\n  map< string , int > used;\n  que.push( mas );\n  memo[mas] = 0;\n  while(!que.empty()){\n \n    string p = que.front(); que.pop();\n    if(back( p, memo[p])) break;\n    if(p == \"0123456789AB0\") return memo[p];\n \n    for(int i = 0; i < 13; i++){\n      if(p[i] == '0') {\n        for(int j = 0; j < edge[i].size(); j++){\n          string next = p;\n          swap( next[i], next[edge[i][j]]);\n          if(memo.find(next) != memo.end()) continue;\n          que.push( next );\n          memo[next] = memo[p] + 1;\n        }\n      }\n    }\n  }\n  return -1;\n}\n \nint main(){\n  vector< int > mas(13);\n \n  edge[0].push_back(2);\n  edge[1].push_back(2); edge[1].push_back(4);\n  edge[2].push_back(0); edge[2].push_back(1); edge[2].push_back(3); edge[2].push_back(6);\n  edge[3].push_back(2); edge[3].push_back(7);\n  edge[4].push_back(5);\n  edge[5].push_back(1); edge[5].push_back(4); edge[5].push_back(6); edge[5].push_back(9);\n  edge[6].push_back(2); edge[6].push_back(5); edge[6].push_back(7); edge[6].push_back(10);\n  edge[7].push_back(3); edge[7].push_back(6); edge[7].push_back(8); edge[7].push_back(11);\n  edge[8].push_back(7);\n  edge[9].push_back(5); edge[9].push_back(10);\n  edge[10].push_back(6); edge[10].push_back(9); edge[10].push_back(11); edge[10].push_back(12);\n  edge[11].push_back(7); edge[11].push_back(10);\n  edge[12].push_back(10);\n \n  while(cin >> mas[0], mas[0] != -1){\n    for(int i = 1; i < 13; i++){\n      cin >> mas[i];\n    }\n \n    string start = \"\";\n    for(int i = 0; i < 13; i++){\n      if(mas[i] >= 10) start += (char)(mas[i] - 10 + 'A');\n      else start += mas[i] + '0';\n    }\n    int ret = bfs(start);\n    if(~ret) cout << ret << endl;\n    else cout << \"NA\" << endl;\n \n    memo.clear();\n  }\n}"
  },
  {
    "language": "C++",
    "code": "#include<iostream>\n#include<string>\n#include<set>\n#include<utility>\n#include<queue>\n#include<algorithm>\nusing namespace std;\n\nconst int N=7;\n\nint f(string first)\n{\n\tconst string last(\n\t\t\".......\"\n\t\t\"...0...\"\n\t\t\"..123..\"\n\t\t\".45678.\"\n\t\t\"..9AB..\"\n\t\t\"...0...\"\n\t\t\".......\");\n\tset<string>s;\n\tqueue<string>q;\n\tstring p,next;\n\tint ans = 0,i,j,k,zeroPos[2],a[]={-1,1,N,-N};\n\n\tq.push(first);\n\tq.push(\"\");\n\twhile(!q.empty())\n\t{\n\t\tp = q.front(); q.pop();\n\t\tif(p.empty())\n\t\t{\n\t\t\t++ans;\n\t\t\tif(ans > 20)\n\t\t\t\treturn -1;\t\t//èª©©è·¬Ä¢Ü·\n\t\t\tq.push(\"\");\n\t\t}\n\t\telse if(p==last) break;\n\t\telse\n\t\t{\n\t\t\tif(!s.insert(p).second)\n\t\t\t\tcontinue;\t//à¤»Ì`ÉÈÁ½±Æª éÈç½àµÈ¢\n\t\t\t//0ÌêðT·\n\t\t\tzeroPos[0]=p.find('0');\n\t\t\tzeroPos[1]=p.find('0',zeroPos[0]+1);\n\t\t\t//0Ìê©çAãº¶Eª.Å³¯êÎð·µÄo^\n\t\t\tfor(i=0;i<2;++i)\n\t\t\t{\n\t\t\t\tfor(j=0;j<4;++j)\n\t\t\t\t{\n\t\t\t\t\tif(p[ zeroPos[i]+a[j] ]!='.')\n\t\t\t\t\t{\n\t\t\t\t\t\tnext=p;\n\t\t\t\t\t\tswap(next[zeroPos[i]], next[ zeroPos[i]+a[j] ]);\n\t\t\t\t\t\tq.push(next);\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t}\n\treturn ans;\n}\n\nint main()\n{\n\tconst char a[]=\"0123456789AB\";\n\t//(5+2)^2ÌvfðAÔºà©ËÄmÛ\n\tstring s(49,'.');\n\tint i,x;\n\twhile(cin>>x,x>=0)\n\t{\n\t\ts[10]=a[x];\n\t\tfor(i=0;i<3;++i) cin>>x,s[16+i]=a[x];\n\t\tfor(i=0;i<5;++i) cin>>x,s[22+i]=a[x];\n\t\tfor(i=0;i<3;++i) cin>>x,s[30+i]=a[x];\n\t\tcin>>x,s[38]=a[x];\n\n\t\tx=f(s);\n\t\tif(x>=0) cout<<x<<endl;\n\t\telse cout<<\"NA\\n\";\n\t}\n\treturn 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include<iostream>\n#include<cmath>\n#include<stdio.h>\nusing namespace std;\n\n#define LIMIT 20\n\nstruct Puzzle {\n  int cont[25];\n  int space[2];\n};\n\nint limit;\n\nPuzzle puzzle;\n\nint tx[12]={0,1,2,3,0,1,2,3,4,1,2,3};\nint ty[12]={0,1,1,1,2,2,2,2,2,3,3,3};\nint dx[4]={0,1,0,-1};\nint dy[4]={-1,0,1,0};\n\nint heuris[12][25];\n\nint getHeuristic(){\n  int res=0;\n  for(int i=0;i<25;i++){\n    if(puzzle.cont[i]==-1||puzzle.cont[i]==0)continue;\n    res+=heuris[puzzle.cont[i]][i];\n  }\n  return res;\n}\n\nbool dfs(int depth,int prev0,int prev1){\n  /*\n  cout<<depth<<endl;\n  for(int i=0;i<5;i++){\n    for(int j=0;j<5;j++){\n      if(puzzle.cont[i*5+j]!=-1)printf(\"%3d\",puzzle.cont[i*5+j]);\n      else cout<<\"???\";\n    }\n    cout<<endl;\n  }\n  */\n  int heuri;\n  heuri=getHeuristic();\n  if(heuri==0){\n    cout<<depth<<endl;\n    return true;\n  }\n  if(depth + heuri>limit)return false;\n\n  int px,py,nx,ny;\n  Puzzle tmp=puzzle;\n\n  py=puzzle.space[0]/5;px=puzzle.space[0]%5;\n\n  for(int i=0;i<4;i++){\n    if(max(prev0,i)-min(prev0,i)==2)continue;\n    ny=py+dy[i];nx=px+dx[i];\n    if(ny<0||ny>=5||nx<0||nx>=5)continue;\n    if(puzzle.cont[ny*5+nx]==-1)continue;\n    if(puzzle.cont[ny*5+nx]==0)continue;\n    puzzle.cont[py*5+px]=puzzle.cont[ny*5+nx];\n    puzzle.cont[ny*5+nx]=0;\n    puzzle.space[0]=ny*5+nx;\n    if(dfs(depth+1,i,prev1))return true;\n    puzzle=tmp;\n  }\n  py=puzzle.space[1]/5;px=puzzle.space[1]%5;\n  for(int i=0;i<4;i++){\n    if(max(prev1,i)-min(prev1,i)==2)continue;\n    ny=py+dy[i];nx=px+dx[i];\n    if(ny<0||ny>=5||nx<0||nx>=5)continue;\n    if(puzzle.cont[ny*5+nx]==-1)continue;\n    if(puzzle.cont[ny*5+nx]==0)continue;\n    puzzle.cont[py*5+px]=puzzle.cont[ny*5+nx];\n    puzzle.cont[ny*5+nx]=0;\n    puzzle.space[1]=ny*5+nx;\n    if(dfs(depth+1,prev0,i))return true;\n    puzzle=tmp;\n  }\n  return false;\n}\n\nvoid solve(){\n  Puzzle tmp=puzzle;\n  for(limit=getHeuristic();limit<=LIMIT;limit+=2){\n    puzzle=tmp;\n    if(dfs(0,-100,-100))return;\n  }\n  cout<<\"NA\"<<endl;\n}\n\nint main(){\n  int x,y,c=0;\n\n  for(int i=1;i<=11;i++){\n    for(int j=0;j<25;j++){\n      y=j/5;\n      x=j%5;\n      heuris[i][j]=abs(tx[i]-x)+abs(ty[i]-y);\n    }\n  }\n\n\n  for(int i=0;i<25;i++)puzzle.cont[i]=-1;\n\n  while(1){\n    c=0;\n    for(int i=0;i<25;i++)puzzle.cont[i]=-1;\n    cin>>puzzle.cont[2];\n    if(puzzle.cont[2]==-1)break;\n    if(puzzle.cont[2]==0)puzzle.space[c++]=2;\n    \n    \n    for(int i=6;i<=8;i++){\n      cin>>puzzle.cont[i];\n      if(puzzle.cont[i]==0)puzzle.space[c++]=i;\n    }\n    for(int i=10;i<=14;i++){\n      cin>>puzzle.cont[i];\n      if(puzzle.cont[i]==0)puzzle.space[c++]=i;\n    }\n    \n    for(int i=16;i<=18;i++){\n      cin>>puzzle.cont[i];\n      if(puzzle.cont[i]==0)puzzle.space[c++]=i;\n    }\n    \n    cin>>puzzle.cont[22];\n    if(puzzle.cont[22]==0)puzzle.space[c++]=22;\n    solve();\n  }\n\n  return 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\nusing namespace std;\n\nconst int INF = 1<<28;\nconst int H = 5;\nconst int W = 5;\n\nstruct State {\n  int g[H][W];\n  int x[2], y[2];\n  bool operator < (const State &s) const {\n    for(int i = 0; i < H; ++i) {\n      for(int j = abs(2-i); j < W-abs(2-i); ++j) {\n        if(g[i][j] != s.g[i][j]) return g[i][j] < s.g[i][j];\n      }\n    }\n    return false;\n  }\n  bool operator == (const State &s) const {\n    return !(*this < s) && !(s < *this);\n  }\n};\n\nmap<State,int> bfs1(State src) {\n  const static int dx[4] = {1,0,-1,0};\n  const static int dy[4] = {0,1,0,-1};\n  map<State,int> cost;\n  queue<State> que;\n  cost[src] = 0;\n  que.push(src);\n  while(que.size()) {\n    const State s = que.front();\n    que.pop();\n    if(cost[s] == 11) continue;\n    for(int k = 0; k < 2; ++k) {\n      for(int i = 0; i < 4; ++i) {\n        int nx = s.x[k] + dx[i];\n        int ny = s.y[k] + dy[i];\n        if(nx < 0 || nx >= W) continue;\n        if(ny < 0 || ny >= H) continue;\n        if(s.g[ny][nx] <= 0) continue;\n        State t = s;\n        swap(t.g[t.y[k]][t.x[k]], t.g[ny][nx]);\n        t.x[k] = nx;\n        t.y[k] = ny;\n        if(cost.count(t)) continue;\n        cost[t] = cost[s] + 1;\n        que.push(t);\n      }\n    }\n  }\n  return cost;\n}\n\nint bfs2(State src, map<State,int> rcost) {\n  const static int dx[4] = {1,0,-1,0};\n  const static int dy[4] = {0,1,0,-1};\n  if(rcost.count(src)) return rcost[src];\n  map<State,int> cost;\n  queue<State> que;\n  cost[src] = 0;\n  que.push(src);\n  while(que.size()) {\n    const State s = que.front();\n    que.pop();\n    if(cost[s] == 11) continue;\n    for(int k = 0; k < 2; ++k) {\n      for(int i = 0; i < 4; ++i) {\n        int nx = s.x[k] + dx[i];\n        int ny = s.y[k] + dy[i];\n        if(nx < 0 || nx >= W) continue;\n        if(ny < 0 || ny >= H) continue;\n        if(s.g[ny][nx] <= 0) continue;\n        State t = s;\n        swap(t.g[t.y[k]][t.x[k]], t.g[ny][nx]);\n        t.x[k] = nx;\n        t.y[k] = ny;\n        if(cost.count(t)) continue;\n        cost[t] = cost[s] + 1;\n        que.push(t);\n        if(rcost.count(t)) {\n          return cost[t] + rcost[t];\n        }\n      }\n    }\n  }\n  return INF;\n}\n\nint main() {\n  State src, dst;\n  map<State,int> rcost;\n  fill(src.g[0], src.g[H], -1);\n  fill(dst.g[0], dst.g[H], -1);\n  for(int i = 0, k = 0, t = 0; i < H; ++i) {\n    for(int j = abs(2-i); j < W-abs(2-i); ++j) {\n      dst.g[i][j] = t % 12;\n      ++t;\n      if(dst.g[i][j] == 0) {\n        dst.x[k] = j;\n        dst.y[k] = j;\n        ++k;\n      }\n    }\n  }\n  rcost = bfs1(dst);\n  while(1) {\n    for(int i = 0, k = 0; i < H; ++i) {\n      for(int j = abs(2-i); j < W-abs(2-i); ++j) {\n        cin >> src.g[i][j];\n        if(src.g[i][j] == -1) return 0;\n        if(src.g[i][j] == 0) {\n          src.x[k] = j;\n          src.y[k] = i;\n          ++k;\n        }\n      }\n    }\n    int res = bfs2(src, rcost);\n    if(res > 20) cout << \"NA\" << endl;\n    else cout << res << endl;\n  }\n  return 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include<iostream> \n#include<algorithm> \n\nusing namespace std;\n\n#define N 5\n#define REP(i, n) for ( int i = 0; i < (int)n; i++ )\n#define LIMIT 20\n\n// S[ÌÇ±É éÌ©\nstatic const int T[12][2] = {\n\t{-1, -1},\n\t{1, 1},\n\t{1, 2},\n\t{1, 3},\n\t{2, 0},\n\t{2, 1},\n\t{2, 2},\n\t{2, 3},\n\t{2, 4},\n\t{3, 1},\n\t{3, 2},\n\t{3, 3}\n};\n\n// S[Ìzu\nstatic const int g[N][N] = {\n\t{-1, -1,  0, -1, -1},\n\t{-1,  1,  2,  3, -1},\n\t{ 4,  5,  6,  7,  8},\n\t{-1,  9, 10, 11, -1},\n\t{-1, -1,  0, -1, -1}\n};\n\nclass Puzzle\n{\npublic:\n\tint C[N][N], mdist; //manhatta distance\n\tPuzzle(){}\n\t\n\tbool swapAdj( int si, int sj, int ti, int tj )\n\t{\n\t\tif ( ti < 0 || tj < 0 || ti >= N || tj >= N )\n\t\t\treturn false;\n\t\tif ( C[ti][tj] <= 0 )\n\t\t\treturn false;\n\n\t\tswap( C[ti][tj], C[si][sj] );\n\n\t\tint tti = T[C[si][sj]][0];\n\t\tint ttj = T[C[si][sj]][1];\n\t\tmdist -= max(tti, ti)-min(tti, ti) + max(ttj, tj)-min(ttj, tj);\n\t\tmdist += max(tti, si)-min(tti, si) + max(ttj, sj)-min(ttj, sj);\n\t\treturn true;\n\t}\n\t\n\tbool isGoal()\n\t{\n\t\tREP(i, N) REP(j, N)\n\t\t\tif ( g[i][j] != C[i][j] )\n\t\t\t\treturn false;\n\t\treturn true;\n\t}\n\t\n\t// get initial manhattan distance\n\tint getMD()\n\t{\n\t\tint sum = 0;\n\t\tint ti, tj;\n\t\tREP(i, 5) REP(j, 5)\n\t\t{\n\t\t\tif ( C[i][j] <= 0 )\n\t\t\t\tcontinue;\n\t\t\tti = T[C[i][j]][0];\n\t\t\ttj = T[C[i][j]][1];\n\t\t\tsum += (max(ti, i)-min(ti, i) + max(tj, j) - min(tj, j));\n\t\t}\n\t\treturn sum;\n\t}\n};\n \nint limit;\n \nbool dfs( int depth, Puzzle P )\n{\n\tif ( P.isGoal() )\n\t\treturn true;\n\tif ( depth + P.getMD() > limit )\n\t\treturn false;\n\t\n\tstatic const int di[4] = {0, -1, 0, 1};\n\tstatic const int dj[4] = {1, 0, -1, 0};\n\t\n\tREP(i, N) REP(j, N)\n\t{\n\t\tif ( P.C[i][j] != 0 )\n\t\t\tcontinue;\n\n\t\tREP(r, 4)\n\t\t{\n\t\t\tPuzzle v = P;\n\t\t\tif ( !v.swapAdj(i, j, i+di[r], j+dj[r]) )\n\t\t\t\tcontinue;\n\t\t\tif ( dfs( depth + 1, v ) )\n\t\t\t\treturn true;\n\t\t}\n\t}\n\t\n\treturn false;\n}\n\nint idp(Puzzle source)\n{\n\tfor ( limit = 0; limit <= LIMIT; limit++ )\n\t{\n\t\tsource.mdist = source.getMD();\n\t\tif ( dfs(0, source) )\n\t\t\treturn limit;\n\t}\n\treturn INT_MAX;\n}\n\nint main()\n{\n\tPuzzle P;\n\tint top;\n\t\n\twhile(1)\n\t{\n\t\tcin >> top;\n\t\tif ( top == -1 ) break;\n\t\tREP(j, N) P.C[0][j] = -1;\n\t\tP.C[0][2] = top;\n\t\tfor(int i = 1; i < N; i++) REP(j, N)\n\t\t{\n\t\t\tif ( (i == 1 || i == 3) && (j == 0 || j == 4 ) )\n\t\t\t\tP.C[i][j] = -1;\n\t\t\telse if ( i == 4 && j != 2 )\n\t\t\t\tP.C[i][j] = -1;\n\t\t\telse\n\t\t\t\tcin >> P.C[i][j];\n\t\t}\n\t\n\t\tint cost = idp(P);\n\t\t\n\t\tif ( cost == INT_MAX )\n\t\t\tcout << \"NA\" << endl;\n\t\telse\n\t\t\tcout << cost << endl;\t\n\t}\n\t\n\treturn 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include<bits/stdc++.h>\nusing namespace std;\n  \ntypedef long long int64;\nconst int INF = 1 << 30;\n  \nvector< int > edge[13];\nmap< string, int > memo;\n \nbool back(string str, int cnt){ //枝刈り大事だな\n  int X[]={ 2, 1, 2, 3, 0, 1, 2, 3, 4, 1, 2, 3, 2};\n  int Y[]={ 0, 1, 1, 1, 2, 2, 2, 2, 2, 3, 3, 3, 4};\n\n  int diff = 0;\n  for(int i = 0; i < 13; i++){\n   \n    if(str[i] != '0'){\n      int pos = (str[i] >= 'A' ? str[i] - 'A' : str[i] - '0');\n      diff += abs( X[pos] - X[i]) + abs( Y[pos] - Y[i]);\n    }\n  }\n  return diff + cnt > 20;\n}\n \n \nint bfs(string mas){\n \n  queue< string > que;\n  map< string , int > used;\n  que.push( mas );\n  memo[mas] = 0;\n  while(!que.empty()){\n \n    string p = que.front(); que.pop();\n    if(back( p, memo[p])) continue;\n    if(p == \"0123456789AB0\") return memo[p];\n \n    for(int i = 0; i < 13; i++){\n      if(p[i] == '0') {\n        for(int j = 0; j < edge[i].size(); j++){\n          string next = p;\n          swap( next[i], next[edge[i][j]]);\n          if(memo.find(next) != memo.end()) continue;\n          que.push( next );\n          memo[next] = memo[p] + 1;\n        }\n      }\n    }\n  }\n  return -1;\n}\n \nint main(){\n  vector< int > mas(13);\n \n  edge[0].push_back(2);\n  edge[1].push_back(2); edge[1].push_back(4);\n  edge[2].push_back(0); edge[2].push_back(1); edge[2].push_back(3); edge[2].push_back(6);\n  edge[3].push_back(2); edge[3].push_back(7);\n  edge[4].push_back(5);\n  edge[5].push_back(1); edge[5].push_back(4); edge[5].push_back(6); edge[5].push_back(9);\n  edge[6].push_back(2); edge[6].push_back(5); edge[6].push_back(7); edge[6].push_back(10);\n  edge[7].push_back(3); edge[7].push_back(6); edge[7].push_back(8); edge[7].push_back(11);\n  edge[8].push_back(7);\n  edge[9].push_back(5); edge[9].push_back(10);\n  edge[10].push_back(6); edge[10].push_back(9); edge[10].push_back(11); edge[10].push_back(12);\n  edge[11].push_back(7); edge[11].push_back(10);\n  edge[12].push_back(10);\n \n  while(cin >> mas[0], mas[0] != -1){\n    for(int i = 1; i < 13; i++){\n      cin >> mas[i];\n    }\n \n    string start = \"\";\n    for(int i = 0; i < 13; i++){\n      if(mas[i] >= 10) start += (char)(mas[i] - 10 + 'A');\n      else start += mas[i] + '0';\n    }\n    int ret = bfs(start);\n    if(~ret) cout << ret << endl;\n    else cout << \"NA\" << endl;\n \n    memo.clear();\n  }\n}"
  },
  {
    "language": "C++",
    "code": "#include <iostream>\n#include <string>\n#include <sstream>\n#include <map>\n#include <queue>\nusing namespace std;\n\n#define REP(i,n,m) for(int i=n;i<m;i++)\n#define rep(i,n) REP(i,0,n)\n\nclass State{\npublic:\n\tstring s;\n\tint cost;\n\tint idx[2];\n\n\tState(string ts,int tcost,int tidx[]){\n\t\ts = ts;\n\t\tcost = tcost;\n\t\tidx[0] = tidx[0];\n\t\tidx[1] = tidx[1];\n\t}\n};\n\nint di[13][4] = {\n\t{-1,-1,2,-1},\n\t{-1,2,5,-1},\n\t{0,3,6,1},\n\t{-1,-1,7,2},\n\t{-1,5,-1,-1},\n\t{1,6,9,4},\n\t{2,7,10,5},\n\t{3,8,11,6},\n\t{-1,-1,-1,7},\n\t{5,10,-1,-1},\n\t{6,11,12,9},\n\t{7,-1,-1,10},\n\t{10,-1,-1,-1},\n};\n\nvoid printPuzzle(string s){\n\tcout<<\"  \"<<s.substr(0,1)<<endl;\n\tcout<<\" \"<<s.substr(1,3)<<endl;\n\tcout<<s.substr(4,5)<<endl;\n\tcout<<\" \"<<s.substr(9,3)<<endl;\n\tcout<<\"  \"<<s.substr(12,1)<<endl;\n\tcout<<\"----------------------------\\n\";\n}\n\nqueue<State> open;\nmap<string,int> closed,closed2;\n\nint main(void){\n\tstring alpha = \"abcdefghijkl\";\n\tint idx[] = {0,12};\n\n\topen.push(State(\"abcdefghijkla\",0,idx));\n\tclosed.insert(pair<string,int>(\"abcdefghijkla\",0));\n\n\twhile(!open.empty()){\n\t\tState st = open.front(); open.pop();\n\t\tif(st.cost >= 14) continue;\n\n\t\trep(i,2){\n\t\t\trep(j,4){\n\t\t\t\tint to = di[st.idx[i]][j];\n\t\t\t\tif(to == -1) continue;\n\n\t\t\t\tstring res = st.s;\n\t\t\t\tint tmp = res[st.idx[i]];\n\t\t\t\tres[st.idx[i]] = res[to];\n\t\t\t\tres[to] = tmp;\n\n\t\t\t\tif(closed.find(res) == closed.end()){\n\t\t\t\t\tidx[0] = i==0 ? to : st.idx[0];\n\t\t\t\t\tidx[1] = i==1 ? to : st.idx[1];\n\t\t\t\t\topen.push(State(res,st.cost+1,idx));\n\t\t\t\t\tclosed.insert(pair<string,int>(res,st.cost+1));\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t}\n\n\twhile(1){\n\t\tint x;\n\t\tcin>>x;\n\t\tif(x == -1) break;\n\n\t\tstringstream ss;\n\t\tss<<alpha[x];\n\t\trep(i,12){\n\t\t\tcin>>x;\n\t\t\tss<<alpha[x];\n\t\t}\n\n\t\tstring start = ss.str();\n\n\t\twhile(!open.empty()) open.pop();\n\t\tclosed2.clear();\n\n\t\tfor(idx[0]=0;start[idx[0]]!='a';idx[0]++);\n\t\tfor(idx[1]=start.length()-1;start[idx[1]]!='a';idx[1]--);\n\t\topen.push(State(start,0,idx));\n\t\tclosed2.insert(pair<string,int>(start,0));\n\n\t\tint ans = -1;\n\n\t\twhile(!open.empty()){\n\t\t\tState st = open.front(); open.pop();\n\t\t\tif(closed.find(st.s) != closed.end() && st.cost + closed[st.s] <= 20){\n\t\t\t\tans = st.cost + closed[st.s];\n\t\t\t\tbreak;\n\t\t\t}\n\t\t\tif(st.cost >= 7) continue;\n\n\t\t\trep(i,2){\n\t\t\t\trep(j,4){\n\t\t\t\t\tint to = di[st.idx[i]][j];\n\t\t\t\t\tif(to == -1) continue;\n\n\t\t\t\t\tstring res = st.s;\n\t\t\t\t\tint tmp = res[st.idx[i]];\n\t\t\t\t\tres[st.idx[i]] = res[to];\n\t\t\t\t\tres[to] = tmp;\n\n\t\t\t\t\tif(closed2.find(res) == closed2.end()){\n\t\t\t\t\t\tidx[0] = i==0 ? to : st.idx[0];\n\t\t\t\t\t\tidx[1] = i==1 ? to : st.idx[1];\n\t\t\t\t\t\topen.push(State(res,st.cost+1,idx));\n\t\t\t\t\t\tclosed2.insert(pair<string,int>(res,st.cost+1));\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\n\t\tif(ans == -1) cout<<\"NA\\n\";\n\t\telse cout<<ans<<endl;\n\t}\n\n\treturn 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include <iostream>\n#include <vector>\nusing namespace std;\n\ntypedef vector <int> VI;\ntypedef vector <VI> VVI;\n\nVVI goal;\nVVI init;\n\nint limit;\n\nconst int di[4] = { 0, 0, 1, -1 };\nconst int dj[4] = { 1, -1, 0, 0 };\n\nconst int T[12][2] = {\n\t{ 0, 0 },\n\t{ 1+1, 1+1 },\n\t{ 1+1, 2+1 },\n\t{ 1+1, 3+1 },\n\t{ 2+1, 0+1 },\n\t{ 2+1, 1+1 },\n\t{ 2+1, 2+1 },\n\t{ 2+1, 3+1 },\n\t{ 2+1, 4+1 },\n\t{ 3+1, 1+1 },\n\t{ 3+1, 2+1 },\n\t{ 3+1, 3+1 }\n};\n\nint getMD( VVI P )\n{\n\tint sum = 0;\n\tint ti, tj;\n\tfor ( int i = 0; i < 7; i++ )\n\t{\n\t\tfor ( int j = 0; j < 7; j++ )\n\t\t{\n\t\t\tif ( P[j][i] <= 0 )\n\t\t\t\tcontinue;\n\n\t\t\tti = T[P[j][i]][0];\n\t\t\ttj = T[P[j][i]][1];\n\t\t\tsum += max( ti, i ) - min( ti, i ) + max( tj, j ) - min( tj, j );\n\t\t}\n\t}\n\treturn sum;\n}\n\nbool is_goal( VVI puzzle )\n{\n\tbool ok = true;\n\tfor ( int i = 0; ok && i < 7; i++ ) for ( int j = 0; ok && j < 7; j++ )\n\t{\n\t\tif ( puzzle[j][i] != goal[j][i] )\n\t\t\tok = false;\n\t}\n\treturn ok;\n}\n\nbool dfs( int depth, VVI now )\n{\n\tif ( is_goal( now ) )\n\t\treturn true;\n\n\tif ( depth + getMD( now ) > limit )\n\t\treturn false;\n\n\tfor ( int i = 0; i < 7; i++ )\n\t{\n\t\tfor ( int j = 0; j < 7; j++ )\n\t\t{\n\t\t\tif ( now[j][i] <= 0 )\n\t\t\t\tcontinue;\n\n\t\t\tfor ( int k = 0; k < 4; k++ )\n\t\t\t{\n\t\t\t\tVVI v = now;\n\t\t\t\tint ni = i + di[k];\n\t\t\t\tint nj = j + dj[k];\n\n\t\t\t\tif ( v[nj][ni] <= 0 )\n\t\t\t\t\tcontinue;\n\n\t\t\t\tswap( v[j][i], v[nj][ni] );\n\n\t\t\t\tif ( dfs( depth+1, v ) )\n\t\t\t\t\treturn true;\n\n\t\t\t}\n\t\t}\n\t}\n\n}\n\nint idfs( VVI src )\n{\n\tfor ( limit = 0; limit <= 20; limit++ )\n\t{\n\t\tif ( dfs( 0, src ) )\n\t\t\treturn limit;\n\t}\n\treturn -1;\n}\n\nint main( void )\n{\n\t// S[ÌóÔðìé\n\tgoal = VVI( 7, VI( 7, -1 ) );\n\tgoal[3][1] = 0;\n\tgoal[3][5] = 0;\n\tfor ( int i = 0; i < 3; i++ )\n\t{\n\t\tgoal[2+i][2] = 1+i;\n\t\tgoal[2+i][4] = 9+i;\n\t}\n\tfor ( int i = 0; i < 5; i++ )\n\t{\n\t\tgoal[1+i][3] = 4+i;\n\t}\n\n\twhile ( 1 )\n\t{\n\t\t// úóÔÌüÍ\n\t\tinit = VVI( 7, VI( 7, -1 ) );\n\t\tcin >> init[3][1];\n\t\tif ( init[3][1] == -1 )\n\t\t\tbreak;\n\t\tfor ( int i = 0; i < 3; i++ )\n\t\t\tcin >> init[2+i][2];\n\t\tfor ( int i = 0; i < 5; i++ )\n\t\t\tcin >> init[1+i][3];\n\t\tfor ( int i = 0; i < 3; i++ )\n\t\t\tcin >> init[2+i][4];\n\t\tcin >> init[3][5];\n\n\t\tint cost = idfs( init );\n\n\t\tif ( cost == -1 )\n\t\t\tcout << \"NA\" << endl;\n\t\telse\n\t\t\tcout << cost << endl;\n\n\t}\n\n\treturn 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include <iostream>\n#include <queue>\n#include <map>\nusing namespace std;\n\nunsigned long long int makeID( int (&p)[ 13 ] )\n{\n\tunsigned long long int ret = 0;\n\tfor( int i = 0; i < 13; ++i ){\n\t\tret *= 13;\n\t\tret += p[ i ];\n\t}\n\treturn ret;\n}\n\nunsigned long long int slide( unsigned long long int s, int a, int b )\n{\n\tint p[ 13 ];\n\tfor( int i = 0; i < 13; ++i ){\n\t\tp[ 12 - i ] = s % 13;\n\t\ts /= 13;\n\t}\n\tint t = p[ a ];\n\tp[ a ] = p[ b ];\n\tp[ b ] = t;\n\treturn makeID( p );\n}\n\nint main()\n{\n\tmap< unsigned long long int, int > ans;\n\tqueue< unsigned long long int > q;\n\n\tint side[][ 4 ] = {\n\t\t{ -1, -1,  2, -1 },\n\t\t{ -1,  2,  5, -1 },\n\t\t{  0,  3,  6,  1 },\n\t\t{ -1, -1,  7,  2 },\n\t\t{ -1,  5, -1, -1 },\n\t\t{  1,  6,  9,  4 },\n\t\t{  2,  7, 10,  5 },\n\t\t{  3,  8, 11,  6 },\n\t\t{ -1, -1, -1,  7 },\n\t\t{  5, 10, -1, -1,},\n\t\t{  6, 11, 12,  9 },\n\t\t{  7, -1, -1, 10 },\n\t\t{ 10, -1, -1, -1 }\n\t};\n\n\tint p[ 13 ];\n\tfor( int i = 0; i < 13; ++i ){\n\t\tp[ i ] = i;\n\t}\n\tp[ 12 ] = 0;\n\tunsigned long long int s = makeID( p );\n\tans[ s ] = 0;\n\tq.push( s );\n\n\tint cnt = 1;\n\twhile( cnt < 20 ){\n\t\tint size = q.size();\n\t\tfor( int i = 0; i < size; ++i ){\n\t\t\ts = q.front();\n\t\t\tq.pop();\n\t\t\tint pos[ 2 ], a = 0;\n\t\t\tunsigned long long int t = s;\n\t\t\tfor( int j = 0; j < 13; ++j ){\n\t\t\t\tint b = t % 13;\n\t\t\t\tif( b == 0 ) pos[ a++ ] = 12 - j;\n\t\t\t\tt /= 13;\n\t\t\t}\n\t\t\tfor( int j = 0; j < 2; ++j ){\n\t\t\t\tint b = pos[ j ];\n\t\t\t\tfor( int k = 0; k < 4; ++k ){\n\t\t\t\t\tint c = side[ b ][ k ];\n\t\t\t\t\tif( c == -1 ) continue;\n\t\t\t\t\tt = slide( s, b, c );\n\t\t\t\t\tif( ans.find( t ) == ans.end() ){\n\t\t\t\t\t\tans[ t ] = cnt;\n\t\t\t\t\t\tq.push( t );\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t\t++cnt;\n\t}\n\twhile( !q.empty() ){\n\t\ts = q.front();\n\t\tq.pop();\n\t\tans[ s ] = 20;\n\t}\n\n\twhile( cin >> p[ 0 ] && p [ 0 ] != -1 ){\n\t\tfor( int i = 1; i < 13; ++i ){\n\t\t\tcin >> p[ i ];\n\t\t}\n\t\ts = makeID( p );\n\t\tif( ans.find( s ) != ans.end() ){\n\t\t\tcout << ans[ s ] << endl;\n\t\t}else{\n\t\t\tcout << \"NA\" << endl;\n\t\t}\n\t}\n\n\treturn 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include <iostream>\n#include <iomanip>\n#include <vector>\n#include <map>\n#include <set>\n#include <queue>\nusing namespace std;\n\n#define NONE -1\n\n// »ÝÌóÔ\nvector < vector <int> > F( 5, vector <int>(5,NONE) );\n// S[\nvector < vector <int> > GOAL( 5, vector <int>(5,NONE) );\n// KâÏÝ\nset < vector < vector <int> > > V;\n// ó«Ìê\nint empty_x[2];\nint empty_y[2];\nint now;\n\nint abs( int n )\n{\n\tif ( n < 0 )\n\t\treturn -n;\n\treturn n;\n}\n\nint getMD()\n{\n\tint md = 0;\n\tfor ( int i = 0; i < 5; i++ ) for ( int j = 0; j < 5; j++ )\n\t{\n\t\tif ( F[i][j] != GOAL[i][j] )\n\t\t{\n\t\t\t// T·\n\t\t\tbool found = false;\n\t\t\tfor ( int k = 0; k < 5; k++ )\n\t\t\t{\n\t\t\t\tfor ( int m = 0; m < 5; m++ )\n\t\t\t\t{\n\t\t\t\t\t//  Á½\n\t\t\t\t\tif ( F[i][j] == GOAL[k][m] )\n\t\t\t\t\t{\n\t\t\t\t\t\tmd += abs(k-i) + abs(m-j);\n\t\t\t\t\t\tfound = true;\n\t\t\t\t\t\tbreak;\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t\tif ( found ) break;\n\t\t\t}\n\t\t}\n\t}\n\treturn md;\n}\n\nbool search( int depth )\n{\n\tif ( F == GOAL )\n\t\treturn true;\n\tif ( now + getMD() > depth )\n\t\treturn false;\n\n\tnow++;\n\tfor ( int e = 0; e < 2; e++ ) for ( int i = -1; i < 2; i++ ) for ( int j = -1; j < 2; j++ )\n\t{\n\t\tif ( i+j == 1 || i+j == -1 )\n\t\t{\n\t\t\tint ox = empty_x[e];\n\t\t\tint oy = empty_y[e];\n\t\t\tint tx = empty_x[e] + i;\n\t\t\tint ty = empty_y[e] + j;\n\n\t\t\tif ( ( tx >= 0 && tx <= 4 ) && ( ty >= 0 && ty <= 4 ) )\n\t\t\t{\n\t\t\t\tif ( F[ty][tx] != 0 && F[ty][tx] != NONE )\n\t\t\t\t{\n\t\t\t\t\t// ®©·\n\t\t\t\t\tswap( F[oy][ox], F[ty][tx] );\n\n\t\t\t\t\t// ¢JÌnÅ éÈçÎ\n\t\t\t\t\tif ( V.find( F ) == V.end() )\n\t\t\t\t\t{\n\t\t\t\t\t\tif ( search( depth ) )\n\t\t\t\t\t\t\treturn true;\n\t\t\t\t\t}\n\n\t\t\t\t\t// ß·\n\t\t\t\t\tswap( F[oy][ox], F[ty][tx] );\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t}\n\tnow--;\n\n}\n\nint main( void )\n{\n\twhile ( 1 )\n\t{\n\t\t// S[ðìé\n\t\tGOAL[0][2] = 0;\n\t\tfor ( int i = 0; i < 3; i++ )\n\t\t\tGOAL[1][1+i] = i+1;\n\t\tfor ( int i = 0; i < 5; i++ )\n\t\t\tGOAL[2][i] = 4 + i;\n\t\tfor ( int i = 0; i < 3; i++ )\n\t\t\tGOAL[3][1+i] = 9 + i;\n\t\tGOAL[4][2] = 0;\n\n\t\t// üÍ\n\t\tcin >> F[0][2];\n\t\tif ( F[0][2] == -1 )\n\t\t\tbreak;\n\t\tfor ( int i = 0; i < 3; i++ )\n\t\t\tcin >> F[1][1+i];\n\t\tfor ( int i = 0; i < 5; i++ )\n\t\t\tcin >> F[2][i];\n\t\tfor ( int i = 0; i < 3; i++ )\n\t\t\tcin >> F[3][1+i];\n\t\tcin >> F[4][2];\n\n\t\t// óðT·\n\t\tint empty_count = 0;\n\t\tfor ( int i = 0; i < 5; i++ )\n\t\t{\n\t\t\tfor ( int j = 0; j < 5; j++ )\n\t\t\t{\n\t\t\t\tif ( F[i][j] == 0 )\n\t\t\t\t{\n\t\t\t\t\tempty_x[empty_count] = j;\n\t\t\t\t\tempty_y[empty_count] = i;\n\t\t\t\t\tempty_count++;\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\n\t\t// ½[»[³DæTõ\n\t\tV.insert( F );\n\t\tnow = 0;\n\t\tbool goal_flag = false;\n\t\tfor ( int i = 0; i <= 20; i++ )\n\t\t{\n\t\t\tif ( search( i ) )\n\t\t\t{\n\t\t\t\tgoal_flag = true;\n\t\t\t\tbreak;\n\t\t\t}\n\t\t}\n\n\t\tif ( goal_flag )\n\t\t\tcout << now << endl;\n\t\telse\n\t\t\tcout << \"NA\" << endl;\n\n\t}\n\treturn 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include<iostream>\n#include<map>\n#include<deque>\n#include<cstring>\n#include<cstdlib>\nusing namespace std;\nstruct board{\n\tchar s[14];\n\tint z1,z2;\n\tbool operator<(const board& rhs)const{return strcmp(s,rhs.s)<0;}\n};\nint main(){\n\tint d[13][5]={\n\t\t{2,-1},\t\t\t//0\n\t\t{2,5,-1},\t\t//1\n\t\t{0,1,3,6,-1},\t//2\n\t\t{2,7,-1},\t\t//3\n\t\t{5,-1},\t\t\t//4\n\t\t{1,4,6,9,-1},\t//5\n\t\t{2,5,7,10,-1},\t//6\n\t\t{3,6,8,11,-1},\t//7\n\t\t{7,-1},\t\t\t//8\n\t\t{5,10,-1},\t\t//9\n\t\t{6,9,11,12,-1},\t//10\n\t\t{7,10,-1},\t\t//11\n\t\t{10,-1},\t\t//12\n\t};\n\tint gx[]={2,1,2,3,0,1,2,3,4,1,2,3,2};\n\tint gy[]={0,1,1,1,2,2,2,2,2,3,3,3,4};\n\tboard goal;\n\tstrcpy(goal.s,\"0123456789:;0\");\n\tfor(;;){\n\t\ttypedef map<board,int>SM;\n\t\tSM stepmap;\n\t\tdeque<board> que;\n\t\tboard b0;\n\t\tb0.z1=b0.z2=-1;\n\t\tfor(int i=0;i<13;i++){\n\t\t\tint v;\n\t\t\tcin>>v;\n\t\t\tif(v==-1)\n\t\t\t\treturn 0;\n\t\t\tb0.s[i]='0'+v;\n\t\t\tif(v==0){\n\t\t\t\tif(b0.z1==-1)\n\t\t\t\t\tb0.z1=i;\n\t\t\t\telse\n\t\t\t\t\tb0.z2=i;\n\t\t\t}\n\t\t}\n\t\tb0.s[13]=0;\n\t\tque.push_back(b0);\n\t\tstepmap[b0]=1;\n\t\twhile(!que.empty()){\n\t\t\tboard b=que.front();\n\t\t\tif(strcmp(b.s,goal.s)==0){\n\t\t\t\tbreak;\n\t\t\t}\n\t\t\tque.pop_front();\n\t\t\tint dist=0;\n\t\t\tfor(int i=0;i<13;i++){\n\t\t\t\tint v=b.s[i]-'0';\n\t\t\t\tif(v){\n\t\t\t\t\tdist+=abs(gx[v]-gx[i])+abs(gy[v]-gy[i]);\n\t\t\t\t}\n\t\t\t}\n\t\t\tif(dist<=20){\n\t\t\t\tint step=stepmap[b];\n\t\t\t\tif(step<=20){\n\t\t\t\t\tfor(int i=0;d[b.z1][i]!=-1;i++){\n\t\t\t\t\t\tboard bn=b;\n\t\t\t\t\t\tbn.z1=d[b.z1][i];\n\t\t\t\t\t\tif(bn.z1!=bn.z2){\n\t\t\t\t\t\t\tswap(bn.s[b.z1],bn.s[bn.z1]);\n\t\t\t\t\t\t\tint&ns=stepmap[bn];\n\t\t\t\t\t\t\tif(!ns){\n\t\t\t\t\t\t\t\tns=step+1;\n\t\t\t\t\t\t\t\tque.push_back(bn);\n\t\t\t\t\t\t\t}\n\t\t\t\t\t\t}\n\t\t\t\t\t}\n\t\t\t\t\tfor(int i=0;d[b.z2][i]!=-1;i++){\n\t\t\t\t\t\tboard bn=b;\n\t\t\t\t\t\tbn.z2=d[b.z2][i];\n\t\t\t\t\t\tif(bn.z2!=bn.z1){\n\t\t\t\t\t\t\tswap(bn.s[b.z2],bn.s[bn.z2]);\n\t\t\t\t\t\t\tint&ns=stepmap[bn];\n\t\t\t\t\t\t\tif(!ns){\n\t\t\t\t\t\t\t\tns=step+1;\n\t\t\t\t\t\t\t\tque.push_back(bn);\n\t\t\t\t\t\t\t}\n\t\t\t\t\t\t}\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t\tif(stepmap[goal]==0)\n\t\t\tcout<<\"NA \"<<endl;\n\t\telse\n\t\t\tcout<<stepmap[goal]-1<<endl;\n\t}\n}"
  },
  {
    "language": "C++",
    "code": "#include<iostream>\n#include<algorithm>\n#include<vector>\n#include<queue>\n#include<unordered_map>\n#define lol(i,n) for(int i=0;i<n;i++)\n#define mod 1000000007\ntypedef long long ll;\nusing namespace std;\nint dx[13][4]={\n  {3,0,0,0},\n  {3,6,0,0},\n  {1,2,4,6},\n  {3,8,0,0},\n  {6,0,0,0},\n  {2,5,7,10},\n  {3,6,8,11},\n  {4,7,9,12},\n  {8,0,0,0},\n  {6,11,0,0},\n  {6,10,12,13},\n  {8,11,0,0},\n  {11,0,0,0}\n};\nunordered_map<ll,int> mp;\nll Compress(int p[]){\n  ll ans=0;\n  for(int i=0;i<13;i++){\n    ans*=13;\n    ans+=p[i];\n  }\n  return ans;\n}\n\nint unzip[13];\nvoid Unzip(ll x){\n  for(int i=0;i<13;i++){\n    unzip[12-i]=x%13;\n    x/=13;\n  }\n}\n\nint beflen=0;\nqueue<pair<ll,int> >Q;\nvoid BFS(int p[],int len){\n  //if(len!=beflen){cout<<len<<endl;beflen=len;}\n  ll tmp=Compress(p);\n  mp[tmp]=len;\n  if(len==17)return;\n  lol(i,13){\n    if(p[i]==0){\n      lol(j,4){\n\tint t=dx[i][j];\n\tif(t==0)break;\n\tt--;\n\tif(p[t]!=0){\n\t  swap(p[i],p[t]);\n\t  tmp=Compress(p);\n\t  if(mp[tmp]!=0)continue;\n\t  mp[tmp]=-1;\n\t  Q.push(make_pair(tmp,len+1));\n\t  swap(p[i],p[t]);\n\t}\n      }\n    }\n  }\n}\n\nint ans;\nvoid EFS(int p[],int len){\n  //if(len!=beflen){cout<<len<<endl;beflen=len;}\n  ll tmp=Compress(p);\n  if(mp[tmp]>0){\n    ans=min(ans,len+mp[tmp]);\n    return;\n  }\n  if(len==5)return;\n  lol(i,13){\n    if(p[i]==0){\n      lol(j,4){\n\tint t=dx[i][j];\n\tif(t==0)break;\n\tt--;\n\tif(p[t]!=0){\n\t  swap(p[i],p[t]);\n\t  tmp=Compress(p);\n\t  Q.push(make_pair(tmp,len+1));\n\t  swap(p[i],p[t]);\n\t}\n      }\n    }\n  }\n}\nint main(){\n  int p[13];\n  lol(i,13)p[i]=i;p[12]=0;\n  Q.push(make_pair(Compress(p),1));\n  while(!Q.empty()){\n    ll data=Q.front().first;\n    int len=Q.front().second;\n    Q.pop();\n    if(mp[data]>0)continue;\n    Unzip(data);\n    BFS(unzip,len);\n  }\n  while(cin>>p[0]&&p[0]!=-1){\n    for(int i=1;i<13;i++)cin>>p[i];\n    ans=mod;\n    Q.push(make_pair(Compress(p),0));\n    while(!Q.empty()){\n      ll data=Q.front().first;\n      int len=Q.front().second;\n      Q.pop();\n      Unzip(data);\n      EFS(unzip,len);\n    }\n    if(ans==mod)cout<<\"NA\"<<endl;\n    else cout<<ans-1<<endl;\n  }\n  return 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\nusing namespace std;\n\nconst int INF = 1<<28;\nconst int H = 5;\nconst int W = 5;\n\nstruct State {\n  int g[H][W];\n  int x[2], y[2];\n  bool operator < (const State &s) const {\n    for(int i = 0; i < H; ++i) {\n      for(int j = abs(2-i); j < W-abs(2-i); ++j) {\n        if(g[i][j] != s.g[i][j]) return g[i][j] < s.g[i][j];\n      }\n    }\n    return false;\n  }\n  bool operator == (const State &s) const {\n    return !(*this < s) && !(s < *this);\n  }\n};\n\nmap<State,int> bfs1(State src) {\n  const static int dx[4] = {1,0,-1,0};\n  const static int dy[4] = {0,1,0,-1};\n  map<State,int> cost;\n  queue<State> que;\n  cost[src] = 0;\n  que.push(src);\n  while(que.size()) {\n    const State s = que.front();\n    que.pop();\n    if(cost[s] == 11) continue;\n    for(int k = 0; k < 2; ++k) {\n      for(int i = 0; i < 4; ++i) {\n        int nx = s.x[k] + dx[i];\n        int ny = s.y[k] + dy[i];\n        if(nx < 0 || nx >= W) continue;\n        if(ny < 0 || ny >= H) continue;\n        if(s.g[ny][nx] <= 0) continue;\n        State t = s;\n        swap(t.g[t.y[k]][t.x[k]], t.g[ny][nx]);\n        t.x[k] = nx;\n        t.y[k] = ny;\n        if(cost.count(t)) continue;\n        cost[t] = cost[s] + 1;\n        que.push(t);\n      }\n    }\n  }\n  return cost;\n}\n\nint bfs2(State src, map<State,int> rcost) {\n  const static int dx[4] = {1,0,-1,0};\n  const static int dy[4] = {0,1,0,-1};\n  if(rcost.count(src)) return rcost[src];\n  map<State,int> cost;\n  queue<State> que;\n  cost[src] = 0;\n  que.push(src);\n  int res = INF;\n  while(que.size()) {\n    const State s = que.front();\n    que.pop();\n    if(cost[s] == 11) continue;\n    for(int k = 0; k < 2; ++k) {\n      for(int i = 0; i < 4; ++i) {\n        int nx = s.x[k] + dx[i];\n        int ny = s.y[k] + dy[i];\n        if(nx < 0 || nx >= W) continue;\n        if(ny < 0 || ny >= H) continue;\n        if(s.g[ny][nx] <= 0) continue;\n        State t = s;\n        swap(t.g[t.y[k]][t.x[k]], t.g[ny][nx]);\n        t.x[k] = nx;\n        t.y[k] = ny;\n        if(cost.count(t)) continue;\n        cost[t] = cost[s] + 1;\n        que.push(t);\n        if(rcost.count(t)) {\n          res = min(res, cost[t] + rcost[t]);\n        }\n      }\n    }\n  }\n  return res;\n}\n\nint main() {\n  State src, dst;\n  fill(src.g[0], src.g[H], -1);\n  fill(dst.g[0], dst.g[H], -1);\n  for(int i = 0, k = 0, t = 0; i < H; ++i) {\n    for(int j = abs(2-i); j < W-abs(2-i); ++j) {\n      dst.g[i][j] = t % 12;\n      ++t;\n      if(dst.g[i][j] == 0) {\n        dst.x[k] = j;\n        dst.y[k] = j;\n        ++k;\n      }\n    }\n  }\n  const map<State,int> rcost = bfs1(dst);\n  while(1) {\n    for(int i = 0, k = 0; i < H; ++i) {\n      for(int j = abs(2-i); j < W-abs(2-i); ++j) {\n        cin >> src.g[i][j];\n        if(src.g[i][j] == -1) return 0;\n        if(src.g[i][j] == 0) {\n          src.x[k] = j;\n          src.y[k] = i;\n          ++k;\n        }\n      }\n    }\n    int res = bfs2(src, rcost);\n    if(res > 20) cout << \"NA\" << endl;\n    else cout << res << endl;\n  }\n  return 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include<iostream>\n#include<map>\n#include<deque>\nusing namespace std;\nstruct board{\n\tchar s[14];\n\tint z1,z2;\n\tbool operator<(const board& rhs)const{return strcmp(s,rhs.s)<0;}\n};\nint main(){\n\tint d[13][5]={\n\t\t{2,-1},\t\t\t//0\n\t\t{2,5,-1},\t\t//1\n\t\t{0,1,3,6,-1},\t//2\n\t\t{2,7,-1},\t\t//3\n\t\t{5,-1},\t\t\t//4\n\t\t{1,4,6,9,-1},\t//5\n\t\t{2,5,7,10,-1},\t//6\n\t\t{3,6,8,11,-1},\t//7\n\t\t{7,-1},\t\t\t//8\n\t\t{5,10,-1},\t\t//9\n\t\t{6,9,11,12,-1},\t//10\n\t\t{7,10,-1},\t\t//11\n\t\t{10,-1},\t\t//12\n\t};\n\tboard goal;\n\tstrcpy(goal.s,\"0123456789AB0\");\n\tfor(;;){\n\t\ttypedef map<board,int>SM;\n\t\tSM stepmap;\n\t\tdeque<board> que;\n\t\tboard b0;\n\t\tb0.z1=b0.z2=-1;\n\t\tint dist=0;\n\t\tfor(int i=0;i<13;i++){\n\t\t\tint v;\n\t\t\tcin>>v;\n\t\t\tif(v==-1)\n\t\t\t\treturn 0;\n\t\t\tb0.s[i]=\"0123456789AB\"[v];\n\t\t\tif(v==0){\n\t\t\t\tif(b0.z1==-1)\n\t\t\t\t\tb0.z1=i;\n\t\t\t\telse\n\t\t\t\t\tb0.z2=i;\n\t\t\t}else{\n\t\t\t\tstatic int x[]={2,1,2,3,0,1,2,3,4,1,2,3,2};\n\t\t\t\tstatic int y[]={0,1,1,1,2,2,2,2,2,3,3,3,4};\n\t\t\t\tdist+=abs(x[v]-x[i])+abs(y[v]-y[i]);\n\t\t\t}\n\t\t}\n\t\tb0.s[13]=0;\n\t\tque.push_back(b0);\n\t\tstepmap[b0]=1;\n\t\tif(dist<=20){\n\t\t\twhile(!que.empty()){\n\t\t\t\tboard b=que.front();\n\t\t\t\tif(strcmp(b.s,goal.s)==0){\n\t\t\t\t\tbreak;\n\t\t\t\t}\n\t\t\t\tque.pop_front();\n\t\t\t\tint step=stepmap[b];\n\t\t\t\tif(step<=20){\n\t\t\t\t\tfor(int i=0;d[b.z1][i]!=-1;i++){\n\t\t\t\t\t\tboard bn=b;\n\t\t\t\t\t\tbn.z1=d[b.z1][i];\n\t\t\t\t\t\tif(bn.z1!=bn.z2){\n\t\t\t\t\t\t\tswap(bn.s[b.z1],bn.s[bn.z1]);\n\t\t\t\t\t\t\tint&ns=stepmap[bn];\n\t\t\t\t\t\t\tif(!ns){\n\t\t\t\t\t\t\t\tns=step+1;\n\t\t\t\t\t\t\t\tque.push_back(bn);\n\t\t\t\t\t\t\t}\n\t\t\t\t\t\t}\n\t\t\t\t\t}\n\t\t\t\t\tfor(int i=0;d[b.z2][i]!=-1;i++){\n\t\t\t\t\t\tboard bn=b;\n\t\t\t\t\t\tbn.z2=d[b.z2][i];\n\t\t\t\t\t\tif(bn.z2!=bn.z1){\n\t\t\t\t\t\t\tswap(bn.s[b.z2],bn.s[bn.z2]);\n\t\t\t\t\t\t\tint&ns=stepmap[bn];\n\t\t\t\t\t\t\tif(!ns){\n\t\t\t\t\t\t\t\tns=step+1;\n\t\t\t\t\t\t\t\tque.push_back(bn);\n\t\t\t\t\t\t\t}\n\t\t\t\t\t\t}\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t\tif(stepmap[goal]==0)\n\t\t\tcout<<\"NA \"<<endl;\n\t\telse\n\t\t\tcout<<stepmap[goal]-1<<endl;\n\t}\n}"
  },
  {
    "language": "C++",
    "code": "#include <iostream>\n#include <sstream>\n#include <string>\n#include <algorithm>\n#include <vector>\n#include <stack>\n#include <queue>\n#include <set>\n#include <map>\n#include <cstdio>\n#include <cstdlib>\n#include <cstring>\n#include <cmath>\n\nusing namespace std;\n\n#define FOR(i,k,n) for(int i=(k); i<(int)n; ++i)\n#define REP(i,n) FOR(i,0,n)\n#define FORIT(i,c) for(__typeof((c).begin())i=(c).begin();i!=(c).end();++i)\n\nstruct S{\n  vector<int> p;\n  int t;\n  S(vector<int> p, int t) : p(p),t(t) {}\n};\n\nbool operator<(const S& s, const S& t){\n  return s.t > t.t;\n}\n\nset<S> memo;\nvector<int> goal(13);\nint bfs(S start){\n  priority_queue<S> que;\n  que.push(start);\n  while(!que.empty()){\n    S s = que.top(); que.pop();\n    if(s.t > 20) return -1;\n    if(s.p == goal) return s.t;\n    if(memo.find(s)!=memo.end()) continue;\n    memo.insert(s);\n    REP(i,13){\n      vector<int> tmp = s.p;\n      if(s.p[i]==0){\n        switch(i){\n          case 0:\n          case 2:\n            swap(tmp[0],tmp[2]);\n            que.push(S(tmp,s.t+1));\n            break;\n          case 12:\n          case 10:\n            swap(tmp[12],tmp[10]);\n            que.push(S(tmp,s.t+1));\n            break;\n          case 4:\n          case 5:\n            swap(tmp[4],tmp[5]);\n            que.push(S(tmp,s.t+1));\n            break;\n          case 8:\n          case 7:\n            swap(tmp[8],tmp[7]);\n            que.push(S(tmp,s.t+1));\n            break;\n        }\n        if(i % 4 == 2 || i % 4 == 3){\n          tmp = s.p;\n          swap(tmp[i],tmp[i-1]);\n          que.push(S(tmp,s.t+1));\n        }\n        if(i % 4 == 1 || i % 4 == 2){\n          tmp = s.p;\n          swap(tmp[i],tmp[i+1]);\n          que.push(S(tmp,s.t+1));\n        }\n        if(i % 4 != 0 && i < 8){\n          tmp = s.p;\n          swap(tmp[i],tmp[i+4]);\n          que.push(S(tmp,s.t+1));\n        }\n        if(i % 4 != 0 && i > 4){\n          tmp = s.p;\n          swap(tmp[i],tmp[i-4]);\n          que.push(S(tmp,s.t+1));\n        }\n      }\n    }\n  }\n}\nint main(){\n  int n;\n  vector<int> p(13);\n\n  REP(i,11) goal[i+1] = i+1;\n\n  while(cin>>p[0], p[0]!=-1){\n    for(int i = 1; i < 13; i++){\n      cin>>p[i];\n    }\n    S start(p,0);\n    memo.clear();\n    int ans = bfs(start);\n    if(ans == -1)cout<<\"NA\"<<endl;\n    else cout<< ans << endl;\n  }\n  return 0;\n}"
  },
  {
    "language": "C++",
    "code": "#define _USE_MATH_DEFINES\n#define INF 10000000\n#include <iostream>\n#include <sstream>\n#include <cstdio>\n#include <cmath>\n#include <algorithm>\n#include <queue>\n#include <stack>\n#include <limits>\n#include <map>\n#include <string>\n#include <cstring>\n#include <set>\n#include <deque>\n#include <bitset>\n#include <list>\n\nusing namespace std;\n\ntypedef long long ll;\ntypedef pair<int,string> P;\n\nstatic const double eps = 1e-8;\n\nint main(){\n  int a,b;\n  while(~scanf(\"%d %d\",&a,&b)){\n    printf(\"%d\\n\",abs(a-b));\n  }\n}"
  },
  {
    "language": "C++",
    "code": "#include <iostream>\n#include <algorithm>\n#include <vector>\n#include <cstring>\n#include <cstdio>\n#include <climits>\n\nusing namespace std;\n\n\n#define REP(i,a,n) for(int i=(a); i<(int)(n); i++)\n#define rep(i,n) REP(i,0,n)\n#define DEB 0\n\nint board[7][7]; //1base\nint sx[2], sy[2];\nstatic const int dx[] = {0,0,1,-1};\nstatic const int dy[] = {1,-1,0,0};\n\nint calc(int y, int x){\n    switch(board[y][x]){\n    case 1: return abs(2-y)+abs(2-x);\n    case 2: return abs(2-y)+abs(3-x);\n    case 3: return abs(2-y)+abs(4-x);\n    case 4: return abs(3-y)+abs(1-x);\n    case 5: return abs(3-y)+abs(2-x);\n    case 6: return abs(3-y)+abs(3-x);\n    case 7: return abs(3-y)+abs(4-x);\n    case 8: return abs(3-y)+abs(5-x);\n    case 9: return abs(4-y)+abs(2-x);\n    case 10: return abs(4-y)+abs(3-x);\n    case 11: return abs(4-y)+abs(4-x);\n    }\n    return -1;\n}\nint dist(void){\n    int ret = 0;\n    if( board[1][3] ) ret += calc(1,3);\n    rep(i,3) if( board[2][2+i] ) ret += calc(2,2+i);\n    rep(i,5) if( board[3][1+i] ) ret += calc(3,1+i);\n    rep(i,3) if( board[4][2+i] ) ret += calc(4,2+i);\n    if( board[5][3] ) ret += calc(5,3);\n    return ret;\n}\nbool isgoal(void){\n    if( board[1][3]!=0 ) return false;\n    rep(i,3) if( board[2][2+i]!=i+1 ) return false;\n    rep(i,5) if( board[3][1+i]!=i+4 ) return false;\n    rep(i,3) if( board[4][2+i]!=i+9 ) return false;\n    if( board[5][3]!=0 ) return false;\n    return true;\n}\n\nbool dfs(int cnt, int LIM, int py, int px, const vector<pair<int,int> > sp){\n    if( isgoal() ) return true;\n    if( cnt+dist()>LIM ) return false;\n\n    rep(i,2){\n        if( board[sp[i].second][sp[i].first]!=0 ) exit(-1);\n        rep(k,4){\n            int tx = sp[i].first + dx[k];\n            int ty = sp[i].second + dy[k];\n            if( board[ty][tx]<=0 ) continue;\n\n            swap(board[sp[i].second][sp[i].first], board[ty][tx]);\n\n            vector<pair<int,int> > v = sp;\n            pair<int,int> tmp(tx,ty);\n            swap(v[i], tmp);\n            if( dfs(cnt+1, LIM, ty, tx, v) ) return true;\n\n            swap(board[sp[i].second][sp[i].first] ,board[ty][tx]);\n        }\n    }\n    return false;\n}\nint solve(void){\n    int ttx[2], tty[2];\n    int tb[7][7];\n    vector<pair<int,int> > sp;\n    rep(i,2) sp.push_back(make_pair(sx[i],sy[i]));\n    rep(i,7)rep(j,7) tb[i][j] = board[i][j];\n\n    for(int lim = 0; lim < 21; lim++){\n        if( dfs(0,lim,-1,-1,sp) ) return lim;\n        //rep(i,7)rep(j,7)if( board[i][j]!=tb[i][j] ) puts(\"ugeeeee\");\n    }\n    return -1;\n}\nint main(){\n    for(;;){\n        memset(board, -1, sizeof(board));\n        int sz = 0;\n\n        scanf(\"%d\",&board[1][3]); if( board[1][3]==-1 ) break;\n        rep(i,3) scanf(\"%d\",&board[2][2+i]);\n        rep(i,5) scanf(\"%d\",&board[3][1+i]);\n        rep(i,3) scanf(\"%d\",&board[4][2+i]);\n        scanf(\"%d\",&board[5][3]);\n\n        // find space\n        if( board[1][3]==0 ){ sx[sz]=3; sy[sz]=1; sz++; }\n        rep(i,3) if( board[2][2+i]==0 ) { sx[sz]=2+i; sy[sz]=2; sz++; }\n        rep(i,5) if( board[3][1+i]==0 ) { sx[sz]=1+i; sy[sz]=3; sz++; }\n        rep(i,3) if( board[4][2+i]==0 ) { sx[sz]=2+i; sy[sz]=4; sz++; }\n        if( board[5][3]==0 ){ sx[sz]=3; sy[sz]=5; sz++; }\n\n        //printf(\"hoge:%d\\n\",dist());\n        int ans = solve();\n        if( ans!=-1 ) printf(\"%d\\n\",ans); else puts(\"NA\");\n    }\n    return 0;\n}\n\n/*\n\n//-------------------------------------------------------\n\n#define N 5\n#define REP(i, n) for ( int i = 0; i < (int)n; i++ )\n#define LIMIT 20\n\nstatic const int T[12][2] = {\n    {-1, -1},\n    {1, 1}, \n    {1, 2}, \n    {1, 3},\n    {2, 0},\n    {2, 1},\n    {2, 2},\n    {2, 3},\n    {2, 4},\n    {3, 1}, \n    {3, 2},\n    {3, 3}\n};\nstatic const int g[N][N] = {\n    {-1,-1, 0,-1,-1},\n    {-1, 1, 2, 3,-1},\n    { 4, 5, 6, 7, 8},\n    {-1, 9,10,11,-1}, \n    {-1,-1, 0,-1,-1}\n};\n\nclass Puzzle{\npublic:\n    int C[N][N], mdist; //manhatta distance\n    Puzzle(){}\n\n    bool swapAdj( int si, int sj, int ti, int tj ){\n        if ( ti < 0 || tj < 0 || ti >= N || tj >= N ) return false;\n        if ( C[ti][tj] <= 0 ) return false;\n        swap(C[ti][tj], C[si][sj]);\n        int tti = T[C[si][sj]][0];\n        int ttj = T[C[si][sj]][1];\n        //mdist -= max(tti, ti)-min(tti, ti) + max(ttj, tj)-min(ttj, tj);\n        //mdist += max(tti, si)-min(tti, si) + max(ttj, sj)-min(ttj, sj);\n        //mdist -= abs(tti-ti)+abs(ttj-tj);\n        //mdist += abs(tti-si)+abs(ttj-sj);\n        return true;\n    }\n\n    bool isGoal(){\n        REP(i, N) REP(j, N) if ( g[i][j] != C[i][j] ) return false;\n        return true;\n    }\n\n    int getMD(){ // get initial manhattan distance\n        int sum = 0;\n        int ti, tj;\n        REP(i, 5) REP(j, 5){\n            if ( C[i][j] <= 0 ) continue;\n            ti = T[C[i][j]][0];\n            tj = T[C[i][j]][1];\n            //sum += (max(ti, i)-min(ti, i) + max(tj, j) - min(tj, j));\n            sum += abs(ti-i) + abs(tj-j);\n        }\n        return sum;\n    }\n};\n\nint limit;\n\nbool dfs( int depth, Puzzle P ){\n    if ( P.isGoal() ) return true;\n    if ( depth + P.getMD() > limit ) return false;\n\n    static const int di[4] = {0, -1, 0, 1};\n    static const int dj[4] = {1, 0, -1, 0};\n\n    REP(i, N) REP(j, N){\n        if ( P.C[i][j] != 0 ) continue;\n        REP(r, 4){\n            Puzzle v = P;\n            if ( !v.swapAdj(i, j, i+di[r], j+dj[r]) ) continue;\n            if ( dfs( depth + 1, v ) ) return true;\n        }\n    }\n\n    return false;\n}\n\nint idp(Puzzle source){\n    for ( limit = 0; limit <= LIMIT; limit++ ){\n        //source.mdist = source.getMD();\n        if ( dfs(0, source) ) return limit;\n    }\n    return INT_MAX;\n}\n\nint main(){\n    Puzzle P;\n    int top;\n\n    while(1){\n        cin >> top;\n        if ( top == -1 ) break;\n        REP(j, N) P.C[0][j] = -1;\n        P.C[0][2] = top;\n        for(int i = 1; i < N; i++) REP(j, N){\n                if ( (i == 1 || i == 3) && (j == 0 || j == 4 ) ) P.C[i][j] = -1;\n                else if ( i == 4 && j != 2 ) P.C[i][j] = -1;\n                else cin >> P.C[i][j];\n            }\n\n        int cost = idp(P);\n        if ( cost == INT_MAX ) cout << \"NA\" << endl;\n        else cout << cost << endl;\t\n    }\n\n    return 0;\n}\n\n*/"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\n\nusing namespace std;\n\n#define int long long\n#define FR first\n#define SC second\n#define all(v) (v).begin(), (v).end()\n#define rep(i, n) for(int i = 0; i < (int)(n); i++)\n#define reps(i, f, n) for(int i = (int)(f); i < (int)(n); i++)\n#define each(a, b) for(auto& a : b)\n\ntypedef pair<int, int> P;\n\nconst int inf = 1LL << 55;\n\nvector< vector<int> > to = {\n  {2},\n  {2, 5},\n  {0, 1, 3, 6},\n  {2, 7},\n  {5},\n  {1, 4, 6, 9},\n  {2, 5, 7, 10},\n  {3, 6, 8, 11},\n  {7},\n  {5, 10},\n  {6, 9, 11, 12},\n  {7, 10},\n  {10}\n};\n\nvector<int> ans = {0,1,2,3,4,5,6,7,8,9,10,11,0};\n\nvector<int> x = {2,1,2,3,0,1,2,3,4,1,2,3,2};\nvector<int> y = {0,1,1,1,2,2,2,2,2,3,3,3,4};\n\nsigned main()\n{\n  cin.tie(0);\n  ios_base::sync_with_stdio(0);\n  cout << fixed << setprecision(12);\n\n  int p;\n  while(cin >> p, ~p) {\n    vector<int> pzl; pzl.push_back(p);\n    rep(i, 12) cin >> p, pzl.push_back(p);\n    map<vector<int>, int> d;\n    queue< vector<int> > que;\n    que.push(pzl);\n    d[pzl] = 0;\n    bool flag = false;\n    while(!que.empty() && !flag) {\n      auto v = que.front(); que.pop();\n      int e = 0;\n      rep(i, v.size()) if(v[i]) {\n\te += abs(x[i]-x[v[i]]) + abs(y[i]-y[v[i]]);\n      }\n      if(e == 0) {\n\tcout << d[v] << endl;\n\tflag = true;\n\tbreak;\n      }\n      if(e + d[v] > 20) continue;\n      rep(i, v.size()) {\n\tif(v[i]) continue;\n\trep(j, to[i].size()) {\n\t  int c = d[v];\n\t  swap(v[i], v[to[i][j]]);\n\t  if(!d.count(v)) {\n\t    que.push(v);\n\t    d[v] = c + 1;\n\t  }\n\t  swap(v[i], v[to[i][j]]);\n\t}\n      }\n    }\n    if(!flag) cout << \"NA\" << endl;\n  }\n  \n  return 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include<iostream>\n#include<vector>\n#include<algorithm>\n#include<map>\n#include<queue>\n\nusing namespace std;\n\nmap<vector<int>,int>mp,used;\n\nstruct State{\n  vector<int>v;\n  int t;\n  State(vector<int>v,int t):v(v),t(t){}\n};\n\nvector<vector<int> > generate(vector<int> v){\n  vector<vector<int> >res;\n\n  for(int i=0;i<13;i++){\n    if(v[i]==0){\n      vector<int>tmp=v;\n      switch(i){\n      case 0:\n\tswap(tmp[0],tmp[2]);\n\tres.push_back(tmp);\n\tbreak;\n      case 1:\n\tswap(tmp[1],tmp[2]);\n\tres.push_back(tmp);\n\tswap(tmp[1],tmp[2]);\n\tswap(tmp[1],tmp[5]);\n\tres.push_back(tmp);\n\tbreak;\n      case 2:\n\tswap(tmp[2],tmp[0]);\n\tres.push_back(tmp);\n\tswap(tmp[2],tmp[0]);\n\n\tswap(tmp[2],tmp[1]);\n\tres.push_back(tmp);\n\tswap(tmp[2],tmp[1]);\n\n\tswap(tmp[2],tmp[3]);\n\tres.push_back(tmp);\n\tswap(tmp[2],tmp[3]);\n\n\tswap(tmp[2],tmp[6]);\n\tres.push_back(tmp);\n\tbreak;\n      case 3:\n\tswap(tmp[3],tmp[2]);\n\tres.push_back(tmp);\n\tswap(tmp[3],tmp[2]);\n\n\tswap(tmp[3],tmp[7]);\n\tres.push_back(tmp);\n\tbreak;\n      case 4:\n\tswap(tmp[4],tmp[5]);\n\tres.push_back(tmp);\n\tbreak;\n      case 5:\n\tswap(tmp[5],tmp[1]);\n\tres.push_back(tmp);\n\tswap(tmp[5],tmp[1]);\n\n\tswap(tmp[5],tmp[4]);\n\tres.push_back(tmp);\n\tswap(tmp[5],tmp[4]);\n\n\tswap(tmp[5],tmp[6]);\n\tres.push_back(tmp);\n\tswap(tmp[5],tmp[6]);\n\n\tswap(tmp[5],tmp[9]);\n\tres.push_back(tmp);\n\tbreak;\n      case 6:\n\tswap(tmp[6],tmp[2]);\n\tres.push_back(tmp);\n\tswap(tmp[6],tmp[2]);\n\n\tswap(tmp[6],tmp[5]);\n\tres.push_back(tmp);\n\tswap(tmp[6],tmp[5]);\n\n\tswap(tmp[6],tmp[7]);\n\tres.push_back(tmp);\n\tswap(tmp[6],tmp[7]);\n\n\tswap(tmp[6],tmp[10]);\n\tres.push_back(tmp);\n\tbreak;\n      case 7:\n\tswap(tmp[7],tmp[3]);\n\tres.push_back(tmp);\n\tswap(tmp[7],tmp[3]);\n\n\tswap(tmp[7],tmp[6]);\n\tres.push_back(tmp);\n\tswap(tmp[7],tmp[6]);\n\n\tswap(tmp[7],tmp[8]);\n\tres.push_back(tmp);\n\tswap(tmp[7],tmp[8]);\n\n\tswap(tmp[7],tmp[11]);\n\tres.push_back(tmp);\n\tbreak;\n      case 8:\n\tswap(tmp[8],tmp[7]);\n\tres.push_back(tmp);\n\tbreak;\n      case 9: \n\tswap(tmp[9],tmp[5]);\n\tres.push_back(tmp);\n\tswap(tmp[9],tmp[5]);\n\n\tswap(tmp[9],tmp[10]);\n\tres.push_back(tmp);\n\tbreak;\n      case 10:\n\tswap(tmp[10],tmp[6]);\n\tres.push_back(tmp);\n\tswap(tmp[10],tmp[6]);\n\n\tswap(tmp[10],tmp[9]);\n\tres.push_back(tmp);\n\tswap(tmp[10],tmp[9]);\n\n\tswap(tmp[10],tmp[11]);\n\tres.push_back(tmp);\n\tswap(tmp[10],tmp[11]);\n\n\tswap(tmp[10],tmp[12]);\n\tres.push_back(tmp);\n\tbreak;\n      case 11:\n\tswap(tmp[11],tmp[7]);\n\tres.push_back(tmp);\n\tswap(tmp[11],tmp[7]);\n\n\tswap(tmp[11],tmp[10]);\n\tres.push_back(tmp);\n\tbreak;\n      case 12:\n\tswap(tmp[12],tmp[10]);\n\tres.push_back(tmp);\n\tbreak;\n      }\n    }\n  }\n  return res;\n}\n\nvoid bfs(void){\n\n  queue<State>que;\n  vector<int>s;\n  for(int i=0;i<12;i++)s.push_back(i);\n  s.push_back(0);\n  que.push(State(s,0));\n\n  while(!que.empty()){\n    State now=que.front();\n    que.pop();\n    \n    if(mp.count(now.v) && now.t>=mp[now.v])continue;\n    if(now.t>=9)continue;\n\n    mp[now.v]=now.t;\n\n    vector<vector<int> >res=generate(now.v);\n    for(int i=0;i<res.size();i++){\n      que.push(State(res[i],now.t+1));\n    }\n  }\n}\n\nint bfs(vector<int> s){\n  \n  used.clear();\n  \n  queue<State>que;\n  que.push(State(s,0));\n  \n  while(!que.empty()){\n    State now=que.front();\n    que.pop();\n    \n    if(now.t>=11)continue;\n    if(used.count(now.v))continue;\n    if(mp.count(now.v))return now.t+mp[now.v];\n    used[now.v]=1;\n    \n    vector<vector<int> >res=generate(now.v);\n    for(int i=0;i<res.size();i++){\n      que.push(State(res[i],now.t+1));\n    }\n  }\n  return -1;\n}\n\nint main(void){\n\n  bfs();\n\n  while(true){\n    vector<int>s(13);\n    for(int i=0;i<13;i++){\n      cin >> s[i];\n      if(s[i]<0)return 0;\n    }\n    int res=bfs(s);\n    if(res<0 || res>20)cout << \"NA\" << endl;\n    else cout << res << endl;\n  }\n\n  return 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include <iostream>\n#include <string>\n#include <sstream>\n#include <map>\n#include <queue>\nusing namespace std;\n\n#define REP(i,n,m) for(int i=n;i<m;i++)\n#define rep(i,n) REP(i,0,n)\n#define LIMIT 14\n\nclass State{\npublic:\n\tstring s;\n\tint cost;\n\tint idx[2];\n\n\tState(string ts,int tcost,int tidx[]){\n\t\ts = ts;\n\t\tcost = tcost;\n\t\tidx[0] = tidx[0];\n\t\tidx[1] = tidx[1];\n\t}\n};\n\nint di[13][4] = {\n\t{-1,-1,2,-1},\n\t{-1,2,5,-1},\n\t{0,3,6,1},\n\t{-1,-1,7,2},\n\t{-1,5,-1,-1},\n\t{1,6,9,4},\n\t{2,7,10,5},\n\t{3,8,11,6},\n\t{-1,-1,-1,7},\n\t{5,10,-1,-1},\n\t{6,11,12,9},\n\t{7,-1,-1,10},\n\t{10,-1,-1,-1},\n};\n\nvoid printPuzzle(string s){\n\tcout<<\"  \"<<s.substr(0,1)<<endl;\n\tcout<<\" \"<<s.substr(1,3)<<endl;\n\tcout<<s.substr(4,5)<<endl;\n\tcout<<\" \"<<s.substr(9,3)<<endl;\n\tcout<<\"  \"<<s.substr(12,1)<<endl;\n\tcout<<\"----------------------------\\n\";\n}\n\nqueue<State> open;\nmap<string,int> closed,closed2;\n\nint main(void){\n\tstring alpha = \"abcdefghijkl\";\n\tint idx[] = {0,12};\n\n\topen.push(State(\"abcdefghijkla\",0,idx));\n\tclosed.insert(pair<string,int>(\"abcdefghijkla\",0));\n\n\twhile(!open.empty()){\n\t\tState st = open.front(); open.pop();\n\t\tif(st.cost >= LIMIT) continue;\n\n\t\trep(i,2){\n\t\t\trep(j,4){\n\t\t\t\tint to = di[st.idx[i]][j];\n\t\t\t\tif(to == -1) continue;\n\n\t\t\t\tstring res = st.s;\n\t\t\t\tint tmp = res[st.idx[i]];\n\t\t\t\tres[st.idx[i]] = res[to];\n\t\t\t\tres[to] = tmp;\n\n\t\t\t\tif(closed.find(res) == closed.end()){\n\t\t\t\t\tidx[0] = i==0 ? to : st.idx[0];\n\t\t\t\t\tidx[1] = i==1 ? to : st.idx[1];\n\t\t\t\t\topen.push(State(res,st.cost+1,idx));\n\t\t\t\t\tclosed.insert(pair<string,int>(res,st.cost+1));\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t}\n\n\twhile(1){\n\t\tint x;\n\t\tcin>>x;\n\t\tif(x == -1) break;\n\n\t\tstringstream ss;\n\t\tss<<alpha[x];\n\t\trep(i,12){\n\t\t\tcin>>x;\n\t\t\tss<<alpha[x];\n\t\t}\n\n\t\tstring start = ss.str();\n\n\t\twhile(!open.empty()) open.pop();\n\n\t\tfor(idx[0]=0;start[idx[0]]!='a';idx[0]++);\n\t\tfor(idx[1]=start.length()-1;start[idx[1]]!='a';idx[1]--);\n\t\topen.push(State(start,0,idx));\n\t\tclosed2.insert(pair<string,int>(start,0));\n\n\t\tint ans = -1;\n\n\t\twhile(!open.empty()){\n\t\t\tState st = open.front(); open.pop();\n\t\t\tif(closed.find(st.s) != closed.end()){\n\t\t\t\tans = st.cost + closed[st.s];\n\t\t\t\tbreak;\n\t\t\t}\n\t\t\tif(st.cost >= 20-LIMIT) continue;\n\n\t\t\trep(i,2){\n\t\t\t\trep(j,4){\n\t\t\t\t\tint to = di[st.idx[i]][j];\n\t\t\t\t\tif(to == -1) continue;\n\n\t\t\t\t\tstring res = st.s;\n\t\t\t\t\tint tmp = res[st.idx[i]];\n\t\t\t\t\tres[st.idx[i]] = res[to];\n\t\t\t\t\tres[to] = tmp;\n\n\t\t\t\t\tif(closed2.find(res) == closed2.end()){\n\t\t\t\t\t\tidx[0] = i==0 ? to : st.idx[0];\n\t\t\t\t\t\tidx[1] = i==1 ? to : st.idx[1];\n\t\t\t\t\t\topen.push(State(res,st.cost+1,idx));\n\t\t\t\t\t\tclosed2.insert(pair<string,int>(res,st.cost+1));\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\n\t\tif(ans == -1) cout<<\"NA\\n\";\n\t\telse cout<<ans<<endl;\n\t}\n\n\treturn 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include<bits/stdc++.h>\nusing namespace std;\n   \ntypedef long long int64;\nconst int INF = 1 << 30;\n   \nvector< int > edge[13];\nmap< string, int > memo;\n  \nbool back(string str, int cnt){ //枝刈り大事だな\n  static int dist[] = { 0, 2, 1, 2, 4, 3, 2, 3, 4, 2, 1, 2, 0};\n  static int fuee[] = { 2, 0, 1, 2, 2, 1, 2, 3, 4, 2, 3, 4, 4};\n  static int fuga[] = { 1, 1, 0, 1, 3, 2, 1, 2, 3, 3, 2, 3, 3};\n  static int haaa[] = { 2, 2, 1, 0, 4, 3, 2, 1, 2, 4, 3, 2, 4};\n  static int kira[] = { 3, 3, 2, 3, 3, 2, 1, 2, 3, 1, 0, 1, 1};\n  \n  if(cnt > 20) return true;\n  int foo1 = 0, foo2 = 0, foo3 = 0, foo4 = 0, foo5 = 0;\n  for(int i = 0; i < 13; i++){\n    if(str[i] == '0') foo1 += dist[i];\n    else if(str[i] == '1') foo2 += fuee[i];\n    else if(str[i] == '2') foo3 += fuga[i];\n    else if(str[i] == '3') foo4 += haaa[i];\n    else if(str[i] == 'A') foo5 += kira[i];\n  }\n  return cnt + foo1 + foo2 + foo3 + foo4 + foo5 > 28;\n}\n  \n  \nint bfs(string mas){\n  \n  queue< string > que;\n  map< string , int > used;\n  que.push( mas );\n  memo[mas] = 0;\n  while(!que.empty()){\n  \n    string p = que.front(); que.pop();\n    if(back( p, memo[p])) continue;\n    if(p == \"0123456789AB0\") return memo[p];\n  \n    for(int i = 0; i < 13; i++){\n      if(p[i] == '0') {\n        for(int j = 0; j < edge[i].size(); j++){\n          string next = p;\n          swap( next[i], next[edge[i][j]]);\n          if(memo.find(next) != memo.end()) continue;\n          que.push( next );\n          memo[next] = memo[p] + 1;\n        }\n      }\n    }\n  }\n  return -1;\n}\n  \nint main(){\n  vector< int > mas(13);\n  \n  edge[0].push_back(2);\n  edge[1].push_back(2); edge[1].push_back(4);\n  edge[2].push_back(0); edge[2].push_back(1); edge[2].push_back(3); edge[2].push_back(6);\n  edge[3].push_back(2); edge[3].push_back(7);\n  edge[4].push_back(5);\n  edge[5].push_back(1); edge[5].push_back(4); edge[5].push_back(6); edge[5].push_back(9);\n  edge[6].push_back(2); edge[6].push_back(5); edge[6].push_back(7); edge[6].push_back(10);\n  edge[7].push_back(3); edge[7].push_back(6); edge[7].push_back(8); edge[7].push_back(11);\n  edge[8].push_back(7);\n  edge[9].push_back(5); edge[9].push_back(10);\n  edge[10].push_back(6); edge[10].push_back(9); edge[10].push_back(11); edge[10].push_back(12);\n  edge[11].push_back(7); edge[11].push_back(10);\n  edge[12].push_back(10);\n  \n  while(cin >> mas[0], mas[0] != -1){\n    for(int i = 1; i < 13; i++){\n      cin >> mas[i];\n    }\n  \n    string start = \"\";\n    for(int i = 0; i < 13; i++){\n      if(mas[i] >= 10) start += (char)(mas[i] - 10 + 'A');\n      else start += mas[i] + '0';\n    }\n    int ret = bfs(start);\n    if(~ret) cout << ret << endl;\n    else cout << \"NA\" << endl;\n  \n    memo.clear();\n  }\n}"
  },
  {
    "language": "C++",
    "code": "#include <iostream>\n#include <algorithm>\n#include <vector>\n#include <cstring>\n#include <cstdio>\n#include <climits>\n\nusing namespace std;\n\n#define REP(i,a,n) for(int i=(a); i<(int)(n); i++)\n#define rep(i,n) REP(i,0,n)\n#define DEB 0\n\n/*\n  1 = [2][2]\n  2 = [2][3]\n  3 = [2][4]\n  4 = [3][1]\n  5 = [3][2]\n  6 = [3][3]\n  7 = [3][4]\n  8 = [3][5]\n  9 = [4][2]\n  10= [4][3]\n  11= [4][4]\n*/\nint board[7][7]; //1base\nint sx[2], sy[2];\nstatic const int dx[] = {0,0,1,-1};\nstatic const int dy[] = {1,-1,0,0};\n\n/*\n(y,x)\n */\nint calc(int y, int x){\n    switch(board[y][x]){\n    case 1: return abs(2-y)+abs(2-x);\n    case 2: return abs(2-y)+abs(3-x);\n    case 3: return abs(2-y)+abs(4-x);\n    case 4: return abs(3-y)+abs(1-x);\n    case 5: return abs(3-y)+abs(2-x);\n    case 6: return abs(3-y)+abs(3-x);\n    case 7: return abs(3-y)+abs(4-x);\n    case 8: return abs(3-y)+abs(5-x);\n    case 9: return abs(4-y)+abs(2-x);\n    case 10: return abs(4-y)+abs(3-x);\n    case 11: return abs(4-y)+abs(4-x);\n    }\n    return -1;\n}\nint dist(void){\n    int ret = 0;\n    if( board[1][3] ) ret += calc(1,3);\n    rep(i,3) if( board[2][2+i] ) ret += calc(2,2+i);\n    rep(i,5) if( board[3][1+i] ) ret += calc(3,1+i);\n    rep(i,3) if( board[4][2+i] ) ret += calc(4,2+i);\n    if( board[5][3] ) ret += calc(5,3);\n    return ret;\n}\nbool isgoal(void){\n    if( board[1][3]!=0 ) return false;\n    rep(i,3) if( board[2][2+i]!=i+1 ) return false;\n    rep(i,5) if( board[3][1+i]!=i+4 ) return false;\n    rep(i,3) if( board[4][2+i]!=i+9 ) return false;\n    if( board[5][3]!=0 ) return false;\n    return true;\n}\n\nbool dfs(int cnt, int LIM, int py, int px){\n    if( LIM<cnt ) return false;\n    if( isgoal() ) return true;\n    if( cnt+dist()>30 ) return false;\n\n    rep(i,2){\n        rep(k,4){\n            int tx = sx[i] + dx[k];\n            int ty = sy[i] + dy[k];\n            if( board[ty][tx]==-1 || ty==py&&tx==px ) continue;\n            swap(board[sy[i]][sx[i]], board[ty][tx]);\n            swap(sx[i], tx); swap(sy[i],ty);\n            if( dfs(cnt+1, LIM, ty, tx) ) return true;\n            swap(sx[i], tx); swap(sy[i],ty);\n            swap(board[sy[i]][sx[i]] ,board[ty][tx]);\n        }\n    }\n    return false;\n}\nint solve(void){\n    int ttx[2], tty[2];\n    rep(i,2) ttx[i]=sx[i], tty[i]=sy[i];\n\n    for(int lim = 0; lim < 21; lim++){\n        rep(i,2) sx[i]=ttx[i], sy[i]=tty[i];\n        if( dfs(0,lim,-1,-1) ) return lim;\n    }\n    return -1;\n}\nint main(){\n    for(;;){\n        memset(board, -1, sizeof(board));\n        int sz = 0;\n\n        scanf(\"%d\",&board[1][3]); if( board[1][3]==-1 ) break;\n        rep(i,3) scanf(\"%d\",&board[2][2+i]);\n        rep(i,5) scanf(\"%d\",&board[3][1+i]);\n        rep(i,3) scanf(\"%d\",&board[4][2+i]);\n        scanf(\"%d\",&board[5][3]);\n\n        // find space\n        if( board[1][3]==0 ){ sx[sz]=3; sy[sz]=1; sz++; }\n        rep(i,3) if( board[2][2+i]==0 ) { sx[sz]=2+i; sy[sz]=2; sz++; }\n        rep(i,5) if( board[3][1+i]==0 ) { sx[sz]=1+i; sy[sz]=3; sz++; }\n        rep(i,3) if( board[4][2+i]==0 ) { sx[sz]=2+i; sy[sz]=4; sz++; }\n        if( board[5][3]==0 ){ sx[sz]=3; sy[sz]=5; sz++; }\n\n        int ans = solve();\n        if( ans!=-1 ) printf(\"%d\\n\",ans); else puts(\"NA\");\n    }\n    return 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include<bits/stdc++.h>\nusing namespace std;\n  \ntypedef long long int64;\nconst int INF = 1 << 30;\n  \nvector< int > edge[13];\nmap< string, int > memo;\n \nbool back(string str, int cnt){ //枝刈り大事だな\n  static int dist[] = { 0, 2, 1, 2, 4, 3, 2, 3, 4, 2, 1, 2, 0};\n  static int fuee[] = { 2, 0, 1, 2, 2, 1, 2, 3, 4, 2, 3, 4, 4};\n  static int fuga[] = { 1, 1, 0, 1, 3, 2, 1, 2, 3, 3, 2, 3, 3};\n  static int haaa[] = { 2, 2, 1, 0, 4, 3, 2, 1, 2, 4, 3, 2, 4};\n  static int kira[] = { 3, 3, 2, 3, 3, 2, 1, 2, 3, 1, 0, 1, 1};\n \n  if(cnt > 20) return true;\n  int foo1 = 0, foo2 = 0, foo3 = 0, foo4 = 0, foo5 = 0;\n  for(int i = 0; i < 13; i++){\n    if(str[i] == '0') foo1 += dist[i];\n    else if(str[i] == '1') foo2 += fuee[i];\n    else if(str[i] == '2') foo3 += fuga[i];\n    else if(str[i] == '3') foo4 += haaa[i];\n    else if(str[i] == 'A') foo5 += kira[i];\n  }\n  return cnt + foo1 + foo2 + foo3 + foo4 + foo5 > 28;\n}\n \n \nint bfs(string mas){\n \n  queue< string > que;\n  map< string , int > used;\n  que.push( mas );\n  memo[mas] = 0;\n  while(!que.empty()){\n \n    string p = que.front(); que.pop();\n    if(back( p, memo[p])) break;\n    if(p == \"0123456789AB0\") return memo[p];\n \n    for(int i = 0; i < 13; i++){\n      if(p[i] == '0') {\n        for(int j = 0; j < edge[i].size(); j++){\n          string next = p;\n          swap( next[i], next[edge[i][j]]);\n          if(memo.find(next) != memo.end()) continue;\n          que.push( next );\n          memo[next] = memo[p] + 1;\n        }\n      }\n    }\n  }\n  return -1;\n}\n \nint main(){\n  vector< int > mas(13);\n \n  edge[0].push_back(2);\n  edge[1].push_back(2); edge[1].push_back(4);\n  edge[2].push_back(0); edge[2].push_back(1); edge[2].push_back(3); edge[2].push_back(6);\n  edge[3].push_back(2); edge[3].push_back(7);\n  edge[4].push_back(5);\n  edge[5].push_back(1); edge[5].push_back(4); edge[5].push_back(6); edge[5].push_back(9);\n  edge[6].push_back(2); edge[6].push_back(5); edge[6].push_back(7); edge[6].push_back(10);\n  edge[7].push_back(3); edge[7].push_back(6); edge[7].push_back(8); edge[7].push_back(11);\n  edge[8].push_back(7);\n  edge[9].push_back(5); edge[9].push_back(10);\n  edge[10].push_back(6); edge[10].push_back(9); edge[10].push_back(11); edge[10].push_back(12);\n  edge[11].push_back(7); edge[11].push_back(10);\n  edge[12].push_back(10);\n \n  while(cin >> mas[0], mas[0] != -1){\n    for(int i = 1; i < 13; i++){\n      cin >> mas[i];\n    }\n \n    string start = \"\";\n    for(int i = 0; i < 13; i++){\n      if(mas[i] >= 10) start += (char)(mas[i] - 10 + 'A');\n      else start += mas[i] + '0';\n    }\n    int ret = bfs(start);\n    if(~ret) cout << ret << endl;\n    else cout << \"NA\" << endl;\n \n    memo.clear();\n  }\n}"
  },
  {
    "language": "C++",
    "code": "#include <cstdio>\n#include <cstring>\n#include <algorithm>\n#include <string>\n#include <cmath>\n#include <stack>\n#include <vector>\n#include <map>\n#include <set>\n#include <queue>\n#include <list>\n#include <iostream>\n#include <sstream>\n#include <climits>\n#include <cfloat>\n#include <complex>\n\nusing namespace std;\n\ntypedef long long ll;\n\nll encode(int* state)\n{\n\tll res = 0;\n\tfor (int i = 0; i < 13; ++i)\n\t\tres = res << 4 | state[i];\n\treturn res;\n}\nvoid decode(int* d, ll e)\n{\n\tfor (int i = 12; i >= 0; --i, e >>= 4)\n\t\td[i] = e & 15;\n}\nvoid p(ll s)\n{\n\tint d[13];\n\tdecode(d, s);\n\tfor (int i = 0; i < 13; ++i)\n\t\tprintf(\"%d \", d[i]);\n\tprintf(\"\\n\");\n}\n\nint main()\n{\n\tmap<ll, int> minSteps;\n\tint dir[] = { -1, 1, -2, 2, -4, 4 };\n\tmap<int, bool> ok[3];\n\n\tint o[][9] = {\n\t\t{ 1, 2, 4, 5, 6, 7, 9, 10, -1 },\n\t\t{ 0, 10, -1 },\n\t\t{ 1, 2, 3, 5, 6, 7, -1 }\n\t};\n\tfor (int i = 0; i < 3; ++i)\n\t\tfor (int j = 0; o[i][j] != -1; ++j)\n\t\t\tok[i][o[i][j]] = true;\n\n\tint initial[] = { 0, 1, 2, 3, 4, 5, 6, 7, 8, 9, 10, 11, 0 };\n\tll t = encode(initial);\n\tminSteps[t] = 0;\n\tqueue<ll> q;\n\tq.push(t);\n\n\twhile (!q.empty())\n\t{\n\t\tll e = q.front();\n\t\tq.pop();\n\t\tint d[13];\n\t\tdecode(d, e);\n\n\t\tint zero_pos[2];\n\t\tfor (int i = 0, j = 0; j < 2; ++i)\n\t\t\tif (!d[i])\n\t\t\t\tzero_pos[j++] = i;\n\n\t\tfor (int i = 0; i < 2; ++i)\n\t\t{\n\t\t\tfor (int j = 0; j < 6; ++j)\n\t\t\t{\n\t\t\t\tint a = zero_pos[i];\n\t\t\t\tint b = a + dir[j];\n\t\t\t\tif (a > b)\n\t\t\t\t\tswap(a, b);\n\t\t\t\tif (a < 0 || b > 12 || !d[a] && !d[b] || !ok[j/2][a])\n\t\t\t\t\tcontinue;\n\n\t\t\t\tint copy[13];\n\t\t\t\tmemcpy(copy, d, sizeof(copy));\n\t\t\t\tswap(copy[a], copy[b]);\n\t\t\t\tll next = encode(copy);\n\n\t\t\t\tif (!minSteps.count(next))\n\t\t\t\t{\n\t\t\t\t\tminSteps[next] = minSteps[e] + 1;\n\t\t\t\t\tif (minSteps[next] < 10)\n\t\t\t\t\t\tq.push(next);\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t}\n\n\twhile (true)\n\t{\n\t\tint d[13];\n\t\tfor (int i = 0; i < 13; ++i)\n\t\t\tscanf(\"%d\", d + i);\n\t\tif (d[0] == -1)\n\t\t\tbreak;\n\n\t\tint ans = -1;\n\t\tll s = encode(d);\n\t\tif (minSteps.count(s))\n\t\t\tans = minSteps[s];\n\t\telse\n\t\t{\n\t\t\tmap<ll, int> c;\n\t\t\tc[s] = 0;\n\t\t\tq = queue<ll>();\n\t\t\tq.push(s);\n\t\t\twhile (!q.empty())\n\t\t\t{\n\t\t\t\tll e = q.front();\n\t\t\t\tq.pop();\n\t\t\t\tint d[13];\n\t\t\t\tdecode(d, e);\n\n\t\t\t\tint zero_pos[2];\n\t\t\t\tfor (int i = 0, j = 0; j < 2; ++i)\n\t\t\t\t\tif (!d[i])\n\t\t\t\t\t\tzero_pos[j++] = i;\n\n\t\t\t\tfor (int i = 0; i < 2; ++i)\n\t\t\t\t{\n\t\t\t\t\tfor (int j = 0; j < 6; ++j)\n\t\t\t\t\t{\n\t\t\t\t\t\tint a = zero_pos[i];\n\t\t\t\t\t\tint b = a + dir[j];\n\t\t\t\t\t\tif (a > b)\n\t\t\t\t\t\t\tswap(a, b);\n\t\t\t\t\t\tif (a < 0 || b > 12 || !d[a] && !d[b] || !ok[j/2][a])\n\t\t\t\t\t\t\tcontinue;\n\n\t\t\t\t\t\tint copy[13];\n\t\t\t\t\t\tmemcpy(copy, d, sizeof(copy));\n\t\t\t\t\t\tswap(copy[a], copy[b]);\n\t\t\t\t\t\tll next = encode(copy);\n\n\t\t\t\t\t\tif (minSteps.count(next))\n\t\t\t\t\t\t{\n\t\t\t\t\t\t\tans = 10 + c[e] + 1;\n\t\t\t\t\t\t\tgoto End;\n\t\t\t\t\t\t}\n\t\t\t\t\t\tif (!c.count(next) && c[e] < 10)\n\t\t\t\t\t\t{\n\t\t\t\t\t\t\tc[next] = c[e] + 1;\n\t\t\t\t\t\t\tq.push(next);\n\t\t\t\t\t\t}\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t}\n\t\t}\nEnd:\n\t\tif (ans != -1)\n\t\t\tprintf(\"%d\\n\", ans);\n\t\telse\n\t\t\tputs(\"NA\");\n\t}\n\n\treturn 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include<iostream>\n#include<cmath>\n#include<stdio.h>\nusing namespace std;\n\n#define LIMIT 20\n\nstruct Puzzle {\n  int cont[25];\n  int space[2];\n};\n\nint limit;\n\nPuzzle puzzle;\n\nint tx[12]={0,1,2,3,0,1,2,3,4,1,2,3};\nint ty[12]={0,1,1,1,2,2,2,2,2,3,3,3};\nint dx[4]={0,1,0,-1};\nint dy[4]={-1,0,1,0};\n\nint heuris[12][25];\n\nint getHeuristic(){\n  int res=0;\n  for(int i=0;i<25;i++){\n    if(puzzle.cont[i]==-1||puzzle.cont[i]==0)continue;\n    res+=heuris[puzzle.cont[i]][i];\n  }\n  return res;\n}\n\nbool dfs(int depth,int prev0,int prev1){\n  /*\n  cout<<depth<<endl;\n  for(int i=0;i<5;i++){\n    for(int j=0;j<5;j++){\n      if(puzzle.cont[i*5+j]!=-1)printf(\"%3d\",puzzle.cont[i*5+j]);\n      else cout<<\"???\";\n    }\n    cout<<endl;\n  }\n  */\n  int heuri;\n  heuri=getHeuristic();\n  if(heuri==0){\n    cout<<depth<<endl;\n    return true;\n  }\n  if(depth + heuri>limit)return false;\n\n  int px,py,nx,ny;\n  Puzzle tmp=puzzle;\n\n  py=puzzle.space[0]/5;px=puzzle.space[0]%5;\n\n  for(int i=0;i<4;i++){\n    if(max(prev0,i)-min(prev0,i)==2)continue;\n    ny=py+dy[i];nx=px+dx[i];\n    if(ny<0||ny>=5||nx<0||nx>=5)continue;\n    if(puzzle.cont[ny*5+nx]==-1)continue;\n    if(puzzle.cont[ny*5+nx]==0)continue;\n    puzzle.cont[py*5+px]=puzzle.cont[ny*5+nx];\n    puzzle.cont[ny*5+nx]=0;\n    puzzle.space[0]=ny*5+nx;\n    if(dfs(depth+1,i,prev1))return true;\n    puzzle=tmp;\n  }\n  py=puzzle.space[1]/5;px=puzzle.space[1]%5;\n  for(int i=0;i<4;i++){\n    if(max(prev1,i)-min(prev1,i)==2)continue;\n    ny=py+dy[i];nx=px+dx[i];\n    if(ny<0||ny>=5||nx<0||nx>=5)continue;\n    if(puzzle.cont[ny*5+nx]==-1)continue;\n    if(puzzle.cont[ny*5+nx]==0)continue;\n    puzzle.cont[py*5+px]=puzzle.cont[ny*5+nx];\n    puzzle.cont[ny*5+nx]=0;\n    puzzle.space[1]=ny*5+nx;\n    if(dfs(depth+1,prev0,i))return true;\n    puzzle=tmp;\n  }\n  return false;\n}\n\nvoid solve(){\n  Puzzle tmp=puzzle;\n  for(limit=getHeuristic();limit<=LIMIT;limit++){\n    puzzle=tmp;\n    if(dfs(0,-100,-100))return;\n  }\n  cout<<\"NA\"<<endl;\n}\n\nint main(){\n  int x,y,c=0;\n\n  for(int i=1;i<=11;i++){\n    for(int j=0;j<25;j++){\n      y=j/5;\n      x=j%5;\n      heuris[i][j]=abs(tx[i]-x)+abs(ty[i]-y);\n    }\n  }\n\n\n  for(int i=0;i<25;i++)puzzle.cont[i]=-1;\n\n  while(1){\n    c=0;\n    for(int i=0;i<25;i++)puzzle.cont[i]=-1;\n    cin>>puzzle.cont[2];\n    if(puzzle.cont[2]==-1)break;\n    if(puzzle.cont[2]==0)puzzle.space[c++]=2;\n    \n    \n    for(int i=6;i<=8;i++){\n      cin>>puzzle.cont[i];\n      if(puzzle.cont[i]==0)puzzle.space[c++]=i;\n    }\n    for(int i=10;i<=14;i++){\n      cin>>puzzle.cont[i];\n      if(puzzle.cont[i]==0)puzzle.space[c++]=i;\n    }\n    \n    for(int i=16;i<=18;i++){\n      cin>>puzzle.cont[i];\n      if(puzzle.cont[i]==0)puzzle.space[c++]=i;\n    }\n    \n    cin>>puzzle.cont[22];\n    if(puzzle.cont[22]==0)puzzle.space[c++]=22;\n    solve();\n  }\n\n  return 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include<iostream>\n#include<algorithm>\n#include<vector>\n#include<queue>\n#include<unordered_map>\n#define lol(i,n) for(int i=0;i<n;i++)\n#define mod 1000000007\ntypedef long long ll;\nusing namespace std;\nint dx[13][4]={\n  {3,0,0,0},\n  {3,6,0,0},\n  {1,2,4,6},\n  {3,8,0,0},\n  {6,0,0,0},\n  {2,5,7,10},\n  {3,6,8,11},\n  {4,7,9,12},\n  {8,0,0,0},\n  {6,11,0,0},\n  {6,10,12,13},\n  {8,11,0,0},\n  {11,0,0,0}\n};\nunordered_map<ll,int> mp;\nll Compress(int p[]){\n  ll ans=0;\n  for(int i=0;i<13;i++){\n    ans*=13;\n    ans+=p[i];\n  }\n  return ans;\n}\n\nint unzip[13];\nvoid Unzip(ll x){\n  for(int i=0;i<13;i++){\n    unzip[12-i]=x%13;\n    x/=13;\n  }\n}\n\nint beflen=0;\nqueue<pair<ll,int> >Q;\nvoid BFS(int p[],int len){\n  //if(len!=beflen){cout<<len<<endl;beflen=len;}\n  ll tmp=Compress(p);\n  mp[tmp]=len;\n  if(len==17)return;\n  lol(i,13){\n    if(p[i]==0){\n      lol(j,4){\n\tint t=dx[i][j];\n\tif(t==0)break;\n\tt--;\n\tif(p[t]!=0){\n\t  swap(p[i],p[t]);\n\t  tmp=Compress(p);\n\t  if(mp[tmp]!=0)continue;\n\t  mp[tmp]=-1;\n\t  Q.push(make_pair(tmp,len+1));\n\t  swap(p[i],p[t]);\n\t}\n      }\n    }\n  }\n}\n\nint ans;\nvoid EFS(int p[],int len){\n  //if(len!=beflen){cout<<len<<endl;beflen=len;}\n  ll tmp=Compress(p);\n  if(mp[tmp]>0){\n    ans=min(ans,len+mp[tmp]);\n    return;\n  }\n  if(len==5)return;\n  lol(i,13){\n    if(p[i]==0){\n      lol(j,4){\n\tint t=dx[i][j];\n\tif(t==0)break;\n\tt--;\n\tif(p[t]!=0){\n\t  swap(p[i],p[t]);\n\t  tmp=Compress(p);\n\t  Q.push(make_pair(tmp,len+1));\n\t  swap(p[i],p[t]);\n\t}\n      }\n    }\n  }\n}\nint main(){\n  int p[13];\n  lol(i,13)p[i]=i;p[12]=0;\n  Q.push(make_pair(Compress(p),1));\n  while(!Q.empty()){\n    ll data=Q.front().first;\n    int len=Q.front().second;\n    Q.pop();\n    if(mp[data]>0)continue;\n    Unzip(data);\n    BFS(unzip,len);\n  }\n  while(cin>>p[0]&&p[0]!=-1){\n    for(int i=1;i<13;i++)cin>>p[i];\n    ans=mod;\n    Q.push(make_pair(Compress(p),0));\n    while(!Q.empty()){\n      ll data=Q.front().first;\n      int len=Q.front().second;\n      Q.pop();\n      Unzip(data);\n      EFS(unzip,len);\n    }\n    if(ans==mod)cout<<\"NA\"<<endl;\n    else cout<<ans-1<<endl;\n  }\n  return 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include <cstdio>\n#include <cstdlib>\n#include <cmath>\n#include <climits>\n#include <cfloat>\n#include <map>\n#include <utility>\n#include <set>\n#include <iostream>\n#include <memory>\n#include <string>\n#include <vector>\n#include <algorithm>\n#include <functional>\n#include <sstream>\n#include <complex>\n#include <stack>\n#include <queue>\n#include <cstring>\n#include <sstream>\n#include <cassert>\n#include <list>\nusing namespace std;\nstatic const double EPS = 1e-10;\ntypedef long long ll;\ntypedef pair<int,int> PI;\ntypedef vector<int> vi;\n#ifndef M_PI\n#define M_PI 3.14159265358979323846\n#endif\n#define rep(i,n) for(int i=0;i<(int)n;++i)\n#define FOR(i,c) for(__typeof((c).begin())i=(c).begin();i!=(c).end();++i)\n#define ALL(c) (c).begin(), (c).end()\n#define mp(a,b) make_pair(a,b)\n#define pb(a) push_back(a)\n#define F first\n#define S second\ntemplate <typename T> string print_array(const vector<T> &V) { ostringstream os; os << \"{ \"; for (typename vector<T>::const_iterator iter = V.begin(); iter != V.end(); ++iter) os << '\\\"' << *iter << \"\\\",\"; os << \" }\"; return os.str(); }\n\nint dx[]={0,1,0,-1},dy[]={1,0,-1,0};\n\nvector<int> se[13];\nint x[]={0,-1,0,1,-2,-1,0,1,2,-1,0,1,0};\nint y[]={2,1,1,1,0,0,0,0,0,-1,-1,-1,-2};\n\nvoid pr(ll in){\n\n  printf(\"      %3lld\\n\",in&15);\n  printf(\"   %3lld%3lld%3lld\\n\",(in>>4)&15,(in>>8)&15,(in>>12)&15);\n  printf(\"%3lld%3lld%3lld%3lld%3lld\\n\",(in>>16)&15,(in>>20)&15,(in>>24)&15,(in>>28)&15,(in>>32)&15);\n  printf(\"   %3lld%3lld%3lld\\n\",(in>>36)&15,(in>>40)&15,(in>>44)&15);\n  printf(\"      %3lld\\n\",(in>>48)&15);\n  puts(\"\");\n}\n\nint manh(ll in){\n  int ret=0;\n  rep(i,13){\n    int t=(in>>(i*4))&15;\n\n    if(!t){\n      int nx=x[t]-x[i],ny=y[t]-y[i];\n      int co=abs(nx)+abs(ny);\n      nx=x[12]-x[i],ny=y[12]-y[i];\n      int k=abs(nx)+abs(ny);\n      ret+=min(co,k);\n      continue;\n    }\n    int nx=(x[t]-x[i]),ny=y[t]-y[i];\n    ret+=abs(nx)+abs(ny);\n  }\n  return ret;\n}\n\nmain(){\n  ll p;\n\n  ll goal=0;\n  rep(i,11){\n    goal|=(i+1LL)<<(4*(i+1));\n    //cout<<goal<<endl;\n    //pr(goal);\n  }\n  //pr(goal);\n\n  se[0].pb(2);\n  se[1].pb(2);\n  se[1].pb(5);\n  se[2].pb(0);\n  se[2].pb(1);\n  se[2].pb(3);\n  se[2].pb(6);\n  se[3].pb(2);\n  se[3].pb(7);\n  se[4].pb(5);\n  se[5].pb(1);\n  se[5].pb(4);\n  se[5].pb(6);\n  se[5].pb(9);\n  se[6].pb(2);\n  se[6].pb(5);\n  se[6].pb(7);\n  se[6].pb(10);\n  se[7].pb(3);\n  se[7].pb(6);\n  se[7].pb(8);\n  se[7].pb(11);\n  se[8].pb(7);\n  se[9].pb(5);\n  se[9].pb(10);\n  se[10].pb(6);\n  se[10].pb(9);\n  se[10].pb(11);\n  se[10].pb(12);\n  se[11].pb(7);\n  se[11].pb(10);\n  se[12].pb(10);\n  \n  while(cin>>p){\n    if(p==-1)break;\n    ll in=p;\n\n    rep(i,12){\n      cin>>p;\n      in|=p<<(4*(i+1));\n    }\n\n    set<ll> app;\n\n    queue<pair<int,ll> > Q;\n    app.insert(in);\n    Q.push(mp(0,in));\n    int ans=21;\n    int mans=0;\n\n    while(!Q.empty()){\n      ll cvec=Q.front().S;\n      int ccost=Q.front().F;\n      Q.pop();\n    \n      //pr(cvec);\n\n      //if(ccost>3)break;\n     \n      if(cvec==goal){\n\tans=ccost;\n\tbreak;\n      }\n      if(ccost+manh(cvec)>32)continue;\n      rep(i,13){\n\tll t=cvec>>(i<<2);\n\tt=t&15;\n\tif(!t){\n\t  rep(j,se[i].size()){\n\t    t=cvec>>(se[i][j]<<2);\n\t    t=t&15;\n\t    if(t){\n\t      ll nvec=cvec;\n\t      t=t<<(i<<2);\n\t      nvec|=t;\n\t      nvec&=~(15LL<<se[i][j]*4);\n\t      \n\t      if(!app.count(nvec)){\n\t\tapp.insert(nvec);\n\t\tQ.push(mp(ccost+1,nvec));\n\t      }\n\t    }\n\t  }\n\t}\n      }\n    }\n    if(ans==21)cout<<\"NA\"<<endl;\n    else cout<<ans<<endl;\n  }\n}"
  },
  {
    "language": "C++",
    "code": "//35\n#include<iostream>\n#include<vector>\n#include<set>\n#include<algorithm>\n#include<queue>\n\nusing namespace std;\n\nstruct S{\n  vector<int> v;\n  int t;\n};\n\nint main(){\n  for(;;){\n    vector<int> v(13);\n    cin>>v[2]>>v[1]>>v[4]>>v[7]>>v[0]>>v[3]>>v[6]>>v[9]>>v[12]>>v[5]>>v[8]>>v[11]>>v[10];\n    if(v[2]==-1)return 0;\n    queue<S> que;\n    S is={v,0};\n    que.push(is);\n    set<vector<int> > p;\n    while(!que.empty()&&que.front().t<=20){\n      S  c=que.front();\n      int g[]={4,1,0,5,2,9,6,3,10,7,0,11,8};\n      if(c.v==vector<int>(g,g+13))break;\n      que.pop();\n      if(p.count(c.v))continue;\n      p.insert(c.v);\n      for(int i=0;i<13;i++){\n\tif(v[i]==0){\n\t  for(int j=0;j<4;j++){\n\t    int d[]={-2,3,2,-3};\n\t    int b[][5]={{0,1,2,7,12},{2,7,12,11,10},{12,11,10,5,0},{10,5,0,1,2}};\n\t    int k;\n\t    for(k=0;k<5;k++){\n\t      if(i==b[j][k])break;\n\t    }\n\t    if(k==5){\n\t      vector<int> n=c.v;\n\t      swap(n[i],n[i+d[j]]);\n\t      S ns={n,c.t+1};\n\t      if(!p.count(n)){\n\t\tque.push(ns);\n\t      }\n\t    }\n\t  }\n\t}\n      }\n    }\n    if(que.empty()||que.front().t>20){\n      cout<<\"NA\"<<endl;\n    }else{\n      cout<<que.front().t<<endl;\n    }\n  }\n  return 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\nusing namespace std;\n\nconst int INF = 1<<28;\nconst int H = 5;\nconst int W = 5;\n\nstruct State {\n  int g[H][W];\n  int x[2], y[2];\n  bool operator < (const State &s) const {\n    for(int i = 0; i < H; ++i) {\n      for(int j = abs(2-i); j < W-abs(2-i); ++j) {\n        if(g[i][j] != s.g[i][j]) return g[i][j] < s.g[i][j];\n      }\n    }\n    return false;\n  }\n  bool operator == (const State &s) const {\n    return !(*this < s) && !(s < *this);\n  }\n};\n\nmap<State,int> bfs1(State src) {\n  const static int dx[4] = {1,0,-1,0};\n  const static int dy[4] = {0,1,0,-1};\n  map<State,int> cost;\n  queue<State> que;\n  cost[src] = 0;\n  que.push(src);\n  while(que.size()) {\n    const State s = que.front();\n    que.pop();\n    if(cost[s] == 10) continue;\n    for(int k = 0; k < 2; ++k) {\n      for(int i = 0; i < 4; ++i) {\n        int nx = s.x[k] + dx[i];\n        int ny = s.y[k] + dy[i];\n        if(nx < 0 || nx >= W) continue;\n        if(ny < 0 || ny >= H) continue;\n        if(s.g[ny][nx] <= 0) continue;\n        State t = s;\n        swap(t.g[t.y[k]][t.x[k]], t.g[ny][nx]);\n        t.x[k] = nx;\n        t.y[k] = ny;\n        if(cost.count(t)) continue;\n        cost[t] = cost[s] + 1;\n        que.push(t);\n      }\n    }\n  }\n  return cost;\n}\n\nint bfs2(State src, map<State,int> rcost) {\n  const static int dx[4] = {1,0,-1,0};\n  const static int dy[4] = {0,1,0,-1};\n  if(rcost.count(src)) return rcost[src];\n  map<State,int> cost;\n  queue<State> que;\n  cost[src] = 0;\n  que.push(src);\n  while(que.size()) {\n    const State s = que.front();\n    que.pop();\n    if(cost[s] == 10) continue;\n    for(int k = 0; k < 2; ++k) {\n      for(int i = 0; i < 4; ++i) {\n        int nx = s.x[k] + dx[i];\n        int ny = s.y[k] + dy[i];\n        if(nx < 0 || nx >= W) continue;\n        if(ny < 0 || ny >= H) continue;\n        if(s.g[ny][nx] <= 0) continue;\n        State t = s;\n        swap(t.g[t.y[k]][t.x[k]], t.g[ny][nx]);\n        t.x[k] = nx;\n        t.y[k] = ny;\n        if(cost.count(t)) continue;\n        cost[t] = cost[s] + 1;\n        que.push(t);\n        if(rcost.count(t)) {\n          return cost[t] + rcost[t];\n        }\n      }\n    }\n  }\n  return INF;\n}\n\nint main() {\n  State src, dst;\n  map<State,int> rcost;\n  fill(src.g[0], src.g[H], -1);\n  fill(dst.g[0], dst.g[H], -1);\n  for(int i = 0, k = 0, t = 0; i < H; ++i) {\n    for(int j = abs(2-i); j < W-abs(2-i); ++j) {\n      dst.g[i][j] = t % 12;\n      ++t;\n      if(dst.g[i][j] == 0) {\n        dst.x[k] = j;\n        dst.y[k] = j;\n        ++k;\n      }\n    }\n  }\n  rcost = bfs1(dst);\n  while(1) {\n    for(int i = 0, k = 0; i < H; ++i) {\n      for(int j = abs(2-i); j < W-abs(2-i); ++j) {\n        cin >> src.g[i][j];\n        if(src.g[i][j] == -1) return 0;\n        if(src.g[i][j] == 0) {\n          src.x[k] = j;\n          src.y[k] = i;\n          ++k;\n        }\n      }\n    }\n    int res = bfs2(src, rcost);\n    if(res == INF) cout << \"NA\" << endl;\n    else cout << res << endl;\n  }\n  return 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include <cmath>\n#include <iostream>\n#include <string>\n#include <vector>\n#include <queue>\n#include <map>\n#include <set>\n#include <array>\n#include <sstream>\nusing namespace std;\n#ifdef _MSC_VER\n#include \"_lib_msc.h\"\n#endif\n#define ITER(c)             __typeof__((c).begin())\n#define REP(i, n)           for(int(i)=0;(i)<(n);++(i))\ntemplate<class _T> _T MAX(_T p1,_T p2){return (p2<p1)?p1:p2;} \ntemplate<class _T> _T MIN(_T p1,_T p2){return (p1<p2)?p1:p2;} \ntypedef vector<int> VI;\ntypedef vector<VI> VVI;\n#define mp                  make_pair\n#define pb                  push_back\n\nconst int inf = 1<<29;\n\ntypedef array<char,13> obj;\nobj final  = {{0,1,2,3,4,5,6,7,8,9,10,11,0}};\nobj final1 = {{2,1,0,3,4,5,6,7,8,9,0,11,10}};\nobj final2 = {{2,1,0,3,4,5,6,7,8,9,10,11,0}};\nobj final3 = {{0,1,2,3,4,5,6,7,8,9,0,11,10}};\nint mov[][5] = {\n    {2,-1},         // 0\n    {2,5,-1},       // 1\n    {0,1,3,6,-1},   // 2\n    {2,7,-1},       // 3\n    {5,-1},         // 4\n    {1,4,6,9,-1},   // 5\n    {2,5,7,10,-1},  // 6\n    {3,6,8,11,-1},  // 7\n    {7,-1},         // 8\n    {5,10,-1},      // 9\n    {6,9,11,12,-1}, // 10\n    {7,10,-1},      // 11\n    {10,-1},        // 12\n};\nint dtblm[5][5] = {\n    {-1, -1,  0, -1, -1},\n    {-1,  1,  2,  3, -1},\n    { 4,  5,  6,  7,  8},\n    {-1,  9, 10, 11, -1},\n    {-1, -1, 12, -1, -1},\n};\nint dtbl[13][13];\n\nvoid mktbl(){\n    REP(y1,5) REP(x1,5){\n        if(dtblm[y1][x1] == -1) continue;\n        int k1 = dtblm[y1][x1];\n        REP(y2,5) REP(x2,5){\n            if(dtblm[y2][x2] == -1) continue;\n            int k2 = dtblm[y2][x2];\n            dtbl[k1][k2] = abs(x1-x2) + abs(y1-y2);\n        }\n    }\n}\n\nstruct QOBJ{\n    obj p;\n    int sp[2];\n    QOBJ(obj p, int sp1, int sp2) : p(p){sp[0]=sp1,sp[1]=sp2;}\n};\n\nint distance(const obj &p){\n    int total = 0;\n    REP(i,13){\n        if(p[i] == 0) continue;\n        total += dtbl[i][(int)(p[i])];\n    }\n    return total;\n}\n\nstring solve(const obj &o){\n    if(o == final) return \"0\";\n\n    map<obj, int> memo;\n    queue<QOBJ> q;\n    int sp1 = -1, sp2 = -1;\n    REP(i,13) if(o[i] == 0){\n        if(sp1 == -1) sp1 = i; else sp2 = i;\n    }\n    q.push(QOBJ(o,sp1,sp2));\n    memo[o] = 0;\n    int maxstep = 21;\n\n    while(!q.empty()){\n        QOBJ &p = q.front();\n        obj &pp = p.p;\n        int step = memo[pp];\n        if(step + distance(pp) <= maxstep){\n            REP(sp,2){\n                int sps = p.sp[sp];\n                REP(mi, 4){\n                    int spd = mov[sps][mi];\n                    if(spd == -1) break;\n                    swap(pp[sps],pp[spd]);\n                    ITER(memo) it = memo.find(pp);\n                    if(it == memo.end() || it->second > step+1){\n                        if(it == memo.end()){\n                            memo[pp] = step+1;\n                        } else {\n                            it->second = step+1;\n                        }\n                        if(pp == final){\n                            maxstep = step;\n                        }\n                            if(sp == 0){\n                                q.push(QOBJ(pp,spd,p.sp[1]));\n                            } else {\n                                q.push(QOBJ(pp,p.sp[0],spd));\n                            }\n                    }\n                    swap(pp[sps],pp[spd]);\n                }\n            }\n        }\n        q.pop();\n    }\n    if(memo.count(final) == 0) return \"NA\";\n    if(memo[final] >= 21) return \"NA\";\n\n    stringstream ss;\n    ss << memo[final];\n\n    return ss.str();\n}\n\nint main(void){\n    mktbl();\n    int n,m;\n    while(cin >> n && n != -1){\n        obj o;\n        o[0] = n;\n        REP(i,3){ cin >> m; o[i+1] = m; }\n        REP(i,5){ cin >> m; o[i+4] = m; }\n        REP(i,3){ cin >> m; o[i+9] = m; }\n        cin >> m; o[12] = m;\n        cout << solve(o) << endl;\n    }\n    return 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\n\n#ifndef INCLUDE_ZOBRIST_HASH_HPP\n#define INCLUDE_ZOBRIST_HASH_HPP\n\n#include <random>\n#include <iostream>\n#include <typeinfo>\n\nnamespace orislib {\n\ntemplate <typename T, int W, int H, int STATE>\nstruct ZobristHash {\n  typedef T hash_t;\n  ZobristHash() {\n    std::random_device rd;\n    std::mt19937 mt(rd());\n    std::uniform_int_distribution<T> dist;\n    for (int h = 0; h < H; h++) {\n      for (int w = 0; w < W; w++) {\n        for (int s = 0; s < STATE; s++) {\n          rands[h][w][s] = dist(mt);\n        }\n      }\n    }\n  }\n  template <typename TT>\n  hash_t hash(TT data[H][W]) {\n    hash_t r = 0;\n    for (int h = 0; h < H; h++) {\n      for (int w = 0; w < W; w++) {\n        r ^= rands[h][w][data[h][w]];\n      }\n    }\n    return r;\n  }\n  hash_t rands[H][W][STATE];\n};\n}\n\n#endif\nusing namespace std;\nusing namespace orislib;\n\ntypedef long long ll;\ntypedef long double ld;\ntypedef tuple<int, int> duo;\nconst int dx[] = {0, 0, 1, -1, 1, 1, -1, -1};\nconst int dy[] = {1, -1, 0, 0, 1, -1, 1, -1};\nconst int Mod = 1000000000 + 0;\n//{{{ templates\n#define TT_             \\\n  template <typename T> \\\n  inline\n#define TTF_                        \\\n  template <typename T, typename F> \\\n  inline\nTT_ T sq(T x) { return x * x; }\nTT_ T In() {\n  T x;\n  cin >> x;\n  return x;\n}\nTT_ void Out(T& x) { cout << x; }\nTT_ void sort(T& v) { sort(begin(v), end(v)); }\nTT_ void revs(T& v) { reverse(begin(v), end(v)); }\nTT_ void uniq(T& v) {\n  sort(v);\n  v.erase(unique(begin(v), end(v)), end(v));\n}\nTT_ int ubnd(T& v, typename T::value_type& x) {\n  return upper_bound(begin(v), end(v), x) - begin(v);\n}\nTT_ int lbnd(T& v, typename T::value_type& x) {\n  return lower_bound(begin(v), end(v), x) - begin(v);\n}\nTTF_ void inpt(T& v, int n, F f) {\n  for (v.reserve(n); n--; v.emplace_back(f()))\n    ;\n}\nTTF_ void show(T& v, F f, string d = \" \", string e = \"\\n\") {\n  int i = 0;\n  for (auto& x : v) i++&&(cout << d), f(x);\n  cout << e;\n}\nTT_ typename T::iterator minel(T& v) { return min_element(begin(v), end(v)); }\nTT_ typename T::iterator maxel(T& v) { return max_element(begin(v), end(v)); }\n\ninline void fast_io() {\n  ios::sync_with_stdio(0);\n  cin.tie(0);\n}\ninline int in() {\n  int x;\n  scanf(\"%d\", &x);\n  return x;\n}\ninline ll pow_mod(ll a, ll k, ll m) {\n  ll r = 1;\n  for (; k > 0; a = a * a % m, k >>= 1)\n    if (k & 1) r = r * a % m;\n  return r;\n}\ninline ll mod_inv(ll a, ll p) { return pow_mod(a, p - 2, p); }\n//}}} priority_queue queue deque front stringstream max_element min_element\n// insert count make_tuple\n\nstruct Board {\n  Board() {}\n  Board(const vector<vector<int>>& v) {\n    memset(b, '#', sizeof(b));\n    for (int i = 0; i < 5; i++) b[i][5] = 0;\n    for (int i = 0; i < v[0].size(); i++) b[0][2 + i] = conv_hex(v[0][i]);\n    for (int i = 0; i < v[1].size(); i++) b[1][1 + i] = conv_hex(v[1][i]);\n    for (int i = 0; i < v[2].size(); i++) b[2][0 + i] = conv_hex(v[2][i]);\n    for (int i = 0; i < v[3].size(); i++) b[3][1 + i] = conv_hex(v[3][i]);\n    for (int i = 0; i < v[4].size(); i++) b[4][2 + i] = conv_hex(v[4][i]);\n    int it = 0;\n    for (int i = 0; i < 5; i++) {\n      for (int j = 0; j < 5; j++) {\n        if (b[i][j] == '0') {\n          cx[it] = j;\n          cy[it] = i;\n          it++;\n        }\n      }\n    }\n    turn = 0;\n  }\n  char conv_hex(int a) { return \"0123456789ABCDEF\"[a]; }\n  bool slide(int index, int dir) {\n    int px = cx[index], py = cy[index];\n    int nx = px + dx[dir], ny = py + dy[dir];\n    if (invalid(nx, ny)) return false;\n    if (b[ny][nx] == '#') return false;\n    if (b[ny][nx] == '0') return false;\n    swap(b[py][px], b[ny][nx]);\n    cx[index] = nx;\n    cy[index] = ny;\n    turn++;\n    return true;\n  }\n  bool is_ok() {\n    static const char cb[5][6] = {\n        \"##0##\", \"#123#\", \"45678\", \"#9AB#\", \"##0##\", };\n    return memcmp(cb, b, sizeof(cb)) == 0;\n  }\n  bool invalid(int x, int y) { return x < 0 || x >= 5 || y < 0 || y >= 5; }\n  char b[5][6];\n  int cx[2], cy[2];\n  int turn;\n};\n\nint main() {\n  ZobristHash<int, 6, 5, 256> zh;\n  int h;\n  while (h = in(), h != -1) {\n    vector<vector<int>> vs(5);\n    vs[0].emplace_back(h);\n    inpt(vs[1], 3, in);\n    inpt(vs[2], 5, in);\n    inpt(vs[3], 3, in);\n    inpt(vs[4], 1, in);\n    Board b(vs);\n    queue<Board> Q;\n    set<int> vis;\n    Q.push(b);\n    vis.insert(zh.hash(b.b));\n\n    while (!Q.empty()) {\n      Board bi = Q.front();\n      Q.pop();\n      if (bi.turn > 15) break;\n      if (bi.is_ok()) {\n        cout << bi.turn << endl;\n        goto END;\n      }\n      for (int i = 0; i < 2; i++) {\n        for (int d = 0; d < 4; d++) {\n          Board bii = bi;\n          if (!bii.slide(i, d)) continue;\n          int hv = zh.hash(bii.b);\n          if (vis.count(hv)) continue;\n          vis.insert(hv);\n          Q.push(bii);\n        }\n      }\n    }\n  cout << \"NA\" << endl;\nEND:;\n  }\n  return 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include <cstdio>\n#include <cstring>\n#include <algorithm>\n\nusing namespace std;\n\nint fie[5][5];\nint o_fie[5][5]={\n\t-1,-1,0,-1,-1,\n\t-1,1,2,3,-1,\n\t4,5,6,7,8,\n\t-1,9,10,11,-1\n\t-1,-1,0,-1,-1,\n};\n\nint ox[12],oy[12],zx[2],zy[2],zcnt;\nint res;\nbool flag;\n\nint dx[4]={1,0,-1,0};\nint dy[4]={0,1,0,-1};\n\nvoid dfs(int v,int dist,int pd,int pu){\n\tif(dist==0){\n\t\tflag=true;\n\t\tres=min(res,v+dist);\n\t\treturn;\n\t}\n\tfor(int i=0;i<4;i++){\n\t\tfor(int j=0;j<2;j++){\n\t\t\tif(pu==j && (pd+2)%4==i)continue;\n\t\t\tint nx=zx[j]+dx[i],ny=zy[j]+dy[i];\n\t\t\tif(nx>=0 && nx<5 && ny>=0 && ny<5){\n\t\t\t\tif(fie[nx][ny]<=0)continue;\n\t\t\t\tint ch=fie[nx][ny];\n\t\t\t\tint ndist=dist;\n\t\t\t\tndist-=abs(ox[ch]-nx)+abs(oy[ch]-ny);\n\t\t\t\tswap(fie[nx][ny],fie[zx[j]][zy[j]]);\n\t\t\t\tndist+=abs(ox[ch]-zx[j])+abs(oy[ch]-zy[j]);\n\t\t\t\tzx[j]+=dx[i];\n\t\t\t\tzy[j]+=dy[i];\n\t\t\t\tif(v+1+ndist<=res)dfs(v+1,ndist,i,j);\n\t\t\t\tswap(fie[nx][ny],fie[zx[j]][zy[j]]);\n\t\t\t\tzx[j]-=dx[i];\n\t\t\t\tzy[j]-=dy[i];\n\t\t\t}\n\t\t}\n\t}\n}\nint dist;\n\nint main(void){\n\tfor(int i=0;i<5;i++){\n\t\tfor(int j=abs(2-i);j<=4-abs(2-i);j++){\n\t\t\tox[o_fie[i][j]]=j;\n\t\t\toy[o_fie[i][j]]=i;\n\t\t}\n\t}\n\twhile(1){\n\t\tmemset(fie,-1,sizeof(fie));\n\t\tdist=0;\n\t\tzcnt=0;\n\t\tfor(int i=0;i<5;i++){\n\t\t\tfor(int j=abs(2-i);j<=4-abs(2-i);j++){\n\t\t\t\tscanf(\"%d\",&fie[j][i]);\n\t\t\t\tif(fie[j][i]==-1)return 0;\n\t\t\t}\n\t\t}\n\t\tfor(int i=0;i<5;i++){\n\t\t\tfor(int j=abs(2-i);j<=4-abs(2-i);j++){\n\t\t\t\tint v=fie[j][i];\n\t\t\t\tif(v==0){\n\t\t\t\t\tzx[zcnt]=j;\n\t\t\t\t\tzy[zcnt++]=i;\n\t\t\t\t}else dist+=abs(ox[v]-j)+abs(oy[v]-i);\n\t\t\t}\n\t\t}\n\t\tif(dist>20){\n\t\t\tprintf(\"NA\\n\");\n\t\t}else{\n\t\t\tint i=0;\n\t\t\tflag=false;\n\t\t\tres=20;\n\t\t\tdfs(0,dist,-1,-1);\n\t\t\tif(flag){\n\t\t\t\tprintf(\"%d\\n\",res);\n\t\t\t}\n\t\t\tif(!flag)printf(\"NA\\n\");\n\t\t}\n\t}\n\treturn 0;\n} "
  },
  {
    "language": "C++",
    "code": "#include<iostream>\n#include<algorithm>\n#include<iomanip>\n\n#define N 7\n#define INV (-1)\n\n#define UP 0\n#define RIGHT 1\n#define DOWN 2\n#define LEFT 3\n#define DIRMAX 4\n\n#define NA 20\n\nusing namespace std;\n\nstruct State\n{\n  int map[N][N];\n  State(){\n    //fill(&map[0][0],&map[N-1][N-1],-1);\n  }\n  State(int tmap[][N]){\n    for(int i = 0; i < N; ++i){\n      for(int j = 0; j < N; ++j){\n\tmap[i][j] = tmap[i][j];\n      }\n    }\n  }\n  bool move(int which, int dir){\n    // which = 0, upper,left\n    // which != 0, bottom,right\n    for(int i = (which==0?0:N-2); which==0?(i<N-1):(i>=1); which==0?++i:--i){\n      for(int j = (which==0?0:N-2); which==0?(j<N-1):(j>=1); which==0?++j:--j){\n\tif( map[i][j] == 0 ){\n\t  switch(dir){\n\t  case UP:   if( map[i-1][j] > 0 ){swap( map[i][j], map[i-1][j] );return true;}break;\n\t  case RIGHT:if( map[i][j+1] > 0 ){swap( map[i][j], map[i][j+1] );return true;}break;\n\t  case DOWN: if( map[i+1][j] > 0 ){swap( map[i][j], map[i+1][j] );return true;}break;\n\t  case LEFT: if( map[i][j-1] > 0 ){swap( map[i][j], map[i][j-1] );return true;}break;\n\t  }\n\t  return false;\n\t}\n      }\n    }\n  }\n  int getHeuristic()const{\n    const int ti[] = {0,2,2,2,3,3,3,3,3,4,4,4};\n    const int tj[] = {0,2,3,4,1,2,3,4,5,2,3,4};\n    int ret = 0;\n    int max1=0,max2=0;\n    for(int i = 1; i < N-1; ++i){\n      for(int j = 1; j < N-1; ++j){\n\tif( map[i][j] > 0 ){\n\t  int x = abs(i-ti[map[i][j]] )+ abs(j-tj[map[i][j]]);\n\t  ret += x;\n\t  if( max1 < x ){\n\t    max2 = max1;\n\t    max1 = x;\n\t  }\n\t}\n      }\n    }\n    return ret;\n  }\n  bool isComplete()const{\n    return getHeuristic() == 0;\n  }\n};\n\nint IterativeDeepning(int depth, const State &now, int &ans)\n{\n\n  if( now.isComplete() ){\n    ans = min( ans , depth );\n    return ans;\n  }\n  int least = depth+now.getHeuristic();\n  if( least > ans ){\n    return NA;\n  }\n  // ans = min( ans, least );\n  for(int w = 0; w < 2; ++w){\n    for(int dir = 0; dir < DIRMAX; ++dir){\n      State next = now;\n      if( next.move( w, dir ) ){\n\tans = min( ans, IterativeDeepning( depth + 1, next, ans ) );\n      }\n    }\n  }\n  return NA;\n}\n\nint main()\n{\n  while(true){\n    int map[N][N];\n    int ans;\n    fill(&map[0][0],&map[N-1][N],-1);\n    \n    const int imax[] = {1,3,5,3,1};\n    const int dj[] = {2,1,0,1,2};\n    for(int i = 0; i < 5; ++i){\n      for(int j = 0; j < imax[i]; ++j){\n\tint t;\n\tcin >> t;\n\tif( t < 0 ) return 0;\n\tmap[i+1][j+dj[i]+1]=t;\n      }\n    }\n\n    /*\n    for(int i = 0; i < N; ++i){\n      for(int j = 0; j < N; ++j){\n\tcout << setw(3) << map[i][j] << ' ';\n      }\n      cout << endl;\n    }\n    cout << endl;\n    */\n\n    ans = NA;\n    IterativeDeepning( 0, State(map), ans );\n    if( ans >= NA ){\n      cout << \"NA\" << endl;\n    }else{\n      cout << ans << endl;\n    }\n      \n  }\n  return 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include <iostream>\n#include <map>\n#include <queue>\n#include <cstdlib>\n#include <vector>\nusing namespace std;\n#define rep(i,n) for(int i=0;i<n;i++)\n\nint to[13][5] = {\n\t{2,-1},\n\t{2,5,-1},\n\t{0,1,3,6,-1},\n\t{2,7,-1},\n\t{5,-1},\n\t{1,4,6,9,-1},\n\t{2,5,7,10,-1},\n\t{3,6,8,11,-1},\n\t{7,-1},\n\t{5,10,-1},\n\t{6,9,11,12},\n\t{7,10,-1},\n\t{10,-1}\n};\nint solve(vector<int> data){\n\tqueue< vector<int> > Q;\n\tmap<vector<int>,int> done;\n\tQ.push(data);\n\tdone[Q.front()] = 0;\n\t\n\twhile(Q.size()){\n\t\tvector<int> q = Q.front(); Q.pop();\n\t\tint dif = 0;\n\t\trep(i,13)if(q[i])dif += abs(i-q[i]);\n\t\tif(dif==0)return done[q];\n\t\tif(dif/2+done[q]>=20)continue;\n\t\tint curcost = done[q];\n\t\trep(x,13){\n\t\t\tif(q[x] == 0){\n\t\t\t\trep(i,5){\n\t\t\t\t\tif(!~to[x][i])break;\n\t\t\t\t\tswap(q[x],q[to[x][i]]);\n\t\t\t\t\tif(done.find(q) == done.end() ){\n\t\t\t\t\t\tdone[q] = curcost+1;\n\t\t\t\t\t\tQ.push(q);\n\t\t\t\t\t}\n\t\t\t\t\tswap(q[x],q[to[x][i]]);\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t}\n\treturn 21;\n}\nint main(){\n\tvector<int> data(13);\n\twhile(1){\n\t\trep(i,13)if(!(cin >> data[i]))return 0;\n\t\tint ans = solve(data);\n\t\tif(ans > 20)cout << \"NA\" << endl;\n\t\telse cout << ans << endl;\n\t}\n}"
  },
  {
    "language": "C++",
    "code": "#include<iostream>\n#include<cmath>\n#include<stdio.h>\nusing namespace std;\n \n#define LIMIT 20\n \nstruct Puzzle {\n  int cont[25];\n  int space[2];\n};\n \nint limit;\n \nPuzzle puzzle;\n \nint tx[12]={0,1,2,3,0,1,2,3,4,1,2,3};\nint ty[12]={0,1,1,1,2,2,2,2,2,3,3,3};\nint dx[4]={0,1,0,-1};\nint dy[4]={-1,0,1,0};\n \nint heuris[12][25];\n \nint getHeuristic(){\n  int res=0;\n  for(int i=0;i<25;i++){\n    if(puzzle.cont[i]==-1||puzzle.cont[i]==0)continue;\n    res+=heuris[puzzle.cont[i]][i];\n  }\n  return res;\n}\n \nbool dfs(int depth,int prev0,int prev1){\n   \n  int heuri;\n  heuri=getHeuristic();\n  /*\n  cout<<depth<<' '<<heuri<<endl;\n  for(int i=0;i<5;i++){\n    for(int j=0;j<5;j++){\n      if(puzzle.cont[i*5+j]!=-1)printf(\"%3d\",puzzle.cont[i*5+j]);\n      else cout<<\"???\";\n    }\n    cout<<endl;\n  }\n  */\n  if(heuri==0){\n    cout<<depth<<endl;\n    return true;\n  }\n  if(depth + heuri>limit)return false;\n \n  int px,py,nx,ny;\n  Puzzle tmp=puzzle;\n \n  py=puzzle.space[0]/5;\n  px=puzzle.space[0]%5;\n  for(int i=0;i<4;i++){\n    if(max(prev0,i)-min(prev0,i)==2)continue;\n    ny=py+dy[i];nx=px+dx[i];\n    if(ny<0||ny>=5||nx<0||nx>=5)continue;\n    if(puzzle.cont[ny*5+nx]==-1)continue;\n    if(puzzle.cont[ny*5+nx]==0)continue;\n    puzzle.cont[py*5+px]=puzzle.cont[ny*5+nx];\n    puzzle.cont[ny*5+nx]=0;\n    puzzle.space[0]=ny*5+nx;\n    if(dfs(depth+1,i,prev1))return true;\n    puzzle=tmp;\n  }\n \n  py=puzzle.space[1]/5;\n  px=puzzle.space[1]%5;\n  for(int i=0;i<4;i++){\n    if(max(prev1,i)-min(prev1,i)==2)continue;\n    ny=py+dy[i];nx=px+dx[i];\n    if(ny<0||ny>=5||nx<0||nx>=5)continue;\n    if(puzzle.cont[ny*5+nx]==-1)continue;\n    if(puzzle.cont[ny*5+nx]==0)continue;\n    puzzle.cont[py*5+px]=puzzle.cont[ny*5+nx];\n    puzzle.cont[ny*5+nx]=0;\n    puzzle.space[1]=ny*5+nx;\n    if(dfs(depth+1,prev0,i))return true;\n    puzzle=tmp;\n  }\n  return false;\n}\n \nvoid solve(){\n  Puzzle tmp=puzzle;\n  for(limit=getHeuristic();limit<=LIMIT;limit++){\n    puzzle=tmp;\n    if(dfs(0,-100,-100))return;\n  }\n  cout<<\"NA\"<<endl;\n}\n \nint main(){\n  int x,y,c=0;\n \n  for(int i=1;i<=11;i++){\n    for(int j=0;j<25;j++){\n      y=j/5;\n      x=j%5;\n      heuris[i][j]=abs(tx[i]-x)+abs(ty[i]-y);\n    }\n  }\n  /*\n  for(int i=1;i<=11;i++){\n    for(int j=0;j<5;j++){\n      for(int k=0;k<5;k++){\n    cout<<heuris[i][j*5+k]<<' ';\n      }\n      cout<<endl;\n    }\n    cout<<endl;\n  }\n  */\n \n \n  while(1){\n    c=0;\n    for(int i=0;i<25;i++)puzzle.cont[i]=-1;\n \n    cin>>puzzle.cont[2];\n    if(puzzle.cont[2]==-1)break;\n    if(puzzle.cont[2]==0)puzzle.space[c++]=2;\n     \n     \n    for(int i=6;i<=8;i++){\n      cin>>puzzle.cont[i];\n      if(puzzle.cont[i]==0)puzzle.space[c++]=i;\n    }\n    for(int i=10;i<=14;i++){\n      cin>>puzzle.cont[i];\n      if(puzzle.cont[i]==0)puzzle.space[c++]=i;\n    }\n     \n    for(int i=16;i<=18;i++){\n      cin>>puzzle.cont[i];\n      if(puzzle.cont[i]==0)puzzle.space[c++]=i;\n    }\n     \n    cin>>puzzle.cont[22];\n    if(puzzle.cont[22]==0)puzzle.space[c++]=22;\n    solve();\n  }\n \n  return 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include <cstdio>\n#include <cstdlib>\n#include <cmath>\n#include <climits>\n#include <cfloat>\n#include <map>\n#include <utility>\n#include <set>\n#include <iostream>\n#include <memory>\n#include <string>\n#include <vector>\n#include <algorithm>\n#include <functional>\n#include <sstream>\n#include <complex>\n#include <stack>\n#include <queue>\n#include <cstring>\n#include <sstream>\n#include <cassert>\n#include <list>\nusing namespace std;\nstatic const double EPS = 1e-10;\ntypedef long long ll;\ntypedef pair<int,int> PI;\ntypedef vector<int> vi;\n#ifndef M_PI\n#define M_PI 3.14159265358979323846\n#endif\n#define rep(i,n) for(int i=0;i<(int)n;++i)\n#define FOR(i,c) for(__typeof((c).begin())i=(c).begin();i!=(c).end();++i)\n#define ALL(c) (c).begin(), (c).end()\n#define mp(a,b) make_pair(a,b)\n#define pb(a) push_back(a)\n#define F first\n#define S second\ntemplate <typename T> string print_array(const vector<T> &V) { ostringstream os; os << \"{ \"; for (typename vector<T>::const_iterator iter = V.begin(); iter != V.end(); ++iter) os << '\\\"' << *iter << \"\\\",\"; os << \" }\"; return os.str(); }\n\nint dx[]={0,1,0,-1},dy[]={1,0,-1,0};\n\nvector<int> se[13];\nint x[]={0,-1,0,1,-2,-1,0,1,2,-1,0,1,0};\nint y[]={2,1,1,1,0,0,0,0,0,-1,-1,-1,-2};\n\nvoid pr(ll in){\n\n  printf(\"      %3lld\\n\",in&15);\n  printf(\"   %3lld%3lld%3lld\\n\",(in>>4)&15,(in>>8)&15,(in>>12)&15);\n  printf(\"%3lld%3lld%3lld%3lld%3lld\\n\",(in>>16)&15,(in>>20)&15,(in>>24)&15,(in>>28)&15,(in>>32)&15);\n  printf(\"   %3lld%3lld%3lld\\n\",(in>>36)&15,(in>>40)&15,(in>>44)&15);\n  printf(\"      %3lld\\n\",(in>>48)&15);\n  puts(\"\");\n}\n\nint manh(ll in){\n  int ret=0;\n  rep(i,13){\n    int t=(in>>(i*4))&15;\n\n    if(!t)continue;\n    int nx=(x[t]-x[i]),ny=y[t]-y[i];\n    ret+=abs(nx)+abs(ny);\n  }\n  return ret;\n}\n\nmain(){\n  ll p;\n\n  ll goal=0;\n  rep(i,11){\n    goal|=(i+1LL)<<(4*(i+1));\n    //cout<<goal<<endl;\n    //pr(goal);\n  }\n  //pr(goal);\n\n  se[0].pb(2);\n  se[1].pb(2);\n  se[1].pb(5);\n  se[2].pb(0);\n  se[2].pb(1);\n  se[2].pb(3);\n  se[2].pb(6);\n  se[3].pb(2);\n  se[3].pb(7);\n  se[4].pb(5);\n  se[5].pb(1);\n  se[5].pb(4);\n  se[5].pb(6);\n  se[5].pb(9);\n  se[6].pb(2);\n  se[6].pb(5);\n  se[6].pb(7);\n  se[6].pb(10);\n  se[7].pb(3);\n  se[7].pb(6);\n  se[7].pb(8);\n  se[7].pb(11);\n  se[8].pb(7);\n  se[9].pb(5);\n  se[9].pb(10);\n  se[10].pb(6);\n  se[10].pb(9);\n  se[10].pb(11);\n  se[10].pb(12);\n  se[11].pb(7);\n  se[11].pb(10);\n  se[12].pb(10);\n  \n  while(cin>>p){\n    if(p==-1)break;\n    ll in=p;\n\n    rep(i,12){\n      cin>>p;\n      in|=p<<(4*(i+1));\n    }\n\n    set<ll> app;\n\n    queue<pair<int,ll> > Q;\n    app.insert(in);\n    Q.push(mp(0,in));\n    int ans=21;\n    int mans=0;\n\n    while(!Q.empty()){\n      ll cvec=Q.front().S;\n      int ccost=Q.front().F;\n      Q.pop();\n    \n      //pr(cvec);\n\n      //if(ccost>3)break;\n      if(ccost+manh(cvec)+8>20)continue;\n      if(cvec==goal){\n\tans=ccost;\n\tbreak;\n      }\n      rep(i,13){\n\tll t=cvec>>(i<<2);\n\tt=t&15;\n\tif(!t){\n\t  rep(j,se[i].size()){\n\t    t=cvec>>(se[i][j]<<2);\n\t    t=t&15;\n\t    if(t){\n\t      ll nvec=cvec;\n\t      t=t<<(i<<2);\n\t      nvec|=t;\n\t      nvec&=~(15LL<<se[i][j]*4);\n\t      \n\t      if(!app.count(nvec)){\n\t\tapp.insert(nvec);\n\t\tQ.push(mp(ccost+1,nvec));\n\t      }\n\t    }\n\t  }\n\t}\n      }\n    }\n    if(ans==21)cout<<\"NA\"<<endl;\n    else cout<<ans<<endl;\n  }\n}"
  },
  {
    "language": "C++",
    "code": "#include <iostream>\n#include <sstream>\n#include <cstdio>\n#include <cstdlib>\n#include <cmath>\n#include <ctime>\n#include <cstring>\n#include <climits>\n#include <algorithm>\n#include <map>\n#include <set>\n#include <stack>\n#include <vector>\n#include <queue>\n#include <bitset>\n#include <string>\nusing namespace std;\n \n#define rep(i,n) for(int i=0; i<n; i++)\n#define repa(i,s,e) for(int i=s; i<=e; i++)\n#define repd(i,s,e) for(int i=s; i>=e; i--)\n#define PB(a) push_back(a)\n#define MP(i,s) make_pair(i,s)\n \ntypedef long long ll;\n\nconst int dx[4] = {-1, 0, 0, 1};\nconst int dy[4] = {0, -1, 1, 0};\nconst int field[5][5] = {\n\t{0, 0, 1, 0, 0}, \n\t{0, 1, 1, 1, 0},\n\t{1, 1, 1, 1, 1},\n\t{0, 1, 1, 1, 0},\n\t{0, 0, 1, 0, 0}, \n};\n\nconst int ans[5][5] = {\n\t{0, 0, 0, 0, 0},\n\t{0, 1, 2, 3, 0},\n\t{4, 5, 6, 7, 8},\n\t{0, 9, 10, 11, 0},\n\t{0, 0, 0, 0, 0}\n};\n\nconst int px[13] = {2, 1, 2, 3, 0, 1, 2, 3, 4, 1, 2, 3, 2};\nconst int py[13] = {0, 1, 1, 1, 2, 2, 2, 2, 2, 3, 3, 3, 4};\n\nint P[5][5];\nmap<ll,int> used;\nmap<ll,int> H;\n\nll hash_val() {\n\tll h = 0;\n\trep(i,13) {\n\t\th *= 13;\n\t\th += P[py[i]][px[i]];\n\t}\n\treturn h;\n}\n\nvoid make_ans(int m, int d) {\n\tll h = hash_val();\n\tif(m == d) return;\n\tmap<ll,int>::iterator it = H.find(h);\n\t\n\tif(it == H.end()) {\n\t\tused.insert(MP(h,m));\n\t} else if((*it).second > m) {\n\t\t(*it).second = m;\n\t} else {\n\t\treturn;\n\t}\n\n\tH.insert(MP(h,m));\n\trep(i,13) {\n\t\tint x = px[i];\n\t\tint y = py[i];\n\t\tif(P[y][x] == 0) {\n\t\t\trep(k,4) {\n\t\t\t\tint xx = x + dx[k];\n\t\t\t\tint yy = y + dy[k];\n\t\t\t\tif(xx>=0 && yy>=0 && xx<5 && yy<5 && field[yy][xx] == 1 && P[yy][xx] != 0) {\n\t\t\t\t\tswap(P[y][x], P[yy][xx]);\n\t\t\t\t\tmake_ans(m+1, d);\n\t\t\t\t\tswap(P[y][x], P[yy][xx]);\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t}\n}\n\nint dfs(int m, int d) {\n\tmap<ll,int>::iterator it;\n\tll h = hash_val();\n\n\tit = H.find(h);\n\tif(it != H.end()) return m + (*it).second;\n\n\tif(m == d) return -1;\n\t\n\tit = used.find(h);\n\tif(it == used.end()) {\n\t\tused.insert(MP(h,m));\n\t} else if((*it).second > m) {\n\t\t(*it).second = m;\n\t} else {\n\t\treturn -1;\n\t}\n\n\trep(i,13) {\n\t\tint x = px[i];\n\t\tint y = py[i];\n\t\tif(P[y][x] == 0) {\n\t\t\trep(k,4) {\n\t\t\t\tint xx = x + dx[k];\n\t\t\t\tint yy = y + dy[k];\n\t\t\t\tif(xx>=0 && yy>=0 && xx<5 && yy<5 && field[yy][xx] == 1 && P[yy][xx] != 0) {\n\t\t\t\t\tswap(P[y][x], P[yy][xx]);\n\t\t\t\t\tint a = dfs(m+1, d);\n\t\t\t\t\tif(a >= 0) return a;\n\t\t\t\t\tswap(P[y][x], P[yy][xx]);\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t}\n\treturn -1;\n}\n\nvoid solve() {\n\trepa(d,0,10) {\n\t\tused.clear();\n\t\tint a = dfs(0, d);\n\t\tif(a >= 0 && a <= 20) {\n\t\t\tprintf(\"%d\\n\", a);\n\t\t\treturn;\n\t\t}\n\t}\n\tprintf(\"NA\\n\");\n}\n\nint main() {\n\tmemcpy(P, ans, sizeof(P));\n\tmake_ans(0, 10);\n\tfor(;;) {\n\t\trep(i,13) {\n\t\t\tscanf(\"%d\", &P[py[i]][px[i]]);\n\t\t\tif(P[py[i]][px[i]] < 0) return 0;\n\t\t}\n\t\tsolve();\n\t}\n}"
  },
  {
    "language": "C++",
    "code": "#include<iostream>\n#include<queue>\n#include<algorithm>\n#include<map>\n\nusing namespace std;\n\nconst int SIZE = 13;\n\nstruct Puzzle{\n  short c[SIZE];\n  \n  void move(int d, int n){\n    if(d == 0) moveUp(n);\n    if(d == 1) moveDown(n);\n    if(d == 2) moveLeft(n);\n    if(d == 3) moveRight(n);\n  }\n  // n = choosed blank number 0(first one) or 1(second one)\n  void moveUp(int n){\n    int pos = findBlankPosition(n);\n    int tmp[] = {-1,-1,0,-1,-1,1,2,3,-1,5,6,7,10};\n    \n    int npos = tmp[pos];\n    if(npos != -1) swap(c[pos],c[npos]);\n  }\n\n  void moveDown(int n){\n    int pos = findBlankPosition(n);\n    int tmp[] = {2,5,6,7,-1,9,10,11,-1,-1,12,-1,-1};\n    \n    int npos = tmp[pos];\n    if(npos != -1) swap(c[pos],c[npos]);\n  }\n\n  void moveLeft(int n){\n    int pos = findBlankPosition(n);\n    int tmp[] = {-1,-1,1,2,-1,4,5,6,7,-1,9,10,-1};\n    \n    int npos = tmp[pos];\n    if(npos != -1) swap(c[pos],c[npos]);\n  }\n\n  void moveRight(int n){\n    int pos = findBlankPosition(n);\n    int tmp[] = {-1,2,3,-1,5,6,7,8,-1,10,11,-1,-1};\n    \n    int npos = tmp[pos];\n    if(npos != -1) swap(c[pos],c[npos]);\n  }\n\n  int findBlankPosition(int n){\n    for(int i = 0; i < SIZE; i++){\n      if(c[i] == 0) n--;\n      if(n < 0) return i;\n    }\n    return -1;\n  }\n\n  bool operator < (const Puzzle& p) const {\n    for(int i = 0; i < SIZE; i++)\n      if(c[i] != p.c[i]) return c[i] < p.c[i];\n    return false;\n  }\n};\n\nPuzzle puz;\n\nbool input(){\n  cin >> puz.c[0];\n  if(puz.c[0] == -1) return false;\n  for(int i = 1; i < SIZE; i++) cin >> puz.c[i];\n  return true;\n}\n\nvoid solve(){\n  map<Puzzle, int> M;\n  M[puz] = 1;\n \n  queue<Puzzle> Q;\n  Q.push(puz);\n\n  while(!Q.empty()){\n    Puzzle now = Q.front(); Q.pop();\n  \n    for(int i = 0; i < 4; i++)\n      for(int j = 0; j < 2; j++){\n\tPuzzle nex = now;\n\tnex.move(i,j);\n\tif(M[nex] > M[now]+1|| M[nex] == 0){\n\t  M[nex] = M[now]+1;\n\t  if(M[nex] < 11) Q.push(nex);\n\t}\n      }\n  }\n\n  Puzzle tmp;\n  for(int i = 0; i < SIZE; i++) tmp.c[i] = i%(SIZE-1);\n\n \n  int ans = 25;\n  Q.push(tmp);\n  map<Puzzle,int> MG;\n  MG[tmp] = 1;\n  while(!Q.empty()){\n    Puzzle now = Q.front(); Q.pop();\n    if(M[now] != 0) ans = min(ans,M[now]+MG[now]-2);\n    for(int i = 0; i < 4; i++)\n      for(int j = 0; j < 2; j++){\n\tPuzzle nex = now;\n\tnex.move(i,j);\n      \n        if(MG[nex] > MG[now]+1 || MG[nex] == 0){\n\t  MG[nex] = MG[now]+1;\n\t  if(MG[nex] < 11) Q.push(nex);\n\t}\n      }\n    }\n    if(ans <= 20) cout << ans << endl;\n    else cout << \"NA\" << endl;\n}\n\nint main(){\n  while(input()) solve();\n  return 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include <iostream>\n#include <iomanip>\n#include <vector>\n#include <map>\n#include <set>\n#include <queue>\n#include <cmath>\nusing namespace std;\n\n#define NONE -1\n\n#include <windows.h>\nvoid print( const vector < vector <int> > &F )\n{\n\tfor ( int i = 0; i < 5; i++ )\n\t{\n\t\tfor ( int j = 0; j < 5; j++ )\n\t\t{\n\t\t\tcout << setw(3) << F[i][j];\n\t\t}\n\t\tcout << endl;\n\t}\n}\n\n// »ÝÌóÔ\nvector < vector <int> > F( 5, vector <int>(5,NONE) );\n// S[\nvector < vector <int> > GOAL( 5, vector <int>(5,NONE) );\n// KâÏÝ\nset < vector < vector <int> > > V;\n// ó«Ìê\nint empty_x[2];\nint empty_y[2];\nint now;\n\nint getMD();\nbool search( int );\n\nbool search( int depth )\n{\n\tif ( F == GOAL )\n\t\treturn true;\n\tif ( now + getMD() > depth )\n\t\treturn false;\n\n\tnow++;\n\tfor ( int e = 0; e < 2; e++ ) for ( int i = -1; i < 2; i++ ) for ( int j = -1; j < 2; j++ )\n\t{\n\t\tif ( i+j == 1 || i+j == -1 )\n\t\t{\n\t\t\tint ox = empty_x[e];\n\t\t\tint oy = empty_y[e];\n\t\t\tint tx = empty_x[e] + i;\n\t\t\tint ty = empty_y[e] + j;\n\n\t\t\tif ( ( tx >= 0 && tx <= 4 ) && ( ty >= 0 && ty <= 4 ) )\n\t\t\t{\n\t\t\t\tif ( F[ty][tx] != 0 && F[ty][tx] != NONE )\n\t\t\t\t{\n\t\t\t\t\t// ®©·\n\t\t\t\t\tswap( F[oy][ox], F[ty][tx] );\n\n\t\t\t\t\t// ¢JÌnÅ éÈçÎ\n\t\t\t\t\tif ( V.find( F ) == V.end() )\n\t\t\t\t\t{\n\t\t\t\t\t\tif ( search( depth ) )\n\t\t\t\t\t\t\treturn true;\n\t\t\t\t\t}\n\n\t\t\t\t\t// ß·\n\t\t\t\t\tswap( F[oy][ox], F[ty][tx] );\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t}\n\tnow--;\n\n}\n\nint getMD()\n{\n\tint md = 0;\n\tfor ( int i = 0; i < 5; i++ ) for ( int j = 0; j < 5; j++ )\n\t{\n\t\tif ( F[i][j] != GOAL[i][j] )\n\t\t{\n\t\t\t// T·\n\t\t\tbool found = false;\n\t\t\tfor ( int k = 0; k < 5; k++ )\n\t\t\t{\n\t\t\t\tfor ( int m = 0; m < 5; m++ )\n\t\t\t\t{\n\t\t\t\t\t//  Á½\n\t\t\t\t\tif ( F[i][j] == GOAL[k][m] )\n\t\t\t\t\t{\n\t\t\t\t\t\tmd += abs(k-i) + abs(m-j);\n\t\t\t\t\t\tfound = true;\n\t\t\t\t\t\tbreak;\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t\tif ( found ) break;\n\t\t\t}\n\t\t}\n\t}\n\treturn md;\n}\n\nint main( void )\n{\n\twhile ( 1 )\n\t{\n\t\t// S[ðìé\n\t\tGOAL[0][2] = 0;\n\t\tfor ( int i = 0; i < 3; i++ )\n\t\t\tGOAL[1][1+i] = i+1;\n\t\tfor ( int i = 0; i < 5; i++ )\n\t\t\tGOAL[2][i] = 4 + i;\n\t\tfor ( int i = 0; i < 3; i++ )\n\t\t\tGOAL[3][1+i] = 9 + i;\n\t\tGOAL[4][2] = 0;\n\n\t\t// üÍ\n\t\tcin >> F[0][2];\n\t\tif ( F[0][2] == -1 )\n\t\t\tbreak;\n\t\tfor ( int i = 0; i < 3; i++ )\n\t\t\tcin >> F[1][1+i];\n\t\tfor ( int i = 0; i < 5; i++ )\n\t\t\tcin >> F[2][i];\n\t\tfor ( int i = 0; i < 3; i++ )\n\t\t\tcin >> F[3][1+i];\n\t\tcin >> F[4][2];\n\n\t\t// óðT·\n\t\tint empty_count = 0;\n\t\tfor ( int i = 0; i < 5; i++ )\n\t\t{\n\t\t\tfor ( int j = 0; j < 5; j++ )\n\t\t\t{\n\t\t\t\tif ( F[i][j] == 0 )\n\t\t\t\t{\n\t\t\t\t\tempty_x[empty_count] = j;\n\t\t\t\t\tempty_y[empty_count] = i;\n\t\t\t\t\tempty_count++;\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\n\t\t// ½[»[³DæTõ\n\t\tV.insert( F );\n\t\tnow = 0;\n\t\tbool goal_flag = false;\n\t\tfor ( int i = 0; i < 20; i++ )\n\t\t{\n\t\t\tif ( search( i ) )\n\t\t\t{\n\t\t\t\tgoal_flag = true;\n\t\t\t\tbreak;\n\t\t\t}\n\t\t}\n\n\t\tif ( goal_flag )\n\t\t\tcout << now << endl;\n\t\telse\n\t\t\tcout << \"NA\" << endl;\n\n\t}\n\treturn 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include<iostream>\n#include<vector>\n#include<map>\n#include<queue>\n#include<algorithm>\nusing namespace std;\n\nconst int N = 13;\nconst vector<vector<int>> NEXT = {\n    {2},\n    {2, 5},\n    {0, 1, 3, 6},\n    {2, 7},\n    {5},\n    {1, 4, 6, 9},\n    {2, 5, 7, 10},\n    {3, 6, 8, 11},\n    {7},\n    {5, 10},\n    {6, 9, 11, 12},\n    {7, 10},\n    {10},\n};\n\nclass Node {\npublic:\n    vector<int> puzzle;\n    int depth;\n    Node(const vector<int>& p, int d) :puzzle(p), depth(d) {}\n};\n\nmap<vector<int>, int> memo1;\nmap<vector<int>, int> memo2;\n\nvoid bfs(const vector<int>& puzzle, map<vector<int>, int>& memo) {\n    queue<Node> q;\n    q.push(Node(puzzle, 0));\n    while(!q.empty()) {\n        Node current(q.front()); q.pop();\n        if(current.depth > 10) continue;\n        if(memo.count(current.puzzle)) continue;\n        memo[current.puzzle] = current.depth;\n        for(int i = 0; i < N; ++i) {\n            if(current.puzzle[i] != 0) continue;\n            for(const auto& j: NEXT[i]) {\n                vector<int> next(current.puzzle);\n                swap(next[i], next[j]);\n                q.push(Node(next, current.depth + 1));\n            }\n        }\n    }\n}\n\nint main() {\n    bfs({0, 1, 2, 3, 4, 5, 6, 7, 8, 9, 10, 11, 0}, memo1);\n    vector<int> puzzle(N);\n    while(cin >> puzzle[0], puzzle[0] != -1) {\n        for(int i = 1; i < N; ++i) cin >> puzzle[i];\n        memo2.clear();\n        bfs(puzzle, memo2);\n        int answer = 21;\n        for(auto& i: memo1) if(memo2.count(get<0>(i))) answer = min(answer, get<1>(i) + memo2[get<0>(i)]);\n        if(answer > 20) cout << \"NA\" << endl;\n        else cout << answer << endl;\n    }\n}"
  },
  {
    "language": "C++",
    "code": "#include <iostream>\n#include <map>\n#include <queue>\n#include <cstdlib>\n#include <vector>\nusing namespace std;\n#define rep(i,n) for(int i=0;i<n;i++)\n\nint to[13][5] = {\n\t{2,-1},\n\t{2,5,-1},\n\t{0,1,3,6,-1},\n\t{2,7,-1},\n\t{5,-1},\n\t{1,4,6,9,-1},\n\t{2,5,7,10,-1},\n\t{3,6,8,11,-1},\n\t{7,-1},\n\t{5,10,-1},\n\t{6,9,11,12},\n\t{7,10,-1},\n\t{10,-1}\n};\nint X[]={2,1,2,3,0,1,2,3,4,1,2,3,2};\nint Y[]={0,1,1,1,2,2,2,2,2,3,3,3,4};\n\nint solve(vector<int> data){\n\tqueue< vector<int> > Q;\n\tmap<vector<int>,int> done;\n\tQ.push(data);\n\tdone[Q.front()] = 0;\n\t\n\twhile(Q.size()){\n\t\tvector<int> q = Q.front(); Q.pop();\n\t\tint dif = 0;\n\t\trep(i,13)if(q[i])dif += abs(X[q[i]]-X[i])+abs(Y[q[i]]-Y[i]);\n\t\tif(dif==0)return done[q];;\n\t\tif(dif+done[q]>20)continue;\n\t\tint curcost = done[q];\n\t\trep(x,13){\n\t\t\tif(q[x] == 0){\n\t\t\t\trep(i,5){\n\t\t\t\t\tif(!~to[x][i])break;\n\t\t\t\t\tswap(q[x],q[to[x][i]]);\n\t\t\t\t\tif(done.find(q) == done.end() ){\n\t\t\t\t\t\tdone[q] = curcost+1;\n\t\t\t\t\t\tQ.push(q);\n\t\t\t\t\t}\n\t\t\t\t\tswap(q[x],q[to[x][i]]);\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t}\n\treturn 21;\n}\nint main(){\n\tvector<int> data(13);\n\twhile(1){\n\t\trep(i,13)if(!(cin >> data[i]))return 0;\n\t\tint ans = solve(data);\n\t\tif(ans > 20)cout << \"NA\" << endl;\n\t\telse cout << ans << endl;\n\t}\n}"
  },
  {
    "language": "C++",
    "code": "#include<bits/stdc++.h>\n#define r(i,n) for(int i=0;i<n;i++)\nusing namespace std;\ntypedef pair<vector<int>,int>P;\nvector<int>v[13],s(13),t(13);\nmap<vector<int>,int>m;\nvoid init(){\n\n    v[0].push_back(2);\n\n    v[1].push_back(2);\n    v[1].push_back(5);\n\n    v[2].push_back(0);\n    v[2].push_back(1);\n    v[2].push_back(3);\n    v[2].push_back(6);\n\n    v[3].push_back(2);\n    v[3].push_back(7);\n\n    v[4].push_back(5);\n\n    v[5].push_back(1);\n    v[5].push_back(4);\n    v[5].push_back(6);\n    v[5].push_back(9);\n\n    v[6].push_back(2);\n    v[6].push_back(5);\n    v[6].push_back(7);\n    v[6].push_back(10);\n\n    v[7].push_back(3);\n    v[7].push_back(6);\n    v[7].push_back(8);\n    v[7].push_back(11);\n\n    v[8].push_back(7);\n\n    v[9].push_back(5);\n    v[9].push_back(10);\n\n    v[10].push_back(6);\n    v[10].push_back(9);\n    v[10].push_back(11);\n    v[10].push_back(12);\n\n    v[11].push_back(7);\n    v[11].push_back(10);\n\n    v[12].push_back(10);\n}\nvoid BFS1(){\n    s[0]=0;\n    s[12]=0;\n    r(i,11)s[i+1]=i+1;\n    set<vector<int> >st;\n    st.insert(s);\n    m[s]=0;\n    queue<P>q;\n    q.push(P(s,0));\n    while(1){\n        vector<int>now=q.front().first;\n        int cost=q.front().second;\n        q.pop();\n        if(cost==6)break;\n        r(i,13)if(now[i]!=0){\n            r(j,v[i].size()){\n                swap(now[i],now[v[i][j]]);\n                if(!st.count(now)){\n                    st.insert(now);\n                    m[now]=cost+1;\n                    q.push(P(now,cost+1));\n                }\n                swap(now[i],now[v[i][j]]);\n            }\n        }\n    }\n}\n\nvoid BFS2(){\n    set<vector<int> >st;\n    st.insert(t);\n    queue<P>q;\n    q.push(P(t,0));\n    while(1){\n        vector<int>now=q.front().first;\n        int cost=q.front().second;\n        if(m.count(now)){\n            cout<<m[now]+cost<<endl;\n            return ;\n        }\n        q.pop();\n        if(cost==5)break;\n        r(i,13)if(now[i]!=0){\n            r(j,v[i].size()){\n                swap(now[i],now[v[i][j]]);\n                if(!st.count(now)){\n                    st.insert(now);\n                    q.push(P(now,cost+1));\n                }\n                swap(now[i],now[v[i][j]]);\n            }\n        }\n    }\n    cout<<\"NA\"<<endl;\n}\n\n\nint main(){\n    init();\n    BFS1();\n    while(cin>>t[0],t[0]!=-1){\n        r(i,12)cin>>t[i+1];\n        BFS2();\n    }\n}\n"
  },
  {
    "language": "C++",
    "code": "#include<iostream>\n#include<vector>\n#include<queue>\n#include<map>\n#include<cmath>\n#include<cstdlib>\n#include<algorithm>\nusing namespace std;\n\nstring ans;\n\nclass board{\npublic:\n  int h,c;\n  string s;\n  board(int x,int y,string z){ h=x; c=y; s=z;}\n  const bool operator<(const board x)const{return (h+c>x.h+x.c) || (h+c==x.h+x.c && c>x.c); }\n};\n\nint score(string s){\n  int res=0;\n  for(int i=0;i<25;i++){\n    if(s[i]!='x'){\n      int m=20;\n      for(int j=0;j<25;j++){\n\tif(s[i]==ans[j]){\n\t  int a = abs(i-j);\n\t  int tmp = a/5 + a%5;\n\t  m = min(m,tmp);\n\t  if(s[i]!='o')break;\n\t}\n      }\n      res += m;\n    }\n  }\n  return res/2;\n}\n\nchar trans(int x){\n  if(!x)return 'o';\n  else return 'a'+x-1;\n}\n\nint main(){\n  string s;\n  ans = \"xxoxxxabcxdefghxijkxxxoxx\";\n  int tmp,cost;\n\n  for(;;){\n    cin >> tmp;\n    if(tmp<0)break;\n\n    s = \"xx\";\n    s += trans(tmp);\n    s += \"xxx\";\n    for(int i=0;i<3;i++){\n      cin >> tmp;\n      s += trans(tmp);\n    }\n    s += \"x\";\n    for(int i=0;i<5;i++){\n      cin >> tmp;\n      s += trans(tmp);\n    }\n    s += \"x\";\n    for(int i=0;i<3;i++){\n      cin >> tmp;\n      s+= trans(tmp);\n    }\n    s += \"xxx\";\n    cin >> tmp;\n    s += trans(tmp);\n    s += \"xx\";\n\n    priority_queue<board> q1;\n    q1.push(board(score(s),0,s));\n\n    map<string,bool> m1;\n    m1[s] = 0;\n    while(q1.size()){\n      board p = q1.top();q1.pop();\n      int dx[] = {-5,1,5,-1};\n      //cout << p.h << \" \" << p.c << \" \" << p.s << endl;\n      cost = p.c;\n      if(p.s == ans)break;\n      if(cost>20)break;\n\n      for(int i=0;i<25;i++){\n\tif(p.s[i]=='o'){\n\t  for(int j=0;j<4;j++){\n\t    int sx = i + dx[j];\n\t    string str = p.s;\n\t    if(sx<0 || 25<=sx)continue;\n\t    if(str[sx] == 'x' || str[sx] == 'o')continue;\n\t    swap(str[i],str[sx]);\n\t    if(!m1[str]){\n\t      q1.push(board(score(str),cost+1,str));\n\t      m1[str] = cost+1;\n\t    }\n\t  }\n\t}\n      }\n    }\n\n\n\n    if(cost>20)cout << \"NA\\n\";\n    else cout << cost << endl;\n  }\n}"
  },
  {
    "language": "C++",
    "code": "#include <stdio.h>\n#include <cmath>\n#include <algorithm>\n#include <cfloat>\n#include <stack>\n#include <queue>\n#include <vector>\n#include <string>\n#include <iostream>\n#include <set>\n#include <map>\ntypedef long long int ll;\ntypedef unsigned long long int ull;\n#define BIG_NUM 2000000000\n#define MOD 1000000007\n#define EPS 0.000000001\nusing namespace std;\n\nstruct Info{\n\tshort table[5][5];\n\tint space_row1,space_col1,space_row2,space_col2;\n};\n\nmap<string,bool> MAP;\n\nbool rangeCheck(int row,int col){\n\tif(row < 0 || row >= 5)return false;\n\n\tswitch(row){\n\tcase 0:\n\t\tif(col == 2)return true;\n\t\tbreak;\n\tcase 1:\n\t\tif(col >= 1 && col <= 3)return true;\n\t\tbreak;\n\tcase 2:\n\t\tif(col >= 0 && col <= 4)return true;\n\t\tbreak;\n\tcase 3:\n\t\tif(col >= 1 && col <= 3)return true;\n\t\tbreak;\n\tcase 4:\n\t\tif(col == 2)return true;\n\t\tbreak;\n\t}\n\treturn false;\n}\n\nbool clearFLG;\nint ans;\nint p[13];\nint diff_row[4] = {-1,0,0,1},diff_col[4] = {0,-1,1,0};\n\n\nvoid copyInfo(Info& to,Info from){\n\n\tfor(int row = 0; row <= 4; row++){\n\t\tfor(int col = 0; col <= 4; col++){\n\t\t\tto.table[row][col] = from.table[row][col];\n\t\t}\n\t}\n}\n\nint calc_manhattan_sum(Info info){\n\n\tint sum = 0;\n\tfor(int row = 0; row <= 4; row++){\n\t\tfor(int col = 0; col <= 4; col++){\n\t\t\tif(rangeCheck(row,col) == true && info.table[row][col] != 0){\n\t\t\t\tswitch(info.table[row][col]){\n\t\t\t\tcase 1:\n\t\t\t\t\tsum += abs(row-1)+abs(col-1);\n\t\t\t\t\tbreak;\n\t\t\t\tcase 2:\n\t\t\t\t\tsum += abs(row-1)+abs(col-2);\n\t\t\t\t\tbreak;\n\t\t\t\tcase 3:\n\t\t\t\t\tsum += abs(row-1)+abs(col-3);\n\t\t\t\t\tbreak;\n\t\t\t\tcase 4:\n\t\t\t\t\tsum += abs(row-2)+abs(col-0);\n\t\t\t\t\tbreak;\n\t\t\t\tcase 5:\n\t\t\t\t\tsum += abs(row-2)+abs(col-1);\n\t\t\t\t\tbreak;\n\t\t\t\tcase 6:\n\t\t\t\t\tsum += abs(row-2)+abs(col-2);\n\t\t\t\t\tbreak;\n\t\t\t\tcase 7:\n\t\t\t\t\tsum += abs(row-2)+abs(col-3);\n\t\t\t\t\tbreak;\n\t\t\t\tcase 8:\n\t\t\t\t\tsum += abs(row-2)+abs(col-4);\n\t\t\t\t\tbreak;\n\t\t\t\tcase 9:\n\t\t\t\t\tsum += abs(row-3)+abs(col-1);\n\t\t\t\t\tbreak;\n\t\t\t\tcase 10:\n\t\t\t\t\tsum += abs(row-3)+abs(col-2);\n\t\t\t\t\tbreak;\n\t\t\t\tcase 11:\n\t\t\t\t\tsum += abs(row-3)+abs(col-3);\n\t\t\t\t\tbreak;\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t}\n\treturn sum;\n}\n\n\nvoid recursive(Info info,int depth,int max_depth){\n\n\tif(clearFLG)return;\n\n\tif(depth == max_depth){\n\t\tif(info.table[1][1] == 1 && info.table[1][2] == 2 && info.table[1][3] == 3 &&\n\t\t\t\tinfo.table[2][0] == 4 && info.table[2][1] == 5 && info.table[2][2] == 6 && info.table[2][3] == 7 && info.table[2][4] == 8 &&\n\t\t\t\tinfo.table[3][1] == 9 && info.table[3][2] == 10 && info.table[3][3] == 11){\n\t\t\tclearFLG = true;\n\t\t}\n\t\treturn;\n\t}\n\n\tint adj_row,adj_col;\n\n\tfor(int i = 0; i < 4; i++){\n\t\tadj_row = info.space_row1+diff_row[i];\n\t\tadj_col = info.space_col1+diff_col[i];\n\n\t\tif(rangeCheck(adj_row,adj_col) == false || info.table[adj_row][adj_col] == 0)continue;\n\n\t\tInfo next_info;\n\t\tcopyInfo(next_info,info);\n\n\t\tswap(next_info.table[info.space_row1][info.space_col1],next_info.table[adj_row][adj_col]);\n\n\t\tstring tmp;\n\t\tfor(int row = 0; row <= 4; row++){\n\t\t\tfor(int col = 0; col <= 4; col++){\n\t\t\t\tif(rangeCheck(row,col)){\n\t\t\t\t\ttmp.append(to_string(next_info.table[row][col])).append(to_string('*'));\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\n\t\tauto at = MAP.find(tmp);\n\t\tif(at != MAP.end())continue;\n\n\t\tMAP[tmp] = true;\n\n\t\tnext_info.space_row1 = adj_row;\n\t\tnext_info.space_col1 = adj_col;\n\t\tnext_info.space_row2 = info.space_row2;\n\t\tnext_info.space_col2 = info.space_col2;\n\n\t\tif(max_depth-(depth+1) < calc_manhattan_sum(next_info))continue;\n\n\t\trecursive(next_info,depth+1,max_depth);\n\t}\n\n\tfor(int i = 0; i < 4; i++){\n\t\tadj_row = info.space_row2+diff_row[i];\n\t\tadj_col = info.space_col2+diff_col[i];\n\n\t\tif(rangeCheck(adj_row,adj_col) == false || info.table[adj_row][adj_col] == 0)continue;\n\n\t\tInfo next_info;\n\t\tcopyInfo(next_info,info);\n\n\t\tswap(next_info.table[info.space_row2][info.space_col2],next_info.table[adj_row][adj_col]);\n\n\t\tstring tmp;\n\t\tfor(int row = 0; row <= 4; row++){\n\t\t\tfor(int col = 0; col <= 4; col++){\n\t\t\t\tif(rangeCheck(row,col)){\n\t\t\t\t\ttmp.append(to_string(next_info.table[row][col])).append(to_string('*'));\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\n\t\tauto at = MAP.find(tmp);\n\t\tif(at != MAP.end())continue;\n\n\t\tMAP[tmp] = true;\n\n\t\tnext_info.space_row1 = info.space_row1;\n\t\tnext_info.space_col1 = info.space_col1;\n\t\tnext_info.space_row2 = adj_row;\n\t\tnext_info.space_col2 = adj_col;\n\n\t\tif(max_depth-(depth+1) < calc_manhattan_sum(next_info))continue;\n\n\t\trecursive(next_info,depth+1,max_depth);\n\t}\n}\n\nvoid func(){\n\n\tfor(int i = 1; i < 13; i++)scanf(\"%d\",&p[i]);\n\n\tInfo first;\n\tfirst.table[0][2] = p[0];\n\tfor(int i = 1; i <= 3; i++)first.table[1][i] = p[i];\n\tfor(int i = 0; i <= 4; i++)first.table[2][i] = p[4+i];\n\tfor(int i = 1; i <= 3; i++)first.table[3][i] = p[8+i];\n\tfirst.table[4][2] = p[12];\n\n\tint count = 0;\n\n\tfor(int row = 0; row <= 4; row++){\n\t\tfor(int col = 0; col <= 4; col++){\n\t\t\tif(rangeCheck(row,col) == true && first.table[row][col] == 0){\n\t\t\t\tif(count == 0){\n\t\t\t\t\tfirst.space_row1 = row;\n\t\t\t\t\tfirst.space_col1 = col;\n\t\t\t\t\tcount++;\n\t\t\t\t}else{\n\t\t\t\t\tfirst.space_row2 = row;\n\t\t\t\t\tfirst.space_col2 = col;\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t}\n\n\tclearFLG = false;\n\n\tfor(int max_depth = 0; max_depth <= 20; max_depth++){\n\t\tMAP.clear();\n\n\t\tstring tmp;\n\t\tfor(int row = 0; row <= 4; row++){\n\t\t\tfor(int col = 0; col <= 4; col++){\n\t\t\t\tif(rangeCheck(row,col)){\n\t\t\t\t\ttmp.append(to_string(first.table[row][col])).append(to_string('*'));\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\n\t\tMAP[tmp] = true;\n\n\t\trecursive(first,0,max_depth);\n\t\tif(clearFLG){\n\t\t\tans = max_depth;\n\t\t\tbreak;\n\t\t}\n\t}\n\n\tif(clearFLG){\n\t\tprintf(\"%d\\n\",ans);\n\t}else{\n\t\tprintf(\"NA\\n\");\n\t}\n}\n\nint main(){\n\n\twhile(true){\n\t\tscanf(\"%d\",&p[0]);\n\t\tif(p[0] == -1)break;\n\n\t\tfunc();\n\t}\n\n\treturn 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include<iostream>\n#include<cmath>\n#include<stdio.h>\nusing namespace std;\n\n#define LIMIT 20\n\nstruct Puzzle {\n  int cont[25];\n  int space[2];\n};\n\nint limit;\n\nPuzzle puzzle;\n\nint tx[12]={0,1,2,3,0,1,2,3,4,1,2,3};\nint ty[12]={0,1,1,1,2,2,2,2,2,3,3,3};\nint dx[4]={0,1,0,-1};\nint dy[4]={-1,0,1,0};\n\nint heuris[12][25];\n\nint getHeuristic(){\n  int res=0;\n  for(int i=0;i<25;i++){\n    if(puzzle.cont[i]==-1||puzzle.cont[i]==0)continue;\n    if(i%5==tx[puzzle.cont[i]]&&i/5==ty[puzzle.cont[i]]){}else res++;//=heuris[puzzle.cont[i]][i];\n  }\n  return res;\n}\n\nbool dfs(int depth,int prev0,int prev1){\n  /*\n  cout<<depth<<endl;\n  for(int i=0;i<5;i++){\n    for(int j=0;j<5;j++){\n      if(puzzle.cont[i*5+j]!=-1)printf(\"%3d\",puzzle.cont[i*5+j]);\n      else cout<<\"???\";\n    }\n    cout<<endl;\n  }\n  */\n  int heuri;\n  heuri=getHeuristic();\n  if(heuri==0){\n    cout<<depth<<endl;\n    return true;\n  }\n  if(depth + heuri>limit)return false;\n\n  int px,py,nx,ny;\n  Puzzle tmp=puzzle;\n\n  py=puzzle.space[0]/5;px=puzzle.space[0]%5;\n\n  for(int i=0;i<4;i++){\n    if(max(prev0,i)-min(prev0,i)==2)continue;\n    ny=py+dy[i];nx=px+dx[i];\n    if(ny<0||ny>=5||nx<0||nx>=5)continue;\n    if(puzzle.cont[ny*5+nx]==-1)continue;\n    if(puzzle.cont[ny*5+nx]==0)continue;\n    puzzle.cont[py*5+px]=puzzle.cont[ny*5+nx];\n    puzzle.cont[ny*5+nx]=0;\n    puzzle.space[0]=ny*5+nx;\n    if(dfs(depth+1,i,prev1))return true;\n    puzzle=tmp;\n  }\n  py=puzzle.space[1]/5;px=puzzle.space[1]%5;\n  for(int i=0;i<4;i++){\n    if(max(prev1,i)-min(prev1,i)==2)continue;\n    ny=py+dy[i];nx=px+dx[i];\n    if(ny<0||ny>=5||nx<0||nx>=5)continue;\n    if(puzzle.cont[ny*5+nx]==-1)continue;\n    if(puzzle.cont[ny*5+nx]==0)continue;\n    puzzle.cont[py*5+px]=puzzle.cont[ny*5+nx];\n    puzzle.cont[ny*5+nx]=0;\n    puzzle.space[1]=ny*5+nx;\n    if(dfs(depth+1,prev0,i))return true;\n    puzzle=tmp;\n  }\n  return false;\n}\n\nvoid solve(){\n  Puzzle tmp=puzzle;\n  for(limit=getHeuristic();limit<=LIMIT;limit++){\n    puzzle=tmp;\n    if(dfs(0,-100,-100))return;\n  }\n  cout<<\"NA\"<<endl;\n}\n\nint main(){\n  int x,y,c=0;\n\n  for(int i=1;i<=11;i++){\n    for(int j=0;j<25;j++){\n      y=j/5;\n      x=j%5;\n      heuris[i][j]=abs(tx[i]-x)+abs(ty[i]-y);\n    }\n  }\n\n\n  for(int i=0;i<25;i++)puzzle.cont[i]=-1;\n\n  while(1){\n    c=0;\n    for(int i=0;i<25;i++)puzzle.cont[i]=-1;\n    cin>>puzzle.cont[2];\n    if(puzzle.cont[2]==-1)break;\n    if(puzzle.cont[2]==0)puzzle.space[c++]=2;\n    \n    \n    for(int i=6;i<=8;i++){\n      cin>>puzzle.cont[i];\n      if(puzzle.cont[i]==0)puzzle.space[c++]=i;\n    }\n    for(int i=10;i<=14;i++){\n      cin>>puzzle.cont[i];\n      if(puzzle.cont[i]==0)puzzle.space[c++]=i;\n    }\n    \n    for(int i=16;i<=18;i++){\n      cin>>puzzle.cont[i];\n      if(puzzle.cont[i]==0)puzzle.space[c++]=i;\n    }\n    \n    cin>>puzzle.cont[22];\n    if(puzzle.cont[22]==0)puzzle.space[c++]=22;\n    solve();\n  }\n\n  return 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include <algorithm>\n#include <cctype>\n#include <climits>\n#include <cmath>\n#include <cstdio>\n#include <cstdlib>\n#include <cstring>\n#include <functional>\n#include <map>\n#include <numeric>\n#include <queue>\n#include <set>\n#include <sstream>\n#include <string>\n#include <vector>\n\nusing namespace std;\n\n#define reps(i,f,n) for(int i=f; i<int(n); ++i)\n#define rep(i,n) reps(i,0,n)\n\ntypedef long long ll;\ntypedef vector<int> vi;\ntypedef vector<vi> vvi;\ntypedef pair<int, int> pii;\n\nconst int INF = 1001001001;\nconst ll SAMPLE = 0x0ba9876543210ll;\n\nint bfs(ll init)\n{\n\tif(init == SAMPLE)\n\t\treturn 0;\n\t\n\tconst int move[13][5] = {\n\t\t{2, -1},\n\t\t{2, 5, -1},\n\t\t{0, 1, 3, 6, -1},\n\t\t{2, 7, -1},\n\t\t{5, -1},\n\t\t{1, 4, 6, 9, -1},\n\t\t{2, 5, 7, 10, -1},\n\t\t{3, 6, 8, 11, -1},\n\t\t{7, -1},\n\t\t{5, 10, -1},\n\t\t{6, 9, 11, 12, -1},\n\t\t{7, 10, -1},\n\t\t{10, -1}\n\t};\n\t\n\tset<ll> visited;\n\tqueue<pair<ll, int> > Q;\n\tQ.push(make_pair(init, 0));\n\tvisited.insert(init);\n\twhile(!Q.empty()){\n\t\tpair<ll, int> data = Q.front();\n\t\tQ.pop();\n\n\t\tfor(int i=0, cnt=2; cnt; ++i){\n\t\t\tif(((data.first>>(i*4)) & 0xfll) == 0){\n\t\t\t\tfor(int j=0; move[i][j]!=-1; ++j){\n\t\t\t\t\tll next = data.first;\n\t\t\t\t\tnext &= ~((0xfll << (i*4)) | (0xfll << (move[i][j]*4)));\n\t\t\t\t\tnext |= ((data.first >> (move[i][j]*4)) & 0xfll) << (i*4);\n\t\t\t\t\tif(next == SAMPLE)\n\t\t\t\t\t\treturn data.second + 1;\n\n\t\t\t\t\tif(visited.find(next) == visited.end()){\n\t\t\t\t\t\tvisited.insert(next);\n\t\t\t\t\t\tif(data.second < 19)\n\t\t\t\t\t\t\tQ.push(make_pair(next, data.second+1));\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t\t--cnt;\n\t\t\t}\n\t\t}\n\t}\n\treturn -1;\n}\n\nint main()\n{\n\tfor(;;){\n\t\tint input[13];\n\t\trep(i, 13){\n\t\t\tscanf(\"%d\", &input[i]);\n\t\t\tif(input[i] == -1)\n\t\t\t\treturn 0;\n\t\t}\n\n\t\tll init = 0;\n\t\trep(i, 13)\n\t\t\tinit = (init << 4) | input[12-i];\n\n\t\tint ans = bfs(init);\n\t\tif(ans == -1)\n\t\t\tputs(\"NA\");\n\t\telse\n\t\t\tprintf(\"%d\\n\", ans);\n\t}\n}"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\n\nusing namespace std;\n\n#define int long long\n#define FR first\n#define SC second\n#define all(v) (v).begin(), (v).end()\n#define rep(i, n) for(int i = 0; i < (int)(n); i++)\n#define reps(i, f, n) for(int i = (int)(f); i < (int)(n); i++)\n#define each(a, b) for(auto& a : b)\n\ntypedef pair<int, int> P;\n\nconst int inf = 1LL << 55;\n\nvector< vector<int> > to = {\n  {2},\n  {2, 5},\n  {0, 1, 3, 6},\n  {2, 7},\n  {5},\n  {1, 4, 6, 9},\n  {2, 5, 7, 10},\n  {3, 6, 8, 11},\n  {7},\n  {5, 10},\n  {6, 9, 11, 12},\n  {7, 10},\n  {10}\n};\n\nvector<int> ans = {0,1,2,3,4,5,6,7,8,9,10,11,0};\n\nsigned main()\n{\n  cin.tie(0);\n  ios_base::sync_with_stdio(0);\n  cout << fixed << setprecision(12);\n\n  map<vector<int>, int> D;  \n  queue< vector<int> > que;\n  que.push(ans);\n  D[ans] = 0;\n  while(!que.empty()) {\n    auto v = que.front(); que.pop();\n    if(D[v] >= 10) break;\n    rep(i, v.size()) {\n      if(v[i]) continue;\n      rep(j, to[i].size()) {\n\tint c = D[v];\n\tswap(v[i], v[to[i][j]]);\n\tif(!D.count(v)) {\n\t  que.push(v);\n\t  D[v] = c + 1;\n\t}\n\tswap(v[i], v[to[i][j]]);\t\n      }\n    }\n  }\n  \n  int p;\n  while(cin >> p, ~p) {\n    vector<int> pzl; pzl.push_back(p);\n    rep(i, 12) cin >> p, pzl.push_back(p);\n    map<vector<int>, int> d;\n    queue< vector<int> > que;\n    que.push(pzl);\n    d[pzl] = 0;\n    bool flag = false;\n    while(!que.empty() && !flag) {\n      auto v = que.front(); que.pop();\n      if(v == ans) {\n\tcout << d[v] << endl;\n\tflag = true;\n\tbreak;\n      }\n      if(d[v] >= 10) break;\n      rep(i, v.size()) {\n\tif(v[i]) continue;\n\trep(j, to[i].size()) {\n\t  int c = d[v];\n\t  swap(v[i], v[to[i][j]]);\n\t  if(D.count(v)) {\n\t    cout << D[v] + c + 1 << endl;\n\t    flag = true;\n\t    break;\n\t  } else if(!d.count(v)) {\n\t    que.push(v);\n\t    d[v] = c + 1;\n\t  }\n\t  swap(v[i], v[to[i][j]]);\n\t}\n\tif(flag) break;\n      }\n    }\n    if(!flag) cout << \"NA\" << endl;\n  }\n  return 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include<iostream>\n#include<algorithm>\n#include<vector>\n#include<cmath>\nusing namespace std;\n#define MAX_N 20\n#define WIDTH 100\nint OK[5][5] = { {0,0,1,0,0},{0,1,1,1,0},{1,1,1,1,1},{0,1,1,1,0},{0,0,1,0,0} };\nint dx[4] = { 1,0,-1,0 }, dy[4] = { 0,1,0,-1 };\npair<int, vector<vector<int>>> dp[MAX_N + 2][WIDTH], E[WIDTH * 10];\n\nint score(vector<vector<int>>p) {\n\tint sum = 0; pair<int, int>a[12], b[12]; int CNT = 0;\n\tfor (int i = 0; i < 25; i++) {\n\t\tif (p[i / 5][i % 5] >= 1)a[p[i / 5][i % 5]] = make_pair(i / 5, i % 5);\n\t}\n\tfor (int i = 5; i < 20; i++) {\n\t\tif (OK[i / 5][i % 5] == 1) { CNT++; b[CNT] = make_pair(i / 5, i % 5); }\n\t}\n\tfor (int i = 1; i <= 11; i++) { sum += abs(a[i].first - b[i].first) + abs(a[i].second - b[i].second); }\n\treturn sum;\n}\nvector<vector<int>> Move(vector<vector<int>>p, int x, int y,int dir) {\n\tswap(p[x + dx[dir]][y + dy[dir]], p[x][y]); return p;\n}\nint BeemSearch(vector<vector<int>>Z) {\n\tvector<vector<int>>GOAL; int CNT = 0;\n\tfor (int i = 0; i < 5; i++) { vector<int>GOAL2(5, -1); GOAL.push_back(GOAL2); }\n\tfor (int i = 5; i < 20; i++) {\n\t\tif (OK[i / 5][i % 5] == 1) { CNT++; GOAL[i / 5][i % 5] = CNT; }\n\t}\n\tGOAL[0][2] = 0; GOAL[4][2] = 0;\n\tif (Z == GOAL)return 0;\n\tdp[0][0] = make_pair(score(Z), Z);\n\tfor (int i = 0; i < MAX_N; i++) {\n\t\tint CNTS = 0;\n\t\tfor (int j = 0; j < WIDTH; j++) {\n\t\t\tif (dp[i][j].second.size() == 0)continue;\n\t\t\tvector<vector<int>>D = dp[i][j].second;\n\t\t\tfor (int k = 0; k < 25; k++) {\n\t\t\t\tif (D[k / 5][k % 5] != 0)continue;\n\t\t\t\tfor (int l = 0; l < 4; l++) {\n\t\t\t\t\tint cx = (k / 5) + dx[l], cy = (k % 5) + dy[l];\n\t\t\t\t\tif (cx < 0 || cx >= 5 || cy < 0 || cy >= 5)continue;\n\t\t\t\t\tif (D[cx][cy] <= 0)continue;\n\t\t\t\t\tvector<vector<int>>D2 = Move(D, k / 5, k % 5, l);\n\t\t\t\t\tE[CNTS] = make_pair(score(D2), D2); CNTS++;\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t\tsort(E, E + CNTS); dp[i + 1][0] = E[0]; int CNT2 = 1;\n\t\tif (E[0].first == 0)return i + 1;\n\t\tfor (int i = 1; i < CNTS; i++) {\n\t\t\tif (E[i - 1] != E[i]) { dp[i + 1][CNT2] = E[i]; CNT2++; }\n\t\t\tif (CNT2 == WIDTH)break;\n\t\t}\n\t}\n\treturn -1;\n}\nint main() {\n\twhile (true) {\n\t\tfor (int i = 0; i < MAX_N + 2; i++) {\n\t\t\tfor (int j = 0; j < WIDTH; j++) {\n\t\t\t\tvector<vector<int>>ZERO; dp[i][j] = make_pair(0, ZERO);\n\t\t\t}\n\t\t}\n\t\tfor (int i = 0; i < WIDTH * 10; i++) { vector<vector<int>>ZERO; E[i] = make_pair(0, ZERO); }\n\t\tvector<vector<int>>C;\n\t\tfor (int i = 0; i < 5; i++) { vector<int>C2(5, -1); C.push_back(C2); }\n\t\tcin >> C[0][2]; if (C[0][2] == -1)break;\n\t\tfor (int i = 1; i < 4; i++)cin >> C[1][i];\n\t\tfor (int i = 0; i < 5; i++)cin >> C[2][i];\n\t\tfor (int i = 1; i < 4; i++)cin >> C[3][i]; cin >> C[4][2];\n\t\tint ret = BeemSearch(C);\n\t\tif (ret == -1)cout << \"NA\" << endl; else cout << ret << endl;\n\t}\n\treturn 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\n\nusing namespace std;\n\n#define FOR(i,a,b) for(int i=(a);i<(b);i++)\n#define REP(i,n) FOR(i,0,n)\n#define ALL(v) (v).begin(),(v).end()\n#define fi first\n#define se second\n\ntemplate<typename A, typename B> inline bool chmax(A &a, B b) { if (a<b) { a=b; return 1; } return 0; }\ntemplate<typename A, typename B> inline bool chmin(A &a, B b) { if (a>b) { a=b; return 1; } return 0; }\n\ntypedef long long ll;\ntypedef pair<int, int> pii;\ntypedef pair<ll, ll> pll;\ntypedef pair<int, pll> pip;\nconst ll INF = 1ll<<29;\nconst ll MOD = 1000000007;\nconst double EPS  = 1e-9;\n\nint dd[13][4] = {\n\t{2,-1,-1,-1},\n\t{2,5,-1,-1},\n\t{0,1,3,6},\n\t{2,7,-1,-1},\n\t{5,-1,-1,-1},\n\t{1,4,6,9},\n\t{2,5,7,10},\n\t{3,6,8,11},\n\t{7,-1,-1,-1},\n\t{5,10,-1,-1},\n\t{6,9,11,12},\n\t{7,10,-1,-1},\n\t{10,-1,-1,-1}\n};\n\nint main() {\n\tqueue<string> que;\n\tmap<string, int> d;\n\t\n\tstring ans = \"abcdefghijkla\";\n\tque.push(ans);\n\td[ans] = 0;\n\t\n\twhile (!que.empty()) {\n\t\tstring now = que.front(); que.pop();\n\t\tint cost = d[now];\n\t\t\n\t\tif (cost > 10) break;\n\t\t\n\t\tREP(i, 13) if (now[i] == 'a') {\n\t\t\tREP(j, 4) {\n\t\t\t\tif (dd[i][j] == -1) break;\n\t\t\t\t\n\t\t\t\tswap(now[i], now[dd[i][j]]);\n\t\t\t\tif (d.find(now) == d.end()) {\n\t\t\t\t\td[now] = cost + 1;\n\t\t\t\t\tque.push(now);\n\t\t\t}\n\t\t\t\tswap(now[i], now[dd[i][j]]);\n\t\t\t}\n\t\t}\n\t}\n\twhile (!que.empty()) que.pop();\n\n\tint p[13];\n\twhile (cin >> p[0], ~p[0]) {\n\t\tFOR(i, 1, 13) cin >> p[i];\n\t\tstring st = \"\";\n\t\tREP(i, 13) st += p[i] + 'a';\n\t\t\n\t\tmap<string, int> d2;\n\t\tque.push(st);\n\t\td2[st] = 0;\n\t\t\n\t\twhile (!que.empty()) {\n\t\t\tstring now = que.front(); que.pop();\n\t\t\tint cost = d2[now];\n\t\t\t\n\t\t\tif (cost > 10 || d.find(now) != d.end()) break;\n\t\t\t\n\t\t\tREP(i, 13) if (now[i] == 'a') {\n\t\t\t\tREP(j, 4) {\n\t\t\t\t\tif (dd[i][j] == -1) break;\n\t\t\t\t\t\n\t\t\t\t\tswap(now[i], now[dd[i][j]]);\n\t\t\t\t\tif (d2.find(now) == d2.end()) {\n\t\t\t\t\t\td2[now] = cost + 1;\n\t\t\t\t\t\tque.push(now);\n\t\t\t\t}\n\t\t\t\t\tswap(now[i], now[dd[i][j]]);\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t\twhile (!que.empty()) que.pop();\n\t\t\n\t\tif (d.find(st) != d.end()) cout << d[st] + d2[st] << endl;\n\t\telse puts(\"NA\");\n\t}\n\treturn 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include <cstdio>\n#include <cstring>\n#include <algorithm>\n\nusing namespace std;\n\nint fie[5][5];\nint o_fie[5][5]={\n\t-1,-1,0,-1,-1,\n\t-1,1,2,3,-1,\n\t4,5,6,7,8,\n\t-1,9,10,11,-1\n\t-1,-1,0,-1,-1,\n};\n\nint ox[12],oy[12],zx[2],zy[2],zcnt;\nint res;\nbool flag;\n\nint dx[4]={1,0,-1,0};\nint dy[4]={0,1,0,-1};\n\nvoid dfs(int v,int dist,int pd,int pu){\n\tif(dist==0){\n\t\tflag=true;\n\t\tres=min(res,v);\n\t\treturn;\n\t}\n\tfor(int i=0;i<4;i++){\n\t\tfor(int j=0;j<2;j++){\n\t\t\tif(pu==j && (pd+2)%4==i)continue;\n\t\t\tint nx=zx[j]+dx[i],ny=zy[j]+dy[i];\n\t\t\tif(nx>=0 && nx<5 && ny>=0 && ny<5){\n\t\t\t\tif(fie[nx][ny]<=0)continue;\n\t\t\t\tint ch=fie[nx][ny];\n\t\t\t\tint ndist=dist;\n\t\t\t\tndist-=abs(ox[ch]-nx)+abs(oy[ch]-ny);\n\t\t\t\tswap(fie[nx][ny],fie[zx[j]][zy[j]]);\n\t\t\t\tndist+=abs(ox[ch]-zx[j])+abs(oy[ch]-zy[j]);\n\t\t\t\tzx[j]+=dx[i];\n\t\t\t\tzy[j]+=dy[i];\n\t\t\t\tif(v+1+ndist<=res)dfs(v+1,ndist,i,j);\n\t\t\t\tzx[j]-=dx[i];\n\t\t\t\tzy[j]-=dy[i];\n\t\t\t\tswap(fie[nx][ny],fie[zx[j]][zy[j]]);\n\t\t\t}\n\t\t}\n\t}\n}\nint dist;\n\nint main(void){\n\tfor(int i=0;i<5;i++){\n\t\tfor(int j=abs(2-i);j<=4-abs(2-i);j++){\n\t\t\tox[o_fie[i][j]]=j;\n\t\t\toy[o_fie[i][j]]=i;\n\t\t}\n\t}\n\twhile(1){\n\t\tmemset(fie,-1,sizeof(fie));\n\t\tdist=0;\n\t\tzcnt=0;\n\t\tfor(int i=0;i<5;i++){\n\t\t\tfor(int j=abs(2-i);j<=4-abs(2-i);j++){\n\t\t\t\tscanf(\"%d\",&fie[j][i]);\n\t\t\t\tif(fie[j][i]==-1)return 0;\n\t\t\t}\n\t\t}\n\t\tfor(int i=0;i<5;i++){\n\t\t\tfor(int j=abs(2-i);j<=4-abs(2-i);j++){\n\t\t\t\tint v=fie[j][i];\n\t\t\t\tif(v==0){\n\t\t\t\t\tzx[zcnt]=j;\n\t\t\t\t\tzy[zcnt++]=i;\n\t\t\t\t}else dist+=abs(ox[v]-j)+abs(oy[v]-i);\n\t\t\t}\n\t\t}\n\t\tif(dist>20){\n\t\t\tprintf(\"NA\\n\");\n\t\t}else{\n\t\t\tint i=0;\n\t\t\tflag=false;\n\t\t\tres=20;\n\t\t\tdfs(0,dist,-1,-1);\n\t\t\tif(flag){\n\t\t\t\tprintf(\"%d\\n\",res);\n\t\t\t}\n\t\t\tif(!flag)printf(\"NA\\n\");\n\t\t}\n\t}\n\treturn 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include<iostream>\n#include<map>\n#include<deque>\n#include<cstring>\n#include<cstdlib>\nusing namespace std;\nstruct board{\n\tchar s[14];\n\tint z1,z2;\n\tbool operator<(const board& rhs)const{return strcmp(s,rhs.s)<0;}\n};\nint main(){\n\tint d[13][5]={\n\t\t{2,-1},\t\t\t//0\n\t\t{2,5,-1},\t\t//1\n\t\t{0,1,3,6,-1},\t//2\n\t\t{2,7,-1},\t\t//3\n\t\t{5,-1},\t\t\t//4\n\t\t{1,4,6,9,-1},\t//5\n\t\t{2,5,7,10,-1},\t//6\n\t\t{3,6,8,11,-1},\t//7\n\t\t{7,-1},\t\t\t//8\n\t\t{5,10,-1},\t\t//9\n\t\t{6,9,11,12,-1},\t//10\n\t\t{7,10,-1},\t\t//11\n\t\t{10,-1},\t\t//12\n\t};\n\tint gx[]={2,1,2,3,0,1,2,3,4,1,2,3,2};\n\tint gy[]={0,1,1,1,2,2,2,2,2,3,3,3,4};\n\tboard goal;\n\tstrcpy(goal.s,\"0123456789:;0\");\n\tfor(;;){\n\t\ttypedef map<board,int>SM;\n\t\tSM stepmap;\n\t\tdeque<board> que;\n\t\tboard b0;\n\t\tb0.z1=b0.z2=-1;\n\t\tfor(int i=0;i<13;i++){\n\t\t\tint v;\n\t\t\tcin>>v;\n\t\t\tif(v==-1)\n\t\t\t\treturn 0;\n\t\t\tb0.s[i]='0'+v;\n\t\t\tif(v==0){\n\t\t\t\tif(b0.z1==-1)\n\t\t\t\t\tb0.z1=i;\n\t\t\t\telse\n\t\t\t\t\tb0.z2=i;\n\t\t\t}\n\t\t}\n\t\tb0.s[13]=0;\n\t\tque.push_back(b0);\n\t\tstepmap[b0]=1;\n\t\twhile(!que.empty()){\n\t\t\tboard b=que.front();\n\t\t\tif(strcmp(b.s,goal.s)==0){\n\t\t\t\tbreak;\n\t\t\t}\n\t\t\tque.pop_front();\n\t\t\tint dist=0;\n\t\t\tfor(int i=0;i<13;i++){\n\t\t\t\tint v=b.s[i]-'0';\n\t\t\t\tif(v){\n\t\t\t\t\tdist+=abs(gx[v]-gx[i])+abs(gy[v]-gy[i]);\n\t\t\t\t}\n\t\t\t}\n\t\t\tint step=stepmap[b];\n\t\t\tif(step-1+dist<=20){\n\t\t\t\tfor(int i=0;d[b.z1][i]!=-1;i++){\n\t\t\t\t\tboard bn=b;\n\t\t\t\t\tbn.z1=d[b.z1][i];\n\t\t\t\t\tif(bn.z1!=bn.z2){\n\t\t\t\t\t\tswap(bn.s[b.z1],bn.s[bn.z1]);\n\t\t\t\t\t\tint&ns=stepmap[bn];\n\t\t\t\t\t\tif(!ns){\n\t\t\t\t\t\t\tns=step+1;\n\t\t\t\t\t\t\tque.push_back(bn);\n\t\t\t\t\t\t}\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t\tfor(int i=0;d[b.z2][i]!=-1;i++){\n\t\t\t\t\tboard bn=b;\n\t\t\t\t\tbn.z2=d[b.z2][i];\n\t\t\t\t\tif(bn.z2!=bn.z1){\n\t\t\t\t\t\tswap(bn.s[b.z2],bn.s[bn.z2]);\n\t\t\t\t\t\tint&ns=stepmap[bn];\n\t\t\t\t\t\tif(!ns){\n\t\t\t\t\t\t\tns=step+1;\n\t\t\t\t\t\t\tque.push_back(bn);\n\t\t\t\t\t\t}\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t\tif(stepmap[goal]==0)\n\t\t\tcout<<\"NA \"<<endl;\n\t\telse\n\t\t\tcout<<stepmap[goal]-1<<endl;\n\t}\n}"
  },
  {
    "language": "C++",
    "code": "#include <iostream>\n#include <vector>\n\nusing namespace std;\n \nstruct P {\n    int x, y;\n    P(int x, int y) : x{x}, y{y} {}\n};\n \nint limit;\nvector<int> v;\n\nconstexpr int X[] = {2, 1, 2, 3, 0, 1, 2, 3, 4, 1, 2, 3, 2};\nconstexpr int Y[] = {0, 1, 1, 1, 2, 2, 2, 2, 2, 3, 3, 3, 4};\n \nint getPos(P p)\n{\n    switch (p.y) {\n        case 0:\n            return (p.x == 2 ? 0 : -1);\n        case 1:\n            return (1 <= p.x && p.x <= 3 ? p.x : -1);\n        case 2:\n            return (p.x <= 4 ? p.x + 4 : -1); \n        case 3:\n            return (1 <= p.x && p.x <= 3 ? p.x + 8 : -1);\n        case 4:\n            return (p.x == 2 ? 12 : -1);\n    }\n    return -1;\n}\n \nint getMD()\n{\n    int sum = 0;\n    for (int i = 0; i < 13; i++) {\n        if (v[i] == 0) continue;\n        P np{X[i], Y[i]};\n        P tp{X[v[i]], Y[v[i]]};\n        sum += abs(np.x - tp.x) + abs(np.y - tp.y);\n    }\n    return sum;\n}\n \nconstexpr int dx[] = {-1, 0, 1, 0};\nconstexpr int dy[] = {0, -1, 0, 1};\n \nbool dfs(const int* sp, int step)\n{\n    int md = getMD();\n    if (md == 0) return 1;\n    if (md + step > limit) {\n        return 0;\n    }\n    \n    for (int i = 0; i < 2; i++) {\n        int x = X[sp[i]], y = Y[sp[i]];\n        for (int j = 0; j < 4; j++) {\n            int nx = x + dx[j], ny = y + dy[j];\n            P np{nx, ny};\n            \n            int next = getPos(np);\n            if (next == -1) continue;\n            \n            int nsp1[] = {next, sp[1]}, nsp2[] = {sp[0], next};\n            \n            swap(v[sp[i]], v[next]);\n            if (i == 0 && dfs(nsp1, step + 1)) {\n                return 1;\n            }\n            if (i == 1 && dfs(nsp2, step + 1)) {\n                return 1;\n            }\n            swap(v[sp[i]], v[next]);\n        }\n    }\n    return 0;\n}\n \nint main()\n{\n    int x;\n    while (cin >> x, x != -1) {\n        int sp[2];\n        v.resize(13); v[0] = x;\n        for (int i = 1, j = 0; i < 13; i++) {\n            cin >> v[i];\n            if (v[i] == 0) {\n                sp[j++] = i;\n            }\n        }\n\n        bool found = 0;\n        constexpr int LIMIT = 20;\n        for (limit = 0; limit <= LIMIT; limit++) {\n            if (dfs(sp, 0)) {\n                cout << limit << endl;\n                found = 1;\n                break;\n            }\n        }\n        if (!found) {\n            cout << \"NA\" << endl;\n        }\n    }\n    return 0;\n}"
  },
  {
    "language": "C",
    "code": "#include <stdio.h>\n#include <math.h>\n#include <stdlib.h>\n\ntypedef struct{\n\tlong long int code;\n\tint steps;\n} puzz;\n\nint SW,q[10000000][14],size[2][30000];\nlong long int FR,TO;\npuzz* hash[2][30000][100];\n\nvoid swap (int* x,int* y){\n\tint z;\n\tz=*x;\n\t*x=*y;\n\t*y=z;\n}\n\nlong long int convert(int a[]){\n\tlong long int ret=0;\n\tint i;\n\tfor(i=0;i<13;i++)ret=ret*13+a[i];\n\treturn ret;\n}\n\nvoid hashadd(long long int code,int step,int loc){\n\tint ccc=code%30000;\n\tpuzz* ppp=(puzz*)malloc(sizeof(puzz));\n\tppp->code=code;\n\tppp->steps=step;\n\tif(size[loc][ccc]>99){fprintf(stderr,\"SIZE OVER!! (%d)\\n\",ccc);return;}\n\thash[loc][ccc][size[loc][ccc]]=ppp;\n\tsize[loc][ccc]++;\n}\n\nint hashsearch(long long int code,int loc){\n\tint ccc=code%30000;\n\tint i=size[loc][ccc]-1;\n\tfor(;i>=0;i--){\n\t\tif(hash[loc][ccc][i]->code==code)return hash[loc][ccc][i]->steps;\n\t}\n\treturn -1;\n}\n\nvoid mark(int x,int y){\n\tint k;\n\tlong long int cd;\n\n\tswap(&q[FR][x],&q[FR][y]);\n\tcd=convert(q[FR]);\n\n\tif(hashsearch(cd,SW)<0){\n\t\tfor(k=0;k<14;k++){q[TO][k]=q[FR][k];}\n\t\tq[TO][13]++;\n\t\tif(SW==0)hashadd(cd,q[TO][13],SW);\n\t\tTO++;\n\t}\n\n\tswap(&q[FR][x],&q[FR][y]);\n\n}\n\nvoid check(){\n\tif(q[FR][0]==0){mark(0,2);}\n\tif(q[FR][1]==0){mark(1,2);mark(1,5);}\n\tif(q[FR][2]==0){mark(2,0);mark(2,1);mark(2,3);mark(2,6);}\n\tif(q[FR][3]==0){mark(3,2);mark(3,7);}\n\tif(q[FR][4]==0){mark(4,5);}\n\tif(q[FR][5]==0){mark(5,1);mark(5,4);mark(5,6);mark(5,9);}\n\tif(q[FR][6]==0){mark(6,2);mark(6,5);mark(6,7);mark(6,10);}\n\tif(q[FR][7]==0){mark(7,3);mark(7,6);mark(7,8);mark(7,11);}\n\tif(q[FR][8]==0){mark(8,7);}\n\tif(q[FR][9]==0){mark(9,5);mark(9,10);}\n\tif(q[FR][10]==0){mark(10,6);mark(10,9);mark(10,11);mark(10,12);}\n\tif(q[FR][11]==0){mark(11,7);mark(11,10);}\n\tif(q[FR][12]==0){mark(12,10);}\n}\n\n\nint main(){\n\tint i,ans;\n\tlong long int cd;\n\n\tfor(i=1;i<12;i++)q[0][i]=i;\n\tq[0][0]=0;q[0][12]=0;q[0][13]=0;\n\thashadd(convert(q[0]),0,0);\n\n\tFR=0;TO=1;SW=0;\n\n\twhile(FR<TO && q[FR][13]<=13){\n\t\tcheck();\n\t\tFR++;\n\t}\n\n\twhile(scanf(\"%d\",&q[0][0])*q[0][0]>=0){\n\t\tfor(i=1;i<13;i++)scanf(\"%d\",&q[0][i]);\n\t\tq[0][13]=0;FR=0;TO=1;SW=1;ans=9999;\n\t\tfor(i=0;i<30000;i++)size[1][i]=0;\n\n\t\twhile(FR<TO){\n\t\t\tcd=hashsearch(convert(q[FR]),0);\n\t\t\tif(cd>=0){\n\t\t\t\tans=(int)cd+q[FR][13];\n\t\t\t\tbreak;\n\t\t\t}\n\t\t\tif(q[FR][13]<6)check();\n\t\t\tFR++;\n\t\t}\n\n\t\tif(ans>20)printf(\"NA\\n\"); else printf(\"%d\\n\",ans);\n\t}\n\n\treturn 0;\n}"
  },
  {
    "language": "C",
    "code": "// Aizu Vol-1 0190: Eleven Puzzle\n// 2017.8.23 bal4u@uu\n// ???????????¢?´¢??????????????\\??????????????§??¶????????§??????\n// ????????????????????????16?????????????????§??§???OK???\n// 1????????????????????§8??????4??????????????§4096????????¶??????\n\n#include <stdio.h>\n\n#define MAX 500000\ntypedef unsigned long long UL;\n\ntypedef struct { UL s; char m; } HASH;\ntypedef struct { UL s; char b1, b2; } QUE;\n#define HASHSIZ 900001ULL\nHASH hash[HASHSIZ + 5], *hashend = hash + HASHSIZ;\nQUE Q[MAX + 5], *top, *end, *qmax = Q + MAX;\n\nint lookup(UL s)\n{\n\tHASH *p = hash + s % HASHSIZ;\n\twhile (p->s) {\n\t\tif (p->s == s) return p->m;\n\t\tif (++p == hashend) p = hash;\n\t}\n\treturn -1;\n}\n\nint insert(UL s, char m)\n{\n\tHASH *p = hash + s % HASHSIZ;\n\twhile (p->s) {\n\t\tif (p->s == s) return 0;\n\t\tif (++p == hashend) p = hash;\n\t}\n\tp->s = s, p->m = m;\n\treturn 1;\n}\n\nint move[13][5] = {\n\t/*  0 */{ 2, -1 },\n\t/*  1 */{ 2, 5, -1 },\n\t/*  2 */{ 0, 1, 3, 6, -1 },\n\t/*  3 */{ 2, 7, -1 },\n\t/*  4 */{ 5, -1 },\n\t/*  5 */{ 1, 4, 6, 9, -1 },\n\t/*  6 */{ 2, 5, 7, 10, -1 },\n\t/*  7 */{ 3, 6, 8, 11, -1 },\n\t/*  8 */{ 7, -1 },\n\t/*  9 */{ 5, 10, -1 },\n\t/* 10 */{ 6, 9, 11, 12, -1 },\n\t/* 11 */{ 7, 10, -1 },\n\t/* 12 */{ 10, -1 } };\n\nUL swap(UL s, int p1, int sp)\n{\n\tUL n1;\n\tp1 = (12 - p1) << 2, sp = (12 - sp) << 2;\n\tn1 = (s >> p1) & 0xf;\n\ts &= ~(0xfULL << p1);\n\ts |= (n1 << sp);\n\treturn s;\n}\n\nint sach(UL s, int b1, int b2, int mode, int step, int lim)\n{\n\tint i, j, k, x, b[2];\n\tUL s2;\n\n\ttop = end = Q;\n\tend->s = s, end->b1 = b1, end->b2 = b2, end++, end->s = 0, end++;\n\twhile (top < end) {\n\t\ts = top->s, b[0] = top->b1, b[1] = top->b2, top++;\n\t\tif (!s) { step++, end->s = 0, end++; continue; }\n\t\tif (step > lim) break;\n//\tprintf(\"%#15llx, b1 %2d, b2 %2d, step %2d\\n\", s, b[0], b[1], step);\n\t\tfor (i = 0; i < 2; i++) {\n\t\t\tfor (j = 0; (x = move[b[i]][j]) >= 0; j++) {\n\t\t\t\tif (x == b[0] || x == b[1]) continue;\n\t\t\t\ts2 = swap(s, x, b[i]);\n\t\t\t\tif (mode) { if ((k = lookup(s2) >= 0)) return k; }\n\t\t\t\telse if (!insert(s2, step)) continue;\n\t\t\t\tend->s = s2;\n\t\t\t\tif (i) end->b1 = b[0], end->b2 = x;\n\t\t\t\telse   end->b1 = x, end->b2 = b[1];\n\t\t\t\tend++;\n\t\t\t}\n\t\t}\n\t}\n\treturn step;\n}\n\nint main()\n{\n\tint i, ans, p, b1, b2;\n\tUL s;\n\n\ts = 0x123456789ab0ULL, insert(s, 0);\n\tsach(s, 0, 12, 0, 1, 16);\n\twhile (1) {\n\t\tb1 = -1;\n\t\tfor (s = i = 0; i < 13; i++) {\n\t\t\tscanf(\"%d\", &p);\n\t\t\tif (i == 0 && p < 0) return 0;\n\t\t\tif (!p) { if (b1 < 0) b1 = i; else b2 = i; }\n\t\t\ts = (s << 4) | p;\n\t\t}\n\t\tif ((ans = lookup(s)) < 0) {\n\t\t\tif ((ans = sach(s, b1, b2, 1, 0, 4)) > 4) ans = -1;\n\t\t\telse ans += 16;\n\t\t}\n\t\tprintf(ans < 0 ? \"NA\\n\" : \"%d\\n\", ans);\t\n\t}\n\treturn 0;\n}"
  },
  {
    "language": "C",
    "code": "#include <stdio.h>\n#include <math.h>\n#include <stdlib.h>\n\ntypedef struct{\n\tlong long int code;\n\tint steps;\n} puzz;\n\nint q[10000000][14],size[30000];\nlong long int FR,TO,SW;\npuzz* hash[30000][100];\n\nvoid swap (int* x,int* y){\n\tint z;\n\tz=*x;\n\t*x=*y;\n\t*y=z;\n}\n\nlong long int convert(int a[]){\n\tlong long int ret=0;\n\tint i;\n\tfor(i=0;i<13;i++)ret=ret*13+a[i];\n\treturn ret;\n}\n\nvoid hashadd(long long int code,int step){\n\tint ccc=code%30000;\n\tpuzz* ppp=(puzz*)malloc(sizeof(puzz));\n\tppp->code=code;\n\tppp->steps=step;\n\tif(size[ccc]>99){fprintf(stderr,\"SIZE OVER!! (%d)\\n\",ccc);return;}\n\thash[ccc][size[ccc]]=ppp;\n\tsize[ccc]++;\n}\n\nint hashsearch(long long int code){\n\tint ccc=code%30000;\n\tint i=size[ccc]-1;\n\tfor(;i>=0;i--){\n\t\tif(hash[ccc][i]->code==code)return hash[ccc][i]->steps;\n\t}\n\treturn -1;\n}\n\nvoid mark(int x,int y){\n\tint k;\n\tlong long int cd;\n\n\tswap(&q[FR][x],&q[FR][y]);\n\tcd=convert(q[FR]);\n\n\tif(SW==1 || hashsearch(cd)<0){\n\t\tfor(k=0;k<14;k++){q[TO][k]=q[FR][k];}\n\t\tq[TO][13]++;\n\t\tif(SW==0)hashadd(cd,q[TO][13]);\n\t\tTO++;\n\t}\n\n\tswap(&q[FR][x],&q[FR][y]);\n\n}\n\nvoid check(){\n\tif(q[FR][0]==0){mark(0,2);}\n\tif(q[FR][1]==0){mark(1,2);mark(1,5);}\n\tif(q[FR][2]==0){mark(2,0);mark(2,1);mark(2,3);mark(2,6);}\n\tif(q[FR][3]==0){mark(3,2);mark(3,7);}\n\tif(q[FR][4]==0){mark(4,5);}\n\tif(q[FR][5]==0){mark(5,1);mark(5,4);mark(5,6);mark(5,9);}\n\tif(q[FR][6]==0){mark(6,2);mark(6,5);mark(6,7);mark(6,10);}\n\tif(q[FR][7]==0){mark(7,3);mark(7,6);mark(7,8);mark(7,11);}\n\tif(q[FR][8]==0){mark(8,7);}\n\tif(q[FR][9]==0){mark(9,5);mark(9,10);}\n\tif(q[FR][10]==0){mark(10,6);mark(10,9);mark(10,11);mark(10,12);}\n\tif(q[FR][11]==0){mark(11,7);mark(11,10);}\n\tif(q[FR][12]==0){mark(12,10);}\n}\n\n\nint main(){\n\tint i,ans;\n\tlong long int cd;\n\n\tfor(i=1;i<12;i++)q[0][i]=i;\n\tq[0][0]=0;q[0][12]=0;q[0][13]=0;\n\thashadd(convert(q[0]),0);\n\n\tFR=0;TO=1;SW=0;\n\n\twhile(FR<TO && q[FR][13]<=13){\n\t\tcheck();\n\t\tFR++;\n\t}\n\n\twhile(scanf(\"%d\",&q[0][0])*q[0][0]>=0){\n\t\tfor(i=1;i<13;i++)scanf(\"%d\",&q[0][i]);\n\t\tq[0][13]=0;FR=0;TO=1;SW=1;ans=9999;\n\t\t//for(i=0;i<30000;i++)size2[i]=0;\n\n\t\twhile(FR<TO){\n\t\t\tcd=hashsearch(convert(q[FR]));\n\t\t\tif(cd>=0){\n\t\t\t\tans=(int)cd+q[FR][13];\n\t\t\t\tbreak;\n\t\t\t}\n\t\t\tif(q[FR][13]<6)check();\n\t\t\tFR++;\n\t\t}\n\n\t\tif(ans>20)printf(\"NA\\n\"); else printf(\"%d\\n\",ans);\n\t}\n\n\treturn 0;\n}"
  },
  {
    "language": "C",
    "code": "// Aizu Vol-1 0190: Eleven Puzzle\n// 2017.8.23 bal4u@uu\n// ???????????¢?´¢??????????????\\??????????????§??¶????????§??????\n// ????????????????????????16?????????????????§??§???OK???\n// 1????????????????????§8??????4??????????????§4096????????¶??????\n\n#include <stdio.h>\n\n#define MAX 500000\ntypedef unsigned long long UL;\n\ntypedef struct { UL s; char m; } HASH;\ntypedef struct { UL s; char b1, b2; } QUE;\n#define HASHSIZ 900001ULL\nHASH hash[HASHSIZ + 5], *hashend = hash + HASHSIZ;\nQUE Q[MAX + 5], *top, *end, *qmax = Q + MAX;\n\nint lookup(UL s)\n{\n\tHASH *p = hash + s % HASHSIZ;\n\twhile (p->s) {\n\t\tif (p->s == s) return p->m;\n\t\tif (++p == hashend) p = hash;\n\t}\n\treturn -1;\n}\n\nint insert(UL s, char m)\n{\n\tHASH *p = hash + s % HASHSIZ;\n\twhile (p->s) {\n\t\tif (p->s == s) return 0;\n\t\tif (++p == hashend) p = hash;\n\t}\n\tp->s = s, p->m = m;\n\treturn 1;\n}\n\nint move[13][5] = {\n\t/*  0 */{ 2, -1 },\n\t/*  1 */{ 2, 5, -1 },\n\t/*  2 */{ 0, 1, 3, 6, -1 },\n\t/*  3 */{ 2, 7, -1 },\n\t/*  4 */{ 5, -1 },\n\t/*  5 */{ 1, 4, 6, 9, -1 },\n\t/*  6 */{ 2, 5, 7, 10, -1 },\n\t/*  7 */{ 3, 6, 8, 11, -1 },\n\t/*  8 */{ 7, -1 },\n\t/*  9 */{ 5, 10, -1 },\n\t/* 10 */{ 6, 9, 11, 12, -1 },\n\t/* 11 */{ 7, 10, -1 },\n\t/* 12 */{ 10, -1 } };\n\nUL swap(UL s, int p1, int sp)\n{\n\tUL n1;\n\tp1 = (12 - p1) << 2, sp = (12 - sp) << 2;\n\tn1 = (s >> p1) & 0xf;\n\ts &= ~(0xfULL << p1);\n\ts |= (n1 << sp);\n\treturn s;\n}\n\nint sach(UL s, int b1, int b2, int mode, int step, int lim)\n{\n\tint i, j, x, b[2];\n\tUL s2;\n\n\ttop = end = Q;\n\tend->s = s, end->b1 = b1, end->b2 = b2, end++, end->s = 0, end++;\n\twhile (top < end) {\n\t\ts = top->s, b[0] = top->b1, b[1] = top->b2, top++;\n\t\tif (!s) { step++, end->s = 0, end++; continue; }\n\t\tif (step > lim) break;\n//\tprintf(\"%#15llx, b1 %2d, b2 %2d, step %2d\\n\", s, b[0], b[1], step);\n\t\tfor (i = 0; i < 2; i++) {\n\t\t\tfor (j = 0; (x = move[b[i]][j]) >= 0; j++) {\n\t\t\t\tif (x == b[0] || x == b[1]) continue;\n\t\t\t\ts2 = swap(s, x, b[i]);\n\t\t\t\tif (mode) { if (lookup(s2) >= 0) return step; }\n\t\t\t\telse if (!insert(s2, step)) continue;\n\t\t\t\tend->s = s2;\n\t\t\t\tif (i) end->b1 = b[0], end->b2 = x;\n\t\t\t\telse   end->b1 = x, end->b2 = b[1];\n\t\t\t\tend++;\n\t\t\t}\n\t\t}\n\t}\n\treturn step;\n}\n\nint main()\n{\n\tint i, ans, p, b1, b2;\n\tUL s;\n\tint lim = 16;\n\n\ts = 0x123456789ab0ULL, insert(s, 0);\n\tsach(s, 0, 12, 0, 1, lim);\n\twhile (1) {\n\t\tb1 = -1;\n\t\tfor (s = i = 0; i < 13; i++) {\n\t\t\tscanf(\"%d\", &p);\n\t\t\tif (i == 0 && p < 0) return 0;\n\t\t\tif (!p) { if (b1 < 0) b1 = i; else b2 = i; }\n\t\t\ts = (s << 4) | p;\n\t\t}\n\t\tif ((ans = lookup(s)) < 0) {\n\t\t\tif ((ans = sach(s, b1, b2, 1, 1, 4)) > 4) ans = -1;\n\t\t\telse ans += lim;\n\t\t}\n\t\tprintf(ans < 0 ? \"NA\\n\" : \"%d\\n\", ans);\t\n\t}\n\treturn 0;\n}"
  },
  {
    "language": "C",
    "code": "#include <stdio.h>\n#include <math.h>\n#include <stdlib.h>\n \ntypedef struct{\n    long long int code;\n    int steps;\n} puzz;\n \nint q[1000000][14],size[500000];\nlong long int FR,TO,SW;\npuzz* hash[500000][10];\n \nvoid swap (int* x,int* y){\n    int z;\n    z=*x;\n    *x=*y;\n    *y=z;\n}\n \nlong long int convert(int a[]){\n    long long int ret=0;\n    int i;\n    for(i=0;i<13;i++)ret=ret*13+a[i];\n    return ret;\n}\n \nvoid hashadd(long long int code,int step){\n    int ccc=code%500000;\n    puzz* ppp=(puzz*)malloc(sizeof(puzz));\n    ppp->code=code;\n    ppp->steps=step;\n    if(size[ccc]>9){fprintf(stderr,\"SIZE OVER!! (%d)\\n\",ccc);return;}\n    hash[ccc][size[ccc]]=ppp;\n    size[ccc]++;\n}\n \nint hashsearch(long long int code){\n    int ccc=code%500000;\n    int i=size[ccc]-1;\n    for(;i>=0;i--){\n        if(hash[ccc][i]->code==code)return hash[ccc][i]->steps;\n    }\n    return -1;\n}\n \nvoid mark(int x,int y){\n    int k;\n    long long int cd;\n \n    swap(&q[FR][x],&q[FR][y]);\n    cd=convert(q[FR]);\n \n    if(SW==1 || hashsearch(cd)<0){\n        for(k=0;k<14;k++){q[TO][k]=q[FR][k];}\n        q[TO][13]++;\n        if(SW==0)hashadd(cd,q[TO][13]);\n        TO++;\n    }\n \n    swap(&q[FR][x],&q[FR][y]);\n \n}\n \nvoid check(){\n    if(q[FR][0]==0){mark(0,2);}\n    if(q[FR][1]==0){mark(1,2);mark(1,5);}\n    if(q[FR][2]==0){mark(2,0);mark(2,1);mark(2,3);mark(2,6);}\n    if(q[FR][3]==0){mark(3,2);mark(3,7);}\n    if(q[FR][4]==0){mark(4,5);}\n    if(q[FR][5]==0){mark(5,1);mark(5,4);mark(5,6);mark(5,9);}\n    if(q[FR][6]==0){mark(6,2);mark(6,5);mark(6,7);mark(6,10);}\n    if(q[FR][7]==0){mark(7,3);mark(7,6);mark(7,8);mark(7,11);}\n    if(q[FR][8]==0){mark(8,7);}\n    if(q[FR][9]==0){mark(9,5);mark(9,10);}\n    if(q[FR][10]==0){mark(10,6);mark(10,9);mark(10,11);mark(10,12);}\n    if(q[FR][11]==0){mark(11,7);mark(11,10);}\n    if(q[FR][12]==0){mark(12,10);}\n}\n \n \nint main(){\n    int i,ans;\n    long long int cd;\n \n    for(i=1;i<12;i++)q[0][i]=i;\n    q[0][0]=0;q[0][12]=0;q[0][13]=0;\n    hashadd(convert(q[0]),0);\n \n    FR=0;TO=1;SW=0;\n \n    while(FR<TO && q[FR][13]<=13){\n        check();\n        FR++;\n    }\n\n    while(scanf(\"%d\",&q[0][0])*q[0][0]>=0){\n        for(i=1;i<13;i++)scanf(\"%d\",&q[0][i]);\n        q[0][13]=0;FR=0;TO=1;SW=1;ans=9999;\n \n        while(FR<TO){\n            cd=hashsearch(convert(q[FR]));\n            if(cd>=0){\n                ans=(int)cd+q[FR][13];\n                break;\n            }\n            if(q[FR][13]<6)check();\n            FR++;\n        }\n \n        if(ans>20)printf(\"NA\\n\"); else printf(\"%d\\n\",ans);\n    }\n \n    return 0;\n}"
  },
  {
    "language": "C",
    "code": "#include <stdio.h>\n#include <math.h>\n#include <stdlib.h>\n\ntypedef struct{\n\tlong long int code;\n\tint steps;\n} puzz;\n\nint q[10000000][14],size[30000],size2[30000];\nlong long int FR,TO,SW;\npuzz* hash[30000][100],hash2[30000][100];\n\nvoid swap (int* x,int* y){\n\tint z;\n\tz=*x;\n\t*x=*y;\n\t*y=z;\n}\n\nlong long int convert(int a[]){\n\tlong long int ret=0;\n\tint i;\n\tfor(i=0;i<13;i++)ret=ret*13+a[i];\n\treturn ret;\n}\n\nvoid hashadd(long long int code,int step){\n\tint ccc=code%30000;\n\tpuzz* ppp=(puzz*)malloc(sizeof(puzz));\n\tppp->code=code;\n\tppp->steps=step;\n\tif(size[ccc]>99){fprintf(stderr,\"SIZE OVER!! (%d)\\n\",ccc);return;}\n\thash[ccc][size[ccc]]=ppp;\n\tsize[ccc]++;\n}\n\nint hashsearch(long long int code){\n\tint ccc=code%30000;\n\tint i=size[ccc];\n\tfor(i--;i>=0;i--){\n\t\tif(hash[ccc][i]->code==code)return hash[ccc][i]->steps;\n\t}\n\treturn -1;\n}\n\nvoid mark(int x,int y){\n\tint k;\n\tlong long int cd;\n\n\tswap(&q[FR][x],&q[FR][y]);\n\tcd=convert(q[FR]);\n\n\tif(hashsearch(cd)<0){\n\t\tfor(k=0;k<14;k++){q[TO][k]=q[FR][k];}\n\t\tq[TO][13]++;\n\t\tif(SW==0)hashadd(cd,q[TO][13]);\n\t\tTO++;\n\t}\n\n\tswap(&q[FR][x],&q[FR][y]);\n\n}\n\nvoid check(){\n\tif(q[FR][0]==0){mark(0,2);}\n\tif(q[FR][1]==0){mark(1,2);mark(1,5);}\n\tif(q[FR][2]==0){mark(2,0);mark(2,1);mark(2,3);mark(2,6);}\n\tif(q[FR][3]==0){mark(3,2);mark(3,7);}\n\tif(q[FR][4]==0){mark(4,5);}\n\tif(q[FR][5]==0){mark(5,1);mark(5,4);mark(5,6);mark(5,9);}\n\tif(q[FR][6]==0){mark(6,2);mark(6,5);mark(6,7);mark(6,10);}\n\tif(q[FR][7]==0){mark(7,3);mark(7,6);mark(7,8);mark(7,11);}\n\tif(q[FR][8]==0){mark(8,7);}\n\tif(q[FR][9]==0){mark(9,5);mark(9,10);}\n\tif(q[FR][10]==0){mark(10,6);mark(10,9);mark(10,11);mark(10,12);}\n\tif(q[FR][11]==0){mark(11,7);mark(11,10);}\n\tif(q[FR][12]==0){mark(12,10);}\n}\n\n\nint main(){\n\tint i;\n\tlong long int cd;\n\n\tfor(i=1;i<12;i++)q[0][i]=i;\n\tq[0][12]=0;q[0][13]=0;\n\n\tFR=0;TO=1;SW=0;\n\n\twhile(FR<TO && q[FR][13]<=13){\n\t\tcheck();\n\t\tFR++;\n\t}\n\n\twhile(scanf(\"%d\",&q[0][0])*q[0][0]>=0){\n\t\tfor(i=1;i<13;i++)scanf(\"%d\",&q[0][i]);\n\t\tq[0][13]=0;FR=0;TO=1;SW=1;\n\t\t//for(i=0;i<30000;i++)size2[i]=0;\n\n\t\twhile(FR<TO && q[FR][13]<=6){\n\t\t\tcd=hashsearch(convert(q[FR]));\n\t\t\tif(cd>=0){printf(\"%d\\n\",cd+q[FR][13]);break;}\n\t\t\tif(q[FR][13]<6)check();\n\t\t\tFR++;\n\t\t}\n\n\t\tif(FR>=TO)printf(\"NA\\n\");\n\t}\n\n\treturn 0;\n}"
  },
  {
    "language": "C",
    "code": "#include <stdio.h>\n#include <math.h>\n#include <stdlib.h>\n\ntypedef struct{\n\tlong long int code;\n\tint steps;\n} puzz;\n\nint q[10000000][14],size[30000],size2[30000];\nlong long int FR,TO,SW;\npuzz* hash[30000][100],hash2[30000][100];\n\nvoid swap (int* x,int* y){\n\tint z;\n\tz=*x;\n\t*x=*y;\n\t*y=z;\n}\n\nlong long int convert(int a[]){\n\tlong long int ret=0;\n\tint i;\n\tfor(i=0;i<13;i++)ret=ret*13+a[i];\n\treturn ret;\n}\n\nvoid hashadd(long long int code,int step){\n\tint ccc=code%30000;\n\tpuzz* ppp=(puzz*)malloc(sizeof(puzz));\n\tppp->code=code;\n\tppp->steps=step;\n\tif(size[ccc]>99){fprintf(stderr,\"SIZE OVER!! (%d)\\n\",ccc);return;}\n\thash[ccc][size[ccc]]=ppp;\n\tsize[ccc]++;\n}\n\nint hashsearch(long long int code){\n\tint ccc=code%30000;\n\tint i=size[ccc];\n\tfor(i--;i>=0;i--){\n\t\tif(hash[ccc][i]->code==code)return hash[ccc][i]->steps;\n\t}\n\treturn -1;\n}\n\nvoid mark(int x,int y){\n\tint k;\n\tlong long int cd;\n\n\tswap(&q[FR][x],&q[FR][y]);\n\tcd=convert(q[FR]);\n\n\tif(SW==1 || hashsearch(cd)<0){\n\t\tfor(k=0;k<14;k++){q[TO][k]=q[FR][k];}\n\t\tq[TO][13]++;\n\t\tif(SW==0)hashadd(cd,q[TO][13]);\n\t\tTO++;\n\t}\n\n\tswap(&q[FR][x],&q[FR][y]);\n\n}\n\nvoid check(){\n\tif(q[FR][0]==0){mark(0,2);}\n\tif(q[FR][1]==0){mark(1,2);mark(1,5);}\n\tif(q[FR][2]==0){mark(2,0);mark(2,1);mark(2,3);mark(2,6);}\n\tif(q[FR][3]==0){mark(3,2);mark(3,7);}\n\tif(q[FR][4]==0){mark(4,5);}\n\tif(q[FR][5]==0){mark(5,1);mark(5,4);mark(5,6);mark(5,9);}\n\tif(q[FR][6]==0){mark(6,2);mark(6,5);mark(6,7);mark(6,10);}\n\tif(q[FR][7]==0){mark(7,3);mark(7,6);mark(7,8);mark(7,11);}\n\tif(q[FR][8]==0){mark(8,7);}\n\tif(q[FR][9]==0){mark(9,5);mark(9,10);}\n\tif(q[FR][10]==0){mark(10,6);mark(10,9);mark(10,11);mark(10,12);}\n\tif(q[FR][11]==0){mark(11,7);mark(11,10);}\n\tif(q[FR][12]==0){mark(12,10);}\n}\n\n\nint main(){\n\tint i,ans;\n\tlong long int cd;\n\n\tfor(i=1;i<12;i++)q[0][i]=i;\n\tq[0][0]=0;q[0][12]=0;q[0][13]=0;\n\n\tFR=0;TO=1;SW=0;\n\n\twhile(FR<TO && q[FR][13]<=13){\n\t\tcheck();\n\t\tFR++;\n\t}\n\n\twhile(scanf(\"%d\",&q[0][0])*q[0][0]>=0){\n\t\tfor(i=1;i<13;i++)scanf(\"%d\",&q[0][i]);\n\t\tq[0][13]=0;FR=0;TO=1;SW=1;ans=9999;\n\t\t//for(i=0;i<30000;i++)size2[i]=0;\n\n\t\twhile(FR<TO){\n\t\t\tcd=hashsearch(convert(q[FR]));\n\t\t\tif(cd>=0){\n\t\t\t\tif(cd!=14)fprintf(stderr,\"%d?\\n\",cd);\n\t\t\t\tans=(int)cd+q[FR][13];\n\t\t\t\tbreak;\n\t\t\t}\n\t\t\tif(q[FR][13]<6)check();\n\t\t\tFR++;\n\t\t}\n\n\t\tif(ans>20)printf(\"NA\\n\"); else printf(\"%d\\n\",ans);\n\t}\n\n\treturn 0;\n}"
  },
  {
    "language": "C",
    "code": "// Aizu Vol-1 0190: Eleven Puzzle\n// 2017.8.21 bal4u@uu\n// ??±???????????¢?´¢??????????????\\??????????????§??¶????????§??????\n\n#include <stdio.h>\n\n#define MAX 100000\ntypedef unsigned long long UL;\n\ntypedef struct { UL s; char m; } HASH;\ntypedef struct { UL s; char m, b1, b2; } QUE;\n#define HASHSIZ 500009ULL   // 19997\nHASH hash[HASHSIZ + 5], *hashend = hash + HASHSIZ;\nQUE Q[MAX + 5]; int top;\n\nint lookup(UL s)\n{\n\tHASH *p = hash + s % HASHSIZ;\n\twhile (p->s) {\n\t\tif (p->s == s) return p->m;\n\t\tif (++p == hashend) p = hash;\n\t}\n\treturn -1;\n}\n\nint insert(UL s, char m)\n{\n\tHASH *p = hash + s % HASHSIZ;\n\twhile (p->s) {\n\t\tif (p->s == s) {\n\t\t\tif (p->m > m) { p->m = m; return 1; }\n\t\t\treturn 0;\n\t\t}\n\t\tif (++p == hashend) p = hash;\n\t}\n\tp->s = s, p->m = m;\n\treturn 1;\n}\n\nint move[13][5] = {\n\t/*  0 */{ 2, -1 },\n\t/*  1 */{ 2, 5, -1 },\n\t/*  2 */{ 0, 1, 3, 6, -1 },\n\t/*  3 */{ 2, 7, -1 },\n\t/*  4 */{ 5, -1 },\n\t/*  5 */{ 1, 4, 6, 9, -1 },\n\t/*  6 */{ 2, 5, 7, 10, -1 },\n\t/*  7 */{ 3, 6, 8, 11, -1 },\n\t/*  8 */{ 7, -1 },\n\t/*  9 */{ 5, 10, -1 },\n\t/* 10 */{ 6, 9, 11, 12, -1 },\n\t/* 11 */{ 7, 10, -1 },\n\t/* 12 */{ 10, -1 } };\n\nUL bit[13] = {\n\t0x0ffffffffffffULL, 0xf0fffffffffffULL, 0xff0ffffffffffULL, 0xfff0fffffffffULL,\n\t0xffff0ffffffffULL, 0xfffff0fffffffULL, 0xffffff0ffffffULL, 0xfffffff0fffffULL,\n\t0xffffffff0ffffULL, 0xfffffffff0fffULL, 0xffffffffff0ffULL, 0xfffffffffff0fULL,\n\t0xffffffffffff0ULL };\n\nUL nextStep(UL s, int new, int old)\n{\n\tUL n;\n\t\n\tn = ((s >> ((12 - new) << 2))) & 0xf;\n\ts &= ( bit[new] & bit[old]);\n\ts |= (n << ((12 - old) << 2));\n\treturn s;\n}\n\nvoid state(void)\n{\n\tint i, j, k, x, step, b[2];\n\tUL s, s2;\n\n\ts = 0x123456789ab0ULL;\n\tQ[0].s = s, Q[0].m = 0, Q[0].b1 = 0, Q[0].b2 = 12, insert(s, 0);\n\ttop = 1;\n\twhile (top) {\n\t\ts = Q[--top].s, step = Q[top].m + 1;\n\t\tb[0] = Q[top].b1, b[1] = Q[top].b2;\n\t\tif (step > 20) continue;\n//\tprintf(\"%0llx, b1 %d, b2 %d, step %d, max %d, top %d\\n\", s, b[0], b[1], step-1, max, top);\n\n\t\tfor (i = 0; i < 2; i++) {\n\t\t\tk = b[i];\n\t\t\tfor (j = 0; (x = move[k][j]) >= 0; j++) {\n\t\t\t\tif (x == b[0] || x == b[1]) continue;\n\t\t\t\tif (i && x < 4 || !i && x > 8) continue;\n\t\t\t\ts2 = nextStep(s, x, k);\n\t\t\t\tif (insert(s2, step)) {\n\t\t\t\t\tQ[top].s = s2, Q[top].m = step;\n\t\t\t\t\tif (i)  Q[top].b1 = b[0], Q[top].b2 = x;\n\t\t\t\t\telse    Q[top].b1 = x, Q[top].b2 = b[1];\n\t\t\t\t\ttop++;\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t}\n}\n\nint main()\n{\n\tint i, p;\n\tUL s;\n\n\tstate();\n\twhile (1) {\n\t\tfor (s = i = 0; i < 13; i++) {\n\t\t\tscanf(\"%d\", &p);\n\t\t\tif (i == 0 && p < 0) return 0;\n\t\t\ts = (s << 4) | p;\n\t\t}\n\t\tif ((p = lookup(s)) >= 0) printf(\"%d\\n\", p);\n\t\telse puts(\"NA\");\n\t}\n\treturn 0;\n}"
  },
  {
    "language": "C",
    "code": "// Aizu Vol-1 0190: Eleven Puzzle\n// 2017.8.23 bal4u@uu\n// 2017.11.21\n\n#include <stdio.h>\n#define TM 0\n#if TM\n#include <time.h>\n#endif\n\ntypedef unsigned long long UL;\n\n#define HASHSIZ 900001\ntypedef struct { UL s; char m; } HASH;\nHASH hash[HASHSIZ+3], *hashend = hash+HASHSIZ;\n\nint lookup(UL s)\n{\n\tHASH *p = hash + s % HASHSIZ;\n\twhile (p->s) {\n\t\tif (p->s == s) return p->m;\n\t\tif (++p == hashend) p = hash;\n\t}\n\treturn -1;\n}\n\nint insert(UL s, char m)\n{\n\tHASH *p = hash + s % HASHSIZ;\n\twhile (p->s) {\n\t\tif (p->s == s) return 0;\n\t\tif (++p == hashend) p = hash;\n\t}\n\tp->s = s, p->m = m;\n\treturn 1;\n}\n\n#define MAX 500000\ntypedef struct { UL s; char b1, b2; } QUE;\nQUE Q[MAX+3], *top, *end, *qmax = Q+MAX;\n\nint move[13][5] = {\n\t/*  0 */{ 2, -1 },\n\t/*  1 */{ 2, 5, -1 },\n\t/*  2 */{ 0, 1, 3, 6, -1 },\n\t/*  3 */{ 2, 7, -1 },\n\t/*  4 */{ 5, -1 },\n\t/*  5 */{ 1, 4, 6, 9, -1 },\n\t/*  6 */{ 2, 5, 7, 10, -1 },\n\t/*  7 */{ 3, 6, 8, 11, -1 },\n\t/*  8 */{ 7, -1 },\n\t/*  9 */{ 5, 10, -1 },\n\t/* 10 */{ 6, 9, 11, 12, -1 },\n\t/* 11 */{ 7, 10, -1 },\n\t/* 12 */{ 10, -1 } };\n\nUL swap(UL s, int p, int sp)\n{\n\tUL n;\n\tp = (12 - p) << 2, sp = (12 - sp) << 2;\n\tn = (s >> p) & 0xf;\n\ts &= ~(0xfULL << p);\n\treturn s | (n << sp);\n}\n\nint sach(UL s, int b1, int b2, int mode, int lim)\n{\n\tint i, j, x, b[2], step = 1;\n\tUL s2;\n\n\ttop = end = Q, end->s = s, end->b1 = b1, end->b2 = b2, end++, end->s = 0, end++;\n\twhile (top+1 < end) {\n\t\ts = top->s, b[0] = top->b1, b[1] = top->b2, top++;\n\t\tif (!s) { step++, end->s = 0, end++; continue; }\n\t\tif (step > lim) break;\n//\tprintf(\"%#15llx, b1 %2d, b2 %2d, step %2d\\n\", s, b[0], b[1], step);\n\t\tfor (i = 0; i < 2; i++) {\n\t\t\tfor (j = 0; (x = move[b[i]][j]) >= 0; j++) {\n\t\t\t\tif (x == b[0] || x == b[1]) continue;\n\t\t\t\ts2 = swap(s, x, b[i]);\n\t\t\t\tif (mode) { if (lookup(s2) >= 0) return step; }\n\t\t\t\telse if (!insert(s2, step)) continue;\n\t\t\t\tend->s = s2;\n\t\t\t\tif (i) end->b1 = b[0], end->b2 = x;\n\t\t\t\telse   end->b1 = x, end->b2 = b[1];\n\t\t\t\tend++;\n\t\t\t}\n\t\t}\n\t}\n\treturn step;\n}\n\nint main()\n{\n\tUL s;\n\tint i, ans, p, b1, b2;\n#if TM\n\tclock_t start, finish;\n\tstart = clock();\n#endif\n\ts = 0x123456789ab0ULL, insert(s, 0);\n\tsach(s, 0, 12, 0, 13);\n\twhile (1) {\n\t\tfor (b1 = -1, s = i = 0; i < 13; i++) {\n\t\t\tscanf(\"%d\", &p);\n\t\t\tif (p < 0) goto done;\n\t\t\tif (!p) { if (b1 < 0) b1 = i; else b2 = i; }\n\t\t\ts = (s << 4) | p;\n\t\t}\n\t\tif ((ans = lookup(s)) < 0) {\n\t\t\tif ((ans = sach(s, b1, b2, 1, 7)) > 7) ans = -1;\n\t\t\telse ans += 13;\n\t\t}\n\t\tprintf(ans < 0 ? \"NA\\n\" : \"%d\\n\", ans);\t\n\t}\ndone:\n#if TM\n\tfinish = clock();\n\tprintf(\"time %lf\\n\", (double)(finish-start)/CLOCKS_PER_SEC);\n#endif\n\treturn 0;\n}"
  },
  {
    "language": "C",
    "code": "// Aizu Vol-1 0190: Eleven Puzzle\n// 2017.8.23 bal4u@uu\n// ???????????¢?´¢??????????????\\??????????????§??¶????????§??????\n\n#include <stdio.h>\n\n#define MAX 9999991\ntypedef unsigned long long UL;\n\ntypedef struct { UL s; char m; } HASH;\ntypedef struct { UL s; char b1, b2; } QUE;\n#define HASHSIZ 9999991ULL   // 19997\nHASH hash[HASHSIZ + 5], *hashend = hash + HASHSIZ;\nQUE Q[MAX + 5], *top, *end, *qmax = Q + MAX;\n\nint lookup(UL s)\n{\n\tHASH *p = hash + s % HASHSIZ;\n\twhile (p->s) {\n\t\tif (p->s == s) return p->m;\n\t\tif (++p == hashend) p = hash;\n\t}\n\treturn -1;\n}\n\nint insert(UL s, char m)\n{\n\tHASH *p = hash + s % HASHSIZ;\n\twhile (p->s) {\n\t\tif (p->s == s) return 0;\n\t\tif (++p == hashend) p = hash;\n\t}\n\tp->s = s, p->m = m;\n\treturn 1;\n}\n\nint move[13][5] = {\n\t/*  0 */{ 2, -1 },\n\t/*  1 */{ 2, 5, -1 },\n\t/*  2 */{ 0, 1, 3, 6, -1 },\n\t/*  3 */{ 2, 7, -1 },\n\t/*  4 */{ 5, -1 },\n\t/*  5 */{ 1, 4, 6, 9, -1 },\n\t/*  6 */{ 2, 5, 7, 10, -1 },\n\t/*  7 */{ 3, 6, 8, 11, -1 },\n\t/*  8 */{ 7, -1 },\n\t/*  9 */{ 5, 10, -1 },\n\t/* 10 */{ 6, 9, 11, 12, -1 },\n\t/* 11 */{ 7, 10, -1 },\n\t/* 12 */{ 10, -1 } };\n\nUL swap(UL s, int p1, int sp)\n{\n\tUL n1;\n\n\tp1 = (12 - p1) << 2, sp = (12 - sp) << 2;\n\tn1 = (s >> p1) & 0xf;\n\ts &= ~(0xfULL << p1);\n\ts |= (n1 << sp);\n\treturn s;\n}\n\nvoid state(void)\n{\n\tint i, j, k, x, step, b[2];\n\tUL s, s2;\n\n\ts = 0x123456789ab0ULL, insert(s, 0), step = 1;\n\ttop = end = Q;\n\tend->s = s, end->b1 = 0, end->b2 = 12, end++, end->s = 0, end++;\n\twhile (top < end) {\n\t\ts = top->s, b[0] = top->b1, b[1] = top->b2; if (++top >= qmax) top = Q;\n\t\tif (!s) {\n\t\t\tstep++, end->s = 0;\n\t\t\tif (++end >= qmax) end = qmax;\n\t\t\tif (end == top) break;\n\t\t\tcontinue;\n\t\t}\n\t\tif (step > 20) break;\n\t\tif (b[0] >= b[1]) x = b[0], b[0] = b[1], b[1] = x;\n\n//\tprintf(\"%llx, b1 %d, b2 %d, step %d\\n\", s, b[0], b[1], step);\n\n\t\tfor (i = 0; i < 2; i++) {\n\t\t\tk = b[i];\n\t\t\tfor (j = 0; (x = move[k][j]) >= 0; j++) {\n\t\t\t\tif (x == b[0] || x == b[1]) continue;\n\t\t\t\ts2 = swap(s, x, k);\n\t\t\t\tif (lookup(s2) < 0) {\n\t\t\t\t\tinsert(s2, step);\n\t\t\t\t\tend->s = s2;\n\t\t\t\t\tif (i) end->b1 = b[0], end->b2 = x;\n\t\t\t\t\telse   end->b1 = x, end->b2 = b[1];\n\t\t\t\t\tif (++end >= qmax) end = Q;\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t}\n}\n\nint main()\n{\n\tint i, p;\n\tUL s;\n\n\tstate();\n\twhile (1) {\n\t\tfor (s = i = 0; i < 13; i++) {\n\t\t\tscanf(\"%d\", &p);\n\t\t\tif (i == 0 && p < 0) return 0;\n\t\t\ts = (s << 4) | p;\n\t\t}\n\t\tif ((p = lookup(s)) >= 0) printf(\"%d\\n\", p);\n\t\telse puts(\"NA\");\n\t}\n\treturn 0;\n}"
  },
  {
    "language": "C",
    "code": "#include <stdio.h>\n#include <math.h>\n#include <stdlib.h>\n\ntypedef struct{\n\tlong long int code;\n\tint steps;\n} puzz;\n\nint q[10000000][14],size[30000],size2[30000];\nlong long int FR,TO,SW;\npuzz* hash[30000][100],hash2[30000][100];\n\nvoid swap (int* x,int* y){\n\tint z;\n\tz=*x;\n\t*x=*y;\n\t*y=z;\n}\n\nlong long int convert(int a[]){\n\tlong long int ret=0;\n\tint i;\n\tfor(i=0;i<13;i++)ret=ret*13+a[i];\n\treturn ret;\n}\n\nvoid hashadd(long long int code,int step){\n\tint ccc=code%30000;\n\tpuzz* ppp=(puzz*)malloc(sizeof(puzz));\n\tppp->code=code;\n\tppp->steps=step;\n\tif(size[ccc]>99){fprintf(stderr,\"SIZE OVER!! (%d)\\n\",ccc);return;}\n\thash[ccc][size[ccc]]=ppp;\n\tsize[ccc]++;\n}\n\nint hashsearch(long long int code){\n\tint ccc=code%30000;\n\tint i=size[ccc];\n\tfor(i--;i>=0;i--){\n\t\tif(hash[ccc][i]->code==code)return hash[ccc][i]->steps;\n\t}\n\treturn -1;\n}\n\nvoid mark(int x,int y){\n\tint k;\n\tlong long int cd;\n\n\tswap(&q[FR][x],&q[FR][y]);\n\tcd=convert(q[FR]);\n\n\tif(SW==1 || hashsearch(cd)<0){\n\t\tfor(k=0;k<14;k++){q[TO][k]=q[FR][k];}\n\t\tq[TO][13]++;\n\t\tif(SW==0)hashadd(cd,q[TO][13]);\n\t\tTO++;\n\t}\n\n\tswap(&q[FR][x],&q[FR][y]);\n\n}\n\nvoid check(){\n\tif(q[FR][0]==0){mark(0,2);}\n\tif(q[FR][1]==0){mark(1,2);mark(1,5);}\n\tif(q[FR][2]==0){mark(2,0);mark(2,1);mark(2,3);mark(2,6);}\n\tif(q[FR][3]==0){mark(3,2);mark(3,7);}\n\tif(q[FR][4]==0){mark(4,5);}\n\tif(q[FR][5]==0){mark(5,1);mark(5,4);mark(5,6);mark(5,9);}\n\tif(q[FR][6]==0){mark(6,2);mark(6,5);mark(6,7);mark(6,10);}\n\tif(q[FR][7]==0){mark(7,3);mark(7,6);mark(7,8);mark(7,11);}\n\tif(q[FR][8]==0){mark(8,7);}\n\tif(q[FR][9]==0){mark(9,5);mark(9,10);}\n\tif(q[FR][10]==0){mark(10,6);mark(10,9);mark(10,11);mark(10,12);}\n\tif(q[FR][11]==0){mark(11,7);mark(11,10);}\n\tif(q[FR][12]==0){mark(12,10);}\n}\n\n\nint main(){\n\tint i;\n\tlong long int cd;\n\n\tfor(i=1;i<12;i++)q[0][i]=i;\n\tq[0][12]=0;q[0][13]=0;\n\n\tFR=0;TO=1;SW=0;\n\tint aaa[13]={2,9,5,1,4,10,6,3,8,11,7,0,0};\n\n\twhile(FR<TO && q[FR][13]<=13){\n\t\tcheck();\n\t\tFR++;\n\t}\n\n\twhile(scanf(\"%d\",&q[0][0])*q[0][0]>=0){\n\t\tfor(i=1;i<13;i++)scanf(\"%d\",&q[0][i]);\n\t\tq[0][13]=0;FR=0;TO=1;SW=1;\n\t\t//for(i=0;i<30000;i++)size2[i]=0;\n\n\t\twhile(FR<TO){\n\t\t\tcd=hashsearch(convert(q[FR]));\n\t\t\tif(cd>=0){printf(\"%d\\n\",cd+q[FR][13]);break;}\n\t\t\tif(q[FR][13]<6)check();\n\t\t\tFR++;\n\t\t}\n\n\t\tif(FR>=TO)printf(\"NA\\n\");\n\t}\n\n\treturn 0;\n}"
  },
  {
    "language": "C",
    "code": "// Aizu Vol-1 0190: Eleven Puzzle\n// 2017.8.23 bal4u@uu\n// 2017.11.21\n\n#include <stdio.h>\n#define TM 0\n#if TM\n#include <time.h>\n#endif\n\ntypedef unsigned long long UL;\n\n#define HASHSIZ 900007\ntypedef struct { UL s; char m; } HASH;\nHASH hash[HASHSIZ+3], *hashend = hash+HASHSIZ;\n\nint lookup(UL s)\n{\n\tHASH *p = hash + s % HASHSIZ;\n\twhile (p->s) {\n\t\tif (p->s == s) return p->m;\n\t\tif (++p == hashend) p = hash;\n\t}\n\treturn -1;\n}\n\nint insert(UL s, char m)\n{\n\tHASH *p = hash + s % HASHSIZ;\n\twhile (p->s) {\n\t\tif (p->s == s) return 0;\n\t\tif (++p == hashend) p = hash;\n\t}\n\tp->s = s, p->m = m;\n\treturn 1;\n}\n\n#define MAX 500000\ntypedef struct { UL s; char b1, b2; } QUE;\nQUE Q[MAX+3], *top, *end, *qmax = Q+MAX;\n\nint move[13][5] = {\n\t/*  0 */{ 2, -1 },\n\t/*  1 */{ 2, 5, -1 },\n\t/*  2 */{ 0, 1, 3, 6, -1 },\n\t/*  3 */{ 2, 7, -1 },\n\t/*  4 */{ 5, -1 },\n\t/*  5 */{ 1, 4, 6, 9, -1 },\n\t/*  6 */{ 2, 5, 7, 10, -1 },\n\t/*  7 */{ 3, 6, 8, 11, -1 },\n\t/*  8 */{ 7, -1 },\n\t/*  9 */{ 5, 10, -1 },\n\t/* 10 */{ 6, 9, 11, 12, -1 },\n\t/* 11 */{ 7, 10, -1 },\n\t/* 12 */{ 10, -1 } };\n\nUL swap(UL s, int p, int sp)\n{\n\tUL n;\n\tp = (12 - p) << 2, sp = (12 - sp) << 2;\n\tn = (s >> p) & 0xf;\n\ts &= ~(0xfULL << p);\n\treturn s | (n << sp);\n}\n\nint seach(UL s, int b1, int b2, int mode, int lim)\n{\n\tint i, j, x, b[2], step = 1;\n\tUL s2;\n\n\ttop = end = Q, end->s = s, end->b1 = b1, end->b2 = b2, end++, end->s = 0, end++;\n\twhile (top+1 < end) {\n\t\ts = top->s, b[0] = top->b1, b[1] = top->b2, top++;\n\t\tif (!s) { step++, end->s = 0, end++; continue; }\n\t\tif (step > lim) break;\n//\tprintf(\"%#15llx, b1 %2d, b2 %2d, step %2d\\n\", s, b[0], b[1], step);\n\t\tfor (i = 0; i < 2; i++) {\n\t\t\tfor (j = 0; (x = move[b[i]][j]) >= 0; j++) {\n\t\t\t\tif (x == b[0] || x == b[1]) continue;\n\t\t\t\ts2 = swap(s, x, b[i]);\n\t\t\t\tif (mode) { if (lookup(s2) >= 0) return step; }\n\t\t\t\telse if (!insert(s2, step)) continue;\n\t\t\t\tend->s = s2;\n\t\t\t\tif (i) end->b1 = b[0], end->b2 = x;\n\t\t\t\telse   end->b1 = x, end->b2 = b[1];\n\t\t\t\tend++;\n\t\t\t}\n\t\t}\n\t}\n\treturn step;\n}\n\n#define PAR  14\nint main()\n{\n\tUL s;\n\tint i, ans, p, b1, b2;\n#if TM\n\tclock_t start, finish;\n\tstart = clock();\n#endif\n\ts = 0x123456789ab0ULL, insert(s, 0);\n\tseach(s, 0, 12, 0, PAR);\n\twhile (1) {\n\t\tfor (b1 = -1, s = i = 0; i < 13; i++) {\n\t\t\tscanf(\"%d\", &p);\n\t\t\tif (p < 0) goto done;\n\t\t\tif (!p) { if (b1 < 0) b1 = i; else b2 = i; }\n\t\t\ts = (s << 4) | p;\n\t\t}\n\t\tif ((ans = lookup(s)) < 0) {\n\t\t\tif ((ans = seach(s, b1, b2, 1, 20-PAR)) > 20-PAR) ans = -1;\n\t\t\telse ans += PAR;\n\t\t}\n\t\tprintf(ans < 0 ? \"NA\\n\" : \"%d\\n\", ans);\t\n\t}\ndone:\n#if TM\n\tfinish = clock();\n\tprintf(\"time %lf\\n\", (double)(finish-start)/CLOCKS_PER_SEC);\n#endif\n\treturn 0;\n}"
  },
  {
    "language": "C",
    "code": "#include <stdio.h>\n#include <math.h>\n#include <stdlib.h>\n \ntypedef struct{\n    long long int code;\n    int steps;\n} puzz;\n \nint q[1000000][14],size[100000];\nlong long int FR,TO,SW;\npuzz* hash[100000][100];\n \nvoid swap (int* x,int* y){\n    int z;\n    z=*x;\n    *x=*y;\n    *y=z;\n}\n \nlong long int convert(int a[]){\n    long long int ret=0;\n    int i;\n    for(i=0;i<13;i++)ret=ret*13+a[i];\n    return ret;\n}\n \nvoid hashadd(long long int code,int step){\n    int ccc=code%100000;\n    puzz* ppp=(puzz*)malloc(sizeof(puzz));\n    ppp->code=code;\n    ppp->steps=step;\n    if(size[ccc]>99){fprintf(stderr,\"SIZE OVER!! (%d)\\n\",ccc);return;}\n    hash[ccc][size[ccc]]=ppp;\n    size[ccc]++;\n}\n \nint hashsearch(long long int code){\n    int ccc=code%100000;\n    int i=size[ccc]-1;\n    for(;i>=0;i--){\n        if(hash[ccc][i]->code==code)return hash[ccc][i]->steps;\n    }\n    return -1;\n}\n \nvoid mark(int x,int y){\n    int k;\n    long long int cd;\n \n    swap(&q[FR][x],&q[FR][y]);\n    cd=convert(q[FR]);\n \n    if(SW==1 || hashsearch(cd)<0){\n        for(k=0;k<14;k++){q[TO][k]=q[FR][k];}\n        q[TO][13]++;\n        if(SW==0)hashadd(cd,q[TO][13]);\n        TO++;\n    }\n \n    swap(&q[FR][x],&q[FR][y]);\n \n}\n \nvoid check(){\n    if(q[FR][0]==0){mark(0,2);}\n    if(q[FR][1]==0){mark(1,2);mark(1,5);}\n    if(q[FR][2]==0){mark(2,0);mark(2,1);mark(2,3);mark(2,6);}\n    if(q[FR][3]==0){mark(3,2);mark(3,7);}\n    if(q[FR][4]==0){mark(4,5);}\n    if(q[FR][5]==0){mark(5,1);mark(5,4);mark(5,6);mark(5,9);}\n    if(q[FR][6]==0){mark(6,2);mark(6,5);mark(6,7);mark(6,10);}\n    if(q[FR][7]==0){mark(7,3);mark(7,6);mark(7,8);mark(7,11);}\n    if(q[FR][8]==0){mark(8,7);}\n    if(q[FR][9]==0){mark(9,5);mark(9,10);}\n    if(q[FR][10]==0){mark(10,6);mark(10,9);mark(10,11);mark(10,12);}\n    if(q[FR][11]==0){mark(11,7);mark(11,10);}\n    if(q[FR][12]==0){mark(12,10);}\n}\n \n \nint main(){\n    int i,ans;\n    long long int cd;\n \n    for(i=1;i<12;i++)q[0][i]=i;\n    q[0][0]=0;q[0][12]=0;q[0][13]=0;\n    hashadd(convert(q[0]),0);\n \n    FR=0;TO=1;SW=0;\n \n    while(FR<TO && q[FR][13]<=13){\n        check();\n        FR++;\n    }\n\n    while(scanf(\"%d\",&q[0][0])*q[0][0]>=0){\n        for(i=1;i<13;i++)scanf(\"%d\",&q[0][i]);\n        q[0][13]=0;FR=0;TO=1;SW=1;ans=9999;\n \n        while(FR<TO){\n            cd=hashsearch(convert(q[FR]));\n            if(cd>=0){\n                ans=(int)cd+q[FR][13];\n                break;\n            }\n            if(q[FR][13]<6)check();\n            FR++;\n        }\n \n        if(ans>20)printf(\"NA\\n\"); else printf(\"%d\\n\",ans);\n    }\n \n    return 0;\n}"
  },
  {
    "language": "C",
    "code": "#include <stdio.h>\n#include <math.h>\n#include <stdlib.h>\n \ntypedef struct{\n    long long int code;\n    int steps;\n} puzz;\n \nint q[1000000][14],size[100000];\nlong long int FR,TO,SW;\npuzz* hash[100000][20];\n \nvoid swap (int* x,int* y){\n    int z;\n    z=*x;\n    *x=*y;\n    *y=z;\n}\n \nlong long int convert(int a[]){\n    long long int ret=0;\n    int i;\n    for(i=0;i<13;i++)ret=ret*13+a[i];\n    return ret;\n}\n \nvoid hashadd(long long int code,int step){\n    int ccc=code%100000;\n    puzz* ppp=(puzz*)malloc(sizeof(puzz));\n    ppp->code=code;\n    ppp->steps=step;\n    if(size[ccc]>19){fprintf(stderr,\"SIZE OVER!! (%d)\\n\",ccc);return;}\n    hash[ccc][size[ccc]]=ppp;\n    size[ccc]++;\n}\n \nint hashsearch(long long int code){\n    int ccc=code%100000;\n    int i=size[ccc]-1;\n    for(;i>=0;i--){\n        if(hash[ccc][i]->code==code)return hash[ccc][i]->steps;\n    }\n    return -1;\n}\n \nvoid mark(int x,int y){\n    int k;\n    long long int cd;\n \n    swap(&q[FR][x],&q[FR][y]);\n    cd=convert(q[FR]);\n \n    if(SW==1 || hashsearch(cd)<0){\n        for(k=0;k<14;k++){q[TO][k]=q[FR][k];}\n        q[TO][13]++;\n        if(SW==0)hashadd(cd,q[TO][13]);\n        TO++;\n    }\n \n    swap(&q[FR][x],&q[FR][y]);\n \n}\n \nvoid check(){\n    if(q[FR][0]==0){mark(0,2);}\n    if(q[FR][1]==0){mark(1,2);mark(1,5);}\n    if(q[FR][2]==0){mark(2,0);mark(2,1);mark(2,3);mark(2,6);}\n    if(q[FR][3]==0){mark(3,2);mark(3,7);}\n    if(q[FR][4]==0){mark(4,5);}\n    if(q[FR][5]==0){mark(5,1);mark(5,4);mark(5,6);mark(5,9);}\n    if(q[FR][6]==0){mark(6,2);mark(6,5);mark(6,7);mark(6,10);}\n    if(q[FR][7]==0){mark(7,3);mark(7,6);mark(7,8);mark(7,11);}\n    if(q[FR][8]==0){mark(8,7);}\n    if(q[FR][9]==0){mark(9,5);mark(9,10);}\n    if(q[FR][10]==0){mark(10,6);mark(10,9);mark(10,11);mark(10,12);}\n    if(q[FR][11]==0){mark(11,7);mark(11,10);}\n    if(q[FR][12]==0){mark(12,10);}\n}\n \n \nint main(){\n    int i,ans;\n    long long int cd;\n \n    for(i=1;i<12;i++)q[0][i]=i;\n    q[0][0]=0;q[0][12]=0;q[0][13]=0;\n    hashadd(convert(q[0]),0);\n \n    FR=0;TO=1;SW=0;\n \n    while(FR<TO && q[FR][13]<=13){\n        check();\n        FR++;\n    }\n\n    while(scanf(\"%d\",&q[0][0])*q[0][0]>=0){\n        for(i=1;i<13;i++)scanf(\"%d\",&q[0][i]);\n        q[0][13]=0;FR=0;TO=1;SW=1;ans=9999;\n \n        while(FR<TO){\n            cd=hashsearch(convert(q[FR]));\n            if(cd>=0){\n                ans=(int)cd+q[FR][13];\n                break;\n            }\n            if(q[FR][13]<6)check();\n            FR++;\n        }\n \n        if(ans>20)printf(\"NA\\n\"); else printf(\"%d\\n\",ans);\n    }\n \n    return 0;\n}"
  },
  {
    "language": "C",
    "code": "#include <stdio.h>\n#include <math.h>\n#include <stdlib.h>\n\ntypedef struct{\n\tlong long int code;\n\tint steps;\n} puzz;\n\nint q[10000000][14],size[30000],size2[30000];\nlong long int FR,TO,SW;\npuzz* hash[30000][100],hash2[30000][100];\n\nvoid swap (int* x,int* y){\n\tint z;\n\tz=*x;\n\t*x=*y;\n\t*y=z;\n}\n\nlong long int convert(int a[]){\n\tlong long int ret=0;\n\tint i;\n\tfor(i=0;i<13;i++)ret=ret*13+a[i];\n\treturn ret;\n}\n\nvoid hashadd(long long int code,int step){\n\tint ccc=code%30000;\n\tpuzz* ppp=(puzz*)malloc(sizeof(puzz));\n\tppp->code=code;\n\tppp->steps=step;\n\tif(size[ccc]>99){fprintf(stderr,\"SIZE OVER!! (%d)\\n\",ccc);return;}\n\thash[ccc][size[ccc]]=ppp;\n\tsize[ccc]++;\n}\n\nint hashsearch(long long int code){\n\tint ccc=code%30000;\n\tint i=size[ccc];\n\tfor(i--;i>=0;i--){\n\t\tif(hash[ccc][i]->code==code)return hash[ccc][i]->steps;\n\t}\n\treturn -1;\n}\n\nvoid mark(int x,int y){\n\tint k;\n\tlong long int cd;\n\n\tswap(&q[FR][x],&q[FR][y]);\n\tcd=convert(q[FR]);\n\n\tif(hashsearch(cd)<0){\n\t\tfor(k=0;k<14;k++){q[TO][k]=q[FR][k];}\n\t\tq[TO][13]++;\n\t\tif(SW==0)hashadd(cd,q[TO][13]);\n\t\tTO++;\n\t}\n\n\tswap(&q[FR][x],&q[FR][y]);\n\n}\n\nvoid check(){\n\tif(q[FR][0]==0){mark(0,2);}\n\tif(q[FR][1]==0){mark(1,2);mark(1,5);}\n\tif(q[FR][2]==0){mark(2,0);mark(2,1);mark(2,3);mark(2,6);}\n\tif(q[FR][3]==0){mark(3,2);mark(3,7);}\n\tif(q[FR][4]==0){mark(4,5);}\n\tif(q[FR][5]==0){mark(5,1);mark(5,4);mark(5,6);mark(5,9);}\n\tif(q[FR][6]==0){mark(6,2);mark(6,5);mark(6,7);mark(6,10);}\n\tif(q[FR][7]==0){mark(7,3);mark(7,6);mark(7,8);mark(7,11);}\n\tif(q[FR][8]==0){mark(8,7);}\n\tif(q[FR][9]==0){mark(9,5);mark(9,10);}\n\tif(q[FR][10]==0){mark(10,6);mark(10,9);mark(10,11);mark(10,12);}\n\tif(q[FR][11]==0){mark(11,7);mark(11,10);}\n\tif(q[FR][12]==0){mark(12,10);}\n}\n\n\nint main(){\n\tint i;\n\tlong long int cd;\n\n\tfor(i=1;i<12;i++)q[0][i]=i;\n\tq[0][12]=0;q[0][13]=0;\n\n\tFR=0;TO=1;SW=0;\n\n\twhile(FR<TO && q[FR][13]<=13){\n\t\tcheck();\n\t\tFR++;\n\t}\n\n\twhile(scanf(\"%d\",&q[0][0])*q[0][0]>=0){\n\t\tfor(i=1;i<13;i++)scanf(\"%d\",&q[0][i]);\n\t\tq[0][13]=0;FR=0;TO=1;SW=1;\n\t\t//for(i=0;i<30000;i++)size2[i]=0;\n\n\t\twhile(FR<TO && q[FR][13]<=7){\n\t\t\tcd=hashsearch(convert(q[FR]));\n\t\t\tif(cd>=0){printf(\"%d\\n\",cd+q[FR][13]);break;}\n\t\t\tif(q[FR][13]<7)check();\n\t\t\tFR++;\n\t\t}\n\n\t\tif(FR>=TO)printf(\"NA\\n\");\n\t}\n\n\treturn 0;\n}"
  },
  {
    "language": "C",
    "code": "#include <stdio.h>\n#include <math.h>\n#include <stdlib.h>\n\ntypedef struct{\n\tlong long int code;\n\tint steps;\n} puzz;\n\nint q[10000000][14],size[30000],size2[30000];\nlong long int FR,TO,SW;\npuzz* hash[30000][100],hash2[30000][100];\n\nvoid swap (int* x,int* y){\n\tint z;\n\tz=*x;\n\t*x=*y;\n\t*y=z;\n}\n\nlong long int convert(int a[]){\n\tlong long int ret=0;\n\tint i;\n\tfor(i=0;i<13;i++)ret=ret*13+a[i];\n\treturn ret;\n}\n\nvoid hashadd(long long int code,int step){\n\tint ccc=code%30000;\n\tpuzz* ppp=(puzz*)malloc(sizeof(puzz));\n\tppp->code=code;\n\tppp->steps=step;\n\tif(size[ccc]>99){fprintf(stderr,\"SIZE OVER!! (%d)\\n\",ccc);return;}\n\thash[ccc][size[ccc]]=ppp;\n\tsize[ccc]++;\n}\n\nint hashsearch(long long int code){\n\tint ccc=code%30000;\n\tint i=size[ccc];\n\tfor(i--;i>=0;i--){\n\t\tif(hash[ccc][i]->code==code)return hash[ccc][i]->steps;\n\t}\n\treturn -1;\n}\n\nvoid mark(int x,int y){\n\tint k;\n\tlong long int cd;\n\n\tswap(&q[FR][x],&q[FR][y]);\n\tcd=convert(q[FR]);\n\n\tif(SW==1 || hashsearch(cd)<0){\n\t\tfor(k=0;k<14;k++){q[TO][k]=q[FR][k];}\n\t\tq[TO][13]++;\n\t\tif(SW==0)hashadd(cd,q[TO][13]);\n\t\tTO++;\n\t}\n\n\tswap(&q[FR][x],&q[FR][y]);\n\n}\n\nvoid check(){\n\tif(q[FR][0]==0){mark(0,2);}\n\tif(q[FR][1]==0){mark(1,2);mark(1,5);}\n\tif(q[FR][2]==0){mark(2,0);mark(2,1);mark(2,3);mark(2,6);}\n\tif(q[FR][3]==0){mark(3,2);mark(3,7);}\n\tif(q[FR][4]==0){mark(4,5);}\n\tif(q[FR][5]==0){mark(5,1);mark(5,4);mark(5,6);mark(5,9);}\n\tif(q[FR][6]==0){mark(6,2);mark(6,5);mark(6,7);mark(6,10);}\n\tif(q[FR][7]==0){mark(7,3);mark(7,6);mark(7,8);mark(7,11);}\n\tif(q[FR][8]==0){mark(8,7);}\n\tif(q[FR][9]==0){mark(9,5);mark(9,10);}\n\tif(q[FR][10]==0){mark(10,6);mark(10,9);mark(10,11);mark(10,12);}\n\tif(q[FR][11]==0){mark(11,7);mark(11,10);}\n\tif(q[FR][12]==0){mark(12,10);}\n}\n\n\nint main(){\n\tint i,ans=9999;\n\tlong long int cd;\n\n\tfor(i=1;i<12;i++)q[0][i]=i;\n\tq[0][12]=0;q[0][13]=0;\n\n\tFR=0;TO=1;SW=0;\n\tint aaa[13]={2,9,5,1,4,10,6,3,8,11,7,0,0};\n\n\twhile(FR<TO && q[FR][13]<=13){\n\t\tcheck();\n\t\tFR++;\n\t}\n\n\twhile(scanf(\"%d\",&q[0][0])*q[0][0]>=0){\n\t\tfor(i=1;i<13;i++)scanf(\"%d\",&q[0][i]);\n\t\tq[0][13]=0;FR=0;TO=1;SW=1;\n\t\t//for(i=0;i<30000;i++)size2[i]=0;\n\n\t\twhile(FR<TO){\n\t\t\tcd=hashsearch(convert(q[FR]));\n\t\t\tif(cd>=0 && ans>q[FR][13]+cd)ans=q[FR][13]+cd;\n\t\t\tif(q[FR][13]<6)check();\n\t\t\tFR++;\n\t\t}\n\n\t\tif(ans>20)printf(\"NA\\n\"); else printf(\"%d\\n\",ans);\n\t}\n\n\treturn 0;\n}"
  },
  {
    "language": "C",
    "code": "#include <stdio.h>\n#include <math.h>\n#include <stdlib.h>\n\ntypedef struct{\n\tlong long int code;\n\tint steps;\n} puzz;\n\nint q[10000000][14],size[30000],size2[30000];\nlong long int FR,TO,SW;\npuzz* hash[30000][100],hash2[30000][100];\n\nvoid swap (int* x,int* y){\n\tint z;\n\tz=*x;\n\t*x=*y;\n\t*y=z;\n}\n\nlong long int convert(int a[]){\n\tlong long int ret=0;\n\tint i;\n\tfor(i=0;i<13;i++)ret=ret*13+a[i];\n\treturn ret;\n}\n\nvoid hashadd(long long int code,int step){\n\tint ccc=code%30000;\n\tpuzz* ppp=(puzz*)malloc(sizeof(puzz));\n\tppp->code=code;\n\tppp->steps=step;\n\tif(size[ccc]>99){fprintf(stderr,\"SIZE OVER!! (%d)\\n\",ccc);return;}\n\thash[ccc][size[ccc]]=ppp;\n\tsize[ccc]++;\n}\n\nint hashsearch(long long int code){\n\tint ccc=code%30000;\n\tint i=size[ccc];\n\tfor(i--;i>=0;i--){\n\t\tif(hash[ccc][i]->code==code)return hash[ccc][i]->steps;\n\t}\n\treturn -1;\n}\n\nvoid mark(int x,int y){\n\tint k;\n\tlong long int cd;\n\n\tswap(&q[FR][x],&q[FR][y]);\n\tcd=convert(q[FR]);\n\n\tif(SW==1 || hashsearch(cd)<0){\n\t\tfor(k=0;k<14;k++){q[TO][k]=q[FR][k];}\n\t\tq[TO][13]++;\n\t\tif(SW==0)hashadd(cd,q[TO][13]);\n\t\tTO++;\n\t}\n\n\tswap(&q[FR][x],&q[FR][y]);\n\n}\n\nvoid check(){\n\tif(q[FR][0]==0){mark(0,2);}\n\tif(q[FR][1]==0){mark(1,2);mark(1,5);}\n\tif(q[FR][2]==0){mark(2,0);mark(2,1);mark(2,3);mark(2,6);}\n\tif(q[FR][3]==0){mark(3,2);mark(3,7);}\n\tif(q[FR][4]==0){mark(4,5);}\n\tif(q[FR][5]==0){mark(5,1);mark(5,4);mark(5,6);mark(5,9);}\n\tif(q[FR][6]==0){mark(6,2);mark(6,5);mark(6,7);mark(6,10);}\n\tif(q[FR][7]==0){mark(7,3);mark(7,6);mark(7,8);mark(7,11);}\n\tif(q[FR][8]==0){mark(8,7);}\n\tif(q[FR][9]==0){mark(9,5);mark(9,10);}\n\tif(q[FR][10]==0){mark(10,6);mark(10,9);mark(10,11);mark(10,12);}\n\tif(q[FR][11]==0){mark(11,7);mark(11,10);}\n\tif(q[FR][12]==0){mark(12,10);}\n}\n\n\nint main(){\n\tint i,ans;\n\tlong long int cd;\n\n\tfor(i=1;i<12;i++)q[0][i]=i;\n\tq[0][0]=0;q[0][12]=0;q[0][13]=0;\n\n\tFR=0;TO=1;SW=0;\n\n\twhile(FR<TO && q[FR][13]<=13){\n\t\tcheck();\n\t\tFR++;\n\t}\n\n\twhile(scanf(\"%d\",&q[0][0])*q[0][0]>=0){\n\t\tfor(i=1;i<13;i++)scanf(\"%d\",&q[0][i]);\n\t\tq[0][13]=0;FR=0;TO=1;SW=1;ans=9999;\n\t\t//for(i=0;i<30000;i++)size2[i]=0;\n\n\t\twhile(FR<TO){\n\t\t\tcd=hashsearch(convert(q[FR]));\n\t\t\tif(cd>=0){\n\t\t\t\tif(FR>0 && cd!=14)fprintf(stderr,\"%d?\\n\",cd);\n\t\t\t\tans=(int)cd+q[FR][13];\n\t\t\t\tbreak;\n\t\t\t}\n\t\t\tif(q[FR][13]<6)check();\n\t\t\tFR++;\n\t\t}\n\n\t\tif(ans>20 && ans<9999)fprintf(stderr,\"ans:%d?\\n\",ans);\n\t\tif(ans>20)printf(\"NA\\n\"); else printf(\"%d\\n\",ans);\n\t}\n\n\treturn 0;\n}"
  },
  {
    "language": "C",
    "code": "#include <stdio.h>\n#include <math.h>\n#include <stdlib.h>\n\ntypedef struct{\n\tlong long int code;\n\tint steps;\n} puzz;\n\nint q[10000000][14],size[30000],size2[30000];\nlong long int FR,TO,SW;\npuzz* hash[30000][100],hash2[30000][100];\n\nvoid swap (int* x,int* y){\n\tint z;\n\tz=*x;\n\t*x=*y;\n\t*y=z;\n}\n\nlong long int convert(int a[]){\n\tlong long int ret=0;\n\tint i;\n\tfor(i=0;i<13;i++)ret=ret*13+a[i];\n\treturn ret;\n}\n\nvoid hashadd(long long int code,int step){\n\tint ccc=code%30000;\n\tpuzz* ppp=(puzz*)malloc(sizeof(puzz));\n\tppp->code=code;\n\tppp->steps=step;\n\tif(size[ccc]>99){fprintf(stderr,\"SIZE OVER!! (%d)\\n\",ccc);return;}\n\thash[ccc][size[ccc]]=ppp;\n\tsize[ccc]++;\n}\n\nint hashsearch(long long int code){\n\tint ccc=code%30000;\n\tint i=size[ccc];\n\tfor(i--;i>=0;i--){\n\t\tif(hash[ccc][i]->code==code)return hash[ccc][i]->steps;\n\t}\n\treturn -1;\n}\n\nvoid mark(int x,int y){\n\tint k;\n\tlong long int cd;\n\n\tswap(&q[FR][x],&q[FR][y]);\n\tcd=convert(q[FR]);\n\n\tif(SW==1 || hashsearch(cd)<0){\n\t\tfor(k=0;k<14;k++){q[TO][k]=q[FR][k];}\n\t\tq[TO][13]++;\n\t\tif(SW==0)hashadd(cd,q[TO][13]);\n\t\tTO++;\n\t}\n\n\tswap(&q[FR][x],&q[FR][y]);\n\n}\n\nvoid check(){\n\tif(q[FR][0]==0){mark(0,2);}\n\tif(q[FR][1]==0){mark(1,2);mark(1,5);}\n\tif(q[FR][2]==0){mark(2,0);mark(2,1);mark(2,3);mark(2,6);}\n\tif(q[FR][3]==0){mark(3,2);mark(3,7);}\n\tif(q[FR][4]==0){mark(4,5);}\n\tif(q[FR][5]==0){mark(5,1);mark(5,4);mark(5,6);mark(5,9);}\n\tif(q[FR][6]==0){mark(6,2);mark(6,5);mark(6,7);mark(6,10);}\n\tif(q[FR][7]==0){mark(7,3);mark(7,6);mark(7,8);mark(7,11);}\n\tif(q[FR][8]==0){mark(8,7);}\n\tif(q[FR][9]==0){mark(9,5);mark(9,10);}\n\tif(q[FR][10]==0){mark(10,6);mark(10,9);mark(10,11);mark(10,12);}\n\tif(q[FR][11]==0){mark(11,7);mark(11,10);}\n\tif(q[FR][12]==0){mark(12,10);}\n}\n\n\nint main(){\n\tint i,ans=9999;\n\tlong long int cd;\n\n\tfor(i=1;i<12;i++)q[0][i]=i;\n\tq[0][12]=0;q[0][13]=0;\n\n\tFR=0;TO=1;SW=0;\n\tint aaa[13]={2,9,5,1,4,10,6,3,8,11,7,0,0};\n\n\twhile(FR<TO && q[FR][13]<=13){\n\t\tcheck();\n\t\tFR++;\n\t}\n\n\twhile(scanf(\"%d\",&q[0][0])*q[0][0]>=0){\n\t\tfor(i=1;i<13;i++)scanf(\"%d\",&q[0][i]);\n\t\tq[0][13]=0;FR=0;TO=1;SW=1;\n\t\t//for(i=0;i<30000;i++)size2[i]=0;\n\n\t\twhile(FR<TO){\n\t\t\tcd=hashsearch(convert(q[FR]));\n\t\t\tif(cd>=0){\n\t\t\t\tif(ans<21 && cd!=14)fprintf(stderr,\"??\\n\");\n\t\t\t\tans=(int)cd+q[FR][13];\n\t\t\t\tbreak;\n\t\t\t}\n\t\t\tif(q[FR][13]<6)check();\n\t\t\tFR++;\n\t\t}\n\n\t\tif(ans>20)printf(\"NA\\n\"); else printf(\"%d\\n\",ans);\n\t}\n\n\treturn 0;\n}"
  },
  {
    "language": "C",
    "code": "#include <stdio.h>\n#include <math.h>\n#include <stdlib.h>\n\ntypedef struct{\n\tlong long int code;\n\tint steps;\n} puzz;\n\nint q[10000000][14],size[30000],size2[30000];\nlong long int FR,TO,SW;\npuzz* hash[30000][100],hash2[30000][100];\n\nvoid swap (int* x,int* y){\n\tint z;\n\tz=*x;\n\t*x=*y;\n\t*y=z;\n}\n\nlong long int convert(int a[]){\n\tlong long int ret=0;\n\tint i;\n\tfor(i=0;i<13;i++)ret=ret*13+a[i];\n\treturn ret;\n}\n\nvoid hashadd(long long int code,int step){\n\tint ccc=code%30000;\n\tpuzz* ppp=(puzz*)malloc(sizeof(puzz));\n\tppp->code=code;\n\tppp->steps=step;\n\tif(size[ccc]>99){fprintf(stderr,\"SIZE OVER!! (%d)\\n\",ccc);return;}\n\thash[ccc][size[ccc]]=ppp;\n\tsize[ccc]++;\n}\n\nint hashsearch(long long int code){\n\tint ccc=code%30000;\n\tint i=size[ccc];\n\tfor(i--;i>=0;i--){\n\t\tif(hash[ccc][i]->code==code)return hash[ccc][i]->steps;\n\t}\n\treturn -1;\n}\n\nvoid mark(int x,int y){\n\tint k;\n\tlong long int cd;\n\n\tswap(&q[FR][x],&q[FR][y]);\n\tcd=convert(q[FR]);\n\n\tif(SW==1 || hashsearch(cd)<0){\n\t\tfor(k=0;k<14;k++){q[TO][k]=q[FR][k];}\n\t\tq[TO][13]++;\n\t\tif(SW==0)hashadd(cd,q[TO][13]);\n\t\tTO++;\n\t}\n\n\tswap(&q[FR][x],&q[FR][y]);\n\n}\n\nvoid check(){\n\tif(q[FR][0]==0){mark(0,2);}\n\tif(q[FR][1]==0){mark(1,2);mark(1,5);}\n\tif(q[FR][2]==0){mark(2,0);mark(2,1);mark(2,3);mark(2,6);}\n\tif(q[FR][3]==0){mark(3,2);mark(3,7);}\n\tif(q[FR][4]==0){mark(4,5);}\n\tif(q[FR][5]==0){mark(5,1);mark(5,4);mark(5,6);mark(5,9);}\n\tif(q[FR][6]==0){mark(6,2);mark(6,5);mark(6,7);mark(6,10);}\n\tif(q[FR][7]==0){mark(7,3);mark(7,6);mark(7,8);mark(7,11);}\n\tif(q[FR][8]==0){mark(8,7);}\n\tif(q[FR][9]==0){mark(9,5);mark(9,10);}\n\tif(q[FR][10]==0){mark(10,6);mark(10,9);mark(10,11);mark(10,12);}\n\tif(q[FR][11]==0){mark(11,7);mark(11,10);}\n\tif(q[FR][12]==0){mark(12,10);}\n}\n\n\nint main(){\n\tint i,ans;\n\tlong long int cd;\n\n\tfor(i=1;i<12;i++)q[0][i]=i;\n\tq[0][0]=0;q[0][12]=0;q[0][13]=0;\n\n\tFR=0;TO=1;SW=0;\n\n\twhile(FR<TO && q[FR][13]<=13){\n\t\tcheck();\n\t\tFR++;\n\t}\n\n\twhile(scanf(\"%d\",&q[0][0])*q[0][0]>=0){\n\t\tfor(i=1;i<13;i++)scanf(\"%d\",&q[0][i]);\n\t\tq[0][13]=0;FR=0;TO=1;SW=1;ans=9999;\n\t\t//for(i=0;i<30000;i++)size2[i]=0;\n\n\t\twhile(FR<TO){\n\t\t\tcd=hashsearch(convert(q[FR]));\n\t\t\tif(cd>=0){\n\t\t\t\tif(FR>0 && cd!=14)fprintf(stderr,\"%d?\\n\",cd);\n\t\t\t\tans=(int)cd+q[FR][13];\n\t\t\t\tbreak;\n\t\t\t}\n\t\t\tif(q[FR][13]<6)check();\n\t\t\tFR++;\n\t\t}\n\n\t\tif(ans>20)printf(\"NA\\n\"); else printf(\"%d\\n\",ans);\n\t}\n\n\treturn 0;\n}"
  },
  {
    "language": "C",
    "code": "// Aizu Vol-1 0190: Eleven Puzzle\n// 2017.8.23 bal4u@uu\n// ???????????¢?´¢??????????????\\??????????????§??¶????????§??????\n// ????????????????????????16?????????????????§??§???OK???\n// 1????????????????????§8??????4??????????????§4096????????¶??????\n\n#include <stdio.h>\n\n#define MAX 500000\ntypedef unsigned long long UL;\n\ntypedef struct { UL s; char m; } HASH;\ntypedef struct { UL s; char b1, b2; } QUE;\n#define HASHSIZ 900001ULL\nHASH hash[HASHSIZ + 5], *hashend = hash + HASHSIZ;\nQUE Q[MAX + 5], *top, *end, *qmax = Q + MAX;\n\nint lookup(UL s)\n{\n\tHASH *p = hash + s % HASHSIZ;\n\twhile (p->s) {\n\t\tif (p->s == s) return p->m;\n\t\tif (++p == hashend) p = hash;\n\t}\n\treturn -1;\n}\n\nint insert(UL s, char m)\n{\n\tHASH *p = hash + s % HASHSIZ;\n\twhile (p->s) {\n\t\tif (p->s == s) return 0;\n\t\tif (++p == hashend) p = hash;\n\t}\n\tp->s = s, p->m = m;\n\treturn 1;\n}\n\nint move[13][5] = {\n\t/*  0 */{ 2, -1 },\n\t/*  1 */{ 2, 5, -1 },\n\t/*  2 */{ 0, 1, 3, 6, -1 },\n\t/*  3 */{ 2, 7, -1 },\n\t/*  4 */{ 5, -1 },\n\t/*  5 */{ 1, 4, 6, 9, -1 },\n\t/*  6 */{ 2, 5, 7, 10, -1 },\n\t/*  7 */{ 3, 6, 8, 11, -1 },\n\t/*  8 */{ 7, -1 },\n\t/*  9 */{ 5, 10, -1 },\n\t/* 10 */{ 6, 9, 11, 12, -1 },\n\t/* 11 */{ 7, 10, -1 },\n\t/* 12 */{ 10, -1 } };\n\nUL swap(UL s, int p, int sp)\n{\n\tUL n;\n\tp = (12 - p) << 2, sp = (12 - sp) << 2;\n\tn = (s >> p) & 0xf;\n\ts &= ~(0xfULL << p);\n\treturn s | (n << sp);\n}\n\nint sach(UL s, int b1, int b2, int mode, int lim)\n{\n\tint i, j, x, b[2], step = 1;\n\tUL s2;\n\n\ttop = end = Q, end->s = s, end->b1 = b1, end->b2 = b2, end++, end->s = 0, end++;\n\twhile (top < end) {\n\t\ts = top->s, b[0] = top->b1, b[1] = top->b2, top++;\n\t\tif (!s) { step++, end->s = 0, end++; continue; }\n\t\tif (step > lim) break;\n//\tprintf(\"%#15llx, b1 %2d, b2 %2d, step %2d\\n\", s, b[0], b[1], step);\n\t\tfor (i = 0; i < 2; i++) {\n\t\t\tfor (j = 0; (x = move[b[i]][j]) >= 0; j++) {\n\t\t\t\tif (x == b[0] || x == b[1]) continue;\n\t\t\t\ts2 = swap(s, x, b[i]);\n\t\t\t\tif (mode) { if (lookup(s2) >= 0) return step; }\n\t\t\t\telse if (!insert(s2, step)) continue;\n\t\t\t\tend->s = s2;\n\t\t\t\tif (i) end->b1 = b[0], end->b2 = x;\n\t\t\t\telse   end->b1 = x, end->b2 = b[1];\n\t\t\t\tend++;\n\t\t\t}\n\t\t}\n\t}\n\treturn step;\n}\n\nint main()\n{\n\tUL s;\n\tint i, ans, p, b1, b2;\n\n\ts = 0x123456789ab0ULL, insert(s, 0);\n\tsach(s, 0, 12, 0, 16);\n\twhile (1) {\n\t\tfor (b1 = 01, s = i = 0; i < 13; i++) {\n\t\t\tscanf(\"%d\", &p);\n\t\t\tif (i == 0 && p < 0) return 0;\n\t\t\tif (!p) { if (b1 < 0) b1 = i; else b2 = i; }\n\t\t\ts = (s << 4) | p;\n\t\t}\n\t\tif ((ans = lookup(s)) < 0) {\n\t\t\tif ((ans = sach(s, b1, b2, 1, 4)) > 4) ans = -1;\n\t\t\telse ans += 16;\n\t\t}\n\t\tprintf(ans < 0 ? \"NA\\n\" : \"%d\\n\", ans);\t\n\t}\n\treturn 0;\n}"
  },
  {
    "language": "C",
    "code": "#include <stdio.h>\n#include <math.h>\n#include <stdlib.h>\n\ntypedef struct{\n\tlong long int code;\n\tint steps;\n} puzz;\n\nint q[10000000][14],size[30000],size2[30000];\nlong long int FR,TO,SW;\npuzz* hash[30000][100],hash2[30000][100];\n\nvoid swap (int* x,int* y){\n\tint z;\n\tz=*x;\n\t*x=*y;\n\t*y=z;\n}\n\nlong long int convert(int a[]){\n\tlong long int ret=0;\n\tint i;\n\tfor(i=0;i<13;i++)ret=ret*13+a[i];\n\treturn ret;\n}\n\nvoid hashadd(long long int code,int step){\n\tint ccc=code%30000;\n\tpuzz* ppp=(puzz*)malloc(sizeof(puzz));\n\tppp->code=code;\n\tppp->steps=step;\n\tif(size[ccc]>99){fprintf(stderr,\"SIZE OVER!! (%d)\\n\",ccc);return;}\n\thash[ccc][size[ccc]]=ppp;\n\tsize[ccc]++;\n}\n\nint hashsearch(long long int code){\n\tint ccc=code%30000;\n\tint i=size[ccc];\n\tfor(i--;i>=0;i--){\n\t\tif(hash[ccc][i]->code==code)return hash[ccc][i]->steps;\n\t}\n\treturn -1;\n}\n\nvoid mark(int x,int y){\n\tint k;\n\tlong long int cd;\n\n\tswap(&q[FR][x],&q[FR][y]);\n\tcd=convert(q[FR]);\n\n\tif(SW==1 || hashsearch(cd)<0){\n\t\tfor(k=0;k<14;k++){q[TO][k]=q[FR][k];}\n\t\tq[TO][13]++;\n\t\tif(SW==0)hashadd(cd,q[TO][13]);\n\t\tTO++;\n\t}\n\n\tswap(&q[FR][x],&q[FR][y]);\n\n}\n\nvoid check(){\n\tif(q[FR][0]==0){mark(0,2);}\n\tif(q[FR][1]==0){mark(1,2);mark(1,5);}\n\tif(q[FR][2]==0){mark(2,0);mark(2,1);mark(2,3);mark(2,6);}\n\tif(q[FR][3]==0){mark(3,2);mark(3,7);}\n\tif(q[FR][4]==0){mark(4,5);}\n\tif(q[FR][5]==0){mark(5,1);mark(5,4);mark(5,6);mark(5,9);}\n\tif(q[FR][6]==0){mark(6,2);mark(6,5);mark(6,7);mark(6,10);}\n\tif(q[FR][7]==0){mark(7,3);mark(7,6);mark(7,8);mark(7,11);}\n\tif(q[FR][8]==0){mark(8,7);}\n\tif(q[FR][9]==0){mark(9,5);mark(9,10);}\n\tif(q[FR][10]==0){mark(10,6);mark(10,9);mark(10,11);mark(10,12);}\n\tif(q[FR][11]==0){mark(11,7);mark(11,10);}\n\tif(q[FR][12]==0){mark(12,10);}\n}\n\n\nint main(){\n\tint i,ans;\n\tlong long int cd;\n\n\tfor(i=1;i<12;i++)q[0][i]=i;\n\tq[0][12]=0;q[0][13]=0;\n\n\tFR=0;TO=1;SW=0;\n\tint aaa[13]={2,9,5,1,4,10,6,3,8,11,7,0,0};\n\n\twhile(FR<TO && q[FR][13]<=13){\n\t\tcheck();\n\t\tFR++;\n\t}\n\n\twhile(scanf(\"%d\",&q[0][0])*q[0][0]>=0){\n\t\tfor(i=1;i<13;i++)scanf(\"%d\",&q[0][i]);\n\t\tq[0][13]=0;FR=0;TO=1;SW=1;ans=9999;\n\t\t//for(i=0;i<30000;i++)size2[i]=0;\n\n\t\twhile(FR<TO){\n\t\t\tcd=hashsearch(convert(q[FR]));\n\t\t\tif(cd>=0){\n\t\t\t\tif(ans<21 && cd!=14)fprintf(stderr,\"??\\n\");\n\t\t\t\tans=(int)cd+q[FR][13];\n\t\t\t\tbreak;\n\t\t\t}\n\t\t\tif(q[FR][13]<6)check();\n\t\t\tFR++;\n\t\t}\n\n\t\tif(ans>20)printf(\"NA\\n\"); else printf(\"%d\\n\",ans);\n\t}\n\n\treturn 0;\n}"
  },
  {
    "language": "C",
    "code": "// Aizu Vol-1 0190: Eleven Puzzle\n// 2017.8.23 bal4u@uu\n// 2017.11.5 retry\n// ???????????¢?´¢??????????????\\??????????????§??¶????????§??????\n// ????????????????????????16?????????????????§??§???OK???\n// 1????????????????????§8??????4??????????????§4096????????¶??????\n\n#include <stdio.h>\n\ntypedef unsigned long long UL;\n\n#define HASHSIZ 900001\ntypedef struct { UL s; char m; } HASH;\nHASH hash[HASHSIZ+3], *hashend = hash+HASHSIZ;\n\nint lookup(UL s)\n{\n\tHASH *p = hash + s % HASHSIZ;\n\twhile (p->s) {\n\t\tif (p->s == s) return p->m;\n\t\tif (++p == hashend) p = hash;\n\t}\n\treturn -1;\n}\n\nint insert(UL s, char m)\n{\n\tHASH *p = hash + s % HASHSIZ;\n\twhile (p->s) {\n\t\tif (p->s == s) return 0;\n\t\tif (++p == hashend) p = hash;\n\t}\n\tp->s = s, p->m = m;\n\treturn 1;\n}\n\n#define MAX 500000\ntypedef struct { UL s; char b1, b2; } QUE;\nQUE Q[MAX+3], *top, *end, *qmax = Q+MAX;\n\nint move[13][5] = {\n\t/*  0 */{ 2, -1 },\n\t/*  1 */{ 2, 5, -1 },\n\t/*  2 */{ 0, 1, 3, 6, -1 },\n\t/*  3 */{ 2, 7, -1 },\n\t/*  4 */{ 5, -1 },\n\t/*  5 */{ 1, 4, 6, 9, -1 },\n\t/*  6 */{ 2, 5, 7, 10, -1 },\n\t/*  7 */{ 3, 6, 8, 11, -1 },\n\t/*  8 */{ 7, -1 },\n\t/*  9 */{ 5, 10, -1 },\n\t/* 10 */{ 6, 9, 11, 12, -1 },\n\t/* 11 */{ 7, 10, -1 },\n\t/* 12 */{ 10, -1 } };\n\nUL swap(UL s, int p, int sp)\n{\n\tUL n;\n\tp = (12 - p) << 2, sp = (12 - sp) << 2;\n\tn = (s >> p) & 0xf;\n\ts &= ~(0xfULL << p);\n\treturn s | (n << sp);\n}\n\nint sach(UL s, int b1, int b2, int mode, int lim)\n{\n\tint i, j, x, b[2], step = 1;\n\tUL s2;\n\n\ttop = end = Q, end->s = s, end->b1 = b1, end->b2 = b2, end++, end->s = 0, end++;\n\twhile (top+1 < end) {\n\t\ts = top->s, b[0] = top->b1, b[1] = top->b2, top++;\n\t\tif (!s) { step++, end->s = 0, end++; continue; }\n\t\tif (step > lim) break;\n//\tprintf(\"%#15llx, b1 %2d, b2 %2d, step %2d\\n\", s, b[0], b[1], step);\n\t\tfor (i = 0; i < 2; i++) {\n\t\t\tfor (j = 0; (x = move[b[i]][j]) >= 0; j++) {\n\t\t\t\tif (x == b[0] || x == b[1]) continue;\n\t\t\t\ts2 = swap(s, x, b[i]);\n\t\t\t\tif (mode) { if (lookup(s2) >= 0) return step; }\n\t\t\t\telse if (!insert(s2, step)) continue;\n\t\t\t\tend->s = s2;\n\t\t\t\tif (i) end->b1 = b[0], end->b2 = x;\n\t\t\t\telse   end->b1 = x, end->b2 = b[1];\n\t\t\t\tend++;\n\t\t\t}\n\t\t}\n\t}\n\treturn step;\n}\n\nint main()\n{\n\tUL s;\n\tint i, ans, p, b1, b2;\n\n\ts = 0x123456789ab0ULL, insert(s, 0);\n\tsach(s, 0, 12, 0, 16);\n\twhile (1) {\n\t\tfor (b1 = -1, s = i = 0; i < 13; i++) {\n\t\t\tscanf(\"%d\", &p);\n\t\t\tif (p < 0) return 0;\n\t\t\tif (!p) { if (b1 < 0) b1 = i; else b2 = i; }\n\t\t\ts = (s << 4) | p;\n\t\t}\n\t\tif ((ans = lookup(s)) < 0) {\n\t\t\tif ((ans = sach(s, b1, b2, 1, 4)) > 4) ans = -1;\n\t\t\telse ans += 16;\n\t\t}\n\t\tprintf(ans < 0 ? \"NA\\n\" : \"%d\\n\", ans);\t\n\t}\n\treturn 0;\n}"
  },
  {
    "language": "C",
    "code": "// Aizu Vol-1 0190: Eleven Puzzle\n// 2017.8.23 bal4u@uu\n// ???????????¢?´¢??????????????\\??????????????§??¶????????§??????\n\n#include <stdio.h>\n\n#define MAX 999983\ntypedef unsigned long long UL;\n\ntypedef struct { UL s; char m; } HASH;\ntypedef struct { UL s; char b1, b2; } QUE;\n#define HASHSIZ 999983ULL   // 19997\nHASH hash[HASHSIZ + 5], *hashend = hash + HASHSIZ;\nQUE Q[MAX + 5], *top, *end, *qmax = Q + MAX;\n\nint lookup(UL s)\n{\n\tHASH *p = hash + s % HASHSIZ;\n\twhile (p->s) {\n\t\tif (p->s == s) return p->m;\n\t\tif (++p == hashend) p = hash;\n\t}\n\treturn -1;\n}\n\nint insert(UL s, char m)\n{\n\tHASH *p = hash + s % HASHSIZ;\n\twhile (p->s) {\n\t\tif (p->s == s) return 0;\n\t\tif (++p == hashend) p = hash;\n\t}\n\tp->s = s, p->m = m;\n\treturn 1;\n}\n\nint move[13][5] = {\n\t/*  0 */{ 2, -1 },\n\t/*  1 */{ 2, 5, -1 },\n\t/*  2 */{ 0, 1, 3, 6, -1 },\n\t/*  3 */{ 2, 7, -1 },\n\t/*  4 */{ 5, -1 },\n\t/*  5 */{ 1, 4, 6, 9, -1 },\n\t/*  6 */{ 2, 5, 7, 10, -1 },\n\t/*  7 */{ 3, 6, 8, 11, -1 },\n\t/*  8 */{ 7, -1 },\n\t/*  9 */{ 5, 10, -1 },\n\t/* 10 */{ 6, 9, 11, 12, -1 },\n\t/* 11 */{ 7, 10, -1 },\n\t/* 12 */{ 10, -1 } };\n\nUL swap(UL s, int p1, int sp)\n{\n\tUL n1;\n\n\tp1 = (12 - p1) << 2, sp = (12 - sp) << 2;\n\tn1 = (s >> p1) & 0xf;\n\ts &= ~(0xfULL << p1);\n\ts |= (n1 << sp);\n\treturn s;\n}\n\nvoid state(void)\n{\n\tint i, j, k, x, step, b[2];\n\tUL s, s2;\n\n\ts = 0x123456789ab0ULL, insert(s, 0), step = 1;\n\ttop = end = Q;\n\tend->s = s, end->b1 = 0, end->b2 = 12, end++, end->s = 0, end++;\n\twhile (top < end) {\n\t\ts = top->s, b[0] = top->b1, b[1] = top->b2; if (++top >= qmax) top = Q;\n\t\tif (!s) {\n\t\t\tstep++, end->s = 0;\n\t\t\tif (++end >= qmax) end = qmax;\n\t\t\tif (end == top) break;\n\t\t\tcontinue;\n\t\t}\n\t\tif (step > 20) break;\n\t\tif (b[0] >= b[1]) x = b[0], b[0] = b[1], b[1] = x;\n\n//\tprintf(\"%llx, b1 %d, b2 %d, step %d\\n\", s, b[0], b[1], step);\n\n\t\tfor (i = 0; i < 2; i++) {\n\t\t\tk = b[i];\n\t\t\tfor (j = 0; (x = move[k][j]) >= 0; j++) {\n\t\t\t\tif (x == b[0] || x == b[1]) continue;\n\t\t\t\ts2 = swap(s, x, k);\n\t\t\t\tif (lookup(s2) < 0) {\n\t\t\t\t\tinsert(s2, step);\n\t\t\t\t\tend->s = s2;\n\t\t\t\t\tif (i) end->b1 = b[0], end->b2 = x;\n\t\t\t\t\telse   end->b1 = x, end->b2 = b[1];\n\t\t\t\t\tif (++end >= qmax) end = Q;\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t}\n}\n\nint main()\n{\n\tint i, p;\n\tUL s;\n\n\tstate();\n\twhile (1) {\n\t\tfor (s = i = 0; i < 13; i++) {\n\t\t\tscanf(\"%d\", &p);\n\t\t\tif (i == 0 && p < 0) return 0;\n\t\t\ts = (s << 4) | p;\n\t\t}\n\t\tif ((p = lookup(s)) >= 0) printf(\"%d\\n\", p);\n\t\telse puts(\"NA\");\n\t}\n\treturn 0;\n}"
  },
  {
    "language": "C",
    "code": "// Aizu Vol-1 0190: Eleven Puzzle\n// 2017.8.23 bal4u@uu\n// ???????????¢?´¢??????????????\\??????????????§??¶????????§??????\n\n#include <stdio.h>\n\n#define MAX 200000\ntypedef unsigned long long UL;\n\ntypedef struct { UL s; char m; } HASH;\ntypedef struct { UL s; char b1, b2; } QUE;\n#define HASHSIZ  1999993ULL   // 19997\nHASH hash[HASHSIZ + 5], *hashend = hash + HASHSIZ;\nQUE Q[MAX + 5], *top, *end, *qmax = Q + MAX;\n\nint lookup(UL s)\n{\n\tHASH *p = hash + s % HASHSIZ;\n\twhile (p->s) {\n\t\tif (p->s == s) return p->m;\n\t\tif (++p == hashend) p = hash;\n\t}\n\treturn -1;\n}\n\nint insert(UL s, char m)\n{\n\tHASH *p = hash + s % HASHSIZ;\n\twhile (p->s) {\n\t\tif (p->s == s) return 0;\n\t\tif (++p == hashend) p = hash;\n\t}\n\tp->s = s, p->m = m;\n\treturn 1;\n}\n\nint move[13][5] = {\n\t/*  0 */{ 2, -1 },\n\t/*  1 */{ 2, 5, -1 },\n\t/*  2 */{ 0, 1, 3, 6, -1 },\n\t/*  3 */{ 2, 7, -1 },\n\t/*  4 */{ 5, -1 },\n\t/*  5 */{ 1, 4, 6, 9, -1 },\n\t/*  6 */{ 2, 5, 7, 10, -1 },\n\t/*  7 */{ 3, 6, 8, 11, -1 },\n\t/*  8 */{ 7, -1 },\n\t/*  9 */{ 5, 10, -1 },\n\t/* 10 */{ 6, 9, 11, 12, -1 },\n\t/* 11 */{ 7, 10, -1 },\n\t/* 12 */{ 10, -1 } };\n\nUL swap(UL s, int p1, int sp)\n{\n\tUL n1;\n\n\tp1 = (12 - p1) << 2, sp = (12 - sp) << 2;\n\tn1 = (s >> p1) & 0xf;\n\ts &= ~(0xfULL << p1);\n\ts |= (n1 << sp);\n\treturn s;\n}\n\nvoid state(void)\n{\n\tint i, j, k, x, step, b[2];\n\tUL s, s2;\n\n\ts = 0x123456789ab0ULL, insert(s, 0), step = 1;\n\ttop = end = Q;\n\tend->s = s, end->b1 = 0, end->b2 = 12, end++, end->s = 0, end++;\n\twhile (top < end) {\n\t\ts = top->s, b[0] = top->b1, b[1] = top->b2; if (++top >= qmax) top = Q;\n\t\tif (!s) {\n\t\t\tstep++, end->s = 0;\n\t\t\tif (++end >= qmax) end = qmax;\n\t\t\tif (end == top) break;\n\t\t\tcontinue;\n\t\t}\n\t\tif (step > 20) break;\n//\t\tif (b[0] >= b[1]) x = b[0], b[0] = b[1], b[1] = x;\n\n//\tprintf(\"%llx, b1 %d, b2 %d, step %d\\n\", s, b[0], b[1], step);\n\n\t\tfor (i = 0; i < 2; i++) {\n\t\t\tk = b[i];\n\t\t\tfor (j = 0; (x = move[k][j]) >= 0; j++) {\n//\t\t\t\tif (x == b[0] || x == b[1]) continue;\n\t\t\t\ts2 = swap(s, x, k);\n\t\t\t\tif (lookup(s2) < 0) {\n\t\t\t\t\tinsert(s2, step);\n\t\t\t\t\tend->s = s2;\n\t\t\t\t\tif (i) end->b1 = b[0], end->b2 = x;\n\t\t\t\t\telse   end->b1 = x, end->b2 = b[1];\n\t\t\t\t\tif (++end >= qmax) end = Q;\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t}\n}\n\nint main()\n{\n\tint i, p;\n\tUL s;\n\n\tstate();\n\twhile (1) {\n\t\tfor (s = i = 0; i < 13; i++) {\n\t\t\tscanf(\"%d\", &p);\n\t\t\tif (i == 0 && p < 0) return 0;\n\t\t\ts = (s << 4) | p;\n\t\t}\n\t\tif ((p = lookup(s)) >= 0) printf(\"%d\\n\", p);\n\t\telse puts(\"NA\");\n\t}\n\treturn 0;\n}"
  },
  {
    "language": "C",
    "code": "#include <stdio.h>\n#include <math.h>\n#include <stdlib.h>\n\ntypedef struct{\n\tlong long int code;\n\tint steps;\n} puzz;\n\nint q[10000000][14],size[30000],size2[30000];\nlong long int FR,TO,SW;\npuzz* hash[30000][100],hash2[30000][100];\n\nvoid swap (int* x,int* y){\n\tint z;\n\tz=*x;\n\t*x=*y;\n\t*y=z;\n}\n\nlong long int convert(int a[]){\n\tlong long int ret=0;\n\tint i;\n\tfor(i=0;i<13;i++)ret=ret*13+a[i];\n\treturn ret;\n}\n\nvoid hashadd(long long int code,int step){\n\tint ccc=code%30000;\n\tpuzz* ppp=(puzz*)malloc(sizeof(puzz));\n\tppp->code=code;\n\tppp->steps=step;\n\tif(size[ccc]>99){fprintf(stderr,\"SIZE OVER!! (%d)\\n\",ccc);return;}\n\thash[ccc][size[ccc]]=ppp;\n\tsize[ccc]++;\n}\n\nint hashsearch(long long int code){\n\tint ccc=code%30000;\n\tint i=size[ccc];\n\tfor(i--;i>=0;i--){\n\t\tif(hash[ccc][i]->code==code)return hash[ccc][i]->steps;\n\t}\n\treturn -1;\n}\n\nvoid mark(int x,int y){\n\tint k;\n\tlong long int cd;\n\n\tswap(&q[FR][x],&q[FR][y]);\n\tcd=convert(q[FR]);\n\n\tif(SW==1 || hashsearch(cd)<0){\n\t\tfor(k=0;k<14;k++){q[TO][k]=q[FR][k];}\n\t\tq[TO][13]++;\n\t\tif(SW==0)hashadd(cd,q[TO][13]);\n\t\tTO++;\n\t}\n\n\tswap(&q[FR][x],&q[FR][y]);\n\n}\n\nvoid check(){\n\tif(q[FR][0]==0){mark(0,2);}\n\tif(q[FR][1]==0){mark(1,2);mark(1,5);}\n\tif(q[FR][2]==0){mark(2,0);mark(2,1);mark(2,3);mark(2,6);}\n\tif(q[FR][3]==0){mark(3,2);mark(3,7);}\n\tif(q[FR][4]==0){mark(4,5);}\n\tif(q[FR][5]==0){mark(5,1);mark(5,4);mark(5,6);mark(5,9);}\n\tif(q[FR][6]==0){mark(6,2);mark(6,5);mark(6,7);mark(6,10);}\n\tif(q[FR][7]==0){mark(7,3);mark(7,6);mark(7,8);mark(7,11);}\n\tif(q[FR][8]==0){mark(8,7);}\n\tif(q[FR][9]==0){mark(9,5);mark(9,10);}\n\tif(q[FR][10]==0){mark(10,6);mark(10,9);mark(10,11);mark(10,12);}\n\tif(q[FR][11]==0){mark(11,7);mark(11,10);}\n\tif(q[FR][12]==0){mark(12,10);}\n}\n\n\nint main(){\n\tint i,ans;\n\tlong long int cd;\n\n\tfor(i=1;i<12;i++)q[0][i]=i;\n\tq[0][12]=0;q[0][13]=0;\n\n\tFR=0;TO=1;SW=0;\n\tint aaa[13]={2,9,5,1,4,10,6,3,8,11,7,0,0};\n\n\twhile(FR<TO && q[FR][13]<=13){\n\t\tcheck();\n\t\tFR++;\n\t}\n\n\twhile(scanf(\"%d\",&q[0][0])*q[0][0]>=0){\n\t\tfor(i=1;i<13;i++)scanf(\"%d\",&q[0][i]);\n\t\tq[0][13]=0;FR=0;TO=1;SW=1;ans=9999;\n\t\t//for(i=0;i<30000;i++)size2[i]=0;\n\n\t\twhile(FR<TO){\n\t\t\tcd=hashsearch(convert(q[FR]));\n\t\t\tif(cd>=0){\n\t\t\t\tif(ans<21 && cd!=14)fprintf(stderr,\"??\\n\");\n\t\t\t\tans=(int)cd+q[FR][13];\n\t\t\t\tif(FR==0)break;\n\t\t\t}\n\t\t\tif(q[FR][13]<6)check();\n\t\t\tFR++;\n\t\t}\n\n\t\tif(ans>20)printf(\"NA\\n\"); else printf(\"%d\\n\",ans);\n\t}\n\n\treturn 0;\n}"
  },
  {
    "language": "C",
    "code": "// Aizu Vol-1 0190: Eleven Puzzle\n// 2017.8.23 bal4u@uu\n// ???????????¢?´¢??????????????\\??????????????§??¶????????§??????\n\n#include <stdio.h>\n\n#define MAX 999983\ntypedef unsigned long long UL;\n\ntypedef struct { UL s; char m; } HASH;\ntypedef struct { UL s; char b1, b2; } QUE;\n#define HASHSIZ 9999991ULL   // 19997\nHASH hash[HASHSIZ + 5], *hashend = hash + HASHSIZ;\nQUE Q[MAX + 5], *top, *end, *qmax = Q + MAX;\n\nint lookup(UL s)\n{\n\tHASH *p = hash + s % HASHSIZ;\n\twhile (p->s) {\n\t\tif (p->s == s) return p->m;\n\t\tif (++p == hashend) p = hash;\n\t}\n\treturn -1;\n}\n\nint insert(UL s, char m)\n{\n\tHASH *p = hash + s % HASHSIZ;\n\twhile (p->s) {\n\t\tif (p->s == s) return 0;\n\t\tif (++p == hashend) p = hash;\n\t}\n\tp->s = s, p->m = m;\n\treturn 1;\n}\n\nint move[13][5] = {\n\t/*  0 */{ 2, -1 },\n\t/*  1 */{ 2, 5, -1 },\n\t/*  2 */{ 0, 1, 3, 6, -1 },\n\t/*  3 */{ 2, 7, -1 },\n\t/*  4 */{ 5, -1 },\n\t/*  5 */{ 1, 4, 6, 9, -1 },\n\t/*  6 */{ 2, 5, 7, 10, -1 },\n\t/*  7 */{ 3, 6, 8, 11, -1 },\n\t/*  8 */{ 7, -1 },\n\t/*  9 */{ 5, 10, -1 },\n\t/* 10 */{ 6, 9, 11, 12, -1 },\n\t/* 11 */{ 7, 10, -1 },\n\t/* 12 */{ 10, -1 } };\n\nUL swap(UL s, int p1, int sp)\n{\n\tUL n1;\n\n\tp1 = (12 - p1) << 2, sp = (12 - sp) << 2;\n\tn1 = (s >> p1) & 0xf;\n\ts &= ~(0xfULL << p1);\n\ts |= (n1 << sp);\n\treturn s;\n}\n\nvoid state(void)\n{\n\tint i, j, k, x, step, b[2];\n\tUL s, s2;\n\n\ts = 0x123456789ab0ULL, insert(s, 0), step = 1;\n\ttop = end = Q;\n\tend->s = s, end->b1 = 0, end->b2 = 12, end++, end->s = 0, end++;\n\twhile (top < end) {\n\t\ts = top->s, b[0] = top->b1, b[1] = top->b2; if (++top >= qmax) top = Q;\n\t\tif (!s) {\n\t\t\tstep++, end->s = 0;\n\t\t\tif (++end >= qmax) end = qmax;\n\t\t\tif (end == top) break;\n\t\t\tcontinue;\n\t\t}\n\t\tif (step > 20) break;\n\t\tif (b[0] >= b[1]) x = b[0], b[0] = b[1], b[1] = x;\n\n//\tprintf(\"%llx, b1 %d, b2 %d, step %d\\n\", s, b[0], b[1], step);\n\n\t\tfor (i = 0; i < 2; i++) {\n\t\t\tk = b[i];\n\t\t\tfor (j = 0; (x = move[k][j]) >= 0; j++) {\n\t\t\t\tif (x == b[0] || x == b[1]) continue;\n\t\t\t\ts2 = swap(s, x, k);\n\t\t\t\tif (lookup(s2) < 0) {\n\t\t\t\t\tinsert(s2, step);\n\t\t\t\t\tend->s = s2;\n\t\t\t\t\tif (i) end->b1 = b[0], end->b2 = x;\n\t\t\t\t\telse   end->b1 = x, end->b2 = b[1];\n\t\t\t\t\tif (++end >= qmax) end = Q;\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t}\n}\n\nint main()\n{\n\tint i, p;\n\tUL s;\n\n\tstate();\n\twhile (1) {\n\t\tfor (s = i = 0; i < 13; i++) {\n\t\t\tscanf(\"%d\", &p);\n\t\t\tif (i == 0 && p < 0) return 0;\n\t\t\ts = (s << 4) | p;\n\t\t}\n\t\tif ((p = lookup(s)) >= 0) printf(\"%d\\n\", p);\n\t\telse puts(\"NA\");\n\t}\n\treturn 0;\n}"
  },
  {
    "language": "C",
    "code": "// Aizu Vol-1 0190: Eleven Puzzle\n// 2017.8.23 bal4u@uu\n// 2017.11.21\n\n#include <stdio.h>\n#define TM 0\n#if TM\n#include <time.h>\n#endif\n\ntypedef unsigned long long UL;\n\n#define HASHSIZ 900001\ntypedef struct { UL s; char m; } HASH;\nHASH hash[HASHSIZ+3], *hashend = hash+HASHSIZ;\n\nint lookup(UL s)\n{\n\tHASH *p = hash + s % HASHSIZ;\n\twhile (p->s) {\n\t\tif (p->s == s) return p->m;\n\t\tif (++p == hashend) p = hash;\n\t}\n\treturn -1;\n}\n\nint insert(UL s, char m)\n{\n\tHASH *p = hash + s % HASHSIZ;\n\twhile (p->s) {\n\t\tif (p->s == s) return 0;\n\t\tif (++p == hashend) p = hash;\n\t}\n\tp->s = s, p->m = m;\n\treturn 1;\n}\n\n#define MAX 500000\ntypedef struct { UL s; char b1, b2; } QUE;\nQUE Q[MAX+3], *top, *end, *qmax = Q+MAX;\n\nint move[13][5] = {\n\t/*  0 */{ 2, -1 },\n\t/*  1 */{ 2, 5, -1 },\n\t/*  2 */{ 0, 1, 3, 6, -1 },\n\t/*  3 */{ 2, 7, -1 },\n\t/*  4 */{ 5, -1 },\n\t/*  5 */{ 1, 4, 6, 9, -1 },\n\t/*  6 */{ 2, 5, 7, 10, -1 },\n\t/*  7 */{ 3, 6, 8, 11, -1 },\n\t/*  8 */{ 7, -1 },\n\t/*  9 */{ 5, 10, -1 },\n\t/* 10 */{ 6, 9, 11, 12, -1 },\n\t/* 11 */{ 7, 10, -1 },\n\t/* 12 */{ 10, -1 } };\n\nUL swap(UL s, int p, int sp)\n{\n\tUL n;\n\tp = (12 - p) << 2, sp = (12 - sp) << 2;\n\tn = (s >> p) & 0xf;\n\ts &= ~(0xfULL << p);\n\treturn s | (n << sp);\n}\n\nint sach(UL s, int b1, int b2, int mode, int lim)\n{\n\tint i, j, x, b[2], step = 1;\n\tUL s2;\n\n\ttop = end = Q, end->s = s, end->b1 = b1, end->b2 = b2, end++, end->s = 0, end++;\n\twhile (top+1 < end) {\n\t\ts = top->s, b[0] = top->b1, b[1] = top->b2, top++;\n\t\tif (!s) { step++, end->s = 0, end++; continue; }\n\t\tif (step > lim) break;\n//\tprintf(\"%#15llx, b1 %2d, b2 %2d, step %2d\\n\", s, b[0], b[1], step);\n\t\tfor (i = 0; i < 2; i++) {\n\t\t\tfor (j = 0; (x = move[b[i]][j]) >= 0; j++) {\n\t\t\t\tif (x == b[0] || x == b[1]) continue;\n\t\t\t\ts2 = swap(s, x, b[i]);\n\t\t\t\tif (mode) { if (lookup(s2) >= 0) return step; }\n\t\t\t\telse if (!insert(s2, step)) continue;\n\t\t\t\tend->s = s2;\n\t\t\t\tif (i) end->b1 = b[0], end->b2 = x;\n\t\t\t\telse   end->b1 = x, end->b2 = b[1];\n\t\t\t\tend++;\n\t\t\t}\n\t\t}\n\t}\n\treturn step;\n}\n\nint main()\n{\n\tUL s;\n\tint i, ans, p, b1, b2;\n#if TM\n\tclock_t start, finish;\n\tstart = clock();\n#endif\n\ts = 0x123456789ab0ULL, insert(s, 0);\n\tsach(s, 0, 12, 0, 14);\n\twhile (1) {\n\t\tfor (b1 = -1, s = i = 0; i < 13; i++) {\n\t\t\tscanf(\"%d\", &p);\n\t\t\tif (p < 0) goto done;\n\t\t\tif (!p) { if (b1 < 0) b1 = i; else b2 = i; }\n\t\t\ts = (s << 4) | p;\n\t\t}\n\t\tif ((ans = lookup(s)) < 0) {\n\t\t\tif ((ans = sach(s, b1, b2, 1, 6)) > 6) ans = -1;\n\t\t\telse ans += 14;\n\t\t}\n\t\tprintf(ans < 0 ? \"NA\\n\" : \"%d\\n\", ans);\t\n\t}\ndone:\n#if TM\n\tfinish = clock();\n\tprintf(\"time %lf\\n\", (double)(finish-start)/CLOCKS_PER_SEC);\n#endif\n\treturn 0;\n}"
  },
  {
    "language": "C",
    "code": "// Aizu Vol-1 0190: Eleven Puzzle\n// 2017.8.23 bal4u@uu\n// ???????????¢?´¢??????????????\\??????????????§??¶????????§??????\n// ????????????????????????16?????????????????§??§???OK???\n// 1????????????????????§8??????4??????????????§4096????????¶??????\n\n#include <stdio.h>\n\n#define MAX 500000\ntypedef unsigned long long UL;\n\ntypedef struct { UL s; char m; } HASH;\ntypedef struct { UL s; char b1, b2; } QUE;\n#define HASHSIZ 900001ULL\nHASH hash[HASHSIZ + 5], *hashend = hash + HASHSIZ;\nQUE Q[MAX + 5], *top, *end, *qmax = Q + MAX;\n\nint lookup(UL s)\n{\n\tHASH *p = hash + s % HASHSIZ;\n\twhile (p->s) {\n\t\tif (p->s == s) return p->m;\n\t\tif (++p == hashend) p = hash;\n\t}\n\treturn -1;\n}\n\nint insert(UL s, char m)\n{\n\tHASH *p = hash + s % HASHSIZ;\n\twhile (p->s) {\n\t\tif (p->s == s) return 0;\n\t\tif (++p == hashend) p = hash;\n\t}\n\tp->s = s, p->m = m;\n\treturn 1;\n}\n\nint move[13][5] = {\n\t/*  0 */{ 2, -1 },\n\t/*  1 */{ 2, 5, -1 },\n\t/*  2 */{ 0, 1, 3, 6, -1 },\n\t/*  3 */{ 2, 7, -1 },\n\t/*  4 */{ 5, -1 },\n\t/*  5 */{ 1, 4, 6, 9, -1 },\n\t/*  6 */{ 2, 5, 7, 10, -1 },\n\t/*  7 */{ 3, 6, 8, 11, -1 },\n\t/*  8 */{ 7, -1 },\n\t/*  9 */{ 5, 10, -1 },\n\t/* 10 */{ 6, 9, 11, 12, -1 },\n\t/* 11 */{ 7, 10, -1 },\n\t/* 12 */{ 10, -1 } };\n\nUL swap(UL s, int p1, int sp)\n{\n\tUL n1;\n\tp1 = (12 - p1) << 2, sp = (12 - sp) << 2;\n\tn1 = (s >> p1) & 0xf;\n\ts &= ~(0xfULL << p1);\n\ts |= (n1 << sp);\n\treturn s;\n}\n\nint sach(UL s, int b1, int b2, int mode, int step, int lim)\n{\n\tint i, j, k, x, b[2];\n\tUL s2;\n\n\ttop = end = Q;\n\tend->s = s, end->b1 = 0, end->b2 = 12, end++, end->s = 0, end++;\n\twhile (top < end) {\n\t\ts = top->s, b[0] = top->b1, b[1] = top->b2, top++;\n\t\tif (!s) { step++, end->s = 0, end++; continue; }\n\t\tif (step > lim) break;\n//\tprintf(\"%#15llx, b1 %2d, b2 %2d, step %2d\\n\", s, b[0], b[1], step);\n\t\tfor (i = 0; i < 2; i++) {\n\t\t\tfor (j = 0; (x = move[b[i]][j]) >= 0; j++) {\n\t\t\t\tif (x == b[0] || x == b[1]) continue;\n\t\t\t\ts2 = swap(s, x, b[i]);\n\t\t\t\tif (mode) { if ((k = lookup(s2) >= 0)) return k; }\n\t\t\t\telse if (!insert(s2, step)) continue;\n\t\t\t\tend->s = s2;\n\t\t\t\tif (i) end->b1 = b[0], end->b2 = x;\n\t\t\t\telse   end->b1 = x, end->b2 = b[1];\n\t\t\t\tend++;\n\t\t\t}\n\t\t}\n\t}\n\treturn step;\n}\n\nint main()\n{\n\tint i, ans, p, b1, b2;\n\tUL s;\n\n\ts = 0x123456789ab0ULL, insert(s, 0);\n\tsach(s, 0, 12, 0, 1, 16);\n\twhile (1) {\n\t\tb1 = -1;\n\t\tfor (s = i = 0; i < 13; i++) {\n\t\t\tscanf(\"%d\", &p);\n\t\t\tif (i == 0 && p < 0) return 0;\n\t\t\tif (!p) { if (b1 < 0) b1 = i; else b2 = i; }\n\t\t\ts = (s << 4) | p;\n\t\t}\n\t\tif ((ans = lookup(s)) < 0) {\n\t\t\tif ((ans = sach(s, b1, b2, 1, 0, 4)) > 4) ans = -1;\n\t\t\telse ans += 16;\n\t\t}\n\t\tprintf(ans < 0 ? \"NA\\n\" : \"%d\\n\", ans);\t\n\t}\n\treturn 0;\n}"
  },
  {
    "language": "C",
    "code": "#include <stdio.h>\n#include <math.h>\n#include <stdlib.h>\n \ntypedef struct{\n    long long int code;\n    int steps;\n} puzz;\n \nint q[1000000][14],size[100000];\nlong long int FR,TO,SW;\npuzz* hash[60000][100];\n \nvoid swap (int* x,int* y){\n    int z;\n    z=*x;\n    *x=*y;\n    *y=z;\n}\n \nlong long int convert(int a[]){\n    long long int ret=0;\n    int i;\n    for(i=0;i<13;i++)ret=ret*13+a[i];\n    return ret;\n}\n \nvoid hashadd(long long int code,int step){\n    int ccc=code%60000;\n    puzz* ppp=(puzz*)malloc(sizeof(puzz));\n    ppp->code=code;\n    ppp->steps=step;\n    if(size[ccc]>99){fprintf(stderr,\"SIZE OVER!! (%d)\\n\",ccc);return;}\n    hash[ccc][size[ccc]]=ppp;\n    size[ccc]++;\n}\n \nint hashsearch(long long int code){\n    int ccc=code%60000;\n    int i=size[ccc]-1;\n    for(;i>=0;i--){\n        if(hash[ccc][i]->code==code)return hash[ccc][i]->steps;\n    }\n    return -1;\n}\n \nvoid mark(int x,int y){\n    int k;\n    long long int cd;\n \n    swap(&q[FR][x],&q[FR][y]);\n    cd=convert(q[FR]);\n \n    if(SW==1 || hashsearch(cd)<0){\n        for(k=0;k<14;k++){q[TO][k]=q[FR][k];}\n        q[TO][13]++;\n        if(SW==0)hashadd(cd,q[TO][13]);\n        TO++;\n    }\n \n    swap(&q[FR][x],&q[FR][y]);\n \n}\n \nvoid check(){\n    if(q[FR][0]==0){mark(0,2);}\n    if(q[FR][1]==0){mark(1,2);mark(1,5);}\n    if(q[FR][2]==0){mark(2,0);mark(2,1);mark(2,3);mark(2,6);}\n    if(q[FR][3]==0){mark(3,2);mark(3,7);}\n    if(q[FR][4]==0){mark(4,5);}\n    if(q[FR][5]==0){mark(5,1);mark(5,4);mark(5,6);mark(5,9);}\n    if(q[FR][6]==0){mark(6,2);mark(6,5);mark(6,7);mark(6,10);}\n    if(q[FR][7]==0){mark(7,3);mark(7,6);mark(7,8);mark(7,11);}\n    if(q[FR][8]==0){mark(8,7);}\n    if(q[FR][9]==0){mark(9,5);mark(9,10);}\n    if(q[FR][10]==0){mark(10,6);mark(10,9);mark(10,11);mark(10,12);}\n    if(q[FR][11]==0){mark(11,7);mark(11,10);}\n    if(q[FR][12]==0){mark(12,10);}\n}\n \n \nint main(){\n    int i,ans;\n    long long int cd;\n \n    for(i=1;i<12;i++)q[0][i]=i;\n    q[0][0]=0;q[0][12]=0;q[0][13]=0;\n    hashadd(convert(q[0]),0);\n \n    FR=0;TO=1;SW=0;\n \n    while(FR<TO && q[FR][13]<=13){\n        check();\n        FR++;\n    }\n\n    while(scanf(\"%d\",&q[0][0])*q[0][0]>=0){\n        for(i=1;i<13;i++)scanf(\"%d\",&q[0][i]);\n        q[0][13]=0;FR=0;TO=1;SW=1;ans=9999;\n \n        while(FR<TO){\n            cd=hashsearch(convert(q[FR]));\n            if(cd>=0){\n                ans=(int)cd+q[FR][13];\n                break;\n            }\n            if(q[FR][13]<6)check();\n            FR++;\n        }\n \n        if(ans>20)printf(\"NA\\n\"); else printf(\"%d\\n\",ans);\n    }\n \n    return 0;\n}"
  },
  {
    "language": "C",
    "code": "// Aizu Vol-1 0190: Eleven Puzzle\n// 2017.8.23 bal4u@uu\n// 2017.11.21\n\n#include <stdio.h>\n#define TM 0\n#if TM\n#include <time.h>\n#endif\n\ntypedef unsigned long long UL;\n\n#define HASHSIZ 900001\ntypedef struct { UL s; char m; } HASH;\nHASH hash[HASHSIZ+3], *hashend = hash+HASHSIZ;\n\nint lookup(UL s)\n{\n\tHASH *p = hash + s % HASHSIZ;\n\twhile (p->s) {\n\t\tif (p->s == s) return p->m;\n\t\tif (++p == hashend) p = hash;\n\t}\n\treturn -1;\n}\n\nint insert(UL s, char m)\n{\n\tHASH *p = hash + s % HASHSIZ;\n\twhile (p->s) {\n\t\tif (p->s == s) return 0;\n\t\tif (++p == hashend) p = hash;\n\t}\n\tp->s = s, p->m = m;\n\treturn 1;\n}\n\n#define MAX 500000\ntypedef struct { UL s; char b1, b2; } QUE;\nQUE Q[MAX+3], *top, *end, *qmax = Q+MAX;\n\nint move[13][5] = {\n\t/*  0 */{ 2, -1 },\n\t/*  1 */{ 2, 5, -1 },\n\t/*  2 */{ 0, 1, 3, 6, -1 },\n\t/*  3 */{ 2, 7, -1 },\n\t/*  4 */{ 5, -1 },\n\t/*  5 */{ 1, 4, 6, 9, -1 },\n\t/*  6 */{ 2, 5, 7, 10, -1 },\n\t/*  7 */{ 3, 6, 8, 11, -1 },\n\t/*  8 */{ 7, -1 },\n\t/*  9 */{ 5, 10, -1 },\n\t/* 10 */{ 6, 9, 11, 12, -1 },\n\t/* 11 */{ 7, 10, -1 },\n\t/* 12 */{ 10, -1 } };\n\nUL swap(UL s, int p, int sp)\n{\n\tUL n;\n\tp = (12 - p) << 2, sp = (12 - sp) << 2;\n\tn = (s >> p) & 0xf;\n\ts &= ~(0xfULL << p);\n\treturn s | (n << sp);\n}\n\nint sach(UL s, int b1, int b2, int mode, int lim)\n{\n\tint i, j, x, b[2], step = 1;\n\tUL s2;\n\n\ttop = end = Q, end->s = s, end->b1 = b1, end->b2 = b2, end++, end->s = 0, end++;\n\twhile (top+1 < end) {\n\t\ts = top->s, b[0] = top->b1, b[1] = top->b2, top++;\n\t\tif (!s) { step++, end->s = 0, end++; continue; }\n\t\tif (step > lim) break;\n//\tprintf(\"%#15llx, b1 %2d, b2 %2d, step %2d\\n\", s, b[0], b[1], step);\n\t\tfor (i = 0; i < 2; i++) {\n\t\t\tfor (j = 0; (x = move[b[i]][j]) >= 0; j++) {\n\t\t\t\tif (x == b[0] || x == b[1]) continue;\n\t\t\t\ts2 = swap(s, x, b[i]);\n\t\t\t\tif (mode) { if (lookup(s2) >= 0) return step; }\n\t\t\t\telse if (!insert(s2, step)) continue;\n\t\t\t\tend->s = s2;\n\t\t\t\tif (i) end->b1 = b[0], end->b2 = x;\n\t\t\t\telse   end->b1 = x, end->b2 = b[1];\n\t\t\t\tend++;\n\t\t\t}\n\t\t}\n\t}\n\treturn step;\n}\n\nint main()\n{\n\tUL s;\n\tint i, ans, p, b1, b2;\n#if TM\n\tclock_t start, finish;\n\tstart = clock();\n#endif\n\ts = 0x123456789ab0ULL, insert(s, 0);\n\tsach(s, 0, 12, 0, 14);\n\twhile (1) {\n\t\tfor (b1 = -1, s = i = 0; i < 13; i++) {\n\t\t\tscanf(\"%d\", &p);\n\t\t\tif (p < 0) goto done;\n\t\t\tif (!p) { if (b1 < 0) b1 = i; else b2 = i; }\n\t\t\ts = (s << 4) | p;\n\t\t}\n\t\tif ((ans = lookup(s)) < 0) {\n\t\t\tif ((ans = sach(s, b1, b2, 1, 6)) > 6) ans = -1;\n\t\t\telse ans += 16;\n\t\t}\n\t\tprintf(ans < 0 ? \"NA\\n\" : \"%d\\n\", ans);\t\n\t}\ndone:\n#if TM\n\tfinish = clock();\n\tprintf(\"time %lf\\n\", (double)(finish-start)/CLOCKS_PER_SEC);\n#endif\n\treturn 0;\n}"
  },
  {
    "language": "C",
    "code": "// Aizu Vol-1 0190: Eleven Puzzle\n// 2017.8.21 bal4u@uu\n// ??±???????????¢?´¢??????????????\\??????????????§??¶????????§??????\n\n#include <stdio.h>\n\n#define MAX 10000\ntypedef unsigned long long UL;\n\ntypedef struct { UL s; char m; } HASH;\ntypedef struct { UL s; char m, b1, b2; } QUE;\n#define HASHSIZ 200003ULL   // 19997\nHASH hash[HASHSIZ + 5], *hashend = hash + HASHSIZ;\nQUE Q[MAX + 5]; int top;\n\nint lookup(UL s)\n{\n\tHASH *p = hash + s % HASHSIZ;\n\twhile (p->s) {\n\t\tif (p->s == s) return p->m;\n\t\tif (++p == hashend) p = hash;\n\t}\n\treturn -1;\n}\n\nint insert(UL s, char m)\n{\n\tHASH *p = hash + s % HASHSIZ;\n\twhile (p->s) {\n\t\tif (p->s == s) {\n\t\t\tif (p->m > m) { p->m = m; return 1; }\n\t\t\treturn 0;\n\t\t}\n\t\tif (++p == hashend) p = hash;\n\t}\n\tp->s = s, p->m = m;\n\treturn 1;\n}\n\nint move[13][5] = {\n\t/*  0 */{ 2, -1 },\n\t/*  1 */{ 2, 5, -1 },\n\t/*  2 */{ 0, 1, 3, 6, -1 },\n\t/*  3 */{ 2, 7, -1 },\n\t/*  4 */{ 5, -1 },\n\t/*  5 */{ 1, 4, 6, 9, -1 },\n\t/*  6 */{ 2, 5, 7, 10, -1 },\n\t/*  7 */{ 3, 6, 8, 11, -1 },\n\t/*  8 */{ 7, -1 },\n\t/*  9 */{ 5, 10, -1 },\n\t/* 10 */{ 6, 9, 11, 12, -1 },\n\t/* 11 */{ 7, 10, -1 },\n\t/* 12 */{ 10, -1 } };\n\nUL bit[13] = {\n\t0x0ffffffffffffULL, 0xf0fffffffffffULL, 0xff0ffffffffffULL, 0xfff0fffffffffULL,\n\t0xffff0ffffffffULL, 0xfffff0fffffffULL, 0xffffff0ffffffULL, 0xfffffff0fffffULL,\n\t0xffffffff0ffffULL, 0xfffffffff0fffULL, 0xffffffffff0ffULL, 0xfffffffffff0fULL,\n\t0xffffffffffff0ULL };\n\nUL nextStep(UL s, int new, int old)\n{\n\tUL n;\n\t\n\tn = ((s >> ((12 - new) << 2))) & 0xf;\n//\tprintf(\" %llx, n %llx, new %d, old %d\", s, n, new, old);\n\ts &= ( bit[new] & bit[old]);\n\ts |= (n << ((12 - old) << 2));\n//\tprintf(\" ----> %llx \\n\", s);\n\treturn s;\n}\n\nvoid state(void)\n{\n\tint i, j, k, x, step, b[2];\n\tUL s, s2;\n\n\ts = 0x123456789ab0ULL;\n\tQ[0].s = s, Q[0].m = 0, Q[0].b1 = 0, Q[0].b2 = 12, insert(s, 0);\n\ttop = 1;\n\twhile (top) {\n\t\ts = Q[--top].s, step = Q[top].m + 1;\n\t\tb[0] = Q[top].b1, b[1] = Q[top].b2;\n\t\tif (step > 20) continue;\n//\tprintf(\"%0llx, b1 %d, b2 %d, step %d, max %d, top %d\\n\", s, b[0], b[1], step-1, max, top);\n\n\t\tfor (i = 0; i < 2; i++) {\n\t\t\tk = b[i];\n\t\t\tfor (j = 0; (x = move[k][j]) >= 0; j++) {\n\t\t\t\tif (x == b[0] || x == b[1]) continue;\n\t\t\t\tif (i && x < 6 || !i && x > 6) continue;\n\t\t\t\ts2 = nextStep(s, x, k);\n\t\t\t\tif (insert(s2, step)) {\n\t\t\t\t\tQ[top].s = s2, Q[top].m = step;\n\t\t\t\t\tif (i)  Q[top].b1 = b[0], Q[top].b2 = x;\n\t\t\t\t\telse    Q[top].b1 = x, Q[top].b2 = b[1];\n\t\t\t\t\ttop++;\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t}\n}\n\nint main()\n{\n\tint i, p;\n\tUL s;\n\n\tstate();\n\twhile (1) {\n\t\tfor (s = i = 0; i < 13; i++) {\n\t\t\tscanf(\"%d\", &p);\n\t\t\tif (i == 0 && p < 0) return 0;\n\t\t\ts = (s << 4) | p;\n\t\t}\n\t\tif ((p = lookup(s)) >= 0) printf(\"%d\\n\", p);\n\t\telse puts(\"NA\");\n\t}\n\treturn 0;\n}"
  },
  {
    "language": "C",
    "code": "// Aizu Vol-1 0190: Eleven Puzzle\n// 2017.8.23 bal4u@uu\n// 2017.11.21\n\n#include <stdio.h>\n#define TM 0\n#if TM\n#include <time.h>\n#endif\n\ntypedef unsigned long long UL;\n\n#define HASHSIZ 900001\ntypedef struct { UL s; char m; } HASH;\nHASH hash[HASHSIZ+3], *hashend = hash+HASHSIZ;\n\nint lookup(UL s)\n{\n\tHASH *p = hash + s % HASHSIZ;\n\twhile (p->s) {\n\t\tif (p->s == s) return p->m;\n\t\tif (++p == hashend) p = hash;\n\t}\n\treturn -1;\n}\n\nint insert(UL s, char m)\n{\n\tHASH *p = hash + s % HASHSIZ;\n\twhile (p->s) {\n\t\tif (p->s == s) return 0;\n\t\tif (++p == hashend) p = hash;\n\t}\n\tp->s = s, p->m = m;\n\treturn 1;\n}\n\n#define MAX 500000\ntypedef struct { UL s; char b1, b2; } QUE;\nQUE Q[MAX+3], *top, *end, *qmax = Q+MAX;\n\nint move[13][5] = {\n\t/*  0 */{ 2, -1 },\n\t/*  1 */{ 2, 5, -1 },\n\t/*  2 */{ 0, 1, 3, 6, -1 },\n\t/*  3 */{ 2, 7, -1 },\n\t/*  4 */{ 5, -1 },\n\t/*  5 */{ 1, 4, 6, 9, -1 },\n\t/*  6 */{ 2, 5, 7, 10, -1 },\n\t/*  7 */{ 3, 6, 8, 11, -1 },\n\t/*  8 */{ 7, -1 },\n\t/*  9 */{ 5, 10, -1 },\n\t/* 10 */{ 6, 9, 11, 12, -1 },\n\t/* 11 */{ 7, 10, -1 },\n\t/* 12 */{ 10, -1 } };\n\nUL swap(UL s, int p, int sp)\n{\n\tUL n;\n\tp = (12 - p) << 2, sp = (12 - sp) << 2;\n\tn = (s >> p) & 0xf;\n\ts &= ~(0xfULL << p);\n\treturn s | (n << sp);\n}\n\nint sach(UL s, int b1, int b2, int mode, int lim)\n{\n\tint i, j, x, b[2], step = 1;\n\tUL s2;\n\n\ttop = end = Q, end->s = s, end->b1 = b1, end->b2 = b2, end++, end->s = 0, end++;\n\twhile (top+1 < end) {\n\t\ts = top->s, b[0] = top->b1, b[1] = top->b2, top++;\n\t\tif (!s) { step++, end->s = 0, end++; continue; }\n\t\tif (step > lim) break;\n//\tprintf(\"%#15llx, b1 %2d, b2 %2d, step %2d\\n\", s, b[0], b[1], step);\n\t\tfor (i = 0; i < 2; i++) {\n\t\t\tfor (j = 0; (x = move[b[i]][j]) >= 0; j++) {\n\t\t\t\tif (x == b[0] || x == b[1]) continue;\n\t\t\t\ts2 = swap(s, x, b[i]);\n\t\t\t\tif (mode) { if (lookup(s2) >= 0) return step; }\n\t\t\t\telse if (!insert(s2, step)) continue;\n\t\t\t\tend->s = s2;\n\t\t\t\tif (i) end->b1 = b[0], end->b2 = x;\n\t\t\t\telse   end->b1 = x, end->b2 = b[1];\n\t\t\t\tend++;\n\t\t\t}\n\t\t}\n\t}\n\treturn step;\n}\n\n#define PAR  12\nint main()\n{\n\tUL s;\n\tint i, ans, p, b1, b2;\n#if TM\n\tclock_t start, finish;\n\tstart = clock();\n#endif\n\ts = 0x123456789ab0ULL, insert(s, 0);\n\tsach(s, 0, 12, 0, PAR);\n\twhile (1) {\n\t\tfor (b1 = -1, s = i = 0; i < 13; i++) {\n\t\t\tscanf(\"%d\", &p);\n\t\t\tif (p < 0) goto done;\n\t\t\tif (!p) { if (b1 < 0) b1 = i; else b2 = i; }\n\t\t\ts = (s << 4) | p;\n\t\t}\n\t\tif ((ans = lookup(s)) < 0) {\n\t\t\tif ((ans = sach(s, b1, b2, 1, 20-PAR)) > 20-PAR) ans = -1;\n\t\t\telse ans += PAR;\n\t\t}\n\t\tprintf(ans < 0 ? \"NA\\n\" : \"%d\\n\", ans);\t\n\t}\ndone:\n#if TM\n\tfinish = clock();\n\tprintf(\"time %lf\\n\", (double)(finish-start)/CLOCKS_PER_SEC);\n#endif\n\treturn 0;\n}"
  },
  {
    "language": "C",
    "code": "#include <stdio.h>\n#include <math.h>\n#include <stdlib.h>\n \ntypedef struct{\n    long long int code;\n    int steps;\n} puzz;\n \nint q[1000000][14],size[500000];\nlong long int FR,TO,SW;\npuzz* hash[500000][5];\n \nvoid swap (int* x,int* y){\n    int z;\n    z=*x;\n    *x=*y;\n    *y=z;\n}\n \nlong long int convert(int a[]){\n    long long int ret=0;\n    int i;\n    for(i=0;i<13;i++)ret=ret*13+a[i];\n    return ret;\n}\n \nvoid hashadd(long long int code,int step){\n    int ccc=code%499999;\n    puzz* ppp=(puzz*)malloc(sizeof(puzz));\n    ppp->code=code;\n    ppp->steps=step;\n    if(size[ccc]>4){fprintf(stderr,\"SIZE OVER!! (%d)\\n\",ccc);return;}\n    hash[ccc][size[ccc]]=ppp;\n    size[ccc]++;\n}\n \nint hashsearch(long long int code){\n    int ccc=code%499999;\n    int i=size[ccc]-1;\n    for(;i>=0;i--){\n        if(hash[ccc][i]->code==code)return hash[ccc][i]->steps;\n    }\n    return -1;\n}\n \nvoid mark(int x,int y){\n    int k;\n    long long int cd;\n \n    swap(&q[FR][x],&q[FR][y]);\n    cd=convert(q[FR]);\n \n    if(SW==1 || hashsearch(cd)<0){\n        for(k=0;k<14;k++){q[TO][k]=q[FR][k];}\n        q[TO][13]++;\n        if(SW==0)hashadd(cd,q[TO][13]);\n        TO++;\n    }\n \n    swap(&q[FR][x],&q[FR][y]);\n \n}\n \nvoid check(){\n    if(q[FR][0]==0){mark(0,2);}\n    if(q[FR][1]==0){mark(1,2);mark(1,5);}\n    if(q[FR][2]==0){mark(2,0);mark(2,1);mark(2,3);mark(2,6);}\n    if(q[FR][3]==0){mark(3,2);mark(3,7);}\n    if(q[FR][4]==0){mark(4,5);}\n    if(q[FR][5]==0){mark(5,1);mark(5,4);mark(5,6);mark(5,9);}\n    if(q[FR][6]==0){mark(6,2);mark(6,5);mark(6,7);mark(6,10);}\n    if(q[FR][7]==0){mark(7,3);mark(7,6);mark(7,8);mark(7,11);}\n    if(q[FR][8]==0){mark(8,7);}\n    if(q[FR][9]==0){mark(9,5);mark(9,10);}\n    if(q[FR][10]==0){mark(10,6);mark(10,9);mark(10,11);mark(10,12);}\n    if(q[FR][11]==0){mark(11,7);mark(11,10);}\n    if(q[FR][12]==0){mark(12,10);}\n}\n \n \nint main(){\n    int i,ans;\n    long long int cd;\n \n    for(i=1;i<12;i++)q[0][i]=i;\n    q[0][0]=0;q[0][12]=0;q[0][13]=0;\n    hashadd(convert(q[0]),0);\n \n    FR=0;TO=1;SW=0;\n \n    while(FR<TO && q[FR][13]<=13){\n        check();\n        FR++;\n    }\n\n    while(scanf(\"%d\",&q[0][0])*q[0][0]>=0){\n        for(i=1;i<13;i++)scanf(\"%d\",&q[0][i]);\n        q[0][13]=0;FR=0;TO=1;SW=1;ans=9999;\n \n        while(FR<TO){\n            cd=hashsearch(convert(q[FR]));\n            if(cd>=0){\n                ans=(int)cd+q[FR][13];\n                break;\n            }\n            if(q[FR][13]<6)check();\n            FR++;\n        }\n \n        if(ans>20)printf(\"NA\\n\"); else printf(\"%d\\n\",ans);\n    }\n \n    return 0;\n}"
  },
  {
    "language": "C",
    "code": "// Aizu Vol-1 0190: Eleven Puzzle\n// 2017.8.23 bal4u@uu\n// ???????????¢?´¢??????????????\\??????????????§??¶????????§??????\n\n#include <stdio.h>\n\n#define MAX 999983\ntypedef unsigned long long UL;\n\ntypedef struct { UL s; char m; } HASH;\ntypedef struct { UL s; char b1, b2; } QUE;\n#define HASHSIZ 999983ULL   // 19997\nHASH hash[HASHSIZ + 5], *hashend = hash + HASHSIZ;\nQUE Q[MAX + 5], *top, *end, *qmax = Q + MAX;\n\nint lookup(UL s)\n{\n\tHASH *p = hash + s % HASHSIZ;\n\twhile (p->s) {\n\t\tif (p->s == s) return p->m;\n\t\tif (++p == hashend) p = hash;\n\t}\n\treturn -1;\n}\n\nint insert(UL s, char m)\n{\n\tHASH *p = hash + s % HASHSIZ;\n\twhile (p->s) {\n\t\tif (p->s == s) return 0;\n\t\tif (++p == hashend) p = hash;\n\t}\n\tp->s = s, p->m = m;\n\treturn 1;\n}\n\nint move[13][5] = {\n\t/*  0 */{ 2, -1 },\n\t/*  1 */{ 2, 5, -1 },\n\t/*  2 */{ 0, 1, 3, 6, -1 },\n\t/*  3 */{ 2, 7, -1 },\n\t/*  4 */{ 5, -1 },\n\t/*  5 */{ 1, 4, 6, 9, -1 },\n\t/*  6 */{ 2, 5, 7, 10, -1 },\n\t/*  7 */{ 3, 6, 8, 11, -1 },\n\t/*  8 */{ 7, -1 },\n\t/*  9 */{ 5, 10, -1 },\n\t/* 10 */{ 6, 9, 11, 12, -1 },\n\t/* 11 */{ 7, 10, -1 },\n\t/* 12 */{ 10, -1 } };\n\nUL swap(UL s, int p1, int sp)\n{\n\tUL n1;\n\n\tp1 = (12 - p1) << 2, sp = (12 - sp) << 2;\n\tn1 = (s >> p1) & 0xf;\n\ts &= ~(0xfULL << p1);\n\ts |= (n1 << sp);\n\treturn s;\n}\n\nvoid state(void)\n{\n\tint i, j, k, x, step, b[2];\n\tUL s, s2;\n\n\ts = 0x123456789ab0ULL, insert(s, 0), step = 1;\n\ttop = end = Q;\n\tend->s = s, end->b1 = 0, end->b2 = 12, end++, end->s = 0, end++;\n\twhile (top < end) {\n\t\ts = top->s, b[0] = top->b1, b[1] = top->b2; if (++top >= qmax) top = Q;\n\t\tif (!s) {\n\t\t\tstep++, end->s = 0;\n\t\t\tif (++end >= qmax) end = qmax;\n\t\t\tif (end == top) break;\n\t\t\tcontinue;\n\t\t}\n\t\tif (step > 20) break;\n//\t\tif (b[0] >= b[1]) x = b[0], b[0] = b[1], b[1] = x;\n\n//\tprintf(\"%llx, b1 %d, b2 %d, step %d\\n\", s, b[0], b[1], step);\n\n\t\tfor (i = 0; i < 2; i++) {\n\t\t\tk = b[i];\n\t\t\tfor (j = 0; (x = move[k][j]) >= 0; j++) {\n\t\t\t\tif (x == b[0] || x == b[1]) continue;\n\t\t\t\ts2 = swap(s, x, k);\n\t\t\t\tif (lookup(s2) < 0) {\n\t\t\t\t\tinsert(s2, step);\n\t\t\t\t\tend->s = s2;\n\t\t\t\t\tif (i) end->b1 = b[0], end->b2 = x;\n\t\t\t\t\telse   end->b1 = x, end->b2 = b[1];\n\t\t\t\t\tif (++end >= qmax) end = Q;\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t}\n}\n\nint main()\n{\n\tint i, p;\n\tUL s;\n\n\tstate();\n\twhile (1) {\n\t\tfor (s = i = 0; i < 13; i++) {\n\t\t\tscanf(\"%d\", &p);\n\t\t\tif (i == 0 && p < 0) return 0;\n\t\t\ts = (s << 4) | p;\n\t\t}\n\t\tif ((p = lookup(s)) >= 0) printf(\"%d\\n\", p);\n\t\telse puts(\"NA\");\n\t}\n\treturn 0;\n}"
  },
  {
    "language": "Java",
    "code": "import java.util.ArrayDeque;\nimport java.util.Arrays;\nimport java.util.HashMap;\nimport java.util.Scanner;\n\npublic class Main {\n\tstatic HashMap<String,Integer> map = new HashMap<String,Integer>();\n\tstatic int[][] move = new int[][] {\n\t\t\t\t\t\t\t\t{2},\n\t\t\t\t\t   {2,5},{0,1,3,6},{2,7},\n\t\t\t   {5},{1,4,6,9},{2,5,7,10},{3,6,8,11},{7},\n\t\t\t          {5,10},{6,9,11,12},{7,10},\n\t\t\t          \t\t\t{10}\n\t\t\t          };\n \t\n\tpublic static void main(String[] args) {\n\t\tScanner sc = new Scanner(System.in);\n\t\tString first = \"0123456789AB0\";\n\t\tdfs(0,0,12,first);\n\t\tSystem.out.println(map.size());\n\t\tIN:while(true) {\n\t\t\tchar[] data = new char[13];\n\t\t\tfor(int i = 0; i < 13; i++) {\n\t\t\t\tString tmp = sc.next();\n\t\t\t\tif(tmp.equals(\"-1\")) break IN;\n\t\t\t\tif(tmp.equals(\"10\")) tmp = \"A\";\n\t\t\t\tif(tmp.equals(\"11\")) tmp = \"B\";\n\t\t\t\tdata[i] = tmp.charAt(0);\n\t\t\t}\n\t\t\tif(map.containsKey(String.valueOf(data))) {\n\t\t\t\tSystem.out.println(map.get(String.valueOf(data)));\n\t\t\t}\n\t\t\telse {\n\t\t\t\tSystem.out.println(\"NA\");\n\t\t\t}\n\t\t\t\n\t\t}\n\t}\n\tstatic String swap(int a, int b, String c) {\n\t\tchar[] x = c.toCharArray();\n\t\tchar tmp = x[a];\n\t\tx[a] = x[b];\n\t\tx[b] = tmp;\n\t\tString cx = String.valueOf(x);\n\t\treturn cx;\n\t}\n\tstatic void dfs(int a, int b1,int b2, String c) {\n\t\tif(a >= 10) return;\n\t\tif(map.containsKey(c)) {\n\t\t\tif(map.get(c) <= a) {\n\t\t\t\treturn;\n\t\t\t}\n\t\t\telse {\n\t\t\t\tmap.put(c, a);\n\t\t\t}\n\t\t}\n\t\telse {\n\t\t\tmap.put(c, a);\n\t\t}\n\t\tfor(int i = 0; i < 13; i++) {\n\t\t\tif(b1 == i) {\n\t\t\t\tfor(int j = 0; j < move[i].length; j++) {\n\t\t\t\t\tif(move[i][j] == b2) {\n\t\t\t\t\t\tc = swap(b2,b1,c);\n\t\t\t\t\t\tdfs(a,b2,b1,c);\n\t\t\t\t\t\tc = swap(b2,b1,c);\n\t\t\t\t\t}\n\t\t\t\t\telse {\n\t\t\t\t\t\tc = swap(move[i][j],b1,c);\n\t\t\t\t\t\tdfs(a+1,move[i][j],b2,c);\n\t\t\t\t\t\tc = swap(move[i][j],b1,c);\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t}\n\t\t\tif(b2 == i) {\n\t\t\t\tfor(int j = 0; j < move[i].length; j++) {\n\t\t\t\t\tif(move[i][j] == b1) {\n\t\t\t\t\t\tc = swap(b2,b1,c);\n\t\t\t\t\t\tdfs(a,b2,b1,c);\n\t\t\t\t\t\tc = swap(b2,b1,c);\n\t\t\t\t\t}\n\t\t\t\t\telse {\n\t\t\t\t\t\tc = swap(move[i][j],b2,c);\n\t\t\t\t\t\tdfs(a+1,b1,move[i][j],c);\n\t\t\t\t\t\tc = swap(move[i][j],b2,c);\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t}\n\t\n\n}"
  },
  {
    "language": "Java",
    "code": "import java.util.*;\nimport java.util.regex.Pattern;\npublic class Main {\n\t\n\tArrayList<ArrayList<Integer>> swapList;\n\tint ans;\n\tHashMap<String,Integer> fromAns;\n\t\n\tclass C{\n\t\tint s;\n\t\tString now;\n\t\tpublic C(String now, int s){\n\t\t\tthis.now = now;\n\t\t\tthis.s = s;\n\t\t}\n\t}\n\t\n\tprivate void doit(){\n\t\tScanner sc = new Scanner(System.in);\n\t\t\n\t\t//swap pattern list\n\t\tcreateSwapList();\n\t\t\n\t\t//from ans\n\t\tString goal = \"0 1 2 3 4 5 6 7 8 9 10 11 0\";\n\t\tfromAns = new HashMap<String, Integer>();\n\t\tcreateStep(goal);\n\t\t\n\t\twhile(true){\n\t\t\t//input data\n\t\t\tint n = sc.nextInt();\n\t\t\tif(n == -1) break;\n\t\t\t//create start String\n\t\t\tStringBuilder sb  = new StringBuilder(\"\"+n);\n\t\t\tfor(int i=1; i <= 12; i++){\n\t\t\t\tsb.append(\" \");\n\t\t\t\tsb.append(sc.next());\n\t\t\t}\n\t\t\tString startS = sb.toString();\n\t\t\t\n\t\t\tif(fromAns.containsKey(startS)){\n\t\t\t\tSystem.out.println(fromAns.get(startS));\n\t\t\t\tcontinue;\n\t\t\t}\n\t\t\t\n\t\t\t//from start\n\t\t\tans = -1;\n\t\t\tcreateStep(startS);\n\t\t\t\n\t\t\t//comp and out\n\t\t\tif(ans != -1){\n\t\t\t\tSystem.out.println(ans);\n\t\t\t}\n\t\t\telse{\n\t\t\t\tSystem.out.println(\"NA\");\n\t\t\t}\n\t\t}\n\t}\n\t\n\tprivate int getInd0F(String [] s) {\n\t\tint len = s.length;\n\t\tfor(int i=0; i < len; i++){\n\t\t\tif(s[i].equals(\"0\")) return i;\n\t\t}\n\t\treturn -1;\n\t}\n\t\n\tprivate int getInd0L(String [] s) {\n\t\tint len = s.length;\n\t\tfor(int i=len-1; i >= 0; i--){\n\t\t\tif(s[i].equals(\"0\")) return i;\n\t\t}\n\t\treturn -1;\n\t}\n\t\n\tprivate String createS(String [] s){\n\t\tStringBuilder sb = new StringBuilder();\n\t\tfor(int i=0; i < s.length-1; i++){\n\t\t\tsb.append(s[i]);\n\t\t\tsb.append(\" \");\n\t\t}\n\t\tsb.append(s[s.length-1]);\n\t\treturn sb.toString();\n\t}\n\t\n\tprivate void createStep(String start){\n\t\t//init\n\t\tLinkedList<C> open = new LinkedList<C>();\n\t\topen.add(new C(start, 0));\n\t\tHashMap<String, Integer> close = new HashMap<String, Integer>();\n\t\tif(fromAns.containsKey(start)){\n\t\t\tans = fromAns.get(start);\n\t\t\t\n\t\t\treturn ;\n\t\t}\n\t\tclose.put(start, 0);\n\t\t\n\t\t//start\n\t\twhile(! open.isEmpty()){\n\t\t\tC now = open.removeFirst();\n\t\t\t\n\t\t\t//find a zero ind\n\t\t\tString [] nowParse = now.now.split(\" \");\n\t\t\tint ind01 = getInd0F(nowParse);\n\t\t\tint ind02 = getInd0L(nowParse);\n\t\t\tint [] ind0list = {ind01, ind02};\n\t\t\t\n\t\t\t//swap pattern times\n\t\t\tfor(int i = 0; i < ind0list.length;i++){\n\t\t\t\tint nowind = ind0list[i];\n\t\t\t\tfor(int j=0; j < swapList.get(nowind).size(); j++){\n\t\t\t\t\tint swapind = swapList.get(nowind).get(j);\n\t\t\t\t\tString [] work = now.now.split(\" \");\n\t\t\t\t\t\n\t\t\t\t\t//swap\n\t\t\t\t\tString temp = work[nowind];\n\t\t\t\t\twork[nowind] = work[swapind];\n\t\t\t\t\twork[swapind] = temp;\n\t\t\t\t\t\n\t\t\t\t\t//create new String \n\t\t\t\t\tString newS = createS(work);\n\t\t\t\t\t\n\t\t\t\t\t//close contains\n\t\t\t\t\tif(close.containsKey(newS)) continue;\n\t\t\t\t\t\n\t\t\t\t\t//find a goal\n\t\t\t\t\tint nextstep = now.s + 1;\n\t\t\t\t\tif(fromAns.containsKey(newS)){\n\t\t\t\t\t\tans = nextstep + fromAns.get(newS);\n\t\t\t\t\t\treturn ;\n\t\t\t\t\t}\n\t\t\t\t\t\n\t\t\t\t\t//open.add\n\t\t\t\t\tif(now.s != 10){\n\t\t\t\t\t\topen.add(new C(newS, nextstep));\n\t\t\t\t\t}\n\t\t\t\t\t\n\t\t\t\t\t//close.put\n\t\t\t\t\tclose.put(newS, nextstep);\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t\tfromAns = close;\n\t}\n\n\tprivate void createSwapList() {\n\t\tswapList = new ArrayList<ArrayList<Integer>>();\n\t\tfor(int i=0; i <= 12; i++){\n\t\t\tswapList.add(new ArrayList<Integer>());\n\t\t\t//bottom\n\t\t\tif(! (i == 4 || i == 9 || i == 12 || i == 11 || i == 8 || i == 10)){\n\t\t\t\tswapList.get(i).add(i+4);\n\t\t\t}\n\t\t\t//right\n\t\t\tif(! (i == 0 || i == 3 || i == 8 || i == 11 || i == 12)){\n\t\t\t\tswapList.get(i).add(i+1);\n\t\t\t}\n\t\t\t//left\n\t\t\tif(! (i == 0 || i == 1 || i == 4 || i == 9 || i == 12)){\n\t\t\t\tswapList.get(i).add(i-1);\n\t\t\t}\n\t\t\t//top\n\t\t\tif(! (i == 4 || i == 1 || i == 0 || i == 3 || i == 8 || i == 2)){\n\t\t\t\tswapList.get(i).add(i -4);\n\t\t\t}\n\t\t}\n\t\tswapList.get(2).add(0);\n\t\tswapList.get(10).add(12);\n\t\t\n\t}\n\n\tpublic static void main(String[] args) {\n\t\tMain obj = new Main();\n\t\tobj.doit();\n\t}\n}"
  },
  {
    "language": "Java",
    "code": "import java.util.*;\npublic class Main {\n\tint [][] start;\n\tfinal int [] xdir = {0,1,0,-1};\n\tfinal int [] ydir = {1,0,-1,0};\n\n\tpublic class C {\n\t\tint deep;\n\t\tStringBuilder data;\n\t\tpublic C(int deep, String data) {\n\t\t\tthis.deep = deep;\n\t\t\tthis.data = new StringBuilder(data);\n\t\t}\n\t}\n\n\tprivate int[] getIndex(int ind){\n\t\tfor(int i=0; i < 7; i++){\n\t\t\tfor(int j=0; j < 7; j++){\n\t\t\t\tif(start[i][j] == ind){\n\t\t\t\t\tint [] ans = {j,i};\n\t\t\t\t\treturn ans;\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t\treturn null;\n\t}\n\n\tpublic void doIt(){\n\t\tScanner sc = new Scanner(System.in);\n\t\tLinkedList<C> open = new LinkedList<C>();\n\t\tHashMap<String,Integer> close = new HashMap<String, Integer>();\n\t\tstart = new int[7][7];\n\t\tfor(int i=0; i < 7; i++){\n\t\t\tArrays.fill(start[i], -1);\n\t\t}\n\t\tstart[1][3] = 0;\n\t\tstart[2][2] = 1;\n\t\tstart[2][3] = 2;\n\t\tstart[2][4] = 3;\n\t\tstart[3][1] = 4;\n\t\tstart[3][2] = 5;\n\t\tstart[3][3] = 6;\n\t\tstart[3][4] = 7;\n\t\tstart[3][5] = 8;\n\t\tstart[4][2] = 9;\n\t\tstart[4][3] = 10;\n\t\tstart[4][4] = 11;\n\t\tstart[5][3] = 12;\n\t\topen.addLast(new C(0,\"0123456789ab0\"));\n\t\tclose.put(\"0123456789ab0\", 0);\n\n\t\twhile(! open.isEmpty()){\n\t\t\tC pat = open.remove();\n\t\t\tStringBuilder patStr = pat.data;\n\t\t\tint patDeep = pat.deep;\n\t\t\tint lastInd = 0;\n\t\t\tif(patDeep >= 10){\n\t\t\t\tcontinue;\n\t\t\t}\n\n\t\t\tfor(int i=0; i < 2; i++){\n\t\t\t\tint ind = patStr.indexOf(\"0\", lastInd);\n\t\t\t\tint [] result = getIndex(ind);\n\t\t\t\tint x = result[0];\n\t\t\t\tint y = result[1];\n\n\t\t\t\tfor(int j=0; j < 4; j++){\n\t\t\t\t\tint patX = x + xdir[j];\n\t\t\t\t\tint patY = y + ydir[j];\n\t\t\t\t\tif(start[patY][patX] >= 0){\n\t\t\t\t\t\tStringBuilder newStr = new StringBuilder(patStr.toString());\n\t\t\t\t\t\tchar change = newStr.charAt(start[patY][patX]);\n\t\t\t\t\t\tnewStr.setCharAt(ind, change);\n\t\t\t\t\t\tnewStr.setCharAt(start[patY][patX], '0');\n\t\t\t\t\t\tString temp = newStr.toString();\n\n\t\t\t\t\t\tif((! close.containsKey(temp))){\n\t\t\t\t\t\t\topen.addLast(new C(patDeep + 1, temp));\n\t\t\t\t\t\t\tclose.put(temp, patDeep+1);\n\t\t\t\t\t\t}\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t\tlastInd = ind + 1;\n\t\t\t}\n\t\t}\n\n\t\twhile(true){\n\t\t\tint n = sc.nextInt();\n\t\t\tif(n == -1){\n\t\t\t\tbreak;\n\t\t\t}\n\t\t\tStringBuilder input = new StringBuilder();\n\t\t\tif(n == 10){\n\t\t\t\tinput.append('a');\n\t\t\t}\n\t\t\telse if(n == 11){\n\t\t\t\tinput.append('b');\n\t\t\t}\n\t\t\telse{\n\t\t\t\tinput.append(\"\" + n);\n\t\t\t}\n\n\t\t\tfor(int i=0; i < 12; i++){\n\t\t\t\tn = sc.nextInt();\n\t\t\t\tif(n == 10){\n\t\t\t\t\tinput.append('a');\n\t\t\t\t}\n\t\t\t\telse if(n == 11){\n\t\t\t\t\tinput.append('b');\n\t\t\t\t}\n\t\t\t\telse{\n\t\t\t\t\tinput.append(\"\" + n);\n\t\t\t\t}\n\t\t\t}\n\t\t\tString inputStr = input.toString();\n\t\t\tif(close.containsKey(inputStr)){\n\t\t\t\tSystem.out.println(close.get(inputStr));\n\t\t\t}\n\t\t\telse{\n\t\t\t\topen.addLast(new C(0,inputStr));\n\t\t\t\tHashMap<String,Integer> anotherclose = new HashMap<String, Integer>();\n\t\t\t\tanotherclose.put(inputStr, 0);\n\t\t\t\tboolean flg = false;\n\t\t\t\twhile(! open.isEmpty()){\n\t\t\t\t\tC pat = open.remove();\n\t\t\t\t\tStringBuilder patStr = pat.data;\n\t\t\t\t\tint patDeep = pat.deep;\n\t\t\t\t\tint lastInd = 0;\n\t\t\t\t\tif(patDeep >= 10){\n\t\t\t\t\t\tbreak;\n\t\t\t\t\t}\n\n\t\t\t\t\tfor(int i=0; i < 2; i++){\n\t\t\t\t\t\tint ind = patStr.indexOf(\"0\", lastInd);\n\t\t\t\t\t\tint [] result = getIndex(ind);\n\t\t\t\t\t\tint x = result[0];\n\t\t\t\t\t\tint y = result[1];\n\n\t\t\t\t\t\tfor(int j=0; j < 4; j++){\n\t\t\t\t\t\t\tint patX = x + xdir[j];\n\t\t\t\t\t\t\tint patY = y + ydir[j];\n\t\t\t\t\t\t\tif(start[patY][patX] >= 0){\n\t\t\t\t\t\t\t\tStringBuilder newStr = new StringBuilder(patStr.toString());\n\t\t\t\t\t\t\t\tchar change = newStr.charAt(start[patY][patX]);\n\t\t\t\t\t\t\t\tnewStr.setCharAt(ind, change);\n\t\t\t\t\t\t\t\tnewStr.setCharAt(start[patY][patX], '0');\n\t\t\t\t\t\t\t\tString temp = newStr.toString();\n\n\t\t\t\t\t\t\t\tif((close.containsKey(temp))){\n\t\t\t\t\t\t\t\t\tflg = true;\n\t\t\t\t\t\t\t\t\tSystem.out.println(patDeep + 1 + close.get(temp));\n\t\t\t\t\t\t\t\t\tbreak;\n\t\t\t\t\t\t\t\t}\n\n\t\t\t\t\t\t\t\tif((! anotherclose.containsKey(temp))){\n\t\t\t\t\t\t\t\t\topen.addLast(new C(patDeep + 1, temp));\n\t\t\t\t\t\t\t\t\tanotherclose.put(temp, patDeep+1);\n\t\t\t\t\t\t\t\t}\n\t\t\t\t\t\t\t}\n\t\t\t\t\t\t}\n\t\t\t\t\t\tif(flg)\n\t\t\t\t\t\t\tbreak;\n\t\t\t\t\t\tlastInd = ind + 1;\n\t\t\t\t\t}\n\t\t\t\t\tif(flg)\n\t\t\t\t\t\tbreak;\n\t\t\t\t}\n\t\t\t\tif(!flg){\n\t\t\t\t\tSystem.out.println(\"NA\");\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t}\n\tpublic static void main(String[] args) {\n\t\tMain obj = new Main();\n\t\tobj.doIt();\n\t}\n}"
  },
  {
    "language": "Java",
    "code": "import java.util.*;\nimport java.util.regex.Pattern;\npublic class Main {\n\t\n\tArrayList<ArrayList<Integer>> swapList;\n\tint ans;\n\tHashMap<String,Integer> fromAns;\n\t\n\tclass C{\n\t\tint s;\n\t\tString now;\n\t\tpublic C(String now, int s){\n\t\t\tthis.now = now;\n\t\t\tthis.s = s;\n\t\t}\n\t}\n\t\n\tprivate void doit(){\n\t\tScanner sc = new Scanner(System.in);\n\t\t\n\t\t//swap pattern list\n\t\tcreateSwapList();\n\t\t\n\t\t//from ans\n\t\tString goal = \"0 1 2 3 4 5 6 7 8 9 10 11 0\";\n\t\tfromAns = new HashMap<String, Integer>();\n\t\tcreateStep(goal);\n\t\t\n\t\twhile(true){\n\t\t\t//input data\n\t\t\tint n = sc.nextInt();\n\t\t\tif(n == -1) break;\n\t\t\t//create start String\n\t\t\tStringBuilder sb  = new StringBuilder(\"\"+n);\n\t\t\tfor(int i=1; i <= 12; i++){\n\t\t\t\tsb.append(\" \");\n\t\t\t\tsb.append(sc.next());\n\t\t\t}\n\t\t\tString startS = sb.toString();\n\t\t\t\n\t\t\tif(fromAns.containsKey(startS)){\n\t\t\t\tSystem.out.println(fromAns.get(startS));\n\t\t\t\tcontinue;\n\t\t\t}\n\t\t\t\n\t\t\t//from start\n\t\t\tans = -1;\n\t\t\tcreateStep(startS);\n\t\t\t\n\t\t\t//comp and out\n\t\t\tif(ans != -1){\n\t\t\t\tSystem.out.println(ans);\n\t\t\t}\n\t\t\telse if(ans == 20)\n\t\t\t\tSystem.out.println(\"NA\");\n\t\t\telse{\n\t\t\t\tSystem.out.println(\"NA\");\n\t\t\t}\n\t\t}\n\t}\n\t\n\tprivate int getInd0F(String [] s) {\n\t\tint len = s.length;\n\t\tfor(int i=0; i < len; i++){\n\t\t\tif(s[i].equals(\"0\")) return i;\n\t\t}\n\t\treturn -1;\n\t}\n\t\n\tprivate int getInd0L(String [] s) {\n\t\tint len = s.length;\n\t\tfor(int i=len-1; i >= 0; i--){\n\t\t\tif(s[i].equals(\"0\")) return i;\n\t\t}\n\t\treturn -1;\n\t}\n\t\n\tprivate String createS(String [] s){\n\t\tStringBuilder sb = new StringBuilder();\n\t\tfor(int i=0; i < s.length-1; i++){\n\t\t\tsb.append(s[i]);\n\t\t\tsb.append(\" \");\n\t\t}\n\t\tsb.append(s[s.length-1]);\n\t\treturn sb.toString();\n\t}\n\t\n\tprivate void createStep(String start){\n\t\t//init\n\t\tLinkedList<C> open = new LinkedList<C>();\n\t\topen.add(new C(start, 0));\n\t\tHashMap<String, Integer> close = new HashMap<String, Integer>();\n\t\tif(fromAns.containsKey(start)){\n\t\t\tans = fromAns.get(start);\n\t\t\t\n\t\t\treturn ;\n\t\t}\n\t\tclose.put(start, 0);\n\t\t\n\t\t//start\n\t\twhile(! open.isEmpty()){\n\t\t\tC now = open.removeFirst();\n\t\t\t\n\t\t\t//find a zero ind\n\t\t\tString [] nowParse = now.now.split(\" \");\n\t\t\tint ind01 = getInd0F(nowParse);\n\t\t\tint ind02 = getInd0L(nowParse);\n\t\t\tint [] ind0list = {ind01, ind02};\n\t\t\t\n\t\t\t//swap pattern times\n\t\t\tfor(int i = 0; i < ind0list.length;i++){\n\t\t\t\tint nowind = ind0list[i];\n\t\t\t\tfor(int j=0; j < swapList.get(nowind).size(); j++){\n\t\t\t\t\tint swapind = swapList.get(nowind).get(j);\n\t\t\t\t\tString [] work = now.now.split(\" \");\n\t\t\t\t\t\n\t\t\t\t\t//swap\n\t\t\t\t\tString temp = work[nowind];\n\t\t\t\t\twork[nowind] = work[swapind];\n\t\t\t\t\twork[swapind] = temp;\n\t\t\t\t\t\n\t\t\t\t\t//create new String \n\t\t\t\t\tString newS = createS(work);\n\t\t\t\t\t\n\t\t\t\t\t//close contains\n\t\t\t\t\tif(close.containsKey(newS)) continue;\n\t\t\t\t\t\n\t\t\t\t\t//find a goal\n\t\t\t\t\tint nextstep = now.s + 1;\n\t\t\t\t\tif(fromAns.containsKey(newS)){\n\t\t\t\t\t\tans = nextstep + fromAns.get(newS);\n\t\t\t\t\t\treturn ;\n\t\t\t\t\t}\n\t\t\t\t\t\n\t\t\t\t\t//open.add\n\t\t\t\t\tif(now.s != 10){\n\t\t\t\t\t\topen.add(new C(newS, nextstep));\n\t\t\t\t\t}\n\t\t\t\t\t\n\t\t\t\t\t//close.put\n\t\t\t\t\tclose.put(newS, nextstep);\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t\tfromAns = close;\n\t}\n\n\tprivate void createSwapList() {\n\t\tswapList = new ArrayList<ArrayList<Integer>>();\n\t\tfor(int i=0; i <= 12; i++){\n\t\t\tswapList.add(new ArrayList<Integer>());\n\t\t\t//bottom\n\t\t\tif(! (i == 4 || i == 9 || i == 12 || i == 11 || i == 8 || i == 10)){\n\t\t\t\tswapList.get(i).add(i+4);\n\t\t\t}\n\t\t\t//right\n\t\t\tif(! (i == 0 || i == 3 || i == 8 || i == 11 || i == 12)){\n\t\t\t\tswapList.get(i).add(i+1);\n\t\t\t}\n\t\t\t//left\n\t\t\tif(! (i == 0 || i == 1 || i == 4 || i == 9 || i == 12)){\n\t\t\t\tswapList.get(i).add(i-1);\n\t\t\t}\n\t\t\t//top\n\t\t\tif(! (i == 4 || i == 1 || i == 0 || i == 3 || i == 8 || i == 2)){\n\t\t\t\tswapList.get(i).add(i -4);\n\t\t\t}\n\t\t}\n\t\tswapList.get(2).add(0);\n\t\tswapList.get(10).add(12);\n\t\t\n\t}\n\n\tpublic static void main(String[] args) {\n\t\tMain obj = new Main();\n\t\tobj.doit();\n\t}\n}"
  },
  {
    "language": "Java",
    "code": "import java.util.ArrayDeque;\nimport java.util.Arrays;\nimport java.util.HashMap;\nimport java.util.Scanner;\n\npublic class Main {\n\tstatic HashMap<String,Integer> map = new HashMap<String,Integer>();\n\tstatic int[][] move = new int[][] {\n\t\t\t\t\t\t\t\t{2},\n\t\t\t\t\t   {2,5},{0,1,3,6},{2,7},\n\t\t\t   {5},{1,4,6,9},{2,5,7,10},{3,6,8,11},{7},\n\t\t\t          {5,10},{6,9,11,12},{7,10},\n\t\t\t          \t\t\t{10}\n\t\t\t          };\n \t\n\tpublic static void main(String[] args) {\n\t\tScanner sc = new Scanner(System.in);\n\t\tchar[] first = new char[] { '0','1','2','3','4','5','6','7','8','9','A','B','0'};\n\t\t\n\t\tdfs(0,0,12,first);\n\t\t\n\t\tIN:while(true) {\n\t\t\tchar[] data = new char[13];\n\t\t\tfor(int i = 0; i < 13; i++) {\n\t\t\t\tString tmp = sc.next();\n\t\t\t\tif(tmp.equals(\"-1\")) break IN;\n\t\t\t\tif(tmp.equals(\"10\")) tmp = \"A\";\n\t\t\t\tif(tmp.equals(\"11\")) tmp = \"B\";\n\t\t\t\tdata[i] = tmp.charAt(0);\n\t\t\t}\n\t\t\tif(map.containsKey(String.valueOf(data))) {\n\t\t\t\tSystem.out.println(map.get(String.valueOf(data)));\n\t\t\t}\n\t\t\telse {\n\t\t\t\tSystem.out.println(\"NA\");\n\t\t\t}\n\t\t\t\n\t\t}\n\t}\n\tstatic void swap(int a, int b, char[] c) {\n\t\tchar tmp = c[a];\n\t\tc[a] = c[b];\n\t\tc[b] = tmp;\n\t}\n\tstatic void dfs(int a, int b1,int b2, char[] c) {\n\t\tStringBuilder tmp = new StringBuilder(String.valueOf(c));\n\t\tif(a >= 20) return;\n\t\tString s = tmp.toString();\n\t\tif(map.containsKey(s)) {\n\t\t\tif(map.get(s) <= a) {\n\t\t\t\treturn;\n\t\t\t}\n\t\t\telse {\n\t\t\t\tmap.put(s, a);\n\t\t\t}\n\t\t}\n\t\telse {\n\t\t\tmap.put(s, a);\n\t\t}\n\t\tfor(int i = 0; i < 13; i++) {\n\t\t\tif(b1 == i) {\n\t\t\t\tfor(int j = 0; j < move[i].length; j++) {\n\t\t\t\t\tif(move[i][j] == b2) {\n\t\t\t\t\t\tswap(b2,b1,c);\n\t\t\t\t\t\tdfs(a+1,b2,b1,c);\n\t\t\t\t\t\tswap(b2,b1,c);\n\t\t\t\t\t}\n\t\t\t\t\telse {\n\t\t\t\t\t\tswap(move[i][j],b1,c);\n\t\t\t\t\t\tdfs(a+1,move[i][j],b2,c);\n\t\t\t\t\t\tswap(move[i][j],b1,c);\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t}\n\t\t\telse if(b2 == i) {\n\t\t\t\tfor(int j = 0; j < move[i].length; j++) {\n\t\t\t\t\tif(move[i][j] == b1) {\n\t\t\t\t\t\tswap(b2,b1,c);\n\t\t\t\t\t\tdfs(a+1,b2,b1,c);\n\t\t\t\t\t\tswap(b2,b1,c);\n\t\t\t\t\t}\n\t\t\t\t\telse {\n\t\t\t\t\t\tswap(move[i][j],b2,c);\n\t\t\t\t\t\tdfs(a+1,b1,move[i][j],c);\n\t\t\t\t\t\tswap(move[i][j],b2,c);\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t}\n\t\n\n}"
  },
  {
    "language": "Java",
    "code": "import java.util.ArrayDeque;\nimport java.util.Arrays;\nimport java.util.HashMap;\nimport java.util.Scanner;\n\npublic class Main {\n\tstatic HashMap<String,Integer> map = new HashMap<String,Integer>();\n\tstatic int[][] move = new int[][] {\n\t\t\t\t\t\t\t\t{2},\n\t\t\t\t\t   {2,5},{0,1,3,6},{2,7},\n\t\t\t   {5},{1,4,6,9},{2,5,7,10},{3,6,8,11},{7},\n\t\t\t          {5,10},{6,9,11,12},{7,10},\n\t\t\t          \t\t\t{10}\n\t\t\t          };\n \t\n\tpublic static void main(String[] args) {\n\t\tScanner sc = new Scanner(System.in);\n\t\tString first = \"0123456789AB0\";\n\t\tdfs(0,0,12,first);\n\t\tSystem.out.println(map.size());\n\t\tIN:while(true) {\n\t\t\tchar[] data = new char[13];\n\t\t\tfor(int i = 0; i < 13; i++) {\n\t\t\t\tString tmp = sc.next();\n\t\t\t\tif(tmp.equals(\"-1\")) break IN;\n\t\t\t\tif(tmp.equals(\"10\")) tmp = \"A\";\n\t\t\t\tif(tmp.equals(\"11\")) tmp = \"B\";\n\t\t\t\tdata[i] = tmp.charAt(0);\n\t\t\t}\n\t\t\tif(map.containsKey(String.valueOf(data))) {\n\t\t\t\tSystem.out.println(map.get(String.valueOf(data)));\n\t\t\t}\n\t\t\telse {\n\t\t\t\tSystem.out.println(\"NA\");\n\t\t\t}\n\t\t\t\n\t\t}\n\t}\n\tstatic String swap(int a, int b, String c) {\n\t\tchar[] x = c.toCharArray();\n\t\tchar tmp = x[a];\n\t\tx[a] = x[b];\n\t\tx[b] = tmp;\n\t\tString cx = String.valueOf(x);\n\t\treturn cx;\n\t}\n\tstatic void dfs(int a, int b1,int b2, String c) {\n\t\tif(a >= 20) return;\n\t\tif(map.containsKey(c)) {\n\t\t\tif(map.get(c) <= a) {\n\t\t\t\treturn;\n\t\t\t}\n\t\t\telse {\n\t\t\t\tmap.put(c, a);\n\t\t\t}\n\t\t}\n\t\telse {\n\t\t\tmap.put(c, a);\n\t\t}\n\t\tfor(int i = 0; i < 13; i++) {\n\t\t\tif(b1 == i) {\n\t\t\t\tfor(int j = 0; j < move[i].length; j++) {\n\t\t\t\t\tif(move[i][j] == b2) {\n\t\t\t\t\t\tc = swap(b2,b1,c);\n\t\t\t\t\t\tdfs(a,b2,b1,c);\n\t\t\t\t\t\tc = swap(b2,b1,c);\n\t\t\t\t\t}\n\t\t\t\t\telse {\n\t\t\t\t\t\tc = swap(move[i][j],b1,c);\n\t\t\t\t\t\tdfs(a+1,move[i][j],b2,c);\n\t\t\t\t\t\tc = swap(move[i][j],b1,c);\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t}\n\t\t\tif(b2 == i) {\n\t\t\t\tfor(int j = 0; j < move[i].length; j++) {\n\t\t\t\t\tif(move[i][j] == b1) {\n\t\t\t\t\t\tc = swap(b2,b1,c);\n\t\t\t\t\t\tdfs(a,b2,b1,c);\n\t\t\t\t\t\tc = swap(b2,b1,c);\n\t\t\t\t\t}\n\t\t\t\t\telse {\n\t\t\t\t\t\tc = swap(move[i][j],b2,c);\n\t\t\t\t\t\tdfs(a+1,b1,move[i][j],c);\n\t\t\t\t\t\tc = swap(move[i][j],b2,c);\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t}\n\t\n\n}"
  },
  {
    "language": "Java",
    "code": "import java.util.ArrayDeque;\nimport java.util.Arrays;\nimport java.util.HashMap;\nimport java.util.Scanner;\n\npublic class Main {\n\tstatic HashMap<String,Integer> map = new HashMap<String,Integer>();\n\tstatic HashMap<String,Integer> map2 = new HashMap<String,Integer>();\n\tstatic int min = 21;\n\tstatic int[][] move = new int[][] {\n\t\t\t\t\t\t\t\t{2},\n\t\t\t\t\t   {2,5},{0,1,3,6},{2,7},\n\t\t\t   {5},{1,4,6,9},{2,5,7,10},{3,6,8,11},{7},\n\t\t\t          {5,10},{6,9,11,12},{7,10},\n\t\t\t          \t\t\t{10}\n\t\t\t          };\n \t\n\tpublic static void main(String[] args) {\n\t\tScanner sc = new Scanner(System.in);\n\t\tString first = \"0123456789AB0\";\n\t\tBfsa(0,0,12,first);\n\t\tIN:while(true) {\n\t\t\tmin = 21;\n\t\t\tchar[] data = new char[13];\n\t\t\tint xa = -1;\n\t\t\tint xb = -1;\n\t\t\tfor(int i = 0; i < 13; i++) {\n\t\t\t\tString tmp = sc.next();\n\t\t\t\tif(tmp.equals(\"-1\")) break IN;\n\t\t\t\tif(tmp.equals(\"10\")) tmp = \"A\";\n\t\t\t\tif(tmp.equals(\"11\")) tmp = \"B\";\n\t\t\t\tif(tmp.equals(\"0\")) {\n\t\t\t\t\tif(xa == -1) xa = i;\n\t\t\t\t\telse xb = i;\n\t\t\t\t}\n\t\t\t\tdata[i] = tmp.charAt(0);\n\t\t\t}\n\t\t\tif(map.containsKey(String.valueOf(data))) {\n\t\t\t\tmin = map.get(String.valueOf(data));\n\t\t\t}\n\t\t\tBfsb(0,xa,xb,String.valueOf(data));\n\t\t\tif(min <= 20) {\n\t\t\t\tSystem.out.println(min);\n\t\t\t}\n\t\t\telse {\n\t\t\t\tSystem.out.println(\"NA\");\n\t\t\t}\n\t\t\t\n\t\t}\n\t}\n\tstatic ArrayDeque<Data> queue = new ArrayDeque<Data>();\n\t\n\tstatic void Bfsa(int a, int b, int c,String d) {\n\t\tqueue.clear();\n\t\tqueue.add(new Data(a,b,c,d));\n\t\twhile(!queue.isEmpty()) {\n\t\t\tData ax = queue.poll();\n\t\t\tbfsa(ax.a,ax.b1,ax.b2,ax.d);\n\t\t}\n\t}\n\t\n\tstatic void Bfsb(int a, int b, int c,String d) {\n\t\tmap2.clear();\n\t\tqueue.clear();\n\t\tqueue.add(new Data(a,b,c,d));\n\t\twhile(!queue.isEmpty()) {\n\t\t\tData ax = queue.poll();\n\t\t\tbfsb(ax.a,ax.b1,ax.b2,ax.d);\n\t\t}\n\t}\n\t\n\t\n\tstatic String swap(int a, int b, String c) {\n\t\tchar[] x = c.toCharArray();\n\t\tchar tmp = x[a];\n\t\tx[a] = x[b];\n\t\tx[b] = tmp;\n\t\tString cx = String.valueOf(x);\n\t\treturn cx;\n\t}\n\tstatic void bfsa(int a, int b1,int b2, String c) {\n\t\tif(a >= 10) return;\n\t\tif(!map.containsKey(c)) {\n\t\t\t\tmap.put(c, a);\n\t\t}\n\t\telse {\n\t\t\treturn;\n\t\t}\n\t\tfor(int i = 0; i < 13; i++) {\n\t\t\tif(b1 == i) {\n\t\t\t\tfor(int j = 0; j < move[i].length; j++) {\n\t\t\t\t\tif(move[i][j] == b2) {\n\t\t\t\t\t\tc = swap(b2,b1,c);\n\t\t\t\t\t\tqueue.add(new Data(a,b2,b1,c));\n\t\t\t\t\t\tc = swap(b2,b1,c);\n\t\t\t\t\t}\n\t\t\t\t\telse {\n\t\t\t\t\t\tc = swap(move[i][j],b1,c);\n\t\t\t\t\t\tqueue.add(new Data(a+1,move[i][j],b2,c));\n\t\t\t\t\t\tc = swap(move[i][j],b1,c);\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t}\n\t\t\tif(b2 == i) {\n\t\t\t\tfor(int j = 0; j < move[i].length; j++) {\n\t\t\t\t\tif(move[i][j] == b1) {\n\t\t\t\t\t\tc = swap(b2,b1,c);\n\t\t\t\t\t\tqueue.add(new Data(a,b2,b1,c));\n\t\t\t\t\t\tc = swap(b2,b1,c);\n\t\t\t\t\t}\n\t\t\t\t\telse {\n\t\t\t\t\t\tc = swap(move[i][j],b2,c);\n\t\t\t\t\t\tqueue.add(new Data(a+1,b1,move[i][j],c));\n\t\t\t\t\t\tc = swap(move[i][j],b2,c);\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t}\n\t\n\tstatic void bfsb(int a, int b1,int b2, String c) {\n\t\tif(a >= 10) return;\n\t\tif(!map2.containsKey(c)) {\n\t\t\tif(map.containsKey(c)) {\n\t\t\t\tmin = Math.min(min, a + map.get(c));\n\t\t\t}\n\t\t\tmap2.put(c, a);\n\t\t}\n\t\telse {\n\t\t\treturn;\n\t\t}\n\t\tfor(int i = 0; i < 13; i++) {\n\t\t\tif(b1 == i) {\n\t\t\t\tfor(int j = 0; j < move[i].length; j++) {\n\t\t\t\t\tif(move[i][j] == b2) {\n\t\t\t\t\t\tc = swap(b2,b1,c);\n\t\t\t\t\t\tqueue.add(new Data(a,b2,b1,c));\n\t\t\t\t\t\tc = swap(b2,b1,c);\n\t\t\t\t\t}\n\t\t\t\t\telse {\n\t\t\t\t\t\tc = swap(move[i][j],b1,c);\n\t\t\t\t\t\tqueue.add(new Data(a+1,move[i][j],b2,c));\n\t\t\t\t\t\tc = swap(move[i][j],b1,c);\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t}\n\t\t\tif(b2 == i) {\n\t\t\t\tfor(int j = 0; j < move[i].length; j++) {\n\t\t\t\t\tif(move[i][j] == b1) {\n\t\t\t\t\t\tc = swap(b2,b1,c);\n\t\t\t\t\t\tqueue.add(new Data(a,b2,b1,c));\n\t\t\t\t\t\tc = swap(b2,b1,c);\n\t\t\t\t\t}\n\t\t\t\t\telse {\n\t\t\t\t\t\tc = swap(move[i][j],b2,c);\n\t\t\t\t\t\tqueue.add(new Data(a+1,b1,move[i][j],c));\n\t\t\t\t\t\tc = swap(move[i][j],b2,c);\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t}\n\t\n\tstatic class Data {\n\t\tint a, b1, b2 ;\n\t\tString d;\n\t\tData(int a, int b, int c, String d) {\n\t\t\tthis.a = a;\n\t\t\tb1 = b;\n\t\t\tb2 = c;\n\t\t\tthis.d = d;\n\t\t}\n\t}\n\t\n\n}"
  },
  {
    "language": "Java",
    "code": "import java.util.*;\nimport java.util.regex.Pattern;\npublic class Main {\n\t\n\tArrayList<ArrayList<Integer>> swapList;\n\tint ans;\n\tHashMap<String,Integer> fromAns;\n\t\n\tclass C{\n\t\tint s;\n\t\tString now;\n\t\tpublic C(String now, int s){\n\t\t\tthis.now = now;\n\t\t\tthis.s = s;\n\t\t}\n\t}\n\t\n\tprivate void doit(){\n\t\tScanner sc = new Scanner(System.in);\n\t\t\n\t\t//swap pattern list\n\t\tswapList = createSwapList();\n\t\t\n\t\t//from ans\n\t\tString goal = \"0 1 2 3 4 5 6 7 8 9 10 11 0\";\n\t\tfromAns = new HashMap<String, Integer>();\n\t\tcreateStep(goal);\n\t\t\n\t\twhile(true){\n\t\t\t//input data\n\t\t\tint n = sc.nextInt();\n\t\t\tif(n == -1) break;\n\t\t\t//create start String\n\t\t\tStringBuilder sb  = new StringBuilder(\"\"+n);\n\t\t\tfor(int i=1; i <= 12; i++){\n\t\t\t\tsb.append(\" \");\n\t\t\t\tsb.append(sc.next());\n\t\t\t}\n\t\t\tString startS = sb.toString();\n\t\t\t\n\t\t\tif(fromAns.containsKey(startS)){\n\t\t\t\tSystem.out.println(fromAns.get(startS));\n\t\t\t\tcontinue;\n\t\t\t}\n\t\t\t\n\t\t\t//from start\n\t\t\tans = -1;\n\t\t\tcreateStep(startS);\n\t\t\t\n\t\t\t//comp and out\n\t\t\tif(ans != -1){\n\t\t\t\tSystem.out.println(ans);\n\t\t\t}\n\t\t\telse{\n\t\t\t\tSystem.out.println(\"NA\");\n\t\t\t}\n\t\t}\n\t}\n\t\n\tprivate int getInd0F(String [] s) {\n\t\tint len = s.length;\n\t\tfor(int i=0; i < len; i++){\n\t\t\tif(s[i].equals(\"0\")) return i;\n\t\t}\n\t\treturn -1;\n\t}\n\t\n\tprivate int getInd0L(String [] s) {\n\t\tint len = s.length;\n\t\tfor(int i=len-1; i >= 0; i--){\n\t\t\tif(s[i].equals(\"0\")) return i;\n\t\t}\n\t\treturn -1;\n\t}\n\t\n\tprivate String createS(String [] s){\n\t\tStringBuilder sb = new StringBuilder();\n\t\tfor(int i=0; i < s.length-1; i++){\n\t\t\tsb.append(s[i]);\n\t\t\tsb.append(\" \");\n\t\t}\n\t\tsb.append(s[s.length-1]);\n\t\treturn sb.toString();\n\t}\n\t\n\tprivate void createStep(String start){\n\t\t//init\n\t\tLinkedList<C> open = new LinkedList<C>();\n\t\topen.add(new C(start, 0));\n\t\tHashMap<String , Integer> close = new HashMap<String, Integer>();\n\t\tif(fromAns.containsKey(start)){\n\t\t\tclose.put(start, fromAns.get(start));\n\t\t}\n\t\telse{\n\t\t\tclose.put(start, 0);\n\t\t}\n\t\t\n\t\t//start\n\t\twhile(! open.isEmpty()){\n\t\t\tC now = open.removeFirst();\n\t\t\t\n\t\t\t//find a zero ind\n\t\t\tString [] nowParse = now.now.split(\" \");\n\t\t\tint ind01 = getInd0F(nowParse);\n\t\t\tint ind02 = getInd0L(nowParse);\n\t\t\tint [] ind0list = {ind01, ind02};\n\t\t\t\n\t\t\t//swap pattern times\n\t\t\tfor(int i = 0; i < ind0list.length;i++){\n\t\t\t\tint nowind = ind0list[i];\n\t\t\t\tfor(int j=0; j < swapList.get(nowind).size(); j++){\n\t\t\t\t\tint swapind = swapList.get(nowind).get(j);\n\t\t\t\t\tString [] work = now.now.split(\" \");\n\t\t\t\t\t\n\t\t\t\t\t//swap\n\t\t\t\t\tString temp = work[nowind];\n\t\t\t\t\twork[nowind] = work[swapind];\n\t\t\t\t\twork[swapind] = temp;\n\t\t\t\t\t\n\t\t\t\t\t//create new String \n\t\t\t\t\tString newS = createS(work);\n\t\t\t\t\t\n\t\t\t\t\t//close contains\n\t\t\t\t\tif(close.containsKey(newS)) continue;\n\t\t\t\t\t\n\t\t\t\t\t//find a goal\n\t\t\t\t\tint nextstep = now.s + 1;\n\t\t\t\t\tif(fromAns.containsKey(newS)){\n\t\t\t\t\t\tans = nextstep + fromAns.get(newS);\n\t\t\t\t\t\treturn ;\n\t\t\t\t\t}\n\t\t\t\t\t\n\t\t\t\t\t//open.add\n\t\t\t\t\tif(now.s != 10){\n\t\t\t\t\t\topen.add(new C(newS, nextstep));\n\t\t\t\t\t}\n\t\t\t\t\t\n\t\t\t\t\t//close.put\n\t\t\t\t\tclose.put(newS, nextstep);\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t\tfromAns = close;\n\t}\n\n\tprivate ArrayList<ArrayList<Integer>> createSwapList() {\n\t\tArrayList<ArrayList<Integer>> res = new ArrayList<ArrayList<Integer>>();\n\t\tfor(int i=0; i <= 12; i++){\n\t\t\tres.add(new ArrayList<Integer>());\n\t\t\t//bottom\n\t\t\tif(! (i == 4 || i == 9 || i == 12 || i == 11 || i == 8 || i == 10)){\n\t\t\t\tres.get(i).add(i+4);\n\t\t\t}\n\t\t\t//right\n\t\t\tif(! (i == 0 || i == 3 || i == 8 || i == 11 || i == 12)){\n\t\t\t\tres.get(i).add(i+1);\n\t\t\t}\n\t\t\t//left\n\t\t\tif(! (i == 0 || i == 1 || i == 4 || i == 9 || i == 12)){\n\t\t\t\tres.get(i).add(i-1);\n\t\t\t}\n\t\t\t//top\n\t\t\tif(! (i == 4 || i == 1 || i == 0 || i == 3 || i == 8 || i == 2)){\n\t\t\t\tres.get(i).add(i -4);\n\t\t\t}\n\t\t}\n\t\tres.get(2).add(0);\n\t\tres.get(10).add(12);\n\t\t\n\t\treturn res;\n\t}\n\n\tpublic static void main(String[] args) {\n\t\tMain obj = new Main();\n\t\tobj.doit();\n\t}\n}"
  },
  {
    "language": "Java",
    "code": "\nimport java.util.*;\npublic class Main {\n\tint [][] start;\n\tfinal int [] xdir = {0,1,0,-1};\n\tfinal int [] ydir = {1,0,-1,0};\n\n\tpublic class C {\n\t\tint deep;\n\t\tStringBuilder data;\n\t\tpublic C(int deep, String data) {\n\t\t\tthis.deep = deep;\n\t\t\tthis.data = new StringBuilder(data);\n\t\t}\n\t}\n\n\tprivate int[] getIndex(int ind){\n\t\tfor(int i=0; i < 7; i++){\n\t\t\tfor(int j=0; j < 7; j++){\n\t\t\t\tif(start[i][j] == ind){\n\t\t\t\t\tint [] ans = {j,i};\n\t\t\t\t\treturn ans;\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t\treturn null;\n\t}\n\n\tpublic void doIt(){\n\t\tScanner sc = new Scanner(System.in);\n\t\tLinkedList<C> open = new LinkedList<C>();\n\t\tHashMap<String,Integer> close = new HashMap<String, Integer>();\n\t\tstart = new int[7][7];\n\t\tfor(int i=0; i < 7; i++){\n\t\t\tArrays.fill(start[i], -1);\n\t\t}\n\t\tstart[1][3] = 0;\n\t\tstart[2][2] = 1;\n\t\tstart[2][3] = 2;\n\t\tstart[2][4] = 3;\n\t\tstart[3][1] = 4;\n\t\tstart[3][2] = 5;\n\t\tstart[3][3] = 6;\n\t\tstart[3][4] = 7;\n\t\tstart[3][5] = 8;\n\t\tstart[4][2] = 9;\n\t\tstart[4][3] = 10;\n\t\tstart[4][4] = 11;\n\t\tstart[5][3] = 12;\n\t\topen.addLast(new C(0,\"0123456789ab0\"));\n\t\tclose.put(\"0123456789ab0\", 0);\n\n\t\twhile(! open.isEmpty()){\n\t\t\tC pat = open.remove();\n\t\t\tStringBuilder patStr = pat.data;\n\t\t\tint patDeep = pat.deep;\n\t\t\tint lastInd = 0;\n\t\t\tif(patDeep >= 10){\n\t\t\t\topen.clear();\n\t\t\t\tbreak;\n\t\t\t}\n\n\t\t\tfor(int i=0; i < 2; i++){\n\t\t\t\tint ind = patStr.indexOf(\"0\", lastInd);\n\t\t\t\tint [] result = getIndex(ind);\n\t\t\t\tint x = result[0];\n\t\t\t\tint y = result[1];\n\n\t\t\t\tfor(int j=0; j < 4; j++){\n\t\t\t\t\tint patX = x + xdir[j];\n\t\t\t\t\tint patY = y + ydir[j];\n\t\t\t\t\tif(start[patY][patX] >= 0){\n\t\t\t\t\t\tStringBuilder newStr = new StringBuilder(patStr.toString());\n\t\t\t\t\t\tchar change = newStr.charAt(start[patY][patX]);\n\t\t\t\t\t\tnewStr.setCharAt(ind, change);\n\t\t\t\t\t\tnewStr.setCharAt(start[patY][patX], '0');\n\t\t\t\t\t\tString temp = newStr.toString();\n\n\t\t\t\t\t\tif((! close.containsKey(temp))){\n\t\t\t\t\t\t\topen.addLast(new C(patDeep + 1, temp));\n\t\t\t\t\t\t\tclose.put(temp, patDeep+1);\n\t\t\t\t\t\t}\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t\tlastInd = ind + 1;\n\t\t\t}\n\t\t}\n\n\t\twhile(true){\n\t\t\tint n = sc.nextInt();\n\t\t\tif(n == -1){\n\t\t\t\tbreak;\n\t\t\t}\n\t\t\tStringBuilder input = new StringBuilder();\n\t\t\tif(n == 10){\n\t\t\t\tinput.append('a');\n\t\t\t}\n\t\t\telse if(n == 11){\n\t\t\t\tinput.append('b');\n\t\t\t}\n\t\t\telse{\n\t\t\t\tinput.append(\"\" + n);\n\t\t\t}\n\n\t\t\tfor(int i=0; i < 12; i++){\n\t\t\t\tn = sc.nextInt();\n\t\t\t\tif(n == 10){\n\t\t\t\t\tinput.append('a');\n\t\t\t\t}\n\t\t\t\telse if(n == 11){\n\t\t\t\t\tinput.append('b');\n\t\t\t\t}\n\t\t\t\telse{\n\t\t\t\t\tinput.append(\"\" + n);\n\t\t\t\t}\n\t\t\t}\n\t\t\tString inputStr = input.toString();\n\t\t\tif(close.containsKey(inputStr)){\n\t\t\t\tSystem.out.println(close.get(inputStr));\n\t\t\t}\n\t\t\telse{\n\t\t\t\topen.addLast(new C(0,inputStr));\n\t\t\t\tHashMap<String,Integer> anotherclose = new HashMap<String, Integer>();\n\t\t\t\tanotherclose.put(inputStr, 0);\n\t\t\t\twhile(! open.isEmpty()){\n\t\t\t\t\tC pat = open.remove();\n\t\t\t\t\tStringBuilder patStr = pat.data;\n\t\t\t\t\tint patDeep = pat.deep;\n\t\t\t\t\tint lastInd = 0;\n\n\t\t\t\t\tif((close.containsKey(patStr.toString()))){\n\t\t\t\t\t\tSystem.out.println(patDeep + close.get(patStr.toString()));\n\t\t\t\t\t\tbreak;\n\t\t\t\t\t}\n\n\t\t\t\t\tif(patDeep >= 10){\n\t\t\t\t\t\tSystem.out.println(\"NA\");\n\t\t\t\t\t\tbreak;\n\t\t\t\t\t}\n\n\t\t\t\t\tfor(int i=0; i < 2; i++){\n\t\t\t\t\t\tint ind = patStr.indexOf(\"0\", lastInd);\n\t\t\t\t\t\tint [] result = getIndex(ind);\n\t\t\t\t\t\tint x = result[0];\n\t\t\t\t\t\tint y = result[1];\n\n\t\t\t\t\t\tfor(int j=0; j < 4; j++){\n\t\t\t\t\t\t\tint patX = x + xdir[j];\n\t\t\t\t\t\t\tint patY = y + ydir[j];\n\t\t\t\t\t\t\tif(start[patY][patX] >= 0){\n\t\t\t\t\t\t\t\tStringBuilder newStr = new StringBuilder(patStr.toString());\n\t\t\t\t\t\t\t\tchar change = newStr.charAt(start[patY][patX]);\n\t\t\t\t\t\t\t\tnewStr.setCharAt(ind, change);\n\t\t\t\t\t\t\t\tnewStr.setCharAt(start[patY][patX], '0');\n\t\t\t\t\t\t\t\tString temp = newStr.toString();\n\n\t\t\t\t\t\t\t\tif((! anotherclose.containsKey(temp))){\n\t\t\t\t\t\t\t\t\topen.addLast(new C(patDeep + 1, temp));\n\t\t\t\t\t\t\t\t\tanotherclose.put(temp, patDeep+1);\n\t\t\t\t\t\t\t\t}\n\t\t\t\t\t\t\t}\n\t\t\t\t\t\t}\n\t\t\t\t\t\tlastInd = ind + 1;\n\t\t\t\t\t}\n\t\t\t\t}\n\n\t\t\t}\n\t\t}\n\n\t}\n\tpublic static void main(String[] args) {\n\t\tMain obj = new Main();\n\t\tobj.doIt();\n\t}\n}"
  },
  {
    "language": "Java",
    "code": "import java.util.ArrayDeque;\nimport java.util.Arrays;\nimport java.util.HashMap;\nimport java.util.Scanner;\n\npublic class Main {\n\tstatic HashMap<String,Integer> map = new HashMap<String,Integer>();\n\tstatic int[][] move = new int[][] {\n\t\t\t\t\t\t\t\t{2},\n\t\t\t\t\t   {2,5},{0,1,3,6},{2,7},\n\t\t\t   {5},{1,4,6,9},{2,5,7,10},{3,6,8,11},{7},\n\t\t\t          {5,10},{6,9,11,12},{7,10},\n\t\t\t          \t\t\t{10}\n\t\t\t          };\n \t\n\tpublic static void main(String[] args) {\n\t\tScanner sc = new Scanner(System.in);\n\t\tchar[] first = new char[] { '0','1','2','3','4','5','6','7','8','9','A','B','0'};\n\t\t\n\t\tdfs(0,0,12,first);\n\t\tSystem.out.println(map.size());\n\t\tIN:while(true) {\n\t\t\tchar[] data = new char[13];\n\t\t\tfor(int i = 0; i < 13; i++) {\n\t\t\t\tString tmp = sc.next();\n\t\t\t\tif(tmp.equals(\"-1\")) break IN;\n\t\t\t\tif(tmp.equals(\"10\")) tmp = \"A\";\n\t\t\t\tif(tmp.equals(\"11\")) tmp = \"B\";\n\t\t\t\tdata[i] = tmp.charAt(0);\n\t\t\t}\n\t\t\tif(map.containsKey(String.valueOf(data))) {\n\t\t\t\tSystem.out.println(map.get(String.valueOf(data)));\n\t\t\t}\n\t\t\telse {\n\t\t\t\tSystem.out.println(\"NA\");\n\t\t\t}\n\t\t\t\n\t\t}\n\t}\n\tstatic void swap(int a, int b, char[] c) {\n\t\tchar tmp = c[a];\n\t\tc[a] = c[b];\n\t\tc[b] = tmp;\n\t}\n\tstatic void dfs(int a, int b1,int b2, char[] c) {\n\t\tStringBuilder tmp = new StringBuilder(String.valueOf(c));\n\t\tif(a >= 20) return;\n\t\tString s = tmp.toString();\n\t\tif(map.containsKey(s)) {\n\t\t\tif(map.get(s) <= a) {\n\t\t\t\treturn;\n\t\t\t}\n\t\t\telse {\n\t\t\t\tmap.put(s, a);\n\t\t\t}\n\t\t}\n\t\telse {\n\t\t\tmap.put(s, a);\n\t\t}\n\t\tfor(int i = 0; i < 13; i++) {\n\t\t\tif(b1 == i) {\n\t\t\t\tfor(int j = 0; j < move[i].length; j++) {\n\t\t\t\t\tif(move[i][j] == b2) {\n\t\t\t\t\t\tswap(b2,b1,c);\n\t\t\t\t\t\tdfs(a,b2,b1,c);\n\t\t\t\t\t\tswap(b2,b1,c);\n\t\t\t\t\t}\n\t\t\t\t\telse {\n\t\t\t\t\t\tswap(move[i][j],b1,c);\n\t\t\t\t\t\tdfs(a+1,move[i][j],b2,c);\n\t\t\t\t\t\tswap(move[i][j],b1,c);\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t}\n\t\t\tif(b2 == i) {\n\t\t\t\tfor(int j = 0; j < move[i].length; j++) {\n\t\t\t\t\tif(move[i][j] == b1) {\n\t\t\t\t\t\tswap(b2,b1,c);\n\t\t\t\t\t\tdfs(a,b2,b1,c);\n\t\t\t\t\t\tswap(b2,b1,c);\n\t\t\t\t\t}\n\t\t\t\t\telse {\n\t\t\t\t\t\tswap(move[i][j],b2,c);\n\t\t\t\t\t\tdfs(a+1,b1,move[i][j],c);\n\t\t\t\t\t\tswap(move[i][j],b2,c);\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t}\n\t\n\n}"
  },
  {
    "language": "Java",
    "code": "import java.util.*;\nimport java.util.regex.Pattern;\npublic class Main {\n\t\n\tArrayList<ArrayList<Integer>> swapList;\n\tint ans;\n\tclass C{\n\t\tint s;\n\t\tString now;\n\t\tpublic C(String now, int s){\n\t\t\tthis.now = now;\n\t\t\tthis.s = s;\n\t\t}\n\t}\n\t\n\tprivate void doit(){\n\t\tScanner sc = new Scanner(System.in);\n\t\t\n\t\t//swap pattern list\n\t\tswapList = createSwapList();\n\t\t\n\t\t//from ans\n\t\tString goal = \"0 1 2 3 4 5 6 7 8 9 10 11 0\";\n\t\tHashMap<String, Integer> fromAns = createStep(goal,new HashMap<String,Integer>());\n\t\t\n\t\t\n\t\twhile(true){\n\t\t\t//input data\n\t\t\tint n = sc.nextInt();\n\t\t\tif(n == -1) break;\n\t\t\t//create start String\n\t\t\tStringBuilder sb  = new StringBuilder(\"\"+n);\n\t\t\tfor(int i=1; i <= 12; i++){\n\t\t\t\tsb.append(\" \" + sc.next());\n\t\t\t}\n\t\t\tString startS = sb.toString();\n\t\t\t\n\t\t\tif(fromAns.containsKey(startS)){\n\t\t\t\tSystem.out.println(fromAns.get(startS));\n\t\t\t\tcontinue;\n\t\t\t}\n\t\t\t\n\t\t\t//from start\n\t\t\tans = -1;\n\t\t\tHashMap<String, Integer> fromStart = createStep(startS,fromAns);\n\t\t\t\n\t\t\t//comp and out\n\t\t\tif(ans != -1){\n\t\t\t\tSystem.out.println(ans);\n\t\t\t}\n\t\t\telse{\n\t\t\t\tSystem.out.println(\"NA\");\n\t\t\t}\n\t\t}\n\t}\n\t\n\tprivate int getInd0F(String [] s) {\n\t\tint len = s.length;\n\t\tfor(int i=0; i < len; i++){\n\t\t\tif(s[i].equals(\"0\")) return i;\n\t\t}\n\t\treturn -1;\n\t}\n\t\n\tprivate int getInd0L(String [] s) {\n\t\tint len = s.length;\n\t\tfor(int i=len-1; i >= 0; i--){\n\t\t\tif(s[i].equals(\"0\")) return i;\n\t\t}\n\t\treturn -1;\n\t}\n\t\n\tprivate String createS(String [] s){\n\t\tStringBuilder sb = new StringBuilder();\n\t\tfor(int i=0; i < s.length-1; i++){\n\t\t\tsb.append(s[i] + \" \");\n\t\t}\n\t\tsb.append(s[s.length-1]);\n\t\treturn sb.toString();\n\t}\n\t\n\tprivate HashMap<String,Integer> createStep(String start, HashMap<String, Integer> another){\n\t\t//init\n\t\tLinkedList<C> open = new LinkedList<C>();\n\t\topen.add(new C(start, 0));\n\t\tHashMap<String , Integer> close = new HashMap<String, Integer>();\n\t\tif(another.containsKey(start)){\n\t\t\tclose.put(start, another.get(start));\n\t\t}\n\t\telse{\n\t\t\tclose.put(start, 0);\n\t\t}\n\t\t\n\t\t//start\n\t\twhile(! open.isEmpty()){\n\t\t\tC now = open.removeFirst();\n\t\t\t\n\t\t\t//find a zero ind\n\t\t\tString [] nowParse = now.now.split(\" \");\n\t\t\tint ind01 = getInd0F(nowParse);\n\t\t\tint ind02 = getInd0L(nowParse);\n\t\t\tint [] ind0list = {ind01, ind02};\n\t\t\t\n\t\t\t//swap pattern times\n\t\t\tfor(int i = 0; i < ind0list.length;i++){\n\t\t\t\tint nowind = ind0list[i];\n\t\t\t\tfor(int j=0; j < swapList.get(nowind).size(); j++){\n\t\t\t\t\tint swapind = swapList.get(nowind).get(j);\n\t\t\t\t\tString [] work = now.now.split(\" \");\n\t\t\t\t\t\n\t\t\t\t\t//swap\n\t\t\t\t\tString temp = work[nowind];\n\t\t\t\t\twork[nowind] = work[swapind];\n\t\t\t\t\twork[swapind] = temp;\n\t\t\t\t\t\n\t\t\t\t\t//create new String \n\t\t\t\t\tString newS = createS(work);\n\t\t\t\t\t\n\t\t\t\t\t//close contains\n\t\t\t\t\tif(close.containsKey(newS)) continue;\n\t\t\t\t\t\n\t\t\t\t\t//find a goal\n\t\t\t\t\tint nextstep = now.s + 1;\n\t\t\t\t\tif(another.containsKey(newS)){\n\t\t\t\t\t\tans = nextstep + another.get(newS);\n\t\t\t\t\t\treturn close;\n\t\t\t\t\t}\n\t\t\t\t\t\n\t\t\t\t\t//open.add\n\t\t\t\t\tif(now.s != 10){\n\t\t\t\t\t\topen.add(new C(newS, nextstep));\n\t\t\t\t\t}\n\t\t\t\t\t\n\t\t\t\t\t//close.put\n\t\t\t\t\tclose.put(newS, nextstep);\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t\treturn close;\n\t}\n\n\tprivate ArrayList<ArrayList<Integer>> createSwapList() {\n\t\tArrayList<ArrayList<Integer>> res = new ArrayList<ArrayList<Integer>>();\n\t\tfor(int i=0; i <= 12; i++){\n\t\t\tres.add(new ArrayList<Integer>());\n\t\t\t//bottom\n\t\t\tif(! (i == 4 || i == 9 || i == 12 || i == 11 || i == 8 || i == 10)){\n\t\t\t\tres.get(i).add(i+4);\n\t\t\t}\n\t\t\t//right\n\t\t\tif(! (i == 0 || i == 3 || i == 8 || i == 11 || i == 12)){\n\t\t\t\tres.get(i).add(i+1);\n\t\t\t}\n\t\t\t//left\n\t\t\tif(! (i == 0 || i == 1 || i == 4 || i == 9 || i == 12)){\n\t\t\t\tres.get(i).add(i-1);\n\t\t\t}\n\t\t\t//top\n\t\t\tif(! (i == 4 || i == 1 || i == 0 || i == 3 || i == 8 || i == 2)){\n\t\t\t\tres.get(i).add(i -4);\n\t\t\t}\n\t\t}\n\t\tres.get(2).add(0);\n\t\tres.get(10).add(12);\n\t\t\n\t\treturn res;\n\t}\n\n\tpublic static void main(String[] args) {\n\t\tMain obj = new Main();\n\t\tobj.doit();\n\t}\n}"
  },
  {
    "language": "Java",
    "code": "\nimport java.util.ArrayDeque;\nimport java.util.Deque;\nimport java.util.HashMap;\nimport java.util.HashSet;\nimport java.util.Map;\nimport java.util.Scanner;\nimport java.util.Set;\n\npublic class Main {\n\n\tpublic static void main(String[] args) {\n\t\tnew Main().run();\n\t}\n\n\tprivate void run() {\n\t\tScanner scanner = new Scanner(System.in);\n\t\tint[][] map = { { 2 }, { 2, 5 }, { 0, 1, 3, 6 }, { 2, 7 }, { 5 },\n\t\t\t\t{ 1, 4, 6, 9 }, { 2, 5, 7, 10 }, { 3, 6, 8, 11 }, { 7 },\n\t\t\t\t{ 5, 10 }, { 6, 9, 11, 12 }, { 7, 10 }, { 10 } };\n\t\tString reslt = \"0ABCDEFGHIJK0\";\n\t\tMap<String, Integer> memo = new HashMap<String, Integer>();\n\t\tmemo.put(reslt, 0);\n\t\tint step = 1;\n\t\tDeque<String> deque = new ArrayDeque<String>();\n\t\tdeque.offer(reslt);\n\t\twhile (step <= 10) {\n\t\t\tint size = deque.size();\n\t\t\twhile (size-- > 0) {\n\t\t\t\tchar[] chs = deque.pop().toCharArray();\n\t\t\t\tfor (int i = 0; i < 13; i++) {\n\t\t\t\t\tif (chs[i] == '0') {\n\t\t\t\t\t\tfor (int j : map[i]) {\n\t\t\t\t\t\t\tchs[i] = chs[j];\n\t\t\t\t\t\t\tchs[j] = '0';\n\t\t\t\t\t\t\tString tmp = String.valueOf(chs);\n\t\t\t\t\t\t\tif (!memo.containsKey(tmp)) {\n\t\t\t\t\t\t\t\tmemo.put(tmp, step);\n\t\t\t\t\t\t\t\tdeque.offer(tmp);\n\t\t\t\t\t\t\t}\n\t\t\t\t\t\t\tchs[j] = chs[i];\n\t\t\t\t\t\t\tchs[i] = '0';\n\t\t\t\t\t\t}\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t}\n\t\t\tstep++;\n\t\t}\n\t\twhile (true) {\n\t\t\tint n = scanner.nextInt();\n\t\t\tif (n == -1)\n\t\t\t\tbreak;\n\t\t\tchar[] cs = new char[13];\n\t\t\tcs[0] = n == 0 ? '0' : (char) (n - 1 + 'A');\n\t\t\tfor (int i = 1; i < 13; i++) {\n\t\t\t\tint c = scanner.nextInt();\n\t\t\t\tcs[i] = c == 0 ? '0' : (char) (c - 1 + 'A');\n\t\t\t}\n\t\t\tstep = 0;\n\t\t\tdeque.clear();\n\t\t\tString s = String.valueOf(cs);\n\t\t\tdeque.offer(s);\n\t\t\tSet<String> set = new HashSet<String>();\n\t\t\tset.add(s);\n\t\t\tString ret = \"NA\";\n\t\t\tloop: while (step <= 10) {\n\t\t\t\tint size = deque.size();\n\t\t\t\twhile (size-- > 0) {\n\t\t\t\t\tString str = deque.pop();\n\t\t\t\t\tif (memo.containsKey(str)) {\n\t\t\t\t\t\tret = String.valueOf(memo.get(str) + step);\n\t\t\t\t\t\tbreak loop;\n\t\t\t\t\t}\n\t\t\t\t\tchar[] chs = str.toCharArray();\n\t\t\t\t\tfor (int i = 0; i < 13; i++) {\n\t\t\t\t\t\tif (chs[i] == '0') {\n\t\t\t\t\t\t\tfor (int j : map[i]) {\n\t\t\t\t\t\t\t\tchs[i] = chs[j];\n\t\t\t\t\t\t\t\tchs[j] = '0';\n\t\t\t\t\t\t\t\tString tmp = String.valueOf(chs);\n\t\t\t\t\t\t\t\tif (!set.contains(tmp)) {\n\t\t\t\t\t\t\t\t\tset.add(tmp);\n\t\t\t\t\t\t\t\t\tdeque.offer(tmp);\n\t\t\t\t\t\t\t\t}\n\t\t\t\t\t\t\t\tchs[j] = chs[i];\n\t\t\t\t\t\t\t\tchs[i] = '0';\n\t\t\t\t\t\t\t}\n\t\t\t\t\t\t}\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t\tstep++;\n\t\t\t}\n\t\t\tSystem.out.println(ret);\n\t\t}\n\n\t}\n}"
  },
  {
    "language": "Java",
    "code": "\nimport java.util.ArrayDeque;\nimport java.util.Deque;\nimport java.util.HashMap;\nimport java.util.HashSet;\nimport java.util.Map;\nimport java.util.Scanner;\nimport java.util.Set;\n\npublic class Main {\n\n\tpublic static void main(String[] args) {\n\t\tnew Main().run();\n\t}\n\n\tprivate void run() {\n\t\tScanner scanner = new Scanner(System.in);\n\t\tint[][] adj = { { 2 }, { 2, 5 }, { 0, 1, 3, 6 }, { 2, 7 }, { 5 },\n\t\t\t\t{ 1, 4, 6, 9 }, { 2, 5, 7, 10 }, { 3, 6, 8, 11 }, { 7 },\n\t\t\t\t{ 5, 10 }, { 6, 9, 11, 12 }, { 7, 10 }, { 10 } };\n\t\tString g = \"0ABCDEFGHIJK0\";\n\t\tMap<String, Integer> m = new HashMap<String, Integer>();\n\t\tDeque<String> deque = new ArrayDeque<String>();\n\t\tint step = 1;\n\t\tdeque.offer(g);\n\t\tm.put(g, 0);\n\t\twhile (!deque.isEmpty() && step < 11) {\n\t\t\tint size = deque.size();\n\t\t\tfor (int k = 0; k < size; k++) {\n\t\t\t\tString s = deque.pop();\n\t\t\t\tchar[] c = s.toCharArray();\n\t\t\t\tfor (int i = 0; i < 13; i++) {\n\t\t\t\t\tif (c[i] == '0') {\n\t\t\t\t\t\tfor (int j = 0; j < adj[i].length; j++) {\n\t\t\t\t\t\t\tc[i] = c[adj[i][j]];\n\t\t\t\t\t\t\tc[adj[i][j]] = '0';\n\t\t\t\t\t\t\tString n = String.valueOf(c);\n\t\t\t\t\t\t\tif (!m.containsKey(n)) {\n\t\t\t\t\t\t\t\tm.put(n, step);\n\t\t\t\t\t\t\t\tdeque.offer(n);\n\t\t\t\t\t\t\t}\n\t\t\t\t\t\t\tc[adj[i][j]] = c[i];\n\t\t\t\t\t\t\tc[i] = '0';\n\t\t\t\t\t\t}\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t}\n\t\t\tstep++;\n\t\t}\n\t\twhile (true) {\n\t\t\tint p = scanner.nextInt();\n\t\t\tif (p == -1)\n\t\t\t\tbreak;\n\t\t\tchar[] cc = new char[13];\n\t\t\tcc[0] = p == 0 ? '0' : (char) (p - 1 + 'A');\n\t\t\tfor (int i = 1; i < 13; i++) {\n\t\t\t\tp = scanner.nextInt();\n\t\t\t\tcc[i] = p == 0 ? '0' : (char) (p - 1 + 'A');\n\t\t\t}\n\t\t\tString st = String.valueOf(cc);\n\t\t\tSet<String> set = new HashSet<String>();\n\t\t\tdeque.clear();\n\t\t\tdeque.offer(st);\n\t\t\tstep = 0;\n\t\t\tboolean flag = false;\n\t\t\tString ans = \"\";\n\t\t\tloop: while (!deque.isEmpty() && step < 11) {\n\t\t\t\tint size = deque.size();\n\t\t\t\tfor (int w = 0; w < size; w++) {\n\t\t\t\t\tString s = deque.pop();\n\t\t\t\t\tif (m.containsKey(s)) {\n\t\t\t\t\t\tflag = true;\n\t\t\t\t\t\tans = s;\n\t\t\t\t\t\tbreak loop;\n\t\t\t\t\t}\n\t\t\t\t\tchar[] cs = s.toCharArray();\n\t\t\t\t\tfor (int i = 0; i < 13; i++) {\n\t\t\t\t\t\tif (cs[i] == '0') {\n\t\t\t\t\t\t\tfor (int j = 0; j < adj[i].length; j++) {\n\t\t\t\t\t\t\t\tcs[i] = cs[adj[i][j]];\n\t\t\t\t\t\t\t\tcs[adj[i][j]] = '0';\n\t\t\t\t\t\t\t\tString news = String.valueOf(cs);\n\t\t\t\t\t\t\t\tif (!set.contains(news)) {\n\t\t\t\t\t\t\t\t\tset.add(news);\n\t\t\t\t\t\t\t\t\tdeque.offer(news);\n\t\t\t\t\t\t\t\t}\n\t\t\t\t\t\t\t\tcs[adj[i][j]] = cs[i];\n\t\t\t\t\t\t\t\tcs[i] = '0';\n\t\t\t\t\t\t\t}\n\t\t\t\t\t\t}\n\t\t\t\t\t}\n\n\t\t\t\t}\n\t\t\t\tstep++;\n\t\t\t}\n\t\t\tSystem.out.println(flag ? m.get(ans) : \"NA\");\n\n\t\t}\n\t}\n}"
  },
  {
    "language": "Java",
    "code": "import java.util.*;\npublic class Main {\n\tint [][] start;\n\tfinal int [] xdir = {0,1,0,-1};\n\tfinal int [] ydir = {1,0,-1,0};\n\n\tpublic class C {\n\t\tint deep;\n\t\tStringBuilder data;\n\t\tpublic C(int deep, String data) {\n\t\t\tthis.deep = deep;\n\t\t\tthis.data = new StringBuilder(data);\n\t\t}\n\t}\n\n\tprivate int[] getIndex(int ind){\n\t\tfor(int i=0; i < 7; i++){\n\t\t\tfor(int j=0; j < 7; j++){\n\t\t\t\tif(start[i][j] == ind){\n\t\t\t\t\tint [] ans = {j,i};\n\t\t\t\t\treturn ans;\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t\treturn null;\n\t}\n\n\tpublic void doIt(){\n\t\tScanner sc = new Scanner(System.in);\n\t\tLinkedList<C> open = new LinkedList<C>();\n\t\tHashMap<String,Integer> close = new HashMap<String, Integer>();\n\t\tstart = new int[7][7];\n\t\tfor(int i=0; i < 7; i++){\n\t\t\tArrays.fill(start[i], -1);\n\t\t}\n\t\tstart[1][3] = 0;\n\t\tstart[2][2] = 1;\n\t\tstart[2][3] = 2;\n\t\tstart[2][4] = 3;\n\t\tstart[3][1] = 4;\n\t\tstart[3][2] = 5;\n\t\tstart[3][3] = 6;\n\t\tstart[3][4] = 7;\n\t\tstart[3][5] = 8;\n\t\tstart[4][2] = 9;\n\t\tstart[4][3] = 10;\n\t\tstart[4][4] = 11;\n\t\tstart[5][3] = 12;\n\t\topen.addLast(new C(0,\"0123456789ab0\"));\n\t\tclose.put(\"0123456789ab0\", 0);\n\n\t\twhile(! open.isEmpty()){\n\t\t\tC pat = open.remove();\n\t\t\tStringBuilder patStr = pat.data;\n\t\t\tint patDeep = pat.deep;\n\t\t\tint lastInd = 0;\n\t\t\tif(patDeep >= 10){\n\t\t\t\tbreak;\n\t\t\t}\n\n\t\t\tfor(int i=0; i < 2; i++){\n\t\t\t\tint ind = patStr.indexOf(\"0\", lastInd);\n\t\t\t\tint [] result = getIndex(ind);\n\t\t\t\tint x = result[0];\n\t\t\t\tint y = result[1];\n\n\t\t\t\tfor(int j=0; j < 4; j++){\n\t\t\t\t\tint patX = x + xdir[j];\n\t\t\t\t\tint patY = y + ydir[j];\n\t\t\t\t\tif(start[patY][patX] >= 0){\n\t\t\t\t\t\tStringBuilder newStr = new StringBuilder(patStr.toString());\n\t\t\t\t\t\tchar change = newStr.charAt(start[patY][patX]);\n\t\t\t\t\t\tnewStr.setCharAt(ind, change);\n\t\t\t\t\t\tnewStr.setCharAt(start[patY][patX], '0');\n\t\t\t\t\t\tString temp = newStr.toString();\n\n\t\t\t\t\t\tif((! close.containsKey(temp))){\n\t\t\t\t\t\t\topen.addLast(new C(patDeep + 1, temp));\n\t\t\t\t\t\t\tclose.put(temp, patDeep+1);\n\t\t\t\t\t\t}\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t\tlastInd = ind + 1;\n\t\t\t}\n\t\t}\n\n\t\twhile(true){\n\t\t\tint n = sc.nextInt();\n\t\t\tif(n == -1){\n\t\t\t\tbreak;\n\t\t\t}\n\t\t\tStringBuilder input = new StringBuilder();\n\t\t\tif(n == 10){\n\t\t\t\tinput.append('a');\n\t\t\t}\n\t\t\telse if(n == 11){\n\t\t\t\tinput.append('b');\n\t\t\t}\n\t\t\telse{\n\t\t\t\tinput.append(\"\" + n);\n\t\t\t}\n\n\t\t\tfor(int i=0; i < 12; i++){\n\t\t\t\tn = sc.nextInt();\n\t\t\t\tif(n == 10){\n\t\t\t\t\tinput.append('a');\n\t\t\t\t}\n\t\t\t\telse if(n == 11){\n\t\t\t\t\tinput.append('b');\n\t\t\t\t}\n\t\t\t\telse{\n\t\t\t\t\tinput.append(\"\" + n);\n\t\t\t\t}\n\t\t\t}\n\t\t\tString inputStr = input.toString();\n\t\t\tif(close.containsKey(inputStr)){\n\t\t\t\tSystem.out.println(close.get(inputStr));\n\t\t\t}\n\t\t\telse{\n\t\t\t\topen.addLast(new C(0,inputStr));\n\t\t\t\tHashMap<String,Integer> anotherclose = new HashMap<String, Integer>();\n\t\t\t\tanotherclose.put(inputStr, 0);\n\t\t\t\twhile(! open.isEmpty()){\n\t\t\t\t\tC pat = open.remove();\n\t\t\t\t\tStringBuilder patStr = pat.data;\n\t\t\t\t\tint patDeep = pat.deep;\n\t\t\t\t\tint lastInd = 0;\n\n\t\t\t\t\tif((close.containsKey(patStr.toString()))){\n\t\t\t\t\t\tSystem.out.println(patDeep + close.get(patStr.toString()));\n\t\t\t\t\t\tbreak;\n\t\t\t\t\t}\n\n\t\t\t\t\tif(patDeep >= 10){\n\t\t\t\t\t\tSystem.out.println(\"NA\");\n\t\t\t\t\t\tbreak;\n\t\t\t\t\t}\n\n\t\t\t\t\tfor(int i=0; i < 2; i++){\n\t\t\t\t\t\tint ind = patStr.indexOf(\"0\", lastInd);\n\t\t\t\t\t\tint [] result = getIndex(ind);\n\t\t\t\t\t\tint x = result[0];\n\t\t\t\t\t\tint y = result[1];\n\n\t\t\t\t\t\tfor(int j=0; j < 4; j++){\n\t\t\t\t\t\t\tint patX = x + xdir[j];\n\t\t\t\t\t\t\tint patY = y + ydir[j];\n\t\t\t\t\t\t\tif(start[patY][patX] >= 0){\n\t\t\t\t\t\t\t\tStringBuilder newStr = new StringBuilder(patStr.toString());\n\t\t\t\t\t\t\t\tchar change = newStr.charAt(start[patY][patX]);\n\t\t\t\t\t\t\t\tnewStr.setCharAt(ind, change);\n\t\t\t\t\t\t\t\tnewStr.setCharAt(start[patY][patX], '0');\n\t\t\t\t\t\t\t\tString temp = newStr.toString();\n\n\t\t\t\t\t\t\t\tif((! anotherclose.containsKey(temp))){\n\t\t\t\t\t\t\t\t\topen.addLast(new C(patDeep + 1, temp));\n\t\t\t\t\t\t\t\t\tanotherclose.put(temp, patDeep+1);\n\t\t\t\t\t\t\t\t}\n\t\t\t\t\t\t\t}\n\t\t\t\t\t\t}\n\t\t\t\t\t\tlastInd = ind + 1;\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t}\n\tpublic static void main(String[] args) {\n\t\tMain obj = new Main();\n\t\tobj.doIt();\n\t}\n}"
  },
  {
    "language": "Java",
    "code": "\nimport java.util.ArrayDeque;\nimport java.util.Deque;\nimport java.util.HashMap;\nimport java.util.Map;\nimport java.util.Scanner;\n\npublic class Main {\n\n\tpublic static void main(String[] args) {\n\t\tnew Main().run();\n\t}\n\n\tprivate void run() {\n\t\tScanner scanner = new Scanner(System.in);\n\t\tint[][] adj = { { 2 }, { 2, 5 }, { 0, 1, 3, 6 }, { 2, 7 }, { 5 },\n\t\t\t\t{ 1, 4, 6, 9 }, { 2, 5, 7, 10 }, { 3, 6, 8, 11 }, { 7 },\n\t\t\t\t{ 5, 10 }, { 6, 9, 11, 12 }, { 7, 10 }, { 10 } };\n\t\tString g = \"0ABCDEFGHIJK0\";\n\t\tMap<String, Integer> m = new HashMap<String, Integer>();\n\t\tDeque<String> deque = new ArrayDeque<String>();\n\t\tint step = 1;\n\t\tdeque.offer(g);\n\t\tm.put(g, 0);\n\t\twhile (!deque.isEmpty() && step < 20) {\n\t\t\tint size = deque.size();\n\t\t\tfor (int k = 0; k < size; k++) {\n\t\t\t\tString s = deque.pop();\n\t\t\t\tchar[] c = s.toCharArray();\n\t\t\t\tfor (int i = 0; i < 13; i++) {\n\t\t\t\t\tif (c[i] == '0') {\n\t\t\t\t\t\tfor (int j = 0; j < adj[i].length; j++) {\n\t\t\t\t\t\t\tchar u = c[adj[i][j]];\n\t\t\t\t\t\t\tc[adj[i][j]] = '0';\n\t\t\t\t\t\t\tc[i] = u;\n\t\t\t\t\t\t\tString n = String.valueOf(c);\n\t\t\t\t\t\t\tif (!m.containsKey(n)) {\n\t\t\t\t\t\t\t\tm.put(n, step);\n\t\t\t\t\t\t\t\tdeque.offer(n);\n\t\t\t\t\t\t\t}\n\t\t\t\t\t\t\tc[adj[i][j]] = u;\n\t\t\t\t\t\t\tc[i] = '0';\n\t\t\t\t\t\t}\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t}\n\t\t\tstep++;\n\t\t}\n\t\twhile (true) {\n\t\t\tint p = scanner.nextInt();\n\t\t\tif (p == -1)\n\t\t\t\tbreak;\n\t\t\tchar[] cc = new char[13];\n\t\t\tcc[0] = p == 0 ? '0' : (char) (p - 1 + 'A');\n\t\t\tfor (int i = 1; i < 13; i++) {\n\t\t\t\tp = scanner.nextInt();\n\t\t\t\tcc[i] = p == 0 ? '0' : (char) (p - 1 + 'A');\n\t\t\t}\n\t\t\tString st = String.valueOf(cc);\n\t\t\tSystem.out.println(m.get(st) == null ? \"NA\" : m.get(st));\n\n\t\t}\n\t}\n}"
  },
  {
    "language": "Java",
    "code": "import java.util.*;\nimport java.util.regex.Pattern;\npublic class Main {\n\t\n\tArrayList<ArrayList<Integer>> swapList;\n\tint ans;\n\tHashMap<String,Integer> fromAns;\n\t\n\tclass C{\n\t\tint s;\n\t\tString now;\n\t\tpublic C(String now, int s){\n\t\t\tthis.now = now;\n\t\t\tthis.s = s;\n\t\t}\n\t}\n\t\n\tprivate void doit(){\n\t\tScanner sc = new Scanner(System.in);\n\t\t\n\t\t//swap pattern list\n\t\tcreateSwapList();\n\t\t\n\t\t//from ans\n\t\tString goal = \"0 1 2 3 4 5 6 7 8 9 10 11 0\";\n\t\tfromAns = new HashMap<String, Integer>();\n\t\tcreateStep(goal,0);\n\t\t\n\t\twhile(true){\n\t\t\t//input data\n\t\t\tint n = sc.nextInt();\n\t\t\tif(n == -1) break;\n\t\t\t//create start String\n\t\t\tStringBuilder sb  = new StringBuilder(\"\"+n);\n\t\t\tfor(int i=1; i <= 12; i++){\n\t\t\t\tsb.append(\" \");\n\t\t\t\tsb.append(sc.next());\n\t\t\t}\n\t\t\tString startS = sb.toString();\n\t\t\t\n\t\t\tif(fromAns.containsKey(startS)){\n\t\t\t\tSystem.out.println(fromAns.get(startS));\n\t\t\t\tcontinue;\n\t\t\t}\n\t\t\t\n\t\t\t//from start\n\t\t\tans = -1;\n\t\t\tcreateStep(startS,1);\n\t\t\t\n\t\t\t//comp and out\n\t\t\tif(ans != -1){\n\t\t\t\tSystem.out.println(ans);\n\t\t\t}\n\t\t\telse{\n\t\t\t\tSystem.out.println(\"NA\");\n\t\t\t}\n\t\t}\n//\t\tfor(String key: fromAns.keySet()){\n//\t\t\tif(fromAns.get(key) == 10){\n//\t\t\t\tSystem.out.println(key);\n//\t\t\t}\n//\t\t}\n\t}\n\t\n\tprivate int getInd0F(String [] s) {\n\t\tint len = s.length;\n\t\tfor(int i=0; i < len; i++){\n\t\t\tif(s[i].equals(\"0\")) return i;\n\t\t}\n\t\treturn -1;\n\t}\n\t\n\tprivate int getInd0L(String [] s) {\n\t\tint len = s.length;\n\t\tfor(int i=len-1; i >= 0; i--){\n\t\t\tif(s[i].equals(\"0\")) return i;\n\t\t}\n\t\treturn -1;\n\t}\n\t\n\tprivate String createS(String [] s){\n\t\tStringBuilder sb = new StringBuilder();\n\t\tfor(int i=0; i < s.length-1; i++){\n\t\t\tsb.append(s[i]);\n\t\t\tsb.append(\" \");\n\t\t}\n\t\tsb.append(s[s.length-1]);\n\t\treturn sb.toString();\n\t}\n\t\n\tprivate void createStep(String start, int state){\n\t\t//init\n\t\tLinkedList<C> open = new LinkedList<C>();\n\t\topen.add(new C(start, 0));\n\t\tHashMap<String, Integer> close = new HashMap<String, Integer>();\n\t\tif(fromAns.containsKey(start)){\n\t\t\tans = fromAns.get(start);\n\t\t\treturn ;\n\t\t}\n\t\tclose.put(start, 0);\n\t\t\n\t\t//start\n\t\twhile(! open.isEmpty()){\n\t\t\tC now = open.removeFirst();\n\t\t\t\n\t\t\t//find a zero ind\n\t\t\tString [] nowParse = now.now.split(\" \");\n\t\t\tint ind01 = getInd0F(nowParse);\n\t\t\tint ind02 = getInd0L(nowParse);\n\t\t\tint [] ind0list = {ind01, ind02};\n\t\t\t\n\t\t\t//swap pattern times\n\t\t\tfor(int i = 0; i < ind0list.length;i++){\n\t\t\t\tint nowind = ind0list[i];\n\t\t\t\tfor(int j=0; j < swapList.get(nowind).size(); j++){\n\t\t\t\t\tint swapind = swapList.get(nowind).get(j);\n\t\t\t\t\tString [] work = now.now.split(\" \");\n\t\t\t\t\t\n\t\t\t\t\t//swap\n\t\t\t\t\tString temp = work[nowind];\n\t\t\t\t\twork[nowind] = work[swapind];\n\t\t\t\t\twork[swapind] = temp;\n\t\t\t\t\t\n\t\t\t\t\t//create new String \n\t\t\t\t\tString newS = createS(work);\n\t\t\t\t\t\n\t\t\t\t\t//close contains\n\t\t\t\t\tif(close.containsKey(newS)) continue;\n\t\t\t\t\t\n\t\t\t\t\t//find a goal\n\t\t\t\t\tint nextstep = now.s + 1;\n\t\t\t\t\tif(fromAns.containsKey(newS)){\n\t\t\t\t\t\tans = nextstep + fromAns.get(newS);\n\t\t\t\t\t\treturn ;\n\t\t\t\t\t}\n\t\t\t\t\t\n\t\t\t\t\t//open.add\n\t\t\t\t\tif(nextstep != 10){\n\t\t\t\t\t\topen.add(new C(newS, nextstep));\n\t\t\t\t\t}\n\t\t\t\t\t\n\t\t\t\t\t//close.put\n\t\t\t\t\tclose.put(newS, nextstep);\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t\tif(state == 0){\n\t\t\tfromAns = close;\n\t\t}\n\t}\n\n\tprivate void createSwapList() {\n\t\tswapList = new ArrayList<ArrayList<Integer>>();\n\t\tfor(int i=0; i <= 12; i++){\n\t\t\tswapList.add(new ArrayList<Integer>());\n\t\t}\n\t\tfor(int i=0; i <= 12; i++){\n\t\t\t//bottom\n\t\t\tif(i == 1 || i == 2 || i == 3 || i == 5 || i == 6 || i == 7){\n\t\t\t\tswapList.get(i).add(i+4);\n\t\t\t\tswapList.get(i+4).add(i);\n\t\t\t}\n\t\t\tif(i == 0 || i == 10){\n\t\t\t\tswapList.get(i).add(i+2);\n\t\t\t\tswapList.get(i+2).add(i);\n\t\t\t}\n\t\t\t//right\n\t\t\tif(i == 1 || i == 2 || i == 4 || i == 5 || i == 6 || i == 7 || i == 9 || i == 10 ){\n\t\t\t\tswapList.get(i).add(i+1);\n\t\t\t\tswapList.get(i+1).add(i);\n\t\t\t}\n\t\t}\n\t}\n\n\tpublic static void main(String[] args) {\n\t\tMain obj = new Main();\n\t\tobj.doit();\n\t}\n}"
  },
  {
    "language": "Java",
    "code": "\nimport java.util.ArrayDeque;\nimport java.util.Deque;\nimport java.util.HashMap;\nimport java.util.HashSet;\nimport java.util.Map;\nimport java.util.Scanner;\nimport java.util.Set;\n\npublic class Main {\n\n\tpublic static void main(String[] args) {\n\t\tnew Main().run();\n\t}\n\n\tprivate void run() {\n\t\tScanner scanner = new Scanner(System.in);\n\t\tint[][] map = { { 2 }, { 2, 5 }, { 0, 1, 3, 6 }, { 2, 7 }, { 5 },\n\t\t\t\t{ 1, 4, 6, 9 }, { 2, 5, 7, 10 }, { 3, 6, 8, 11 }, { 7 },\n\t\t\t\t{ 5, 10 }, { 2, 5, 7, 10 }, { 7, 10 }, { 10 } };\n\t\tString reslt = \"0ABCDEFGHIJK0\";\n\t\tMap<String, Integer> memo = new HashMap<String, Integer>();\n\t\tmemo.put(reslt, 0);\n\t\tint step = 1;\n\t\tDeque<String> deque = new ArrayDeque<String>();\n\t\tdeque.offer(reslt);\n\t\twhile (step <= 10) {\n\t\t\tint size = deque.size();\n\t\t\twhile (size-- > 0) {\n\t\t\t\tchar[] chs = deque.pop().toCharArray();\n\t\t\t\tfor (int i = 0; i < 13; i++) {\n\t\t\t\t\tif (chs[i] == '0') {\n\t\t\t\t\t\tfor (int j : map[i]) {\n\t\t\t\t\t\t\tchs[i] = chs[j];\n\t\t\t\t\t\t\tchs[j] = '0';\n\t\t\t\t\t\t\tString tmp = String.valueOf(chs);\n\t\t\t\t\t\t\tif (!memo.containsKey(tmp)) {\n\t\t\t\t\t\t\t\tmemo.put(tmp, step);\n\t\t\t\t\t\t\t\tdeque.offer(tmp);\n\t\t\t\t\t\t\t}\n\t\t\t\t\t\t\tchs[j] = chs[i];\n\t\t\t\t\t\t\tchs[i] = '0';\n\t\t\t\t\t\t}\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t}\n\t\t\tstep++;\n\t\t}\n\t\twhile (true) {\n\t\t\tint n = scanner.nextInt();\n\t\t\tif (n == -1)\n\t\t\t\tbreak;\n\t\t\tchar[] cs = new char[13];\n\t\t\tcs[0] = n == 0 ? '0' : (char) (n - 1 + 'A');\n\t\t\tfor (int i = 1; i < 13; i++) {\n\t\t\t\tint c = scanner.nextInt();\n\t\t\t\tcs[i] = c == 0 ? '0' : (char) (c - 1 + 'A');\n\t\t\t}\n\t\t\tstep = 0;\n\t\t\tdeque.clear();\n\t\t\tString s = String.valueOf(cs);\n\t\t\tdeque.offer(s);\n\t\t\tSet<String> set = new HashSet<String>();\n\t\t\tset.add(s);\n\t\t\tString ret = \"NA\";\n\t\t\tloop: while (step <= 10) {\n\t\t\t\tint size = deque.size();\n\t\t\t\twhile (size-- > 0) {\n\t\t\t\t\tString str = deque.pop();\n\t\t\t\t\tif (memo.containsKey(str)) {\n\t\t\t\t\t\tret = String.valueOf(memo.get(str + step));\n\t\t\t\t\t\tbreak loop;\n\t\t\t\t\t}\n\t\t\t\t\tchar[] chs = str.toCharArray();\n\t\t\t\t\tfor (int i = 0; i < 13; i++) {\n\t\t\t\t\t\tif (chs[i] == '0') {\n\t\t\t\t\t\t\tfor (int j : map[i]) {\n\t\t\t\t\t\t\t\tchs[i] = chs[j];\n\t\t\t\t\t\t\t\tchs[j] = '0';\n\t\t\t\t\t\t\t\tString tmp = String.valueOf(chs);\n\t\t\t\t\t\t\t\tif (!set.contains(tmp)) {\n\t\t\t\t\t\t\t\t\tset.add(tmp);\n\t\t\t\t\t\t\t\t\tdeque.offer(tmp);\n\t\t\t\t\t\t\t\t}\n\t\t\t\t\t\t\t\tchs[j] = chs[i];\n\t\t\t\t\t\t\t\tchs[i] = '0';\n\t\t\t\t\t\t\t}\n\t\t\t\t\t\t}\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t\tstep++;\n\t\t\t}\n\t\t\tSystem.out.println(ret);\n\t\t}\n\n\t}\n}"
  },
  {
    "language": "Java",
    "code": "import java.util.ArrayDeque;\nimport java.util.Arrays;\nimport java.util.HashMap;\nimport java.util.Scanner;\n\npublic class Main {\n\tstatic HashMap<String,Integer> map = new HashMap<String,Integer>();\n\tstatic HashMap<String,Integer> map2 = new HashMap<String,Integer>();\n\tstatic int min = 21;\n\tstatic int[][] move = new int[][] {\n\t\t\t\t\t\t\t\t{2},\n\t\t\t\t\t   {2,5},{0,1,3,6},{2,7},\n\t\t\t   {5},{1,4,6,9},{2,5,7,10},{3,6,8,11},{7},\n\t\t\t          {5,10},{6,9,11,12},{7,10},\n\t\t\t          \t\t\t{10}\n\t\t\t          };\n \t\n\tpublic static void main(String[] args) {\n\t\tScanner sc = new Scanner(System.in);\n\t\tString first = \"0123456789AB0\";\n\t\tBfsa(0,0,12,first);\n\t\tIN:while(true) {\n\t\t\tmin = 21;\n\t\t\tchar[] data = new char[13];\n\t\t\tint xa = -1;\n\t\t\tint xb = -1;\n\t\t\tfor(int i = 0; i < 13; i++) {\n\t\t\t\tString tmp = sc.next();\n\t\t\t\tif(tmp.equals(\"-1\")) break IN;\n\t\t\t\tif(tmp.equals(\"10\")) tmp = \"A\";\n\t\t\t\tif(tmp.equals(\"11\")) tmp = \"B\";\n\t\t\t\tif(tmp.equals(\"0\")) {\n\t\t\t\t\tif(xa == -1) xa = i;\n\t\t\t\t\telse xb = i;\n\t\t\t\t}\n\t\t\t\tdata[i] = tmp.charAt(0);\n\t\t\t}\n\t\t\tif(map.containsKey(String.valueOf(data))) {\n\t\t\t\tmin = map.get(String.valueOf(data));\n\t\t\t}\n\t\t\tBfsb(0,xa,xb,String.valueOf(data));\n\t\t\tif(min <= 20) {\n\t\t\t\tSystem.out.println(min);\n\t\t\t}\n\t\t\telse {\n\t\t\t\tSystem.out.println(\"NA\");\n\t\t\t}\n\t\t\t\n\t\t}\n\t}\n\tstatic ArrayDeque<Data> queue = new ArrayDeque<Data>();\n\t\n\tstatic void Bfsa(int a, int b, int c,String d) {\n\t\tqueue.clear();\n\t\tqueue.add(new Data(a,b,c,d));\n\t\twhile(!queue.isEmpty()) {\n\t\t\tData ax = queue.poll();\n\t\t\tbfsa(ax.a,ax.b1,ax.b2,ax.d);\n\t\t}\n\t}\n\t\n\tstatic void Bfsb(int a, int b, int c,String d) {\n\t\tqueue.clear();\n\t\tqueue.add(new Data(a,b,c,d));\n\t\twhile(!queue.isEmpty()) {\n\t\t\tData ax = queue.poll();\n\t\t\tbfsb(ax.a,ax.b1,ax.b2,ax.d);\n\t\t}\n\t}\n\t\n\t\n\tstatic String swap(int a, int b, String c) {\n\t\tchar[] x = c.toCharArray();\n\t\tchar tmp = x[a];\n\t\tx[a] = x[b];\n\t\tx[b] = tmp;\n\t\tString cx = String.valueOf(x);\n\t\treturn cx;\n\t}\n\tstatic void bfsa(int a, int b1,int b2, String c) {\n\t\tif(a >= 10) return;\n\t\tif(!map.containsKey(c)) {\n\t\t\t\tmap.put(c, a);\n\t\t}\n\t\telse {\n\t\t\treturn;\n\t\t}\n\t\tfor(int i = 0; i < 13; i++) {\n\t\t\tif(b1 == i) {\n\t\t\t\tfor(int j = 0; j < move[i].length; j++) {\n\t\t\t\t\tif(move[i][j] == b2) {\n\t\t\t\t\t\tc = swap(b2,b1,c);\n\t\t\t\t\t\tqueue.add(new Data(a,b2,b1,c));\n\t\t\t\t\t\tc = swap(b2,b1,c);\n\t\t\t\t\t}\n\t\t\t\t\telse {\n\t\t\t\t\t\tc = swap(move[i][j],b1,c);\n\t\t\t\t\t\tqueue.add(new Data(a+1,move[i][j],b2,c));\n\t\t\t\t\t\tc = swap(move[i][j],b1,c);\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t}\n\t\t\tif(b2 == i) {\n\t\t\t\tfor(int j = 0; j < move[i].length; j++) {\n\t\t\t\t\tif(move[i][j] == b1) {\n\t\t\t\t\t\tc = swap(b2,b1,c);\n\t\t\t\t\t\tqueue.add(new Data(a,b2,b1,c));\n\t\t\t\t\t\tc = swap(b2,b1,c);\n\t\t\t\t\t}\n\t\t\t\t\telse {\n\t\t\t\t\t\tc = swap(move[i][j],b2,c);\n\t\t\t\t\t\tqueue.add(new Data(a+1,b1,move[i][j],c));\n\t\t\t\t\t\tc = swap(move[i][j],b2,c);\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t}\n\t\n\tstatic void bfsb(int a, int b1,int b2, String c) {\n\t\tif(a >= 10) return;\n\t\tif(!map2.containsKey(c)) {\n\t\t\tif(map.containsKey(c)) {\n\t\t\t\tmin = Math.min(min, a + map.get(c));\n\t\t\t}\n\t\t\tmap2.put(c, a);\n\t\t}\n\t\telse {\n\t\t\treturn;\n\t\t}\n\t\tfor(int i = 0; i < 13; i++) {\n\t\t\tif(b1 == i) {\n\t\t\t\tfor(int j = 0; j < move[i].length; j++) {\n\t\t\t\t\tif(move[i][j] == b2) {\n\t\t\t\t\t\tc = swap(b2,b1,c);\n\t\t\t\t\t\tqueue.add(new Data(a,b2,b1,c));\n\t\t\t\t\t\tc = swap(b2,b1,c);\n\t\t\t\t\t}\n\t\t\t\t\telse {\n\t\t\t\t\t\tc = swap(move[i][j],b1,c);\n\t\t\t\t\t\tqueue.add(new Data(a+1,move[i][j],b2,c));\n\t\t\t\t\t\tc = swap(move[i][j],b1,c);\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t}\n\t\t\tif(b2 == i) {\n\t\t\t\tfor(int j = 0; j < move[i].length; j++) {\n\t\t\t\t\tif(move[i][j] == b1) {\n\t\t\t\t\t\tc = swap(b2,b1,c);\n\t\t\t\t\t\tqueue.add(new Data(a,b2,b1,c));\n\t\t\t\t\t\tc = swap(b2,b1,c);\n\t\t\t\t\t}\n\t\t\t\t\telse {\n\t\t\t\t\t\tc = swap(move[i][j],b2,c);\n\t\t\t\t\t\tqueue.add(new Data(a+1,b1,move[i][j],c));\n\t\t\t\t\t\tc = swap(move[i][j],b2,c);\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t}\n\t\n\tstatic class Data {\n\t\tint a, b1, b2 ;\n\t\tString d;\n\t\tData(int a, int b, int c, String d) {\n\t\t\tthis.a = a;\n\t\t\tb1 = b;\n\t\t\tb2 = c;\n\t\t\tthis.d = d;\n\t\t}\n\t}\n\t\n\n}"
  },
  {
    "language": "Java",
    "code": "import java.util.*;\npublic class Main {\n\tint [][] start;\n\tfinal int [] xdir = {0,1,0,-1};\n\tfinal int [] ydir = {1,0,-1,0};\n\n\tpublic class C {\n\t\tint deep;\n\t\tStringBuilder data;\n\t\tpublic C(int deep, String data) {\n\t\t\tthis.deep = deep;\n\t\t\tthis.data = new StringBuilder(data);\n\t\t}\n\t}\n\n\tprivate int[] getIndex(int ind){\n\t\tfor(int i=0; i < 7; i++){\n\t\t\tfor(int j=0; j < 7; j++){\n\t\t\t\tif(start[i][j] == ind){\n\t\t\t\t\tint [] ans = {j,i};\n\t\t\t\t\treturn ans;\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t\treturn null;\n\t}\n\n\tpublic void doIt(){\n\t\tScanner sc = new Scanner(System.in);\n\t\tLinkedList<C> open = new LinkedList<C>();\n\t\tHashMap<String,Integer> close = new HashMap<String, Integer>();\n\t\tstart = new int[7][7];\n\t\tfor(int i=0; i < 7; i++){\n\t\t\tArrays.fill(start[i], -1);\n\t\t}\n\t\tstart[1][3] = 0;\n\t\tstart[2][2] = 1;\n\t\tstart[2][3] = 2;\n\t\tstart[2][4] = 3;\n\t\tstart[3][1] = 4;\n\t\tstart[3][2] = 5;\n\t\tstart[3][3] = 6;\n\t\tstart[3][4] = 7;\n\t\tstart[3][5] = 8;\n\t\tstart[4][2] = 9;\n\t\tstart[4][3] = 10;\n\t\tstart[4][4] = 11;\n\t\tstart[5][3] = 12;\n\t\topen.addLast(new C(0,\"0123456789ab0\"));\n\t\tclose.put(\"0123456789ab0\", 0);\n\n\t\twhile(! open.isEmpty()){\n\t\t\tC pat = open.remove();\n\t\t\tStringBuilder patStr = pat.data;\n\t\t\tint patDeep = pat.deep;\n\t\t\tint lastInd = 0;\n\t\t\tif(patDeep >= 10){\n\t\t\t\topen.clear();\n\t\t\t\tbreak;\n\t\t\t}\n\n\t\t\tfor(int i=0; i < 2; i++){\n\t\t\t\tint ind = patStr.indexOf(\"0\", lastInd);\n\t\t\t\tint [] result = getIndex(ind);\n\t\t\t\tint x = result[0];\n\t\t\t\tint y = result[1];\n\n\t\t\t\tfor(int j=0; j < 4; j++){\n\t\t\t\t\tint patX = x + xdir[j];\n\t\t\t\t\tint patY = y + ydir[j];\n\t\t\t\t\tif(start[patY][patX] >= 0){\n\t\t\t\t\t\tStringBuilder newStr = new StringBuilder(patStr.toString());\n\t\t\t\t\t\tchar change = newStr.charAt(start[patY][patX]);\n\t\t\t\t\t\tnewStr.setCharAt(ind, change);\n\t\t\t\t\t\tnewStr.setCharAt(start[patY][patX], '0');\n\t\t\t\t\t\tString temp = newStr.toString();\n\n\t\t\t\t\t\tif((! close.containsKey(temp))){\n\t\t\t\t\t\t\topen.addLast(new C(patDeep + 1, temp));\n\t\t\t\t\t\t\tclose.put(temp, patDeep+1);\n\t\t\t\t\t\t}\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t\tlastInd = ind + 1;\n\t\t\t}\n\t\t}\n\n\t\twhile(true){\n\t\t\tint n = sc.nextInt();\n\t\t\tif(n == -1){\n\t\t\t\tbreak;\n\t\t\t}\n\t\t\tStringBuilder input = new StringBuilder();\n\t\t\tif(n == 10){\n\t\t\t\tinput.append('a');\n\t\t\t}\n\t\t\telse if(n == 11){\n\t\t\t\tinput.append('b');\n\t\t\t}\n\t\t\telse{\n\t\t\t\tinput.append(\"\" + n);\n\t\t\t}\n\n\t\t\tfor(int i=0; i < 12; i++){\n\t\t\t\tn = sc.nextInt();\n\t\t\t\tif(n == 10){\n\t\t\t\t\tinput.append('a');\n\t\t\t\t}\n\t\t\t\telse if(n == 11){\n\t\t\t\t\tinput.append('b');\n\t\t\t\t}\n\t\t\t\telse{\n\t\t\t\t\tinput.append(\"\" + n);\n\t\t\t\t}\n\t\t\t}\n\t\t\tString inputStr = input.toString();\n//\t\t\tString inputStr = sc.next();\n//\t\t\tif(inputStr.equals(\"-1\"))\n//\t\t\t\tbreak;\n\n\t\t\tif(close.containsKey(inputStr)){\n\t\t\t\tSystem.out.println(close.get(inputStr));\n\t\t\t}\n\t\t\telse{\n\t\t\t\topen.addLast(new C(0,inputStr));\n\t\t\t\tHashMap<String,Integer> anotherclose = new HashMap<String, Integer>();\n\t\t\t\tanotherclose.put(inputStr, 0);\n\t\t\t\twhile(! open.isEmpty()){\n\t\t\t\t\tC pat = open.remove();\n\t\t\t\t\tStringBuilder patStr = pat.data;\n\t\t\t\t\tint patDeep = pat.deep;\n\t\t\t\t\tint lastInd = 0;\n\n\t\t\t\t\tif((close.containsKey(patStr.toString()))){\n\t\t\t\t\t\tSystem.out.println(patDeep + close.get(patStr.toString()));\n\t\t\t\t\t\tbreak;\n\t\t\t\t\t}\n\n\t\t\t\t\tif(patDeep >= 11){\n\t\t\t\t\t\tSystem.out.println(\"NA\");\n\t\t\t\t\t\tbreak;\n\t\t\t\t\t}\n\n\t\t\t\t\tfor(int i=0; i < 2; i++){\n\t\t\t\t\t\tint ind = patStr.indexOf(\"0\", lastInd);\n\t\t\t\t\t\tint [] result = getIndex(ind);\n\t\t\t\t\t\tint x = result[0];\n\t\t\t\t\t\tint y = result[1];\n\n\t\t\t\t\t\tfor(int j=0; j < 4; j++){\n\t\t\t\t\t\t\tint patX = x + xdir[j];\n\t\t\t\t\t\t\tint patY = y + ydir[j];\n\t\t\t\t\t\t\tif(start[patY][patX] >= 0){\n\t\t\t\t\t\t\t\tStringBuilder newStr = new StringBuilder(patStr.toString());\n\t\t\t\t\t\t\t\tchar change = newStr.charAt(start[patY][patX]);\n\t\t\t\t\t\t\t\tnewStr.setCharAt(ind, change);\n\t\t\t\t\t\t\t\tnewStr.setCharAt(start[patY][patX], '0');\n\t\t\t\t\t\t\t\tString temp = newStr.toString();\n\n\t\t\t\t\t\t\t\tif((! anotherclose.containsKey(temp))){\n\t\t\t\t\t\t\t\t\topen.addLast(new C(patDeep + 1, temp));\n\t\t\t\t\t\t\t\t\tanotherclose.put(temp, patDeep+1);\n\t\t\t\t\t\t\t\t}\n\t\t\t\t\t\t\t}\n\t\t\t\t\t\t}\n\t\t\t\t\t\tlastInd = ind + 1;\n\t\t\t\t\t}\n\t\t\t\t}\n\n\t\t\t}\n\t\t}\n\n\t}\n\tpublic static void main(String[] args) {\n\t\tMain obj = new Main();\n\t\tobj.doIt();\n\t}\n}"
  },
  {
    "language": "Java",
    "code": "import java.util.ArrayDeque;\nimport java.util.Arrays;\nimport java.util.HashMap;\nimport java.util.Scanner;\n\npublic class Main {\n\tstatic HashMap<String,Integer> map = new HashMap<String,Integer>();\n\tstatic int[][] move = new int[][] {\n\t\t\t\t\t\t\t\t{2},\n\t\t\t\t\t   {2,5},{0,1,3,6},{2,7},\n\t\t\t   {5},{1,4,6,9},{2,5,7,10},{3,6,8,11},{7},\n\t\t\t          {5,10},{6,9,11,12},{7,10},\n\t\t\t          \t\t\t{10}\n\t\t\t          };\n \t\n\tpublic static void main(String[] args) {\n\t\tScanner sc = new Scanner(System.in);\n\t\tchar[] first = new char[] { '0','1','2','3','4','5','6','7','8','9','A','B','0'};\n\t\tdfs(0,0,12,first);\n\t\tIN:while(true) {\n\t\t\tchar[] data = new char[13];\n\t\t\tfor(int i = 0; i < 13; i++) {\n\t\t\t\tString tmp = sc.next();\n\t\t\t\tif(tmp.equals(\"-1\")) break IN;\n\t\t\t\tif(tmp.equals(\"10\")) tmp = \"A\";\n\t\t\t\tif(tmp.equals(\"11\")) tmp = \"B\";\n\t\t\t\tdata[i] = tmp.charAt(0);\n\t\t\t}\n\t\t\tif(map.containsKey(String.valueOf(data))) {\n\t\t\t\tSystem.out.println(map.get(String.valueOf(data)));\n\t\t\t}\n\t\t\telse {\n\t\t\t\tSystem.out.println(\"NA\");\n\t\t\t}\n\t\t\t\n\t\t}\n\t}\n\tstatic void swap(int a, int b, char[] c) {\n\t\tchar tmp = c[a];\n\t\tc[a] = c[b];\n\t\tc[b] = tmp;\n\t}\n\tstatic void dfs(int a, int b1,int b2, char[] c) {\n\t\tStringBuilder tmp = new StringBuilder(String.valueOf(c));\n\t\tif(a >= 20) return;\n\t\tString s = tmp.toString();\n\t\tif(map.containsKey(s)) {\n\t\t\tif(map.get(s) <= a) {\n\t\t\t\treturn;\n\t\t\t}\n\t\t\telse {\n\t\t\t\tmap.put(s, a);\n\t\t\t}\n\t\t}\n\t\telse {\n\t\t\tmap.put(s, a);\n\t\t}\n\t\tfor(int i = 0; i < 13; i++) {\n\t\t\tif(b1 == i) {\n\t\t\t\tfor(int j = 0; j < move[i].length; j++) {\n\t\t\t\t\tif(move[i][j] == b2) {\n\t\t\t\t\t\tswap(b2,b1,c);\n\t\t\t\t\t\tdfs(a+1,b2,b1,c);\n\t\t\t\t\t\tswap(b2,b1,c);\n\t\t\t\t\t}\n\t\t\t\t\telse {\n\t\t\t\t\t\tswap(move[i][j],b1,c);\n\t\t\t\t\t\tdfs(a+1,move[i][j],b2,c);\n\t\t\t\t\t\tswap(move[i][j],b1,c);\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t}\n\t\t\tif(b2 == i) {\n\t\t\t\tfor(int j = 0; j < move[i].length; j++) {\n\t\t\t\t\tif(move[i][j] == b1) {\n\t\t\t\t\t\tswap(b2,b1,c);\n\t\t\t\t\t\tdfs(a+1,b2,b1,c);\n\t\t\t\t\t\tswap(b2,b1,c);\n\t\t\t\t\t}\n\t\t\t\t\telse {\n\t\t\t\t\t\tswap(move[i][j],b2,c);\n\t\t\t\t\t\tdfs(a+1,b1,move[i][j],c);\n\t\t\t\t\t\tswap(move[i][j],b2,c);\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t}\n\t\n\n}"
  },
  {
    "language": "Java",
    "code": "import java.util.*;\npublic class Main {\n\tint [][] start;\n\tfinal int [] xdir = {0,1,0,-1};\n\tfinal int [] ydir = {1,0,-1,0};\n\n\tpublic class C {\n\t\tint deep;\n\t\tStringBuilder data;\n\t\tpublic C(int deep, String data) {\n\t\t\tthis.deep = deep;\n\t\t\tthis.data = new StringBuilder(data);\n\t\t}\n\t}\n\n\tprivate int[] getIndex(int ind){\n\t\tfor(int i=0; i < 7; i++){\n\t\t\tfor(int j=0; j < 7; j++){\n\t\t\t\tif(start[i][j] == ind){\n\t\t\t\t\tint [] ans = {j,i};\n\t\t\t\t\treturn ans;\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t\treturn null;\n\t}\n\n\tpublic void doIt(){\n\t\tScanner sc = new Scanner(System.in);\n\t\tLinkedList<C> open = new LinkedList<C>();\n\t\tHashMap<String,Integer> close = new HashMap<String, Integer>();\n\t\tstart = new int[7][7];\n\t\tfor(int i=0; i < 7; i++){\n\t\t\tArrays.fill(start[i], -1);\n\t\t}\n\t\tstart[1][3] = 0;\n\t\tstart[2][2] = 1;\n\t\tstart[2][3] = 2;\n\t\tstart[2][4] = 3;\n\t\tstart[3][1] = 4;\n\t\tstart[3][2] = 5;\n\t\tstart[3][3] = 6;\n\t\tstart[3][4] = 7;\n\t\tstart[3][5] = 8;\n\t\tstart[4][2] = 9;\n\t\tstart[4][3] = 10;\n\t\tstart[4][4] = 11;\n\t\tstart[5][3] = 12;\n\t\topen.addLast(new C(0,\"0123456789ab0\"));\n\t\tclose.put(\"0123456789ab0\", 0);\n\n\t\twhile(! open.isEmpty()){\n\t\t\tC pat = open.remove();\n\t\t\tStringBuilder patStr = pat.data;\n\t\t\tint patDeep = pat.deep;\n\t\t\tint lastInd = 0;\n\t\t\tif(patDeep > 10){\n\t\t\t\tcontinue;\n\t\t\t}\n\n\t\t\tfor(int i=0; i < 2; i++){\n\t\t\t\tint ind = patStr.indexOf(\"0\", lastInd);\n\t\t\t\tint [] result = getIndex(ind);\n\t\t\t\tint x = result[0];\n\t\t\t\tint y = result[1];\n\n\t\t\t\tfor(int j=0; j < 4; j++){\n\t\t\t\t\tint patX = x + xdir[j];\n\t\t\t\t\tint patY = y + ydir[j];\n\t\t\t\t\tif(start[patY][patX] >= 0){\n\t\t\t\t\t\tStringBuilder newStr = new StringBuilder(patStr.toString());\n\t\t\t\t\t\tchar change = newStr.charAt(start[patY][patX]);\n\t\t\t\t\t\tnewStr.setCharAt(ind, change);\n\t\t\t\t\t\tnewStr.setCharAt(start[patY][patX], '0');\n\t\t\t\t\t\tString temp = newStr.toString();\n\n\t\t\t\t\t\tif((! close.containsKey(temp))){\n\t\t\t\t\t\t\topen.addLast(new C(patDeep + 1, temp));\n\t\t\t\t\t\t\tclose.put(temp, patDeep+1);\n\t\t\t\t\t\t}\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t\tlastInd = ind + 1;\n\t\t\t}\n\t\t}\n\n\t\twhile(true){\n\t\t\tint n = sc.nextInt();\n\t\t\tif(n == -1){\n\t\t\t\tbreak;\n\t\t\t}\n\t\t\tStringBuilder input = new StringBuilder();\n\t\t\tif(n == 10){\n\t\t\t\tinput.append('a');\n\t\t\t}\n\t\t\telse if(n == 11){\n\t\t\t\tinput.append('b');\n\t\t\t}\n\t\t\telse{\n\t\t\t\tinput.append(\"\" + n);\n\t\t\t}\n\n\t\t\tfor(int i=0; i < 12; i++){\n\t\t\t\tn = sc.nextInt();\n\t\t\t\tif(n == 10){\n\t\t\t\t\tinput.append('a');\n\t\t\t\t}\n\t\t\t\telse if(n == 11){\n\t\t\t\t\tinput.append('b');\n\t\t\t\t}\n\t\t\t\telse{\n\t\t\t\t\tinput.append(\"\" + n);\n\t\t\t\t}\n\t\t\t}\n\t\t\tString inputStr = input.toString();\n\t\t\tif(close.containsKey(inputStr)){\n\t\t\t\tSystem.out.println(close.get(inputStr));\n\t\t\t}\n\t\t\telse{\n\t\t\t\topen.addLast(new C(0,inputStr));\n\t\t\t\tHashMap<String,Integer> anotherclose = new HashMap<String, Integer>();\n\t\t\t\tanotherclose.put(inputStr, 0);\n\t\t\t\tboolean flg = false;\n\t\t\t\twhile(! open.isEmpty()){\n\t\t\t\t\tC pat = open.remove();\n\t\t\t\t\tStringBuilder patStr = pat.data;\n\t\t\t\t\tint patDeep = pat.deep;\n\t\t\t\t\tint lastInd = 0;\n\t\t\t\t\tif(patDeep > 10){\n\t\t\t\t\t\tbreak;\n\t\t\t\t\t}\n\n\t\t\t\t\tfor(int i=0; i < 2; i++){\n\t\t\t\t\t\tint ind = patStr.indexOf(\"0\", lastInd);\n\t\t\t\t\t\tint [] result = getIndex(ind);\n\t\t\t\t\t\tint x = result[0];\n\t\t\t\t\t\tint y = result[1];\n\n\t\t\t\t\t\tfor(int j=0; j < 4; j++){\n\t\t\t\t\t\t\tint patX = x + xdir[j];\n\t\t\t\t\t\t\tint patY = y + ydir[j];\n\t\t\t\t\t\t\tif(start[patY][patX] >= 0){\n\t\t\t\t\t\t\t\tStringBuilder newStr = new StringBuilder(patStr.toString());\n\t\t\t\t\t\t\t\tchar change = newStr.charAt(start[patY][patX]);\n\t\t\t\t\t\t\t\tnewStr.setCharAt(ind, change);\n\t\t\t\t\t\t\t\tnewStr.setCharAt(start[patY][patX], '0');\n\t\t\t\t\t\t\t\tString temp = newStr.toString();\n\n\t\t\t\t\t\t\t\tif((close.containsKey(temp))){\n\t\t\t\t\t\t\t\t\tflg = true;\n\t\t\t\t\t\t\t\t\tSystem.out.println(patDeep + 1 + close.get(temp));\n\t\t\t\t\t\t\t\t\tbreak;\n\t\t\t\t\t\t\t\t}\n\n\t\t\t\t\t\t\t\tif((! anotherclose.containsKey(temp))){\n\t\t\t\t\t\t\t\t\topen.addLast(new C(patDeep + 1, temp));\n\t\t\t\t\t\t\t\t\tanotherclose.put(temp, patDeep+1);\n\t\t\t\t\t\t\t\t}\n\t\t\t\t\t\t\t}\n\t\t\t\t\t\t}\n\t\t\t\t\t\tif(flg)\n\t\t\t\t\t\t\tbreak;\n\t\t\t\t\t\tlastInd = ind + 1;\n\t\t\t\t\t}\n\t\t\t\t\tif(flg)\n\t\t\t\t\t\tbreak;\n\t\t\t\t}\n\t\t\t\tif(!flg){\n\t\t\t\t\tSystem.out.println(\"NA\");\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t}\n\tpublic static void main(String[] args) {\n\t\tMain obj = new Main();\n\t\tobj.doIt();\n\t}\n}"
  },
  {
    "language": "Java",
    "code": "\nimport java.util.ArrayDeque;\nimport java.util.Deque;\nimport java.util.HashMap;\nimport java.util.HashSet;\nimport java.util.Map;\nimport java.util.Scanner;\nimport java.util.Set;\n\npublic class Main {\n\n\tpublic static void main(String[] args) {\n\t\tnew Main().run();\n\t}\n\n\tprivate void run() {\n\t\tScanner scanner = new Scanner(System.in);\n\t\tint[][] map = { { 2 }, { 2, 5 }, { 0, 1, 3, 6 }, { 2, 7 }, { 5 },\n\t\t\t\t{ 1, 4, 6, 9 }, { 2, 5, 7, 10 }, { 3, 6, 8, 11 }, { 7 },\n\t\t\t\t{ 5, 10 }, { 2, 5, 7, 10 }, { 7, 10 }, { 10 } };\n\t\tString reslt = \"0ABCDEFGHIJK0\";\n\t\tMap<String, Integer> memo = new HashMap<String, Integer>();\n\t\tmemo.put(reslt, 0);\n\t\tint step = 1;\n\t\tDeque<String> deque = new ArrayDeque<String>();\n\t\tdeque.offer(reslt);\n\t\twhile (step <= 10) {\n\t\t\tint size = deque.size();\n\t\t\twhile (size-- > 0) {\n\t\t\t\tchar[] chs = deque.pop().toCharArray();\n\t\t\t\tfor (int i = 0; i < 13; i++) {\n\t\t\t\t\tif (chs[i] == '0') {\n\t\t\t\t\t\tfor (int j : map[i]) {\n\t\t\t\t\t\t\tchs[i] = chs[j];\n\t\t\t\t\t\t\tchs[j] = '0';\n\t\t\t\t\t\t\tString tmp = String.valueOf(chs);\n\t\t\t\t\t\t\tif (!memo.containsKey(tmp)) {\n\t\t\t\t\t\t\t\tmemo.put(tmp, step);\n\t\t\t\t\t\t\t\tdeque.offer(tmp);\n\t\t\t\t\t\t\t}\n\t\t\t\t\t\t\tchs[j] = chs[i];\n\t\t\t\t\t\t\tchs[i] = '0';\n\t\t\t\t\t\t}\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t}\n\t\t\tstep++;\n\t\t}\n\t\twhile (true) {\n\t\t\tint n = scanner.nextInt();\n\t\t\tif (n == -1)\n\t\t\t\tbreak;\n\t\t\tchar[] cs = new char[13];\n\t\t\tcs[0] = n == 0 ? '0' : (char) (n - 1 + 'A');\n\t\t\tfor (int i = 1; i < 13; i++) {\n\t\t\t\tint c = scanner.nextInt();\n\t\t\t\tcs[i] = c == 0 ? '0' : (char) (c - 1 + 'A');\n\t\t\t}\n\t\t\tstep = 0;\n\t\t\tdeque.clear();\n\t\t\tString s = String.valueOf(cs);\n\t\t\tdeque.offer(s);\n\t\t\tSet<String> set = new HashSet<String>();\n\t\t\tset.add(s);\n\t\t\tString ret = \"NA\";\n\t\t\tloop: while (step <= 10) {\n\t\t\t\tint size = deque.size();\n\t\t\t\twhile (size-- > 0) {\n\t\t\t\t\tString str = deque.pop();\n\t\t\t\t\tif (memo.containsKey(str)) {\n\t\t\t\t\t\tret = String.valueOf(memo.get(str));\n\t\t\t\t\t\tbreak loop;\n\t\t\t\t\t}\n\t\t\t\t\tchar[] chs = str.toCharArray();\n\t\t\t\t\tfor (int i = 0; i < 13; i++) {\n\t\t\t\t\t\tif (chs[i] == '0') {\n\t\t\t\t\t\t\tfor (int j : map[i]) {\n\t\t\t\t\t\t\t\tchs[i] = chs[j];\n\t\t\t\t\t\t\t\tchs[j] = '0';\n\t\t\t\t\t\t\t\tString tmp = String.valueOf(chs);\n\t\t\t\t\t\t\t\tif (!set.contains(tmp)) {\n\t\t\t\t\t\t\t\t\tset.add(tmp);\n\t\t\t\t\t\t\t\t\tdeque.offer(tmp);\n\t\t\t\t\t\t\t\t}\n\t\t\t\t\t\t\t\tchs[j] = chs[i];\n\t\t\t\t\t\t\t\tchs[i] = '0';\n\t\t\t\t\t\t\t}\n\t\t\t\t\t\t}\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t\tstep++;\n\t\t\t}\n\t\t\tSystem.out.println(ret);\n\t\t}\n\n\t}\n}"
  },
  {
    "language": "Java",
    "code": "import java.util.ArrayDeque;\nimport java.util.Arrays;\nimport java.util.HashMap;\nimport java.util.Scanner;\n\npublic class Main {\n\tstatic HashMap<String,Integer> map = new HashMap<String,Integer>();\n\tstatic HashMap<String,Integer> map2 = new HashMap<String,Integer>();\n\tstatic int min = 21;\n\tstatic int[][] move = new int[][] {\n\t\t\t\t\t\t\t\t{2},\n\t\t\t\t\t   {2,5},{0,1,3,6},{2,7},\n\t\t\t   {5},{1,4,6,9},{2,5,7,10},{3,6,8,11},{7},\n\t\t\t          {5,10},{6,9,11,12},{7,10},\n\t\t\t          \t\t\t{10}\n\t\t\t          };\n \t\n\tpublic static void main(String[] args) {\n\t\tScanner sc = new Scanner(System.in);\n\t\tString first = \"0123456789AB0\";\n\t\tBfsa(0,0,12,first);\n\t\tIN:while(true) {\n\t\t\tmin = 21;\n\t\t\tchar[] data = new char[13];\n\t\t\tint xa = -1;\n\t\t\tint xb = -1;\n\t\t\tfor(int i = 0; i < 13; i++) {\n\t\t\t\tString tmp = sc.next();\n\t\t\t\tif(tmp.equals(\"-1\")) break IN;\n\t\t\t\tif(tmp.equals(\"10\")) tmp = \"A\";\n\t\t\t\tif(tmp.equals(\"11\")) tmp = \"B\";\n\t\t\t\tif(tmp.equals(\"0\")) {\n\t\t\t\t\tif(xa == -1) xa = i;\n\t\t\t\t\telse xb = i;\n\t\t\t\t}\n\t\t\t\tdata[i] = tmp.charAt(0);\n\t\t\t}\n\t\t\tif(map.containsKey(String.valueOf(data))) {\n\t\t\t\tmin = map.get(String.valueOf(data));\n\t\t\t}\n\t\t\tBfsb(0,xa,xb,String.valueOf(data));\n\t\t\tif(min <= 20) {\n\t\t\t\tSystem.out.println(min);\n\t\t\t}\n\t\t\telse {\n\t\t\t\tSystem.out.println(\"NA\");\n\t\t\t}\n\t\t\t\n\t\t}\n\t}\n\tstatic ArrayDeque<Data> queue = new ArrayDeque<Data>();\n\t\n\tstatic void Bfsa(int a, int b, int c,String d) {\n\t\tqueue.clear();\n\t\tqueue.add(new Data(a,b,c,d));\n\t\twhile(!queue.isEmpty()) {\n\t\t\tData ax = queue.poll();\n\t\t\tbfsa(ax.a,ax.b1,ax.b2,ax.d);\n\t\t}\n\t}\n\t\n\tstatic void Bfsb(int a, int b, int c,String d) {\n\t\tmap2.clear();\n\t\tqueue.clear();\n\t\tqueue.add(new Data(a,b,c,d));\n\t\twhile(!queue.isEmpty()) {\n\t\t\tData ax = queue.poll();\n\t\t\tbfsb(ax.a,ax.b1,ax.b2,ax.d);\n\t\t}\n\t}\n\t\n\t\n\tstatic String swap(int a, int b, String c) {\n\t\tchar[] x = c.toCharArray();\n\t\tchar tmp = x[a];\n\t\tx[a] = x[b];\n\t\tx[b] = tmp;\n\t\tString cx = String.valueOf(x);\n\t\treturn cx;\n\t}\n\tstatic void bfsa(int a, int b1,int b2, String c) {\n\t\tif(a > 10) return;\n\t\tif(!map.containsKey(c)) {\n\t\t\t\tmap.put(c, a);\n\t\t}\n\t\telse {\n\t\t\treturn;\n\t\t}\n\t\tfor(int i = 0; i < 13; i++) {\n\t\t\tif(b1 == i) {\n\t\t\t\tfor(int j = 0; j < move[i].length; j++) {\n\t\t\t\t\tif(move[i][j] == b2) {\n\t\t\t\t\t\tc = swap(b2,b1,c);\n\t\t\t\t\t\tqueue.add(new Data(a,b2,b1,c));\n\t\t\t\t\t\tc = swap(b2,b1,c);\n\t\t\t\t\t}\n\t\t\t\t\telse {\n\t\t\t\t\t\tc = swap(move[i][j],b1,c);\n\t\t\t\t\t\tqueue.add(new Data(a+1,move[i][j],b2,c));\n\t\t\t\t\t\tc = swap(move[i][j],b1,c);\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t}\n\t\t\tif(b2 == i) {\n\t\t\t\tfor(int j = 0; j < move[i].length; j++) {\n\t\t\t\t\tif(move[i][j] == b1) {\n\t\t\t\t\t\tc = swap(b2,b1,c);\n\t\t\t\t\t\tqueue.add(new Data(a,b2,b1,c));\n\t\t\t\t\t\tc = swap(b2,b1,c);\n\t\t\t\t\t}\n\t\t\t\t\telse {\n\t\t\t\t\t\tc = swap(move[i][j],b2,c);\n\t\t\t\t\t\tqueue.add(new Data(a+1,b1,move[i][j],c));\n\t\t\t\t\t\tc = swap(move[i][j],b2,c);\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t}\n\t\n\tstatic void bfsb(int a, int b1,int b2, String c) {\n\t\tif(a > 10) return;\n\t\tif(!map2.containsKey(c)) {\n\t\t\tif(map.containsKey(c)) {\n\t\t\t\tmin = Math.min(min, a + map.get(c));\n\t\t\t}\n\t\t\tmap2.put(c, a);\n\t\t}\n\t\telse {\n\t\t\treturn;\n\t\t}\n\t\tfor(int i = 0; i < 13; i++) {\n\t\t\tif(b1 == i) {\n\t\t\t\tfor(int j = 0; j < move[i].length; j++) {\n\t\t\t\t\tif(move[i][j] == b2) {\n\t\t\t\t\t\tc = swap(b2,b1,c);\n\t\t\t\t\t\tqueue.add(new Data(a,b2,b1,c));\n\t\t\t\t\t\tc = swap(b2,b1,c);\n\t\t\t\t\t}\n\t\t\t\t\telse {\n\t\t\t\t\t\tc = swap(move[i][j],b1,c);\n\t\t\t\t\t\tqueue.add(new Data(a+1,move[i][j],b2,c));\n\t\t\t\t\t\tc = swap(move[i][j],b1,c);\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t}\n\t\t\tif(b2 == i) {\n\t\t\t\tfor(int j = 0; j < move[i].length; j++) {\n\t\t\t\t\tif(move[i][j] == b1) {\n\t\t\t\t\t\tc = swap(b2,b1,c);\n\t\t\t\t\t\tqueue.add(new Data(a,b2,b1,c));\n\t\t\t\t\t\tc = swap(b2,b1,c);\n\t\t\t\t\t}\n\t\t\t\t\telse {\n\t\t\t\t\t\tc = swap(move[i][j],b2,c);\n\t\t\t\t\t\tqueue.add(new Data(a+1,b1,move[i][j],c));\n\t\t\t\t\t\tc = swap(move[i][j],b2,c);\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t}\n\t\n\tstatic class Data {\n\t\tint a, b1, b2 ;\n\t\tString d;\n\t\tData(int a, int b, int c, String d) {\n\t\t\tthis.a = a;\n\t\t\tb1 = b;\n\t\t\tb2 = c;\n\t\t\tthis.d = d;\n\t\t}\n\t}\n\t\n\n}"
  },
  {
    "language": "Java",
    "code": "\nimport static java.util.Arrays.deepToString;\n\nimport java.util.ArrayDeque;\nimport java.util.HashSet;\nimport java.util.Queue;\nimport java.util.Scanner;\nimport java.util.Set;\n\npublic class Main {\n\tpublic static void main(String[] args) {\n\t\tnew Main().run();\n\t}\n\tvoid tr(Object... os) {\n\t\tSystem.err.println(deepToString(os));\n\t}\n\t\n\tScanner sc = new Scanner(System.in);\n\t\n\tchar[] goal = \"0123456789ab0\".toCharArray();\n\tint[] rs = {0, 1, 1, 1, 2, 2, 2, 2, 2, 3, 3, 3, 4};\n\tint[] cs = {2, 1, 2, 3, 0, 1, 2, 3, 4, 1, 2, 3, 2};\n\tint[] dr = {0, 1, 0, -1};\n\tint[] dc = {1, 0, -1, 0};\n\t\n\tint[][] rm = {\n\t\t{-1, -1, -1,-1, -1, -1, -1},\n\t\t{-1, -1, -1, 0, -1, -1, -1},\n\t\t{-1, -1,  1, 2,  3, -1, -1},\n\t\t{-1,  4,  5, 6,  7,  8, -1},\n\t\t{-1, -1,  9, 10, 11, -1, -1},\n\t\t{-1, -1, -1, 12, -1, -1, -1},\n\t\t{-1, -1, -1, -1, -1, -1, -1},\n\t};\n\t\n\tpublic void run() {\n\t\tfor (;sc.hasNext();) {\n\t\t\tchar[] s = new char[13];\n\t\t\tint x = sc.nextInt();\n\t\t\tif (x == -1) break;\n\t\t\ts[0] = toc(x);\n\t\t\tfor (int i = 1; i < 13; i++) {\n\t\t\t\ts[i] = toc(sc.nextInt());\n\t\t\t}\n\t\t\tSet<String> vis = new HashSet<String>();\n\t\t\tvis.add(new String(s));\n\t\t\tQueue<String> q1 = new ArrayDeque<String>();\n\t\t\tQueue<Integer> q2 = new ArrayDeque<Integer>();\n\t\t\tq1.add(new String(s));\n\t\t\tq2.add(0);\n\t\t\tint ans = -1;\n\t\t\twhile (q1.size() > 0) {\n\t\t\t\ts = q1.poll().toCharArray();\n\t\t\t\tint step = q2.poll();\n//\t\t\t\ttr(vis.size(), q1.size(), step);\n\t\t\t\tif (isGoal(s)) {\n\t\t\t\t\tans = step;\n\t\t\t\t\tbreak;\n\t\t\t\t}\n\t\t\t\t\n\t\t\t\t\n\t\t\t\tif (step < 20) {\n\t\t\t\t\tfor (int i = 0; i < s.length; i++) if (s[i] == '0') {\n\t\t\t\t\t\tfinal int zr = rs[i];\n\t\t\t\t\t\tfinal int zc = cs[i];\n\t\t\t\t\t\tfor (int k = 0; k < 4; k++) {\n\t\t\t\t\t\t\tint nr = zr + dr[k];\n\t\t\t\t\t\t\tint nc = zc + dc[k];\n\t\t\t\t\t\t\tint ni = rm[nr + 1][nc + 1];\n\t\t\t\t\t\t\tif (ni == -1) continue;\n\t\t\t\t\t\t\tswap(s, i, ni);\n\t\t\t\t\t\t\tString nxt = new String(s);\n\t\t\t\t\t\t\tif (!vis.contains(nxt)) {\n\t\t\t\t\t\t\t\tif (step + estimate(s) <= 20) {\n\t\t\t\t\t\t\t\t\tvis.add(nxt);\n\t\t\t\t\t\t\t\t\tq1.add(nxt);\n\t\t\t\t\t\t\t\t\tq2.add(step+1);\n\t\t\t\t\t\t\t\t}\n\t\t\t\t\t\t\t}\n\t\t\t\t\t\t\tswap(s, i, ni);\n\t\t\t\t\t\t}\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t}\n\t\t\t\n\t\t\tif (ans == -1) System.out.println(\"NA\"); else System.out.println(ans);\n\t\t}\n\t}\n\tint estimate(char[] s) {\n\t\tint sum = 0;\n\t\tfor (int i = 0; i < s.length; i++) if (s[i] != '0') {\n\t\t\tint n = getNum(s[i]);\n\t\t\tint d = Math.abs(rs[i] - rs[n]) + Math.abs(cs[i] - cs[n]);\n\t\t\tsum += d;\n\t\t}\n\t\treturn Math.max(0, sum - 2);\n\t}\n\tint getNum(char c) {\n\t\tif (c == 'a') return 10;\n\t\tif (c == 'b') return 11;\n\t\treturn c - '0';\n\t}\n\tvoid swap(char[] s, int i, int j) {\n\t\tchar t = s[i]; s[i] = s[j]; s[j] = t;\n\t}\n\tboolean isGoal(char[] s) {\n\t\tfor (int i = 0; i < s.length; i++) if (s[i] != goal[i]) return false;\n\t\treturn true;\n\t}\n\tchar toc(int x) {\n\t\treturn String.format(\"%x\", x).charAt(0);\n\t}\n}"
  },
  {
    "language": "Java",
    "code": "import java.util.*;\nimport java.util.regex.Pattern;\npublic class Main {\n\t\n\tArrayList<ArrayList<Integer>> swapList;\n\tint ans;\n\tHashMap<String,Integer> fromAns;\n\t\n\tclass C{\n\t\tint s;\n\t\tString now;\n\t\tpublic C(String now, int s){\n\t\t\tthis.now = now;\n\t\t\tthis.s = s;\n\t\t}\n\t}\n\t\n\tprivate void doit(){\n\t\tScanner sc = new Scanner(System.in);\n\t\t\n\t\t//swap pattern list\n\t\tcreateSwapList();\n\t\t\n\t\t//from ans\n\t\tString goal = \"0 1 2 3 4 5 6 7 8 9 10 11 0\";\n\t\tfromAns = new HashMap<String, Integer>();\n\t\tcreateStep(goal);\n\t\t\n\t\twhile(true){\n\t\t\t//input data\n\t\t\tint n = sc.nextInt();\n\t\t\tif(n == -1) break;\n\t\t\t//create start String\n\t\t\tStringBuilder sb  = new StringBuilder(\"\"+n);\n\t\t\tfor(int i=1; i <= 12; i++){\n\t\t\t\tsb.append(\" \");\n\t\t\t\tsb.append(sc.next());\n\t\t\t}\n\t\t\tString startS = sb.toString();\n\t\t\t\n\t\t\tif(fromAns.containsKey(startS)){\n\t\t\t\tSystem.out.println(fromAns.get(startS));\n\t\t\t\tcontinue;\n\t\t\t}\n\t\t\t\n\t\t\t//from start\n\t\t\tans = -1;\n\t\t\tcreateStep(startS);\n\t\t\t\n\t\t\t//comp and out\n\t\t\tif(ans > 20) {\n\t\t\t\tSystem.out.println(\"NA\");\n\t\t\t}\n\t\t\tif(ans != -1){\n\t\t\t\tSystem.out.println(ans);\n\t\t\t}\n\t\t\telse{\n\t\t\t\tSystem.out.println(\"NA\");\n\t\t\t}\n\t\t}\n//\t\tfor(String key: fromAns.keySet()){\n//\t\t\tif(fromAns.get(key) == 10){\n//\t\t\t\tSystem.out.println(key);\n//\t\t\t}\n//\t\t}\n\t}\n\t\n\tprivate int getInd0F(String [] s) {\n\t\tint len = s.length;\n\t\tfor(int i=0; i < len; i++){\n\t\t\tif(s[i].equals(\"0\")) return i;\n\t\t}\n\t\treturn -1;\n\t}\n\t\n\tprivate int getInd0L(String [] s) {\n\t\tint len = s.length;\n\t\tfor(int i=len-1; i >= 0; i--){\n\t\t\tif(s[i].equals(\"0\")) return i;\n\t\t}\n\t\treturn -1;\n\t}\n\t\n\tprivate String createS(String [] s){\n\t\tStringBuilder sb = new StringBuilder();\n\t\tfor(int i=0; i < s.length-1; i++){\n\t\t\tsb.append(s[i]);\n\t\t\tsb.append(\" \");\n\t\t}\n\t\tsb.append(s[s.length-1]);\n\t\treturn sb.toString();\n\t}\n\t\n\tprivate void createStep(String start){\n\t\t//init\n\t\tLinkedList<C> open = new LinkedList<C>();\n\t\topen.add(new C(start, 0));\n\t\tHashMap<String, Integer> close = new HashMap<String, Integer>();\n\t\tif(fromAns.containsKey(start)){\n\t\t\tans = fromAns.get(start);\n\t\t\treturn ;\n\t\t}\n\t\tclose.put(start, 0);\n\t\t\n\t\t//start\n\t\twhile(! open.isEmpty()){\n\t\t\tC now = open.removeFirst();\n\t\t\t\n\t\t\t//find a zero ind\n\t\t\tString [] nowParse = now.now.split(\" \");\n\t\t\tint ind01 = getInd0F(nowParse);\n\t\t\tint ind02 = getInd0L(nowParse);\n\t\t\tint [] ind0list = {ind01, ind02};\n\t\t\t\n\t\t\t//swap pattern times\n\t\t\tfor(int i = 0; i < ind0list.length;i++){\n\t\t\t\tint nowind = ind0list[i];\n\t\t\t\tfor(int j=0; j < swapList.get(nowind).size(); j++){\n\t\t\t\t\tint swapind = swapList.get(nowind).get(j);\n\t\t\t\t\tString [] work = now.now.split(\" \");\n\t\t\t\t\t\n\t\t\t\t\t//swap\n\t\t\t\t\tString temp = work[nowind];\n\t\t\t\t\twork[nowind] = work[swapind];\n\t\t\t\t\twork[swapind] = temp;\n\t\t\t\t\t\n\t\t\t\t\t//create new String \n\t\t\t\t\tString newS = createS(work);\n\t\t\t\t\t\n\t\t\t\t\t//close contains\n\t\t\t\t\tif(close.containsKey(newS)) continue;\n\t\t\t\t\t\n\t\t\t\t\t//find a goal\n\t\t\t\t\tint nextstep = now.s + 1;\n\t\t\t\t\tif(fromAns.containsKey(newS)){\n\t\t\t\t\t\tans = nextstep + fromAns.get(newS);\n\t\t\t\t\t\treturn ;\n\t\t\t\t\t}\n\t\t\t\t\t\n\t\t\t\t\t//open.add\n\t\t\t\t\tif(now.s != 10){\n\t\t\t\t\t\topen.add(new C(newS, nextstep));\n\t\t\t\t\t}\n\t\t\t\t\t\n\t\t\t\t\t//close.put\n\t\t\t\t\tclose.put(newS, nextstep);\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t\tfromAns = close;\n\t}\n\n\tprivate void createSwapList() {\n\t\tswapList = new ArrayList<ArrayList<Integer>>();\n\t\tfor(int i=0; i <= 12; i++){\n\t\t\tswapList.add(new ArrayList<Integer>());\n\t\t}\n\t\tfor(int i=0; i <= 12; i++){\n\t\t\t//bottom\n\t\t\tif(i == 1 || i == 2 || i == 3 || i == 5 || i == 6 || i == 7){\n\t\t\t\tswapList.get(i).add(i+4);\n\t\t\t\tswapList.get(i+4).add(i);\n\t\t\t}\n\t\t\tif(i == 0 || i == 10){\n\t\t\t\tswapList.get(i).add(i+2);\n\t\t\t\tswapList.get(i+2).add(i);\n\t\t\t}\n\t\t\t//right\n\t\t\tif(i == 1 || i == 2 || i == 4 || i == 5 || i == 6 || i == 7 || i == 9 || i == 10 ){\n\t\t\t\tswapList.get(i).add(i+1);\n\t\t\t\tswapList.get(i+1).add(i);\n\t\t\t}\n\t\t}\n\t}\n\n\tpublic static void main(String[] args) {\n\t\tMain obj = new Main();\n\t\tobj.doit();\n\t}\n}"
  },
  {
    "language": "Java",
    "code": "\nimport java.util.ArrayDeque;\nimport java.util.Deque;\nimport java.util.HashMap;\nimport java.util.HashSet;\nimport java.util.Map;\nimport java.util.Scanner;\nimport java.util.Set;\n\npublic class Main {\n\n\tpublic static void main(String[] args) {\n\t\tnew Main().run();\n\t}\n\n\tprivate void run() {\n\t\tScanner scanner = new Scanner(System.in);\n\t\tint[][] adj = { { 2 }, { 2, 5 }, { 0, 1, 3, 6 }, { 2, 7 }, { 5 },\n\t\t\t\t{ 1, 4, 6, 9 }, { 2, 5, 7, 10 }, { 3, 6, 8, 11 }, { 7 },\n\t\t\t\t{ 5, 10 }, { 6, 9, 11, 12 }, { 7, 10 }, { 10 } };\n\t\tString g = \"0ABCDEFGHIJK0\";\n\t\tMap<String, Integer> m = new HashMap<String, Integer>();\n\t\tDeque<String> deque = new ArrayDeque<String>();\n\t\tint step = 1;\n\t\tdeque.offer(g);\n\t\tm.put(g, 0);\n\t\twhile (!deque.isEmpty() && step < 11) {\n\t\t\tint size = deque.size();\n\t\t\tfor (int k = 0; k < size; k++) {\n\t\t\t\tString s = deque.pop();\n\t\t\t\tchar[] c = s.toCharArray();\n\t\t\t\tfor (int i = 0; i < 13; i++) {\n\t\t\t\t\tif (c[i] == '0') {\n\t\t\t\t\t\tfor (int j = 0; j < adj[i].length; j++) {\n\t\t\t\t\t\t\tc[i] = c[adj[i][j]];\n\t\t\t\t\t\t\tc[adj[i][j]] = '0';\n\t\t\t\t\t\t\tString n = String.valueOf(c);\n\t\t\t\t\t\t\tif (!m.containsKey(n)) {\n\t\t\t\t\t\t\t\tm.put(n, step);\n\t\t\t\t\t\t\t\tdeque.offer(n);\n\t\t\t\t\t\t\t}\n\t\t\t\t\t\t\tc[adj[i][j]] = c[i];\n\t\t\t\t\t\t\tc[i] = '0';\n\t\t\t\t\t\t}\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t}\n\t\t\tstep++;\n\t\t}\n\t\twhile (true) {\n\t\t\tint p = scanner.nextInt();\n\t\t\tif (p == -1)\n\t\t\t\tbreak;\n\t\t\tchar[] cc = new char[13];\n\t\t\tcc[0] = p == 0 ? '0' : (char) (p - 1 + 'A');\n\t\t\tfor (int i = 1; i < 13; i++) {\n\t\t\t\tp = scanner.nextInt();\n\t\t\t\tcc[i] = p == 0 ? '0' : (char) (p - 1 + 'A');\n\t\t\t}\n\t\t\tString st = String.valueOf(cc);\n\t\t\tSet<String> set = new HashSet<String>();\n\t\t\tset.add(st);\n\t\t\tdeque.clear();\n\t\t\tdeque.offer(st);\n\t\t\tstep = 0;\n\t\t\tboolean flag = false;\n\t\t\tString ans = \"\";\n\t\t\tloop: while (!deque.isEmpty() && step < 10) {\n\t\t\t\tint size = deque.size();\n\t\t\t\tfor (int w = 0; w < size; w++) {\n\t\t\t\t\tString s = deque.pop();\n\t\t\t\t\tif (m.containsKey(s)) {\n\t\t\t\t\t\tflag = true;\n\t\t\t\t\t\tans = s;\n\t\t\t\t\t\tbreak loop;\n\t\t\t\t\t}\n\t\t\t\t\tchar[] cs = s.toCharArray();\n\t\t\t\t\tfor (int i = 0; i < 13; i++) {\n\t\t\t\t\t\tif (cs[i] == '0') {\n\t\t\t\t\t\t\tfor (int j = 0; j < adj[i].length; j++) {\n\t\t\t\t\t\t\t\tcs[i] = cs[adj[i][j]];\n\t\t\t\t\t\t\t\tcs[adj[i][j]] = '0';\n\t\t\t\t\t\t\t\tString news = String.valueOf(cs);\n\t\t\t\t\t\t\t\tif (!set.contains(news)) {\n\t\t\t\t\t\t\t\t\tset.add(news);\n\t\t\t\t\t\t\t\t\tdeque.offer(news);\n\t\t\t\t\t\t\t\t}\n\t\t\t\t\t\t\t\tcs[adj[i][j]] = cs[i];\n\t\t\t\t\t\t\t\tcs[i] = '0';\n\t\t\t\t\t\t\t}\n\t\t\t\t\t\t}\n\t\t\t\t\t}\n\n\t\t\t\t}\n\t\t\t\tstep++;\n\t\t\t}\n\t\t\tSystem.out.println(flag ? m.get(ans) + step : \"NA\");\n\n\t\t}\n\t}\n}"
  },
  {
    "language": "Java",
    "code": "import java.util.ArrayDeque;\nimport java.util.Arrays;\nimport java.util.HashMap;\nimport java.util.Scanner;\n\npublic class Main {\n\tstatic HashMap<String,Integer> map = new HashMap<String,Integer>();\n\tstatic HashMap<String,Integer> map2 = new HashMap<String,Integer>();\n\tstatic int min = 21;\n\tstatic int[][] move = new int[][] {\n\t\t\t\t\t\t\t\t{2},\n\t\t\t\t\t   {2,5},{0,1,3,6},{2,7},\n\t\t\t   {5},{1,4,6,9},{2,5,7,10},{3,6,8,11},{7},\n\t\t\t          {5,10},{6,9,11,12},{7,10},\n\t\t\t          \t\t\t{10}\n\t\t\t          };\n \t\n\tpublic static void main(String[] args) {\n\t\tScanner sc = new Scanner(System.in);\n\t\tString first = \"0123456789AB0\";\n\t\tBfsa(0,0,12,first);\n\t\tIN:while(true) {\n\t\t\tmin = 21;\n\t\t\tchar[] data = new char[13];\n\t\t\tint xa = -1;\n\t\t\tint xb = -1;\n\t\t\tfor(int i = 0; i < 13; i++) {\n\t\t\t\tString tmp = sc.next();\n\t\t\t\tif(tmp.equals(\"-1\")) break IN;\n\t\t\t\tif(tmp.equals(\"10\")) tmp = \"A\";\n\t\t\t\tif(tmp.equals(\"11\")) tmp = \"B\";\n\t\t\t\tif(tmp.equals(\"0\")) {\n\t\t\t\t\tif(xa == -1) xa = i;\n\t\t\t\t\telse xb = i;\n\t\t\t\t}\n\t\t\t\tdata[i] = tmp.charAt(0);\n\t\t\t}\n\t\t\tif(map.containsKey(String.valueOf(data))) {\n\t\t\t\tmin = map.get(String.valueOf(data));\n\t\t\t}\n\t\t\tBfsb(0,xa,xb,String.valueOf(data));\n\t\t\tif(min <= 20) {\n\t\t\t\tSystem.out.println(min);\n\t\t\t}\n\t\t\telse {\n\t\t\t\tSystem.out.println(\"NA\");\n\t\t\t}\n\t\t\t\n\t\t}\n\t}\n\tstatic ArrayDeque<Data> queue = new ArrayDeque<Data>();\n\t\n\tstatic void Bfsa(int a, int b, int c,String d) {\n\t\tqueue.clear();\n\t\tqueue.add(new Data(a,b,c,d));\n\t\twhile(!queue.isEmpty()) {\n\t\t\tData ax = queue.poll();\n\t\t\tbfsa(ax.a,ax.b1,ax.b2,ax.d);\n\t\t}\n\t}\n\t\n\tstatic void Bfsb(int a, int b, int c,String d) {\n\t\tmap2.clear();\n\t\tqueue.clear();\n\t\tqueue.add(new Data(a,b,c,d));\n\t\twhile(!queue.isEmpty()) {\n\t\t\tData ax = queue.poll();\n\t\t\tbfsb(ax.a,ax.b1,ax.b2,ax.d);\n\t\t}\n\t}\n\t\n\t\n\tstatic String swap(int a, int b, String c) {\n\t\tchar[] x = c.toCharArray();\n\t\tchar tmp = x[a];\n\t\tx[a] = x[b];\n\t\tx[b] = tmp;\n\t\tString cx = String.valueOf(x);\n\t\treturn cx;\n\t}\n\tstatic void bfsa(int a, int b1,int b2, String c) {\n\t\tif(a > 10) return;\n\t\tif(!map.containsKey(c)) {\n\t\t\t\tmap.put(c, a);\n\t\t}\n\t\telse {\n\t\t\treturn;\n\t\t}\n\t\tfor(int i = 0; i < 13; i++) {\n\t\t\tif(b1 == i) {\n\t\t\t\tfor(int j = 0; j < move[i].length; j++) {\n\t\t\t\t\tif(move[i][j] == b2) {\n\t\t\t\t\t\tc = swap(b2,b1,c);\n\t\t\t\t\t\tqueue.add(new Data(a,b2,b1,c));\n\t\t\t\t\t\tc = swap(b2,b1,c);\n\t\t\t\t\t}\n\t\t\t\t\telse {\n\t\t\t\t\t\tc = swap(move[i][j],b1,c);\n\t\t\t\t\t\tqueue.add(new Data(a+1,move[i][j],b2,c));\n\t\t\t\t\t\tc = swap(move[i][j],b1,c);\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t}\n\t\t\tif(b2 == i) {\n\t\t\t\tfor(int j = 0; j < move[i].length; j++) {\n\t\t\t\t\tif(move[i][j] == b1) {\n\t\t\t\t\t\tc = swap(b2,b1,c);\n\t\t\t\t\t\tqueue.add(new Data(a,b2,b1,c));\n\t\t\t\t\t\tc = swap(b2,b1,c);\n\t\t\t\t\t}\n\t\t\t\t\telse {\n\t\t\t\t\t\tc = swap(move[i][j],b2,c);\n\t\t\t\t\t\tqueue.add(new Data(a+1,b1,move[i][j],c));\n\t\t\t\t\t\tc = swap(move[i][j],b2,c);\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t}\n\t\n\tstatic void bfsb(int a, int b1,int b2, String c) {\n\t\tif(a >= 10) return;\n\t\tif(!map2.containsKey(c)) {\n\t\t\tif(map.containsKey(c)) {\n\t\t\t\tmin = Math.min(min, a + map.get(c));\n\t\t\t}\n\t\t\tmap2.put(c, a);\n\t\t}\n\t\telse {\n\t\t\treturn;\n\t\t}\n\t\tfor(int i = 0; i < 13; i++) {\n\t\t\tif(b1 == i) {\n\t\t\t\tfor(int j = 0; j < move[i].length; j++) {\n\t\t\t\t\tif(move[i][j] == b2) {\n\t\t\t\t\t\tc = swap(b2,b1,c);\n\t\t\t\t\t\tqueue.add(new Data(a,b2,b1,c));\n\t\t\t\t\t\tc = swap(b2,b1,c);\n\t\t\t\t\t}\n\t\t\t\t\telse {\n\t\t\t\t\t\tc = swap(move[i][j],b1,c);\n\t\t\t\t\t\tqueue.add(new Data(a+1,move[i][j],b2,c));\n\t\t\t\t\t\tc = swap(move[i][j],b1,c);\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t}\n\t\t\tif(b2 == i) {\n\t\t\t\tfor(int j = 0; j < move[i].length; j++) {\n\t\t\t\t\tif(move[i][j] == b1) {\n\t\t\t\t\t\tc = swap(b2,b1,c);\n\t\t\t\t\t\tqueue.add(new Data(a,b2,b1,c));\n\t\t\t\t\t\tc = swap(b2,b1,c);\n\t\t\t\t\t}\n\t\t\t\t\telse {\n\t\t\t\t\t\tc = swap(move[i][j],b2,c);\n\t\t\t\t\t\tqueue.add(new Data(a+1,b1,move[i][j],c));\n\t\t\t\t\t\tc = swap(move[i][j],b2,c);\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t}\n\t\n\tstatic class Data {\n\t\tint a, b1, b2 ;\n\t\tString d;\n\t\tData(int a, int b, int c, String d) {\n\t\t\tthis.a = a;\n\t\t\tb1 = b;\n\t\t\tb2 = c;\n\t\t\tthis.d = d;\n\t\t}\n\t}\n\t\n\n}"
  },
  {
    "language": "Java",
    "code": "import java.util.*;\npublic class Main {\n\tint [][] start;\n\tfinal int [] xdir = {0,1,0,-1};\n\tfinal int [] ydir = {1,0,-1,0};\n\n\tpublic class C {\n\t\tint deep;\n\t\tStringBuilder data;\n\t\tpublic C(int deep, String data) {\n\t\t\tthis.deep = deep;\n\t\t\tthis.data = new StringBuilder(data);\n\t\t}\n\t}\n\n\tprivate int[] getIndex(int ind){\n\t\tfor(int i=0; i < 7; i++){\n\t\t\tfor(int j=0; j < 7; j++){\n\t\t\t\tif(start[i][j] == ind){\n\t\t\t\t\tint [] ans = {j,i};\n\t\t\t\t\treturn ans;\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t\treturn null;\n\t}\n\n\tpublic void doIt(){\n\t\tScanner sc = new Scanner(System.in);\n\t\tLinkedList<C> open = new LinkedList<C>();\n\t\tHashMap<String,Integer> close = new HashMap<String, Integer>();\n\t\tstart = new int[7][7];\n\t\tfor(int i=0; i < 7; i++){\n\t\t\tArrays.fill(start[i], -1);\n\t\t}\n\t\tstart[1][3] = 0;\n\t\tstart[2][2] = 1;\n\t\tstart[2][3] = 2;\n\t\tstart[2][4] = 3;\n\t\tstart[3][1] = 4;\n\t\tstart[3][2] = 5;\n\t\tstart[3][3] = 6;\n\t\tstart[3][4] = 7;\n\t\tstart[3][5] = 8;\n\t\tstart[4][2] = 9;\n\t\tstart[4][3] = 10;\n\t\tstart[4][4] = 11;\n\t\tstart[5][3] = 12;\n\t\topen.addLast(new C(0,\"0123456789ab0\"));\n\t\tclose.put(\"0123456789ab0\", 0);\n\n\t\twhile(! open.isEmpty()){\n\t\t\tC pat = open.remove();\n\t\t\tStringBuilder patStr = pat.data;\n\t\t\tint patDeep = pat.deep;\n\t\t\tint lastInd = 0;\n\t\t\tif(patDeep >= 10){\n\t\t\t\topen.clear();\n\t\t\t\tbreak;\n\t\t\t}\n\n\t\t\tfor(int i=0; i < 2; i++){\n\t\t\t\tint ind = patStr.indexOf(\"0\", lastInd);\n\t\t\t\tint [] result = getIndex(ind);\n\t\t\t\tint x = result[0];\n\t\t\t\tint y = result[1];\n\n\t\t\t\tfor(int j=0; j < 4; j++){\n\t\t\t\t\tint patX = x + xdir[j];\n\t\t\t\t\tint patY = y + ydir[j];\n\t\t\t\t\tif(start[patY][patX] >= 0){\n\t\t\t\t\t\tStringBuilder newStr = new StringBuilder(patStr.toString());\n\t\t\t\t\t\tchar change = newStr.charAt(start[patY][patX]);\n\t\t\t\t\t\tnewStr.setCharAt(ind, change);\n\t\t\t\t\t\tnewStr.setCharAt(start[patY][patX], '0');\n\t\t\t\t\t\tString temp = newStr.toString();\n\n\t\t\t\t\t\tif((! close.containsKey(temp))){\n\t\t\t\t\t\t\topen.addLast(new C(patDeep + 1, temp));\n\t\t\t\t\t\t\tclose.put(temp, patDeep+1);\n\t\t\t\t\t\t}\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t\tlastInd = ind + 1;\n\t\t\t}\n\t\t}\n\n\t\twhile(true){\n\t\t\tint n = sc.nextInt();\n\t\t\tif(n == -1){\n\t\t\t\tbreak;\n\t\t\t}\n\t\t\tStringBuilder input = new StringBuilder();\n\t\t\tif(n == 10){\n\t\t\t\tinput.append('a');\n\t\t\t}\n\t\t\telse if(n == 11){\n\t\t\t\tinput.append('b');\n\t\t\t}\n\t\t\telse{\n\t\t\t\tinput.append(\"\" + n);\n\t\t\t}\n\n\t\t\tfor(int i=0; i < 12; i++){\n\t\t\t\tn = sc.nextInt();\n\t\t\t\tif(n == 10){\n\t\t\t\t\tinput.append('a');\n\t\t\t\t}\n\t\t\t\telse if(n == 11){\n\t\t\t\t\tinput.append('b');\n\t\t\t\t}\n\t\t\t\telse{\n\t\t\t\t\tinput.append(\"\" + n);\n\t\t\t\t}\n\t\t\t}\n\t\t\tString inputStr = input.toString();\n\n\t\t\tif(close.containsKey(inputStr)){\n\t\t\t\tSystem.out.println(close.get(inputStr));\n\t\t\t}\n\t\t\telse{\n\t\t\t\topen.addLast(new C(0,inputStr));\n\t\t\t\tHashMap<String,Integer> anotherclose = new HashMap<String, Integer>();\n\t\t\t\tanotherclose.put(inputStr, 0);\n\t\t\t\twhile(! open.isEmpty()){\n\t\t\t\t\tC pat = open.remove();\n\t\t\t\t\tStringBuilder patStr = pat.data;\n\t\t\t\t\tint patDeep = pat.deep;\n\t\t\t\t\tint lastInd = 0;\n\n\t\t\t\t\tif((close.containsKey(patStr.toString()))){\n\t\t\t\t\t\tSystem.out.println(patDeep + close.get(patStr.toString()));\n\t\t\t\t\t\tbreak;\n\t\t\t\t\t}\n\n\t\t\t\t\tif(patDeep >= 11){\n\t\t\t\t\t\tSystem.out.println(\"NA\");\n\t\t\t\t\t\tbreak;\n\t\t\t\t\t}\n\n\t\t\t\t\tfor(int i=0; i < 2; i++){\n\t\t\t\t\t\tint ind = patStr.indexOf(\"0\", lastInd);\n\t\t\t\t\t\tint [] result = getIndex(ind);\n\t\t\t\t\t\tint x = result[0];\n\t\t\t\t\t\tint y = result[1];\n\n\t\t\t\t\t\tfor(int j=0; j < 4; j++){\n\t\t\t\t\t\t\tint patX = x + xdir[j];\n\t\t\t\t\t\t\tint patY = y + ydir[j];\n\t\t\t\t\t\t\tif(start[patY][patX] >= 0){\n\t\t\t\t\t\t\t\tStringBuilder newStr = new StringBuilder(patStr.toString());\n\t\t\t\t\t\t\t\tchar change = newStr.charAt(start[patY][patX]);\n\t\t\t\t\t\t\t\tnewStr.setCharAt(ind, change);\n\t\t\t\t\t\t\t\tnewStr.setCharAt(start[patY][patX], '0');\n\t\t\t\t\t\t\t\tString temp = newStr.toString();\n\n\t\t\t\t\t\t\t\tif((! anotherclose.containsKey(temp))){\n\t\t\t\t\t\t\t\t\topen.addLast(new C(patDeep + 1, temp));\n\t\t\t\t\t\t\t\t\tanotherclose.put(temp, patDeep+1);\n\t\t\t\t\t\t\t\t}\n\t\t\t\t\t\t\t}\n\t\t\t\t\t\t}\n\t\t\t\t\t\tlastInd = ind + 1;\n\t\t\t\t\t}\n\t\t\t\t}\n\n\t\t\t}\n\t\t}\n\n\t}\n\tpublic static void main(String[] args) {\n\t\tMain obj = new Main();\n\t\tobj.doIt();\n\t}\n}"
  },
  {
    "language": "Java",
    "code": "import java.util.*;\nimport java.util.regex.Pattern;\npublic class Main {\n\t\n\tArrayList<ArrayList<Integer>> swapList;\n\tint ans;\n\tHashMap<String,Integer> fromAns;\n\t\n\tclass C{\n\t\tint s;\n\t\tString now;\n\t\tpublic C(String now, int s){\n\t\t\tthis.now = now;\n\t\t\tthis.s = s;\n\t\t}\n\t}\n\t\n\tprivate void doit(){\n\t\tScanner sc = new Scanner(System.in);\n\t\t\n\t\t//swap pattern list\n\t\tcreateSwapList();\n\t\t\n\t\t//from ans\n\t\tString goal = \"0 1 2 3 4 5 6 7 8 9 10 11 0\";\n\t\tfromAns = new HashMap<String, Integer>();\n\t\tcreateStep(goal);\n\t\t\n\t\twhile(true){\n\t\t\t//input data\n\t\t\tint n = sc.nextInt();\n\t\t\tif(n == -1) break;\n\t\t\t//create start String\n\t\t\tStringBuilder sb  = new StringBuilder(\"\"+n);\n\t\t\tfor(int i=1; i <= 12; i++){\n\t\t\t\tsb.append(\" \");\n\t\t\t\tsb.append(sc.next());\n\t\t\t}\n\t\t\tString startS = sb.toString();\n\t\t\t\n\t\t\tif(fromAns.containsKey(startS)){\n\t\t\t\tSystem.out.println(fromAns.get(startS));\n\t\t\t\tcontinue;\n\t\t\t}\n\t\t\t\n\t\t\t//from start\n\t\t\tans = -1;\n\t\t\tcreateStep(startS);\n\t\t\t\n\t\t\t//comp and out\n\t\t\tif(ans != -1){\n\t\t\t\tSystem.out.println(ans);\n\t\t\t}\n\t\t\telse{\n\t\t\t\tSystem.out.println(\"NA\");\n\t\t\t}\n\t\t}\n//\t\tfor(String key: fromAns.keySet()){\n//\t\t\tif(fromAns.get(key) == 10){\n//\t\t\t\tSystem.out.println(key);\n//\t\t\t}\n//\t\t}\n\t}\n\t\n\tprivate int getInd0F(String [] s) {\n\t\tint len = s.length;\n\t\tfor(int i=0; i < len; i++){\n\t\t\tif(s[i].equals(\"0\")) return i;\n\t\t}\n\t\treturn -1;\n\t}\n\t\n\tprivate int getInd0L(String [] s) {\n\t\tint len = s.length;\n\t\tfor(int i=len-1; i >= 0; i--){\n\t\t\tif(s[i].equals(\"0\")) return i;\n\t\t}\n\t\treturn -1;\n\t}\n\t\n\tprivate String createS(String [] s){\n\t\tStringBuilder sb = new StringBuilder();\n\t\tfor(int i=0; i < s.length-1; i++){\n\t\t\tsb.append(s[i]);\n\t\t\tsb.append(\" \");\n\t\t}\n\t\tsb.append(s[s.length-1]);\n\t\treturn sb.toString();\n\t}\n\t\n\tprivate void createStep(String start){\n\t\t//init\n\t\tLinkedList<C> open = new LinkedList<C>();\n\t\topen.add(new C(start, 0));\n\t\tHashMap<String, Integer> close = new HashMap<String, Integer>();\n\t\tif(fromAns.containsKey(start)){\n\t\t\tans = fromAns.get(start);\n\t\t\treturn ;\n\t\t}\n\t\tclose.put(start, 0);\n\t\t\n\t\t//start\n\t\twhile(! open.isEmpty()){\n\t\t\tC now = open.removeFirst();\n\t\t\t\n\t\t\t//find a zero ind\n\t\t\tString [] nowParse = now.now.split(\" \");\n\t\t\tint ind01 = getInd0F(nowParse);\n\t\t\tint ind02 = getInd0L(nowParse);\n\t\t\tint [] ind0list = {ind01, ind02};\n\t\t\t\n\t\t\t//swap pattern times\n\t\t\tfor(int i = 0; i < ind0list.length;i++){\n\t\t\t\tint nowind = ind0list[i];\n\t\t\t\tfor(int j=0; j < swapList.get(nowind).size(); j++){\n\t\t\t\t\tint swapind = swapList.get(nowind).get(j);\n\t\t\t\t\tString [] work = now.now.split(\" \");\n\t\t\t\t\t\n\t\t\t\t\t//swap\n\t\t\t\t\tString temp = work[nowind];\n\t\t\t\t\twork[nowind] = work[swapind];\n\t\t\t\t\twork[swapind] = temp;\n\t\t\t\t\t\n\t\t\t\t\t//create new String \n\t\t\t\t\tString newS = createS(work);\n\t\t\t\t\t\n\t\t\t\t\t//close contains\n\t\t\t\t\tif(close.containsKey(newS)) continue;\n\t\t\t\t\t\n\t\t\t\t\t//find a goal\n\t\t\t\t\tint nextstep = now.s + 1;\n\t\t\t\t\tif(fromAns.containsKey(newS)){\n\t\t\t\t\t\tans = nextstep + fromAns.get(newS);\n\t\t\t\t\t\treturn ;\n\t\t\t\t\t}\n\t\t\t\t\t\n\t\t\t\t\t//open.add\n\t\t\t\t\tif(now.s != 10){\n\t\t\t\t\t\topen.add(new C(newS, nextstep));\n\t\t\t\t\t}\n\t\t\t\t\t\n\t\t\t\t\t//close.put\n\t\t\t\t\tclose.put(newS, nextstep);\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t\tfromAns = close;\n\t}\n\n\tprivate void createSwapList() {\n\t\tswapList = new ArrayList<ArrayList<Integer>>();\n\t\tfor(int i=0; i <= 12; i++){\n\t\t\tswapList.add(new ArrayList<Integer>());\n\t\t}\n\t\tfor(int i=0; i <= 12; i++){\n\t\t\t//bottom\n\t\t\tif(i == 1 || i == 2 || i == 3 || i == 5 || i == 6 || i == 7){\n\t\t\t\tswapList.get(i).add(i+4);\n\t\t\t\tswapList.get(i+4).add(i);\n\t\t\t}\n\t\t\tif(i == 0 || i == 10){\n\t\t\t\tswapList.get(i).add(i+2);\n\t\t\t\tswapList.get(i+2).add(i);\n\t\t\t}\n\t\t\t//right\n\t\t\tif(i == 1 || i == 2 || i == 4 || i == 5 || i == 6 || i == 7 || i == 9 || i == 10 ){\n\t\t\t\tswapList.get(i).add(i+1);\n\t\t\t\tswapList.get(i+1).add(i);\n\t\t\t}\n\t\t}\n\t}\n\n\tpublic static void main(String[] args) {\n\t\tMain obj = new Main();\n\t\tobj.doit();\n\t}\n}"
  },
  {
    "language": "Java",
    "code": "\nimport java.util.ArrayDeque;\nimport java.util.Deque;\nimport java.util.HashMap;\nimport java.util.HashSet;\nimport java.util.Map;\nimport java.util.Scanner;\nimport java.util.Set;\n\npublic class Main {\n\n\tpublic static void main(String[] args) {\n\t\tnew Main().run();\n\t}\n\n\tprivate void run() {\n\t\tScanner scanner = new Scanner(System.in);\n\t\tint[][] adj = { { 2 }, { 2, 5 }, { 0, 1, 3, 6 }, { 2, 7 }, { 5 },\n\t\t\t\t{ 1, 4, 6, 9 }, { 2, 5, 7, 10 }, { 3, 6, 8, 11 }, { 7 },\n\t\t\t\t{ 5, 10 }, { 6, 9, 11, 12 }, { 7, 10 }, { 10 } };\n\t\tString g = \"0ABCDEFGHIJK0\";\n\t\tMap<String, Integer> m = new HashMap<String, Integer>();\n\t\tDeque<String> deque = new ArrayDeque<String>();\n\t\tint step = 1;\n\t\tdeque.offer(g);\n\t\tm.put(g, 0);\n\t\twhile (!deque.isEmpty() && step < 10) {\n\t\t\tint size = deque.size();\n\t\t\tfor (int k = 0; k < size; k++) {\n\t\t\t\tString s = deque.pop();\n\t\t\t\tchar[] c = s.toCharArray();\n\t\t\t\tfor (int i = 0; i < 13; i++) {\n\t\t\t\t\tif (c[i] == '0') {\n\t\t\t\t\t\tfor (int j = 0; j < adj[i].length; j++) {\n\t\t\t\t\t\t\tc[i] = c[adj[i][j]];\n\t\t\t\t\t\t\tc[adj[i][j]] = '0';\n\t\t\t\t\t\t\tString n = String.valueOf(c);\n\t\t\t\t\t\t\tif (!m.containsKey(n)) {\n\t\t\t\t\t\t\t\tm.put(n, step);\n\t\t\t\t\t\t\t\tdeque.offer(n);\n\t\t\t\t\t\t\t}\n\t\t\t\t\t\t\tc[adj[i][j]] = c[i];\n\t\t\t\t\t\t\tc[i] = '0';\n\t\t\t\t\t\t}\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t}\n\t\t\tstep++;\n\t\t}\n\t\twhile (true) {\n\t\t\tint p = scanner.nextInt();\n\t\t\tif (p == -1)\n\t\t\t\tbreak;\n\t\t\tchar[] cc = new char[13];\n\t\t\tcc[0] = p == 0 ? '0' : (char) (p - 1 + 'A');\n\t\t\tfor (int i = 1; i < 13; i++) {\n\t\t\t\tp = scanner.nextInt();\n\t\t\t\tcc[i] = p == 0 ? '0' : (char) (p - 1 + 'A');\n\t\t\t}\n\t\t\tString st = String.valueOf(cc);\n\t\t\tSet<String> set = new HashSet<String>();\n\t\t\tdeque.clear();\n\t\t\tdeque.offer(st);\n\t\t\tstep = 0;\n\t\t\tboolean flag = false;\n\t\t\tString ans = \"\";\n\t\t\tloop: while (!deque.isEmpty() && step < 10) {\n\t\t\t\tint size = deque.size();\n\t\t\t\tfor (int w = 0; w < size; w++) {\n\t\t\t\t\tString s = deque.pop();\n\t\t\t\t\tif (m.containsKey(s)) {\n\t\t\t\t\t\tflag = true;\n\t\t\t\t\t\tans = s;\n\t\t\t\t\t\tbreak loop;\n\t\t\t\t\t}\n\t\t\t\t\tchar[] cs = s.toCharArray();\n\t\t\t\t\tfor (int i = 0; i < 13; i++) {\n\t\t\t\t\t\tif (cs[i] == '0') {\n\t\t\t\t\t\t\tfor (int j = 0; j < adj[i].length; j++) {\n\t\t\t\t\t\t\t\tcs[i] = cs[adj[i][j]];\n\t\t\t\t\t\t\t\tcs[adj[i][j]] = '0';\n\t\t\t\t\t\t\t\tString news = String.valueOf(cs);\n\t\t\t\t\t\t\t\tif (!set.contains(news)) {\n\t\t\t\t\t\t\t\t\tset.add(news);\n\t\t\t\t\t\t\t\t\tdeque.offer(news);\n\t\t\t\t\t\t\t\t}\n\t\t\t\t\t\t\t\tcs[adj[i][j]] = cs[i];\n\t\t\t\t\t\t\t\tcs[i] = '0';\n\t\t\t\t\t\t\t}\n\t\t\t\t\t\t}\n\t\t\t\t\t}\n\n\t\t\t\t}\n\t\t\t\tstep++;\n\t\t\t}\n\t\t\tSystem.out.println(flag ? m.get(ans) : \"NA\");\n\n\t\t}\n\t}\n}"
  },
  {
    "language": "Java",
    "code": "\nimport java.util.ArrayDeque;\nimport java.util.Deque;\nimport java.util.HashMap;\nimport java.util.HashSet;\nimport java.util.Map;\nimport java.util.Scanner;\nimport java.util.Set;\n\npublic class Main {\n\n\tpublic static void main(String[] args) {\n\t\tnew Main().run();\n\t}\n\n\tprivate void run() {\n\t\tScanner scanner = new Scanner(System.in);\n\t\tint[][] map = { { 2 }, { 2, 5 }, { 0, 1, 3, 6 }, { 2, 7 }, { 5 },\n\t\t\t\t{ 1, 4, 6, 9 }, { 2, 5, 7, 10 }, { 3, 6, 8, 11 }, { 7 },\n\t\t\t\t{ 5, 10 }, { 2, 5, 7, 10 }, { 7, 10 }, { 10 } };\n\t\tString reslt = \"0ABCDEFGHIJK0\";\n\t\tMap<String, Integer> memo = new HashMap<String, Integer>();\n\t\tmemo.put(reslt, 0);\n\t\tint step = 1;\n\t\tDeque<String> deque = new ArrayDeque<String>();\n\t\tdeque.offer(reslt);\n\t\twhile (step <= 10) {\n\t\t\tint size = deque.size();\n\t\t\twhile (size-- > 0) {\n\t\t\t\tchar[] chs = deque.pop().toCharArray();\n\t\t\t\tfor (int i = 0; i < 13; i++) {\n\t\t\t\t\tif (chs[i] == '0') {\n\t\t\t\t\t\tfor (int j : map[i]) {\n\t\t\t\t\t\t\tchs[i] = chs[j];\n\t\t\t\t\t\t\tchs[j] = '0';\n\t\t\t\t\t\t\tString tmp = String.valueOf(chs);\n\t\t\t\t\t\t\tif (!memo.containsKey(tmp)) {\n\t\t\t\t\t\t\t\tmemo.put(tmp, step);\n\t\t\t\t\t\t\t\tdeque.offer(tmp);\n\t\t\t\t\t\t\t}\n\t\t\t\t\t\t\tchs[j] = chs[i];\n\t\t\t\t\t\t\tchs[i] = '0';\n\t\t\t\t\t\t}\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t}\n\t\t\tstep++;\n\t\t}\n\t\twhile (true) {\n\t\t\tint n = scanner.nextInt();\n\t\t\tif (n == -1)\n\t\t\t\tbreak;\n\t\t\tchar[] cs = new char[13];\n\t\t\tcs[0] = n == 0 ? '0' : (char) (n - 1 + 'A');\n\t\t\tfor (int i = 1; i < 13; i++) {\n\t\t\t\tint c = scanner.nextInt();\n\t\t\t\tcs[i] = c == 0 ? '0' : (char) (c - 1 + 'A');\n\t\t\t}\n\t\t\tstep = 0;\n\t\t\tdeque.clear();\n\t\t\tString s = String.valueOf(cs);\n\t\t\tdeque.offer(s);\n\t\t\tSet<String> set = new HashSet<String>();\n\t\t\tset.add(s);\n\t\t\tString ret = \"NA\";\n\t\t\tloop: while (step <= 10) {\n\t\t\t\tint size = deque.size();\n\t\t\t\twhile (size-- > 0) {\n\t\t\t\t\tString str = deque.pop();\n\t\t\t\t\tif (memo.containsKey(str)) {\n\t\t\t\t\t\tret = String.valueOf(memo.get(str) + step);\n\t\t\t\t\t\tbreak loop;\n\t\t\t\t\t}\n\t\t\t\t\tchar[] chs = str.toCharArray();\n\t\t\t\t\tfor (int i = 0; i < 13; i++) {\n\t\t\t\t\t\tif (chs[i] == '0') {\n\t\t\t\t\t\t\tfor (int j : map[i]) {\n\t\t\t\t\t\t\t\tchs[i] = chs[j];\n\t\t\t\t\t\t\t\tchs[j] = '0';\n\t\t\t\t\t\t\t\tString tmp = String.valueOf(chs);\n\t\t\t\t\t\t\t\tif (!set.contains(tmp)) {\n\t\t\t\t\t\t\t\t\tset.add(tmp);\n\t\t\t\t\t\t\t\t\tdeque.offer(tmp);\n\t\t\t\t\t\t\t\t}\n\t\t\t\t\t\t\t\tchs[j] = chs[i];\n\t\t\t\t\t\t\t\tchs[i] = '0';\n\t\t\t\t\t\t\t}\n\t\t\t\t\t\t}\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t\tstep++;\n\t\t\t}\n\t\t\tSystem.out.println(ret);\n\t\t}\n\n\t}\n}"
  },
  {
    "language": "Java",
    "code": "import java.util.*;\nimport java.util.regex.Pattern;\npublic class Main {\n\t\n\tArrayList<ArrayList<Integer>> swapList;\n\tint ans;\n\tHashMap<String,Integer> fromAns;\n\t\n\tclass C{\n\t\tint s;\n\t\tString now;\n\t\tpublic C(String now, int s){\n\t\t\tthis.now = now;\n\t\t\tthis.s = s;\n\t\t}\n\t}\n\t\n\tprivate void doit(){\n\t\tScanner sc = new Scanner(System.in);\n\t\t\n\t\t//swap pattern list\n\t\tcreateSwapList();\n\t\t\n\t\t//from ans\n\t\tString goal = \"0 1 2 3 4 5 6 7 8 9 10 11 0\";\n\t\tfromAns = new HashMap<String, Integer>();\n\t\tcreateStep(goal,0);\n\t\t\n\t\twhile(true){\n\t\t\t//input data\n\t\t\tint n = sc.nextInt();\n\t\t\tif(n == -1) break;\n\t\t\t//create start String\n\t\t\tStringBuilder sb  = new StringBuilder(\"\"+n);\n\t\t\tfor(int i=1; i <= 12; i++){\n\t\t\t\tsb.append(\" \");\n\t\t\t\tsb.append(sc.next());\n\t\t\t}\n\t\t\tString startS = sb.toString();\n\t\t\t\n\t\t\tif(fromAns.containsKey(startS)){\n\t\t\t\tSystem.out.println(fromAns.get(startS));\n\t\t\t\tcontinue;\n\t\t\t}\n\t\t\t\n\t\t\t//from start\n\t\t\tans = -1;\n\t\t\tcreateStep(startS,1);\n\t\t\t\n\t\t\t//comp and out\n\t\t\tif(ans > 20) {\n\t\t\t\tSystem.out.println(\"NA\");\n\t\t\t}\n\t\t\tif(ans != -1){\n\t\t\t\tSystem.out.println(ans);\n\t\t\t}\n\t\t\telse{\n\t\t\t\tSystem.out.println(\"NA\");\n\t\t\t}\n\t\t}\n//\t\tfor(String key: fromAns.keySet()){\n//\t\t\tif(fromAns.get(key) == 10){\n//\t\t\t\tSystem.out.println(key);\n//\t\t\t}\n//\t\t}\n\t}\n\t\n\tprivate int getInd0F(String [] s) {\n\t\tint len = s.length;\n\t\tfor(int i=0; i < len; i++){\n\t\t\tif(s[i].equals(\"0\")) return i;\n\t\t}\n\t\treturn -1;\n\t}\n\t\n\tprivate int getInd0L(String [] s) {\n\t\tint len = s.length;\n\t\tfor(int i=len-1; i >= 0; i--){\n\t\t\tif(s[i].equals(\"0\")) return i;\n\t\t}\n\t\treturn -1;\n\t}\n\t\n\tprivate String createS(String [] s){\n\t\tStringBuilder sb = new StringBuilder();\n\t\tfor(int i=0; i < s.length-1; i++){\n\t\t\tsb.append(s[i]);\n\t\t\tsb.append(\" \");\n\t\t}\n\t\tsb.append(s[s.length-1]);\n\t\treturn sb.toString();\n\t}\n\t\n\tprivate void createStep(String start, int state){\n\t\t//init\n\t\tLinkedList<C> open = new LinkedList<C>();\n\t\topen.add(new C(start, 0));\n\t\tHashMap<String, Integer> close = new HashMap<String, Integer>();\n\t\tif(fromAns.containsKey(start)){\n\t\t\tans = fromAns.get(start);\n\t\t\treturn ;\n\t\t}\n\t\tclose.put(start, 0);\n\t\t\n\t\t//start\n\t\twhile(! open.isEmpty()){\n\t\t\tC now = open.removeFirst();\n\t\t\t\n\t\t\t//find a zero ind\n\t\t\tString [] nowParse = now.now.split(\" \");\n\t\t\tint ind01 = getInd0F(nowParse);\n\t\t\tint ind02 = getInd0L(nowParse);\n\t\t\tint [] ind0list = {ind01, ind02};\n\t\t\t\n\t\t\t//swap pattern times\n\t\t\tfor(int i = 0; i < ind0list.length;i++){\n\t\t\t\tint nowind = ind0list[i];\n\t\t\t\tfor(int j=0; j < swapList.get(nowind).size(); j++){\n\t\t\t\t\tint swapind = swapList.get(nowind).get(j);\n\t\t\t\t\tString [] work = now.now.split(\" \");\n\t\t\t\t\t\n\t\t\t\t\t//swap\n\t\t\t\t\tString temp = work[nowind];\n\t\t\t\t\twork[nowind] = work[swapind];\n\t\t\t\t\twork[swapind] = temp;\n\t\t\t\t\t\n\t\t\t\t\t//create new String \n\t\t\t\t\tString newS = createS(work);\n\t\t\t\t\t\n\t\t\t\t\t//close contains\n\t\t\t\t\tif(close.containsKey(newS)) continue;\n\t\t\t\t\t\n\t\t\t\t\t//find a goal\n\t\t\t\t\tint nextstep = now.s + 1;\n\t\t\t\t\tif(fromAns.containsKey(newS)){\n\t\t\t\t\t\tans = nextstep + fromAns.get(newS);\n\t\t\t\t\t\treturn ;\n\t\t\t\t\t}\n\t\t\t\t\t\n\t\t\t\t\t//open.add\n\t\t\t\t\tif(now.s != 10){\n\t\t\t\t\t\topen.add(new C(newS, nextstep));\n\t\t\t\t\t}\n\t\t\t\t\t\n\t\t\t\t\t//close.put\n\t\t\t\t\tclose.put(newS, nextstep);\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t\tif(state == 0){\n\t\t\tfromAns = close;\n\t\t}\n\t}\n\n\tprivate void createSwapList() {\n\t\tswapList = new ArrayList<ArrayList<Integer>>();\n\t\tfor(int i=0; i <= 12; i++){\n\t\t\tswapList.add(new ArrayList<Integer>());\n\t\t}\n\t\tfor(int i=0; i <= 12; i++){\n\t\t\t//bottom\n\t\t\tif(i == 1 || i == 2 || i == 3 || i == 5 || i == 6 || i == 7){\n\t\t\t\tswapList.get(i).add(i+4);\n\t\t\t\tswapList.get(i+4).add(i);\n\t\t\t}\n\t\t\tif(i == 0 || i == 10){\n\t\t\t\tswapList.get(i).add(i+2);\n\t\t\t\tswapList.get(i+2).add(i);\n\t\t\t}\n\t\t\t//right\n\t\t\tif(i == 1 || i == 2 || i == 4 || i == 5 || i == 6 || i == 7 || i == 9 || i == 10 ){\n\t\t\t\tswapList.get(i).add(i+1);\n\t\t\t\tswapList.get(i+1).add(i);\n\t\t\t}\n\t\t}\n\t}\n\n\tpublic static void main(String[] args) {\n\t\tMain obj = new Main();\n\t\tobj.doit();\n\t}\n}"
  },
  {
    "language": "Java",
    "code": "\nimport java.util.ArrayDeque;\nimport java.util.Deque;\nimport java.util.HashMap;\nimport java.util.HashSet;\nimport java.util.Map;\nimport java.util.Scanner;\nimport java.util.Set;\n\npublic class Main {\n\n\tpublic static void main(String[] args) {\n\t\tnew Main().run();\n\t}\n\n\tprivate void run() {\n\t\tScanner scanner = new Scanner(System.in);\n\t\tint[][] adj = { { 2 }, { 2, 5 }, { 0, 1, 3, 6 }, { 2, 7 }, { 5 },\n\t\t\t\t{ 1, 4, 6, 9 }, { 2, 5, 7, 10 }, { 3, 6, 8, 11 }, { 7 },\n\t\t\t\t{ 5, 10 }, { 6, 9, 11, 12 }, { 7, 10 }, { 10 } };\n\t\tString g = \"0ABCDEFGHIJK0\";\n\t\tMap<String, Integer> m = new HashMap<String, Integer>();\n\t\tDeque<String> deque = new ArrayDeque<String>();\n\t\tint step = 1;\n\t\tdeque.offer(g);\n\t\tm.put(g, 0);\n\t\twhile (!deque.isEmpty() && step < 11) {\n\t\t\tint size = deque.size();\n\t\t\tfor (int k = 0; k < size; k++) {\n\t\t\t\tString s = deque.pop();\n\t\t\t\tchar[] c = s.toCharArray();\n\t\t\t\tfor (int i = 0; i < 13; i++) {\n\t\t\t\t\tif (c[i] == '0') {\n\t\t\t\t\t\tfor (int j = 0; j < adj[i].length; j++) {\n\t\t\t\t\t\t\tc[i] = c[adj[i][j]];\n\t\t\t\t\t\t\tc[adj[i][j]] = '0';\n\t\t\t\t\t\t\tString n = String.valueOf(c);\n\t\t\t\t\t\t\tif (!m.containsKey(n)) {\n\t\t\t\t\t\t\t\tm.put(n, step);\n\t\t\t\t\t\t\t\tdeque.offer(n);\n\t\t\t\t\t\t\t}\n\t\t\t\t\t\t\tc[adj[i][j]] = c[i];\n\t\t\t\t\t\t\tc[i] = '0';\n\t\t\t\t\t\t}\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t}\n\t\t\tstep++;\n\t\t}\n\t\twhile (true) {\n\t\t\tint p = scanner.nextInt();\n\t\t\tif (p == -1)\n\t\t\t\tbreak;\n\t\t\tchar[] cc = new char[13];\n\t\t\tcc[0] = p == 0 ? '0' : (char) (p - 1 + 'A');\n\t\t\tfor (int i = 1; i < 13; i++) {\n\t\t\t\tp = scanner.nextInt();\n\t\t\t\tcc[i] = p == 0 ? '0' : (char) (p - 1 + 'A');\n\t\t\t}\n\t\t\tString st = String.valueOf(cc);\n\t\t\tSet<String> set = new HashSet<String>();\n\t\t\tset.add(st);\n\t\t\tdeque.clear();\n\t\t\tdeque.offer(st);\n\t\t\tstep = 0;\n\t\t\tboolean flag = false;\n\t\t\tString ans = \"\";\n\t\t\tloop: while (!deque.isEmpty() && step < 11) {\n\t\t\t\tint size = deque.size();\n\t\t\t\tfor (int w = 0; w < size; w++) {\n\t\t\t\t\tString s = deque.pop();\n\t\t\t\t\tif (m.containsKey(s)) {\n\t\t\t\t\t\tflag = true;\n\t\t\t\t\t\tans = s;\n\t\t\t\t\t\tbreak loop;\n\t\t\t\t\t}\n\t\t\t\t\tchar[] cs = s.toCharArray();\n\t\t\t\t\tfor (int i = 0; i < 13; i++) {\n\t\t\t\t\t\tif (cs[i] == '0') {\n\t\t\t\t\t\t\tfor (int j = 0; j < adj[i].length; j++) {\n\t\t\t\t\t\t\t\tcs[i] = cs[adj[i][j]];\n\t\t\t\t\t\t\t\tcs[adj[i][j]] = '0';\n\t\t\t\t\t\t\t\tString news = String.valueOf(cs);\n\t\t\t\t\t\t\t\tif (!set.contains(news)) {\n\t\t\t\t\t\t\t\t\tset.add(news);\n\t\t\t\t\t\t\t\t\tdeque.offer(news);\n\t\t\t\t\t\t\t\t}\n\t\t\t\t\t\t\t\tcs[adj[i][j]] = cs[i];\n\t\t\t\t\t\t\t\tcs[i] = '0';\n\t\t\t\t\t\t\t}\n\t\t\t\t\t\t}\n\t\t\t\t\t}\n\n\t\t\t\t}\n\t\t\t\tstep++;\n\t\t\t}\n\t\t\tSystem.out.println(flag ? m.get(ans) + step : \"NA\");\n\n\t\t}\n\t}\n}"
  },
  {
    "language": "Java",
    "code": "import java.util.ArrayList;\nimport java.util.HashMap;\nimport java.util.HashSet;\nimport java.util.List;\nimport java.util.Map;\nimport java.util.Scanner;\nimport java.util.Set;\n\n//Eleven Puzzle\npublic class Main{\n\n\tpublic static void main(String[] args) {\n\t\tScanner sc = new Scanner(System.in);\n\t\tint[][] adj = {\n\t\t\t\t{2},\n\t\t\t\t{2,5},\n\t\t\t\t{0,1,3,6},\n\t\t\t\t{2,7},\n\t\t\t\t{5},\n\t\t\t\t{1,4,6,9},\n\t\t\t\t{2,5,7,10},\n\t\t\t\t{3,6,8,11},\n\t\t\t\t{7},\n\t\t\t\t{5,10},\n\t\t\t\t{6,9,11,12},\n\t\t\t\t{7,10},\n\t\t\t\t{10}\n\t\t};\n\t\tfinal String g = \"0ABCDEFGHIJK0\";\n\t\tMap<String, Integer> m = new HashMap<String, Integer>();\n\t\tList<String> l = new ArrayList<String>();\n\t\tint step = 1;\n\t\tl.add(g);\n\t\tm.put(g, 0);\n\t\twhile(!l.isEmpty()&&step<=2){\n\t\t\tList<String> next = new ArrayList<String>();\n\t\t\tfor(String s:l){\n\t\t\t\tchar[] c = s.toCharArray();\n\t\t\t\tfor(int i=0;i<13;i++){\n\t\t\t\t\tif(c[i]=='0'){\n\t\t\t\t\t\tfor(int j=0;j<adj[i].length;j++){\n\t\t\t\t\t\t\tchar u = c[adj[i][j]];\n\t\t\t\t\t\t\tc[adj[i][j]] = '0';\n\t\t\t\t\t\t\tc[i] = u;\n\t\t\t\t\t\t\tString n = new String(c);\n\t\t\t\t\t\t\tif(!m.containsKey(n)){\n\t\t\t\t\t\t\t\tm.put(n, step);\n\t\t\t\t\t\t\t\tnext.add(n);\n\t\t\t\t\t\t\t}\n\t\t\t\t\t\t\tc[adj[i][j]] = u;\n\t\t\t\t\t\t\tc[i] = '0';\n\t\t\t\t\t\t}\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t}\n\t\t\tstep++;\n\t\t\tl = next;\n\t\t}\n\t\twhile(true){\n\t\t\tint p = sc.nextInt();\n\t\t\tif(p==-1)break;\n\t\t\tchar[] cc = new char[13];\n\t\t\tcc[0] = p==0?'0':(char)(p-1+'A');\n\t\t\tfor(int i=1;i<13;i++){\n\t\t\t\tp = sc.nextInt();\n\t\t\t\tcc[i] = p==0?'0':(char)(p-1+'A');\n\t\t\t}\n\t\t\tString st = new String(cc);\n\t\t\tl = new ArrayList<String>();\n\t\t\tstep = 0;\n\t\t\tl.add(st);\n\t\t\tString ans = \"NA\";\n\t\t\tSet<String> set = new HashSet<String>();\n\t\t\twhile(!l.isEmpty()&&step<=2){\n\t\t\t\tList<String> next = new ArrayList<String>();\n\t\t\t\tfor(String s:l){\n\t\t\t\t\tif(m.containsKey(s)){\n\t\t\t\t\t\tans = (step+m.get(s))+\"\";\n\t\t\t\t\t\tnext.clear();\n\t\t\t\t\t\tbreak;\n\t\t\t\t\t}\n\t\t\t\t\tchar[] c = s.toCharArray();\n\t\t\t\t\tfor(int i=0;i<13;i++){\n\t\t\t\t\t\tif(c[i]=='0'){\n\t\t\t\t\t\t\tfor(int j=0;j<adj[i].length;j++){\n\t\t\t\t\t\t\t\tchar u = c[adj[i][j]];\n\t\t\t\t\t\t\t\tc[adj[i][j]] = '0';\n\t\t\t\t\t\t\t\tc[i] = u;\n\t\t\t\t\t\t\t\tString n = new String(c);\n\t\t\t\t\t\t\t\tif(!set.contains(n)){\n\t\t\t\t\t\t\t\t\tset.add(n);\n\t\t\t\t\t\t\t\t\tnext.add(n);\n\t\t\t\t\t\t\t\t}\n\t\t\t\t\t\t\t\tc[adj[i][j]] = u;\n\t\t\t\t\t\t\t\tc[i] = '0';\n\t\t\t\t\t\t\t}\n\t\t\t\t\t\t}\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t\tstep++;\n\t\t\t\tl = next;\n\t\t\t}\n\t\t\tSystem.out.println(ans);\n\t\t}\n\t}\n}"
  },
  {
    "language": "Java",
    "code": "import java.util.ArrayDeque;\nimport java.util.Arrays;\nimport java.util.HashMap;\nimport java.util.Scanner;\n\npublic class Main {\n\tstatic HashMap<String,Integer> map = new HashMap<String,Integer>();\n\tstatic HashMap<String,Integer> map2 = new HashMap<String,Integer>();\n\tstatic int min = 21;\n\tstatic int[][] move = new int[][] {\n\t\t\t\t\t\t\t\t{2},\n\t\t\t\t\t   {2,5},{0,1,3,6},{2,7},\n\t\t\t   {5},{1,4,6,9},{2,5,7,10},{3,6,8,11},{7},\n\t\t\t          {5,10},{6,9,11,12},{7,10},\n\t\t\t          \t\t\t{10}\n\t\t\t          };\n \t\n\tpublic static void main(String[] args) {\n\t\tScanner sc = new Scanner(System.in);\n\t\tString first = \"0123456789AB0\";\n\t\tBfsa(0,0,12,first);\n\t\tIN:while(true) {\n\t\t\tmin = 21;\n\t\t\tchar[] data = new char[13];\n\t\t\tint xa = -1;\n\t\t\tint xb = -1;\n\t\t\tfor(int i = 0; i < 13; i++) {\n\t\t\t\tString tmp = sc.next();\n\t\t\t\tif(tmp.equals(\"-1\")) break IN;\n\t\t\t\tif(tmp.equals(\"10\")) tmp = \"A\";\n\t\t\t\tif(tmp.equals(\"11\")) tmp = \"B\";\n\t\t\t\tif(tmp.equals(\"0\")) {\n\t\t\t\t\tif(xa == -1) xa = i;\n\t\t\t\t\telse xb = i;\n\t\t\t\t}\n\t\t\t\tdata[i] = tmp.charAt(0);\n\t\t\t}\n\t\t\tif(map.containsKey(String.valueOf(data))) {\n\t\t\t\tmin = map.get(String.valueOf(data));\n\t\t\t}\n\t\t\tBfsb(0,xa,xb,String.valueOf(data));\n\t\t\tif(min <= 20) {\n\t\t\t\tSystem.out.println(min);\n\t\t\t}\n\t\t\telse {\n\t\t\t\tSystem.out.println(\"NA\");\n\t\t\t}\n\t\t\t\n\t\t}\n\t}\n\tstatic ArrayDeque<Data> queue = new ArrayDeque<Data>();\n\t\n\tstatic void Bfsa(int a, int b, int c,String d) {\n\t\tqueue.clear();\n\t\tqueue.add(new Data(a,b,c,d));\n\t\twhile(!queue.isEmpty()) {\n\t\t\tData ax = queue.poll();\n\t\t\tbfsa(ax.a,ax.b1,ax.b2,ax.d);\n\t\t}\n\t}\n\t\n\tstatic void Bfsb(int a, int b, int c,String d) {\n\t\tmap2.clear();\n\t\tSystem.gc();\n\t\tqueue.clear();\n\t\tqueue.add(new Data(a,b,c,d));\n\t\twhile(!queue.isEmpty()) {\n\t\t\tData ax = queue.poll();\n\t\t\tbfsb(ax.a,ax.b1,ax.b2,ax.d);\n\t\t}\n\t}\n\t\n\t\n\tstatic String swap(int a, int b, String c) {\n\t\tchar[] x = c.toCharArray();\n\t\tchar tmp = x[a];\n\t\tx[a] = x[b];\n\t\tx[b] = tmp;\n\t\tString cx = String.valueOf(x);\n\t\treturn cx;\n\t}\n\tstatic void bfsa(int a, int b1,int b2, String c) {\n\t\tif(a > 10) return;\n\t\tif(!map.containsKey(c)) {\n\t\t\t\tmap.put(c, a);\n\t\t}\n\t\telse {\n\t\t\treturn;\n\t\t}\n\t\tfor(int i = 0; i < 13; i++) {\n\t\t\tif(b1 == i) {\n\t\t\t\tfor(int j = 0; j < move[i].length; j++) {\n\t\t\t\t\tif(move[i][j] == b2) {\n\t\t\t\t\t\tc = swap(b2,b1,c);\n\t\t\t\t\t\tqueue.add(new Data(a,b2,b1,c));\n\t\t\t\t\t\tc = swap(b2,b1,c);\n\t\t\t\t\t}\n\t\t\t\t\telse {\n\t\t\t\t\t\tc = swap(move[i][j],b1,c);\n\t\t\t\t\t\tqueue.add(new Data(a+1,move[i][j],b2,c));\n\t\t\t\t\t\tc = swap(move[i][j],b1,c);\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t}\n\t\t\tif(b2 == i) {\n\t\t\t\tfor(int j = 0; j < move[i].length; j++) {\n\t\t\t\t\tif(move[i][j] == b1) {\n\t\t\t\t\t\tc = swap(b2,b1,c);\n\t\t\t\t\t\tqueue.add(new Data(a,b2,b1,c));\n\t\t\t\t\t\tc = swap(b2,b1,c);\n\t\t\t\t\t}\n\t\t\t\t\telse {\n\t\t\t\t\t\tc = swap(move[i][j],b2,c);\n\t\t\t\t\t\tqueue.add(new Data(a+1,b1,move[i][j],c));\n\t\t\t\t\t\tc = swap(move[i][j],b2,c);\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t}\n\t\n\tstatic void bfsb(int a, int b1,int b2, String c) {\n\t\tif(a > 10) return;\n\t\tif(!map2.containsKey(c)) {\n\t\t\tif(map.containsKey(c)) {\n\t\t\t\tmin = Math.min(min, a + map.get(c));\n\t\t\t}\n\t\t\tmap2.put(c, a);\n\t\t}\n\t\telse {\n\t\t\treturn;\n\t\t}\n\t\tfor(int i = 0; i < 13; i++) {\n\t\t\tif(b1 == i) {\n\t\t\t\tfor(int j = 0; j < move[i].length; j++) {\n\t\t\t\t\tif(move[i][j] == b2) {\n\t\t\t\t\t\tc = swap(b2,b1,c);\n\t\t\t\t\t\tqueue.add(new Data(a,b2,b1,c));\n\t\t\t\t\t\tc = swap(b2,b1,c);\n\t\t\t\t\t}\n\t\t\t\t\telse {\n\t\t\t\t\t\tc = swap(move[i][j],b1,c);\n\t\t\t\t\t\tqueue.add(new Data(a+1,move[i][j],b2,c));\n\t\t\t\t\t\tc = swap(move[i][j],b1,c);\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t}\n\t\t\tif(b2 == i) {\n\t\t\t\tfor(int j = 0; j < move[i].length; j++) {\n\t\t\t\t\tif(move[i][j] == b1) {\n\t\t\t\t\t\tc = swap(b2,b1,c);\n\t\t\t\t\t\tqueue.add(new Data(a,b2,b1,c));\n\t\t\t\t\t\tc = swap(b2,b1,c);\n\t\t\t\t\t}\n\t\t\t\t\telse {\n\t\t\t\t\t\tc = swap(move[i][j],b2,c);\n\t\t\t\t\t\tqueue.add(new Data(a+1,b1,move[i][j],c));\n\t\t\t\t\t\tc = swap(move[i][j],b2,c);\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t}\n\t\n\tstatic class Data {\n\t\tint a, b1, b2 ;\n\t\tString d;\n\t\tData(int a, int b, int c, String d) {\n\t\t\tthis.a = a;\n\t\t\tb1 = b;\n\t\t\tb2 = c;\n\t\t\tthis.d = d;\n\t\t}\n\t}\n\t\n\n}"
  },
  {
    "language": "Java",
    "code": "import java.lang.reflect.Array;\nimport java.util.ArrayList;\nimport java.util.Arrays;\nimport java.util.HashMap;\nimport java.util.HashSet;\nimport java.util.LinkedList;\nimport java.util.Scanner;\n\npublic class Main {\n\t\n\tpublic static final long[] ans_array = new long[]{0, 1, 2, 3, 4, 5, 6, 7, 8, 9, 10, 11, 0};\n\t\n\tpublic static final int[][] move_dir = new int[][]{{1, 0}, {-1, 0}, {0, 1}, {0, -1}};\n\t\n\tpublic static int get_x(int pos){\n\t\tif(pos == 0){\n\t\t\treturn 0;\n\t\t}else if(pos >= 1 && pos <= 3){\n\t\t\treturn pos - 2;\n\t\t}else if(pos >= 4 && pos <= 8){\n\t\t\treturn pos - 6;\n\t\t}else if(pos >= 9 && pos <= 11){\n\t\t\treturn pos - 10;\n\t\t}else{\n\t\t\treturn 0;\n\t\t}\n\t}\n\t\n\tpublic static int get_y(int pos){\n\t\tif(pos == 0){\n\t\t\treturn -2;\n\t\t}else if(pos >= 1 && pos <= 3){\n\t\t\treturn -1;\n\t\t}else if(pos >= 4 && pos <= 8){\n\t\t\treturn 0;\n\t\t}else if(pos >= 9 && pos <= 11){\n\t\t\treturn 1;\n\t\t}else{\n\t\t\treturn 2;\n\t\t}\n\t}\n\t\n\tpublic static int get_pos(int x, int y){\n\t\tif(y == -2 && x == 0){\n\t\t\treturn 0;\n\t\t}else if(y == -1 && x >= -1 && x <= 1){\n\t\t\treturn 2 + x;\n\t\t}else if(y == 0 && x >= -2 && x <= 2){\n\t\t\treturn 6 + x;\n\t\t}else if(y == 1 && x >= -1 && x <= 1){\n\t\t\treturn 10 + x;\n\t\t}else{\n\t\t\treturn 12;\n\t\t}\n\t}\n\t\n\tpublic static void print_bit(long bit){\n\t\tfor(int i = 0; i < 13; i++){\n\t\t\tSystem.out.print((bit >>> (i * 4)) & 15);\n\t\t\tSystem.out.print(\" ,\");\n\t\t}\n\t\tSystem.out.println();\n\t}\n\t\n\tpublic static void main(String[] args) {\n\t\tScanner sc = new Scanner(System.in);\n\t\t\n\t\tHashSet<Long> is_visited = new HashSet<Long>();\n\t\t\n\t\tlong ans_bit = 0;\n\t\tfor(int i = 0; i < 13; i++){\n\t\t\tans_bit |= (ans_array[i] << (i * 4));\n\t\t}\n\t\t\n\t\twhile(true){\n\t\t\tfinal int top = sc.nextInt();\n\t\t\t\n\t\t\tif(top == -1){\n\t\t\t\tbreak;\n\t\t\t}\n\t\t\t\n\t\t\tis_visited.clear();\n\t\t\t\n\t\t\tlong init_bit = top;\n\t\t\tfor(int i = 1; i < 13; i++){\n\t\t\t\tinit_bit |= (sc.nextLong() << (i * 4));\n\t\t\t}\n\t\t\t\n\t\t\tLinkedList<Long> bit_queue = new LinkedList<Long>();\n\t\t\tLinkedList<Integer> time_queue = new LinkedList<Integer>();\n\t\t\tis_visited.add(init_bit);\n\t\t\tbit_queue.add(init_bit);\n\t\t\ttime_queue.add(0);\n\t\t\t\n\t\t\tboolean flag = false;\n\t\t\twhile(!bit_queue.isEmpty()){\n\t\t\t\tlong bit = bit_queue.poll();\n\t\t\t\tint time = time_queue.poll();\n\t\t\t\t\n\t\t\t\tif(time > 20){\n\t\t\t\t\tcontinue;\n\t\t\t\t}\n\t\t\t\t//print_bit(bit);\n\t\t\t\t//print_bit(ans_bit);\n\t\t\t\t//sc.next();\n\t\t\t\t//System.out.println(bit + \" \" + time);\n\t\t\t\t\n\t\t\t\tif(bit == ans_bit){\n\t\t\t\t\tflag = true;\n\t\t\t\t\tSystem.out.println(time);\n\t\t\t\t\tbreak;\n\t\t\t\t}\n\t\t\t\t\n\t\t\t\tif(time == 20){\n\t\t\t\t\tcontinue;\n\t\t\t\t}\n\t\t\t\t\n\t\t\t\tfor(int hole = 0; hole < 13; hole++){\n\t\t\t\t\tif((bit & (15L << (hole * 4))) != 0){\n\t\t\t\t\t\tcontinue;\n\t\t\t\t\t}\n\t\t\t\t\t\n\t\t\t\t\tfinal int x_pos = get_x(hole);\n\t\t\t\t\tfinal int y_pos = get_y(hole);\n\t\t\t\t\t\n\t\t\t\t\tfor(int[] move : move_dir){\n\t\t\t\t\t\tfinal int nx = x_pos + move[0];\n\t\t\t\t\t\tfinal int ny = y_pos + move[1];\n\t\t\t\t\t\t\n\t\t\t\t\t\tif(Math.abs(nx) + Math.abs(ny) > 2){\n\t\t\t\t\t\t\tcontinue;\n\t\t\t\t\t\t}\n\t\t\t\t\t\t\n\t\t\t\t\t\tint next_hole = get_pos(nx, ny);\n\t\t\t\t\t\tlong next_value = (bit >>> (next_hole * 4)) & (15L);\n\t\t\t\t\t\t\n\t\t\t\t\t\tif(next_value == 0){\n\t\t\t\t\t\t\tcontinue;\n\t\t\t\t\t\t}\n\t\t\t\t\t\t\n\t\t\t\t\t\tlong next_bit = bit & ~(15L << (hole * 4));\n\t\t\t\t\t\tnext_bit = next_bit & ~(15L << (next_hole * 4));\n\t\t\t\t\t\t\n\t\t\t\t\t\tnext_bit |= (next_value << (hole * 4));\n\t\t\t\t\t\t\n\t\t\t\t\t\tif(is_visited.contains(next_bit)){\n\t\t\t\t\t\t\tcontinue;\n\t\t\t\t\t\t}\n\t\t\t\t\t\t\n\t\t\t\t\t\tis_visited.add(next_bit);\n\t\t\t\t\t\ttime_queue.add(time + 1);\n\t\t\t\t\t\tbit_queue.add(next_bit);\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t}\n\t\t\t\n\t\t\tif(!flag){\n\t\t\t\tSystem.out.println(\"NA\");\n\t\t\t}\n\t\t}\n\t}\n}"
  },
  {
    "language": "Java",
    "code": "\nimport java.util.ArrayDeque;\nimport java.util.Deque;\nimport java.util.HashMap;\nimport java.util.HashSet;\nimport java.util.Map;\nimport java.util.Scanner;\nimport java.util.Set;\n\npublic class Main {\n\n\tpublic static void main(String[] args) {\n\t\tnew Main().run();\n\t}\n\n\tprivate void run() {\n\t\tScanner scanner = new Scanner(System.in);\n\t\tint[][] adj = { { 2 }, { 2, 5 }, { 0, 1, 3, 6 }, { 2, 7 }, { 5 },\n\t\t\t\t{ 1, 4, 6, 9 }, { 2, 5, 7, 10 }, { 3, 6, 8, 11 }, { 7 },\n\t\t\t\t{ 5, 10 }, { 6, 9, 11, 12 }, { 7, 10 }, { 10 } };\n\t\tString g = \"0ABCDEFGHIJK0\";\n\t\tMap<String, Integer> m = new HashMap<String, Integer>();\n\t\tDeque<String> deque = new ArrayDeque<String>();\n\t\tint step = 1;\n\t\tdeque.offer(g);\n\t\tm.put(g, 0);\n\t\twhile (!deque.isEmpty() && step < 10) {\n\t\t\tint size = deque.size();\n\t\t\tfor (int k = 0; k < size; k++) {\n\t\t\t\tString s = deque.pop();\n\t\t\t\tchar[] c = s.toCharArray();\n\t\t\t\tfor (int i = 0; i < 13; i++) {\n\t\t\t\t\tif (c[i] == '0') {\n\t\t\t\t\t\tfor (int j = 0; j < adj[i].length; j++) {\n\t\t\t\t\t\t\tc[i] = c[adj[i][j]];\n\t\t\t\t\t\t\tc[adj[i][j]] = '0';\n\t\t\t\t\t\t\tString n = String.valueOf(c);\n\t\t\t\t\t\t\tif (!m.containsKey(n)) {\n\t\t\t\t\t\t\t\tm.put(n, step);\n\t\t\t\t\t\t\t\tdeque.offer(n);\n\t\t\t\t\t\t\t}\n\t\t\t\t\t\t\tc[adj[i][j]] = c[i];\n\t\t\t\t\t\t\tc[i] = '0';\n\t\t\t\t\t\t}\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t}\n\t\t\tstep++;\n\t\t}\n\t\twhile (true) {\n\t\t\tint p = scanner.nextInt();\n\t\t\tif (p == -1)\n\t\t\t\tbreak;\n\t\t\tchar[] cc = new char[13];\n\t\t\tcc[0] = p == 0 ? '0' : (char) (p - 1 + 'A');\n\t\t\tfor (int i = 1; i < 13; i++) {\n\t\t\t\tp = scanner.nextInt();\n\t\t\t\tcc[i] = p == 0 ? '0' : (char) (p - 1 + 'A');\n\t\t\t}\n\t\t\tString st = String.valueOf(cc);\n\t\t\tSet<String> set = new HashSet<String>();\n\t\t\tdeque.clear();\n\t\t\tdeque.offer(st);\n\t\t\tstep = 0;\n\t\t\tboolean flag = false;\n\t\t\tString ans = \"\";\n\t\t\tloop: while (!deque.isEmpty() && step < 10) {\n\t\t\t\tint size = deque.size();\n\t\t\t\tfor (int w = 0; w < size; w++) {\n\t\t\t\t\tString s = deque.pop();\n\t\t\t\t\tif (m.containsKey(s)) {\n\t\t\t\t\t\tflag = true;\n\t\t\t\t\t\tans = s;\n\t\t\t\t\t\tbreak loop;\n\t\t\t\t\t}\n\t\t\t\t\tchar[] cs = s.toCharArray();\n\t\t\t\t\tfor (int i = 0; i < 13; i++) {\n\t\t\t\t\t\tif (cs[i] == '0') {\n\t\t\t\t\t\t\tfor (int j = 0; j < adj[i].length; j++) {\n\t\t\t\t\t\t\t\tcs[i] = cs[adj[i][j]];\n\t\t\t\t\t\t\t\tcs[adj[i][j]] = '0';\n\t\t\t\t\t\t\t\tString news = String.valueOf(cs);\n\t\t\t\t\t\t\t\tif (!set.contains(news)) {\n\t\t\t\t\t\t\t\t\tset.add(news);\n\t\t\t\t\t\t\t\t\tdeque.offer(news);\n\t\t\t\t\t\t\t\t}\n\t\t\t\t\t\t\t\tcs[adj[i][j]] = cs[i];\n\t\t\t\t\t\t\t\tcs[i] = '0';\n\t\t\t\t\t\t\t}\n\t\t\t\t\t\t}\n\t\t\t\t\t}\n\n\t\t\t\t}\n\t\t\t\tstep++;\n\t\t\t}\n\t\t\tSystem.out.println(flag ? m.get(ans) : \"NA\");\n\n\t\t}\n\t}\n}"
  },
  {
    "language": "Java",
    "code": "import static java.util.Arrays.deepToString;\n\nimport java.util.ArrayDeque;\nimport java.util.HashSet;\nimport java.util.Queue;\nimport java.util.Scanner;\nimport java.util.Set;\n\npublic class Main {\n\tpublic static void main(String[] args) {\n\t\tnew Main().run();\n\t}\n\tvoid tr(Object... os) {\n\t\tSystem.err.println(deepToString(os));\n\t}\n\t\n\tScanner sc = new Scanner(System.in);\n\t\n\tchar[] goal = \"0123456789ab0\".toCharArray();\n\tint[] rs = {0, 1, 1, 1, 2, 2, 2, 2, 2, 3, 3, 3, 4};\n\tint[] cs = {2, 1, 2, 3, 0, 1, 2, 3, 4, 1, 2, 3, 2};\n\tint[] dr = {0, 1, 0, -1};\n\tint[] dc = {1, 0, -1, 0};\n\t\n\tint[][] rm = {\n\t\t{-1, -1, -1,-1, -1, -1, -1},\n\t\t{-1, -1, -1, 0, -1, -1, -1},\n\t\t{-1, -1,  1, 2,  3, -1, -1},\n\t\t{-1,  4,  5, 6,  7,  8, -1},\n\t\t{-1, -1,  9, 10, 11, -1, -1},\n\t\t{-1, -1, -1, 12, -1, -1, -1},\n\t\t{-1, -1, -1, -1, -1, -1, -1},\n\t};\n\t\n\tpublic void run() {\n\t\tfor (;sc.hasNext();) {\n\t\t\tchar[] s = new char[13];\n\t\t\tint x = sc.nextInt();\n\t\t\tif (x == -1) break;\n\t\t\ts[0] = toc(x);\n\t\t\tfor (int i = 1; i < 13; i++) {\n\t\t\t\ts[i] = toc(sc.nextInt());\n\t\t\t}\n\t\t\tSet<String> vis = new HashSet<String>();\n\t\t\tvis.add(new String(s));\n\t\t\tQueue<String> q1 = new ArrayDeque<String>();\n\t\t\tQueue<Integer> q2 = new ArrayDeque<Integer>();\n\t\t\tq1.add(new String(s));\n\t\t\tq2.add(0);\n\t\t\tint ans = -1;\n\t\t\twhile (q1.size() > 0) {\n\t\t\t\ts = q1.poll().toCharArray();\n\t\t\t\tint step = q2.poll();\n//\t\t\t\ttr(vis.size(), q1.size(), step);\n\t\t\t\tif (isGoal(s)) {\n\t\t\t\t\tans = step;\n\t\t\t\t\tbreak;\n\t\t\t\t}\n\t\t\t\t\n\t\t\t\tif (step + estimate(s) > 20) continue;  // prune\n\t\t\t\t\n\t\t\t\tif (step < 20) {\n\t\t\t\t\tfor (int i = 0; i < s.length; i++) if (s[i] == '0') {\n\t\t\t\t\t\tfinal int zr = rs[i];\n\t\t\t\t\t\tfinal int zc = cs[i];\n\t\t\t\t\t\tfor (int k = 0; k < 4; k++) {\n\t\t\t\t\t\t\tint nr = zr + dr[k];\n\t\t\t\t\t\t\tint nc = zc + dc[k];\n\t\t\t\t\t\t\tint ni = rm[nr + 1][nc + 1];\n\t\t\t\t\t\t\tif (ni == -1) continue;\n\t\t\t\t\t\t\tswap(s, i, ni);\n\t\t\t\t\t\t\tString nxt = new String(s);\n\t\t\t\t\t\t\tif (!vis.contains(nxt)) {\n\t\t\t\t\t\t\t\tvis.add(nxt);\n\t\t\t\t\t\t\t\tq1.add(nxt);\n\t\t\t\t\t\t\t\tq2.add(step+1);\n\t\t\t\t\t\t\t}\n\t\t\t\t\t\t\tswap(s, i, ni);\n\t\t\t\t\t\t}\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t}\n\t\t\t\n\t\t\tif (ans == -1) System.out.println(\"NA\"); else System.out.println(ans);\n\t\t}\n\t}\n\tint estimate(char[] s) {\n\t\tint sum = 0;\n\t\tfor (int i = 0; i < s.length; i++) if (s[i] != '0') {\n\t\t\tint n = getNum(s[i]);\n\t\t\tint d = Math.abs(rs[i] - rs[n]) + Math.abs(cs[i] - cs[n]);\n\t\t\tsum += d;\n\t\t}\n\t\treturn sum / 2;\n\t}\n\tint getNum(char c) {\n\t\tif (c == 'a') return 10;\n\t\tif (c == 'b') return 11;\n\t\treturn c - '0';\n\t}\n\tvoid swap(char[] s, int i, int j) {\n\t\tchar t = s[i]; s[i] = s[j]; s[j] = t;\n\t}\n\tboolean isGoal(char[] s) {\n\t\tfor (int i = 0; i < s.length; i++) if (s[i] != goal[i]) return false;\n\t\treturn true;\n\t}\n\tchar toc(int x) {\n\t\treturn String.format(\"%x\", x).charAt(0);\n\t}\n}"
  },
  {
    "language": "Java",
    "code": "import java.util.ArrayList;\nimport java.util.HashMap;\nimport java.util.HashSet;\nimport java.util.List;\nimport java.util.Map;\nimport java.util.Scanner;\nimport java.util.Set;\n\n//Eleven Puzzle\npublic class Main{\n\n\tpublic static void main(String[] args) {\n\t\tScanner sc = new Scanner(System.in);\n\t\tint[][] adj = {\n\t\t\t\t{2},\n\t\t\t\t{2,5},\n\t\t\t\t{0,1,3,6},\n\t\t\t\t{2,7},\n\t\t\t\t{5},\n\t\t\t\t{1,4,6,9},\n\t\t\t\t{2,5,7,10},\n\t\t\t\t{3,6,8,11},\n\t\t\t\t{7},\n\t\t\t\t{5,10},\n\t\t\t\t{6,9,11,12},\n\t\t\t\t{7,10},\n\t\t\t\t{10}\n\t\t};\n\t\tfinal String g = \"0ABCDEFGHIJK0\";\n\t\tMap<String, Integer> m = new HashMap<String, Integer>();\n\t\tList<String> l = new ArrayList<String>();\n\t\tint step = 1;\n\t\tl.add(g);\n\t\tm.put(g, 0);\n\t\twhile(!l.isEmpty()&&step<=10){\n\t\t\tList<String> next = new ArrayList<String>();\n\t\t\tfor(String s:l){\n\t\t\t\tchar[] c = s.toCharArray();\n\t\t\t\tfor(int i=0;i<13;i++){\n\t\t\t\t\tif(c[i]=='0'){\n\t\t\t\t\t\tfor(int j=0;j<adj[i].length;j++){\n\t\t\t\t\t\t\tchar u = c[adj[i][j]];\n\t\t\t\t\t\t\tc[adj[i][j]] = '0';\n\t\t\t\t\t\t\tc[i] = u;\n\t\t\t\t\t\t\tString n = new String(c);\n\t\t\t\t\t\t\tif(!m.containsKey(n)){\n\t\t\t\t\t\t\t\tm.put(n, step);\n\t\t\t\t\t\t\t\tnext.add(n);\n\t\t\t\t\t\t\t}\n\t\t\t\t\t\t\tc[adj[i][j]] = u;\n\t\t\t\t\t\t\tc[i] = '0';\n\t\t\t\t\t\t}\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t}\n\t\t\tstep++;\n\t\t\tl = next;\n\t\t}\n\t\twhile(true){\n\t\t\tint p = sc.nextInt();\n\t\t\tif(p==-1)break;\n\t\t\tchar[] cc = new char[13];\n\t\t\tcc[0] = p==0?'0':(char)(p-1+'A');\n\t\t\tfor(int i=1;i<13;i++){\n\t\t\t\tp = sc.nextInt();\n\t\t\t\tcc[i] = p==0?'0':(char)(p-1+'A');\n\t\t\t}\n\t\t\tString st = new String(cc);\n\t\t\tl = new ArrayList<String>();\n\t\t\tstep = 0;\n\t\t\tl.add(st);\n\t\t\tString ans = \"NA\";\n\t\t\tSet<String> set = new HashSet<String>();\n\t\t\twhile(!l.isEmpty()&&step<=10){\n\t\t\t\tList<String> next = new ArrayList<String>();\n\t\t\t\tfor(String s:l){\n\t\t\t\t\tif(m.containsKey(s)){\n\t\t\t\t\t\tans = (step+m.get(s))+\"\";\n\t\t\t\t\t\tnext.clear();\n\t\t\t\t\t\tbreak;\n\t\t\t\t\t}\n\t\t\t\t\tchar[] c = s.toCharArray();\n\t\t\t\t\tfor(int i=0;i<13;i++){\n\t\t\t\t\t\tif(c[i]=='0'){\n\t\t\t\t\t\t\tfor(int j=0;j<adj[i].length;j++){\n\t\t\t\t\t\t\t\tchar u = c[adj[i][j]];\n\t\t\t\t\t\t\t\tc[adj[i][j]] = '0';\n\t\t\t\t\t\t\t\tc[i] = u;\n\t\t\t\t\t\t\t\tString n = new String(c);\n\t\t\t\t\t\t\t\tif(!set.contains(n)){\n\t\t\t\t\t\t\t\t\tset.add(n);\n\t\t\t\t\t\t\t\t\tnext.add(n);\n\t\t\t\t\t\t\t\t}\n\t\t\t\t\t\t\t\tc[adj[i][j]] = u;\n\t\t\t\t\t\t\t\tc[i] = '0';\n\t\t\t\t\t\t\t}\n\t\t\t\t\t\t}\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t\tstep++;\n\t\t\t\tl = next;\n\t\t\t}\n\t\t\tSystem.out.println(ans);\n\t\t}\n\t}\n}"
  },
  {
    "language": "Java",
    "code": "\nimport java.util.ArrayDeque;\nimport java.util.Deque;\nimport java.util.HashMap;\nimport java.util.HashSet;\nimport java.util.Map;\nimport java.util.Scanner;\nimport java.util.Set;\n\npublic class Main {\n\n\tpublic static void main(String[] args) {\n\t\tnew Main().run();\n\t}\n\n\tprivate void run() {\n\t\tScanner scanner = new Scanner(System.in);\n\t\tint[][] map = { { 2 }, { 2, 5 }, { 0, 1, 3, 6 }, { 2, 7 }, { 5 },\n\t\t\t\t{ 1, 4, 6, 9 }, { 2, 5, 7, 10 }, { 3, 6, 8, 11 }, { 7 },\n\t\t\t\t{ 5, 10 }, { 6, 9, 11, 12 }, { 7, 10 }, { 10 } };\n\t\tString reslt = \"0ABCDEFGHIJK0\";\n\t\tMap<String, Integer> memo = new HashMap<String, Integer>();\n\t\tmemo.put(reslt, 0);\n\t\tint step = 1;\n\t\tDeque<String> deque = new ArrayDeque<String>();\n\t\tdeque.offer(reslt);\n\t\twhile (step <= 10) {\n\t\t\tint size = deque.size();\n\t\t\twhile (size-- > 0) {\n\t\t\t\tchar[] chs = deque.pop().toCharArray();\n\t\t\t\tfor (int i = 0; i < 13; i++) {\n\t\t\t\t\tif (chs[i] == '0') {\n\t\t\t\t\t\tfor (int j : map[i]) {\n\t\t\t\t\t\t\tchs[i] = chs[j];\n\t\t\t\t\t\t\tchs[j] = '0';\n\t\t\t\t\t\t\tString tmp = String.valueOf(chs);\n\t\t\t\t\t\t\tif (!memo.containsKey(tmp)) {\n\t\t\t\t\t\t\t\tmemo.put(tmp, step);\n\t\t\t\t\t\t\t\tdeque.offer(tmp);\n\t\t\t\t\t\t\t}\n\t\t\t\t\t\t\tchs[j] = chs[i];\n\t\t\t\t\t\t\tchs[i] = '0';\n\t\t\t\t\t\t}\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t}\n\t\t\tstep++;\n\t\t}\n\t\twhile (true) {\n\t\t\tint n = scanner.nextInt();\n\t\t\tif (n == -1)\n\t\t\t\tbreak;\n\t\t\tchar[] cs = new char[13];\n\t\t\tcs[0] = n == 0 ? '0' : (char) (n - 1 + 'A');\n\t\t\tfor (int i = 1; i < 13; i++) {\n\t\t\t\tint c = scanner.nextInt();\n\t\t\t\tcs[i] = c == 0 ? '0' : (char) (c - 1 + 'A');\n\t\t\t}\n\t\t\tString s = String.valueOf(cs);\n\t\t\tSet<String> set = new HashSet<String>();\n\t\t\tset.add(s);\n\t\t\tint ans = slove(0, map, memo, s, set);\n\t\t\tSystem.out.println(ans == -1 ? \"NA\" : String.valueOf(ans));\n\t\t}\n\t}\n\n\tint slove(int k, int[][] map, Map<String, Integer> memo, String str,\n\t\t\tSet<String> set) {\n\t\tif (k == 11) {\n\t\t\treturn -1;\n\t\t}\n\t\tif (memo.containsKey(str)) {\n\t\t\treturn memo.get(str) + k;\n\t\t}\n\t\tchar[] chs = str.toCharArray();\n\t\tfor (int i = 0; i < 13; i++) {\n\t\t\tif (chs[i] == '0') {\n\t\t\t\tfor (int j : map[i]) {\n\t\t\t\t\tchs[i] = chs[j];\n\t\t\t\t\tchs[j] = '0';\n\t\t\t\t\tString tmp = String.valueOf(chs);\n\t\t\t\t\tif (!set.contains(tmp)) {\n\t\t\t\t\t\tset.add(tmp);\n\t\t\t\t\t\tslove(k + 1, map, memo, tmp, set);\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\n\t\treturn -1;\n\n\t}\n}"
  },
  {
    "language": "Ruby",
    "code": "require 'set'\n\n# ??????: ???????????¢?´¢\n\n# ??£\nNB = [\n  [2],\n  [5, 2],\n  [0, 1, 3, 6],\n  [2, 7],\n  [5],\n  [1, 4, 6, 9],\n  [2, 5, 7, 10],\n  [3, 6, 8, 11],\n  [7],\n  [5, 10],\n  [6, 9, 11, 12],\n  [10, 7],\n  [10]\n]\n\nY = [0, 1, 1, 1, 2, 2, 2, 2, 2, 3, 3, 3, 4]\nX = [2, 1, 2, 3, 0, 1, 2, 3, 4, 1, 2, 3, 2]\n\ndef solve(field)\n  queue = []\n  queue << [field, 0]\n  used = Set.new\n  dist = -1\n  prev_dist = -1\n  until queue.empty?\n    f, dist = queue.shift\n    return dist if f == [0, 1, 2, 3, 4, 5, 6, 7, 8, 9, 10, 11, 0]\n    res = f.each_with_index.inject(0) {|accum, (v, i)|\n      accum + (i != 0 ? (X[v] - X[i % 12]).abs + (Y[v] - Y[i % 12]).abs : 0)\n    }\n    next if ((res / 2) + dist) > 20\n    f.each.with_index do |v, i|\n      next unless v == 0\n      NB[i].each do |t|\n        f[i], f[t] = f[t], f[i]\n        unless used.include? f\n          nf = f.clone\n          used.add(nf)\n          queue << [nf, dist + 1]\n        end\n        f[i], f[t] = f[t], f[i]\n      end\n    end\n    # p \"N: #{prev_dist = dist}\" if prev_dist < dist\n  end\n  return nil if queue.empty?\n  dist\nend\n\nloop do\n  v = gets.to_i\n  break if v == -1\n  field = (1..4).map { gets.split(\" \").map(&:to_i) }\n  res = solve(([[v]] + field).flatten)\n  puts res.nil? ? \"NA\" : res\nend"
  },
  {
    "language": "Ruby",
    "code": "require 'set'\n \nMove = [ [2],\n         [2, 5], [0, 1, 3, 6], [2, 7],\n         [5], [1, 4, 6, 9], [2, 5, 7, 10], [3, 6, 8, 11], [7],\n         [5, 10], [6, 9, 11, 12], [7, 10],\n         [10] ]\nR = [0, 1, 1, 1, 2, 2, 2, 2, 2, 3, 3, 3, 4]\nC = [2, 1, 2, 3, 0, 1, 2, 3, 4, 1, 2, 3, 2]\n \ndef judge(brd)\n  ret = 0\n  13.times do |i|\n    if brd[i] > 0\n      [R, C].each do |a|\n        ret += (a[i] - a[brd[i]]).abs\n      end\n    end\n  end\n  ret\nend\n \ndef solve(brd)\n  q = [[judge(brd), brd, 0]]\n  set = Set.new([])\n  set.add(brd)\n  until q.empty?\n    arr = q.min{ |a, b| a <=> b }\n    q.delete(arr)\n    x, b, d = arr\n    return d if x == 0\n    13.times do |i|\n      if b[i] == 0\n        Move[i].each do |m|\n          b[i], b[m] = b[m], b[i]\n          nb = b.dup\n          nx = judge(nb)\n          unless set.include?(nb)\n            set.add(nb)\n            q << [nx, nb, d + 1]\n          end\n          b[i], b[m] = b[m], b[i]\n        end\n      end\n    end\n  end\n  false\nend\n\nwhile n = gets.to_i\n  break if n == -1\n  ans = solve([n, 4.times.map{ gets.split.map(&:to_i) } ].flatten)\n  puts ans && ans <= 20 ? ans : 'NA'\nend"
  },
  {
    "language": "Ruby",
    "code": "def f h,n\nh[n]=0\nq=[n]\n(yield a=q.shift\n[a.index(0),a.rindex(0)].map{|j|[6,-6,1,-1].map{|i|a[k=i+j]>0&&(b=a.dup\nb[j],b[k]=b[k],b[j]\nh[b]||=(q<<b;h[a]+1))}})while q[0]&&h[q[0]]<11\nend\no=[-1]\nd=o*2\nf(g={},d+[0]+o*4+[*1..3]+d+[*4..8]+d+[*9..11]+o*4+[0]+o*6){}\nputs f(h={},d+[$_.to_i]+o*3+[1,0,1,2].flat_map{|i|o*i+gets.split.map(&:to_i)+o*i+o}+o*3){|a|g[a]&&(break h[a]+g[a])}||:NA while gets>?0"
  },
  {
    "language": "Ruby",
    "code": "start = \"fff0fff\" \"ff123ff\" \"f45678f\" \"ff9abff\" \"fff0fff\"\nresult = {}\nresult[start] = 0\nstack = [start]\n\nwhile (nxt = stack.shift)\n  doit = ->(idx) {\n    [1, -1, 7, -7].each do |di|\n      next_index = idx + di\n      next if next_index < 0 or next_index >= 35\n      next if (c = start[next_index]) == \"f\" or c == \"0\"\n      next_field = nxt.dup\n      next_field[idx] = c\n      next_field[next_index] = \"0\"\n      next if result[next_field]\n      result[next_field] = result[nxt] + 1\n      stack << next_field\n    end\n  }\n  doit.(nxt.index(\"0\"))\n  doit.(nxt.rindex(\"0\"))\nend\n\npat = Array.new(5)\nuntil (pat[0] = gets.to_i) == -1\n  pat[0] = pat[0].to_s(16).center(7, \"f\")\n  4.times {|i| pat[i + 1] = gets.split.map {|a| a.to_i.to_s(16)}.join.center(7, \"f\") }\n  num = result[pat.join]\n  puts num ? num : \"NA\"\nend\n"
  },
  {
    "language": "Ruby",
    "code": "### constant\n\nMAX_D = 10\nGOAL = ' ABCDEFGHIJK '\n\nNEIGHBORS = [\n  [2],\n  [2, 5],\n  [0, 1, 3, 6],\n  [2, 7],\n  [5],\n  [1, 4, 6, 9],\n  [2, 5, 7, 10],\n  [3, 6, 8, 11],\n  [7],\n  [5, 10],\n  [6, 9, 11, 12],\n  [7, 10],\n  [10]\n]\n\n### subroutines\n\ndef move(s, i, j)\n  s0 = s.clone\n  s0[i] = s0[j]\n  s0[j] = ' '\n  s0\nend\n\ndef neighbors(s)\n  nbrs = []\n\n  i0 = s.index(' ')\n  for ni in NEIGHBORS[i0]\n    nbrs << move(s, i0, ni)\n  end\n\n  i1 = s.index(' ', i0 + 1)\n  for ni in NEIGHBORS[i1]\n    nbrs << move(s, i1, ni)\n  end\n\n  nbrs\nend\n\n### main\n\ngdists = {}\ngdists[GOAL] = 0\nqueue = [GOAL]\n\nwhile ! queue.empty?\n  v = queue.shift\n  next if gdists[v] >= 10\n\n  for nv in neighbors(v)\n    if gdists[nv].nil?\n      gdists[nv] = gdists[v] + 1\n      queue << nv\n    end\n  end\nend\n\nwhile true\n  p1 = gets.strip.to_i\n  break if p1 == -1\n\n  ps = [p1]\n  4.times.each do\n    ps += gets.strip.split(' ').map{|s| s.to_i}\n  end\n\n  st = ps.map{|p| (p != 0) ? (p + 64).chr : ' '}.join('')\n\n  queue = [st]\n  dists = {}\n  dists[st] = 0\n\n  sumd = 'NA'\n\n  while ! queue.empty?\n    v = queue.shift\n    if ! gdists[v].nil?\n      sumd = dists[v] + gdists[v]\n      sumd = 'NA' if sumd > 20\n      break\n    end\n\n    next if dists[v] >= 10\n\n    for nv in neighbors(v)\n      if dists[nv].nil?\n        dists[nv] = dists[v] + 1\n        queue << nv\n      end\n    end\n  end\n\n  puts sumd\nend"
  },
  {
    "language": "Ruby",
    "code": "require 'set'\n \nMove = [ [2],\n         [2, 5], [0, 1, 3, 6], [2, 7],\n         [5], [1, 4, 6, 9], [2, 5, 7, 10], [3, 6, 8, 11], [7],\n         [5, 10], [6, 9, 11, 12], [7, 10],\n         [10] ]\nR = [0, 1, 1, 1, 2, 2, 2, 2, 2, 3, 3, 3, 4]\nC = [2, 1, 2, 3, 0, 1, 2, 3, 4, 1, 2, 3, 2]\n \ndef min_heapify(x = 1)\n  l = 2*x\n  r = 2*x+1\n  if l <= $n && $heap[l][0] < $heap[x][0]\n    minimum = l\n  else\n    minimum = x\n  end\n  if r <= $n && $heap[r][0] < $heap[minimum][0]\n    minimum = r\n  end\n  if minimum != x\n    $heap[x], $heap[minimum] = $heap[minimum], $heap[x]\n    min_heapify(minimum)\n  end\nend\n\ndef extract\n  key = $heap[1]\n  $heap[1] = $heap[$n]\n  $n -= 1\n  min_heapify\n  key\nend\n\ndef insert(key)\n  $n += 1\n  $heap[$n] = key\n  i = $n\n  while i > 1 && $heap[i/2][0] > $heap[i][0]\n    $heap[i], $heap[i/2] = $heap[i/2], $heap[i]\n    i /= 2\n  end\nend\n\ndef judge(brd, depth)\n  ret = depth\n  13.times do |i|\n    if brd[i] > 0\n      [R, C].each do |a|\n        ret += (a[i] - a[brd[i]]).abs\n      end\n    end\n  end\n  ret\nend\n \ndef solve(brd)\n  $heap = []\n  $n = 0\n  insert [judge(brd, 0), brd, 0]\n  set = Set.new([])\n  set.add(brd)\n  \n  until $heap.empty?\n    arr = extract\n    x, b, d = arr\n    return d if x == d\n    next if x > 20\n    13.times do |i|\n      if b[i] == 0\n        Move[i].each do |m|\n          b[i], b[m] = b[m], b[i]\n          nb = b.dup\n          nx = judge(nb, d + 1)\n          unless set.include?(nb)\n            set.add(nb)\n            insert [nx, nb, d + 1]\n          end\n          b[i], b[m] = b[m], b[i]\n        end\n      end\n    end\n  end\n  false\nend\n \nwhile n = gets.to_i\n  break if n == -1\n  ans = solve([n, 4.times.map{ gets.split.map(&:to_i) } ].flatten)\n  puts ans && ans <= 20 ? ans : 'NA'\nend"
  },
  {
    "language": "Ruby",
    "code": "require 'set'\nMove = [ [2, -1, -1, -1],\n         [2, 5, -1, -1], [0, 1, 3, 6], [2, 7, -1, -1],\n         [5, -1, -1, -1], [1, 4, 6, 9], [2, 5, 7, 10], [3, 6, 8, 11], [7, -1, -1, -1],\n         [5, 10, -1, -1], [6, 9, 11, 12], [7, 10, -1, -1],\n         [10, -1, -1, -1] ]\nR = [0, 1, 1, 1, 2, 2, 2, 2, 2, 3, 3, 3, 4]\nC = [2, 1, 2, 3, 0, 1, 2, 3, 4, 1, 2, 3, 2]\n\nset = SortedSet.new([])\nwhile n = gets.to_i\n  break if n == -1\n  brd = [n, 4.times.map{ gets.split.map(&:to_i) } ].flatten\n  q = [[brd, 0]]\n  ans = -1\n  set.add(brd)\n  until q.empty?\n    b, d = q.shift\n    if (1..11).all?{ |v| b[v] == v }\n      ans = d\n      break\n    end\n    x = d\n    13.times do |i|\n      if b[i] > 0\n        [R, C].each do |a|\n          x += (a[i] - a[b[i]]).abs\n        end\n      end\n    end\n    unless x > 20\n      13.times do |i|\n        if b[i] == 0\n          4.times do |j|\n            unless Move[i][j] == -1\n              b[i], b[Move[i][j]] = b[Move[i][j]], b[i]\n              unless set.include?(b)\n                set.add(nb = b.dup)\n                q << [nb, d + 1]\n              end\n              b[i], b[Move[i][j]] = b[Move[i][j]], b[i]\n            end\n          end\n        end\n      end\n    end\n  end\n  puts ans == -1 ? 'NA' : ans\nend"
  },
  {
    "language": "Ruby",
    "code": "require 'set'\n \nMove = [ [2],\n         [2, 5], [0, 1, 3, 6], [2, 7],\n         [5], [1, 4, 6, 9], [2, 5, 7, 10], [3, 6, 8, 11], [7],\n         [5, 10], [6, 9, 11, 12], [7, 10],\n         [10] ]\nR = [0, 1, 1, 1, 2, 2, 2, 2, 2, 3, 3, 3, 4]\nC = [2, 1, 2, 3, 0, 1, 2, 3, 4, 1, 2, 3, 2]\n \ndef judge(brd, depth)\n  ret = depth\n  13.times do |i|\n    if brd[i] > 0\n      [R, C].each do |a|\n        ret += (a[i] - a[brd[i]]).abs\n      end\n    end\n  end\n  ret\nend\n \ndef solve(brd)\n  q = [[judge(brd, 0), brd, 0]]\n  set = Set.new([])\n  set.add(brd)\n  until q.empty?\n    arr = q.shift\n    q.delete(arr)\n    x, b, d = arr\n    return d if (1..11).all?{ |v| b[v] == v }\n    next if x > 20\n    13.times do |i|\n      if b[i] == 0\n        Move[i].each do |m|\n          b[i], b[m] = b[m], b[i]\n          nb = b.dup\n          nx = judge(nb, d + 1)\n          unless set.include?(nb)\n            set.add(nb)\n            q << [nx, nb, d + 1]\n          end\n          b[i], b[m] = b[m], b[i]\n        end\n      end\n    end\n  end\n  false\nend\n \nwhile n = gets.to_i\n  break if n == -1\n  ans = solve([n, 4.times.map{ gets.split.map(&:to_i) } ].flatten)\n  puts ans && ans <= 20 ? ans : 'NA'\nend"
  },
  {
    "language": "Ruby",
    "code": "### constant\n\nMAX_D = 11\nGOAL = ' ABCDEFGHIJK '\n\nNEIGHBORS = [\n  [2],\n  [2, 5],\n  [0, 1, 3, 6],\n  [2, 7],\n  [5],\n  [1, 4, 6, 9],\n  [2, 5, 7, 10],\n  [3, 6, 8, 11],\n  [7],\n  [5, 10],\n  [6, 9, 11, 12],\n  [7, 10],\n  [10]\n]\n\n### subroutines\n\ndef move(s, i, j)\n  s0 = s.clone\n  s0[i] = s0[j]\n  s0[j] = ' '\n  s0\nend\n\ndef neighbors(s)\n  nbrs = []\n\n  for i in (0..12)\n    next if s[i] != ' '\n\n    for ni in NEIGHBORS[i]\n      nbrs << move(s, i, ni)\n    end\n  end\n\n  nbrs\nend\n\n### main\n\ngdists = {}\ngdists[GOAL] = 0\nqueue = [GOAL]\n\nwhile ! queue.empty?\n  v = queue.shift\n\n  for nv in neighbors(v)\n    if gdists[nv].nil?\n      gd = gdists[nv] = gdists[v] + 1\n      queue << nv if gd <= MAX_D\n    end\n  end\nend\n\nwhile true\n  p1 = gets.strip.to_i\n  break if p1 == -1\n\n  ps = [p1]\n  4.times.each do\n    ps += gets.strip.split(' ').map{|s| s.to_i}\n  end\n\n  st = ps.map{|p| (p != 0) ? (p + 64).chr : ' '}.join('')\n\n  queue = [st]\n  dists = {}\n  dists[st] = 0\n\n  d = 'NA'\n\n  while ! queue.empty?\n    v = queue.shift\n    if ! gdists[v].nil?\n      d = dists[v] + gdists[v]\n      break\n    end\n\n    for nv in neighbors(v)\n      if dists[nv].nil?\n        dist = dists[nv] = dists[v] + 1\n        queue << nv if dist <= MAX_D\n      end\n    end\n  end\n\n  puts d\nend"
  },
  {
    "language": "Ruby",
    "code": "start = \"fff0fff\" \"ff123ff\" \"f45678f\" \"ff9abff\" \"fff0fff\"\nresult = {}\nresult[start] = 0\nstack = [start]\n\nwhile (nxt = stack.shift)\n  next if result[nxt] >= 20\n  doit = ->(idx) {\n    [1, -1, 7, -7].each do |di|\n      next_index = idx + di\n      next if next_index < 0 or next_index >= 35\n      next if (c = nxt[next_index]) == \"f\" or c == \"0\"\n      next_field = nxt.dup\n      next_field[idx] = c\n      next_field[next_index] = \"0\"\n      next if result[next_field]\n      result[next_field] = result[nxt] + 1\n      stack << next_field\n    end\n  }\n  doit.(nxt.index(\"0\"))\n  doit.(nxt.rindex(\"0\"))\nend\n\npat = Array.new(5)\nuntil (pat[0] = $<.gets.chomp) == \"-1\"\n  pat[0] = pat[0].to_i.to_s(16).center(7, \"f\")\n  4.times {|i| pat[i + 1] = $<.gets.split.map {|a| a.to_i.to_s(16)}.join.center(7, \"f\") }\n  num = result[pat.join]\n  puts num ? num : \"NA\"\nend\n"
  },
  {
    "language": "Ruby",
    "code": "require 'set'\n\nMove = [ [2],\n         [2, 5], [0, 1, 3, 6], [2, 7],\n         [5], [1, 4, 6, 9], [2, 5, 7, 10], [3, 6, 8, 11], [7],\n         [5, 10], [6, 9, 11, 12], [7, 10],\n         [10] ]\nR = [0, 1, 1, 1, 2, 2, 2, 2, 2, 3, 3, 3, 4]\nC = [2, 1, 2, 3, 0, 1, 2, 3, 4, 1, 2, 3, 2]\n\ndef judge(brd)\n  ret = 0\n  13.times do |i|\n    if brd[i] > 0\n      [R, C].each do |a|\n        ret += (a[i] - a[brd[i]]).abs\n      end\n    end\n  end\n  ret\nend\n\ndef solve(brd)\n  q = [[judge(brd), brd, 0]]\n  set = Set.new([])\n  set.add(brd)\n  until q.empty?\n    arr = q.min{ |a, b| a <=> b }\n    q.delete(arr)\n    x, b, d = arr\n    next if x + d > 20\n    13.times do |i|\n      if b[i] == 0\n        Move[i].each do |m|\n          b[i], b[m] = b[m], b[i]\n          nb = b.dup\n          nx = judge(nb)\n          return d + 1 if nx == 0\n          unless set.include?(nb)\n            set.add(nb)\n            q << [nx, nb, d + 1]\n          end\n          b[i], b[m] = b[m], b[i]\n        end\n      end\n    end\n  end\n  false\nend\n\nwhile n = gets.to_i\n  break if n == -1\n  ans = solve([n, 4.times.map{ gets.split.map(&:to_i) } ].flatten)\n  puts ans ? ans : 'NA'\nend"
  },
  {
    "language": "Ruby",
    "code": "Next = [\n  [nil, nil, 2, nil],\n  [nil, 2, 5, nil],\n  [0, 3, 6, 1],\n  [nil, nil, 7, 2],\n  [nil, 5, nil, nil],\n  [1, 6, 9, 4],\n  [2, 7, 10, 5],\n  [3, 8, 11, 6],\n  [nil, nil, nil, 7],\n  [5, 10, nil, nil],\n  [6, 11, 12, 9],\n  [7, nil, nil, 10],\n  [10, nil, nil, nil],\n]\n\ndef copy(target)\n  Marshal.load(Marshal.dump(target))\nend\n\ndef bfs(original_puzzle, memo)\n  q = [[original_puzzle, 0]]\n  until q.empty?\n    puzzle, depth = q.shift\n    next if depth > 10\n    next if memo[puzzle]\n    memo[puzzle] = depth\n\n    i1 = puzzle.index(0)\n    i2 = puzzle[i1 + 1, puzzle.size].index(0) + i1 + 1\n    [i1, i2].each do |i|\n      Next[i].each do |j|\n        next unless j\n        _puzzle = copy(puzzle)\n        _puzzle[i], _puzzle[j] = _puzzle[j], _puzzle[i]\n        q << [_puzzle, depth + 1]\n      end\n    end\n  end\nend\n\n@memo1 = Hash.new\nbfs([*0..11, 0], @memo1)\n\nuntil (puzzle = [gets.to_i]) == [-1]\n  puzzle += 4.times.map{gets.split.map(&:to_i)}.flatten\n\n  @memo2 = Hash.new\n  bfs(puzzle, @memo2)\n\n  answer = 21\n  @memo1.keys.each do |k|\n    next unless @memo2[k]\n    answer = [answer, @memo1[k] + @memo2[k]].min\n  end\n  puts (answer > 20 ? \"NA\" : answer)\nend"
  },
  {
    "language": "Ruby",
    "code": "require 'set'\n\n# ??????: ???????????¢?´¢\n\n# ??£\nNB = [\n  [2],\n  [5, 2],\n  [0, 1, 3, 6],\n  [2, 7],\n  [5],\n  [1, 4, 6, 9],\n  [2, 5, 7, 10],\n  [3, 6, 8, 11],\n  [7],\n  [5, 10],\n  [6, 9, 11, 12],\n  [10, 7],\n  [10]\n]\n\nY = [0, 1, 1, 1, 2, 2, 2, 2, 2, 3, 3, 3, 4]\nX = [2, 1, 2, 3, 0, 1, 2, 3, 4, 1, 2, 3, 2]\n\ndef solve(field)\n  queue = []\n  queue << [field, 0]\n  used = Set.new\n  dist = -1\n  prev_dist = -1\n  until queue.empty?\n    f, dist = queue.shift\n    break if f == [0, 1, 2, 3, 4, 5, 6, 7, 8, 9, 10, 11, 0]\n    res = f.each_with_index.inject(0) {|accum, (v, i)|\n      accum + (i != 0 ? (X[v] - X[i % 12]).abs + (Y[v] - Y[i % 12]).abs : 0)\n    }\n    next if ((res / 2) + dist) > 20\n    f.each.with_index do |v, i|\n      next unless v == 0\n      NB[i].each do |t|\n        f[i], f[t] = f[t], f[i]\n        unless used.include? f\n          nf = f.clone\n          used.add(nf)\n          queue << [nf, dist + 1]\n        end\n        f[i], f[t] = f[t], f[i]\n      end\n    end\n    # p \"N: #{prev_dist = dist}\" if prev_dist < dist\n  end\n  return nil if queue.empty?\n  dist\nend\n\nloop do\n  v = gets.to_i\n  break if v == -1\n  field = (1..4).map { gets.split(\" \").map(&:to_i) }\n  res = solve(([[v]] + field).flatten)\n  puts res.nil? ? \"NA\" : res\nend"
  },
  {
    "language": "Ruby",
    "code": "require 'set'\n\n# ??????: ???????????¢?´¢\n\n# ??£\nNB = [\n  [2],\n  [5, 2],\n  [0, 1, 3, 6],\n  [2, 7],\n  [5],\n  [1, 4, 6, 9],\n  [2, 5, 7, 10],\n  [3, 6, 8, 11],\n  [7],\n  [5, 10],\n  [6, 9, 11, 12],\n  [10, 7],\n  [10]\n]\n\nY = [0, 1, 1, 1, 2, 2, 2, 2, 2, 3, 3, 3, 4]\nX = [2, 1, 2, 3, 0, 1, 2, 3, 4, 1, 2, 3, 2]\n\ndef solve(field)\n  queue = []\n  queue << [field, 0]\n  used = Set.new\n  dist = -1\n  prev_dist = -1\n  until queue.empty?\n    f, dist = queue.shift\n    return dist if f == [0, 1, 2, 3, 4, 5, 6, 7, 8, 9, 10, 11, 0]\n    d = dist\n    13.times do |i|\n      next if (i%12) == 0\n      d += (X[f[i]] - X[i]).abs + (Y[f[i]] - Y[i]).abs\n    end\n    next if d > 20\n    13.times do |i|\n      next if f[i] != 0\n      NB[i].each do |t|\n        f[i], f[t] = f[t], f[i]\n        unless used.include? f\n          nf = f.clone\n          used.add(nf)\n          queue << [nf, dist + 1]\n        end\n        f[i], f[t] = f[t], f[i]\n      end\n    end\n    # p \"N: #{prev_dist = dist}\" if prev_dist < dist\n  end\n  return -1 if queue.empty?\n  dist\nend\n\nloop do\n  v = gets.to_i\n  break if v == -1\n  field = (1..4).map { gets.split(\" \").map(&:to_i) }\n  res = solve(([[v]] + field).flatten)\n  puts (res == -1) ? \"NA\" : res\nend"
  },
  {
    "language": "Ruby",
    "code": "start = \"fff0fff\" \"ff123ff\" \"f45678f\" \"ff9abff\" \"fff0fff\"\nresult1 = {}\nresult1[start] = 0\nstack = [start]\n\nwhile (nxt = stack.shift)\n  next if result1[nxt] >= 10\n  doit1 = ->(idx) {\n    [1, -1, 7, -7].each do |di|\n      next_index = idx + di\n      next if next_index < 0 or next_index >= 35\n      next if (c = nxt[next_index]) == \"f\" or c == \"0\"\n      next_field = nxt.dup\n      next_field[idx] = c\n      next_field[next_index] = \"0\"\n      next if result1[next_field]\n      result1[next_field] = result1[nxt] + 1\n      stack << next_field\n    end\n  }\n  doit1.(nxt.index(\"0\"))\n  doit1.(nxt.rindex(\"0\"))\nend\n\npat = Array.new(5)\nuntil (pat[0] = gets.to_i) == -1\n  pat[0] = pat[0].to_s(16).center(7, \"f\")\n  4.times {|i| pat[i + 1] = gets.split.map {|a| a.to_i.to_s(16)}.join.center(7, \"f\") }\n  \n  if (ans = result1[start = pat.join])\n    puts ans\n    next\n  end\n  \n  result2 = {}\n  result2[start] = 0\n  stack = [start]\n  str = \"NA\"\n  f = true\n  \n  while (nxt = stack.shift) and f\n    next if result2[nxt] >= 10\n    doit2 = ->(idx) {\n      [1, -1, 7, -7].each do |di|\n        next_index = idx + di\n        next if next_index < 0 or next_index >= 35\n        next if (c = nxt[next_index]) == \"f\" or c == \"0\"\n        next_field = nxt.dup\n        next_field[idx] = c\n        next_field[next_index] = \"0\"\n        next if result2[next_field]\n        if result1[next_field]\n          str = (result1[next_field] + result2[nxt] + 1).to_s\n          return false\n        end\n        result2[next_field] = result2[nxt] + 1\n        stack << next_field\n      end\n      true\n    }\n    f = doit2.(nxt.index(\"0\"))\n    f = doit2.(nxt.rindex(\"0\")) if f\n  end\n  puts str\nend\n"
  },
  {
    "language": "Ruby",
    "code": "start = \"fff0fff\" \"ff123ff\" \"f45678f\" \"ff9abff\" \"fff0fff\"\nresult = {}\nresult[start] = 0\nstack = [start]\n\nwhile (nxt = stack.shift)\n  doit = ->(idx) {\n    [1, -1, 7, -7].each do |di|\n      next_index = idx + di\n      next if next_index < 0 or next_index >= 35\n      next if (c = start[next_index]) == \"f\" or c == \"0\"\n      next_field = nxt.dup\n      next_field[idx] = c\n      next_field[next_index] = \"0\"\n      next if result[next_field]\n      result[next_field] = result[nxt] + 1\n      stack << next_field\n    end\n  }\n  doit.(nxt.index(\"0\"))\n  doit.(nxt.rindex(\"0\"))\nend\n\npat = Array.new(5)\nuntil (pat[0] = gets.to_i) == -1\n  pat[0] = pat[0].to_s(16).center(7, \"f\")\n  4.times {|i| pat[i + 1] = gets.split.map {|a| a.to_i.to_s(16)}.join.center(7, \"f\") }\n  num = result[pat.join]\n  puts num ? num : \"NA\"\nend\n"
  },
  {
    "language": "Ruby",
    "code": "start = \"fff0fff\" \"ff123ff\" \"f45678f\" \"ff9abff\" \"fff0fff\"\nresult = {}\nresult[start] = 0\nstack = [start]\n\nwhile (nxt = stack.shift)\n  doit = ->(idx) {\n    [1, -1, 7, -7].each do |di|\n      next_index = idx + di\n      next if next_index < 0 or next_index >= 35\n      next if (c = start[next_index]) == \"f\" or c == \"0\"\n      next_field = nxt.dup\n      next_field[idx] = c\n      next_field[next_index] = \"0\"\n      next if result[next_field]\n      result[next_field] = result[nxt] + 1\n      stack << next_field\n    end\n  }\n  doit.(nxt.index(\"0\"))\n  doit.(nxt.rindex(\"0\"))\nend\n\npat = Array.new(5)\nuntil (pat[0] = $<.gets.chomp) == \"-1\"\n  pat[0] = pat[0].to_i.to_s(16).center(7, \"f\")\n  4.times {|i| pat[i + 1] = $<.gets.split.map {|a| a.to_i.to_s(16)}.join.center(7, \"f\") }\n  num = result[pat.join]\n  puts num ? num : \"NA\"\nend\n"
  },
  {
    "language": "Ruby",
    "code": "start = \"fff0fff\" \"ff123ff\" \"f45678f\" \"ff9abff\" \"fff0fff\"\nresult = {}\nresult[start] = 0\nstack = [start]\n\nwhile (nxt = stack.shift)\n  doit = ->(idx) {\n    [1, -1, 7, -7].each do |di|\n      next_index = idx + di\n      next if next_index < 0 or next_index >= 35\n      next if (c = start[next_index]) == \"f\" or c == \"0\"\n      next_field = nxt.dup\n      next_field[idx] = c\n      next_field[next_index] = \"0\"\n      next if result[next_field]\n      result[next_field] = result[nxt] + 1\n      stack << next_field\n    end\n  }\n  doit.(nxt.index(\"0\"))\n  doit.(nxt.rindex(\"0\", -1))\nend\n\npat = Array.new(5)\nuntil (pat[0] = gets.chomp) == \"-1\"\n  pat[0] = pat[0].to_i.to_s(16).center(7, \"f\")\n  4.times {|i| pat[i + 1] = gets.split.map {|a| a.to_i.to_s(16)}.join.center(7, \"f\") }\n  num = result[pat.join]\n  puts num ? num : \"NA\"\nend\n"
  },
  {
    "language": "Ruby",
    "code": "require 'set'\n\nMove = [ [2],\n         [2, 5], [0, 1, 3, 6], [2, 7],\n         [5], [1, 4, 6, 9], [2, 5, 7, 10], [3, 6, 8, 11], [7],\n         [5, 10], [6, 9, 11, 12], [7, 10],\n         [10] ]\nR = [0, 1, 1, 1, 2, 2, 2, 2, 2, 3, 3, 3, 4]\nC = [2, 1, 2, 3, 0, 1, 2, 3, 4, 1, 2, 3, 2]\n\ndef judge(brd)\n  ret = 0\n  13.times do |i|\n    if brd[i] > 0\n      [R, C].each do |a|\n        ret += (a[i] - a[brd[i]]).abs\n      end\n    end\n  end\n  ret\nend\n\ndef solve(brd)\n  q = [[judge(brd), brd, 0]]\n  set = Set.new([])\n  set.add(brd)\n  until q.empty?\n    arr = q.min{ |a, b| a <=> b }\n    q.delete(arr)\n    x, b, d = arr\n    return d if (1..11).all?{ |v| b[v] == v }\n    next if x + d > 20\n    13.times do |i|\n      if b[i] == 0\n        Move[i].each do |m|\n          b[i], b[m] = b[m], b[i]\n          nb = b.dup\n          nx = judge(nb)\n          unless set.include?(nb)\n            set.add(nb)\n            q << [nx, nb, d + 1]\n          end\n          b[i], b[m] = b[m], b[i]\n        end\n      end\n    end\n  end\n  false\nend\n\nwhile n = gets.to_i\n  break if n == -1\n  ans = solve([n, 4.times.map{ gets.split.map(&:to_i) } ].flatten)\n  puts ans ? ans : 'NA'\nend"
  },
  {
    "language": "Ruby",
    "code": "def f h,n,m\nh[n]=0\nq=[n]\n(yield a=q.shift\n[a.index(0),a.rindex(0)].map{|j|[6,-6,1,-1].map{|i|a[k=i+j]>0&&(b=a.dup\nb[j],b[k]=b[k],b[j]\nh[b]||=(q<<b;h[a]+1))}})while q[0]&&h[q[0]]<m\nend\no=[-1]\nd=o*2\nf(g={},d+[0]+o*4+[*1..3]+d+[*4..8]+d+[*9..11]+o*4+[0]+o*6,12){}\nputs f(h={},d+[$_.to_i]+o*3+[1,0,1,2].flat_map{|i|o*i+gets.split.map(&:to_i)+o*i+o}+o*3,10){|a|g[a]&&(break h[a]+g[a])}||:NA while gets>?0"
  },
  {
    "language": "Ruby",
    "code": "require 'set'\nMove = [ [2, -1, -1, -1],\n         [2, 5, -1, -1], [0, 1, 3, 6], [2, 7, -1, -1],\n         [5, -1, -1, -1], [1, 4, 6, 9], [2, 5, 7, 10], [3, 6, 8, 11], [7, -1, -1, -1],\n         [5, 10, -1, -1], [6, 9, 11, 12], [7, 10, -1, -1],\n         [10, -1, -1, -1] ]\nR = [0, 1, 1, 1, 2, 2, 2, 2, 2, 3, 3, 3, 4]\nC = [2, 1, 2, 3, 0, 1, 2, 3, 4, 1, 2, 3, 2]\n\nset = SortedSet.new([])\nwhile n = gets.to_i\n  break if n == -1\n  brd = [n, 4.times.map{ gets.split.map(&:to_i) } ].flatten\n  q = [[brd, 0]]\n  ans = -1\n  set.add(brd)\n  until q.empty?\n    b, d = q.shift\n    if (1..11).all?{ |v| b[v] == v }\n      ans = d\n      break\n    end\n    x = d\n    13.times do |i|\n      if b[i] > 0\n        [R, C].each do |a|\n          x += [(a[i] - a[b[i]]).abs, -(a[i] - a[b[i]]).abs].max\n        end\n      end\n    end\n    unless x > 20\n      13.times do |i|\n        if b[i] == 0\n          4.times do |j|\n            unless Move[i][j] == -1\n              b[i], b[Move[i][j]] = b[Move[i][j]], b[i]\n              unless set.include?(b)\n                set.add(nb = b.dup)\n                q << [nb, d + 1]\n              end\n              b[i], b[Move[i][j]] = b[Move[i][j]], b[i]\n            end\n          end\n        end\n      end\n    end\n  end\n  puts ans == -1 ? 'NA' : ans\nend"
  },
  {
    "language": "Ruby",
    "code": "require 'set'\nMove = [ [2, -1, -1, -1],\n         [2, 5, -1, -1], [0, 1, 3, 6], [2, 7, -1, -1],\n         [5, -1, -1, -1], [1, 4, 6, 9], [2, 5, 7, 10], [3, 6, 8, 11], [7, -1, -1, -1],\n         [5, 10, -1, -1], [6, 9, 11, 12], [7, 10, -1, -1],\n         [10, -1, -1, -1] ]\nR = [0, 1, 1, 1, 2, 2, 2, 2, 2, 3, 3, 3, 4]\nC = [2, 1, 2, 3, 0, 1, 2, 3, 4, 1, 2, 3, 2]\n \n\nwhile n = gets.to_i\n  break if n == -1\n  brd = [n, 4.times.map{ gets.split.map(&:to_i) } ].flatten\n  q = [[brd, 0]]\n  ans = -1\n  set = Set.new([])\n  set.add(brd)\n  until q.empty?\n    b, d = q.shift\n    if (1..11).all?{ |v| b[v] == v }\n      ans = d\n      break\n    end\n    x = d\n    13.times do |i|\n      if b[i] > 0\n        [R, C].each do |a|\n          x += (a[i] - a[b[i]]).abs\n        end\n      end\n    end\n    unless x > 20\n      13.times do |i|\n        if b[i] == 0\n          4.times do |j|\n            unless Move[i][j] == -1\n              b[i], b[Move[i][j]] = b[Move[i][j]], b[i]\n              unless set.include?(b)\n                set.add(nb = b.dup)\n                q << [nb, d + 1]\n              end\n              b[i], b[Move[i][j]] = b[Move[i][j]], b[i]\n            end\n          end\n        end\n      end\n    end\n  end\n  puts ans == -1 ? 'NA' : ans\nend"
  },
  {
    "language": "Ruby",
    "code": "start = \"fff0fff\" \"ff123ff\" \"f45678f\" \"ff9abff\" \"fff0fff\"\nresult = {}\nresult[start] = 0\nstack = [start]\n\nwhile (nxt = stack.shift)\n  next if result[nxt] >= 20\n  doit = ->(idx) {\n    [1, -1, 7, -7].each do |di|\n      next_index = idx + di\n      next if next_index < 0 or next_index >= 35\n      next if (c = start[next_index]) == \"f\" or c == \"0\"\n      next_field = nxt.dup\n      next_field[idx] = c\n      next_field[next_index] = \"0\"\n      next if result[next_field]\n      result[next_field] = result[nxt] + 1\n      stack << next_field\n    end\n  }\n  doit.(nxt.index(\"0\"))\n  doit.(nxt.rindex(\"0\"))\nend\n\npat = Array.new(5)\nuntil (pat[0] = $<.gets.chomp) == \"-1\"\n  pat[0] = pat[0].to_i.to_s(16).center(7, \"f\")\n  4.times {|i| pat[i + 1] = $<.gets.split.map {|a| a.to_i.to_s(16)}.join.center(7, \"f\") }\n  num = result[pat.join]\n  puts num ? num : \"NA\"\nend\n"
  },
  {
    "language": "Ruby",
    "code": "require 'set'\nMove = [ [2, -1, -1, -1],\n         [2, 5, -1, -1], [0, 1, 3, 6], [2, 7, -1, -1],\n         [5, -1, -1, -1], [1, 4, 6, 9], [2, 5, 7, 10], [3, 6, 8, 11], [7, -1, -1, -1],\n         [5, 10, -1, -1], [6, 9, 11, 12], [7, 10, -1, -1],\n         [10, -1, -1, -1] ]\nR = [0, 1, 1, 1, 2, 2, 2, 2, 2, 3, 3, 3, 4]\nC = [2, 1, 2, 3, 0, 1, 2, 3, 4, 1, 2, 3, 2]\n\ninclude Comparable\nset = Set.new([])\nwhile n = gets.to_i\n  break if n == -1\n  brd = [n, *4.times.flat_map{ gets.split.map(&:to_i) } ].flatten\n  q = [[brd, 0]]\n  ans = -1\n  set.add(brd)\n  until q.empty?\n    b, d = q.shift\n    if b.all?{ |v| b.index(v) == v}\n      ans = d\n      break\n    end\n    x = d\n    13.times do |i|\n      if b[i] > 0\n        [R, C].each do |a|\n          x += [(a[i] - a[b[i]]).abs, -(a[i] - a[b[i]]).abs].max\n        end\n      end\n    end\n    unless x > 20\n      13.times do |i|\n        if b[i] == 0\n          4.times do |j|\n            unless Move[i][j] != -1\n              b[i], b[Move[i][j]] = b[Move[i][j]], b[i]\n              unless set.include?(b)\n                set.add(b)\n                q << [b, d + 1]\n              end\n              b[i], b[Move[i][j]] = b[Move[i][j]], b[i]\n            end\n          end\n        end\n      end\n    end\n  end\n  p ans\nend"
  },
  {
    "language": "Ruby",
    "code": "require 'set'\n\n# ??????: ???????????¢?´¢\n\n# ??£\nNB = [\n  [2],\n  [5, 2],\n  [0, 1, 3, 6],\n  [2, 7],\n  [5],\n  [1, 4, 6, 9],\n  [2, 5, 7, 10],\n  [3, 6, 8, 11],\n  [7],\n  [5, 10],\n  [6, 9, 11, 12],\n  [10, 7],\n  [10]\n]\n\nY = [0, 1, 1, 1, 2, 2, 2, 2, 2, 3, 3, 3, 4]\nX = [2, 1, 2, 3, 0, 1, 2, 3, 4, 1, 2, 3, 2]\n\ndef solve(field)\n  queue = []\n  queue << [field, 0]\n  used = Set.new\n  dist = -1\n  prev_dist = -1\n  until queue.empty?\n    f, dist = queue.shift\n    break if f == [0, 1, 2, 3, 4, 5, 6, 7, 8, 9, 10, 11, 0]\n    res = f.each_with_index.inject(0) {|accum, (v, i)|\n      if i != 0\n        accum + (X[v] - X[i % 12]).abs + (Y[v] - Y[i % 12]).abs\n      elsif i == 0\n        accum + [(X[v] - X[0]).abs + (Y[v] - Y[0]).abs,\n                 (X[v] - X[12]).abs + (Y[v] - Y[12]).abs].min\n      end\n    }\n    return nil if (res / 2) + dist > 20\n    f.each.with_index do |v, i|\n      next unless v == 0\n      NB[i].each do |t|\n        f[i], f[t] = f[t], f[i]\n        unless used.include? f\n          nf = f.clone\n          used.add(nf)\n          queue << [nf, dist + 1]\n        end\n        f[i], f[t] = f[t], f[i]\n      end\n    end\n    # p \"N: #{prev_dist = dist}\" if prev_dist < dist\n  end\n  dist\nend\n\nloop do\n  v = gets.to_i\n  break if v == -1\n  field = (1..4).map { gets.split(\" \").map(&:to_i) }\n  res = solve(([[v]] + field).flatten)\n  puts res.nil? ? \"NA\" : res\nend"
  },
  {
    "language": "Ruby",
    "code": "require 'set'\nMove = [ [2],\n         [2, 5], [0, 1, 3, 6], [2, 7],\n         [5], [1, 4, 6, 9], [2, 5, 7, 10], [3, 6, 8, 11], [7],\n         [5, 10], [6, 9, 11, 12], [7, 10],\n         [10] ]\nR = [0, 1, 1, 1, 2, 2, 2, 2, 2, 3, 3, 3, 4]\nC = [2, 1, 2, 3, 0, 1, 2, 3, 4, 1, 2, 3, 2]\n\nwhile n = gets.to_i\n  break if n == -1\n  brd = [n, 4.times.map{ gets.split.map(&:to_i) } ].flatten\n  q = [[brd, 0]]\n  ans = -1\n  set = Set.new([])\n  set.add(brd)\n  until q.empty?\n    b, d = q.shift\n    if (1..11).all?{ |v| b[v] == v }\n      ans = d\n      break\n    end\n    x = d\n    13.times do |i|\n      if b[i] > 0\n        [R, C].each do |a|\n          x += (a[i] - a[b[i]]).abs\n        end\n      end\n    end\n    unless x > 20\n      13.times do |i|\n        if b[i] == 0\n          Move[i].each do |m|\n            b[i], b[m] = b[m], b[i]\n            unless set.include?(b)\n              set.add(nb = b.dup)\n              q << [nb, d + 1]\n            end\n            b[i], b[m] = b[m], b[i]\n          end\n        end\n      end\n    end\n  end\n  puts ans == -1 ? 'NA' : ans\nend"
  },
  {
    "language": "Ruby",
    "code": "require 'set'\n \nMove = [ [2],\n         [2, 5], [0, 1, 3, 6], [2, 7],\n         [5], [1, 4, 6, 9], [2, 5, 7, 10], [3, 6, 8, 11], [7],\n         [5, 10], [6, 9, 11, 12], [7, 10],\n         [10] ]\nR = [0, 1, 1, 1, 2, 2, 2, 2, 2, 3, 3, 3, 4]\nC = [2, 1, 2, 3, 0, 1, 2, 3, 4, 1, 2, 3, 2]\n \ndef min_heapify(x = 1)\n  l = 2*x\n  r = 2*x+1\n  if l <= $n && $heap[l][0] < $heap[x][0]\n    minimum = l\n  else\n    minimum = x\n  end\n  if r <= $n && $heap[r][0] < $heap[minimum][0]\n    minimum = r\n  end\n  if minimum != x\n    $heap[x], $heap[minimum] = $heap[minimum], $heap[x]\n    min_heapify(minimum)\n  end\nend\n\ndef extract\n  key = $heap[1]\n  $heap[1] = $heap[$n]\n  $n -= 1\n  min_heapify\n  key\nend\n\ndef insert(key)\n  $n += 1\n  $heap[$n] = key\n  i = $n\n  while i > 1 && $heap[i/2][0] > $heap[i][0]\n    $heap[i], $heap[i/2] = $heap[i/2], $heap[i]\n    i /= 2\n  end\nend\n\ndef judge(brd, depth)\n  ret = depth\n  13.times do |i|\n    if brd[i] > 0\n      [R, C].each do |a|\n        ret += (a[i] - a[brd[i]]).abs\n      end\n    end\n  end\n  ret\nend\n \ndef solve(brd)\n  $heap = []\n  $n = 0\n  insert [judge(brd, 0), brd, 0]\n  set = Set.new([])\n  set.add(brd)\n\n  while $n > 0\n    arr = extract\n    x, b, d = arr\n    return d if (1..11).all?{ |v| b[v] == v }\n    next if x > 20\n    13.times do |i|\n      if b[i] == 0\n        Move[i].each do |m|\n          b[i], b[m] = b[m], b[i]\n          nb = b.dup\n          nx = judge(nb, d + 1)\n          unless set.include?(nb)\n            set.add(nb)\n            insert [nx, nb, d + 1]\n          end\n          b[i], b[m] = b[m], b[i]\n        end\n      end\n    end\n  end\n  false\nend\n \nwhile n = gets.to_i\n  break if n == -1\n  ans = solve([n, 4.times.map{ gets.split.map(&:to_i) } ].flatten)\n  puts ans && ans <= 20 ? ans : 'NA'\nend"
  },
  {
    "language": "Ruby",
    "code": "require 'set'\n\n# ??????: ???????????¢?´¢\n\n# ??£\nNB = [\n  [2],\n  [5, 2],\n  [0, 1, 3, 6],\n  [2, 7],\n  [5],\n  [1, 4, 6, 9],\n  [2, 5, 7, 10],\n  [3, 6, 8, 11],\n  [7],\n  [5, 10],\n  [6, 9, 11, 12],\n  [10, 7],\n  [10]\n]\n\nY = [0, 1, 1, 1, 2, 2, 2, 2, 2, 3, 3, 3, 4]\nX = [2, 1, 2, 3, 0, 1, 2, 3, 4, 1, 2, 3, 2]\n\ndef solve(field)\n  queue = []\n  queue << [field, 0]\n  used = Set.new\n  dist = -1\n  prev_dist = -1\n  until queue.empty?\n    f, dist = queue.shift\n    return dist if f == [0, 1, 2, 3, 4, 5, 6, 7, 8, 9, 10, 11, 0]\n    d = dist\n    13.times do |i|\n      d += (f[i] != 0 ? (X[f[i]] - X[i%12]).abs + (Y[f[i]] - Y[i%12]).abs : 0)\n    end\n    next if d > 20\n    13.times do |i|\n      next if f[i] != 0\n      NB[i].each do |t|\n        f[i], f[t] = f[t], f[i]\n        unless used.include? f\n          nf = f.clone\n          used.add(nf)\n          queue << [nf, dist + 1]\n        end\n        f[i], f[t] = f[t], f[i]\n      end\n    end\n    # p \"N: #{prev_dist = dist}\" if prev_dist < dist\n  end\n  return -1 if queue.empty?\n  dist\nend\n\nloop do\n  v = gets.to_i\n  break if v == -1\n  field = (1..4).map { gets.split(\" \").map(&:to_i) }\n  res = solve(([[v]] + field).flatten)\n  puts (res == -1) ? \"NA\" : res\nend"
  },
  {
    "language": "Ruby",
    "code": "require 'set'\n\n# ??????: ???????????¢?´¢\n\n# ??£\nNB = [\n  [2],\n  [5, 2],\n  [0, 1, 3, 6],\n  [2, 7],\n  [5],\n  [1, 4, 6, 9],\n  [2, 5, 7, 10],\n  [3, 6, 8, 11],\n  [7],\n  [5, 10],\n  [6, 9, 11, 12],\n  [10, 7],\n  [10]\n]\n\nY = [0, 1, 1, 1, 2, 2, 2, 2, 2, 3, 3, 3, 4]\nX = [2, 1, 2, 3, 0, 1, 2, 3, 4, 1, 2, 3, 2]\n\ndef solve(field)\n  queue = []\n  queue << [field, 0]\n  used = Set.new\n  dist = -1\n  prev_dist = -1\n  until queue.empty?\n    f, dist = queue.shift\n    return dist if f == [0, 1, 2, 3, 4, 5, 6, 7, 8, 9, 10, 11, 0]\n    res = f.each_with_index.inject(0) {|accum, (v, i)|\n      accum + (v != 0 ? (X[v] - X[i%12]).abs + (Y[v] - Y[i%12]).abs : 0)\n    }\n    next if ((res / 2) + dist) > 20\n    f.each.with_index do |v, i|\n      next unless v == 0\n      NB[i].each do |t|\n        f[i], f[t] = f[t], f[i]\n        unless used.include? f\n          nf = f.clone\n          used.add(nf)\n          queue << [nf, dist + 1]\n        end\n        f[i], f[t] = f[t], f[i]\n      end\n    end\n    # p \"N: #{prev_dist = dist}\" if prev_dist < dist\n  end\n  return -1 if queue.empty?\n  dist\nend\n\nloop do\n  v = gets.to_i\n  break if v == -1\n  field = (1..4).map { gets.split(\" \").map(&:to_i) }\n  res = solve(([[v]] + field).flatten)\n  puts (res == -1) ? \"NA\" : res\nend"
  },
  {
    "language": "Ruby",
    "code": "require 'set'\n\nMove = [ [2],\n         [2, 5], [0, 1, 3, 6], [2, 7],\n         [5], [1, 4, 6, 9], [2, 5, 7, 10], [3, 6, 8, 11], [7],\n         [5, 10], [6, 9, 11, 12], [7, 10],\n         [10] ]\nR = [0, 1, 1, 1, 2, 2, 2, 2, 2, 3, 3, 3, 4]\nC = [2, 1, 2, 3, 0, 1, 2, 3, 4, 1, 2, 3, 2]\n\ndef judge(brd, d)\n  x = d\n  13.times do |i|\n    if brd[i] > 0\n      [R, C].each do |a|\n        x += (a[i] - a[brd[i]]).abs\n      end\n    end\n  end\n  x\nend\n\nwhile n = gets.to_i\n  break if n == -1\n  brd = [n, 4.times.map{ gets.split.map(&:to_i) } ].flatten\n  q = [[judge(brd, 0), brd, 0]]\n  ans = -1\n  set = Set.new([])\n  set.add(brd)\n  until q.empty?\n    arr = q.min{ |x, y| x[0] <=> y[0] }\n    q.delete(arr)\n    j, b, d = arr\n    next if j > 20\n    if j == d\n      ans = d\n      break\n    end\n    13.times do |i|\n      if b[i] == 0\n        Move[i].each do |m|\n          b[i], b[m] = b[m], b[i]\n          unless set.include?(b)\n            set.add(nb = b.dup)\n            q << [judge(nb, d + 1), nb, d + 1]\n          end\n          b[i], b[m] = b[m], b[i]\n        end\n      end\n    end\n  end\n  puts ans == -1 ? 'NA' : ans\nend"
  },
  {
    "language": "Ruby",
    "code": "### constant\n\nMAX_D = 12\nGOAL = ' ABCDEFGHIJK '\n\nNEIGHBORS = [\n  [2],\n  [2, 5],\n  [0, 1, 3, 6],\n  [2, 7],\n  [5],\n  [1, 4, 6, 9],\n  [2, 5, 7, 10],\n  [3, 6, 8, 11],\n  [7],\n  [5, 10],\n  [6, 9, 11, 12],\n  [7, 10],\n  [10]\n]\n\n### subroutines\n\ndef move(s, i, j)\n  s0 = s.clone\n  s0[i] = s0[j]\n  s0[j] = ' '\n  s0\nend\n\ndef neighbors(s)\n  nbrs = []\n\n  for i in (0..12)\n    next if s[i] != ' '\n\n    for ni in NEIGHBORS[i]\n      nbrs << move(s, i, ni)\n    end\n  end\n\n  nbrs\nend\n\n### main\n\ngdists = {}\ngdists[GOAL] = 0\nqueue = [GOAL]\n\nwhile ! queue.empty?\n  v = queue.shift\n\n  for nv in neighbors(v)\n    if gdists[nv].nil?\n      gd = gdists[nv] = gdists[v] + 1\n      queue << nv if gd <= MAX_D\n    end\n  end\nend\n\nwhile true\n  p1 = gets.strip.to_i\n  break if p1 == -1\n\n  ps = [p1]\n  4.times.each do\n    ps += gets.strip.split(' ').map{|s| s.to_i}\n  end\n\n  st = ps.map{|p| (p != 0) ? (p + 64).chr : ' '}.join('')\n\n  queue = [st]\n  dists = {}\n  dists[st] = 0\n\n  d = 'NA'\n\n  while ! queue.empty?\n    v = queue.shift\n    if ! gdists[v].nil?\n      d = dists[v] + gdists[v]\n      break\n    end\n\n    for nv in neighbors(v)\n      if dists[nv].nil?\n        dist = dists[nv] = dists[v] + 1\n        queue << nv if dist <= MAX_D\n      end\n    end\n  end\n\n  puts d\nend"
  },
  {
    "language": "Ruby",
    "code": "require 'set'\n \nMove = [ [2],\n         [2, 5], [0, 1, 3, 6], [2, 7],\n         [5], [1, 4, 6, 9], [2, 5, 7, 10], [3, 6, 8, 11], [7],\n         [5, 10], [6, 9, 11, 12], [7, 10],\n         [10] ]\nR = [0, 1, 1, 1, 2, 2, 2, 2, 2, 3, 3, 3, 4]\nC = [2, 1, 2, 3, 0, 1, 2, 3, 4, 1, 2, 3, 2]\n \ndef judge(brd, depth)\n  ret = depth\n  13.times do |i|\n    if brd[i] > 0\n      [R, C].each do |a|\n        ret += (a[i] - a[brd[i]]).abs\n      end\n    end\n  end\n  ret\nend\n \ndef solve(brd)\n  q = [[judge(brd, 0), brd, 0]]\n  set = Set.new([])\n  set.add(brd)\n  until q.empty?\n    arr = q.min{ |a, b| a <=> b }\n    q.delete(arr)\n    x, b, d = arr\n    return d if (1..11).all?{ |v| b[v] == v }\n    next if x > 20\n    13.times do |i|\n      if b[i] == 0\n        Move[i].each do |m|\n          b[i], b[m] = b[m], b[i]\n          nb = b.dup\n          nx = judge(nb, d + 1)\n          unless set.include?(nb)\n            set.add(nb)\n            q << [nx, nb, d + 1]\n          end\n          b[i], b[m] = b[m], b[i]\n        end\n      end\n    end\n  end\n  false\nend\n \nwhile n = gets.to_i\n  break if n == -1\n  ans = solve([n, 4.times.map{ gets.split.map(&:to_i) } ].flatten)\n  puts ans && ans <= 20 ? ans : 'NA'\nend"
  },
  {
    "language": "Ruby",
    "code": "require 'set'\n\nMove = [ [2],\n         [2, 5], [0, 1, 3, 6], [2, 7],\n         [5], [1, 4, 6, 9], [2, 5, 7, 10], [3, 6, 8, 11], [7],\n         [5, 10], [6, 9, 11, 12], [7, 10],\n         [10] ]\nR = [0, 1, 1, 1, 2, 2, 2, 2, 2, 3, 3, 3, 4]\nC = [2, 1, 2, 3, 0, 1, 2, 3, 4, 1, 2, 3, 2]\n\ndef judge(brd)\n  ret = 0\n  13.times do |i|\n    if brd[i] > 0\n      [R, C].each do |a|\n        ret += (a[i] - a[brd[i]]).abs\n      end\n    end\n  end\n  ret\nend\n\ndef solve(brd)\n  q = [[judge(brd), brd, 0]]\n  set = Set.new([])\n  set.add(brd)\n  until q.empty?\n    arr = q.min{ |a, b| a <=> b }\n    q.delete(arr)\n    x, b, d = arr\n    return d if x == 0\n    next if x + d > 20\n    13.times do |i|\n      if b[i] == 0\n        Move[i].each do |m|\n          b[i], b[m] = b[m], b[i]\n          nb = b.dup\n          nx = judge(nb)\n          unless set.include?(nb)\n            set.add(nb)\n            q << [nx, nb, d + 1]\n          end\n          b[i], b[m] = b[m], b[i]\n        end\n      end\n    end\n  end\n  false\nend\n\nwhile n = gets.to_i\n  break if n == -1\n  ans = solve([n, 4.times.map{ gets.split.map(&:to_i) } ].flatten)\n  puts ans ? ans : 'NA'\nend"
  },
  {
    "language": "Ruby",
    "code": "def f h,n,m\nh[n]=0\nq=[n]\n(yield a=q.shift\np \"#{a} #{h[a]}\"\n[a.index(0),a.rindex(0)].map{|j|[6,-6,1,-1].map{|i|a[k=i+j]>0&&(b=a.dup\nb[j],b[k]=b[k],b[j]\nh[b]||=(q<<b;h[a]+1))}})while q[0]&&h[q[0]]<m\nend\no=[-1]\nd=o*2\nf(g={},d+[0]+o*4+[*1..3]+d+[*4..8]+d+[*9..11]+o*4+[0]+o*6,12){}\nputs f(h={},d+[$_.to_i]+o*3+[1,0,1,2].flat_map{|i|o*i+gets.split.map(&:to_i)+o*i+o}+o*3,10){|a|g[a]&&(break h[a]+g[a])}||:NA while gets>?0"
  },
  {
    "language": "Ruby",
    "code": "require 'set'\n\n# ??????: ???????????¢?´¢\n\n# ??£\nNB = [\n  [2],\n  [5, 2],\n  [0, 1, 3, 6],\n  [2, 7],\n  [5],\n  [1, 4, 6, 9],\n  [2, 5, 7, 10],\n  [3, 6, 8, 11],\n  [7],\n  [5, 10],\n  [6, 9, 11, 12],\n  [10, 7],\n  [10]\n]\n\nY = [0, 1, 1, 1, 2, 2, 2, 2, 2, 3, 3, 3, 4]\nX = [2, 1, 2, 3, 0, 1, 2, 3, 4, 1, 2, 3, 2]\n\ndef solve(field)\n  queue = []\n  queue << [field, 0]\n  used = Set.new\n  dist = -1\n  prev_dist = -1\n  until queue.empty?\n    f, dist = queue.shift\n    return dist if f == [0, 1, 2, 3, 4, 5, 6, 7, 8, 9, 10, 11, 0]\n    d = dist\n    13.times do |i|\n      next if f[i] == 0\n      d += (X[f[i]] - X[i]).abs + (Y[f[i]] - Y[i]).abs\n    end\n    next if d > 20\n    13.times do |i|\n      next if f[i] != 0\n      NB[i].each do |t|\n        f[i], f[t] = f[t], f[i]\n        unless used.include? f\n          nf = f.clone\n          used.add(nf)\n          queue << [nf, dist + 1]\n        end\n        f[i], f[t] = f[t], f[i]\n      end\n    end\n    # p \"N: #{prev_dist = dist}\" if prev_dist < dist\n  end\n  return -1 if queue.empty?\n  dist\nend\n\nloop do\n  v = gets.to_i\n  break if v == -1\n  field = (1..4).map { gets.split(\" \").map(&:to_i) }\n  res = solve(([[v]] + field).flatten)\n  puts (res == -1) ? \"NA\" : res\nend"
  },
  {
    "language": "Ruby",
    "code": "require 'set'\n \nMove = [ [2],\n         [2, 5], [0, 1, 3, 6], [2, 7],\n         [5], [1, 4, 6, 9], [2, 5, 7, 10], [3, 6, 8, 11], [7],\n         [5, 10], [6, 9, 11, 12], [7, 10],\n         [10] ]\nR = [0, 1, 1, 1, 2, 2, 2, 2, 2, 3, 3, 3, 4]\nC = [2, 1, 2, 3, 0, 1, 2, 3, 4, 1, 2, 3, 2]\n \ndef min_heapify(x = 1)\n  l = 2*x\n  r = 2*x+1\n  if l <= $n && $heap[l][0] < $heap[x][0]\n    minimum = l\n  else\n    minimum = x\n  end\n  if r <= $n && $heap[r][0] < $heap[minimum][0]\n    minimum = r\n  end\n  if minimum != x\n    $heap[x], $heap[minimum] = $heap[minimum], $heap[x]\n    min_heapify(minimum)\n  end\nend\n\ndef extract\n  key = $heap[1]\n  $heap[1] = $heap[$n]\n  $n -= 1\n  min_heapify\n  key\nend\n\ndef insert(key)\n  $n += 1\n  $heap[$n] = key\n  i = $n\n  while i > 1 && $heap[i/2][0] > $heap[i][0]\n    $heap[i], $heap[i/2] = $heap[i/2], $heap[i]\n    i /= 2\n  end\nend\n\ndef judge(brd, depth)\n  ret = depth\n  13.times do |i|\n    if brd[i] > 0\n      [R, C].each do |a|\n        ret += (a[i] - a[brd[i]]).abs\n      end\n    end\n  end\n  ret\nend\n \ndef solve(brd)\n  $heap = []\n  $n = 0\n  insert [judge(brd, 0), brd, 0]\n  set = Set.new([])\n  set.add(brd)\n  \n  until $heap.empty?\n    arr = extract\n    x, b, d = arr\n    return d if (1..11).all?{ |v| b[v] == v }\n    next if x > 20\n    13.times do |i|\n      if b[i] == 0\n        Move[i].each do |m|\n          b[i], b[m] = b[m], b[i]\n          nb = b.dup\n          nx = judge(nb, d + 1)\n          unless set.include?(nb)\n            set.add(nb)\n            insert [nx, nb, d + 1]\n          end\n          b[i], b[m] = b[m], b[i]\n        end\n      end\n    end\n  end\n  false\nend\n \nwhile n = gets.to_i\n  break if n == -1\n  ans = solve([n, 4.times.map{ gets.split.map(&:to_i) } ].flatten)\n  puts ans && ans <= 20 ? ans : 'NA'\nend"
  },
  {
    "language": "Ruby",
    "code": "start = \"fff0fff\" \"ff123ff\" \"f45678f\" \"ff9abff\" \"fff0fff\"\nresult1 = {}\nresult1[start] = 0\nstack = [start]\n\nwhile (nxt = stack.shift)\n  next if result1[nxt] >= 10\n  doit1 = ->(idx) {\n    [1, -1, 7, -7].each do |di|\n      next_index = idx + di\n      next if next_index < 0 or next_index >= 35\n      next if (c = nxt[next_index]) == \"f\" or c == \"0\"\n      next_field = nxt.dup\n      next_field[idx] = c\n      next_field[next_index] = \"0\"\n      next if result1[next_field]\n      result1[next_field] = result1[nxt] + 1\n      stack << next_field\n    end\n  }\n  doit1.(nxt.index(\"0\"))\n  doit1.(nxt.rindex(\"0\"))\nend\n\npat = Array.new(5)\nuntil (pat[0] = gets.to_i) == -1\n  pat[0] = pat[0].to_s(16).center(7, \"f\")\n  4.times {|i| pat[i + 1] = gets.split.map {|a| a.to_i.to_s(16)}.join.center(7, \"f\") }\n  \n  if (ans = result1[start = pat.join])\n    puts ans\n    next\n  end\n  \n  result2 = {}\n  result2[start] = 0\n  stack = [start]\n  str = \"NA\"\n  f = true\n  \n  while (nxt = stack.shift) and f\n    next if result2[nxt] >= 10\n    doit2 = ->(idx) {\n      [1, -1, 7, -7].each do |di|\n        next_index = idx + di\n        next if next_index < 0 or next_index >= 35\n        next if (c = nxt[next_index]) == \"f\" or c == \"0\"\n        next_field = nxt.dup\n        next_field[idx] = c\n        next_field[next_index] = \"0\"\n        next if result2[next_field]\n        if result1[next_field]\n          str = (result1[next_field] + result2[nxt] + 1).to_s\n          return false\n        end\n        result2[next_field] = result2[nxt] + 1\n        stack << next_field\n      end\n      true\n    }\n    f = doit2.(nxt.index(\"0\"))\n    doit2.(nxt.rindex(\"0\")) if f\n  end\n  puts str\nend\n"
  },
  {
    "language": "Ruby",
    "code": "require 'set'\n \nMove = [ [2],\n         [2, 5], [0, 1, 3, 6], [2, 7],\n         [5], [1, 4, 6, 9], [2, 5, 7, 10], [3, 6, 8, 11], [7],\n         [5, 10], [6, 9, 11, 12], [7, 10],\n         [10] ]\nR = [0, 1, 1, 1, 2, 2, 2, 2, 2, 3, 3, 3, 4]\nC = [2, 1, 2, 3, 0, 1, 2, 3, 4, 1, 2, 3, 2]\n \ndef min_heapify(x = 1)\n  l = 2*x\n  r = 2*x+1\n  if l <= $n && $heap[l][0] < $heap[x][0]\n    minimum = l\n  else\n    minimum = x\n  end\n  if r <= $n && $heap[r][0] < $heap[minimum][0]\n    minimum = r\n  end\n  if minimum != x\n    $heap[x], $heap[minimum] = $heap[minimum], $heap[x]\n    min_heapify(minimum)\n  end\nend\n\ndef extract\n  key = $heap[1]\n  $heap[1] = $heap[$n]\n  $n -= 1\n  min_heapify\n  key\nend\n\ndef insert(key)\n  $n += 1\n  $heap[$n] = key\n  i = $n\n  while i > 1 && $heap[i/2][0] > $heap[i][0]\n    $heap[i], $heap[i/2] = $heap[i/2], $heap[i]\n    i /= 2\n  end\nend\n\ndef judge(brd, depth)\n  ret = depth\n  13.times do |i|\n    if brd[i] > 0\n      [R, C].each do |a|\n        ret += (a[i] - a[brd[i]]).abs\n      end\n    end\n  end\n  ret\nend\n \ndef solve(brd)\n  $heap = []\n  $n = 0\n  insert [judge(brd, 0), brd, 0]\n  set = Set.new([])\n  set.add(brd)\n  ans = 'NA'\n  while $n > 0\n    x, b, d = extract\n    next if x > 20\n    if x == d\n      ans = d\n      break\n    end\n    13.times do |i|\n      if b[i] == 0\n        Move[i].each do |m|\n          b[i], b[m] = b[m], b[i]\n          nb = b.dup\n          nx = judge(nb, d + 1)\n          unless set.include?(nb)\n            set.add(nb)\n            insert [nx, nb, d + 1]\n          end\n          b[i], b[m] = b[m], b[i]\n        end\n      end\n    end\n  end\n  ans\nend\n \nwhile n = gets.to_i\n  break if n == -1\n  puts solve([n, 4.times.map{ gets.split.map(&:to_i) } ].flatten)\nend"
  },
  {
    "language": "Ruby",
    "code": "def f h,n\nh[n]=0\nq=[n]\nyield n\n(a=q.shift\n[a.index(0),a.rindex(0)].map{|j|[6,-6,1,-1].map{|i|a[k=i+j]>0&&(b=a.dup\nb[j],b[k]=b[k],b[j]\nh[b]||=(q<<b;h[a]+1)\nyield b)}})while q[0]&&h[q[0]]<10\nend\no=[-1]\nd=o*2\nf(g={},d+[0]+o*4+[*1..3]+d+[*4..8]+d+[*9..11]+o*4+[0]+o*6){}\nputs f(h={},d+[$_.to_i]+o*3+[1,0,1,2].flat_map{|i|o*i+gets.split.map(&:to_i)+o*i+o}+o*3){|a|g[a]&&(break h[a]+g[a])}||:NA while gets>?0"
  },
  {
    "language": "Ruby",
    "code": "require 'set'\nMove = [ [2, -1, -1, -1],\n         [2, 5, -1, -1], [0, 1, 3, 6], [2, 7, -1, -1],\n         [5, -1, -1, -1], [1, 4, 6, 9], [2, 5, 7, 10], [3, 6, 8, 11], [7, -1, -1, -1],\n         [5, 10, -1, -1], [6, 9, 11, 12], [7, 10, -1, -1],\n         [10, -1, -1, -1] ]\nR = [0, 1, 1, 1, 2, 2, 2, 2, 2, 3, 3, 3, 4]\nC = [2, 1, 2, 3, 0, 1, 2, 3, 4, 1, 2, 3, 2]\n \n\nwhile n = gets.to_i\n  break if n == -1\n  brd = [n, 4.times.map{ gets.split.map(&:to_i) } ].flatten\n  q = [[brd, 0]]\n  ans = -1\n  set = SortedSet.new([])\n  set.add(brd)\n  until q.empty?\n    b, d = q.shift\n    if (1..11).all?{ |v| b[v] == v }\n      ans = d\n      break\n    end\n    x = d\n    13.times do |i|\n      if b[i] > 0\n        [R, C].each do |a|\n          x += (a[i] - a[b[i]]).abs\n        end\n      end\n    end\n    unless x > 20\n      13.times do |i|\n        if b[i] == 0\n          4.times do |j|\n            unless Move[i][j] == -1\n              b[i], b[Move[i][j]] = b[Move[i][j]], b[i]\n              unless set.include?(b)\n                set.add(nb = b.dup)\n                q << [nb, d + 1]\n              end\n              b[i], b[Move[i][j]] = b[Move[i][j]], b[i]\n            end\n          end\n        end\n      end\n    end\n  end\n  puts ans == -1 ? 'NA' : ans\nend"
  },
  {
    "language": "Ruby",
    "code": "require 'set'\nrequire 'awesome_print'\n\n# ??????: ???????????¢?´¢\n\n# ??£\nNB = [\n  [2],\n  [5, 2],\n  [0, 1, 3, 6],\n  [2, 7],\n  [5],\n  [1, 4, 6, 9],\n  [2, 5, 7, 10],\n  [3, 6, 8, 11],\n  [7],\n  [5, 10],\n  [6, 9, 11, 12],\n  [10, 7],\n  [10]\n]\n\nY = [0, 1, 1, 1, 2, 2, 2, 2, 2, 3, 3, 3, 4]\nX = [2, 1, 2, 3, 0, 1, 2, 3, 4, 1, 2, 3, 2]\n\ndef solve(field)\n  queue = []\n  queue << [field, 0]\n  used = Set.new\n  dist = -1\n  prev_dist = -1\n  until queue.empty?\n    f, dist = queue.shift\n    break if f == [0, 1, 2, 3, 4, 5, 6, 7, 8, 9, 10, 11, 0]\n    res = f.each_with_index.inject(0) {|accum, (v, i)|\n      if i != 0\n        accum + (X[v] - X[i % 12]).abs + (Y[v] - Y[i % 12]).abs\n      elsif i == 0\n        accum + [(X[v] - X[0]).abs + (Y[v] - Y[0]).abs,\n                 (X[v] - X[12]).abs + (Y[v] - Y[12]).abs].min\n      end\n    }\n    return nil if (res / 2) + dist > 20\n    f.each.with_index do |v, i|\n      next unless v == 0\n      NB[i].each do |t|\n        f[i], f[t] = f[t], f[i]\n        unless used.include? f\n          nf = f.clone\n          used.add(nf)\n          queue << [nf, dist + 1]\n        end\n        f[i], f[t] = f[t], f[i]\n      end\n    end\n    # p \"N: #{prev_dist = dist}\" if prev_dist < dist\n  end\n  dist\nend\n\nloop do\n  v = gets.to_i\n  break if v == -1\n  field = (1..4).map { gets.split(\" \").map(&:to_i) }\n  res = solve(([[v]] + field).flatten)\n  puts res.nil? ? \"NA\" : res\nend"
  },
  {
    "language": "Ruby",
    "code": "require 'set'\nMove = [ [2],\n         [2, 5], [0, 1, 3, 6], [2, 7],\n         [5], [1, 4, 6, 9], [2, 5, 7, 10], [3, 6, 8, 11], [7],\n         [5, 10], [6, 9, 11, 12], [7, 10],\n         [10] ]\nR = [0, 1, 1, 1, 2, 2, 2, 2, 2, 3, 3, 3, 4]\nC = [2, 1, 2, 3, 0, 1, 2, 3, 4, 1, 2, 3, 2]\n\nwhile n = gets.to_i\n  break if n == -1\n  brd = [n, 4.times.map{ gets.split.map(&:to_i) } ].flatten\n  q = [[brd, 0]]\n  ans = -1\n  set = SortedSet.new([])\n  set.add(brd)\n  until q.empty?\n    b, d = q.shift\n    if (1..11).all?{ |v| b[v] == v }\n      ans = d\n      break\n    end\n    x = d\n    13.times do |i|\n      if b[i] > 0\n        [R, C].each do |a|\n          x += (a[i] - a[b[i]]).abs\n        end\n      end\n    end\n    unless x > 20\n      13.times do |i|\n        if b[i] == 0\n          Move[i].each do |m|\n            b[i], b[m] = b[m], b[i]\n            unless set.include?(b)\n              set.add(nb = b.dup)\n              q << [nb, d + 1]\n            end\n            b[i], b[m] = b[m], b[i]\n          end\n        end\n      end\n    end\n  end\n  puts ans == -1 ? 'NA' : ans\nend"
  },
  {
    "language": "Ruby",
    "code": "def f h,n\nh[n]=0\nq=[n]\n(yield a=q.shift\n[a.index(0),a.rindex(0)].map{|j|[6,-6,1,-1].map{|i|a[k=i+j]>0&&(b=a.dup\nb[j],b[k]=b[k],b[j]\nh[b]||=(q<<b;h[a]+1))}})while q[0]&&h[q[0]]<10\nend\no=[-1]\nd=o*2\nf(g={},d+[0]+o*4+[*1..3]+d+[*4..8]+d+[*9..11]+o*4+[0]+o*6){}\nputs f(h={},d+[$_.to_i]+o*3+[1,0,1,2].flat_map{|i|o*i+gets.split.map(&:to_i)+o*i+o}+o*3){|a|g[a]&&(break h[a]+g[a])}||:NA while gets>?0"
  },
  {
    "language": "Ruby",
    "code": "require 'set'\n\nMove = [ [2],\n         [2, 5], [0, 1, 3, 6], [2, 7],\n         [5], [1, 4, 6, 9], [2, 5, 7, 10], [3, 6, 8, 11], [7],\n         [5, 10], [6, 9, 11, 12], [7, 10],\n         [10] ]\nR = [0, 1, 1, 1, 2, 2, 2, 2, 2, 3, 3, 3, 4]\nC = [2, 1, 2, 3, 0, 1, 2, 3, 4, 1, 2, 3, 2]\n\ndef judge(brd)\n  ret = 0\n  13.times do |i|\n    if brd[i] > 0\n      [R, C].each do |a|\n        ret += (a[i] - a[brd[i]]).abs\n      end\n    end\n  end\n  ret\nend\n\ndef solve(brd)\n  q = [[judge(brd), brd, 0]]\n  set = Set.new([])\n  set.add(brd)\n  until q.empty?\n    arr = q.min{ |a, b| a <=> b }\n    q.delete(arr)\n    x, b, d = arr\n    next if x + d > 20\n    13.times do |i|\n      if b[i] == 0\n        Move[i].each do |m|\n          b[i], b[m] = b[m], b[i]\n          nb = b.dup\n          nx = judge(nb)\n          if nx == 0\n            if d < 20 then return d + 1\n            else return false\n            end\n          end\n          unless set.include?(nb)\n            set.add(nb)\n            q << [nx, nb, d + 1]\n          end\n          b[i], b[m] = b[m], b[i]\n        end\n      end\n    end\n  end\n  false\nend\n\nwhile n = gets.to_i\n  break if n == -1\n  ans = solve([n, 4.times.map{ gets.split.map(&:to_i) } ].flatten)\n  puts ans ? ans : 'NA'\nend"
  },
  {
    "language": "Ruby",
    "code": "start = \"fff0fff\" \"ff123ff\" \"f45678f\" \"ff9abff\" \"fff0fff\"\nresult1 = {}\nresult1[start] = 0\nstack = [start]\n\nwhile (nxt = stack.shift)\n  next if result1[nxt] >= 10\n  doit = ->(idx) {\n    [1, -1, 7, -7].each do |di|\n      next_index = idx + di\n      next if next_index < 0 or next_index >= 35\n      next if (c = nxt[next_index]) == \"f\" or c == \"0\"\n      next_field = nxt.dup\n      next_field[idx] = c\n      next_field[next_index] = \"0\"\n      next if result1[next_field]\n      result1[next_field] = result1[nxt] + 1\n      stack << next_field\n    end\n  }\n  doit.(nxt.index(\"0\"))\n  doit.(nxt.rindex(\"0\"))\nend\n\npat = Array.new(5)\nuntil (pat[0] = gets.to_i) == -1\n  pat[0] = pat[0].to_s(16).center(7, \"f\")\n  4.times {|i| pat[i + 1] = gets.split.map {|a| a.to_i.to_s(16)}.join.center(7, \"f\") }\n  \n  if (ans = result1[start = pat.join])\n    puts ans\n    next\n  end\n  \n  result2 = {}\n  result2[start] = 0\n  stack = [start]\n  str = \"NA\"\n  f = true\n  \n  while (nxt = stack.shift) and f\n    next if result2[nxt] >= 10\n    doit = ->(idx) {\n      [1, -1, 7, -7].each do |di|\n        next_index = idx + di\n        next if next_index < 0 or next_index >= 35\n        next if (c = nxt[next_index]) == \"f\" or c == \"0\"\n        next_field = nxt.dup\n        next_field[idx] = c\n        next_field[next_index] = \"0\"\n        next if result2[next_field]\n        if result1[next_field]\n          str = (result1[next_field] + result2[nxt] + 1).to_s\n          return false\n        end\n        result2[next_field] = result2[nxt] + 1\n        stack << next_field\n      end\n      true\n    }\n    f = doit.(nxt.index(\"0\"))\n    doit.(nxt.rindex(\"0\")) if f\n  end\n  puts str\nend\n"
  },
  {
    "language": "Go",
    "code": "// BFS\n\npackage main\n\nimport (\n\t\"bufio\"\n\t\"os\"\n\t\t\"fmt\"\n\t\"strconv\"\n\t\"strings\"\n)\n\nvar scanner = bufio.NewScanner(os.Stdin)\n\nvar p = [15]int{}\nvar g = [13][4]int {\n\t// -1は存在しないマス目\n\t{2,-1,-1,-1},\n\t{2,5,-1,-1},{0,1,3,6},{2,7,-1,-1},\n\t{5,-1,-1,-1},{1,4,6,9},{2,5,7,10},{3,6,8,11},{7,-1,-1,-1},\n\t{5,10,-1,-1},{6,9,11,12},{7,10,-1,-1},\n\t{10,-1,-1,-1},\n}\n\n/*\n　  ０ １ ２ ３ ４\n 0 |／|／|  |／|／|\n 1 |／|　|  |　|／|\n 2 |　|　|  |　|　|\n 3 |／|　|  |　|／|\n 4 |／|／|  |／|／|\n*/\n\nvar row = [13]int{0,1,1,1,2,2,2,2,2,3,3,3,4}\nvar col = [13]int{2,1,2,3,0,1,2,3,4,1,2,3,2}\n\ntype wolf struct {\n\tm [13]int\n}\n\ntype pair struct {\n\tfirst wolf\n\tsecond int\n}\n\nfunc abs(a int) int {\n\tif a < 0 {\n\t\treturn -a\n\t}\n\treturn a\n}\n\nfunc print_board(board [13]int) {\n\tfmt.Println(\"--------------------------\")\n\tfmt.Printf(\"        [%2d]\\n\", board[0])\n\tfmt.Printf(\"    [%2d][%2d][%2d]\\n\", board[1], board[2], board[3])\n\tfmt.Printf(\"[%2d][%2d][%2d][%2d][%2d]\\n\", board[4], board[5], board[6], board[7], board[8])\n\tfmt.Printf(\"    [%2d][%2d][%2d]\\n\", board[9], board[10], board[11])\n\tfmt.Printf(\"        [%2d]\\n\", board[12])\n\tfmt.Println(\"--------------------------\")\n}\n\nfunc main() {\n\tfor scanner.Scan() {\n\t\tp1, _ := strconv.Atoi(scanner.Text())\n\t\tif p1 == -1 {\n\t\t\tbreak\n\t\t}\n\t\tp[0]= p1\n\t\tscanner.Scan()\n\t\tbuf1 := strings.Split(scanner.Text(), \" \")\n\t\tp2, _ := strconv.Atoi(buf1[0])\n\t\tp3, _ := strconv.Atoi(buf1[1])\n\t\tp4, _ := strconv.Atoi(buf1[2])\n\t\tp[1], p[2], p[3] = p2, p3, p4\n\t\tscanner.Scan()\n\t\tbuf2 := strings.Split(scanner.Text(), \" \")\n\t\tp5, _ := strconv.Atoi(buf2[0])\n\t\tp6, _ := strconv.Atoi(buf2[1])\n\t\tp7, _ := strconv.Atoi(buf2[2])\n\t\tp8, _ := strconv.Atoi(buf2[3])\n\t\tp9, _ := strconv.Atoi(buf2[4])\n\t\tp[4], p[5], p[6], p[7], p[8] = p5, p6, p7, p8, p9\n\t\tscanner.Scan()\n\t\tbuf3 := strings.Split(scanner.Text(), \" \")\n\t\tp10, _ := strconv.Atoi(buf3[0])\n\t\tp11, _ := strconv.Atoi(buf3[1])\n\t\tp12, _ := strconv.Atoi(buf3[2])\n\t\tp[9], p[10], p[11] = p10, p11, p12\n\t\tscanner.Scan()\n\t\tp13, _ := strconv.Atoi(scanner.Text())\n\t\tp[12] = p13\n\t\tS := make(map[wolf]struct{})\n\t\tst := wolf{}\n\t\tfor i := 0; i < 13; i++ {\n\t\t\tst.m[i] = p[i]\n\t\t}\n\t\tQ := make([]pair, 0)\n\t\tS[st] = struct{}{}\n\t\tQ = append(Q, pair{st, 0})\n\t\tyet := true\n\t\tfor len(Q) > 0 {\n\t\t\tat := Q[0].first\n\t\t\tprint_board(at.m)\n\t\t\tcost := Q[0].second\n\t\t\tQ = Q[1:]\n\t\t\tok := true\n\t\t\tfor i :=1; i < 12; i++ {\n\t\t\t\tif at.m[i] != i {\n\t\t\t\t\tok = false\n\t\t\t\t}\n\t\t\t}\n\t\t\tif ok {\n\t\t\t\t// print_board(at.m)\n\t\t\t\tyet = false\n\t\t\t\tfmt.Println(cost)\n\t\t\t\tbreak\n\t\t\t}\n\t\t\tnow := cost\n\t\t\tfor i := 0; i < 13; i++ {\n\t\t\t\tif at.m[i] != 0 {\n\t\t\t\t\tnow += abs(row[i]-row[at.m[i]]) + abs(col[i]-col[at.m[i]])\n\t\t\t\t}\n\t\t\t}\n\t\t\tif now > 20 {\n\t\t\t\tcontinue\n\t\t\t}\n\t\t\tfor i := 0; i < 13; i++ {\n\t\t\t\tif at.m[i] == 0 {\n\t\t\t\t\tfor j := 0; j < 4; j++ {\n\t\t\t\t\t\tif ^g[i][j] != 0 {\n\t\t\t\t\t\t\tat.m[i], at.m[g[i][j]] = at.m[g[i][j]], at.m[i]\n\t\t\t\t\t\t\tif _, ok := S[at]; !ok {\n\t\t\t\t\t\t\t\tS[at] = struct{}{}\n\t\t\t\t\t\t\t\tQ = append(Q, pair{at, cost+1})\n\t\t\t\t\t\t\t}\n\t\t\t\t\t\t\tat.m[i], at.m[g[i][j]] = at.m[g[i][j]], at.m[i]\n\t\t\t\t\t\t}\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t\tif yet {\n\t\t\tfmt.Println(\"NA\")\n\t\t}\n\t}\n}\n"
  },
  {
    "language": "Go",
    "code": "// BFS\n\npackage main\n\nimport (\n\t\"bufio\"\n\t\"os\"\n\t\t\"fmt\"\n\t\"strconv\"\n\t\"strings\"\n)\n\nvar scanner = bufio.NewScanner(os.Stdin)\n\nvar p = [15]int{}\nvar g = [13][4]int {\n\t// -1は存在しないマス目\n\t{2,-1,-1,-1},\n\t{2,5,-1,-1},{0,1,3,6},{2,7,-1,-1},\n\t{5,-1,-1,-1},{1,4,6,9},{2,5,7,10},{3,6,8,11},{7,-1,-1,-1},\n\t{5,10,-1,-1},{6,9,11,12},{7,10,-1,-1},\n\t{10,-1,-1,-1},\n}\n\n/*\n　  ０ １ ２ ３ ４\n 0 |／|／|  |／|／|\n 1 |／|　|  |　|／|\n 2 |　|　|  |　|　|\n 3 |／|　|  |　|／|\n 4 |／|／|  |／|／|\n*/\n\nvar row = [13]int{0,1,1,1,2,2,2,2,2,3,3,3,4}\nvar col = [13]int{2,1,2,3,0,1,2,3,4,1,2,3,2}\n\ntype wolf struct {\n\tm [13]int\n}\n\ntype pair struct {\n\tfirst wolf\n\tsecond int\n}\n\nfunc abs(a int) int {\n\tif a < 0 {\n\t\treturn -a\n\t}\n\treturn a\n}\n\nfunc print_board(board [13]int) {\n\tfmt.Println(\"--------------------------\")\n\tfmt.Printf(\"        [%2d]\\n\", board[0])\n\tfmt.Printf(\"    [%2d][%2d][%2d]\\n\", board[1], board[2], board[3])\n\tfmt.Printf(\"[%2d][%2d][%2d][%2d][%2d]\\n\", board[4], board[5], board[6], board[7], board[8])\n\tfmt.Printf(\"    [%2d][%2d][%2d]\\n\", board[9], board[10], board[11])\n\tfmt.Printf(\"        [%2d]\\n\", board[12])\n\tfmt.Println(\"--------------------------\")\n}\n\nfunc main() {\n\tfor scanner.Scan() {\n\t\tp1, _ := strconv.Atoi(scanner.Text())\n\t\tif p1 == -1 {\n\t\t\tbreak\n\t\t}\n\t\tp[0]= p1\n\t\tscanner.Scan()\n\t\tbuf1 := strings.Split(scanner.Text(), \" \")\n\t\tp2, _ := strconv.Atoi(buf1[0])\n\t\tp3, _ := strconv.Atoi(buf1[1])\n\t\tp4, _ := strconv.Atoi(buf1[2])\n\t\tp[1], p[2], p[3] = p2, p3, p4\n\t\tscanner.Scan()\n\t\tbuf2 := strings.Split(scanner.Text(), \" \")\n\t\tp5, _ := strconv.Atoi(buf2[0])\n\t\tp6, _ := strconv.Atoi(buf2[1])\n\t\tp7, _ := strconv.Atoi(buf2[2])\n\t\tp8, _ := strconv.Atoi(buf2[3])\n\t\tp9, _ := strconv.Atoi(buf2[4])\n\t\tp[4], p[5], p[6], p[7], p[8] = p5, p6, p7, p8, p9\n\t\tscanner.Scan()\n\t\tbuf3 := strings.Split(scanner.Text(), \" \")\n\t\tp10, _ := strconv.Atoi(buf3[0])\n\t\tp11, _ := strconv.Atoi(buf3[1])\n\t\tp12, _ := strconv.Atoi(buf3[2])\n\t\tp[9], p[10], p[11] = p10, p11, p12\n\t\tscanner.Scan()\n\t\tp13, _ := strconv.Atoi(scanner.Text())\n\t\tp[12] = p13\n\t\tS := make(map[wolf]struct{})\n\t\tst := wolf{}\n\t\tfor i := 0; i < 13; i++ {\n\t\t\tst.m[i] = p[i]\n\t\t}\n\t\tQ := make([]pair, 0)\n\t\tS[st] = struct{}{}\n\t\tQ = append(Q, pair{st, 0})\n\t\tyet := true\n\t\tfor len(Q) > 0 {\n\t\t\tat := Q[0].first\n\t\t\t// print_board(at.m)\n\t\t\tcost := Q[0].second\n\t\t\tQ = Q[1:]\n\t\t\tok := true\n\t\t\tfor i :=1; i < 12; i++ {\n\t\t\t\tif at.m[i] != i {\n\t\t\t\t\tok = false\n\t\t\t\t}\n\t\t\t}\n\t\t\tif ok {\n\t\t\t\t// print_board(at.m)\n\t\t\t\tyet = false\n\t\t\t\tfmt.Println(cost)\n\t\t\t\tbreak\n\t\t\t}\n\t\t\tnow := cost\n\t\t\tfor i := 0; i < 13; i++ {\n\t\t\t\tif at.m[i] != 0 {\n\t\t\t\t\tnow += abs(row[i]-row[at.m[i]]) + abs(col[i]-col[at.m[i]])\n\t\t\t\t}\n\t\t\t}\n\t\t\tif now > 20 {\n\t\t\t\tcontinue\n\t\t\t}\n\t\t\tfor i := 0; i < 13; i++ {\n\t\t\t\tif at.m[i] == 0 {\n\t\t\t\t\tfor j := 0; j < 4; j++ {\n\t\t\t\t\t\tif ^g[i][j] != 0 {\n\t\t\t\t\t\t\tat.m[i], at.m[g[i][j]] = at.m[g[i][j]], at.m[i]\n\t\t\t\t\t\t\tif _, ok := S[at]; !ok {\n\t\t\t\t\t\t\t\tS[at] = struct{}{}\n\t\t\t\t\t\t\t\tQ = append(Q, pair{at, cost+1})\n\t\t\t\t\t\t\t}\n\t\t\t\t\t\t\tat.m[i], at.m[g[i][j]] = at.m[g[i][j]], at.m[i]\n\t\t\t\t\t\t}\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t\tif yet {\n\t\t\tfmt.Println(\"NA\")\n\t\t}\n\t}\n}\n"
  },
  {
    "language": "Go",
    "code": "// BFS\n\npackage main\n\nimport (\n\t\"bufio\"\n\t\"os\"\n\t\t\"fmt\"\n\t\"strconv\"\n\t\"strings\"\n)\n\nvar scanner = bufio.NewScanner(os.Stdin)\n\nvar p = [15]int{}\nvar g = [13][4]int {\n\t// -1は存在しないマス目\n\t{2,-1,-1,-1},\n\t{2,5,-1,-1},{0,1,3,6},{2,7,-1,-1},\n\t{5,-1,-1,-1},{1,4,6,9},{2,5,7,10},{3,6,8,11},{7,-1,-1,-1},\n\t{5,10,-1,-1},{6,9,11,12},{7,10,-1,-1},\n\t{10,-1,-1,-1},\n}\n\n/*\n　  ０ １ ２ ３ ４\n 0 |／|／|  |／|／|\n 1 |／|　|  |　|／|\n 2 |　|　|  |　|　|\n 3 |／|　|  |　|／|\n 4 |／|／|  |／|／|\n*/\n\nvar row = [13]int{0,1,1,1,2,2,2,2,2,3,3,3,4}\nvar col = [13]int{2,1,2,3,0,1,2,3,4,1,2,3,2}\n\ntype wolf struct {\n\tm [13]int\n}\n\ntype pair struct {\n\tfirst wolf\n\tsecond int\n}\n\nfunc abs(a int) int {\n\tif a < 0 {\n\t\treturn -a\n\t}\n\treturn a\n}\n\nfunc print_board(board [13]int) {\n\tfmt.Println(\"--------------------------\")\n\tfmt.Printf(\"        [%2d]\\n\", board[0])\n\tfmt.Printf(\"    [%2d][%2d][%2d]\\n\", board[1], board[2], board[3])\n\tfmt.Printf(\"[%2d][%2d][%2d][%2d][%2d]\\n\", board[4], board[5], board[6], board[7], board[8])\n\tfmt.Printf(\"    [%2d][%2d][%2d]\\n\", board[9], board[10], board[11])\n\tfmt.Printf(\"        [%2d]\\n\", board[12])\n\tfmt.Println(\"--------------------------\")\n}\n\nfunc main() {\n\tfor scanner.Scan() {\n\t\tp1, _ := strconv.Atoi(scanner.Text())\n\t\tif p1 == -1 {\n\t\t\tbreak\n\t\t}\n\t\tp[0]= p1\n\t\tscanner.Scan()\n\t\tbuf1 := strings.Split(scanner.Text(), \" \")\n\t\tp2, _ := strconv.Atoi(buf1[0])\n\t\tp3, _ := strconv.Atoi(buf1[1])\n\t\tp4, _ := strconv.Atoi(buf1[2])\n\t\tp[1], p[2], p[3] = p2, p3, p4\n\t\tscanner.Scan()\n\t\tbuf2 := strings.Split(scanner.Text(), \" \")\n\t\tp5, _ := strconv.Atoi(buf2[0])\n\t\tp6, _ := strconv.Atoi(buf2[1])\n\t\tp7, _ := strconv.Atoi(buf2[2])\n\t\tp8, _ := strconv.Atoi(buf2[3])\n\t\tp9, _ := strconv.Atoi(buf2[4])\n\t\tp[4], p[5], p[6], p[7], p[8] = p5, p6, p7, p8, p9\n\t\tscanner.Scan()\n\t\tbuf3 := strings.Split(scanner.Text(), \" \")\n\t\tp10, _ := strconv.Atoi(buf3[0])\n\t\tp11, _ := strconv.Atoi(buf3[1])\n\t\tp12, _ := strconv.Atoi(buf3[2])\n\t\tp[9], p[10], p[11] = p10, p11, p12\n\t\tscanner.Scan()\n\t\tp13, _ := strconv.Atoi(scanner.Text())\n\t\tp[12] = p13\n\t\tS := make(map[wolf]struct{})\n\t\tst := wolf{}\n\t\tfor i := 0; i < 13; i++ {\n\t\t\tst.m[i] = p[i]\n\t\t}\n\t\tQ := make([]pair, 0)\n\t\tS[st] = struct{}{}\n\t\tQ = append(Q, pair{st, 0})\n\t\tyet := true\n\t\tfor len(Q) > 0 {\n\t\t\tat := Q[0].first\n\t\t\tprint_board(at.m)\n\t\t\tcost := Q[0].second\n\t\t\tQ = Q[1:]\n\t\t\tok := true\n\t\t\tfor i :=1; i < 12; i++ {\n\t\t\t\tif at.m[i] != i {\n\t\t\t\t\tok = false\n\t\t\t\t}\n\t\t\t}\n\t\t\tif ok {\n\t\t\t\tprint_board(at.m)\n\t\t\t\tyet = false\n\t\t\t\tfmt.Println(cost)\n\t\t\t\tbreak\n\t\t\t}\n\t\t\tnow := cost\n\t\t\tfor i := 0; i < 13; i++ {\n\t\t\t\tif at.m[i] != 0 {\n\t\t\t\t\tnow += abs(row[i]-row[at.m[i]]) + abs(col[i]-col[at.m[i]])\n\t\t\t\t}\n\t\t\t}\n\t\t\tif now > 20 {\n\t\t\t\tcontinue\n\t\t\t}\n\t\t\tfor i := 0; i < 13; i++ {\n\t\t\t\tif at.m[i] == 0 {\n\t\t\t\t\tfor j := 0; j < 4; j++ {\n\t\t\t\t\t\tif ^g[i][j] != 0 {\n\t\t\t\t\t\t\tat.m[i], at.m[g[i][j]] = at.m[g[i][j]], at.m[i]\n\t\t\t\t\t\t\tif _, ok := S[at]; !ok {\n\t\t\t\t\t\t\t\tS[at] = struct{}{}\n\t\t\t\t\t\t\t\tQ = append(Q, pair{at, cost+1})\n\t\t\t\t\t\t\t}\n\t\t\t\t\t\t\tat.m[i], at.m[g[i][j]] = at.m[g[i][j]], at.m[i]\n\t\t\t\t\t\t}\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t\tif yet {\n\t\t\tfmt.Println(\"NA\")\n\t\t}\n\t}\n}\n"
  },
  {
    "language": "Python",
    "code": "from math import factorial\nfrom Queue import PriorityQueue\n\nFACTORIAL=[factorial(i) for i in xrange(13)]\nLEFT,UP,RIGHT,DOWN=0,1,2,3\nMOVE=[[0] for u in xrange(13)]\nMOVE[0] =[-1,-1,-1, 2]\nMOVE[1] =[-1,-1, 2, 5]\nMOVE[2] =[ 1, 0, 3, 6]\nMOVE[3] =[ 2,-1,-1, 7] \nMOVE[4] =[-1,-1, 5,-1]\nMOVE[5] =[ 4, 1, 6, 9]\nMOVE[6] =[ 5, 2, 7,10]\nMOVE[7] =[ 6, 3, 8,11]\nMOVE[8] =[ 7,-1,-1,-1]\nMOVE[9] =[-1, 5,10,-1]\nMOVE[10]=[ 9, 6,11,12]\nMOVE[11]=[10, 7,-1,-1]\nMOVE[12]=[-1,10,-1,-1]\n\ndef hash(cell):\n    work = cell[:]\n    hash = 0\n    for i in xrange(12):\n        hash += work[i] * FACTORIAL[13-1-i]\n        for ii in xrange(i+1,13):\n            if work[ii]>work[i]:\n                work[ii]-=1\n    return hash\n\ndef dehash(key):\n    cell=[]\n    for i in xrange(13):\n        cell.append(key/FACTORIAL[13-1-i])\n        key %= FACTORIAL[13-1-i]\n    for i in xrange(13-1,-1,-1):\n        for ii in xrange(i+1,13):\n            if cell[i]<=cell[ii]:\n                cell[ii]+=1\n    return cell\n\ndef evaluate(cell):\n    point=[[0,2],\n           [1,1],[1,2],[1,3],\n           [2,0],[2,1],[2,2],[2,3],[2,4],\n           [3,1],[3,2],[3,3],\n           [4,2]]\n    eva=0\n    for i in xrange(0,13):\n        if not (cell[i]==0 or cell[i]==12):\n            eva+=abs(point[cell[i]][0]-point[i][0])\n            eva+=abs(point[cell[i]][1]-point[i][1])\n    return eva\n\nwhile True:\n    p=[input()]\n    if p==[-1]:\n        break\n    for u in xrange(4):\n        for pp in map(int,raw_input().split()):\n            p.append(pp)\n    p[p.index(0)]=12\n    pq=PriorityQueue()\n    init_hash=hash(p)\n    init_eva=evaluate(p)\n    pq.put([init_eva,init_hash,0])\n    visited={}\n    visited[init_hash]=True\n    ans=0 if init_eva==0 else \"NA\"\n        #cur=[eva,hashkey,step]\n    while not pq.empty():\n        cur_eva,cur_hash,cur_step=pq.get()\n        cur_cell=dehash(cur_hash)\n        if not (cur_eva<20 and ans==\"NA\"):\n            break\n        for i in xrange(13):\n            if cur_cell[i]==0 or cur_cell[i]==12:\n                for ii in [LEFT,UP,RIGHT,DOWN]:\n                    if not MOVE[i][ii]==-1:\n                        cur_cell[i],cur_cell[MOVE[i][ii]]=cur_cell[MOVE[i][ii]],cur_cell[i]\n                        hashkey=hash(cur_cell)\n                        if not hashkey in visited:\n                            eva=evaluate(cur_cell)\n                            if eva==0:\n                                ans=cur_step+1\n                                break\n                            pq.put([evaluate(cur_cell)+cur_step+1,hashkey,cur_step+1])\n                            visited[hashkey]=True\n                        cur_cell[i],cur_cell[MOVE[i][ii]]=cur_cell[MOVE[i][ii]],cur_cell[i]\n    print ans"
  },
  {
    "language": "Python",
    "code": "from math import factorial\nfrom Queue import PriorityQueue\n\nFACTORIAL=[factorial(i) for i in xrange(13)]\nLEFT,UP,RIGHT,DOWN=0,1,2,3\nMOVE=[[0] for u in xrange(13)]\nMOVE[0] =[-1,-1,-1, 2]\nMOVE[1] =[-1,-1, 2, 5]\nMOVE[2] =[ 1, 0, 3, 6]\nMOVE[3] =[ 2,-1,-1, 7] \nMOVE[4] =[-1,-1, 5,-1]\nMOVE[5] =[ 4, 1, 6, 9]\nMOVE[6] =[ 5, 2, 7,10]\nMOVE[7] =[ 6, 3, 8,11]\nMOVE[8] =[ 7,-1,-1,-1]\nMOVE[9] =[-1, 5,10,-1]\nMOVE[10]=[ 9, 6,11,12]\nMOVE[11]=[10, 7,-1,-1]\nMOVE[12]=[-1,10,-1,-1]\n\n\"\"\"\nMOVE[0][LEFT]=MOVE[1][LEFT]=MOVE[4][LEFT]=MOVE[9][LEFT]=MOVE[12][LEFT]=False\nMOVE[0][UP]=MOVE[1][UP]=MOVE[3][UP]=MOVE[4][UP]=MOVE[8][UP]=False\nMOVE[0][RIGHT]=MOVE[3][RIGHT]=MOVE[8][RIGHT]=MOVE[11][RIGHT]=MOVE[12][RIGHT]=False\nMOVE[4][DOWN]=MOVE[8][DOWN]=MOVE[9][DOWN]=MOVE[11][DOWN]=MOVE[12][DOWN]=False\n\"\"\"\n\ndef hash(cell):\n    work = cell[:]\n    hash = 0\n    for i in xrange(12):\n        hash += work[i] * FACTORIAL[13-1-i]\n        for ii in xrange(i+1,13):\n            if work[ii]>work[i]:\n                work[ii]-=1\n    return hash\n\ndef dehash(key):\n    cell=[]\n    for i in xrange(13):\n        cell.append(key/FACTORIAL[13-1-i])\n        key %= FACTORIAL[13-1-i]\n    for i in xrange(13-1,-1,-1):\n        for ii in xrange(i+1,13):\n            if cell[i]<=cell[ii]:\n                cell[ii]+=1\n    return cell\n\ndef evaluate(cell):\n    point=[[0,2],\n           [1,1],[1,2],[1,3],\n           [2,0],[2,1],[2,2],[2,3],[2,4],\n           [3,1],[3,2],[3,3],\n           [4,2]]\n    eva=0\n    for i in xrange(0,13):\n        if not (cell[i]==0 or cell[i]==12):\n            eva+=abs(point[cell[i]][0]-point[i][0])\n            eva+=abs(point[cell[i]][1]-point[i][1])\n    return eva\n\nANS_HASH=[hash([0,1,2,3,4,5,6,7,8,9,10,11,12]),hash([12,1,2,3,4,5,6,7,8,9,10,11,0])]          \n\nwhile True:\n    p=[input()]\n    if p==[-1]:\n        break\n    for u in xrange(4):\n        for pp in map(int,raw_input().split()):\n            p.append(pp)\n    p[p.index(0)]=12\n    pq = PriorityQueue()\n    pq.put([evaluate(p),hash(p),0])\n    visited={}\n    visited[hash(p)]=True\n    ans=0 if hash(p) in ANS_HASH else \"NA\"\n    #cur=[eva,hashkey,step]\n    while not pq.empty():\n        unused,cur_hash,cur_step=pq.get()\n        cur_cell=dehash(cur_hash)\n        \"\"\"\n        print \"STEP\",cur_step\n        print [cur_cell[0]]\n        print cur_cell[1:4]\n        print cur_cell[4:9]\n        print cur_cell[9:12]\n        print [cur_cell[12]]\n        print\n        \"\"\"\n        if not (cur_step<20 and ans==\"NA\"):\n            break\n        for i in xrange(13):\n            if cur_cell[i]==0 or cur_cell[i]==12:\n                #print cur_cell[i]\n                for ii in [LEFT,UP,RIGHT,DOWN]:\n                    #print ii,\n                    if not MOVE[i][ii]==-1:\n                        #print \"MOVE\"\n                        cur_cell[i],cur_cell[MOVE[i][ii]]=cur_cell[MOVE[i][ii]],cur_cell[i]\n                        \"\"\"\n                        print \"MOVING\",ii\n                        print [cur_cell[0]]\n                        print cur_cell[1:4]\n                        print cur_cell[4:9]\n                        print cur_cell[9:12]\n                        print [cur_cell[12]]\n                        \"\"\"\n                        hashkey=hash(cur_cell)\n                        if not hashkey in visited:\n                            if hashkey in ANS_HASH:\n                                ans=cur_step+1\n                                break\n                            pq.put([evaluate(cur_cell)+cur_step+1,hashkey,cur_step+1])\n                            visited[hashkey]=True\n                        cur_cell[i],cur_cell[MOVE[i][ii]]=cur_cell[MOVE[i][ii]],cur_cell[i]\n                    else:\n                        pass\n                        #print \n    print ans"
  },
  {
    "language": "Python",
    "code": "from math import factorial\nfrom Queue import PriorityQueue\n\nFACTORIAL=[factorial(i) for i in xrange(13)]\nLEFT,UP,RIGHT,DOWN=0,1,2,3\nMOVE=[[0] for u in xrange(13)]\nMOVE[0] =[-1,-1,-1, 2]\nMOVE[1] =[-1,-1, 2, 5]\nMOVE[2] =[ 1, 0, 3, 6]\nMOVE[3] =[ 2,-1,-1, 7] \nMOVE[4] =[-1,-1, 5,-1]\nMOVE[5] =[ 4, 1, 6, 9]\nMOVE[6] =[ 5, 2, 7,10]\nMOVE[7] =[ 6, 3, 8,11]\nMOVE[8] =[ 7,-1,-1,-1]\nMOVE[9] =[-1, 5,10,-1]\nMOVE[10]=[ 9, 6,11,12]\nMOVE[11]=[10, 7,-1,-1]\nMOVE[12]=[-1,10,-1,-1]\n\ndef hash(cell):\n    work = cell[:]\n    hash = 0\n    for i in xrange(12):\n        hash += work[i] * FACTORIAL[13-1-i]\n        for ii in xrange(i+1,13):\n            if work[ii]>work[i]:\n                work[ii]-=1\n    return hash\n\ndef dehash(key):\n    cell=[]\n    for i in xrange(13):\n        cell.append(key/FACTORIAL[13-1-i])\n        key %= FACTORIAL[13-1-i]\n    for i in xrange(13-1,-1,-1):\n        for ii in xrange(i+1,13):\n            if cell[i]<=cell[ii]:\n                cell[ii]+=1\n    return cell\n\ndef evaluate(cell):\n    point=[[0,2],\n           [1,1],[1,2],[1,3],\n           [2,0],[2,1],[2,2],[2,3],[2,4],\n           [3,1],[3,2],[3,3],\n           [4,2]]\n    eva=0\n    for i in xrange(0,13):\n        if not (cell[i]==0 or cell[i]==12):\n            eva+=abs(point[cell[i]][0]-point[i][0])\n            eva+=abs(point[cell[i]][1]-point[i][1])\n    return eva\n\nwhile True:\n    p=[input()]\n    if p==[-1]:\n        break\n    for u in xrange(4):\n        for pp in map(int,raw_input().split()):\n            p.append(pp)\n    p[p.index(0)]=12\n    pq=PriorityQueue()\n    init_hash=hash(p)\n    init_eva=evaluate(p)\n    pq.put([init_eva,init_hash,0])\n    visited={}\n    visited[init_hash]=True\n    ans=0 if init_eva==0 else \"NA\"\n        #cur=[eva,hashkey,step]\n    while not pq.empty():\n        cur_eva,cur_hash,cur_step=pq.get()\n        cur_cell=dehash(cur_hash)\n        if not (cur_eva<=20 and ans==\"NA\"):\n            break\n        for i in xrange(13):\n            if cur_cell[i]==0 or cur_cell[i]==12:\n                for ii in [LEFT,UP,RIGHT,DOWN]:\n                    if not MOVE[i][ii]==-1:\n                        cur_cell[i],cur_cell[MOVE[i][ii]]=cur_cell[MOVE[i][ii]],cur_cell[i]\n                        hashkey=hash(cur_cell)\n                        if not hashkey in visited:\n                            eva=evaluate(cur_cell)\n                            if eva==0:\n                                ans=cur_step+1\n                                break\n                            pq.put([evaluate(cur_cell)+cur_step+1,hashkey,cur_step+1])\n                            visited[hashkey]=True\n                        cur_cell[i],cur_cell[MOVE[i][ii]]=cur_cell[MOVE[i][ii]],cur_cell[i]\n    print ans"
  },
  {
    "language": "Python",
    "code": "from heapq import heappush, heappop\n\ncomp = [(1, 1), (2, 1), (3, 1),\n        (0, 2), (1, 2), (2, 2), (3, 2), (4, 2),\n        (1, 3), (2, 3), (3, 3)]\nnumbers = range(11)\nzeros = (11, 12)\n\ndef manhattan(v1, v2):\n  x1, y1 = v1\n  x2, y2 = v2\n  return abs(x2 - x1) + abs(y2 - y1)\n\ndef heuristic(state):\n  return sum([manhattan(state[i], comp[i]) for i in numbers])\n\ndef swaped(state, n1, n2):\n  new_state = [i for i in state]\n  new_state[n1], new_state[n2] = new_state[n2], new_state[n1]\n  return tuple(new_state)\n\ndef main():\n  while True:\n    p1 = int(input())\n    if p1 == -1:\n      break\n    l1 = [-1, -1, p1, -1, -1]\n    l2 = [-1] + list(map(int, input().split())) + [-1]\n    l3 = list(map(int, input().split()))\n    l4 = [-1] + list(map(int, input().split())) + [-1]\n    l5 = [-1, -1, int(input()), -1, -1]\n    mp = [l1, l2, l3, l4, l5]\n    init_state = [None] * 13\n    for y in range(5):\n      for x in range(5):\n        if mp[y][x] != -1:\n          if mp[y][x] == 0:\n            if not init_state[11]:\n              init_state[11] = (x, y)\n            else:\n              init_state[12] = (x, y)\n          else:\n            init_state[mp[y][x] - 1] = (x, y)\n    init_state = tuple(init_state)\n    dic = {}\n    dic[init_state] = True\n    que = []\n    heappush(que, (heuristic(init_state) + 0, 0, init_state))\n    while que:\n      score, count, state = heappop(que)\n      if score == count:\n        print(count)\n        break\n  \n      for z in zeros:\n        for i in numbers:\n          if manhattan(state[z], state[i]) == 1:\n            new_state = swaped(state, i, z)\n            if new_state not in dic:\n              dic[new_state] = True\n              new_score = heuristic(new_state) + count + 1\n              if new_score <= 20:\n                heappush(que, (new_score, count + 1, new_state))\n    else:\n      print(\"NA\")\n\nmain()\n"
  },
  {
    "language": "Python",
    "code": "from math import factorial\nfrom Queue import PriorityQueue\n\nFACTORIAL=[factorial(i) for i in xrange(13)]\nLEFT,UP,RIGHT,DOWN=0,1,2,3\nMOVE=[[0] for u in xrange(13)]\nMOVE[0] =[-1,-1,-1, 2]\nMOVE[1] =[-1,-1, 2, 5]\nMOVE[2] =[ 1, 0, 3, 6]\nMOVE[3] =[ 2,-1,-1, 7] \nMOVE[4] =[-1,-1, 5,-1]\nMOVE[5] =[ 4, 1, 6, 9]\nMOVE[6] =[ 5, 2, 7,10]\nMOVE[7] =[ 6, 3, 8,11]\nMOVE[8] =[ 7,-1,-1,-1]\nMOVE[9] =[-1, 5,10,-1]\nMOVE[10]=[ 9, 6,11,12]\nMOVE[11]=[10, 7,-1,-1]\nMOVE[12]=[-1,10,-1,-1]\n\ndef hash(cell):\n    work = cell[:]\n    hash = 0\n    for i in xrange(12):\n        hash += work[i] * FACTORIAL[13-1-i]\n        for ii in xrange(i+1,13):\n            if work[ii]>work[i]:\n                work[ii]-=1\n    return hash\n\ndef dehash(key):\n    cell=[]\n    for i in xrange(13):\n        cell.append(key/FACTORIAL[13-1-i])\n        key %= FACTORIAL[13-1-i]\n    for i in xrange(13-1,-1,-1):\n        for ii in xrange(i+1,13):\n            if cell[i]<=cell[ii]:\n                cell[ii]+=1\n    return cell\n\ndef evaluate(cell):\n    point=[[0,2],\n           [1,1],[1,2],[1,3],\n           [2,0],[2,1],[2,2],[2,3],[2,4],\n           [3,1],[3,2],[3,3],\n           [4,2]]\n    eva=0\n    for i in xrange(0,13):\n        if not (cell[i]==0 or cell[i]==12):\n            eva+=abs(point[cell[i]][0]-point[i][0])\n            eva+=abs(point[cell[i]][1]-point[i][1])\n    return eva\n\nif __name__== \"__main__\":\n    while True:\n        p=[input()]\n        if p==[-1]:\n            break\n        for u in xrange(4):\n            for pp in map(int,raw_input().split()):\n                p.append(pp)\n        p[p.index(0)]=12\n        pq=PriorityQueue()\n        init_hash=hash(p)\n        init_eva=evaluate(p)\n        pq.put([init_eva,init_hash,0])\n        visited={}\n        visited[init_hash]=True\n        ans=0 if init_eva==0 else \"NA\"\n        count=0\n        #cur=[eva,hashkey,step]\n        while not pq.empty():\n            count+=1\n            cur_eva,cur_hash,cur_step=pq.get()\n            cur_cell=dehash(cur_hash)\n            if not (cur_eva<=20 and ans==\"NA\"):\n                break\n            for i in xrange(13):\n                if cur_cell[i]==0 or cur_cell[i]==12:\n                    for ii in [LEFT,UP,RIGHT,DOWN]:\n                        if not MOVE[i][ii]==-1:\n                            cur_cell[i],cur_cell[MOVE[i][ii]]=cur_cell[MOVE[i][ii]],cur_cell[i]\n                            hashkey=hash(cur_cell)\n                            if not hashkey in visited:\n                                eva=evaluate(cur_cell)\n                                if eva==0:\n                                    ans=cur_step+1\n                                    break\n                                pq.put([evaluate(cur_cell)+cur_step+1,hashkey,cur_step+1])\n                                visited[hashkey]=True\n                            cur_cell[i],cur_cell[MOVE[i][ii]]=cur_cell[MOVE[i][ii]],cur_cell[i]\n        print ans"
  },
  {
    "language": "Python",
    "code": "from math import factorial\nfrom Queue import PriorityQueue\n\nFACTORIAL=[factorial(i) for i in xrange(13)]\nLEFT,UP,RIGHT,DOWN=0,1,2,3\nMOVE=[[0] for u in xrange(13)]\nMOVE[0] =[-1,-1,-1, 2]\nMOVE[1] =[-1,-1, 2, 5]\nMOVE[2] =[ 1, 0, 3, 6]\nMOVE[3] =[ 2,-1,-1, 7] \nMOVE[4] =[-1,-1, 5,-1]\nMOVE[5] =[ 4, 1, 6, 9]\nMOVE[6] =[ 5, 2, 7,10]\nMOVE[7] =[ 6, 3, 8,11]\nMOVE[8] =[ 7,-1,-1,-1]\nMOVE[9] =[-1, 5,10,-1]\nMOVE[10]=[ 9, 6,11,12]\nMOVE[11]=[10, 7,-1,-1]\nMOVE[12]=[-1,10,-1,-1]\n\ndef hash(cell):\n    work = cell[:]\n    hash = 0\n    for i in xrange(12):\n        hash += work[i] * FACTORIAL[13-1-i]\n        for ii in xrange(i+1,13):\n            if work[ii]>work[i]:\n                work[ii]-=1\n    return hash\n\ndef dehash(key):\n    cell=[]\n    for i in xrange(13):\n        cell.append(key/FACTORIAL[13-1-i])\n        key %= FACTORIAL[13-1-i]\n    for i in xrange(13-1,-1,-1):\n        for ii in xrange(i+1,13):\n            if cell[i]<=cell[ii]:\n                cell[ii]+=1\n    return cell\n\ndef evaluate(cell):\n    point=[[0,2],\n           [1,1],[1,2],[1,3],\n           [2,0],[2,1],[2,2],[2,3],[2,4],\n           [3,1],[3,2],[3,3],\n           [4,2]]\n    eva=0\n    for i in xrange(0,13):\n        if not (cell[i]==0 or cell[i]==12):\n            eva+=abs(point[cell[i]][0]-point[i][0])\n            eva+=abs(point[cell[i]][1]-point[i][1])\n    return eva\n\nANS_HASH=[hash([0,1,2,3,4,5,6,7,8,9,10,11,12]),hash([12,1,2,3,4,5,6,7,8,9,10,11,0])]          \n\nwhile True:\n    p=[input()]\n    if p==[-1]:\n        break\n    for u in xrange(4):\n        for pp in map(int,raw_input().split()):\n            p.append(pp)\n    p[p.index(0)]=12\n    pq = PriorityQueue()\n    pq.put([evaluate(p),hash(p),0])\n    visited={}\n    visited[hash(p)]=True\n    ans=0 if hash(p) in ANS_HASH else \"NA\"\n    #cur=[eva,hashkey,step]\n    while not pq.empty():\n        eva,cur_hash,cur_step=pq.get()\n        cur_cell=dehash(cur_hash)\n        if not (eva<=20 and ans==\"NA\"):\n            break\n        for i in xrange(13):\n            if cur_cell[i]==0 or cur_cell[i]==12:\n                for ii in [LEFT,UP,RIGHT,DOWN]:\n                    if not MOVE[i][ii]==-1:\n                        cur_cell[i],cur_cell[MOVE[i][ii]]=cur_cell[MOVE[i][ii]],cur_cell[i]\n                        hashkey=hash(cur_cell)\n                        if not hashkey in visited:\n                            if hashkey in ANS_HASH:\n                                ans=cur_step+1\n                                break\n                            pq.put([evaluate(cur_cell)+cur_step+1,hashkey,cur_step+1])\n                            visited[hashkey]=True\n                        cur_cell[i],cur_cell[MOVE[i][ii]]=cur_cell[MOVE[i][ii]],cur_cell[i]\n    print ans"
  },
  {
    "language": "Python",
    "code": "from math import factorial\nfrom Queue import PriorityQueue\n\nFACTORIAL=[factorial(i) for i in xrange(13)]\nLEFT,UP,RIGHT,DOWN=0,1,2,3\nMOVE=[[0] for u in xrange(13)]\nMOVE[0] =[-1,-1,-1, 2]\nMOVE[1] =[-1,-1, 2, 5]\nMOVE[2] =[ 1, 0, 3, 6]\nMOVE[3] =[ 2,-1,-1, 7] \nMOVE[4] =[-1,-1, 5,-1]\nMOVE[5] =[ 4, 1, 6, 9]\nMOVE[6] =[ 5, 2, 7,10]\nMOVE[7] =[ 6, 3, 8,11]\nMOVE[8] =[ 7,-1,-1,-1]\nMOVE[9] =[-1, 5,10,-1]\nMOVE[10]=[ 9, 6,11,12]\nMOVE[11]=[10, 7,-1,-1]\nMOVE[12]=[-1,10,-1,-1]\n\ndef hash(cell):\n    work = cell[:]\n    hash = 0\n    for i in xrange(12):\n        hash += work[i] * FACTORIAL[13-1-i]\n        for ii in xrange(i+1,13):\n            if work[ii]>work[i]:\n                work[ii]-=1\n    return hash\n\ndef dehash(key):\n    cell=[]\n    for i in xrange(13):\n        cell.append(key/FACTORIAL[13-1-i])\n        key %= FACTORIAL[13-1-i]\n    for i in xrange(13-1,-1,-1):\n        for ii in xrange(i+1,13):\n            if cell[i]<=cell[ii]:\n                cell[ii]+=1\n    return cell\n\ndef evaluate(cell):\n    point=[[0,2],\n           [1,1],[1,2],[1,3],\n           [2,0],[2,1],[2,2],[2,3],[2,4],\n           [3,1],[3,2],[3,3],\n           [4,2]]\n    eva=0\n    for i in xrange(0,13):\n        if not (cell[i]==0 or cell[i]==12):\n            eva+=abs(point[cell[i]][0]-point[i][0])\n            eva+=abs(point[cell[i]][1]-point[i][1])\n    return eva\n\nANS_HASH=[hash([0,1,2,3,4,5,6,7,8,9,10,11,12]),hash([12,1,2,3,4,5,6,7,8,9,10,11,0])]          \n\nwhile True:\n    p=[input()]\n    if p==[-1]:\n        break\n    for u in xrange(4):\n        for pp in map(int,raw_input().split()):\n            p.append(pp)\n    p[p.index(0)]=12\n    pq = PriorityQueue()\n    pq.put([evaluate(p),hash(p),0])\n    visited={}\n    visited[hash(p)]=True\n    ans=0 if hash(p) in ANS_HASH else \"NA\"\n    #cur=[eva,hashkey,step]\n    while not pq.empty():\n        eva,cur_hash,cur_step=pq.get()\n        cur_cell=dehash(cur_hash)\n        if not (eva<20 and ans==\"NA\"):\n            break\n        for i in xrange(13):\n            if cur_cell[i]==0 or cur_cell[i]==12:\n                for ii in [LEFT,UP,RIGHT,DOWN]:\n                    if not MOVE[i][ii]==-1:\n                        cur_cell[i],cur_cell[MOVE[i][ii]]=cur_cell[MOVE[i][ii]],cur_cell[i]\n                        hashkey=hash(cur_cell)\n                        if not hashkey in visited:\n                            if hashkey in ANS_HASH:\n                                ans=cur_step+1\n                                break\n                            pq.put([evaluate(cur_cell)+cur_step+1,hashkey,cur_step+1])\n                            visited[hashkey]=True\n                        cur_cell[i],cur_cell[MOVE[i][ii]]=cur_cell[MOVE[i][ii]],cur_cell[i]\n    print ans"
  }
]