[
  {
    "model": "deepseek-v3",
    "prompt_type": "zero_shot",
    "language": "C",
    "code": "#include <stdio.h>\n#include <stdlib.h>\n#include <string.h>\n#include <stdbool.h>\n\n#define MAX_STATES 1000000\n#define MAX_MOVES 20\n\ntypedef struct {\n    int board[13];\n} State;\n\nState goal = { {1, 2, 3, 4, 5, 6, 7, 8, 9, 10, 11, 0, 0} };\n\ntypedef struct {\n    State states[MAX_STATES];\n    int moves[MAX_STATES];\n    int parent[MAX_STATES];\n    int front, rear;\n} Queue;\n\nvoid init_queue(Queue *q) {\n    q->front = q->rear = 0;\n}\n\nbool is_empty(Queue *q) {\n    return q->front == q->rear;\n}\n\nvoid enqueue(Queue *q, State state, int move, int parent) {\n    q->states[q->rear] = state;\n    q->moves[q->rear] = move;\n    q->parent[q->rear] = parent;\n    q->rear++;\n}\n\nvoid dequeue(Queue *q, State *state, int *move, int *parent) {\n    *state = q->states[q->front];\n    *move = q->moves[q->front];\n    *parent = q->parent[q->front];\n    q->front++;\n}\n\nbool is_goal(State *state) {\n    for (int i = 0; i < 13; i++) {\n        if (state->board[i] != goal.board[i]) {\n            return false;\n        }\n    }\n    return true;\n}\n\nunsigned long hash_state(State *state) {\n    unsigned long hash = 0;\n    for (int i = 0; i < 13; i++) {\n        hash = hash * 13 + state->board[i];\n    }\n    return hash;\n}\n\nbool visited[MAX_STATES];\nint visited_moves[MAX_STATES];\n\nint solve(State initial) {\n    memset(visited, 0, sizeof(visited));\n    memset(visited_moves, -1, sizeof(visited_moves));\n\n    Queue q;\n    init_queue(&q);\n    enqueue(&q, initial, 0, -1);\n\n    while (!is_empty(&q)) {\n        State current;\n        int moves, parent;\n        dequeue(&q, &current, &moves, &parent);\n\n        if (moves > MAX_MOVES) {\n            continue;\n        }\n\n        unsigned long h = hash_state(&current);\n        if (visited[h]) {\n            if (visited_moves[h] <= moves) {\n                continue;\n            }\n        }\n        visited[h] = true;\n        visited_moves[h] = moves;\n\n        if (is_goal(&current)) {\n            return moves;\n        }\n\n        int empty1 = -1, empty2 = -1;\n        for (int i = 0; i < 13; i++) {\n            if (current.board[i] == 0) {\n                if (empty1 == -1) {\n                    empty1 = i;\n                } else {\n                    empty2 = i;\n                }\n            }\n        }\n\n        int adj[13][5] = {\n            {1, 2, -1},          // 0\n            {0, 2, 3, -1},       // 1\n            {0, 1, 4, -1},       // 2\n            {1, 4, 5, 6, -1},    // 3\n            {2, 3, 6, 7, -1},    // 4\n            {3, 6, 8, -1},       // 5\n            {3, 4, 5, 7, 8},     // 6\n            {4, 6, 8, 9, -1},    // 7\n            {5, 6, 7, 9, 10},    // 8\n            {7, 8, 10, 11, -1},  // 9\n            {8, 9, 11, 12, -1},  // 10\n            {9, 10, 12, -1},     // 11\n            {10, 11, -1}         // 12\n        };\n\n        for (int e = 0; e < 2; e++) {\n            int empty = (e == 0) ? empty1 : empty2;\n            for (int i = 0; adj[empty][i] != -1; i++) {\n                int neighbor = adj[empty][i];\n                if (current.board[neighbor] == 0) {\n                    continue;\n                }\n\n                State next = current;\n                next.board[empty] = next.board[neighbor];\n                next.board[neighbor] = 0;\n\n                unsigned long next_hash = hash_state(&next);\n                if (!visited[next_hash] || visited_moves[next_hash] > moves + 1) {\n                    enqueue(&q, next, moves + 1, parent);\n                }\n            }\n        }\n    }\n\n    return -1;\n}\n\nint main() {\n    while (1) {\n        int p1, p2, p3, p4, p5, p6, p7, p8, p9, p10, p11, p12, p13;\n        scanf(\"%d\", &p1);\n        if (p1 == -1) {\n            break;\n        }\n        scanf(\"%d %d %d\", &p2, &p3, &p4);\n        scanf(\"%d %d %d %d %d\", &p5, &p6, &p7, &p8, &p9);\n        scanf(\"%d %d %d\", &p10, &p11, &p12);\n        scanf(\"%d\", &p13);\n\n        State initial = { {p1, p2, p3, p4, p5, p6, p7, p8, p9, p10, p11, p12, p13} };\n\n        int result = solve(initial);\n        if (result != -1 && result <= 20) {\n            printf(\"%d\\n\", result);\n        } else {\n            printf(\"NA\\n\");\n        }\n    }\n\n    return 0;\n}",
    "timestamp": "2025-08-05 18:35:32"
  },
  {
    "model": "claude-3-5-haiku-20241022",
    "prompt_type": "zero_shot",
    "language": "Java",
    "code": "import java.util.*;\n\npublic class ElevenPuzzle {\n    static final int MAX_DEPTH = 20;\n    static final int[] dx = {0, 0, 1, -1};\n    static final int[] dy = {1, -1, 0, 0};\n    static int[][] target = {\n        {2, 1, 3},\n        {10, 5, 7, 8},\n        {9, 4, 11},\n        {0, 0}\n    };\n\n    public static void main(String[] args) {\n        Scanner scanner = new Scanner(System.in);\n        \n        while (true) {\n            int[][] board = new int[4][];\n            boolean endInput = false;\n            \n            for (int i = 0; i < 4; i++) {\n                String line = scanner.nextLine().trim();\n                if (line.equals(\"-1\")) {\n                    endInput = true;\n                    break;\n                }\n                \n                String[] nums = line.split(\" \");\n                board[i] = new int[nums.length];\n                for (int j = 0; j < nums.length; j++) {\n                    board[i][j] = Integer.parseInt(nums[j]);\n                }\n            }\n            \n            if (endInput) break;\n            \n            int steps = solve(board);\n            System.out.println(steps == -1 ? \"NA\" : steps);\n        }\n        \n        scanner.close();\n    }\n    \n    static int solve(int[][] initial) {\n        String initialState = boardToString(initial);\n        String targetState = boardToString(target);\n        \n        Queue<String> queue = new LinkedList<>();\n        Map<String, Integer> visited = new HashMap<>();\n        \n        queue.offer(initialState);\n        visited.put(initialState, 0);\n        \n        while (!queue.isEmpty()) {\n            String current = queue.poll();\n            int steps = visited.get(current);\n            \n            if (current.equals(targetState)) {\n                return steps;\n            }\n            \n            if (steps >= MAX_DEPTH) continue;\n            \n            int[][] currentBoard = stringToBoard(current);\n            List<int[]> emptySpaces = findEmptySpaces(currentBoard);\n            \n            for (int[] space : emptySpaces) {\n                for (int k = 0; k < 4; k++) {\n                    int nx = space[0] + dx[k];\n                    int ny = space[1] + dy[k];\n                    \n                    if (isValidMove(currentBoard, nx, ny)) {\n                        int[][] newBoard = copyBoard(currentBoard);\n                        newBoard[space[0]][space[1]] = newBoard[nx][ny];\n                        newBoard[nx][ny] = 0;\n                        \n                        String newState = boardToString(newBoard);\n                        if (!visited.containsKey(newState) || visited.get(newState) > steps + 1) {\n                            visited.put(newState, steps + 1);\n                            queue.offer(newState);\n                        }\n                    }\n                }\n            }\n        }\n        \n        return -1;\n    }\n    \n    static String boardToString(int[][] board) {\n        StringBuilder sb = new StringBuilder();\n        for (int[] row : board) {\n            for (int num : row) {\n                sb.append(num).append(\",\");\n            }\n        }\n        return sb.toString();\n    }\n    \n    static int[][] stringToBoard(String state) {\n        String[] nums = state.split(\",\");\n        int[][] board = new int[4][];\n        board[0] = new int[3];\n        board[1] = new int[4];\n        board[2] = new int[3];\n        board[3] = new int[2];\n        \n        int index = 0;\n        for (int i = 0; i < board.length; i++) {\n            for (int j = 0; j < board[i].length; j++) {\n                board[i][j] = Integer.parseInt(nums[index++]);\n            }\n        }\n        \n        return board;\n    }\n    \n    static List<int[]> findEmptySpaces(int[][] board) {\n        List<int[]> spaces = new ArrayList<>();\n        for (int i = 0; i < board.length; i++) {\n            for (int j = 0; j < board[i].length; j++) {\n                if (board[i][j] == 0) {\n                    spaces.add(new int[]{i, j});\n                }\n            }\n        }\n        return spaces;\n    }\n    \n    static boolean isValidMove(int[][] board, int x, int y) {\n        return x >= 0 && x < board.length && y >= 0 && y < board[x].length;\n    }\n    \n    static int[][] copyBoard(int[][] board) {\n        int[][] copy = new int[board.length][];\n        for (int i = 0; i < board.length; i++) {\n            copy[i] = Arrays.copyOf(board[i], board[i].length);\n        }\n        return copy;\n    }\n}",
    "timestamp": "2025-08-05 18:35:48"
  },
  {
    "model": "deepseek-v3",
    "prompt_type": "zero_shot",
    "language": "C++",
    "code": "#include <iostream>\n#include <vector>\n#include <queue>\n#include <map>\n#include <algorithm>\nusing namespace std;\n\nstruct State {\n    vector<vector<int>> grid;\n    int zero_r1, zero_c1, zero_r2, zero_c2;\n    int steps;\n\n    bool operator==(const State &other) const {\n        return grid == other.grid;\n    }\n\n    bool operator<(const State &other) const {\n        return grid < other.grid;\n    }\n};\n\nconst vector<vector<int>> goal = {\n    {0},\n    {1, 2, 3},\n    {4, 5, 6, 7, 8},\n    {9, 10, 11},\n    {0}\n};\n\nvector<pair<int, int>> get_moves(const State &s, int r, int c) {\n    vector<pair<int, int>> moves;\n    if (r == 0) {\n        if (c == 0) {\n            moves.emplace_back(1, 0);\n            moves.emplace_back(1, 1);\n        }\n    } else if (r == 1) {\n        if (c == 0) {\n            moves.emplace_back(0, 0);\n            moves.emplace_back(1, 1);\n            moves.emplace_back(2, 0);\n            moves.emplace_back(2, 1);\n        } else if (c == 1) {\n            moves.emplace_back(0, 0);\n            moves.emplace_back(1, 0);\n            moves.emplace_back(1, 2);\n            moves.emplace_back(2, 1);\n            moves.emplace_back(2, 2);\n        } else if (c == 2) {\n            moves.emplace_back(1, 1);\n            moves.emplace_back(2, 2);\n            moves.emplace_back(2, 3);\n        }\n    } else if (r == 2) {\n        if (c == 0) {\n            moves.emplace_back(1, 0);\n            moves.emplace_back(2, 1);\n            moves.emplace_back(3, 0);\n        } else if (c == 1) {\n            moves.emplace_back(1, 0);\n            moves.emplace_back(1, 1);\n            moves.emplace_back(2, 0);\n            moves.emplace_back(2, 2);\n            moves.emplace_back(3, 0);\n            moves.emplace_back(3, 1);\n        } else if (c == 2) {\n            moves.emplace_back(1, 1);\n            moves.emplace_back(1, 2);\n            moves.emplace_back(2, 1);\n            moves.emplace_back(2, 3);\n            moves.emplace_back(3, 1);\n            moves.emplace_back(3, 2);\n        } else if (c == 3) {\n            moves.emplace_back(1, 2);\n            moves.emplace_back(2, 2);\n            moves.emplace_back(3, 2);\n        }\n    } else if (r == 3) {\n        if (c == 0) {\n            moves.emplace_back(2, 0);\n            moves.emplace_back(2, 1);\n            moves.emplace_back(4, 0);\n        } else if (c == 1) {\n            moves.emplace_back(2, 1);\n            moves.emplace_back(2, 2);\n            moves.emplace_back(3, 0);\n            moves.emplace_back(3, 2);\n            moves.emplace_back(4, 0);\n        } else if (c == 2) {\n            moves.emplace_back(2, 2);\n            moves.emplace_back(2, 3);\n            moves.emplace_back(3, 1);\n            moves.emplace_back(4, 0);\n        }\n    } else if (r == 4) {\n        if (c == 0) {\n            moves.emplace_back(3, 0);\n            moves.emplace_back(3, 1);\n            moves.emplace_back(3, 2);\n        }\n    }\n    return moves;\n}\n\nint bfs(State initial) {\n    queue<State> q;\n    map<State, int> visited;\n\n    q.push(initial);\n    visited[initial] = 1;\n\n    while (!q.empty()) {\n        State current = q.front();\n        q.pop();\n\n        if (current.grid == goal) {\n            return current.steps;\n        }\n\n        if (current.steps >= 20) {\n            continue;\n        }\n\n        vector<pair<int, int>> zero_positions = {\n            {current.zero_r1, current.zero_c1},\n            {current.zero_r2, current.zero_c2}\n        };\n\n        for (auto &zero_pos : zero_positions) {\n            int r = zero_pos.first;\n            int c = zero_pos.second;\n            vector<pair<int, int>> moves = get_moves(current, r, c);\n            for (auto &move : moves) {\n                int nr = move.first;\n                int nc = move.second;\n                if (current.grid[nr][nc] != 0) {\n                    State next = current;\n                    swap(next.grid[r][c], next.grid[nr][nc]);\n                    if (r == current.zero_r1 && c == current.zero_c1) {\n                        next.zero_r1 = nr;\n                        next.zero_c1 = nc;\n                    } else {\n                        next.zero_r2 = nr;\n                        next.zero_c2 = nc;\n                    }\n                    next.steps++;\n                    if (visited.find(next) == visited.end()) {\n                        visited[next] = 1;\n                        q.push(next);\n                    }\n                }\n            }\n        }\n    }\n    return -1;\n}\n\nint main() {\n    while (true) {\n        int p1;\n        cin >> p1;\n        if (p1 == -1) break;\n\n        vector<vector<int>> grid(5);\n        grid[0].push_back(p1);\n\n        for (int i = 1; i <= 3; ++i) {\n            if (i == 1) {\n                int p2, p3, p4;\n                cin >> p2 >> p3 >> p4;\n                grid[1].push_back(p2);\n                grid[1].push_back(p3);\n                grid[1].push_back(p4);\n            } else if (i == 2) {\n                int p5, p6, p7, p8, p9;\n                cin >> p5 >> p6 >> p7 >> p8 >> p9;\n                grid[2].push_back(p5);\n                grid[2].push_back(p6);\n                grid[2].push_back(p7);\n                grid[2].push_back(p8);\n                grid[2].push_back(p9);\n            } else if (i == 3) {\n                int p10, p11, p12;\n                cin >> p10 >> p11 >> p12;\n                grid[3].push_back(p10);\n                grid[3].push_back(p11);\n                grid[3].push_back(p12);\n            }\n        }\n        int p13;\n        cin >> p13;\n        grid[4].push_back(p13);\n\n        State initial;\n        initial.grid = grid;\n        initial.steps = 0;\n        bool first_zero = true;\n        for (int i = 0; i < 5; ++i) {\n            for (int j = 0; j < grid[i].size(); ++j) {\n                if (grid[i][j] == 0) {\n                    if (first_zero) {\n                        initial.zero_r1 = i;\n                        initial.zero_c1 = j;\n                        first_zero = false;\n                    } else {\n                        initial.zero_r2 = i;\n                        initial.zero_c2 = j;\n                    }\n                }\n            }\n        }\n\n        int result = bfs(initial);\n        if (result == -1 || result > 20) {\n            cout << \"NA\" << endl;\n        } else {\n            cout << result << endl;\n        }\n    }\n    return 0;\n}",
    "timestamp": "2025-08-05 18:36:55"
  },
  {
    "model": "claude-3-5-haiku-20241022",
    "prompt_type": "zero_shot",
    "language": "C",
    "code": "#include <stdio.h>\n#include <string.h>\n#include <stdlib.h>\n#include <limits.h>\n\n#define MAX_MOVES 20\n#define BOARD_SIZE 13\n\ntypedef struct {\n    int board[BOARD_SIZE];\n    int zero1, zero2;\n    int moves;\n} State;\n\nint dx[] = {-1, 1, 0, 0};\nint dy[] = {0, 0, -1, 1};\n\nint is_solved(int* board) {\n    int expected[] = {1, 2, 3, 4, 5, 6, 7, 8, 9, 10, 11, 0, 0};\n    return memcmp(board, expected, sizeof(expected)) == 0;\n}\n\nint is_valid_move(int pos, int zero) {\n    int x1 = pos / 4, y1 = pos % 4;\n    int x2 = zero / 4, y2 = zero % 4;\n    return abs(x1 - x2) + abs(y1 - y2) == 1;\n}\n\nint bfs(State start) {\n    State queue[1000000];\n    int front = 0, rear = 0;\n    int visited[1 << 24] = {0};\n\n    queue[rear++] = start;\n\n    while (front < rear) {\n        State current = queue[front++];\n\n        if (is_solved(current.board)) {\n            return current.moves;\n        }\n\n        if (current.moves >= MAX_MOVES) continue;\n\n        int hash = 0;\n        for (int i = 0; i < BOARD_SIZE; i++) {\n            hash = (hash << 2) | current.board[i];\n        }\n\n        if (visited[hash & ((1 << 24) - 1)]) continue;\n        visited[hash & ((1 << 24) - 1)] = 1;\n\n        for (int k = 0; k < 4; k++) {\n            State next = current;\n            next.moves++;\n\n            int new_zero1 = current.zero1 + dx[k] * 4 + dy[k];\n            int new_zero2 = current.zero2 + dx[k] * 4 + dy[k];\n\n            if (new_zero1 >= 0 && new_zero1 < BOARD_SIZE &&\n                is_valid_move(new_zero1, current.zero1)) {\n                next.board[current.zero1] = next.board[new_zero1];\n                next.board[new_zero1] = 0;\n                next.zero1 = new_zero1;\n                queue[rear++] = next;\n            }\n\n            if (new_zero2 >= 0 && new_zero2 < BOARD_SIZE &&\n                is_valid_move(new_zero2, current.zero2)) {\n                next = current;\n                next.moves++;\n                next.board[current.zero2] = next.board[new_zero2];\n                next.board[new_zero2] = 0;\n                next.zero2 = new_zero2;\n                queue[rear++] = next;\n            }\n        }\n    }\n\n    return -1;\n}\n\nint main() {\n    int p;\n    while (scanf(\"%d\", &p) && p != -1) {\n        State start;\n        start.board[0] = p;\n        start.moves = 0;\n\n        for (int i = 1; i < 3; i++) {\n            for (int j = 0; j < 3; j++) {\n                scanf(\"%d\", &start.board[i * 3 + j]);\n            }\n        }\n\n        for (int i = 9; i < 12; i++) {\n            scanf(\"%d\", &start.board[i]);\n        }\n\n        start.zero1 = -1;\n        start.zero2 = -1;\n\n        for (int i = 0; i < BOARD_SIZE; i++) {\n            if (start.board[i] == 0) {\n                if (start.zero1 == -1) start.zero1 = i;\n                else start.zero2 = i;\n            }\n        }\n\n        int min_moves = bfs(start);\n        if (min_moves == -1 || min_moves > MAX_MOVES) {\n            printf(\"NA\\n\");\n        } else {\n            printf(\"%d\\n\", min_moves);\n        }\n    }\n    return 0;\n}",
    "timestamp": "2025-08-05 18:37:13"
  },
  {
    "model": "claude-3-5-haiku-20241022",
    "prompt_type": "zero_shot",
    "language": "C++",
    "code": "#include <iostream>\n#include <queue>\n#include <vector>\n#include <string>\n#include <unordered_set>\n#include <algorithm>\n\nusing namespace std;\n\nstruct State {\n    vector<vector<int>> board;\n    int steps;\n    string key;\n};\n\nbool isGoal(const vector<vector<int>>& board) {\n    return board == vector<vector<int>>{{1,2,3},{4,5,6,7,8},{9,10,11}};\n}\n\nstring boardToKey(const vector<vector<int>>& board) {\n    string key;\n    for (const auto& row : board) {\n        for (int num : row) {\n            key += to_string(num) + \",\";\n        }\n    }\n    return key;\n}\n\nvector<pair<int,int>> findEmptySpaces(const vector<vector<int>>& board) {\n    vector<pair<int,int>> empty_spaces;\n    for (int i = 0; i < board.size(); i++) {\n        for (int j = 0; j < board[i].size(); j++) {\n            if (board[i][j] == 0) {\n                empty_spaces.push_back({i, j});\n            }\n        }\n    }\n    return empty_spaces;\n}\n\nint solve(vector<vector<int>> initial_board) {\n    queue<State> q;\n    unordered_set<string> visited;\n    \n    State start{initial_board, 0, boardToKey(initial_board)};\n    q.push(start);\n    visited.insert(start.key);\n    \n    vector<pair<int,int>> dirs = {{-1,0}, {1,0}, {0,-1}, {0,1}};\n    \n    while (!q.empty()) {\n        State current = q.front();\n        q.pop();\n        \n        if (isGoal(current.board)) {\n            return current.steps;\n        }\n        \n        if (current.steps == 20) continue;\n        \n        vector<pair<int,int>> empty_spaces = findEmptySpaces(current.board);\n        \n        for (auto [ex, ey] : empty_spaces) {\n            for (auto [dx, dy] : dirs) {\n                int nx = ex + dx, ny = ey + dy;\n                \n                if (nx >= 0 && nx < current.board.size() && \n                    ny >= 0 && ny < current.board[nx].size() &&\n                    current.board[nx][ny] != 0) {\n                    \n                    State next = current;\n                    swap(next.board[ex][ey], next.board[nx][ny]);\n                    next.steps++;\n                    next.key = boardToKey(next.board);\n                    \n                    if (visited.find(next.key) == visited.end()) {\n                        q.push(next);\n                        visited.insert(next.key);\n                    }\n                }\n            }\n        }\n    }\n    \n    return -1;\n}\n\nint main() {\n    int p1;\n    while (cin >> p1 && p1 != -1) {\n        vector<vector<int>> board(3);\n        board[0].push_back(p1);\n        \n        for (int i = 0; i < 3; i++) {\n            string line;\n            getline(cin, line);\n            \n            stringstream ss(line);\n            int num;\n            while (ss >> num) {\n                board[i].push_back(num);\n            }\n        }\n        \n        int result = solve(board);\n        \n        if (result == -1) {\n            cout << \"NA\" << endl;\n        } else {\n            cout << result << endl;\n        }\n    }\n    \n    return 0;\n}",
    "timestamp": "2025-08-05 18:37:25"
  },
  {
    "model": "deepseek-v3",
    "prompt_type": "zero_shot",
    "language": "Java",
    "code": "import java.util.*;\n\npublic class Main {\n    static class State {\n        int[][] board;\n        int zero1Row, zero1Col, zero2Row, zero2Col;\n        int steps;\n        String key;\n\n        State(int[][] board, int zero1Row, int zero1Col, int zero2Row, int zero2Col, int steps) {\n            this.board = new int[5][5];\n            for (int i = 0; i < 5; i++) {\n                System.arraycopy(board[i], 0, this.board[i], 0, 5);\n            }\n            this.zero1Row = zero1Row;\n            this.zero1Col = zero1Col;\n            this.zero2Row = zero2Row;\n            this.zero2Col = zero2Col;\n            this.steps = steps;\n            this.key = generateKey();\n        }\n\n        String generateKey() {\n            StringBuilder sb = new StringBuilder();\n            for (int i = 0; i < 5; i++) {\n                for (int j = 0; j < 5; j++) {\n                    sb.append(board[i][j]).append(\",\");\n                }\n            }\n            return sb.toString();\n        }\n    }\n\n    static final int[][] GOAL = {\n            {0, 0, 1, 0, 0},\n            {0, 2, 3, 4, 0},\n            {5, 6, 7, 8, 9},\n            {0, 10, 11, 0, 0},\n            {0, 0, 0, 0, 0}\n    };\n\n    static final int[][] MOVES = {{-1, 0}, {1, 0}, {0, -1}, {0, 1}};\n\n    public static void main(String[] args) {\n        Scanner scanner = new Scanner(System.in);\n        while (true) {\n            String line = scanner.nextLine().trim();\n            if (line.equals(\"-1\")) {\n                break;\n            }\n            int[][] initialBoard = new int[5][5];\n            for (int i = 0; i < 5; i++) {\n                Arrays.fill(initialBoard[i], -1);\n            }\n            int p1 = Integer.parseInt(line);\n            initialBoard[0][2] = p1;\n            String[] parts = scanner.nextLine().split(\"\\\\s+\");\n            initialBoard[1][1] = Integer.parseInt(parts[0]);\n            initialBoard[1][2] = Integer.parseInt(parts[1]);\n            initialBoard[1][3] = Integer.parseInt(parts[2]);\n            parts = scanner.nextLine().split(\"\\\\s+\");\n            initialBoard[2][0] = Integer.parseInt(parts[0]);\n            initialBoard[2][1] = Integer.parseInt(parts[1]);\n            initialBoard[2][2] = Integer.parseInt(parts[2]);\n            initialBoard[2][3] = Integer.parseInt(parts[3]);\n            initialBoard[2][4] = Integer.parseInt(parts[4]);\n            parts = scanner.nextLine().split(\"\\\\s+\");\n            initialBoard[3][1] = Integer.parseInt(parts[0]);\n            initialBoard[3][2] = Integer.parseInt(parts[1]);\n            initialBoard[3][3] = Integer.parseInt(parts[2]);\n            line = scanner.nextLine().trim();\n            initialBoard[4][2] = Integer.parseInt(line);\n\n            int zero1Row = -1, zero1Col = -1, zero2Row = -1, zero2Col = -1;\n            for (int i = 0; i < 5; i++) {\n                for (int j = 0; j < 5; j++) {\n                    if (initialBoard[i][j] == 0) {\n                        if (zero1Row == -1) {\n                            zero1Row = i;\n                            zero1Col = j;\n                        } else {\n                            zero2Row = i;\n                            zero2Col = j;\n                        }\n                    }\n                }\n            }\n\n            int result = bfs(initialBoard, zero1Row, zero1Col, zero2Row, zero2Col);\n            System.out.println(result <= 20 ? result : \"NA\");\n        }\n    }\n\n    static int bfs(int[][] initialBoard, int zero1Row, int zero1Col, int zero2Row, int zero2Col) {\n        Queue<State> queue = new LinkedList<>();\n        Set<String> visited = new HashSet<>();\n        State initialState = new State(initialBoard, zero1Row, zero1Col, zero2Row, zero2Col, 0);\n        queue.add(initialState);\n        visited.add(initialState.key);\n\n        while (!queue.isEmpty()) {\n            State current = queue.poll();\n            if (isGoal(current.board)) {\n                return current.steps;\n            }\n            if (current.steps >= 20) {\n                continue;\n            }\n\n            for (int i = 0; i < 4; i++) {\n                int newRow = current.zero1Row + MOVES[i][0];\n                int newCol = current.zero1Col + MOVES[i][1];\n                if (isValid(newRow, newCol) && current.board[newRow][newCol] != -1) {\n                    int[][] newBoard = new int[5][5];\n                    for (int r = 0; r < 5; r++) {\n                        System.arraycopy(current.board[r], 0, newBoard[r], 0, 5);\n                    }\n                    newBoard[current.zero1Row][current.zero1Col] = newBoard[newRow][newCol];\n                    newBoard[newRow][newCol] = 0;\n                    State newState = new State(newBoard, newRow, newCol, current.zero2Row, current.zero2Col, current.steps + 1);\n                    if (!visited.contains(newState.key)) {\n                        visited.add(newState.key);\n                        queue.add(newState);\n                    }\n                }\n            }\n\n            for (int i = 0; i < 4; i++) {\n                int newRow = current.zero2Row + MOVES[i][0];\n                int newCol = current.zero2Col + MOVES[i][1];\n                if (isValid(newRow, newCol) && current.board[newRow][newCol] != -1) {\n                    int[][] newBoard = new int[5][5];\n                    for (int r = 0; r < 5; r++) {\n                        System.arraycopy(current.board[r], 0, newBoard[r], 0, 5);\n                    }\n                    newBoard[current.zero2Row][current.zero2Col] = newBoard[newRow][newCol];\n                    newBoard[newRow][newCol] = 0;\n                    State newState = new State(newBoard, current.zero1Row, current.zero1Col, newRow, newCol, current.steps + 1);\n                    if (!visited.contains(newState.key)) {\n                        visited.add(newState.key);\n                        queue.add(newState);\n                    }\n                }\n            }\n        }\n        return Integer.MAX_VALUE;\n    }\n\n    static boolean isValid(int row, int col) {\n        return row >= 0 && row < 5 && col >= 0 && col < 5;\n    }\n\n    static boolean isGoal(int[][] board) {\n        for (int i = 0; i < 5; i++) {\n            for (int j = 0; j < 5; j++) {\n                if (board[i][j] != GOAL[i][j]) {\n                    return false;\n                }\n            }\n        }\n        return true;\n    }\n}",
    "timestamp": "2025-08-05 18:38:26"
  },
  {
    "model": "gpt-4o",
    "prompt_type": "zero_shot",
    "language": "python",
    "code": "from collections import deque\n\ndef puzzle_to_string(puzzle):\n    return ','.join(map(str, puzzle))\n\ndef string_to_puzzle(string):\n    return list(map(int, string.split(',')))\n\ndef solve_puzzle(initial_puzzle):\n    target_puzzle = [1, 2, 3, 4, 5, 6, 7, 8, 9, 10, 11, 0, 0]\n    target_str = puzzle_to_string(target_puzzle)\n\n    visited = set()\n    queue = deque([(puzzle_to_string(initial_puzzle), 0)])\n\n    directions = [(-1, 0), (1, 0), (0, -1), (0, 1)]\n\n    def get_neighbors(state):\n        puzzle = string_to_puzzle(state)\n        empty_indices = [i for i, x in enumerate(puzzle) if x == 0]\n        neighbors = []\n\n        for empty_idx in empty_indices:\n            ei, ej = divmod(empty_idx, 3)\n\n            for di, dj in directions:\n                ni, nj = ei + di, ej + dj\n                if 0 <= ni < 4 and 0 <= nj < 3:\n                    new_idx = ni * 3 + nj\n                    puzzle[empty_idx], puzzle[new_idx] = puzzle[new_idx], puzzle[empty_idx]\n                    neighbors.append(puzzle_to_string(puzzle))\n                    puzzle[empty_idx], puzzle[new_idx] = puzzle[new_idx], puzzle[empty_idx]\n                    \n        return neighbors\n\n    while queue:\n        current, steps = queue.popleft()\n\n        if current == target_str:\n            return steps\n\n        if current not in visited:\n            visited.add(current)\n\n            for neighbor in get_neighbors(current):\n                if neighbor not in visited:\n                    queue.append((neighbor, steps + 1))\n\n    return 'NA'\n\ndef main():\n    import sys\n    input = sys.stdin.read\n    data = input().strip().split('\\n')\n    \n    idx = 0\n    results = []\n    while idx < len(data) and data[idx] != '-1':\n        puzzle = []\n        puzzle.append(int(data[idx]))\n        idx += 1\n        \n        puzzle.extend(map(int, data[idx].split()))\n        idx += 1\n\n        puzzle.extend(map(int, data[idx].split()))\n        idx += 1\n\n        puzzle.extend(map(int, data[idx].split()))\n        idx += 1\n\n        puzzle.append(int(data[idx]))\n        idx += 1\n        \n        result = solve_puzzle(puzzle)\n        if isinstance(result, int) and result > 20:\n            result = 'NA'\n        results.append(result)\n    \n    for result in results:\n        print(result)\n\nmain()",
    "timestamp": "2025-08-12 23:59:55"
  },
  {
    "model": "gpt-4o",
    "prompt_type": "zero_shot",
    "language": "java",
    "code": "import java.util.*;\n\npublic class ElevenPuzzle {\n    private static final String TARGET = \"12345678910110\";\n    private static final int[] DX = {1, -1, 0, 0};\n    private static final int[] DY = {0, 0, 1, -1};\n\n    public static void main(String[] args) {\n        Scanner scanner = new Scanner(System.in);\n        while (true) {\n            List<Integer> puzzleList = new ArrayList<>();\n            for (int i = 0; i < 4; i++) {\n                String line = scanner.nextLine();\n                if (line.equals(\"-1\")) {\n                    return;\n                }\n                String[] parts = line.split(\"\\\\s+\");\n                for (String part : parts) {\n                    puzzleList.add(Integer.parseInt(part));\n                }\n            }\n            System.out.println(solvePuzzle(puzzleList));\n        }\n    }\n\n    private static String solvePuzzle(List<Integer> puzzleList) {\n        StringBuilder initial = new StringBuilder();\n        for (int num : puzzleList) {\n            initial.append(num);\n        }\n        String startState = initial.toString();\n        if (startState.equals(TARGET)) {\n            return \"0\";\n        }\n\n        Queue<Node> queue = new LinkedList<>();\n        Set<String> visited = new HashSet<>();\n        queue.offer(new Node(startState, 0));\n        visited.add(startState);\n\n        while (!queue.isEmpty()) {\n            Node currentNode = queue.poll();\n            String currentState = currentNode.state;\n            int zeroIndex = currentState.indexOf('0');\n            int zeroRow = getRow(zeroIndex);\n            int zeroCol = getCol(zeroIndex);\n\n            for (int k = 0; k < 4; k++) {\n                int newRow = zeroRow + DX[k];\n                int newCol = zeroCol + DY[k];\n                if (isValid(newRow, newCol)) {\n                    int newZeroIndex = getIndex(newRow, newCol);\n                    String nextState = swap(currentState, zeroIndex, newZeroIndex);\n                    if (nextState.equals(TARGET)) {\n                        return String.valueOf(currentNode.steps + 1);\n                    }\n                    if (!visited.contains(nextState)) {\n                        visited.add(nextState);\n                        queue.offer(new Node(nextState, currentNode.steps + 1));\n                    }\n                }\n            }\n        }\n        return \"NA\";\n    }\n\n    private static int getIndex(int row, int col) {\n        int[] rowMap = {0, 1, 5, 9};\n        if (row == 1) {\n            return rowMap[row] + col;\n        } else if (row == 2) {\n            return rowMap[row] + col - 1;\n        }\n        return rowMap[row] + col - (row == 3 ? 3 : 0);\n    }\n\n    private static int getRow(int index) {\n        if (index < 1) return 0;\n        if (index < 5) return 1;\n        if (index < 9) return 2;\n        return 3;\n    }\n\n    private static int getCol(int index) {\n        if (index < 1) return index;\n        if (index < 5) return index - 1;\n        if (index < 9) return index - 5;\n        return index - 9;\n    }\n\n    private static boolean isValid(int row, int col) {\n        if (row == 0 && col == 0) return false;\n        if (row == 1) return col >= 0 && col <= 3;\n        if (row == 2) return col >= 1 && col <= 3;\n        return row == 3 && col >= 1 && col <= 2;\n    }\n\n    private static String swap(String state, int i, int j) {\n        char[] arr = state.toCharArray();\n        char temp = arr[i];\n        arr[i] = arr[j];\n        arr[j] = temp;\n        return new String(arr);\n    }\n\n    static class Node {\n        String state;\n        int steps;\n\n        Node(String state, int steps) {\n            this.state = state;\n            this.steps = steps;\n        }\n    }\n}",
    "timestamp": "2025-08-13 00:00:26"
  },
  {
    "model": "gpt-4o",
    "prompt_type": "zero_shot",
    "language": "c",
    "code": "#include <stdio.h>\n#include <string.h>\n#include <stdlib.h>\n\n#define SIZE 13\n#define INF 21\n\ntypedef struct {\n    int board[SIZE];\n    int empty1, empty2;\n} State;\n\nint goal[SIZE] = { 1, 2, 3, 4, 5, 6, 7, 8, 9, 10, 11, 0, 0 };\nint direction[9] = { -4, -3, -1, 1, 3, 4, 0 }; // possible moves\nint neighbors[SIZE][9] = {\n    { 3, 1, -1, -1, -1, -1, -1, -1, -1 }, // neighbors for position 0\n    { 4, 2, 0, -1, -1, -1, -1, -1, -1 }, // neighbors for position 1\n    { 5, 1, -1, -1, -1, -1, -1, -1, -1 }, // neighbors for position 2\n    { 0, 6, 4, -1, -1, -1, -1, -1, -1 }, // neighbors for position 3\n    { 1, 7, 5, 3, -1, -1, -1, -1, -1 }, // neighbors for position 4\n    { 2, 8, 4, -1, -1, -1, -1, -1, -1 }, // neighbors for position 5\n    { 3, 7, 9, -1, -1, -1, -1, -1, -1 }, // neighbors for position 6\n    { 4, 10, 8, 6, -1, -1, -1, -1, -1 }, // neighbors for position 7\n    { 5, 11, 7, -1, -1, -1, -1, -1, -1 }, // neighbors for position 8\n    { 6, 10, 12, -1, -1, -1, -1, -1, -1 }, // neighbors for position 9\n    { 7, 9, 11, -1, -1, -1, -1, -1, -1 }, // neighbors for position 10\n    { 8, 10, -1, -1, -1, -1, -1, -1, -1 }, // neighbors for position 11\n    { 9, -1, -1, -1, -1, -1, -1, -1, -1 } // neighbors for position 12\n};\n\nint visited[362880]; // factorial(9) for permutation states\n\nint factorial(int n) {\n    int result = 1;\n    for (int i = 2; i <= n; ++i) result *= i;\n    return result;\n}\n\nint permutationIndex(int *perm) {\n    int index = 0, factor, i, j;\n    bool used[SIZE] = { false };\n    for (i = 0; i < SIZE; ++i) {\n        factor = factorial(SIZE - 1 - i);\n        int count = 0;\n        for (j = 0; j < SIZE; ++j) {\n            if (used[j]) continue;\n            if (perm[i] == j) break;\n            ++count;\n        }\n        index += count * factor;\n        used[perm[i]] = true;\n    }\n    return index;\n}\n\nint bfs(State start) {\n    State queue[362880];\n    memset(visited, 0, sizeof(visited));\n    int front = 0, rear = 0;\n    queue[rear++] = start;\n    visited[permutationIndex(start.board)] = 1;\n\n    while (front < rear) {\n        State current = queue[front++];\n        if (memcmp(current.board, goal, sizeof(goal)) == 0) {\n            return visited[permutationIndex(current.board)] - 1;\n        }\n        int step = visited[permutationIndex(current.board)];\n        for (int i = 0; neighbors[current.empty1][i] != -1; ++i) {\n            int neighbor = neighbors[current.empty1][i];\n            State next = current;\n            next.board[current.empty1] = next.board[neighbor];\n            next.board[neighbor] = 0;\n            next.empty1 = neighbor;\n\n            int idx = permutationIndex(next.board);\n            if (!visited[idx] || visited[idx] > step + 1) {\n                visited[idx] = step + 1;\n                queue[rear++] = next;\n            }\n        }\n        for (int i = 0; neighbors[current.empty2][i] != -1; ++i) {\n            int neighbor = neighbors[current.empty2][i];\n            State next = current;\n            next.board[current.empty2] = next.board[neighbor];\n            next.board[neighbor] = 0;\n            next.empty2 = neighbor;\n\n            int idx = permutationIndex(next.board);\n            if (!visited[idx] || visited[idx] > step + 1) {\n                visited[idx] = step + 1;\n                queue[rear++] = next;\n            }\n        }\n    }\n\n    return INF;\n}\n\nint main() {\n    char line[SIZE * 3];\n    while (fgets(line, sizeof(line), stdin)) {\n        if (strcmp(line, \"-1\\n\") == 0) break;\n        State start;\n        int count = 0;\n        char *token = strtok(line, \" \");\n        while (token != NULL) {\n            start.board[count] = atoi(token);\n            if (start.board[count] == 0) {\n                if (count < 11) start.empty1 = count;\n                else start.empty2 = count;\n            }\n            token = strtok(NULL, \" \");\n            count++;\n        }\n        int result = bfs(start);\n        if (result > 20) printf(\"NA\\n\");\n        else printf(\"%d\\n\", result);\n    }\n    return 0;\n}",
    "timestamp": "2025-08-13 00:00:47"
  },
  {
    "model": "claude-3-5-haiku-20241022",
    "prompt_type": "zero_shot",
    "language": "python",
    "code": "from typing import List, Tuple\nfrom collections import deque\n\ndef solve_11_puzzle(initial_state: List[List[int]]) -> str:\n    # Flatten the state into a single list\n    initial_flat = [num for row in initial_state for num in row if num != 0]\n    goal_state = list(range(1, 12))\n    \n    # Find initial empty spaces\n    empty_spaces = [(i, j) for i in range(4) for j in range(len(initial_state[i])) if initial_state[i][j] == 0]\n    \n    # State representation: (flat board, empty spaces, moves)\n    start = (initial_flat, empty_spaces, 0)\n    \n    # BFS with visited set to track states\n    visited = set()\n    queue = deque([start])\n    \n    while queue:\n        curr_board, curr_empty, moves = queue.popleft()\n        \n        # Check if solved\n        if curr_board == goal_state:\n            return str(moves) if moves <= 20 else 'NA'\n        \n        # State key for visited tracking\n        state_key = (tuple(curr_board), tuple(curr_empty))\n        if state_key in visited:\n            continue\n        visited.add(state_key)\n        \n        # Try moving each number to empty spaces\n        for i, empty in enumerate(curr_empty):\n            for direction in [(0, 1), (0, -1), (1, 0), (-1, 0)]:\n                new_empty = (empty[0] + direction[0], empty[1] + direction[1])\n                \n                # Check if new empty space is valid\n                if (0 <= new_empty[0] < 4 and \n                    0 <= new_empty[1] < len(initial_state[new_empty[0]])):\n                    \n                    # Create new board and empty spaces\n                    new_board = curr_board.copy()\n                    new_empty_spaces = curr_empty.copy()\n                    \n                    # Find number at new empty space\n                    board_state = [row.copy() for row in initial_state]\n                    for r in range(4):\n                        for c in range(len(board_state[r])):\n                            if board_state[r][c] != 0:\n                                board_state[r][c] = new_board[board_state[r][c]-1]\n                    \n                    num_index = None\n                    for r in range(4):\n                        for c in range(len(board_state[r])):\n                            if (r, c) == new_empty and board_state[r][c] != 0:\n                                num_index = board_state[r][c] - 1\n                    \n                    if num_index is not None:\n                        # Swap number\n                        new_board[num_index], new_board[curr_board[num_index]-1] = \\\n                            new_board[curr_board[num_index]-1], new_board[num_index]\n                        \n                        # Update empty spaces\n                        new_empty_spaces[i] = new_empty\n                        \n                        # Add to queue\n                        queue.append((new_board, new_empty_spaces, moves + 1))\n    \n    return 'NA'\n\ndef main():\n    while True:\n        # Input first line\n        first_line = input().strip()\n        if first_line == '-1':\n            break\n        \n        # Parse input\n        state = [[int(x) for x in first_line.split()]]\n        \n        # Read next lines\n        for _ in range(3):\n            line = input().strip()\n            state.append([int(x) for x in line.split()])\n        \n        # Solve and print result\n        print(solve_11_puzzle(state))\n\nif __name__ == '__main__':\n    main()",
    "timestamp": "2025-08-13 00:01:09"
  },
  {
    "model": "deepseek-v3",
    "prompt_type": "zero_shot",
    "language": "python",
    "code": "import sys\nfrom collections import deque\n\ndef solve():\n    # Precompute the target state\n    target = (\n        (0,),\n        (1, 2, 3),\n        (4, 5, 6, 7, 8),\n        (9, 10, 11),\n        (0,)\n    )\n    \n    # Directions for moving the empty spaces (0s)\n    # The structure is like a grid with specific positions:\n    # The positions are:\n    # (0,0), \n    # (1,0), (1,1), (1,2),\n    # (2,0), (2,1), (2,2), (2,3), (2,4),\n    # (3,0), (3,1), (3,2),\n    # (4,0)\n    # The neighbors for each position are precomputed\n    neighbors = {\n        (0,0): [(1,0), (1,1)],\n        (1,0): [(0,0), (1,1), (2,0), (2,1)],\n        (1,1): [(0,0), (1,0), (1,2), (2,1), (2,2)],\n        (1,2): [(1,1), (2,2), (2,3)],\n        (2,0): [(1,0), (2,1), (3,0)],\n        (2,1): [(1,0), (1,1), (2,0), (2,2), (3,0), (3,1)],\n        (2,2): [(1,1), (1,2), (2,1), (2,3), (3,1), (3,2)],\n        (2,3): [(1,2), (2,2), (2,4), (3,2)],\n        (2,4): [(2,3), (3,2)],\n        (3,0): [(2,0), (2,1), (3,1), (4,0)],\n        (3,1): [(2,1), (2,2), (3,0), (3,2)],\n        (3,2): [(2,2), (2,3), (2,4), (3,1), (4,0)],\n        (4,0): [(3,0), (3,2)]\n    }\n    \n    def state_to_tuple(state):\n        return (\n            (state[0][0],),\n            (state[1][0], state[1][1], state[1][2]),\n            (state[2][0], state[2][1], state[2][2], state[2][3], state[2][4]),\n            (state[3][0], state[3][1], state[3][2]),\n            (state[4][0],)\n        )\n    \n    def tuple_to_state(t):\n        return [\n            [t[0][0]],\n            [t[1][0], t[1][1], t[1][2]],\n            [t[2][0], t[2][1], t[2][2], t[2][3], t[2][4]],\n            [t[3][0], t[3][1], t[3][2]],\n            [t[4][0]]\n        ]\n    \n    def get_zero_positions(state):\n        zeros = []\n        for i in range(len(state)):\n            row = state[i]\n            for j in range(len(row)):\n                if row[j] == 0:\n                    zeros.append((i, j))\n        return zeros\n    \n    def is_target(state):\n        current = state_to_tuple(state)\n        return current == target\n    \n    def bfs(initial_state):\n        visited = set()\n        queue = deque()\n        initial_tuple = state_to_tuple(initial_state)\n        visited.add(initial_tuple)\n        queue.append((initial_state, 0))\n        \n        while queue:\n            current_state, steps = queue.popleft()\n            if steps > 20:\n                return -1\n            if is_target(current_state):\n                return steps\n            zero_positions = get_zero_positions(current_state)\n            for z_row, z_col in zero_positions:\n                for n_row, n_col in neighbors[(z_row, z_col)]:\n                    if 0 <= n_row < len(current_state) and 0 <= n_col < len(current_state[n_row]):\n                        if current_state[n_row][n_col] != 0:\n                            # Create a new state by swapping\n                            new_state = [list(row) for row in current_state]\n                            new_state[z_row][z_col], new_state[n_row][n_col] = new_state[n_row][n_col], new_state[z_row][z_col]\n                            new_tuple = state_to_tuple(new_state)\n                            if new_tuple not in visited:\n                                visited.add(new_tuple)\n                                queue.append((new_state, steps + 1))\n        return -1\n    \n    # Read input\n    while True:\n        first_line = sys.stdin.readline().strip()\n        if first_line == '-1':\n            break\n        p1 = int(first_line)\n        p2, p3, p4 = map(int, sys.stdin.readline().split())\n        p5, p6, p7, p8, p9 = map(int, sys.stdin.readline().split())\n        p10, p11, p12 = map(int, sys.stdin.readline().split())\n        p13 = int(sys.stdin.readline().strip())\n        \n        initial_state = [\n            [p1],\n            [p2, p3, p4],\n            [p5, p6, p7, p8, p9],\n            [p10, p11, p12],\n            [p13]\n        ]\n        \n        steps = bfs(initial_state)\n        if steps == -1:\n            print(\"NA\")\n        else:\n            print(steps)\n\nsolve()",
    "timestamp": "2025-08-13 00:01:58"
  },
  {
    "model": "gpt-4o",
    "prompt_type": "zero_shot",
    "language": "c++",
    "code": "#include <bits/stdc++.h>\nusing namespace std;\n\nconst int MAX_STEPS = 20;\nconst string GOAL_STATE = \"12345678910110\";\nconst vector<vector<int>> moves = {\n    {1, 4}, {0, 2, 5}, {1, 3, 6}, {2, 7},\n    {0, 5, 8}, {1, 4, 6, 9}, {2, 5, 7, 10}, {3, 6, 11},\n    {4, 9}, {5, 8, 10}, {6, 9, 11}, {7, 10}\n};\n\nstruct PuzzleState {\n    string state;\n    int empty1, empty2;\n    int steps;\n};\n\nint solvePuzzle(const vector<int>& initialState) {\n    string startState;\n    int empty1 = -1, empty2 = -1;\n    for (int i = 0; i < 13; ++i) {\n        if (initialState[i] == 0 && empty1 == -1)\n            empty1 = i;\n        else if (initialState[i] == 0)\n            empty2 = i;\n        else\n            startState += to_string(initialState[i]);\n    }\n    \n    startState.insert(empty1, \" \");\n    startState.insert(empty2 + 1, \" \");\n    \n    queue<PuzzleState> q;\n    set<string> visited;\n    q.push({startState, empty1, empty2, 0});\n    visited.insert(startState);\n    \n    while (!q.empty()) {\n        auto current = q.front();\n        q.pop();\n        \n        if (current.state.substr(0, 11) == GOAL_STATE) {\n            return current.steps;\n        }\n        \n        if (current.steps >= MAX_STEPS) continue;\n        \n        for (int nei : moves[current.empty1]) {\n            string nextState = current.state;\n            swap(nextState[current.empty1], nextState[nei]);\n            if (visited.find(nextState) == visited.end()) {\n                visited.insert(nextState);\n                q.push({nextState, nei, current.empty2, current.steps + 1});\n            }\n        }\n        \n        for (int nei : moves[current.empty2]) {\n            string nextState = current.state;\n            swap(nextState[current.empty2], nextState[nei]);\n            if (visited.find(nextState) == visited.end()) {\n                visited.insert(nextState);\n                q.push({nextState, current.empty1, nei, current.steps + 1});\n            }\n        }\n    }\n\n    return -1; // If not solvable within MAX_STEPS\n}\n\nint main() {\n    string line;\n    while (true) {\n        vector<int> initialState(13);\n        cin >> initialState[0];\n        if (initialState[0] == -1) break;\n        for (int i = 1; i < 13; ++i) {\n            cin >> initialState[i];\n        }\n        \n        int result = solvePuzzle(initialState);\n        if (result == -1 || result > MAX_STEPS) {\n            cout << \"NA\" << endl;\n        } else {\n            cout << result << endl;\n        }\n    }\n    return 0;\n}",
    "timestamp": "2025-08-13 10:52:04"
  }
]